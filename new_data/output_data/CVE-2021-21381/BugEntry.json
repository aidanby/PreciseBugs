{"buggy_code": ["/*\n * Copyright \u00a9 2014-2019 Red Hat, Inc\n * Copyright \u00a9 2017 Endless Mobile, Inc.\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\t See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library. If not, see <http://www.gnu.org/licenses/>.\n *\n * Authors:\n *       Alexander Larsson <alexl@redhat.com>\n *       Philip Withnall <withnall@endlessm.com>\n *       Matthew Leeds <matthew.leeds@endlessm.com>\n */\n\n#include \"config.h\"\n\n#include <errno.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/file.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <utime.h>\n\n#include <glib/gi18n-lib.h>\n#include <glib/gstdio.h>\n\n#include <libxml/parser.h>\n#include <libxml/tree.h>\n\n#include <gio/gio.h>\n#include <gio/gunixsocketaddress.h>\n#include <ostree.h>\n\n#ifdef USE_SYSTEM_HELPER\n#include <polkit/polkit.h>\n#endif\n\n#include \"flatpak-appdata-private.h\"\n#include \"flatpak-dir-private.h\"\n#include \"flatpak-error.h\"\n#include \"flatpak-oci-registry-private.h\"\n#include \"flatpak-ref.h\"\n#include \"flatpak-run-private.h\"\n#include \"flatpak-utils-base-private.h\"\n#include \"flatpak-variant-private.h\"\n#include \"flatpak-variant-impl-private.h\"\n#include \"libglnx/libglnx.h\"\n\n#ifdef HAVE_LIBMALCONTENT\n#include <libmalcontent/malcontent.h>\n#include \"flatpak-parental-controls-private.h\"\n#endif\n\n#ifdef HAVE_LIBSYSTEMD\n#define SD_JOURNAL_SUPPRESS_LOCATION\n#include <systemd/sd-journal.h>\n#endif\n\n#define NO_SYSTEM_HELPER ((FlatpakSystemHelper *) (gpointer) 1)\n\n#define SUMMARY_CACHE_TIMEOUT_SEC (60 * 5)\n#define FILTER_MTIME_CHECK_TIMEOUT_MSEC 500\n\n#define SYSCONF_INSTALLATIONS_DIR \"installations.d\"\n#define SYSCONF_INSTALLATIONS_FILE_EXT \".conf\"\n#define SYSCONF_REMOTES_DIR \"remotes.d\"\n#define SYSCONF_REMOTES_FILE_EXT \".flatpakrepo\"\n\n#define SIDELOAD_REPOS_DIR_NAME \"sideload-repos\"\n\n#ifdef USE_SYSTEM_HELPER\n/* This uses a weird Auto prefix to avoid conflicts with later added polkit types.\n */\ntypedef PolkitAuthority           AutoPolkitAuthority;\ntypedef PolkitAuthorizationResult AutoPolkitAuthorizationResult;\ntypedef PolkitDetails             AutoPolkitDetails;\ntypedef PolkitSubject             AutoPolkitSubject;\n\nG_DEFINE_AUTOPTR_CLEANUP_FUNC (AutoPolkitAuthority, g_object_unref)\nG_DEFINE_AUTOPTR_CLEANUP_FUNC (AutoPolkitAuthorizationResult, g_object_unref)\nG_DEFINE_AUTOPTR_CLEANUP_FUNC (AutoPolkitDetails, g_object_unref)\nG_DEFINE_AUTOPTR_CLEANUP_FUNC (AutoPolkitSubject, g_object_unref)\n#endif\n\nstatic FlatpakOciRegistry *flatpak_dir_create_system_child_oci_registry (FlatpakDir   *self,\n                                                                         GLnxLockFile *file_lock,\n                                                                         const char   *token,\n                                                                         GError      **error);\n\nstatic OstreeRepo * flatpak_dir_create_child_repo (FlatpakDir   *self,\n                                                   GFile        *cache_dir,\n                                                   GLnxLockFile *file_lock,\n                                                   const char   *optional_commit,\n                                                   GError      **error);\nstatic OstreeRepo * flatpak_dir_create_system_child_repo (FlatpakDir   *self,\n                                                          GLnxLockFile *file_lock,\n                                                          const char   *optional_commit,\n                                                          GError      **error);\n\nstatic gboolean flatpak_dir_mirror_oci (FlatpakDir          *self,\n                                        FlatpakOciRegistry  *dst_registry,\n                                        FlatpakRemoteState  *state,\n                                        const char          *ref,\n                                        const char          *opt_rev,\n                                        const char          *skip_if_current_is,\n                                        const char          *token,\n                                        FlatpakProgress     *progress,\n                                        GCancellable        *cancellable,\n                                        GError             **error);\n\nstatic gboolean flatpak_dir_remote_fetch_summary (FlatpakDir   *self,\n                                                  const char   *name,\n                                                  gboolean      only_cached,\n                                                  GBytes      **out_summary,\n                                                  GBytes      **out_summary_sig,\n                                                  GCancellable *cancellable,\n                                                  GError      **error);\n\nstatic gboolean flatpak_dir_remote_fetch_summary_index (FlatpakDir   *self,\n                                                        const char   *name_or_uri,\n                                                        gboolean      only_cached,\n                                                        GBytes      **out_index,\n                                                        GBytes      **out_index_sig,\n                                                        GCancellable *cancellable,\n                                                        GError      **error);\n\nstatic gboolean flatpak_dir_remote_fetch_indexed_summary (FlatpakDir   *self,\n                                                          const char   *name_or_uri,\n                                                          const char   *arch,\n                                                          GVariant     *subsummary_info_v,\n                                                          gboolean      only_cached,\n                                                          GBytes      **out_summary,\n                                                          GCancellable *cancellable,\n                                                          GError      **error);\n\nstatic gboolean flatpak_dir_gc_cached_digested_summaries (FlatpakDir   *self,\n                                                          const char   *remote_name,\n                                                          const char   *dont_prune_file,\n                                                          GCancellable *cancellable,\n                                                          GError      **error);\n\nstatic gboolean flatpak_dir_cleanup_remote_for_url_change (FlatpakDir   *self,\n                                                           const char   *remote_name,\n                                                           const char   *url,\n                                                           GCancellable *cancellable,\n                                                           GError      **error);\n\nstatic gboolean flatpak_dir_lookup_remote_filter (FlatpakDir *self,\n                                                  const char *name,\n                                                  gboolean    force_load,\n                                                  char      **checksum_out,\n                                                  GRegex    **allow_regex,\n                                                  GRegex    **deny_regex,\n                                                  GError **error);\n\nstatic void ensure_soup_session (FlatpakDir *self);\n\nstatic void flatpak_dir_log (FlatpakDir *self,\n                             const char *file,\n                             int         line,\n                             const char *func,\n                             const char *source,\n                             const char *change,\n                             const char *remote,\n                             const char *ref,\n                             const char *commit,\n                             const char *old_commit,\n                             const char *url,\n                             const char *format,\n                             ...);\n\n#define flatpak_dir_log(self, change, remote, ref, commit, old_commit, url, format, ...) \\\n  (flatpak_dir_log) (self, __FILE__, __LINE__, __FUNCTION__, \\\n                     NULL, change, remote, ref, commit, old_commit, url, format, __VA_ARGS__)\n\nstatic GBytes *upgrade_deploy_data (GBytes             *deploy_data,\n                                    GFile              *deploy_dir,\n                                    FlatpakDecomposed  *ref,\n                                    OstreeRepo         *repo,\n                                    GCancellable       *cancellable,\n                                    GError            **error);\n\ntypedef struct\n{\n  GBytes *bytes;\n  GBytes *bytes_sig;\n  char   *name;\n  char   *url;\n  guint64 time;\n} CachedSummary;\n\ntypedef struct\n{\n  char                 *id;\n  char                 *display_name;\n  gint                  priority;\n  FlatpakDirStorageType storage_type;\n} DirExtraData;\n\ntypedef struct {\n  GFile *path;\n  GTimeVal mtime;\n  guint64 last_mtime_check;\n  char *checksum;\n  GRegex *allow;\n  GRegex *deny;\n} RemoteFilter;\n\nstruct FlatpakDir\n{\n  GObject          parent;\n\n  gboolean         user;\n  GFile           *basedir;\n  DirExtraData    *extra_data;\n  OstreeRepo      *repo;\n  GFile           *cache_dir;\n  gboolean         no_system_helper;\n  gboolean         no_interaction;\n  pid_t            source_pid;\n\n  GDBusConnection *system_helper_bus;\n\n  GHashTable      *summary_cache;\n\n  GHashTable      *remote_filters;\n\n  /* Config cache, protected by config_cache lock */\n  GRegex          *masked;\n  GRegex          *pinned;\n\n  SoupSession     *soup_session;\n};\n\nG_LOCK_DEFINE_STATIC (config_cache);\n\ntypedef struct\n{\n  GObjectClass parent_class;\n} FlatpakDirClass;\n\nstruct FlatpakDeploy\n{\n  GObject            parent;\n\n  FlatpakDecomposed *ref;\n  GFile             *dir;\n  GKeyFile          *metadata;\n  FlatpakContext    *system_overrides;\n  FlatpakContext    *user_overrides;\n  FlatpakContext    *system_app_overrides;\n  FlatpakContext    *user_app_overrides;\n  OstreeRepo        *repo;\n};\n\ntypedef struct\n{\n  GObjectClass parent_class;\n} FlatpakDeployClass;\n\nG_DEFINE_TYPE (FlatpakDir, flatpak_dir, G_TYPE_OBJECT)\nG_DEFINE_TYPE (FlatpakDeploy, flatpak_deploy, G_TYPE_OBJECT)\n\nenum {\n  PROP_0,\n\n  PROP_USER,\n  PROP_PATH\n};\n\n#define OSTREE_GIO_FAST_QUERYINFO (\"standard::name,standard::type,standard::size,standard::is-symlink,standard::symlink-target,\" \\\n                                   \"unix::device,unix::inode,unix::mode,unix::uid,unix::gid,unix::rdev\")\n\nstatic const char *\nget_config_dir_location (void)\n{\n  static gsize path = 0;\n\n  if (g_once_init_enter (&path))\n    {\n      gsize setup_value = 0;\n      const char *config_dir = g_getenv (\"FLATPAK_CONFIG_DIR\");\n      if (config_dir != NULL)\n        setup_value = (gsize) config_dir;\n      else\n        setup_value = (gsize) FLATPAK_CONFIGDIR;\n      g_once_init_leave (&path, setup_value);\n    }\n\n  return (const char *) path;\n}\n\nstatic const char *\nget_run_dir_location (void)\n{\n  static gsize path = 0;\n\n  if (g_once_init_enter (&path))\n    {\n      gsize setup_value = 0;\n      /* Note: $FLATPAK_RUN_DIR should only be set in the unit tests. At\n       * runtime, /run/flatpak is assumed by\n       * flatpak-create-sideload-symlinks.sh\n       */\n      const char *config_dir = g_getenv (\"FLATPAK_RUN_DIR\");\n      if (config_dir != NULL)\n        setup_value = (gsize) config_dir;\n      else\n        setup_value = (gsize) \"/run/flatpak\";\n      g_once_init_leave (&path, setup_value);\n    }\n\n  return (const char *) path;\n}\n\nstatic void\nflatpak_sideload_state_free (FlatpakSideloadState *sideload_state)\n{\n  g_object_unref (sideload_state->repo);\n  g_variant_unref (sideload_state->summary);\n  g_free (sideload_state);\n}\n\nstatic void\nvariant_maybe_unref (GVariant *variant)\n{\n  if (variant)\n    g_variant_unref (variant);\n}\n\nstatic FlatpakRemoteState *\nflatpak_remote_state_new (void)\n{\n  FlatpakRemoteState *state = g_new0 (FlatpakRemoteState, 1);\n\n  state->refcount = 1;\n  state->sideload_repos = g_ptr_array_new_with_free_func ((GDestroyNotify)flatpak_sideload_state_free);\n  state->subsummaries = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, (GDestroyNotify)variant_maybe_unref);\n  return state;\n}\n\nFlatpakRemoteState *\nflatpak_remote_state_ref (FlatpakRemoteState *remote_state)\n{\n  g_assert (remote_state->refcount > 0);\n  remote_state->refcount++;\n  return remote_state;\n}\n\nvoid\nflatpak_remote_state_unref (FlatpakRemoteState *remote_state)\n{\n  g_assert (remote_state->refcount > 0);\n  remote_state->refcount--;\n\n  if (remote_state->refcount == 0)\n    {\n      g_free (remote_state->remote_name);\n      g_free (remote_state->collection_id);\n      g_clear_pointer (&remote_state->index, g_variant_unref);\n      g_clear_pointer (&remote_state->index_ht, g_hash_table_unref);\n      g_clear_pointer (&remote_state->index_sig_bytes, g_bytes_unref);\n      g_clear_pointer (&remote_state->subsummaries, g_hash_table_unref);\n      g_clear_pointer (&remote_state->summary, g_variant_unref);\n      g_clear_pointer (&remote_state->summary_bytes, g_bytes_unref);\n      g_clear_pointer (&remote_state->summary_sig_bytes, g_bytes_unref);\n      g_clear_error (&remote_state->summary_fetch_error);\n      g_clear_pointer (&remote_state->allow_refs, g_regex_unref);\n      g_clear_pointer (&remote_state->deny_refs, g_regex_unref);\n      g_clear_pointer (&remote_state->sideload_repos, g_ptr_array_unref);\n\n      g_free (remote_state);\n    }\n}\n\nstatic gboolean\n_validate_summary_for_collection_id (GVariant    *summary_v,\n                                     const char  *collection_id,\n                                     GError     **error)\n{\n  VarSummaryRef summary;\n  summary = var_summary_from_gvariant (summary_v);\n\n  if (!flatpak_summary_find_ref_map (summary, collection_id, NULL))\n    return flatpak_fail_error (error, FLATPAK_ERROR_INVALID_DATA,\n                               _(\"Configured collection ID \u2018%s\u2019 not in summary file\"), collection_id);\n\n  return TRUE;\n}\n\nvoid\nflatpak_remote_state_add_sideload_repo (FlatpakRemoteState *self,\n                                        GFile *dir)\n{\n  g_autoptr(GFile) summary_path = NULL;\n  g_autoptr(GMappedFile) mfile = NULL;\n  g_autoptr(OstreeRepo) sideload_repo = NULL;\n\n  /* Sideloading only works if collection id is set */\n  if (self->collection_id == NULL)\n    return;\n\n  summary_path = g_file_get_child (dir, \"summary\");\n  sideload_repo = ostree_repo_new (dir);\n\n  mfile = g_mapped_file_new (flatpak_file_get_path_cached (summary_path), FALSE, NULL);\n  if (mfile != NULL && ostree_repo_open (sideload_repo, NULL, NULL))\n    {\n      g_autoptr(GError) local_error = NULL;\n      g_autoptr(GBytes) summary_bytes = g_mapped_file_get_bytes (mfile);\n      FlatpakSideloadState *ss = g_new0 (FlatpakSideloadState, 1);\n\n      ss->repo = g_steal_pointer (&sideload_repo);\n      ss->summary = g_variant_ref_sink (g_variant_new_from_bytes (OSTREE_SUMMARY_GVARIANT_FORMAT, summary_bytes, TRUE));\n\n      if (!_validate_summary_for_collection_id (ss->summary, self->collection_id, &local_error))\n        {\n          /* We expect to hit this code path when the repo is providing things\n           * from other remotes\n           */\n          g_debug (\"Sideload repo at path %s not valid for remote %s: %s\",\n                   flatpak_file_get_path_cached (dir), self->remote_name, local_error->message);\n          flatpak_sideload_state_free (ss);\n        }\n      else\n        {\n          g_ptr_array_add (self->sideload_repos, ss);\n          g_debug (\"Using sideloaded repo %s for remote %s\", flatpak_file_get_path_cached (dir), self->remote_name);\n        }\n    }\n}\n\ngboolean\nflatpak_remote_state_ensure_summary (FlatpakRemoteState *self,\n                                     GError            **error)\n{\n  if (self->index == NULL && self->summary == NULL)\n    return flatpak_fail_error (error, FLATPAK_ERROR_INVALID_DATA, _(\"Unable to load summary from remote %s: %s\"), self->remote_name,\n                               self->summary_fetch_error != NULL ? self->summary_fetch_error->message : \"unknown error\");\n\n  return TRUE;\n}\n\ngboolean\nflatpak_remote_state_ensure_subsummary (FlatpakRemoteState *self,\n                                        FlatpakDir         *dir,\n                                        const char         *arch,\n                                        gboolean            only_cached,\n                                        GCancellable       *cancellable,\n                                        GError            **error)\n{\n  GVariant *subsummary;\n  const char *alt_arch;\n  GVariant *subsummary_info_v;\n\n  g_autoptr(GBytes) bytes = NULL;\n\n  if (self->summary != NULL)\n    return TRUE; /* We have them all anyway */\n\n  if (self->index == NULL)\n    return TRUE; /* Don't fail unnecessarily in e.g. the sideload case */\n\n  if (g_hash_table_contains (self->subsummaries, arch))\n    return TRUE;\n\n  /* If i.e. we already loaded x86_64 subsummary (which has i386 refs),\n   * don't load i386 one */\n  alt_arch = flatpak_get_compat_arch_reverse (arch);\n  if (alt_arch != NULL &&\n      g_hash_table_contains (self->subsummaries, alt_arch))\n    return TRUE;\n\n  subsummary_info_v = g_hash_table_lookup (self->index_ht, arch);\n  if (subsummary_info_v == NULL)\n    return TRUE; /* No refs for this arch */\n\n  if (!flatpak_dir_remote_fetch_indexed_summary (dir, self->remote_name, arch, subsummary_info_v, only_cached,\n                                                 &bytes, cancellable, error))\n    return FALSE;\n\n  subsummary = g_variant_ref_sink (g_variant_new_from_bytes (OSTREE_SUMMARY_GVARIANT_FORMAT, bytes, FALSE));\n  g_hash_table_insert (self->subsummaries, g_strdup (arch), subsummary);\n\n  return TRUE;\n}\n\ngboolean\nflatpak_remote_state_allow_ref (FlatpakRemoteState *self,\n                                const char *ref)\n{\n  return flatpak_filters_allow_ref (self->allow_refs, self->deny_refs, ref);\n}\n\n\nstatic guint64\nget_timestamp_from_ref_info (VarRefInfoRef info)\n{\n  VarMetadataRef metadata = var_ref_info_get_metadata (info);\n  return GUINT64_FROM_BE(var_metadata_lookup_uint64 (metadata, OSTREE_COMMIT_TIMESTAMP, 0));\n }\n\n\nGFile *\nflatpak_remote_state_lookup_sideload_checksum (FlatpakRemoteState *self,\n                                               char               *checksum)\n{\n  for (int i = 0; i < self->sideload_repos->len; i++)\n    {\n      FlatpakSideloadState *ss = g_ptr_array_index (self->sideload_repos, i);\n      OstreeRepoCommitState commit_state;\n\n      if (ostree_repo_load_commit (ss->repo, checksum, NULL, &commit_state, NULL) &&\n          commit_state == OSTREE_REPO_COMMIT_STATE_NORMAL)\n        return g_object_ref (ostree_repo_get_path (ss->repo));\n    }\n\n  return NULL;\n}\n\nstatic gboolean\nflatpak_remote_state_resolve_sideloaded_ref (FlatpakRemoteState *self,\n                                             const char         *ref,\n                                             char              **out_checksum,\n                                             guint64            *out_timestamp,\n                                             VarRefInfoRef      *out_info,\n                                             FlatpakSideloadState  **out_sideload_state,\n                                             GError            **error)\n{\n  g_autofree char *latest_checksum = NULL;\n  guint64 latest_timestamp = 0;\n  FlatpakSideloadState *latest_ss = NULL;\n  VarRefInfoRef latest_sideload_info;\n\n  for (int i = 0; i < self->sideload_repos->len; i++)\n    {\n      FlatpakSideloadState *ss = g_ptr_array_index (self->sideload_repos, i);\n      g_autofree char *sideload_checksum = NULL;\n      VarRefInfoRef sideload_info;\n\n      if (flatpak_summary_lookup_ref (ss->summary, self->collection_id, ref, &sideload_checksum, &sideload_info))\n        {\n          guint64 timestamp = get_timestamp_from_ref_info (sideload_info);\n\n          if (latest_checksum == 0 || latest_timestamp < timestamp)\n            {\n              g_free (latest_checksum);\n              latest_checksum = g_steal_pointer (&sideload_checksum);\n              latest_timestamp = timestamp;\n              latest_sideload_info = sideload_info;\n              latest_ss = ss;\n            }\n        }\n    }\n\n  if (latest_checksum == NULL)\n    return flatpak_fail_error (error, FLATPAK_ERROR_REF_NOT_FOUND,\n                               _(\"No such ref '%s' in remote %s\"),\n                               ref, self->remote_name);\n\n  if (out_checksum)\n    *out_checksum = g_steal_pointer (&latest_checksum);\n  if (out_timestamp)\n    *out_timestamp = latest_timestamp;\n  if (out_info)\n    *out_info = latest_sideload_info;\n  if (out_sideload_state)\n    *out_sideload_state = latest_ss;\n\n  return TRUE;\n}\n\nstatic GVariant *\nget_summary_for_ref (FlatpakRemoteState *self,\n                     const char *ref)\n{\n  GVariant *summary = NULL;\n\n  if (self->index != NULL)\n    {\n      g_autofree char * arch = flatpak_get_arch_for_ref (ref);\n\n      if (arch != NULL)\n        summary = g_hash_table_lookup (self->subsummaries, arch);\n\n      if (summary == NULL)\n        {\n          const char *non_compat_arch = flatpak_get_compat_arch_reverse (arch);\n\n          if (non_compat_arch != NULL)\n            summary = g_hash_table_lookup (self->subsummaries, non_compat_arch);\n        }\n    }\n  else\n    summary = self->summary;\n\n  return summary;\n}\n\n/* Returns TRUE if the ref is found in the summary or cache.\n * out_checksum and out_variant are only set when the ref is found.\n */\ngboolean\nflatpak_remote_state_lookup_ref (FlatpakRemoteState *self,\n                                 const char         *ref,\n                                 char              **out_checksum,\n                                 guint64            *out_timestamp,\n                                 VarRefInfoRef      *out_info,\n                                 GFile             **out_sideload_path,\n                                 GError            **error)\n{\n  if (!flatpak_remote_state_allow_ref (self, ref))\n    {\n      return flatpak_fail_error (error, FLATPAK_ERROR_REF_NOT_FOUND,\n                                 _(\"No entry for %s in remote '%s' summary flatpak cache \"),\n                                 ref, self->remote_name);\n    }\n\n  /* If there is a summary we use it for metadata and for latest. We may later install from a sideloaded source though */\n  if (self->summary != NULL || self->index != NULL)\n    {\n      VarRefInfoRef info;\n      g_autofree char *checksum = NULL;\n      GVariant *summary;\n\n      summary = get_summary_for_ref (self, ref);\n      if (summary == NULL ||\n          !flatpak_summary_lookup_ref (summary, NULL, ref, &checksum, &info))\n        return flatpak_fail_error (error, FLATPAK_ERROR_REF_NOT_FOUND,\n                                   _(\"No such ref '%s' in remote %s\"),\n                                   ref, self->remote_name);\n\n      /* Even if its available in the summary we want to install it from a sideload repo if available */\n\n      if (out_sideload_path)\n        {\n          g_autoptr(GFile) found_sideload_path = NULL;\n\n          for (int i = 0; i < self->sideload_repos->len; i++)\n            {\n              FlatpakSideloadState *ss = g_ptr_array_index (self->sideload_repos, i);\n              OstreeRepoCommitState commit_state;\n\n              if (ostree_repo_load_commit (ss->repo, checksum, NULL, &commit_state, NULL) &&\n                  commit_state == OSTREE_REPO_COMMIT_STATE_NORMAL)\n                {\n                  found_sideload_path = g_object_ref (ostree_repo_get_path (ss->repo));\n                  break;\n                }\n            }\n\n          *out_sideload_path = g_steal_pointer (&found_sideload_path);\n        }\n\n      if (out_info)\n        *out_info = info;\n      if (out_checksum)\n        *out_checksum = g_steal_pointer (&checksum);\n      if (out_timestamp)\n        *out_timestamp = get_timestamp_from_ref_info (info);\n    }\n  else\n    {\n      FlatpakSideloadState *ss = NULL;\n\n      if (!flatpak_remote_state_resolve_sideloaded_ref (self, ref, out_checksum, out_timestamp, out_info, &ss, error))\n        return FALSE;\n\n      if (out_sideload_path)\n        *out_sideload_path = g_object_ref (ostree_repo_get_path (ss->repo));\n    }\n\n  return TRUE;\n}\n\nGPtrArray *\nflatpak_remote_state_match_subrefs (FlatpakRemoteState *self,\n                                    FlatpakDecomposed *ref)\n{\n  GVariant *summary;\n\n  if (self->summary == NULL && self->index == NULL)\n    {\n      g_debug (\"flatpak_remote_state_match_subrefs with no summary\");\n      return g_ptr_array_new_with_free_func ((GDestroyNotify)flatpak_decomposed_unref);\n    }\n\n  summary = get_summary_for_ref (self, flatpak_decomposed_get_ref (ref));\n  if (summary == NULL)\n    return g_ptr_array_new_with_free_func ((GDestroyNotify)flatpak_decomposed_unref);\n\n  return flatpak_summary_match_subrefs (summary, NULL, ref);\n}\n\nstatic VarMetadataRef\nflatpak_remote_state_get_main_metadata (FlatpakRemoteState *self)\n{\n  VarSummaryRef summary;\n  VarSummaryIndexRef index;\n  VarMetadataRef meta;\n\n  if (self->index)\n    {\n      index = var_summary_index_from_gvariant (self->index);\n      meta = var_summary_index_get_metadata (index);\n    }\n  else if (self->summary)\n    {\n      summary = var_summary_from_gvariant (self->summary);\n      meta = var_summary_get_metadata (summary);\n    }\n  else\n    g_assert_not_reached ();\n\n  return meta;\n}\n\n\n/* 0 if not specified */\nstatic guint32\nflatpak_remote_state_get_cache_version (FlatpakRemoteState *self)\n{\n  VarMetadataRef meta;\n\n  if (!flatpak_remote_state_ensure_summary (self, NULL))\n    return 0;\n\n  meta = flatpak_remote_state_get_main_metadata (self);\n  return GUINT32_FROM_LE (var_metadata_lookup_uint32 (meta, \"xa.cache-version\", 0));\n}\n\ngboolean\nflatpak_remote_state_lookup_cache (FlatpakRemoteState *self,\n                                   const char         *ref,\n                                   guint64            *out_download_size,\n                                   guint64            *out_installed_size,\n                                   const char        **out_metadata,\n                                   GError            **error)\n{\n  VarCacheDataRef cache_data;\n  VarMetadataRef meta;\n  VarSummaryRef summary;\n  guint32 summary_version;\n  GVariant *summary_v;\n\n  if (!flatpak_remote_state_ensure_summary (self, error))\n    return FALSE;\n\n  summary_v = get_summary_for_ref (self, ref);\n  if (summary_v == NULL)\n    return flatpak_fail_error (error, FLATPAK_ERROR_REF_NOT_FOUND,\n                               _(\"No entry for %s in remote '%s' summary flatpak cache \"),\n                               ref, self->remote_name);\n\n\n  summary = var_summary_from_gvariant (summary_v);\n  meta = var_summary_get_metadata (summary);\n\n  summary_version = GUINT32_FROM_LE (var_metadata_lookup_uint32 (meta, \"xa.summary-version\", 0));\n\n  if (summary_version == 0)\n    {\n      VarCacheRef cache;\n      gsize pos;\n      VarVariantRef cache_vv;\n      VarVariantRef cache_v;\n\n      if (!var_metadata_lookup (meta, \"xa.cache\", NULL, &cache_vv))\n        {\n          flatpak_fail_error (error, FLATPAK_ERROR_INVALID_DATA, _(\"No summary or Flatpak cache available for remote %s\"),\n                              self->remote_name);\n          return FALSE;\n        }\n\n      /* For stupid historical reasons the xa.cache is double-wrapped in a variant */\n      cache_v = var_variant_from_variant (cache_vv);\n      cache = var_cache_from_variant (cache_v);\n\n      if (!var_cache_lookup (cache, ref, &pos, &cache_data))\n        return flatpak_fail_error (error, FLATPAK_ERROR_REF_NOT_FOUND,\n                                   _(\"No entry for %s in remote '%s' summary flatpak cache \"),\n                                   ref, self->remote_name);\n    }\n  else if (summary_version == 1)\n    {\n      VarRefMapRef ref_map = var_summary_get_ref_map (summary);\n      VarRefInfoRef info;\n      VarMetadataRef commit_metadata;\n      VarVariantRef cache_data_v;\n\n      if (!flatpak_var_ref_map_lookup_ref (ref_map, ref, &info))\n        return flatpak_fail_error (error, FLATPAK_ERROR_REF_NOT_FOUND,\n                                   _(\"No entry for %s in remote '%s' summary cache \"),\n                                   ref, self->remote_name);\n\n      commit_metadata = var_ref_info_get_metadata (info);\n      if (!var_metadata_lookup (commit_metadata, \"xa.data\", NULL, &cache_data_v))\n        return flatpak_fail_error (error, FLATPAK_ERROR_INVALID_DATA, _(\"Missing xa.data in summary for remote %s\"),\n                                   self->remote_name);\n      cache_data = var_cache_data_from_variant (cache_data_v);\n    }\n  else\n    {\n      flatpak_fail_error (error, FLATPAK_ERROR_INVALID_DATA, _(\"Unsupported summary version %d for remote %s\"),\n                          summary_version, self->remote_name);\n      return FALSE;\n    }\n\n  if (out_installed_size)\n    *out_installed_size = var_cache_data_get_installed_size (cache_data);\n\n  if (out_download_size)\n    *out_download_size = var_cache_data_get_download_size (cache_data);\n\n  if (out_metadata)\n    *out_metadata = var_cache_data_get_metadata (cache_data);\n\n  return TRUE;\n}\n\ngboolean\nflatpak_remote_state_load_data (FlatpakRemoteState *self,\n                                const char         *ref,\n                                guint64            *out_download_size,\n                                guint64            *out_installed_size,\n                                char              **out_metadata,\n                                GError            **error)\n{\n  if (self->summary || self->index)\n    {\n      const char *metadata = NULL;\n      if (!flatpak_remote_state_lookup_cache (self, ref, out_download_size, out_installed_size, &metadata, error))\n        return FALSE;\n\n      if (out_metadata)\n        *out_metadata = g_strdup (metadata);\n    }\n  else\n    {\n      /* Look up from sideload */\n      g_autofree char *checksum = NULL;\n      guint64 timestamp;\n      VarRefInfoRef info;\n      FlatpakSideloadState *ss = NULL;\n      g_autoptr(GVariant) commit_data = NULL;\n      g_autoptr(GVariant) commit_metadata = NULL;\n      const char *xa_metadata = NULL;\n      guint64 download_size = 0;\n      guint64 installed_size = 0;\n\n      /* Use sideload refs if any */\n\n      if (!flatpak_remote_state_resolve_sideloaded_ref (self, ref, &checksum, &timestamp,\n                                                        &info, &ss, error))\n        return FALSE;\n\n      if (!ostree_repo_load_commit (ss->repo, checksum, &commit_data, NULL, error))\n        return FALSE;\n\n      commit_metadata = g_variant_get_child_value (commit_data, 0);\n      g_variant_lookup (commit_metadata, \"xa.metadata\", \"&s\", &xa_metadata);\n      if (xa_metadata == NULL)\n        return flatpak_fail (error, \"No xa.metadata in sideload commit %s ref %s\", checksum, ref);\n\n      if (g_variant_lookup (commit_metadata, \"xa.download-size\", \"t\", &download_size))\n        download_size = GUINT64_FROM_BE (download_size);\n      if (g_variant_lookup (commit_metadata, \"xa.installed-size\", \"t\", &installed_size))\n        installed_size = GUINT64_FROM_BE (installed_size);\n\n      if (out_installed_size)\n        *out_installed_size = installed_size;\n\n      if (out_download_size)\n        *out_download_size = download_size;\n\n      if (out_metadata)\n        *out_metadata = g_strdup (xa_metadata);\n    }\n  return TRUE;\n}\n\nstatic char *\nlookup_oci_registry_uri_from_summary (GVariant *summary,\n                                      GError  **error)\n{\n  g_autoptr(GVariant) extensions = g_variant_get_child_value (summary, 1);\n  g_autofree char *registry_uri = NULL;\n\n  if (!g_variant_lookup (extensions, \"xa.oci-registry-uri\", \"s\", &registry_uri))\n    {\n      flatpak_fail_error (error, FLATPAK_ERROR_INVALID_DATA, _(\"Remote OCI index has no registry uri\"));\n      return NULL;\n    }\n\n  return g_steal_pointer (&registry_uri);\n}\n\nstatic FlatpakOciRegistry *\nflatpak_remote_state_new_oci_registry (FlatpakRemoteState *self,\n                                       const char   *token,\n                                       GCancellable *cancellable,\n                                       GError      **error)\n{\n  g_autofree char *registry_uri = NULL;\n  g_autoptr(FlatpakOciRegistry) registry = NULL;\n\n  if (!flatpak_remote_state_ensure_summary (self, error))\n    return NULL;\n\n  registry_uri = lookup_oci_registry_uri_from_summary (self->summary, error);\n  if (registry_uri == NULL)\n    return NULL;\n\n  registry = flatpak_oci_registry_new (registry_uri, FALSE, -1, NULL, error);\n  if (registry == NULL)\n    return NULL;\n\n  flatpak_oci_registry_set_token (registry, token);\n\n  return g_steal_pointer (&registry);\n}\n\nstatic GVariant *\nflatpak_remote_state_fetch_commit_object_oci (FlatpakRemoteState *self,\n                                              FlatpakDir   *dir,\n                                              const char   *ref,\n                                              const char   *checksum,\n                                              const char   *token,\n                                              GCancellable *cancellable,\n                                              GError      **error)\n{\n  g_autoptr(FlatpakOciRegistry) registry = NULL;\n  g_autoptr(FlatpakOciVersioned) versioned = NULL;\n  g_autoptr(FlatpakOciImage) image_config = NULL;\n  g_autofree char *oci_digest = NULL;\n  g_autofree char *latest_rev = NULL;\n  VarRefInfoRef latest_rev_info;\n  VarMetadataRef metadata;\n  const char *oci_repository = NULL;\n  GHashTable *labels;\n  g_autofree char *subject = NULL;\n  g_autofree char *body = NULL;\n  g_autofree char *manifest_ref = NULL;\n  g_autofree char *parent = NULL;\n  guint64 timestamp = 0;\n  g_autoptr(GVariantBuilder) metadata_builder = g_variant_builder_new (G_VARIANT_TYPE (\"a{sv}\"));\n  g_autoptr(GVariant) metadata_v = NULL;\n\n  registry = flatpak_remote_state_new_oci_registry (self, token, cancellable, error);\n  if (registry == NULL)\n    return NULL;\n\n  /* We extract the rev info from the latest, even if we don't use the latest digest, assuming refs don't move */\n  if (!flatpak_remote_state_lookup_ref (self, ref, &latest_rev, NULL, &latest_rev_info, NULL, error))\n    return NULL;\n\n  if (latest_rev == NULL)\n    {\n      flatpak_fail_error (error, FLATPAK_ERROR_REF_NOT_FOUND,\n                          _(\"Couldn't find ref %s in remote %s\"),\n                          ref, self->remote_name);\n      return NULL;\n    }\n\n  metadata = var_ref_info_get_metadata (latest_rev_info);\n  oci_repository = var_metadata_lookup_string (metadata, \"xa.oci-repository\", NULL);\n\n  oci_digest = g_strconcat (\"sha256:\", checksum, NULL);\n\n  versioned = flatpak_oci_registry_load_versioned (registry, oci_repository, oci_digest,\n                                                   NULL, NULL, cancellable, error);\n  if (versioned == NULL)\n    return NULL;\n\n  if (!FLATPAK_IS_OCI_MANIFEST (versioned))\n    {\n      flatpak_fail_error (error, FLATPAK_ERROR_INVALID_DATA, _(\"Image is not a manifest\"));\n      return NULL;\n    }\n\n  image_config = flatpak_oci_registry_load_image_config (registry, oci_repository,\n                                                         FLATPAK_OCI_MANIFEST (versioned)->config.digest,\n                                                         (const char **)FLATPAK_OCI_MANIFEST (versioned)->config.urls,\n                                                         NULL, cancellable, error);\n  if (image_config == NULL)\n    return NULL;\n\n  labels = flatpak_oci_image_get_labels (image_config);\n  if (labels)\n    flatpak_oci_parse_commit_labels (labels, &timestamp,\n                                     &subject, &body,\n                                     &manifest_ref, NULL, &parent,\n                                     metadata_builder);\n\n\n  if (g_strcmp0 (manifest_ref, ref) != 0)\n    {\n      flatpak_fail_error (error, FLATPAK_ERROR_INVALID_DATA, _(\"Commit has no requested ref \u2018%s\u2019 in ref binding metadata\"),  ref);\n      return NULL;\n    }\n\n  metadata_v = g_variant_ref_sink (g_variant_builder_end (metadata_builder));\n\n  /* This isn't going to be exactly the same as the reconstructed one from the pull, because we don't have the contents, but its useful to get metadata */\n  return\n    g_variant_ref_sink (g_variant_new (\"(@a{sv}@ay@a(say)sst@ay@ay)\",\n                                       metadata_v,\n                                       parent ? ostree_checksum_to_bytes_v (parent) :  g_variant_new_from_data (G_VARIANT_TYPE (\"ay\"), NULL, 0, FALSE, NULL, NULL),\n                                       g_variant_new_array (G_VARIANT_TYPE (\"(say)\"), NULL, 0),\n                                       subject, body,\n                                       GUINT64_TO_BE (timestamp),\n                                       ostree_checksum_to_bytes_v (\"0000000000000000000000000000000000000000000000000000000000000000\"),\n                                       ostree_checksum_to_bytes_v (\"0000000000000000000000000000000000000000000000000000000000000000\")));\n}\n\nstatic GVariant *\nflatpak_remote_state_fetch_commit_object (FlatpakRemoteState *self,\n                                          FlatpakDir   *dir,\n                                          const char   *ref,\n                                          const char   *checksum,\n                                          const char   *token,\n                                          GCancellable *cancellable,\n                                          GError      **error)\n{\n  g_autofree char *base_url = NULL;\n  g_autofree char *object_url = NULL;\n  g_autofree char *part1 = NULL;\n  g_autofree char *part2 = NULL;\n  g_autoptr(GBytes) bytes = NULL;\n  g_autoptr(GVariant) commit_data = NULL;\n  g_autoptr(GVariant) commit_metadata = NULL;\n\n  if (!ostree_repo_remote_get_url (dir->repo, self->remote_name, &base_url, error))\n    return NULL;\n\n  ensure_soup_session (dir);\n\n  part1 = g_strndup (checksum, 2);\n  part2 = g_strdup_printf (\"%s.commit\", checksum + 2);\n\n  object_url = g_build_filename (base_url, \"objects\", part1, part2, NULL);\n\n  bytes = flatpak_load_uri (dir->soup_session, object_url, 0, token,\n                            NULL, NULL, NULL,\n                            cancellable, error);\n  if (bytes == NULL)\n    return NULL;\n\n  commit_data = g_variant_ref_sink (g_variant_new_from_bytes (OSTREE_COMMIT_GVARIANT_FORMAT,\n                                                              bytes, FALSE));\n\n  /* We downloaded this without validating the signature, so we do some basic verification\n     of it. However, the signature will be checked when the download is done, and the final\n     metadata is compared to what we got here, so its pretty ok to use it for resolving\n     the transaction op. However, we do some basic checks. */\n  if (!ostree_validate_structureof_commit (commit_data, error))\n    return NULL;\n\n  commit_metadata = g_variant_get_child_value (commit_data, 0);\n  if (ref != NULL)\n    {\n      const char *xa_ref = NULL;\n      const char *collection_binding = NULL;\n      g_autofree const char **commit_refs = NULL;\n\n      if ((g_variant_lookup (commit_metadata, \"xa.ref\", \"&s\", &xa_ref) &&\n           g_strcmp0 (xa_ref, ref) != 0) ||\n          (g_variant_lookup (commit_metadata, OSTREE_COMMIT_META_KEY_REF_BINDING, \"^a&s\", &commit_refs) &&\n           !g_strv_contains ((const char * const *) commit_refs, ref)))\n        {\n          flatpak_fail_error (error, FLATPAK_ERROR_INVALID_DATA, _(\"Commit has no requested ref \u2018%s\u2019 in ref binding metadata\"),  ref);\n          return NULL;\n        }\n\n      /* Check that the locally configured collection ID is correct by looking\n       * for it in the commit metadata */\n      if (self->collection_id != NULL &&\n          (!g_variant_lookup (commit_metadata, OSTREE_COMMIT_META_KEY_COLLECTION_BINDING, \"&s\", &collection_binding) ||\n           g_strcmp0 (self->collection_id, collection_binding) != 0))\n        {\n          g_autoptr(GVariantIter) collection_refs_iter = NULL;\n          gboolean found_in_collection_refs_binding = FALSE;\n          /* Note: the OSTREE_COMMIT_META_... define for this is not yet merged\n           * in https://github.com/ostreedev/ostree/pull/1805 */\n          if (g_variant_lookup (commit_metadata, \"ostree.collection-refs-binding\", \"a(ss)\", &collection_refs_iter))\n            {\n              const gchar *crb_collection_id, *crb_ref_name;\n              while (g_variant_iter_loop (collection_refs_iter, \"(&s&s)\", &crb_collection_id, &crb_ref_name))\n                {\n                  if (g_strcmp0 (self->collection_id, crb_collection_id) == 0 &&\n                      g_strcmp0 (ref, crb_ref_name) == 0)\n                    {\n                      found_in_collection_refs_binding = TRUE;\n                      break;\n                    }\n                }\n            }\n\n          if (!found_in_collection_refs_binding)\n            {\n              flatpak_fail_error (error, FLATPAK_ERROR_INVALID_DATA,\n                                  _(\"Configured collection ID \u2018%s\u2019 not in binding metadata\"),\n                                  self->collection_id);\n              return NULL;\n            }\n        }\n    }\n\n  return g_steal_pointer (&commit_data);\n}\n\n\n/* Tries to load the specified commit object that we resolved from\n   this remote.  This either comes from the already available local\n   repo, or from one of the sideloading repos, and if not available we\n   download it from the actual remote. */\nGVariant *\nflatpak_remote_state_load_ref_commit (FlatpakRemoteState *self,\n                                      FlatpakDir         *dir,\n                                      const char         *ref,\n                                      const char         *opt_commit,\n                                      const char         *token,\n                                      char              **out_commit,\n                                      GCancellable       *cancellable,\n                                      GError            **error)\n{\n  g_autoptr(GVariant) commit_data = NULL;\n  g_autofree char *commit = NULL;\n\n  if (opt_commit == NULL)\n    {\n      if (!flatpak_remote_state_lookup_ref (self, ref, &commit, NULL, NULL, NULL, error))\n        return NULL;\n\n      if (commit == NULL)\n        {\n          flatpak_fail_error (error, FLATPAK_ERROR_REF_NOT_FOUND,\n                              _(\"Couldn't find latest checksum for ref %s in remote %s\"),\n                              ref, self->remote_name);\n          return NULL;\n        }\n    }\n  else\n    commit = g_strdup (opt_commit);\n\n  /* First try local availability */\n  if (ostree_repo_load_commit (dir->repo, commit, &commit_data, NULL, NULL))\n    goto out;\n\n  for (int i = 0; i < self->sideload_repos->len; i++)\n    {\n      FlatpakSideloadState *ss = g_ptr_array_index (self->sideload_repos, i);\n\n      if (ostree_repo_load_commit (ss->repo, commit, &commit_data, NULL, NULL))\n        goto out;\n    }\n\n  if (flatpak_dir_get_remote_oci (dir, self->remote_name))\n    commit_data = flatpak_remote_state_fetch_commit_object_oci (self, dir, ref, commit, token,\n                                                                cancellable, error);\n  else\n    commit_data = flatpak_remote_state_fetch_commit_object (self, dir, ref, commit, token,\n                                                            cancellable, error);\n\nout:\n  if (out_commit)\n    *out_commit = g_steal_pointer (&commit);\n\n  return g_steal_pointer (&commit_data);\n}\n\n\ngboolean\nflatpak_remote_state_lookup_sparse_cache (FlatpakRemoteState *self,\n                                          const char         *ref,\n                                          VarMetadataRef     *out_metadata,\n                                          GError            **error)\n{\n  VarSummaryRef summary;\n  VarMetadataRef meta;\n  VarVariantRef sparse_cache_v;\n  guint32 summary_version;\n  GVariant *summary_v;\n\n  if (!flatpak_remote_state_ensure_summary (self, error))\n    return FALSE;\n\n  summary_v = get_summary_for_ref (self, ref);\n  if (summary_v == NULL)\n    return flatpak_fail_error (error, FLATPAK_ERROR_REF_NOT_FOUND,\n                             _(\"No entry for %s in remote summary flatpak sparse cache \"), ref);\n\n  summary = var_summary_from_gvariant (summary_v);\n  meta = var_summary_get_metadata (summary);\n\n  summary_version = GUINT32_FROM_LE (var_metadata_lookup_uint32 (meta, \"xa.summary-version\", 0));\n\n  if (summary_version == 0)\n    {\n      if (var_metadata_lookup (meta, \"xa.sparse-cache\", NULL, &sparse_cache_v))\n        {\n          VarSparseCacheRef sparse_cache = var_sparse_cache_from_variant (sparse_cache_v);\n          if (var_sparse_cache_lookup (sparse_cache, ref, NULL, out_metadata))\n            return TRUE;\n        }\n    }\n  else if (summary_version == 1)\n    {\n      VarRefMapRef ref_map = var_summary_get_ref_map (summary);\n      VarRefInfoRef info;\n\n      if (flatpak_var_ref_map_lookup_ref (ref_map, ref, &info))\n        {\n          *out_metadata = var_ref_info_get_metadata (info);\n          return TRUE;\n        }\n    }\n  else\n    {\n      flatpak_fail_error (error, FLATPAK_ERROR_INVALID_DATA, _(\"Unsupported summary version %d for remote %s\"),\n                          summary_version, self->remote_name);\n      return FALSE;\n    }\n\n  return flatpak_fail_error (error, FLATPAK_ERROR_REF_NOT_FOUND,\n                             _(\"No entry for %s in remote summary flatpak sparse cache \"), ref);\n}\n\nstatic DirExtraData *\ndir_extra_data_new (const char           *id,\n                    const char           *display_name,\n                    gint                  priority,\n                    FlatpakDirStorageType type)\n{\n  DirExtraData *dir_extra_data = g_new0 (DirExtraData, 1);\n\n  dir_extra_data->id = g_strdup (id);\n  dir_extra_data->display_name = g_strdup (display_name);\n  dir_extra_data->priority = priority;\n  dir_extra_data->storage_type = type;\n\n  return dir_extra_data;\n}\n\nstatic DirExtraData *\ndir_extra_data_clone (DirExtraData *extra_data)\n{\n  if (extra_data != NULL)\n    return dir_extra_data_new (extra_data->id,\n                               extra_data->display_name,\n                               extra_data->priority,\n                               extra_data->storage_type);\n  return NULL;\n}\n\nstatic void\ndir_extra_data_free (DirExtraData *dir_extra_data)\n{\n  g_free (dir_extra_data->id);\n  g_free (dir_extra_data->display_name);\n  g_free (dir_extra_data);\n}\n\nG_DEFINE_AUTOPTR_CLEANUP_FUNC (DirExtraData, dir_extra_data_free);\n\nstatic GVariant *\nvariant_new_ay_bytes (GBytes *bytes)\n{\n  gsize size;\n  gconstpointer data;\n\n  data = g_bytes_get_data (bytes, &size);\n  g_bytes_ref (bytes);\n  return g_variant_ref_sink (g_variant_new_from_data (G_VARIANT_TYPE (\"ay\"), data, size,\n                                                      TRUE, (GDestroyNotify) g_bytes_unref, bytes));\n}\n\nstatic void\nflatpak_deploy_finalize (GObject *object)\n{\n  FlatpakDeploy *self = FLATPAK_DEPLOY (object);\n\n  g_clear_pointer (&self->ref, flatpak_decomposed_unref);\n  g_clear_object (&self->dir);\n  g_clear_pointer (&self->metadata, g_key_file_unref);\n  g_clear_pointer (&self->system_overrides, flatpak_context_free);\n  g_clear_pointer (&self->user_overrides, flatpak_context_free);\n  g_clear_pointer (&self->system_app_overrides, flatpak_context_free);\n  g_clear_pointer (&self->user_app_overrides, flatpak_context_free);\n  g_clear_object (&self->repo);\n\n  G_OBJECT_CLASS (flatpak_deploy_parent_class)->finalize (object);\n}\n\nstatic void\nflatpak_deploy_class_init (FlatpakDeployClass *klass)\n{\n  GObjectClass *object_class = G_OBJECT_CLASS (klass);\n\n  object_class->finalize = flatpak_deploy_finalize;\n}\n\nstatic void\nflatpak_deploy_init (FlatpakDeploy *self)\n{\n}\n\nGFile *\nflatpak_deploy_get_dir (FlatpakDeploy *deploy)\n{\n  return g_object_ref (deploy->dir);\n}\n\nGBytes *\nflatpak_load_deploy_data (GFile             *deploy_dir,\n                          FlatpakDecomposed *ref,\n                          OstreeRepo        *repo,\n                          int                required_version,\n                          GCancellable      *cancellable,\n                          GError           **error)\n{\n  g_autoptr(GFile) data_file = NULL;\n  g_autoptr(GBytes) deploy_data = NULL;\n  gchar *contents;\n  gsize len;\n\n  data_file = g_file_get_child (deploy_dir, \"deploy\");\n\n  if (!g_file_load_contents (data_file, cancellable, &contents, &len, NULL, error))\n    return NULL;\n\n  deploy_data = g_bytes_new_take (contents, len);\n\n  if (flatpak_deploy_data_get_version (deploy_data) < required_version)\n    return upgrade_deploy_data (deploy_data, deploy_dir, ref, repo, cancellable, error);\n\n  return g_steal_pointer (&deploy_data);\n}\n\n\nGBytes *\nflatpak_deploy_get_deploy_data (FlatpakDeploy *deploy,\n                                int            required_version,\n                                GCancellable  *cancellable,\n                                GError       **error)\n{\n  return flatpak_load_deploy_data (deploy->dir,\n                                   deploy->ref,\n                                   deploy->repo,\n                                   required_version,\n                                   cancellable,\n                                   error);\n}\n\nGFile *\nflatpak_deploy_get_files (FlatpakDeploy *deploy)\n{\n  return g_file_get_child (deploy->dir, \"files\");\n}\n\nFlatpakContext *\nflatpak_deploy_get_overrides (FlatpakDeploy *deploy)\n{\n  FlatpakContext *overrides = flatpak_context_new ();\n\n  if (deploy->system_overrides)\n    flatpak_context_merge (overrides, deploy->system_overrides);\n\n  if (deploy->system_app_overrides)\n    flatpak_context_merge (overrides, deploy->system_app_overrides);\n\n  if (deploy->user_overrides)\n    flatpak_context_merge (overrides, deploy->user_overrides);\n\n  if (deploy->user_app_overrides)\n    flatpak_context_merge (overrides, deploy->user_app_overrides);\n\n  return overrides;\n}\n\nGKeyFile *\nflatpak_deploy_get_metadata (FlatpakDeploy *deploy)\n{\n  return g_key_file_ref (deploy->metadata);\n}\n\nstatic FlatpakDeploy *\nflatpak_deploy_new (GFile             *dir,\n                    FlatpakDecomposed *ref,\n                    GKeyFile          *metadata,\n                    OstreeRepo        *repo)\n{\n  FlatpakDeploy *deploy;\n\n  deploy = g_object_new (FLATPAK_TYPE_DEPLOY, NULL);\n  deploy->ref = flatpak_decomposed_ref (ref);\n  deploy->dir = g_object_ref (dir);\n  deploy->metadata = g_key_file_ref (metadata);\n  deploy->repo = g_object_ref (repo);\n\n  return deploy;\n}\n\nGFile *\nflatpak_get_system_default_base_dir_location (void)\n{\n  static gsize path = 0;\n\n  if (g_once_init_enter (&path))\n    {\n      gsize setup_value = 0;\n      const char *system_dir = g_getenv (\"FLATPAK_SYSTEM_DIR\");\n      if (system_dir != NULL)\n        setup_value = (gsize) system_dir;\n      else\n        setup_value = (gsize) FLATPAK_SYSTEMDIR;\n      g_once_init_leave (&path, setup_value);\n    }\n\n  return g_file_new_for_path ((char *) path);\n}\n\nstatic FlatpakDirStorageType\nparse_storage_type (const char *type_string)\n{\n  if (type_string != NULL)\n    {\n      g_autofree char *type_low = NULL;\n\n      type_low = g_ascii_strdown (type_string, -1);\n      if (g_strcmp0 (type_low, \"network\") == 0)\n        return FLATPAK_DIR_STORAGE_TYPE_NETWORK;\n\n      if (g_strcmp0 (type_low, \"mmc\") == 0)\n        return FLATPAK_DIR_STORAGE_TYPE_MMC;\n\n      if (g_strcmp0 (type_low, \"sdcard\") == 0)\n        return FLATPAK_DIR_STORAGE_TYPE_SDCARD;\n\n      if (g_strcmp0 (type_low, \"hardisk\") == 0)\n        return FLATPAK_DIR_STORAGE_TYPE_HARD_DISK;\n    }\n\n  return FLATPAK_DIR_STORAGE_TYPE_DEFAULT;\n}\n\nstatic gboolean\nhas_system_location (GPtrArray  *locations,\n                     const char *id)\n{\n  int i;\n\n  for (i = 0; i < locations->len; i++)\n    {\n      GFile *path = g_ptr_array_index (locations, i);\n      DirExtraData *extra_data = g_object_get_data (G_OBJECT (path), \"extra-data\");\n      if (extra_data != NULL && g_strcmp0 (extra_data->id, id) == 0)\n        return TRUE;\n    }\n\n  return FALSE;\n}\n\nstatic void\nappend_new_system_location (GPtrArray            *locations,\n                            GFile                *location,\n                            const char           *id,\n                            const char           *display_name,\n                            FlatpakDirStorageType storage_type,\n                            gint                  priority)\n{\n  DirExtraData *extra_data = NULL;\n\n  extra_data = dir_extra_data_new (id, display_name, priority, storage_type);\n  g_object_set_data_full (G_OBJECT (location), \"extra-data\", extra_data,\n                          (GDestroyNotify) dir_extra_data_free);\n\n  g_ptr_array_add (locations, location);\n}\n\nstatic gboolean\nis_good_installation_id (const char *id)\n{\n  if (strcmp (id, \"\") == 0 ||\n      strcmp (id, \"user\") == 0 ||\n      strcmp (id, SYSTEM_DIR_DEFAULT_ID) == 0 ||\n      strcmp (id, \"system\") == 0)\n    return FALSE;\n\n  if (!g_str_is_ascii (id) ||\n      strpbrk (id, \" /\\n\"))\n    return FALSE;\n\n  if (strlen (id) > 80)\n    return FALSE;\n\n  return TRUE;\n}\n\nstatic gboolean\nappend_locations_from_config_file (GPtrArray    *locations,\n                                   const char   *file_path,\n                                   GCancellable *cancellable,\n                                   GError      **error)\n{\n  g_autoptr(GKeyFile) keyfile = NULL;\n  g_auto(GStrv) groups = NULL;\n  g_autoptr(GError) my_error = NULL;\n  gboolean ret = FALSE;\n  gsize n_groups;\n  int i;\n\n  keyfile = g_key_file_new ();\n\n  if (!g_key_file_load_from_file (keyfile, file_path, G_KEY_FILE_NONE, &my_error))\n    {\n      g_debug (\"Could not get list of system installations from '%s': %s\", file_path, my_error->message);\n      g_propagate_error (error, g_steal_pointer (&my_error));\n      goto out;\n    }\n\n  /* One configuration file might define more than one installation */\n  groups = g_key_file_get_groups (keyfile, &n_groups);\n  for (i = 0; i < n_groups; i++)\n    {\n      g_autofree char *id = NULL;\n      g_autofree char *path = NULL;\n      size_t len;\n\n      if (!g_str_has_prefix (groups[i], \"Installation \\\"\"))\n        {\n          if (g_str_has_prefix (groups[i], \"Installation \"))\n            g_warning (\"Installation without quotes (%s). Ignoring\", groups[i]);\n          continue;\n        }\n\n      id = g_strdup (&groups[i][14]);\n      if (!g_str_has_suffix (id, \"\\\"\"))\n        {\n          g_warning (\"While reading '%s': Installation without closing quote (%s). Ignoring\", file_path, groups[i]);\n          continue;\n        }\n\n      len = strlen (id);\n      if (len > 0)\n        id[len - 1] = '\\0';\n\n      if (!is_good_installation_id (id))\n        {\n          g_warning (\"While reading '%s': Bad installation ID '%s'. Ignoring\", file_path, id);\n          continue;\n        }\n\n      if (has_system_location (locations, id))\n        {\n          g_warning (\"While reading '%s': Duplicate installation ID '%s'. Ignoring\", file_path, id);\n          continue;\n        }\n\n      path = g_key_file_get_string (keyfile, groups[i], \"Path\", &my_error);\n      if (path == NULL)\n        {\n          g_debug (\"While reading '%s': Unable to get path for installation '%s': %s\", file_path, id, my_error->message);\n          g_propagate_error (error, g_steal_pointer (&my_error));\n          goto out;\n        }\n      else\n        {\n          GFile *location = NULL;\n          g_autofree char *display_name = NULL;\n          g_autofree char *priority = NULL;\n          g_autofree char *storage_type = NULL;\n          gint priority_val = 0;\n\n          display_name = g_key_file_get_string (keyfile, groups[i], \"DisplayName\", NULL);\n          priority = g_key_file_get_string (keyfile, groups[i], \"Priority\", NULL);\n          storage_type = g_key_file_get_string (keyfile, groups[i], \"StorageType\", NULL);\n\n          if (priority != NULL)\n            priority_val = g_ascii_strtoll (priority, NULL, 10);\n\n          location = g_file_new_for_path (path);\n          append_new_system_location (locations, location, id, display_name,\n                                      parse_storage_type (storage_type),\n                                      priority_val);\n        }\n    }\n\n  ret = TRUE;\n\nout:\n  return ret;\n}\n\nstatic gint\nsystem_locations_compare_func (gconstpointer location_a, gconstpointer location_b)\n{\n  const GFile *location_object_a = *(const GFile **) location_a;\n  const GFile *location_object_b = *(const GFile **) location_b;\n  DirExtraData *extra_data_a = NULL;\n  DirExtraData *extra_data_b = NULL;\n  gint prio_a = 0;\n  gint prio_b = 0;\n\n  extra_data_a = g_object_get_data (G_OBJECT (location_object_a), \"extra-data\");\n  prio_a = (extra_data_a != NULL) ? extra_data_a->priority : 0;\n\n  extra_data_b = g_object_get_data (G_OBJECT (location_object_b), \"extra-data\");\n  prio_b = (extra_data_b != NULL) ? extra_data_b->priority : 0;\n\n  return prio_b - prio_a;\n}\n\nstatic GPtrArray *\nsystem_locations_from_configuration (GCancellable *cancellable,\n                                     GError      **error)\n{\n  g_autoptr(GPtrArray) locations = NULL;\n  g_autoptr(GFile) conf_dir = NULL;\n  g_autoptr(GFileEnumerator) dir_enum = NULL;\n  g_autoptr(GError) my_error = NULL;\n  g_autofree char *config_dir = NULL;\n\n  locations = g_ptr_array_new_with_free_func (g_object_unref);\n  config_dir = g_strdup_printf (\"%s/%s\",\n                                get_config_dir_location (),\n                                SYSCONF_INSTALLATIONS_DIR);\n\n  if (!g_file_test (config_dir, G_FILE_TEST_IS_DIR))\n    {\n      g_debug (\"No installations directory in %s. Skipping\", config_dir);\n      goto out;\n    }\n\n  conf_dir = g_file_new_for_path (config_dir);\n  dir_enum = g_file_enumerate_children (conf_dir,\n                                        G_FILE_ATTRIBUTE_STANDARD_NAME \",\" G_FILE_ATTRIBUTE_STANDARD_TYPE,\n                                        G_FILE_QUERY_INFO_NONE,\n                                        cancellable, &my_error);\n  if (my_error != NULL)\n    {\n      g_debug (\"Unexpected error retrieving extra installations in %s: %s\",\n               config_dir, my_error->message);\n      g_propagate_error (error, g_steal_pointer (&my_error));\n      goto out;\n    }\n\n  while (TRUE)\n    {\n      GFileInfo *file_info;\n      GFile *path;\n      const char *name;\n      guint32 type;\n\n      if (!g_file_enumerator_iterate (dir_enum, &file_info, &path,\n                                      cancellable, &my_error))\n        {\n          g_debug (\"Unexpected error reading file in %s: %s\",\n                   config_dir, my_error->message);\n          g_propagate_error (error, g_steal_pointer (&my_error));\n          goto out;\n        }\n\n      if (file_info == NULL)\n        break;\n\n      name = g_file_info_get_attribute_byte_string (file_info, \"standard::name\");\n      type = g_file_info_get_attribute_uint32 (file_info, \"standard::type\");\n\n      if (type == G_FILE_TYPE_REGULAR && g_str_has_suffix (name, SYSCONF_INSTALLATIONS_FILE_EXT))\n        {\n          g_autofree char *path_str = g_file_get_path (path);\n          if (!append_locations_from_config_file (locations, path_str, cancellable, error))\n            goto out;\n        }\n    }\n\nout:\n  return g_steal_pointer (&locations);\n}\n\nstatic GPtrArray *\nget_system_locations (GCancellable *cancellable,\n                      GError      **error)\n{\n  g_autoptr(GPtrArray) locations = NULL;\n\n  /* This will always return a GPtrArray, being an empty one\n   * if no additional system installations have been configured.\n   */\n  locations = system_locations_from_configuration (cancellable, error);\n\n  /* Only fill the details of the default directory if not overridden. */\n  if (!has_system_location (locations, SYSTEM_DIR_DEFAULT_ID))\n    {\n      append_new_system_location (locations,\n                                  flatpak_get_system_default_base_dir_location (),\n                                  SYSTEM_DIR_DEFAULT_ID,\n                                  SYSTEM_DIR_DEFAULT_DISPLAY_NAME,\n                                  SYSTEM_DIR_DEFAULT_STORAGE_TYPE,\n                                  SYSTEM_DIR_DEFAULT_PRIORITY);\n    }\n\n  /* Store the list of system locations sorted according to priorities */\n  g_ptr_array_sort (locations, system_locations_compare_func);\n\n  return g_steal_pointer (&locations);\n}\n\nGPtrArray *\nflatpak_get_system_base_dir_locations (GCancellable *cancellable,\n                                       GError      **error)\n{\n  static gsize array = 0;\n\n  if (g_once_init_enter (&array))\n    {\n      gsize setup_value = 0;\n      setup_value = (gsize) get_system_locations (cancellable, error);\n      g_once_init_leave (&array, setup_value);\n    }\n\n  return (GPtrArray *) array;\n}\n\nGFile *\nflatpak_get_user_base_dir_location (void)\n{\n  static gsize file = 0;\n\n  if (g_once_init_enter (&file))\n    {\n      gsize setup_value = 0;\n      const char *path;\n      g_autofree char *free_me = NULL;\n      const char *user_dir = g_getenv (\"FLATPAK_USER_DIR\");\n      if (user_dir != NULL && *user_dir != 0)\n        path = user_dir;\n      else\n        path = free_me = g_build_filename (g_get_user_data_dir (), \"flatpak\", NULL);\n\n      setup_value = (gsize) g_file_new_for_path (path);\n\n      g_once_init_leave (&file, setup_value);\n    }\n\n  return g_object_ref ((GFile *) file);\n}\n\nstatic gboolean\nvalidate_commit_metadata (GVariant   *commit_data,\n                          const char *ref,\n                          const char *required_metadata,\n                          gboolean   require_xa_metadata,\n                          GError   **error)\n{\n  g_autoptr(GVariant) commit_metadata = NULL;\n  const char *xa_metadata = NULL;\n\n  commit_metadata = g_variant_get_child_value (commit_data, 0);\n\n  if (commit_metadata != NULL)\n    g_variant_lookup (commit_metadata, \"xa.metadata\", \"&s\", &xa_metadata);\n\n  if ((xa_metadata == NULL && require_xa_metadata) ||\n      (xa_metadata != NULL && g_strcmp0 (required_metadata, xa_metadata) != 0))\n    {\n      g_set_error (error, G_IO_ERROR, G_IO_ERROR_PERMISSION_DENIED,\n                   _(\"Commit metadata for %s not matching expected metadata\"), ref);\n      return FALSE;\n    }\n\n  return TRUE;\n}\n\n/* This is a cache directory similar to ~/.cache/flatpak/system-cache,\n * but in /var/tmp. This is useful for things like the system child\n * repos, because it is more likely to be on the same filesystem as\n * the system repo (thus increasing chances for e.g. reflink copying),\n * and avoids filling the users homedirectory with temporary data.\n *\n * In order to re-use this between instances we create a symlink\n * in /run to it and verify it before use.\n */\nstatic GFile *\nflatpak_ensure_system_user_cache_dir_location (GError **error)\n{\n  g_autofree char *path = NULL;\n  g_autofree char *symlink_path = NULL;\n  struct stat st_buf;\n  const char *custom_path = g_getenv (\"FLATPAK_SYSTEM_CACHE_DIR\");\n\n  if (custom_path != NULL && *custom_path != 0)\n    {\n      if (g_mkdir_with_parents (custom_path, 0755) != 0)\n        {\n          glnx_set_error_from_errno (error);\n          return NULL;\n        }\n\n      return g_file_new_for_path (custom_path);\n    }\n\n  symlink_path = g_build_filename (g_get_user_runtime_dir (), \".flatpak-cache\", NULL);\n  path = flatpak_readlink (symlink_path, NULL);\n\n  if (stat (path, &st_buf) == 0 &&\n      /* Must be owned by us */\n      st_buf.st_uid == getuid () &&\n      /* and not writeable by others, but readable */\n      (st_buf.st_mode & 0777) == 0755)\n    return g_file_new_for_path (path);\n\n  path = g_strdup (\"/var/tmp/flatpak-cache-XXXXXX\");\n\n  if (g_mkdtemp_full (path, 0755) == NULL)\n    {\n      flatpak_fail (error, \"Can't create temporary directory\");\n      return NULL;\n    }\n\n  unlink (symlink_path);\n  if (symlink (path, symlink_path) != 0)\n    {\n      glnx_set_error_from_errno (error);\n      return NULL;\n    }\n\n  return g_file_new_for_path (path);\n}\n\nstatic GFile *\nflatpak_get_user_cache_dir_location (void)\n{\n  g_autoptr(GFile) base_dir = g_file_new_for_path (g_get_user_cache_dir ());\n\n  return g_file_resolve_relative_path (base_dir, \"flatpak/system-cache\");\n}\n\nstatic GFile *\nflatpak_ensure_user_cache_dir_location (GError **error)\n{\n  g_autoptr(GFile) cache_dir = NULL;\n  g_autofree char *cache_path = NULL;\n\n  cache_dir = flatpak_get_user_cache_dir_location ();\n  cache_path = g_file_get_path (cache_dir);\n\n  if (g_mkdir_with_parents (cache_path, 0755) != 0)\n    {\n      glnx_set_error_from_errno (error);\n      return NULL;\n    }\n\n  return g_steal_pointer (&cache_dir);\n}\n\nstatic GFile *\nflatpak_dir_get_oci_cache_file (FlatpakDir *self,\n                                const char *remote,\n                                const char *suffix,\n                                GError    **error)\n{\n  g_autoptr(GFile) oci_dir = NULL;\n  g_autofree char *filename = NULL;\n\n  oci_dir = g_file_get_child (flatpak_dir_get_path (self), \"oci\");\n  if (g_mkdir_with_parents (flatpak_file_get_path_cached (oci_dir), 0755) != 0)\n    {\n      glnx_set_error_from_errno (error);\n      return NULL;\n    }\n\n  filename = g_strconcat (remote, suffix, NULL);\n  return g_file_get_child (oci_dir, filename);\n}\n\nstatic GFile *\nflatpak_dir_get_oci_index_location (FlatpakDir *self,\n                                    const char *remote,\n                                    GError    **error)\n{\n  return flatpak_dir_get_oci_cache_file (self, remote, \".index.gz\", error);\n}\n\nstatic GFile *\nflatpak_dir_get_oci_summary_location (FlatpakDir *self,\n                                      const char *remote,\n                                      GError    **error)\n{\n  return flatpak_dir_get_oci_cache_file (self, remote, \".summary\", error);\n}\n\nstatic gboolean\nflatpak_dir_remove_oci_file (FlatpakDir   *self,\n                             const char   *remote,\n                             const char   *suffix,\n                             GCancellable *cancellable,\n                             GError      **error)\n{\n  g_autoptr(GFile) file = flatpak_dir_get_oci_cache_file (self, remote, suffix, error);\n  g_autoptr(GError) local_error = NULL;\n\n  if (file == NULL)\n    return FALSE;\n\n  if (!g_file_delete (file, cancellable, &local_error) &&\n      !g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND))\n    {\n      g_propagate_error (error, g_steal_pointer (&local_error));\n      return FALSE;\n    }\n\n  return TRUE;\n}\n\nstatic gboolean\nflatpak_dir_remove_oci_files (FlatpakDir   *self,\n                              const char   *remote,\n                              GCancellable *cancellable,\n                              GError      **error)\n{\n  if (!flatpak_dir_remove_oci_file (self, remote, \".index.gz\", cancellable, error) ||\n      !flatpak_dir_remove_oci_file (self, remote, \".summary\", cancellable, error))\n    return FALSE;\n\n  return TRUE;\n}\n\nstatic gchar *\nflatpak_dir_revokefs_fuse_create_mountpoint (FlatpakDecomposed *ref,\n                                             GError           **error)\n{\n  g_autoptr(GFile) cache_dir = NULL;\n  g_autofree gchar *cache_dir_path = NULL;\n  g_autofree gchar *mnt_dir = NULL;\n  g_autofree gchar *id = NULL;\n  g_autofree gchar *mountpoint = NULL;\n\n  cache_dir = flatpak_ensure_system_user_cache_dir_location (error);\n  if (cache_dir == NULL)\n    return NULL;\n\n  id = flatpak_decomposed_dup_id (ref);\n  cache_dir_path = g_file_get_path (cache_dir);\n  mnt_dir = g_strdup_printf (\"%s-XXXXXX\", id);\n  mountpoint = g_mkdtemp_full (g_build_filename (cache_dir_path, mnt_dir, NULL), 0755);\n  if (mountpoint == NULL)\n    {\n      glnx_set_error_from_errno (error);\n      return NULL;\n    }\n\n  return g_steal_pointer (&mountpoint);\n}\n\nstatic gboolean\nflatpak_dir_revokefs_fuse_unmount (OstreeRepo **repo,\n                                  GLnxLockFile *lockfile,\n                                  const gchar *mnt_dir,\n                                  GError **error)\n{\n  g_autoptr(GSubprocess) fusermount = NULL;\n\n  /* Clear references to child_repo as not to leave any open fds. This is needed for\n   * a clean umount operation.\n   */\n  g_clear_pointer (repo, g_object_unref);\n  glnx_release_lock_file (lockfile);\n\n  fusermount = g_subprocess_new (G_SUBPROCESS_FLAGS_NONE,\n                                 error,\n                                 \"fusermount\", \"-u\", \"-z\", mnt_dir,\n                                 NULL);\n  if (g_subprocess_wait_check (fusermount, NULL, error))\n    {\n      g_autoptr(GFile) mnt_dir_file = g_file_new_for_path (mnt_dir);\n      g_autoptr(GError) tmp_error = NULL;\n\n      if (!flatpak_rm_rf (mnt_dir_file, NULL, &tmp_error))\n        g_warning (\"Unable to remove mountpoint directory %s: %s\", mnt_dir, tmp_error->message);\n\n      return TRUE;\n    }\n\n  return FALSE;\n}\n\nstatic gboolean\nflatpak_dir_use_system_helper (FlatpakDir *self,\n                               const char *installing_from_remote)\n{\n#ifdef USE_SYSTEM_HELPER\n  if (self->no_system_helper || self->user || getuid () == 0)\n    return FALSE;\n\n  /* OCI doesn't do signatures atm, so we can't use the system helper for this */\n  if (installing_from_remote != NULL && flatpak_dir_get_remote_oci (self, installing_from_remote))\n    return FALSE;\n\n  return TRUE;\n#else\n  return FALSE;\n#endif\n}\n\nstatic GVariant *\nflatpak_dir_system_helper_call (FlatpakDir         *self,\n                                const gchar        *method_name,\n                                GVariant           *parameters,\n                                const GVariantType *reply_type,\n                                GUnixFDList       **out_fd_list,\n                                GCancellable       *cancellable,\n                                GError            **error)\n{\n  GVariant *res;\n\n  if (g_once_init_enter (&self->system_helper_bus))\n    {\n      const char *on_session = g_getenv (\"FLATPAK_SYSTEM_HELPER_ON_SESSION\");\n      GDBusConnection *system_helper_bus =\n        g_bus_get_sync (on_session != NULL ? G_BUS_TYPE_SESSION : G_BUS_TYPE_SYSTEM,\n                        cancellable, NULL);\n\n      /* To ensure reverse mapping */\n      flatpak_error_quark ();\n\n      g_once_init_leave (&self->system_helper_bus, system_helper_bus ? system_helper_bus : (gpointer) 1 );\n    }\n\n  if (self->system_helper_bus == (gpointer) 1)\n    {\n      flatpak_fail (error, _(\"Unable to connect to system bus\"));\n      return NULL;\n    }\n\n  g_debug (\"Calling system helper: %s\", method_name);\n  res = g_dbus_connection_call_with_unix_fd_list_sync (self->system_helper_bus,\n                                                       \"org.freedesktop.Flatpak.SystemHelper\",\n                                                       \"/org/freedesktop/Flatpak/SystemHelper\",\n                                                       \"org.freedesktop.Flatpak.SystemHelper\",\n                                                       method_name,\n                                                       parameters,\n                                                       reply_type,\n                                                       G_DBUS_CALL_FLAGS_NONE, G_MAXINT,\n                                                       NULL, out_fd_list,\n                                                       cancellable,\n                                                       error);\n\n if (res == NULL && error)\n    g_dbus_error_strip_remote_error (*error);\n\n  return res;\n}\n\nstatic gboolean\nflatpak_dir_system_helper_call_deploy (FlatpakDir         *self,\n                                       const gchar        *arg_repo_path,\n                                       guint               arg_flags,\n                                       const gchar        *arg_ref,\n                                       const gchar        *arg_origin,\n                                       const gchar *const *arg_subpaths,\n                                       const gchar *const *arg_previous_ids,\n                                       const gchar        *arg_installation,\n                                       GCancellable       *cancellable,\n                                       GError            **error)\n{\n  const char *empty[] = { NULL };\n\n  if (arg_subpaths == NULL)\n    arg_subpaths = empty;\n  if (arg_previous_ids == NULL)\n    arg_previous_ids = empty;\n\n  if (flatpak_dir_get_no_interaction (self))\n    arg_flags |= FLATPAK_HELPER_DEPLOY_FLAGS_NO_INTERACTION;\n\n  g_autoptr(GVariant) ret =\n    flatpak_dir_system_helper_call (self, \"Deploy\",\n                                    g_variant_new (\"(^ayuss^as^ass)\",\n                                                   arg_repo_path,\n                                                   arg_flags,\n                                                   arg_ref,\n                                                   arg_origin,\n                                                   arg_subpaths,\n                                                   arg_previous_ids,\n                                                   arg_installation),\n                                    G_VARIANT_TYPE (\"()\"), NULL,\n                                    cancellable, error);\n  return ret != NULL;\n}\n\nstatic gboolean\nflatpak_dir_system_helper_call_deploy_appstream (FlatpakDir   *self,\n                                                 const gchar  *arg_repo_path,\n                                                 guint         arg_flags,\n                                                 const gchar  *arg_origin,\n                                                 const gchar  *arg_arch,\n                                                 const gchar  *arg_installation,\n                                                 GCancellable *cancellable,\n                                                 GError      **error)\n{\n  if (flatpak_dir_get_no_interaction (self))\n    arg_flags |= FLATPAK_HELPER_DEPLOY_APPSTREAM_FLAGS_NO_INTERACTION;\n\n  g_autoptr(GVariant) ret =\n    flatpak_dir_system_helper_call (self, \"DeployAppstream\",\n                                    g_variant_new (\"(^ayusss)\",\n                                                   arg_repo_path,\n                                                   arg_flags,\n                                                   arg_origin,\n                                                   arg_arch,\n                                                   arg_installation),\n                                    G_VARIANT_TYPE (\"()\"), NULL,\n                                    cancellable, error);\n  return ret != NULL;\n}\n\nstatic gboolean\nflatpak_dir_system_helper_call_uninstall (FlatpakDir   *self,\n                                          guint         arg_flags,\n                                          const gchar  *arg_ref,\n                                          const gchar  *arg_installation,\n                                          GCancellable *cancellable,\n                                          GError      **error)\n{\n  if (flatpak_dir_get_no_interaction (self))\n    arg_flags |= FLATPAK_HELPER_UNINSTALL_FLAGS_NO_INTERACTION;\n\n  g_autoptr(GVariant) ret =\n    flatpak_dir_system_helper_call (self, \"Uninstall\",\n                                    g_variant_new (\"(uss)\",\n                                                   arg_flags,\n                                                   arg_ref,\n                                                   arg_installation),\n                                    G_VARIANT_TYPE (\"()\"), NULL,\n                                    cancellable, error);\n  return ret != NULL;\n}\n\nstatic gboolean\nflatpak_dir_system_helper_call_install_bundle (FlatpakDir   *self,\n                                               const gchar  *arg_bundle_path,\n                                               guint         arg_flags,\n                                               const gchar  *arg_remote,\n                                               const gchar  *arg_installation,\n                                               gchar       **out_ref,\n                                               GCancellable *cancellable,\n                                               GError      **error)\n{\n  if (flatpak_dir_get_no_interaction (self))\n    arg_flags |= FLATPAK_HELPER_INSTALL_BUNDLE_FLAGS_NO_INTERACTION;\n\n  g_autoptr(GVariant) ret =\n    flatpak_dir_system_helper_call (self, \"InstallBundle\",\n                                    g_variant_new (\"(^ayuss)\",\n                                                   arg_bundle_path,\n                                                   arg_flags,\n                                                   arg_remote,\n                                                   arg_installation),\n                                    G_VARIANT_TYPE (\"(s)\"), NULL,\n                                    cancellable, error);\n  if (ret == NULL)\n    return FALSE;\n\n  g_variant_get (ret, \"(s)\", out_ref);\n  return TRUE;\n}\n\nstatic gboolean\nflatpak_dir_system_helper_call_configure_remote (FlatpakDir   *self,\n                                                 guint         arg_flags,\n                                                 const gchar  *arg_remote,\n                                                 const gchar  *arg_config,\n                                                 GVariant     *arg_gpg_key,\n                                                 const gchar  *arg_installation,\n                                                 GCancellable *cancellable,\n                                                 GError      **error)\n{\n  if (flatpak_dir_get_no_interaction (self))\n    arg_flags |= FLATPAK_HELPER_CONFIGURE_REMOTE_FLAGS_NO_INTERACTION;\n\n  g_autoptr(GVariant) ret =\n    flatpak_dir_system_helper_call (self, \"ConfigureRemote\",\n                                    g_variant_new (\"(uss@ays)\",\n                                                   arg_flags,\n                                                   arg_remote,\n                                                   arg_config,\n                                                   arg_gpg_key,\n                                                   arg_installation),\n                                    G_VARIANT_TYPE (\"()\"), NULL,\n                                    cancellable,\n                                    error);\n  return ret != NULL;\n}\n\nstatic gboolean\nflatpak_dir_system_helper_call_configure (FlatpakDir   *self,\n                                          guint         arg_flags,\n                                          const gchar  *arg_key,\n                                          const gchar  *arg_value,\n                                          const gchar  *arg_installation,\n                                          GCancellable *cancellable,\n                                          GError      **error)\n{\n  if (flatpak_dir_get_no_interaction (self))\n    arg_flags |= FLATPAK_HELPER_CONFIGURE_FLAGS_NO_INTERACTION;\n\n  g_autoptr(GVariant) ret =\n    flatpak_dir_system_helper_call (self, \"Configure\",\n                                    g_variant_new (\"(usss)\",\n                                                   arg_flags,\n                                                   arg_key,\n                                                   arg_value,\n                                                   arg_installation),\n                                    G_VARIANT_TYPE (\"()\"), NULL,\n                                    cancellable, error);\n  return ret != NULL;\n}\n\nstatic gboolean\nflatpak_dir_system_helper_call_update_remote (FlatpakDir   *self,\n                                              guint         arg_flags,\n                                              const gchar  *arg_remote,\n                                              const gchar  *arg_installation,\n                                              const gchar  *arg_summary_path,\n                                              const gchar  *arg_summary_sig_path,\n                                              GCancellable *cancellable,\n                                              GError      **error)\n{\n  if (flatpak_dir_get_no_interaction (self))\n    arg_flags |= FLATPAK_HELPER_UPDATE_REMOTE_FLAGS_NO_INTERACTION;\n\n  g_autoptr(GVariant) ret =\n    flatpak_dir_system_helper_call (self, \"UpdateRemote\",\n                                    g_variant_new (\"(uss^ay^ay)\",\n                                                   arg_flags,\n                                                   arg_remote,\n                                                   arg_installation,\n                                                   arg_summary_path,\n                                                   arg_summary_sig_path),\n                                    G_VARIANT_TYPE (\"()\"), NULL,\n                                    cancellable, error);\n  return ret != NULL;\n}\n\nstatic gboolean\nflatpak_dir_system_helper_call_remove_local_ref (FlatpakDir   *self,\n                                                 guint         arg_flags,\n                                                 const gchar  *arg_remote,\n                                                 const gchar  *arg_ref,\n                                                 const gchar  *arg_installation,\n                                                 GCancellable *cancellable,\n                                                 GError      **error)\n{\n  if (flatpak_dir_get_no_interaction (self))\n    arg_flags |= FLATPAK_HELPER_REMOVE_LOCAL_REF_FLAGS_NO_INTERACTION;\n\n  g_autoptr(GVariant) ret =\n    flatpak_dir_system_helper_call (self, \"RemoveLocalRef\",\n                                    g_variant_new (\"(usss)\",\n                                                   arg_flags,\n                                                   arg_remote,\n                                                   arg_ref,\n                                                   arg_installation),\n                                    G_VARIANT_TYPE (\"()\"), NULL,\n                                    cancellable, error);\n  return ret != NULL;\n}\n\nstatic gboolean\nflatpak_dir_system_helper_call_prune_local_repo (FlatpakDir   *self,\n                                                 guint         arg_flags,\n                                                 const gchar  *arg_installation,\n                                                 GCancellable *cancellable,\n                                                 GError      **error)\n{\n  if (flatpak_dir_get_no_interaction (self))\n    arg_flags |= FLATPAK_HELPER_PRUNE_LOCAL_REPO_FLAGS_NO_INTERACTION;\n\n  g_autoptr(GVariant) ret =\n    flatpak_dir_system_helper_call (self, \"PruneLocalRepo\",\n                                    g_variant_new (\"(us)\",\n                                                   arg_flags,\n                                                   arg_installation),\n                                    G_VARIANT_TYPE (\"()\"), NULL,\n                                    cancellable, error);\n  return ret != NULL;\n}\n\nstatic gboolean\nflatpak_dir_system_helper_call_run_triggers (FlatpakDir   *self,\n                                             guint         arg_flags,\n                                             const gchar  *arg_installation,\n                                             GCancellable *cancellable,\n                                             GError      **error)\n{\n  if (flatpak_dir_get_no_interaction (self))\n    arg_flags |= FLATPAK_HELPER_RUN_TRIGGERS_FLAGS_NO_INTERACTION;\n\n  g_autoptr(GVariant) ret =\n    flatpak_dir_system_helper_call (self, \"RunTriggers\",\n                                    g_variant_new (\"(us)\",\n                                                   arg_flags,\n                                                   arg_installation),\n                                    G_VARIANT_TYPE (\"()\"), NULL,\n                                    cancellable, error);\n  return ret != NULL;\n}\n\nstatic gboolean\nflatpak_dir_system_helper_call_ensure_repo (FlatpakDir   *self,\n                                            guint         arg_flags,\n                                            const gchar  *arg_installation,\n                                            GCancellable *cancellable,\n                                            GError      **error)\n{\n  if (flatpak_dir_get_no_interaction (self))\n    arg_flags |= FLATPAK_HELPER_ENSURE_REPO_FLAGS_NO_INTERACTION;\n\n  g_autoptr(GVariant) ret =\n    flatpak_dir_system_helper_call (self, \"EnsureRepo\",\n                                    g_variant_new (\"(us)\",\n                                                   arg_flags,\n                                                   arg_installation),\n                                    G_VARIANT_TYPE (\"()\"), NULL,\n                                    cancellable, error);\n  return ret != NULL;\n}\n\nstatic gboolean\nflatpak_dir_system_helper_call_cancel_pull (FlatpakDir    *self,\n                                            guint          arg_flags,\n                                            const gchar   *arg_installation,\n                                            const gchar   *arg_src_dir,\n                                            GCancellable  *cancellable,\n                                            GError       **error)\n{\n  if (flatpak_dir_get_no_interaction (self))\n    arg_flags |= FLATPAK_HELPER_CANCEL_PULL_FLAGS_NO_INTERACTION;\n\n  g_debug (\"Calling system helper: CancelPull\");\n\n  g_autoptr(GVariant) ret =\n    flatpak_dir_system_helper_call (self, \"CancelPull\",\n                                    g_variant_new (\"(uss)\",\n                                                   arg_flags,\n                                                   arg_installation,\n                                                   arg_src_dir),\n                                    NULL, NULL,\n                                    cancellable, error);\n\n   return ret != NULL;\n}\n\nstatic gboolean\nflatpak_dir_system_helper_call_get_revokefs_fd (FlatpakDir   *self,\n                                                guint         arg_flags,\n                                                const gchar  *arg_installation,\n                                                gint         *out_socket,\n                                                gchar       **out_src_dir,\n                                                GCancellable *cancellable,\n                                                GError      **error)\n{\n  g_autoptr(GUnixFDList) out_fd_list = NULL;\n  gint fd = -1;\n  gint fd_index = -1;\n\n  if (flatpak_dir_get_no_interaction (self))\n    arg_flags |= FLATPAK_HELPER_GET_REVOKEFS_FD_FLAGS_NO_INTERACTION;\n\n  g_debug (\"Calling system helper: GetRevokefsFd\");\n\n  g_autoptr(GVariant) ret =\n    flatpak_dir_system_helper_call (self, \"GetRevokefsFd\",\n                                    g_variant_new (\"(us)\",\n                                                   arg_flags,\n                                                   arg_installation),\n                                    G_VARIANT_TYPE (\"(hs)\"),\n                                    &out_fd_list,\n                                    cancellable, error);\n\n  if (ret == NULL)\n    return FALSE;\n\n  g_variant_get (ret, \"(hs)\", &fd_index, out_src_dir);\n  fd  = g_unix_fd_list_get (out_fd_list, fd_index, error);\n  if (fd == -1)\n    return FALSE;\n\n  *out_socket = fd;\n\n  return TRUE;\n}\n\nstatic gboolean\nflatpak_dir_system_helper_call_update_summary (FlatpakDir   *self,\n                                               guint         arg_flags,\n                                               const gchar  *arg_installation,\n                                               GCancellable *cancellable,\n                                               GError      **error)\n{\n  if (flatpak_dir_get_no_interaction (self))\n    arg_flags |= FLATPAK_HELPER_UPDATE_SUMMARY_FLAGS_NO_INTERACTION;\n\n  g_autoptr(GVariant) ret =\n    flatpak_dir_system_helper_call (self, \"UpdateSummary\",\n                                    g_variant_new (\"(us)\",\n                                                   arg_flags,\n                                                   arg_installation),\n                                    G_VARIANT_TYPE (\"()\"), NULL,\n                                    cancellable, error);\n  return ret != NULL;\n}\n\nstatic gboolean\nflatpak_dir_system_helper_call_generate_oci_summary (FlatpakDir   *self,\n                                                     guint         arg_flags,\n                                                     const gchar  *arg_origin,\n                                                     const gchar  *arg_installation,\n                                                     GCancellable *cancellable,\n                                                     GError      **error)\n{\n  if (flatpak_dir_get_no_interaction (self))\n    arg_flags |= FLATPAK_HELPER_GENERATE_OCI_SUMMARY_FLAGS_NO_INTERACTION;\n\n  g_autoptr(GVariant) ret =\n    flatpak_dir_system_helper_call (self, \"GenerateOciSummary\",\n                                    g_variant_new (\"(uss)\",\n                                                   arg_flags,\n                                                   arg_origin,\n                                                   arg_installation),\n                                    G_VARIANT_TYPE (\"()\"), NULL,\n                                    cancellable, error);\n  return ret != NULL;\n}\n\nstatic void\nflatpak_dir_finalize (GObject *object)\n{\n  FlatpakDir *self = FLATPAK_DIR (object);\n\n  g_clear_object (&self->repo);\n  g_clear_object (&self->cache_dir);\n  g_clear_object (&self->basedir);\n  g_clear_pointer (&self->extra_data, dir_extra_data_free);\n\n  if (self->system_helper_bus != (gpointer) 1)\n    g_clear_object (&self->system_helper_bus);\n\n  g_clear_object (&self->soup_session);\n  g_clear_pointer (&self->summary_cache, g_hash_table_unref);\n  g_clear_pointer (&self->remote_filters, g_hash_table_unref);\n  g_clear_pointer (&self->masked, g_regex_unref);\n  g_clear_pointer (&self->pinned, g_regex_unref);\n\n  G_OBJECT_CLASS (flatpak_dir_parent_class)->finalize (object);\n}\n\nstatic void\nflatpak_dir_set_property (GObject      *object,\n                          guint         prop_id,\n                          const GValue *value,\n                          GParamSpec   *pspec)\n{\n  FlatpakDir *self = FLATPAK_DIR (object);\n\n  switch (prop_id)\n    {\n    case PROP_PATH:\n      /* Canonicalize */\n      self->basedir = g_file_new_for_path (flatpak_file_get_path_cached (g_value_get_object (value)));\n      break;\n\n    case PROP_USER:\n      self->user = g_value_get_boolean (value);\n      break;\n\n    default:\n      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);\n      break;\n    }\n}\n\nstatic void\nflatpak_dir_get_property (GObject    *object,\n                          guint       prop_id,\n                          GValue     *value,\n                          GParamSpec *pspec)\n{\n  FlatpakDir *self = FLATPAK_DIR (object);\n\n  switch (prop_id)\n    {\n    case PROP_PATH:\n      g_value_set_object (value, self->basedir);\n      break;\n\n    case PROP_USER:\n      g_value_set_boolean (value, self->user);\n      break;\n\n    default:\n      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);\n      break;\n    }\n}\n\nstatic void\nflatpak_dir_class_init (FlatpakDirClass *klass)\n{\n  GObjectClass *object_class = G_OBJECT_CLASS (klass);\n\n  object_class->get_property = flatpak_dir_get_property;\n  object_class->set_property = flatpak_dir_set_property;\n  object_class->finalize = flatpak_dir_finalize;\n\n  g_object_class_install_property (object_class,\n                                   PROP_USER,\n                                   g_param_spec_boolean (\"user\",\n                                                         \"\",\n                                                         \"\",\n                                                         FALSE,\n                                                         G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY));\n  g_object_class_install_property (object_class,\n                                   PROP_PATH,\n                                   g_param_spec_object (\"path\",\n                                                        \"\",\n                                                        \"\",\n                                                        G_TYPE_FILE,\n                                                        G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY));\n}\n\nstatic void\nflatpak_dir_init (FlatpakDir *self)\n{\n  /* Work around possible deadlock due to: https://bugzilla.gnome.org/show_bug.cgi?id=674885 */\n  g_type_ensure (G_TYPE_UNIX_SOCKET_ADDRESS);\n\n  /* Optional data that needs initialization */\n  self->extra_data = NULL;\n}\n\ngboolean\nflatpak_dir_is_user (FlatpakDir *self)\n{\n  return self->user;\n}\n\nvoid\nflatpak_dir_set_no_system_helper (FlatpakDir *self,\n                                  gboolean    no_system_helper)\n{\n  self->no_system_helper = no_system_helper;\n}\n\nvoid\nflatpak_dir_set_no_interaction (FlatpakDir *self,\n                                gboolean    no_interaction)\n{\n  self->no_interaction = no_interaction;\n}\n\ngboolean\nflatpak_dir_get_no_interaction (FlatpakDir *self)\n{\n  return self->no_interaction;\n}\n\nGFile *\nflatpak_dir_get_path (FlatpakDir *self)\n{\n  return self->basedir;\n}\n\nGFile *\nflatpak_dir_get_changed_path (FlatpakDir *self)\n{\n  return g_file_get_child (self->basedir, \".changed\");\n}\n\nconst char *\nflatpak_dir_get_id (FlatpakDir *self)\n{\n  if (self->user)\n    return \"user\";\n\n  if (self->extra_data != NULL)\n    return self->extra_data->id;\n\n  return NULL;\n}\n\nchar *\nflatpak_dir_get_name (FlatpakDir *self)\n{\n  const char *id = NULL;\n\n  if (self->user)\n    return g_strdup (\"user\");\n\n  id = flatpak_dir_get_id (self);\n  if (id != NULL && g_strcmp0 (id, SYSTEM_DIR_DEFAULT_ID) != 0)\n    return g_strdup_printf (\"system (%s)\", id);\n\n  return g_strdup (\"system\");\n}\n\nconst char *\nflatpak_dir_get_name_cached (FlatpakDir *self)\n{\n  char *name;\n\n  name = g_object_get_data (G_OBJECT (self), \"cached-name\");\n  if (!name)\n    {\n      name = flatpak_dir_get_name (self),\n      g_object_set_data_full (G_OBJECT (self), \"cached-name\", name, g_free);\n    }\n\n  return (const char *) name;\n}\n\nchar *\nflatpak_dir_get_display_name (FlatpakDir *self)\n{\n  if (self->user)\n    return g_strdup (_(\"User installation\"));\n\n  if (self->extra_data != NULL && g_strcmp0 (self->extra_data->id, SYSTEM_DIR_DEFAULT_ID) != 0)\n    {\n      if (self->extra_data->display_name)\n        return g_strdup (self->extra_data->display_name);\n\n      return g_strdup_printf (_(\"System (%s) installation\"), self->extra_data->id);\n    }\n\n  return g_strdup (SYSTEM_DIR_DEFAULT_DISPLAY_NAME);\n}\n\ngint\nflatpak_dir_get_priority (FlatpakDir *self)\n{\n  if (self->extra_data != NULL)\n    return self->extra_data->priority;\n\n  return 0;\n}\n\nFlatpakDirStorageType\nflatpak_dir_get_storage_type (FlatpakDir *self)\n{\n  if (self->extra_data != NULL)\n    return self->extra_data->storage_type;\n\n  return FLATPAK_DIR_STORAGE_TYPE_DEFAULT;\n}\n\nchar *\nflatpak_dir_load_override (FlatpakDir *self,\n                           const char *app_id,\n                           gsize      *length,\n                           GError    **error)\n{\n  g_autoptr(GFile) override_dir = NULL;\n  g_autoptr(GFile) file = NULL;\n  char *metadata_contents;\n\n  override_dir = g_file_get_child (self->basedir, \"overrides\");\n\n  if (app_id)\n    file = g_file_get_child (override_dir, app_id);\n  else\n    file = g_file_get_child (override_dir, \"global\");\n\n  if (!g_file_load_contents (file, NULL,\n                             &metadata_contents, length, NULL, NULL))\n    {\n      g_set_error (error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND,\n                   _(\"No overrides found for %s\"), app_id);\n      return NULL;\n    }\n\n  return metadata_contents;\n}\n\nGKeyFile *\nflatpak_load_override_keyfile (const char *app_id, gboolean user, GError **error)\n{\n  g_autofree char *metadata_contents = NULL;\n  gsize metadata_size;\n  g_autoptr(GKeyFile) metakey = g_key_file_new ();\n  g_autoptr(FlatpakDir) dir = NULL;\n\n  dir = user ? flatpak_dir_get_user () : flatpak_dir_get_system_default ();\n\n  metadata_contents = flatpak_dir_load_override (dir, app_id, &metadata_size, error);\n  if (metadata_contents == NULL)\n    return NULL;\n\n  if (!g_key_file_load_from_data (metakey,\n                                  metadata_contents,\n                                  metadata_size,\n                                  0, error))\n    return NULL;\n\n  return g_steal_pointer (&metakey);\n}\n\nFlatpakContext *\nflatpak_load_override_file (const char *app_id, gboolean user, GError **error)\n{\n  g_autoptr(FlatpakContext) overrides = flatpak_context_new ();\n  g_autoptr(GKeyFile) metakey = NULL;\n  g_autoptr(GError) my_error = NULL;\n\n  metakey = flatpak_load_override_keyfile (app_id, user, &my_error);\n  if (metakey == NULL)\n    {\n      if (!g_error_matches (my_error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND))\n        {\n          g_propagate_error (error, g_steal_pointer (&my_error));\n          return NULL;\n        }\n    }\n  else\n    {\n      if (!flatpak_context_load_metadata (overrides, metakey, error))\n        return NULL;\n    }\n\n  return g_steal_pointer (&overrides);\n}\n\ngboolean\nflatpak_save_override_keyfile (GKeyFile   *metakey,\n                               const char *app_id,\n                               gboolean    user,\n                               GError    **error)\n{\n  g_autoptr(GFile) base_dir = NULL;\n  g_autoptr(GFile) override_dir = NULL;\n  g_autoptr(GFile) file = NULL;\n  g_autofree char *filename = NULL;\n  g_autofree char *parent = NULL;\n\n  if (user)\n    base_dir = flatpak_get_user_base_dir_location ();\n  else\n    base_dir = flatpak_get_system_default_base_dir_location ();\n\n  override_dir = g_file_get_child (base_dir, \"overrides\");\n\n  if (app_id)\n    file = g_file_get_child (override_dir, app_id);\n  else\n    file = g_file_get_child (override_dir, \"global\");\n\n  filename = g_file_get_path (file);\n  parent = g_path_get_dirname (filename);\n  if (g_mkdir_with_parents (parent, 0755))\n    {\n      glnx_set_error_from_errno (error);\n      return FALSE;\n    }\n\n  return g_key_file_save_to_file (metakey, filename, error);\n}\n\ngboolean\nflatpak_remove_override_keyfile (const char *app_id,\n                                 gboolean    user,\n                                 GError    **error)\n{\n  g_autoptr(GFile) base_dir = NULL;\n  g_autoptr(GFile) override_dir = NULL;\n  g_autoptr(GFile) file = NULL;\n  g_autoptr(GError) local_error = NULL;\n\n  if (user)\n    base_dir = flatpak_get_user_base_dir_location ();\n  else\n    base_dir = flatpak_get_system_default_base_dir_location ();\n\n  override_dir = g_file_get_child (base_dir, \"overrides\");\n\n  if (app_id)\n    file = g_file_get_child (override_dir, app_id);\n  else\n    file = g_file_get_child (override_dir, \"global\");\n\n  if (!g_file_delete (file, NULL, &local_error) &&\n      !g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND))\n    {\n      g_propagate_error (error, g_steal_pointer (&local_error));\n      return FALSE;\n    }\n\n  return TRUE;\n}\n\n/* Note: passing a checksum only works here for non-sub-set deploys, not\n   e.g. a partial locale install, because it will not find the real\n   deploy directory. This is ok for now, because checksum is only\n   currently passed from flatpak_installation_launch() when launching\n   a particular version of an app, which is not used for locales. */\nFlatpakDeploy *\nflatpak_dir_load_deployed (FlatpakDir        *self,\n                           FlatpakDecomposed *ref,\n                           const char        *checksum,\n                           GCancellable      *cancellable,\n                           GError           **error)\n{\n  g_autoptr(GFile) deploy_dir = NULL;\n  g_autoptr(GKeyFile) metakey = NULL;\n  g_autoptr(GFile) metadata = NULL;\n  g_autofree char *metadata_contents = NULL;\n  FlatpakDeploy *deploy;\n  gsize metadata_size;\n\n  deploy_dir = flatpak_dir_get_if_deployed (self, ref, checksum, cancellable);\n  if (deploy_dir == NULL)\n    {\n      if (checksum == NULL)\n        g_set_error (error, FLATPAK_ERROR, FLATPAK_ERROR_NOT_INSTALLED,\n                     _(\"%s not installed\"), flatpak_decomposed_get_ref (ref));\n      else\n        g_set_error (error, FLATPAK_ERROR, FLATPAK_ERROR_NOT_INSTALLED,\n                     _(\"%s (commit %s) not installed\"), flatpak_decomposed_get_ref (ref), checksum);\n      return NULL;\n    }\n\n  if (!flatpak_dir_ensure_repo (self, cancellable, error))\n    return NULL;\n\n  metadata = g_file_get_child (deploy_dir, \"metadata\");\n  if (!g_file_load_contents (metadata, cancellable, &metadata_contents, &metadata_size, NULL, error))\n    return NULL;\n\n  metakey = g_key_file_new ();\n  if (!g_key_file_load_from_data (metakey, metadata_contents, metadata_size, 0, error))\n    return NULL;\n\n  deploy = flatpak_deploy_new (deploy_dir, ref, metakey, self->repo);\n\n  /* Only load system global overrides for system installed apps */\n  if (!self->user)\n    {\n      deploy->system_overrides = flatpak_load_override_file (NULL, FALSE, error);\n      if (deploy->system_overrides == NULL)\n        return NULL;\n    }\n\n  /* Always load user global overrides */\n  deploy->user_overrides = flatpak_load_override_file (NULL, TRUE, error);\n  if (deploy->user_overrides == NULL)\n    return NULL;\n\n  /* Only apps have app overrides */\n  if (flatpak_decomposed_is_app (ref))\n    {\n      g_autofree char *id = flatpak_decomposed_dup_id (ref);\n\n      /* Only load system overrides for system installed apps */\n      if (!self->user)\n        {\n          deploy->system_app_overrides = flatpak_load_override_file (id, FALSE, error);\n          if (deploy->system_app_overrides == NULL)\n            return NULL;\n        }\n\n      /* Always load user overrides */\n      deploy->user_app_overrides = flatpak_load_override_file (id, TRUE, error);\n      if (deploy->user_app_overrides == NULL)\n        return NULL;\n    }\n\n  return deploy;\n}\n\nGFile *\nflatpak_dir_get_deploy_dir (FlatpakDir *self,\n                            FlatpakDecomposed *ref)\n{\n  return g_file_resolve_relative_path (self->basedir, flatpak_decomposed_get_ref (ref));\n}\n\nchar *\nflatpak_dir_get_deploy_subdir (FlatpakDir          *self,\n                               const char          *checksum,\n                               const char * const * subpaths)\n{\n  if (subpaths == NULL || *subpaths == NULL)\n    return g_strdup (checksum);\n  else\n    {\n      GString *str = g_string_new (checksum);\n      int i;\n      for (i = 0; subpaths[i] != NULL; i++)\n        {\n          const char *s = subpaths[i];\n          g_string_append_c (str, '-');\n          while (*s)\n            {\n              if (*s != '/')\n                g_string_append_c (str, *s);\n              s++;\n            }\n        }\n      return g_string_free (str, FALSE);\n    }\n}\n\nGFile *\nflatpak_dir_get_unmaintained_extension_dir (FlatpakDir *self,\n                                            const char *name,\n                                            const char *arch,\n                                            const char *branch)\n{\n  g_autofree char *unmaintained_ref = NULL;\n\n  unmaintained_ref = g_build_filename (\"extension\", name, arch, branch, NULL);\n  return g_file_resolve_relative_path (self->basedir, unmaintained_ref);\n}\n\nGFile *\nflatpak_dir_get_exports_dir (FlatpakDir *self)\n{\n  return g_file_get_child (self->basedir, \"exports\");\n}\n\nGFile *\nflatpak_dir_get_removed_dir (FlatpakDir *self)\n{\n  return g_file_get_child (self->basedir, \".removed\");\n}\n\nGFile *\nflatpak_dir_get_sideload_repos_dir (FlatpakDir *self)\n{\n  return g_file_get_child (self->basedir, SIDELOAD_REPOS_DIR_NAME);\n}\n\nGFile *\nflatpak_dir_get_runtime_sideload_repos_dir (FlatpakDir *self)\n{\n  g_autoptr(GFile) base = g_file_new_for_path (get_run_dir_location ());\n  return g_file_get_child (base, SIDELOAD_REPOS_DIR_NAME);\n}\n\nOstreeRepo *\nflatpak_dir_get_repo (FlatpakDir *self)\n{\n  return self->repo;\n}\n\n\n/* This is an exclusive per flatpak installation file lock that is taken\n * whenever any config in the directory outside the repo is to be changed. For\n * instance deployments, overrides or active commit changes.\n *\n * For concurrency protection of the actual repository we rely on ostree\n * to do the right thing.\n */\ngboolean\nflatpak_dir_lock (FlatpakDir   *self,\n                  GLnxLockFile *lockfile,\n                  GCancellable *cancellable,\n                  GError      **error)\n{\n  g_autoptr(GFile) lock_file = g_file_get_child (flatpak_dir_get_path (self), \"lock\");\n  g_autofree char *lock_path = g_file_get_path (lock_file);\n\n  return glnx_make_lock_file (AT_FDCWD, lock_path, LOCK_EX, lockfile, error);\n}\n\n\n/* This is an lock that protects the repo itself. Any operation that\n * relies on objects not disappearing from the repo need to hold this\n * in a non-exclusive mode, while anything that can remove objects\n * (i.e. prune) need to take it in exclusive mode.\n *\n * The following operations depends on objects not disappearing:\n *  * pull into a staging directory (pre-existing objects are not downloaded)\n *  * moving a staging directory into the repo (no ref keeps the object alive during copy)\n *  * Deploying a ref (a parallel update + prune could cause objects to be removed)\n *\n * In practice this means we hold a shared lock during deploy and\n * pull, and an excusive lock during prune.\n */\ngboolean\nflatpak_dir_repo_lock (FlatpakDir   *self,\n                       GLnxLockFile *lockfile,\n                       int           operation,\n                       GCancellable *cancellable,\n                       GError      **error)\n{\n  g_autoptr(GFile) lock_file = g_file_get_child (flatpak_dir_get_path (self), \"repo-lock\");\n  g_autofree char *lock_path = g_file_get_path (lock_file);\n\n  return glnx_make_lock_file (AT_FDCWD, lock_path, operation, lockfile, error);\n}\n\nconst char *\nflatpak_deploy_data_get_origin (GBytes *deploy_data)\n{\n  VarDeployDataRef ref = var_deploy_data_from_bytes (deploy_data);\n  return var_deploy_data_get_origin (ref);\n}\n\nconst char *\nflatpak_deploy_data_get_commit (GBytes *deploy_data)\n{\n  VarDeployDataRef ref = var_deploy_data_from_bytes (deploy_data);\n  return var_deploy_data_get_commit (ref);\n}\n\ngint32\nflatpak_deploy_data_get_version (GBytes *deploy_data)\n{\n  VarDeployDataRef ref = var_deploy_data_from_bytes (deploy_data);\n  VarMetadataRef metadata = var_deploy_data_get_metadata (ref);\n\n  return var_metadata_lookup_int32 (metadata, \"deploy-version\", 0);\n}\n\n/* Note: This will return 0 if this is unset, which happens on deloy data updates, so ensure we handle that in all callers */\nguint64\nflatpak_deploy_data_get_timestamp (GBytes *deploy_data)\n{\n  VarDeployDataRef ref = var_deploy_data_from_bytes (deploy_data);\n  VarMetadataRef metadata = var_deploy_data_get_metadata (ref);\n\n  return var_metadata_lookup_uint64 (metadata, \"timestamp\", 0);\n}\n\nstatic const char *\nflatpak_deploy_data_get_string (GBytes *deploy_data, const char *key)\n{\n  VarDeployDataRef ref = var_deploy_data_from_bytes (deploy_data);\n  VarMetadataRef metadata = var_deploy_data_get_metadata (ref);\n\n  return var_metadata_lookup_string (metadata, key, NULL);\n}\n\nstatic const char *\nflatpak_deploy_data_get_localed_string (GBytes *deploy_data, const char *key)\n{\n  VarDeployDataRef ref = var_deploy_data_from_bytes (deploy_data);\n  VarMetadataRef metadata = var_deploy_data_get_metadata (ref);\n  const char * const * languages = g_get_language_names ();\n  int i;\n\n  for (i = 0; languages[i]; ++i)\n    {\n      g_autofree char *localed_key = NULL;\n      VarVariantRef value_v;\n\n      if (strcmp (languages[i], \"C\") == 0)\n        localed_key = g_strdup (key);\n      else\n        localed_key = g_strdup_printf (\"%s@%s\", key, languages[i]);\n\n      if (var_metadata_lookup (metadata, localed_key, NULL,  &value_v) &&\n          var_variant_is_type (value_v, G_VARIANT_TYPE_STRING))\n        return var_variant_get_string (value_v);\n    }\n\n  return NULL;\n}\n\nconst char *\nflatpak_deploy_data_get_alt_id (GBytes *deploy_data)\n{\n  return flatpak_deploy_data_get_string (deploy_data, \"alt-id\");\n}\n\nconst char *\nflatpak_deploy_data_get_eol (GBytes *deploy_data)\n{\n  return flatpak_deploy_data_get_string (deploy_data, \"eol\");\n}\n\nconst char *\nflatpak_deploy_data_get_eol_rebase (GBytes *deploy_data)\n{\n  return flatpak_deploy_data_get_string (deploy_data, \"eolr\");\n}\n\nconst char **\nflatpak_deploy_data_get_previous_ids (GBytes *deploy_data, gsize *length)\n{\n  VarDeployDataRef ref = var_deploy_data_from_bytes (deploy_data);\n  VarMetadataRef metadata = var_deploy_data_get_metadata (ref);\n  VarVariantRef previous_ids_v;\n\n  if (var_metadata_lookup (metadata, \"previous-ids\", NULL,  &previous_ids_v))\n    return var_arrayofstring_to_strv (var_arrayofstring_from_variant (previous_ids_v), length);\n\n  if (length != NULL)\n    *length = 0;\n\n  return NULL;\n}\n\nconst char *\nflatpak_deploy_data_get_runtime (GBytes *deploy_data)\n{\n  return flatpak_deploy_data_get_string (deploy_data, \"runtime\");\n}\n\nconst char *\nflatpak_deploy_data_get_extension_of (GBytes *deploy_data)\n{\n  return flatpak_deploy_data_get_string (deploy_data, \"extension-of\");\n}\n\nconst char *\nflatpak_deploy_data_get_appdata_name (GBytes *deploy_data)\n{\n  return flatpak_deploy_data_get_localed_string (deploy_data, \"appdata-name\");\n}\n\nconst char *\nflatpak_deploy_data_get_appdata_summary (GBytes *deploy_data)\n{\n  return flatpak_deploy_data_get_localed_string (deploy_data, \"appdata-summary\");\n}\n\nconst char *\nflatpak_deploy_data_get_appdata_version (GBytes *deploy_data)\n{\n  return flatpak_deploy_data_get_string (deploy_data, \"appdata-version\");\n}\n\nconst char *\nflatpak_deploy_data_get_appdata_license (GBytes *deploy_data)\n{\n  return flatpak_deploy_data_get_string (deploy_data, \"appdata-license\");\n}\n\nconst char *\nflatpak_deploy_data_get_appdata_content_rating_type (GBytes *deploy_data)\n{\n  VarDeployDataRef ref = var_deploy_data_from_bytes (deploy_data);\n  VarMetadataRef metadata = var_deploy_data_get_metadata (ref);\n  VarVariantRef rating_v;\n\n  if (var_metadata_lookup (metadata, \"appdata-content-rating\", NULL,  &rating_v))\n    {\n      VarContentRatingRef rating = var_content_rating_from_variant (rating_v);\n      return var_content_rating_get_rating_type (rating);\n    }\n\n  return NULL;\n}\n\nGHashTable *  /* (transfer container) (nullable) */\nflatpak_deploy_data_get_appdata_content_rating (GBytes *deploy_data)\n{\n  VarDeployDataRef ref = var_deploy_data_from_bytes (deploy_data);\n  VarMetadataRef metadata = var_deploy_data_get_metadata (ref);\n  VarVariantRef rating_v;\n  g_autoptr(GHashTable) content_rating = NULL;\n\n  if (var_metadata_lookup (metadata, \"appdata-content-rating\", NULL,  &rating_v))\n    {\n      VarContentRatingRef rating = var_content_rating_from_variant (rating_v);\n      VarRatingsRef ratings = var_content_rating_get_ratings (rating);\n      gsize len, i;\n\n      content_rating = g_hash_table_new_full (g_str_hash, g_str_equal, NULL, NULL);\n\n      len = var_ratings_get_length (ratings);\n      for (i = 0; i < len; i++)\n        {\n          VarRatingsEntryRef entry = var_ratings_get_at (ratings, i);\n\n          g_hash_table_insert (content_rating,\n                               (gpointer) g_intern_string (var_ratings_entry_get_key (entry)),\n                               (gpointer) g_intern_string (var_ratings_entry_get_value (entry)));\n        }\n    }\n\n  return g_steal_pointer (&content_rating);\n}\n\n/*<private>\n * flatpak_deploy_data_get_subpaths:\n *\n * Returns: (array zero-terminated=1) (transfer container): an array of constant strings\n **/\nconst char **\nflatpak_deploy_data_get_subpaths (GBytes *deploy_data)\n{\n  VarDeployDataRef ref = var_deploy_data_from_bytes (deploy_data);\n  return var_arrayofstring_to_strv (var_deploy_data_get_subpaths (ref), NULL);\n}\n\ngboolean\nflatpak_deploy_data_has_subpaths (GBytes *deploy_data)\n{\n  VarDeployDataRef ref = var_deploy_data_from_bytes (deploy_data);\n  VarArrayofstringRef subpaths = var_deploy_data_get_subpaths (ref);\n\n  return var_arrayofstring_get_length (subpaths) != 0;\n}\n\nguint64\nflatpak_deploy_data_get_installed_size (GBytes *deploy_data)\n{\n  VarDeployDataRef ref = var_deploy_data_from_bytes (deploy_data);\n  return var_deploy_data_get_installed_size (ref);\n}\n\nstatic char *\nread_appdata_xml_from_deploy_dir (GFile *deploy_dir, const char *id)\n{\n  g_autoptr(GFile) appdata_file = NULL;\n  g_autofree char *appdata_name = NULL;\n  g_autoptr(GFileInputStream) appdata_in = NULL;\n  gsize size;\n\n  appdata_name = g_strconcat (id, \".xml.gz\", NULL);\n  appdata_file  = flatpak_build_file (deploy_dir, \"files/share/app-info/xmls\", appdata_name, NULL);\n\n  appdata_in = g_file_read (appdata_file, NULL, NULL);\n  if (appdata_in)\n    {\n      g_autoptr(GZlibDecompressor) decompressor = g_zlib_decompressor_new (G_ZLIB_COMPRESSOR_FORMAT_GZIP);\n      g_autoptr(GInputStream) converter = g_converter_input_stream_new (G_INPUT_STREAM (appdata_in), G_CONVERTER (decompressor));\n      g_autoptr(GBytes) appdata_xml = NULL;\n\n      appdata_xml = flatpak_read_stream (converter, TRUE, NULL);\n      if (appdata_xml)\n        return g_bytes_unref_to_data (g_steal_pointer (&appdata_xml), &size);\n    }\n\n  return NULL;\n}\n\nstatic void\nadd_locale_metadata_string (GVariantDict *metadata_dict,\n                            const char   *keyname,\n                            GHashTable   *values)\n{\n  if (values == NULL)\n    return;\n\n  GLNX_HASH_TABLE_FOREACH_KV (values, const char *, locale, const char *, value)\n  {\n    const char *key;\n    g_autofree char *key_free = NULL;\n\n    if (strcmp (locale, \"C\") == 0)\n      key = keyname;\n    else\n      {\n        key_free = g_strdup_printf (\"%s@%s\", keyname, locale);\n        key = key_free;\n      }\n\n    g_variant_dict_insert_value (metadata_dict, key,\n                                 g_variant_new_string (value));\n  }\n}\n\n/* Convert @content_rating_type and @content_rating to a floating #GVariant of\n * type `(sa{ss})`. */\nstatic GVariant *\nappdata_content_rating_to_variant (const char *content_rating_type,\n                                   GHashTable *content_rating)\n{\n  g_autoptr(GVariantBuilder) builder = g_variant_builder_new (G_VARIANT_TYPE (\"(sa{ss})\"));\n  GHashTableIter iter;\n  gpointer key, value;\n\n  g_variant_builder_add (builder, \"s\", content_rating_type);\n  g_variant_builder_open (builder, G_VARIANT_TYPE (\"a{ss}\"));\n\n  g_hash_table_iter_init (&iter, content_rating);\n\n  while (g_hash_table_iter_next (&iter, &key, &value))\n    {\n      const char *id = key, *val = value;\n      g_variant_builder_add (builder, \"{ss}\", id, val);\n    }\n\n  g_variant_builder_close (builder);\n\n  return g_variant_builder_end (builder);\n}\n\nstatic void\nadd_appdata_to_deploy_data (GVariantDict *metadata_dict,\n                            GFile        *deploy_dir,\n                            const char   *id)\n{\n  g_autofree char *appdata_xml = NULL;\n  g_autoptr(GHashTable) names = NULL;\n  g_autoptr(GHashTable) comments = NULL;\n  g_autofree char *version = NULL;\n  g_autofree char *license = NULL;\n  g_autofree char *content_rating_type = NULL;\n  g_autoptr(GHashTable) content_rating = NULL;\n\n  appdata_xml = read_appdata_xml_from_deploy_dir (deploy_dir, id);\n  if (appdata_xml == NULL)\n    return;\n\n  if (flatpak_parse_appdata (appdata_xml, id, &names, &comments, &version, &license,\n                             &content_rating_type, &content_rating))\n    {\n      add_locale_metadata_string (metadata_dict, \"appdata-name\", names);\n      add_locale_metadata_string (metadata_dict, \"appdata-summary\", comments);\n      if (version)\n        g_variant_dict_insert_value (metadata_dict, \"appdata-version\",\n                                     g_variant_new_string (version));\n      if (license)\n        g_variant_dict_insert_value (metadata_dict, \"appdata-license\",\n                                     g_variant_new_string (license));\n      if (content_rating_type != NULL && content_rating != NULL)\n        g_variant_dict_insert_value (metadata_dict, \"appdata-content-rating\",\n                                     appdata_content_rating_to_variant (content_rating_type, content_rating));\n    }\n}\n\nstatic void\nadd_commit_metadata_to_deploy_data (GVariantDict *metadata_dict,\n                                    GVariant     *commit_metadata)\n{\n  const char *alt_id = NULL;\n  const char *eol = NULL;\n  const char *eol_rebase = NULL;\n\n  g_variant_lookup (commit_metadata, \"xa.alt-id\", \"&s\", &alt_id);\n  g_variant_lookup (commit_metadata, OSTREE_COMMIT_META_KEY_ENDOFLIFE, \"&s\", &eol);\n  g_variant_lookup (commit_metadata, OSTREE_COMMIT_META_KEY_ENDOFLIFE_REBASE, \"&s\", &eol_rebase);\n\n  if (alt_id)\n    g_variant_dict_insert_value (metadata_dict, \"alt-id\",\n                                 g_variant_new_string (alt_id));\n  if (eol)\n    g_variant_dict_insert_value (metadata_dict, \"eol\",\n                                 g_variant_new_string (eol));\n  if (eol_rebase)\n    g_variant_dict_insert_value (metadata_dict, \"eolr\",\n                                 g_variant_new_string (eol_rebase));\n}\n\nstatic void\nadd_metadata_to_deploy_data (GVariantDict *metadata_dict,\n                             GKeyFile     *keyfile)\n{\n  g_autofree char *application_runtime = NULL;\n  g_autofree char *extension_of = NULL;\n\n  application_runtime = g_key_file_get_string (keyfile,\n                                               FLATPAK_METADATA_GROUP_APPLICATION,\n                                               FLATPAK_METADATA_KEY_RUNTIME, NULL);\n  extension_of = g_key_file_get_string (keyfile,\n                                        FLATPAK_METADATA_GROUP_EXTENSION_OF,\n                                        FLATPAK_METADATA_KEY_REF, NULL);\n\n  if (application_runtime)\n    g_variant_dict_insert_value (metadata_dict, \"runtime\",\n                                 g_variant_new_string (application_runtime));\n  if (extension_of)\n    g_variant_dict_insert_value (metadata_dict, \"extension-of\",\n                                 g_variant_new_string (extension_of));\n}\n\nstatic GBytes *\nflatpak_dir_new_deploy_data (FlatpakDir         *self,\n                             GFile              *deploy_dir,\n                             GVariant           *commit_data,\n                             GVariant           *commit_metadata,\n                             GKeyFile           *metadata,\n                             const char         *id,\n                             const char         *origin,\n                             const char         *commit,\n                             char              **subpaths,\n                             guint64             installed_size,\n                             const char * const *previous_ids)\n{\n  char *empty_subpaths[] = {NULL};\n  g_auto(GVariantDict) metadata_dict = FLATPAK_VARIANT_DICT_INITIALIZER;\n  g_autoptr(GVariant) res = NULL;\n\n  g_variant_dict_init (&metadata_dict, NULL);\n  g_variant_dict_insert_value (&metadata_dict, \"deploy-version\",\n                               g_variant_new_int32 (FLATPAK_DEPLOY_VERSION_CURRENT));\n  g_variant_dict_insert_value (&metadata_dict, \"timestamp\",\n                               g_variant_new_uint64 (ostree_commit_get_timestamp (commit_data)));\n\n  if (previous_ids)\n    g_variant_dict_insert_value (&metadata_dict, \"previous-ids\",\n                                 g_variant_new_strv (previous_ids, -1));\n\n  add_commit_metadata_to_deploy_data (&metadata_dict, commit_metadata);\n  add_metadata_to_deploy_data (&metadata_dict, metadata);\n  add_appdata_to_deploy_data (&metadata_dict, deploy_dir, id);\n\n  res = g_variant_ref_sink (g_variant_new (\"(ss^ast@a{sv})\",\n                                           origin,\n                                           commit,\n                                           subpaths ? subpaths : empty_subpaths,\n                                           GUINT64_TO_BE (installed_size),\n                                           g_variant_dict_end (&metadata_dict)));\n  return g_variant_get_data_as_bytes (res);\n}\n\nstatic GBytes *\nupgrade_deploy_data (GBytes             *deploy_data,\n                     GFile              *deploy_dir,\n                     FlatpakDecomposed  *ref,\n                     OstreeRepo         *repo,\n                     GCancellable       *cancellable,\n                     GError            **error)\n{\n  VarDeployDataRef deploy_ref = var_deploy_data_from_bytes (deploy_data);\n  g_autoptr(GVariant) metadata = g_variant_ref_sink (var_metadata_peek_as_gvariant (var_deploy_data_get_metadata (deploy_ref)));\n  g_auto(GVariantDict) metadata_dict = FLATPAK_VARIANT_DICT_INITIALIZER;\n  g_autofree const char **subpaths = NULL;\n  g_autoptr(GVariant) res = NULL;\n  int i, n, old_version;\n\n  g_variant_dict_init (&metadata_dict, NULL);\n  g_variant_dict_insert_value (&metadata_dict, \"deploy-version\",\n                               g_variant_new_int32 (FLATPAK_DEPLOY_VERSION_CURRENT));\n\n  /* Copy all metadata except version from old */\n  n = g_variant_n_children (metadata);\n  for (i = 0; i < n; i++)\n    {\n      const char *key;\n      g_autoptr(GVariant) value = NULL;\n\n      g_variant_get_child (metadata, i, \"{&s@v}\", &key, &value);\n      if (strcmp (key, \"deploy-version\") == 0)\n        continue;\n      g_variant_dict_insert_value (&metadata_dict, key, value);\n    }\n\n  old_version = flatpak_deploy_data_get_version (deploy_data);\n  if (old_version < 1)\n    {\n      g_autofree char *id = flatpak_decomposed_dup_id (ref);\n      add_appdata_to_deploy_data (&metadata_dict, deploy_dir, id);\n    }\n\n  if (old_version < 3)\n    {\n      /* We don't know what timestamp to use here, use 0 and special case that for update checks */\n      g_variant_dict_insert_value (&metadata_dict, \"timestamp\",\n                                   g_variant_new_uint64 (0));\n    }\n\n  /* Deploy versions older than 4 might have some of the below fields, but it's\n   * not guaranteed if the deploy was first created with an old Flatpak version\n   */\n  if (old_version < 4)\n    {\n      const char *commit;\n      g_autoptr(GVariant) commit_data = NULL;\n      g_autoptr(GVariant) commit_metadata = NULL;\n      g_autoptr(GKeyFile) keyfile = NULL;\n      g_autoptr(GFile) metadata_file = NULL;\n      g_autofree char *metadata_contents = NULL;\n      g_autofree char *id = flatpak_decomposed_dup_id (ref);\n\n      /* Add fields from commit metadata to deploy */\n      commit = flatpak_deploy_data_get_commit (deploy_data);\n      if (!ostree_repo_load_commit (repo, commit, &commit_data, NULL, error))\n        return NULL;\n      commit_metadata = g_variant_get_child_value (commit_data, 0);\n      add_commit_metadata_to_deploy_data (&metadata_dict, commit_metadata);\n\n      /* Add fields from metadata file to deploy */\n      keyfile = g_key_file_new ();\n      metadata_file = g_file_resolve_relative_path (deploy_dir, \"metadata\");\n      if (!g_file_load_contents (metadata_file, cancellable,\n                                 &metadata_contents, NULL, NULL, error))\n        return NULL;\n      if (!g_key_file_load_from_data (keyfile, metadata_contents, -1, 0, error))\n        return NULL;\n      add_metadata_to_deploy_data (&metadata_dict, keyfile);\n\n      /* Add fields from appdata to deploy, since appdata-content-rating wasn't\n       * added when upgrading from version 2 as it should have been\n       */\n      if (old_version >= 1)\n        add_appdata_to_deploy_data (&metadata_dict, deploy_dir, id);\n    }\n\n  subpaths = flatpak_deploy_data_get_subpaths (deploy_data);\n  res = g_variant_ref_sink (g_variant_new (\"(ss^ast@a{sv})\",\n                                           flatpak_deploy_data_get_origin (deploy_data),\n                                           flatpak_deploy_data_get_commit (deploy_data),\n                                           subpaths,\n                                           GUINT64_TO_BE (flatpak_deploy_data_get_installed_size (deploy_data)),\n                                           g_variant_dict_end (&metadata_dict)));\n  return g_variant_get_data_as_bytes (res);\n}\n\nGBytes *\nflatpak_dir_get_deploy_data (FlatpakDir        *self,\n                             FlatpakDecomposed *ref,\n                             int                required_version,\n                             GCancellable      *cancellable,\n                             GError           **error)\n{\n  g_autoptr(GFile) deploy_dir = NULL;\n\n  deploy_dir = flatpak_dir_get_if_deployed (self, ref, NULL, cancellable);\n  if (deploy_dir == NULL)\n    {\n      g_set_error (error, FLATPAK_ERROR, FLATPAK_ERROR_NOT_INSTALLED,\n                   _(\"%s not installed\"), flatpak_decomposed_get_ref (ref));\n      return NULL;\n    }\n\n  if (!flatpak_dir_ensure_repo (self, cancellable, error))\n    return NULL;\n\n  return flatpak_load_deploy_data (deploy_dir,\n                                   ref,\n                                   self->repo,\n                                   required_version,\n                                   cancellable,\n                                   error);\n}\n\nchar *\nflatpak_dir_get_origin (FlatpakDir        *self,\n                        FlatpakDecomposed *ref,\n                        GCancellable      *cancellable,\n                        GError           **error)\n{\n  g_autoptr(GBytes) deploy_data = NULL;\n\n  deploy_data = flatpak_dir_get_deploy_data (self, ref, FLATPAK_DEPLOY_VERSION_ANY,\n                                             cancellable, error);\n  if (deploy_data == NULL)\n    return NULL;\n\n  return g_strdup (flatpak_deploy_data_get_origin (deploy_data));\n}\n\ngboolean\nflatpak_dir_ensure_path (FlatpakDir   *self,\n                         GCancellable *cancellable,\n                         GError      **error)\n{\n  /* In the system case, we use default perms */\n  if (!self->user)\n    return flatpak_mkdir_p (self->basedir, cancellable, error);\n  else\n    {\n      /* First make the parent */\n      g_autoptr(GFile) parent = g_file_get_parent (self->basedir);\n      if (!flatpak_mkdir_p (parent, cancellable, error))\n        return FALSE;\n      glnx_autofd int parent_dfd = -1;\n      if (!glnx_opendirat (AT_FDCWD, flatpak_file_get_path_cached (parent), TRUE,\n                           &parent_dfd, error))\n        return FALSE;\n      g_autofree char *name = g_file_get_basename (self->basedir);\n      /* Use 0700 in the user case to neuter any suid or world-writable\n       * bits that happen to be in content; see\n       * https://github.com/flatpak/flatpak/pull/837\n       */\n      if (mkdirat (parent_dfd, name, 0700) < 0)\n        {\n          if (errno == EEXIST)\n            {\n              /* And fix up any existing installs that had too-wide perms */\n              struct stat stbuf;\n              if (fstatat (parent_dfd, name, &stbuf, 0) < 0)\n                return glnx_throw_errno_prefix (error, \"fstatat\");\n              if (stbuf.st_mode & S_IXOTH)\n                {\n                  if (fchmodat (parent_dfd, name, 0700, 0) < 0)\n                    return glnx_throw_errno_prefix (error, \"fchmodat\");\n                }\n            }\n          else\n            return glnx_throw_errno_prefix (error, \"mkdirat\");\n        }\n\n      return TRUE;\n    }\n}\n\ngboolean\nflatpak_dir_migrate_config (FlatpakDir   *self,\n                            gboolean     *changed,\n                            GCancellable *cancellable,\n                            GError      **error)\n{\n  g_auto(GStrv) remotes = NULL;\n  g_autoptr(GKeyFile) config = NULL;\n  int i;\n\n  if (changed != NULL)\n    *changed = FALSE;\n\n  /* Only do anything if it exists */\n  if (!flatpak_dir_maybe_ensure_repo (self, NULL, NULL))\n    return TRUE;\n\n  remotes = flatpak_dir_list_remotes (self, cancellable, NULL);\n  if (remotes == NULL)\n    return TRUE;\n\n  /* Enable gpg-verify-summary for all remotes with a collection id *and* gpg-verify set, because\n   * we want to use summary verification, but older versions of collection-id didn't work with it */\n  for (i = 0; remotes != NULL && remotes[i] != NULL; i++)\n    {\n      g_autofree char *remote_collection_id = NULL;\n      const char *remote = remotes[i];\n      gboolean gpg_verify_summary;\n      gboolean gpg_verify;\n\n      if (flatpak_dir_get_remote_disabled (self, remote))\n        continue;\n\n      remote_collection_id = flatpak_dir_get_remote_collection_id (self, remotes[i]);\n      if (remote_collection_id == NULL)\n        continue;\n\n      if (!ostree_repo_remote_get_gpg_verify_summary (self->repo, remote, &gpg_verify_summary, NULL))\n        continue;\n\n      if (!ostree_repo_remote_get_gpg_verify (self->repo, remote, &gpg_verify, NULL))\n        continue;\n\n      if (gpg_verify && !gpg_verify_summary)\n        {\n          g_autofree char *group = g_strdup_printf (\"remote \\\"%s\\\"\", remote);\n          if (config == NULL)\n            config = ostree_repo_copy_config (flatpak_dir_get_repo (self));\n\n          g_debug (\"Migrating remote '%s' to gpg-verify-summary\", remote);\n          g_key_file_set_boolean (config, group, \"gpg-verify-summary\", TRUE);\n        }\n    }\n\n  if (config != NULL)\n    {\n      if (flatpak_dir_use_system_helper (self, NULL))\n        {\n          g_autoptr(GError) local_error = NULL;\n          const char *installation = flatpak_dir_get_id (self);\n\n          if (!flatpak_dir_system_helper_call_ensure_repo (self,\n                                                           FLATPAK_HELPER_ENSURE_REPO_FLAGS_NONE,\n                                                           installation ? installation : \"\",\n                                                           NULL, &local_error))\n            g_debug (\"Failed to migrate system config: %s\", local_error->message);\n        }\n      else\n        {\n          if (!ostree_repo_write_config (self->repo, config, error))\n            return FALSE;\n        }\n\n      if (changed != NULL)\n        *changed = TRUE;\n    }\n\n  return TRUE;\n}\n\n/* Warning: This is not threadsafe, don't use in libflatpak */\ngboolean\nflatpak_dir_recreate_repo (FlatpakDir   *self,\n                           GCancellable *cancellable,\n                           GError      **error)\n{\n  gboolean res;\n  OstreeRepo *old_repo = g_steal_pointer (&self->repo);\n\n  /* This is also set by ensure repo, so clear it too */\n  g_clear_object (&self->cache_dir);\n\n  res = flatpak_dir_ensure_repo (self, cancellable, error);\n  g_clear_object (&old_repo);\n\n  G_LOCK (config_cache);\n\n  g_clear_pointer (&self->masked, g_regex_unref);\n  g_clear_pointer (&self->pinned, g_regex_unref);\n\n  G_UNLOCK (config_cache);\n\n  return res;\n}\n\nstatic void\ncopy_remote_config (GKeyFile *config,\n                    GKeyFile *group_config,\n                    const char *remote_name)\n{\n  g_auto(GStrv) keys = NULL;\n  g_autofree char *group = g_strdup_printf (\"remote \\\"%s\\\"\", remote_name);\n  int i;\n\n  g_key_file_remove_group (config, group, NULL);\n\n  keys = g_key_file_get_keys (group_config, group, NULL, NULL);\n  if (keys == NULL)\n    return;\n\n  for (i = 0; keys[i] != NULL; i++)\n    {\n      g_autofree gchar *value = g_key_file_get_value (group_config, group, keys[i], NULL);\n      if (value &&\n          /* Canonicalize empty filter to unset */\n          (strcmp (keys[i], \"xa.filter\") != 0 ||\n           *value != 0))\n        g_key_file_set_value (config, group, keys[i], value);\n    }\n}\n\nstatic GHashTable *\n_flatpak_dir_find_new_flatpakrepos (FlatpakDir *self, OstreeRepo *repo)\n{\n  g_autoptr(GHashTable) flatpakrepos = NULL;\n  g_autoptr(GFile) conf_dir = NULL;\n  g_autoptr(GFileEnumerator) dir_enum = NULL;\n  g_autoptr(GError) my_error = NULL;\n  g_autofree char *config_dir = NULL;\n  g_auto(GStrv) remotes = NULL;\n  g_auto(GStrv) applied_remotes = NULL;\n\n  g_assert (repo != NULL);\n\n  /* Predefined remotes only applies for the default system installation */\n  if (self->user ||\n      (self->extra_data != NULL &&\n       strcmp (self->extra_data->id, SYSTEM_DIR_DEFAULT_ID) != 0))\n    return NULL;\n\n  config_dir = g_strdup_printf (\"%s/%s\",\n                                get_config_dir_location (),\n                                SYSCONF_REMOTES_DIR);\n  conf_dir = g_file_new_for_path (config_dir);\n  dir_enum = g_file_enumerate_children (conf_dir,\n                                        G_FILE_ATTRIBUTE_STANDARD_NAME \",\" G_FILE_ATTRIBUTE_STANDARD_TYPE,\n                                        G_FILE_QUERY_INFO_NONE,\n                                        NULL, &my_error);\n  if (my_error != NULL)\n    return NULL;\n\n  remotes = ostree_repo_remote_list (repo, NULL);\n  applied_remotes = g_key_file_get_string_list (ostree_repo_get_config (repo),\n                                                \"core\", \"xa.applied-remotes\", NULL, NULL);\n\n  while (TRUE)\n    {\n      GFileInfo *file_info;\n      GFile *path;\n      const char *name;\n      guint32 type;\n\n      if (!g_file_enumerator_iterate (dir_enum, &file_info, &path,\n                                      NULL, &my_error))\n        {\n          g_debug (\"Unexpected error reading file in %s: %s\",\n                   config_dir, my_error->message);\n          break;\n        }\n\n      if (file_info == NULL)\n        break;\n\n      name = g_file_info_get_name (file_info);\n      type = g_file_info_get_file_type (file_info);\n\n      if (type == G_FILE_TYPE_REGULAR && g_str_has_suffix (name, SYSCONF_REMOTES_FILE_EXT))\n        {\n          g_autofree char *remote_name = g_strndup (name, strlen (name) - strlen (SYSCONF_REMOTES_FILE_EXT));\n\n          if (remotes && g_strv_contains ((const char * const *)remotes, remote_name))\n            continue;\n\n          if (applied_remotes && g_strv_contains ((const char * const *)applied_remotes, remote_name))\n            continue;\n\n          if (flatpakrepos == NULL)\n            flatpakrepos = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, g_object_unref);\n\n          g_hash_table_insert (flatpakrepos, g_steal_pointer (&remote_name), g_file_enumerator_get_child (dir_enum, file_info));\n        }\n    }\n\n  return g_steal_pointer (&flatpakrepos);\n}\n\nstatic gboolean\napply_new_flatpakrepo (const char *remote_name,\n                       GFile      *file,\n                       OstreeRepo *repo,\n                       GError    **error)\n{\n  g_autoptr(GBytes) gpg_data = NULL;\n  g_autoptr(GKeyFile) group_config = NULL;\n  g_autoptr(GKeyFile) keyfile = g_key_file_new ();\n  g_autoptr(GError) local_error = NULL;\n  g_autoptr(GKeyFile) new_config = NULL;\n  g_auto(GStrv) old_applied_remotes = NULL;\n  g_autoptr(GPtrArray) new_applied_remotes = NULL;\n  int i;\n\n  if (!g_key_file_load_from_file (keyfile, flatpak_file_get_path_cached (file), 0, &local_error))\n    {\n      flatpak_fail (error, _(\"Can't load file %s: %s\\n\"), flatpak_file_get_path_cached (file), local_error->message);\n      return FALSE;\n    }\n\n  group_config = flatpak_parse_repofile (remote_name, FALSE, keyfile, &gpg_data, NULL, &local_error);\n  if (group_config == NULL)\n    {\n      flatpak_fail (error, _(\"Error parsing system flatpakrepo file for %s: %s\"), remote_name, local_error->message);\n      return FALSE;\n    }\n\n  new_config = ostree_repo_copy_config (repo);\n\n  old_applied_remotes = g_key_file_get_string_list (new_config, \"core\", \"xa.applied-remotes\", NULL, NULL);\n\n  copy_remote_config (new_config, group_config, remote_name);\n\n  new_applied_remotes = g_ptr_array_new_with_free_func (g_free);\n  for (i = 0; old_applied_remotes != NULL && old_applied_remotes[i] != NULL; i++)\n    g_ptr_array_add (new_applied_remotes, g_strdup (old_applied_remotes[i]));\n\n  g_ptr_array_add (new_applied_remotes, g_strdup (remote_name));\n\n  g_key_file_set_string_list (new_config, \"core\", \"xa.applied-remotes\",\n                              (const char * const *) new_applied_remotes->pdata, new_applied_remotes->len);\n\n  if (!ostree_repo_write_config (repo, new_config, error))\n    return FALSE;\n\n  if (!ostree_repo_reload_config (repo, NULL, error))\n    return FALSE;\n\n  if (gpg_data != NULL)\n    {\n      g_autoptr(GInputStream) input_stream = g_memory_input_stream_new_from_bytes (gpg_data);\n      guint imported = 0;\n\n      if (!ostree_repo_remote_gpg_import (repo, remote_name, input_stream,\n                                          NULL, &imported, NULL, error))\n        return FALSE;\n\n      g_debug (\"Imported %u GPG key%s to remote \\\"%s\\\"\", imported, (imported == 1) ? \"\" : \"s\", remote_name);\n    }\n\n  return TRUE;\n}\n\nstatic gboolean\n_flatpak_dir_ensure_repo (FlatpakDir   *self,\n                          gboolean      allow_empty,\n                          GCancellable *cancellable,\n                          GError      **error)\n{\n  g_autoptr(GFile) repodir = NULL;\n  g_autoptr(OstreeRepo) repo = NULL;\n  g_autoptr(GError) my_error = NULL;\n  g_autoptr(GFile) cache_dir = NULL;\n  g_autoptr(GHashTable) flatpakrepos = NULL;\n\n  if (self->repo != NULL)\n    return TRUE;\n\n  if (!g_file_query_exists (self->basedir, cancellable))\n    {\n      if (flatpak_dir_use_system_helper (self, NULL))\n        {\n          g_autoptr(GError) local_error = NULL;\n          const char *installation = flatpak_dir_get_id (self);\n\n          if (!flatpak_dir_system_helper_call_ensure_repo (self,\n                                                           FLATPAK_HELPER_ENSURE_REPO_FLAGS_NONE,\n                                                           installation ? installation : \"\",\n                                                           NULL, &local_error))\n            {\n              if (allow_empty)\n                return TRUE;\n\n              g_propagate_error (error, g_steal_pointer (&local_error));\n              return FALSE;\n            }\n        }\n      else\n        {\n          g_autoptr(GError) local_error = NULL;\n          if (!flatpak_dir_ensure_path (self, cancellable, &local_error))\n            {\n              if (allow_empty)\n                return TRUE;\n\n              g_propagate_error (error, g_steal_pointer (&local_error));\n              return FALSE;\n            }\n        }\n    }\n\n  repodir = g_file_get_child (self->basedir, \"repo\");\n\n  repo = ostree_repo_new (repodir);\n\n  if (!g_file_query_exists (repodir, cancellable))\n    {\n      /* We always use bare-user-only these days, except old installations\n         that still user bare-user */\n      OstreeRepoMode mode = OSTREE_REPO_MODE_BARE_USER_ONLY;\n\n      if (!ostree_repo_create (repo, mode, cancellable, &my_error))\n        {\n          flatpak_rm_rf (repodir, cancellable, NULL);\n\n          if (allow_empty)\n            return TRUE;\n\n          g_propagate_error (error, g_steal_pointer (&my_error));\n          return FALSE;\n        }\n\n      /* Create .changed file early to avoid polling non-existing file in monitor */\n      if (!flatpak_dir_mark_changed (self, &my_error))\n        {\n          g_warning (\"Error marking directory as changed: %s\", my_error->message);\n          g_clear_error (&my_error);\n        }\n    }\n  else\n    {\n      if (!ostree_repo_open (repo, cancellable, error))\n        {\n          g_autofree char *repopath = NULL;\n\n          repopath = g_file_get_path (repodir);\n          g_prefix_error (error, _(\"While opening repository %s: \"), repopath);\n          return FALSE;\n        }\n    }\n\n  /* In the system-helper case we're directly using the global repo, and we can't write any\n   * caches for summaries there, so we need to set a custom dir for this. Note, as per #3303\n   * this has to be called after ostree_repo_open() in order to the custom cachedir being\n   * overridden if the system dir is writable (like in the testsuite).\n   */\n  if (flatpak_dir_use_system_helper (self, NULL))\n    {\n      g_autofree char *cache_path = NULL;\n\n      cache_dir = flatpak_ensure_user_cache_dir_location (error);\n      if (cache_dir == NULL)\n        return FALSE;\n\n      cache_path = g_file_get_path (cache_dir);\n      if (!ostree_repo_set_cache_dir (repo,\n                                      AT_FDCWD, cache_path,\n                                      cancellable, error))\n        return FALSE;\n    }\n\n  /* Earlier flatpak used to reset min-free-space-percent to 0 every time, but now we\n   * favor min-free-space-size instead of it (See below).\n   */\n  if (!flatpak_dir_use_system_helper (self, NULL))\n    {\n      GKeyFile *orig_config = NULL;\n      g_autoptr(GKeyFile) new_config = NULL;\n      g_autofree char *orig_min_free_space_percent = NULL;\n      g_autofree char *orig_min_free_space_size = NULL;\n      const char *min_free_space_size = \"500MB\";\n      guint64 min_free_space_percent_int;\n\n      orig_config = ostree_repo_get_config (repo);\n      orig_min_free_space_percent = g_key_file_get_value (orig_config, \"core\", \"min-free-space-percent\", NULL);\n      orig_min_free_space_size = g_key_file_get_value (orig_config, \"core\", \"min-free-space-size\", NULL);\n\n      if (orig_min_free_space_size == NULL)\n        new_config = ostree_repo_copy_config (repo);\n\n      /* Scrap previously written min-free-space-percent=0 and replace it with min-free-space-size */\n      if (orig_min_free_space_size == NULL &&\n          orig_min_free_space_percent != NULL &&\n          flatpak_utils_ascii_string_to_unsigned (orig_min_free_space_percent, 10,\n                                                  0, G_MAXUINT64,\n                                                  &min_free_space_percent_int, &my_error))\n        {\n          if (min_free_space_percent_int == 0)\n            {\n              g_key_file_remove_key (new_config, \"core\", \"min-free-space-percent\", NULL);\n              g_key_file_set_string (new_config, \"core\", \"min-free-space-size\", min_free_space_size);\n            }\n        }\n      else if (my_error != NULL)\n        {\n          g_propagate_error (error, g_steal_pointer (&my_error));\n          return FALSE;\n        }\n\n      if (orig_min_free_space_size == NULL &&\n          orig_min_free_space_percent == NULL)\n        g_key_file_set_string (new_config, \"core\", \"min-free-space-size\", min_free_space_size);\n\n      if (new_config != NULL)\n        {\n          if (!ostree_repo_write_config (repo, new_config, error))\n            return FALSE;\n\n          if (!ostree_repo_reload_config (repo, cancellable, error))\n            return FALSE;\n        }\n    }\n\n  flatpakrepos = _flatpak_dir_find_new_flatpakrepos (self, repo);\n  if (flatpakrepos)\n    {\n      if (flatpak_dir_use_system_helper (self, NULL))\n        {\n          const char *installation = flatpak_dir_get_id (self);\n          if (!flatpak_dir_system_helper_call_ensure_repo (self,\n                                                           FLATPAK_HELPER_ENSURE_REPO_FLAGS_NONE,\n                                                           installation ? installation : \"\",\n                                                           NULL, &my_error))\n            {\n              if (allow_empty)\n                return TRUE;\n\n              g_propagate_error (error, g_steal_pointer (&my_error));\n              return FALSE;\n            }\n\n          if (!ostree_repo_reload_config (repo, cancellable, error))\n            return FALSE;\n        }\n      else\n        {\n          GLNX_HASH_TABLE_FOREACH_KV (flatpakrepos, const char *, remote_name, GFile *, file)\n            {\n              if (!apply_new_flatpakrepo (remote_name, file, repo, error))\n                return FALSE;\n            }\n        }\n    }\n\n\n  if (cache_dir == NULL)\n    cache_dir = g_file_get_child (repodir, \"tmp/cache\");\n\n  /* Make sure we didn't reenter weirdly */\n  g_assert (self->repo == NULL);\n  self->repo = g_object_ref (repo);\n  self->cache_dir = g_object_ref (cache_dir);\n\n  return TRUE;\n}\n\ngboolean\nflatpak_dir_ensure_repo (FlatpakDir   *self,\n                         GCancellable *cancellable,\n                         GError      **error)\n{\n  return _flatpak_dir_ensure_repo (self, FALSE, cancellable, error);\n}\n\ngboolean\nflatpak_dir_maybe_ensure_repo (FlatpakDir   *self,\n                               GCancellable *cancellable,\n                               GError      **error)\n{\n  return _flatpak_dir_ensure_repo (self, TRUE, cancellable, error);\n}\n\nstatic gboolean\n_flatpak_dir_reload_config (FlatpakDir   *self,\n                            GCancellable *cancellable,\n                            GError      **error)\n{\n  if (self->repo)\n    {\n      if (!ostree_repo_reload_config (self->repo, cancellable, error))\n        return FALSE;\n    }\n\n  /* Clear cached stuff from repo config */\n  G_LOCK (config_cache);\n\n  g_clear_pointer (&self->masked, g_regex_unref);\n  g_clear_pointer (&self->pinned, g_regex_unref);\n\n  G_UNLOCK (config_cache);\n  return TRUE;\n}\n\nchar *\nflatpak_dir_get_config (FlatpakDir *self,\n                        const char *key,\n                        GError    **error)\n{\n  GKeyFile *config;\n  g_autofree char *ostree_key = NULL;\n\n  if (!flatpak_dir_maybe_ensure_repo (self, NULL, error))\n    return NULL;\n\n  if (self->repo == NULL)\n    {\n      g_set_error (error, G_KEY_FILE_ERROR, G_KEY_FILE_ERROR_KEY_NOT_FOUND,\n                   _(\"The config key %s is not set\"), key);\n      return NULL;\n    }\n\n  config = ostree_repo_get_config (self->repo);\n  ostree_key = g_strconcat (\"xa.\", key, NULL);\n\n  return g_key_file_get_string (config, \"core\", ostree_key, error);\n}\n\nGPtrArray *\nflatpak_dir_get_config_patterns (FlatpakDir *dir, const char *key)\n{\n  g_autoptr(GPtrArray) patterns = NULL;\n  g_autofree char *key_value = NULL;\n  int i;\n\n  patterns = g_ptr_array_new_with_free_func (g_free);\n\n  key_value = flatpak_dir_get_config (dir, key, NULL);\n  if (key_value)\n    {\n      g_auto(GStrv) oldv = g_strsplit (key_value, \";\", -1);\n\n      for (i = 0; oldv[i] != NULL; i++)\n        {\n          const char *old = oldv[i];\n\n          if (*old != 0 && !flatpak_g_ptr_array_contains_string (patterns, old))\n            g_ptr_array_add (patterns, g_strdup (old));\n        }\n    }\n\n  return g_steal_pointer (&patterns);\n}\n\ngboolean\nflatpak_dir_set_config (FlatpakDir *self,\n                        const char *key,\n                        const char *value,\n                        GError    **error)\n{\n  g_autoptr(GKeyFile) config = NULL;\n  g_autofree char *ostree_key = NULL;\n\n  if (!flatpak_dir_ensure_repo (self, NULL, error))\n    return FALSE;\n\n  config = ostree_repo_copy_config (self->repo);\n  ostree_key = g_strconcat (\"xa.\", key, NULL);\n\n  if (flatpak_dir_use_system_helper (self, NULL))\n    {\n      FlatpakHelperConfigureFlags flags = 0;\n      const char *installation = flatpak_dir_get_id (self);\n\n      if (value == NULL)\n        {\n          flags |= FLATPAK_HELPER_CONFIGURE_FLAGS_UNSET;\n          value = \"\";\n        }\n\n      if (!flatpak_dir_system_helper_call_configure (self,\n                                                     flags, key, value,\n                                                     installation ? installation : \"\",\n                                                     NULL, error))\n        return FALSE;\n\n      return TRUE;\n    }\n\n  if (value == NULL)\n    g_key_file_remove_key (config, \"core\", ostree_key, NULL);\n  else\n    g_key_file_set_value (config, \"core\", ostree_key, value);\n\n  if (!ostree_repo_write_config (self->repo, config, error))\n    return FALSE;\n\n  if (!_flatpak_dir_reload_config (self, NULL, error))\n    return FALSE;\n\n  return TRUE;\n}\n\ngboolean\nflatpak_dir_config_append_pattern (FlatpakDir *self,\n                                   const char *key,\n                                   const char *pattern,\n                                   gboolean    runtime_only,\n                                   gboolean   *out_already_present,\n                                   GError    **error)\n{\n  g_autoptr(GPtrArray) patterns = flatpak_dir_get_config_patterns (self, key);\n  g_autofree char *regexp;\n  gboolean already_present;\n  g_autofree char *merged_patterns = NULL;\n\n  regexp = flatpak_filter_glob_to_regexp (pattern, runtime_only, error);\n  if (regexp == NULL)\n    return FALSE;\n\n  if (!(already_present = flatpak_g_ptr_array_contains_string (patterns, pattern)))\n    g_ptr_array_add (patterns, g_strdup (pattern));\n\n  if (out_already_present)\n    *out_already_present = already_present;\n\n  g_ptr_array_sort (patterns, flatpak_strcmp0_ptr);\n\n  g_ptr_array_add (patterns, NULL);\n  merged_patterns = g_strjoinv (\";\", (char **)patterns->pdata);\n\n  return flatpak_dir_set_config (self, key, merged_patterns, error);\n}\n\ngboolean\nflatpak_dir_config_remove_pattern (FlatpakDir *self,\n                                   const char *key,\n                                   const char *pattern,\n                                   GError    **error)\n{\n  g_autoptr(GPtrArray) patterns = flatpak_dir_get_config_patterns (self, key);\n  g_autofree char *merged_patterns = NULL;\n  int j;\n\n  for (j = 0; j < patterns->len; j++)\n    {\n      if (strcmp (g_ptr_array_index (patterns, j), pattern) == 0)\n        break;\n    }\n\n  if (j == patterns->len)\n    return flatpak_fail (error, _(\"No current %s pattern matching %s\"), key, pattern);\n  else\n    g_ptr_array_remove_index (patterns, j);\n\n  g_ptr_array_add (patterns, NULL);\n  merged_patterns = g_strjoinv (\";\", (char **)patterns->pdata);\n\n  return flatpak_dir_set_config (self, key, merged_patterns, error);\n}\n\ngboolean\nflatpak_dir_mark_changed (FlatpakDir *self,\n                          GError    **error)\n{\n  g_autoptr(GFile) changed_file = NULL;\n  g_autofree char * changed_path = NULL;\n\n  changed_file = flatpak_dir_get_changed_path (self);\n  changed_path = g_file_get_path (changed_file);\n\n  if (!g_utime (changed_path, NULL))\n    return TRUE;\n\n  if (errno != ENOENT)\n    return glnx_throw_errno (error);\n\n  if (!g_file_replace_contents (changed_file, \"\", 0, NULL, FALSE,\n                                G_FILE_CREATE_NONE, NULL, NULL, error))\n    return FALSE;\n\n  return TRUE;\n}\n\ngboolean\nflatpak_dir_remove_appstream (FlatpakDir   *self,\n                              const char   *remote,\n                              GCancellable *cancellable,\n                              GError      **error)\n{\n  g_autoptr(GFile) appstream_dir = NULL;\n  g_autoptr(GFile) remote_dir = NULL;\n\n  if (!flatpak_dir_ensure_repo (self, cancellable, error))\n    return FALSE;\n\n  appstream_dir = g_file_get_child (flatpak_dir_get_path (self), \"appstream\");\n  remote_dir = g_file_get_child (appstream_dir, remote);\n\n  if (g_file_query_exists (remote_dir, cancellable) &&\n      !flatpak_rm_rf (remote_dir, cancellable, error))\n    return FALSE;\n\n  return TRUE;\n}\n\ngboolean\nflatpak_dir_deploy_appstream (FlatpakDir   *self,\n                              const char   *remote,\n                              const char   *arch,\n                              gboolean     *out_changed,\n                              GCancellable *cancellable,\n                              GError      **error)\n{\n  g_autoptr(GFile) appstream_dir = NULL;\n  g_autoptr(GFile) remote_dir = NULL;\n  g_autoptr(GFile) arch_dir = NULL;\n  g_autoptr(GFile) checkout_dir = NULL;\n  g_autoptr(GFile) real_checkout_dir = NULL;\n  g_autoptr(GFile) timestamp_file = NULL;\n  g_autofree char *arch_path = NULL;\n  gboolean checkout_exists;\n  const char *old_dir = NULL;\n  g_autofree char *new_checksum = NULL;\n  g_autoptr(GFile) active_link = NULL;\n  g_autofree char *branch = NULL;\n  g_autoptr(GFile) old_checkout_dir = NULL;\n  g_autoptr(GFile) active_tmp_link = NULL;\n  g_autoptr(GError) tmp_error = NULL;\n  g_autofree char *new_dir = NULL;\n  g_autofree char *checkout_dir_path = NULL;\n  OstreeRepoCheckoutAtOptions options = { 0, };\n  glnx_autofd int dfd = -1;\n  g_autoptr(GFileInfo) file_info = NULL;\n  g_autofree char *tmpname = g_strdup (\".active-XXXXXX\");\n  g_auto(GLnxLockFile) lock = { 0, };\n  gboolean do_compress = FALSE;\n  gboolean do_uncompress = TRUE;\n  g_autofree char *filter_checksum = NULL;\n  g_autoptr(GRegex) allow_refs = NULL;\n  g_autoptr(GRegex) deny_refs = NULL;\n  g_autofree char *subset = NULL;\n\n  /* Keep a shared repo lock to avoid prunes removing objects we're relying on\n   * while we do the checkout. This could happen if the ref changes after we\n   * read its current value for the checkout. */\n  if (!flatpak_dir_repo_lock (self, &lock, LOCK_SH, cancellable, error))\n    return FALSE;\n\n  if (!flatpak_dir_lookup_remote_filter (self, remote, TRUE, &filter_checksum, &allow_refs, &deny_refs, error))\n    return FALSE;\n\n  appstream_dir = g_file_get_child (flatpak_dir_get_path (self), \"appstream\");\n  remote_dir = g_file_get_child (appstream_dir, remote);\n  arch_dir = g_file_get_child (remote_dir, arch);\n  active_link = g_file_get_child (arch_dir, \"active\");\n  timestamp_file = g_file_get_child (arch_dir, \".timestamp\");\n\n  arch_path = g_file_get_path (arch_dir);\n  if (g_mkdir_with_parents (arch_path, 0755) != 0)\n    {\n      glnx_set_error_from_errno (error);\n      return FALSE;\n    }\n\n  if (!glnx_opendirat (AT_FDCWD, arch_path, TRUE, &dfd, error))\n    return FALSE;\n\n  old_dir = NULL;\n  file_info = g_file_query_info (active_link, OSTREE_GIO_FAST_QUERYINFO,\n                                 G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n                                 cancellable, NULL);\n  if (file_info != NULL)\n    old_dir =  g_file_info_get_symlink_target (file_info);\n\n  subset = flatpak_dir_get_remote_subset (self, remote);\n\n  if (subset)\n    branch = g_strdup_printf (\"appstream2/%s-%s\", subset, arch);\n  else\n    branch = g_strdup_printf (\"appstream2/%s\", arch);\n\n  if (!flatpak_repo_resolve_rev (self->repo, NULL, remote, branch, TRUE,\n                                 &new_checksum, cancellable, error))\n    return FALSE;\n\n  if (new_checksum == NULL && subset == NULL)\n    {\n      /* Fall back to old branch (only exist on non-subsets) */\n      g_clear_pointer (&branch, g_free);\n      branch = g_strdup_printf (\"appstream/%s\", arch);\n      if (!flatpak_repo_resolve_rev (self->repo, NULL, remote, branch, TRUE,\n                                     &new_checksum, cancellable, error))\n        return FALSE;\n      do_compress = FALSE;\n      do_uncompress = TRUE;\n    }\n  else\n    {\n      do_compress = TRUE;\n      do_uncompress = FALSE;\n    }\n\n  if (new_checksum == NULL)\n    return flatpak_fail_error (error, FLATPAK_ERROR_INVALID_DATA, _(\"No appstream commit to deploy\"));\n\n  if (filter_checksum)\n    new_dir = g_strconcat (new_checksum, \"-\", filter_checksum, NULL);\n  else\n    new_dir = g_strdup (new_checksum);\n\n  real_checkout_dir = g_file_get_child (arch_dir, new_dir);\n  checkout_exists = g_file_query_exists (real_checkout_dir, NULL);\n\n  if (old_dir != NULL && new_dir != NULL &&\n      strcmp (old_dir, new_dir) == 0 &&\n      checkout_exists)\n    {\n      if (!g_file_replace_contents (timestamp_file, \"\", 0, NULL, FALSE,\n                                    G_FILE_CREATE_REPLACE_DESTINATION, NULL, NULL, error))\n        return FALSE;\n\n      if (out_changed)\n        *out_changed = FALSE;\n\n      return TRUE; /* No changes, don't checkout */\n    }\n\n  {\n    g_autofree char *template = g_strdup_printf (\".%s-XXXXXX\", new_dir);\n    g_autoptr(GFile) tmp_dir_template = g_file_get_child (arch_dir, template);\n    checkout_dir_path = g_file_get_path (tmp_dir_template);\n    if (g_mkdtemp_full (checkout_dir_path, 0755) == NULL)\n      {\n        g_set_error (error, G_IO_ERROR, G_IO_ERROR_FAILED,\n                     _(\"Can't create deploy directory\"));\n        return FALSE;\n      }\n  }\n  checkout_dir = g_file_new_for_path (checkout_dir_path);\n\n  options.mode = OSTREE_REPO_CHECKOUT_MODE_USER;\n  options.overwrite_mode = OSTREE_REPO_CHECKOUT_OVERWRITE_UNION_FILES;\n  options.enable_fsync = FALSE; /* We checkout to a temp dir and sync before moving it in place */\n  options.bareuseronly_dirs = TRUE; /* https://github.com/ostreedev/ostree/pull/927 */\n\n  if (!ostree_repo_checkout_at (self->repo, &options,\n                                AT_FDCWD, checkout_dir_path, new_checksum,\n                                cancellable, error))\n    return FALSE;\n\n  /* Old appstream format don't have uncompressed file, so we uncompress it */\n  if (do_uncompress)\n    {\n      g_autoptr(GFile) appstream_xml = g_file_get_child (checkout_dir, \"appstream.xml\");\n      g_autoptr(GFile) appstream_gz_xml = g_file_get_child (checkout_dir, \"appstream.xml.gz\");\n      g_autoptr(GOutputStream) out2 = NULL;\n      g_autoptr(GFileOutputStream) out = NULL;\n      g_autoptr(GFileInputStream) in = NULL;\n\n      in = g_file_read (appstream_gz_xml, NULL, NULL);\n      if (in)\n        {\n          g_autoptr(GZlibDecompressor) decompressor = g_zlib_decompressor_new (G_ZLIB_COMPRESSOR_FORMAT_GZIP);\n          out = g_file_replace (appstream_xml, NULL, FALSE, G_FILE_CREATE_REPLACE_DESTINATION,\n                                NULL, error);\n          if (out == NULL)\n            return FALSE;\n\n          out2 = g_converter_output_stream_new (G_OUTPUT_STREAM (out), G_CONVERTER (decompressor));\n          if (g_output_stream_splice (out2, G_INPUT_STREAM (in), G_OUTPUT_STREAM_SPLICE_CLOSE_SOURCE | G_OUTPUT_STREAM_SPLICE_CLOSE_TARGET,\n                                      NULL, error) < 0)\n            return FALSE;\n        }\n    }\n\n  if (deny_refs)\n    {\n      g_autoptr(GFile) appstream_xml = g_file_get_child (checkout_dir, \"appstream.xml\");\n      g_autoptr(GFileInputStream) in = NULL;\n\n      /* We need some ref filtering, so parse the xml */\n\n      in = g_file_read (appstream_xml, NULL, NULL);\n      if (in)\n        {\n          g_autoptr(FlatpakXml) appstream = NULL;\n          g_autoptr(GBytes) content = NULL;\n\n          appstream = flatpak_xml_parse (G_INPUT_STREAM (in), FALSE, cancellable, error);\n          if (appstream == NULL)\n            return FALSE;\n\n          flatpak_appstream_xml_filter (appstream, allow_refs, deny_refs);\n\n          if (!flatpak_appstream_xml_root_to_data (appstream, &content, NULL, error))\n            return FALSE;\n\n          if (!g_file_replace_contents  (appstream_xml,\n                                         g_bytes_get_data (content, NULL), g_bytes_get_size (content),\n                                         NULL, FALSE, G_FILE_CREATE_REPLACE_DESTINATION, NULL,\n                                         cancellable, error))\n            return FALSE;\n        }\n\n      do_compress = TRUE; /* We need to recompress this */\n    }\n\n  /* New appstream format don't have compressed file, so we compress it */\n  if (do_compress)\n    {\n      g_autoptr(GFile) appstream_xml = g_file_get_child (checkout_dir, \"appstream.xml\");\n      g_autoptr(GFile) appstream_gz_xml = g_file_get_child (checkout_dir, \"appstream.xml.gz\");\n      g_autoptr(GZlibCompressor) compressor = NULL;\n      g_autoptr(GOutputStream) out2 = NULL;\n      g_autoptr(GFileOutputStream) out = NULL;\n      g_autoptr(GFileInputStream) in = NULL;\n\n      in = g_file_read (appstream_xml, NULL, NULL);\n      if (in)\n        {\n          compressor = g_zlib_compressor_new (G_ZLIB_COMPRESSOR_FORMAT_GZIP, -1);\n          out = g_file_replace (appstream_gz_xml, NULL, FALSE, G_FILE_CREATE_REPLACE_DESTINATION,\n                                NULL, error);\n          if (out == NULL)\n            return FALSE;\n\n          out2 = g_converter_output_stream_new (G_OUTPUT_STREAM (out), G_CONVERTER (compressor));\n          if (g_output_stream_splice (out2, G_INPUT_STREAM (in), G_OUTPUT_STREAM_SPLICE_CLOSE_SOURCE | G_OUTPUT_STREAM_SPLICE_CLOSE_TARGET,\n                                      NULL, error) < 0)\n            return FALSE;\n        }\n    }\n\n  glnx_gen_temp_name (tmpname);\n  active_tmp_link = g_file_get_child (arch_dir, tmpname);\n\n  if (!g_file_make_symbolic_link (active_tmp_link, new_dir, cancellable, error))\n    return FALSE;\n\n  if (syncfs (dfd) != 0)\n    {\n      glnx_set_error_from_errno (error);\n      return FALSE;\n    }\n\n  /* By now the checkout to the temporary directory is on disk, as is the temporary\n     symlink pointing to the final target. */\n\n  if (!g_file_move (checkout_dir, real_checkout_dir, G_FILE_COPY_NO_FALLBACK_FOR_MOVE,\n                    cancellable, NULL, NULL, error))\n    return FALSE;\n\n  if (syncfs (dfd) != 0)\n    {\n      glnx_set_error_from_errno (error);\n      return FALSE;\n    }\n\n  if (!flatpak_file_rename (active_tmp_link,\n                            active_link,\n                            cancellable, error))\n    return FALSE;\n\n  if (old_dir != NULL &&\n      g_strcmp0 (old_dir, new_dir) != 0)\n    {\n      old_checkout_dir = g_file_get_child (arch_dir, old_dir);\n      if (!flatpak_rm_rf (old_checkout_dir, cancellable, &tmp_error))\n        g_warning (\"Unable to remove old appstream checkout: %s\", tmp_error->message);\n    }\n\n  if (!g_file_replace_contents (timestamp_file, \"\", 0, NULL, FALSE,\n                                G_FILE_CREATE_REPLACE_DESTINATION, NULL, NULL, error))\n    return FALSE;\n\n  /* If we added a new checkout, touch the toplevel dir to tell people that they need\n     to re-scan */\n  if (!checkout_exists)\n    {\n      g_autofree char *appstream_dir_path = g_file_get_path (appstream_dir);\n      utime (appstream_dir_path, NULL);\n    }\n\n  if (out_changed)\n    *out_changed = TRUE;\n\n  return TRUE;\n}\n\nstatic gboolean repo_get_remote_collection_id (OstreeRepo *repo,\n                                               const char *remote_name,\n                                               char      **collection_id_out,\n                                               GError    **error);\n\n\ngboolean\nflatpak_dir_find_latest_rev (FlatpakDir               *self,\n                             FlatpakRemoteState       *state,\n                             const char               *ref,\n                             const char               *checksum_or_latest,\n                             char                    **out_rev,\n                             guint64                  *out_timestamp,\n                             GFile                   **out_sideload_path,\n                             GCancellable             *cancellable,\n                             GError                  **error)\n{\n  g_autofree char *latest_rev = NULL;\n\n  g_return_val_if_fail (out_rev != NULL, FALSE);\n\n  if (!flatpak_remote_state_lookup_ref (state, ref, &latest_rev, out_timestamp, NULL, out_sideload_path, error))\n    return FALSE;\n  if (latest_rev == NULL)\n    return flatpak_fail_error (error, FLATPAK_ERROR_REF_NOT_FOUND,\n                               _(\"Couldn't find latest checksum for ref %s in remote %s\"),\n                               ref, state->remote_name);\n\n  if (out_rev != NULL)\n    *out_rev = g_steal_pointer (&latest_rev);\n\n  return TRUE;\n}\n\nstatic gboolean\nget_mtime (GFile        *file,\n           GTimeVal     *result,\n           GCancellable *cancellable,\n           GError      **error)\n{\n  g_autoptr(GFileInfo) info = g_file_query_info (file,\n                                                 G_FILE_ATTRIBUTE_TIME_MODIFIED,\n                                                 G_FILE_QUERY_INFO_NONE,\n                                                 cancellable, error);\n  if (info)\n    {\n      g_file_info_get_modification_time (info, result);\n      return TRUE;\n    }\n  else\n    {\n      return FALSE;\n    }\n}\n\nstatic gboolean\ncheck_destination_mtime (GFile        *src,\n                         GFile        *dest,\n                         GCancellable *cancellable)\n{\n  GTimeVal src_mtime;\n  GTimeVal dest_mtime;\n\n  return get_mtime (src, &src_mtime, cancellable, NULL) &&\n         get_mtime (dest, &dest_mtime, cancellable, NULL) &&\n         (src_mtime.tv_sec < dest_mtime.tv_sec ||\n          (src_mtime.tv_sec == dest_mtime.tv_sec && src_mtime.tv_usec < dest_mtime.tv_usec));\n}\n\nstatic GFile *\nflatpak_dir_update_oci_index (FlatpakDir   *self,\n                              const char   *remote,\n                              char        **index_uri_out,\n                              GCancellable *cancellable,\n                              GError      **error)\n{\n  g_autoptr(GError) local_error = NULL;\n  g_autoptr(GFile) index_cache = NULL;\n  g_autofree char *oci_uri = NULL;\n\n  index_cache = flatpak_dir_get_oci_index_location (self, remote, error);\n  if (index_cache == NULL)\n    return NULL;\n\n  ensure_soup_session (self);\n\n  if (!ostree_repo_remote_get_url (self->repo,\n                                   remote,\n                                   &oci_uri,\n                                   error))\n    return NULL;\n\n  if (!flatpak_oci_index_ensure_cached (self->soup_session, oci_uri,\n                                        index_cache, index_uri_out,\n                                        cancellable, &local_error))\n    {\n      if (!g_error_matches (local_error, FLATPAK_HTTP_ERROR, FLATPAK_HTTP_ERROR_NOT_CHANGED))\n        {\n          g_propagate_error (error, g_steal_pointer (&local_error));\n          return NULL;\n        }\n\n      g_clear_error (&local_error);\n    }\n\n  return g_steal_pointer (&index_cache);\n}\n\nstatic gboolean\nreplace_contents_compressed (GFile        *dest,\n                             GBytes       *contents,\n                             GCancellable *cancellable,\n                             GError      **error)\n{\n  g_autoptr(GZlibCompressor) compressor = NULL;\n  g_autoptr(GFileOutputStream) out = NULL;\n  g_autoptr(GOutputStream) out2 = NULL;\n\n  compressor = g_zlib_compressor_new (G_ZLIB_COMPRESSOR_FORMAT_GZIP, -1);\n  out = g_file_replace (dest, NULL, FALSE, G_FILE_CREATE_REPLACE_DESTINATION,\n                        NULL, error);\n  out2 = g_converter_output_stream_new (G_OUTPUT_STREAM (out), G_CONVERTER (compressor));\n  if (out == NULL)\n    return FALSE;\n\n  if (!g_output_stream_write_all (out2,\n                                  g_bytes_get_data (contents, NULL),\n                                  g_bytes_get_size (contents),\n                                  NULL,\n                                  cancellable, error))\n    return FALSE;\n\n  if (!g_output_stream_close (out2, cancellable, error))\n    return FALSE;\n\n  return TRUE;\n}\n\nstatic gboolean\nflatpak_dir_update_appstream_oci (FlatpakDir          *self,\n                                  const char          *remote,\n                                  const char          *arch,\n                                  gboolean            *out_changed,\n                                  FlatpakProgress     *progress,\n                                  GCancellable        *cancellable,\n                                  GError             **error)\n{\n  g_autoptr(GFile) arch_dir = NULL;\n  g_autoptr(GFile) lock_file = NULL;\n  g_auto(GLnxLockFile) lock = { 0, };\n  g_autoptr(GFile) index_cache = NULL;\n  g_autofree char *index_uri = NULL;\n  g_autoptr(GFile) timestamp_file = NULL;\n  g_autoptr(GFile) icons_dir = NULL;\n  glnx_autofd int icons_dfd = -1;\n  g_autoptr(GBytes) appstream = NULL;\n  g_autoptr(GFile) new_appstream_file = NULL;\n\n  arch_dir = flatpak_build_file (flatpak_dir_get_path (self),\n                                 \"appstream\", remote, arch, NULL);\n  if (g_mkdir_with_parents (flatpak_file_get_path_cached (arch_dir), 0755) != 0)\n    {\n      glnx_set_error_from_errno (error);\n      return FALSE;\n    }\n\n  lock_file = g_file_get_child (arch_dir, \"lock\");\n  if (!glnx_make_lock_file (AT_FDCWD, flatpak_file_get_path_cached (lock_file),\n                            LOCK_EX, &lock, error))\n    return FALSE;\n\n  index_cache = flatpak_dir_update_oci_index (self, remote, &index_uri, cancellable, error);\n  if (index_cache == NULL)\n    return FALSE;\n\n  timestamp_file = g_file_get_child (arch_dir, \".timestamp\");\n  if (check_destination_mtime (index_cache, timestamp_file, cancellable))\n    return TRUE;\n\n  icons_dir = g_file_get_child (arch_dir, \"icons\");\n  if (g_mkdir_with_parents (flatpak_file_get_path_cached (icons_dir), 0755) != 0)\n    {\n      glnx_set_error_from_errno (error);\n      return FALSE;\n    }\n\n  if (!glnx_opendirat (AT_FDCWD, flatpak_file_get_path_cached (icons_dir),\n                       FALSE, &icons_dfd, error))\n    return FALSE;\n\n  ensure_soup_session (self);\n\n  appstream = flatpak_oci_index_make_appstream (self->soup_session,\n                                                index_cache,\n                                                index_uri,\n                                                arch,\n                                                icons_dfd,\n                                                cancellable,\n                                                error);\n  if (appstream == NULL)\n    return FALSE;\n\n  new_appstream_file = g_file_get_child (arch_dir, \"appstream.xml.gz\");\n  if (!replace_contents_compressed (new_appstream_file, appstream, cancellable, error))\n    return FALSE;\n\n  if (!g_file_replace_contents (timestamp_file, \"\", 0, NULL, FALSE,\n                                G_FILE_CREATE_REPLACE_DESTINATION, NULL, NULL, error))\n    return FALSE;\n\n  if (out_changed)\n    *out_changed = TRUE;\n\n  return TRUE;\n}\n\ngboolean\nflatpak_dir_update_appstream (FlatpakDir          *self,\n                              const char          *remote,\n                              const char          *arch,\n                              gboolean            *out_changed,\n                              FlatpakProgress     *progress,\n                              GCancellable        *cancellable,\n                              GError             **error)\n{\n  g_autofree char *new_branch = NULL;\n  g_autofree char *old_branch = NULL;\n  const char *used_branch = NULL;\n  g_autofree char *new_checksum = NULL;\n  g_autoptr(GError) first_error = NULL;\n  g_autoptr(GError) second_error = NULL;\n  g_autoptr(FlatpakRemoteState) state = NULL;\n  g_autofree char *appstream_commit = NULL;\n  g_autofree char *subset = NULL;\n  g_autoptr(GFile) appstream_sideload_path = NULL;\n  const char *installation;\n  gboolean is_oci;\n\n  if (out_changed)\n    *out_changed = FALSE;\n\n  if (arch == NULL)\n    arch = flatpak_get_arch ();\n\n  subset = flatpak_dir_get_remote_subset (self, remote);\n\n  if (subset)\n    {\n      new_branch = g_strdup_printf (\"appstream2/%s-%s\", subset, arch);\n      old_branch = g_strdup_printf (\"appstream/%s-%s\", subset, arch);\n    }\n  else\n    {\n      new_branch = g_strdup_printf (\"appstream2/%s\", arch);\n      old_branch = g_strdup_printf (\"appstream/%s\", arch);\n    }\n\n  is_oci = flatpak_dir_get_remote_oci (self, remote);\n\n  state = flatpak_dir_get_remote_state_optional (self, remote, FALSE, cancellable, error);\n  if (state == NULL)\n    return FALSE;\n\n  used_branch = new_branch;\n  if (!is_oci)\n    {\n      if (!flatpak_dir_find_latest_rev (self, state, used_branch, NULL, &appstream_commit, NULL, &appstream_sideload_path, cancellable, &first_error))\n        {\n          used_branch = old_branch;\n          if (!flatpak_dir_find_latest_rev (self, state, used_branch, NULL, &appstream_commit, NULL, &appstream_sideload_path, cancellable, &second_error))\n            {\n              g_prefix_error (&first_error, \"Error updating appstream2: \");\n              g_prefix_error (&second_error, \"Error updating appstream: \");\n              g_propagate_prefixed_error (error, g_steal_pointer (&second_error), \"%s; \", first_error->message);\n              return FALSE;\n            }\n        }\n    }\n\n  if (flatpak_dir_use_system_helper (self, NULL))\n    {\n      g_auto(GLnxLockFile) child_repo_lock = { 0, };\n      g_autofree char *url = NULL;\n      g_autoptr(GFile) child_repo_file = NULL;\n      g_autofree char *child_repo_path = NULL;\n      gboolean gpg_verify_summary;\n      gboolean gpg_verify;\n\n      if (!ostree_repo_remote_get_url (self->repo,\n                                       state->remote_name,\n                                       &url,\n                                       error))\n        return FALSE;\n\n      if (!ostree_repo_remote_get_gpg_verify_summary (self->repo, state->remote_name,\n                                                      &gpg_verify_summary, error))\n        return FALSE;\n\n      if (!ostree_repo_remote_get_gpg_verify (self->repo, state->remote_name,\n                                              &gpg_verify, error))\n        return FALSE;\n\n      if (is_oci)\n        {\n          /* In the OCI case, we just ask the system helper do the network i/o, since\n           * there is no way to verify the index validity without actually downloading it.\n           * While we try to avoid network i/o as root, there's no hard line where doing\n           * network i/o as root is much worse than parsing the results of network i/o\n           * as root. A trusted, but unprivileged helper could be used to do the download\n           * if necessary.\n           */\n        }\n      else if (!gpg_verify_summary || !gpg_verify)\n        {\n          /* The remote is not gpg verified, so we don't want to allow installation via\n             a download in the home directory, as there is no way to verify you're not\n             injecting anything into the remote. However, in the case of a remote\n             configured to a local filesystem we can just let the system helper do\n             the installation, as it can then avoid network i/o and be certain the\n             data comes from the right place.  */\n          if (!g_str_has_prefix (url, \"file:\"))\n            return flatpak_fail_error (error, FLATPAK_ERROR_UNTRUSTED, _(\"Can't pull from untrusted non-gpg verified remote\"));\n        }\n      else\n        {\n          g_autoptr(OstreeRepo) child_repo = flatpak_dir_create_system_child_repo (self, &child_repo_lock, NULL, error);\n          if (child_repo == NULL)\n            return FALSE;\n\n          if (!flatpak_dir_pull (self, state, used_branch, appstream_commit, NULL, appstream_sideload_path, NULL, NULL,\n                                 child_repo, FLATPAK_PULL_FLAGS_NONE, 0,\n                                 progress, cancellable, error))\n            {\n              g_prefix_error (&first_error, \"Error updating appstream: \");\n              return FALSE;\n            }\n\n          if (!flatpak_repo_resolve_rev (child_repo, NULL, remote, used_branch, TRUE,\n                                         &new_checksum, cancellable, error))\n            return FALSE;\n\n          child_repo_file = g_object_ref (ostree_repo_get_path (child_repo));\n        }\n\n      if (child_repo_file)\n        child_repo_path = g_file_get_path (child_repo_file);\n\n      installation = flatpak_dir_get_id (self);\n\n      if (!flatpak_dir_system_helper_call_deploy_appstream (self,\n                                                            child_repo_path ? child_repo_path : \"\",\n                                                            FLATPAK_HELPER_DEPLOY_APPSTREAM_FLAGS_NONE,\n                                                            remote,\n                                                            arch,\n                                                            installation ? installation : \"\",\n                                                            cancellable,\n                                                            error))\n        return FALSE;\n\n      if (child_repo_file)\n        (void) flatpak_rm_rf (child_repo_file, NULL, NULL);\n\n      return TRUE;\n    }\n\n  if (is_oci)\n    {\n      return flatpak_dir_update_appstream_oci (self, remote, arch,\n                                               out_changed, progress, cancellable,\n                                               error);\n    }\n\n\n  if (!flatpak_dir_pull (self, state, used_branch, appstream_commit, NULL, appstream_sideload_path, NULL, NULL, NULL,\n                         FLATPAK_PULL_FLAGS_NONE, OSTREE_REPO_PULL_FLAGS_NONE, progress,\n                         cancellable, error))\n    {\n      g_prefix_error (&first_error, \"Error updating appstream: \");\n      return FALSE;\n    }\n\n  if (!flatpak_repo_resolve_rev (self->repo, NULL, remote, used_branch, TRUE,\n                                 &new_checksum, cancellable, error))\n    return FALSE;\n\n  return flatpak_dir_deploy_appstream (self,\n                                       remote,\n                                       arch,\n                                       out_changed,\n                                       cancellable,\n                                       error);\n}\n\n/* Get the configured collection-id for @remote_name, squashing empty strings into\n * %NULL. Return %TRUE if the ID was fetched successfully, or if it was unset or\n * empty. */\nstatic gboolean\nrepo_get_remote_collection_id (OstreeRepo *repo,\n                               const char *remote_name,\n                               char      **collection_id_out,\n                               GError    **error)\n{\n  if (collection_id_out != NULL)\n    {\n      if (!ostree_repo_get_remote_option (repo, remote_name, \"collection-id\",\n                                          NULL, collection_id_out, error))\n        return FALSE;\n      if (*collection_id_out != NULL && **collection_id_out == '\\0')\n        g_clear_pointer (collection_id_out, g_free);\n    }\n\n  return TRUE;\n}\n\n/* Get options for the OSTree pull operation which can be shared between\n * collection-based and normal pulls. Update @builder in place. */\nstatic void\nget_common_pull_options (GVariantBuilder     *builder,\n                         FlatpakRemoteState  *state,\n                         const char          *ref_to_fetch,\n                         const char          *token,\n                         const gchar * const *dirs_to_pull,\n                         const char          *current_local_checksum,\n                         gboolean             force_disable_deltas,\n                         OstreeRepoPullFlags  flags,\n                         FlatpakProgress     *progress)\n{\n  guint32 update_interval = 0;\n  GVariantBuilder hdr_builder;\n\n  if (state->summary_bytes && state->summary_sig_bytes)\n    {\n      g_variant_builder_add (builder, \"{s@v}\", \"summary-bytes\",\n                             g_variant_new_variant (g_variant_new_from_bytes (G_VARIANT_TYPE (\"ay\"), state->summary_bytes, TRUE)));\n      g_variant_builder_add (builder, \"{s@v}\", \"summary-sig-bytes\",\n                             g_variant_new_variant (g_variant_new_from_bytes (G_VARIANT_TYPE (\"ay\"), state->summary_sig_bytes, TRUE)));\n    }\n\n  if (dirs_to_pull)\n    {\n      g_variant_builder_add (builder, \"{s@v}\", \"subdirs\",\n                             g_variant_new_variant (g_variant_new_strv ((const char * const *) dirs_to_pull, -1)));\n      force_disable_deltas = TRUE;\n    }\n\n  if (force_disable_deltas)\n    {\n      g_variant_builder_add (builder, \"{s@v}\", \"disable-static-deltas\",\n                             g_variant_new_variant (g_variant_new_boolean (TRUE)));\n    }\n\n  g_variant_builder_add (builder, \"{s@v}\", \"inherit-transaction\",\n                         g_variant_new_variant (g_variant_new_boolean (TRUE)));\n\n  g_variant_builder_add (builder, \"{s@v}\", \"flags\",\n                         g_variant_new_variant (g_variant_new_int32 (flags)));\n\n\n  g_variant_builder_init (&hdr_builder, G_VARIANT_TYPE (\"a(ss)\"));\n  g_variant_builder_add (&hdr_builder, \"(ss)\", \"Flatpak-Ref\", ref_to_fetch);\n  if (token)\n    {\n      g_autofree char *bearer_token = g_strdup_printf (\"Bearer %s\", token);\n      g_variant_builder_add (&hdr_builder, \"(ss)\", \"Authorization\", bearer_token);\n    }\n  if (current_local_checksum)\n    g_variant_builder_add (&hdr_builder, \"(ss)\", \"Flatpak-Upgrade-From\", current_local_checksum);\n  g_variant_builder_add (builder, \"{s@v}\", \"http-headers\",\n                         g_variant_new_variant (g_variant_builder_end (&hdr_builder)));\n  g_variant_builder_add (builder, \"{s@v}\", \"append-user-agent\",\n                         g_variant_new_variant (g_variant_new_string (\"flatpak/\" PACKAGE_VERSION)));\n\n  update_interval = flatpak_progress_get_update_interval (progress);\n\n  g_variant_builder_add (builder, \"{s@v}\", \"update-frequency\",\n                         g_variant_new_variant (g_variant_new_uint32 (update_interval)));\n}\n\nstatic gboolean\ntranslate_ostree_repo_pull_errors (GError **error)\n{\n  if (*error)\n    {\n      if (strstr ((*error)->message, \"min-free-space-size\") ||\n          strstr ((*error)->message, \"min-free-space-percent\"))\n        {\n          (*error)->domain = FLATPAK_ERROR;\n          (*error)->code = FLATPAK_ERROR_OUT_OF_SPACE;\n        }\n    }\n\n  return FALSE;\n}\n\nstatic gboolean\nrepo_pull (OstreeRepo                           *self,\n           FlatpakRemoteState                   *state,\n           const char                          **dirs_to_pull,\n           const char                           *ref_to_fetch,\n           const char                           *rev_to_fetch, /* (nullable) */\n           GFile                                *sideload_repo,\n           const char                           *token,\n           FlatpakPullFlags                      flatpak_flags,\n           OstreeRepoPullFlags                   flags,\n           FlatpakProgress                      *progress,\n           GCancellable                         *cancellable,\n           GError                              **error)\n{\n  gboolean force_disable_deltas = (flatpak_flags & FLATPAK_PULL_FLAGS_NO_STATIC_DELTAS) != 0;\n  g_autofree char *current_checksum = NULL;\n  g_autoptr(GVariant) old_commit = NULL;\n  g_autoptr(GVariant) new_commit = NULL;\n  const char *revs_to_fetch[2];\n  g_autoptr(GError) dummy_error = NULL;\n  GVariantBuilder builder;\n  g_autoptr(GVariant) options = NULL;\n  const char *refs_to_fetch[2];\n  g_autofree char *sideload_url = NULL;\n\n  /* The ostree fetcher asserts if error is NULL */\n  if (error == NULL)\n    error = &dummy_error;\n\n  /* We always want this on for every type of pull */\n  flags |= OSTREE_REPO_PULL_FLAGS_BAREUSERONLY_FILES;\n\n  if (!flatpak_repo_resolve_rev (self, NULL, state->remote_name, ref_to_fetch, TRUE,\n                                 &current_checksum, cancellable, error))\n    return FALSE;\n\n  if (current_checksum != NULL &&\n      !ostree_repo_load_commit (self, current_checksum, &old_commit, NULL, error))\n    return FALSE;\n\n  /* Pull options */\n  g_variant_builder_init (&builder, G_VARIANT_TYPE (\"a{sv}\"));\n  get_common_pull_options (&builder, state, ref_to_fetch, token, dirs_to_pull, current_checksum,\n                           force_disable_deltas, flags, progress);\n\n  if (sideload_repo)\n    {\n      GVariantBuilder colref_builder;\n\n      sideload_url = g_file_get_uri (sideload_repo);\n\n      g_debug (\"Sideloading %s from %s in pull\", ref_to_fetch, sideload_url);\n\n      g_assert (state->collection_id != NULL);\n\n      g_variant_builder_init (&colref_builder, G_VARIANT_TYPE (\"a(sss)\"));\n      g_variant_builder_add (&colref_builder, \"(sss)\", state->collection_id, ref_to_fetch, rev_to_fetch);\n\n      g_variant_builder_add (&builder, \"{s@v}\", \"collection-refs\",\n                             g_variant_new_variant (g_variant_builder_end (&colref_builder)));\n      g_variant_builder_add (&builder, \"{s@v}\", \"override-remote-name\",\n                             g_variant_new_variant (g_variant_new_string (state->remote_name)));\n    }\n  else\n    {\n      refs_to_fetch[0] = ref_to_fetch;\n      refs_to_fetch[1] = NULL;\n      g_variant_builder_add (&builder, \"{s@v}\", \"refs\",\n                             g_variant_new_variant (g_variant_new_strv ((const char * const *) refs_to_fetch, -1)));\n\n      revs_to_fetch[0] = rev_to_fetch;\n      revs_to_fetch[1] = NULL;\n      g_variant_builder_add (&builder, \"{s@v}\", \"override-commit-ids\",\n                             g_variant_new_variant (g_variant_new_strv ((const char * const *) revs_to_fetch, -1)));\n\n\n      if (state->sideload_repos->len > 0)\n        {\n          GVariantBuilder localcache_repos_builder;\n\n          g_variant_builder_init (&localcache_repos_builder, G_VARIANT_TYPE (\"as\"));\n          for (int i = 0; i < state->sideload_repos->len; i++)\n            {\n              FlatpakSideloadState *ss = g_ptr_array_index (state->sideload_repos, i);\n              GFile *sideload_path = ostree_repo_get_path (ss->repo);\n\n              g_variant_builder_add (&localcache_repos_builder, \"s\",\n                                     flatpak_file_get_path_cached (sideload_path));\n            }\n          g_variant_builder_add (&builder, \"{s@v}\", \"localcache-repos\",\n                                 g_variant_new_variant (g_variant_builder_end (&localcache_repos_builder)));\n        }\n    }\n\n  options = g_variant_ref_sink (g_variant_builder_end (&builder));\n\n  {\n    g_auto(FlatpakMainContext) context = FLATKPAK_MAIN_CONTEXT_INIT;\n    flatpak_progress_init_main_context (progress, &context);\n\n    if (!ostree_repo_pull_with_options (self,\n                                        sideload_url ? sideload_url : state->remote_name,\n                                        options, context.ostree_progress, cancellable, error))\n      return translate_ostree_repo_pull_errors (error);\n  }\n\n  if (old_commit &&\n      (flatpak_flags & FLATPAK_PULL_FLAGS_ALLOW_DOWNGRADE) == 0)\n    {\n      guint64 old_timestamp;\n      guint64 new_timestamp;\n\n      if (!ostree_repo_load_commit (self, rev_to_fetch, &new_commit, NULL, error))\n        return FALSE;\n\n      old_timestamp = ostree_commit_get_timestamp (old_commit);\n      new_timestamp = ostree_commit_get_timestamp (new_commit);\n\n      if (new_timestamp < old_timestamp)\n        return flatpak_fail_error (error, FLATPAK_ERROR_DOWNGRADE, \"Update is older than current version\");\n    }\n\n  return TRUE;\n}\n\nstatic void\nensure_soup_session (FlatpakDir *self)\n{\n  if (g_once_init_enter (&self->soup_session))\n    {\n      SoupSession *soup_session;\n\n      soup_session = flatpak_create_soup_session (PACKAGE_STRING);\n\n      g_once_init_leave (&self->soup_session, soup_session);\n    }\n}\n\nstatic void\nextra_data_progress_report (guint64  downloaded_bytes,\n                            gpointer user_data)\n{\n  FlatpakProgress *progress = FLATPAK_PROGRESS (user_data);\n\n  flatpak_progress_update_extra_data (progress, downloaded_bytes);\n}\n\nstatic void\ncompute_extra_data_download_size (GVariant *commitv,\n                                  guint64 *out_n_extra_data,\n                                  guint64 *out_total_download_size)\n{\n  guint64 i;\n  guint64 n_extra_data = 0;\n  guint64 total_download_size = 0;\n  g_autoptr(GVariant) extra_data_sources = NULL;\n\n  extra_data_sources = flatpak_commit_get_extra_data_sources (commitv, NULL);\n  if (extra_data_sources != NULL)\n    {\n      n_extra_data = g_variant_n_children (extra_data_sources);\n      for (i = 0; i < n_extra_data; i++)\n        {\n          guint64 download_size;\n          flatpak_repo_parse_extra_data_sources (extra_data_sources, i,\n                                                 NULL,\n                                                 &download_size,\n                                                 NULL,\n                                                 NULL,\n                                                 NULL);\n          total_download_size += download_size;\n        }\n    }\n\n  *out_n_extra_data = n_extra_data;\n  *out_total_download_size = total_download_size;\n}\n\nstatic gboolean\nflatpak_dir_setup_extra_data (FlatpakDir                           *self,\n                              FlatpakRemoteState                   *state,\n                              OstreeRepo                           *repo,\n                              const char                           *ref,\n                              const char                           *rev,\n                              GFile                                *sideload_repo,\n                              const char                           *token,\n                              FlatpakPullFlags                      flatpak_flags,\n                              FlatpakProgress                      *progress,\n                              GCancellable                         *cancellable,\n                              GError                              **error)\n{\n  guint64 n_extra_data = 0;\n  guint64 total_download_size = 0;\n\n  /* ostree-metadata and appstreams never have extra data, so ignore those */\n  if (g_str_has_prefix (ref, \"app/\") || g_str_has_prefix (ref, \"runtime/\"))\n    {\n      g_autofree char *summary_checksum = NULL;\n      GVariant *summary;\n\n      /* Version 1 added extra data details, so we can rely on it\n       * either being in the sparse cache or no extra data.  However,\n       * it only applies to the commit the summary contains, so verify\n       * that too.\n       */\n      summary = get_summary_for_ref (state, ref);\n      if (summary != NULL &&\n          flatpak_summary_lookup_ref (summary, NULL, ref, &summary_checksum, NULL) &&\n          g_strcmp0 (rev, summary_checksum) == 0 &&\n          flatpak_remote_state_get_cache_version (state) >= 1)\n        {\n          VarMetadataRef metadata;\n          VarVariantRef res;\n\n          if (flatpak_remote_state_lookup_sparse_cache (state, ref, &metadata, NULL) &&\n              var_metadata_lookup (metadata, FLATPAK_SPARSE_CACHE_KEY_EXTRA_DATA_SIZE, NULL, &res) &&\n              var_variant_is_type (res, VAR_EXTRA_DATA_SIZE_TYPEFORMAT))\n            {\n              VarExtraDataSizeRef eds = var_extra_data_size_from_variant (res);\n              n_extra_data = var_extra_data_size_get_n_extra_data (eds);\n              total_download_size = var_extra_data_size_get_total_size (eds);\n            }\n        }\n      else\n        {\n          /* No summary/cache or old cache version, download commit and get size from there */\n          g_autoptr(GVariant) commitv = flatpak_remote_state_load_ref_commit (state, self, ref, rev, token, NULL, cancellable, error);\n          if (commitv == NULL)\n            return FALSE;\n\n          compute_extra_data_download_size (commitv, &n_extra_data, &total_download_size);\n        }\n    }\n\n  if (n_extra_data > 0 &&\n      (flatpak_flags & FLATPAK_PULL_FLAGS_DOWNLOAD_EXTRA_DATA) == 0)\n    return flatpak_fail_error (error, FLATPAK_ERROR_UNTRUSTED, _(\"Extra data not supported for non-gpg-verified local system installs\"));\n\n  flatpak_progress_init_extra_data (progress, n_extra_data, total_download_size);\n\n  return TRUE;\n}\n\nstatic gboolean\nflatpak_dir_pull_extra_data (FlatpakDir          *self,\n                             OstreeRepo          *repo,\n                             const char          *repository,\n                             const char          *ref,\n                             const char          *rev,\n                             FlatpakPullFlags     flatpak_flags,\n                             FlatpakProgress     *progress,\n                             GCancellable        *cancellable,\n                             GError             **error)\n{\n  g_autoptr(GVariant) extra_data_sources = NULL;\n  g_autoptr(GVariant) detached_metadata = NULL;\n  g_auto(GVariantDict) new_metadata_dict = FLATPAK_VARIANT_DICT_INITIALIZER;\n  g_autoptr(GVariantBuilder) extra_data_builder = NULL;\n  g_autoptr(GVariant) new_detached_metadata = NULL;\n  g_autoptr(GVariant) extra_data = NULL;\n  g_autoptr(GFile) base_dir = NULL;\n  int i;\n  gsize n_extra_data;\n\n  extra_data_sources = flatpak_repo_get_extra_data_sources (repo, rev, cancellable, NULL);\n  if (extra_data_sources == NULL)\n    return TRUE;\n\n  n_extra_data = g_variant_n_children (extra_data_sources);\n  if (n_extra_data == 0)\n    return TRUE;\n\n  if ((flatpak_flags & FLATPAK_PULL_FLAGS_DOWNLOAD_EXTRA_DATA) == 0)\n    return flatpak_fail_error (error, FLATPAK_ERROR_UNTRUSTED, _(\"Extra data not supported for non-gpg-verified local system installs\"));\n\n  extra_data_builder = g_variant_builder_new (G_VARIANT_TYPE (\"a(ayay)\"));\n\n  /* Other fields were already set in flatpak_dir_setup_extra_data() */\n  flatpak_progress_start_extra_data (progress);\n\n  base_dir = flatpak_get_user_base_dir_location ();\n\n  for (i = 0; i < n_extra_data; i++)\n    {\n      const char *extra_data_uri = NULL;\n      g_autofree char *extra_data_sha256 = NULL;\n      const char *extra_data_name = NULL;\n      guint64 download_size;\n      guint64 installed_size;\n      g_autofree char *sha256 = NULL;\n      const guchar *sha256_bytes;\n      g_autoptr(GBytes) bytes = NULL;\n      g_autoptr(GFile) extra_local_file = NULL;\n\n      flatpak_repo_parse_extra_data_sources (extra_data_sources, i,\n                                             &extra_data_name,\n                                             &download_size,\n                                             &installed_size,\n                                             &sha256_bytes,\n                                             &extra_data_uri);\n\n      if (sha256_bytes == NULL)\n        return flatpak_fail_error (error, FLATPAK_ERROR_INVALID_DATA, _(\"Invalid checksum for extra data uri %s\"), extra_data_uri);\n\n      extra_data_sha256 = ostree_checksum_from_bytes (sha256_bytes);\n\n      if (*extra_data_name == 0)\n        return flatpak_fail_error (error, FLATPAK_ERROR_INVALID_DATA, _(\"Empty name for extra data uri %s\"), extra_data_uri);\n\n      /* Don't allow file uris here as that could read local files based on remote data */\n      if (!g_str_has_prefix (extra_data_uri, \"http:\") &&\n          !g_str_has_prefix (extra_data_uri, \"https:\"))\n        {\n          flatpak_progress_reset_extra_data (progress);\n          return flatpak_fail_error (error, FLATPAK_ERROR_INVALID_DATA, _(\"Unsupported extra data uri %s\"), extra_data_uri);\n        }\n\n      /* TODO: Download to disk to support resumed downloads on error */\n\n      extra_local_file = flatpak_build_file (base_dir, \"extra-data\", extra_data_sha256, extra_data_name, NULL);\n      if (g_file_query_exists (extra_local_file, cancellable))\n        {\n          g_debug (\"Loading extra-data from local file %s\", flatpak_file_get_path_cached (extra_local_file));\n          gsize extra_local_size;\n          g_autofree char *extra_local_contents = NULL;\n          g_autoptr(GError) my_error = NULL;\n\n          if (!g_file_load_contents (extra_local_file, cancellable, &extra_local_contents, &extra_local_size, NULL, &my_error))\n            return flatpak_fail_error (error, FLATPAK_ERROR_INVALID_DATA, _(\"Failed to load local extra-data %s: %s\"),\n                                       flatpak_file_get_path_cached (extra_local_file), my_error->message);\n          if (extra_local_size != download_size)\n            return flatpak_fail_error (error, FLATPAK_ERROR_INVALID_DATA, _(\"Wrong size for extra-data %s\"), flatpak_file_get_path_cached (extra_local_file));\n\n          bytes = g_bytes_new (extra_local_contents, extra_local_size);\n        }\n      else\n        {\n          ensure_soup_session (self);\n          bytes = flatpak_load_uri (self->soup_session, extra_data_uri, 0, NULL,\n                                    extra_data_progress_report, progress, NULL,\n                                    cancellable, error);\n        }\n\n      if (bytes == NULL)\n        {\n          flatpak_progress_reset_extra_data (progress);\n          g_prefix_error (error, _(\"While downloading %s: \"), extra_data_uri);\n          return FALSE;\n        }\n\n      if (g_bytes_get_size (bytes) != download_size)\n        {\n          flatpak_progress_reset_extra_data (progress);\n          return flatpak_fail_error (error, FLATPAK_ERROR_INVALID_DATA, _(\"Wrong size for extra data %s\"), extra_data_uri);\n        }\n\n      flatpak_progress_complete_extra_data_download (progress, download_size);\n\n      sha256 = g_compute_checksum_for_bytes (G_CHECKSUM_SHA256, bytes);\n      if (strcmp (sha256, extra_data_sha256) != 0)\n        {\n          flatpak_progress_reset_extra_data (progress);\n          return flatpak_fail_error (error, FLATPAK_ERROR_INVALID_DATA, _(\"Invalid checksum for extra data %s\"), extra_data_uri);\n        }\n\n      g_variant_builder_add (extra_data_builder,\n                             \"(^ay@ay)\",\n                             extra_data_name,\n                             g_variant_new_from_bytes (G_VARIANT_TYPE (\"ay\"), bytes, TRUE));\n    }\n\n  extra_data = g_variant_ref_sink (g_variant_builder_end (extra_data_builder));\n\n  flatpak_progress_reset_extra_data (progress);\n\n  if (!ostree_repo_read_commit_detached_metadata (repo, rev, &detached_metadata,\n                                                  cancellable, error))\n    return FALSE;\n\n  g_variant_dict_init (&new_metadata_dict, detached_metadata);\n  g_variant_dict_insert_value (&new_metadata_dict, \"xa.extra-data\", extra_data);\n  new_detached_metadata = g_variant_ref_sink (g_variant_dict_end (&new_metadata_dict));\n\n  /* There is a commitmeta size limit when pulling, so we have to side-load it\n     when installing in the system repo */\n  if (flatpak_flags & FLATPAK_PULL_FLAGS_SIDELOAD_EXTRA_DATA)\n    {\n      int dfd =  ostree_repo_get_dfd (repo);\n      g_autoptr(GVariant) normalized = g_variant_get_normal_form (new_detached_metadata);\n      gsize normalized_size = g_variant_get_size (normalized);\n      const guint8 *data = g_variant_get_data (normalized);\n      g_autofree char *filename = NULL;\n\n      filename = g_strconcat (rev, \".commitmeta\", NULL);\n      if (!glnx_file_replace_contents_at (dfd, filename,\n                                          data, normalized_size,\n                                          0, cancellable, error))\n        {\n          g_prefix_error (error, \"Unable to write sideloaded detached metadata: \");\n          return FALSE;\n        }\n    }\n  else\n    {\n      if (!ostree_repo_write_commit_detached_metadata (repo, rev, new_detached_metadata,\n                                                       cancellable, error))\n        return FALSE;\n    }\n\n  return TRUE;\n}\n\nstatic void\noci_pull_progress_cb (guint64 total_size, guint64 pulled_size,\n                      guint32 n_layers, guint32 pulled_layers,\n                      gpointer data)\n{\n  FlatpakProgress *progress = data;\n\n  flatpak_progress_update_oci_pull (progress, total_size, pulled_size, n_layers, pulled_layers);\n}\n\nstatic gboolean\nflatpak_dir_mirror_oci (FlatpakDir          *self,\n                        FlatpakOciRegistry  *dst_registry,\n                        FlatpakRemoteState  *state,\n                        const char          *ref,\n                        const char          *opt_rev,\n                        const char          *skip_if_current_is,\n                        const char          *token,\n                        FlatpakProgress     *progress,\n                        GCancellable        *cancellable,\n                        GError             **error)\n{\n  g_autoptr(FlatpakOciRegistry) registry = NULL;\n  g_autofree char *oci_digest = NULL;\n  g_autofree char *latest_rev = NULL;\n  VarRefInfoRef latest_rev_info;\n  VarMetadataRef metadata;\n  const char *oci_repository = NULL;\n  const char *delta_url = NULL;\n  const char *rev;\n  gboolean res;\n\n  /* We use the summary so that we can reuse any cached json */\n  if (!flatpak_remote_state_lookup_ref (state, ref, &latest_rev, NULL, &latest_rev_info, NULL, error))\n    return FALSE;\n  if (latest_rev == NULL)\n    return flatpak_fail_error (error, FLATPAK_ERROR_REF_NOT_FOUND,\n                               _(\"Couldn't find latest checksum for ref %s in remote %s\"),\n                               ref, state->remote_name);\n\n  rev = opt_rev != NULL ? opt_rev : latest_rev;\n\n  if (skip_if_current_is != NULL && strcmp (rev, skip_if_current_is) == 0)\n    {\n      return flatpak_fail_error (error, FLATPAK_ERROR_ALREADY_INSTALLED,\n                                 _(\"%s commit %s already installed\"),\n                                 ref, rev);\n    }\n\n  metadata = var_ref_info_get_metadata (latest_rev_info);\n  oci_repository = var_metadata_lookup_string (metadata, \"xa.oci-repository\", NULL);\n  delta_url = var_metadata_lookup_string (metadata, \"xa.delta-url\", NULL);\n\n  oci_digest = g_strconcat (\"sha256:\", rev, NULL);\n\n  registry = flatpak_remote_state_new_oci_registry (state, token, cancellable, error);\n  if (registry == NULL)\n    return FALSE;\n\n  flatpak_progress_start_oci_pull (progress);\n\n  g_debug (\"Mirroring OCI image %s\", oci_digest);\n\n  res = flatpak_mirror_image_from_oci (dst_registry, registry, oci_repository, oci_digest, state->remote_name, ref, delta_url, self->repo, oci_pull_progress_cb,\n                                       progress, cancellable, error);\n\n  if (!res)\n    return FALSE;\n\n  return TRUE;\n}\n\nstatic gboolean\nflatpak_dir_pull_oci (FlatpakDir          *self,\n                      FlatpakRemoteState  *state,\n                      const char          *ref,\n                      const char          *opt_rev,\n                      OstreeRepo          *repo,\n                      FlatpakPullFlags     flatpak_flags,\n                      OstreeRepoPullFlags  flags,\n                      const char          *token,\n                      FlatpakProgress     *progress,\n                      GCancellable        *cancellable,\n                      GError             **error)\n{\n  g_autoptr(FlatpakOciRegistry) registry = NULL;\n  g_autoptr(FlatpakOciVersioned) versioned = NULL;\n  g_autoptr(FlatpakOciImage) image_config = NULL;\n  g_autofree char *full_ref = NULL;\n  const char *oci_repository = NULL;\n  const char *delta_url = NULL;\n  g_autofree char *oci_digest = NULL;\n  g_autofree char *checksum = NULL;\n  VarRefInfoRef latest_rev_info;\n  g_autofree char *latest_alt_commit = NULL;\n  VarMetadataRef metadata;\n  g_autofree char *latest_rev = NULL;\n  G_GNUC_UNUSED g_autofree char *latest_commit =\n    flatpak_dir_read_latest (self, state->remote_name, ref, &latest_alt_commit, cancellable, NULL);\n  g_autofree char *name = NULL;\n\n  /* We use the summary so that we can reuse any cached json */\n  if (!flatpak_remote_state_lookup_ref (state, ref, &latest_rev, NULL, &latest_rev_info, NULL, error))\n    return FALSE;\n  if (latest_rev == NULL)\n    return flatpak_fail_error (error, FLATPAK_ERROR_REF_NOT_FOUND,\n                               _(\"Couldn't find latest checksum for ref %s in remote %s\"),\n                               ref, state->remote_name);\n\n  metadata = var_ref_info_get_metadata (latest_rev_info);\n  oci_repository = var_metadata_lookup_string (metadata, \"xa.oci-repository\", NULL);\n  delta_url = var_metadata_lookup_string (metadata, \"xa.delta-url\", NULL);\n\n  oci_digest = g_strconcat (\"sha256:\", opt_rev != NULL ? opt_rev : latest_rev, NULL);\n\n  /* Short circuit if we've already got this commit */\n  if (latest_alt_commit != NULL && strcmp (oci_digest + strlen (\"sha256:\"), latest_alt_commit) == 0)\n    return TRUE;\n\n  registry = flatpak_remote_state_new_oci_registry (state, token, cancellable, error);\n  if (registry == NULL)\n    return FALSE;\n\n  versioned = flatpak_oci_registry_load_versioned (registry, oci_repository, oci_digest,\n                                                   NULL, NULL, cancellable, error);\n  if (versioned == NULL)\n    return FALSE;\n\n  if (!FLATPAK_IS_OCI_MANIFEST (versioned))\n    return flatpak_fail_error (error, FLATPAK_ERROR_INVALID_DATA, _(\"Image is not a manifest\"));\n\n  image_config = flatpak_oci_registry_load_image_config (registry, oci_repository,\n                                                         FLATPAK_OCI_MANIFEST (versioned)->config.digest,\n                                                         (const char **)FLATPAK_OCI_MANIFEST (versioned)->config.urls,\n                                                         NULL, cancellable, error);\n  if (image_config == NULL)\n    return FALSE;\n\n  full_ref = g_strdup_printf (\"%s:%s\", state->remote_name, ref);\n\n  if (repo == NULL)\n    repo = self->repo;\n\n  flatpak_progress_start_oci_pull (progress);\n\n  g_debug (\"Pulling OCI image %s\", oci_digest);\n\n  checksum = flatpak_pull_from_oci (repo, registry, oci_repository, oci_digest, delta_url, FLATPAK_OCI_MANIFEST (versioned), image_config,\n                                    state->remote_name, ref, flatpak_flags, oci_pull_progress_cb, progress, cancellable, error);\n\n  if (checksum == NULL)\n    return FALSE;\n\n  g_debug (\"Imported OCI image as checksum %s\", checksum);\n\n  if (repo == self->repo)\n    name = flatpak_dir_get_name (self);\n  else\n    {\n      GFile *file = ostree_repo_get_path (repo);\n      name = g_file_get_path (file);\n    }\n\n  (flatpak_dir_log) (self, __FILE__, __LINE__, __FUNCTION__, name,\n                     \"pull oci\", flatpak_oci_registry_get_uri (registry), ref, NULL, NULL, NULL,\n                     \"Pulled %s from %s\", ref, flatpak_oci_registry_get_uri (registry));\n\n  return TRUE;\n}\n\ngboolean\nflatpak_dir_pull (FlatpakDir                           *self,\n                  FlatpakRemoteState                   *state,\n                  const char                           *ref,\n                  const char                           *opt_rev,\n                  const char                          **subpaths,\n                  GFile                                *sideload_repo,\n                  GBytes                               *require_metadata,\n                  const char                           *token,\n                  OstreeRepo                           *repo,\n                  FlatpakPullFlags                      flatpak_flags,\n                  OstreeRepoPullFlags                   flags,\n                  FlatpakProgress                      *progress,\n                  GCancellable                         *cancellable,\n                  GError                              **error)\n{\n  gboolean ret = FALSE;\n  g_autofree char *rev = NULL;\n  g_autofree char *url = NULL;\n  g_autoptr(GPtrArray) subdirs_arg = NULL;\n  g_auto(GLnxLockFile) lock = { 0, };\n  g_autofree char *name = NULL;\n  g_autofree char *current_checksum = NULL;\n\n  if (!flatpak_dir_ensure_repo (self, cancellable, error))\n    return FALSE;\n\n  /* Keep a shared repo lock to avoid prunes removing objects we're relying on\n   * while we do the pull. There are two cases we protect against. 1) objects we\n   * need but that we already decided are locally available could be removed,\n   * and 2) during the transaction commit objects that don't yet have a ref to\n   * them could be considered unreachable.\n   */\n  if (repo == NULL && !flatpak_dir_repo_lock (self, &lock, LOCK_SH, cancellable, error))\n    return FALSE;\n\n  if (flatpak_dir_get_remote_oci (self, state->remote_name))\n    return flatpak_dir_pull_oci (self, state, ref, opt_rev, repo, flatpak_flags,\n                                 flags, token, progress, cancellable, error);\n\n  if (!ostree_repo_remote_get_url (self->repo,\n                                   state->remote_name,\n                                   &url,\n                                   error))\n    return FALSE;\n\n  if (*url == 0)\n    return TRUE; /* Empty url, silently disables updates */\n\n  /* We get the rev ahead of time so that we know it for looking up e.g. extra-data\n     and to make sure we're atomically using a single rev if we happen to do multiple\n     pulls (e.g. with subpaths) */\n  if (opt_rev != NULL)\n    {\n      rev = g_strdup (opt_rev);\n    }\n  else\n    {\n      flatpak_remote_state_lookup_ref (state, ref, &rev, NULL, NULL, NULL, error);\n      if (rev == NULL && error != NULL && *error == NULL)\n        flatpak_fail_error (error, FLATPAK_ERROR_REF_NOT_FOUND, _(\"Couldn't find latest checksum for ref %s in remote %s\"),\n                            ref, state->remote_name);\n\n      if (rev == NULL)\n        {\n          g_assert (error == NULL || *error != NULL);\n          return FALSE;\n        }\n    }\n\n  g_debug (\"%s: Using commit %s for pull of ref %s from remote %s%s%s\",\n           G_STRFUNC, rev, ref, state->remote_name,\n           sideload_repo ? \"sideloaded from \" : \"\",\n           sideload_repo ? flatpak_file_get_path_cached (sideload_repo) : \"\"\n           );\n\n  if (repo == NULL)\n    repo = self->repo;\n\n  /* Past this we must use goto out, so we clean up console and\n     abort the transaction on error */\n\n  if (subpaths != NULL && subpaths[0] != NULL)\n    {\n      subdirs_arg = g_ptr_array_new_with_free_func (g_free);\n      int i;\n      g_ptr_array_add (subdirs_arg, g_strdup (\"/metadata\"));\n      for (i = 0; subpaths[i] != NULL; i++)\n        g_ptr_array_add (subdirs_arg,\n                         g_build_filename (\"/files\", subpaths[i], NULL));\n      g_ptr_array_add (subdirs_arg, NULL);\n    }\n\n  /* Setup extra data information before starting to pull, so we can have precise\n   * progress reports */\n  if (!flatpak_dir_setup_extra_data (self, state, repo,\n                                     ref, rev, sideload_repo, token,\n                                     flatpak_flags,\n                                     progress,\n                                     cancellable,\n                                     error))\n    goto out;\n\n  if (!ostree_repo_prepare_transaction (repo, NULL, cancellable, error))\n    goto out;\n\n  flatpak_repo_resolve_rev (repo, NULL, state->remote_name, ref, TRUE,\n                            &current_checksum, NULL, NULL);\n\n  if (!repo_pull (repo, state,\n                  subdirs_arg ? (const char **) subdirs_arg->pdata : NULL,\n                  ref, rev, sideload_repo, token, flatpak_flags, flags,\n                  progress,\n                  cancellable, error))\n    {\n      g_prefix_error (error, _(\"While pulling %s from remote %s: \"), ref, state->remote_name);\n      goto out;\n    }\n\n\n  if (require_metadata)\n    {\n      g_autoptr(GVariant) commit_data = NULL;\n      if (!ostree_repo_load_commit (repo, rev, &commit_data, NULL, error) ||\n          !validate_commit_metadata (commit_data, ref, (const char *)g_bytes_get_data (require_metadata, NULL), TRUE, error))\n        return FALSE;\n    }\n\n  if (!flatpak_dir_pull_extra_data (self, repo,\n                                    state->remote_name,\n                                    ref, rev,\n                                    flatpak_flags,\n                                    progress,\n                                    cancellable,\n                                    error))\n    goto out;\n\n\n  if (!ostree_repo_commit_transaction (repo, NULL, cancellable, error))\n    goto out;\n\n  ret = TRUE;\n\n  if (repo == self->repo)\n    name = flatpak_dir_get_name (self);\n  else\n    {\n      GFile *file = ostree_repo_get_path (repo);\n      name = g_file_get_path (file);\n    }\n\n  (flatpak_dir_log) (self, __FILE__, __LINE__, __FUNCTION__, name,\n                     \"pull\", state->remote_name, ref, rev, current_checksum, NULL,\n                     \"Pulled %s from %s\", ref, state->remote_name);\n\nout:\n  if (!ret)\n    {\n      ostree_repo_abort_transaction (repo, cancellable, NULL);\n      g_assert (error == NULL || *error != NULL);\n    }\n\n  return ret;\n}\n\nstatic gboolean\nrepo_pull_local_untrusted (FlatpakDir          *self,\n                           OstreeRepo          *repo,\n                           const char          *remote_name,\n                           const char          *url,\n                           const char         **dirs_to_pull,\n                           const char          *ref,\n                           const char          *checksum,\n                           FlatpakProgress     *progress,\n                           GCancellable        *cancellable,\n                           GError             **error)\n{\n  /* The latter flag was introduced in https://github.com/ostreedev/ostree/pull/926 */\n  const OstreeRepoPullFlags flags = OSTREE_REPO_PULL_FLAGS_UNTRUSTED | OSTREE_REPO_PULL_FLAGS_BAREUSERONLY_FILES;\n  GVariantBuilder builder;\n  g_autoptr(GVariant) options = NULL;\n  gboolean res;\n  g_variant_builder_init (&builder, G_VARIANT_TYPE (\"a{sv}\"));\n  const char *refs[2] = { NULL, NULL };\n  const char *commits[2] = { NULL, NULL };\n  g_autoptr(GError) dummy_error = NULL;\n  g_auto(FlatpakMainContext) context = FLATKPAK_MAIN_CONTEXT_INIT;\n\n  /* The ostree fetcher asserts if error is NULL */\n  if (error == NULL)\n    error = &dummy_error;\n\n  refs[0] = ref;\n  commits[0] = checksum;\n\n  g_variant_builder_add (&builder, \"{s@v}\", \"refs\",\n                         g_variant_new_variant (g_variant_new_strv ((const char * const *) refs, -1)));\n  g_variant_builder_add (&builder, \"{s@v}\", \"override-commit-ids\",\n                         g_variant_new_variant (g_variant_new_strv ((const char * const *) commits, -1)));\n\n  g_variant_builder_add (&builder, \"{s@v}\", \"flags\",\n                         g_variant_new_variant (g_variant_new_int32 (flags)));\n  g_variant_builder_add (&builder, \"{s@v}\", \"override-remote-name\",\n                         g_variant_new_variant (g_variant_new_string (remote_name)));\n  g_variant_builder_add (&builder, \"{s@v}\", \"gpg-verify\",\n                         g_variant_new_variant (g_variant_new_boolean (TRUE)));\n  g_variant_builder_add (&builder, \"{s@v}\", \"gpg-verify-summary\",\n                         g_variant_new_variant (g_variant_new_boolean (FALSE)));\n  g_variant_builder_add (&builder, \"{s@v}\", \"inherit-transaction\",\n                         g_variant_new_variant (g_variant_new_boolean (TRUE)));\n  g_variant_builder_add (&builder, \"{s@v}\", \"update-frequency\",\n                         g_variant_new_variant (g_variant_new_uint32 (FLATPAK_DEFAULT_UPDATE_INTERVAL_MS)));\n\n  if (dirs_to_pull)\n    {\n      g_variant_builder_add (&builder, \"{s@v}\", \"subdirs\",\n                             g_variant_new_variant (g_variant_new_strv ((const char * const *) dirs_to_pull, -1)));\n      g_variant_builder_add (&builder, \"{s@v}\", \"disable-static-deltas\",\n                             g_variant_new_variant (g_variant_new_boolean (TRUE)));\n    }\n\n  options = g_variant_ref_sink (g_variant_builder_end (&builder));\n\n  flatpak_progress_init_main_context (progress, &context);\n  res = ostree_repo_pull_with_options (repo, url, options,\n                                       context.ostree_progress, cancellable, error);\n  if (!res)\n    translate_ostree_repo_pull_errors (error);\n\n  return res;\n}\n\ngboolean\nflatpak_dir_pull_untrusted_local (FlatpakDir          *self,\n                                  const char          *src_path,\n                                  const char          *remote_name,\n                                  const char          *ref,\n                                  const char         **subpaths,\n                                  FlatpakProgress     *progress,\n                                  GCancellable        *cancellable,\n                                  GError             **error)\n{\n  g_autoptr(GFile) path_file = g_file_new_for_path (src_path);\n  g_autofree char *url = g_file_get_uri (path_file);\n  g_autofree char *checksum = NULL;\n  g_autofree char *current_checksum = NULL;\n  gboolean gpg_verify_summary;\n  gboolean gpg_verify;\n  g_autoptr(OstreeGpgVerifyResult) gpg_result = NULL;\n  g_autoptr(GVariant) old_commit = NULL;\n  g_autoptr(OstreeRepo) src_repo = NULL;\n  g_autoptr(GVariant) new_commit = NULL;\n  g_autoptr(GVariant) new_commit_metadata = NULL;\n  g_autoptr(GVariant) extra_data_sources = NULL;\n  g_autoptr(GPtrArray) subdirs_arg = NULL;\n  g_auto(GLnxLockFile) lock = { 0, };\n  gboolean ret = FALSE;\n  g_autofree const char **ref_bindings = NULL;\n\n  if (!flatpak_dir_ensure_repo (self, cancellable, error))\n    return FALSE;\n\n  /* Keep a shared repo lock to avoid prunes removing objects we're relying on\n   * while we do the pull. There are two cases we protect against. 1) objects we\n   * need but that we already decided are locally available could be removed,\n   * and 2) during the transaction commit objects that don't yet have a ref to\n   * them could be considered unreachable.\n   */\n  if (!flatpak_dir_repo_lock (self, &lock, LOCK_SH, cancellable, error))\n    return FALSE;\n\n  if (!ostree_repo_remote_get_gpg_verify_summary (self->repo, remote_name,\n                                                  &gpg_verify_summary, error))\n    return FALSE;\n\n  if (!ostree_repo_remote_get_gpg_verify (self->repo, remote_name,\n                                          &gpg_verify, error))\n    return FALSE;\n\n  /* This was verified in the client, but lets do it here too */\n  if (!gpg_verify_summary || !gpg_verify)\n    return flatpak_fail_error (error, FLATPAK_ERROR_UNTRUSTED, _(\"Can't pull from untrusted non-gpg verified remote\"));\n\n  if (!flatpak_repo_resolve_rev (self->repo, NULL, remote_name, ref, TRUE,\n                                 &current_checksum, NULL, error))\n    return FALSE;\n\n  if (current_checksum != NULL &&\n      !ostree_repo_load_commit (self->repo, current_checksum, &old_commit, NULL, error))\n    return FALSE;\n\n  src_repo = ostree_repo_new (path_file);\n  if (!ostree_repo_open (src_repo, cancellable, error))\n    return FALSE;\n\n  if (!flatpak_repo_resolve_rev (src_repo, NULL, remote_name, ref, FALSE, &checksum, NULL, error))\n    return FALSE;\n\n  if (gpg_verify)\n    {\n      gpg_result = ostree_repo_verify_commit_for_remote (src_repo, checksum, remote_name, cancellable, error);\n      if (gpg_result == NULL)\n        return FALSE;\n\n      if (ostree_gpg_verify_result_count_valid (gpg_result) == 0)\n        return flatpak_fail_error (error, FLATPAK_ERROR_UNTRUSTED, _(\"GPG signatures found, but none are in trusted keyring\"));\n    }\n\n  g_clear_object (&gpg_result);\n\n  if (!ostree_repo_load_commit (src_repo, checksum, &new_commit, NULL, error))\n    return FALSE;\n\n  /* Here we check that there is actually a ref binding, otherwise we\n     could allow installing a ref as another app, because both would\n     pass gpg validation. Note that ostree pull actually also verifies\n     the ref-bindings, but only if they exist. We could do only the\n     ref-binding existence check, but if we got something weird might as\n     well stop handling it early. */\n\n  new_commit_metadata = g_variant_get_child_value (new_commit, 0);\n  if (!g_variant_lookup (new_commit_metadata, OSTREE_COMMIT_META_KEY_REF_BINDING, \"^a&s\", &ref_bindings))\n    return flatpak_fail_error (error, FLATPAK_ERROR_INVALID_DATA, _(\"Commit for \u2018%s\u2019 has no ref binding\"),  ref);\n\n  if (!g_strv_contains ((const char *const *) ref_bindings, ref))\n    {\n      g_autofree char *as_string = g_strjoinv (\", \", (char **)ref_bindings);\n      return flatpak_fail_error (error, FLATPAK_ERROR_INVALID_DATA, _(\"Commit for \u2018%s\u2019 is not in expected bound refs: %s\"),  ref, as_string);\n    }\n\n  if (old_commit)\n    {\n      guint64 old_timestamp;\n      guint64 new_timestamp;\n\n      old_timestamp = ostree_commit_get_timestamp (old_commit);\n      new_timestamp = ostree_commit_get_timestamp (new_commit);\n\n      if (new_timestamp < old_timestamp)\n        return flatpak_fail_error (error, FLATPAK_ERROR_DOWNGRADE, \"Not allowed to downgrade %s (old_commit: %s/%\" G_GINT64_FORMAT \" new_commit: %s/%\" G_GINT64_FORMAT \")\",\n                                   ref, current_checksum, old_timestamp, checksum, new_timestamp);\n    }\n\n  if (subpaths != NULL && subpaths[0] != NULL)\n    {\n      subdirs_arg = g_ptr_array_new_with_free_func (g_free);\n      int i;\n      g_ptr_array_add (subdirs_arg, g_strdup (\"/metadata\"));\n      for (i = 0; subpaths[i] != NULL; i++)\n        g_ptr_array_add (subdirs_arg,\n                         g_build_filename (\"/files\", subpaths[i], NULL));\n      g_ptr_array_add (subdirs_arg, NULL);\n    }\n\n  if (!ostree_repo_prepare_transaction (self->repo, NULL, cancellable, error))\n    goto out;\n\n  /* Past this we must use goto out, so we abort the transaction on error */\n\n  if (!repo_pull_local_untrusted (self, self->repo, remote_name, url,\n                                  subdirs_arg ? (const char **) subdirs_arg->pdata : NULL,\n                                  ref, checksum, progress,\n                                  cancellable, error))\n    {\n      g_prefix_error (error, _(\"While pulling %s from remote %s: \"), ref, remote_name);\n      goto out;\n    }\n\n  /* Get the out of bands extra-data required due to an ostree pull\n     commitmeta size limit */\n  extra_data_sources = flatpak_commit_get_extra_data_sources (new_commit, NULL);\n  if (extra_data_sources)\n    {\n      GFile *dir = ostree_repo_get_path (src_repo);\n      g_autoptr(GFile) file = NULL;\n      g_autofree char *filename = NULL;\n      g_autofree char *commitmeta = NULL;\n      gsize commitmeta_size;\n      g_autoptr(GVariant) new_metadata = NULL;\n\n      filename = g_strconcat (checksum, \".commitmeta\", NULL);\n      file = g_file_get_child (dir, filename);\n      if (!g_file_load_contents (file, cancellable,\n                                 &commitmeta, &commitmeta_size,\n                                 NULL, error))\n        goto out;\n\n      new_metadata = g_variant_ref_sink (g_variant_new_from_data (G_VARIANT_TYPE (\"a{sv}\"),\n                                                                  commitmeta, commitmeta_size,\n                                                                  FALSE,\n                                                                  g_free, commitmeta));\n      g_steal_pointer (&commitmeta); /* steal into the variant */\n\n      if (!ostree_repo_write_commit_detached_metadata (self->repo, checksum, new_metadata, cancellable, error))\n        goto out;\n    }\n\n  if (!ostree_repo_commit_transaction (self->repo, NULL, cancellable, error))\n    goto out;\n\n  ret = TRUE;\n\n  flatpak_dir_log (self, \"pull local\", src_path, ref, checksum, current_checksum, NULL,\n                   \"Pulled %s from %s\", ref, src_path);\nout:\n  if (!ret)\n    ostree_repo_abort_transaction (self->repo, cancellable, NULL);\n\n  return ret;\n}\n\nFlatpakDecomposed *\nflatpak_dir_current_ref (FlatpakDir   *self,\n                         const char   *name,\n                         GCancellable *cancellable)\n{\n  g_autoptr(GFile) base = NULL;\n  g_autoptr(GFile) dir = NULL;\n  g_autoptr(GFile) current_link = NULL;\n  g_autoptr(GFileInfo) file_info = NULL;\n  FlatpakDecomposed *decomposed;\n  char *ref;\n\n  base = g_file_get_child (flatpak_dir_get_path (self), \"app\");\n  dir = g_file_get_child (base, name);\n\n  current_link = g_file_get_child (dir, \"current\");\n\n  file_info = g_file_query_info (current_link, OSTREE_GIO_FAST_QUERYINFO,\n                                 G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n                                 cancellable, NULL);\n  if (file_info == NULL)\n    return NULL;\n\n  ref = g_strconcat (\"app/\", name, \"/\", g_file_info_get_symlink_target (file_info), NULL);\n  decomposed = flatpak_decomposed_new_from_ref_take (ref, NULL);\n  if (decomposed == NULL)\n    g_free (ref);\n\n  return decomposed;\n}\n\ngboolean\nflatpak_dir_drop_current_ref (FlatpakDir   *self,\n                              const char   *name,\n                              GCancellable *cancellable,\n                              GError      **error)\n{\n  g_autoptr(GFile) base = NULL;\n  g_autoptr(GFile) dir = NULL;\n  g_autoptr(GFile) current_link = NULL;\n  g_autoptr(GPtrArray) refs = NULL;\n  g_autoptr(FlatpakDecomposed) current_ref = NULL;\n  FlatpakDecomposed *other_ref = NULL;\n\n  current_ref = flatpak_dir_current_ref (self, name, cancellable);\n  if (current_ref)\n    {\n      refs = flatpak_dir_list_refs_for_name (self, FLATPAK_KINDS_APP, name, cancellable, NULL);\n      if (refs)\n        {\n          for (int i = 0; i < refs->len; i++)\n            {\n              FlatpakDecomposed *ref = g_ptr_array_index (refs, i);\n              if (!flatpak_decomposed_equal (ref, current_ref))\n                {\n                  other_ref = ref;\n                  break;\n                }\n            }\n        }\n    }\n\n  base = g_file_get_child (flatpak_dir_get_path (self), \"app\");\n  dir = g_file_get_child (base, name);\n\n  current_link = g_file_get_child (dir, \"current\");\n  if (!g_file_delete (current_link, cancellable, error))\n    return FALSE;\n\n  if (other_ref)\n    {\n      if (!flatpak_dir_make_current_ref (self, other_ref, cancellable, error))\n        return FALSE;\n    }\n\n  return TRUE;\n}\n\ngboolean\nflatpak_dir_make_current_ref (FlatpakDir        *self,\n                              FlatpakDecomposed *ref,\n                              GCancellable      *cancellable,\n                              GError           **error)\n{\n  g_autoptr(GFile) base = NULL;\n  g_autoptr(GFile) dir = NULL;\n  g_autoptr(GFile) current_link = NULL;\n  g_autofree char *id = NULL;\n  const char *rest;\n\n  if (!flatpak_decomposed_is_app (ref))\n    return flatpak_fail (error, _(\"Only applications can be made current\"));\n\n  base = g_file_get_child (flatpak_dir_get_path (self), flatpak_decomposed_get_kind_str (ref));\n\n  id = flatpak_decomposed_dup_id (ref);\n  dir = g_file_get_child (base, id);\n\n  current_link = g_file_get_child (dir, \"current\");\n\n  g_file_delete (current_link, cancellable, NULL);\n\n  rest = flatpak_decomposed_peek_arch (ref, NULL);\n  if (!g_file_make_symbolic_link (current_link, rest, cancellable, error))\n    return FALSE;\n\n  return TRUE;\n}\n\nstatic gboolean\n_flatpak_dir_list_refs_for_name (FlatpakDir   *self,\n                                 GFile        *base_dir,\n                                 FlatpakKinds kind,\n                                 const char   *name,\n                                 GPtrArray    *refs,\n                                 GCancellable *cancellable,\n                                 GError      **error)\n{\n  g_autoptr(GFile) dir = NULL;\n  g_autoptr(GFileEnumerator) dir_enum = NULL;\n  g_autoptr(GFileInfo) child_info = NULL;\n  GError *temp_error = NULL;\n\n  g_assert (kind == FLATPAK_KINDS_RUNTIME || kind == FLATPAK_KINDS_APP);\n\n  dir = g_file_get_child (base_dir, name);\n\n  if (!g_file_query_exists (dir, cancellable))\n    return TRUE;\n\n  dir_enum = g_file_enumerate_children (dir, OSTREE_GIO_FAST_QUERYINFO,\n                                        G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n                                        cancellable, error);\n  if (!dir_enum)\n    return FALSE;\n\n  while ((child_info = g_file_enumerator_next_file (dir_enum, cancellable, &temp_error)))\n    {\n      g_autoptr(GFile) child = NULL;\n      g_autoptr(GFileEnumerator) dir_enum2 = NULL;\n      g_autoptr(GFileInfo) child_info2 = NULL;\n      const char *arch;\n\n      arch = g_file_info_get_name (child_info);\n\n      if (g_file_info_get_file_type (child_info) != G_FILE_TYPE_DIRECTORY ||\n          strcmp (arch, \"data\") == 0 /* There used to be a data dir here, lets ignore it */)\n        {\n          g_clear_object (&child_info);\n          continue;\n        }\n\n      child = g_file_get_child (dir, arch);\n      g_clear_object (&dir_enum2);\n      dir_enum2 = g_file_enumerate_children (child, OSTREE_GIO_FAST_QUERYINFO,\n                                             G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n                                             cancellable, error);\n      if (!dir_enum2)\n        return FALSE;\n\n      while ((child_info2 = g_file_enumerator_next_file (dir_enum2, cancellable, &temp_error)))\n        {\n          const char *branch = g_file_info_get_name (child_info2);\n\n          if (g_file_info_get_file_type (child_info2) == G_FILE_TYPE_DIRECTORY)\n            {\n              g_autoptr(GFile) deploy = flatpak_build_file (child, branch, \"active/deploy\", NULL);\n\n              if (g_file_query_exists (deploy, NULL))\n                {\n                  FlatpakDecomposed *ref = flatpak_decomposed_new_from_parts (kind, name, arch, branch, NULL);\n                  if (ref)\n                    g_ptr_array_add (refs, ref);\n                }\n            }\n\n          g_clear_object (&child_info2);\n        }\n\n      if (temp_error != NULL)\n        {\n          g_propagate_error (error, temp_error);\n          return FALSE;\n        }\n\n      g_clear_object (&child_info);\n    }\n\n  if (temp_error != NULL)\n    {\n      g_propagate_error (error, temp_error);\n      return FALSE;\n    }\n\n  return TRUE;\n}\n\nGPtrArray *\nflatpak_dir_list_refs_for_name (FlatpakDir   *self,\n                                FlatpakKinds kinds,\n                                const char   *name,\n                                GCancellable *cancellable,\n                                GError      **error)\n{\n  g_autoptr(GPtrArray) refs = NULL;\n\n  refs = g_ptr_array_new_with_free_func ((GDestroyNotify)flatpak_decomposed_unref);\n\n  if ((kinds & FLATPAK_KINDS_APP) != 0)\n    {\n      g_autoptr(GFile) base = g_file_get_child (flatpak_dir_get_path (self), \"app\");\n\n      if (!_flatpak_dir_list_refs_for_name (self, base, FLATPAK_KINDS_APP, name, refs, cancellable, error))\n        return NULL;\n    }\n\n  if ((kinds & FLATPAK_KINDS_RUNTIME) != 0)\n    {\n      g_autoptr(GFile) base = g_file_get_child (flatpak_dir_get_path (self), \"runtime\");\n\n      if (!_flatpak_dir_list_refs_for_name (self, base, FLATPAK_KINDS_RUNTIME, name, refs, cancellable, error))\n        return NULL;\n    }\n\n  g_ptr_array_sort (refs, (GCompareFunc)flatpak_decomposed_strcmp_p);\n\n  return g_steal_pointer (&refs);\n}\n\nGPtrArray *\nflatpak_dir_list_refs (FlatpakDir   *self,\n                       FlatpakKinds kinds,\n                       GCancellable *cancellable,\n                       GError      **error)\n{\n  g_autoptr(GPtrArray) refs = NULL;\n\n  refs = g_ptr_array_new_with_free_func ((GDestroyNotify)flatpak_decomposed_unref);\n\n  if (kinds & FLATPAK_KINDS_APP)\n    {\n      g_autoptr(GFile) base = NULL;\n      g_autoptr(GFileEnumerator) dir_enum = NULL;\n      g_autoptr(GFileInfo) child_info = NULL;\n      GError *temp_error = NULL;\n\n      base = g_file_get_child (flatpak_dir_get_path (self), \"app\");\n\n      if (g_file_query_exists (base, cancellable))\n        {\n          dir_enum = g_file_enumerate_children (base, OSTREE_GIO_FAST_QUERYINFO,\n                                                G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n                                                cancellable, error);\n          if (!dir_enum)\n            return NULL;\n\n          while ((child_info = g_file_enumerator_next_file (dir_enum, cancellable, &temp_error)))\n            {\n              const char *name = g_file_info_get_name (child_info);\n\n              if (g_file_info_get_file_type (child_info) != G_FILE_TYPE_DIRECTORY)\n                {\n                  g_clear_object (&child_info);\n                  continue;\n                }\n\n              if (!_flatpak_dir_list_refs_for_name (self, base, FLATPAK_KINDS_APP, name, refs, cancellable, error))\n                return NULL;\n\n              g_clear_object (&child_info);\n            }\n\n          if (temp_error != NULL)\n            {\n              g_propagate_error (error, temp_error);\n              return NULL;\n            }\n        }\n    }\n\n  if (kinds & FLATPAK_KINDS_RUNTIME)\n    {\n      g_autoptr(GFile) base = NULL;\n      g_autoptr(GFileEnumerator) dir_enum = NULL;\n      g_autoptr(GFileInfo) child_info = NULL;\n      GError *temp_error = NULL;\n\n      base = g_file_get_child (flatpak_dir_get_path (self), \"runtime\");\n\n      if (g_file_query_exists (base, cancellable))\n        {\n          dir_enum = g_file_enumerate_children (base, OSTREE_GIO_FAST_QUERYINFO,\n                                                G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n                                                cancellable, error);\n          if (!dir_enum)\n            return NULL;\n\n          while ((child_info = g_file_enumerator_next_file (dir_enum, cancellable, &temp_error)))\n            {\n              const char *name = g_file_info_get_name (child_info);\n\n              if (g_file_info_get_file_type (child_info) != G_FILE_TYPE_DIRECTORY)\n                {\n                  g_clear_object (&child_info);\n                  continue;\n                }\n\n              if (!_flatpak_dir_list_refs_for_name (self, base, FLATPAK_KINDS_RUNTIME, name, refs, cancellable, error))\n                return NULL;\n\n              g_clear_object (&child_info);\n            }\n\n          if (temp_error != NULL)\n            {\n              g_propagate_error (error, temp_error);\n              return NULL;\n            }\n        }\n    }\n\n  g_ptr_array_sort (refs, (GCompareFunc)flatpak_decomposed_strcmp_p);\n\n  return g_steal_pointer (&refs);\n}\n\nGPtrArray *\nflatpak_dir_list_app_refs_with_runtime (FlatpakDir        *self,\n                                        FlatpakDecomposed *runtime_ref,\n                                        GCancellable      *cancellable,\n                                        GError           **error)\n{\n  g_autoptr(GPtrArray) app_refs = NULL;\n  const char *runtime_pref = flatpak_decomposed_get_pref (runtime_ref);\n  g_autoptr(GPtrArray) apps = g_ptr_array_new_with_free_func ((GDestroyNotify)flatpak_decomposed_unref);\n\n  app_refs = flatpak_dir_list_refs (self, FLATPAK_KINDS_APP, NULL, NULL);\n  for (int i = 0; app_refs != NULL && i < app_refs->len; i++)\n    {\n      FlatpakDecomposed *app_ref = g_ptr_array_index (app_refs, i);\n      /* deploy v4 guarantees runtime info */\n      g_autoptr(GBytes) app_deploy_data = flatpak_dir_get_deploy_data (self, app_ref, 4, NULL, NULL);\n\n      if (app_deploy_data)\n        {\n          const char *app_runtime = flatpak_deploy_data_get_runtime (app_deploy_data);\n          if (g_strcmp0 (app_runtime, runtime_pref) == 0)\n            g_ptr_array_add (apps, flatpak_decomposed_ref (app_ref));\n        }\n    }\n\n  return g_steal_pointer (&apps);\n}\n\nGVariant *\nflatpak_dir_read_latest_commit (FlatpakDir        *self,\n                                const char        *remote,\n                                FlatpakDecomposed *ref,\n                                char             **out_checksum,\n                                GCancellable      *cancellable,\n                                GError           **error)\n{\n  g_autofree char *res = NULL;\n  g_autoptr(GVariant) commit_data = NULL;\n\n  if (!flatpak_repo_resolve_rev (self->repo, NULL, remote, flatpak_decomposed_get_ref (ref), FALSE,\n                                 &res, cancellable, error))\n    return NULL;\n\n  if (!ostree_repo_load_commit (self->repo, res, &commit_data, NULL, error))\n    return NULL;\n\n  if (out_checksum)\n    *out_checksum = g_steal_pointer (&res);\n\n  return g_steal_pointer (&commit_data);\n}\n\n\nchar *\nflatpak_dir_read_latest (FlatpakDir   *self,\n                         const char   *remote,\n                         const char   *ref,\n                         char        **out_alt_id,\n                         GCancellable *cancellable,\n                         GError      **error)\n{\n  g_autofree char *alt_id = NULL;\n  g_autofree char *res = NULL;\n\n  if (!flatpak_repo_resolve_rev (self->repo, NULL, remote, ref, FALSE,\n                                 &res, cancellable, error))\n    return NULL;\n\n  if (out_alt_id)\n    {\n      g_autoptr(GVariant) commit_data = NULL;\n      g_autoptr(GVariant) commit_metadata = NULL;\n\n      if (!ostree_repo_load_commit (self->repo, res, &commit_data, NULL, error))\n        return NULL;\n\n      commit_metadata = g_variant_get_child_value (commit_data, 0);\n      g_variant_lookup (commit_metadata, \"xa.alt-id\", \"s\", &alt_id);\n\n      *out_alt_id = g_steal_pointer (&alt_id);\n    }\n\n  return g_steal_pointer (&res);\n}\n\nchar *\nflatpak_dir_read_active (FlatpakDir        *self,\n                         FlatpakDecomposed *ref,\n                         GCancellable      *cancellable)\n{\n  g_autoptr(GFile) deploy_base = NULL;\n  g_autoptr(GFile) active_link = NULL;\n  g_autoptr(GFileInfo) file_info = NULL;\n\n  deploy_base = flatpak_dir_get_deploy_dir (self, ref);\n  active_link = g_file_get_child (deploy_base, \"active\");\n\n  file_info = g_file_query_info (active_link, OSTREE_GIO_FAST_QUERYINFO,\n                                 G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n                                 cancellable, NULL);\n  if (file_info == NULL)\n    return NULL;\n\n  return g_strdup (g_file_info_get_symlink_target (file_info));\n}\n\ngboolean\nflatpak_dir_set_active (FlatpakDir        *self,\n                        FlatpakDecomposed *ref,\n                        const char        *active_id,\n                        GCancellable      *cancellable,\n                        GError           **error)\n{\n  gboolean ret = FALSE;\n  g_autoptr(GFile) deploy_base = NULL;\n  g_autoptr(GFile) active_tmp_link = NULL;\n  g_autoptr(GFile) active_link = NULL;\n  g_autoptr(GError) my_error = NULL;\n  g_autofree char *tmpname = g_strdup (\".active-XXXXXX\");\n\n  deploy_base = flatpak_dir_get_deploy_dir (self, ref);\n  active_link = g_file_get_child (deploy_base, \"active\");\n\n  if (active_id != NULL)\n    {\n      glnx_gen_temp_name (tmpname);\n      active_tmp_link = g_file_get_child (deploy_base, tmpname);\n      if (!g_file_make_symbolic_link (active_tmp_link, active_id, cancellable, error))\n        goto out;\n\n      if (!flatpak_file_rename (active_tmp_link,\n                                active_link,\n                                cancellable, error))\n        goto out;\n    }\n  else\n    {\n      if (!g_file_delete (active_link, cancellable, &my_error) &&\n          !g_error_matches (my_error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND))\n        {\n          g_propagate_error (error, my_error);\n          my_error = NULL;\n          goto out;\n        }\n    }\n\n  ret = TRUE;\nout:\n  return ret;\n}\n\ngboolean\nflatpak_dir_run_triggers (FlatpakDir   *self,\n                          GCancellable *cancellable,\n                          GError      **error)\n{\n  gboolean ret = FALSE;\n  g_autoptr(GFileEnumerator) dir_enum = NULL;\n  g_autoptr(GFileInfo) child_info = NULL;\n  g_autoptr(GFile) triggersdir = NULL;\n  GError *temp_error = NULL;\n  const char *triggerspath;\n\n  if (flatpak_dir_use_system_helper (self, NULL))\n    {\n      const char *installation = flatpak_dir_get_id (self);\n\n      if (!flatpak_dir_system_helper_call_run_triggers (self,\n                                                        FLATPAK_HELPER_RUN_TRIGGERS_FLAGS_NONE,\n                                                        installation ? installation : \"\",\n                                                        cancellable,\n                                                        error))\n        return FALSE;\n\n      return TRUE;\n    }\n\n  triggerspath = g_getenv (\"FLATPAK_TRIGGERSDIR\");\n  if (triggerspath == NULL)\n    triggerspath = FLATPAK_TRIGGERDIR;\n\n  g_debug (\"running triggers from %s\", triggerspath);\n\n  triggersdir = g_file_new_for_path (triggerspath);\n\n  dir_enum = g_file_enumerate_children (triggersdir, \"standard::type,standard::name\",\n                                        0, cancellable, error);\n  if (!dir_enum)\n    goto out;\n\n  while ((child_info = g_file_enumerator_next_file (dir_enum, cancellable, &temp_error)) != NULL)\n    {\n      g_autoptr(GFile) child = NULL;\n      const char *name;\n      GError *trigger_error = NULL;\n\n      name = g_file_info_get_name (child_info);\n\n      child = g_file_get_child (triggersdir, name);\n\n      if (g_file_info_get_file_type (child_info) == G_FILE_TYPE_REGULAR &&\n          g_str_has_suffix (name, \".trigger\"))\n        {\n          g_autoptr(GPtrArray) argv_array = NULL;\n          /* We need to canonicalize the basedir, because if has a symlink\n             somewhere the bind mount will be on the target of that, not\n             at that exact path. */\n          g_autofree char *basedir_orig = g_file_get_path (self->basedir);\n          g_autofree char *basedir = realpath (basedir_orig, NULL);\n          g_autoptr(FlatpakBwrap) bwrap = NULL;\n          g_autofree char *commandline = NULL;\n\n          g_debug (\"running trigger %s\", name);\n\n          bwrap = flatpak_bwrap_new (NULL);\n\n          argv_array = g_ptr_array_new_with_free_func (g_free);\n#ifndef DISABLE_SANDBOXED_TRIGGERS\n          flatpak_bwrap_add_arg (bwrap, flatpak_get_bwrap ());\n          flatpak_bwrap_add_args (bwrap,\n                                  \"--unshare-ipc\",\n                                  \"--unshare-net\",\n                                  \"--unshare-pid\",\n                                  \"--ro-bind\", \"/\", \"/\",\n                                  \"--proc\", \"/proc\",\n                                  \"--dev\", \"/dev\",\n                                  \"--bind\", basedir, basedir,\n                                  NULL);\n#endif\n          flatpak_bwrap_add_args (bwrap,\n                                  flatpak_file_get_path_cached (child),\n                                  basedir,\n                                  NULL);\n          flatpak_bwrap_finish (bwrap);\n\n          commandline = flatpak_quote_argv ((const char **) bwrap->argv->pdata, -1);\n          g_debug (\"Running '%s'\", commandline);\n\n          /* We use LEAVE_DESCRIPTORS_OPEN to work around dead-lock, see flatpak_close_fds_workaround */\n          if (!g_spawn_sync (\"/\",\n                             (char **) bwrap->argv->pdata,\n                             NULL,\n                             G_SPAWN_SEARCH_PATH | G_SPAWN_LEAVE_DESCRIPTORS_OPEN,\n                             flatpak_bwrap_child_setup_cb, bwrap->fds,\n                             NULL, NULL,\n                             NULL, &trigger_error))\n            {\n              g_warning (\"Error running trigger %s: %s\", name, trigger_error->message);\n              g_clear_error (&trigger_error);\n            }\n        }\n\n      g_clear_object (&child_info);\n    }\n\n  if (temp_error != NULL)\n    {\n      g_propagate_error (error, temp_error);\n      goto out;\n    }\n\n  ret = TRUE;\nout:\n  return ret;\n}\n\nstatic gboolean\nread_fd (int          fd,\n         struct stat *stat_buf,\n         gchar      **contents,\n         gsize       *length,\n         GError     **error)\n{\n  gchar *buf;\n  gsize bytes_read;\n  gsize size;\n  gsize alloc_size;\n\n  size = stat_buf->st_size;\n\n  alloc_size = size + 1;\n  buf = g_try_malloc (alloc_size);\n\n  if (buf == NULL)\n    {\n      g_set_error_literal (error, G_FILE_ERROR, G_FILE_ERROR_NOMEM,\n                           _(\"Not enough memory\"));\n      return FALSE;\n    }\n\n  bytes_read = 0;\n  while (bytes_read < size)\n    {\n      gssize rc;\n\n      rc = read (fd, buf + bytes_read, size - bytes_read);\n\n      if (rc < 0)\n        {\n          if (errno != EINTR)\n            {\n              int save_errno = errno;\n\n              g_free (buf);\n              g_set_error_literal (error, G_FILE_ERROR, g_file_error_from_errno (save_errno),\n                                   _(\"Failed to read from exported file\"));\n              return FALSE;\n            }\n        }\n      else if (rc == 0)\n        {\n          break;\n        }\n      else\n        {\n          bytes_read += rc;\n        }\n    }\n\n  buf[bytes_read] = '\\0';\n\n  if (length)\n    *length = bytes_read;\n\n  *contents = buf;\n\n  return TRUE;\n}\n\n/* This is conservative, but lets us avoid escaping most\n   regular Exec= lines, which is nice as that can sometimes\n   cause problems for apps launching desktop files. */\nstatic gboolean\nneed_quotes (const char *str)\n{\n  const char *p;\n\n  for (p = str; *p; p++)\n    {\n      if (!g_ascii_isalnum (*p) &&\n          strchr (\"-_%.=:/@\", *p) == NULL)\n        return TRUE;\n    }\n\n  return FALSE;\n}\n\nstatic char *\nmaybe_quote (const char *str)\n{\n  if (need_quotes (str))\n    return g_shell_quote (str);\n  return g_strdup (str);\n}\n\ntypedef enum {\n  INI_FILE_TYPE_SEARCH_PROVIDER = 1,\n} ExportedIniFileType;\n\nstatic gboolean\nexport_ini_file (int                 parent_fd,\n                 const char         *name,\n                 ExportedIniFileType ini_type,\n                 struct stat        *stat_buf,\n                 char              **target,\n                 GCancellable       *cancellable,\n                 GError            **error)\n{\n  glnx_autofd int desktop_fd = -1;\n  g_autofree char *tmpfile_name = g_strdup_printf (\"export-ini-XXXXXX\");\n  g_autoptr(GOutputStream) out_stream = NULL;\n  g_autofree gchar *data = NULL;\n  gsize data_len;\n  g_autofree gchar *new_data = NULL;\n  gsize new_data_len;\n  g_autoptr(GKeyFile) keyfile = NULL;\n\n  if (!flatpak_openat_noatime (parent_fd, name, &desktop_fd, cancellable, error) ||\n      !read_fd (desktop_fd, stat_buf, &data, &data_len, error))\n    return FALSE;\n\n  keyfile = g_key_file_new ();\n  if (!g_key_file_load_from_data (keyfile, data, data_len, G_KEY_FILE_KEEP_TRANSLATIONS, error))\n    return FALSE;\n\n  if (ini_type == INI_FILE_TYPE_SEARCH_PROVIDER)\n    g_key_file_set_boolean (keyfile, \"Shell Search Provider\", \"DefaultDisabled\", TRUE);\n\n  new_data = g_key_file_to_data (keyfile, &new_data_len, error);\n  if (new_data == NULL)\n    return FALSE;\n\n  if (!flatpak_open_in_tmpdir_at (parent_fd, 0755, tmpfile_name, &out_stream, cancellable, error) ||\n      !g_output_stream_write_all (out_stream, new_data, new_data_len, NULL, cancellable, error) ||\n      !g_output_stream_close (out_stream, cancellable, error))\n    return FALSE;\n\n  if (target)\n    *target = g_steal_pointer (&tmpfile_name);\n\n  return TRUE;\n}\n\nstatic inline void\nxml_autoptr_cleanup_generic_free (void *p)\n{\n  void **pp = (void **) p;\n\n  if (*pp)\n    xmlFree (*pp);\n}\n\n\n#define xml_autofree _GLIB_CLEANUP (xml_autoptr_cleanup_generic_free)\n\n/* This verifies the basic layout of the files, then it removes\n * any magic matches, and makes all glob matches have a very low\n * priority (weight = 5). This should make it pretty safe to\n * export mime types, because the should not override the system\n * ones in any weird ways. */\nstatic gboolean\nrewrite_mime_xml (xmlDoc *doc)\n{\n  xmlNode *root_element = xmlDocGetRootElement (doc);\n  xmlNode *top_node = NULL;\n\n  for (top_node = root_element; top_node; top_node = top_node->next)\n    {\n      xmlNode *mime_node = NULL;\n      if (top_node->type != XML_ELEMENT_NODE)\n        continue;\n\n      if (strcmp ((char *) top_node->name, \"mime-info\") != 0)\n        return FALSE;\n\n      for (mime_node = top_node->children; mime_node; mime_node = mime_node->next)\n        {\n          xmlNode *sub_node = NULL;\n          xmlNode *next_sub_node = NULL;\n\n          xml_autofree xmlChar *mimetype = NULL;\n          if (mime_node->type != XML_ELEMENT_NODE)\n            continue;\n\n          if (strcmp ((char *) mime_node->name, \"mime-type\") != 0)\n            return FALSE;\n\n          mimetype = xmlGetProp (mime_node, (xmlChar *) \"type\");\n          for (sub_node = mime_node->children; sub_node; sub_node = next_sub_node)\n            {\n              next_sub_node = sub_node->next;\n\n              if (sub_node->type != XML_ELEMENT_NODE)\n                continue;\n\n              if (strcmp ((char *) sub_node->name, \"magic\") == 0)\n                {\n                  g_warning (\"Removing magic mime rule from exports\");\n                  xmlUnlinkNode (sub_node);\n                  xmlFreeNode (sub_node);\n                }\n              else if (strcmp ((char *) sub_node->name, \"glob\") == 0)\n                {\n                  xmlSetProp (sub_node,\n                              (const xmlChar *) \"weight\",\n                              (const xmlChar *) \"5\");\n                }\n            }\n        }\n    }\n\n  return TRUE;\n}\n\nstatic gboolean\nexport_mime_file (int           parent_fd,\n                  const char   *name,\n                  struct stat  *stat_buf,\n                  char        **target,\n                  GCancellable *cancellable,\n                  GError      **error)\n{\n  glnx_autofd int desktop_fd = -1;\n  g_autofree char *tmpfile_name = g_strdup_printf (\"export-mime-XXXXXX\");\n  g_autoptr(GOutputStream) out_stream = NULL;\n  g_autofree gchar *data = NULL;\n  gsize data_len;\n  xmlDoc *doc = NULL;\n  xml_autofree xmlChar *xmlbuff = NULL;\n  int buffersize;\n\n  if (!flatpak_openat_noatime (parent_fd, name, &desktop_fd, cancellable, error) ||\n      !read_fd (desktop_fd, stat_buf, &data, &data_len, error))\n    return FALSE;\n\n  doc = xmlReadMemory (data, data_len, NULL, NULL,  0);\n  if (doc == NULL)\n    return flatpak_fail_error (error, FLATPAK_ERROR_EXPORT_FAILED, _(\"Error reading mimetype xml file\"));\n\n  if (!rewrite_mime_xml (doc))\n    {\n      xmlFreeDoc (doc);\n      return flatpak_fail_error (error, FLATPAK_ERROR_EXPORT_FAILED, _(\"Invalid mimetype xml file\"));\n    }\n\n  xmlDocDumpFormatMemory (doc, &xmlbuff, &buffersize, 1);\n  xmlFreeDoc (doc);\n\n  if (!flatpak_open_in_tmpdir_at (parent_fd, 0755, tmpfile_name, &out_stream, cancellable, error) ||\n      !g_output_stream_write_all (out_stream, xmlbuff, buffersize, NULL, cancellable, error) ||\n      !g_output_stream_close (out_stream, cancellable, error))\n    return FALSE;\n\n  if (target)\n    *target = g_steal_pointer (&tmpfile_name);\n\n  return TRUE;\n}\n\nstatic char *\nformat_flatpak_run_args_from_run_opts (GStrv flatpak_run_args)\n{\n  GString *str;\n  GStrv iter = flatpak_run_args;\n\n  if (flatpak_run_args == NULL)\n    return NULL;\n\n  str = g_string_new (\"\");\n  for (; *iter != NULL; ++iter)\n    {\n      if (g_strcmp0 (*iter, \"no-a11y-bus\") == 0)\n        g_string_append_printf (str, \" --no-a11y-bus\");\n      else if (g_strcmp0 (*iter, \"no-documents-portal\") == 0)\n        g_string_append_printf (str, \" --no-documents-portal\");\n    }\n\n  return g_string_free (str, FALSE);\n}\n\nstatic gboolean\nexport_desktop_file (const char         *app,\n                     const char         *branch,\n                     const char         *arch,\n                     GKeyFile           *metadata,\n                     const char * const *previous_ids,\n                     int                 parent_fd,\n                     const char         *name,\n                     struct stat        *stat_buf,\n                     char              **target,\n                     GCancellable       *cancellable,\n                     GError            **error)\n{\n  gboolean ret = FALSE;\n  glnx_autofd int desktop_fd = -1;\n  g_autofree char *tmpfile_name = g_strdup_printf (\"export-desktop-XXXXXX\");\n  g_autoptr(GOutputStream) out_stream = NULL;\n  g_autofree gchar *data = NULL;\n  gsize data_len;\n  g_autofree gchar *new_data = NULL;\n  gsize new_data_len;\n  g_autoptr(GKeyFile) keyfile = NULL;\n  g_autofree gchar *old_exec = NULL;\n  gint old_argc;\n  g_auto(GStrv) old_argv = NULL;\n  g_auto(GStrv) groups = NULL;\n  GString *new_exec = NULL;\n  g_autofree char *escaped_app = maybe_quote (app);\n  g_autofree char *escaped_branch = maybe_quote (branch);\n  g_autofree char *escaped_arch = maybe_quote (arch);\n  int i;\n\n  if (!flatpak_openat_noatime (parent_fd, name, &desktop_fd, cancellable, error))\n    goto out;\n\n  if (!read_fd (desktop_fd, stat_buf, &data, &data_len, error))\n    goto out;\n\n  keyfile = g_key_file_new ();\n  if (!g_key_file_load_from_data (keyfile, data, data_len, G_KEY_FILE_KEEP_TRANSLATIONS, error))\n    goto out;\n\n  if (g_str_has_suffix (name, \".service\"))\n    {\n      g_autofree gchar *dbus_name = NULL;\n      g_autofree gchar *expected_dbus_name = g_strndup (name, strlen (name) - strlen (\".service\"));\n\n      dbus_name = g_key_file_get_string (keyfile, \"D-BUS Service\", \"Name\", NULL);\n\n      if (dbus_name == NULL || strcmp (dbus_name, expected_dbus_name) != 0)\n        {\n          return flatpak_fail_error (error, FLATPAK_ERROR_EXPORT_FAILED,\n                                     _(\"D-Bus service file '%s' has wrong name\"), name);\n        }\n    }\n\n  if (g_str_has_suffix (name, \".desktop\"))\n    {\n      gsize length;\n      g_auto(GStrv) tags = g_key_file_get_string_list (metadata,\n                                                       \"Application\",\n                                                       \"tags\", &length,\n                                                       NULL);\n\n      if (tags != NULL)\n        {\n          g_key_file_set_string_list (keyfile,\n                                      G_KEY_FILE_DESKTOP_GROUP,\n                                      \"X-Flatpak-Tags\",\n                                      (const char * const *) tags, length);\n        }\n\n      /* Add a marker so consumers can easily find out that this launches a sandbox */\n      g_key_file_set_string (keyfile, G_KEY_FILE_DESKTOP_GROUP, \"X-Flatpak\", app);\n\n      /* If the app has been renamed, add its old .desktop filename to\n       * X-Flatpak-RenamedFrom in the new .desktop file, taking care not to\n       * introduce duplicates.\n       */\n      if (previous_ids != NULL)\n        {\n          const char *X_FLATPAK_RENAMED_FROM = \"X-Flatpak-RenamedFrom\";\n          g_auto(GStrv) renamed_from = g_key_file_get_string_list (keyfile,\n                                                                   G_KEY_FILE_DESKTOP_GROUP,\n                                                                   X_FLATPAK_RENAMED_FROM,\n                                                                   NULL, NULL);\n          g_autoptr(GPtrArray) merged = g_ptr_array_new_with_free_func (g_free);\n          g_autoptr(GHashTable) seen = g_hash_table_new (g_str_hash, g_str_equal);\n          const char *new_suffix;\n\n          for (i = 0; renamed_from != NULL && renamed_from[i] != NULL; i++)\n            {\n              if (!g_hash_table_contains (seen, renamed_from[i]))\n                {\n                  gchar *copy = g_strdup (renamed_from[i]);\n                  g_hash_table_insert (seen, copy, copy);\n                  g_ptr_array_add (merged, g_steal_pointer (&copy));\n                }\n            }\n\n          /* If an app was renamed from com.example.Foo to net.example.Bar, and\n           * the new version exports net.example.Bar-suffix.desktop, we assume the\n           * old version exported com.example.Foo-suffix.desktop.\n           *\n           * This assertion is true because\n           * flatpak_name_matches_one_wildcard_prefix() is called on all\n           * exported files before we get here.\n           */\n          g_assert (g_str_has_prefix (name, app));\n          /* \".desktop\" for the \"main\" desktop file; something like\n           * \"-suffix.desktop\" for extra ones.\n           */\n          new_suffix = name + strlen (app);\n\n          for (i = 0; previous_ids[i] != NULL; i++)\n            {\n              g_autofree gchar *previous_desktop = g_strconcat (previous_ids[i], new_suffix, NULL);\n              if (!g_hash_table_contains (seen, previous_desktop))\n                {\n                  g_hash_table_insert (seen, previous_desktop, previous_desktop);\n                  g_ptr_array_add (merged, g_steal_pointer (&previous_desktop));\n                }\n            }\n\n          if (merged->len > 0)\n            {\n              g_ptr_array_add (merged, NULL);\n              g_key_file_set_string_list (keyfile,\n                                          G_KEY_FILE_DESKTOP_GROUP,\n                                          X_FLATPAK_RENAMED_FROM,\n                                          (const char * const *) merged->pdata,\n                                          merged->len - 1);\n            }\n        }\n    }\n\n  groups = g_key_file_get_groups (keyfile, NULL);\n\n  for (i = 0; groups[i] != NULL; i++)\n    {\n      g_auto(GStrv) flatpak_run_opts = g_key_file_get_string_list (keyfile, groups[i], \"X-Flatpak-RunOptions\", NULL, NULL);\n      g_autofree char *flatpak_run_args = format_flatpak_run_args_from_run_opts (flatpak_run_opts);\n\n      g_key_file_remove_key (keyfile, groups[i], \"X-Flatpak-RunOptions\", NULL);\n      g_key_file_remove_key (keyfile, groups[i], \"TryExec\", NULL);\n\n      /* Remove this to make sure nothing tries to execute it outside the sandbox*/\n      g_key_file_remove_key (keyfile, groups[i], \"X-GNOME-Bugzilla-ExtraInfoScript\", NULL);\n\n      new_exec = g_string_new (\"\");\n      g_string_append_printf (new_exec,\n                              FLATPAK_BINDIR \"/flatpak run --branch=%s --arch=%s\",\n                              escaped_branch,\n                              escaped_arch);\n\n      if (flatpak_run_args != NULL)\n        g_string_append_printf (new_exec, \"%s\", flatpak_run_args);\n\n      old_exec = g_key_file_get_string (keyfile, groups[i], \"Exec\", NULL);\n      if (old_exec && g_shell_parse_argv (old_exec, &old_argc, &old_argv, NULL) && old_argc >= 1)\n        {\n          int j;\n          g_autofree char *command = maybe_quote (old_argv[0]);\n\n          g_string_append_printf (new_exec, \" --command=%s\", command);\n\n          for (j = 1; j < old_argc; j++)\n            {\n              if (strcasecmp (old_argv[j], \"%f\") == 0 ||\n                  strcasecmp (old_argv[j], \"%u\") == 0)\n                {\n                  g_string_append (new_exec, \" --file-forwarding\");\n                  break;\n                }\n            }\n\n          g_string_append (new_exec, \" \");\n          g_string_append (new_exec, escaped_app);\n\n          for (j = 1; j < old_argc; j++)\n            {\n              g_autofree char *arg = maybe_quote (old_argv[j]);\n\n              if (strcasecmp (arg, \"%f\") == 0)\n                g_string_append_printf (new_exec, \" @@ %s @@\", arg);\n              else if (strcasecmp (arg, \"%u\") == 0)\n                g_string_append_printf (new_exec, \" @@u %s @@\", arg);\n              else\n                g_string_append_printf (new_exec, \" %s\", arg);\n            }\n        }\n      else\n        {\n          g_string_append (new_exec, \" \");\n          g_string_append (new_exec, escaped_app);\n        }\n\n      g_key_file_set_string (keyfile, groups[i], G_KEY_FILE_DESKTOP_KEY_EXEC, new_exec->str);\n    }\n\n  new_data = g_key_file_to_data (keyfile, &new_data_len, error);\n  if (new_data == NULL)\n    goto out;\n\n  if (!flatpak_open_in_tmpdir_at (parent_fd, 0755, tmpfile_name, &out_stream, cancellable, error))\n    goto out;\n\n  if (!g_output_stream_write_all (out_stream, new_data, new_data_len, NULL, cancellable, error))\n    goto out;\n\n  if (!g_output_stream_close (out_stream, cancellable, error))\n    goto out;\n\n  if (target)\n    *target = g_steal_pointer (&tmpfile_name);\n\n  ret = TRUE;\nout:\n\n  if (new_exec != NULL)\n    g_string_free (new_exec, TRUE);\n\n  return ret;\n}\n\nstatic gboolean\nrewrite_export_dir (const char         *app,\n                    const char         *branch,\n                    const char         *arch,\n                    GKeyFile           *metadata,\n                    const char * const *previous_ids,\n                    FlatpakContext     *context,\n                    int                 source_parent_fd,\n                    const char         *source_name,\n                    const char         *source_path,\n                    GCancellable       *cancellable,\n                    GError            **error)\n{\n  gboolean ret = FALSE;\n  g_auto(GLnxDirFdIterator) source_iter = {0};\n  g_autoptr(GHashTable) visited_children = NULL;\n  struct dirent *dent;\n  gboolean exports_allowed = FALSE;\n  g_auto(GStrv) allowed_prefixes = NULL;\n  g_auto(GStrv) allowed_extensions = NULL;\n  gboolean require_exact_match = FALSE;\n\n  if (!glnx_dirfd_iterator_init_at (source_parent_fd, source_name, FALSE, &source_iter, error))\n    goto out;\n\n  exports_allowed = flatpak_get_allowed_exports (source_path, app, context,\n                                                 &allowed_extensions, &allowed_prefixes, &require_exact_match);\n\n  visited_children = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, NULL);\n\n  while (TRUE)\n    {\n      struct stat stbuf;\n\n      if (!glnx_dirfd_iterator_next_dent (&source_iter, &dent, cancellable, error))\n        goto out;\n\n      if (dent == NULL)\n        break;\n\n      if (g_hash_table_contains (visited_children, dent->d_name))\n        continue;\n\n      /* Avoid processing the same file again if it was re-created during an export */\n      g_hash_table_insert (visited_children, g_strdup (dent->d_name), GINT_TO_POINTER (1));\n\n      if (fstatat (source_iter.fd, dent->d_name, &stbuf, AT_SYMLINK_NOFOLLOW) == -1)\n        {\n          if (errno == ENOENT)\n            {\n              continue;\n            }\n          else\n            {\n              glnx_set_error_from_errno (error);\n              goto out;\n            }\n        }\n\n      if (S_ISDIR (stbuf.st_mode))\n        {\n          g_autofree char *path = g_build_filename (source_path, dent->d_name, NULL);\n\n          if (!rewrite_export_dir (app, branch, arch, metadata, previous_ids, context,\n                                   source_iter.fd, dent->d_name,\n                                   path, cancellable, error))\n            goto out;\n        }\n      else if (S_ISREG (stbuf.st_mode) && exports_allowed)\n        {\n          g_autofree gchar *name_without_extension = NULL;\n          g_autofree gchar *new_name = NULL;\n          int i;\n\n          for (i = 0; allowed_extensions[i] != NULL; i++)\n            {\n              if (g_str_has_suffix (dent->d_name, allowed_extensions[i]))\n                break;\n            }\n\n          if (allowed_extensions[i] == NULL)\n            {\n              g_warning (\"Invalid extension for %s in app %s, removing.\", dent->d_name, app);\n              if (unlinkat (source_iter.fd, dent->d_name, 0) != 0 && errno != ENOENT)\n                {\n                  glnx_set_error_from_errno (error);\n                  goto out;\n                }\n              continue;\n            }\n\n          name_without_extension = g_strndup (dent->d_name, strlen (dent->d_name) - strlen (allowed_extensions[i]));\n\n          if (!flatpak_name_matches_one_wildcard_prefix (name_without_extension, (const char * const *) allowed_prefixes, require_exact_match))\n            {\n              g_warning (\"Non-prefixed filename %s in app %s, removing.\", dent->d_name, app);\n              if (unlinkat (source_iter.fd, dent->d_name, 0) != 0 && errno != ENOENT)\n                {\n                  glnx_set_error_from_errno (error);\n                  goto out;\n                }\n            }\n\n          if (g_str_has_suffix (dent->d_name, \".desktop\") ||\n              g_str_has_suffix (dent->d_name, \".service\"))\n            {\n              if (!export_desktop_file (app, branch, arch, metadata, previous_ids,\n                                        source_iter.fd, dent->d_name, &stbuf, &new_name, cancellable, error))\n                goto out;\n            }\n\n          if (strcmp (source_name, \"search-providers\") == 0 &&\n              g_str_has_suffix (dent->d_name, \".ini\"))\n            {\n              if (!export_ini_file (source_iter.fd, dent->d_name, INI_FILE_TYPE_SEARCH_PROVIDER,\n                                    &stbuf, &new_name, cancellable, error))\n                goto out;\n            }\n\n          if (strcmp (source_name, \"packages\") == 0 &&\n              g_str_has_suffix (dent->d_name, \".xml\"))\n            {\n              if (!export_mime_file (source_iter.fd, dent->d_name,\n                                     &stbuf, &new_name, cancellable, error))\n                goto out;\n            }\n\n          if (new_name)\n            {\n              g_hash_table_insert (visited_children, g_strdup (new_name), GINT_TO_POINTER (1));\n\n              if (renameat (source_iter.fd, new_name, source_iter.fd, dent->d_name) != 0)\n                {\n                  glnx_set_error_from_errno (error);\n                  goto out;\n                }\n            }\n        }\n      else\n        {\n          g_warning (\"Not exporting file %s of unsupported type.\", dent->d_name);\n          if (unlinkat (source_iter.fd, dent->d_name, 0) != 0 && errno != ENOENT)\n            {\n              glnx_set_error_from_errno (error);\n              goto out;\n            }\n        }\n    }\n\n  ret = TRUE;\nout:\n\n  return ret;\n}\n\nstatic gboolean\nflatpak_rewrite_export_dir (const char         *app,\n                            const char         *branch,\n                            const char         *arch,\n                            GKeyFile           *metadata,\n                            const char * const *previous_ids,\n                            GFile              *source,\n                            GCancellable       *cancellable,\n                            GError            **error)\n{\n  gboolean ret = FALSE;\n  g_autoptr(GFile) parent = g_file_get_parent (source);\n  glnx_autofd int parentfd = -1;\n  g_autofree char *name = g_file_get_basename (source);\n\n  /* Start with a source path of \"\" - we don't care about\n   * the \"export\" component and we want to start path traversal\n   * relative to it. */\n  const char *source_path = \"\";\n  g_autoptr(FlatpakContext) context = flatpak_context_new ();\n\n  if (!flatpak_context_load_metadata (context, metadata, error))\n    return FALSE;\n\n  if (!glnx_opendirat (AT_FDCWD,\n                       flatpak_file_get_path_cached (parent),\n                       TRUE,\n                       &parentfd,\n                       error))\n    return FALSE;\n\n  /* The fds are closed by this call */\n  if (!rewrite_export_dir (app, branch, arch, metadata, previous_ids, context,\n                           parentfd, name, source_path,\n                           cancellable, error))\n    goto out;\n\n  ret = TRUE;\n\nout:\n  return ret;\n}\n\n\nstatic gboolean\nexport_dir (int           source_parent_fd,\n            const char   *source_name,\n            const char   *source_symlink_prefix,\n            const char   *source_relpath,\n            int           destination_parent_fd,\n            const char   *destination_name,\n            GCancellable *cancellable,\n            GError      **error)\n{\n  gboolean ret = FALSE;\n  int res;\n  g_auto(GLnxDirFdIterator) source_iter = {0};\n  glnx_autofd int destination_dfd = -1;\n  struct dirent *dent;\n\n  if (!glnx_dirfd_iterator_init_at (source_parent_fd, source_name, FALSE, &source_iter, error))\n    goto out;\n\n  do\n    res = mkdirat (destination_parent_fd, destination_name, 0755);\n  while (G_UNLIKELY (res == -1 && errno == EINTR));\n  if (res == -1)\n    {\n      if (errno != EEXIST)\n        {\n          glnx_set_error_from_errno (error);\n          goto out;\n        }\n    }\n\n  if (!glnx_opendirat (destination_parent_fd, destination_name, TRUE,\n                       &destination_dfd, error))\n    goto out;\n\n  while (TRUE)\n    {\n      struct stat stbuf;\n\n      if (!glnx_dirfd_iterator_next_dent (&source_iter, &dent, cancellable, error))\n        goto out;\n\n      if (dent == NULL)\n        break;\n\n      if (fstatat (source_iter.fd, dent->d_name, &stbuf, AT_SYMLINK_NOFOLLOW) == -1)\n        {\n          if (errno == ENOENT)\n            {\n              continue;\n            }\n          else\n            {\n              glnx_set_error_from_errno (error);\n              goto out;\n            }\n        }\n\n      if (S_ISDIR (stbuf.st_mode))\n        {\n          g_autofree gchar *child_symlink_prefix = g_build_filename (\"..\", source_symlink_prefix, dent->d_name, NULL);\n          g_autofree gchar *child_relpath = g_strconcat (source_relpath, dent->d_name, \"/\", NULL);\n\n          if (!export_dir (source_iter.fd, dent->d_name, child_symlink_prefix, child_relpath, destination_dfd, dent->d_name,\n                           cancellable, error))\n            goto out;\n        }\n      else if (S_ISREG (stbuf.st_mode))\n        {\n          g_autofree char *symlink_name = g_strdup (\".export-symlink-XXXXXX\");\n          g_autofree gchar *target = NULL;\n\n          target = g_build_filename (source_symlink_prefix, dent->d_name, NULL);\n\n          for (int count = 0; count < 100; count++)\n            {\n              glnx_gen_temp_name (symlink_name);\n\n              if (symlinkat (target, destination_dfd, symlink_name) != 0)\n                {\n                  if (errno == EEXIST)\n                    continue;\n\n                  glnx_set_error_from_errno (error);\n                  goto out;\n                }\n\n              if (renameat (destination_dfd, symlink_name, destination_dfd, dent->d_name) != 0)\n                {\n                  glnx_set_error_from_errno (error);\n                  goto out;\n                }\n\n              break;\n            }\n        }\n    }\n\n  ret = TRUE;\nout:\n\n  return ret;\n}\n\nstatic gboolean\nflatpak_export_dir (GFile        *source,\n                    GFile        *destination,\n                    const char   *symlink_prefix,\n                    GCancellable *cancellable,\n                    GError      **error)\n{\n  const char *exported_subdirs[] = {\n    \"share/applications\",                  \"../..\",\n    \"share/icons\",                         \"../..\",\n    \"share/dbus-1/services\",               \"../../..\",\n    \"share/gnome-shell/search-providers\",  \"../../..\",\n    \"share/mime/packages\",                 \"../../..\",\n    \"bin\",                                 \"..\",\n  };\n  int i;\n\n  for (i = 0; i < G_N_ELEMENTS (exported_subdirs); i = i + 2)\n    {\n      /* The fds are closed by this call */\n      g_autoptr(GFile) sub_source = g_file_resolve_relative_path (source, exported_subdirs[i]);\n      g_autoptr(GFile) sub_destination = g_file_resolve_relative_path (destination, exported_subdirs[i]);\n      g_autofree char *sub_symlink_prefix = g_build_filename (exported_subdirs[i + 1], symlink_prefix, exported_subdirs[i], NULL);\n\n      if (!g_file_query_exists (sub_source, cancellable))\n        continue;\n\n      if (!flatpak_mkdir_p (sub_destination, cancellable, error))\n        return FALSE;\n\n      if (!export_dir (AT_FDCWD, flatpak_file_get_path_cached (sub_source), sub_symlink_prefix, \"\",\n                       AT_FDCWD, flatpak_file_get_path_cached (sub_destination),\n                       cancellable, error))\n        return FALSE;\n    }\n\n  return TRUE;\n}\n\ngboolean\nflatpak_dir_update_exports (FlatpakDir   *self,\n                            const char   *changed_app,\n                            GCancellable *cancellable,\n                            GError      **error)\n{\n  gboolean ret = FALSE;\n  g_autoptr(GFile) exports = NULL;\n  g_autoptr(FlatpakDecomposed) current_ref = NULL;\n  g_autofree char *active_id = NULL;\n  g_autofree char *symlink_prefix = NULL;\n\n  exports = flatpak_dir_get_exports_dir (self);\n\n  if (!flatpak_mkdir_p (exports, cancellable, error))\n    goto out;\n\n  if (changed_app &&\n      (current_ref = flatpak_dir_current_ref (self, changed_app, cancellable)) &&\n      (active_id = flatpak_dir_read_active (self, current_ref, cancellable)))\n    {\n      g_autoptr(GFile) deploy_base = NULL;\n      g_autoptr(GFile) active = NULL;\n      g_autoptr(GFile) export = NULL;\n\n      deploy_base = flatpak_dir_get_deploy_dir (self, current_ref);\n      active = g_file_get_child (deploy_base, active_id);\n      export = g_file_get_child (active, \"export\");\n\n      if (g_file_query_exists (export, cancellable))\n        {\n          symlink_prefix = g_build_filename (\"..\", \"app\", changed_app, \"current\", \"active\", \"export\", NULL);\n          if (!flatpak_export_dir (export, exports,\n                                   symlink_prefix,\n                                   cancellable,\n                                   error))\n            goto out;\n        }\n    }\n\n  if (!flatpak_remove_dangling_symlinks (exports, cancellable, error))\n    goto out;\n\n  ret = TRUE;\n\nout:\n  return ret;\n}\n\nstatic gboolean\nextract_extra_data (FlatpakDir   *self,\n                    const char   *checksum,\n                    GFile        *extradir,\n                    gboolean     *created_extra_data,\n                    GCancellable *cancellable,\n                    GError      **error)\n{\n  g_autoptr(GVariant) detached_metadata = NULL;\n  g_autoptr(GVariant) extra_data = NULL;\n  g_autoptr(GVariant) extra_data_sources = NULL;\n  g_autoptr(GError) local_error = NULL;\n  gsize i, n_extra_data = 0;\n  gsize n_extra_data_sources;\n\n  extra_data_sources = flatpak_repo_get_extra_data_sources (self->repo, checksum,\n                                                            cancellable, &local_error);\n  if (extra_data_sources == NULL)\n    {\n      /* This should protect us against potential errors at the OSTree level\n         (e.g. ostree_repo_load_variant), so that we don't report success. */\n      if (!g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND))\n        {\n          g_propagate_error (error, g_steal_pointer (&local_error));\n          return FALSE;\n        }\n\n      return TRUE;\n    }\n\n  n_extra_data_sources = g_variant_n_children (extra_data_sources);\n  if (n_extra_data_sources == 0)\n    return TRUE;\n\n  g_debug (\"extracting extra data to %s\", flatpak_file_get_path_cached (extradir));\n\n  if (!ostree_repo_read_commit_detached_metadata (self->repo, checksum, &detached_metadata,\n                                                  cancellable, error))\n    {\n      g_prefix_error (error, _(\"While getting detached metadata: \"));\n      return FALSE;\n    }\n\n  if (detached_metadata == NULL)\n    return flatpak_fail_error (error, FLATPAK_ERROR_INVALID_DATA, _(\"Extra data missing in detached metadata\"));\n\n  extra_data = g_variant_lookup_value (detached_metadata, \"xa.extra-data\",\n                                       G_VARIANT_TYPE (\"a(ayay)\"));\n  if (extra_data == NULL)\n    return flatpak_fail_error (error, FLATPAK_ERROR_INVALID_DATA, _(\"Extra data missing in detached metadata\"));\n\n  n_extra_data = g_variant_n_children (extra_data);\n  if (n_extra_data < n_extra_data_sources)\n    return flatpak_fail_error (error, FLATPAK_ERROR_INVALID_DATA, _(\"Extra data missing in detached metadata\"));\n\n  if (!flatpak_mkdir_p (extradir, cancellable, error))\n    {\n      g_prefix_error (error, _(\"While creating extradir: \"));\n      return FALSE;\n    }\n\n  for (i = 0; i < n_extra_data_sources; i++)\n    {\n      g_autofree char *extra_data_sha256 = NULL;\n      const guchar *extra_data_sha256_bytes;\n      const char *extra_data_source_name = NULL;\n      guint64 download_size;\n      gboolean found;\n      int j;\n\n      flatpak_repo_parse_extra_data_sources (extra_data_sources, i,\n                                             &extra_data_source_name,\n                                             &download_size,\n                                             NULL,\n                                             &extra_data_sha256_bytes,\n                                             NULL);\n\n      if (extra_data_sha256_bytes == NULL)\n        return flatpak_fail_error (error, FLATPAK_ERROR_INVALID_DATA, _(\"Invalid checksum for extra data\"));\n\n      extra_data_sha256 = ostree_checksum_from_bytes (extra_data_sha256_bytes);\n\n      /* We need to verify the data in the commitmeta again, because the only signed\n         thing is the commit, which has the source info. We could have accidentally\n         picked up some other commitmeta stuff from the remote, or via the untrusted\n         local-pull of the system helper. */\n      found = FALSE;\n      for (j = 0; j < n_extra_data; j++)\n        {\n          g_autoptr(GVariant) content = NULL;\n          g_autoptr(GFile) dest = NULL;\n          g_autofree char *sha256 = NULL;\n          const char *extra_data_name = NULL;\n          const guchar *data;\n          gsize len;\n\n          g_variant_get_child (extra_data, j, \"(^ay@ay)\",\n                               &extra_data_name,\n                               &content);\n\n          if (strcmp (extra_data_source_name, extra_data_name) != 0)\n            continue;\n\n          data = g_variant_get_data (content);\n          len = g_variant_get_size (content);\n\n          if (len != download_size)\n            return flatpak_fail_error (error, FLATPAK_ERROR_INVALID_DATA, _(\"Wrong size for extra data\"));\n\n          sha256 = g_compute_checksum_for_data (G_CHECKSUM_SHA256, data, len);\n          if (strcmp (sha256, extra_data_sha256) != 0)\n            return flatpak_fail_error (error, FLATPAK_ERROR_INVALID_DATA, _(\"Invalid checksum for extra data\"));\n\n          dest = g_file_get_child (extradir, extra_data_name);\n          if (!g_file_replace_contents (dest,\n                                        g_variant_get_data (content),\n                                        g_variant_get_size (content),\n                                        NULL, FALSE, G_FILE_CREATE_REPLACE_DESTINATION,\n                                        NULL, cancellable, error))\n            {\n              g_prefix_error (error, _(\"While writing extra data file '%s': \"), extra_data_name);\n              return FALSE;\n            }\n          found = TRUE;\n        }\n\n      if (!found)\n        return flatpak_fail_error (error, FLATPAK_ERROR_INVALID_DATA,\n                                   _(\"Extra data %s missing in detached metadata\"),\n                                   extra_data_source_name);\n    }\n\n  *created_extra_data = TRUE;\n\n  return TRUE;\n}\n\nstatic void\nchild_setup (gpointer user_data)\n{\n  GArray *fd_array = user_data;\n  int i;\n\n  /* If no fd_array was specified, don't care. */\n  if (fd_array == NULL)\n    return;\n\n  /* Otherwise, mark not - close-on-exec all the fds in the array */\n  for (i = 0; i < fd_array->len; i++)\n    {\n      int fd = g_array_index (fd_array, int, i);\n\n      /* We also seek all fds to the start, because this lets\n         us use the same fd_array multiple times */\n      if (lseek (fd, 0, SEEK_SET) < 0)\n        g_printerr (\"lseek error in child setup\");\n\n      fcntl (fd, F_SETFD, 0);\n    }\n}\n\nstatic gboolean\napply_extra_data (FlatpakDir   *self,\n                  GFile        *checkoutdir,\n                  GCancellable *cancellable,\n                  GError      **error)\n{\n  g_autoptr(GFile) metadata = NULL;\n  g_autofree char *metadata_contents = NULL;\n  gsize metadata_size;\n  g_autoptr(GKeyFile) metakey = NULL;\n  g_autofree char *id = NULL;\n  g_autofree char *runtime_pref = NULL;\n  g_autoptr(FlatpakDecomposed) runtime_ref = NULL;\n  g_autoptr(FlatpakDeploy) runtime_deploy = NULL;\n  g_autoptr(FlatpakBwrap) bwrap = NULL;\n  g_autoptr(GFile) app_files = NULL;\n  g_autoptr(GFile) apply_extra_file = NULL;\n  g_autoptr(GFile) app_export_file = NULL;\n  g_autoptr(GFile) extra_export_file = NULL;\n  g_autoptr(GFile) extra_files = NULL;\n  g_autoptr(GFile) runtime_files = NULL;\n  g_autoptr(FlatpakContext) app_context = NULL;\n  g_auto(GStrv) minimal_envp = NULL;\n  g_autofree char *runtime_arch = NULL;\n  int exit_status;\n  const char *group = FLATPAK_METADATA_GROUP_APPLICATION;\n  g_autoptr(GError) local_error = NULL;\n\n  apply_extra_file = g_file_resolve_relative_path (checkoutdir, \"files/bin/apply_extra\");\n  if (!g_file_query_exists (apply_extra_file, cancellable))\n    return TRUE;\n\n  metadata = g_file_get_child (checkoutdir, \"metadata\");\n\n  if (!g_file_load_contents (metadata, cancellable, &metadata_contents, &metadata_size, NULL, error))\n    return FALSE;\n\n  metakey = g_key_file_new ();\n  if (!g_key_file_load_from_data (metakey, metadata_contents, metadata_size, 0, error))\n    return FALSE;\n\n  id = g_key_file_get_string (metakey, group, FLATPAK_METADATA_KEY_NAME,\n                              &local_error);\n  if (id == NULL)\n    {\n      group = FLATPAK_METADATA_GROUP_RUNTIME;\n      id = g_key_file_get_string (metakey, group, FLATPAK_METADATA_KEY_NAME,\n                                  NULL);\n      if (id == NULL)\n        {\n          g_propagate_error (error, g_steal_pointer (&local_error));\n          return FALSE;\n        }\n      g_clear_error (&local_error);\n    }\n\n  runtime_pref = g_key_file_get_string (metakey, group,\n                                        FLATPAK_METADATA_KEY_RUNTIME, error);\n  if (runtime_pref == NULL)\n    runtime_pref = g_key_file_get_string (metakey, FLATPAK_METADATA_GROUP_EXTENSION_OF,\n                                          FLATPAK_METADATA_KEY_RUNTIME, NULL);\n  if (runtime_pref == NULL)\n    return FALSE;\n\n  runtime_ref = flatpak_decomposed_new_from_pref (FLATPAK_KINDS_RUNTIME, runtime_pref, error);\n  if (runtime_ref == NULL)\n    return FALSE;\n  runtime_arch = flatpak_decomposed_dup_arch (runtime_ref);\n\n  if (!g_key_file_get_boolean (metakey, FLATPAK_METADATA_GROUP_EXTRA_DATA,\n                               FLATPAK_METADATA_KEY_NO_RUNTIME, NULL))\n    {\n      /* We pass in self here so that we ensure that we find the runtime in case it only\n         exists in this installation (which might be custom) */\n      runtime_deploy = flatpak_find_deploy_for_ref (flatpak_decomposed_get_ref (runtime_ref), NULL, self, cancellable, error);\n      if (runtime_deploy == NULL)\n        return FALSE;\n      runtime_files = flatpak_deploy_get_files (runtime_deploy);\n    }\n\n  app_files = g_file_get_child (checkoutdir, \"files\");\n  app_export_file = g_file_get_child (checkoutdir, \"export\");\n  extra_files = g_file_get_child (app_files, \"extra\");\n  extra_export_file = g_file_get_child (extra_files, \"export\");\n\n  minimal_envp = flatpak_run_get_minimal_env (FALSE, FALSE);\n  bwrap = flatpak_bwrap_new (minimal_envp);\n  flatpak_bwrap_add_args (bwrap, flatpak_get_bwrap (), NULL);\n\n  if (runtime_files)\n    flatpak_bwrap_add_args (bwrap,\n                            \"--ro-bind\", flatpak_file_get_path_cached (runtime_files), \"/usr\",\n                            \"--lock-file\", \"/usr/.ref\",\n                            NULL);\n\n  flatpak_bwrap_add_args (bwrap,\n                          \"--ro-bind\", flatpak_file_get_path_cached (app_files), \"/app\",\n                          \"--bind\", flatpak_file_get_path_cached (extra_files), \"/app/extra\",\n                          \"--chdir\", \"/app/extra\",\n                          /* We run as root in the system-helper case, so drop all caps */\n                          \"--cap-drop\", \"ALL\",\n                          NULL);\n\n  if (!flatpak_run_setup_base_argv (bwrap, runtime_files, NULL, runtime_arch,\n                                    /* Might need multiarch in apply_extra (see e.g. #3742). Should be pretty safe in this limited context */\n                                    FLATPAK_RUN_FLAG_MULTIARCH |\n                                    FLATPAK_RUN_FLAG_NO_SESSION_HELPER | FLATPAK_RUN_FLAG_NO_PROC,\n                                    error))\n    return FALSE;\n\n  app_context = flatpak_context_new ();\n\n  if (!flatpak_run_add_environment_args (bwrap, NULL,\n                                         FLATPAK_RUN_FLAG_NO_SESSION_BUS_PROXY |\n                                         FLATPAK_RUN_FLAG_NO_SYSTEM_BUS_PROXY |\n                                         FLATPAK_RUN_FLAG_NO_A11Y_BUS_PROXY,\n                                         id,\n                                         app_context, NULL, NULL, NULL, cancellable, error))\n    return FALSE;\n\n  flatpak_bwrap_envp_to_args (bwrap);\n\n  flatpak_bwrap_add_arg (bwrap, \"/app/bin/apply_extra\");\n\n  flatpak_bwrap_finish (bwrap);\n\n  g_debug (\"Running /app/bin/apply_extra \");\n\n  /* We run the sandbox without caps, but it can still create files owned by itself with\n   * arbitrary permissions, including setuid myself. This is extra risky in the case where\n   * this runs as root in the system helper case. We canonicalize the permissions at the\n   * end, but to avoid non-canonical permissions leaking out before then we make the\n   * toplevel dir only accessible to the user */\n  if (chmod (flatpak_file_get_path_cached (extra_files), 0700) != 0)\n    {\n      glnx_set_error_from_errno (error);\n      return FALSE;\n    }\n\n  if (!g_spawn_sync (NULL,\n                     (char **) bwrap->argv->pdata,\n                     bwrap->envp,\n                     G_SPAWN_SEARCH_PATH,\n                     child_setup, bwrap->fds,\n                     NULL, NULL,\n                     &exit_status,\n                     error))\n    return FALSE;\n\n  if (!flatpak_canonicalize_permissions (AT_FDCWD, flatpak_file_get_path_cached (extra_files),\n                                         getuid () == 0 ? 0 : -1,\n                                         getuid () == 0 ? 0 : -1,\n                                         error))\n    return FALSE;\n\n  if (exit_status != 0)\n    {\n      g_set_error (error, G_IO_ERROR, G_IO_ERROR_FAILED,\n                   _(\"apply_extra script failed, exit status %d\"), exit_status);\n      return FALSE;\n    }\n\n  if (g_file_query_exists (extra_export_file, cancellable))\n    {\n      if (!flatpak_mkdir_p (app_export_file, cancellable, error))\n        return FALSE;\n      if (!flatpak_cp_a (extra_export_file,\n                         app_export_file,\n                         FLATPAK_CP_FLAGS_MERGE,\n                         cancellable, error))\n        return FALSE;\n    }\n\n  return TRUE;\n}\n\n/* Check the user\u2019s parental controls allow installation of @ref by looking at\n * its cached @deploy_data, which contains its content rating as extracted from\n * its AppData when it was originally downloaded. That\u2019s compared to the\n * parental controls policy loaded from the #MctManager.\n *\n * If @ref should not be installed, an error is returned. */\nstatic gboolean\nflatpak_dir_check_parental_controls (FlatpakDir    *self,\n                                     const char    *ref,\n                                     GBytes        *deploy_data,\n                                     GCancellable  *cancellable,\n                                     GError       **error)\n{\n#ifdef HAVE_LIBMALCONTENT\n#ifdef USE_SYSTEM_HELPER\n  g_autoptr(GError) local_error = NULL;\n  const char *on_session = g_getenv (\"FLATPAK_SYSTEM_HELPER_ON_SESSION\");\n  g_autoptr(GDBusConnection) dbus_connection = NULL;\n  g_autoptr(MctManager) manager = NULL;\n  g_autoptr(MctAppFilter) app_filter = NULL;\n  const char *content_rating_type;\n  g_autoptr(GHashTable) content_rating = NULL;\n  g_autoptr(AutoPolkitAuthority) authority = NULL;\n  g_autoptr(AutoPolkitDetails) details = NULL;\n  g_autoptr(AutoPolkitSubject) subject = NULL;\n  gint subject_uid;\n  g_autoptr(AutoPolkitAuthorizationResult) result = NULL;\n  gboolean authorized;\n  gboolean repo_installation_allowed, app_is_appropriate;\n  \n  /* Assume that root is allowed to install any ref and shouldn't have any\n   * parental controls restrictions applied to them */\n  if (getuid () == 0)\n    return TRUE;\n\n  /* The ostree-metadata and appstream/ branches should not have any parental\n   * controls restrictions. Similarly, for the moment, there is no point in\n   * restricting runtimes. */\n  if (!g_str_has_prefix (ref, \"app/\"))\n    return TRUE;\n\n  g_debug (\"Getting parental controls details for %s from %s\",\n           ref, flatpak_deploy_data_get_origin (deploy_data));\n\n  if (on_session != NULL)\n    {\n      /* FIXME: Instead of skipping the parental controls check in the test\n       * environment, make a mock service for it.\n       * https://github.com/flatpak/flatpak/issues/2993 */\n      g_debug (\"Skipping parental controls check for %s since the \"\n               \"system bus is unavailable in the test environment\", ref);\n      return TRUE;\n    }\n\n  dbus_connection = g_bus_get_sync (G_BUS_TYPE_SYSTEM, cancellable, &local_error);\n  if (dbus_connection == NULL)\n    {\n      g_propagate_error (error, g_steal_pointer (&local_error));\n      return FALSE;\n    }\n\n  if (self->user || self->source_pid == 0)\n    subject = polkit_unix_process_new_for_owner (getpid (), 0, getuid ());\n  else\n    subject = polkit_unix_process_new_for_owner (self->source_pid, 0, -1);\n\n  /* Get the parental controls for the invoking user. */\n  subject_uid = polkit_unix_process_get_uid (POLKIT_UNIX_PROCESS (subject));\n  if (subject_uid == -1)\n    {\n      g_set_error_literal (error, G_DBUS_ERROR, G_DBUS_ERROR_AUTH_FAILED,\n                           \"Failed to get subject UID\");\n      return FALSE;\n    }\n\n  manager = mct_manager_new (dbus_connection);\n  app_filter = mct_manager_get_app_filter (manager, subject_uid,\n                                           MCT_GET_APP_FILTER_FLAGS_INTERACTIVE,\n                                           cancellable, &local_error);\n  if (g_error_matches (local_error, MCT_APP_FILTER_ERROR, MCT_APP_FILTER_ERROR_DISABLED))\n    {\n      g_debug (\"Skipping parental controls check for %s since parental \"\n               \"controls are disabled globally\", ref);\n      return TRUE;\n    }\n  else if (g_error_matches (local_error, G_DBUS_ERROR, G_DBUS_ERROR_SERVICE_UNKNOWN) ||\n           g_error_matches (local_error, G_DBUS_ERROR, G_DBUS_ERROR_NAME_HAS_NO_OWNER))\n    {\n      g_debug (\"Skipping parental controls check for %s since a required \"\n               \"service was not found\", ref);\n      return TRUE;\n    }\n  else if (local_error != NULL)\n    {\n      g_propagate_error (error, g_steal_pointer (&local_error));\n      return FALSE;\n    }\n\n  /* Check the content rating against the parental controls. If the app is\n   * allowed to be installed, return so immediately. */\n  repo_installation_allowed = ((self->user && mct_app_filter_is_user_installation_allowed (app_filter)) ||\n                               (!self->user && mct_app_filter_is_system_installation_allowed (app_filter)));\n\n  content_rating_type = flatpak_deploy_data_get_appdata_content_rating_type (deploy_data);\n  content_rating = flatpak_deploy_data_get_appdata_content_rating (deploy_data);\n  app_is_appropriate = flatpak_oars_check_rating (content_rating, content_rating_type,\n                                                  app_filter);\n\n  if (repo_installation_allowed && app_is_appropriate)\n    {\n      g_debug (\"Parental controls policy satisfied for %s\", ref);\n      return TRUE;\n    }\n\n  /* Otherwise, check polkit to see if the admin is going to allow the user to\n   * override their parental controls policy. We can\u2019t pass any details to this\n   * polkit check, since it could be run by the user or by the system helper,\n   * and non-root users can\u2019t pass details to polkit checks. */\n  authority = polkit_authority_get_sync (NULL, error);\n  if (authority == NULL)\n    return FALSE;\n\n  result = polkit_authority_check_authorization_sync (authority, subject,\n                                                      \"org.freedesktop.Flatpak.override-parental-controls\",\n                                                      NULL,\n                                                      POLKIT_CHECK_AUTHORIZATION_FLAGS_ALLOW_USER_INTERACTION,\n                                                      cancellable, error);\n  if (result == NULL)\n    return FALSE;\n\n  authorized = polkit_authorization_result_get_is_authorized (result);\n\n  if (!authorized)\n    return flatpak_fail_error (error, FLATPAK_ERROR_PERMISSION_DENIED,\n                               /* Translators: The placeholder is for an app ref. */\n                               _(\"Installing %s is not allowed by the policy set by your administrator\"),\n                               ref);\n\n  g_debug (\"Parental controls policy overridden by polkit for %s\", ref);\n#endif  /* USE_SYSTEM_HELPER */\n#endif  /* HAVE_LIBMALCONTENT */\n\n  return TRUE;\n}\n\n/* We create a deploy ref for the currently deployed version of all refs to avoid\n   deployed commits being pruned when e.g. we pull --no-deploy. */\nstatic gboolean\nflatpak_dir_update_deploy_ref (FlatpakDir *self,\n                               const char *ref,\n                               const char *checksum,\n                               GError    **error)\n{\n  g_autofree char *deploy_ref = g_strconcat (\"deploy/\", ref, NULL);\n\n  if (!ostree_repo_set_ref_immediate (self->repo, NULL, deploy_ref, checksum, NULL, error))\n    return FALSE;\n\n  return TRUE;\n}\n\ngboolean\nflatpak_dir_deploy (FlatpakDir          *self,\n                    const char          *origin,\n                    FlatpakDecomposed   *ref,\n                    const char          *checksum_or_latest,\n                    const char * const * subpaths,\n                    const char * const * previous_ids,\n                    GCancellable        *cancellable,\n                    GError             **error)\n{\n  g_autofree char *resolved_ref = NULL;\n  g_autofree char *ref_id = NULL;\n  g_autoptr(GFile) root = NULL;\n  g_autoptr(GFile) deploy_base = NULL;\n  g_autoptr(GFile) checkoutdir = NULL;\n  g_autoptr(GFile) bindir = NULL;\n  g_autofree char *checkoutdirpath = NULL;\n  g_autoptr(GFile) real_checkoutdir = NULL;\n  g_autoptr(GFile) dotref = NULL;\n  g_autoptr(GFile) files_etc = NULL;\n  g_autoptr(GFile) deploy_data_file = NULL;\n  g_autoptr(GVariant) commit_data = NULL;\n  g_autoptr(GBytes) deploy_data = NULL;\n  g_autoptr(GFile) export = NULL;\n  g_autoptr(GFile) extradir = NULL;\n  g_autoptr(GKeyFile) keyfile = NULL;\n  guint64 installed_size = 0;\n  OstreeRepoCheckoutAtOptions options = { 0, };\n  const char *checksum;\n  glnx_autofd int checkoutdir_dfd = -1;\n  g_autoptr(GFile) tmp_dir_template = NULL;\n  g_autofree char *tmp_dir_path = NULL;\n  const char *xa_ref = NULL;\n  g_autofree char *checkout_basename = NULL;\n  gboolean created_extra_data = FALSE;\n  g_autoptr(GVariant) commit_metadata = NULL;\n  g_auto(GLnxLockFile) lock = { 0, };\n  g_autoptr(GFile) metadata_file = NULL;\n  g_autofree char *metadata_contents = NULL;\n  gboolean is_oci;\n\n  if (!flatpak_dir_ensure_repo (self, cancellable, error))\n    return FALSE;\n\n  ref_id = flatpak_decomposed_dup_id (ref);\n\n  /* Keep a shared repo lock to avoid prunes removing objects we're relying on\n   * while we do the checkout. This could happen if the ref changes after we\n   * read its current value for the checkout. */\n  if (!flatpak_dir_repo_lock (self, &lock, LOCK_SH, cancellable, error))\n    return FALSE;\n\n  deploy_base = flatpak_dir_get_deploy_dir (self, ref);\n\n  if (checksum_or_latest == NULL)\n    {\n      g_debug (\"No checksum specified, getting tip of %s from origin %s\", flatpak_decomposed_get_ref (ref), origin);\n\n      resolved_ref = flatpak_dir_read_latest (self, origin, flatpak_decomposed_get_ref (ref), NULL, cancellable, error);\n      if (resolved_ref == NULL)\n        {\n          g_prefix_error (error, _(\"While trying to resolve ref %s: \"), flatpak_decomposed_get_ref (ref));\n          return FALSE;\n        }\n\n      checksum = resolved_ref;\n      g_debug (\"tip resolved to: %s\", checksum);\n    }\n  else\n    {\n      checksum = checksum_or_latest;\n      g_debug (\"Looking for checksum %s in local repo\", checksum);\n      if (!ostree_repo_read_commit (self->repo, checksum, NULL, NULL, cancellable, NULL))\n        return flatpak_fail_error (error, FLATPAK_ERROR_INVALID_DATA, _(\"%s is not available\"), flatpak_decomposed_get_ref (ref));\n    }\n\n  if (!ostree_repo_load_commit (self->repo, checksum, &commit_data, NULL, error))\n    return FALSE;\n\n  commit_metadata = g_variant_get_child_value (commit_data, 0);\n  checkout_basename = flatpak_dir_get_deploy_subdir (self, checksum, subpaths);\n\n  real_checkoutdir = g_file_get_child (deploy_base, checkout_basename);\n  if (g_file_query_exists (real_checkoutdir, cancellable))\n    return flatpak_fail_error (error, FLATPAK_ERROR_ALREADY_INSTALLED,\n                               _(\"%s commit %s already installed\"), flatpak_decomposed_get_ref (ref), checksum);\n\n  g_autofree char *template = g_strdup_printf (\".%s-XXXXXX\", checkout_basename);\n  tmp_dir_template = g_file_get_child (deploy_base, template);\n  tmp_dir_path = g_file_get_path (tmp_dir_template);\n\n  if (g_mkdtemp_full (tmp_dir_path, 0755) == NULL)\n    {\n      g_set_error_literal (error, G_IO_ERROR, G_IO_ERROR_FAILED,\n                           _(\"Can't create deploy directory\"));\n      return FALSE;\n    }\n\n  checkoutdir = g_file_new_for_path (tmp_dir_path);\n\n  if (!ostree_repo_read_commit (self->repo, checksum, &root, NULL, cancellable, error))\n    {\n      g_prefix_error (error, _(\"Failed to read commit %s: \"), checksum);\n      return FALSE;\n    }\n\n  if (!flatpak_repo_collect_sizes (self->repo, root, &installed_size, NULL, cancellable, error))\n    return FALSE;\n\n  options.mode = OSTREE_REPO_CHECKOUT_MODE_USER;\n  options.overwrite_mode = OSTREE_REPO_CHECKOUT_OVERWRITE_UNION_FILES;\n  options.enable_fsync = FALSE; /* We checkout to a temp dir and sync before moving it in place */\n  options.bareuseronly_dirs = TRUE; /* https://github.com/ostreedev/ostree/pull/927 */\n  checkoutdirpath = g_file_get_path (checkoutdir);\n\n  if (subpaths == NULL || *subpaths == NULL)\n    {\n      if (!ostree_repo_checkout_at (self->repo, &options,\n                                    AT_FDCWD, checkoutdirpath,\n                                    checksum,\n                                    cancellable, error))\n        {\n          g_prefix_error (error, _(\"While trying to checkout %s into %s: \"), checksum, checkoutdirpath);\n          return FALSE;\n        }\n    }\n  else\n    {\n      g_autoptr(GFile) files = g_file_get_child (checkoutdir, \"files\");\n      int i;\n\n      if (!g_file_make_directory_with_parents (files, cancellable, error))\n        return FALSE;\n\n      options.subpath = \"/metadata\";\n\n      if (!ostree_repo_checkout_at (self->repo, &options,\n                                    AT_FDCWD, checkoutdirpath,\n                                    checksum,\n                                    cancellable, error))\n        {\n          g_prefix_error (error, _(\"While trying to checkout metadata subpath: \"));\n          return FALSE;\n        }\n\n      for (i = 0; subpaths[i] != NULL; i++)\n        {\n          g_autofree char *subpath = g_build_filename (\"/files\", subpaths[i], NULL);\n          g_autofree char *dstpath = g_build_filename (checkoutdirpath, \"/files\", subpaths[i], NULL);\n          g_autofree char *dstpath_parent = g_path_get_dirname (dstpath);\n          g_autoptr(GFile) child = NULL;\n\n          child = g_file_resolve_relative_path (root, subpath);\n\n          if (!g_file_query_exists (child, cancellable))\n            {\n              g_debug (\"subpath %s not in tree\", subpaths[i]);\n              continue;\n            }\n\n          if (g_mkdir_with_parents (dstpath_parent, 0755))\n            {\n              glnx_set_error_from_errno (error);\n              return FALSE;\n            }\n\n          options.subpath = subpath;\n          if (!ostree_repo_checkout_at (self->repo, &options,\n                                        AT_FDCWD, dstpath,\n                                        checksum,\n                                        cancellable, error))\n            {\n              g_prefix_error (error, _(\"While trying to checkout subpath \u2018%s\u2019: \"), subpath);\n              return FALSE;\n            }\n        }\n    }\n\n  /* Extract any extra data */\n  extradir = g_file_resolve_relative_path (checkoutdir, \"files/extra\");\n  if (!flatpak_rm_rf (extradir, cancellable, error))\n    {\n      g_prefix_error (error, _(\"While trying to remove existing extra dir: \"));\n      return FALSE;\n    }\n\n  if (!extract_extra_data (self, checksum, extradir, &created_extra_data, cancellable, error))\n    return FALSE;\n\n  if (created_extra_data)\n    {\n      if (!apply_extra_data (self, checkoutdir, cancellable, error))\n        {\n          g_prefix_error (error, _(\"While trying to apply extra data: \"));\n          return FALSE;\n        }\n    }\n\n  g_variant_lookup (commit_metadata, \"xa.ref\", \"&s\", &xa_ref);\n  if (xa_ref != NULL)\n    {\n      gboolean gpg_verify_summary;\n\n      if (!ostree_repo_remote_get_gpg_verify_summary (self->repo, origin, &gpg_verify_summary, error))\n        return FALSE;\n\n      if (gpg_verify_summary)\n        {\n          /* If we're using signed summaries, then the security is really due to the signatures on\n           * the summary, and the xa.ref is not needed for security. In particular, endless are\n           * currently using one single commit on multiple branches to handle devel/stable promotion.\n           * So, to support this we report branch discrepancies as a warning, rather than as an error.\n           * See https://github.com/flatpak/flatpak/pull/1013 for more discussion.\n           */\n          FlatpakDecomposed *checkout_ref = ref;\n          g_autoptr(FlatpakDecomposed) commit_ref = NULL;\n\n          commit_ref = flatpak_decomposed_new_from_ref (xa_ref, error);\n          if (commit_ref == NULL)\n            {\n              g_prefix_error (error, _(\"Invalid commit ref %s: \"), xa_ref);\n              return FALSE;\n            }\n\n          /* Fatal if kind/name/arch don't match. Warn for branch mismatch. */\n          if (!flatpak_decomposed_equal_except_branch (checkout_ref, commit_ref))\n            {\n              g_set_error (error, G_IO_ERROR, G_IO_ERROR_PERMISSION_DENIED,\n                           _(\"Deployed ref %s does not match commit (%s)\"),\n                           flatpak_decomposed_get_ref (ref), xa_ref);\n              return FALSE;\n            }\n\n          if (strcmp (flatpak_decomposed_get_branch (checkout_ref), flatpak_decomposed_get_branch (commit_ref)) != 0)\n            g_warning (_(\"Deployed ref %s branch does not match commit (%s)\"),\n                       flatpak_decomposed_get_ref (ref), xa_ref);\n        }\n      else if (strcmp (flatpak_decomposed_get_ref (ref), xa_ref) != 0)\n        {\n          g_set_error (error, G_IO_ERROR, G_IO_ERROR_PERMISSION_DENIED,\n                       _(\"Deployed ref %s does not match commit (%s)\"), flatpak_decomposed_get_ref (ref), xa_ref);\n          return FALSE;\n        }\n    }\n\n  keyfile = g_key_file_new ();\n  metadata_file = g_file_resolve_relative_path (checkoutdir, \"metadata\");\n  if (g_file_load_contents (metadata_file, NULL,\n                            &metadata_contents, NULL, NULL, NULL))\n    {\n      if (!g_key_file_load_from_data (keyfile,\n                                      metadata_contents,\n                                      -1,\n                                      0, error))\n        return FALSE;\n\n      if (!flatpak_check_required_version (flatpak_decomposed_get_ref (ref), keyfile, error))\n        return FALSE;\n    }\n\n  /* Check the metadata in the commit to make sure it matches the actual\n   * deployed metadata, in case we relied on the one in the commit for\n   * a decision\n   * Note: For historical reason we don't enforce commits to contain xa.metadata\n   * since this was lacking in fedora builds.\n   */\n  is_oci = flatpak_dir_get_remote_oci (self, origin);\n  if (!validate_commit_metadata (commit_data, flatpak_decomposed_get_ref (ref),\n                                 metadata_contents, !is_oci, error))\n    return FALSE;\n\n  dotref = g_file_resolve_relative_path (checkoutdir, \"files/.ref\");\n  if (!g_file_replace_contents (dotref, \"\", 0, NULL, FALSE,\n                                G_FILE_CREATE_REPLACE_DESTINATION, NULL, cancellable, error))\n    return TRUE;\n\n  export = g_file_get_child (checkoutdir, \"export\");\n\n  /* Never export any binaries bundled with the app */\n  bindir = g_file_get_child (export, \"bin\");\n  if (!flatpak_rm_rf (bindir, cancellable, error))\n    return FALSE;\n\n  if (flatpak_decomposed_is_runtime (ref))\n    {\n      /* Ensure that various files exists as regular files in /usr/etc, as we\n         want to bind-mount over them */\n      files_etc = g_file_resolve_relative_path (checkoutdir, \"files/etc\");\n      if (g_file_query_exists (files_etc, cancellable))\n        {\n          char *etcfiles[] = {\"passwd\", \"group\", \"machine-id\" };\n          g_autoptr(GFile) etc_resolve_conf = g_file_get_child (files_etc, \"resolv.conf\");\n          int i;\n          for (i = 0; i < G_N_ELEMENTS (etcfiles); i++)\n            {\n              g_autoptr(GFile) etc_file = g_file_get_child (files_etc, etcfiles[i]);\n              GFileType type;\n\n              type = g_file_query_file_type (etc_file, G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n                                             cancellable);\n              if (type == G_FILE_TYPE_REGULAR)\n                continue;\n\n              if (type != G_FILE_TYPE_UNKNOWN)\n                {\n                  /* Already exists, but not regular, probably symlink. Remove it */\n                  if (!g_file_delete (etc_file, cancellable, error))\n                    return FALSE;\n                }\n\n              if (!g_file_replace_contents (etc_file, \"\", 0, NULL, FALSE,\n                                            G_FILE_CREATE_REPLACE_DESTINATION,\n                                            NULL, cancellable, error))\n                return FALSE;\n            }\n\n          if (g_file_query_exists (etc_resolve_conf, cancellable) &&\n              !g_file_delete (etc_resolve_conf, cancellable, error))\n            return TRUE;\n\n          if (!g_file_make_symbolic_link (etc_resolve_conf,\n                                          \"/run/host/monitor/resolv.conf\",\n                                          cancellable, error))\n            return FALSE;\n        }\n\n      /* Runtime should never export anything */\n      if (!flatpak_rm_rf (export, cancellable, error))\n        return FALSE;\n    }\n  else /* is app */\n    {\n      g_autofree char *ref_arch = flatpak_decomposed_dup_arch (ref);\n      g_autofree char *ref_branch = flatpak_decomposed_dup_branch (ref);\n      g_autoptr(GFile) wrapper = g_file_get_child (bindir, ref_id);\n      g_autofree char *escaped_app = maybe_quote (ref_id);\n      g_autofree char *escaped_branch = maybe_quote (ref_branch);\n      g_autofree char *escaped_arch = maybe_quote (ref_arch);\n      g_autofree char *bin_data = NULL;\n      int r;\n\n      if (!flatpak_mkdir_p (bindir, cancellable, error))\n        return FALSE;\n\n      if (!flatpak_rewrite_export_dir (ref_id, ref_branch, ref_arch,\n                                       keyfile, previous_ids, export,\n                                       cancellable,\n                                       error))\n        return FALSE;\n\n      bin_data = g_strdup_printf (\"#!/bin/sh\\nexec %s/flatpak run --branch=%s --arch=%s %s \\\"$@\\\"\\n\",\n                                  FLATPAK_BINDIR, escaped_branch, escaped_arch, escaped_app);\n      if (!g_file_replace_contents (wrapper, bin_data, strlen (bin_data), NULL, FALSE,\n                                    G_FILE_CREATE_REPLACE_DESTINATION, NULL, cancellable, error))\n        return FALSE;\n\n      do\n        r = fchmodat (AT_FDCWD, flatpak_file_get_path_cached (wrapper), 0755, 0);\n      while (G_UNLIKELY (r == -1 && errno == EINTR));\n      if (r == -1)\n        return glnx_throw_errno_prefix (error, \"fchmodat\");\n    }\n\n  deploy_data = flatpak_dir_new_deploy_data (self,\n                                             checkoutdir,\n                                             commit_data,\n                                             commit_metadata,\n                                             keyfile,\n                                             ref_id,\n                                             origin,\n                                             checksum,\n                                             (char **) subpaths,\n                                             installed_size,\n                                             previous_ids);\n\n  /* Check the app is actually allowed to be used by this user. This can block\n   * on getting authorisation. */\n  if (!flatpak_dir_check_parental_controls (self, flatpak_decomposed_get_ref (ref), deploy_data, cancellable, error))\n    return FALSE;\n\n  deploy_data_file = g_file_get_child (checkoutdir, \"deploy\");\n  if (!flatpak_bytes_save (deploy_data_file, deploy_data, cancellable, error))\n    return FALSE;\n\n  if (!glnx_opendirat (AT_FDCWD, checkoutdirpath, TRUE, &checkoutdir_dfd, error))\n    return FALSE;\n\n  if (syncfs (checkoutdir_dfd) != 0)\n    {\n      glnx_set_error_from_errno (error);\n      return FALSE;\n    }\n\n  if (!g_file_move (checkoutdir, real_checkoutdir, G_FILE_COPY_NO_FALLBACK_FOR_MOVE,\n                    cancellable, NULL, NULL, error))\n    return FALSE;\n\n  if (!flatpak_dir_set_active (self, ref, checkout_basename, cancellable, error))\n    return FALSE;\n\n  if (!flatpak_dir_update_deploy_ref (self, flatpak_decomposed_get_ref (ref), checksum, error))\n    return FALSE;\n\n  return TRUE;\n}\n\n/* -origin remotes are deleted when the last ref referring to it is undeployed */\nvoid\nflatpak_dir_prune_origin_remote (FlatpakDir *self,\n                                 const char *remote)\n{\n  if (remote != NULL &&\n      g_str_has_suffix (remote, \"-origin\") &&\n      flatpak_dir_get_remote_noenumerate (self, remote) &&\n      !flatpak_dir_remote_has_deploys (self, remote))\n    {\n      if (flatpak_dir_use_system_helper (self, NULL))\n        {\n          const char *installation = flatpak_dir_get_id (self);\n          g_autoptr(GVariant) gpg_data_v = NULL;\n\n          gpg_data_v = g_variant_ref_sink (g_variant_new_from_data (G_VARIANT_TYPE (\"ay\"), \"\", 0, TRUE, NULL, NULL));\n\n          flatpak_dir_system_helper_call_configure_remote (self,\n                                                           FLATPAK_HELPER_CONFIGURE_FLAGS_NONE,\n                                                           remote,\n                                                           \"\",\n                                                           gpg_data_v,\n                                                           installation ? installation : \"\",\n                                                           NULL, NULL);\n        }\n      else\n        flatpak_dir_remove_remote (self, FALSE, remote, NULL, NULL);\n    }\n}\n\ngboolean\nflatpak_dir_deploy_install (FlatpakDir        *self,\n                            FlatpakDecomposed *ref,\n                            const char        *origin,\n                            const char       **subpaths,\n                            const char       **previous_ids,\n                            gboolean           reinstall,\n                            GCancellable      *cancellable,\n                            GError           **error)\n{\n  g_auto(GLnxLockFile) lock = { 0, };\n  g_autoptr(GFile) deploy_base = NULL;\n  g_autoptr(GFile) old_deploy_dir = NULL;\n  gboolean created_deploy_base = FALSE;\n  gboolean ret = FALSE;\n  g_autoptr(GError) local_error = NULL;\n  g_autofree char *remove_ref_from_remote = NULL;\n  g_autofree char *commit = NULL;\n  g_autofree char *old_active = NULL;\n\n  if (!flatpak_dir_lock (self, &lock,\n                         cancellable, error))\n    goto out;\n\n  old_deploy_dir = flatpak_dir_get_if_deployed (self, ref, NULL, cancellable);\n  if (old_deploy_dir != NULL)\n    {\n      old_active = flatpak_dir_read_active (self, ref, cancellable);\n\n      if (reinstall)\n        {\n          g_autoptr(GBytes) old_deploy = NULL;\n          const char *old_origin;\n\n          old_deploy = flatpak_load_deploy_data (old_deploy_dir, ref, self->repo, FLATPAK_DEPLOY_VERSION_ANY, cancellable, error);\n          if (old_deploy == NULL)\n            goto out;\n\n          /* If the old install was from a different remote, remove the ref */\n          old_origin = flatpak_deploy_data_get_origin (old_deploy);\n          if (strcmp (old_origin, origin) != 0)\n            remove_ref_from_remote = g_strdup (old_origin);\n\n          g_debug (\"Removing old deployment for reinstall\");\n          if (!flatpak_dir_undeploy (self, ref, old_active,\n                                     TRUE, FALSE,\n                                     cancellable, error))\n            goto out;\n        }\n      else\n        {\n          g_autofree char *id = flatpak_decomposed_dup_id (ref);\n          g_autofree char *branch = flatpak_decomposed_dup_branch (ref);\n          g_set_error (error, FLATPAK_ERROR, FLATPAK_ERROR_ALREADY_INSTALLED,\n                       _(\"%s branch %s already installed\"), id, branch);\n          goto out;\n        }\n    }\n\n  deploy_base = flatpak_dir_get_deploy_dir (self, ref);\n  if (!g_file_make_directory_with_parents (deploy_base, cancellable, &local_error))\n    {\n      if (!g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_EXISTS))\n        {\n          g_propagate_error (error, g_steal_pointer (&local_error));\n          goto out;\n        }\n    }\n\n  /* After we create the deploy base we must goto out on errors */\n  created_deploy_base = TRUE;\n\n  if (!flatpak_dir_deploy (self, origin, ref, NULL, (const char * const *) subpaths,\n                           previous_ids, cancellable, error))\n    goto out;\n\n  if (flatpak_decomposed_is_app (ref))\n    {\n      g_autofree char *id = flatpak_decomposed_dup_id (ref);\n\n      if (!flatpak_dir_make_current_ref (self, ref, cancellable, error))\n        goto out;\n\n      if (!flatpak_dir_update_exports (self, id, cancellable, error))\n        goto out;\n    }\n\n  /* Remove old ref if the reinstalled was from a different remote */\n  if (remove_ref_from_remote != NULL)\n    {\n      if (!flatpak_dir_remove_ref (self, remove_ref_from_remote, flatpak_decomposed_get_ref (ref), cancellable, error))\n        goto out;\n\n      flatpak_dir_prune_origin_remote (self, remove_ref_from_remote);\n    }\n\n  /* Release lock before doing possibly slow prune */\n  glnx_release_lock_file (&lock);\n\n  flatpak_dir_cleanup_removed (self, cancellable, NULL);\n\n  if (!flatpak_dir_mark_changed (self, error))\n    goto out;\n\n  ret = TRUE;\n\n  commit = flatpak_dir_read_active (self, ref, cancellable);\n  flatpak_dir_log (self, \"deploy install\", origin, flatpak_decomposed_get_ref (ref), commit, old_active, NULL,\n                   \"Installed %s from %s\", flatpak_decomposed_get_ref (ref), origin);\n\nout:\n  if (created_deploy_base && !ret)\n    flatpak_rm_rf (deploy_base, cancellable, NULL);\n\n  return ret;\n}\n\n\ngboolean\nflatpak_dir_deploy_update (FlatpakDir        *self,\n                           FlatpakDecomposed *ref,\n                           const char        *checksum_or_latest,\n                           const char       **opt_subpaths,\n                           const char       **opt_previous_ids,\n                           GCancellable      *cancellable,\n                           GError           **error)\n{\n  g_autoptr(GBytes) old_deploy_data = NULL;\n  g_auto(GLnxLockFile) lock = { 0, };\n  g_autofree const char **old_subpaths = NULL;\n  g_autofree char *old_active = NULL;\n  const char *old_origin;\n  g_autofree char *commit = NULL;\n  g_auto(GStrv) previous_ids = NULL;\n\n  if (!flatpak_dir_lock (self, &lock,\n                         cancellable, error))\n    return FALSE;\n\n  old_deploy_data = flatpak_dir_get_deploy_data (self, ref,\n                                                 FLATPAK_DEPLOY_VERSION_ANY,\n                                                 cancellable, error);\n  if (old_deploy_data == NULL)\n    return FALSE;\n\n  old_active = flatpak_dir_read_active (self, ref, cancellable);\n\n  old_origin = flatpak_deploy_data_get_origin (old_deploy_data);\n  old_subpaths = flatpak_deploy_data_get_subpaths (old_deploy_data);\n\n  previous_ids = g_strdupv ((char **) flatpak_deploy_data_get_previous_ids (old_deploy_data, NULL));\n  if (opt_previous_ids)\n    {\n      g_auto(GStrv) old_previous_ids = previous_ids;\n      previous_ids = flatpak_strv_merge (old_previous_ids, (char **) opt_previous_ids);\n    }\n\n  if (!flatpak_dir_deploy (self,\n                           old_origin,\n                           ref,\n                           checksum_or_latest,\n                           opt_subpaths ? opt_subpaths : old_subpaths,\n                           (const char * const *) previous_ids,\n                           cancellable, error))\n    return FALSE;\n\n  if (old_active &&\n      !flatpak_dir_undeploy (self, ref, old_active,\n                             TRUE, FALSE,\n                             cancellable, error))\n    return FALSE;\n\n  if (flatpak_decomposed_is_app (ref))\n    {\n      g_autofree char *id = flatpak_decomposed_dup_id (ref);\n\n      if (!flatpak_dir_update_exports (self, id, cancellable, error))\n        return FALSE;\n    }\n\n  /* Release lock before doing possibly slow prune */\n  glnx_release_lock_file (&lock);\n\n  if (!flatpak_dir_mark_changed (self, error))\n    return FALSE;\n\n  flatpak_dir_cleanup_removed (self, cancellable, NULL);\n\n  commit = flatpak_dir_read_active (self, ref, cancellable);\n  flatpak_dir_log (self, \"deploy update\", old_origin, flatpak_decomposed_get_ref (ref), commit, old_active, NULL,\n                   \"Updated %s from %s\", flatpak_decomposed_get_ref (ref), old_origin);\n\n  return TRUE;\n}\n\nstatic FlatpakOciRegistry *\nflatpak_dir_create_system_child_oci_registry (FlatpakDir   *self,\n                                              GLnxLockFile *file_lock,\n                                              const char   *token,\n                                              GError      **error)\n{\n  g_autoptr(GFile) cache_dir = NULL;\n  g_autoptr(GFile) repo_dir = NULL;\n  g_autofree char *repo_url = NULL;\n  g_autofree char *tmpdir_name = NULL;\n  g_autoptr(FlatpakOciRegistry) new_registry = NULL;\n\n  g_assert (!self->user);\n\n  if (!flatpak_dir_ensure_repo (self, NULL, error))\n    return NULL;\n\n  cache_dir = flatpak_ensure_system_user_cache_dir_location (error);\n  if (cache_dir == NULL)\n    return NULL;\n\n  if (!flatpak_allocate_tmpdir (AT_FDCWD,\n                                flatpak_file_get_path_cached (cache_dir),\n                                \"child-oci-\", &tmpdir_name,\n                                NULL,\n                                file_lock,\n                                NULL,\n                                NULL, error))\n    return NULL;\n\n  repo_dir = g_file_get_child (cache_dir, tmpdir_name);\n  repo_url = g_file_get_uri (repo_dir);\n\n  new_registry = flatpak_oci_registry_new (repo_url, TRUE, -1,\n                                           NULL, error);\n  if (new_registry == NULL)\n    return NULL;\n\n  flatpak_oci_registry_set_token (new_registry, token);\n\n  return g_steal_pointer (&new_registry);\n}\n\nstatic OstreeRepo *\nflatpak_dir_create_child_repo (FlatpakDir   *self,\n                               GFile        *cache_dir,\n                               GLnxLockFile *file_lock,\n                               const char   *optional_commit,\n                               GError      **error)\n{\n  g_autoptr(GFile) repo_dir = NULL;\n  g_autoptr(GFile) repo_dir_config = NULL;\n  g_autoptr(OstreeRepo) repo = NULL;\n  g_autofree char *tmpdir_name = NULL;\n  g_autoptr(OstreeRepo) new_repo = NULL;\n  g_autoptr(GKeyFile) config = NULL;\n  g_autofree char *current_mode = NULL;\n  GKeyFile *orig_config = NULL;\n  g_autofree char *orig_min_free_space_percent = NULL;\n  g_autofree char *orig_min_free_space_size = NULL;\n\n  /* We use bare-user-only here now, which means we don't need xattrs\n   * for the child repo. This only works as long as the pulled repo\n   * is valid in a bare-user-only repo, i.e. doesn't have xattrs or\n   * weird permissions, because then the pull into the system repo\n   * would complain that the checksum was wrong. However, by now all\n   * flatpak builds are likely to be valid, so this is fine.\n   */\n  OstreeRepoMode mode = OSTREE_REPO_MODE_BARE_USER_ONLY;\n  const char *mode_str = \"bare-user-only\";\n\n  if (!flatpak_dir_ensure_repo (self, NULL, error))\n    return NULL;\n\n  orig_config = ostree_repo_get_config (self->repo);\n\n  if (!flatpak_allocate_tmpdir (AT_FDCWD,\n                                flatpak_file_get_path_cached (cache_dir),\n                                \"repo-\", &tmpdir_name,\n                                NULL,\n                                file_lock,\n                                NULL,\n                                NULL, error))\n    return NULL;\n\n  repo_dir = g_file_get_child (cache_dir, tmpdir_name);\n\n  new_repo = ostree_repo_new (repo_dir);\n\n  repo_dir_config = g_file_get_child (repo_dir, \"config\");\n  if (!g_file_query_exists (repo_dir_config, NULL))\n    {\n      if (!ostree_repo_create (new_repo, mode, NULL, error))\n        return NULL;\n    }\n  else\n    {\n      /* Try to open, but on failure, re-create */\n      if (!ostree_repo_open (new_repo, NULL, NULL))\n        {\n          flatpak_rm_rf (repo_dir, NULL, NULL);\n          if (!ostree_repo_create (new_repo, mode, NULL, error))\n            return NULL;\n        }\n    }\n\n  config = ostree_repo_copy_config (new_repo);\n\n  /* Verify that the mode is the expected one; if it isn't, recreate the repo */\n  current_mode = g_key_file_get_string (config, \"core\", \"mode\", NULL);\n  if (current_mode == NULL || g_strcmp0 (current_mode, mode_str) != 0)\n    {\n      flatpak_rm_rf (repo_dir, NULL, NULL);\n\n      /* Re-initialize the object because its dir's contents have been deleted (and it\n       * holds internal references to them) */\n      g_object_unref (new_repo);\n      new_repo = ostree_repo_new (repo_dir);\n\n      if (!ostree_repo_create (new_repo, mode, NULL, error))\n        return NULL;\n\n      /* Reload the repo config */\n      g_key_file_free (config);\n      config = ostree_repo_copy_config (new_repo);\n    }\n\n  /* Ensure the config is updated */\n  g_key_file_set_string (config, \"core\", \"parent\",\n                         flatpak_file_get_path_cached (ostree_repo_get_path (self->repo)));\n\n  /* Copy the min space percent value so it affects the temporary repo too */\n  orig_min_free_space_percent = g_key_file_get_value (orig_config, \"core\", \"min-free-space-percent\", NULL);\n  if (orig_min_free_space_percent)\n    g_key_file_set_value (config, \"core\", \"min-free-space-percent\", orig_min_free_space_percent);\n\n  /* Copy the min space size value so it affects the temporary repo too */\n  orig_min_free_space_size = g_key_file_get_value (orig_config, \"core\", \"min-free-space-size\", NULL);\n  if (orig_min_free_space_size)\n    g_key_file_set_value (config, \"core\", \"min-free-space-size\", orig_min_free_space_size);\n\n  if (!ostree_repo_write_config (new_repo, config, error))\n    return NULL;\n\n  /* We need to reopen to apply the parent config */\n  repo = ostree_repo_new (repo_dir);\n\n  if (!ostree_repo_open (repo, NULL, error))\n    return NULL;\n\n  /* We don't need to sync the child repos, they are never used for stable storage, and we\n     verify + fsync when importing to stable storage */\n  ostree_repo_set_disable_fsync (repo, TRUE);\n\n  g_autoptr(GFile) user_cache_dir = flatpak_ensure_user_cache_dir_location (error);\n  if (user_cache_dir == NULL)\n    return FALSE;\n\n  if (!ostree_repo_set_cache_dir (repo, AT_FDCWD,\n                                  flatpak_file_get_path_cached (user_cache_dir),\n                                  NULL, error))\n    return FALSE;\n\n  /* Create a commitpartial in the child repo if needed to ensure we download everything, because\n     any commitpartial state in the parent will not otherwise be inherited */\n  if (optional_commit)\n    {\n      g_autofree char *commitpartial_basename = g_strconcat (optional_commit, \".commitpartial\", NULL);\n      g_autoptr(GFile) orig_commitpartial =\n        flatpak_build_file (ostree_repo_get_path (self->repo),\n                            \"state\", commitpartial_basename, NULL);\n      if (g_file_query_exists (orig_commitpartial, NULL))\n        {\n          g_autoptr(GFile) commitpartial =\n            flatpak_build_file (ostree_repo_get_path (repo),\n                                \"state\", commitpartial_basename, NULL);\n          g_file_replace_contents (commitpartial, \"\", 0, NULL, FALSE, G_FILE_CREATE_REPLACE_DESTINATION, NULL, NULL, NULL);\n        }\n    }\n  return g_steal_pointer (&repo);\n}\n\nstatic OstreeRepo *\nflatpak_dir_create_system_child_repo (FlatpakDir   *self,\n                                      GLnxLockFile *file_lock,\n                                      const char   *optional_commit,\n                                      GError      **error)\n{\n  g_autoptr(GFile) cache_dir = NULL;\n\n  g_assert (!self->user);\n\n  cache_dir = flatpak_ensure_system_user_cache_dir_location (error);\n  if (cache_dir == NULL)\n    return NULL;\n\n  return flatpak_dir_create_child_repo (self, cache_dir, file_lock, optional_commit, error);\n}\n\nstatic gboolean\nflatpak_dir_setup_revokefs_fuse_mount (FlatpakDir    *self,\n                                       FlatpakDecomposed *ref,\n                                       const gchar   *installation,\n                                       gchar        **out_src_dir,\n                                       gchar        **out_mnt_dir,\n                                       GCancellable  *cancellable)\n{\n  g_autoptr (GError) local_error = NULL;\n  g_autofree gchar *src_dir_tmp = NULL;\n  g_autofree gchar *mnt_dir_tmp = NULL;\n  gint socket = -1;\n  gboolean res = FALSE;\n  const char *revokefs_fuse_bin = LIBEXECDIR \"/revokefs-fuse\";\n\n  if (g_getenv (\"FLATPAK_REVOKEFS_FUSE\"))\n    revokefs_fuse_bin = g_getenv (\"FLATPAK_REVOKEFS_FUSE\");\n\n  if (!flatpak_dir_system_helper_call_get_revokefs_fd (self,\n                                                       FLATPAK_HELPER_GET_REVOKEFS_FD_FLAGS_NONE,\n                                                       installation ? installation : \"\",\n                                                       &socket,\n                                                       &src_dir_tmp,\n                                                       cancellable,\n                                                       &local_error))\n    {\n      if (g_error_matches (local_error, G_DBUS_ERROR, G_DBUS_ERROR_NOT_SUPPORTED))\n        g_debug (\"revokefs-fuse not supported on your installation: %s\", local_error->message);\n      else\n        g_warning (\"Failed to get revokefs-fuse socket from system-helper: %s\", local_error->message);\n\n      goto out;\n    }\n  else\n    {\n      g_autoptr(GSubprocess) revokefs_fuse = NULL;\n      g_autoptr(GSubprocessLauncher) launcher = NULL;\n      g_autofree gchar *client_uid = NULL;\n\n      mnt_dir_tmp = flatpak_dir_revokefs_fuse_create_mountpoint (ref, &local_error);\n      if (mnt_dir_tmp == NULL)\n        {\n          g_warning (\"Failed to create a mountpoint for revokefs-fuse: %s\", local_error->message);\n          close (socket);\n          goto out;\n        }\n\n      client_uid = g_strdup_printf (\"uid=%d\", getuid ());\n      launcher = g_subprocess_launcher_new (G_SUBPROCESS_FLAGS_NONE);\n      g_subprocess_launcher_take_fd (launcher, socket, 3);\n      revokefs_fuse = g_subprocess_launcher_spawn (launcher,\n                                                   &local_error,\n                                                   revokefs_fuse_bin, \"-o\", client_uid, \"--socket=3\",\n                                                   src_dir_tmp, mnt_dir_tmp, NULL);\n      if (revokefs_fuse == NULL ||\n          !g_subprocess_wait_check (revokefs_fuse, NULL, &local_error))\n        {\n          g_warning (\"Error spawning revokefs-fuse: %s\", local_error->message);\n          close (socket);\n          goto out;\n        }\n    }\n\n  res = TRUE;\n\nout:\n  /* It is unconventional to steal these values on error. However, it depends on where\n   * this function failed. If we are able to spawn the revokefs backend (src_dir_tmp\n   * is non-NULL) but failed to create mountpoint or spawning revokefs-fuse here,\n   * we  still need the src_dir_tmp value to cleanup the revokefs backend properly\n   * through the system-helper's CancelPull(). Hence, always stealing values can tell\n   * the caller under what circumstances this function failed and cleanup accordingly. */\n  *out_mnt_dir = g_steal_pointer (&mnt_dir_tmp);\n  *out_src_dir = g_steal_pointer (&src_dir_tmp);\n\n  return res;\n}\n\nstatic void\nflatpak_dir_unmount_and_cancel_pull (FlatpakDir    *self,\n                                     guint          arg_flags,\n                                     GCancellable  *cancellable,\n                                     OstreeRepo   **repo,\n                                     GLnxLockFile  *lockfile,\n                                     const char    *mnt_dir,\n                                     const char    *src_dir)\n{\n  const char *installation = flatpak_dir_get_id (self);\n  g_autoptr(GError) error = NULL;\n\n  if (mnt_dir &&\n      !flatpak_dir_revokefs_fuse_unmount (repo, lockfile, mnt_dir, &error))\n    g_warning (\"Could not unmount revokefs-fuse filesystem at %s: %s\", mnt_dir, error->message);\n\n  g_clear_error (&error);\n\n  if (src_dir &&\n      !flatpak_dir_system_helper_call_cancel_pull (self,\n                                                   arg_flags,\n                                                   installation ? installation : \"\",\n                                                   src_dir, cancellable, &error))\n    g_warning (\"Error cancelling ongoing pull at %s: %s\", src_dir, error->message);\n}\n\ngboolean\nflatpak_dir_install (FlatpakDir          *self,\n                     gboolean             no_pull,\n                     gboolean             no_deploy,\n                     gboolean             no_static_deltas,\n                     gboolean             reinstall,\n                     gboolean             app_hint,\n                     FlatpakRemoteState  *state,\n                     FlatpakDecomposed   *ref,\n                     const char          *opt_commit,\n                     const char         **opt_subpaths,\n                     const char         **opt_previous_ids,\n                     GFile               *sideload_repo,\n                     GBytes              *require_metadata,\n                     const char          *token,\n                     FlatpakProgress     *progress,\n                     GCancellable        *cancellable,\n                     GError             **error)\n{\n  FlatpakPullFlags flatpak_flags;\n\n  flatpak_flags = FLATPAK_PULL_FLAGS_DOWNLOAD_EXTRA_DATA;\n  if (no_static_deltas)\n    flatpak_flags |= FLATPAK_PULL_FLAGS_NO_STATIC_DELTAS;\n\n  if (flatpak_dir_use_system_helper (self, NULL))\n    {\n      g_autoptr(OstreeRepo) child_repo = NULL;\n      g_auto(GLnxLockFile) child_repo_lock = { 0, };\n      const char *installation = flatpak_dir_get_id (self);\n      const char *empty_subpaths[] = {NULL};\n      const char **subpaths;\n      g_autofree char *child_repo_path = NULL;\n      FlatpakHelperDeployFlags helper_flags = 0;\n      g_autofree char *url = NULL;\n      gboolean gpg_verify_summary;\n      gboolean gpg_verify;\n      gboolean is_oci;\n      gboolean is_revokefs_pull = FALSE;\n\n      if (opt_subpaths)\n        subpaths = opt_subpaths;\n      else\n        subpaths = empty_subpaths;\n\n      if (!ostree_repo_remote_get_url (self->repo,\n                                       state->remote_name,\n                                       &url,\n                                       error))\n        return FALSE;\n\n      if (!ostree_repo_remote_get_gpg_verify_summary (self->repo, state->remote_name,\n                                                      &gpg_verify_summary, error))\n        return FALSE;\n\n      if (!ostree_repo_remote_get_gpg_verify (self->repo, state->remote_name,\n                                              &gpg_verify, error))\n        return FALSE;\n\n      is_oci = flatpak_dir_get_remote_oci (self, state->remote_name);\n      if (no_pull)\n        {\n          /* Do nothing */\n        }\n      else if (is_oci)\n        {\n          g_autoptr(FlatpakOciRegistry) registry = NULL;\n          g_autoptr(GFile) registry_file = NULL;\n\n          registry = flatpak_dir_create_system_child_oci_registry (self, &child_repo_lock, token, error);\n          if (registry == NULL)\n            return FALSE;\n\n          registry_file = g_file_new_for_uri (flatpak_oci_registry_get_uri (registry));\n\n          child_repo_path = g_file_get_path (registry_file);\n\n          if (!flatpak_dir_mirror_oci (self, registry, state, flatpak_decomposed_get_ref (ref), opt_commit, NULL, token, progress, cancellable, error))\n            return FALSE;\n        }\n      else if (!gpg_verify_summary || !gpg_verify)\n        {\n          /* The remote is not gpg verified, so we don't want to allow installation via\n             a download in the home directory, as there is no way to verify you're not\n             injecting anything into the remote. However, in the case of a remote\n             configured to a local filesystem we can just let the system helper do\n             the installation, as it can then avoid network i/o and be certain the\n             data comes from the right place. */\n          if (g_str_has_prefix (url, \"file:\"))\n            helper_flags |= FLATPAK_HELPER_DEPLOY_FLAGS_LOCAL_PULL;\n          else\n            return flatpak_fail_error (error, FLATPAK_ERROR_UNTRUSTED, _(\"Can't pull from untrusted non-gpg verified remote\"));\n        }\n      else\n        {\n          /* For system pulls, the pull has to be made in a child repo first,\n             which is then pulled into the system's one. The pull from child\n             repo into the system repo can occur in one of the two following ways:\n                1) Hard-link the child repo into system's one.\n                2) Copy and verify each object from the child repo to the system's one.\n\n             2) poses the problem of using double disk-space which might fail the\n             installation of very big applications. For e.g. at endless, the encyclopedia app\n             is about ~6GB, hence ~12GB of free disk-space is required to get it installed.\n\n             For 1), we need to make sure that we address all the security concerns that\n             might escalate during the pull from a remote into child repo and subsequently,\n             hard-linking it into the (root-owned)system repo. This is taken care of by a\n             special FUSE process(revokefs-fuse) which guards all the writes made to the\n             child repo and ensures that no file descriptors remain open to the child repo\n             before the hard-linkable pull is made into the system's repo.\n             More details about the security issues dealt here are present at\n             https://github.com/flatpak/flatpak/wiki/Noncopying-system-app-installation\n\n             In case we fail to apply pull approach 1), the pull automatically fallbacks to use 2). */\n          g_autofree gchar *src_dir = NULL;\n          g_autofree gchar *mnt_dir = NULL;\n          g_autoptr(GError) local_error = NULL;\n\n          if (!flatpak_dir_setup_revokefs_fuse_mount (self,\n                                                      ref,\n                                                      installation,\n                                                      &src_dir, &mnt_dir,\n                                                      cancellable))\n            {\n              flatpak_dir_unmount_and_cancel_pull (self, FLATPAK_HELPER_CANCEL_PULL_FLAGS_NONE,\n                                                   cancellable,\n                                                   &child_repo, &child_repo_lock,\n                                                   mnt_dir, src_dir);\n            }\n          else\n            {\n              g_autofree gchar *repo_basename = NULL;\n              g_autoptr(GFile) mnt_dir_file = NULL;\n\n              mnt_dir_file = g_file_new_for_path (mnt_dir);\n              child_repo = flatpak_dir_create_child_repo (self, mnt_dir_file, &child_repo_lock, opt_commit, &local_error);\n              if (child_repo == NULL)\n                {\n                  g_warning (\"Cannot create repo on revokefs mountpoint %s: %s\", mnt_dir, local_error->message);\n                  flatpak_dir_unmount_and_cancel_pull (self,\n                                                       FLATPAK_HELPER_CANCEL_PULL_FLAGS_NONE,\n                                                       cancellable,\n                                                       &child_repo, &child_repo_lock,\n                                                       mnt_dir, src_dir);\n                  g_clear_error (&local_error);\n                }\n              else\n                {\n                  repo_basename = g_file_get_basename (ostree_repo_get_path (child_repo));\n                  child_repo_path = g_build_filename (src_dir, repo_basename, NULL);\n                  is_revokefs_pull = TRUE;\n                }\n            }\n\n          /* Fallback if revokefs-fuse setup does not succeed. This makes the pull\n           * temporarily use double disk-space. */\n          if (!is_revokefs_pull)\n            {\n             /* We're pulling from a remote source, we do the network mirroring pull as a\n                user and hand back the resulting data to the system-helper, that trusts us\n                due to the GPG signatures in the repo */\n              child_repo = flatpak_dir_create_system_child_repo (self, &child_repo_lock, NULL, error);\n              if (child_repo == NULL)\n                return FALSE;\n              else\n                child_repo_path = g_file_get_path (ostree_repo_get_path (child_repo));\n            }\n\n          flatpak_flags |= FLATPAK_PULL_FLAGS_SIDELOAD_EXTRA_DATA;\n\n          if (!flatpak_dir_pull (self, state, flatpak_decomposed_get_ref (ref), opt_commit, subpaths, sideload_repo, require_metadata, token,\n                                 child_repo,\n                                 flatpak_flags,\n                                 0,\n                                 progress, cancellable, error))\n            {\n              if (is_revokefs_pull)\n                {\n                  flatpak_dir_unmount_and_cancel_pull (self,\n                                                       FLATPAK_HELPER_CANCEL_PULL_FLAGS_PRESERVE_PULL,\n                                                       cancellable,\n                                                       &child_repo, &child_repo_lock,\n                                                       mnt_dir, src_dir);\n                }\n\n              return FALSE;\n            }\n\n          g_assert (child_repo_path != NULL);\n\n          if (is_revokefs_pull &&\n              !flatpak_dir_revokefs_fuse_unmount (&child_repo, &child_repo_lock, mnt_dir, &local_error))\n            {\n              g_propagate_prefixed_error (error, g_steal_pointer (&local_error), \n                      _(\"Could not unmount revokefs-fuse filesystem at %s: \"), mnt_dir);\n\n              if (src_dir &&\n                  !flatpak_dir_system_helper_call_cancel_pull (self,\n                                                               FLATPAK_HELPER_CANCEL_PULL_FLAGS_PRESERVE_PULL,\n                                                               installation ? installation : \"\",\n                                                               src_dir, cancellable, &local_error))\n                g_warning (\"Error cancelling ongoing pull at %s: %s\", src_dir, local_error->message);\n              return FALSE;\n            }\n        }\n\n      if (no_deploy)\n        helper_flags |= FLATPAK_HELPER_DEPLOY_FLAGS_NO_DEPLOY;\n\n      if (reinstall)\n        helper_flags |= FLATPAK_HELPER_DEPLOY_FLAGS_REINSTALL;\n\n      if (app_hint)\n        helper_flags |= FLATPAK_HELPER_DEPLOY_FLAGS_APP_HINT;\n\n      helper_flags |= FLATPAK_HELPER_DEPLOY_FLAGS_INSTALL_HINT;\n\n      if (!flatpak_dir_system_helper_call_deploy (self,\n                                                  child_repo_path ? child_repo_path : \"\",\n                                                  helper_flags, flatpak_decomposed_get_ref (ref), state->remote_name,\n                                                  (const char * const *) subpaths,\n                                                  (const char * const *) opt_previous_ids,\n                                                  installation ? installation : \"\",\n                                                  cancellable,\n                                                  error))\n        return FALSE;\n\n      if (child_repo_path && !is_revokefs_pull)\n        (void) glnx_shutil_rm_rf_at (AT_FDCWD, child_repo_path, NULL, NULL);\n\n      return TRUE;\n    }\n\n  if (!no_pull)\n    {\n      if (!flatpak_dir_pull (self, state, flatpak_decomposed_get_ref (ref), opt_commit, opt_subpaths, sideload_repo, require_metadata, token, NULL,\n                             flatpak_flags, OSTREE_REPO_PULL_FLAGS_NONE,\n                             progress, cancellable, error))\n        return FALSE;\n    }\n\n  if (!no_deploy)\n    {\n      if (!flatpak_dir_deploy_install (self, ref, state->remote_name, opt_subpaths,\n                                       opt_previous_ids, reinstall, cancellable, error))\n        return FALSE;\n    }\n\n  return TRUE;\n}\n\nchar *\nflatpak_dir_ensure_bundle_remote (FlatpakDir         *self,\n                                  GFile              *file,\n                                  GBytes             *extra_gpg_data,\n                                  FlatpakDecomposed **out_ref,\n                                  char              **out_checksum,\n                                  char              **out_metadata,\n                                  gboolean           *out_created_remote,\n                                  GCancellable       *cancellable,\n                                  GError            **error)\n{\n  g_autoptr(FlatpakDecomposed) ref = NULL;\n  gboolean created_remote = FALSE;\n  g_autoptr(GBytes) deploy_data = NULL;\n  g_autoptr(GVariant) metadata = NULL;\n  g_autofree char *origin = NULL;\n  g_autofree char *fp_metadata = NULL;\n  g_autofree char *basename = NULL;\n  g_autoptr(GBytes) included_gpg_data = NULL;\n  GBytes *gpg_data = NULL;\n  g_autofree char *to_checksum = NULL;\n  g_autofree char *remote = NULL;\n  g_autofree char *collection_id = NULL;\n\n  if (!flatpak_dir_ensure_repo (self, cancellable, error))\n    return NULL;\n\n  metadata = flatpak_bundle_load (file, &to_checksum,\n                                  &ref,\n                                  &origin,\n                                  NULL, &fp_metadata, NULL,\n                                  &included_gpg_data,\n                                  &collection_id,\n                                  error);\n  if (metadata == NULL)\n    return NULL;\n\n  gpg_data = extra_gpg_data ? extra_gpg_data : included_gpg_data;\n\n  deploy_data = flatpak_dir_get_deploy_data (self, ref, FLATPAK_DEPLOY_VERSION_ANY, cancellable, NULL);\n  if (deploy_data != NULL)\n    {\n      remote = g_strdup (flatpak_deploy_data_get_origin (deploy_data));\n\n      /* We need to import any gpg keys because otherwise the pull will fail */\n      if (gpg_data != NULL)\n        {\n          g_autoptr(GKeyFile) new_config = NULL;\n\n          new_config = ostree_repo_copy_config (flatpak_dir_get_repo (self));\n\n          if (!flatpak_dir_modify_remote (self, remote, new_config,\n                                          gpg_data, cancellable, error))\n            return NULL;\n        }\n    }\n  else\n    {\n      g_autofree char *id = flatpak_decomposed_dup_id (ref);\n      /* Add a remote for later updates */\n      basename = g_file_get_basename (file);\n      remote = flatpak_dir_create_origin_remote (self,\n                                                 origin,\n                                                 id,\n                                                 basename,\n                                                 flatpak_decomposed_get_ref (ref),\n                                                 gpg_data,\n                                                 collection_id,\n                                                 &created_remote,\n                                                 cancellable,\n                                                 error);\n      if (remote == NULL)\n        return NULL;\n    }\n\n  if (out_created_remote)\n    *out_created_remote = created_remote;\n\n  if (out_ref)\n    *out_ref = g_steal_pointer (&ref);\n\n  if (out_checksum)\n    *out_checksum = g_steal_pointer (&to_checksum);\n\n  if (out_metadata)\n    *out_metadata = g_steal_pointer (&fp_metadata);\n\n\n  return g_steal_pointer (&remote);\n}\n\n/* If core.add-remotes-config-dir is set for this repository (which is\n * not a common configuration, but it is possible), we will fail to modify\n * remote configuration when using a combination of\n * ostree_repo_remote_[add|change]() and ostree_repo_write_config() due to\n * adding remote config in /etc/flatpak/remotes.d and also in\n * /ostree/repo/config. Avoid that.\n *\n * FIXME: See https://github.com/flatpak/flatpak/issues/1665. In future, we\n * should just write the remote config to the correct place, factoring\n * core.add-remotes-config-dir in. */\nstatic gboolean\nflatpak_dir_check_add_remotes_config_dir (FlatpakDir *self,\n                                          GError    **error)\n{\n  g_autoptr(GError) local_error = NULL;\n  gboolean val;\n  GKeyFile *config;\n\n  if (!flatpak_dir_maybe_ensure_repo (self, NULL, error))\n    return FALSE;\n\n  if (self->repo == NULL)\n    return TRUE;\n\n  config = ostree_repo_get_config (self->repo);\n\n  if (config == NULL)\n    return TRUE;\n\n  val = g_key_file_get_boolean (config, \"core\", \"add-remotes-config-dir\", &local_error);\n\n  if (local_error != NULL)\n    {\n      if (g_error_matches (local_error, G_KEY_FILE_ERROR, G_KEY_FILE_ERROR_KEY_NOT_FOUND))\n        {\n          g_clear_error (&local_error);\n          val = ostree_repo_is_system (self->repo);\n        }\n      else\n        {\n          g_propagate_error (error, g_steal_pointer (&local_error));\n          return FALSE;\n        }\n    }\n\n  if (!val)\n    return TRUE;\n\n  return flatpak_fail (error,\n                       \"Can\u2019t update remote configuration on a repository with \"\n                       \"core.add-remotes-config-dir=true\");\n}\n\ngboolean\nflatpak_dir_install_bundle (FlatpakDir         *self,\n                            GFile              *file,\n                            const char         *remote,\n                            FlatpakDecomposed **out_ref,\n                            GCancellable       *cancellable,\n                            GError            **error)\n{\n  g_autofree char *ref_str = NULL;\n  g_autoptr(FlatpakDecomposed) ref = NULL;\n  g_autoptr(GBytes) deploy_data = NULL;\n  g_autoptr(GVariant) metadata = NULL;\n  g_autofree char *origin = NULL;\n  g_autofree char *to_checksum = NULL;\n  gboolean gpg_verify;\n\n  if (!flatpak_dir_check_add_remotes_config_dir (self, error))\n    return FALSE;\n\n  if (flatpak_dir_use_system_helper (self, NULL))\n    {\n      const char *installation = flatpak_dir_get_id (self);\n\n      if (!flatpak_dir_system_helper_call_install_bundle (self,\n                                                          flatpak_file_get_path_cached (file),\n                                                          0, remote,\n                                                          installation ? installation : \"\",\n                                                          &ref_str,\n                                                          cancellable,\n                                                          error))\n        return FALSE;\n\n\n      ref = flatpak_decomposed_new_from_ref (ref_str, error);\n      if (ref == NULL)\n        return FALSE;\n\n      if (out_ref)\n        *out_ref = g_steal_pointer (&ref);\n\n      return TRUE;\n    }\n\n  if (!flatpak_dir_ensure_repo (self, cancellable, error))\n    return FALSE;\n\n  metadata = flatpak_bundle_load (file, &to_checksum,\n                                  &ref,\n                                  &origin,\n                                  NULL, NULL,\n                                  NULL, NULL, NULL,\n                                  error);\n  if (metadata == NULL)\n    return FALSE;\n\n  deploy_data = flatpak_dir_get_deploy_data (self, ref, FLATPAK_DEPLOY_VERSION_ANY, cancellable, NULL);\n  if (deploy_data != NULL)\n    {\n      if (strcmp (flatpak_deploy_data_get_commit (deploy_data), to_checksum) == 0)\n        {\n          g_autofree char *id = flatpak_decomposed_dup_id (ref);\n          g_set_error (error, FLATPAK_ERROR, FLATPAK_ERROR_ALREADY_INSTALLED,\n                       _(\"This version of %s is already installed\"), id);\n          return FALSE;\n        }\n\n      if (strcmp (remote, flatpak_deploy_data_get_origin (deploy_data)) != 0)\n        {\n          g_set_error (error, G_IO_ERROR, G_IO_ERROR_FAILED,\n                       _(\"Can't change remote during bundle install\"));\n          return FALSE;\n        }\n    }\n\n  if (!ostree_repo_remote_get_gpg_verify (self->repo, remote,\n                                          &gpg_verify, error))\n    return FALSE;\n\n  if (!flatpak_pull_from_bundle (self->repo,\n                                 file,\n                                 remote,\n                                 flatpak_decomposed_get_ref (ref),\n                                 gpg_verify,\n                                 cancellable,\n                                 error))\n    return FALSE;\n\n  if (deploy_data != NULL)\n    {\n      g_autofree char *group = g_strdup_printf (\"remote \\\"%s\\\"\", remote);\n      g_autofree char *old_url = NULL;\n      g_autoptr(GKeyFile) new_config = NULL;\n\n      /* The pull succeeded, and this is an update. So, we need to update the repo config\n         if anything changed */\n      ostree_repo_remote_get_url (self->repo,\n                                  remote,\n                                  &old_url,\n                                  NULL);\n      if (origin != NULL &&\n          (old_url == NULL || strcmp (old_url, origin) != 0))\n        {\n          if (new_config == NULL)\n            new_config = ostree_repo_copy_config (self->repo);\n\n          g_key_file_set_value (new_config, group, \"url\", origin);\n        }\n\n      if (new_config)\n        {\n          if (!flatpak_dir_cleanup_remote_for_url_change (self, remote,\n                                                          origin, cancellable, error))\n            return FALSE;\n\n          if (!ostree_repo_write_config (self->repo, new_config, error))\n            return FALSE;\n        }\n    }\n\n  if (deploy_data)\n    {\n      if (!flatpak_dir_deploy_update (self, ref, NULL, NULL, NULL, cancellable, error))\n        return FALSE;\n    }\n  else\n    {\n      if (!flatpak_dir_deploy_install (self, ref, remote, NULL, NULL, FALSE, cancellable, error))\n        return FALSE;\n    }\n\n  if (out_ref)\n    *out_ref = g_steal_pointer (&ref);\n\n  return TRUE;\n}\n\nstatic gboolean\n_g_strv_equal0 (gchar **a, gchar **b)\n{\n  gboolean ret = FALSE;\n  guint n;\n\n  if (a == NULL && b == NULL)\n    {\n      ret = TRUE;\n      goto out;\n    }\n  if (a == NULL || b == NULL)\n    goto out;\n  if (g_strv_length (a) != g_strv_length (b))\n    goto out;\n  for (n = 0; a[n] != NULL; n++)\n    if (g_strcmp0 (a[n], b[n]) != 0)\n      goto out;\n  ret = TRUE;\nout:\n  return ret;\n}\n\ngboolean\nflatpak_dir_needs_update_for_commit_and_subpaths (FlatpakDir        *self,\n                                                  const char        *remote,\n                                                  FlatpakDecomposed *ref,\n                                                  const char        *target_commit,\n                                                  const char       **opt_subpaths)\n{\n  g_autoptr(GBytes) deploy_data = NULL;\n  g_autofree const char **old_subpaths = NULL;\n  const char **subpaths;\n  g_autofree char *url = NULL;\n  const char *installed_commit;\n  const char *installed_alt_id;\n  const char *extension_of;\n\n  g_assert (target_commit != NULL);\n\n  /* Never update from disabled remotes */\n  if (!ostree_repo_remote_get_url (self->repo, remote, &url, NULL))\n    return FALSE;\n\n  if (*url == 0)\n    return FALSE;\n\n  /* deploy v4 guarantees alt-id/extension-of info */\n  deploy_data = flatpak_dir_get_deploy_data (self, ref, 4, NULL, NULL);\n  if (deploy_data != NULL)\n    old_subpaths = flatpak_deploy_data_get_subpaths (deploy_data);\n  else\n    old_subpaths = g_new0 (const char *, 1); /* Empty strv == all subpaths*/\n\n  if (opt_subpaths)\n    subpaths = opt_subpaths;\n  else\n    subpaths = old_subpaths;\n\n  /* Not deployed => need update */\n  if (deploy_data == NULL)\n    return TRUE;\n\n  /* If masked, don't update */\n  if (flatpak_dir_ref_is_masked (self, flatpak_decomposed_get_ref (ref)))\n    return FALSE;\n\n  extension_of = flatpak_deploy_data_get_extension_of (deploy_data);\n  /* If the main ref is masked, don't update extensions of it (like .Locale or .Debug) */\n  if (extension_of && flatpak_dir_ref_is_masked (self, extension_of))\n    return FALSE;\n\n  installed_commit = flatpak_deploy_data_get_commit (deploy_data);\n  installed_alt_id = flatpak_deploy_data_get_alt_id (deploy_data);\n\n  /* Different target commit than deployed => update */\n  if (g_strcmp0 (target_commit, installed_commit) != 0 &&\n      g_strcmp0 (target_commit, installed_alt_id) != 0)\n    return TRUE;\n\n  /* target commit is the same as current, but maybe something else that is different? */\n\n  /* Same commit, but different subpaths => update */\n  if (!_g_strv_equal0 ((char **) subpaths, (char **) old_subpaths))\n    return TRUE;\n\n  /* Same subpaths and commit, no need to update */\n  return FALSE;\n}\n\n/* This is called by the old-school non-transaction flatpak_installation_update, so doesn't do a lot. */\nchar *\nflatpak_dir_check_for_update (FlatpakDir               *self,\n                              FlatpakRemoteState       *state,\n                              FlatpakDecomposed        *ref,\n                              const char               *checksum_or_latest,\n                              const char              **opt_subpaths,\n                              gboolean                  no_pull,\n                              GCancellable             *cancellable,\n                              GError                  **error)\n{\n  g_autofree char *latest_rev = NULL;\n  const char *target_rev = NULL;\n\n  if (no_pull)\n    {\n      if (!flatpak_repo_resolve_rev (self->repo, NULL, state->remote_name,\n                                     flatpak_decomposed_get_ref (ref), FALSE, &latest_rev, NULL, NULL))\n        {\n          g_set_error (error, FLATPAK_ERROR, FLATPAK_ERROR_ALREADY_INSTALLED,\n                       _(\"%s already installed\"), flatpak_decomposed_get_ref (ref));\n          return NULL; /* No update, because nothing to update to */\n        }\n    }\n  else\n    {\n      if (!flatpak_dir_find_latest_rev (self, state, flatpak_decomposed_get_ref (ref), checksum_or_latest, &latest_rev,\n                                        NULL, NULL, cancellable, error))\n        return NULL;\n    }\n\n  if (checksum_or_latest != NULL)\n    target_rev = checksum_or_latest;\n  else\n    target_rev = latest_rev;\n\n  if (flatpak_dir_needs_update_for_commit_and_subpaths (self, state->remote_name, ref, target_rev, opt_subpaths))\n    return g_strdup (target_rev);\n\n  g_set_error (error, FLATPAK_ERROR, FLATPAK_ERROR_ALREADY_INSTALLED,\n               _(\"%s commit %s already installed\"), flatpak_decomposed_get_ref (ref), target_rev);\n  return NULL;\n}\n\ngboolean\nflatpak_dir_update (FlatpakDir                           *self,\n                    gboolean                              no_pull,\n                    gboolean                              no_deploy,\n                    gboolean                              no_static_deltas,\n                    gboolean                              allow_downgrade,\n                    gboolean                              app_hint,\n                    gboolean                              install_hint,\n                    FlatpakRemoteState                   *state,\n                    FlatpakDecomposed                    *ref,\n                    const char                           *commit,\n                    const char                          **opt_subpaths,\n                    const char                          **opt_previous_ids,\n                    GFile                                *sideload_repo,\n                    GBytes                               *require_metadata,\n                    const char                           *token,\n                    FlatpakProgress                      *progress,\n                    GCancellable                         *cancellable,\n                    GError                              **error)\n{\n  g_autoptr(GBytes) deploy_data = NULL;\n  const char **subpaths = NULL;\n  const char *empty_subpaths[] = {NULL};\n  g_autofree char *url = NULL;\n  FlatpakPullFlags flatpak_flags;\n  g_autofree const char **old_subpaths = NULL;\n  gboolean is_oci;\n\n  /* This is calculated in check_for_update */\n  g_assert (commit != NULL);\n\n  flatpak_flags = FLATPAK_PULL_FLAGS_DOWNLOAD_EXTRA_DATA;\n  if (allow_downgrade)\n    flatpak_flags |= FLATPAK_PULL_FLAGS_ALLOW_DOWNGRADE;\n  if (no_static_deltas)\n    flatpak_flags |= FLATPAK_PULL_FLAGS_NO_STATIC_DELTAS;\n\n  deploy_data = flatpak_dir_get_deploy_data (self, ref, FLATPAK_DEPLOY_VERSION_ANY,\n                                             cancellable, NULL);\n\n  if (deploy_data != NULL)\n    old_subpaths = flatpak_deploy_data_get_subpaths (deploy_data);\n\n  if (opt_subpaths)\n    subpaths = opt_subpaths;\n  else if (old_subpaths)\n    subpaths = old_subpaths;\n  else\n    subpaths = empty_subpaths;\n\n  if (!ostree_repo_remote_get_url (self->repo, state->remote_name, &url, error))\n    return FALSE;\n\n  if (*url == 0)\n    return TRUE; /* Empty URL => disabled */\n\n  is_oci = flatpak_dir_get_remote_oci (self, state->remote_name);\n\n  if (flatpak_dir_use_system_helper (self, NULL))\n    {\n      const char *installation = flatpak_dir_get_id (self);\n      g_autoptr(OstreeRepo) child_repo = NULL;\n      g_auto(GLnxLockFile) child_repo_lock = { 0, };\n      g_autofree char *child_repo_path = NULL;\n      FlatpakHelperDeployFlags helper_flags = 0;\n      gboolean gpg_verify_summary;\n      gboolean gpg_verify;\n      gboolean is_revokefs_pull = FALSE;\n\n      if (allow_downgrade)\n        return flatpak_fail_error (error, FLATPAK_ERROR_DOWNGRADE,\n                                   _(\"Can't update to a specific commit without root permissions\"));\n\n      helper_flags = FLATPAK_HELPER_DEPLOY_FLAGS_UPDATE;\n\n      if (!ostree_repo_remote_get_gpg_verify_summary (self->repo, state->remote_name,\n                                                      &gpg_verify_summary, error))\n        return FALSE;\n\n      if (!ostree_repo_remote_get_gpg_verify (self->repo, state->remote_name,\n                                              &gpg_verify, error))\n        return FALSE;\n\n      if (no_pull)\n        {\n          /* Nothing to do here */\n        }\n      else if (is_oci)\n        {\n          g_autoptr(FlatpakOciRegistry) registry = NULL;\n          g_autoptr(GFile) registry_file = NULL;\n\n          registry = flatpak_dir_create_system_child_oci_registry (self, &child_repo_lock, token, error);\n          if (registry == NULL)\n            return FALSE;\n\n          registry_file = g_file_new_for_uri (flatpak_oci_registry_get_uri (registry));\n\n          child_repo_path = g_file_get_path (registry_file);\n\n          if (!flatpak_dir_mirror_oci (self, registry, state, flatpak_decomposed_get_ref (ref),\n                                       commit, NULL, token, progress, cancellable, error))\n            return FALSE;\n        }\n      else if (!gpg_verify_summary || !gpg_verify)\n        {\n          /* The remote is not gpg verified, so we don't want to allow installation via\n             a download in the home directory, as there is no way to verify you're not\n             injecting anything into the remote. However, in the case of a remote\n             configured to a local filesystem we can just let the system helper do\n             the installation, as it can then avoid network i/o and be certain the\n             data comes from the right place.\n\n             If @collection_id is non-%NULL, we can verify the refs in commit\n             metadata, so don\u2019t need to verify the summary. */\n          if (g_str_has_prefix (url, \"file:\"))\n            helper_flags |= FLATPAK_HELPER_DEPLOY_FLAGS_LOCAL_PULL;\n          else\n            return flatpak_fail_error (error, FLATPAK_ERROR_UNTRUSTED, _(\"Can't pull from untrusted non-gpg verified remote\"));\n        }\n      else\n        {\n          /* First try to update using revokefs-fuse codepath. If it fails, try to update using a\n           * temporary child-repo. Read flatpak_dir_install for more details on using revokefs-fuse */\n          g_autofree gchar *src_dir = NULL;\n          g_autofree gchar *mnt_dir = NULL;\n          g_autoptr(GError) local_error = NULL;\n\n          if (!flatpak_dir_setup_revokefs_fuse_mount (self,\n                                                      ref,\n                                                      installation,\n                                                      &src_dir, &mnt_dir,\n                                                      cancellable))\n            {\n              flatpak_dir_unmount_and_cancel_pull (self, FLATPAK_HELPER_CANCEL_PULL_FLAGS_NONE,\n                                                   cancellable,\n                                                   &child_repo, &child_repo_lock,\n                                                   mnt_dir, src_dir);\n            }\n          else\n            {\n              g_autofree gchar *repo_basename = NULL;\n              g_autoptr(GFile) mnt_dir_file = NULL;\n\n              mnt_dir_file = g_file_new_for_path (mnt_dir);\n              child_repo = flatpak_dir_create_child_repo (self, mnt_dir_file, &child_repo_lock, commit, &local_error);\n              if (child_repo == NULL)\n                {\n                  g_warning (\"Cannot create repo on revokefs mountpoint %s: %s\", mnt_dir, local_error->message);\n                  flatpak_dir_unmount_and_cancel_pull (self,\n                                                       FLATPAK_HELPER_CANCEL_PULL_FLAGS_NONE,\n                                                       cancellable,\n                                                       &child_repo, &child_repo_lock,\n                                                       mnt_dir, src_dir);\n                  g_clear_error (&local_error);\n                }\n              else\n                {\n                  repo_basename = g_file_get_basename (ostree_repo_get_path (child_repo));\n                  child_repo_path = g_build_filename (src_dir, repo_basename, NULL);\n                  is_revokefs_pull = TRUE;\n                }\n            }\n\n          /* Fallback if revokefs-fuse setup does not succeed. This makes the pull\n           * temporarily use double disk-space. */\n          if (!is_revokefs_pull)\n            {\n              /* We're pulling from a remote source, we do the network mirroring pull as a\n                 user and hand back the resulting data to the system-helper, that trusts us\n                 due to the GPG signatures in the repo */\n\n              child_repo = flatpak_dir_create_system_child_repo (self, &child_repo_lock, commit, error);\n              if (child_repo == NULL)\n                return FALSE;\n              else\n                child_repo_path = g_file_get_path (ostree_repo_get_path (child_repo));\n            }\n\n          flatpak_flags |= FLATPAK_PULL_FLAGS_SIDELOAD_EXTRA_DATA;\n          if (!flatpak_dir_pull (self, state, flatpak_decomposed_get_ref (ref),\n                                 commit, subpaths, sideload_repo, require_metadata, token,\n                                 child_repo,\n                                 flatpak_flags, 0,\n                                 progress, cancellable, error))\n            {\n              if (is_revokefs_pull)\n                {\n                  flatpak_dir_unmount_and_cancel_pull (self,\n                                                       FLATPAK_HELPER_CANCEL_PULL_FLAGS_PRESERVE_PULL,\n                                                       cancellable,\n                                                       &child_repo, &child_repo_lock,\n                                                       mnt_dir, src_dir);\n                }\n\n              return FALSE;\n            }\n\n          g_assert (child_repo_path != NULL);\n\n          if (is_revokefs_pull &&\n              !flatpak_dir_revokefs_fuse_unmount (&child_repo, &child_repo_lock, mnt_dir, &local_error))\n            {\n              g_warning (\"Could not unmount revokefs-fuse filesystem at %s: %s\", mnt_dir, local_error->message);\n              flatpak_dir_unmount_and_cancel_pull (self,\n                                                   FLATPAK_HELPER_CANCEL_PULL_FLAGS_PRESERVE_PULL,\n                                                   cancellable,\n                                                   &child_repo, &child_repo_lock,\n                                                   mnt_dir, src_dir);\n              return FALSE;\n            }\n        }\n\n      if (no_deploy)\n        helper_flags |= FLATPAK_HELPER_DEPLOY_FLAGS_NO_DEPLOY;\n\n      if (app_hint)\n        helper_flags |= FLATPAK_HELPER_DEPLOY_FLAGS_APP_HINT;\n\n      if (install_hint)\n        helper_flags |= FLATPAK_HELPER_DEPLOY_FLAGS_INSTALL_HINT;\n\n      if (!flatpak_dir_system_helper_call_deploy (self,\n                                                  child_repo_path ? child_repo_path : \"\",\n                                                  helper_flags, flatpak_decomposed_get_ref (ref), state->remote_name,\n                                                  subpaths, opt_previous_ids,\n                                                  installation ? installation : \"\",\n                                                  cancellable,\n                                                  error))\n        return FALSE;\n\n      if (child_repo_path && !is_revokefs_pull)\n        (void) glnx_shutil_rm_rf_at (AT_FDCWD, child_repo_path, NULL, NULL);\n\n      return TRUE;\n    }\n\n  if (!no_pull)\n    {\n      if (!flatpak_dir_pull (self, state, flatpak_decomposed_get_ref (ref),\n                             commit, subpaths, sideload_repo, require_metadata, token,\n                             NULL, flatpak_flags, OSTREE_REPO_PULL_FLAGS_NONE,\n                             progress, cancellable, error))\n        return FALSE;\n\n      /* Take this opportunity to clean up refs/mirrors/ since a prune will happen\n       * after this update operation. See\n       * https://github.com/flatpak/flatpak/issues/3222\n       * Note: For the system-helper case we do this in handle_deploy()\n       */\n      if (!flatpak_dir_delete_mirror_refs (self, FALSE, cancellable, error))\n        return FALSE;\n    }\n\n  if (!no_deploy)\n    {\n      if (!flatpak_dir_deploy_update (self, ref,\n                                      /* We don't know the local commit id in the OCI case, and\n                                         we only support one version anyway */\n                                      is_oci ? NULL : commit,\n                                      subpaths, opt_previous_ids,\n                                      cancellable, error))\n        return FALSE;\n    }\n\n  return TRUE;\n}\n\ngboolean\nflatpak_dir_uninstall (FlatpakDir                 *self,\n                       FlatpakDecomposed          *ref,\n                       FlatpakHelperUninstallFlags flags,\n                       GCancellable               *cancellable,\n                       GError                    **error)\n{\n  const char *repository;\n  g_autoptr(FlatpakDecomposed) current_ref = NULL;\n  gboolean was_deployed;\n  g_autofree char *name = NULL;\n  g_autofree char *old_active = NULL;\n  g_auto(GLnxLockFile) lock = { 0, };\n  g_autoptr(GBytes) deploy_data = NULL;\n  gboolean keep_ref = flags & FLATPAK_HELPER_UNINSTALL_FLAGS_KEEP_REF;\n  gboolean force_remove = flags & FLATPAK_HELPER_UNINSTALL_FLAGS_FORCE_REMOVE;\n\n  name = flatpak_decomposed_dup_id (ref);\n\n  if (flatpak_dir_use_system_helper (self, NULL))\n    {\n      const char *installation = flatpak_dir_get_id (self);\n\n      if (!flatpak_dir_system_helper_call_uninstall (self,\n                                                     flags, flatpak_decomposed_get_ref (ref),\n                                                     installation ? installation : \"\",\n                                                     cancellable, error))\n        return FALSE;\n\n      return TRUE;\n    }\n\n  if (!flatpak_dir_lock (self, &lock,\n                         cancellable, error))\n    return FALSE;\n\n  deploy_data = flatpak_dir_get_deploy_data (self, ref, FLATPAK_DEPLOY_VERSION_ANY,\n                                             cancellable, error);\n  if (deploy_data == NULL)\n    return FALSE;\n\n  /* Note: the origin remote usually exists but it's not guaranteed (the user\n   * could have run remote-delete --force) */\n  repository = flatpak_deploy_data_get_origin (deploy_data);\n  if (repository == NULL)\n    return FALSE;\n\n  if (flatpak_decomposed_is_runtime (ref) && !force_remove)\n    {\n      g_autoptr(GPtrArray) blocking = NULL;\n\n      /* Look for apps that need this runtime */\n      blocking = flatpak_dir_list_app_refs_with_runtime (self, ref, cancellable, error);\n      if (blocking == NULL)\n        return FALSE;\n\n      if (blocking->len > 0)\n        {\n          g_autoptr(GString) joined = g_string_new (\"\");\n          for (int i = 0; i < blocking->len; i++)\n            {\n              FlatpakDecomposed *blocking_ref = g_ptr_array_index (blocking, i);\n              g_autofree char *id = flatpak_decomposed_dup_id (blocking_ref);\n              if (i != 0)\n                g_string_append (joined, \", \");\n              g_string_append (joined, id);\n            }\n\n          return flatpak_fail_error (error, FLATPAK_ERROR_RUNTIME_USED,\n                                     _(\"Can't remove %s, it is needed for: %s\"), flatpak_decomposed_get_pref (ref), joined->str);\n        }\n    }\n\n  old_active = g_strdup (flatpak_deploy_data_get_commit (deploy_data));\n\n  g_debug (\"dropping active ref\");\n  if (!flatpak_dir_set_active (self, ref, NULL, cancellable, error))\n    return FALSE;\n\n  if (flatpak_decomposed_is_app (ref))\n    {\n      current_ref = flatpak_dir_current_ref (self, name, cancellable);\n      if (current_ref != NULL &&\n          flatpak_decomposed_equal (ref, current_ref))\n        {\n          g_debug (\"dropping current ref\");\n          if (!flatpak_dir_drop_current_ref (self, name, cancellable, error))\n            return FALSE;\n        }\n    }\n\n  if (!flatpak_dir_update_deploy_ref (self, flatpak_decomposed_get_ref (ref), NULL, error))\n    return FALSE;\n\n  if (!flatpak_dir_undeploy_all (self, ref, force_remove, &was_deployed, cancellable, error))\n    return FALSE;\n\n  if (!keep_ref &&\n      !flatpak_dir_remove_ref (self, repository, flatpak_decomposed_get_ref (ref), cancellable, error))\n    return FALSE;\n\n  /* Take this opportunity to clean up refs/mirrors/ since a prune will happen\n   * after this uninstall operation. See\n   * https://github.com/flatpak/flatpak/issues/3222\n   */\n  if (!flatpak_dir_delete_mirror_refs (self, FALSE, cancellable, error))\n    return FALSE;\n\n  if (flatpak_decomposed_is_app (ref) &&\n      !flatpak_dir_update_exports (self, name, cancellable, error))\n    return FALSE;\n\n  glnx_release_lock_file (&lock);\n\n  flatpak_dir_prune_origin_remote (self, repository);\n\n  flatpak_dir_cleanup_removed (self, cancellable, NULL);\n\n  if (!flatpak_dir_mark_changed (self, error))\n    return FALSE;\n\n  if (!was_deployed)\n    {\n      const char *branch = flatpak_decomposed_get_branch (ref);\n      g_set_error (error, FLATPAK_ERROR, FLATPAK_ERROR_NOT_INSTALLED,\n                   _(\"%s branch %s is not installed\"), name, branch);\n      return FALSE;\n    }\n\n  flatpak_dir_log (self, \"uninstall\", NULL, flatpak_decomposed_get_ref (ref), NULL, old_active, NULL,\n                   \"Uninstalled %s\", flatpak_decomposed_get_ref (ref));\n\n  return TRUE;\n}\n\ngboolean\nflatpak_dir_collect_deployed_refs (FlatpakDir   *self,\n                                   const char   *type,\n                                   const char   *name_prefix,\n                                   const char   *arch,\n                                   const char   *branch,\n                                   GHashTable   *hash,\n                                   GCancellable *cancellable,\n                                   GError      **error)\n{\n  gboolean ret = FALSE;\n  g_autoptr(GFile) dir = NULL;\n  g_autoptr(GFileEnumerator) dir_enum = NULL;\n  g_autoptr(GFileInfo) child_info = NULL;\n  GError *temp_error = NULL;\n  FlatpakKinds kind;\n\n  if (strcmp (type, \"app\") == 0)\n    kind = FLATPAK_KINDS_APP;\n  else\n    kind = FLATPAK_KINDS_RUNTIME;\n\n  dir = g_file_get_child (self->basedir, type);\n  if (!g_file_query_exists (dir, cancellable))\n    return TRUE;\n\n  dir_enum = g_file_enumerate_children (dir, OSTREE_GIO_FAST_QUERYINFO,\n                                        G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n                                        cancellable,\n                                        error);\n  if (!dir_enum)\n    goto out;\n\n  while ((child_info = g_file_enumerator_next_file (dir_enum, cancellable, &temp_error)) != NULL)\n    {\n      const char *name = g_file_info_get_name (child_info);\n\n      if (g_file_info_get_file_type (child_info) == G_FILE_TYPE_DIRECTORY &&\n          name[0] != '.' && (name_prefix == NULL || g_str_has_prefix (name, name_prefix)))\n        {\n          g_autoptr(GFile) child1 = g_file_get_child (dir, name);\n          g_autoptr(GFile) child2 = g_file_get_child (child1, arch);\n          g_autoptr(GFile) child3 = g_file_get_child (child2, branch);\n          g_autoptr(GFile) active = g_file_get_child (child3, \"active\");\n\n          if (g_file_query_exists (active, cancellable))\n            {\n              FlatpakDecomposed *ref = flatpak_decomposed_new_from_parts (kind, name, arch, branch, NULL);\n              if (ref)\n                g_hash_table_add (hash, ref);\n            }\n        }\n\n      g_clear_object (&child_info);\n    }\n\n  if (temp_error != NULL)\n    {\n      g_propagate_error (error, temp_error);\n      goto out;\n    }\n\n  ret = TRUE;\nout:\n  return ret;\n}\n\ngboolean\nflatpak_dir_collect_unmaintained_refs (FlatpakDir   *self,\n                                       const char   *name_prefix,\n                                       const char   *arch,\n                                       const char   *branch,\n                                       GHashTable   *hash,\n                                       GCancellable *cancellable,\n                                       GError      **error)\n{\n  gboolean ret = FALSE;\n  g_autoptr(GFile) unmaintained_dir = NULL;\n  g_autoptr(GFileEnumerator) unmaintained_dir_enum = NULL;\n  g_autoptr(GFileInfo) child_info = NULL;\n  GError *temp_error = NULL;\n\n  unmaintained_dir = g_file_get_child (self->basedir, \"extension\");\n  if (!g_file_query_exists (unmaintained_dir, cancellable))\n    return TRUE;\n\n  unmaintained_dir_enum = g_file_enumerate_children (unmaintained_dir, G_FILE_ATTRIBUTE_STANDARD_NAME,\n                                                     G_FILE_QUERY_INFO_NONE,\n                                                     cancellable,\n                                                     error);\n  if (!unmaintained_dir_enum)\n    goto out;\n\n  while ((child_info = g_file_enumerator_next_file (unmaintained_dir_enum, cancellable, &temp_error)) != NULL)\n    {\n      const char *name = g_file_info_get_name (child_info);\n\n      if (g_file_info_get_file_type (child_info) == G_FILE_TYPE_DIRECTORY &&\n          name[0] != '.' && (name_prefix == NULL || g_str_has_prefix (name, name_prefix)))\n        {\n          g_autoptr(GFile) child1 = g_file_get_child (unmaintained_dir, name);\n          g_autoptr(GFile) child2 = g_file_get_child (child1, arch);\n          g_autoptr(GFile) child3 = g_file_get_child (child2, branch);\n\n          if (g_file_query_exists (child3, cancellable))\n            g_hash_table_add (hash, g_strdup (name));\n        }\n\n      g_clear_object (&child_info);\n    }\n\n  if (temp_error != NULL)\n    {\n      g_propagate_error (error, temp_error);\n      goto out;\n    }\n\n  ret = TRUE;\nout:\n  return ret;\n}\n\ngboolean\nflatpak_dir_list_deployed (FlatpakDir        *self,\n                           FlatpakDecomposed *ref,\n                           char            ***deployed_ids,\n                           GCancellable      *cancellable,\n                           GError           **error)\n{\n  gboolean ret = FALSE;\n  g_autoptr(GFile) deploy_base = NULL;\n  g_autoptr(GPtrArray) ids = NULL;\n  GError *temp_error = NULL;\n  g_autoptr(GFileEnumerator) dir_enum = NULL;\n  g_autoptr(GFile) child = NULL;\n  g_autoptr(GFileInfo) child_info = NULL;\n  g_autoptr(GError) my_error = NULL;\n\n  deploy_base = flatpak_dir_get_deploy_dir (self, ref);\n\n  ids = g_ptr_array_new_with_free_func (g_free);\n\n  dir_enum = g_file_enumerate_children (deploy_base, OSTREE_GIO_FAST_QUERYINFO,\n                                        G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n                                        cancellable,\n                                        &my_error);\n  if (!dir_enum)\n    {\n      if (g_error_matches (my_error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND))\n        ret = TRUE; /* Success, but empty */\n      else\n        g_propagate_error (error, g_steal_pointer (&my_error));\n      goto out;\n    }\n\n  while ((child_info = g_file_enumerator_next_file (dir_enum, cancellable, &temp_error)) != NULL)\n    {\n      const char *name;\n\n      name = g_file_info_get_name (child_info);\n\n      g_clear_object (&child);\n      child = g_file_get_child (deploy_base, name);\n\n      if (g_file_info_get_file_type (child_info) == G_FILE_TYPE_DIRECTORY &&\n          name[0] != '.' &&\n          strlen (name) == 64)\n        g_ptr_array_add (ids, g_strdup (name));\n\n      g_clear_object (&child_info);\n    }\n\n  if (temp_error != NULL)\n    {\n      g_propagate_error (error, temp_error);\n      goto out;\n    }\n\n  ret = TRUE;\n\nout:\n  if (ret)\n    {\n      g_ptr_array_add (ids, NULL);\n      *deployed_ids = (char **) g_ptr_array_free (g_steal_pointer (&ids), FALSE);\n    }\n\n  return ret;\n}\n\nstatic gboolean\ndir_is_locked (GFile *dir)\n{\n  glnx_autofd int ref_fd = -1;\n  struct flock lock = {0};\n  g_autoptr(GFile) reffile = NULL;\n\n  reffile = g_file_resolve_relative_path (dir, \"files/.ref\");\n\n  ref_fd = open (flatpak_file_get_path_cached (reffile), O_RDWR | O_CLOEXEC);\n  if (ref_fd != -1)\n    {\n      lock.l_type = F_WRLCK;\n      lock.l_whence = SEEK_SET;\n      lock.l_start = 0;\n      lock.l_len = 0;\n\n      if (fcntl (ref_fd, F_GETLK, &lock) == 0)\n        return lock.l_type != F_UNLCK;\n    }\n\n  return FALSE;\n}\n\ngboolean\nflatpak_dir_undeploy (FlatpakDir        *self,\n                      FlatpakDecomposed *ref,\n                      const char        *active_id,\n                      gboolean           is_update,\n                      gboolean           force_remove,\n                      GCancellable      *cancellable,\n                      GError           **error)\n{\n  g_autoptr(GFile) deploy_base = NULL;\n  g_autoptr(GFile) checkoutdir = NULL;\n  g_autoptr(GFile) removed_subdir = NULL;\n  g_autoptr(GFile) removed_dir = NULL;\n  g_autofree char *id = NULL;\n  g_autofree char *dirname = NULL;\n  g_autofree char *current_active = NULL;\n  g_autoptr(GFile) change_file = NULL;\n  g_autoptr(GError) child_error = NULL;\n  int i, retry;\n\n  g_assert (ref != NULL);\n  g_assert (active_id != NULL);\n\n  deploy_base = flatpak_dir_get_deploy_dir (self, ref);\n\n  checkoutdir = g_file_get_child (deploy_base, active_id);\n  if (!g_file_query_exists (checkoutdir, cancellable))\n    {\n      g_set_error (error, FLATPAK_ERROR, FLATPAK_ERROR_NOT_INSTALLED,\n                   _(\"%s commit %s not installed\"),\n                   flatpak_decomposed_get_ref (ref), active_id);\n      return FALSE;\n    }\n\n  if (!flatpak_dir_ensure_repo (self, cancellable, error))\n    return FALSE;\n\n  current_active = flatpak_dir_read_active (self, ref, cancellable);\n  if (current_active != NULL && strcmp (current_active, active_id) == 0)\n    {\n      g_auto(GStrv) deployed_ids = NULL;\n      const char *some_deployment;\n\n      /* We're removing the active deployment, start by repointing that\n         to another deployment if one exists */\n\n      if (!flatpak_dir_list_deployed (self, ref,\n                                      &deployed_ids,\n                                      cancellable, error))\n        return FALSE;\n\n      some_deployment = NULL;\n      for (i = 0; deployed_ids[i] != NULL; i++)\n        {\n          if (strcmp (deployed_ids[i], active_id) == 0)\n            continue;\n\n          some_deployment = deployed_ids[i];\n          break;\n        }\n\n      if (!flatpak_dir_set_active (self, ref, some_deployment, cancellable, error))\n        return FALSE;\n    }\n\n  removed_dir = flatpak_dir_get_removed_dir (self);\n  if (!flatpak_mkdir_p (removed_dir, cancellable, error))\n    return FALSE;\n\n  id = flatpak_decomposed_dup_id (ref);\n  dirname = g_strdup_printf (\"%s-%s\", id, active_id);\n\n  removed_subdir = g_file_get_child (removed_dir, dirname);\n\n  retry = 0;\n  while (TRUE)\n    {\n      g_autoptr(GError) local_error = NULL;\n      g_autoptr(GFile) tmpdir = NULL;\n      g_autofree char *tmpname = NULL;\n\n      if (flatpak_file_rename (checkoutdir,\n                               removed_subdir,\n                               cancellable, &local_error))\n        break;\n\n      if (!g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_EXISTS) || retry >= 10)\n        {\n          g_propagate_error (error, g_steal_pointer (&local_error));\n          return FALSE;\n        }\n\n      retry++;\n\n      /* Destination already existed, move that aside, as we want to use the exact\n       * removed dirname for the latest undeployed version */\n\n      tmpname = g_strdup_printf (\"%s-XXXXXX\", dirname);\n      glnx_gen_temp_name (tmpname);\n      tmpdir = g_file_get_child (removed_dir, tmpname);\n\n      if (!flatpak_file_rename (removed_subdir,\n                                tmpdir,\n                                cancellable, error))\n        return FALSE;\n    }\n\n\n  if (is_update)\n    change_file = g_file_resolve_relative_path (removed_subdir, \"files/.updated\");\n  else\n    change_file = g_file_resolve_relative_path (removed_subdir, \"files/.removed\");\n\n  if (!g_file_replace_contents (change_file, \"\", 0, NULL, FALSE,\n                                G_FILE_CREATE_REPLACE_DESTINATION, NULL, NULL, &child_error))\n    {\n      g_autofree gchar *path = g_file_get_path (change_file);\n      g_warning (\"Unable to clear %s: %s\", path, child_error->message);\n      g_clear_error (&child_error);\n    }\n\n  if (force_remove || !dir_is_locked (removed_subdir))\n    {\n      g_autoptr(GError) tmp_error = NULL;\n\n      if (!flatpak_rm_rf (removed_subdir, cancellable, &tmp_error))\n        g_warning (\"Unable to remove old checkout: %s\", tmp_error->message);\n    }\n\n  return TRUE;\n}\n\ngboolean\nflatpak_dir_undeploy_all (FlatpakDir        *self,\n                          FlatpakDecomposed *ref,\n                          gboolean           force_remove,\n                          gboolean          *was_deployed_out,\n                          GCancellable      *cancellable,\n                          GError           **error)\n{\n  g_auto(GStrv) deployed = NULL;\n  g_autoptr(GFile) deploy_base = NULL;\n  g_autoptr(GFile) arch_dir = NULL;\n  g_autoptr(GFile) top_dir = NULL;\n  GError *temp_error = NULL;\n  int i;\n  gboolean was_deployed;\n\n  if (!flatpak_dir_list_deployed (self, ref, &deployed, cancellable, error))\n    return FALSE;\n\n  for (i = 0; deployed[i] != NULL; i++)\n    {\n      g_debug (\"undeploying %s\", deployed[i]);\n      if (!flatpak_dir_undeploy (self, ref, deployed[i], FALSE, force_remove, cancellable, error))\n        return FALSE;\n    }\n\n  deploy_base = flatpak_dir_get_deploy_dir (self, ref);\n  was_deployed = g_file_query_exists (deploy_base, cancellable);\n  if (was_deployed)\n    {\n      g_debug (\"removing deploy base\");\n      if (!flatpak_rm_rf (deploy_base, cancellable, error))\n        return FALSE;\n    }\n\n  g_debug (\"cleaning up empty directories\");\n  arch_dir = g_file_get_parent (deploy_base);\n  if (g_file_query_exists (arch_dir, cancellable) &&\n      !g_file_delete (arch_dir, cancellable, &temp_error))\n    {\n      if (!g_error_matches (temp_error, G_IO_ERROR, G_IO_ERROR_NOT_EMPTY))\n        {\n          g_propagate_error (error, temp_error);\n          return FALSE;\n        }\n      g_clear_error (&temp_error);\n    }\n\n  top_dir = g_file_get_parent (arch_dir);\n  if (g_file_query_exists (top_dir, cancellable) &&\n      !g_file_delete (top_dir, cancellable, &temp_error))\n    {\n      if (!g_error_matches (temp_error, G_IO_ERROR, G_IO_ERROR_NOT_EMPTY))\n        {\n          g_propagate_error (error, temp_error);\n          return FALSE;\n        }\n      g_clear_error (&temp_error);\n    }\n\n  if (was_deployed_out)\n    *was_deployed_out = was_deployed;\n\n  return TRUE;\n}\n\n/**\n * flatpak_dir_remove_ref:\n * @self: a #FlatpakDir\n * @remote_name: the name of the remote\n * @ref: the flatpak ref to remove\n * @cancellable: (nullable) (optional): a #GCancellable\n * @error: a #GError\n *\n * Remove the flatpak ref given by @remote_name:@ref from the underlying\n * OSTree repo. Attempting to remove a ref that is currently deployed\n * is an error, you need to uninstall the flatpak first. Note that this does\n * not remove the objects bound to @ref from the disk, you will need to\n * call flatpak_dir_prune() to do that.\n *\n * Returns: %TRUE if removing the ref succeeded, %FALSE otherwise.\n */\ngboolean\nflatpak_dir_remove_ref (FlatpakDir        *self,\n                        const char        *remote_name,\n                        const char        *ref, /* NOTE: Not necessarily a app/runtime ref */\n                        GCancellable      *cancellable,\n                        GError           **error)\n{\n  if (flatpak_dir_use_system_helper (self, NULL))\n    {\n      const char *installation = flatpak_dir_get_id (self);\n\n      if (!flatpak_dir_system_helper_call_remove_local_ref (self,\n                                                            FLATPAK_HELPER_REMOVE_LOCAL_REF_FLAGS_NONE,\n                                                            remote_name,\n                                                            ref,\n                                                            installation ? installation : \"\",\n                                                            cancellable,\n                                                            error))\n        return FALSE;\n\n      return TRUE;\n    }\n\n  if (!ostree_repo_set_ref_immediate (self->repo,\n                                      remote_name,\n                                      ref,\n                                      NULL,\n                                      cancellable,\n                                      error))\n    return FALSE;\n\n  return TRUE;\n}\n\ngboolean\nflatpak_dir_cleanup_removed (FlatpakDir   *self,\n                             GCancellable *cancellable,\n                             GError      **error)\n{\n  gboolean ret = FALSE;\n  g_autoptr(GFile) removed_dir = NULL;\n  g_autoptr(GFileEnumerator) dir_enum = NULL;\n  g_autoptr(GFileInfo) child_info = NULL;\n  GError *temp_error = NULL;\n\n  removed_dir = flatpak_dir_get_removed_dir (self);\n  if (!g_file_query_exists (removed_dir, cancellable))\n    return TRUE;\n\n  dir_enum = g_file_enumerate_children (removed_dir, OSTREE_GIO_FAST_QUERYINFO,\n                                        G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n                                        cancellable,\n                                        error);\n  if (!dir_enum)\n    goto out;\n\n  while ((child_info = g_file_enumerator_next_file (dir_enum, cancellable, &temp_error)) != NULL)\n    {\n      const char *name = g_file_info_get_name (child_info);\n      g_autoptr(GFile) child = g_file_get_child (removed_dir, name);\n\n      if (g_file_info_get_file_type (child_info) == G_FILE_TYPE_DIRECTORY &&\n          !dir_is_locked (child))\n        {\n          g_autoptr(GError) tmp_error = NULL;\n          if (!flatpak_rm_rf (child, cancellable, &tmp_error))\n            g_warning (\"Unable to remove old checkout: %s\", tmp_error->message);\n        }\n\n      g_clear_object (&child_info);\n    }\n\n  if (temp_error != NULL)\n    {\n      g_propagate_error (error, temp_error);\n      goto out;\n    }\n\n  ret = TRUE;\nout:\n  return ret;\n}\n\ngboolean\nflatpak_dir_prune (FlatpakDir   *self,\n                   GCancellable *cancellable,\n                   GError      **error)\n{\n  gboolean ret = FALSE;\n  gint objects_total, objects_pruned;\n  guint64 pruned_object_size_total;\n  g_autofree char *formatted_freed_size = NULL;\n  g_autoptr(GError) local_error = NULL;\n  g_autoptr(GError) lock_error = NULL;\n  g_auto(GLnxLockFile) lock = { 0, };\n\n  if (error == NULL)\n    error = &local_error;\n\n  if (flatpak_dir_use_system_helper (self, NULL))\n    {\n      const char *installation = flatpak_dir_get_id (self);\n\n      if (!flatpak_dir_system_helper_call_prune_local_repo (self,\n                                                            FLATPAK_HELPER_PRUNE_LOCAL_REPO_FLAGS_NONE,\n                                                            installation ? installation : \"\",\n                                                            cancellable,\n                                                            error))\n        return FALSE;\n\n      return TRUE;\n    }\n\n  if (!flatpak_dir_ensure_repo (self, cancellable, error))\n    goto out;\n\n  /* This could remove objects, so take an exclusive repo lock */\n  if (!flatpak_dir_repo_lock (self, &lock, LOCK_EX | LOCK_NB, cancellable, &lock_error))\n    {\n      /* If we can't get an exclusive lock, don't block for a long time. Eventually\n         the shared lock operation is released and we will do a prune then */\n      if (g_error_matches (lock_error, G_IO_ERROR, G_IO_ERROR_WOULD_BLOCK))\n        {\n          g_debug (\"Skipping prune due to in progress operation\");\n          return TRUE;\n        }\n\n      g_propagate_error (error, g_steal_pointer (&lock_error));\n      return FALSE;\n    }\n\n  g_debug (\"Pruning repo\");\n  if (!ostree_repo_prune (self->repo,\n                          OSTREE_REPO_PRUNE_FLAGS_REFS_ONLY,\n                          0,\n                          &objects_total,\n                          &objects_pruned,\n                          &pruned_object_size_total,\n                          cancellable, error))\n    goto out;\n\n  formatted_freed_size = g_format_size_full (pruned_object_size_total, 0);\n  g_debug (\"Pruned %d/%d objects, size %s\", objects_total, objects_pruned, formatted_freed_size);\n\n  ret = TRUE;\n\nout:\n\n  /* There was an issue in ostree where for local pulls we don't get a .commitpartial (now fixed),\n     which caused errors when pruning. We print these here, but don't stop processing. */\n  if (local_error != NULL)\n    g_print (_(\"Pruning repo failed: %s\"), local_error->message);\n\n  return ret;\n}\n\ngboolean\nflatpak_dir_update_summary (FlatpakDir   *self,\n                            gboolean      delete,\n                            GCancellable *cancellable,\n                            GError      **error)\n{\n  if (flatpak_dir_use_system_helper (self, NULL))\n    {\n      const char *installation = flatpak_dir_get_id (self);\n\n      return flatpak_dir_system_helper_call_update_summary (self,\n                                                            delete ? FLATPAK_HELPER_UPDATE_SUMMARY_FLAGS_DELETE\n                                                                   : FLATPAK_HELPER_UPDATE_SUMMARY_FLAGS_NONE,\n                                                            installation ? installation : \"\",\n                                                            cancellable,\n                                                            error);\n    }\n\n  if (!flatpak_dir_ensure_repo (self, cancellable, error))\n    return FALSE;\n\n  if (delete)\n    {\n      g_autoptr(GError) local_error = NULL;\n      g_autoptr(GFile) summary_file = NULL;\n\n      g_debug (\"Deleting summary\");\n\n      summary_file = g_file_get_child (ostree_repo_get_path (self->repo), \"summary\");\n\n      if (!g_file_delete (summary_file, cancellable, &local_error) &&\n          !g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND))\n        {\n          g_propagate_error (error, g_steal_pointer (&local_error));\n          return FALSE;\n        }\n      return TRUE;\n    }\n  else\n    {\n      g_auto(GLnxLockFile) lock = { 0, };\n\n      g_debug (\"Updating summary\");\n\n      /* Keep a shared repo lock to avoid prunes removing objects we're relying on\n       * while generating the summary. */\n      if (!flatpak_dir_repo_lock (self, &lock, LOCK_SH, cancellable, error))\n        return FALSE;\n\n      return ostree_repo_regenerate_summary (self->repo, NULL, cancellable, error);\n    }\n}\n\nGFile *\nflatpak_dir_get_if_deployed (FlatpakDir        *self,\n                             FlatpakDecomposed *ref,\n                             const char        *checksum,\n                             GCancellable      *cancellable)\n{\n  g_autoptr(GFile) deploy_base = NULL;\n  g_autoptr(GFile) deploy_dir = NULL;\n\n  deploy_base = flatpak_dir_get_deploy_dir (self, ref);\n\n  if (checksum != NULL)\n    {\n      deploy_dir = g_file_get_child (deploy_base, checksum);\n    }\n  else\n    {\n      g_autoptr(GFile) active_link = g_file_get_child (deploy_base, \"active\");\n      g_autoptr(GFileInfo) info = NULL;\n      const char *target;\n\n      info = g_file_query_info (active_link,\n                                G_FILE_ATTRIBUTE_STANDARD_TYPE \",\" G_FILE_ATTRIBUTE_STANDARD_SYMLINK_TARGET,\n                                G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n                                NULL,\n                                NULL);\n      if (info == NULL)\n        return NULL;\n\n      target = g_file_info_get_symlink_target (info);\n      if (target == NULL)\n        return NULL;\n\n      deploy_dir = g_file_get_child (deploy_base, target);\n    }\n\n  if (g_file_query_file_type (deploy_dir, G_FILE_QUERY_INFO_NONE, cancellable) == G_FILE_TYPE_DIRECTORY)\n    return g_object_ref (deploy_dir);\n\n  /* Maybe it was removed but is still living? */\n  if (checksum != NULL)\n    {\n      g_autoptr(GFile) removed_dir = flatpak_dir_get_removed_dir (self);\n      g_autoptr(GFile) removed_deploy_dir = NULL;\n      g_autofree char *id = flatpak_decomposed_dup_id (ref);\n      g_autofree char *dirname = NULL;\n\n      dirname = g_strdup_printf (\"%s-%s\", id, checksum);\n      removed_deploy_dir = g_file_get_child (removed_dir, dirname);\n\n      if (g_file_query_file_type (removed_deploy_dir, G_FILE_QUERY_INFO_NONE, cancellable) == G_FILE_TYPE_DIRECTORY)\n        return g_object_ref (removed_deploy_dir);\n    }\n\n  return NULL;\n}\n\nGFile *\nflatpak_dir_get_unmaintained_extension_dir_if_exists (FlatpakDir   *self,\n                                                      const char   *name,\n                                                      const char   *arch,\n                                                      const char   *branch,\n                                                      GCancellable *cancellable)\n{\n  g_autoptr(GFile) extension_dir = NULL;\n  g_autoptr(GFileInfo) extension_dir_info = NULL;\n\n  extension_dir = flatpak_dir_get_unmaintained_extension_dir (self, name, arch, branch);\n\n  extension_dir_info = g_file_query_info (extension_dir,\n                                          G_FILE_ATTRIBUTE_STANDARD_SYMLINK_TARGET,\n                                          G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n                                          cancellable,\n                                          NULL);\n  if (extension_dir_info == NULL)\n    return NULL;\n\n  if (g_file_info_get_is_symlink (extension_dir_info))\n    return g_file_new_for_path (g_file_info_get_symlink_target (extension_dir_info));\n  else\n    return g_steal_pointer (&extension_dir);\n}\n\nstatic void\nremote_filter_free (RemoteFilter *remote_filter)\n{\n  g_free (remote_filter->checksum);\n  g_object_unref (remote_filter->path);\n  if (remote_filter->allow)\n    g_regex_unref (remote_filter->allow);\n  if (remote_filter->deny)\n    g_regex_unref (remote_filter->deny);\n\n  g_free (remote_filter);\n}\n\n\nstatic RemoteFilter *\nremote_filter_load (GFile *path, GError **error)\n{\n  RemoteFilter *filter;\n  g_autofree char *data = NULL;\n  gsize data_size;\n  GTimeVal mtime;\n  g_autoptr(GRegex) allow_refs = NULL;\n  g_autoptr(GRegex) deny_refs = NULL;\n\n  /* Save mtime before loading to avoid races */\n  if (!get_mtime (path, &mtime, NULL, error))\n    {\n      glnx_prefix_error (error, _(\"Failed to load filter '%s'\"), flatpak_file_get_path_cached (path));\n      return NULL;\n    }\n\n  if (!g_file_load_contents (path, NULL, &data, &data_size, NULL, error))\n    {\n      glnx_prefix_error (error, _(\"Failed to load filter '%s'\"), flatpak_file_get_path_cached (path));\n      return NULL;\n    }\n\n  if (!flatpak_parse_filters (data, &allow_refs, &deny_refs, error))\n    {\n      glnx_prefix_error (error, _(\"Failed to parse filter '%s'\"), flatpak_file_get_path_cached (path));\n      return NULL;\n    }\n\n  filter = g_new0 (RemoteFilter, 1);\n  filter->checksum = g_compute_checksum_for_data (G_CHECKSUM_SHA1, (guchar *)data, data_size);\n  filter->path = g_object_ref (path);\n  filter->mtime = mtime;\n  filter->last_mtime_check = g_get_monotonic_time ();\n  filter->allow = g_steal_pointer (&allow_refs);\n  filter->deny = g_steal_pointer (&deny_refs);\n\n  return filter;\n}\n\nG_LOCK_DEFINE_STATIC (filters);\n\nstatic gboolean\nflatpak_dir_lookup_remote_filter (FlatpakDir *self,\n                                  const char *name,\n                                  gboolean    force_load,\n                                  char      **checksum_out,\n                                  GRegex    **allow_regex,\n                                  GRegex    **deny_regex,\n                                  GError **error)\n{\n  RemoteFilter *filter = NULL;\n  g_autofree char *filter_path = NULL;\n  gboolean handled_fallback = FALSE;\n  g_autoptr(GFile) filter_file = NULL;\n\n  if (checksum_out)\n    *checksum_out = NULL;\n  *allow_regex = NULL;\n  *deny_regex = NULL;\n\n  filter_path = flatpak_dir_get_remote_filter (self, name);\n\n  if (filter_path == NULL)\n    return TRUE;\n\n  filter_file = g_file_new_for_path (filter_path);\n\n  G_LOCK (filters);\n\n  if (self->remote_filters == NULL)\n    self->remote_filters = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, (GDestroyNotify) remote_filter_free);\n\n  filter = g_hash_table_lookup (self->remote_filters, name);\n  if (filter)\n    {\n      guint64 now = g_get_monotonic_time ();\n      GTimeVal mtime;\n\n      if (g_file_equal (filter->path, filter_file) != 0)\n        filter = NULL; /* New path, reload */\n      else if ((now - filter->last_mtime_check) > (1000 * (FILTER_MTIME_CHECK_TIMEOUT_MSEC)))\n        {\n          /* Fall back to backup copy if remote filter disappears */\n          handled_fallback = TRUE;\n          if (!g_file_query_exists (filter_file, NULL))\n            {\n              g_autofree char *basename = g_strconcat (name, \".filter\", NULL);\n              g_object_unref (filter_file);\n              filter_file = flatpak_build_file (self->basedir, \"repo\", basename, NULL);\n            }\n\n          filter->last_mtime_check = now;\n          if (!get_mtime (filter_file, &mtime, NULL, NULL) ||\n              mtime.tv_sec != filter->mtime.tv_sec ||\n              mtime.tv_usec != filter->mtime.tv_usec)\n            filter = NULL; /* Different mtime, reload */\n        }\n    }\n\n  if (filter)\n    {\n      if (checksum_out)\n        *checksum_out = g_strdup (filter->checksum);\n      if (filter->allow)\n        *allow_regex = g_regex_ref (filter->allow);\n      if (filter->deny)\n        *deny_regex = g_regex_ref (filter->deny);\n    }\n\n  G_UNLOCK (filters);\n\n  if (filter) /* This is outside the lock, but we already copied the returned data, and we're not dereferencing filter */\n    return TRUE;\n\n  /* Fall back to backup copy if remote filter disappears */\n  if (!handled_fallback && !g_file_query_exists (filter_file, NULL))\n    {\n      g_autofree char *basename = g_strconcat (name, \".filter\", NULL);\n      g_object_unref (filter_file);\n      filter_file = flatpak_build_file (self->basedir, \"repo\", basename, NULL);\n    }\n\n  filter = remote_filter_load (filter_file, error);\n  if (filter == NULL)\n    return FALSE;\n\n  if (checksum_out)\n    *checksum_out = g_strdup (filter->checksum);\n  if (filter->allow)\n    *allow_regex = g_regex_ref (filter->allow);\n  if (filter->deny)\n    *deny_regex = g_regex_ref (filter->deny);\n\n  G_LOCK (filters);\n  g_hash_table_replace (self->remote_filters, g_strdup (name), filter);\n  G_UNLOCK (filters);\n\n  return TRUE;\n}\n\nG_LOCK_DEFINE_STATIC (cache);\n\n/* FIXME: Move all this caching into libostree. */\nstatic void\ncached_summary_free (CachedSummary *summary)\n{\n  g_bytes_unref (summary->bytes);\n  if (summary->bytes_sig)\n    g_bytes_unref (summary->bytes_sig);\n  g_free (summary->name);\n  g_free (summary->url);\n  g_free (summary);\n}\n\nstatic CachedSummary *\ncached_summary_new (GBytes     *bytes,\n                    GBytes     *bytes_sig,\n                    const char *name,\n                    const char *url)\n{\n  CachedSummary *summary = g_new0 (CachedSummary, 1);\n\n  summary->bytes = g_bytes_ref (bytes);\n  if (bytes_sig)\n    summary->bytes_sig = g_bytes_ref (bytes_sig);\n  summary->url = g_strdup (url);\n  summary->name = g_strdup (name);\n  summary->time = g_get_monotonic_time ();\n  return summary;\n}\n\nstatic gboolean\nflatpak_dir_lookup_cached_summary (FlatpakDir *self,\n                                   GBytes    **bytes_out,\n                                   GBytes    **bytes_sig_out,\n                                   const char *name,\n                                   const char *url)\n{\n  CachedSummary *summary;\n  gboolean res = FALSE;\n\n  G_LOCK (cache);\n\n  if (self->summary_cache == NULL)\n    self->summary_cache = g_hash_table_new_full (g_str_hash, g_str_equal, NULL, (GDestroyNotify) cached_summary_free);\n\n  summary = g_hash_table_lookup (self->summary_cache, name);\n  if (summary)\n    {\n      guint64 now = g_get_monotonic_time ();\n      if ((now - summary->time) / G_USEC_PER_SEC < SUMMARY_CACHE_TIMEOUT_SEC &&\n          strcmp (url, summary->url) == 0)\n        {\n          /* g_debug (\"Using cached summary for remote %s\", name); */\n          *bytes_out = g_bytes_ref (summary->bytes);\n          if (bytes_sig_out)\n            {\n              if (summary->bytes_sig)\n                *bytes_sig_out = g_bytes_ref (summary->bytes_sig);\n              else\n                *bytes_sig_out = NULL;\n            }\n          res = TRUE;\n\n          /* Bump the cache expiry time */\n          summary->time = now;\n        }\n      else\n        {\n          /* Timed out or URL has changed; remove the entry */\n          g_hash_table_remove (self->summary_cache, name);\n          res = FALSE;\n        }\n    }\n\n  G_UNLOCK (cache);\n\n  return res;\n}\n\nstatic void\nflatpak_dir_cache_summary (FlatpakDir *self,\n                           GBytes     *bytes,\n                           GBytes     *bytes_sig,\n                           const char *name,\n                           const char *url)\n{\n  CachedSummary *summary;\n\n  /* No sense caching the summary if there isn't one */\n  if (!bytes)\n    return;\n\n  G_LOCK (cache);\n\n  /* This was already initialized in the cache-miss lookup */\n  g_assert (self->summary_cache != NULL);\n\n  summary = cached_summary_new (bytes, bytes_sig, name, url);\n  g_hash_table_replace (self->summary_cache, summary->name, summary);\n\n  G_UNLOCK (cache);\n}\n\ngboolean\nflatpak_dir_remote_make_oci_summary (FlatpakDir   *self,\n                                     const char   *remote,\n                                     gboolean      only_cached,\n                                     GBytes      **out_summary,\n                                     GCancellable *cancellable,\n                                     GError      **error)\n{\n  g_autoptr(GVariant) summary = NULL;\n  g_autoptr(GFile) index_cache = NULL;\n  g_autofree char *index_uri = NULL;\n  g_autoptr(GFile) summary_cache = NULL;\n  g_autofree char *self_name = NULL;\n  g_autoptr(GError) local_error = NULL;\n  g_autoptr(GMappedFile) mfile = NULL;\n  g_autoptr(GBytes) cache_bytes = NULL;\n  g_autoptr(GBytes) summary_bytes = NULL;\n\n  if (flatpak_dir_use_system_helper (self, NULL))\n    {\n      const char *installation = flatpak_dir_get_id (self);\n      FlatpakHelperGenerateOciSummaryFlags flags = FLATPAK_HELPER_GENERATE_OCI_SUMMARY_FLAGS_NONE;\n\n      if (only_cached)\n        flags |= FLATPAK_HELPER_GENERATE_OCI_SUMMARY_FLAGS_ONLY_CACHED;\n\n      if (!flatpak_dir_system_helper_call_generate_oci_summary (self,\n                                                                flags,\n                                                                remote,\n                                                                installation ? installation : \"\",\n                                                                cancellable, error))\n        return FALSE;\n\n      summary_cache = flatpak_dir_get_oci_summary_location (self, remote, error);\n      if (summary_cache == NULL)\n        return FALSE;\n    }\n  else\n    {\n      self_name = flatpak_dir_get_name (self);\n\n      index_cache = flatpak_dir_update_oci_index (self, remote, &index_uri, cancellable, error);\n      if (index_cache == NULL)\n        return FALSE;\n\n      summary_cache = flatpak_dir_get_oci_summary_location (self, remote, error);\n      if (summary_cache == NULL)\n        return FALSE;\n\n      if (!only_cached && !check_destination_mtime (index_cache, summary_cache, cancellable))\n        {\n          summary = flatpak_oci_index_make_summary (index_cache, index_uri, cancellable, &local_error);\n          if (summary == NULL)\n            {\n              g_propagate_error (error, g_steal_pointer (&local_error));\n              return FALSE;\n            }\n\n          summary_bytes = g_variant_get_data_as_bytes (summary);\n\n          if (!g_file_replace_contents (summary_cache,\n                                        g_bytes_get_data (summary_bytes, NULL),\n                                        g_bytes_get_size (summary_bytes),\n                                        NULL, FALSE, 0, NULL, cancellable, error))\n            {\n              g_prefix_error (error, _(\"Failed to write summary cache: \"));\n              return FALSE;\n            }\n\n          if (out_summary)\n            *out_summary = g_steal_pointer (&summary_bytes);\n          return TRUE;\n        }\n    }\n\n  if (out_summary)\n    {\n      mfile = g_mapped_file_new (flatpak_file_get_path_cached (summary_cache), FALSE, error);\n      if (mfile == NULL)\n        {\n          if (only_cached)\n            {\n              g_clear_error (error);\n              g_set_error (error, FLATPAK_ERROR, FLATPAK_ERROR_NOT_CACHED,\n                           _(\"No oci summary cached for remote '%s'\"), remote);\n            }\n\n          return FALSE;\n        }\n\n      cache_bytes = g_mapped_file_get_bytes (mfile);\n      *out_summary = g_steal_pointer (&cache_bytes);\n    }\n\n  return TRUE;\n}\n\ntypedef struct {\n  char *filename;\n  gint64 mtime;\n} CachedSummaryData;\n\nstatic void\ncached_summary_data_free (CachedSummaryData *data)\n{\n  g_free (data->filename);\n  g_free (data);\n}\n\nstatic gboolean\nflatpak_dir_gc_cached_digested_summaries (FlatpakDir   *self,\n                                          const char   *remote_name,\n                                          const char   *dont_prune_file,\n                                          GCancellable *cancellable,\n                                          GError      **error)\n{\n  g_autoptr(GHashTable) cached_data_for_arch = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, (GDestroyNotify)cached_summary_data_free);\n  g_autoptr(GFile) cache_dir = flatpak_build_file (self->cache_dir, \"summaries\", NULL);\n  g_auto(GLnxDirFdIterator) iter = {0};\n  struct dirent *dent;\n  g_autoptr(GError) local_error = NULL;\n\n  if (!glnx_dirfd_iterator_init_at (AT_FDCWD, flatpak_file_get_path_cached (cache_dir), FALSE, &iter, &local_error))\n    {\n      if (g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND))\n        return TRUE;\n\n      g_propagate_error (error, g_steal_pointer (&local_error));\n      return FALSE;\n    }\n\n  g_autofree char *prefix = g_strconcat (remote_name, \"-\", NULL);\n\n  while (TRUE)\n    {\n      struct stat stbuf;\n      const char *arch_start, *arch_end;\n      g_autofree char *arch = NULL;\n\n      if (!glnx_dirfd_iterator_next_dent_ensure_dtype (&iter, &dent, cancellable, error))\n        return FALSE;\n\n      if (dent == NULL)\n        break;\n\n      /* Cached are regular file named \"${remote-name}-${arch}-${sha256}.sub\", ignore anything else */\n      if (dent->d_type != DT_REG ||\n          !g_str_has_prefix (dent->d_name, prefix) ||\n          !g_str_has_suffix (dent->d_name, \".sub\"))\n        continue;\n\n      arch_start = dent->d_name + strlen (prefix);\n      arch_end = strchr (arch_start, '-');\n      if (arch_end == NULL)\n        continue;\n\n      /* Keep the latest subsummary for each remote-name + arch so we can use it for deltas */\n      if (fstatat (iter.fd, dent->d_name, &stbuf, AT_SYMLINK_NOFOLLOW) == -1)\n        {\n          glnx_set_error_from_errno (error);\n          return FALSE;\n        }\n\n      arch = g_strndup (arch_start, arch_end - arch_start);\n\n      CachedSummaryData *old_data = g_hash_table_lookup (cached_data_for_arch, arch);\n      if (old_data == NULL || stbuf.st_mtime > old_data->mtime)\n        {\n          CachedSummaryData *new_data;\n\n          if (old_data &&\n              strcmp (dont_prune_file, old_data->filename) != 0 &&\n              unlinkat (iter.fd, old_data->filename, 0) != 0)\n            {\n              glnx_set_error_from_errno (error);\n              return FALSE;\n            }\n\n          new_data = g_new0 (CachedSummaryData, 1);\n          new_data->filename = g_strdup (dent->d_name);\n          new_data->mtime = stbuf.st_mtime;\n          g_hash_table_insert (cached_data_for_arch, g_steal_pointer (&arch), new_data);\n        }\n      else /* stbuf.st_mtime <= old_data->mtime */\n        {\n          if (stbuf.st_mtime < old_data->mtime &&\n              strcmp (dont_prune_file, dent->d_name) != 0 &&\n              unlinkat (iter.fd, dent->d_name, 0) != 0)\n            {\n              glnx_set_error_from_errno (error);\n              return FALSE;\n            }\n        }\n    }\n\n  return TRUE;\n}\n\nstatic gboolean\n_flatpak_dir_remote_clear_cached_summary (FlatpakDir   *self,\n                                          const char   *remote,\n                                          const char   *extension,\n                                          GCancellable *cancellable,\n                                          GError      **error)\n{\n  g_autoptr(GFile) cache_dir = flatpak_build_file (self->cache_dir, \"summaries\", NULL);\n  g_autofree char *filename = g_strconcat (remote, extension, NULL);\n  g_autoptr(GFile) file = flatpak_build_file (cache_dir, filename, NULL);\n  g_autoptr(GError) local_error = NULL;\n\n  if (!g_file_delete (file, NULL, &local_error) &&\n      !g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND))\n    {\n      g_propagate_error (error, g_steal_pointer (&local_error));\n      return FALSE;\n    }\n\n  return TRUE;\n}\n\nstatic gboolean\nflatpak_dir_remote_clear_cached_summary (FlatpakDir   *self,\n                                         const char   *remote,\n                                         GCancellable *cancellable,\n                                         GError      **error)\n{\n  g_debug (\"Clearing cached summaries for remote %s\", remote);\n  if (!_flatpak_dir_remote_clear_cached_summary (self, remote, NULL, cancellable, error))\n    return FALSE;\n  if (!_flatpak_dir_remote_clear_cached_summary (self, remote, \".sig\", cancellable, error))\n    return FALSE;\n  if (!_flatpak_dir_remote_clear_cached_summary (self, remote, \".idx\", cancellable, error))\n    return FALSE;\n  if (!_flatpak_dir_remote_clear_cached_summary (self, remote, \".idx.sig\", cancellable, error))\n    return FALSE;\n  return TRUE;\n}\n\n\nstatic gboolean\nflatpak_dir_remote_save_cached_summary (FlatpakDir   *self,\n                                        const char   *basename,\n                                        const char   *main_ext,\n                                        const char   *sig_ext,\n                                        GBytes       *main,\n                                        GBytes       *sig,\n                                        GCancellable *cancellable,\n                                        GError      **error)\n{\n  g_autofree char *main_file_name = g_strconcat (basename, main_ext, NULL);\n  g_autofree char *sig_file_name = g_strconcat (basename, sig_ext, NULL);\n  g_autoptr(GFile) cache_dir = flatpak_build_file (self->cache_dir, \"summaries\", NULL);\n  g_autoptr(GFile) main_cache_file = flatpak_build_file (cache_dir, main_file_name, NULL);\n  g_autoptr(GFile) sig_cache_file = flatpak_build_file (cache_dir, sig_file_name, NULL);\n  g_autoptr(GError) local_error = NULL;\n\n  if (!flatpak_mkdir_p (cache_dir, cancellable, error))\n    return FALSE;\n\n  if (!g_file_replace_contents (main_cache_file, g_bytes_get_data (main, NULL), g_bytes_get_size (main), NULL, FALSE,\n                                G_FILE_CREATE_REPLACE_DESTINATION, NULL, cancellable, error))\n    return FALSE;\n\n  if (sig_ext)\n    {\n      if (sig)\n        {\n          if (!g_file_replace_contents (sig_cache_file, g_bytes_get_data (sig, NULL), g_bytes_get_size (sig), NULL, FALSE,\n                                        G_FILE_CREATE_REPLACE_DESTINATION, NULL, cancellable, error))\n            return FALSE;\n        }\n      else\n        {\n          if (!g_file_delete (sig_cache_file, NULL, &local_error) &&\n              !g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND))\n            {\n              g_propagate_error (error, g_steal_pointer (&local_error));\n              return FALSE;\n            }\n        }\n    }\n\n  return TRUE;\n}\n\nstatic gboolean\nflatpak_dir_remote_load_cached_summary (FlatpakDir   *self,\n                                        const char   *basename,\n                                        const char   *main_ext,\n                                        const char   *sig_ext,\n                                        GBytes      **out_main,\n                                        GBytes      **out_sig,\n                                        GCancellable *cancellable,\n                                        GError      **error)\n{\n  g_autofree char *main_file_name = g_strconcat (basename, main_ext, NULL);\n  g_autofree char *sig_file_name = g_strconcat (basename, sig_ext, NULL);\n  g_autoptr(GFile) main_cache_file = flatpak_build_file (self->cache_dir, \"summaries\", main_file_name, NULL);\n  g_autoptr(GFile) sig_cache_file = flatpak_build_file (self->cache_dir, \"summaries\", sig_file_name, NULL);\n  g_autoptr(GMappedFile) mfile = NULL;\n  g_autoptr(GMappedFile) sig_mfile = NULL;\n\n  mfile = g_mapped_file_new (flatpak_file_get_path_cached (main_cache_file), FALSE, NULL);\n  if (mfile == NULL)\n    {\n      g_set_error (error, FLATPAK_ERROR, FLATPAK_ERROR_NOT_CACHED,\n                   _(\"No cached summary for remote '%s'\"), basename);\n      return FALSE;\n    }\n\n  if (out_sig)\n    sig_mfile = g_mapped_file_new (flatpak_file_get_path_cached (sig_cache_file), FALSE, NULL);\n\n  *out_main = g_mapped_file_get_bytes (mfile);\n  if (sig_mfile)\n    *out_sig = g_mapped_file_get_bytes (sig_mfile);\n\n  return TRUE;\n}\n\nstatic gboolean\nflatpak_dir_remote_fetch_summary (FlatpakDir   *self,\n                                  const char   *name_or_uri,\n                                  gboolean      only_cached,\n                                  GBytes      **out_summary,\n                                  GBytes      **out_summary_sig,\n                                  GCancellable *cancellable,\n                                  GError      **error)\n{\n  g_autofree char *url = NULL;\n  gboolean is_local;\n  g_autoptr(GError) local_error = NULL;\n  g_autoptr(GBytes) summary = NULL;\n  g_autoptr(GBytes) summary_sig = NULL;\n\n  if (!ostree_repo_remote_get_url (self->repo, name_or_uri, &url, error))\n    return FALSE;\n\n  if (!g_str_has_prefix (name_or_uri, \"file:\") && flatpak_dir_get_remote_disabled (self, name_or_uri))\n    {\n      g_set_error (error, G_IO_ERROR, G_IO_ERROR_INVALID_DATA,\n                   \"Can't fetch summary from disabled remote \u2018%s\u2019\", name_or_uri);\n      return FALSE;\n    }\n\n  is_local = g_str_has_prefix (url, \"file:\");\n\n  /* Seems ostree asserts if this is NULL */\n  if (error == NULL)\n    error = &local_error;\n\n  if (flatpak_dir_get_remote_oci (self, name_or_uri))\n    {\n      if (!flatpak_dir_remote_make_oci_summary (self, name_or_uri,\n                                                only_cached,\n                                                &summary,\n                                                cancellable,\n                                                error))\n        return FALSE;\n    }\n  else\n    {\n      if (only_cached)\n        {\n          if (!flatpak_dir_remote_load_cached_summary (self, name_or_uri, NULL, \".sig\",\n                                                       &summary, &summary_sig, cancellable, error))\n            return FALSE;\n          g_debug (\"Loaded summary from cache for remote \u2018%s\u2019\", name_or_uri);\n        }\n      else\n        {\n          g_debug (\"Fetching summary file for remote \u2018%s\u2019\", name_or_uri);\n          if (!ostree_repo_remote_fetch_summary (self->repo, name_or_uri,\n                                                 &summary, &summary_sig,\n                                                 cancellable,\n                                                 error))\n            return FALSE;\n        }\n    }\n\n  if (summary == NULL)\n    return flatpak_fail_error (error, FLATPAK_ERROR_INVALID_DATA, _(\"Remote listing for %s not available; server has no summary file. Check the URL passed to remote-add was valid.\"), name_or_uri);\n\n  if (!is_local && !only_cached)\n    {\n      g_autofree char *cache_key = g_strconcat (\"summary-\", name_or_uri, NULL);\n      flatpak_dir_cache_summary (self, summary, summary_sig, cache_key, url);\n    }\n\n  *out_summary = g_steal_pointer (&summary);\n  if (out_summary_sig)\n    *out_summary_sig = g_steal_pointer (&summary_sig);\n\n  return TRUE;\n}\n\nstatic gboolean\nremote_verify_signature (OstreeRepo *repo,\n                         const char *remote_name,\n                         GBytes *data,\n                         GBytes *sig_file,\n                         GCancellable *cancellable,\n                         GError **error)\n{\n  g_autoptr(GVariant) signatures_variant = NULL;\n  g_autoptr(GVariant) signaturedata = NULL;\n  g_autoptr (GBytes) signatures = NULL;\n  g_autoptr(GByteArray) buffer = NULL;\n  g_autoptr(OstreeGpgVerifyResult) verify_result = NULL;\n  GVariantIter iter;\n  GVariant *child;\n\n  signatures_variant = g_variant_new_from_bytes (OSTREE_SUMMARY_SIG_GVARIANT_FORMAT,\n                                                 sig_file, FALSE);\n  signaturedata = g_variant_lookup_value (signatures_variant, \"ostree.gpgsigs\", G_VARIANT_TYPE (\"aay\"));\n  if (signaturedata == NULL)\n    {\n      g_set_error_literal (error, OSTREE_GPG_ERROR, OSTREE_GPG_ERROR_NO_SIGNATURE,\n                           \"GPG verification enabled, but no signatures found (use gpg-verify=false in remote config to disable)\");\n      return FALSE;\n    }\n\n  buffer = g_byte_array_new ();\n  g_variant_iter_init (&iter, signaturedata);\n  while ((child = g_variant_iter_next_value (&iter)) != NULL)\n    {\n      g_byte_array_append (buffer,\n                           g_variant_get_data (child),\n                           g_variant_get_size (child));\n      g_variant_unref (child);\n    }\n  signatures = g_byte_array_free_to_bytes (g_steal_pointer (&buffer));\n\n  verify_result = ostree_repo_gpg_verify_data (repo,\n                                               remote_name,\n                                               data,\n                                               signatures,\n                                               NULL, NULL,\n                                               cancellable, error);\n  if (!ostree_gpg_verify_result_require_valid_signature (verify_result, error))\n    return FALSE;\n\n  return TRUE;\n}\n\nstatic GBytes *\nload_uri_with_fallback (SoupSession           *soup_session,\n                        const char            *uri,\n                        const char            *uri2,\n                        FlatpakHTTPFlags       flags,\n                        const char            *token,\n                        GCancellable          *cancellable,\n                        GError               **error)\n{\n  g_autoptr(GError) local_error = NULL;\n  GBytes *res;\n\n  res = flatpak_load_uri (soup_session, uri, flags, token,\n                          NULL, NULL, NULL,\n                          cancellable, &local_error);\n  if (res)\n    return res;\n\n  if (!g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND))\n    {\n      g_propagate_error (error, g_steal_pointer (&local_error));\n      return NULL;\n    }\n\n  return flatpak_load_uri (soup_session, uri2, flags, token,\n                           NULL, NULL, NULL,\n                           cancellable, error);\n}\n\nstatic gboolean\nflatpak_dir_remote_fetch_summary_index (FlatpakDir   *self,\n                                        const char   *name_or_uri,\n                                        gboolean      only_cached,\n                                        GBytes      **out_index,\n                                        GBytes      **out_index_sig,\n                                        GCancellable *cancellable,\n                                        GError      **error)\n{\n  g_autofree char *url = NULL;\n  gboolean is_local;\n  g_autoptr(GError) local_error = NULL;\n  g_autoptr(GError) cache_error = NULL;\n  g_autoptr(GBytes) cached_index = NULL;\n  g_autoptr(GBytes) cached_index_sig = NULL;\n  g_autoptr(GBytes) index = NULL;\n  g_autoptr(GBytes) index_sig = NULL;\n  gboolean gpg_verify_summary;\n\n  ensure_soup_session (self);\n\n  if (!ostree_repo_remote_get_url (self->repo, name_or_uri, &url, error))\n    return FALSE;\n\n  if (!ostree_repo_remote_get_gpg_verify_summary (self->repo, name_or_uri, &gpg_verify_summary, NULL))\n    return FALSE;\n\n  if (!g_str_has_prefix (name_or_uri, \"file:\") && flatpak_dir_get_remote_disabled (self, name_or_uri))\n    {\n      g_set_error (error, G_IO_ERROR, G_IO_ERROR_INVALID_DATA,\n                   \"Can't fetch summary from disabled remote \u2018%s\u2019\", name_or_uri);\n      return FALSE;\n    }\n\n  if (flatpak_dir_get_remote_oci (self, name_or_uri))\n    {\n      g_set_error (error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND,\n                   \"No index in OCI remote \u2018%s\u2019\", name_or_uri);\n      return FALSE;\n    }\n\n  is_local = g_str_has_prefix (url, \"file:\");\n\n  /* Seems ostree asserts if this is NULL */\n  if (error == NULL)\n    error = &local_error;\n\n  flatpak_dir_remote_load_cached_summary (self, name_or_uri, \".idx\", \".idx.sig\",\n                                          &cached_index, &cached_index_sig, cancellable, &cache_error);\n\n  if (only_cached)\n    {\n      if (cached_index == NULL)\n        {\n          g_propagate_error (error, g_steal_pointer (&cache_error));\n          return FALSE;\n        }\n      g_debug (\"Loaded summary index from cache for remote \u2018%s\u2019\", name_or_uri);\n\n      index = g_steal_pointer (&cached_index);\n      if (gpg_verify_summary)\n        index_sig = g_steal_pointer (&cached_index_sig);\n    }\n  else\n    {\n      g_autofree char *index_url = g_build_filename (url, \"summary.idx\", NULL);\n      g_autoptr(GBytes) dl_index = NULL;\n      gboolean used_download = FALSE;\n\n      g_debug (\"Fetching summary index file for remote \u2018%s\u2019\", name_or_uri);\n\n      dl_index = flatpak_load_uri (self->soup_session, index_url, 0, NULL,\n                                   NULL, NULL, NULL,\n                                   cancellable, error);\n      if (dl_index == NULL)\n        return FALSE;\n\n      /* If the downloaded index is the same as the cached one we need not re-download or\n       * re-verify, just use the cache (which we verified before) */\n      if (cached_index != NULL && g_bytes_equal (cached_index, dl_index))\n        {\n          index = g_steal_pointer (&cached_index);\n          if (gpg_verify_summary)\n            index_sig = g_steal_pointer (&cached_index_sig);\n        }\n      else\n        {\n          index = g_steal_pointer (&dl_index);\n          used_download = TRUE;\n        }\n\n      if (gpg_verify_summary && index_sig == NULL)\n        {\n          g_autofree char *index_digest = g_compute_checksum_for_bytes (G_CHECKSUM_SHA256, index);\n          g_autofree char *index_sig_filename = g_strconcat (index_digest, \".idx.sig\", NULL);\n          g_autofree char *index_sig_url = g_build_filename (url, \"summaries\", index_sig_filename, NULL);\n          g_autofree char *index_sig_url2 = g_build_filename (url, \"summary.idx.sig\", NULL);\n          g_autoptr(GError) dl_sig_error = NULL;\n          g_autoptr (GBytes) dl_index_sig = NULL;\n\n          dl_index_sig = load_uri_with_fallback (self->soup_session, index_sig_url, index_sig_url2, 0, NULL,\n                                                 cancellable, &dl_sig_error);\n          if (dl_index_sig == NULL)\n            {\n              if (g_error_matches (dl_sig_error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND))\n                g_set_error (error, OSTREE_GPG_ERROR, OSTREE_GPG_ERROR_NO_SIGNATURE,\n                             \"GPG verification enabled, but no summary signatures found (use gpg-verify-summary=false in remote config to disable)\");\n              else\n                g_propagate_error (error, g_steal_pointer (&dl_sig_error));\n\n              return FALSE;\n            }\n\n          if (!remote_verify_signature (self->repo, name_or_uri,\n                                        index, dl_index_sig,\n                                        cancellable, error))\n            return FALSE;\n\n          index_sig = g_steal_pointer (&dl_index_sig);\n          used_download = TRUE;\n        }\n\n      g_assert (index != NULL);\n      if (gpg_verify_summary)\n        g_assert (index_sig != NULL);\n\n      /* Update cache on disk if we downloaded anything, but never cache for file: repos */\n      if (used_download && !is_local &&\n          !flatpak_dir_remote_save_cached_summary (self, name_or_uri, \".idx\", \".idx.sig\",\n                                                   index, index_sig, cancellable, error))\n        return FALSE;\n    }\n\n  /* Cache in memory */\n  if (!is_local && !only_cached)\n    {\n      g_autofree char *cache_key = g_strconcat (\"index-\", name_or_uri, NULL);\n      flatpak_dir_cache_summary (self, index, index_sig, cache_key, url);\n    }\n\n  *out_index = g_steal_pointer (&index);\n  if (out_index_sig)\n    *out_index_sig = g_steal_pointer (&index_sig);\n\n  return TRUE;\n}\n\nstatic gboolean\nflatpak_dir_remote_fetch_indexed_summary (FlatpakDir   *self,\n                                          const char   *name_or_uri,\n                                          const char   *arch,\n                                          GVariant     *subsummary_info_v,\n                                          gboolean      only_cached,\n                                          GBytes      **out_summary,\n                                          GCancellable *cancellable,\n                                          GError      **error)\n{\n  g_autofree char *url = NULL;\n  gboolean is_local;\n  g_autoptr(GError) cache_error = NULL;\n  g_autoptr(GBytes) summary_z = NULL;\n  g_autoptr(GBytes) summary = NULL;\n  g_autofree char *sha256 = NULL;\n  VarSubsummaryRef subsummary_info;\n  gsize checksum_bytes_len;\n  const guchar *checksum_bytes;\n  g_autofree char *checksum = NULL;\n  g_autofree char *cache_name = NULL;\n\n  ensure_soup_session (self);\n\n  if (!ostree_repo_remote_get_url (self->repo, name_or_uri, &url, error))\n    return FALSE;\n\n  if (!g_str_has_prefix (name_or_uri, \"file:\") && flatpak_dir_get_remote_disabled (self, name_or_uri))\n    {\n      g_set_error (error, G_IO_ERROR, G_IO_ERROR_INVALID_DATA,\n                   \"Can't fetch summary from disabled remote \u2018%s\u2019\", name_or_uri);\n      return FALSE;\n    }\n\n  subsummary_info = var_subsummary_from_gvariant (subsummary_info_v);\n  checksum_bytes = var_subsummary_peek_checksum (subsummary_info, &checksum_bytes_len);\n  g_assert (checksum_bytes_len == OSTREE_SHA256_DIGEST_LEN); /* We verified this when scanning index */\n  checksum = ostree_checksum_from_bytes (checksum_bytes);\n\n  is_local = g_str_has_prefix (url, \"file:\");\n\n  /* No in-memory caching for local files */\n  if (!is_local)\n    {\n      if (flatpak_dir_lookup_cached_summary (self, out_summary, NULL, checksum, url))\n        return TRUE;\n    }\n\n  cache_name = g_strconcat (name_or_uri, \"-\", arch, \"-\", checksum, NULL);\n\n  /* First look for an on-disk cache */\n  if (!flatpak_dir_remote_load_cached_summary (self, cache_name, \".sub\", NULL,\n                                               &summary, NULL, cancellable, &cache_error))\n    {\n      g_autofree char *old_checksum = NULL;\n      g_autoptr(GBytes) old_summary = NULL;\n\n      /* Else fetch it */\n      if (only_cached)\n        {\n          g_propagate_error (error, g_steal_pointer (&cache_error));\n          return FALSE;\n        }\n\n      /* Look for first applicable deltas */\n      VarArrayofChecksumRef history = var_subsummary_get_history (subsummary_info);\n      gsize history_len = var_arrayof_checksum_get_length (history);\n      for (gsize i = 0; i < history_len; i++)\n        {\n          VarChecksumRef old = var_arrayof_checksum_get_at (history, i);\n          g_autofree char *old_cache_name = NULL;\n\n          if (var_checksum_get_length (old) != OSTREE_SHA256_DIGEST_LEN)\n            continue;\n\n          old_checksum = ostree_checksum_from_bytes (var_checksum_peek (old));\n          old_cache_name = g_strconcat (name_or_uri, \"-\", arch, \"-\", old_checksum, NULL);\n          if (flatpak_dir_remote_load_cached_summary (self, old_cache_name, \".sub\", NULL,\n                                                      &old_summary, NULL, cancellable, NULL))\n            break;\n        }\n\n      if (old_summary)\n        {\n          g_autoptr(GError) delta_error = NULL;\n\n          g_autofree char *delta_filename = g_strconcat (old_checksum, \"-\", checksum, \".delta\", NULL);\n          g_autofree char *delta_url = g_build_filename (url, \"summaries\", delta_filename, NULL);\n\n          g_debug (\"Fetching indexed summary delta %s for remote \u2018%s\u2019\", delta_filename, name_or_uri);\n\n          g_autoptr(GBytes) delta = flatpak_load_uri (self->soup_session, delta_url, 0, NULL,\n                                                      NULL, NULL, NULL,\n                                                      cancellable, &delta_error);\n          if (delta == NULL)\n            g_debug (\"Failed to load delta, falling back: %s\", delta_error->message);\n          else\n            {\n              g_autoptr(GBytes) applied = flatpak_summary_apply_diff (old_summary, delta, &delta_error);\n\n              if (applied == NULL)\n                g_warning (\"Failed to apply delta, falling back: %s\", delta_error->message);\n              else\n                {\n                  sha256 = g_compute_checksum_for_bytes (G_CHECKSUM_SHA256, applied);\n                  if (strcmp (sha256, checksum) != 0)\n                    g_warning (\"Appliying delta gave wrong checksum, falling backn\");\n                  else\n                    summary = g_steal_pointer (&applied);\n                }\n            }\n        }\n\n      if (summary == NULL)\n        {\n          g_autofree char *filename = g_strconcat (checksum, \".gz\", NULL);\n          g_debug (\"Fetching indexed summary file %s for remote \u2018%s\u2019\", filename, name_or_uri);\n          g_autofree char *subsummary_url = g_build_filename (url, \"summaries\", filename, NULL);\n          summary_z = flatpak_load_uri (self->soup_session, subsummary_url, 0, NULL,\n                                        NULL, NULL, NULL,\n                                        cancellable, error);\n          if (summary_z == NULL)\n            return FALSE;\n\n          summary = flatpak_zlib_decompress_bytes (summary_z, error);\n          if (summary == NULL)\n            return FALSE;\n\n          sha256 = g_compute_checksum_for_bytes (G_CHECKSUM_SHA256, summary);\n          if (strcmp (sha256, checksum) != 0)\n            return flatpak_fail_error (error, FLATPAK_ERROR_INVALID_DATA, _(\"Invalid checksum for indexed summary %s for remote '%s'\"), checksum, name_or_uri);\n        }\n\n      /* Save to disk */\n      if (!is_local)\n        {\n          if (!flatpak_dir_remote_save_cached_summary (self, cache_name, \".sub\", NULL,\n                                                       summary, NULL,\n                                                       cancellable, error))\n            return FALSE;\n\n          if (!flatpak_dir_gc_cached_digested_summaries (self, name_or_uri, cache_name,\n                                                         cancellable, error))\n            return FALSE;\n        }\n    }\n  else\n    g_debug (\"Loaded indexed summary file %s from cache for remote \u2018%s\u2019\", checksum, name_or_uri);\n\n  /* Cache in memory */\n  if (!is_local && !only_cached)\n    flatpak_dir_cache_summary (self, summary, NULL, checksum, url);\n\n  *out_summary = g_steal_pointer (&summary);\n\n  return TRUE;\n}\n\nstatic FlatpakRemoteState *\n_flatpak_dir_get_remote_state (FlatpakDir   *self,\n                               const char   *remote_or_uri,\n                               gboolean      optional,\n                               gboolean      local_only,\n                               gboolean      only_cached,\n                               gboolean      opt_summary_is_index,\n                               GBytes       *opt_summary,\n                               GBytes       *opt_summary_sig,\n                               GCancellable *cancellable,\n                               GError      **error)\n{\n  g_autoptr(FlatpakRemoteState) state = flatpak_remote_state_new ();\n  g_autoptr(GPtrArray) sideload_paths = NULL;\n  g_autofree char *url = NULL;\n  g_autoptr(GError) my_error = NULL;\n  gboolean is_local;\n  gboolean got_summary = FALSE;\n  const char *arch = flatpak_get_default_arch ();\n  g_autoptr(GBytes) index_bytes = NULL;\n  g_autoptr(GBytes) index_sig_bytes = NULL;\n  g_autoptr(GBytes) summary_bytes = NULL;\n  g_autoptr(GBytes) summary_sig_bytes = NULL;\n\n  if (error == NULL)\n    error = &my_error;\n\n  if (!flatpak_dir_ensure_repo (self, cancellable, error))\n    return NULL;\n\n  state->remote_name = g_strdup (remote_or_uri);\n  state->is_file_uri = is_local = g_str_has_prefix (remote_or_uri, \"file:\");\n  if (!is_local)\n    {\n      if (!flatpak_dir_has_remote (self, remote_or_uri, error))\n        return NULL;\n      if (!repo_get_remote_collection_id (self->repo, remote_or_uri, &state->collection_id, error))\n        return NULL;\n      if (!flatpak_dir_lookup_remote_filter (self, remote_or_uri, FALSE, NULL, &state->allow_refs, &state->deny_refs, error))\n        return NULL;\n      if (!ostree_repo_remote_get_url (self->repo, remote_or_uri, &url, error))\n        return FALSE;\n\n      state->default_token_type = flatpak_dir_get_remote_default_token_type (self, remote_or_uri);\n    }\n\n  sideload_paths = flatpak_dir_get_sideload_repo_paths (self);\n  for (int i = 0; i < sideload_paths->len; i++)\n    flatpak_remote_state_add_sideload_repo (state, g_ptr_array_index (sideload_paths, i));\n\n  if (local_only)\n    {\n      flatpak_fail (&state->summary_fetch_error, \"Internal error, local_only state\");\n      return g_steal_pointer (&state);\n    }\n\n  if (opt_summary)\n    {\n      if (opt_summary_sig)\n        {\n          /* If specified, must be valid signature */\n          g_autoptr(OstreeGpgVerifyResult) gpg_result =\n            ostree_repo_verify_summary (self->repo,\n                                        state->remote_name,\n                                        opt_summary,\n                                        opt_summary_sig,\n                                        NULL, error);\n          if (gpg_result == NULL ||\n              !ostree_gpg_verify_result_require_valid_signature (gpg_result, error))\n            return NULL;\n        }\n\n      if (opt_summary_is_index)\n        {\n          if (opt_summary_sig)\n            index_sig_bytes = g_bytes_ref (opt_summary_sig);\n          index_bytes = g_bytes_ref (opt_summary);\n        }\n      else\n        {\n          if (opt_summary_sig)\n            summary_sig_bytes = g_bytes_ref (opt_summary_sig);\n          summary_bytes = g_bytes_ref (opt_summary);\n        }\n\n      got_summary = TRUE;\n    }\n\n  /* First try the memory cache. Note: No in-memory caching for local files. */\n  if (!is_local)\n    {\n      if (!got_summary)\n        {\n          g_autofree char *index_cache_key = g_strconcat (\"index-\", remote_or_uri, NULL);\n          if (flatpak_dir_lookup_cached_summary (self, &index_bytes, &index_sig_bytes, index_cache_key, url))\n            got_summary = TRUE;\n        }\n\n      if (!got_summary)\n        {\n          g_autofree char *summary_cache_key = g_strconcat (\"summary-\", remote_or_uri, NULL);\n          if (flatpak_dir_lookup_cached_summary (self, &summary_bytes, &summary_sig_bytes, summary_cache_key, url))\n            got_summary = TRUE;\n        }\n    }\n\n  /* Then look for an indexed summary on disk/network */\n  if (!got_summary)\n    {\n      g_autoptr(GError) local_error = NULL;\n\n      if (flatpak_dir_remote_fetch_summary_index (self, remote_or_uri, only_cached, &index_bytes, &index_sig_bytes,\n                                                  cancellable, &local_error))\n        {\n          got_summary = TRUE;\n        }\n      else\n        {\n          if (!g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND) &&\n              !g_error_matches (local_error, FLATPAK_ERROR, FLATPAK_ERROR_NOT_CACHED))\n            {\n              /* We got an error other than not-found, assume we're indexed but there is some network error */\n              got_summary = TRUE;\n              if (optional && !g_cancellable_is_cancelled (cancellable))\n                {\n                  g_debug (\"Failed to download optional summary index: %s\", local_error->message);\n                  state->summary_fetch_error = g_steal_pointer (&local_error);\n                }\n              else\n                {\n                  g_propagate_error (error, g_steal_pointer (&local_error));\n                  return NULL;\n                }\n            }\n        }\n    }\n\n  if (!got_summary)\n    {\n      /* No index, fall back to full summary */\n      g_autoptr(GError) local_error = NULL;\n\n      if (flatpak_dir_remote_fetch_summary (self, remote_or_uri, only_cached, &summary_bytes, &summary_sig_bytes,\n                                            cancellable, &local_error))\n        {\n          got_summary = TRUE;\n        }\n      else\n        {\n          if (optional && !g_cancellable_is_cancelled (cancellable))\n            {\n              g_debug (\"Failed to download optional summary: %s\", local_error->message);\n              state->summary_fetch_error = g_steal_pointer (&local_error);\n            }\n          else\n            {\n              g_propagate_error (error, g_steal_pointer (&local_error));\n              return NULL;\n            }\n        }\n    }\n\n  if (index_bytes)\n    {\n      state->index = g_variant_ref_sink (g_variant_new_from_bytes (FLATPAK_SUMMARY_INDEX_GVARIANT_FORMAT,\n                                                                   index_bytes, FALSE));\n      state->index_sig_bytes = g_steal_pointer (&index_sig_bytes);\n    }\n  else if (summary_bytes)\n    {\n      state->summary = g_variant_ref_sink (g_variant_new_from_bytes (OSTREE_SUMMARY_GVARIANT_FORMAT,\n                                                                     summary_bytes, FALSE));\n      state->summary_bytes = g_steal_pointer (&summary_bytes);\n      state->summary_sig_bytes = g_steal_pointer (&summary_sig_bytes);\n    }\n\n  if (state->index)\n    {\n      g_autofree char *require_subset = flatpak_dir_get_remote_subset (self, state->remote_name);\n      VarSummaryIndexRef index = var_summary_index_from_gvariant (state->index);\n      VarSummaryIndexSubsummariesRef subsummaries = var_summary_index_get_subsummaries (index);\n      gsize n_subsummaries = var_summary_index_subsummaries_get_length (subsummaries);\n\n      state->index_ht = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, (GDestroyNotify)g_variant_unref);\n\n      for (gsize i = 0; i < n_subsummaries; i++)\n        {\n          VarSummaryIndexSubsummariesEntryRef entry = var_summary_index_subsummaries_get_at (subsummaries, i);\n          const char *name = var_summary_index_subsummaries_entry_get_key (entry);\n          VarSubsummaryRef subsummary = var_summary_index_subsummaries_entry_get_value (entry);\n          gsize checksum_bytes_len;\n          const guchar *checksum_bytes;\n          g_autofree char *digest = NULL;\n          const char *dash, *subsummary_arch;\n\n          dash = strchr (name, '-');\n          subsummary_arch = dash == NULL ? name : dash + 1;\n\n          if (dash == NULL) /* No subset */\n            {\n              if (require_subset != NULL)\n                continue;\n            }\n          else /* Subset */\n            {\n              if (require_subset == NULL)\n                continue;\n              else\n                {\n                  g_autofree char *subset = g_strndup (name, dash - name);\n                  if (strcmp (require_subset, subset) != 0)\n                    continue;\n                }\n            }\n\n          checksum_bytes = var_subsummary_peek_checksum (subsummary, &checksum_bytes_len);\n          if (G_UNLIKELY (checksum_bytes_len != OSTREE_SHA256_DIGEST_LEN))\n            {\n              g_debug (\"Invalid checksum for digested summary, not using cache\");\n              continue;\n            }\n          digest = ostree_checksum_from_bytes (checksum_bytes);\n\n          g_hash_table_insert (state->index_ht, g_strdup (subsummary_arch), var_subsummary_to_owned_gvariant (subsummary, state->index));\n        }\n\n      /* Always load default (or specified) arch subsummary. Further arches can be manually loaded with flatpak_remote_state_ensure_subsummary. */\n      if (opt_summary == NULL &&\n          !flatpak_remote_state_ensure_subsummary (state, self, arch, only_cached, cancellable, error))\n        return NULL;\n    }\n\n  if (state->collection_id != NULL &&\n      state->summary != NULL &&\n      !_validate_summary_for_collection_id (state->summary, state->collection_id, error))\n    return NULL;\n\n  if (flatpak_dir_get_remote_oci (self, remote_or_uri))\n    {\n      state->default_token_type = 1;\n    }\n\n  if (state->summary != NULL || state->index != NULL) /* In the optional case we might not have a summary */\n    {\n      VarMetadataRef meta = flatpak_remote_state_get_main_metadata (state);\n      VarVariantRef res;\n\n      if (var_metadata_lookup (meta, \"xa.default-token-type\", NULL, &res) &&\n          var_variant_is_type (res, G_VARIANT_TYPE_INT32))\n        state->default_token_type = GINT32_FROM_LE (var_variant_get_int32 (res));\n    }\n\n  return g_steal_pointer (&state);\n}\n\nFlatpakRemoteState *\nflatpak_dir_get_remote_state (FlatpakDir   *self,\n                              const char   *remote,\n                              gboolean      only_cached,\n                              GCancellable *cancellable,\n                              GError      **error)\n{\n  return _flatpak_dir_get_remote_state (self, remote, FALSE, FALSE, only_cached, FALSE, NULL, NULL, cancellable, error);\n}\n\n/* This is an alternative way to get the state where the summary is\n * from elsewhere. It is mainly used by the system-helper where the\n * summary is from the user-mode part which downloaded an update\n *\n * It will verify the summary if a signature is passed in, but not\n * otherwise.\n **/\nFlatpakRemoteState *\nflatpak_dir_get_remote_state_for_summary (FlatpakDir   *self,\n                                          const char   *remote,\n                                          GBytes       *opt_summary,\n                                          GBytes       *opt_summary_sig,\n                                          GCancellable *cancellable,\n                                          GError      **error)\n{\n  return _flatpak_dir_get_remote_state (self, remote, FALSE, FALSE, FALSE, FALSE, opt_summary, opt_summary_sig, cancellable, error);\n}\n\nFlatpakRemoteState *\nflatpak_dir_get_remote_state_for_index (FlatpakDir   *self,\n                                        const char   *remote,\n                                        GBytes       *opt_index,\n                                        GBytes       *opt_index_sig,\n                                        GCancellable *cancellable,\n                                        GError      **error)\n{\n  return _flatpak_dir_get_remote_state (self, remote, FALSE, FALSE, FALSE, TRUE, opt_index, opt_index_sig, cancellable, error);\n}\n\n/* This is an alternative way to get the remote state that doesn't\n * error out if the summary or metadata is not available.\n * For example, we want to be able to update an app even when\n * we can't talk to the main repo, but there is a local (p2p/sdcard)\n * source for apps, and we want to be able to deploy a ref without pulling it,\n * e.g. because we are installing with FLATPAK_INSTALL_FLAGS_NO_PULL, and we\n * already pulled it out of band beforehand.\n */\nFlatpakRemoteState *\nflatpak_dir_get_remote_state_optional (FlatpakDir   *self,\n                                       const char   *remote,\n                                       gboolean      only_cached,\n                                       GCancellable *cancellable,\n                                       GError      **error)\n{\n  return _flatpak_dir_get_remote_state (self, remote, TRUE, FALSE, only_cached, FALSE, NULL, NULL, cancellable, error);\n}\n\n\n/* This doesn't do any i/o at all, just keeps track of the local details like\n   remote and collection-id. Useful when doing no-pull operations */\nFlatpakRemoteState *\nflatpak_dir_get_remote_state_local_only (FlatpakDir   *self,\n                                         const char   *remote,\n                                         GCancellable *cancellable,\n                                         GError      **error)\n{\n  return _flatpak_dir_get_remote_state (self, remote, TRUE, TRUE, FALSE, FALSE, NULL, NULL, cancellable, error);\n}\n\nstatic void\npopulate_hash_table_from_refs_map (GHashTable         *ret_all_refs,\n                                   GHashTable         *ref_timestamps,\n                                   VarRefMapRef        ref_map,\n                                   const char         *opt_collection_id,\n                                   FlatpakRemoteState *state)\n{\n  gsize len, i;\n\n  len = var_ref_map_get_length (ref_map);\n  for (i = 0; i < len; i++)\n    {\n      VarRefMapEntryRef entry = var_ref_map_get_at (ref_map, i);\n      const char *ref_name = var_ref_map_entry_get_ref (entry);\n      const guint8 *csum_bytes;\n      gsize csum_len;\n      VarRefInfoRef info;\n      guint64 *new_timestamp = NULL;\n      g_autoptr(FlatpakDecomposed) decomposed = NULL;\n\n      if (!flatpak_remote_state_allow_ref (state, ref_name))\n        continue;\n\n      info = var_ref_map_entry_get_info (entry);\n\n      csum_bytes = var_ref_info_peek_checksum (info, &csum_len);\n      if (csum_len != OSTREE_SHA256_DIGEST_LEN)\n        continue;\n\n      decomposed = flatpak_decomposed_new_from_col_ref (ref_name, opt_collection_id, NULL);\n      if (decomposed == NULL)\n        continue;\n\n      if (ref_timestamps)\n        {\n          guint64 timestamp = get_timestamp_from_ref_info (info);\n          gpointer value;\n\n          if (g_hash_table_lookup_extended (ref_timestamps, ref_name, NULL, &value))\n            {\n              guint64 *old_timestamp = value;\n              if (*old_timestamp >= timestamp)\n                continue; /* New timestamp is older, skip this commit */\n            }\n\n          new_timestamp = g_memdup (&timestamp, sizeof (guint64));\n        }\n\n      g_hash_table_replace (ret_all_refs, g_steal_pointer (&decomposed), ostree_checksum_from_bytes (csum_bytes));\n      if (new_timestamp)\n        g_hash_table_replace (ref_timestamps, g_strdup (ref_name), new_timestamp);\n    }\n}\n\n\n/* This tries to list all available remote refs but also tries to keep\n * working when offline, so it looks in sideloaded repos. Also it uses\n * in-memory cached summaries which ostree doesn't. */\ngboolean\nflatpak_dir_list_all_remote_refs (FlatpakDir         *self,\n                                  FlatpakRemoteState *state,\n                                  GHashTable        **out_all_refs,\n                                  GCancellable       *cancellable,\n                                  GError            **error)\n{\n  g_autoptr(GHashTable) ret_all_refs = NULL;\n  VarSummaryRef summary;\n  VarMetadataRef exts;\n  VarRefMapRef ref_map;\n  VarVariantRef v;\n\n  /* This is  ref->commit */\n  ret_all_refs = g_hash_table_new_full ((GHashFunc)flatpak_decomposed_hash, (GEqualFunc)flatpak_decomposed_equal, (GDestroyNotify)flatpak_decomposed_unref, g_free);\n\n  if (state->index != NULL)\n    {\n      /* We're online, so report only the refs from the summary */\n      GLNX_HASH_TABLE_FOREACH_KV (state->subsummaries, const char *, arch, GVariant *, subsummary)\n        {\n          summary = var_summary_from_gvariant (subsummary);\n          ref_map = var_summary_get_ref_map (summary);\n          populate_hash_table_from_refs_map (ret_all_refs, NULL, ref_map, NULL, state);\n        }\n    }\n  else if (state->summary != NULL)\n    {\n      /* We're online, so report only the refs from the summary */\n      const char *main_collection_id = NULL;\n\n      summary = var_summary_from_gvariant (state->summary);\n\n      exts = var_summary_get_metadata (summary);\n\n      if (state->is_file_uri)\n        {\n          /* This is a local repo, generally this means we gave a file: uri to a sideload repo so\n           * we can enumerate it. We special case this by also adding all the collection_ref maps,\n           * with collection_id set on the decomposed refs and setting the right collection id for\n           * the main ref_map.\n           */\n          main_collection_id = var_metadata_lookup_string (exts, \"ostree.summary.collection-id\", NULL);\n          if (var_metadata_lookup (exts, \"ostree.summary.collection-map\", NULL, &v))\n            {\n              VarCollectionMapRef map = var_collection_map_from_variant (v);\n\n              gsize len = var_collection_map_get_length (map);\n              for (gsize i = 0; i < len; i++)\n                {\n                  VarCollectionMapEntryRef entry = var_collection_map_get_at (map, i);\n                  const char *collection_id = var_collection_map_entry_get_key (entry);\n                  ref_map = var_collection_map_entry_get_value (entry);\n\n                  populate_hash_table_from_refs_map (ret_all_refs, NULL, ref_map, collection_id, state);\n                }\n            }\n        }\n\n      /* refs that match the main collection-id,\n         NOTE: We only set collection id if this is a file: uri remote */\n      ref_map = var_summary_get_ref_map (summary);\n      populate_hash_table_from_refs_map (ret_all_refs, NULL, ref_map, main_collection_id, state);\n    }\n  else if (state->collection_id)\n    {\n      g_autoptr(GHashTable) ref_mtimes = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, g_free);\n\n      /* No main summary, add just all sideloded refs, with the latest version of each checksum */\n\n      for (int i = 0; i < state->sideload_repos->len; i++)\n        {\n          FlatpakSideloadState *ss = g_ptr_array_index (state->sideload_repos, i);\n\n          summary = var_summary_from_gvariant (ss->summary);\n          exts = var_summary_get_metadata (summary);\n\n          if (var_metadata_lookup (exts, \"ostree.summary.collection-map\", NULL, &v))\n            {\n              VarCollectionMapRef map = var_collection_map_from_variant (v);\n\n              if (var_collection_map_lookup (map, state->collection_id, NULL, &ref_map))\n                populate_hash_table_from_refs_map (ret_all_refs, ref_mtimes, ref_map, NULL, state);\n            }\n        }\n    }\n\n  /* If no sideloaded refs, might as well return the summary error if set */\n  if (g_hash_table_size (ret_all_refs) == 0 &&\n      !flatpak_remote_state_ensure_summary (state, error))\n    return FALSE;\n\n  *out_all_refs = g_steal_pointer (&ret_all_refs);\n\n  return TRUE;\n}\n\nstatic GPtrArray *\nfind_matching_refs (GHashTable           *refs,\n                    const char           *opt_name,\n                    const char           *opt_branch,\n                    const char           *opt_default_branch,\n                    const char           *opt_arch,\n                    const char           *opt_default_arch,\n                    FlatpakKinds          kinds,\n                    FindMatchingRefsFlags flags,\n                    GError              **error)\n{\n  g_autoptr(GPtrArray) matched_refs = NULL;\n  const char **arches = flatpak_get_arches ();\n  const char *opt_arches[] = {opt_arch, NULL};\n  g_autoptr(GError) local_error = NULL;\n  gboolean found_exact_name_match = FALSE;\n  gboolean found_default_branch_match = FALSE;\n  gboolean found_default_arch_match = FALSE;\n\n  if (opt_arch != NULL)\n    arches = opt_arches;\n\n  if (opt_name && !(flags & FIND_MATCHING_REFS_FLAGS_FUZZY) &&\n      !flatpak_is_valid_name (opt_name, -1, &local_error))\n    {\n      flatpak_fail_error (error, FLATPAK_ERROR_INVALID_REF, _(\"'%s' is not a valid name: %s\"), opt_name, local_error->message);\n      return NULL;\n    }\n\n  if (opt_branch && !flatpak_is_valid_branch (opt_branch, -1, &local_error))\n    {\n      flatpak_fail_error (error, FLATPAK_ERROR_INVALID_REF, _(\"'%s' is not a valid branch name: %s\"), opt_branch, local_error->message);\n      return NULL;\n    }\n\n  matched_refs = g_ptr_array_new_with_free_func ((GDestroyNotify)flatpak_decomposed_unref);\n\n  GLNX_HASH_TABLE_FOREACH (refs, FlatpakDecomposed *, ref)\n    {\n      if ((flatpak_decomposed_get_kinds (ref) & kinds) == 0)\n        continue;\n\n      if (opt_name)\n        {\n          if ((flags & FIND_MATCHING_REFS_FLAGS_FUZZY) && !flatpak_decomposed_id_is_subref (ref))\n            {\n              if (!flatpak_decomposed_is_id_fuzzy (ref, opt_name))\n                continue;\n            }\n          else\n            {\n              if (!flatpak_decomposed_is_id (ref, opt_name))\n                continue;\n           }\n        }\n\n      if (!flatpak_decomposed_is_arches (ref, -1, arches))\n        continue;\n\n      if (opt_branch != NULL && !flatpak_decomposed_is_branch (ref, opt_branch))\n        continue;\n\n      if (opt_name != NULL && flatpak_decomposed_is_id (ref, opt_name))\n        found_exact_name_match = TRUE;\n\n      if (opt_default_arch != NULL && flatpak_decomposed_is_arch (ref, opt_default_arch))\n        found_default_arch_match = TRUE;\n\n      if (opt_default_branch != NULL && flatpak_decomposed_is_branch (ref, opt_default_branch))\n        found_default_branch_match = TRUE;\n\n      g_ptr_array_add (matched_refs, flatpak_decomposed_ref (ref));\n    }\n\n  /* Don't show fuzzy matches if we found at least one exact name match, and\n   * enforce the default arch/branch */\n  if (found_exact_name_match || found_default_arch_match || found_default_branch_match)\n    {\n      guint i;\n\n      /* Walk through the array backwards so we can safely remove */\n      for (i = matched_refs->len; i > 0; i--)\n        {\n          FlatpakDecomposed *matched_ref = g_ptr_array_index (matched_refs, i - 1);\n\n          if (found_exact_name_match && !flatpak_decomposed_is_id (matched_ref, opt_name))\n            g_ptr_array_remove_index (matched_refs, i - 1);\n          else if (found_default_arch_match && !flatpak_decomposed_is_arch (matched_ref, opt_default_arch))\n            g_ptr_array_remove_index (matched_refs, i - 1);\n          else if (found_default_branch_match && !flatpak_decomposed_is_branch (matched_ref, opt_default_branch))\n            g_ptr_array_remove_index (matched_refs, i - 1);\n        }\n    }\n\n  return g_steal_pointer (&matched_refs);\n}\n\nstatic FlatpakDecomposed *\nfind_matching_ref (GHashTable  *refs,\n                   const char  *name,\n                   const char  *opt_branch,\n                   const char  *opt_default_branch,\n                   const char  *opt_arch,\n                   FlatpakKinds kinds,\n                   GError     **error)\n{\n  const char **arches = flatpak_get_arches ();\n  const char *opt_arches[] = {opt_arch, NULL};\n  int i;\n\n  if (opt_arch != NULL)\n    arches = opt_arches;\n\n  /* We stop at the first arch (in prio order) that has a match */\n  for (i = 0; arches[i] != NULL; i++)\n    {\n      g_autoptr(GPtrArray) matched_refs = NULL;\n      int j;\n\n      matched_refs = find_matching_refs (refs,\n                                         name,\n                                         opt_branch,\n                                         opt_default_branch,\n                                         arches[i],\n                                         NULL,\n                                         kinds,\n                                         FIND_MATCHING_REFS_FLAGS_NONE,\n                                         error);\n      if (matched_refs == NULL)\n        return NULL;\n\n      if (matched_refs->len == 0)\n        continue;\n\n      if (matched_refs->len == 1)\n        return flatpak_decomposed_ref (g_ptr_array_index (matched_refs, 0));\n\n      /* Nothing to do other than reporting the different choices */\n      g_autoptr(GString) err = g_string_new (\"\");\n      g_string_printf (err, _(\"Multiple branches available for %s, you must specify one of: \"), name);\n      g_ptr_array_sort (matched_refs, flatpak_strcmp0_ptr);\n      for (j = 0; j < matched_refs->len; j++)\n        {\n          FlatpakDecomposed *ref = g_ptr_array_index (matched_refs, j);\n          if (j != 0)\n            g_string_append (err, \", \");\n\n          const char *branch = flatpak_decomposed_get_branch (ref);\n\n          g_string_append (err,\n                           g_strdup_printf (\"%s/%s/%s\",\n                                            name,\n                                            opt_arch ? opt_arch : \"\",\n                                            branch));\n        }\n\n      flatpak_fail (error, \"%s\", err->str);\n      return NULL;\n    }\n\n  g_set_error (error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND,\n               _(\"Nothing matches %s\"), name);\n  return NULL;\n}\n\nchar *\nflatpak_dir_get_remote_collection_id (FlatpakDir *self,\n                                      const char *remote_name)\n{\n  char *collection_id = NULL;\n\n  if (!flatpak_dir_ensure_repo (self, NULL, NULL))\n    return NULL;\n\n  repo_get_remote_collection_id (self->repo, remote_name, &collection_id, NULL);\n\n  return collection_id;\n}\n\nGPtrArray *\nflatpak_dir_find_remote_refs (FlatpakDir           *self,\n                              FlatpakRemoteState   *state,\n                              const char           *name,\n                              const char           *opt_branch,\n                              const char           *opt_default_branch,\n                              const char           *opt_arch,\n                              const char           *opt_default_arch,\n                              FlatpakKinds          kinds,\n                              FindMatchingRefsFlags flags,\n                              GCancellable         *cancellable,\n                              GError              **error)\n{\n  g_autoptr(GHashTable) remote_refs = NULL;\n  g_autoptr(GPtrArray) matched_refs = NULL;\n\n  if (!flatpak_dir_list_all_remote_refs (self, state,\n                                         &remote_refs, cancellable, error))\n    return NULL;\n\n\n  matched_refs = find_matching_refs (remote_refs,\n                                     name,\n                                     opt_branch,\n                                     opt_default_branch,\n                                     opt_arch,\n                                     opt_default_arch,\n                                     kinds,\n                                     flags,\n                                     error);\n  if (matched_refs == NULL)\n    return NULL;\n\n  /* If we can't match anything and we had an error downloading (offline?), report that as its more helpful */\n  if (matched_refs->len == 0 && state->summary_fetch_error)\n    {\n      g_propagate_error (error, g_error_copy (state->summary_fetch_error));\n      return NULL;\n    }\n\n  return g_steal_pointer (&matched_refs);\n}\n\nstatic FlatpakDecomposed *\nfind_ref_for_refs_set (GHashTable   *refs,\n                       const char   *name,\n                       const char   *opt_branch,\n                       const char   *opt_default_branch,\n                       const char   *opt_arch,\n                       FlatpakKinds  kinds,\n                       GError      **error)\n{\n  g_autoptr(GError) my_error = NULL;\n  g_autoptr(FlatpakDecomposed) ref = find_matching_ref (refs,\n                                                        name,\n                                                        opt_branch,\n                                                        opt_default_branch,\n                                                        opt_arch,\n                                                        kinds,\n                                                        &my_error);\n  if (ref == NULL)\n    {\n      if (g_error_matches (my_error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND))\n        g_clear_error (&my_error);\n      else\n        {\n          g_propagate_error (error, g_steal_pointer (&my_error));\n          return NULL;\n        }\n    }\n  else\n    {\n      return g_steal_pointer (&ref);\n    }\n\n  g_set_error (error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND,\n               _(\"Can't find ref %s%s%s%s%s\"), name,\n               (opt_arch != NULL || opt_branch != NULL) ? \"/\" : \"\",\n               opt_arch ? opt_arch : \"\",\n               opt_branch ? \"/\" : \"\",\n               opt_branch ? opt_branch : \"\");\n\n  return NULL;\n}\n\nFlatpakDecomposed *\nflatpak_dir_find_remote_ref (FlatpakDir   *self,\n                             FlatpakRemoteState *state,\n                             const char   *name,\n                             const char   *opt_branch,\n                             const char   *opt_default_branch,\n                             const char   *opt_arch,\n                             FlatpakKinds  kinds,\n                             GCancellable *cancellable,\n                             GError      **error)\n{\n  g_autoptr(FlatpakDecomposed) remote_ref = NULL;\n  g_autoptr(GHashTable) remote_refs = NULL;\n  g_autoptr(GError) my_error = NULL;\n\n  /* Avoid work if the entire ref was specified */\n  if (opt_branch != NULL && opt_arch != NULL && (kinds == FLATPAK_KINDS_APP || kinds == FLATPAK_KINDS_RUNTIME))\n    return flatpak_decomposed_new_from_parts (kinds, name, opt_arch, opt_branch, error);\n\n  if (!flatpak_dir_list_all_remote_refs (self, state,\n                                         &remote_refs, cancellable, error))\n    return NULL;\n\n  remote_ref = find_ref_for_refs_set (remote_refs, name, opt_branch,\n                                      opt_default_branch, opt_arch,\n                                      kinds,  &my_error);\n  if (!remote_ref)\n    {\n      if (g_error_matches (my_error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND))\n        {\n          g_set_error (error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND,\n                       _(\"Error searching remote %s: %s\"),\n                       state->remote_name,\n                       my_error->message);\n          return NULL;\n        }\n      else\n        {\n          g_propagate_error (error, g_steal_pointer (&my_error));\n          return NULL;\n        }\n    }\n\n  return g_steal_pointer (&remote_ref);\n}\n\nstatic GHashTable *\nrefspecs_decompose_steal (GHashTable *refspecs)\n{\n  g_autoptr(GHashTable) refs = NULL;\n  GHashTableIter iter;\n  gpointer key, value;\n\n  refs = g_hash_table_new_full ((GHashFunc)flatpak_decomposed_hash, (GEqualFunc)flatpak_decomposed_equal,\n                                (GDestroyNotify)flatpak_decomposed_unref, g_free);\n\n  g_hash_table_iter_init (&iter, refspecs);\n  while (g_hash_table_iter_next (&iter, &key, &value))\n    {\n      char *checksum = value;\n      char *refspec = key;\n      FlatpakDecomposed *decomposed;\n\n      g_hash_table_iter_steal (&iter);\n\n      decomposed = flatpak_decomposed_new_from_refspec_take (refspec, NULL);\n      if (decomposed)\n        {\n          g_hash_table_insert (refs, decomposed, checksum);\n        }\n      else\n        {\n          g_free (checksum);\n          g_free (refspec);\n        }\n    }\n\n  return g_steal_pointer (&refs);\n}\n\nGPtrArray *\nflatpak_dir_find_local_refs (FlatpakDir           *self,\n                             const char           *remote,\n                             const char           *name,\n                             const char           *opt_branch,\n                             const char           *opt_default_branch,\n                             const char           *opt_arch,\n                             const char           *opt_default_arch,\n                             FlatpakKinds          kinds,\n                             FindMatchingRefsFlags flags,\n                             GCancellable         *cancellable,\n                             GError              **error)\n{\n  g_autoptr(GHashTable) local_refs = NULL;\n  g_autoptr(GHashTable) local_refspecs = NULL;\n  g_autoptr(GError) my_error = NULL;\n  g_autofree char *refspec_prefix = g_strconcat (remote, \":.\", NULL);\n  g_autoptr(GPtrArray) matched_refs = NULL;\n\n  if (!flatpak_dir_ensure_repo (self, NULL, error))\n    return NULL;\n\n  if (!ostree_repo_list_refs (self->repo,\n                              refspec_prefix,\n                              &local_refspecs, cancellable, error))\n    return NULL;\n\n  local_refs = refspecs_decompose_steal (local_refspecs);\n\n  matched_refs = find_matching_refs (local_refs,\n                                     name,\n                                     opt_branch,\n                                     opt_default_branch,\n                                     opt_arch,\n                                     opt_default_arch,\n                                     kinds,\n                                     flags,\n                                     &my_error);\n  if (matched_refs == NULL)\n    {\n      if (g_error_matches (my_error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND))\n        {\n          g_set_error (error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND,\n                       _(\"Error searching local repository: %s\"),\n                       my_error->message);\n          return NULL;\n        }\n      else\n        {\n          g_propagate_error (error, g_steal_pointer (&my_error));\n          return NULL;\n        }\n    }\n\n  return g_steal_pointer (&matched_refs);\n}\n\nstatic GHashTable *\nflatpak_dir_get_all_installed_refs (FlatpakDir  *self,\n                                    FlatpakKinds kinds,\n                                    GError     **error)\n{\n  g_autoptr(GHashTable) local_refs = NULL;\n\n  if (!flatpak_dir_maybe_ensure_repo (self, NULL, error))\n    return NULL;\n\n  local_refs = g_hash_table_new_full ((GHashFunc)flatpak_decomposed_hash, (GEqualFunc)flatpak_decomposed_equal, (GDestroyNotify)flatpak_decomposed_unref, NULL);\n  if (kinds & FLATPAK_KINDS_APP)\n    {\n      g_autoptr(GPtrArray) app_refs = flatpak_dir_list_refs (self, FLATPAK_KINDS_APP, NULL, error);\n      if (app_refs == NULL)\n        return NULL;\n\n      for (int i = 0; i < app_refs->len; i++)\n        {\n          FlatpakDecomposed *app_ref = g_ptr_array_index (app_refs, i);\n          g_hash_table_add (local_refs, flatpak_decomposed_ref (app_ref));\n        }\n    }\n  if (kinds & FLATPAK_KINDS_RUNTIME)\n    {\n      g_autoptr(GPtrArray) runtime_refs = flatpak_dir_list_refs (self, FLATPAK_KINDS_RUNTIME, NULL, error);\n      if (runtime_refs == NULL)\n        return NULL;\n\n      for (int i = 0; i < runtime_refs->len; i++)\n        {\n          FlatpakDecomposed *runtime_ref = g_ptr_array_index (runtime_refs, i);\n          g_hash_table_add (local_refs, flatpak_decomposed_ref (runtime_ref));\n        }\n    }\n\n  return g_steal_pointer (&local_refs);\n}\n\nGPtrArray *\nflatpak_dir_find_installed_refs (FlatpakDir           *self,\n                                 const char           *opt_name,\n                                 const char           *opt_branch,\n                                 const char           *opt_arch,\n                                 FlatpakKinds          kinds,\n                                 FindMatchingRefsFlags flags,\n                                 GError              **error)\n{\n  g_autoptr(GHashTable) local_refs = NULL;\n  g_autoptr(GPtrArray) matched_refs = NULL;\n\n  local_refs = flatpak_dir_get_all_installed_refs (self, kinds, error);\n  if (local_refs == NULL)\n    return NULL;\n\n  matched_refs = find_matching_refs (local_refs,\n                                     opt_name,\n                                     opt_branch,\n                                     NULL, /* default branch */\n                                     opt_arch,\n                                     NULL, /* default arch */\n                                     kinds,\n                                     flags,\n                                     error);\n  if (matched_refs == NULL)\n    return NULL;\n\n  return g_steal_pointer (&matched_refs);\n}\n\nFlatpakDecomposed *\nflatpak_dir_find_installed_ref (FlatpakDir   *self,\n                                const char   *opt_name,\n                                const char   *opt_branch,\n                                const char   *opt_arch,\n                                FlatpakKinds  kinds,\n                                GError      **error)\n{\n  g_autoptr(FlatpakDecomposed) local_ref = NULL;\n  g_autoptr(GHashTable) local_refs = NULL;\n  g_autoptr(GError) my_error = NULL;\n\n  local_refs = flatpak_dir_get_all_installed_refs (self, kinds, error);\n  if (local_refs == NULL)\n    return NULL;\n\n  local_ref = find_matching_ref (local_refs, opt_name, opt_branch, NULL,\n                                 opt_arch, kinds, &my_error);\n  if (local_ref == NULL)\n    {\n      if (g_error_matches (my_error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND))\n        g_clear_error (&my_error);\n      else\n        {\n          g_propagate_error (error, g_steal_pointer (&my_error));\n          return NULL;\n        }\n    }\n  else\n    {\n      return g_steal_pointer (&local_ref);\n    }\n\n  g_set_error (error, FLATPAK_ERROR, FLATPAK_ERROR_NOT_INSTALLED,\n               _(\"%s/%s/%s not installed\"),\n               opt_name ? opt_name : \"*unspecified*\",\n               opt_arch ? opt_arch : \"*unspecified*\",\n               opt_branch ? opt_branch : \"*unspecified*\");\n  return NULL;\n}\n\n/* Given a list of decomposed refs in local_refspecs, remove any refs that have already\n * been deployed and return a new GPtrArray containing only the undeployed\n * refs. This is used by flatpak_dir_cleanup_undeployed_refs to determine\n * which undeployed refs need to be removed from the local repository.\n *\n * Returns: (transfer-full): A #GPtrArray\n */\nstatic GPtrArray *\nfilter_out_deployed_refs (FlatpakDir *self,\n                          GPtrArray  *local_refspecs,\n                          GError    **error)\n{\n  g_autoptr(GPtrArray) undeployed_refs = g_ptr_array_new_full (local_refspecs->len, (GDestroyNotify)flatpak_decomposed_unref);\n  gsize i;\n\n  for (i = 0; i < local_refspecs->len; ++i)\n    {\n      FlatpakDecomposed *ref = g_ptr_array_index (local_refspecs, i);\n      g_autoptr(GBytes) deploy_data = NULL;\n\n      deploy_data = flatpak_dir_get_deploy_data (self, ref, FLATPAK_DEPLOY_VERSION_ANY, NULL, NULL);\n\n      if (!deploy_data)\n        g_ptr_array_add (undeployed_refs, flatpak_decomposed_ref (ref));\n    }\n\n  return g_steal_pointer (&undeployed_refs);\n}\n\n/**\n * flatpak_dir_cleanup_undeployed_refs:\n * @self: a #FlatpakDir\n * @cancellable: (nullable) (optional): a #GCancellable\n * @error: a #GError\n *\n * Find all flatpak refs in the local repository which have not been deployed\n * in the dir and remove them from the repository. You might want to call this\n * function if you pulled refs into the dir but then decided that you did\n * not want to deploy them for some reason. Note that this does not prune\n * objects bound to the cleaned up refs from the underlying OSTree repository,\n * you should consider using flatpak_dir_prune() to do that.\n *\n * Since: 0.10.0\n * Returns: %TRUE if cleaning up the refs succeeded, %FALSE otherwise\n */\ngboolean\nflatpak_dir_cleanup_undeployed_refs (FlatpakDir   *self,\n                                     GCancellable *cancellable,\n                                     GError      **error)\n{\n  g_autoptr(GHashTable) local_refspecs = NULL;\n  g_autoptr(GHashTable) local_refs = NULL;\n  g_autoptr(GPtrArray)  local_flatpak_refspecs = NULL;\n  g_autoptr(GPtrArray) undeployed_refs = NULL;\n  gsize i = 0;\n\n  if (!ostree_repo_list_refs (self->repo, NULL, &local_refspecs, cancellable, error))\n    return FALSE;\n\n  local_refs = refspecs_decompose_steal (local_refspecs);\n\n  local_flatpak_refspecs = find_matching_refs (local_refs,\n                                               NULL, NULL, NULL, NULL, NULL,\n                                               FLATPAK_KINDS_APP |\n                                               FLATPAK_KINDS_RUNTIME,\n                                               0, error);\n\n  if (!local_flatpak_refspecs)\n    return FALSE;\n\n  undeployed_refs = filter_out_deployed_refs (self, local_flatpak_refspecs, error);\n\n  if (!undeployed_refs)\n    return FALSE;\n\n  for (; i < undeployed_refs->len; ++i)\n    {\n      FlatpakDecomposed *ref = g_ptr_array_index (undeployed_refs, i);\n      g_autofree gchar *remote = flatpak_decomposed_dup_remote (ref);\n\n      if (!flatpak_dir_remove_ref (self, remote, flatpak_decomposed_get_ref (ref), cancellable, error))\n        return FALSE;\n    }\n\n  return TRUE;\n}\n\nstatic FlatpakDir *\nflatpak_dir_new_full (GFile *path, gboolean user, DirExtraData *extra_data)\n{\n  FlatpakDir *dir = g_object_new (FLATPAK_TYPE_DIR, \"path\", path, \"user\", user, NULL);\n\n  if (extra_data != NULL)\n    dir->extra_data = dir_extra_data_clone (extra_data);\n\n  return dir;\n}\n\nFlatpakDir *\nflatpak_dir_new (GFile *path, gboolean user)\n{\n  /* We are only interested on extra data for system-wide installations, in which\n     case we use _new_full() directly, so here we just call it passing NULL */\n  return flatpak_dir_new_full (path, user, NULL);\n}\n\nFlatpakDir *\nflatpak_dir_clone (FlatpakDir *self)\n{\n  FlatpakDir *clone;\n\n  clone = flatpak_dir_new_full (self->basedir, self->user, self->extra_data);\n\n  flatpak_dir_set_no_system_helper (clone, self->no_system_helper);\n  flatpak_dir_set_no_interaction (clone, self->no_interaction);\n\n  return clone;\n}\n\nFlatpakDir *\nflatpak_dir_get_system_default (void)\n{\n  g_autoptr(GFile) path = flatpak_get_system_default_base_dir_location ();\n  g_autoptr(DirExtraData) extra_data = dir_extra_data_new (SYSTEM_DIR_DEFAULT_ID,\n                                                           SYSTEM_DIR_DEFAULT_DISPLAY_NAME,\n                                                           SYSTEM_DIR_DEFAULT_PRIORITY,\n                                                           SYSTEM_DIR_DEFAULT_STORAGE_TYPE);\n  return flatpak_dir_new_full (path, FALSE, extra_data);\n}\n\n/* This figures out if it is a user or system dir automatically */\nFlatpakDir *\nflatpak_dir_get_by_path (GFile *path)\n{\n  GPtrArray *locations = flatpak_get_system_base_dir_locations (NULL, NULL);\n  int i;\n\n  if (locations)\n    {\n      for (i = 0; i < locations->len; i++)\n        {\n          GFile *system_path = g_ptr_array_index (locations, i);\n\n          if (g_file_equal (system_path, path))\n            {\n              DirExtraData *extra_data = g_object_get_data (G_OBJECT (path), \"extra-data\");\n              return flatpak_dir_new_full (path, FALSE, extra_data);\n            }\n        }\n    }\n\n  /* If its not configured as a system installation it will not have\n     an installation id and we can't use the system helper, so assume\n     user (and fail later with permission issues if its not owned by\n     the caller) */\n\n  return flatpak_dir_new (path, TRUE);\n}\n\nFlatpakDir *\nflatpak_dir_get_system_by_id (const char   *id,\n                              GCancellable *cancellable,\n                              GError      **error)\n{\n  g_autoptr(GError) local_error = NULL;\n  GPtrArray *locations = NULL;\n  FlatpakDir *ret = NULL;\n  int i;\n\n  if (id == NULL || g_strcmp0 (id, SYSTEM_DIR_DEFAULT_ID) == 0)\n    return flatpak_dir_get_system_default ();\n\n  /* An error in flatpak_get_system_base_dir_locations() will still return\n   * return an empty array with the GError set, but we want to return NULL.\n   */\n  locations = flatpak_get_system_base_dir_locations (cancellable, &local_error);\n  if (local_error != NULL)\n    {\n      g_propagate_error (error, g_steal_pointer (&local_error));\n      return NULL;\n    }\n\n  for (i = 0; i < locations->len; i++)\n    {\n      GFile *path = g_ptr_array_index (locations, i);\n      DirExtraData *extra_data = g_object_get_data (G_OBJECT (path), \"extra-data\");\n      if (extra_data != NULL && g_strcmp0 (extra_data->id, id) == 0)\n        {\n          ret = flatpak_dir_new_full (path, FALSE, extra_data);\n          break;\n        }\n    }\n\n  if (ret == NULL)\n    {\n      g_set_error (error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND,\n                   _(\"Could not find installation %s\"), id);\n    }\n\n  return ret;\n}\n\nGPtrArray *\nflatpak_dir_get_system_list (GCancellable *cancellable,\n                             GError      **error)\n{\n  g_autoptr(GPtrArray) result = NULL;\n  g_autoptr(GError) local_error = NULL;\n  GPtrArray *locations = NULL;\n  int i;\n\n  /* An error in flatpak_get_system_base_dir_locations() will still return\n   * return an empty array with the GError set, but we want to return NULL.\n   */\n  locations = flatpak_get_system_base_dir_locations (cancellable, &local_error);\n  if (local_error != NULL)\n    {\n      g_propagate_error (error, g_steal_pointer (&local_error));\n      return NULL;\n    }\n\n  result = g_ptr_array_new_with_free_func (g_object_unref);\n  for (i = 0; i < locations->len; i++)\n    {\n      GFile *path = g_ptr_array_index (locations, i);\n      DirExtraData *extra_data = g_object_get_data (G_OBJECT (path), \"extra-data\");\n      g_ptr_array_add (result, flatpak_dir_new_full (path, FALSE, extra_data));\n    }\n\n  return g_steal_pointer (&result);\n}\n\nFlatpakDir *\nflatpak_dir_get_user (void)\n{\n  g_autoptr(GFile) path = flatpak_get_user_base_dir_location ();\n  return flatpak_dir_new (path, TRUE);\n}\n\nstatic char *\nget_group (const char *remote_name)\n{\n  return g_strdup_printf (\"remote \\\"%s\\\"\", remote_name);\n}\n\nstatic GKeyFile *\nflatpak_dir_get_repo_config (FlatpakDir *self)\n{\n  if (!flatpak_dir_ensure_repo (self, NULL, NULL))\n    return NULL;\n\n  return ostree_repo_get_config (self->repo);\n}\n\nchar **\nflatpak_dir_list_remote_config_keys (FlatpakDir *self,\n                                     const char *remote_name)\n{\n  GKeyFile *config = flatpak_dir_get_repo_config (self);\n  g_autofree char *group = get_group (remote_name);\n\n  if (config)\n    return g_key_file_get_keys (config, group, NULL, NULL);\n\n  return NULL;\n}\n\nstatic void\nadd_subdirs (GPtrArray *res,\n             GFile     *parent,\n             gboolean   recurse)\n{\n  g_autoptr(GFileEnumerator) dir_enum = NULL;\n\n  dir_enum = g_file_enumerate_children (parent,\n                                        G_FILE_ATTRIBUTE_STANDARD_NAME \",\"\n                                        G_FILE_ATTRIBUTE_STANDARD_TYPE,\n                                        G_FILE_QUERY_INFO_NONE,\n                                        NULL, NULL);\n  if (dir_enum == NULL)\n    return;\n\n  while (TRUE)\n    {\n      GFileInfo *info;\n      GFile *path;\n\n      if (!g_file_enumerator_iterate (dir_enum, &info, &path, NULL, NULL) ||\n          info == NULL)\n        break;\n\n      /* Here we support either a plain repo or, if @recurse is TRUE, the root\n       * directory of a USB created with \"flatpak create-usb\"\n       */\n      if (g_file_info_get_file_type (info) == G_FILE_TYPE_DIRECTORY)\n        {\n          g_autoptr(OstreeRepo) repo = ostree_repo_new (path);\n\n          if (ostree_repo_open (repo, NULL, NULL))\n            g_ptr_array_add (res, g_object_ref (path));\n          else if (recurse)\n            {\n              g_autoptr(GFile) ostree_repo_subpath = NULL;\n              g_autoptr(GFile) dot_ostree_repo_subpath = NULL;\n              g_autoptr(GFile) dot_ostree_repo_d_subpath = NULL;\n              g_autoptr(OstreeRepo) ostree_repo_subpath_repo = NULL;\n              g_autoptr(OstreeRepo) dot_ostree_repo_subpath_repo = NULL;\n\n              ostree_repo_subpath = g_file_resolve_relative_path (path, \"ostree/repo\");\n              ostree_repo_subpath_repo = ostree_repo_new (ostree_repo_subpath);\n              if (ostree_repo_open (ostree_repo_subpath_repo, NULL, NULL))\n                g_ptr_array_add (res, g_object_ref (ostree_repo_subpath));\n\n              dot_ostree_repo_subpath = g_file_resolve_relative_path (path, \".ostree/repo\");\n              dot_ostree_repo_subpath_repo = ostree_repo_new (dot_ostree_repo_subpath);\n              if (ostree_repo_open (dot_ostree_repo_subpath_repo, NULL, NULL))\n                g_ptr_array_add (res, g_object_ref (dot_ostree_repo_subpath));\n\n              dot_ostree_repo_d_subpath = g_file_resolve_relative_path (path, \".ostree/repos.d\");\n              add_subdirs (res, dot_ostree_repo_d_subpath, FALSE);\n            }\n        }\n    }\n}\n\nGPtrArray *\nflatpak_dir_get_sideload_repo_paths (FlatpakDir *self)\n{\n  g_autoptr(GFile) sideload_repos_dir = flatpak_dir_get_sideload_repos_dir (self);\n  g_autoptr(GFile) runtime_sideload_repos_dir = flatpak_dir_get_runtime_sideload_repos_dir (self);\n  g_autoptr(GPtrArray) res = g_ptr_array_new_with_free_func (g_object_unref);\n\n  add_subdirs (res, sideload_repos_dir, TRUE);\n  add_subdirs (res, runtime_sideload_repos_dir, TRUE);\n\n  return g_steal_pointer (&res);\n}\n\n\nchar *\nflatpak_dir_get_remote_title (FlatpakDir *self,\n                              const char *remote_name)\n{\n  GKeyFile *config = flatpak_dir_get_repo_config (self);\n  g_autofree char *group = get_group (remote_name);\n\n  if (config)\n    return g_key_file_get_string (config, group, \"xa.title\", NULL);\n\n  return NULL;\n}\n\nstatic const char *\ncanonical_filter (const char *filter)\n{\n  /* Canonicalize \"no filter\", to NULL (empty means the same) */\n  if (filter && *filter == 0)\n    return NULL;\n  return filter;\n}\n\ngboolean\nflatpak_dir_compare_remote_filter (FlatpakDir *self,\n                                   const char *remote_name,\n                                   const char *filter)\n{\n  g_autofree char *current_filter = flatpak_dir_get_remote_filter (self, remote_name);\n\n  return g_strcmp0 (current_filter, canonical_filter (filter)) == 0;\n}\n\n/* returns the canonical form */\nchar *\nflatpak_dir_get_remote_filter (FlatpakDir *self,\n                               const char *remote_name)\n{\n  GKeyFile *config = flatpak_dir_get_repo_config (self);\n  g_autofree char *group = get_group (remote_name);\n\n  if (config)\n    {\n      g_autofree char *filter = g_key_file_get_string (config, group, \"xa.filter\", NULL);\n\n      if (filter && *filter != 0)\n        return g_steal_pointer (&filter);\n    }\n\n  return NULL;\n}\n\nchar *\nflatpak_dir_get_remote_comment (FlatpakDir *self,\n                                const char *remote_name)\n{\n  GKeyFile *config = flatpak_dir_get_repo_config (self);\n  g_autofree char *group = get_group (remote_name);\n\n  if (config)\n    return g_key_file_get_string (config, group, \"xa.comment\", NULL);\n\n  return NULL;\n}\n\nchar *\nflatpak_dir_get_remote_description (FlatpakDir *self,\n                                    const char *remote_name)\n{\n  GKeyFile *config = flatpak_dir_get_repo_config (self);\n  g_autofree char *group = get_group (remote_name);\n\n  if (config)\n    return g_key_file_get_string (config, group, \"xa.description\", NULL);\n\n  return NULL;\n}\n\nchar *\nflatpak_dir_get_remote_homepage (FlatpakDir *self,\n                                 const char *remote_name)\n{\n  GKeyFile *config = flatpak_dir_get_repo_config (self);\n  g_autofree char *group = get_group (remote_name);\n\n  if (config)\n    return g_key_file_get_string (config, group, \"xa.homepage\", NULL);\n\n  return NULL;\n}\n\nchar *\nflatpak_dir_get_remote_icon (FlatpakDir *self,\n                             const char *remote_name)\n{\n  GKeyFile *config = flatpak_dir_get_repo_config (self);\n  g_autofree char *group = get_group (remote_name);\n\n  if (config)\n    return g_key_file_get_string (config, group, \"xa.icon\", NULL);\n\n  return NULL;\n}\n\ngboolean\nflatpak_dir_get_remote_oci (FlatpakDir *self,\n                            const char *remote_name)\n{\n  g_autofree char *url = NULL;\n\n  if (!flatpak_dir_ensure_repo (self, NULL, NULL))\n    return FALSE;\n\n  if (!ostree_repo_remote_get_url (self->repo, remote_name, &url, NULL))\n    return FALSE;\n\n  return url && g_str_has_prefix (url, \"oci+\");\n}\n\ngint32\nflatpak_dir_get_remote_default_token_type (FlatpakDir *self,\n                                           const char *remote_name)\n{\n  GKeyFile *config = flatpak_dir_get_repo_config (self);\n  g_autofree char *group = get_group (remote_name);\n\n  if (config)\n    return (gint32)g_key_file_get_integer (config, group, \"xa.default-token-type\", NULL);\n\n  return 0;\n}\n\nchar *\nflatpak_dir_get_remote_main_ref (FlatpakDir *self,\n                                 const char *remote_name)\n{\n  GKeyFile *config = flatpak_dir_get_repo_config (self);\n  g_autofree char *group = get_group (remote_name);\n\n  if (config)\n    return g_key_file_get_string (config, group, \"xa.main-ref\", NULL);\n\n  return NULL;\n}\n\nchar *\nflatpak_dir_get_remote_default_branch (FlatpakDir *self,\n                                       const char *remote_name)\n{\n  GKeyFile *config = flatpak_dir_get_repo_config (self);\n  g_autofree char *group = get_group (remote_name);\n\n  if (config)\n    return g_key_file_get_string (config, group, \"xa.default-branch\", NULL);\n\n  return NULL;\n}\n\nint\nflatpak_dir_get_remote_prio (FlatpakDir *self,\n                             const char *remote_name)\n{\n  GKeyFile *config = flatpak_dir_get_repo_config (self);\n  g_autofree char *group = get_group (remote_name);\n\n  if (config && g_key_file_has_key (config, group, \"xa.prio\", NULL))\n    return g_key_file_get_integer (config, group, \"xa.prio\", NULL);\n\n  return 1;\n}\n\ngboolean\nflatpak_dir_get_remote_noenumerate (FlatpakDir *self,\n                                    const char *remote_name)\n{\n  GKeyFile *config = flatpak_dir_get_repo_config (self);\n  g_autofree char *group = get_group (remote_name);\n\n  if (config)\n    return g_key_file_get_boolean (config, group, \"xa.noenumerate\", NULL);\n\n  return TRUE;\n}\n\ngboolean\nflatpak_dir_get_remote_nodeps (FlatpakDir *self,\n                               const char *remote_name)\n{\n  GKeyFile *config = flatpak_dir_get_repo_config (self);\n  g_autofree char *group = get_group (remote_name);\n\n  if (config)\n    return g_key_file_get_boolean (config, group, \"xa.nodeps\", NULL);\n\n  return TRUE;\n}\n\nchar *\nflatpak_dir_get_remote_subset (FlatpakDir *self,\n                               const char *remote_name)\n{\n  GKeyFile *config = flatpak_dir_get_repo_config (self);\n  g_autofree char *group = get_group (remote_name);\n  g_autofree char *subset = NULL;\n\n  if (config == NULL)\n    return NULL;\n\n  subset = g_key_file_get_string (config, group, \"xa.subset\", NULL);\n  if (subset == NULL || *subset == 0)\n    return NULL;\n\n  return g_steal_pointer (&subset);\n}\n\ngboolean\nflatpak_dir_get_remote_disabled (FlatpakDir *self,\n                                 const char *remote_name)\n{\n  GKeyFile *config = flatpak_dir_get_repo_config (self);\n  g_autofree char *group = get_group (remote_name);\n  g_autofree char *url = NULL;\n\n  if (config &&\n      g_key_file_get_boolean (config, group, \"xa.disable\", NULL))\n    return TRUE;\n\n  if (self->repo &&\n      ostree_repo_remote_get_url (self->repo, remote_name, &url, NULL) && *url == 0)\n    return TRUE; /* Empty URL => disabled */\n\n  return FALSE;\n}\n\nstatic char *\nflatpak_dir_get_remote_install_authenticator_name (FlatpakDir *self,\n                                                   const char *remote_name)\n{\n  GKeyFile *config = flatpak_dir_get_repo_config (self);\n  g_autofree char *group = get_group (remote_name);\n\n  if (config == NULL ||\n      !g_key_file_get_boolean (config, group, \"xa.authenticator-install\", NULL))\n    return NULL;\n\n  return g_key_file_get_string (config, group, \"xa.authenticator-name\", NULL);\n}\n\ngboolean\nflatpak_dir_remote_has_deploys (FlatpakDir *self,\n                                const char *remote)\n{\n  g_autoptr(GHashTable) refs = NULL;\n  GHashTableIter hash_iter;\n  gpointer key;\n\n  refs = flatpak_dir_get_all_installed_refs (self, FLATPAK_KINDS_APP | FLATPAK_KINDS_RUNTIME, NULL);\n  if (refs == NULL)\n    return FALSE;\n\n  g_hash_table_iter_init (&hash_iter, refs);\n  while (g_hash_table_iter_next (&hash_iter, &key, NULL))\n    {\n      FlatpakDecomposed *ref = key;\n      g_autofree char *origin = flatpak_dir_get_origin (self, ref, NULL, NULL);\n\n      if (strcmp (remote, origin) == 0)\n        return TRUE;\n    }\n\n  return FALSE;\n}\n\nstatic gint\ncmp_remote (gconstpointer a,\n            gconstpointer b,\n            gpointer      user_data)\n{\n  FlatpakDir *self = user_data;\n  const char *a_name = *(const char **) a;\n  const char *b_name = *(const char **) b;\n  int prio_a, prio_b;\n\n  prio_a = flatpak_dir_get_remote_prio (self, a_name);\n  prio_b = flatpak_dir_get_remote_prio (self, b_name);\n\n  if (prio_b != prio_a)\n    return prio_b - prio_a;\n\n  /* Ensure we have a well-defined order for same prio */\n  return strcmp (a_name, b_name);\n}\n\nstatic gboolean\norigin_remote_matches (OstreeRepo *repo,\n                       const char *remote_name,\n                       const char *url,\n                       const char *main_ref,\n                       gboolean    gpg_verify)\n{\n  g_autofree char *real_url = NULL;\n  g_autofree char *real_main_ref = NULL;\n  gboolean noenumerate;\n  gboolean real_gpg_verify;\n\n  /* Must match url */\n  if (url == NULL)\n    return FALSE;\n\n  if (!ostree_repo_remote_get_url (repo, remote_name, &real_url, NULL))\n    return FALSE;\n\n  if (g_strcmp0 (url, real_url) != 0)\n    return FALSE;\n\n  /* Must be noenumerate */\n  if (!ostree_repo_get_remote_boolean_option (repo, remote_name,\n                                              \"xa.noenumerate\",\n                                              FALSE, &noenumerate,\n                                              NULL) ||\n      !noenumerate)\n    return FALSE;\n\n  /* Must match gpg-verify\n   * NOTE: We assume if all else matches the actual gpg key matches too. */\n  if (!ostree_repo_get_remote_boolean_option (repo, remote_name,\n                                              \"gpg-verify\",\n                                              FALSE, &real_gpg_verify,\n                                              NULL) ||\n      real_gpg_verify != gpg_verify)\n    return FALSE;\n\n  /* Must match main-ref */\n  if (ostree_repo_get_remote_option (repo, remote_name,\n                                     \"xa.main-ref\",\n                                     NULL, &real_main_ref,\n                                     NULL) &&\n      g_strcmp0 (main_ref, real_main_ref) != 0)\n    return FALSE;\n\n  return TRUE;\n}\n\nstatic char *\ncreate_origin_remote_config (OstreeRepo *repo,\n                             const char *url,\n                             const char *id,\n                             const char *title,\n                             const char *main_ref,\n                             gboolean    gpg_verify,\n                             const char *collection_id,\n                             GKeyFile  **new_config)\n{\n  g_autofree char *remote = NULL;\n  g_auto(GStrv) remotes = NULL;\n  int version = 0;\n  g_autofree char *group = NULL;\n  g_autofree char *prefix = NULL;\n  const char *last_dot;\n\n  remotes = ostree_repo_remote_list (repo, NULL);\n\n  last_dot = strrchr (id, '.');\n  prefix = g_ascii_strdown (last_dot ? last_dot + 1 : id, -1);\n\n  do\n    {\n      g_autofree char *name = NULL;\n      if (version == 0)\n        name = g_strdup_printf (\"%s-origin\", prefix);\n      else\n        name = g_strdup_printf (\"%s%d-origin\", prefix, version);\n      version++;\n\n      if (origin_remote_matches (repo, name, url, main_ref, gpg_verify))\n        return g_steal_pointer (&name);\n\n      if (remotes == NULL ||\n          !g_strv_contains ((const char * const *) remotes, name))\n        remote = g_steal_pointer (&name);\n    }\n  while (remote == NULL);\n\n  group = g_strdup_printf (\"remote \\\"%s\\\"\", remote);\n\n  *new_config = g_key_file_new ();\n\n  g_key_file_set_string (*new_config, group, \"url\", url ? url : \"\");\n  if (title)\n    g_key_file_set_string (*new_config, group, \"xa.title\", title);\n  g_key_file_set_string (*new_config, group, \"xa.noenumerate\", \"true\");\n  g_key_file_set_string (*new_config, group, \"xa.prio\", \"0\");\n  g_key_file_set_string (*new_config, group, \"gpg-verify-summary\", gpg_verify ? \"true\" : \"false\");\n  g_key_file_set_string (*new_config, group, \"gpg-verify\", gpg_verify ? \"true\" : \"false\");\n  if (main_ref)\n    g_key_file_set_string (*new_config, group, \"xa.main-ref\", main_ref);\n\n  if (collection_id)\n    g_key_file_set_string (*new_config, group, \"collection-id\", collection_id);\n\n  return g_steal_pointer (&remote);\n}\n\nchar *\nflatpak_dir_create_origin_remote (FlatpakDir   *self,\n                                  const char   *url,\n                                  const char   *id,\n                                  const char   *title,\n                                  const char   *main_ref,\n                                  GBytes       *gpg_data,\n                                  const char   *collection_id,\n                                  gboolean     *changed_config,\n                                  GCancellable *cancellable,\n                                  GError      **error)\n{\n  g_autoptr(GKeyFile) new_config = NULL;\n  g_autofree char *remote = NULL;\n\n  remote = create_origin_remote_config (self->repo, url, id, title, main_ref, gpg_data != NULL, collection_id, &new_config);\n\n  if (new_config &&\n      !flatpak_dir_modify_remote (self, remote, new_config,\n                                  gpg_data, cancellable, error))\n    return NULL;\n\n  if (new_config && !_flatpak_dir_reload_config (self, cancellable, error))\n    return FALSE;\n\n  if (changed_config)\n    *changed_config = (new_config != NULL);\n\n  return g_steal_pointer (&remote);\n}\n\nstatic gboolean\nparse_ref_file (GKeyFile *keyfile,\n                char    **name_out,\n                char    **branch_out,\n                char    **url_out,\n                char    **title_out,\n                GBytes  **gpg_data_out,\n                gboolean *is_runtime_out,\n                char    **collection_id_out,\n                GError  **error)\n{\n  g_autofree char *url = NULL;\n  g_autofree char *title = NULL;\n  g_autofree char *name = NULL;\n  g_autofree char *branch = NULL;\n  g_autofree char *version = NULL;\n  g_autoptr(GBytes) gpg_data = NULL;\n  gboolean is_runtime = FALSE;\n  g_autofree char *collection_id = NULL;\n  g_autofree char *str = NULL;\n\n  *name_out = NULL;\n  *branch_out = NULL;\n  *url_out = NULL;\n  *title_out = NULL;\n  *gpg_data_out = NULL;\n  *is_runtime_out = FALSE;\n\n  if (!g_key_file_has_group (keyfile, FLATPAK_REF_GROUP))\n    return flatpak_fail_error (error, FLATPAK_ERROR_INVALID_DATA, _(\"Invalid file format, no %s group\"), FLATPAK_REF_GROUP);\n\n  version = g_key_file_get_string (keyfile, FLATPAK_REF_GROUP,\n                                   FLATPAK_REF_VERSION_KEY, NULL);\n  if (version != NULL && strcmp (version, \"1\") != 0)\n    return flatpak_fail_error (error, FLATPAK_ERROR_INVALID_DATA, _(\"Invalid version %s, only 1 supported\"), version);\n\n  url = g_key_file_get_string (keyfile, FLATPAK_REF_GROUP,\n                               FLATPAK_REF_URL_KEY, NULL);\n  if (url == NULL)\n    return flatpak_fail_error (error, FLATPAK_ERROR_INVALID_DATA, _(\"Invalid file format, no %s specified\"), FLATPAK_REF_URL_KEY);\n\n  name = g_key_file_get_string (keyfile, FLATPAK_REF_GROUP,\n                                FLATPAK_REF_NAME_KEY, NULL);\n  if (name == NULL)\n    return flatpak_fail_error (error, FLATPAK_ERROR_INVALID_DATA, _(\"Invalid file format, no %s specified\"), FLATPAK_REF_NAME_KEY);\n\n  branch = g_key_file_get_string (keyfile, FLATPAK_REF_GROUP,\n                                  FLATPAK_REF_BRANCH_KEY, NULL);\n  if (branch == NULL)\n    branch = g_strdup (\"master\");\n\n  title = g_key_file_get_string (keyfile, FLATPAK_REF_GROUP,\n                                 FLATPAK_REF_TITLE_KEY, NULL);\n\n  is_runtime = g_key_file_get_boolean (keyfile, FLATPAK_REF_GROUP,\n                                       FLATPAK_REF_IS_RUNTIME_KEY, NULL);\n\n  str = g_key_file_get_string (keyfile, FLATPAK_REF_GROUP,\n                               FLATPAK_REF_GPGKEY_KEY, NULL);\n  if (str != NULL)\n    {\n      g_autofree guchar *decoded = NULL;\n      gsize decoded_len;\n\n      str = g_strstrip (str);\n      decoded = g_base64_decode (str, &decoded_len);\n      if (decoded_len < 10) /* Check some minimal size so we don't get crap */\n        return flatpak_fail_error (error, FLATPAK_ERROR_INVALID_DATA, _(\"Invalid file format, gpg key invalid\"));\n\n      gpg_data = g_bytes_new_take (g_steal_pointer (&decoded), decoded_len);\n    }\n\n  collection_id = g_key_file_get_string (keyfile, FLATPAK_REF_GROUP,\n                                         FLATPAK_REF_DEPLOY_COLLECTION_ID_KEY, NULL);\n\n  if (collection_id == NULL || *collection_id == '\\0')\n    {\n      collection_id = g_key_file_get_string (keyfile, FLATPAK_REF_GROUP,\n                                             FLATPAK_REF_COLLECTION_ID_KEY, NULL);\n    }\n\n  if (collection_id != NULL && *collection_id == '\\0')\n    collection_id = NULL;\n\n  if (collection_id != NULL && gpg_data == NULL)\n    return flatpak_fail_error (error, FLATPAK_ERROR_INVALID_DATA, _(\"Collection ID requires GPG key to be provided\"));\n\n  *name_out = g_steal_pointer (&name);\n  *branch_out = g_steal_pointer (&branch);\n  *url_out = g_steal_pointer (&url);\n  *title_out = g_steal_pointer (&title);\n  *gpg_data_out = g_steal_pointer (&gpg_data);\n  *is_runtime_out = is_runtime;\n  *collection_id_out = g_steal_pointer (&collection_id);\n\n  return TRUE;\n}\n\ngboolean\nflatpak_dir_create_remote_for_ref_file (FlatpakDir         *self,\n                                        GKeyFile           *keyfile,\n                                        const char         *default_arch,\n                                        char              **remote_name_out,\n                                        char              **collection_id_out,\n                                        FlatpakDecomposed **ref_out,\n                                        GError            **error)\n{\n  g_autoptr(GBytes) gpg_data = NULL;\n  g_autofree char *name = NULL;\n  g_autofree char *branch = NULL;\n  g_autofree char *url = NULL;\n  g_autofree char *title = NULL;\n  g_autofree char *remote = NULL;\n  gboolean is_runtime = FALSE;\n  g_autofree char *collection_id = NULL;\n  g_autoptr(GFile) deploy_dir = NULL;\n  g_autoptr(FlatpakDecomposed) ref = NULL;\n\n  if (!parse_ref_file (keyfile, &name, &branch, &url, &title, &gpg_data, &is_runtime, &collection_id, error))\n    return FALSE;\n\n  ref = flatpak_decomposed_new_from_parts (is_runtime ? FLATPAK_KINDS_RUNTIME : FLATPAK_KINDS_APP,\n                                           name, default_arch, branch, error);\n  if (ref == NULL)\n    return FALSE;\n\n  deploy_dir = flatpak_dir_get_if_deployed (self, ref, NULL, NULL);\n  if (deploy_dir != NULL)\n    {\n      g_set_error (error, FLATPAK_ERROR, FLATPAK_ERROR_ALREADY_INSTALLED,\n                   is_runtime ? _(\"Runtime %s, branch %s is already installed\") :\n                   _(\"App %s, branch %s is already installed\"),\n                   name, branch);\n      return FALSE;\n    }\n\n  /* First try to reuse existing remote */\n  remote = flatpak_dir_find_remote_by_uri (self, url);\n\n  if (remote == NULL)\n    {\n      remote = flatpak_dir_create_origin_remote (self, url, name, title, flatpak_decomposed_get_ref (ref),\n                                                 gpg_data, collection_id, NULL, NULL, error);\n      if (remote == NULL)\n        return FALSE;\n    }\n\n  if (collection_id_out != NULL)\n    *collection_id_out = g_steal_pointer (&collection_id);\n\n  *remote_name_out = g_steal_pointer (&remote);\n  *ref_out = g_steal_pointer (&ref);\n  return TRUE;\n}\n\nstatic gboolean\n_flatpak_uri_equal (const char *uri1,\n                    const char *uri2)\n{\n  g_autofree char *uri1_norm = NULL;\n  g_autofree char *uri2_norm = NULL;\n  gsize uri1_len = strlen (uri1);\n  gsize uri2_len = strlen (uri2);\n\n  /* URIs handled by libostree are equivalent with or without a trailing slash,\n   * but this isn't otherwise guaranteed to be the case.\n   */\n  if (g_str_has_prefix (uri1, \"oci+\") || g_str_has_prefix (uri2, \"oci+\"))\n    return g_strcmp0 (uri1, uri2) == 0;\n\n  if (g_str_has_suffix (uri1, \"/\"))\n    uri1_norm = g_strndup (uri1, uri1_len - 1);\n  else\n    uri1_norm = g_strdup (uri1);\n\n  if (g_str_has_suffix (uri2, \"/\"))\n    uri2_norm = g_strndup (uri2, uri2_len - 1);\n  else\n    uri2_norm = g_strdup (uri2);\n\n  return g_strcmp0 (uri1_norm, uri2_norm) == 0;\n}\n\n/* This tries to find a pre-configured remote for the specified uri.\n *\n *  We consider non-OCI URLs equal even if one lacks a trailing slash.\n */\nchar *\nflatpak_dir_find_remote_by_uri (FlatpakDir *self,\n                                const char *uri)\n{\n  g_auto(GStrv) remotes = NULL;\n\n  g_return_val_if_fail (self != NULL, NULL);\n  g_return_val_if_fail (uri != NULL, NULL);\n\n  if (!flatpak_dir_ensure_repo (self, NULL, NULL))\n    return NULL;\n\n  remotes = flatpak_dir_list_enumerated_remotes (self, NULL, NULL);\n  if (remotes)\n    {\n      int i;\n\n      for (i = 0; remotes != NULL && remotes[i] != NULL; i++)\n        {\n          const char *remote = remotes[i];\n          g_autofree char *remote_uri = NULL;\n\n          if (!ostree_repo_remote_get_url (self->repo,\n                                           remote,\n                                           &remote_uri,\n                                           NULL))\n            continue;\n\n          if (_flatpak_uri_equal (uri, remote_uri))\n            return g_strdup (remote);\n        }\n    }\n\n  return NULL;\n}\n\ngboolean\nflatpak_dir_has_remote (FlatpakDir *self,\n                        const char *remote_name,\n                        GError    **error)\n{\n  GKeyFile *config = NULL;\n  g_autofree char *group = g_strdup_printf (\"remote \\\"%s\\\"\", remote_name);\n\n  if (flatpak_dir_maybe_ensure_repo (self, NULL, NULL) &&\n      self->repo != NULL)\n    {\n      config = ostree_repo_get_config (self->repo);\n      if (config && g_key_file_has_group (config, group))\n        return TRUE;\n    }\n\n  return flatpak_fail_error (error, FLATPAK_ERROR_REMOTE_NOT_FOUND,\n                             \"Remote \\\"%s\\\" not found\", remote_name);\n}\n\n\nchar **\nflatpak_dir_list_remotes (FlatpakDir   *self,\n                          GCancellable *cancellable,\n                          GError      **error)\n{\n  char **res = NULL;\n\n  if (!flatpak_dir_maybe_ensure_repo (self, cancellable, error))\n    return NULL;\n\n  if (self->repo)\n    res = ostree_repo_remote_list (self->repo, NULL);\n\n  if (res == NULL)\n    res = g_new0 (char *, 1); /* Return empty array, not error */\n\n  g_qsort_with_data (res, g_strv_length (res), sizeof (char *),\n                     cmp_remote, self);\n\n  return res;\n}\n\nchar **\nflatpak_dir_list_enumerated_remotes (FlatpakDir   *self,\n                                     GCancellable *cancellable,\n                                     GError      **error)\n{\n  g_autoptr(GPtrArray) res = g_ptr_array_new_with_free_func (g_free);\n  g_auto(GStrv) remotes = NULL;\n  int i;\n\n  remotes = flatpak_dir_list_remotes (self, cancellable, error);\n  if (remotes == NULL)\n    return NULL;\n\n  for (i = 0; remotes != NULL && remotes[i] != NULL; i++)\n    {\n      const char *remote = remotes[i];\n\n      if (flatpak_dir_get_remote_disabled (self, remote))\n        continue;\n\n      if (flatpak_dir_get_remote_noenumerate (self, remote))\n        continue;\n\n      g_ptr_array_add (res, g_strdup (remote));\n    }\n\n  g_ptr_array_add (res, NULL);\n  return (char **) g_ptr_array_free (g_steal_pointer (&res), FALSE);\n}\n\nchar **\nflatpak_dir_list_dependency_remotes (FlatpakDir   *self,\n                                     GCancellable *cancellable,\n                                     GError      **error)\n{\n  g_autoptr(GPtrArray) res = g_ptr_array_new_with_free_func (g_free);\n  g_auto(GStrv) remotes = NULL;\n  int i;\n\n  remotes = flatpak_dir_list_remotes (self, cancellable, error);\n  if (remotes == NULL)\n    return NULL;\n\n  for (i = 0; remotes != NULL && remotes[i] != NULL; i++)\n    {\n      const char *remote = remotes[i];\n\n      if (flatpak_dir_get_remote_disabled (self, remote))\n        continue;\n\n      if (flatpak_dir_get_remote_noenumerate (self, remote))\n        continue;\n\n      if (flatpak_dir_get_remote_nodeps (self, remote))\n        continue;\n\n      g_ptr_array_add (res, g_strdup (remote));\n    }\n\n  g_ptr_array_add (res, NULL);\n  return (char **) g_ptr_array_free (g_steal_pointer (&res), FALSE);\n}\n\ngboolean\nflatpak_dir_remove_remote (FlatpakDir   *self,\n                           gboolean      force_remove,\n                           const char   *remote_name,\n                           GCancellable *cancellable,\n                           GError      **error)\n{\n  g_autofree char *prefix = NULL;\n  g_autoptr(GHashTable) refs = NULL;\n  GHashTableIter hash_iter;\n  gpointer key;\n  g_autofree char *url = NULL;\n\n  if (flatpak_dir_use_system_helper (self, NULL))\n    {\n      g_autoptr(GVariant) gpg_data_v = NULL;\n      FlatpakHelperConfigureRemoteFlags flags = 0;\n      const char *installation = flatpak_dir_get_id (self);\n\n      gpg_data_v = g_variant_ref_sink (g_variant_new_from_data (G_VARIANT_TYPE (\"ay\"), \"\", 0, TRUE, NULL, NULL));\n\n      if (force_remove)\n        flags |= FLATPAK_HELPER_CONFIGURE_REMOTE_FLAGS_FORCE_REMOVE;\n\n      if (!flatpak_dir_system_helper_call_configure_remote (self,\n                                                            flags, remote_name,\n                                                            \"\",\n                                                            gpg_data_v,\n                                                            installation ? installation : \"\",\n                                                            cancellable, error))\n        return FALSE;\n\n      return TRUE;\n    }\n\n  if (!flatpak_dir_ensure_repo (self, cancellable, error))\n    return FALSE;\n\n  if (!ostree_repo_list_refs (self->repo,\n                              NULL,\n                              &refs,\n                              cancellable, error))\n    return FALSE;\n\n  prefix = g_strdup_printf (\"%s:\", remote_name);\n\n  if (!force_remove)\n    {\n      g_hash_table_iter_init (&hash_iter, refs);\n      while (g_hash_table_iter_next (&hash_iter, &key, NULL))\n        {\n          const char *refspec = key;\n\n          if (!g_str_has_prefix (refspec, prefix))\n            continue;\n\n          g_autoptr(FlatpakDecomposed) ref = flatpak_decomposed_new_from_refspec (refspec, NULL);\n          if (ref == NULL)\n            continue;\n\n          g_autofree char *origin = flatpak_dir_get_origin (self, ref, cancellable, NULL);\n          if (g_strcmp0 (origin, remote_name) == 0)\n            return flatpak_fail_error (error, FLATPAK_ERROR_REMOTE_USED,\n                                       _(\"Can't remove remote '%s' with installed ref %s (at least)\"),\n                                       remote_name, flatpak_decomposed_get_ref (ref));\n        }\n    }\n\n  /* Remove all refs */\n  g_hash_table_iter_init (&hash_iter, refs);\n  while (g_hash_table_iter_next (&hash_iter, &key, NULL))\n    {\n      const char *refspec = key;\n\n      if (g_str_has_prefix (refspec, prefix) &&\n          !flatpak_dir_remove_ref (self, remote_name, refspec + strlen (prefix), cancellable, error))\n        return FALSE;\n    }\n\n  if (!flatpak_dir_remove_appstream (self, remote_name,\n                                     cancellable, error))\n    return FALSE;\n\n  if (flatpak_dir_get_remote_oci (self, remote_name) &&\n      !flatpak_dir_remove_oci_files (self, remote_name,\n                                     cancellable, error))\n    return FALSE;\n\n  ostree_repo_remote_get_url (self->repo, remote_name, &url, NULL);\n\n  if (!ostree_repo_remote_change (self->repo, NULL,\n                                  OSTREE_REPO_REMOTE_CHANGE_DELETE,\n                                  remote_name, NULL,\n                                  NULL,\n                                  cancellable, error))\n    return FALSE;\n\n  if (!flatpak_dir_mark_changed (self, error))\n    return FALSE;\n\n  flatpak_dir_log (self, \"remove remote\",\n                   remote_name, NULL, NULL, NULL, url,\n                   \"Removed remote %s\", remote_name);\n\n  return TRUE;\n}\n\nstatic gboolean\nflatpak_dir_cleanup_remote_for_url_change (FlatpakDir   *self,\n                                           const char   *remote_name,\n                                           const char   *url,\n                                           GCancellable *cancellable,\n                                           GError      **error)\n{\n  g_autofree char *old_url = NULL;\n\n  /* We store things a bit differently for OCI and non-OCI remotes,\n   * so when changing from one to the other, we need to clean up cached\n   * files.\n   */\n  if (ostree_repo_remote_get_url (self->repo,\n                                  remote_name,\n                                  &old_url,\n                                  NULL))\n    {\n      gboolean was_oci = g_str_has_prefix (old_url, \"oci+\");\n      gboolean will_be_oci = g_str_has_prefix (url, \"oci+\");\n\n      if (was_oci != will_be_oci)\n        {\n          if (!flatpak_dir_remove_appstream (self, remote_name,\n                                             cancellable, error))\n            return FALSE;\n        }\n\n      if (was_oci && !will_be_oci)\n        {\n          if (!flatpak_dir_remove_oci_files (self, remote_name,\n                                             cancellable, error))\n            return FALSE;\n        }\n    }\n\n  return TRUE;\n}\n\ngboolean\nflatpak_dir_modify_remote (FlatpakDir   *self,\n                           const char   *remote_name,\n                           GKeyFile     *config,\n                           GBytes       *gpg_data,\n                           GCancellable *cancellable,\n                           GError      **error)\n{\n  g_autofree char *group = g_strdup_printf (\"remote \\\"%s\\\"\", remote_name);\n  g_autofree char *url = NULL;\n  g_autofree char *metalink = NULL;\n  g_autoptr(GKeyFile) new_config = NULL;\n  g_autofree gchar *filter_path = NULL;\n  gboolean has_remote;\n\n  if (strchr (remote_name, '/') != NULL)\n    return flatpak_fail_error (error, FLATPAK_ERROR_REMOTE_NOT_FOUND, _(\"Invalid character '/' in remote name: %s\"),\n                               remote_name);\n\n  has_remote = flatpak_dir_has_remote (self, remote_name, NULL);\n\n  if (!g_key_file_has_group (config, group))\n    return flatpak_fail_error (error, FLATPAK_ERROR_INVALID_DATA, _(\"No configuration for remote %s specified\"),\n                               remote_name);\n\n  if (!flatpak_dir_check_add_remotes_config_dir (self, error))\n    return FALSE;\n\n  if (flatpak_dir_use_system_helper (self, NULL))\n    {\n      g_autofree char *config_data = g_key_file_to_data (config, NULL, NULL);\n      g_autoptr(GVariant) gpg_data_v = NULL;\n      const char *installation = flatpak_dir_get_id (self);\n\n      if (gpg_data != NULL)\n        gpg_data_v = variant_new_ay_bytes (gpg_data);\n      else\n        gpg_data_v = g_variant_ref_sink (g_variant_new_from_data (G_VARIANT_TYPE (\"ay\"), \"\", 0, TRUE, NULL, NULL));\n\n      if (!flatpak_dir_system_helper_call_configure_remote (self,\n                                                            0, remote_name,\n                                                            config_data,\n                                                            gpg_data_v,\n                                                            installation ? installation : \"\",\n                                                            cancellable, error))\n        return FALSE;\n\n      /* If we e.g. changed url or gpg config the cached summary may be invalid */\n      if (!flatpak_dir_remote_clear_cached_summary (self, remote_name, cancellable, error))\n        return FALSE;\n\n      return TRUE;\n    }\n\n  metalink = g_key_file_get_string (config, group, \"metalink\", NULL);\n  if (metalink != NULL && *metalink != 0)\n    url = g_strconcat (\"metalink=\", metalink, NULL);\n  else\n    url = g_key_file_get_string (config, group, \"url\", NULL);\n\n  /* No url => disabled */\n  if (url == NULL)\n    url = g_strdup (\"\");\n\n  if (!flatpak_dir_cleanup_remote_for_url_change (self, remote_name, url, cancellable, error))\n    return FALSE;\n\n  /* Add it if its not there yet */\n  if (!ostree_repo_remote_change (self->repo, NULL,\n                                  OSTREE_REPO_REMOTE_CHANGE_ADD_IF_NOT_EXISTS,\n                                  remote_name,\n                                  url, NULL, cancellable, error))\n    return FALSE;\n\n  new_config = ostree_repo_copy_config (self->repo);\n\n  copy_remote_config (new_config, config, remote_name);\n\n  if (!ostree_repo_write_config (self->repo, new_config, error))\n    return FALSE;\n\n  if (gpg_data != NULL)\n    {\n      g_autoptr(GInputStream) input_stream = g_memory_input_stream_new_from_bytes (gpg_data);\n      guint imported = 0;\n\n      if (!ostree_repo_remote_gpg_import (self->repo, remote_name, input_stream,\n                                          NULL, &imported, cancellable, error))\n        return FALSE;\n\n      /* XXX If we ever add internationalization, use ngettext() here. */\n      g_debug (\"Imported %u GPG key%s to remote \\\"%s\\\"\",\n               imported, (imported == 1) ? \"\" : \"s\", remote_name);\n    }\n\n  filter_path = g_key_file_get_value (new_config, group, \"xa.filter\", NULL);\n  if (filter_path && *filter_path && g_file_test (filter_path, G_FILE_TEST_EXISTS))\n    {\n      /* Make a backup filter copy in case it goes away later */\n      g_autofree char *filter_name = g_strconcat (remote_name, \".filter\", NULL);\n      g_autoptr(GFile) filter_file = g_file_new_for_path (filter_path);\n      g_autoptr(GFile) filter_copy = flatpak_build_file (self->basedir, \"repo\", filter_name, NULL);\n      g_autoptr(GError) local_error = NULL;\n      g_autofree char *backup_data = NULL;\n      gsize backup_data_size;\n\n      if (g_file_load_contents (filter_file, cancellable, &backup_data, &backup_data_size, NULL, &local_error))\n        {\n          g_autofree char *backup_data_copy =\n            g_strdup_printf (\"# backup copy of %s, do not edit!\\n%s\", filter_path, backup_data);\n\n          if (!g_file_replace_contents (filter_copy, backup_data_copy, strlen (backup_data_copy),\n                                        NULL, FALSE, G_FILE_CREATE_REPLACE_DESTINATION, NULL, cancellable, &local_error))\n            g_debug (\"Failed to save backup copy of filter file %s: %s\\n\", filter_path, local_error->message);\n        }\n      else\n        {\n          g_debug (\"Failed to read filter %s file while making a backup copy: %s\\n\", filter_path, local_error->message);\n        }\n    }\n\n  /* If we e.g. changed url or gpg config the cached summary may be invalid */\n  if (!flatpak_dir_remote_clear_cached_summary (self, remote_name, cancellable, error))\n    return FALSE;\n\n  if (!flatpak_dir_mark_changed (self, error))\n    return FALSE;\n\n  if (has_remote)\n    flatpak_dir_log (self, \"modify remote\", remote_name, NULL, NULL, NULL, url,\n                     \"Modified remote %s to %s\", remote_name, url);\n  else\n    flatpak_dir_log (self, \"add remote\", remote_name, NULL, NULL, NULL, url,\n                     \"Added remote %s to %s\", remote_name, url);\n\n  return TRUE;\n}\n\nstatic gboolean\nremove_unless_decomposed_in_hash (gpointer key,\n                                  gpointer value,\n                                  gpointer user_data)\n{\n  GHashTable *table = user_data;\n  const FlatpakDecomposed *d = key;\n\n  return !g_hash_table_contains (table, d);\n}\n\ngboolean\nflatpak_dir_list_remote_refs (FlatpakDir         *self,\n                              FlatpakRemoteState *state,\n                              GHashTable        **refs,\n                              GCancellable       *cancellable,\n                              GError            **error)\n{\n  g_autoptr(GError) my_error = NULL;\n\n  if (error == NULL)\n    error = &my_error;\n\n  if (!flatpak_dir_list_all_remote_refs (self, state, refs,\n                                         cancellable, error))\n    return FALSE;\n\n  if (flatpak_dir_get_remote_noenumerate (self, state->remote_name))\n    {\n      g_autoptr(GHashTable) decomposed_local_refs =\n        g_hash_table_new_full ((GHashFunc)flatpak_decomposed_hash, (GEqualFunc)flatpak_decomposed_equal, (GDestroyNotify)flatpak_decomposed_unref, NULL);\n      g_autoptr(GHashTable) local_refs = NULL;\n      GHashTableIter hash_iter;\n      gpointer key;\n      g_autofree char *refspec_prefix = g_strconcat (state->remote_name, \":.\", NULL);\n\n      /* For noenumerate remotes, only return data for already locally\n       * available refs */\n\n      if (!ostree_repo_list_refs (self->repo, refspec_prefix, &local_refs,\n                                  cancellable, error))\n        return FALSE;\n\n      g_hash_table_iter_init (&hash_iter, local_refs);\n      while (g_hash_table_iter_next (&hash_iter, &key, NULL))\n        {\n          const char *refspec = key;\n          g_autoptr(FlatpakDecomposed) d = flatpak_decomposed_new_from_refspec (refspec, NULL);\n          if (d)\n            g_hash_table_insert (decomposed_local_refs, g_steal_pointer (&d), NULL);\n        }\n\n      /* Then we remove all remote refs not in the local refs set */\n      g_hash_table_foreach_remove (*refs,\n                                   remove_unless_decomposed_in_hash,\n                                   decomposed_local_refs);\n    }\n\n  return TRUE;\n}\n\nstatic gboolean\nstrv_contains_prefix (const gchar * const *strv,\n                      const gchar         *str)\n{\n  g_return_val_if_fail (strv != NULL, FALSE);\n  g_return_val_if_fail (str != NULL, FALSE);\n\n  for (; *strv != NULL; strv++)\n    {\n      if (g_str_has_prefix (str, *strv))\n        return TRUE;\n    }\n\n  return FALSE;\n}\n\ngboolean\nflatpak_dir_update_remote_configuration_for_state (FlatpakDir         *self,\n                                                   FlatpakRemoteState *remote_state,\n                                                   gboolean            dry_run,\n                                                   gboolean           *has_changed_out,\n                                                   GCancellable       *cancellable,\n                                                   GError            **error)\n{\n  /* We only support those configuration parameters that can\n     be set in the server when building the repo (see the\n     flatpak_repo_set_* () family of functions) */\n  static const char *const supported_params[] = {\n    \"xa.title\",\n    \"xa.comment\",\n    \"xa.description\",\n    \"xa.homepage\",\n    \"xa.icon\",\n    \"xa.default-branch\",\n    \"xa.gpg-keys\",\n    \"xa.redirect-url\",\n    \"xa.authenticator-name\",\n    \"xa.authenticator-install\",\n    OSTREE_META_KEY_DEPLOY_COLLECTION_ID,\n    \"xa.deploy-collection-id\", /* This is a new version only supported in post p2p flatpak (1.7) */\n    NULL\n  };\n  static const char *const supported_param_prefixes[] = {\n    \"xa.authenticator-options.\",\n    NULL\n  };\n  g_autoptr(GPtrArray) updated_params = NULL;\n  g_autoptr(GVariant) metadata = NULL;\n  GVariantIter iter;\n  g_autoptr(GBytes) gpg_keys = NULL;\n\n  updated_params = g_ptr_array_new_with_free_func (g_free);\n\n  if (!flatpak_remote_state_ensure_summary (remote_state, error))\n    return FALSE;\n\n  if (remote_state->index)\n    metadata = g_variant_get_child_value (remote_state->index, 1);\n  else\n    metadata = g_variant_get_child_value (remote_state->summary, 1);\n\n  g_variant_iter_init (&iter, metadata);\n  if (g_variant_iter_n_children (&iter) > 0)\n    {\n      GVariant *value_var = NULL;\n      char *key = NULL;\n\n      while (g_variant_iter_next (&iter, \"{sv}\", &key, &value_var))\n        {\n          if (g_strv_contains (supported_params, key) ||\n              strv_contains_prefix (supported_param_prefixes, key))\n            {\n              if (strcmp (key, \"xa.gpg-keys\") == 0)\n                {\n                  if (g_variant_is_of_type (value_var, G_VARIANT_TYPE_BYTESTRING))\n                    {\n                      const guchar *gpg_data = g_variant_get_data (value_var);\n                      gsize gpg_size = g_variant_get_size (value_var);\n                      g_autofree gchar *gpg_data_checksum = g_compute_checksum_for_data (G_CHECKSUM_SHA256, gpg_data, gpg_size);\n\n                      gpg_keys = g_bytes_new (gpg_data, gpg_size);\n\n                      /* We store the hash so that we can detect when things changed or not\n                         instead of re-importing the key over-and-over */\n                      g_ptr_array_add (updated_params, g_strdup (\"xa.gpg-keys-hash\"));\n                      g_ptr_array_add (updated_params, g_steal_pointer (&gpg_data_checksum));\n                    }\n                }\n              else if (g_variant_is_of_type (value_var, G_VARIANT_TYPE_STRING))\n                {\n                  const char *value = g_variant_get_string (value_var, NULL);\n                  if (value != NULL && *value != 0)\n                    {\n                      if (strcmp (key, \"xa.redirect-url\") == 0)\n                        g_ptr_array_add (updated_params, g_strdup (\"url\"));\n                      else if (strcmp (key, OSTREE_META_KEY_DEPLOY_COLLECTION_ID) == 0)\n                        g_ptr_array_add (updated_params, g_strdup (\"collection-id\"));\n                      else if (strcmp (key, \"xa.deploy-collection-id\") == 0)\n                        g_ptr_array_add (updated_params, g_strdup (\"collection-id\"));\n                      else\n                        g_ptr_array_add (updated_params, g_strdup (key));\n                      g_ptr_array_add (updated_params, g_strdup (value));\n                    }\n                }\n              else if (g_variant_is_of_type (value_var, G_VARIANT_TYPE_BOOLEAN))\n                {\n                  gboolean value = g_variant_get_boolean (value_var);\n                  g_ptr_array_add (updated_params, g_strdup (key));\n                  if (value)\n                    g_ptr_array_add (updated_params, g_strdup (\"true\"));\n                  else\n                    g_ptr_array_add (updated_params, g_strdup (\"false\"));\n                }\n            }\n\n          g_variant_unref (value_var);\n          g_free (key);\n        }\n    }\n\n  if (updated_params->len > 0)\n    {\n      g_autoptr(GKeyFile) config = NULL;\n      g_autofree char *group = NULL;\n      gboolean has_changed = FALSE;\n      int i;\n\n      config = ostree_repo_copy_config (flatpak_dir_get_repo (self));\n      group = g_strdup_printf (\"remote \\\"%s\\\"\", remote_state->remote_name);\n\n      i = 0;\n      while (i < (updated_params->len - 1))\n        {\n          /* This array should have an even number of elements with\n             keys in the odd positions and values on even ones. */\n          const char *key = g_ptr_array_index (updated_params, i);\n          const char *new_val = g_ptr_array_index (updated_params, i + 1);\n          g_autofree char *current_val = NULL;\n          g_autofree char *is_set_key = g_strconcat (key, \"-is-set\", NULL);\n          gboolean is_set = FALSE;\n\n          is_set = g_key_file_get_boolean (config, group, is_set_key, NULL);\n          if (!is_set)\n            {\n              current_val = g_key_file_get_string (config, group, key, NULL);\n              if ((!g_str_equal (key, \"collection-id\") &&\n                   g_strcmp0 (current_val, new_val) != 0) ||\n                  (g_str_equal (key, \"collection-id\") &&\n                   (current_val == NULL || *current_val == '\\0') &&\n                   new_val != NULL && *new_val != '\\0'))\n                {\n                  has_changed = TRUE;\n                  g_key_file_set_string (config, group, key, new_val);\n                }\n            }\n\n          i += 2;\n        }\n\n      if (has_changed_out)\n        *has_changed_out = has_changed;\n\n      if (dry_run || !has_changed)\n        return TRUE;\n\n      /* Update the local remote configuration with the updated info. */\n      if (!flatpak_dir_modify_remote (self, remote_state->remote_name, config, gpg_keys, cancellable, error))\n        return FALSE;\n    }\n\n  return TRUE;\n}\n\ngboolean\nflatpak_dir_update_remote_configuration (FlatpakDir   *self,\n                                         const char   *remote,\n                                         FlatpakRemoteState *optional_remote_state,\n                                         gboolean     *updated_out,\n                                         GCancellable *cancellable,\n                                         GError      **error)\n{\n  gboolean is_oci;\n  g_autoptr(FlatpakRemoteState) local_state = NULL;\n  FlatpakRemoteState *state;\n  gboolean has_changed = FALSE;\n\n  /* Initialize if we exit early */\n  if (updated_out)\n    *updated_out = FALSE;\n\n  if (flatpak_dir_get_remote_disabled (self, remote))\n    return TRUE;\n\n  is_oci = flatpak_dir_get_remote_oci (self, remote);\n  if (is_oci)\n    return TRUE;\n\n  if (optional_remote_state)\n    state = optional_remote_state;\n  else\n    {\n      local_state = flatpak_dir_get_remote_state (self, remote, FALSE, cancellable, error);\n      if (local_state == NULL)\n        return FALSE;\n      state = local_state;\n    }\n\n  if (flatpak_dir_use_system_helper (self, NULL))\n    {\n      gboolean gpg_verify_summary;\n      gboolean gpg_verify;\n\n      if (!ostree_repo_remote_get_gpg_verify_summary (self->repo, remote, &gpg_verify_summary, error))\n        return FALSE;\n\n      if (!ostree_repo_remote_get_gpg_verify (self->repo, remote, &gpg_verify, error))\n        return FALSE;\n\n      if (!gpg_verify_summary || !gpg_verify)\n        {\n          g_debug (\"Ignoring automatic updates for system-helper remotes without gpg signatures\");\n          return TRUE;\n        }\n\n      if ((state->summary != NULL && state->summary_sig_bytes == NULL) ||\n          (state->index != NULL && state->index_sig_bytes == NULL))\n        {\n          g_debug (\"Can't update remote configuration as user, no GPG signature\");\n          return TRUE;\n        }\n\n      if (!flatpak_dir_update_remote_configuration_for_state (self, state, TRUE, &has_changed, cancellable, error))\n        return FALSE;\n\n      if (has_changed)\n        {\n          g_autoptr(GBytes) bytes = g_variant_get_data_as_bytes (state->index ? state->index : state->summary);\n          GBytes *sig_bytes = state->index ? state->index_sig_bytes : state->summary_sig_bytes;\n          glnx_autofd int summary_fd = -1;\n          g_autofree char *summary_path = NULL;\n          glnx_autofd int summary_sig_fd = -1;\n          g_autofree char *summary_sig_path = NULL;\n          const char *installation;\n          FlatpakHelperUpdateRemoteFlags flags = 0;\n\n          if (state->index)\n            flags |= FLATPAK_HELPER_UPDATE_REMOTE_FLAGS_SUMMARY_IS_INDEX;\n\n          summary_fd = g_file_open_tmp (\"remote-summary.XXXXXX\", &summary_path, error);\n          if (summary_fd == -1)\n            return FALSE;\n          if (glnx_loop_write (summary_fd, g_bytes_get_data (bytes, NULL), g_bytes_get_size (bytes)) < 0)\n            return glnx_throw_errno (error);\n\n          if (sig_bytes != NULL)\n            {\n              summary_sig_fd = g_file_open_tmp (\"remote-summary-sig.XXXXXX\", &summary_sig_path, error);\n              if (summary_sig_fd == -1)\n                return FALSE;\n              if (glnx_loop_write (summary_sig_fd, g_bytes_get_data (sig_bytes, NULL), g_bytes_get_size (sig_bytes)) < 0)\n                return glnx_throw_errno (error);\n            }\n\n          installation = flatpak_dir_get_id (self);\n\n          if (!flatpak_dir_system_helper_call_update_remote (self, flags, remote,\n                                                             installation ? installation : \"\",\n                                                             summary_path, summary_sig_path ? summary_sig_path : \"\",\n                                                             cancellable, error))\n            return FALSE;\n\n          unlink (summary_path);\n          if (summary_sig_path)\n            unlink (summary_sig_path);\n\n\n          if (!flatpak_dir_remote_clear_cached_summary (self, remote, cancellable, error))\n            return FALSE;\n\n        }\n\n      if (updated_out)\n        *updated_out = has_changed;\n\n      return TRUE;\n    }\n\n  if (!flatpak_dir_update_remote_configuration_for_state (self, state, FALSE, &has_changed, cancellable, error))\n    return FALSE;\n\n  if (has_changed &&\n      !flatpak_dir_remote_clear_cached_summary (self, remote, cancellable, error))\n    return FALSE;\n\n  if (updated_out)\n    *updated_out = has_changed;\n\n  return TRUE;\n}\n\nvoid\nflatpak_related_free (FlatpakRelated *self)\n{\n  flatpak_decomposed_unref (self->ref);\n  g_free (self->commit);\n  g_strfreev (self->subpaths);\n  g_free (self);\n}\n\nstatic void\nadd_related (FlatpakDir        *self,\n             GPtrArray         *related,\n             const char        *extension,\n             FlatpakDecomposed *extension_ref,\n             const char        *checksum,\n             gboolean           no_autodownload,\n             const char        *download_if,\n             const char        *autoprune_unless,\n             gboolean           autodelete,\n             gboolean           locale_subset)\n{\n  g_autoptr(GBytes) deploy_data = NULL;\n  g_autofree const char **old_subpaths = NULL;\n  g_autofree const char *id = NULL;\n  g_autofree const char *arch = NULL;\n  g_autofree const char *branch = NULL;\n  g_auto(GStrv) extra_subpaths = NULL;\n  g_auto(GStrv) subpaths = NULL;\n  FlatpakRelated *rel;\n  gboolean download;\n  gboolean delete = autodelete;\n  gboolean auto_prune = FALSE;\n  g_autoptr(GFile) unmaintained_path = NULL;\n\n  deploy_data = flatpak_dir_get_deploy_data (self, extension_ref, FLATPAK_DEPLOY_VERSION_ANY, NULL, NULL);\n\n  id = flatpak_decomposed_dup_id (extension_ref);\n  arch = flatpak_decomposed_dup_arch (extension_ref);\n  branch = flatpak_decomposed_dup_branch (extension_ref);\n\n  if (deploy_data)\n    old_subpaths = flatpak_deploy_data_get_subpaths (deploy_data);\n\n  /* Only respect no-autodownload/download-if for uninstalled refs, we\n     always want to update if you manually installed something */\n  download =\n    flatpak_extension_matches_reason (id, download_if, !no_autodownload) ||\n    deploy_data != NULL;\n\n  if (!flatpak_extension_matches_reason (id, autoprune_unless, TRUE))\n    auto_prune = TRUE;\n\n  /* Don't download if there is an unmaintained extension already installed */\n  unmaintained_path =\n    flatpak_find_unmaintained_extension_dir_if_exists (id, arch, branch, NULL);\n  if (unmaintained_path != NULL && deploy_data == NULL)\n    {\n      g_debug (\"Skipping related extension \u2018%s\u2019 because it is already \"\n               \"installed as an unmaintained extension in \u2018%s\u2019.\",\n               id, flatpak_file_get_path_cached (unmaintained_path));\n      download = FALSE;\n    }\n\n  if (g_str_has_suffix (extension, \".Debug\"))\n    {\n      /* debug files only updated if already installed */\n      if (deploy_data == NULL)\n        download = FALSE;\n\n      /* Always remove debug */\n      delete = TRUE;\n    }\n\n  if (g_str_has_suffix (extension, \".Locale\"))\n    locale_subset = TRUE;\n\n  if (locale_subset)\n    {\n      extra_subpaths = flatpak_dir_get_locale_subpaths (self);\n\n      /* Always remove locale */\n      delete = TRUE;\n    }\n\n  subpaths = flatpak_subpaths_merge ((char **) old_subpaths, extra_subpaths);\n\n  rel = g_new0 (FlatpakRelated, 1);\n  rel->ref = flatpak_decomposed_ref (extension_ref);\n  rel->commit = g_strdup (checksum);\n  rel->subpaths = g_steal_pointer (&subpaths);\n  rel->download = download;\n  rel->delete = delete;\n  rel->auto_prune = auto_prune;\n\n  g_ptr_array_add (related, rel);\n}\n\nstatic GRegex *\nflatpak_dir_get_mask_regexp (FlatpakDir *self)\n{\n  GRegex *res = NULL;\n\n  G_LOCK (config_cache);\n\n  if (self->masked == NULL)\n    {\n      g_autofree char *masked = NULL;\n\n      masked = flatpak_dir_get_config (self, \"masked\", NULL);\n      if (masked)\n        {\n          g_auto(GStrv) patterns = g_strsplit (masked, \";\", -1);\n          g_autoptr(GString) deny_regexp = g_string_new (\"^(\");\n          int i;\n\n          for (i = 0; patterns[i] != NULL; i++)\n            {\n              const char *pattern = patterns[i];\n\n              if (*pattern != 0)\n                {\n                  g_autofree char *regexp = NULL;\n\n                  regexp = flatpak_filter_glob_to_regexp (pattern, FALSE, NULL);\n                  if (regexp)\n                    {\n                      if (i != 0)\n                        g_string_append (deny_regexp, \"|\");\n                      g_string_append (deny_regexp, regexp);\n                    }\n                }\n            }\n\n          g_string_append (deny_regexp, \")$\");\n          self->masked = g_regex_new (deny_regexp->str, G_REGEX_DOLLAR_ENDONLY|G_REGEX_RAW|G_REGEX_OPTIMIZE, G_REGEX_MATCH_ANCHORED, NULL);\n        }\n    }\n\n  if (self->masked)\n    res = g_regex_ref (self->masked);\n\n  G_UNLOCK (config_cache);\n\n  return res;\n}\n\ngboolean\nflatpak_dir_ref_is_masked (FlatpakDir *self,\n                           const char *ref)\n{\n  g_autoptr(GRegex) masked = flatpak_dir_get_mask_regexp (self);\n\n  return !flatpak_filters_allow_ref (NULL, masked, ref);\n}\n\nstatic GRegex *\nflatpak_dir_get_pin_regexp (FlatpakDir *self)\n{\n  GRegex *res = NULL;\n\n  G_LOCK (config_cache);\n\n  if (self->pinned == NULL)\n    {\n      g_autofree char *pinned = NULL;\n\n      pinned = flatpak_dir_get_config (self, \"pinned\", NULL);\n      if (pinned)\n        {\n          g_auto(GStrv) patterns = g_strsplit (pinned, \";\", -1);\n          g_autoptr(GString) deny_regexp = g_string_new (\"^(\");\n          int i;\n\n          for (i = 0; patterns[i] != NULL; i++)\n            {\n              const char *pattern = patterns[i];\n\n              if (*pattern != 0)\n                {\n                  g_autofree char *regexp = NULL;\n\n                  regexp = flatpak_filter_glob_to_regexp (pattern,\n                                                          TRUE, /* only match runtimes */\n                                                          NULL);\n                  if (regexp)\n                    {\n                      if (i != 0)\n                        g_string_append (deny_regexp, \"|\");\n                      g_string_append (deny_regexp, regexp);\n                    }\n                }\n            }\n\n          g_string_append (deny_regexp, \")$\");\n          self->pinned = g_regex_new (deny_regexp->str, G_REGEX_DOLLAR_ENDONLY|G_REGEX_RAW|G_REGEX_OPTIMIZE, G_REGEX_MATCH_ANCHORED, NULL);\n        }\n    }\n\n  if (self->pinned)\n    res = g_regex_ref (self->pinned);\n\n  G_UNLOCK (config_cache);\n\n  return res;\n}\n\ngboolean\nflatpak_dir_ref_is_pinned (FlatpakDir *self,\n                           const char *ref)\n{\n  g_autoptr(GRegex) pinned = flatpak_dir_get_pin_regexp (self);\n\n  return !flatpak_filters_allow_ref (NULL, pinned, ref);\n}\n\nGPtrArray *\nflatpak_dir_find_remote_related_for_metadata (FlatpakDir         *self,\n                                              FlatpakRemoteState *state,\n                                              FlatpakDecomposed  *ref,\n                                              GKeyFile           *metakey,\n                                              GCancellable       *cancellable,\n                                              GError            **error)\n{\n  int i;\n  g_autoptr(GPtrArray) related = g_ptr_array_new_with_free_func ((GDestroyNotify) flatpak_related_free);\n  g_autofree char *url = NULL;\n  g_auto(GStrv) groups = NULL;\n  g_autoptr(GRegex) masked = NULL;\n  g_autofree char *ref_arch = flatpak_decomposed_dup_arch (ref);\n  g_autofree char *ref_branch = flatpak_decomposed_dup_branch (ref);\n\n  if (!ostree_repo_remote_get_url (self->repo,\n                                   state->remote_name,\n                                   &url,\n                                   error))\n    return NULL;\n\n  if (*url == 0)\n    return g_steal_pointer (&related);  /* Empty url, silently disables updates */\n\n  masked = flatpak_dir_get_mask_regexp (self);\n\n  groups = g_key_file_get_groups (metakey, NULL);\n  for (i = 0; groups[i] != NULL; i++)\n    {\n      char *tagged_extension;\n\n      if (g_str_has_prefix (groups[i], FLATPAK_METADATA_GROUP_PREFIX_EXTENSION) &&\n          *(tagged_extension = (groups[i] + strlen (FLATPAK_METADATA_GROUP_PREFIX_EXTENSION))) != 0)\n        {\n          g_autofree char *extension = NULL;\n          g_autofree char *version = g_key_file_get_string (metakey, groups[i],\n                                                            FLATPAK_METADATA_KEY_VERSION, NULL);\n          g_auto(GStrv) versions = g_key_file_get_string_list (metakey, groups[i],\n                                                               FLATPAK_METADATA_KEY_VERSIONS,\n                                                               NULL, NULL);\n          gboolean subdirectories = g_key_file_get_boolean (metakey, groups[i],\n                                                            FLATPAK_METADATA_KEY_SUBDIRECTORIES, NULL);\n          gboolean no_autodownload = g_key_file_get_boolean (metakey, groups[i],\n                                                             FLATPAK_METADATA_KEY_NO_AUTODOWNLOAD, NULL);\n          g_autofree char *download_if = g_key_file_get_string (metakey, groups[i],\n                                                                FLATPAK_METADATA_KEY_DOWNLOAD_IF, NULL);\n          g_autofree char *autoprune_unless = g_key_file_get_string (metakey, groups[i],\n                                                                     FLATPAK_METADATA_KEY_AUTOPRUNE_UNLESS, NULL);\n          gboolean autodelete = g_key_file_get_boolean (metakey, groups[i],\n                                                        FLATPAK_METADATA_KEY_AUTODELETE, NULL);\n          gboolean locale_subset = g_key_file_get_boolean (metakey, groups[i],\n                                                           FLATPAK_METADATA_KEY_LOCALE_SUBSET, NULL);\n          const char *default_branches[] = { NULL, NULL};\n          const char **branches;\n          int branch_i;\n\n          /* Parse actual extension name */\n          flatpak_parse_extension_with_tag (tagged_extension, &extension, NULL);\n\n          if (versions)\n            branches = (const char **) versions;\n          else\n            {\n              if (version)\n                default_branches[0] = version;\n              else\n                default_branches[0] = ref_branch;\n              branches = default_branches;\n            }\n\n          for (branch_i = 0; branches[branch_i] != NULL; branch_i++)\n            {\n              g_autoptr(FlatpakDecomposed) extension_ref = NULL;\n              g_autofree char *checksum = NULL;\n              const char *branch = branches[branch_i];\n\n              extension_ref = flatpak_decomposed_new_from_parts (FLATPAK_KINDS_RUNTIME,\n                                                                 extension, ref_arch, branch, NULL);\n              if (extension_ref == NULL)\n                continue;\n\n              if (flatpak_remote_state_lookup_ref (state, flatpak_decomposed_get_ref (extension_ref), &checksum, NULL, NULL, NULL, NULL))\n                {\n                  if (flatpak_filters_allow_ref (NULL, masked, flatpak_decomposed_get_ref (extension_ref)))\n                    add_related (self, related, extension, extension_ref, checksum,\n                                 no_autodownload, download_if, autoprune_unless, autodelete, locale_subset);\n                }\n              else if (subdirectories)\n                {\n                  g_autoptr(GPtrArray) subref_refs = flatpak_remote_state_match_subrefs (state, extension_ref);\n                  for (int j = 0; j < subref_refs->len; j++)\n                    {\n                      FlatpakDecomposed *subref_ref = g_ptr_array_index (subref_refs, j);\n                      g_autofree char *subref_checksum = NULL;\n\n                      if (flatpak_remote_state_lookup_ref (state, flatpak_decomposed_get_ref (subref_ref),\n                                                           &subref_checksum, NULL, NULL, NULL, NULL) &&\n                          flatpak_filters_allow_ref (NULL, masked,  flatpak_decomposed_get_ref (subref_ref)))\n                        add_related (self, related, extension, subref_ref, subref_checksum,\n                                     no_autodownload, download_if, autoprune_unless, autodelete, locale_subset);\n                    }\n                }\n            }\n        }\n    }\n\n  return g_steal_pointer (&related);\n}\n\nGPtrArray *\nflatpak_dir_find_remote_related (FlatpakDir         *self,\n                                 FlatpakRemoteState *state,\n                                 FlatpakDecomposed  *ref,\n                                 GCancellable       *cancellable,\n                                 GError            **error)\n{\n  g_autofree char *metadata = NULL;\n  g_autoptr(GKeyFile) metakey = g_key_file_new ();\n  g_autoptr(GPtrArray) related = g_ptr_array_new_with_free_func ((GDestroyNotify) flatpak_related_free);\n  g_autofree char *url = NULL;\n\n  if (!ostree_repo_remote_get_url (self->repo,\n                                   state->remote_name,\n                                   &url,\n                                   error))\n    return NULL;\n\n  if (*url == 0)\n    return g_steal_pointer (&related);  /* Empty url, silently disables updates */\n\n  if (flatpak_remote_state_load_data (state, flatpak_decomposed_get_ref (ref),\n                                      NULL, NULL, &metadata,\n                                      NULL) &&\n      g_key_file_load_from_data (metakey, metadata, -1, 0, NULL))\n    {\n      g_ptr_array_unref (related);\n      related = flatpak_dir_find_remote_related_for_metadata (self, state, ref, metakey, cancellable, error);\n    }\n\n  return g_steal_pointer (&related);\n}\n\nstatic GHashTable *\nlocal_match_prefix (FlatpakDir        *self,\n                    FlatpakDecomposed *extension_ref,\n                    const char        *remote)\n{\n  GHashTable *matches = g_hash_table_new_full ((GHashFunc)flatpak_decomposed_hash, (GEqualFunc)flatpak_decomposed_equal, (GDestroyNotify)flatpak_decomposed_unref, NULL);\n  FlatpakKinds kind;\n  g_autofree char *id = NULL;\n  g_autofree char *arch = NULL;\n  g_autofree char *branch = NULL;\n  g_autofree char *id_prefix = NULL;\n  g_autoptr(GHashTable) refs = NULL;\n  g_autofree char *list_prefix = NULL;\n  const char *kind_str;\n\n  kind = flatpak_decomposed_get_kinds (extension_ref);\n  id = flatpak_decomposed_dup_id (extension_ref);\n  arch = flatpak_decomposed_dup_arch (extension_ref);\n  branch = flatpak_decomposed_dup_branch (extension_ref);\n\n  id_prefix = g_strconcat (id, \".\", NULL);\n\n  kind_str = flatpak_decomposed_get_kind_str (extension_ref);\n\n  if (remote)\n    list_prefix = g_strdup_printf (\"%s:%s\", remote, kind_str);\n\n  if (ostree_repo_list_refs (self->repo, list_prefix, &refs, NULL, NULL))\n    {\n      GHashTableIter hash_iter;\n      gpointer key;\n\n      g_hash_table_iter_init (&hash_iter, refs);\n      while (g_hash_table_iter_next (&hash_iter, &key, NULL))\n        {\n          const char *partial_ref_and_origin = key;\n          g_autofree char *partial_ref_store = NULL;\n          const char *partial_ref;\n          g_autoptr(FlatpakDecomposed) matched = NULL;\n\n          ostree_parse_refspec (partial_ref_and_origin, NULL, &partial_ref_store, NULL);\n          if (remote == NULL)\n            {\n              /* If we're not filtering via list_prefix we need to filter by part[0] manually */\n              char *slash = strchr (partial_ref_store, '/');\n              if (slash == NULL)\n                continue;\n              *slash = 0;\n              if (strcmp (partial_ref_store, kind_str) != 0)\n                continue;\n              partial_ref = slash + 1;\n            }\n          else\n            partial_ref = partial_ref_store;\n\n          matched = flatpak_decomposed_new_from_pref (kind, partial_ref, NULL);\n          if (matched == NULL)\n            continue;\n\n          /* Must match type, arch, branch */\n          if (!flatpak_decomposed_is_arch (matched, arch) ||\n              !flatpak_decomposed_is_branch (matched, branch))\n            continue;\n\n          /* But only prefix of id */\n          if (!flatpak_decomposed_id_has_prefix (matched, id_prefix))\n            continue;\n\n          g_hash_table_add (matches, g_steal_pointer (&matched));\n        }\n    }\n\n  /* Also check deploys. In case remote-delete --force is run, we can end up\n   * with a deploy without a corresponding ref in the repo. */\n  flatpak_dir_collect_deployed_refs (self, kind_str, id_prefix, arch, branch, matches, NULL, NULL);\n\n  return matches;\n}\n\n/* Finds all the locally installed ref related to ref, if remote_name is set it is limited to refs from that remote */\nGPtrArray *\nflatpak_dir_find_local_related_for_metadata (FlatpakDir        *self,\n                                             FlatpakDecomposed *ref,\n                                             const char        *remote_name, /* nullable */\n                                             GKeyFile          *metakey,\n                                             GCancellable      *cancellable,\n                                             GError           **error)\n{\n  int i;\n  g_autoptr(GPtrArray) related = g_ptr_array_new_with_free_func ((GDestroyNotify) flatpak_related_free);\n  g_auto(GStrv) groups = NULL;\n  g_autofree char *ref_arch = flatpak_decomposed_dup_arch (ref);\n  g_autofree char *ref_branch = flatpak_decomposed_dup_branch (ref);\n\n  if (!flatpak_dir_ensure_repo (self, cancellable, error))\n    return NULL;\n\n  groups = g_key_file_get_groups (metakey, NULL);\n  for (i = 0; groups[i] != NULL; i++)\n    {\n      char *tagged_extension;\n\n      if (g_str_has_prefix (groups[i], FLATPAK_METADATA_GROUP_PREFIX_EXTENSION) &&\n          *(tagged_extension = (groups[i] + strlen (FLATPAK_METADATA_GROUP_PREFIX_EXTENSION))) != 0)\n        {\n          g_autofree char *extension = NULL;\n          g_autofree char *version = g_key_file_get_string (metakey, groups[i],\n                                                            FLATPAK_METADATA_KEY_VERSION, NULL);\n          g_auto(GStrv) versions = g_key_file_get_string_list (metakey, groups[i],\n                                                               FLATPAK_METADATA_KEY_VERSIONS,\n                                                               NULL, NULL);\n          gboolean subdirectories = g_key_file_get_boolean (metakey, groups[i],\n                                                            FLATPAK_METADATA_KEY_SUBDIRECTORIES, NULL);\n          gboolean no_autodownload = g_key_file_get_boolean (metakey, groups[i],\n                                                             FLATPAK_METADATA_KEY_NO_AUTODOWNLOAD, NULL);\n          g_autofree char *download_if = g_key_file_get_string (metakey, groups[i],\n                                                                FLATPAK_METADATA_KEY_DOWNLOAD_IF, NULL);\n          g_autofree char *autoprune_unless = g_key_file_get_string (metakey, groups[i],\n                                                                     FLATPAK_METADATA_KEY_AUTOPRUNE_UNLESS, NULL);\n          gboolean autodelete = g_key_file_get_boolean (metakey, groups[i],\n                                                        FLATPAK_METADATA_KEY_AUTODELETE, NULL);\n          gboolean locale_subset = g_key_file_get_boolean (metakey, groups[i],\n                                                           FLATPAK_METADATA_KEY_LOCALE_SUBSET, NULL);\n          const char *default_branches[] = { NULL, NULL};\n          const char **branches;\n          int branch_i;\n\n          /* Parse actual extension name */\n          flatpak_parse_extension_with_tag (tagged_extension, &extension, NULL);\n\n          if (versions)\n            branches = (const char **) versions;\n          else\n            {\n              if (version)\n                default_branches[0] = version;\n              else\n                default_branches[0] = ref_branch;\n              branches = default_branches;\n            }\n\n          for (branch_i = 0; branches[branch_i] != NULL; branch_i++)\n            {\n              g_autoptr(FlatpakDecomposed) extension_ref = NULL;\n              g_autofree char *checksum = NULL;\n              g_autoptr(GBytes) deploy_data = NULL;\n              const char *branch = branches[branch_i];\n\n              extension_ref = flatpak_decomposed_new_from_parts (FLATPAK_KINDS_RUNTIME,\n                                                                 extension, ref_arch, branch, NULL);\n              if (remote_name != NULL &&\n                  flatpak_repo_resolve_rev (self->repo,\n                                            NULL,\n                                            remote_name,\n                                            flatpak_decomposed_get_ref (extension_ref),\n                                            FALSE,\n                                            &checksum,\n                                            NULL,\n                                            NULL))\n                {\n                  add_related (self, related, extension, extension_ref,\n                               checksum, no_autodownload, download_if, autoprune_unless, autodelete, locale_subset);\n                }\n              else if ((deploy_data = flatpak_dir_get_deploy_data (self, extension_ref,\n                                                                   FLATPAK_DEPLOY_VERSION_ANY,\n                                                                   NULL, NULL)) != NULL &&\n                       (remote_name == NULL || g_strcmp0 (flatpak_deploy_data_get_origin (deploy_data), remote_name) == 0))\n                {\n                  /* Here we're including extensions that are deployed but might\n                   * not have a ref in the repo, as happens with remote-delete\n                   * --force\n                   */\n                  checksum = g_strdup (flatpak_deploy_data_get_commit (deploy_data));\n                  add_related (self, related, extension, extension_ref,\n                               checksum, no_autodownload, download_if, autoprune_unless, autodelete, locale_subset);\n                }\n              else if (subdirectories)\n                {\n                  g_autoptr(GHashTable) matches = local_match_prefix (self, extension_ref, remote_name);\n                  GLNX_HASH_TABLE_FOREACH (matches, FlatpakDecomposed *, match)\n                    {\n                      g_autofree char *match_checksum = NULL;\n                      g_autoptr(GBytes) match_deploy_data = NULL;\n\n                      if (remote_name != NULL &&\n                          flatpak_repo_resolve_rev (self->repo,\n                                                    NULL,\n                                                    remote_name,\n                                                    flatpak_decomposed_get_ref (match),\n                                                    FALSE,\n                                                    &match_checksum,\n                                                    NULL,\n                                                    NULL))\n                        {\n                          add_related (self, related, extension, match, match_checksum,\n                                       no_autodownload, download_if, autoprune_unless, autodelete, locale_subset);\n                        }\n                      else if ((match_deploy_data = flatpak_dir_get_deploy_data (self, match,\n                                                                                 FLATPAK_DEPLOY_VERSION_ANY,\n                                                                                 NULL, NULL)) != NULL &&\n                               (remote_name == NULL || g_strcmp0 (flatpak_deploy_data_get_origin (match_deploy_data), remote_name) == 0))\n                        {\n                          /* Here again we're including extensions that are deployed but might\n                           * not have a ref in the repo\n                           */\n                          match_checksum = g_strdup (flatpak_deploy_data_get_commit (match_deploy_data));\n                          add_related (self, related, extension, match, match_checksum,\n                                       no_autodownload, download_if, autoprune_unless, autodelete, locale_subset);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n  return g_steal_pointer (&related);\n}\n\n\nGPtrArray *\nflatpak_dir_find_local_related (FlatpakDir        *self,\n                                FlatpakDecomposed *ref,\n                                const char        *remote_name,\n                                gboolean           deployed,\n                                GCancellable      *cancellable,\n                                GError           **error)\n{\n  g_autoptr(GFile) deploy_dir = NULL;\n  g_autoptr(GBytes) deploy_data = NULL;\n  g_autoptr(GFile) metadata = NULL;\n  g_autofree char *metadata_contents = NULL;\n  g_autoptr(GKeyFile) metakey = g_key_file_new ();\n  g_autoptr(GPtrArray) related = NULL;\n\n  if (!flatpak_dir_ensure_repo (self, cancellable, error))\n    return NULL;\n\n  if (deployed)\n    {\n      deploy_dir = flatpak_dir_get_if_deployed (self, ref, NULL, cancellable);\n      if (deploy_dir == NULL)\n        {\n          g_set_error (error, FLATPAK_ERROR, FLATPAK_ERROR_NOT_INSTALLED,\n                       _(\"%s not installed\"), flatpak_decomposed_get_ref (ref));\n          return NULL;\n        }\n\n      deploy_data = flatpak_load_deploy_data (deploy_dir, ref, self->repo, FLATPAK_DEPLOY_VERSION_ANY, cancellable, error);\n      if (deploy_data == NULL)\n        return NULL;\n\n      metadata = g_file_get_child (deploy_dir, \"metadata\");\n      if (!g_file_load_contents (metadata, cancellable, &metadata_contents, NULL, NULL, NULL))\n        {\n          g_debug (\"No metadata in local deploy\");\n          /* No metadata => no related, but no error */\n        }\n    }\n  else\n    {\n      g_autofree char *checksum = NULL;\n      g_autoptr(GVariant) commit_data = flatpak_dir_read_latest_commit (self, remote_name, ref, &checksum, NULL, NULL);\n      if (commit_data)\n        {\n          g_autoptr(GVariant) commit_metadata = g_variant_get_child_value (commit_data, 0);\n          g_variant_lookup (commit_metadata, \"xa.metadata\", \"s\", &metadata_contents);\n          if (metadata_contents == NULL)\n            g_debug (\"No xa.metadata in local commit %s ref %s\", checksum, flatpak_decomposed_get_ref (ref));\n        }\n    }\n\n  if (metadata_contents &&\n      g_key_file_load_from_data (metakey, metadata_contents, -1, 0, NULL))\n    related = flatpak_dir_find_local_related_for_metadata (self, ref, remote_name, metakey, cancellable, error);\n  else\n    related = g_ptr_array_new_with_free_func ((GDestroyNotify) flatpak_related_free);\n\n  return g_steal_pointer (&related);\n}\n\nFlatpakDecomposed *\nflatpak_dir_get_remote_auto_install_authenticator_ref (FlatpakDir         *self,\n                                                        const char         *remote_name)\n{\n  g_autofree char *authenticator_name = NULL;\n  g_autoptr(FlatpakDecomposed) ref = NULL;\n\n  authenticator_name = flatpak_dir_get_remote_install_authenticator_name (self, remote_name);\n  if (authenticator_name != NULL)\n    {\n      g_autoptr(GError) local_error = NULL;\n      ref = flatpak_decomposed_new_from_parts (FLATPAK_KINDS_APP, authenticator_name, flatpak_get_arch (), \"autoinstall\", &local_error);\n      if (ref == NULL)\n        g_debug (\"Invalid authenticator ref: %s\\n\", local_error->message);\n    }\n\n  return g_steal_pointer (&ref);\n}\n\n\nstatic GDBusProxy *\nget_localed_dbus_proxy (void)\n{\n  const char *localed_bus_name = \"org.freedesktop.locale1\";\n  const char *localed_object_path = \"/org/freedesktop/locale1\";\n  const char *localed_interface_name = localed_bus_name;\n\n  return g_dbus_proxy_new_for_bus_sync (G_BUS_TYPE_SYSTEM,\n                                        G_DBUS_PROXY_FLAGS_NONE,\n                                        NULL,\n                                        localed_bus_name,\n                                        localed_object_path,\n                                        localed_interface_name,\n                                        NULL,\n                                        NULL);\n}\n\nstatic void\nget_locale_langs_from_localed_dbus (GDBusProxy *proxy, GPtrArray *langs)\n{\n  g_autoptr(GVariant) locale_variant = NULL;\n  g_autofree const gchar **strv = NULL;\n  gsize i, j;\n\n  locale_variant = g_dbus_proxy_get_cached_property (proxy, \"Locale\");\n  if (locale_variant == NULL)\n    return;\n\n  strv = g_variant_get_strv (locale_variant, NULL);\n\n  for (i = 0; strv[i]; i++)\n    {\n      const gchar *locale = NULL;\n      g_autofree char *lang = NULL;\n\n      /* See locale(7) for these categories */\n      const char * const categories[] = { \"LANG=\", \"LC_ALL=\", \"LC_MESSAGES=\", \"LC_ADDRESS=\",\n                                          \"LC_COLLATE=\", \"LC_CTYPE=\", \"LC_IDENTIFICATION=\",\n                                          \"LC_MONETARY=\", \"LC_MEASUREMENT=\", \"LC_NAME=\",\n                                          \"LC_NUMERIC=\", \"LC_PAPER=\", \"LC_TELEPHONE=\",\n                                          \"LC_TIME=\", NULL };\n\n      for (j = 0; categories[j]; j++)\n        {\n          if (g_str_has_prefix (strv[i], categories[j]))\n            {\n              locale = strv[i] + strlen (categories[j]);\n              break;\n            }\n        }\n\n      if (locale == NULL || strcmp (locale, \"\") == 0)\n        continue;\n\n      lang = flatpak_get_lang_from_locale (locale);\n      if (lang != NULL && !flatpak_g_ptr_array_contains_string (langs, lang))\n        g_ptr_array_add (langs, g_steal_pointer (&lang));\n    }\n}\n\nstatic GDBusProxy *\nget_accounts_dbus_proxy (void)\n{\n  const char *accounts_bus_name = \"org.freedesktop.Accounts\";\n  const char *accounts_object_path = \"/org/freedesktop/Accounts\";\n  const char *accounts_interface_name = accounts_bus_name;\n\n  return g_dbus_proxy_new_for_bus_sync (G_BUS_TYPE_SYSTEM,\n                                        G_DBUS_PROXY_FLAGS_NONE,\n                                        NULL,\n                                        accounts_bus_name,\n                                        accounts_object_path,\n                                        accounts_interface_name,\n                                        NULL,\n                                        NULL);\n}\n\nstatic void\nget_locale_langs_from_accounts_dbus (GDBusProxy *proxy, GPtrArray *langs)\n{\n  const char *accounts_bus_name = \"org.freedesktop.Accounts\";\n  const char *accounts_interface_name = \"org.freedesktop.Accounts.User\";\n  g_auto(GStrv) object_paths = NULL;\n  int i;\n  g_autoptr(GVariant) ret = NULL;\n\n  ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),\n                                \"ListCachedUsers\",\n                                g_variant_new (\"()\"),\n                                G_DBUS_CALL_FLAGS_NONE,\n                                -1,\n                                NULL,\n                                NULL);\n  if (ret != NULL)\n    g_variant_get (ret,\n                   \"(^ao)\",\n                   &object_paths);\n\n  if (object_paths != NULL)\n    {\n      for (i = 0; object_paths[i] != NULL; i++)\n        {\n          g_autoptr(GDBusProxy) accounts_proxy = NULL;\n          g_autoptr(GVariant) value = NULL;\n\n          accounts_proxy = g_dbus_proxy_new_for_bus_sync (G_BUS_TYPE_SYSTEM,\n                                                          G_DBUS_PROXY_FLAGS_NONE,\n                                                          NULL,\n                                                          accounts_bus_name,\n                                                          object_paths[i],\n                                                          accounts_interface_name,\n                                                          NULL,\n                                                          NULL);\n\n          if (accounts_proxy)\n            {\n              value = g_dbus_proxy_get_cached_property (accounts_proxy, \"Language\");\n              if (value != NULL)\n                {\n                  const char *locale = g_variant_get_string (value, NULL);\n                  g_autofree char *lang = NULL;\n\n                  if (strcmp (locale, \"\") == 0)\n                    continue; /* This user wants the system default locale */\n\n                  lang = flatpak_get_lang_from_locale (locale);\n                  if (lang != NULL && !flatpak_g_ptr_array_contains_string (langs, lang))\n                    g_ptr_array_add (langs, g_steal_pointer (&lang));\n                }\n            }\n        }\n    }\n}\n\nstatic int\ncmpstringp (const void *p1, const void *p2)\n{\n  return strcmp (*(char * const *) p1, *(char * const *) p2);\n}\n\nstatic char **\nsort_strv (char **strv)\n{\n  qsort (strv, g_strv_length (strv), sizeof (const char *), cmpstringp);\n  return strv;\n}\n\nstatic char **\nflatpak_dir_get_config_strv (FlatpakDir *self, char *key) \n{\n  GKeyFile *config = flatpak_dir_get_repo_config (self);\n  g_auto(GStrv) lang = NULL;\n\n  if (config)\n    {\n      if (g_key_file_has_key (config, \"core\", key, NULL))\n        {\n          lang = g_key_file_get_string_list (config, \"core\", key, NULL, NULL);\n          return g_steal_pointer (&lang);\n        }\n    }\n  return NULL;\n}\n\nstatic const GPtrArray *\nget_system_locales (FlatpakDir *self)\n{\n  static GPtrArray *cached = NULL;\n\n  if (g_once_init_enter (&cached))\n    {\n      GPtrArray *langs = g_ptr_array_new_with_free_func (g_free);\n      g_autoptr(GDBusProxy) localed_proxy = NULL;\n      g_autoptr(GDBusProxy) accounts_proxy = NULL;\n\n      /* Get the system default locales */\n      localed_proxy = get_localed_dbus_proxy ();\n      if (localed_proxy != NULL)\n        get_locale_langs_from_localed_dbus (localed_proxy, langs);\n\n      /* Now add the user account locales from AccountsService. If accounts_proxy is\n       * not NULL, it means that AccountsService exists */\n      accounts_proxy = get_accounts_dbus_proxy ();\n      if (accounts_proxy != NULL)\n        get_locale_langs_from_accounts_dbus (accounts_proxy, langs);\n\n      g_ptr_array_add (langs, NULL);\n\n      g_once_init_leave (&cached, langs);\n    }\n\n  return (const GPtrArray *)cached;\n}\n\nchar **\nflatpak_dir_get_default_locales (FlatpakDir *self)\n{\n  g_auto(GStrv) extra_languages = NULL;\n  const GPtrArray *langs;\n\n  extra_languages = flatpak_dir_get_config_strv (self, \"xa.extra-languages\");\n\n  if (flatpak_dir_is_user (self))\n    {\n      g_auto(GStrv) locale_langs = flatpak_get_current_locale_langs ();\n\n      return sort_strv (flatpak_strv_merge (extra_languages, locale_langs));\n    }\n\n  /* Then get the system default locales */\n  langs = get_system_locales (self);\n\n  return sort_strv (flatpak_strv_merge (extra_languages, (char **) langs->pdata));\n}\n\nchar **\nflatpak_dir_get_default_locale_languages (FlatpakDir *self)\n{\n  g_auto(GStrv) extra_languages = NULL;\n  const GPtrArray *langs;\n  int i;\n\n  extra_languages = flatpak_dir_get_config_strv (self, \"xa.extra-languages\");\n  for (i = 0; extra_languages != NULL && extra_languages[i] != NULL; i++)\n    {\n      /* Strip the locale, modifier or codeset, if present. */\n      gchar *match = strpbrk (extra_languages[i], \"._@\");\n      if (match != NULL)\n        *match = '\\0';\n    }\n\n  if (flatpak_dir_is_user (self))\n    {\n      g_auto(GStrv) locale_langs = flatpak_get_current_locale_langs ();\n\n      return sort_strv (flatpak_strv_merge (extra_languages, locale_langs));\n    }\n\n  /* Then get the system default locales */\n  langs = get_system_locales (self);\n\n  return sort_strv (flatpak_strv_merge (extra_languages, (char **) langs->pdata));\n}\n\nchar **\nflatpak_dir_get_locales (FlatpakDir *self)\n{\n  char **langs = NULL;\n\n  /* Fetch the list of languages specified by xa.languages - if this key is empty,\n   * this would mean that all languages are accepted. You can read the man for the\n   * flatpak-config section for more info.\n   */\n  langs = flatpak_dir_get_config_strv (self, \"xa.languages\");\n  if (langs)\n    return sort_strv (langs);\n\n  return flatpak_dir_get_default_locales (self);\n}\n\n\nchar **\nflatpak_dir_get_locale_languages (FlatpakDir *self)\n{\n  char **langs = NULL;\n\n  /* Fetch the list of languages specified by xa.languages - if this key is empty,\n   * this would mean that all languages are accepted. You can read the man for the\n   * flatpak-config section for more info.\n   */\n  langs = flatpak_dir_get_config_strv (self, \"xa.languages\");\n  if (langs)\n    return sort_strv (langs);\n\n  return flatpak_dir_get_default_locale_languages (self);\n}\n\nchar **\nflatpak_dir_get_locale_subpaths (FlatpakDir *self)\n{\n  char **subpaths = flatpak_dir_get_locale_languages (self);\n  int i;\n\n  /* Convert languages to paths */\n  for (i = 0; subpaths[i] != NULL; i++)\n    {\n      char *lang = subpaths[i];\n      /* For backwards compat with old xa.languages we support the configuration having slashes already */\n      if (*lang != '/')\n        {\n          subpaths[i] = g_strconcat (\"/\", lang, NULL);\n          g_free (lang);\n        }\n    }\n  return subpaths;\n}\n\nvoid\nflatpak_dir_set_source_pid (FlatpakDir *self,\n                            pid_t       pid)\n{\n  self->source_pid = pid;\n}\n\npid_t\nflatpak_dir_get_source_pid (FlatpakDir *self)\n{\n  return self->source_pid;\n}\n\nstatic void\n  (flatpak_dir_log) (FlatpakDir * self,\n                     const char *file,\n                     int line,\n                     const char *func,\n                     const char *source, /* overrides self->name */\n                     const char *change,\n                     const char *remote,\n                     const char *ref,\n                     const char *commit,\n                     const char *old_commit,\n                     const char *url,\n                     const char *format,\n                     ...)\n{\n#ifdef HAVE_LIBSYSTEMD\n  const char *installation = source ? source : flatpak_dir_get_name_cached (self);\n  pid_t source_pid = flatpak_dir_get_source_pid (self);\n  char message[1024];\n  int len;\n  va_list args;\n\n  len = g_snprintf (message, sizeof (message), \"%s: \", installation);\n\n  va_start (args, format);\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wformat-nonliteral\"\n  g_vsnprintf (message + len, sizeof (message) - len, format, args);\n#pragma GCC diagnostic pop\n\n  va_end (args);\n\n  /* See systemd.journal-fields(7) for the meaning of the\n   * standard fields we use, in particular OBJECT_PID\n   */\n  sd_journal_send (\"MESSAGE_ID=\" FLATPAK_MESSAGE_ID,\n                   \"PRIORITY=5\",\n                   \"OBJECT_PID=%d\", source_pid,\n                   \"CODE_FILE=%s\", file,\n                   \"CODE_LINE=%d\", line,\n                   \"CODE_FUNC=%s\", func,\n                   \"MESSAGE=%s\", message,\n                   /* custom fields below */\n                   \"FLATPAK_VERSION=\" PACKAGE_VERSION,\n                   \"INSTALLATION=%s\", installation,\n                   \"OPERATION=%s\", change,\n                   \"REMOTE=%s\", remote ? remote : \"\",\n                   \"REF=%s\", ref ? ref : \"\",\n                   \"COMMIT=%s\", commit ? commit : \"\",\n                   \"OLD_COMMIT=%s\", old_commit ? old_commit : \"\",\n                   \"URL=%s\", url ? url : \"\",\n                   NULL);\n#endif\n}\n\n/* Delete refs that are in refs/mirrors/ rather than refs/remotes/ to prevent\n * disk space from leaking. See https://github.com/flatpak/flatpak/issues/3222\n * The caller is responsible for ensuring that @dir has a repo, and for pruning\n * the repo after calling this function to actually free the disk space.\n */\ngboolean\nflatpak_dir_delete_mirror_refs (FlatpakDir    *self,\n                                gboolean       dry_run,\n                                GCancellable  *cancellable,\n                                GError       **error)\n{\n  g_autoptr(GHashTable) collection_refs = NULL;  /* (element-type OstreeCollectionRef utf8) */\n  g_autoptr(GPtrArray) ignore_collections = g_ptr_array_new_with_free_func (g_free); /* (element-type utf8) */\n  g_auto(GStrv) remotes = NULL;\n  const char *repo_collection_id;\n  OstreeRepo *repo;\n  int i;\n\n  /* Generally a flatpak repo should not have its own collection ID set, but\n   * check just in case flatpak is being run on a server for some reason. When\n   * a repo has a collection ID set, its own refs from refs/heads/ will be\n   * listed by the ostree_repo_list_collection_refs() call below, and we need\n   * to be sure not to delete them. There would be no reason to install from a\n   * server to itself, so we don't expect refs matching repo_collection_id to\n   * be in refs/mirrors/.\n   */\n  repo = flatpak_dir_get_repo (self);\n  repo_collection_id = ostree_repo_get_collection_id (repo);\n  if (repo_collection_id != NULL)\n    g_ptr_array_add (ignore_collections, g_strdup (repo_collection_id));\n\n  /* Check also for any disabled remotes and ignore any associated\n   * collection-refs; in the case of Endless this would be the remote used for\n   * OS updates which Flatpak shouldn't touch.\n   */\n  remotes = ostree_repo_remote_list (repo, NULL);\n  for (i = 0; remotes != NULL && remotes[i] != NULL; i++)\n    {\n      g_autofree char *remote_collection_id = NULL;\n\n      if (!flatpak_dir_get_remote_disabled (self, remotes[i]))\n        continue;\n      remote_collection_id = flatpak_dir_get_remote_collection_id (self, remotes[i]);\n      if (remote_collection_id != NULL)\n        g_ptr_array_add (ignore_collections, g_steal_pointer (&remote_collection_id));\n    }\n  g_ptr_array_add (ignore_collections, NULL);\n\n  if (!ostree_repo_list_collection_refs (repo, NULL, &collection_refs,\n                                         OSTREE_REPO_LIST_REFS_EXT_EXCLUDE_REMOTES,\n                                         cancellable, error))\n    return FALSE;\n\n  /* Now delete any collection-refs which are in refs/mirrors/, were created by\n   * Flatpak, and don't belong to a disabled remote.\n   */\n  GLNX_HASH_TABLE_FOREACH (collection_refs, const OstreeCollectionRef *, c_r)\n    {\n      if (g_strv_contains ((const char * const *)ignore_collections->pdata, c_r->collection_id))\n        {\n          g_debug (\"Ignoring collection-ref (%s, %s) since its remote is disabled or it matches the repo collection ID\",\n                   c_r->collection_id, c_r->ref_name);\n          continue;\n        }\n\n      /* Only delete refs which Flatpak created; the repo may have other\n       * users. We could check only for refs that come from configured\n       * remotes, but that would not cover the case of if a remote was\n       * deleted.\n       */\n      if (g_str_has_prefix (c_r->ref_name, \"app/\") ||\n          g_str_has_prefix (c_r->ref_name, \"runtime/\") ||\n          g_str_has_prefix (c_r->ref_name, \"appstream/\") ||\n          g_str_has_prefix (c_r->ref_name, \"appstream2/\") ||\n          g_strcmp0 (c_r->ref_name, OSTREE_REPO_METADATA_REF) == 0)\n        {\n          if (dry_run)\n            g_print (_(\"Skipping deletion of mirror ref (%s, %s)\u2026\\n\"), c_r->collection_id, c_r->ref_name);\n          else\n            {\n              if (!ostree_repo_set_collection_ref_immediate (repo, c_r, NULL, cancellable, error))\n                return FALSE;\n            }\n        }\n    }\n\n  return TRUE;\n}\n\n\nstatic gboolean\ndir_get_metadata (FlatpakDir        *dir,\n                  FlatpakDecomposed *ref,\n                  GKeyFile         **out_metakey)\n{\n  g_autoptr(GFile) deploy_dir = NULL;\n  g_autoptr(GKeyFile) metakey = NULL;\n  g_autoptr(GFile) metadata = NULL;\n  g_autofree char *metadata_contents = NULL;\n  gsize metadata_size;\n\n  deploy_dir = flatpak_dir_get_if_deployed (dir, ref, NULL, NULL);\n  if (deploy_dir == NULL)\n    return FALSE;\n\n  metadata = g_file_get_child (deploy_dir, \"metadata\");\n  if (!g_file_load_contents (metadata, NULL, &metadata_contents, &metadata_size, NULL, NULL))\n    return FALSE;\n\n  metakey = g_key_file_new ();\n  if (!g_key_file_load_from_data (metakey, metadata_contents, metadata_size, 0, NULL))\n    return FALSE;\n\n  *out_metakey = g_steal_pointer (&metakey);\n\n  return TRUE;\n}\n\nstatic gboolean\nmaybe_get_metakey (FlatpakDir        *dir,\n                   FlatpakDir        *shadowing_dir,\n                   FlatpakDecomposed *ref,\n                   GHashTable        *metadata_injection,\n                   GKeyFile         **out_metakey,\n                   gboolean          *out_ref_is_shadowed)\n{\n  if (shadowing_dir &&\n      dir_get_metadata (shadowing_dir, ref, out_metakey))\n    {\n      *out_ref_is_shadowed = TRUE;\n      return TRUE;\n    }\n\n  if (metadata_injection != NULL)\n    {\n      GKeyFile *injected_metakey = g_hash_table_lookup (metadata_injection, flatpak_decomposed_get_ref (ref));\n      if (injected_metakey != NULL)\n        {\n          *out_ref_is_shadowed = FALSE;\n          *out_metakey = g_key_file_ref (injected_metakey);\n          return TRUE;\n        }\n    }\n\n  if (dir_get_metadata (dir, ref, out_metakey))\n    {\n      *out_ref_is_shadowed = FALSE;\n      return TRUE;\n    }\n\n  return FALSE;\n}\n\nstatic void\nqueue_ref_for_analysis (FlatpakDecomposed *ref,\n                        const char *arch,\n                        GHashTable *analyzed_refs,\n                        GQueue     *refs_to_analyze)\n{\n  if (arch != NULL && !flatpak_decomposed_is_arch (ref, arch))\n    return;\n\n  if (g_hash_table_lookup (analyzed_refs, ref) != NULL)\n    return;\n\n  g_hash_table_add (analyzed_refs, flatpak_decomposed_ref (ref));\n  g_queue_push_tail (refs_to_analyze, ref); /* owned by analyzed_refs */\n}\n\n/* This traverses from all the \"root\" refs and into for any recursive dependencies in @self\n * that they use. In the regular case we just consider the @self installation,\n * but we can also handle the case where another directory \"shadows\" self. For example\n * we might be looking for used refs in the \"system\" dir, and the \"user\" dir is\n * shadowing it, meaning that if a ref is installed in the user dir it is considered used\n * from there instead of @self. So, analyzed refs from @shadowing_dir are *not* put\n * in @used_ref (although their dependencies may).\n *\n * Notes:\n *  The \"root\" refs come from @shadowing_dir if not %NULL and @self otherwise.\n *  refs_to_exclude, and metadata_injection both only affect @self, not @shadowing_dir\n */\nstatic GHashTable *\nfind_used_refs (FlatpakDir         *self,\n                FlatpakDir         *shadowing_dir, /* nullable */\n                const char         *arch,\n                GHashTable         *metadata_injection,\n                GHashTable         *refs_to_exclude,\n                GHashTable         *used_refs, /* This is filled in */\n                GCancellable       *cancellable,\n                GError            **error)\n{\n  g_autoptr(GPtrArray) root_app_refs = NULL;\n  g_autoptr(GPtrArray) root_runtime_refs = NULL;\n  g_autoptr(GHashTable) analyzed_refs = NULL;\n  g_autoptr(GQueue) refs_to_analyze = NULL;\n  FlatpakDir *root_ref_dir;\n  FlatpakDecomposed *ref_to_analyze;\n\n  refs_to_analyze = g_queue_new ();\n  analyzed_refs = g_hash_table_new_full ((GHashFunc)flatpak_decomposed_hash, (GEqualFunc)flatpak_decomposed_equal, (GDestroyNotify)flatpak_decomposed_unref, NULL);\n\n  if (shadowing_dir)\n    root_ref_dir = shadowing_dir;\n  else\n    root_ref_dir = self;\n\n  root_app_refs = flatpak_dir_list_refs (root_ref_dir, FLATPAK_KINDS_APP, cancellable, error);\n  if (root_app_refs == NULL)\n    return NULL;\n\n  for (int i = 0; i < root_app_refs->len; i++)\n    {\n      FlatpakDecomposed *root_app_ref = g_ptr_array_index (root_app_refs, i);\n      queue_ref_for_analysis (root_app_ref, arch, analyzed_refs, refs_to_analyze);\n    }\n\n  root_runtime_refs = flatpak_dir_list_refs (root_ref_dir, FLATPAK_KINDS_RUNTIME, cancellable, error);\n  if (root_runtime_refs == NULL)\n    return NULL;\n\n  for (int i = 0; i < root_runtime_refs->len; i++)\n    {\n      FlatpakDecomposed *root_runtime_ref = g_ptr_array_index (root_runtime_refs, i);\n      /* Consider all shadow dir runtimes as roots because we don't really do full analysis for shadowing_dir.\n       * For example a system installed app could end up using the user version of a runtime, which in turn\n       * uses a system gl extension.\n       *\n       * However, for non-shadowed runtime refs, only pinned ones are roots */\n      if (root_ref_dir == shadowing_dir ||\n          flatpak_dir_ref_is_pinned (root_ref_dir, flatpak_decomposed_get_ref (root_runtime_ref)))\n        queue_ref_for_analysis (root_runtime_ref, arch, analyzed_refs, refs_to_analyze);\n    }\n\n  /* Any injected refs are considered used, because this is used by transaction\n   * to emulate installing a new ref, and we never want the new ref:s dependencies\n   * seem ununsed. */\n  if (metadata_injection)\n    {\n      GLNX_HASH_TABLE_FOREACH (metadata_injection, const char *, injected_ref)\n        {\n          g_autoptr(FlatpakDecomposed) injected = flatpak_decomposed_new_from_ref (injected_ref, NULL);\n          if (injected)\n            queue_ref_for_analysis (injected, arch, analyzed_refs, refs_to_analyze);\n        }\n    }\n\n  while ((ref_to_analyze = g_queue_pop_head (refs_to_analyze)) != NULL)\n    {\n      g_autoptr(GKeyFile) metakey = NULL;\n      gboolean ref_is_shadowed;\n      gboolean is_app;\n      g_autoptr(GPtrArray) related = NULL;\n      g_autofree char *sdk = NULL;\n\n      if (!maybe_get_metakey (self, shadowing_dir, ref_to_analyze, metadata_injection,\n                              &metakey, &ref_is_shadowed))\n        continue; /* Something used something we could not find, that is fine and happens for instance with sdk dependencies */\n\n      if (!ref_is_shadowed)\n        {\n          /* Mark the analyzed ref used as it wasn't shadowed */\n          if (!g_hash_table_contains (used_refs, ref_to_analyze))\n            g_hash_table_add (used_refs, flatpak_decomposed_ref (ref_to_analyze));\n\n          /* For excluded refs we mark them as used (above) so that they don't get listed as\n           * unused, but we don't analyze them for any dependencies. Note that refs_to_exclude only\n           * affects the base dir, so does not affect shadowed refs */\n          if (refs_to_exclude != NULL && g_hash_table_contains (refs_to_exclude, ref_to_analyze))\n            continue;\n        }\n\n      /************************************************\n       * Find all dependencies and queue for analysis *\n       ***********************************************/\n\n      is_app = flatpak_decomposed_is_app (ref_to_analyze);\n\n      /* App directly depends on its runtime */\n      if (is_app)\n        {\n          g_autofree char *runtime = g_key_file_get_string (metakey, \"Application\", \"runtime\", NULL);\n          if (runtime)\n            {\n              g_autoptr(FlatpakDecomposed) runtime_ref = flatpak_decomposed_new_from_pref (FLATPAK_KINDS_RUNTIME, runtime, NULL);\n              if (runtime_ref && !flatpak_decomposed_equal (runtime_ref, ref_to_analyze))\n                queue_ref_for_analysis (runtime_ref, arch, analyzed_refs, refs_to_analyze);\n            }\n        }\n\n      /* Both apps and runtims directly depends on its sdk, to avoid suddenly uninstalling something you use to develop the app */\n      sdk = g_key_file_get_string (metakey, is_app ? \"Application\" : \"Runtime\", \"sdk\", NULL);\n      if (sdk)\n        {\n          g_autoptr(FlatpakDecomposed) sdk_ref = flatpak_decomposed_new_from_pref (FLATPAK_KINDS_RUNTIME, sdk, NULL);\n          if (sdk_ref && !flatpak_decomposed_equal (sdk_ref, ref_to_analyze))\n            queue_ref_for_analysis (sdk_ref, arch, analyzed_refs, refs_to_analyze);\n        }\n\n      /* Extensions with extra data, that are not specially marked NoRuntime needs the runtime at install.\n       * Lets keep it around to not re-download it next update */\n      if (!is_app &&\n          g_key_file_has_group (metakey, \"Extra Data\") &&\n          !g_key_file_get_boolean (metakey, \"Extra Data\", \"NoRuntime\", NULL))\n        {\n          g_autofree char *extension_runtime_ref = g_key_file_get_string (metakey, \"ExtensionOf\", \"runtime\", NULL);\n          if (extension_runtime_ref != NULL)\n            {\n              g_autoptr(FlatpakDecomposed) d = flatpak_decomposed_new_from_ref (extension_runtime_ref, NULL);\n              if (d)\n                queue_ref_for_analysis (d, arch, analyzed_refs, refs_to_analyze);\n            }\n        }\n\n      /* We pass NULL for remote-name here, because we want to consider related refs from all remotes */\n      related = flatpak_dir_find_local_related_for_metadata (self, ref_to_analyze,\n                                                             NULL, metakey, NULL, NULL);\n      for (int i = 0; related != NULL && i < related->len; i++)\n        {\n          FlatpakRelated *rel = g_ptr_array_index (related, i);\n\n          if (!rel->auto_prune)\n            {\n              queue_ref_for_analysis (rel->ref, arch, analyzed_refs, refs_to_analyze);\n            }\n        }\n    }\n\n  return g_steal_pointer (&used_refs);\n}\n\n/* See the documentation for\n * flatpak_installation_list_unused_refs_with_options().\n * The returned pointer array is transfer full. */\nchar **\nflatpak_dir_list_unused_refs (FlatpakDir         *self,\n                              const char         *arch,\n                              GHashTable         *metadata_injection,\n                              GHashTable         *eol_injection,\n                              const char * const *refs_to_exclude,\n                              gboolean            filter_by_eol,\n                              GCancellable       *cancellable,\n                              GError            **error)\n{\n  g_autoptr(GHashTable) used_refs = NULL;\n  g_autoptr(GHashTable) excluded_refs_ht = NULL;\n  g_autoptr(GPtrArray) refs =  NULL;\n  g_autoptr(GPtrArray) runtime_refs = NULL;\n\n  /* Convert refs_to_exclude to hashtable for fast repeated lookups */\n  if (refs_to_exclude)\n    {\n      excluded_refs_ht = g_hash_table_new_full ((GHashFunc)flatpak_decomposed_hash, (GEqualFunc)flatpak_decomposed_equal, (GDestroyNotify)flatpak_decomposed_unref, NULL);\n      for (int i = 0; refs_to_exclude[i] != NULL; i++)\n        {\n          const char *ref_to_exclude = refs_to_exclude[i];\n          g_autoptr(FlatpakDecomposed) d = flatpak_decomposed_new_from_ref (ref_to_exclude, NULL);\n          if (d)\n            g_hash_table_add (excluded_refs_ht, flatpak_decomposed_ref (d));\n        }\n    }\n\n  used_refs = g_hash_table_new_full ((GHashFunc)flatpak_decomposed_hash, (GEqualFunc)flatpak_decomposed_equal, (GDestroyNotify)flatpak_decomposed_unref, NULL);\n\n  if (!find_used_refs (self, NULL, arch, metadata_injection, excluded_refs_ht,\n                       used_refs, cancellable, error))\n    return NULL;\n\n  /* If @self is a system installation, also check the per-user installation\n   * for any apps there using runtimes in the system installation or runtimes\n   * there with sdks or extensions in the system installation. Only do so if\n   * the per-user installation exists; it wouldn't make sense to create it here\n   * if not.\n   */\n  if (!flatpak_dir_is_user (self))\n    {\n      g_autoptr(FlatpakDir) user_dir = flatpak_dir_get_user ();\n      g_autoptr(GError) local_error = NULL;\n\n      if (!find_used_refs (self, user_dir, arch, metadata_injection, excluded_refs_ht,\n                           used_refs, cancellable, &local_error))\n        {\n          /* We may get permission denied if the process is sandboxed with\n           * systemd's ProtectHome=\n           */\n          if (!g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND) &&\n              !g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_PERMISSION_DENIED))\n            {\n              g_propagate_error (error, g_steal_pointer (&local_error));\n              return NULL;\n            }\n        }\n    }\n\n  runtime_refs = flatpak_dir_list_refs (self, FLATPAK_KINDS_RUNTIME, cancellable, error);\n  if (runtime_refs == NULL)\n    return NULL;\n\n  refs = g_ptr_array_new_with_free_func (g_free);\n\n  for (int i = 0; i < runtime_refs->len; i++)\n    {\n      FlatpakDecomposed *ref = g_ptr_array_index (runtime_refs, i);\n\n      if (g_hash_table_contains (used_refs, ref))\n        continue;\n\n      if (arch != NULL && !flatpak_decomposed_is_arch (ref, arch))\n        continue;\n\n      if (filter_by_eol)\n        {\n          gboolean is_eol = FALSE;\n\n          if (eol_injection && g_hash_table_contains (eol_injection, flatpak_decomposed_get_ref (ref)))\n            {\n              is_eol = GPOINTER_TO_INT (g_hash_table_lookup (eol_injection, ref));\n            }\n          else\n            {\n              g_autoptr(GBytes) deploy_data = NULL;\n\n              /* deploy v4 guarantees eol/eolr info */\n              deploy_data = flatpak_dir_get_deploy_data (self, ref, 4,\n                                                         cancellable, NULL);\n              is_eol = deploy_data != NULL &&\n                (flatpak_deploy_data_get_eol (deploy_data) != NULL ||\n                 flatpak_deploy_data_get_eol_rebase (deploy_data));\n            }\n\n          if (!is_eol)\n            continue;\n        }\n\n      g_ptr_array_add (refs, flatpak_decomposed_dup_ref (ref));\n    }\n\n  g_ptr_array_add (refs, NULL);\n  return (char **)g_ptr_array_free (g_steal_pointer (&refs), FALSE);\n}\n"], "fixing_code": ["/*\n * Copyright \u00a9 2014-2019 Red Hat, Inc\n * Copyright \u00a9 2017 Endless Mobile, Inc.\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\t See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library. If not, see <http://www.gnu.org/licenses/>.\n *\n * Authors:\n *       Alexander Larsson <alexl@redhat.com>\n *       Philip Withnall <withnall@endlessm.com>\n *       Matthew Leeds <matthew.leeds@endlessm.com>\n */\n\n#include \"config.h\"\n\n#include <errno.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/file.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <utime.h>\n\n#include <glib/gi18n-lib.h>\n#include <glib/gstdio.h>\n\n#include <libxml/parser.h>\n#include <libxml/tree.h>\n\n#include <gio/gio.h>\n#include <gio/gunixsocketaddress.h>\n#include <ostree.h>\n\n#ifdef USE_SYSTEM_HELPER\n#include <polkit/polkit.h>\n#endif\n\n#include \"flatpak-appdata-private.h\"\n#include \"flatpak-dir-private.h\"\n#include \"flatpak-error.h\"\n#include \"flatpak-oci-registry-private.h\"\n#include \"flatpak-ref.h\"\n#include \"flatpak-run-private.h\"\n#include \"flatpak-utils-base-private.h\"\n#include \"flatpak-variant-private.h\"\n#include \"flatpak-variant-impl-private.h\"\n#include \"libglnx/libglnx.h\"\n\n#ifdef HAVE_LIBMALCONTENT\n#include <libmalcontent/malcontent.h>\n#include \"flatpak-parental-controls-private.h\"\n#endif\n\n#ifdef HAVE_LIBSYSTEMD\n#define SD_JOURNAL_SUPPRESS_LOCATION\n#include <systemd/sd-journal.h>\n#endif\n\n#define NO_SYSTEM_HELPER ((FlatpakSystemHelper *) (gpointer) 1)\n\n#define SUMMARY_CACHE_TIMEOUT_SEC (60 * 5)\n#define FILTER_MTIME_CHECK_TIMEOUT_MSEC 500\n\n#define SYSCONF_INSTALLATIONS_DIR \"installations.d\"\n#define SYSCONF_INSTALLATIONS_FILE_EXT \".conf\"\n#define SYSCONF_REMOTES_DIR \"remotes.d\"\n#define SYSCONF_REMOTES_FILE_EXT \".flatpakrepo\"\n\n#define SIDELOAD_REPOS_DIR_NAME \"sideload-repos\"\n\n#ifdef USE_SYSTEM_HELPER\n/* This uses a weird Auto prefix to avoid conflicts with later added polkit types.\n */\ntypedef PolkitAuthority           AutoPolkitAuthority;\ntypedef PolkitAuthorizationResult AutoPolkitAuthorizationResult;\ntypedef PolkitDetails             AutoPolkitDetails;\ntypedef PolkitSubject             AutoPolkitSubject;\n\nG_DEFINE_AUTOPTR_CLEANUP_FUNC (AutoPolkitAuthority, g_object_unref)\nG_DEFINE_AUTOPTR_CLEANUP_FUNC (AutoPolkitAuthorizationResult, g_object_unref)\nG_DEFINE_AUTOPTR_CLEANUP_FUNC (AutoPolkitDetails, g_object_unref)\nG_DEFINE_AUTOPTR_CLEANUP_FUNC (AutoPolkitSubject, g_object_unref)\n#endif\n\nstatic FlatpakOciRegistry *flatpak_dir_create_system_child_oci_registry (FlatpakDir   *self,\n                                                                         GLnxLockFile *file_lock,\n                                                                         const char   *token,\n                                                                         GError      **error);\n\nstatic OstreeRepo * flatpak_dir_create_child_repo (FlatpakDir   *self,\n                                                   GFile        *cache_dir,\n                                                   GLnxLockFile *file_lock,\n                                                   const char   *optional_commit,\n                                                   GError      **error);\nstatic OstreeRepo * flatpak_dir_create_system_child_repo (FlatpakDir   *self,\n                                                          GLnxLockFile *file_lock,\n                                                          const char   *optional_commit,\n                                                          GError      **error);\n\nstatic gboolean flatpak_dir_mirror_oci (FlatpakDir          *self,\n                                        FlatpakOciRegistry  *dst_registry,\n                                        FlatpakRemoteState  *state,\n                                        const char          *ref,\n                                        const char          *opt_rev,\n                                        const char          *skip_if_current_is,\n                                        const char          *token,\n                                        FlatpakProgress     *progress,\n                                        GCancellable        *cancellable,\n                                        GError             **error);\n\nstatic gboolean flatpak_dir_remote_fetch_summary (FlatpakDir   *self,\n                                                  const char   *name,\n                                                  gboolean      only_cached,\n                                                  GBytes      **out_summary,\n                                                  GBytes      **out_summary_sig,\n                                                  GCancellable *cancellable,\n                                                  GError      **error);\n\nstatic gboolean flatpak_dir_remote_fetch_summary_index (FlatpakDir   *self,\n                                                        const char   *name_or_uri,\n                                                        gboolean      only_cached,\n                                                        GBytes      **out_index,\n                                                        GBytes      **out_index_sig,\n                                                        GCancellable *cancellable,\n                                                        GError      **error);\n\nstatic gboolean flatpak_dir_remote_fetch_indexed_summary (FlatpakDir   *self,\n                                                          const char   *name_or_uri,\n                                                          const char   *arch,\n                                                          GVariant     *subsummary_info_v,\n                                                          gboolean      only_cached,\n                                                          GBytes      **out_summary,\n                                                          GCancellable *cancellable,\n                                                          GError      **error);\n\nstatic gboolean flatpak_dir_gc_cached_digested_summaries (FlatpakDir   *self,\n                                                          const char   *remote_name,\n                                                          const char   *dont_prune_file,\n                                                          GCancellable *cancellable,\n                                                          GError      **error);\n\nstatic gboolean flatpak_dir_cleanup_remote_for_url_change (FlatpakDir   *self,\n                                                           const char   *remote_name,\n                                                           const char   *url,\n                                                           GCancellable *cancellable,\n                                                           GError      **error);\n\nstatic gboolean flatpak_dir_lookup_remote_filter (FlatpakDir *self,\n                                                  const char *name,\n                                                  gboolean    force_load,\n                                                  char      **checksum_out,\n                                                  GRegex    **allow_regex,\n                                                  GRegex    **deny_regex,\n                                                  GError **error);\n\nstatic void ensure_soup_session (FlatpakDir *self);\n\nstatic void flatpak_dir_log (FlatpakDir *self,\n                             const char *file,\n                             int         line,\n                             const char *func,\n                             const char *source,\n                             const char *change,\n                             const char *remote,\n                             const char *ref,\n                             const char *commit,\n                             const char *old_commit,\n                             const char *url,\n                             const char *format,\n                             ...);\n\n#define flatpak_dir_log(self, change, remote, ref, commit, old_commit, url, format, ...) \\\n  (flatpak_dir_log) (self, __FILE__, __LINE__, __FUNCTION__, \\\n                     NULL, change, remote, ref, commit, old_commit, url, format, __VA_ARGS__)\n\nstatic GBytes *upgrade_deploy_data (GBytes             *deploy_data,\n                                    GFile              *deploy_dir,\n                                    FlatpakDecomposed  *ref,\n                                    OstreeRepo         *repo,\n                                    GCancellable       *cancellable,\n                                    GError            **error);\n\ntypedef struct\n{\n  GBytes *bytes;\n  GBytes *bytes_sig;\n  char   *name;\n  char   *url;\n  guint64 time;\n} CachedSummary;\n\ntypedef struct\n{\n  char                 *id;\n  char                 *display_name;\n  gint                  priority;\n  FlatpakDirStorageType storage_type;\n} DirExtraData;\n\ntypedef struct {\n  GFile *path;\n  GTimeVal mtime;\n  guint64 last_mtime_check;\n  char *checksum;\n  GRegex *allow;\n  GRegex *deny;\n} RemoteFilter;\n\nstruct FlatpakDir\n{\n  GObject          parent;\n\n  gboolean         user;\n  GFile           *basedir;\n  DirExtraData    *extra_data;\n  OstreeRepo      *repo;\n  GFile           *cache_dir;\n  gboolean         no_system_helper;\n  gboolean         no_interaction;\n  pid_t            source_pid;\n\n  GDBusConnection *system_helper_bus;\n\n  GHashTable      *summary_cache;\n\n  GHashTable      *remote_filters;\n\n  /* Config cache, protected by config_cache lock */\n  GRegex          *masked;\n  GRegex          *pinned;\n\n  SoupSession     *soup_session;\n};\n\nG_LOCK_DEFINE_STATIC (config_cache);\n\ntypedef struct\n{\n  GObjectClass parent_class;\n} FlatpakDirClass;\n\nstruct FlatpakDeploy\n{\n  GObject            parent;\n\n  FlatpakDecomposed *ref;\n  GFile             *dir;\n  GKeyFile          *metadata;\n  FlatpakContext    *system_overrides;\n  FlatpakContext    *user_overrides;\n  FlatpakContext    *system_app_overrides;\n  FlatpakContext    *user_app_overrides;\n  OstreeRepo        *repo;\n};\n\ntypedef struct\n{\n  GObjectClass parent_class;\n} FlatpakDeployClass;\n\nG_DEFINE_TYPE (FlatpakDir, flatpak_dir, G_TYPE_OBJECT)\nG_DEFINE_TYPE (FlatpakDeploy, flatpak_deploy, G_TYPE_OBJECT)\n\nenum {\n  PROP_0,\n\n  PROP_USER,\n  PROP_PATH\n};\n\n#define OSTREE_GIO_FAST_QUERYINFO (\"standard::name,standard::type,standard::size,standard::is-symlink,standard::symlink-target,\" \\\n                                   \"unix::device,unix::inode,unix::mode,unix::uid,unix::gid,unix::rdev\")\n\nstatic const char *\nget_config_dir_location (void)\n{\n  static gsize path = 0;\n\n  if (g_once_init_enter (&path))\n    {\n      gsize setup_value = 0;\n      const char *config_dir = g_getenv (\"FLATPAK_CONFIG_DIR\");\n      if (config_dir != NULL)\n        setup_value = (gsize) config_dir;\n      else\n        setup_value = (gsize) FLATPAK_CONFIGDIR;\n      g_once_init_leave (&path, setup_value);\n    }\n\n  return (const char *) path;\n}\n\nstatic const char *\nget_run_dir_location (void)\n{\n  static gsize path = 0;\n\n  if (g_once_init_enter (&path))\n    {\n      gsize setup_value = 0;\n      /* Note: $FLATPAK_RUN_DIR should only be set in the unit tests. At\n       * runtime, /run/flatpak is assumed by\n       * flatpak-create-sideload-symlinks.sh\n       */\n      const char *config_dir = g_getenv (\"FLATPAK_RUN_DIR\");\n      if (config_dir != NULL)\n        setup_value = (gsize) config_dir;\n      else\n        setup_value = (gsize) \"/run/flatpak\";\n      g_once_init_leave (&path, setup_value);\n    }\n\n  return (const char *) path;\n}\n\nstatic void\nflatpak_sideload_state_free (FlatpakSideloadState *sideload_state)\n{\n  g_object_unref (sideload_state->repo);\n  g_variant_unref (sideload_state->summary);\n  g_free (sideload_state);\n}\n\nstatic void\nvariant_maybe_unref (GVariant *variant)\n{\n  if (variant)\n    g_variant_unref (variant);\n}\n\nstatic FlatpakRemoteState *\nflatpak_remote_state_new (void)\n{\n  FlatpakRemoteState *state = g_new0 (FlatpakRemoteState, 1);\n\n  state->refcount = 1;\n  state->sideload_repos = g_ptr_array_new_with_free_func ((GDestroyNotify)flatpak_sideload_state_free);\n  state->subsummaries = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, (GDestroyNotify)variant_maybe_unref);\n  return state;\n}\n\nFlatpakRemoteState *\nflatpak_remote_state_ref (FlatpakRemoteState *remote_state)\n{\n  g_assert (remote_state->refcount > 0);\n  remote_state->refcount++;\n  return remote_state;\n}\n\nvoid\nflatpak_remote_state_unref (FlatpakRemoteState *remote_state)\n{\n  g_assert (remote_state->refcount > 0);\n  remote_state->refcount--;\n\n  if (remote_state->refcount == 0)\n    {\n      g_free (remote_state->remote_name);\n      g_free (remote_state->collection_id);\n      g_clear_pointer (&remote_state->index, g_variant_unref);\n      g_clear_pointer (&remote_state->index_ht, g_hash_table_unref);\n      g_clear_pointer (&remote_state->index_sig_bytes, g_bytes_unref);\n      g_clear_pointer (&remote_state->subsummaries, g_hash_table_unref);\n      g_clear_pointer (&remote_state->summary, g_variant_unref);\n      g_clear_pointer (&remote_state->summary_bytes, g_bytes_unref);\n      g_clear_pointer (&remote_state->summary_sig_bytes, g_bytes_unref);\n      g_clear_error (&remote_state->summary_fetch_error);\n      g_clear_pointer (&remote_state->allow_refs, g_regex_unref);\n      g_clear_pointer (&remote_state->deny_refs, g_regex_unref);\n      g_clear_pointer (&remote_state->sideload_repos, g_ptr_array_unref);\n\n      g_free (remote_state);\n    }\n}\n\nstatic gboolean\n_validate_summary_for_collection_id (GVariant    *summary_v,\n                                     const char  *collection_id,\n                                     GError     **error)\n{\n  VarSummaryRef summary;\n  summary = var_summary_from_gvariant (summary_v);\n\n  if (!flatpak_summary_find_ref_map (summary, collection_id, NULL))\n    return flatpak_fail_error (error, FLATPAK_ERROR_INVALID_DATA,\n                               _(\"Configured collection ID \u2018%s\u2019 not in summary file\"), collection_id);\n\n  return TRUE;\n}\n\nvoid\nflatpak_remote_state_add_sideload_repo (FlatpakRemoteState *self,\n                                        GFile *dir)\n{\n  g_autoptr(GFile) summary_path = NULL;\n  g_autoptr(GMappedFile) mfile = NULL;\n  g_autoptr(OstreeRepo) sideload_repo = NULL;\n\n  /* Sideloading only works if collection id is set */\n  if (self->collection_id == NULL)\n    return;\n\n  summary_path = g_file_get_child (dir, \"summary\");\n  sideload_repo = ostree_repo_new (dir);\n\n  mfile = g_mapped_file_new (flatpak_file_get_path_cached (summary_path), FALSE, NULL);\n  if (mfile != NULL && ostree_repo_open (sideload_repo, NULL, NULL))\n    {\n      g_autoptr(GError) local_error = NULL;\n      g_autoptr(GBytes) summary_bytes = g_mapped_file_get_bytes (mfile);\n      FlatpakSideloadState *ss = g_new0 (FlatpakSideloadState, 1);\n\n      ss->repo = g_steal_pointer (&sideload_repo);\n      ss->summary = g_variant_ref_sink (g_variant_new_from_bytes (OSTREE_SUMMARY_GVARIANT_FORMAT, summary_bytes, TRUE));\n\n      if (!_validate_summary_for_collection_id (ss->summary, self->collection_id, &local_error))\n        {\n          /* We expect to hit this code path when the repo is providing things\n           * from other remotes\n           */\n          g_debug (\"Sideload repo at path %s not valid for remote %s: %s\",\n                   flatpak_file_get_path_cached (dir), self->remote_name, local_error->message);\n          flatpak_sideload_state_free (ss);\n        }\n      else\n        {\n          g_ptr_array_add (self->sideload_repos, ss);\n          g_debug (\"Using sideloaded repo %s for remote %s\", flatpak_file_get_path_cached (dir), self->remote_name);\n        }\n    }\n}\n\ngboolean\nflatpak_remote_state_ensure_summary (FlatpakRemoteState *self,\n                                     GError            **error)\n{\n  if (self->index == NULL && self->summary == NULL)\n    return flatpak_fail_error (error, FLATPAK_ERROR_INVALID_DATA, _(\"Unable to load summary from remote %s: %s\"), self->remote_name,\n                               self->summary_fetch_error != NULL ? self->summary_fetch_error->message : \"unknown error\");\n\n  return TRUE;\n}\n\ngboolean\nflatpak_remote_state_ensure_subsummary (FlatpakRemoteState *self,\n                                        FlatpakDir         *dir,\n                                        const char         *arch,\n                                        gboolean            only_cached,\n                                        GCancellable       *cancellable,\n                                        GError            **error)\n{\n  GVariant *subsummary;\n  const char *alt_arch;\n  GVariant *subsummary_info_v;\n\n  g_autoptr(GBytes) bytes = NULL;\n\n  if (self->summary != NULL)\n    return TRUE; /* We have them all anyway */\n\n  if (self->index == NULL)\n    return TRUE; /* Don't fail unnecessarily in e.g. the sideload case */\n\n  if (g_hash_table_contains (self->subsummaries, arch))\n    return TRUE;\n\n  /* If i.e. we already loaded x86_64 subsummary (which has i386 refs),\n   * don't load i386 one */\n  alt_arch = flatpak_get_compat_arch_reverse (arch);\n  if (alt_arch != NULL &&\n      g_hash_table_contains (self->subsummaries, alt_arch))\n    return TRUE;\n\n  subsummary_info_v = g_hash_table_lookup (self->index_ht, arch);\n  if (subsummary_info_v == NULL)\n    return TRUE; /* No refs for this arch */\n\n  if (!flatpak_dir_remote_fetch_indexed_summary (dir, self->remote_name, arch, subsummary_info_v, only_cached,\n                                                 &bytes, cancellable, error))\n    return FALSE;\n\n  subsummary = g_variant_ref_sink (g_variant_new_from_bytes (OSTREE_SUMMARY_GVARIANT_FORMAT, bytes, FALSE));\n  g_hash_table_insert (self->subsummaries, g_strdup (arch), subsummary);\n\n  return TRUE;\n}\n\ngboolean\nflatpak_remote_state_allow_ref (FlatpakRemoteState *self,\n                                const char *ref)\n{\n  return flatpak_filters_allow_ref (self->allow_refs, self->deny_refs, ref);\n}\n\n\nstatic guint64\nget_timestamp_from_ref_info (VarRefInfoRef info)\n{\n  VarMetadataRef metadata = var_ref_info_get_metadata (info);\n  return GUINT64_FROM_BE(var_metadata_lookup_uint64 (metadata, OSTREE_COMMIT_TIMESTAMP, 0));\n }\n\n\nGFile *\nflatpak_remote_state_lookup_sideload_checksum (FlatpakRemoteState *self,\n                                               char               *checksum)\n{\n  for (int i = 0; i < self->sideload_repos->len; i++)\n    {\n      FlatpakSideloadState *ss = g_ptr_array_index (self->sideload_repos, i);\n      OstreeRepoCommitState commit_state;\n\n      if (ostree_repo_load_commit (ss->repo, checksum, NULL, &commit_state, NULL) &&\n          commit_state == OSTREE_REPO_COMMIT_STATE_NORMAL)\n        return g_object_ref (ostree_repo_get_path (ss->repo));\n    }\n\n  return NULL;\n}\n\nstatic gboolean\nflatpak_remote_state_resolve_sideloaded_ref (FlatpakRemoteState *self,\n                                             const char         *ref,\n                                             char              **out_checksum,\n                                             guint64            *out_timestamp,\n                                             VarRefInfoRef      *out_info,\n                                             FlatpakSideloadState  **out_sideload_state,\n                                             GError            **error)\n{\n  g_autofree char *latest_checksum = NULL;\n  guint64 latest_timestamp = 0;\n  FlatpakSideloadState *latest_ss = NULL;\n  VarRefInfoRef latest_sideload_info;\n\n  for (int i = 0; i < self->sideload_repos->len; i++)\n    {\n      FlatpakSideloadState *ss = g_ptr_array_index (self->sideload_repos, i);\n      g_autofree char *sideload_checksum = NULL;\n      VarRefInfoRef sideload_info;\n\n      if (flatpak_summary_lookup_ref (ss->summary, self->collection_id, ref, &sideload_checksum, &sideload_info))\n        {\n          guint64 timestamp = get_timestamp_from_ref_info (sideload_info);\n\n          if (latest_checksum == 0 || latest_timestamp < timestamp)\n            {\n              g_free (latest_checksum);\n              latest_checksum = g_steal_pointer (&sideload_checksum);\n              latest_timestamp = timestamp;\n              latest_sideload_info = sideload_info;\n              latest_ss = ss;\n            }\n        }\n    }\n\n  if (latest_checksum == NULL)\n    return flatpak_fail_error (error, FLATPAK_ERROR_REF_NOT_FOUND,\n                               _(\"No such ref '%s' in remote %s\"),\n                               ref, self->remote_name);\n\n  if (out_checksum)\n    *out_checksum = g_steal_pointer (&latest_checksum);\n  if (out_timestamp)\n    *out_timestamp = latest_timestamp;\n  if (out_info)\n    *out_info = latest_sideload_info;\n  if (out_sideload_state)\n    *out_sideload_state = latest_ss;\n\n  return TRUE;\n}\n\nstatic GVariant *\nget_summary_for_ref (FlatpakRemoteState *self,\n                     const char *ref)\n{\n  GVariant *summary = NULL;\n\n  if (self->index != NULL)\n    {\n      g_autofree char * arch = flatpak_get_arch_for_ref (ref);\n\n      if (arch != NULL)\n        summary = g_hash_table_lookup (self->subsummaries, arch);\n\n      if (summary == NULL)\n        {\n          const char *non_compat_arch = flatpak_get_compat_arch_reverse (arch);\n\n          if (non_compat_arch != NULL)\n            summary = g_hash_table_lookup (self->subsummaries, non_compat_arch);\n        }\n    }\n  else\n    summary = self->summary;\n\n  return summary;\n}\n\n/* Returns TRUE if the ref is found in the summary or cache.\n * out_checksum and out_variant are only set when the ref is found.\n */\ngboolean\nflatpak_remote_state_lookup_ref (FlatpakRemoteState *self,\n                                 const char         *ref,\n                                 char              **out_checksum,\n                                 guint64            *out_timestamp,\n                                 VarRefInfoRef      *out_info,\n                                 GFile             **out_sideload_path,\n                                 GError            **error)\n{\n  if (!flatpak_remote_state_allow_ref (self, ref))\n    {\n      return flatpak_fail_error (error, FLATPAK_ERROR_REF_NOT_FOUND,\n                                 _(\"No entry for %s in remote '%s' summary flatpak cache \"),\n                                 ref, self->remote_name);\n    }\n\n  /* If there is a summary we use it for metadata and for latest. We may later install from a sideloaded source though */\n  if (self->summary != NULL || self->index != NULL)\n    {\n      VarRefInfoRef info;\n      g_autofree char *checksum = NULL;\n      GVariant *summary;\n\n      summary = get_summary_for_ref (self, ref);\n      if (summary == NULL ||\n          !flatpak_summary_lookup_ref (summary, NULL, ref, &checksum, &info))\n        return flatpak_fail_error (error, FLATPAK_ERROR_REF_NOT_FOUND,\n                                   _(\"No such ref '%s' in remote %s\"),\n                                   ref, self->remote_name);\n\n      /* Even if its available in the summary we want to install it from a sideload repo if available */\n\n      if (out_sideload_path)\n        {\n          g_autoptr(GFile) found_sideload_path = NULL;\n\n          for (int i = 0; i < self->sideload_repos->len; i++)\n            {\n              FlatpakSideloadState *ss = g_ptr_array_index (self->sideload_repos, i);\n              OstreeRepoCommitState commit_state;\n\n              if (ostree_repo_load_commit (ss->repo, checksum, NULL, &commit_state, NULL) &&\n                  commit_state == OSTREE_REPO_COMMIT_STATE_NORMAL)\n                {\n                  found_sideload_path = g_object_ref (ostree_repo_get_path (ss->repo));\n                  break;\n                }\n            }\n\n          *out_sideload_path = g_steal_pointer (&found_sideload_path);\n        }\n\n      if (out_info)\n        *out_info = info;\n      if (out_checksum)\n        *out_checksum = g_steal_pointer (&checksum);\n      if (out_timestamp)\n        *out_timestamp = get_timestamp_from_ref_info (info);\n    }\n  else\n    {\n      FlatpakSideloadState *ss = NULL;\n\n      if (!flatpak_remote_state_resolve_sideloaded_ref (self, ref, out_checksum, out_timestamp, out_info, &ss, error))\n        return FALSE;\n\n      if (out_sideload_path)\n        *out_sideload_path = g_object_ref (ostree_repo_get_path (ss->repo));\n    }\n\n  return TRUE;\n}\n\nGPtrArray *\nflatpak_remote_state_match_subrefs (FlatpakRemoteState *self,\n                                    FlatpakDecomposed *ref)\n{\n  GVariant *summary;\n\n  if (self->summary == NULL && self->index == NULL)\n    {\n      g_debug (\"flatpak_remote_state_match_subrefs with no summary\");\n      return g_ptr_array_new_with_free_func ((GDestroyNotify)flatpak_decomposed_unref);\n    }\n\n  summary = get_summary_for_ref (self, flatpak_decomposed_get_ref (ref));\n  if (summary == NULL)\n    return g_ptr_array_new_with_free_func ((GDestroyNotify)flatpak_decomposed_unref);\n\n  return flatpak_summary_match_subrefs (summary, NULL, ref);\n}\n\nstatic VarMetadataRef\nflatpak_remote_state_get_main_metadata (FlatpakRemoteState *self)\n{\n  VarSummaryRef summary;\n  VarSummaryIndexRef index;\n  VarMetadataRef meta;\n\n  if (self->index)\n    {\n      index = var_summary_index_from_gvariant (self->index);\n      meta = var_summary_index_get_metadata (index);\n    }\n  else if (self->summary)\n    {\n      summary = var_summary_from_gvariant (self->summary);\n      meta = var_summary_get_metadata (summary);\n    }\n  else\n    g_assert_not_reached ();\n\n  return meta;\n}\n\n\n/* 0 if not specified */\nstatic guint32\nflatpak_remote_state_get_cache_version (FlatpakRemoteState *self)\n{\n  VarMetadataRef meta;\n\n  if (!flatpak_remote_state_ensure_summary (self, NULL))\n    return 0;\n\n  meta = flatpak_remote_state_get_main_metadata (self);\n  return GUINT32_FROM_LE (var_metadata_lookup_uint32 (meta, \"xa.cache-version\", 0));\n}\n\ngboolean\nflatpak_remote_state_lookup_cache (FlatpakRemoteState *self,\n                                   const char         *ref,\n                                   guint64            *out_download_size,\n                                   guint64            *out_installed_size,\n                                   const char        **out_metadata,\n                                   GError            **error)\n{\n  VarCacheDataRef cache_data;\n  VarMetadataRef meta;\n  VarSummaryRef summary;\n  guint32 summary_version;\n  GVariant *summary_v;\n\n  if (!flatpak_remote_state_ensure_summary (self, error))\n    return FALSE;\n\n  summary_v = get_summary_for_ref (self, ref);\n  if (summary_v == NULL)\n    return flatpak_fail_error (error, FLATPAK_ERROR_REF_NOT_FOUND,\n                               _(\"No entry for %s in remote '%s' summary flatpak cache \"),\n                               ref, self->remote_name);\n\n\n  summary = var_summary_from_gvariant (summary_v);\n  meta = var_summary_get_metadata (summary);\n\n  summary_version = GUINT32_FROM_LE (var_metadata_lookup_uint32 (meta, \"xa.summary-version\", 0));\n\n  if (summary_version == 0)\n    {\n      VarCacheRef cache;\n      gsize pos;\n      VarVariantRef cache_vv;\n      VarVariantRef cache_v;\n\n      if (!var_metadata_lookup (meta, \"xa.cache\", NULL, &cache_vv))\n        {\n          flatpak_fail_error (error, FLATPAK_ERROR_INVALID_DATA, _(\"No summary or Flatpak cache available for remote %s\"),\n                              self->remote_name);\n          return FALSE;\n        }\n\n      /* For stupid historical reasons the xa.cache is double-wrapped in a variant */\n      cache_v = var_variant_from_variant (cache_vv);\n      cache = var_cache_from_variant (cache_v);\n\n      if (!var_cache_lookup (cache, ref, &pos, &cache_data))\n        return flatpak_fail_error (error, FLATPAK_ERROR_REF_NOT_FOUND,\n                                   _(\"No entry for %s in remote '%s' summary flatpak cache \"),\n                                   ref, self->remote_name);\n    }\n  else if (summary_version == 1)\n    {\n      VarRefMapRef ref_map = var_summary_get_ref_map (summary);\n      VarRefInfoRef info;\n      VarMetadataRef commit_metadata;\n      VarVariantRef cache_data_v;\n\n      if (!flatpak_var_ref_map_lookup_ref (ref_map, ref, &info))\n        return flatpak_fail_error (error, FLATPAK_ERROR_REF_NOT_FOUND,\n                                   _(\"No entry for %s in remote '%s' summary cache \"),\n                                   ref, self->remote_name);\n\n      commit_metadata = var_ref_info_get_metadata (info);\n      if (!var_metadata_lookup (commit_metadata, \"xa.data\", NULL, &cache_data_v))\n        return flatpak_fail_error (error, FLATPAK_ERROR_INVALID_DATA, _(\"Missing xa.data in summary for remote %s\"),\n                                   self->remote_name);\n      cache_data = var_cache_data_from_variant (cache_data_v);\n    }\n  else\n    {\n      flatpak_fail_error (error, FLATPAK_ERROR_INVALID_DATA, _(\"Unsupported summary version %d for remote %s\"),\n                          summary_version, self->remote_name);\n      return FALSE;\n    }\n\n  if (out_installed_size)\n    *out_installed_size = var_cache_data_get_installed_size (cache_data);\n\n  if (out_download_size)\n    *out_download_size = var_cache_data_get_download_size (cache_data);\n\n  if (out_metadata)\n    *out_metadata = var_cache_data_get_metadata (cache_data);\n\n  return TRUE;\n}\n\ngboolean\nflatpak_remote_state_load_data (FlatpakRemoteState *self,\n                                const char         *ref,\n                                guint64            *out_download_size,\n                                guint64            *out_installed_size,\n                                char              **out_metadata,\n                                GError            **error)\n{\n  if (self->summary || self->index)\n    {\n      const char *metadata = NULL;\n      if (!flatpak_remote_state_lookup_cache (self, ref, out_download_size, out_installed_size, &metadata, error))\n        return FALSE;\n\n      if (out_metadata)\n        *out_metadata = g_strdup (metadata);\n    }\n  else\n    {\n      /* Look up from sideload */\n      g_autofree char *checksum = NULL;\n      guint64 timestamp;\n      VarRefInfoRef info;\n      FlatpakSideloadState *ss = NULL;\n      g_autoptr(GVariant) commit_data = NULL;\n      g_autoptr(GVariant) commit_metadata = NULL;\n      const char *xa_metadata = NULL;\n      guint64 download_size = 0;\n      guint64 installed_size = 0;\n\n      /* Use sideload refs if any */\n\n      if (!flatpak_remote_state_resolve_sideloaded_ref (self, ref, &checksum, &timestamp,\n                                                        &info, &ss, error))\n        return FALSE;\n\n      if (!ostree_repo_load_commit (ss->repo, checksum, &commit_data, NULL, error))\n        return FALSE;\n\n      commit_metadata = g_variant_get_child_value (commit_data, 0);\n      g_variant_lookup (commit_metadata, \"xa.metadata\", \"&s\", &xa_metadata);\n      if (xa_metadata == NULL)\n        return flatpak_fail (error, \"No xa.metadata in sideload commit %s ref %s\", checksum, ref);\n\n      if (g_variant_lookup (commit_metadata, \"xa.download-size\", \"t\", &download_size))\n        download_size = GUINT64_FROM_BE (download_size);\n      if (g_variant_lookup (commit_metadata, \"xa.installed-size\", \"t\", &installed_size))\n        installed_size = GUINT64_FROM_BE (installed_size);\n\n      if (out_installed_size)\n        *out_installed_size = installed_size;\n\n      if (out_download_size)\n        *out_download_size = download_size;\n\n      if (out_metadata)\n        *out_metadata = g_strdup (xa_metadata);\n    }\n  return TRUE;\n}\n\nstatic char *\nlookup_oci_registry_uri_from_summary (GVariant *summary,\n                                      GError  **error)\n{\n  g_autoptr(GVariant) extensions = g_variant_get_child_value (summary, 1);\n  g_autofree char *registry_uri = NULL;\n\n  if (!g_variant_lookup (extensions, \"xa.oci-registry-uri\", \"s\", &registry_uri))\n    {\n      flatpak_fail_error (error, FLATPAK_ERROR_INVALID_DATA, _(\"Remote OCI index has no registry uri\"));\n      return NULL;\n    }\n\n  return g_steal_pointer (&registry_uri);\n}\n\nstatic FlatpakOciRegistry *\nflatpak_remote_state_new_oci_registry (FlatpakRemoteState *self,\n                                       const char   *token,\n                                       GCancellable *cancellable,\n                                       GError      **error)\n{\n  g_autofree char *registry_uri = NULL;\n  g_autoptr(FlatpakOciRegistry) registry = NULL;\n\n  if (!flatpak_remote_state_ensure_summary (self, error))\n    return NULL;\n\n  registry_uri = lookup_oci_registry_uri_from_summary (self->summary, error);\n  if (registry_uri == NULL)\n    return NULL;\n\n  registry = flatpak_oci_registry_new (registry_uri, FALSE, -1, NULL, error);\n  if (registry == NULL)\n    return NULL;\n\n  flatpak_oci_registry_set_token (registry, token);\n\n  return g_steal_pointer (&registry);\n}\n\nstatic GVariant *\nflatpak_remote_state_fetch_commit_object_oci (FlatpakRemoteState *self,\n                                              FlatpakDir   *dir,\n                                              const char   *ref,\n                                              const char   *checksum,\n                                              const char   *token,\n                                              GCancellable *cancellable,\n                                              GError      **error)\n{\n  g_autoptr(FlatpakOciRegistry) registry = NULL;\n  g_autoptr(FlatpakOciVersioned) versioned = NULL;\n  g_autoptr(FlatpakOciImage) image_config = NULL;\n  g_autofree char *oci_digest = NULL;\n  g_autofree char *latest_rev = NULL;\n  VarRefInfoRef latest_rev_info;\n  VarMetadataRef metadata;\n  const char *oci_repository = NULL;\n  GHashTable *labels;\n  g_autofree char *subject = NULL;\n  g_autofree char *body = NULL;\n  g_autofree char *manifest_ref = NULL;\n  g_autofree char *parent = NULL;\n  guint64 timestamp = 0;\n  g_autoptr(GVariantBuilder) metadata_builder = g_variant_builder_new (G_VARIANT_TYPE (\"a{sv}\"));\n  g_autoptr(GVariant) metadata_v = NULL;\n\n  registry = flatpak_remote_state_new_oci_registry (self, token, cancellable, error);\n  if (registry == NULL)\n    return NULL;\n\n  /* We extract the rev info from the latest, even if we don't use the latest digest, assuming refs don't move */\n  if (!flatpak_remote_state_lookup_ref (self, ref, &latest_rev, NULL, &latest_rev_info, NULL, error))\n    return NULL;\n\n  if (latest_rev == NULL)\n    {\n      flatpak_fail_error (error, FLATPAK_ERROR_REF_NOT_FOUND,\n                          _(\"Couldn't find ref %s in remote %s\"),\n                          ref, self->remote_name);\n      return NULL;\n    }\n\n  metadata = var_ref_info_get_metadata (latest_rev_info);\n  oci_repository = var_metadata_lookup_string (metadata, \"xa.oci-repository\", NULL);\n\n  oci_digest = g_strconcat (\"sha256:\", checksum, NULL);\n\n  versioned = flatpak_oci_registry_load_versioned (registry, oci_repository, oci_digest,\n                                                   NULL, NULL, cancellable, error);\n  if (versioned == NULL)\n    return NULL;\n\n  if (!FLATPAK_IS_OCI_MANIFEST (versioned))\n    {\n      flatpak_fail_error (error, FLATPAK_ERROR_INVALID_DATA, _(\"Image is not a manifest\"));\n      return NULL;\n    }\n\n  image_config = flatpak_oci_registry_load_image_config (registry, oci_repository,\n                                                         FLATPAK_OCI_MANIFEST (versioned)->config.digest,\n                                                         (const char **)FLATPAK_OCI_MANIFEST (versioned)->config.urls,\n                                                         NULL, cancellable, error);\n  if (image_config == NULL)\n    return NULL;\n\n  labels = flatpak_oci_image_get_labels (image_config);\n  if (labels)\n    flatpak_oci_parse_commit_labels (labels, &timestamp,\n                                     &subject, &body,\n                                     &manifest_ref, NULL, &parent,\n                                     metadata_builder);\n\n\n  if (g_strcmp0 (manifest_ref, ref) != 0)\n    {\n      flatpak_fail_error (error, FLATPAK_ERROR_INVALID_DATA, _(\"Commit has no requested ref \u2018%s\u2019 in ref binding metadata\"),  ref);\n      return NULL;\n    }\n\n  metadata_v = g_variant_ref_sink (g_variant_builder_end (metadata_builder));\n\n  /* This isn't going to be exactly the same as the reconstructed one from the pull, because we don't have the contents, but its useful to get metadata */\n  return\n    g_variant_ref_sink (g_variant_new (\"(@a{sv}@ay@a(say)sst@ay@ay)\",\n                                       metadata_v,\n                                       parent ? ostree_checksum_to_bytes_v (parent) :  g_variant_new_from_data (G_VARIANT_TYPE (\"ay\"), NULL, 0, FALSE, NULL, NULL),\n                                       g_variant_new_array (G_VARIANT_TYPE (\"(say)\"), NULL, 0),\n                                       subject, body,\n                                       GUINT64_TO_BE (timestamp),\n                                       ostree_checksum_to_bytes_v (\"0000000000000000000000000000000000000000000000000000000000000000\"),\n                                       ostree_checksum_to_bytes_v (\"0000000000000000000000000000000000000000000000000000000000000000\")));\n}\n\nstatic GVariant *\nflatpak_remote_state_fetch_commit_object (FlatpakRemoteState *self,\n                                          FlatpakDir   *dir,\n                                          const char   *ref,\n                                          const char   *checksum,\n                                          const char   *token,\n                                          GCancellable *cancellable,\n                                          GError      **error)\n{\n  g_autofree char *base_url = NULL;\n  g_autofree char *object_url = NULL;\n  g_autofree char *part1 = NULL;\n  g_autofree char *part2 = NULL;\n  g_autoptr(GBytes) bytes = NULL;\n  g_autoptr(GVariant) commit_data = NULL;\n  g_autoptr(GVariant) commit_metadata = NULL;\n\n  if (!ostree_repo_remote_get_url (dir->repo, self->remote_name, &base_url, error))\n    return NULL;\n\n  ensure_soup_session (dir);\n\n  part1 = g_strndup (checksum, 2);\n  part2 = g_strdup_printf (\"%s.commit\", checksum + 2);\n\n  object_url = g_build_filename (base_url, \"objects\", part1, part2, NULL);\n\n  bytes = flatpak_load_uri (dir->soup_session, object_url, 0, token,\n                            NULL, NULL, NULL,\n                            cancellable, error);\n  if (bytes == NULL)\n    return NULL;\n\n  commit_data = g_variant_ref_sink (g_variant_new_from_bytes (OSTREE_COMMIT_GVARIANT_FORMAT,\n                                                              bytes, FALSE));\n\n  /* We downloaded this without validating the signature, so we do some basic verification\n     of it. However, the signature will be checked when the download is done, and the final\n     metadata is compared to what we got here, so its pretty ok to use it for resolving\n     the transaction op. However, we do some basic checks. */\n  if (!ostree_validate_structureof_commit (commit_data, error))\n    return NULL;\n\n  commit_metadata = g_variant_get_child_value (commit_data, 0);\n  if (ref != NULL)\n    {\n      const char *xa_ref = NULL;\n      const char *collection_binding = NULL;\n      g_autofree const char **commit_refs = NULL;\n\n      if ((g_variant_lookup (commit_metadata, \"xa.ref\", \"&s\", &xa_ref) &&\n           g_strcmp0 (xa_ref, ref) != 0) ||\n          (g_variant_lookup (commit_metadata, OSTREE_COMMIT_META_KEY_REF_BINDING, \"^a&s\", &commit_refs) &&\n           !g_strv_contains ((const char * const *) commit_refs, ref)))\n        {\n          flatpak_fail_error (error, FLATPAK_ERROR_INVALID_DATA, _(\"Commit has no requested ref \u2018%s\u2019 in ref binding metadata\"),  ref);\n          return NULL;\n        }\n\n      /* Check that the locally configured collection ID is correct by looking\n       * for it in the commit metadata */\n      if (self->collection_id != NULL &&\n          (!g_variant_lookup (commit_metadata, OSTREE_COMMIT_META_KEY_COLLECTION_BINDING, \"&s\", &collection_binding) ||\n           g_strcmp0 (self->collection_id, collection_binding) != 0))\n        {\n          g_autoptr(GVariantIter) collection_refs_iter = NULL;\n          gboolean found_in_collection_refs_binding = FALSE;\n          /* Note: the OSTREE_COMMIT_META_... define for this is not yet merged\n           * in https://github.com/ostreedev/ostree/pull/1805 */\n          if (g_variant_lookup (commit_metadata, \"ostree.collection-refs-binding\", \"a(ss)\", &collection_refs_iter))\n            {\n              const gchar *crb_collection_id, *crb_ref_name;\n              while (g_variant_iter_loop (collection_refs_iter, \"(&s&s)\", &crb_collection_id, &crb_ref_name))\n                {\n                  if (g_strcmp0 (self->collection_id, crb_collection_id) == 0 &&\n                      g_strcmp0 (ref, crb_ref_name) == 0)\n                    {\n                      found_in_collection_refs_binding = TRUE;\n                      break;\n                    }\n                }\n            }\n\n          if (!found_in_collection_refs_binding)\n            {\n              flatpak_fail_error (error, FLATPAK_ERROR_INVALID_DATA,\n                                  _(\"Configured collection ID \u2018%s\u2019 not in binding metadata\"),\n                                  self->collection_id);\n              return NULL;\n            }\n        }\n    }\n\n  return g_steal_pointer (&commit_data);\n}\n\n\n/* Tries to load the specified commit object that we resolved from\n   this remote.  This either comes from the already available local\n   repo, or from one of the sideloading repos, and if not available we\n   download it from the actual remote. */\nGVariant *\nflatpak_remote_state_load_ref_commit (FlatpakRemoteState *self,\n                                      FlatpakDir         *dir,\n                                      const char         *ref,\n                                      const char         *opt_commit,\n                                      const char         *token,\n                                      char              **out_commit,\n                                      GCancellable       *cancellable,\n                                      GError            **error)\n{\n  g_autoptr(GVariant) commit_data = NULL;\n  g_autofree char *commit = NULL;\n\n  if (opt_commit == NULL)\n    {\n      if (!flatpak_remote_state_lookup_ref (self, ref, &commit, NULL, NULL, NULL, error))\n        return NULL;\n\n      if (commit == NULL)\n        {\n          flatpak_fail_error (error, FLATPAK_ERROR_REF_NOT_FOUND,\n                              _(\"Couldn't find latest checksum for ref %s in remote %s\"),\n                              ref, self->remote_name);\n          return NULL;\n        }\n    }\n  else\n    commit = g_strdup (opt_commit);\n\n  /* First try local availability */\n  if (ostree_repo_load_commit (dir->repo, commit, &commit_data, NULL, NULL))\n    goto out;\n\n  for (int i = 0; i < self->sideload_repos->len; i++)\n    {\n      FlatpakSideloadState *ss = g_ptr_array_index (self->sideload_repos, i);\n\n      if (ostree_repo_load_commit (ss->repo, commit, &commit_data, NULL, NULL))\n        goto out;\n    }\n\n  if (flatpak_dir_get_remote_oci (dir, self->remote_name))\n    commit_data = flatpak_remote_state_fetch_commit_object_oci (self, dir, ref, commit, token,\n                                                                cancellable, error);\n  else\n    commit_data = flatpak_remote_state_fetch_commit_object (self, dir, ref, commit, token,\n                                                            cancellable, error);\n\nout:\n  if (out_commit)\n    *out_commit = g_steal_pointer (&commit);\n\n  return g_steal_pointer (&commit_data);\n}\n\n\ngboolean\nflatpak_remote_state_lookup_sparse_cache (FlatpakRemoteState *self,\n                                          const char         *ref,\n                                          VarMetadataRef     *out_metadata,\n                                          GError            **error)\n{\n  VarSummaryRef summary;\n  VarMetadataRef meta;\n  VarVariantRef sparse_cache_v;\n  guint32 summary_version;\n  GVariant *summary_v;\n\n  if (!flatpak_remote_state_ensure_summary (self, error))\n    return FALSE;\n\n  summary_v = get_summary_for_ref (self, ref);\n  if (summary_v == NULL)\n    return flatpak_fail_error (error, FLATPAK_ERROR_REF_NOT_FOUND,\n                             _(\"No entry for %s in remote summary flatpak sparse cache \"), ref);\n\n  summary = var_summary_from_gvariant (summary_v);\n  meta = var_summary_get_metadata (summary);\n\n  summary_version = GUINT32_FROM_LE (var_metadata_lookup_uint32 (meta, \"xa.summary-version\", 0));\n\n  if (summary_version == 0)\n    {\n      if (var_metadata_lookup (meta, \"xa.sparse-cache\", NULL, &sparse_cache_v))\n        {\n          VarSparseCacheRef sparse_cache = var_sparse_cache_from_variant (sparse_cache_v);\n          if (var_sparse_cache_lookup (sparse_cache, ref, NULL, out_metadata))\n            return TRUE;\n        }\n    }\n  else if (summary_version == 1)\n    {\n      VarRefMapRef ref_map = var_summary_get_ref_map (summary);\n      VarRefInfoRef info;\n\n      if (flatpak_var_ref_map_lookup_ref (ref_map, ref, &info))\n        {\n          *out_metadata = var_ref_info_get_metadata (info);\n          return TRUE;\n        }\n    }\n  else\n    {\n      flatpak_fail_error (error, FLATPAK_ERROR_INVALID_DATA, _(\"Unsupported summary version %d for remote %s\"),\n                          summary_version, self->remote_name);\n      return FALSE;\n    }\n\n  return flatpak_fail_error (error, FLATPAK_ERROR_REF_NOT_FOUND,\n                             _(\"No entry for %s in remote summary flatpak sparse cache \"), ref);\n}\n\nstatic DirExtraData *\ndir_extra_data_new (const char           *id,\n                    const char           *display_name,\n                    gint                  priority,\n                    FlatpakDirStorageType type)\n{\n  DirExtraData *dir_extra_data = g_new0 (DirExtraData, 1);\n\n  dir_extra_data->id = g_strdup (id);\n  dir_extra_data->display_name = g_strdup (display_name);\n  dir_extra_data->priority = priority;\n  dir_extra_data->storage_type = type;\n\n  return dir_extra_data;\n}\n\nstatic DirExtraData *\ndir_extra_data_clone (DirExtraData *extra_data)\n{\n  if (extra_data != NULL)\n    return dir_extra_data_new (extra_data->id,\n                               extra_data->display_name,\n                               extra_data->priority,\n                               extra_data->storage_type);\n  return NULL;\n}\n\nstatic void\ndir_extra_data_free (DirExtraData *dir_extra_data)\n{\n  g_free (dir_extra_data->id);\n  g_free (dir_extra_data->display_name);\n  g_free (dir_extra_data);\n}\n\nG_DEFINE_AUTOPTR_CLEANUP_FUNC (DirExtraData, dir_extra_data_free);\n\nstatic GVariant *\nvariant_new_ay_bytes (GBytes *bytes)\n{\n  gsize size;\n  gconstpointer data;\n\n  data = g_bytes_get_data (bytes, &size);\n  g_bytes_ref (bytes);\n  return g_variant_ref_sink (g_variant_new_from_data (G_VARIANT_TYPE (\"ay\"), data, size,\n                                                      TRUE, (GDestroyNotify) g_bytes_unref, bytes));\n}\n\nstatic void\nflatpak_deploy_finalize (GObject *object)\n{\n  FlatpakDeploy *self = FLATPAK_DEPLOY (object);\n\n  g_clear_pointer (&self->ref, flatpak_decomposed_unref);\n  g_clear_object (&self->dir);\n  g_clear_pointer (&self->metadata, g_key_file_unref);\n  g_clear_pointer (&self->system_overrides, flatpak_context_free);\n  g_clear_pointer (&self->user_overrides, flatpak_context_free);\n  g_clear_pointer (&self->system_app_overrides, flatpak_context_free);\n  g_clear_pointer (&self->user_app_overrides, flatpak_context_free);\n  g_clear_object (&self->repo);\n\n  G_OBJECT_CLASS (flatpak_deploy_parent_class)->finalize (object);\n}\n\nstatic void\nflatpak_deploy_class_init (FlatpakDeployClass *klass)\n{\n  GObjectClass *object_class = G_OBJECT_CLASS (klass);\n\n  object_class->finalize = flatpak_deploy_finalize;\n}\n\nstatic void\nflatpak_deploy_init (FlatpakDeploy *self)\n{\n}\n\nGFile *\nflatpak_deploy_get_dir (FlatpakDeploy *deploy)\n{\n  return g_object_ref (deploy->dir);\n}\n\nGBytes *\nflatpak_load_deploy_data (GFile             *deploy_dir,\n                          FlatpakDecomposed *ref,\n                          OstreeRepo        *repo,\n                          int                required_version,\n                          GCancellable      *cancellable,\n                          GError           **error)\n{\n  g_autoptr(GFile) data_file = NULL;\n  g_autoptr(GBytes) deploy_data = NULL;\n  gchar *contents;\n  gsize len;\n\n  data_file = g_file_get_child (deploy_dir, \"deploy\");\n\n  if (!g_file_load_contents (data_file, cancellable, &contents, &len, NULL, error))\n    return NULL;\n\n  deploy_data = g_bytes_new_take (contents, len);\n\n  if (flatpak_deploy_data_get_version (deploy_data) < required_version)\n    return upgrade_deploy_data (deploy_data, deploy_dir, ref, repo, cancellable, error);\n\n  return g_steal_pointer (&deploy_data);\n}\n\n\nGBytes *\nflatpak_deploy_get_deploy_data (FlatpakDeploy *deploy,\n                                int            required_version,\n                                GCancellable  *cancellable,\n                                GError       **error)\n{\n  return flatpak_load_deploy_data (deploy->dir,\n                                   deploy->ref,\n                                   deploy->repo,\n                                   required_version,\n                                   cancellable,\n                                   error);\n}\n\nGFile *\nflatpak_deploy_get_files (FlatpakDeploy *deploy)\n{\n  return g_file_get_child (deploy->dir, \"files\");\n}\n\nFlatpakContext *\nflatpak_deploy_get_overrides (FlatpakDeploy *deploy)\n{\n  FlatpakContext *overrides = flatpak_context_new ();\n\n  if (deploy->system_overrides)\n    flatpak_context_merge (overrides, deploy->system_overrides);\n\n  if (deploy->system_app_overrides)\n    flatpak_context_merge (overrides, deploy->system_app_overrides);\n\n  if (deploy->user_overrides)\n    flatpak_context_merge (overrides, deploy->user_overrides);\n\n  if (deploy->user_app_overrides)\n    flatpak_context_merge (overrides, deploy->user_app_overrides);\n\n  return overrides;\n}\n\nGKeyFile *\nflatpak_deploy_get_metadata (FlatpakDeploy *deploy)\n{\n  return g_key_file_ref (deploy->metadata);\n}\n\nstatic FlatpakDeploy *\nflatpak_deploy_new (GFile             *dir,\n                    FlatpakDecomposed *ref,\n                    GKeyFile          *metadata,\n                    OstreeRepo        *repo)\n{\n  FlatpakDeploy *deploy;\n\n  deploy = g_object_new (FLATPAK_TYPE_DEPLOY, NULL);\n  deploy->ref = flatpak_decomposed_ref (ref);\n  deploy->dir = g_object_ref (dir);\n  deploy->metadata = g_key_file_ref (metadata);\n  deploy->repo = g_object_ref (repo);\n\n  return deploy;\n}\n\nGFile *\nflatpak_get_system_default_base_dir_location (void)\n{\n  static gsize path = 0;\n\n  if (g_once_init_enter (&path))\n    {\n      gsize setup_value = 0;\n      const char *system_dir = g_getenv (\"FLATPAK_SYSTEM_DIR\");\n      if (system_dir != NULL)\n        setup_value = (gsize) system_dir;\n      else\n        setup_value = (gsize) FLATPAK_SYSTEMDIR;\n      g_once_init_leave (&path, setup_value);\n    }\n\n  return g_file_new_for_path ((char *) path);\n}\n\nstatic FlatpakDirStorageType\nparse_storage_type (const char *type_string)\n{\n  if (type_string != NULL)\n    {\n      g_autofree char *type_low = NULL;\n\n      type_low = g_ascii_strdown (type_string, -1);\n      if (g_strcmp0 (type_low, \"network\") == 0)\n        return FLATPAK_DIR_STORAGE_TYPE_NETWORK;\n\n      if (g_strcmp0 (type_low, \"mmc\") == 0)\n        return FLATPAK_DIR_STORAGE_TYPE_MMC;\n\n      if (g_strcmp0 (type_low, \"sdcard\") == 0)\n        return FLATPAK_DIR_STORAGE_TYPE_SDCARD;\n\n      if (g_strcmp0 (type_low, \"hardisk\") == 0)\n        return FLATPAK_DIR_STORAGE_TYPE_HARD_DISK;\n    }\n\n  return FLATPAK_DIR_STORAGE_TYPE_DEFAULT;\n}\n\nstatic gboolean\nhas_system_location (GPtrArray  *locations,\n                     const char *id)\n{\n  int i;\n\n  for (i = 0; i < locations->len; i++)\n    {\n      GFile *path = g_ptr_array_index (locations, i);\n      DirExtraData *extra_data = g_object_get_data (G_OBJECT (path), \"extra-data\");\n      if (extra_data != NULL && g_strcmp0 (extra_data->id, id) == 0)\n        return TRUE;\n    }\n\n  return FALSE;\n}\n\nstatic void\nappend_new_system_location (GPtrArray            *locations,\n                            GFile                *location,\n                            const char           *id,\n                            const char           *display_name,\n                            FlatpakDirStorageType storage_type,\n                            gint                  priority)\n{\n  DirExtraData *extra_data = NULL;\n\n  extra_data = dir_extra_data_new (id, display_name, priority, storage_type);\n  g_object_set_data_full (G_OBJECT (location), \"extra-data\", extra_data,\n                          (GDestroyNotify) dir_extra_data_free);\n\n  g_ptr_array_add (locations, location);\n}\n\nstatic gboolean\nis_good_installation_id (const char *id)\n{\n  if (strcmp (id, \"\") == 0 ||\n      strcmp (id, \"user\") == 0 ||\n      strcmp (id, SYSTEM_DIR_DEFAULT_ID) == 0 ||\n      strcmp (id, \"system\") == 0)\n    return FALSE;\n\n  if (!g_str_is_ascii (id) ||\n      strpbrk (id, \" /\\n\"))\n    return FALSE;\n\n  if (strlen (id) > 80)\n    return FALSE;\n\n  return TRUE;\n}\n\nstatic gboolean\nappend_locations_from_config_file (GPtrArray    *locations,\n                                   const char   *file_path,\n                                   GCancellable *cancellable,\n                                   GError      **error)\n{\n  g_autoptr(GKeyFile) keyfile = NULL;\n  g_auto(GStrv) groups = NULL;\n  g_autoptr(GError) my_error = NULL;\n  gboolean ret = FALSE;\n  gsize n_groups;\n  int i;\n\n  keyfile = g_key_file_new ();\n\n  if (!g_key_file_load_from_file (keyfile, file_path, G_KEY_FILE_NONE, &my_error))\n    {\n      g_debug (\"Could not get list of system installations from '%s': %s\", file_path, my_error->message);\n      g_propagate_error (error, g_steal_pointer (&my_error));\n      goto out;\n    }\n\n  /* One configuration file might define more than one installation */\n  groups = g_key_file_get_groups (keyfile, &n_groups);\n  for (i = 0; i < n_groups; i++)\n    {\n      g_autofree char *id = NULL;\n      g_autofree char *path = NULL;\n      size_t len;\n\n      if (!g_str_has_prefix (groups[i], \"Installation \\\"\"))\n        {\n          if (g_str_has_prefix (groups[i], \"Installation \"))\n            g_warning (\"Installation without quotes (%s). Ignoring\", groups[i]);\n          continue;\n        }\n\n      id = g_strdup (&groups[i][14]);\n      if (!g_str_has_suffix (id, \"\\\"\"))\n        {\n          g_warning (\"While reading '%s': Installation without closing quote (%s). Ignoring\", file_path, groups[i]);\n          continue;\n        }\n\n      len = strlen (id);\n      if (len > 0)\n        id[len - 1] = '\\0';\n\n      if (!is_good_installation_id (id))\n        {\n          g_warning (\"While reading '%s': Bad installation ID '%s'. Ignoring\", file_path, id);\n          continue;\n        }\n\n      if (has_system_location (locations, id))\n        {\n          g_warning (\"While reading '%s': Duplicate installation ID '%s'. Ignoring\", file_path, id);\n          continue;\n        }\n\n      path = g_key_file_get_string (keyfile, groups[i], \"Path\", &my_error);\n      if (path == NULL)\n        {\n          g_debug (\"While reading '%s': Unable to get path for installation '%s': %s\", file_path, id, my_error->message);\n          g_propagate_error (error, g_steal_pointer (&my_error));\n          goto out;\n        }\n      else\n        {\n          GFile *location = NULL;\n          g_autofree char *display_name = NULL;\n          g_autofree char *priority = NULL;\n          g_autofree char *storage_type = NULL;\n          gint priority_val = 0;\n\n          display_name = g_key_file_get_string (keyfile, groups[i], \"DisplayName\", NULL);\n          priority = g_key_file_get_string (keyfile, groups[i], \"Priority\", NULL);\n          storage_type = g_key_file_get_string (keyfile, groups[i], \"StorageType\", NULL);\n\n          if (priority != NULL)\n            priority_val = g_ascii_strtoll (priority, NULL, 10);\n\n          location = g_file_new_for_path (path);\n          append_new_system_location (locations, location, id, display_name,\n                                      parse_storage_type (storage_type),\n                                      priority_val);\n        }\n    }\n\n  ret = TRUE;\n\nout:\n  return ret;\n}\n\nstatic gint\nsystem_locations_compare_func (gconstpointer location_a, gconstpointer location_b)\n{\n  const GFile *location_object_a = *(const GFile **) location_a;\n  const GFile *location_object_b = *(const GFile **) location_b;\n  DirExtraData *extra_data_a = NULL;\n  DirExtraData *extra_data_b = NULL;\n  gint prio_a = 0;\n  gint prio_b = 0;\n\n  extra_data_a = g_object_get_data (G_OBJECT (location_object_a), \"extra-data\");\n  prio_a = (extra_data_a != NULL) ? extra_data_a->priority : 0;\n\n  extra_data_b = g_object_get_data (G_OBJECT (location_object_b), \"extra-data\");\n  prio_b = (extra_data_b != NULL) ? extra_data_b->priority : 0;\n\n  return prio_b - prio_a;\n}\n\nstatic GPtrArray *\nsystem_locations_from_configuration (GCancellable *cancellable,\n                                     GError      **error)\n{\n  g_autoptr(GPtrArray) locations = NULL;\n  g_autoptr(GFile) conf_dir = NULL;\n  g_autoptr(GFileEnumerator) dir_enum = NULL;\n  g_autoptr(GError) my_error = NULL;\n  g_autofree char *config_dir = NULL;\n\n  locations = g_ptr_array_new_with_free_func (g_object_unref);\n  config_dir = g_strdup_printf (\"%s/%s\",\n                                get_config_dir_location (),\n                                SYSCONF_INSTALLATIONS_DIR);\n\n  if (!g_file_test (config_dir, G_FILE_TEST_IS_DIR))\n    {\n      g_debug (\"No installations directory in %s. Skipping\", config_dir);\n      goto out;\n    }\n\n  conf_dir = g_file_new_for_path (config_dir);\n  dir_enum = g_file_enumerate_children (conf_dir,\n                                        G_FILE_ATTRIBUTE_STANDARD_NAME \",\" G_FILE_ATTRIBUTE_STANDARD_TYPE,\n                                        G_FILE_QUERY_INFO_NONE,\n                                        cancellable, &my_error);\n  if (my_error != NULL)\n    {\n      g_debug (\"Unexpected error retrieving extra installations in %s: %s\",\n               config_dir, my_error->message);\n      g_propagate_error (error, g_steal_pointer (&my_error));\n      goto out;\n    }\n\n  while (TRUE)\n    {\n      GFileInfo *file_info;\n      GFile *path;\n      const char *name;\n      guint32 type;\n\n      if (!g_file_enumerator_iterate (dir_enum, &file_info, &path,\n                                      cancellable, &my_error))\n        {\n          g_debug (\"Unexpected error reading file in %s: %s\",\n                   config_dir, my_error->message);\n          g_propagate_error (error, g_steal_pointer (&my_error));\n          goto out;\n        }\n\n      if (file_info == NULL)\n        break;\n\n      name = g_file_info_get_attribute_byte_string (file_info, \"standard::name\");\n      type = g_file_info_get_attribute_uint32 (file_info, \"standard::type\");\n\n      if (type == G_FILE_TYPE_REGULAR && g_str_has_suffix (name, SYSCONF_INSTALLATIONS_FILE_EXT))\n        {\n          g_autofree char *path_str = g_file_get_path (path);\n          if (!append_locations_from_config_file (locations, path_str, cancellable, error))\n            goto out;\n        }\n    }\n\nout:\n  return g_steal_pointer (&locations);\n}\n\nstatic GPtrArray *\nget_system_locations (GCancellable *cancellable,\n                      GError      **error)\n{\n  g_autoptr(GPtrArray) locations = NULL;\n\n  /* This will always return a GPtrArray, being an empty one\n   * if no additional system installations have been configured.\n   */\n  locations = system_locations_from_configuration (cancellable, error);\n\n  /* Only fill the details of the default directory if not overridden. */\n  if (!has_system_location (locations, SYSTEM_DIR_DEFAULT_ID))\n    {\n      append_new_system_location (locations,\n                                  flatpak_get_system_default_base_dir_location (),\n                                  SYSTEM_DIR_DEFAULT_ID,\n                                  SYSTEM_DIR_DEFAULT_DISPLAY_NAME,\n                                  SYSTEM_DIR_DEFAULT_STORAGE_TYPE,\n                                  SYSTEM_DIR_DEFAULT_PRIORITY);\n    }\n\n  /* Store the list of system locations sorted according to priorities */\n  g_ptr_array_sort (locations, system_locations_compare_func);\n\n  return g_steal_pointer (&locations);\n}\n\nGPtrArray *\nflatpak_get_system_base_dir_locations (GCancellable *cancellable,\n                                       GError      **error)\n{\n  static gsize array = 0;\n\n  if (g_once_init_enter (&array))\n    {\n      gsize setup_value = 0;\n      setup_value = (gsize) get_system_locations (cancellable, error);\n      g_once_init_leave (&array, setup_value);\n    }\n\n  return (GPtrArray *) array;\n}\n\nGFile *\nflatpak_get_user_base_dir_location (void)\n{\n  static gsize file = 0;\n\n  if (g_once_init_enter (&file))\n    {\n      gsize setup_value = 0;\n      const char *path;\n      g_autofree char *free_me = NULL;\n      const char *user_dir = g_getenv (\"FLATPAK_USER_DIR\");\n      if (user_dir != NULL && *user_dir != 0)\n        path = user_dir;\n      else\n        path = free_me = g_build_filename (g_get_user_data_dir (), \"flatpak\", NULL);\n\n      setup_value = (gsize) g_file_new_for_path (path);\n\n      g_once_init_leave (&file, setup_value);\n    }\n\n  return g_object_ref ((GFile *) file);\n}\n\nstatic gboolean\nvalidate_commit_metadata (GVariant   *commit_data,\n                          const char *ref,\n                          const char *required_metadata,\n                          gboolean   require_xa_metadata,\n                          GError   **error)\n{\n  g_autoptr(GVariant) commit_metadata = NULL;\n  const char *xa_metadata = NULL;\n\n  commit_metadata = g_variant_get_child_value (commit_data, 0);\n\n  if (commit_metadata != NULL)\n    g_variant_lookup (commit_metadata, \"xa.metadata\", \"&s\", &xa_metadata);\n\n  if ((xa_metadata == NULL && require_xa_metadata) ||\n      (xa_metadata != NULL && g_strcmp0 (required_metadata, xa_metadata) != 0))\n    {\n      g_set_error (error, G_IO_ERROR, G_IO_ERROR_PERMISSION_DENIED,\n                   _(\"Commit metadata for %s not matching expected metadata\"), ref);\n      return FALSE;\n    }\n\n  return TRUE;\n}\n\n/* This is a cache directory similar to ~/.cache/flatpak/system-cache,\n * but in /var/tmp. This is useful for things like the system child\n * repos, because it is more likely to be on the same filesystem as\n * the system repo (thus increasing chances for e.g. reflink copying),\n * and avoids filling the users homedirectory with temporary data.\n *\n * In order to re-use this between instances we create a symlink\n * in /run to it and verify it before use.\n */\nstatic GFile *\nflatpak_ensure_system_user_cache_dir_location (GError **error)\n{\n  g_autofree char *path = NULL;\n  g_autofree char *symlink_path = NULL;\n  struct stat st_buf;\n  const char *custom_path = g_getenv (\"FLATPAK_SYSTEM_CACHE_DIR\");\n\n  if (custom_path != NULL && *custom_path != 0)\n    {\n      if (g_mkdir_with_parents (custom_path, 0755) != 0)\n        {\n          glnx_set_error_from_errno (error);\n          return NULL;\n        }\n\n      return g_file_new_for_path (custom_path);\n    }\n\n  symlink_path = g_build_filename (g_get_user_runtime_dir (), \".flatpak-cache\", NULL);\n  path = flatpak_readlink (symlink_path, NULL);\n\n  if (stat (path, &st_buf) == 0 &&\n      /* Must be owned by us */\n      st_buf.st_uid == getuid () &&\n      /* and not writeable by others, but readable */\n      (st_buf.st_mode & 0777) == 0755)\n    return g_file_new_for_path (path);\n\n  path = g_strdup (\"/var/tmp/flatpak-cache-XXXXXX\");\n\n  if (g_mkdtemp_full (path, 0755) == NULL)\n    {\n      flatpak_fail (error, \"Can't create temporary directory\");\n      return NULL;\n    }\n\n  unlink (symlink_path);\n  if (symlink (path, symlink_path) != 0)\n    {\n      glnx_set_error_from_errno (error);\n      return NULL;\n    }\n\n  return g_file_new_for_path (path);\n}\n\nstatic GFile *\nflatpak_get_user_cache_dir_location (void)\n{\n  g_autoptr(GFile) base_dir = g_file_new_for_path (g_get_user_cache_dir ());\n\n  return g_file_resolve_relative_path (base_dir, \"flatpak/system-cache\");\n}\n\nstatic GFile *\nflatpak_ensure_user_cache_dir_location (GError **error)\n{\n  g_autoptr(GFile) cache_dir = NULL;\n  g_autofree char *cache_path = NULL;\n\n  cache_dir = flatpak_get_user_cache_dir_location ();\n  cache_path = g_file_get_path (cache_dir);\n\n  if (g_mkdir_with_parents (cache_path, 0755) != 0)\n    {\n      glnx_set_error_from_errno (error);\n      return NULL;\n    }\n\n  return g_steal_pointer (&cache_dir);\n}\n\nstatic GFile *\nflatpak_dir_get_oci_cache_file (FlatpakDir *self,\n                                const char *remote,\n                                const char *suffix,\n                                GError    **error)\n{\n  g_autoptr(GFile) oci_dir = NULL;\n  g_autofree char *filename = NULL;\n\n  oci_dir = g_file_get_child (flatpak_dir_get_path (self), \"oci\");\n  if (g_mkdir_with_parents (flatpak_file_get_path_cached (oci_dir), 0755) != 0)\n    {\n      glnx_set_error_from_errno (error);\n      return NULL;\n    }\n\n  filename = g_strconcat (remote, suffix, NULL);\n  return g_file_get_child (oci_dir, filename);\n}\n\nstatic GFile *\nflatpak_dir_get_oci_index_location (FlatpakDir *self,\n                                    const char *remote,\n                                    GError    **error)\n{\n  return flatpak_dir_get_oci_cache_file (self, remote, \".index.gz\", error);\n}\n\nstatic GFile *\nflatpak_dir_get_oci_summary_location (FlatpakDir *self,\n                                      const char *remote,\n                                      GError    **error)\n{\n  return flatpak_dir_get_oci_cache_file (self, remote, \".summary\", error);\n}\n\nstatic gboolean\nflatpak_dir_remove_oci_file (FlatpakDir   *self,\n                             const char   *remote,\n                             const char   *suffix,\n                             GCancellable *cancellable,\n                             GError      **error)\n{\n  g_autoptr(GFile) file = flatpak_dir_get_oci_cache_file (self, remote, suffix, error);\n  g_autoptr(GError) local_error = NULL;\n\n  if (file == NULL)\n    return FALSE;\n\n  if (!g_file_delete (file, cancellable, &local_error) &&\n      !g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND))\n    {\n      g_propagate_error (error, g_steal_pointer (&local_error));\n      return FALSE;\n    }\n\n  return TRUE;\n}\n\nstatic gboolean\nflatpak_dir_remove_oci_files (FlatpakDir   *self,\n                              const char   *remote,\n                              GCancellable *cancellable,\n                              GError      **error)\n{\n  if (!flatpak_dir_remove_oci_file (self, remote, \".index.gz\", cancellable, error) ||\n      !flatpak_dir_remove_oci_file (self, remote, \".summary\", cancellable, error))\n    return FALSE;\n\n  return TRUE;\n}\n\nstatic gchar *\nflatpak_dir_revokefs_fuse_create_mountpoint (FlatpakDecomposed *ref,\n                                             GError           **error)\n{\n  g_autoptr(GFile) cache_dir = NULL;\n  g_autofree gchar *cache_dir_path = NULL;\n  g_autofree gchar *mnt_dir = NULL;\n  g_autofree gchar *id = NULL;\n  g_autofree gchar *mountpoint = NULL;\n\n  cache_dir = flatpak_ensure_system_user_cache_dir_location (error);\n  if (cache_dir == NULL)\n    return NULL;\n\n  id = flatpak_decomposed_dup_id (ref);\n  cache_dir_path = g_file_get_path (cache_dir);\n  mnt_dir = g_strdup_printf (\"%s-XXXXXX\", id);\n  mountpoint = g_mkdtemp_full (g_build_filename (cache_dir_path, mnt_dir, NULL), 0755);\n  if (mountpoint == NULL)\n    {\n      glnx_set_error_from_errno (error);\n      return NULL;\n    }\n\n  return g_steal_pointer (&mountpoint);\n}\n\nstatic gboolean\nflatpak_dir_revokefs_fuse_unmount (OstreeRepo **repo,\n                                  GLnxLockFile *lockfile,\n                                  const gchar *mnt_dir,\n                                  GError **error)\n{\n  g_autoptr(GSubprocess) fusermount = NULL;\n\n  /* Clear references to child_repo as not to leave any open fds. This is needed for\n   * a clean umount operation.\n   */\n  g_clear_pointer (repo, g_object_unref);\n  glnx_release_lock_file (lockfile);\n\n  fusermount = g_subprocess_new (G_SUBPROCESS_FLAGS_NONE,\n                                 error,\n                                 \"fusermount\", \"-u\", \"-z\", mnt_dir,\n                                 NULL);\n  if (g_subprocess_wait_check (fusermount, NULL, error))\n    {\n      g_autoptr(GFile) mnt_dir_file = g_file_new_for_path (mnt_dir);\n      g_autoptr(GError) tmp_error = NULL;\n\n      if (!flatpak_rm_rf (mnt_dir_file, NULL, &tmp_error))\n        g_warning (\"Unable to remove mountpoint directory %s: %s\", mnt_dir, tmp_error->message);\n\n      return TRUE;\n    }\n\n  return FALSE;\n}\n\nstatic gboolean\nflatpak_dir_use_system_helper (FlatpakDir *self,\n                               const char *installing_from_remote)\n{\n#ifdef USE_SYSTEM_HELPER\n  if (self->no_system_helper || self->user || getuid () == 0)\n    return FALSE;\n\n  /* OCI doesn't do signatures atm, so we can't use the system helper for this */\n  if (installing_from_remote != NULL && flatpak_dir_get_remote_oci (self, installing_from_remote))\n    return FALSE;\n\n  return TRUE;\n#else\n  return FALSE;\n#endif\n}\n\nstatic GVariant *\nflatpak_dir_system_helper_call (FlatpakDir         *self,\n                                const gchar        *method_name,\n                                GVariant           *parameters,\n                                const GVariantType *reply_type,\n                                GUnixFDList       **out_fd_list,\n                                GCancellable       *cancellable,\n                                GError            **error)\n{\n  GVariant *res;\n\n  if (g_once_init_enter (&self->system_helper_bus))\n    {\n      const char *on_session = g_getenv (\"FLATPAK_SYSTEM_HELPER_ON_SESSION\");\n      GDBusConnection *system_helper_bus =\n        g_bus_get_sync (on_session != NULL ? G_BUS_TYPE_SESSION : G_BUS_TYPE_SYSTEM,\n                        cancellable, NULL);\n\n      /* To ensure reverse mapping */\n      flatpak_error_quark ();\n\n      g_once_init_leave (&self->system_helper_bus, system_helper_bus ? system_helper_bus : (gpointer) 1 );\n    }\n\n  if (self->system_helper_bus == (gpointer) 1)\n    {\n      flatpak_fail (error, _(\"Unable to connect to system bus\"));\n      return NULL;\n    }\n\n  g_debug (\"Calling system helper: %s\", method_name);\n  res = g_dbus_connection_call_with_unix_fd_list_sync (self->system_helper_bus,\n                                                       \"org.freedesktop.Flatpak.SystemHelper\",\n                                                       \"/org/freedesktop/Flatpak/SystemHelper\",\n                                                       \"org.freedesktop.Flatpak.SystemHelper\",\n                                                       method_name,\n                                                       parameters,\n                                                       reply_type,\n                                                       G_DBUS_CALL_FLAGS_NONE, G_MAXINT,\n                                                       NULL, out_fd_list,\n                                                       cancellable,\n                                                       error);\n\n if (res == NULL && error)\n    g_dbus_error_strip_remote_error (*error);\n\n  return res;\n}\n\nstatic gboolean\nflatpak_dir_system_helper_call_deploy (FlatpakDir         *self,\n                                       const gchar        *arg_repo_path,\n                                       guint               arg_flags,\n                                       const gchar        *arg_ref,\n                                       const gchar        *arg_origin,\n                                       const gchar *const *arg_subpaths,\n                                       const gchar *const *arg_previous_ids,\n                                       const gchar        *arg_installation,\n                                       GCancellable       *cancellable,\n                                       GError            **error)\n{\n  const char *empty[] = { NULL };\n\n  if (arg_subpaths == NULL)\n    arg_subpaths = empty;\n  if (arg_previous_ids == NULL)\n    arg_previous_ids = empty;\n\n  if (flatpak_dir_get_no_interaction (self))\n    arg_flags |= FLATPAK_HELPER_DEPLOY_FLAGS_NO_INTERACTION;\n\n  g_autoptr(GVariant) ret =\n    flatpak_dir_system_helper_call (self, \"Deploy\",\n                                    g_variant_new (\"(^ayuss^as^ass)\",\n                                                   arg_repo_path,\n                                                   arg_flags,\n                                                   arg_ref,\n                                                   arg_origin,\n                                                   arg_subpaths,\n                                                   arg_previous_ids,\n                                                   arg_installation),\n                                    G_VARIANT_TYPE (\"()\"), NULL,\n                                    cancellable, error);\n  return ret != NULL;\n}\n\nstatic gboolean\nflatpak_dir_system_helper_call_deploy_appstream (FlatpakDir   *self,\n                                                 const gchar  *arg_repo_path,\n                                                 guint         arg_flags,\n                                                 const gchar  *arg_origin,\n                                                 const gchar  *arg_arch,\n                                                 const gchar  *arg_installation,\n                                                 GCancellable *cancellable,\n                                                 GError      **error)\n{\n  if (flatpak_dir_get_no_interaction (self))\n    arg_flags |= FLATPAK_HELPER_DEPLOY_APPSTREAM_FLAGS_NO_INTERACTION;\n\n  g_autoptr(GVariant) ret =\n    flatpak_dir_system_helper_call (self, \"DeployAppstream\",\n                                    g_variant_new (\"(^ayusss)\",\n                                                   arg_repo_path,\n                                                   arg_flags,\n                                                   arg_origin,\n                                                   arg_arch,\n                                                   arg_installation),\n                                    G_VARIANT_TYPE (\"()\"), NULL,\n                                    cancellable, error);\n  return ret != NULL;\n}\n\nstatic gboolean\nflatpak_dir_system_helper_call_uninstall (FlatpakDir   *self,\n                                          guint         arg_flags,\n                                          const gchar  *arg_ref,\n                                          const gchar  *arg_installation,\n                                          GCancellable *cancellable,\n                                          GError      **error)\n{\n  if (flatpak_dir_get_no_interaction (self))\n    arg_flags |= FLATPAK_HELPER_UNINSTALL_FLAGS_NO_INTERACTION;\n\n  g_autoptr(GVariant) ret =\n    flatpak_dir_system_helper_call (self, \"Uninstall\",\n                                    g_variant_new (\"(uss)\",\n                                                   arg_flags,\n                                                   arg_ref,\n                                                   arg_installation),\n                                    G_VARIANT_TYPE (\"()\"), NULL,\n                                    cancellable, error);\n  return ret != NULL;\n}\n\nstatic gboolean\nflatpak_dir_system_helper_call_install_bundle (FlatpakDir   *self,\n                                               const gchar  *arg_bundle_path,\n                                               guint         arg_flags,\n                                               const gchar  *arg_remote,\n                                               const gchar  *arg_installation,\n                                               gchar       **out_ref,\n                                               GCancellable *cancellable,\n                                               GError      **error)\n{\n  if (flatpak_dir_get_no_interaction (self))\n    arg_flags |= FLATPAK_HELPER_INSTALL_BUNDLE_FLAGS_NO_INTERACTION;\n\n  g_autoptr(GVariant) ret =\n    flatpak_dir_system_helper_call (self, \"InstallBundle\",\n                                    g_variant_new (\"(^ayuss)\",\n                                                   arg_bundle_path,\n                                                   arg_flags,\n                                                   arg_remote,\n                                                   arg_installation),\n                                    G_VARIANT_TYPE (\"(s)\"), NULL,\n                                    cancellable, error);\n  if (ret == NULL)\n    return FALSE;\n\n  g_variant_get (ret, \"(s)\", out_ref);\n  return TRUE;\n}\n\nstatic gboolean\nflatpak_dir_system_helper_call_configure_remote (FlatpakDir   *self,\n                                                 guint         arg_flags,\n                                                 const gchar  *arg_remote,\n                                                 const gchar  *arg_config,\n                                                 GVariant     *arg_gpg_key,\n                                                 const gchar  *arg_installation,\n                                                 GCancellable *cancellable,\n                                                 GError      **error)\n{\n  if (flatpak_dir_get_no_interaction (self))\n    arg_flags |= FLATPAK_HELPER_CONFIGURE_REMOTE_FLAGS_NO_INTERACTION;\n\n  g_autoptr(GVariant) ret =\n    flatpak_dir_system_helper_call (self, \"ConfigureRemote\",\n                                    g_variant_new (\"(uss@ays)\",\n                                                   arg_flags,\n                                                   arg_remote,\n                                                   arg_config,\n                                                   arg_gpg_key,\n                                                   arg_installation),\n                                    G_VARIANT_TYPE (\"()\"), NULL,\n                                    cancellable,\n                                    error);\n  return ret != NULL;\n}\n\nstatic gboolean\nflatpak_dir_system_helper_call_configure (FlatpakDir   *self,\n                                          guint         arg_flags,\n                                          const gchar  *arg_key,\n                                          const gchar  *arg_value,\n                                          const gchar  *arg_installation,\n                                          GCancellable *cancellable,\n                                          GError      **error)\n{\n  if (flatpak_dir_get_no_interaction (self))\n    arg_flags |= FLATPAK_HELPER_CONFIGURE_FLAGS_NO_INTERACTION;\n\n  g_autoptr(GVariant) ret =\n    flatpak_dir_system_helper_call (self, \"Configure\",\n                                    g_variant_new (\"(usss)\",\n                                                   arg_flags,\n                                                   arg_key,\n                                                   arg_value,\n                                                   arg_installation),\n                                    G_VARIANT_TYPE (\"()\"), NULL,\n                                    cancellable, error);\n  return ret != NULL;\n}\n\nstatic gboolean\nflatpak_dir_system_helper_call_update_remote (FlatpakDir   *self,\n                                              guint         arg_flags,\n                                              const gchar  *arg_remote,\n                                              const gchar  *arg_installation,\n                                              const gchar  *arg_summary_path,\n                                              const gchar  *arg_summary_sig_path,\n                                              GCancellable *cancellable,\n                                              GError      **error)\n{\n  if (flatpak_dir_get_no_interaction (self))\n    arg_flags |= FLATPAK_HELPER_UPDATE_REMOTE_FLAGS_NO_INTERACTION;\n\n  g_autoptr(GVariant) ret =\n    flatpak_dir_system_helper_call (self, \"UpdateRemote\",\n                                    g_variant_new (\"(uss^ay^ay)\",\n                                                   arg_flags,\n                                                   arg_remote,\n                                                   arg_installation,\n                                                   arg_summary_path,\n                                                   arg_summary_sig_path),\n                                    G_VARIANT_TYPE (\"()\"), NULL,\n                                    cancellable, error);\n  return ret != NULL;\n}\n\nstatic gboolean\nflatpak_dir_system_helper_call_remove_local_ref (FlatpakDir   *self,\n                                                 guint         arg_flags,\n                                                 const gchar  *arg_remote,\n                                                 const gchar  *arg_ref,\n                                                 const gchar  *arg_installation,\n                                                 GCancellable *cancellable,\n                                                 GError      **error)\n{\n  if (flatpak_dir_get_no_interaction (self))\n    arg_flags |= FLATPAK_HELPER_REMOVE_LOCAL_REF_FLAGS_NO_INTERACTION;\n\n  g_autoptr(GVariant) ret =\n    flatpak_dir_system_helper_call (self, \"RemoveLocalRef\",\n                                    g_variant_new (\"(usss)\",\n                                                   arg_flags,\n                                                   arg_remote,\n                                                   arg_ref,\n                                                   arg_installation),\n                                    G_VARIANT_TYPE (\"()\"), NULL,\n                                    cancellable, error);\n  return ret != NULL;\n}\n\nstatic gboolean\nflatpak_dir_system_helper_call_prune_local_repo (FlatpakDir   *self,\n                                                 guint         arg_flags,\n                                                 const gchar  *arg_installation,\n                                                 GCancellable *cancellable,\n                                                 GError      **error)\n{\n  if (flatpak_dir_get_no_interaction (self))\n    arg_flags |= FLATPAK_HELPER_PRUNE_LOCAL_REPO_FLAGS_NO_INTERACTION;\n\n  g_autoptr(GVariant) ret =\n    flatpak_dir_system_helper_call (self, \"PruneLocalRepo\",\n                                    g_variant_new (\"(us)\",\n                                                   arg_flags,\n                                                   arg_installation),\n                                    G_VARIANT_TYPE (\"()\"), NULL,\n                                    cancellable, error);\n  return ret != NULL;\n}\n\nstatic gboolean\nflatpak_dir_system_helper_call_run_triggers (FlatpakDir   *self,\n                                             guint         arg_flags,\n                                             const gchar  *arg_installation,\n                                             GCancellable *cancellable,\n                                             GError      **error)\n{\n  if (flatpak_dir_get_no_interaction (self))\n    arg_flags |= FLATPAK_HELPER_RUN_TRIGGERS_FLAGS_NO_INTERACTION;\n\n  g_autoptr(GVariant) ret =\n    flatpak_dir_system_helper_call (self, \"RunTriggers\",\n                                    g_variant_new (\"(us)\",\n                                                   arg_flags,\n                                                   arg_installation),\n                                    G_VARIANT_TYPE (\"()\"), NULL,\n                                    cancellable, error);\n  return ret != NULL;\n}\n\nstatic gboolean\nflatpak_dir_system_helper_call_ensure_repo (FlatpakDir   *self,\n                                            guint         arg_flags,\n                                            const gchar  *arg_installation,\n                                            GCancellable *cancellable,\n                                            GError      **error)\n{\n  if (flatpak_dir_get_no_interaction (self))\n    arg_flags |= FLATPAK_HELPER_ENSURE_REPO_FLAGS_NO_INTERACTION;\n\n  g_autoptr(GVariant) ret =\n    flatpak_dir_system_helper_call (self, \"EnsureRepo\",\n                                    g_variant_new (\"(us)\",\n                                                   arg_flags,\n                                                   arg_installation),\n                                    G_VARIANT_TYPE (\"()\"), NULL,\n                                    cancellable, error);\n  return ret != NULL;\n}\n\nstatic gboolean\nflatpak_dir_system_helper_call_cancel_pull (FlatpakDir    *self,\n                                            guint          arg_flags,\n                                            const gchar   *arg_installation,\n                                            const gchar   *arg_src_dir,\n                                            GCancellable  *cancellable,\n                                            GError       **error)\n{\n  if (flatpak_dir_get_no_interaction (self))\n    arg_flags |= FLATPAK_HELPER_CANCEL_PULL_FLAGS_NO_INTERACTION;\n\n  g_debug (\"Calling system helper: CancelPull\");\n\n  g_autoptr(GVariant) ret =\n    flatpak_dir_system_helper_call (self, \"CancelPull\",\n                                    g_variant_new (\"(uss)\",\n                                                   arg_flags,\n                                                   arg_installation,\n                                                   arg_src_dir),\n                                    NULL, NULL,\n                                    cancellable, error);\n\n   return ret != NULL;\n}\n\nstatic gboolean\nflatpak_dir_system_helper_call_get_revokefs_fd (FlatpakDir   *self,\n                                                guint         arg_flags,\n                                                const gchar  *arg_installation,\n                                                gint         *out_socket,\n                                                gchar       **out_src_dir,\n                                                GCancellable *cancellable,\n                                                GError      **error)\n{\n  g_autoptr(GUnixFDList) out_fd_list = NULL;\n  gint fd = -1;\n  gint fd_index = -1;\n\n  if (flatpak_dir_get_no_interaction (self))\n    arg_flags |= FLATPAK_HELPER_GET_REVOKEFS_FD_FLAGS_NO_INTERACTION;\n\n  g_debug (\"Calling system helper: GetRevokefsFd\");\n\n  g_autoptr(GVariant) ret =\n    flatpak_dir_system_helper_call (self, \"GetRevokefsFd\",\n                                    g_variant_new (\"(us)\",\n                                                   arg_flags,\n                                                   arg_installation),\n                                    G_VARIANT_TYPE (\"(hs)\"),\n                                    &out_fd_list,\n                                    cancellable, error);\n\n  if (ret == NULL)\n    return FALSE;\n\n  g_variant_get (ret, \"(hs)\", &fd_index, out_src_dir);\n  fd  = g_unix_fd_list_get (out_fd_list, fd_index, error);\n  if (fd == -1)\n    return FALSE;\n\n  *out_socket = fd;\n\n  return TRUE;\n}\n\nstatic gboolean\nflatpak_dir_system_helper_call_update_summary (FlatpakDir   *self,\n                                               guint         arg_flags,\n                                               const gchar  *arg_installation,\n                                               GCancellable *cancellable,\n                                               GError      **error)\n{\n  if (flatpak_dir_get_no_interaction (self))\n    arg_flags |= FLATPAK_HELPER_UPDATE_SUMMARY_FLAGS_NO_INTERACTION;\n\n  g_autoptr(GVariant) ret =\n    flatpak_dir_system_helper_call (self, \"UpdateSummary\",\n                                    g_variant_new (\"(us)\",\n                                                   arg_flags,\n                                                   arg_installation),\n                                    G_VARIANT_TYPE (\"()\"), NULL,\n                                    cancellable, error);\n  return ret != NULL;\n}\n\nstatic gboolean\nflatpak_dir_system_helper_call_generate_oci_summary (FlatpakDir   *self,\n                                                     guint         arg_flags,\n                                                     const gchar  *arg_origin,\n                                                     const gchar  *arg_installation,\n                                                     GCancellable *cancellable,\n                                                     GError      **error)\n{\n  if (flatpak_dir_get_no_interaction (self))\n    arg_flags |= FLATPAK_HELPER_GENERATE_OCI_SUMMARY_FLAGS_NO_INTERACTION;\n\n  g_autoptr(GVariant) ret =\n    flatpak_dir_system_helper_call (self, \"GenerateOciSummary\",\n                                    g_variant_new (\"(uss)\",\n                                                   arg_flags,\n                                                   arg_origin,\n                                                   arg_installation),\n                                    G_VARIANT_TYPE (\"()\"), NULL,\n                                    cancellable, error);\n  return ret != NULL;\n}\n\nstatic void\nflatpak_dir_finalize (GObject *object)\n{\n  FlatpakDir *self = FLATPAK_DIR (object);\n\n  g_clear_object (&self->repo);\n  g_clear_object (&self->cache_dir);\n  g_clear_object (&self->basedir);\n  g_clear_pointer (&self->extra_data, dir_extra_data_free);\n\n  if (self->system_helper_bus != (gpointer) 1)\n    g_clear_object (&self->system_helper_bus);\n\n  g_clear_object (&self->soup_session);\n  g_clear_pointer (&self->summary_cache, g_hash_table_unref);\n  g_clear_pointer (&self->remote_filters, g_hash_table_unref);\n  g_clear_pointer (&self->masked, g_regex_unref);\n  g_clear_pointer (&self->pinned, g_regex_unref);\n\n  G_OBJECT_CLASS (flatpak_dir_parent_class)->finalize (object);\n}\n\nstatic void\nflatpak_dir_set_property (GObject      *object,\n                          guint         prop_id,\n                          const GValue *value,\n                          GParamSpec   *pspec)\n{\n  FlatpakDir *self = FLATPAK_DIR (object);\n\n  switch (prop_id)\n    {\n    case PROP_PATH:\n      /* Canonicalize */\n      self->basedir = g_file_new_for_path (flatpak_file_get_path_cached (g_value_get_object (value)));\n      break;\n\n    case PROP_USER:\n      self->user = g_value_get_boolean (value);\n      break;\n\n    default:\n      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);\n      break;\n    }\n}\n\nstatic void\nflatpak_dir_get_property (GObject    *object,\n                          guint       prop_id,\n                          GValue     *value,\n                          GParamSpec *pspec)\n{\n  FlatpakDir *self = FLATPAK_DIR (object);\n\n  switch (prop_id)\n    {\n    case PROP_PATH:\n      g_value_set_object (value, self->basedir);\n      break;\n\n    case PROP_USER:\n      g_value_set_boolean (value, self->user);\n      break;\n\n    default:\n      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);\n      break;\n    }\n}\n\nstatic void\nflatpak_dir_class_init (FlatpakDirClass *klass)\n{\n  GObjectClass *object_class = G_OBJECT_CLASS (klass);\n\n  object_class->get_property = flatpak_dir_get_property;\n  object_class->set_property = flatpak_dir_set_property;\n  object_class->finalize = flatpak_dir_finalize;\n\n  g_object_class_install_property (object_class,\n                                   PROP_USER,\n                                   g_param_spec_boolean (\"user\",\n                                                         \"\",\n                                                         \"\",\n                                                         FALSE,\n                                                         G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY));\n  g_object_class_install_property (object_class,\n                                   PROP_PATH,\n                                   g_param_spec_object (\"path\",\n                                                        \"\",\n                                                        \"\",\n                                                        G_TYPE_FILE,\n                                                        G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY));\n}\n\nstatic void\nflatpak_dir_init (FlatpakDir *self)\n{\n  /* Work around possible deadlock due to: https://bugzilla.gnome.org/show_bug.cgi?id=674885 */\n  g_type_ensure (G_TYPE_UNIX_SOCKET_ADDRESS);\n\n  /* Optional data that needs initialization */\n  self->extra_data = NULL;\n}\n\ngboolean\nflatpak_dir_is_user (FlatpakDir *self)\n{\n  return self->user;\n}\n\nvoid\nflatpak_dir_set_no_system_helper (FlatpakDir *self,\n                                  gboolean    no_system_helper)\n{\n  self->no_system_helper = no_system_helper;\n}\n\nvoid\nflatpak_dir_set_no_interaction (FlatpakDir *self,\n                                gboolean    no_interaction)\n{\n  self->no_interaction = no_interaction;\n}\n\ngboolean\nflatpak_dir_get_no_interaction (FlatpakDir *self)\n{\n  return self->no_interaction;\n}\n\nGFile *\nflatpak_dir_get_path (FlatpakDir *self)\n{\n  return self->basedir;\n}\n\nGFile *\nflatpak_dir_get_changed_path (FlatpakDir *self)\n{\n  return g_file_get_child (self->basedir, \".changed\");\n}\n\nconst char *\nflatpak_dir_get_id (FlatpakDir *self)\n{\n  if (self->user)\n    return \"user\";\n\n  if (self->extra_data != NULL)\n    return self->extra_data->id;\n\n  return NULL;\n}\n\nchar *\nflatpak_dir_get_name (FlatpakDir *self)\n{\n  const char *id = NULL;\n\n  if (self->user)\n    return g_strdup (\"user\");\n\n  id = flatpak_dir_get_id (self);\n  if (id != NULL && g_strcmp0 (id, SYSTEM_DIR_DEFAULT_ID) != 0)\n    return g_strdup_printf (\"system (%s)\", id);\n\n  return g_strdup (\"system\");\n}\n\nconst char *\nflatpak_dir_get_name_cached (FlatpakDir *self)\n{\n  char *name;\n\n  name = g_object_get_data (G_OBJECT (self), \"cached-name\");\n  if (!name)\n    {\n      name = flatpak_dir_get_name (self),\n      g_object_set_data_full (G_OBJECT (self), \"cached-name\", name, g_free);\n    }\n\n  return (const char *) name;\n}\n\nchar *\nflatpak_dir_get_display_name (FlatpakDir *self)\n{\n  if (self->user)\n    return g_strdup (_(\"User installation\"));\n\n  if (self->extra_data != NULL && g_strcmp0 (self->extra_data->id, SYSTEM_DIR_DEFAULT_ID) != 0)\n    {\n      if (self->extra_data->display_name)\n        return g_strdup (self->extra_data->display_name);\n\n      return g_strdup_printf (_(\"System (%s) installation\"), self->extra_data->id);\n    }\n\n  return g_strdup (SYSTEM_DIR_DEFAULT_DISPLAY_NAME);\n}\n\ngint\nflatpak_dir_get_priority (FlatpakDir *self)\n{\n  if (self->extra_data != NULL)\n    return self->extra_data->priority;\n\n  return 0;\n}\n\nFlatpakDirStorageType\nflatpak_dir_get_storage_type (FlatpakDir *self)\n{\n  if (self->extra_data != NULL)\n    return self->extra_data->storage_type;\n\n  return FLATPAK_DIR_STORAGE_TYPE_DEFAULT;\n}\n\nchar *\nflatpak_dir_load_override (FlatpakDir *self,\n                           const char *app_id,\n                           gsize      *length,\n                           GError    **error)\n{\n  g_autoptr(GFile) override_dir = NULL;\n  g_autoptr(GFile) file = NULL;\n  char *metadata_contents;\n\n  override_dir = g_file_get_child (self->basedir, \"overrides\");\n\n  if (app_id)\n    file = g_file_get_child (override_dir, app_id);\n  else\n    file = g_file_get_child (override_dir, \"global\");\n\n  if (!g_file_load_contents (file, NULL,\n                             &metadata_contents, length, NULL, NULL))\n    {\n      g_set_error (error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND,\n                   _(\"No overrides found for %s\"), app_id);\n      return NULL;\n    }\n\n  return metadata_contents;\n}\n\nGKeyFile *\nflatpak_load_override_keyfile (const char *app_id, gboolean user, GError **error)\n{\n  g_autofree char *metadata_contents = NULL;\n  gsize metadata_size;\n  g_autoptr(GKeyFile) metakey = g_key_file_new ();\n  g_autoptr(FlatpakDir) dir = NULL;\n\n  dir = user ? flatpak_dir_get_user () : flatpak_dir_get_system_default ();\n\n  metadata_contents = flatpak_dir_load_override (dir, app_id, &metadata_size, error);\n  if (metadata_contents == NULL)\n    return NULL;\n\n  if (!g_key_file_load_from_data (metakey,\n                                  metadata_contents,\n                                  metadata_size,\n                                  0, error))\n    return NULL;\n\n  return g_steal_pointer (&metakey);\n}\n\nFlatpakContext *\nflatpak_load_override_file (const char *app_id, gboolean user, GError **error)\n{\n  g_autoptr(FlatpakContext) overrides = flatpak_context_new ();\n  g_autoptr(GKeyFile) metakey = NULL;\n  g_autoptr(GError) my_error = NULL;\n\n  metakey = flatpak_load_override_keyfile (app_id, user, &my_error);\n  if (metakey == NULL)\n    {\n      if (!g_error_matches (my_error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND))\n        {\n          g_propagate_error (error, g_steal_pointer (&my_error));\n          return NULL;\n        }\n    }\n  else\n    {\n      if (!flatpak_context_load_metadata (overrides, metakey, error))\n        return NULL;\n    }\n\n  return g_steal_pointer (&overrides);\n}\n\ngboolean\nflatpak_save_override_keyfile (GKeyFile   *metakey,\n                               const char *app_id,\n                               gboolean    user,\n                               GError    **error)\n{\n  g_autoptr(GFile) base_dir = NULL;\n  g_autoptr(GFile) override_dir = NULL;\n  g_autoptr(GFile) file = NULL;\n  g_autofree char *filename = NULL;\n  g_autofree char *parent = NULL;\n\n  if (user)\n    base_dir = flatpak_get_user_base_dir_location ();\n  else\n    base_dir = flatpak_get_system_default_base_dir_location ();\n\n  override_dir = g_file_get_child (base_dir, \"overrides\");\n\n  if (app_id)\n    file = g_file_get_child (override_dir, app_id);\n  else\n    file = g_file_get_child (override_dir, \"global\");\n\n  filename = g_file_get_path (file);\n  parent = g_path_get_dirname (filename);\n  if (g_mkdir_with_parents (parent, 0755))\n    {\n      glnx_set_error_from_errno (error);\n      return FALSE;\n    }\n\n  return g_key_file_save_to_file (metakey, filename, error);\n}\n\ngboolean\nflatpak_remove_override_keyfile (const char *app_id,\n                                 gboolean    user,\n                                 GError    **error)\n{\n  g_autoptr(GFile) base_dir = NULL;\n  g_autoptr(GFile) override_dir = NULL;\n  g_autoptr(GFile) file = NULL;\n  g_autoptr(GError) local_error = NULL;\n\n  if (user)\n    base_dir = flatpak_get_user_base_dir_location ();\n  else\n    base_dir = flatpak_get_system_default_base_dir_location ();\n\n  override_dir = g_file_get_child (base_dir, \"overrides\");\n\n  if (app_id)\n    file = g_file_get_child (override_dir, app_id);\n  else\n    file = g_file_get_child (override_dir, \"global\");\n\n  if (!g_file_delete (file, NULL, &local_error) &&\n      !g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND))\n    {\n      g_propagate_error (error, g_steal_pointer (&local_error));\n      return FALSE;\n    }\n\n  return TRUE;\n}\n\n/* Note: passing a checksum only works here for non-sub-set deploys, not\n   e.g. a partial locale install, because it will not find the real\n   deploy directory. This is ok for now, because checksum is only\n   currently passed from flatpak_installation_launch() when launching\n   a particular version of an app, which is not used for locales. */\nFlatpakDeploy *\nflatpak_dir_load_deployed (FlatpakDir        *self,\n                           FlatpakDecomposed *ref,\n                           const char        *checksum,\n                           GCancellable      *cancellable,\n                           GError           **error)\n{\n  g_autoptr(GFile) deploy_dir = NULL;\n  g_autoptr(GKeyFile) metakey = NULL;\n  g_autoptr(GFile) metadata = NULL;\n  g_autofree char *metadata_contents = NULL;\n  FlatpakDeploy *deploy;\n  gsize metadata_size;\n\n  deploy_dir = flatpak_dir_get_if_deployed (self, ref, checksum, cancellable);\n  if (deploy_dir == NULL)\n    {\n      if (checksum == NULL)\n        g_set_error (error, FLATPAK_ERROR, FLATPAK_ERROR_NOT_INSTALLED,\n                     _(\"%s not installed\"), flatpak_decomposed_get_ref (ref));\n      else\n        g_set_error (error, FLATPAK_ERROR, FLATPAK_ERROR_NOT_INSTALLED,\n                     _(\"%s (commit %s) not installed\"), flatpak_decomposed_get_ref (ref), checksum);\n      return NULL;\n    }\n\n  if (!flatpak_dir_ensure_repo (self, cancellable, error))\n    return NULL;\n\n  metadata = g_file_get_child (deploy_dir, \"metadata\");\n  if (!g_file_load_contents (metadata, cancellable, &metadata_contents, &metadata_size, NULL, error))\n    return NULL;\n\n  metakey = g_key_file_new ();\n  if (!g_key_file_load_from_data (metakey, metadata_contents, metadata_size, 0, error))\n    return NULL;\n\n  deploy = flatpak_deploy_new (deploy_dir, ref, metakey, self->repo);\n\n  /* Only load system global overrides for system installed apps */\n  if (!self->user)\n    {\n      deploy->system_overrides = flatpak_load_override_file (NULL, FALSE, error);\n      if (deploy->system_overrides == NULL)\n        return NULL;\n    }\n\n  /* Always load user global overrides */\n  deploy->user_overrides = flatpak_load_override_file (NULL, TRUE, error);\n  if (deploy->user_overrides == NULL)\n    return NULL;\n\n  /* Only apps have app overrides */\n  if (flatpak_decomposed_is_app (ref))\n    {\n      g_autofree char *id = flatpak_decomposed_dup_id (ref);\n\n      /* Only load system overrides for system installed apps */\n      if (!self->user)\n        {\n          deploy->system_app_overrides = flatpak_load_override_file (id, FALSE, error);\n          if (deploy->system_app_overrides == NULL)\n            return NULL;\n        }\n\n      /* Always load user overrides */\n      deploy->user_app_overrides = flatpak_load_override_file (id, TRUE, error);\n      if (deploy->user_app_overrides == NULL)\n        return NULL;\n    }\n\n  return deploy;\n}\n\nGFile *\nflatpak_dir_get_deploy_dir (FlatpakDir *self,\n                            FlatpakDecomposed *ref)\n{\n  return g_file_resolve_relative_path (self->basedir, flatpak_decomposed_get_ref (ref));\n}\n\nchar *\nflatpak_dir_get_deploy_subdir (FlatpakDir          *self,\n                               const char          *checksum,\n                               const char * const * subpaths)\n{\n  if (subpaths == NULL || *subpaths == NULL)\n    return g_strdup (checksum);\n  else\n    {\n      GString *str = g_string_new (checksum);\n      int i;\n      for (i = 0; subpaths[i] != NULL; i++)\n        {\n          const char *s = subpaths[i];\n          g_string_append_c (str, '-');\n          while (*s)\n            {\n              if (*s != '/')\n                g_string_append_c (str, *s);\n              s++;\n            }\n        }\n      return g_string_free (str, FALSE);\n    }\n}\n\nGFile *\nflatpak_dir_get_unmaintained_extension_dir (FlatpakDir *self,\n                                            const char *name,\n                                            const char *arch,\n                                            const char *branch)\n{\n  g_autofree char *unmaintained_ref = NULL;\n\n  unmaintained_ref = g_build_filename (\"extension\", name, arch, branch, NULL);\n  return g_file_resolve_relative_path (self->basedir, unmaintained_ref);\n}\n\nGFile *\nflatpak_dir_get_exports_dir (FlatpakDir *self)\n{\n  return g_file_get_child (self->basedir, \"exports\");\n}\n\nGFile *\nflatpak_dir_get_removed_dir (FlatpakDir *self)\n{\n  return g_file_get_child (self->basedir, \".removed\");\n}\n\nGFile *\nflatpak_dir_get_sideload_repos_dir (FlatpakDir *self)\n{\n  return g_file_get_child (self->basedir, SIDELOAD_REPOS_DIR_NAME);\n}\n\nGFile *\nflatpak_dir_get_runtime_sideload_repos_dir (FlatpakDir *self)\n{\n  g_autoptr(GFile) base = g_file_new_for_path (get_run_dir_location ());\n  return g_file_get_child (base, SIDELOAD_REPOS_DIR_NAME);\n}\n\nOstreeRepo *\nflatpak_dir_get_repo (FlatpakDir *self)\n{\n  return self->repo;\n}\n\n\n/* This is an exclusive per flatpak installation file lock that is taken\n * whenever any config in the directory outside the repo is to be changed. For\n * instance deployments, overrides or active commit changes.\n *\n * For concurrency protection of the actual repository we rely on ostree\n * to do the right thing.\n */\ngboolean\nflatpak_dir_lock (FlatpakDir   *self,\n                  GLnxLockFile *lockfile,\n                  GCancellable *cancellable,\n                  GError      **error)\n{\n  g_autoptr(GFile) lock_file = g_file_get_child (flatpak_dir_get_path (self), \"lock\");\n  g_autofree char *lock_path = g_file_get_path (lock_file);\n\n  return glnx_make_lock_file (AT_FDCWD, lock_path, LOCK_EX, lockfile, error);\n}\n\n\n/* This is an lock that protects the repo itself. Any operation that\n * relies on objects not disappearing from the repo need to hold this\n * in a non-exclusive mode, while anything that can remove objects\n * (i.e. prune) need to take it in exclusive mode.\n *\n * The following operations depends on objects not disappearing:\n *  * pull into a staging directory (pre-existing objects are not downloaded)\n *  * moving a staging directory into the repo (no ref keeps the object alive during copy)\n *  * Deploying a ref (a parallel update + prune could cause objects to be removed)\n *\n * In practice this means we hold a shared lock during deploy and\n * pull, and an excusive lock during prune.\n */\ngboolean\nflatpak_dir_repo_lock (FlatpakDir   *self,\n                       GLnxLockFile *lockfile,\n                       int           operation,\n                       GCancellable *cancellable,\n                       GError      **error)\n{\n  g_autoptr(GFile) lock_file = g_file_get_child (flatpak_dir_get_path (self), \"repo-lock\");\n  g_autofree char *lock_path = g_file_get_path (lock_file);\n\n  return glnx_make_lock_file (AT_FDCWD, lock_path, operation, lockfile, error);\n}\n\nconst char *\nflatpak_deploy_data_get_origin (GBytes *deploy_data)\n{\n  VarDeployDataRef ref = var_deploy_data_from_bytes (deploy_data);\n  return var_deploy_data_get_origin (ref);\n}\n\nconst char *\nflatpak_deploy_data_get_commit (GBytes *deploy_data)\n{\n  VarDeployDataRef ref = var_deploy_data_from_bytes (deploy_data);\n  return var_deploy_data_get_commit (ref);\n}\n\ngint32\nflatpak_deploy_data_get_version (GBytes *deploy_data)\n{\n  VarDeployDataRef ref = var_deploy_data_from_bytes (deploy_data);\n  VarMetadataRef metadata = var_deploy_data_get_metadata (ref);\n\n  return var_metadata_lookup_int32 (metadata, \"deploy-version\", 0);\n}\n\n/* Note: This will return 0 if this is unset, which happens on deloy data updates, so ensure we handle that in all callers */\nguint64\nflatpak_deploy_data_get_timestamp (GBytes *deploy_data)\n{\n  VarDeployDataRef ref = var_deploy_data_from_bytes (deploy_data);\n  VarMetadataRef metadata = var_deploy_data_get_metadata (ref);\n\n  return var_metadata_lookup_uint64 (metadata, \"timestamp\", 0);\n}\n\nstatic const char *\nflatpak_deploy_data_get_string (GBytes *deploy_data, const char *key)\n{\n  VarDeployDataRef ref = var_deploy_data_from_bytes (deploy_data);\n  VarMetadataRef metadata = var_deploy_data_get_metadata (ref);\n\n  return var_metadata_lookup_string (metadata, key, NULL);\n}\n\nstatic const char *\nflatpak_deploy_data_get_localed_string (GBytes *deploy_data, const char *key)\n{\n  VarDeployDataRef ref = var_deploy_data_from_bytes (deploy_data);\n  VarMetadataRef metadata = var_deploy_data_get_metadata (ref);\n  const char * const * languages = g_get_language_names ();\n  int i;\n\n  for (i = 0; languages[i]; ++i)\n    {\n      g_autofree char *localed_key = NULL;\n      VarVariantRef value_v;\n\n      if (strcmp (languages[i], \"C\") == 0)\n        localed_key = g_strdup (key);\n      else\n        localed_key = g_strdup_printf (\"%s@%s\", key, languages[i]);\n\n      if (var_metadata_lookup (metadata, localed_key, NULL,  &value_v) &&\n          var_variant_is_type (value_v, G_VARIANT_TYPE_STRING))\n        return var_variant_get_string (value_v);\n    }\n\n  return NULL;\n}\n\nconst char *\nflatpak_deploy_data_get_alt_id (GBytes *deploy_data)\n{\n  return flatpak_deploy_data_get_string (deploy_data, \"alt-id\");\n}\n\nconst char *\nflatpak_deploy_data_get_eol (GBytes *deploy_data)\n{\n  return flatpak_deploy_data_get_string (deploy_data, \"eol\");\n}\n\nconst char *\nflatpak_deploy_data_get_eol_rebase (GBytes *deploy_data)\n{\n  return flatpak_deploy_data_get_string (deploy_data, \"eolr\");\n}\n\nconst char **\nflatpak_deploy_data_get_previous_ids (GBytes *deploy_data, gsize *length)\n{\n  VarDeployDataRef ref = var_deploy_data_from_bytes (deploy_data);\n  VarMetadataRef metadata = var_deploy_data_get_metadata (ref);\n  VarVariantRef previous_ids_v;\n\n  if (var_metadata_lookup (metadata, \"previous-ids\", NULL,  &previous_ids_v))\n    return var_arrayofstring_to_strv (var_arrayofstring_from_variant (previous_ids_v), length);\n\n  if (length != NULL)\n    *length = 0;\n\n  return NULL;\n}\n\nconst char *\nflatpak_deploy_data_get_runtime (GBytes *deploy_data)\n{\n  return flatpak_deploy_data_get_string (deploy_data, \"runtime\");\n}\n\nconst char *\nflatpak_deploy_data_get_extension_of (GBytes *deploy_data)\n{\n  return flatpak_deploy_data_get_string (deploy_data, \"extension-of\");\n}\n\nconst char *\nflatpak_deploy_data_get_appdata_name (GBytes *deploy_data)\n{\n  return flatpak_deploy_data_get_localed_string (deploy_data, \"appdata-name\");\n}\n\nconst char *\nflatpak_deploy_data_get_appdata_summary (GBytes *deploy_data)\n{\n  return flatpak_deploy_data_get_localed_string (deploy_data, \"appdata-summary\");\n}\n\nconst char *\nflatpak_deploy_data_get_appdata_version (GBytes *deploy_data)\n{\n  return flatpak_deploy_data_get_string (deploy_data, \"appdata-version\");\n}\n\nconst char *\nflatpak_deploy_data_get_appdata_license (GBytes *deploy_data)\n{\n  return flatpak_deploy_data_get_string (deploy_data, \"appdata-license\");\n}\n\nconst char *\nflatpak_deploy_data_get_appdata_content_rating_type (GBytes *deploy_data)\n{\n  VarDeployDataRef ref = var_deploy_data_from_bytes (deploy_data);\n  VarMetadataRef metadata = var_deploy_data_get_metadata (ref);\n  VarVariantRef rating_v;\n\n  if (var_metadata_lookup (metadata, \"appdata-content-rating\", NULL,  &rating_v))\n    {\n      VarContentRatingRef rating = var_content_rating_from_variant (rating_v);\n      return var_content_rating_get_rating_type (rating);\n    }\n\n  return NULL;\n}\n\nGHashTable *  /* (transfer container) (nullable) */\nflatpak_deploy_data_get_appdata_content_rating (GBytes *deploy_data)\n{\n  VarDeployDataRef ref = var_deploy_data_from_bytes (deploy_data);\n  VarMetadataRef metadata = var_deploy_data_get_metadata (ref);\n  VarVariantRef rating_v;\n  g_autoptr(GHashTable) content_rating = NULL;\n\n  if (var_metadata_lookup (metadata, \"appdata-content-rating\", NULL,  &rating_v))\n    {\n      VarContentRatingRef rating = var_content_rating_from_variant (rating_v);\n      VarRatingsRef ratings = var_content_rating_get_ratings (rating);\n      gsize len, i;\n\n      content_rating = g_hash_table_new_full (g_str_hash, g_str_equal, NULL, NULL);\n\n      len = var_ratings_get_length (ratings);\n      for (i = 0; i < len; i++)\n        {\n          VarRatingsEntryRef entry = var_ratings_get_at (ratings, i);\n\n          g_hash_table_insert (content_rating,\n                               (gpointer) g_intern_string (var_ratings_entry_get_key (entry)),\n                               (gpointer) g_intern_string (var_ratings_entry_get_value (entry)));\n        }\n    }\n\n  return g_steal_pointer (&content_rating);\n}\n\n/*<private>\n * flatpak_deploy_data_get_subpaths:\n *\n * Returns: (array zero-terminated=1) (transfer container): an array of constant strings\n **/\nconst char **\nflatpak_deploy_data_get_subpaths (GBytes *deploy_data)\n{\n  VarDeployDataRef ref = var_deploy_data_from_bytes (deploy_data);\n  return var_arrayofstring_to_strv (var_deploy_data_get_subpaths (ref), NULL);\n}\n\ngboolean\nflatpak_deploy_data_has_subpaths (GBytes *deploy_data)\n{\n  VarDeployDataRef ref = var_deploy_data_from_bytes (deploy_data);\n  VarArrayofstringRef subpaths = var_deploy_data_get_subpaths (ref);\n\n  return var_arrayofstring_get_length (subpaths) != 0;\n}\n\nguint64\nflatpak_deploy_data_get_installed_size (GBytes *deploy_data)\n{\n  VarDeployDataRef ref = var_deploy_data_from_bytes (deploy_data);\n  return var_deploy_data_get_installed_size (ref);\n}\n\nstatic char *\nread_appdata_xml_from_deploy_dir (GFile *deploy_dir, const char *id)\n{\n  g_autoptr(GFile) appdata_file = NULL;\n  g_autofree char *appdata_name = NULL;\n  g_autoptr(GFileInputStream) appdata_in = NULL;\n  gsize size;\n\n  appdata_name = g_strconcat (id, \".xml.gz\", NULL);\n  appdata_file  = flatpak_build_file (deploy_dir, \"files/share/app-info/xmls\", appdata_name, NULL);\n\n  appdata_in = g_file_read (appdata_file, NULL, NULL);\n  if (appdata_in)\n    {\n      g_autoptr(GZlibDecompressor) decompressor = g_zlib_decompressor_new (G_ZLIB_COMPRESSOR_FORMAT_GZIP);\n      g_autoptr(GInputStream) converter = g_converter_input_stream_new (G_INPUT_STREAM (appdata_in), G_CONVERTER (decompressor));\n      g_autoptr(GBytes) appdata_xml = NULL;\n\n      appdata_xml = flatpak_read_stream (converter, TRUE, NULL);\n      if (appdata_xml)\n        return g_bytes_unref_to_data (g_steal_pointer (&appdata_xml), &size);\n    }\n\n  return NULL;\n}\n\nstatic void\nadd_locale_metadata_string (GVariantDict *metadata_dict,\n                            const char   *keyname,\n                            GHashTable   *values)\n{\n  if (values == NULL)\n    return;\n\n  GLNX_HASH_TABLE_FOREACH_KV (values, const char *, locale, const char *, value)\n  {\n    const char *key;\n    g_autofree char *key_free = NULL;\n\n    if (strcmp (locale, \"C\") == 0)\n      key = keyname;\n    else\n      {\n        key_free = g_strdup_printf (\"%s@%s\", keyname, locale);\n        key = key_free;\n      }\n\n    g_variant_dict_insert_value (metadata_dict, key,\n                                 g_variant_new_string (value));\n  }\n}\n\n/* Convert @content_rating_type and @content_rating to a floating #GVariant of\n * type `(sa{ss})`. */\nstatic GVariant *\nappdata_content_rating_to_variant (const char *content_rating_type,\n                                   GHashTable *content_rating)\n{\n  g_autoptr(GVariantBuilder) builder = g_variant_builder_new (G_VARIANT_TYPE (\"(sa{ss})\"));\n  GHashTableIter iter;\n  gpointer key, value;\n\n  g_variant_builder_add (builder, \"s\", content_rating_type);\n  g_variant_builder_open (builder, G_VARIANT_TYPE (\"a{ss}\"));\n\n  g_hash_table_iter_init (&iter, content_rating);\n\n  while (g_hash_table_iter_next (&iter, &key, &value))\n    {\n      const char *id = key, *val = value;\n      g_variant_builder_add (builder, \"{ss}\", id, val);\n    }\n\n  g_variant_builder_close (builder);\n\n  return g_variant_builder_end (builder);\n}\n\nstatic void\nadd_appdata_to_deploy_data (GVariantDict *metadata_dict,\n                            GFile        *deploy_dir,\n                            const char   *id)\n{\n  g_autofree char *appdata_xml = NULL;\n  g_autoptr(GHashTable) names = NULL;\n  g_autoptr(GHashTable) comments = NULL;\n  g_autofree char *version = NULL;\n  g_autofree char *license = NULL;\n  g_autofree char *content_rating_type = NULL;\n  g_autoptr(GHashTable) content_rating = NULL;\n\n  appdata_xml = read_appdata_xml_from_deploy_dir (deploy_dir, id);\n  if (appdata_xml == NULL)\n    return;\n\n  if (flatpak_parse_appdata (appdata_xml, id, &names, &comments, &version, &license,\n                             &content_rating_type, &content_rating))\n    {\n      add_locale_metadata_string (metadata_dict, \"appdata-name\", names);\n      add_locale_metadata_string (metadata_dict, \"appdata-summary\", comments);\n      if (version)\n        g_variant_dict_insert_value (metadata_dict, \"appdata-version\",\n                                     g_variant_new_string (version));\n      if (license)\n        g_variant_dict_insert_value (metadata_dict, \"appdata-license\",\n                                     g_variant_new_string (license));\n      if (content_rating_type != NULL && content_rating != NULL)\n        g_variant_dict_insert_value (metadata_dict, \"appdata-content-rating\",\n                                     appdata_content_rating_to_variant (content_rating_type, content_rating));\n    }\n}\n\nstatic void\nadd_commit_metadata_to_deploy_data (GVariantDict *metadata_dict,\n                                    GVariant     *commit_metadata)\n{\n  const char *alt_id = NULL;\n  const char *eol = NULL;\n  const char *eol_rebase = NULL;\n\n  g_variant_lookup (commit_metadata, \"xa.alt-id\", \"&s\", &alt_id);\n  g_variant_lookup (commit_metadata, OSTREE_COMMIT_META_KEY_ENDOFLIFE, \"&s\", &eol);\n  g_variant_lookup (commit_metadata, OSTREE_COMMIT_META_KEY_ENDOFLIFE_REBASE, \"&s\", &eol_rebase);\n\n  if (alt_id)\n    g_variant_dict_insert_value (metadata_dict, \"alt-id\",\n                                 g_variant_new_string (alt_id));\n  if (eol)\n    g_variant_dict_insert_value (metadata_dict, \"eol\",\n                                 g_variant_new_string (eol));\n  if (eol_rebase)\n    g_variant_dict_insert_value (metadata_dict, \"eolr\",\n                                 g_variant_new_string (eol_rebase));\n}\n\nstatic void\nadd_metadata_to_deploy_data (GVariantDict *metadata_dict,\n                             GKeyFile     *keyfile)\n{\n  g_autofree char *application_runtime = NULL;\n  g_autofree char *extension_of = NULL;\n\n  application_runtime = g_key_file_get_string (keyfile,\n                                               FLATPAK_METADATA_GROUP_APPLICATION,\n                                               FLATPAK_METADATA_KEY_RUNTIME, NULL);\n  extension_of = g_key_file_get_string (keyfile,\n                                        FLATPAK_METADATA_GROUP_EXTENSION_OF,\n                                        FLATPAK_METADATA_KEY_REF, NULL);\n\n  if (application_runtime)\n    g_variant_dict_insert_value (metadata_dict, \"runtime\",\n                                 g_variant_new_string (application_runtime));\n  if (extension_of)\n    g_variant_dict_insert_value (metadata_dict, \"extension-of\",\n                                 g_variant_new_string (extension_of));\n}\n\nstatic GBytes *\nflatpak_dir_new_deploy_data (FlatpakDir         *self,\n                             GFile              *deploy_dir,\n                             GVariant           *commit_data,\n                             GVariant           *commit_metadata,\n                             GKeyFile           *metadata,\n                             const char         *id,\n                             const char         *origin,\n                             const char         *commit,\n                             char              **subpaths,\n                             guint64             installed_size,\n                             const char * const *previous_ids)\n{\n  char *empty_subpaths[] = {NULL};\n  g_auto(GVariantDict) metadata_dict = FLATPAK_VARIANT_DICT_INITIALIZER;\n  g_autoptr(GVariant) res = NULL;\n\n  g_variant_dict_init (&metadata_dict, NULL);\n  g_variant_dict_insert_value (&metadata_dict, \"deploy-version\",\n                               g_variant_new_int32 (FLATPAK_DEPLOY_VERSION_CURRENT));\n  g_variant_dict_insert_value (&metadata_dict, \"timestamp\",\n                               g_variant_new_uint64 (ostree_commit_get_timestamp (commit_data)));\n\n  if (previous_ids)\n    g_variant_dict_insert_value (&metadata_dict, \"previous-ids\",\n                                 g_variant_new_strv (previous_ids, -1));\n\n  add_commit_metadata_to_deploy_data (&metadata_dict, commit_metadata);\n  add_metadata_to_deploy_data (&metadata_dict, metadata);\n  add_appdata_to_deploy_data (&metadata_dict, deploy_dir, id);\n\n  res = g_variant_ref_sink (g_variant_new (\"(ss^ast@a{sv})\",\n                                           origin,\n                                           commit,\n                                           subpaths ? subpaths : empty_subpaths,\n                                           GUINT64_TO_BE (installed_size),\n                                           g_variant_dict_end (&metadata_dict)));\n  return g_variant_get_data_as_bytes (res);\n}\n\nstatic GBytes *\nupgrade_deploy_data (GBytes             *deploy_data,\n                     GFile              *deploy_dir,\n                     FlatpakDecomposed  *ref,\n                     OstreeRepo         *repo,\n                     GCancellable       *cancellable,\n                     GError            **error)\n{\n  VarDeployDataRef deploy_ref = var_deploy_data_from_bytes (deploy_data);\n  g_autoptr(GVariant) metadata = g_variant_ref_sink (var_metadata_peek_as_gvariant (var_deploy_data_get_metadata (deploy_ref)));\n  g_auto(GVariantDict) metadata_dict = FLATPAK_VARIANT_DICT_INITIALIZER;\n  g_autofree const char **subpaths = NULL;\n  g_autoptr(GVariant) res = NULL;\n  int i, n, old_version;\n\n  g_variant_dict_init (&metadata_dict, NULL);\n  g_variant_dict_insert_value (&metadata_dict, \"deploy-version\",\n                               g_variant_new_int32 (FLATPAK_DEPLOY_VERSION_CURRENT));\n\n  /* Copy all metadata except version from old */\n  n = g_variant_n_children (metadata);\n  for (i = 0; i < n; i++)\n    {\n      const char *key;\n      g_autoptr(GVariant) value = NULL;\n\n      g_variant_get_child (metadata, i, \"{&s@v}\", &key, &value);\n      if (strcmp (key, \"deploy-version\") == 0)\n        continue;\n      g_variant_dict_insert_value (&metadata_dict, key, value);\n    }\n\n  old_version = flatpak_deploy_data_get_version (deploy_data);\n  if (old_version < 1)\n    {\n      g_autofree char *id = flatpak_decomposed_dup_id (ref);\n      add_appdata_to_deploy_data (&metadata_dict, deploy_dir, id);\n    }\n\n  if (old_version < 3)\n    {\n      /* We don't know what timestamp to use here, use 0 and special case that for update checks */\n      g_variant_dict_insert_value (&metadata_dict, \"timestamp\",\n                                   g_variant_new_uint64 (0));\n    }\n\n  /* Deploy versions older than 4 might have some of the below fields, but it's\n   * not guaranteed if the deploy was first created with an old Flatpak version\n   */\n  if (old_version < 4)\n    {\n      const char *commit;\n      g_autoptr(GVariant) commit_data = NULL;\n      g_autoptr(GVariant) commit_metadata = NULL;\n      g_autoptr(GKeyFile) keyfile = NULL;\n      g_autoptr(GFile) metadata_file = NULL;\n      g_autofree char *metadata_contents = NULL;\n      g_autofree char *id = flatpak_decomposed_dup_id (ref);\n\n      /* Add fields from commit metadata to deploy */\n      commit = flatpak_deploy_data_get_commit (deploy_data);\n      if (!ostree_repo_load_commit (repo, commit, &commit_data, NULL, error))\n        return NULL;\n      commit_metadata = g_variant_get_child_value (commit_data, 0);\n      add_commit_metadata_to_deploy_data (&metadata_dict, commit_metadata);\n\n      /* Add fields from metadata file to deploy */\n      keyfile = g_key_file_new ();\n      metadata_file = g_file_resolve_relative_path (deploy_dir, \"metadata\");\n      if (!g_file_load_contents (metadata_file, cancellable,\n                                 &metadata_contents, NULL, NULL, error))\n        return NULL;\n      if (!g_key_file_load_from_data (keyfile, metadata_contents, -1, 0, error))\n        return NULL;\n      add_metadata_to_deploy_data (&metadata_dict, keyfile);\n\n      /* Add fields from appdata to deploy, since appdata-content-rating wasn't\n       * added when upgrading from version 2 as it should have been\n       */\n      if (old_version >= 1)\n        add_appdata_to_deploy_data (&metadata_dict, deploy_dir, id);\n    }\n\n  subpaths = flatpak_deploy_data_get_subpaths (deploy_data);\n  res = g_variant_ref_sink (g_variant_new (\"(ss^ast@a{sv})\",\n                                           flatpak_deploy_data_get_origin (deploy_data),\n                                           flatpak_deploy_data_get_commit (deploy_data),\n                                           subpaths,\n                                           GUINT64_TO_BE (flatpak_deploy_data_get_installed_size (deploy_data)),\n                                           g_variant_dict_end (&metadata_dict)));\n  return g_variant_get_data_as_bytes (res);\n}\n\nGBytes *\nflatpak_dir_get_deploy_data (FlatpakDir        *self,\n                             FlatpakDecomposed *ref,\n                             int                required_version,\n                             GCancellable      *cancellable,\n                             GError           **error)\n{\n  g_autoptr(GFile) deploy_dir = NULL;\n\n  deploy_dir = flatpak_dir_get_if_deployed (self, ref, NULL, cancellable);\n  if (deploy_dir == NULL)\n    {\n      g_set_error (error, FLATPAK_ERROR, FLATPAK_ERROR_NOT_INSTALLED,\n                   _(\"%s not installed\"), flatpak_decomposed_get_ref (ref));\n      return NULL;\n    }\n\n  if (!flatpak_dir_ensure_repo (self, cancellable, error))\n    return NULL;\n\n  return flatpak_load_deploy_data (deploy_dir,\n                                   ref,\n                                   self->repo,\n                                   required_version,\n                                   cancellable,\n                                   error);\n}\n\nchar *\nflatpak_dir_get_origin (FlatpakDir        *self,\n                        FlatpakDecomposed *ref,\n                        GCancellable      *cancellable,\n                        GError           **error)\n{\n  g_autoptr(GBytes) deploy_data = NULL;\n\n  deploy_data = flatpak_dir_get_deploy_data (self, ref, FLATPAK_DEPLOY_VERSION_ANY,\n                                             cancellable, error);\n  if (deploy_data == NULL)\n    return NULL;\n\n  return g_strdup (flatpak_deploy_data_get_origin (deploy_data));\n}\n\ngboolean\nflatpak_dir_ensure_path (FlatpakDir   *self,\n                         GCancellable *cancellable,\n                         GError      **error)\n{\n  /* In the system case, we use default perms */\n  if (!self->user)\n    return flatpak_mkdir_p (self->basedir, cancellable, error);\n  else\n    {\n      /* First make the parent */\n      g_autoptr(GFile) parent = g_file_get_parent (self->basedir);\n      if (!flatpak_mkdir_p (parent, cancellable, error))\n        return FALSE;\n      glnx_autofd int parent_dfd = -1;\n      if (!glnx_opendirat (AT_FDCWD, flatpak_file_get_path_cached (parent), TRUE,\n                           &parent_dfd, error))\n        return FALSE;\n      g_autofree char *name = g_file_get_basename (self->basedir);\n      /* Use 0700 in the user case to neuter any suid or world-writable\n       * bits that happen to be in content; see\n       * https://github.com/flatpak/flatpak/pull/837\n       */\n      if (mkdirat (parent_dfd, name, 0700) < 0)\n        {\n          if (errno == EEXIST)\n            {\n              /* And fix up any existing installs that had too-wide perms */\n              struct stat stbuf;\n              if (fstatat (parent_dfd, name, &stbuf, 0) < 0)\n                return glnx_throw_errno_prefix (error, \"fstatat\");\n              if (stbuf.st_mode & S_IXOTH)\n                {\n                  if (fchmodat (parent_dfd, name, 0700, 0) < 0)\n                    return glnx_throw_errno_prefix (error, \"fchmodat\");\n                }\n            }\n          else\n            return glnx_throw_errno_prefix (error, \"mkdirat\");\n        }\n\n      return TRUE;\n    }\n}\n\ngboolean\nflatpak_dir_migrate_config (FlatpakDir   *self,\n                            gboolean     *changed,\n                            GCancellable *cancellable,\n                            GError      **error)\n{\n  g_auto(GStrv) remotes = NULL;\n  g_autoptr(GKeyFile) config = NULL;\n  int i;\n\n  if (changed != NULL)\n    *changed = FALSE;\n\n  /* Only do anything if it exists */\n  if (!flatpak_dir_maybe_ensure_repo (self, NULL, NULL))\n    return TRUE;\n\n  remotes = flatpak_dir_list_remotes (self, cancellable, NULL);\n  if (remotes == NULL)\n    return TRUE;\n\n  /* Enable gpg-verify-summary for all remotes with a collection id *and* gpg-verify set, because\n   * we want to use summary verification, but older versions of collection-id didn't work with it */\n  for (i = 0; remotes != NULL && remotes[i] != NULL; i++)\n    {\n      g_autofree char *remote_collection_id = NULL;\n      const char *remote = remotes[i];\n      gboolean gpg_verify_summary;\n      gboolean gpg_verify;\n\n      if (flatpak_dir_get_remote_disabled (self, remote))\n        continue;\n\n      remote_collection_id = flatpak_dir_get_remote_collection_id (self, remotes[i]);\n      if (remote_collection_id == NULL)\n        continue;\n\n      if (!ostree_repo_remote_get_gpg_verify_summary (self->repo, remote, &gpg_verify_summary, NULL))\n        continue;\n\n      if (!ostree_repo_remote_get_gpg_verify (self->repo, remote, &gpg_verify, NULL))\n        continue;\n\n      if (gpg_verify && !gpg_verify_summary)\n        {\n          g_autofree char *group = g_strdup_printf (\"remote \\\"%s\\\"\", remote);\n          if (config == NULL)\n            config = ostree_repo_copy_config (flatpak_dir_get_repo (self));\n\n          g_debug (\"Migrating remote '%s' to gpg-verify-summary\", remote);\n          g_key_file_set_boolean (config, group, \"gpg-verify-summary\", TRUE);\n        }\n    }\n\n  if (config != NULL)\n    {\n      if (flatpak_dir_use_system_helper (self, NULL))\n        {\n          g_autoptr(GError) local_error = NULL;\n          const char *installation = flatpak_dir_get_id (self);\n\n          if (!flatpak_dir_system_helper_call_ensure_repo (self,\n                                                           FLATPAK_HELPER_ENSURE_REPO_FLAGS_NONE,\n                                                           installation ? installation : \"\",\n                                                           NULL, &local_error))\n            g_debug (\"Failed to migrate system config: %s\", local_error->message);\n        }\n      else\n        {\n          if (!ostree_repo_write_config (self->repo, config, error))\n            return FALSE;\n        }\n\n      if (changed != NULL)\n        *changed = TRUE;\n    }\n\n  return TRUE;\n}\n\n/* Warning: This is not threadsafe, don't use in libflatpak */\ngboolean\nflatpak_dir_recreate_repo (FlatpakDir   *self,\n                           GCancellable *cancellable,\n                           GError      **error)\n{\n  gboolean res;\n  OstreeRepo *old_repo = g_steal_pointer (&self->repo);\n\n  /* This is also set by ensure repo, so clear it too */\n  g_clear_object (&self->cache_dir);\n\n  res = flatpak_dir_ensure_repo (self, cancellable, error);\n  g_clear_object (&old_repo);\n\n  G_LOCK (config_cache);\n\n  g_clear_pointer (&self->masked, g_regex_unref);\n  g_clear_pointer (&self->pinned, g_regex_unref);\n\n  G_UNLOCK (config_cache);\n\n  return res;\n}\n\nstatic void\ncopy_remote_config (GKeyFile *config,\n                    GKeyFile *group_config,\n                    const char *remote_name)\n{\n  g_auto(GStrv) keys = NULL;\n  g_autofree char *group = g_strdup_printf (\"remote \\\"%s\\\"\", remote_name);\n  int i;\n\n  g_key_file_remove_group (config, group, NULL);\n\n  keys = g_key_file_get_keys (group_config, group, NULL, NULL);\n  if (keys == NULL)\n    return;\n\n  for (i = 0; keys[i] != NULL; i++)\n    {\n      g_autofree gchar *value = g_key_file_get_value (group_config, group, keys[i], NULL);\n      if (value &&\n          /* Canonicalize empty filter to unset */\n          (strcmp (keys[i], \"xa.filter\") != 0 ||\n           *value != 0))\n        g_key_file_set_value (config, group, keys[i], value);\n    }\n}\n\nstatic GHashTable *\n_flatpak_dir_find_new_flatpakrepos (FlatpakDir *self, OstreeRepo *repo)\n{\n  g_autoptr(GHashTable) flatpakrepos = NULL;\n  g_autoptr(GFile) conf_dir = NULL;\n  g_autoptr(GFileEnumerator) dir_enum = NULL;\n  g_autoptr(GError) my_error = NULL;\n  g_autofree char *config_dir = NULL;\n  g_auto(GStrv) remotes = NULL;\n  g_auto(GStrv) applied_remotes = NULL;\n\n  g_assert (repo != NULL);\n\n  /* Predefined remotes only applies for the default system installation */\n  if (self->user ||\n      (self->extra_data != NULL &&\n       strcmp (self->extra_data->id, SYSTEM_DIR_DEFAULT_ID) != 0))\n    return NULL;\n\n  config_dir = g_strdup_printf (\"%s/%s\",\n                                get_config_dir_location (),\n                                SYSCONF_REMOTES_DIR);\n  conf_dir = g_file_new_for_path (config_dir);\n  dir_enum = g_file_enumerate_children (conf_dir,\n                                        G_FILE_ATTRIBUTE_STANDARD_NAME \",\" G_FILE_ATTRIBUTE_STANDARD_TYPE,\n                                        G_FILE_QUERY_INFO_NONE,\n                                        NULL, &my_error);\n  if (my_error != NULL)\n    return NULL;\n\n  remotes = ostree_repo_remote_list (repo, NULL);\n  applied_remotes = g_key_file_get_string_list (ostree_repo_get_config (repo),\n                                                \"core\", \"xa.applied-remotes\", NULL, NULL);\n\n  while (TRUE)\n    {\n      GFileInfo *file_info;\n      GFile *path;\n      const char *name;\n      guint32 type;\n\n      if (!g_file_enumerator_iterate (dir_enum, &file_info, &path,\n                                      NULL, &my_error))\n        {\n          g_debug (\"Unexpected error reading file in %s: %s\",\n                   config_dir, my_error->message);\n          break;\n        }\n\n      if (file_info == NULL)\n        break;\n\n      name = g_file_info_get_name (file_info);\n      type = g_file_info_get_file_type (file_info);\n\n      if (type == G_FILE_TYPE_REGULAR && g_str_has_suffix (name, SYSCONF_REMOTES_FILE_EXT))\n        {\n          g_autofree char *remote_name = g_strndup (name, strlen (name) - strlen (SYSCONF_REMOTES_FILE_EXT));\n\n          if (remotes && g_strv_contains ((const char * const *)remotes, remote_name))\n            continue;\n\n          if (applied_remotes && g_strv_contains ((const char * const *)applied_remotes, remote_name))\n            continue;\n\n          if (flatpakrepos == NULL)\n            flatpakrepos = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, g_object_unref);\n\n          g_hash_table_insert (flatpakrepos, g_steal_pointer (&remote_name), g_file_enumerator_get_child (dir_enum, file_info));\n        }\n    }\n\n  return g_steal_pointer (&flatpakrepos);\n}\n\nstatic gboolean\napply_new_flatpakrepo (const char *remote_name,\n                       GFile      *file,\n                       OstreeRepo *repo,\n                       GError    **error)\n{\n  g_autoptr(GBytes) gpg_data = NULL;\n  g_autoptr(GKeyFile) group_config = NULL;\n  g_autoptr(GKeyFile) keyfile = g_key_file_new ();\n  g_autoptr(GError) local_error = NULL;\n  g_autoptr(GKeyFile) new_config = NULL;\n  g_auto(GStrv) old_applied_remotes = NULL;\n  g_autoptr(GPtrArray) new_applied_remotes = NULL;\n  int i;\n\n  if (!g_key_file_load_from_file (keyfile, flatpak_file_get_path_cached (file), 0, &local_error))\n    {\n      flatpak_fail (error, _(\"Can't load file %s: %s\\n\"), flatpak_file_get_path_cached (file), local_error->message);\n      return FALSE;\n    }\n\n  group_config = flatpak_parse_repofile (remote_name, FALSE, keyfile, &gpg_data, NULL, &local_error);\n  if (group_config == NULL)\n    {\n      flatpak_fail (error, _(\"Error parsing system flatpakrepo file for %s: %s\"), remote_name, local_error->message);\n      return FALSE;\n    }\n\n  new_config = ostree_repo_copy_config (repo);\n\n  old_applied_remotes = g_key_file_get_string_list (new_config, \"core\", \"xa.applied-remotes\", NULL, NULL);\n\n  copy_remote_config (new_config, group_config, remote_name);\n\n  new_applied_remotes = g_ptr_array_new_with_free_func (g_free);\n  for (i = 0; old_applied_remotes != NULL && old_applied_remotes[i] != NULL; i++)\n    g_ptr_array_add (new_applied_remotes, g_strdup (old_applied_remotes[i]));\n\n  g_ptr_array_add (new_applied_remotes, g_strdup (remote_name));\n\n  g_key_file_set_string_list (new_config, \"core\", \"xa.applied-remotes\",\n                              (const char * const *) new_applied_remotes->pdata, new_applied_remotes->len);\n\n  if (!ostree_repo_write_config (repo, new_config, error))\n    return FALSE;\n\n  if (!ostree_repo_reload_config (repo, NULL, error))\n    return FALSE;\n\n  if (gpg_data != NULL)\n    {\n      g_autoptr(GInputStream) input_stream = g_memory_input_stream_new_from_bytes (gpg_data);\n      guint imported = 0;\n\n      if (!ostree_repo_remote_gpg_import (repo, remote_name, input_stream,\n                                          NULL, &imported, NULL, error))\n        return FALSE;\n\n      g_debug (\"Imported %u GPG key%s to remote \\\"%s\\\"\", imported, (imported == 1) ? \"\" : \"s\", remote_name);\n    }\n\n  return TRUE;\n}\n\nstatic gboolean\n_flatpak_dir_ensure_repo (FlatpakDir   *self,\n                          gboolean      allow_empty,\n                          GCancellable *cancellable,\n                          GError      **error)\n{\n  g_autoptr(GFile) repodir = NULL;\n  g_autoptr(OstreeRepo) repo = NULL;\n  g_autoptr(GError) my_error = NULL;\n  g_autoptr(GFile) cache_dir = NULL;\n  g_autoptr(GHashTable) flatpakrepos = NULL;\n\n  if (self->repo != NULL)\n    return TRUE;\n\n  if (!g_file_query_exists (self->basedir, cancellable))\n    {\n      if (flatpak_dir_use_system_helper (self, NULL))\n        {\n          g_autoptr(GError) local_error = NULL;\n          const char *installation = flatpak_dir_get_id (self);\n\n          if (!flatpak_dir_system_helper_call_ensure_repo (self,\n                                                           FLATPAK_HELPER_ENSURE_REPO_FLAGS_NONE,\n                                                           installation ? installation : \"\",\n                                                           NULL, &local_error))\n            {\n              if (allow_empty)\n                return TRUE;\n\n              g_propagate_error (error, g_steal_pointer (&local_error));\n              return FALSE;\n            }\n        }\n      else\n        {\n          g_autoptr(GError) local_error = NULL;\n          if (!flatpak_dir_ensure_path (self, cancellable, &local_error))\n            {\n              if (allow_empty)\n                return TRUE;\n\n              g_propagate_error (error, g_steal_pointer (&local_error));\n              return FALSE;\n            }\n        }\n    }\n\n  repodir = g_file_get_child (self->basedir, \"repo\");\n\n  repo = ostree_repo_new (repodir);\n\n  if (!g_file_query_exists (repodir, cancellable))\n    {\n      /* We always use bare-user-only these days, except old installations\n         that still user bare-user */\n      OstreeRepoMode mode = OSTREE_REPO_MODE_BARE_USER_ONLY;\n\n      if (!ostree_repo_create (repo, mode, cancellable, &my_error))\n        {\n          flatpak_rm_rf (repodir, cancellable, NULL);\n\n          if (allow_empty)\n            return TRUE;\n\n          g_propagate_error (error, g_steal_pointer (&my_error));\n          return FALSE;\n        }\n\n      /* Create .changed file early to avoid polling non-existing file in monitor */\n      if (!flatpak_dir_mark_changed (self, &my_error))\n        {\n          g_warning (\"Error marking directory as changed: %s\", my_error->message);\n          g_clear_error (&my_error);\n        }\n    }\n  else\n    {\n      if (!ostree_repo_open (repo, cancellable, error))\n        {\n          g_autofree char *repopath = NULL;\n\n          repopath = g_file_get_path (repodir);\n          g_prefix_error (error, _(\"While opening repository %s: \"), repopath);\n          return FALSE;\n        }\n    }\n\n  /* In the system-helper case we're directly using the global repo, and we can't write any\n   * caches for summaries there, so we need to set a custom dir for this. Note, as per #3303\n   * this has to be called after ostree_repo_open() in order to the custom cachedir being\n   * overridden if the system dir is writable (like in the testsuite).\n   */\n  if (flatpak_dir_use_system_helper (self, NULL))\n    {\n      g_autofree char *cache_path = NULL;\n\n      cache_dir = flatpak_ensure_user_cache_dir_location (error);\n      if (cache_dir == NULL)\n        return FALSE;\n\n      cache_path = g_file_get_path (cache_dir);\n      if (!ostree_repo_set_cache_dir (repo,\n                                      AT_FDCWD, cache_path,\n                                      cancellable, error))\n        return FALSE;\n    }\n\n  /* Earlier flatpak used to reset min-free-space-percent to 0 every time, but now we\n   * favor min-free-space-size instead of it (See below).\n   */\n  if (!flatpak_dir_use_system_helper (self, NULL))\n    {\n      GKeyFile *orig_config = NULL;\n      g_autoptr(GKeyFile) new_config = NULL;\n      g_autofree char *orig_min_free_space_percent = NULL;\n      g_autofree char *orig_min_free_space_size = NULL;\n      const char *min_free_space_size = \"500MB\";\n      guint64 min_free_space_percent_int;\n\n      orig_config = ostree_repo_get_config (repo);\n      orig_min_free_space_percent = g_key_file_get_value (orig_config, \"core\", \"min-free-space-percent\", NULL);\n      orig_min_free_space_size = g_key_file_get_value (orig_config, \"core\", \"min-free-space-size\", NULL);\n\n      if (orig_min_free_space_size == NULL)\n        new_config = ostree_repo_copy_config (repo);\n\n      /* Scrap previously written min-free-space-percent=0 and replace it with min-free-space-size */\n      if (orig_min_free_space_size == NULL &&\n          orig_min_free_space_percent != NULL &&\n          flatpak_utils_ascii_string_to_unsigned (orig_min_free_space_percent, 10,\n                                                  0, G_MAXUINT64,\n                                                  &min_free_space_percent_int, &my_error))\n        {\n          if (min_free_space_percent_int == 0)\n            {\n              g_key_file_remove_key (new_config, \"core\", \"min-free-space-percent\", NULL);\n              g_key_file_set_string (new_config, \"core\", \"min-free-space-size\", min_free_space_size);\n            }\n        }\n      else if (my_error != NULL)\n        {\n          g_propagate_error (error, g_steal_pointer (&my_error));\n          return FALSE;\n        }\n\n      if (orig_min_free_space_size == NULL &&\n          orig_min_free_space_percent == NULL)\n        g_key_file_set_string (new_config, \"core\", \"min-free-space-size\", min_free_space_size);\n\n      if (new_config != NULL)\n        {\n          if (!ostree_repo_write_config (repo, new_config, error))\n            return FALSE;\n\n          if (!ostree_repo_reload_config (repo, cancellable, error))\n            return FALSE;\n        }\n    }\n\n  flatpakrepos = _flatpak_dir_find_new_flatpakrepos (self, repo);\n  if (flatpakrepos)\n    {\n      if (flatpak_dir_use_system_helper (self, NULL))\n        {\n          const char *installation = flatpak_dir_get_id (self);\n          if (!flatpak_dir_system_helper_call_ensure_repo (self,\n                                                           FLATPAK_HELPER_ENSURE_REPO_FLAGS_NONE,\n                                                           installation ? installation : \"\",\n                                                           NULL, &my_error))\n            {\n              if (allow_empty)\n                return TRUE;\n\n              g_propagate_error (error, g_steal_pointer (&my_error));\n              return FALSE;\n            }\n\n          if (!ostree_repo_reload_config (repo, cancellable, error))\n            return FALSE;\n        }\n      else\n        {\n          GLNX_HASH_TABLE_FOREACH_KV (flatpakrepos, const char *, remote_name, GFile *, file)\n            {\n              if (!apply_new_flatpakrepo (remote_name, file, repo, error))\n                return FALSE;\n            }\n        }\n    }\n\n\n  if (cache_dir == NULL)\n    cache_dir = g_file_get_child (repodir, \"tmp/cache\");\n\n  /* Make sure we didn't reenter weirdly */\n  g_assert (self->repo == NULL);\n  self->repo = g_object_ref (repo);\n  self->cache_dir = g_object_ref (cache_dir);\n\n  return TRUE;\n}\n\ngboolean\nflatpak_dir_ensure_repo (FlatpakDir   *self,\n                         GCancellable *cancellable,\n                         GError      **error)\n{\n  return _flatpak_dir_ensure_repo (self, FALSE, cancellable, error);\n}\n\ngboolean\nflatpak_dir_maybe_ensure_repo (FlatpakDir   *self,\n                               GCancellable *cancellable,\n                               GError      **error)\n{\n  return _flatpak_dir_ensure_repo (self, TRUE, cancellable, error);\n}\n\nstatic gboolean\n_flatpak_dir_reload_config (FlatpakDir   *self,\n                            GCancellable *cancellable,\n                            GError      **error)\n{\n  if (self->repo)\n    {\n      if (!ostree_repo_reload_config (self->repo, cancellable, error))\n        return FALSE;\n    }\n\n  /* Clear cached stuff from repo config */\n  G_LOCK (config_cache);\n\n  g_clear_pointer (&self->masked, g_regex_unref);\n  g_clear_pointer (&self->pinned, g_regex_unref);\n\n  G_UNLOCK (config_cache);\n  return TRUE;\n}\n\nchar *\nflatpak_dir_get_config (FlatpakDir *self,\n                        const char *key,\n                        GError    **error)\n{\n  GKeyFile *config;\n  g_autofree char *ostree_key = NULL;\n\n  if (!flatpak_dir_maybe_ensure_repo (self, NULL, error))\n    return NULL;\n\n  if (self->repo == NULL)\n    {\n      g_set_error (error, G_KEY_FILE_ERROR, G_KEY_FILE_ERROR_KEY_NOT_FOUND,\n                   _(\"The config key %s is not set\"), key);\n      return NULL;\n    }\n\n  config = ostree_repo_get_config (self->repo);\n  ostree_key = g_strconcat (\"xa.\", key, NULL);\n\n  return g_key_file_get_string (config, \"core\", ostree_key, error);\n}\n\nGPtrArray *\nflatpak_dir_get_config_patterns (FlatpakDir *dir, const char *key)\n{\n  g_autoptr(GPtrArray) patterns = NULL;\n  g_autofree char *key_value = NULL;\n  int i;\n\n  patterns = g_ptr_array_new_with_free_func (g_free);\n\n  key_value = flatpak_dir_get_config (dir, key, NULL);\n  if (key_value)\n    {\n      g_auto(GStrv) oldv = g_strsplit (key_value, \";\", -1);\n\n      for (i = 0; oldv[i] != NULL; i++)\n        {\n          const char *old = oldv[i];\n\n          if (*old != 0 && !flatpak_g_ptr_array_contains_string (patterns, old))\n            g_ptr_array_add (patterns, g_strdup (old));\n        }\n    }\n\n  return g_steal_pointer (&patterns);\n}\n\ngboolean\nflatpak_dir_set_config (FlatpakDir *self,\n                        const char *key,\n                        const char *value,\n                        GError    **error)\n{\n  g_autoptr(GKeyFile) config = NULL;\n  g_autofree char *ostree_key = NULL;\n\n  if (!flatpak_dir_ensure_repo (self, NULL, error))\n    return FALSE;\n\n  config = ostree_repo_copy_config (self->repo);\n  ostree_key = g_strconcat (\"xa.\", key, NULL);\n\n  if (flatpak_dir_use_system_helper (self, NULL))\n    {\n      FlatpakHelperConfigureFlags flags = 0;\n      const char *installation = flatpak_dir_get_id (self);\n\n      if (value == NULL)\n        {\n          flags |= FLATPAK_HELPER_CONFIGURE_FLAGS_UNSET;\n          value = \"\";\n        }\n\n      if (!flatpak_dir_system_helper_call_configure (self,\n                                                     flags, key, value,\n                                                     installation ? installation : \"\",\n                                                     NULL, error))\n        return FALSE;\n\n      return TRUE;\n    }\n\n  if (value == NULL)\n    g_key_file_remove_key (config, \"core\", ostree_key, NULL);\n  else\n    g_key_file_set_value (config, \"core\", ostree_key, value);\n\n  if (!ostree_repo_write_config (self->repo, config, error))\n    return FALSE;\n\n  if (!_flatpak_dir_reload_config (self, NULL, error))\n    return FALSE;\n\n  return TRUE;\n}\n\ngboolean\nflatpak_dir_config_append_pattern (FlatpakDir *self,\n                                   const char *key,\n                                   const char *pattern,\n                                   gboolean    runtime_only,\n                                   gboolean   *out_already_present,\n                                   GError    **error)\n{\n  g_autoptr(GPtrArray) patterns = flatpak_dir_get_config_patterns (self, key);\n  g_autofree char *regexp;\n  gboolean already_present;\n  g_autofree char *merged_patterns = NULL;\n\n  regexp = flatpak_filter_glob_to_regexp (pattern, runtime_only, error);\n  if (regexp == NULL)\n    return FALSE;\n\n  if (!(already_present = flatpak_g_ptr_array_contains_string (patterns, pattern)))\n    g_ptr_array_add (patterns, g_strdup (pattern));\n\n  if (out_already_present)\n    *out_already_present = already_present;\n\n  g_ptr_array_sort (patterns, flatpak_strcmp0_ptr);\n\n  g_ptr_array_add (patterns, NULL);\n  merged_patterns = g_strjoinv (\";\", (char **)patterns->pdata);\n\n  return flatpak_dir_set_config (self, key, merged_patterns, error);\n}\n\ngboolean\nflatpak_dir_config_remove_pattern (FlatpakDir *self,\n                                   const char *key,\n                                   const char *pattern,\n                                   GError    **error)\n{\n  g_autoptr(GPtrArray) patterns = flatpak_dir_get_config_patterns (self, key);\n  g_autofree char *merged_patterns = NULL;\n  int j;\n\n  for (j = 0; j < patterns->len; j++)\n    {\n      if (strcmp (g_ptr_array_index (patterns, j), pattern) == 0)\n        break;\n    }\n\n  if (j == patterns->len)\n    return flatpak_fail (error, _(\"No current %s pattern matching %s\"), key, pattern);\n  else\n    g_ptr_array_remove_index (patterns, j);\n\n  g_ptr_array_add (patterns, NULL);\n  merged_patterns = g_strjoinv (\";\", (char **)patterns->pdata);\n\n  return flatpak_dir_set_config (self, key, merged_patterns, error);\n}\n\ngboolean\nflatpak_dir_mark_changed (FlatpakDir *self,\n                          GError    **error)\n{\n  g_autoptr(GFile) changed_file = NULL;\n  g_autofree char * changed_path = NULL;\n\n  changed_file = flatpak_dir_get_changed_path (self);\n  changed_path = g_file_get_path (changed_file);\n\n  if (!g_utime (changed_path, NULL))\n    return TRUE;\n\n  if (errno != ENOENT)\n    return glnx_throw_errno (error);\n\n  if (!g_file_replace_contents (changed_file, \"\", 0, NULL, FALSE,\n                                G_FILE_CREATE_NONE, NULL, NULL, error))\n    return FALSE;\n\n  return TRUE;\n}\n\ngboolean\nflatpak_dir_remove_appstream (FlatpakDir   *self,\n                              const char   *remote,\n                              GCancellable *cancellable,\n                              GError      **error)\n{\n  g_autoptr(GFile) appstream_dir = NULL;\n  g_autoptr(GFile) remote_dir = NULL;\n\n  if (!flatpak_dir_ensure_repo (self, cancellable, error))\n    return FALSE;\n\n  appstream_dir = g_file_get_child (flatpak_dir_get_path (self), \"appstream\");\n  remote_dir = g_file_get_child (appstream_dir, remote);\n\n  if (g_file_query_exists (remote_dir, cancellable) &&\n      !flatpak_rm_rf (remote_dir, cancellable, error))\n    return FALSE;\n\n  return TRUE;\n}\n\ngboolean\nflatpak_dir_deploy_appstream (FlatpakDir   *self,\n                              const char   *remote,\n                              const char   *arch,\n                              gboolean     *out_changed,\n                              GCancellable *cancellable,\n                              GError      **error)\n{\n  g_autoptr(GFile) appstream_dir = NULL;\n  g_autoptr(GFile) remote_dir = NULL;\n  g_autoptr(GFile) arch_dir = NULL;\n  g_autoptr(GFile) checkout_dir = NULL;\n  g_autoptr(GFile) real_checkout_dir = NULL;\n  g_autoptr(GFile) timestamp_file = NULL;\n  g_autofree char *arch_path = NULL;\n  gboolean checkout_exists;\n  const char *old_dir = NULL;\n  g_autofree char *new_checksum = NULL;\n  g_autoptr(GFile) active_link = NULL;\n  g_autofree char *branch = NULL;\n  g_autoptr(GFile) old_checkout_dir = NULL;\n  g_autoptr(GFile) active_tmp_link = NULL;\n  g_autoptr(GError) tmp_error = NULL;\n  g_autofree char *new_dir = NULL;\n  g_autofree char *checkout_dir_path = NULL;\n  OstreeRepoCheckoutAtOptions options = { 0, };\n  glnx_autofd int dfd = -1;\n  g_autoptr(GFileInfo) file_info = NULL;\n  g_autofree char *tmpname = g_strdup (\".active-XXXXXX\");\n  g_auto(GLnxLockFile) lock = { 0, };\n  gboolean do_compress = FALSE;\n  gboolean do_uncompress = TRUE;\n  g_autofree char *filter_checksum = NULL;\n  g_autoptr(GRegex) allow_refs = NULL;\n  g_autoptr(GRegex) deny_refs = NULL;\n  g_autofree char *subset = NULL;\n\n  /* Keep a shared repo lock to avoid prunes removing objects we're relying on\n   * while we do the checkout. This could happen if the ref changes after we\n   * read its current value for the checkout. */\n  if (!flatpak_dir_repo_lock (self, &lock, LOCK_SH, cancellable, error))\n    return FALSE;\n\n  if (!flatpak_dir_lookup_remote_filter (self, remote, TRUE, &filter_checksum, &allow_refs, &deny_refs, error))\n    return FALSE;\n\n  appstream_dir = g_file_get_child (flatpak_dir_get_path (self), \"appstream\");\n  remote_dir = g_file_get_child (appstream_dir, remote);\n  arch_dir = g_file_get_child (remote_dir, arch);\n  active_link = g_file_get_child (arch_dir, \"active\");\n  timestamp_file = g_file_get_child (arch_dir, \".timestamp\");\n\n  arch_path = g_file_get_path (arch_dir);\n  if (g_mkdir_with_parents (arch_path, 0755) != 0)\n    {\n      glnx_set_error_from_errno (error);\n      return FALSE;\n    }\n\n  if (!glnx_opendirat (AT_FDCWD, arch_path, TRUE, &dfd, error))\n    return FALSE;\n\n  old_dir = NULL;\n  file_info = g_file_query_info (active_link, OSTREE_GIO_FAST_QUERYINFO,\n                                 G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n                                 cancellable, NULL);\n  if (file_info != NULL)\n    old_dir =  g_file_info_get_symlink_target (file_info);\n\n  subset = flatpak_dir_get_remote_subset (self, remote);\n\n  if (subset)\n    branch = g_strdup_printf (\"appstream2/%s-%s\", subset, arch);\n  else\n    branch = g_strdup_printf (\"appstream2/%s\", arch);\n\n  if (!flatpak_repo_resolve_rev (self->repo, NULL, remote, branch, TRUE,\n                                 &new_checksum, cancellable, error))\n    return FALSE;\n\n  if (new_checksum == NULL && subset == NULL)\n    {\n      /* Fall back to old branch (only exist on non-subsets) */\n      g_clear_pointer (&branch, g_free);\n      branch = g_strdup_printf (\"appstream/%s\", arch);\n      if (!flatpak_repo_resolve_rev (self->repo, NULL, remote, branch, TRUE,\n                                     &new_checksum, cancellable, error))\n        return FALSE;\n      do_compress = FALSE;\n      do_uncompress = TRUE;\n    }\n  else\n    {\n      do_compress = TRUE;\n      do_uncompress = FALSE;\n    }\n\n  if (new_checksum == NULL)\n    return flatpak_fail_error (error, FLATPAK_ERROR_INVALID_DATA, _(\"No appstream commit to deploy\"));\n\n  if (filter_checksum)\n    new_dir = g_strconcat (new_checksum, \"-\", filter_checksum, NULL);\n  else\n    new_dir = g_strdup (new_checksum);\n\n  real_checkout_dir = g_file_get_child (arch_dir, new_dir);\n  checkout_exists = g_file_query_exists (real_checkout_dir, NULL);\n\n  if (old_dir != NULL && new_dir != NULL &&\n      strcmp (old_dir, new_dir) == 0 &&\n      checkout_exists)\n    {\n      if (!g_file_replace_contents (timestamp_file, \"\", 0, NULL, FALSE,\n                                    G_FILE_CREATE_REPLACE_DESTINATION, NULL, NULL, error))\n        return FALSE;\n\n      if (out_changed)\n        *out_changed = FALSE;\n\n      return TRUE; /* No changes, don't checkout */\n    }\n\n  {\n    g_autofree char *template = g_strdup_printf (\".%s-XXXXXX\", new_dir);\n    g_autoptr(GFile) tmp_dir_template = g_file_get_child (arch_dir, template);\n    checkout_dir_path = g_file_get_path (tmp_dir_template);\n    if (g_mkdtemp_full (checkout_dir_path, 0755) == NULL)\n      {\n        g_set_error (error, G_IO_ERROR, G_IO_ERROR_FAILED,\n                     _(\"Can't create deploy directory\"));\n        return FALSE;\n      }\n  }\n  checkout_dir = g_file_new_for_path (checkout_dir_path);\n\n  options.mode = OSTREE_REPO_CHECKOUT_MODE_USER;\n  options.overwrite_mode = OSTREE_REPO_CHECKOUT_OVERWRITE_UNION_FILES;\n  options.enable_fsync = FALSE; /* We checkout to a temp dir and sync before moving it in place */\n  options.bareuseronly_dirs = TRUE; /* https://github.com/ostreedev/ostree/pull/927 */\n\n  if (!ostree_repo_checkout_at (self->repo, &options,\n                                AT_FDCWD, checkout_dir_path, new_checksum,\n                                cancellable, error))\n    return FALSE;\n\n  /* Old appstream format don't have uncompressed file, so we uncompress it */\n  if (do_uncompress)\n    {\n      g_autoptr(GFile) appstream_xml = g_file_get_child (checkout_dir, \"appstream.xml\");\n      g_autoptr(GFile) appstream_gz_xml = g_file_get_child (checkout_dir, \"appstream.xml.gz\");\n      g_autoptr(GOutputStream) out2 = NULL;\n      g_autoptr(GFileOutputStream) out = NULL;\n      g_autoptr(GFileInputStream) in = NULL;\n\n      in = g_file_read (appstream_gz_xml, NULL, NULL);\n      if (in)\n        {\n          g_autoptr(GZlibDecompressor) decompressor = g_zlib_decompressor_new (G_ZLIB_COMPRESSOR_FORMAT_GZIP);\n          out = g_file_replace (appstream_xml, NULL, FALSE, G_FILE_CREATE_REPLACE_DESTINATION,\n                                NULL, error);\n          if (out == NULL)\n            return FALSE;\n\n          out2 = g_converter_output_stream_new (G_OUTPUT_STREAM (out), G_CONVERTER (decompressor));\n          if (g_output_stream_splice (out2, G_INPUT_STREAM (in), G_OUTPUT_STREAM_SPLICE_CLOSE_SOURCE | G_OUTPUT_STREAM_SPLICE_CLOSE_TARGET,\n                                      NULL, error) < 0)\n            return FALSE;\n        }\n    }\n\n  if (deny_refs)\n    {\n      g_autoptr(GFile) appstream_xml = g_file_get_child (checkout_dir, \"appstream.xml\");\n      g_autoptr(GFileInputStream) in = NULL;\n\n      /* We need some ref filtering, so parse the xml */\n\n      in = g_file_read (appstream_xml, NULL, NULL);\n      if (in)\n        {\n          g_autoptr(FlatpakXml) appstream = NULL;\n          g_autoptr(GBytes) content = NULL;\n\n          appstream = flatpak_xml_parse (G_INPUT_STREAM (in), FALSE, cancellable, error);\n          if (appstream == NULL)\n            return FALSE;\n\n          flatpak_appstream_xml_filter (appstream, allow_refs, deny_refs);\n\n          if (!flatpak_appstream_xml_root_to_data (appstream, &content, NULL, error))\n            return FALSE;\n\n          if (!g_file_replace_contents  (appstream_xml,\n                                         g_bytes_get_data (content, NULL), g_bytes_get_size (content),\n                                         NULL, FALSE, G_FILE_CREATE_REPLACE_DESTINATION, NULL,\n                                         cancellable, error))\n            return FALSE;\n        }\n\n      do_compress = TRUE; /* We need to recompress this */\n    }\n\n  /* New appstream format don't have compressed file, so we compress it */\n  if (do_compress)\n    {\n      g_autoptr(GFile) appstream_xml = g_file_get_child (checkout_dir, \"appstream.xml\");\n      g_autoptr(GFile) appstream_gz_xml = g_file_get_child (checkout_dir, \"appstream.xml.gz\");\n      g_autoptr(GZlibCompressor) compressor = NULL;\n      g_autoptr(GOutputStream) out2 = NULL;\n      g_autoptr(GFileOutputStream) out = NULL;\n      g_autoptr(GFileInputStream) in = NULL;\n\n      in = g_file_read (appstream_xml, NULL, NULL);\n      if (in)\n        {\n          compressor = g_zlib_compressor_new (G_ZLIB_COMPRESSOR_FORMAT_GZIP, -1);\n          out = g_file_replace (appstream_gz_xml, NULL, FALSE, G_FILE_CREATE_REPLACE_DESTINATION,\n                                NULL, error);\n          if (out == NULL)\n            return FALSE;\n\n          out2 = g_converter_output_stream_new (G_OUTPUT_STREAM (out), G_CONVERTER (compressor));\n          if (g_output_stream_splice (out2, G_INPUT_STREAM (in), G_OUTPUT_STREAM_SPLICE_CLOSE_SOURCE | G_OUTPUT_STREAM_SPLICE_CLOSE_TARGET,\n                                      NULL, error) < 0)\n            return FALSE;\n        }\n    }\n\n  glnx_gen_temp_name (tmpname);\n  active_tmp_link = g_file_get_child (arch_dir, tmpname);\n\n  if (!g_file_make_symbolic_link (active_tmp_link, new_dir, cancellable, error))\n    return FALSE;\n\n  if (syncfs (dfd) != 0)\n    {\n      glnx_set_error_from_errno (error);\n      return FALSE;\n    }\n\n  /* By now the checkout to the temporary directory is on disk, as is the temporary\n     symlink pointing to the final target. */\n\n  if (!g_file_move (checkout_dir, real_checkout_dir, G_FILE_COPY_NO_FALLBACK_FOR_MOVE,\n                    cancellable, NULL, NULL, error))\n    return FALSE;\n\n  if (syncfs (dfd) != 0)\n    {\n      glnx_set_error_from_errno (error);\n      return FALSE;\n    }\n\n  if (!flatpak_file_rename (active_tmp_link,\n                            active_link,\n                            cancellable, error))\n    return FALSE;\n\n  if (old_dir != NULL &&\n      g_strcmp0 (old_dir, new_dir) != 0)\n    {\n      old_checkout_dir = g_file_get_child (arch_dir, old_dir);\n      if (!flatpak_rm_rf (old_checkout_dir, cancellable, &tmp_error))\n        g_warning (\"Unable to remove old appstream checkout: %s\", tmp_error->message);\n    }\n\n  if (!g_file_replace_contents (timestamp_file, \"\", 0, NULL, FALSE,\n                                G_FILE_CREATE_REPLACE_DESTINATION, NULL, NULL, error))\n    return FALSE;\n\n  /* If we added a new checkout, touch the toplevel dir to tell people that they need\n     to re-scan */\n  if (!checkout_exists)\n    {\n      g_autofree char *appstream_dir_path = g_file_get_path (appstream_dir);\n      utime (appstream_dir_path, NULL);\n    }\n\n  if (out_changed)\n    *out_changed = TRUE;\n\n  return TRUE;\n}\n\nstatic gboolean repo_get_remote_collection_id (OstreeRepo *repo,\n                                               const char *remote_name,\n                                               char      **collection_id_out,\n                                               GError    **error);\n\n\ngboolean\nflatpak_dir_find_latest_rev (FlatpakDir               *self,\n                             FlatpakRemoteState       *state,\n                             const char               *ref,\n                             const char               *checksum_or_latest,\n                             char                    **out_rev,\n                             guint64                  *out_timestamp,\n                             GFile                   **out_sideload_path,\n                             GCancellable             *cancellable,\n                             GError                  **error)\n{\n  g_autofree char *latest_rev = NULL;\n\n  g_return_val_if_fail (out_rev != NULL, FALSE);\n\n  if (!flatpak_remote_state_lookup_ref (state, ref, &latest_rev, out_timestamp, NULL, out_sideload_path, error))\n    return FALSE;\n  if (latest_rev == NULL)\n    return flatpak_fail_error (error, FLATPAK_ERROR_REF_NOT_FOUND,\n                               _(\"Couldn't find latest checksum for ref %s in remote %s\"),\n                               ref, state->remote_name);\n\n  if (out_rev != NULL)\n    *out_rev = g_steal_pointer (&latest_rev);\n\n  return TRUE;\n}\n\nstatic gboolean\nget_mtime (GFile        *file,\n           GTimeVal     *result,\n           GCancellable *cancellable,\n           GError      **error)\n{\n  g_autoptr(GFileInfo) info = g_file_query_info (file,\n                                                 G_FILE_ATTRIBUTE_TIME_MODIFIED,\n                                                 G_FILE_QUERY_INFO_NONE,\n                                                 cancellable, error);\n  if (info)\n    {\n      g_file_info_get_modification_time (info, result);\n      return TRUE;\n    }\n  else\n    {\n      return FALSE;\n    }\n}\n\nstatic gboolean\ncheck_destination_mtime (GFile        *src,\n                         GFile        *dest,\n                         GCancellable *cancellable)\n{\n  GTimeVal src_mtime;\n  GTimeVal dest_mtime;\n\n  return get_mtime (src, &src_mtime, cancellable, NULL) &&\n         get_mtime (dest, &dest_mtime, cancellable, NULL) &&\n         (src_mtime.tv_sec < dest_mtime.tv_sec ||\n          (src_mtime.tv_sec == dest_mtime.tv_sec && src_mtime.tv_usec < dest_mtime.tv_usec));\n}\n\nstatic GFile *\nflatpak_dir_update_oci_index (FlatpakDir   *self,\n                              const char   *remote,\n                              char        **index_uri_out,\n                              GCancellable *cancellable,\n                              GError      **error)\n{\n  g_autoptr(GError) local_error = NULL;\n  g_autoptr(GFile) index_cache = NULL;\n  g_autofree char *oci_uri = NULL;\n\n  index_cache = flatpak_dir_get_oci_index_location (self, remote, error);\n  if (index_cache == NULL)\n    return NULL;\n\n  ensure_soup_session (self);\n\n  if (!ostree_repo_remote_get_url (self->repo,\n                                   remote,\n                                   &oci_uri,\n                                   error))\n    return NULL;\n\n  if (!flatpak_oci_index_ensure_cached (self->soup_session, oci_uri,\n                                        index_cache, index_uri_out,\n                                        cancellable, &local_error))\n    {\n      if (!g_error_matches (local_error, FLATPAK_HTTP_ERROR, FLATPAK_HTTP_ERROR_NOT_CHANGED))\n        {\n          g_propagate_error (error, g_steal_pointer (&local_error));\n          return NULL;\n        }\n\n      g_clear_error (&local_error);\n    }\n\n  return g_steal_pointer (&index_cache);\n}\n\nstatic gboolean\nreplace_contents_compressed (GFile        *dest,\n                             GBytes       *contents,\n                             GCancellable *cancellable,\n                             GError      **error)\n{\n  g_autoptr(GZlibCompressor) compressor = NULL;\n  g_autoptr(GFileOutputStream) out = NULL;\n  g_autoptr(GOutputStream) out2 = NULL;\n\n  compressor = g_zlib_compressor_new (G_ZLIB_COMPRESSOR_FORMAT_GZIP, -1);\n  out = g_file_replace (dest, NULL, FALSE, G_FILE_CREATE_REPLACE_DESTINATION,\n                        NULL, error);\n  out2 = g_converter_output_stream_new (G_OUTPUT_STREAM (out), G_CONVERTER (compressor));\n  if (out == NULL)\n    return FALSE;\n\n  if (!g_output_stream_write_all (out2,\n                                  g_bytes_get_data (contents, NULL),\n                                  g_bytes_get_size (contents),\n                                  NULL,\n                                  cancellable, error))\n    return FALSE;\n\n  if (!g_output_stream_close (out2, cancellable, error))\n    return FALSE;\n\n  return TRUE;\n}\n\nstatic gboolean\nflatpak_dir_update_appstream_oci (FlatpakDir          *self,\n                                  const char          *remote,\n                                  const char          *arch,\n                                  gboolean            *out_changed,\n                                  FlatpakProgress     *progress,\n                                  GCancellable        *cancellable,\n                                  GError             **error)\n{\n  g_autoptr(GFile) arch_dir = NULL;\n  g_autoptr(GFile) lock_file = NULL;\n  g_auto(GLnxLockFile) lock = { 0, };\n  g_autoptr(GFile) index_cache = NULL;\n  g_autofree char *index_uri = NULL;\n  g_autoptr(GFile) timestamp_file = NULL;\n  g_autoptr(GFile) icons_dir = NULL;\n  glnx_autofd int icons_dfd = -1;\n  g_autoptr(GBytes) appstream = NULL;\n  g_autoptr(GFile) new_appstream_file = NULL;\n\n  arch_dir = flatpak_build_file (flatpak_dir_get_path (self),\n                                 \"appstream\", remote, arch, NULL);\n  if (g_mkdir_with_parents (flatpak_file_get_path_cached (arch_dir), 0755) != 0)\n    {\n      glnx_set_error_from_errno (error);\n      return FALSE;\n    }\n\n  lock_file = g_file_get_child (arch_dir, \"lock\");\n  if (!glnx_make_lock_file (AT_FDCWD, flatpak_file_get_path_cached (lock_file),\n                            LOCK_EX, &lock, error))\n    return FALSE;\n\n  index_cache = flatpak_dir_update_oci_index (self, remote, &index_uri, cancellable, error);\n  if (index_cache == NULL)\n    return FALSE;\n\n  timestamp_file = g_file_get_child (arch_dir, \".timestamp\");\n  if (check_destination_mtime (index_cache, timestamp_file, cancellable))\n    return TRUE;\n\n  icons_dir = g_file_get_child (arch_dir, \"icons\");\n  if (g_mkdir_with_parents (flatpak_file_get_path_cached (icons_dir), 0755) != 0)\n    {\n      glnx_set_error_from_errno (error);\n      return FALSE;\n    }\n\n  if (!glnx_opendirat (AT_FDCWD, flatpak_file_get_path_cached (icons_dir),\n                       FALSE, &icons_dfd, error))\n    return FALSE;\n\n  ensure_soup_session (self);\n\n  appstream = flatpak_oci_index_make_appstream (self->soup_session,\n                                                index_cache,\n                                                index_uri,\n                                                arch,\n                                                icons_dfd,\n                                                cancellable,\n                                                error);\n  if (appstream == NULL)\n    return FALSE;\n\n  new_appstream_file = g_file_get_child (arch_dir, \"appstream.xml.gz\");\n  if (!replace_contents_compressed (new_appstream_file, appstream, cancellable, error))\n    return FALSE;\n\n  if (!g_file_replace_contents (timestamp_file, \"\", 0, NULL, FALSE,\n                                G_FILE_CREATE_REPLACE_DESTINATION, NULL, NULL, error))\n    return FALSE;\n\n  if (out_changed)\n    *out_changed = TRUE;\n\n  return TRUE;\n}\n\ngboolean\nflatpak_dir_update_appstream (FlatpakDir          *self,\n                              const char          *remote,\n                              const char          *arch,\n                              gboolean            *out_changed,\n                              FlatpakProgress     *progress,\n                              GCancellable        *cancellable,\n                              GError             **error)\n{\n  g_autofree char *new_branch = NULL;\n  g_autofree char *old_branch = NULL;\n  const char *used_branch = NULL;\n  g_autofree char *new_checksum = NULL;\n  g_autoptr(GError) first_error = NULL;\n  g_autoptr(GError) second_error = NULL;\n  g_autoptr(FlatpakRemoteState) state = NULL;\n  g_autofree char *appstream_commit = NULL;\n  g_autofree char *subset = NULL;\n  g_autoptr(GFile) appstream_sideload_path = NULL;\n  const char *installation;\n  gboolean is_oci;\n\n  if (out_changed)\n    *out_changed = FALSE;\n\n  if (arch == NULL)\n    arch = flatpak_get_arch ();\n\n  subset = flatpak_dir_get_remote_subset (self, remote);\n\n  if (subset)\n    {\n      new_branch = g_strdup_printf (\"appstream2/%s-%s\", subset, arch);\n      old_branch = g_strdup_printf (\"appstream/%s-%s\", subset, arch);\n    }\n  else\n    {\n      new_branch = g_strdup_printf (\"appstream2/%s\", arch);\n      old_branch = g_strdup_printf (\"appstream/%s\", arch);\n    }\n\n  is_oci = flatpak_dir_get_remote_oci (self, remote);\n\n  state = flatpak_dir_get_remote_state_optional (self, remote, FALSE, cancellable, error);\n  if (state == NULL)\n    return FALSE;\n\n  used_branch = new_branch;\n  if (!is_oci)\n    {\n      if (!flatpak_dir_find_latest_rev (self, state, used_branch, NULL, &appstream_commit, NULL, &appstream_sideload_path, cancellable, &first_error))\n        {\n          used_branch = old_branch;\n          if (!flatpak_dir_find_latest_rev (self, state, used_branch, NULL, &appstream_commit, NULL, &appstream_sideload_path, cancellable, &second_error))\n            {\n              g_prefix_error (&first_error, \"Error updating appstream2: \");\n              g_prefix_error (&second_error, \"Error updating appstream: \");\n              g_propagate_prefixed_error (error, g_steal_pointer (&second_error), \"%s; \", first_error->message);\n              return FALSE;\n            }\n        }\n    }\n\n  if (flatpak_dir_use_system_helper (self, NULL))\n    {\n      g_auto(GLnxLockFile) child_repo_lock = { 0, };\n      g_autofree char *url = NULL;\n      g_autoptr(GFile) child_repo_file = NULL;\n      g_autofree char *child_repo_path = NULL;\n      gboolean gpg_verify_summary;\n      gboolean gpg_verify;\n\n      if (!ostree_repo_remote_get_url (self->repo,\n                                       state->remote_name,\n                                       &url,\n                                       error))\n        return FALSE;\n\n      if (!ostree_repo_remote_get_gpg_verify_summary (self->repo, state->remote_name,\n                                                      &gpg_verify_summary, error))\n        return FALSE;\n\n      if (!ostree_repo_remote_get_gpg_verify (self->repo, state->remote_name,\n                                              &gpg_verify, error))\n        return FALSE;\n\n      if (is_oci)\n        {\n          /* In the OCI case, we just ask the system helper do the network i/o, since\n           * there is no way to verify the index validity without actually downloading it.\n           * While we try to avoid network i/o as root, there's no hard line where doing\n           * network i/o as root is much worse than parsing the results of network i/o\n           * as root. A trusted, but unprivileged helper could be used to do the download\n           * if necessary.\n           */\n        }\n      else if (!gpg_verify_summary || !gpg_verify)\n        {\n          /* The remote is not gpg verified, so we don't want to allow installation via\n             a download in the home directory, as there is no way to verify you're not\n             injecting anything into the remote. However, in the case of a remote\n             configured to a local filesystem we can just let the system helper do\n             the installation, as it can then avoid network i/o and be certain the\n             data comes from the right place.  */\n          if (!g_str_has_prefix (url, \"file:\"))\n            return flatpak_fail_error (error, FLATPAK_ERROR_UNTRUSTED, _(\"Can't pull from untrusted non-gpg verified remote\"));\n        }\n      else\n        {\n          g_autoptr(OstreeRepo) child_repo = flatpak_dir_create_system_child_repo (self, &child_repo_lock, NULL, error);\n          if (child_repo == NULL)\n            return FALSE;\n\n          if (!flatpak_dir_pull (self, state, used_branch, appstream_commit, NULL, appstream_sideload_path, NULL, NULL,\n                                 child_repo, FLATPAK_PULL_FLAGS_NONE, 0,\n                                 progress, cancellable, error))\n            {\n              g_prefix_error (&first_error, \"Error updating appstream: \");\n              return FALSE;\n            }\n\n          if (!flatpak_repo_resolve_rev (child_repo, NULL, remote, used_branch, TRUE,\n                                         &new_checksum, cancellable, error))\n            return FALSE;\n\n          child_repo_file = g_object_ref (ostree_repo_get_path (child_repo));\n        }\n\n      if (child_repo_file)\n        child_repo_path = g_file_get_path (child_repo_file);\n\n      installation = flatpak_dir_get_id (self);\n\n      if (!flatpak_dir_system_helper_call_deploy_appstream (self,\n                                                            child_repo_path ? child_repo_path : \"\",\n                                                            FLATPAK_HELPER_DEPLOY_APPSTREAM_FLAGS_NONE,\n                                                            remote,\n                                                            arch,\n                                                            installation ? installation : \"\",\n                                                            cancellable,\n                                                            error))\n        return FALSE;\n\n      if (child_repo_file)\n        (void) flatpak_rm_rf (child_repo_file, NULL, NULL);\n\n      return TRUE;\n    }\n\n  if (is_oci)\n    {\n      return flatpak_dir_update_appstream_oci (self, remote, arch,\n                                               out_changed, progress, cancellable,\n                                               error);\n    }\n\n\n  if (!flatpak_dir_pull (self, state, used_branch, appstream_commit, NULL, appstream_sideload_path, NULL, NULL, NULL,\n                         FLATPAK_PULL_FLAGS_NONE, OSTREE_REPO_PULL_FLAGS_NONE, progress,\n                         cancellable, error))\n    {\n      g_prefix_error (&first_error, \"Error updating appstream: \");\n      return FALSE;\n    }\n\n  if (!flatpak_repo_resolve_rev (self->repo, NULL, remote, used_branch, TRUE,\n                                 &new_checksum, cancellable, error))\n    return FALSE;\n\n  return flatpak_dir_deploy_appstream (self,\n                                       remote,\n                                       arch,\n                                       out_changed,\n                                       cancellable,\n                                       error);\n}\n\n/* Get the configured collection-id for @remote_name, squashing empty strings into\n * %NULL. Return %TRUE if the ID was fetched successfully, or if it was unset or\n * empty. */\nstatic gboolean\nrepo_get_remote_collection_id (OstreeRepo *repo,\n                               const char *remote_name,\n                               char      **collection_id_out,\n                               GError    **error)\n{\n  if (collection_id_out != NULL)\n    {\n      if (!ostree_repo_get_remote_option (repo, remote_name, \"collection-id\",\n                                          NULL, collection_id_out, error))\n        return FALSE;\n      if (*collection_id_out != NULL && **collection_id_out == '\\0')\n        g_clear_pointer (collection_id_out, g_free);\n    }\n\n  return TRUE;\n}\n\n/* Get options for the OSTree pull operation which can be shared between\n * collection-based and normal pulls. Update @builder in place. */\nstatic void\nget_common_pull_options (GVariantBuilder     *builder,\n                         FlatpakRemoteState  *state,\n                         const char          *ref_to_fetch,\n                         const char          *token,\n                         const gchar * const *dirs_to_pull,\n                         const char          *current_local_checksum,\n                         gboolean             force_disable_deltas,\n                         OstreeRepoPullFlags  flags,\n                         FlatpakProgress     *progress)\n{\n  guint32 update_interval = 0;\n  GVariantBuilder hdr_builder;\n\n  if (state->summary_bytes && state->summary_sig_bytes)\n    {\n      g_variant_builder_add (builder, \"{s@v}\", \"summary-bytes\",\n                             g_variant_new_variant (g_variant_new_from_bytes (G_VARIANT_TYPE (\"ay\"), state->summary_bytes, TRUE)));\n      g_variant_builder_add (builder, \"{s@v}\", \"summary-sig-bytes\",\n                             g_variant_new_variant (g_variant_new_from_bytes (G_VARIANT_TYPE (\"ay\"), state->summary_sig_bytes, TRUE)));\n    }\n\n  if (dirs_to_pull)\n    {\n      g_variant_builder_add (builder, \"{s@v}\", \"subdirs\",\n                             g_variant_new_variant (g_variant_new_strv ((const char * const *) dirs_to_pull, -1)));\n      force_disable_deltas = TRUE;\n    }\n\n  if (force_disable_deltas)\n    {\n      g_variant_builder_add (builder, \"{s@v}\", \"disable-static-deltas\",\n                             g_variant_new_variant (g_variant_new_boolean (TRUE)));\n    }\n\n  g_variant_builder_add (builder, \"{s@v}\", \"inherit-transaction\",\n                         g_variant_new_variant (g_variant_new_boolean (TRUE)));\n\n  g_variant_builder_add (builder, \"{s@v}\", \"flags\",\n                         g_variant_new_variant (g_variant_new_int32 (flags)));\n\n\n  g_variant_builder_init (&hdr_builder, G_VARIANT_TYPE (\"a(ss)\"));\n  g_variant_builder_add (&hdr_builder, \"(ss)\", \"Flatpak-Ref\", ref_to_fetch);\n  if (token)\n    {\n      g_autofree char *bearer_token = g_strdup_printf (\"Bearer %s\", token);\n      g_variant_builder_add (&hdr_builder, \"(ss)\", \"Authorization\", bearer_token);\n    }\n  if (current_local_checksum)\n    g_variant_builder_add (&hdr_builder, \"(ss)\", \"Flatpak-Upgrade-From\", current_local_checksum);\n  g_variant_builder_add (builder, \"{s@v}\", \"http-headers\",\n                         g_variant_new_variant (g_variant_builder_end (&hdr_builder)));\n  g_variant_builder_add (builder, \"{s@v}\", \"append-user-agent\",\n                         g_variant_new_variant (g_variant_new_string (\"flatpak/\" PACKAGE_VERSION)));\n\n  update_interval = flatpak_progress_get_update_interval (progress);\n\n  g_variant_builder_add (builder, \"{s@v}\", \"update-frequency\",\n                         g_variant_new_variant (g_variant_new_uint32 (update_interval)));\n}\n\nstatic gboolean\ntranslate_ostree_repo_pull_errors (GError **error)\n{\n  if (*error)\n    {\n      if (strstr ((*error)->message, \"min-free-space-size\") ||\n          strstr ((*error)->message, \"min-free-space-percent\"))\n        {\n          (*error)->domain = FLATPAK_ERROR;\n          (*error)->code = FLATPAK_ERROR_OUT_OF_SPACE;\n        }\n    }\n\n  return FALSE;\n}\n\nstatic gboolean\nrepo_pull (OstreeRepo                           *self,\n           FlatpakRemoteState                   *state,\n           const char                          **dirs_to_pull,\n           const char                           *ref_to_fetch,\n           const char                           *rev_to_fetch, /* (nullable) */\n           GFile                                *sideload_repo,\n           const char                           *token,\n           FlatpakPullFlags                      flatpak_flags,\n           OstreeRepoPullFlags                   flags,\n           FlatpakProgress                      *progress,\n           GCancellable                         *cancellable,\n           GError                              **error)\n{\n  gboolean force_disable_deltas = (flatpak_flags & FLATPAK_PULL_FLAGS_NO_STATIC_DELTAS) != 0;\n  g_autofree char *current_checksum = NULL;\n  g_autoptr(GVariant) old_commit = NULL;\n  g_autoptr(GVariant) new_commit = NULL;\n  const char *revs_to_fetch[2];\n  g_autoptr(GError) dummy_error = NULL;\n  GVariantBuilder builder;\n  g_autoptr(GVariant) options = NULL;\n  const char *refs_to_fetch[2];\n  g_autofree char *sideload_url = NULL;\n\n  /* The ostree fetcher asserts if error is NULL */\n  if (error == NULL)\n    error = &dummy_error;\n\n  /* We always want this on for every type of pull */\n  flags |= OSTREE_REPO_PULL_FLAGS_BAREUSERONLY_FILES;\n\n  if (!flatpak_repo_resolve_rev (self, NULL, state->remote_name, ref_to_fetch, TRUE,\n                                 &current_checksum, cancellable, error))\n    return FALSE;\n\n  if (current_checksum != NULL &&\n      !ostree_repo_load_commit (self, current_checksum, &old_commit, NULL, error))\n    return FALSE;\n\n  /* Pull options */\n  g_variant_builder_init (&builder, G_VARIANT_TYPE (\"a{sv}\"));\n  get_common_pull_options (&builder, state, ref_to_fetch, token, dirs_to_pull, current_checksum,\n                           force_disable_deltas, flags, progress);\n\n  if (sideload_repo)\n    {\n      GVariantBuilder colref_builder;\n\n      sideload_url = g_file_get_uri (sideload_repo);\n\n      g_debug (\"Sideloading %s from %s in pull\", ref_to_fetch, sideload_url);\n\n      g_assert (state->collection_id != NULL);\n\n      g_variant_builder_init (&colref_builder, G_VARIANT_TYPE (\"a(sss)\"));\n      g_variant_builder_add (&colref_builder, \"(sss)\", state->collection_id, ref_to_fetch, rev_to_fetch);\n\n      g_variant_builder_add (&builder, \"{s@v}\", \"collection-refs\",\n                             g_variant_new_variant (g_variant_builder_end (&colref_builder)));\n      g_variant_builder_add (&builder, \"{s@v}\", \"override-remote-name\",\n                             g_variant_new_variant (g_variant_new_string (state->remote_name)));\n    }\n  else\n    {\n      refs_to_fetch[0] = ref_to_fetch;\n      refs_to_fetch[1] = NULL;\n      g_variant_builder_add (&builder, \"{s@v}\", \"refs\",\n                             g_variant_new_variant (g_variant_new_strv ((const char * const *) refs_to_fetch, -1)));\n\n      revs_to_fetch[0] = rev_to_fetch;\n      revs_to_fetch[1] = NULL;\n      g_variant_builder_add (&builder, \"{s@v}\", \"override-commit-ids\",\n                             g_variant_new_variant (g_variant_new_strv ((const char * const *) revs_to_fetch, -1)));\n\n\n      if (state->sideload_repos->len > 0)\n        {\n          GVariantBuilder localcache_repos_builder;\n\n          g_variant_builder_init (&localcache_repos_builder, G_VARIANT_TYPE (\"as\"));\n          for (int i = 0; i < state->sideload_repos->len; i++)\n            {\n              FlatpakSideloadState *ss = g_ptr_array_index (state->sideload_repos, i);\n              GFile *sideload_path = ostree_repo_get_path (ss->repo);\n\n              g_variant_builder_add (&localcache_repos_builder, \"s\",\n                                     flatpak_file_get_path_cached (sideload_path));\n            }\n          g_variant_builder_add (&builder, \"{s@v}\", \"localcache-repos\",\n                                 g_variant_new_variant (g_variant_builder_end (&localcache_repos_builder)));\n        }\n    }\n\n  options = g_variant_ref_sink (g_variant_builder_end (&builder));\n\n  {\n    g_auto(FlatpakMainContext) context = FLATKPAK_MAIN_CONTEXT_INIT;\n    flatpak_progress_init_main_context (progress, &context);\n\n    if (!ostree_repo_pull_with_options (self,\n                                        sideload_url ? sideload_url : state->remote_name,\n                                        options, context.ostree_progress, cancellable, error))\n      return translate_ostree_repo_pull_errors (error);\n  }\n\n  if (old_commit &&\n      (flatpak_flags & FLATPAK_PULL_FLAGS_ALLOW_DOWNGRADE) == 0)\n    {\n      guint64 old_timestamp;\n      guint64 new_timestamp;\n\n      if (!ostree_repo_load_commit (self, rev_to_fetch, &new_commit, NULL, error))\n        return FALSE;\n\n      old_timestamp = ostree_commit_get_timestamp (old_commit);\n      new_timestamp = ostree_commit_get_timestamp (new_commit);\n\n      if (new_timestamp < old_timestamp)\n        return flatpak_fail_error (error, FLATPAK_ERROR_DOWNGRADE, \"Update is older than current version\");\n    }\n\n  return TRUE;\n}\n\nstatic void\nensure_soup_session (FlatpakDir *self)\n{\n  if (g_once_init_enter (&self->soup_session))\n    {\n      SoupSession *soup_session;\n\n      soup_session = flatpak_create_soup_session (PACKAGE_STRING);\n\n      g_once_init_leave (&self->soup_session, soup_session);\n    }\n}\n\nstatic void\nextra_data_progress_report (guint64  downloaded_bytes,\n                            gpointer user_data)\n{\n  FlatpakProgress *progress = FLATPAK_PROGRESS (user_data);\n\n  flatpak_progress_update_extra_data (progress, downloaded_bytes);\n}\n\nstatic void\ncompute_extra_data_download_size (GVariant *commitv,\n                                  guint64 *out_n_extra_data,\n                                  guint64 *out_total_download_size)\n{\n  guint64 i;\n  guint64 n_extra_data = 0;\n  guint64 total_download_size = 0;\n  g_autoptr(GVariant) extra_data_sources = NULL;\n\n  extra_data_sources = flatpak_commit_get_extra_data_sources (commitv, NULL);\n  if (extra_data_sources != NULL)\n    {\n      n_extra_data = g_variant_n_children (extra_data_sources);\n      for (i = 0; i < n_extra_data; i++)\n        {\n          guint64 download_size;\n          flatpak_repo_parse_extra_data_sources (extra_data_sources, i,\n                                                 NULL,\n                                                 &download_size,\n                                                 NULL,\n                                                 NULL,\n                                                 NULL);\n          total_download_size += download_size;\n        }\n    }\n\n  *out_n_extra_data = n_extra_data;\n  *out_total_download_size = total_download_size;\n}\n\nstatic gboolean\nflatpak_dir_setup_extra_data (FlatpakDir                           *self,\n                              FlatpakRemoteState                   *state,\n                              OstreeRepo                           *repo,\n                              const char                           *ref,\n                              const char                           *rev,\n                              GFile                                *sideload_repo,\n                              const char                           *token,\n                              FlatpakPullFlags                      flatpak_flags,\n                              FlatpakProgress                      *progress,\n                              GCancellable                         *cancellable,\n                              GError                              **error)\n{\n  guint64 n_extra_data = 0;\n  guint64 total_download_size = 0;\n\n  /* ostree-metadata and appstreams never have extra data, so ignore those */\n  if (g_str_has_prefix (ref, \"app/\") || g_str_has_prefix (ref, \"runtime/\"))\n    {\n      g_autofree char *summary_checksum = NULL;\n      GVariant *summary;\n\n      /* Version 1 added extra data details, so we can rely on it\n       * either being in the sparse cache or no extra data.  However,\n       * it only applies to the commit the summary contains, so verify\n       * that too.\n       */\n      summary = get_summary_for_ref (state, ref);\n      if (summary != NULL &&\n          flatpak_summary_lookup_ref (summary, NULL, ref, &summary_checksum, NULL) &&\n          g_strcmp0 (rev, summary_checksum) == 0 &&\n          flatpak_remote_state_get_cache_version (state) >= 1)\n        {\n          VarMetadataRef metadata;\n          VarVariantRef res;\n\n          if (flatpak_remote_state_lookup_sparse_cache (state, ref, &metadata, NULL) &&\n              var_metadata_lookup (metadata, FLATPAK_SPARSE_CACHE_KEY_EXTRA_DATA_SIZE, NULL, &res) &&\n              var_variant_is_type (res, VAR_EXTRA_DATA_SIZE_TYPEFORMAT))\n            {\n              VarExtraDataSizeRef eds = var_extra_data_size_from_variant (res);\n              n_extra_data = var_extra_data_size_get_n_extra_data (eds);\n              total_download_size = var_extra_data_size_get_total_size (eds);\n            }\n        }\n      else\n        {\n          /* No summary/cache or old cache version, download commit and get size from there */\n          g_autoptr(GVariant) commitv = flatpak_remote_state_load_ref_commit (state, self, ref, rev, token, NULL, cancellable, error);\n          if (commitv == NULL)\n            return FALSE;\n\n          compute_extra_data_download_size (commitv, &n_extra_data, &total_download_size);\n        }\n    }\n\n  if (n_extra_data > 0 &&\n      (flatpak_flags & FLATPAK_PULL_FLAGS_DOWNLOAD_EXTRA_DATA) == 0)\n    return flatpak_fail_error (error, FLATPAK_ERROR_UNTRUSTED, _(\"Extra data not supported for non-gpg-verified local system installs\"));\n\n  flatpak_progress_init_extra_data (progress, n_extra_data, total_download_size);\n\n  return TRUE;\n}\n\nstatic gboolean\nflatpak_dir_pull_extra_data (FlatpakDir          *self,\n                             OstreeRepo          *repo,\n                             const char          *repository,\n                             const char          *ref,\n                             const char          *rev,\n                             FlatpakPullFlags     flatpak_flags,\n                             FlatpakProgress     *progress,\n                             GCancellable        *cancellable,\n                             GError             **error)\n{\n  g_autoptr(GVariant) extra_data_sources = NULL;\n  g_autoptr(GVariant) detached_metadata = NULL;\n  g_auto(GVariantDict) new_metadata_dict = FLATPAK_VARIANT_DICT_INITIALIZER;\n  g_autoptr(GVariantBuilder) extra_data_builder = NULL;\n  g_autoptr(GVariant) new_detached_metadata = NULL;\n  g_autoptr(GVariant) extra_data = NULL;\n  g_autoptr(GFile) base_dir = NULL;\n  int i;\n  gsize n_extra_data;\n\n  extra_data_sources = flatpak_repo_get_extra_data_sources (repo, rev, cancellable, NULL);\n  if (extra_data_sources == NULL)\n    return TRUE;\n\n  n_extra_data = g_variant_n_children (extra_data_sources);\n  if (n_extra_data == 0)\n    return TRUE;\n\n  if ((flatpak_flags & FLATPAK_PULL_FLAGS_DOWNLOAD_EXTRA_DATA) == 0)\n    return flatpak_fail_error (error, FLATPAK_ERROR_UNTRUSTED, _(\"Extra data not supported for non-gpg-verified local system installs\"));\n\n  extra_data_builder = g_variant_builder_new (G_VARIANT_TYPE (\"a(ayay)\"));\n\n  /* Other fields were already set in flatpak_dir_setup_extra_data() */\n  flatpak_progress_start_extra_data (progress);\n\n  base_dir = flatpak_get_user_base_dir_location ();\n\n  for (i = 0; i < n_extra_data; i++)\n    {\n      const char *extra_data_uri = NULL;\n      g_autofree char *extra_data_sha256 = NULL;\n      const char *extra_data_name = NULL;\n      guint64 download_size;\n      guint64 installed_size;\n      g_autofree char *sha256 = NULL;\n      const guchar *sha256_bytes;\n      g_autoptr(GBytes) bytes = NULL;\n      g_autoptr(GFile) extra_local_file = NULL;\n\n      flatpak_repo_parse_extra_data_sources (extra_data_sources, i,\n                                             &extra_data_name,\n                                             &download_size,\n                                             &installed_size,\n                                             &sha256_bytes,\n                                             &extra_data_uri);\n\n      if (sha256_bytes == NULL)\n        return flatpak_fail_error (error, FLATPAK_ERROR_INVALID_DATA, _(\"Invalid checksum for extra data uri %s\"), extra_data_uri);\n\n      extra_data_sha256 = ostree_checksum_from_bytes (sha256_bytes);\n\n      if (*extra_data_name == 0)\n        return flatpak_fail_error (error, FLATPAK_ERROR_INVALID_DATA, _(\"Empty name for extra data uri %s\"), extra_data_uri);\n\n      /* Don't allow file uris here as that could read local files based on remote data */\n      if (!g_str_has_prefix (extra_data_uri, \"http:\") &&\n          !g_str_has_prefix (extra_data_uri, \"https:\"))\n        {\n          flatpak_progress_reset_extra_data (progress);\n          return flatpak_fail_error (error, FLATPAK_ERROR_INVALID_DATA, _(\"Unsupported extra data uri %s\"), extra_data_uri);\n        }\n\n      /* TODO: Download to disk to support resumed downloads on error */\n\n      extra_local_file = flatpak_build_file (base_dir, \"extra-data\", extra_data_sha256, extra_data_name, NULL);\n      if (g_file_query_exists (extra_local_file, cancellable))\n        {\n          g_debug (\"Loading extra-data from local file %s\", flatpak_file_get_path_cached (extra_local_file));\n          gsize extra_local_size;\n          g_autofree char *extra_local_contents = NULL;\n          g_autoptr(GError) my_error = NULL;\n\n          if (!g_file_load_contents (extra_local_file, cancellable, &extra_local_contents, &extra_local_size, NULL, &my_error))\n            return flatpak_fail_error (error, FLATPAK_ERROR_INVALID_DATA, _(\"Failed to load local extra-data %s: %s\"),\n                                       flatpak_file_get_path_cached (extra_local_file), my_error->message);\n          if (extra_local_size != download_size)\n            return flatpak_fail_error (error, FLATPAK_ERROR_INVALID_DATA, _(\"Wrong size for extra-data %s\"), flatpak_file_get_path_cached (extra_local_file));\n\n          bytes = g_bytes_new (extra_local_contents, extra_local_size);\n        }\n      else\n        {\n          ensure_soup_session (self);\n          bytes = flatpak_load_uri (self->soup_session, extra_data_uri, 0, NULL,\n                                    extra_data_progress_report, progress, NULL,\n                                    cancellable, error);\n        }\n\n      if (bytes == NULL)\n        {\n          flatpak_progress_reset_extra_data (progress);\n          g_prefix_error (error, _(\"While downloading %s: \"), extra_data_uri);\n          return FALSE;\n        }\n\n      if (g_bytes_get_size (bytes) != download_size)\n        {\n          flatpak_progress_reset_extra_data (progress);\n          return flatpak_fail_error (error, FLATPAK_ERROR_INVALID_DATA, _(\"Wrong size for extra data %s\"), extra_data_uri);\n        }\n\n      flatpak_progress_complete_extra_data_download (progress, download_size);\n\n      sha256 = g_compute_checksum_for_bytes (G_CHECKSUM_SHA256, bytes);\n      if (strcmp (sha256, extra_data_sha256) != 0)\n        {\n          flatpak_progress_reset_extra_data (progress);\n          return flatpak_fail_error (error, FLATPAK_ERROR_INVALID_DATA, _(\"Invalid checksum for extra data %s\"), extra_data_uri);\n        }\n\n      g_variant_builder_add (extra_data_builder,\n                             \"(^ay@ay)\",\n                             extra_data_name,\n                             g_variant_new_from_bytes (G_VARIANT_TYPE (\"ay\"), bytes, TRUE));\n    }\n\n  extra_data = g_variant_ref_sink (g_variant_builder_end (extra_data_builder));\n\n  flatpak_progress_reset_extra_data (progress);\n\n  if (!ostree_repo_read_commit_detached_metadata (repo, rev, &detached_metadata,\n                                                  cancellable, error))\n    return FALSE;\n\n  g_variant_dict_init (&new_metadata_dict, detached_metadata);\n  g_variant_dict_insert_value (&new_metadata_dict, \"xa.extra-data\", extra_data);\n  new_detached_metadata = g_variant_ref_sink (g_variant_dict_end (&new_metadata_dict));\n\n  /* There is a commitmeta size limit when pulling, so we have to side-load it\n     when installing in the system repo */\n  if (flatpak_flags & FLATPAK_PULL_FLAGS_SIDELOAD_EXTRA_DATA)\n    {\n      int dfd =  ostree_repo_get_dfd (repo);\n      g_autoptr(GVariant) normalized = g_variant_get_normal_form (new_detached_metadata);\n      gsize normalized_size = g_variant_get_size (normalized);\n      const guint8 *data = g_variant_get_data (normalized);\n      g_autofree char *filename = NULL;\n\n      filename = g_strconcat (rev, \".commitmeta\", NULL);\n      if (!glnx_file_replace_contents_at (dfd, filename,\n                                          data, normalized_size,\n                                          0, cancellable, error))\n        {\n          g_prefix_error (error, \"Unable to write sideloaded detached metadata: \");\n          return FALSE;\n        }\n    }\n  else\n    {\n      if (!ostree_repo_write_commit_detached_metadata (repo, rev, new_detached_metadata,\n                                                       cancellable, error))\n        return FALSE;\n    }\n\n  return TRUE;\n}\n\nstatic void\noci_pull_progress_cb (guint64 total_size, guint64 pulled_size,\n                      guint32 n_layers, guint32 pulled_layers,\n                      gpointer data)\n{\n  FlatpakProgress *progress = data;\n\n  flatpak_progress_update_oci_pull (progress, total_size, pulled_size, n_layers, pulled_layers);\n}\n\nstatic gboolean\nflatpak_dir_mirror_oci (FlatpakDir          *self,\n                        FlatpakOciRegistry  *dst_registry,\n                        FlatpakRemoteState  *state,\n                        const char          *ref,\n                        const char          *opt_rev,\n                        const char          *skip_if_current_is,\n                        const char          *token,\n                        FlatpakProgress     *progress,\n                        GCancellable        *cancellable,\n                        GError             **error)\n{\n  g_autoptr(FlatpakOciRegistry) registry = NULL;\n  g_autofree char *oci_digest = NULL;\n  g_autofree char *latest_rev = NULL;\n  VarRefInfoRef latest_rev_info;\n  VarMetadataRef metadata;\n  const char *oci_repository = NULL;\n  const char *delta_url = NULL;\n  const char *rev;\n  gboolean res;\n\n  /* We use the summary so that we can reuse any cached json */\n  if (!flatpak_remote_state_lookup_ref (state, ref, &latest_rev, NULL, &latest_rev_info, NULL, error))\n    return FALSE;\n  if (latest_rev == NULL)\n    return flatpak_fail_error (error, FLATPAK_ERROR_REF_NOT_FOUND,\n                               _(\"Couldn't find latest checksum for ref %s in remote %s\"),\n                               ref, state->remote_name);\n\n  rev = opt_rev != NULL ? opt_rev : latest_rev;\n\n  if (skip_if_current_is != NULL && strcmp (rev, skip_if_current_is) == 0)\n    {\n      return flatpak_fail_error (error, FLATPAK_ERROR_ALREADY_INSTALLED,\n                                 _(\"%s commit %s already installed\"),\n                                 ref, rev);\n    }\n\n  metadata = var_ref_info_get_metadata (latest_rev_info);\n  oci_repository = var_metadata_lookup_string (metadata, \"xa.oci-repository\", NULL);\n  delta_url = var_metadata_lookup_string (metadata, \"xa.delta-url\", NULL);\n\n  oci_digest = g_strconcat (\"sha256:\", rev, NULL);\n\n  registry = flatpak_remote_state_new_oci_registry (state, token, cancellable, error);\n  if (registry == NULL)\n    return FALSE;\n\n  flatpak_progress_start_oci_pull (progress);\n\n  g_debug (\"Mirroring OCI image %s\", oci_digest);\n\n  res = flatpak_mirror_image_from_oci (dst_registry, registry, oci_repository, oci_digest, state->remote_name, ref, delta_url, self->repo, oci_pull_progress_cb,\n                                       progress, cancellable, error);\n\n  if (!res)\n    return FALSE;\n\n  return TRUE;\n}\n\nstatic gboolean\nflatpak_dir_pull_oci (FlatpakDir          *self,\n                      FlatpakRemoteState  *state,\n                      const char          *ref,\n                      const char          *opt_rev,\n                      OstreeRepo          *repo,\n                      FlatpakPullFlags     flatpak_flags,\n                      OstreeRepoPullFlags  flags,\n                      const char          *token,\n                      FlatpakProgress     *progress,\n                      GCancellable        *cancellable,\n                      GError             **error)\n{\n  g_autoptr(FlatpakOciRegistry) registry = NULL;\n  g_autoptr(FlatpakOciVersioned) versioned = NULL;\n  g_autoptr(FlatpakOciImage) image_config = NULL;\n  g_autofree char *full_ref = NULL;\n  const char *oci_repository = NULL;\n  const char *delta_url = NULL;\n  g_autofree char *oci_digest = NULL;\n  g_autofree char *checksum = NULL;\n  VarRefInfoRef latest_rev_info;\n  g_autofree char *latest_alt_commit = NULL;\n  VarMetadataRef metadata;\n  g_autofree char *latest_rev = NULL;\n  G_GNUC_UNUSED g_autofree char *latest_commit =\n    flatpak_dir_read_latest (self, state->remote_name, ref, &latest_alt_commit, cancellable, NULL);\n  g_autofree char *name = NULL;\n\n  /* We use the summary so that we can reuse any cached json */\n  if (!flatpak_remote_state_lookup_ref (state, ref, &latest_rev, NULL, &latest_rev_info, NULL, error))\n    return FALSE;\n  if (latest_rev == NULL)\n    return flatpak_fail_error (error, FLATPAK_ERROR_REF_NOT_FOUND,\n                               _(\"Couldn't find latest checksum for ref %s in remote %s\"),\n                               ref, state->remote_name);\n\n  metadata = var_ref_info_get_metadata (latest_rev_info);\n  oci_repository = var_metadata_lookup_string (metadata, \"xa.oci-repository\", NULL);\n  delta_url = var_metadata_lookup_string (metadata, \"xa.delta-url\", NULL);\n\n  oci_digest = g_strconcat (\"sha256:\", opt_rev != NULL ? opt_rev : latest_rev, NULL);\n\n  /* Short circuit if we've already got this commit */\n  if (latest_alt_commit != NULL && strcmp (oci_digest + strlen (\"sha256:\"), latest_alt_commit) == 0)\n    return TRUE;\n\n  registry = flatpak_remote_state_new_oci_registry (state, token, cancellable, error);\n  if (registry == NULL)\n    return FALSE;\n\n  versioned = flatpak_oci_registry_load_versioned (registry, oci_repository, oci_digest,\n                                                   NULL, NULL, cancellable, error);\n  if (versioned == NULL)\n    return FALSE;\n\n  if (!FLATPAK_IS_OCI_MANIFEST (versioned))\n    return flatpak_fail_error (error, FLATPAK_ERROR_INVALID_DATA, _(\"Image is not a manifest\"));\n\n  image_config = flatpak_oci_registry_load_image_config (registry, oci_repository,\n                                                         FLATPAK_OCI_MANIFEST (versioned)->config.digest,\n                                                         (const char **)FLATPAK_OCI_MANIFEST (versioned)->config.urls,\n                                                         NULL, cancellable, error);\n  if (image_config == NULL)\n    return FALSE;\n\n  full_ref = g_strdup_printf (\"%s:%s\", state->remote_name, ref);\n\n  if (repo == NULL)\n    repo = self->repo;\n\n  flatpak_progress_start_oci_pull (progress);\n\n  g_debug (\"Pulling OCI image %s\", oci_digest);\n\n  checksum = flatpak_pull_from_oci (repo, registry, oci_repository, oci_digest, delta_url, FLATPAK_OCI_MANIFEST (versioned), image_config,\n                                    state->remote_name, ref, flatpak_flags, oci_pull_progress_cb, progress, cancellable, error);\n\n  if (checksum == NULL)\n    return FALSE;\n\n  g_debug (\"Imported OCI image as checksum %s\", checksum);\n\n  if (repo == self->repo)\n    name = flatpak_dir_get_name (self);\n  else\n    {\n      GFile *file = ostree_repo_get_path (repo);\n      name = g_file_get_path (file);\n    }\n\n  (flatpak_dir_log) (self, __FILE__, __LINE__, __FUNCTION__, name,\n                     \"pull oci\", flatpak_oci_registry_get_uri (registry), ref, NULL, NULL, NULL,\n                     \"Pulled %s from %s\", ref, flatpak_oci_registry_get_uri (registry));\n\n  return TRUE;\n}\n\ngboolean\nflatpak_dir_pull (FlatpakDir                           *self,\n                  FlatpakRemoteState                   *state,\n                  const char                           *ref,\n                  const char                           *opt_rev,\n                  const char                          **subpaths,\n                  GFile                                *sideload_repo,\n                  GBytes                               *require_metadata,\n                  const char                           *token,\n                  OstreeRepo                           *repo,\n                  FlatpakPullFlags                      flatpak_flags,\n                  OstreeRepoPullFlags                   flags,\n                  FlatpakProgress                      *progress,\n                  GCancellable                         *cancellable,\n                  GError                              **error)\n{\n  gboolean ret = FALSE;\n  g_autofree char *rev = NULL;\n  g_autofree char *url = NULL;\n  g_autoptr(GPtrArray) subdirs_arg = NULL;\n  g_auto(GLnxLockFile) lock = { 0, };\n  g_autofree char *name = NULL;\n  g_autofree char *current_checksum = NULL;\n\n  if (!flatpak_dir_ensure_repo (self, cancellable, error))\n    return FALSE;\n\n  /* Keep a shared repo lock to avoid prunes removing objects we're relying on\n   * while we do the pull. There are two cases we protect against. 1) objects we\n   * need but that we already decided are locally available could be removed,\n   * and 2) during the transaction commit objects that don't yet have a ref to\n   * them could be considered unreachable.\n   */\n  if (repo == NULL && !flatpak_dir_repo_lock (self, &lock, LOCK_SH, cancellable, error))\n    return FALSE;\n\n  if (flatpak_dir_get_remote_oci (self, state->remote_name))\n    return flatpak_dir_pull_oci (self, state, ref, opt_rev, repo, flatpak_flags,\n                                 flags, token, progress, cancellable, error);\n\n  if (!ostree_repo_remote_get_url (self->repo,\n                                   state->remote_name,\n                                   &url,\n                                   error))\n    return FALSE;\n\n  if (*url == 0)\n    return TRUE; /* Empty url, silently disables updates */\n\n  /* We get the rev ahead of time so that we know it for looking up e.g. extra-data\n     and to make sure we're atomically using a single rev if we happen to do multiple\n     pulls (e.g. with subpaths) */\n  if (opt_rev != NULL)\n    {\n      rev = g_strdup (opt_rev);\n    }\n  else\n    {\n      flatpak_remote_state_lookup_ref (state, ref, &rev, NULL, NULL, NULL, error);\n      if (rev == NULL && error != NULL && *error == NULL)\n        flatpak_fail_error (error, FLATPAK_ERROR_REF_NOT_FOUND, _(\"Couldn't find latest checksum for ref %s in remote %s\"),\n                            ref, state->remote_name);\n\n      if (rev == NULL)\n        {\n          g_assert (error == NULL || *error != NULL);\n          return FALSE;\n        }\n    }\n\n  g_debug (\"%s: Using commit %s for pull of ref %s from remote %s%s%s\",\n           G_STRFUNC, rev, ref, state->remote_name,\n           sideload_repo ? \"sideloaded from \" : \"\",\n           sideload_repo ? flatpak_file_get_path_cached (sideload_repo) : \"\"\n           );\n\n  if (repo == NULL)\n    repo = self->repo;\n\n  /* Past this we must use goto out, so we clean up console and\n     abort the transaction on error */\n\n  if (subpaths != NULL && subpaths[0] != NULL)\n    {\n      subdirs_arg = g_ptr_array_new_with_free_func (g_free);\n      int i;\n      g_ptr_array_add (subdirs_arg, g_strdup (\"/metadata\"));\n      for (i = 0; subpaths[i] != NULL; i++)\n        g_ptr_array_add (subdirs_arg,\n                         g_build_filename (\"/files\", subpaths[i], NULL));\n      g_ptr_array_add (subdirs_arg, NULL);\n    }\n\n  /* Setup extra data information before starting to pull, so we can have precise\n   * progress reports */\n  if (!flatpak_dir_setup_extra_data (self, state, repo,\n                                     ref, rev, sideload_repo, token,\n                                     flatpak_flags,\n                                     progress,\n                                     cancellable,\n                                     error))\n    goto out;\n\n  if (!ostree_repo_prepare_transaction (repo, NULL, cancellable, error))\n    goto out;\n\n  flatpak_repo_resolve_rev (repo, NULL, state->remote_name, ref, TRUE,\n                            &current_checksum, NULL, NULL);\n\n  if (!repo_pull (repo, state,\n                  subdirs_arg ? (const char **) subdirs_arg->pdata : NULL,\n                  ref, rev, sideload_repo, token, flatpak_flags, flags,\n                  progress,\n                  cancellable, error))\n    {\n      g_prefix_error (error, _(\"While pulling %s from remote %s: \"), ref, state->remote_name);\n      goto out;\n    }\n\n\n  if (require_metadata)\n    {\n      g_autoptr(GVariant) commit_data = NULL;\n      if (!ostree_repo_load_commit (repo, rev, &commit_data, NULL, error) ||\n          !validate_commit_metadata (commit_data, ref, (const char *)g_bytes_get_data (require_metadata, NULL), TRUE, error))\n        return FALSE;\n    }\n\n  if (!flatpak_dir_pull_extra_data (self, repo,\n                                    state->remote_name,\n                                    ref, rev,\n                                    flatpak_flags,\n                                    progress,\n                                    cancellable,\n                                    error))\n    goto out;\n\n\n  if (!ostree_repo_commit_transaction (repo, NULL, cancellable, error))\n    goto out;\n\n  ret = TRUE;\n\n  if (repo == self->repo)\n    name = flatpak_dir_get_name (self);\n  else\n    {\n      GFile *file = ostree_repo_get_path (repo);\n      name = g_file_get_path (file);\n    }\n\n  (flatpak_dir_log) (self, __FILE__, __LINE__, __FUNCTION__, name,\n                     \"pull\", state->remote_name, ref, rev, current_checksum, NULL,\n                     \"Pulled %s from %s\", ref, state->remote_name);\n\nout:\n  if (!ret)\n    {\n      ostree_repo_abort_transaction (repo, cancellable, NULL);\n      g_assert (error == NULL || *error != NULL);\n    }\n\n  return ret;\n}\n\nstatic gboolean\nrepo_pull_local_untrusted (FlatpakDir          *self,\n                           OstreeRepo          *repo,\n                           const char          *remote_name,\n                           const char          *url,\n                           const char         **dirs_to_pull,\n                           const char          *ref,\n                           const char          *checksum,\n                           FlatpakProgress     *progress,\n                           GCancellable        *cancellable,\n                           GError             **error)\n{\n  /* The latter flag was introduced in https://github.com/ostreedev/ostree/pull/926 */\n  const OstreeRepoPullFlags flags = OSTREE_REPO_PULL_FLAGS_UNTRUSTED | OSTREE_REPO_PULL_FLAGS_BAREUSERONLY_FILES;\n  GVariantBuilder builder;\n  g_autoptr(GVariant) options = NULL;\n  gboolean res;\n  g_variant_builder_init (&builder, G_VARIANT_TYPE (\"a{sv}\"));\n  const char *refs[2] = { NULL, NULL };\n  const char *commits[2] = { NULL, NULL };\n  g_autoptr(GError) dummy_error = NULL;\n  g_auto(FlatpakMainContext) context = FLATKPAK_MAIN_CONTEXT_INIT;\n\n  /* The ostree fetcher asserts if error is NULL */\n  if (error == NULL)\n    error = &dummy_error;\n\n  refs[0] = ref;\n  commits[0] = checksum;\n\n  g_variant_builder_add (&builder, \"{s@v}\", \"refs\",\n                         g_variant_new_variant (g_variant_new_strv ((const char * const *) refs, -1)));\n  g_variant_builder_add (&builder, \"{s@v}\", \"override-commit-ids\",\n                         g_variant_new_variant (g_variant_new_strv ((const char * const *) commits, -1)));\n\n  g_variant_builder_add (&builder, \"{s@v}\", \"flags\",\n                         g_variant_new_variant (g_variant_new_int32 (flags)));\n  g_variant_builder_add (&builder, \"{s@v}\", \"override-remote-name\",\n                         g_variant_new_variant (g_variant_new_string (remote_name)));\n  g_variant_builder_add (&builder, \"{s@v}\", \"gpg-verify\",\n                         g_variant_new_variant (g_variant_new_boolean (TRUE)));\n  g_variant_builder_add (&builder, \"{s@v}\", \"gpg-verify-summary\",\n                         g_variant_new_variant (g_variant_new_boolean (FALSE)));\n  g_variant_builder_add (&builder, \"{s@v}\", \"inherit-transaction\",\n                         g_variant_new_variant (g_variant_new_boolean (TRUE)));\n  g_variant_builder_add (&builder, \"{s@v}\", \"update-frequency\",\n                         g_variant_new_variant (g_variant_new_uint32 (FLATPAK_DEFAULT_UPDATE_INTERVAL_MS)));\n\n  if (dirs_to_pull)\n    {\n      g_variant_builder_add (&builder, \"{s@v}\", \"subdirs\",\n                             g_variant_new_variant (g_variant_new_strv ((const char * const *) dirs_to_pull, -1)));\n      g_variant_builder_add (&builder, \"{s@v}\", \"disable-static-deltas\",\n                             g_variant_new_variant (g_variant_new_boolean (TRUE)));\n    }\n\n  options = g_variant_ref_sink (g_variant_builder_end (&builder));\n\n  flatpak_progress_init_main_context (progress, &context);\n  res = ostree_repo_pull_with_options (repo, url, options,\n                                       context.ostree_progress, cancellable, error);\n  if (!res)\n    translate_ostree_repo_pull_errors (error);\n\n  return res;\n}\n\ngboolean\nflatpak_dir_pull_untrusted_local (FlatpakDir          *self,\n                                  const char          *src_path,\n                                  const char          *remote_name,\n                                  const char          *ref,\n                                  const char         **subpaths,\n                                  FlatpakProgress     *progress,\n                                  GCancellable        *cancellable,\n                                  GError             **error)\n{\n  g_autoptr(GFile) path_file = g_file_new_for_path (src_path);\n  g_autofree char *url = g_file_get_uri (path_file);\n  g_autofree char *checksum = NULL;\n  g_autofree char *current_checksum = NULL;\n  gboolean gpg_verify_summary;\n  gboolean gpg_verify;\n  g_autoptr(OstreeGpgVerifyResult) gpg_result = NULL;\n  g_autoptr(GVariant) old_commit = NULL;\n  g_autoptr(OstreeRepo) src_repo = NULL;\n  g_autoptr(GVariant) new_commit = NULL;\n  g_autoptr(GVariant) new_commit_metadata = NULL;\n  g_autoptr(GVariant) extra_data_sources = NULL;\n  g_autoptr(GPtrArray) subdirs_arg = NULL;\n  g_auto(GLnxLockFile) lock = { 0, };\n  gboolean ret = FALSE;\n  g_autofree const char **ref_bindings = NULL;\n\n  if (!flatpak_dir_ensure_repo (self, cancellable, error))\n    return FALSE;\n\n  /* Keep a shared repo lock to avoid prunes removing objects we're relying on\n   * while we do the pull. There are two cases we protect against. 1) objects we\n   * need but that we already decided are locally available could be removed,\n   * and 2) during the transaction commit objects that don't yet have a ref to\n   * them could be considered unreachable.\n   */\n  if (!flatpak_dir_repo_lock (self, &lock, LOCK_SH, cancellable, error))\n    return FALSE;\n\n  if (!ostree_repo_remote_get_gpg_verify_summary (self->repo, remote_name,\n                                                  &gpg_verify_summary, error))\n    return FALSE;\n\n  if (!ostree_repo_remote_get_gpg_verify (self->repo, remote_name,\n                                          &gpg_verify, error))\n    return FALSE;\n\n  /* This was verified in the client, but lets do it here too */\n  if (!gpg_verify_summary || !gpg_verify)\n    return flatpak_fail_error (error, FLATPAK_ERROR_UNTRUSTED, _(\"Can't pull from untrusted non-gpg verified remote\"));\n\n  if (!flatpak_repo_resolve_rev (self->repo, NULL, remote_name, ref, TRUE,\n                                 &current_checksum, NULL, error))\n    return FALSE;\n\n  if (current_checksum != NULL &&\n      !ostree_repo_load_commit (self->repo, current_checksum, &old_commit, NULL, error))\n    return FALSE;\n\n  src_repo = ostree_repo_new (path_file);\n  if (!ostree_repo_open (src_repo, cancellable, error))\n    return FALSE;\n\n  if (!flatpak_repo_resolve_rev (src_repo, NULL, remote_name, ref, FALSE, &checksum, NULL, error))\n    return FALSE;\n\n  if (gpg_verify)\n    {\n      gpg_result = ostree_repo_verify_commit_for_remote (src_repo, checksum, remote_name, cancellable, error);\n      if (gpg_result == NULL)\n        return FALSE;\n\n      if (ostree_gpg_verify_result_count_valid (gpg_result) == 0)\n        return flatpak_fail_error (error, FLATPAK_ERROR_UNTRUSTED, _(\"GPG signatures found, but none are in trusted keyring\"));\n    }\n\n  g_clear_object (&gpg_result);\n\n  if (!ostree_repo_load_commit (src_repo, checksum, &new_commit, NULL, error))\n    return FALSE;\n\n  /* Here we check that there is actually a ref binding, otherwise we\n     could allow installing a ref as another app, because both would\n     pass gpg validation. Note that ostree pull actually also verifies\n     the ref-bindings, but only if they exist. We could do only the\n     ref-binding existence check, but if we got something weird might as\n     well stop handling it early. */\n\n  new_commit_metadata = g_variant_get_child_value (new_commit, 0);\n  if (!g_variant_lookup (new_commit_metadata, OSTREE_COMMIT_META_KEY_REF_BINDING, \"^a&s\", &ref_bindings))\n    return flatpak_fail_error (error, FLATPAK_ERROR_INVALID_DATA, _(\"Commit for \u2018%s\u2019 has no ref binding\"),  ref);\n\n  if (!g_strv_contains ((const char *const *) ref_bindings, ref))\n    {\n      g_autofree char *as_string = g_strjoinv (\", \", (char **)ref_bindings);\n      return flatpak_fail_error (error, FLATPAK_ERROR_INVALID_DATA, _(\"Commit for \u2018%s\u2019 is not in expected bound refs: %s\"),  ref, as_string);\n    }\n\n  if (old_commit)\n    {\n      guint64 old_timestamp;\n      guint64 new_timestamp;\n\n      old_timestamp = ostree_commit_get_timestamp (old_commit);\n      new_timestamp = ostree_commit_get_timestamp (new_commit);\n\n      if (new_timestamp < old_timestamp)\n        return flatpak_fail_error (error, FLATPAK_ERROR_DOWNGRADE, \"Not allowed to downgrade %s (old_commit: %s/%\" G_GINT64_FORMAT \" new_commit: %s/%\" G_GINT64_FORMAT \")\",\n                                   ref, current_checksum, old_timestamp, checksum, new_timestamp);\n    }\n\n  if (subpaths != NULL && subpaths[0] != NULL)\n    {\n      subdirs_arg = g_ptr_array_new_with_free_func (g_free);\n      int i;\n      g_ptr_array_add (subdirs_arg, g_strdup (\"/metadata\"));\n      for (i = 0; subpaths[i] != NULL; i++)\n        g_ptr_array_add (subdirs_arg,\n                         g_build_filename (\"/files\", subpaths[i], NULL));\n      g_ptr_array_add (subdirs_arg, NULL);\n    }\n\n  if (!ostree_repo_prepare_transaction (self->repo, NULL, cancellable, error))\n    goto out;\n\n  /* Past this we must use goto out, so we abort the transaction on error */\n\n  if (!repo_pull_local_untrusted (self, self->repo, remote_name, url,\n                                  subdirs_arg ? (const char **) subdirs_arg->pdata : NULL,\n                                  ref, checksum, progress,\n                                  cancellable, error))\n    {\n      g_prefix_error (error, _(\"While pulling %s from remote %s: \"), ref, remote_name);\n      goto out;\n    }\n\n  /* Get the out of bands extra-data required due to an ostree pull\n     commitmeta size limit */\n  extra_data_sources = flatpak_commit_get_extra_data_sources (new_commit, NULL);\n  if (extra_data_sources)\n    {\n      GFile *dir = ostree_repo_get_path (src_repo);\n      g_autoptr(GFile) file = NULL;\n      g_autofree char *filename = NULL;\n      g_autofree char *commitmeta = NULL;\n      gsize commitmeta_size;\n      g_autoptr(GVariant) new_metadata = NULL;\n\n      filename = g_strconcat (checksum, \".commitmeta\", NULL);\n      file = g_file_get_child (dir, filename);\n      if (!g_file_load_contents (file, cancellable,\n                                 &commitmeta, &commitmeta_size,\n                                 NULL, error))\n        goto out;\n\n      new_metadata = g_variant_ref_sink (g_variant_new_from_data (G_VARIANT_TYPE (\"a{sv}\"),\n                                                                  commitmeta, commitmeta_size,\n                                                                  FALSE,\n                                                                  g_free, commitmeta));\n      g_steal_pointer (&commitmeta); /* steal into the variant */\n\n      if (!ostree_repo_write_commit_detached_metadata (self->repo, checksum, new_metadata, cancellable, error))\n        goto out;\n    }\n\n  if (!ostree_repo_commit_transaction (self->repo, NULL, cancellable, error))\n    goto out;\n\n  ret = TRUE;\n\n  flatpak_dir_log (self, \"pull local\", src_path, ref, checksum, current_checksum, NULL,\n                   \"Pulled %s from %s\", ref, src_path);\nout:\n  if (!ret)\n    ostree_repo_abort_transaction (self->repo, cancellable, NULL);\n\n  return ret;\n}\n\nFlatpakDecomposed *\nflatpak_dir_current_ref (FlatpakDir   *self,\n                         const char   *name,\n                         GCancellable *cancellable)\n{\n  g_autoptr(GFile) base = NULL;\n  g_autoptr(GFile) dir = NULL;\n  g_autoptr(GFile) current_link = NULL;\n  g_autoptr(GFileInfo) file_info = NULL;\n  FlatpakDecomposed *decomposed;\n  char *ref;\n\n  base = g_file_get_child (flatpak_dir_get_path (self), \"app\");\n  dir = g_file_get_child (base, name);\n\n  current_link = g_file_get_child (dir, \"current\");\n\n  file_info = g_file_query_info (current_link, OSTREE_GIO_FAST_QUERYINFO,\n                                 G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n                                 cancellable, NULL);\n  if (file_info == NULL)\n    return NULL;\n\n  ref = g_strconcat (\"app/\", name, \"/\", g_file_info_get_symlink_target (file_info), NULL);\n  decomposed = flatpak_decomposed_new_from_ref_take (ref, NULL);\n  if (decomposed == NULL)\n    g_free (ref);\n\n  return decomposed;\n}\n\ngboolean\nflatpak_dir_drop_current_ref (FlatpakDir   *self,\n                              const char   *name,\n                              GCancellable *cancellable,\n                              GError      **error)\n{\n  g_autoptr(GFile) base = NULL;\n  g_autoptr(GFile) dir = NULL;\n  g_autoptr(GFile) current_link = NULL;\n  g_autoptr(GPtrArray) refs = NULL;\n  g_autoptr(FlatpakDecomposed) current_ref = NULL;\n  FlatpakDecomposed *other_ref = NULL;\n\n  current_ref = flatpak_dir_current_ref (self, name, cancellable);\n  if (current_ref)\n    {\n      refs = flatpak_dir_list_refs_for_name (self, FLATPAK_KINDS_APP, name, cancellable, NULL);\n      if (refs)\n        {\n          for (int i = 0; i < refs->len; i++)\n            {\n              FlatpakDecomposed *ref = g_ptr_array_index (refs, i);\n              if (!flatpak_decomposed_equal (ref, current_ref))\n                {\n                  other_ref = ref;\n                  break;\n                }\n            }\n        }\n    }\n\n  base = g_file_get_child (flatpak_dir_get_path (self), \"app\");\n  dir = g_file_get_child (base, name);\n\n  current_link = g_file_get_child (dir, \"current\");\n  if (!g_file_delete (current_link, cancellable, error))\n    return FALSE;\n\n  if (other_ref)\n    {\n      if (!flatpak_dir_make_current_ref (self, other_ref, cancellable, error))\n        return FALSE;\n    }\n\n  return TRUE;\n}\n\ngboolean\nflatpak_dir_make_current_ref (FlatpakDir        *self,\n                              FlatpakDecomposed *ref,\n                              GCancellable      *cancellable,\n                              GError           **error)\n{\n  g_autoptr(GFile) base = NULL;\n  g_autoptr(GFile) dir = NULL;\n  g_autoptr(GFile) current_link = NULL;\n  g_autofree char *id = NULL;\n  const char *rest;\n\n  if (!flatpak_decomposed_is_app (ref))\n    return flatpak_fail (error, _(\"Only applications can be made current\"));\n\n  base = g_file_get_child (flatpak_dir_get_path (self), flatpak_decomposed_get_kind_str (ref));\n\n  id = flatpak_decomposed_dup_id (ref);\n  dir = g_file_get_child (base, id);\n\n  current_link = g_file_get_child (dir, \"current\");\n\n  g_file_delete (current_link, cancellable, NULL);\n\n  rest = flatpak_decomposed_peek_arch (ref, NULL);\n  if (!g_file_make_symbolic_link (current_link, rest, cancellable, error))\n    return FALSE;\n\n  return TRUE;\n}\n\nstatic gboolean\n_flatpak_dir_list_refs_for_name (FlatpakDir   *self,\n                                 GFile        *base_dir,\n                                 FlatpakKinds kind,\n                                 const char   *name,\n                                 GPtrArray    *refs,\n                                 GCancellable *cancellable,\n                                 GError      **error)\n{\n  g_autoptr(GFile) dir = NULL;\n  g_autoptr(GFileEnumerator) dir_enum = NULL;\n  g_autoptr(GFileInfo) child_info = NULL;\n  GError *temp_error = NULL;\n\n  g_assert (kind == FLATPAK_KINDS_RUNTIME || kind == FLATPAK_KINDS_APP);\n\n  dir = g_file_get_child (base_dir, name);\n\n  if (!g_file_query_exists (dir, cancellable))\n    return TRUE;\n\n  dir_enum = g_file_enumerate_children (dir, OSTREE_GIO_FAST_QUERYINFO,\n                                        G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n                                        cancellable, error);\n  if (!dir_enum)\n    return FALSE;\n\n  while ((child_info = g_file_enumerator_next_file (dir_enum, cancellable, &temp_error)))\n    {\n      g_autoptr(GFile) child = NULL;\n      g_autoptr(GFileEnumerator) dir_enum2 = NULL;\n      g_autoptr(GFileInfo) child_info2 = NULL;\n      const char *arch;\n\n      arch = g_file_info_get_name (child_info);\n\n      if (g_file_info_get_file_type (child_info) != G_FILE_TYPE_DIRECTORY ||\n          strcmp (arch, \"data\") == 0 /* There used to be a data dir here, lets ignore it */)\n        {\n          g_clear_object (&child_info);\n          continue;\n        }\n\n      child = g_file_get_child (dir, arch);\n      g_clear_object (&dir_enum2);\n      dir_enum2 = g_file_enumerate_children (child, OSTREE_GIO_FAST_QUERYINFO,\n                                             G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n                                             cancellable, error);\n      if (!dir_enum2)\n        return FALSE;\n\n      while ((child_info2 = g_file_enumerator_next_file (dir_enum2, cancellable, &temp_error)))\n        {\n          const char *branch = g_file_info_get_name (child_info2);\n\n          if (g_file_info_get_file_type (child_info2) == G_FILE_TYPE_DIRECTORY)\n            {\n              g_autoptr(GFile) deploy = flatpak_build_file (child, branch, \"active/deploy\", NULL);\n\n              if (g_file_query_exists (deploy, NULL))\n                {\n                  FlatpakDecomposed *ref = flatpak_decomposed_new_from_parts (kind, name, arch, branch, NULL);\n                  if (ref)\n                    g_ptr_array_add (refs, ref);\n                }\n            }\n\n          g_clear_object (&child_info2);\n        }\n\n      if (temp_error != NULL)\n        {\n          g_propagate_error (error, temp_error);\n          return FALSE;\n        }\n\n      g_clear_object (&child_info);\n    }\n\n  if (temp_error != NULL)\n    {\n      g_propagate_error (error, temp_error);\n      return FALSE;\n    }\n\n  return TRUE;\n}\n\nGPtrArray *\nflatpak_dir_list_refs_for_name (FlatpakDir   *self,\n                                FlatpakKinds kinds,\n                                const char   *name,\n                                GCancellable *cancellable,\n                                GError      **error)\n{\n  g_autoptr(GPtrArray) refs = NULL;\n\n  refs = g_ptr_array_new_with_free_func ((GDestroyNotify)flatpak_decomposed_unref);\n\n  if ((kinds & FLATPAK_KINDS_APP) != 0)\n    {\n      g_autoptr(GFile) base = g_file_get_child (flatpak_dir_get_path (self), \"app\");\n\n      if (!_flatpak_dir_list_refs_for_name (self, base, FLATPAK_KINDS_APP, name, refs, cancellable, error))\n        return NULL;\n    }\n\n  if ((kinds & FLATPAK_KINDS_RUNTIME) != 0)\n    {\n      g_autoptr(GFile) base = g_file_get_child (flatpak_dir_get_path (self), \"runtime\");\n\n      if (!_flatpak_dir_list_refs_for_name (self, base, FLATPAK_KINDS_RUNTIME, name, refs, cancellable, error))\n        return NULL;\n    }\n\n  g_ptr_array_sort (refs, (GCompareFunc)flatpak_decomposed_strcmp_p);\n\n  return g_steal_pointer (&refs);\n}\n\nGPtrArray *\nflatpak_dir_list_refs (FlatpakDir   *self,\n                       FlatpakKinds kinds,\n                       GCancellable *cancellable,\n                       GError      **error)\n{\n  g_autoptr(GPtrArray) refs = NULL;\n\n  refs = g_ptr_array_new_with_free_func ((GDestroyNotify)flatpak_decomposed_unref);\n\n  if (kinds & FLATPAK_KINDS_APP)\n    {\n      g_autoptr(GFile) base = NULL;\n      g_autoptr(GFileEnumerator) dir_enum = NULL;\n      g_autoptr(GFileInfo) child_info = NULL;\n      GError *temp_error = NULL;\n\n      base = g_file_get_child (flatpak_dir_get_path (self), \"app\");\n\n      if (g_file_query_exists (base, cancellable))\n        {\n          dir_enum = g_file_enumerate_children (base, OSTREE_GIO_FAST_QUERYINFO,\n                                                G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n                                                cancellable, error);\n          if (!dir_enum)\n            return NULL;\n\n          while ((child_info = g_file_enumerator_next_file (dir_enum, cancellable, &temp_error)))\n            {\n              const char *name = g_file_info_get_name (child_info);\n\n              if (g_file_info_get_file_type (child_info) != G_FILE_TYPE_DIRECTORY)\n                {\n                  g_clear_object (&child_info);\n                  continue;\n                }\n\n              if (!_flatpak_dir_list_refs_for_name (self, base, FLATPAK_KINDS_APP, name, refs, cancellable, error))\n                return NULL;\n\n              g_clear_object (&child_info);\n            }\n\n          if (temp_error != NULL)\n            {\n              g_propagate_error (error, temp_error);\n              return NULL;\n            }\n        }\n    }\n\n  if (kinds & FLATPAK_KINDS_RUNTIME)\n    {\n      g_autoptr(GFile) base = NULL;\n      g_autoptr(GFileEnumerator) dir_enum = NULL;\n      g_autoptr(GFileInfo) child_info = NULL;\n      GError *temp_error = NULL;\n\n      base = g_file_get_child (flatpak_dir_get_path (self), \"runtime\");\n\n      if (g_file_query_exists (base, cancellable))\n        {\n          dir_enum = g_file_enumerate_children (base, OSTREE_GIO_FAST_QUERYINFO,\n                                                G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n                                                cancellable, error);\n          if (!dir_enum)\n            return NULL;\n\n          while ((child_info = g_file_enumerator_next_file (dir_enum, cancellable, &temp_error)))\n            {\n              const char *name = g_file_info_get_name (child_info);\n\n              if (g_file_info_get_file_type (child_info) != G_FILE_TYPE_DIRECTORY)\n                {\n                  g_clear_object (&child_info);\n                  continue;\n                }\n\n              if (!_flatpak_dir_list_refs_for_name (self, base, FLATPAK_KINDS_RUNTIME, name, refs, cancellable, error))\n                return NULL;\n\n              g_clear_object (&child_info);\n            }\n\n          if (temp_error != NULL)\n            {\n              g_propagate_error (error, temp_error);\n              return NULL;\n            }\n        }\n    }\n\n  g_ptr_array_sort (refs, (GCompareFunc)flatpak_decomposed_strcmp_p);\n\n  return g_steal_pointer (&refs);\n}\n\nGPtrArray *\nflatpak_dir_list_app_refs_with_runtime (FlatpakDir        *self,\n                                        FlatpakDecomposed *runtime_ref,\n                                        GCancellable      *cancellable,\n                                        GError           **error)\n{\n  g_autoptr(GPtrArray) app_refs = NULL;\n  const char *runtime_pref = flatpak_decomposed_get_pref (runtime_ref);\n  g_autoptr(GPtrArray) apps = g_ptr_array_new_with_free_func ((GDestroyNotify)flatpak_decomposed_unref);\n\n  app_refs = flatpak_dir_list_refs (self, FLATPAK_KINDS_APP, NULL, NULL);\n  for (int i = 0; app_refs != NULL && i < app_refs->len; i++)\n    {\n      FlatpakDecomposed *app_ref = g_ptr_array_index (app_refs, i);\n      /* deploy v4 guarantees runtime info */\n      g_autoptr(GBytes) app_deploy_data = flatpak_dir_get_deploy_data (self, app_ref, 4, NULL, NULL);\n\n      if (app_deploy_data)\n        {\n          const char *app_runtime = flatpak_deploy_data_get_runtime (app_deploy_data);\n          if (g_strcmp0 (app_runtime, runtime_pref) == 0)\n            g_ptr_array_add (apps, flatpak_decomposed_ref (app_ref));\n        }\n    }\n\n  return g_steal_pointer (&apps);\n}\n\nGVariant *\nflatpak_dir_read_latest_commit (FlatpakDir        *self,\n                                const char        *remote,\n                                FlatpakDecomposed *ref,\n                                char             **out_checksum,\n                                GCancellable      *cancellable,\n                                GError           **error)\n{\n  g_autofree char *res = NULL;\n  g_autoptr(GVariant) commit_data = NULL;\n\n  if (!flatpak_repo_resolve_rev (self->repo, NULL, remote, flatpak_decomposed_get_ref (ref), FALSE,\n                                 &res, cancellable, error))\n    return NULL;\n\n  if (!ostree_repo_load_commit (self->repo, res, &commit_data, NULL, error))\n    return NULL;\n\n  if (out_checksum)\n    *out_checksum = g_steal_pointer (&res);\n\n  return g_steal_pointer (&commit_data);\n}\n\n\nchar *\nflatpak_dir_read_latest (FlatpakDir   *self,\n                         const char   *remote,\n                         const char   *ref,\n                         char        **out_alt_id,\n                         GCancellable *cancellable,\n                         GError      **error)\n{\n  g_autofree char *alt_id = NULL;\n  g_autofree char *res = NULL;\n\n  if (!flatpak_repo_resolve_rev (self->repo, NULL, remote, ref, FALSE,\n                                 &res, cancellable, error))\n    return NULL;\n\n  if (out_alt_id)\n    {\n      g_autoptr(GVariant) commit_data = NULL;\n      g_autoptr(GVariant) commit_metadata = NULL;\n\n      if (!ostree_repo_load_commit (self->repo, res, &commit_data, NULL, error))\n        return NULL;\n\n      commit_metadata = g_variant_get_child_value (commit_data, 0);\n      g_variant_lookup (commit_metadata, \"xa.alt-id\", \"s\", &alt_id);\n\n      *out_alt_id = g_steal_pointer (&alt_id);\n    }\n\n  return g_steal_pointer (&res);\n}\n\nchar *\nflatpak_dir_read_active (FlatpakDir        *self,\n                         FlatpakDecomposed *ref,\n                         GCancellable      *cancellable)\n{\n  g_autoptr(GFile) deploy_base = NULL;\n  g_autoptr(GFile) active_link = NULL;\n  g_autoptr(GFileInfo) file_info = NULL;\n\n  deploy_base = flatpak_dir_get_deploy_dir (self, ref);\n  active_link = g_file_get_child (deploy_base, \"active\");\n\n  file_info = g_file_query_info (active_link, OSTREE_GIO_FAST_QUERYINFO,\n                                 G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n                                 cancellable, NULL);\n  if (file_info == NULL)\n    return NULL;\n\n  return g_strdup (g_file_info_get_symlink_target (file_info));\n}\n\ngboolean\nflatpak_dir_set_active (FlatpakDir        *self,\n                        FlatpakDecomposed *ref,\n                        const char        *active_id,\n                        GCancellable      *cancellable,\n                        GError           **error)\n{\n  gboolean ret = FALSE;\n  g_autoptr(GFile) deploy_base = NULL;\n  g_autoptr(GFile) active_tmp_link = NULL;\n  g_autoptr(GFile) active_link = NULL;\n  g_autoptr(GError) my_error = NULL;\n  g_autofree char *tmpname = g_strdup (\".active-XXXXXX\");\n\n  deploy_base = flatpak_dir_get_deploy_dir (self, ref);\n  active_link = g_file_get_child (deploy_base, \"active\");\n\n  if (active_id != NULL)\n    {\n      glnx_gen_temp_name (tmpname);\n      active_tmp_link = g_file_get_child (deploy_base, tmpname);\n      if (!g_file_make_symbolic_link (active_tmp_link, active_id, cancellable, error))\n        goto out;\n\n      if (!flatpak_file_rename (active_tmp_link,\n                                active_link,\n                                cancellable, error))\n        goto out;\n    }\n  else\n    {\n      if (!g_file_delete (active_link, cancellable, &my_error) &&\n          !g_error_matches (my_error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND))\n        {\n          g_propagate_error (error, my_error);\n          my_error = NULL;\n          goto out;\n        }\n    }\n\n  ret = TRUE;\nout:\n  return ret;\n}\n\ngboolean\nflatpak_dir_run_triggers (FlatpakDir   *self,\n                          GCancellable *cancellable,\n                          GError      **error)\n{\n  gboolean ret = FALSE;\n  g_autoptr(GFileEnumerator) dir_enum = NULL;\n  g_autoptr(GFileInfo) child_info = NULL;\n  g_autoptr(GFile) triggersdir = NULL;\n  GError *temp_error = NULL;\n  const char *triggerspath;\n\n  if (flatpak_dir_use_system_helper (self, NULL))\n    {\n      const char *installation = flatpak_dir_get_id (self);\n\n      if (!flatpak_dir_system_helper_call_run_triggers (self,\n                                                        FLATPAK_HELPER_RUN_TRIGGERS_FLAGS_NONE,\n                                                        installation ? installation : \"\",\n                                                        cancellable,\n                                                        error))\n        return FALSE;\n\n      return TRUE;\n    }\n\n  triggerspath = g_getenv (\"FLATPAK_TRIGGERSDIR\");\n  if (triggerspath == NULL)\n    triggerspath = FLATPAK_TRIGGERDIR;\n\n  g_debug (\"running triggers from %s\", triggerspath);\n\n  triggersdir = g_file_new_for_path (triggerspath);\n\n  dir_enum = g_file_enumerate_children (triggersdir, \"standard::type,standard::name\",\n                                        0, cancellable, error);\n  if (!dir_enum)\n    goto out;\n\n  while ((child_info = g_file_enumerator_next_file (dir_enum, cancellable, &temp_error)) != NULL)\n    {\n      g_autoptr(GFile) child = NULL;\n      const char *name;\n      GError *trigger_error = NULL;\n\n      name = g_file_info_get_name (child_info);\n\n      child = g_file_get_child (triggersdir, name);\n\n      if (g_file_info_get_file_type (child_info) == G_FILE_TYPE_REGULAR &&\n          g_str_has_suffix (name, \".trigger\"))\n        {\n          g_autoptr(GPtrArray) argv_array = NULL;\n          /* We need to canonicalize the basedir, because if has a symlink\n             somewhere the bind mount will be on the target of that, not\n             at that exact path. */\n          g_autofree char *basedir_orig = g_file_get_path (self->basedir);\n          g_autofree char *basedir = realpath (basedir_orig, NULL);\n          g_autoptr(FlatpakBwrap) bwrap = NULL;\n          g_autofree char *commandline = NULL;\n\n          g_debug (\"running trigger %s\", name);\n\n          bwrap = flatpak_bwrap_new (NULL);\n\n          argv_array = g_ptr_array_new_with_free_func (g_free);\n#ifndef DISABLE_SANDBOXED_TRIGGERS\n          flatpak_bwrap_add_arg (bwrap, flatpak_get_bwrap ());\n          flatpak_bwrap_add_args (bwrap,\n                                  \"--unshare-ipc\",\n                                  \"--unshare-net\",\n                                  \"--unshare-pid\",\n                                  \"--ro-bind\", \"/\", \"/\",\n                                  \"--proc\", \"/proc\",\n                                  \"--dev\", \"/dev\",\n                                  \"--bind\", basedir, basedir,\n                                  NULL);\n#endif\n          flatpak_bwrap_add_args (bwrap,\n                                  flatpak_file_get_path_cached (child),\n                                  basedir,\n                                  NULL);\n          flatpak_bwrap_finish (bwrap);\n\n          commandline = flatpak_quote_argv ((const char **) bwrap->argv->pdata, -1);\n          g_debug (\"Running '%s'\", commandline);\n\n          /* We use LEAVE_DESCRIPTORS_OPEN to work around dead-lock, see flatpak_close_fds_workaround */\n          if (!g_spawn_sync (\"/\",\n                             (char **) bwrap->argv->pdata,\n                             NULL,\n                             G_SPAWN_SEARCH_PATH | G_SPAWN_LEAVE_DESCRIPTORS_OPEN,\n                             flatpak_bwrap_child_setup_cb, bwrap->fds,\n                             NULL, NULL,\n                             NULL, &trigger_error))\n            {\n              g_warning (\"Error running trigger %s: %s\", name, trigger_error->message);\n              g_clear_error (&trigger_error);\n            }\n        }\n\n      g_clear_object (&child_info);\n    }\n\n  if (temp_error != NULL)\n    {\n      g_propagate_error (error, temp_error);\n      goto out;\n    }\n\n  ret = TRUE;\nout:\n  return ret;\n}\n\nstatic gboolean\nread_fd (int          fd,\n         struct stat *stat_buf,\n         gchar      **contents,\n         gsize       *length,\n         GError     **error)\n{\n  gchar *buf;\n  gsize bytes_read;\n  gsize size;\n  gsize alloc_size;\n\n  size = stat_buf->st_size;\n\n  alloc_size = size + 1;\n  buf = g_try_malloc (alloc_size);\n\n  if (buf == NULL)\n    {\n      g_set_error_literal (error, G_FILE_ERROR, G_FILE_ERROR_NOMEM,\n                           _(\"Not enough memory\"));\n      return FALSE;\n    }\n\n  bytes_read = 0;\n  while (bytes_read < size)\n    {\n      gssize rc;\n\n      rc = read (fd, buf + bytes_read, size - bytes_read);\n\n      if (rc < 0)\n        {\n          if (errno != EINTR)\n            {\n              int save_errno = errno;\n\n              g_free (buf);\n              g_set_error_literal (error, G_FILE_ERROR, g_file_error_from_errno (save_errno),\n                                   _(\"Failed to read from exported file\"));\n              return FALSE;\n            }\n        }\n      else if (rc == 0)\n        {\n          break;\n        }\n      else\n        {\n          bytes_read += rc;\n        }\n    }\n\n  buf[bytes_read] = '\\0';\n\n  if (length)\n    *length = bytes_read;\n\n  *contents = buf;\n\n  return TRUE;\n}\n\n/* This is conservative, but lets us avoid escaping most\n   regular Exec= lines, which is nice as that can sometimes\n   cause problems for apps launching desktop files. */\nstatic gboolean\nneed_quotes (const char *str)\n{\n  const char *p;\n\n  for (p = str; *p; p++)\n    {\n      if (!g_ascii_isalnum (*p) &&\n          strchr (\"-_%.=:/@\", *p) == NULL)\n        return TRUE;\n    }\n\n  return FALSE;\n}\n\nstatic char *\nmaybe_quote (const char *str)\n{\n  if (need_quotes (str))\n    return g_shell_quote (str);\n  return g_strdup (str);\n}\n\ntypedef enum {\n  INI_FILE_TYPE_SEARCH_PROVIDER = 1,\n} ExportedIniFileType;\n\nstatic gboolean\nexport_ini_file (int                 parent_fd,\n                 const char         *name,\n                 ExportedIniFileType ini_type,\n                 struct stat        *stat_buf,\n                 char              **target,\n                 GCancellable       *cancellable,\n                 GError            **error)\n{\n  glnx_autofd int desktop_fd = -1;\n  g_autofree char *tmpfile_name = g_strdup_printf (\"export-ini-XXXXXX\");\n  g_autoptr(GOutputStream) out_stream = NULL;\n  g_autofree gchar *data = NULL;\n  gsize data_len;\n  g_autofree gchar *new_data = NULL;\n  gsize new_data_len;\n  g_autoptr(GKeyFile) keyfile = NULL;\n\n  if (!flatpak_openat_noatime (parent_fd, name, &desktop_fd, cancellable, error) ||\n      !read_fd (desktop_fd, stat_buf, &data, &data_len, error))\n    return FALSE;\n\n  keyfile = g_key_file_new ();\n  if (!g_key_file_load_from_data (keyfile, data, data_len, G_KEY_FILE_KEEP_TRANSLATIONS, error))\n    return FALSE;\n\n  if (ini_type == INI_FILE_TYPE_SEARCH_PROVIDER)\n    g_key_file_set_boolean (keyfile, \"Shell Search Provider\", \"DefaultDisabled\", TRUE);\n\n  new_data = g_key_file_to_data (keyfile, &new_data_len, error);\n  if (new_data == NULL)\n    return FALSE;\n\n  if (!flatpak_open_in_tmpdir_at (parent_fd, 0755, tmpfile_name, &out_stream, cancellable, error) ||\n      !g_output_stream_write_all (out_stream, new_data, new_data_len, NULL, cancellable, error) ||\n      !g_output_stream_close (out_stream, cancellable, error))\n    return FALSE;\n\n  if (target)\n    *target = g_steal_pointer (&tmpfile_name);\n\n  return TRUE;\n}\n\nstatic inline void\nxml_autoptr_cleanup_generic_free (void *p)\n{\n  void **pp = (void **) p;\n\n  if (*pp)\n    xmlFree (*pp);\n}\n\n\n#define xml_autofree _GLIB_CLEANUP (xml_autoptr_cleanup_generic_free)\n\n/* This verifies the basic layout of the files, then it removes\n * any magic matches, and makes all glob matches have a very low\n * priority (weight = 5). This should make it pretty safe to\n * export mime types, because the should not override the system\n * ones in any weird ways. */\nstatic gboolean\nrewrite_mime_xml (xmlDoc *doc)\n{\n  xmlNode *root_element = xmlDocGetRootElement (doc);\n  xmlNode *top_node = NULL;\n\n  for (top_node = root_element; top_node; top_node = top_node->next)\n    {\n      xmlNode *mime_node = NULL;\n      if (top_node->type != XML_ELEMENT_NODE)\n        continue;\n\n      if (strcmp ((char *) top_node->name, \"mime-info\") != 0)\n        return FALSE;\n\n      for (mime_node = top_node->children; mime_node; mime_node = mime_node->next)\n        {\n          xmlNode *sub_node = NULL;\n          xmlNode *next_sub_node = NULL;\n\n          xml_autofree xmlChar *mimetype = NULL;\n          if (mime_node->type != XML_ELEMENT_NODE)\n            continue;\n\n          if (strcmp ((char *) mime_node->name, \"mime-type\") != 0)\n            return FALSE;\n\n          mimetype = xmlGetProp (mime_node, (xmlChar *) \"type\");\n          for (sub_node = mime_node->children; sub_node; sub_node = next_sub_node)\n            {\n              next_sub_node = sub_node->next;\n\n              if (sub_node->type != XML_ELEMENT_NODE)\n                continue;\n\n              if (strcmp ((char *) sub_node->name, \"magic\") == 0)\n                {\n                  g_warning (\"Removing magic mime rule from exports\");\n                  xmlUnlinkNode (sub_node);\n                  xmlFreeNode (sub_node);\n                }\n              else if (strcmp ((char *) sub_node->name, \"glob\") == 0)\n                {\n                  xmlSetProp (sub_node,\n                              (const xmlChar *) \"weight\",\n                              (const xmlChar *) \"5\");\n                }\n            }\n        }\n    }\n\n  return TRUE;\n}\n\nstatic gboolean\nexport_mime_file (int           parent_fd,\n                  const char   *name,\n                  struct stat  *stat_buf,\n                  char        **target,\n                  GCancellable *cancellable,\n                  GError      **error)\n{\n  glnx_autofd int desktop_fd = -1;\n  g_autofree char *tmpfile_name = g_strdup_printf (\"export-mime-XXXXXX\");\n  g_autoptr(GOutputStream) out_stream = NULL;\n  g_autofree gchar *data = NULL;\n  gsize data_len;\n  xmlDoc *doc = NULL;\n  xml_autofree xmlChar *xmlbuff = NULL;\n  int buffersize;\n\n  if (!flatpak_openat_noatime (parent_fd, name, &desktop_fd, cancellable, error) ||\n      !read_fd (desktop_fd, stat_buf, &data, &data_len, error))\n    return FALSE;\n\n  doc = xmlReadMemory (data, data_len, NULL, NULL,  0);\n  if (doc == NULL)\n    return flatpak_fail_error (error, FLATPAK_ERROR_EXPORT_FAILED, _(\"Error reading mimetype xml file\"));\n\n  if (!rewrite_mime_xml (doc))\n    {\n      xmlFreeDoc (doc);\n      return flatpak_fail_error (error, FLATPAK_ERROR_EXPORT_FAILED, _(\"Invalid mimetype xml file\"));\n    }\n\n  xmlDocDumpFormatMemory (doc, &xmlbuff, &buffersize, 1);\n  xmlFreeDoc (doc);\n\n  if (!flatpak_open_in_tmpdir_at (parent_fd, 0755, tmpfile_name, &out_stream, cancellable, error) ||\n      !g_output_stream_write_all (out_stream, xmlbuff, buffersize, NULL, cancellable, error) ||\n      !g_output_stream_close (out_stream, cancellable, error))\n    return FALSE;\n\n  if (target)\n    *target = g_steal_pointer (&tmpfile_name);\n\n  return TRUE;\n}\n\nstatic char *\nformat_flatpak_run_args_from_run_opts (GStrv flatpak_run_args)\n{\n  GString *str;\n  GStrv iter = flatpak_run_args;\n\n  if (flatpak_run_args == NULL)\n    return NULL;\n\n  str = g_string_new (\"\");\n  for (; *iter != NULL; ++iter)\n    {\n      if (g_strcmp0 (*iter, \"no-a11y-bus\") == 0)\n        g_string_append_printf (str, \" --no-a11y-bus\");\n      else if (g_strcmp0 (*iter, \"no-documents-portal\") == 0)\n        g_string_append_printf (str, \" --no-documents-portal\");\n    }\n\n  return g_string_free (str, FALSE);\n}\n\nstatic gboolean\nexport_desktop_file (const char         *app,\n                     const char         *branch,\n                     const char         *arch,\n                     GKeyFile           *metadata,\n                     const char * const *previous_ids,\n                     int                 parent_fd,\n                     const char         *name,\n                     struct stat        *stat_buf,\n                     char              **target,\n                     GCancellable       *cancellable,\n                     GError            **error)\n{\n  gboolean ret = FALSE;\n  glnx_autofd int desktop_fd = -1;\n  g_autofree char *tmpfile_name = g_strdup_printf (\"export-desktop-XXXXXX\");\n  g_autoptr(GOutputStream) out_stream = NULL;\n  g_autofree gchar *data = NULL;\n  gsize data_len;\n  g_autofree gchar *new_data = NULL;\n  gsize new_data_len;\n  g_autoptr(GKeyFile) keyfile = NULL;\n  g_autofree gchar *old_exec = NULL;\n  gint old_argc;\n  g_auto(GStrv) old_argv = NULL;\n  g_auto(GStrv) groups = NULL;\n  GString *new_exec = NULL;\n  g_autofree char *escaped_app = maybe_quote (app);\n  g_autofree char *escaped_branch = maybe_quote (branch);\n  g_autofree char *escaped_arch = maybe_quote (arch);\n  int i;\n\n  if (!flatpak_openat_noatime (parent_fd, name, &desktop_fd, cancellable, error))\n    goto out;\n\n  if (!read_fd (desktop_fd, stat_buf, &data, &data_len, error))\n    goto out;\n\n  keyfile = g_key_file_new ();\n  if (!g_key_file_load_from_data (keyfile, data, data_len, G_KEY_FILE_KEEP_TRANSLATIONS, error))\n    goto out;\n\n  if (g_str_has_suffix (name, \".service\"))\n    {\n      g_autofree gchar *dbus_name = NULL;\n      g_autofree gchar *expected_dbus_name = g_strndup (name, strlen (name) - strlen (\".service\"));\n\n      dbus_name = g_key_file_get_string (keyfile, \"D-BUS Service\", \"Name\", NULL);\n\n      if (dbus_name == NULL || strcmp (dbus_name, expected_dbus_name) != 0)\n        {\n          return flatpak_fail_error (error, FLATPAK_ERROR_EXPORT_FAILED,\n                                     _(\"D-Bus service file '%s' has wrong name\"), name);\n        }\n    }\n\n  if (g_str_has_suffix (name, \".desktop\"))\n    {\n      gsize length;\n      g_auto(GStrv) tags = g_key_file_get_string_list (metadata,\n                                                       \"Application\",\n                                                       \"tags\", &length,\n                                                       NULL);\n\n      if (tags != NULL)\n        {\n          g_key_file_set_string_list (keyfile,\n                                      G_KEY_FILE_DESKTOP_GROUP,\n                                      \"X-Flatpak-Tags\",\n                                      (const char * const *) tags, length);\n        }\n\n      /* Add a marker so consumers can easily find out that this launches a sandbox */\n      g_key_file_set_string (keyfile, G_KEY_FILE_DESKTOP_GROUP, \"X-Flatpak\", app);\n\n      /* If the app has been renamed, add its old .desktop filename to\n       * X-Flatpak-RenamedFrom in the new .desktop file, taking care not to\n       * introduce duplicates.\n       */\n      if (previous_ids != NULL)\n        {\n          const char *X_FLATPAK_RENAMED_FROM = \"X-Flatpak-RenamedFrom\";\n          g_auto(GStrv) renamed_from = g_key_file_get_string_list (keyfile,\n                                                                   G_KEY_FILE_DESKTOP_GROUP,\n                                                                   X_FLATPAK_RENAMED_FROM,\n                                                                   NULL, NULL);\n          g_autoptr(GPtrArray) merged = g_ptr_array_new_with_free_func (g_free);\n          g_autoptr(GHashTable) seen = g_hash_table_new (g_str_hash, g_str_equal);\n          const char *new_suffix;\n\n          for (i = 0; renamed_from != NULL && renamed_from[i] != NULL; i++)\n            {\n              if (!g_hash_table_contains (seen, renamed_from[i]))\n                {\n                  gchar *copy = g_strdup (renamed_from[i]);\n                  g_hash_table_insert (seen, copy, copy);\n                  g_ptr_array_add (merged, g_steal_pointer (&copy));\n                }\n            }\n\n          /* If an app was renamed from com.example.Foo to net.example.Bar, and\n           * the new version exports net.example.Bar-suffix.desktop, we assume the\n           * old version exported com.example.Foo-suffix.desktop.\n           *\n           * This assertion is true because\n           * flatpak_name_matches_one_wildcard_prefix() is called on all\n           * exported files before we get here.\n           */\n          g_assert (g_str_has_prefix (name, app));\n          /* \".desktop\" for the \"main\" desktop file; something like\n           * \"-suffix.desktop\" for extra ones.\n           */\n          new_suffix = name + strlen (app);\n\n          for (i = 0; previous_ids[i] != NULL; i++)\n            {\n              g_autofree gchar *previous_desktop = g_strconcat (previous_ids[i], new_suffix, NULL);\n              if (!g_hash_table_contains (seen, previous_desktop))\n                {\n                  g_hash_table_insert (seen, previous_desktop, previous_desktop);\n                  g_ptr_array_add (merged, g_steal_pointer (&previous_desktop));\n                }\n            }\n\n          if (merged->len > 0)\n            {\n              g_ptr_array_add (merged, NULL);\n              g_key_file_set_string_list (keyfile,\n                                          G_KEY_FILE_DESKTOP_GROUP,\n                                          X_FLATPAK_RENAMED_FROM,\n                                          (const char * const *) merged->pdata,\n                                          merged->len - 1);\n            }\n        }\n    }\n\n  groups = g_key_file_get_groups (keyfile, NULL);\n\n  for (i = 0; groups[i] != NULL; i++)\n    {\n      g_auto(GStrv) flatpak_run_opts = g_key_file_get_string_list (keyfile, groups[i], \"X-Flatpak-RunOptions\", NULL, NULL);\n      g_autofree char *flatpak_run_args = format_flatpak_run_args_from_run_opts (flatpak_run_opts);\n\n      g_key_file_remove_key (keyfile, groups[i], \"X-Flatpak-RunOptions\", NULL);\n      g_key_file_remove_key (keyfile, groups[i], \"TryExec\", NULL);\n\n      /* Remove this to make sure nothing tries to execute it outside the sandbox*/\n      g_key_file_remove_key (keyfile, groups[i], \"X-GNOME-Bugzilla-ExtraInfoScript\", NULL);\n\n      new_exec = g_string_new (\"\");\n      g_string_append_printf (new_exec,\n                              FLATPAK_BINDIR \"/flatpak run --branch=%s --arch=%s\",\n                              escaped_branch,\n                              escaped_arch);\n\n      if (flatpak_run_args != NULL)\n        g_string_append_printf (new_exec, \"%s\", flatpak_run_args);\n\n      old_exec = g_key_file_get_string (keyfile, groups[i], \"Exec\", NULL);\n      if (old_exec && g_shell_parse_argv (old_exec, &old_argc, &old_argv, NULL) && old_argc >= 1)\n        {\n          int j;\n          g_autofree char *command = maybe_quote (old_argv[0]);\n\n          g_string_append_printf (new_exec, \" --command=%s\", command);\n\n          for (j = 1; j < old_argc; j++)\n            {\n              if (strcasecmp (old_argv[j], \"%f\") == 0 ||\n                  strcasecmp (old_argv[j], \"%u\") == 0)\n                {\n                  g_string_append (new_exec, \" --file-forwarding\");\n                  break;\n                }\n            }\n\n          g_string_append (new_exec, \" \");\n          g_string_append (new_exec, escaped_app);\n\n          for (j = 1; j < old_argc; j++)\n            {\n              g_autofree char *arg = maybe_quote (old_argv[j]);\n\n              if (strcasecmp (arg, \"%f\") == 0)\n                g_string_append_printf (new_exec, \" @@ %s @@\", arg);\n              else if (strcasecmp (arg, \"%u\") == 0)\n                g_string_append_printf (new_exec, \" @@u %s @@\", arg);\n              else if (strcmp (arg, \"@@\") == 0 || strcmp (arg, \"@@u\") == 0)\n                g_print (_(\"Skipping invalid Exec argument %s\\n\"), arg);\n              else\n                g_string_append_printf (new_exec, \" %s\", arg);\n            }\n        }\n      else\n        {\n          g_string_append (new_exec, \" \");\n          g_string_append (new_exec, escaped_app);\n        }\n\n      g_key_file_set_string (keyfile, groups[i], G_KEY_FILE_DESKTOP_KEY_EXEC, new_exec->str);\n    }\n\n  new_data = g_key_file_to_data (keyfile, &new_data_len, error);\n  if (new_data == NULL)\n    goto out;\n\n  if (!flatpak_open_in_tmpdir_at (parent_fd, 0755, tmpfile_name, &out_stream, cancellable, error))\n    goto out;\n\n  if (!g_output_stream_write_all (out_stream, new_data, new_data_len, NULL, cancellable, error))\n    goto out;\n\n  if (!g_output_stream_close (out_stream, cancellable, error))\n    goto out;\n\n  if (target)\n    *target = g_steal_pointer (&tmpfile_name);\n\n  ret = TRUE;\nout:\n\n  if (new_exec != NULL)\n    g_string_free (new_exec, TRUE);\n\n  return ret;\n}\n\nstatic gboolean\nrewrite_export_dir (const char         *app,\n                    const char         *branch,\n                    const char         *arch,\n                    GKeyFile           *metadata,\n                    const char * const *previous_ids,\n                    FlatpakContext     *context,\n                    int                 source_parent_fd,\n                    const char         *source_name,\n                    const char         *source_path,\n                    GCancellable       *cancellable,\n                    GError            **error)\n{\n  gboolean ret = FALSE;\n  g_auto(GLnxDirFdIterator) source_iter = {0};\n  g_autoptr(GHashTable) visited_children = NULL;\n  struct dirent *dent;\n  gboolean exports_allowed = FALSE;\n  g_auto(GStrv) allowed_prefixes = NULL;\n  g_auto(GStrv) allowed_extensions = NULL;\n  gboolean require_exact_match = FALSE;\n\n  if (!glnx_dirfd_iterator_init_at (source_parent_fd, source_name, FALSE, &source_iter, error))\n    goto out;\n\n  exports_allowed = flatpak_get_allowed_exports (source_path, app, context,\n                                                 &allowed_extensions, &allowed_prefixes, &require_exact_match);\n\n  visited_children = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, NULL);\n\n  while (TRUE)\n    {\n      struct stat stbuf;\n\n      if (!glnx_dirfd_iterator_next_dent (&source_iter, &dent, cancellable, error))\n        goto out;\n\n      if (dent == NULL)\n        break;\n\n      if (g_hash_table_contains (visited_children, dent->d_name))\n        continue;\n\n      /* Avoid processing the same file again if it was re-created during an export */\n      g_hash_table_insert (visited_children, g_strdup (dent->d_name), GINT_TO_POINTER (1));\n\n      if (fstatat (source_iter.fd, dent->d_name, &stbuf, AT_SYMLINK_NOFOLLOW) == -1)\n        {\n          if (errno == ENOENT)\n            {\n              continue;\n            }\n          else\n            {\n              glnx_set_error_from_errno (error);\n              goto out;\n            }\n        }\n\n      if (S_ISDIR (stbuf.st_mode))\n        {\n          g_autofree char *path = g_build_filename (source_path, dent->d_name, NULL);\n\n          if (!rewrite_export_dir (app, branch, arch, metadata, previous_ids, context,\n                                   source_iter.fd, dent->d_name,\n                                   path, cancellable, error))\n            goto out;\n        }\n      else if (S_ISREG (stbuf.st_mode) && exports_allowed)\n        {\n          g_autofree gchar *name_without_extension = NULL;\n          g_autofree gchar *new_name = NULL;\n          int i;\n\n          for (i = 0; allowed_extensions[i] != NULL; i++)\n            {\n              if (g_str_has_suffix (dent->d_name, allowed_extensions[i]))\n                break;\n            }\n\n          if (allowed_extensions[i] == NULL)\n            {\n              g_warning (\"Invalid extension for %s in app %s, removing.\", dent->d_name, app);\n              if (unlinkat (source_iter.fd, dent->d_name, 0) != 0 && errno != ENOENT)\n                {\n                  glnx_set_error_from_errno (error);\n                  goto out;\n                }\n              continue;\n            }\n\n          name_without_extension = g_strndup (dent->d_name, strlen (dent->d_name) - strlen (allowed_extensions[i]));\n\n          if (!flatpak_name_matches_one_wildcard_prefix (name_without_extension, (const char * const *) allowed_prefixes, require_exact_match))\n            {\n              g_warning (\"Non-prefixed filename %s in app %s, removing.\", dent->d_name, app);\n              if (unlinkat (source_iter.fd, dent->d_name, 0) != 0 && errno != ENOENT)\n                {\n                  glnx_set_error_from_errno (error);\n                  goto out;\n                }\n            }\n\n          if (g_str_has_suffix (dent->d_name, \".desktop\") ||\n              g_str_has_suffix (dent->d_name, \".service\"))\n            {\n              if (!export_desktop_file (app, branch, arch, metadata, previous_ids,\n                                        source_iter.fd, dent->d_name, &stbuf, &new_name, cancellable, error))\n                goto out;\n            }\n\n          if (strcmp (source_name, \"search-providers\") == 0 &&\n              g_str_has_suffix (dent->d_name, \".ini\"))\n            {\n              if (!export_ini_file (source_iter.fd, dent->d_name, INI_FILE_TYPE_SEARCH_PROVIDER,\n                                    &stbuf, &new_name, cancellable, error))\n                goto out;\n            }\n\n          if (strcmp (source_name, \"packages\") == 0 &&\n              g_str_has_suffix (dent->d_name, \".xml\"))\n            {\n              if (!export_mime_file (source_iter.fd, dent->d_name,\n                                     &stbuf, &new_name, cancellable, error))\n                goto out;\n            }\n\n          if (new_name)\n            {\n              g_hash_table_insert (visited_children, g_strdup (new_name), GINT_TO_POINTER (1));\n\n              if (renameat (source_iter.fd, new_name, source_iter.fd, dent->d_name) != 0)\n                {\n                  glnx_set_error_from_errno (error);\n                  goto out;\n                }\n            }\n        }\n      else\n        {\n          g_warning (\"Not exporting file %s of unsupported type.\", dent->d_name);\n          if (unlinkat (source_iter.fd, dent->d_name, 0) != 0 && errno != ENOENT)\n            {\n              glnx_set_error_from_errno (error);\n              goto out;\n            }\n        }\n    }\n\n  ret = TRUE;\nout:\n\n  return ret;\n}\n\nstatic gboolean\nflatpak_rewrite_export_dir (const char         *app,\n                            const char         *branch,\n                            const char         *arch,\n                            GKeyFile           *metadata,\n                            const char * const *previous_ids,\n                            GFile              *source,\n                            GCancellable       *cancellable,\n                            GError            **error)\n{\n  gboolean ret = FALSE;\n  g_autoptr(GFile) parent = g_file_get_parent (source);\n  glnx_autofd int parentfd = -1;\n  g_autofree char *name = g_file_get_basename (source);\n\n  /* Start with a source path of \"\" - we don't care about\n   * the \"export\" component and we want to start path traversal\n   * relative to it. */\n  const char *source_path = \"\";\n  g_autoptr(FlatpakContext) context = flatpak_context_new ();\n\n  if (!flatpak_context_load_metadata (context, metadata, error))\n    return FALSE;\n\n  if (!glnx_opendirat (AT_FDCWD,\n                       flatpak_file_get_path_cached (parent),\n                       TRUE,\n                       &parentfd,\n                       error))\n    return FALSE;\n\n  /* The fds are closed by this call */\n  if (!rewrite_export_dir (app, branch, arch, metadata, previous_ids, context,\n                           parentfd, name, source_path,\n                           cancellable, error))\n    goto out;\n\n  ret = TRUE;\n\nout:\n  return ret;\n}\n\n\nstatic gboolean\nexport_dir (int           source_parent_fd,\n            const char   *source_name,\n            const char   *source_symlink_prefix,\n            const char   *source_relpath,\n            int           destination_parent_fd,\n            const char   *destination_name,\n            GCancellable *cancellable,\n            GError      **error)\n{\n  gboolean ret = FALSE;\n  int res;\n  g_auto(GLnxDirFdIterator) source_iter = {0};\n  glnx_autofd int destination_dfd = -1;\n  struct dirent *dent;\n\n  if (!glnx_dirfd_iterator_init_at (source_parent_fd, source_name, FALSE, &source_iter, error))\n    goto out;\n\n  do\n    res = mkdirat (destination_parent_fd, destination_name, 0755);\n  while (G_UNLIKELY (res == -1 && errno == EINTR));\n  if (res == -1)\n    {\n      if (errno != EEXIST)\n        {\n          glnx_set_error_from_errno (error);\n          goto out;\n        }\n    }\n\n  if (!glnx_opendirat (destination_parent_fd, destination_name, TRUE,\n                       &destination_dfd, error))\n    goto out;\n\n  while (TRUE)\n    {\n      struct stat stbuf;\n\n      if (!glnx_dirfd_iterator_next_dent (&source_iter, &dent, cancellable, error))\n        goto out;\n\n      if (dent == NULL)\n        break;\n\n      if (fstatat (source_iter.fd, dent->d_name, &stbuf, AT_SYMLINK_NOFOLLOW) == -1)\n        {\n          if (errno == ENOENT)\n            {\n              continue;\n            }\n          else\n            {\n              glnx_set_error_from_errno (error);\n              goto out;\n            }\n        }\n\n      if (S_ISDIR (stbuf.st_mode))\n        {\n          g_autofree gchar *child_symlink_prefix = g_build_filename (\"..\", source_symlink_prefix, dent->d_name, NULL);\n          g_autofree gchar *child_relpath = g_strconcat (source_relpath, dent->d_name, \"/\", NULL);\n\n          if (!export_dir (source_iter.fd, dent->d_name, child_symlink_prefix, child_relpath, destination_dfd, dent->d_name,\n                           cancellable, error))\n            goto out;\n        }\n      else if (S_ISREG (stbuf.st_mode))\n        {\n          g_autofree char *symlink_name = g_strdup (\".export-symlink-XXXXXX\");\n          g_autofree gchar *target = NULL;\n\n          target = g_build_filename (source_symlink_prefix, dent->d_name, NULL);\n\n          for (int count = 0; count < 100; count++)\n            {\n              glnx_gen_temp_name (symlink_name);\n\n              if (symlinkat (target, destination_dfd, symlink_name) != 0)\n                {\n                  if (errno == EEXIST)\n                    continue;\n\n                  glnx_set_error_from_errno (error);\n                  goto out;\n                }\n\n              if (renameat (destination_dfd, symlink_name, destination_dfd, dent->d_name) != 0)\n                {\n                  glnx_set_error_from_errno (error);\n                  goto out;\n                }\n\n              break;\n            }\n        }\n    }\n\n  ret = TRUE;\nout:\n\n  return ret;\n}\n\nstatic gboolean\nflatpak_export_dir (GFile        *source,\n                    GFile        *destination,\n                    const char   *symlink_prefix,\n                    GCancellable *cancellable,\n                    GError      **error)\n{\n  const char *exported_subdirs[] = {\n    \"share/applications\",                  \"../..\",\n    \"share/icons\",                         \"../..\",\n    \"share/dbus-1/services\",               \"../../..\",\n    \"share/gnome-shell/search-providers\",  \"../../..\",\n    \"share/mime/packages\",                 \"../../..\",\n    \"bin\",                                 \"..\",\n  };\n  int i;\n\n  for (i = 0; i < G_N_ELEMENTS (exported_subdirs); i = i + 2)\n    {\n      /* The fds are closed by this call */\n      g_autoptr(GFile) sub_source = g_file_resolve_relative_path (source, exported_subdirs[i]);\n      g_autoptr(GFile) sub_destination = g_file_resolve_relative_path (destination, exported_subdirs[i]);\n      g_autofree char *sub_symlink_prefix = g_build_filename (exported_subdirs[i + 1], symlink_prefix, exported_subdirs[i], NULL);\n\n      if (!g_file_query_exists (sub_source, cancellable))\n        continue;\n\n      if (!flatpak_mkdir_p (sub_destination, cancellable, error))\n        return FALSE;\n\n      if (!export_dir (AT_FDCWD, flatpak_file_get_path_cached (sub_source), sub_symlink_prefix, \"\",\n                       AT_FDCWD, flatpak_file_get_path_cached (sub_destination),\n                       cancellable, error))\n        return FALSE;\n    }\n\n  return TRUE;\n}\n\ngboolean\nflatpak_dir_update_exports (FlatpakDir   *self,\n                            const char   *changed_app,\n                            GCancellable *cancellable,\n                            GError      **error)\n{\n  gboolean ret = FALSE;\n  g_autoptr(GFile) exports = NULL;\n  g_autoptr(FlatpakDecomposed) current_ref = NULL;\n  g_autofree char *active_id = NULL;\n  g_autofree char *symlink_prefix = NULL;\n\n  exports = flatpak_dir_get_exports_dir (self);\n\n  if (!flatpak_mkdir_p (exports, cancellable, error))\n    goto out;\n\n  if (changed_app &&\n      (current_ref = flatpak_dir_current_ref (self, changed_app, cancellable)) &&\n      (active_id = flatpak_dir_read_active (self, current_ref, cancellable)))\n    {\n      g_autoptr(GFile) deploy_base = NULL;\n      g_autoptr(GFile) active = NULL;\n      g_autoptr(GFile) export = NULL;\n\n      deploy_base = flatpak_dir_get_deploy_dir (self, current_ref);\n      active = g_file_get_child (deploy_base, active_id);\n      export = g_file_get_child (active, \"export\");\n\n      if (g_file_query_exists (export, cancellable))\n        {\n          symlink_prefix = g_build_filename (\"..\", \"app\", changed_app, \"current\", \"active\", \"export\", NULL);\n          if (!flatpak_export_dir (export, exports,\n                                   symlink_prefix,\n                                   cancellable,\n                                   error))\n            goto out;\n        }\n    }\n\n  if (!flatpak_remove_dangling_symlinks (exports, cancellable, error))\n    goto out;\n\n  ret = TRUE;\n\nout:\n  return ret;\n}\n\nstatic gboolean\nextract_extra_data (FlatpakDir   *self,\n                    const char   *checksum,\n                    GFile        *extradir,\n                    gboolean     *created_extra_data,\n                    GCancellable *cancellable,\n                    GError      **error)\n{\n  g_autoptr(GVariant) detached_metadata = NULL;\n  g_autoptr(GVariant) extra_data = NULL;\n  g_autoptr(GVariant) extra_data_sources = NULL;\n  g_autoptr(GError) local_error = NULL;\n  gsize i, n_extra_data = 0;\n  gsize n_extra_data_sources;\n\n  extra_data_sources = flatpak_repo_get_extra_data_sources (self->repo, checksum,\n                                                            cancellable, &local_error);\n  if (extra_data_sources == NULL)\n    {\n      /* This should protect us against potential errors at the OSTree level\n         (e.g. ostree_repo_load_variant), so that we don't report success. */\n      if (!g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND))\n        {\n          g_propagate_error (error, g_steal_pointer (&local_error));\n          return FALSE;\n        }\n\n      return TRUE;\n    }\n\n  n_extra_data_sources = g_variant_n_children (extra_data_sources);\n  if (n_extra_data_sources == 0)\n    return TRUE;\n\n  g_debug (\"extracting extra data to %s\", flatpak_file_get_path_cached (extradir));\n\n  if (!ostree_repo_read_commit_detached_metadata (self->repo, checksum, &detached_metadata,\n                                                  cancellable, error))\n    {\n      g_prefix_error (error, _(\"While getting detached metadata: \"));\n      return FALSE;\n    }\n\n  if (detached_metadata == NULL)\n    return flatpak_fail_error (error, FLATPAK_ERROR_INVALID_DATA, _(\"Extra data missing in detached metadata\"));\n\n  extra_data = g_variant_lookup_value (detached_metadata, \"xa.extra-data\",\n                                       G_VARIANT_TYPE (\"a(ayay)\"));\n  if (extra_data == NULL)\n    return flatpak_fail_error (error, FLATPAK_ERROR_INVALID_DATA, _(\"Extra data missing in detached metadata\"));\n\n  n_extra_data = g_variant_n_children (extra_data);\n  if (n_extra_data < n_extra_data_sources)\n    return flatpak_fail_error (error, FLATPAK_ERROR_INVALID_DATA, _(\"Extra data missing in detached metadata\"));\n\n  if (!flatpak_mkdir_p (extradir, cancellable, error))\n    {\n      g_prefix_error (error, _(\"While creating extradir: \"));\n      return FALSE;\n    }\n\n  for (i = 0; i < n_extra_data_sources; i++)\n    {\n      g_autofree char *extra_data_sha256 = NULL;\n      const guchar *extra_data_sha256_bytes;\n      const char *extra_data_source_name = NULL;\n      guint64 download_size;\n      gboolean found;\n      int j;\n\n      flatpak_repo_parse_extra_data_sources (extra_data_sources, i,\n                                             &extra_data_source_name,\n                                             &download_size,\n                                             NULL,\n                                             &extra_data_sha256_bytes,\n                                             NULL);\n\n      if (extra_data_sha256_bytes == NULL)\n        return flatpak_fail_error (error, FLATPAK_ERROR_INVALID_DATA, _(\"Invalid checksum for extra data\"));\n\n      extra_data_sha256 = ostree_checksum_from_bytes (extra_data_sha256_bytes);\n\n      /* We need to verify the data in the commitmeta again, because the only signed\n         thing is the commit, which has the source info. We could have accidentally\n         picked up some other commitmeta stuff from the remote, or via the untrusted\n         local-pull of the system helper. */\n      found = FALSE;\n      for (j = 0; j < n_extra_data; j++)\n        {\n          g_autoptr(GVariant) content = NULL;\n          g_autoptr(GFile) dest = NULL;\n          g_autofree char *sha256 = NULL;\n          const char *extra_data_name = NULL;\n          const guchar *data;\n          gsize len;\n\n          g_variant_get_child (extra_data, j, \"(^ay@ay)\",\n                               &extra_data_name,\n                               &content);\n\n          if (strcmp (extra_data_source_name, extra_data_name) != 0)\n            continue;\n\n          data = g_variant_get_data (content);\n          len = g_variant_get_size (content);\n\n          if (len != download_size)\n            return flatpak_fail_error (error, FLATPAK_ERROR_INVALID_DATA, _(\"Wrong size for extra data\"));\n\n          sha256 = g_compute_checksum_for_data (G_CHECKSUM_SHA256, data, len);\n          if (strcmp (sha256, extra_data_sha256) != 0)\n            return flatpak_fail_error (error, FLATPAK_ERROR_INVALID_DATA, _(\"Invalid checksum for extra data\"));\n\n          dest = g_file_get_child (extradir, extra_data_name);\n          if (!g_file_replace_contents (dest,\n                                        g_variant_get_data (content),\n                                        g_variant_get_size (content),\n                                        NULL, FALSE, G_FILE_CREATE_REPLACE_DESTINATION,\n                                        NULL, cancellable, error))\n            {\n              g_prefix_error (error, _(\"While writing extra data file '%s': \"), extra_data_name);\n              return FALSE;\n            }\n          found = TRUE;\n        }\n\n      if (!found)\n        return flatpak_fail_error (error, FLATPAK_ERROR_INVALID_DATA,\n                                   _(\"Extra data %s missing in detached metadata\"),\n                                   extra_data_source_name);\n    }\n\n  *created_extra_data = TRUE;\n\n  return TRUE;\n}\n\nstatic void\nchild_setup (gpointer user_data)\n{\n  GArray *fd_array = user_data;\n  int i;\n\n  /* If no fd_array was specified, don't care. */\n  if (fd_array == NULL)\n    return;\n\n  /* Otherwise, mark not - close-on-exec all the fds in the array */\n  for (i = 0; i < fd_array->len; i++)\n    {\n      int fd = g_array_index (fd_array, int, i);\n\n      /* We also seek all fds to the start, because this lets\n         us use the same fd_array multiple times */\n      if (lseek (fd, 0, SEEK_SET) < 0)\n        g_printerr (\"lseek error in child setup\");\n\n      fcntl (fd, F_SETFD, 0);\n    }\n}\n\nstatic gboolean\napply_extra_data (FlatpakDir   *self,\n                  GFile        *checkoutdir,\n                  GCancellable *cancellable,\n                  GError      **error)\n{\n  g_autoptr(GFile) metadata = NULL;\n  g_autofree char *metadata_contents = NULL;\n  gsize metadata_size;\n  g_autoptr(GKeyFile) metakey = NULL;\n  g_autofree char *id = NULL;\n  g_autofree char *runtime_pref = NULL;\n  g_autoptr(FlatpakDecomposed) runtime_ref = NULL;\n  g_autoptr(FlatpakDeploy) runtime_deploy = NULL;\n  g_autoptr(FlatpakBwrap) bwrap = NULL;\n  g_autoptr(GFile) app_files = NULL;\n  g_autoptr(GFile) apply_extra_file = NULL;\n  g_autoptr(GFile) app_export_file = NULL;\n  g_autoptr(GFile) extra_export_file = NULL;\n  g_autoptr(GFile) extra_files = NULL;\n  g_autoptr(GFile) runtime_files = NULL;\n  g_autoptr(FlatpakContext) app_context = NULL;\n  g_auto(GStrv) minimal_envp = NULL;\n  g_autofree char *runtime_arch = NULL;\n  int exit_status;\n  const char *group = FLATPAK_METADATA_GROUP_APPLICATION;\n  g_autoptr(GError) local_error = NULL;\n\n  apply_extra_file = g_file_resolve_relative_path (checkoutdir, \"files/bin/apply_extra\");\n  if (!g_file_query_exists (apply_extra_file, cancellable))\n    return TRUE;\n\n  metadata = g_file_get_child (checkoutdir, \"metadata\");\n\n  if (!g_file_load_contents (metadata, cancellable, &metadata_contents, &metadata_size, NULL, error))\n    return FALSE;\n\n  metakey = g_key_file_new ();\n  if (!g_key_file_load_from_data (metakey, metadata_contents, metadata_size, 0, error))\n    return FALSE;\n\n  id = g_key_file_get_string (metakey, group, FLATPAK_METADATA_KEY_NAME,\n                              &local_error);\n  if (id == NULL)\n    {\n      group = FLATPAK_METADATA_GROUP_RUNTIME;\n      id = g_key_file_get_string (metakey, group, FLATPAK_METADATA_KEY_NAME,\n                                  NULL);\n      if (id == NULL)\n        {\n          g_propagate_error (error, g_steal_pointer (&local_error));\n          return FALSE;\n        }\n      g_clear_error (&local_error);\n    }\n\n  runtime_pref = g_key_file_get_string (metakey, group,\n                                        FLATPAK_METADATA_KEY_RUNTIME, error);\n  if (runtime_pref == NULL)\n    runtime_pref = g_key_file_get_string (metakey, FLATPAK_METADATA_GROUP_EXTENSION_OF,\n                                          FLATPAK_METADATA_KEY_RUNTIME, NULL);\n  if (runtime_pref == NULL)\n    return FALSE;\n\n  runtime_ref = flatpak_decomposed_new_from_pref (FLATPAK_KINDS_RUNTIME, runtime_pref, error);\n  if (runtime_ref == NULL)\n    return FALSE;\n  runtime_arch = flatpak_decomposed_dup_arch (runtime_ref);\n\n  if (!g_key_file_get_boolean (metakey, FLATPAK_METADATA_GROUP_EXTRA_DATA,\n                               FLATPAK_METADATA_KEY_NO_RUNTIME, NULL))\n    {\n      /* We pass in self here so that we ensure that we find the runtime in case it only\n         exists in this installation (which might be custom) */\n      runtime_deploy = flatpak_find_deploy_for_ref (flatpak_decomposed_get_ref (runtime_ref), NULL, self, cancellable, error);\n      if (runtime_deploy == NULL)\n        return FALSE;\n      runtime_files = flatpak_deploy_get_files (runtime_deploy);\n    }\n\n  app_files = g_file_get_child (checkoutdir, \"files\");\n  app_export_file = g_file_get_child (checkoutdir, \"export\");\n  extra_files = g_file_get_child (app_files, \"extra\");\n  extra_export_file = g_file_get_child (extra_files, \"export\");\n\n  minimal_envp = flatpak_run_get_minimal_env (FALSE, FALSE);\n  bwrap = flatpak_bwrap_new (minimal_envp);\n  flatpak_bwrap_add_args (bwrap, flatpak_get_bwrap (), NULL);\n\n  if (runtime_files)\n    flatpak_bwrap_add_args (bwrap,\n                            \"--ro-bind\", flatpak_file_get_path_cached (runtime_files), \"/usr\",\n                            \"--lock-file\", \"/usr/.ref\",\n                            NULL);\n\n  flatpak_bwrap_add_args (bwrap,\n                          \"--ro-bind\", flatpak_file_get_path_cached (app_files), \"/app\",\n                          \"--bind\", flatpak_file_get_path_cached (extra_files), \"/app/extra\",\n                          \"--chdir\", \"/app/extra\",\n                          /* We run as root in the system-helper case, so drop all caps */\n                          \"--cap-drop\", \"ALL\",\n                          NULL);\n\n  if (!flatpak_run_setup_base_argv (bwrap, runtime_files, NULL, runtime_arch,\n                                    /* Might need multiarch in apply_extra (see e.g. #3742). Should be pretty safe in this limited context */\n                                    FLATPAK_RUN_FLAG_MULTIARCH |\n                                    FLATPAK_RUN_FLAG_NO_SESSION_HELPER | FLATPAK_RUN_FLAG_NO_PROC,\n                                    error))\n    return FALSE;\n\n  app_context = flatpak_context_new ();\n\n  if (!flatpak_run_add_environment_args (bwrap, NULL,\n                                         FLATPAK_RUN_FLAG_NO_SESSION_BUS_PROXY |\n                                         FLATPAK_RUN_FLAG_NO_SYSTEM_BUS_PROXY |\n                                         FLATPAK_RUN_FLAG_NO_A11Y_BUS_PROXY,\n                                         id,\n                                         app_context, NULL, NULL, NULL, cancellable, error))\n    return FALSE;\n\n  flatpak_bwrap_envp_to_args (bwrap);\n\n  flatpak_bwrap_add_arg (bwrap, \"/app/bin/apply_extra\");\n\n  flatpak_bwrap_finish (bwrap);\n\n  g_debug (\"Running /app/bin/apply_extra \");\n\n  /* We run the sandbox without caps, but it can still create files owned by itself with\n   * arbitrary permissions, including setuid myself. This is extra risky in the case where\n   * this runs as root in the system helper case. We canonicalize the permissions at the\n   * end, but to avoid non-canonical permissions leaking out before then we make the\n   * toplevel dir only accessible to the user */\n  if (chmod (flatpak_file_get_path_cached (extra_files), 0700) != 0)\n    {\n      glnx_set_error_from_errno (error);\n      return FALSE;\n    }\n\n  if (!g_spawn_sync (NULL,\n                     (char **) bwrap->argv->pdata,\n                     bwrap->envp,\n                     G_SPAWN_SEARCH_PATH,\n                     child_setup, bwrap->fds,\n                     NULL, NULL,\n                     &exit_status,\n                     error))\n    return FALSE;\n\n  if (!flatpak_canonicalize_permissions (AT_FDCWD, flatpak_file_get_path_cached (extra_files),\n                                         getuid () == 0 ? 0 : -1,\n                                         getuid () == 0 ? 0 : -1,\n                                         error))\n    return FALSE;\n\n  if (exit_status != 0)\n    {\n      g_set_error (error, G_IO_ERROR, G_IO_ERROR_FAILED,\n                   _(\"apply_extra script failed, exit status %d\"), exit_status);\n      return FALSE;\n    }\n\n  if (g_file_query_exists (extra_export_file, cancellable))\n    {\n      if (!flatpak_mkdir_p (app_export_file, cancellable, error))\n        return FALSE;\n      if (!flatpak_cp_a (extra_export_file,\n                         app_export_file,\n                         FLATPAK_CP_FLAGS_MERGE,\n                         cancellable, error))\n        return FALSE;\n    }\n\n  return TRUE;\n}\n\n/* Check the user\u2019s parental controls allow installation of @ref by looking at\n * its cached @deploy_data, which contains its content rating as extracted from\n * its AppData when it was originally downloaded. That\u2019s compared to the\n * parental controls policy loaded from the #MctManager.\n *\n * If @ref should not be installed, an error is returned. */\nstatic gboolean\nflatpak_dir_check_parental_controls (FlatpakDir    *self,\n                                     const char    *ref,\n                                     GBytes        *deploy_data,\n                                     GCancellable  *cancellable,\n                                     GError       **error)\n{\n#ifdef HAVE_LIBMALCONTENT\n#ifdef USE_SYSTEM_HELPER\n  g_autoptr(GError) local_error = NULL;\n  const char *on_session = g_getenv (\"FLATPAK_SYSTEM_HELPER_ON_SESSION\");\n  g_autoptr(GDBusConnection) dbus_connection = NULL;\n  g_autoptr(MctManager) manager = NULL;\n  g_autoptr(MctAppFilter) app_filter = NULL;\n  const char *content_rating_type;\n  g_autoptr(GHashTable) content_rating = NULL;\n  g_autoptr(AutoPolkitAuthority) authority = NULL;\n  g_autoptr(AutoPolkitDetails) details = NULL;\n  g_autoptr(AutoPolkitSubject) subject = NULL;\n  gint subject_uid;\n  g_autoptr(AutoPolkitAuthorizationResult) result = NULL;\n  gboolean authorized;\n  gboolean repo_installation_allowed, app_is_appropriate;\n  \n  /* Assume that root is allowed to install any ref and shouldn't have any\n   * parental controls restrictions applied to them */\n  if (getuid () == 0)\n    return TRUE;\n\n  /* The ostree-metadata and appstream/ branches should not have any parental\n   * controls restrictions. Similarly, for the moment, there is no point in\n   * restricting runtimes. */\n  if (!g_str_has_prefix (ref, \"app/\"))\n    return TRUE;\n\n  g_debug (\"Getting parental controls details for %s from %s\",\n           ref, flatpak_deploy_data_get_origin (deploy_data));\n\n  if (on_session != NULL)\n    {\n      /* FIXME: Instead of skipping the parental controls check in the test\n       * environment, make a mock service for it.\n       * https://github.com/flatpak/flatpak/issues/2993 */\n      g_debug (\"Skipping parental controls check for %s since the \"\n               \"system bus is unavailable in the test environment\", ref);\n      return TRUE;\n    }\n\n  dbus_connection = g_bus_get_sync (G_BUS_TYPE_SYSTEM, cancellable, &local_error);\n  if (dbus_connection == NULL)\n    {\n      g_propagate_error (error, g_steal_pointer (&local_error));\n      return FALSE;\n    }\n\n  if (self->user || self->source_pid == 0)\n    subject = polkit_unix_process_new_for_owner (getpid (), 0, getuid ());\n  else\n    subject = polkit_unix_process_new_for_owner (self->source_pid, 0, -1);\n\n  /* Get the parental controls for the invoking user. */\n  subject_uid = polkit_unix_process_get_uid (POLKIT_UNIX_PROCESS (subject));\n  if (subject_uid == -1)\n    {\n      g_set_error_literal (error, G_DBUS_ERROR, G_DBUS_ERROR_AUTH_FAILED,\n                           \"Failed to get subject UID\");\n      return FALSE;\n    }\n\n  manager = mct_manager_new (dbus_connection);\n  app_filter = mct_manager_get_app_filter (manager, subject_uid,\n                                           MCT_GET_APP_FILTER_FLAGS_INTERACTIVE,\n                                           cancellable, &local_error);\n  if (g_error_matches (local_error, MCT_APP_FILTER_ERROR, MCT_APP_FILTER_ERROR_DISABLED))\n    {\n      g_debug (\"Skipping parental controls check for %s since parental \"\n               \"controls are disabled globally\", ref);\n      return TRUE;\n    }\n  else if (g_error_matches (local_error, G_DBUS_ERROR, G_DBUS_ERROR_SERVICE_UNKNOWN) ||\n           g_error_matches (local_error, G_DBUS_ERROR, G_DBUS_ERROR_NAME_HAS_NO_OWNER))\n    {\n      g_debug (\"Skipping parental controls check for %s since a required \"\n               \"service was not found\", ref);\n      return TRUE;\n    }\n  else if (local_error != NULL)\n    {\n      g_propagate_error (error, g_steal_pointer (&local_error));\n      return FALSE;\n    }\n\n  /* Check the content rating against the parental controls. If the app is\n   * allowed to be installed, return so immediately. */\n  repo_installation_allowed = ((self->user && mct_app_filter_is_user_installation_allowed (app_filter)) ||\n                               (!self->user && mct_app_filter_is_system_installation_allowed (app_filter)));\n\n  content_rating_type = flatpak_deploy_data_get_appdata_content_rating_type (deploy_data);\n  content_rating = flatpak_deploy_data_get_appdata_content_rating (deploy_data);\n  app_is_appropriate = flatpak_oars_check_rating (content_rating, content_rating_type,\n                                                  app_filter);\n\n  if (repo_installation_allowed && app_is_appropriate)\n    {\n      g_debug (\"Parental controls policy satisfied for %s\", ref);\n      return TRUE;\n    }\n\n  /* Otherwise, check polkit to see if the admin is going to allow the user to\n   * override their parental controls policy. We can\u2019t pass any details to this\n   * polkit check, since it could be run by the user or by the system helper,\n   * and non-root users can\u2019t pass details to polkit checks. */\n  authority = polkit_authority_get_sync (NULL, error);\n  if (authority == NULL)\n    return FALSE;\n\n  result = polkit_authority_check_authorization_sync (authority, subject,\n                                                      \"org.freedesktop.Flatpak.override-parental-controls\",\n                                                      NULL,\n                                                      POLKIT_CHECK_AUTHORIZATION_FLAGS_ALLOW_USER_INTERACTION,\n                                                      cancellable, error);\n  if (result == NULL)\n    return FALSE;\n\n  authorized = polkit_authorization_result_get_is_authorized (result);\n\n  if (!authorized)\n    return flatpak_fail_error (error, FLATPAK_ERROR_PERMISSION_DENIED,\n                               /* Translators: The placeholder is for an app ref. */\n                               _(\"Installing %s is not allowed by the policy set by your administrator\"),\n                               ref);\n\n  g_debug (\"Parental controls policy overridden by polkit for %s\", ref);\n#endif  /* USE_SYSTEM_HELPER */\n#endif  /* HAVE_LIBMALCONTENT */\n\n  return TRUE;\n}\n\n/* We create a deploy ref for the currently deployed version of all refs to avoid\n   deployed commits being pruned when e.g. we pull --no-deploy. */\nstatic gboolean\nflatpak_dir_update_deploy_ref (FlatpakDir *self,\n                               const char *ref,\n                               const char *checksum,\n                               GError    **error)\n{\n  g_autofree char *deploy_ref = g_strconcat (\"deploy/\", ref, NULL);\n\n  if (!ostree_repo_set_ref_immediate (self->repo, NULL, deploy_ref, checksum, NULL, error))\n    return FALSE;\n\n  return TRUE;\n}\n\ngboolean\nflatpak_dir_deploy (FlatpakDir          *self,\n                    const char          *origin,\n                    FlatpakDecomposed   *ref,\n                    const char          *checksum_or_latest,\n                    const char * const * subpaths,\n                    const char * const * previous_ids,\n                    GCancellable        *cancellable,\n                    GError             **error)\n{\n  g_autofree char *resolved_ref = NULL;\n  g_autofree char *ref_id = NULL;\n  g_autoptr(GFile) root = NULL;\n  g_autoptr(GFile) deploy_base = NULL;\n  g_autoptr(GFile) checkoutdir = NULL;\n  g_autoptr(GFile) bindir = NULL;\n  g_autofree char *checkoutdirpath = NULL;\n  g_autoptr(GFile) real_checkoutdir = NULL;\n  g_autoptr(GFile) dotref = NULL;\n  g_autoptr(GFile) files_etc = NULL;\n  g_autoptr(GFile) deploy_data_file = NULL;\n  g_autoptr(GVariant) commit_data = NULL;\n  g_autoptr(GBytes) deploy_data = NULL;\n  g_autoptr(GFile) export = NULL;\n  g_autoptr(GFile) extradir = NULL;\n  g_autoptr(GKeyFile) keyfile = NULL;\n  guint64 installed_size = 0;\n  OstreeRepoCheckoutAtOptions options = { 0, };\n  const char *checksum;\n  glnx_autofd int checkoutdir_dfd = -1;\n  g_autoptr(GFile) tmp_dir_template = NULL;\n  g_autofree char *tmp_dir_path = NULL;\n  const char *xa_ref = NULL;\n  g_autofree char *checkout_basename = NULL;\n  gboolean created_extra_data = FALSE;\n  g_autoptr(GVariant) commit_metadata = NULL;\n  g_auto(GLnxLockFile) lock = { 0, };\n  g_autoptr(GFile) metadata_file = NULL;\n  g_autofree char *metadata_contents = NULL;\n  gboolean is_oci;\n\n  if (!flatpak_dir_ensure_repo (self, cancellable, error))\n    return FALSE;\n\n  ref_id = flatpak_decomposed_dup_id (ref);\n\n  /* Keep a shared repo lock to avoid prunes removing objects we're relying on\n   * while we do the checkout. This could happen if the ref changes after we\n   * read its current value for the checkout. */\n  if (!flatpak_dir_repo_lock (self, &lock, LOCK_SH, cancellable, error))\n    return FALSE;\n\n  deploy_base = flatpak_dir_get_deploy_dir (self, ref);\n\n  if (checksum_or_latest == NULL)\n    {\n      g_debug (\"No checksum specified, getting tip of %s from origin %s\", flatpak_decomposed_get_ref (ref), origin);\n\n      resolved_ref = flatpak_dir_read_latest (self, origin, flatpak_decomposed_get_ref (ref), NULL, cancellable, error);\n      if (resolved_ref == NULL)\n        {\n          g_prefix_error (error, _(\"While trying to resolve ref %s: \"), flatpak_decomposed_get_ref (ref));\n          return FALSE;\n        }\n\n      checksum = resolved_ref;\n      g_debug (\"tip resolved to: %s\", checksum);\n    }\n  else\n    {\n      checksum = checksum_or_latest;\n      g_debug (\"Looking for checksum %s in local repo\", checksum);\n      if (!ostree_repo_read_commit (self->repo, checksum, NULL, NULL, cancellable, NULL))\n        return flatpak_fail_error (error, FLATPAK_ERROR_INVALID_DATA, _(\"%s is not available\"), flatpak_decomposed_get_ref (ref));\n    }\n\n  if (!ostree_repo_load_commit (self->repo, checksum, &commit_data, NULL, error))\n    return FALSE;\n\n  commit_metadata = g_variant_get_child_value (commit_data, 0);\n  checkout_basename = flatpak_dir_get_deploy_subdir (self, checksum, subpaths);\n\n  real_checkoutdir = g_file_get_child (deploy_base, checkout_basename);\n  if (g_file_query_exists (real_checkoutdir, cancellable))\n    return flatpak_fail_error (error, FLATPAK_ERROR_ALREADY_INSTALLED,\n                               _(\"%s commit %s already installed\"), flatpak_decomposed_get_ref (ref), checksum);\n\n  g_autofree char *template = g_strdup_printf (\".%s-XXXXXX\", checkout_basename);\n  tmp_dir_template = g_file_get_child (deploy_base, template);\n  tmp_dir_path = g_file_get_path (tmp_dir_template);\n\n  if (g_mkdtemp_full (tmp_dir_path, 0755) == NULL)\n    {\n      g_set_error_literal (error, G_IO_ERROR, G_IO_ERROR_FAILED,\n                           _(\"Can't create deploy directory\"));\n      return FALSE;\n    }\n\n  checkoutdir = g_file_new_for_path (tmp_dir_path);\n\n  if (!ostree_repo_read_commit (self->repo, checksum, &root, NULL, cancellable, error))\n    {\n      g_prefix_error (error, _(\"Failed to read commit %s: \"), checksum);\n      return FALSE;\n    }\n\n  if (!flatpak_repo_collect_sizes (self->repo, root, &installed_size, NULL, cancellable, error))\n    return FALSE;\n\n  options.mode = OSTREE_REPO_CHECKOUT_MODE_USER;\n  options.overwrite_mode = OSTREE_REPO_CHECKOUT_OVERWRITE_UNION_FILES;\n  options.enable_fsync = FALSE; /* We checkout to a temp dir and sync before moving it in place */\n  options.bareuseronly_dirs = TRUE; /* https://github.com/ostreedev/ostree/pull/927 */\n  checkoutdirpath = g_file_get_path (checkoutdir);\n\n  if (subpaths == NULL || *subpaths == NULL)\n    {\n      if (!ostree_repo_checkout_at (self->repo, &options,\n                                    AT_FDCWD, checkoutdirpath,\n                                    checksum,\n                                    cancellable, error))\n        {\n          g_prefix_error (error, _(\"While trying to checkout %s into %s: \"), checksum, checkoutdirpath);\n          return FALSE;\n        }\n    }\n  else\n    {\n      g_autoptr(GFile) files = g_file_get_child (checkoutdir, \"files\");\n      int i;\n\n      if (!g_file_make_directory_with_parents (files, cancellable, error))\n        return FALSE;\n\n      options.subpath = \"/metadata\";\n\n      if (!ostree_repo_checkout_at (self->repo, &options,\n                                    AT_FDCWD, checkoutdirpath,\n                                    checksum,\n                                    cancellable, error))\n        {\n          g_prefix_error (error, _(\"While trying to checkout metadata subpath: \"));\n          return FALSE;\n        }\n\n      for (i = 0; subpaths[i] != NULL; i++)\n        {\n          g_autofree char *subpath = g_build_filename (\"/files\", subpaths[i], NULL);\n          g_autofree char *dstpath = g_build_filename (checkoutdirpath, \"/files\", subpaths[i], NULL);\n          g_autofree char *dstpath_parent = g_path_get_dirname (dstpath);\n          g_autoptr(GFile) child = NULL;\n\n          child = g_file_resolve_relative_path (root, subpath);\n\n          if (!g_file_query_exists (child, cancellable))\n            {\n              g_debug (\"subpath %s not in tree\", subpaths[i]);\n              continue;\n            }\n\n          if (g_mkdir_with_parents (dstpath_parent, 0755))\n            {\n              glnx_set_error_from_errno (error);\n              return FALSE;\n            }\n\n          options.subpath = subpath;\n          if (!ostree_repo_checkout_at (self->repo, &options,\n                                        AT_FDCWD, dstpath,\n                                        checksum,\n                                        cancellable, error))\n            {\n              g_prefix_error (error, _(\"While trying to checkout subpath \u2018%s\u2019: \"), subpath);\n              return FALSE;\n            }\n        }\n    }\n\n  /* Extract any extra data */\n  extradir = g_file_resolve_relative_path (checkoutdir, \"files/extra\");\n  if (!flatpak_rm_rf (extradir, cancellable, error))\n    {\n      g_prefix_error (error, _(\"While trying to remove existing extra dir: \"));\n      return FALSE;\n    }\n\n  if (!extract_extra_data (self, checksum, extradir, &created_extra_data, cancellable, error))\n    return FALSE;\n\n  if (created_extra_data)\n    {\n      if (!apply_extra_data (self, checkoutdir, cancellable, error))\n        {\n          g_prefix_error (error, _(\"While trying to apply extra data: \"));\n          return FALSE;\n        }\n    }\n\n  g_variant_lookup (commit_metadata, \"xa.ref\", \"&s\", &xa_ref);\n  if (xa_ref != NULL)\n    {\n      gboolean gpg_verify_summary;\n\n      if (!ostree_repo_remote_get_gpg_verify_summary (self->repo, origin, &gpg_verify_summary, error))\n        return FALSE;\n\n      if (gpg_verify_summary)\n        {\n          /* If we're using signed summaries, then the security is really due to the signatures on\n           * the summary, and the xa.ref is not needed for security. In particular, endless are\n           * currently using one single commit on multiple branches to handle devel/stable promotion.\n           * So, to support this we report branch discrepancies as a warning, rather than as an error.\n           * See https://github.com/flatpak/flatpak/pull/1013 for more discussion.\n           */\n          FlatpakDecomposed *checkout_ref = ref;\n          g_autoptr(FlatpakDecomposed) commit_ref = NULL;\n\n          commit_ref = flatpak_decomposed_new_from_ref (xa_ref, error);\n          if (commit_ref == NULL)\n            {\n              g_prefix_error (error, _(\"Invalid commit ref %s: \"), xa_ref);\n              return FALSE;\n            }\n\n          /* Fatal if kind/name/arch don't match. Warn for branch mismatch. */\n          if (!flatpak_decomposed_equal_except_branch (checkout_ref, commit_ref))\n            {\n              g_set_error (error, G_IO_ERROR, G_IO_ERROR_PERMISSION_DENIED,\n                           _(\"Deployed ref %s does not match commit (%s)\"),\n                           flatpak_decomposed_get_ref (ref), xa_ref);\n              return FALSE;\n            }\n\n          if (strcmp (flatpak_decomposed_get_branch (checkout_ref), flatpak_decomposed_get_branch (commit_ref)) != 0)\n            g_warning (_(\"Deployed ref %s branch does not match commit (%s)\"),\n                       flatpak_decomposed_get_ref (ref), xa_ref);\n        }\n      else if (strcmp (flatpak_decomposed_get_ref (ref), xa_ref) != 0)\n        {\n          g_set_error (error, G_IO_ERROR, G_IO_ERROR_PERMISSION_DENIED,\n                       _(\"Deployed ref %s does not match commit (%s)\"), flatpak_decomposed_get_ref (ref), xa_ref);\n          return FALSE;\n        }\n    }\n\n  keyfile = g_key_file_new ();\n  metadata_file = g_file_resolve_relative_path (checkoutdir, \"metadata\");\n  if (g_file_load_contents (metadata_file, NULL,\n                            &metadata_contents, NULL, NULL, NULL))\n    {\n      if (!g_key_file_load_from_data (keyfile,\n                                      metadata_contents,\n                                      -1,\n                                      0, error))\n        return FALSE;\n\n      if (!flatpak_check_required_version (flatpak_decomposed_get_ref (ref), keyfile, error))\n        return FALSE;\n    }\n\n  /* Check the metadata in the commit to make sure it matches the actual\n   * deployed metadata, in case we relied on the one in the commit for\n   * a decision\n   * Note: For historical reason we don't enforce commits to contain xa.metadata\n   * since this was lacking in fedora builds.\n   */\n  is_oci = flatpak_dir_get_remote_oci (self, origin);\n  if (!validate_commit_metadata (commit_data, flatpak_decomposed_get_ref (ref),\n                                 metadata_contents, !is_oci, error))\n    return FALSE;\n\n  dotref = g_file_resolve_relative_path (checkoutdir, \"files/.ref\");\n  if (!g_file_replace_contents (dotref, \"\", 0, NULL, FALSE,\n                                G_FILE_CREATE_REPLACE_DESTINATION, NULL, cancellable, error))\n    return TRUE;\n\n  export = g_file_get_child (checkoutdir, \"export\");\n\n  /* Never export any binaries bundled with the app */\n  bindir = g_file_get_child (export, \"bin\");\n  if (!flatpak_rm_rf (bindir, cancellable, error))\n    return FALSE;\n\n  if (flatpak_decomposed_is_runtime (ref))\n    {\n      /* Ensure that various files exists as regular files in /usr/etc, as we\n         want to bind-mount over them */\n      files_etc = g_file_resolve_relative_path (checkoutdir, \"files/etc\");\n      if (g_file_query_exists (files_etc, cancellable))\n        {\n          char *etcfiles[] = {\"passwd\", \"group\", \"machine-id\" };\n          g_autoptr(GFile) etc_resolve_conf = g_file_get_child (files_etc, \"resolv.conf\");\n          int i;\n          for (i = 0; i < G_N_ELEMENTS (etcfiles); i++)\n            {\n              g_autoptr(GFile) etc_file = g_file_get_child (files_etc, etcfiles[i]);\n              GFileType type;\n\n              type = g_file_query_file_type (etc_file, G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n                                             cancellable);\n              if (type == G_FILE_TYPE_REGULAR)\n                continue;\n\n              if (type != G_FILE_TYPE_UNKNOWN)\n                {\n                  /* Already exists, but not regular, probably symlink. Remove it */\n                  if (!g_file_delete (etc_file, cancellable, error))\n                    return FALSE;\n                }\n\n              if (!g_file_replace_contents (etc_file, \"\", 0, NULL, FALSE,\n                                            G_FILE_CREATE_REPLACE_DESTINATION,\n                                            NULL, cancellable, error))\n                return FALSE;\n            }\n\n          if (g_file_query_exists (etc_resolve_conf, cancellable) &&\n              !g_file_delete (etc_resolve_conf, cancellable, error))\n            return TRUE;\n\n          if (!g_file_make_symbolic_link (etc_resolve_conf,\n                                          \"/run/host/monitor/resolv.conf\",\n                                          cancellable, error))\n            return FALSE;\n        }\n\n      /* Runtime should never export anything */\n      if (!flatpak_rm_rf (export, cancellable, error))\n        return FALSE;\n    }\n  else /* is app */\n    {\n      g_autofree char *ref_arch = flatpak_decomposed_dup_arch (ref);\n      g_autofree char *ref_branch = flatpak_decomposed_dup_branch (ref);\n      g_autoptr(GFile) wrapper = g_file_get_child (bindir, ref_id);\n      g_autofree char *escaped_app = maybe_quote (ref_id);\n      g_autofree char *escaped_branch = maybe_quote (ref_branch);\n      g_autofree char *escaped_arch = maybe_quote (ref_arch);\n      g_autofree char *bin_data = NULL;\n      int r;\n\n      if (!flatpak_mkdir_p (bindir, cancellable, error))\n        return FALSE;\n\n      if (!flatpak_rewrite_export_dir (ref_id, ref_branch, ref_arch,\n                                       keyfile, previous_ids, export,\n                                       cancellable,\n                                       error))\n        return FALSE;\n\n      bin_data = g_strdup_printf (\"#!/bin/sh\\nexec %s/flatpak run --branch=%s --arch=%s %s \\\"$@\\\"\\n\",\n                                  FLATPAK_BINDIR, escaped_branch, escaped_arch, escaped_app);\n      if (!g_file_replace_contents (wrapper, bin_data, strlen (bin_data), NULL, FALSE,\n                                    G_FILE_CREATE_REPLACE_DESTINATION, NULL, cancellable, error))\n        return FALSE;\n\n      do\n        r = fchmodat (AT_FDCWD, flatpak_file_get_path_cached (wrapper), 0755, 0);\n      while (G_UNLIKELY (r == -1 && errno == EINTR));\n      if (r == -1)\n        return glnx_throw_errno_prefix (error, \"fchmodat\");\n    }\n\n  deploy_data = flatpak_dir_new_deploy_data (self,\n                                             checkoutdir,\n                                             commit_data,\n                                             commit_metadata,\n                                             keyfile,\n                                             ref_id,\n                                             origin,\n                                             checksum,\n                                             (char **) subpaths,\n                                             installed_size,\n                                             previous_ids);\n\n  /* Check the app is actually allowed to be used by this user. This can block\n   * on getting authorisation. */\n  if (!flatpak_dir_check_parental_controls (self, flatpak_decomposed_get_ref (ref), deploy_data, cancellable, error))\n    return FALSE;\n\n  deploy_data_file = g_file_get_child (checkoutdir, \"deploy\");\n  if (!flatpak_bytes_save (deploy_data_file, deploy_data, cancellable, error))\n    return FALSE;\n\n  if (!glnx_opendirat (AT_FDCWD, checkoutdirpath, TRUE, &checkoutdir_dfd, error))\n    return FALSE;\n\n  if (syncfs (checkoutdir_dfd) != 0)\n    {\n      glnx_set_error_from_errno (error);\n      return FALSE;\n    }\n\n  if (!g_file_move (checkoutdir, real_checkoutdir, G_FILE_COPY_NO_FALLBACK_FOR_MOVE,\n                    cancellable, NULL, NULL, error))\n    return FALSE;\n\n  if (!flatpak_dir_set_active (self, ref, checkout_basename, cancellable, error))\n    return FALSE;\n\n  if (!flatpak_dir_update_deploy_ref (self, flatpak_decomposed_get_ref (ref), checksum, error))\n    return FALSE;\n\n  return TRUE;\n}\n\n/* -origin remotes are deleted when the last ref referring to it is undeployed */\nvoid\nflatpak_dir_prune_origin_remote (FlatpakDir *self,\n                                 const char *remote)\n{\n  if (remote != NULL &&\n      g_str_has_suffix (remote, \"-origin\") &&\n      flatpak_dir_get_remote_noenumerate (self, remote) &&\n      !flatpak_dir_remote_has_deploys (self, remote))\n    {\n      if (flatpak_dir_use_system_helper (self, NULL))\n        {\n          const char *installation = flatpak_dir_get_id (self);\n          g_autoptr(GVariant) gpg_data_v = NULL;\n\n          gpg_data_v = g_variant_ref_sink (g_variant_new_from_data (G_VARIANT_TYPE (\"ay\"), \"\", 0, TRUE, NULL, NULL));\n\n          flatpak_dir_system_helper_call_configure_remote (self,\n                                                           FLATPAK_HELPER_CONFIGURE_FLAGS_NONE,\n                                                           remote,\n                                                           \"\",\n                                                           gpg_data_v,\n                                                           installation ? installation : \"\",\n                                                           NULL, NULL);\n        }\n      else\n        flatpak_dir_remove_remote (self, FALSE, remote, NULL, NULL);\n    }\n}\n\ngboolean\nflatpak_dir_deploy_install (FlatpakDir        *self,\n                            FlatpakDecomposed *ref,\n                            const char        *origin,\n                            const char       **subpaths,\n                            const char       **previous_ids,\n                            gboolean           reinstall,\n                            GCancellable      *cancellable,\n                            GError           **error)\n{\n  g_auto(GLnxLockFile) lock = { 0, };\n  g_autoptr(GFile) deploy_base = NULL;\n  g_autoptr(GFile) old_deploy_dir = NULL;\n  gboolean created_deploy_base = FALSE;\n  gboolean ret = FALSE;\n  g_autoptr(GError) local_error = NULL;\n  g_autofree char *remove_ref_from_remote = NULL;\n  g_autofree char *commit = NULL;\n  g_autofree char *old_active = NULL;\n\n  if (!flatpak_dir_lock (self, &lock,\n                         cancellable, error))\n    goto out;\n\n  old_deploy_dir = flatpak_dir_get_if_deployed (self, ref, NULL, cancellable);\n  if (old_deploy_dir != NULL)\n    {\n      old_active = flatpak_dir_read_active (self, ref, cancellable);\n\n      if (reinstall)\n        {\n          g_autoptr(GBytes) old_deploy = NULL;\n          const char *old_origin;\n\n          old_deploy = flatpak_load_deploy_data (old_deploy_dir, ref, self->repo, FLATPAK_DEPLOY_VERSION_ANY, cancellable, error);\n          if (old_deploy == NULL)\n            goto out;\n\n          /* If the old install was from a different remote, remove the ref */\n          old_origin = flatpak_deploy_data_get_origin (old_deploy);\n          if (strcmp (old_origin, origin) != 0)\n            remove_ref_from_remote = g_strdup (old_origin);\n\n          g_debug (\"Removing old deployment for reinstall\");\n          if (!flatpak_dir_undeploy (self, ref, old_active,\n                                     TRUE, FALSE,\n                                     cancellable, error))\n            goto out;\n        }\n      else\n        {\n          g_autofree char *id = flatpak_decomposed_dup_id (ref);\n          g_autofree char *branch = flatpak_decomposed_dup_branch (ref);\n          g_set_error (error, FLATPAK_ERROR, FLATPAK_ERROR_ALREADY_INSTALLED,\n                       _(\"%s branch %s already installed\"), id, branch);\n          goto out;\n        }\n    }\n\n  deploy_base = flatpak_dir_get_deploy_dir (self, ref);\n  if (!g_file_make_directory_with_parents (deploy_base, cancellable, &local_error))\n    {\n      if (!g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_EXISTS))\n        {\n          g_propagate_error (error, g_steal_pointer (&local_error));\n          goto out;\n        }\n    }\n\n  /* After we create the deploy base we must goto out on errors */\n  created_deploy_base = TRUE;\n\n  if (!flatpak_dir_deploy (self, origin, ref, NULL, (const char * const *) subpaths,\n                           previous_ids, cancellable, error))\n    goto out;\n\n  if (flatpak_decomposed_is_app (ref))\n    {\n      g_autofree char *id = flatpak_decomposed_dup_id (ref);\n\n      if (!flatpak_dir_make_current_ref (self, ref, cancellable, error))\n        goto out;\n\n      if (!flatpak_dir_update_exports (self, id, cancellable, error))\n        goto out;\n    }\n\n  /* Remove old ref if the reinstalled was from a different remote */\n  if (remove_ref_from_remote != NULL)\n    {\n      if (!flatpak_dir_remove_ref (self, remove_ref_from_remote, flatpak_decomposed_get_ref (ref), cancellable, error))\n        goto out;\n\n      flatpak_dir_prune_origin_remote (self, remove_ref_from_remote);\n    }\n\n  /* Release lock before doing possibly slow prune */\n  glnx_release_lock_file (&lock);\n\n  flatpak_dir_cleanup_removed (self, cancellable, NULL);\n\n  if (!flatpak_dir_mark_changed (self, error))\n    goto out;\n\n  ret = TRUE;\n\n  commit = flatpak_dir_read_active (self, ref, cancellable);\n  flatpak_dir_log (self, \"deploy install\", origin, flatpak_decomposed_get_ref (ref), commit, old_active, NULL,\n                   \"Installed %s from %s\", flatpak_decomposed_get_ref (ref), origin);\n\nout:\n  if (created_deploy_base && !ret)\n    flatpak_rm_rf (deploy_base, cancellable, NULL);\n\n  return ret;\n}\n\n\ngboolean\nflatpak_dir_deploy_update (FlatpakDir        *self,\n                           FlatpakDecomposed *ref,\n                           const char        *checksum_or_latest,\n                           const char       **opt_subpaths,\n                           const char       **opt_previous_ids,\n                           GCancellable      *cancellable,\n                           GError           **error)\n{\n  g_autoptr(GBytes) old_deploy_data = NULL;\n  g_auto(GLnxLockFile) lock = { 0, };\n  g_autofree const char **old_subpaths = NULL;\n  g_autofree char *old_active = NULL;\n  const char *old_origin;\n  g_autofree char *commit = NULL;\n  g_auto(GStrv) previous_ids = NULL;\n\n  if (!flatpak_dir_lock (self, &lock,\n                         cancellable, error))\n    return FALSE;\n\n  old_deploy_data = flatpak_dir_get_deploy_data (self, ref,\n                                                 FLATPAK_DEPLOY_VERSION_ANY,\n                                                 cancellable, error);\n  if (old_deploy_data == NULL)\n    return FALSE;\n\n  old_active = flatpak_dir_read_active (self, ref, cancellable);\n\n  old_origin = flatpak_deploy_data_get_origin (old_deploy_data);\n  old_subpaths = flatpak_deploy_data_get_subpaths (old_deploy_data);\n\n  previous_ids = g_strdupv ((char **) flatpak_deploy_data_get_previous_ids (old_deploy_data, NULL));\n  if (opt_previous_ids)\n    {\n      g_auto(GStrv) old_previous_ids = previous_ids;\n      previous_ids = flatpak_strv_merge (old_previous_ids, (char **) opt_previous_ids);\n    }\n\n  if (!flatpak_dir_deploy (self,\n                           old_origin,\n                           ref,\n                           checksum_or_latest,\n                           opt_subpaths ? opt_subpaths : old_subpaths,\n                           (const char * const *) previous_ids,\n                           cancellable, error))\n    return FALSE;\n\n  if (old_active &&\n      !flatpak_dir_undeploy (self, ref, old_active,\n                             TRUE, FALSE,\n                             cancellable, error))\n    return FALSE;\n\n  if (flatpak_decomposed_is_app (ref))\n    {\n      g_autofree char *id = flatpak_decomposed_dup_id (ref);\n\n      if (!flatpak_dir_update_exports (self, id, cancellable, error))\n        return FALSE;\n    }\n\n  /* Release lock before doing possibly slow prune */\n  glnx_release_lock_file (&lock);\n\n  if (!flatpak_dir_mark_changed (self, error))\n    return FALSE;\n\n  flatpak_dir_cleanup_removed (self, cancellable, NULL);\n\n  commit = flatpak_dir_read_active (self, ref, cancellable);\n  flatpak_dir_log (self, \"deploy update\", old_origin, flatpak_decomposed_get_ref (ref), commit, old_active, NULL,\n                   \"Updated %s from %s\", flatpak_decomposed_get_ref (ref), old_origin);\n\n  return TRUE;\n}\n\nstatic FlatpakOciRegistry *\nflatpak_dir_create_system_child_oci_registry (FlatpakDir   *self,\n                                              GLnxLockFile *file_lock,\n                                              const char   *token,\n                                              GError      **error)\n{\n  g_autoptr(GFile) cache_dir = NULL;\n  g_autoptr(GFile) repo_dir = NULL;\n  g_autofree char *repo_url = NULL;\n  g_autofree char *tmpdir_name = NULL;\n  g_autoptr(FlatpakOciRegistry) new_registry = NULL;\n\n  g_assert (!self->user);\n\n  if (!flatpak_dir_ensure_repo (self, NULL, error))\n    return NULL;\n\n  cache_dir = flatpak_ensure_system_user_cache_dir_location (error);\n  if (cache_dir == NULL)\n    return NULL;\n\n  if (!flatpak_allocate_tmpdir (AT_FDCWD,\n                                flatpak_file_get_path_cached (cache_dir),\n                                \"child-oci-\", &tmpdir_name,\n                                NULL,\n                                file_lock,\n                                NULL,\n                                NULL, error))\n    return NULL;\n\n  repo_dir = g_file_get_child (cache_dir, tmpdir_name);\n  repo_url = g_file_get_uri (repo_dir);\n\n  new_registry = flatpak_oci_registry_new (repo_url, TRUE, -1,\n                                           NULL, error);\n  if (new_registry == NULL)\n    return NULL;\n\n  flatpak_oci_registry_set_token (new_registry, token);\n\n  return g_steal_pointer (&new_registry);\n}\n\nstatic OstreeRepo *\nflatpak_dir_create_child_repo (FlatpakDir   *self,\n                               GFile        *cache_dir,\n                               GLnxLockFile *file_lock,\n                               const char   *optional_commit,\n                               GError      **error)\n{\n  g_autoptr(GFile) repo_dir = NULL;\n  g_autoptr(GFile) repo_dir_config = NULL;\n  g_autoptr(OstreeRepo) repo = NULL;\n  g_autofree char *tmpdir_name = NULL;\n  g_autoptr(OstreeRepo) new_repo = NULL;\n  g_autoptr(GKeyFile) config = NULL;\n  g_autofree char *current_mode = NULL;\n  GKeyFile *orig_config = NULL;\n  g_autofree char *orig_min_free_space_percent = NULL;\n  g_autofree char *orig_min_free_space_size = NULL;\n\n  /* We use bare-user-only here now, which means we don't need xattrs\n   * for the child repo. This only works as long as the pulled repo\n   * is valid in a bare-user-only repo, i.e. doesn't have xattrs or\n   * weird permissions, because then the pull into the system repo\n   * would complain that the checksum was wrong. However, by now all\n   * flatpak builds are likely to be valid, so this is fine.\n   */\n  OstreeRepoMode mode = OSTREE_REPO_MODE_BARE_USER_ONLY;\n  const char *mode_str = \"bare-user-only\";\n\n  if (!flatpak_dir_ensure_repo (self, NULL, error))\n    return NULL;\n\n  orig_config = ostree_repo_get_config (self->repo);\n\n  if (!flatpak_allocate_tmpdir (AT_FDCWD,\n                                flatpak_file_get_path_cached (cache_dir),\n                                \"repo-\", &tmpdir_name,\n                                NULL,\n                                file_lock,\n                                NULL,\n                                NULL, error))\n    return NULL;\n\n  repo_dir = g_file_get_child (cache_dir, tmpdir_name);\n\n  new_repo = ostree_repo_new (repo_dir);\n\n  repo_dir_config = g_file_get_child (repo_dir, \"config\");\n  if (!g_file_query_exists (repo_dir_config, NULL))\n    {\n      if (!ostree_repo_create (new_repo, mode, NULL, error))\n        return NULL;\n    }\n  else\n    {\n      /* Try to open, but on failure, re-create */\n      if (!ostree_repo_open (new_repo, NULL, NULL))\n        {\n          flatpak_rm_rf (repo_dir, NULL, NULL);\n          if (!ostree_repo_create (new_repo, mode, NULL, error))\n            return NULL;\n        }\n    }\n\n  config = ostree_repo_copy_config (new_repo);\n\n  /* Verify that the mode is the expected one; if it isn't, recreate the repo */\n  current_mode = g_key_file_get_string (config, \"core\", \"mode\", NULL);\n  if (current_mode == NULL || g_strcmp0 (current_mode, mode_str) != 0)\n    {\n      flatpak_rm_rf (repo_dir, NULL, NULL);\n\n      /* Re-initialize the object because its dir's contents have been deleted (and it\n       * holds internal references to them) */\n      g_object_unref (new_repo);\n      new_repo = ostree_repo_new (repo_dir);\n\n      if (!ostree_repo_create (new_repo, mode, NULL, error))\n        return NULL;\n\n      /* Reload the repo config */\n      g_key_file_free (config);\n      config = ostree_repo_copy_config (new_repo);\n    }\n\n  /* Ensure the config is updated */\n  g_key_file_set_string (config, \"core\", \"parent\",\n                         flatpak_file_get_path_cached (ostree_repo_get_path (self->repo)));\n\n  /* Copy the min space percent value so it affects the temporary repo too */\n  orig_min_free_space_percent = g_key_file_get_value (orig_config, \"core\", \"min-free-space-percent\", NULL);\n  if (orig_min_free_space_percent)\n    g_key_file_set_value (config, \"core\", \"min-free-space-percent\", orig_min_free_space_percent);\n\n  /* Copy the min space size value so it affects the temporary repo too */\n  orig_min_free_space_size = g_key_file_get_value (orig_config, \"core\", \"min-free-space-size\", NULL);\n  if (orig_min_free_space_size)\n    g_key_file_set_value (config, \"core\", \"min-free-space-size\", orig_min_free_space_size);\n\n  if (!ostree_repo_write_config (new_repo, config, error))\n    return NULL;\n\n  /* We need to reopen to apply the parent config */\n  repo = ostree_repo_new (repo_dir);\n\n  if (!ostree_repo_open (repo, NULL, error))\n    return NULL;\n\n  /* We don't need to sync the child repos, they are never used for stable storage, and we\n     verify + fsync when importing to stable storage */\n  ostree_repo_set_disable_fsync (repo, TRUE);\n\n  g_autoptr(GFile) user_cache_dir = flatpak_ensure_user_cache_dir_location (error);\n  if (user_cache_dir == NULL)\n    return FALSE;\n\n  if (!ostree_repo_set_cache_dir (repo, AT_FDCWD,\n                                  flatpak_file_get_path_cached (user_cache_dir),\n                                  NULL, error))\n    return FALSE;\n\n  /* Create a commitpartial in the child repo if needed to ensure we download everything, because\n     any commitpartial state in the parent will not otherwise be inherited */\n  if (optional_commit)\n    {\n      g_autofree char *commitpartial_basename = g_strconcat (optional_commit, \".commitpartial\", NULL);\n      g_autoptr(GFile) orig_commitpartial =\n        flatpak_build_file (ostree_repo_get_path (self->repo),\n                            \"state\", commitpartial_basename, NULL);\n      if (g_file_query_exists (orig_commitpartial, NULL))\n        {\n          g_autoptr(GFile) commitpartial =\n            flatpak_build_file (ostree_repo_get_path (repo),\n                                \"state\", commitpartial_basename, NULL);\n          g_file_replace_contents (commitpartial, \"\", 0, NULL, FALSE, G_FILE_CREATE_REPLACE_DESTINATION, NULL, NULL, NULL);\n        }\n    }\n  return g_steal_pointer (&repo);\n}\n\nstatic OstreeRepo *\nflatpak_dir_create_system_child_repo (FlatpakDir   *self,\n                                      GLnxLockFile *file_lock,\n                                      const char   *optional_commit,\n                                      GError      **error)\n{\n  g_autoptr(GFile) cache_dir = NULL;\n\n  g_assert (!self->user);\n\n  cache_dir = flatpak_ensure_system_user_cache_dir_location (error);\n  if (cache_dir == NULL)\n    return NULL;\n\n  return flatpak_dir_create_child_repo (self, cache_dir, file_lock, optional_commit, error);\n}\n\nstatic gboolean\nflatpak_dir_setup_revokefs_fuse_mount (FlatpakDir    *self,\n                                       FlatpakDecomposed *ref,\n                                       const gchar   *installation,\n                                       gchar        **out_src_dir,\n                                       gchar        **out_mnt_dir,\n                                       GCancellable  *cancellable)\n{\n  g_autoptr (GError) local_error = NULL;\n  g_autofree gchar *src_dir_tmp = NULL;\n  g_autofree gchar *mnt_dir_tmp = NULL;\n  gint socket = -1;\n  gboolean res = FALSE;\n  const char *revokefs_fuse_bin = LIBEXECDIR \"/revokefs-fuse\";\n\n  if (g_getenv (\"FLATPAK_REVOKEFS_FUSE\"))\n    revokefs_fuse_bin = g_getenv (\"FLATPAK_REVOKEFS_FUSE\");\n\n  if (!flatpak_dir_system_helper_call_get_revokefs_fd (self,\n                                                       FLATPAK_HELPER_GET_REVOKEFS_FD_FLAGS_NONE,\n                                                       installation ? installation : \"\",\n                                                       &socket,\n                                                       &src_dir_tmp,\n                                                       cancellable,\n                                                       &local_error))\n    {\n      if (g_error_matches (local_error, G_DBUS_ERROR, G_DBUS_ERROR_NOT_SUPPORTED))\n        g_debug (\"revokefs-fuse not supported on your installation: %s\", local_error->message);\n      else\n        g_warning (\"Failed to get revokefs-fuse socket from system-helper: %s\", local_error->message);\n\n      goto out;\n    }\n  else\n    {\n      g_autoptr(GSubprocess) revokefs_fuse = NULL;\n      g_autoptr(GSubprocessLauncher) launcher = NULL;\n      g_autofree gchar *client_uid = NULL;\n\n      mnt_dir_tmp = flatpak_dir_revokefs_fuse_create_mountpoint (ref, &local_error);\n      if (mnt_dir_tmp == NULL)\n        {\n          g_warning (\"Failed to create a mountpoint for revokefs-fuse: %s\", local_error->message);\n          close (socket);\n          goto out;\n        }\n\n      client_uid = g_strdup_printf (\"uid=%d\", getuid ());\n      launcher = g_subprocess_launcher_new (G_SUBPROCESS_FLAGS_NONE);\n      g_subprocess_launcher_take_fd (launcher, socket, 3);\n      revokefs_fuse = g_subprocess_launcher_spawn (launcher,\n                                                   &local_error,\n                                                   revokefs_fuse_bin, \"-o\", client_uid, \"--socket=3\",\n                                                   src_dir_tmp, mnt_dir_tmp, NULL);\n      if (revokefs_fuse == NULL ||\n          !g_subprocess_wait_check (revokefs_fuse, NULL, &local_error))\n        {\n          g_warning (\"Error spawning revokefs-fuse: %s\", local_error->message);\n          close (socket);\n          goto out;\n        }\n    }\n\n  res = TRUE;\n\nout:\n  /* It is unconventional to steal these values on error. However, it depends on where\n   * this function failed. If we are able to spawn the revokefs backend (src_dir_tmp\n   * is non-NULL) but failed to create mountpoint or spawning revokefs-fuse here,\n   * we  still need the src_dir_tmp value to cleanup the revokefs backend properly\n   * through the system-helper's CancelPull(). Hence, always stealing values can tell\n   * the caller under what circumstances this function failed and cleanup accordingly. */\n  *out_mnt_dir = g_steal_pointer (&mnt_dir_tmp);\n  *out_src_dir = g_steal_pointer (&src_dir_tmp);\n\n  return res;\n}\n\nstatic void\nflatpak_dir_unmount_and_cancel_pull (FlatpakDir    *self,\n                                     guint          arg_flags,\n                                     GCancellable  *cancellable,\n                                     OstreeRepo   **repo,\n                                     GLnxLockFile  *lockfile,\n                                     const char    *mnt_dir,\n                                     const char    *src_dir)\n{\n  const char *installation = flatpak_dir_get_id (self);\n  g_autoptr(GError) error = NULL;\n\n  if (mnt_dir &&\n      !flatpak_dir_revokefs_fuse_unmount (repo, lockfile, mnt_dir, &error))\n    g_warning (\"Could not unmount revokefs-fuse filesystem at %s: %s\", mnt_dir, error->message);\n\n  g_clear_error (&error);\n\n  if (src_dir &&\n      !flatpak_dir_system_helper_call_cancel_pull (self,\n                                                   arg_flags,\n                                                   installation ? installation : \"\",\n                                                   src_dir, cancellable, &error))\n    g_warning (\"Error cancelling ongoing pull at %s: %s\", src_dir, error->message);\n}\n\ngboolean\nflatpak_dir_install (FlatpakDir          *self,\n                     gboolean             no_pull,\n                     gboolean             no_deploy,\n                     gboolean             no_static_deltas,\n                     gboolean             reinstall,\n                     gboolean             app_hint,\n                     FlatpakRemoteState  *state,\n                     FlatpakDecomposed   *ref,\n                     const char          *opt_commit,\n                     const char         **opt_subpaths,\n                     const char         **opt_previous_ids,\n                     GFile               *sideload_repo,\n                     GBytes              *require_metadata,\n                     const char          *token,\n                     FlatpakProgress     *progress,\n                     GCancellable        *cancellable,\n                     GError             **error)\n{\n  FlatpakPullFlags flatpak_flags;\n\n  flatpak_flags = FLATPAK_PULL_FLAGS_DOWNLOAD_EXTRA_DATA;\n  if (no_static_deltas)\n    flatpak_flags |= FLATPAK_PULL_FLAGS_NO_STATIC_DELTAS;\n\n  if (flatpak_dir_use_system_helper (self, NULL))\n    {\n      g_autoptr(OstreeRepo) child_repo = NULL;\n      g_auto(GLnxLockFile) child_repo_lock = { 0, };\n      const char *installation = flatpak_dir_get_id (self);\n      const char *empty_subpaths[] = {NULL};\n      const char **subpaths;\n      g_autofree char *child_repo_path = NULL;\n      FlatpakHelperDeployFlags helper_flags = 0;\n      g_autofree char *url = NULL;\n      gboolean gpg_verify_summary;\n      gboolean gpg_verify;\n      gboolean is_oci;\n      gboolean is_revokefs_pull = FALSE;\n\n      if (opt_subpaths)\n        subpaths = opt_subpaths;\n      else\n        subpaths = empty_subpaths;\n\n      if (!ostree_repo_remote_get_url (self->repo,\n                                       state->remote_name,\n                                       &url,\n                                       error))\n        return FALSE;\n\n      if (!ostree_repo_remote_get_gpg_verify_summary (self->repo, state->remote_name,\n                                                      &gpg_verify_summary, error))\n        return FALSE;\n\n      if (!ostree_repo_remote_get_gpg_verify (self->repo, state->remote_name,\n                                              &gpg_verify, error))\n        return FALSE;\n\n      is_oci = flatpak_dir_get_remote_oci (self, state->remote_name);\n      if (no_pull)\n        {\n          /* Do nothing */\n        }\n      else if (is_oci)\n        {\n          g_autoptr(FlatpakOciRegistry) registry = NULL;\n          g_autoptr(GFile) registry_file = NULL;\n\n          registry = flatpak_dir_create_system_child_oci_registry (self, &child_repo_lock, token, error);\n          if (registry == NULL)\n            return FALSE;\n\n          registry_file = g_file_new_for_uri (flatpak_oci_registry_get_uri (registry));\n\n          child_repo_path = g_file_get_path (registry_file);\n\n          if (!flatpak_dir_mirror_oci (self, registry, state, flatpak_decomposed_get_ref (ref), opt_commit, NULL, token, progress, cancellable, error))\n            return FALSE;\n        }\n      else if (!gpg_verify_summary || !gpg_verify)\n        {\n          /* The remote is not gpg verified, so we don't want to allow installation via\n             a download in the home directory, as there is no way to verify you're not\n             injecting anything into the remote. However, in the case of a remote\n             configured to a local filesystem we can just let the system helper do\n             the installation, as it can then avoid network i/o and be certain the\n             data comes from the right place. */\n          if (g_str_has_prefix (url, \"file:\"))\n            helper_flags |= FLATPAK_HELPER_DEPLOY_FLAGS_LOCAL_PULL;\n          else\n            return flatpak_fail_error (error, FLATPAK_ERROR_UNTRUSTED, _(\"Can't pull from untrusted non-gpg verified remote\"));\n        }\n      else\n        {\n          /* For system pulls, the pull has to be made in a child repo first,\n             which is then pulled into the system's one. The pull from child\n             repo into the system repo can occur in one of the two following ways:\n                1) Hard-link the child repo into system's one.\n                2) Copy and verify each object from the child repo to the system's one.\n\n             2) poses the problem of using double disk-space which might fail the\n             installation of very big applications. For e.g. at endless, the encyclopedia app\n             is about ~6GB, hence ~12GB of free disk-space is required to get it installed.\n\n             For 1), we need to make sure that we address all the security concerns that\n             might escalate during the pull from a remote into child repo and subsequently,\n             hard-linking it into the (root-owned)system repo. This is taken care of by a\n             special FUSE process(revokefs-fuse) which guards all the writes made to the\n             child repo and ensures that no file descriptors remain open to the child repo\n             before the hard-linkable pull is made into the system's repo.\n             More details about the security issues dealt here are present at\n             https://github.com/flatpak/flatpak/wiki/Noncopying-system-app-installation\n\n             In case we fail to apply pull approach 1), the pull automatically fallbacks to use 2). */\n          g_autofree gchar *src_dir = NULL;\n          g_autofree gchar *mnt_dir = NULL;\n          g_autoptr(GError) local_error = NULL;\n\n          if (!flatpak_dir_setup_revokefs_fuse_mount (self,\n                                                      ref,\n                                                      installation,\n                                                      &src_dir, &mnt_dir,\n                                                      cancellable))\n            {\n              flatpak_dir_unmount_and_cancel_pull (self, FLATPAK_HELPER_CANCEL_PULL_FLAGS_NONE,\n                                                   cancellable,\n                                                   &child_repo, &child_repo_lock,\n                                                   mnt_dir, src_dir);\n            }\n          else\n            {\n              g_autofree gchar *repo_basename = NULL;\n              g_autoptr(GFile) mnt_dir_file = NULL;\n\n              mnt_dir_file = g_file_new_for_path (mnt_dir);\n              child_repo = flatpak_dir_create_child_repo (self, mnt_dir_file, &child_repo_lock, opt_commit, &local_error);\n              if (child_repo == NULL)\n                {\n                  g_warning (\"Cannot create repo on revokefs mountpoint %s: %s\", mnt_dir, local_error->message);\n                  flatpak_dir_unmount_and_cancel_pull (self,\n                                                       FLATPAK_HELPER_CANCEL_PULL_FLAGS_NONE,\n                                                       cancellable,\n                                                       &child_repo, &child_repo_lock,\n                                                       mnt_dir, src_dir);\n                  g_clear_error (&local_error);\n                }\n              else\n                {\n                  repo_basename = g_file_get_basename (ostree_repo_get_path (child_repo));\n                  child_repo_path = g_build_filename (src_dir, repo_basename, NULL);\n                  is_revokefs_pull = TRUE;\n                }\n            }\n\n          /* Fallback if revokefs-fuse setup does not succeed. This makes the pull\n           * temporarily use double disk-space. */\n          if (!is_revokefs_pull)\n            {\n             /* We're pulling from a remote source, we do the network mirroring pull as a\n                user and hand back the resulting data to the system-helper, that trusts us\n                due to the GPG signatures in the repo */\n              child_repo = flatpak_dir_create_system_child_repo (self, &child_repo_lock, NULL, error);\n              if (child_repo == NULL)\n                return FALSE;\n              else\n                child_repo_path = g_file_get_path (ostree_repo_get_path (child_repo));\n            }\n\n          flatpak_flags |= FLATPAK_PULL_FLAGS_SIDELOAD_EXTRA_DATA;\n\n          if (!flatpak_dir_pull (self, state, flatpak_decomposed_get_ref (ref), opt_commit, subpaths, sideload_repo, require_metadata, token,\n                                 child_repo,\n                                 flatpak_flags,\n                                 0,\n                                 progress, cancellable, error))\n            {\n              if (is_revokefs_pull)\n                {\n                  flatpak_dir_unmount_and_cancel_pull (self,\n                                                       FLATPAK_HELPER_CANCEL_PULL_FLAGS_PRESERVE_PULL,\n                                                       cancellable,\n                                                       &child_repo, &child_repo_lock,\n                                                       mnt_dir, src_dir);\n                }\n\n              return FALSE;\n            }\n\n          g_assert (child_repo_path != NULL);\n\n          if (is_revokefs_pull &&\n              !flatpak_dir_revokefs_fuse_unmount (&child_repo, &child_repo_lock, mnt_dir, &local_error))\n            {\n              g_propagate_prefixed_error (error, g_steal_pointer (&local_error), \n                      _(\"Could not unmount revokefs-fuse filesystem at %s: \"), mnt_dir);\n\n              if (src_dir &&\n                  !flatpak_dir_system_helper_call_cancel_pull (self,\n                                                               FLATPAK_HELPER_CANCEL_PULL_FLAGS_PRESERVE_PULL,\n                                                               installation ? installation : \"\",\n                                                               src_dir, cancellable, &local_error))\n                g_warning (\"Error cancelling ongoing pull at %s: %s\", src_dir, local_error->message);\n              return FALSE;\n            }\n        }\n\n      if (no_deploy)\n        helper_flags |= FLATPAK_HELPER_DEPLOY_FLAGS_NO_DEPLOY;\n\n      if (reinstall)\n        helper_flags |= FLATPAK_HELPER_DEPLOY_FLAGS_REINSTALL;\n\n      if (app_hint)\n        helper_flags |= FLATPAK_HELPER_DEPLOY_FLAGS_APP_HINT;\n\n      helper_flags |= FLATPAK_HELPER_DEPLOY_FLAGS_INSTALL_HINT;\n\n      if (!flatpak_dir_system_helper_call_deploy (self,\n                                                  child_repo_path ? child_repo_path : \"\",\n                                                  helper_flags, flatpak_decomposed_get_ref (ref), state->remote_name,\n                                                  (const char * const *) subpaths,\n                                                  (const char * const *) opt_previous_ids,\n                                                  installation ? installation : \"\",\n                                                  cancellable,\n                                                  error))\n        return FALSE;\n\n      if (child_repo_path && !is_revokefs_pull)\n        (void) glnx_shutil_rm_rf_at (AT_FDCWD, child_repo_path, NULL, NULL);\n\n      return TRUE;\n    }\n\n  if (!no_pull)\n    {\n      if (!flatpak_dir_pull (self, state, flatpak_decomposed_get_ref (ref), opt_commit, opt_subpaths, sideload_repo, require_metadata, token, NULL,\n                             flatpak_flags, OSTREE_REPO_PULL_FLAGS_NONE,\n                             progress, cancellable, error))\n        return FALSE;\n    }\n\n  if (!no_deploy)\n    {\n      if (!flatpak_dir_deploy_install (self, ref, state->remote_name, opt_subpaths,\n                                       opt_previous_ids, reinstall, cancellable, error))\n        return FALSE;\n    }\n\n  return TRUE;\n}\n\nchar *\nflatpak_dir_ensure_bundle_remote (FlatpakDir         *self,\n                                  GFile              *file,\n                                  GBytes             *extra_gpg_data,\n                                  FlatpakDecomposed **out_ref,\n                                  char              **out_checksum,\n                                  char              **out_metadata,\n                                  gboolean           *out_created_remote,\n                                  GCancellable       *cancellable,\n                                  GError            **error)\n{\n  g_autoptr(FlatpakDecomposed) ref = NULL;\n  gboolean created_remote = FALSE;\n  g_autoptr(GBytes) deploy_data = NULL;\n  g_autoptr(GVariant) metadata = NULL;\n  g_autofree char *origin = NULL;\n  g_autofree char *fp_metadata = NULL;\n  g_autofree char *basename = NULL;\n  g_autoptr(GBytes) included_gpg_data = NULL;\n  GBytes *gpg_data = NULL;\n  g_autofree char *to_checksum = NULL;\n  g_autofree char *remote = NULL;\n  g_autofree char *collection_id = NULL;\n\n  if (!flatpak_dir_ensure_repo (self, cancellable, error))\n    return NULL;\n\n  metadata = flatpak_bundle_load (file, &to_checksum,\n                                  &ref,\n                                  &origin,\n                                  NULL, &fp_metadata, NULL,\n                                  &included_gpg_data,\n                                  &collection_id,\n                                  error);\n  if (metadata == NULL)\n    return NULL;\n\n  gpg_data = extra_gpg_data ? extra_gpg_data : included_gpg_data;\n\n  deploy_data = flatpak_dir_get_deploy_data (self, ref, FLATPAK_DEPLOY_VERSION_ANY, cancellable, NULL);\n  if (deploy_data != NULL)\n    {\n      remote = g_strdup (flatpak_deploy_data_get_origin (deploy_data));\n\n      /* We need to import any gpg keys because otherwise the pull will fail */\n      if (gpg_data != NULL)\n        {\n          g_autoptr(GKeyFile) new_config = NULL;\n\n          new_config = ostree_repo_copy_config (flatpak_dir_get_repo (self));\n\n          if (!flatpak_dir_modify_remote (self, remote, new_config,\n                                          gpg_data, cancellable, error))\n            return NULL;\n        }\n    }\n  else\n    {\n      g_autofree char *id = flatpak_decomposed_dup_id (ref);\n      /* Add a remote for later updates */\n      basename = g_file_get_basename (file);\n      remote = flatpak_dir_create_origin_remote (self,\n                                                 origin,\n                                                 id,\n                                                 basename,\n                                                 flatpak_decomposed_get_ref (ref),\n                                                 gpg_data,\n                                                 collection_id,\n                                                 &created_remote,\n                                                 cancellable,\n                                                 error);\n      if (remote == NULL)\n        return NULL;\n    }\n\n  if (out_created_remote)\n    *out_created_remote = created_remote;\n\n  if (out_ref)\n    *out_ref = g_steal_pointer (&ref);\n\n  if (out_checksum)\n    *out_checksum = g_steal_pointer (&to_checksum);\n\n  if (out_metadata)\n    *out_metadata = g_steal_pointer (&fp_metadata);\n\n\n  return g_steal_pointer (&remote);\n}\n\n/* If core.add-remotes-config-dir is set for this repository (which is\n * not a common configuration, but it is possible), we will fail to modify\n * remote configuration when using a combination of\n * ostree_repo_remote_[add|change]() and ostree_repo_write_config() due to\n * adding remote config in /etc/flatpak/remotes.d and also in\n * /ostree/repo/config. Avoid that.\n *\n * FIXME: See https://github.com/flatpak/flatpak/issues/1665. In future, we\n * should just write the remote config to the correct place, factoring\n * core.add-remotes-config-dir in. */\nstatic gboolean\nflatpak_dir_check_add_remotes_config_dir (FlatpakDir *self,\n                                          GError    **error)\n{\n  g_autoptr(GError) local_error = NULL;\n  gboolean val;\n  GKeyFile *config;\n\n  if (!flatpak_dir_maybe_ensure_repo (self, NULL, error))\n    return FALSE;\n\n  if (self->repo == NULL)\n    return TRUE;\n\n  config = ostree_repo_get_config (self->repo);\n\n  if (config == NULL)\n    return TRUE;\n\n  val = g_key_file_get_boolean (config, \"core\", \"add-remotes-config-dir\", &local_error);\n\n  if (local_error != NULL)\n    {\n      if (g_error_matches (local_error, G_KEY_FILE_ERROR, G_KEY_FILE_ERROR_KEY_NOT_FOUND))\n        {\n          g_clear_error (&local_error);\n          val = ostree_repo_is_system (self->repo);\n        }\n      else\n        {\n          g_propagate_error (error, g_steal_pointer (&local_error));\n          return FALSE;\n        }\n    }\n\n  if (!val)\n    return TRUE;\n\n  return flatpak_fail (error,\n                       \"Can\u2019t update remote configuration on a repository with \"\n                       \"core.add-remotes-config-dir=true\");\n}\n\ngboolean\nflatpak_dir_install_bundle (FlatpakDir         *self,\n                            GFile              *file,\n                            const char         *remote,\n                            FlatpakDecomposed **out_ref,\n                            GCancellable       *cancellable,\n                            GError            **error)\n{\n  g_autofree char *ref_str = NULL;\n  g_autoptr(FlatpakDecomposed) ref = NULL;\n  g_autoptr(GBytes) deploy_data = NULL;\n  g_autoptr(GVariant) metadata = NULL;\n  g_autofree char *origin = NULL;\n  g_autofree char *to_checksum = NULL;\n  gboolean gpg_verify;\n\n  if (!flatpak_dir_check_add_remotes_config_dir (self, error))\n    return FALSE;\n\n  if (flatpak_dir_use_system_helper (self, NULL))\n    {\n      const char *installation = flatpak_dir_get_id (self);\n\n      if (!flatpak_dir_system_helper_call_install_bundle (self,\n                                                          flatpak_file_get_path_cached (file),\n                                                          0, remote,\n                                                          installation ? installation : \"\",\n                                                          &ref_str,\n                                                          cancellable,\n                                                          error))\n        return FALSE;\n\n\n      ref = flatpak_decomposed_new_from_ref (ref_str, error);\n      if (ref == NULL)\n        return FALSE;\n\n      if (out_ref)\n        *out_ref = g_steal_pointer (&ref);\n\n      return TRUE;\n    }\n\n  if (!flatpak_dir_ensure_repo (self, cancellable, error))\n    return FALSE;\n\n  metadata = flatpak_bundle_load (file, &to_checksum,\n                                  &ref,\n                                  &origin,\n                                  NULL, NULL,\n                                  NULL, NULL, NULL,\n                                  error);\n  if (metadata == NULL)\n    return FALSE;\n\n  deploy_data = flatpak_dir_get_deploy_data (self, ref, FLATPAK_DEPLOY_VERSION_ANY, cancellable, NULL);\n  if (deploy_data != NULL)\n    {\n      if (strcmp (flatpak_deploy_data_get_commit (deploy_data), to_checksum) == 0)\n        {\n          g_autofree char *id = flatpak_decomposed_dup_id (ref);\n          g_set_error (error, FLATPAK_ERROR, FLATPAK_ERROR_ALREADY_INSTALLED,\n                       _(\"This version of %s is already installed\"), id);\n          return FALSE;\n        }\n\n      if (strcmp (remote, flatpak_deploy_data_get_origin (deploy_data)) != 0)\n        {\n          g_set_error (error, G_IO_ERROR, G_IO_ERROR_FAILED,\n                       _(\"Can't change remote during bundle install\"));\n          return FALSE;\n        }\n    }\n\n  if (!ostree_repo_remote_get_gpg_verify (self->repo, remote,\n                                          &gpg_verify, error))\n    return FALSE;\n\n  if (!flatpak_pull_from_bundle (self->repo,\n                                 file,\n                                 remote,\n                                 flatpak_decomposed_get_ref (ref),\n                                 gpg_verify,\n                                 cancellable,\n                                 error))\n    return FALSE;\n\n  if (deploy_data != NULL)\n    {\n      g_autofree char *group = g_strdup_printf (\"remote \\\"%s\\\"\", remote);\n      g_autofree char *old_url = NULL;\n      g_autoptr(GKeyFile) new_config = NULL;\n\n      /* The pull succeeded, and this is an update. So, we need to update the repo config\n         if anything changed */\n      ostree_repo_remote_get_url (self->repo,\n                                  remote,\n                                  &old_url,\n                                  NULL);\n      if (origin != NULL &&\n          (old_url == NULL || strcmp (old_url, origin) != 0))\n        {\n          if (new_config == NULL)\n            new_config = ostree_repo_copy_config (self->repo);\n\n          g_key_file_set_value (new_config, group, \"url\", origin);\n        }\n\n      if (new_config)\n        {\n          if (!flatpak_dir_cleanup_remote_for_url_change (self, remote,\n                                                          origin, cancellable, error))\n            return FALSE;\n\n          if (!ostree_repo_write_config (self->repo, new_config, error))\n            return FALSE;\n        }\n    }\n\n  if (deploy_data)\n    {\n      if (!flatpak_dir_deploy_update (self, ref, NULL, NULL, NULL, cancellable, error))\n        return FALSE;\n    }\n  else\n    {\n      if (!flatpak_dir_deploy_install (self, ref, remote, NULL, NULL, FALSE, cancellable, error))\n        return FALSE;\n    }\n\n  if (out_ref)\n    *out_ref = g_steal_pointer (&ref);\n\n  return TRUE;\n}\n\nstatic gboolean\n_g_strv_equal0 (gchar **a, gchar **b)\n{\n  gboolean ret = FALSE;\n  guint n;\n\n  if (a == NULL && b == NULL)\n    {\n      ret = TRUE;\n      goto out;\n    }\n  if (a == NULL || b == NULL)\n    goto out;\n  if (g_strv_length (a) != g_strv_length (b))\n    goto out;\n  for (n = 0; a[n] != NULL; n++)\n    if (g_strcmp0 (a[n], b[n]) != 0)\n      goto out;\n  ret = TRUE;\nout:\n  return ret;\n}\n\ngboolean\nflatpak_dir_needs_update_for_commit_and_subpaths (FlatpakDir        *self,\n                                                  const char        *remote,\n                                                  FlatpakDecomposed *ref,\n                                                  const char        *target_commit,\n                                                  const char       **opt_subpaths)\n{\n  g_autoptr(GBytes) deploy_data = NULL;\n  g_autofree const char **old_subpaths = NULL;\n  const char **subpaths;\n  g_autofree char *url = NULL;\n  const char *installed_commit;\n  const char *installed_alt_id;\n  const char *extension_of;\n\n  g_assert (target_commit != NULL);\n\n  /* Never update from disabled remotes */\n  if (!ostree_repo_remote_get_url (self->repo, remote, &url, NULL))\n    return FALSE;\n\n  if (*url == 0)\n    return FALSE;\n\n  /* deploy v4 guarantees alt-id/extension-of info */\n  deploy_data = flatpak_dir_get_deploy_data (self, ref, 4, NULL, NULL);\n  if (deploy_data != NULL)\n    old_subpaths = flatpak_deploy_data_get_subpaths (deploy_data);\n  else\n    old_subpaths = g_new0 (const char *, 1); /* Empty strv == all subpaths*/\n\n  if (opt_subpaths)\n    subpaths = opt_subpaths;\n  else\n    subpaths = old_subpaths;\n\n  /* Not deployed => need update */\n  if (deploy_data == NULL)\n    return TRUE;\n\n  /* If masked, don't update */\n  if (flatpak_dir_ref_is_masked (self, flatpak_decomposed_get_ref (ref)))\n    return FALSE;\n\n  extension_of = flatpak_deploy_data_get_extension_of (deploy_data);\n  /* If the main ref is masked, don't update extensions of it (like .Locale or .Debug) */\n  if (extension_of && flatpak_dir_ref_is_masked (self, extension_of))\n    return FALSE;\n\n  installed_commit = flatpak_deploy_data_get_commit (deploy_data);\n  installed_alt_id = flatpak_deploy_data_get_alt_id (deploy_data);\n\n  /* Different target commit than deployed => update */\n  if (g_strcmp0 (target_commit, installed_commit) != 0 &&\n      g_strcmp0 (target_commit, installed_alt_id) != 0)\n    return TRUE;\n\n  /* target commit is the same as current, but maybe something else that is different? */\n\n  /* Same commit, but different subpaths => update */\n  if (!_g_strv_equal0 ((char **) subpaths, (char **) old_subpaths))\n    return TRUE;\n\n  /* Same subpaths and commit, no need to update */\n  return FALSE;\n}\n\n/* This is called by the old-school non-transaction flatpak_installation_update, so doesn't do a lot. */\nchar *\nflatpak_dir_check_for_update (FlatpakDir               *self,\n                              FlatpakRemoteState       *state,\n                              FlatpakDecomposed        *ref,\n                              const char               *checksum_or_latest,\n                              const char              **opt_subpaths,\n                              gboolean                  no_pull,\n                              GCancellable             *cancellable,\n                              GError                  **error)\n{\n  g_autofree char *latest_rev = NULL;\n  const char *target_rev = NULL;\n\n  if (no_pull)\n    {\n      if (!flatpak_repo_resolve_rev (self->repo, NULL, state->remote_name,\n                                     flatpak_decomposed_get_ref (ref), FALSE, &latest_rev, NULL, NULL))\n        {\n          g_set_error (error, FLATPAK_ERROR, FLATPAK_ERROR_ALREADY_INSTALLED,\n                       _(\"%s already installed\"), flatpak_decomposed_get_ref (ref));\n          return NULL; /* No update, because nothing to update to */\n        }\n    }\n  else\n    {\n      if (!flatpak_dir_find_latest_rev (self, state, flatpak_decomposed_get_ref (ref), checksum_or_latest, &latest_rev,\n                                        NULL, NULL, cancellable, error))\n        return NULL;\n    }\n\n  if (checksum_or_latest != NULL)\n    target_rev = checksum_or_latest;\n  else\n    target_rev = latest_rev;\n\n  if (flatpak_dir_needs_update_for_commit_and_subpaths (self, state->remote_name, ref, target_rev, opt_subpaths))\n    return g_strdup (target_rev);\n\n  g_set_error (error, FLATPAK_ERROR, FLATPAK_ERROR_ALREADY_INSTALLED,\n               _(\"%s commit %s already installed\"), flatpak_decomposed_get_ref (ref), target_rev);\n  return NULL;\n}\n\ngboolean\nflatpak_dir_update (FlatpakDir                           *self,\n                    gboolean                              no_pull,\n                    gboolean                              no_deploy,\n                    gboolean                              no_static_deltas,\n                    gboolean                              allow_downgrade,\n                    gboolean                              app_hint,\n                    gboolean                              install_hint,\n                    FlatpakRemoteState                   *state,\n                    FlatpakDecomposed                    *ref,\n                    const char                           *commit,\n                    const char                          **opt_subpaths,\n                    const char                          **opt_previous_ids,\n                    GFile                                *sideload_repo,\n                    GBytes                               *require_metadata,\n                    const char                           *token,\n                    FlatpakProgress                      *progress,\n                    GCancellable                         *cancellable,\n                    GError                              **error)\n{\n  g_autoptr(GBytes) deploy_data = NULL;\n  const char **subpaths = NULL;\n  const char *empty_subpaths[] = {NULL};\n  g_autofree char *url = NULL;\n  FlatpakPullFlags flatpak_flags;\n  g_autofree const char **old_subpaths = NULL;\n  gboolean is_oci;\n\n  /* This is calculated in check_for_update */\n  g_assert (commit != NULL);\n\n  flatpak_flags = FLATPAK_PULL_FLAGS_DOWNLOAD_EXTRA_DATA;\n  if (allow_downgrade)\n    flatpak_flags |= FLATPAK_PULL_FLAGS_ALLOW_DOWNGRADE;\n  if (no_static_deltas)\n    flatpak_flags |= FLATPAK_PULL_FLAGS_NO_STATIC_DELTAS;\n\n  deploy_data = flatpak_dir_get_deploy_data (self, ref, FLATPAK_DEPLOY_VERSION_ANY,\n                                             cancellable, NULL);\n\n  if (deploy_data != NULL)\n    old_subpaths = flatpak_deploy_data_get_subpaths (deploy_data);\n\n  if (opt_subpaths)\n    subpaths = opt_subpaths;\n  else if (old_subpaths)\n    subpaths = old_subpaths;\n  else\n    subpaths = empty_subpaths;\n\n  if (!ostree_repo_remote_get_url (self->repo, state->remote_name, &url, error))\n    return FALSE;\n\n  if (*url == 0)\n    return TRUE; /* Empty URL => disabled */\n\n  is_oci = flatpak_dir_get_remote_oci (self, state->remote_name);\n\n  if (flatpak_dir_use_system_helper (self, NULL))\n    {\n      const char *installation = flatpak_dir_get_id (self);\n      g_autoptr(OstreeRepo) child_repo = NULL;\n      g_auto(GLnxLockFile) child_repo_lock = { 0, };\n      g_autofree char *child_repo_path = NULL;\n      FlatpakHelperDeployFlags helper_flags = 0;\n      gboolean gpg_verify_summary;\n      gboolean gpg_verify;\n      gboolean is_revokefs_pull = FALSE;\n\n      if (allow_downgrade)\n        return flatpak_fail_error (error, FLATPAK_ERROR_DOWNGRADE,\n                                   _(\"Can't update to a specific commit without root permissions\"));\n\n      helper_flags = FLATPAK_HELPER_DEPLOY_FLAGS_UPDATE;\n\n      if (!ostree_repo_remote_get_gpg_verify_summary (self->repo, state->remote_name,\n                                                      &gpg_verify_summary, error))\n        return FALSE;\n\n      if (!ostree_repo_remote_get_gpg_verify (self->repo, state->remote_name,\n                                              &gpg_verify, error))\n        return FALSE;\n\n      if (no_pull)\n        {\n          /* Nothing to do here */\n        }\n      else if (is_oci)\n        {\n          g_autoptr(FlatpakOciRegistry) registry = NULL;\n          g_autoptr(GFile) registry_file = NULL;\n\n          registry = flatpak_dir_create_system_child_oci_registry (self, &child_repo_lock, token, error);\n          if (registry == NULL)\n            return FALSE;\n\n          registry_file = g_file_new_for_uri (flatpak_oci_registry_get_uri (registry));\n\n          child_repo_path = g_file_get_path (registry_file);\n\n          if (!flatpak_dir_mirror_oci (self, registry, state, flatpak_decomposed_get_ref (ref),\n                                       commit, NULL, token, progress, cancellable, error))\n            return FALSE;\n        }\n      else if (!gpg_verify_summary || !gpg_verify)\n        {\n          /* The remote is not gpg verified, so we don't want to allow installation via\n             a download in the home directory, as there is no way to verify you're not\n             injecting anything into the remote. However, in the case of a remote\n             configured to a local filesystem we can just let the system helper do\n             the installation, as it can then avoid network i/o and be certain the\n             data comes from the right place.\n\n             If @collection_id is non-%NULL, we can verify the refs in commit\n             metadata, so don\u2019t need to verify the summary. */\n          if (g_str_has_prefix (url, \"file:\"))\n            helper_flags |= FLATPAK_HELPER_DEPLOY_FLAGS_LOCAL_PULL;\n          else\n            return flatpak_fail_error (error, FLATPAK_ERROR_UNTRUSTED, _(\"Can't pull from untrusted non-gpg verified remote\"));\n        }\n      else\n        {\n          /* First try to update using revokefs-fuse codepath. If it fails, try to update using a\n           * temporary child-repo. Read flatpak_dir_install for more details on using revokefs-fuse */\n          g_autofree gchar *src_dir = NULL;\n          g_autofree gchar *mnt_dir = NULL;\n          g_autoptr(GError) local_error = NULL;\n\n          if (!flatpak_dir_setup_revokefs_fuse_mount (self,\n                                                      ref,\n                                                      installation,\n                                                      &src_dir, &mnt_dir,\n                                                      cancellable))\n            {\n              flatpak_dir_unmount_and_cancel_pull (self, FLATPAK_HELPER_CANCEL_PULL_FLAGS_NONE,\n                                                   cancellable,\n                                                   &child_repo, &child_repo_lock,\n                                                   mnt_dir, src_dir);\n            }\n          else\n            {\n              g_autofree gchar *repo_basename = NULL;\n              g_autoptr(GFile) mnt_dir_file = NULL;\n\n              mnt_dir_file = g_file_new_for_path (mnt_dir);\n              child_repo = flatpak_dir_create_child_repo (self, mnt_dir_file, &child_repo_lock, commit, &local_error);\n              if (child_repo == NULL)\n                {\n                  g_warning (\"Cannot create repo on revokefs mountpoint %s: %s\", mnt_dir, local_error->message);\n                  flatpak_dir_unmount_and_cancel_pull (self,\n                                                       FLATPAK_HELPER_CANCEL_PULL_FLAGS_NONE,\n                                                       cancellable,\n                                                       &child_repo, &child_repo_lock,\n                                                       mnt_dir, src_dir);\n                  g_clear_error (&local_error);\n                }\n              else\n                {\n                  repo_basename = g_file_get_basename (ostree_repo_get_path (child_repo));\n                  child_repo_path = g_build_filename (src_dir, repo_basename, NULL);\n                  is_revokefs_pull = TRUE;\n                }\n            }\n\n          /* Fallback if revokefs-fuse setup does not succeed. This makes the pull\n           * temporarily use double disk-space. */\n          if (!is_revokefs_pull)\n            {\n              /* We're pulling from a remote source, we do the network mirroring pull as a\n                 user and hand back the resulting data to the system-helper, that trusts us\n                 due to the GPG signatures in the repo */\n\n              child_repo = flatpak_dir_create_system_child_repo (self, &child_repo_lock, commit, error);\n              if (child_repo == NULL)\n                return FALSE;\n              else\n                child_repo_path = g_file_get_path (ostree_repo_get_path (child_repo));\n            }\n\n          flatpak_flags |= FLATPAK_PULL_FLAGS_SIDELOAD_EXTRA_DATA;\n          if (!flatpak_dir_pull (self, state, flatpak_decomposed_get_ref (ref),\n                                 commit, subpaths, sideload_repo, require_metadata, token,\n                                 child_repo,\n                                 flatpak_flags, 0,\n                                 progress, cancellable, error))\n            {\n              if (is_revokefs_pull)\n                {\n                  flatpak_dir_unmount_and_cancel_pull (self,\n                                                       FLATPAK_HELPER_CANCEL_PULL_FLAGS_PRESERVE_PULL,\n                                                       cancellable,\n                                                       &child_repo, &child_repo_lock,\n                                                       mnt_dir, src_dir);\n                }\n\n              return FALSE;\n            }\n\n          g_assert (child_repo_path != NULL);\n\n          if (is_revokefs_pull &&\n              !flatpak_dir_revokefs_fuse_unmount (&child_repo, &child_repo_lock, mnt_dir, &local_error))\n            {\n              g_warning (\"Could not unmount revokefs-fuse filesystem at %s: %s\", mnt_dir, local_error->message);\n              flatpak_dir_unmount_and_cancel_pull (self,\n                                                   FLATPAK_HELPER_CANCEL_PULL_FLAGS_PRESERVE_PULL,\n                                                   cancellable,\n                                                   &child_repo, &child_repo_lock,\n                                                   mnt_dir, src_dir);\n              return FALSE;\n            }\n        }\n\n      if (no_deploy)\n        helper_flags |= FLATPAK_HELPER_DEPLOY_FLAGS_NO_DEPLOY;\n\n      if (app_hint)\n        helper_flags |= FLATPAK_HELPER_DEPLOY_FLAGS_APP_HINT;\n\n      if (install_hint)\n        helper_flags |= FLATPAK_HELPER_DEPLOY_FLAGS_INSTALL_HINT;\n\n      if (!flatpak_dir_system_helper_call_deploy (self,\n                                                  child_repo_path ? child_repo_path : \"\",\n                                                  helper_flags, flatpak_decomposed_get_ref (ref), state->remote_name,\n                                                  subpaths, opt_previous_ids,\n                                                  installation ? installation : \"\",\n                                                  cancellable,\n                                                  error))\n        return FALSE;\n\n      if (child_repo_path && !is_revokefs_pull)\n        (void) glnx_shutil_rm_rf_at (AT_FDCWD, child_repo_path, NULL, NULL);\n\n      return TRUE;\n    }\n\n  if (!no_pull)\n    {\n      if (!flatpak_dir_pull (self, state, flatpak_decomposed_get_ref (ref),\n                             commit, subpaths, sideload_repo, require_metadata, token,\n                             NULL, flatpak_flags, OSTREE_REPO_PULL_FLAGS_NONE,\n                             progress, cancellable, error))\n        return FALSE;\n\n      /* Take this opportunity to clean up refs/mirrors/ since a prune will happen\n       * after this update operation. See\n       * https://github.com/flatpak/flatpak/issues/3222\n       * Note: For the system-helper case we do this in handle_deploy()\n       */\n      if (!flatpak_dir_delete_mirror_refs (self, FALSE, cancellable, error))\n        return FALSE;\n    }\n\n  if (!no_deploy)\n    {\n      if (!flatpak_dir_deploy_update (self, ref,\n                                      /* We don't know the local commit id in the OCI case, and\n                                         we only support one version anyway */\n                                      is_oci ? NULL : commit,\n                                      subpaths, opt_previous_ids,\n                                      cancellable, error))\n        return FALSE;\n    }\n\n  return TRUE;\n}\n\ngboolean\nflatpak_dir_uninstall (FlatpakDir                 *self,\n                       FlatpakDecomposed          *ref,\n                       FlatpakHelperUninstallFlags flags,\n                       GCancellable               *cancellable,\n                       GError                    **error)\n{\n  const char *repository;\n  g_autoptr(FlatpakDecomposed) current_ref = NULL;\n  gboolean was_deployed;\n  g_autofree char *name = NULL;\n  g_autofree char *old_active = NULL;\n  g_auto(GLnxLockFile) lock = { 0, };\n  g_autoptr(GBytes) deploy_data = NULL;\n  gboolean keep_ref = flags & FLATPAK_HELPER_UNINSTALL_FLAGS_KEEP_REF;\n  gboolean force_remove = flags & FLATPAK_HELPER_UNINSTALL_FLAGS_FORCE_REMOVE;\n\n  name = flatpak_decomposed_dup_id (ref);\n\n  if (flatpak_dir_use_system_helper (self, NULL))\n    {\n      const char *installation = flatpak_dir_get_id (self);\n\n      if (!flatpak_dir_system_helper_call_uninstall (self,\n                                                     flags, flatpak_decomposed_get_ref (ref),\n                                                     installation ? installation : \"\",\n                                                     cancellable, error))\n        return FALSE;\n\n      return TRUE;\n    }\n\n  if (!flatpak_dir_lock (self, &lock,\n                         cancellable, error))\n    return FALSE;\n\n  deploy_data = flatpak_dir_get_deploy_data (self, ref, FLATPAK_DEPLOY_VERSION_ANY,\n                                             cancellable, error);\n  if (deploy_data == NULL)\n    return FALSE;\n\n  /* Note: the origin remote usually exists but it's not guaranteed (the user\n   * could have run remote-delete --force) */\n  repository = flatpak_deploy_data_get_origin (deploy_data);\n  if (repository == NULL)\n    return FALSE;\n\n  if (flatpak_decomposed_is_runtime (ref) && !force_remove)\n    {\n      g_autoptr(GPtrArray) blocking = NULL;\n\n      /* Look for apps that need this runtime */\n      blocking = flatpak_dir_list_app_refs_with_runtime (self, ref, cancellable, error);\n      if (blocking == NULL)\n        return FALSE;\n\n      if (blocking->len > 0)\n        {\n          g_autoptr(GString) joined = g_string_new (\"\");\n          for (int i = 0; i < blocking->len; i++)\n            {\n              FlatpakDecomposed *blocking_ref = g_ptr_array_index (blocking, i);\n              g_autofree char *id = flatpak_decomposed_dup_id (blocking_ref);\n              if (i != 0)\n                g_string_append (joined, \", \");\n              g_string_append (joined, id);\n            }\n\n          return flatpak_fail_error (error, FLATPAK_ERROR_RUNTIME_USED,\n                                     _(\"Can't remove %s, it is needed for: %s\"), flatpak_decomposed_get_pref (ref), joined->str);\n        }\n    }\n\n  old_active = g_strdup (flatpak_deploy_data_get_commit (deploy_data));\n\n  g_debug (\"dropping active ref\");\n  if (!flatpak_dir_set_active (self, ref, NULL, cancellable, error))\n    return FALSE;\n\n  if (flatpak_decomposed_is_app (ref))\n    {\n      current_ref = flatpak_dir_current_ref (self, name, cancellable);\n      if (current_ref != NULL &&\n          flatpak_decomposed_equal (ref, current_ref))\n        {\n          g_debug (\"dropping current ref\");\n          if (!flatpak_dir_drop_current_ref (self, name, cancellable, error))\n            return FALSE;\n        }\n    }\n\n  if (!flatpak_dir_update_deploy_ref (self, flatpak_decomposed_get_ref (ref), NULL, error))\n    return FALSE;\n\n  if (!flatpak_dir_undeploy_all (self, ref, force_remove, &was_deployed, cancellable, error))\n    return FALSE;\n\n  if (!keep_ref &&\n      !flatpak_dir_remove_ref (self, repository, flatpak_decomposed_get_ref (ref), cancellable, error))\n    return FALSE;\n\n  /* Take this opportunity to clean up refs/mirrors/ since a prune will happen\n   * after this uninstall operation. See\n   * https://github.com/flatpak/flatpak/issues/3222\n   */\n  if (!flatpak_dir_delete_mirror_refs (self, FALSE, cancellable, error))\n    return FALSE;\n\n  if (flatpak_decomposed_is_app (ref) &&\n      !flatpak_dir_update_exports (self, name, cancellable, error))\n    return FALSE;\n\n  glnx_release_lock_file (&lock);\n\n  flatpak_dir_prune_origin_remote (self, repository);\n\n  flatpak_dir_cleanup_removed (self, cancellable, NULL);\n\n  if (!flatpak_dir_mark_changed (self, error))\n    return FALSE;\n\n  if (!was_deployed)\n    {\n      const char *branch = flatpak_decomposed_get_branch (ref);\n      g_set_error (error, FLATPAK_ERROR, FLATPAK_ERROR_NOT_INSTALLED,\n                   _(\"%s branch %s is not installed\"), name, branch);\n      return FALSE;\n    }\n\n  flatpak_dir_log (self, \"uninstall\", NULL, flatpak_decomposed_get_ref (ref), NULL, old_active, NULL,\n                   \"Uninstalled %s\", flatpak_decomposed_get_ref (ref));\n\n  return TRUE;\n}\n\ngboolean\nflatpak_dir_collect_deployed_refs (FlatpakDir   *self,\n                                   const char   *type,\n                                   const char   *name_prefix,\n                                   const char   *arch,\n                                   const char   *branch,\n                                   GHashTable   *hash,\n                                   GCancellable *cancellable,\n                                   GError      **error)\n{\n  gboolean ret = FALSE;\n  g_autoptr(GFile) dir = NULL;\n  g_autoptr(GFileEnumerator) dir_enum = NULL;\n  g_autoptr(GFileInfo) child_info = NULL;\n  GError *temp_error = NULL;\n  FlatpakKinds kind;\n\n  if (strcmp (type, \"app\") == 0)\n    kind = FLATPAK_KINDS_APP;\n  else\n    kind = FLATPAK_KINDS_RUNTIME;\n\n  dir = g_file_get_child (self->basedir, type);\n  if (!g_file_query_exists (dir, cancellable))\n    return TRUE;\n\n  dir_enum = g_file_enumerate_children (dir, OSTREE_GIO_FAST_QUERYINFO,\n                                        G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n                                        cancellable,\n                                        error);\n  if (!dir_enum)\n    goto out;\n\n  while ((child_info = g_file_enumerator_next_file (dir_enum, cancellable, &temp_error)) != NULL)\n    {\n      const char *name = g_file_info_get_name (child_info);\n\n      if (g_file_info_get_file_type (child_info) == G_FILE_TYPE_DIRECTORY &&\n          name[0] != '.' && (name_prefix == NULL || g_str_has_prefix (name, name_prefix)))\n        {\n          g_autoptr(GFile) child1 = g_file_get_child (dir, name);\n          g_autoptr(GFile) child2 = g_file_get_child (child1, arch);\n          g_autoptr(GFile) child3 = g_file_get_child (child2, branch);\n          g_autoptr(GFile) active = g_file_get_child (child3, \"active\");\n\n          if (g_file_query_exists (active, cancellable))\n            {\n              FlatpakDecomposed *ref = flatpak_decomposed_new_from_parts (kind, name, arch, branch, NULL);\n              if (ref)\n                g_hash_table_add (hash, ref);\n            }\n        }\n\n      g_clear_object (&child_info);\n    }\n\n  if (temp_error != NULL)\n    {\n      g_propagate_error (error, temp_error);\n      goto out;\n    }\n\n  ret = TRUE;\nout:\n  return ret;\n}\n\ngboolean\nflatpak_dir_collect_unmaintained_refs (FlatpakDir   *self,\n                                       const char   *name_prefix,\n                                       const char   *arch,\n                                       const char   *branch,\n                                       GHashTable   *hash,\n                                       GCancellable *cancellable,\n                                       GError      **error)\n{\n  gboolean ret = FALSE;\n  g_autoptr(GFile) unmaintained_dir = NULL;\n  g_autoptr(GFileEnumerator) unmaintained_dir_enum = NULL;\n  g_autoptr(GFileInfo) child_info = NULL;\n  GError *temp_error = NULL;\n\n  unmaintained_dir = g_file_get_child (self->basedir, \"extension\");\n  if (!g_file_query_exists (unmaintained_dir, cancellable))\n    return TRUE;\n\n  unmaintained_dir_enum = g_file_enumerate_children (unmaintained_dir, G_FILE_ATTRIBUTE_STANDARD_NAME,\n                                                     G_FILE_QUERY_INFO_NONE,\n                                                     cancellable,\n                                                     error);\n  if (!unmaintained_dir_enum)\n    goto out;\n\n  while ((child_info = g_file_enumerator_next_file (unmaintained_dir_enum, cancellable, &temp_error)) != NULL)\n    {\n      const char *name = g_file_info_get_name (child_info);\n\n      if (g_file_info_get_file_type (child_info) == G_FILE_TYPE_DIRECTORY &&\n          name[0] != '.' && (name_prefix == NULL || g_str_has_prefix (name, name_prefix)))\n        {\n          g_autoptr(GFile) child1 = g_file_get_child (unmaintained_dir, name);\n          g_autoptr(GFile) child2 = g_file_get_child (child1, arch);\n          g_autoptr(GFile) child3 = g_file_get_child (child2, branch);\n\n          if (g_file_query_exists (child3, cancellable))\n            g_hash_table_add (hash, g_strdup (name));\n        }\n\n      g_clear_object (&child_info);\n    }\n\n  if (temp_error != NULL)\n    {\n      g_propagate_error (error, temp_error);\n      goto out;\n    }\n\n  ret = TRUE;\nout:\n  return ret;\n}\n\ngboolean\nflatpak_dir_list_deployed (FlatpakDir        *self,\n                           FlatpakDecomposed *ref,\n                           char            ***deployed_ids,\n                           GCancellable      *cancellable,\n                           GError           **error)\n{\n  gboolean ret = FALSE;\n  g_autoptr(GFile) deploy_base = NULL;\n  g_autoptr(GPtrArray) ids = NULL;\n  GError *temp_error = NULL;\n  g_autoptr(GFileEnumerator) dir_enum = NULL;\n  g_autoptr(GFile) child = NULL;\n  g_autoptr(GFileInfo) child_info = NULL;\n  g_autoptr(GError) my_error = NULL;\n\n  deploy_base = flatpak_dir_get_deploy_dir (self, ref);\n\n  ids = g_ptr_array_new_with_free_func (g_free);\n\n  dir_enum = g_file_enumerate_children (deploy_base, OSTREE_GIO_FAST_QUERYINFO,\n                                        G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n                                        cancellable,\n                                        &my_error);\n  if (!dir_enum)\n    {\n      if (g_error_matches (my_error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND))\n        ret = TRUE; /* Success, but empty */\n      else\n        g_propagate_error (error, g_steal_pointer (&my_error));\n      goto out;\n    }\n\n  while ((child_info = g_file_enumerator_next_file (dir_enum, cancellable, &temp_error)) != NULL)\n    {\n      const char *name;\n\n      name = g_file_info_get_name (child_info);\n\n      g_clear_object (&child);\n      child = g_file_get_child (deploy_base, name);\n\n      if (g_file_info_get_file_type (child_info) == G_FILE_TYPE_DIRECTORY &&\n          name[0] != '.' &&\n          strlen (name) == 64)\n        g_ptr_array_add (ids, g_strdup (name));\n\n      g_clear_object (&child_info);\n    }\n\n  if (temp_error != NULL)\n    {\n      g_propagate_error (error, temp_error);\n      goto out;\n    }\n\n  ret = TRUE;\n\nout:\n  if (ret)\n    {\n      g_ptr_array_add (ids, NULL);\n      *deployed_ids = (char **) g_ptr_array_free (g_steal_pointer (&ids), FALSE);\n    }\n\n  return ret;\n}\n\nstatic gboolean\ndir_is_locked (GFile *dir)\n{\n  glnx_autofd int ref_fd = -1;\n  struct flock lock = {0};\n  g_autoptr(GFile) reffile = NULL;\n\n  reffile = g_file_resolve_relative_path (dir, \"files/.ref\");\n\n  ref_fd = open (flatpak_file_get_path_cached (reffile), O_RDWR | O_CLOEXEC);\n  if (ref_fd != -1)\n    {\n      lock.l_type = F_WRLCK;\n      lock.l_whence = SEEK_SET;\n      lock.l_start = 0;\n      lock.l_len = 0;\n\n      if (fcntl (ref_fd, F_GETLK, &lock) == 0)\n        return lock.l_type != F_UNLCK;\n    }\n\n  return FALSE;\n}\n\ngboolean\nflatpak_dir_undeploy (FlatpakDir        *self,\n                      FlatpakDecomposed *ref,\n                      const char        *active_id,\n                      gboolean           is_update,\n                      gboolean           force_remove,\n                      GCancellable      *cancellable,\n                      GError           **error)\n{\n  g_autoptr(GFile) deploy_base = NULL;\n  g_autoptr(GFile) checkoutdir = NULL;\n  g_autoptr(GFile) removed_subdir = NULL;\n  g_autoptr(GFile) removed_dir = NULL;\n  g_autofree char *id = NULL;\n  g_autofree char *dirname = NULL;\n  g_autofree char *current_active = NULL;\n  g_autoptr(GFile) change_file = NULL;\n  g_autoptr(GError) child_error = NULL;\n  int i, retry;\n\n  g_assert (ref != NULL);\n  g_assert (active_id != NULL);\n\n  deploy_base = flatpak_dir_get_deploy_dir (self, ref);\n\n  checkoutdir = g_file_get_child (deploy_base, active_id);\n  if (!g_file_query_exists (checkoutdir, cancellable))\n    {\n      g_set_error (error, FLATPAK_ERROR, FLATPAK_ERROR_NOT_INSTALLED,\n                   _(\"%s commit %s not installed\"),\n                   flatpak_decomposed_get_ref (ref), active_id);\n      return FALSE;\n    }\n\n  if (!flatpak_dir_ensure_repo (self, cancellable, error))\n    return FALSE;\n\n  current_active = flatpak_dir_read_active (self, ref, cancellable);\n  if (current_active != NULL && strcmp (current_active, active_id) == 0)\n    {\n      g_auto(GStrv) deployed_ids = NULL;\n      const char *some_deployment;\n\n      /* We're removing the active deployment, start by repointing that\n         to another deployment if one exists */\n\n      if (!flatpak_dir_list_deployed (self, ref,\n                                      &deployed_ids,\n                                      cancellable, error))\n        return FALSE;\n\n      some_deployment = NULL;\n      for (i = 0; deployed_ids[i] != NULL; i++)\n        {\n          if (strcmp (deployed_ids[i], active_id) == 0)\n            continue;\n\n          some_deployment = deployed_ids[i];\n          break;\n        }\n\n      if (!flatpak_dir_set_active (self, ref, some_deployment, cancellable, error))\n        return FALSE;\n    }\n\n  removed_dir = flatpak_dir_get_removed_dir (self);\n  if (!flatpak_mkdir_p (removed_dir, cancellable, error))\n    return FALSE;\n\n  id = flatpak_decomposed_dup_id (ref);\n  dirname = g_strdup_printf (\"%s-%s\", id, active_id);\n\n  removed_subdir = g_file_get_child (removed_dir, dirname);\n\n  retry = 0;\n  while (TRUE)\n    {\n      g_autoptr(GError) local_error = NULL;\n      g_autoptr(GFile) tmpdir = NULL;\n      g_autofree char *tmpname = NULL;\n\n      if (flatpak_file_rename (checkoutdir,\n                               removed_subdir,\n                               cancellable, &local_error))\n        break;\n\n      if (!g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_EXISTS) || retry >= 10)\n        {\n          g_propagate_error (error, g_steal_pointer (&local_error));\n          return FALSE;\n        }\n\n      retry++;\n\n      /* Destination already existed, move that aside, as we want to use the exact\n       * removed dirname for the latest undeployed version */\n\n      tmpname = g_strdup_printf (\"%s-XXXXXX\", dirname);\n      glnx_gen_temp_name (tmpname);\n      tmpdir = g_file_get_child (removed_dir, tmpname);\n\n      if (!flatpak_file_rename (removed_subdir,\n                                tmpdir,\n                                cancellable, error))\n        return FALSE;\n    }\n\n\n  if (is_update)\n    change_file = g_file_resolve_relative_path (removed_subdir, \"files/.updated\");\n  else\n    change_file = g_file_resolve_relative_path (removed_subdir, \"files/.removed\");\n\n  if (!g_file_replace_contents (change_file, \"\", 0, NULL, FALSE,\n                                G_FILE_CREATE_REPLACE_DESTINATION, NULL, NULL, &child_error))\n    {\n      g_autofree gchar *path = g_file_get_path (change_file);\n      g_warning (\"Unable to clear %s: %s\", path, child_error->message);\n      g_clear_error (&child_error);\n    }\n\n  if (force_remove || !dir_is_locked (removed_subdir))\n    {\n      g_autoptr(GError) tmp_error = NULL;\n\n      if (!flatpak_rm_rf (removed_subdir, cancellable, &tmp_error))\n        g_warning (\"Unable to remove old checkout: %s\", tmp_error->message);\n    }\n\n  return TRUE;\n}\n\ngboolean\nflatpak_dir_undeploy_all (FlatpakDir        *self,\n                          FlatpakDecomposed *ref,\n                          gboolean           force_remove,\n                          gboolean          *was_deployed_out,\n                          GCancellable      *cancellable,\n                          GError           **error)\n{\n  g_auto(GStrv) deployed = NULL;\n  g_autoptr(GFile) deploy_base = NULL;\n  g_autoptr(GFile) arch_dir = NULL;\n  g_autoptr(GFile) top_dir = NULL;\n  GError *temp_error = NULL;\n  int i;\n  gboolean was_deployed;\n\n  if (!flatpak_dir_list_deployed (self, ref, &deployed, cancellable, error))\n    return FALSE;\n\n  for (i = 0; deployed[i] != NULL; i++)\n    {\n      g_debug (\"undeploying %s\", deployed[i]);\n      if (!flatpak_dir_undeploy (self, ref, deployed[i], FALSE, force_remove, cancellable, error))\n        return FALSE;\n    }\n\n  deploy_base = flatpak_dir_get_deploy_dir (self, ref);\n  was_deployed = g_file_query_exists (deploy_base, cancellable);\n  if (was_deployed)\n    {\n      g_debug (\"removing deploy base\");\n      if (!flatpak_rm_rf (deploy_base, cancellable, error))\n        return FALSE;\n    }\n\n  g_debug (\"cleaning up empty directories\");\n  arch_dir = g_file_get_parent (deploy_base);\n  if (g_file_query_exists (arch_dir, cancellable) &&\n      !g_file_delete (arch_dir, cancellable, &temp_error))\n    {\n      if (!g_error_matches (temp_error, G_IO_ERROR, G_IO_ERROR_NOT_EMPTY))\n        {\n          g_propagate_error (error, temp_error);\n          return FALSE;\n        }\n      g_clear_error (&temp_error);\n    }\n\n  top_dir = g_file_get_parent (arch_dir);\n  if (g_file_query_exists (top_dir, cancellable) &&\n      !g_file_delete (top_dir, cancellable, &temp_error))\n    {\n      if (!g_error_matches (temp_error, G_IO_ERROR, G_IO_ERROR_NOT_EMPTY))\n        {\n          g_propagate_error (error, temp_error);\n          return FALSE;\n        }\n      g_clear_error (&temp_error);\n    }\n\n  if (was_deployed_out)\n    *was_deployed_out = was_deployed;\n\n  return TRUE;\n}\n\n/**\n * flatpak_dir_remove_ref:\n * @self: a #FlatpakDir\n * @remote_name: the name of the remote\n * @ref: the flatpak ref to remove\n * @cancellable: (nullable) (optional): a #GCancellable\n * @error: a #GError\n *\n * Remove the flatpak ref given by @remote_name:@ref from the underlying\n * OSTree repo. Attempting to remove a ref that is currently deployed\n * is an error, you need to uninstall the flatpak first. Note that this does\n * not remove the objects bound to @ref from the disk, you will need to\n * call flatpak_dir_prune() to do that.\n *\n * Returns: %TRUE if removing the ref succeeded, %FALSE otherwise.\n */\ngboolean\nflatpak_dir_remove_ref (FlatpakDir        *self,\n                        const char        *remote_name,\n                        const char        *ref, /* NOTE: Not necessarily a app/runtime ref */\n                        GCancellable      *cancellable,\n                        GError           **error)\n{\n  if (flatpak_dir_use_system_helper (self, NULL))\n    {\n      const char *installation = flatpak_dir_get_id (self);\n\n      if (!flatpak_dir_system_helper_call_remove_local_ref (self,\n                                                            FLATPAK_HELPER_REMOVE_LOCAL_REF_FLAGS_NONE,\n                                                            remote_name,\n                                                            ref,\n                                                            installation ? installation : \"\",\n                                                            cancellable,\n                                                            error))\n        return FALSE;\n\n      return TRUE;\n    }\n\n  if (!ostree_repo_set_ref_immediate (self->repo,\n                                      remote_name,\n                                      ref,\n                                      NULL,\n                                      cancellable,\n                                      error))\n    return FALSE;\n\n  return TRUE;\n}\n\ngboolean\nflatpak_dir_cleanup_removed (FlatpakDir   *self,\n                             GCancellable *cancellable,\n                             GError      **error)\n{\n  gboolean ret = FALSE;\n  g_autoptr(GFile) removed_dir = NULL;\n  g_autoptr(GFileEnumerator) dir_enum = NULL;\n  g_autoptr(GFileInfo) child_info = NULL;\n  GError *temp_error = NULL;\n\n  removed_dir = flatpak_dir_get_removed_dir (self);\n  if (!g_file_query_exists (removed_dir, cancellable))\n    return TRUE;\n\n  dir_enum = g_file_enumerate_children (removed_dir, OSTREE_GIO_FAST_QUERYINFO,\n                                        G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n                                        cancellable,\n                                        error);\n  if (!dir_enum)\n    goto out;\n\n  while ((child_info = g_file_enumerator_next_file (dir_enum, cancellable, &temp_error)) != NULL)\n    {\n      const char *name = g_file_info_get_name (child_info);\n      g_autoptr(GFile) child = g_file_get_child (removed_dir, name);\n\n      if (g_file_info_get_file_type (child_info) == G_FILE_TYPE_DIRECTORY &&\n          !dir_is_locked (child))\n        {\n          g_autoptr(GError) tmp_error = NULL;\n          if (!flatpak_rm_rf (child, cancellable, &tmp_error))\n            g_warning (\"Unable to remove old checkout: %s\", tmp_error->message);\n        }\n\n      g_clear_object (&child_info);\n    }\n\n  if (temp_error != NULL)\n    {\n      g_propagate_error (error, temp_error);\n      goto out;\n    }\n\n  ret = TRUE;\nout:\n  return ret;\n}\n\ngboolean\nflatpak_dir_prune (FlatpakDir   *self,\n                   GCancellable *cancellable,\n                   GError      **error)\n{\n  gboolean ret = FALSE;\n  gint objects_total, objects_pruned;\n  guint64 pruned_object_size_total;\n  g_autofree char *formatted_freed_size = NULL;\n  g_autoptr(GError) local_error = NULL;\n  g_autoptr(GError) lock_error = NULL;\n  g_auto(GLnxLockFile) lock = { 0, };\n\n  if (error == NULL)\n    error = &local_error;\n\n  if (flatpak_dir_use_system_helper (self, NULL))\n    {\n      const char *installation = flatpak_dir_get_id (self);\n\n      if (!flatpak_dir_system_helper_call_prune_local_repo (self,\n                                                            FLATPAK_HELPER_PRUNE_LOCAL_REPO_FLAGS_NONE,\n                                                            installation ? installation : \"\",\n                                                            cancellable,\n                                                            error))\n        return FALSE;\n\n      return TRUE;\n    }\n\n  if (!flatpak_dir_ensure_repo (self, cancellable, error))\n    goto out;\n\n  /* This could remove objects, so take an exclusive repo lock */\n  if (!flatpak_dir_repo_lock (self, &lock, LOCK_EX | LOCK_NB, cancellable, &lock_error))\n    {\n      /* If we can't get an exclusive lock, don't block for a long time. Eventually\n         the shared lock operation is released and we will do a prune then */\n      if (g_error_matches (lock_error, G_IO_ERROR, G_IO_ERROR_WOULD_BLOCK))\n        {\n          g_debug (\"Skipping prune due to in progress operation\");\n          return TRUE;\n        }\n\n      g_propagate_error (error, g_steal_pointer (&lock_error));\n      return FALSE;\n    }\n\n  g_debug (\"Pruning repo\");\n  if (!ostree_repo_prune (self->repo,\n                          OSTREE_REPO_PRUNE_FLAGS_REFS_ONLY,\n                          0,\n                          &objects_total,\n                          &objects_pruned,\n                          &pruned_object_size_total,\n                          cancellable, error))\n    goto out;\n\n  formatted_freed_size = g_format_size_full (pruned_object_size_total, 0);\n  g_debug (\"Pruned %d/%d objects, size %s\", objects_total, objects_pruned, formatted_freed_size);\n\n  ret = TRUE;\n\nout:\n\n  /* There was an issue in ostree where for local pulls we don't get a .commitpartial (now fixed),\n     which caused errors when pruning. We print these here, but don't stop processing. */\n  if (local_error != NULL)\n    g_print (_(\"Pruning repo failed: %s\"), local_error->message);\n\n  return ret;\n}\n\ngboolean\nflatpak_dir_update_summary (FlatpakDir   *self,\n                            gboolean      delete,\n                            GCancellable *cancellable,\n                            GError      **error)\n{\n  if (flatpak_dir_use_system_helper (self, NULL))\n    {\n      const char *installation = flatpak_dir_get_id (self);\n\n      return flatpak_dir_system_helper_call_update_summary (self,\n                                                            delete ? FLATPAK_HELPER_UPDATE_SUMMARY_FLAGS_DELETE\n                                                                   : FLATPAK_HELPER_UPDATE_SUMMARY_FLAGS_NONE,\n                                                            installation ? installation : \"\",\n                                                            cancellable,\n                                                            error);\n    }\n\n  if (!flatpak_dir_ensure_repo (self, cancellable, error))\n    return FALSE;\n\n  if (delete)\n    {\n      g_autoptr(GError) local_error = NULL;\n      g_autoptr(GFile) summary_file = NULL;\n\n      g_debug (\"Deleting summary\");\n\n      summary_file = g_file_get_child (ostree_repo_get_path (self->repo), \"summary\");\n\n      if (!g_file_delete (summary_file, cancellable, &local_error) &&\n          !g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND))\n        {\n          g_propagate_error (error, g_steal_pointer (&local_error));\n          return FALSE;\n        }\n      return TRUE;\n    }\n  else\n    {\n      g_auto(GLnxLockFile) lock = { 0, };\n\n      g_debug (\"Updating summary\");\n\n      /* Keep a shared repo lock to avoid prunes removing objects we're relying on\n       * while generating the summary. */\n      if (!flatpak_dir_repo_lock (self, &lock, LOCK_SH, cancellable, error))\n        return FALSE;\n\n      return ostree_repo_regenerate_summary (self->repo, NULL, cancellable, error);\n    }\n}\n\nGFile *\nflatpak_dir_get_if_deployed (FlatpakDir        *self,\n                             FlatpakDecomposed *ref,\n                             const char        *checksum,\n                             GCancellable      *cancellable)\n{\n  g_autoptr(GFile) deploy_base = NULL;\n  g_autoptr(GFile) deploy_dir = NULL;\n\n  deploy_base = flatpak_dir_get_deploy_dir (self, ref);\n\n  if (checksum != NULL)\n    {\n      deploy_dir = g_file_get_child (deploy_base, checksum);\n    }\n  else\n    {\n      g_autoptr(GFile) active_link = g_file_get_child (deploy_base, \"active\");\n      g_autoptr(GFileInfo) info = NULL;\n      const char *target;\n\n      info = g_file_query_info (active_link,\n                                G_FILE_ATTRIBUTE_STANDARD_TYPE \",\" G_FILE_ATTRIBUTE_STANDARD_SYMLINK_TARGET,\n                                G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n                                NULL,\n                                NULL);\n      if (info == NULL)\n        return NULL;\n\n      target = g_file_info_get_symlink_target (info);\n      if (target == NULL)\n        return NULL;\n\n      deploy_dir = g_file_get_child (deploy_base, target);\n    }\n\n  if (g_file_query_file_type (deploy_dir, G_FILE_QUERY_INFO_NONE, cancellable) == G_FILE_TYPE_DIRECTORY)\n    return g_object_ref (deploy_dir);\n\n  /* Maybe it was removed but is still living? */\n  if (checksum != NULL)\n    {\n      g_autoptr(GFile) removed_dir = flatpak_dir_get_removed_dir (self);\n      g_autoptr(GFile) removed_deploy_dir = NULL;\n      g_autofree char *id = flatpak_decomposed_dup_id (ref);\n      g_autofree char *dirname = NULL;\n\n      dirname = g_strdup_printf (\"%s-%s\", id, checksum);\n      removed_deploy_dir = g_file_get_child (removed_dir, dirname);\n\n      if (g_file_query_file_type (removed_deploy_dir, G_FILE_QUERY_INFO_NONE, cancellable) == G_FILE_TYPE_DIRECTORY)\n        return g_object_ref (removed_deploy_dir);\n    }\n\n  return NULL;\n}\n\nGFile *\nflatpak_dir_get_unmaintained_extension_dir_if_exists (FlatpakDir   *self,\n                                                      const char   *name,\n                                                      const char   *arch,\n                                                      const char   *branch,\n                                                      GCancellable *cancellable)\n{\n  g_autoptr(GFile) extension_dir = NULL;\n  g_autoptr(GFileInfo) extension_dir_info = NULL;\n\n  extension_dir = flatpak_dir_get_unmaintained_extension_dir (self, name, arch, branch);\n\n  extension_dir_info = g_file_query_info (extension_dir,\n                                          G_FILE_ATTRIBUTE_STANDARD_SYMLINK_TARGET,\n                                          G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n                                          cancellable,\n                                          NULL);\n  if (extension_dir_info == NULL)\n    return NULL;\n\n  if (g_file_info_get_is_symlink (extension_dir_info))\n    return g_file_new_for_path (g_file_info_get_symlink_target (extension_dir_info));\n  else\n    return g_steal_pointer (&extension_dir);\n}\n\nstatic void\nremote_filter_free (RemoteFilter *remote_filter)\n{\n  g_free (remote_filter->checksum);\n  g_object_unref (remote_filter->path);\n  if (remote_filter->allow)\n    g_regex_unref (remote_filter->allow);\n  if (remote_filter->deny)\n    g_regex_unref (remote_filter->deny);\n\n  g_free (remote_filter);\n}\n\n\nstatic RemoteFilter *\nremote_filter_load (GFile *path, GError **error)\n{\n  RemoteFilter *filter;\n  g_autofree char *data = NULL;\n  gsize data_size;\n  GTimeVal mtime;\n  g_autoptr(GRegex) allow_refs = NULL;\n  g_autoptr(GRegex) deny_refs = NULL;\n\n  /* Save mtime before loading to avoid races */\n  if (!get_mtime (path, &mtime, NULL, error))\n    {\n      glnx_prefix_error (error, _(\"Failed to load filter '%s'\"), flatpak_file_get_path_cached (path));\n      return NULL;\n    }\n\n  if (!g_file_load_contents (path, NULL, &data, &data_size, NULL, error))\n    {\n      glnx_prefix_error (error, _(\"Failed to load filter '%s'\"), flatpak_file_get_path_cached (path));\n      return NULL;\n    }\n\n  if (!flatpak_parse_filters (data, &allow_refs, &deny_refs, error))\n    {\n      glnx_prefix_error (error, _(\"Failed to parse filter '%s'\"), flatpak_file_get_path_cached (path));\n      return NULL;\n    }\n\n  filter = g_new0 (RemoteFilter, 1);\n  filter->checksum = g_compute_checksum_for_data (G_CHECKSUM_SHA1, (guchar *)data, data_size);\n  filter->path = g_object_ref (path);\n  filter->mtime = mtime;\n  filter->last_mtime_check = g_get_monotonic_time ();\n  filter->allow = g_steal_pointer (&allow_refs);\n  filter->deny = g_steal_pointer (&deny_refs);\n\n  return filter;\n}\n\nG_LOCK_DEFINE_STATIC (filters);\n\nstatic gboolean\nflatpak_dir_lookup_remote_filter (FlatpakDir *self,\n                                  const char *name,\n                                  gboolean    force_load,\n                                  char      **checksum_out,\n                                  GRegex    **allow_regex,\n                                  GRegex    **deny_regex,\n                                  GError **error)\n{\n  RemoteFilter *filter = NULL;\n  g_autofree char *filter_path = NULL;\n  gboolean handled_fallback = FALSE;\n  g_autoptr(GFile) filter_file = NULL;\n\n  if (checksum_out)\n    *checksum_out = NULL;\n  *allow_regex = NULL;\n  *deny_regex = NULL;\n\n  filter_path = flatpak_dir_get_remote_filter (self, name);\n\n  if (filter_path == NULL)\n    return TRUE;\n\n  filter_file = g_file_new_for_path (filter_path);\n\n  G_LOCK (filters);\n\n  if (self->remote_filters == NULL)\n    self->remote_filters = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, (GDestroyNotify) remote_filter_free);\n\n  filter = g_hash_table_lookup (self->remote_filters, name);\n  if (filter)\n    {\n      guint64 now = g_get_monotonic_time ();\n      GTimeVal mtime;\n\n      if (g_file_equal (filter->path, filter_file) != 0)\n        filter = NULL; /* New path, reload */\n      else if ((now - filter->last_mtime_check) > (1000 * (FILTER_MTIME_CHECK_TIMEOUT_MSEC)))\n        {\n          /* Fall back to backup copy if remote filter disappears */\n          handled_fallback = TRUE;\n          if (!g_file_query_exists (filter_file, NULL))\n            {\n              g_autofree char *basename = g_strconcat (name, \".filter\", NULL);\n              g_object_unref (filter_file);\n              filter_file = flatpak_build_file (self->basedir, \"repo\", basename, NULL);\n            }\n\n          filter->last_mtime_check = now;\n          if (!get_mtime (filter_file, &mtime, NULL, NULL) ||\n              mtime.tv_sec != filter->mtime.tv_sec ||\n              mtime.tv_usec != filter->mtime.tv_usec)\n            filter = NULL; /* Different mtime, reload */\n        }\n    }\n\n  if (filter)\n    {\n      if (checksum_out)\n        *checksum_out = g_strdup (filter->checksum);\n      if (filter->allow)\n        *allow_regex = g_regex_ref (filter->allow);\n      if (filter->deny)\n        *deny_regex = g_regex_ref (filter->deny);\n    }\n\n  G_UNLOCK (filters);\n\n  if (filter) /* This is outside the lock, but we already copied the returned data, and we're not dereferencing filter */\n    return TRUE;\n\n  /* Fall back to backup copy if remote filter disappears */\n  if (!handled_fallback && !g_file_query_exists (filter_file, NULL))\n    {\n      g_autofree char *basename = g_strconcat (name, \".filter\", NULL);\n      g_object_unref (filter_file);\n      filter_file = flatpak_build_file (self->basedir, \"repo\", basename, NULL);\n    }\n\n  filter = remote_filter_load (filter_file, error);\n  if (filter == NULL)\n    return FALSE;\n\n  if (checksum_out)\n    *checksum_out = g_strdup (filter->checksum);\n  if (filter->allow)\n    *allow_regex = g_regex_ref (filter->allow);\n  if (filter->deny)\n    *deny_regex = g_regex_ref (filter->deny);\n\n  G_LOCK (filters);\n  g_hash_table_replace (self->remote_filters, g_strdup (name), filter);\n  G_UNLOCK (filters);\n\n  return TRUE;\n}\n\nG_LOCK_DEFINE_STATIC (cache);\n\n/* FIXME: Move all this caching into libostree. */\nstatic void\ncached_summary_free (CachedSummary *summary)\n{\n  g_bytes_unref (summary->bytes);\n  if (summary->bytes_sig)\n    g_bytes_unref (summary->bytes_sig);\n  g_free (summary->name);\n  g_free (summary->url);\n  g_free (summary);\n}\n\nstatic CachedSummary *\ncached_summary_new (GBytes     *bytes,\n                    GBytes     *bytes_sig,\n                    const char *name,\n                    const char *url)\n{\n  CachedSummary *summary = g_new0 (CachedSummary, 1);\n\n  summary->bytes = g_bytes_ref (bytes);\n  if (bytes_sig)\n    summary->bytes_sig = g_bytes_ref (bytes_sig);\n  summary->url = g_strdup (url);\n  summary->name = g_strdup (name);\n  summary->time = g_get_monotonic_time ();\n  return summary;\n}\n\nstatic gboolean\nflatpak_dir_lookup_cached_summary (FlatpakDir *self,\n                                   GBytes    **bytes_out,\n                                   GBytes    **bytes_sig_out,\n                                   const char *name,\n                                   const char *url)\n{\n  CachedSummary *summary;\n  gboolean res = FALSE;\n\n  G_LOCK (cache);\n\n  if (self->summary_cache == NULL)\n    self->summary_cache = g_hash_table_new_full (g_str_hash, g_str_equal, NULL, (GDestroyNotify) cached_summary_free);\n\n  summary = g_hash_table_lookup (self->summary_cache, name);\n  if (summary)\n    {\n      guint64 now = g_get_monotonic_time ();\n      if ((now - summary->time) / G_USEC_PER_SEC < SUMMARY_CACHE_TIMEOUT_SEC &&\n          strcmp (url, summary->url) == 0)\n        {\n          /* g_debug (\"Using cached summary for remote %s\", name); */\n          *bytes_out = g_bytes_ref (summary->bytes);\n          if (bytes_sig_out)\n            {\n              if (summary->bytes_sig)\n                *bytes_sig_out = g_bytes_ref (summary->bytes_sig);\n              else\n                *bytes_sig_out = NULL;\n            }\n          res = TRUE;\n\n          /* Bump the cache expiry time */\n          summary->time = now;\n        }\n      else\n        {\n          /* Timed out or URL has changed; remove the entry */\n          g_hash_table_remove (self->summary_cache, name);\n          res = FALSE;\n        }\n    }\n\n  G_UNLOCK (cache);\n\n  return res;\n}\n\nstatic void\nflatpak_dir_cache_summary (FlatpakDir *self,\n                           GBytes     *bytes,\n                           GBytes     *bytes_sig,\n                           const char *name,\n                           const char *url)\n{\n  CachedSummary *summary;\n\n  /* No sense caching the summary if there isn't one */\n  if (!bytes)\n    return;\n\n  G_LOCK (cache);\n\n  /* This was already initialized in the cache-miss lookup */\n  g_assert (self->summary_cache != NULL);\n\n  summary = cached_summary_new (bytes, bytes_sig, name, url);\n  g_hash_table_replace (self->summary_cache, summary->name, summary);\n\n  G_UNLOCK (cache);\n}\n\ngboolean\nflatpak_dir_remote_make_oci_summary (FlatpakDir   *self,\n                                     const char   *remote,\n                                     gboolean      only_cached,\n                                     GBytes      **out_summary,\n                                     GCancellable *cancellable,\n                                     GError      **error)\n{\n  g_autoptr(GVariant) summary = NULL;\n  g_autoptr(GFile) index_cache = NULL;\n  g_autofree char *index_uri = NULL;\n  g_autoptr(GFile) summary_cache = NULL;\n  g_autofree char *self_name = NULL;\n  g_autoptr(GError) local_error = NULL;\n  g_autoptr(GMappedFile) mfile = NULL;\n  g_autoptr(GBytes) cache_bytes = NULL;\n  g_autoptr(GBytes) summary_bytes = NULL;\n\n  if (flatpak_dir_use_system_helper (self, NULL))\n    {\n      const char *installation = flatpak_dir_get_id (self);\n      FlatpakHelperGenerateOciSummaryFlags flags = FLATPAK_HELPER_GENERATE_OCI_SUMMARY_FLAGS_NONE;\n\n      if (only_cached)\n        flags |= FLATPAK_HELPER_GENERATE_OCI_SUMMARY_FLAGS_ONLY_CACHED;\n\n      if (!flatpak_dir_system_helper_call_generate_oci_summary (self,\n                                                                flags,\n                                                                remote,\n                                                                installation ? installation : \"\",\n                                                                cancellable, error))\n        return FALSE;\n\n      summary_cache = flatpak_dir_get_oci_summary_location (self, remote, error);\n      if (summary_cache == NULL)\n        return FALSE;\n    }\n  else\n    {\n      self_name = flatpak_dir_get_name (self);\n\n      index_cache = flatpak_dir_update_oci_index (self, remote, &index_uri, cancellable, error);\n      if (index_cache == NULL)\n        return FALSE;\n\n      summary_cache = flatpak_dir_get_oci_summary_location (self, remote, error);\n      if (summary_cache == NULL)\n        return FALSE;\n\n      if (!only_cached && !check_destination_mtime (index_cache, summary_cache, cancellable))\n        {\n          summary = flatpak_oci_index_make_summary (index_cache, index_uri, cancellable, &local_error);\n          if (summary == NULL)\n            {\n              g_propagate_error (error, g_steal_pointer (&local_error));\n              return FALSE;\n            }\n\n          summary_bytes = g_variant_get_data_as_bytes (summary);\n\n          if (!g_file_replace_contents (summary_cache,\n                                        g_bytes_get_data (summary_bytes, NULL),\n                                        g_bytes_get_size (summary_bytes),\n                                        NULL, FALSE, 0, NULL, cancellable, error))\n            {\n              g_prefix_error (error, _(\"Failed to write summary cache: \"));\n              return FALSE;\n            }\n\n          if (out_summary)\n            *out_summary = g_steal_pointer (&summary_bytes);\n          return TRUE;\n        }\n    }\n\n  if (out_summary)\n    {\n      mfile = g_mapped_file_new (flatpak_file_get_path_cached (summary_cache), FALSE, error);\n      if (mfile == NULL)\n        {\n          if (only_cached)\n            {\n              g_clear_error (error);\n              g_set_error (error, FLATPAK_ERROR, FLATPAK_ERROR_NOT_CACHED,\n                           _(\"No oci summary cached for remote '%s'\"), remote);\n            }\n\n          return FALSE;\n        }\n\n      cache_bytes = g_mapped_file_get_bytes (mfile);\n      *out_summary = g_steal_pointer (&cache_bytes);\n    }\n\n  return TRUE;\n}\n\ntypedef struct {\n  char *filename;\n  gint64 mtime;\n} CachedSummaryData;\n\nstatic void\ncached_summary_data_free (CachedSummaryData *data)\n{\n  g_free (data->filename);\n  g_free (data);\n}\n\nstatic gboolean\nflatpak_dir_gc_cached_digested_summaries (FlatpakDir   *self,\n                                          const char   *remote_name,\n                                          const char   *dont_prune_file,\n                                          GCancellable *cancellable,\n                                          GError      **error)\n{\n  g_autoptr(GHashTable) cached_data_for_arch = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, (GDestroyNotify)cached_summary_data_free);\n  g_autoptr(GFile) cache_dir = flatpak_build_file (self->cache_dir, \"summaries\", NULL);\n  g_auto(GLnxDirFdIterator) iter = {0};\n  struct dirent *dent;\n  g_autoptr(GError) local_error = NULL;\n\n  if (!glnx_dirfd_iterator_init_at (AT_FDCWD, flatpak_file_get_path_cached (cache_dir), FALSE, &iter, &local_error))\n    {\n      if (g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND))\n        return TRUE;\n\n      g_propagate_error (error, g_steal_pointer (&local_error));\n      return FALSE;\n    }\n\n  g_autofree char *prefix = g_strconcat (remote_name, \"-\", NULL);\n\n  while (TRUE)\n    {\n      struct stat stbuf;\n      const char *arch_start, *arch_end;\n      g_autofree char *arch = NULL;\n\n      if (!glnx_dirfd_iterator_next_dent_ensure_dtype (&iter, &dent, cancellable, error))\n        return FALSE;\n\n      if (dent == NULL)\n        break;\n\n      /* Cached are regular file named \"${remote-name}-${arch}-${sha256}.sub\", ignore anything else */\n      if (dent->d_type != DT_REG ||\n          !g_str_has_prefix (dent->d_name, prefix) ||\n          !g_str_has_suffix (dent->d_name, \".sub\"))\n        continue;\n\n      arch_start = dent->d_name + strlen (prefix);\n      arch_end = strchr (arch_start, '-');\n      if (arch_end == NULL)\n        continue;\n\n      /* Keep the latest subsummary for each remote-name + arch so we can use it for deltas */\n      if (fstatat (iter.fd, dent->d_name, &stbuf, AT_SYMLINK_NOFOLLOW) == -1)\n        {\n          glnx_set_error_from_errno (error);\n          return FALSE;\n        }\n\n      arch = g_strndup (arch_start, arch_end - arch_start);\n\n      CachedSummaryData *old_data = g_hash_table_lookup (cached_data_for_arch, arch);\n      if (old_data == NULL || stbuf.st_mtime > old_data->mtime)\n        {\n          CachedSummaryData *new_data;\n\n          if (old_data &&\n              strcmp (dont_prune_file, old_data->filename) != 0 &&\n              unlinkat (iter.fd, old_data->filename, 0) != 0)\n            {\n              glnx_set_error_from_errno (error);\n              return FALSE;\n            }\n\n          new_data = g_new0 (CachedSummaryData, 1);\n          new_data->filename = g_strdup (dent->d_name);\n          new_data->mtime = stbuf.st_mtime;\n          g_hash_table_insert (cached_data_for_arch, g_steal_pointer (&arch), new_data);\n        }\n      else /* stbuf.st_mtime <= old_data->mtime */\n        {\n          if (stbuf.st_mtime < old_data->mtime &&\n              strcmp (dont_prune_file, dent->d_name) != 0 &&\n              unlinkat (iter.fd, dent->d_name, 0) != 0)\n            {\n              glnx_set_error_from_errno (error);\n              return FALSE;\n            }\n        }\n    }\n\n  return TRUE;\n}\n\nstatic gboolean\n_flatpak_dir_remote_clear_cached_summary (FlatpakDir   *self,\n                                          const char   *remote,\n                                          const char   *extension,\n                                          GCancellable *cancellable,\n                                          GError      **error)\n{\n  g_autoptr(GFile) cache_dir = flatpak_build_file (self->cache_dir, \"summaries\", NULL);\n  g_autofree char *filename = g_strconcat (remote, extension, NULL);\n  g_autoptr(GFile) file = flatpak_build_file (cache_dir, filename, NULL);\n  g_autoptr(GError) local_error = NULL;\n\n  if (!g_file_delete (file, NULL, &local_error) &&\n      !g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND))\n    {\n      g_propagate_error (error, g_steal_pointer (&local_error));\n      return FALSE;\n    }\n\n  return TRUE;\n}\n\nstatic gboolean\nflatpak_dir_remote_clear_cached_summary (FlatpakDir   *self,\n                                         const char   *remote,\n                                         GCancellable *cancellable,\n                                         GError      **error)\n{\n  g_debug (\"Clearing cached summaries for remote %s\", remote);\n  if (!_flatpak_dir_remote_clear_cached_summary (self, remote, NULL, cancellable, error))\n    return FALSE;\n  if (!_flatpak_dir_remote_clear_cached_summary (self, remote, \".sig\", cancellable, error))\n    return FALSE;\n  if (!_flatpak_dir_remote_clear_cached_summary (self, remote, \".idx\", cancellable, error))\n    return FALSE;\n  if (!_flatpak_dir_remote_clear_cached_summary (self, remote, \".idx.sig\", cancellable, error))\n    return FALSE;\n  return TRUE;\n}\n\n\nstatic gboolean\nflatpak_dir_remote_save_cached_summary (FlatpakDir   *self,\n                                        const char   *basename,\n                                        const char   *main_ext,\n                                        const char   *sig_ext,\n                                        GBytes       *main,\n                                        GBytes       *sig,\n                                        GCancellable *cancellable,\n                                        GError      **error)\n{\n  g_autofree char *main_file_name = g_strconcat (basename, main_ext, NULL);\n  g_autofree char *sig_file_name = g_strconcat (basename, sig_ext, NULL);\n  g_autoptr(GFile) cache_dir = flatpak_build_file (self->cache_dir, \"summaries\", NULL);\n  g_autoptr(GFile) main_cache_file = flatpak_build_file (cache_dir, main_file_name, NULL);\n  g_autoptr(GFile) sig_cache_file = flatpak_build_file (cache_dir, sig_file_name, NULL);\n  g_autoptr(GError) local_error = NULL;\n\n  if (!flatpak_mkdir_p (cache_dir, cancellable, error))\n    return FALSE;\n\n  if (!g_file_replace_contents (main_cache_file, g_bytes_get_data (main, NULL), g_bytes_get_size (main), NULL, FALSE,\n                                G_FILE_CREATE_REPLACE_DESTINATION, NULL, cancellable, error))\n    return FALSE;\n\n  if (sig_ext)\n    {\n      if (sig)\n        {\n          if (!g_file_replace_contents (sig_cache_file, g_bytes_get_data (sig, NULL), g_bytes_get_size (sig), NULL, FALSE,\n                                        G_FILE_CREATE_REPLACE_DESTINATION, NULL, cancellable, error))\n            return FALSE;\n        }\n      else\n        {\n          if (!g_file_delete (sig_cache_file, NULL, &local_error) &&\n              !g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND))\n            {\n              g_propagate_error (error, g_steal_pointer (&local_error));\n              return FALSE;\n            }\n        }\n    }\n\n  return TRUE;\n}\n\nstatic gboolean\nflatpak_dir_remote_load_cached_summary (FlatpakDir   *self,\n                                        const char   *basename,\n                                        const char   *main_ext,\n                                        const char   *sig_ext,\n                                        GBytes      **out_main,\n                                        GBytes      **out_sig,\n                                        GCancellable *cancellable,\n                                        GError      **error)\n{\n  g_autofree char *main_file_name = g_strconcat (basename, main_ext, NULL);\n  g_autofree char *sig_file_name = g_strconcat (basename, sig_ext, NULL);\n  g_autoptr(GFile) main_cache_file = flatpak_build_file (self->cache_dir, \"summaries\", main_file_name, NULL);\n  g_autoptr(GFile) sig_cache_file = flatpak_build_file (self->cache_dir, \"summaries\", sig_file_name, NULL);\n  g_autoptr(GMappedFile) mfile = NULL;\n  g_autoptr(GMappedFile) sig_mfile = NULL;\n\n  mfile = g_mapped_file_new (flatpak_file_get_path_cached (main_cache_file), FALSE, NULL);\n  if (mfile == NULL)\n    {\n      g_set_error (error, FLATPAK_ERROR, FLATPAK_ERROR_NOT_CACHED,\n                   _(\"No cached summary for remote '%s'\"), basename);\n      return FALSE;\n    }\n\n  if (out_sig)\n    sig_mfile = g_mapped_file_new (flatpak_file_get_path_cached (sig_cache_file), FALSE, NULL);\n\n  *out_main = g_mapped_file_get_bytes (mfile);\n  if (sig_mfile)\n    *out_sig = g_mapped_file_get_bytes (sig_mfile);\n\n  return TRUE;\n}\n\nstatic gboolean\nflatpak_dir_remote_fetch_summary (FlatpakDir   *self,\n                                  const char   *name_or_uri,\n                                  gboolean      only_cached,\n                                  GBytes      **out_summary,\n                                  GBytes      **out_summary_sig,\n                                  GCancellable *cancellable,\n                                  GError      **error)\n{\n  g_autofree char *url = NULL;\n  gboolean is_local;\n  g_autoptr(GError) local_error = NULL;\n  g_autoptr(GBytes) summary = NULL;\n  g_autoptr(GBytes) summary_sig = NULL;\n\n  if (!ostree_repo_remote_get_url (self->repo, name_or_uri, &url, error))\n    return FALSE;\n\n  if (!g_str_has_prefix (name_or_uri, \"file:\") && flatpak_dir_get_remote_disabled (self, name_or_uri))\n    {\n      g_set_error (error, G_IO_ERROR, G_IO_ERROR_INVALID_DATA,\n                   \"Can't fetch summary from disabled remote \u2018%s\u2019\", name_or_uri);\n      return FALSE;\n    }\n\n  is_local = g_str_has_prefix (url, \"file:\");\n\n  /* Seems ostree asserts if this is NULL */\n  if (error == NULL)\n    error = &local_error;\n\n  if (flatpak_dir_get_remote_oci (self, name_or_uri))\n    {\n      if (!flatpak_dir_remote_make_oci_summary (self, name_or_uri,\n                                                only_cached,\n                                                &summary,\n                                                cancellable,\n                                                error))\n        return FALSE;\n    }\n  else\n    {\n      if (only_cached)\n        {\n          if (!flatpak_dir_remote_load_cached_summary (self, name_or_uri, NULL, \".sig\",\n                                                       &summary, &summary_sig, cancellable, error))\n            return FALSE;\n          g_debug (\"Loaded summary from cache for remote \u2018%s\u2019\", name_or_uri);\n        }\n      else\n        {\n          g_debug (\"Fetching summary file for remote \u2018%s\u2019\", name_or_uri);\n          if (!ostree_repo_remote_fetch_summary (self->repo, name_or_uri,\n                                                 &summary, &summary_sig,\n                                                 cancellable,\n                                                 error))\n            return FALSE;\n        }\n    }\n\n  if (summary == NULL)\n    return flatpak_fail_error (error, FLATPAK_ERROR_INVALID_DATA, _(\"Remote listing for %s not available; server has no summary file. Check the URL passed to remote-add was valid.\"), name_or_uri);\n\n  if (!is_local && !only_cached)\n    {\n      g_autofree char *cache_key = g_strconcat (\"summary-\", name_or_uri, NULL);\n      flatpak_dir_cache_summary (self, summary, summary_sig, cache_key, url);\n    }\n\n  *out_summary = g_steal_pointer (&summary);\n  if (out_summary_sig)\n    *out_summary_sig = g_steal_pointer (&summary_sig);\n\n  return TRUE;\n}\n\nstatic gboolean\nremote_verify_signature (OstreeRepo *repo,\n                         const char *remote_name,\n                         GBytes *data,\n                         GBytes *sig_file,\n                         GCancellable *cancellable,\n                         GError **error)\n{\n  g_autoptr(GVariant) signatures_variant = NULL;\n  g_autoptr(GVariant) signaturedata = NULL;\n  g_autoptr (GBytes) signatures = NULL;\n  g_autoptr(GByteArray) buffer = NULL;\n  g_autoptr(OstreeGpgVerifyResult) verify_result = NULL;\n  GVariantIter iter;\n  GVariant *child;\n\n  signatures_variant = g_variant_new_from_bytes (OSTREE_SUMMARY_SIG_GVARIANT_FORMAT,\n                                                 sig_file, FALSE);\n  signaturedata = g_variant_lookup_value (signatures_variant, \"ostree.gpgsigs\", G_VARIANT_TYPE (\"aay\"));\n  if (signaturedata == NULL)\n    {\n      g_set_error_literal (error, OSTREE_GPG_ERROR, OSTREE_GPG_ERROR_NO_SIGNATURE,\n                           \"GPG verification enabled, but no signatures found (use gpg-verify=false in remote config to disable)\");\n      return FALSE;\n    }\n\n  buffer = g_byte_array_new ();\n  g_variant_iter_init (&iter, signaturedata);\n  while ((child = g_variant_iter_next_value (&iter)) != NULL)\n    {\n      g_byte_array_append (buffer,\n                           g_variant_get_data (child),\n                           g_variant_get_size (child));\n      g_variant_unref (child);\n    }\n  signatures = g_byte_array_free_to_bytes (g_steal_pointer (&buffer));\n\n  verify_result = ostree_repo_gpg_verify_data (repo,\n                                               remote_name,\n                                               data,\n                                               signatures,\n                                               NULL, NULL,\n                                               cancellable, error);\n  if (!ostree_gpg_verify_result_require_valid_signature (verify_result, error))\n    return FALSE;\n\n  return TRUE;\n}\n\nstatic GBytes *\nload_uri_with_fallback (SoupSession           *soup_session,\n                        const char            *uri,\n                        const char            *uri2,\n                        FlatpakHTTPFlags       flags,\n                        const char            *token,\n                        GCancellable          *cancellable,\n                        GError               **error)\n{\n  g_autoptr(GError) local_error = NULL;\n  GBytes *res;\n\n  res = flatpak_load_uri (soup_session, uri, flags, token,\n                          NULL, NULL, NULL,\n                          cancellable, &local_error);\n  if (res)\n    return res;\n\n  if (!g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND))\n    {\n      g_propagate_error (error, g_steal_pointer (&local_error));\n      return NULL;\n    }\n\n  return flatpak_load_uri (soup_session, uri2, flags, token,\n                           NULL, NULL, NULL,\n                           cancellable, error);\n}\n\nstatic gboolean\nflatpak_dir_remote_fetch_summary_index (FlatpakDir   *self,\n                                        const char   *name_or_uri,\n                                        gboolean      only_cached,\n                                        GBytes      **out_index,\n                                        GBytes      **out_index_sig,\n                                        GCancellable *cancellable,\n                                        GError      **error)\n{\n  g_autofree char *url = NULL;\n  gboolean is_local;\n  g_autoptr(GError) local_error = NULL;\n  g_autoptr(GError) cache_error = NULL;\n  g_autoptr(GBytes) cached_index = NULL;\n  g_autoptr(GBytes) cached_index_sig = NULL;\n  g_autoptr(GBytes) index = NULL;\n  g_autoptr(GBytes) index_sig = NULL;\n  gboolean gpg_verify_summary;\n\n  ensure_soup_session (self);\n\n  if (!ostree_repo_remote_get_url (self->repo, name_or_uri, &url, error))\n    return FALSE;\n\n  if (!ostree_repo_remote_get_gpg_verify_summary (self->repo, name_or_uri, &gpg_verify_summary, NULL))\n    return FALSE;\n\n  if (!g_str_has_prefix (name_or_uri, \"file:\") && flatpak_dir_get_remote_disabled (self, name_or_uri))\n    {\n      g_set_error (error, G_IO_ERROR, G_IO_ERROR_INVALID_DATA,\n                   \"Can't fetch summary from disabled remote \u2018%s\u2019\", name_or_uri);\n      return FALSE;\n    }\n\n  if (flatpak_dir_get_remote_oci (self, name_or_uri))\n    {\n      g_set_error (error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND,\n                   \"No index in OCI remote \u2018%s\u2019\", name_or_uri);\n      return FALSE;\n    }\n\n  is_local = g_str_has_prefix (url, \"file:\");\n\n  /* Seems ostree asserts if this is NULL */\n  if (error == NULL)\n    error = &local_error;\n\n  flatpak_dir_remote_load_cached_summary (self, name_or_uri, \".idx\", \".idx.sig\",\n                                          &cached_index, &cached_index_sig, cancellable, &cache_error);\n\n  if (only_cached)\n    {\n      if (cached_index == NULL)\n        {\n          g_propagate_error (error, g_steal_pointer (&cache_error));\n          return FALSE;\n        }\n      g_debug (\"Loaded summary index from cache for remote \u2018%s\u2019\", name_or_uri);\n\n      index = g_steal_pointer (&cached_index);\n      if (gpg_verify_summary)\n        index_sig = g_steal_pointer (&cached_index_sig);\n    }\n  else\n    {\n      g_autofree char *index_url = g_build_filename (url, \"summary.idx\", NULL);\n      g_autoptr(GBytes) dl_index = NULL;\n      gboolean used_download = FALSE;\n\n      g_debug (\"Fetching summary index file for remote \u2018%s\u2019\", name_or_uri);\n\n      dl_index = flatpak_load_uri (self->soup_session, index_url, 0, NULL,\n                                   NULL, NULL, NULL,\n                                   cancellable, error);\n      if (dl_index == NULL)\n        return FALSE;\n\n      /* If the downloaded index is the same as the cached one we need not re-download or\n       * re-verify, just use the cache (which we verified before) */\n      if (cached_index != NULL && g_bytes_equal (cached_index, dl_index))\n        {\n          index = g_steal_pointer (&cached_index);\n          if (gpg_verify_summary)\n            index_sig = g_steal_pointer (&cached_index_sig);\n        }\n      else\n        {\n          index = g_steal_pointer (&dl_index);\n          used_download = TRUE;\n        }\n\n      if (gpg_verify_summary && index_sig == NULL)\n        {\n          g_autofree char *index_digest = g_compute_checksum_for_bytes (G_CHECKSUM_SHA256, index);\n          g_autofree char *index_sig_filename = g_strconcat (index_digest, \".idx.sig\", NULL);\n          g_autofree char *index_sig_url = g_build_filename (url, \"summaries\", index_sig_filename, NULL);\n          g_autofree char *index_sig_url2 = g_build_filename (url, \"summary.idx.sig\", NULL);\n          g_autoptr(GError) dl_sig_error = NULL;\n          g_autoptr (GBytes) dl_index_sig = NULL;\n\n          dl_index_sig = load_uri_with_fallback (self->soup_session, index_sig_url, index_sig_url2, 0, NULL,\n                                                 cancellable, &dl_sig_error);\n          if (dl_index_sig == NULL)\n            {\n              if (g_error_matches (dl_sig_error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND))\n                g_set_error (error, OSTREE_GPG_ERROR, OSTREE_GPG_ERROR_NO_SIGNATURE,\n                             \"GPG verification enabled, but no summary signatures found (use gpg-verify-summary=false in remote config to disable)\");\n              else\n                g_propagate_error (error, g_steal_pointer (&dl_sig_error));\n\n              return FALSE;\n            }\n\n          if (!remote_verify_signature (self->repo, name_or_uri,\n                                        index, dl_index_sig,\n                                        cancellable, error))\n            return FALSE;\n\n          index_sig = g_steal_pointer (&dl_index_sig);\n          used_download = TRUE;\n        }\n\n      g_assert (index != NULL);\n      if (gpg_verify_summary)\n        g_assert (index_sig != NULL);\n\n      /* Update cache on disk if we downloaded anything, but never cache for file: repos */\n      if (used_download && !is_local &&\n          !flatpak_dir_remote_save_cached_summary (self, name_or_uri, \".idx\", \".idx.sig\",\n                                                   index, index_sig, cancellable, error))\n        return FALSE;\n    }\n\n  /* Cache in memory */\n  if (!is_local && !only_cached)\n    {\n      g_autofree char *cache_key = g_strconcat (\"index-\", name_or_uri, NULL);\n      flatpak_dir_cache_summary (self, index, index_sig, cache_key, url);\n    }\n\n  *out_index = g_steal_pointer (&index);\n  if (out_index_sig)\n    *out_index_sig = g_steal_pointer (&index_sig);\n\n  return TRUE;\n}\n\nstatic gboolean\nflatpak_dir_remote_fetch_indexed_summary (FlatpakDir   *self,\n                                          const char   *name_or_uri,\n                                          const char   *arch,\n                                          GVariant     *subsummary_info_v,\n                                          gboolean      only_cached,\n                                          GBytes      **out_summary,\n                                          GCancellable *cancellable,\n                                          GError      **error)\n{\n  g_autofree char *url = NULL;\n  gboolean is_local;\n  g_autoptr(GError) cache_error = NULL;\n  g_autoptr(GBytes) summary_z = NULL;\n  g_autoptr(GBytes) summary = NULL;\n  g_autofree char *sha256 = NULL;\n  VarSubsummaryRef subsummary_info;\n  gsize checksum_bytes_len;\n  const guchar *checksum_bytes;\n  g_autofree char *checksum = NULL;\n  g_autofree char *cache_name = NULL;\n\n  ensure_soup_session (self);\n\n  if (!ostree_repo_remote_get_url (self->repo, name_or_uri, &url, error))\n    return FALSE;\n\n  if (!g_str_has_prefix (name_or_uri, \"file:\") && flatpak_dir_get_remote_disabled (self, name_or_uri))\n    {\n      g_set_error (error, G_IO_ERROR, G_IO_ERROR_INVALID_DATA,\n                   \"Can't fetch summary from disabled remote \u2018%s\u2019\", name_or_uri);\n      return FALSE;\n    }\n\n  subsummary_info = var_subsummary_from_gvariant (subsummary_info_v);\n  checksum_bytes = var_subsummary_peek_checksum (subsummary_info, &checksum_bytes_len);\n  g_assert (checksum_bytes_len == OSTREE_SHA256_DIGEST_LEN); /* We verified this when scanning index */\n  checksum = ostree_checksum_from_bytes (checksum_bytes);\n\n  is_local = g_str_has_prefix (url, \"file:\");\n\n  /* No in-memory caching for local files */\n  if (!is_local)\n    {\n      if (flatpak_dir_lookup_cached_summary (self, out_summary, NULL, checksum, url))\n        return TRUE;\n    }\n\n  cache_name = g_strconcat (name_or_uri, \"-\", arch, \"-\", checksum, NULL);\n\n  /* First look for an on-disk cache */\n  if (!flatpak_dir_remote_load_cached_summary (self, cache_name, \".sub\", NULL,\n                                               &summary, NULL, cancellable, &cache_error))\n    {\n      g_autofree char *old_checksum = NULL;\n      g_autoptr(GBytes) old_summary = NULL;\n\n      /* Else fetch it */\n      if (only_cached)\n        {\n          g_propagate_error (error, g_steal_pointer (&cache_error));\n          return FALSE;\n        }\n\n      /* Look for first applicable deltas */\n      VarArrayofChecksumRef history = var_subsummary_get_history (subsummary_info);\n      gsize history_len = var_arrayof_checksum_get_length (history);\n      for (gsize i = 0; i < history_len; i++)\n        {\n          VarChecksumRef old = var_arrayof_checksum_get_at (history, i);\n          g_autofree char *old_cache_name = NULL;\n\n          if (var_checksum_get_length (old) != OSTREE_SHA256_DIGEST_LEN)\n            continue;\n\n          old_checksum = ostree_checksum_from_bytes (var_checksum_peek (old));\n          old_cache_name = g_strconcat (name_or_uri, \"-\", arch, \"-\", old_checksum, NULL);\n          if (flatpak_dir_remote_load_cached_summary (self, old_cache_name, \".sub\", NULL,\n                                                      &old_summary, NULL, cancellable, NULL))\n            break;\n        }\n\n      if (old_summary)\n        {\n          g_autoptr(GError) delta_error = NULL;\n\n          g_autofree char *delta_filename = g_strconcat (old_checksum, \"-\", checksum, \".delta\", NULL);\n          g_autofree char *delta_url = g_build_filename (url, \"summaries\", delta_filename, NULL);\n\n          g_debug (\"Fetching indexed summary delta %s for remote \u2018%s\u2019\", delta_filename, name_or_uri);\n\n          g_autoptr(GBytes) delta = flatpak_load_uri (self->soup_session, delta_url, 0, NULL,\n                                                      NULL, NULL, NULL,\n                                                      cancellable, &delta_error);\n          if (delta == NULL)\n            g_debug (\"Failed to load delta, falling back: %s\", delta_error->message);\n          else\n            {\n              g_autoptr(GBytes) applied = flatpak_summary_apply_diff (old_summary, delta, &delta_error);\n\n              if (applied == NULL)\n                g_warning (\"Failed to apply delta, falling back: %s\", delta_error->message);\n              else\n                {\n                  sha256 = g_compute_checksum_for_bytes (G_CHECKSUM_SHA256, applied);\n                  if (strcmp (sha256, checksum) != 0)\n                    g_warning (\"Appliying delta gave wrong checksum, falling backn\");\n                  else\n                    summary = g_steal_pointer (&applied);\n                }\n            }\n        }\n\n      if (summary == NULL)\n        {\n          g_autofree char *filename = g_strconcat (checksum, \".gz\", NULL);\n          g_debug (\"Fetching indexed summary file %s for remote \u2018%s\u2019\", filename, name_or_uri);\n          g_autofree char *subsummary_url = g_build_filename (url, \"summaries\", filename, NULL);\n          summary_z = flatpak_load_uri (self->soup_session, subsummary_url, 0, NULL,\n                                        NULL, NULL, NULL,\n                                        cancellable, error);\n          if (summary_z == NULL)\n            return FALSE;\n\n          summary = flatpak_zlib_decompress_bytes (summary_z, error);\n          if (summary == NULL)\n            return FALSE;\n\n          sha256 = g_compute_checksum_for_bytes (G_CHECKSUM_SHA256, summary);\n          if (strcmp (sha256, checksum) != 0)\n            return flatpak_fail_error (error, FLATPAK_ERROR_INVALID_DATA, _(\"Invalid checksum for indexed summary %s for remote '%s'\"), checksum, name_or_uri);\n        }\n\n      /* Save to disk */\n      if (!is_local)\n        {\n          if (!flatpak_dir_remote_save_cached_summary (self, cache_name, \".sub\", NULL,\n                                                       summary, NULL,\n                                                       cancellable, error))\n            return FALSE;\n\n          if (!flatpak_dir_gc_cached_digested_summaries (self, name_or_uri, cache_name,\n                                                         cancellable, error))\n            return FALSE;\n        }\n    }\n  else\n    g_debug (\"Loaded indexed summary file %s from cache for remote \u2018%s\u2019\", checksum, name_or_uri);\n\n  /* Cache in memory */\n  if (!is_local && !only_cached)\n    flatpak_dir_cache_summary (self, summary, NULL, checksum, url);\n\n  *out_summary = g_steal_pointer (&summary);\n\n  return TRUE;\n}\n\nstatic FlatpakRemoteState *\n_flatpak_dir_get_remote_state (FlatpakDir   *self,\n                               const char   *remote_or_uri,\n                               gboolean      optional,\n                               gboolean      local_only,\n                               gboolean      only_cached,\n                               gboolean      opt_summary_is_index,\n                               GBytes       *opt_summary,\n                               GBytes       *opt_summary_sig,\n                               GCancellable *cancellable,\n                               GError      **error)\n{\n  g_autoptr(FlatpakRemoteState) state = flatpak_remote_state_new ();\n  g_autoptr(GPtrArray) sideload_paths = NULL;\n  g_autofree char *url = NULL;\n  g_autoptr(GError) my_error = NULL;\n  gboolean is_local;\n  gboolean got_summary = FALSE;\n  const char *arch = flatpak_get_default_arch ();\n  g_autoptr(GBytes) index_bytes = NULL;\n  g_autoptr(GBytes) index_sig_bytes = NULL;\n  g_autoptr(GBytes) summary_bytes = NULL;\n  g_autoptr(GBytes) summary_sig_bytes = NULL;\n\n  if (error == NULL)\n    error = &my_error;\n\n  if (!flatpak_dir_ensure_repo (self, cancellable, error))\n    return NULL;\n\n  state->remote_name = g_strdup (remote_or_uri);\n  state->is_file_uri = is_local = g_str_has_prefix (remote_or_uri, \"file:\");\n  if (!is_local)\n    {\n      if (!flatpak_dir_has_remote (self, remote_or_uri, error))\n        return NULL;\n      if (!repo_get_remote_collection_id (self->repo, remote_or_uri, &state->collection_id, error))\n        return NULL;\n      if (!flatpak_dir_lookup_remote_filter (self, remote_or_uri, FALSE, NULL, &state->allow_refs, &state->deny_refs, error))\n        return NULL;\n      if (!ostree_repo_remote_get_url (self->repo, remote_or_uri, &url, error))\n        return FALSE;\n\n      state->default_token_type = flatpak_dir_get_remote_default_token_type (self, remote_or_uri);\n    }\n\n  sideload_paths = flatpak_dir_get_sideload_repo_paths (self);\n  for (int i = 0; i < sideload_paths->len; i++)\n    flatpak_remote_state_add_sideload_repo (state, g_ptr_array_index (sideload_paths, i));\n\n  if (local_only)\n    {\n      flatpak_fail (&state->summary_fetch_error, \"Internal error, local_only state\");\n      return g_steal_pointer (&state);\n    }\n\n  if (opt_summary)\n    {\n      if (opt_summary_sig)\n        {\n          /* If specified, must be valid signature */\n          g_autoptr(OstreeGpgVerifyResult) gpg_result =\n            ostree_repo_verify_summary (self->repo,\n                                        state->remote_name,\n                                        opt_summary,\n                                        opt_summary_sig,\n                                        NULL, error);\n          if (gpg_result == NULL ||\n              !ostree_gpg_verify_result_require_valid_signature (gpg_result, error))\n            return NULL;\n        }\n\n      if (opt_summary_is_index)\n        {\n          if (opt_summary_sig)\n            index_sig_bytes = g_bytes_ref (opt_summary_sig);\n          index_bytes = g_bytes_ref (opt_summary);\n        }\n      else\n        {\n          if (opt_summary_sig)\n            summary_sig_bytes = g_bytes_ref (opt_summary_sig);\n          summary_bytes = g_bytes_ref (opt_summary);\n        }\n\n      got_summary = TRUE;\n    }\n\n  /* First try the memory cache. Note: No in-memory caching for local files. */\n  if (!is_local)\n    {\n      if (!got_summary)\n        {\n          g_autofree char *index_cache_key = g_strconcat (\"index-\", remote_or_uri, NULL);\n          if (flatpak_dir_lookup_cached_summary (self, &index_bytes, &index_sig_bytes, index_cache_key, url))\n            got_summary = TRUE;\n        }\n\n      if (!got_summary)\n        {\n          g_autofree char *summary_cache_key = g_strconcat (\"summary-\", remote_or_uri, NULL);\n          if (flatpak_dir_lookup_cached_summary (self, &summary_bytes, &summary_sig_bytes, summary_cache_key, url))\n            got_summary = TRUE;\n        }\n    }\n\n  /* Then look for an indexed summary on disk/network */\n  if (!got_summary)\n    {\n      g_autoptr(GError) local_error = NULL;\n\n      if (flatpak_dir_remote_fetch_summary_index (self, remote_or_uri, only_cached, &index_bytes, &index_sig_bytes,\n                                                  cancellable, &local_error))\n        {\n          got_summary = TRUE;\n        }\n      else\n        {\n          if (!g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND) &&\n              !g_error_matches (local_error, FLATPAK_ERROR, FLATPAK_ERROR_NOT_CACHED))\n            {\n              /* We got an error other than not-found, assume we're indexed but there is some network error */\n              got_summary = TRUE;\n              if (optional && !g_cancellable_is_cancelled (cancellable))\n                {\n                  g_debug (\"Failed to download optional summary index: %s\", local_error->message);\n                  state->summary_fetch_error = g_steal_pointer (&local_error);\n                }\n              else\n                {\n                  g_propagate_error (error, g_steal_pointer (&local_error));\n                  return NULL;\n                }\n            }\n        }\n    }\n\n  if (!got_summary)\n    {\n      /* No index, fall back to full summary */\n      g_autoptr(GError) local_error = NULL;\n\n      if (flatpak_dir_remote_fetch_summary (self, remote_or_uri, only_cached, &summary_bytes, &summary_sig_bytes,\n                                            cancellable, &local_error))\n        {\n          got_summary = TRUE;\n        }\n      else\n        {\n          if (optional && !g_cancellable_is_cancelled (cancellable))\n            {\n              g_debug (\"Failed to download optional summary: %s\", local_error->message);\n              state->summary_fetch_error = g_steal_pointer (&local_error);\n            }\n          else\n            {\n              g_propagate_error (error, g_steal_pointer (&local_error));\n              return NULL;\n            }\n        }\n    }\n\n  if (index_bytes)\n    {\n      state->index = g_variant_ref_sink (g_variant_new_from_bytes (FLATPAK_SUMMARY_INDEX_GVARIANT_FORMAT,\n                                                                   index_bytes, FALSE));\n      state->index_sig_bytes = g_steal_pointer (&index_sig_bytes);\n    }\n  else if (summary_bytes)\n    {\n      state->summary = g_variant_ref_sink (g_variant_new_from_bytes (OSTREE_SUMMARY_GVARIANT_FORMAT,\n                                                                     summary_bytes, FALSE));\n      state->summary_bytes = g_steal_pointer (&summary_bytes);\n      state->summary_sig_bytes = g_steal_pointer (&summary_sig_bytes);\n    }\n\n  if (state->index)\n    {\n      g_autofree char *require_subset = flatpak_dir_get_remote_subset (self, state->remote_name);\n      VarSummaryIndexRef index = var_summary_index_from_gvariant (state->index);\n      VarSummaryIndexSubsummariesRef subsummaries = var_summary_index_get_subsummaries (index);\n      gsize n_subsummaries = var_summary_index_subsummaries_get_length (subsummaries);\n\n      state->index_ht = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, (GDestroyNotify)g_variant_unref);\n\n      for (gsize i = 0; i < n_subsummaries; i++)\n        {\n          VarSummaryIndexSubsummariesEntryRef entry = var_summary_index_subsummaries_get_at (subsummaries, i);\n          const char *name = var_summary_index_subsummaries_entry_get_key (entry);\n          VarSubsummaryRef subsummary = var_summary_index_subsummaries_entry_get_value (entry);\n          gsize checksum_bytes_len;\n          const guchar *checksum_bytes;\n          g_autofree char *digest = NULL;\n          const char *dash, *subsummary_arch;\n\n          dash = strchr (name, '-');\n          subsummary_arch = dash == NULL ? name : dash + 1;\n\n          if (dash == NULL) /* No subset */\n            {\n              if (require_subset != NULL)\n                continue;\n            }\n          else /* Subset */\n            {\n              if (require_subset == NULL)\n                continue;\n              else\n                {\n                  g_autofree char *subset = g_strndup (name, dash - name);\n                  if (strcmp (require_subset, subset) != 0)\n                    continue;\n                }\n            }\n\n          checksum_bytes = var_subsummary_peek_checksum (subsummary, &checksum_bytes_len);\n          if (G_UNLIKELY (checksum_bytes_len != OSTREE_SHA256_DIGEST_LEN))\n            {\n              g_debug (\"Invalid checksum for digested summary, not using cache\");\n              continue;\n            }\n          digest = ostree_checksum_from_bytes (checksum_bytes);\n\n          g_hash_table_insert (state->index_ht, g_strdup (subsummary_arch), var_subsummary_to_owned_gvariant (subsummary, state->index));\n        }\n\n      /* Always load default (or specified) arch subsummary. Further arches can be manually loaded with flatpak_remote_state_ensure_subsummary. */\n      if (opt_summary == NULL &&\n          !flatpak_remote_state_ensure_subsummary (state, self, arch, only_cached, cancellable, error))\n        return NULL;\n    }\n\n  if (state->collection_id != NULL &&\n      state->summary != NULL &&\n      !_validate_summary_for_collection_id (state->summary, state->collection_id, error))\n    return NULL;\n\n  if (flatpak_dir_get_remote_oci (self, remote_or_uri))\n    {\n      state->default_token_type = 1;\n    }\n\n  if (state->summary != NULL || state->index != NULL) /* In the optional case we might not have a summary */\n    {\n      VarMetadataRef meta = flatpak_remote_state_get_main_metadata (state);\n      VarVariantRef res;\n\n      if (var_metadata_lookup (meta, \"xa.default-token-type\", NULL, &res) &&\n          var_variant_is_type (res, G_VARIANT_TYPE_INT32))\n        state->default_token_type = GINT32_FROM_LE (var_variant_get_int32 (res));\n    }\n\n  return g_steal_pointer (&state);\n}\n\nFlatpakRemoteState *\nflatpak_dir_get_remote_state (FlatpakDir   *self,\n                              const char   *remote,\n                              gboolean      only_cached,\n                              GCancellable *cancellable,\n                              GError      **error)\n{\n  return _flatpak_dir_get_remote_state (self, remote, FALSE, FALSE, only_cached, FALSE, NULL, NULL, cancellable, error);\n}\n\n/* This is an alternative way to get the state where the summary is\n * from elsewhere. It is mainly used by the system-helper where the\n * summary is from the user-mode part which downloaded an update\n *\n * It will verify the summary if a signature is passed in, but not\n * otherwise.\n **/\nFlatpakRemoteState *\nflatpak_dir_get_remote_state_for_summary (FlatpakDir   *self,\n                                          const char   *remote,\n                                          GBytes       *opt_summary,\n                                          GBytes       *opt_summary_sig,\n                                          GCancellable *cancellable,\n                                          GError      **error)\n{\n  return _flatpak_dir_get_remote_state (self, remote, FALSE, FALSE, FALSE, FALSE, opt_summary, opt_summary_sig, cancellable, error);\n}\n\nFlatpakRemoteState *\nflatpak_dir_get_remote_state_for_index (FlatpakDir   *self,\n                                        const char   *remote,\n                                        GBytes       *opt_index,\n                                        GBytes       *opt_index_sig,\n                                        GCancellable *cancellable,\n                                        GError      **error)\n{\n  return _flatpak_dir_get_remote_state (self, remote, FALSE, FALSE, FALSE, TRUE, opt_index, opt_index_sig, cancellable, error);\n}\n\n/* This is an alternative way to get the remote state that doesn't\n * error out if the summary or metadata is not available.\n * For example, we want to be able to update an app even when\n * we can't talk to the main repo, but there is a local (p2p/sdcard)\n * source for apps, and we want to be able to deploy a ref without pulling it,\n * e.g. because we are installing with FLATPAK_INSTALL_FLAGS_NO_PULL, and we\n * already pulled it out of band beforehand.\n */\nFlatpakRemoteState *\nflatpak_dir_get_remote_state_optional (FlatpakDir   *self,\n                                       const char   *remote,\n                                       gboolean      only_cached,\n                                       GCancellable *cancellable,\n                                       GError      **error)\n{\n  return _flatpak_dir_get_remote_state (self, remote, TRUE, FALSE, only_cached, FALSE, NULL, NULL, cancellable, error);\n}\n\n\n/* This doesn't do any i/o at all, just keeps track of the local details like\n   remote and collection-id. Useful when doing no-pull operations */\nFlatpakRemoteState *\nflatpak_dir_get_remote_state_local_only (FlatpakDir   *self,\n                                         const char   *remote,\n                                         GCancellable *cancellable,\n                                         GError      **error)\n{\n  return _flatpak_dir_get_remote_state (self, remote, TRUE, TRUE, FALSE, FALSE, NULL, NULL, cancellable, error);\n}\n\nstatic void\npopulate_hash_table_from_refs_map (GHashTable         *ret_all_refs,\n                                   GHashTable         *ref_timestamps,\n                                   VarRefMapRef        ref_map,\n                                   const char         *opt_collection_id,\n                                   FlatpakRemoteState *state)\n{\n  gsize len, i;\n\n  len = var_ref_map_get_length (ref_map);\n  for (i = 0; i < len; i++)\n    {\n      VarRefMapEntryRef entry = var_ref_map_get_at (ref_map, i);\n      const char *ref_name = var_ref_map_entry_get_ref (entry);\n      const guint8 *csum_bytes;\n      gsize csum_len;\n      VarRefInfoRef info;\n      guint64 *new_timestamp = NULL;\n      g_autoptr(FlatpakDecomposed) decomposed = NULL;\n\n      if (!flatpak_remote_state_allow_ref (state, ref_name))\n        continue;\n\n      info = var_ref_map_entry_get_info (entry);\n\n      csum_bytes = var_ref_info_peek_checksum (info, &csum_len);\n      if (csum_len != OSTREE_SHA256_DIGEST_LEN)\n        continue;\n\n      decomposed = flatpak_decomposed_new_from_col_ref (ref_name, opt_collection_id, NULL);\n      if (decomposed == NULL)\n        continue;\n\n      if (ref_timestamps)\n        {\n          guint64 timestamp = get_timestamp_from_ref_info (info);\n          gpointer value;\n\n          if (g_hash_table_lookup_extended (ref_timestamps, ref_name, NULL, &value))\n            {\n              guint64 *old_timestamp = value;\n              if (*old_timestamp >= timestamp)\n                continue; /* New timestamp is older, skip this commit */\n            }\n\n          new_timestamp = g_memdup (&timestamp, sizeof (guint64));\n        }\n\n      g_hash_table_replace (ret_all_refs, g_steal_pointer (&decomposed), ostree_checksum_from_bytes (csum_bytes));\n      if (new_timestamp)\n        g_hash_table_replace (ref_timestamps, g_strdup (ref_name), new_timestamp);\n    }\n}\n\n\n/* This tries to list all available remote refs but also tries to keep\n * working when offline, so it looks in sideloaded repos. Also it uses\n * in-memory cached summaries which ostree doesn't. */\ngboolean\nflatpak_dir_list_all_remote_refs (FlatpakDir         *self,\n                                  FlatpakRemoteState *state,\n                                  GHashTable        **out_all_refs,\n                                  GCancellable       *cancellable,\n                                  GError            **error)\n{\n  g_autoptr(GHashTable) ret_all_refs = NULL;\n  VarSummaryRef summary;\n  VarMetadataRef exts;\n  VarRefMapRef ref_map;\n  VarVariantRef v;\n\n  /* This is  ref->commit */\n  ret_all_refs = g_hash_table_new_full ((GHashFunc)flatpak_decomposed_hash, (GEqualFunc)flatpak_decomposed_equal, (GDestroyNotify)flatpak_decomposed_unref, g_free);\n\n  if (state->index != NULL)\n    {\n      /* We're online, so report only the refs from the summary */\n      GLNX_HASH_TABLE_FOREACH_KV (state->subsummaries, const char *, arch, GVariant *, subsummary)\n        {\n          summary = var_summary_from_gvariant (subsummary);\n          ref_map = var_summary_get_ref_map (summary);\n          populate_hash_table_from_refs_map (ret_all_refs, NULL, ref_map, NULL, state);\n        }\n    }\n  else if (state->summary != NULL)\n    {\n      /* We're online, so report only the refs from the summary */\n      const char *main_collection_id = NULL;\n\n      summary = var_summary_from_gvariant (state->summary);\n\n      exts = var_summary_get_metadata (summary);\n\n      if (state->is_file_uri)\n        {\n          /* This is a local repo, generally this means we gave a file: uri to a sideload repo so\n           * we can enumerate it. We special case this by also adding all the collection_ref maps,\n           * with collection_id set on the decomposed refs and setting the right collection id for\n           * the main ref_map.\n           */\n          main_collection_id = var_metadata_lookup_string (exts, \"ostree.summary.collection-id\", NULL);\n          if (var_metadata_lookup (exts, \"ostree.summary.collection-map\", NULL, &v))\n            {\n              VarCollectionMapRef map = var_collection_map_from_variant (v);\n\n              gsize len = var_collection_map_get_length (map);\n              for (gsize i = 0; i < len; i++)\n                {\n                  VarCollectionMapEntryRef entry = var_collection_map_get_at (map, i);\n                  const char *collection_id = var_collection_map_entry_get_key (entry);\n                  ref_map = var_collection_map_entry_get_value (entry);\n\n                  populate_hash_table_from_refs_map (ret_all_refs, NULL, ref_map, collection_id, state);\n                }\n            }\n        }\n\n      /* refs that match the main collection-id,\n         NOTE: We only set collection id if this is a file: uri remote */\n      ref_map = var_summary_get_ref_map (summary);\n      populate_hash_table_from_refs_map (ret_all_refs, NULL, ref_map, main_collection_id, state);\n    }\n  else if (state->collection_id)\n    {\n      g_autoptr(GHashTable) ref_mtimes = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, g_free);\n\n      /* No main summary, add just all sideloded refs, with the latest version of each checksum */\n\n      for (int i = 0; i < state->sideload_repos->len; i++)\n        {\n          FlatpakSideloadState *ss = g_ptr_array_index (state->sideload_repos, i);\n\n          summary = var_summary_from_gvariant (ss->summary);\n          exts = var_summary_get_metadata (summary);\n\n          if (var_metadata_lookup (exts, \"ostree.summary.collection-map\", NULL, &v))\n            {\n              VarCollectionMapRef map = var_collection_map_from_variant (v);\n\n              if (var_collection_map_lookup (map, state->collection_id, NULL, &ref_map))\n                populate_hash_table_from_refs_map (ret_all_refs, ref_mtimes, ref_map, NULL, state);\n            }\n        }\n    }\n\n  /* If no sideloaded refs, might as well return the summary error if set */\n  if (g_hash_table_size (ret_all_refs) == 0 &&\n      !flatpak_remote_state_ensure_summary (state, error))\n    return FALSE;\n\n  *out_all_refs = g_steal_pointer (&ret_all_refs);\n\n  return TRUE;\n}\n\nstatic GPtrArray *\nfind_matching_refs (GHashTable           *refs,\n                    const char           *opt_name,\n                    const char           *opt_branch,\n                    const char           *opt_default_branch,\n                    const char           *opt_arch,\n                    const char           *opt_default_arch,\n                    FlatpakKinds          kinds,\n                    FindMatchingRefsFlags flags,\n                    GError              **error)\n{\n  g_autoptr(GPtrArray) matched_refs = NULL;\n  const char **arches = flatpak_get_arches ();\n  const char *opt_arches[] = {opt_arch, NULL};\n  g_autoptr(GError) local_error = NULL;\n  gboolean found_exact_name_match = FALSE;\n  gboolean found_default_branch_match = FALSE;\n  gboolean found_default_arch_match = FALSE;\n\n  if (opt_arch != NULL)\n    arches = opt_arches;\n\n  if (opt_name && !(flags & FIND_MATCHING_REFS_FLAGS_FUZZY) &&\n      !flatpak_is_valid_name (opt_name, -1, &local_error))\n    {\n      flatpak_fail_error (error, FLATPAK_ERROR_INVALID_REF, _(\"'%s' is not a valid name: %s\"), opt_name, local_error->message);\n      return NULL;\n    }\n\n  if (opt_branch && !flatpak_is_valid_branch (opt_branch, -1, &local_error))\n    {\n      flatpak_fail_error (error, FLATPAK_ERROR_INVALID_REF, _(\"'%s' is not a valid branch name: %s\"), opt_branch, local_error->message);\n      return NULL;\n    }\n\n  matched_refs = g_ptr_array_new_with_free_func ((GDestroyNotify)flatpak_decomposed_unref);\n\n  GLNX_HASH_TABLE_FOREACH (refs, FlatpakDecomposed *, ref)\n    {\n      if ((flatpak_decomposed_get_kinds (ref) & kinds) == 0)\n        continue;\n\n      if (opt_name)\n        {\n          if ((flags & FIND_MATCHING_REFS_FLAGS_FUZZY) && !flatpak_decomposed_id_is_subref (ref))\n            {\n              if (!flatpak_decomposed_is_id_fuzzy (ref, opt_name))\n                continue;\n            }\n          else\n            {\n              if (!flatpak_decomposed_is_id (ref, opt_name))\n                continue;\n           }\n        }\n\n      if (!flatpak_decomposed_is_arches (ref, -1, arches))\n        continue;\n\n      if (opt_branch != NULL && !flatpak_decomposed_is_branch (ref, opt_branch))\n        continue;\n\n      if (opt_name != NULL && flatpak_decomposed_is_id (ref, opt_name))\n        found_exact_name_match = TRUE;\n\n      if (opt_default_arch != NULL && flatpak_decomposed_is_arch (ref, opt_default_arch))\n        found_default_arch_match = TRUE;\n\n      if (opt_default_branch != NULL && flatpak_decomposed_is_branch (ref, opt_default_branch))\n        found_default_branch_match = TRUE;\n\n      g_ptr_array_add (matched_refs, flatpak_decomposed_ref (ref));\n    }\n\n  /* Don't show fuzzy matches if we found at least one exact name match, and\n   * enforce the default arch/branch */\n  if (found_exact_name_match || found_default_arch_match || found_default_branch_match)\n    {\n      guint i;\n\n      /* Walk through the array backwards so we can safely remove */\n      for (i = matched_refs->len; i > 0; i--)\n        {\n          FlatpakDecomposed *matched_ref = g_ptr_array_index (matched_refs, i - 1);\n\n          if (found_exact_name_match && !flatpak_decomposed_is_id (matched_ref, opt_name))\n            g_ptr_array_remove_index (matched_refs, i - 1);\n          else if (found_default_arch_match && !flatpak_decomposed_is_arch (matched_ref, opt_default_arch))\n            g_ptr_array_remove_index (matched_refs, i - 1);\n          else if (found_default_branch_match && !flatpak_decomposed_is_branch (matched_ref, opt_default_branch))\n            g_ptr_array_remove_index (matched_refs, i - 1);\n        }\n    }\n\n  return g_steal_pointer (&matched_refs);\n}\n\nstatic FlatpakDecomposed *\nfind_matching_ref (GHashTable  *refs,\n                   const char  *name,\n                   const char  *opt_branch,\n                   const char  *opt_default_branch,\n                   const char  *opt_arch,\n                   FlatpakKinds kinds,\n                   GError     **error)\n{\n  const char **arches = flatpak_get_arches ();\n  const char *opt_arches[] = {opt_arch, NULL};\n  int i;\n\n  if (opt_arch != NULL)\n    arches = opt_arches;\n\n  /* We stop at the first arch (in prio order) that has a match */\n  for (i = 0; arches[i] != NULL; i++)\n    {\n      g_autoptr(GPtrArray) matched_refs = NULL;\n      int j;\n\n      matched_refs = find_matching_refs (refs,\n                                         name,\n                                         opt_branch,\n                                         opt_default_branch,\n                                         arches[i],\n                                         NULL,\n                                         kinds,\n                                         FIND_MATCHING_REFS_FLAGS_NONE,\n                                         error);\n      if (matched_refs == NULL)\n        return NULL;\n\n      if (matched_refs->len == 0)\n        continue;\n\n      if (matched_refs->len == 1)\n        return flatpak_decomposed_ref (g_ptr_array_index (matched_refs, 0));\n\n      /* Nothing to do other than reporting the different choices */\n      g_autoptr(GString) err = g_string_new (\"\");\n      g_string_printf (err, _(\"Multiple branches available for %s, you must specify one of: \"), name);\n      g_ptr_array_sort (matched_refs, flatpak_strcmp0_ptr);\n      for (j = 0; j < matched_refs->len; j++)\n        {\n          FlatpakDecomposed *ref = g_ptr_array_index (matched_refs, j);\n          if (j != 0)\n            g_string_append (err, \", \");\n\n          const char *branch = flatpak_decomposed_get_branch (ref);\n\n          g_string_append (err,\n                           g_strdup_printf (\"%s/%s/%s\",\n                                            name,\n                                            opt_arch ? opt_arch : \"\",\n                                            branch));\n        }\n\n      flatpak_fail (error, \"%s\", err->str);\n      return NULL;\n    }\n\n  g_set_error (error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND,\n               _(\"Nothing matches %s\"), name);\n  return NULL;\n}\n\nchar *\nflatpak_dir_get_remote_collection_id (FlatpakDir *self,\n                                      const char *remote_name)\n{\n  char *collection_id = NULL;\n\n  if (!flatpak_dir_ensure_repo (self, NULL, NULL))\n    return NULL;\n\n  repo_get_remote_collection_id (self->repo, remote_name, &collection_id, NULL);\n\n  return collection_id;\n}\n\nGPtrArray *\nflatpak_dir_find_remote_refs (FlatpakDir           *self,\n                              FlatpakRemoteState   *state,\n                              const char           *name,\n                              const char           *opt_branch,\n                              const char           *opt_default_branch,\n                              const char           *opt_arch,\n                              const char           *opt_default_arch,\n                              FlatpakKinds          kinds,\n                              FindMatchingRefsFlags flags,\n                              GCancellable         *cancellable,\n                              GError              **error)\n{\n  g_autoptr(GHashTable) remote_refs = NULL;\n  g_autoptr(GPtrArray) matched_refs = NULL;\n\n  if (!flatpak_dir_list_all_remote_refs (self, state,\n                                         &remote_refs, cancellable, error))\n    return NULL;\n\n\n  matched_refs = find_matching_refs (remote_refs,\n                                     name,\n                                     opt_branch,\n                                     opt_default_branch,\n                                     opt_arch,\n                                     opt_default_arch,\n                                     kinds,\n                                     flags,\n                                     error);\n  if (matched_refs == NULL)\n    return NULL;\n\n  /* If we can't match anything and we had an error downloading (offline?), report that as its more helpful */\n  if (matched_refs->len == 0 && state->summary_fetch_error)\n    {\n      g_propagate_error (error, g_error_copy (state->summary_fetch_error));\n      return NULL;\n    }\n\n  return g_steal_pointer (&matched_refs);\n}\n\nstatic FlatpakDecomposed *\nfind_ref_for_refs_set (GHashTable   *refs,\n                       const char   *name,\n                       const char   *opt_branch,\n                       const char   *opt_default_branch,\n                       const char   *opt_arch,\n                       FlatpakKinds  kinds,\n                       GError      **error)\n{\n  g_autoptr(GError) my_error = NULL;\n  g_autoptr(FlatpakDecomposed) ref = find_matching_ref (refs,\n                                                        name,\n                                                        opt_branch,\n                                                        opt_default_branch,\n                                                        opt_arch,\n                                                        kinds,\n                                                        &my_error);\n  if (ref == NULL)\n    {\n      if (g_error_matches (my_error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND))\n        g_clear_error (&my_error);\n      else\n        {\n          g_propagate_error (error, g_steal_pointer (&my_error));\n          return NULL;\n        }\n    }\n  else\n    {\n      return g_steal_pointer (&ref);\n    }\n\n  g_set_error (error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND,\n               _(\"Can't find ref %s%s%s%s%s\"), name,\n               (opt_arch != NULL || opt_branch != NULL) ? \"/\" : \"\",\n               opt_arch ? opt_arch : \"\",\n               opt_branch ? \"/\" : \"\",\n               opt_branch ? opt_branch : \"\");\n\n  return NULL;\n}\n\nFlatpakDecomposed *\nflatpak_dir_find_remote_ref (FlatpakDir   *self,\n                             FlatpakRemoteState *state,\n                             const char   *name,\n                             const char   *opt_branch,\n                             const char   *opt_default_branch,\n                             const char   *opt_arch,\n                             FlatpakKinds  kinds,\n                             GCancellable *cancellable,\n                             GError      **error)\n{\n  g_autoptr(FlatpakDecomposed) remote_ref = NULL;\n  g_autoptr(GHashTable) remote_refs = NULL;\n  g_autoptr(GError) my_error = NULL;\n\n  /* Avoid work if the entire ref was specified */\n  if (opt_branch != NULL && opt_arch != NULL && (kinds == FLATPAK_KINDS_APP || kinds == FLATPAK_KINDS_RUNTIME))\n    return flatpak_decomposed_new_from_parts (kinds, name, opt_arch, opt_branch, error);\n\n  if (!flatpak_dir_list_all_remote_refs (self, state,\n                                         &remote_refs, cancellable, error))\n    return NULL;\n\n  remote_ref = find_ref_for_refs_set (remote_refs, name, opt_branch,\n                                      opt_default_branch, opt_arch,\n                                      kinds,  &my_error);\n  if (!remote_ref)\n    {\n      if (g_error_matches (my_error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND))\n        {\n          g_set_error (error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND,\n                       _(\"Error searching remote %s: %s\"),\n                       state->remote_name,\n                       my_error->message);\n          return NULL;\n        }\n      else\n        {\n          g_propagate_error (error, g_steal_pointer (&my_error));\n          return NULL;\n        }\n    }\n\n  return g_steal_pointer (&remote_ref);\n}\n\nstatic GHashTable *\nrefspecs_decompose_steal (GHashTable *refspecs)\n{\n  g_autoptr(GHashTable) refs = NULL;\n  GHashTableIter iter;\n  gpointer key, value;\n\n  refs = g_hash_table_new_full ((GHashFunc)flatpak_decomposed_hash, (GEqualFunc)flatpak_decomposed_equal,\n                                (GDestroyNotify)flatpak_decomposed_unref, g_free);\n\n  g_hash_table_iter_init (&iter, refspecs);\n  while (g_hash_table_iter_next (&iter, &key, &value))\n    {\n      char *checksum = value;\n      char *refspec = key;\n      FlatpakDecomposed *decomposed;\n\n      g_hash_table_iter_steal (&iter);\n\n      decomposed = flatpak_decomposed_new_from_refspec_take (refspec, NULL);\n      if (decomposed)\n        {\n          g_hash_table_insert (refs, decomposed, checksum);\n        }\n      else\n        {\n          g_free (checksum);\n          g_free (refspec);\n        }\n    }\n\n  return g_steal_pointer (&refs);\n}\n\nGPtrArray *\nflatpak_dir_find_local_refs (FlatpakDir           *self,\n                             const char           *remote,\n                             const char           *name,\n                             const char           *opt_branch,\n                             const char           *opt_default_branch,\n                             const char           *opt_arch,\n                             const char           *opt_default_arch,\n                             FlatpakKinds          kinds,\n                             FindMatchingRefsFlags flags,\n                             GCancellable         *cancellable,\n                             GError              **error)\n{\n  g_autoptr(GHashTable) local_refs = NULL;\n  g_autoptr(GHashTable) local_refspecs = NULL;\n  g_autoptr(GError) my_error = NULL;\n  g_autofree char *refspec_prefix = g_strconcat (remote, \":.\", NULL);\n  g_autoptr(GPtrArray) matched_refs = NULL;\n\n  if (!flatpak_dir_ensure_repo (self, NULL, error))\n    return NULL;\n\n  if (!ostree_repo_list_refs (self->repo,\n                              refspec_prefix,\n                              &local_refspecs, cancellable, error))\n    return NULL;\n\n  local_refs = refspecs_decompose_steal (local_refspecs);\n\n  matched_refs = find_matching_refs (local_refs,\n                                     name,\n                                     opt_branch,\n                                     opt_default_branch,\n                                     opt_arch,\n                                     opt_default_arch,\n                                     kinds,\n                                     flags,\n                                     &my_error);\n  if (matched_refs == NULL)\n    {\n      if (g_error_matches (my_error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND))\n        {\n          g_set_error (error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND,\n                       _(\"Error searching local repository: %s\"),\n                       my_error->message);\n          return NULL;\n        }\n      else\n        {\n          g_propagate_error (error, g_steal_pointer (&my_error));\n          return NULL;\n        }\n    }\n\n  return g_steal_pointer (&matched_refs);\n}\n\nstatic GHashTable *\nflatpak_dir_get_all_installed_refs (FlatpakDir  *self,\n                                    FlatpakKinds kinds,\n                                    GError     **error)\n{\n  g_autoptr(GHashTable) local_refs = NULL;\n\n  if (!flatpak_dir_maybe_ensure_repo (self, NULL, error))\n    return NULL;\n\n  local_refs = g_hash_table_new_full ((GHashFunc)flatpak_decomposed_hash, (GEqualFunc)flatpak_decomposed_equal, (GDestroyNotify)flatpak_decomposed_unref, NULL);\n  if (kinds & FLATPAK_KINDS_APP)\n    {\n      g_autoptr(GPtrArray) app_refs = flatpak_dir_list_refs (self, FLATPAK_KINDS_APP, NULL, error);\n      if (app_refs == NULL)\n        return NULL;\n\n      for (int i = 0; i < app_refs->len; i++)\n        {\n          FlatpakDecomposed *app_ref = g_ptr_array_index (app_refs, i);\n          g_hash_table_add (local_refs, flatpak_decomposed_ref (app_ref));\n        }\n    }\n  if (kinds & FLATPAK_KINDS_RUNTIME)\n    {\n      g_autoptr(GPtrArray) runtime_refs = flatpak_dir_list_refs (self, FLATPAK_KINDS_RUNTIME, NULL, error);\n      if (runtime_refs == NULL)\n        return NULL;\n\n      for (int i = 0; i < runtime_refs->len; i++)\n        {\n          FlatpakDecomposed *runtime_ref = g_ptr_array_index (runtime_refs, i);\n          g_hash_table_add (local_refs, flatpak_decomposed_ref (runtime_ref));\n        }\n    }\n\n  return g_steal_pointer (&local_refs);\n}\n\nGPtrArray *\nflatpak_dir_find_installed_refs (FlatpakDir           *self,\n                                 const char           *opt_name,\n                                 const char           *opt_branch,\n                                 const char           *opt_arch,\n                                 FlatpakKinds          kinds,\n                                 FindMatchingRefsFlags flags,\n                                 GError              **error)\n{\n  g_autoptr(GHashTable) local_refs = NULL;\n  g_autoptr(GPtrArray) matched_refs = NULL;\n\n  local_refs = flatpak_dir_get_all_installed_refs (self, kinds, error);\n  if (local_refs == NULL)\n    return NULL;\n\n  matched_refs = find_matching_refs (local_refs,\n                                     opt_name,\n                                     opt_branch,\n                                     NULL, /* default branch */\n                                     opt_arch,\n                                     NULL, /* default arch */\n                                     kinds,\n                                     flags,\n                                     error);\n  if (matched_refs == NULL)\n    return NULL;\n\n  return g_steal_pointer (&matched_refs);\n}\n\nFlatpakDecomposed *\nflatpak_dir_find_installed_ref (FlatpakDir   *self,\n                                const char   *opt_name,\n                                const char   *opt_branch,\n                                const char   *opt_arch,\n                                FlatpakKinds  kinds,\n                                GError      **error)\n{\n  g_autoptr(FlatpakDecomposed) local_ref = NULL;\n  g_autoptr(GHashTable) local_refs = NULL;\n  g_autoptr(GError) my_error = NULL;\n\n  local_refs = flatpak_dir_get_all_installed_refs (self, kinds, error);\n  if (local_refs == NULL)\n    return NULL;\n\n  local_ref = find_matching_ref (local_refs, opt_name, opt_branch, NULL,\n                                 opt_arch, kinds, &my_error);\n  if (local_ref == NULL)\n    {\n      if (g_error_matches (my_error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND))\n        g_clear_error (&my_error);\n      else\n        {\n          g_propagate_error (error, g_steal_pointer (&my_error));\n          return NULL;\n        }\n    }\n  else\n    {\n      return g_steal_pointer (&local_ref);\n    }\n\n  g_set_error (error, FLATPAK_ERROR, FLATPAK_ERROR_NOT_INSTALLED,\n               _(\"%s/%s/%s not installed\"),\n               opt_name ? opt_name : \"*unspecified*\",\n               opt_arch ? opt_arch : \"*unspecified*\",\n               opt_branch ? opt_branch : \"*unspecified*\");\n  return NULL;\n}\n\n/* Given a list of decomposed refs in local_refspecs, remove any refs that have already\n * been deployed and return a new GPtrArray containing only the undeployed\n * refs. This is used by flatpak_dir_cleanup_undeployed_refs to determine\n * which undeployed refs need to be removed from the local repository.\n *\n * Returns: (transfer-full): A #GPtrArray\n */\nstatic GPtrArray *\nfilter_out_deployed_refs (FlatpakDir *self,\n                          GPtrArray  *local_refspecs,\n                          GError    **error)\n{\n  g_autoptr(GPtrArray) undeployed_refs = g_ptr_array_new_full (local_refspecs->len, (GDestroyNotify)flatpak_decomposed_unref);\n  gsize i;\n\n  for (i = 0; i < local_refspecs->len; ++i)\n    {\n      FlatpakDecomposed *ref = g_ptr_array_index (local_refspecs, i);\n      g_autoptr(GBytes) deploy_data = NULL;\n\n      deploy_data = flatpak_dir_get_deploy_data (self, ref, FLATPAK_DEPLOY_VERSION_ANY, NULL, NULL);\n\n      if (!deploy_data)\n        g_ptr_array_add (undeployed_refs, flatpak_decomposed_ref (ref));\n    }\n\n  return g_steal_pointer (&undeployed_refs);\n}\n\n/**\n * flatpak_dir_cleanup_undeployed_refs:\n * @self: a #FlatpakDir\n * @cancellable: (nullable) (optional): a #GCancellable\n * @error: a #GError\n *\n * Find all flatpak refs in the local repository which have not been deployed\n * in the dir and remove them from the repository. You might want to call this\n * function if you pulled refs into the dir but then decided that you did\n * not want to deploy them for some reason. Note that this does not prune\n * objects bound to the cleaned up refs from the underlying OSTree repository,\n * you should consider using flatpak_dir_prune() to do that.\n *\n * Since: 0.10.0\n * Returns: %TRUE if cleaning up the refs succeeded, %FALSE otherwise\n */\ngboolean\nflatpak_dir_cleanup_undeployed_refs (FlatpakDir   *self,\n                                     GCancellable *cancellable,\n                                     GError      **error)\n{\n  g_autoptr(GHashTable) local_refspecs = NULL;\n  g_autoptr(GHashTable) local_refs = NULL;\n  g_autoptr(GPtrArray)  local_flatpak_refspecs = NULL;\n  g_autoptr(GPtrArray) undeployed_refs = NULL;\n  gsize i = 0;\n\n  if (!ostree_repo_list_refs (self->repo, NULL, &local_refspecs, cancellable, error))\n    return FALSE;\n\n  local_refs = refspecs_decompose_steal (local_refspecs);\n\n  local_flatpak_refspecs = find_matching_refs (local_refs,\n                                               NULL, NULL, NULL, NULL, NULL,\n                                               FLATPAK_KINDS_APP |\n                                               FLATPAK_KINDS_RUNTIME,\n                                               0, error);\n\n  if (!local_flatpak_refspecs)\n    return FALSE;\n\n  undeployed_refs = filter_out_deployed_refs (self, local_flatpak_refspecs, error);\n\n  if (!undeployed_refs)\n    return FALSE;\n\n  for (; i < undeployed_refs->len; ++i)\n    {\n      FlatpakDecomposed *ref = g_ptr_array_index (undeployed_refs, i);\n      g_autofree gchar *remote = flatpak_decomposed_dup_remote (ref);\n\n      if (!flatpak_dir_remove_ref (self, remote, flatpak_decomposed_get_ref (ref), cancellable, error))\n        return FALSE;\n    }\n\n  return TRUE;\n}\n\nstatic FlatpakDir *\nflatpak_dir_new_full (GFile *path, gboolean user, DirExtraData *extra_data)\n{\n  FlatpakDir *dir = g_object_new (FLATPAK_TYPE_DIR, \"path\", path, \"user\", user, NULL);\n\n  if (extra_data != NULL)\n    dir->extra_data = dir_extra_data_clone (extra_data);\n\n  return dir;\n}\n\nFlatpakDir *\nflatpak_dir_new (GFile *path, gboolean user)\n{\n  /* We are only interested on extra data for system-wide installations, in which\n     case we use _new_full() directly, so here we just call it passing NULL */\n  return flatpak_dir_new_full (path, user, NULL);\n}\n\nFlatpakDir *\nflatpak_dir_clone (FlatpakDir *self)\n{\n  FlatpakDir *clone;\n\n  clone = flatpak_dir_new_full (self->basedir, self->user, self->extra_data);\n\n  flatpak_dir_set_no_system_helper (clone, self->no_system_helper);\n  flatpak_dir_set_no_interaction (clone, self->no_interaction);\n\n  return clone;\n}\n\nFlatpakDir *\nflatpak_dir_get_system_default (void)\n{\n  g_autoptr(GFile) path = flatpak_get_system_default_base_dir_location ();\n  g_autoptr(DirExtraData) extra_data = dir_extra_data_new (SYSTEM_DIR_DEFAULT_ID,\n                                                           SYSTEM_DIR_DEFAULT_DISPLAY_NAME,\n                                                           SYSTEM_DIR_DEFAULT_PRIORITY,\n                                                           SYSTEM_DIR_DEFAULT_STORAGE_TYPE);\n  return flatpak_dir_new_full (path, FALSE, extra_data);\n}\n\n/* This figures out if it is a user or system dir automatically */\nFlatpakDir *\nflatpak_dir_get_by_path (GFile *path)\n{\n  GPtrArray *locations = flatpak_get_system_base_dir_locations (NULL, NULL);\n  int i;\n\n  if (locations)\n    {\n      for (i = 0; i < locations->len; i++)\n        {\n          GFile *system_path = g_ptr_array_index (locations, i);\n\n          if (g_file_equal (system_path, path))\n            {\n              DirExtraData *extra_data = g_object_get_data (G_OBJECT (path), \"extra-data\");\n              return flatpak_dir_new_full (path, FALSE, extra_data);\n            }\n        }\n    }\n\n  /* If its not configured as a system installation it will not have\n     an installation id and we can't use the system helper, so assume\n     user (and fail later with permission issues if its not owned by\n     the caller) */\n\n  return flatpak_dir_new (path, TRUE);\n}\n\nFlatpakDir *\nflatpak_dir_get_system_by_id (const char   *id,\n                              GCancellable *cancellable,\n                              GError      **error)\n{\n  g_autoptr(GError) local_error = NULL;\n  GPtrArray *locations = NULL;\n  FlatpakDir *ret = NULL;\n  int i;\n\n  if (id == NULL || g_strcmp0 (id, SYSTEM_DIR_DEFAULT_ID) == 0)\n    return flatpak_dir_get_system_default ();\n\n  /* An error in flatpak_get_system_base_dir_locations() will still return\n   * return an empty array with the GError set, but we want to return NULL.\n   */\n  locations = flatpak_get_system_base_dir_locations (cancellable, &local_error);\n  if (local_error != NULL)\n    {\n      g_propagate_error (error, g_steal_pointer (&local_error));\n      return NULL;\n    }\n\n  for (i = 0; i < locations->len; i++)\n    {\n      GFile *path = g_ptr_array_index (locations, i);\n      DirExtraData *extra_data = g_object_get_data (G_OBJECT (path), \"extra-data\");\n      if (extra_data != NULL && g_strcmp0 (extra_data->id, id) == 0)\n        {\n          ret = flatpak_dir_new_full (path, FALSE, extra_data);\n          break;\n        }\n    }\n\n  if (ret == NULL)\n    {\n      g_set_error (error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND,\n                   _(\"Could not find installation %s\"), id);\n    }\n\n  return ret;\n}\n\nGPtrArray *\nflatpak_dir_get_system_list (GCancellable *cancellable,\n                             GError      **error)\n{\n  g_autoptr(GPtrArray) result = NULL;\n  g_autoptr(GError) local_error = NULL;\n  GPtrArray *locations = NULL;\n  int i;\n\n  /* An error in flatpak_get_system_base_dir_locations() will still return\n   * return an empty array with the GError set, but we want to return NULL.\n   */\n  locations = flatpak_get_system_base_dir_locations (cancellable, &local_error);\n  if (local_error != NULL)\n    {\n      g_propagate_error (error, g_steal_pointer (&local_error));\n      return NULL;\n    }\n\n  result = g_ptr_array_new_with_free_func (g_object_unref);\n  for (i = 0; i < locations->len; i++)\n    {\n      GFile *path = g_ptr_array_index (locations, i);\n      DirExtraData *extra_data = g_object_get_data (G_OBJECT (path), \"extra-data\");\n      g_ptr_array_add (result, flatpak_dir_new_full (path, FALSE, extra_data));\n    }\n\n  return g_steal_pointer (&result);\n}\n\nFlatpakDir *\nflatpak_dir_get_user (void)\n{\n  g_autoptr(GFile) path = flatpak_get_user_base_dir_location ();\n  return flatpak_dir_new (path, TRUE);\n}\n\nstatic char *\nget_group (const char *remote_name)\n{\n  return g_strdup_printf (\"remote \\\"%s\\\"\", remote_name);\n}\n\nstatic GKeyFile *\nflatpak_dir_get_repo_config (FlatpakDir *self)\n{\n  if (!flatpak_dir_ensure_repo (self, NULL, NULL))\n    return NULL;\n\n  return ostree_repo_get_config (self->repo);\n}\n\nchar **\nflatpak_dir_list_remote_config_keys (FlatpakDir *self,\n                                     const char *remote_name)\n{\n  GKeyFile *config = flatpak_dir_get_repo_config (self);\n  g_autofree char *group = get_group (remote_name);\n\n  if (config)\n    return g_key_file_get_keys (config, group, NULL, NULL);\n\n  return NULL;\n}\n\nstatic void\nadd_subdirs (GPtrArray *res,\n             GFile     *parent,\n             gboolean   recurse)\n{\n  g_autoptr(GFileEnumerator) dir_enum = NULL;\n\n  dir_enum = g_file_enumerate_children (parent,\n                                        G_FILE_ATTRIBUTE_STANDARD_NAME \",\"\n                                        G_FILE_ATTRIBUTE_STANDARD_TYPE,\n                                        G_FILE_QUERY_INFO_NONE,\n                                        NULL, NULL);\n  if (dir_enum == NULL)\n    return;\n\n  while (TRUE)\n    {\n      GFileInfo *info;\n      GFile *path;\n\n      if (!g_file_enumerator_iterate (dir_enum, &info, &path, NULL, NULL) ||\n          info == NULL)\n        break;\n\n      /* Here we support either a plain repo or, if @recurse is TRUE, the root\n       * directory of a USB created with \"flatpak create-usb\"\n       */\n      if (g_file_info_get_file_type (info) == G_FILE_TYPE_DIRECTORY)\n        {\n          g_autoptr(OstreeRepo) repo = ostree_repo_new (path);\n\n          if (ostree_repo_open (repo, NULL, NULL))\n            g_ptr_array_add (res, g_object_ref (path));\n          else if (recurse)\n            {\n              g_autoptr(GFile) ostree_repo_subpath = NULL;\n              g_autoptr(GFile) dot_ostree_repo_subpath = NULL;\n              g_autoptr(GFile) dot_ostree_repo_d_subpath = NULL;\n              g_autoptr(OstreeRepo) ostree_repo_subpath_repo = NULL;\n              g_autoptr(OstreeRepo) dot_ostree_repo_subpath_repo = NULL;\n\n              ostree_repo_subpath = g_file_resolve_relative_path (path, \"ostree/repo\");\n              ostree_repo_subpath_repo = ostree_repo_new (ostree_repo_subpath);\n              if (ostree_repo_open (ostree_repo_subpath_repo, NULL, NULL))\n                g_ptr_array_add (res, g_object_ref (ostree_repo_subpath));\n\n              dot_ostree_repo_subpath = g_file_resolve_relative_path (path, \".ostree/repo\");\n              dot_ostree_repo_subpath_repo = ostree_repo_new (dot_ostree_repo_subpath);\n              if (ostree_repo_open (dot_ostree_repo_subpath_repo, NULL, NULL))\n                g_ptr_array_add (res, g_object_ref (dot_ostree_repo_subpath));\n\n              dot_ostree_repo_d_subpath = g_file_resolve_relative_path (path, \".ostree/repos.d\");\n              add_subdirs (res, dot_ostree_repo_d_subpath, FALSE);\n            }\n        }\n    }\n}\n\nGPtrArray *\nflatpak_dir_get_sideload_repo_paths (FlatpakDir *self)\n{\n  g_autoptr(GFile) sideload_repos_dir = flatpak_dir_get_sideload_repos_dir (self);\n  g_autoptr(GFile) runtime_sideload_repos_dir = flatpak_dir_get_runtime_sideload_repos_dir (self);\n  g_autoptr(GPtrArray) res = g_ptr_array_new_with_free_func (g_object_unref);\n\n  add_subdirs (res, sideload_repos_dir, TRUE);\n  add_subdirs (res, runtime_sideload_repos_dir, TRUE);\n\n  return g_steal_pointer (&res);\n}\n\n\nchar *\nflatpak_dir_get_remote_title (FlatpakDir *self,\n                              const char *remote_name)\n{\n  GKeyFile *config = flatpak_dir_get_repo_config (self);\n  g_autofree char *group = get_group (remote_name);\n\n  if (config)\n    return g_key_file_get_string (config, group, \"xa.title\", NULL);\n\n  return NULL;\n}\n\nstatic const char *\ncanonical_filter (const char *filter)\n{\n  /* Canonicalize \"no filter\", to NULL (empty means the same) */\n  if (filter && *filter == 0)\n    return NULL;\n  return filter;\n}\n\ngboolean\nflatpak_dir_compare_remote_filter (FlatpakDir *self,\n                                   const char *remote_name,\n                                   const char *filter)\n{\n  g_autofree char *current_filter = flatpak_dir_get_remote_filter (self, remote_name);\n\n  return g_strcmp0 (current_filter, canonical_filter (filter)) == 0;\n}\n\n/* returns the canonical form */\nchar *\nflatpak_dir_get_remote_filter (FlatpakDir *self,\n                               const char *remote_name)\n{\n  GKeyFile *config = flatpak_dir_get_repo_config (self);\n  g_autofree char *group = get_group (remote_name);\n\n  if (config)\n    {\n      g_autofree char *filter = g_key_file_get_string (config, group, \"xa.filter\", NULL);\n\n      if (filter && *filter != 0)\n        return g_steal_pointer (&filter);\n    }\n\n  return NULL;\n}\n\nchar *\nflatpak_dir_get_remote_comment (FlatpakDir *self,\n                                const char *remote_name)\n{\n  GKeyFile *config = flatpak_dir_get_repo_config (self);\n  g_autofree char *group = get_group (remote_name);\n\n  if (config)\n    return g_key_file_get_string (config, group, \"xa.comment\", NULL);\n\n  return NULL;\n}\n\nchar *\nflatpak_dir_get_remote_description (FlatpakDir *self,\n                                    const char *remote_name)\n{\n  GKeyFile *config = flatpak_dir_get_repo_config (self);\n  g_autofree char *group = get_group (remote_name);\n\n  if (config)\n    return g_key_file_get_string (config, group, \"xa.description\", NULL);\n\n  return NULL;\n}\n\nchar *\nflatpak_dir_get_remote_homepage (FlatpakDir *self,\n                                 const char *remote_name)\n{\n  GKeyFile *config = flatpak_dir_get_repo_config (self);\n  g_autofree char *group = get_group (remote_name);\n\n  if (config)\n    return g_key_file_get_string (config, group, \"xa.homepage\", NULL);\n\n  return NULL;\n}\n\nchar *\nflatpak_dir_get_remote_icon (FlatpakDir *self,\n                             const char *remote_name)\n{\n  GKeyFile *config = flatpak_dir_get_repo_config (self);\n  g_autofree char *group = get_group (remote_name);\n\n  if (config)\n    return g_key_file_get_string (config, group, \"xa.icon\", NULL);\n\n  return NULL;\n}\n\ngboolean\nflatpak_dir_get_remote_oci (FlatpakDir *self,\n                            const char *remote_name)\n{\n  g_autofree char *url = NULL;\n\n  if (!flatpak_dir_ensure_repo (self, NULL, NULL))\n    return FALSE;\n\n  if (!ostree_repo_remote_get_url (self->repo, remote_name, &url, NULL))\n    return FALSE;\n\n  return url && g_str_has_prefix (url, \"oci+\");\n}\n\ngint32\nflatpak_dir_get_remote_default_token_type (FlatpakDir *self,\n                                           const char *remote_name)\n{\n  GKeyFile *config = flatpak_dir_get_repo_config (self);\n  g_autofree char *group = get_group (remote_name);\n\n  if (config)\n    return (gint32)g_key_file_get_integer (config, group, \"xa.default-token-type\", NULL);\n\n  return 0;\n}\n\nchar *\nflatpak_dir_get_remote_main_ref (FlatpakDir *self,\n                                 const char *remote_name)\n{\n  GKeyFile *config = flatpak_dir_get_repo_config (self);\n  g_autofree char *group = get_group (remote_name);\n\n  if (config)\n    return g_key_file_get_string (config, group, \"xa.main-ref\", NULL);\n\n  return NULL;\n}\n\nchar *\nflatpak_dir_get_remote_default_branch (FlatpakDir *self,\n                                       const char *remote_name)\n{\n  GKeyFile *config = flatpak_dir_get_repo_config (self);\n  g_autofree char *group = get_group (remote_name);\n\n  if (config)\n    return g_key_file_get_string (config, group, \"xa.default-branch\", NULL);\n\n  return NULL;\n}\n\nint\nflatpak_dir_get_remote_prio (FlatpakDir *self,\n                             const char *remote_name)\n{\n  GKeyFile *config = flatpak_dir_get_repo_config (self);\n  g_autofree char *group = get_group (remote_name);\n\n  if (config && g_key_file_has_key (config, group, \"xa.prio\", NULL))\n    return g_key_file_get_integer (config, group, \"xa.prio\", NULL);\n\n  return 1;\n}\n\ngboolean\nflatpak_dir_get_remote_noenumerate (FlatpakDir *self,\n                                    const char *remote_name)\n{\n  GKeyFile *config = flatpak_dir_get_repo_config (self);\n  g_autofree char *group = get_group (remote_name);\n\n  if (config)\n    return g_key_file_get_boolean (config, group, \"xa.noenumerate\", NULL);\n\n  return TRUE;\n}\n\ngboolean\nflatpak_dir_get_remote_nodeps (FlatpakDir *self,\n                               const char *remote_name)\n{\n  GKeyFile *config = flatpak_dir_get_repo_config (self);\n  g_autofree char *group = get_group (remote_name);\n\n  if (config)\n    return g_key_file_get_boolean (config, group, \"xa.nodeps\", NULL);\n\n  return TRUE;\n}\n\nchar *\nflatpak_dir_get_remote_subset (FlatpakDir *self,\n                               const char *remote_name)\n{\n  GKeyFile *config = flatpak_dir_get_repo_config (self);\n  g_autofree char *group = get_group (remote_name);\n  g_autofree char *subset = NULL;\n\n  if (config == NULL)\n    return NULL;\n\n  subset = g_key_file_get_string (config, group, \"xa.subset\", NULL);\n  if (subset == NULL || *subset == 0)\n    return NULL;\n\n  return g_steal_pointer (&subset);\n}\n\ngboolean\nflatpak_dir_get_remote_disabled (FlatpakDir *self,\n                                 const char *remote_name)\n{\n  GKeyFile *config = flatpak_dir_get_repo_config (self);\n  g_autofree char *group = get_group (remote_name);\n  g_autofree char *url = NULL;\n\n  if (config &&\n      g_key_file_get_boolean (config, group, \"xa.disable\", NULL))\n    return TRUE;\n\n  if (self->repo &&\n      ostree_repo_remote_get_url (self->repo, remote_name, &url, NULL) && *url == 0)\n    return TRUE; /* Empty URL => disabled */\n\n  return FALSE;\n}\n\nstatic char *\nflatpak_dir_get_remote_install_authenticator_name (FlatpakDir *self,\n                                                   const char *remote_name)\n{\n  GKeyFile *config = flatpak_dir_get_repo_config (self);\n  g_autofree char *group = get_group (remote_name);\n\n  if (config == NULL ||\n      !g_key_file_get_boolean (config, group, \"xa.authenticator-install\", NULL))\n    return NULL;\n\n  return g_key_file_get_string (config, group, \"xa.authenticator-name\", NULL);\n}\n\ngboolean\nflatpak_dir_remote_has_deploys (FlatpakDir *self,\n                                const char *remote)\n{\n  g_autoptr(GHashTable) refs = NULL;\n  GHashTableIter hash_iter;\n  gpointer key;\n\n  refs = flatpak_dir_get_all_installed_refs (self, FLATPAK_KINDS_APP | FLATPAK_KINDS_RUNTIME, NULL);\n  if (refs == NULL)\n    return FALSE;\n\n  g_hash_table_iter_init (&hash_iter, refs);\n  while (g_hash_table_iter_next (&hash_iter, &key, NULL))\n    {\n      FlatpakDecomposed *ref = key;\n      g_autofree char *origin = flatpak_dir_get_origin (self, ref, NULL, NULL);\n\n      if (strcmp (remote, origin) == 0)\n        return TRUE;\n    }\n\n  return FALSE;\n}\n\nstatic gint\ncmp_remote (gconstpointer a,\n            gconstpointer b,\n            gpointer      user_data)\n{\n  FlatpakDir *self = user_data;\n  const char *a_name = *(const char **) a;\n  const char *b_name = *(const char **) b;\n  int prio_a, prio_b;\n\n  prio_a = flatpak_dir_get_remote_prio (self, a_name);\n  prio_b = flatpak_dir_get_remote_prio (self, b_name);\n\n  if (prio_b != prio_a)\n    return prio_b - prio_a;\n\n  /* Ensure we have a well-defined order for same prio */\n  return strcmp (a_name, b_name);\n}\n\nstatic gboolean\norigin_remote_matches (OstreeRepo *repo,\n                       const char *remote_name,\n                       const char *url,\n                       const char *main_ref,\n                       gboolean    gpg_verify)\n{\n  g_autofree char *real_url = NULL;\n  g_autofree char *real_main_ref = NULL;\n  gboolean noenumerate;\n  gboolean real_gpg_verify;\n\n  /* Must match url */\n  if (url == NULL)\n    return FALSE;\n\n  if (!ostree_repo_remote_get_url (repo, remote_name, &real_url, NULL))\n    return FALSE;\n\n  if (g_strcmp0 (url, real_url) != 0)\n    return FALSE;\n\n  /* Must be noenumerate */\n  if (!ostree_repo_get_remote_boolean_option (repo, remote_name,\n                                              \"xa.noenumerate\",\n                                              FALSE, &noenumerate,\n                                              NULL) ||\n      !noenumerate)\n    return FALSE;\n\n  /* Must match gpg-verify\n   * NOTE: We assume if all else matches the actual gpg key matches too. */\n  if (!ostree_repo_get_remote_boolean_option (repo, remote_name,\n                                              \"gpg-verify\",\n                                              FALSE, &real_gpg_verify,\n                                              NULL) ||\n      real_gpg_verify != gpg_verify)\n    return FALSE;\n\n  /* Must match main-ref */\n  if (ostree_repo_get_remote_option (repo, remote_name,\n                                     \"xa.main-ref\",\n                                     NULL, &real_main_ref,\n                                     NULL) &&\n      g_strcmp0 (main_ref, real_main_ref) != 0)\n    return FALSE;\n\n  return TRUE;\n}\n\nstatic char *\ncreate_origin_remote_config (OstreeRepo *repo,\n                             const char *url,\n                             const char *id,\n                             const char *title,\n                             const char *main_ref,\n                             gboolean    gpg_verify,\n                             const char *collection_id,\n                             GKeyFile  **new_config)\n{\n  g_autofree char *remote = NULL;\n  g_auto(GStrv) remotes = NULL;\n  int version = 0;\n  g_autofree char *group = NULL;\n  g_autofree char *prefix = NULL;\n  const char *last_dot;\n\n  remotes = ostree_repo_remote_list (repo, NULL);\n\n  last_dot = strrchr (id, '.');\n  prefix = g_ascii_strdown (last_dot ? last_dot + 1 : id, -1);\n\n  do\n    {\n      g_autofree char *name = NULL;\n      if (version == 0)\n        name = g_strdup_printf (\"%s-origin\", prefix);\n      else\n        name = g_strdup_printf (\"%s%d-origin\", prefix, version);\n      version++;\n\n      if (origin_remote_matches (repo, name, url, main_ref, gpg_verify))\n        return g_steal_pointer (&name);\n\n      if (remotes == NULL ||\n          !g_strv_contains ((const char * const *) remotes, name))\n        remote = g_steal_pointer (&name);\n    }\n  while (remote == NULL);\n\n  group = g_strdup_printf (\"remote \\\"%s\\\"\", remote);\n\n  *new_config = g_key_file_new ();\n\n  g_key_file_set_string (*new_config, group, \"url\", url ? url : \"\");\n  if (title)\n    g_key_file_set_string (*new_config, group, \"xa.title\", title);\n  g_key_file_set_string (*new_config, group, \"xa.noenumerate\", \"true\");\n  g_key_file_set_string (*new_config, group, \"xa.prio\", \"0\");\n  g_key_file_set_string (*new_config, group, \"gpg-verify-summary\", gpg_verify ? \"true\" : \"false\");\n  g_key_file_set_string (*new_config, group, \"gpg-verify\", gpg_verify ? \"true\" : \"false\");\n  if (main_ref)\n    g_key_file_set_string (*new_config, group, \"xa.main-ref\", main_ref);\n\n  if (collection_id)\n    g_key_file_set_string (*new_config, group, \"collection-id\", collection_id);\n\n  return g_steal_pointer (&remote);\n}\n\nchar *\nflatpak_dir_create_origin_remote (FlatpakDir   *self,\n                                  const char   *url,\n                                  const char   *id,\n                                  const char   *title,\n                                  const char   *main_ref,\n                                  GBytes       *gpg_data,\n                                  const char   *collection_id,\n                                  gboolean     *changed_config,\n                                  GCancellable *cancellable,\n                                  GError      **error)\n{\n  g_autoptr(GKeyFile) new_config = NULL;\n  g_autofree char *remote = NULL;\n\n  remote = create_origin_remote_config (self->repo, url, id, title, main_ref, gpg_data != NULL, collection_id, &new_config);\n\n  if (new_config &&\n      !flatpak_dir_modify_remote (self, remote, new_config,\n                                  gpg_data, cancellable, error))\n    return NULL;\n\n  if (new_config && !_flatpak_dir_reload_config (self, cancellable, error))\n    return FALSE;\n\n  if (changed_config)\n    *changed_config = (new_config != NULL);\n\n  return g_steal_pointer (&remote);\n}\n\nstatic gboolean\nparse_ref_file (GKeyFile *keyfile,\n                char    **name_out,\n                char    **branch_out,\n                char    **url_out,\n                char    **title_out,\n                GBytes  **gpg_data_out,\n                gboolean *is_runtime_out,\n                char    **collection_id_out,\n                GError  **error)\n{\n  g_autofree char *url = NULL;\n  g_autofree char *title = NULL;\n  g_autofree char *name = NULL;\n  g_autofree char *branch = NULL;\n  g_autofree char *version = NULL;\n  g_autoptr(GBytes) gpg_data = NULL;\n  gboolean is_runtime = FALSE;\n  g_autofree char *collection_id = NULL;\n  g_autofree char *str = NULL;\n\n  *name_out = NULL;\n  *branch_out = NULL;\n  *url_out = NULL;\n  *title_out = NULL;\n  *gpg_data_out = NULL;\n  *is_runtime_out = FALSE;\n\n  if (!g_key_file_has_group (keyfile, FLATPAK_REF_GROUP))\n    return flatpak_fail_error (error, FLATPAK_ERROR_INVALID_DATA, _(\"Invalid file format, no %s group\"), FLATPAK_REF_GROUP);\n\n  version = g_key_file_get_string (keyfile, FLATPAK_REF_GROUP,\n                                   FLATPAK_REF_VERSION_KEY, NULL);\n  if (version != NULL && strcmp (version, \"1\") != 0)\n    return flatpak_fail_error (error, FLATPAK_ERROR_INVALID_DATA, _(\"Invalid version %s, only 1 supported\"), version);\n\n  url = g_key_file_get_string (keyfile, FLATPAK_REF_GROUP,\n                               FLATPAK_REF_URL_KEY, NULL);\n  if (url == NULL)\n    return flatpak_fail_error (error, FLATPAK_ERROR_INVALID_DATA, _(\"Invalid file format, no %s specified\"), FLATPAK_REF_URL_KEY);\n\n  name = g_key_file_get_string (keyfile, FLATPAK_REF_GROUP,\n                                FLATPAK_REF_NAME_KEY, NULL);\n  if (name == NULL)\n    return flatpak_fail_error (error, FLATPAK_ERROR_INVALID_DATA, _(\"Invalid file format, no %s specified\"), FLATPAK_REF_NAME_KEY);\n\n  branch = g_key_file_get_string (keyfile, FLATPAK_REF_GROUP,\n                                  FLATPAK_REF_BRANCH_KEY, NULL);\n  if (branch == NULL)\n    branch = g_strdup (\"master\");\n\n  title = g_key_file_get_string (keyfile, FLATPAK_REF_GROUP,\n                                 FLATPAK_REF_TITLE_KEY, NULL);\n\n  is_runtime = g_key_file_get_boolean (keyfile, FLATPAK_REF_GROUP,\n                                       FLATPAK_REF_IS_RUNTIME_KEY, NULL);\n\n  str = g_key_file_get_string (keyfile, FLATPAK_REF_GROUP,\n                               FLATPAK_REF_GPGKEY_KEY, NULL);\n  if (str != NULL)\n    {\n      g_autofree guchar *decoded = NULL;\n      gsize decoded_len;\n\n      str = g_strstrip (str);\n      decoded = g_base64_decode (str, &decoded_len);\n      if (decoded_len < 10) /* Check some minimal size so we don't get crap */\n        return flatpak_fail_error (error, FLATPAK_ERROR_INVALID_DATA, _(\"Invalid file format, gpg key invalid\"));\n\n      gpg_data = g_bytes_new_take (g_steal_pointer (&decoded), decoded_len);\n    }\n\n  collection_id = g_key_file_get_string (keyfile, FLATPAK_REF_GROUP,\n                                         FLATPAK_REF_DEPLOY_COLLECTION_ID_KEY, NULL);\n\n  if (collection_id == NULL || *collection_id == '\\0')\n    {\n      collection_id = g_key_file_get_string (keyfile, FLATPAK_REF_GROUP,\n                                             FLATPAK_REF_COLLECTION_ID_KEY, NULL);\n    }\n\n  if (collection_id != NULL && *collection_id == '\\0')\n    collection_id = NULL;\n\n  if (collection_id != NULL && gpg_data == NULL)\n    return flatpak_fail_error (error, FLATPAK_ERROR_INVALID_DATA, _(\"Collection ID requires GPG key to be provided\"));\n\n  *name_out = g_steal_pointer (&name);\n  *branch_out = g_steal_pointer (&branch);\n  *url_out = g_steal_pointer (&url);\n  *title_out = g_steal_pointer (&title);\n  *gpg_data_out = g_steal_pointer (&gpg_data);\n  *is_runtime_out = is_runtime;\n  *collection_id_out = g_steal_pointer (&collection_id);\n\n  return TRUE;\n}\n\ngboolean\nflatpak_dir_create_remote_for_ref_file (FlatpakDir         *self,\n                                        GKeyFile           *keyfile,\n                                        const char         *default_arch,\n                                        char              **remote_name_out,\n                                        char              **collection_id_out,\n                                        FlatpakDecomposed **ref_out,\n                                        GError            **error)\n{\n  g_autoptr(GBytes) gpg_data = NULL;\n  g_autofree char *name = NULL;\n  g_autofree char *branch = NULL;\n  g_autofree char *url = NULL;\n  g_autofree char *title = NULL;\n  g_autofree char *remote = NULL;\n  gboolean is_runtime = FALSE;\n  g_autofree char *collection_id = NULL;\n  g_autoptr(GFile) deploy_dir = NULL;\n  g_autoptr(FlatpakDecomposed) ref = NULL;\n\n  if (!parse_ref_file (keyfile, &name, &branch, &url, &title, &gpg_data, &is_runtime, &collection_id, error))\n    return FALSE;\n\n  ref = flatpak_decomposed_new_from_parts (is_runtime ? FLATPAK_KINDS_RUNTIME : FLATPAK_KINDS_APP,\n                                           name, default_arch, branch, error);\n  if (ref == NULL)\n    return FALSE;\n\n  deploy_dir = flatpak_dir_get_if_deployed (self, ref, NULL, NULL);\n  if (deploy_dir != NULL)\n    {\n      g_set_error (error, FLATPAK_ERROR, FLATPAK_ERROR_ALREADY_INSTALLED,\n                   is_runtime ? _(\"Runtime %s, branch %s is already installed\") :\n                   _(\"App %s, branch %s is already installed\"),\n                   name, branch);\n      return FALSE;\n    }\n\n  /* First try to reuse existing remote */\n  remote = flatpak_dir_find_remote_by_uri (self, url);\n\n  if (remote == NULL)\n    {\n      remote = flatpak_dir_create_origin_remote (self, url, name, title, flatpak_decomposed_get_ref (ref),\n                                                 gpg_data, collection_id, NULL, NULL, error);\n      if (remote == NULL)\n        return FALSE;\n    }\n\n  if (collection_id_out != NULL)\n    *collection_id_out = g_steal_pointer (&collection_id);\n\n  *remote_name_out = g_steal_pointer (&remote);\n  *ref_out = g_steal_pointer (&ref);\n  return TRUE;\n}\n\nstatic gboolean\n_flatpak_uri_equal (const char *uri1,\n                    const char *uri2)\n{\n  g_autofree char *uri1_norm = NULL;\n  g_autofree char *uri2_norm = NULL;\n  gsize uri1_len = strlen (uri1);\n  gsize uri2_len = strlen (uri2);\n\n  /* URIs handled by libostree are equivalent with or without a trailing slash,\n   * but this isn't otherwise guaranteed to be the case.\n   */\n  if (g_str_has_prefix (uri1, \"oci+\") || g_str_has_prefix (uri2, \"oci+\"))\n    return g_strcmp0 (uri1, uri2) == 0;\n\n  if (g_str_has_suffix (uri1, \"/\"))\n    uri1_norm = g_strndup (uri1, uri1_len - 1);\n  else\n    uri1_norm = g_strdup (uri1);\n\n  if (g_str_has_suffix (uri2, \"/\"))\n    uri2_norm = g_strndup (uri2, uri2_len - 1);\n  else\n    uri2_norm = g_strdup (uri2);\n\n  return g_strcmp0 (uri1_norm, uri2_norm) == 0;\n}\n\n/* This tries to find a pre-configured remote for the specified uri.\n *\n *  We consider non-OCI URLs equal even if one lacks a trailing slash.\n */\nchar *\nflatpak_dir_find_remote_by_uri (FlatpakDir *self,\n                                const char *uri)\n{\n  g_auto(GStrv) remotes = NULL;\n\n  g_return_val_if_fail (self != NULL, NULL);\n  g_return_val_if_fail (uri != NULL, NULL);\n\n  if (!flatpak_dir_ensure_repo (self, NULL, NULL))\n    return NULL;\n\n  remotes = flatpak_dir_list_enumerated_remotes (self, NULL, NULL);\n  if (remotes)\n    {\n      int i;\n\n      for (i = 0; remotes != NULL && remotes[i] != NULL; i++)\n        {\n          const char *remote = remotes[i];\n          g_autofree char *remote_uri = NULL;\n\n          if (!ostree_repo_remote_get_url (self->repo,\n                                           remote,\n                                           &remote_uri,\n                                           NULL))\n            continue;\n\n          if (_flatpak_uri_equal (uri, remote_uri))\n            return g_strdup (remote);\n        }\n    }\n\n  return NULL;\n}\n\ngboolean\nflatpak_dir_has_remote (FlatpakDir *self,\n                        const char *remote_name,\n                        GError    **error)\n{\n  GKeyFile *config = NULL;\n  g_autofree char *group = g_strdup_printf (\"remote \\\"%s\\\"\", remote_name);\n\n  if (flatpak_dir_maybe_ensure_repo (self, NULL, NULL) &&\n      self->repo != NULL)\n    {\n      config = ostree_repo_get_config (self->repo);\n      if (config && g_key_file_has_group (config, group))\n        return TRUE;\n    }\n\n  return flatpak_fail_error (error, FLATPAK_ERROR_REMOTE_NOT_FOUND,\n                             \"Remote \\\"%s\\\" not found\", remote_name);\n}\n\n\nchar **\nflatpak_dir_list_remotes (FlatpakDir   *self,\n                          GCancellable *cancellable,\n                          GError      **error)\n{\n  char **res = NULL;\n\n  if (!flatpak_dir_maybe_ensure_repo (self, cancellable, error))\n    return NULL;\n\n  if (self->repo)\n    res = ostree_repo_remote_list (self->repo, NULL);\n\n  if (res == NULL)\n    res = g_new0 (char *, 1); /* Return empty array, not error */\n\n  g_qsort_with_data (res, g_strv_length (res), sizeof (char *),\n                     cmp_remote, self);\n\n  return res;\n}\n\nchar **\nflatpak_dir_list_enumerated_remotes (FlatpakDir   *self,\n                                     GCancellable *cancellable,\n                                     GError      **error)\n{\n  g_autoptr(GPtrArray) res = g_ptr_array_new_with_free_func (g_free);\n  g_auto(GStrv) remotes = NULL;\n  int i;\n\n  remotes = flatpak_dir_list_remotes (self, cancellable, error);\n  if (remotes == NULL)\n    return NULL;\n\n  for (i = 0; remotes != NULL && remotes[i] != NULL; i++)\n    {\n      const char *remote = remotes[i];\n\n      if (flatpak_dir_get_remote_disabled (self, remote))\n        continue;\n\n      if (flatpak_dir_get_remote_noenumerate (self, remote))\n        continue;\n\n      g_ptr_array_add (res, g_strdup (remote));\n    }\n\n  g_ptr_array_add (res, NULL);\n  return (char **) g_ptr_array_free (g_steal_pointer (&res), FALSE);\n}\n\nchar **\nflatpak_dir_list_dependency_remotes (FlatpakDir   *self,\n                                     GCancellable *cancellable,\n                                     GError      **error)\n{\n  g_autoptr(GPtrArray) res = g_ptr_array_new_with_free_func (g_free);\n  g_auto(GStrv) remotes = NULL;\n  int i;\n\n  remotes = flatpak_dir_list_remotes (self, cancellable, error);\n  if (remotes == NULL)\n    return NULL;\n\n  for (i = 0; remotes != NULL && remotes[i] != NULL; i++)\n    {\n      const char *remote = remotes[i];\n\n      if (flatpak_dir_get_remote_disabled (self, remote))\n        continue;\n\n      if (flatpak_dir_get_remote_noenumerate (self, remote))\n        continue;\n\n      if (flatpak_dir_get_remote_nodeps (self, remote))\n        continue;\n\n      g_ptr_array_add (res, g_strdup (remote));\n    }\n\n  g_ptr_array_add (res, NULL);\n  return (char **) g_ptr_array_free (g_steal_pointer (&res), FALSE);\n}\n\ngboolean\nflatpak_dir_remove_remote (FlatpakDir   *self,\n                           gboolean      force_remove,\n                           const char   *remote_name,\n                           GCancellable *cancellable,\n                           GError      **error)\n{\n  g_autofree char *prefix = NULL;\n  g_autoptr(GHashTable) refs = NULL;\n  GHashTableIter hash_iter;\n  gpointer key;\n  g_autofree char *url = NULL;\n\n  if (flatpak_dir_use_system_helper (self, NULL))\n    {\n      g_autoptr(GVariant) gpg_data_v = NULL;\n      FlatpakHelperConfigureRemoteFlags flags = 0;\n      const char *installation = flatpak_dir_get_id (self);\n\n      gpg_data_v = g_variant_ref_sink (g_variant_new_from_data (G_VARIANT_TYPE (\"ay\"), \"\", 0, TRUE, NULL, NULL));\n\n      if (force_remove)\n        flags |= FLATPAK_HELPER_CONFIGURE_REMOTE_FLAGS_FORCE_REMOVE;\n\n      if (!flatpak_dir_system_helper_call_configure_remote (self,\n                                                            flags, remote_name,\n                                                            \"\",\n                                                            gpg_data_v,\n                                                            installation ? installation : \"\",\n                                                            cancellable, error))\n        return FALSE;\n\n      return TRUE;\n    }\n\n  if (!flatpak_dir_ensure_repo (self, cancellable, error))\n    return FALSE;\n\n  if (!ostree_repo_list_refs (self->repo,\n                              NULL,\n                              &refs,\n                              cancellable, error))\n    return FALSE;\n\n  prefix = g_strdup_printf (\"%s:\", remote_name);\n\n  if (!force_remove)\n    {\n      g_hash_table_iter_init (&hash_iter, refs);\n      while (g_hash_table_iter_next (&hash_iter, &key, NULL))\n        {\n          const char *refspec = key;\n\n          if (!g_str_has_prefix (refspec, prefix))\n            continue;\n\n          g_autoptr(FlatpakDecomposed) ref = flatpak_decomposed_new_from_refspec (refspec, NULL);\n          if (ref == NULL)\n            continue;\n\n          g_autofree char *origin = flatpak_dir_get_origin (self, ref, cancellable, NULL);\n          if (g_strcmp0 (origin, remote_name) == 0)\n            return flatpak_fail_error (error, FLATPAK_ERROR_REMOTE_USED,\n                                       _(\"Can't remove remote '%s' with installed ref %s (at least)\"),\n                                       remote_name, flatpak_decomposed_get_ref (ref));\n        }\n    }\n\n  /* Remove all refs */\n  g_hash_table_iter_init (&hash_iter, refs);\n  while (g_hash_table_iter_next (&hash_iter, &key, NULL))\n    {\n      const char *refspec = key;\n\n      if (g_str_has_prefix (refspec, prefix) &&\n          !flatpak_dir_remove_ref (self, remote_name, refspec + strlen (prefix), cancellable, error))\n        return FALSE;\n    }\n\n  if (!flatpak_dir_remove_appstream (self, remote_name,\n                                     cancellable, error))\n    return FALSE;\n\n  if (flatpak_dir_get_remote_oci (self, remote_name) &&\n      !flatpak_dir_remove_oci_files (self, remote_name,\n                                     cancellable, error))\n    return FALSE;\n\n  ostree_repo_remote_get_url (self->repo, remote_name, &url, NULL);\n\n  if (!ostree_repo_remote_change (self->repo, NULL,\n                                  OSTREE_REPO_REMOTE_CHANGE_DELETE,\n                                  remote_name, NULL,\n                                  NULL,\n                                  cancellable, error))\n    return FALSE;\n\n  if (!flatpak_dir_mark_changed (self, error))\n    return FALSE;\n\n  flatpak_dir_log (self, \"remove remote\",\n                   remote_name, NULL, NULL, NULL, url,\n                   \"Removed remote %s\", remote_name);\n\n  return TRUE;\n}\n\nstatic gboolean\nflatpak_dir_cleanup_remote_for_url_change (FlatpakDir   *self,\n                                           const char   *remote_name,\n                                           const char   *url,\n                                           GCancellable *cancellable,\n                                           GError      **error)\n{\n  g_autofree char *old_url = NULL;\n\n  /* We store things a bit differently for OCI and non-OCI remotes,\n   * so when changing from one to the other, we need to clean up cached\n   * files.\n   */\n  if (ostree_repo_remote_get_url (self->repo,\n                                  remote_name,\n                                  &old_url,\n                                  NULL))\n    {\n      gboolean was_oci = g_str_has_prefix (old_url, \"oci+\");\n      gboolean will_be_oci = g_str_has_prefix (url, \"oci+\");\n\n      if (was_oci != will_be_oci)\n        {\n          if (!flatpak_dir_remove_appstream (self, remote_name,\n                                             cancellable, error))\n            return FALSE;\n        }\n\n      if (was_oci && !will_be_oci)\n        {\n          if (!flatpak_dir_remove_oci_files (self, remote_name,\n                                             cancellable, error))\n            return FALSE;\n        }\n    }\n\n  return TRUE;\n}\n\ngboolean\nflatpak_dir_modify_remote (FlatpakDir   *self,\n                           const char   *remote_name,\n                           GKeyFile     *config,\n                           GBytes       *gpg_data,\n                           GCancellable *cancellable,\n                           GError      **error)\n{\n  g_autofree char *group = g_strdup_printf (\"remote \\\"%s\\\"\", remote_name);\n  g_autofree char *url = NULL;\n  g_autofree char *metalink = NULL;\n  g_autoptr(GKeyFile) new_config = NULL;\n  g_autofree gchar *filter_path = NULL;\n  gboolean has_remote;\n\n  if (strchr (remote_name, '/') != NULL)\n    return flatpak_fail_error (error, FLATPAK_ERROR_REMOTE_NOT_FOUND, _(\"Invalid character '/' in remote name: %s\"),\n                               remote_name);\n\n  has_remote = flatpak_dir_has_remote (self, remote_name, NULL);\n\n  if (!g_key_file_has_group (config, group))\n    return flatpak_fail_error (error, FLATPAK_ERROR_INVALID_DATA, _(\"No configuration for remote %s specified\"),\n                               remote_name);\n\n  if (!flatpak_dir_check_add_remotes_config_dir (self, error))\n    return FALSE;\n\n  if (flatpak_dir_use_system_helper (self, NULL))\n    {\n      g_autofree char *config_data = g_key_file_to_data (config, NULL, NULL);\n      g_autoptr(GVariant) gpg_data_v = NULL;\n      const char *installation = flatpak_dir_get_id (self);\n\n      if (gpg_data != NULL)\n        gpg_data_v = variant_new_ay_bytes (gpg_data);\n      else\n        gpg_data_v = g_variant_ref_sink (g_variant_new_from_data (G_VARIANT_TYPE (\"ay\"), \"\", 0, TRUE, NULL, NULL));\n\n      if (!flatpak_dir_system_helper_call_configure_remote (self,\n                                                            0, remote_name,\n                                                            config_data,\n                                                            gpg_data_v,\n                                                            installation ? installation : \"\",\n                                                            cancellable, error))\n        return FALSE;\n\n      /* If we e.g. changed url or gpg config the cached summary may be invalid */\n      if (!flatpak_dir_remote_clear_cached_summary (self, remote_name, cancellable, error))\n        return FALSE;\n\n      return TRUE;\n    }\n\n  metalink = g_key_file_get_string (config, group, \"metalink\", NULL);\n  if (metalink != NULL && *metalink != 0)\n    url = g_strconcat (\"metalink=\", metalink, NULL);\n  else\n    url = g_key_file_get_string (config, group, \"url\", NULL);\n\n  /* No url => disabled */\n  if (url == NULL)\n    url = g_strdup (\"\");\n\n  if (!flatpak_dir_cleanup_remote_for_url_change (self, remote_name, url, cancellable, error))\n    return FALSE;\n\n  /* Add it if its not there yet */\n  if (!ostree_repo_remote_change (self->repo, NULL,\n                                  OSTREE_REPO_REMOTE_CHANGE_ADD_IF_NOT_EXISTS,\n                                  remote_name,\n                                  url, NULL, cancellable, error))\n    return FALSE;\n\n  new_config = ostree_repo_copy_config (self->repo);\n\n  copy_remote_config (new_config, config, remote_name);\n\n  if (!ostree_repo_write_config (self->repo, new_config, error))\n    return FALSE;\n\n  if (gpg_data != NULL)\n    {\n      g_autoptr(GInputStream) input_stream = g_memory_input_stream_new_from_bytes (gpg_data);\n      guint imported = 0;\n\n      if (!ostree_repo_remote_gpg_import (self->repo, remote_name, input_stream,\n                                          NULL, &imported, cancellable, error))\n        return FALSE;\n\n      /* XXX If we ever add internationalization, use ngettext() here. */\n      g_debug (\"Imported %u GPG key%s to remote \\\"%s\\\"\",\n               imported, (imported == 1) ? \"\" : \"s\", remote_name);\n    }\n\n  filter_path = g_key_file_get_value (new_config, group, \"xa.filter\", NULL);\n  if (filter_path && *filter_path && g_file_test (filter_path, G_FILE_TEST_EXISTS))\n    {\n      /* Make a backup filter copy in case it goes away later */\n      g_autofree char *filter_name = g_strconcat (remote_name, \".filter\", NULL);\n      g_autoptr(GFile) filter_file = g_file_new_for_path (filter_path);\n      g_autoptr(GFile) filter_copy = flatpak_build_file (self->basedir, \"repo\", filter_name, NULL);\n      g_autoptr(GError) local_error = NULL;\n      g_autofree char *backup_data = NULL;\n      gsize backup_data_size;\n\n      if (g_file_load_contents (filter_file, cancellable, &backup_data, &backup_data_size, NULL, &local_error))\n        {\n          g_autofree char *backup_data_copy =\n            g_strdup_printf (\"# backup copy of %s, do not edit!\\n%s\", filter_path, backup_data);\n\n          if (!g_file_replace_contents (filter_copy, backup_data_copy, strlen (backup_data_copy),\n                                        NULL, FALSE, G_FILE_CREATE_REPLACE_DESTINATION, NULL, cancellable, &local_error))\n            g_debug (\"Failed to save backup copy of filter file %s: %s\\n\", filter_path, local_error->message);\n        }\n      else\n        {\n          g_debug (\"Failed to read filter %s file while making a backup copy: %s\\n\", filter_path, local_error->message);\n        }\n    }\n\n  /* If we e.g. changed url or gpg config the cached summary may be invalid */\n  if (!flatpak_dir_remote_clear_cached_summary (self, remote_name, cancellable, error))\n    return FALSE;\n\n  if (!flatpak_dir_mark_changed (self, error))\n    return FALSE;\n\n  if (has_remote)\n    flatpak_dir_log (self, \"modify remote\", remote_name, NULL, NULL, NULL, url,\n                     \"Modified remote %s to %s\", remote_name, url);\n  else\n    flatpak_dir_log (self, \"add remote\", remote_name, NULL, NULL, NULL, url,\n                     \"Added remote %s to %s\", remote_name, url);\n\n  return TRUE;\n}\n\nstatic gboolean\nremove_unless_decomposed_in_hash (gpointer key,\n                                  gpointer value,\n                                  gpointer user_data)\n{\n  GHashTable *table = user_data;\n  const FlatpakDecomposed *d = key;\n\n  return !g_hash_table_contains (table, d);\n}\n\ngboolean\nflatpak_dir_list_remote_refs (FlatpakDir         *self,\n                              FlatpakRemoteState *state,\n                              GHashTable        **refs,\n                              GCancellable       *cancellable,\n                              GError            **error)\n{\n  g_autoptr(GError) my_error = NULL;\n\n  if (error == NULL)\n    error = &my_error;\n\n  if (!flatpak_dir_list_all_remote_refs (self, state, refs,\n                                         cancellable, error))\n    return FALSE;\n\n  if (flatpak_dir_get_remote_noenumerate (self, state->remote_name))\n    {\n      g_autoptr(GHashTable) decomposed_local_refs =\n        g_hash_table_new_full ((GHashFunc)flatpak_decomposed_hash, (GEqualFunc)flatpak_decomposed_equal, (GDestroyNotify)flatpak_decomposed_unref, NULL);\n      g_autoptr(GHashTable) local_refs = NULL;\n      GHashTableIter hash_iter;\n      gpointer key;\n      g_autofree char *refspec_prefix = g_strconcat (state->remote_name, \":.\", NULL);\n\n      /* For noenumerate remotes, only return data for already locally\n       * available refs */\n\n      if (!ostree_repo_list_refs (self->repo, refspec_prefix, &local_refs,\n                                  cancellable, error))\n        return FALSE;\n\n      g_hash_table_iter_init (&hash_iter, local_refs);\n      while (g_hash_table_iter_next (&hash_iter, &key, NULL))\n        {\n          const char *refspec = key;\n          g_autoptr(FlatpakDecomposed) d = flatpak_decomposed_new_from_refspec (refspec, NULL);\n          if (d)\n            g_hash_table_insert (decomposed_local_refs, g_steal_pointer (&d), NULL);\n        }\n\n      /* Then we remove all remote refs not in the local refs set */\n      g_hash_table_foreach_remove (*refs,\n                                   remove_unless_decomposed_in_hash,\n                                   decomposed_local_refs);\n    }\n\n  return TRUE;\n}\n\nstatic gboolean\nstrv_contains_prefix (const gchar * const *strv,\n                      const gchar         *str)\n{\n  g_return_val_if_fail (strv != NULL, FALSE);\n  g_return_val_if_fail (str != NULL, FALSE);\n\n  for (; *strv != NULL; strv++)\n    {\n      if (g_str_has_prefix (str, *strv))\n        return TRUE;\n    }\n\n  return FALSE;\n}\n\ngboolean\nflatpak_dir_update_remote_configuration_for_state (FlatpakDir         *self,\n                                                   FlatpakRemoteState *remote_state,\n                                                   gboolean            dry_run,\n                                                   gboolean           *has_changed_out,\n                                                   GCancellable       *cancellable,\n                                                   GError            **error)\n{\n  /* We only support those configuration parameters that can\n     be set in the server when building the repo (see the\n     flatpak_repo_set_* () family of functions) */\n  static const char *const supported_params[] = {\n    \"xa.title\",\n    \"xa.comment\",\n    \"xa.description\",\n    \"xa.homepage\",\n    \"xa.icon\",\n    \"xa.default-branch\",\n    \"xa.gpg-keys\",\n    \"xa.redirect-url\",\n    \"xa.authenticator-name\",\n    \"xa.authenticator-install\",\n    OSTREE_META_KEY_DEPLOY_COLLECTION_ID,\n    \"xa.deploy-collection-id\", /* This is a new version only supported in post p2p flatpak (1.7) */\n    NULL\n  };\n  static const char *const supported_param_prefixes[] = {\n    \"xa.authenticator-options.\",\n    NULL\n  };\n  g_autoptr(GPtrArray) updated_params = NULL;\n  g_autoptr(GVariant) metadata = NULL;\n  GVariantIter iter;\n  g_autoptr(GBytes) gpg_keys = NULL;\n\n  updated_params = g_ptr_array_new_with_free_func (g_free);\n\n  if (!flatpak_remote_state_ensure_summary (remote_state, error))\n    return FALSE;\n\n  if (remote_state->index)\n    metadata = g_variant_get_child_value (remote_state->index, 1);\n  else\n    metadata = g_variant_get_child_value (remote_state->summary, 1);\n\n  g_variant_iter_init (&iter, metadata);\n  if (g_variant_iter_n_children (&iter) > 0)\n    {\n      GVariant *value_var = NULL;\n      char *key = NULL;\n\n      while (g_variant_iter_next (&iter, \"{sv}\", &key, &value_var))\n        {\n          if (g_strv_contains (supported_params, key) ||\n              strv_contains_prefix (supported_param_prefixes, key))\n            {\n              if (strcmp (key, \"xa.gpg-keys\") == 0)\n                {\n                  if (g_variant_is_of_type (value_var, G_VARIANT_TYPE_BYTESTRING))\n                    {\n                      const guchar *gpg_data = g_variant_get_data (value_var);\n                      gsize gpg_size = g_variant_get_size (value_var);\n                      g_autofree gchar *gpg_data_checksum = g_compute_checksum_for_data (G_CHECKSUM_SHA256, gpg_data, gpg_size);\n\n                      gpg_keys = g_bytes_new (gpg_data, gpg_size);\n\n                      /* We store the hash so that we can detect when things changed or not\n                         instead of re-importing the key over-and-over */\n                      g_ptr_array_add (updated_params, g_strdup (\"xa.gpg-keys-hash\"));\n                      g_ptr_array_add (updated_params, g_steal_pointer (&gpg_data_checksum));\n                    }\n                }\n              else if (g_variant_is_of_type (value_var, G_VARIANT_TYPE_STRING))\n                {\n                  const char *value = g_variant_get_string (value_var, NULL);\n                  if (value != NULL && *value != 0)\n                    {\n                      if (strcmp (key, \"xa.redirect-url\") == 0)\n                        g_ptr_array_add (updated_params, g_strdup (\"url\"));\n                      else if (strcmp (key, OSTREE_META_KEY_DEPLOY_COLLECTION_ID) == 0)\n                        g_ptr_array_add (updated_params, g_strdup (\"collection-id\"));\n                      else if (strcmp (key, \"xa.deploy-collection-id\") == 0)\n                        g_ptr_array_add (updated_params, g_strdup (\"collection-id\"));\n                      else\n                        g_ptr_array_add (updated_params, g_strdup (key));\n                      g_ptr_array_add (updated_params, g_strdup (value));\n                    }\n                }\n              else if (g_variant_is_of_type (value_var, G_VARIANT_TYPE_BOOLEAN))\n                {\n                  gboolean value = g_variant_get_boolean (value_var);\n                  g_ptr_array_add (updated_params, g_strdup (key));\n                  if (value)\n                    g_ptr_array_add (updated_params, g_strdup (\"true\"));\n                  else\n                    g_ptr_array_add (updated_params, g_strdup (\"false\"));\n                }\n            }\n\n          g_variant_unref (value_var);\n          g_free (key);\n        }\n    }\n\n  if (updated_params->len > 0)\n    {\n      g_autoptr(GKeyFile) config = NULL;\n      g_autofree char *group = NULL;\n      gboolean has_changed = FALSE;\n      int i;\n\n      config = ostree_repo_copy_config (flatpak_dir_get_repo (self));\n      group = g_strdup_printf (\"remote \\\"%s\\\"\", remote_state->remote_name);\n\n      i = 0;\n      while (i < (updated_params->len - 1))\n        {\n          /* This array should have an even number of elements with\n             keys in the odd positions and values on even ones. */\n          const char *key = g_ptr_array_index (updated_params, i);\n          const char *new_val = g_ptr_array_index (updated_params, i + 1);\n          g_autofree char *current_val = NULL;\n          g_autofree char *is_set_key = g_strconcat (key, \"-is-set\", NULL);\n          gboolean is_set = FALSE;\n\n          is_set = g_key_file_get_boolean (config, group, is_set_key, NULL);\n          if (!is_set)\n            {\n              current_val = g_key_file_get_string (config, group, key, NULL);\n              if ((!g_str_equal (key, \"collection-id\") &&\n                   g_strcmp0 (current_val, new_val) != 0) ||\n                  (g_str_equal (key, \"collection-id\") &&\n                   (current_val == NULL || *current_val == '\\0') &&\n                   new_val != NULL && *new_val != '\\0'))\n                {\n                  has_changed = TRUE;\n                  g_key_file_set_string (config, group, key, new_val);\n                }\n            }\n\n          i += 2;\n        }\n\n      if (has_changed_out)\n        *has_changed_out = has_changed;\n\n      if (dry_run || !has_changed)\n        return TRUE;\n\n      /* Update the local remote configuration with the updated info. */\n      if (!flatpak_dir_modify_remote (self, remote_state->remote_name, config, gpg_keys, cancellable, error))\n        return FALSE;\n    }\n\n  return TRUE;\n}\n\ngboolean\nflatpak_dir_update_remote_configuration (FlatpakDir   *self,\n                                         const char   *remote,\n                                         FlatpakRemoteState *optional_remote_state,\n                                         gboolean     *updated_out,\n                                         GCancellable *cancellable,\n                                         GError      **error)\n{\n  gboolean is_oci;\n  g_autoptr(FlatpakRemoteState) local_state = NULL;\n  FlatpakRemoteState *state;\n  gboolean has_changed = FALSE;\n\n  /* Initialize if we exit early */\n  if (updated_out)\n    *updated_out = FALSE;\n\n  if (flatpak_dir_get_remote_disabled (self, remote))\n    return TRUE;\n\n  is_oci = flatpak_dir_get_remote_oci (self, remote);\n  if (is_oci)\n    return TRUE;\n\n  if (optional_remote_state)\n    state = optional_remote_state;\n  else\n    {\n      local_state = flatpak_dir_get_remote_state (self, remote, FALSE, cancellable, error);\n      if (local_state == NULL)\n        return FALSE;\n      state = local_state;\n    }\n\n  if (flatpak_dir_use_system_helper (self, NULL))\n    {\n      gboolean gpg_verify_summary;\n      gboolean gpg_verify;\n\n      if (!ostree_repo_remote_get_gpg_verify_summary (self->repo, remote, &gpg_verify_summary, error))\n        return FALSE;\n\n      if (!ostree_repo_remote_get_gpg_verify (self->repo, remote, &gpg_verify, error))\n        return FALSE;\n\n      if (!gpg_verify_summary || !gpg_verify)\n        {\n          g_debug (\"Ignoring automatic updates for system-helper remotes without gpg signatures\");\n          return TRUE;\n        }\n\n      if ((state->summary != NULL && state->summary_sig_bytes == NULL) ||\n          (state->index != NULL && state->index_sig_bytes == NULL))\n        {\n          g_debug (\"Can't update remote configuration as user, no GPG signature\");\n          return TRUE;\n        }\n\n      if (!flatpak_dir_update_remote_configuration_for_state (self, state, TRUE, &has_changed, cancellable, error))\n        return FALSE;\n\n      if (has_changed)\n        {\n          g_autoptr(GBytes) bytes = g_variant_get_data_as_bytes (state->index ? state->index : state->summary);\n          GBytes *sig_bytes = state->index ? state->index_sig_bytes : state->summary_sig_bytes;\n          glnx_autofd int summary_fd = -1;\n          g_autofree char *summary_path = NULL;\n          glnx_autofd int summary_sig_fd = -1;\n          g_autofree char *summary_sig_path = NULL;\n          const char *installation;\n          FlatpakHelperUpdateRemoteFlags flags = 0;\n\n          if (state->index)\n            flags |= FLATPAK_HELPER_UPDATE_REMOTE_FLAGS_SUMMARY_IS_INDEX;\n\n          summary_fd = g_file_open_tmp (\"remote-summary.XXXXXX\", &summary_path, error);\n          if (summary_fd == -1)\n            return FALSE;\n          if (glnx_loop_write (summary_fd, g_bytes_get_data (bytes, NULL), g_bytes_get_size (bytes)) < 0)\n            return glnx_throw_errno (error);\n\n          if (sig_bytes != NULL)\n            {\n              summary_sig_fd = g_file_open_tmp (\"remote-summary-sig.XXXXXX\", &summary_sig_path, error);\n              if (summary_sig_fd == -1)\n                return FALSE;\n              if (glnx_loop_write (summary_sig_fd, g_bytes_get_data (sig_bytes, NULL), g_bytes_get_size (sig_bytes)) < 0)\n                return glnx_throw_errno (error);\n            }\n\n          installation = flatpak_dir_get_id (self);\n\n          if (!flatpak_dir_system_helper_call_update_remote (self, flags, remote,\n                                                             installation ? installation : \"\",\n                                                             summary_path, summary_sig_path ? summary_sig_path : \"\",\n                                                             cancellable, error))\n            return FALSE;\n\n          unlink (summary_path);\n          if (summary_sig_path)\n            unlink (summary_sig_path);\n\n\n          if (!flatpak_dir_remote_clear_cached_summary (self, remote, cancellable, error))\n            return FALSE;\n\n        }\n\n      if (updated_out)\n        *updated_out = has_changed;\n\n      return TRUE;\n    }\n\n  if (!flatpak_dir_update_remote_configuration_for_state (self, state, FALSE, &has_changed, cancellable, error))\n    return FALSE;\n\n  if (has_changed &&\n      !flatpak_dir_remote_clear_cached_summary (self, remote, cancellable, error))\n    return FALSE;\n\n  if (updated_out)\n    *updated_out = has_changed;\n\n  return TRUE;\n}\n\nvoid\nflatpak_related_free (FlatpakRelated *self)\n{\n  flatpak_decomposed_unref (self->ref);\n  g_free (self->commit);\n  g_strfreev (self->subpaths);\n  g_free (self);\n}\n\nstatic void\nadd_related (FlatpakDir        *self,\n             GPtrArray         *related,\n             const char        *extension,\n             FlatpakDecomposed *extension_ref,\n             const char        *checksum,\n             gboolean           no_autodownload,\n             const char        *download_if,\n             const char        *autoprune_unless,\n             gboolean           autodelete,\n             gboolean           locale_subset)\n{\n  g_autoptr(GBytes) deploy_data = NULL;\n  g_autofree const char **old_subpaths = NULL;\n  g_autofree const char *id = NULL;\n  g_autofree const char *arch = NULL;\n  g_autofree const char *branch = NULL;\n  g_auto(GStrv) extra_subpaths = NULL;\n  g_auto(GStrv) subpaths = NULL;\n  FlatpakRelated *rel;\n  gboolean download;\n  gboolean delete = autodelete;\n  gboolean auto_prune = FALSE;\n  g_autoptr(GFile) unmaintained_path = NULL;\n\n  deploy_data = flatpak_dir_get_deploy_data (self, extension_ref, FLATPAK_DEPLOY_VERSION_ANY, NULL, NULL);\n\n  id = flatpak_decomposed_dup_id (extension_ref);\n  arch = flatpak_decomposed_dup_arch (extension_ref);\n  branch = flatpak_decomposed_dup_branch (extension_ref);\n\n  if (deploy_data)\n    old_subpaths = flatpak_deploy_data_get_subpaths (deploy_data);\n\n  /* Only respect no-autodownload/download-if for uninstalled refs, we\n     always want to update if you manually installed something */\n  download =\n    flatpak_extension_matches_reason (id, download_if, !no_autodownload) ||\n    deploy_data != NULL;\n\n  if (!flatpak_extension_matches_reason (id, autoprune_unless, TRUE))\n    auto_prune = TRUE;\n\n  /* Don't download if there is an unmaintained extension already installed */\n  unmaintained_path =\n    flatpak_find_unmaintained_extension_dir_if_exists (id, arch, branch, NULL);\n  if (unmaintained_path != NULL && deploy_data == NULL)\n    {\n      g_debug (\"Skipping related extension \u2018%s\u2019 because it is already \"\n               \"installed as an unmaintained extension in \u2018%s\u2019.\",\n               id, flatpak_file_get_path_cached (unmaintained_path));\n      download = FALSE;\n    }\n\n  if (g_str_has_suffix (extension, \".Debug\"))\n    {\n      /* debug files only updated if already installed */\n      if (deploy_data == NULL)\n        download = FALSE;\n\n      /* Always remove debug */\n      delete = TRUE;\n    }\n\n  if (g_str_has_suffix (extension, \".Locale\"))\n    locale_subset = TRUE;\n\n  if (locale_subset)\n    {\n      extra_subpaths = flatpak_dir_get_locale_subpaths (self);\n\n      /* Always remove locale */\n      delete = TRUE;\n    }\n\n  subpaths = flatpak_subpaths_merge ((char **) old_subpaths, extra_subpaths);\n\n  rel = g_new0 (FlatpakRelated, 1);\n  rel->ref = flatpak_decomposed_ref (extension_ref);\n  rel->commit = g_strdup (checksum);\n  rel->subpaths = g_steal_pointer (&subpaths);\n  rel->download = download;\n  rel->delete = delete;\n  rel->auto_prune = auto_prune;\n\n  g_ptr_array_add (related, rel);\n}\n\nstatic GRegex *\nflatpak_dir_get_mask_regexp (FlatpakDir *self)\n{\n  GRegex *res = NULL;\n\n  G_LOCK (config_cache);\n\n  if (self->masked == NULL)\n    {\n      g_autofree char *masked = NULL;\n\n      masked = flatpak_dir_get_config (self, \"masked\", NULL);\n      if (masked)\n        {\n          g_auto(GStrv) patterns = g_strsplit (masked, \";\", -1);\n          g_autoptr(GString) deny_regexp = g_string_new (\"^(\");\n          int i;\n\n          for (i = 0; patterns[i] != NULL; i++)\n            {\n              const char *pattern = patterns[i];\n\n              if (*pattern != 0)\n                {\n                  g_autofree char *regexp = NULL;\n\n                  regexp = flatpak_filter_glob_to_regexp (pattern, FALSE, NULL);\n                  if (regexp)\n                    {\n                      if (i != 0)\n                        g_string_append (deny_regexp, \"|\");\n                      g_string_append (deny_regexp, regexp);\n                    }\n                }\n            }\n\n          g_string_append (deny_regexp, \")$\");\n          self->masked = g_regex_new (deny_regexp->str, G_REGEX_DOLLAR_ENDONLY|G_REGEX_RAW|G_REGEX_OPTIMIZE, G_REGEX_MATCH_ANCHORED, NULL);\n        }\n    }\n\n  if (self->masked)\n    res = g_regex_ref (self->masked);\n\n  G_UNLOCK (config_cache);\n\n  return res;\n}\n\ngboolean\nflatpak_dir_ref_is_masked (FlatpakDir *self,\n                           const char *ref)\n{\n  g_autoptr(GRegex) masked = flatpak_dir_get_mask_regexp (self);\n\n  return !flatpak_filters_allow_ref (NULL, masked, ref);\n}\n\nstatic GRegex *\nflatpak_dir_get_pin_regexp (FlatpakDir *self)\n{\n  GRegex *res = NULL;\n\n  G_LOCK (config_cache);\n\n  if (self->pinned == NULL)\n    {\n      g_autofree char *pinned = NULL;\n\n      pinned = flatpak_dir_get_config (self, \"pinned\", NULL);\n      if (pinned)\n        {\n          g_auto(GStrv) patterns = g_strsplit (pinned, \";\", -1);\n          g_autoptr(GString) deny_regexp = g_string_new (\"^(\");\n          int i;\n\n          for (i = 0; patterns[i] != NULL; i++)\n            {\n              const char *pattern = patterns[i];\n\n              if (*pattern != 0)\n                {\n                  g_autofree char *regexp = NULL;\n\n                  regexp = flatpak_filter_glob_to_regexp (pattern,\n                                                          TRUE, /* only match runtimes */\n                                                          NULL);\n                  if (regexp)\n                    {\n                      if (i != 0)\n                        g_string_append (deny_regexp, \"|\");\n                      g_string_append (deny_regexp, regexp);\n                    }\n                }\n            }\n\n          g_string_append (deny_regexp, \")$\");\n          self->pinned = g_regex_new (deny_regexp->str, G_REGEX_DOLLAR_ENDONLY|G_REGEX_RAW|G_REGEX_OPTIMIZE, G_REGEX_MATCH_ANCHORED, NULL);\n        }\n    }\n\n  if (self->pinned)\n    res = g_regex_ref (self->pinned);\n\n  G_UNLOCK (config_cache);\n\n  return res;\n}\n\ngboolean\nflatpak_dir_ref_is_pinned (FlatpakDir *self,\n                           const char *ref)\n{\n  g_autoptr(GRegex) pinned = flatpak_dir_get_pin_regexp (self);\n\n  return !flatpak_filters_allow_ref (NULL, pinned, ref);\n}\n\nGPtrArray *\nflatpak_dir_find_remote_related_for_metadata (FlatpakDir         *self,\n                                              FlatpakRemoteState *state,\n                                              FlatpakDecomposed  *ref,\n                                              GKeyFile           *metakey,\n                                              GCancellable       *cancellable,\n                                              GError            **error)\n{\n  int i;\n  g_autoptr(GPtrArray) related = g_ptr_array_new_with_free_func ((GDestroyNotify) flatpak_related_free);\n  g_autofree char *url = NULL;\n  g_auto(GStrv) groups = NULL;\n  g_autoptr(GRegex) masked = NULL;\n  g_autofree char *ref_arch = flatpak_decomposed_dup_arch (ref);\n  g_autofree char *ref_branch = flatpak_decomposed_dup_branch (ref);\n\n  if (!ostree_repo_remote_get_url (self->repo,\n                                   state->remote_name,\n                                   &url,\n                                   error))\n    return NULL;\n\n  if (*url == 0)\n    return g_steal_pointer (&related);  /* Empty url, silently disables updates */\n\n  masked = flatpak_dir_get_mask_regexp (self);\n\n  groups = g_key_file_get_groups (metakey, NULL);\n  for (i = 0; groups[i] != NULL; i++)\n    {\n      char *tagged_extension;\n\n      if (g_str_has_prefix (groups[i], FLATPAK_METADATA_GROUP_PREFIX_EXTENSION) &&\n          *(tagged_extension = (groups[i] + strlen (FLATPAK_METADATA_GROUP_PREFIX_EXTENSION))) != 0)\n        {\n          g_autofree char *extension = NULL;\n          g_autofree char *version = g_key_file_get_string (metakey, groups[i],\n                                                            FLATPAK_METADATA_KEY_VERSION, NULL);\n          g_auto(GStrv) versions = g_key_file_get_string_list (metakey, groups[i],\n                                                               FLATPAK_METADATA_KEY_VERSIONS,\n                                                               NULL, NULL);\n          gboolean subdirectories = g_key_file_get_boolean (metakey, groups[i],\n                                                            FLATPAK_METADATA_KEY_SUBDIRECTORIES, NULL);\n          gboolean no_autodownload = g_key_file_get_boolean (metakey, groups[i],\n                                                             FLATPAK_METADATA_KEY_NO_AUTODOWNLOAD, NULL);\n          g_autofree char *download_if = g_key_file_get_string (metakey, groups[i],\n                                                                FLATPAK_METADATA_KEY_DOWNLOAD_IF, NULL);\n          g_autofree char *autoprune_unless = g_key_file_get_string (metakey, groups[i],\n                                                                     FLATPAK_METADATA_KEY_AUTOPRUNE_UNLESS, NULL);\n          gboolean autodelete = g_key_file_get_boolean (metakey, groups[i],\n                                                        FLATPAK_METADATA_KEY_AUTODELETE, NULL);\n          gboolean locale_subset = g_key_file_get_boolean (metakey, groups[i],\n                                                           FLATPAK_METADATA_KEY_LOCALE_SUBSET, NULL);\n          const char *default_branches[] = { NULL, NULL};\n          const char **branches;\n          int branch_i;\n\n          /* Parse actual extension name */\n          flatpak_parse_extension_with_tag (tagged_extension, &extension, NULL);\n\n          if (versions)\n            branches = (const char **) versions;\n          else\n            {\n              if (version)\n                default_branches[0] = version;\n              else\n                default_branches[0] = ref_branch;\n              branches = default_branches;\n            }\n\n          for (branch_i = 0; branches[branch_i] != NULL; branch_i++)\n            {\n              g_autoptr(FlatpakDecomposed) extension_ref = NULL;\n              g_autofree char *checksum = NULL;\n              const char *branch = branches[branch_i];\n\n              extension_ref = flatpak_decomposed_new_from_parts (FLATPAK_KINDS_RUNTIME,\n                                                                 extension, ref_arch, branch, NULL);\n              if (extension_ref == NULL)\n                continue;\n\n              if (flatpak_remote_state_lookup_ref (state, flatpak_decomposed_get_ref (extension_ref), &checksum, NULL, NULL, NULL, NULL))\n                {\n                  if (flatpak_filters_allow_ref (NULL, masked, flatpak_decomposed_get_ref (extension_ref)))\n                    add_related (self, related, extension, extension_ref, checksum,\n                                 no_autodownload, download_if, autoprune_unless, autodelete, locale_subset);\n                }\n              else if (subdirectories)\n                {\n                  g_autoptr(GPtrArray) subref_refs = flatpak_remote_state_match_subrefs (state, extension_ref);\n                  for (int j = 0; j < subref_refs->len; j++)\n                    {\n                      FlatpakDecomposed *subref_ref = g_ptr_array_index (subref_refs, j);\n                      g_autofree char *subref_checksum = NULL;\n\n                      if (flatpak_remote_state_lookup_ref (state, flatpak_decomposed_get_ref (subref_ref),\n                                                           &subref_checksum, NULL, NULL, NULL, NULL) &&\n                          flatpak_filters_allow_ref (NULL, masked,  flatpak_decomposed_get_ref (subref_ref)))\n                        add_related (self, related, extension, subref_ref, subref_checksum,\n                                     no_autodownload, download_if, autoprune_unless, autodelete, locale_subset);\n                    }\n                }\n            }\n        }\n    }\n\n  return g_steal_pointer (&related);\n}\n\nGPtrArray *\nflatpak_dir_find_remote_related (FlatpakDir         *self,\n                                 FlatpakRemoteState *state,\n                                 FlatpakDecomposed  *ref,\n                                 GCancellable       *cancellable,\n                                 GError            **error)\n{\n  g_autofree char *metadata = NULL;\n  g_autoptr(GKeyFile) metakey = g_key_file_new ();\n  g_autoptr(GPtrArray) related = g_ptr_array_new_with_free_func ((GDestroyNotify) flatpak_related_free);\n  g_autofree char *url = NULL;\n\n  if (!ostree_repo_remote_get_url (self->repo,\n                                   state->remote_name,\n                                   &url,\n                                   error))\n    return NULL;\n\n  if (*url == 0)\n    return g_steal_pointer (&related);  /* Empty url, silently disables updates */\n\n  if (flatpak_remote_state_load_data (state, flatpak_decomposed_get_ref (ref),\n                                      NULL, NULL, &metadata,\n                                      NULL) &&\n      g_key_file_load_from_data (metakey, metadata, -1, 0, NULL))\n    {\n      g_ptr_array_unref (related);\n      related = flatpak_dir_find_remote_related_for_metadata (self, state, ref, metakey, cancellable, error);\n    }\n\n  return g_steal_pointer (&related);\n}\n\nstatic GHashTable *\nlocal_match_prefix (FlatpakDir        *self,\n                    FlatpakDecomposed *extension_ref,\n                    const char        *remote)\n{\n  GHashTable *matches = g_hash_table_new_full ((GHashFunc)flatpak_decomposed_hash, (GEqualFunc)flatpak_decomposed_equal, (GDestroyNotify)flatpak_decomposed_unref, NULL);\n  FlatpakKinds kind;\n  g_autofree char *id = NULL;\n  g_autofree char *arch = NULL;\n  g_autofree char *branch = NULL;\n  g_autofree char *id_prefix = NULL;\n  g_autoptr(GHashTable) refs = NULL;\n  g_autofree char *list_prefix = NULL;\n  const char *kind_str;\n\n  kind = flatpak_decomposed_get_kinds (extension_ref);\n  id = flatpak_decomposed_dup_id (extension_ref);\n  arch = flatpak_decomposed_dup_arch (extension_ref);\n  branch = flatpak_decomposed_dup_branch (extension_ref);\n\n  id_prefix = g_strconcat (id, \".\", NULL);\n\n  kind_str = flatpak_decomposed_get_kind_str (extension_ref);\n\n  if (remote)\n    list_prefix = g_strdup_printf (\"%s:%s\", remote, kind_str);\n\n  if (ostree_repo_list_refs (self->repo, list_prefix, &refs, NULL, NULL))\n    {\n      GHashTableIter hash_iter;\n      gpointer key;\n\n      g_hash_table_iter_init (&hash_iter, refs);\n      while (g_hash_table_iter_next (&hash_iter, &key, NULL))\n        {\n          const char *partial_ref_and_origin = key;\n          g_autofree char *partial_ref_store = NULL;\n          const char *partial_ref;\n          g_autoptr(FlatpakDecomposed) matched = NULL;\n\n          ostree_parse_refspec (partial_ref_and_origin, NULL, &partial_ref_store, NULL);\n          if (remote == NULL)\n            {\n              /* If we're not filtering via list_prefix we need to filter by part[0] manually */\n              char *slash = strchr (partial_ref_store, '/');\n              if (slash == NULL)\n                continue;\n              *slash = 0;\n              if (strcmp (partial_ref_store, kind_str) != 0)\n                continue;\n              partial_ref = slash + 1;\n            }\n          else\n            partial_ref = partial_ref_store;\n\n          matched = flatpak_decomposed_new_from_pref (kind, partial_ref, NULL);\n          if (matched == NULL)\n            continue;\n\n          /* Must match type, arch, branch */\n          if (!flatpak_decomposed_is_arch (matched, arch) ||\n              !flatpak_decomposed_is_branch (matched, branch))\n            continue;\n\n          /* But only prefix of id */\n          if (!flatpak_decomposed_id_has_prefix (matched, id_prefix))\n            continue;\n\n          g_hash_table_add (matches, g_steal_pointer (&matched));\n        }\n    }\n\n  /* Also check deploys. In case remote-delete --force is run, we can end up\n   * with a deploy without a corresponding ref in the repo. */\n  flatpak_dir_collect_deployed_refs (self, kind_str, id_prefix, arch, branch, matches, NULL, NULL);\n\n  return matches;\n}\n\n/* Finds all the locally installed ref related to ref, if remote_name is set it is limited to refs from that remote */\nGPtrArray *\nflatpak_dir_find_local_related_for_metadata (FlatpakDir        *self,\n                                             FlatpakDecomposed *ref,\n                                             const char        *remote_name, /* nullable */\n                                             GKeyFile          *metakey,\n                                             GCancellable      *cancellable,\n                                             GError           **error)\n{\n  int i;\n  g_autoptr(GPtrArray) related = g_ptr_array_new_with_free_func ((GDestroyNotify) flatpak_related_free);\n  g_auto(GStrv) groups = NULL;\n  g_autofree char *ref_arch = flatpak_decomposed_dup_arch (ref);\n  g_autofree char *ref_branch = flatpak_decomposed_dup_branch (ref);\n\n  if (!flatpak_dir_ensure_repo (self, cancellable, error))\n    return NULL;\n\n  groups = g_key_file_get_groups (metakey, NULL);\n  for (i = 0; groups[i] != NULL; i++)\n    {\n      char *tagged_extension;\n\n      if (g_str_has_prefix (groups[i], FLATPAK_METADATA_GROUP_PREFIX_EXTENSION) &&\n          *(tagged_extension = (groups[i] + strlen (FLATPAK_METADATA_GROUP_PREFIX_EXTENSION))) != 0)\n        {\n          g_autofree char *extension = NULL;\n          g_autofree char *version = g_key_file_get_string (metakey, groups[i],\n                                                            FLATPAK_METADATA_KEY_VERSION, NULL);\n          g_auto(GStrv) versions = g_key_file_get_string_list (metakey, groups[i],\n                                                               FLATPAK_METADATA_KEY_VERSIONS,\n                                                               NULL, NULL);\n          gboolean subdirectories = g_key_file_get_boolean (metakey, groups[i],\n                                                            FLATPAK_METADATA_KEY_SUBDIRECTORIES, NULL);\n          gboolean no_autodownload = g_key_file_get_boolean (metakey, groups[i],\n                                                             FLATPAK_METADATA_KEY_NO_AUTODOWNLOAD, NULL);\n          g_autofree char *download_if = g_key_file_get_string (metakey, groups[i],\n                                                                FLATPAK_METADATA_KEY_DOWNLOAD_IF, NULL);\n          g_autofree char *autoprune_unless = g_key_file_get_string (metakey, groups[i],\n                                                                     FLATPAK_METADATA_KEY_AUTOPRUNE_UNLESS, NULL);\n          gboolean autodelete = g_key_file_get_boolean (metakey, groups[i],\n                                                        FLATPAK_METADATA_KEY_AUTODELETE, NULL);\n          gboolean locale_subset = g_key_file_get_boolean (metakey, groups[i],\n                                                           FLATPAK_METADATA_KEY_LOCALE_SUBSET, NULL);\n          const char *default_branches[] = { NULL, NULL};\n          const char **branches;\n          int branch_i;\n\n          /* Parse actual extension name */\n          flatpak_parse_extension_with_tag (tagged_extension, &extension, NULL);\n\n          if (versions)\n            branches = (const char **) versions;\n          else\n            {\n              if (version)\n                default_branches[0] = version;\n              else\n                default_branches[0] = ref_branch;\n              branches = default_branches;\n            }\n\n          for (branch_i = 0; branches[branch_i] != NULL; branch_i++)\n            {\n              g_autoptr(FlatpakDecomposed) extension_ref = NULL;\n              g_autofree char *checksum = NULL;\n              g_autoptr(GBytes) deploy_data = NULL;\n              const char *branch = branches[branch_i];\n\n              extension_ref = flatpak_decomposed_new_from_parts (FLATPAK_KINDS_RUNTIME,\n                                                                 extension, ref_arch, branch, NULL);\n              if (remote_name != NULL &&\n                  flatpak_repo_resolve_rev (self->repo,\n                                            NULL,\n                                            remote_name,\n                                            flatpak_decomposed_get_ref (extension_ref),\n                                            FALSE,\n                                            &checksum,\n                                            NULL,\n                                            NULL))\n                {\n                  add_related (self, related, extension, extension_ref,\n                               checksum, no_autodownload, download_if, autoprune_unless, autodelete, locale_subset);\n                }\n              else if ((deploy_data = flatpak_dir_get_deploy_data (self, extension_ref,\n                                                                   FLATPAK_DEPLOY_VERSION_ANY,\n                                                                   NULL, NULL)) != NULL &&\n                       (remote_name == NULL || g_strcmp0 (flatpak_deploy_data_get_origin (deploy_data), remote_name) == 0))\n                {\n                  /* Here we're including extensions that are deployed but might\n                   * not have a ref in the repo, as happens with remote-delete\n                   * --force\n                   */\n                  checksum = g_strdup (flatpak_deploy_data_get_commit (deploy_data));\n                  add_related (self, related, extension, extension_ref,\n                               checksum, no_autodownload, download_if, autoprune_unless, autodelete, locale_subset);\n                }\n              else if (subdirectories)\n                {\n                  g_autoptr(GHashTable) matches = local_match_prefix (self, extension_ref, remote_name);\n                  GLNX_HASH_TABLE_FOREACH (matches, FlatpakDecomposed *, match)\n                    {\n                      g_autofree char *match_checksum = NULL;\n                      g_autoptr(GBytes) match_deploy_data = NULL;\n\n                      if (remote_name != NULL &&\n                          flatpak_repo_resolve_rev (self->repo,\n                                                    NULL,\n                                                    remote_name,\n                                                    flatpak_decomposed_get_ref (match),\n                                                    FALSE,\n                                                    &match_checksum,\n                                                    NULL,\n                                                    NULL))\n                        {\n                          add_related (self, related, extension, match, match_checksum,\n                                       no_autodownload, download_if, autoprune_unless, autodelete, locale_subset);\n                        }\n                      else if ((match_deploy_data = flatpak_dir_get_deploy_data (self, match,\n                                                                                 FLATPAK_DEPLOY_VERSION_ANY,\n                                                                                 NULL, NULL)) != NULL &&\n                               (remote_name == NULL || g_strcmp0 (flatpak_deploy_data_get_origin (match_deploy_data), remote_name) == 0))\n                        {\n                          /* Here again we're including extensions that are deployed but might\n                           * not have a ref in the repo\n                           */\n                          match_checksum = g_strdup (flatpak_deploy_data_get_commit (match_deploy_data));\n                          add_related (self, related, extension, match, match_checksum,\n                                       no_autodownload, download_if, autoprune_unless, autodelete, locale_subset);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n  return g_steal_pointer (&related);\n}\n\n\nGPtrArray *\nflatpak_dir_find_local_related (FlatpakDir        *self,\n                                FlatpakDecomposed *ref,\n                                const char        *remote_name,\n                                gboolean           deployed,\n                                GCancellable      *cancellable,\n                                GError           **error)\n{\n  g_autoptr(GFile) deploy_dir = NULL;\n  g_autoptr(GBytes) deploy_data = NULL;\n  g_autoptr(GFile) metadata = NULL;\n  g_autofree char *metadata_contents = NULL;\n  g_autoptr(GKeyFile) metakey = g_key_file_new ();\n  g_autoptr(GPtrArray) related = NULL;\n\n  if (!flatpak_dir_ensure_repo (self, cancellable, error))\n    return NULL;\n\n  if (deployed)\n    {\n      deploy_dir = flatpak_dir_get_if_deployed (self, ref, NULL, cancellable);\n      if (deploy_dir == NULL)\n        {\n          g_set_error (error, FLATPAK_ERROR, FLATPAK_ERROR_NOT_INSTALLED,\n                       _(\"%s not installed\"), flatpak_decomposed_get_ref (ref));\n          return NULL;\n        }\n\n      deploy_data = flatpak_load_deploy_data (deploy_dir, ref, self->repo, FLATPAK_DEPLOY_VERSION_ANY, cancellable, error);\n      if (deploy_data == NULL)\n        return NULL;\n\n      metadata = g_file_get_child (deploy_dir, \"metadata\");\n      if (!g_file_load_contents (metadata, cancellable, &metadata_contents, NULL, NULL, NULL))\n        {\n          g_debug (\"No metadata in local deploy\");\n          /* No metadata => no related, but no error */\n        }\n    }\n  else\n    {\n      g_autofree char *checksum = NULL;\n      g_autoptr(GVariant) commit_data = flatpak_dir_read_latest_commit (self, remote_name, ref, &checksum, NULL, NULL);\n      if (commit_data)\n        {\n          g_autoptr(GVariant) commit_metadata = g_variant_get_child_value (commit_data, 0);\n          g_variant_lookup (commit_metadata, \"xa.metadata\", \"s\", &metadata_contents);\n          if (metadata_contents == NULL)\n            g_debug (\"No xa.metadata in local commit %s ref %s\", checksum, flatpak_decomposed_get_ref (ref));\n        }\n    }\n\n  if (metadata_contents &&\n      g_key_file_load_from_data (metakey, metadata_contents, -1, 0, NULL))\n    related = flatpak_dir_find_local_related_for_metadata (self, ref, remote_name, metakey, cancellable, error);\n  else\n    related = g_ptr_array_new_with_free_func ((GDestroyNotify) flatpak_related_free);\n\n  return g_steal_pointer (&related);\n}\n\nFlatpakDecomposed *\nflatpak_dir_get_remote_auto_install_authenticator_ref (FlatpakDir         *self,\n                                                        const char         *remote_name)\n{\n  g_autofree char *authenticator_name = NULL;\n  g_autoptr(FlatpakDecomposed) ref = NULL;\n\n  authenticator_name = flatpak_dir_get_remote_install_authenticator_name (self, remote_name);\n  if (authenticator_name != NULL)\n    {\n      g_autoptr(GError) local_error = NULL;\n      ref = flatpak_decomposed_new_from_parts (FLATPAK_KINDS_APP, authenticator_name, flatpak_get_arch (), \"autoinstall\", &local_error);\n      if (ref == NULL)\n        g_debug (\"Invalid authenticator ref: %s\\n\", local_error->message);\n    }\n\n  return g_steal_pointer (&ref);\n}\n\n\nstatic GDBusProxy *\nget_localed_dbus_proxy (void)\n{\n  const char *localed_bus_name = \"org.freedesktop.locale1\";\n  const char *localed_object_path = \"/org/freedesktop/locale1\";\n  const char *localed_interface_name = localed_bus_name;\n\n  return g_dbus_proxy_new_for_bus_sync (G_BUS_TYPE_SYSTEM,\n                                        G_DBUS_PROXY_FLAGS_NONE,\n                                        NULL,\n                                        localed_bus_name,\n                                        localed_object_path,\n                                        localed_interface_name,\n                                        NULL,\n                                        NULL);\n}\n\nstatic void\nget_locale_langs_from_localed_dbus (GDBusProxy *proxy, GPtrArray *langs)\n{\n  g_autoptr(GVariant) locale_variant = NULL;\n  g_autofree const gchar **strv = NULL;\n  gsize i, j;\n\n  locale_variant = g_dbus_proxy_get_cached_property (proxy, \"Locale\");\n  if (locale_variant == NULL)\n    return;\n\n  strv = g_variant_get_strv (locale_variant, NULL);\n\n  for (i = 0; strv[i]; i++)\n    {\n      const gchar *locale = NULL;\n      g_autofree char *lang = NULL;\n\n      /* See locale(7) for these categories */\n      const char * const categories[] = { \"LANG=\", \"LC_ALL=\", \"LC_MESSAGES=\", \"LC_ADDRESS=\",\n                                          \"LC_COLLATE=\", \"LC_CTYPE=\", \"LC_IDENTIFICATION=\",\n                                          \"LC_MONETARY=\", \"LC_MEASUREMENT=\", \"LC_NAME=\",\n                                          \"LC_NUMERIC=\", \"LC_PAPER=\", \"LC_TELEPHONE=\",\n                                          \"LC_TIME=\", NULL };\n\n      for (j = 0; categories[j]; j++)\n        {\n          if (g_str_has_prefix (strv[i], categories[j]))\n            {\n              locale = strv[i] + strlen (categories[j]);\n              break;\n            }\n        }\n\n      if (locale == NULL || strcmp (locale, \"\") == 0)\n        continue;\n\n      lang = flatpak_get_lang_from_locale (locale);\n      if (lang != NULL && !flatpak_g_ptr_array_contains_string (langs, lang))\n        g_ptr_array_add (langs, g_steal_pointer (&lang));\n    }\n}\n\nstatic GDBusProxy *\nget_accounts_dbus_proxy (void)\n{\n  const char *accounts_bus_name = \"org.freedesktop.Accounts\";\n  const char *accounts_object_path = \"/org/freedesktop/Accounts\";\n  const char *accounts_interface_name = accounts_bus_name;\n\n  return g_dbus_proxy_new_for_bus_sync (G_BUS_TYPE_SYSTEM,\n                                        G_DBUS_PROXY_FLAGS_NONE,\n                                        NULL,\n                                        accounts_bus_name,\n                                        accounts_object_path,\n                                        accounts_interface_name,\n                                        NULL,\n                                        NULL);\n}\n\nstatic void\nget_locale_langs_from_accounts_dbus (GDBusProxy *proxy, GPtrArray *langs)\n{\n  const char *accounts_bus_name = \"org.freedesktop.Accounts\";\n  const char *accounts_interface_name = \"org.freedesktop.Accounts.User\";\n  g_auto(GStrv) object_paths = NULL;\n  int i;\n  g_autoptr(GVariant) ret = NULL;\n\n  ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),\n                                \"ListCachedUsers\",\n                                g_variant_new (\"()\"),\n                                G_DBUS_CALL_FLAGS_NONE,\n                                -1,\n                                NULL,\n                                NULL);\n  if (ret != NULL)\n    g_variant_get (ret,\n                   \"(^ao)\",\n                   &object_paths);\n\n  if (object_paths != NULL)\n    {\n      for (i = 0; object_paths[i] != NULL; i++)\n        {\n          g_autoptr(GDBusProxy) accounts_proxy = NULL;\n          g_autoptr(GVariant) value = NULL;\n\n          accounts_proxy = g_dbus_proxy_new_for_bus_sync (G_BUS_TYPE_SYSTEM,\n                                                          G_DBUS_PROXY_FLAGS_NONE,\n                                                          NULL,\n                                                          accounts_bus_name,\n                                                          object_paths[i],\n                                                          accounts_interface_name,\n                                                          NULL,\n                                                          NULL);\n\n          if (accounts_proxy)\n            {\n              value = g_dbus_proxy_get_cached_property (accounts_proxy, \"Language\");\n              if (value != NULL)\n                {\n                  const char *locale = g_variant_get_string (value, NULL);\n                  g_autofree char *lang = NULL;\n\n                  if (strcmp (locale, \"\") == 0)\n                    continue; /* This user wants the system default locale */\n\n                  lang = flatpak_get_lang_from_locale (locale);\n                  if (lang != NULL && !flatpak_g_ptr_array_contains_string (langs, lang))\n                    g_ptr_array_add (langs, g_steal_pointer (&lang));\n                }\n            }\n        }\n    }\n}\n\nstatic int\ncmpstringp (const void *p1, const void *p2)\n{\n  return strcmp (*(char * const *) p1, *(char * const *) p2);\n}\n\nstatic char **\nsort_strv (char **strv)\n{\n  qsort (strv, g_strv_length (strv), sizeof (const char *), cmpstringp);\n  return strv;\n}\n\nstatic char **\nflatpak_dir_get_config_strv (FlatpakDir *self, char *key) \n{\n  GKeyFile *config = flatpak_dir_get_repo_config (self);\n  g_auto(GStrv) lang = NULL;\n\n  if (config)\n    {\n      if (g_key_file_has_key (config, \"core\", key, NULL))\n        {\n          lang = g_key_file_get_string_list (config, \"core\", key, NULL, NULL);\n          return g_steal_pointer (&lang);\n        }\n    }\n  return NULL;\n}\n\nstatic const GPtrArray *\nget_system_locales (FlatpakDir *self)\n{\n  static GPtrArray *cached = NULL;\n\n  if (g_once_init_enter (&cached))\n    {\n      GPtrArray *langs = g_ptr_array_new_with_free_func (g_free);\n      g_autoptr(GDBusProxy) localed_proxy = NULL;\n      g_autoptr(GDBusProxy) accounts_proxy = NULL;\n\n      /* Get the system default locales */\n      localed_proxy = get_localed_dbus_proxy ();\n      if (localed_proxy != NULL)\n        get_locale_langs_from_localed_dbus (localed_proxy, langs);\n\n      /* Now add the user account locales from AccountsService. If accounts_proxy is\n       * not NULL, it means that AccountsService exists */\n      accounts_proxy = get_accounts_dbus_proxy ();\n      if (accounts_proxy != NULL)\n        get_locale_langs_from_accounts_dbus (accounts_proxy, langs);\n\n      g_ptr_array_add (langs, NULL);\n\n      g_once_init_leave (&cached, langs);\n    }\n\n  return (const GPtrArray *)cached;\n}\n\nchar **\nflatpak_dir_get_default_locales (FlatpakDir *self)\n{\n  g_auto(GStrv) extra_languages = NULL;\n  const GPtrArray *langs;\n\n  extra_languages = flatpak_dir_get_config_strv (self, \"xa.extra-languages\");\n\n  if (flatpak_dir_is_user (self))\n    {\n      g_auto(GStrv) locale_langs = flatpak_get_current_locale_langs ();\n\n      return sort_strv (flatpak_strv_merge (extra_languages, locale_langs));\n    }\n\n  /* Then get the system default locales */\n  langs = get_system_locales (self);\n\n  return sort_strv (flatpak_strv_merge (extra_languages, (char **) langs->pdata));\n}\n\nchar **\nflatpak_dir_get_default_locale_languages (FlatpakDir *self)\n{\n  g_auto(GStrv) extra_languages = NULL;\n  const GPtrArray *langs;\n  int i;\n\n  extra_languages = flatpak_dir_get_config_strv (self, \"xa.extra-languages\");\n  for (i = 0; extra_languages != NULL && extra_languages[i] != NULL; i++)\n    {\n      /* Strip the locale, modifier or codeset, if present. */\n      gchar *match = strpbrk (extra_languages[i], \"._@\");\n      if (match != NULL)\n        *match = '\\0';\n    }\n\n  if (flatpak_dir_is_user (self))\n    {\n      g_auto(GStrv) locale_langs = flatpak_get_current_locale_langs ();\n\n      return sort_strv (flatpak_strv_merge (extra_languages, locale_langs));\n    }\n\n  /* Then get the system default locales */\n  langs = get_system_locales (self);\n\n  return sort_strv (flatpak_strv_merge (extra_languages, (char **) langs->pdata));\n}\n\nchar **\nflatpak_dir_get_locales (FlatpakDir *self)\n{\n  char **langs = NULL;\n\n  /* Fetch the list of languages specified by xa.languages - if this key is empty,\n   * this would mean that all languages are accepted. You can read the man for the\n   * flatpak-config section for more info.\n   */\n  langs = flatpak_dir_get_config_strv (self, \"xa.languages\");\n  if (langs)\n    return sort_strv (langs);\n\n  return flatpak_dir_get_default_locales (self);\n}\n\n\nchar **\nflatpak_dir_get_locale_languages (FlatpakDir *self)\n{\n  char **langs = NULL;\n\n  /* Fetch the list of languages specified by xa.languages - if this key is empty,\n   * this would mean that all languages are accepted. You can read the man for the\n   * flatpak-config section for more info.\n   */\n  langs = flatpak_dir_get_config_strv (self, \"xa.languages\");\n  if (langs)\n    return sort_strv (langs);\n\n  return flatpak_dir_get_default_locale_languages (self);\n}\n\nchar **\nflatpak_dir_get_locale_subpaths (FlatpakDir *self)\n{\n  char **subpaths = flatpak_dir_get_locale_languages (self);\n  int i;\n\n  /* Convert languages to paths */\n  for (i = 0; subpaths[i] != NULL; i++)\n    {\n      char *lang = subpaths[i];\n      /* For backwards compat with old xa.languages we support the configuration having slashes already */\n      if (*lang != '/')\n        {\n          subpaths[i] = g_strconcat (\"/\", lang, NULL);\n          g_free (lang);\n        }\n    }\n  return subpaths;\n}\n\nvoid\nflatpak_dir_set_source_pid (FlatpakDir *self,\n                            pid_t       pid)\n{\n  self->source_pid = pid;\n}\n\npid_t\nflatpak_dir_get_source_pid (FlatpakDir *self)\n{\n  return self->source_pid;\n}\n\nstatic void\n  (flatpak_dir_log) (FlatpakDir * self,\n                     const char *file,\n                     int line,\n                     const char *func,\n                     const char *source, /* overrides self->name */\n                     const char *change,\n                     const char *remote,\n                     const char *ref,\n                     const char *commit,\n                     const char *old_commit,\n                     const char *url,\n                     const char *format,\n                     ...)\n{\n#ifdef HAVE_LIBSYSTEMD\n  const char *installation = source ? source : flatpak_dir_get_name_cached (self);\n  pid_t source_pid = flatpak_dir_get_source_pid (self);\n  char message[1024];\n  int len;\n  va_list args;\n\n  len = g_snprintf (message, sizeof (message), \"%s: \", installation);\n\n  va_start (args, format);\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wformat-nonliteral\"\n  g_vsnprintf (message + len, sizeof (message) - len, format, args);\n#pragma GCC diagnostic pop\n\n  va_end (args);\n\n  /* See systemd.journal-fields(7) for the meaning of the\n   * standard fields we use, in particular OBJECT_PID\n   */\n  sd_journal_send (\"MESSAGE_ID=\" FLATPAK_MESSAGE_ID,\n                   \"PRIORITY=5\",\n                   \"OBJECT_PID=%d\", source_pid,\n                   \"CODE_FILE=%s\", file,\n                   \"CODE_LINE=%d\", line,\n                   \"CODE_FUNC=%s\", func,\n                   \"MESSAGE=%s\", message,\n                   /* custom fields below */\n                   \"FLATPAK_VERSION=\" PACKAGE_VERSION,\n                   \"INSTALLATION=%s\", installation,\n                   \"OPERATION=%s\", change,\n                   \"REMOTE=%s\", remote ? remote : \"\",\n                   \"REF=%s\", ref ? ref : \"\",\n                   \"COMMIT=%s\", commit ? commit : \"\",\n                   \"OLD_COMMIT=%s\", old_commit ? old_commit : \"\",\n                   \"URL=%s\", url ? url : \"\",\n                   NULL);\n#endif\n}\n\n/* Delete refs that are in refs/mirrors/ rather than refs/remotes/ to prevent\n * disk space from leaking. See https://github.com/flatpak/flatpak/issues/3222\n * The caller is responsible for ensuring that @dir has a repo, and for pruning\n * the repo after calling this function to actually free the disk space.\n */\ngboolean\nflatpak_dir_delete_mirror_refs (FlatpakDir    *self,\n                                gboolean       dry_run,\n                                GCancellable  *cancellable,\n                                GError       **error)\n{\n  g_autoptr(GHashTable) collection_refs = NULL;  /* (element-type OstreeCollectionRef utf8) */\n  g_autoptr(GPtrArray) ignore_collections = g_ptr_array_new_with_free_func (g_free); /* (element-type utf8) */\n  g_auto(GStrv) remotes = NULL;\n  const char *repo_collection_id;\n  OstreeRepo *repo;\n  int i;\n\n  /* Generally a flatpak repo should not have its own collection ID set, but\n   * check just in case flatpak is being run on a server for some reason. When\n   * a repo has a collection ID set, its own refs from refs/heads/ will be\n   * listed by the ostree_repo_list_collection_refs() call below, and we need\n   * to be sure not to delete them. There would be no reason to install from a\n   * server to itself, so we don't expect refs matching repo_collection_id to\n   * be in refs/mirrors/.\n   */\n  repo = flatpak_dir_get_repo (self);\n  repo_collection_id = ostree_repo_get_collection_id (repo);\n  if (repo_collection_id != NULL)\n    g_ptr_array_add (ignore_collections, g_strdup (repo_collection_id));\n\n  /* Check also for any disabled remotes and ignore any associated\n   * collection-refs; in the case of Endless this would be the remote used for\n   * OS updates which Flatpak shouldn't touch.\n   */\n  remotes = ostree_repo_remote_list (repo, NULL);\n  for (i = 0; remotes != NULL && remotes[i] != NULL; i++)\n    {\n      g_autofree char *remote_collection_id = NULL;\n\n      if (!flatpak_dir_get_remote_disabled (self, remotes[i]))\n        continue;\n      remote_collection_id = flatpak_dir_get_remote_collection_id (self, remotes[i]);\n      if (remote_collection_id != NULL)\n        g_ptr_array_add (ignore_collections, g_steal_pointer (&remote_collection_id));\n    }\n  g_ptr_array_add (ignore_collections, NULL);\n\n  if (!ostree_repo_list_collection_refs (repo, NULL, &collection_refs,\n                                         OSTREE_REPO_LIST_REFS_EXT_EXCLUDE_REMOTES,\n                                         cancellable, error))\n    return FALSE;\n\n  /* Now delete any collection-refs which are in refs/mirrors/, were created by\n   * Flatpak, and don't belong to a disabled remote.\n   */\n  GLNX_HASH_TABLE_FOREACH (collection_refs, const OstreeCollectionRef *, c_r)\n    {\n      if (g_strv_contains ((const char * const *)ignore_collections->pdata, c_r->collection_id))\n        {\n          g_debug (\"Ignoring collection-ref (%s, %s) since its remote is disabled or it matches the repo collection ID\",\n                   c_r->collection_id, c_r->ref_name);\n          continue;\n        }\n\n      /* Only delete refs which Flatpak created; the repo may have other\n       * users. We could check only for refs that come from configured\n       * remotes, but that would not cover the case of if a remote was\n       * deleted.\n       */\n      if (g_str_has_prefix (c_r->ref_name, \"app/\") ||\n          g_str_has_prefix (c_r->ref_name, \"runtime/\") ||\n          g_str_has_prefix (c_r->ref_name, \"appstream/\") ||\n          g_str_has_prefix (c_r->ref_name, \"appstream2/\") ||\n          g_strcmp0 (c_r->ref_name, OSTREE_REPO_METADATA_REF) == 0)\n        {\n          if (dry_run)\n            g_print (_(\"Skipping deletion of mirror ref (%s, %s)\u2026\\n\"), c_r->collection_id, c_r->ref_name);\n          else\n            {\n              if (!ostree_repo_set_collection_ref_immediate (repo, c_r, NULL, cancellable, error))\n                return FALSE;\n            }\n        }\n    }\n\n  return TRUE;\n}\n\n\nstatic gboolean\ndir_get_metadata (FlatpakDir        *dir,\n                  FlatpakDecomposed *ref,\n                  GKeyFile         **out_metakey)\n{\n  g_autoptr(GFile) deploy_dir = NULL;\n  g_autoptr(GKeyFile) metakey = NULL;\n  g_autoptr(GFile) metadata = NULL;\n  g_autofree char *metadata_contents = NULL;\n  gsize metadata_size;\n\n  deploy_dir = flatpak_dir_get_if_deployed (dir, ref, NULL, NULL);\n  if (deploy_dir == NULL)\n    return FALSE;\n\n  metadata = g_file_get_child (deploy_dir, \"metadata\");\n  if (!g_file_load_contents (metadata, NULL, &metadata_contents, &metadata_size, NULL, NULL))\n    return FALSE;\n\n  metakey = g_key_file_new ();\n  if (!g_key_file_load_from_data (metakey, metadata_contents, metadata_size, 0, NULL))\n    return FALSE;\n\n  *out_metakey = g_steal_pointer (&metakey);\n\n  return TRUE;\n}\n\nstatic gboolean\nmaybe_get_metakey (FlatpakDir        *dir,\n                   FlatpakDir        *shadowing_dir,\n                   FlatpakDecomposed *ref,\n                   GHashTable        *metadata_injection,\n                   GKeyFile         **out_metakey,\n                   gboolean          *out_ref_is_shadowed)\n{\n  if (shadowing_dir &&\n      dir_get_metadata (shadowing_dir, ref, out_metakey))\n    {\n      *out_ref_is_shadowed = TRUE;\n      return TRUE;\n    }\n\n  if (metadata_injection != NULL)\n    {\n      GKeyFile *injected_metakey = g_hash_table_lookup (metadata_injection, flatpak_decomposed_get_ref (ref));\n      if (injected_metakey != NULL)\n        {\n          *out_ref_is_shadowed = FALSE;\n          *out_metakey = g_key_file_ref (injected_metakey);\n          return TRUE;\n        }\n    }\n\n  if (dir_get_metadata (dir, ref, out_metakey))\n    {\n      *out_ref_is_shadowed = FALSE;\n      return TRUE;\n    }\n\n  return FALSE;\n}\n\nstatic void\nqueue_ref_for_analysis (FlatpakDecomposed *ref,\n                        const char *arch,\n                        GHashTable *analyzed_refs,\n                        GQueue     *refs_to_analyze)\n{\n  if (arch != NULL && !flatpak_decomposed_is_arch (ref, arch))\n    return;\n\n  if (g_hash_table_lookup (analyzed_refs, ref) != NULL)\n    return;\n\n  g_hash_table_add (analyzed_refs, flatpak_decomposed_ref (ref));\n  g_queue_push_tail (refs_to_analyze, ref); /* owned by analyzed_refs */\n}\n\n/* This traverses from all the \"root\" refs and into for any recursive dependencies in @self\n * that they use. In the regular case we just consider the @self installation,\n * but we can also handle the case where another directory \"shadows\" self. For example\n * we might be looking for used refs in the \"system\" dir, and the \"user\" dir is\n * shadowing it, meaning that if a ref is installed in the user dir it is considered used\n * from there instead of @self. So, analyzed refs from @shadowing_dir are *not* put\n * in @used_ref (although their dependencies may).\n *\n * Notes:\n *  The \"root\" refs come from @shadowing_dir if not %NULL and @self otherwise.\n *  refs_to_exclude, and metadata_injection both only affect @self, not @shadowing_dir\n */\nstatic GHashTable *\nfind_used_refs (FlatpakDir         *self,\n                FlatpakDir         *shadowing_dir, /* nullable */\n                const char         *arch,\n                GHashTable         *metadata_injection,\n                GHashTable         *refs_to_exclude,\n                GHashTable         *used_refs, /* This is filled in */\n                GCancellable       *cancellable,\n                GError            **error)\n{\n  g_autoptr(GPtrArray) root_app_refs = NULL;\n  g_autoptr(GPtrArray) root_runtime_refs = NULL;\n  g_autoptr(GHashTable) analyzed_refs = NULL;\n  g_autoptr(GQueue) refs_to_analyze = NULL;\n  FlatpakDir *root_ref_dir;\n  FlatpakDecomposed *ref_to_analyze;\n\n  refs_to_analyze = g_queue_new ();\n  analyzed_refs = g_hash_table_new_full ((GHashFunc)flatpak_decomposed_hash, (GEqualFunc)flatpak_decomposed_equal, (GDestroyNotify)flatpak_decomposed_unref, NULL);\n\n  if (shadowing_dir)\n    root_ref_dir = shadowing_dir;\n  else\n    root_ref_dir = self;\n\n  root_app_refs = flatpak_dir_list_refs (root_ref_dir, FLATPAK_KINDS_APP, cancellable, error);\n  if (root_app_refs == NULL)\n    return NULL;\n\n  for (int i = 0; i < root_app_refs->len; i++)\n    {\n      FlatpakDecomposed *root_app_ref = g_ptr_array_index (root_app_refs, i);\n      queue_ref_for_analysis (root_app_ref, arch, analyzed_refs, refs_to_analyze);\n    }\n\n  root_runtime_refs = flatpak_dir_list_refs (root_ref_dir, FLATPAK_KINDS_RUNTIME, cancellable, error);\n  if (root_runtime_refs == NULL)\n    return NULL;\n\n  for (int i = 0; i < root_runtime_refs->len; i++)\n    {\n      FlatpakDecomposed *root_runtime_ref = g_ptr_array_index (root_runtime_refs, i);\n      /* Consider all shadow dir runtimes as roots because we don't really do full analysis for shadowing_dir.\n       * For example a system installed app could end up using the user version of a runtime, which in turn\n       * uses a system gl extension.\n       *\n       * However, for non-shadowed runtime refs, only pinned ones are roots */\n      if (root_ref_dir == shadowing_dir ||\n          flatpak_dir_ref_is_pinned (root_ref_dir, flatpak_decomposed_get_ref (root_runtime_ref)))\n        queue_ref_for_analysis (root_runtime_ref, arch, analyzed_refs, refs_to_analyze);\n    }\n\n  /* Any injected refs are considered used, because this is used by transaction\n   * to emulate installing a new ref, and we never want the new ref:s dependencies\n   * seem ununsed. */\n  if (metadata_injection)\n    {\n      GLNX_HASH_TABLE_FOREACH (metadata_injection, const char *, injected_ref)\n        {\n          g_autoptr(FlatpakDecomposed) injected = flatpak_decomposed_new_from_ref (injected_ref, NULL);\n          if (injected)\n            queue_ref_for_analysis (injected, arch, analyzed_refs, refs_to_analyze);\n        }\n    }\n\n  while ((ref_to_analyze = g_queue_pop_head (refs_to_analyze)) != NULL)\n    {\n      g_autoptr(GKeyFile) metakey = NULL;\n      gboolean ref_is_shadowed;\n      gboolean is_app;\n      g_autoptr(GPtrArray) related = NULL;\n      g_autofree char *sdk = NULL;\n\n      if (!maybe_get_metakey (self, shadowing_dir, ref_to_analyze, metadata_injection,\n                              &metakey, &ref_is_shadowed))\n        continue; /* Something used something we could not find, that is fine and happens for instance with sdk dependencies */\n\n      if (!ref_is_shadowed)\n        {\n          /* Mark the analyzed ref used as it wasn't shadowed */\n          if (!g_hash_table_contains (used_refs, ref_to_analyze))\n            g_hash_table_add (used_refs, flatpak_decomposed_ref (ref_to_analyze));\n\n          /* For excluded refs we mark them as used (above) so that they don't get listed as\n           * unused, but we don't analyze them for any dependencies. Note that refs_to_exclude only\n           * affects the base dir, so does not affect shadowed refs */\n          if (refs_to_exclude != NULL && g_hash_table_contains (refs_to_exclude, ref_to_analyze))\n            continue;\n        }\n\n      /************************************************\n       * Find all dependencies and queue for analysis *\n       ***********************************************/\n\n      is_app = flatpak_decomposed_is_app (ref_to_analyze);\n\n      /* App directly depends on its runtime */\n      if (is_app)\n        {\n          g_autofree char *runtime = g_key_file_get_string (metakey, \"Application\", \"runtime\", NULL);\n          if (runtime)\n            {\n              g_autoptr(FlatpakDecomposed) runtime_ref = flatpak_decomposed_new_from_pref (FLATPAK_KINDS_RUNTIME, runtime, NULL);\n              if (runtime_ref && !flatpak_decomposed_equal (runtime_ref, ref_to_analyze))\n                queue_ref_for_analysis (runtime_ref, arch, analyzed_refs, refs_to_analyze);\n            }\n        }\n\n      /* Both apps and runtims directly depends on its sdk, to avoid suddenly uninstalling something you use to develop the app */\n      sdk = g_key_file_get_string (metakey, is_app ? \"Application\" : \"Runtime\", \"sdk\", NULL);\n      if (sdk)\n        {\n          g_autoptr(FlatpakDecomposed) sdk_ref = flatpak_decomposed_new_from_pref (FLATPAK_KINDS_RUNTIME, sdk, NULL);\n          if (sdk_ref && !flatpak_decomposed_equal (sdk_ref, ref_to_analyze))\n            queue_ref_for_analysis (sdk_ref, arch, analyzed_refs, refs_to_analyze);\n        }\n\n      /* Extensions with extra data, that are not specially marked NoRuntime needs the runtime at install.\n       * Lets keep it around to not re-download it next update */\n      if (!is_app &&\n          g_key_file_has_group (metakey, \"Extra Data\") &&\n          !g_key_file_get_boolean (metakey, \"Extra Data\", \"NoRuntime\", NULL))\n        {\n          g_autofree char *extension_runtime_ref = g_key_file_get_string (metakey, \"ExtensionOf\", \"runtime\", NULL);\n          if (extension_runtime_ref != NULL)\n            {\n              g_autoptr(FlatpakDecomposed) d = flatpak_decomposed_new_from_ref (extension_runtime_ref, NULL);\n              if (d)\n                queue_ref_for_analysis (d, arch, analyzed_refs, refs_to_analyze);\n            }\n        }\n\n      /* We pass NULL for remote-name here, because we want to consider related refs from all remotes */\n      related = flatpak_dir_find_local_related_for_metadata (self, ref_to_analyze,\n                                                             NULL, metakey, NULL, NULL);\n      for (int i = 0; related != NULL && i < related->len; i++)\n        {\n          FlatpakRelated *rel = g_ptr_array_index (related, i);\n\n          if (!rel->auto_prune)\n            {\n              queue_ref_for_analysis (rel->ref, arch, analyzed_refs, refs_to_analyze);\n            }\n        }\n    }\n\n  return g_steal_pointer (&used_refs);\n}\n\n/* See the documentation for\n * flatpak_installation_list_unused_refs_with_options().\n * The returned pointer array is transfer full. */\nchar **\nflatpak_dir_list_unused_refs (FlatpakDir         *self,\n                              const char         *arch,\n                              GHashTable         *metadata_injection,\n                              GHashTable         *eol_injection,\n                              const char * const *refs_to_exclude,\n                              gboolean            filter_by_eol,\n                              GCancellable       *cancellable,\n                              GError            **error)\n{\n  g_autoptr(GHashTable) used_refs = NULL;\n  g_autoptr(GHashTable) excluded_refs_ht = NULL;\n  g_autoptr(GPtrArray) refs =  NULL;\n  g_autoptr(GPtrArray) runtime_refs = NULL;\n\n  /* Convert refs_to_exclude to hashtable for fast repeated lookups */\n  if (refs_to_exclude)\n    {\n      excluded_refs_ht = g_hash_table_new_full ((GHashFunc)flatpak_decomposed_hash, (GEqualFunc)flatpak_decomposed_equal, (GDestroyNotify)flatpak_decomposed_unref, NULL);\n      for (int i = 0; refs_to_exclude[i] != NULL; i++)\n        {\n          const char *ref_to_exclude = refs_to_exclude[i];\n          g_autoptr(FlatpakDecomposed) d = flatpak_decomposed_new_from_ref (ref_to_exclude, NULL);\n          if (d)\n            g_hash_table_add (excluded_refs_ht, flatpak_decomposed_ref (d));\n        }\n    }\n\n  used_refs = g_hash_table_new_full ((GHashFunc)flatpak_decomposed_hash, (GEqualFunc)flatpak_decomposed_equal, (GDestroyNotify)flatpak_decomposed_unref, NULL);\n\n  if (!find_used_refs (self, NULL, arch, metadata_injection, excluded_refs_ht,\n                       used_refs, cancellable, error))\n    return NULL;\n\n  /* If @self is a system installation, also check the per-user installation\n   * for any apps there using runtimes in the system installation or runtimes\n   * there with sdks or extensions in the system installation. Only do so if\n   * the per-user installation exists; it wouldn't make sense to create it here\n   * if not.\n   */\n  if (!flatpak_dir_is_user (self))\n    {\n      g_autoptr(FlatpakDir) user_dir = flatpak_dir_get_user ();\n      g_autoptr(GError) local_error = NULL;\n\n      if (!find_used_refs (self, user_dir, arch, metadata_injection, excluded_refs_ht,\n                           used_refs, cancellable, &local_error))\n        {\n          /* We may get permission denied if the process is sandboxed with\n           * systemd's ProtectHome=\n           */\n          if (!g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND) &&\n              !g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_PERMISSION_DENIED))\n            {\n              g_propagate_error (error, g_steal_pointer (&local_error));\n              return NULL;\n            }\n        }\n    }\n\n  runtime_refs = flatpak_dir_list_refs (self, FLATPAK_KINDS_RUNTIME, cancellable, error);\n  if (runtime_refs == NULL)\n    return NULL;\n\n  refs = g_ptr_array_new_with_free_func (g_free);\n\n  for (int i = 0; i < runtime_refs->len; i++)\n    {\n      FlatpakDecomposed *ref = g_ptr_array_index (runtime_refs, i);\n\n      if (g_hash_table_contains (used_refs, ref))\n        continue;\n\n      if (arch != NULL && !flatpak_decomposed_is_arch (ref, arch))\n        continue;\n\n      if (filter_by_eol)\n        {\n          gboolean is_eol = FALSE;\n\n          if (eol_injection && g_hash_table_contains (eol_injection, flatpak_decomposed_get_ref (ref)))\n            {\n              is_eol = GPOINTER_TO_INT (g_hash_table_lookup (eol_injection, ref));\n            }\n          else\n            {\n              g_autoptr(GBytes) deploy_data = NULL;\n\n              /* deploy v4 guarantees eol/eolr info */\n              deploy_data = flatpak_dir_get_deploy_data (self, ref, 4,\n                                                         cancellable, NULL);\n              is_eol = deploy_data != NULL &&\n                (flatpak_deploy_data_get_eol (deploy_data) != NULL ||\n                 flatpak_deploy_data_get_eol_rebase (deploy_data));\n            }\n\n          if (!is_eol)\n            continue;\n        }\n\n      g_ptr_array_add (refs, flatpak_decomposed_dup_ref (ref));\n    }\n\n  g_ptr_array_add (refs, NULL);\n  return (char **)g_ptr_array_free (g_steal_pointer (&refs), FALSE);\n}\n"], "filenames": ["common/flatpak-dir.c"], "buggy_code_start_loc": [7141], "buggy_code_end_loc": [7141], "fixing_code_start_loc": [7142], "fixing_code_end_loc": [7144], "type": "CWE-74", "message": "Flatpak is a system for building, distributing, and running sandboxed desktop applications on Linux. In Flatpack since version 0.9.4 and before version 1.10.2 has a vulnerability in the \"file forwarding\" feature which can be used by an attacker to gain access to files that would not ordinarily be allowed by the app's permissions. By putting the special tokens `@@` and/or `@@u` in the Exec field of a Flatpak app's .desktop file, a malicious app publisher can trick flatpak into behaving as though the user had chosen to open a target file with their Flatpak app, which automatically makes that file available to the Flatpak app. This is fixed in version 1.10.2. A minimal solution is the first commit \"`Disallow @@ and @@U usage in desktop files`\". The follow-up commits \"`dir: Reserve the whole @@ prefix`\" and \"`dir: Refuse to export .desktop files with suspicious uses of @@ tokens`\" are recommended, but not strictly required. As a workaround, avoid installing Flatpak apps from untrusted sources, or check the contents of the exported `.desktop` files in `exports/share/applications/*.desktop` (typically `~/.local/share/flatpak/exports/share/applications/*.desktop` and `/var/lib/flatpak/exports/share/applications/*.desktop`) to make sure that literal filenames do not follow `@@` or `@@u`.", "other": {"cve": {"id": "CVE-2021-21381", "sourceIdentifier": "security-advisories@github.com", "published": "2021-03-11T17:15:12.703", "lastModified": "2021-03-25T00:01:39.813", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Flatpak is a system for building, distributing, and running sandboxed desktop applications on Linux. In Flatpack since version 0.9.4 and before version 1.10.2 has a vulnerability in the \"file forwarding\" feature which can be used by an attacker to gain access to files that would not ordinarily be allowed by the app's permissions. By putting the special tokens `@@` and/or `@@u` in the Exec field of a Flatpak app's .desktop file, a malicious app publisher can trick flatpak into behaving as though the user had chosen to open a target file with their Flatpak app, which automatically makes that file available to the Flatpak app. This is fixed in version 1.10.2. A minimal solution is the first commit \"`Disallow @@ and @@U usage in desktop files`\". The follow-up commits \"`dir: Reserve the whole @@ prefix`\" and \"`dir: Refuse to export .desktop files with suspicious uses of @@ tokens`\" are recommended, but not strictly required. As a workaround, avoid installing Flatpak apps from untrusted sources, or check the contents of the exported `.desktop` files in `exports/share/applications/*.desktop` (typically `~/.local/share/flatpak/exports/share/applications/*.desktop` and `/var/lib/flatpak/exports/share/applications/*.desktop`) to make sure that literal filenames do not follow `@@` or `@@u`."}, {"lang": "es", "value": "Flatpak es un sistema para construir, distribuir y ejecutar aplicaciones de escritorio en sandbox en Linux. En Flatpack desde la versi\u00f3n 0.9.4 y anteriores a la versi\u00f3n 1.10.2, presenta una vulnerabilidad en la funcionalidad \"file forwarding\" que puede ser usada por un atacante para conseguir acceso a archivos que normalmente no estar\u00edan permitidos por los permisos de la aplicaci\u00f3n. Colocando los tokens especiales \"@@\" y/o \"@@u\" en el campo Exec del archivo .desktop de una aplicaci\u00f3n Flatpak, un editor de aplicaciones malicioso puede enga\u00f1ar a Flatpak para que se comporte como si el usuario hubiera elegido abrir un archivo de destino con su aplicaci\u00f3n Flatpak, lo que autom\u00e1ticamente hace que ese archivo est\u00e9 disponible para la aplicaci\u00f3n Flatpak. Esto ha sido corregido en versi\u00f3n 1.10.2. Una soluci\u00f3n m\u00ednima es el primer commit \"`Disallow @@ and @@U usage in desktop files`\". El siguiente commit \"`dir: Reserve the whole @@ prefix`\" y \"`dir: Refuse to export .desktop files with suspicious uses of @@ tokens`\" se recomiendan, pero no son estrictamente necesarias. Como soluci\u00f3n, evite instalar aplicaciones Flatpak de fuentes no fiables, o compruebe el contenido de los archivos exportados \".desktop\" en \"exports/share/applications/*.desktop\" (normalmente \"~/.local/share/flatpak/exports/share/applications/*.desktop\" y \"/var/lib/flatpak/exports/share/applications/*.desktop\") para asegurarse de que los nombres literales de los archivos no siguen \"@@\" o \"@@u\""}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:C/C:H/I:H/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 8.2, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.8}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:C/C:L/I:H/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 4.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-74"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:flatpak:flatpak:*:*:*:*:*:*:*:*", "versionStartIncluding": "0.9.4", "versionEndExcluding": "1.10.2", "matchCriteriaId": "AB8FA716-DCCF-4E1B-B683-B5313303ED3E"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:33:*:*:*:*:*:*:*", "matchCriteriaId": "E460AA51-FCDA-46B9-AE97-E6676AA5E194"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:34:*:*:*:*:*:*:*", "matchCriteriaId": "A930E247-0B43-43CB-98FF-6CE7B8189835"}]}]}], "references": [{"url": "https://github.com/flatpak/flatpak/commit/8279c5818425b6812523e3805bbe242fb6a5d961", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/flatpak/flatpak/commit/a7401e638bf0c03102039e216ab1081922f140ae", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/flatpak/flatpak/commit/eb7946bb6248923d8c90fe9b84425fef97ae580d", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/flatpak/flatpak/pull/4156", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/flatpak/flatpak/releases/tag/1.10.2", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/flatpak/flatpak/security/advisories/GHSA-xgh4-387p-hqpp", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/2MXXLXC2DPJ45HSMTI5MZYHMYEGQN6AA/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/WXNVFOIB6ZP4DGOVKAM25T6OIEP3YLGV/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://www.debian.org/security/2021/dsa-4868", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/flatpak/flatpak/commit/8279c5818425b6812523e3805bbe242fb6a5d961"}}