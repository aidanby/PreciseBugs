{"buggy_code": ["language: node_js\nnode_js:\n  - v6\n  - v5\n  - v4\nafter_script:\n  - 'npm run coveralls'\n", "/** @module bodymen */\nimport _ from 'lodash'\nimport Param from 'rich-param'\nimport Schema from './bodymen-schema'\n\nexport { Param, Schema }\n\nexport const handlers = {\n  formatters: {},\n  validators: {}\n}\n\n/**\n * Get or set a handler.\n * @memberof bodymen\n * @param {string} type - Handler type.\n * @param {string} name - Handler name.\n * @param {Function} [fn] - Set the handler method.\n */\nexport function handler (type, name, fn) {\n  if (arguments.length > 2) {\n    handlers[type][name] = fn\n  }\n\n  return handlers[type][name]\n}\n\n/**\n * Get or set a formatter.\n * @memberof bodymen\n * @param {string} name - Formatter name.\n * @param {formatterFn} [fn] - Set the formatter method.\n * @return {formatterFn} The formatter method.\n */\nexport function formatter (name, fn) {\n  return handler('formatters', ...arguments)\n}\n\n/**\n * Get or set a validator.\n * @memberof bodymen\n * @param {string} name - Validator name.\n * @param {validatorFn} [fn] - Set the validator method.\n * @return {validatorFn} The validator method.\n */\nexport function validator (name, fn) {\n  return handler('validators', ...arguments)\n}\n\n/**\n * Create a middleware.\n * @memberof bodymen\n * @param {BodymenSchema|Object} [schema] - Schema object.\n * @param {Object} [options] - Options to be passed to schema.\n * @return {Function} The middleware.\n */\nexport function middleware (schema, options) {\n  return function (req, res, next) {\n    let _schema = schema instanceof Schema\n                ? _.clone(schema)\n                : new Schema(schema, options)\n\n    _schema.validate(req.body, (err) => {\n      if (err) {\n        req.bodymen = {error: err}\n        res.status(400)\n        return next(err.message)\n      }\n\n      req.bodymen = {body: _schema.parse(), schema: _schema}\n      next()\n    })\n  }\n}\n\n/**\n * Error handler middleware.\n * @memberof bodymen\n * @return {Function} The middleware.\n */\nexport function errorHandler () {\n  return function (err, req, res, next) {\n    if (req.bodymen && req.bodymen.error) {\n      res.status(400).json(req.bodymen.error)\n    } else {\n      next(err)\n    }\n  }\n}\n\nexport default {\n  Schema,\n  Param,\n  handlers,\n  handler,\n  formatter,\n  validator,\n  middleware,\n  errorHandler\n}\n", "import request from 'supertest'\nimport express from 'express'\nimport bodyParser from 'body-parser'\nimport test from 'tape'\nimport bodymen, {Schema} from '../src'\nimport './bodymen-schema'\n\nlet route = (...args) => {\n  let app = express()\n  app.use(bodyParser.json())\n  app.use(bodyParser.urlencoded({ extended: true }))\n\n  app.post('/tests', bodymen.middleware(...args), (req, res) => {\n    res.status(200).json(req.bodymen.body)\n  })\n\n  app.use(bodymen.errorHandler())\n  return app\n}\n\ntest('Bodymen handler', (t) => {\n  t.notOk(bodymen.formatter('testFormatter'), 'should not get nonexistent formatter')\n  t.notOk(bodymen.validator('testValidator'), 'should not get nonexistent validator')\n\n  bodymen.formatter('testFormatter', () => 'test')\n  bodymen.validator('testValidator', () => ({valid: false}))\n\n  t.ok(bodymen.formatter('testFormatter'), 'should get formatter')\n  t.ok(bodymen.validator('testValidator'), 'should get validator')\n\n  let schema = new bodymen.Schema({test: String})\n\n  t.ok(schema.formatter('testFormatter'), 'should get formatter in schema')\n  t.ok(schema.validator('testValidator'), 'should get validator in schema')\n\n  t.ok(schema.param('test').formatter('testFormatter'), 'should get formatter in param')\n  t.ok(schema.param('test').validator('testValidator'), 'should get validator in param')\n\n  t.end()\n})\n\ntest('Bodymen middleware', (t) => {\n  t.plan(7)\n\n  request(route())\n    .post('/tests')\n    .send({name: 'test'})\n    .expect(200)\n    .end((err, res) => {\n      if (err) throw err\n      t.same(res.body, {}, 'should respond with blank object')\n    })\n\n  request(route(new Schema({name: String})))\n    .post('/tests')\n    .send({name: 'test'})\n    .expect(200)\n    .end((err, res) => {\n      if (err) throw err\n      t.same(res.body, {name: 'test'}, 'should respond with correct object')\n    })\n\n  request(route(new Schema({\n    name: {\n      type: String,\n      uppercase: true\n    }\n  })))\n    .post('/tests')\n    .send({name: 'test'})\n    .expect(200)\n    .end((err, res) => {\n      if (err) throw err\n      t.same(res.body, {name: 'TEST'}, 'should respond with uppercase value')\n    })\n\n  request(route(new Schema({\n    name: {\n      type: String,\n      required: true\n    }\n  })))\n    .post('/tests')\n    .expect(400)\n    .end((err, res) => {\n      if (err) throw err\n      t.same(res.body.param, 'name', 'should respond with error object')\n    })\n\n  // issue #1\n  request(route(new Schema({links: [Object]})))\n    .post('/tests')\n    .send({links: [{icon: 'path to icon'}]})\n    .expect(200)\n    .end((err, res) => {\n      if (err) throw err\n      t.same(res.body, {links: [{icon: 'path to icon'}]}, 'should respond with correct object')\n    })\n\n  // parse subdocuments as Object\n  request(route(new Schema({sub: {name: String}})))\n    .post('/tests')\n    .send({sub: {name: 'test'}})\n    .expect(200)\n    .end((err, res) => {\n      if (err) throw err\n      t.same(res.body, {sub: {name: 'test'}}, 'should respond with correct object')\n    })\n\n  request(route(new Schema({links: [{icon: String}]})))\n    .post('/tests')\n    .send({links: [{icon: 'path to icon'}]})\n    .expect(200)\n    .end((err, res) => {\n      if (err) throw err\n      t.same(res.body, {links: [{icon: 'path to icon'}]}, 'should respond with correct object')\n    })\n})\n"], "fixing_code": ["language: node_js\nnode_js:\n  - v6\nafter_script:\n  - 'npm run coveralls'\n", "/** @module bodymen */\nimport _ from 'lodash'\nimport Param from 'rich-param'\nimport Schema from './bodymen-schema'\n\nexport { Param, Schema }\n\nexport const handlers = {\n  formatters: {},\n  validators: {}\n}\n\n/**\n * Get or set a handler.\n * @memberof bodymen\n * @param {string} type - Handler type.\n * @param {string} name - Handler name.\n * @param {Function} [fn] - Set the handler method.\n */\nexport function handler (type, name, fn) {\n  if (\n    type === 'constructor' ||\n    type === '__proto__' ||\n    name === 'constructor' ||\n    name === '__proto__'\n  ) {\n    return\n  }\n  if (arguments.length > 2) {\n    handlers[type][name] = fn\n  }\n\n  return handlers[type][name]\n}\n\n/**\n * Get or set a formatter.\n * @memberof bodymen\n * @param {string} name - Formatter name.\n * @param {formatterFn} [fn] - Set the formatter method.\n * @return {formatterFn} The formatter method.\n */\nexport function formatter (name, fn) {\n  return handler('formatters', ...arguments)\n}\n\n/**\n * Get or set a validator.\n * @memberof bodymen\n * @param {string} name - Validator name.\n * @param {validatorFn} [fn] - Set the validator method.\n * @return {validatorFn} The validator method.\n */\nexport function validator (name, fn) {\n  return handler('validators', ...arguments)\n}\n\n/**\n * Create a middleware.\n * @memberof bodymen\n * @param {BodymenSchema|Object} [schema] - Schema object.\n * @param {Object} [options] - Options to be passed to schema.\n * @return {Function} The middleware.\n */\nexport function middleware (schema, options) {\n  return function (req, res, next) {\n    let _schema = schema instanceof Schema\n                ? _.clone(schema)\n                : new Schema(schema, options)\n\n    _schema.validate(req.body, (err) => {\n      if (err) {\n        req.bodymen = {error: err}\n        res.status(400)\n        return next(err.message)\n      }\n\n      req.bodymen = {body: _schema.parse(), schema: _schema}\n      next()\n    })\n  }\n}\n\n/**\n * Error handler middleware.\n * @memberof bodymen\n * @return {Function} The middleware.\n */\nexport function errorHandler () {\n  return function (err, req, res, next) {\n    if (req.bodymen && req.bodymen.error) {\n      res.status(400).json(req.bodymen.error)\n    } else {\n      next(err)\n    }\n  }\n}\n\nexport default {\n  Schema,\n  Param,\n  handlers,\n  handler,\n  formatter,\n  validator,\n  middleware,\n  errorHandler\n}\n", "import request from 'supertest'\nimport express from 'express'\nimport bodyParser from 'body-parser'\nimport test from 'tape'\nimport bodymen, {Schema} from '../src'\nimport './bodymen-schema'\n\nlet route = (...args) => {\n  let app = express()\n  app.use(bodyParser.json())\n  app.use(bodyParser.urlencoded({ extended: true }))\n\n  app.post('/tests', bodymen.middleware(...args), (req, res) => {\n    res.status(200).json(req.bodymen.body)\n  })\n\n  app.use(bodymen.errorHandler())\n  return app\n}\n\ntest('Bodymen handler', (t) => {\n  t.notOk(bodymen.formatter('testFormatter'), 'should not get nonexistent formatter')\n  t.notOk(bodymen.validator('testValidator'), 'should not get nonexistent validator')\n\n  bodymen.formatter('testFormatter', () => 'test')\n  bodymen.validator('testValidator', () => ({valid: false}))\n\n  t.ok(bodymen.formatter('testFormatter'), 'should get formatter')\n  t.ok(bodymen.validator('testValidator'), 'should get validator')\n\n  let schema = new bodymen.Schema({test: String})\n\n  t.ok(schema.formatter('testFormatter'), 'should get formatter in schema')\n  t.ok(schema.validator('testValidator'), 'should get validator in schema')\n\n  t.ok(schema.param('test').formatter('testFormatter'), 'should get formatter in param')\n  t.ok(schema.param('test').validator('testValidator'), 'should get validator in param')\n\n  t.end()\n})\n\ntest('Bodymen middleware', (t) => {\n  t.plan(7)\n\n  request(route())\n    .post('/tests')\n    .send({name: 'test'})\n    .expect(200)\n    .end((err, res) => {\n      if (err) throw err\n      t.same(res.body, {}, 'should respond with blank object')\n    })\n\n  request(route(new Schema({name: String})))\n    .post('/tests')\n    .send({name: 'test'})\n    .expect(200)\n    .end((err, res) => {\n      if (err) throw err\n      t.same(res.body, {name: 'test'}, 'should respond with correct object')\n    })\n\n  request(route(new Schema({\n    name: {\n      type: String,\n      uppercase: true\n    }\n  })))\n    .post('/tests')\n    .send({name: 'test'})\n    .expect(200)\n    .end((err, res) => {\n      if (err) throw err\n      t.same(res.body, {name: 'TEST'}, 'should respond with uppercase value')\n    })\n\n  request(route(new Schema({\n    name: {\n      type: String,\n      required: true\n    }\n  })))\n    .post('/tests')\n    .expect(400)\n    .end((err, res) => {\n      if (err) throw err\n      t.same(res.body.param, 'name', 'should respond with error object')\n    })\n\n  // issue #1\n  request(route(new Schema({links: [Object]})))\n    .post('/tests')\n    .send({links: [{icon: 'path to icon'}]})\n    .expect(200)\n    .end((err, res) => {\n      if (err) throw err\n      t.same(res.body, {links: [{icon: 'path to icon'}]}, 'should respond with correct object')\n    })\n\n  // parse subdocuments as Object\n  request(route(new Schema({sub: {name: String}})))\n    .post('/tests')\n    .send({sub: {name: 'test'}})\n    .expect(200)\n    .end((err, res) => {\n      if (err) throw err\n      t.same(res.body, {sub: {name: 'test'}}, 'should respond with correct object')\n    })\n\n  request(route(new Schema({links: [{icon: String}]})))\n    .post('/tests')\n    .send({links: [{icon: 'path to icon'}]})\n    .expect(200)\n    .end((err, res) => {\n      if (err) throw err\n      t.same(res.body, {links: [{icon: 'path to icon'}]}, 'should respond with correct object')\n    })\n})\n\ntest('Prototype pollution', (t) => {\n  const { toString } = {}\n\n  bodymen.handler('__proto__', 'toString', 'JHU')\n  t.ok({}.toString === toString, 'should not be vulnerable to prototype pollution')\n\n  bodymen.handler('formatters', '__proto__', { toString: 'JHU' })\n  t.ok({}.toString === toString, 'should not be vulnerable to prototype pollution')\n\n  bodymen.handler('validators', '__proto__', { toString: 'JHU' })\n  t.ok({}.toString === toString, 'should not be vulnerable to prototype pollution')\n\n  t.end()\n})\n"], "filenames": [".travis.yml", "src/index.js", "test/index.js"], "buggy_code_start_loc": [4, 20, 118], "buggy_code_end_loc": [6, 20, 118], "fixing_code_start_loc": [3, 21, 119], "fixing_code_end_loc": [3, 29, 134], "type": "CWE-74", "message": "bodymen before 1.1.1 is vulnerable to Prototype Pollution. The handler function could be tricked into adding or modifying properties of Object.prototype using a __proto__ payload.", "other": {"cve": {"id": "CVE-2019-10792", "sourceIdentifier": "report@snyk.io", "published": "2020-02-18T16:15:10.233", "lastModified": "2020-02-27T17:00:59.150", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "bodymen before 1.1.1 is vulnerable to Prototype Pollution. The handler function could be tricked into adding or modifying properties of Object.prototype using a __proto__ payload."}, {"lang": "es", "value": "bodymen versiones anteriores a 1.1.1, es vulnerable a una Contaminaci\u00f3n por Prototipo (Prototype Pollution). La funci\u00f3n handler podr\u00eda ser enga\u00f1ada para agregar o modificar propiedades de Object.prototype usando una carga \u00fatil __proto__."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 6.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.5}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-74"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:bodymen_project:bodymen:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "1.1.1", "matchCriteriaId": "76D49614-9492-4408-8AAB-C6058FF3FF34"}]}]}], "references": [{"url": "https://github.com/diegohaz/bodymen/commit/5d52e8cf360410ee697afd90937e6042c3a8653b", "source": "report@snyk.io", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://snyk.io/vuln/SNYK-JS-BODYMEN-548897", "source": "report@snyk.io", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/diegohaz/bodymen/commit/5d52e8cf360410ee697afd90937e6042c3a8653b"}}