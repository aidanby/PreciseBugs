{"buggy_code": ["/*\n * Soft:        Keepalived is a failover program for the LVS project\n *              <www.linuxvirtualserver.org>. It monitor & manipulate\n *              a loadbalanced server pool using multi-layer checks.\n *\n * Part:        Main program structure.\n *\n * Author:      Alexandre Cassen, <acassen@linux-vs.org>\n *\n *              This program is distributed in the hope that it will be useful,\n *              but WITHOUT ANY WARRANTY; without even the implied warranty of\n *              MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n *              See the GNU General Public License for more details.\n *\n *              This program is free software; you can redistribute it and/or\n *              modify it under the terms of the GNU General Public License\n *              as published by the Free Software Foundation; either version\n *              2 of the License, or (at your option) any later version.\n *\n * Copyright (C) 2001-2017 Alexandre Cassen, <acassen@gmail.com>\n */\n\n#include \"config.h\"\n\n#include <stdlib.h>\n#include <sys/utsname.h>\n#include <sys/resource.h>\n#include <stdbool.h>\n#ifdef HAVE_SIGNALFD\n#include <sys/signalfd.h>\n#endif\n#include <errno.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <getopt.h>\n#include <linux/version.h>\n#include <ctype.h>\n\n#include \"main.h\"\n#include \"global_data.h\"\n#include \"daemon.h\"\n#include \"config.h\"\n#include \"git-commit.h\"\n#include \"utils.h\"\n#include \"signals.h\"\n#include \"pidfile.h\"\n#include \"bitops.h\"\n#include \"logger.h\"\n#include \"parser.h\"\n#include \"notify.h\"\n#include \"utils.h\"\n#ifdef _WITH_LVS_\n#include \"check_parser.h\"\n#include \"check_daemon.h\"\n#endif\n#ifdef _WITH_VRRP_\n#include \"vrrp_daemon.h\"\n#include \"vrrp_parser.h\"\n#include \"vrrp_if.h\"\n#ifdef _WITH_JSON_\n#include \"vrrp_json.h\"\n#endif\n#endif\n#ifdef _WITH_BFD_\n#include \"bfd_daemon.h\"\n#include \"bfd_parser.h\"\n#endif\n#include \"global_parser.h\"\n#if HAVE_DECL_CLONE_NEWNET\n#include \"namespaces.h\"\n#endif\n#include \"scheduler.h\"\n#include \"keepalived_netlink.h\"\n#include \"git-commit.h\"\n#if defined THREAD_DUMP || defined _EPOLL_DEBUG_ || defined _EPOLL_THREAD_DUMP_\n#include \"scheduler.h\"\n#endif\n#include \"process.h\"\n#ifdef _TIMER_CHECK_\n#include \"timer.h\"\n#endif\n#ifdef _SMTP_ALERT_DEBUG_\n#include \"smtp.h\"\n#endif\n#if defined _REGEX_DEBUG_ || defined _WITH_REGEX_TIMERS_\n#include \"check_http.h\"\n#endif\n#ifdef _TSM_DEBUG_\n#include \"vrrp_scheduler.h\"\n#endif\n\n/* musl libc doesn't define the following */\n#ifndef\tW_EXITCODE\n#define\tW_EXITCODE(ret, sig)\t((ret) << 8 | (sig))\n#endif\n#ifndef\tWCOREFLAG\n#define\tWCOREFLAG\t\t((int32_t)WCOREDUMP(0xffffffff))\n#endif\n\n#define\tVERSION_STRING\t\tPACKAGE_NAME \" v\" PACKAGE_VERSION \" (\" GIT_DATE \")\"\n#define COPYRIGHT_STRING\t\"Copyright(C) 2001-\" GIT_YEAR \" Alexandre Cassen, <acassen@gmail.com>\"\n\n#define CHILD_WAIT_SECS\t5\n\n/* global var */\nconst char *version_string = VERSION_STRING;\t\t/* keepalived version */\nchar *conf_file = KEEPALIVED_CONFIG_FILE;\t\t/* Configuration file */\nint log_facility = LOG_DAEMON;\t\t\t\t/* Optional logging facilities */\nbool reload;\t\t\t\t\t\t/* Set during a reload */\nchar *main_pidfile;\t\t\t\t\t/* overrule default pidfile */\nstatic bool free_main_pidfile;\n#ifdef _WITH_LVS_\npid_t checkers_child;\t\t\t\t\t/* Healthcheckers child process ID */\nchar *checkers_pidfile;\t\t\t\t\t/* overrule default pidfile */\nstatic bool free_checkers_pidfile;\n#endif\n#ifdef _WITH_VRRP_\npid_t vrrp_child;\t\t\t\t\t/* VRRP child process ID */\nchar *vrrp_pidfile;\t\t\t\t\t/* overrule default pidfile */\nstatic bool free_vrrp_pidfile;\n#endif\n#ifdef _WITH_BFD_\npid_t bfd_child;\t\t\t\t\t/* BFD child process ID */\nchar *bfd_pidfile;\t\t\t\t\t/* overrule default pidfile */\nstatic bool free_bfd_pidfile;\n#endif\nunsigned long daemon_mode;\t\t\t\t/* VRRP/CHECK/BFD subsystem selection */\n#ifdef _WITH_SNMP_\nbool snmp;\t\t\t\t\t\t/* Enable SNMP support */\nconst char *snmp_socket;\t\t\t\t/* Socket to use for SNMP agent */\n#endif\nstatic char *syslog_ident;\t\t\t\t/* syslog ident if not default */\nbool use_pid_dir;\t\t\t\t\t/* Put pid files in /var/run/keepalived or @localstatedir@/run/keepalived */\n\nunsigned os_major;\t\t\t\t\t/* Kernel version */\nunsigned os_minor;\nunsigned os_release;\nchar *hostname;\t\t\t\t\t\t/* Initial part of hostname */\n\n#if HAVE_DECL_CLONE_NEWNET\nstatic char *override_namespace;\t\t\t/* If namespace specified on command line */\n#endif\n\nunsigned child_wait_time = CHILD_WAIT_SECS;\t\t/* Time to wait for children to exit */\n\n/* Log facility table */\nstatic struct {\n\tint facility;\n} LOG_FACILITY[] = {\n\t{LOG_LOCAL0}, {LOG_LOCAL1}, {LOG_LOCAL2}, {LOG_LOCAL3},\n\t{LOG_LOCAL4}, {LOG_LOCAL5}, {LOG_LOCAL6}, {LOG_LOCAL7}\n};\n#define\tLOG_FACILITY_MAX\t((sizeof(LOG_FACILITY) / sizeof(LOG_FACILITY[0])) - 1)\n\n/* umask settings */\nbool umask_cmdline;\nstatic mode_t umask_val = S_IXUSR | S_IWGRP | S_IXGRP | S_IWOTH | S_IXOTH;\n\n/* Control producing core dumps */\nstatic bool set_core_dump_pattern = false;\nstatic bool create_core_dump = false;\nstatic const char *core_dump_pattern = \"core\";\nstatic char *orig_core_dump_pattern = NULL;\n\n/* debug flags */\n#if defined _TIMER_CHECK_ || defined _SMTP_ALERT_DEBUG_ || defined _EPOLL_DEBUG_ || defined _EPOLL_THREAD_DUMP_ || defined _REGEX_DEBUG_ || defined _WITH_REGEX_TIMERS_ || defined _TSM_DEBUG_ || defined _VRRP_FD_DEBUG_ || defined _NETLINK_TIMERS_\n#define WITH_DEBUG_OPTIONS 1\n#endif\n\n#ifdef _TIMER_CHECK_\nstatic char timer_debug;\n#endif\n#ifdef _SMTP_ALERT_DEBUG_\nstatic char smtp_debug;\n#endif\n#ifdef _EPOLL_DEBUG_\nstatic char epoll_debug;\n#endif\n#ifdef _EPOLL_THREAD_DUMP_\nstatic char epoll_thread_debug;\n#endif\n#ifdef _REGEX_DEBUG_\nstatic char regex_debug;\n#endif\n#ifdef _WITH_REGEX_TIMERS_\nstatic char regex_timers;\n#endif\n#ifdef _TSM_DEBUG_\nstatic char tsm_debug;\n#endif\n#ifdef _VRRP_FD_DEBUG_\nstatic char vrrp_fd_debug;\n#endif\n#ifdef _NETLINK_TIMERS_\nstatic char netlink_timer_debug;\n#endif\n\nvoid\nfree_parent_mallocs_startup(bool am_child)\n{\n\tif (am_child) {\n#if HAVE_DECL_CLONE_NEWNET\n\t\tfree_dirname();\n#endif\n#ifndef _MEM_CHECK_LOG_\n\t\tFREE_PTR(syslog_ident);\n#else\n\t\tfree(syslog_ident);\n#endif\n\t\tsyslog_ident = NULL;\n\n\t\tFREE_PTR(orig_core_dump_pattern);\n\t}\n\n\tif (free_main_pidfile) {\n\t\tFREE_PTR(main_pidfile);\n\t\tfree_main_pidfile = false;\n\t}\n}\n\nvoid\nfree_parent_mallocs_exit(void)\n{\n#ifdef _WITH_VRRP_\n\tif (free_vrrp_pidfile)\n\t\tFREE_PTR(vrrp_pidfile);\n#endif\n#ifdef _WITH_LVS_\n\tif (free_checkers_pidfile)\n\t\tFREE_PTR(checkers_pidfile);\n#endif\n#ifdef _WITH_BFD_\n\tif (free_bfd_pidfile)\n\t\tFREE_PTR(bfd_pidfile);\n#endif\n\n\tFREE_PTR(config_id);\n}\n\nchar *\nmake_syslog_ident(const char* name)\n{\n\tsize_t ident_len = strlen(name) + 1;\n\tchar *ident;\n\n#if HAVE_DECL_CLONE_NEWNET\n\tif (global_data->network_namespace)\n\t\tident_len += strlen(global_data->network_namespace) + 1;\n#endif\n\tif (global_data->instance_name)\n\t\tident_len += strlen(global_data->instance_name) + 1;\n\n\t/* If we are writing MALLOC/FREE info to the log, we have\n\t * trouble FREEing the syslog_ident */\n#ifndef _MEM_CHECK_LOG_\n\tident = MALLOC(ident_len);\n#else\n\tident = malloc(ident_len);\n#endif\n\n\tif (!ident)\n\t\treturn NULL;\n\n\tstrcpy(ident, name);\n#if HAVE_DECL_CLONE_NEWNET\n\tif (global_data->network_namespace) {\n\t\tstrcat(ident, \"_\");\n\t\tstrcat(ident, global_data->network_namespace);\n\t}\n#endif\n\tif (global_data->instance_name) {\n\t\tstrcat(ident, \"_\");\n\t\tstrcat(ident, global_data->instance_name);\n\t}\n\n\treturn ident;\n}\n\nstatic char *\nmake_pidfile_name(const char* start, const char* instance, const char* extn)\n{\n\tsize_t len;\n\tchar *name;\n\n\tlen = strlen(start) + 1;\n\tif (instance)\n\t\tlen += strlen(instance) + 1;\n\tif (extn)\n\t\tlen += strlen(extn);\n\n\tname = MALLOC(len);\n\tif (!name) {\n\t\tlog_message(LOG_INFO, \"Unable to make pidfile name for %s\", start);\n\t\treturn NULL;\n\t}\n\n\tstrcpy(name, start);\n\tif (instance) {\n\t\tstrcat(name, \"_\");\n\t\tstrcat(name, instance);\n\t}\n\tif (extn)\n\t\tstrcat(name, extn);\n\n\treturn name;\n}\n\n#ifdef _WITH_VRRP_\nbool\nrunning_vrrp(void)\n{\n\treturn (__test_bit(DAEMON_VRRP, &daemon_mode) &&\n\t    (global_data->have_vrrp_config ||\n\t     __test_bit(RUN_ALL_CHILDREN, &daemon_mode)));\n}\n#endif\n\n#ifdef _WITH_LVS_\nbool\nrunning_checker(void)\n{\n\treturn (__test_bit(DAEMON_CHECKERS, &daemon_mode) &&\n\t    (global_data->have_checker_config ||\n\t     __test_bit(RUN_ALL_CHILDREN, &daemon_mode)));\n}\n#endif\n\n#ifdef _WITH_BFD_\nbool\nrunning_bfd(void)\n{\n\treturn (__test_bit(DAEMON_BFD, &daemon_mode) &&\n\t    (global_data->have_bfd_config ||\n\t     __test_bit(RUN_ALL_CHILDREN, &daemon_mode)));\n}\n#endif\n\nstatic char const *\nfind_keepalived_child_name(pid_t pid)\n{\n#ifdef _WITH_LVS_\n\tif (pid == checkers_child)\n\t\treturn PROG_CHECK;\n#endif\n#ifdef _WITH_VRRP_\n\tif (pid == vrrp_child)\n\t\treturn PROG_VRRP;\n#endif\n#ifdef _WITH_BFD_\n\tif (pid == bfd_child)\n\t\treturn PROG_BFD;\n#endif\n\n\treturn NULL;\n}\n\nstatic vector_t *\nglobal_init_keywords(void)\n{\n\t/* global definitions mapping */\n\tinit_global_keywords(true);\n\n#ifdef _WITH_VRRP_\n\tinit_vrrp_keywords(false);\n#endif\n#ifdef _WITH_LVS_\n\tinit_check_keywords(false);\n#endif\n#ifdef _WITH_BFD_\n\tinit_bfd_keywords(false);\n#endif\n\n\treturn keywords;\n}\n\nstatic void\nread_config_file(void)\n{\n\tinit_data(conf_file, global_init_keywords);\n}\n\n/* Daemon stop sequence */\nvoid\nstop_keepalived(void)\n{\n#ifndef _DEBUG_\n\t/* Just cleanup memory & exit */\n\tthread_destroy_master(master);\n\n#ifdef _WITH_VRRP_\n\tif (__test_bit(DAEMON_VRRP, &daemon_mode))\n\t\tpidfile_rm(vrrp_pidfile);\n#endif\n\n#ifdef _WITH_LVS_\n\tif (__test_bit(DAEMON_CHECKERS, &daemon_mode))\n\t\tpidfile_rm(checkers_pidfile);\n#endif\n\n#ifdef _WITH_BFD_\n\tif (__test_bit(DAEMON_BFD, &daemon_mode))\n\t\tpidfile_rm(bfd_pidfile);\n#endif\n\n\tpidfile_rm(main_pidfile);\n#endif\n}\n\n/* Daemon init sequence */\nstatic int\nstart_keepalived(void)\n{\n\tbool have_child = false;\n\n#ifdef _WITH_BFD_\n\t/* must be opened before vrrp and bfd start */\n\topen_bfd_pipes();\n#endif\n\n#ifdef _WITH_LVS_\n\t/* start healthchecker child */\n\tif (running_checker()) {\n\t\tstart_check_child();\n\t\thave_child = true;\n\t}\n#endif\n#ifdef _WITH_VRRP_\n\t/* start vrrp child */\n\tif (running_vrrp()) {\n\t\tstart_vrrp_child();\n\t\thave_child = true;\n\t}\n#endif\n#ifdef _WITH_BFD_\n\t/* start bfd child */\n\tif (running_bfd()) {\n\t\tstart_bfd_child();\n\t\thave_child = true;\n\t}\n#endif\n\n\treturn have_child;\n}\n\nstatic void\nvalidate_config(void)\n{\n#ifdef _WITH_VRRP_\n\tkernel_netlink_read_interfaces();\n#endif\n\n#ifdef _WITH_LVS_\n\t/* validate healthchecker config */\n#ifndef _DEBUG_\n\tprog_type = PROG_TYPE_CHECKER;\n#endif\n\tcheck_validate_config();\n#endif\n#ifdef _WITH_VRRP_\n\t/* validate vrrp config */\n#ifndef _DEBUG_\n\tprog_type = PROG_TYPE_VRRP;\n#endif\n\tvrrp_validate_config();\n#endif\n#ifdef _WITH_BFD_\n\t/* validate bfd config */\n#ifndef _DEBUG_\n\tprog_type = PROG_TYPE_BFD;\n#endif\n\tbfd_validate_config();\n#endif\n}\n\nstatic void\nconfig_test_exit(void)\n{\n\tconfig_err_t config_err = get_config_status();\n\n\tswitch (config_err) {\n\tcase CONFIG_OK:\n\t\texit(KEEPALIVED_EXIT_OK);\n\tcase CONFIG_FILE_NOT_FOUND:\n\tcase CONFIG_BAD_IF:\n\tcase CONFIG_FATAL:\n\t\texit(KEEPALIVED_EXIT_CONFIG);\n\tcase CONFIG_SECURITY_ERROR:\n\t\texit(KEEPALIVED_EXIT_CONFIG_TEST_SECURITY);\n\tdefault:\n\t\texit(KEEPALIVED_EXIT_CONFIG_TEST);\n\t}\n}\n\n#ifndef _DEBUG_\nstatic bool reload_config(void)\n{\n\tbool unsupported_change = false;\n\n\tlog_message(LOG_INFO, \"Reloading ...\");\n\n\t/* Make sure there isn't an attempt to change the network namespace or instance name */\n\told_global_data = global_data;\n\tglobal_data = NULL;\n\tglobal_data = alloc_global_data();\n\n\tread_config_file();\n\n\tinit_global_data(global_data, old_global_data);\n\n#if HAVE_DECL_CLONE_NEWNET\n\tif (!!old_global_data->network_namespace != !!global_data->network_namespace ||\n\t    (global_data->network_namespace && strcmp(old_global_data->network_namespace, global_data->network_namespace))) {\n\t\tlog_message(LOG_INFO, \"Cannot change network namespace at a reload - please restart %s\", PACKAGE);\n\t\tunsupported_change = true;\n\t}\n\tFREE_PTR(global_data->network_namespace);\n\tglobal_data->network_namespace = old_global_data->network_namespace;\n\told_global_data->network_namespace = NULL;\n#endif\n\n\tif (!!old_global_data->instance_name != !!global_data->instance_name ||\n\t    (global_data->instance_name && strcmp(old_global_data->instance_name, global_data->instance_name))) {\n\t\tlog_message(LOG_INFO, \"Cannot change instance name at a reload - please restart %s\", PACKAGE);\n\t\tunsupported_change = true;\n\t}\n\tFREE_PTR(global_data->instance_name);\n\tglobal_data->instance_name = old_global_data->instance_name;\n\told_global_data->instance_name = NULL;\n\n\tif (unsupported_change) {\n\t\t/* We cannot reload the configuration, so continue with the old config */\n\t\tfree_global_data (global_data);\n\t\tglobal_data = old_global_data;\n\t}\n\telse\n\t\tfree_global_data (old_global_data);\n\n\treturn !unsupported_change;\n}\n\n/* SIGHUP/USR1/USR2 handler */\nstatic void\npropagate_signal(__attribute__((unused)) void *v, int sig)\n{\n\tif (sig == SIGHUP) {\n\t\tif (!reload_config())\n\t\t\treturn;\n\t}\n\n\t/* Signal child processes */\n#ifdef _WITH_VRRP_\n\tif (vrrp_child > 0)\n\t\tkill(vrrp_child, sig);\n\telse if (sig == SIGHUP && running_vrrp())\n\t\tstart_vrrp_child();\n#endif\n#ifdef _WITH_LVS_\n\tif (sig == SIGHUP) {\n\t\tif (checkers_child > 0)\n\t\t\tkill(checkers_child, sig);\n\t\telse if (running_checker())\n\t\t\tstart_check_child();\n\t}\n#endif\n#ifdef _WITH_BFD_\n\tif (sig == SIGHUP) {\n\t\tif (bfd_child > 0)\n\t\t\tkill(bfd_child, sig);\n\t\telse if (running_bfd())\n\t\t\tstart_bfd_child();\n\t}\n#endif\n}\n\n/* Terminate handler */\nstatic void\nsigend(__attribute__((unused)) void *v, __attribute__((unused)) int sig)\n{\n\tint status;\n\tint ret;\n\tint wait_count = 0;\n\tstruct timeval start_time, now;\n#ifdef HAVE_SIGNALFD\n\tstruct timeval timeout = {\n\t\t.tv_sec = child_wait_time,\n\t\t.tv_usec = 0\n\t};\n\tint signal_fd = master->signal_fd;\n\tfd_set read_set;\n\tstruct signalfd_siginfo siginfo;\n\tsigset_t sigmask;\n#else\n\tsigset_t old_set, child_wait;\n\tstruct timespec timeout = {\n\t\t.tv_sec = child_wait_time,\n\t\t.tv_nsec = 0\n\t};\n#endif\n\n\t/* register the terminate thread */\n\tthread_add_terminate_event(master);\n\n\tlog_message(LOG_INFO, \"Stopping\");\n\n#ifdef HAVE_SIGNALFD\n\t/* We only want to receive SIGCHLD now */\n\tsigemptyset(&sigmask);\n\tsigaddset(&sigmask, SIGCHLD);\n\tsignalfd(signal_fd, &sigmask, 0);\n\tFD_ZERO(&read_set);\n#else\n\tsigmask_func(0, NULL, &old_set);\n\tif (!sigismember(&old_set, SIGCHLD)) {\n\t\tsigemptyset(&child_wait);\n\t\tsigaddset(&child_wait, SIGCHLD);\n\t\tsigmask_func(SIG_BLOCK, &child_wait, NULL);\n\t}\n#endif\n\n#ifdef _WITH_VRRP_\n\tif (vrrp_child > 0) {\n\t\tif (kill(vrrp_child, SIGTERM)) {\n\t\t\t/* ESRCH means no such process */\n\t\t\tif (errno == ESRCH)\n\t\t\t\tvrrp_child = 0;\n\t\t}\n\t\telse\n\t\t\twait_count++;\n\t}\n#endif\n#ifdef _WITH_LVS_\n\tif (checkers_child > 0) {\n\t\tif (kill(checkers_child, SIGTERM)) {\n\t\t\tif (errno == ESRCH)\n\t\t\t\tcheckers_child = 0;\n\t\t}\n\t\telse\n\t\t\twait_count++;\n\t}\n#endif\n#ifdef _WITH_BFD_\n\tif (bfd_child > 0) {\n\t\tif (kill(bfd_child, SIGTERM)) {\n\t\t\tif (errno == ESRCH)\n\t\t\t\tbfd_child = 0;\n\t\t}\n\t\telse\n\t\t\twait_count++;\n\t}\n#endif\n\n\tgettimeofday(&start_time, NULL);\n\twhile (wait_count) {\n#ifdef HAVE_SIGNALFD\n\t\tFD_SET(signal_fd, &read_set);\n\t\tret = select(signal_fd + 1, &read_set, NULL, NULL, &timeout);\n\t\tif (ret == 0)\n\t\t\tbreak;\n\t\tif (ret == -1) {\n\t\t\tif (errno == EINTR)\n\t\t\t\tcontinue;\n\n\t\t\tlog_message(LOG_INFO, \"Terminating select returned errno %d\", errno);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!FD_ISSET(signal_fd, &read_set)) {\n\t\t\tlog_message(LOG_INFO, \"Terminating select did not return select_fd\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (read(signal_fd, &siginfo, sizeof(siginfo)) != sizeof(siginfo)) {\n\t\t\tlog_message(LOG_INFO, \"Terminating signal read did not read entire siginfo\");\n\t\t\tbreak;\n\t\t}\n\n\t\tstatus = siginfo.ssi_code == CLD_EXITED ? W_EXITCODE(siginfo.ssi_status, 0) :\n\t\t\t siginfo.ssi_code == CLD_KILLED ? W_EXITCODE(0, siginfo.ssi_status) :\n\t\t\t\t\t\t\t   WCOREFLAG;\n\n#ifdef _WITH_VRRP_\n\t\tif (vrrp_child > 0 && vrrp_child == (pid_t)siginfo.ssi_pid) {\n\t\t\treport_child_status(status, vrrp_child, PROG_VRRP);\n\t\t\tvrrp_child = 0;\n\t\t\twait_count--;\n\t\t}\n#endif\n\n#ifdef _WITH_LVS_\n\t\tif (checkers_child > 0 && checkers_child == (pid_t)siginfo.ssi_pid) {\n\t\t\treport_child_status(status, checkers_child, PROG_CHECK);\n\t\t\tcheckers_child = 0;\n\t\t\twait_count--;\n\t\t}\n#endif\n#ifdef _WITH_BFD_\n\t\tif (bfd_child > 0 && bfd_child == (pid_t)siginfo.ssi_pid) {\n\t\t\treport_child_status(status, bfd_child, PROG_BFD);\n\t\t\tbfd_child = 0;\n\t\t\twait_count--;\n\t\t}\n#endif\n\n#else\n\t\tret = sigtimedwait(&child_wait, NULL, &timeout);\n\t\tif (ret == -1) {\n\t\t\tif (errno == EINTR)\n\t\t\t\tcontinue;\n\t\t\tif (errno == EAGAIN)\n\t\t\t\tbreak;\n\t\t}\n\n#ifdef _WITH_VRRP_\n\t\tif (vrrp_child > 0 && vrrp_child == waitpid(vrrp_child, &status, WNOHANG)) {\n\t\t\treport_child_status(status, vrrp_child, PROG_VRRP);\n\t\t\tvrrp_child = 0;\n\t\t\twait_count--;\n\t\t}\n#endif\n\n#ifdef _WITH_LVS_\n\t\tif (checkers_child > 0 && checkers_child == waitpid(checkers_child, &status, WNOHANG)) {\n\t\t\treport_child_status(status, checkers_child, PROG_CHECK);\n\t\t\tcheckers_child = 0;\n\t\t\twait_count--;\n\t\t}\n#endif\n#ifdef _WITH_BFD_\n\t\tif (bfd_child > 0 && bfd_child == waitpid(bfd_child, &status, WNOHANG)) {\n\t\t\treport_child_status(status, bfd_child, PROG_BFD);\n\t\t\tbfd_child = 0;\n\t\t\twait_count--;\n\t\t}\n#endif\n\n#endif\n\n\t\tif (wait_count) {\n\t\t\tgettimeofday(&now, NULL);\n\t\t\ttimeout.tv_sec = child_wait_time - (now.tv_sec - start_time.tv_sec);\n#ifdef HAVE_SIGNALFD\n\t\t\ttimeout.tv_usec = (start_time.tv_usec - now.tv_usec);\n\t\t\tif (timeout.tv_usec < 0) {\n\t\t\t\ttimeout.tv_usec += 1000000L;\n\t\t\t\ttimeout.tv_sec--;\n\t\t\t}\n#else\n\t\t\ttimeout.tv_nsec = (start_time.tv_usec - now.tv_usec) * 1000;\n\t\t\tif (timeout.tv_nsec < 0) {\n\t\t\t\ttimeout.tv_nsec += 1000000000L;\n\t\t\t\ttimeout.tv_sec--;\n\t\t\t}\n#endif\n\t\t\tif (timeout.tv_sec < 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* A child may not have terminated, so force its termination */\n#ifdef _WITH_VRRP_\n\tif (vrrp_child) {\n\t\tlog_message(LOG_INFO, \"vrrp process failed to die - forcing termination\");\n\t\tkill(vrrp_child, SIGKILL);\n\t}\n#endif\n#ifdef _WITH_LVS_\n\tif (checkers_child) {\n\t\tlog_message(LOG_INFO, \"checker process failed to die - forcing termination\");\n\t\tkill(checkers_child, SIGKILL);\n\t}\n#endif\n#ifdef _WITH_BFD_\n\tif (bfd_child) {\n\t\tlog_message(LOG_INFO, \"bfd process failed to die - forcing termination\");\n\t\tkill(bfd_child, SIGKILL);\n\t}\n#endif\n\n#ifndef HAVE_SIGNALFD\n\tif (!sigismember(&old_set, SIGCHLD))\n\t\tsigmask_func(SIG_UNBLOCK, &child_wait, NULL);\n#endif\n}\n#endif\n\n/* Initialize signal handler */\nstatic void\nsignal_init(void)\n{\n#ifndef _DEBUG_\n\tsignal_set(SIGHUP, propagate_signal, NULL);\n\tsignal_set(SIGUSR1, propagate_signal, NULL);\n\tsignal_set(SIGUSR2, propagate_signal, NULL);\n#ifdef _WITH_JSON_\n\tsignal_set(SIGJSON, propagate_signal, NULL);\n#endif\n\tsignal_set(SIGINT, sigend, NULL);\n\tsignal_set(SIGTERM, sigend, NULL);\n#endif\n\tsignal_ignore(SIGPIPE);\n}\n\n/* To create a core file when abrt is running (a RedHat distribution),\n * and keepalived isn't installed from an RPM package, edit the file\n * \u201c/etc/abrt/abrt.conf\u201d, and change the value of the field\n * \u201cProcessUnpackaged\u201d to \u201cyes\u201d.\n *\n * Alternatively, use the -M command line option. */\nstatic void\nupdate_core_dump_pattern(const char *pattern_str)\n{\n\tint fd;\n\tbool initialising = (orig_core_dump_pattern == NULL);\n\n\t/* CORENAME_MAX_SIZE in kernel source include/linux/binfmts.h defines\n\t * the maximum string length, * see core_pattern[CORENAME_MAX_SIZE] in\n\t * fs/coredump.c. Currently (Linux 4.10) defines it to be 128, but the\n\t * definition is not exposed to user-space. */\n#define\tCORENAME_MAX_SIZE\t128\n\n\tif (initialising)\n\t\torig_core_dump_pattern = MALLOC(CORENAME_MAX_SIZE);\n\n\tfd = open (\"/proc/sys/kernel/core_pattern\", O_RDWR);\n\n\tif (fd == -1 ||\n\t    (initialising && read(fd, orig_core_dump_pattern, CORENAME_MAX_SIZE - 1) == -1) ||\n\t    write(fd, pattern_str, strlen(pattern_str)) == -1) {\n\t\tlog_message(LOG_INFO, \"Unable to read/write core_pattern\");\n\n\t\tif (fd != -1)\n\t\t\tclose(fd);\n\n\t\tFREE(orig_core_dump_pattern);\n\n\t\treturn;\n\t}\n\n\tclose(fd);\n\n\tif (!initialising)\n\t\tFREE_PTR(orig_core_dump_pattern);\n}\n\nstatic void\ncore_dump_init(void)\n{\n\tstruct rlimit orig_rlim, rlim;\n\n\tif (set_core_dump_pattern) {\n\t\t/* If we set the core_pattern here, we will attempt to restore it when we\n\t\t * exit. This will be fine if it is a child of ours that core dumps,\n\t\t * but if we ourself core dump, then the core_pattern will not be restored */\n\t\tupdate_core_dump_pattern(core_dump_pattern);\n\t}\n\n\tif (create_core_dump) {\n\t\trlim.rlim_cur = RLIM_INFINITY;\n\t\trlim.rlim_max = RLIM_INFINITY;\n\n\t\tif (getrlimit(RLIMIT_CORE, &orig_rlim) == -1)\n\t\t\tlog_message(LOG_INFO, \"Failed to get core file size\");\n\t\telse if (setrlimit(RLIMIT_CORE, &rlim) == -1)\n\t\t\tlog_message(LOG_INFO, \"Failed to set core file size\");\n\t\telse\n\t\t\tset_child_rlimit(RLIMIT_CORE, &orig_rlim);\n\t}\n}\n\nstatic mode_t\nset_umask(const char *optarg)\n{\n\tlong umask_long;\n\tmode_t umask_val;\n\tchar *endptr;\n\n\tumask_long = strtoll(optarg, &endptr, 0);\n\n\tif (*endptr || umask_long < 0 || umask_long & ~0777L) {\n\t\tfprintf(stderr, \"Invalid --umask option %s\", optarg);\n\t\treturn 0;\n\t}\n\n\tumask_val = umask_long & 0777;\n\tumask(umask_val);\n\n\tumask_cmdline = true;\n\n\treturn umask_val;\n}\n\nvoid\ninitialise_debug_options(void)\n{\n#if defined WITH_DEBUG_OPTIONS && !defined _DEBUG_\n\tchar mask = 0;\n\n\tif (prog_type == PROG_TYPE_PARENT)\n\t\tmask = 1 << PROG_TYPE_PARENT;\n#if _WITH_BFD_\n\telse if (prog_type == PROG_TYPE_BFD)\n\t\tmask = 1 << PROG_TYPE_BFD;\n#endif\n#if _WITH_LVS_\n\telse if (prog_type == PROG_TYPE_CHECKER)\n\t\tmask = 1 << PROG_TYPE_CHECKER;\n#endif\n#if _WITH_VRRP_\n\telse if (prog_type == PROG_TYPE_VRRP)\n\t\tmask = 1 << PROG_TYPE_VRRP;\n#endif\n\n#ifdef _TIMER_CHECK_\n\tdo_timer_check = !!(timer_debug & mask);\n#endif\n#ifdef _SMTP_ALERT_DEBUG_\n\tdo_smtp_alert_debug = !!(smtp_debug & mask);\n#endif\n#ifdef _EPOLL_DEBUG_\n\tdo_epoll_debug = !!(epoll_debug & mask);\n#endif\n#ifdef _EPOLL_THREAD_DUMP_\n\tdo_epoll_thread_dump = !!(epoll_thread_debug & mask);\n#endif\n#ifdef _REGEX_DEBUG_\n\tdo_regex_debug = !!(regex_debug & mask);\n#endif\n#ifdef _WITH_REGEX_TIMERS_\n\tdo_regex_timers = !!(regex_timers & mask);\n#endif\n#ifdef _TSM_DEBUG_\n\tdo_tsm_debug = !!(tsm_debug & mask);\n#endif\n#ifdef _VRRP_FD_DEBUG_\n\tdo_vrrp_fd_debug = !!(vrrp_fd_debug & mask);\n#endif\n#ifdef _NETLINK_TIMERS_\n\tdo_netlink_timers = !!(netlink_timer_debug & mask);\n#endif\n#endif\n}\n\n#ifdef  WITH_DEBUG_OPTIONS\nstatic void\nset_debug_options(const char *options)\n{\n\tchar all_processes, processes;\n\tchar opt;\n\tconst char *opt_p = options;\n\n#ifdef _DEBUG_\n\tall_processes = 1;\n#else\n\tall_processes = (1 << PROG_TYPE_PARENT);\n#if _WITH_BFD_\n\tall_processes |= (1 << PROG_TYPE_BFD);\n#endif\n#if _WITH_LVS_\n\tall_processes |= (1 << PROG_TYPE_CHECKER);\n#endif\n#if _WITH_VRRP_\n\tall_processes |= (1 << PROG_TYPE_VRRP);\n#endif\n#endif\n\n\tif (!options) {\n#ifdef _TIMER_CHECK_\n\t\ttimer_debug = all_processes;\n#endif\n#ifdef _SMTP_ALERT_DEBUG_\n\t\tsmtp_debug = all_processes;\n#endif\n#ifdef _EPOLL_DEBUG_\n\t\tepoll_debug = all_processes;\n#endif\n#ifdef _EPOLL_THREAD_DUMP_\n\t\tepoll_thread_debug = all_processes;\n#endif\n#ifdef _REGEX_DEBUG_\n\t\tregex_debug = all_processes;\n#endif\n#ifdef _WITH_REGEX_TIMERS_\n\t\tregex_timers = all_processes;\n#endif\n#ifdef _TSM_DEBUG_\n\t\ttsm_debug = all_processes;\n#endif\n#ifdef _VRRP_FD_DEBUG_\n\t\tvrrp_fd_debug = all_processes;\n#endif\n#ifdef _NETLINK_TIMERS_\n\t\tnetlink_timer_debug = all_processes;\n#endif\n\n\t\treturn;\n\t}\n\n\topt_p = options;\n\tdo {\n\t\tif (!isupper(*opt_p)) {\n\t\t\tfprintf(stderr, \"Unknown debug option'%c' in '%s'\\n\", *opt_p, options);\n\t\t\treturn;\n\t\t}\n\t\topt = *opt_p++;\n\n#ifdef _DEBUG_\n\t\tprocesses = all_processes;\n#else\n\t\tif (!*opt_p || isupper(*opt_p))\n\t\t\tprocesses = all_processes;\n\t\telse {\n\t\t\tprocesses = 0;\n\t\t\twhile (*opt_p && !isupper(*opt_p)) {\n\t\t\t\tswitch (*opt_p) {\n\t\t\t\tcase 'p':\n\t\t\t\t\tprocesses |= (1 << PROG_TYPE_PARENT);\n\t\t\t\t\tbreak;\n#if _WITH_BFD_\n\t\t\t\tcase 'b':\n\t\t\t\t\tprocesses |= (1 << PROG_TYPE_BFD);\n\t\t\t\t\tbreak;\n#endif\n#if _WITH_LVS_\n\t\t\t\tcase 'c':\n\t\t\t\t\tprocesses |= (1 << PROG_TYPE_CHECKER);\n\t\t\t\t\tbreak;\n#endif\n#if _WITH_VRRP_\n\t\t\t\tcase 'v':\n\t\t\t\t\tprocesses |= (1 << PROG_TYPE_VRRP);\n\t\t\t\t\tbreak;\n#endif\n\t\t\t\tdefault:\n\t\t\t\t\tfprintf(stderr, \"Unknown debug process '%c' in '%s'\\n\", *opt_p, options);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\topt_p++;\n\t\t\t}\n\t\t}\n#endif\n\n\t\tswitch (opt) {\n#ifdef _TIMER_CHECK_\n\t\tcase 'T':\n\t\t\ttimer_debug = processes;\n\t\t\tbreak;\n#endif\n#ifdef _SMTP_ALERT_DEBUG_\n\t\tcase 'M':\n\t\t\tsmtp_debug = processes;\n\t\t\tbreak;\n#endif\n#ifdef _EPOLL_DEBUG_\n\t\tcase 'E':\n\t\t\tepoll_debug = processes;\n\t\t\tbreak;\n#endif\n#ifdef _EPOLL_THREAD_DUMP_\n\t\tcase 'D':\n\t\t\tepoll_thread_debug = processes;\n\t\t\tbreak;\n#endif\n#ifdef _REGEX_DEBUG_\n\t\tcase 'R':\n\t\t\tregex_debug = processes;\n\t\t\tbreak;\n#endif\n#ifdef _WITH_REGEX_TIMERS_\n\t\tcase 'X':\n\t\t\tregex_timers = processes;\n\t\t\tbreak;\n#endif\n#ifdef _TSM_DEBUG_\n\t\tcase 'S':\n\t\t\ttsm_debug = processes;\n\t\t\tbreak;\n#endif\n#ifdef _VRRP_FD_DEBUG_\n\t\tcase 'F':\n\t\t\tvrrp_fd_debug = processes;\n\t\t\tbreak;\n#endif\n#ifdef _NETLINK_TIMERS_\n\t\tcase 'N':\n\t\t\tnetlink_timer_debug = processes;\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\t\tfprintf(stderr, \"Unknown debug type '%c' in '%s'\\n\", opt, options);\n\t\t\treturn;\n\t\t}\n\t} while (opt_p && *opt_p);\n}\n#endif\n\n/* Usage function */\nstatic void\nusage(const char *prog)\n{\n\tfprintf(stderr, \"Usage: %s [OPTION...]\\n\", prog);\n\tfprintf(stderr, \"  -f, --use-file=FILE          Use the specified configuration file\\n\");\n#if defined _WITH_VRRP_ && defined _WITH_LVS_\n\tfprintf(stderr, \"  -P, --vrrp                   Only run with VRRP subsystem\\n\");\n\tfprintf(stderr, \"  -C, --check                  Only run with Health-checker subsystem\\n\");\n#endif\n#ifdef _WITH_BFD_\n\tfprintf(stderr, \"  -B, --no_bfd                 Don't run BFD subsystem\\n\");\n#endif\n\tfprintf(stderr, \"      --all                    Force all child processes to run, even if have no configuration\\n\");\n\tfprintf(stderr, \"  -l, --log-console            Log messages to local console\\n\");\n\tfprintf(stderr, \"  -D, --log-detail             Detailed log messages\\n\");\n\tfprintf(stderr, \"  -S, --log-facility=[0-7]     Set syslog facility to LOG_LOCAL[0-7]\\n\");\n\tfprintf(stderr, \"  -g, --log-file=FILE          Also log to FILE (default /tmp/keepalived.log)\\n\");\n\tfprintf(stderr, \"      --flush-log-file         Flush log file on write\\n\");\n\tfprintf(stderr, \"  -G, --no-syslog              Don't log via syslog\\n\");\n\tfprintf(stderr, \"  -u, --umask=MASK             umask for file creation (in numeric form)\\n\");\n#ifdef _WITH_VRRP_\n\tfprintf(stderr, \"  -X, --release-vips           Drop VIP on transition from signal.\\n\");\n\tfprintf(stderr, \"  -V, --dont-release-vrrp      Don't remove VRRP VIPs and VROUTEs on daemon stop\\n\");\n#endif\n#ifdef _WITH_LVS_\n\tfprintf(stderr, \"  -I, --dont-release-ipvs      Don't remove IPVS topology on daemon stop\\n\");\n#endif\n\tfprintf(stderr, \"  -R, --dont-respawn           Don't respawn child processes\\n\");\n\tfprintf(stderr, \"  -n, --dont-fork              Don't fork the daemon process\\n\");\n\tfprintf(stderr, \"  -d, --dump-conf              Dump the configuration data\\n\");\n\tfprintf(stderr, \"  -p, --pid=FILE               Use specified pidfile for parent process\\n\");\n#ifdef _WITH_VRRP_\n\tfprintf(stderr, \"  -r, --vrrp_pid=FILE          Use specified pidfile for VRRP child process\\n\");\n#endif\n#ifdef _WITH_LVS_\n\tfprintf(stderr, \"  -c, --checkers_pid=FILE      Use specified pidfile for checkers child process\\n\");\n\tfprintf(stderr, \"  -a, --address-monitoring     Report all address additions/deletions notified via netlink\\n\");\n#endif\n#ifdef _WITH_BFD_\n\tfprintf(stderr, \"  -b, --bfd_pid=FILE           Use specified pidfile for BFD child process\\n\");\n#endif\n#ifdef _WITH_SNMP_\n\tfprintf(stderr, \"  -x, --snmp                   Enable SNMP subsystem\\n\");\n\tfprintf(stderr, \"  -A, --snmp-agent-socket=FILE Use the specified socket for master agent\\n\");\n#endif\n#if HAVE_DECL_CLONE_NEWNET\n\tfprintf(stderr, \"  -s, --namespace=NAME         Run in network namespace NAME (overrides config)\\n\");\n#endif\n\tfprintf(stderr, \"  -m, --core-dump              Produce core dump if terminate abnormally\\n\");\n\tfprintf(stderr, \"  -M, --core-dump-pattern=PATN Also set /proc/sys/kernel/core_pattern to PATN (default 'core')\\n\");\n#ifdef _MEM_CHECK_LOG_\n\tfprintf(stderr, \"  -L, --mem-check-log          Log malloc/frees to syslog\\n\");\n#endif\n\tfprintf(stderr, \"  -i, --config-id id           Skip any configuration lines beginning '@' that don't match id\\n\"\n\t\t\t\"                                or any lines beginning @^ that do match.\\n\"\n\t\t\t\"                                The config-id defaults to the node name if option not used\\n\");\n\tfprintf(stderr, \"      --signum=SIGFUNC         Return signal number for STOP, RELOAD, DATA, STATS\"\n#ifdef _WITH_JSON_\n\t\t\t\t\t\t\t\t\", JSON\"\n#endif\n\t\t\t\t\t\t\t\t\"\\n\");\n\tfprintf(stderr, \"  -t, --config-test[=LOG_FILE] Check the configuration for obvious errors, output to\\n\"\n\t\t\t\"                                stderr by default\\n\");\n#ifdef _WITH_PERF_\n\tfprintf(stderr, \"      --perf[=PERF_TYPE]       Collect perf data, PERF_TYPE=all, run(default) or end\\n\");\n#endif\n#ifdef WITH_DEBUG_OPTIONS\n\tfprintf(stderr, \"      --debug[=...]            Enable debug options. p, b, c, v specify parent, bfd, checker and vrrp processes\\n\");\n#ifdef _TIMER_CHECK_\n\tfprintf(stderr, \"                                   T - timer debug\\n\");\n#endif\n#ifdef _SMTP_ALERT_DEBUG_\n\tfprintf(stderr, \"                                   M - email alert debug\\n\");\n#endif\n#ifdef _EPOLL_DEBUG_\n\tfprintf(stderr, \"                                   E - epoll debug\\n\");\n#endif\n#ifdef _EPOLL_THREAD_DUMP_\n\tfprintf(stderr, \"                                   D - epoll thread dump debug\\n\");\n#endif\n#ifdef _VRRP_FD_DEBUG\n\tfprintf(stderr, \"                                   F - vrrp fd dump debug\\n\");\n#endif\n#ifdef _REGEX_DEBUG_\n\tfprintf(stderr, \"                                   R - regex debug\\n\");\n#endif\n#ifdef _WITH_REGEX_TIMERS_\n\tfprintf(stderr, \"                                   X - regex timers\\n\");\n#endif\n#ifdef _TSM_DEBUG_\n\tfprintf(stderr, \"                                   S - TSM debug\\n\");\n#endif\n#ifdef _NETLINK_TIMERS_\n\tfprintf(stderr, \"                                   N - netlink timer debug\\n\");\n#endif\n\tfprintf(stderr, \"                                 Example --debug=TpMEvcp\\n\");\n#endif\n\tfprintf(stderr, \"  -v, --version                Display the version number\\n\");\n\tfprintf(stderr, \"  -h, --help                   Display this help message\\n\");\n}\n\n/* Command line parser */\nstatic bool\nparse_cmdline(int argc, char **argv)\n{\n\tint c;\n\tbool reopen_log = false;\n\tint signum;\n\tstruct utsname uname_buf;\n\tint longindex;\n\tint curind;\n\tbool bad_option = false;\n\tunsigned facility;\n\tmode_t new_umask_val;\n\n\tstruct option long_options[] = {\n\t\t{\"use-file\",\t\trequired_argument,\tNULL, 'f'},\n#if defined _WITH_VRRP_ && defined _WITH_LVS_\n\t\t{\"vrrp\",\t\tno_argument,\t\tNULL, 'P'},\n\t\t{\"check\",\t\tno_argument,\t\tNULL, 'C'},\n#endif\n#ifdef _WITH_BFD_\n\t\t{\"no_bfd\",\t\tno_argument,\t\tNULL, 'B'},\n#endif\n\t\t{\"all\",\t\t\tno_argument,\t\tNULL,  3 },\n\t\t{\"log-console\",\t\tno_argument,\t\tNULL, 'l'},\n\t\t{\"log-detail\",\t\tno_argument,\t\tNULL, 'D'},\n\t\t{\"log-facility\",\trequired_argument,\tNULL, 'S'},\n\t\t{\"log-file\",\t\toptional_argument,\tNULL, 'g'},\n\t\t{\"flush-log-file\",\tno_argument,\t\tNULL,  2 },\n\t\t{\"no-syslog\",\t\tno_argument,\t\tNULL, 'G'},\n\t\t{\"umask\",\t\trequired_argument,\tNULL, 'u'},\n#ifdef _WITH_VRRP_\n\t\t{\"release-vips\",\tno_argument,\t\tNULL, 'X'},\n\t\t{\"dont-release-vrrp\",\tno_argument,\t\tNULL, 'V'},\n#endif\n#ifdef _WITH_LVS_\n\t\t{\"dont-release-ipvs\",\tno_argument,\t\tNULL, 'I'},\n#endif\n\t\t{\"dont-respawn\",\tno_argument,\t\tNULL, 'R'},\n\t\t{\"dont-fork\",\t\tno_argument,\t\tNULL, 'n'},\n\t\t{\"dump-conf\",\t\tno_argument,\t\tNULL, 'd'},\n\t\t{\"pid\",\t\t\trequired_argument,\tNULL, 'p'},\n#ifdef _WITH_VRRP_\n\t\t{\"vrrp_pid\",\t\trequired_argument,\tNULL, 'r'},\n#endif\n#ifdef _WITH_LVS_\n\t\t{\"checkers_pid\",\trequired_argument,\tNULL, 'c'},\n\t\t{\"address-monitoring\",\tno_argument,\t\tNULL, 'a'},\n#endif\n#ifdef _WITH_BFD_\n\t\t{\"bfd_pid\",\t\trequired_argument,\tNULL, 'b'},\n#endif\n#ifdef _WITH_SNMP_\n\t\t{\"snmp\",\t\tno_argument,\t\tNULL, 'x'},\n\t\t{\"snmp-agent-socket\",\trequired_argument,\tNULL, 'A'},\n#endif\n\t\t{\"core-dump\",\t\tno_argument,\t\tNULL, 'm'},\n\t\t{\"core-dump-pattern\",\toptional_argument,\tNULL, 'M'},\n#ifdef _MEM_CHECK_LOG_\n\t\t{\"mem-check-log\",\tno_argument,\t\tNULL, 'L'},\n#endif\n#if HAVE_DECL_CLONE_NEWNET\n\t\t{\"namespace\",\t\trequired_argument,\tNULL, 's'},\n#endif\n\t\t{\"config-id\",\t\trequired_argument,\tNULL, 'i'},\n\t\t{\"signum\",\t\trequired_argument,\tNULL,  4 },\n\t\t{\"config-test\",\t\toptional_argument,\tNULL, 't'},\n#ifdef _WITH_PERF_\n\t\t{\"perf\",\t\toptional_argument,\tNULL,  5 },\n#endif\n#ifdef WITH_DEBUG_OPTIONS\n\t\t{\"debug\",\t\toptional_argument,\tNULL,  6 },\n#endif\n\t\t{\"version\",\t\tno_argument,\t\tNULL, 'v'},\n\t\t{\"help\",\t\tno_argument,\t\tNULL, 'h'},\n\n\t\t{NULL,\t\t\t0,\t\t\tNULL,  0 }\n\t};\n\n\t/* Unfortunately, if a short option is used, getopt_long() doesn't change the value\n\t * of longindex, so we need to ensure that before calling getopt_long(), longindex\n\t * is set to a known invalid value */\n\tcurind = optind;\n\twhile (longindex = -1, (c = getopt_long(argc, argv, \":vhlndu:DRS:f:p:i:mM::g::Gt::\"\n#if defined _WITH_VRRP_ && defined _WITH_LVS_\n\t\t\t\t\t    \"PC\"\n#endif\n#ifdef _WITH_VRRP_\n\t\t\t\t\t    \"r:VX\"\n#endif\n#ifdef _WITH_LVS_\n\t\t\t\t\t    \"ac:I\"\n#endif\n#ifdef _WITH_BFD_\n\t\t\t\t\t    \"Bb:\"\n#endif\n#ifdef _WITH_SNMP_\n\t\t\t\t\t    \"xA:\"\n#endif\n#ifdef _MEM_CHECK_LOG_\n\t\t\t\t\t    \"L\"\n#endif\n#if HAVE_DECL_CLONE_NEWNET\n\t\t\t\t\t    \"s:\"\n#endif\n\t\t\t\t, long_options, &longindex)) != -1) {\n\n\t\t/* Check for an empty option argument. For example --use-file= returns\n\t\t * a 0 length option, which we don't want */\n\t\tif (longindex >= 0 && long_options[longindex].has_arg == required_argument && optarg && !optarg[0]) {\n\t\t\tc = ':';\n\t\t\toptarg = NULL;\n\t\t}\n\n\t\tswitch (c) {\n\t\tcase 'v':\n\t\t\tfprintf(stderr, \"%s\", version_string);\n#ifdef GIT_COMMIT\n\t\t\tfprintf(stderr, \", git commit %s\", GIT_COMMIT);\n#endif\n\t\t\tfprintf(stderr, \"\\n\\n%s\\n\\n\", COPYRIGHT_STRING);\n\t\t\tfprintf(stderr, \"Built with kernel headers for Linux %d.%d.%d\\n\",\n\t\t\t\t\t\t(LINUX_VERSION_CODE >> 16) & 0xff,\n\t\t\t\t\t\t(LINUX_VERSION_CODE >>  8) & 0xff,\n\t\t\t\t\t\t(LINUX_VERSION_CODE      ) & 0xff);\n\t\t\tuname(&uname_buf);\n\t\t\tfprintf(stderr, \"Running on %s %s %s\\n\\n\", uname_buf.sysname, uname_buf.release, uname_buf.version);\n\t\t\tfprintf(stderr, \"configure options: %s\\n\\n\", KEEPALIVED_CONFIGURE_OPTIONS);\n\t\t\tfprintf(stderr, \"Config options: %s\\n\\n\", CONFIGURATION_OPTIONS);\n\t\t\tfprintf(stderr, \"System options: %s\\n\", SYSTEM_OPTIONS);\n\t\t\texit(0);\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\tusage(argv[0]);\n\t\t\texit(0);\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\t__set_bit(LOG_CONSOLE_BIT, &debug);\n\t\t\treopen_log = true;\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\t__set_bit(DONT_FORK_BIT, &debug);\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\t__set_bit(DUMP_CONF_BIT, &debug);\n\t\t\tbreak;\n#ifdef _WITH_VRRP_\n\t\tcase 'V':\n\t\t\t__set_bit(DONT_RELEASE_VRRP_BIT, &debug);\n\t\t\tbreak;\n#endif\n#ifdef _WITH_LVS_\n\t\tcase 'I':\n\t\t\t__set_bit(DONT_RELEASE_IPVS_BIT, &debug);\n\t\t\tbreak;\n#endif\n\t\tcase 'D':\n\t\t\tif (__test_bit(LOG_DETAIL_BIT, &debug))\n\t\t\t\t__set_bit(LOG_EXTRA_DETAIL_BIT, &debug);\n\t\t\telse\n\t\t\t\t__set_bit(LOG_DETAIL_BIT, &debug);\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\t__set_bit(DONT_RESPAWN_BIT, &debug);\n\t\t\tbreak;\n#ifdef _WITH_VRRP_\n\t\tcase 'X':\n\t\t\t__set_bit(RELEASE_VIPS_BIT, &debug);\n\t\t\tbreak;\n#endif\n\t\tcase 'S':\n\t\t\tif (!read_unsigned(optarg, &facility, 0, LOG_FACILITY_MAX, false))\n\t\t\t\tfprintf(stderr, \"Invalid log facility '%s'\\n\", optarg);\n\t\t\telse {\n\t\t\t\tlog_facility = LOG_FACILITY[facility].facility;\n\t\t\t\treopen_log = true;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'g':\n\t\t\tif (optarg && optarg[0])\n\t\t\t\tlog_file_name = optarg;\n\t\t\telse\n\t\t\t\tlog_file_name = \"/tmp/keepalived.log\";\n\t\t\topen_log_file(log_file_name, NULL, NULL, NULL);\n\t\t\tbreak;\n\t\tcase 'G':\n\t\t\t__set_bit(NO_SYSLOG_BIT, &debug);\n\t\t\treopen_log = true;\n\t\t\tbreak;\n\t\tcase 'u':\n\t\t\tnew_umask_val = set_umask(optarg);\n\t\t\tif (umask_cmdline)\n\t\t\t\tumask_val = new_umask_val;\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\t__set_bit(CONFIG_TEST_BIT, &debug);\n\t\t\t__set_bit(DONT_RESPAWN_BIT, &debug);\n\t\t\t__set_bit(DONT_FORK_BIT, &debug);\n\t\t\t__set_bit(NO_SYSLOG_BIT, &debug);\n\t\t\tif (optarg && optarg[0]) {\n\t\t\t\tint fd = open(optarg, O_WRONLY | O_APPEND | O_CREAT, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n\t\t\t\tif (fd == -1) {\n\t\t\t\t\tfprintf(stderr, \"Unable to open config-test log file %s\\n\", optarg);\n\t\t\t\t\texit(EXIT_FAILURE);\n\t\t\t\t}\n\t\t\t\tdup2(fd, STDERR_FILENO);\n\t\t\t\tclose(fd);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tconf_file = optarg;\n\t\t\tbreak;\n\t\tcase 2:\t\t/* --flush-log-file */\n\t\t\tset_flush_log_file();\n\t\t\tbreak;\n#if defined _WITH_VRRP_ && defined _WITH_LVS_\n\t\tcase 'P':\n\t\t\t__clear_bit(DAEMON_CHECKERS, &daemon_mode);\n\t\t\tbreak;\n\t\tcase 'C':\n\t\t\t__clear_bit(DAEMON_VRRP, &daemon_mode);\n\t\t\tbreak;\n#endif\n#ifdef _WITH_BFD_\n\t\tcase 'B':\n\t\t\t__clear_bit(DAEMON_BFD, &daemon_mode);\n\t\t\tbreak;\n#endif\n\t\tcase 'p':\n\t\t\tmain_pidfile = optarg;\n\t\t\tbreak;\n#ifdef _WITH_LVS_\n\t\tcase 'c':\n\t\t\tcheckers_pidfile = optarg;\n\t\t\tbreak;\n\t\tcase 'a':\n\t\t\t__set_bit(LOG_ADDRESS_CHANGES, &debug);\n\t\t\tbreak;\n#endif\n#ifdef _WITH_VRRP_\n\t\tcase 'r':\n\t\t\tvrrp_pidfile = optarg;\n\t\t\tbreak;\n#endif\n#ifdef _WITH_BFD_\n\t\tcase 'b':\n\t\t\tbfd_pidfile = optarg;\n\t\t\tbreak;\n#endif\n#ifdef _WITH_SNMP_\n\t\tcase 'x':\n\t\t\tsnmp = 1;\n\t\t\tbreak;\n\t\tcase 'A':\n\t\t\tsnmp_socket = optarg;\n\t\t\tbreak;\n#endif\n\t\tcase 'M':\n\t\t\tset_core_dump_pattern = true;\n\t\t\tif (optarg && optarg[0])\n\t\t\t\tcore_dump_pattern = optarg;\n\t\t\t/* ... falls through ... */\n\t\tcase 'm':\n\t\t\tcreate_core_dump = true;\n\t\t\tbreak;\n#ifdef _MEM_CHECK_LOG_\n\t\tcase 'L':\n\t\t\t__set_bit(MEM_CHECK_LOG_BIT, &debug);\n\t\t\tbreak;\n#endif\n#if HAVE_DECL_CLONE_NEWNET\n\t\tcase 's':\n\t\t\toverride_namespace = MALLOC(strlen(optarg) + 1);\n\t\t\tstrcpy(override_namespace, optarg);\n\t\t\tbreak;\n#endif\n\t\tcase 'i':\n\t\t\tFREE_PTR(config_id);\n\t\t\tconfig_id = MALLOC(strlen(optarg) + 1);\n\t\t\tstrcpy(config_id, optarg);\n\t\t\tbreak;\n\t\tcase 4:\t\t\t/* --signum */\n\t\t\tsignum = get_signum(optarg);\n\t\t\tif (signum == -1) {\n\t\t\t\tfprintf(stderr, \"Unknown sigfunc %s\\n\", optarg);\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\tprintf(\"%d\\n\", signum);\n\t\t\texit(0);\n\t\t\tbreak;\n\t\tcase 3:\t\t\t/* --all */\n\t\t\t__set_bit(RUN_ALL_CHILDREN, &daemon_mode);\n#ifdef _WITH_VRRP_\n\t\t\t__set_bit(DAEMON_VRRP, &daemon_mode);\n#endif\n#ifdef _WITH_LVS_\n\t\t\t__set_bit(DAEMON_CHECKERS, &daemon_mode);\n#endif\n#ifdef _WITH_BFD_\n\t\t\t__set_bit(DAEMON_BFD, &daemon_mode);\n#endif\n\t\t\tbreak;\n#ifdef _WITH_PERF_\n\t\tcase 5:\n\t\t\tif (optarg && optarg[0]) {\n\t\t\t\tif (!strcmp(optarg, \"run\"))\n\t\t\t\t\tperf_run = PERF_RUN;\n\t\t\t\telse if (!strcmp(optarg, \"all\"))\n\t\t\t\t\tperf_run = PERF_ALL;\n\t\t\t\telse if (!strcmp(optarg, \"end\"))\n\t\t\t\t\tperf_run = PERF_END;\n\t\t\t\telse\n\t\t\t\t\tlog_message(LOG_INFO, \"Unknown perf start point %s\", optarg);\n\t\t\t}\n\t\t\telse\n\t\t\t\tperf_run = PERF_RUN;\n\n\t\t\tbreak;\n#endif\n#ifdef WITH_DEBUG_OPTIONS\n\t\tcase 6:\n\t\t\tset_debug_options(optarg && optarg[0] ? optarg : NULL);\n\t\t\tbreak;\n#endif\n\t\tcase '?':\n\t\t\tif (optopt && argv[curind][1] != '-')\n\t\t\t\tfprintf(stderr, \"Unknown option -%c\\n\", optopt);\n\t\t\telse\n\t\t\t\tfprintf(stderr, \"Unknown option %s\\n\", argv[curind]);\n\t\t\tbad_option = true;\n\t\t\tbreak;\n\t\tcase ':':\n\t\t\tif (optopt && argv[curind][1] != '-')\n\t\t\t\tfprintf(stderr, \"Missing parameter for option -%c\\n\", optopt);\n\t\t\telse\n\t\t\t\tfprintf(stderr, \"Missing parameter for option --%s\\n\", long_options[longindex].name);\n\t\t\tbad_option = true;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\texit(1);\n\t\t\tbreak;\n\t\t}\n\t\tcurind = optind;\n\t}\n\n\tif (optind < argc) {\n\t\tprintf(\"Unexpected argument(s): \");\n\t\twhile (optind < argc)\n\t\t\tprintf(\"%s \", argv[optind++]);\n\t\tprintf(\"\\n\");\n\t}\n\n\tif (bad_option)\n\t\texit(1);\n\n\treturn reopen_log;\n}\n\n#ifdef THREAD_DUMP\nstatic void\nregister_parent_thread_addresses(void)\n{\n\tregister_scheduler_addresses();\n\tregister_signal_thread_addresses();\n\n#ifdef _WITH_LVS_\n\tregister_check_parent_addresses();\n#endif\n#ifdef _WITH_VRRP_\n\tregister_vrrp_parent_addresses();\n#endif\n#ifdef _WITH_BFD_\n\tregister_bfd_parent_addresses();\n#endif\n\n#ifndef _DEBUG_\n\tregister_signal_handler_address(\"propagate_signal\", propagate_signal);\n\tregister_signal_handler_address(\"sigend\", sigend);\n#endif\n\tregister_signal_handler_address(\"thread_child_handler\", thread_child_handler);\n}\n#endif\n\n/* Entry point */\nint\nkeepalived_main(int argc, char **argv)\n{\n\tbool report_stopped = true;\n\tstruct utsname uname_buf;\n\tchar *end;\n\n\t/* Ensure time_now is set. We then don't have to check anywhere\n\t * else if it is set. */\n\tset_time_now();\n\n\t/* Save command line options in case need to log them later */\n\tsave_cmd_line_options(argc, argv);\n\n\t/* Init debugging level */\n\tdebug = 0;\n\n\t/* We are the parent process */\n#ifndef _DEBUG_\n\tprog_type = PROG_TYPE_PARENT;\n#endif\n\n\t/* Initialise daemon_mode */\n#ifdef _WITH_VRRP_\n\t__set_bit(DAEMON_VRRP, &daemon_mode);\n#endif\n#ifdef _WITH_LVS_\n\t__set_bit(DAEMON_CHECKERS, &daemon_mode);\n#endif\n#ifdef _WITH_BFD_\n\t__set_bit(DAEMON_BFD, &daemon_mode);\n#endif\n\n\t/* Set default file creation mask */\n\tumask(022);\n\n\t/* Open log with default settings so we can log initially */\n\topenlog(PACKAGE_NAME, LOG_PID, log_facility);\n\n#ifdef _MEM_CHECK_\n\tmem_log_init(PACKAGE_NAME, \"Parent process\");\n#endif\n\n\t/* Some functionality depends on kernel version, so get the version here */\n\tif (uname(&uname_buf))\n\t\tlog_message(LOG_INFO, \"Unable to get uname() information - error %d\", errno);\n\telse {\n\t\tos_major = (unsigned)strtoul(uname_buf.release, &end, 10);\n\t\tif (*end != '.')\n\t\t\tos_major = 0;\n\t\telse {\n\t\t\tos_minor = (unsigned)strtoul(end + 1, &end, 10);\n\t\t\tif (*end != '.')\n\t\t\t\tos_major = 0;\n\t\t\telse {\n\t\t\t\tif (!isdigit(end[1]))\n\t\t\t\t\tos_major = 0;\n\t\t\t\telse\n\t\t\t\t\tos_release = (unsigned)strtoul(end + 1, &end, 10);\n\t\t\t}\n\t\t}\n\t\tif (!os_major)\n\t\t\tlog_message(LOG_INFO, \"Unable to parse kernel version %s\", uname_buf.release);\n\n\t\t/* config_id defaults to hostname */\n\t\tif (!config_id) {\n\t\t\tend = strchrnul(uname_buf.nodename, '.');\n\t\t\tconfig_id = MALLOC((size_t)(end - uname_buf.nodename) + 1);\n\t\t\tstrncpy(config_id, uname_buf.nodename, (size_t)(end - uname_buf.nodename));\n\t\t\tconfig_id[end - uname_buf.nodename] = '\\0';\n\t\t}\n\t}\n\n\t/*\n\t * Parse command line and set debug level.\n\t * bits 0..7 reserved by main.c\n\t */\n\tif (parse_cmdline(argc, argv)) {\n\t\tcloselog();\n\t\tif (!__test_bit(NO_SYSLOG_BIT, &debug))\n\t\t\topenlog(PACKAGE_NAME, LOG_PID | ((__test_bit(LOG_CONSOLE_BIT, &debug)) ? LOG_CONS : 0) , log_facility);\n\t}\n\n\tif (__test_bit(LOG_CONSOLE_BIT, &debug))\n\t\tenable_console_log();\n\n#ifdef GIT_COMMIT\n\tlog_message(LOG_INFO, \"Starting %s, git commit %s\", version_string, GIT_COMMIT);\n#else\n\tlog_message(LOG_INFO, \"Starting %s\", version_string);\n#endif\n\n\t/* Handle any core file requirements */\n\tcore_dump_init();\n\n\tif (os_major) {\n\t\tif (KERNEL_VERSION(os_major, os_minor, os_release) < LINUX_VERSION_CODE) {\n\t\t\t/* keepalived was build for a later kernel version */\n\t\t\tlog_message(LOG_INFO, \"WARNING - keepalived was build for newer Linux %d.%d.%d, running on %s %s %s\",\n\t\t\t\t\t(LINUX_VERSION_CODE >> 16) & 0xff,\n\t\t\t\t\t(LINUX_VERSION_CODE >>  8) & 0xff,\n\t\t\t\t\t(LINUX_VERSION_CODE      ) & 0xff,\n\t\t\t\t\tuname_buf.sysname, uname_buf.release, uname_buf.version);\n\t\t} else {\n\t\t\t/* keepalived was build for a later kernel version */\n\t\t\tlog_message(LOG_INFO, \"Running on %s %s %s (built for Linux %d.%d.%d)\",\n\t\t\t\t\tuname_buf.sysname, uname_buf.release, uname_buf.version,\n\t\t\t\t\t(LINUX_VERSION_CODE >> 16) & 0xff,\n\t\t\t\t\t(LINUX_VERSION_CODE >>  8) & 0xff,\n\t\t\t\t\t(LINUX_VERSION_CODE      ) & 0xff);\n\t\t}\n\t}\n\n#ifndef _DEBUG_\n\tlog_command_line(0);\n#endif\n\n\t/* Check we can read the configuration file(s).\n\t   NOTE: the working directory will be / if we\n\t   forked, but will be the current working directory\n\t   when keepalived was run if we haven't forked.\n\t   This means that if any config file names are not\n\t   absolute file names, the behaviour will be different\n\t   depending on whether we forked or not. */\n\tif (!check_conf_file(conf_file)) {\n\t\tif (__test_bit(CONFIG_TEST_BIT, &debug))\n\t\t\tconfig_test_exit();\n\n\t\tgoto end;\n\t}\n\n\tglobal_data = alloc_global_data();\n\tglobal_data->umask = umask_val;\n\n\tread_config_file();\n\n\tinit_global_data(global_data, NULL);\n\n#if HAVE_DECL_CLONE_NEWNET\n\tif (override_namespace) {\n\t\tif (global_data->network_namespace) {\n\t\t\tlog_message(LOG_INFO, \"Overriding config net_namespace '%s' with command line namespace '%s'\", global_data->network_namespace, override_namespace);\n\t\t\tFREE(global_data->network_namespace);\n\t\t}\n\t\tglobal_data->network_namespace = override_namespace;\n\t\toverride_namespace = NULL;\n\t}\n#endif\n\n\tif (!__test_bit(CONFIG_TEST_BIT, &debug) &&\n\t    (global_data->instance_name\n#if HAVE_DECL_CLONE_NEWNET\n\t     || global_data->network_namespace\n#endif\n\t\t\t\t\t      )) {\n\t\tif ((syslog_ident = make_syslog_ident(PACKAGE_NAME))) {\n\t\t\tlog_message(LOG_INFO, \"Changing syslog ident to %s\", syslog_ident);\n\t\t\tcloselog();\n\t\t\topenlog(syslog_ident, LOG_PID | ((__test_bit(LOG_CONSOLE_BIT, &debug)) ? LOG_CONS : 0), log_facility);\n\t\t}\n\t\telse\n\t\t\tlog_message(LOG_INFO, \"Unable to change syslog ident\");\n\n\t\tuse_pid_dir = true;\n\n\t\topen_log_file(log_file_name,\n\t\t\t\tNULL,\n#if HAVE_DECL_CLONE_NEWNET\n\t\t\t\tglobal_data->network_namespace,\n#else\n\t\t\t\tNULL,\n#endif\n\t\t\t\tglobal_data->instance_name);\n\t}\n\n\t/* Initialise pointer to child finding function */\n\tset_child_finder_name(find_keepalived_child_name);\n\n\tif (!__test_bit(CONFIG_TEST_BIT, &debug)) {\n\t\tif (use_pid_dir) {\n\t\t\t/* Create the directory for pid files */\n\t\t\tcreate_pid_dir();\n\t\t}\n\t}\n\n#if HAVE_DECL_CLONE_NEWNET\n\tif (global_data->network_namespace) {\n\t\tif (global_data->network_namespace && !set_namespaces(global_data->network_namespace)) {\n\t\t\tlog_message(LOG_ERR, \"Unable to set network namespace %s - exiting\", global_data->network_namespace);\n\t\t\tgoto end;\n\t\t}\n\t}\n#endif\n\n\tif (!__test_bit(CONFIG_TEST_BIT, &debug)) {\n\t\tif (global_data->instance_name) {\n\t\t\tif (!main_pidfile && (main_pidfile = make_pidfile_name(KEEPALIVED_PID_DIR KEEPALIVED_PID_FILE, global_data->instance_name, PID_EXTENSION)))\n\t\t\t\tfree_main_pidfile = true;\n#ifdef _WITH_LVS_\n\t\t\tif (!checkers_pidfile && (checkers_pidfile = make_pidfile_name(KEEPALIVED_PID_DIR CHECKERS_PID_FILE, global_data->instance_name, PID_EXTENSION)))\n\t\t\t\tfree_checkers_pidfile = true;\n#endif\n#ifdef _WITH_VRRP_\n\t\t\tif (!vrrp_pidfile && (vrrp_pidfile = make_pidfile_name(KEEPALIVED_PID_DIR VRRP_PID_FILE, global_data->instance_name, PID_EXTENSION)))\n\t\t\t\tfree_vrrp_pidfile = true;\n#endif\n#ifdef _WITH_BFD_\n\t\t\tif (!bfd_pidfile && (bfd_pidfile = make_pidfile_name(KEEPALIVED_PID_DIR VRRP_PID_FILE, global_data->instance_name, PID_EXTENSION)))\n\t\t\t\tfree_bfd_pidfile = true;\n#endif\n\t\t}\n\n\t\tif (use_pid_dir) {\n\t\t\tif (!main_pidfile)\n\t\t\t\tmain_pidfile = KEEPALIVED_PID_DIR KEEPALIVED_PID_FILE PID_EXTENSION;\n#ifdef _WITH_LVS_\n\t\t\tif (!checkers_pidfile)\n\t\t\t\tcheckers_pidfile = KEEPALIVED_PID_DIR CHECKERS_PID_FILE PID_EXTENSION;\n#endif\n#ifdef _WITH_VRRP_\n\t\t\tif (!vrrp_pidfile)\n\t\t\t\tvrrp_pidfile = KEEPALIVED_PID_DIR VRRP_PID_FILE PID_EXTENSION;\n#endif\n#ifdef _WITH_BFD_\n\t\t\tif (!bfd_pidfile)\n\t\t\t\tbfd_pidfile = KEEPALIVED_PID_DIR BFD_PID_FILE PID_EXTENSION;\n#endif\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (!main_pidfile)\n\t\t\t\tmain_pidfile = PID_DIR KEEPALIVED_PID_FILE PID_EXTENSION;\n#ifdef _WITH_LVS_\n\t\t\tif (!checkers_pidfile)\n\t\t\t\tcheckers_pidfile = PID_DIR CHECKERS_PID_FILE PID_EXTENSION;\n#endif\n#ifdef _WITH_VRRP_\n\t\t\tif (!vrrp_pidfile)\n\t\t\t\tvrrp_pidfile = PID_DIR VRRP_PID_FILE PID_EXTENSION;\n#endif\n#ifdef _WITH_BFD_\n\t\t\tif (!bfd_pidfile)\n\t\t\t\tbfd_pidfile = PID_DIR BFD_PID_FILE PID_EXTENSION;\n#endif\n\t\t}\n\n\t\t/* Check if keepalived is already running */\n\t\tif (keepalived_running(daemon_mode)) {\n\t\t\tlog_message(LOG_INFO, \"daemon is already running\");\n\t\t\treport_stopped = false;\n\t\t\tgoto end;\n\t\t}\n\t}\n\n\t/* daemonize process */\n\tif (!__test_bit(DONT_FORK_BIT, &debug) &&\n\t    xdaemon(false, false, true) > 0) {\n\t\tcloselog();\n\t\tFREE_PTR(config_id);\n\t\tFREE_PTR(orig_core_dump_pattern);\n\t\tclose_std_fd();\n\t\texit(0);\n\t}\n\n#ifdef _MEM_CHECK_\n\tenable_mem_log_termination();\n#endif\n\n\tif (__test_bit(CONFIG_TEST_BIT, &debug)) {\n\t\tvalidate_config();\n\n\t\tconfig_test_exit();\n\t}\n\n\t/* write the father's pidfile */\n\tif (!pidfile_write(main_pidfile, getpid()))\n\t\tgoto end;\n\n\t/* Create the master thread */\n\tmaster = thread_make_master();\n\n\t/* Signal handling initialization  */\n\tsignal_init();\n\n\t/* Init daemon */\n\tif (!start_keepalived())\n\t\tlog_message(LOG_INFO, \"Warning - keepalived has no configuration to run\");\n\n\tinitialise_debug_options();\n\n#ifdef THREAD_DUMP\n\tregister_parent_thread_addresses();\n#endif\n\n\t/* Launch the scheduling I/O multiplexer */\n\tlaunch_thread_scheduler(master);\n\n\t/* Finish daemon process */\n\tstop_keepalived();\n\n#ifdef THREAD_DUMP\n\tderegister_thread_addresses();\n#endif\n\n\t/*\n\t * Reached when terminate signal catched.\n\t * finally return from system\n\t */\nend:\n\tif (report_stopped) {\n#ifdef GIT_COMMIT\n\t\tlog_message(LOG_INFO, \"Stopped %s, git commit %s\", version_string, GIT_COMMIT);\n#else\n\t\tlog_message(LOG_INFO, \"Stopped %s\", version_string);\n#endif\n\t}\n\n#if HAVE_DECL_CLONE_NEWNET\n\tif (global_data && global_data->network_namespace)\n\t\tclear_namespaces();\n#endif\n\n\tif (use_pid_dir)\n\t\tremove_pid_dir();\n\n\t/* Restore original core_pattern if necessary */\n\tif (orig_core_dump_pattern)\n\t\tupdate_core_dump_pattern(orig_core_dump_pattern);\n\n\tfree_parent_mallocs_startup(false);\n\tfree_parent_mallocs_exit();\n\tfree_global_data(global_data);\n\n\tcloselog();\n\n#ifndef _MEM_CHECK_LOG_\n\tFREE_PTR(syslog_ident);\n#else\n\tif (syslog_ident)\n\t\tfree(syslog_ident);\n#endif\n\tclose_std_fd();\n\n\texit(KEEPALIVED_EXIT_OK);\n}\n", "/*\n * Soft:        Keepalived is a failover program for the LVS project\n *              <www.linuxvirtualserver.org>. It monitor & manipulate\n *              a loadbalanced server pool using multi-layer checks.\n *\n * Part:        pidfile utility.\n *\n * Author:      Alexandre Cassen, <acassen@linux-vs.org>\n *\n *              This program is distributed in the hope that it will be useful,\n *              but WITHOUT ANY WARRANTY; without even the implied warranty of\n *              MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n *              See the GNU General Public License for more details.\n *\n *              This program is free software; you can redistribute it and/or\n *              modify it under the terms of the GNU General Public License\n *              as published by the Free Software Foundation; either version\n *              2 of the License, or (at your option) any later version.\n *\n * Copyright (C) 2001-2017 Alexandre Cassen, <acassen@gmail.com>\n */\n\n#include \"config.h\"\n\n#include <errno.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <stdio.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys/stat.h>\n\n#include \"logger.h\"\n#include \"pidfile.h\"\n#include \"main.h\"\n#include \"bitops.h\"\n#include \"utils.h\"\n\nconst char *pid_directory = PID_DIR PACKAGE;\n\n/* Create the directory for non-standard pid files */\nvoid\ncreate_pid_dir(void)\n{\n\tif (mkdir(pid_directory, S_IRWXU | S_IRGRP | S_IXGRP | S_IROTH | S_IXOTH) && errno != EEXIST) {\n\t\tlog_message(LOG_INFO, \"Unable to create directory %s\", pid_directory);\n\t\treturn;\n\t}\n}\n\nvoid\nremove_pid_dir(void)\n{\n\tif (rmdir(pid_directory) && errno != ENOTEMPTY && errno != EBUSY)\n\t\tlog_message(LOG_INFO, \"unlink of %s failed - error (%d) '%s'\", pid_directory, errno, strerror(errno));\n}\n\n/* Create the running daemon pidfile */\nint\npidfile_write(const char *pid_file, int pid)\n{\n\tFILE *pidfile = NULL;\n\tint pidfd = creat(pid_file, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n\n\tif (pidfd != -1) pidfile = fdopen(pidfd, \"w\");\n\n\tif (!pidfile) {\n\t\tlog_message(LOG_INFO, \"pidfile_write : Cannot open %s pidfile\",\n\t\t       pid_file);\n\t\treturn 0;\n\t}\n\tfprintf(pidfile, \"%d\\n\", pid);\n\tfclose(pidfile);\n\treturn 1;\n}\n\n/* Remove the running daemon pidfile */\nvoid\npidfile_rm(const char *pid_file)\n{\n\tunlink(pid_file);\n}\n\n/* return the daemon running state */\nstatic int\nprocess_running(const char *pid_file)\n{\n\tFILE *pidfile = fopen(pid_file, \"r\");\n\tpid_t pid = 0;\n\tint ret;\n\n\t/* No pidfile */\n\tif (!pidfile)\n\t\treturn 0;\n\n\tret = fscanf(pidfile, \"%d\", &pid);\n\tfclose(pidfile);\n\tif (ret != 1) {\n\t\tlog_message(LOG_INFO, \"Error reading pid file %s\", pid_file);\n\t\tpid = 0;\n\t\tpidfile_rm(pid_file);\n\t}\n\n\t/* What should we return - we don't know if it is running or not. */\n\tif (!pid)\n\t\treturn 1;\n\n\t/* If no process is attached to pidfile, remove it */\n\tif (kill(pid, 0)) {\n\t\tlog_message(LOG_INFO, \"Remove a zombie pid file %s\", pid_file);\n\t\tpidfile_rm(pid_file);\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\n/* Return parent process daemon state */\nbool\nkeepalived_running(unsigned long mode)\n{\n\tif (process_running(main_pidfile))\n\t\treturn true;\n#ifdef _WITH_VRRP_\n\tif (__test_bit(DAEMON_VRRP, &mode) && process_running(vrrp_pidfile))\n\t\treturn true;\n#endif\n#ifdef _WITH_LVS_\n\tif (__test_bit(DAEMON_CHECKERS, &mode) && process_running(checkers_pidfile))\n\t\treturn true;\n#endif\n#ifdef _WITH_BFD_\n\tif (__test_bit(DAEMON_BFD, &mode) && process_running(bfd_pidfile))\n\t\treturn true;\n#endif\n\treturn false;\n}\n", "/*\n * Soft:        Keepalived is a failover program for the LVS project\n *              <www.linuxvirtualserver.org>. It monitor & manipulate\n *              a loadbalanced server pool using multi-layer checks.\n *\n * Part:        SMTP WRAPPER connect to a specified smtp server and send mail\n *              using the smtp protocol according to the RFC 821. A non blocking\n *              timeouted connection is used to handle smtp protocol.\n *\n * Author:      Alexandre Cassen, <acassen@linux-vs.org>\n *\n *              This program is distributed in the hope that it will be useful,\n *              but WITHOUT ANY WARRANTY; without even the implied warranty of\n *              MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n *              See the GNU General Public License for more details.\n *\n *              This program is free software; you can redistribute it and/or\n *              modify it under the terms of the GNU General Public License\n *              as published by the Free Software Foundation; either version\n *              2 of the License, or (at your option) any later version.\n *\n * Copyright (C) 2001-2017 Alexandre Cassen, <acassen@gmail.com>\n */\n\n#include \"config.h\"\n\n#include <errno.h>\n#include <unistd.h>\n#include <time.h>\n\n#include \"smtp.h\"\n#include \"memory.h\"\n#include \"layer4.h\"\n#include \"logger.h\"\n#include \"utils.h\"\n#if !HAVE_DECL_SOCK_CLOEXEC\n#include \"old_socket.h\"\n#endif\n#ifdef _WITH_LVS_\n#include \"check_api.h\"\n#endif\n#ifdef THREAD_DUMP\n#include \"scheduler.h\"\n#endif\n#ifdef _SMTP_ALERT_DEBUG_\nbool do_smtp_alert_debug;\n#endif\n\n/* SMTP FSM definition */\nstatic int connection_error(thread_t *);\nstatic int connection_in_progress(thread_t *);\nstatic int connection_timeout(thread_t *);\nstatic int connection_success(thread_t *);\nstatic int helo_cmd(thread_t *);\nstatic int mail_cmd(thread_t *);\nstatic int rcpt_cmd(thread_t *);\nstatic int data_cmd(thread_t *);\nstatic int body_cmd(thread_t *);\nstatic int quit_cmd(thread_t *);\n\nstatic int connection_code(thread_t *, int);\nstatic int helo_code(thread_t *, int);\nstatic int mail_code(thread_t *, int);\nstatic int rcpt_code(thread_t *, int);\nstatic int data_code(thread_t *, int);\nstatic int body_code(thread_t *, int);\nstatic int quit_code(thread_t *, int);\n\nstatic int smtp_read_thread(thread_t *);\nstatic int smtp_send_thread(thread_t *);\n\nstruct {\n\tint (*send) (thread_t *);\n\tint (*read) (thread_t *, int);\n} SMTP_FSM[SMTP_MAX_FSM_STATE] = {\n/*      Stream Write Handlers    |   Stream Read handlers   *\n *-------------------------------+--------------------------*/\n\t{connection_error,\t\tNULL},\t\t\t/* connect_error */\n\t{connection_in_progress,\tNULL},\t\t\t/* connect_in_progress */\n\t{connection_timeout,\t\tNULL},\t\t\t/* connect_timeout */\n\t{connection_success,\t\tconnection_code},\t/* connect_success */\n\t{helo_cmd,\t\t\thelo_code},\t\t/* HELO */\n\t{mail_cmd,\t\t\tmail_code},\t\t/* MAIL */\n\t{rcpt_cmd,\t\t\trcpt_code},\t\t/* RCPT */\n\t{data_cmd,\t\t\tdata_code},\t\t/* DATA */\n\t{body_cmd,\t\t\tbody_code},\t\t/* BODY */\n\t{quit_cmd,\t\t\tquit_code}\t\t/* QUIT */\n};\n\nstatic void\nfree_smtp_all(smtp_t * smtp)\n{\n\tFREE(smtp->buffer);\n\tFREE(smtp->subject);\n\tFREE(smtp->body);\n\tFREE(smtp->email_to);\n\tFREE(smtp);\n}\n\nstatic char *\nfetch_next_email(smtp_t * smtp)\n{\n\treturn list_element(global_data->email, smtp->email_it);\n}\n\n/* layer4 connection handlers */\nstatic int\nconnection_error(thread_t * thread)\n{\n\tsmtp_t *smtp = THREAD_ARG(thread);\n\n\tlog_message(LOG_INFO, \"SMTP connection ERROR to %s.\"\n\t\t\t    , FMT_SMTP_HOST());\n\tfree_smtp_all(smtp);\n\treturn 0;\n}\nstatic int\nconnection_timeout(thread_t * thread)\n{\n\tsmtp_t *smtp = THREAD_ARG(thread);\n\n\tlog_message(LOG_INFO, \"Timeout connecting SMTP server %s.\"\n\t\t\t    , FMT_SMTP_HOST());\n\tfree_smtp_all(smtp);\n\treturn 0;\n}\nstatic int\nconnection_in_progress(thread_t * thread)\n{\n\tint status;\n\n\tDBG(\"SMTP connection to %s now IN_PROGRESS.\",\n\t    FMT_SMTP_HOST());\n\n\t/*\n\t * Here we use the propriety of a union structure,\n\t * each element of the structure have the same value.\n\t */\n\tstatus = tcp_socket_state(thread, connection_in_progress);\n\n\tif (status != connect_in_progress)\n\t\tSMTP_FSM_SEND(status, thread);\n\n\treturn 0;\n}\nstatic int\nconnection_success(thread_t * thread)\n{\n\tsmtp_t *smtp = THREAD_ARG(thread);\n\n\tlog_message(LOG_INFO, \"Remote SMTP server %s connected.\"\n\t\t\t    , FMT_SMTP_HOST());\n\n\tsmtp->stage = connect_success;\n\tthread_add_read(thread->master, smtp_read_thread, smtp,\n\t\t\tsmtp->fd, global_data->smtp_connection_to);\n\treturn 0;\n}\n\n/* SMTP protocol handlers */\nstatic int\nsmtp_read_thread(thread_t * thread)\n{\n\tsmtp_t *smtp;\n\tchar *buffer;\n\tchar *reply;\n\tssize_t rcv_buffer_size;\n\tint status = -1;\n\n\tsmtp = THREAD_ARG(thread);\n\n\tif (thread->type == THREAD_READ_TIMEOUT) {\n\t\tlog_message(LOG_INFO, \"Timeout reading data to remote SMTP server %s.\"\n\t\t\t\t    , FMT_SMTP_HOST());\n\t\tSMTP_FSM_READ(QUIT, thread, 0);\n\t\treturn -1;\n\t}\n\n\tbuffer = smtp->buffer;\n\n\trcv_buffer_size = read(thread->u.fd, buffer + smtp->buflen,\n\t\t\t       SMTP_BUFFER_LENGTH - smtp->buflen);\n\n\tif (rcv_buffer_size == -1) {\n\t\tif (errno == EAGAIN)\n\t\t\tgoto end;\n\t\tlog_message(LOG_INFO, \"Error reading data from remote SMTP server %s.\"\n\t\t\t\t    , FMT_SMTP_HOST());\n\t\tSMTP_FSM_READ(QUIT, thread, 0);\n\t\treturn 0;\n\t} else if (rcv_buffer_size == 0) {\n\t\tlog_message(LOG_INFO, \"Remote SMTP server %s has closed the connection.\"\n\t\t\t\t    , FMT_SMTP_HOST());\n\t\tSMTP_FSM_READ(QUIT, thread, 0);\n\t\treturn 0;\n\t}\n\n\t/* received data overflow buffer size ? */\n\tif (smtp->buflen >= SMTP_BUFFER_MAX) {\n\t\tlog_message(LOG_INFO, \"Received buffer from remote SMTP server %s\"\n\t\t\t\t      \" overflow our get read buffer length.\"\n\t\t\t\t    , FMT_SMTP_HOST());\n\t\tSMTP_FSM_READ(QUIT, thread, 0);\n\t\treturn 0;\n\t} else {\n\t\tsmtp->buflen += (size_t)rcv_buffer_size;\n\t\tbuffer[smtp->buflen] = 0;\t/* NULL terminate */\n\t}\n\n      end:\n\n\t/* parse the buffer, finding the last line of the response for the code */\n\treply = buffer;\n\twhile (reply < buffer + smtp->buflen) {\n\t\tchar *p;\n\n\t\tp = strstr(reply, \"\\r\\n\");\n\t\tif (!p) {\n\t\t\tmemmove(buffer, reply,\n\t\t\t\tsmtp->buflen - (size_t)(reply - buffer));\n\t\t\tsmtp->buflen -= (size_t)(reply - buffer);\n\t\t\tbuffer[smtp->buflen] = 0;\n\n\t\t\tthread_add_read(thread->master, smtp_read_thread,\n\t\t\t\t\tsmtp, thread->u.fd,\n\t\t\t\t\tglobal_data->smtp_connection_to);\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (reply[3] == '-') {\n\t\t\t/* Skip over the \\r\\n */\n\t\t\treply = p + 2;\n\t\t\tcontinue;\n\t\t}\n\n\t\tstatus = ((reply[0] - '0') * 100) + ((reply[1] - '0') * 10) + (reply[2] - '0');\n\n\t\treply = p + 2;\n\t\tbreak;\n\t}\n\n\tmemmove(buffer, reply, smtp->buflen - (size_t)(reply - buffer));\n\tsmtp->buflen -= (size_t)(reply - buffer);\n\tbuffer[smtp->buflen] = 0;\n\n\tif (status == -1) {\n\t\tthread_add_read(thread->master, smtp_read_thread, smtp,\n\t\t\t\tthread->u.fd, global_data->smtp_connection_to);\n\t\treturn 0;\n\t}\n\n\tSMTP_FSM_READ(smtp->stage, thread, status);\n\n\t/* Registering next smtp command processing thread */\n\tif (smtp->stage != ERROR) {\n\t\tthread_add_write(thread->master, smtp_send_thread, smtp,\n\t\t\t\t smtp->fd, global_data->smtp_connection_to);\n\t} else {\n\t\tlog_message(LOG_INFO, \"Can not read data from remote SMTP server %s.\"\n\t\t\t\t    , FMT_SMTP_HOST());\n\t\tSMTP_FSM_READ(QUIT, thread, 0);\n\t}\n\n\treturn 0;\n}\n\nstatic int\nsmtp_send_thread(thread_t * thread)\n{\n\tsmtp_t *smtp = THREAD_ARG(thread);\n\n\tif (thread->type == THREAD_WRITE_TIMEOUT) {\n\t\tlog_message(LOG_INFO, \"Timeout sending data to remote SMTP server %s.\"\n\t\t\t\t    , FMT_SMTP_HOST());\n\t\tSMTP_FSM_READ(QUIT, thread, 0);\n\t\treturn 0;\n\t}\n\n\tSMTP_FSM_SEND(smtp->stage, thread);\n\n\t/* Handle END command */\n\tif (smtp->stage == END) {\n\t\tSMTP_FSM_READ(QUIT, thread, 0);\n\t\treturn 0;\n\t}\n\n\t/* Registering next smtp command processing thread */\n\tif (smtp->stage != ERROR) {\n\t\tthread_add_read(thread->master, smtp_read_thread, smtp,\n\t\t\t\tthread->u.fd, global_data->smtp_connection_to);\n\t\tthread_del_write(thread);\n\t} else {\n\t\tlog_message(LOG_INFO, \"Can not send data to remote SMTP server %s.\"\n\t\t\t\t    , FMT_SMTP_HOST());\n\t\tSMTP_FSM_READ(QUIT, thread, 0);\n\t}\n\n\treturn 0;\n}\n\nstatic int\nconnection_code(thread_t * thread, int status)\n{\n\tsmtp_t *smtp = THREAD_ARG(thread);\n\n\tif (status == 220) {\n\t\tsmtp->stage++;\n\t} else {\n\t\tlog_message(LOG_INFO, \"Error connecting SMTP server %s.\"\n\t\t\t\t      \" SMTP status code = %d\"\n\t\t\t\t    , FMT_SMTP_HOST()\n\t\t\t\t    , status);\n\t\tsmtp->stage = ERROR;\n\t}\n\n\treturn 0;\n}\n\n/* HELO command processing */\nstatic int\nhelo_cmd(thread_t * thread)\n{\n\tsmtp_t *smtp = THREAD_ARG(thread);\n\tchar *buffer;\n\n\tbuffer = (char *) MALLOC(SMTP_BUFFER_MAX);\n\tsnprintf(buffer, SMTP_BUFFER_MAX, SMTP_HELO_CMD, (global_data->smtp_helo_name) ? global_data->smtp_helo_name : \"localhost\");\n\tif (send(thread->u.fd, buffer, strlen(buffer), 0) == -1)\n\t\tsmtp->stage = ERROR;\n\tFREE(buffer);\n\n\treturn 0;\n}\nstatic int\nhelo_code(thread_t * thread, int status)\n{\n\tsmtp_t *smtp = THREAD_ARG(thread);\n\n\tif (status == 250) {\n\t\tsmtp->stage++;\n\t} else {\n\t\tlog_message(LOG_INFO, \"Error processing HELO cmd on SMTP server %s.\"\n\t\t\t\t      \" SMTP status code = %d\"\n\t\t\t\t    , FMT_SMTP_HOST()\n\t\t\t\t    , status);\n\t\tsmtp->stage = ERROR;\n\t}\n\n\treturn 0;\n}\n\n/* MAIL command processing */\nstatic int\nmail_cmd(thread_t * thread)\n{\n\tsmtp_t *smtp = THREAD_ARG(thread);\n\tchar *buffer;\n\n\tbuffer = (char *) MALLOC(SMTP_BUFFER_MAX);\n\tsnprintf(buffer, SMTP_BUFFER_MAX, SMTP_MAIL_CMD, global_data->email_from);\n\tif (send(thread->u.fd, buffer, strlen(buffer), 0) == -1)\n\t\tsmtp->stage = ERROR;\n\tFREE(buffer);\n\n\treturn 0;\n}\nstatic int\nmail_code(thread_t * thread, int status)\n{\n\tsmtp_t *smtp = THREAD_ARG(thread);\n\n\tif (status == 250) {\n\t\tsmtp->stage++;\n\t} else {\n\t\tlog_message(LOG_INFO, \"Error processing MAIL cmd on SMTP server %s.\"\n\t\t\t\t      \" SMTP status code = %d\"\n\t\t\t\t    , FMT_SMTP_HOST()\n\t\t\t\t    , status);\n\t\tsmtp->stage = ERROR;\n\t}\n\n\treturn 0;\n}\n\n/* RCPT command processing */\nstatic int\nrcpt_cmd(thread_t * thread)\n{\n\tsmtp_t *smtp = THREAD_ARG(thread);\n\tchar *buffer;\n\tchar *fetched_email;\n\n\tbuffer = (char *) MALLOC(SMTP_BUFFER_MAX);\n\t/* We send RCPT TO command multiple time to add all our email receivers.\n\t * --rfc821.3.1\n\t */\n\tfetched_email = fetch_next_email(smtp);\n\n\tsnprintf(buffer, SMTP_BUFFER_MAX, SMTP_RCPT_CMD, fetched_email);\n\tif (send(thread->u.fd, buffer, strlen(buffer), 0) == -1)\n\t\tsmtp->stage = ERROR;\n\tFREE(buffer);\n\n\treturn 0;\n}\nstatic int\nrcpt_code(thread_t * thread, int status)\n{\n\tsmtp_t *smtp = THREAD_ARG(thread);\n\tchar *fetched_email;\n\n\tif (status == 250) {\n\t\tsmtp->email_it++;\n\n\t\tfetched_email = fetch_next_email(smtp);\n\n\t\tif (!fetched_email)\n\t\t\tsmtp->stage++;\n\t} else {\n\t\tlog_message(LOG_INFO, \"Error processing RCPT cmd on SMTP server %s.\"\n\t\t\t\t      \" SMTP status code = %d\"\n\t\t\t\t    , FMT_SMTP_HOST()\n\t\t\t\t    , status);\n\t\tsmtp->stage = ERROR;\n\t}\n\n\treturn 0;\n}\n\n/* DATA command processing */\nstatic int\ndata_cmd(thread_t * thread)\n{\n\tsmtp_t *smtp = THREAD_ARG(thread);\n\n\tif (send(thread->u.fd, SMTP_DATA_CMD, strlen(SMTP_DATA_CMD), 0) == -1)\n\t\tsmtp->stage = ERROR;\n\treturn 0;\n}\nstatic int\ndata_code(thread_t * thread, int status)\n{\n\tsmtp_t *smtp = THREAD_ARG(thread);\n\n\tif (status == 354) {\n\t\tsmtp->stage++;\n\t} else {\n\t\tlog_message(LOG_INFO, \"Error processing DATA cmd on SMTP server %s.\"\n\t\t\t\t      \" SMTP status code = %d\"\n\t\t\t\t    , FMT_SMTP_HOST()\n\t\t\t\t    , status);\n\t\tsmtp->stage = ERROR;\n\t}\n\n\treturn 0;\n}\n\n/* BODY command processing.\n * Do we need to use mutli-thread for multi-part body\n * handling ? Don t really think :)\n */\nstatic int\nbody_cmd(thread_t * thread)\n{\n\tsmtp_t *smtp = THREAD_ARG(thread);\n\tchar *buffer;\n\tchar rfc822[80];\n\ttime_t now;\n\tstruct tm *t;\n\n\tbuffer = (char *) MALLOC(SMTP_BUFFER_MAX);\n\n\ttime(&now);\n\tt = localtime(&now);\n\tstrftime(rfc822, sizeof(rfc822), \"%a, %d %b %Y %H:%M:%S %z\", t);\n\n\tsnprintf(buffer, SMTP_BUFFER_MAX, SMTP_HEADERS_CMD,\n\t\t rfc822, global_data->email_from, smtp->subject, smtp->email_to);\n\n\t/* send the subject field */\n\tif (send(thread->u.fd, buffer, strlen(buffer), 0) == -1)\n\t\tsmtp->stage = ERROR;\n\n\tmemset(buffer, 0, SMTP_BUFFER_MAX);\n\tsnprintf(buffer, SMTP_BUFFER_MAX, SMTP_BODY_CMD, smtp->body);\n\n\t/* send the the body field */\n\tif (send(thread->u.fd, buffer, strlen(buffer), 0) == -1)\n\t\tsmtp->stage = ERROR;\n\n\t/* send the sending dot */\n\tif (send(thread->u.fd, SMTP_SEND_CMD, strlen(SMTP_SEND_CMD), 0) == -1)\n\t\tsmtp->stage = ERROR;\n\n\tFREE(buffer);\n\treturn 0;\n}\nstatic int\nbody_code(thread_t * thread, int status)\n{\n\tsmtp_t *smtp = THREAD_ARG(thread);\n\n\tif (status == 250) {\n\t\tlog_message(LOG_INFO, \"SMTP alert successfully sent.\");\n\t\tsmtp->stage++;\n\t} else {\n\t\tlog_message(LOG_INFO, \"Error processing DOT cmd on SMTP server %s.\"\n\t\t\t\t      \" SMTP status code = %d\"\n\t\t\t\t    , FMT_SMTP_HOST()\n\t\t\t\t    , status);\n\t\tsmtp->stage = ERROR;\n\t}\n\n\treturn 0;\n}\n\n/* QUIT command processing */\nstatic int\nquit_cmd(thread_t * thread)\n{\n\tsmtp_t *smtp = THREAD_ARG(thread);\n\n\tif (send(thread->u.fd, SMTP_QUIT_CMD, strlen(SMTP_QUIT_CMD), 0) == -1)\n\t\tsmtp->stage = ERROR;\n\telse\n\t\tsmtp->stage++;\n\treturn 0;\n}\n\nstatic int\nquit_code(thread_t * thread, __attribute__((unused)) int status)\n{\n\tsmtp_t *smtp = THREAD_ARG(thread);\n\n\t/* final state, we are disconnected from the remote host */\n\tfree_smtp_all(smtp);\n\tthread_close_fd(thread);\n\treturn 0;\n}\n\n/* connect remote SMTP server */\nstatic void\nsmtp_connect(smtp_t * smtp)\n{\n\tenum connect_result status;\n\n\tif ((smtp->fd = socket(global_data->smtp_server.ss_family, SOCK_STREAM | SOCK_CLOEXEC | SOCK_NONBLOCK, IPPROTO_TCP)) == -1) {\n\t\tDBG(\"SMTP connect fail to create socket.\");\n\t\tfree_smtp_all(smtp);\n\t\treturn;\n\t}\n\n#if !HAVE_DECL_SOCK_NONBLOCK\n\tif (set_sock_flags(smtp->fd, F_SETFL, O_NONBLOCK))\n\t\tlog_message(LOG_INFO, \"Unable to set NONBLOCK on smtp_connect socket - %s (%d)\", strerror(errno), errno);\n#endif\n\n#if !HAVE_DECL_SOCK_CLOEXEC\n\tif (set_sock_flags(smtp->fd, F_SETFD, FD_CLOEXEC))\n\t\tlog_message(LOG_INFO, \"Unable to set CLOEXEC on smtp_connect socket - %s (%d)\", strerror(errno), errno);\n#endif\n\n\tstatus = tcp_connect(smtp->fd, &global_data->smtp_server);\n\n\t/* Handle connection status code */\n\tthread_add_event(master, SMTP_FSM[status].send, smtp, smtp->fd);\n}\n\n#ifdef _SMTP_ALERT_DEBUG_\nstatic void\nsmtp_log_to_file(smtp_t *smtp)\n{\n\tFILE *fp = fopen(\"/tmp/smtp-alert.log\", \"a\");\n\ttime_t now;\n\tstruct tm tm;\n\tchar time_buf[25];\n\tint time_buf_len;\n\n\ttime(&now);\n\tlocaltime_r(&now, &tm);\n\ttime_buf_len = strftime(time_buf, sizeof time_buf, \"%a %b %e %X %Y\", &tm);\n\n\tfprintf(fp, \"%s: %s -> %s\\n\"\n\t\t    \"%*sSubject: %s\\n\"\n\t\t    \"%*sBody:    %s\\n\\n\",\n\t\t    time_buf, global_data->email_from, smtp->email_to,\n\t\t    time_buf_len - 7, \"\", smtp->subject,\n\t\t    time_buf_len - 7, \"\", smtp->body);\n\n\tfclose(fp);\n\n\tfree_smtp_all(smtp);\n}\n#endif\n\n/*\n * Build a comma separated string of smtp recipient email addresses\n * for the email message To-header.\n */\nstatic void\nbuild_to_header_rcpt_addrs(smtp_t *smtp)\n{\n\tchar *fetched_email;\n\tchar *email_to_addrs;\n\tsize_t bytes_available = SMTP_BUFFER_MAX - 1;\n\tsize_t bytes_to_write;\n\n\tif (smtp == NULL)\n\t\treturn;\n\n\temail_to_addrs = smtp->email_to;\n\tsmtp->email_it = 0;\n\n\twhile (1) {\n\t\tfetched_email = fetch_next_email(smtp);\n\t\tif (fetched_email == NULL)\n\t\t\tbreak;\n\n\t\tbytes_to_write = strlen(fetched_email);\n\t\tif (!smtp->email_it) {\n\t\t\tif (bytes_available < bytes_to_write)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tif (bytes_available < 2 + bytes_to_write)\n\t\t\t\tbreak;\n\n\t\t\t/* Prepend with a comma and space to all non-first email addresses */\n\t\t\t*email_to_addrs++ = ',';\n\t\t\t*email_to_addrs++ = ' ';\n\t\t\tbytes_available -= 2;\n\t\t}\n\n\t\tif (snprintf(email_to_addrs, bytes_to_write + 1, \"%s\", fetched_email) != (int)bytes_to_write) {\n\t\t\t/* Inconsistent state, no choice but to break here and do nothing */\n\t\t\tbreak;\n\t\t}\n\n\t\temail_to_addrs += bytes_to_write;\n\t\tbytes_available -= bytes_to_write;\n\t\tsmtp->email_it++;\n\t}\n\n\tsmtp->email_it = 0;\n}\n\n/* Main entry point */\nvoid\nsmtp_alert(smtp_msg_t msg_type, void* data, const char *subject, const char *body)\n{\n\tsmtp_t *smtp;\n#ifdef _WITH_VRRP_\n\tvrrp_t *vrrp;\n\tvrrp_sgroup_t *vgroup;\n#endif\n#ifdef _WITH_LVS_\n\tchecker_t *checker;\n\tvirtual_server_t *vs;\n\tsmtp_rs *rs_info;\n#endif\n\n\t/* Only send mail if email specified */\n\tif (LIST_ISEMPTY(global_data->email) || !global_data->smtp_server.ss_family)\n\t\treturn;\n\n\t/* allocate & initialize smtp argument data structure */\n\tsmtp = (smtp_t *) MALLOC(sizeof(smtp_t));\n\tsmtp->subject = (char *) MALLOC(MAX_HEADERS_LENGTH);\n\tsmtp->body = (char *) MALLOC(MAX_BODY_LENGTH);\n\tsmtp->buffer = (char *) MALLOC(SMTP_BUFFER_MAX);\n\tsmtp->email_to = (char *) MALLOC(SMTP_BUFFER_MAX);\n\n\t/* format subject if rserver is specified */\n#ifdef _WITH_LVS_\n\tif (msg_type == SMTP_MSG_RS) {\n\t\tchecker = (checker_t *)data;\n\t\tsnprintf(smtp->subject, MAX_HEADERS_LENGTH, \"[%s] Realserver %s of virtual server %s - %s\",\n\t\t\t\t\tglobal_data->router_id,\n\t\t\t\t\tFMT_RS(checker->rs, checker->vs),\n\t\t\t\t\tFMT_VS(checker->vs),\n\t\t\t\t\tchecker->rs->alive ? \"UP\" : \"DOWN\");\n\t}\n\telse if (msg_type == SMTP_MSG_VS) {\n\t\tvs = (virtual_server_t *)data;\n\t\tsnprintf(smtp->subject, MAX_HEADERS_LENGTH, \"[%s] Virtualserver %s - %s\",\n\t\t\t\t\tglobal_data->router_id,\n\t\t\t\t\tFMT_VS(vs),\n\t\t\t\t\tsubject);\n\t}\n\telse if (msg_type == SMTP_MSG_RS_SHUT) {\n\t\trs_info = (smtp_rs *)data;\n\t\tsnprintf(smtp->subject, MAX_HEADERS_LENGTH, \"[%s] Realserver %s of virtual server %s - %s\",\n\t\t\t\t\tglobal_data->router_id,\n\t\t\t\t\tFMT_RS(rs_info->rs, rs_info->vs),\n\t\t\t\t\tFMT_VS(rs_info->vs),\n\t\t\t\t\tsubject);\n\t}\n\telse\n#endif\n#ifdef _WITH_VRRP_\n\tif (msg_type == SMTP_MSG_VRRP) {\n\t\tvrrp = (vrrp_t *)data;\n\t\tsnprintf(smtp->subject, MAX_HEADERS_LENGTH, \"[%s] VRRP Instance %s - %s\",\n\t\t\t\t\tglobal_data->router_id,\n\t\t\t\t\tvrrp->iname,\n\t\t\t\t\tsubject);\n\t} else if (msg_type == SMTP_MSG_VGROUP) {\n\t\tvgroup = (vrrp_sgroup_t *)data;\n\t\tsnprintf(smtp->subject, MAX_HEADERS_LENGTH, \"[%s] VRRP Group %s - %s\",\n\t\t\t\t\tglobal_data->router_id,\n\t\t\t\t\tvgroup->gname,\n\t\t\t\t\tsubject);\n\t}\n\telse\n#endif\n\tif (global_data->router_id)\n\t\tsnprintf(smtp->subject, MAX_HEADERS_LENGTH, \"[%s] %s\"\n\t\t\t\t      , global_data->router_id\n\t\t\t\t      , subject);\n\telse\n\t\tsnprintf(smtp->subject, MAX_HEADERS_LENGTH, \"%s\", subject);\n\n\tstrncpy(smtp->body, body, MAX_BODY_LENGTH - 1);\n\tsmtp->body[MAX_BODY_LENGTH - 1]= '\\0';\n\n\tbuild_to_header_rcpt_addrs(smtp);\n\n#ifdef _SMTP_ALERT_DEBUG_\n\tif (do_smtp_alert_debug)\n\t\tsmtp_log_to_file(smtp);\n\telse\n#endif\n\tsmtp_connect(smtp);\n}\n\n#ifdef THREAD_DUMP\nvoid\nregister_smtp_addresses(void)\n{\n\tregister_thread_address(\"body_cmd\", body_cmd);\n\tregister_thread_address(\"connection_error\", connection_error);\n\tregister_thread_address(\"connection_in_progress\", connection_in_progress);\n\tregister_thread_address(\"connection_success\", connection_success);\n\tregister_thread_address(\"connection_timeout\", connection_timeout);\n\tregister_thread_address(\"data_cmd\", data_cmd);\n\tregister_thread_address(\"helo_cmd\", helo_cmd);\n\tregister_thread_address(\"mail_cmd\", mail_cmd);\n\tregister_thread_address(\"quit_cmd\", quit_cmd);\n\tregister_thread_address(\"rcpt_cmd\", rcpt_cmd);\n\tregister_thread_address(\"smtp_read_thread\", smtp_read_thread);\n\tregister_thread_address(\"smtp_send_thread\", smtp_send_thread);\n}\n#endif\n", "/*\n * Soft:        Keepalived is a failover program for the LVS project\n *              <www.linuxvirtualserver.org>. It monitor & manipulate\n *              a loadbalanced server pool using multi-layer checks.\n *\n * Part:        DBus server thread for VRRP\n *\n * Author:      Alexandre Cassen, <acassen@linux-vs.org>\n *\n *              This program is distributed in the hope that it will be useful,\n *              but WITHOUT ANY WARRANTY; without even the implied warranty of\n *              MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n *              See the GNU General Public License for more details.\n *\n *              This program is free software; you can redistribute it and/or\n *              modify it under the terms of the GNU General Public License\n *              as published by the Free Software Foundation; either version\n *              2 of the License, or (at your option) any later version.\n *\n * Copyright (C) 2016-2017 Alexandre Cassen, <acassen@gmail.com>\n */\n\n/* See https://git.gnome.org/browse/glib/tree/gio/tests/fdbus-example-server.c\n * and https://developer.gnome.org/gio/stable/GDBusConnection.html#gdbus-server\n * for examples of coding.\n *\n * Create a general /org/keepalived/Vrrp1/Vrrp DBus\n * object and a /org/keepalived/Vrrp1/Instance/#interface#/#group# object for\n * each VRRP instance.\n * Interface org.keepalived.Vrrp1.Vrrp implements methods PrintData,\n * PrintStats and signal VrrpStopped.\n * Interface com.keepalived.Vrrp1.Instance implements method SendGarp\n * (sends a single Gratuitous ARP from the given Instance),\n * signal VrrpStatusChange, and properties Name and State (retrievable\n * through calls to org.freedesktop.DBus.Properties.Get)\n *\n * Interface files need to be installed in /usr/share/dbus-1/interfaces/\n * A policy file, which determines who has access to the service, is\n * installed in /etc/dbus-1/system.d/. Sources for the policy and interface\n * files are in keepalived/dbus.\n *\n * To test the DBus service run a command like: dbus-send --system --dest=org.keepalived.Vrrp1 --print-reply object interface.method type:argument\n * e.g.\n * dbus-send --system --dest=org.keepalived.Vrrp1 --print-reply /org/keepalived/Vrrp1/Vrrp org.keepalived.Vrrp1.Vrrp.PrintData\n * or\n * dbus-send --system --dest=org.keepalived.Vrrp1 --print-reply /org/keepalived/Vrrp1/Instance/eth0/1/IPv4 org.freedesktop.DBus.Properties.Get string:'org.keepalived.Vrrp1.Instance' string:'State'\n *\n * To monitor signals, run:\n * dbus-monitor --system type='signal'\n *\n * d-feet is a useful program for interfacing with DBus\n */\n\n#include \"config.h\"\n\n#include <errno.h>\n#include <pthread.h>\n#include <semaphore.h>\n#include <gio/gio.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <stdlib.h>\n#include <stdint.h>\n\n#include \"vrrp_dbus.h\"\n#include \"vrrp_data.h\"\n#include \"vrrp_print.h\"\n#include \"global_data.h\"\n#include \"main.h\"\n#include \"logger.h\"\n#include \"utils.h\"\n#ifdef THREAD_DUMP\n#include \"scheduler.h\"\n#endif\n\ntypedef enum dbus_action {\n\tDBUS_ACTION_NONE,\n\tDBUS_PRINT_DATA,\n\tDBUS_PRINT_STATS,\n\tDBUS_RELOAD,\n#ifdef _WITH_DBUS_CREATE_INSTANCE_\n\tDBUS_CREATE_INSTANCE,\n\tDBUS_DESTROY_INSTANCE,\n#endif\n\tDBUS_SEND_GARP,\n\tDBUS_GET_NAME,\n\tDBUS_GET_STATUS,\n} dbus_action_t;\n\ntypedef enum dbus_error {\n\tDBUS_SUCCESS,\n\tDBUS_INTERFACE_NOT_FOUND,\n\tDBUS_OBJECT_ALREADY_EXISTS,\n\tDBUS_INTERFACE_TOO_LONG,\n\tDBUS_INSTANCE_NOT_FOUND,\n} dbus_error_t;\n\ntypedef struct dbus_queue_ent {\n\tdbus_action_t action;\n\tdbus_error_t reply;\n\tchar *ifname;\n\tuint8_t vrid;\n\tuint8_t family;\n\tGVariant *args;\n} dbus_queue_ent_t;\n\n/* Global file variables */\nstatic GDBusNodeInfo *vrrp_introspection_data = NULL;\nstatic GDBusNodeInfo *vrrp_instance_introspection_data = NULL;\nstatic GDBusConnection *global_connection;\nstatic GHashTable *objects;\nstatic GMainLoop *loop;\n\n/* Data passing between main vrrp thread and dbus thread */\ndbus_queue_ent_t *ent_ptr;\nstatic int dbus_in_pipe[2], dbus_out_pipe[2];\nstatic sem_t thread_end;\n\n/* The only characters that are valid in a dbus path are A-Z, a-z, 0-9, _ */\nstatic char *\nset_valid_path(char *valid_path, const char *path)\n{\n\tconst char *str_in;\n\tchar *str_out;\n\n\tfor (str_in = path, str_out = valid_path; *str_in; str_in++, str_out++) {\n\t\tif (!isalnum(*str_in))\n\t\t\t*str_out = '_';\n\t\telse\n\t\t\t*str_out = *str_in;\n\t}\n\t*str_out = '\\0';\n\n\treturn valid_path;\n}\n\nstatic bool\nvalid_path_cmp(const char *path, const char *valid_path)\n{\n\tfor ( ; *path && *valid_path; path++, valid_path++) {\n\t\tif (!isalnum(*path)) {\n\t\t\tif (*valid_path != '_')\n\t\t\t\treturn true;\n\t\t}\n\t\telse if (*path != *valid_path)\n\t\t\treturn true;\n\t}\n\n\treturn *path != *valid_path;\n}\n\nstatic const char *\nfamily_str(int family)\n{\n\tif (family == AF_INET)\n\t\treturn \"IPv4\";\n\tif (family == AF_INET6)\n\t\treturn \"IPv6\";\n\treturn \"None\";\n}\n\nstatic const char *\nstate_str(int state)\n{\n\tswitch (state) {\n\tcase VRRP_STATE_INIT:\n\t\treturn \"Init\";\n\tcase VRRP_STATE_BACK:\n\t\treturn \"Backup\";\n\tcase VRRP_STATE_MAST:\n\t\treturn \"Master\";\n\tcase VRRP_STATE_FAULT:\n\t\treturn \"Fault\";\n\t}\n\treturn \"Unknown\";\n}\n\nstatic vrrp_t *\nget_vrrp_instance(const char *ifname, int vrid, int family)\n{\n\telement e;\n\tvrrp_t *vrrp;\n\n\tif (LIST_ISEMPTY(vrrp_data->vrrp))\n\t\treturn NULL;\n\n\tfor (e = LIST_HEAD(vrrp_data->vrrp); e; ELEMENT_NEXT(e)) {\n\t\tvrrp = ELEMENT_DATA(e);\n\n\t\tif (vrrp->vrid == vrid &&\n\t\t    vrrp->family == family &&\n\t\t    !valid_path_cmp(IF_BASE_IFP(vrrp->ifp)->ifname, ifname))\n\t\t\t\treturn vrrp;\n\t}\n\n\treturn NULL;\n}\n\nstatic gboolean\nunregister_object(gpointer key, gpointer value, __attribute__((unused)) gpointer user_data)\n{\n\tif (g_hash_table_remove(objects, key))\n\t\treturn g_dbus_connection_unregister_object(global_connection, GPOINTER_TO_UINT(value));\n\treturn false;\n}\n\nstatic gchar *\ndbus_object_create_path_vrrp(void)\n{\n\treturn g_strconcat(DBUS_VRRP_OBJECT_ROOT,\n#if HAVE_DECL_CLONE_NEWNET\n\t\t\t  global_data->network_namespace ? \"/\" : \"\", global_data->network_namespace ? global_data->network_namespace : \"\",\n#endif\n\t\t\t  global_data->instance_name ? \"/\" : \"\", global_data->instance_name ? global_data->instance_name : \"\",\n\n\t\t\t  \"/Vrrp\", NULL);\n}\n\nstatic gchar *\ndbus_object_create_path_instance(const gchar *interface, int vrid, sa_family_t family)\n{\n\tgchar *object_path;\n\tchar standardized_name[sizeof ((vrrp_t*)NULL)->ifp->ifname];\n\tgchar *vrid_str = g_strdup_printf(\"%d\", vrid);\n\n\tset_valid_path(standardized_name, interface);\n\n\tobject_path = g_strconcat(DBUS_VRRP_OBJECT_ROOT,\n#if HAVE_DECL_CLONE_NEWNET\n\t\t\t\t  global_data->network_namespace ? \"/\" : \"\", global_data->network_namespace ? global_data->network_namespace : \"\",\n#endif\n\t\t\t\t  global_data->instance_name ? \"/\" : \"\", global_data->instance_name ? global_data->instance_name : \"\",\n\n\t\t\t\t  \"/Instance/\",\n\t\t\t\t  standardized_name, \"/\", vrid_str,\n\t\t\t\t  \"/\", family_str(family),\n\t\t\t\t  NULL);\n\n\tg_free(vrid_str);\n\treturn object_path;\n}\n\nstatic dbus_queue_ent_t *\nprocess_method_call(dbus_queue_ent_t *ent)\n{\n\tssize_t ret;\n\n\tif (!ent)\n\t\treturn NULL;\n\n\t/* Tell the main thread that a queue entry is waiting. Any data works */\n\tent_ptr = ent;\n\tif (write(dbus_in_pipe[1], ent, 1) != 1)\n\t\tlog_message(LOG_INFO, \"Write from DBus thread to main thread failed\");\n\n\t/* Wait for a response */\n\twhile ((ret = read(dbus_out_pipe[0], ent, 1)) == -1 && errno == EINTR) {\n\t\tlog_message(LOG_INFO, \"dbus_out_pipe read returned EINTR\");\n\t}\n\tif (ret == -1)\n\t\tlog_message(LOG_INFO, \"DBus response read error - errno = %d\", errno);\n\n#ifdef DBUS_DEBUG\n\tif (ent->reply != DBUS_SUCCESS) {\n\t\tchar *iname;\n\n\t\tif (ent->reply == DBUS_INTERFACE_NOT_FOUND)\n\t\t\tlog_message(LOG_INFO, \"Unable to find DBus requested instance %s/%d/%s\", ent->ifname, ent->vrid, family_str(ent->family));\n\t\telse if (ent->reply == DBUS_OBJECT_ALREADY_EXISTS)\n\t\t\tlog_message(LOG_INFO, \"Unable to create DBus requested object with instance %s/%d/%s\", ent->ifname, ent->vrid, family_str(ent->family));\n\t\telse if (ent->reply == DBUS_INSTANCE_NOT_FOUND) {\n\t\t\tg_variant_get(ent->args, \"(s)\", &iname);\n\t\t\tlog_message(LOG_INFO, \"Unable to find DBus requested instance %s\", iname);\n\t\t}\n\t\telse\n\t\t\tlog_message(LOG_INFO, \"Unknown DBus reply %d\", ent->reply);\n\t}\n#endif\n\n\treturn ent;\n}\n\nstatic void\nget_interface_ids(const gchar *object_path, gchar *interface, uint8_t *vrid, uint8_t *family)\n{\n\tint path_length = DBUS_VRRP_INSTANCE_PATH_DEFAULT_LENGTH;\n\tgchar **dirs;\n\tchar *endptr;\n\n#if HAVE_DECL_CLONE_NEWNET\n\tif(global_data->network_namespace)\n\t\tpath_length++;\n#endif\n\tif(global_data->instance_name)\n\t\tpath_length++;\n\n\t/* object_path will have interface, vrid and family as\n\t * the third to last, second to last and last levels */\n\tdirs = g_strsplit(object_path, \"/\", path_length);\n\tstrcpy(interface, dirs[path_length-3]);\n\t*vrid = (uint8_t)strtoul(dirs[path_length-2], &endptr, 10);\n\tif (*endptr)\n\t\tlog_message(LOG_INFO, \"Dbus unexpected characters '%s' at end of number '%s'\", endptr, dirs[path_length-2]);\n\t*family = !g_strcmp0(dirs[path_length-1], \"IPv4\") ? AF_INET : !g_strcmp0(dirs[path_length-1], \"IPv6\") ? AF_INET6 : AF_UNSPEC;\n\n\t/* We are finished with all the object_path strings now */\n\tg_strfreev(dirs);\n}\n\n/* handles reply to org.freedesktop.DBus.Properties.Get method on any object*/\nstatic GVariant *\nhandle_get_property(__attribute__((unused)) GDBusConnection *connection,\n\t\t    __attribute__((unused)) const gchar     *sender,\n\t\t\t\t\t    const gchar     *object_path,\n\t\t\t\t\t    const gchar     *interface_name,\n\t\t\t\t\t    const gchar     *property_name,\n\t\t\t\t\t    GError\t   **error,\n\t\t    __attribute__((unused)) gpointer\t     user_data)\n{\n\tGVariant *ret = NULL;\n\tdbus_queue_ent_t ent;\n\tchar ifname_str[sizeof ((vrrp_t*)NULL)->ifp->ifname];\n\tint action;\n\n\tif (g_strcmp0(interface_name, DBUS_VRRP_INSTANCE_INTERFACE)) {\n\t\tlog_message(LOG_INFO, \"Interface %s has not been implemented yet\", interface_name);\n\t\treturn NULL;\n\t}\n\n\tif (!g_strcmp0(property_name, \"Name\"))\n\t\taction = DBUS_GET_NAME;\n\telse if (!g_strcmp0(property_name, \"State\"))\n\t\taction = DBUS_GET_STATUS;\n\telse {\n\t\tlog_message(LOG_INFO, \"Property %s does not exist\", property_name);\n\t\treturn NULL;\n\t}\n\n\tget_interface_ids(object_path, ifname_str, &ent.vrid, &ent.family);\n\n\tent.action = action;\n\tent.ifname = ifname_str;\n\tent.args = NULL;\n\tprocess_method_call(&ent);\n\tif (ent.reply == DBUS_SUCCESS)\n\t\tret = ent.args;\n\telse\n\t\tg_set_error(error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, \"Instance '%s/%d/%s' not found\", ifname_str, ent.vrid, family_str(ent.family));\n\n\treturn ret;\n}\n\n/* handles method_calls on any object */\nstatic void\nhandle_method_call(__attribute__((unused)) GDBusConnection *connection,\n\t\t   __attribute__((unused)) const gchar\t   *sender,\n\t\t\t\t\t   const gchar\t   *object_path,\n\t\t\t\t\t   const gchar\t   *interface_name,\n\t\t\t\t\t   const gchar\t   *method_name,\n#ifndef _WITH_DBUS_CREATE_INSTANCE_\n\t\t   __attribute__((unused))\n#endif\n\t\t\t\t\t   GVariant *parameters,\n\t\t   GDBusMethodInvocation *invocation,\n\t\t   __attribute__((unused)) gpointer user_data)\n{\n#ifdef _WITH_DBUS_CREATE_INSTANCE_\n\tchar *iname;\n\tchar *ifname;\n\tsize_t len;\n\tunsigned family;\n#endif\n\tdbus_queue_ent_t ent;\n\tchar ifname_str[sizeof ((vrrp_t*)NULL)->ifp->ifname];\n\n\tif (!g_strcmp0(interface_name, DBUS_VRRP_INTERFACE)) {\n\t\tif (!g_strcmp0(method_name, \"PrintData\")) {\n\t\t\tent.action = DBUS_PRINT_DATA;\n\t\t\tprocess_method_call(&ent);\n\t\t\tg_dbus_method_invocation_return_value(invocation, NULL);\n\t\t}\n\t\telse if (g_strcmp0(method_name, \"PrintStats\") == 0) {\n\t\t\tent.action = DBUS_PRINT_STATS;\n\t\t\tprocess_method_call(&ent);\n\t\t\tg_dbus_method_invocation_return_value(invocation, NULL);\n\t\t}\n\t\telse if (g_strcmp0(method_name, \"ReloadConfig\") == 0) {\n\t\t\tg_dbus_method_invocation_return_value(invocation, NULL);\n\t\t\tkill(getppid(), SIGHUP);\n\t\t}\n#ifdef _WITH_DBUS_CREATE_INSTANCE_\n\t\telse if (g_strcmp0(method_name, \"CreateInstance\") == 0) {\n\t\t\tg_variant_get(parameters, \"(ssuu)\", &iname, &ifname, &ent.vrid, &family);\n\t\t\tlen = strlen(ifname);\n\t\t\tif (len == 0 || len >= IFNAMSIZ) {\n\t\t\t\tlog_message(LOG_INFO, \"Interface name '%s' too long for CreateInstance\", ifname);\n\t\t\t\tg_dbus_method_invocation_return_error(invocation, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, \"Interface name empty or too long\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tent.action = DBUS_CREATE_INSTANCE;\n\t\t\tent.ifname = ifname;\n\t\t\tent.family = family == 4 ? AF_INET : family == 6 ? AF_INET6 : AF_UNSPEC;\n\t\t\tent.args = g_variant_new(\"(s)\", iname);\n\t\t\tprocess_method_call(&ent);\n\t\t\tg_variant_unref(ent.args);\n\t\t\tg_dbus_method_invocation_return_value(invocation, NULL);\n\t\t}\n\t\telse if (g_strcmp0(method_name, \"DestroyInstance\") == 0) {\n// TODO - this should be on the instance\n\t\t\tent.action = DBUS_DESTROY_INSTANCE;\n\t\t\tent.args = parameters;\n\t\t\tprocess_method_call(&ent);\n\n\t\t\tif (ent.reply == DBUS_INSTANCE_NOT_FOUND) {\n\t\t\t\tg_variant_get(parameters, \"(s)\", &iname);\n\t\t\t\tg_dbus_method_invocation_return_error(invocation, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, \"Instance '%s' not found\", iname);\n\t\t\t}\n\t\t\telse\n\t\t\t\tg_dbus_method_invocation_return_value(invocation, NULL);\n\t\t}\n#endif\n\t\telse {\n\t\t\tlog_message(LOG_INFO, \"Method %s has not been implemented yet\", method_name);\n\t\t\tg_dbus_method_invocation_return_error(invocation, G_DBUS_ERROR, G_DBUS_ERROR_MATCH_RULE_NOT_FOUND, \"Method not implemented\");\n\t\t}\n\n\t\treturn;\n\t}\n\n\tif (!g_strcmp0(interface_name, DBUS_VRRP_INSTANCE_INTERFACE)) {\n\t\tif (!g_strcmp0(method_name, \"SendGarp\")) {\n\t\t\tget_interface_ids(object_path, ifname_str, &ent.vrid, &ent.family);\n\t\t\tent.action = DBUS_SEND_GARP;\n\t\t\tent.ifname = ifname_str;\n\t\t\tprocess_method_call(&ent);\n\t\t\tif (ent.reply ==  DBUS_INTERFACE_NOT_FOUND)\n\t\t\t\tg_dbus_method_invocation_return_error(invocation, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, \"Instance '%s/%d/%s' not found\", ifname_str, ent.vrid, family_str(ent.family));\n\t\t\telse\n\t\t\t\tg_dbus_method_invocation_return_value(invocation, NULL);\n\t\t} else {\n\t\t\tlog_message(LOG_INFO, \"Method %s has not been implemented yet\", method_name);\n\t\t\tg_dbus_method_invocation_return_error(invocation, G_DBUS_ERROR, G_DBUS_ERROR_MATCH_RULE_NOT_FOUND, \"Method not implemented\");\n\t\t}\n\n\t\treturn;\n\t}\n\n\tlog_message(LOG_INFO, \"Interface %s has not been implemented yet\", interface_name);\n\tg_dbus_method_invocation_return_error(invocation, G_DBUS_ERROR, G_DBUS_ERROR_MATCH_RULE_NOT_FOUND, \"Interface not implemented\");\n}\n\nstatic const GDBusInterfaceVTable interface_vtable =\n{\n\thandle_method_call,\n\thandle_get_property,\n\tNULL, /* handle_set_property is null because we have no writeable property */\n\t{}\n};\n\nstatic int\ndbus_create_object_params(char *instance_name, const char *interface_name, int vrid, sa_family_t family, bool log_success)\n{\n\tgchar *object_path;\n\tGError *local_error = NULL;\n\n\tif (g_hash_table_lookup(objects, instance_name)) {\n\t\tlog_message(LOG_INFO, \"An object for instance %s already exists\", instance_name);\n\t\treturn DBUS_OBJECT_ALREADY_EXISTS;\n\t}\n\n\tobject_path = dbus_object_create_path_instance(interface_name, vrid, family);\n\n\tguint instance = g_dbus_connection_register_object(global_connection, object_path,\n\t\t\t\t\t\tvrrp_instance_introspection_data->interfaces[0],\n\t\t\t\t\t\t&interface_vtable, NULL, NULL, &local_error);\n\tif (local_error != NULL) {\n\t\tlog_message(LOG_INFO, \"Registering DBus object on %s failed: %s\",\n\t\t\t    object_path, local_error->message);\n\t\tg_clear_error(&local_error);\n\t}\n\n\tif (instance) {\n\t\tg_hash_table_insert(objects, instance_name, GUINT_TO_POINTER(instance));\n\t\tif (log_success)\n\t\t\tlog_message(LOG_INFO, \"Added DBus object for instance %s on path %s\", instance_name, object_path);\n\t}\n\tg_free(object_path);\n\n\treturn DBUS_SUCCESS;\n}\n\nstatic void\ndbus_create_object(vrrp_t *vrrp)\n{\n\tdbus_create_object_params(vrrp->iname, IF_NAME(IF_BASE_IFP(vrrp->ifp)), vrrp->vrid, vrrp->family, false);\n}\n\nstatic bool\ndbus_emit_signal(GDBusConnection *connection,\n\t\t const gchar *object_path,\n\t\t const gchar *interface_name,\n\t\t const gchar *signal_name,\n\t\t GVariant *parameters)\n{\n\tGError *local_error = NULL;\n\n\tg_dbus_connection_emit_signal(connection, NULL, object_path, interface_name, signal_name, parameters,\n\t\t\t\t      &local_error);\n\n\tif (local_error != NULL) {\n\t\tlog_message(LOG_INFO, \"Emitting DBus signal %s.%s on %s failed: %s\",\n\t\t\t    interface_name, signal_name, object_path, local_error->message);\n\t\tg_clear_error(&local_error);\n\t\treturn false;\n\t}\n\treturn true;\n}\n\n/* first function to be run when trying to own bus,\n * exports objects to the bus */\nstatic void\non_bus_acquired(GDBusConnection *connection,\n\t\tconst gchar     *name,\n\t\t__attribute__((unused)) gpointer user_data)\n{\n\tglobal_connection = connection;\n\tgchar *path;\n\telement e;\n\tGError *local_error = NULL;\n\n\tlog_message(LOG_INFO, \"Acquired DBus bus %s\", name);\n\n\t/* register VRRP object */\n\tpath = dbus_object_create_path_vrrp();\n\tguint vrrp = g_dbus_connection_register_object(connection, path,\n\t\t\t\t\t\t\t vrrp_introspection_data->interfaces[0],\n\t\t\t\t\t\t\t &interface_vtable, NULL, NULL, &local_error);\n\tg_hash_table_insert(objects, \"__Vrrp__\", GUINT_TO_POINTER(vrrp));\n\tg_free(path);\n\tif (local_error != NULL) {\n\t\tlog_message(LOG_INFO, \"Registering VRRP object on %s failed: %s\",\n\t\t\t    path, local_error->message);\n\t\tg_clear_error(&local_error);\n\t}\n\n\t/* for each available VRRP instance, register an object */\n\tif (LIST_ISEMPTY(vrrp_data->vrrp))\n\t\treturn;\n\n\tfor (e = LIST_HEAD(vrrp_data->vrrp); e; ELEMENT_NEXT(e)) {\n\t\tvrrp_t * vrrp = ELEMENT_DATA(e);\n\t\tdbus_create_object(vrrp);\n\t}\n\n\t/* Send a signal to say we have started */\n\tpath = dbus_object_create_path_vrrp();\n\tdbus_emit_signal(global_connection, path, DBUS_VRRP_INTERFACE, \"VrrpStarted\", NULL);\n\tg_free(path);\n\n\t/* Notify DBus of the state of our instances */\n\tfor (e = LIST_HEAD(vrrp_data->vrrp); e; ELEMENT_NEXT(e)) {\n\t\tvrrp_t * vrrp = ELEMENT_DATA(e);\n\t\tdbus_send_state_signal(vrrp);\n\t}\n}\n\n/* run if bus name is acquired successfully */\nstatic void\non_name_acquired(__attribute__((unused)) GDBusConnection *connection,\n\t\t const gchar     *name,\n\t\t __attribute__((unused)) gpointer user_data)\n{\n\tlog_message(LOG_INFO, \"Acquired the name %s on the session bus\", name);\n}\n\n/* run if bus name or connection are lost */\nstatic void\non_name_lost(GDBusConnection *connection,\n\t     const gchar     *name,\n\t     __attribute__((unused)) gpointer user_data)\n{\n\tlog_message(LOG_INFO, \"Lost the name %s on the session bus\", name);\n\tglobal_connection = connection;\n\tg_hash_table_foreach_remove(objects, unregister_object, NULL);\n\tobjects = NULL;\n\tglobal_connection = NULL;\n}\n\nstatic gchar*\nread_file(gchar* filepath)\n{\n\tFILE * f;\n\tsize_t length;\n\tgchar *ret = NULL;\n\n\tf = fopen(filepath, \"rb\");\n\tif (f) {\n\t\tfseek(f, 0, SEEK_END);\n\t\tlength = (size_t)ftell(f);\n\t\tfseek(f, 0, SEEK_SET);\n\n\t\t/* We can't use MALLOC since it isn't thread safe */\n\t\tret = MALLOC(length + 1);\n\t\tif (ret) {\n\t\t\tif (fread(ret, length, 1, f) != 1) {\n\t\t\t\tlog_message(LOG_INFO, \"Failed to read all of %s\", filepath);\n\t\t\t}\n\t\t\tret[length] = '\\0';\n\t\t}\n\t\telse\n\t\t\tlog_message(LOG_INFO, \"Unable to read Dbus file %s\", filepath);\n\n\t\tfclose(f);\n\t}\n\treturn ret;\n}\n\nstatic void *\ndbus_main(__attribute__ ((unused)) void *unused)\n{\n\tgchar *introspection_xml;\n\tguint owner_id;\n\tconst char *service_name;\n\n\tobjects = g_hash_table_new(g_str_hash, g_str_equal);\n\n\t/* DBus service org.keepalived.Vrrp1 exposes two interfaces, Vrrp and Instance.\n\t * Vrrp is implemented by a single VRRP object for general purposes, such as printing\n\t * data or signaling that the VRRP process has been stopped.\n\t * Instance is implemented by an Instance object for every VRRP Instance in vrrp_data.\n\t * It exposes instance specific methods and properties.\n\t */\n#ifdef DBUS_NEED_G_TYPE_INIT\n\tg_type_init();\n#endif\n\tGError *error = NULL;\n\n\t/* read service interface data from xml files */\n\tintrospection_xml = read_file(DBUS_VRRP_INTERFACE_FILE_PATH);\n\tif (!introspection_xml)\n\t\treturn NULL;\n\tvrrp_introspection_data = g_dbus_node_info_new_for_xml(introspection_xml, &error);\n\tFREE(introspection_xml);\n\tif (error != NULL) {\n\t\tlog_message(LOG_INFO, \"Parsing DBus interface %s from file %s failed: %s\",\n\t\t\t    DBUS_VRRP_INTERFACE, DBUS_VRRP_INTERFACE_FILE_PATH, error->message);\n\t\tg_clear_error(&error);\n\t\treturn NULL;\n\t}\n\n\tintrospection_xml = read_file(DBUS_VRRP_INSTANCE_INTERFACE_FILE_PATH);\n\tif (!introspection_xml)\n\t\treturn NULL;\n\tvrrp_instance_introspection_data = g_dbus_node_info_new_for_xml(introspection_xml, &error);\n\tFREE(introspection_xml);\n\tif (error != NULL) {\n\t\tlog_message(LOG_INFO, \"Parsing DBus interface %s from file %s failed: %s\",\n\t\t\t    DBUS_VRRP_INSTANCE_INTERFACE, DBUS_VRRP_INSTANCE_INTERFACE_FILE_PATH, error->message);\n\t\tg_clear_error(&error);\n\t\treturn NULL;\n\t}\n\n\tservice_name = global_data->dbus_service_name ? global_data->dbus_service_name : DBUS_SERVICE_NAME;\n\towner_id = g_bus_own_name(G_BUS_TYPE_SYSTEM,\n\t\t\t\t  service_name,\n\t\t\t\t  G_BUS_NAME_OWNER_FLAGS_NONE,\n\t\t\t\t  on_bus_acquired,\n\t\t\t\t  on_name_acquired,\n\t\t\t\t  on_name_lost,\n\t\t\t\t  NULL,  /* user_data */\n\t\t\t\t  NULL); /* user_data_free_func */\n\n\tloop = g_main_loop_new(NULL, FALSE);\n\tg_main_loop_run(loop);\n\n\t/* cleanup after loop terminates */\n\tg_main_loop_unref(loop);\n\tg_bus_unown_name(owner_id);\n\tglobal_connection = NULL;\n\n\tsem_post(&thread_end);\n\tpthread_exit(0);\n}\n\n/* The following functions are run in the context of the main vrrp thread */\n\n/* send signal VrrpStatusChange\n * containing the new state of vrrp */\nvoid\ndbus_send_state_signal(vrrp_t *vrrp)\n{\n\tgchar *object_path;\n\tGVariant *args;\n\n\t/* the interface will go through the initial state changes before\n\t * the main loop can be started and global_connection initialised */\n\tif (global_connection == NULL)\n\t\treturn;\n\n\tobject_path = dbus_object_create_path_instance(IF_NAME(IF_BASE_IFP(vrrp->ifp)), vrrp->vrid, vrrp->family);\n\n\targs = g_variant_new(\"(u)\", vrrp->state);\n\tdbus_emit_signal(global_connection, object_path, DBUS_VRRP_INSTANCE_INTERFACE, \"VrrpStatusChange\", args);\n\tg_free(object_path);\n}\n\n/* send signal VrrpRestarted */\nstatic void\ndbus_send_reload_signal(void)\n{\n\tgchar *path;\n\n\tif (global_connection == NULL)\n\t\treturn;\n\n\tpath = dbus_object_create_path_vrrp();\n\tdbus_emit_signal(global_connection, path, DBUS_VRRP_INTERFACE, \"VrrpReloaded\", NULL);\n\tg_free(path);\n}\n\nstatic gboolean\ndbus_unregister_object(char *str)\n{\n\tgboolean ret = false;\n\n\tgpointer value = g_hash_table_lookup(objects, str);\n\tif (value) {\n\t\tret = unregister_object(str, value, NULL);\n\t\tlog_message(LOG_INFO, \"Deleted DBus object for instance %s\", str);\n\t}\n#ifdef DBUS_DEBUG\n\telse\n\t\tlog_message(LOG_INFO, \"DBus object not found for instance %s\", str);\n#endif\n\n\treturn ret;\n}\n\nvoid\ndbus_remove_object(vrrp_t *vrrp)\n{\n\tdbus_unregister_object(vrrp->iname);\n}\n\nstatic int\nhandle_dbus_msg(__attribute__((unused)) thread_t *thread)\n{\n\tdbus_queue_ent_t *ent;\n\tchar recv_buf;\n\tvrrp_t *vrrp;\n#ifdef _WITH_DBUS_CREATE_INSTANCE_\n\tgchar *name;\n#endif\n\n\tif (read(dbus_in_pipe[0], &recv_buf, 1) != 1)\n\t\tlog_message(LOG_INFO, \"Read from DBus thread to vrrp thread failed\");\n\n\tif ((ent = ent_ptr) != NULL) {\n\t\tent->reply = DBUS_SUCCESS;\n\n\t\tif (ent->action == DBUS_PRINT_DATA) {\n\t\t\tlog_message(LOG_INFO, \"Printing VRRP data on DBus request\");\n\t\t\tvrrp_print_data();\n\n\t\t}\n\t\telse if (ent->action == DBUS_PRINT_STATS) {\n\t\t\tlog_message(LOG_INFO, \"Printing VRRP stats on DBus request\");\n\t\t\tvrrp_print_stats();\n\t\t}\n#ifdef _WITH_DBUS_CREATE_INSTANCE_\n\t\telse if (ent->action == DBUS_CREATE_INSTANCE) {\n\t\t\tg_variant_get(ent->args, \"(s)\", &name);\n\t\t\tent->reply = dbus_create_object_params(name, ent->ifname, ent->vrid, ent->family, true);\n\t\t}\n\t\telse if (ent->action == DBUS_DESTROY_INSTANCE) {\n\t\t\tg_variant_get(ent->args, \"(s)\", &name);\n\t\t\tif (!dbus_unregister_object(name))\n\t\t\t\tent->reply = DBUS_INSTANCE_NOT_FOUND;\n\t\t}\n#endif\n\t\telse if (ent->action == DBUS_SEND_GARP) {\n\t\t\tent->reply = DBUS_INTERFACE_NOT_FOUND;\n\t\t\tvrrp = get_vrrp_instance(ent->ifname, ent->vrid, ent->family);\n\t\t\tif (vrrp) {\n\t\t\t\tlog_message(LOG_INFO, \"Sending garps on %s on DBus request\", vrrp->iname);\n\t\t\t\tvrrp_send_link_update(vrrp, 1);\n\t\t\t\tent->reply = DBUS_SUCCESS;\n\t\t\t}\n\t\t}\n\t\telse if (ent->action == DBUS_GET_NAME ||\n\t\t\t ent->action == DBUS_GET_STATUS) {\n\t\t\t/* we look for the vrrp instance object that corresponds to our interface and group */\n\t\t\tent->reply = DBUS_INTERFACE_NOT_FOUND;\n\n\t\t\tvrrp = get_vrrp_instance(ent->ifname, ent->vrid, ent->family);\n\n\t\t\tif (vrrp) {\n\t\t\t\t/* the property_name argument is the property we want to Get */\n\t\t\t\tif (ent->action == DBUS_GET_NAME)\n\t\t\t\t\tent->args = g_variant_new(\"(s)\", vrrp->iname);\n\t\t\t\telse if (ent->action == DBUS_GET_STATUS)\n\t\t\t\t\tent->args = g_variant_new(\"(us)\", vrrp->state, state_str(vrrp->state));\n\t\t\t\telse\n\t\t\t\t\tent->args = NULL;\t /* How did we get here? */\n\t\t\t\tent->reply = DBUS_SUCCESS;\n\t\t\t}\n\t\t}\n\t\tif (write(dbus_out_pipe[1], ent, 1) != 1)\n\t\t\tlog_message(LOG_INFO, \"Write from main thread to DBus thread failed\");\n\t}\n\n\tthread_add_read(master, handle_dbus_msg, NULL, dbus_in_pipe[0], TIMER_NEVER);\n\n\treturn 0;\n}\n\nvoid\ndbus_reload(list o, list n)\n{\n\telement e1, e2, e3;\n\tvrrp_t *vrrp_n, *vrrp_o, *vrrp_n3;\n\n\tif (!LIST_ISEMPTY(n)) {\n\t\tfor (e1 = LIST_HEAD(n); e1; ELEMENT_NEXT(e1)) {\n\t\t\tchar *n_name;\n\t\t\tbool match_found;\n\n\t\t\tvrrp_n = ELEMENT_DATA(e1);\n\n\t\t\tif (LIST_ISEMPTY(o)) {\n\t\t\t\tdbus_create_object(vrrp_n);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tn_name = IF_BASE_IFP(vrrp_n->ifp)->ifname;\n\n\t\t\t/* Try an find an instance with same vrid/family/interface that existed before and now */\n\t\t\tfor (e2 = LIST_HEAD(o), match_found = false; e2 && !match_found; ELEMENT_NEXT(e2)) {\n\t\t\t\tvrrp_o = ELEMENT_DATA(e2);\n\n\t\t\t\tif (vrrp_n->vrid == vrrp_o->vrid &&\n\t\t\t\t    vrrp_n->family == vrrp_o->family &&\n\t\t\t\t    !strcmp(n_name, IF_BASE_IFP(vrrp_o->ifp)->ifname)) {\n\t\t\t\t\t/* If the old instance exists in the new config,\n\t\t\t\t\t * then the dbus object will exist */\n\t\t\t\t\tif (!strcmp(vrrp_n->iname, vrrp_o->iname)) {\n\t\t\t\t\t\tmatch_found = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* Check if the old instance name we found still exists\n\t\t\t\t\t * (but has a different vrid/family/interface) */\n\t\t\t\t\tfor (e3 = LIST_HEAD(n); e3; ELEMENT_NEXT(e3)) {\n\t\t\t\t\t\tvrrp_n3 = ELEMENT_DATA(e3);\n\t\t\t\t\t\tif (!strcmp(vrrp_o->iname, vrrp_n3->iname)) {\n\t\t\t\t\t\t\tmatch_found = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (match_found)\n\t\t\t\tcontinue;\n\n\t\t\tdbus_create_object(vrrp_n);\n\t\t}\n\t}\n\n\t/* Signal we have reloaded */\n\tdbus_send_reload_signal();\n\n\t/* We need to reinstate the read thread */\n\tthread_add_read(master, handle_dbus_msg, NULL, dbus_in_pipe[0], TIMER_NEVER);\n}\n\nbool\ndbus_start(void)\n{\n\tpthread_t dbus_thread;\n\tsigset_t sigset, cursigset;\n\n\tif (open_pipe(dbus_in_pipe)) {\n\t\tlog_message(LOG_INFO, \"Unable to create inbound dbus pipe - disabling DBus\");\n\t\treturn false;\n\t}\n\tif (open_pipe(dbus_out_pipe)) {\n\t\tlog_message(LOG_INFO, \"Unable to create outbound dbus pipe - disabling DBus\");\n\t\tclose(dbus_in_pipe[0]);\n\t\tclose(dbus_in_pipe[1]);\n\t\treturn false;\n\t}\n\n\t/* We don't want the main thread to block when using the pipes,\n\t * but the other side of the pipes should block. */\n\tfcntl(dbus_in_pipe[1], F_SETFL, fcntl(dbus_in_pipe[1], F_GETFL) & ~O_NONBLOCK);\n\tfcntl(dbus_out_pipe[0], F_SETFL, fcntl(dbus_out_pipe[0], F_GETFL) & ~O_NONBLOCK);\n\n\tthread_add_read(master, handle_dbus_msg, NULL, dbus_in_pipe[0], TIMER_NEVER);\n\n\t/* Initialise the thread termination semaphore */\n\tsem_init(&thread_end, 0, 0);\n\n\t/* Block signals (all) we don't want the new thread to process */\n\tsigfillset(&sigset);\n\tpthread_sigmask(SIG_SETMASK, &sigset, &cursigset);\n\n\t/* Now create the dbus thread */\n\tpthread_create(&dbus_thread, NULL, &dbus_main, NULL);\n\n\t/* Reenable our signals */\n\tpthread_sigmask(SIG_SETMASK, &cursigset, NULL);\n\n\treturn true;\n}\n\nvoid\ndbus_stop(void)\n{\n\tstruct timespec thread_end_wait;\n\tint ret;\n\tgchar *path;\n\n\tif (global_connection != NULL) {\n\t\tpath = dbus_object_create_path_vrrp();\n\t\tdbus_emit_signal(global_connection, path, DBUS_VRRP_INTERFACE, \"VrrpStopped\", NULL);\n\t\tg_free(path);\n\t}\n\n\tg_main_loop_quit(loop);\n\n\tg_dbus_node_info_unref(vrrp_introspection_data);\n\tg_dbus_node_info_unref(vrrp_instance_introspection_data);\n\n\tclock_gettime(CLOCK_REALTIME, &thread_end_wait);\n\tthread_end_wait.tv_sec += 1;\n\twhile ((ret = sem_timedwait(&thread_end, &thread_end_wait)) == -1 && errno == EINTR) ;\n\n\tif (ret == -1 ) {\n\t\tif (errno == ETIMEDOUT)\n\t\t\tlog_message(LOG_INFO, \"DBus thread termination timed out\");\n\t\telse\n\t\t\tlog_message(LOG_INFO, \"sem_timewait error %d\", errno);\n\t}\n\telse {\n\t\tlog_message(LOG_INFO, \"Released DBus\");\n\t\tsem_destroy(&thread_end);\n\t}\n}\n\n#ifdef THREAD_DUMP\nvoid\nregister_vrrp_dbus_addresses(void)\n{\n\tregister_thread_address(\"handle_dbus_msg\", handle_dbus_msg);\n}\n#endif\n", "/*\n * Soft:        Vrrpd is an implementation of VRRPv2 as specified in rfc2338.\n *              VRRP is a protocol which elect a master server on a LAN. If the\n *              master fails, a backup server takes over.\n *              The original implementation has been made by jerome etienne.\n *\n * Part:        Output running VRRP state information in JSON format\n *\n * Author:      Damien Clabaut, <Damien.Clabaut@corp.ovh.com>\n *\n *              This program is distributed in the hope that it will be useful,\n *              but WITHOUT ANY WARRANTY; without even the implied warranty of\n *              MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n *              See the GNU General Public License for more details.\n *\n *              This program is free software; you can redistribute it and/or\n *              modify it under the terms of the GNU General Public License\n *              as published by the Free Software Foundation; either version\n *              2 of the License, or (at your option) any later version.\n *\n * Copyright (C) 2017 Damien Clabaut, <Damien.Clabaut@corp.ovh.com>\n * Copyright (C) 2017-2017 Alexandre Cassen, <acassen@gmail.com>\n */\n\n#include \"config.h\"\n#include \"vrrp_json.h\"\n\n#include <errno.h>\n#include <stdio.h>\n#include <json.h>\n\n#include \"vrrp.h\"\n#include \"vrrp_track.h\"\n#include \"list.h\"\n#include \"vrrp_data.h\"\n#include \"vrrp_iproute.h\"\n#include \"vrrp_iprule.h\"\n#include \"logger.h\"\n#include \"timer.h\"\n\nstatic inline double\ntimeval_to_double(const timeval_t *t)\n{\n\t/* The casts are necessary to avoid conversion warnings */\n\treturn (double)t->tv_sec + (double)t->tv_usec / TIMER_HZ_FLOAT;\n}\n\nvoid\nvrrp_print_json(void)\n{\n\tFILE *file;\n\telement e;\n\tstruct json_object *array;\n\n\tif (LIST_ISEMPTY(vrrp_data->vrrp))\n\t\treturn;\n\n\tfile = fopen (\"/tmp/keepalived.json\",\"w\");\n\tif (!file) {\n\t\tlog_message(LOG_INFO, \"Can't open /tmp/keepalived.json (%d: %s)\",\n\t\t\terrno, strerror(errno));\n\t\treturn;\n\t}\n\n\tarray = json_object_new_array();\n\n\tfor (e = LIST_HEAD(vrrp_data->vrrp); e; ELEMENT_NEXT(e)) {\n\t\tstruct json_object *instance_json, *json_stats, *json_data,\n\t\t\t*vips, *evips, *track_ifp, *track_script;\n#ifdef _HAVE_FIB_ROUTING_\n\t\tstruct json_object *vroutes, *vrules;\n#endif\n\t\telement f;\n\n\t\tvrrp_t *vrrp = ELEMENT_DATA(e);\n\t\tinstance_json = json_object_new_object();\n\t\tjson_stats = json_object_new_object();\n\t\tjson_data = json_object_new_object();\n\t\tvips = json_object_new_array();\n\t\tevips = json_object_new_array();\n\t\ttrack_ifp = json_object_new_array();\n\t\ttrack_script = json_object_new_array();\n#ifdef _HAVE_FIB_ROUTING_\n\t\tvroutes = json_object_new_array();\n\t\tvrules = json_object_new_array();\n#endif\n\n\t\t// Dump data to json\n\t\tjson_object_object_add(json_data, \"iname\",\n\t\t\tjson_object_new_string(vrrp->iname));\n\t\tjson_object_object_add(json_data, \"dont_track_primary\",\n\t\t\tjson_object_new_int(vrrp->dont_track_primary));\n\t\tjson_object_object_add(json_data, \"skip_check_adv_addr\",\n\t\t\tjson_object_new_int(vrrp->skip_check_adv_addr));\n\t\tjson_object_object_add(json_data, \"strict_mode\",\n\t\t\tjson_object_new_int((int)vrrp->strict_mode));\n#ifdef _HAVE_VRRP_VMAC_\n\t\tjson_object_object_add(json_data, \"vmac_ifname\",\n\t\t\tjson_object_new_string(vrrp->vmac_ifname));\n#endif\n\t\t// Tracked interfaces are stored in a list\n\t\tif (!LIST_ISEMPTY(vrrp->track_ifp)) {\n\t\t\tfor (f = LIST_HEAD(vrrp->track_ifp); f; ELEMENT_NEXT(f)) {\n\t\t\t\tinterface_t *ifp = ELEMENT_DATA(f);\n\t\t\t\tjson_object_array_add(track_ifp,\n\t\t\t\t\tjson_object_new_string(ifp->ifname));\n\t\t\t}\n\t\t}\n\t\tjson_object_object_add(json_data, \"track_ifp\", track_ifp);\n\n\t\t// Tracked scripts also\n\t\tif (!LIST_ISEMPTY(vrrp->track_script)) {\n\t\t\tfor (f = LIST_HEAD(vrrp->track_script); f; ELEMENT_NEXT(f)) {\n\t\t\t\ttracked_sc_t *tsc = ELEMENT_DATA(f);\n\t\t\t\tvrrp_script_t *vscript = tsc->scr;\n\t\t\t\tjson_object_array_add(track_script,\n\t\t\t\t\tjson_object_new_string(cmd_str(&vscript->script)));\n\t\t\t}\n\t\t}\n\t\tjson_object_object_add(json_data, \"track_script\", track_script);\n\n\t\tjson_object_object_add(json_data, \"ifp_ifname\",\n\t\t\tjson_object_new_string(vrrp->ifp->ifname));\n\t\tjson_object_object_add(json_data, \"master_priority\",\n\t\t\tjson_object_new_int(vrrp->master_priority));\n\t\tjson_object_object_add(json_data, \"last_transition\",\n\t\t\tjson_object_new_double(timeval_to_double(&vrrp->last_transition)));\n\t\tjson_object_object_add(json_data, \"garp_delay\",\n\t\t\tjson_object_new_double(vrrp->garp_delay / TIMER_HZ_FLOAT));\n\t\tjson_object_object_add(json_data, \"garp_refresh\",\n\t\t\tjson_object_new_int((int)vrrp->garp_refresh.tv_sec));\n\t\tjson_object_object_add(json_data, \"garp_rep\",\n\t\t\tjson_object_new_int((int)vrrp->garp_rep));\n\t\tjson_object_object_add(json_data, \"garp_refresh_rep\",\n\t\t\tjson_object_new_int((int)vrrp->garp_refresh_rep));\n\t\tjson_object_object_add(json_data, \"garp_lower_prio_delay\",\n\t\t\tjson_object_new_int((int)(vrrp->garp_lower_prio_delay / TIMER_HZ)));\n\t\tjson_object_object_add(json_data, \"garp_lower_prio_rep\",\n\t\t\tjson_object_new_int((int)vrrp->garp_lower_prio_rep));\n\t\tjson_object_object_add(json_data, \"lower_prio_no_advert\",\n\t\t\tjson_object_new_int((int)vrrp->lower_prio_no_advert));\n\t\tjson_object_object_add(json_data, \"higher_prio_send_advert\",\n\t\t\tjson_object_new_int((int)vrrp->higher_prio_send_advert));\n\t\tjson_object_object_add(json_data, \"vrid\",\n\t\t\tjson_object_new_int(vrrp->vrid));\n\t\tjson_object_object_add(json_data, \"base_priority\",\n\t\t\tjson_object_new_int(vrrp->base_priority));\n\t\tjson_object_object_add(json_data, \"effective_priority\",\n\t\t\tjson_object_new_int(vrrp->effective_priority));\n\t\tjson_object_object_add(json_data, \"vipset\",\n\t\t\tjson_object_new_boolean(vrrp->vipset));\n\n\t\t//Virtual IPs are stored in a list\n\t\tif (!LIST_ISEMPTY(vrrp->vip)) {\n\t\t\tfor (f = LIST_HEAD(vrrp->vip); f; ELEMENT_NEXT(f)) {\n\t\t\t\tip_address_t *vip = ELEMENT_DATA(f);\n\t\t\t\tchar ipaddr[INET6_ADDRSTRLEN];\n\t\t\t\tinet_ntop(vrrp->family, &(vip->u.sin.sin_addr.s_addr),\n\t\t\t\t\tipaddr, INET6_ADDRSTRLEN);\n\t\t\t\tjson_object_array_add(vips,\n\t\t\t\t\tjson_object_new_string(ipaddr));\n\t\t\t}\n\t\t}\n\t\tjson_object_object_add(json_data, \"vips\", vips);\n\n\t\t//External VIPs are also stored in a list\n\t\tif (!LIST_ISEMPTY(vrrp->evip)) {\n\t\t\tfor (f = LIST_HEAD(vrrp->evip); f; ELEMENT_NEXT(f)) {\n\t\t\t\tip_address_t *evip = ELEMENT_DATA(f);\n\t\t\t\tchar ipaddr[INET6_ADDRSTRLEN];\n\t\t\t\tinet_ntop(vrrp->family, &(evip->u.sin.sin_addr.s_addr),\n\t\t\t\t\tipaddr, INET6_ADDRSTRLEN);\n\t\t\t\tjson_object_array_add(evips,\n\t\t\t\t\tjson_object_new_string(ipaddr));\n\t\t\t}\n\t\t}\n\t\tjson_object_object_add(json_data, \"evips\", evips);\n\n\t\tjson_object_object_add(json_data, \"promote_secondaries\",\n\t\t\tjson_object_new_boolean(vrrp->promote_secondaries));\n\n#ifdef _HAVE_FIB_ROUTING_\n\t\t// Dump vroutes\n\t\tif (!LIST_ISEMPTY(vrrp->vroutes)) {\n\t\t\tfor (f = LIST_HEAD(vrrp->vroutes); f; ELEMENT_NEXT(f)) {\n\t\t\t\tip_route_t *route = ELEMENT_DATA(f);\n\t\t\t\tchar *buf = MALLOC(ROUTE_BUF_SIZE);\n\t\t\t\tformat_iproute(route, buf, ROUTE_BUF_SIZE);\n\t\t\t\tjson_object_array_add(vroutes,\n\t\t\t\t\tjson_object_new_string(buf));\n\t\t\t}\n\t\t}\n\t\tjson_object_object_add(json_data, \"vroutes\", vroutes);\n\n\t\t// Dump vrules\n\t\tif (!LIST_ISEMPTY(vrrp->vrules)) {\n\t\t\tfor (f = LIST_HEAD(vrrp->vrules); f; ELEMENT_NEXT(f)) {\n\t\t\t\tip_rule_t *rule = ELEMENT_DATA(f);\n\t\t\t\tchar *buf = MALLOC(RULE_BUF_SIZE);\n\t\t\t\tformat_iprule(rule, buf, RULE_BUF_SIZE);\n\t\t\t\tjson_object_array_add(vrules,\n\t\t\t\t\tjson_object_new_string(buf));\n\t\t\t}\n\t\t}\n\t\tjson_object_object_add(json_data, \"vrules\", vrules);\n#endif\n\n\t\tjson_object_object_add(json_data, \"adver_int\",\n\t\t\tjson_object_new_double(vrrp->adver_int / TIMER_HZ_FLOAT));\n\t\tjson_object_object_add(json_data, \"master_adver_int\",\n\t\t\tjson_object_new_double(vrrp->master_adver_int / TIMER_HZ_FLOAT));\n\t\tjson_object_object_add(json_data, \"accept\",\n\t\t\tjson_object_new_int((int)vrrp->accept));\n\t\tjson_object_object_add(json_data, \"nopreempt\",\n\t\t\tjson_object_new_boolean(vrrp->nopreempt));\n\t\tjson_object_object_add(json_data, \"preempt_delay\",\n\t\t\tjson_object_new_int((int)(vrrp->preempt_delay / TIMER_HZ)));\n\t\tjson_object_object_add(json_data, \"state\",\n\t\t\tjson_object_new_int(vrrp->state));\n\t\tjson_object_object_add(json_data, \"wantstate\",\n\t\t\tjson_object_new_int(vrrp->wantstate));\n\t\tjson_object_object_add(json_data, \"version\",\n\t\t\tjson_object_new_int(vrrp->version));\n\t\tif (vrrp->script_backup)\n\t\t\tjson_object_object_add(json_data, \"script_backup\",\n\t\t\t\tjson_object_new_string(cmd_str(vrrp->script_backup)));\n\t\tif (vrrp->script_master)\n\t\t\tjson_object_object_add(json_data, \"script_master\",\n\t\t\t\tjson_object_new_string(cmd_str(vrrp->script_master)));\n\t\tif (vrrp->script_fault)\n\t\t\tjson_object_object_add(json_data, \"script_fault\",\n\t\t\t\tjson_object_new_string(cmd_str(vrrp->script_fault)));\n\t\tif (vrrp->script_stop)\n\t\t\tjson_object_object_add(json_data, \"script_stop\",\n\t\t\t\tjson_object_new_string(cmd_str(vrrp->script_stop)));\n\t\tif (vrrp->script)\n\t\t\tjson_object_object_add(json_data, \"script\",\n\t\t\t\tjson_object_new_string(cmd_str(vrrp->script)));\n\t\tif (vrrp->script_master_rx_lower_pri)\n\t\t\tjson_object_object_add(json_data, \"script_master_rx_lower_pri\",\n\t\t\t\tjson_object_new_string(cmd_str(vrrp->script_master_rx_lower_pri)));\n\t\tjson_object_object_add(json_data, \"smtp_alert\",\n\t\t\tjson_object_new_boolean(vrrp->smtp_alert));\n#ifdef _WITH_VRRP_AUTH_\n\t\tif (vrrp->auth_type) {\n\t\t\tjson_object_object_add(json_data, \"auth_type\",\n\t\t\t\tjson_object_new_int(vrrp->auth_type));\n\n\t\t\tif (vrrp->auth_type != VRRP_AUTH_AH) {\n\t\t\t\tchar auth_data[sizeof(vrrp->auth_data) + 1];\n\t\t\t\tmemcpy(auth_data, vrrp->auth_data, sizeof(vrrp->auth_data));\n\t\t\t\tauth_data[sizeof(vrrp->auth_data)] = '\\0';\n\t\t\t\tjson_object_object_add(json_data, \"auth_data\",\n\t\t\t\t\tjson_object_new_string(auth_data));\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tjson_object_object_add(json_data, \"auth_type\",\n\t\t\t\tjson_object_new_int(0));\n#endif\n\n\t\t// Dump stats to json\n\t\tjson_object_object_add(json_stats, \"advert_rcvd\",\n\t\t\tjson_object_new_int64((int64_t)vrrp->stats->advert_rcvd));\n\t\tjson_object_object_add(json_stats, \"advert_sent\",\n\t\t\tjson_object_new_int64(vrrp->stats->advert_sent));\n\t\tjson_object_object_add(json_stats, \"become_master\",\n\t\t\tjson_object_new_int64(vrrp->stats->become_master));\n\t\tjson_object_object_add(json_stats, \"release_master\",\n\t\t\tjson_object_new_int64(vrrp->stats->release_master));\n\t\tjson_object_object_add(json_stats, \"packet_len_err\",\n\t\t\tjson_object_new_int64((int64_t)vrrp->stats->packet_len_err));\n\t\tjson_object_object_add(json_stats, \"advert_interval_err\",\n\t\t\tjson_object_new_int64((int64_t)vrrp->stats->advert_interval_err));\n\t\tjson_object_object_add(json_stats, \"ip_ttl_err\",\n\t\t\tjson_object_new_int64((int64_t)vrrp->stats->ip_ttl_err));\n\t\tjson_object_object_add(json_stats, \"invalid_type_rcvd\",\n\t\t\tjson_object_new_int64((int64_t)vrrp->stats->invalid_type_rcvd));\n\t\tjson_object_object_add(json_stats, \"addr_list_err\",\n\t\t\tjson_object_new_int64((int64_t)vrrp->stats->addr_list_err));\n\t\tjson_object_object_add(json_stats, \"invalid_authtype\",\n\t\t\tjson_object_new_int64(vrrp->stats->invalid_authtype));\n#ifdef _WITH_VRRP_AUTH_\n\t\tjson_object_object_add(json_stats, \"authtype_mismatch\",\n\t\t\tjson_object_new_int64(vrrp->stats->authtype_mismatch));\n\t\tjson_object_object_add(json_stats, \"auth_failure\",\n\t\t\tjson_object_new_int64(vrrp->stats->auth_failure));\n#endif\n\t\tjson_object_object_add(json_stats, \"pri_zero_rcvd\",\n\t\t\tjson_object_new_int64((int64_t)vrrp->stats->pri_zero_rcvd));\n\t\tjson_object_object_add(json_stats, \"pri_zero_sent\",\n\t\t\tjson_object_new_int64((int64_t)vrrp->stats->pri_zero_sent));\n\n\t\t// Add both json_data and json_stats to main instance_json\n\t\tjson_object_object_add(instance_json, \"data\", json_data);\n\t\tjson_object_object_add(instance_json, \"stats\", json_stats);\n\n\t\t// Add instance_json to main array\n\t\tjson_object_array_add(array, instance_json);\n\n\t}\n\tfprintf(file, \"%s\", json_object_to_json_string(array));\n\tfclose(file);\n}\n", "/*\n * Soft:        Keepalived is a failover program for the LVS project\n *              <www.linuxvirtualserver.org>. It monitor & manipulate\n *              a loadbalanced server pool using multi-layer checks.\n *\n * Part:        Configuration file parser/reader. Place into the dynamic\n *              data structure representation the conf file representing\n *              the loadbalanced server pool.\n *\n * Author:      Alexandre Cassen, <acassen@linux-vs.org>\n *\n *              This program is distributed in the hope that it will be useful,\n *              but WITHOUT ANY WARRANTY; without even the implied warranty of\n *              MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n *              See the GNU General Public License for more details.\n *\n *              This program is free software; you can redistribute it and/or\n *              modify it under the terms of the GNU General Public License\n *              as published by the Free Software Foundation; either version\n *              2 of the License, or (at your option) any later version.\n *\n * Copyright (C) 2001-2017 Alexandre Cassen, <acassen@gmail.com>\n */\n\n#include \"config.h\"\n\n#include <unistd.h>\n#include <string.h>\n#include <stdint.h>\n#include <net/if_arp.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n//#include <unistd.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <net/if.h>\n\n#include \"vrrp_parser.h\"\n#include \"logger.h\"\n#include \"parser.h\"\n#include \"bitops.h\"\n#include \"utils.h\"\n\n#include \"main.h\"\n#include \"global_data.h\"\n#include \"global_parser.h\"\n\n#include \"vrrp_data.h\"\n#include \"vrrp_ipaddress.h\"\n#include \"vrrp_sync.h\"\n#include \"vrrp_track.h\"\n#ifdef _HAVE_VRRP_VMAC_\n#include \"vrrp_vmac.h\"\n#endif\n#include \"vrrp_static_track.h\"\n\n#ifdef _WITH_LVS_\n#include \"check_parser.h\"\n#endif\n#ifdef _WITH_BFD_\n#include \"bfd_parser.h\"\n#endif\n\n/* Used for initialising track files */\nstatic enum {\n\tTRACK_FILE_NO_INIT,\n\tTRACK_FILE_CREATE,\n\tTRACK_FILE_INIT,\n} track_file_init;\nstatic int track_file_init_value;\n\nstatic bool script_user_set;\nstatic bool remove_script;\n\n/* track groups for static items */\nstatic void\nstatic_track_group_handler(vector_t *strvec)\n{\n\telement e;\n\tstatic_track_group_t *tg;\n\tchar* gname;\n\n\tif (!strvec)\n\t\treturn;\n\n\tif (vector_count(strvec) != 2) {\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"track_group must have a name - skipping\");\n\t\tskip_block(true);\n\t\treturn;\n\t}\n\n\tgname = strvec_slot(strvec, 1);\n\n\t/* check group doesn't already exist */\n\tLIST_FOREACH(vrrp_data->static_track_groups, tg, e) {\n\t\tif (!strcmp(gname,tg->gname)) {\n\t\t\treport_config_error(CONFIG_GENERAL_ERROR, \"track_group %s already defined\", gname);\n\t\t\tskip_block(true);\n\t\t\treturn;\n\t\t}\n\t}\n\n\talloc_static_track_group(gname);\n}\n\nstatic void\nstatic_track_group_group_handler(vector_t *strvec)\n{\n\tstatic_track_group_t *tgroup = LIST_TAIL_DATA(vrrp_data->static_track_groups);\n\n\tif (tgroup->iname) {\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"Group list already specified for sync group %s\", tgroup->gname);\n\t\tskip_block(true);\n\t\treturn;\n\t}\n\n\ttgroup->iname = read_value_block(strvec);\n\n\tif (!tgroup->iname)\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"Warning - track group %s has empty group block\", tgroup->gname);\n}\n\n/* Static addresses handler */\nstatic void\nstatic_addresses_handler(vector_t *strvec)\n{\n\tglobal_data->have_vrrp_config = true;\n\n\tif (!strvec)\n\t\treturn;\n\n\talloc_value_block(alloc_saddress, vector_slot(strvec, 0));\n}\n\n#ifdef _HAVE_FIB_ROUTING_\n/* Static routes handler */\nstatic void\nstatic_routes_handler(vector_t *strvec)\n{\n\tglobal_data->have_vrrp_config = true;\n\n\tif (!strvec)\n\t\treturn;\n\n\talloc_value_block(alloc_sroute, vector_slot(strvec, 0));\n}\n\n/* Static rules handler */\nstatic void\nstatic_rules_handler(vector_t *strvec)\n{\n\tglobal_data->have_vrrp_config = true;\n\n\tif (!strvec)\n\t\treturn;\n\n\talloc_value_block(alloc_srule, vector_slot(strvec, 0));\n}\n#endif\n\n/* VRRP handlers */\nstatic void\nvrrp_sync_group_handler(vector_t *strvec)\n{\n\tlist l;\n\telement e;\n\tvrrp_sgroup_t *sg;\n\tchar* gname;\n\n\tif (!strvec)\n\t\treturn;\n\n\tif (vector_count(strvec) != 2) {\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"vrrp_sync_group must have a name - skipping\");\n\t\tskip_block(true);\n\t\treturn;\n\t}\n\n\tgname = strvec_slot(strvec, 1);\n\n\t/* check group doesn't already exist */\n\tif (!LIST_ISEMPTY(vrrp_data->vrrp_sync_group)) {\n\t\tl = vrrp_data->vrrp_sync_group;\n\t\tfor (e = LIST_HEAD(l); e; ELEMENT_NEXT(e)) {\n\t\t\tsg = ELEMENT_DATA(e);\n\t\t\tif (!strcmp(gname,sg->gname)) {\n\t\t\t\treport_config_error(CONFIG_GENERAL_ERROR, \"vrrp sync group %s already defined\", gname);\n\t\t\t\tskip_block(true);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\talloc_vrrp_sync_group(gname);\n}\n\nstatic void\nvrrp_group_handler(vector_t *strvec)\n{\n\tvrrp_sgroup_t *vgroup = LIST_TAIL_DATA(vrrp_data->vrrp_sync_group);\n\n\tif (vgroup->iname) {\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"Group list already specified for sync group %s\", vgroup->gname);\n\t\tskip_block(true);\n\t\treturn;\n\t}\n\n\tvgroup->iname = read_value_block(strvec);\n\n\tif (!vgroup->iname)\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"Warning - sync group %s has empty group block\", vgroup->gname);\n}\n\nstatic void\nvrrp_group_track_if_handler(vector_t *strvec)\n{\n\talloc_value_block(alloc_vrrp_group_track_if, vector_slot(strvec, 0));\n}\n\nstatic void\nvrrp_group_track_scr_handler(vector_t *strvec)\n{\n\talloc_value_block(alloc_vrrp_group_track_script, vector_slot(strvec, 0));\n}\n\nstatic void\nvrrp_group_track_file_handler(vector_t *strvec)\n{\n\talloc_value_block(alloc_vrrp_group_track_file, vector_slot(strvec, 0));\n}\n\n#if defined _WITH_BFD_\nstatic void\nvrrp_group_track_bfd_handler(vector_t *strvec)\n{\n\talloc_value_block(alloc_vrrp_group_track_bfd, vector_slot(strvec, 0));\n}\n#endif\n\nstatic inline notify_script_t*\nset_vrrp_notify_script(__attribute__((unused)) vector_t *strvec, int extra_params)\n{\n\treturn notify_script_init(extra_params, \"notify\");\n}\n\nstatic void\nvrrp_gnotify_backup_handler(vector_t *strvec)\n{\n\tvrrp_sgroup_t *vgroup = LIST_TAIL_DATA(vrrp_data->vrrp_sync_group);\n\tif (vgroup->script_backup) {\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"vrrp group %s: notify_backup script already specified - ignoring %s\", vgroup->gname, FMT_STR_VSLOT(strvec,1));\n\t\treturn;\n\t}\n\tvgroup->script_backup = set_vrrp_notify_script(strvec, 0);\n\tvgroup->notify_exec = true;\n}\nstatic void\nvrrp_gnotify_master_handler(vector_t *strvec)\n{\n\tvrrp_sgroup_t *vgroup = LIST_TAIL_DATA(vrrp_data->vrrp_sync_group);\n\tif (vgroup->script_master) {\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"vrrp group %s: notify_master script already specified - ignoring %s\", vgroup->gname, FMT_STR_VSLOT(strvec,1));\n\t\treturn;\n\t}\n\tvgroup->script_master = set_vrrp_notify_script(strvec, 0);\n\tvgroup->notify_exec = true;\n}\nstatic void\nvrrp_gnotify_fault_handler(vector_t *strvec)\n{\n\tvrrp_sgroup_t *vgroup = LIST_TAIL_DATA(vrrp_data->vrrp_sync_group);\n\tif (vgroup->script_fault) {\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"vrrp group %s: notify_fault script already specified - ignoring %s\", vgroup->gname, FMT_STR_VSLOT(strvec,1));\n\t\treturn;\n\t}\n\tvgroup->script_fault = set_vrrp_notify_script(strvec, 0);\n\tvgroup->notify_exec = true;\n}\nstatic void\nvrrp_gnotify_stop_handler(vector_t *strvec)\n{\n\tvrrp_sgroup_t *vgroup = LIST_TAIL_DATA(vrrp_data->vrrp_sync_group);\n\tif (vgroup->script_stop) {\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"vrrp group %s: notify_stop script already specified - ignoring %s\", vgroup->gname, FMT_STR_VSLOT(strvec,1));\n\t\treturn;\n\t}\n\tvgroup->script_stop = set_vrrp_notify_script(strvec, 0);\n\tvgroup->notify_exec = true;\n}\nstatic void\nvrrp_gnotify_handler(vector_t *strvec)\n{\n\tvrrp_sgroup_t *vgroup = LIST_TAIL_DATA(vrrp_data->vrrp_sync_group);\n\tif (vgroup->script) {\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"vrrp group %s: notify script already specified - ignoring %s\", vgroup->gname, FMT_STR_VSLOT(strvec,1));\n\t\treturn;\n\t}\n\tvgroup->script = set_vrrp_notify_script(strvec, 4);\n\tvgroup->notify_exec = true;\n}\nstatic void\nvrrp_gsmtp_handler(__attribute__((unused)) vector_t *strvec)\n{\n\tvrrp_sgroup_t *vgroup = LIST_TAIL_DATA(vrrp_data->vrrp_sync_group);\n\tint res = true;\n\n\tif (vector_size(strvec) >= 2) {\n\t\tres = check_true_false(strvec_slot(strvec, 1));\n\t\tif (res == -1) {\n\t\t\treport_config_error(CONFIG_GENERAL_ERROR, \"Invalid vrrp_group smtp_alert parameter %s\", FMT_STR_VSLOT(strvec, 1));\n\t\t\treturn;\n\t\t}\n\t}\n\tvgroup->smtp_alert = res;\n}\nstatic void\nvrrp_gglobal_tracking_handler(__attribute__((unused)) vector_t *strvec)\n{\n\tvrrp_sgroup_t *vgroup = LIST_TAIL_DATA(vrrp_data->vrrp_sync_group);\n\n\treport_config_error(CONFIG_GENERAL_ERROR, \"(%s) global_tracking is deprecated. Use track_interface/script/file on the sync group\", vgroup->gname);\n\tvgroup->sgroup_tracking_weight = true;\n}\nstatic void\nvrrp_sg_tracking_weight_handler(__attribute__((unused)) vector_t *strvec)\n{\n\tvrrp_sgroup_t *vgroup = LIST_TAIL_DATA(vrrp_data->vrrp_sync_group);\n\tvgroup->sgroup_tracking_weight = true;\n}\nstatic void\nvrrp_handler(vector_t *strvec)\n{\n\tlist l;\n\telement e;\n\tvrrp_t *vrrp;\n\tchar *iname;\n\n\tglobal_data->have_vrrp_config = true;\n\n\tif (!strvec)\n\t\treturn;\n\n\tif (vector_count(strvec) != 2) {\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"vrrp_instance must have a name\");\n\t\tskip_block(true);\n\t\treturn;\n\t}\n\n\tiname = strvec_slot(strvec,1);\n\n\t/* Make sure the vrrp instance doesn't already exist */\n\tif (!LIST_ISEMPTY(vrrp_data->vrrp)) {\n\t\tl = vrrp_data->vrrp;\n\t\tfor (e = LIST_HEAD(l); e; ELEMENT_NEXT(e)) {\n\t\t\tvrrp = ELEMENT_DATA(e);\n\t\t\tif (!strcmp(iname,vrrp->iname)) {\n\t\t\t\treport_config_error(CONFIG_GENERAL_ERROR, \"vrrp instance %s already defined\", iname );\n\t\t\t\tskip_block(true);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\talloc_vrrp(iname);\n}\n#ifdef _HAVE_VRRP_VMAC_\nstatic void\nvrrp_vmac_handler(vector_t *strvec)\n{\n\tvrrp_t *vrrp = LIST_TAIL_DATA(vrrp_data->vrrp);\n\tinterface_t *ifp;\n\n\t__set_bit(VRRP_VMAC_BIT, &vrrp->vmac_flags);\n\n\tif (vector_size(strvec) >= 2) {\n\t\tif (strlen(strvec_slot(strvec, 1)) >= IFNAMSIZ) {\n\t\t\treport_config_error(CONFIG_GENERAL_ERROR, \"VMAC interface name '%s' too long - ignoring\", FMT_STR_VSLOT(strvec, 1));\n\t\t\treturn;\n\t\t}\n\n\t\tstrcpy(vrrp->vmac_ifname, strvec_slot(strvec, 1));\n\n\t\t/* Check if the interface exists and is a macvlan we can use */\n\t\tif ((ifp = if_get_by_ifname(vrrp->vmac_ifname, IF_NO_CREATE)) &&\n\t\t    ifp->vmac_type != MACVLAN_MODE_PRIVATE) {\n\t\t\treport_config_error(CONFIG_GENERAL_ERROR, \"(%s) interface %s already exists and is not a private macvlan; ignoring vmac if_name\", vrrp->iname, vrrp->vmac_ifname);\n\t\t\tvrrp->vmac_ifname[0] = '\\0';\n\t\t}\n\t}\n}\nstatic void\nvrrp_vmac_xmit_base_handler(__attribute__((unused)) vector_t *strvec)\n{\n\tvrrp_t *vrrp = LIST_TAIL_DATA(vrrp_data->vrrp);\n\n\t__set_bit(VRRP_VMAC_XMITBASE_BIT, &vrrp->vmac_flags);\n}\n#endif\nstatic void\nvrrp_unicast_peer_handler(vector_t *strvec)\n{\n\talloc_value_block(alloc_vrrp_unicast_peer, vector_slot(strvec, 0));\n}\n#ifdef _WITH_UNICAST_CHKSUM_COMPAT_\nstatic void\nvrrp_unicast_chksum_handler(vector_t *strvec)\n{\n\tvrrp_t *vrrp = LIST_TAIL_DATA(vrrp_data->vrrp);\n\n\tif (vector_size(strvec) >= 2) {\n\t\tif (!strcmp(strvec_slot(strvec, 1), \"never\"))\n\t\t\tvrrp->unicast_chksum_compat = CHKSUM_COMPATIBILITY_NEVER;\n\t\telse\n\t\t\treport_config_error(CONFIG_GENERAL_ERROR, \"(%s) Unknown old_unicast_chksum mode %s - ignoring\", vrrp->iname, FMT_STR_VSLOT(strvec, 1));\n\t}\n\telse\n\t\tvrrp->unicast_chksum_compat = CHKSUM_COMPATIBILITY_CONFIG;\n}\n#endif\nstatic void\nvrrp_native_ipv6_handler(__attribute__((unused)) vector_t *strvec)\n{\n\tvrrp_t *vrrp = LIST_TAIL_DATA(vrrp_data->vrrp);\n\n\tif (vrrp->family == AF_INET) {\n\t\treport_config_error(CONFIG_GENERAL_ERROR,\"(%s) Cannot specify native_ipv6 with IPv4 addresses\", vrrp->iname);\n\t\treturn;\n\t}\n\n\tvrrp->family = AF_INET6;\n\tvrrp->version = VRRP_VERSION_3;\n}\nstatic void\nvrrp_state_handler(vector_t *strvec)\n{\n\tchar *str = strvec_slot(strvec, 1);\n\tvrrp_t *vrrp = LIST_TAIL_DATA(vrrp_data->vrrp);\n\n\tif (!strcmp(str, \"MASTER\"))\n\t\tvrrp->wantstate = VRRP_STATE_MAST;\n\telse if (!strcmp(str, \"BACKUP\"))\n\t{\n\t\tif (vrrp->wantstate == VRRP_STATE_MAST)\n\t\t\treport_config_error(CONFIG_GENERAL_ERROR, \"(%s) state previously set as MASTER - ignoring BACKUP\", vrrp->iname);\n\t\telse\n\t\t\tvrrp->wantstate = VRRP_STATE_BACK;\n\t}\n\telse {\n\t\treport_config_error(CONFIG_GENERAL_ERROR,\"(%s) unknown state '%s', defaulting to BACKUP\", vrrp->iname, str);\n\t\tvrrp->wantstate = VRRP_STATE_BACK;\n\t}\n}\nstatic void\nvrrp_int_handler(vector_t *strvec)\n{\n\tvrrp_t *vrrp = LIST_TAIL_DATA(vrrp_data->vrrp);\n\tchar *name = strvec_slot(strvec, 1);\n\n\tif (strlen(name) >= IFNAMSIZ) {\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"Interface name '%s' too long - ignoring\", name);\n\t\treturn;\n\t}\n\n\tvrrp->ifp = if_get_by_ifname(name, IF_CREATE_IF_DYNAMIC);\n\tif (!vrrp->ifp)\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"WARNING - interface %s for vrrp_instance %s doesn't exist\", name, vrrp->iname);\n\telse if (vrrp->ifp->hw_type == ARPHRD_LOOPBACK) {\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"(%s) cannot use a loopback interface (%s) for vrrp - ignoring\", vrrp->iname, vrrp->ifp->ifname);\n\t\tvrrp->ifp = NULL;\n\t}\n\n#ifdef _HAVE_VRRP_VMAC_\n\tvrrp->configured_ifp = vrrp->ifp;\n#endif\n}\nstatic void\nvrrp_linkbeat_handler(__attribute__((unused)) vector_t *strvec)\n{\n\tvrrp_t *vrrp = LIST_TAIL_DATA(vrrp_data->vrrp);\n\n\tvrrp->linkbeat_use_polling = true;\n}\nstatic void\nvrrp_track_if_handler(vector_t *strvec)\n{\n\talloc_value_block(alloc_vrrp_track_if, vector_slot(strvec, 0));\n}\nstatic void\nvrrp_track_scr_handler(vector_t *strvec)\n{\n\talloc_value_block(alloc_vrrp_track_script, vector_slot(strvec, 0));\n}\nstatic void\nvrrp_track_file_handler(vector_t *strvec)\n{\n\talloc_value_block(alloc_vrrp_track_file, vector_slot(strvec, 0));\n}\nstatic void\nvrrp_dont_track_handler(__attribute__((unused)) vector_t *strvec)\n{\n\tvrrp_t *vrrp = LIST_TAIL_DATA(vrrp_data->vrrp);\n\tvrrp->dont_track_primary = true;\n}\n#ifdef _WITH_BFD_\nstatic void\nvrrp_track_bfd_handler(vector_t *strvec)\n{\n\talloc_value_block(alloc_vrrp_track_bfd, vector_slot(strvec, 0));\n}\n#endif\nstatic void\nvrrp_srcip_handler(vector_t *strvec)\n{\n\tvrrp_t *vrrp = LIST_TAIL_DATA(vrrp_data->vrrp);\n\tstruct sockaddr_storage *saddr = &vrrp->saddr;\n\n\tif (inet_stosockaddr(strvec_slot(strvec, 1), NULL, saddr)) {\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"Configuration error: VRRP instance[%s] malformed\"\n\t\t\t\t     \" src address[%s]. Skipping...\"\n\t\t\t\t   , vrrp->iname, FMT_STR_VSLOT(strvec, 1));\n\t\treturn;\n\t}\n\n\tvrrp->saddr_from_config = true;\n\n\tif (vrrp->family == AF_UNSPEC)\n\t\tvrrp->family = saddr->ss_family;\n\telse if (saddr->ss_family != vrrp->family) {\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"Configuration error: VRRP instance[%s] and src address\"\n\t\t\t\t     \"[%s] MUST be of the same family !!! Skipping...\"\n\t\t\t\t   , vrrp->iname, FMT_STR_VSLOT(strvec, 1));\n\t\tsaddr->ss_family = AF_UNSPEC;\n\t\tvrrp->saddr_from_config = false;\n\t}\n}\nstatic void\nvrrp_track_srcip_handler(__attribute__((unused)) vector_t *strvec)\n{\n\tvrrp_t *vrrp = LIST_TAIL_DATA(vrrp_data->vrrp);\n\n\tvrrp->track_saddr = true;\n}\nstatic void\nvrrp_vrid_handler(vector_t *strvec)\n{\n\tvrrp_t *vrrp = LIST_TAIL_DATA(vrrp_data->vrrp);\n\tunsigned vrid;\n\n\tif (!read_unsigned_strvec(strvec, 1, &vrid, 1, 255, false)) {\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"(%s): VRID '%s' not valid - must be between 1 & 255\", vrrp->iname, FMT_STR_VSLOT(strvec, 1));\n\t\treturn;\n\t}\n\n\tvrrp->vrid = (uint8_t)vrid;\n}\nstatic void\nvrrp_prio_handler(vector_t *strvec)\n{\n\tvrrp_t *vrrp = LIST_TAIL_DATA(vrrp_data->vrrp);\n\tunsigned base_priority;\n\n\tif (!read_unsigned_strvec(strvec, 1, &base_priority, 1, VRRP_PRIO_OWNER, false)) {\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"(%s) Priority not valid! must be between 1 & %d. Using default %d\", vrrp->iname, VRRP_PRIO_OWNER, VRRP_PRIO_DFL);\n\t\tvrrp->base_priority = VRRP_PRIO_DFL;\n\t}\n\telse\n\t\tvrrp->base_priority = (uint8_t)base_priority;\n}\nstatic void\nvrrp_adv_handler(vector_t *strvec)\n{\n\tvrrp_t *vrrp = LIST_TAIL_DATA(vrrp_data->vrrp);\n\tdouble adver_int;\n\tbool res;\n\n\tres = read_double_strvec(strvec, 1, &adver_int, 0.01, 255.0, true);\n\n\t/* Simple check - just positive */\n\tif (!res || adver_int <= 0)\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"(%s) Advert interval (%s) not valid! Must be > 0 - ignoring\", vrrp->iname, FMT_STR_VSLOT(strvec, 1));\n\telse\n\t\tvrrp->adver_int = (unsigned)(adver_int * TIMER_HZ);\n}\nstatic void\nvrrp_debug_handler(vector_t *strvec)\n{\n\tvrrp_t *vrrp = LIST_TAIL_DATA(vrrp_data->vrrp);\n\tunsigned debug;\n\n\tif (!read_unsigned_strvec(strvec, 1, &debug, 0, 4, true))\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"(%s) Debug value '%s' not valid; must be between 0-4\", vrrp->iname, FMT_STR_VSLOT(strvec, 1));\n\telse\n\t\tvrrp->debug = debug;\n}\nstatic void\nvrrp_skip_check_adv_addr_handler(vector_t *strvec)\n{\n\tvrrp_t *vrrp = LIST_TAIL_DATA(vrrp_data->vrrp);\n\tint res;\n\n\tif (vector_size(strvec) >= 2) {\n\t\tres = check_true_false(strvec_slot(strvec, 1));\n\t\tif (res >= 0)\n\t\t\tvrrp->skip_check_adv_addr = (bool)res;\n\t\telse\n\t\t\treport_config_error(CONFIG_GENERAL_ERROR, \"(%s) invalid skip_check_adv_addr %s specified\", vrrp->iname, FMT_STR_VSLOT(strvec, 1));\n\t} else {\n\t\t/* Defaults to true */\n\t\tvrrp->skip_check_adv_addr = true;\n\t}\n}\nstatic void\nvrrp_strict_mode_handler(vector_t *strvec)\n{\n\tint res;\n\n\tvrrp_t *vrrp = LIST_TAIL_DATA(vrrp_data->vrrp);\n\tif (vector_size(strvec) >= 2) {\n\t\tres = check_true_false(strvec_slot(strvec, 1));\n\t\tif (res >= 0)\n\t\t\tvrrp->strict_mode = (bool)res;\n\t\telse\n\t\t\treport_config_error(CONFIG_GENERAL_ERROR, \"(%s) invalid strict_mode %s specified\", vrrp->iname, FMT_STR_VSLOT(strvec, 1));\n\t} else {\n\t\t/* Defaults to true */\n\t\tvrrp->strict_mode = true;\n\t}\n}\nstatic void\nvrrp_nopreempt_handler(__attribute__((unused)) vector_t *strvec)\n{\n\tvrrp_t *vrrp = LIST_TAIL_DATA(vrrp_data->vrrp);\n\tvrrp->nopreempt = 1;\n}\nstatic void\t/* backwards compatibility */\nvrrp_preempt_handler(__attribute__((unused)) vector_t *strvec)\n{\n\tvrrp_t *vrrp = LIST_TAIL_DATA(vrrp_data->vrrp);\n\tvrrp->nopreempt = 0;\n}\nstatic void\nvrrp_preempt_delay_handler(vector_t *strvec)\n{\n\tvrrp_t *vrrp = LIST_TAIL_DATA(vrrp_data->vrrp);\n\tdouble preempt_delay;\n\n\tif (!read_double_strvec(strvec, 1, &preempt_delay, 0, TIMER_MAX_SEC, true)) {\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"(%s) Preempt_delay not valid! must be between 0-%d\", vrrp->iname, TIMER_MAX_SEC);\n\t\tvrrp->preempt_delay = 0;\n\t}\n\telse\n\t\tvrrp->preempt_delay = (unsigned long)(preempt_delay * TIMER_HZ);\n}\nstatic void\nvrrp_notify_backup_handler(vector_t *strvec)\n{\n\tvrrp_t *vrrp = LIST_TAIL_DATA(vrrp_data->vrrp);\n\tif (vrrp->script_backup) {\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"(%s) notify_backup script already specified - ignoring %s\", vrrp->iname, FMT_STR_VSLOT(strvec,1));\n\t\treturn;\n\t}\n\tvrrp->script_backup = set_vrrp_notify_script(strvec, 0);\n\tvrrp->notify_exec = true;\n}\nstatic void\nvrrp_notify_master_handler(vector_t *strvec)\n{\n\tvrrp_t *vrrp = LIST_TAIL_DATA(vrrp_data->vrrp);\n\tif (vrrp->script_master) {\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"(%s) notify_master script already specified - ignoring %s\", vrrp->iname, FMT_STR_VSLOT(strvec,1));\n\t\treturn;\n\t}\n\tvrrp->script_master = set_vrrp_notify_script(strvec, 0);\n\tvrrp->notify_exec = true;\n}\nstatic void\nvrrp_notify_fault_handler(vector_t *strvec)\n{\n\tvrrp_t *vrrp = LIST_TAIL_DATA(vrrp_data->vrrp);\n\tif (vrrp->script_fault) {\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"(%s) notify_fault script already specified - ignoring %s\", vrrp->iname, FMT_STR_VSLOT(strvec,1));\n\t\treturn;\n\t}\n\tvrrp->script_fault = set_vrrp_notify_script(strvec, 0);\n\tvrrp->notify_exec = true;\n}\nstatic void\nvrrp_notify_stop_handler(vector_t *strvec)\n{\n\tvrrp_t *vrrp = LIST_TAIL_DATA(vrrp_data->vrrp);\n\tif (vrrp->script_stop) {\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"(%s) notify_stop script already specified - ignoring %s\", vrrp->iname, FMT_STR_VSLOT(strvec,1));\n\t\treturn;\n\t}\n\tvrrp->script_stop = set_vrrp_notify_script(strvec, 0);\n\tvrrp->notify_exec = true;\n}\nstatic void\nvrrp_notify_handler(vector_t *strvec)\n{\n\tvrrp_t *vrrp = LIST_TAIL_DATA(vrrp_data->vrrp);\n\tif (vrrp->script) {\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"(%s) notify script already specified - ignoring %s\", vrrp->iname, FMT_STR_VSLOT(strvec,1));\n\t\treturn;\n\t}\n\tvrrp->script = set_vrrp_notify_script(strvec, 4);\n\tvrrp->notify_exec = true;\n}\nstatic void\nvrrp_notify_master_rx_lower_pri(vector_t *strvec)\n{\n\tvrrp_t *vrrp = LIST_TAIL_DATA(vrrp_data->vrrp);\n\tif (vrrp->script_master_rx_lower_pri) {\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"(%s) notify_master_rx_lower_pri script already specified - ignoring %s\", vrrp->iname, FMT_STR_VSLOT(strvec,1));\n\t\treturn;\n\t}\n\tvrrp->script_master_rx_lower_pri = set_vrrp_notify_script(strvec, 0);\n\tvrrp->notify_exec = true;\n}\nstatic void\nvrrp_smtp_handler(__attribute__((unused)) vector_t *strvec)\n{\n\tvrrp_t *vrrp = LIST_TAIL_DATA(vrrp_data->vrrp);\n\tint res = true;\n\n\tif (vector_size(strvec) >= 2) {\n\t\tres = check_true_false(strvec_slot(strvec, 1));\n\t\tif (res == -1) {\n\t\t\treport_config_error(CONFIG_GENERAL_ERROR, \"Invalid vrrp_instance smtp_alert parameter %s\", FMT_STR_VSLOT(strvec, 1));\n\t\t\treturn;\n\t\t}\n\t}\n\tvrrp->smtp_alert = res;\n}\n#ifdef _WITH_LVS_\nstatic void\nvrrp_lvs_syncd_handler(vector_t *strvec)\n{\n\tvrrp_t *vrrp = LIST_TAIL_DATA(vrrp_data->vrrp);\n\n\treport_config_error(CONFIG_GENERAL_ERROR, \"(%s) Specifying lvs_sync_daemon_interface against a vrrp is deprecated.\", vrrp->iname);  /* Deprecated after v1.2.19 */\n\treport_config_error(CONFIG_GENERAL_ERROR, \"      %*sPlease use global lvs_sync_daemon\", (int)strlen(vrrp->iname) - 2, \"\");\n\n\tif (global_data->lvs_syncd.ifname) {\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"(%s) lvs_sync_daemon_interface has already been specified as %s - ignoring\", vrrp->iname, global_data->lvs_syncd.ifname);\n\t\treturn;\n\t}\n\n\tglobal_data->lvs_syncd.ifname = set_value(strvec);\n\tglobal_data->lvs_syncd.vrrp = vrrp;\n}\n#endif\nstatic void\nvrrp_garp_delay_handler(vector_t *strvec)\n{\n\tvrrp_t *vrrp = LIST_TAIL_DATA(vrrp_data->vrrp);\n\tunsigned delay;\n\n\tif (!read_unsigned_strvec(strvec, 1, &delay, 0, UINT_MAX / TIMER_HZ, true)) {\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"(%s): garp_master_delay '%s' invalid - ignoring\", vrrp->iname, FMT_STR_VSLOT(strvec, 1));\n\t\treturn;\n\t}\n\n\tvrrp->garp_delay = delay * TIMER_HZ;\n}\nstatic void\nvrrp_garp_refresh_handler(vector_t *strvec)\n{\n\tvrrp_t *vrrp = LIST_TAIL_DATA(vrrp_data->vrrp);\n\tunsigned refresh;\n\n\tif (!read_unsigned_strvec(strvec, 1, &refresh, 0, UINT_MAX, true)) {\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"(%s): Invalid garp_master_refresh '%s' - ignoring\", vrrp->iname, FMT_STR_VSLOT(strvec, 1));\n\t\tvrrp->garp_refresh.tv_sec = 0;\n\t}\n\telse\n\t\tvrrp->garp_refresh.tv_sec = refresh;\n\tvrrp->garp_refresh.tv_usec = 0;\n}\nstatic void\nvrrp_garp_rep_handler(vector_t *strvec)\n{\n\tvrrp_t *vrrp = LIST_TAIL_DATA(vrrp_data->vrrp);\n\tunsigned repeats;\n\n\t/* The min value should be 1, but allow 0 to maintain backward compatibility\n\t * with pre v2.0.7 */\n\tif (!read_unsigned_strvec(strvec, 1, &repeats, 0, UINT_MAX, true)) {\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"(%s): garp_master_repeat '%s' invalid - ignoring\", vrrp->iname, FMT_STR_VSLOT(strvec, 1));\n\t\treturn;\n\t}\n\n\tif (repeats == 0) {\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"(%s): garp_master_repeat must be greater than 0, setting to 1\", vrrp->iname);\n\t\trepeats = 1;\n\t}\n\n\tvrrp->garp_rep = repeats;\n}\nstatic void\nvrrp_garp_refresh_rep_handler(vector_t *strvec)\n{\n\tvrrp_t *vrrp = LIST_TAIL_DATA(vrrp_data->vrrp);\n\tunsigned repeats;\n\n\t/* The min value should be 1, but allow 0 to maintain backward compatibility\n\t * with pre v2.0.7 */\n\tif (!read_unsigned_strvec(strvec, 1, &repeats, 0, UINT_MAX, true)) {\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"(%s): garp_master_refresh_repeat '%s' invalid - ignoring\", vrrp->iname, FMT_STR_VSLOT(strvec, 1));\n\t\treturn;\n\t}\n\n\tif (repeats == 0) {\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"(%s): garp_master_refresh_repeat must be greater than 0, setting to 1\", vrrp->iname);\n\t\trepeats = 1;\n\t}\n\n\tvrrp->garp_refresh_rep = repeats;\n}\n\nstatic void\nvrrp_garp_lower_prio_delay_handler(vector_t *strvec)\n{\n\tvrrp_t *vrrp = LIST_TAIL_DATA(vrrp_data->vrrp);\n\tunsigned delay;\n\n\tif (!read_unsigned_strvec(strvec, 1, &delay, 0, UINT_MAX / TIMER_HZ, true)) {\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"(%s): garp_lower_prio_delay '%s' invalid - ignoring\", vrrp->iname, FMT_STR_VSLOT(strvec, 1));\n\t\treturn;\n\t}\n\n\tvrrp->garp_lower_prio_delay = delay * TIMER_HZ;\n}\nstatic void\nvrrp_garp_lower_prio_rep_handler(vector_t *strvec)\n{\n\tvrrp_t *vrrp = LIST_TAIL_DATA(vrrp_data->vrrp);\n\tunsigned garp_lower_prio_rep;\n\n\tif (!read_unsigned_strvec(strvec, 1, &garp_lower_prio_rep, 0, INT_MAX, true)) {\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"(%s): Invalid garp_lower_prio_repeat '%s'\", vrrp->iname, FMT_STR_VSLOT(strvec, 1));\n\t\treturn;\n\t}\n\n\tvrrp->garp_lower_prio_rep = garp_lower_prio_rep;\n}\nstatic void\nvrrp_lower_prio_no_advert_handler(vector_t *strvec)\n{\n\tvrrp_t *vrrp = LIST_TAIL_DATA(vrrp_data->vrrp);\n\tint res;\n\n\tif (vector_size(strvec) >= 2) {\n\t\tres = check_true_false(strvec_slot(strvec, 1));\n\t\tif (res >= 0)\n\t\t\tvrrp->lower_prio_no_advert = (unsigned)res;\n\t\telse\n\t\t\treport_config_error(CONFIG_GENERAL_ERROR, \"(%s) invalid lower_prio_no_advert %s specified\", vrrp->iname, FMT_STR_VSLOT(strvec, 1));\n\t} else {\n\t\t/* Defaults to true */\n\t\tvrrp->lower_prio_no_advert = true;\n\t}\n}\n\nstatic void\nvrrp_higher_prio_send_advert_handler(vector_t *strvec)\n{\n\tint res;\n\tvrrp_t *vrrp = LIST_TAIL_DATA(vrrp_data->vrrp);\n\n\tif (vector_size(strvec) >= 2) {\n\t\tres = check_true_false(strvec_slot(strvec, 1));\n\t\tif (res >= 0)\n\t\t\tvrrp->higher_prio_send_advert = (unsigned)res;\n\t\telse\n\t\t\treport_config_error(CONFIG_GENERAL_ERROR, \"(%s) invalid higher_prio_send_advert %s specified\", vrrp->iname, FMT_STR_VSLOT(strvec, 1));\n\t} else {\n\t\t/* Defaults to true */\n\t\tvrrp->higher_prio_send_advert = true;\n\t}\n}\n\n\nstatic void\nkernel_rx_buf_size_handler(vector_t *strvec)\n{\n\tvrrp_t *vrrp = LIST_TAIL_DATA(vrrp_data->vrrp);\n\tunsigned rx_buf_size;\n\n\tif (vector_size(strvec) == 2 &&\n\t    read_unsigned_strvec(strvec, 1, &rx_buf_size, 0, UINT_MAX, false)) {\n\t\tvrrp->kernel_rx_buf_size = rx_buf_size;\n\t\treturn;\n\t}\n\n\treport_config_error(CONFIG_GENERAL_ERROR, \"(%s) invalid kernel_rx_buf_size specified\", vrrp->iname);\n}\n\n#if defined _WITH_VRRP_AUTH_\nstatic void\nvrrp_auth_type_handler(vector_t *strvec)\n{\n\tvrrp_t *vrrp = LIST_TAIL_DATA(vrrp_data->vrrp);\n\tchar *str = strvec_slot(strvec, 1);\n\n\tif (!strcmp(str, \"AH\"))\n\t\tvrrp->auth_type = VRRP_AUTH_AH;\n\telse if (!strcmp(str, \"PASS\"))\n\t\tvrrp->auth_type = VRRP_AUTH_PASS;\n\telse\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"(%s) unknown authentication type '%s'\", vrrp->iname, str);\n}\nstatic void\nvrrp_auth_pass_handler(vector_t *strvec)\n{\n\tvrrp_t *vrrp = LIST_TAIL_DATA(vrrp_data->vrrp);\n\tchar *str = strvec_slot(strvec, 1);\n\tsize_t max_size = sizeof (vrrp->auth_data);\n\tsize_t str_len = strlen(str);\n\n\tif (str_len > max_size) {\n\t\tstr_len = max_size;\n\t\treport_config_error(CONFIG_GENERAL_ERROR,\n\t\t\t    \"Truncating auth_pass to %zu characters\", max_size);\n\t}\n\n\tmemset(vrrp->auth_data, 0, max_size);\n\tmemcpy(vrrp->auth_data, str, str_len);\n}\n#endif\nstatic void\nvrrp_vip_handler(vector_t *strvec)\n{\n\talloc_value_block(alloc_vrrp_vip, vector_slot(strvec, 0));\n}\nstatic void\nvrrp_evip_handler(vector_t *strvec)\n{\n\talloc_value_block(alloc_vrrp_evip, vector_slot(strvec, 0));\n}\nstatic void\nvrrp_promote_secondaries_handler(__attribute__((unused)) vector_t *strvec)\n{\n\tvrrp_t *vrrp = LIST_TAIL_DATA(vrrp_data->vrrp);\n\n\tvrrp->promote_secondaries = true;\n}\n#ifdef _HAVE_FIB_ROUTING_\nstatic void\nvrrp_vroutes_handler(vector_t *strvec)\n{\n\talloc_value_block(alloc_vrrp_vroute, vector_slot(strvec, 0));\n}\nstatic void\nvrrp_vrules_handler(vector_t *strvec)\n{\n\talloc_value_block(alloc_vrrp_vrule, vector_slot(strvec, 0));\n}\n#endif\nstatic void\nvrrp_script_handler(vector_t *strvec)\n{\n\tif (!strvec)\n\t\treturn;\n\n\talloc_vrrp_script(strvec_slot(strvec, 1));\n\tscript_user_set = false;\n\tremove_script = false;\n}\nstatic void\nvrrp_vscript_script_handler(__attribute__((unused)) vector_t *strvec)\n{\n\tvrrp_script_t *vscript = LIST_TAIL_DATA(vrrp_data->vrrp_script);\n\tvector_t *strvec_qe;\n\n\t/* We need to allow quoted and escaped strings for the script and parameters */\n\tstrvec_qe = alloc_strvec_quoted_escaped(NULL);\n\n\tset_script_params_array(strvec_qe, &vscript->script, 0);\n\tfree_strvec(strvec_qe);\n}\nstatic void\nvrrp_vscript_interval_handler(vector_t *strvec)\n{\n\tvrrp_script_t *vscript = LIST_TAIL_DATA(vrrp_data->vrrp_script);\n\tunsigned interval;\n\n\t/* The min value should be 1, but allow 0 to maintain backward compatibility\n\t * with pre v2.0.7 */\n\tif (!read_unsigned_strvec(strvec, 1, &interval, 0, UINT_MAX / TIMER_HZ, true)) {\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"(%s): vrrp script interval '%s' must be between 1 and %u - ignoring\", vscript->sname, FMT_STR_VSLOT(strvec, 1), UINT_MAX / TIMER_HZ);\n\t\treturn;\n\t}\n\n\tif (interval == 0) {\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"(%s): vrrp script interval must be greater than 0, setting to 1\", vscript->sname);\n\t\tinterval = 1;\n\t}\n\n\tvscript->interval = interval * TIMER_HZ;\n}\nstatic void\nvrrp_vscript_timeout_handler(vector_t *strvec)\n{\n\tvrrp_script_t *vscript = LIST_TAIL_DATA(vrrp_data->vrrp_script);\n\tunsigned timeout;\n\n\t/* The min value should be 1, but allow 0 to maintain backward compatibility\n\t * with pre v2.0.7 */\n\tif (!read_unsigned_strvec(strvec, 1, &timeout, 0, UINT_MAX / TIMER_HZ, true)) {\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"(%s): vrrp script timeout '%s' invalid - ignoring\", vscript->sname, FMT_STR_VSLOT(strvec, 1));\n\t\treturn;\n\t}\n\n\tif (timeout == 0) {\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"(%s): vrrp script timeout must be greater than 0, setting to 1\", vscript->sname);\n\t\ttimeout = 1;\n\t}\n\n\tvscript->timeout = timeout * TIMER_HZ;\n}\nstatic void\nvrrp_vscript_weight_handler(vector_t *strvec)\n{\n\tvrrp_script_t *vscript = LIST_TAIL_DATA(vrrp_data->vrrp_script);\n\tint weight;\n\n\tif (!read_int_strvec(strvec, 1, &weight, -253, 253, true))\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"vrrp_script %s weight %s must be in [-253, 253]\", vscript->sname, FMT_STR_VSLOT(strvec, 1));\n\tvscript->weight = weight;\n}\nstatic void\nvrrp_vscript_rise_handler(vector_t *strvec)\n{\n\tvrrp_script_t *vscript = LIST_TAIL_DATA(vrrp_data->vrrp_script);\n\tunsigned rise;\n\n\tif (!read_unsigned_strvec(strvec, 1, &rise, 1, INT_MAX, true)) {\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"(%s): vrrp script rise value '%s' invalid, defaulting to 1\", vscript->sname, FMT_STR_VSLOT(strvec, 1));\n\t\tvscript->rise = 1;\n\t}\n\telse\n\t\tvscript->rise = rise;\n}\nstatic void\nvrrp_vscript_fall_handler(vector_t *strvec)\n{\n\tvrrp_script_t *vscript = LIST_TAIL_DATA(vrrp_data->vrrp_script);\n\tunsigned fall;\n\n\tif (!read_unsigned_strvec(strvec, 1, &fall, 1, INT_MAX, true)) {\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"(%s): vrrp script fall value '%s' invalid, defaulting to 1\", vscript->sname, FMT_STR_VSLOT(strvec, 1));\n\t\tvscript->fall = 1;\n\t}\n\telse\n\t\tvscript->fall = fall;\n}\nstatic void\nvrrp_vscript_user_handler(vector_t *strvec)\n{\n\tvrrp_script_t *vscript = LIST_TAIL_DATA(vrrp_data->vrrp_script);\n\n\tif (set_script_uid_gid(strvec, 1, &vscript->script.uid, &vscript->script.gid)) {\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"Unable to set uid/gid for script %s\", cmd_str(&vscript->script));\n\t\tremove_script = true;\n\t}\n\telse {\n\t\tremove_script = false;\n\t\tscript_user_set = true;\n\t}\n}\nstatic void\nvrrp_vscript_end_handler(void)\n{\n\tvrrp_script_t *vscript = LIST_TAIL_DATA(vrrp_data->vrrp_script);\n\n\tif (!vscript->script.args || !vscript->script.args[0]) {\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"No script set for vrrp_script %s - removing\", vscript->sname);\n\t\tremove_script = true;\n\t}\n\telse if (!remove_script) {\n\t\tif (script_user_set)\n\t\t\treturn;\n\n\t\tif (set_default_script_user(NULL, NULL)) {\n\t\t\treport_config_error(CONFIG_GENERAL_ERROR, \"Unable to set default user for vrrp script %s - removing\", vscript->sname);\n\t\t\tremove_script = true;\n\t\t}\n\t}\n\n\tif (remove_script) {\n\t\tfree_list_element(vrrp_data->vrrp_script, vrrp_data->vrrp_script->tail);\n\t\treturn;\n\t}\n\n\tvscript->script.uid = default_script_uid;\n\tvscript->script.gid = default_script_gid;\n}\nstatic void\nvrrp_tfile_handler(vector_t *strvec)\n{\n\tif (!strvec)\n\t\treturn;\n\n\talloc_vrrp_file(strvec_slot(strvec, 1));\n\n\ttrack_file_init = TRACK_FILE_NO_INIT;\n}\nstatic void\nvrrp_tfile_file_handler(vector_t *strvec)\n{\n\tvrrp_tracked_file_t *tfile = LIST_TAIL_DATA(vrrp_data->vrrp_track_files);\n\tif (tfile->file_path) {\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"File already set for track file %s - ignoring %s\", tfile->fname, FMT_STR_VSLOT(strvec, 1));\n\t\treturn;\n\t}\n\ttfile->file_path = set_value(strvec);\n}\nstatic void\nvrrp_tfile_weight_handler(vector_t *strvec)\n{\n\tint weight;\n\tvrrp_tracked_file_t *tfile = LIST_TAIL_DATA(vrrp_data->vrrp_track_files);\n\n\tif (vector_size(strvec) < 2) {\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"No weight specified for track file %s - ignoring\", tfile->fname);\n\t\treturn;\n\t}\n\tif (tfile->weight != 1) {\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"Weight already set for track file %s - ignoring %s\", tfile->fname, FMT_STR_VSLOT(strvec, 1));\n\t\treturn;\n\t}\n\n\tif (!read_int_strvec(strvec, 1, &weight, -254, 254, true)) {\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"Weight (%s) for vrrp_track_file %s must be between \"\n\t\t\t\t \"[-254..254] inclusive. Ignoring...\", FMT_STR_VSLOT(strvec, 1), tfile->fname);\n\t\tweight = 1;\n\t}\n\n\ttfile->weight = weight;\n}\nstatic void\nvrrp_tfile_init_handler(vector_t *strvec)\n{\n\tunsigned i;\n\tchar *word;\n\tvrrp_tracked_file_t *tfile = LIST_TAIL_DATA(vrrp_data->vrrp_track_files);\n\tint value;\n\n\ttrack_file_init = TRACK_FILE_CREATE;\n\ttrack_file_init_value = 0;\n\n\tfor (i = 1; i < vector_size(strvec); i++) {\n\t\tword = strvec_slot(strvec, i);\n\t\tword += strspn(word, WHITE_SPACE);\n\t\tif (isdigit(word[0]) || word[0] == '-') {\n\t\t\tif (!read_int_strvec(strvec, i, &value, INT_MIN, INT_MAX, false)) {\n\t\t\t\t/* It is not a valid integer */\n\t\t\t\treport_config_error(CONFIG_GENERAL_ERROR, \"Track file %s init value %s is invalid\", tfile->fname, word);\n\t\t\t\tvalue = 0;\n\t\t\t}\n\t\t\telse if (value < -254 || value > 254)\n\t\t\t\treport_config_error(CONFIG_GENERAL_ERROR, \"Track file %s init value %d is outside sensible range [%d, %d]\", tfile->fname, value, -254, 254);\n\t\t\ttrack_file_init_value = value;\n\t\t}\n\t\telse if (!strcmp(word, \"overwrite\"))\n\t\t\ttrack_file_init = TRACK_FILE_INIT;\n\t\telse\n\t\t\treport_config_error(CONFIG_GENERAL_ERROR, \"Unknown track file init option %s\", word);\n\t}\n}\nstatic void\nvrrp_tfile_end_handler(void)\n{\n\tvrrp_tracked_file_t *tfile = LIST_TAIL_DATA(vrrp_data->vrrp_track_files);\n\tstruct stat statb;\n\tFILE *tf;\n\tint ret;\n\n\tif (!tfile->file_path) {\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"No file set for track_file %s - removing\", tfile->fname);\n\t\tfree_list_element(vrrp_data->vrrp_track_files, vrrp_data->vrrp_track_files->tail);\n\t\treturn;\n\t}\n\n\tif (track_file_init == TRACK_FILE_NO_INIT)\n\t\treturn;\n\n\tret = stat(tfile->file_path, &statb);\n\tif (!ret) {\n\t\tif (track_file_init == TRACK_FILE_CREATE) {\n\t\t\t/* The file exists */\n\t\t\treturn;\n\t\t}\n\t\tif ((statb.st_mode & S_IFMT) != S_IFREG) {\n\t\t\t/* It is not a regular file */\n\t\t\treport_config_error(CONFIG_GENERAL_ERROR, \"Cannot initialise track file %s - it is not a regular file\", tfile->fname);\n\t\t\treturn;\n\t\t}\n\n\t\t/* Don't overwrite a file on reload */\n\t\tif (reload)\n\t\t\treturn;\n\t}\n\n\tif (!__test_bit(CONFIG_TEST_BIT, &debug)) {\n\t\t/* Write the value to the file */\n\t\tif ((tf = fopen(tfile->file_path, \"w\"))) {\n\t\t\tfprintf(tf, \"%d\\n\", track_file_init_value);\n\t\t\tfclose(tf);\n\t\t}\n\t\telse\n\t\t\treport_config_error(CONFIG_GENERAL_ERROR, \"Unable to initialise track file %s\", tfile->fname);\n\t}\n}\nstatic void\nvrrp_vscript_init_fail_handler(__attribute__((unused)) vector_t *strvec)\n{\n\tvrrp_script_t *vscript = LIST_TAIL_DATA(vrrp_data->vrrp_script);\n\tvscript->init_state = SCRIPT_INIT_STATE_FAILED;\n}\nstatic void\nvrrp_version_handler(vector_t *strvec)\n{\n\tvrrp_t *vrrp = LIST_TAIL_DATA(vrrp_data->vrrp);\n\tint version;\n\n\tif (!read_int_strvec(strvec, 1, &version, 2, 3, true)) {\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"(%s): Version must be either 2 or 3\", vrrp->iname);\n\t\treturn;\n\t}\n\n\tif ((vrrp->version && vrrp->version != version) ||\n\t    (version == VRRP_VERSION_2 && vrrp->family == AF_INET6)) {\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"(%s) vrrp_version %d conflicts with configured or deduced version %d; ignoring.\", vrrp->iname, version, vrrp->version);\n\t\treturn;\n\t}\n\n\tvrrp->version = version;\n}\n\nstatic void\nvrrp_accept_handler(__attribute__((unused)) vector_t *strvec)\n{\n\tvrrp_t *vrrp = LIST_TAIL_DATA(vrrp_data->vrrp);\n\n\tvrrp->accept = true;\n}\n\nstatic void\nvrrp_no_accept_handler(__attribute__((unused)) vector_t *strvec)\n{\n\tvrrp_t *vrrp = LIST_TAIL_DATA(vrrp_data->vrrp);\n\n\tvrrp->accept = false;\n}\n\nstatic void\ngarp_group_handler(vector_t *strvec)\n{\n\tif (!strvec)\n\t\treturn;\n\n\talloc_garp_delay();\n}\nstatic void\ngarp_group_garp_interval_handler(vector_t *strvec)\n{\n\tgarp_delay_t *delay = LIST_TAIL_DATA(garp_delay);\n\tdouble val;\n\n\tif (!read_double_strvec(strvec, 1, &val, 0, INT_MAX / 1000000, true)) {\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"garp_group garp_interval '%s' invalid\", FMT_STR_VSLOT(strvec, 1));\n\t\treturn;\n\t}\n\n\tdelay->garp_interval.tv_sec = (time_t)val;\n\tdelay->garp_interval.tv_usec = (suseconds_t)((val - delay->garp_interval.tv_sec) * 1000000);\n\tdelay->have_garp_interval = true;\n\n\tif (delay->garp_interval.tv_sec >= 1)\n\t\tlog_message(LOG_INFO, \"The garp_interval is very large - %s seconds\", FMT_STR_VSLOT(strvec,1));\n}\nstatic void\ngarp_group_gna_interval_handler(vector_t *strvec)\n{\n\tgarp_delay_t *delay = LIST_TAIL_DATA(garp_delay);\n\tdouble val;\n\n\tif (!read_double_strvec(strvec, 1, &val, 0, INT_MAX / 1000000, true)) {\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"garp_group gna_interval '%s' invalid\", FMT_STR_VSLOT(strvec, 1));\n\t\treturn;\n\t}\n\n\tdelay->gna_interval.tv_sec = (time_t)val;\n\tdelay->gna_interval.tv_usec = (suseconds_t)((val - delay->gna_interval.tv_sec) * 1000000);\n\tdelay->have_gna_interval = true;\n\n\tif (delay->gna_interval.tv_sec >= 1)\n\t\tlog_message(LOG_INFO, \"The gna_interval is very large - %s seconds\", FMT_STR_VSLOT(strvec,1));\n}\nstatic void\ngarp_group_interface_handler(vector_t *strvec)\n{\n\tinterface_t *ifp = if_get_by_ifname(strvec_slot(strvec, 1), IF_CREATE_IF_DYNAMIC);\n\tif (!ifp) {\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"WARNING - interface %s specified for garp_group doesn't exist\", FMT_STR_VSLOT(strvec, 1));\n\t\treturn;\n\t}\n\n\tif (ifp->garp_delay) {\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"garp_group already specified for %s - ignoring\", FMT_STR_VSLOT(strvec, 1));\n\t\treturn;\n\t}\n\n#ifdef _HAVE_VRRP_VMAC_\n\t/* We cannot have a group on a vmac interface */\n\tif (ifp->vmac_type) {\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"Cannot specify garp_delay on a vmac (%s) - ignoring\", ifp->ifname);\n\t\treturn;\n\t}\n#endif\n\tifp->garp_delay = LIST_TAIL_DATA(garp_delay);\n}\nstatic void\ngarp_group_interfaces_handler(vector_t *strvec)\n{\n\tgarp_delay_t *delay = LIST_TAIL_DATA(garp_delay);\n\tinterface_t *ifp;\n\tvector_t *interface_vec = read_value_block(strvec);\n\tsize_t i;\n\tgarp_delay_t *gd;\n\telement e;\n\n\t/* Handle the interfaces block being empty */\n\tif (!interface_vec) {\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"Warning - empty garp_group interfaces block\");\n\t\treturn;\n\t}\n\n\t/* First set the next aggregation group number */\n\tdelay->aggregation_group = 1;\n\tfor (e = LIST_HEAD(garp_delay); e; ELEMENT_NEXT(e)) {\n\t\tgd = ELEMENT_DATA(e);\n\t\tif (gd->aggregation_group && gd != delay)\n\t\t\tdelay->aggregation_group++;\n\t}\n\n\tfor (i = 0; i < vector_size(interface_vec); i++) {\n\t\tifp = if_get_by_ifname(vector_slot(interface_vec, i), IF_CREATE_IF_DYNAMIC);\n\t\tif (!ifp) {\n\t\t\tif (global_data->dynamic_interfaces)\n\t\t\t\tlog_message(LOG_INFO, \"WARNING - interface %s specified for garp_group doesn't exist\", FMT_STR_VSLOT(strvec, i));\n\t\t\telse\n\t\t\t\treport_config_error(CONFIG_GENERAL_ERROR, \"WARNING - interface %s specified for garp_group doesn't exist\", FMT_STR_VSLOT(strvec, i));\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (ifp->garp_delay) {\n\t\t\treport_config_error(CONFIG_GENERAL_ERROR, \"garp_group already specified for %s - ignoring\", FMT_STR_VSLOT(strvec, 1));\n\t\t\tcontinue;\n\t\t}\n\n#ifdef _HAVE_VRRP_VMAC_\n\t\tif (ifp->vmac_type) {\n\t\t\treport_config_error(CONFIG_GENERAL_ERROR, \"Cannot specify garp_delay on a vmac (%s) - ignoring\", ifp->ifname);\n\t\t\tcontinue;\n\t\t}\n#endif\n\t\tifp->garp_delay = delay;\n\t}\n\n\tfree_strvec(interface_vec);\n}\nstatic void\ngarp_group_end_handler(void)\n{\n\tgarp_delay_t *delay = LIST_TAIL_DATA(garp_delay);\n\telement e, next;\n\tinterface_t *ifp;\n\n\tif (!delay->have_garp_interval && !delay->have_gna_interval) {\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"garp group %d does not have any delay set - removing\", delay->aggregation_group);\n\n\t\t/* Remove the garp_delay from any interfaces that are using it */\n\t\tLIST_FOREACH_NEXT(get_if_list(), ifp, e, next) {\n\t\t\tif (ifp->garp_delay == delay)\n\t\t\t\tifp->garp_delay = NULL;\n\t\t}\n\n\t\tfree_list_element(garp_delay, garp_delay->tail);\n\t}\n}\n\nvoid\ninit_vrrp_keywords(bool active)\n{\n\t/* Static addresses/routes/rules */\n\tinstall_keyword_root(\"track_group\", &static_track_group_handler, active);\n\tinstall_keyword(\"group\", &static_track_group_group_handler);\n\tinstall_keyword_root(\"static_ipaddress\", &static_addresses_handler, active);\n#ifdef _HAVE_FIB_ROUTING_\n\tinstall_keyword_root(\"static_routes\", &static_routes_handler, active);\n\tinstall_keyword_root(\"static_rules\", &static_rules_handler, active);\n#endif\n\n\t/* Sync group declarations */\n\tinstall_keyword_root(\"vrrp_sync_group\", &vrrp_sync_group_handler, active);\n\tinstall_keyword(\"group\", &vrrp_group_handler);\n\tinstall_keyword(\"track_interface\", &vrrp_group_track_if_handler);\n\tinstall_keyword(\"track_script\", &vrrp_group_track_scr_handler);\n\tinstall_keyword(\"track_file\", &vrrp_group_track_file_handler);\n#ifdef _WITH_BFD_\n\tinstall_keyword(\"track_bfd\", &vrrp_group_track_bfd_handler);\n#endif\n\tinstall_keyword(\"notify_backup\", &vrrp_gnotify_backup_handler);\n\tinstall_keyword(\"notify_master\", &vrrp_gnotify_master_handler);\n\tinstall_keyword(\"notify_fault\", &vrrp_gnotify_fault_handler);\n\tinstall_keyword(\"notify_stop\", &vrrp_gnotify_stop_handler);\n\tinstall_keyword(\"notify\", &vrrp_gnotify_handler);\n\tinstall_keyword(\"smtp_alert\", &vrrp_gsmtp_handler);\n\tinstall_keyword(\"global_tracking\", &vrrp_gglobal_tracking_handler);\n\tinstall_keyword(\"sync_group_tracking_weight\", &vrrp_sg_tracking_weight_handler);\n\n\tinstall_keyword_root(\"garp_group\", &garp_group_handler, active);\n\tinstall_keyword(\"garp_interval\", &garp_group_garp_interval_handler);\n\tinstall_keyword(\"gna_interval\", &garp_group_gna_interval_handler);\n\tinstall_keyword(\"interface\", &garp_group_interface_handler);\n\tinstall_keyword(\"interfaces\", &garp_group_interfaces_handler);\n\tinstall_sublevel_end_handler(&garp_group_end_handler);\n\n\t/* VRRP Instance mapping */\n\tinstall_keyword_root(\"vrrp_instance\", &vrrp_handler, active);\n#ifdef _HAVE_VRRP_VMAC_\n\tinstall_keyword(\"use_vmac\", &vrrp_vmac_handler);\n\tinstall_keyword(\"vmac_xmit_base\", &vrrp_vmac_xmit_base_handler);\n#endif\n\tinstall_keyword(\"unicast_peer\", &vrrp_unicast_peer_handler);\n#ifdef _WITH_UNICAST_CHKSUM_COMPAT_\n\tinstall_keyword(\"old_unicast_checksum\", &vrrp_unicast_chksum_handler);\n#endif\n\tinstall_keyword(\"native_ipv6\", &vrrp_native_ipv6_handler);\n\tinstall_keyword(\"state\", &vrrp_state_handler);\n\tinstall_keyword(\"interface\", &vrrp_int_handler);\n\tinstall_keyword(\"dont_track_primary\", &vrrp_dont_track_handler);\n\tinstall_keyword(\"track_interface\", &vrrp_track_if_handler);\n\tinstall_keyword(\"track_script\", &vrrp_track_scr_handler);\n\tinstall_keyword(\"track_file\", &vrrp_track_file_handler);\n#ifdef _WITH_BFD_\n\tinstall_keyword(\"track_bfd\", &vrrp_track_bfd_handler);\n#endif\n\tinstall_keyword(\"mcast_src_ip\", &vrrp_srcip_handler);\n\tinstall_keyword(\"unicast_src_ip\", &vrrp_srcip_handler);\n\tinstall_keyword(\"track_src_ip\", &vrrp_track_srcip_handler);\n\tinstall_keyword(\"virtual_router_id\", &vrrp_vrid_handler);\n\tinstall_keyword(\"version\", &vrrp_version_handler);\n\tinstall_keyword(\"priority\", &vrrp_prio_handler);\n\tinstall_keyword(\"advert_int\", &vrrp_adv_handler);\n\tinstall_keyword(\"virtual_ipaddress\", &vrrp_vip_handler);\n\tinstall_keyword(\"virtual_ipaddress_excluded\", &vrrp_evip_handler);\n\tinstall_keyword(\"promote_secondaries\", &vrrp_promote_secondaries_handler);\n\tinstall_keyword(\"linkbeat_use_polling\", &vrrp_linkbeat_handler);\n#ifdef _HAVE_FIB_ROUTING_\n\tinstall_keyword(\"virtual_routes\", &vrrp_vroutes_handler);\n\tinstall_keyword(\"virtual_rules\", &vrrp_vrules_handler);\n#endif\n\tinstall_keyword(\"accept\", &vrrp_accept_handler);\n\tinstall_keyword(\"no_accept\", &vrrp_no_accept_handler);\n\tinstall_keyword(\"skip_check_adv_addr\", &vrrp_skip_check_adv_addr_handler);\n\tinstall_keyword(\"strict_mode\", &vrrp_strict_mode_handler);\n\tinstall_keyword(\"preempt\", &vrrp_preempt_handler);\n\tinstall_keyword(\"nopreempt\", &vrrp_nopreempt_handler);\n\tinstall_keyword(\"preempt_delay\", &vrrp_preempt_delay_handler);\n\tinstall_keyword(\"debug\", &vrrp_debug_handler);\n\tinstall_keyword(\"notify_backup\", &vrrp_notify_backup_handler);\n\tinstall_keyword(\"notify_master\", &vrrp_notify_master_handler);\n\tinstall_keyword(\"notify_fault\", &vrrp_notify_fault_handler);\n\tinstall_keyword(\"notify_stop\", &vrrp_notify_stop_handler);\n\tinstall_keyword(\"notify\", &vrrp_notify_handler);\n\tinstall_keyword(\"notify_master_rx_lower_pri\", vrrp_notify_master_rx_lower_pri);\n\tinstall_keyword(\"smtp_alert\", &vrrp_smtp_handler);\n#ifdef _WITH_LVS_\n\tinstall_keyword(\"lvs_sync_daemon_interface\", &vrrp_lvs_syncd_handler);\n#endif\n\tinstall_keyword(\"garp_master_delay\", &vrrp_garp_delay_handler);\n\tinstall_keyword(\"garp_master_refresh\", &vrrp_garp_refresh_handler);\n\tinstall_keyword(\"garp_master_repeat\", &vrrp_garp_rep_handler);\n\tinstall_keyword(\"garp_master_refresh_repeat\", &vrrp_garp_refresh_rep_handler);\n\tinstall_keyword(\"garp_lower_prio_delay\", &vrrp_garp_lower_prio_delay_handler);\n\tinstall_keyword(\"garp_lower_prio_repeat\", &vrrp_garp_lower_prio_rep_handler);\n\tinstall_keyword(\"lower_prio_no_advert\", &vrrp_lower_prio_no_advert_handler);\n\tinstall_keyword(\"higher_prio_send_advert\", &vrrp_higher_prio_send_advert_handler);\n\tinstall_keyword(\"kernel_rx_buf_size\", &kernel_rx_buf_size_handler);\n#if defined _WITH_VRRP_AUTH_\n\tinstall_keyword(\"authentication\", NULL);\n\tinstall_sublevel();\n\tinstall_keyword(\"auth_type\", &vrrp_auth_type_handler);\n\tinstall_keyword(\"auth_pass\", &vrrp_auth_pass_handler);\n\tinstall_sublevel_end();\n#endif\n\tinstall_keyword_root(\"vrrp_script\", &vrrp_script_handler, active);\n\tinstall_keyword(\"script\", &vrrp_vscript_script_handler);\n\tinstall_keyword(\"interval\", &vrrp_vscript_interval_handler);\n\tinstall_keyword(\"timeout\", &vrrp_vscript_timeout_handler);\n\tinstall_keyword(\"weight\", &vrrp_vscript_weight_handler);\n\tinstall_keyword(\"rise\", &vrrp_vscript_rise_handler);\n\tinstall_keyword(\"fall\", &vrrp_vscript_fall_handler);\n\tinstall_keyword(\"user\", &vrrp_vscript_user_handler);\n\tinstall_keyword(\"init_fail\", &vrrp_vscript_init_fail_handler);\n\tinstall_sublevel_end_handler(&vrrp_vscript_end_handler);\n\n\t/* Track file declarations */\n\tinstall_keyword_root(\"vrrp_track_file\", &vrrp_tfile_handler, active);\n\tinstall_keyword(\"file\", &vrrp_tfile_file_handler);\n\tinstall_keyword(\"weight\", &vrrp_tfile_weight_handler);\n\tinstall_keyword(\"init_file\", &vrrp_tfile_init_handler);\n\tinstall_sublevel_end_handler(&vrrp_tfile_end_handler);\n}\n\nvector_t *\nvrrp_init_keywords(void)\n{\n\t/* global definitions mapping */\n\tinit_global_keywords(reload);\n\n\tinit_vrrp_keywords(true);\n#ifdef _WITH_LVS_\n\tinit_check_keywords(false);\n#endif\n#ifdef _WITH_BFD_\n\tinit_bfd_keywords(true);\n#endif\n\n\treturn keywords;\n}\n", "/*\n * Soft:        Vrrpd is an implementation of VRRPv2 as specified in rfc2338.\n *              VRRP is a protocol which elect a master server on a LAN. If the\n *              master fails, a backup server takes over.\n *              The original implementation has been made by jerome etienne.\n *\n * Part:        Print running VRRP state information\n *\n * Author:      John Southworth, <john.southworth@vyatta.com>\n *\n *              This program is distributed in the hope that it will be useful,\n *              but WITHOUT ANY WARRANTY; without even the implied warranty of\n *              MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n *              See the GNU General Public License for more details.\n *\n *              This program is free software; you can redistribute it and/or\n *              modify it under the terms of the GNU General Public License\n *              as published by the Free Software Foundation; either version\n *              2 of the License, or (at your option) any later version.\n *\n * Copyright (C) 2012 John Southworth, <john.southworth@vyatta.com>\n * Copyright (C) 2015-2017 Alexandre Cassen, <acassen@gmail.com>\n */\n\n#include \"config.h\"\n\n#include <errno.h>\n#include <inttypes.h>\n\n#include \"logger.h\"\n\n#include \"vrrp.h\"\n#include \"vrrp_data.h\"\n#include \"vrrp_print.h\"\n\nstatic const char *dump_file = \"/tmp/keepalived.data\";\nstatic const char *stats_file = \"/tmp/keepalived.stats\";\n\nvoid\nvrrp_print_data(void)\n{\n\tFILE *file = fopen (dump_file, \"w\");\n\n\tif (!file) {\n\t\tlog_message(LOG_INFO, \"Can't open %s (%d: %s)\",\n\t\t\tdump_file, errno, strerror(errno));\n\t\treturn;\n\t}\n\n\tdump_data_vrrp(file);\n\n\tfclose(file);\n}\n\nvoid\nvrrp_print_stats(void)\n{\n\tFILE *file;\n\tfile = fopen (stats_file, \"w\");\n\n\tif (!file) {\n\t\tlog_message(LOG_INFO, \"Can't open %s (%d: %s)\",\n\t\t\tstats_file, errno, strerror(errno));\n\t\treturn;\n\t}\n\n\tlist l = vrrp_data->vrrp;\n\telement e;\n\tvrrp_t *vrrp;\n\n\tfor (e = LIST_HEAD(l); e; ELEMENT_NEXT(e)) {\n\t\tvrrp = ELEMENT_DATA(e);\n\t\tfprintf(file, \"VRRP Instance: %s\\n\", vrrp->iname);\n\t\tfprintf(file, \"  Advertisements:\\n\");\n\t\tfprintf(file, \"    Received: %\" PRIu64 \"\\n\", vrrp->stats->advert_rcvd);\n\t\tfprintf(file, \"    Sent: %d\\n\", vrrp->stats->advert_sent);\n\t\tfprintf(file, \"  Became master: %d\\n\", vrrp->stats->become_master);\n\t\tfprintf(file, \"  Released master: %d\\n\",\n\t\t\tvrrp->stats->release_master);\n\t\tfprintf(file, \"  Packet Errors:\\n\");\n\t\tfprintf(file, \"    Length: %\" PRIu64 \"\\n\", vrrp->stats->packet_len_err);\n\t\tfprintf(file, \"    TTL: %\" PRIu64 \"\\n\", vrrp->stats->ip_ttl_err);\n\t\tfprintf(file, \"    Invalid Type: %\" PRIu64 \"\\n\",\n\t\t\tvrrp->stats->invalid_type_rcvd);\n\t\tfprintf(file, \"    Advertisement Interval: %\" PRIu64 \"\\n\",\n\t\t\tvrrp->stats->advert_interval_err);\n\t\tfprintf(file, \"    Address List: %\" PRIu64 \"\\n\",\n\t\t\tvrrp->stats->addr_list_err);\n\t\tfprintf(file, \"  Authentication Errors:\\n\");\n\t\tfprintf(file, \"    Invalid Type: %d\\n\",\n\t\t\tvrrp->stats->invalid_authtype);\n#ifdef _WITH_VRRP_AUTH_\n\t\tfprintf(file, \"    Type Mismatch: %d\\n\",\n\t\t\tvrrp->stats->authtype_mismatch);\n\t\tfprintf(file, \"    Failure: %d\\n\",\n\t\t\tvrrp->stats->auth_failure);\n#endif\n\t\tfprintf(file, \"  Priority Zero:\\n\");\n\t\tfprintf(file, \"    Received: %\" PRIu64 \"\\n\", vrrp->stats->pri_zero_rcvd);\n\t\tfprintf(file, \"    Sent: %\" PRIu64 \"\\n\", vrrp->stats->pri_zero_sent);\n\t}\n\tfclose(file);\n}\n", "/*\n * Soft:        Keepalived is a failover program for the LVS project\n *              <www.linuxvirtualserver.org>. It monitor & manipulate\n *              a loadbalanced server pool using multi-layer checks.\n *\n * Part:        Sheduling framework for vrrp code.\n *\n * Author:      Alexandre Cassen, <acassen@linux-vs.org>\n *\n *              This program is distributed in the hope that it will be useful,\n *              but WITHOUT ANY WARRANTY; without even the implied warranty of\n *              MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n *              See the GNU General Public License for more details.\n *\n *              This program is free software; you can redistribute it and/or\n *              modify it under the terms of the GNU General Public License\n *              as published by the Free Software Foundation; either version\n *              2 of the License, or (at your option) any later version.\n *\n * Copyright (C) 2001-2017 Alexandre Cassen, <acassen@gmail.com>\n */\n\n#include \"config.h\"\n\n#include <errno.h>\n#include <netinet/ip.h>\n#include <signal.h>\n#if defined _WITH_VRRP_AUTH_\n#include <netinet/in.h>\n#endif\n#include <stdint.h>\n#include <stdio.h>\n\n#include \"vrrp_scheduler.h\"\n#include \"vrrp_track.h\"\n#ifdef _HAVE_VRRP_VMAC_\n#include \"vrrp_vmac.h\"\n#endif\n#include \"vrrp_sync.h\"\n#include \"vrrp_notify.h\"\n#include \"vrrp_data.h\"\n#include \"vrrp_arp.h\"\n#include \"vrrp_ndisc.h\"\n#include \"vrrp_if.h\"\n#include \"global_data.h\"\n#include \"memory.h\"\n#include \"list.h\"\n#include \"logger.h\"\n#include \"main.h\"\n#include \"signals.h\"\n#include \"utils.h\"\n#include \"bitops.h\"\n#include \"vrrp_sock.h\"\n#ifdef _WITH_SNMP_RFCV3_\n#include \"vrrp_snmp.h\"\n#endif\n#ifdef _WITH_BFD_\n#include \"bfd_event.h\"\n#include \"bfd_daemon.h\"\n#endif\n#ifdef THREAD_DUMP\n#include \"scheduler.h\"\n#endif\n\n/* global vars */\ntimeval_t garp_next_time;\nthread_t *garp_thread;\nbool vrrp_initialised;\n\n#ifdef _TSM_DEBUG_\nbool do_tsm_debug;\n#endif\n\n/* local variables */\n#ifdef _WITH_BFD_\nstatic thread_t *bfd_thread;\t\t /* BFD control pipe read thread */\n#endif\n\n/* VRRP FSM (Finite State Machine) design.\n *\n * The state transition diagram implemented is :\n *\n *                         +---------------+\n *        +----------------|               |----------------+\n *        |                |     Fault     |                |\n *        |  +------------>|               |<------------+  |\n *        |  |             +---------------+             |  |\n *        |  |                     |                     |  |\n *        |  |                     V                     |  |\n *        |  |             +---------------+             |  |\n *        |  |  +--------->|               |<---------+  |  |\n *        |  |  |          |  Initialize   |          |  |  |\n *        |  |  |  +-------|               |-------+  |  |  |\n *        |  |  |  |       +---------------+       |  |  |  |\n *        |  |  |  |                               |  |  |  |\n *        V  |  |  V                               V  |  |  V\n *     +---------------+                       +---------------+\n *     |               |---------------------->|               |\n *     |    Master     |                       |    Backup     |\n *     |               |<----------------------|               |\n *     +---------------+                       +---------------+\n */\n\nstatic int vrrp_script_child_thread(thread_t *);\nstatic int vrrp_script_thread(thread_t *);\n#ifdef _WITH_BFD_\nstatic int vrrp_bfd_thread(thread_t *);\n#endif\n\nstatic int vrrp_read_dispatcher_thread(thread_t *);\n\n/* VRRP TSM (Transition State Matrix) design.\n *\n * Introducing the Synchronization extension to VRRP\n * protocol, introduce the need for a transition machinery.\n * This mechanism can be designed using a diagonal matrix.\n * We call this matrix the VRRP TSM:\n *\n *   \\ E |  B  |  M  |  F  |\n *   S \\ |     |     |     |\n * ------+-----+-----+-----+     Legend:\n *   B   |  x     1     2  |       B: VRRP BACKUP state\n * ------+                 |       M: VRRP MASTER state\n *   M   |  3     x     4  |       F: VRRP FAULT state\n * ------+                 |       S: VRRP start state (before transition)\n *   F   |  5     6     x  |       E: VRRP end state (after transition)\n * ------+-----------------+       [1..6]: Handler functions.\n *\n * So we have have to implement n(n-1) handlers in order to deal with\n * all transitions possible. This matrix defines the maximum handlers\n * to implement for having the most time optimized transition machine.\n * For example:\n *     . The handler (1) will sync all the BACKUP VRRP instances of a\n *       group to MASTER state => we will call it vrrp_sync_master.\n *     .... and so on for all other state ....\n *\n * This matrix is the strict implementation way. For readability and\n * performance we have implemented some handlers directly into the VRRP\n * FSM or they are handled when the trigger events to/from FAULT state occur.\n * For instance the handlers (2), (4), (5) & (6) are handled when it is\n * detected that a script or an interface has failed or recovered since\n * it will speed up convergence to init state.\n * Additionaly, we have implemented some other handlers into the matrix\n * in order to speed up group synchronization takeover. For instance\n * transition:\n *    o B->B: To catch wantstate MASTER transition to force sync group\n *            to this transition state too.\n *    o F->F: To speed up FAULT state transition if group is not already\n *            synced to FAULT state.\n */\nstatic struct {\n\tvoid (*handler) (vrrp_t *);\n} VRRP_TSM[VRRP_MAX_TSM_STATE + 1][VRRP_MAX_TSM_STATE + 1] =\n{\n/* From:\t  To: >\t  BACKUP\t\t\tMASTER\t\t    FAULT */\n/*   v    */\t{ {NULL}, {NULL},\t\t\t{NULL},\t\t   {NULL} },\n/* BACKUP */\t{ {NULL}, {NULL},\t\t\t{vrrp_sync_master}, {NULL} },\n/* MASTER */\t{ {NULL}, {vrrp_sync_backup},\t\t{vrrp_sync_master}, {NULL} },\n/* FAULT  */\t{ {NULL}, {NULL},\t\t\t{vrrp_sync_master}, {NULL} }\n};\n\n/*\n * Initialize state handling\n * --rfc2338.6.4.1\n */\nstatic void\nvrrp_init_state(list l)\n{\n\tvrrp_t *vrrp;\n\tvrrp_sgroup_t *vgroup;\n\telement e;\n\tbool is_up;\n\tint new_state;\n\n\t/* We can send SMTP messages from this point, so set the time */\n\tset_time_now();\n\n\t/* Do notifications for any sync groups in fault state */\n\tfor (e = LIST_HEAD(vrrp_data->vrrp_sync_group); e; ELEMENT_NEXT(e)) {\n\t\t/* Init group if needed  */\n\t\tvgroup = ELEMENT_DATA(e);\n\n\t\tif (vgroup->state == VRRP_STATE_FAULT)\n\t\t\tsend_group_notifies(vgroup);\n\t}\n\n\tfor (e = LIST_HEAD(l); e; ELEMENT_NEXT(e)) {\n\t\tvrrp = ELEMENT_DATA(e);\n\n\t\t/* wantstate is the state we would be in disregarding any sync group */\n\t\tif (vrrp->state == VRRP_STATE_FAULT)\n\t\t\tvrrp->wantstate = VRRP_STATE_FAULT;\n\n\t\tnew_state = vrrp->sync ? vrrp->sync->state : vrrp->wantstate;\n\n\t\tis_up = VRRP_ISUP(vrrp);\n\n\t\tif (is_up &&\n\t\t    new_state == VRRP_STATE_MAST &&\n\t\t    !vrrp->num_script_init && (!vrrp->sync || !vrrp->sync->num_member_init) &&\n\t\t    (vrrp->base_priority == VRRP_PRIO_OWNER ||\n\t\t     vrrp->reload_master) &&\n\t\t    vrrp->wantstate == VRRP_STATE_MAST) {\n#ifdef _WITH_LVS_\n\t\t\t/* Check if sync daemon handling is needed */\n\t\t\tif (global_data->lvs_syncd.ifname &&\n\t\t\t    global_data->lvs_syncd.vrrp == vrrp)\n\t\t\t\tipvs_syncd_cmd(IPVS_STARTDAEMON,\n\t\t\t\t\t       &global_data->lvs_syncd,\n\t\t\t\t\t       vrrp->state == VRRP_STATE_MAST ? IPVS_MASTER : IPVS_BACKUP,\n\t\t\t\t\t       false,\n\t\t\t\t\t       false);\n#endif\n\t\t\tif (!vrrp->reload_master) {\n#ifdef _WITH_SNMP_RFCV3_\n\t\t\t\tvrrp->stats->next_master_reason = VRRPV3_MASTER_REASON_PREEMPTED;\n#endif\n\n\t\t\t\t/* The simplest way to become master is to timeout from the backup state\n\t\t\t\t * very quickly (1usec) */\n\t\t\t\tvrrp->state = VRRP_STATE_BACK;\n\t\t\t\tvrrp->ms_down_timer = 1;\n\t\t\t}\n\n// TODO Do we need ->\tvrrp_restore_interface(vrrp, false, false);\n// It removes everything, so probably if !reload\n\t\t} else {\n\t\t\tif (new_state == VRRP_STATE_BACK && vrrp->wantstate == VRRP_STATE_MAST)\n\t\t\t\tvrrp->ms_down_timer = vrrp->master_adver_int + VRRP_TIMER_SKEW_MIN(vrrp);\n\t\t\telse\n\t\t\t\tvrrp->ms_down_timer = 3 * vrrp->master_adver_int + VRRP_TIMER_SKEW(vrrp);\n\n#ifdef _WITH_SNMP_RFCV3_\n\t\t\tvrrp->stats->next_master_reason = VRRPV3_MASTER_REASON_MASTER_NO_RESPONSE;\n#endif\n\n#ifdef _WITH_LVS_\n\t\t\t/* Check if sync daemon handling is needed */\n\t\t\tif (global_data->lvs_syncd.ifname &&\n\t\t\t    global_data->lvs_syncd.vrrp == vrrp)\n\t\t\t\tipvs_syncd_cmd(IPVS_STARTDAEMON,\n\t\t\t\t\t       &global_data->lvs_syncd,\n\t\t\t\t\t       IPVS_BACKUP,\n\t\t\t\t\t       false,\n\t\t\t\t\t       false);\n#endif\n\n\t\t\t/* Set interface state */\n\t\t\tvrrp_restore_interface(vrrp, false, false);\n\t\t\tif (is_up && new_state != VRRP_STATE_FAULT && !vrrp->num_script_init && (!vrrp->sync || !vrrp->sync->num_member_init)) {\n\t\t\t\tif (is_up) {\n\t\t\t\t\tvrrp->state = VRRP_STATE_BACK;\n\t\t\t\t\tlog_message(LOG_INFO, \"(%s) Entering BACKUP STATE (init)\", vrrp->iname);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tvrrp->state = VRRP_STATE_FAULT;\n\t\t\t\t\tlog_message(LOG_INFO, \"(%s) Entering FAULT STATE (init)\", vrrp->iname);\n\t\t\t\t}\n\t\t\t\tsend_instance_notifies(vrrp);\n\t\t\t}\n\t\t\tvrrp->last_transition = timer_now();\n\t\t}\n#ifdef _WITH_SNMP_RFC_\n\t\tvrrp->stats->uptime = timer_now();\n#endif\n\t}\n}\n\n/* Declare vrrp_timer_cmp() rbtree compare function */\nRB_TIMER_CMP(vrrp);\n\n/* Compute the new instance sands */\nvoid\nvrrp_init_instance_sands(vrrp_t * vrrp)\n{\n\tset_time_now();\n\n\tif (vrrp->state == VRRP_STATE_MAST) {\n\t\tif (vrrp->reload_master)\n\t\t\tvrrp->sands = time_now;\n\t\telse\n\t\t\tvrrp->sands = timer_add_long(time_now, vrrp->adver_int);\n\t}\n\telse if (vrrp->state == VRRP_STATE_BACK) {\n\t\t/*\n\t\t * When in the BACKUP state the expiry timer should be updated to\n\t\t * time_now plus the Master Down Timer, when a non-preemptable packet is\n\t\t * received.\n\t\t */\n\t\tvrrp->sands = timer_add_long(time_now, vrrp->ms_down_timer);\n\t}\n\telse if (vrrp->state == VRRP_STATE_FAULT || vrrp->state == VRRP_STATE_INIT)\n\t\tvrrp->sands.tv_sec = TIMER_DISABLED;\n\n\trb_move_cached(&vrrp->sockets->rb_sands, vrrp, rb_sands, vrrp_timer_cmp);\n}\n\nstatic void\nvrrp_init_sands(list l)\n{\n\tvrrp_t *vrrp;\n\telement e;\n\n\tLIST_FOREACH(l, vrrp, e) {\n\t\tvrrp->sands.tv_sec = TIMER_DISABLED;\n\t\trb_insert_sort_cached(&vrrp->sockets->rb_sands, vrrp, rb_sands, vrrp_timer_cmp);\n\t\tvrrp_init_instance_sands(vrrp);\n\t\tvrrp->reload_master = false;\n\t}\n}\n\nstatic void\nvrrp_init_script(list l)\n{\n\tvrrp_script_t *vscript;\n\telement e;\n\n\tLIST_FOREACH(l, vscript, e) {\n\t\tif (vscript->init_state == SCRIPT_INIT_STATE_INIT)\n\t\t\tvscript->result = vscript->rise - 1; /* one success is enough */\n\t\telse if (vscript->init_state == SCRIPT_INIT_STATE_FAILED)\n\t\t\tvscript->result = 0; /* assume failed by config */\n\n\t\tthread_add_event(master, vrrp_script_thread, vscript, (int)vscript->interval);\n\t}\n}\n\n/* Timer functions */\nstatic timeval_t *\nvrrp_compute_timer(const sock_t *sock)\n{\n\tvrrp_t *vrrp;\n\tstatic timeval_t timer = { .tv_sec = TIMER_DISABLED };\n\n\t/* The sock won't exist if there isn't a vrrp instance on it,\n\t * so rb_first will always exist. */\n\tvrrp = rb_entry(rb_first_cached(&sock->rb_sands), vrrp_t, rb_sands);\n\tif (vrrp)\n\t\treturn &vrrp->sands;\n\n\treturn &timer;\n}\n\nvoid\nvrrp_thread_requeue_read(vrrp_t *vrrp)\n{\n\tthread_requeue_read(master, vrrp->sockets->fd_in, vrrp_compute_timer(vrrp->sockets));\n}\n\n/* Thread functions */\nstatic void\nvrrp_register_workers(list l)\n{\n\tsock_t *sock;\n\ttimeval_t timer;\n\telement e;\n\n\t/* Init compute timer */\n\tmemset(&timer, 0, sizeof(timer));\n\n\t/* Init the VRRP instances state */\n\tvrrp_init_state(vrrp_data->vrrp);\n\n\t/* Init VRRP instances sands */\n\tvrrp_init_sands(vrrp_data->vrrp);\n\n\t/* Init VRRP tracking scripts */\n\tif (!LIST_ISEMPTY(vrrp_data->vrrp_script))\n\t\tvrrp_init_script(vrrp_data->vrrp_script);\n\n#ifdef _WITH_BFD_\n\tif (!LIST_ISEMPTY(vrrp_data->vrrp)) {\n// TODO - should we only do this if we have track_bfd? Probably not\n\t\t/* Init BFD tracking thread */\n\t\tbfd_thread = thread_add_read(master, vrrp_bfd_thread, NULL,\n\t\t\t\t\t     bfd_vrrp_event_pipe[0], TIMER_NEVER);\n\t}\n#endif\n\n\t/* Register VRRP workers threads */\n\tLIST_FOREACH(l, sock, e) {\n\t\t/* Register a timer thread if interface exists */\n\t\tif (sock->fd_in != -1)\n\t\t\tsock->thread = thread_add_read_sands(master, vrrp_read_dispatcher_thread,\n\t\t\t\t\t\t       sock, sock->fd_in, vrrp_compute_timer(sock));\n\t}\n}\n\nvoid\nvrrp_thread_add_read(vrrp_t *vrrp)\n{\n\tvrrp->sockets->thread = thread_add_read_sands(master, vrrp_read_dispatcher_thread,\n\t\t\t\t\t\tvrrp->sockets, vrrp->sockets->fd_in, vrrp_compute_timer(vrrp->sockets));\n}\n\n/* VRRP dispatcher functions */\nstatic sock_t *\nalready_exist_sock(list l, sa_family_t family, int proto, ifindex_t ifindex, bool unicast)\n{\n\tsock_t *sock;\n\telement e;\n\n\tLIST_FOREACH(l, sock, e) {\n\t\tif ((sock->family == family)\t&&\n\t\t    (sock->proto == proto)\t&&\n\t\t    (sock->ifindex == ifindex)\t&&\n\t\t    (sock->unicast == unicast))\n\t\t\treturn sock;\n\t}\n\n\treturn NULL;\n}\n\nstatic sock_t *\nalloc_sock(sa_family_t family, list l, int proto, ifindex_t ifindex, bool unicast)\n{\n\tsock_t *new;\n\n\tnew = (sock_t *)MALLOC(sizeof (sock_t));\n\tnew->family = family;\n\tnew->proto = proto;\n\tnew->ifindex = ifindex;\n\tnew->unicast = unicast;\n\tnew->rb_vrid = RB_ROOT;\n\tnew->rb_sands = RB_ROOT_CACHED;\n\n\tlist_add(l, new);\n\n\treturn new;\n}\n\nstatic inline int\nvrrp_vrid_cmp(const vrrp_t *v1, const vrrp_t *v2)\n{\n\treturn v1->vrid - v2->vrid;\n}\n\nstatic void\nvrrp_create_sockpool(list l)\n{\n\tvrrp_t *vrrp;\n\telement e;\n\tifindex_t ifindex;\n\tint proto;\n\tbool unicast;\n\tsock_t *sock;\n\n\tLIST_FOREACH(vrrp_data->vrrp, vrrp, e) {\n\t\tifindex =\n#ifdef _HAVE_VRRP_VMAC_\n\t\t\t  (__test_bit(VRRP_VMAC_XMITBASE_BIT, &vrrp->vmac_flags)) ? IF_BASE_INDEX(vrrp->ifp) :\n#endif\n\t\t\t\t\t\t\t\t\t\t    IF_INDEX(vrrp->ifp);\n\t\tunicast = !LIST_ISEMPTY(vrrp->unicast_peer);\n#if defined _WITH_VRRP_AUTH_\n\t\tif (vrrp->auth_type == VRRP_AUTH_AH)\n\t\t\tproto = IPPROTO_AH;\n\t\telse\n#endif\n\t\t\tproto = IPPROTO_VRRP;\n\n\t\t/* add the vrrp element if not exist */\n\t\tif (!(sock = already_exist_sock(l, vrrp->family, proto, ifindex, unicast)))\n\t\t\tsock = alloc_sock(vrrp->family, l, proto, ifindex, unicast);\n\n\t\t/* Add the vrrp_t indexed by vrid to the socket */\n\t\trb_insert_sort(&sock->rb_vrid, vrrp, rb_vrid, vrrp_vrid_cmp);\n\n\t\tif (vrrp->kernel_rx_buf_size)\n\t\t\tsock->rx_buf_size += vrrp->kernel_rx_buf_size;\n\t\telse if (global_data->vrrp_rx_bufs_policy & RX_BUFS_SIZE)\n\t\t\tsock->rx_buf_size += global_data->vrrp_rx_bufs_size;\n\t\telse if (global_data->vrrp_rx_bufs_policy & RX_BUFS_POLICY_ADVERT)\n\t\t\tsock->rx_buf_size += global_data->vrrp_rx_bufs_multiples * vrrp_adv_len(vrrp);\n\t\telse if (global_data->vrrp_rx_bufs_policy & RX_BUFS_POLICY_MTU)\n\t\t\tsock->rx_buf_size += global_data->vrrp_rx_bufs_multiples * vrrp->ifp->mtu;\n\t}\n}\n\nstatic void\nvrrp_open_sockpool(list l)\n{\n\tsock_t *sock;\n\telement e;\n\tinterface_t *ifp;\n\n\tLIST_FOREACH(l, sock, e) {\n\t\tif (!sock->ifindex) {\n\t\t\tsock->fd_in = sock->fd_out = -1;\n\t\t\tcontinue;\n\t\t}\n\t\tifp = if_get_by_ifindex(sock->ifindex);\n\t\tsock->fd_in = open_vrrp_read_socket(sock->family, sock->proto,\n\t\t\t\t\t       ifp, sock->unicast, sock->rx_buf_size);\n\t\tif (sock->fd_in == -1)\n\t\t\tsock->fd_out = -1;\n\t\telse\n\t\t\tsock->fd_out = open_vrrp_send_socket(sock->family, sock->proto,\n\t\t\t\t\t\t\t     ifp, sock->unicast);\n\t}\n}\n\nstatic void\nvrrp_set_fds(list l)\n{\n\tsock_t *sock;\n\tvrrp_t *vrrp;\n\telement e;\n\n\tLIST_FOREACH(l, sock, e) {\n\t\trb_for_each_entry(vrrp, &sock->rb_vrid, rb_vrid)\n\t\t\tvrrp->sockets = sock;\n\t}\n}\n\n/*\n * We create & allocate a socket pool here. The soft design\n * can be sum up by the following sketch :\n *\n *    fd1  fd2    fd3  fd4          fdi  fdi+1\n * -----\\__/--------\\__/---........---\\__/---\n *    | ETH0 |    | ETH1 |          | ETHn |\n *    +------+    +------+          +------+\n *\n * TODO TODO - this description is way out of date\n * Here we have n physical NIC. Each NIC own a maximum of 2 fds.\n * (one for VRRP the other for IPSEC_AH). All our VRRP instances\n * are multiplexed through this fds. So our design can handle 2*n\n * multiplexing points.\n */\nint\nvrrp_dispatcher_init(__attribute__((unused)) thread_t * thread)\n{\n\tvrrp_create_sockpool(vrrp_data->vrrp_socket_pool);\n\n\t/* open the VRRP socket pool */\n\tvrrp_open_sockpool(vrrp_data->vrrp_socket_pool);\n\n\t/* set VRRP instance fds to sockpool */\n\tvrrp_set_fds(vrrp_data->vrrp_socket_pool);\n\n\t/* create the VRRP socket pool list */\n\t/* register read dispatcher worker thread */\n\tvrrp_register_workers(vrrp_data->vrrp_socket_pool);\n\n\t/* Dump socket pool */\n\tif (__test_bit(LOG_DETAIL_BIT, &debug))\n\t\tdump_list(NULL, vrrp_data->vrrp_socket_pool);\n\n\tvrrp_initialised = true;\n\n\treturn 1;\n}\n\nvoid\nvrrp_dispatcher_release(vrrp_data_t *data)\n{\n\tfree_list(&data->vrrp_socket_pool);\n#ifdef _WITH_BFD_\n\tthread_cancel(bfd_thread);\n\tbfd_thread = NULL;\n#endif\n}\n\nstatic void\nvrrp_goto_master(vrrp_t * vrrp)\n{\n\t/* handle master state transition */\n\tvrrp->wantstate = VRRP_STATE_MAST;\n\tvrrp_state_goto_master(vrrp);\n}\n\n/* Delayed gratuitous ARP thread */\nint\nvrrp_gratuitous_arp_thread(thread_t * thread)\n{\n\tvrrp_t *vrrp = THREAD_ARG(thread);\n\n\t/* Simply broadcast the gratuitous ARP */\n\tvrrp_send_link_update(vrrp, vrrp->garp_rep);\n\n\treturn 0;\n}\n\n/* Delayed gratuitous ARP thread after receiving a lower priority advert */\nint\nvrrp_lower_prio_gratuitous_arp_thread(thread_t * thread)\n{\n\tvrrp_t *vrrp = THREAD_ARG(thread);\n\n\t/* Simply broadcast the gratuitous ARP */\n\tvrrp_send_link_update(vrrp, vrrp->garp_lower_prio_rep);\n\n\treturn 0;\n}\n\nstatic void\nvrrp_master(vrrp_t * vrrp)\n{\n\t/* Send the VRRP advert */\n\tvrrp_state_master_tx(vrrp);\n}\n\nvoid\ntry_up_instance(vrrp_t *vrrp, bool leaving_init)\n{\n\tint wantstate;\n\n\tif (leaving_init) {\n\t\tif (vrrp->num_script_if_fault)\n\t\t\treturn;\n\t}\n\telse if (--vrrp->num_script_if_fault || vrrp->num_script_init)\n\t\treturn;\n\n\tif (vrrp->wantstate == VRRP_STATE_MAST && vrrp->base_priority == VRRP_PRIO_OWNER) {\n\t\tvrrp->wantstate = VRRP_STATE_MAST;\n#ifdef _WITH_SNMP_RFCV3_\n\t\tvrrp->stats->next_master_reason = VRRPV3_MASTER_REASON_PREEMPTED;\n#endif\n\t} else {\n\t\tvrrp->wantstate = VRRP_STATE_BACK;\n#ifdef _WITH_SNMP_RFCV3_\n\t\tvrrp->stats->next_master_reason = VRRPV3_MASTER_REASON_MASTER_NO_RESPONSE;\n#endif\n\t}\n\n\tvrrp->master_adver_int = vrrp->adver_int;\n\tif (vrrp->wantstate == VRRP_STATE_MAST && vrrp->base_priority == VRRP_PRIO_OWNER)\n\t\tvrrp->ms_down_timer = vrrp->master_adver_int + VRRP_TIMER_SKEW(vrrp);\n\telse\n\t\tvrrp->ms_down_timer = 3 * vrrp->master_adver_int + VRRP_TIMER_SKEW(vrrp);\n\n\tif (vrrp->sync) {\n\t\tif (leaving_init) {\n\t\t\tif (vrrp->sync->num_member_fault)\n\t\t\t\treturn;\n\t\t}\n\t\telse if (--vrrp->sync->num_member_fault || vrrp->sync->num_member_init)\n\t\t\treturn;\n\t}\n\n\t/* If the sync group can't go to master, we must go to backup state */\n\twantstate = vrrp->wantstate;\n\tif (vrrp->sync && vrrp->wantstate == VRRP_STATE_MAST && !vrrp_sync_can_goto_master(vrrp))\n\t\tvrrp->wantstate = VRRP_STATE_BACK;\n\n\t/* We can come up */\n\tvrrp_state_leave_fault(vrrp);\n\n\tvrrp_init_instance_sands(vrrp);\n\tvrrp_thread_requeue_read(vrrp);\n\n\tvrrp->wantstate = wantstate;\n\n\tif (vrrp->sync) {\n\t\tif (vrrp->state == VRRP_STATE_MAST)\n\t\t\tvrrp_sync_master(vrrp);\n\t\telse\n\t\t\tvrrp_sync_backup(vrrp);\n\t}\n}\n\n#ifdef _WITH_BFD_\nstatic void\nvrrp_handle_bfd_event(bfd_event_t * evt)\n{\n\tvrrp_tracked_bfd_t *vbfd;\n\ttracking_vrrp_t *tbfd;\n\tvrrp_t * vrrp;\n\telement e, e1;\n\tstruct timeval time_now;\n\tstruct timeval timer_tmp;\n\tuint32_t delivery_time;\n\n\tif (__test_bit(LOG_DETAIL_BIT, &debug)) {\n\t\ttime_now = timer_now();\n\t\ttimersub(&time_now, &evt->sent_time, &timer_tmp);\n\t\tdelivery_time = timer_long(timer_tmp);\n\t\tlog_message(LOG_INFO, \"Received BFD event: instance %s is in\"\n\t\t\t    \" state %s (delivered in %i usec)\",\n\t\t\t    evt->iname, BFD_STATE_STR(evt->state), delivery_time);\n\t}\n\n\tLIST_FOREACH(vrrp_data->vrrp_track_bfds, vbfd, e) {\n\t\tif (strcmp(vbfd->bname, evt->iname))\n\t\t\tcontinue;\n\n\t\tif ((vbfd->bfd_up && evt->state == BFD_STATE_UP) ||\n\t\t    (!vbfd->bfd_up && evt->state == BFD_STATE_DOWN))\n\t\t\tcontinue;\n\n\t\tvbfd->bfd_up = (evt->state == BFD_STATE_UP);\n\n\t\tLIST_FOREACH(vbfd->tracking_vrrp, tbfd, e1) {\n\t\t\tvrrp = tbfd->vrrp;\n\n\t\t\tlog_message(LOG_INFO, \"VRRP_Instance(%s) Tracked BFD\"\n\t\t\t\t    \" instance %s is %s\", vrrp->iname, evt->iname, vbfd->bfd_up ? \"UP\" : \"DOWN\");\n\n\t\t\tif (tbfd->weight) {\n\t\t\t\tif (vbfd->bfd_up)\n\t\t\t\t\tvrrp->total_priority += abs(tbfd->weight);\n\t\t\t\telse\n\t\t\t\t\tvrrp->total_priority -= abs(tbfd->weight);\n\t\t\t\tvrrp_set_effective_priority(vrrp);\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (vbfd->bfd_up)\n\t\t\t\ttry_up_instance(vrrp, false);\n\t\t\telse\n\t\t\t\tdown_instance(vrrp);\n\t\t}\n\n\t\tbreak;\n\t}\n}\n\nstatic int\nvrrp_bfd_thread(thread_t * thread)\n{\n\tbfd_event_t evt;\n\n\tbfd_thread = thread_add_read(master, vrrp_bfd_thread, NULL,\n\t\t\t\t     thread->u.fd, TIMER_NEVER);\n\n\tif (thread->type != THREAD_READY_FD)\n\t\treturn 0;\n\n\twhile (read(thread->u.fd, &evt, sizeof(bfd_event_t)) != -1)\n\t\tvrrp_handle_bfd_event(&evt);\n\n\treturn 0;\n}\n#endif\n\n/* Handle dispatcher read timeout */\nstatic int\nvrrp_dispatcher_read_timeout(sock_t *sock)\n{\n\tvrrp_t *vrrp;\n\tint prev_state;\n\n\tset_time_now();\n\n\trb_for_each_entry_cached(vrrp, &sock->rb_sands, rb_sands) {\n\t\tif (vrrp->sands.tv_sec == TIMER_DISABLED ||\n\t\t    timercmp(&vrrp->sands, &time_now, >))\n\t\t\tbreak;\n\n\t\tprev_state = vrrp->state;\n\n\t\tif (vrrp->state == VRRP_STATE_BACK) {\n\t\t\tif (__test_bit(LOG_DETAIL_BIT, &debug))\n\t\t\t\tlog_message(LOG_INFO, \"(%s) Receive advertisement timeout\", vrrp->iname);\n\t\t\tvrrp_goto_master(vrrp);\n\t\t}\n\t\telse if (vrrp->state == VRRP_STATE_MAST)\n\t\t\tvrrp_master(vrrp);\n\n\t\t/* handle instance synchronization */\n#ifdef _TSM_DEBUG_\n\t\tif (do_tsm_debug)\n\t\t\tlog_message(LOG_INFO, \"Send [%s] TSM transition : [%d,%d] Wantstate = [%d]\",\n\t\t\t\tvrrp->iname, prev_state, vrrp->state, vrrp->wantstate);\n#endif\n\t\tVRRP_TSM_HANDLE(prev_state, vrrp);\n\n\t\tvrrp_init_instance_sands(vrrp);\n\t}\n\n\treturn sock->fd_in;\n}\n\n/* Handle dispatcher read packet */\nstatic int\nvrrp_dispatcher_read(sock_t * sock)\n{\n\tvrrp_t *vrrp;\n\tvrrphdr_t *hd;\n\tssize_t len = 0;\n\tint prev_state = 0;\n\tunsigned proto = 0;\n\tstruct sockaddr_storage src_addr;\n\tsocklen_t src_addr_len = sizeof(src_addr);\n\tvrrp_t vrrp_lookup;\n\n\t/* Clean the read buffer */\n\tmemset(vrrp_buffer, 0, vrrp_buffer_len);\n\n\t/* read & affect received buffer */\n\tlen = recvfrom(sock->fd_in, vrrp_buffer, vrrp_buffer_len, 0,\n\t\t       (struct sockaddr *) &src_addr, &src_addr_len);\n\thd = vrrp_get_header(sock->family, vrrp_buffer, &proto);\n\n\tvrrp_lookup.vrid = hd->vrid;\n\tvrrp = rb_search(&sock->rb_vrid, &vrrp_lookup, rb_vrid, vrrp_vrid_cmp);\n\n\t/* If no instance found => ignore the advert */\n\tif (!vrrp)\n\t\treturn sock->fd_in;\n\n\tif (vrrp->state == VRRP_STATE_FAULT ||\n\t    vrrp->state == VRRP_STATE_INIT) {\n\t\t/* We just ignore a message received when we are in fault state or\n\t\t * not yet fully initialised */\n\t\treturn sock->fd_in;\n\t}\n\n\tvrrp->pkt_saddr = src_addr;\n\n\tprev_state = vrrp->state;\n\n\tif (vrrp->state == VRRP_STATE_BACK)\n\t\tvrrp_state_backup(vrrp, vrrp_buffer, len);\n\telse if (vrrp->state == VRRP_STATE_MAST) {\n\t\tif (vrrp_state_master_rx(vrrp, vrrp_buffer, len))\n\t\t\tvrrp_state_leave_master(vrrp, false);\n\t} else\n\t\tlog_message(LOG_INFO, \"(%s) In dispatcher_read with state %d\", vrrp->iname, vrrp->state);\n\n\t/* handle instance synchronization */\n#ifdef _TSM_DEBUG_\n\tif (do_tsm_debug)\n\t\tlog_message(LOG_INFO, \"Read [%s] TSM transition : [%d,%d] Wantstate = [%d]\",\n\t\t\tvrrp->iname, prev_state, vrrp->state, vrrp->wantstate);\n#endif\n\tVRRP_TSM_HANDLE(prev_state, vrrp);\n\n\t/* If we have sent an advert, reset the timer */\n\tif (vrrp->state != VRRP_STATE_MAST || !vrrp->lower_prio_no_advert)\n\t\tvrrp_init_instance_sands(vrrp);\n\n\treturn sock->fd_in;\n}\n\n/* Our read packet dispatcher */\nstatic int\nvrrp_read_dispatcher_thread(thread_t * thread)\n{\n\tsock_t *sock;\n\tint fd;\n\n\t/* Fetch thread arg */\n\tsock = THREAD_ARG(thread);\n\n\t/* Dispatcher state handler */\n\tif (thread->type == THREAD_READ_TIMEOUT || sock->fd_in == -1)\n\t\tfd = vrrp_dispatcher_read_timeout(sock);\n\telse\n\t\tfd = vrrp_dispatcher_read(sock);\n\n\t/* register next dispatcher thread */\n\tif (fd != -1)\n\t\tsock->thread = thread_add_read_sands(thread->master, vrrp_read_dispatcher_thread,\n\t\t\t\t\t       sock, fd, vrrp_compute_timer(sock));\n\n\treturn 0;\n}\n\nstatic int\nvrrp_script_thread(thread_t * thread)\n{\n\tvrrp_script_t *vscript = THREAD_ARG(thread);\n\tint ret;\n\n\t/* Register next timer tracker */\n\tthread_add_timer(thread->master, vrrp_script_thread, vscript,\n\t\t\t vscript->interval);\n\n\tif (vscript->state != SCRIPT_STATE_IDLE) {\n\t\t/* We don't want the system to be overloaded with scripts that we are executing */\n\t\tlog_message(LOG_INFO, \"Track script %s is %s, expect idle - skipping run\",\n\t\t\t    vscript->sname, vscript->state == SCRIPT_STATE_RUNNING ? \"already running\" : \"being timed out\");\n\n\t\treturn 0;\n\t}\n\n\t/* Execute the script in a child process. Parent returns, child doesn't */\n\tret = system_call_script(thread->master, vrrp_script_child_thread,\n\t\t\t\t  vscript, (vscript->timeout) ? vscript->timeout : vscript->interval,\n\t\t\t\t  &vscript->script);\n\tif (!ret)\n\t\tvscript->state = SCRIPT_STATE_RUNNING;\n\n\treturn ret;\n}\n\nstatic int\nvrrp_script_child_thread(thread_t * thread)\n{\n\tint wait_status;\n\tpid_t pid;\n\tvrrp_script_t *vscript = THREAD_ARG(thread);\n\tint sig_num;\n\tunsigned timeout = 0;\n\tchar *script_exit_type = NULL;\n\tbool script_success;\n\tchar *reason = NULL;\n\tint reason_code;\n\n\tif (thread->type == THREAD_CHILD_TIMEOUT) {\n\t\tpid = THREAD_CHILD_PID(thread);\n\n\t\tif (vscript->state == SCRIPT_STATE_RUNNING) {\n\t\t\tvscript->state = SCRIPT_STATE_REQUESTING_TERMINATION;\n\t\t\tsig_num = SIGTERM;\n\t\t\ttimeout = 2;\n\t\t} else if (vscript->state == SCRIPT_STATE_REQUESTING_TERMINATION) {\n\t\t\tvscript->state = SCRIPT_STATE_FORCING_TERMINATION;\n\t\t\tsig_num = SIGKILL;\n\t\t\ttimeout = 2;\n\t\t} else if (vscript->state == SCRIPT_STATE_FORCING_TERMINATION) {\n\t\t\tlog_message(LOG_INFO, \"Child (PID %d) failed to terminate after kill\", pid);\n\t\t\tsig_num = SIGKILL;\n\t\t\ttimeout = 10;\t/* Give it longer to terminate */\n\t\t}\n\n\t\t/* Kill it off. */\n\t\tif (timeout) {\n\t\t\t/* If kill returns an error, we can't kill the process since either the process has terminated,\n\t\t\t * or we don't have permission. If we can't kill it, there is no point trying again. */\n\t\t\tif (kill(-pid, sig_num)) {\n\t\t\t\tif (errno == ESRCH) {\n\t\t\t\t\t/* The process does not exist; presumably it\n\t\t\t\t\t * has just terminated. We should get\n\t\t\t\t\t * notification of it's termination, so allow\n\t\t\t\t\t * that to handle it. */\n\t\t\t\t\ttimeout = 1;\n\t\t\t\t} else {\n\t\t\t\t\tlog_message(LOG_INFO, \"kill -%d of process %s(%d) with new state %d failed with errno %d\", sig_num, vscript->script.args[0], pid, vscript->state, errno);\n\t\t\t\t\ttimeout = 1000;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (vscript->state != SCRIPT_STATE_IDLE) {\n\t\t\tlog_message(LOG_INFO, \"Child thread pid %d timeout with unknown script state %d\", pid, vscript->state);\n\t\t\ttimeout = 10;\t/* We need some timeout */\n\t\t}\n\n\t\tif (timeout)\n\t\t\tthread_add_child(thread->master, vrrp_script_child_thread, vscript, pid, timeout * TIMER_HZ);\n\n\t\treturn 0;\n\t}\n\n\twait_status = THREAD_CHILD_STATUS(thread);\n\n\tif (WIFEXITED(wait_status)) {\n\t\tint status = WEXITSTATUS(wait_status);\n\n\t\t/* Report if status has changed */\n\t\tif (status != vscript->last_status)\n\t\t\tlog_message(LOG_INFO, \"Script `%s` now returning %d\", vscript->sname, status);\n\n\t\tif (status == 0) {\n\t\t\t/* success */\n\t\t\tscript_exit_type = \"succeeded\";\n\t\t\tscript_success = true;\n\t\t} else {\n\t\t\t/* failure */\n\t\t\tscript_exit_type = \"failed\";\n\t\t\tscript_success = false;\n\t\t\treason = \"exited with status\";\n\t\t\treason_code = status;\n\t\t}\n\n\t\tvscript->last_status = status;\n\t}\n\telse if (WIFSIGNALED(wait_status)) {\n\t\tif (vscript->state == SCRIPT_STATE_REQUESTING_TERMINATION && WTERMSIG(wait_status) == SIGTERM) {\n\t\t\t/* The script terminated due to a SIGTERM, and we sent it a SIGTERM to\n\t\t\t * terminate the process. Now make sure any children it created have\n\t\t\t * died too. */\n\t\t\tpid = THREAD_CHILD_PID(thread);\n\t\t\tkill(-pid, SIGKILL);\n\t\t}\n\n\t\t/* We treat forced termination as a failure */\n\t\tif ((vscript->state == SCRIPT_STATE_REQUESTING_TERMINATION && WTERMSIG(wait_status) == SIGTERM) ||\n\t\t    (vscript->state == SCRIPT_STATE_FORCING_TERMINATION && (WTERMSIG(wait_status) == SIGKILL || WTERMSIG(wait_status) == SIGTERM)))\n\t\t\tscript_exit_type = \"timed_out\";\n\t\telse {\n\t\t\tscript_exit_type = \"failed\";\n\t\t\treason = \"due to signal\";\n\t\t\treason_code = WTERMSIG(wait_status);\n\t\t}\n\t\tscript_success = false;\n\t}\n\n\tif (script_exit_type) {\n\t\tif (script_success) {\n\t\t\tif (vscript->result < vscript->rise - 1) {\n\t\t\t\tvscript->result++;\n\t\t\t} else if (vscript->result != vscript->rise + vscript->fall - 1) {\n\t\t\t\tif (vscript->result < vscript->rise) {\t/* i.e. == vscript->rise - 1 */\n\t\t\t\t\tlog_message(LOG_INFO, \"VRRP_Script(%s) %s\", vscript->sname, script_exit_type);\n\t\t\t\t\tupdate_script_priorities(vscript, true);\n\t\t\t\t}\n\t\t\t\tvscript->result = vscript->rise + vscript->fall - 1;\n\t\t\t}\n\t\t} else {\n\t\t\tif (vscript->result > vscript->rise) {\n\t\t\t\tvscript->result--;\n\t\t\t} else {\n\t\t\t\tif (vscript->result == vscript->rise ||\n\t\t\t\t    vscript->init_state == SCRIPT_INIT_STATE_INIT) {\n\t\t\t\t\tif (reason)\n\t\t\t\t\t\tlog_message(LOG_INFO, \"VRRP_Script(%s) %s (%s %d)\", vscript->sname, script_exit_type, reason, reason_code);\n\t\t\t\t\telse\n\t\t\t\t\t\tlog_message(LOG_INFO, \"VRRP_Script(%s) %s\", vscript->sname, script_exit_type);\n\t\t\t\t\tupdate_script_priorities(vscript, false);\n\t\t\t\t}\n\t\t\t\tvscript->result = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tvscript->state = SCRIPT_STATE_IDLE;\n\tvscript->init_state = SCRIPT_INIT_STATE_DONE;\n\n\treturn 0;\n}\n\n/* Delayed ARP/NA thread */\nint\nvrrp_arp_thread(thread_t *thread)\n{\n\telement e, a;\n\tlist l;\n\tip_address_t *ipaddress;\n\ttimeval_t next_time = {\n\t\t.tv_sec = INT_MAX\t/* We're never going to delay this long - I hope! */\n\t};\n\tinterface_t *ifp;\n\tvrrp_t *vrrp;\n\tenum {\n\t\tVIP,\n\t\tEVIP\n\t} i;\n\n\tset_time_now();\n\n\tfor (e = LIST_HEAD(vrrp_data->vrrp); e; ELEMENT_NEXT(e)) {\n\t\tvrrp = ELEMENT_DATA(e);\n\n\t\tif (!vrrp->garp_pending && !vrrp->gna_pending)\n\t\t\tcontinue;\n\n\t\tvrrp->garp_pending = false;\n\t\tvrrp->gna_pending = false;\n\n\t\tif (vrrp->state != VRRP_STATE_MAST ||\n\t\t    !vrrp->vipset)\n\t\t\tcontinue;\n\n\t\tfor (i = VIP; i <= EVIP; i++) {\n\t\t\tl = (i == VIP) ? vrrp->vip : vrrp->evip;\n\n\t\t\tif (!LIST_ISEMPTY(l)) {\n\t\t\t\tfor (a = LIST_HEAD(l); a; ELEMENT_NEXT(a)) {\n\t\t\t\t\tipaddress = ELEMENT_DATA(a);\n\t\t\t\t\tif (!ipaddress->garp_gna_pending)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (!ipaddress->set) {\n\t\t\t\t\t\tipaddress->garp_gna_pending = false;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tifp = IF_BASE_IFP(ipaddress->ifp);\n\n\t\t\t\t\t/* This should never happen */\n\t\t\t\t\tif (!ifp->garp_delay) {\n\t\t\t\t\t\tipaddress->garp_gna_pending = false;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!IP_IS6(ipaddress)) {\n\t\t\t\t\t\tif (timercmp(&time_now, &ifp->garp_delay->garp_next_time, >=)) {\n\t\t\t\t\t\t\tsend_gratuitous_arp_immediate(ifp, ipaddress);\n\t\t\t\t\t\t\tipaddress->garp_gna_pending = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tvrrp->garp_pending = true;\n\t\t\t\t\t\t\tif (timercmp(&ifp->garp_delay->garp_next_time, &next_time, <))\n\t\t\t\t\t\t\t\tnext_time = ifp->garp_delay->garp_next_time;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (timercmp(&time_now, &ifp->garp_delay->gna_next_time, >=)) {\n\t\t\t\t\t\t\tndisc_send_unsolicited_na_immediate(ifp, ipaddress);\n\t\t\t\t\t\t\tipaddress->garp_gna_pending = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tvrrp->gna_pending = true;\n\t\t\t\t\t\t\tif (timercmp(&ifp->garp_delay->gna_next_time, &next_time, <))\n\t\t\t\t\t\t\t\tnext_time = ifp->garp_delay->gna_next_time;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (next_time.tv_sec != INT_MAX) {\n\t\t/* Register next timer tracker */\n\t\tgarp_next_time = next_time;\n\n\t\tgarp_thread = thread_add_timer(thread->master, vrrp_arp_thread, NULL,\n\t\t\t\t\t\t timer_long(timer_sub_now(next_time)));\n\t}\n\telse\n\t\tgarp_thread = NULL;\n\n\treturn 0;\n}\n\n#ifdef _WITH_DUMP_THREADS_\nvoid\ndump_threads(void)\n{\n\tFILE *fp;\n\tchar time_buf[26];\n\telement e;\n\tvrrp_t *vrrp;\n\tchar *file_name;\n\n\tfile_name = make_file_name(\"/tmp/thread_dump.dat\",\n\t\t\t\t\t\"vrrp\",\n#if HAVE_DECL_CLONE_NEWNET\n\t\t\t\t\tglobal_data->network_namespace,\n#else\n\t\t\t\t\tNULL,\n#endif\n\t\t\t\t\tglobal_data->instance_name);\n\tfp = fopen(file_name, \"a\");\n\tFREE(file_name);\n\n\tset_time_now();\n\tctime_r(&time_now.tv_sec, time_buf);\n\n\tfprintf(fp, \"\\n%.19s.%6.6ld: Thread dump\\n\", time_buf, time_now.tv_usec);\n\n\tdump_thread_data(master, fp);\n\n\tfprintf(fp, \"alloc = %lu\\n\", master->alloc);\n\n\tfprintf(fp, \"\\n\");\n\tLIST_FOREACH(vrrp_data->vrrp, vrrp, e) {\n\t\tctime_r(&vrrp->sands.tv_sec, time_buf);\n\t\tfprintf(fp, \"VRRP instance %s, sands %.19s.%6.6lu, status %s\\n\", vrrp->iname, time_buf, vrrp->sands.tv_usec,\n\t\t\t\tvrrp->state == VRRP_STATE_INIT ? \"INIT\" :\n\t\t\t\tvrrp->state == VRRP_STATE_BACK ? \"BACKUP\" :\n\t\t\t\tvrrp->state == VRRP_STATE_MAST ? \"MASTER\" :\n\t\t\t\tvrrp->state == VRRP_STATE_FAULT ? \"FAULT\" :\n\t\t\t\tvrrp->state == VRRP_STATE_STOP ? \"STOP\" :\n\t\t\t\tvrrp->state == VRRP_DISPATCHER ? \"DISPATCHER\" : \"unknown\");\n\t}\n\tfclose(fp);\n}\n#endif\n\n#ifdef THREAD_DUMP\nvoid\nregister_vrrp_scheduler_addresses(void)\n{\n\tregister_thread_address(\"vrrp_arp_thread\", vrrp_arp_thread);\n\tregister_thread_address(\"vrrp_dispatcher_init\", vrrp_dispatcher_init);\n\tregister_thread_address(\"vrrp_gratuitous_arp_thread\", vrrp_gratuitous_arp_thread);\n\tregister_thread_address(\"vrrp_lower_prio_gratuitous_arp_thread\", vrrp_lower_prio_gratuitous_arp_thread);\n\tregister_thread_address(\"vrrp_script_child_thread\", vrrp_script_child_thread);\n\tregister_thread_address(\"vrrp_script_thread\", vrrp_script_thread);\n\tregister_thread_address(\"vrrp_read_dispatcher_thread\", vrrp_read_dispatcher_thread);\n#ifdef _WITH_BFD_\n\tregister_thread_address(\"vrrp_bfd_thread\", vrrp_bfd_thread);\n#endif\n}\n#endif\n", "/*\n * Soft:        Keepalived is a failover program for the LVS project\n *              <www.linuxvirtualserver.org>. It monitor & manipulate\n *              a loadbalanced server pool using multi-layer checks.\n *\n * Part:        logging facility.\n *\n * Author:      Alexandre Cassen, <acassen@linux-vs.org>\n *\n *              This program is distributed in the hope that it will be useful,\n *              but WITHOUT ANY WARRANTY; without even the implied warranty of\n *              MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n *              See the GNU General Public License for more details.\n *\n *              This program is free software; you can redistribute it and/or\n *              modify it under the terms of the GNU General Public License\n *              as published by the Free Software Foundation; either version\n *              2 of the License, or (at your option) any later version.\n *\n * Copyright (C) 2001-2017 Alexandre Cassen, <acassen@gmail.com>\n */\n\n#include \"config.h\"\n\n#include <stdio.h>\n#include <stdbool.h>\n#include <time.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <string.h>\n#include <memory.h>\n\n#include \"logger.h\"\n#include \"bitops.h\"\n#include \"utils.h\"\n\n/* Boolean flag - send messages to console as well as syslog */\nstatic bool log_console = false;\n\n/* File to write log messages to */\nchar *log_file_name;\nstatic FILE *log_file;\nbool always_flush_log_file;\n\nvoid\nenable_console_log(void)\n{\n\tlog_console = true;\n}\n\nvoid\nset_flush_log_file(void)\n{\n\talways_flush_log_file = true;\n}\n\nvoid\nclose_log_file(void)\n{\n\tif (log_file) {\n\t\tfclose(log_file);\n\t\tlog_file = NULL;\n\t}\n}\n\nvoid\nopen_log_file(const char *name, const char *prog, const char *namespace, const char *instance)\n{\n\tchar *file_name;\n\n\tif (log_file) {\n\t\tfclose(log_file);\n\t\tlog_file = NULL;\n\t}\n\n\tif (!name)\n\t\treturn;\n\n\tfile_name = make_file_name(name, prog, namespace, instance);\n\n\tlog_file = fopen(file_name, \"a\");\n\tif (log_file) {\n\t\tint n = fileno(log_file);\n\t\tfcntl(n, F_SETFD, FD_CLOEXEC | fcntl(n, F_GETFD));\n\t\tfcntl(n, F_SETFL, O_NONBLOCK | fcntl(n, F_GETFL));\n\t}\n\n\tFREE(file_name);\n}\n\nvoid\nflush_log_file(void)\n{\n\tif (log_file)\n\t\tfflush(log_file);\n}\n\nvoid\nvlog_message(const int facility, const char* format, va_list args)\n{\n#if !HAVE_VSYSLOG\n\tchar buf[MAX_LOG_MSG+1];\n\n\tvsnprintf(buf, sizeof(buf), format, args);\n#endif\n\n\t/* Don't write syslog if testing configuration */\n\tif (__test_bit(CONFIG_TEST_BIT, &debug))\n\t\treturn;\n\n\tif (log_file || (__test_bit(DONT_FORK_BIT, &debug) && log_console)) {\n#if HAVE_VSYSLOG\n\t\tva_list args1;\n\t\tchar buf[2 * MAX_LOG_MSG + 1];\n\n\t\tva_copy(args1, args);\n\t\tvsnprintf(buf, sizeof(buf), format, args1);\n\t\tva_end(args1);\n#endif\n\n\t\t/* timestamp setup */\n\t\ttime_t t = time(NULL);\n\t\tstruct tm tm;\n\t\tlocaltime_r(&t, &tm);\n\t\tchar timestamp[64];\n\t\tstrftime(timestamp, sizeof(timestamp), \"%c\", &tm);\n\n\t\tif (log_console && __test_bit(DONT_FORK_BIT, &debug))\n\t\t\tfprintf(stderr, \"%s: %s\\n\", timestamp, buf);\n\t\tif (log_file) {\n\t\t\tfprintf(log_file, \"%s: %s\\n\", timestamp, buf);\n\t\t\tif (always_flush_log_file)\n\t\t\t\tfflush(log_file);\n\t\t}\n\t}\n\n\tif (!__test_bit(NO_SYSLOG_BIT, &debug))\n#if HAVE_VSYSLOG\n\t\tvsyslog(facility, format, args);\n#else\n\t\tsyslog(facility, \"%s\", buf);\n#endif\n}\n\nvoid\nlog_message(const int facility, const char *format, ...)\n{\n\tva_list args;\n\n\tva_start(args, format);\n\tvlog_message(facility, format, args);\n\tva_end(args);\n}\n\nvoid\nconf_write(FILE *fp, const char *format, ...)\n{\n\tva_list args;\n\n\tva_start(args, format);\n\tif (fp) {\n\t\tvfprintf(fp, format, args);\n\t\tfprintf(fp, \"\\n\");\n\t}\n\telse\n\t\tvlog_message(LOG_INFO, format, args);\n\n\tva_end(args);\n}\n", "/*\n * Soft:        Keepalived is a failover program for the LVS project\n *              <www.linuxvirtualserver.org>. It monitor & manipulate\n *              a loadbalanced server pool using multi-layer checks.\n *\n * Part:        Memory management framework. This framework is used to\n *              find any memory leak.\n *\n * Authors:     Alexandre Cassen, <acassen@linux-vs.org>\n *              Jan Holmberg, <jan@artech.net>\n *\n *              This program is distributed in the hope that it will be useful,\n *              but WITHOUT ANY WARRANTY; without even the implied warranty of\n *              MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n *              See the GNU General Public License for more details.\n *\n *              This program is free software; you can redistribute it and/or\n *              modify it under the terms of the GNU General Public License\n *              as published by the Free Software Foundation; either version\n *              2 of the License, or (at your option) any later version.\n *\n * Copyright (C) 2001-2017 Alexandre Cassen, <acassen@gmail.com>\n */\n\n#include \"config.h\"\n\n#ifdef _MEM_CHECK_\n#include <assert.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <stdlib.h>\n#include <time.h>\n#include <limits.h>\n#endif\n\n#include <errno.h>\n#include <string.h>\n\n#include \"memory.h\"\n#include \"utils.h\"\n#include \"bitops.h\"\n#include \"logger.h\"\n\n#ifdef _MEM_CHECK_\n#include \"timer.h\"\n#include \"rbtree.h\"\n#include \"list_head.h\"\n\n/* Global var */\nsize_t mem_allocated;\t\t\t/* Total memory used in Bytes */\nstatic size_t max_mem_allocated;\t/* Maximum memory used in Bytes */\n\nstatic const char *terminate_banner;\t/* banner string for report file */\n\nstatic bool skip_mem_check_final;\n#endif\n\nstatic void *\nxalloc(unsigned long size)\n{\n\tvoid *mem = malloc(size);\n\n\tif (mem == NULL) {\n\t\tif (__test_bit(DONT_FORK_BIT, &debug))\n\t\t\tperror(\"Keepalived\");\n\t\telse\n\t\t\tlog_message(LOG_INFO, \"Keepalived xalloc() error - %s\", strerror(errno));\n\t\texit(EXIT_FAILURE);\n\t}\n\n#ifdef _MEM_CHECK_\n\tmem_allocated += size - sizeof(long);\n\tif (mem_allocated > max_mem_allocated)\n\t\tmax_mem_allocated = mem_allocated;\n#endif\n\n\treturn mem;\n}\n\nvoid *\nzalloc(unsigned long size)\n{\n\tvoid *mem = xalloc(size);\n\n\tif (mem)\n\t\tmemset(mem, 0, size);\n\n\treturn mem;\n}\n\n/* KeepAlived memory management. in debug mode,\n * help finding eventual memory leak.\n * Allocation memory types manipulated are :\n *\n * +-type------------------+-meaning------------------+\n * ! FREE_SLOT             ! Free slot                !\n * ! OVERRUN               ! Overrun                  !\n * ! FREE_NULL             ! free null                !\n * ! REALLOC_NULL          ! realloc null             !\n * ! DOUBLE_FREE           ! double free              !\n * ! REALLOC_DOUBLE_FREE   ! realloc freed block      !\n * ! FREE_NOT_ALLOC        ! Not previously allocated !\n * ! REALLOC_NOT_ALLOC     ! Not previously allocated !\n * ! MALLOC_ZERO_SIZE      ! malloc with size 0       !\n * ! REALLOC_ZERO_SIZE     ! realloc with size 0      !\n * ! LAST_FREE             ! Last free list           !\n * ! ALLOCATED             ! Allocated                !\n * +-----------------------+--------------------------+\n *\n * global variable debug bit MEM_ERR_DETECT_BIT used to\n * flag some memory error.\n *\n */\n\n#ifdef _MEM_CHECK_\n\nenum slot_type {\n\tFREE_SLOT = 0,\n\tOVERRUN,\n\tFREE_NULL,\n\tREALLOC_NULL,\n\tDOUBLE_FREE,\n\tREALLOC_DOUBLE_FREE,\n\tFREE_NOT_ALLOC,\n\tREALLOC_NOT_ALLOC,\n\tMALLOC_ZERO_SIZE,\n\tREALLOC_ZERO_SIZE,\n\tLAST_FREE,\n\tALLOCATED,\n} ;\n\n#define TIME_STR_LEN\t9\n\n#if ULONG_MAX == 0xffffffffffffffffUL\n#define CHECK_VAL\t0xa5a55a5aa5a55a5aUL\n#elif ULONG_MAX == 0xffffffffUL\n#define CHECK_VAL\t0xa5a55a5aUL\n#else\n#define CHECK_VAL\t0xa5a5\n#endif\n\n#define FREE_LIST_SIZE\t256\n\ntypedef struct {\n\tenum slot_type type;\n\tint line;\n\tconst char *func;\n\tconst char *file;\n\tvoid *ptr;\n\tsize_t size;\n\tunion {\n\t\tlist_head_t l;\t/* When on free list */\n\t\trb_node_t t;\n\t};\n\tunsigned seq_num;\n} MEMCHECK;\n\n/* Last free pointers */\nstatic LH_LIST_HEAD(free_list);\nstatic unsigned free_list_size;\n\n/* alloc_list entries used for 1000 VRRP instance each with VMAC interfaces is 33589 */\nstatic rb_root_t alloc_list = RB_ROOT;\nstatic LH_LIST_HEAD(bad_list);\n\nstatic unsigned number_alloc_list;\t/* number of alloc_list allocation entries */\nstatic unsigned max_alloc_list;\nstatic unsigned num_mallocs;\nstatic unsigned num_reallocs;\nstatic unsigned seq_num;\n\nstatic FILE *log_op = NULL;\n\nstatic inline int\nmemcheck_ptr_cmp(MEMCHECK *m1, MEMCHECK *m2)\n{\n\treturn m1->ptr - m2->ptr;\n}\n\nstatic inline int\nmemcheck_seq_cmp(MEMCHECK *m1, MEMCHECK *m2)\n{\n\treturn m1->seq_num - m2->seq_num;\n}\n\nstatic const char *\nformat_time(void)\n{\n\tstatic char time_buf[TIME_STR_LEN+1];\n\n\tstrftime(time_buf, sizeof time_buf, \"%T \", localtime(&time_now.tv_sec));\n\n\treturn time_buf;\n}\n\nvoid\nmemcheck_log(const char *called_func, const char *param, const char *file, const char *function, int line)\n{\n\tint len = strlen(called_func) + (param ? strlen(param) : 0);\n\n\tif ((len = 36 - len) < 0)\n\t\tlen = 0;\n\n\tfprintf(log_op, \"%s%*s%s(%s) at %s, %d, %s\\n\",\n\t       format_time(), len, \"\", called_func, param ? param : \"\", file, line, function);\n}\n\nstatic MEMCHECK *\nget_free_alloc_entry(void)\n{\n\tMEMCHECK *entry;\n\n\t/* If number on free list < 256, allocate new entry, otherwise take head */\n\tif (free_list_size < 256)\n\t\tentry = malloc(sizeof *entry);\n\telse {\n\t\tentry = list_first_entry(&free_list, MEMCHECK, l);\n\t\tlist_head_del(&entry->l);\n\t\tfree_list_size--;\n\t}\n\n\tentry->seq_num = seq_num++;\n\n\treturn entry;\n}\n\nvoid *\nkeepalived_malloc(size_t size, const char *file, const char *function, int line)\n{\n\tvoid *buf;\n\tMEMCHECK *entry, *entry2;\n\n\tbuf = zalloc(size + sizeof (unsigned long));\n\n\t*(unsigned long *) ((char *) buf + size) = size + CHECK_VAL;\n\n\tentry = get_free_alloc_entry();\n\n\tentry->ptr = buf;\n\tentry->size = size;\n\tentry->file = file;\n\tentry->func = function;\n\tentry->line = line;\n\tentry->type = ALLOCATED;\n\n\trb_insert_sort(&alloc_list, entry, t, memcheck_ptr_cmp);\n\tif (++number_alloc_list > max_alloc_list)\n\t\tmax_alloc_list = number_alloc_list;\n\n\tfprintf(log_op, \"%szalloc [%3d:%3d], %9p, %4zu at %s, %3d, %s%s\\n\",\n\t       format_time(), entry->seq_num, number_alloc_list, buf, size, file, line, function, !size ? \" - size is 0\" : \"\");\n#ifdef _MEM_CHECK_LOG_\n\tif (__test_bit(MEM_CHECK_LOG_BIT, &debug))\n\t\tlog_message(LOG_INFO, \"zalloc[%3d:%3d], %9p, %4zu at %s, %3d, %s\",\n\t\t       entry->seq_num, number_alloc_list, buf, size, file, line, function);\n#endif\n\n\tnum_mallocs++;\n\n\tif (!size) {\n\t\t/* Record malloc with 0 size */\n\t\tentry2 = get_free_alloc_entry();\n\t\t*entry2 = *entry;\n\t\tentry2->type = MALLOC_ZERO_SIZE;\n\t\tlist_add_tail(&entry2->l, &bad_list);\n\t}\n\n\treturn buf;\n}\n\nstatic void *\nkeepalived_free_realloc_common(void *buffer, size_t size, const char *file, const char *function, int line, bool is_realloc)\n{\n\tunsigned long check;\n\tMEMCHECK *entry, *entry2, *le;\n\tMEMCHECK search = {.ptr = buffer};\n\n\t/* If nullpointer remember */\n\tif (buffer == NULL) {\n\t\tentry = get_free_alloc_entry();\n\n\t\tentry->ptr = NULL;\n\t\tentry->size = size;\n\t\tentry->file = file;\n\t\tentry->func = function;\n\t\tentry->line = line;\n\t\tentry->type = !size ? FREE_NULL : REALLOC_NULL;\n\n\t\tif (!is_realloc)\n\t\t\tfprintf(log_op, \"%s%-7s%9s, %9s, %4s at %s, %3d, %s\\n\", format_time(),\n\t\t\t\t\"free\", \"ERROR\", \"NULL\", \"\",\n\t\t\t\tfile, line, function);\n\t\telse\n\t\t\tfprintf(log_op, \"%s%-7s%9s, %9s, %4zu at %s, %3d, %s%s\\n\", format_time(),\n\t\t\t\t\"realloc\", \"ERROR\", \"NULL\",\n\t\t\t\tsize, file, line, function, size ? \" *** converted to malloc\" : \"\");\n\n\t\t__set_bit(MEM_ERR_DETECT_BIT, &debug);\n\n\t\tlist_add_tail(&entry->l, &bad_list);\n\n\t\treturn !size ? NULL : keepalived_malloc(size, file, function, line);\n\t}\n\n\tentry = rb_search(&alloc_list, &search, t, memcheck_ptr_cmp);\n\n\t/* Not found */\n\tif (!entry) {\n\t\tentry = get_free_alloc_entry();\n\n\t\tentry->ptr = buffer;\n\t\tentry->size = size;\n\t\tentry->file = file;\n\t\tentry->func = function;\n\t\tentry->line = line;\n\t\tentry->type = !size ? FREE_NOT_ALLOC : REALLOC_NOT_ALLOC;\n\t\tentry->seq_num = seq_num++;\n\n\t\tif (!is_realloc)\n\t\t\tfprintf(log_op, \"%s%-7s%9s, %9p,      at %s, %3d, %s - not found\\n\", format_time(),\n\t\t\t\t\"free\", \"ERROR\",\n\t\t\t\tbuffer, file, line, function);\n\t\telse\n\t\t\tfprintf(log_op, \"%s%-7s%9s, %9p, %4zu at %s, %3d, %s - not found\\n\", format_time(),\n\t\t\t\t\"realloc\", \"ERROR\",\n\t\t\t\tbuffer, size, file, line, function);\n\n\t\t__set_bit(MEM_ERR_DETECT_BIT, &debug);\n\n\t\tlist_for_each_entry_reverse(le, &free_list, l) {\n\t\t\tif (le->ptr == buffer &&\n\t\t\t    le->type == LAST_FREE) {\n\t\t\t\tfprintf\n\t\t\t\t    (log_op, \"%11s-> pointer last released at [%3d:%3d], at %s, %3d, %s\\n\",\n\t\t\t\t     \"\", le->seq_num, number_alloc_list,\n\t\t\t\t     le->file, le->line,\n\t\t\t\t     le->func);\n\n\t\t\t\tentry->type = !size ? DOUBLE_FREE : REALLOC_DOUBLE_FREE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t};\n\n\t\tlist_add_tail(&entry->l, &bad_list);\n\n\t\treturn NULL;\n\t}\n\n\tcheck = entry->size + CHECK_VAL;\n\tif (*(unsigned long *)((char *)buffer + entry->size) != check) {\n\t\tentry2 = get_free_alloc_entry();\n\n\t\t*entry2 = *entry;\n\t\tentry2->type = OVERRUN;\n\t\tlist_add_tail(&entry2->l, &bad_list);\n\n\t\tfprintf(log_op, \"%s%s corrupt, buffer overrun [%3d:%3d], %9p, %4zu at %s, %3d, %s\\n\",\n\t\t       format_time(), !is_realloc ? \"free\" : \"realloc\",\n\t\t       entry->seq_num, number_alloc_list, buffer,\n\t\t       entry->size, file,\n\t\t       line, function);\n\t\tdump_buffer(entry->ptr,\n\t\t\t    entry->size + sizeof (check), log_op, TIME_STR_LEN);\n\t\tfprintf(log_op, \"%*sCheck_sum\\n\", TIME_STR_LEN, \"\");\n\t\tdump_buffer((char *) &check,\n\t\t\t    sizeof(check), log_op, TIME_STR_LEN);\n\n\t\t__set_bit(MEM_ERR_DETECT_BIT, &debug);\n\t}\n\n\tmem_allocated -= entry->size;\n\n\tif (!size) {\n\t\tfree(buffer);\n\n\t\tif (is_realloc) {\n\t\t\tfprintf(log_op, \"%s%-7s[%3d:%3d], %9p, %4zu at %s, %3d, %s -> %9s, %4s at %s, %3d, %s\\n\",\n\t\t\t       format_time(), \"realloc\", entry->seq_num,\n\t\t\t       number_alloc_list, entry->ptr,\n\t\t\t       entry->size, entry->file,\n\t\t\t       entry->line, entry->func,\n\t\t\t       \"made free\", \"\", file, line, function);\n\n\t\t\t/* Record bad realloc */\n\t\t\tentry2 = get_free_alloc_entry();\n\t\t\t*entry2 = *entry;\n\t\t\tentry2->type = REALLOC_ZERO_SIZE;\n\t\t\tentry2->file = file;\n\t\t\tentry2->line = line;\n\t\t\tentry2->func = function;\n\t\t\tlist_add_tail(&entry2->l, &bad_list);\n\t\t}\n\t\telse\n\t\t\tfprintf(log_op, \"%s%-7s[%3d:%3d], %9p, %4zu at %s, %3d, %s -> %9s, %4s at %s, %3d, %s\\n\",\n\t\t\t       format_time(), \"free\", entry->seq_num,\n\t\t\t       number_alloc_list, entry->ptr,\n\t\t\t       entry->size, entry->file,\n\t\t\t       entry->line, entry->func,\n\t\t\t       \"NULL\", \"\", file, line, function);\n#ifdef _MEM_CHECK_LOG_\n\t\tif (__test_bit(MEM_CHECK_LOG_BIT, &debug))\n\t\t\tlog_message(LOG_INFO, \"%-7s[%3d:%3d], %9p, %4zu at %s, %3d, %s\",\n\t\t\t       is_realloc ? \"realloc\" : \"free\",\n\t\t\t       entry->seq_num, number_alloc_list, buffer,\n\t\t\t       entry->size, file, line, function);\n#endif\n\n\t\tentry->file = file;\n\t\tentry->line = line;\n\t\tentry->func = function;\n\t\tentry->type = LAST_FREE;\n\n\t\trb_erase(&entry->t, &alloc_list);\n\t\tlist_add_tail(&entry->l, &free_list);\n\t\tfree_list_size++;\n\n\t\tnumber_alloc_list--;\n\n\t\treturn NULL;\n\t}\n\n\tbuffer = realloc(buffer, size + sizeof (unsigned long));\n\tmem_allocated += size;\n\n\tif (mem_allocated > max_mem_allocated)\n\t\tmax_mem_allocated = mem_allocated;\n\n\tfprintf(log_op, \"%srealloc[%3d:%3d], %9p, %4zu at %s, %3d, %s -> %9p, %4zu at %s, %3d, %s\\n\",\n\t       format_time(), entry->seq_num,\n\t       number_alloc_list, entry->ptr,\n\t       entry->size, entry->file,\n\t       entry->line, entry->func,\n\t       buffer, size, file, line, function);\n#ifdef _MEM_CHECK_LOG_\n\tif (__test_bit(MEM_CHECK_LOG_BIT, &debug))\n\t\tlog_message(LOG_INFO, \"realloc[%3d:%3d], %9p, %4zu at %s, %3d, %s -> %9p, %4zu at %s, %3d, %s\",\n\t\t       entry->seq_num, number_alloc_list, entry->ptr,\n\t\t       entry->size, entry->file,\n\t\t       entry->line, entry->func,\n\t\t       buffer, size, file, line, function);\n#endif\n\n\t*(unsigned long *) ((char *) buffer + size) = size + CHECK_VAL;\n\n\tif (entry->ptr != buffer) {\n\t\trb_erase(&entry->t, &alloc_list);\n\t\tentry->ptr = buffer;\n\t\trb_insert_sort(&alloc_list, entry, t, memcheck_ptr_cmp);\n\t} else\n\t\tentry->ptr = buffer;\n\tentry->size = size;\n\tentry->file = file;\n\tentry->line = line;\n\tentry->func = function;\n\n\tnum_reallocs++;\n\n\treturn buffer;\n}\n\nvoid\nkeepalived_free(void *buffer, const char *file, const char *function, int line)\n{\n\tkeepalived_free_realloc_common(buffer, 0, file, function, line, false);\n}\n\nvoid *\nkeepalived_realloc(void *buffer, size_t size, const char *file,\n\t\t   const char *function, int line)\n{\n\treturn keepalived_free_realloc_common(buffer, size, file, function, line, true);\n}\n\nstatic void\nkeepalived_alloc_log(bool final)\n{\n\tunsigned int overrun = 0, badptr = 0, zero_size = 0;\n\tsize_t sum = 0;\n\tMEMCHECK *entry;\n\n\tif (final) {\n\t\t/* If this is a forked child, we don't want the dump */\n\t\tif (skip_mem_check_final)\n\t\t\treturn;\n\n\t\tfprintf(log_op, \"\\n---[ Keepalived memory dump for (%s) ]---\\n\\n\", terminate_banner);\n\t}\n\telse\n\t\tfprintf(log_op, \"\\n---[ Keepalived memory dump for (%s) at %s ]---\\n\\n\", terminate_banner, format_time());\n\n\t/* List the blocks currently allocated */\n\tif (!RB_EMPTY_ROOT(&alloc_list)) {\n\t\tfprintf(log_op, \"Entries %s\\n\\n\", final ? \"not released\" : \"currently allocated\");\n\t\trb_for_each_entry(entry, &alloc_list, t) {\n\t\t\tsum += entry->size;\n\t\t\tfprintf(log_op, \"%9p [%3d:%3d], %4zu at %s, %3d, %s\",\n\t\t\t       entry->ptr, entry->seq_num, number_alloc_list,\n\t\t\t       entry->size, entry->file, entry->line, entry->func);\n\t\t\tif (entry->type != ALLOCATED)\n\t\t\t\tfprintf(log_op, \" type = %d\", entry->type);\n\t\t\tfprintf(log_op, \"\\n\");\n\t\t}\n\t}\n\n\tif (!list_empty(&bad_list)) {\n\t\tif (!RB_EMPTY_ROOT(&alloc_list))\n\t\t\tfprintf(log_op, \"\\n\");\n\t\tfprintf(log_op, \"Bad entry list\\n\\n\");\n\n\t\tlist_for_each_entry(entry, &bad_list, l) {\n\t\t\tswitch (entry->type) {\n\t\t\tcase FREE_NULL:\n\t\t\t\tbadptr++;\n\t\t\t\tfprintf(log_op, \"%9s %9s, %4s at %s, %3d, %s - null pointer to free\\n\",\n\t\t\t\t       \"NULL\", \"\", \"\", entry->file, entry->line, entry->func);\n\t\t\t\tbreak;\n\t\t\tcase REALLOC_NULL:\n\t\t\t\tbadptr++;\n\t\t\t\tfprintf(log_op, \"%9s %9s, %4zu at %s, %3d, %s - null pointer to realloc (converted to malloc)\\n\",\n\t\t\t\t     \"NULL\", \"\", entry->size, entry->file, entry->line, entry->func);\n\t\t\t\tbreak;\n\t\t\tcase FREE_NOT_ALLOC:\n\t\t\t\tbadptr++;\n\t\t\t\tfprintf(log_op, \"%9p %9s, %4s at %s, %3d, %s - pointer not found for free\\n\",\n\t\t\t\t     entry->ptr, \"\", \"\", entry->file, entry->line, entry->func);\n\t\t\t\tbreak;\n\t\t\tcase REALLOC_NOT_ALLOC:\n\t\t\t\tbadptr++;\n\t\t\t\tfprintf(log_op, \"%9p %9s, %4zu at %s, %3d, %s - pointer not found for realloc\\n\",\n\t\t\t\t     entry->ptr, \"\", entry->size, entry->file, entry->line, entry->func);\n\t\t\t\tbreak;\n\t\t\tcase DOUBLE_FREE:\n\t\t\t\tbadptr++;\n\t\t\t\tfprintf(log_op, \"%9p %9s, %4s at %s, %3d, %s - double free of pointer\\n\",\n\t\t\t\t     entry->ptr, \"\", \"\", entry->file, entry->line, entry->func);\n\t\t\t\tbreak;\n\t\t\tcase REALLOC_DOUBLE_FREE:\n\t\t\t\tbadptr++;\n\t\t\t\tfprintf(log_op, \"%9p %9s, %4zu at %s, %3d, %s - realloc 0 size already freed\\n\",\n\t\t\t\t     entry->ptr, \"\", entry->size, entry->file, entry->line, entry->func);\n\t\t\t\tbreak;\n\t\t\tcase OVERRUN:\n\t\t\t\toverrun++;\n\t\t\t\tfprintf(log_op, \"%9p [%3d:%3d], %4zu at %s, %3d, %s - buffer overrun\\n\",\n\t\t\t\t       entry->ptr, entry->seq_num, number_alloc_list,\n\t\t\t\t       entry->size, entry->file, entry->line, entry->func);\n\t\t\t\tbreak;\n\t\t\tcase MALLOC_ZERO_SIZE:\n\t\t\t\tzero_size++;\n\t\t\t\tfprintf(log_op, \"%9p [%3d:%3d], %4zu at %s, %3d, %s - malloc zero size\\n\",\n\t\t\t\t       entry->ptr, entry->seq_num, number_alloc_list,\n\t\t\t\t       entry->size, entry->file, entry->line, entry->func);\n\t\t\t\tbreak;\n\t\t\tcase REALLOC_ZERO_SIZE:\n\t\t\t\tzero_size++;\n\t\t\t\tfprintf(log_op, \"%9p [%3d:%3d], %4zu at %s, %3d, %s - realloc zero size (handled as free)\\n\",\n\t\t\t\t       entry->ptr, entry->seq_num, number_alloc_list,\n\t\t\t\t       entry->size, entry->file, entry->line, entry->func);\n\t\t\t\tbreak;\n\t\t\tcase ALLOCATED:\t/* not used - avoid compiler warning */\n\t\t\tcase FREE_SLOT:\n\t\t\tcase LAST_FREE:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tfprintf(log_op, \"\\n\\n---[ Keepalived memory dump summary for (%s) ]---\\n\", terminate_banner);\n\tfprintf(log_op, \"Total number of bytes %s...: %zu\\n\", final ? \"not freed\" : \"allocated\", sum);\n\tfprintf(log_op, \"Number of entries %s.......: %d\\n\", final ? \"not freed\" : \"allocated\", number_alloc_list);\n\tfprintf(log_op, \"Maximum allocated entries.........: %d\\n\", max_alloc_list);\n\tfprintf(log_op, \"Maximum memory allocated..........: %zu\\n\", max_mem_allocated);\n\tfprintf(log_op, \"Number of mallocs.................: %d\\n\", num_mallocs);\n\tfprintf(log_op, \"Number of reallocs................: %d\\n\", num_reallocs);\n\tfprintf(log_op, \"Number of bad entries.............: %d\\n\", badptr);\n\tfprintf(log_op, \"Number of buffer overrun..........: %d\\n\", overrun);\n\tfprintf(log_op, \"Number of 0 size allocations......: %d\\n\\n\", zero_size);\n\tif (sum != mem_allocated)\n\t\tfprintf(log_op, \"ERROR - sum of allocated %zu != mem_allocated %zu\\n\", sum, mem_allocated);\n\n\tif (final) {\n\t\tif (sum || number_alloc_list || badptr || overrun)\n\t\t\tfprintf(log_op, \"=> Program seems to have some memory problem !!!\\n\\n\");\n\t\telse\n\t\t\tfprintf(log_op, \"=> Program seems to be memory allocation safe...\\n\\n\");\n\t}\n}\n\nstatic void\nkeepalived_free_final(void)\n{\n\tkeepalived_alloc_log(true);\n}\n\nvoid\nkeepalived_alloc_dump(void)\n{\n\tkeepalived_alloc_log(false);\n}\n\nvoid\nmem_log_init(const char* prog_name, const char *banner)\n{\n\tsize_t log_name_len;\n\tchar *log_name;\n\n\tif (__test_bit(LOG_CONSOLE_BIT, &debug)) {\n\t\tlog_op = stderr;\n\t\treturn;\n\t}\n\n\tif (log_op)\n\t\tfclose(log_op);\n\n\tlog_name_len = 5 + strlen(prog_name) + 5 + 7 + 4 + 1;\t/* \"/tmp/\" + prog_name + \"_mem.\" + PID + \".log\" + '\\0\" */\n\tlog_name = malloc(log_name_len);\n\tif (!log_name) {\n\t\tlog_message(LOG_INFO, \"Unable to malloc log file name\");\n\t\tlog_op = stderr;\n\t\treturn;\n\t}\n\n\tsnprintf(log_name, log_name_len, \"/tmp/%s_mem.%d.log\", prog_name, getpid());\n\tlog_op = fopen(log_name, \"a\");\n\tif (log_op == NULL) {\n\t\tlog_message(LOG_INFO, \"Unable to open %s for appending\", log_name);\n\t\tlog_op = stderr;\n\t}\n\telse {\n\t\tint fd = fileno(log_op);\n\n\t\t/* We don't want any children to inherit the log file */\n\t\tfcntl(fd, F_SETFD, fcntl(fd, F_GETFD) | FD_CLOEXEC);\n\n\t\t/* Make the log output line buffered. This was to ensure that\n\t\t * children didn't inherit the buffer, but the CLOEXEC above\n\t\t * should resolve that. */\n\t\tsetlinebuf(log_op);\n\n\t\tfprintf(log_op, \"\\n\");\n\t}\n\n\tfree(log_name);\n\n\tterminate_banner = banner;\n}\n\nvoid skip_mem_dump(void)\n{\n\tskip_mem_check_final = true;\n}\n\nvoid enable_mem_log_termination(void)\n{\n\tatexit(keepalived_free_final);\n}\n#endif\n", "/*\n * Soft:        Keepalived is a failover program for the LVS project\n *              <www.linuxvirtualserver.org>. It monitor & manipulate\n *              a loadbalanced server pool using multi-layer checks.\n *\n * Part:        Forked system call to launch an extra script.\n *\n * Author:      Alexandre Cassen, <acassen@linux-vs.org>\n *\n *              This program is distributed in the hope that it will be useful,\n *              but WITHOUT ANY WARRANTY; without even the implied warranty of\n *              MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n *              See the GNU General Public License for more details.\n *\n *              This program is free software; you can redistribute it and/or\n *              modify it under the terms of the GNU General Public License\n *              as published by the Free Software Foundation; either version\n *              2 of the License, or (at your option) any later version.\n *\n * Copyright (C) 2001-2017 Alexandre Cassen, <acassen@gmail.com>\n */\n\n#include \"config.h\"\n\n#include <unistd.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <signal.h>\n#include <grp.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <pwd.h>\n#include <sys/resource.h>\n#include <limits.h>\n#include <sys/prctl.h>\n\n#include \"notify.h\"\n#include \"signals.h\"\n#include \"logger.h\"\n#include \"utils.h\"\n#include \"process.h\"\n#include \"parser.h\"\n#include \"keepalived_magic.h\"\n#include \"scheduler.h\"\n\n/* Default user/group for script execution */\nuid_t default_script_uid;\ngid_t default_script_gid;\n\n/* Have we got a default user OK? */\nstatic bool default_script_uid_set = false;\nstatic bool default_user_fail = false;\t\t\t/* Set if failed to set default user,\n\t\t\t\t\t\t\t   unless it defaults to root */\n\n/* Script security enabled */\nbool script_security = false;\n\n/* Buffer length needed for getpwnam_r/getgrname_r */\nstatic size_t getpwnam_buf_len;\n\nstatic char *path;\nstatic bool path_is_malloced;\n\n/* The priority this process is running at */\nstatic int cur_prio = INT_MAX;\n\n/* Buffer for expanding notify script commands */\nstatic char cmd_str_buf[MAXBUF];\n\nstatic bool\nset_privileges(uid_t uid, gid_t gid)\n{\n\tint retval;\n\n\t/* Ensure we receive SIGTERM if our parent process dies */\n\tprctl(PR_SET_PDEATHSIG, SIGTERM);\n\n\t/* If we have increased our priority, set it to default for the script */\n\tif (cur_prio != INT_MAX)\n\t\tcur_prio = getpriority(PRIO_PROCESS, 0);\n\tif (cur_prio < 0)\n\t\tsetpriority(PRIO_PROCESS, 0, 0);\n\n\t/* Drop our privileges if configured */\n\tif (gid) {\n\t\tretval = setgid(gid);\n\t\tif (retval < 0) {\n\t\t\tlog_message(LOG_ALERT, \"Couldn't setgid: %d (%m)\", gid);\n\t\t\treturn true;\n\t\t}\n\n\t\t/* Clear any extra supplementary groups */\n\t\tretval = setgroups(1, &gid);\n\t\tif (retval < 0) {\n\t\t\tlog_message(LOG_ALERT, \"Couldn't setgroups: %d (%m)\", gid);\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tif (uid) {\n\t\tretval = setuid(uid);\n\t\tif (retval < 0) {\n\t\t\tlog_message(LOG_ALERT, \"Couldn't setuid: %d (%m)\", uid);\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t/* Prepare for invoking process/script */\n\tsignal_handler_script();\n\tset_std_fd(false);\n\n\treturn false;\n}\n\nchar *\ncmd_str_r(const notify_script_t *script, char *buf, size_t len)\n{\n\tchar *str_p;\n\tint i;\n\tsize_t str_len;\n\n\tstr_p = buf;\n\n\tfor (i = 0; i < script->num_args; i++) {\n\t\t/* Check there is enough room for the next word */\n\t\tstr_len = strlen(script->args[i]);\n\t\tif (str_p + str_len + 2 + (i ? 1 : 0) >= buf + len)\n\t\t\treturn NULL;\n\n\t\tif (i)\n\t\t\t*str_p++ = ' ';\n\t\t*str_p++ = '\\'';\n\t\tstrcpy(str_p, script->args[i]);\n\t\tstr_p += str_len;\n\t\t*str_p++ = '\\'';\n\t}\n\t*str_p = '\\0';\n\n\treturn buf;\n}\n\nchar *\ncmd_str(const notify_script_t *script)\n{\n\tsize_t len;\n\tint i;\n\n\tfor (i = 0, len = 0; i < script->num_args; i++)\n\t\tlen += strlen(script->args[i]) + 3; /* Add two ', and trailing space (or null for last arg) */\n\n\tif (len > sizeof cmd_str_buf)\n\t\treturn NULL;\n\n\treturn cmd_str_r(script, cmd_str_buf, sizeof cmd_str_buf);\n}\n\n/* Execute external script/program to process FIFO */\nstatic pid_t\nnotify_fifo_exec(thread_master_t *m, int (*func) (thread_t *), void *arg, notify_script_t *script)\n{\n\tpid_t pid;\n\tint retval;\n\tchar *scr;\n\n\tpid = local_fork();\n\n\t/* In case of fork is error. */\n\tif (pid < 0) {\n\t\tlog_message(LOG_INFO, \"Failed fork process\");\n\t\treturn -1;\n\t}\n\n\t/* In case of this is parent process */\n\tif (pid) {\n\t\tthread_add_child(m, func, arg, pid, TIMER_NEVER);\n\t\treturn 0;\n\t}\n\n#ifdef _MEM_CHECK_\n\tskip_mem_dump();\n#endif\n\n\tsetpgid(0, 0);\n\tset_privileges(script->uid, script->gid);\n\n\tif (script->flags | SC_EXECABLE) {\n\t\t/* If keepalived dies, we want the script to die */\n\t\tprctl(PR_SET_PDEATHSIG, SIGTERM);\n\n\t\texecve(script->args[0], script->args, environ);\n\n\t\tif (errno == EACCES)\n\t\t\tlog_message(LOG_INFO, \"FIFO notify script %s is not executable\", script->args[0]);\n\t\telse\n\t\t\tlog_message(LOG_INFO, \"Unable to execute FIFO notify script %s - errno %d - %m\", script->args[0], errno);\n\t}\n\telse {\n\t\tretval = system(scr = cmd_str(script));\n\n\t\tif (retval == 127) {\n\t\t\t/* couldn't exec command */\n\t\t\tlog_message(LOG_ALERT, \"Couldn't exec FIFO command: %s\", scr);\n\t\t}\n\t\telse if (retval == -1)\n\t\t\tlog_message(LOG_ALERT, \"Error exec-ing FIFO command: %s\", scr);\n\n\t\texit(0);\n\t}\n\n\t/* unreached unless error */\n\texit(0);\n}\n\nstatic void\nfifo_open(notify_fifo_t* fifo, int (*script_exit)(thread_t *), const char *type)\n{\n\tint ret;\n\tint sav_errno;\n\n\tif (fifo->name) {\n\t\tsav_errno = 0;\n\n\t\tif (!(ret = mkfifo(fifo->name, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)))\n\t\t\tfifo->created_fifo = true;\n\t\telse {\n\t\t\tsav_errno = errno;\n\n\t\t\tif (sav_errno != EEXIST)\n\t\t\t\tlog_message(LOG_INFO, \"Unable to create %snotify fifo %s\", type, fifo->name);\n\t\t}\n\n\t\tif (!sav_errno || sav_errno == EEXIST) {\n\t\t\t/* Run the notify script if there is one */\n\t\t\tif (fifo->script)\n\t\t\t\tnotify_fifo_exec(master, script_exit, fifo, fifo->script);\n\n\t\t\t/* Now open the fifo */\n\t\t\tif ((fifo->fd = open(fifo->name, O_RDWR | O_CLOEXEC | O_NONBLOCK)) == -1) {\n\t\t\t\tlog_message(LOG_INFO, \"Unable to open %snotify fifo %s - errno %d\", type, fifo->name, errno);\n\t\t\t\tif (fifo->created_fifo) {\n\t\t\t\t\tunlink(fifo->name);\n\t\t\t\t\tfifo->created_fifo = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (fifo->fd == -1) {\n\t\t\tFREE(fifo->name);\n\t\t\tfifo->name = NULL;\n\t\t}\n\t}\n}\n\nvoid\nnotify_fifo_open(notify_fifo_t* global_fifo, notify_fifo_t* fifo, int (*script_exit)(thread_t *), const char *type)\n{\n\t/* Open the global FIFO if specified */\n\tif (global_fifo->name)\n\t\tfifo_open(global_fifo, script_exit, \"\");\n\n\t/* Now the specific FIFO */\n\tif (fifo->name)\n\t\tfifo_open(fifo, script_exit, type);\n}\n\nstatic void\nfifo_close(notify_fifo_t* fifo)\n{\n\tif (fifo->fd != -1) {\n\t\tclose(fifo->fd);\n\t\tfifo->fd = -1;\n\t}\n\tif (fifo->created_fifo)\n\t\tunlink(fifo->name);\n}\n\nvoid\nnotify_fifo_close(notify_fifo_t* global_fifo, notify_fifo_t* fifo)\n{\n\tif (global_fifo->fd != -1)\n\t\tfifo_close(global_fifo);\n\n\tfifo_close(fifo);\n}\n\n/* perform a system call */\nstatic void system_call(const notify_script_t *) __attribute__ ((noreturn));\n\nstatic void\nsystem_call(const notify_script_t* script)\n{\n\tchar *command_line = NULL;\n\tchar *str;\n\tint retval;\n\n\tif (set_privileges(script->uid, script->gid))\n\t\texit(0);\n\n\t/* Move us into our own process group, so if the script needs to be killed\n\t * all its child processes will also be killed. */\n\tsetpgid(0, 0);\n\n\tif (script->flags & SC_EXECABLE) {\n\t\t/* If keepalived dies, we want the script to die */\n\t\tprctl(PR_SET_PDEATHSIG, SIGTERM);\n\n\t\texecve(script->args[0], script->args, environ);\n\n\t\t/* error */\n\t\tlog_message(LOG_ALERT, \"Error exec-ing command '%s', error %d: %m\", script->args[0], errno);\n\t}\n\telse {\n\t\tretval = system(str = cmd_str(script));\n\n\t\tif (retval == -1)\n\t\t\tlog_message(LOG_ALERT, \"Error exec-ing command: %s\", str);\n\t\telse if (WIFEXITED(retval)) {\n\t\t\tif (WEXITSTATUS(retval) == 127) {\n\t\t\t\t/* couldn't find command */\n\t\t\t\tlog_message(LOG_ALERT, \"Couldn't find command: %s\", str);\n\t\t\t}\n\t\t\telse if (WEXITSTATUS(retval) == 126) {\n\t\t\t\t/* couldn't find command */\n\t\t\t\tlog_message(LOG_ALERT, \"Couldn't execute command: %s\", str);\n\t\t\t}\n\t\t}\n\n\t\tif (command_line)\n\t\t\tFREE(command_line);\n\n\t\tif (retval == -1 ||\n\t\t    (WIFEXITED(retval) && (WEXITSTATUS(retval) == 126 || WEXITSTATUS(retval) == 127)))\n\t\t\texit(0);\n\t\tif (WIFEXITED(retval))\n\t\t\texit(WEXITSTATUS(retval));\n\t\tif (WIFSIGNALED(retval))\n\t\t\tkill(getpid(), WTERMSIG(retval));\n\t\texit(0);\n\t}\n\n\texit(0);\n}\n\n/* Execute external script/program */\nint\nnotify_exec(const notify_script_t *script)\n{\n\tpid_t pid;\n\n\tif (log_file_name)\n\t\tflush_log_file();\n\n\tpid = local_fork();\n\n\tif (pid < 0) {\n\t\t/* fork error */\n\t\tlog_message(LOG_INFO, \"Failed fork process\");\n\t\treturn -1;\n\t}\n\n\tif (pid) {\n\t\t/* parent process */\n\t\treturn 0;\n\t}\n\n#ifdef _MEM_CHECK_\n\tskip_mem_dump();\n#endif\n\n\tsystem_call(script);\n\n\t/* We should never get here */\n\texit(0);\n}\n\nint\nsystem_call_script(thread_master_t *m, int (*func) (thread_t *), void * arg, unsigned long timer, notify_script_t* script)\n{\n\tpid_t pid;\n\n\t/* Daemonization to not degrade our scheduling timer */\n\tif (log_file_name)\n\t\tflush_log_file();\n\n\tpid = local_fork();\n\n\tif (pid < 0) {\n\t\t/* fork error */\n\t\tlog_message(LOG_INFO, \"Failed fork process\");\n\t\treturn -1;\n\t}\n\n\tif (pid) {\n\t\t/* parent process */\n\t\tthread_add_child(m, func, arg, pid, timer);\n\t\treturn 0;\n\t}\n\n\t/* Child process */\n#ifdef _MEM_CHECK_\n\tskip_mem_dump();\n#endif\n\n\tsystem_call(script);\n\n\texit(0); /* Script errors aren't server errors */\n}\n\nint\nchild_killed_thread(thread_t *thread)\n{\n\tthread_master_t *m = thread->master;\n\n\t/* If the child didn't die, then force it */\n\tif (thread->type == THREAD_CHILD_TIMEOUT)\n\t\tkill(-getpgid(thread->u.c.pid), SIGKILL);\n\n\t/* If all children have died, we can now complete the\n\t * termination process */\n\tif (!&m->child.rb_root.rb_node && !m->shutdown_timer_running)\n\t\tthread_add_terminate_event(m);\n\n\treturn 0;\n}\n\nvoid\nscript_killall(thread_master_t *m, int signo, bool requeue)\n{\n\tthread_t *thread;\n\tpid_t p_pgid, c_pgid;\n#ifndef HAVE_SIGNALFD\n\tsigset_t old_set, child_wait;\n\n\tsigmask_func(0, NULL, &old_set);\n\tif (!sigismember(&old_set, SIGCHLD)) {\n\t\tsigemptyset(&child_wait);\n\t\tsigaddset(&child_wait, SIGCHLD);\n\t\tsigmask_func(SIG_BLOCK, &child_wait, NULL);\n\t}\n#endif\n\n\tp_pgid = getpgid(0);\n\n\trb_for_each_entry_cached(thread, &m->child, n) {\n\t\tc_pgid = getpgid(thread->u.c.pid);\n\t\tif (c_pgid != p_pgid)\n\t\t\tkill(-c_pgid, signo);\n\t\telse {\n\t\t\tlog_message(LOG_INFO, \"Child process %d in our process group %d\", c_pgid, p_pgid);\n\t\t\tkill(thread->u.c.pid, signo);\n\t\t}\n\t}\n\n\t/* We want to timeout the killed children in 1 second */\n\tif (requeue && signo != SIGKILL)\n\t\tthread_children_reschedule(m, child_killed_thread, TIMER_HZ);\n\n#ifndef HAVE_SIGNALFD\n\tif (!sigismember(&old_set, SIGCHLD))\n\t\tsigmask_func(SIG_UNBLOCK, &child_wait, NULL);\n#endif\n}\n\nstatic bool\nis_executable(struct stat *buf, uid_t uid, gid_t gid)\n{\n\treturn (uid == 0 && buf->st_mode & (S_IXUSR | S_IXGRP | S_IXOTH)) ||\n\t       (uid == buf->st_uid && buf->st_mode & S_IXUSR) ||\n\t       (uid != buf->st_uid &&\n\t\t((gid == buf->st_gid && buf->st_mode & S_IXGRP) ||\n\t\t (gid != buf->st_gid && buf->st_mode & S_IXOTH)));\n}\n\nstatic void\nreplace_cmd_name(notify_script_t *script, char *new_path)\n{\n\tsize_t len;\n\tchar **wp = &script->args[1];\n\tsize_t num_words = 1;\n\tchar **params;\n\tchar **word_ptrs;\n\tchar *words;\n\n\tlen = strlen(new_path) + 1;\n\twhile (*wp)\n\t\tlen += strlen(*wp++) + 1;\n\tnum_words = ((char **)script->args[0] - &script->args[0]) - 1;\n\n\tparams = word_ptrs = MALLOC((num_words + 1) * sizeof(char *) + len);\n\twords = (char *)&params[num_words + 1];\n\n\tstrcpy(words, new_path);\n\t*(word_ptrs++) = words;\n\twords += strlen(words) + 1;\n\n\twp = &script->args[1];\n\twhile (*wp) {\n\t\tstrcpy(words, *wp);\n\t\t*(word_ptrs++) = words;\n\t\twords += strlen(*wp) + 1;\n\t\twp++;\n\t}\n\t*word_ptrs = NULL;\n\n\tFREE(script->args);\n\tscript->args = params;\n}\n\n/* The following function is essentially __execve() from glibc */\nstatic int\nfind_path(notify_script_t *script)\n{\n\tsize_t filename_len;\n\tsize_t file_len;\n\tsize_t path_len;\n\tchar *file = script->args[0];\n\tstruct stat buf;\n\tint ret;\n\tint ret_val = ENOENT;\n\tint sgid_num;\n\tgid_t *sgid_list = NULL;\n\tconst char *subp;\n\tbool got_eacces = false;\n\tconst char *p;\n\n\t/* We check the simple case first. */\n\tif (*file == '\\0')\n\t\treturn ENOENT;\n\n\tfilename_len = strlen(file);\n\tif (filename_len >= PATH_MAX) {\n\t\tret_val = ENAMETOOLONG;\n\t\tgoto exit1;\n\t}\n\n\t/* Don't search when it contains a slash. */\n\tif (strchr (file, '/') != NULL) {\n\t\tret_val = 0;\n\t\tgoto exit1;\n\t}\n\n\t/* Get the path if we haven't already done so, and if that doesn't\n\t * exist, use CS_PATH */\n\tif (!path) {\n\t\tpath = getenv (\"PATH\");\n\n\t\tif (!path) {\n\t\t\tsize_t cs_path_len;\n\t\t\tpath = MALLOC(cs_path_len = confstr(_CS_PATH, NULL, 0));\n\t\t\tconfstr(_CS_PATH, path, cs_path_len);\n\t\t\tpath_is_malloced = true;\n\t\t}\n\t}\n\n\t/* Although GLIBC does not enforce NAME_MAX, we set it as the maximum\n\t   size to avoid unbounded stack allocation.  Same applies for\n\t   PATH_MAX. */\n\tfile_len = strnlen (file, NAME_MAX + 1);\n\tpath_len = strnlen (path, PATH_MAX - 1) + 1;\n\n\tif (file_len > NAME_MAX) {\n\t\tret_val = ENAMETOOLONG;\n\t\tgoto exit1;\n\t}\n\n\t/* Set file access to the relevant uid/gid */\n\tif (script->gid) {\n\t\tif (setegid(script->gid)) {\n\t\t\tlog_message(LOG_INFO, \"Unable to set egid to %d (%m)\", script->gid);\n\t\t\tret_val = EACCES;\n\t\t\tgoto exit1;\n\t\t}\n\n\t\t/* Get our supplementary groups */\n\t\tsgid_num = getgroups(0, NULL);\n\t\tsgid_list = MALLOC(((size_t)sgid_num + 1) * sizeof(gid_t));\n\t\tsgid_num = getgroups(sgid_num, sgid_list);\n\t\tsgid_list[sgid_num++] = 0;\n\n\t\t/* Clear the supplementary group list */\n\t\tif (setgroups(1, &script->gid)) {\n\t\t\tlog_message(LOG_INFO, \"Unable to set supplementary gids (%m)\");\n\t\t\tret_val = EACCES;\n\t\t\tgoto exit;\n\t\t}\n\t}\n\tif (script->uid && seteuid(script->uid)) {\n\t\tlog_message(LOG_INFO, \"Unable to set euid to %d (%m)\", script->uid);\n\t\tret_val = EACCES;\n\t\tgoto exit;\n\t}\n\n\tfor (p = path; ; p = subp)\n\t{\n\t\tchar buffer[path_len + file_len + 1];\n\n\t\tsubp = strchrnul (p, ':');\n\n\t\t/* PATH is larger than PATH_MAX and thus potentially larger than\n\t\t   the stack allocation. */\n\t\tif (subp >= p + path_len) {\n\t\t\t/* There are no more paths, bail out. */\n\t\t\tif (*subp == '\\0') {\n\t\t\t\tret_val = ENOENT;\n\t\t\t\tgoto exit;\n\t\t\t}\n\n\t\t\t/* Otherwise skip to next one. */\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Use the current path entry, plus a '/' if nonempty, plus the file to execute. */\n\t\tchar *pend = mempcpy (buffer, p, (size_t)(subp - p));\n\t\t*pend = '/';\n\t\tmemcpy (pend + (p < subp), file, file_len + 1);\n\n\t\tret = stat (buffer, &buf);\n\t\tif (!ret) {\n\t\t\tif (!S_ISREG(buf.st_mode))\n\t\t\t\terrno = EACCES;\n\t\t\telse if (!is_executable(&buf, script->uid, script->gid)) {\n\t\t\t\terrno = EACCES;\n\t\t\t} else {\n\t\t\t\t/* Success */\n\t\t\t\tlog_message(LOG_INFO, \"WARNING - script `%s` resolved by path search to `%s`. Please specify full path.\", script->args[0], buffer);\n\n\t\t\t\t/* Copy the found file name, and any parameters */\n\t\t\t\treplace_cmd_name(script, buffer);\n\n\t\t\t\tret_val = 0;\n\t\t\t\tgot_eacces = false;\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\n\t\tswitch (errno)\n\t\t{\n\t\tcase ENOEXEC:\n\t\tcase EACCES:\n\t\t\t/* Record that we got a 'Permission denied' error.  If we end\n\t\t\t   up finding no executable we can use, we want to diagnose\n\t\t\t   that we did find one but were denied access. */\n\t\t\tif (!ret)\n\t\t\t\tgot_eacces = true;\n\t\tcase ENOENT:\n\t\tcase ESTALE:\n\t\tcase ENOTDIR:\n\t\t\t/* Those errors indicate the file is missing or not executable\n\t\t\t   by us, in which case we want to just try the next path\n\t\t\t   directory. */\n\t\tcase ENODEV:\n\t\tcase ETIMEDOUT:\n\t\t\t/* Some strange filesystems like AFS return even\n\t\t\t   stranger error numbers.  They cannot reasonably mean\n\t\t\t   anything else so ignore those, too. */\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t/* Some other error means we found an executable file, but\n\t\t\t   something went wrong accessing it; return the error to our\n\t\t\t   caller. */\n\t\t\tret_val = -1;\n\t\t\tgoto exit;\n\t\t}\n\n\t\tif (*subp++ == '\\0')\n\t\t\tbreak;\n\t}\n\nexit:\n\t/* Restore root euid/egid */\n\tif (script->uid && seteuid(0))\n\t\tlog_message(LOG_INFO, \"Unable to restore euid after script search (%m)\");\n\tif (script->gid) {\n\t\tif (setegid(0))\n\t\t\tlog_message(LOG_INFO, \"Unable to restore egid after script search (%m)\");\n\n\t\t/* restore supplementary groups */\n\t\tif (sgid_list) {\n\t\t\tif (setgroups((size_t)sgid_num, sgid_list))\n\t\t\t\tlog_message(LOG_INFO, \"Unable to restore supplementary groups after script search (%m)\");\n\t\t\tFREE(sgid_list);\n\t\t}\n\t}\n\nexit1:\n\t/* We tried every element and none of them worked. */\n\tif (got_eacces) {\n\t\t/* At least one failure was due to permissions, so report that error. */\n\t\treturn EACCES;\n\t}\n\n\treturn ret_val;\n}\n\nstatic int\ncheck_security(char *filename, bool script_security)\n{\n\tchar *next;\n\tchar *slash;\n\tchar sav;\n\tint ret;\n\tstruct stat buf;\n\tint flags = 0;\n\n\tnext = filename;\n\twhile (next) {\n\t\tslash = strchrnul(next, '/');\n\t\tif (*slash)\n\t\t\tnext = slash + 1;\n\t\telse {\n\t\t\tslash = NULL;\n\t\t\tnext = NULL;\n\t\t}\n\n\t\tif (slash) {\n\t\t\t/* We want to check '/' for first time around */\n\t\t\tif (slash == filename)\n\t\t\t\tslash++;\n\t\t\tsav = *slash;\n\t\t\t*slash = 0;\n\t\t}\n\n\t\tret = fstatat(0, filename, &buf, AT_SYMLINK_NOFOLLOW);\n\n\t\t/* Restore the full path name */\n\t\tif (slash)\n\t\t\t*slash = sav;\n\n\t\tif (ret) {\n\t\t\tif (errno == EACCES || errno == ELOOP || errno == ENOENT || errno == ENOTDIR)\n\t\t\t\tlog_message(LOG_INFO, \"check_script_secure could not find script '%s' - disabling\", filename);\n\t\t\telse\n\t\t\t\tlog_message(LOG_INFO, \"check_script_secure('%s') returned errno %d - %s - disabling\", filename, errno, strerror(errno));\n\t\t\treturn flags | SC_NOTFOUND;\n\t\t}\n\n\t\t/* If it is not the last item, it must be a directory. If it is the last item\n\t\t * it must be a file or a symbolic link. */\n\t\tif ((slash && !S_ISDIR(buf.st_mode)) ||\n\t\t    (!slash &&\n\t\t     !S_ISREG(buf.st_mode) &&\n\t\t     !S_ISLNK(buf.st_mode))) {\n\t\t\tlog_message(LOG_INFO, \"Wrong file type found in script path '%s'.\", filename);\n\t\t\treturn flags | SC_INHIBIT;\n\t\t}\n\n\t\tif (buf.st_uid ||\t\t\t\t/* Owner is not root */\n\t\t    (((S_ISDIR(buf.st_mode) &&\t\t\t/* A directory without the sticky bit set */\n\t\t       !(buf.st_mode & S_ISVTX)) ||\n\t\t      S_ISREG(buf.st_mode)) &&\t\t\t/* This is a file */\n\t\t     ((buf.st_gid && buf.st_mode & S_IWGRP) ||\t/* Group is not root and group write permission */\n\t\t      buf.st_mode & S_IWOTH))) {\t\t/* World has write permission */\n\t\t\tlog_message(LOG_INFO, \"Unsafe permissions found for script '%s'%s.\", filename, script_security ? \" - disabling\" : \"\");\n\t\t\tflags |= SC_INSECURE;\n\t\t\treturn flags | (script_security ? SC_INHIBIT : 0);\n\t\t}\n\t}\n\n\treturn flags;\n}\n\nint\ncheck_script_secure(notify_script_t *script,\n#ifndef _HAVE_LIBMAGIC_\n\t\t\t\t\t     __attribute__((unused))\n#endif\n\t\t\t\t\t\t\t\t     magic_t magic)\n{\n\tint flags;\n\tint ret, ret_real, ret_new;\n\tstruct stat file_buf, real_buf;\n\tbool need_script_protection = false;\n\tuid_t old_uid = 0;\n\tgid_t old_gid = 0;\n\tchar *new_path;\n\tint sav_errno;\n\tchar *real_file_path;\n\tchar *orig_file_part, *new_file_part;\n\n\tif (!script)\n\t\treturn 0;\n\n\t/* If the script starts \"</\" (possibly with white space between\n\t * the '<' and '/'), it is checking for a file being openable,\n\t * so it won't be executed */\n\tif (script->args[0][0] == '<' &&\n\t    script->args[0][strspn(script->args[0] + 1, \" \\t\") + 1] == '/')\n\t\treturn SC_SYSTEM;\n\n\tif (!strchr(script->args[0], '/')) {\n\t\t/* It is a bare file name, so do a path search */\n\t\tif ((ret = find_path(script))) {\n\t\t\tif (ret == EACCES)\n\t\t\t\tlog_message(LOG_INFO, \"Permissions failure for script %s in path - disabling\", script->args[0]);\n\t\t\telse\n\t\t\t\tlog_message(LOG_INFO, \"Cannot find script %s in path - disabling\", script->args[0]);\n\t\t\treturn SC_NOTFOUND;\n\t\t}\n\t}\n\n\t/* Check script accessible by the user running it */\n\tif (script->uid)\n\t\told_uid = geteuid();\n\tif (script->gid)\n\t\told_gid = getegid();\n\n\tif ((script->gid && setegid(script->gid)) ||\n\t    (script->uid && seteuid(script->uid))) {\n\t\tlog_message(LOG_INFO, \"Unable to set uid:gid %d:%d for script %s - disabling\", script->uid, script->gid, script->args[0]);\n\n\t\tif ((script->uid && seteuid(old_uid)) ||\n\t\t    (script->gid && setegid(old_gid)))\n\t\t\tlog_message(LOG_INFO, \"Unable to restore uid:gid %d:%d after script %s\", script->uid, script->gid, script->args[0]);\n\n\t\treturn SC_INHIBIT;\n\t}\n\n\t/* Remove /./, /../, multiple /'s, and resolve symbolic links */\n\tnew_path = realpath(script->args[0], NULL);\n\tsav_errno = errno;\n\n\tif ((script->gid && setegid(old_gid)) ||\n\t    (script->uid && seteuid(old_uid)))\n\t\tlog_message(LOG_INFO, \"Unable to restore uid:gid %d:%d after checking script %s\", script->uid, script->gid, script->args[0]);\n\n\tif (!new_path)\n\t{\n\t\tlog_message(LOG_INFO, \"Script %s cannot be accessed - %s\", script->args[0], strerror(sav_errno));\n\n\t\treturn SC_NOTFOUND;\n\t}\n\n\treal_file_path = NULL;\n\n\torig_file_part = strrchr(script->args[0], '/');\n\tnew_file_part = strrchr(new_path, '/');\n\tif (strcmp(script->args[0], new_path)) {\n\t\t/* The path name is different */\n\n\t\t/* If the file name parts don't match, we need to be careful to\n\t\t * ensure that we preserve the file name part since some executables\n\t\t * alter their behaviour based on what they are called */\n\t\tif (strcmp(orig_file_part + 1, new_file_part + 1)) {\n\t\t\treal_file_path = new_path;\n\t\t\tnew_path = MALLOC(new_file_part - real_file_path + 1 + strlen(orig_file_part + 1) + 1);\n\t\t\tstrncpy(new_path, real_file_path, new_file_part + 1 - real_file_path);\n\t\t\tstrcpy(new_path + (new_file_part + 1 - real_file_path), orig_file_part + 1);\n\n\t\t\t/* Now check this is the same file */\n\t\t\tret_real = stat(real_file_path, &real_buf);\n\t\t\tret_new = stat(new_path, &file_buf);\n\t\t\tif (!ret_real &&\n\t\t\t    (ret_new ||\n\t\t\t     real_buf.st_dev != file_buf.st_dev ||\n\t\t\t     real_buf.st_ino != file_buf.st_ino)) {\n\t\t\t\t/* It doesn't resolve to the same file */\n\t\t\t\tFREE(new_path);\n\t\t\t\tnew_path = real_file_path;\n\t\t\t\treal_file_path = NULL;\n\t\t\t}\n\t\t}\n\n\t\tif (strcmp(script->args[0], new_path)) {\n\t \t\t/* We need to set up all the args again */\n\t\t\treplace_cmd_name(script, new_path);\n\t\t}\n\t}\n\n\tif (!real_file_path)\n\t\tfree(new_path);\n\telse\n\t\tFREE(new_path);\n\n\t/* Get the permissions for the file itself */\n\tif (stat(real_file_path ? real_file_path : script->args[0], &file_buf)) {\n\t\tlog_message(LOG_INFO, \"Unable to access script `%s` - disabling\", script->args[0]);\n\t\treturn SC_NOTFOUND;\n\t}\n\n\tflags = SC_ISSCRIPT;\n\n\t/* We have the final file. Check if root is executing it, or it is set uid/gid root. */\n\tif (is_executable(&file_buf, script->uid, script->gid)) {\n\t\tflags |= SC_EXECUTABLE;\n\t\tif (script->uid == 0 || script->gid == 0 ||\n\t\t    (file_buf.st_uid == 0 && (file_buf.st_mode & S_IXUSR) && (file_buf.st_mode & S_ISUID)) ||\n\t\t    (file_buf.st_gid == 0 && (file_buf.st_mode & S_IXGRP) && (file_buf.st_mode & S_ISGID)))\n\t\t\tneed_script_protection = true;\n\t} else\n\t\tlog_message(LOG_INFO, \"WARNING - script '%s' is not executable for uid:gid %d:%d - disabling.\", script->args[0], script->uid, script->gid);\n\n\t/* Default to execable */\n\tscript->flags |= SC_EXECABLE;\n#ifdef _HAVE_LIBMAGIC_\n\tif (magic && flags & SC_EXECUTABLE) {\n\t\tconst char *magic_desc = magic_file(magic, real_file_path ? real_file_path : script->args[0]);\n\t\tif (!strstr(magic_desc, \" executable\") &&\n\t\t    !strstr(magic_desc, \" shared object\")) {\n\t\t\tlog_message(LOG_INFO, \"Please add a #! shebang to script %s\", script->args[0]);\n\t\t\tscript->flags &= ~SC_EXECABLE;\n\t\t}\n\t}\n#endif\n\n\tif (!need_script_protection) {\n\t\tif (real_file_path)\n\t\t\tfree(real_file_path);\n\n\t\treturn flags;\n\t}\n\n\t/* Make sure that all parts of the path are not non-root writable */\n\tflags |= check_security(script->args[0], script_security);\n\n\tif (real_file_path) {\n\t\tflags |= check_security(real_file_path, script_security);\n\t\tfree(real_file_path);\n\t}\n\n\treturn flags;\n}\n\nint\ncheck_notify_script_secure(notify_script_t **script_p, magic_t magic)\n{\n\tint flags;\n\tnotify_script_t *script = *script_p;\n\n\tif (!script)\n\t\treturn 0;\n\n\tflags = check_script_secure(script, magic);\n\n\t/* Mark not to run if needs inhibiting */\n\tif ((flags & (SC_INHIBIT | SC_NOTFOUND)) ||\n\t    !(flags & SC_EXECUTABLE))\n\t\tfree_notify_script(script_p);\n\n\treturn flags;\n}\n\nstatic void\nset_pwnam_buf_len(void)\n{\n\tlong buf_len;\n\n\t/* Get buffer length needed for getpwnam_r/getgrnam_r */\n\tif ((buf_len = sysconf(_SC_GETPW_R_SIZE_MAX)) == -1)\n\t\tgetpwnam_buf_len = 1024;\t/* A safe default if no value is returned */\n\telse\n\t\tgetpwnam_buf_len = (size_t)buf_len;\n\tif ((buf_len = sysconf(_SC_GETGR_R_SIZE_MAX)) != -1 &&\n\t    (size_t)buf_len > getpwnam_buf_len)\n\t\tgetpwnam_buf_len = (size_t)buf_len;\n}\n\nbool\nset_uid_gid(const char *username, const char *groupname, uid_t *uid_p, gid_t *gid_p, bool default_user)\n{\n\tuid_t uid;\n\tgid_t gid;\n\tstruct passwd pwd;\n\tstruct passwd *pwd_p;\n\tstruct group grp;\n\tstruct group *grp_p;\n\tint ret;\n\tbool using_default_default_user = false;\n\n\tif (!getpwnam_buf_len)\n\t\tset_pwnam_buf_len();\n\n\t{\n\t\tchar buf[getpwnam_buf_len];\n\n\t\tif (default_user && !username) {\n\t\t\tusing_default_default_user = true;\n\t\t\tusername = \"keepalived_script\";\n\t\t}\n\n\t\tif ((ret = getpwnam_r(username, &pwd, buf, sizeof(buf), &pwd_p))) {\n\t\t\tlog_message(LOG_INFO, \"Unable to resolve %sscript username '%s' - ignoring\", default_user ? \"default \" : \"\", username);\n\t\t\treturn true;\n\t\t}\n\t\tif (!pwd_p) {\n\t\t\tif (using_default_default_user)\n\t\t\t\tlog_message(LOG_INFO, \"WARNING - default user '%s' for script execution does not exist - please create.\", username);\n\t\t\telse\n\t\t\t\tlog_message(LOG_INFO, \"%script user '%s' does not exist\", default_user ? \"Default s\" : \"S\", username);\n\t\t\treturn true;\n\t\t}\n\n\t\tuid = pwd.pw_uid;\n\t\tgid = pwd.pw_gid;\n\n\t\tif (groupname) {\n\t\t\tif ((ret = getgrnam_r(groupname, &grp, buf, sizeof(buf), &grp_p))) {\n\t\t\t\tlog_message(LOG_INFO, \"Unable to resolve %sscript group name '%s' - ignoring\", default_user ? \"default \" : \"\", groupname);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (!grp_p) {\n\t\t\t\tlog_message(LOG_INFO, \"%script group '%s' does not exist\", default_user ? \"Default s\" : \"S\", groupname);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tgid = grp.gr_gid;\n\t\t}\n\n\t\t*uid_p = uid;\n\t\t*gid_p = gid;\n\t}\n\n\treturn false;\n}\n\n/* The default script user/group is keepalived_script if it exists, or root otherwise */\nbool\nset_default_script_user(const char *username, const char *groupname)\n{\n\tif (!default_script_uid_set || username) {\n\t\t/* Even if we fail to set it, there is no point in trying again */\n\t\tdefault_script_uid_set = true;\n\n\t\tif (set_uid_gid(username, groupname, &default_script_uid, &default_script_gid, true)) {\n\t\t\tif (username || script_security)\n\t\t\t\tdefault_user_fail = true;\n\t\t}\n\t\telse\n\t\t\tdefault_user_fail = false;\n\t}\n\n\treturn default_user_fail;\n}\n\nbool\nset_script_uid_gid(vector_t *strvec, unsigned keyword_offset, uid_t *uid_p, gid_t *gid_p)\n{\n\tchar *username;\n\tchar *groupname;\n\n\tusername = strvec_slot(strvec, keyword_offset);\n\tif (vector_size(strvec) > keyword_offset + 1)\n\t\tgroupname = strvec_slot(strvec, keyword_offset + 1);\n\telse\n\t\tgroupname = NULL;\n\n\treturn set_uid_gid(username, groupname, uid_p, gid_p, false);\n}\n\nvoid\nset_script_params_array(vector_t *strvec, notify_script_t *script, unsigned extra_params)\n{\n\tunsigned num_words = 0;\n\tsize_t len = 0;\n\tchar **word_ptrs;\n\tchar *words;\n\tvector_t *strvec_qe = NULL;\n\tunsigned i;\n\n\t/* Count the number of words, and total string length */\n\tif (vector_size(strvec) >= 2)\n\t\tstrvec_qe = alloc_strvec_quoted_escaped(strvec_slot(strvec, 1));\n\n\tif (!strvec_qe)\n\t\treturn;\n\n\tnum_words = vector_size(strvec_qe);\n\tfor (i = 0; i < num_words; i++)\n\t\tlen += strlen(strvec_slot(strvec_qe, i)) + 1;\n\n\t/* Allocate memory for pointers to words and words themselves */\n\tscript->args = word_ptrs = MALLOC((num_words + extra_params + 1) * sizeof(char *) + len);\n\twords = (char *)word_ptrs + (num_words + extra_params + 1) * sizeof(char *);\n\n\t/* Set up pointers to words, and copy the words */\n\tfor (i = 0; i < num_words; i++) {\n\t\tstrcpy(words, strvec_slot(strvec_qe, i));\n\t\t*(word_ptrs++) = words;\n\t\twords += strlen(words) + 1;\n\t}\n\t*word_ptrs = NULL;\n\n\tscript->num_args = num_words;\n\n\tfree_strvec(strvec_qe);\n}\n\nnotify_script_t*\nnotify_script_init(int extra_params, const char *type)\n{\n\tnotify_script_t *script = MALLOC(sizeof(notify_script_t));\n\tvector_t *strvec_qe;\n\n\t/* We need to reparse the command line, allowing for quoted and escaped strings */\n\tstrvec_qe = alloc_strvec_quoted_escaped(NULL);\n\n\tif (!strvec_qe) {\n\t\tlog_message(LOG_INFO, \"Unable to parse notify script\");\n\t\tFREE(script);\n\t\treturn NULL;\n\t}\n\n\tset_script_params_array(strvec_qe, script, extra_params);\n\tif (!script->args) {\n\t\tlog_message(LOG_INFO, \"Unable to parse script '%s' - ignoring\", FMT_STR_VSLOT(strvec_qe, 1));\n\t\tFREE(script);\n\t\tfree_strvec(strvec_qe);\n\t\treturn NULL;\n\t}\n\n\tscript->flags = 0;\n\n\tif (vector_size(strvec_qe) > 2) {\n\t\tif (set_script_uid_gid(strvec_qe, 2, &script->uid, &script->gid)) {\n\t\t\tlog_message(LOG_INFO, \"Invalid user/group for %s script %s - ignoring\", type, script->args[0]);\n\t\t\tFREE(script->args);\n\t\t\tFREE(script);\n\t\t\tfree_strvec(strvec_qe);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\telse {\n\t\tif (set_default_script_user(NULL, NULL)) {\n\t\t\tlog_message(LOG_INFO, \"Failed to set default user for %s script %s - ignoring\", type, script->args[0]);\n\t\t\tFREE(script->args);\n\t\t\tFREE(script);\n\t\t\tfree_strvec(strvec_qe);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tscript->uid = default_script_uid;\n\t\tscript->gid = default_script_gid;\n\t}\n\n\tfree_strvec(strvec_qe);\n\n\treturn script;\n}\n\nvoid\nadd_script_param(notify_script_t *script, char *param)\n{\n\t/* We store the args as an array of pointers to the args, terminated\n\t * by a NULL pointer, followed by the null terminated strings themselves\n\t */\n\n\tif (script->args[script->num_args + 1]) {\n\t\tlog_message(LOG_INFO, \"notify_fifo_script %s no room to add parameter %s\", script->args[0], param);\n\t\treturn;\n\t}\n\n\t/* Add the extra parameter in the pre-reserved slot at the end */\n\tscript->args[script->num_args++] = param;\n}\n\nvoid\nnotify_resource_release(void)\n{\n\tif (path_is_malloced) {\n\t\tFREE(path);\n\t\tpath_is_malloced = false;\n\t\tpath = NULL;\n\t}\n}\n\nbool\nnotify_script_compare(notify_script_t *a, notify_script_t *b)\n{\n\tint i;\n\n\tif (a->num_args != b->num_args)\n\t\treturn false;\n\tfor (i = 0; i < a->num_args; i++) {\n\t\tif (strcmp(a->args[i], b->args[i]))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n#ifdef THREAD_DUMP\nvoid\nregister_notify_addresses(void)\n{\n\tregister_thread_address(\"child_killed_thread\", child_killed_thread);\n}\n#endif\n", "/*\n * Soft:        Keepalived is a failover program for the LVS project\n *              <www.linuxvirtualserver.org>. It monitor & manipulate\n *              a loadbalanced server pool using multi-layer checks.\n *\n * Part:        Configuration file parser/reader. Place into the dynamic\n *              data structure representation the conf file representing\n *              the loadbalanced server pool.\n *\n * Author:      Alexandre Cassen, <acassen@linux-vs.org>\n *\n *              This program is distributed in the hope that it will be useful,\n *              but WITHOUT ANY WARRANTY; without even the implied warranty of\n *              MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n *              See the GNU General Public License for more details.\n *\n *              This program is free software; you can redistribute it and/or\n *              modify it under the terms of the GNU General Public License\n *              as published by the Free Software Foundation; either version\n *              2 of the License, or (at your option) any later version.\n *\n * Copyright (C) 2001-2017 Alexandre Cassen, <acassen@gmail.com>\n */\n\n#include \"config.h\"\n\n#include <glob.h>\n#include <unistd.h>\n#include <libgen.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <stdbool.h>\n#include <linux/version.h>\n#include <pwd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <math.h>\n#include <inttypes.h>\n\n#include \"parser.h\"\n#include \"memory.h\"\n#include \"logger.h\"\n#include \"rttables.h\"\n#include \"scheduler.h\"\n#include \"notify.h\"\n#include \"list.h\"\n#include \"bitops.h\"\n#include \"utils.h\"\n\n/* #define PARSER_DEBUG */\n\n#define DUMP_KEYWORDS\t0\n\n#define DEF_LINE_END\t\"\\n\"\n\n#define BOB \"{\"\n#define EOB \"}\"\n#define WHITE_SPACE_STR \" \\t\\f\\n\\r\\v\"\n\ntypedef struct _defs {\n\tchar *name;\n\tsize_t name_len;\n\tchar *value;\n\tsize_t value_len;\n\tbool multiline;\n\tchar *(*fn)(void);\n} def_t;\n\n/* global vars */\nvector_t *keywords;\nchar *config_id;\nconst char *WHITE_SPACE = WHITE_SPACE_STR;\n\n/* local vars */\nstatic vector_t *current_keywords;\nstatic FILE *current_stream;\nstatic const char *current_file_name;\nstatic size_t current_file_line_no;\nstatic int sublevel = 0;\nstatic int skip_sublevel = 0;\nstatic list multiline_stack;\nstatic char *buf_extern;\nstatic config_err_t config_err = CONFIG_OK; /* Highest level of config error for --config-test */\n\n/* Parameter definitions */\nstatic list defs;\n\n/* Forward declarations for recursion */\nstatic bool read_line(char *, size_t);\n\nvoid\nreport_config_error(config_err_t err, const char *format, ...)\n{\n\tva_list args;\n\tchar *format_buf = NULL;\n\n\t/* current_file_name will be set if there is more than one config file, in which\n\t * case we need to specify the file name. */\n\tif (current_file_name) {\n\t\t/* \"(file_name:line_no) format\" + '\\0' */\n\t\tformat_buf = MALLOC(1 + strlen(current_file_name) + 1 + 10 + 1 + 1 + strlen(format) + 1);\n\t\tsprintf(format_buf, \"(%s:%zd) %s\", current_file_name, current_file_line_no, format);\n\t} else if (current_file_line_no) {\t/* Set while reading from config files */\n\t\t/* \"(Line line_no) format\" + '\\0' */\n\t\tformat_buf = MALLOC(1 + 5 + 10 + 1 + 1 + strlen(format) + 1);\n\t\tsprintf(format_buf, \"(%s %zd) %s\", \"Line\", current_file_line_no, format);\n\t}\n\n\tva_start(args, format);\n\n\tif (__test_bit(CONFIG_TEST_BIT, &debug)) {\n\t\tvfprintf(stderr, format_buf ? format_buf : format, args);\n\t\tfputc('\\n', stderr);\n\n\t\tif (config_err == CONFIG_OK || config_err < err)\n\t\t\tconfig_err = err;\n\t}\n\telse\n\t\tvlog_message(LOG_INFO, format_buf ? format_buf : format, args);\n\n\tva_end(args);\n\n\tif (format_buf)\n\t\tFREE(format_buf);\n}\n\nconfig_err_t\nget_config_status(void)\n{\n\treturn config_err;\n}\n\nstatic char *\nnull_strvec(const vector_t *strvec, size_t index)\n{\n\tif (index - 1 < vector_size(strvec) && index > 0 && vector_slot(strvec, index - 1))\n\t\treport_config_error(CONFIG_MISSING_PARAMETER, \"*** Configuration line starting `%s` is missing a parameter after keyword `%s` at word position %zu\", vector_slot(strvec, 0) ? (char *)vector_slot(strvec, 0) : \"***MISSING ***\", (char *)vector_slot(strvec, index - 1), index + 1);\n\telse\n\t\treport_config_error(CONFIG_MISSING_PARAMETER, \"*** Configuration line starting `%s` is missing a parameter at word position %zu\", vector_slot(strvec, 0) ? (char *)vector_slot(strvec, 0) : \"***MISSING ***\", index + 1);\n\n\texit(KEEPALIVED_EXIT_CONFIG);\n\n\treturn NULL;\n}\n\nstatic bool\nread_int_func(const char *number, int base, int *res, int min_val, int max_val, __attribute__((unused)) bool ignore_error)\n{\n\tlong val;\n\tchar *endptr;\n\tchar *warn = \"\";\n\n#ifndef _STRICT_CONFIG_\n\tif (ignore_error && !__test_bit(CONFIG_TEST_BIT, &debug))\n\t\twarn = \"WARNING - \";\n#endif\n\n\terrno = 0;\n\tval = strtol(number, &endptr, base);\n\t*res = (int)val;\n\n\tif (*endptr)\n\t\treport_config_error(CONFIG_INVALID_NUMBER, \"%sinvalid number '%s'\", warn, number);\n\telse if (errno == ERANGE || val < INT_MIN || val > INT_MAX)\n\t\treport_config_error(CONFIG_INVALID_NUMBER, \"%snumber '%s' outside integer range\", warn, number);\n\telse if (val < min_val || val > max_val)\n\t\treport_config_error(CONFIG_INVALID_NUMBER, \"number '%s' outside range [%d, %d]\", number, min_val, max_val);\n\telse\n\t\treturn true;\n\n#ifdef _STRICT_CONFIG_\n\treturn false;\n#else\n\treturn ignore_error && val >= min_val && val <= max_val && !__test_bit(CONFIG_TEST_BIT, &debug);\n#endif\n}\n\nstatic bool\nread_unsigned_func(const char *number, int base, unsigned *res, unsigned min_val, unsigned max_val, __attribute__((unused)) bool ignore_error)\n{\n\tunsigned long val;\n\tchar *endptr;\n\tchar *warn = \"\";\n\tsize_t offset;\n\n#ifndef _STRICT_CONFIG_\n\tif (ignore_error && !__test_bit(CONFIG_TEST_BIT, &debug))\n\t\twarn = \"WARNING - \";\n#endif\n\n\t/* In case the string starts with spaces (even in the configuration this\n\t * can be achieved by enclosing the number in quotes - e.g. weight \"  -100\")\n\t * skip any leading whitespace */\n\toffset = strspn(number, WHITE_SPACE);\n\n\terrno = 0;\n\tval = strtoul(number + offset, &endptr, base);\n\t*res = (unsigned)val;\n\n\tif (number[offset] == '-')\n\t\treport_config_error(CONFIG_INVALID_NUMBER, \"%snegative number '%s'\", warn, number);\n\telse if (*endptr)\n\t\treport_config_error(CONFIG_INVALID_NUMBER, \"%sinvalid number '%s'\", warn, number);\n\telse if (errno == ERANGE || val > UINT_MAX)\n\t\treport_config_error(CONFIG_INVALID_NUMBER, \"%snumber '%s' outside unsigned integer range\", warn, number);\n\telse if (val < min_val || val > max_val)\n\t\treport_config_error(CONFIG_INVALID_NUMBER, \"number '%s' outside range [%u, %u]\", number, min_val, max_val);\n\telse\n\t\treturn true;\n\n#ifdef _STRICT_CONFIG_\n\treturn false;\n#else\n\treturn ignore_error && val >= min_val && val <= max_val && !__test_bit(CONFIG_TEST_BIT, &debug);\n#endif\n}\n\nstatic bool\nread_unsigned64_func(const char *number, int base, uint64_t *res, uint64_t min_val, uint64_t max_val, __attribute__((unused)) bool ignore_error)\n{\n\tunsigned long long val;\n\tchar *endptr;\n\tchar *warn = \"\";\n\tsize_t offset;\n\n#ifndef _STRICT_CONFIG_\n\tif (ignore_error && !__test_bit(CONFIG_TEST_BIT, &debug))\n\t\twarn = \"WARNING - \";\n#endif\n\n\t/* In case the string starts with spaces (even in the configuration this\n\t * can be achieved by enclosing the number in quotes - e.g. weight \"  -100\")\n\t * skip any leading whitespace */\n\toffset = strspn(number, WHITE_SPACE);\n\n\terrno = 0;\n\tval = strtoull(number + offset, &endptr, base);\n\t*res = (unsigned)val;\n\n\tif (number[offset] == '-')\n\t\treport_config_error(CONFIG_INVALID_NUMBER, \"%snegative number '%s'\", warn, number);\n\telse if (*endptr)\n\t\treport_config_error(CONFIG_INVALID_NUMBER, \"%sinvalid number '%s'\", warn, number);\n\telse if (errno == ERANGE)\n\t\treport_config_error(CONFIG_INVALID_NUMBER, \"%snumber '%s' outside unsigned 64 bit range\", warn, number);\n\telse if (val < min_val || val > max_val)\n\t\treport_config_error(CONFIG_INVALID_NUMBER, \"number '%s' outside range [%\" PRIu64 \", %\" PRIu64 \"]\", number, min_val, max_val);\n\telse\n\t\treturn true;\n\n#ifdef _STRICT_CONFIG_\n\treturn false;\n#else\n\treturn ignore_error && val >= min_val && val <= max_val && !__test_bit(CONFIG_TEST_BIT, &debug);\n#endif\n}\n\nstatic bool\nread_double_func(const char *number, double *res, double min_val, double max_val, __attribute__((unused)) bool ignore_error)\n{\n\tdouble val;\n\tchar *endptr;\n\tchar *warn = \"\";\n\n#ifndef _STRICT_CONFIG_\n\tif (ignore_error && !__test_bit(CONFIG_TEST_BIT, &debug))\n\t\twarn = \"WARNING - \";\n#endif\n\n\terrno = 0;\n\tval = strtod(number, &endptr);\n\t*res = val;\n\n\tif (*endptr)\n\t\treport_config_error(CONFIG_INVALID_NUMBER, \"%sinvalid number '%s'\", warn, number);\n\telse if (errno == ERANGE)\n\t\treport_config_error(CONFIG_INVALID_NUMBER, \"%snumber '%s' out of range\", warn, number);\n\telse if (val == -HUGE_VAL || val == HUGE_VAL)\t/* +/- Inf */\n\t\treport_config_error(CONFIG_INVALID_NUMBER, \"infinite number '%s'\", number);\n\telse if (!(val <= 0 || val >= 0))\t/* NaN */\n\t\treport_config_error(CONFIG_INVALID_NUMBER, \"not a number '%s'\", number);\n\telse if (val < min_val || val > max_val)\n\t\treport_config_error(CONFIG_INVALID_NUMBER, \"number '%s' outside range [%g, %g]\", number, min_val, max_val);\n\telse\n\t\treturn true;\n\n#ifdef _STRICT_CONFIG_\n\treturn false;\n#else\n\treturn ignore_error && val >= min_val && val <= max_val && !__test_bit(CONFIG_TEST_BIT, &debug);\n#endif\n}\n\nbool\nread_int(const char *str, int *res, int min_val, int max_val, bool ignore_error)\n{\n\treturn read_int_func(str, 10, res, min_val, max_val, ignore_error);\n}\n\nbool\nread_unsigned(const char *str, unsigned *res, unsigned min_val, unsigned max_val, bool ignore_error)\n{\n\treturn read_unsigned_func(str, 10, res, min_val, max_val, ignore_error);\n}\n\nbool\nread_unsigned64(const char *str, uint64_t *res, uint64_t min_val, uint64_t max_val, bool ignore_error)\n{\n\treturn read_unsigned64_func(str, 10, res, min_val, max_val, ignore_error);\n}\n\nbool\nread_double(const char *str, double *res, double min_val, double max_val, bool ignore_error)\n{\n\treturn read_double_func(str, res, min_val, max_val, ignore_error);\n}\n\nbool\nread_int_strvec(const vector_t *strvec, size_t index, int *res, int min_val, int max_val, bool ignore_error)\n{\n\treturn read_int_func(strvec_slot(strvec, index), 10, res, min_val, max_val, ignore_error);\n}\n\nbool\nread_unsigned_strvec(const vector_t *strvec, size_t index, unsigned *res, unsigned min_val, unsigned max_val, bool ignore_error)\n{\n\treturn read_unsigned_func(strvec_slot(strvec, index), 10, res, min_val, max_val, ignore_error);\n}\n\nbool\nread_unsigned64_strvec(const vector_t *strvec, size_t index, uint64_t *res, uint64_t min_val, uint64_t max_val, bool ignore_error)\n{\n\treturn read_unsigned64_func(strvec_slot(strvec, index), 10, res, min_val, max_val, ignore_error);\n}\n\nbool\nread_double_strvec(const vector_t *strvec, size_t index, double *res, double min_val, double max_val, bool ignore_error)\n{\n\treturn read_double_func(strvec_slot(strvec, index), res, min_val, max_val, ignore_error);\n}\n\nbool\nread_unsigned_base_strvec(const vector_t *strvec, size_t index, int base, unsigned *res, unsigned min_val, unsigned max_val, bool ignore_error)\n{\n\treturn read_unsigned_func(strvec_slot(strvec, index), base, res, min_val, max_val, ignore_error);\n}\n\nstatic void\nkeyword_alloc(vector_t *keywords_vec, const char *string, void (*handler) (vector_t *), bool active)\n{\n\tkeyword_t *keyword;\n\n\tvector_alloc_slot(keywords_vec);\n\n\tkeyword = (keyword_t *) MALLOC(sizeof(keyword_t));\n\tkeyword->string = string;\n\tkeyword->handler = handler;\n\tkeyword->active = active;\n\n\tvector_set_slot(keywords_vec, keyword);\n}\n\nstatic void\nkeyword_alloc_sub(vector_t *keywords_vec, const char *string, void (*handler) (vector_t *))\n{\n\tint i = 0;\n\tkeyword_t *keyword;\n\n\t/* fetch last keyword */\n\tkeyword = vector_slot(keywords_vec, vector_size(keywords_vec) - 1);\n\n\t/* Don't install subordinate keywords if configuration block inactive */\n\tif (!keyword->active)\n\t\treturn;\n\n\t/* position to last sub level */\n\tfor (i = 0; i < sublevel; i++)\n\t\tkeyword = vector_slot(keyword->sub, vector_size(keyword->sub) - 1);\n\n\t/* First sub level allocation */\n\tif (!keyword->sub)\n\t\tkeyword->sub = vector_alloc();\n\n\t/* add new sub keyword */\n\tkeyword_alloc(keyword->sub, string, handler, true);\n}\n\n/* Exported helpers */\nvoid\ninstall_sublevel(void)\n{\n\tsublevel++;\n}\n\nvoid\ninstall_sublevel_end(void)\n{\n\tsublevel--;\n}\n\nvoid\ninstall_keyword_root(const char *string, void (*handler) (vector_t *), bool active)\n{\n\t/* If the root keyword is inactive, the handler will still be called,\n\t * but with a NULL strvec */\n\tkeyword_alloc(keywords, string, handler, active);\n}\n\nvoid\ninstall_root_end_handler(void (*handler) (void))\n{\n\tkeyword_t *keyword;\n\n\t/* fetch last keyword */\n\tkeyword = vector_slot(keywords, vector_size(keywords) - 1);\n\n\tif (!keyword->active)\n\t\treturn;\n\n\tkeyword->sub_close_handler = handler;\n}\n\nvoid\ninstall_keyword(const char *string, void (*handler) (vector_t *))\n{\n\tkeyword_alloc_sub(keywords, string, handler);\n}\n\nvoid\ninstall_sublevel_end_handler(void (*handler) (void))\n{\n\tint i = 0;\n\tkeyword_t *keyword;\n\n\t/* fetch last keyword */\n\tkeyword = vector_slot(keywords, vector_size(keywords) - 1);\n\n\tif (!keyword->active)\n\t\treturn;\n\n\t/* position to last sub level */\n\tfor (i = 0; i < sublevel; i++)\n\t\tkeyword = vector_slot(keyword->sub, vector_size(keyword->sub) - 1);\n\tkeyword->sub_close_handler = handler;\n}\n\n#if DUMP_KEYWORDS\nstatic void\ndump_keywords(vector_t *keydump, int level, FILE *fp)\n{\n\tunsigned int i;\n\tkeyword_t *keyword_vec;\n\tchar file_name[21];\n\n\tif (!level) {\n\t\tsnprintf(file_name, sizeof(file_name), \"/tmp/keywords.%d\", getpid());\n\t\tfp = fopen(file_name, \"w\");\n\t\tif (!fp)\n\t\t\treturn;\n\t}\n\n\tfor (i = 0; i < vector_size(keydump); i++) {\n\t\tkeyword_vec = vector_slot(keydump, i);\n\t\tfprintf(fp, \"%*sKeyword : %s (%s)\\n\", level * 2, \"\", keyword_vec->string, keyword_vec->active ? \"active\": \"disabled\");\n\t\tif (keyword_vec->sub)\n\t\t\tdump_keywords(keyword_vec->sub, level + 1, fp);\n\t}\n\n\tif (!level)\n\t\tfclose(fp);\n}\n#endif\n\nstatic void\nfree_keywords(vector_t *keywords_vec)\n{\n\tkeyword_t *keyword_vec;\n\tunsigned int i;\n\n\tfor (i = 0; i < vector_size(keywords_vec); i++) {\n\t\tkeyword_vec = vector_slot(keywords_vec, i);\n\t\tif (keyword_vec->sub)\n\t\t\tfree_keywords(keyword_vec->sub);\n\t\tFREE(keyword_vec);\n\t}\n\tvector_free(keywords_vec);\n}\n\n/* Functions used for standard definitions */\nstatic char *\nget_cwd(void)\n{\n\tchar *dir = MALLOC(PATH_MAX);\n\n\t/* Since keepalived doesn't do a chroot(), we don't need to be concerned\n\t * about (unreachable) - see getcwd(3) man page. */\n\treturn getcwd(dir, PATH_MAX);\n}\n\nstatic char *\nget_instance(void)\n{\n\tchar *conf_id = MALLOC(strlen(config_id) + 1);\n\n\tstrcpy(conf_id, config_id);\n\n\treturn conf_id;\n}\n\nvector_t *\nalloc_strvec_quoted_escaped(char *src)\n{\n\tchar *token;\n\tvector_t *strvec;\n\tchar cur_quote = 0;\n\tchar *ofs_op;\n\tchar *op_buf;\n\tchar *ofs, *ofs1;\n\tchar op_char;\n\n\tif (!src) {\n\t\tif (!buf_extern)\n\t\t\treturn NULL;\n\t\tsrc = buf_extern;\n\t}\n\n\t/* Create a vector and alloc each command piece */\n\tstrvec = vector_alloc();\n\top_buf = MALLOC(MAXBUF);\n\n\tofs = src;\n\twhile (*ofs) {\n\t\t/* Find the next 'word' */\n\t\tofs += strspn(ofs, WHITE_SPACE);\n\t\tif (!*ofs)\n\t\t\tbreak;\n\n\t\tofs_op = op_buf;\n\n\t\twhile (*ofs) {\n\t\t\tofs1 = strpbrk(ofs, cur_quote == '\"' ? \"\\\"\\\\\" : cur_quote == '\\'' ? \"'\\\\\" : WHITE_SPACE_STR \"'\\\"\\\\\");\n\n\t\t\tif (!ofs1) {\n\t\t\t\tsize_t len;\n\t\t\t\tif (cur_quote) {\n\t\t\t\t\treport_config_error(CONFIG_UNMATCHED_QUOTE, \"String '%s': missing terminating %c\", src, cur_quote);\n\t\t\t\t\tgoto err_exit;\n\t\t\t\t}\n\t\t\t\tstrcpy(ofs_op, ofs);\n\t\t\t\tlen =  strlen(ofs);\n\t\t\t\tofs += len;\n\t\t\t\tofs_op += len;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Save the wanted text */\n\t\t\tstrncpy(ofs_op, ofs, ofs1 - ofs);\n\t\t\tofs_op += ofs1 - ofs;\n\t\t\tofs = ofs1;\n\n\t\t\tif (*ofs == '\\\\') {\n\t\t\t\t/* It is a '\\' */\n\t\t\t\tofs++;\n\n\t\t\t\tif (!*ofs) {\n\t\t\t\t\tlog_message(LOG_INFO, \"Missing escape char at end: '%s'\", src);\n\t\t\t\t\tgoto err_exit;\n\t\t\t\t}\n\n\t\t\t\tif (*ofs == 'x' && isxdigit(ofs[1])) {\n\t\t\t\t\top_char = 0;\n\t\t\t\t\tofs++;\n\t\t\t\t\twhile (isxdigit(*ofs)) {\n\t\t\t\t\t\top_char <<= 4;\n\t\t\t\t\t\top_char |= isdigit(*ofs) ? *ofs - '0' : (10 + *ofs - (isupper(*ofs)  ? 'A' : 'a'));\n\t\t\t\t\t\tofs++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (*ofs == 'c' && ofs[1]) {\n\t\t\t\t\top_char = *++ofs & 0x1f;\t/* Convert to control character */\n\t\t\t\t\tofs++;\n\t\t\t\t}\n\t\t\t\telse if (*ofs >= '0' && *ofs <= '7') {\n\t\t\t\t\top_char = *ofs++ - '0';\n\t\t\t\t\tif (*ofs >= '0' && *ofs <= '7') {\n\t\t\t\t\t\top_char <<= 3;\n\t\t\t\t\t\top_char += *ofs++ - '0';\n\t\t\t\t\t}\n\t\t\t\t\tif (*ofs >= '0' && *ofs <= '7') {\n\t\t\t\t\t\top_char <<= 3;\n\t\t\t\t\t\top_char += *ofs++ - '0';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tswitch (*ofs) {\n\t\t\t\t\tcase 'a':\n\t\t\t\t\t\top_char = '\\a';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'b':\n\t\t\t\t\t\top_char = '\\b';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'E':\n\t\t\t\t\t\top_char = 0x1b;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'f':\n\t\t\t\t\t\top_char = '\\f';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'n':\n\t\t\t\t\t\top_char = '\\n';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'r':\n\t\t\t\t\t\top_char = '\\r';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 't':\n\t\t\t\t\t\top_char = '\\t';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'v':\n\t\t\t\t\t\top_char = '\\v';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault: /* \\\"'  */\n\t\t\t\t\t\top_char = *ofs;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tofs++;\n\t\t\t\t}\n\n\t\t\t\t*ofs_op++ = op_char;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (cur_quote) {\n\t\t\t\t/* It's the close quote */\n\t\t\t\tofs++;\n\t\t\t\tcur_quote = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (*ofs == '\"' || *ofs == '\\'') {\n\t\t\t\tcur_quote = *ofs++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\n\t\ttoken = MALLOC(ofs_op - op_buf + 1);\n\t\tmemcpy(token, op_buf, ofs_op - op_buf);\n\t\ttoken[ofs_op - op_buf] = '\\0';\n\n\t\t/* Alloc & set the slot */\n\t\tvector_alloc_slot(strvec);\n\t\tvector_set_slot(strvec, token);\n\t}\n\n\tFREE(op_buf);\n\n\tif (!vector_size(strvec)) {\n\t\tfree_strvec(strvec);\n\t\treturn NULL;\n\t}\n\n\treturn strvec;\n\nerr_exit:\n\tfree_strvec(strvec);\n\tFREE(op_buf);\n\treturn NULL;\n}\n\nvector_t *\nalloc_strvec_r(char *string)\n{\n\tchar *cp, *start, *token;\n\tsize_t str_len;\n\tvector_t *strvec;\n\n\tif (!string)\n\t\treturn NULL;\n\n\t/* Create a vector and alloc each command piece */\n\tstrvec = vector_alloc();\n\n\tcp = string;\n\twhile (true) {\n\t\tcp += strspn(cp, WHITE_SPACE);\n\t\tif (!*cp)\n\t\t\tbreak;\n\n\t\tstart = cp;\n\n\t\t/* Save a quoted string without the \"\"s as a single string */\n\t\tif (*start == '\"') {\n\t\t\tstart++;\n\t\t\tif (!(cp = strchr(start, '\"'))) {\n\t\t\t\treport_config_error(CONFIG_UNMATCHED_QUOTE, \"Unmatched quote: '%s'\", string);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstr_len = (size_t)(cp - start);\n\t\t\tcp++;\n\t\t} else {\n\t\t\tcp += strcspn(start, WHITE_SPACE_STR \"\\\"\");\n\t\t\tstr_len = (size_t)(cp - start);\n\t\t}\n\t\ttoken = MALLOC(str_len + 1);\n\t\tmemcpy(token, start, str_len);\n\t\ttoken[str_len] = '\\0';\n\n\t\t/* Alloc & set the slot */\n\t\tvector_alloc_slot(strvec);\n\t\tvector_set_slot(strvec, token);\n\t}\n\n\tif (!vector_size(strvec)) {\n\t\tfree_strvec(strvec);\n\t\treturn NULL;\n\t}\n\n\treturn strvec;\n}\n\ntypedef struct _seq {\n\tchar *var;\n\tint next;\n\tint last;\n\tint step;\n\tchar *text;\n} seq_t;\n\nstatic list seq_list;\t/* List of seq_t */\n\n#ifdef PARSER_DEBUG\nstatic void\ndump_seqs(void)\n{\n\tseq_t *seq;\n\telement e;\n\n\tLIST_FOREACH(seq_list, seq, e)\n\t\tlog_message(LOG_INFO, \"SEQ: %s => %d -> %d step %d: '%s'\", seq->var, seq->next, seq->last, seq->step, seq->text);\n\tlog_message(LOG_INFO, \"%s\", \"\");\n}\n#endif\n\nstatic void\nfree_seq(void *s)\n{\n\tseq_t *seq = s;\n\n\tFREE(seq->var);\n\tFREE(seq->text);\n\tFREE(seq);\n}\n\nstatic bool\nadd_seq(char *buf)\n{\n\tchar *p = buf + 4;\t\t/* Skip ~SEQ */\n\tlong one, two, three;\n\tlong start, step, end;\n\tseq_t *seq_ent;\n\tchar *var;\n\tchar *var_end;\n\n\tp += strspn(p, \" \\t\");\n\tif (*p++ != '(')\n\t\treturn false;\n\tp += strspn(p, \" \\t\");\n\n\tvar = p;\n\n\tp += strcspn(p, \" \\t,)\");\n\tvar_end = p;\n\tp += strspn(p, \" \\t\");\n\tif (!*p || *p == ')' || p == var) {\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"Invalid ~SEQ definition '%s'\", buf);\n\t\treturn false;\n\t}\n\n\tp++;\n\tdo {\n\t\t// Handle missing number\n\t\tone = strtol(p, &p, 0);\n\t\tp += strspn(p, \" \\t\");\n\t\tif (*p == ')') {\n\t\t\tend = one;\n\t\t\tstep = (end < 1) ? -1 : 1;\n\t\t\tstart = (end < 0) ? -1 : 1;\n\n\t\t\tbreak;\n\t\t}\n\n\t\tif (*p != ',') {\n\t\t\treport_config_error(CONFIG_GENERAL_ERROR, \"Invalid ~SEQ definition '%s'\", buf);\n\t\t\treturn false;\n\t\t}\n\n\t\ttwo = strtol(p + 1, &p, 0);\n\t\tp += strspn(p, \" \\t\");\n\t\tif (*p == ')') {\n\t\t\tstart = one;\n\t\t\tend = two;\n\t\t\tstep = start <= end ? 1 : -1;\n\n\t\t\tbreak;\n\t\t}\n\n\t\tif (*p != ',') {\n\t\t\treport_config_error(CONFIG_GENERAL_ERROR, \"Invalid ~SEQ definition '%s'\", buf);\n\t\t\treturn false;\n\t\t}\n\n\t\tthree = strtol(p + 1, &p, 0);\n\t\tp += strspn(p, \" \\t\");\n\t\tif (*p != ')') {\n\t\t\treport_config_error(CONFIG_GENERAL_ERROR, \"Invalid ~SEQ definition '%s'\", buf);\n\t\t\treturn false;\n\t\t}\n\n\t\tstart = one;\n\t\tstep = two;\n\t\tend = three;\n\n\t\tif (!step ||\n\t\t    (start < end && step < 0) ||\n\t\t    (start > end && step > 0))\n\t\t{\n\t\t\treport_config_error(CONFIG_GENERAL_ERROR, \"Invalid ~SEQ values '%s'\", buf);\n\t\t\treturn false;\n\t\t}\n\t} while (false);\n\n\tp += strspn(p + 1, \" \\t\") + 1;\n\n\tPMALLOC(seq_ent);\n\tseq_ent->var = MALLOC(var_end - var + 1);\n\tstrncpy(seq_ent->var, var, var_end - var);\n\tseq_ent->next = start;\n\tseq_ent->step = step;\n\tseq_ent->last = end;\n\tseq_ent->text = MALLOC(strlen(p) + 1);\n\tstrcpy(seq_ent->text, p);\n\n\tif (!seq_list)\n\t\tseq_list = alloc_list(free_seq, NULL);\n\tlist_add(seq_list, seq_ent);\n\n\treturn true;\n}\n\n#ifdef PARSER_DEBUG\nstatic void\ndump_definitions(void)\n{\n\tdef_t *def;\n\telement e;\n\n\tLIST_FOREACH(defs, def, e)\n\t\tlog_message(LOG_INFO, \"Defn %s = '%s'\", def->name, def->value);\n\tlog_message(LOG_INFO, \"%s\", \"\");\n}\n#endif\n\n/* recursive configuration stream handler */\nstatic int kw_level;\nstatic int block_depth;\n\nstatic bool\nprocess_stream(vector_t *keywords_vec, int need_bob)\n{\n\tunsigned int i;\n\tkeyword_t *keyword_vec;\n\tchar *str;\n\tchar *buf;\n\tvector_t *strvec;\n\tvector_t *prev_keywords = current_keywords;\n\tcurrent_keywords = keywords_vec;\n\tint bob_needed = 0;\n\tbool ret_err = false;\n\tbool ret;\n\n\tbuf = MALLOC(MAXBUF);\n\twhile (read_line(buf, MAXBUF)) {\n\t\tstrvec = alloc_strvec(buf);\n\n\t\tif (!strvec)\n\t\t\tcontinue;\n\n\t\tstr = vector_slot(strvec, 0);\n\n\t\tif (skip_sublevel == -1) {\n\t\t\t/* There wasn't a '{' on the keyword line */\n\t\t\tif (!strcmp(str, BOB)) {\n\t\t\t\t/* We've got the opening '{' now */\n\t\t\t\tskip_sublevel = 1;\n\t\t\t\tneed_bob = 0;\n\t\t\t\tfree_strvec(strvec);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* The skipped keyword doesn't have a {} block, so we no longer want to skip */\n\t\t\tskip_sublevel = 0;\n\t\t}\n\t\tif (skip_sublevel) {\n\t\t\tfor (i = 0; i < vector_size(strvec); i++) {\n\t\t\t\tstr = vector_slot(strvec,i);\n\t\t\t\tif (!strcmp(str,BOB))\n\t\t\t\t\tskip_sublevel++;\n\t\t\t\telse if (!strcmp(str,EOB)) {\n\t\t\t\t\tif (--skip_sublevel == 0)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* If we have reached the outer level of the block and we have\n\t\t\t * nested keyword level, then we need to return to restore the\n\t\t\t * next level up of keywords. */\n\t\t\tif (!strcmp(str, EOB) && skip_sublevel == 0 && kw_level > 0) {\n\t\t\t\tret_err = true;\n\t\t\t\tfree_strvec(strvec);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfree_strvec(strvec);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (need_bob) {\n\t\t\tneed_bob = 0;\n\t\t\tif (!strcmp(str, BOB) && kw_level > 0) {\n\t\t\t\tfree_strvec(strvec);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse\n\t\t\t\treport_config_error(CONFIG_MISSING_BOB, \"Missing '%s' at beginning of configuration block\", BOB);\n\t\t}\n\t\telse if (!strcmp(str, BOB)) {\n\t\t\treport_config_error(CONFIG_UNEXPECTED_BOB, \"Unexpected '%s' - ignoring\", BOB);\n\t\t\tfree_strvec(strvec);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!strcmp(str, EOB) && kw_level > 0) {\n\t\t\tfree_strvec(strvec);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!strncmp(str, \"~SEQ\", 4)) {\n\t\t\tif (!add_seq(buf))\n\t\t\t\treport_config_error(CONFIG_GENERAL_ERROR, \"Invalid ~SEQ specification '%s'\", buf);\n\t\t\tfree_strvec(strvec);\n#ifdef PARSER_DEBUG\n\t\t\tdump_definitions();\n\t\t\tdump_seqs();\n#endif\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (i = 0; i < vector_size(keywords_vec); i++) {\n\t\t\tkeyword_vec = vector_slot(keywords_vec, i);\n\n\t\t\tif (!strcmp(keyword_vec->string, str)) {\n\t\t\t\tif (!keyword_vec->active) {\n\t\t\t\t\tif (!strcmp(vector_slot(strvec, vector_size(strvec)-1), BOB))\n\t\t\t\t\t\tskip_sublevel = 1;\n\t\t\t\t\telse\n\t\t\t\t\t\tskip_sublevel = -1;\n\n\t\t\t\t\t/* Sometimes a process wants to know if another process\n\t\t\t\t\t * has any of a type of configuration. For example, there\n\t\t\t\t\t * is no point starting the VRRP process of there are no\n\t\t\t\t\t * vrrp instances, and so the parent process would be\n\t\t\t\t\t * interested in that. */\n\t\t\t\t\tif (keyword_vec->handler)\n\t\t\t\t\t\t(*keyword_vec->handler)(NULL);\n\t\t\t\t}\n\n\t\t\t\t/* There is an inconsistency here. 'static_ipaddress' for example\n\t\t\t\t * does not have sub levels, but needs a '{' */\n\t\t\t\tif (keyword_vec->sub) {\n\t\t\t\t\t/* Remove a trailing '{' */\n\t\t\t\t\tchar *bob = vector_slot(strvec, vector_size(strvec)-1) ;\n\t\t\t\t\tif (!strcmp(bob, BOB)) {\n\t\t\t\t\t\tvector_unset(strvec, vector_size(strvec)-1);\n\t\t\t\t\t\tFREE(bob);\n\t\t\t\t\t\tbob_needed = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tbob_needed = 1;\n\t\t\t\t}\n\n\t\t\t\tif (keyword_vec->active && keyword_vec->handler) {\n\t\t\t\t\tbuf_extern = buf;\t/* In case the raw line wants to be accessed */\n\t\t\t\t\t(*keyword_vec->handler) (strvec);\n\t\t\t\t}\n\n\t\t\t\tif (keyword_vec->sub) {\n\t\t\t\t\tkw_level++;\n\t\t\t\t\tret = process_stream(keyword_vec->sub, bob_needed);\n\t\t\t\t\tkw_level--;\n\n\t\t\t\t\t/* We mustn't run any close handler if the block was skipped */\n\t\t\t\t\tif (!ret && keyword_vec->active && keyword_vec->sub_close_handler)\n\t\t\t\t\t\t(*keyword_vec->sub_close_handler) ();\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (i >= vector_size(keywords_vec))\n\t\t\treport_config_error(CONFIG_UNKNOWN_KEYWORD, \"Unknown keyword '%s'\", str);\n\n\t\tfree_strvec(strvec);\n\t}\n\n\tcurrent_keywords = prev_keywords;\n\tFREE(buf);\n\treturn ret_err;\n}\n\nstatic bool\nread_conf_file(const char *conf_file)\n{\n\tFILE *stream;\n\tglob_t globbuf;\n\tsize_t i;\n\tint\tres;\n\tstruct stat stb;\n\tunsigned num_matches = 0;\n\n\tglobbuf.gl_offs = 0;\n\tres = glob(conf_file, GLOB_MARK\n#if HAVE_DECL_GLOB_BRACE\n\t\t\t\t\t| GLOB_BRACE\n#endif\n\t\t\t\t\t\t    , NULL, &globbuf);\n\n\tif (res) {\n\t\tif (res == GLOB_NOMATCH)\n\t\t\tlog_message(LOG_INFO, \"No config files matched '%s'.\", conf_file);\n\t\telse\n\t\t\tlog_message(LOG_INFO, \"Error reading config file(s): glob(\\\"%s\\\") returned %d, skipping.\", conf_file, res);\n\t\treturn true;\n\t}\n\n\tfor (i = 0; i < globbuf.gl_pathc; i++) {\n\t\tif (globbuf.gl_pathv[i][strlen(globbuf.gl_pathv[i])-1] == '/') {\n\t\t\t/* This is a directory - so skip */\n\t\t\tcontinue;\n\t\t}\n\n\t\tlog_message(LOG_INFO, \"Opening file '%s'.\", globbuf.gl_pathv[i]);\n\t\tstream = fopen(globbuf.gl_pathv[i], \"r\");\n\t\tif (!stream) {\n\t\t\tlog_message(LOG_INFO, \"Configuration file '%s' open problem (%s) - skipping\"\n\t\t\t\t       , globbuf.gl_pathv[i], strerror(errno));\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Make sure what we have opened is a regular file, and not for example a directory or executable */\n\t\tif (fstat(fileno(stream), &stb) ||\n\t\t    !S_ISREG(stb.st_mode) ||\n\t\t    (stb.st_mode & (S_IXUSR | S_IXGRP | S_IXOTH))) {\n\t\t\tlog_message(LOG_INFO, \"Configuration file '%s' is not a regular non-executable file - skipping\", globbuf.gl_pathv[i]);\n\t\t\tfclose(stream);\n\t\t\tcontinue;\n\t\t}\n\n\t\tnum_matches++;\n\n\t\tcurrent_stream = stream;\n\n\t\t/* We only want to report the file name if there is more than one file used */\n\t\tif (current_file_name || globbuf.gl_pathc > 1)\n\t\t\tcurrent_file_name = globbuf.gl_pathv[i];\n\t\tcurrent_file_line_no = 0;\n\n\t\tint curdir_fd = -1;\n\t\tif (strchr(globbuf.gl_pathv[i], '/')) {\n\t\t\t/* If the filename contains a directory element, change to that directory.\n\t\t\t   The man page open(2) states that fchdir() didn't support O_PATH until Linux 3.5,\n\t\t\t   even though testing on Linux 3.1 shows it appears to work. To be safe, don't\n\t\t\t   use it until Linux 3.5. */\n\t\t\tcurdir_fd = open(\".\", O_RDONLY | O_DIRECTORY\n#if HAVE_DECL_O_PATH && LINUX_VERSION_CODE >= KERNEL_VERSION(3,5,0)\n\t\t\t\t\t\t\t\t     | O_PATH\n#endif\n\t\t\t\t\t\t\t\t\t     );\n\n\t\t\tchar *confpath = strdup(globbuf.gl_pathv[i]);\n\t\t\tdirname(confpath);\n\t\t\tif (chdir(confpath) < 0)\n\t\t\t\tlog_message(LOG_INFO, \"chdir(%s) error (%s)\", confpath, strerror(errno));\n\t\t\tfree(confpath);\n\t\t}\n\n\t\tprocess_stream(current_keywords, 0);\n\t\tfclose(stream);\n\n\t\tfree_list(&seq_list);\n\n\t\t/* If we changed directory, restore the previous directory */\n\t\tif (curdir_fd != -1) {\n\t\t\tif ((res = fchdir(curdir_fd)))\n\t\t\t\tlog_message(LOG_INFO, \"Failed to restore previous directory after include\");\n\t\t\tclose(curdir_fd);\n\t\t\tif (res)\n\t\t\t\treturn true;\n\t\t}\n\t}\n\n\tglobfree(&globbuf);\n\n\tif (!num_matches)\n\t\tlog_message(LOG_INFO, \"No config files matched '%s'.\", conf_file);\n\n\treturn false;\n}\n\nbool check_conf_file(const char *conf_file)\n{\n\tglob_t globbuf;\n\tsize_t i;\n\tbool ret = true;\n\tint res;\n\tstruct stat stb;\n\tunsigned num_matches = 0;\n\n\tglobbuf.gl_offs = 0;\n\tres = glob(conf_file, GLOB_MARK\n#if HAVE_DECL_GLOB_BRACE\n\t\t\t\t\t| GLOB_BRACE\n#endif\n\t\t\t\t\t\t    , NULL, &globbuf);\n\tif (res) {\n\t\treport_config_error(CONFIG_FILE_NOT_FOUND, \"Unable to find configuration file %s (glob returned %d)\", conf_file, res);\n\t\treturn false;\n\t}\n\n\tfor (i = 0; i < globbuf.gl_pathc; i++) {\n\t\tif (globbuf.gl_pathv[i][strlen(globbuf.gl_pathv[i])-1] == '/') {\n\t\t\t/* This is a directory - so skip */\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (access(globbuf.gl_pathv[i], R_OK)) {\n\t\t\tlog_message(LOG_INFO, \"Unable to read configuration file %s\", globbuf.gl_pathv[i]);\n\t\t\tret = false;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Make sure that the file is a regular file, and not for example a directory or executable */\n\t\tif (stat(globbuf.gl_pathv[i], &stb) ||\n\t\t    !S_ISREG(stb.st_mode) ||\n\t\t     (stb.st_mode & (S_IXUSR | S_IXGRP | S_IXOTH))) {\n\t\t\tlog_message(LOG_INFO, \"Configuration file '%s' is not a regular non-executable file\", globbuf.gl_pathv[i]);\n\t\t\tret = false;\n\t\t\tbreak;\n\t\t}\n\n\t\tnum_matches++;\n\t}\n\n\tif (ret) {\n\t\tif (num_matches > 1)\n\t\t\treport_config_error(CONFIG_MULTIPLE_FILES, \"WARNING, more than one file matches configuration file %s, using %s\", conf_file, globbuf.gl_pathv[0]);\n\t\telse if (num_matches == 0) {\n\t\t\treport_config_error(CONFIG_FILE_NOT_FOUND, \"Unable to find configuration file %s\", conf_file);\n\t\t\tret = false;\n\t\t}\n\t}\n\n\tglobfree(&globbuf);\n\n\treturn ret;\n}\n\nstatic bool\ncheck_include(char *buf)\n{\n\tvector_t *strvec;\n\tbool ret = false;\n\tFILE *prev_stream;\n\tconst char *prev_file_name;\n\tsize_t prev_file_line_no;\n\n\t/* Simple check first for include */\n\tif (!strstr(buf, \"include\"))\n\t\treturn false;\n\n\tstrvec = alloc_strvec(buf);\n\n\tif (!strvec)\n\t\treturn false;\n\n\tif(!strcmp(\"include\", vector_slot(strvec, 0)) && vector_size(strvec) == 2) {\n\t\tprev_stream = current_stream;\n\t\tprev_file_name = current_file_name;\n\t\tprev_file_line_no = current_file_line_no;\n\n\t\tread_conf_file(vector_slot(strvec, 1));\n\n\t\tcurrent_stream = prev_stream;\n\t\tcurrent_file_name = prev_file_name;\n\t\tcurrent_file_line_no = prev_file_line_no;\n\n\t\tret = true;\n\t}\n\n\tfree_strvec(strvec);\n\treturn ret;\n}\n\nstatic def_t *\nfind_definition(const char *name, size_t len, bool definition)\n{\n\telement e;\n\tdef_t *def;\n\tconst char *p;\n\tbool using_braces = false;\n\tbool allow_multiline;\n\n\tif (LIST_ISEMPTY(defs))\n\t\treturn NULL;\n\n\tif (!definition && *name == BOB[0]) {\n\t\tusing_braces = true;\n\t\tname++;\n\t}\n\n\tif (!isalpha(*name) && *name != '_')\n\t\treturn NULL;\n\n\tif (!len) {\n\t\tfor (len = 1, p = name + 1; *p != '\\0' && (isalnum(*p) || *p == '_'); len++, p++);\n\n\t\t/* Check we have a suitable end character */\n\t\tif (using_braces && *p != EOB[0])\n\t\t\treturn NULL;\n\n\t\tif (!using_braces && !definition &&\n\t\t     *p != ' ' && *p != '\\t' && *p != '\\0')\n\t\t\treturn NULL;\n\t}\n\n\tif (definition ||\n\t    (!using_braces && name[len] == '\\0') ||\n\t    (using_braces && name[len+1] == '\\0'))\n\t\tallow_multiline = true;\n\telse\n\t\tallow_multiline = false;\n\n\tfor (e = LIST_HEAD(defs); e; ELEMENT_NEXT(e)) {\n\t\tdef = ELEMENT_DATA(e);\n\t\tif (def->name_len == len &&\n\t\t    (allow_multiline || !def->multiline) &&\n\t\t    !strncmp(def->name, name, len))\n\t\t\treturn def;\n\t}\n\n\treturn NULL;\n}\n\nstatic bool\nreplace_param(char *buf, size_t max_len, char **multiline_ptr_ptr)\n{\n\tchar *cur_pos = buf;\n\tsize_t len_used = strlen(buf);\n\tdef_t *def;\n\tchar *s, *d, *e;\n\tssize_t i;\n\tsize_t extra_braces;\n\tsize_t replacing_len;\n\tchar *next_ptr = NULL;\n\tbool found_defn = false;\n\tchar *multiline_ptr = *multiline_ptr_ptr;\n\n\twhile ((cur_pos = strchr(cur_pos, '$')) && cur_pos[1] != '\\0') {\n\t\tif ((def = find_definition(cur_pos + 1, 0, false))) {\n\t\t\tfound_defn = true;\n\t\t\textra_braces = cur_pos[1] == BOB[0] ? 2 : 0;\n\t\t\tnext_ptr = multiline_ptr;\n\n\t\t\t/* We are in a multiline expansion, and now have another\n\t\t\t * one, so save the previous state on the multiline stack */\n\t\t\tif (def->multiline && multiline_ptr) {\n\t\t\t\tif (!LIST_EXISTS(multiline_stack))\n\t\t\t\t\tmultiline_stack = alloc_list(NULL, NULL);\n\t\t\t\tlist_add(multiline_stack, multiline_ptr);\n\t\t\t}\n\n\t\t\tif (def->fn) {\n\t\t\t\t/* This is a standard definition that uses a function for the replacement text */\n\t\t\t\tif (def->value)\n\t\t\t\t\tFREE(def->value);\n\t\t\t\tdef->value = (*def->fn)();\n\t\t\t\tdef->value_len = strlen(def->value);\n\t\t\t}\n\n\t\t\t/* Ensure there is enough room to replace $PARAM or ${PARAM} with value */\n\t\t\tif (def->multiline) {\n\t\t\t\treplacing_len = strcspn(def->value, DEF_LINE_END);\n\t\t\t\tnext_ptr = def->value + replacing_len + 1;\n\t\t\t\tmultiline_ptr = next_ptr;\n\t\t\t}\n\t\t\telse\n\t\t\t\treplacing_len = def->value_len;\n\n\t\t\tif (len_used + replacing_len - (def->name_len + 1 + extra_braces) >= max_len) {\n\t\t\t\tlog_message(LOG_INFO, \"Parameter substitution on line '%s' would exceed maximum line length\", buf);\n\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\t\tif (def->name_len + 1 + extra_braces != replacing_len) {\n\t\t\t\t/* We need to move the existing text */\n\t\t\t\tif (def->name_len + 1 + extra_braces < replacing_len) {\n\t\t\t\t\t/* We are lengthening the buf text */\n\t\t\t\t\ts = cur_pos + strlen(cur_pos);\n\t\t\t\t\td = s - (def->name_len + 1 + extra_braces) + replacing_len;\n\t\t\t\t\te = cur_pos;\n\t\t\t\t\ti = -1;\n\t\t\t\t} else {\n\t\t\t\t\t/* We are shortening the buf text */\n\t\t\t\t\ts = cur_pos + (def->name_len + 1 + extra_braces) - replacing_len;\n\t\t\t\t\td = cur_pos;\n\t\t\t\t\te = cur_pos + strlen(cur_pos);\n\t\t\t\t\ti = 1;\n\t\t\t\t}\n\n\t\t\t\tdo {\n\t\t\t\t\t*d = *s;\n\t\t\t\t\tif (s == e)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\td += i;\n\t\t\t\t\ts += i;\n\t\t\t\t} while (true);\n\n\t\t\t\tlen_used = len_used + replacing_len - (def->name_len + 1 + extra_braces);\n\t\t\t}\n\n\t\t\t/* Now copy the replacement text */\n\t\t\tstrncpy(cur_pos, def->value, replacing_len);\n\n\t\t\tif (def->value[strspn(def->value, \" \\t\")] == '~')\n\t\t\t\tbreak;\n\t\t}\n\t\telse\n\t\t\tcur_pos++;\n\t}\n\n\t/* If we did a replacement, update the multiline_ptr */\n\tif (found_defn)\n\t\t*multiline_ptr_ptr = next_ptr;\n\n\treturn found_defn;\n}\n\nstatic void\nfree_definition(void *d)\n{\n\tdef_t *def = d;\n\n\tFREE(def->name);\n\tFREE_PTR(def->value);\n\tFREE(def);\n}\n\nstatic def_t*\nset_definition(const char *name, const char *value)\n{\n\tdef_t *def;\n\tsize_t name_len = strlen(name);\n\n\tif ((def = find_definition(name, name_len, false))) {\n\t\tFREE(def->value);\n\t\tdef->fn = NULL;\t\t/* Allow a standard definition to be overridden */\n\t}\n\telse {\n\t\tdef = MALLOC(sizeof(*def));\n\t\tdef->name_len = name_len;\n\t\tdef->name = MALLOC(name_len + 1);\n\t\tstrcpy(def->name, name);\n\n\t\tif (!LIST_EXISTS(defs))\n\t\t\tdefs = alloc_list(free_definition, NULL);\n\t\tlist_add(defs, def);\n\t}\n\tdef->value_len = strlen(value);\n\tdef->value = MALLOC(def->value_len + 1);\n\tstrcpy(def->value, value);\n\n#ifdef PARSER_DEBUG\n\tlog_message(LOG_INFO, \"Definition %s now '%s'\", def->name, def->value);\n#endif\n\n\treturn def;\n}\n\n/* A definition is of the form $NAME=TEXT */\nstatic def_t*\ncheck_definition(const char *buf)\n{\n\tconst char *p;\n\tdef_t* def;\n\tsize_t def_name_len;\n\tchar *str;\n\n\tif (buf[0] != '$')\n\t\treturn false;\n\n\tif (!isalpha(buf[1]) && buf[1] != '_')\n\t\treturn NULL;\n\n\tfor (p = buf + 2; *p; p++) {\n\t\tif (*p == '=')\n\t\t\tbreak;\n\t\tif (!isalnum(*p) &&\n\t\t    !isdigit(*p) &&\n\t\t    *p != '_')\n\t\t\treturn NULL;\n\t}\n\n\tdef_name_len = (size_t)(p - &buf[1]);\n\n\tp += strspn(p, \" \\t\");\n\tif (*p != '=')\n\t\treturn NULL;\n\n\tif ((def = find_definition(&buf[1], def_name_len, true))) {\n\t\tFREE(def->value);\n\t\tdef->fn = NULL;\t\t/* Allow a standard definition to be overridden */\n\t}\n\telse {\n\t\tdef = MALLOC(sizeof(*def));\n\t\tdef->name_len = def_name_len;\n\t\tstr = MALLOC(def->name_len + 1);\n\t\tstrncpy(str, &buf[1], def->name_len);\n\t\tstr[def->name_len] = '\\0';\n\t\tdef->name = str;\n\n\t\tif (!LIST_EXISTS(defs))\n\t\t\tdefs = alloc_list(free_definition, NULL);\n\t\tlist_add(defs, def);\n\t}\n\n\t/* Skip leading whitespace */\n\tp += strspn(p + 1, \" \\t\") + 1;\n\tdef->value_len = strlen(p);\n\tif (p[def->value_len - 1] == '\\\\') {\n\t\t/* Remove trailing whitespace */\n\t\twhile (def->value_len >= 2 &&\n\t\t       isblank(p[def->value_len - 2]))\n\t\t\tdef->value_len--;\n\n\t\tif (def->value_len < 2) {\n\t\t\t/* If the string has nothing except spaces and terminating '\\'\n\t\t\t * point to the string terminator. */\n\t\t\tp += def->value_len;\n\t\t\tdef->value_len = 0;\n\t\t}\n\t\tdef->multiline = true;\n\t} else\n\t\tdef->multiline = false;\n\n\tstr = MALLOC(def->value_len + 1);\n\tstrcpy(str, p);\n\tdef->value = str;\n\n\t/* If it a multiline definition, we need to mark the end of the first line\n\t * by overwriting the '\\' with the line end marker. */\n\tif (def->value_len >= 2 && def->multiline)\n\t\tdef->value[def->value_len - 1] = DEF_LINE_END[0];\n\n\treturn def;\n}\n\nstatic void\nadd_std_definition(const char *name, const char *value, char *(*fn)(void))\n{\n\tdef_t* def;\n\n\tdef = MALLOC(sizeof(*def));\n\tdef->name_len = strlen(name);\n\tdef->name = MALLOC(def->name_len + 1);\n\tstrcpy(def->name, name);\n\tif (value) {\n\t\tdef->value_len = strlen(value);\n\t\tdef->value = MALLOC(def->value_len + 1);\n\t\tstrcpy(def->value, value);\n\t}\n\tdef->fn = fn;\n\n\tif (!LIST_EXISTS(defs))\n\t\tdefs = alloc_list(free_definition, NULL);\n\tlist_add(defs, def);\n}\n\nstatic void\nset_std_definitions(void)\n{\n\tadd_std_definition(\"_PWD\", NULL, get_cwd);\n\tadd_std_definition(\"_INSTANCE\", NULL, get_instance);\n}\n\nstatic void\nfree_parser_data(void)\n{\n\tif (LIST_EXISTS(defs))\n\t\tfree_list(&defs);\n\n\tif (LIST_EXISTS(multiline_stack))\n\t\tfree_list(&multiline_stack);\n}\n\n/* decomment() removes comments, the escaping of comment start characters,\n * and leading and trailing whitespace, including whitespace before a\n * terminating \\ character */\nstatic void\ndecomment(char *str)\n{\n\tbool quote = false;\n\tbool cont = false;\n\tchar *skip = NULL;\n\tchar *p = str + strspn(str, \" \\t\");\n\n\t/* Remove leading whitespace */\n\tif (p != str)\n\t\tmemmove(str, p, strlen(p) + 1);\n\n\tp = str;\n\twhile ((p = strpbrk(p, \"!#\\\"\\\\\"))) {\n\t\tif (*p == '\"') {\n\t\t\tif (!skip)\n\t\t\t\tquote = !quote;\n\t\t\tp++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (*p == '\\\\') {\n\t\t\tif (p[1]) {\n\t\t\t\t/* Don't modify quoted strings */\n\t\t\t\tif (!quote && (p[1] == '#' || p[1] == '!')) {\n\t\t\t\t\tmemmove(p, p + 1, strlen(p + 1) + 1);\n\t\t\t\t\tp++;\n\t\t\t\t} else\n\t\t\t\t\tp += 2;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t*p = '\\0';\n\t\t\tcont = true;\n\t\t\tbreak;\n\t\t}\n\t\tif (!quote && !skip && (*p == '!' || *p == '#'))\n\t\t\tskip = p;\n\t\tp++;\n\t}\n\n\tif (quote)\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"Unterminated quote '%s'\", str);\n\n\tif (skip)\n\t\t*skip = '\\0';\n\n\t/* Remove trailing whitespace */\n\tp = str + strlen(str) - 1;\n\twhile (p >= str && isblank(*p))\n\t\t*p-- = '\\0';\n\tif (cont) {\n\t\t*++p = '\\\\';\n\t\t*++p = '\\0';\n\t}\n}\n\nstatic bool\nread_line(char *buf, size_t size)\n{\n\tsize_t len ;\n\tbool eof = false;\n\tsize_t config_id_len;\n\tchar *buf_start;\n\tbool rev_cmp;\n\tsize_t ofs;\n\tbool recheck;\n\tstatic def_t *def = NULL;\n\tstatic char *next_ptr = NULL;\n\tbool multiline_param_def = false;\n\tchar *end;\n\tstatic char *line_residue = NULL;\n\tsize_t skip;\n\tchar *p;\n\n\tconfig_id_len = config_id ? strlen(config_id) : 0;\n\tdo {\n\t\tif (line_residue) {\n\t\t\tstrcpy(buf, line_residue);\n\t\t\tFREE(line_residue);\n\t\t\tline_residue = NULL;\n\t\t}\n\t\telse if (next_ptr) {\n\t\t\t/* We are expanding a multiline parameter, so copy next line */\n\t\t\tend = strchr(next_ptr, DEF_LINE_END[0]);\n\t\t\tif (!end) {\n\t\t\t\tstrcpy(buf, next_ptr);\n\t\t\t\tif (!LIST_ISEMPTY(multiline_stack)) {\n\t\t\t\t\tnext_ptr = LIST_TAIL_DATA(multiline_stack);\n\t\t\t\t\tlist_remove(multiline_stack, multiline_stack->tail);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tnext_ptr = NULL;\n\t\t\t} else {\n\t\t\t\tstrncpy(buf, next_ptr, (size_t)(end - next_ptr));\n\t\t\t\tbuf[end - next_ptr] = '\\0';\n\t\t\t\tnext_ptr = end + 1;\n\t\t\t}\n\t\t}\n\t\telse if (!LIST_ISEMPTY(seq_list)) {\n\t\t\tseq_t *seq = LIST_TAIL_DATA(seq_list);\n\t\t\tchar val[12];\n\t\t\tsnprintf(val, sizeof(val), \"%d\", seq->next);\n#ifdef PARSER_DEBUG\n\t\t\tlog_message(LOG_INFO, \"Processing seq %d of %s for '%s'\",  seq->next, seq->var, seq->text);\n#endif\n\t\t\tset_definition(seq->var, val);\n\t\t\tstrcpy(buf, seq->text);\n\t\t\tseq->next += seq->step;\n\t\t\tif ((seq->step > 0 && seq->next > seq->last) ||\n\t\t\t    (seq->step < 0 && seq->next < seq->last)) {\n#ifdef PARSER_DEBUG\n\t\t\t\tlog_message(LOG_INFO, \"Removing seq %s for '%s'\", seq->var, seq->text);\n#endif\n\t\t\t\tlist_remove(seq_list, seq_list->tail);\n\t\t\t}\n\t\t}\n\t\telse {\nretry:\n\t\t\tif (!fgets(buf, (int)size, current_stream))\n\t\t\t{\n\t\t\t\teof = true;\n\t\t\t\tbuf[0] = '\\0';\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Check if we have read the end of a line */\n\t\t\tlen = strlen(buf);\n\t\t\tif (buf[0] && buf[len-1] == '\\n')\n\t\t\t\tcurrent_file_line_no++;\n\n\t\t\t/* Remove end of line chars */\n\t\t\twhile (len && (buf[len-1] == '\\n' || buf[len-1] == '\\r'))\n\t\t\t\tlen--;\n\n\t\t\t/* Skip blank lines */\n\t\t\tif (!len)\n\t\t\t\tgoto retry;\n\n\t\t\tbuf[len] = '\\0';\n\n\t\t\tdecomment(buf);\n\t\t}\n\n\t\tlen = strlen(buf);\n\n\t\t/* Handle multi-line definitions */\n\t\tif (multiline_param_def) {\n\t\t\t/* Remove trailing whitespace */\n\t\t\tif (len && buf[len-1] == '\\\\') {\n\t\t\t\tlen--;\n\t\t\t\twhile (len >= 1 && isblank(buf[len - 1]))\n\t\t\t\t\tlen--;\n\t\t\t\tbuf[len++] = DEF_LINE_END[0];\n\t\t\t} else {\n\t\t\t\tmultiline_param_def = false;\n\t\t\t\tif (!def->value_len)\n\t\t\t\t\tdef->multiline = false;\n\t\t\t}\n\n\t\t\t/* Don't add blank lines */\n\t\t\tif (len >= 2 ||\n\t\t\t    (len && !multiline_param_def)) {\n\t\t\t\t/* Add the line to the definition */\n\t\t\t\tdef->value = REALLOC(def->value, def->value_len + len + 1);\n\t\t\t\tstrncpy(def->value + def->value_len, buf, len);\n\t\t\t\tdef->value_len += len;\n\t\t\t\tdef->value[def->value_len] = '\\0';\n\t\t\t}\n\n\t\t\tbuf[0] = '\\0';\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (len == 0)\n\t\t\tcontinue;\n\n\t\trecheck = false;\n\t\tdo {\n\t\t\tif (buf[0] == '@') {\n\t\t\t\t/* If the line starts '@', check the following word matches the system id.\n\t\t\t\t   @^ reverses the sense of the match */\n\t\t\t\tif (buf[1] == '^') {\n\t\t\t\t\trev_cmp = true;\n\t\t\t\t\tofs = 2;\n\t\t\t\t} else {\n\t\t\t\t\trev_cmp = false;\n\t\t\t\t\tofs = 1;\n\t\t\t\t}\n\n\t\t\t\t/* We need something after the system_id */\n\t\t\t\tif (!(buf_start = strpbrk(buf + ofs, \" \\t\"))) {\n\t\t\t\t\tbuf[0] = '\\0';\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t/* Check if config_id matches/doesn't match as appropriate */\n\t\t\t\tif ((!config_id ||\n\t\t\t\t     (size_t)(buf_start - (buf + ofs)) != config_id_len ||\n\t\t\t\t     strncmp(buf + ofs, config_id, config_id_len)) != rev_cmp) {\n\t\t\t\t\tbuf[0] = '\\0';\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t/* Remove the @config_id from start of line */\n\t\t\t\tbuf_start += strspn(buf_start, \" \\t\");\n\t\t\t\tlen -= (buf_start - buf);\n\t\t\t\tmemmove(buf, buf_start, len + 1);\n\t\t\t}\n\n\t\t\tif (buf[0] == '$' && (def = check_definition(buf))) {\n\t\t\t\t/* check_definition() saves the definition */\n\t\t\t\tif (def->multiline)\n\t\t\t\t\tmultiline_param_def = true;\n\t\t\t\tbuf[0] = '\\0';\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (buf[0] == '~')\n\t\t\t\tbreak;\n\n\t\t\tif (!LIST_ISEMPTY(defs) && (p = strchr(buf, '$'))) {\n\t\t\t\tif (!replace_param(buf, size, &next_ptr)) {\n\t\t\t\t\t/* If nothing has changed, we don't need to do any more processing */\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (buf[0] == '@')\n\t\t\t\t\trecheck = true;\n\t\t\t\tif (strchr(buf, '$'))\n\t\t\t\t\trecheck = true;\n\t\t\t}\n\t\t} while (recheck);\n\t} while (buf[0] == '\\0' || check_include(buf));\n\n\t/* Search for BOB[0] or EOB[0] not in \"\" */\n\tif (buf[0]) {\n\t\tp = buf;\n\t\tif (p[0] != BOB[0] && p[0] != EOB[0]) {\n\t\t\twhile ((p = strpbrk(p, BOB EOB \"\\\"\"))) {\n\t\t\t\tif (*p != '\"')\n\t\t\t\t\tbreak;\n\n\t\t\t\t/* Skip over anything in \"\"s */\n\t\t\t\tif (!(p = strchr(p + 1, '\"')))\n\t\t\t\t\tbreak;\n\n\t\t\t\tp++;\n\t\t\t}\n\t\t}\n\n\t\tif (p && (p[0] == BOB[0] || p[0] == EOB[0])) {\n\t\t\tif (p == buf)\n\t\t\t\tskip = strspn(p + 1, \" \\t\") + 1;\n\t\t\telse\n\t\t\t\tskip = 0;\n\n\t\t\tif (p[skip]) {\n\t\t\t\t/* Skip trailing whitespace */\n\t\t\t\tlen = strlen(p + skip);\n\t\t\t\twhile (len && (p[skip+len-1] == ' ' || p[skip+len-1] == '\\t'))\n\t\t\t\t\tlen--;\n\t\t\t\tline_residue = MALLOC(len + 1);\n\t\t\t\tp[skip+len] = '\\0';\n\t\t\t\tstrcpy(line_residue, p + skip);\n\t\t\t\tp[skip] = '\\0';\n\t\t\t}\n\t\t}\n\n\t\t/* Skip trailing whitespace */\n\t\tlen = strlen(buf);\n\t\twhile (len && (buf[len-1] == ' ' || buf[len-1] == '\\t'))\n\t\t\tlen--;\n\t\tbuf[len] = '\\0';\n\n\t\t/* Check that we haven't got too many '}'s */\n\t\tif (!strcmp(buf, BOB))\n\t\t\tblock_depth++;\n\t\telse if (!strcmp(buf, EOB)) {\n\t\t\tif (--block_depth < 0) {\n\t\t\t\treport_config_error(CONFIG_UNEXPECTED_EOB, \"Extra '}' found\");\n\t\t\t\tblock_depth = 0;\n\t\t\t}\n\t\t}\n\t}\n\n#ifdef PARSER_DEBUG\n\tlog_message(LOG_INFO, \"read_line(%d): '%s'\", block_depth, buf);\n#endif\n\n\treturn !eof;\n}\n\nvoid\nalloc_value_block(void (*alloc_func) (vector_t *), const char *block_type)\n{\n\tchar *buf;\n\tchar *str = NULL;\n\tvector_t *vec = NULL;\n\tbool first_line = true;\n\n\tbuf = (char *) MALLOC(MAXBUF);\n\twhile (read_line(buf, MAXBUF)) {\n\t\tif (!(vec = alloc_strvec(buf)))\n\t\t\tcontinue;\n\n\t\tif (first_line) {\n\t\t\tfirst_line = false;\n\n\t\t\tif (!strcmp(vector_slot(vec, 0), BOB)) {\n\t\t\t\tfree_strvec(vec);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tlog_message(LOG_INFO, \"'%s' missing from beginning of block %s\", BOB, block_type);\n\t\t}\n\n\t\tstr = vector_slot(vec, 0);\n\t\tif (!strcmp(str, EOB)) {\n\t\t\tfree_strvec(vec);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (vector_size(vec))\n\t\t\t(*alloc_func) (vec);\n\n\t\tfree_strvec(vec);\n\t}\n\tFREE(buf);\n}\n\nstatic vector_t *read_value_block_vec;\nstatic void\nread_value_block_line(vector_t *strvec)\n{\n\tsize_t word;\n\tchar *str;\n\tchar *dup;\n\n\tif (!read_value_block_vec)\n\t\tread_value_block_vec = vector_alloc();\n\n\tvector_foreach_slot(strvec, str, word) {\n\t\tdup = (char *) MALLOC(strlen(str) + 1);\n\t\tstrcpy(dup, str);\n\t\tvector_alloc_slot(read_value_block_vec);\n\t\tvector_set_slot(read_value_block_vec, dup);\n\t}\n}\n\nvector_t *\nread_value_block(vector_t *strvec)\n{\n\tvector_t *ret_vec;\n\n\talloc_value_block(read_value_block_line, vector_slot(strvec,0));\n\n\tret_vec = read_value_block_vec;\n\tread_value_block_vec = NULL;\n\n\treturn ret_vec;\n}\n\nvoid *\nset_value(vector_t *strvec)\n{\n\tchar *str;\n\tsize_t size;\n\tchar *alloc;\n\n\tif (vector_size(strvec) < 2)\n\t\treturn NULL;\n\n\tstr = vector_slot(strvec, 1);\n\tsize = strlen(str);\n\n\talloc = (char *) MALLOC(size + 1);\n\tif (!alloc)\n\t\treturn NULL;\n\n\tmemcpy(alloc, str, size);\n\n\treturn alloc;\n}\n\nbool\nread_timer(vector_t *strvec, size_t index, unsigned long *res, unsigned long min_time, unsigned long max_time, __attribute__((unused)) bool ignore_error)\n{\n\tunsigned long timer;\n\tchar *endptr;\n\tchar *warn = \"\";\n\n#ifndef _STRICT_CONFIG_\n\tif (ignore_error && !__test_bit(CONFIG_TEST_BIT, &debug))\n\t\twarn = \"WARNING - \";\n#endif\n\n\tif (!max_time)\n\t\tmax_time = TIMER_MAX;\n\n\terrno = 0;\n\ttimer = strtoul(vector_slot(strvec, index), &endptr, 10);\n\t*res = (timer > TIMER_MAX ? TIMER_MAX : timer) * TIMER_HZ;\n\n\tif (FMT_STR_VSLOT(strvec, index)[0] == '-')\n\t\treport_config_error(CONFIG_INVALID_NUMBER, \"%snegative number '%s'\", warn, FMT_STR_VSLOT(strvec, index));\n\telse if (*endptr)\n\t\treport_config_error(CONFIG_INVALID_NUMBER, \"%sinvalid number '%s'\", warn, FMT_STR_VSLOT(strvec, index));\n\telse if (errno == ERANGE || timer > TIMER_MAX)\n\t\treport_config_error(CONFIG_INVALID_NUMBER, \"%snumber '%s' outside timer range\", warn, FMT_STR_VSLOT(strvec, index));\n\telse if (timer < min_time || timer > max_time)\n\t\treport_config_error(CONFIG_INVALID_NUMBER, \"number '%s' outside range [%ld, %ld]\", FMT_STR_VSLOT(strvec, index), min_time, max_time ? max_time : TIMER_MAX);\n\telse\n\t\treturn true;\n\n#ifdef _STRICT_CONFIG_\n\treturn false;\n#else\n\treturn ignore_error && timer >= min_time && timer <= max_time && !__test_bit(CONFIG_TEST_BIT, &debug);\n#endif\n}\n\n/* Checks for on/true/yes or off/false/no */\nint\ncheck_true_false(char *str)\n{\n\tif (!strcmp(str, \"true\") || !strcmp(str, \"on\") || !strcmp(str, \"yes\"))\n\t\treturn true;\n\tif (!strcmp(str, \"false\") || !strcmp(str, \"off\") || !strcmp(str, \"no\"))\n\t\treturn false;\n\n\treturn -1;\t/* error */\n}\n\nvoid skip_block(bool need_block_start)\n{\n\t/* Don't process the rest of the configuration block */\n\tif (need_block_start)\n\t\tskip_sublevel = -1;\n\telse\n\t\tskip_sublevel = 1;\n}\n\n/* Data initialization */\nvoid\ninit_data(const char *conf_file, vector_t * (*init_keywords) (void))\n{\n\t/* Init Keywords structure */\n\tkeywords = vector_alloc();\n\n\t(*init_keywords) ();\n\n\t/* Add out standard definitions */\n\tset_std_definitions();\n\n#if DUMP_KEYWORDS\n\t/* Dump configuration */\n\tdump_keywords(keywords, 0, NULL);\n#endif\n\n\t/* Stream handling */\n\tcurrent_keywords = keywords;\n\n\tcurrent_file_name = NULL;\n\tcurrent_file_line_no = 0;\n\n\t/* A parent process may have left these set */\n\tblock_depth = 0;\n\tkw_level = 0;\n\n\tregister_null_strvec_handler(null_strvec);\n\tread_conf_file(conf_file);\n\tunregister_null_strvec_handler();\n\n\t/* Report if there are missing '}'s. If there are missing '{'s it will already have been reported */\n\tif (block_depth > 0)\n\t\treport_config_error(CONFIG_MISSING_EOB, \"There are %d missing '%s's or extra '%s's\", block_depth, EOB, BOB);\n\n\t/* We have finished reading the configuration files, so any configuration\n\t * errors report from now mustn't include a reference to the config file name */\n\tcurrent_file_line_no = 0;\n\n\t/* Close the password database if it was opened */\n\tendpwent();\n\n\tfree_keywords(keywords);\n\tfree_parser_data();\n#ifdef _WITH_VRRP_\n\tclear_rt_names();\n#endif\n\tnotify_resource_release();\n}\n", "/*\n * Soft:        Keepalived is a failover program for the LVS project\n *              <www.linuxvirtualserver.org>. It monitor & manipulate\n *              a loadbalanced server pool using multi-layer checks.\n *\n * Part:        General program utils.\n *\n * Author:      Alexandre Cassen, <acassen@linux-vs.org>\n *\n *              This program is distributed in the hope that it will be useful,\n *              but WITHOUT ANY WARRANTY; without even the implied warranty of\n *              MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n *              See the GNU General Public License for more details.\n *\n *              This program is free software; you can redistribute it and/or\n *              modify it under the terms of the GNU General Public License\n *              as published by the Free Software Foundation; either version\n *              2 of the License, or (at your option) any later version.\n *\n * Copyright (C) 2001-2017 Alexandre Cassen, <acassen@gmail.com>\n */\n\n#include \"config.h\"\n\n/* System includes */\n#include <string.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <stdlib.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <sys/utsname.h>\n#include <stdint.h>\n#include <errno.h>\n#ifdef _WITH_PERF_\n#include <stdio.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/epoll.h>\n#include <sys/inotify.h>\n#endif\n\n#if !defined _HAVE_LIBIPTC_ || defined _LIBIPTC_DYNAMIC_\n#include <signal.h>\n#include <sys/wait.h>\n#endif\n\n#ifdef _WITH_STACKTRACE_\n#include <sys/stat.h>\n#include <execinfo.h>\n#include <memory.h>\n#endif\n\n/* Local includes */\n#include \"utils.h\"\n#include \"memory.h\"\n#include \"utils.h\"\n#include \"signals.h\"\n#include \"bitops.h\"\n#include \"parser.h\"\n#if !defined _HAVE_LIBIPTC_ || defined _LIBIPTC_DYNAMIC_ || defined _WITH_STACKTRACE_ || defined _WITH_PERF_\n#include \"logger.h\"\n#endif\n#if !defined _HAVE_LIBIPTC_ || defined _LIBIPTC_DYNAMIC_\n#include \"process.h\"\n#endif\n\n/* global vars */\nunsigned long debug = 0;\n\n/* Display a buffer into a HEXA formated output */\nvoid\ndump_buffer(char *buff, size_t count, FILE* fp, int indent)\n{\n\tsize_t i, j, c;\n\tbool printnext = true;\n\n\tif (count % 16)\n\t\tc = count + (16 - count % 16);\n\telse\n\t\tc = count;\n\n\tfor (i = 0; i < c; i++) {\n\t\tif (printnext) {\n\t\t\tprintnext = false;\n\t\t\tfprintf(fp, \"%*s%.4zu \", indent, \"\", i & 0xffff);\n\t\t}\n\t\tif (i < count)\n\t\t\tfprintf(fp, \"%3.2x\", buff[i] & 0xff);\n\t\telse\n\t\t\tfprintf(fp, \"   \");\n\t\tif (!((i + 1) % 8)) {\n\t\t\tif ((i + 1) % 16)\n\t\t\t\tfprintf(fp, \" -\");\n\t\t\telse {\n\t\t\t\tfprintf(fp, \"   \");\n\t\t\t\tfor (j = i - 15; j <= i; j++)\n\t\t\t\t\tif (j < count) {\n\t\t\t\t\t\tif ((buff[j] & 0xff) >= 0x20\n\t\t\t\t\t\t    && (buff[j] & 0xff) <= 0x7e)\n\t\t\t\t\t\t\tfprintf(fp, \"%c\",\n\t\t\t\t\t\t\t       buff[j] & 0xff);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tfprintf(fp, \".\");\n\t\t\t\t\t} else\n\t\t\t\t\t\tfprintf(fp, \" \");\n\t\t\t\tfprintf(fp, \"\\n\");\n\t\t\t\tprintnext = true;\n\t\t\t}\n\t\t}\n\t}\n}\n\n#ifdef _WITH_STACKTRACE_\nvoid\nwrite_stacktrace(const char *file_name, const char *str)\n{\n\tint fd;\n\tvoid *buffer[100];\n\tint nptrs;\n\tint i;\n\tchar **strs;\n\n\tnptrs = backtrace(buffer, 100);\n\tif (file_name) {\n\t\tfd = open(file_name, O_WRONLY | O_APPEND | O_CREAT, 0644);\n\t\tif (str)\n\t\t\tdprintf(fd, \"%s\\n\", str);\n\t\tbacktrace_symbols_fd(buffer, nptrs, fd);\n\t\tif (write(fd, \"\\n\", 1) != 1) {\n\t\t\t/* We don't care, but this stops a warning on Ubuntu */\n\t\t}\n\t\tclose(fd);\n\t} else {\n\t\tif (str)\n\t\t\tlog_message(LOG_INFO, \"%s\", str);\n\t\tstrs = backtrace_symbols(buffer, nptrs);\n\t\tif (strs == NULL) {\n\t\t\tlog_message(LOG_INFO, \"Unable to get stack backtrace\");\n\t\t\treturn;\n\t\t}\n\n\t\t/* We don't need the call to this function, or the first two entries on the stack */\n\t\tfor (i = 1; i < nptrs - 2; i++)\n\t\t\tlog_message(LOG_INFO, \"  %s\", strs[i]);\n\t\tfree(strs);\n\t}\n}\n#endif\n\nchar *\nmake_file_name(const char *name, const char *prog, const char *namespace, const char *instance)\n{\n\tconst char *extn_start;\n\tconst char *dir_end;\n\tsize_t len;\n\tchar *file_name;\n\n\tif (!name)\n\t\treturn NULL;\n\n\tlen = strlen(name);\n\tif (prog)\n\t\tlen += strlen(prog) + 1;\n\tif (namespace)\n\t\tlen += strlen(namespace) + 1;\n\tif (instance)\n\t\tlen += strlen(instance) + 1;\n\n\tfile_name = MALLOC(len + 1);\n\tdir_end = strrchr(name, '/');\n\textn_start = strrchr(dir_end ? dir_end : name, '.');\n\tstrncpy(file_name, name, extn_start ? (size_t)(extn_start - name) : len);\n\n\tif (prog) {\n\t\tstrcat(file_name, \"_\");\n\t\tstrcat(file_name, prog);\n\t}\n\tif (namespace) {\n\t\tstrcat(file_name, \"_\");\n\t\tstrcat(file_name, namespace);\n\t}\n\tif (instance) {\n\t\tstrcat(file_name, \"_\");\n\t\tstrcat(file_name, instance);\n\t}\n\tif (extn_start)\n\t\tstrcat(file_name, extn_start);\n\n\treturn file_name;\n}\n\n#ifdef _WITH_PERF_\nvoid\nrun_perf(const char *process, const char *network_namespace, const char *instance_name)\n{\n\tint ret;\n\tpid_t pid;\n\tchar *orig_name = NULL;\n\tchar *new_name;\n\tconst char *perf_name = \"perf.data\";\n\tint in = -1;\n\tint ep = -1;\n\n\tdo {\n\t\torig_name = MALLOC(PATH_MAX);\n\t\tif (!getcwd(orig_name, PATH_MAX)) {\n\t\t\tlog_message(LOG_INFO, \"Unable to get cwd\");\n\t\t\tbreak;\n\t\t}\n\n#ifdef IN_CLOEXEC\n\t\tin = inotify_init1(IN_CLOEXEC | IN_NONBLOCK);\n#else\n\t\tif ((in = inotify_init()) != -1) {\n\t\t\tfcntl(in, F_SETFD, FD_CLOEXEC | fcntl(n, F_GETFD));\n\t\t\tfcntl(in, F_SETFL, O_NONBLOCK | fcntl(n, F_GETFL));\n\t\t}\n#endif\n\t\tif (in == -1) {\n\t\t\tlog_message(LOG_INFO, \"inotify_init failed %d - %m\", errno);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (inotify_add_watch(in, orig_name, IN_CREATE) == -1) {\n\t\t\tlog_message(LOG_INFO, \"inotify_add_watch of %s failed %d - %m\", orig_name, errno);\n\t\t\tbreak;\n\t\t}\n\n\t\tpid = fork();\n\n\t\tif (pid == -1) {\n\t\t\tlog_message(LOG_INFO, \"fork() for perf failed\");\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Child */\n\t\tif (!pid) {\n\t\t\tchar buf[9];\n\n\t\t\tsnprintf(buf, sizeof buf, \"%d\", getppid());\n\t\t\texeclp(\"perf\", \"perf\", \"record\", \"-p\", buf, \"-q\", \"-g\", \"--call-graph\", \"fp\", NULL);\n\t\t\texit(0);\n\t\t}\n\n\t\t/* Parent */\n\t\tchar buf[sizeof(struct inotify_event) + NAME_MAX + 1];\n\t\tstruct inotify_event *ie = (struct inotify_event*)buf;\n\t\tstruct epoll_event ee = { .events = EPOLLIN, .data.fd = in };\n\n\t\tif ((ep = epoll_create(1)) == -1) {\n\t\t\tlog_message(LOG_INFO, \"perf epoll_create failed errno %d - %m\", errno);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (epoll_ctl(ep, EPOLL_CTL_ADD, in, &ee) == -1) {\n\t\t\tlog_message(LOG_INFO, \"perf epoll_ctl failed errno %d - %m\", errno);\n\t\t\tbreak;\n\t\t}\n\n\t\tdo {\n\t\t\tret = epoll_wait(ep, &ee, 1, 1000);\n\t\t\tif (ret == 0) {\n\t\t\t\tlog_message(LOG_INFO, \"Timed out waiting for creation of %s\", perf_name);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (ret == -1) {\n\t\t\t\tif (errno == EINTR)\n\t\t\t\t\tcontinue;\n\t\t\t\tlog_message(LOG_INFO, \"perf epoll returned errno %d - %m\", errno);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tret = read(in, buf, sizeof(buf));\n\t\t\tif (ret == -1) {\n\t\t\t\tif (errno == EINTR)\n\t\t\t\t\tcontinue;\n\t\t\t\tlog_message(LOG_INFO, \"perf inotify read returned errno %d %m\", errno);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (ret < (int)sizeof(*ie)) {\n\t\t\t\tlog_message(LOG_INFO, \"read returned %d\", ret);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!(ie->mask & IN_CREATE)) {\n\t\t\t\tlog_message(LOG_INFO, \"mask is 0x%x\", ie->mask);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!ie->len) {\n\t\t\t\tlog_message(LOG_INFO, \"perf inotify read returned no len\");\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (strcmp(ie->name, perf_name))\n\t\t\t\tcontinue;\n\n\t\t\t/* Rename the /perf.data file */\n\t\t\tstrcat(orig_name, perf_name);\n\t\t\tnew_name = make_file_name(orig_name, process,\n#if HAVE_DECL_CLONE_NEWNET\n\t\t\t\t\t\t\tnetwork_namespace,\n#else\n\t\t\t\t\t\t\tNULL,\n#endif\n\t\t\t\t\t\t\tinstance_name);\n\n\t\t\tif (rename(orig_name, new_name))\n\t\t\t\tlog_message(LOG_INFO, \"Rename %s to %s failed - %m (%d)\", orig_name, new_name, errno);\n\n\t\t\tFREE(new_name);\n\t\t} while (false);\n\t} while (false);\n\n\tif (ep != -1)\n\t\tclose(ep);\n\tif (in != -1)\n\t\tclose(in);\n\tif (orig_name)\n\t\tFREE(orig_name);\n}\n#endif\n\n/* Compute a checksum */\nuint16_t\nin_csum(const uint16_t *addr, size_t len, uint32_t csum, uint32_t *acc)\n{\n\tregister size_t nleft = len;\n\tconst uint16_t *w = addr;\n\tregister uint16_t answer;\n\tregister uint32_t sum = csum;\n\n\t/*\n\t *  Our algorithm is simple, using a 32 bit accumulator (sum),\n\t *  we add sequential 16 bit words to it, and at the end, fold\n\t *  back all the carry bits from the top 16 bits into the lower\n\t *  16 bits.\n\t */\n\twhile (nleft > 1) {\n\t\tsum += *w++;\n\t\tnleft -= 2;\n\t}\n\n\t/* mop up an odd byte, if necessary */\n\tif (nleft == 1)\n\t\tsum += htons(*(u_char *) w << 8);\n\n\tif (acc)\n\t\t*acc = sum;\n\n\t/*\n\t * add back carry outs from top 16 bits to low 16 bits\n\t */\n\tsum = (sum >> 16) + (sum & 0xffff);\t/* add hi 16 to low 16 */\n\tsum += (sum >> 16);\t\t\t/* add carry */\n\tanswer = (~sum & 0xffff);\t\t/* truncate to 16 bits */\n\treturn (answer);\n}\n\n/* IP network to ascii representation */\nchar *\ninet_ntop2(uint32_t ip)\n{\n\tstatic char buf[16];\n\tunsigned char *bytep;\n\n\tbytep = (unsigned char *) &(ip);\n\tsprintf(buf, \"%d.%d.%d.%d\", bytep[0], bytep[1], bytep[2], bytep[3]);\n\treturn buf;\n}\n\n#ifdef _INCLUDE_UNUSED_CODE_\n/*\n * IP network to ascii representation. To use\n * for multiple IP address convertion into the same call.\n */\nchar *\ninet_ntoa2(uint32_t ip, char *buf)\n{\n\tunsigned char *bytep;\n\n\tbytep = (unsigned char *) &(ip);\n\tsprintf(buf, \"%d.%d.%d.%d\", bytep[0], bytep[1], bytep[2], bytep[3]);\n\treturn buf;\n}\n#endif\n\n/* IP string to network range representation. */\nbool\ninet_stor(const char *addr, uint32_t *range_end)\n{\n\tconst char *cp;\n\tchar *endptr;\n\tunsigned long range;\n\tint family = strchr(addr, ':') ? AF_INET6 : AF_INET;\n\tchar *warn = \"\";\n\n#ifndef _STRICT_CONFIG_\n\tif (!__test_bit(CONFIG_TEST_BIT, &debug))\n\t\twarn = \"WARNING - \";\n#endif\n\n\t/* Return UINT32_MAX to indicate no range */\n\tif (!(cp = strchr(addr, '-'))) {\n\t\t*range_end = UINT32_MAX;\n\t\treturn true;\n\t}\n\n\terrno = 0;\n\trange = strtoul(cp + 1, &endptr, family == AF_INET6 ? 16 : 10);\n\t*range_end = range;\n\n\tif (*endptr)\n\t\treport_config_error(CONFIG_INVALID_NUMBER, \"%sVirtual server group range '%s' has extra characters at end '%s'\", warn, addr, endptr);\n\telse if (errno == ERANGE ||\n\t\t (family == AF_INET6 && range > 0xffff) ||\n\t\t (family == AF_INET && range > 255)) {\n\t\treport_config_error(CONFIG_INVALID_NUMBER, \"Virtual server group range '%s' end '%s' too large\", addr, cp + 1);\n\n\t\t/* Indicate error */\n\t\treturn false;\n\t}\n\telse\n\t\treturn true;\n\n#ifdef _STRICT_CONFIG_\n        return false;\n#else\n        return !__test_bit(CONFIG_TEST_BIT, &debug);\n#endif\n}\n\n/* Domain to sockaddr_storage */\nint\ndomain_stosockaddr(const char *domain, const char *port, struct sockaddr_storage *addr)\n{\n\tstruct addrinfo *res = NULL;\n\tunsigned port_num;\n\n\tif (port) {\n\t\tif (!read_unsigned(port, &port_num, 1, 65535, true)) {\n\t\t\taddr->ss_family = AF_UNSPEC;\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (getaddrinfo(domain, NULL, NULL, &res) != 0 || !res) {\n\t\taddr->ss_family = AF_UNSPEC;\n\t\treturn -1;\n\t}\n\n\taddr->ss_family = (sa_family_t)res->ai_family;\n\n\tif (addr->ss_family == AF_INET6) {\n\t\tstruct sockaddr_in6 *addr6 = (struct sockaddr_in6 *)addr;\n\t\t*addr6 = *(struct sockaddr_in6 *)res->ai_addr;\n\t\tif (port)\n\t\t\taddr6->sin6_port = htons(port_num);\n\t} else {\n\t\tstruct sockaddr_in *addr4 = (struct sockaddr_in *)addr;\n\t\t*addr4 = *(struct sockaddr_in *)res->ai_addr;\n\t\tif (port)\n\t\t\taddr4->sin_port = htons(port_num);\n\t}\n\n\tfreeaddrinfo(res);\n\n\treturn 0;\n}\n\n/* IP string to sockaddr_storage */\nint\ninet_stosockaddr(char *ip, const char *port, struct sockaddr_storage *addr)\n{\n\tvoid *addr_ip;\n\tchar *cp;\n\tchar sav_cp;\n\tunsigned port_num;\n\tint res;\n\n\taddr->ss_family = (strchr(ip, ':')) ? AF_INET6 : AF_INET;\n\n\tif (port) {\n\t\tif (!read_unsigned(port, &port_num, 1, 65535, true)) {\n\t\t\taddr->ss_family = AF_UNSPEC;\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (addr->ss_family == AF_INET6) {\n\t\tstruct sockaddr_in6 *addr6 = (struct sockaddr_in6 *) addr;\n\t\tif (port)\n\t\t\taddr6->sin6_port = htons(port_num);\n\t\taddr_ip = &addr6->sin6_addr;\n\t} else {\n\t\tstruct sockaddr_in *addr4 = (struct sockaddr_in *) addr;\n\t\tif (port)\n\t\t\taddr4->sin_port = htons(port_num);\n\t\taddr_ip = &addr4->sin_addr;\n\t}\n\n\t/* remove range and mask stuff */\n\tif ((cp = strchr(ip, '-')) ||\n\t    (cp = strchr(ip, '/'))) {\n\t\tsav_cp = *cp;\n\t\t*cp = 0;\n\t}\n\n\tres = inet_pton(addr->ss_family, ip, addr_ip);\n\n\t/* restore range and mask stuff */\n\tif (cp)\n\t\t*cp = sav_cp;\n\n\tif (!res) {\n\t\taddr->ss_family = AF_UNSPEC;\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n/* IPv4 to sockaddr_storage */\nvoid\ninet_ip4tosockaddr(struct in_addr *sin_addr, struct sockaddr_storage *addr)\n{\n\tstruct sockaddr_in *addr4 = (struct sockaddr_in *) addr;\n\taddr4->sin_family = AF_INET;\n\taddr4->sin_addr = *sin_addr;\n}\n\n/* IPv6 to sockaddr_storage */\nvoid\ninet_ip6tosockaddr(struct in6_addr *sin_addr, struct sockaddr_storage *addr)\n{\n\tstruct sockaddr_in6 *addr6 = (struct sockaddr_in6 *) addr;\n\taddr6->sin6_family = AF_INET6;\n\taddr6->sin6_addr = *sin_addr;\n}\n\n/* IP network to string representation */\nstatic char *\ninet_sockaddrtos2(struct sockaddr_storage *addr, char *addr_str)\n{\n\tvoid *addr_ip;\n\n\tif (addr->ss_family == AF_INET6) {\n\t\tstruct sockaddr_in6 *addr6 = (struct sockaddr_in6 *) addr;\n\t\taddr_ip = &addr6->sin6_addr;\n\t} else {\n\t\tstruct sockaddr_in *addr4 = (struct sockaddr_in *) addr;\n\t\taddr_ip = &addr4->sin_addr;\n\t}\n\n\tif (!inet_ntop(addr->ss_family, addr_ip, addr_str, INET6_ADDRSTRLEN))\n\t\treturn NULL;\n\n\treturn addr_str;\n}\n\nchar *\ninet_sockaddrtos(struct sockaddr_storage *addr)\n{\n\tstatic char addr_str[INET6_ADDRSTRLEN];\n\tinet_sockaddrtos2(addr, addr_str);\n\treturn addr_str;\n}\n\nuint16_t\ninet_sockaddrport(struct sockaddr_storage *addr)\n{\n\tuint16_t port;\n\n\tif (addr->ss_family == AF_INET6) {\n\t\tstruct sockaddr_in6 *addr6 = (struct sockaddr_in6 *) addr;\n\t\tport = addr6->sin6_port;\n\t} else {\n\t\t/* Note: this might be AF_UNSPEC if it is the sequence number of\n\t\t * a virtual server in a virtual server group */\n\t\tstruct sockaddr_in *addr4 = (struct sockaddr_in *) addr;\n\t\tport = addr4->sin_port;\n\t}\n\n\treturn port;\n}\n\nchar *\ninet_sockaddrtopair(struct sockaddr_storage *addr)\n{\n\tchar addr_str[INET6_ADDRSTRLEN];\n\tstatic char ret[sizeof(addr_str) + 8];\t/* '[' + addr_str + ']' + ':' + 'nnnnn' */\n\n\tinet_sockaddrtos2(addr, addr_str);\n\tsnprintf(ret, sizeof(ret), \"[%s]:%d\"\n\t\t, addr_str\n\t\t, ntohs(inet_sockaddrport(addr)));\n\treturn ret;\n}\n\nchar *\ninet_sockaddrtotrio(struct sockaddr_storage *addr, uint16_t proto)\n{\n\tchar addr_str[INET6_ADDRSTRLEN];\n\tstatic char ret[sizeof(addr_str) + 13];\t/* '[' + addr_str + ']' + ':' + 'sctp' + ':' + 'nnnnn' */\n\tchar *proto_str = proto == IPPROTO_TCP ? \"tcp\" : proto == IPPROTO_UDP ? \"udp\" : proto == IPPROTO_SCTP ? \"sctp\" : proto == 0 ? \"none\" : \"?\";\n\n\tinet_sockaddrtos2(addr, addr_str);\n\tsnprintf(ret, sizeof(ret), \"[%s]:%s:%d\" ,addr_str, proto_str,\n\t\t ntohs(inet_sockaddrport(addr)));\n\treturn ret;\n}\n\nuint32_t\ninet_sockaddrip4(struct sockaddr_storage *addr)\n{\n\tif (addr->ss_family != AF_INET)\n\t\treturn 0xffffffff;\n\n\treturn ((struct sockaddr_in *) addr)->sin_addr.s_addr;\n}\n\nint\ninet_sockaddrip6(struct sockaddr_storage *addr, struct in6_addr *ip6)\n{\n\tif (addr->ss_family != AF_INET6)\n\t\treturn -1;\n\n\t*ip6 = ((struct sockaddr_in6 *) addr)->sin6_addr;\n\treturn 0;\n}\n\n/* IPv6 address compare */\nint\ninet_inaddrcmp(const int family, const void *a, const void *b)\n{\n\tint64_t addr_diff;\n\n\tif (family == AF_INET) {\n\t\taddr_diff = (int64_t)ntohl(*((const uint32_t *) a)) - (int64_t)ntohl(*((const uint32_t *) b));\n\t\tif (addr_diff > 0)\n\t\t\treturn 1;\n\t\tif (addr_diff < 0)\n\t\t\treturn -1;\n\t\treturn 0;\n\t}\n\n\tif (family == AF_INET6) {\n\t\tint i;\n\n\t\tfor (i = 0; i < 4; i++ ) {\n\t\t\taddr_diff = (int64_t)ntohl(((const uint32_t *) (a))[i]) - (int64_t)ntohl(((const uint32_t *) (b))[i]);\n\t\t\tif (addr_diff > 0)\n\t\t\t\treturn 1;\n\t\t\tif (addr_diff < 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn 0;\n\t}\n\n\treturn -2;\n}\n\nint\ninet_sockaddrcmp(const struct sockaddr_storage *a, const struct sockaddr_storage *b)\n{\n\tif (a->ss_family != b->ss_family)\n\t\treturn -2;\n\n\tif (a->ss_family == AF_INET)\n\t\treturn inet_inaddrcmp(a->ss_family,\n\t\t\t\t      &((struct sockaddr_in *) a)->sin_addr,\n\t\t\t\t      &((struct sockaddr_in *) b)->sin_addr);\n\tif (a->ss_family == AF_INET6)\n\t\treturn inet_inaddrcmp(a->ss_family,\n\t\t\t\t      &((struct sockaddr_in6 *) a)->sin6_addr,\n\t\t\t\t      &((struct sockaddr_in6 *) b)->sin6_addr);\n\treturn 0;\n}\n\n\n#ifdef _INCLUDE_UNUSED_CODE_\n/*\n * IP string to network representation\n * Highly inspired from Paul Vixie code.\n */\nint\ninet_ston(const char *addr, uint32_t * dst)\n{\n\tstatic char digits[] = \"0123456789\";\n\tint saw_digit, octets, ch;\n\tu_char tmp[INADDRSZ], *tp;\n\n\tsaw_digit = 0;\n\toctets = 0;\n\t*(tp = tmp) = 0;\n\n\twhile ((ch = *addr++) != '\\0' && ch != '/' && ch != '-') {\n\t\tconst char *pch;\n\t\tif ((pch = strchr(digits, ch)) != NULL) {\n\t\t\tu_int new = *tp * 10 + (pch - digits);\n\t\t\tif (new > 255)\n\t\t\t\treturn 0;\n\t\t\t*tp = new;\n\t\t\tif (!saw_digit) {\n\t\t\t\tif (++octets > 4)\n\t\t\t\t\treturn 0;\n\t\t\t\tsaw_digit = 1;\n\t\t\t}\n\t\t} else if (ch == '.' && saw_digit) {\n\t\t\tif (octets == 4)\n\t\t\t\treturn 0;\n\t\t\t*++tp = 0;\n\t\t\tsaw_digit = 0;\n\t\t} else\n\t\t\treturn 0;\n\t}\n\n\tif (octets < 4)\n\t\treturn 0;\n\n\tmemcpy(dst, tmp, INADDRSZ);\n\treturn 1;\n}\n\n/*\n * Return broadcast address from network and netmask.\n */\nuint32_t\ninet_broadcast(uint32_t network, uint32_t netmask)\n{\n\treturn 0xffffffff - netmask + network;\n}\n\n/*\n * Convert CIDR netmask notation to long notation.\n */\nuint32_t\ninet_cidrtomask(uint8_t cidr)\n{\n\tuint32_t mask = 0;\n\tint b;\n\n\tfor (b = 0; b < cidr; b++)\n\t\tmask |= (1 << (31 - b));\n\treturn ntohl(mask);\n}\n#endif\n\n/* Getting localhost official canonical name */\nchar *\nget_local_name(void)\n{\n\tstruct utsname name;\n\tstruct addrinfo hints, *res = NULL;\n\tchar *canonname = NULL;\n\tsize_t len = 0;\n\n\tmemset(&hints, 0, sizeof(struct addrinfo));\n\thints.ai_flags = AI_CANONNAME;\n\n\tif (uname(&name) < 0)\n\t\treturn NULL;\n\n\tif (getaddrinfo(name.nodename, NULL, &hints, &res) != 0)\n\t\treturn NULL;\n\n\tif (res && res->ai_canonname) {\n\t\tlen = strlen(res->ai_canonname);\n\t\tcanonname = MALLOC(len + 1);\n\t\tif (canonname) {\n\t\t\tmemcpy(canonname, res->ai_canonname, len);\n\t\t}\n\t}\n\n\tfreeaddrinfo(res);\n\n\treturn canonname;\n}\n\n/* String compare with NULL string handling */\nbool\nstring_equal(const char *str1, const char *str2)\n{\n\tif (!str1 && !str2)\n\t\treturn true;\n\tif (!str1 != !str2)\n\t\treturn false;\n\n\treturn !strcmp(str1, str2);\n}\n\nvoid\nset_std_fd(bool force)\n{\n\tint fd;\n\n\tif (force || __test_bit(DONT_FORK_BIT, &debug)) {\n\t\tfd = open(\"/dev/null\", O_RDWR);\n\t\tif (fd != -1) {\n\t\t\tdup2(fd, STDIN_FILENO);\n\t\t\tdup2(fd, STDOUT_FILENO);\n\t\t\tdup2(fd, STDERR_FILENO);\n\t\t\tif (fd > STDERR_FILENO)\n\t\t\t\tclose(fd);\n\t\t}\n\t}\n\n\tsignal_fd_close(STDERR_FILENO+1);\n}\n\nvoid\nclose_std_fd(void)\n{\n\tclose(STDIN_FILENO);\n\tclose(STDOUT_FILENO);\n\tclose(STDERR_FILENO);\n}\n\n#if !defined _HAVE_LIBIPTC_ || defined _LIBIPTC_DYNAMIC_\nint\nfork_exec(char **argv)\n{\n\tpid_t pid;\n\tint status;\n\tstruct sigaction act, old_act;\n\tint res = 0;\n\n\tact.sa_handler = SIG_DFL;\n\tsigemptyset(&act.sa_mask);\n\tact.sa_flags = 0;\n\n\tsigaction(SIGCHLD, &act, &old_act);\n\n\tif (log_file_name)\n\t\tflush_log_file();\n\n\tpid = local_fork();\n\tif (pid < 0)\n\t\tres = -1;\n\telse if (pid == 0) {\n\t\t/* Child */\n\t\tset_std_fd(false);\n\n\t\tsignal_handler_script();\n\n\t\texecvp(*argv, argv);\n\t\texit(EXIT_FAILURE);\n\t} else {\n\t\t/* Parent */\n\t\twhile (waitpid(pid, &status, 0) != pid);\n\n\t\tif (!WIFEXITED(status) || WEXITSTATUS(status) != EXIT_SUCCESS)\n\t\t\tres = -1;\n\t}\n\n\tsigaction(SIGCHLD, &old_act, NULL);\n\n\treturn res;\n}\n#endif\n\n#if defined _WITH_VRRP_ || defined _WITH_BFD_\nint\nopen_pipe(int pipe_arr[2])\n{\n\t/* Open pipe */\n#ifdef HAVE_PIPE2\n\tif (pipe2(pipe_arr, O_CLOEXEC | O_NONBLOCK) == -1)\n#else\n\tif (pipe(pipe_arr) == -1)\n#endif\n\t\treturn -1;\n\n#ifndef HAVE_PIPE2\n\tfcntl(pipe_arr[0], F_SETFL, O_NONBLOCK | fcntl(pipe_arr[0], F_GETFL));\n\tfcntl(pipe_arr[1], F_SETFL, O_NONBLOCK | fcntl(pipe_arr[1], F_GETFL));\n\n\tfcntl(pipe_arr[0], F_SETFD, FD_CLOEXEC | fcntl(pipe_arr[0], F_GETFD));\n\tfcntl(pipe_arr[1], F_SETFD, FD_CLOEXEC | fcntl(pipe_arr[1], F_GETFD));\n#endif\n\n\treturn 0;\n}\n#endif\n", "/*\n * Soft:        Keepalived is a failover program for the LVS project\n *              <www.linuxvirtualserver.org>. It monitor & manipulate\n *              a loadbalanced server pool using multi-layer checks.\n *\n * Part:        utils.h include file.\n *\n * Author:      Alexandre Cassen, <acassen@linux-vs.org>\n *\n *              This program is distributed in the hope that it will be useful,\n *              but WITHOUT ANY WARRANTY; without even the implied warranty of\n *              MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n *              See the GNU General Public License for more details.\n *\n *              This program is free software; you can redistribute it and/or\n *              modify it under the terms of the GNU General Public License\n *              as published by the Free Software Foundation; either version\n *              2 of the License, or (at your option) any later version.\n *\n * Copyright (C) 2001-2017 Alexandre Cassen, <acassen@gmail.com>\n */\n\n#ifndef _UTILS_H\n#define _UTILS_H\n\n#include \"config.h\"\n\n/* system includes */\n#include <sys/types.h>\n#include <stdint.h>\n#include <stdbool.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <stdio.h>\n\n#include \"vector.h\"\n#ifdef _DEBUG_\n#include \"logger.h\"\n#endif\n\n/* Global debugging logging facilities */\n#ifdef _DEBUG_\n#define DBG(fmt, msg...) log_message(LOG_DEBUG, fmt, ## msg)\n#else\n#define DBG(fmt, msg...)\n#endif\n\n#define STR(x)  #x\n\n#ifdef _WITH_PERF_\ntypedef enum {\n\tPERF_NONE,\n\tPERF_RUN,\n\tPERF_ALL,\n\tPERF_END,\n} perf_t;\n#endif\n\n/* inline stuff */\nstatic inline int __ip6_addr_equal(const struct in6_addr *a1,\n\t\t\t\t   const struct in6_addr *a2)\n{\n\treturn (((a1->s6_addr32[0] ^ a2->s6_addr32[0]) |\n\t\t (a1->s6_addr32[1] ^ a2->s6_addr32[1]) |\n\t\t (a1->s6_addr32[2] ^ a2->s6_addr32[2]) |\n\t\t (a1->s6_addr32[3] ^ a2->s6_addr32[3])) == 0);\n}\n\nstatic inline bool sockstorage_equal(const struct sockaddr_storage *s1,\n\t\t\t\t    const struct sockaddr_storage *s2)\n{\n\tif (s1->ss_family != s2->ss_family)\n\t\treturn false;\n\n\tif (s1->ss_family == AF_INET6) {\n\t\tstruct sockaddr_in6 *a1 = (struct sockaddr_in6 *) s1;\n\t\tstruct sockaddr_in6 *a2 = (struct sockaddr_in6 *) s2;\n\n//\t\tif (IN6_ARE_ADDR_EQUAL(a1, a2) && (a1->sin6_port == a2->sin6_port))\n\t\tif (__ip6_addr_equal(&a1->sin6_addr, &a2->sin6_addr) &&\n\t\t    (a1->sin6_port == a2->sin6_port))\n\t\t\treturn true;\n\t} else if (s1->ss_family == AF_INET) {\n\t\tstruct sockaddr_in *a1 = (struct sockaddr_in *) s1;\n\t\tstruct sockaddr_in *a2 = (struct sockaddr_in *) s2;\n\n\t\tif ((a1->sin_addr.s_addr == a2->sin_addr.s_addr) &&\n\t\t    (a1->sin_port == a2->sin_port))\n\t\t\treturn true;\n\t} else if (s1->ss_family == AF_UNSPEC)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic inline bool inaddr_equal(sa_family_t family, void *addr1, void *addr2)\n{\n\tif (family == AF_INET6) {\n\t\tstruct in6_addr *a1 = (struct in6_addr *) addr1;\n\t\tstruct in6_addr *a2 = (struct in6_addr *) addr2;\n\n\t\tif (__ip6_addr_equal(a1, a2))\n\t\t\treturn true;\n\t} else if (family == AF_INET) {\n\t\tstruct in_addr *a1 = (struct in_addr *) addr1;\n\t\tstruct in_addr *a2 = (struct in_addr *) addr2;\n\n\t\tif (a1->s_addr == a2->s_addr)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic inline uint16_t csum_incremental_update32(const uint16_t old_csum, const uint32_t old_val, const uint32_t new_val)\n{\n\t/* This technique for incremental IP checksum update is described in RFC1624,\n\t * along with accompanying errata */\n\n\tif (old_val == new_val)\n\t\treturn old_csum;\n\n\tuint32_t acc = (~old_csum & 0xffff) + (~(old_val >> 16 ) & 0xffff) + (~old_val & 0xffff);\n\n\tacc += (new_val >> 16) + (new_val & 0xffff);\n\n\t/* finally compute vrrp checksum */\n\tacc = (acc & 0xffff) + (acc >> 16);\n\tacc += acc >> 16;\n\n\treturn ~acc & 0xffff;\n}\n\nstatic inline uint16_t csum_incremental_update16(const uint16_t old_csum, const uint16_t old_val, const uint16_t new_val)\n{\n\t/* This technique for incremental IP checksum update is described in RFC1624,\n\t * along with accompanying errata */\n\n\tif (old_val == new_val)\n\t\treturn old_csum;\n\n\tuint32_t acc = (~old_csum & 0xffff) + (~old_val & 0xffff);\n\n\tacc += new_val;\n\n\t/* finally compute vrrp checksum */\n\tacc = (acc & 0xffff) + (acc >> 16);\n\tacc += acc >> 16;\n\n\treturn ~acc & 0xffff;\n}\n\n/* global vars exported */\nextern unsigned long debug;\n#ifdef _WITH_PERF_\nextern perf_t perf_run;\n#endif\n\n/* Prototypes defs */\nextern void dump_buffer(char *, size_t, FILE *, int);\n#ifdef _WITH_STACKTRACE_\nextern void write_stacktrace(const char *, const char *);\n#endif\nextern char *make_file_name(const char *, const char *, const char *, const char *);\n#ifdef _WITH_PERF_\nextern void run_perf(const char *, const char *, const char *);\n#endif\nextern uint16_t in_csum(const uint16_t *, size_t, uint32_t, uint32_t *);\nextern char *inet_ntop2(uint32_t);\nextern bool inet_stor(const char *, uint32_t *);\nextern int domain_stosockaddr(const char *, const char *, struct sockaddr_storage *);\nextern int inet_stosockaddr(char *, const char *, struct sockaddr_storage *);\nextern void inet_ip4tosockaddr(struct in_addr *, struct sockaddr_storage *);\nextern void inet_ip6tosockaddr(struct in6_addr *, struct sockaddr_storage *);\nextern char *inet_sockaddrtos(struct sockaddr_storage *);\nextern char *inet_sockaddrtopair(struct sockaddr_storage *);\nextern char *inet_sockaddrtotrio(struct sockaddr_storage *, uint16_t);\nextern uint16_t inet_sockaddrport(struct sockaddr_storage *);\nextern uint32_t inet_sockaddrip4(struct sockaddr_storage *);\nextern int inet_sockaddrip6(struct sockaddr_storage *, struct in6_addr *);\nextern int inet_inaddrcmp(int, const void *, const void *);\nextern int inet_sockaddrcmp(const struct sockaddr_storage *, const struct sockaddr_storage *);\nextern char *get_local_name(void);\nextern bool string_equal(const char *, const char *);\nextern void set_std_fd(bool);\nextern void close_std_fd(void);\n#if !defined _HAVE_LIBIPTC_ || defined _LIBIPTC_DYNAMIC_\nextern int fork_exec(char **argv);\n#endif\n#if defined _WITH_VRRP_ || defined _WITH_BFD_\nextern int open_pipe(int [2]);\n#endif\n\n#endif\n"], "fixing_code": ["/*\n * Soft:        Keepalived is a failover program for the LVS project\n *              <www.linuxvirtualserver.org>. It monitor & manipulate\n *              a loadbalanced server pool using multi-layer checks.\n *\n * Part:        Main program structure.\n *\n * Author:      Alexandre Cassen, <acassen@linux-vs.org>\n *\n *              This program is distributed in the hope that it will be useful,\n *              but WITHOUT ANY WARRANTY; without even the implied warranty of\n *              MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n *              See the GNU General Public License for more details.\n *\n *              This program is free software; you can redistribute it and/or\n *              modify it under the terms of the GNU General Public License\n *              as published by the Free Software Foundation; either version\n *              2 of the License, or (at your option) any later version.\n *\n * Copyright (C) 2001-2017 Alexandre Cassen, <acassen@gmail.com>\n */\n\n#include \"config.h\"\n\n#include <stdlib.h>\n#include <sys/utsname.h>\n#include <sys/resource.h>\n#include <stdbool.h>\n#ifdef HAVE_SIGNALFD\n#include <sys/signalfd.h>\n#endif\n#include <errno.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <getopt.h>\n#include <linux/version.h>\n#include <ctype.h>\n\n#include \"main.h\"\n#include \"global_data.h\"\n#include \"daemon.h\"\n#include \"config.h\"\n#include \"git-commit.h\"\n#include \"utils.h\"\n#include \"signals.h\"\n#include \"pidfile.h\"\n#include \"bitops.h\"\n#include \"logger.h\"\n#include \"parser.h\"\n#include \"notify.h\"\n#include \"utils.h\"\n#ifdef _WITH_LVS_\n#include \"check_parser.h\"\n#include \"check_daemon.h\"\n#endif\n#ifdef _WITH_VRRP_\n#include \"vrrp_daemon.h\"\n#include \"vrrp_parser.h\"\n#include \"vrrp_if.h\"\n#ifdef _WITH_JSON_\n#include \"vrrp_json.h\"\n#endif\n#endif\n#ifdef _WITH_BFD_\n#include \"bfd_daemon.h\"\n#include \"bfd_parser.h\"\n#endif\n#include \"global_parser.h\"\n#if HAVE_DECL_CLONE_NEWNET\n#include \"namespaces.h\"\n#endif\n#include \"scheduler.h\"\n#include \"keepalived_netlink.h\"\n#include \"git-commit.h\"\n#if defined THREAD_DUMP || defined _EPOLL_DEBUG_ || defined _EPOLL_THREAD_DUMP_\n#include \"scheduler.h\"\n#endif\n#include \"process.h\"\n#ifdef _TIMER_CHECK_\n#include \"timer.h\"\n#endif\n#ifdef _SMTP_ALERT_DEBUG_\n#include \"smtp.h\"\n#endif\n#if defined _REGEX_DEBUG_ || defined _WITH_REGEX_TIMERS_\n#include \"check_http.h\"\n#endif\n#ifdef _TSM_DEBUG_\n#include \"vrrp_scheduler.h\"\n#endif\n\n/* musl libc doesn't define the following */\n#ifndef\tW_EXITCODE\n#define\tW_EXITCODE(ret, sig)\t((ret) << 8 | (sig))\n#endif\n#ifndef\tWCOREFLAG\n#define\tWCOREFLAG\t\t((int32_t)WCOREDUMP(0xffffffff))\n#endif\n\n#define\tVERSION_STRING\t\tPACKAGE_NAME \" v\" PACKAGE_VERSION \" (\" GIT_DATE \")\"\n#define COPYRIGHT_STRING\t\"Copyright(C) 2001-\" GIT_YEAR \" Alexandre Cassen, <acassen@gmail.com>\"\n\n#define CHILD_WAIT_SECS\t5\n\n/* global var */\nconst char *version_string = VERSION_STRING;\t\t/* keepalived version */\nchar *conf_file = KEEPALIVED_CONFIG_FILE;\t\t/* Configuration file */\nint log_facility = LOG_DAEMON;\t\t\t\t/* Optional logging facilities */\nbool reload;\t\t\t\t\t\t/* Set during a reload */\nchar *main_pidfile;\t\t\t\t\t/* overrule default pidfile */\nstatic bool free_main_pidfile;\n#ifdef _WITH_LVS_\npid_t checkers_child;\t\t\t\t\t/* Healthcheckers child process ID */\nchar *checkers_pidfile;\t\t\t\t\t/* overrule default pidfile */\nstatic bool free_checkers_pidfile;\n#endif\n#ifdef _WITH_VRRP_\npid_t vrrp_child;\t\t\t\t\t/* VRRP child process ID */\nchar *vrrp_pidfile;\t\t\t\t\t/* overrule default pidfile */\nstatic bool free_vrrp_pidfile;\n#endif\n#ifdef _WITH_BFD_\npid_t bfd_child;\t\t\t\t\t/* BFD child process ID */\nchar *bfd_pidfile;\t\t\t\t\t/* overrule default pidfile */\nstatic bool free_bfd_pidfile;\n#endif\nunsigned long daemon_mode;\t\t\t\t/* VRRP/CHECK/BFD subsystem selection */\n#ifdef _WITH_SNMP_\nbool snmp;\t\t\t\t\t\t/* Enable SNMP support */\nconst char *snmp_socket;\t\t\t\t/* Socket to use for SNMP agent */\n#endif\nstatic char *syslog_ident;\t\t\t\t/* syslog ident if not default */\nbool use_pid_dir;\t\t\t\t\t/* Put pid files in /var/run/keepalived or @localstatedir@/run/keepalived */\n\nunsigned os_major;\t\t\t\t\t/* Kernel version */\nunsigned os_minor;\nunsigned os_release;\nchar *hostname;\t\t\t\t\t\t/* Initial part of hostname */\n\n#if HAVE_DECL_CLONE_NEWNET\nstatic char *override_namespace;\t\t\t/* If namespace specified on command line */\n#endif\n\nunsigned child_wait_time = CHILD_WAIT_SECS;\t\t/* Time to wait for children to exit */\n\n/* Log facility table */\nstatic struct {\n\tint facility;\n} LOG_FACILITY[] = {\n\t{LOG_LOCAL0}, {LOG_LOCAL1}, {LOG_LOCAL2}, {LOG_LOCAL3},\n\t{LOG_LOCAL4}, {LOG_LOCAL5}, {LOG_LOCAL6}, {LOG_LOCAL7}\n};\n#define\tLOG_FACILITY_MAX\t((sizeof(LOG_FACILITY) / sizeof(LOG_FACILITY[0])) - 1)\n\n/* umask settings */\nbool umask_cmdline;\nstatic mode_t umask_val = S_IXUSR | S_IWGRP | S_IXGRP | S_IWOTH | S_IXOTH;\n\n/* Control producing core dumps */\nstatic bool set_core_dump_pattern = false;\nstatic bool create_core_dump = false;\nstatic const char *core_dump_pattern = \"core\";\nstatic char *orig_core_dump_pattern = NULL;\n\n/* debug flags */\n#if defined _TIMER_CHECK_ || defined _SMTP_ALERT_DEBUG_ || defined _EPOLL_DEBUG_ || defined _EPOLL_THREAD_DUMP_ || defined _REGEX_DEBUG_ || defined _WITH_REGEX_TIMERS_ || defined _TSM_DEBUG_ || defined _VRRP_FD_DEBUG_ || defined _NETLINK_TIMERS_\n#define WITH_DEBUG_OPTIONS 1\n#endif\n\n#ifdef _TIMER_CHECK_\nstatic char timer_debug;\n#endif\n#ifdef _SMTP_ALERT_DEBUG_\nstatic char smtp_debug;\n#endif\n#ifdef _EPOLL_DEBUG_\nstatic char epoll_debug;\n#endif\n#ifdef _EPOLL_THREAD_DUMP_\nstatic char epoll_thread_debug;\n#endif\n#ifdef _REGEX_DEBUG_\nstatic char regex_debug;\n#endif\n#ifdef _WITH_REGEX_TIMERS_\nstatic char regex_timers;\n#endif\n#ifdef _TSM_DEBUG_\nstatic char tsm_debug;\n#endif\n#ifdef _VRRP_FD_DEBUG_\nstatic char vrrp_fd_debug;\n#endif\n#ifdef _NETLINK_TIMERS_\nstatic char netlink_timer_debug;\n#endif\n\nvoid\nfree_parent_mallocs_startup(bool am_child)\n{\n\tif (am_child) {\n#if HAVE_DECL_CLONE_NEWNET\n\t\tfree_dirname();\n#endif\n#ifndef _MEM_CHECK_LOG_\n\t\tFREE_PTR(syslog_ident);\n#else\n\t\tfree(syslog_ident);\n#endif\n\t\tsyslog_ident = NULL;\n\n\t\tFREE_PTR(orig_core_dump_pattern);\n\t}\n\n\tif (free_main_pidfile) {\n\t\tFREE_PTR(main_pidfile);\n\t\tfree_main_pidfile = false;\n\t}\n}\n\nvoid\nfree_parent_mallocs_exit(void)\n{\n#ifdef _WITH_VRRP_\n\tif (free_vrrp_pidfile)\n\t\tFREE_PTR(vrrp_pidfile);\n#endif\n#ifdef _WITH_LVS_\n\tif (free_checkers_pidfile)\n\t\tFREE_PTR(checkers_pidfile);\n#endif\n#ifdef _WITH_BFD_\n\tif (free_bfd_pidfile)\n\t\tFREE_PTR(bfd_pidfile);\n#endif\n\n\tFREE_PTR(config_id);\n}\n\nchar *\nmake_syslog_ident(const char* name)\n{\n\tsize_t ident_len = strlen(name) + 1;\n\tchar *ident;\n\n#if HAVE_DECL_CLONE_NEWNET\n\tif (global_data->network_namespace)\n\t\tident_len += strlen(global_data->network_namespace) + 1;\n#endif\n\tif (global_data->instance_name)\n\t\tident_len += strlen(global_data->instance_name) + 1;\n\n\t/* If we are writing MALLOC/FREE info to the log, we have\n\t * trouble FREEing the syslog_ident */\n#ifndef _MEM_CHECK_LOG_\n\tident = MALLOC(ident_len);\n#else\n\tident = malloc(ident_len);\n#endif\n\n\tif (!ident)\n\t\treturn NULL;\n\n\tstrcpy(ident, name);\n#if HAVE_DECL_CLONE_NEWNET\n\tif (global_data->network_namespace) {\n\t\tstrcat(ident, \"_\");\n\t\tstrcat(ident, global_data->network_namespace);\n\t}\n#endif\n\tif (global_data->instance_name) {\n\t\tstrcat(ident, \"_\");\n\t\tstrcat(ident, global_data->instance_name);\n\t}\n\n\treturn ident;\n}\n\nstatic char *\nmake_pidfile_name(const char* start, const char* instance, const char* extn)\n{\n\tsize_t len;\n\tchar *name;\n\n\tlen = strlen(start) + 1;\n\tif (instance)\n\t\tlen += strlen(instance) + 1;\n\tif (extn)\n\t\tlen += strlen(extn);\n\n\tname = MALLOC(len);\n\tif (!name) {\n\t\tlog_message(LOG_INFO, \"Unable to make pidfile name for %s\", start);\n\t\treturn NULL;\n\t}\n\n\tstrcpy(name, start);\n\tif (instance) {\n\t\tstrcat(name, \"_\");\n\t\tstrcat(name, instance);\n\t}\n\tif (extn)\n\t\tstrcat(name, extn);\n\n\treturn name;\n}\n\n#ifdef _WITH_VRRP_\nbool\nrunning_vrrp(void)\n{\n\treturn (__test_bit(DAEMON_VRRP, &daemon_mode) &&\n\t    (global_data->have_vrrp_config ||\n\t     __test_bit(RUN_ALL_CHILDREN, &daemon_mode)));\n}\n#endif\n\n#ifdef _WITH_LVS_\nbool\nrunning_checker(void)\n{\n\treturn (__test_bit(DAEMON_CHECKERS, &daemon_mode) &&\n\t    (global_data->have_checker_config ||\n\t     __test_bit(RUN_ALL_CHILDREN, &daemon_mode)));\n}\n#endif\n\n#ifdef _WITH_BFD_\nbool\nrunning_bfd(void)\n{\n\treturn (__test_bit(DAEMON_BFD, &daemon_mode) &&\n\t    (global_data->have_bfd_config ||\n\t     __test_bit(RUN_ALL_CHILDREN, &daemon_mode)));\n}\n#endif\n\nstatic char const *\nfind_keepalived_child_name(pid_t pid)\n{\n#ifdef _WITH_LVS_\n\tif (pid == checkers_child)\n\t\treturn PROG_CHECK;\n#endif\n#ifdef _WITH_VRRP_\n\tif (pid == vrrp_child)\n\t\treturn PROG_VRRP;\n#endif\n#ifdef _WITH_BFD_\n\tif (pid == bfd_child)\n\t\treturn PROG_BFD;\n#endif\n\n\treturn NULL;\n}\n\nstatic vector_t *\nglobal_init_keywords(void)\n{\n\t/* global definitions mapping */\n\tinit_global_keywords(true);\n\n#ifdef _WITH_VRRP_\n\tinit_vrrp_keywords(false);\n#endif\n#ifdef _WITH_LVS_\n\tinit_check_keywords(false);\n#endif\n#ifdef _WITH_BFD_\n\tinit_bfd_keywords(false);\n#endif\n\n\treturn keywords;\n}\n\nstatic void\nread_config_file(void)\n{\n\tinit_data(conf_file, global_init_keywords);\n}\n\n/* Daemon stop sequence */\nvoid\nstop_keepalived(void)\n{\n#ifndef _DEBUG_\n\t/* Just cleanup memory & exit */\n\tthread_destroy_master(master);\n\n#ifdef _WITH_VRRP_\n\tif (__test_bit(DAEMON_VRRP, &daemon_mode))\n\t\tpidfile_rm(vrrp_pidfile);\n#endif\n\n#ifdef _WITH_LVS_\n\tif (__test_bit(DAEMON_CHECKERS, &daemon_mode))\n\t\tpidfile_rm(checkers_pidfile);\n#endif\n\n#ifdef _WITH_BFD_\n\tif (__test_bit(DAEMON_BFD, &daemon_mode))\n\t\tpidfile_rm(bfd_pidfile);\n#endif\n\n\tpidfile_rm(main_pidfile);\n#endif\n}\n\n/* Daemon init sequence */\nstatic int\nstart_keepalived(void)\n{\n\tbool have_child = false;\n\n#ifdef _WITH_BFD_\n\t/* must be opened before vrrp and bfd start */\n\topen_bfd_pipes();\n#endif\n\n#ifdef _WITH_LVS_\n\t/* start healthchecker child */\n\tif (running_checker()) {\n\t\tstart_check_child();\n\t\thave_child = true;\n\t}\n#endif\n#ifdef _WITH_VRRP_\n\t/* start vrrp child */\n\tif (running_vrrp()) {\n\t\tstart_vrrp_child();\n\t\thave_child = true;\n\t}\n#endif\n#ifdef _WITH_BFD_\n\t/* start bfd child */\n\tif (running_bfd()) {\n\t\tstart_bfd_child();\n\t\thave_child = true;\n\t}\n#endif\n\n\treturn have_child;\n}\n\nstatic void\nvalidate_config(void)\n{\n#ifdef _WITH_VRRP_\n\tkernel_netlink_read_interfaces();\n#endif\n\n#ifdef _WITH_LVS_\n\t/* validate healthchecker config */\n#ifndef _DEBUG_\n\tprog_type = PROG_TYPE_CHECKER;\n#endif\n\tcheck_validate_config();\n#endif\n#ifdef _WITH_VRRP_\n\t/* validate vrrp config */\n#ifndef _DEBUG_\n\tprog_type = PROG_TYPE_VRRP;\n#endif\n\tvrrp_validate_config();\n#endif\n#ifdef _WITH_BFD_\n\t/* validate bfd config */\n#ifndef _DEBUG_\n\tprog_type = PROG_TYPE_BFD;\n#endif\n\tbfd_validate_config();\n#endif\n}\n\nstatic void\nconfig_test_exit(void)\n{\n\tconfig_err_t config_err = get_config_status();\n\n\tswitch (config_err) {\n\tcase CONFIG_OK:\n\t\texit(KEEPALIVED_EXIT_OK);\n\tcase CONFIG_FILE_NOT_FOUND:\n\tcase CONFIG_BAD_IF:\n\tcase CONFIG_FATAL:\n\t\texit(KEEPALIVED_EXIT_CONFIG);\n\tcase CONFIG_SECURITY_ERROR:\n\t\texit(KEEPALIVED_EXIT_CONFIG_TEST_SECURITY);\n\tdefault:\n\t\texit(KEEPALIVED_EXIT_CONFIG_TEST);\n\t}\n}\n\n#ifndef _DEBUG_\nstatic bool reload_config(void)\n{\n\tbool unsupported_change = false;\n\n\tlog_message(LOG_INFO, \"Reloading ...\");\n\n\t/* Make sure there isn't an attempt to change the network namespace or instance name */\n\told_global_data = global_data;\n\tglobal_data = NULL;\n\tglobal_data = alloc_global_data();\n\n\tread_config_file();\n\n\tinit_global_data(global_data, old_global_data);\n\n#if HAVE_DECL_CLONE_NEWNET\n\tif (!!old_global_data->network_namespace != !!global_data->network_namespace ||\n\t    (global_data->network_namespace && strcmp(old_global_data->network_namespace, global_data->network_namespace))) {\n\t\tlog_message(LOG_INFO, \"Cannot change network namespace at a reload - please restart %s\", PACKAGE);\n\t\tunsupported_change = true;\n\t}\n\tFREE_PTR(global_data->network_namespace);\n\tglobal_data->network_namespace = old_global_data->network_namespace;\n\told_global_data->network_namespace = NULL;\n#endif\n\n\tif (!!old_global_data->instance_name != !!global_data->instance_name ||\n\t    (global_data->instance_name && strcmp(old_global_data->instance_name, global_data->instance_name))) {\n\t\tlog_message(LOG_INFO, \"Cannot change instance name at a reload - please restart %s\", PACKAGE);\n\t\tunsupported_change = true;\n\t}\n\tFREE_PTR(global_data->instance_name);\n\tglobal_data->instance_name = old_global_data->instance_name;\n\told_global_data->instance_name = NULL;\n\n\tif (unsupported_change) {\n\t\t/* We cannot reload the configuration, so continue with the old config */\n\t\tfree_global_data (global_data);\n\t\tglobal_data = old_global_data;\n\t}\n\telse\n\t\tfree_global_data (old_global_data);\n\n\treturn !unsupported_change;\n}\n\n/* SIGHUP/USR1/USR2 handler */\nstatic void\npropagate_signal(__attribute__((unused)) void *v, int sig)\n{\n\tif (sig == SIGHUP) {\n\t\tif (!reload_config())\n\t\t\treturn;\n\t}\n\n\t/* Signal child processes */\n#ifdef _WITH_VRRP_\n\tif (vrrp_child > 0)\n\t\tkill(vrrp_child, sig);\n\telse if (sig == SIGHUP && running_vrrp())\n\t\tstart_vrrp_child();\n#endif\n#ifdef _WITH_LVS_\n\tif (sig == SIGHUP) {\n\t\tif (checkers_child > 0)\n\t\t\tkill(checkers_child, sig);\n\t\telse if (running_checker())\n\t\t\tstart_check_child();\n\t}\n#endif\n#ifdef _WITH_BFD_\n\tif (sig == SIGHUP) {\n\t\tif (bfd_child > 0)\n\t\t\tkill(bfd_child, sig);\n\t\telse if (running_bfd())\n\t\t\tstart_bfd_child();\n\t}\n#endif\n}\n\n/* Terminate handler */\nstatic void\nsigend(__attribute__((unused)) void *v, __attribute__((unused)) int sig)\n{\n\tint status;\n\tint ret;\n\tint wait_count = 0;\n\tstruct timeval start_time, now;\n#ifdef HAVE_SIGNALFD\n\tstruct timeval timeout = {\n\t\t.tv_sec = child_wait_time,\n\t\t.tv_usec = 0\n\t};\n\tint signal_fd = master->signal_fd;\n\tfd_set read_set;\n\tstruct signalfd_siginfo siginfo;\n\tsigset_t sigmask;\n#else\n\tsigset_t old_set, child_wait;\n\tstruct timespec timeout = {\n\t\t.tv_sec = child_wait_time,\n\t\t.tv_nsec = 0\n\t};\n#endif\n\n\t/* register the terminate thread */\n\tthread_add_terminate_event(master);\n\n\tlog_message(LOG_INFO, \"Stopping\");\n\n#ifdef HAVE_SIGNALFD\n\t/* We only want to receive SIGCHLD now */\n\tsigemptyset(&sigmask);\n\tsigaddset(&sigmask, SIGCHLD);\n\tsignalfd(signal_fd, &sigmask, 0);\n\tFD_ZERO(&read_set);\n#else\n\tsigmask_func(0, NULL, &old_set);\n\tif (!sigismember(&old_set, SIGCHLD)) {\n\t\tsigemptyset(&child_wait);\n\t\tsigaddset(&child_wait, SIGCHLD);\n\t\tsigmask_func(SIG_BLOCK, &child_wait, NULL);\n\t}\n#endif\n\n#ifdef _WITH_VRRP_\n\tif (vrrp_child > 0) {\n\t\tif (kill(vrrp_child, SIGTERM)) {\n\t\t\t/* ESRCH means no such process */\n\t\t\tif (errno == ESRCH)\n\t\t\t\tvrrp_child = 0;\n\t\t}\n\t\telse\n\t\t\twait_count++;\n\t}\n#endif\n#ifdef _WITH_LVS_\n\tif (checkers_child > 0) {\n\t\tif (kill(checkers_child, SIGTERM)) {\n\t\t\tif (errno == ESRCH)\n\t\t\t\tcheckers_child = 0;\n\t\t}\n\t\telse\n\t\t\twait_count++;\n\t}\n#endif\n#ifdef _WITH_BFD_\n\tif (bfd_child > 0) {\n\t\tif (kill(bfd_child, SIGTERM)) {\n\t\t\tif (errno == ESRCH)\n\t\t\t\tbfd_child = 0;\n\t\t}\n\t\telse\n\t\t\twait_count++;\n\t}\n#endif\n\n\tgettimeofday(&start_time, NULL);\n\twhile (wait_count) {\n#ifdef HAVE_SIGNALFD\n\t\tFD_SET(signal_fd, &read_set);\n\t\tret = select(signal_fd + 1, &read_set, NULL, NULL, &timeout);\n\t\tif (ret == 0)\n\t\t\tbreak;\n\t\tif (ret == -1) {\n\t\t\tif (errno == EINTR)\n\t\t\t\tcontinue;\n\n\t\t\tlog_message(LOG_INFO, \"Terminating select returned errno %d\", errno);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!FD_ISSET(signal_fd, &read_set)) {\n\t\t\tlog_message(LOG_INFO, \"Terminating select did not return select_fd\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (read(signal_fd, &siginfo, sizeof(siginfo)) != sizeof(siginfo)) {\n\t\t\tlog_message(LOG_INFO, \"Terminating signal read did not read entire siginfo\");\n\t\t\tbreak;\n\t\t}\n\n\t\tstatus = siginfo.ssi_code == CLD_EXITED ? W_EXITCODE(siginfo.ssi_status, 0) :\n\t\t\t siginfo.ssi_code == CLD_KILLED ? W_EXITCODE(0, siginfo.ssi_status) :\n\t\t\t\t\t\t\t   WCOREFLAG;\n\n#ifdef _WITH_VRRP_\n\t\tif (vrrp_child > 0 && vrrp_child == (pid_t)siginfo.ssi_pid) {\n\t\t\treport_child_status(status, vrrp_child, PROG_VRRP);\n\t\t\tvrrp_child = 0;\n\t\t\twait_count--;\n\t\t}\n#endif\n\n#ifdef _WITH_LVS_\n\t\tif (checkers_child > 0 && checkers_child == (pid_t)siginfo.ssi_pid) {\n\t\t\treport_child_status(status, checkers_child, PROG_CHECK);\n\t\t\tcheckers_child = 0;\n\t\t\twait_count--;\n\t\t}\n#endif\n#ifdef _WITH_BFD_\n\t\tif (bfd_child > 0 && bfd_child == (pid_t)siginfo.ssi_pid) {\n\t\t\treport_child_status(status, bfd_child, PROG_BFD);\n\t\t\tbfd_child = 0;\n\t\t\twait_count--;\n\t\t}\n#endif\n\n#else\n\t\tret = sigtimedwait(&child_wait, NULL, &timeout);\n\t\tif (ret == -1) {\n\t\t\tif (errno == EINTR)\n\t\t\t\tcontinue;\n\t\t\tif (errno == EAGAIN)\n\t\t\t\tbreak;\n\t\t}\n\n#ifdef _WITH_VRRP_\n\t\tif (vrrp_child > 0 && vrrp_child == waitpid(vrrp_child, &status, WNOHANG)) {\n\t\t\treport_child_status(status, vrrp_child, PROG_VRRP);\n\t\t\tvrrp_child = 0;\n\t\t\twait_count--;\n\t\t}\n#endif\n\n#ifdef _WITH_LVS_\n\t\tif (checkers_child > 0 && checkers_child == waitpid(checkers_child, &status, WNOHANG)) {\n\t\t\treport_child_status(status, checkers_child, PROG_CHECK);\n\t\t\tcheckers_child = 0;\n\t\t\twait_count--;\n\t\t}\n#endif\n#ifdef _WITH_BFD_\n\t\tif (bfd_child > 0 && bfd_child == waitpid(bfd_child, &status, WNOHANG)) {\n\t\t\treport_child_status(status, bfd_child, PROG_BFD);\n\t\t\tbfd_child = 0;\n\t\t\twait_count--;\n\t\t}\n#endif\n\n#endif\n\n\t\tif (wait_count) {\n\t\t\tgettimeofday(&now, NULL);\n\t\t\ttimeout.tv_sec = child_wait_time - (now.tv_sec - start_time.tv_sec);\n#ifdef HAVE_SIGNALFD\n\t\t\ttimeout.tv_usec = (start_time.tv_usec - now.tv_usec);\n\t\t\tif (timeout.tv_usec < 0) {\n\t\t\t\ttimeout.tv_usec += 1000000L;\n\t\t\t\ttimeout.tv_sec--;\n\t\t\t}\n#else\n\t\t\ttimeout.tv_nsec = (start_time.tv_usec - now.tv_usec) * 1000;\n\t\t\tif (timeout.tv_nsec < 0) {\n\t\t\t\ttimeout.tv_nsec += 1000000000L;\n\t\t\t\ttimeout.tv_sec--;\n\t\t\t}\n#endif\n\t\t\tif (timeout.tv_sec < 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* A child may not have terminated, so force its termination */\n#ifdef _WITH_VRRP_\n\tif (vrrp_child) {\n\t\tlog_message(LOG_INFO, \"vrrp process failed to die - forcing termination\");\n\t\tkill(vrrp_child, SIGKILL);\n\t}\n#endif\n#ifdef _WITH_LVS_\n\tif (checkers_child) {\n\t\tlog_message(LOG_INFO, \"checker process failed to die - forcing termination\");\n\t\tkill(checkers_child, SIGKILL);\n\t}\n#endif\n#ifdef _WITH_BFD_\n\tif (bfd_child) {\n\t\tlog_message(LOG_INFO, \"bfd process failed to die - forcing termination\");\n\t\tkill(bfd_child, SIGKILL);\n\t}\n#endif\n\n#ifndef HAVE_SIGNALFD\n\tif (!sigismember(&old_set, SIGCHLD))\n\t\tsigmask_func(SIG_UNBLOCK, &child_wait, NULL);\n#endif\n}\n#endif\n\n/* Initialize signal handler */\nstatic void\nsignal_init(void)\n{\n#ifndef _DEBUG_\n\tsignal_set(SIGHUP, propagate_signal, NULL);\n\tsignal_set(SIGUSR1, propagate_signal, NULL);\n\tsignal_set(SIGUSR2, propagate_signal, NULL);\n#ifdef _WITH_JSON_\n\tsignal_set(SIGJSON, propagate_signal, NULL);\n#endif\n\tsignal_set(SIGINT, sigend, NULL);\n\tsignal_set(SIGTERM, sigend, NULL);\n#endif\n\tsignal_ignore(SIGPIPE);\n}\n\n/* To create a core file when abrt is running (a RedHat distribution),\n * and keepalived isn't installed from an RPM package, edit the file\n * \u201c/etc/abrt/abrt.conf\u201d, and change the value of the field\n * \u201cProcessUnpackaged\u201d to \u201cyes\u201d.\n *\n * Alternatively, use the -M command line option. */\nstatic void\nupdate_core_dump_pattern(const char *pattern_str)\n{\n\tint fd;\n\tbool initialising = (orig_core_dump_pattern == NULL);\n\n\t/* CORENAME_MAX_SIZE in kernel source include/linux/binfmts.h defines\n\t * the maximum string length, * see core_pattern[CORENAME_MAX_SIZE] in\n\t * fs/coredump.c. Currently (Linux 4.10) defines it to be 128, but the\n\t * definition is not exposed to user-space. */\n#define\tCORENAME_MAX_SIZE\t128\n\n\tif (initialising)\n\t\torig_core_dump_pattern = MALLOC(CORENAME_MAX_SIZE);\n\n\tfd = open (\"/proc/sys/kernel/core_pattern\", O_RDWR);\n\n\tif (fd == -1 ||\n\t    (initialising && read(fd, orig_core_dump_pattern, CORENAME_MAX_SIZE - 1) == -1) ||\n\t    write(fd, pattern_str, strlen(pattern_str)) == -1) {\n\t\tlog_message(LOG_INFO, \"Unable to read/write core_pattern\");\n\n\t\tif (fd != -1)\n\t\t\tclose(fd);\n\n\t\tFREE(orig_core_dump_pattern);\n\n\t\treturn;\n\t}\n\n\tclose(fd);\n\n\tif (!initialising)\n\t\tFREE_PTR(orig_core_dump_pattern);\n}\n\nstatic void\ncore_dump_init(void)\n{\n\tstruct rlimit orig_rlim, rlim;\n\n\tif (set_core_dump_pattern) {\n\t\t/* If we set the core_pattern here, we will attempt to restore it when we\n\t\t * exit. This will be fine if it is a child of ours that core dumps,\n\t\t * but if we ourself core dump, then the core_pattern will not be restored */\n\t\tupdate_core_dump_pattern(core_dump_pattern);\n\t}\n\n\tif (create_core_dump) {\n\t\trlim.rlim_cur = RLIM_INFINITY;\n\t\trlim.rlim_max = RLIM_INFINITY;\n\n\t\tif (getrlimit(RLIMIT_CORE, &orig_rlim) == -1)\n\t\t\tlog_message(LOG_INFO, \"Failed to get core file size\");\n\t\telse if (setrlimit(RLIMIT_CORE, &rlim) == -1)\n\t\t\tlog_message(LOG_INFO, \"Failed to set core file size\");\n\t\telse\n\t\t\tset_child_rlimit(RLIMIT_CORE, &orig_rlim);\n\t}\n}\n\nstatic mode_t\nset_umask(const char *optarg)\n{\n\tlong umask_long;\n\tmode_t umask_val;\n\tchar *endptr;\n\n\tumask_long = strtoll(optarg, &endptr, 0);\n\n\tif (*endptr || umask_long < 0 || umask_long & ~0777L) {\n\t\tfprintf(stderr, \"Invalid --umask option %s\", optarg);\n\t\treturn 0;\n\t}\n\n\tumask_val = umask_long & 0777;\n\tumask(umask_val);\n\n\tumask_cmdline = true;\n\n\treturn umask_val;\n}\n\nvoid\ninitialise_debug_options(void)\n{\n#if defined WITH_DEBUG_OPTIONS && !defined _DEBUG_\n\tchar mask = 0;\n\n\tif (prog_type == PROG_TYPE_PARENT)\n\t\tmask = 1 << PROG_TYPE_PARENT;\n#if _WITH_BFD_\n\telse if (prog_type == PROG_TYPE_BFD)\n\t\tmask = 1 << PROG_TYPE_BFD;\n#endif\n#if _WITH_LVS_\n\telse if (prog_type == PROG_TYPE_CHECKER)\n\t\tmask = 1 << PROG_TYPE_CHECKER;\n#endif\n#if _WITH_VRRP_\n\telse if (prog_type == PROG_TYPE_VRRP)\n\t\tmask = 1 << PROG_TYPE_VRRP;\n#endif\n\n#ifdef _TIMER_CHECK_\n\tdo_timer_check = !!(timer_debug & mask);\n#endif\n#ifdef _SMTP_ALERT_DEBUG_\n\tdo_smtp_alert_debug = !!(smtp_debug & mask);\n#endif\n#ifdef _EPOLL_DEBUG_\n\tdo_epoll_debug = !!(epoll_debug & mask);\n#endif\n#ifdef _EPOLL_THREAD_DUMP_\n\tdo_epoll_thread_dump = !!(epoll_thread_debug & mask);\n#endif\n#ifdef _REGEX_DEBUG_\n\tdo_regex_debug = !!(regex_debug & mask);\n#endif\n#ifdef _WITH_REGEX_TIMERS_\n\tdo_regex_timers = !!(regex_timers & mask);\n#endif\n#ifdef _TSM_DEBUG_\n\tdo_tsm_debug = !!(tsm_debug & mask);\n#endif\n#ifdef _VRRP_FD_DEBUG_\n\tdo_vrrp_fd_debug = !!(vrrp_fd_debug & mask);\n#endif\n#ifdef _NETLINK_TIMERS_\n\tdo_netlink_timers = !!(netlink_timer_debug & mask);\n#endif\n#endif\n}\n\n#ifdef  WITH_DEBUG_OPTIONS\nstatic void\nset_debug_options(const char *options)\n{\n\tchar all_processes, processes;\n\tchar opt;\n\tconst char *opt_p = options;\n\n#ifdef _DEBUG_\n\tall_processes = 1;\n#else\n\tall_processes = (1 << PROG_TYPE_PARENT);\n#if _WITH_BFD_\n\tall_processes |= (1 << PROG_TYPE_BFD);\n#endif\n#if _WITH_LVS_\n\tall_processes |= (1 << PROG_TYPE_CHECKER);\n#endif\n#if _WITH_VRRP_\n\tall_processes |= (1 << PROG_TYPE_VRRP);\n#endif\n#endif\n\n\tif (!options) {\n#ifdef _TIMER_CHECK_\n\t\ttimer_debug = all_processes;\n#endif\n#ifdef _SMTP_ALERT_DEBUG_\n\t\tsmtp_debug = all_processes;\n#endif\n#ifdef _EPOLL_DEBUG_\n\t\tepoll_debug = all_processes;\n#endif\n#ifdef _EPOLL_THREAD_DUMP_\n\t\tepoll_thread_debug = all_processes;\n#endif\n#ifdef _REGEX_DEBUG_\n\t\tregex_debug = all_processes;\n#endif\n#ifdef _WITH_REGEX_TIMERS_\n\t\tregex_timers = all_processes;\n#endif\n#ifdef _TSM_DEBUG_\n\t\ttsm_debug = all_processes;\n#endif\n#ifdef _VRRP_FD_DEBUG_\n\t\tvrrp_fd_debug = all_processes;\n#endif\n#ifdef _NETLINK_TIMERS_\n\t\tnetlink_timer_debug = all_processes;\n#endif\n\n\t\treturn;\n\t}\n\n\topt_p = options;\n\tdo {\n\t\tif (!isupper(*opt_p)) {\n\t\t\tfprintf(stderr, \"Unknown debug option'%c' in '%s'\\n\", *opt_p, options);\n\t\t\treturn;\n\t\t}\n\t\topt = *opt_p++;\n\n#ifdef _DEBUG_\n\t\tprocesses = all_processes;\n#else\n\t\tif (!*opt_p || isupper(*opt_p))\n\t\t\tprocesses = all_processes;\n\t\telse {\n\t\t\tprocesses = 0;\n\t\t\twhile (*opt_p && !isupper(*opt_p)) {\n\t\t\t\tswitch (*opt_p) {\n\t\t\t\tcase 'p':\n\t\t\t\t\tprocesses |= (1 << PROG_TYPE_PARENT);\n\t\t\t\t\tbreak;\n#if _WITH_BFD_\n\t\t\t\tcase 'b':\n\t\t\t\t\tprocesses |= (1 << PROG_TYPE_BFD);\n\t\t\t\t\tbreak;\n#endif\n#if _WITH_LVS_\n\t\t\t\tcase 'c':\n\t\t\t\t\tprocesses |= (1 << PROG_TYPE_CHECKER);\n\t\t\t\t\tbreak;\n#endif\n#if _WITH_VRRP_\n\t\t\t\tcase 'v':\n\t\t\t\t\tprocesses |= (1 << PROG_TYPE_VRRP);\n\t\t\t\t\tbreak;\n#endif\n\t\t\t\tdefault:\n\t\t\t\t\tfprintf(stderr, \"Unknown debug process '%c' in '%s'\\n\", *opt_p, options);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\topt_p++;\n\t\t\t}\n\t\t}\n#endif\n\n\t\tswitch (opt) {\n#ifdef _TIMER_CHECK_\n\t\tcase 'T':\n\t\t\ttimer_debug = processes;\n\t\t\tbreak;\n#endif\n#ifdef _SMTP_ALERT_DEBUG_\n\t\tcase 'M':\n\t\t\tsmtp_debug = processes;\n\t\t\tbreak;\n#endif\n#ifdef _EPOLL_DEBUG_\n\t\tcase 'E':\n\t\t\tepoll_debug = processes;\n\t\t\tbreak;\n#endif\n#ifdef _EPOLL_THREAD_DUMP_\n\t\tcase 'D':\n\t\t\tepoll_thread_debug = processes;\n\t\t\tbreak;\n#endif\n#ifdef _REGEX_DEBUG_\n\t\tcase 'R':\n\t\t\tregex_debug = processes;\n\t\t\tbreak;\n#endif\n#ifdef _WITH_REGEX_TIMERS_\n\t\tcase 'X':\n\t\t\tregex_timers = processes;\n\t\t\tbreak;\n#endif\n#ifdef _TSM_DEBUG_\n\t\tcase 'S':\n\t\t\ttsm_debug = processes;\n\t\t\tbreak;\n#endif\n#ifdef _VRRP_FD_DEBUG_\n\t\tcase 'F':\n\t\t\tvrrp_fd_debug = processes;\n\t\t\tbreak;\n#endif\n#ifdef _NETLINK_TIMERS_\n\t\tcase 'N':\n\t\t\tnetlink_timer_debug = processes;\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\t\tfprintf(stderr, \"Unknown debug type '%c' in '%s'\\n\", opt, options);\n\t\t\treturn;\n\t\t}\n\t} while (opt_p && *opt_p);\n}\n#endif\n\n/* Usage function */\nstatic void\nusage(const char *prog)\n{\n\tfprintf(stderr, \"Usage: %s [OPTION...]\\n\", prog);\n\tfprintf(stderr, \"  -f, --use-file=FILE          Use the specified configuration file\\n\");\n#if defined _WITH_VRRP_ && defined _WITH_LVS_\n\tfprintf(stderr, \"  -P, --vrrp                   Only run with VRRP subsystem\\n\");\n\tfprintf(stderr, \"  -C, --check                  Only run with Health-checker subsystem\\n\");\n#endif\n#ifdef _WITH_BFD_\n\tfprintf(stderr, \"  -B, --no_bfd                 Don't run BFD subsystem\\n\");\n#endif\n\tfprintf(stderr, \"      --all                    Force all child processes to run, even if have no configuration\\n\");\n\tfprintf(stderr, \"  -l, --log-console            Log messages to local console\\n\");\n\tfprintf(stderr, \"  -D, --log-detail             Detailed log messages\\n\");\n\tfprintf(stderr, \"  -S, --log-facility=[0-7]     Set syslog facility to LOG_LOCAL[0-7]\\n\");\n\tfprintf(stderr, \"  -g, --log-file=FILE          Also log to FILE (default /tmp/keepalived.log)\\n\");\n\tfprintf(stderr, \"      --flush-log-file         Flush log file on write\\n\");\n\tfprintf(stderr, \"  -G, --no-syslog              Don't log via syslog\\n\");\n\tfprintf(stderr, \"  -u, --umask=MASK             umask for file creation (in numeric form)\\n\");\n#ifdef _WITH_VRRP_\n\tfprintf(stderr, \"  -X, --release-vips           Drop VIP on transition from signal.\\n\");\n\tfprintf(stderr, \"  -V, --dont-release-vrrp      Don't remove VRRP VIPs and VROUTEs on daemon stop\\n\");\n#endif\n#ifdef _WITH_LVS_\n\tfprintf(stderr, \"  -I, --dont-release-ipvs      Don't remove IPVS topology on daemon stop\\n\");\n#endif\n\tfprintf(stderr, \"  -R, --dont-respawn           Don't respawn child processes\\n\");\n\tfprintf(stderr, \"  -n, --dont-fork              Don't fork the daemon process\\n\");\n\tfprintf(stderr, \"  -d, --dump-conf              Dump the configuration data\\n\");\n\tfprintf(stderr, \"  -p, --pid=FILE               Use specified pidfile for parent process\\n\");\n#ifdef _WITH_VRRP_\n\tfprintf(stderr, \"  -r, --vrrp_pid=FILE          Use specified pidfile for VRRP child process\\n\");\n#endif\n#ifdef _WITH_LVS_\n\tfprintf(stderr, \"  -c, --checkers_pid=FILE      Use specified pidfile for checkers child process\\n\");\n\tfprintf(stderr, \"  -a, --address-monitoring     Report all address additions/deletions notified via netlink\\n\");\n#endif\n#ifdef _WITH_BFD_\n\tfprintf(stderr, \"  -b, --bfd_pid=FILE           Use specified pidfile for BFD child process\\n\");\n#endif\n#ifdef _WITH_SNMP_\n\tfprintf(stderr, \"  -x, --snmp                   Enable SNMP subsystem\\n\");\n\tfprintf(stderr, \"  -A, --snmp-agent-socket=FILE Use the specified socket for master agent\\n\");\n#endif\n#if HAVE_DECL_CLONE_NEWNET\n\tfprintf(stderr, \"  -s, --namespace=NAME         Run in network namespace NAME (overrides config)\\n\");\n#endif\n\tfprintf(stderr, \"  -m, --core-dump              Produce core dump if terminate abnormally\\n\");\n\tfprintf(stderr, \"  -M, --core-dump-pattern=PATN Also set /proc/sys/kernel/core_pattern to PATN (default 'core')\\n\");\n#ifdef _MEM_CHECK_LOG_\n\tfprintf(stderr, \"  -L, --mem-check-log          Log malloc/frees to syslog\\n\");\n#endif\n\tfprintf(stderr, \"  -i, --config-id id           Skip any configuration lines beginning '@' that don't match id\\n\"\n\t\t\t\"                                or any lines beginning @^ that do match.\\n\"\n\t\t\t\"                                The config-id defaults to the node name if option not used\\n\");\n\tfprintf(stderr, \"      --signum=SIGFUNC         Return signal number for STOP, RELOAD, DATA, STATS\"\n#ifdef _WITH_JSON_\n\t\t\t\t\t\t\t\t\", JSON\"\n#endif\n\t\t\t\t\t\t\t\t\"\\n\");\n\tfprintf(stderr, \"  -t, --config-test[=LOG_FILE] Check the configuration for obvious errors, output to\\n\"\n\t\t\t\"                                stderr by default\\n\");\n#ifdef _WITH_PERF_\n\tfprintf(stderr, \"      --perf[=PERF_TYPE]       Collect perf data, PERF_TYPE=all, run(default) or end\\n\");\n#endif\n#ifdef WITH_DEBUG_OPTIONS\n\tfprintf(stderr, \"      --debug[=...]            Enable debug options. p, b, c, v specify parent, bfd, checker and vrrp processes\\n\");\n#ifdef _TIMER_CHECK_\n\tfprintf(stderr, \"                                   T - timer debug\\n\");\n#endif\n#ifdef _SMTP_ALERT_DEBUG_\n\tfprintf(stderr, \"                                   M - email alert debug\\n\");\n#endif\n#ifdef _EPOLL_DEBUG_\n\tfprintf(stderr, \"                                   E - epoll debug\\n\");\n#endif\n#ifdef _EPOLL_THREAD_DUMP_\n\tfprintf(stderr, \"                                   D - epoll thread dump debug\\n\");\n#endif\n#ifdef _VRRP_FD_DEBUG\n\tfprintf(stderr, \"                                   F - vrrp fd dump debug\\n\");\n#endif\n#ifdef _REGEX_DEBUG_\n\tfprintf(stderr, \"                                   R - regex debug\\n\");\n#endif\n#ifdef _WITH_REGEX_TIMERS_\n\tfprintf(stderr, \"                                   X - regex timers\\n\");\n#endif\n#ifdef _TSM_DEBUG_\n\tfprintf(stderr, \"                                   S - TSM debug\\n\");\n#endif\n#ifdef _NETLINK_TIMERS_\n\tfprintf(stderr, \"                                   N - netlink timer debug\\n\");\n#endif\n\tfprintf(stderr, \"                                 Example --debug=TpMEvcp\\n\");\n#endif\n\tfprintf(stderr, \"  -v, --version                Display the version number\\n\");\n\tfprintf(stderr, \"  -h, --help                   Display this help message\\n\");\n}\n\n/* Command line parser */\nstatic bool\nparse_cmdline(int argc, char **argv)\n{\n\tint c;\n\tbool reopen_log = false;\n\tint signum;\n\tstruct utsname uname_buf;\n\tint longindex;\n\tint curind;\n\tbool bad_option = false;\n\tunsigned facility;\n\tmode_t new_umask_val;\n\n\tstruct option long_options[] = {\n\t\t{\"use-file\",\t\trequired_argument,\tNULL, 'f'},\n#if defined _WITH_VRRP_ && defined _WITH_LVS_\n\t\t{\"vrrp\",\t\tno_argument,\t\tNULL, 'P'},\n\t\t{\"check\",\t\tno_argument,\t\tNULL, 'C'},\n#endif\n#ifdef _WITH_BFD_\n\t\t{\"no_bfd\",\t\tno_argument,\t\tNULL, 'B'},\n#endif\n\t\t{\"all\",\t\t\tno_argument,\t\tNULL,  3 },\n\t\t{\"log-console\",\t\tno_argument,\t\tNULL, 'l'},\n\t\t{\"log-detail\",\t\tno_argument,\t\tNULL, 'D'},\n\t\t{\"log-facility\",\trequired_argument,\tNULL, 'S'},\n\t\t{\"log-file\",\t\toptional_argument,\tNULL, 'g'},\n\t\t{\"flush-log-file\",\tno_argument,\t\tNULL,  2 },\n\t\t{\"no-syslog\",\t\tno_argument,\t\tNULL, 'G'},\n\t\t{\"umask\",\t\trequired_argument,\tNULL, 'u'},\n#ifdef _WITH_VRRP_\n\t\t{\"release-vips\",\tno_argument,\t\tNULL, 'X'},\n\t\t{\"dont-release-vrrp\",\tno_argument,\t\tNULL, 'V'},\n#endif\n#ifdef _WITH_LVS_\n\t\t{\"dont-release-ipvs\",\tno_argument,\t\tNULL, 'I'},\n#endif\n\t\t{\"dont-respawn\",\tno_argument,\t\tNULL, 'R'},\n\t\t{\"dont-fork\",\t\tno_argument,\t\tNULL, 'n'},\n\t\t{\"dump-conf\",\t\tno_argument,\t\tNULL, 'd'},\n\t\t{\"pid\",\t\t\trequired_argument,\tNULL, 'p'},\n#ifdef _WITH_VRRP_\n\t\t{\"vrrp_pid\",\t\trequired_argument,\tNULL, 'r'},\n#endif\n#ifdef _WITH_LVS_\n\t\t{\"checkers_pid\",\trequired_argument,\tNULL, 'c'},\n\t\t{\"address-monitoring\",\tno_argument,\t\tNULL, 'a'},\n#endif\n#ifdef _WITH_BFD_\n\t\t{\"bfd_pid\",\t\trequired_argument,\tNULL, 'b'},\n#endif\n#ifdef _WITH_SNMP_\n\t\t{\"snmp\",\t\tno_argument,\t\tNULL, 'x'},\n\t\t{\"snmp-agent-socket\",\trequired_argument,\tNULL, 'A'},\n#endif\n\t\t{\"core-dump\",\t\tno_argument,\t\tNULL, 'm'},\n\t\t{\"core-dump-pattern\",\toptional_argument,\tNULL, 'M'},\n#ifdef _MEM_CHECK_LOG_\n\t\t{\"mem-check-log\",\tno_argument,\t\tNULL, 'L'},\n#endif\n#if HAVE_DECL_CLONE_NEWNET\n\t\t{\"namespace\",\t\trequired_argument,\tNULL, 's'},\n#endif\n\t\t{\"config-id\",\t\trequired_argument,\tNULL, 'i'},\n\t\t{\"signum\",\t\trequired_argument,\tNULL,  4 },\n\t\t{\"config-test\",\t\toptional_argument,\tNULL, 't'},\n#ifdef _WITH_PERF_\n\t\t{\"perf\",\t\toptional_argument,\tNULL,  5 },\n#endif\n#ifdef WITH_DEBUG_OPTIONS\n\t\t{\"debug\",\t\toptional_argument,\tNULL,  6 },\n#endif\n\t\t{\"version\",\t\tno_argument,\t\tNULL, 'v'},\n\t\t{\"help\",\t\tno_argument,\t\tNULL, 'h'},\n\n\t\t{NULL,\t\t\t0,\t\t\tNULL,  0 }\n\t};\n\n\t/* Unfortunately, if a short option is used, getopt_long() doesn't change the value\n\t * of longindex, so we need to ensure that before calling getopt_long(), longindex\n\t * is set to a known invalid value */\n\tcurind = optind;\n\twhile (longindex = -1, (c = getopt_long(argc, argv, \":vhlndu:DRS:f:p:i:mM::g::Gt::\"\n#if defined _WITH_VRRP_ && defined _WITH_LVS_\n\t\t\t\t\t    \"PC\"\n#endif\n#ifdef _WITH_VRRP_\n\t\t\t\t\t    \"r:VX\"\n#endif\n#ifdef _WITH_LVS_\n\t\t\t\t\t    \"ac:I\"\n#endif\n#ifdef _WITH_BFD_\n\t\t\t\t\t    \"Bb:\"\n#endif\n#ifdef _WITH_SNMP_\n\t\t\t\t\t    \"xA:\"\n#endif\n#ifdef _MEM_CHECK_LOG_\n\t\t\t\t\t    \"L\"\n#endif\n#if HAVE_DECL_CLONE_NEWNET\n\t\t\t\t\t    \"s:\"\n#endif\n\t\t\t\t, long_options, &longindex)) != -1) {\n\n\t\t/* Check for an empty option argument. For example --use-file= returns\n\t\t * a 0 length option, which we don't want */\n\t\tif (longindex >= 0 && long_options[longindex].has_arg == required_argument && optarg && !optarg[0]) {\n\t\t\tc = ':';\n\t\t\toptarg = NULL;\n\t\t}\n\n\t\tswitch (c) {\n\t\tcase 'v':\n\t\t\tfprintf(stderr, \"%s\", version_string);\n#ifdef GIT_COMMIT\n\t\t\tfprintf(stderr, \", git commit %s\", GIT_COMMIT);\n#endif\n\t\t\tfprintf(stderr, \"\\n\\n%s\\n\\n\", COPYRIGHT_STRING);\n\t\t\tfprintf(stderr, \"Built with kernel headers for Linux %d.%d.%d\\n\",\n\t\t\t\t\t\t(LINUX_VERSION_CODE >> 16) & 0xff,\n\t\t\t\t\t\t(LINUX_VERSION_CODE >>  8) & 0xff,\n\t\t\t\t\t\t(LINUX_VERSION_CODE      ) & 0xff);\n\t\t\tuname(&uname_buf);\n\t\t\tfprintf(stderr, \"Running on %s %s %s\\n\\n\", uname_buf.sysname, uname_buf.release, uname_buf.version);\n\t\t\tfprintf(stderr, \"configure options: %s\\n\\n\", KEEPALIVED_CONFIGURE_OPTIONS);\n\t\t\tfprintf(stderr, \"Config options: %s\\n\\n\", CONFIGURATION_OPTIONS);\n\t\t\tfprintf(stderr, \"System options: %s\\n\", SYSTEM_OPTIONS);\n\t\t\texit(0);\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\tusage(argv[0]);\n\t\t\texit(0);\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\t__set_bit(LOG_CONSOLE_BIT, &debug);\n\t\t\treopen_log = true;\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\t__set_bit(DONT_FORK_BIT, &debug);\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\t__set_bit(DUMP_CONF_BIT, &debug);\n\t\t\tbreak;\n#ifdef _WITH_VRRP_\n\t\tcase 'V':\n\t\t\t__set_bit(DONT_RELEASE_VRRP_BIT, &debug);\n\t\t\tbreak;\n#endif\n#ifdef _WITH_LVS_\n\t\tcase 'I':\n\t\t\t__set_bit(DONT_RELEASE_IPVS_BIT, &debug);\n\t\t\tbreak;\n#endif\n\t\tcase 'D':\n\t\t\tif (__test_bit(LOG_DETAIL_BIT, &debug))\n\t\t\t\t__set_bit(LOG_EXTRA_DETAIL_BIT, &debug);\n\t\t\telse\n\t\t\t\t__set_bit(LOG_DETAIL_BIT, &debug);\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\t__set_bit(DONT_RESPAWN_BIT, &debug);\n\t\t\tbreak;\n#ifdef _WITH_VRRP_\n\t\tcase 'X':\n\t\t\t__set_bit(RELEASE_VIPS_BIT, &debug);\n\t\t\tbreak;\n#endif\n\t\tcase 'S':\n\t\t\tif (!read_unsigned(optarg, &facility, 0, LOG_FACILITY_MAX, false))\n\t\t\t\tfprintf(stderr, \"Invalid log facility '%s'\\n\", optarg);\n\t\t\telse {\n\t\t\t\tlog_facility = LOG_FACILITY[facility].facility;\n\t\t\t\treopen_log = true;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'g':\n\t\t\tif (optarg && optarg[0])\n\t\t\t\tlog_file_name = optarg;\n\t\t\telse\n\t\t\t\tlog_file_name = \"/tmp/keepalived.log\";\n\t\t\topen_log_file(log_file_name, NULL, NULL, NULL);\n\t\t\tbreak;\n\t\tcase 'G':\n\t\t\t__set_bit(NO_SYSLOG_BIT, &debug);\n\t\t\treopen_log = true;\n\t\t\tbreak;\n\t\tcase 'u':\n\t\t\tnew_umask_val = set_umask(optarg);\n\t\t\tif (umask_cmdline)\n\t\t\t\tumask_val = new_umask_val;\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\t__set_bit(CONFIG_TEST_BIT, &debug);\n\t\t\t__set_bit(DONT_RESPAWN_BIT, &debug);\n\t\t\t__set_bit(DONT_FORK_BIT, &debug);\n\t\t\t__set_bit(NO_SYSLOG_BIT, &debug);\n\t\t\tif (optarg && optarg[0]) {\n\t\t\t\tint fd = open(optarg, O_WRONLY | O_APPEND | O_CREAT | O_NOFOLLOW, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n\t\t\t\tif (fd == -1) {\n\t\t\t\t\tfprintf(stderr, \"Unable to open config-test log file %s\\n\", optarg);\n\t\t\t\t\texit(EXIT_FAILURE);\n\t\t\t\t}\n\t\t\t\tdup2(fd, STDERR_FILENO);\n\t\t\t\tclose(fd);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tconf_file = optarg;\n\t\t\tbreak;\n\t\tcase 2:\t\t/* --flush-log-file */\n\t\t\tset_flush_log_file();\n\t\t\tbreak;\n#if defined _WITH_VRRP_ && defined _WITH_LVS_\n\t\tcase 'P':\n\t\t\t__clear_bit(DAEMON_CHECKERS, &daemon_mode);\n\t\t\tbreak;\n\t\tcase 'C':\n\t\t\t__clear_bit(DAEMON_VRRP, &daemon_mode);\n\t\t\tbreak;\n#endif\n#ifdef _WITH_BFD_\n\t\tcase 'B':\n\t\t\t__clear_bit(DAEMON_BFD, &daemon_mode);\n\t\t\tbreak;\n#endif\n\t\tcase 'p':\n\t\t\tmain_pidfile = optarg;\n\t\t\tbreak;\n#ifdef _WITH_LVS_\n\t\tcase 'c':\n\t\t\tcheckers_pidfile = optarg;\n\t\t\tbreak;\n\t\tcase 'a':\n\t\t\t__set_bit(LOG_ADDRESS_CHANGES, &debug);\n\t\t\tbreak;\n#endif\n#ifdef _WITH_VRRP_\n\t\tcase 'r':\n\t\t\tvrrp_pidfile = optarg;\n\t\t\tbreak;\n#endif\n#ifdef _WITH_BFD_\n\t\tcase 'b':\n\t\t\tbfd_pidfile = optarg;\n\t\t\tbreak;\n#endif\n#ifdef _WITH_SNMP_\n\t\tcase 'x':\n\t\t\tsnmp = 1;\n\t\t\tbreak;\n\t\tcase 'A':\n\t\t\tsnmp_socket = optarg;\n\t\t\tbreak;\n#endif\n\t\tcase 'M':\n\t\t\tset_core_dump_pattern = true;\n\t\t\tif (optarg && optarg[0])\n\t\t\t\tcore_dump_pattern = optarg;\n\t\t\t/* ... falls through ... */\n\t\tcase 'm':\n\t\t\tcreate_core_dump = true;\n\t\t\tbreak;\n#ifdef _MEM_CHECK_LOG_\n\t\tcase 'L':\n\t\t\t__set_bit(MEM_CHECK_LOG_BIT, &debug);\n\t\t\tbreak;\n#endif\n#if HAVE_DECL_CLONE_NEWNET\n\t\tcase 's':\n\t\t\toverride_namespace = MALLOC(strlen(optarg) + 1);\n\t\t\tstrcpy(override_namespace, optarg);\n\t\t\tbreak;\n#endif\n\t\tcase 'i':\n\t\t\tFREE_PTR(config_id);\n\t\t\tconfig_id = MALLOC(strlen(optarg) + 1);\n\t\t\tstrcpy(config_id, optarg);\n\t\t\tbreak;\n\t\tcase 4:\t\t\t/* --signum */\n\t\t\tsignum = get_signum(optarg);\n\t\t\tif (signum == -1) {\n\t\t\t\tfprintf(stderr, \"Unknown sigfunc %s\\n\", optarg);\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\tprintf(\"%d\\n\", signum);\n\t\t\texit(0);\n\t\t\tbreak;\n\t\tcase 3:\t\t\t/* --all */\n\t\t\t__set_bit(RUN_ALL_CHILDREN, &daemon_mode);\n#ifdef _WITH_VRRP_\n\t\t\t__set_bit(DAEMON_VRRP, &daemon_mode);\n#endif\n#ifdef _WITH_LVS_\n\t\t\t__set_bit(DAEMON_CHECKERS, &daemon_mode);\n#endif\n#ifdef _WITH_BFD_\n\t\t\t__set_bit(DAEMON_BFD, &daemon_mode);\n#endif\n\t\t\tbreak;\n#ifdef _WITH_PERF_\n\t\tcase 5:\n\t\t\tif (optarg && optarg[0]) {\n\t\t\t\tif (!strcmp(optarg, \"run\"))\n\t\t\t\t\tperf_run = PERF_RUN;\n\t\t\t\telse if (!strcmp(optarg, \"all\"))\n\t\t\t\t\tperf_run = PERF_ALL;\n\t\t\t\telse if (!strcmp(optarg, \"end\"))\n\t\t\t\t\tperf_run = PERF_END;\n\t\t\t\telse\n\t\t\t\t\tlog_message(LOG_INFO, \"Unknown perf start point %s\", optarg);\n\t\t\t}\n\t\t\telse\n\t\t\t\tperf_run = PERF_RUN;\n\n\t\t\tbreak;\n#endif\n#ifdef WITH_DEBUG_OPTIONS\n\t\tcase 6:\n\t\t\tset_debug_options(optarg && optarg[0] ? optarg : NULL);\n\t\t\tbreak;\n#endif\n\t\tcase '?':\n\t\t\tif (optopt && argv[curind][1] != '-')\n\t\t\t\tfprintf(stderr, \"Unknown option -%c\\n\", optopt);\n\t\t\telse\n\t\t\t\tfprintf(stderr, \"Unknown option %s\\n\", argv[curind]);\n\t\t\tbad_option = true;\n\t\t\tbreak;\n\t\tcase ':':\n\t\t\tif (optopt && argv[curind][1] != '-')\n\t\t\t\tfprintf(stderr, \"Missing parameter for option -%c\\n\", optopt);\n\t\t\telse\n\t\t\t\tfprintf(stderr, \"Missing parameter for option --%s\\n\", long_options[longindex].name);\n\t\t\tbad_option = true;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\texit(1);\n\t\t\tbreak;\n\t\t}\n\t\tcurind = optind;\n\t}\n\n\tif (optind < argc) {\n\t\tprintf(\"Unexpected argument(s): \");\n\t\twhile (optind < argc)\n\t\t\tprintf(\"%s \", argv[optind++]);\n\t\tprintf(\"\\n\");\n\t}\n\n\tif (bad_option)\n\t\texit(1);\n\n\treturn reopen_log;\n}\n\n#ifdef THREAD_DUMP\nstatic void\nregister_parent_thread_addresses(void)\n{\n\tregister_scheduler_addresses();\n\tregister_signal_thread_addresses();\n\n#ifdef _WITH_LVS_\n\tregister_check_parent_addresses();\n#endif\n#ifdef _WITH_VRRP_\n\tregister_vrrp_parent_addresses();\n#endif\n#ifdef _WITH_BFD_\n\tregister_bfd_parent_addresses();\n#endif\n\n#ifndef _DEBUG_\n\tregister_signal_handler_address(\"propagate_signal\", propagate_signal);\n\tregister_signal_handler_address(\"sigend\", sigend);\n#endif\n\tregister_signal_handler_address(\"thread_child_handler\", thread_child_handler);\n}\n#endif\n\n/* Entry point */\nint\nkeepalived_main(int argc, char **argv)\n{\n\tbool report_stopped = true;\n\tstruct utsname uname_buf;\n\tchar *end;\n\n\t/* Ensure time_now is set. We then don't have to check anywhere\n\t * else if it is set. */\n\tset_time_now();\n\n\t/* Save command line options in case need to log them later */\n\tsave_cmd_line_options(argc, argv);\n\n\t/* Init debugging level */\n\tdebug = 0;\n\n\t/* We are the parent process */\n#ifndef _DEBUG_\n\tprog_type = PROG_TYPE_PARENT;\n#endif\n\n\t/* Initialise daemon_mode */\n#ifdef _WITH_VRRP_\n\t__set_bit(DAEMON_VRRP, &daemon_mode);\n#endif\n#ifdef _WITH_LVS_\n\t__set_bit(DAEMON_CHECKERS, &daemon_mode);\n#endif\n#ifdef _WITH_BFD_\n\t__set_bit(DAEMON_BFD, &daemon_mode);\n#endif\n\n\t/* Set default file creation mask */\n\tumask(022);\n\n\t/* Open log with default settings so we can log initially */\n\topenlog(PACKAGE_NAME, LOG_PID, log_facility);\n\n#ifdef _MEM_CHECK_\n\tmem_log_init(PACKAGE_NAME, \"Parent process\");\n#endif\n\n\t/* Some functionality depends on kernel version, so get the version here */\n\tif (uname(&uname_buf))\n\t\tlog_message(LOG_INFO, \"Unable to get uname() information - error %d\", errno);\n\telse {\n\t\tos_major = (unsigned)strtoul(uname_buf.release, &end, 10);\n\t\tif (*end != '.')\n\t\t\tos_major = 0;\n\t\telse {\n\t\t\tos_minor = (unsigned)strtoul(end + 1, &end, 10);\n\t\t\tif (*end != '.')\n\t\t\t\tos_major = 0;\n\t\t\telse {\n\t\t\t\tif (!isdigit(end[1]))\n\t\t\t\t\tos_major = 0;\n\t\t\t\telse\n\t\t\t\t\tos_release = (unsigned)strtoul(end + 1, &end, 10);\n\t\t\t}\n\t\t}\n\t\tif (!os_major)\n\t\t\tlog_message(LOG_INFO, \"Unable to parse kernel version %s\", uname_buf.release);\n\n\t\t/* config_id defaults to hostname */\n\t\tif (!config_id) {\n\t\t\tend = strchrnul(uname_buf.nodename, '.');\n\t\t\tconfig_id = MALLOC((size_t)(end - uname_buf.nodename) + 1);\n\t\t\tstrncpy(config_id, uname_buf.nodename, (size_t)(end - uname_buf.nodename));\n\t\t\tconfig_id[end - uname_buf.nodename] = '\\0';\n\t\t}\n\t}\n\n\t/*\n\t * Parse command line and set debug level.\n\t * bits 0..7 reserved by main.c\n\t */\n\tif (parse_cmdline(argc, argv)) {\n\t\tcloselog();\n\t\tif (!__test_bit(NO_SYSLOG_BIT, &debug))\n\t\t\topenlog(PACKAGE_NAME, LOG_PID | ((__test_bit(LOG_CONSOLE_BIT, &debug)) ? LOG_CONS : 0) , log_facility);\n\t}\n\n\tif (__test_bit(LOG_CONSOLE_BIT, &debug))\n\t\tenable_console_log();\n\n#ifdef GIT_COMMIT\n\tlog_message(LOG_INFO, \"Starting %s, git commit %s\", version_string, GIT_COMMIT);\n#else\n\tlog_message(LOG_INFO, \"Starting %s\", version_string);\n#endif\n\n\t/* Handle any core file requirements */\n\tcore_dump_init();\n\n\tif (os_major) {\n\t\tif (KERNEL_VERSION(os_major, os_minor, os_release) < LINUX_VERSION_CODE) {\n\t\t\t/* keepalived was build for a later kernel version */\n\t\t\tlog_message(LOG_INFO, \"WARNING - keepalived was build for newer Linux %d.%d.%d, running on %s %s %s\",\n\t\t\t\t\t(LINUX_VERSION_CODE >> 16) & 0xff,\n\t\t\t\t\t(LINUX_VERSION_CODE >>  8) & 0xff,\n\t\t\t\t\t(LINUX_VERSION_CODE      ) & 0xff,\n\t\t\t\t\tuname_buf.sysname, uname_buf.release, uname_buf.version);\n\t\t} else {\n\t\t\t/* keepalived was build for a later kernel version */\n\t\t\tlog_message(LOG_INFO, \"Running on %s %s %s (built for Linux %d.%d.%d)\",\n\t\t\t\t\tuname_buf.sysname, uname_buf.release, uname_buf.version,\n\t\t\t\t\t(LINUX_VERSION_CODE >> 16) & 0xff,\n\t\t\t\t\t(LINUX_VERSION_CODE >>  8) & 0xff,\n\t\t\t\t\t(LINUX_VERSION_CODE      ) & 0xff);\n\t\t}\n\t}\n\n#ifndef _DEBUG_\n\tlog_command_line(0);\n#endif\n\n\t/* Check we can read the configuration file(s).\n\t   NOTE: the working directory will be / if we\n\t   forked, but will be the current working directory\n\t   when keepalived was run if we haven't forked.\n\t   This means that if any config file names are not\n\t   absolute file names, the behaviour will be different\n\t   depending on whether we forked or not. */\n\tif (!check_conf_file(conf_file)) {\n\t\tif (__test_bit(CONFIG_TEST_BIT, &debug))\n\t\t\tconfig_test_exit();\n\n\t\tgoto end;\n\t}\n\n\tglobal_data = alloc_global_data();\n\tglobal_data->umask = umask_val;\n\n\tread_config_file();\n\n\tinit_global_data(global_data, NULL);\n\n#if HAVE_DECL_CLONE_NEWNET\n\tif (override_namespace) {\n\t\tif (global_data->network_namespace) {\n\t\t\tlog_message(LOG_INFO, \"Overriding config net_namespace '%s' with command line namespace '%s'\", global_data->network_namespace, override_namespace);\n\t\t\tFREE(global_data->network_namespace);\n\t\t}\n\t\tglobal_data->network_namespace = override_namespace;\n\t\toverride_namespace = NULL;\n\t}\n#endif\n\n\tif (!__test_bit(CONFIG_TEST_BIT, &debug) &&\n\t    (global_data->instance_name\n#if HAVE_DECL_CLONE_NEWNET\n\t     || global_data->network_namespace\n#endif\n\t\t\t\t\t      )) {\n\t\tif ((syslog_ident = make_syslog_ident(PACKAGE_NAME))) {\n\t\t\tlog_message(LOG_INFO, \"Changing syslog ident to %s\", syslog_ident);\n\t\t\tcloselog();\n\t\t\topenlog(syslog_ident, LOG_PID | ((__test_bit(LOG_CONSOLE_BIT, &debug)) ? LOG_CONS : 0), log_facility);\n\t\t}\n\t\telse\n\t\t\tlog_message(LOG_INFO, \"Unable to change syslog ident\");\n\n\t\tuse_pid_dir = true;\n\n\t\topen_log_file(log_file_name,\n\t\t\t\tNULL,\n#if HAVE_DECL_CLONE_NEWNET\n\t\t\t\tglobal_data->network_namespace,\n#else\n\t\t\t\tNULL,\n#endif\n\t\t\t\tglobal_data->instance_name);\n\t}\n\n\t/* Initialise pointer to child finding function */\n\tset_child_finder_name(find_keepalived_child_name);\n\n\tif (!__test_bit(CONFIG_TEST_BIT, &debug)) {\n\t\tif (use_pid_dir) {\n\t\t\t/* Create the directory for pid files */\n\t\t\tcreate_pid_dir();\n\t\t}\n\t}\n\n#if HAVE_DECL_CLONE_NEWNET\n\tif (global_data->network_namespace) {\n\t\tif (global_data->network_namespace && !set_namespaces(global_data->network_namespace)) {\n\t\t\tlog_message(LOG_ERR, \"Unable to set network namespace %s - exiting\", global_data->network_namespace);\n\t\t\tgoto end;\n\t\t}\n\t}\n#endif\n\n\tif (!__test_bit(CONFIG_TEST_BIT, &debug)) {\n\t\tif (global_data->instance_name) {\n\t\t\tif (!main_pidfile && (main_pidfile = make_pidfile_name(KEEPALIVED_PID_DIR KEEPALIVED_PID_FILE, global_data->instance_name, PID_EXTENSION)))\n\t\t\t\tfree_main_pidfile = true;\n#ifdef _WITH_LVS_\n\t\t\tif (!checkers_pidfile && (checkers_pidfile = make_pidfile_name(KEEPALIVED_PID_DIR CHECKERS_PID_FILE, global_data->instance_name, PID_EXTENSION)))\n\t\t\t\tfree_checkers_pidfile = true;\n#endif\n#ifdef _WITH_VRRP_\n\t\t\tif (!vrrp_pidfile && (vrrp_pidfile = make_pidfile_name(KEEPALIVED_PID_DIR VRRP_PID_FILE, global_data->instance_name, PID_EXTENSION)))\n\t\t\t\tfree_vrrp_pidfile = true;\n#endif\n#ifdef _WITH_BFD_\n\t\t\tif (!bfd_pidfile && (bfd_pidfile = make_pidfile_name(KEEPALIVED_PID_DIR VRRP_PID_FILE, global_data->instance_name, PID_EXTENSION)))\n\t\t\t\tfree_bfd_pidfile = true;\n#endif\n\t\t}\n\n\t\tif (use_pid_dir) {\n\t\t\tif (!main_pidfile)\n\t\t\t\tmain_pidfile = KEEPALIVED_PID_DIR KEEPALIVED_PID_FILE PID_EXTENSION;\n#ifdef _WITH_LVS_\n\t\t\tif (!checkers_pidfile)\n\t\t\t\tcheckers_pidfile = KEEPALIVED_PID_DIR CHECKERS_PID_FILE PID_EXTENSION;\n#endif\n#ifdef _WITH_VRRP_\n\t\t\tif (!vrrp_pidfile)\n\t\t\t\tvrrp_pidfile = KEEPALIVED_PID_DIR VRRP_PID_FILE PID_EXTENSION;\n#endif\n#ifdef _WITH_BFD_\n\t\t\tif (!bfd_pidfile)\n\t\t\t\tbfd_pidfile = KEEPALIVED_PID_DIR BFD_PID_FILE PID_EXTENSION;\n#endif\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (!main_pidfile)\n\t\t\t\tmain_pidfile = PID_DIR KEEPALIVED_PID_FILE PID_EXTENSION;\n#ifdef _WITH_LVS_\n\t\t\tif (!checkers_pidfile)\n\t\t\t\tcheckers_pidfile = PID_DIR CHECKERS_PID_FILE PID_EXTENSION;\n#endif\n#ifdef _WITH_VRRP_\n\t\t\tif (!vrrp_pidfile)\n\t\t\t\tvrrp_pidfile = PID_DIR VRRP_PID_FILE PID_EXTENSION;\n#endif\n#ifdef _WITH_BFD_\n\t\t\tif (!bfd_pidfile)\n\t\t\t\tbfd_pidfile = PID_DIR BFD_PID_FILE PID_EXTENSION;\n#endif\n\t\t}\n\n\t\t/* Check if keepalived is already running */\n\t\tif (keepalived_running(daemon_mode)) {\n\t\t\tlog_message(LOG_INFO, \"daemon is already running\");\n\t\t\treport_stopped = false;\n\t\t\tgoto end;\n\t\t}\n\t}\n\n\t/* daemonize process */\n\tif (!__test_bit(DONT_FORK_BIT, &debug) &&\n\t    xdaemon(false, false, true) > 0) {\n\t\tcloselog();\n\t\tFREE_PTR(config_id);\n\t\tFREE_PTR(orig_core_dump_pattern);\n\t\tclose_std_fd();\n\t\texit(0);\n\t}\n\n#ifdef _MEM_CHECK_\n\tenable_mem_log_termination();\n#endif\n\n\tif (__test_bit(CONFIG_TEST_BIT, &debug)) {\n\t\tvalidate_config();\n\n\t\tconfig_test_exit();\n\t}\n\n\t/* write the father's pidfile */\n\tif (!pidfile_write(main_pidfile, getpid()))\n\t\tgoto end;\n\n\t/* Create the master thread */\n\tmaster = thread_make_master();\n\n\t/* Signal handling initialization  */\n\tsignal_init();\n\n\t/* Init daemon */\n\tif (!start_keepalived())\n\t\tlog_message(LOG_INFO, \"Warning - keepalived has no configuration to run\");\n\n\tinitialise_debug_options();\n\n#ifdef THREAD_DUMP\n\tregister_parent_thread_addresses();\n#endif\n\n\t/* Launch the scheduling I/O multiplexer */\n\tlaunch_thread_scheduler(master);\n\n\t/* Finish daemon process */\n\tstop_keepalived();\n\n#ifdef THREAD_DUMP\n\tderegister_thread_addresses();\n#endif\n\n\t/*\n\t * Reached when terminate signal catched.\n\t * finally return from system\n\t */\nend:\n\tif (report_stopped) {\n#ifdef GIT_COMMIT\n\t\tlog_message(LOG_INFO, \"Stopped %s, git commit %s\", version_string, GIT_COMMIT);\n#else\n\t\tlog_message(LOG_INFO, \"Stopped %s\", version_string);\n#endif\n\t}\n\n#if HAVE_DECL_CLONE_NEWNET\n\tif (global_data && global_data->network_namespace)\n\t\tclear_namespaces();\n#endif\n\n\tif (use_pid_dir)\n\t\tremove_pid_dir();\n\n\t/* Restore original core_pattern if necessary */\n\tif (orig_core_dump_pattern)\n\t\tupdate_core_dump_pattern(orig_core_dump_pattern);\n\n\tfree_parent_mallocs_startup(false);\n\tfree_parent_mallocs_exit();\n\tfree_global_data(global_data);\n\n\tcloselog();\n\n#ifndef _MEM_CHECK_LOG_\n\tFREE_PTR(syslog_ident);\n#else\n\tif (syslog_ident)\n\t\tfree(syslog_ident);\n#endif\n\tclose_std_fd();\n\n\texit(KEEPALIVED_EXIT_OK);\n}\n", "/*\n * Soft:        Keepalived is a failover program for the LVS project\n *              <www.linuxvirtualserver.org>. It monitor & manipulate\n *              a loadbalanced server pool using multi-layer checks.\n *\n * Part:        pidfile utility.\n *\n * Author:      Alexandre Cassen, <acassen@linux-vs.org>\n *\n *              This program is distributed in the hope that it will be useful,\n *              but WITHOUT ANY WARRANTY; without even the implied warranty of\n *              MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n *              See the GNU General Public License for more details.\n *\n *              This program is free software; you can redistribute it and/or\n *              modify it under the terms of the GNU General Public License\n *              as published by the Free Software Foundation; either version\n *              2 of the License, or (at your option) any later version.\n *\n * Copyright (C) 2001-2017 Alexandre Cassen, <acassen@gmail.com>\n */\n\n#include \"config.h\"\n\n#include <errno.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <stdio.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys/stat.h>\n\n#include \"logger.h\"\n#include \"pidfile.h\"\n#include \"main.h\"\n#include \"bitops.h\"\n#include \"utils.h\"\n\nconst char *pid_directory = PID_DIR PACKAGE;\n\n/* Create the directory for non-standard pid files */\nvoid\ncreate_pid_dir(void)\n{\n\tif (mkdir(pid_directory, S_IRWXU | S_IRGRP | S_IXGRP | S_IROTH | S_IXOTH) && errno != EEXIST) {\n\t\tlog_message(LOG_INFO, \"Unable to create directory %s\", pid_directory);\n\t\treturn;\n\t}\n}\n\nvoid\nremove_pid_dir(void)\n{\n\tif (rmdir(pid_directory) && errno != ENOTEMPTY && errno != EBUSY)\n\t\tlog_message(LOG_INFO, \"unlink of %s failed - error (%d) '%s'\", pid_directory, errno, strerror(errno));\n}\n\n/* Create the running daemon pidfile */\nint\npidfile_write(const char *pid_file, int pid)\n{\n\tFILE *pidfile = NULL;\n\tint pidfd = open(pid_file, O_NOFOLLOW | O_CREAT | O_WRONLY | O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n\n\tif (pidfd != -1) pidfile = fdopen(pidfd, \"w\");\n\n\tif (!pidfile) {\n\t\tlog_message(LOG_INFO, \"pidfile_write : Cannot open %s pidfile\",\n\t\t       pid_file);\n\t\treturn 0;\n\t}\n\tfprintf(pidfile, \"%d\\n\", pid);\n\tfclose(pidfile);\n\treturn 1;\n}\n\n/* Remove the running daemon pidfile */\nvoid\npidfile_rm(const char *pid_file)\n{\n\tunlink(pid_file);\n}\n\n/* return the daemon running state */\nstatic int\nprocess_running(const char *pid_file)\n{\n\tFILE *pidfile = fopen(pid_file, \"r\");\n\tpid_t pid = 0;\n\tint ret;\n\n\t/* No pidfile */\n\tif (!pidfile)\n\t\treturn 0;\n\n\tret = fscanf(pidfile, \"%d\", &pid);\n\tfclose(pidfile);\n\tif (ret != 1) {\n\t\tlog_message(LOG_INFO, \"Error reading pid file %s\", pid_file);\n\t\tpid = 0;\n\t\tpidfile_rm(pid_file);\n\t}\n\n\t/* What should we return - we don't know if it is running or not. */\n\tif (!pid)\n\t\treturn 1;\n\n\t/* If no process is attached to pidfile, remove it */\n\tif (kill(pid, 0)) {\n\t\tlog_message(LOG_INFO, \"Remove a zombie pid file %s\", pid_file);\n\t\tpidfile_rm(pid_file);\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\n/* Return parent process daemon state */\nbool\nkeepalived_running(unsigned long mode)\n{\n\tif (process_running(main_pidfile))\n\t\treturn true;\n#ifdef _WITH_VRRP_\n\tif (__test_bit(DAEMON_VRRP, &mode) && process_running(vrrp_pidfile))\n\t\treturn true;\n#endif\n#ifdef _WITH_LVS_\n\tif (__test_bit(DAEMON_CHECKERS, &mode) && process_running(checkers_pidfile))\n\t\treturn true;\n#endif\n#ifdef _WITH_BFD_\n\tif (__test_bit(DAEMON_BFD, &mode) && process_running(bfd_pidfile))\n\t\treturn true;\n#endif\n\treturn false;\n}\n", "/*\n * Soft:        Keepalived is a failover program for the LVS project\n *              <www.linuxvirtualserver.org>. It monitor & manipulate\n *              a loadbalanced server pool using multi-layer checks.\n *\n * Part:        SMTP WRAPPER connect to a specified smtp server and send mail\n *              using the smtp protocol according to the RFC 821. A non blocking\n *              timeouted connection is used to handle smtp protocol.\n *\n * Author:      Alexandre Cassen, <acassen@linux-vs.org>\n *\n *              This program is distributed in the hope that it will be useful,\n *              but WITHOUT ANY WARRANTY; without even the implied warranty of\n *              MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n *              See the GNU General Public License for more details.\n *\n *              This program is free software; you can redistribute it and/or\n *              modify it under the terms of the GNU General Public License\n *              as published by the Free Software Foundation; either version\n *              2 of the License, or (at your option) any later version.\n *\n * Copyright (C) 2001-2017 Alexandre Cassen, <acassen@gmail.com>\n */\n\n#include \"config.h\"\n\n#include <errno.h>\n#include <unistd.h>\n#include <time.h>\n\n#include \"smtp.h\"\n#include \"memory.h\"\n#include \"layer4.h\"\n#include \"logger.h\"\n#include \"utils.h\"\n#if !HAVE_DECL_SOCK_CLOEXEC\n#include \"old_socket.h\"\n#endif\n#ifdef _WITH_LVS_\n#include \"check_api.h\"\n#endif\n#ifdef THREAD_DUMP\n#include \"scheduler.h\"\n#endif\n#ifdef _SMTP_ALERT_DEBUG_\nbool do_smtp_alert_debug;\n#endif\n\n/* SMTP FSM definition */\nstatic int connection_error(thread_t *);\nstatic int connection_in_progress(thread_t *);\nstatic int connection_timeout(thread_t *);\nstatic int connection_success(thread_t *);\nstatic int helo_cmd(thread_t *);\nstatic int mail_cmd(thread_t *);\nstatic int rcpt_cmd(thread_t *);\nstatic int data_cmd(thread_t *);\nstatic int body_cmd(thread_t *);\nstatic int quit_cmd(thread_t *);\n\nstatic int connection_code(thread_t *, int);\nstatic int helo_code(thread_t *, int);\nstatic int mail_code(thread_t *, int);\nstatic int rcpt_code(thread_t *, int);\nstatic int data_code(thread_t *, int);\nstatic int body_code(thread_t *, int);\nstatic int quit_code(thread_t *, int);\n\nstatic int smtp_read_thread(thread_t *);\nstatic int smtp_send_thread(thread_t *);\n\nstruct {\n\tint (*send) (thread_t *);\n\tint (*read) (thread_t *, int);\n} SMTP_FSM[SMTP_MAX_FSM_STATE] = {\n/*      Stream Write Handlers    |   Stream Read handlers   *\n *-------------------------------+--------------------------*/\n\t{connection_error,\t\tNULL},\t\t\t/* connect_error */\n\t{connection_in_progress,\tNULL},\t\t\t/* connect_in_progress */\n\t{connection_timeout,\t\tNULL},\t\t\t/* connect_timeout */\n\t{connection_success,\t\tconnection_code},\t/* connect_success */\n\t{helo_cmd,\t\t\thelo_code},\t\t/* HELO */\n\t{mail_cmd,\t\t\tmail_code},\t\t/* MAIL */\n\t{rcpt_cmd,\t\t\trcpt_code},\t\t/* RCPT */\n\t{data_cmd,\t\t\tdata_code},\t\t/* DATA */\n\t{body_cmd,\t\t\tbody_code},\t\t/* BODY */\n\t{quit_cmd,\t\t\tquit_code}\t\t/* QUIT */\n};\n\nstatic void\nfree_smtp_all(smtp_t * smtp)\n{\n\tFREE(smtp->buffer);\n\tFREE(smtp->subject);\n\tFREE(smtp->body);\n\tFREE(smtp->email_to);\n\tFREE(smtp);\n}\n\nstatic char *\nfetch_next_email(smtp_t * smtp)\n{\n\treturn list_element(global_data->email, smtp->email_it);\n}\n\n/* layer4 connection handlers */\nstatic int\nconnection_error(thread_t * thread)\n{\n\tsmtp_t *smtp = THREAD_ARG(thread);\n\n\tlog_message(LOG_INFO, \"SMTP connection ERROR to %s.\"\n\t\t\t    , FMT_SMTP_HOST());\n\tfree_smtp_all(smtp);\n\treturn 0;\n}\nstatic int\nconnection_timeout(thread_t * thread)\n{\n\tsmtp_t *smtp = THREAD_ARG(thread);\n\n\tlog_message(LOG_INFO, \"Timeout connecting SMTP server %s.\"\n\t\t\t    , FMT_SMTP_HOST());\n\tfree_smtp_all(smtp);\n\treturn 0;\n}\nstatic int\nconnection_in_progress(thread_t * thread)\n{\n\tint status;\n\n\tDBG(\"SMTP connection to %s now IN_PROGRESS.\",\n\t    FMT_SMTP_HOST());\n\n\t/*\n\t * Here we use the propriety of a union structure,\n\t * each element of the structure have the same value.\n\t */\n\tstatus = tcp_socket_state(thread, connection_in_progress);\n\n\tif (status != connect_in_progress)\n\t\tSMTP_FSM_SEND(status, thread);\n\n\treturn 0;\n}\nstatic int\nconnection_success(thread_t * thread)\n{\n\tsmtp_t *smtp = THREAD_ARG(thread);\n\n\tlog_message(LOG_INFO, \"Remote SMTP server %s connected.\"\n\t\t\t    , FMT_SMTP_HOST());\n\n\tsmtp->stage = connect_success;\n\tthread_add_read(thread->master, smtp_read_thread, smtp,\n\t\t\tsmtp->fd, global_data->smtp_connection_to);\n\treturn 0;\n}\n\n/* SMTP protocol handlers */\nstatic int\nsmtp_read_thread(thread_t * thread)\n{\n\tsmtp_t *smtp;\n\tchar *buffer;\n\tchar *reply;\n\tssize_t rcv_buffer_size;\n\tint status = -1;\n\n\tsmtp = THREAD_ARG(thread);\n\n\tif (thread->type == THREAD_READ_TIMEOUT) {\n\t\tlog_message(LOG_INFO, \"Timeout reading data to remote SMTP server %s.\"\n\t\t\t\t    , FMT_SMTP_HOST());\n\t\tSMTP_FSM_READ(QUIT, thread, 0);\n\t\treturn -1;\n\t}\n\n\tbuffer = smtp->buffer;\n\n\trcv_buffer_size = read(thread->u.fd, buffer + smtp->buflen,\n\t\t\t       SMTP_BUFFER_LENGTH - smtp->buflen);\n\n\tif (rcv_buffer_size == -1) {\n\t\tif (errno == EAGAIN)\n\t\t\tgoto end;\n\t\tlog_message(LOG_INFO, \"Error reading data from remote SMTP server %s.\"\n\t\t\t\t    , FMT_SMTP_HOST());\n\t\tSMTP_FSM_READ(QUIT, thread, 0);\n\t\treturn 0;\n\t} else if (rcv_buffer_size == 0) {\n\t\tlog_message(LOG_INFO, \"Remote SMTP server %s has closed the connection.\"\n\t\t\t\t    , FMT_SMTP_HOST());\n\t\tSMTP_FSM_READ(QUIT, thread, 0);\n\t\treturn 0;\n\t}\n\n\t/* received data overflow buffer size ? */\n\tif (smtp->buflen >= SMTP_BUFFER_MAX) {\n\t\tlog_message(LOG_INFO, \"Received buffer from remote SMTP server %s\"\n\t\t\t\t      \" overflow our get read buffer length.\"\n\t\t\t\t    , FMT_SMTP_HOST());\n\t\tSMTP_FSM_READ(QUIT, thread, 0);\n\t\treturn 0;\n\t} else {\n\t\tsmtp->buflen += (size_t)rcv_buffer_size;\n\t\tbuffer[smtp->buflen] = 0;\t/* NULL terminate */\n\t}\n\n      end:\n\n\t/* parse the buffer, finding the last line of the response for the code */\n\treply = buffer;\n\twhile (reply < buffer + smtp->buflen) {\n\t\tchar *p;\n\n\t\tp = strstr(reply, \"\\r\\n\");\n\t\tif (!p) {\n\t\t\tmemmove(buffer, reply,\n\t\t\t\tsmtp->buflen - (size_t)(reply - buffer));\n\t\t\tsmtp->buflen -= (size_t)(reply - buffer);\n\t\t\tbuffer[smtp->buflen] = 0;\n\n\t\t\tthread_add_read(thread->master, smtp_read_thread,\n\t\t\t\t\tsmtp, thread->u.fd,\n\t\t\t\t\tglobal_data->smtp_connection_to);\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (reply[3] == '-') {\n\t\t\t/* Skip over the \\r\\n */\n\t\t\treply = p + 2;\n\t\t\tcontinue;\n\t\t}\n\n\t\tstatus = ((reply[0] - '0') * 100) + ((reply[1] - '0') * 10) + (reply[2] - '0');\n\n\t\treply = p + 2;\n\t\tbreak;\n\t}\n\n\tmemmove(buffer, reply, smtp->buflen - (size_t)(reply - buffer));\n\tsmtp->buflen -= (size_t)(reply - buffer);\n\tbuffer[smtp->buflen] = 0;\n\n\tif (status == -1) {\n\t\tthread_add_read(thread->master, smtp_read_thread, smtp,\n\t\t\t\tthread->u.fd, global_data->smtp_connection_to);\n\t\treturn 0;\n\t}\n\n\tSMTP_FSM_READ(smtp->stage, thread, status);\n\n\t/* Registering next smtp command processing thread */\n\tif (smtp->stage != ERROR) {\n\t\tthread_add_write(thread->master, smtp_send_thread, smtp,\n\t\t\t\t smtp->fd, global_data->smtp_connection_to);\n\t} else {\n\t\tlog_message(LOG_INFO, \"Can not read data from remote SMTP server %s.\"\n\t\t\t\t    , FMT_SMTP_HOST());\n\t\tSMTP_FSM_READ(QUIT, thread, 0);\n\t}\n\n\treturn 0;\n}\n\nstatic int\nsmtp_send_thread(thread_t * thread)\n{\n\tsmtp_t *smtp = THREAD_ARG(thread);\n\n\tif (thread->type == THREAD_WRITE_TIMEOUT) {\n\t\tlog_message(LOG_INFO, \"Timeout sending data to remote SMTP server %s.\"\n\t\t\t\t    , FMT_SMTP_HOST());\n\t\tSMTP_FSM_READ(QUIT, thread, 0);\n\t\treturn 0;\n\t}\n\n\tSMTP_FSM_SEND(smtp->stage, thread);\n\n\t/* Handle END command */\n\tif (smtp->stage == END) {\n\t\tSMTP_FSM_READ(QUIT, thread, 0);\n\t\treturn 0;\n\t}\n\n\t/* Registering next smtp command processing thread */\n\tif (smtp->stage != ERROR) {\n\t\tthread_add_read(thread->master, smtp_read_thread, smtp,\n\t\t\t\tthread->u.fd, global_data->smtp_connection_to);\n\t\tthread_del_write(thread);\n\t} else {\n\t\tlog_message(LOG_INFO, \"Can not send data to remote SMTP server %s.\"\n\t\t\t\t    , FMT_SMTP_HOST());\n\t\tSMTP_FSM_READ(QUIT, thread, 0);\n\t}\n\n\treturn 0;\n}\n\nstatic int\nconnection_code(thread_t * thread, int status)\n{\n\tsmtp_t *smtp = THREAD_ARG(thread);\n\n\tif (status == 220) {\n\t\tsmtp->stage++;\n\t} else {\n\t\tlog_message(LOG_INFO, \"Error connecting SMTP server %s.\"\n\t\t\t\t      \" SMTP status code = %d\"\n\t\t\t\t    , FMT_SMTP_HOST()\n\t\t\t\t    , status);\n\t\tsmtp->stage = ERROR;\n\t}\n\n\treturn 0;\n}\n\n/* HELO command processing */\nstatic int\nhelo_cmd(thread_t * thread)\n{\n\tsmtp_t *smtp = THREAD_ARG(thread);\n\tchar *buffer;\n\n\tbuffer = (char *) MALLOC(SMTP_BUFFER_MAX);\n\tsnprintf(buffer, SMTP_BUFFER_MAX, SMTP_HELO_CMD, (global_data->smtp_helo_name) ? global_data->smtp_helo_name : \"localhost\");\n\tif (send(thread->u.fd, buffer, strlen(buffer), 0) == -1)\n\t\tsmtp->stage = ERROR;\n\tFREE(buffer);\n\n\treturn 0;\n}\nstatic int\nhelo_code(thread_t * thread, int status)\n{\n\tsmtp_t *smtp = THREAD_ARG(thread);\n\n\tif (status == 250) {\n\t\tsmtp->stage++;\n\t} else {\n\t\tlog_message(LOG_INFO, \"Error processing HELO cmd on SMTP server %s.\"\n\t\t\t\t      \" SMTP status code = %d\"\n\t\t\t\t    , FMT_SMTP_HOST()\n\t\t\t\t    , status);\n\t\tsmtp->stage = ERROR;\n\t}\n\n\treturn 0;\n}\n\n/* MAIL command processing */\nstatic int\nmail_cmd(thread_t * thread)\n{\n\tsmtp_t *smtp = THREAD_ARG(thread);\n\tchar *buffer;\n\n\tbuffer = (char *) MALLOC(SMTP_BUFFER_MAX);\n\tsnprintf(buffer, SMTP_BUFFER_MAX, SMTP_MAIL_CMD, global_data->email_from);\n\tif (send(thread->u.fd, buffer, strlen(buffer), 0) == -1)\n\t\tsmtp->stage = ERROR;\n\tFREE(buffer);\n\n\treturn 0;\n}\nstatic int\nmail_code(thread_t * thread, int status)\n{\n\tsmtp_t *smtp = THREAD_ARG(thread);\n\n\tif (status == 250) {\n\t\tsmtp->stage++;\n\t} else {\n\t\tlog_message(LOG_INFO, \"Error processing MAIL cmd on SMTP server %s.\"\n\t\t\t\t      \" SMTP status code = %d\"\n\t\t\t\t    , FMT_SMTP_HOST()\n\t\t\t\t    , status);\n\t\tsmtp->stage = ERROR;\n\t}\n\n\treturn 0;\n}\n\n/* RCPT command processing */\nstatic int\nrcpt_cmd(thread_t * thread)\n{\n\tsmtp_t *smtp = THREAD_ARG(thread);\n\tchar *buffer;\n\tchar *fetched_email;\n\n\tbuffer = (char *) MALLOC(SMTP_BUFFER_MAX);\n\t/* We send RCPT TO command multiple time to add all our email receivers.\n\t * --rfc821.3.1\n\t */\n\tfetched_email = fetch_next_email(smtp);\n\n\tsnprintf(buffer, SMTP_BUFFER_MAX, SMTP_RCPT_CMD, fetched_email);\n\tif (send(thread->u.fd, buffer, strlen(buffer), 0) == -1)\n\t\tsmtp->stage = ERROR;\n\tFREE(buffer);\n\n\treturn 0;\n}\nstatic int\nrcpt_code(thread_t * thread, int status)\n{\n\tsmtp_t *smtp = THREAD_ARG(thread);\n\tchar *fetched_email;\n\n\tif (status == 250) {\n\t\tsmtp->email_it++;\n\n\t\tfetched_email = fetch_next_email(smtp);\n\n\t\tif (!fetched_email)\n\t\t\tsmtp->stage++;\n\t} else {\n\t\tlog_message(LOG_INFO, \"Error processing RCPT cmd on SMTP server %s.\"\n\t\t\t\t      \" SMTP status code = %d\"\n\t\t\t\t    , FMT_SMTP_HOST()\n\t\t\t\t    , status);\n\t\tsmtp->stage = ERROR;\n\t}\n\n\treturn 0;\n}\n\n/* DATA command processing */\nstatic int\ndata_cmd(thread_t * thread)\n{\n\tsmtp_t *smtp = THREAD_ARG(thread);\n\n\tif (send(thread->u.fd, SMTP_DATA_CMD, strlen(SMTP_DATA_CMD), 0) == -1)\n\t\tsmtp->stage = ERROR;\n\treturn 0;\n}\nstatic int\ndata_code(thread_t * thread, int status)\n{\n\tsmtp_t *smtp = THREAD_ARG(thread);\n\n\tif (status == 354) {\n\t\tsmtp->stage++;\n\t} else {\n\t\tlog_message(LOG_INFO, \"Error processing DATA cmd on SMTP server %s.\"\n\t\t\t\t      \" SMTP status code = %d\"\n\t\t\t\t    , FMT_SMTP_HOST()\n\t\t\t\t    , status);\n\t\tsmtp->stage = ERROR;\n\t}\n\n\treturn 0;\n}\n\n/* BODY command processing.\n * Do we need to use mutli-thread for multi-part body\n * handling ? Don t really think :)\n */\nstatic int\nbody_cmd(thread_t * thread)\n{\n\tsmtp_t *smtp = THREAD_ARG(thread);\n\tchar *buffer;\n\tchar rfc822[80];\n\ttime_t now;\n\tstruct tm *t;\n\n\tbuffer = (char *) MALLOC(SMTP_BUFFER_MAX);\n\n\ttime(&now);\n\tt = localtime(&now);\n\tstrftime(rfc822, sizeof(rfc822), \"%a, %d %b %Y %H:%M:%S %z\", t);\n\n\tsnprintf(buffer, SMTP_BUFFER_MAX, SMTP_HEADERS_CMD,\n\t\t rfc822, global_data->email_from, smtp->subject, smtp->email_to);\n\n\t/* send the subject field */\n\tif (send(thread->u.fd, buffer, strlen(buffer), 0) == -1)\n\t\tsmtp->stage = ERROR;\n\n\tmemset(buffer, 0, SMTP_BUFFER_MAX);\n\tsnprintf(buffer, SMTP_BUFFER_MAX, SMTP_BODY_CMD, smtp->body);\n\n\t/* send the the body field */\n\tif (send(thread->u.fd, buffer, strlen(buffer), 0) == -1)\n\t\tsmtp->stage = ERROR;\n\n\t/* send the sending dot */\n\tif (send(thread->u.fd, SMTP_SEND_CMD, strlen(SMTP_SEND_CMD), 0) == -1)\n\t\tsmtp->stage = ERROR;\n\n\tFREE(buffer);\n\treturn 0;\n}\nstatic int\nbody_code(thread_t * thread, int status)\n{\n\tsmtp_t *smtp = THREAD_ARG(thread);\n\n\tif (status == 250) {\n\t\tlog_message(LOG_INFO, \"SMTP alert successfully sent.\");\n\t\tsmtp->stage++;\n\t} else {\n\t\tlog_message(LOG_INFO, \"Error processing DOT cmd on SMTP server %s.\"\n\t\t\t\t      \" SMTP status code = %d\"\n\t\t\t\t    , FMT_SMTP_HOST()\n\t\t\t\t    , status);\n\t\tsmtp->stage = ERROR;\n\t}\n\n\treturn 0;\n}\n\n/* QUIT command processing */\nstatic int\nquit_cmd(thread_t * thread)\n{\n\tsmtp_t *smtp = THREAD_ARG(thread);\n\n\tif (send(thread->u.fd, SMTP_QUIT_CMD, strlen(SMTP_QUIT_CMD), 0) == -1)\n\t\tsmtp->stage = ERROR;\n\telse\n\t\tsmtp->stage++;\n\treturn 0;\n}\n\nstatic int\nquit_code(thread_t * thread, __attribute__((unused)) int status)\n{\n\tsmtp_t *smtp = THREAD_ARG(thread);\n\n\t/* final state, we are disconnected from the remote host */\n\tfree_smtp_all(smtp);\n\tthread_close_fd(thread);\n\treturn 0;\n}\n\n/* connect remote SMTP server */\nstatic void\nsmtp_connect(smtp_t * smtp)\n{\n\tenum connect_result status;\n\n\tif ((smtp->fd = socket(global_data->smtp_server.ss_family, SOCK_STREAM | SOCK_CLOEXEC | SOCK_NONBLOCK, IPPROTO_TCP)) == -1) {\n\t\tDBG(\"SMTP connect fail to create socket.\");\n\t\tfree_smtp_all(smtp);\n\t\treturn;\n\t}\n\n#if !HAVE_DECL_SOCK_NONBLOCK\n\tif (set_sock_flags(smtp->fd, F_SETFL, O_NONBLOCK))\n\t\tlog_message(LOG_INFO, \"Unable to set NONBLOCK on smtp_connect socket - %s (%d)\", strerror(errno), errno);\n#endif\n\n#if !HAVE_DECL_SOCK_CLOEXEC\n\tif (set_sock_flags(smtp->fd, F_SETFD, FD_CLOEXEC))\n\t\tlog_message(LOG_INFO, \"Unable to set CLOEXEC on smtp_connect socket - %s (%d)\", strerror(errno), errno);\n#endif\n\n\tstatus = tcp_connect(smtp->fd, &global_data->smtp_server);\n\n\t/* Handle connection status code */\n\tthread_add_event(master, SMTP_FSM[status].send, smtp, smtp->fd);\n}\n\n#ifdef _SMTP_ALERT_DEBUG_\nstatic void\nsmtp_log_to_file(smtp_t *smtp)\n{\n\tFILE *fp = fopen_safe(\"/tmp/smtp-alert.log\", \"a\");\n\ttime_t now;\n\tstruct tm tm;\n\tchar time_buf[25];\n\tint time_buf_len;\n\n\ttime(&now);\n\tlocaltime_r(&now, &tm);\n\ttime_buf_len = strftime(time_buf, sizeof time_buf, \"%a %b %e %X %Y\", &tm);\n\n\tfprintf(fp, \"%s: %s -> %s\\n\"\n\t\t    \"%*sSubject: %s\\n\"\n\t\t    \"%*sBody:    %s\\n\\n\",\n\t\t    time_buf, global_data->email_from, smtp->email_to,\n\t\t    time_buf_len - 7, \"\", smtp->subject,\n\t\t    time_buf_len - 7, \"\", smtp->body);\n\n\tfclose(fp);\n\n\tfree_smtp_all(smtp);\n}\n#endif\n\n/*\n * Build a comma separated string of smtp recipient email addresses\n * for the email message To-header.\n */\nstatic void\nbuild_to_header_rcpt_addrs(smtp_t *smtp)\n{\n\tchar *fetched_email;\n\tchar *email_to_addrs;\n\tsize_t bytes_available = SMTP_BUFFER_MAX - 1;\n\tsize_t bytes_to_write;\n\n\tif (smtp == NULL)\n\t\treturn;\n\n\temail_to_addrs = smtp->email_to;\n\tsmtp->email_it = 0;\n\n\twhile (1) {\n\t\tfetched_email = fetch_next_email(smtp);\n\t\tif (fetched_email == NULL)\n\t\t\tbreak;\n\n\t\tbytes_to_write = strlen(fetched_email);\n\t\tif (!smtp->email_it) {\n\t\t\tif (bytes_available < bytes_to_write)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tif (bytes_available < 2 + bytes_to_write)\n\t\t\t\tbreak;\n\n\t\t\t/* Prepend with a comma and space to all non-first email addresses */\n\t\t\t*email_to_addrs++ = ',';\n\t\t\t*email_to_addrs++ = ' ';\n\t\t\tbytes_available -= 2;\n\t\t}\n\n\t\tif (snprintf(email_to_addrs, bytes_to_write + 1, \"%s\", fetched_email) != (int)bytes_to_write) {\n\t\t\t/* Inconsistent state, no choice but to break here and do nothing */\n\t\t\tbreak;\n\t\t}\n\n\t\temail_to_addrs += bytes_to_write;\n\t\tbytes_available -= bytes_to_write;\n\t\tsmtp->email_it++;\n\t}\n\n\tsmtp->email_it = 0;\n}\n\n/* Main entry point */\nvoid\nsmtp_alert(smtp_msg_t msg_type, void* data, const char *subject, const char *body)\n{\n\tsmtp_t *smtp;\n#ifdef _WITH_VRRP_\n\tvrrp_t *vrrp;\n\tvrrp_sgroup_t *vgroup;\n#endif\n#ifdef _WITH_LVS_\n\tchecker_t *checker;\n\tvirtual_server_t *vs;\n\tsmtp_rs *rs_info;\n#endif\n\n\t/* Only send mail if email specified */\n\tif (LIST_ISEMPTY(global_data->email) || !global_data->smtp_server.ss_family)\n\t\treturn;\n\n\t/* allocate & initialize smtp argument data structure */\n\tsmtp = (smtp_t *) MALLOC(sizeof(smtp_t));\n\tsmtp->subject = (char *) MALLOC(MAX_HEADERS_LENGTH);\n\tsmtp->body = (char *) MALLOC(MAX_BODY_LENGTH);\n\tsmtp->buffer = (char *) MALLOC(SMTP_BUFFER_MAX);\n\tsmtp->email_to = (char *) MALLOC(SMTP_BUFFER_MAX);\n\n\t/* format subject if rserver is specified */\n#ifdef _WITH_LVS_\n\tif (msg_type == SMTP_MSG_RS) {\n\t\tchecker = (checker_t *)data;\n\t\tsnprintf(smtp->subject, MAX_HEADERS_LENGTH, \"[%s] Realserver %s of virtual server %s - %s\",\n\t\t\t\t\tglobal_data->router_id,\n\t\t\t\t\tFMT_RS(checker->rs, checker->vs),\n\t\t\t\t\tFMT_VS(checker->vs),\n\t\t\t\t\tchecker->rs->alive ? \"UP\" : \"DOWN\");\n\t}\n\telse if (msg_type == SMTP_MSG_VS) {\n\t\tvs = (virtual_server_t *)data;\n\t\tsnprintf(smtp->subject, MAX_HEADERS_LENGTH, \"[%s] Virtualserver %s - %s\",\n\t\t\t\t\tglobal_data->router_id,\n\t\t\t\t\tFMT_VS(vs),\n\t\t\t\t\tsubject);\n\t}\n\telse if (msg_type == SMTP_MSG_RS_SHUT) {\n\t\trs_info = (smtp_rs *)data;\n\t\tsnprintf(smtp->subject, MAX_HEADERS_LENGTH, \"[%s] Realserver %s of virtual server %s - %s\",\n\t\t\t\t\tglobal_data->router_id,\n\t\t\t\t\tFMT_RS(rs_info->rs, rs_info->vs),\n\t\t\t\t\tFMT_VS(rs_info->vs),\n\t\t\t\t\tsubject);\n\t}\n\telse\n#endif\n#ifdef _WITH_VRRP_\n\tif (msg_type == SMTP_MSG_VRRP) {\n\t\tvrrp = (vrrp_t *)data;\n\t\tsnprintf(smtp->subject, MAX_HEADERS_LENGTH, \"[%s] VRRP Instance %s - %s\",\n\t\t\t\t\tglobal_data->router_id,\n\t\t\t\t\tvrrp->iname,\n\t\t\t\t\tsubject);\n\t} else if (msg_type == SMTP_MSG_VGROUP) {\n\t\tvgroup = (vrrp_sgroup_t *)data;\n\t\tsnprintf(smtp->subject, MAX_HEADERS_LENGTH, \"[%s] VRRP Group %s - %s\",\n\t\t\t\t\tglobal_data->router_id,\n\t\t\t\t\tvgroup->gname,\n\t\t\t\t\tsubject);\n\t}\n\telse\n#endif\n\tif (global_data->router_id)\n\t\tsnprintf(smtp->subject, MAX_HEADERS_LENGTH, \"[%s] %s\"\n\t\t\t\t      , global_data->router_id\n\t\t\t\t      , subject);\n\telse\n\t\tsnprintf(smtp->subject, MAX_HEADERS_LENGTH, \"%s\", subject);\n\n\tstrncpy(smtp->body, body, MAX_BODY_LENGTH - 1);\n\tsmtp->body[MAX_BODY_LENGTH - 1]= '\\0';\n\n\tbuild_to_header_rcpt_addrs(smtp);\n\n#ifdef _SMTP_ALERT_DEBUG_\n\tif (do_smtp_alert_debug)\n\t\tsmtp_log_to_file(smtp);\n\telse\n#endif\n\tsmtp_connect(smtp);\n}\n\n#ifdef THREAD_DUMP\nvoid\nregister_smtp_addresses(void)\n{\n\tregister_thread_address(\"body_cmd\", body_cmd);\n\tregister_thread_address(\"connection_error\", connection_error);\n\tregister_thread_address(\"connection_in_progress\", connection_in_progress);\n\tregister_thread_address(\"connection_success\", connection_success);\n\tregister_thread_address(\"connection_timeout\", connection_timeout);\n\tregister_thread_address(\"data_cmd\", data_cmd);\n\tregister_thread_address(\"helo_cmd\", helo_cmd);\n\tregister_thread_address(\"mail_cmd\", mail_cmd);\n\tregister_thread_address(\"quit_cmd\", quit_cmd);\n\tregister_thread_address(\"rcpt_cmd\", rcpt_cmd);\n\tregister_thread_address(\"smtp_read_thread\", smtp_read_thread);\n\tregister_thread_address(\"smtp_send_thread\", smtp_send_thread);\n}\n#endif\n", "/*\n * Soft:        Keepalived is a failover program for the LVS project\n *              <www.linuxvirtualserver.org>. It monitor & manipulate\n *              a loadbalanced server pool using multi-layer checks.\n *\n * Part:        DBus server thread for VRRP\n *\n * Author:      Alexandre Cassen, <acassen@linux-vs.org>\n *\n *              This program is distributed in the hope that it will be useful,\n *              but WITHOUT ANY WARRANTY; without even the implied warranty of\n *              MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n *              See the GNU General Public License for more details.\n *\n *              This program is free software; you can redistribute it and/or\n *              modify it under the terms of the GNU General Public License\n *              as published by the Free Software Foundation; either version\n *              2 of the License, or (at your option) any later version.\n *\n * Copyright (C) 2016-2017 Alexandre Cassen, <acassen@gmail.com>\n */\n\n/* See https://git.gnome.org/browse/glib/tree/gio/tests/fdbus-example-server.c\n * and https://developer.gnome.org/gio/stable/GDBusConnection.html#gdbus-server\n * for examples of coding.\n *\n * Create a general /org/keepalived/Vrrp1/Vrrp DBus\n * object and a /org/keepalived/Vrrp1/Instance/#interface#/#group# object for\n * each VRRP instance.\n * Interface org.keepalived.Vrrp1.Vrrp implements methods PrintData,\n * PrintStats and signal VrrpStopped.\n * Interface com.keepalived.Vrrp1.Instance implements method SendGarp\n * (sends a single Gratuitous ARP from the given Instance),\n * signal VrrpStatusChange, and properties Name and State (retrievable\n * through calls to org.freedesktop.DBus.Properties.Get)\n *\n * Interface files need to be installed in /usr/share/dbus-1/interfaces/\n * A policy file, which determines who has access to the service, is\n * installed in /etc/dbus-1/system.d/. Sources for the policy and interface\n * files are in keepalived/dbus.\n *\n * To test the DBus service run a command like: dbus-send --system --dest=org.keepalived.Vrrp1 --print-reply object interface.method type:argument\n * e.g.\n * dbus-send --system --dest=org.keepalived.Vrrp1 --print-reply /org/keepalived/Vrrp1/Vrrp org.keepalived.Vrrp1.Vrrp.PrintData\n * or\n * dbus-send --system --dest=org.keepalived.Vrrp1 --print-reply /org/keepalived/Vrrp1/Instance/eth0/1/IPv4 org.freedesktop.DBus.Properties.Get string:'org.keepalived.Vrrp1.Instance' string:'State'\n *\n * To monitor signals, run:\n * dbus-monitor --system type='signal'\n *\n * d-feet is a useful program for interfacing with DBus\n */\n\n#include \"config.h\"\n\n#include <errno.h>\n#include <pthread.h>\n#include <semaphore.h>\n#include <gio/gio.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <stdlib.h>\n#include <stdint.h>\n\n#include \"vrrp_dbus.h\"\n#include \"vrrp_data.h\"\n#include \"vrrp_print.h\"\n#include \"global_data.h\"\n#include \"main.h\"\n#include \"logger.h\"\n#include \"utils.h\"\n#ifdef THREAD_DUMP\n#include \"scheduler.h\"\n#endif\n\ntypedef enum dbus_action {\n\tDBUS_ACTION_NONE,\n\tDBUS_PRINT_DATA,\n\tDBUS_PRINT_STATS,\n\tDBUS_RELOAD,\n#ifdef _WITH_DBUS_CREATE_INSTANCE_\n\tDBUS_CREATE_INSTANCE,\n\tDBUS_DESTROY_INSTANCE,\n#endif\n\tDBUS_SEND_GARP,\n\tDBUS_GET_NAME,\n\tDBUS_GET_STATUS,\n} dbus_action_t;\n\ntypedef enum dbus_error {\n\tDBUS_SUCCESS,\n\tDBUS_INTERFACE_NOT_FOUND,\n\tDBUS_OBJECT_ALREADY_EXISTS,\n\tDBUS_INTERFACE_TOO_LONG,\n\tDBUS_INSTANCE_NOT_FOUND,\n} dbus_error_t;\n\ntypedef struct dbus_queue_ent {\n\tdbus_action_t action;\n\tdbus_error_t reply;\n\tchar *ifname;\n\tuint8_t vrid;\n\tuint8_t family;\n\tGVariant *args;\n} dbus_queue_ent_t;\n\n/* Global file variables */\nstatic GDBusNodeInfo *vrrp_introspection_data = NULL;\nstatic GDBusNodeInfo *vrrp_instance_introspection_data = NULL;\nstatic GDBusConnection *global_connection;\nstatic GHashTable *objects;\nstatic GMainLoop *loop;\n\n/* Data passing between main vrrp thread and dbus thread */\ndbus_queue_ent_t *ent_ptr;\nstatic int dbus_in_pipe[2], dbus_out_pipe[2];\nstatic sem_t thread_end;\n\n/* The only characters that are valid in a dbus path are A-Z, a-z, 0-9, _ */\nstatic char *\nset_valid_path(char *valid_path, const char *path)\n{\n\tconst char *str_in;\n\tchar *str_out;\n\n\tfor (str_in = path, str_out = valid_path; *str_in; str_in++, str_out++) {\n\t\tif (!isalnum(*str_in))\n\t\t\t*str_out = '_';\n\t\telse\n\t\t\t*str_out = *str_in;\n\t}\n\t*str_out = '\\0';\n\n\treturn valid_path;\n}\n\nstatic bool\nvalid_path_cmp(const char *path, const char *valid_path)\n{\n\tfor ( ; *path && *valid_path; path++, valid_path++) {\n\t\tif (!isalnum(*path)) {\n\t\t\tif (*valid_path != '_')\n\t\t\t\treturn true;\n\t\t}\n\t\telse if (*path != *valid_path)\n\t\t\treturn true;\n\t}\n\n\treturn *path != *valid_path;\n}\n\nstatic const char *\nfamily_str(int family)\n{\n\tif (family == AF_INET)\n\t\treturn \"IPv4\";\n\tif (family == AF_INET6)\n\t\treturn \"IPv6\";\n\treturn \"None\";\n}\n\nstatic const char *\nstate_str(int state)\n{\n\tswitch (state) {\n\tcase VRRP_STATE_INIT:\n\t\treturn \"Init\";\n\tcase VRRP_STATE_BACK:\n\t\treturn \"Backup\";\n\tcase VRRP_STATE_MAST:\n\t\treturn \"Master\";\n\tcase VRRP_STATE_FAULT:\n\t\treturn \"Fault\";\n\t}\n\treturn \"Unknown\";\n}\n\nstatic vrrp_t *\nget_vrrp_instance(const char *ifname, int vrid, int family)\n{\n\telement e;\n\tvrrp_t *vrrp;\n\n\tif (LIST_ISEMPTY(vrrp_data->vrrp))\n\t\treturn NULL;\n\n\tfor (e = LIST_HEAD(vrrp_data->vrrp); e; ELEMENT_NEXT(e)) {\n\t\tvrrp = ELEMENT_DATA(e);\n\n\t\tif (vrrp->vrid == vrid &&\n\t\t    vrrp->family == family &&\n\t\t    !valid_path_cmp(IF_BASE_IFP(vrrp->ifp)->ifname, ifname))\n\t\t\t\treturn vrrp;\n\t}\n\n\treturn NULL;\n}\n\nstatic gboolean\nunregister_object(gpointer key, gpointer value, __attribute__((unused)) gpointer user_data)\n{\n\tif (g_hash_table_remove(objects, key))\n\t\treturn g_dbus_connection_unregister_object(global_connection, GPOINTER_TO_UINT(value));\n\treturn false;\n}\n\nstatic gchar *\ndbus_object_create_path_vrrp(void)\n{\n\treturn g_strconcat(DBUS_VRRP_OBJECT_ROOT,\n#if HAVE_DECL_CLONE_NEWNET\n\t\t\t  global_data->network_namespace ? \"/\" : \"\", global_data->network_namespace ? global_data->network_namespace : \"\",\n#endif\n\t\t\t  global_data->instance_name ? \"/\" : \"\", global_data->instance_name ? global_data->instance_name : \"\",\n\n\t\t\t  \"/Vrrp\", NULL);\n}\n\nstatic gchar *\ndbus_object_create_path_instance(const gchar *interface, int vrid, sa_family_t family)\n{\n\tgchar *object_path;\n\tchar standardized_name[sizeof ((vrrp_t*)NULL)->ifp->ifname];\n\tgchar *vrid_str = g_strdup_printf(\"%d\", vrid);\n\n\tset_valid_path(standardized_name, interface);\n\n\tobject_path = g_strconcat(DBUS_VRRP_OBJECT_ROOT,\n#if HAVE_DECL_CLONE_NEWNET\n\t\t\t\t  global_data->network_namespace ? \"/\" : \"\", global_data->network_namespace ? global_data->network_namespace : \"\",\n#endif\n\t\t\t\t  global_data->instance_name ? \"/\" : \"\", global_data->instance_name ? global_data->instance_name : \"\",\n\n\t\t\t\t  \"/Instance/\",\n\t\t\t\t  standardized_name, \"/\", vrid_str,\n\t\t\t\t  \"/\", family_str(family),\n\t\t\t\t  NULL);\n\n\tg_free(vrid_str);\n\treturn object_path;\n}\n\nstatic dbus_queue_ent_t *\nprocess_method_call(dbus_queue_ent_t *ent)\n{\n\tssize_t ret;\n\n\tif (!ent)\n\t\treturn NULL;\n\n\t/* Tell the main thread that a queue entry is waiting. Any data works */\n\tent_ptr = ent;\n\tif (write(dbus_in_pipe[1], ent, 1) != 1)\n\t\tlog_message(LOG_INFO, \"Write from DBus thread to main thread failed\");\n\n\t/* Wait for a response */\n\twhile ((ret = read(dbus_out_pipe[0], ent, 1)) == -1 && errno == EINTR) {\n\t\tlog_message(LOG_INFO, \"dbus_out_pipe read returned EINTR\");\n\t}\n\tif (ret == -1)\n\t\tlog_message(LOG_INFO, \"DBus response read error - errno = %d\", errno);\n\n#ifdef DBUS_DEBUG\n\tif (ent->reply != DBUS_SUCCESS) {\n\t\tchar *iname;\n\n\t\tif (ent->reply == DBUS_INTERFACE_NOT_FOUND)\n\t\t\tlog_message(LOG_INFO, \"Unable to find DBus requested instance %s/%d/%s\", ent->ifname, ent->vrid, family_str(ent->family));\n\t\telse if (ent->reply == DBUS_OBJECT_ALREADY_EXISTS)\n\t\t\tlog_message(LOG_INFO, \"Unable to create DBus requested object with instance %s/%d/%s\", ent->ifname, ent->vrid, family_str(ent->family));\n\t\telse if (ent->reply == DBUS_INSTANCE_NOT_FOUND) {\n\t\t\tg_variant_get(ent->args, \"(s)\", &iname);\n\t\t\tlog_message(LOG_INFO, \"Unable to find DBus requested instance %s\", iname);\n\t\t}\n\t\telse\n\t\t\tlog_message(LOG_INFO, \"Unknown DBus reply %d\", ent->reply);\n\t}\n#endif\n\n\treturn ent;\n}\n\nstatic void\nget_interface_ids(const gchar *object_path, gchar *interface, uint8_t *vrid, uint8_t *family)\n{\n\tint path_length = DBUS_VRRP_INSTANCE_PATH_DEFAULT_LENGTH;\n\tgchar **dirs;\n\tchar *endptr;\n\n#if HAVE_DECL_CLONE_NEWNET\n\tif(global_data->network_namespace)\n\t\tpath_length++;\n#endif\n\tif(global_data->instance_name)\n\t\tpath_length++;\n\n\t/* object_path will have interface, vrid and family as\n\t * the third to last, second to last and last levels */\n\tdirs = g_strsplit(object_path, \"/\", path_length);\n\tstrcpy(interface, dirs[path_length-3]);\n\t*vrid = (uint8_t)strtoul(dirs[path_length-2], &endptr, 10);\n\tif (*endptr)\n\t\tlog_message(LOG_INFO, \"Dbus unexpected characters '%s' at end of number '%s'\", endptr, dirs[path_length-2]);\n\t*family = !g_strcmp0(dirs[path_length-1], \"IPv4\") ? AF_INET : !g_strcmp0(dirs[path_length-1], \"IPv6\") ? AF_INET6 : AF_UNSPEC;\n\n\t/* We are finished with all the object_path strings now */\n\tg_strfreev(dirs);\n}\n\n/* handles reply to org.freedesktop.DBus.Properties.Get method on any object*/\nstatic GVariant *\nhandle_get_property(__attribute__((unused)) GDBusConnection *connection,\n\t\t    __attribute__((unused)) const gchar     *sender,\n\t\t\t\t\t    const gchar     *object_path,\n\t\t\t\t\t    const gchar     *interface_name,\n\t\t\t\t\t    const gchar     *property_name,\n\t\t\t\t\t    GError\t   **error,\n\t\t    __attribute__((unused)) gpointer\t     user_data)\n{\n\tGVariant *ret = NULL;\n\tdbus_queue_ent_t ent;\n\tchar ifname_str[sizeof ((vrrp_t*)NULL)->ifp->ifname];\n\tint action;\n\n\tif (g_strcmp0(interface_name, DBUS_VRRP_INSTANCE_INTERFACE)) {\n\t\tlog_message(LOG_INFO, \"Interface %s has not been implemented yet\", interface_name);\n\t\treturn NULL;\n\t}\n\n\tif (!g_strcmp0(property_name, \"Name\"))\n\t\taction = DBUS_GET_NAME;\n\telse if (!g_strcmp0(property_name, \"State\"))\n\t\taction = DBUS_GET_STATUS;\n\telse {\n\t\tlog_message(LOG_INFO, \"Property %s does not exist\", property_name);\n\t\treturn NULL;\n\t}\n\n\tget_interface_ids(object_path, ifname_str, &ent.vrid, &ent.family);\n\n\tent.action = action;\n\tent.ifname = ifname_str;\n\tent.args = NULL;\n\tprocess_method_call(&ent);\n\tif (ent.reply == DBUS_SUCCESS)\n\t\tret = ent.args;\n\telse\n\t\tg_set_error(error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, \"Instance '%s/%d/%s' not found\", ifname_str, ent.vrid, family_str(ent.family));\n\n\treturn ret;\n}\n\n/* handles method_calls on any object */\nstatic void\nhandle_method_call(__attribute__((unused)) GDBusConnection *connection,\n\t\t   __attribute__((unused)) const gchar\t   *sender,\n\t\t\t\t\t   const gchar\t   *object_path,\n\t\t\t\t\t   const gchar\t   *interface_name,\n\t\t\t\t\t   const gchar\t   *method_name,\n#ifndef _WITH_DBUS_CREATE_INSTANCE_\n\t\t   __attribute__((unused))\n#endif\n\t\t\t\t\t   GVariant *parameters,\n\t\t   GDBusMethodInvocation *invocation,\n\t\t   __attribute__((unused)) gpointer user_data)\n{\n#ifdef _WITH_DBUS_CREATE_INSTANCE_\n\tchar *iname;\n\tchar *ifname;\n\tsize_t len;\n\tunsigned family;\n#endif\n\tdbus_queue_ent_t ent;\n\tchar ifname_str[sizeof ((vrrp_t*)NULL)->ifp->ifname];\n\n\tif (!g_strcmp0(interface_name, DBUS_VRRP_INTERFACE)) {\n\t\tif (!g_strcmp0(method_name, \"PrintData\")) {\n\t\t\tent.action = DBUS_PRINT_DATA;\n\t\t\tprocess_method_call(&ent);\n\t\t\tg_dbus_method_invocation_return_value(invocation, NULL);\n\t\t}\n\t\telse if (g_strcmp0(method_name, \"PrintStats\") == 0) {\n\t\t\tent.action = DBUS_PRINT_STATS;\n\t\t\tprocess_method_call(&ent);\n\t\t\tg_dbus_method_invocation_return_value(invocation, NULL);\n\t\t}\n\t\telse if (g_strcmp0(method_name, \"ReloadConfig\") == 0) {\n\t\t\tg_dbus_method_invocation_return_value(invocation, NULL);\n\t\t\tkill(getppid(), SIGHUP);\n\t\t}\n#ifdef _WITH_DBUS_CREATE_INSTANCE_\n\t\telse if (g_strcmp0(method_name, \"CreateInstance\") == 0) {\n\t\t\tg_variant_get(parameters, \"(ssuu)\", &iname, &ifname, &ent.vrid, &family);\n\t\t\tlen = strlen(ifname);\n\t\t\tif (len == 0 || len >= IFNAMSIZ) {\n\t\t\t\tlog_message(LOG_INFO, \"Interface name '%s' too long for CreateInstance\", ifname);\n\t\t\t\tg_dbus_method_invocation_return_error(invocation, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, \"Interface name empty or too long\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tent.action = DBUS_CREATE_INSTANCE;\n\t\t\tent.ifname = ifname;\n\t\t\tent.family = family == 4 ? AF_INET : family == 6 ? AF_INET6 : AF_UNSPEC;\n\t\t\tent.args = g_variant_new(\"(s)\", iname);\n\t\t\tprocess_method_call(&ent);\n\t\t\tg_variant_unref(ent.args);\n\t\t\tg_dbus_method_invocation_return_value(invocation, NULL);\n\t\t}\n\t\telse if (g_strcmp0(method_name, \"DestroyInstance\") == 0) {\n// TODO - this should be on the instance\n\t\t\tent.action = DBUS_DESTROY_INSTANCE;\n\t\t\tent.args = parameters;\n\t\t\tprocess_method_call(&ent);\n\n\t\t\tif (ent.reply == DBUS_INSTANCE_NOT_FOUND) {\n\t\t\t\tg_variant_get(parameters, \"(s)\", &iname);\n\t\t\t\tg_dbus_method_invocation_return_error(invocation, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, \"Instance '%s' not found\", iname);\n\t\t\t}\n\t\t\telse\n\t\t\t\tg_dbus_method_invocation_return_value(invocation, NULL);\n\t\t}\n#endif\n\t\telse {\n\t\t\tlog_message(LOG_INFO, \"Method %s has not been implemented yet\", method_name);\n\t\t\tg_dbus_method_invocation_return_error(invocation, G_DBUS_ERROR, G_DBUS_ERROR_MATCH_RULE_NOT_FOUND, \"Method not implemented\");\n\t\t}\n\n\t\treturn;\n\t}\n\n\tif (!g_strcmp0(interface_name, DBUS_VRRP_INSTANCE_INTERFACE)) {\n\t\tif (!g_strcmp0(method_name, \"SendGarp\")) {\n\t\t\tget_interface_ids(object_path, ifname_str, &ent.vrid, &ent.family);\n\t\t\tent.action = DBUS_SEND_GARP;\n\t\t\tent.ifname = ifname_str;\n\t\t\tprocess_method_call(&ent);\n\t\t\tif (ent.reply ==  DBUS_INTERFACE_NOT_FOUND)\n\t\t\t\tg_dbus_method_invocation_return_error(invocation, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, \"Instance '%s/%d/%s' not found\", ifname_str, ent.vrid, family_str(ent.family));\n\t\t\telse\n\t\t\t\tg_dbus_method_invocation_return_value(invocation, NULL);\n\t\t} else {\n\t\t\tlog_message(LOG_INFO, \"Method %s has not been implemented yet\", method_name);\n\t\t\tg_dbus_method_invocation_return_error(invocation, G_DBUS_ERROR, G_DBUS_ERROR_MATCH_RULE_NOT_FOUND, \"Method not implemented\");\n\t\t}\n\n\t\treturn;\n\t}\n\n\tlog_message(LOG_INFO, \"Interface %s has not been implemented yet\", interface_name);\n\tg_dbus_method_invocation_return_error(invocation, G_DBUS_ERROR, G_DBUS_ERROR_MATCH_RULE_NOT_FOUND, \"Interface not implemented\");\n}\n\nstatic const GDBusInterfaceVTable interface_vtable =\n{\n\thandle_method_call,\n\thandle_get_property,\n\tNULL, /* handle_set_property is null because we have no writeable property */\n\t{}\n};\n\nstatic int\ndbus_create_object_params(char *instance_name, const char *interface_name, int vrid, sa_family_t family, bool log_success)\n{\n\tgchar *object_path;\n\tGError *local_error = NULL;\n\n\tif (g_hash_table_lookup(objects, instance_name)) {\n\t\tlog_message(LOG_INFO, \"An object for instance %s already exists\", instance_name);\n\t\treturn DBUS_OBJECT_ALREADY_EXISTS;\n\t}\n\n\tobject_path = dbus_object_create_path_instance(interface_name, vrid, family);\n\n\tguint instance = g_dbus_connection_register_object(global_connection, object_path,\n\t\t\t\t\t\tvrrp_instance_introspection_data->interfaces[0],\n\t\t\t\t\t\t&interface_vtable, NULL, NULL, &local_error);\n\tif (local_error != NULL) {\n\t\tlog_message(LOG_INFO, \"Registering DBus object on %s failed: %s\",\n\t\t\t    object_path, local_error->message);\n\t\tg_clear_error(&local_error);\n\t}\n\n\tif (instance) {\n\t\tg_hash_table_insert(objects, instance_name, GUINT_TO_POINTER(instance));\n\t\tif (log_success)\n\t\t\tlog_message(LOG_INFO, \"Added DBus object for instance %s on path %s\", instance_name, object_path);\n\t}\n\tg_free(object_path);\n\n\treturn DBUS_SUCCESS;\n}\n\nstatic void\ndbus_create_object(vrrp_t *vrrp)\n{\n\tdbus_create_object_params(vrrp->iname, IF_NAME(IF_BASE_IFP(vrrp->ifp)), vrrp->vrid, vrrp->family, false);\n}\n\nstatic bool\ndbus_emit_signal(GDBusConnection *connection,\n\t\t const gchar *object_path,\n\t\t const gchar *interface_name,\n\t\t const gchar *signal_name,\n\t\t GVariant *parameters)\n{\n\tGError *local_error = NULL;\n\n\tg_dbus_connection_emit_signal(connection, NULL, object_path, interface_name, signal_name, parameters,\n\t\t\t\t      &local_error);\n\n\tif (local_error != NULL) {\n\t\tlog_message(LOG_INFO, \"Emitting DBus signal %s.%s on %s failed: %s\",\n\t\t\t    interface_name, signal_name, object_path, local_error->message);\n\t\tg_clear_error(&local_error);\n\t\treturn false;\n\t}\n\treturn true;\n}\n\n/* first function to be run when trying to own bus,\n * exports objects to the bus */\nstatic void\non_bus_acquired(GDBusConnection *connection,\n\t\tconst gchar     *name,\n\t\t__attribute__((unused)) gpointer user_data)\n{\n\tglobal_connection = connection;\n\tgchar *path;\n\telement e;\n\tGError *local_error = NULL;\n\n\tlog_message(LOG_INFO, \"Acquired DBus bus %s\", name);\n\n\t/* register VRRP object */\n\tpath = dbus_object_create_path_vrrp();\n\tguint vrrp = g_dbus_connection_register_object(connection, path,\n\t\t\t\t\t\t\t vrrp_introspection_data->interfaces[0],\n\t\t\t\t\t\t\t &interface_vtable, NULL, NULL, &local_error);\n\tg_hash_table_insert(objects, \"__Vrrp__\", GUINT_TO_POINTER(vrrp));\n\tg_free(path);\n\tif (local_error != NULL) {\n\t\tlog_message(LOG_INFO, \"Registering VRRP object on %s failed: %s\",\n\t\t\t    path, local_error->message);\n\t\tg_clear_error(&local_error);\n\t}\n\n\t/* for each available VRRP instance, register an object */\n\tif (LIST_ISEMPTY(vrrp_data->vrrp))\n\t\treturn;\n\n\tfor (e = LIST_HEAD(vrrp_data->vrrp); e; ELEMENT_NEXT(e)) {\n\t\tvrrp_t * vrrp = ELEMENT_DATA(e);\n\t\tdbus_create_object(vrrp);\n\t}\n\n\t/* Send a signal to say we have started */\n\tpath = dbus_object_create_path_vrrp();\n\tdbus_emit_signal(global_connection, path, DBUS_VRRP_INTERFACE, \"VrrpStarted\", NULL);\n\tg_free(path);\n\n\t/* Notify DBus of the state of our instances */\n\tfor (e = LIST_HEAD(vrrp_data->vrrp); e; ELEMENT_NEXT(e)) {\n\t\tvrrp_t * vrrp = ELEMENT_DATA(e);\n\t\tdbus_send_state_signal(vrrp);\n\t}\n}\n\n/* run if bus name is acquired successfully */\nstatic void\non_name_acquired(__attribute__((unused)) GDBusConnection *connection,\n\t\t const gchar     *name,\n\t\t __attribute__((unused)) gpointer user_data)\n{\n\tlog_message(LOG_INFO, \"Acquired the name %s on the session bus\", name);\n}\n\n/* run if bus name or connection are lost */\nstatic void\non_name_lost(GDBusConnection *connection,\n\t     const gchar     *name,\n\t     __attribute__((unused)) gpointer user_data)\n{\n\tlog_message(LOG_INFO, \"Lost the name %s on the session bus\", name);\n\tglobal_connection = connection;\n\tg_hash_table_foreach_remove(objects, unregister_object, NULL);\n\tobjects = NULL;\n\tglobal_connection = NULL;\n}\n\nstatic gchar*\nread_file(gchar* filepath)\n{\n\tFILE * f;\n\tsize_t length;\n\tgchar *ret = NULL;\n\n\tf = fopen(filepath, \"r\");\n\tif (f) {\n\t\tfseek(f, 0, SEEK_END);\n\t\tlength = (size_t)ftell(f);\n\t\tfseek(f, 0, SEEK_SET);\n\n\t\t/* We can't use MALLOC since it isn't thread safe */\n\t\tret = MALLOC(length + 1);\n\t\tif (ret) {\n\t\t\tif (fread(ret, length, 1, f) != 1) {\n\t\t\t\tlog_message(LOG_INFO, \"Failed to read all of %s\", filepath);\n\t\t\t}\n\t\t\tret[length] = '\\0';\n\t\t}\n\t\telse\n\t\t\tlog_message(LOG_INFO, \"Unable to read Dbus file %s\", filepath);\n\n\t\tfclose(f);\n\t}\n\treturn ret;\n}\n\nstatic void *\ndbus_main(__attribute__ ((unused)) void *unused)\n{\n\tgchar *introspection_xml;\n\tguint owner_id;\n\tconst char *service_name;\n\n\tobjects = g_hash_table_new(g_str_hash, g_str_equal);\n\n\t/* DBus service org.keepalived.Vrrp1 exposes two interfaces, Vrrp and Instance.\n\t * Vrrp is implemented by a single VRRP object for general purposes, such as printing\n\t * data or signaling that the VRRP process has been stopped.\n\t * Instance is implemented by an Instance object for every VRRP Instance in vrrp_data.\n\t * It exposes instance specific methods and properties.\n\t */\n#ifdef DBUS_NEED_G_TYPE_INIT\n\tg_type_init();\n#endif\n\tGError *error = NULL;\n\n\t/* read service interface data from xml files */\n\tintrospection_xml = read_file(DBUS_VRRP_INTERFACE_FILE_PATH);\n\tif (!introspection_xml)\n\t\treturn NULL;\n\tvrrp_introspection_data = g_dbus_node_info_new_for_xml(introspection_xml, &error);\n\tFREE(introspection_xml);\n\tif (error != NULL) {\n\t\tlog_message(LOG_INFO, \"Parsing DBus interface %s from file %s failed: %s\",\n\t\t\t    DBUS_VRRP_INTERFACE, DBUS_VRRP_INTERFACE_FILE_PATH, error->message);\n\t\tg_clear_error(&error);\n\t\treturn NULL;\n\t}\n\n\tintrospection_xml = read_file(DBUS_VRRP_INSTANCE_INTERFACE_FILE_PATH);\n\tif (!introspection_xml)\n\t\treturn NULL;\n\tvrrp_instance_introspection_data = g_dbus_node_info_new_for_xml(introspection_xml, &error);\n\tFREE(introspection_xml);\n\tif (error != NULL) {\n\t\tlog_message(LOG_INFO, \"Parsing DBus interface %s from file %s failed: %s\",\n\t\t\t    DBUS_VRRP_INSTANCE_INTERFACE, DBUS_VRRP_INSTANCE_INTERFACE_FILE_PATH, error->message);\n\t\tg_clear_error(&error);\n\t\treturn NULL;\n\t}\n\n\tservice_name = global_data->dbus_service_name ? global_data->dbus_service_name : DBUS_SERVICE_NAME;\n\towner_id = g_bus_own_name(G_BUS_TYPE_SYSTEM,\n\t\t\t\t  service_name,\n\t\t\t\t  G_BUS_NAME_OWNER_FLAGS_NONE,\n\t\t\t\t  on_bus_acquired,\n\t\t\t\t  on_name_acquired,\n\t\t\t\t  on_name_lost,\n\t\t\t\t  NULL,  /* user_data */\n\t\t\t\t  NULL); /* user_data_free_func */\n\n\tloop = g_main_loop_new(NULL, FALSE);\n\tg_main_loop_run(loop);\n\n\t/* cleanup after loop terminates */\n\tg_main_loop_unref(loop);\n\tg_bus_unown_name(owner_id);\n\tglobal_connection = NULL;\n\n\tsem_post(&thread_end);\n\tpthread_exit(0);\n}\n\n/* The following functions are run in the context of the main vrrp thread */\n\n/* send signal VrrpStatusChange\n * containing the new state of vrrp */\nvoid\ndbus_send_state_signal(vrrp_t *vrrp)\n{\n\tgchar *object_path;\n\tGVariant *args;\n\n\t/* the interface will go through the initial state changes before\n\t * the main loop can be started and global_connection initialised */\n\tif (global_connection == NULL)\n\t\treturn;\n\n\tobject_path = dbus_object_create_path_instance(IF_NAME(IF_BASE_IFP(vrrp->ifp)), vrrp->vrid, vrrp->family);\n\n\targs = g_variant_new(\"(u)\", vrrp->state);\n\tdbus_emit_signal(global_connection, object_path, DBUS_VRRP_INSTANCE_INTERFACE, \"VrrpStatusChange\", args);\n\tg_free(object_path);\n}\n\n/* send signal VrrpRestarted */\nstatic void\ndbus_send_reload_signal(void)\n{\n\tgchar *path;\n\n\tif (global_connection == NULL)\n\t\treturn;\n\n\tpath = dbus_object_create_path_vrrp();\n\tdbus_emit_signal(global_connection, path, DBUS_VRRP_INTERFACE, \"VrrpReloaded\", NULL);\n\tg_free(path);\n}\n\nstatic gboolean\ndbus_unregister_object(char *str)\n{\n\tgboolean ret = false;\n\n\tgpointer value = g_hash_table_lookup(objects, str);\n\tif (value) {\n\t\tret = unregister_object(str, value, NULL);\n\t\tlog_message(LOG_INFO, \"Deleted DBus object for instance %s\", str);\n\t}\n#ifdef DBUS_DEBUG\n\telse\n\t\tlog_message(LOG_INFO, \"DBus object not found for instance %s\", str);\n#endif\n\n\treturn ret;\n}\n\nvoid\ndbus_remove_object(vrrp_t *vrrp)\n{\n\tdbus_unregister_object(vrrp->iname);\n}\n\nstatic int\nhandle_dbus_msg(__attribute__((unused)) thread_t *thread)\n{\n\tdbus_queue_ent_t *ent;\n\tchar recv_buf;\n\tvrrp_t *vrrp;\n#ifdef _WITH_DBUS_CREATE_INSTANCE_\n\tgchar *name;\n#endif\n\n\tif (read(dbus_in_pipe[0], &recv_buf, 1) != 1)\n\t\tlog_message(LOG_INFO, \"Read from DBus thread to vrrp thread failed\");\n\n\tif ((ent = ent_ptr) != NULL) {\n\t\tent->reply = DBUS_SUCCESS;\n\n\t\tif (ent->action == DBUS_PRINT_DATA) {\n\t\t\tlog_message(LOG_INFO, \"Printing VRRP data on DBus request\");\n\t\t\tvrrp_print_data();\n\n\t\t}\n\t\telse if (ent->action == DBUS_PRINT_STATS) {\n\t\t\tlog_message(LOG_INFO, \"Printing VRRP stats on DBus request\");\n\t\t\tvrrp_print_stats();\n\t\t}\n#ifdef _WITH_DBUS_CREATE_INSTANCE_\n\t\telse if (ent->action == DBUS_CREATE_INSTANCE) {\n\t\t\tg_variant_get(ent->args, \"(s)\", &name);\n\t\t\tent->reply = dbus_create_object_params(name, ent->ifname, ent->vrid, ent->family, true);\n\t\t}\n\t\telse if (ent->action == DBUS_DESTROY_INSTANCE) {\n\t\t\tg_variant_get(ent->args, \"(s)\", &name);\n\t\t\tif (!dbus_unregister_object(name))\n\t\t\t\tent->reply = DBUS_INSTANCE_NOT_FOUND;\n\t\t}\n#endif\n\t\telse if (ent->action == DBUS_SEND_GARP) {\n\t\t\tent->reply = DBUS_INTERFACE_NOT_FOUND;\n\t\t\tvrrp = get_vrrp_instance(ent->ifname, ent->vrid, ent->family);\n\t\t\tif (vrrp) {\n\t\t\t\tlog_message(LOG_INFO, \"Sending garps on %s on DBus request\", vrrp->iname);\n\t\t\t\tvrrp_send_link_update(vrrp, 1);\n\t\t\t\tent->reply = DBUS_SUCCESS;\n\t\t\t}\n\t\t}\n\t\telse if (ent->action == DBUS_GET_NAME ||\n\t\t\t ent->action == DBUS_GET_STATUS) {\n\t\t\t/* we look for the vrrp instance object that corresponds to our interface and group */\n\t\t\tent->reply = DBUS_INTERFACE_NOT_FOUND;\n\n\t\t\tvrrp = get_vrrp_instance(ent->ifname, ent->vrid, ent->family);\n\n\t\t\tif (vrrp) {\n\t\t\t\t/* the property_name argument is the property we want to Get */\n\t\t\t\tif (ent->action == DBUS_GET_NAME)\n\t\t\t\t\tent->args = g_variant_new(\"(s)\", vrrp->iname);\n\t\t\t\telse if (ent->action == DBUS_GET_STATUS)\n\t\t\t\t\tent->args = g_variant_new(\"(us)\", vrrp->state, state_str(vrrp->state));\n\t\t\t\telse\n\t\t\t\t\tent->args = NULL;\t /* How did we get here? */\n\t\t\t\tent->reply = DBUS_SUCCESS;\n\t\t\t}\n\t\t}\n\t\tif (write(dbus_out_pipe[1], ent, 1) != 1)\n\t\t\tlog_message(LOG_INFO, \"Write from main thread to DBus thread failed\");\n\t}\n\n\tthread_add_read(master, handle_dbus_msg, NULL, dbus_in_pipe[0], TIMER_NEVER);\n\n\treturn 0;\n}\n\nvoid\ndbus_reload(list o, list n)\n{\n\telement e1, e2, e3;\n\tvrrp_t *vrrp_n, *vrrp_o, *vrrp_n3;\n\n\tif (!LIST_ISEMPTY(n)) {\n\t\tfor (e1 = LIST_HEAD(n); e1; ELEMENT_NEXT(e1)) {\n\t\t\tchar *n_name;\n\t\t\tbool match_found;\n\n\t\t\tvrrp_n = ELEMENT_DATA(e1);\n\n\t\t\tif (LIST_ISEMPTY(o)) {\n\t\t\t\tdbus_create_object(vrrp_n);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tn_name = IF_BASE_IFP(vrrp_n->ifp)->ifname;\n\n\t\t\t/* Try an find an instance with same vrid/family/interface that existed before and now */\n\t\t\tfor (e2 = LIST_HEAD(o), match_found = false; e2 && !match_found; ELEMENT_NEXT(e2)) {\n\t\t\t\tvrrp_o = ELEMENT_DATA(e2);\n\n\t\t\t\tif (vrrp_n->vrid == vrrp_o->vrid &&\n\t\t\t\t    vrrp_n->family == vrrp_o->family &&\n\t\t\t\t    !strcmp(n_name, IF_BASE_IFP(vrrp_o->ifp)->ifname)) {\n\t\t\t\t\t/* If the old instance exists in the new config,\n\t\t\t\t\t * then the dbus object will exist */\n\t\t\t\t\tif (!strcmp(vrrp_n->iname, vrrp_o->iname)) {\n\t\t\t\t\t\tmatch_found = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* Check if the old instance name we found still exists\n\t\t\t\t\t * (but has a different vrid/family/interface) */\n\t\t\t\t\tfor (e3 = LIST_HEAD(n); e3; ELEMENT_NEXT(e3)) {\n\t\t\t\t\t\tvrrp_n3 = ELEMENT_DATA(e3);\n\t\t\t\t\t\tif (!strcmp(vrrp_o->iname, vrrp_n3->iname)) {\n\t\t\t\t\t\t\tmatch_found = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (match_found)\n\t\t\t\tcontinue;\n\n\t\t\tdbus_create_object(vrrp_n);\n\t\t}\n\t}\n\n\t/* Signal we have reloaded */\n\tdbus_send_reload_signal();\n\n\t/* We need to reinstate the read thread */\n\tthread_add_read(master, handle_dbus_msg, NULL, dbus_in_pipe[0], TIMER_NEVER);\n}\n\nbool\ndbus_start(void)\n{\n\tpthread_t dbus_thread;\n\tsigset_t sigset, cursigset;\n\n\tif (open_pipe(dbus_in_pipe)) {\n\t\tlog_message(LOG_INFO, \"Unable to create inbound dbus pipe - disabling DBus\");\n\t\treturn false;\n\t}\n\tif (open_pipe(dbus_out_pipe)) {\n\t\tlog_message(LOG_INFO, \"Unable to create outbound dbus pipe - disabling DBus\");\n\t\tclose(dbus_in_pipe[0]);\n\t\tclose(dbus_in_pipe[1]);\n\t\treturn false;\n\t}\n\n\t/* We don't want the main thread to block when using the pipes,\n\t * but the other side of the pipes should block. */\n\tfcntl(dbus_in_pipe[1], F_SETFL, fcntl(dbus_in_pipe[1], F_GETFL) & ~O_NONBLOCK);\n\tfcntl(dbus_out_pipe[0], F_SETFL, fcntl(dbus_out_pipe[0], F_GETFL) & ~O_NONBLOCK);\n\n\tthread_add_read(master, handle_dbus_msg, NULL, dbus_in_pipe[0], TIMER_NEVER);\n\n\t/* Initialise the thread termination semaphore */\n\tsem_init(&thread_end, 0, 0);\n\n\t/* Block signals (all) we don't want the new thread to process */\n\tsigfillset(&sigset);\n\tpthread_sigmask(SIG_SETMASK, &sigset, &cursigset);\n\n\t/* Now create the dbus thread */\n\tpthread_create(&dbus_thread, NULL, &dbus_main, NULL);\n\n\t/* Reenable our signals */\n\tpthread_sigmask(SIG_SETMASK, &cursigset, NULL);\n\n\treturn true;\n}\n\nvoid\ndbus_stop(void)\n{\n\tstruct timespec thread_end_wait;\n\tint ret;\n\tgchar *path;\n\n\tif (global_connection != NULL) {\n\t\tpath = dbus_object_create_path_vrrp();\n\t\tdbus_emit_signal(global_connection, path, DBUS_VRRP_INTERFACE, \"VrrpStopped\", NULL);\n\t\tg_free(path);\n\t}\n\n\tg_main_loop_quit(loop);\n\n\tg_dbus_node_info_unref(vrrp_introspection_data);\n\tg_dbus_node_info_unref(vrrp_instance_introspection_data);\n\n\tclock_gettime(CLOCK_REALTIME, &thread_end_wait);\n\tthread_end_wait.tv_sec += 1;\n\twhile ((ret = sem_timedwait(&thread_end, &thread_end_wait)) == -1 && errno == EINTR) ;\n\n\tif (ret == -1 ) {\n\t\tif (errno == ETIMEDOUT)\n\t\t\tlog_message(LOG_INFO, \"DBus thread termination timed out\");\n\t\telse\n\t\t\tlog_message(LOG_INFO, \"sem_timewait error %d\", errno);\n\t}\n\telse {\n\t\tlog_message(LOG_INFO, \"Released DBus\");\n\t\tsem_destroy(&thread_end);\n\t}\n}\n\n#ifdef THREAD_DUMP\nvoid\nregister_vrrp_dbus_addresses(void)\n{\n\tregister_thread_address(\"handle_dbus_msg\", handle_dbus_msg);\n}\n#endif\n", "/*\n * Soft:        Vrrpd is an implementation of VRRPv2 as specified in rfc2338.\n *              VRRP is a protocol which elect a master server on a LAN. If the\n *              master fails, a backup server takes over.\n *              The original implementation has been made by jerome etienne.\n *\n * Part:        Output running VRRP state information in JSON format\n *\n * Author:      Damien Clabaut, <Damien.Clabaut@corp.ovh.com>\n *\n *              This program is distributed in the hope that it will be useful,\n *              but WITHOUT ANY WARRANTY; without even the implied warranty of\n *              MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n *              See the GNU General Public License for more details.\n *\n *              This program is free software; you can redistribute it and/or\n *              modify it under the terms of the GNU General Public License\n *              as published by the Free Software Foundation; either version\n *              2 of the License, or (at your option) any later version.\n *\n * Copyright (C) 2017 Damien Clabaut, <Damien.Clabaut@corp.ovh.com>\n * Copyright (C) 2017-2017 Alexandre Cassen, <acassen@gmail.com>\n */\n\n#include \"config.h\"\n#include \"vrrp_json.h\"\n\n#include <errno.h>\n#include <stdio.h>\n#include <json.h>\n\n#include \"vrrp.h\"\n#include \"vrrp_track.h\"\n#include \"list.h\"\n#include \"vrrp_data.h\"\n#include \"vrrp_iproute.h\"\n#include \"vrrp_iprule.h\"\n#include \"logger.h\"\n#include \"timer.h\"\n#include \"utils.h\"\n\nstatic inline double\ntimeval_to_double(const timeval_t *t)\n{\n\t/* The casts are necessary to avoid conversion warnings */\n\treturn (double)t->tv_sec + (double)t->tv_usec / TIMER_HZ_FLOAT;\n}\n\nvoid\nvrrp_print_json(void)\n{\n\tFILE *file;\n\telement e;\n\tstruct json_object *array;\n\n\tif (LIST_ISEMPTY(vrrp_data->vrrp))\n\t\treturn;\n\n\tfile = fopen_safe(\"/tmp/keepalived.json\", \"w\");\n\tif (!file) {\n\t\tlog_message(LOG_INFO, \"Can't open /tmp/keepalived.json (%d: %s)\",\n\t\t\terrno, strerror(errno));\n\t\treturn;\n\t}\n\n\tarray = json_object_new_array();\n\n\tfor (e = LIST_HEAD(vrrp_data->vrrp); e; ELEMENT_NEXT(e)) {\n\t\tstruct json_object *instance_json, *json_stats, *json_data,\n\t\t\t*vips, *evips, *track_ifp, *track_script;\n#ifdef _HAVE_FIB_ROUTING_\n\t\tstruct json_object *vroutes, *vrules;\n#endif\n\t\telement f;\n\n\t\tvrrp_t *vrrp = ELEMENT_DATA(e);\n\t\tinstance_json = json_object_new_object();\n\t\tjson_stats = json_object_new_object();\n\t\tjson_data = json_object_new_object();\n\t\tvips = json_object_new_array();\n\t\tevips = json_object_new_array();\n\t\ttrack_ifp = json_object_new_array();\n\t\ttrack_script = json_object_new_array();\n#ifdef _HAVE_FIB_ROUTING_\n\t\tvroutes = json_object_new_array();\n\t\tvrules = json_object_new_array();\n#endif\n\n\t\t// Dump data to json\n\t\tjson_object_object_add(json_data, \"iname\",\n\t\t\tjson_object_new_string(vrrp->iname));\n\t\tjson_object_object_add(json_data, \"dont_track_primary\",\n\t\t\tjson_object_new_int(vrrp->dont_track_primary));\n\t\tjson_object_object_add(json_data, \"skip_check_adv_addr\",\n\t\t\tjson_object_new_int(vrrp->skip_check_adv_addr));\n\t\tjson_object_object_add(json_data, \"strict_mode\",\n\t\t\tjson_object_new_int((int)vrrp->strict_mode));\n#ifdef _HAVE_VRRP_VMAC_\n\t\tjson_object_object_add(json_data, \"vmac_ifname\",\n\t\t\tjson_object_new_string(vrrp->vmac_ifname));\n#endif\n\t\t// Tracked interfaces are stored in a list\n\t\tif (!LIST_ISEMPTY(vrrp->track_ifp)) {\n\t\t\tfor (f = LIST_HEAD(vrrp->track_ifp); f; ELEMENT_NEXT(f)) {\n\t\t\t\tinterface_t *ifp = ELEMENT_DATA(f);\n\t\t\t\tjson_object_array_add(track_ifp,\n\t\t\t\t\tjson_object_new_string(ifp->ifname));\n\t\t\t}\n\t\t}\n\t\tjson_object_object_add(json_data, \"track_ifp\", track_ifp);\n\n\t\t// Tracked scripts also\n\t\tif (!LIST_ISEMPTY(vrrp->track_script)) {\n\t\t\tfor (f = LIST_HEAD(vrrp->track_script); f; ELEMENT_NEXT(f)) {\n\t\t\t\ttracked_sc_t *tsc = ELEMENT_DATA(f);\n\t\t\t\tvrrp_script_t *vscript = tsc->scr;\n\t\t\t\tjson_object_array_add(track_script,\n\t\t\t\t\tjson_object_new_string(cmd_str(&vscript->script)));\n\t\t\t}\n\t\t}\n\t\tjson_object_object_add(json_data, \"track_script\", track_script);\n\n\t\tjson_object_object_add(json_data, \"ifp_ifname\",\n\t\t\tjson_object_new_string(vrrp->ifp->ifname));\n\t\tjson_object_object_add(json_data, \"master_priority\",\n\t\t\tjson_object_new_int(vrrp->master_priority));\n\t\tjson_object_object_add(json_data, \"last_transition\",\n\t\t\tjson_object_new_double(timeval_to_double(&vrrp->last_transition)));\n\t\tjson_object_object_add(json_data, \"garp_delay\",\n\t\t\tjson_object_new_double(vrrp->garp_delay / TIMER_HZ_FLOAT));\n\t\tjson_object_object_add(json_data, \"garp_refresh\",\n\t\t\tjson_object_new_int((int)vrrp->garp_refresh.tv_sec));\n\t\tjson_object_object_add(json_data, \"garp_rep\",\n\t\t\tjson_object_new_int((int)vrrp->garp_rep));\n\t\tjson_object_object_add(json_data, \"garp_refresh_rep\",\n\t\t\tjson_object_new_int((int)vrrp->garp_refresh_rep));\n\t\tjson_object_object_add(json_data, \"garp_lower_prio_delay\",\n\t\t\tjson_object_new_int((int)(vrrp->garp_lower_prio_delay / TIMER_HZ)));\n\t\tjson_object_object_add(json_data, \"garp_lower_prio_rep\",\n\t\t\tjson_object_new_int((int)vrrp->garp_lower_prio_rep));\n\t\tjson_object_object_add(json_data, \"lower_prio_no_advert\",\n\t\t\tjson_object_new_int((int)vrrp->lower_prio_no_advert));\n\t\tjson_object_object_add(json_data, \"higher_prio_send_advert\",\n\t\t\tjson_object_new_int((int)vrrp->higher_prio_send_advert));\n\t\tjson_object_object_add(json_data, \"vrid\",\n\t\t\tjson_object_new_int(vrrp->vrid));\n\t\tjson_object_object_add(json_data, \"base_priority\",\n\t\t\tjson_object_new_int(vrrp->base_priority));\n\t\tjson_object_object_add(json_data, \"effective_priority\",\n\t\t\tjson_object_new_int(vrrp->effective_priority));\n\t\tjson_object_object_add(json_data, \"vipset\",\n\t\t\tjson_object_new_boolean(vrrp->vipset));\n\n\t\t//Virtual IPs are stored in a list\n\t\tif (!LIST_ISEMPTY(vrrp->vip)) {\n\t\t\tfor (f = LIST_HEAD(vrrp->vip); f; ELEMENT_NEXT(f)) {\n\t\t\t\tip_address_t *vip = ELEMENT_DATA(f);\n\t\t\t\tchar ipaddr[INET6_ADDRSTRLEN];\n\t\t\t\tinet_ntop(vrrp->family, &(vip->u.sin.sin_addr.s_addr),\n\t\t\t\t\tipaddr, INET6_ADDRSTRLEN);\n\t\t\t\tjson_object_array_add(vips,\n\t\t\t\t\tjson_object_new_string(ipaddr));\n\t\t\t}\n\t\t}\n\t\tjson_object_object_add(json_data, \"vips\", vips);\n\n\t\t//External VIPs are also stored in a list\n\t\tif (!LIST_ISEMPTY(vrrp->evip)) {\n\t\t\tfor (f = LIST_HEAD(vrrp->evip); f; ELEMENT_NEXT(f)) {\n\t\t\t\tip_address_t *evip = ELEMENT_DATA(f);\n\t\t\t\tchar ipaddr[INET6_ADDRSTRLEN];\n\t\t\t\tinet_ntop(vrrp->family, &(evip->u.sin.sin_addr.s_addr),\n\t\t\t\t\tipaddr, INET6_ADDRSTRLEN);\n\t\t\t\tjson_object_array_add(evips,\n\t\t\t\t\tjson_object_new_string(ipaddr));\n\t\t\t}\n\t\t}\n\t\tjson_object_object_add(json_data, \"evips\", evips);\n\n\t\tjson_object_object_add(json_data, \"promote_secondaries\",\n\t\t\tjson_object_new_boolean(vrrp->promote_secondaries));\n\n#ifdef _HAVE_FIB_ROUTING_\n\t\t// Dump vroutes\n\t\tif (!LIST_ISEMPTY(vrrp->vroutes)) {\n\t\t\tfor (f = LIST_HEAD(vrrp->vroutes); f; ELEMENT_NEXT(f)) {\n\t\t\t\tip_route_t *route = ELEMENT_DATA(f);\n\t\t\t\tchar *buf = MALLOC(ROUTE_BUF_SIZE);\n\t\t\t\tformat_iproute(route, buf, ROUTE_BUF_SIZE);\n\t\t\t\tjson_object_array_add(vroutes,\n\t\t\t\t\tjson_object_new_string(buf));\n\t\t\t}\n\t\t}\n\t\tjson_object_object_add(json_data, \"vroutes\", vroutes);\n\n\t\t// Dump vrules\n\t\tif (!LIST_ISEMPTY(vrrp->vrules)) {\n\t\t\tfor (f = LIST_HEAD(vrrp->vrules); f; ELEMENT_NEXT(f)) {\n\t\t\t\tip_rule_t *rule = ELEMENT_DATA(f);\n\t\t\t\tchar *buf = MALLOC(RULE_BUF_SIZE);\n\t\t\t\tformat_iprule(rule, buf, RULE_BUF_SIZE);\n\t\t\t\tjson_object_array_add(vrules,\n\t\t\t\t\tjson_object_new_string(buf));\n\t\t\t}\n\t\t}\n\t\tjson_object_object_add(json_data, \"vrules\", vrules);\n#endif\n\n\t\tjson_object_object_add(json_data, \"adver_int\",\n\t\t\tjson_object_new_double(vrrp->adver_int / TIMER_HZ_FLOAT));\n\t\tjson_object_object_add(json_data, \"master_adver_int\",\n\t\t\tjson_object_new_double(vrrp->master_adver_int / TIMER_HZ_FLOAT));\n\t\tjson_object_object_add(json_data, \"accept\",\n\t\t\tjson_object_new_int((int)vrrp->accept));\n\t\tjson_object_object_add(json_data, \"nopreempt\",\n\t\t\tjson_object_new_boolean(vrrp->nopreempt));\n\t\tjson_object_object_add(json_data, \"preempt_delay\",\n\t\t\tjson_object_new_int((int)(vrrp->preempt_delay / TIMER_HZ)));\n\t\tjson_object_object_add(json_data, \"state\",\n\t\t\tjson_object_new_int(vrrp->state));\n\t\tjson_object_object_add(json_data, \"wantstate\",\n\t\t\tjson_object_new_int(vrrp->wantstate));\n\t\tjson_object_object_add(json_data, \"version\",\n\t\t\tjson_object_new_int(vrrp->version));\n\t\tif (vrrp->script_backup)\n\t\t\tjson_object_object_add(json_data, \"script_backup\",\n\t\t\t\tjson_object_new_string(cmd_str(vrrp->script_backup)));\n\t\tif (vrrp->script_master)\n\t\t\tjson_object_object_add(json_data, \"script_master\",\n\t\t\t\tjson_object_new_string(cmd_str(vrrp->script_master)));\n\t\tif (vrrp->script_fault)\n\t\t\tjson_object_object_add(json_data, \"script_fault\",\n\t\t\t\tjson_object_new_string(cmd_str(vrrp->script_fault)));\n\t\tif (vrrp->script_stop)\n\t\t\tjson_object_object_add(json_data, \"script_stop\",\n\t\t\t\tjson_object_new_string(cmd_str(vrrp->script_stop)));\n\t\tif (vrrp->script)\n\t\t\tjson_object_object_add(json_data, \"script\",\n\t\t\t\tjson_object_new_string(cmd_str(vrrp->script)));\n\t\tif (vrrp->script_master_rx_lower_pri)\n\t\t\tjson_object_object_add(json_data, \"script_master_rx_lower_pri\",\n\t\t\t\tjson_object_new_string(cmd_str(vrrp->script_master_rx_lower_pri)));\n\t\tjson_object_object_add(json_data, \"smtp_alert\",\n\t\t\tjson_object_new_boolean(vrrp->smtp_alert));\n#ifdef _WITH_VRRP_AUTH_\n\t\tif (vrrp->auth_type) {\n\t\t\tjson_object_object_add(json_data, \"auth_type\",\n\t\t\t\tjson_object_new_int(vrrp->auth_type));\n\n\t\t\tif (vrrp->auth_type != VRRP_AUTH_AH) {\n\t\t\t\tchar auth_data[sizeof(vrrp->auth_data) + 1];\n\t\t\t\tmemcpy(auth_data, vrrp->auth_data, sizeof(vrrp->auth_data));\n\t\t\t\tauth_data[sizeof(vrrp->auth_data)] = '\\0';\n\t\t\t\tjson_object_object_add(json_data, \"auth_data\",\n\t\t\t\t\tjson_object_new_string(auth_data));\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tjson_object_object_add(json_data, \"auth_type\",\n\t\t\t\tjson_object_new_int(0));\n#endif\n\n\t\t// Dump stats to json\n\t\tjson_object_object_add(json_stats, \"advert_rcvd\",\n\t\t\tjson_object_new_int64((int64_t)vrrp->stats->advert_rcvd));\n\t\tjson_object_object_add(json_stats, \"advert_sent\",\n\t\t\tjson_object_new_int64(vrrp->stats->advert_sent));\n\t\tjson_object_object_add(json_stats, \"become_master\",\n\t\t\tjson_object_new_int64(vrrp->stats->become_master));\n\t\tjson_object_object_add(json_stats, \"release_master\",\n\t\t\tjson_object_new_int64(vrrp->stats->release_master));\n\t\tjson_object_object_add(json_stats, \"packet_len_err\",\n\t\t\tjson_object_new_int64((int64_t)vrrp->stats->packet_len_err));\n\t\tjson_object_object_add(json_stats, \"advert_interval_err\",\n\t\t\tjson_object_new_int64((int64_t)vrrp->stats->advert_interval_err));\n\t\tjson_object_object_add(json_stats, \"ip_ttl_err\",\n\t\t\tjson_object_new_int64((int64_t)vrrp->stats->ip_ttl_err));\n\t\tjson_object_object_add(json_stats, \"invalid_type_rcvd\",\n\t\t\tjson_object_new_int64((int64_t)vrrp->stats->invalid_type_rcvd));\n\t\tjson_object_object_add(json_stats, \"addr_list_err\",\n\t\t\tjson_object_new_int64((int64_t)vrrp->stats->addr_list_err));\n\t\tjson_object_object_add(json_stats, \"invalid_authtype\",\n\t\t\tjson_object_new_int64(vrrp->stats->invalid_authtype));\n#ifdef _WITH_VRRP_AUTH_\n\t\tjson_object_object_add(json_stats, \"authtype_mismatch\",\n\t\t\tjson_object_new_int64(vrrp->stats->authtype_mismatch));\n\t\tjson_object_object_add(json_stats, \"auth_failure\",\n\t\t\tjson_object_new_int64(vrrp->stats->auth_failure));\n#endif\n\t\tjson_object_object_add(json_stats, \"pri_zero_rcvd\",\n\t\t\tjson_object_new_int64((int64_t)vrrp->stats->pri_zero_rcvd));\n\t\tjson_object_object_add(json_stats, \"pri_zero_sent\",\n\t\t\tjson_object_new_int64((int64_t)vrrp->stats->pri_zero_sent));\n\n\t\t// Add both json_data and json_stats to main instance_json\n\t\tjson_object_object_add(instance_json, \"data\", json_data);\n\t\tjson_object_object_add(instance_json, \"stats\", json_stats);\n\n\t\t// Add instance_json to main array\n\t\tjson_object_array_add(array, instance_json);\n\n\t}\n\tfprintf(file, \"%s\", json_object_to_json_string(array));\n\tfclose(file);\n}\n", "/*\n * Soft:        Keepalived is a failover program for the LVS project\n *              <www.linuxvirtualserver.org>. It monitor & manipulate\n *              a loadbalanced server pool using multi-layer checks.\n *\n * Part:        Configuration file parser/reader. Place into the dynamic\n *              data structure representation the conf file representing\n *              the loadbalanced server pool.\n *\n * Author:      Alexandre Cassen, <acassen@linux-vs.org>\n *\n *              This program is distributed in the hope that it will be useful,\n *              but WITHOUT ANY WARRANTY; without even the implied warranty of\n *              MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n *              See the GNU General Public License for more details.\n *\n *              This program is free software; you can redistribute it and/or\n *              modify it under the terms of the GNU General Public License\n *              as published by the Free Software Foundation; either version\n *              2 of the License, or (at your option) any later version.\n *\n * Copyright (C) 2001-2017 Alexandre Cassen, <acassen@gmail.com>\n */\n\n#include \"config.h\"\n\n#include <unistd.h>\n#include <string.h>\n#include <stdint.h>\n#include <net/if_arp.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n//#include <unistd.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <net/if.h>\n\n#include \"vrrp_parser.h\"\n#include \"logger.h\"\n#include \"parser.h\"\n#include \"bitops.h\"\n#include \"utils.h\"\n\n#include \"main.h\"\n#include \"global_data.h\"\n#include \"global_parser.h\"\n\n#include \"vrrp_data.h\"\n#include \"vrrp_ipaddress.h\"\n#include \"vrrp_sync.h\"\n#include \"vrrp_track.h\"\n#ifdef _HAVE_VRRP_VMAC_\n#include \"vrrp_vmac.h\"\n#endif\n#include \"vrrp_static_track.h\"\n\n#ifdef _WITH_LVS_\n#include \"check_parser.h\"\n#endif\n#ifdef _WITH_BFD_\n#include \"bfd_parser.h\"\n#endif\n\n/* Used for initialising track files */\nstatic enum {\n\tTRACK_FILE_NO_INIT,\n\tTRACK_FILE_CREATE,\n\tTRACK_FILE_INIT,\n} track_file_init;\nstatic int track_file_init_value;\n\nstatic bool script_user_set;\nstatic bool remove_script;\n\n/* track groups for static items */\nstatic void\nstatic_track_group_handler(vector_t *strvec)\n{\n\telement e;\n\tstatic_track_group_t *tg;\n\tchar* gname;\n\n\tif (!strvec)\n\t\treturn;\n\n\tif (vector_count(strvec) != 2) {\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"track_group must have a name - skipping\");\n\t\tskip_block(true);\n\t\treturn;\n\t}\n\n\tgname = strvec_slot(strvec, 1);\n\n\t/* check group doesn't already exist */\n\tLIST_FOREACH(vrrp_data->static_track_groups, tg, e) {\n\t\tif (!strcmp(gname,tg->gname)) {\n\t\t\treport_config_error(CONFIG_GENERAL_ERROR, \"track_group %s already defined\", gname);\n\t\t\tskip_block(true);\n\t\t\treturn;\n\t\t}\n\t}\n\n\talloc_static_track_group(gname);\n}\n\nstatic void\nstatic_track_group_group_handler(vector_t *strvec)\n{\n\tstatic_track_group_t *tgroup = LIST_TAIL_DATA(vrrp_data->static_track_groups);\n\n\tif (tgroup->iname) {\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"Group list already specified for sync group %s\", tgroup->gname);\n\t\tskip_block(true);\n\t\treturn;\n\t}\n\n\ttgroup->iname = read_value_block(strvec);\n\n\tif (!tgroup->iname)\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"Warning - track group %s has empty group block\", tgroup->gname);\n}\n\n/* Static addresses handler */\nstatic void\nstatic_addresses_handler(vector_t *strvec)\n{\n\tglobal_data->have_vrrp_config = true;\n\n\tif (!strvec)\n\t\treturn;\n\n\talloc_value_block(alloc_saddress, vector_slot(strvec, 0));\n}\n\n#ifdef _HAVE_FIB_ROUTING_\n/* Static routes handler */\nstatic void\nstatic_routes_handler(vector_t *strvec)\n{\n\tglobal_data->have_vrrp_config = true;\n\n\tif (!strvec)\n\t\treturn;\n\n\talloc_value_block(alloc_sroute, vector_slot(strvec, 0));\n}\n\n/* Static rules handler */\nstatic void\nstatic_rules_handler(vector_t *strvec)\n{\n\tglobal_data->have_vrrp_config = true;\n\n\tif (!strvec)\n\t\treturn;\n\n\talloc_value_block(alloc_srule, vector_slot(strvec, 0));\n}\n#endif\n\n/* VRRP handlers */\nstatic void\nvrrp_sync_group_handler(vector_t *strvec)\n{\n\tlist l;\n\telement e;\n\tvrrp_sgroup_t *sg;\n\tchar* gname;\n\n\tif (!strvec)\n\t\treturn;\n\n\tif (vector_count(strvec) != 2) {\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"vrrp_sync_group must have a name - skipping\");\n\t\tskip_block(true);\n\t\treturn;\n\t}\n\n\tgname = strvec_slot(strvec, 1);\n\n\t/* check group doesn't already exist */\n\tif (!LIST_ISEMPTY(vrrp_data->vrrp_sync_group)) {\n\t\tl = vrrp_data->vrrp_sync_group;\n\t\tfor (e = LIST_HEAD(l); e; ELEMENT_NEXT(e)) {\n\t\t\tsg = ELEMENT_DATA(e);\n\t\t\tif (!strcmp(gname,sg->gname)) {\n\t\t\t\treport_config_error(CONFIG_GENERAL_ERROR, \"vrrp sync group %s already defined\", gname);\n\t\t\t\tskip_block(true);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\talloc_vrrp_sync_group(gname);\n}\n\nstatic void\nvrrp_group_handler(vector_t *strvec)\n{\n\tvrrp_sgroup_t *vgroup = LIST_TAIL_DATA(vrrp_data->vrrp_sync_group);\n\n\tif (vgroup->iname) {\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"Group list already specified for sync group %s\", vgroup->gname);\n\t\tskip_block(true);\n\t\treturn;\n\t}\n\n\tvgroup->iname = read_value_block(strvec);\n\n\tif (!vgroup->iname)\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"Warning - sync group %s has empty group block\", vgroup->gname);\n}\n\nstatic void\nvrrp_group_track_if_handler(vector_t *strvec)\n{\n\talloc_value_block(alloc_vrrp_group_track_if, vector_slot(strvec, 0));\n}\n\nstatic void\nvrrp_group_track_scr_handler(vector_t *strvec)\n{\n\talloc_value_block(alloc_vrrp_group_track_script, vector_slot(strvec, 0));\n}\n\nstatic void\nvrrp_group_track_file_handler(vector_t *strvec)\n{\n\talloc_value_block(alloc_vrrp_group_track_file, vector_slot(strvec, 0));\n}\n\n#if defined _WITH_BFD_\nstatic void\nvrrp_group_track_bfd_handler(vector_t *strvec)\n{\n\talloc_value_block(alloc_vrrp_group_track_bfd, vector_slot(strvec, 0));\n}\n#endif\n\nstatic inline notify_script_t*\nset_vrrp_notify_script(__attribute__((unused)) vector_t *strvec, int extra_params)\n{\n\treturn notify_script_init(extra_params, \"notify\");\n}\n\nstatic void\nvrrp_gnotify_backup_handler(vector_t *strvec)\n{\n\tvrrp_sgroup_t *vgroup = LIST_TAIL_DATA(vrrp_data->vrrp_sync_group);\n\tif (vgroup->script_backup) {\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"vrrp group %s: notify_backup script already specified - ignoring %s\", vgroup->gname, FMT_STR_VSLOT(strvec,1));\n\t\treturn;\n\t}\n\tvgroup->script_backup = set_vrrp_notify_script(strvec, 0);\n\tvgroup->notify_exec = true;\n}\nstatic void\nvrrp_gnotify_master_handler(vector_t *strvec)\n{\n\tvrrp_sgroup_t *vgroup = LIST_TAIL_DATA(vrrp_data->vrrp_sync_group);\n\tif (vgroup->script_master) {\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"vrrp group %s: notify_master script already specified - ignoring %s\", vgroup->gname, FMT_STR_VSLOT(strvec,1));\n\t\treturn;\n\t}\n\tvgroup->script_master = set_vrrp_notify_script(strvec, 0);\n\tvgroup->notify_exec = true;\n}\nstatic void\nvrrp_gnotify_fault_handler(vector_t *strvec)\n{\n\tvrrp_sgroup_t *vgroup = LIST_TAIL_DATA(vrrp_data->vrrp_sync_group);\n\tif (vgroup->script_fault) {\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"vrrp group %s: notify_fault script already specified - ignoring %s\", vgroup->gname, FMT_STR_VSLOT(strvec,1));\n\t\treturn;\n\t}\n\tvgroup->script_fault = set_vrrp_notify_script(strvec, 0);\n\tvgroup->notify_exec = true;\n}\nstatic void\nvrrp_gnotify_stop_handler(vector_t *strvec)\n{\n\tvrrp_sgroup_t *vgroup = LIST_TAIL_DATA(vrrp_data->vrrp_sync_group);\n\tif (vgroup->script_stop) {\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"vrrp group %s: notify_stop script already specified - ignoring %s\", vgroup->gname, FMT_STR_VSLOT(strvec,1));\n\t\treturn;\n\t}\n\tvgroup->script_stop = set_vrrp_notify_script(strvec, 0);\n\tvgroup->notify_exec = true;\n}\nstatic void\nvrrp_gnotify_handler(vector_t *strvec)\n{\n\tvrrp_sgroup_t *vgroup = LIST_TAIL_DATA(vrrp_data->vrrp_sync_group);\n\tif (vgroup->script) {\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"vrrp group %s: notify script already specified - ignoring %s\", vgroup->gname, FMT_STR_VSLOT(strvec,1));\n\t\treturn;\n\t}\n\tvgroup->script = set_vrrp_notify_script(strvec, 4);\n\tvgroup->notify_exec = true;\n}\nstatic void\nvrrp_gsmtp_handler(__attribute__((unused)) vector_t *strvec)\n{\n\tvrrp_sgroup_t *vgroup = LIST_TAIL_DATA(vrrp_data->vrrp_sync_group);\n\tint res = true;\n\n\tif (vector_size(strvec) >= 2) {\n\t\tres = check_true_false(strvec_slot(strvec, 1));\n\t\tif (res == -1) {\n\t\t\treport_config_error(CONFIG_GENERAL_ERROR, \"Invalid vrrp_group smtp_alert parameter %s\", FMT_STR_VSLOT(strvec, 1));\n\t\t\treturn;\n\t\t}\n\t}\n\tvgroup->smtp_alert = res;\n}\nstatic void\nvrrp_gglobal_tracking_handler(__attribute__((unused)) vector_t *strvec)\n{\n\tvrrp_sgroup_t *vgroup = LIST_TAIL_DATA(vrrp_data->vrrp_sync_group);\n\n\treport_config_error(CONFIG_GENERAL_ERROR, \"(%s) global_tracking is deprecated. Use track_interface/script/file on the sync group\", vgroup->gname);\n\tvgroup->sgroup_tracking_weight = true;\n}\nstatic void\nvrrp_sg_tracking_weight_handler(__attribute__((unused)) vector_t *strvec)\n{\n\tvrrp_sgroup_t *vgroup = LIST_TAIL_DATA(vrrp_data->vrrp_sync_group);\n\tvgroup->sgroup_tracking_weight = true;\n}\nstatic void\nvrrp_handler(vector_t *strvec)\n{\n\tlist l;\n\telement e;\n\tvrrp_t *vrrp;\n\tchar *iname;\n\n\tglobal_data->have_vrrp_config = true;\n\n\tif (!strvec)\n\t\treturn;\n\n\tif (vector_count(strvec) != 2) {\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"vrrp_instance must have a name\");\n\t\tskip_block(true);\n\t\treturn;\n\t}\n\n\tiname = strvec_slot(strvec,1);\n\n\t/* Make sure the vrrp instance doesn't already exist */\n\tif (!LIST_ISEMPTY(vrrp_data->vrrp)) {\n\t\tl = vrrp_data->vrrp;\n\t\tfor (e = LIST_HEAD(l); e; ELEMENT_NEXT(e)) {\n\t\t\tvrrp = ELEMENT_DATA(e);\n\t\t\tif (!strcmp(iname,vrrp->iname)) {\n\t\t\t\treport_config_error(CONFIG_GENERAL_ERROR, \"vrrp instance %s already defined\", iname );\n\t\t\t\tskip_block(true);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\talloc_vrrp(iname);\n}\n#ifdef _HAVE_VRRP_VMAC_\nstatic void\nvrrp_vmac_handler(vector_t *strvec)\n{\n\tvrrp_t *vrrp = LIST_TAIL_DATA(vrrp_data->vrrp);\n\tinterface_t *ifp;\n\n\t__set_bit(VRRP_VMAC_BIT, &vrrp->vmac_flags);\n\n\tif (vector_size(strvec) >= 2) {\n\t\tif (strlen(strvec_slot(strvec, 1)) >= IFNAMSIZ) {\n\t\t\treport_config_error(CONFIG_GENERAL_ERROR, \"VMAC interface name '%s' too long - ignoring\", FMT_STR_VSLOT(strvec, 1));\n\t\t\treturn;\n\t\t}\n\n\t\tstrcpy(vrrp->vmac_ifname, strvec_slot(strvec, 1));\n\n\t\t/* Check if the interface exists and is a macvlan we can use */\n\t\tif ((ifp = if_get_by_ifname(vrrp->vmac_ifname, IF_NO_CREATE)) &&\n\t\t    ifp->vmac_type != MACVLAN_MODE_PRIVATE) {\n\t\t\treport_config_error(CONFIG_GENERAL_ERROR, \"(%s) interface %s already exists and is not a private macvlan; ignoring vmac if_name\", vrrp->iname, vrrp->vmac_ifname);\n\t\t\tvrrp->vmac_ifname[0] = '\\0';\n\t\t}\n\t}\n}\nstatic void\nvrrp_vmac_xmit_base_handler(__attribute__((unused)) vector_t *strvec)\n{\n\tvrrp_t *vrrp = LIST_TAIL_DATA(vrrp_data->vrrp);\n\n\t__set_bit(VRRP_VMAC_XMITBASE_BIT, &vrrp->vmac_flags);\n}\n#endif\nstatic void\nvrrp_unicast_peer_handler(vector_t *strvec)\n{\n\talloc_value_block(alloc_vrrp_unicast_peer, vector_slot(strvec, 0));\n}\n#ifdef _WITH_UNICAST_CHKSUM_COMPAT_\nstatic void\nvrrp_unicast_chksum_handler(vector_t *strvec)\n{\n\tvrrp_t *vrrp = LIST_TAIL_DATA(vrrp_data->vrrp);\n\n\tif (vector_size(strvec) >= 2) {\n\t\tif (!strcmp(strvec_slot(strvec, 1), \"never\"))\n\t\t\tvrrp->unicast_chksum_compat = CHKSUM_COMPATIBILITY_NEVER;\n\t\telse\n\t\t\treport_config_error(CONFIG_GENERAL_ERROR, \"(%s) Unknown old_unicast_chksum mode %s - ignoring\", vrrp->iname, FMT_STR_VSLOT(strvec, 1));\n\t}\n\telse\n\t\tvrrp->unicast_chksum_compat = CHKSUM_COMPATIBILITY_CONFIG;\n}\n#endif\nstatic void\nvrrp_native_ipv6_handler(__attribute__((unused)) vector_t *strvec)\n{\n\tvrrp_t *vrrp = LIST_TAIL_DATA(vrrp_data->vrrp);\n\n\tif (vrrp->family == AF_INET) {\n\t\treport_config_error(CONFIG_GENERAL_ERROR,\"(%s) Cannot specify native_ipv6 with IPv4 addresses\", vrrp->iname);\n\t\treturn;\n\t}\n\n\tvrrp->family = AF_INET6;\n\tvrrp->version = VRRP_VERSION_3;\n}\nstatic void\nvrrp_state_handler(vector_t *strvec)\n{\n\tchar *str = strvec_slot(strvec, 1);\n\tvrrp_t *vrrp = LIST_TAIL_DATA(vrrp_data->vrrp);\n\n\tif (!strcmp(str, \"MASTER\"))\n\t\tvrrp->wantstate = VRRP_STATE_MAST;\n\telse if (!strcmp(str, \"BACKUP\"))\n\t{\n\t\tif (vrrp->wantstate == VRRP_STATE_MAST)\n\t\t\treport_config_error(CONFIG_GENERAL_ERROR, \"(%s) state previously set as MASTER - ignoring BACKUP\", vrrp->iname);\n\t\telse\n\t\t\tvrrp->wantstate = VRRP_STATE_BACK;\n\t}\n\telse {\n\t\treport_config_error(CONFIG_GENERAL_ERROR,\"(%s) unknown state '%s', defaulting to BACKUP\", vrrp->iname, str);\n\t\tvrrp->wantstate = VRRP_STATE_BACK;\n\t}\n}\nstatic void\nvrrp_int_handler(vector_t *strvec)\n{\n\tvrrp_t *vrrp = LIST_TAIL_DATA(vrrp_data->vrrp);\n\tchar *name = strvec_slot(strvec, 1);\n\n\tif (strlen(name) >= IFNAMSIZ) {\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"Interface name '%s' too long - ignoring\", name);\n\t\treturn;\n\t}\n\n\tvrrp->ifp = if_get_by_ifname(name, IF_CREATE_IF_DYNAMIC);\n\tif (!vrrp->ifp)\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"WARNING - interface %s for vrrp_instance %s doesn't exist\", name, vrrp->iname);\n\telse if (vrrp->ifp->hw_type == ARPHRD_LOOPBACK) {\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"(%s) cannot use a loopback interface (%s) for vrrp - ignoring\", vrrp->iname, vrrp->ifp->ifname);\n\t\tvrrp->ifp = NULL;\n\t}\n\n#ifdef _HAVE_VRRP_VMAC_\n\tvrrp->configured_ifp = vrrp->ifp;\n#endif\n}\nstatic void\nvrrp_linkbeat_handler(__attribute__((unused)) vector_t *strvec)\n{\n\tvrrp_t *vrrp = LIST_TAIL_DATA(vrrp_data->vrrp);\n\n\tvrrp->linkbeat_use_polling = true;\n}\nstatic void\nvrrp_track_if_handler(vector_t *strvec)\n{\n\talloc_value_block(alloc_vrrp_track_if, vector_slot(strvec, 0));\n}\nstatic void\nvrrp_track_scr_handler(vector_t *strvec)\n{\n\talloc_value_block(alloc_vrrp_track_script, vector_slot(strvec, 0));\n}\nstatic void\nvrrp_track_file_handler(vector_t *strvec)\n{\n\talloc_value_block(alloc_vrrp_track_file, vector_slot(strvec, 0));\n}\nstatic void\nvrrp_dont_track_handler(__attribute__((unused)) vector_t *strvec)\n{\n\tvrrp_t *vrrp = LIST_TAIL_DATA(vrrp_data->vrrp);\n\tvrrp->dont_track_primary = true;\n}\n#ifdef _WITH_BFD_\nstatic void\nvrrp_track_bfd_handler(vector_t *strvec)\n{\n\talloc_value_block(alloc_vrrp_track_bfd, vector_slot(strvec, 0));\n}\n#endif\nstatic void\nvrrp_srcip_handler(vector_t *strvec)\n{\n\tvrrp_t *vrrp = LIST_TAIL_DATA(vrrp_data->vrrp);\n\tstruct sockaddr_storage *saddr = &vrrp->saddr;\n\n\tif (inet_stosockaddr(strvec_slot(strvec, 1), NULL, saddr)) {\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"Configuration error: VRRP instance[%s] malformed\"\n\t\t\t\t     \" src address[%s]. Skipping...\"\n\t\t\t\t   , vrrp->iname, FMT_STR_VSLOT(strvec, 1));\n\t\treturn;\n\t}\n\n\tvrrp->saddr_from_config = true;\n\n\tif (vrrp->family == AF_UNSPEC)\n\t\tvrrp->family = saddr->ss_family;\n\telse if (saddr->ss_family != vrrp->family) {\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"Configuration error: VRRP instance[%s] and src address\"\n\t\t\t\t     \"[%s] MUST be of the same family !!! Skipping...\"\n\t\t\t\t   , vrrp->iname, FMT_STR_VSLOT(strvec, 1));\n\t\tsaddr->ss_family = AF_UNSPEC;\n\t\tvrrp->saddr_from_config = false;\n\t}\n}\nstatic void\nvrrp_track_srcip_handler(__attribute__((unused)) vector_t *strvec)\n{\n\tvrrp_t *vrrp = LIST_TAIL_DATA(vrrp_data->vrrp);\n\n\tvrrp->track_saddr = true;\n}\nstatic void\nvrrp_vrid_handler(vector_t *strvec)\n{\n\tvrrp_t *vrrp = LIST_TAIL_DATA(vrrp_data->vrrp);\n\tunsigned vrid;\n\n\tif (!read_unsigned_strvec(strvec, 1, &vrid, 1, 255, false)) {\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"(%s): VRID '%s' not valid - must be between 1 & 255\", vrrp->iname, FMT_STR_VSLOT(strvec, 1));\n\t\treturn;\n\t}\n\n\tvrrp->vrid = (uint8_t)vrid;\n}\nstatic void\nvrrp_prio_handler(vector_t *strvec)\n{\n\tvrrp_t *vrrp = LIST_TAIL_DATA(vrrp_data->vrrp);\n\tunsigned base_priority;\n\n\tif (!read_unsigned_strvec(strvec, 1, &base_priority, 1, VRRP_PRIO_OWNER, false)) {\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"(%s) Priority not valid! must be between 1 & %d. Using default %d\", vrrp->iname, VRRP_PRIO_OWNER, VRRP_PRIO_DFL);\n\t\tvrrp->base_priority = VRRP_PRIO_DFL;\n\t}\n\telse\n\t\tvrrp->base_priority = (uint8_t)base_priority;\n}\nstatic void\nvrrp_adv_handler(vector_t *strvec)\n{\n\tvrrp_t *vrrp = LIST_TAIL_DATA(vrrp_data->vrrp);\n\tdouble adver_int;\n\tbool res;\n\n\tres = read_double_strvec(strvec, 1, &adver_int, 0.01, 255.0, true);\n\n\t/* Simple check - just positive */\n\tif (!res || adver_int <= 0)\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"(%s) Advert interval (%s) not valid! Must be > 0 - ignoring\", vrrp->iname, FMT_STR_VSLOT(strvec, 1));\n\telse\n\t\tvrrp->adver_int = (unsigned)(adver_int * TIMER_HZ);\n}\nstatic void\nvrrp_debug_handler(vector_t *strvec)\n{\n\tvrrp_t *vrrp = LIST_TAIL_DATA(vrrp_data->vrrp);\n\tunsigned debug;\n\n\tif (!read_unsigned_strvec(strvec, 1, &debug, 0, 4, true))\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"(%s) Debug value '%s' not valid; must be between 0-4\", vrrp->iname, FMT_STR_VSLOT(strvec, 1));\n\telse\n\t\tvrrp->debug = debug;\n}\nstatic void\nvrrp_skip_check_adv_addr_handler(vector_t *strvec)\n{\n\tvrrp_t *vrrp = LIST_TAIL_DATA(vrrp_data->vrrp);\n\tint res;\n\n\tif (vector_size(strvec) >= 2) {\n\t\tres = check_true_false(strvec_slot(strvec, 1));\n\t\tif (res >= 0)\n\t\t\tvrrp->skip_check_adv_addr = (bool)res;\n\t\telse\n\t\t\treport_config_error(CONFIG_GENERAL_ERROR, \"(%s) invalid skip_check_adv_addr %s specified\", vrrp->iname, FMT_STR_VSLOT(strvec, 1));\n\t} else {\n\t\t/* Defaults to true */\n\t\tvrrp->skip_check_adv_addr = true;\n\t}\n}\nstatic void\nvrrp_strict_mode_handler(vector_t *strvec)\n{\n\tint res;\n\n\tvrrp_t *vrrp = LIST_TAIL_DATA(vrrp_data->vrrp);\n\tif (vector_size(strvec) >= 2) {\n\t\tres = check_true_false(strvec_slot(strvec, 1));\n\t\tif (res >= 0)\n\t\t\tvrrp->strict_mode = (bool)res;\n\t\telse\n\t\t\treport_config_error(CONFIG_GENERAL_ERROR, \"(%s) invalid strict_mode %s specified\", vrrp->iname, FMT_STR_VSLOT(strvec, 1));\n\t} else {\n\t\t/* Defaults to true */\n\t\tvrrp->strict_mode = true;\n\t}\n}\nstatic void\nvrrp_nopreempt_handler(__attribute__((unused)) vector_t *strvec)\n{\n\tvrrp_t *vrrp = LIST_TAIL_DATA(vrrp_data->vrrp);\n\tvrrp->nopreempt = 1;\n}\nstatic void\t/* backwards compatibility */\nvrrp_preempt_handler(__attribute__((unused)) vector_t *strvec)\n{\n\tvrrp_t *vrrp = LIST_TAIL_DATA(vrrp_data->vrrp);\n\tvrrp->nopreempt = 0;\n}\nstatic void\nvrrp_preempt_delay_handler(vector_t *strvec)\n{\n\tvrrp_t *vrrp = LIST_TAIL_DATA(vrrp_data->vrrp);\n\tdouble preempt_delay;\n\n\tif (!read_double_strvec(strvec, 1, &preempt_delay, 0, TIMER_MAX_SEC, true)) {\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"(%s) Preempt_delay not valid! must be between 0-%d\", vrrp->iname, TIMER_MAX_SEC);\n\t\tvrrp->preempt_delay = 0;\n\t}\n\telse\n\t\tvrrp->preempt_delay = (unsigned long)(preempt_delay * TIMER_HZ);\n}\nstatic void\nvrrp_notify_backup_handler(vector_t *strvec)\n{\n\tvrrp_t *vrrp = LIST_TAIL_DATA(vrrp_data->vrrp);\n\tif (vrrp->script_backup) {\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"(%s) notify_backup script already specified - ignoring %s\", vrrp->iname, FMT_STR_VSLOT(strvec,1));\n\t\treturn;\n\t}\n\tvrrp->script_backup = set_vrrp_notify_script(strvec, 0);\n\tvrrp->notify_exec = true;\n}\nstatic void\nvrrp_notify_master_handler(vector_t *strvec)\n{\n\tvrrp_t *vrrp = LIST_TAIL_DATA(vrrp_data->vrrp);\n\tif (vrrp->script_master) {\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"(%s) notify_master script already specified - ignoring %s\", vrrp->iname, FMT_STR_VSLOT(strvec,1));\n\t\treturn;\n\t}\n\tvrrp->script_master = set_vrrp_notify_script(strvec, 0);\n\tvrrp->notify_exec = true;\n}\nstatic void\nvrrp_notify_fault_handler(vector_t *strvec)\n{\n\tvrrp_t *vrrp = LIST_TAIL_DATA(vrrp_data->vrrp);\n\tif (vrrp->script_fault) {\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"(%s) notify_fault script already specified - ignoring %s\", vrrp->iname, FMT_STR_VSLOT(strvec,1));\n\t\treturn;\n\t}\n\tvrrp->script_fault = set_vrrp_notify_script(strvec, 0);\n\tvrrp->notify_exec = true;\n}\nstatic void\nvrrp_notify_stop_handler(vector_t *strvec)\n{\n\tvrrp_t *vrrp = LIST_TAIL_DATA(vrrp_data->vrrp);\n\tif (vrrp->script_stop) {\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"(%s) notify_stop script already specified - ignoring %s\", vrrp->iname, FMT_STR_VSLOT(strvec,1));\n\t\treturn;\n\t}\n\tvrrp->script_stop = set_vrrp_notify_script(strvec, 0);\n\tvrrp->notify_exec = true;\n}\nstatic void\nvrrp_notify_handler(vector_t *strvec)\n{\n\tvrrp_t *vrrp = LIST_TAIL_DATA(vrrp_data->vrrp);\n\tif (vrrp->script) {\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"(%s) notify script already specified - ignoring %s\", vrrp->iname, FMT_STR_VSLOT(strvec,1));\n\t\treturn;\n\t}\n\tvrrp->script = set_vrrp_notify_script(strvec, 4);\n\tvrrp->notify_exec = true;\n}\nstatic void\nvrrp_notify_master_rx_lower_pri(vector_t *strvec)\n{\n\tvrrp_t *vrrp = LIST_TAIL_DATA(vrrp_data->vrrp);\n\tif (vrrp->script_master_rx_lower_pri) {\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"(%s) notify_master_rx_lower_pri script already specified - ignoring %s\", vrrp->iname, FMT_STR_VSLOT(strvec,1));\n\t\treturn;\n\t}\n\tvrrp->script_master_rx_lower_pri = set_vrrp_notify_script(strvec, 0);\n\tvrrp->notify_exec = true;\n}\nstatic void\nvrrp_smtp_handler(__attribute__((unused)) vector_t *strvec)\n{\n\tvrrp_t *vrrp = LIST_TAIL_DATA(vrrp_data->vrrp);\n\tint res = true;\n\n\tif (vector_size(strvec) >= 2) {\n\t\tres = check_true_false(strvec_slot(strvec, 1));\n\t\tif (res == -1) {\n\t\t\treport_config_error(CONFIG_GENERAL_ERROR, \"Invalid vrrp_instance smtp_alert parameter %s\", FMT_STR_VSLOT(strvec, 1));\n\t\t\treturn;\n\t\t}\n\t}\n\tvrrp->smtp_alert = res;\n}\n#ifdef _WITH_LVS_\nstatic void\nvrrp_lvs_syncd_handler(vector_t *strvec)\n{\n\tvrrp_t *vrrp = LIST_TAIL_DATA(vrrp_data->vrrp);\n\n\treport_config_error(CONFIG_GENERAL_ERROR, \"(%s) Specifying lvs_sync_daemon_interface against a vrrp is deprecated.\", vrrp->iname);  /* Deprecated after v1.2.19 */\n\treport_config_error(CONFIG_GENERAL_ERROR, \"      %*sPlease use global lvs_sync_daemon\", (int)strlen(vrrp->iname) - 2, \"\");\n\n\tif (global_data->lvs_syncd.ifname) {\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"(%s) lvs_sync_daemon_interface has already been specified as %s - ignoring\", vrrp->iname, global_data->lvs_syncd.ifname);\n\t\treturn;\n\t}\n\n\tglobal_data->lvs_syncd.ifname = set_value(strvec);\n\tglobal_data->lvs_syncd.vrrp = vrrp;\n}\n#endif\nstatic void\nvrrp_garp_delay_handler(vector_t *strvec)\n{\n\tvrrp_t *vrrp = LIST_TAIL_DATA(vrrp_data->vrrp);\n\tunsigned delay;\n\n\tif (!read_unsigned_strvec(strvec, 1, &delay, 0, UINT_MAX / TIMER_HZ, true)) {\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"(%s): garp_master_delay '%s' invalid - ignoring\", vrrp->iname, FMT_STR_VSLOT(strvec, 1));\n\t\treturn;\n\t}\n\n\tvrrp->garp_delay = delay * TIMER_HZ;\n}\nstatic void\nvrrp_garp_refresh_handler(vector_t *strvec)\n{\n\tvrrp_t *vrrp = LIST_TAIL_DATA(vrrp_data->vrrp);\n\tunsigned refresh;\n\n\tif (!read_unsigned_strvec(strvec, 1, &refresh, 0, UINT_MAX, true)) {\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"(%s): Invalid garp_master_refresh '%s' - ignoring\", vrrp->iname, FMT_STR_VSLOT(strvec, 1));\n\t\tvrrp->garp_refresh.tv_sec = 0;\n\t}\n\telse\n\t\tvrrp->garp_refresh.tv_sec = refresh;\n\tvrrp->garp_refresh.tv_usec = 0;\n}\nstatic void\nvrrp_garp_rep_handler(vector_t *strvec)\n{\n\tvrrp_t *vrrp = LIST_TAIL_DATA(vrrp_data->vrrp);\n\tunsigned repeats;\n\n\t/* The min value should be 1, but allow 0 to maintain backward compatibility\n\t * with pre v2.0.7 */\n\tif (!read_unsigned_strvec(strvec, 1, &repeats, 0, UINT_MAX, true)) {\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"(%s): garp_master_repeat '%s' invalid - ignoring\", vrrp->iname, FMT_STR_VSLOT(strvec, 1));\n\t\treturn;\n\t}\n\n\tif (repeats == 0) {\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"(%s): garp_master_repeat must be greater than 0, setting to 1\", vrrp->iname);\n\t\trepeats = 1;\n\t}\n\n\tvrrp->garp_rep = repeats;\n}\nstatic void\nvrrp_garp_refresh_rep_handler(vector_t *strvec)\n{\n\tvrrp_t *vrrp = LIST_TAIL_DATA(vrrp_data->vrrp);\n\tunsigned repeats;\n\n\t/* The min value should be 1, but allow 0 to maintain backward compatibility\n\t * with pre v2.0.7 */\n\tif (!read_unsigned_strvec(strvec, 1, &repeats, 0, UINT_MAX, true)) {\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"(%s): garp_master_refresh_repeat '%s' invalid - ignoring\", vrrp->iname, FMT_STR_VSLOT(strvec, 1));\n\t\treturn;\n\t}\n\n\tif (repeats == 0) {\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"(%s): garp_master_refresh_repeat must be greater than 0, setting to 1\", vrrp->iname);\n\t\trepeats = 1;\n\t}\n\n\tvrrp->garp_refresh_rep = repeats;\n}\n\nstatic void\nvrrp_garp_lower_prio_delay_handler(vector_t *strvec)\n{\n\tvrrp_t *vrrp = LIST_TAIL_DATA(vrrp_data->vrrp);\n\tunsigned delay;\n\n\tif (!read_unsigned_strvec(strvec, 1, &delay, 0, UINT_MAX / TIMER_HZ, true)) {\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"(%s): garp_lower_prio_delay '%s' invalid - ignoring\", vrrp->iname, FMT_STR_VSLOT(strvec, 1));\n\t\treturn;\n\t}\n\n\tvrrp->garp_lower_prio_delay = delay * TIMER_HZ;\n}\nstatic void\nvrrp_garp_lower_prio_rep_handler(vector_t *strvec)\n{\n\tvrrp_t *vrrp = LIST_TAIL_DATA(vrrp_data->vrrp);\n\tunsigned garp_lower_prio_rep;\n\n\tif (!read_unsigned_strvec(strvec, 1, &garp_lower_prio_rep, 0, INT_MAX, true)) {\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"(%s): Invalid garp_lower_prio_repeat '%s'\", vrrp->iname, FMT_STR_VSLOT(strvec, 1));\n\t\treturn;\n\t}\n\n\tvrrp->garp_lower_prio_rep = garp_lower_prio_rep;\n}\nstatic void\nvrrp_lower_prio_no_advert_handler(vector_t *strvec)\n{\n\tvrrp_t *vrrp = LIST_TAIL_DATA(vrrp_data->vrrp);\n\tint res;\n\n\tif (vector_size(strvec) >= 2) {\n\t\tres = check_true_false(strvec_slot(strvec, 1));\n\t\tif (res >= 0)\n\t\t\tvrrp->lower_prio_no_advert = (unsigned)res;\n\t\telse\n\t\t\treport_config_error(CONFIG_GENERAL_ERROR, \"(%s) invalid lower_prio_no_advert %s specified\", vrrp->iname, FMT_STR_VSLOT(strvec, 1));\n\t} else {\n\t\t/* Defaults to true */\n\t\tvrrp->lower_prio_no_advert = true;\n\t}\n}\n\nstatic void\nvrrp_higher_prio_send_advert_handler(vector_t *strvec)\n{\n\tint res;\n\tvrrp_t *vrrp = LIST_TAIL_DATA(vrrp_data->vrrp);\n\n\tif (vector_size(strvec) >= 2) {\n\t\tres = check_true_false(strvec_slot(strvec, 1));\n\t\tif (res >= 0)\n\t\t\tvrrp->higher_prio_send_advert = (unsigned)res;\n\t\telse\n\t\t\treport_config_error(CONFIG_GENERAL_ERROR, \"(%s) invalid higher_prio_send_advert %s specified\", vrrp->iname, FMT_STR_VSLOT(strvec, 1));\n\t} else {\n\t\t/* Defaults to true */\n\t\tvrrp->higher_prio_send_advert = true;\n\t}\n}\n\n\nstatic void\nkernel_rx_buf_size_handler(vector_t *strvec)\n{\n\tvrrp_t *vrrp = LIST_TAIL_DATA(vrrp_data->vrrp);\n\tunsigned rx_buf_size;\n\n\tif (vector_size(strvec) == 2 &&\n\t    read_unsigned_strvec(strvec, 1, &rx_buf_size, 0, UINT_MAX, false)) {\n\t\tvrrp->kernel_rx_buf_size = rx_buf_size;\n\t\treturn;\n\t}\n\n\treport_config_error(CONFIG_GENERAL_ERROR, \"(%s) invalid kernel_rx_buf_size specified\", vrrp->iname);\n}\n\n#if defined _WITH_VRRP_AUTH_\nstatic void\nvrrp_auth_type_handler(vector_t *strvec)\n{\n\tvrrp_t *vrrp = LIST_TAIL_DATA(vrrp_data->vrrp);\n\tchar *str = strvec_slot(strvec, 1);\n\n\tif (!strcmp(str, \"AH\"))\n\t\tvrrp->auth_type = VRRP_AUTH_AH;\n\telse if (!strcmp(str, \"PASS\"))\n\t\tvrrp->auth_type = VRRP_AUTH_PASS;\n\telse\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"(%s) unknown authentication type '%s'\", vrrp->iname, str);\n}\nstatic void\nvrrp_auth_pass_handler(vector_t *strvec)\n{\n\tvrrp_t *vrrp = LIST_TAIL_DATA(vrrp_data->vrrp);\n\tchar *str = strvec_slot(strvec, 1);\n\tsize_t max_size = sizeof (vrrp->auth_data);\n\tsize_t str_len = strlen(str);\n\n\tif (str_len > max_size) {\n\t\tstr_len = max_size;\n\t\treport_config_error(CONFIG_GENERAL_ERROR,\n\t\t\t    \"Truncating auth_pass to %zu characters\", max_size);\n\t}\n\n\tmemset(vrrp->auth_data, 0, max_size);\n\tmemcpy(vrrp->auth_data, str, str_len);\n}\n#endif\nstatic void\nvrrp_vip_handler(vector_t *strvec)\n{\n\talloc_value_block(alloc_vrrp_vip, vector_slot(strvec, 0));\n}\nstatic void\nvrrp_evip_handler(vector_t *strvec)\n{\n\talloc_value_block(alloc_vrrp_evip, vector_slot(strvec, 0));\n}\nstatic void\nvrrp_promote_secondaries_handler(__attribute__((unused)) vector_t *strvec)\n{\n\tvrrp_t *vrrp = LIST_TAIL_DATA(vrrp_data->vrrp);\n\n\tvrrp->promote_secondaries = true;\n}\n#ifdef _HAVE_FIB_ROUTING_\nstatic void\nvrrp_vroutes_handler(vector_t *strvec)\n{\n\talloc_value_block(alloc_vrrp_vroute, vector_slot(strvec, 0));\n}\nstatic void\nvrrp_vrules_handler(vector_t *strvec)\n{\n\talloc_value_block(alloc_vrrp_vrule, vector_slot(strvec, 0));\n}\n#endif\nstatic void\nvrrp_script_handler(vector_t *strvec)\n{\n\tif (!strvec)\n\t\treturn;\n\n\talloc_vrrp_script(strvec_slot(strvec, 1));\n\tscript_user_set = false;\n\tremove_script = false;\n}\nstatic void\nvrrp_vscript_script_handler(__attribute__((unused)) vector_t *strvec)\n{\n\tvrrp_script_t *vscript = LIST_TAIL_DATA(vrrp_data->vrrp_script);\n\tvector_t *strvec_qe;\n\n\t/* We need to allow quoted and escaped strings for the script and parameters */\n\tstrvec_qe = alloc_strvec_quoted_escaped(NULL);\n\n\tset_script_params_array(strvec_qe, &vscript->script, 0);\n\tfree_strvec(strvec_qe);\n}\nstatic void\nvrrp_vscript_interval_handler(vector_t *strvec)\n{\n\tvrrp_script_t *vscript = LIST_TAIL_DATA(vrrp_data->vrrp_script);\n\tunsigned interval;\n\n\t/* The min value should be 1, but allow 0 to maintain backward compatibility\n\t * with pre v2.0.7 */\n\tif (!read_unsigned_strvec(strvec, 1, &interval, 0, UINT_MAX / TIMER_HZ, true)) {\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"(%s): vrrp script interval '%s' must be between 1 and %u - ignoring\", vscript->sname, FMT_STR_VSLOT(strvec, 1), UINT_MAX / TIMER_HZ);\n\t\treturn;\n\t}\n\n\tif (interval == 0) {\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"(%s): vrrp script interval must be greater than 0, setting to 1\", vscript->sname);\n\t\tinterval = 1;\n\t}\n\n\tvscript->interval = interval * TIMER_HZ;\n}\nstatic void\nvrrp_vscript_timeout_handler(vector_t *strvec)\n{\n\tvrrp_script_t *vscript = LIST_TAIL_DATA(vrrp_data->vrrp_script);\n\tunsigned timeout;\n\n\t/* The min value should be 1, but allow 0 to maintain backward compatibility\n\t * with pre v2.0.7 */\n\tif (!read_unsigned_strvec(strvec, 1, &timeout, 0, UINT_MAX / TIMER_HZ, true)) {\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"(%s): vrrp script timeout '%s' invalid - ignoring\", vscript->sname, FMT_STR_VSLOT(strvec, 1));\n\t\treturn;\n\t}\n\n\tif (timeout == 0) {\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"(%s): vrrp script timeout must be greater than 0, setting to 1\", vscript->sname);\n\t\ttimeout = 1;\n\t}\n\n\tvscript->timeout = timeout * TIMER_HZ;\n}\nstatic void\nvrrp_vscript_weight_handler(vector_t *strvec)\n{\n\tvrrp_script_t *vscript = LIST_TAIL_DATA(vrrp_data->vrrp_script);\n\tint weight;\n\n\tif (!read_int_strvec(strvec, 1, &weight, -253, 253, true))\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"vrrp_script %s weight %s must be in [-253, 253]\", vscript->sname, FMT_STR_VSLOT(strvec, 1));\n\tvscript->weight = weight;\n}\nstatic void\nvrrp_vscript_rise_handler(vector_t *strvec)\n{\n\tvrrp_script_t *vscript = LIST_TAIL_DATA(vrrp_data->vrrp_script);\n\tunsigned rise;\n\n\tif (!read_unsigned_strvec(strvec, 1, &rise, 1, INT_MAX, true)) {\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"(%s): vrrp script rise value '%s' invalid, defaulting to 1\", vscript->sname, FMT_STR_VSLOT(strvec, 1));\n\t\tvscript->rise = 1;\n\t}\n\telse\n\t\tvscript->rise = rise;\n}\nstatic void\nvrrp_vscript_fall_handler(vector_t *strvec)\n{\n\tvrrp_script_t *vscript = LIST_TAIL_DATA(vrrp_data->vrrp_script);\n\tunsigned fall;\n\n\tif (!read_unsigned_strvec(strvec, 1, &fall, 1, INT_MAX, true)) {\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"(%s): vrrp script fall value '%s' invalid, defaulting to 1\", vscript->sname, FMT_STR_VSLOT(strvec, 1));\n\t\tvscript->fall = 1;\n\t}\n\telse\n\t\tvscript->fall = fall;\n}\nstatic void\nvrrp_vscript_user_handler(vector_t *strvec)\n{\n\tvrrp_script_t *vscript = LIST_TAIL_DATA(vrrp_data->vrrp_script);\n\n\tif (set_script_uid_gid(strvec, 1, &vscript->script.uid, &vscript->script.gid)) {\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"Unable to set uid/gid for script %s\", cmd_str(&vscript->script));\n\t\tremove_script = true;\n\t}\n\telse {\n\t\tremove_script = false;\n\t\tscript_user_set = true;\n\t}\n}\nstatic void\nvrrp_vscript_end_handler(void)\n{\n\tvrrp_script_t *vscript = LIST_TAIL_DATA(vrrp_data->vrrp_script);\n\n\tif (!vscript->script.args || !vscript->script.args[0]) {\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"No script set for vrrp_script %s - removing\", vscript->sname);\n\t\tremove_script = true;\n\t}\n\telse if (!remove_script) {\n\t\tif (script_user_set)\n\t\t\treturn;\n\n\t\tif (set_default_script_user(NULL, NULL)) {\n\t\t\treport_config_error(CONFIG_GENERAL_ERROR, \"Unable to set default user for vrrp script %s - removing\", vscript->sname);\n\t\t\tremove_script = true;\n\t\t}\n\t}\n\n\tif (remove_script) {\n\t\tfree_list_element(vrrp_data->vrrp_script, vrrp_data->vrrp_script->tail);\n\t\treturn;\n\t}\n\n\tvscript->script.uid = default_script_uid;\n\tvscript->script.gid = default_script_gid;\n}\nstatic void\nvrrp_tfile_handler(vector_t *strvec)\n{\n\tif (!strvec)\n\t\treturn;\n\n\talloc_vrrp_file(strvec_slot(strvec, 1));\n\n\ttrack_file_init = TRACK_FILE_NO_INIT;\n}\nstatic void\nvrrp_tfile_file_handler(vector_t *strvec)\n{\n\tvrrp_tracked_file_t *tfile = LIST_TAIL_DATA(vrrp_data->vrrp_track_files);\n\tif (tfile->file_path) {\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"File already set for track file %s - ignoring %s\", tfile->fname, FMT_STR_VSLOT(strvec, 1));\n\t\treturn;\n\t}\n\ttfile->file_path = set_value(strvec);\n}\nstatic void\nvrrp_tfile_weight_handler(vector_t *strvec)\n{\n\tint weight;\n\tvrrp_tracked_file_t *tfile = LIST_TAIL_DATA(vrrp_data->vrrp_track_files);\n\n\tif (vector_size(strvec) < 2) {\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"No weight specified for track file %s - ignoring\", tfile->fname);\n\t\treturn;\n\t}\n\tif (tfile->weight != 1) {\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"Weight already set for track file %s - ignoring %s\", tfile->fname, FMT_STR_VSLOT(strvec, 1));\n\t\treturn;\n\t}\n\n\tif (!read_int_strvec(strvec, 1, &weight, -254, 254, true)) {\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"Weight (%s) for vrrp_track_file %s must be between \"\n\t\t\t\t \"[-254..254] inclusive. Ignoring...\", FMT_STR_VSLOT(strvec, 1), tfile->fname);\n\t\tweight = 1;\n\t}\n\n\ttfile->weight = weight;\n}\nstatic void\nvrrp_tfile_init_handler(vector_t *strvec)\n{\n\tunsigned i;\n\tchar *word;\n\tvrrp_tracked_file_t *tfile = LIST_TAIL_DATA(vrrp_data->vrrp_track_files);\n\tint value;\n\n\ttrack_file_init = TRACK_FILE_CREATE;\n\ttrack_file_init_value = 0;\n\n\tfor (i = 1; i < vector_size(strvec); i++) {\n\t\tword = strvec_slot(strvec, i);\n\t\tword += strspn(word, WHITE_SPACE);\n\t\tif (isdigit(word[0]) || word[0] == '-') {\n\t\t\tif (!read_int_strvec(strvec, i, &value, INT_MIN, INT_MAX, false)) {\n\t\t\t\t/* It is not a valid integer */\n\t\t\t\treport_config_error(CONFIG_GENERAL_ERROR, \"Track file %s init value %s is invalid\", tfile->fname, word);\n\t\t\t\tvalue = 0;\n\t\t\t}\n\t\t\telse if (value < -254 || value > 254)\n\t\t\t\treport_config_error(CONFIG_GENERAL_ERROR, \"Track file %s init value %d is outside sensible range [%d, %d]\", tfile->fname, value, -254, 254);\n\t\t\ttrack_file_init_value = value;\n\t\t}\n\t\telse if (!strcmp(word, \"overwrite\"))\n\t\t\ttrack_file_init = TRACK_FILE_INIT;\n\t\telse\n\t\t\treport_config_error(CONFIG_GENERAL_ERROR, \"Unknown track file init option %s\", word);\n\t}\n}\nstatic void\nvrrp_tfile_end_handler(void)\n{\n\tvrrp_tracked_file_t *tfile = LIST_TAIL_DATA(vrrp_data->vrrp_track_files);\n\tstruct stat statb;\n\tFILE *tf;\n\tint ret;\n\n\tif (!tfile->file_path) {\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"No file set for track_file %s - removing\", tfile->fname);\n\t\tfree_list_element(vrrp_data->vrrp_track_files, vrrp_data->vrrp_track_files->tail);\n\t\treturn;\n\t}\n\n\tif (track_file_init == TRACK_FILE_NO_INIT)\n\t\treturn;\n\n\tret = stat(tfile->file_path, &statb);\n\tif (!ret) {\n\t\tif (track_file_init == TRACK_FILE_CREATE) {\n\t\t\t/* The file exists */\n\t\t\treturn;\n\t\t}\n\t\tif ((statb.st_mode & S_IFMT) != S_IFREG) {\n\t\t\t/* It is not a regular file */\n\t\t\treport_config_error(CONFIG_GENERAL_ERROR, \"Cannot initialise track file %s - it is not a regular file\", tfile->fname);\n\t\t\treturn;\n\t\t}\n\n\t\t/* Don't overwrite a file on reload */\n\t\tif (reload)\n\t\t\treturn;\n\t}\n\n\tif (!__test_bit(CONFIG_TEST_BIT, &debug)) {\n\t\t/* Write the value to the file */\n\t\tif ((tf = fopen_safe(tfile->file_path, \"w\"))) {\n\t\t\tfprintf(tf, \"%d\\n\", track_file_init_value);\n\t\t\tfclose(tf);\n\t\t}\n\t\telse\n\t\t\treport_config_error(CONFIG_GENERAL_ERROR, \"Unable to initialise track file %s\", tfile->fname);\n\t}\n}\nstatic void\nvrrp_vscript_init_fail_handler(__attribute__((unused)) vector_t *strvec)\n{\n\tvrrp_script_t *vscript = LIST_TAIL_DATA(vrrp_data->vrrp_script);\n\tvscript->init_state = SCRIPT_INIT_STATE_FAILED;\n}\nstatic void\nvrrp_version_handler(vector_t *strvec)\n{\n\tvrrp_t *vrrp = LIST_TAIL_DATA(vrrp_data->vrrp);\n\tint version;\n\n\tif (!read_int_strvec(strvec, 1, &version, 2, 3, true)) {\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"(%s): Version must be either 2 or 3\", vrrp->iname);\n\t\treturn;\n\t}\n\n\tif ((vrrp->version && vrrp->version != version) ||\n\t    (version == VRRP_VERSION_2 && vrrp->family == AF_INET6)) {\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"(%s) vrrp_version %d conflicts with configured or deduced version %d; ignoring.\", vrrp->iname, version, vrrp->version);\n\t\treturn;\n\t}\n\n\tvrrp->version = version;\n}\n\nstatic void\nvrrp_accept_handler(__attribute__((unused)) vector_t *strvec)\n{\n\tvrrp_t *vrrp = LIST_TAIL_DATA(vrrp_data->vrrp);\n\n\tvrrp->accept = true;\n}\n\nstatic void\nvrrp_no_accept_handler(__attribute__((unused)) vector_t *strvec)\n{\n\tvrrp_t *vrrp = LIST_TAIL_DATA(vrrp_data->vrrp);\n\n\tvrrp->accept = false;\n}\n\nstatic void\ngarp_group_handler(vector_t *strvec)\n{\n\tif (!strvec)\n\t\treturn;\n\n\talloc_garp_delay();\n}\nstatic void\ngarp_group_garp_interval_handler(vector_t *strvec)\n{\n\tgarp_delay_t *delay = LIST_TAIL_DATA(garp_delay);\n\tdouble val;\n\n\tif (!read_double_strvec(strvec, 1, &val, 0, INT_MAX / 1000000, true)) {\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"garp_group garp_interval '%s' invalid\", FMT_STR_VSLOT(strvec, 1));\n\t\treturn;\n\t}\n\n\tdelay->garp_interval.tv_sec = (time_t)val;\n\tdelay->garp_interval.tv_usec = (suseconds_t)((val - delay->garp_interval.tv_sec) * 1000000);\n\tdelay->have_garp_interval = true;\n\n\tif (delay->garp_interval.tv_sec >= 1)\n\t\tlog_message(LOG_INFO, \"The garp_interval is very large - %s seconds\", FMT_STR_VSLOT(strvec,1));\n}\nstatic void\ngarp_group_gna_interval_handler(vector_t *strvec)\n{\n\tgarp_delay_t *delay = LIST_TAIL_DATA(garp_delay);\n\tdouble val;\n\n\tif (!read_double_strvec(strvec, 1, &val, 0, INT_MAX / 1000000, true)) {\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"garp_group gna_interval '%s' invalid\", FMT_STR_VSLOT(strvec, 1));\n\t\treturn;\n\t}\n\n\tdelay->gna_interval.tv_sec = (time_t)val;\n\tdelay->gna_interval.tv_usec = (suseconds_t)((val - delay->gna_interval.tv_sec) * 1000000);\n\tdelay->have_gna_interval = true;\n\n\tif (delay->gna_interval.tv_sec >= 1)\n\t\tlog_message(LOG_INFO, \"The gna_interval is very large - %s seconds\", FMT_STR_VSLOT(strvec,1));\n}\nstatic void\ngarp_group_interface_handler(vector_t *strvec)\n{\n\tinterface_t *ifp = if_get_by_ifname(strvec_slot(strvec, 1), IF_CREATE_IF_DYNAMIC);\n\tif (!ifp) {\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"WARNING - interface %s specified for garp_group doesn't exist\", FMT_STR_VSLOT(strvec, 1));\n\t\treturn;\n\t}\n\n\tif (ifp->garp_delay) {\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"garp_group already specified for %s - ignoring\", FMT_STR_VSLOT(strvec, 1));\n\t\treturn;\n\t}\n\n#ifdef _HAVE_VRRP_VMAC_\n\t/* We cannot have a group on a vmac interface */\n\tif (ifp->vmac_type) {\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"Cannot specify garp_delay on a vmac (%s) - ignoring\", ifp->ifname);\n\t\treturn;\n\t}\n#endif\n\tifp->garp_delay = LIST_TAIL_DATA(garp_delay);\n}\nstatic void\ngarp_group_interfaces_handler(vector_t *strvec)\n{\n\tgarp_delay_t *delay = LIST_TAIL_DATA(garp_delay);\n\tinterface_t *ifp;\n\tvector_t *interface_vec = read_value_block(strvec);\n\tsize_t i;\n\tgarp_delay_t *gd;\n\telement e;\n\n\t/* Handle the interfaces block being empty */\n\tif (!interface_vec) {\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"Warning - empty garp_group interfaces block\");\n\t\treturn;\n\t}\n\n\t/* First set the next aggregation group number */\n\tdelay->aggregation_group = 1;\n\tfor (e = LIST_HEAD(garp_delay); e; ELEMENT_NEXT(e)) {\n\t\tgd = ELEMENT_DATA(e);\n\t\tif (gd->aggregation_group && gd != delay)\n\t\t\tdelay->aggregation_group++;\n\t}\n\n\tfor (i = 0; i < vector_size(interface_vec); i++) {\n\t\tifp = if_get_by_ifname(vector_slot(interface_vec, i), IF_CREATE_IF_DYNAMIC);\n\t\tif (!ifp) {\n\t\t\tif (global_data->dynamic_interfaces)\n\t\t\t\tlog_message(LOG_INFO, \"WARNING - interface %s specified for garp_group doesn't exist\", FMT_STR_VSLOT(strvec, i));\n\t\t\telse\n\t\t\t\treport_config_error(CONFIG_GENERAL_ERROR, \"WARNING - interface %s specified for garp_group doesn't exist\", FMT_STR_VSLOT(strvec, i));\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (ifp->garp_delay) {\n\t\t\treport_config_error(CONFIG_GENERAL_ERROR, \"garp_group already specified for %s - ignoring\", FMT_STR_VSLOT(strvec, 1));\n\t\t\tcontinue;\n\t\t}\n\n#ifdef _HAVE_VRRP_VMAC_\n\t\tif (ifp->vmac_type) {\n\t\t\treport_config_error(CONFIG_GENERAL_ERROR, \"Cannot specify garp_delay on a vmac (%s) - ignoring\", ifp->ifname);\n\t\t\tcontinue;\n\t\t}\n#endif\n\t\tifp->garp_delay = delay;\n\t}\n\n\tfree_strvec(interface_vec);\n}\nstatic void\ngarp_group_end_handler(void)\n{\n\tgarp_delay_t *delay = LIST_TAIL_DATA(garp_delay);\n\telement e, next;\n\tinterface_t *ifp;\n\n\tif (!delay->have_garp_interval && !delay->have_gna_interval) {\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"garp group %d does not have any delay set - removing\", delay->aggregation_group);\n\n\t\t/* Remove the garp_delay from any interfaces that are using it */\n\t\tLIST_FOREACH_NEXT(get_if_list(), ifp, e, next) {\n\t\t\tif (ifp->garp_delay == delay)\n\t\t\t\tifp->garp_delay = NULL;\n\t\t}\n\n\t\tfree_list_element(garp_delay, garp_delay->tail);\n\t}\n}\n\nvoid\ninit_vrrp_keywords(bool active)\n{\n\t/* Static addresses/routes/rules */\n\tinstall_keyword_root(\"track_group\", &static_track_group_handler, active);\n\tinstall_keyword(\"group\", &static_track_group_group_handler);\n\tinstall_keyword_root(\"static_ipaddress\", &static_addresses_handler, active);\n#ifdef _HAVE_FIB_ROUTING_\n\tinstall_keyword_root(\"static_routes\", &static_routes_handler, active);\n\tinstall_keyword_root(\"static_rules\", &static_rules_handler, active);\n#endif\n\n\t/* Sync group declarations */\n\tinstall_keyword_root(\"vrrp_sync_group\", &vrrp_sync_group_handler, active);\n\tinstall_keyword(\"group\", &vrrp_group_handler);\n\tinstall_keyword(\"track_interface\", &vrrp_group_track_if_handler);\n\tinstall_keyword(\"track_script\", &vrrp_group_track_scr_handler);\n\tinstall_keyword(\"track_file\", &vrrp_group_track_file_handler);\n#ifdef _WITH_BFD_\n\tinstall_keyword(\"track_bfd\", &vrrp_group_track_bfd_handler);\n#endif\n\tinstall_keyword(\"notify_backup\", &vrrp_gnotify_backup_handler);\n\tinstall_keyword(\"notify_master\", &vrrp_gnotify_master_handler);\n\tinstall_keyword(\"notify_fault\", &vrrp_gnotify_fault_handler);\n\tinstall_keyword(\"notify_stop\", &vrrp_gnotify_stop_handler);\n\tinstall_keyword(\"notify\", &vrrp_gnotify_handler);\n\tinstall_keyword(\"smtp_alert\", &vrrp_gsmtp_handler);\n\tinstall_keyword(\"global_tracking\", &vrrp_gglobal_tracking_handler);\n\tinstall_keyword(\"sync_group_tracking_weight\", &vrrp_sg_tracking_weight_handler);\n\n\tinstall_keyword_root(\"garp_group\", &garp_group_handler, active);\n\tinstall_keyword(\"garp_interval\", &garp_group_garp_interval_handler);\n\tinstall_keyword(\"gna_interval\", &garp_group_gna_interval_handler);\n\tinstall_keyword(\"interface\", &garp_group_interface_handler);\n\tinstall_keyword(\"interfaces\", &garp_group_interfaces_handler);\n\tinstall_sublevel_end_handler(&garp_group_end_handler);\n\n\t/* VRRP Instance mapping */\n\tinstall_keyword_root(\"vrrp_instance\", &vrrp_handler, active);\n#ifdef _HAVE_VRRP_VMAC_\n\tinstall_keyword(\"use_vmac\", &vrrp_vmac_handler);\n\tinstall_keyword(\"vmac_xmit_base\", &vrrp_vmac_xmit_base_handler);\n#endif\n\tinstall_keyword(\"unicast_peer\", &vrrp_unicast_peer_handler);\n#ifdef _WITH_UNICAST_CHKSUM_COMPAT_\n\tinstall_keyword(\"old_unicast_checksum\", &vrrp_unicast_chksum_handler);\n#endif\n\tinstall_keyword(\"native_ipv6\", &vrrp_native_ipv6_handler);\n\tinstall_keyword(\"state\", &vrrp_state_handler);\n\tinstall_keyword(\"interface\", &vrrp_int_handler);\n\tinstall_keyword(\"dont_track_primary\", &vrrp_dont_track_handler);\n\tinstall_keyword(\"track_interface\", &vrrp_track_if_handler);\n\tinstall_keyword(\"track_script\", &vrrp_track_scr_handler);\n\tinstall_keyword(\"track_file\", &vrrp_track_file_handler);\n#ifdef _WITH_BFD_\n\tinstall_keyword(\"track_bfd\", &vrrp_track_bfd_handler);\n#endif\n\tinstall_keyword(\"mcast_src_ip\", &vrrp_srcip_handler);\n\tinstall_keyword(\"unicast_src_ip\", &vrrp_srcip_handler);\n\tinstall_keyword(\"track_src_ip\", &vrrp_track_srcip_handler);\n\tinstall_keyword(\"virtual_router_id\", &vrrp_vrid_handler);\n\tinstall_keyword(\"version\", &vrrp_version_handler);\n\tinstall_keyword(\"priority\", &vrrp_prio_handler);\n\tinstall_keyword(\"advert_int\", &vrrp_adv_handler);\n\tinstall_keyword(\"virtual_ipaddress\", &vrrp_vip_handler);\n\tinstall_keyword(\"virtual_ipaddress_excluded\", &vrrp_evip_handler);\n\tinstall_keyword(\"promote_secondaries\", &vrrp_promote_secondaries_handler);\n\tinstall_keyword(\"linkbeat_use_polling\", &vrrp_linkbeat_handler);\n#ifdef _HAVE_FIB_ROUTING_\n\tinstall_keyword(\"virtual_routes\", &vrrp_vroutes_handler);\n\tinstall_keyword(\"virtual_rules\", &vrrp_vrules_handler);\n#endif\n\tinstall_keyword(\"accept\", &vrrp_accept_handler);\n\tinstall_keyword(\"no_accept\", &vrrp_no_accept_handler);\n\tinstall_keyword(\"skip_check_adv_addr\", &vrrp_skip_check_adv_addr_handler);\n\tinstall_keyword(\"strict_mode\", &vrrp_strict_mode_handler);\n\tinstall_keyword(\"preempt\", &vrrp_preempt_handler);\n\tinstall_keyword(\"nopreempt\", &vrrp_nopreempt_handler);\n\tinstall_keyword(\"preempt_delay\", &vrrp_preempt_delay_handler);\n\tinstall_keyword(\"debug\", &vrrp_debug_handler);\n\tinstall_keyword(\"notify_backup\", &vrrp_notify_backup_handler);\n\tinstall_keyword(\"notify_master\", &vrrp_notify_master_handler);\n\tinstall_keyword(\"notify_fault\", &vrrp_notify_fault_handler);\n\tinstall_keyword(\"notify_stop\", &vrrp_notify_stop_handler);\n\tinstall_keyword(\"notify\", &vrrp_notify_handler);\n\tinstall_keyword(\"notify_master_rx_lower_pri\", vrrp_notify_master_rx_lower_pri);\n\tinstall_keyword(\"smtp_alert\", &vrrp_smtp_handler);\n#ifdef _WITH_LVS_\n\tinstall_keyword(\"lvs_sync_daemon_interface\", &vrrp_lvs_syncd_handler);\n#endif\n\tinstall_keyword(\"garp_master_delay\", &vrrp_garp_delay_handler);\n\tinstall_keyword(\"garp_master_refresh\", &vrrp_garp_refresh_handler);\n\tinstall_keyword(\"garp_master_repeat\", &vrrp_garp_rep_handler);\n\tinstall_keyword(\"garp_master_refresh_repeat\", &vrrp_garp_refresh_rep_handler);\n\tinstall_keyword(\"garp_lower_prio_delay\", &vrrp_garp_lower_prio_delay_handler);\n\tinstall_keyword(\"garp_lower_prio_repeat\", &vrrp_garp_lower_prio_rep_handler);\n\tinstall_keyword(\"lower_prio_no_advert\", &vrrp_lower_prio_no_advert_handler);\n\tinstall_keyword(\"higher_prio_send_advert\", &vrrp_higher_prio_send_advert_handler);\n\tinstall_keyword(\"kernel_rx_buf_size\", &kernel_rx_buf_size_handler);\n#if defined _WITH_VRRP_AUTH_\n\tinstall_keyword(\"authentication\", NULL);\n\tinstall_sublevel();\n\tinstall_keyword(\"auth_type\", &vrrp_auth_type_handler);\n\tinstall_keyword(\"auth_pass\", &vrrp_auth_pass_handler);\n\tinstall_sublevel_end();\n#endif\n\tinstall_keyword_root(\"vrrp_script\", &vrrp_script_handler, active);\n\tinstall_keyword(\"script\", &vrrp_vscript_script_handler);\n\tinstall_keyword(\"interval\", &vrrp_vscript_interval_handler);\n\tinstall_keyword(\"timeout\", &vrrp_vscript_timeout_handler);\n\tinstall_keyword(\"weight\", &vrrp_vscript_weight_handler);\n\tinstall_keyword(\"rise\", &vrrp_vscript_rise_handler);\n\tinstall_keyword(\"fall\", &vrrp_vscript_fall_handler);\n\tinstall_keyword(\"user\", &vrrp_vscript_user_handler);\n\tinstall_keyword(\"init_fail\", &vrrp_vscript_init_fail_handler);\n\tinstall_sublevel_end_handler(&vrrp_vscript_end_handler);\n\n\t/* Track file declarations */\n\tinstall_keyword_root(\"vrrp_track_file\", &vrrp_tfile_handler, active);\n\tinstall_keyword(\"file\", &vrrp_tfile_file_handler);\n\tinstall_keyword(\"weight\", &vrrp_tfile_weight_handler);\n\tinstall_keyword(\"init_file\", &vrrp_tfile_init_handler);\n\tinstall_sublevel_end_handler(&vrrp_tfile_end_handler);\n}\n\nvector_t *\nvrrp_init_keywords(void)\n{\n\t/* global definitions mapping */\n\tinit_global_keywords(reload);\n\n\tinit_vrrp_keywords(true);\n#ifdef _WITH_LVS_\n\tinit_check_keywords(false);\n#endif\n#ifdef _WITH_BFD_\n\tinit_bfd_keywords(true);\n#endif\n\n\treturn keywords;\n}\n", "/*\n * Soft:        Vrrpd is an implementation of VRRPv2 as specified in rfc2338.\n *              VRRP is a protocol which elect a master server on a LAN. If the\n *              master fails, a backup server takes over.\n *              The original implementation has been made by jerome etienne.\n *\n * Part:        Print running VRRP state information\n *\n * Author:      John Southworth, <john.southworth@vyatta.com>\n *\n *              This program is distributed in the hope that it will be useful,\n *              but WITHOUT ANY WARRANTY; without even the implied warranty of\n *              MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n *              See the GNU General Public License for more details.\n *\n *              This program is free software; you can redistribute it and/or\n *              modify it under the terms of the GNU General Public License\n *              as published by the Free Software Foundation; either version\n *              2 of the License, or (at your option) any later version.\n *\n * Copyright (C) 2012 John Southworth, <john.southworth@vyatta.com>\n * Copyright (C) 2015-2017 Alexandre Cassen, <acassen@gmail.com>\n */\n\n#include \"config.h\"\n\n#include <errno.h>\n#include <inttypes.h>\n\n#include \"logger.h\"\n\n#include \"vrrp.h\"\n#include \"vrrp_data.h\"\n#include \"vrrp_print.h\"\n#include \"utils.h\"\n\nstatic const char *dump_file = \"/tmp/keepalived.data\";\nstatic const char *stats_file = \"/tmp/keepalived.stats\";\n\nvoid\nvrrp_print_data(void)\n{\n\tFILE *file = fopen_safe(dump_file, \"w\");\n\n\tif (!file) {\n\t\tlog_message(LOG_INFO, \"Can't open %s (%d: %s)\",\n\t\t\tdump_file, errno, strerror(errno));\n\t\treturn;\n\t}\n\n\tdump_data_vrrp(file);\n\n\tfclose(file);\n}\n\nvoid\nvrrp_print_stats(void)\n{\n\tFILE *file = fopen_safe(stats_file, \"w\");\n\telement e;\n\tvrrp_t *vrrp;\n\n\tif (!file) {\n\t\tlog_message(LOG_INFO, \"Can't open %s (%d: %s)\",\n\t\t\tstats_file, errno, strerror(errno));\n\t\treturn;\n\t}\n\n\n\tLIST_FOREACH(vrrp_data->vrrp, vrrp, e) {\n\t\tfprintf(file, \"VRRP Instance: %s\\n\", vrrp->iname);\n\t\tfprintf(file, \"  Advertisements:\\n\");\n\t\tfprintf(file, \"    Received: %\" PRIu64 \"\\n\", vrrp->stats->advert_rcvd);\n\t\tfprintf(file, \"    Sent: %d\\n\", vrrp->stats->advert_sent);\n\t\tfprintf(file, \"  Became master: %d\\n\", vrrp->stats->become_master);\n\t\tfprintf(file, \"  Released master: %d\\n\", vrrp->stats->release_master);\n\t\tfprintf(file, \"  Packet Errors:\\n\");\n\t\tfprintf(file, \"    Length: %\" PRIu64 \"\\n\", vrrp->stats->packet_len_err);\n\t\tfprintf(file, \"    TTL: %\" PRIu64 \"\\n\", vrrp->stats->ip_ttl_err);\n\t\tfprintf(file, \"    Invalid Type: %\" PRIu64 \"\\n\",\n\t\t\tvrrp->stats->invalid_type_rcvd);\n\t\tfprintf(file, \"    Advertisement Interval: %\" PRIu64 \"\\n\",\n\t\t\tvrrp->stats->advert_interval_err);\n\t\tfprintf(file, \"    Address List: %\" PRIu64 \"\\n\",\n\t\t\tvrrp->stats->addr_list_err);\n\t\tfprintf(file, \"  Authentication Errors:\\n\");\n\t\tfprintf(file, \"    Invalid Type: %d\\n\",\n\t\t\tvrrp->stats->invalid_authtype);\n#ifdef _WITH_VRRP_AUTH_\n\t\tfprintf(file, \"    Type Mismatch: %d\\n\",\n\t\t\tvrrp->stats->authtype_mismatch);\n\t\tfprintf(file, \"    Failure: %d\\n\",\n\t\t\tvrrp->stats->auth_failure);\n#endif\n\t\tfprintf(file, \"  Priority Zero:\\n\");\n\t\tfprintf(file, \"    Received: %\" PRIu64 \"\\n\", vrrp->stats->pri_zero_rcvd);\n\t\tfprintf(file, \"    Sent: %\" PRIu64 \"\\n\", vrrp->stats->pri_zero_sent);\n\t}\n\tfclose(file);\n}\n", "/*\n * Soft:        Keepalived is a failover program for the LVS project\n *              <www.linuxvirtualserver.org>. It monitor & manipulate\n *              a loadbalanced server pool using multi-layer checks.\n *\n * Part:        Sheduling framework for vrrp code.\n *\n * Author:      Alexandre Cassen, <acassen@linux-vs.org>\n *\n *              This program is distributed in the hope that it will be useful,\n *              but WITHOUT ANY WARRANTY; without even the implied warranty of\n *              MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n *              See the GNU General Public License for more details.\n *\n *              This program is free software; you can redistribute it and/or\n *              modify it under the terms of the GNU General Public License\n *              as published by the Free Software Foundation; either version\n *              2 of the License, or (at your option) any later version.\n *\n * Copyright (C) 2001-2017 Alexandre Cassen, <acassen@gmail.com>\n */\n\n#include \"config.h\"\n\n#include <errno.h>\n#include <netinet/ip.h>\n#include <signal.h>\n#if defined _WITH_VRRP_AUTH_\n#include <netinet/in.h>\n#endif\n#include <stdint.h>\n#include <stdio.h>\n\n#include \"vrrp_scheduler.h\"\n#include \"vrrp_track.h\"\n#ifdef _HAVE_VRRP_VMAC_\n#include \"vrrp_vmac.h\"\n#endif\n#include \"vrrp_sync.h\"\n#include \"vrrp_notify.h\"\n#include \"vrrp_data.h\"\n#include \"vrrp_arp.h\"\n#include \"vrrp_ndisc.h\"\n#include \"vrrp_if.h\"\n#include \"global_data.h\"\n#include \"memory.h\"\n#include \"list.h\"\n#include \"logger.h\"\n#include \"main.h\"\n#include \"signals.h\"\n#include \"utils.h\"\n#include \"bitops.h\"\n#include \"vrrp_sock.h\"\n#ifdef _WITH_SNMP_RFCV3_\n#include \"vrrp_snmp.h\"\n#endif\n#ifdef _WITH_BFD_\n#include \"bfd_event.h\"\n#include \"bfd_daemon.h\"\n#endif\n#ifdef THREAD_DUMP\n#include \"scheduler.h\"\n#endif\n\n/* global vars */\ntimeval_t garp_next_time;\nthread_t *garp_thread;\nbool vrrp_initialised;\n\n#ifdef _TSM_DEBUG_\nbool do_tsm_debug;\n#endif\n\n/* local variables */\n#ifdef _WITH_BFD_\nstatic thread_t *bfd_thread;\t\t /* BFD control pipe read thread */\n#endif\n\n/* VRRP FSM (Finite State Machine) design.\n *\n * The state transition diagram implemented is :\n *\n *                         +---------------+\n *        +----------------|               |----------------+\n *        |                |     Fault     |                |\n *        |  +------------>|               |<------------+  |\n *        |  |             +---------------+             |  |\n *        |  |                     |                     |  |\n *        |  |                     V                     |  |\n *        |  |             +---------------+             |  |\n *        |  |  +--------->|               |<---------+  |  |\n *        |  |  |          |  Initialize   |          |  |  |\n *        |  |  |  +-------|               |-------+  |  |  |\n *        |  |  |  |       +---------------+       |  |  |  |\n *        |  |  |  |                               |  |  |  |\n *        V  |  |  V                               V  |  |  V\n *     +---------------+                       +---------------+\n *     |               |---------------------->|               |\n *     |    Master     |                       |    Backup     |\n *     |               |<----------------------|               |\n *     +---------------+                       +---------------+\n */\n\nstatic int vrrp_script_child_thread(thread_t *);\nstatic int vrrp_script_thread(thread_t *);\n#ifdef _WITH_BFD_\nstatic int vrrp_bfd_thread(thread_t *);\n#endif\n\nstatic int vrrp_read_dispatcher_thread(thread_t *);\n\n/* VRRP TSM (Transition State Matrix) design.\n *\n * Introducing the Synchronization extension to VRRP\n * protocol, introduce the need for a transition machinery.\n * This mechanism can be designed using a diagonal matrix.\n * We call this matrix the VRRP TSM:\n *\n *   \\ E |  B  |  M  |  F  |\n *   S \\ |     |     |     |\n * ------+-----+-----+-----+     Legend:\n *   B   |  x     1     2  |       B: VRRP BACKUP state\n * ------+                 |       M: VRRP MASTER state\n *   M   |  3     x     4  |       F: VRRP FAULT state\n * ------+                 |       S: VRRP start state (before transition)\n *   F   |  5     6     x  |       E: VRRP end state (after transition)\n * ------+-----------------+       [1..6]: Handler functions.\n *\n * So we have have to implement n(n-1) handlers in order to deal with\n * all transitions possible. This matrix defines the maximum handlers\n * to implement for having the most time optimized transition machine.\n * For example:\n *     . The handler (1) will sync all the BACKUP VRRP instances of a\n *       group to MASTER state => we will call it vrrp_sync_master.\n *     .... and so on for all other state ....\n *\n * This matrix is the strict implementation way. For readability and\n * performance we have implemented some handlers directly into the VRRP\n * FSM or they are handled when the trigger events to/from FAULT state occur.\n * For instance the handlers (2), (4), (5) & (6) are handled when it is\n * detected that a script or an interface has failed or recovered since\n * it will speed up convergence to init state.\n * Additionaly, we have implemented some other handlers into the matrix\n * in order to speed up group synchronization takeover. For instance\n * transition:\n *    o B->B: To catch wantstate MASTER transition to force sync group\n *            to this transition state too.\n *    o F->F: To speed up FAULT state transition if group is not already\n *            synced to FAULT state.\n */\nstatic struct {\n\tvoid (*handler) (vrrp_t *);\n} VRRP_TSM[VRRP_MAX_TSM_STATE + 1][VRRP_MAX_TSM_STATE + 1] =\n{\n/* From:\t  To: >\t  BACKUP\t\t\tMASTER\t\t    FAULT */\n/*   v    */\t{ {NULL}, {NULL},\t\t\t{NULL},\t\t   {NULL} },\n/* BACKUP */\t{ {NULL}, {NULL},\t\t\t{vrrp_sync_master}, {NULL} },\n/* MASTER */\t{ {NULL}, {vrrp_sync_backup},\t\t{vrrp_sync_master}, {NULL} },\n/* FAULT  */\t{ {NULL}, {NULL},\t\t\t{vrrp_sync_master}, {NULL} }\n};\n\n/*\n * Initialize state handling\n * --rfc2338.6.4.1\n */\nstatic void\nvrrp_init_state(list l)\n{\n\tvrrp_t *vrrp;\n\tvrrp_sgroup_t *vgroup;\n\telement e;\n\tbool is_up;\n\tint new_state;\n\n\t/* We can send SMTP messages from this point, so set the time */\n\tset_time_now();\n\n\t/* Do notifications for any sync groups in fault state */\n\tfor (e = LIST_HEAD(vrrp_data->vrrp_sync_group); e; ELEMENT_NEXT(e)) {\n\t\t/* Init group if needed  */\n\t\tvgroup = ELEMENT_DATA(e);\n\n\t\tif (vgroup->state == VRRP_STATE_FAULT)\n\t\t\tsend_group_notifies(vgroup);\n\t}\n\n\tfor (e = LIST_HEAD(l); e; ELEMENT_NEXT(e)) {\n\t\tvrrp = ELEMENT_DATA(e);\n\n\t\t/* wantstate is the state we would be in disregarding any sync group */\n\t\tif (vrrp->state == VRRP_STATE_FAULT)\n\t\t\tvrrp->wantstate = VRRP_STATE_FAULT;\n\n\t\tnew_state = vrrp->sync ? vrrp->sync->state : vrrp->wantstate;\n\n\t\tis_up = VRRP_ISUP(vrrp);\n\n\t\tif (is_up &&\n\t\t    new_state == VRRP_STATE_MAST &&\n\t\t    !vrrp->num_script_init && (!vrrp->sync || !vrrp->sync->num_member_init) &&\n\t\t    (vrrp->base_priority == VRRP_PRIO_OWNER ||\n\t\t     vrrp->reload_master) &&\n\t\t    vrrp->wantstate == VRRP_STATE_MAST) {\n#ifdef _WITH_LVS_\n\t\t\t/* Check if sync daemon handling is needed */\n\t\t\tif (global_data->lvs_syncd.ifname &&\n\t\t\t    global_data->lvs_syncd.vrrp == vrrp)\n\t\t\t\tipvs_syncd_cmd(IPVS_STARTDAEMON,\n\t\t\t\t\t       &global_data->lvs_syncd,\n\t\t\t\t\t       vrrp->state == VRRP_STATE_MAST ? IPVS_MASTER : IPVS_BACKUP,\n\t\t\t\t\t       false,\n\t\t\t\t\t       false);\n#endif\n\t\t\tif (!vrrp->reload_master) {\n#ifdef _WITH_SNMP_RFCV3_\n\t\t\t\tvrrp->stats->next_master_reason = VRRPV3_MASTER_REASON_PREEMPTED;\n#endif\n\n\t\t\t\t/* The simplest way to become master is to timeout from the backup state\n\t\t\t\t * very quickly (1usec) */\n\t\t\t\tvrrp->state = VRRP_STATE_BACK;\n\t\t\t\tvrrp->ms_down_timer = 1;\n\t\t\t}\n\n// TODO Do we need ->\tvrrp_restore_interface(vrrp, false, false);\n// It removes everything, so probably if !reload\n\t\t} else {\n\t\t\tif (new_state == VRRP_STATE_BACK && vrrp->wantstate == VRRP_STATE_MAST)\n\t\t\t\tvrrp->ms_down_timer = vrrp->master_adver_int + VRRP_TIMER_SKEW_MIN(vrrp);\n\t\t\telse\n\t\t\t\tvrrp->ms_down_timer = 3 * vrrp->master_adver_int + VRRP_TIMER_SKEW(vrrp);\n\n#ifdef _WITH_SNMP_RFCV3_\n\t\t\tvrrp->stats->next_master_reason = VRRPV3_MASTER_REASON_MASTER_NO_RESPONSE;\n#endif\n\n#ifdef _WITH_LVS_\n\t\t\t/* Check if sync daemon handling is needed */\n\t\t\tif (global_data->lvs_syncd.ifname &&\n\t\t\t    global_data->lvs_syncd.vrrp == vrrp)\n\t\t\t\tipvs_syncd_cmd(IPVS_STARTDAEMON,\n\t\t\t\t\t       &global_data->lvs_syncd,\n\t\t\t\t\t       IPVS_BACKUP,\n\t\t\t\t\t       false,\n\t\t\t\t\t       false);\n#endif\n\n\t\t\t/* Set interface state */\n\t\t\tvrrp_restore_interface(vrrp, false, false);\n\t\t\tif (is_up && new_state != VRRP_STATE_FAULT && !vrrp->num_script_init && (!vrrp->sync || !vrrp->sync->num_member_init)) {\n\t\t\t\tif (is_up) {\n\t\t\t\t\tvrrp->state = VRRP_STATE_BACK;\n\t\t\t\t\tlog_message(LOG_INFO, \"(%s) Entering BACKUP STATE (init)\", vrrp->iname);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tvrrp->state = VRRP_STATE_FAULT;\n\t\t\t\t\tlog_message(LOG_INFO, \"(%s) Entering FAULT STATE (init)\", vrrp->iname);\n\t\t\t\t}\n\t\t\t\tsend_instance_notifies(vrrp);\n\t\t\t}\n\t\t\tvrrp->last_transition = timer_now();\n\t\t}\n#ifdef _WITH_SNMP_RFC_\n\t\tvrrp->stats->uptime = timer_now();\n#endif\n\t}\n}\n\n/* Declare vrrp_timer_cmp() rbtree compare function */\nRB_TIMER_CMP(vrrp);\n\n/* Compute the new instance sands */\nvoid\nvrrp_init_instance_sands(vrrp_t * vrrp)\n{\n\tset_time_now();\n\n\tif (vrrp->state == VRRP_STATE_MAST) {\n\t\tif (vrrp->reload_master)\n\t\t\tvrrp->sands = time_now;\n\t\telse\n\t\t\tvrrp->sands = timer_add_long(time_now, vrrp->adver_int);\n\t}\n\telse if (vrrp->state == VRRP_STATE_BACK) {\n\t\t/*\n\t\t * When in the BACKUP state the expiry timer should be updated to\n\t\t * time_now plus the Master Down Timer, when a non-preemptable packet is\n\t\t * received.\n\t\t */\n\t\tvrrp->sands = timer_add_long(time_now, vrrp->ms_down_timer);\n\t}\n\telse if (vrrp->state == VRRP_STATE_FAULT || vrrp->state == VRRP_STATE_INIT)\n\t\tvrrp->sands.tv_sec = TIMER_DISABLED;\n\n\trb_move_cached(&vrrp->sockets->rb_sands, vrrp, rb_sands, vrrp_timer_cmp);\n}\n\nstatic void\nvrrp_init_sands(list l)\n{\n\tvrrp_t *vrrp;\n\telement e;\n\n\tLIST_FOREACH(l, vrrp, e) {\n\t\tvrrp->sands.tv_sec = TIMER_DISABLED;\n\t\trb_insert_sort_cached(&vrrp->sockets->rb_sands, vrrp, rb_sands, vrrp_timer_cmp);\n\t\tvrrp_init_instance_sands(vrrp);\n\t\tvrrp->reload_master = false;\n\t}\n}\n\nstatic void\nvrrp_init_script(list l)\n{\n\tvrrp_script_t *vscript;\n\telement e;\n\n\tLIST_FOREACH(l, vscript, e) {\n\t\tif (vscript->init_state == SCRIPT_INIT_STATE_INIT)\n\t\t\tvscript->result = vscript->rise - 1; /* one success is enough */\n\t\telse if (vscript->init_state == SCRIPT_INIT_STATE_FAILED)\n\t\t\tvscript->result = 0; /* assume failed by config */\n\n\t\tthread_add_event(master, vrrp_script_thread, vscript, (int)vscript->interval);\n\t}\n}\n\n/* Timer functions */\nstatic timeval_t *\nvrrp_compute_timer(const sock_t *sock)\n{\n\tvrrp_t *vrrp;\n\tstatic timeval_t timer = { .tv_sec = TIMER_DISABLED };\n\n\t/* The sock won't exist if there isn't a vrrp instance on it,\n\t * so rb_first will always exist. */\n\tvrrp = rb_entry(rb_first_cached(&sock->rb_sands), vrrp_t, rb_sands);\n\tif (vrrp)\n\t\treturn &vrrp->sands;\n\n\treturn &timer;\n}\n\nvoid\nvrrp_thread_requeue_read(vrrp_t *vrrp)\n{\n\tthread_requeue_read(master, vrrp->sockets->fd_in, vrrp_compute_timer(vrrp->sockets));\n}\n\n/* Thread functions */\nstatic void\nvrrp_register_workers(list l)\n{\n\tsock_t *sock;\n\ttimeval_t timer;\n\telement e;\n\n\t/* Init compute timer */\n\tmemset(&timer, 0, sizeof(timer));\n\n\t/* Init the VRRP instances state */\n\tvrrp_init_state(vrrp_data->vrrp);\n\n\t/* Init VRRP instances sands */\n\tvrrp_init_sands(vrrp_data->vrrp);\n\n\t/* Init VRRP tracking scripts */\n\tif (!LIST_ISEMPTY(vrrp_data->vrrp_script))\n\t\tvrrp_init_script(vrrp_data->vrrp_script);\n\n#ifdef _WITH_BFD_\n\tif (!LIST_ISEMPTY(vrrp_data->vrrp)) {\n// TODO - should we only do this if we have track_bfd? Probably not\n\t\t/* Init BFD tracking thread */\n\t\tbfd_thread = thread_add_read(master, vrrp_bfd_thread, NULL,\n\t\t\t\t\t     bfd_vrrp_event_pipe[0], TIMER_NEVER);\n\t}\n#endif\n\n\t/* Register VRRP workers threads */\n\tLIST_FOREACH(l, sock, e) {\n\t\t/* Register a timer thread if interface exists */\n\t\tif (sock->fd_in != -1)\n\t\t\tsock->thread = thread_add_read_sands(master, vrrp_read_dispatcher_thread,\n\t\t\t\t\t\t       sock, sock->fd_in, vrrp_compute_timer(sock));\n\t}\n}\n\nvoid\nvrrp_thread_add_read(vrrp_t *vrrp)\n{\n\tvrrp->sockets->thread = thread_add_read_sands(master, vrrp_read_dispatcher_thread,\n\t\t\t\t\t\tvrrp->sockets, vrrp->sockets->fd_in, vrrp_compute_timer(vrrp->sockets));\n}\n\n/* VRRP dispatcher functions */\nstatic sock_t *\nalready_exist_sock(list l, sa_family_t family, int proto, ifindex_t ifindex, bool unicast)\n{\n\tsock_t *sock;\n\telement e;\n\n\tLIST_FOREACH(l, sock, e) {\n\t\tif ((sock->family == family)\t&&\n\t\t    (sock->proto == proto)\t&&\n\t\t    (sock->ifindex == ifindex)\t&&\n\t\t    (sock->unicast == unicast))\n\t\t\treturn sock;\n\t}\n\n\treturn NULL;\n}\n\nstatic sock_t *\nalloc_sock(sa_family_t family, list l, int proto, ifindex_t ifindex, bool unicast)\n{\n\tsock_t *new;\n\n\tnew = (sock_t *)MALLOC(sizeof (sock_t));\n\tnew->family = family;\n\tnew->proto = proto;\n\tnew->ifindex = ifindex;\n\tnew->unicast = unicast;\n\tnew->rb_vrid = RB_ROOT;\n\tnew->rb_sands = RB_ROOT_CACHED;\n\n\tlist_add(l, new);\n\n\treturn new;\n}\n\nstatic inline int\nvrrp_vrid_cmp(const vrrp_t *v1, const vrrp_t *v2)\n{\n\treturn v1->vrid - v2->vrid;\n}\n\nstatic void\nvrrp_create_sockpool(list l)\n{\n\tvrrp_t *vrrp;\n\telement e;\n\tifindex_t ifindex;\n\tint proto;\n\tbool unicast;\n\tsock_t *sock;\n\n\tLIST_FOREACH(vrrp_data->vrrp, vrrp, e) {\n\t\tifindex =\n#ifdef _HAVE_VRRP_VMAC_\n\t\t\t  (__test_bit(VRRP_VMAC_XMITBASE_BIT, &vrrp->vmac_flags)) ? IF_BASE_INDEX(vrrp->ifp) :\n#endif\n\t\t\t\t\t\t\t\t\t\t    IF_INDEX(vrrp->ifp);\n\t\tunicast = !LIST_ISEMPTY(vrrp->unicast_peer);\n#if defined _WITH_VRRP_AUTH_\n\t\tif (vrrp->auth_type == VRRP_AUTH_AH)\n\t\t\tproto = IPPROTO_AH;\n\t\telse\n#endif\n\t\t\tproto = IPPROTO_VRRP;\n\n\t\t/* add the vrrp element if not exist */\n\t\tif (!(sock = already_exist_sock(l, vrrp->family, proto, ifindex, unicast)))\n\t\t\tsock = alloc_sock(vrrp->family, l, proto, ifindex, unicast);\n\n\t\t/* Add the vrrp_t indexed by vrid to the socket */\n\t\trb_insert_sort(&sock->rb_vrid, vrrp, rb_vrid, vrrp_vrid_cmp);\n\n\t\tif (vrrp->kernel_rx_buf_size)\n\t\t\tsock->rx_buf_size += vrrp->kernel_rx_buf_size;\n\t\telse if (global_data->vrrp_rx_bufs_policy & RX_BUFS_SIZE)\n\t\t\tsock->rx_buf_size += global_data->vrrp_rx_bufs_size;\n\t\telse if (global_data->vrrp_rx_bufs_policy & RX_BUFS_POLICY_ADVERT)\n\t\t\tsock->rx_buf_size += global_data->vrrp_rx_bufs_multiples * vrrp_adv_len(vrrp);\n\t\telse if (global_data->vrrp_rx_bufs_policy & RX_BUFS_POLICY_MTU)\n\t\t\tsock->rx_buf_size += global_data->vrrp_rx_bufs_multiples * vrrp->ifp->mtu;\n\t}\n}\n\nstatic void\nvrrp_open_sockpool(list l)\n{\n\tsock_t *sock;\n\telement e;\n\tinterface_t *ifp;\n\n\tLIST_FOREACH(l, sock, e) {\n\t\tif (!sock->ifindex) {\n\t\t\tsock->fd_in = sock->fd_out = -1;\n\t\t\tcontinue;\n\t\t}\n\t\tifp = if_get_by_ifindex(sock->ifindex);\n\t\tsock->fd_in = open_vrrp_read_socket(sock->family, sock->proto,\n\t\t\t\t\t       ifp, sock->unicast, sock->rx_buf_size);\n\t\tif (sock->fd_in == -1)\n\t\t\tsock->fd_out = -1;\n\t\telse\n\t\t\tsock->fd_out = open_vrrp_send_socket(sock->family, sock->proto,\n\t\t\t\t\t\t\t     ifp, sock->unicast);\n\t}\n}\n\nstatic void\nvrrp_set_fds(list l)\n{\n\tsock_t *sock;\n\tvrrp_t *vrrp;\n\telement e;\n\n\tLIST_FOREACH(l, sock, e) {\n\t\trb_for_each_entry(vrrp, &sock->rb_vrid, rb_vrid)\n\t\t\tvrrp->sockets = sock;\n\t}\n}\n\n/*\n * We create & allocate a socket pool here. The soft design\n * can be sum up by the following sketch :\n *\n *    fd1  fd2    fd3  fd4          fdi  fdi+1\n * -----\\__/--------\\__/---........---\\__/---\n *    | ETH0 |    | ETH1 |          | ETHn |\n *    +------+    +------+          +------+\n *\n * TODO TODO - this description is way out of date\n * Here we have n physical NIC. Each NIC own a maximum of 2 fds.\n * (one for VRRP the other for IPSEC_AH). All our VRRP instances\n * are multiplexed through this fds. So our design can handle 2*n\n * multiplexing points.\n */\nint\nvrrp_dispatcher_init(__attribute__((unused)) thread_t * thread)\n{\n\tvrrp_create_sockpool(vrrp_data->vrrp_socket_pool);\n\n\t/* open the VRRP socket pool */\n\tvrrp_open_sockpool(vrrp_data->vrrp_socket_pool);\n\n\t/* set VRRP instance fds to sockpool */\n\tvrrp_set_fds(vrrp_data->vrrp_socket_pool);\n\n\t/* create the VRRP socket pool list */\n\t/* register read dispatcher worker thread */\n\tvrrp_register_workers(vrrp_data->vrrp_socket_pool);\n\n\t/* Dump socket pool */\n\tif (__test_bit(LOG_DETAIL_BIT, &debug))\n\t\tdump_list(NULL, vrrp_data->vrrp_socket_pool);\n\n\tvrrp_initialised = true;\n\n\treturn 1;\n}\n\nvoid\nvrrp_dispatcher_release(vrrp_data_t *data)\n{\n\tfree_list(&data->vrrp_socket_pool);\n#ifdef _WITH_BFD_\n\tthread_cancel(bfd_thread);\n\tbfd_thread = NULL;\n#endif\n}\n\nstatic void\nvrrp_goto_master(vrrp_t * vrrp)\n{\n\t/* handle master state transition */\n\tvrrp->wantstate = VRRP_STATE_MAST;\n\tvrrp_state_goto_master(vrrp);\n}\n\n/* Delayed gratuitous ARP thread */\nint\nvrrp_gratuitous_arp_thread(thread_t * thread)\n{\n\tvrrp_t *vrrp = THREAD_ARG(thread);\n\n\t/* Simply broadcast the gratuitous ARP */\n\tvrrp_send_link_update(vrrp, vrrp->garp_rep);\n\n\treturn 0;\n}\n\n/* Delayed gratuitous ARP thread after receiving a lower priority advert */\nint\nvrrp_lower_prio_gratuitous_arp_thread(thread_t * thread)\n{\n\tvrrp_t *vrrp = THREAD_ARG(thread);\n\n\t/* Simply broadcast the gratuitous ARP */\n\tvrrp_send_link_update(vrrp, vrrp->garp_lower_prio_rep);\n\n\treturn 0;\n}\n\nstatic void\nvrrp_master(vrrp_t * vrrp)\n{\n\t/* Send the VRRP advert */\n\tvrrp_state_master_tx(vrrp);\n}\n\nvoid\ntry_up_instance(vrrp_t *vrrp, bool leaving_init)\n{\n\tint wantstate;\n\n\tif (leaving_init) {\n\t\tif (vrrp->num_script_if_fault)\n\t\t\treturn;\n\t}\n\telse if (--vrrp->num_script_if_fault || vrrp->num_script_init)\n\t\treturn;\n\n\tif (vrrp->wantstate == VRRP_STATE_MAST && vrrp->base_priority == VRRP_PRIO_OWNER) {\n\t\tvrrp->wantstate = VRRP_STATE_MAST;\n#ifdef _WITH_SNMP_RFCV3_\n\t\tvrrp->stats->next_master_reason = VRRPV3_MASTER_REASON_PREEMPTED;\n#endif\n\t} else {\n\t\tvrrp->wantstate = VRRP_STATE_BACK;\n#ifdef _WITH_SNMP_RFCV3_\n\t\tvrrp->stats->next_master_reason = VRRPV3_MASTER_REASON_MASTER_NO_RESPONSE;\n#endif\n\t}\n\n\tvrrp->master_adver_int = vrrp->adver_int;\n\tif (vrrp->wantstate == VRRP_STATE_MAST && vrrp->base_priority == VRRP_PRIO_OWNER)\n\t\tvrrp->ms_down_timer = vrrp->master_adver_int + VRRP_TIMER_SKEW(vrrp);\n\telse\n\t\tvrrp->ms_down_timer = 3 * vrrp->master_adver_int + VRRP_TIMER_SKEW(vrrp);\n\n\tif (vrrp->sync) {\n\t\tif (leaving_init) {\n\t\t\tif (vrrp->sync->num_member_fault)\n\t\t\t\treturn;\n\t\t}\n\t\telse if (--vrrp->sync->num_member_fault || vrrp->sync->num_member_init)\n\t\t\treturn;\n\t}\n\n\t/* If the sync group can't go to master, we must go to backup state */\n\twantstate = vrrp->wantstate;\n\tif (vrrp->sync && vrrp->wantstate == VRRP_STATE_MAST && !vrrp_sync_can_goto_master(vrrp))\n\t\tvrrp->wantstate = VRRP_STATE_BACK;\n\n\t/* We can come up */\n\tvrrp_state_leave_fault(vrrp);\n\n\tvrrp_init_instance_sands(vrrp);\n\tvrrp_thread_requeue_read(vrrp);\n\n\tvrrp->wantstate = wantstate;\n\n\tif (vrrp->sync) {\n\t\tif (vrrp->state == VRRP_STATE_MAST)\n\t\t\tvrrp_sync_master(vrrp);\n\t\telse\n\t\t\tvrrp_sync_backup(vrrp);\n\t}\n}\n\n#ifdef _WITH_BFD_\nstatic void\nvrrp_handle_bfd_event(bfd_event_t * evt)\n{\n\tvrrp_tracked_bfd_t *vbfd;\n\ttracking_vrrp_t *tbfd;\n\tvrrp_t * vrrp;\n\telement e, e1;\n\tstruct timeval time_now;\n\tstruct timeval timer_tmp;\n\tuint32_t delivery_time;\n\n\tif (__test_bit(LOG_DETAIL_BIT, &debug)) {\n\t\ttime_now = timer_now();\n\t\ttimersub(&time_now, &evt->sent_time, &timer_tmp);\n\t\tdelivery_time = timer_long(timer_tmp);\n\t\tlog_message(LOG_INFO, \"Received BFD event: instance %s is in\"\n\t\t\t    \" state %s (delivered in %i usec)\",\n\t\t\t    evt->iname, BFD_STATE_STR(evt->state), delivery_time);\n\t}\n\n\tLIST_FOREACH(vrrp_data->vrrp_track_bfds, vbfd, e) {\n\t\tif (strcmp(vbfd->bname, evt->iname))\n\t\t\tcontinue;\n\n\t\tif ((vbfd->bfd_up && evt->state == BFD_STATE_UP) ||\n\t\t    (!vbfd->bfd_up && evt->state == BFD_STATE_DOWN))\n\t\t\tcontinue;\n\n\t\tvbfd->bfd_up = (evt->state == BFD_STATE_UP);\n\n\t\tLIST_FOREACH(vbfd->tracking_vrrp, tbfd, e1) {\n\t\t\tvrrp = tbfd->vrrp;\n\n\t\t\tlog_message(LOG_INFO, \"VRRP_Instance(%s) Tracked BFD\"\n\t\t\t\t    \" instance %s is %s\", vrrp->iname, evt->iname, vbfd->bfd_up ? \"UP\" : \"DOWN\");\n\n\t\t\tif (tbfd->weight) {\n\t\t\t\tif (vbfd->bfd_up)\n\t\t\t\t\tvrrp->total_priority += abs(tbfd->weight);\n\t\t\t\telse\n\t\t\t\t\tvrrp->total_priority -= abs(tbfd->weight);\n\t\t\t\tvrrp_set_effective_priority(vrrp);\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (vbfd->bfd_up)\n\t\t\t\ttry_up_instance(vrrp, false);\n\t\t\telse\n\t\t\t\tdown_instance(vrrp);\n\t\t}\n\n\t\tbreak;\n\t}\n}\n\nstatic int\nvrrp_bfd_thread(thread_t * thread)\n{\n\tbfd_event_t evt;\n\n\tbfd_thread = thread_add_read(master, vrrp_bfd_thread, NULL,\n\t\t\t\t     thread->u.fd, TIMER_NEVER);\n\n\tif (thread->type != THREAD_READY_FD)\n\t\treturn 0;\n\n\twhile (read(thread->u.fd, &evt, sizeof(bfd_event_t)) != -1)\n\t\tvrrp_handle_bfd_event(&evt);\n\n\treturn 0;\n}\n#endif\n\n/* Handle dispatcher read timeout */\nstatic int\nvrrp_dispatcher_read_timeout(sock_t *sock)\n{\n\tvrrp_t *vrrp;\n\tint prev_state;\n\n\tset_time_now();\n\n\trb_for_each_entry_cached(vrrp, &sock->rb_sands, rb_sands) {\n\t\tif (vrrp->sands.tv_sec == TIMER_DISABLED ||\n\t\t    timercmp(&vrrp->sands, &time_now, >))\n\t\t\tbreak;\n\n\t\tprev_state = vrrp->state;\n\n\t\tif (vrrp->state == VRRP_STATE_BACK) {\n\t\t\tif (__test_bit(LOG_DETAIL_BIT, &debug))\n\t\t\t\tlog_message(LOG_INFO, \"(%s) Receive advertisement timeout\", vrrp->iname);\n\t\t\tvrrp_goto_master(vrrp);\n\t\t}\n\t\telse if (vrrp->state == VRRP_STATE_MAST)\n\t\t\tvrrp_master(vrrp);\n\n\t\t/* handle instance synchronization */\n#ifdef _TSM_DEBUG_\n\t\tif (do_tsm_debug)\n\t\t\tlog_message(LOG_INFO, \"Send [%s] TSM transition : [%d,%d] Wantstate = [%d]\",\n\t\t\t\tvrrp->iname, prev_state, vrrp->state, vrrp->wantstate);\n#endif\n\t\tVRRP_TSM_HANDLE(prev_state, vrrp);\n\n\t\tvrrp_init_instance_sands(vrrp);\n\t}\n\n\treturn sock->fd_in;\n}\n\n/* Handle dispatcher read packet */\nstatic int\nvrrp_dispatcher_read(sock_t * sock)\n{\n\tvrrp_t *vrrp;\n\tvrrphdr_t *hd;\n\tssize_t len = 0;\n\tint prev_state = 0;\n\tunsigned proto = 0;\n\tstruct sockaddr_storage src_addr;\n\tsocklen_t src_addr_len = sizeof(src_addr);\n\tvrrp_t vrrp_lookup;\n\n\t/* Clean the read buffer */\n\tmemset(vrrp_buffer, 0, vrrp_buffer_len);\n\n\t/* read & affect received buffer */\n\tlen = recvfrom(sock->fd_in, vrrp_buffer, vrrp_buffer_len, 0,\n\t\t       (struct sockaddr *) &src_addr, &src_addr_len);\n\thd = vrrp_get_header(sock->family, vrrp_buffer, &proto);\n\n\tvrrp_lookup.vrid = hd->vrid;\n\tvrrp = rb_search(&sock->rb_vrid, &vrrp_lookup, rb_vrid, vrrp_vrid_cmp);\n\n\t/* If no instance found => ignore the advert */\n\tif (!vrrp)\n\t\treturn sock->fd_in;\n\n\tif (vrrp->state == VRRP_STATE_FAULT ||\n\t    vrrp->state == VRRP_STATE_INIT) {\n\t\t/* We just ignore a message received when we are in fault state or\n\t\t * not yet fully initialised */\n\t\treturn sock->fd_in;\n\t}\n\n\tvrrp->pkt_saddr = src_addr;\n\n\tprev_state = vrrp->state;\n\n\tif (vrrp->state == VRRP_STATE_BACK)\n\t\tvrrp_state_backup(vrrp, vrrp_buffer, len);\n\telse if (vrrp->state == VRRP_STATE_MAST) {\n\t\tif (vrrp_state_master_rx(vrrp, vrrp_buffer, len))\n\t\t\tvrrp_state_leave_master(vrrp, false);\n\t} else\n\t\tlog_message(LOG_INFO, \"(%s) In dispatcher_read with state %d\", vrrp->iname, vrrp->state);\n\n\t/* handle instance synchronization */\n#ifdef _TSM_DEBUG_\n\tif (do_tsm_debug)\n\t\tlog_message(LOG_INFO, \"Read [%s] TSM transition : [%d,%d] Wantstate = [%d]\",\n\t\t\tvrrp->iname, prev_state, vrrp->state, vrrp->wantstate);\n#endif\n\tVRRP_TSM_HANDLE(prev_state, vrrp);\n\n\t/* If we have sent an advert, reset the timer */\n\tif (vrrp->state != VRRP_STATE_MAST || !vrrp->lower_prio_no_advert)\n\t\tvrrp_init_instance_sands(vrrp);\n\n\treturn sock->fd_in;\n}\n\n/* Our read packet dispatcher */\nstatic int\nvrrp_read_dispatcher_thread(thread_t * thread)\n{\n\tsock_t *sock;\n\tint fd;\n\n\t/* Fetch thread arg */\n\tsock = THREAD_ARG(thread);\n\n\t/* Dispatcher state handler */\n\tif (thread->type == THREAD_READ_TIMEOUT || sock->fd_in == -1)\n\t\tfd = vrrp_dispatcher_read_timeout(sock);\n\telse\n\t\tfd = vrrp_dispatcher_read(sock);\n\n\t/* register next dispatcher thread */\n\tif (fd != -1)\n\t\tsock->thread = thread_add_read_sands(thread->master, vrrp_read_dispatcher_thread,\n\t\t\t\t\t       sock, fd, vrrp_compute_timer(sock));\n\n\treturn 0;\n}\n\nstatic int\nvrrp_script_thread(thread_t * thread)\n{\n\tvrrp_script_t *vscript = THREAD_ARG(thread);\n\tint ret;\n\n\t/* Register next timer tracker */\n\tthread_add_timer(thread->master, vrrp_script_thread, vscript,\n\t\t\t vscript->interval);\n\n\tif (vscript->state != SCRIPT_STATE_IDLE) {\n\t\t/* We don't want the system to be overloaded with scripts that we are executing */\n\t\tlog_message(LOG_INFO, \"Track script %s is %s, expect idle - skipping run\",\n\t\t\t    vscript->sname, vscript->state == SCRIPT_STATE_RUNNING ? \"already running\" : \"being timed out\");\n\n\t\treturn 0;\n\t}\n\n\t/* Execute the script in a child process. Parent returns, child doesn't */\n\tret = system_call_script(thread->master, vrrp_script_child_thread,\n\t\t\t\t  vscript, (vscript->timeout) ? vscript->timeout : vscript->interval,\n\t\t\t\t  &vscript->script);\n\tif (!ret)\n\t\tvscript->state = SCRIPT_STATE_RUNNING;\n\n\treturn ret;\n}\n\nstatic int\nvrrp_script_child_thread(thread_t * thread)\n{\n\tint wait_status;\n\tpid_t pid;\n\tvrrp_script_t *vscript = THREAD_ARG(thread);\n\tint sig_num;\n\tunsigned timeout = 0;\n\tchar *script_exit_type = NULL;\n\tbool script_success;\n\tchar *reason = NULL;\n\tint reason_code;\n\n\tif (thread->type == THREAD_CHILD_TIMEOUT) {\n\t\tpid = THREAD_CHILD_PID(thread);\n\n\t\tif (vscript->state == SCRIPT_STATE_RUNNING) {\n\t\t\tvscript->state = SCRIPT_STATE_REQUESTING_TERMINATION;\n\t\t\tsig_num = SIGTERM;\n\t\t\ttimeout = 2;\n\t\t} else if (vscript->state == SCRIPT_STATE_REQUESTING_TERMINATION) {\n\t\t\tvscript->state = SCRIPT_STATE_FORCING_TERMINATION;\n\t\t\tsig_num = SIGKILL;\n\t\t\ttimeout = 2;\n\t\t} else if (vscript->state == SCRIPT_STATE_FORCING_TERMINATION) {\n\t\t\tlog_message(LOG_INFO, \"Child (PID %d) failed to terminate after kill\", pid);\n\t\t\tsig_num = SIGKILL;\n\t\t\ttimeout = 10;\t/* Give it longer to terminate */\n\t\t}\n\n\t\t/* Kill it off. */\n\t\tif (timeout) {\n\t\t\t/* If kill returns an error, we can't kill the process since either the process has terminated,\n\t\t\t * or we don't have permission. If we can't kill it, there is no point trying again. */\n\t\t\tif (kill(-pid, sig_num)) {\n\t\t\t\tif (errno == ESRCH) {\n\t\t\t\t\t/* The process does not exist; presumably it\n\t\t\t\t\t * has just terminated. We should get\n\t\t\t\t\t * notification of it's termination, so allow\n\t\t\t\t\t * that to handle it. */\n\t\t\t\t\ttimeout = 1;\n\t\t\t\t} else {\n\t\t\t\t\tlog_message(LOG_INFO, \"kill -%d of process %s(%d) with new state %d failed with errno %d\", sig_num, vscript->script.args[0], pid, vscript->state, errno);\n\t\t\t\t\ttimeout = 1000;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (vscript->state != SCRIPT_STATE_IDLE) {\n\t\t\tlog_message(LOG_INFO, \"Child thread pid %d timeout with unknown script state %d\", pid, vscript->state);\n\t\t\ttimeout = 10;\t/* We need some timeout */\n\t\t}\n\n\t\tif (timeout)\n\t\t\tthread_add_child(thread->master, vrrp_script_child_thread, vscript, pid, timeout * TIMER_HZ);\n\n\t\treturn 0;\n\t}\n\n\twait_status = THREAD_CHILD_STATUS(thread);\n\n\tif (WIFEXITED(wait_status)) {\n\t\tint status = WEXITSTATUS(wait_status);\n\n\t\t/* Report if status has changed */\n\t\tif (status != vscript->last_status)\n\t\t\tlog_message(LOG_INFO, \"Script `%s` now returning %d\", vscript->sname, status);\n\n\t\tif (status == 0) {\n\t\t\t/* success */\n\t\t\tscript_exit_type = \"succeeded\";\n\t\t\tscript_success = true;\n\t\t} else {\n\t\t\t/* failure */\n\t\t\tscript_exit_type = \"failed\";\n\t\t\tscript_success = false;\n\t\t\treason = \"exited with status\";\n\t\t\treason_code = status;\n\t\t}\n\n\t\tvscript->last_status = status;\n\t}\n\telse if (WIFSIGNALED(wait_status)) {\n\t\tif (vscript->state == SCRIPT_STATE_REQUESTING_TERMINATION && WTERMSIG(wait_status) == SIGTERM) {\n\t\t\t/* The script terminated due to a SIGTERM, and we sent it a SIGTERM to\n\t\t\t * terminate the process. Now make sure any children it created have\n\t\t\t * died too. */\n\t\t\tpid = THREAD_CHILD_PID(thread);\n\t\t\tkill(-pid, SIGKILL);\n\t\t}\n\n\t\t/* We treat forced termination as a failure */\n\t\tif ((vscript->state == SCRIPT_STATE_REQUESTING_TERMINATION && WTERMSIG(wait_status) == SIGTERM) ||\n\t\t    (vscript->state == SCRIPT_STATE_FORCING_TERMINATION && (WTERMSIG(wait_status) == SIGKILL || WTERMSIG(wait_status) == SIGTERM)))\n\t\t\tscript_exit_type = \"timed_out\";\n\t\telse {\n\t\t\tscript_exit_type = \"failed\";\n\t\t\treason = \"due to signal\";\n\t\t\treason_code = WTERMSIG(wait_status);\n\t\t}\n\t\tscript_success = false;\n\t}\n\n\tif (script_exit_type) {\n\t\tif (script_success) {\n\t\t\tif (vscript->result < vscript->rise - 1) {\n\t\t\t\tvscript->result++;\n\t\t\t} else if (vscript->result != vscript->rise + vscript->fall - 1) {\n\t\t\t\tif (vscript->result < vscript->rise) {\t/* i.e. == vscript->rise - 1 */\n\t\t\t\t\tlog_message(LOG_INFO, \"VRRP_Script(%s) %s\", vscript->sname, script_exit_type);\n\t\t\t\t\tupdate_script_priorities(vscript, true);\n\t\t\t\t}\n\t\t\t\tvscript->result = vscript->rise + vscript->fall - 1;\n\t\t\t}\n\t\t} else {\n\t\t\tif (vscript->result > vscript->rise) {\n\t\t\t\tvscript->result--;\n\t\t\t} else {\n\t\t\t\tif (vscript->result == vscript->rise ||\n\t\t\t\t    vscript->init_state == SCRIPT_INIT_STATE_INIT) {\n\t\t\t\t\tif (reason)\n\t\t\t\t\t\tlog_message(LOG_INFO, \"VRRP_Script(%s) %s (%s %d)\", vscript->sname, script_exit_type, reason, reason_code);\n\t\t\t\t\telse\n\t\t\t\t\t\tlog_message(LOG_INFO, \"VRRP_Script(%s) %s\", vscript->sname, script_exit_type);\n\t\t\t\t\tupdate_script_priorities(vscript, false);\n\t\t\t\t}\n\t\t\t\tvscript->result = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tvscript->state = SCRIPT_STATE_IDLE;\n\tvscript->init_state = SCRIPT_INIT_STATE_DONE;\n\n\treturn 0;\n}\n\n/* Delayed ARP/NA thread */\nint\nvrrp_arp_thread(thread_t *thread)\n{\n\telement e, a;\n\tlist l;\n\tip_address_t *ipaddress;\n\ttimeval_t next_time = {\n\t\t.tv_sec = INT_MAX\t/* We're never going to delay this long - I hope! */\n\t};\n\tinterface_t *ifp;\n\tvrrp_t *vrrp;\n\tenum {\n\t\tVIP,\n\t\tEVIP\n\t} i;\n\n\tset_time_now();\n\n\tfor (e = LIST_HEAD(vrrp_data->vrrp); e; ELEMENT_NEXT(e)) {\n\t\tvrrp = ELEMENT_DATA(e);\n\n\t\tif (!vrrp->garp_pending && !vrrp->gna_pending)\n\t\t\tcontinue;\n\n\t\tvrrp->garp_pending = false;\n\t\tvrrp->gna_pending = false;\n\n\t\tif (vrrp->state != VRRP_STATE_MAST ||\n\t\t    !vrrp->vipset)\n\t\t\tcontinue;\n\n\t\tfor (i = VIP; i <= EVIP; i++) {\n\t\t\tl = (i == VIP) ? vrrp->vip : vrrp->evip;\n\n\t\t\tif (!LIST_ISEMPTY(l)) {\n\t\t\t\tfor (a = LIST_HEAD(l); a; ELEMENT_NEXT(a)) {\n\t\t\t\t\tipaddress = ELEMENT_DATA(a);\n\t\t\t\t\tif (!ipaddress->garp_gna_pending)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (!ipaddress->set) {\n\t\t\t\t\t\tipaddress->garp_gna_pending = false;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tifp = IF_BASE_IFP(ipaddress->ifp);\n\n\t\t\t\t\t/* This should never happen */\n\t\t\t\t\tif (!ifp->garp_delay) {\n\t\t\t\t\t\tipaddress->garp_gna_pending = false;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!IP_IS6(ipaddress)) {\n\t\t\t\t\t\tif (timercmp(&time_now, &ifp->garp_delay->garp_next_time, >=)) {\n\t\t\t\t\t\t\tsend_gratuitous_arp_immediate(ifp, ipaddress);\n\t\t\t\t\t\t\tipaddress->garp_gna_pending = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tvrrp->garp_pending = true;\n\t\t\t\t\t\t\tif (timercmp(&ifp->garp_delay->garp_next_time, &next_time, <))\n\t\t\t\t\t\t\t\tnext_time = ifp->garp_delay->garp_next_time;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (timercmp(&time_now, &ifp->garp_delay->gna_next_time, >=)) {\n\t\t\t\t\t\t\tndisc_send_unsolicited_na_immediate(ifp, ipaddress);\n\t\t\t\t\t\t\tipaddress->garp_gna_pending = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tvrrp->gna_pending = true;\n\t\t\t\t\t\t\tif (timercmp(&ifp->garp_delay->gna_next_time, &next_time, <))\n\t\t\t\t\t\t\t\tnext_time = ifp->garp_delay->gna_next_time;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (next_time.tv_sec != INT_MAX) {\n\t\t/* Register next timer tracker */\n\t\tgarp_next_time = next_time;\n\n\t\tgarp_thread = thread_add_timer(thread->master, vrrp_arp_thread, NULL,\n\t\t\t\t\t\t timer_long(timer_sub_now(next_time)));\n\t}\n\telse\n\t\tgarp_thread = NULL;\n\n\treturn 0;\n}\n\n#ifdef _WITH_DUMP_THREADS_\nvoid\ndump_threads(void)\n{\n\tFILE *fp;\n\tchar time_buf[26];\n\telement e;\n\tvrrp_t *vrrp;\n\tchar *file_name;\n\n\tfile_name = make_file_name(\"/tmp/thread_dump.dat\",\n\t\t\t\t\t\"vrrp\",\n#if HAVE_DECL_CLONE_NEWNET\n\t\t\t\t\tglobal_data->network_namespace,\n#else\n\t\t\t\t\tNULL,\n#endif\n\t\t\t\t\tglobal_data->instance_name);\n\tfp = fopen_safe(file_name, \"a\");\n\tFREE(file_name);\n\n\tset_time_now();\n\tctime_r(&time_now.tv_sec, time_buf);\n\n\tfprintf(fp, \"\\n%.19s.%6.6ld: Thread dump\\n\", time_buf, time_now.tv_usec);\n\n\tdump_thread_data(master, fp);\n\n\tfprintf(fp, \"alloc = %lu\\n\", master->alloc);\n\n\tfprintf(fp, \"\\n\");\n\tLIST_FOREACH(vrrp_data->vrrp, vrrp, e) {\n\t\tctime_r(&vrrp->sands.tv_sec, time_buf);\n\t\tfprintf(fp, \"VRRP instance %s, sands %.19s.%6.6lu, status %s\\n\", vrrp->iname, time_buf, vrrp->sands.tv_usec,\n\t\t\t\tvrrp->state == VRRP_STATE_INIT ? \"INIT\" :\n\t\t\t\tvrrp->state == VRRP_STATE_BACK ? \"BACKUP\" :\n\t\t\t\tvrrp->state == VRRP_STATE_MAST ? \"MASTER\" :\n\t\t\t\tvrrp->state == VRRP_STATE_FAULT ? \"FAULT\" :\n\t\t\t\tvrrp->state == VRRP_STATE_STOP ? \"STOP\" :\n\t\t\t\tvrrp->state == VRRP_DISPATCHER ? \"DISPATCHER\" : \"unknown\");\n\t}\n\tfclose(fp);\n}\n#endif\n\n#ifdef THREAD_DUMP\nvoid\nregister_vrrp_scheduler_addresses(void)\n{\n\tregister_thread_address(\"vrrp_arp_thread\", vrrp_arp_thread);\n\tregister_thread_address(\"vrrp_dispatcher_init\", vrrp_dispatcher_init);\n\tregister_thread_address(\"vrrp_gratuitous_arp_thread\", vrrp_gratuitous_arp_thread);\n\tregister_thread_address(\"vrrp_lower_prio_gratuitous_arp_thread\", vrrp_lower_prio_gratuitous_arp_thread);\n\tregister_thread_address(\"vrrp_script_child_thread\", vrrp_script_child_thread);\n\tregister_thread_address(\"vrrp_script_thread\", vrrp_script_thread);\n\tregister_thread_address(\"vrrp_read_dispatcher_thread\", vrrp_read_dispatcher_thread);\n#ifdef _WITH_BFD_\n\tregister_thread_address(\"vrrp_bfd_thread\", vrrp_bfd_thread);\n#endif\n}\n#endif\n", "/*\n * Soft:        Keepalived is a failover program for the LVS project\n *              <www.linuxvirtualserver.org>. It monitor & manipulate\n *              a loadbalanced server pool using multi-layer checks.\n *\n * Part:        logging facility.\n *\n * Author:      Alexandre Cassen, <acassen@linux-vs.org>\n *\n *              This program is distributed in the hope that it will be useful,\n *              but WITHOUT ANY WARRANTY; without even the implied warranty of\n *              MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n *              See the GNU General Public License for more details.\n *\n *              This program is free software; you can redistribute it and/or\n *              modify it under the terms of the GNU General Public License\n *              as published by the Free Software Foundation; either version\n *              2 of the License, or (at your option) any later version.\n *\n * Copyright (C) 2001-2017 Alexandre Cassen, <acassen@gmail.com>\n */\n\n#include \"config.h\"\n\n#include <stdio.h>\n#include <stdbool.h>\n#include <time.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <string.h>\n#include <memory.h>\n\n#include \"logger.h\"\n#include \"bitops.h\"\n#include \"utils.h\"\n\n/* Boolean flag - send messages to console as well as syslog */\nstatic bool log_console = false;\n\n/* File to write log messages to */\nchar *log_file_name;\nstatic FILE *log_file;\nbool always_flush_log_file;\n\nvoid\nenable_console_log(void)\n{\n\tlog_console = true;\n}\n\nvoid\nset_flush_log_file(void)\n{\n\talways_flush_log_file = true;\n}\n\nvoid\nclose_log_file(void)\n{\n\tif (log_file) {\n\t\tfclose(log_file);\n\t\tlog_file = NULL;\n\t}\n}\n\nvoid\nopen_log_file(const char *name, const char *prog, const char *namespace, const char *instance)\n{\n\tchar *file_name;\n\n\tif (log_file) {\n\t\tfclose(log_file);\n\t\tlog_file = NULL;\n\t}\n\n\tif (!name)\n\t\treturn;\n\n\tfile_name = make_file_name(name, prog, namespace, instance);\n\n\tlog_file = fopen_safe(file_name, \"a\");\n\tif (log_file) {\n\t\tint n = fileno(log_file);\n\t\tfcntl(n, F_SETFD, FD_CLOEXEC | fcntl(n, F_GETFD));\n\t\tfcntl(n, F_SETFL, O_NONBLOCK | fcntl(n, F_GETFL));\n\t}\n\n\tFREE(file_name);\n}\n\nvoid\nflush_log_file(void)\n{\n\tif (log_file)\n\t\tfflush(log_file);\n}\n\nvoid\nvlog_message(const int facility, const char* format, va_list args)\n{\n#if !HAVE_VSYSLOG\n\tchar buf[MAX_LOG_MSG+1];\n\n\tvsnprintf(buf, sizeof(buf), format, args);\n#endif\n\n\t/* Don't write syslog if testing configuration */\n\tif (__test_bit(CONFIG_TEST_BIT, &debug))\n\t\treturn;\n\n\tif (log_file || (__test_bit(DONT_FORK_BIT, &debug) && log_console)) {\n#if HAVE_VSYSLOG\n\t\tva_list args1;\n\t\tchar buf[2 * MAX_LOG_MSG + 1];\n\n\t\tva_copy(args1, args);\n\t\tvsnprintf(buf, sizeof(buf), format, args1);\n\t\tva_end(args1);\n#endif\n\n\t\t/* timestamp setup */\n\t\ttime_t t = time(NULL);\n\t\tstruct tm tm;\n\t\tlocaltime_r(&t, &tm);\n\t\tchar timestamp[64];\n\t\tstrftime(timestamp, sizeof(timestamp), \"%c\", &tm);\n\n\t\tif (log_console && __test_bit(DONT_FORK_BIT, &debug))\n\t\t\tfprintf(stderr, \"%s: %s\\n\", timestamp, buf);\n\t\tif (log_file) {\n\t\t\tfprintf(log_file, \"%s: %s\\n\", timestamp, buf);\n\t\t\tif (always_flush_log_file)\n\t\t\t\tfflush(log_file);\n\t\t}\n\t}\n\n\tif (!__test_bit(NO_SYSLOG_BIT, &debug))\n#if HAVE_VSYSLOG\n\t\tvsyslog(facility, format, args);\n#else\n\t\tsyslog(facility, \"%s\", buf);\n#endif\n}\n\nvoid\nlog_message(const int facility, const char *format, ...)\n{\n\tva_list args;\n\n\tva_start(args, format);\n\tvlog_message(facility, format, args);\n\tva_end(args);\n}\n\nvoid\nconf_write(FILE *fp, const char *format, ...)\n{\n\tva_list args;\n\n\tva_start(args, format);\n\tif (fp) {\n\t\tvfprintf(fp, format, args);\n\t\tfprintf(fp, \"\\n\");\n\t}\n\telse\n\t\tvlog_message(LOG_INFO, format, args);\n\n\tva_end(args);\n}\n", "/*\n * Soft:        Keepalived is a failover program for the LVS project\n *              <www.linuxvirtualserver.org>. It monitor & manipulate\n *              a loadbalanced server pool using multi-layer checks.\n *\n * Part:        Memory management framework. This framework is used to\n *              find any memory leak.\n *\n * Authors:     Alexandre Cassen, <acassen@linux-vs.org>\n *              Jan Holmberg, <jan@artech.net>\n *\n *              This program is distributed in the hope that it will be useful,\n *              but WITHOUT ANY WARRANTY; without even the implied warranty of\n *              MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n *              See the GNU General Public License for more details.\n *\n *              This program is free software; you can redistribute it and/or\n *              modify it under the terms of the GNU General Public License\n *              as published by the Free Software Foundation; either version\n *              2 of the License, or (at your option) any later version.\n *\n * Copyright (C) 2001-2017 Alexandre Cassen, <acassen@gmail.com>\n */\n\n#include \"config.h\"\n\n#ifdef _MEM_CHECK_\n#include <assert.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <stdlib.h>\n#include <time.h>\n#include <limits.h>\n#endif\n\n#include <errno.h>\n#include <string.h>\n\n#include \"memory.h\"\n#include \"utils.h\"\n#include \"bitops.h\"\n#include \"logger.h\"\n\n#ifdef _MEM_CHECK_\n#include \"timer.h\"\n#include \"rbtree.h\"\n#include \"list_head.h\"\n\n/* Global var */\nsize_t mem_allocated;\t\t\t/* Total memory used in Bytes */\nstatic size_t max_mem_allocated;\t/* Maximum memory used in Bytes */\n\nstatic const char *terminate_banner;\t/* banner string for report file */\n\nstatic bool skip_mem_check_final;\n#endif\n\nstatic void *\nxalloc(unsigned long size)\n{\n\tvoid *mem = malloc(size);\n\n\tif (mem == NULL) {\n\t\tif (__test_bit(DONT_FORK_BIT, &debug))\n\t\t\tperror(\"Keepalived\");\n\t\telse\n\t\t\tlog_message(LOG_INFO, \"Keepalived xalloc() error - %s\", strerror(errno));\n\t\texit(EXIT_FAILURE);\n\t}\n\n#ifdef _MEM_CHECK_\n\tmem_allocated += size - sizeof(long);\n\tif (mem_allocated > max_mem_allocated)\n\t\tmax_mem_allocated = mem_allocated;\n#endif\n\n\treturn mem;\n}\n\nvoid *\nzalloc(unsigned long size)\n{\n\tvoid *mem = xalloc(size);\n\n\tif (mem)\n\t\tmemset(mem, 0, size);\n\n\treturn mem;\n}\n\n/* KeepAlived memory management. in debug mode,\n * help finding eventual memory leak.\n * Allocation memory types manipulated are :\n *\n * +-type------------------+-meaning------------------+\n * ! FREE_SLOT             ! Free slot                !\n * ! OVERRUN               ! Overrun                  !\n * ! FREE_NULL             ! free null                !\n * ! REALLOC_NULL          ! realloc null             !\n * ! DOUBLE_FREE           ! double free              !\n * ! REALLOC_DOUBLE_FREE   ! realloc freed block      !\n * ! FREE_NOT_ALLOC        ! Not previously allocated !\n * ! REALLOC_NOT_ALLOC     ! Not previously allocated !\n * ! MALLOC_ZERO_SIZE      ! malloc with size 0       !\n * ! REALLOC_ZERO_SIZE     ! realloc with size 0      !\n * ! LAST_FREE             ! Last free list           !\n * ! ALLOCATED             ! Allocated                !\n * +-----------------------+--------------------------+\n *\n * global variable debug bit MEM_ERR_DETECT_BIT used to\n * flag some memory error.\n *\n */\n\n#ifdef _MEM_CHECK_\n\nenum slot_type {\n\tFREE_SLOT = 0,\n\tOVERRUN,\n\tFREE_NULL,\n\tREALLOC_NULL,\n\tDOUBLE_FREE,\n\tREALLOC_DOUBLE_FREE,\n\tFREE_NOT_ALLOC,\n\tREALLOC_NOT_ALLOC,\n\tMALLOC_ZERO_SIZE,\n\tREALLOC_ZERO_SIZE,\n\tLAST_FREE,\n\tALLOCATED,\n} ;\n\n#define TIME_STR_LEN\t9\n\n#if ULONG_MAX == 0xffffffffffffffffUL\n#define CHECK_VAL\t0xa5a55a5aa5a55a5aUL\n#elif ULONG_MAX == 0xffffffffUL\n#define CHECK_VAL\t0xa5a55a5aUL\n#else\n#define CHECK_VAL\t0xa5a5\n#endif\n\n#define FREE_LIST_SIZE\t256\n\ntypedef struct {\n\tenum slot_type type;\n\tint line;\n\tconst char *func;\n\tconst char *file;\n\tvoid *ptr;\n\tsize_t size;\n\tunion {\n\t\tlist_head_t l;\t/* When on free list */\n\t\trb_node_t t;\n\t};\n\tunsigned seq_num;\n} MEMCHECK;\n\n/* Last free pointers */\nstatic LH_LIST_HEAD(free_list);\nstatic unsigned free_list_size;\n\n/* alloc_list entries used for 1000 VRRP instance each with VMAC interfaces is 33589 */\nstatic rb_root_t alloc_list = RB_ROOT;\nstatic LH_LIST_HEAD(bad_list);\n\nstatic unsigned number_alloc_list;\t/* number of alloc_list allocation entries */\nstatic unsigned max_alloc_list;\nstatic unsigned num_mallocs;\nstatic unsigned num_reallocs;\nstatic unsigned seq_num;\n\nstatic FILE *log_op = NULL;\n\nstatic inline int\nmemcheck_ptr_cmp(MEMCHECK *m1, MEMCHECK *m2)\n{\n\treturn m1->ptr - m2->ptr;\n}\n\nstatic inline int\nmemcheck_seq_cmp(MEMCHECK *m1, MEMCHECK *m2)\n{\n\treturn m1->seq_num - m2->seq_num;\n}\n\nstatic const char *\nformat_time(void)\n{\n\tstatic char time_buf[TIME_STR_LEN+1];\n\n\tstrftime(time_buf, sizeof time_buf, \"%T \", localtime(&time_now.tv_sec));\n\n\treturn time_buf;\n}\n\nvoid\nmemcheck_log(const char *called_func, const char *param, const char *file, const char *function, int line)\n{\n\tint len = strlen(called_func) + (param ? strlen(param) : 0);\n\n\tif ((len = 36 - len) < 0)\n\t\tlen = 0;\n\n\tfprintf(log_op, \"%s%*s%s(%s) at %s, %d, %s\\n\",\n\t       format_time(), len, \"\", called_func, param ? param : \"\", file, line, function);\n}\n\nstatic MEMCHECK *\nget_free_alloc_entry(void)\n{\n\tMEMCHECK *entry;\n\n\t/* If number on free list < 256, allocate new entry, otherwise take head */\n\tif (free_list_size < 256)\n\t\tentry = malloc(sizeof *entry);\n\telse {\n\t\tentry = list_first_entry(&free_list, MEMCHECK, l);\n\t\tlist_head_del(&entry->l);\n\t\tfree_list_size--;\n\t}\n\n\tentry->seq_num = seq_num++;\n\n\treturn entry;\n}\n\nvoid *\nkeepalived_malloc(size_t size, const char *file, const char *function, int line)\n{\n\tvoid *buf;\n\tMEMCHECK *entry, *entry2;\n\n\tbuf = zalloc(size + sizeof (unsigned long));\n\n\t*(unsigned long *) ((char *) buf + size) = size + CHECK_VAL;\n\n\tentry = get_free_alloc_entry();\n\n\tentry->ptr = buf;\n\tentry->size = size;\n\tentry->file = file;\n\tentry->func = function;\n\tentry->line = line;\n\tentry->type = ALLOCATED;\n\n\trb_insert_sort(&alloc_list, entry, t, memcheck_ptr_cmp);\n\tif (++number_alloc_list > max_alloc_list)\n\t\tmax_alloc_list = number_alloc_list;\n\n\tfprintf(log_op, \"%szalloc [%3d:%3d], %9p, %4zu at %s, %3d, %s%s\\n\",\n\t       format_time(), entry->seq_num, number_alloc_list, buf, size, file, line, function, !size ? \" - size is 0\" : \"\");\n#ifdef _MEM_CHECK_LOG_\n\tif (__test_bit(MEM_CHECK_LOG_BIT, &debug))\n\t\tlog_message(LOG_INFO, \"zalloc[%3d:%3d], %9p, %4zu at %s, %3d, %s\",\n\t\t       entry->seq_num, number_alloc_list, buf, size, file, line, function);\n#endif\n\n\tnum_mallocs++;\n\n\tif (!size) {\n\t\t/* Record malloc with 0 size */\n\t\tentry2 = get_free_alloc_entry();\n\t\t*entry2 = *entry;\n\t\tentry2->type = MALLOC_ZERO_SIZE;\n\t\tlist_add_tail(&entry2->l, &bad_list);\n\t}\n\n\treturn buf;\n}\n\nstatic void *\nkeepalived_free_realloc_common(void *buffer, size_t size, const char *file, const char *function, int line, bool is_realloc)\n{\n\tunsigned long check;\n\tMEMCHECK *entry, *entry2, *le;\n\tMEMCHECK search = {.ptr = buffer};\n\n\t/* If nullpointer remember */\n\tif (buffer == NULL) {\n\t\tentry = get_free_alloc_entry();\n\n\t\tentry->ptr = NULL;\n\t\tentry->size = size;\n\t\tentry->file = file;\n\t\tentry->func = function;\n\t\tentry->line = line;\n\t\tentry->type = !size ? FREE_NULL : REALLOC_NULL;\n\n\t\tif (!is_realloc)\n\t\t\tfprintf(log_op, \"%s%-7s%9s, %9s, %4s at %s, %3d, %s\\n\", format_time(),\n\t\t\t\t\"free\", \"ERROR\", \"NULL\", \"\",\n\t\t\t\tfile, line, function);\n\t\telse\n\t\t\tfprintf(log_op, \"%s%-7s%9s, %9s, %4zu at %s, %3d, %s%s\\n\", format_time(),\n\t\t\t\t\"realloc\", \"ERROR\", \"NULL\",\n\t\t\t\tsize, file, line, function, size ? \" *** converted to malloc\" : \"\");\n\n\t\t__set_bit(MEM_ERR_DETECT_BIT, &debug);\n\n\t\tlist_add_tail(&entry->l, &bad_list);\n\n\t\treturn !size ? NULL : keepalived_malloc(size, file, function, line);\n\t}\n\n\tentry = rb_search(&alloc_list, &search, t, memcheck_ptr_cmp);\n\n\t/* Not found */\n\tif (!entry) {\n\t\tentry = get_free_alloc_entry();\n\n\t\tentry->ptr = buffer;\n\t\tentry->size = size;\n\t\tentry->file = file;\n\t\tentry->func = function;\n\t\tentry->line = line;\n\t\tentry->type = !size ? FREE_NOT_ALLOC : REALLOC_NOT_ALLOC;\n\t\tentry->seq_num = seq_num++;\n\n\t\tif (!is_realloc)\n\t\t\tfprintf(log_op, \"%s%-7s%9s, %9p,      at %s, %3d, %s - not found\\n\", format_time(),\n\t\t\t\t\"free\", \"ERROR\",\n\t\t\t\tbuffer, file, line, function);\n\t\telse\n\t\t\tfprintf(log_op, \"%s%-7s%9s, %9p, %4zu at %s, %3d, %s - not found\\n\", format_time(),\n\t\t\t\t\"realloc\", \"ERROR\",\n\t\t\t\tbuffer, size, file, line, function);\n\n\t\t__set_bit(MEM_ERR_DETECT_BIT, &debug);\n\n\t\tlist_for_each_entry_reverse(le, &free_list, l) {\n\t\t\tif (le->ptr == buffer &&\n\t\t\t    le->type == LAST_FREE) {\n\t\t\t\tfprintf\n\t\t\t\t    (log_op, \"%11s-> pointer last released at [%3d:%3d], at %s, %3d, %s\\n\",\n\t\t\t\t     \"\", le->seq_num, number_alloc_list,\n\t\t\t\t     le->file, le->line,\n\t\t\t\t     le->func);\n\n\t\t\t\tentry->type = !size ? DOUBLE_FREE : REALLOC_DOUBLE_FREE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t};\n\n\t\tlist_add_tail(&entry->l, &bad_list);\n\n\t\treturn NULL;\n\t}\n\n\tcheck = entry->size + CHECK_VAL;\n\tif (*(unsigned long *)((char *)buffer + entry->size) != check) {\n\t\tentry2 = get_free_alloc_entry();\n\n\t\t*entry2 = *entry;\n\t\tentry2->type = OVERRUN;\n\t\tlist_add_tail(&entry2->l, &bad_list);\n\n\t\tfprintf(log_op, \"%s%s corrupt, buffer overrun [%3d:%3d], %9p, %4zu at %s, %3d, %s\\n\",\n\t\t       format_time(), !is_realloc ? \"free\" : \"realloc\",\n\t\t       entry->seq_num, number_alloc_list, buffer,\n\t\t       entry->size, file,\n\t\t       line, function);\n\t\tdump_buffer(entry->ptr,\n\t\t\t    entry->size + sizeof (check), log_op, TIME_STR_LEN);\n\t\tfprintf(log_op, \"%*sCheck_sum\\n\", TIME_STR_LEN, \"\");\n\t\tdump_buffer((char *) &check,\n\t\t\t    sizeof(check), log_op, TIME_STR_LEN);\n\n\t\t__set_bit(MEM_ERR_DETECT_BIT, &debug);\n\t}\n\n\tmem_allocated -= entry->size;\n\n\tif (!size) {\n\t\tfree(buffer);\n\n\t\tif (is_realloc) {\n\t\t\tfprintf(log_op, \"%s%-7s[%3d:%3d], %9p, %4zu at %s, %3d, %s -> %9s, %4s at %s, %3d, %s\\n\",\n\t\t\t       format_time(), \"realloc\", entry->seq_num,\n\t\t\t       number_alloc_list, entry->ptr,\n\t\t\t       entry->size, entry->file,\n\t\t\t       entry->line, entry->func,\n\t\t\t       \"made free\", \"\", file, line, function);\n\n\t\t\t/* Record bad realloc */\n\t\t\tentry2 = get_free_alloc_entry();\n\t\t\t*entry2 = *entry;\n\t\t\tentry2->type = REALLOC_ZERO_SIZE;\n\t\t\tentry2->file = file;\n\t\t\tentry2->line = line;\n\t\t\tentry2->func = function;\n\t\t\tlist_add_tail(&entry2->l, &bad_list);\n\t\t}\n\t\telse\n\t\t\tfprintf(log_op, \"%s%-7s[%3d:%3d], %9p, %4zu at %s, %3d, %s -> %9s, %4s at %s, %3d, %s\\n\",\n\t\t\t       format_time(), \"free\", entry->seq_num,\n\t\t\t       number_alloc_list, entry->ptr,\n\t\t\t       entry->size, entry->file,\n\t\t\t       entry->line, entry->func,\n\t\t\t       \"NULL\", \"\", file, line, function);\n#ifdef _MEM_CHECK_LOG_\n\t\tif (__test_bit(MEM_CHECK_LOG_BIT, &debug))\n\t\t\tlog_message(LOG_INFO, \"%-7s[%3d:%3d], %9p, %4zu at %s, %3d, %s\",\n\t\t\t       is_realloc ? \"realloc\" : \"free\",\n\t\t\t       entry->seq_num, number_alloc_list, buffer,\n\t\t\t       entry->size, file, line, function);\n#endif\n\n\t\tentry->file = file;\n\t\tentry->line = line;\n\t\tentry->func = function;\n\t\tentry->type = LAST_FREE;\n\n\t\trb_erase(&entry->t, &alloc_list);\n\t\tlist_add_tail(&entry->l, &free_list);\n\t\tfree_list_size++;\n\n\t\tnumber_alloc_list--;\n\n\t\treturn NULL;\n\t}\n\n\tbuffer = realloc(buffer, size + sizeof (unsigned long));\n\tmem_allocated += size;\n\n\tif (mem_allocated > max_mem_allocated)\n\t\tmax_mem_allocated = mem_allocated;\n\n\tfprintf(log_op, \"%srealloc[%3d:%3d], %9p, %4zu at %s, %3d, %s -> %9p, %4zu at %s, %3d, %s\\n\",\n\t       format_time(), entry->seq_num,\n\t       number_alloc_list, entry->ptr,\n\t       entry->size, entry->file,\n\t       entry->line, entry->func,\n\t       buffer, size, file, line, function);\n#ifdef _MEM_CHECK_LOG_\n\tif (__test_bit(MEM_CHECK_LOG_BIT, &debug))\n\t\tlog_message(LOG_INFO, \"realloc[%3d:%3d], %9p, %4zu at %s, %3d, %s -> %9p, %4zu at %s, %3d, %s\",\n\t\t       entry->seq_num, number_alloc_list, entry->ptr,\n\t\t       entry->size, entry->file,\n\t\t       entry->line, entry->func,\n\t\t       buffer, size, file, line, function);\n#endif\n\n\t*(unsigned long *) ((char *) buffer + size) = size + CHECK_VAL;\n\n\tif (entry->ptr != buffer) {\n\t\trb_erase(&entry->t, &alloc_list);\n\t\tentry->ptr = buffer;\n\t\trb_insert_sort(&alloc_list, entry, t, memcheck_ptr_cmp);\n\t} else\n\t\tentry->ptr = buffer;\n\tentry->size = size;\n\tentry->file = file;\n\tentry->line = line;\n\tentry->func = function;\n\n\tnum_reallocs++;\n\n\treturn buffer;\n}\n\nvoid\nkeepalived_free(void *buffer, const char *file, const char *function, int line)\n{\n\tkeepalived_free_realloc_common(buffer, 0, file, function, line, false);\n}\n\nvoid *\nkeepalived_realloc(void *buffer, size_t size, const char *file,\n\t\t   const char *function, int line)\n{\n\treturn keepalived_free_realloc_common(buffer, size, file, function, line, true);\n}\n\nstatic void\nkeepalived_alloc_log(bool final)\n{\n\tunsigned int overrun = 0, badptr = 0, zero_size = 0;\n\tsize_t sum = 0;\n\tMEMCHECK *entry;\n\n\tif (final) {\n\t\t/* If this is a forked child, we don't want the dump */\n\t\tif (skip_mem_check_final)\n\t\t\treturn;\n\n\t\tfprintf(log_op, \"\\n---[ Keepalived memory dump for (%s) ]---\\n\\n\", terminate_banner);\n\t}\n\telse\n\t\tfprintf(log_op, \"\\n---[ Keepalived memory dump for (%s) at %s ]---\\n\\n\", terminate_banner, format_time());\n\n\t/* List the blocks currently allocated */\n\tif (!RB_EMPTY_ROOT(&alloc_list)) {\n\t\tfprintf(log_op, \"Entries %s\\n\\n\", final ? \"not released\" : \"currently allocated\");\n\t\trb_for_each_entry(entry, &alloc_list, t) {\n\t\t\tsum += entry->size;\n\t\t\tfprintf(log_op, \"%9p [%3d:%3d], %4zu at %s, %3d, %s\",\n\t\t\t       entry->ptr, entry->seq_num, number_alloc_list,\n\t\t\t       entry->size, entry->file, entry->line, entry->func);\n\t\t\tif (entry->type != ALLOCATED)\n\t\t\t\tfprintf(log_op, \" type = %d\", entry->type);\n\t\t\tfprintf(log_op, \"\\n\");\n\t\t}\n\t}\n\n\tif (!list_empty(&bad_list)) {\n\t\tif (!RB_EMPTY_ROOT(&alloc_list))\n\t\t\tfprintf(log_op, \"\\n\");\n\t\tfprintf(log_op, \"Bad entry list\\n\\n\");\n\n\t\tlist_for_each_entry(entry, &bad_list, l) {\n\t\t\tswitch (entry->type) {\n\t\t\tcase FREE_NULL:\n\t\t\t\tbadptr++;\n\t\t\t\tfprintf(log_op, \"%9s %9s, %4s at %s, %3d, %s - null pointer to free\\n\",\n\t\t\t\t       \"NULL\", \"\", \"\", entry->file, entry->line, entry->func);\n\t\t\t\tbreak;\n\t\t\tcase REALLOC_NULL:\n\t\t\t\tbadptr++;\n\t\t\t\tfprintf(log_op, \"%9s %9s, %4zu at %s, %3d, %s - null pointer to realloc (converted to malloc)\\n\",\n\t\t\t\t     \"NULL\", \"\", entry->size, entry->file, entry->line, entry->func);\n\t\t\t\tbreak;\n\t\t\tcase FREE_NOT_ALLOC:\n\t\t\t\tbadptr++;\n\t\t\t\tfprintf(log_op, \"%9p %9s, %4s at %s, %3d, %s - pointer not found for free\\n\",\n\t\t\t\t     entry->ptr, \"\", \"\", entry->file, entry->line, entry->func);\n\t\t\t\tbreak;\n\t\t\tcase REALLOC_NOT_ALLOC:\n\t\t\t\tbadptr++;\n\t\t\t\tfprintf(log_op, \"%9p %9s, %4zu at %s, %3d, %s - pointer not found for realloc\\n\",\n\t\t\t\t     entry->ptr, \"\", entry->size, entry->file, entry->line, entry->func);\n\t\t\t\tbreak;\n\t\t\tcase DOUBLE_FREE:\n\t\t\t\tbadptr++;\n\t\t\t\tfprintf(log_op, \"%9p %9s, %4s at %s, %3d, %s - double free of pointer\\n\",\n\t\t\t\t     entry->ptr, \"\", \"\", entry->file, entry->line, entry->func);\n\t\t\t\tbreak;\n\t\t\tcase REALLOC_DOUBLE_FREE:\n\t\t\t\tbadptr++;\n\t\t\t\tfprintf(log_op, \"%9p %9s, %4zu at %s, %3d, %s - realloc 0 size already freed\\n\",\n\t\t\t\t     entry->ptr, \"\", entry->size, entry->file, entry->line, entry->func);\n\t\t\t\tbreak;\n\t\t\tcase OVERRUN:\n\t\t\t\toverrun++;\n\t\t\t\tfprintf(log_op, \"%9p [%3d:%3d], %4zu at %s, %3d, %s - buffer overrun\\n\",\n\t\t\t\t       entry->ptr, entry->seq_num, number_alloc_list,\n\t\t\t\t       entry->size, entry->file, entry->line, entry->func);\n\t\t\t\tbreak;\n\t\t\tcase MALLOC_ZERO_SIZE:\n\t\t\t\tzero_size++;\n\t\t\t\tfprintf(log_op, \"%9p [%3d:%3d], %4zu at %s, %3d, %s - malloc zero size\\n\",\n\t\t\t\t       entry->ptr, entry->seq_num, number_alloc_list,\n\t\t\t\t       entry->size, entry->file, entry->line, entry->func);\n\t\t\t\tbreak;\n\t\t\tcase REALLOC_ZERO_SIZE:\n\t\t\t\tzero_size++;\n\t\t\t\tfprintf(log_op, \"%9p [%3d:%3d], %4zu at %s, %3d, %s - realloc zero size (handled as free)\\n\",\n\t\t\t\t       entry->ptr, entry->seq_num, number_alloc_list,\n\t\t\t\t       entry->size, entry->file, entry->line, entry->func);\n\t\t\t\tbreak;\n\t\t\tcase ALLOCATED:\t/* not used - avoid compiler warning */\n\t\t\tcase FREE_SLOT:\n\t\t\tcase LAST_FREE:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tfprintf(log_op, \"\\n\\n---[ Keepalived memory dump summary for (%s) ]---\\n\", terminate_banner);\n\tfprintf(log_op, \"Total number of bytes %s...: %zu\\n\", final ? \"not freed\" : \"allocated\", sum);\n\tfprintf(log_op, \"Number of entries %s.......: %d\\n\", final ? \"not freed\" : \"allocated\", number_alloc_list);\n\tfprintf(log_op, \"Maximum allocated entries.........: %d\\n\", max_alloc_list);\n\tfprintf(log_op, \"Maximum memory allocated..........: %zu\\n\", max_mem_allocated);\n\tfprintf(log_op, \"Number of mallocs.................: %d\\n\", num_mallocs);\n\tfprintf(log_op, \"Number of reallocs................: %d\\n\", num_reallocs);\n\tfprintf(log_op, \"Number of bad entries.............: %d\\n\", badptr);\n\tfprintf(log_op, \"Number of buffer overrun..........: %d\\n\", overrun);\n\tfprintf(log_op, \"Number of 0 size allocations......: %d\\n\\n\", zero_size);\n\tif (sum != mem_allocated)\n\t\tfprintf(log_op, \"ERROR - sum of allocated %zu != mem_allocated %zu\\n\", sum, mem_allocated);\n\n\tif (final) {\n\t\tif (sum || number_alloc_list || badptr || overrun)\n\t\t\tfprintf(log_op, \"=> Program seems to have some memory problem !!!\\n\\n\");\n\t\telse\n\t\t\tfprintf(log_op, \"=> Program seems to be memory allocation safe...\\n\\n\");\n\t}\n}\n\nstatic void\nkeepalived_free_final(void)\n{\n\tkeepalived_alloc_log(true);\n}\n\nvoid\nkeepalived_alloc_dump(void)\n{\n\tkeepalived_alloc_log(false);\n}\n\nvoid\nmem_log_init(const char* prog_name, const char *banner)\n{\n\tsize_t log_name_len;\n\tchar *log_name;\n\n\tif (__test_bit(LOG_CONSOLE_BIT, &debug)) {\n\t\tlog_op = stderr;\n\t\treturn;\n\t}\n\n\tif (log_op)\n\t\tfclose(log_op);\n\n\tlog_name_len = 5 + strlen(prog_name) + 5 + 7 + 4 + 1;\t/* \"/tmp/\" + prog_name + \"_mem.\" + PID + \".log\" + '\\0\" */\n\tlog_name = malloc(log_name_len);\n\tif (!log_name) {\n\t\tlog_message(LOG_INFO, \"Unable to malloc log file name\");\n\t\tlog_op = stderr;\n\t\treturn;\n\t}\n\n\tsnprintf(log_name, log_name_len, \"/tmp/%s_mem.%d.log\", prog_name, getpid());\n\tlog_op = fopen_safe(log_name, \"a\");\n\tif (log_op == NULL) {\n\t\tlog_message(LOG_INFO, \"Unable to open %s for appending\", log_name);\n\t\tlog_op = stderr;\n\t}\n\telse {\n\t\tint fd = fileno(log_op);\n\n\t\t/* We don't want any children to inherit the log file */\n\t\tfcntl(fd, F_SETFD, fcntl(fd, F_GETFD) | FD_CLOEXEC);\n\n\t\t/* Make the log output line buffered. This was to ensure that\n\t\t * children didn't inherit the buffer, but the CLOEXEC above\n\t\t * should resolve that. */\n\t\tsetlinebuf(log_op);\n\n\t\tfprintf(log_op, \"\\n\");\n\t}\n\n\tfree(log_name);\n\n\tterminate_banner = banner;\n}\n\nvoid skip_mem_dump(void)\n{\n\tskip_mem_check_final = true;\n}\n\nvoid enable_mem_log_termination(void)\n{\n\tatexit(keepalived_free_final);\n}\n#endif\n", "/*\n * Soft:        Keepalived is a failover program for the LVS project\n *              <www.linuxvirtualserver.org>. It monitor & manipulate\n *              a loadbalanced server pool using multi-layer checks.\n *\n * Part:        Forked system call to launch an extra script.\n *\n * Author:      Alexandre Cassen, <acassen@linux-vs.org>\n *\n *              This program is distributed in the hope that it will be useful,\n *              but WITHOUT ANY WARRANTY; without even the implied warranty of\n *              MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n *              See the GNU General Public License for more details.\n *\n *              This program is free software; you can redistribute it and/or\n *              modify it under the terms of the GNU General Public License\n *              as published by the Free Software Foundation; either version\n *              2 of the License, or (at your option) any later version.\n *\n * Copyright (C) 2001-2017 Alexandre Cassen, <acassen@gmail.com>\n */\n\n#include \"config.h\"\n\n#include <unistd.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <signal.h>\n#include <grp.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <pwd.h>\n#include <sys/resource.h>\n#include <limits.h>\n#include <sys/prctl.h>\n\n#include \"notify.h\"\n#include \"signals.h\"\n#include \"logger.h\"\n#include \"utils.h\"\n#include \"process.h\"\n#include \"parser.h\"\n#include \"keepalived_magic.h\"\n#include \"scheduler.h\"\n\n/* Default user/group for script execution */\nuid_t default_script_uid;\ngid_t default_script_gid;\n\n/* Have we got a default user OK? */\nstatic bool default_script_uid_set = false;\nstatic bool default_user_fail = false;\t\t\t/* Set if failed to set default user,\n\t\t\t\t\t\t\t   unless it defaults to root */\n\n/* Script security enabled */\nbool script_security = false;\n\n/* Buffer length needed for getpwnam_r/getgrname_r */\nstatic size_t getpwnam_buf_len;\n\nstatic char *path;\nstatic bool path_is_malloced;\n\n/* The priority this process is running at */\nstatic int cur_prio = INT_MAX;\n\n/* Buffer for expanding notify script commands */\nstatic char cmd_str_buf[MAXBUF];\n\nstatic bool\nset_privileges(uid_t uid, gid_t gid)\n{\n\tint retval;\n\n\t/* Ensure we receive SIGTERM if our parent process dies */\n\tprctl(PR_SET_PDEATHSIG, SIGTERM);\n\n\t/* If we have increased our priority, set it to default for the script */\n\tif (cur_prio != INT_MAX)\n\t\tcur_prio = getpriority(PRIO_PROCESS, 0);\n\tif (cur_prio < 0)\n\t\tsetpriority(PRIO_PROCESS, 0, 0);\n\n\t/* Drop our privileges if configured */\n\tif (gid) {\n\t\tretval = setgid(gid);\n\t\tif (retval < 0) {\n\t\t\tlog_message(LOG_ALERT, \"Couldn't setgid: %d (%m)\", gid);\n\t\t\treturn true;\n\t\t}\n\n\t\t/* Clear any extra supplementary groups */\n\t\tretval = setgroups(1, &gid);\n\t\tif (retval < 0) {\n\t\t\tlog_message(LOG_ALERT, \"Couldn't setgroups: %d (%m)\", gid);\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tif (uid) {\n\t\tretval = setuid(uid);\n\t\tif (retval < 0) {\n\t\t\tlog_message(LOG_ALERT, \"Couldn't setuid: %d (%m)\", uid);\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t/* Prepare for invoking process/script */\n\tsignal_handler_script();\n\tset_std_fd(false);\n\n\treturn false;\n}\n\nchar *\ncmd_str_r(const notify_script_t *script, char *buf, size_t len)\n{\n\tchar *str_p;\n\tint i;\n\tsize_t str_len;\n\n\tstr_p = buf;\n\n\tfor (i = 0; i < script->num_args; i++) {\n\t\t/* Check there is enough room for the next word */\n\t\tstr_len = strlen(script->args[i]);\n\t\tif (str_p + str_len + 2 + (i ? 1 : 0) >= buf + len)\n\t\t\treturn NULL;\n\n\t\tif (i)\n\t\t\t*str_p++ = ' ';\n\t\t*str_p++ = '\\'';\n\t\tstrcpy(str_p, script->args[i]);\n\t\tstr_p += str_len;\n\t\t*str_p++ = '\\'';\n\t}\n\t*str_p = '\\0';\n\n\treturn buf;\n}\n\nchar *\ncmd_str(const notify_script_t *script)\n{\n\tsize_t len;\n\tint i;\n\n\tfor (i = 0, len = 0; i < script->num_args; i++)\n\t\tlen += strlen(script->args[i]) + 3; /* Add two ', and trailing space (or null for last arg) */\n\n\tif (len > sizeof cmd_str_buf)\n\t\treturn NULL;\n\n\treturn cmd_str_r(script, cmd_str_buf, sizeof cmd_str_buf);\n}\n\n/* Execute external script/program to process FIFO */\nstatic pid_t\nnotify_fifo_exec(thread_master_t *m, int (*func) (thread_t *), void *arg, notify_script_t *script)\n{\n\tpid_t pid;\n\tint retval;\n\tchar *scr;\n\n\tpid = local_fork();\n\n\t/* In case of fork is error. */\n\tif (pid < 0) {\n\t\tlog_message(LOG_INFO, \"Failed fork process\");\n\t\treturn -1;\n\t}\n\n\t/* In case of this is parent process */\n\tif (pid) {\n\t\tthread_add_child(m, func, arg, pid, TIMER_NEVER);\n\t\treturn 0;\n\t}\n\n#ifdef _MEM_CHECK_\n\tskip_mem_dump();\n#endif\n\n\tsetpgid(0, 0);\n\tset_privileges(script->uid, script->gid);\n\n\tif (script->flags | SC_EXECABLE) {\n\t\t/* If keepalived dies, we want the script to die */\n\t\tprctl(PR_SET_PDEATHSIG, SIGTERM);\n\n\t\texecve(script->args[0], script->args, environ);\n\n\t\tif (errno == EACCES)\n\t\t\tlog_message(LOG_INFO, \"FIFO notify script %s is not executable\", script->args[0]);\n\t\telse\n\t\t\tlog_message(LOG_INFO, \"Unable to execute FIFO notify script %s - errno %d - %m\", script->args[0], errno);\n\t}\n\telse {\n\t\tretval = system(scr = cmd_str(script));\n\n\t\tif (retval == 127) {\n\t\t\t/* couldn't exec command */\n\t\t\tlog_message(LOG_ALERT, \"Couldn't exec FIFO command: %s\", scr);\n\t\t}\n\t\telse if (retval == -1)\n\t\t\tlog_message(LOG_ALERT, \"Error exec-ing FIFO command: %s\", scr);\n\n\t\texit(0);\n\t}\n\n\t/* unreached unless error */\n\texit(0);\n}\n\nstatic void\nfifo_open(notify_fifo_t* fifo, int (*script_exit)(thread_t *), const char *type)\n{\n\tint ret;\n\tint sav_errno;\n\n\tif (fifo->name) {\n\t\tsav_errno = 0;\n\n\t\tif (!(ret = mkfifo(fifo->name, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)))\n\t\t\tfifo->created_fifo = true;\n\t\telse {\n\t\t\tsav_errno = errno;\n\n\t\t\tif (sav_errno != EEXIST)\n\t\t\t\tlog_message(LOG_INFO, \"Unable to create %snotify fifo %s\", type, fifo->name);\n\t\t}\n\n\t\tif (!sav_errno || sav_errno == EEXIST) {\n\t\t\t/* Run the notify script if there is one */\n\t\t\tif (fifo->script)\n\t\t\t\tnotify_fifo_exec(master, script_exit, fifo, fifo->script);\n\n\t\t\t/* Now open the fifo */\n\t\t\tif ((fifo->fd = open(fifo->name, O_RDWR | O_CLOEXEC | O_NONBLOCK | O_NOFOLLOW)) == -1) {\n\t\t\t\tlog_message(LOG_INFO, \"Unable to open %snotify fifo %s - errno %d\", type, fifo->name, errno);\n\t\t\t\tif (fifo->created_fifo) {\n\t\t\t\t\tunlink(fifo->name);\n\t\t\t\t\tfifo->created_fifo = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (fifo->fd == -1) {\n\t\t\tFREE(fifo->name);\n\t\t\tfifo->name = NULL;\n\t\t}\n\t}\n}\n\nvoid\nnotify_fifo_open(notify_fifo_t* global_fifo, notify_fifo_t* fifo, int (*script_exit)(thread_t *), const char *type)\n{\n\t/* Open the global FIFO if specified */\n\tif (global_fifo->name)\n\t\tfifo_open(global_fifo, script_exit, \"\");\n\n\t/* Now the specific FIFO */\n\tif (fifo->name)\n\t\tfifo_open(fifo, script_exit, type);\n}\n\nstatic void\nfifo_close(notify_fifo_t* fifo)\n{\n\tif (fifo->fd != -1) {\n\t\tclose(fifo->fd);\n\t\tfifo->fd = -1;\n\t}\n\tif (fifo->created_fifo)\n\t\tunlink(fifo->name);\n}\n\nvoid\nnotify_fifo_close(notify_fifo_t* global_fifo, notify_fifo_t* fifo)\n{\n\tif (global_fifo->fd != -1)\n\t\tfifo_close(global_fifo);\n\n\tfifo_close(fifo);\n}\n\n/* perform a system call */\nstatic void system_call(const notify_script_t *) __attribute__ ((noreturn));\n\nstatic void\nsystem_call(const notify_script_t* script)\n{\n\tchar *command_line = NULL;\n\tchar *str;\n\tint retval;\n\n\tif (set_privileges(script->uid, script->gid))\n\t\texit(0);\n\n\t/* Move us into our own process group, so if the script needs to be killed\n\t * all its child processes will also be killed. */\n\tsetpgid(0, 0);\n\n\tif (script->flags & SC_EXECABLE) {\n\t\t/* If keepalived dies, we want the script to die */\n\t\tprctl(PR_SET_PDEATHSIG, SIGTERM);\n\n\t\texecve(script->args[0], script->args, environ);\n\n\t\t/* error */\n\t\tlog_message(LOG_ALERT, \"Error exec-ing command '%s', error %d: %m\", script->args[0], errno);\n\t}\n\telse {\n\t\tretval = system(str = cmd_str(script));\n\n\t\tif (retval == -1)\n\t\t\tlog_message(LOG_ALERT, \"Error exec-ing command: %s\", str);\n\t\telse if (WIFEXITED(retval)) {\n\t\t\tif (WEXITSTATUS(retval) == 127) {\n\t\t\t\t/* couldn't find command */\n\t\t\t\tlog_message(LOG_ALERT, \"Couldn't find command: %s\", str);\n\t\t\t}\n\t\t\telse if (WEXITSTATUS(retval) == 126) {\n\t\t\t\t/* couldn't find command */\n\t\t\t\tlog_message(LOG_ALERT, \"Couldn't execute command: %s\", str);\n\t\t\t}\n\t\t}\n\n\t\tif (command_line)\n\t\t\tFREE(command_line);\n\n\t\tif (retval == -1 ||\n\t\t    (WIFEXITED(retval) && (WEXITSTATUS(retval) == 126 || WEXITSTATUS(retval) == 127)))\n\t\t\texit(0);\n\t\tif (WIFEXITED(retval))\n\t\t\texit(WEXITSTATUS(retval));\n\t\tif (WIFSIGNALED(retval))\n\t\t\tkill(getpid(), WTERMSIG(retval));\n\t\texit(0);\n\t}\n\n\texit(0);\n}\n\n/* Execute external script/program */\nint\nnotify_exec(const notify_script_t *script)\n{\n\tpid_t pid;\n\n\tif (log_file_name)\n\t\tflush_log_file();\n\n\tpid = local_fork();\n\n\tif (pid < 0) {\n\t\t/* fork error */\n\t\tlog_message(LOG_INFO, \"Failed fork process\");\n\t\treturn -1;\n\t}\n\n\tif (pid) {\n\t\t/* parent process */\n\t\treturn 0;\n\t}\n\n#ifdef _MEM_CHECK_\n\tskip_mem_dump();\n#endif\n\n\tsystem_call(script);\n\n\t/* We should never get here */\n\texit(0);\n}\n\nint\nsystem_call_script(thread_master_t *m, int (*func) (thread_t *), void * arg, unsigned long timer, notify_script_t* script)\n{\n\tpid_t pid;\n\n\t/* Daemonization to not degrade our scheduling timer */\n\tif (log_file_name)\n\t\tflush_log_file();\n\n\tpid = local_fork();\n\n\tif (pid < 0) {\n\t\t/* fork error */\n\t\tlog_message(LOG_INFO, \"Failed fork process\");\n\t\treturn -1;\n\t}\n\n\tif (pid) {\n\t\t/* parent process */\n\t\tthread_add_child(m, func, arg, pid, timer);\n\t\treturn 0;\n\t}\n\n\t/* Child process */\n#ifdef _MEM_CHECK_\n\tskip_mem_dump();\n#endif\n\n\tsystem_call(script);\n\n\texit(0); /* Script errors aren't server errors */\n}\n\nint\nchild_killed_thread(thread_t *thread)\n{\n\tthread_master_t *m = thread->master;\n\n\t/* If the child didn't die, then force it */\n\tif (thread->type == THREAD_CHILD_TIMEOUT)\n\t\tkill(-getpgid(thread->u.c.pid), SIGKILL);\n\n\t/* If all children have died, we can now complete the\n\t * termination process */\n\tif (!&m->child.rb_root.rb_node && !m->shutdown_timer_running)\n\t\tthread_add_terminate_event(m);\n\n\treturn 0;\n}\n\nvoid\nscript_killall(thread_master_t *m, int signo, bool requeue)\n{\n\tthread_t *thread;\n\tpid_t p_pgid, c_pgid;\n#ifndef HAVE_SIGNALFD\n\tsigset_t old_set, child_wait;\n\n\tsigmask_func(0, NULL, &old_set);\n\tif (!sigismember(&old_set, SIGCHLD)) {\n\t\tsigemptyset(&child_wait);\n\t\tsigaddset(&child_wait, SIGCHLD);\n\t\tsigmask_func(SIG_BLOCK, &child_wait, NULL);\n\t}\n#endif\n\n\tp_pgid = getpgid(0);\n\n\trb_for_each_entry_cached(thread, &m->child, n) {\n\t\tc_pgid = getpgid(thread->u.c.pid);\n\t\tif (c_pgid != p_pgid)\n\t\t\tkill(-c_pgid, signo);\n\t\telse {\n\t\t\tlog_message(LOG_INFO, \"Child process %d in our process group %d\", c_pgid, p_pgid);\n\t\t\tkill(thread->u.c.pid, signo);\n\t\t}\n\t}\n\n\t/* We want to timeout the killed children in 1 second */\n\tif (requeue && signo != SIGKILL)\n\t\tthread_children_reschedule(m, child_killed_thread, TIMER_HZ);\n\n#ifndef HAVE_SIGNALFD\n\tif (!sigismember(&old_set, SIGCHLD))\n\t\tsigmask_func(SIG_UNBLOCK, &child_wait, NULL);\n#endif\n}\n\nstatic bool\nis_executable(struct stat *buf, uid_t uid, gid_t gid)\n{\n\treturn (uid == 0 && buf->st_mode & (S_IXUSR | S_IXGRP | S_IXOTH)) ||\n\t       (uid == buf->st_uid && buf->st_mode & S_IXUSR) ||\n\t       (uid != buf->st_uid &&\n\t\t((gid == buf->st_gid && buf->st_mode & S_IXGRP) ||\n\t\t (gid != buf->st_gid && buf->st_mode & S_IXOTH)));\n}\n\nstatic void\nreplace_cmd_name(notify_script_t *script, char *new_path)\n{\n\tsize_t len;\n\tchar **wp = &script->args[1];\n\tsize_t num_words = 1;\n\tchar **params;\n\tchar **word_ptrs;\n\tchar *words;\n\n\tlen = strlen(new_path) + 1;\n\twhile (*wp)\n\t\tlen += strlen(*wp++) + 1;\n\tnum_words = ((char **)script->args[0] - &script->args[0]) - 1;\n\n\tparams = word_ptrs = MALLOC((num_words + 1) * sizeof(char *) + len);\n\twords = (char *)&params[num_words + 1];\n\n\tstrcpy(words, new_path);\n\t*(word_ptrs++) = words;\n\twords += strlen(words) + 1;\n\n\twp = &script->args[1];\n\twhile (*wp) {\n\t\tstrcpy(words, *wp);\n\t\t*(word_ptrs++) = words;\n\t\twords += strlen(*wp) + 1;\n\t\twp++;\n\t}\n\t*word_ptrs = NULL;\n\n\tFREE(script->args);\n\tscript->args = params;\n}\n\n/* The following function is essentially __execve() from glibc */\nstatic int\nfind_path(notify_script_t *script)\n{\n\tsize_t filename_len;\n\tsize_t file_len;\n\tsize_t path_len;\n\tchar *file = script->args[0];\n\tstruct stat buf;\n\tint ret;\n\tint ret_val = ENOENT;\n\tint sgid_num;\n\tgid_t *sgid_list = NULL;\n\tconst char *subp;\n\tbool got_eacces = false;\n\tconst char *p;\n\n\t/* We check the simple case first. */\n\tif (*file == '\\0')\n\t\treturn ENOENT;\n\n\tfilename_len = strlen(file);\n\tif (filename_len >= PATH_MAX) {\n\t\tret_val = ENAMETOOLONG;\n\t\tgoto exit1;\n\t}\n\n\t/* Don't search when it contains a slash. */\n\tif (strchr (file, '/') != NULL) {\n\t\tret_val = 0;\n\t\tgoto exit1;\n\t}\n\n\t/* Get the path if we haven't already done so, and if that doesn't\n\t * exist, use CS_PATH */\n\tif (!path) {\n\t\tpath = getenv (\"PATH\");\n\n\t\tif (!path) {\n\t\t\tsize_t cs_path_len;\n\t\t\tpath = MALLOC(cs_path_len = confstr(_CS_PATH, NULL, 0));\n\t\t\tconfstr(_CS_PATH, path, cs_path_len);\n\t\t\tpath_is_malloced = true;\n\t\t}\n\t}\n\n\t/* Although GLIBC does not enforce NAME_MAX, we set it as the maximum\n\t   size to avoid unbounded stack allocation.  Same applies for\n\t   PATH_MAX. */\n\tfile_len = strnlen (file, NAME_MAX + 1);\n\tpath_len = strnlen (path, PATH_MAX - 1) + 1;\n\n\tif (file_len > NAME_MAX) {\n\t\tret_val = ENAMETOOLONG;\n\t\tgoto exit1;\n\t}\n\n\t/* Set file access to the relevant uid/gid */\n\tif (script->gid) {\n\t\tif (setegid(script->gid)) {\n\t\t\tlog_message(LOG_INFO, \"Unable to set egid to %d (%m)\", script->gid);\n\t\t\tret_val = EACCES;\n\t\t\tgoto exit1;\n\t\t}\n\n\t\t/* Get our supplementary groups */\n\t\tsgid_num = getgroups(0, NULL);\n\t\tsgid_list = MALLOC(((size_t)sgid_num + 1) * sizeof(gid_t));\n\t\tsgid_num = getgroups(sgid_num, sgid_list);\n\t\tsgid_list[sgid_num++] = 0;\n\n\t\t/* Clear the supplementary group list */\n\t\tif (setgroups(1, &script->gid)) {\n\t\t\tlog_message(LOG_INFO, \"Unable to set supplementary gids (%m)\");\n\t\t\tret_val = EACCES;\n\t\t\tgoto exit;\n\t\t}\n\t}\n\tif (script->uid && seteuid(script->uid)) {\n\t\tlog_message(LOG_INFO, \"Unable to set euid to %d (%m)\", script->uid);\n\t\tret_val = EACCES;\n\t\tgoto exit;\n\t}\n\n\tfor (p = path; ; p = subp)\n\t{\n\t\tchar buffer[path_len + file_len + 1];\n\n\t\tsubp = strchrnul (p, ':');\n\n\t\t/* PATH is larger than PATH_MAX and thus potentially larger than\n\t\t   the stack allocation. */\n\t\tif (subp >= p + path_len) {\n\t\t\t/* There are no more paths, bail out. */\n\t\t\tif (*subp == '\\0') {\n\t\t\t\tret_val = ENOENT;\n\t\t\t\tgoto exit;\n\t\t\t}\n\n\t\t\t/* Otherwise skip to next one. */\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Use the current path entry, plus a '/' if nonempty, plus the file to execute. */\n\t\tchar *pend = mempcpy (buffer, p, (size_t)(subp - p));\n\t\t*pend = '/';\n\t\tmemcpy (pend + (p < subp), file, file_len + 1);\n\n\t\tret = stat (buffer, &buf);\n\t\tif (!ret) {\n\t\t\tif (!S_ISREG(buf.st_mode))\n\t\t\t\terrno = EACCES;\n\t\t\telse if (!is_executable(&buf, script->uid, script->gid)) {\n\t\t\t\terrno = EACCES;\n\t\t\t} else {\n\t\t\t\t/* Success */\n\t\t\t\tlog_message(LOG_INFO, \"WARNING - script `%s` resolved by path search to `%s`. Please specify full path.\", script->args[0], buffer);\n\n\t\t\t\t/* Copy the found file name, and any parameters */\n\t\t\t\treplace_cmd_name(script, buffer);\n\n\t\t\t\tret_val = 0;\n\t\t\t\tgot_eacces = false;\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\n\t\tswitch (errno)\n\t\t{\n\t\tcase ENOEXEC:\n\t\tcase EACCES:\n\t\t\t/* Record that we got a 'Permission denied' error.  If we end\n\t\t\t   up finding no executable we can use, we want to diagnose\n\t\t\t   that we did find one but were denied access. */\n\t\t\tif (!ret)\n\t\t\t\tgot_eacces = true;\n\t\tcase ENOENT:\n\t\tcase ESTALE:\n\t\tcase ENOTDIR:\n\t\t\t/* Those errors indicate the file is missing or not executable\n\t\t\t   by us, in which case we want to just try the next path\n\t\t\t   directory. */\n\t\tcase ENODEV:\n\t\tcase ETIMEDOUT:\n\t\t\t/* Some strange filesystems like AFS return even\n\t\t\t   stranger error numbers.  They cannot reasonably mean\n\t\t\t   anything else so ignore those, too. */\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t/* Some other error means we found an executable file, but\n\t\t\t   something went wrong accessing it; return the error to our\n\t\t\t   caller. */\n\t\t\tret_val = -1;\n\t\t\tgoto exit;\n\t\t}\n\n\t\tif (*subp++ == '\\0')\n\t\t\tbreak;\n\t}\n\nexit:\n\t/* Restore root euid/egid */\n\tif (script->uid && seteuid(0))\n\t\tlog_message(LOG_INFO, \"Unable to restore euid after script search (%m)\");\n\tif (script->gid) {\n\t\tif (setegid(0))\n\t\t\tlog_message(LOG_INFO, \"Unable to restore egid after script search (%m)\");\n\n\t\t/* restore supplementary groups */\n\t\tif (sgid_list) {\n\t\t\tif (setgroups((size_t)sgid_num, sgid_list))\n\t\t\t\tlog_message(LOG_INFO, \"Unable to restore supplementary groups after script search (%m)\");\n\t\t\tFREE(sgid_list);\n\t\t}\n\t}\n\nexit1:\n\t/* We tried every element and none of them worked. */\n\tif (got_eacces) {\n\t\t/* At least one failure was due to permissions, so report that error. */\n\t\treturn EACCES;\n\t}\n\n\treturn ret_val;\n}\n\nstatic int\ncheck_security(char *filename, bool script_security)\n{\n\tchar *next;\n\tchar *slash;\n\tchar sav;\n\tint ret;\n\tstruct stat buf;\n\tint flags = 0;\n\n\tnext = filename;\n\twhile (next) {\n\t\tslash = strchrnul(next, '/');\n\t\tif (*slash)\n\t\t\tnext = slash + 1;\n\t\telse {\n\t\t\tslash = NULL;\n\t\t\tnext = NULL;\n\t\t}\n\n\t\tif (slash) {\n\t\t\t/* We want to check '/' for first time around */\n\t\t\tif (slash == filename)\n\t\t\t\tslash++;\n\t\t\tsav = *slash;\n\t\t\t*slash = 0;\n\t\t}\n\n\t\tret = fstatat(0, filename, &buf, AT_SYMLINK_NOFOLLOW);\n\n\t\t/* Restore the full path name */\n\t\tif (slash)\n\t\t\t*slash = sav;\n\n\t\tif (ret) {\n\t\t\tif (errno == EACCES || errno == ELOOP || errno == ENOENT || errno == ENOTDIR)\n\t\t\t\tlog_message(LOG_INFO, \"check_script_secure could not find script '%s' - disabling\", filename);\n\t\t\telse\n\t\t\t\tlog_message(LOG_INFO, \"check_script_secure('%s') returned errno %d - %s - disabling\", filename, errno, strerror(errno));\n\t\t\treturn flags | SC_NOTFOUND;\n\t\t}\n\n\t\t/* If it is not the last item, it must be a directory. If it is the last item\n\t\t * it must be a file or a symbolic link. */\n\t\tif ((slash && !S_ISDIR(buf.st_mode)) ||\n\t\t    (!slash &&\n\t\t     !S_ISREG(buf.st_mode) &&\n\t\t     !S_ISLNK(buf.st_mode))) {\n\t\t\tlog_message(LOG_INFO, \"Wrong file type found in script path '%s'.\", filename);\n\t\t\treturn flags | SC_INHIBIT;\n\t\t}\n\n\t\tif (buf.st_uid ||\t\t\t\t/* Owner is not root */\n\t\t    (((S_ISDIR(buf.st_mode) &&\t\t\t/* A directory without the sticky bit set */\n\t\t       !(buf.st_mode & S_ISVTX)) ||\n\t\t      S_ISREG(buf.st_mode)) &&\t\t\t/* This is a file */\n\t\t     ((buf.st_gid && buf.st_mode & S_IWGRP) ||\t/* Group is not root and group write permission */\n\t\t      buf.st_mode & S_IWOTH))) {\t\t/* World has write permission */\n\t\t\tlog_message(LOG_INFO, \"Unsafe permissions found for script '%s'%s.\", filename, script_security ? \" - disabling\" : \"\");\n\t\t\tflags |= SC_INSECURE;\n\t\t\treturn flags | (script_security ? SC_INHIBIT : 0);\n\t\t}\n\t}\n\n\treturn flags;\n}\n\nint\ncheck_script_secure(notify_script_t *script,\n#ifndef _HAVE_LIBMAGIC_\n\t\t\t\t\t     __attribute__((unused))\n#endif\n\t\t\t\t\t\t\t\t     magic_t magic)\n{\n\tint flags;\n\tint ret, ret_real, ret_new;\n\tstruct stat file_buf, real_buf;\n\tbool need_script_protection = false;\n\tuid_t old_uid = 0;\n\tgid_t old_gid = 0;\n\tchar *new_path;\n\tint sav_errno;\n\tchar *real_file_path;\n\tchar *orig_file_part, *new_file_part;\n\n\tif (!script)\n\t\treturn 0;\n\n\t/* If the script starts \"</\" (possibly with white space between\n\t * the '<' and '/'), it is checking for a file being openable,\n\t * so it won't be executed */\n\tif (script->args[0][0] == '<' &&\n\t    script->args[0][strspn(script->args[0] + 1, \" \\t\") + 1] == '/')\n\t\treturn SC_SYSTEM;\n\n\tif (!strchr(script->args[0], '/')) {\n\t\t/* It is a bare file name, so do a path search */\n\t\tif ((ret = find_path(script))) {\n\t\t\tif (ret == EACCES)\n\t\t\t\tlog_message(LOG_INFO, \"Permissions failure for script %s in path - disabling\", script->args[0]);\n\t\t\telse\n\t\t\t\tlog_message(LOG_INFO, \"Cannot find script %s in path - disabling\", script->args[0]);\n\t\t\treturn SC_NOTFOUND;\n\t\t}\n\t}\n\n\t/* Check script accessible by the user running it */\n\tif (script->uid)\n\t\told_uid = geteuid();\n\tif (script->gid)\n\t\told_gid = getegid();\n\n\tif ((script->gid && setegid(script->gid)) ||\n\t    (script->uid && seteuid(script->uid))) {\n\t\tlog_message(LOG_INFO, \"Unable to set uid:gid %d:%d for script %s - disabling\", script->uid, script->gid, script->args[0]);\n\n\t\tif ((script->uid && seteuid(old_uid)) ||\n\t\t    (script->gid && setegid(old_gid)))\n\t\t\tlog_message(LOG_INFO, \"Unable to restore uid:gid %d:%d after script %s\", script->uid, script->gid, script->args[0]);\n\n\t\treturn SC_INHIBIT;\n\t}\n\n\t/* Remove /./, /../, multiple /'s, and resolve symbolic links */\n\tnew_path = realpath(script->args[0], NULL);\n\tsav_errno = errno;\n\n\tif ((script->gid && setegid(old_gid)) ||\n\t    (script->uid && seteuid(old_uid)))\n\t\tlog_message(LOG_INFO, \"Unable to restore uid:gid %d:%d after checking script %s\", script->uid, script->gid, script->args[0]);\n\n\tif (!new_path)\n\t{\n\t\tlog_message(LOG_INFO, \"Script %s cannot be accessed - %s\", script->args[0], strerror(sav_errno));\n\n\t\treturn SC_NOTFOUND;\n\t}\n\n\treal_file_path = NULL;\n\n\torig_file_part = strrchr(script->args[0], '/');\n\tnew_file_part = strrchr(new_path, '/');\n\tif (strcmp(script->args[0], new_path)) {\n\t\t/* The path name is different */\n\n\t\t/* If the file name parts don't match, we need to be careful to\n\t\t * ensure that we preserve the file name part since some executables\n\t\t * alter their behaviour based on what they are called */\n\t\tif (strcmp(orig_file_part + 1, new_file_part + 1)) {\n\t\t\treal_file_path = new_path;\n\t\t\tnew_path = MALLOC(new_file_part - real_file_path + 1 + strlen(orig_file_part + 1) + 1);\n\t\t\tstrncpy(new_path, real_file_path, new_file_part + 1 - real_file_path);\n\t\t\tstrcpy(new_path + (new_file_part + 1 - real_file_path), orig_file_part + 1);\n\n\t\t\t/* Now check this is the same file */\n\t\t\tret_real = stat(real_file_path, &real_buf);\n\t\t\tret_new = stat(new_path, &file_buf);\n\t\t\tif (!ret_real &&\n\t\t\t    (ret_new ||\n\t\t\t     real_buf.st_dev != file_buf.st_dev ||\n\t\t\t     real_buf.st_ino != file_buf.st_ino)) {\n\t\t\t\t/* It doesn't resolve to the same file */\n\t\t\t\tFREE(new_path);\n\t\t\t\tnew_path = real_file_path;\n\t\t\t\treal_file_path = NULL;\n\t\t\t}\n\t\t}\n\n\t\tif (strcmp(script->args[0], new_path)) {\n\t \t\t/* We need to set up all the args again */\n\t\t\treplace_cmd_name(script, new_path);\n\t\t}\n\t}\n\n\tif (!real_file_path)\n\t\tfree(new_path);\n\telse\n\t\tFREE(new_path);\n\n\t/* Get the permissions for the file itself */\n\tif (stat(real_file_path ? real_file_path : script->args[0], &file_buf)) {\n\t\tlog_message(LOG_INFO, \"Unable to access script `%s` - disabling\", script->args[0]);\n\t\treturn SC_NOTFOUND;\n\t}\n\n\tflags = SC_ISSCRIPT;\n\n\t/* We have the final file. Check if root is executing it, or it is set uid/gid root. */\n\tif (is_executable(&file_buf, script->uid, script->gid)) {\n\t\tflags |= SC_EXECUTABLE;\n\t\tif (script->uid == 0 || script->gid == 0 ||\n\t\t    (file_buf.st_uid == 0 && (file_buf.st_mode & S_IXUSR) && (file_buf.st_mode & S_ISUID)) ||\n\t\t    (file_buf.st_gid == 0 && (file_buf.st_mode & S_IXGRP) && (file_buf.st_mode & S_ISGID)))\n\t\t\tneed_script_protection = true;\n\t} else\n\t\tlog_message(LOG_INFO, \"WARNING - script '%s' is not executable for uid:gid %d:%d - disabling.\", script->args[0], script->uid, script->gid);\n\n\t/* Default to execable */\n\tscript->flags |= SC_EXECABLE;\n#ifdef _HAVE_LIBMAGIC_\n\tif (magic && flags & SC_EXECUTABLE) {\n\t\tconst char *magic_desc = magic_file(magic, real_file_path ? real_file_path : script->args[0]);\n\t\tif (!strstr(magic_desc, \" executable\") &&\n\t\t    !strstr(magic_desc, \" shared object\")) {\n\t\t\tlog_message(LOG_INFO, \"Please add a #! shebang to script %s\", script->args[0]);\n\t\t\tscript->flags &= ~SC_EXECABLE;\n\t\t}\n\t}\n#endif\n\n\tif (!need_script_protection) {\n\t\tif (real_file_path)\n\t\t\tfree(real_file_path);\n\n\t\treturn flags;\n\t}\n\n\t/* Make sure that all parts of the path are not non-root writable */\n\tflags |= check_security(script->args[0], script_security);\n\n\tif (real_file_path) {\n\t\tflags |= check_security(real_file_path, script_security);\n\t\tfree(real_file_path);\n\t}\n\n\treturn flags;\n}\n\nint\ncheck_notify_script_secure(notify_script_t **script_p, magic_t magic)\n{\n\tint flags;\n\tnotify_script_t *script = *script_p;\n\n\tif (!script)\n\t\treturn 0;\n\n\tflags = check_script_secure(script, magic);\n\n\t/* Mark not to run if needs inhibiting */\n\tif ((flags & (SC_INHIBIT | SC_NOTFOUND)) ||\n\t    !(flags & SC_EXECUTABLE))\n\t\tfree_notify_script(script_p);\n\n\treturn flags;\n}\n\nstatic void\nset_pwnam_buf_len(void)\n{\n\tlong buf_len;\n\n\t/* Get buffer length needed for getpwnam_r/getgrnam_r */\n\tif ((buf_len = sysconf(_SC_GETPW_R_SIZE_MAX)) == -1)\n\t\tgetpwnam_buf_len = 1024;\t/* A safe default if no value is returned */\n\telse\n\t\tgetpwnam_buf_len = (size_t)buf_len;\n\tif ((buf_len = sysconf(_SC_GETGR_R_SIZE_MAX)) != -1 &&\n\t    (size_t)buf_len > getpwnam_buf_len)\n\t\tgetpwnam_buf_len = (size_t)buf_len;\n}\n\nbool\nset_uid_gid(const char *username, const char *groupname, uid_t *uid_p, gid_t *gid_p, bool default_user)\n{\n\tuid_t uid;\n\tgid_t gid;\n\tstruct passwd pwd;\n\tstruct passwd *pwd_p;\n\tstruct group grp;\n\tstruct group *grp_p;\n\tint ret;\n\tbool using_default_default_user = false;\n\n\tif (!getpwnam_buf_len)\n\t\tset_pwnam_buf_len();\n\n\t{\n\t\tchar buf[getpwnam_buf_len];\n\n\t\tif (default_user && !username) {\n\t\t\tusing_default_default_user = true;\n\t\t\tusername = \"keepalived_script\";\n\t\t}\n\n\t\tif ((ret = getpwnam_r(username, &pwd, buf, sizeof(buf), &pwd_p))) {\n\t\t\tlog_message(LOG_INFO, \"Unable to resolve %sscript username '%s' - ignoring\", default_user ? \"default \" : \"\", username);\n\t\t\treturn true;\n\t\t}\n\t\tif (!pwd_p) {\n\t\t\tif (using_default_default_user)\n\t\t\t\tlog_message(LOG_INFO, \"WARNING - default user '%s' for script execution does not exist - please create.\", username);\n\t\t\telse\n\t\t\t\tlog_message(LOG_INFO, \"%script user '%s' does not exist\", default_user ? \"Default s\" : \"S\", username);\n\t\t\treturn true;\n\t\t}\n\n\t\tuid = pwd.pw_uid;\n\t\tgid = pwd.pw_gid;\n\n\t\tif (groupname) {\n\t\t\tif ((ret = getgrnam_r(groupname, &grp, buf, sizeof(buf), &grp_p))) {\n\t\t\t\tlog_message(LOG_INFO, \"Unable to resolve %sscript group name '%s' - ignoring\", default_user ? \"default \" : \"\", groupname);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (!grp_p) {\n\t\t\t\tlog_message(LOG_INFO, \"%script group '%s' does not exist\", default_user ? \"Default s\" : \"S\", groupname);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tgid = grp.gr_gid;\n\t\t}\n\n\t\t*uid_p = uid;\n\t\t*gid_p = gid;\n\t}\n\n\treturn false;\n}\n\n/* The default script user/group is keepalived_script if it exists, or root otherwise */\nbool\nset_default_script_user(const char *username, const char *groupname)\n{\n\tif (!default_script_uid_set || username) {\n\t\t/* Even if we fail to set it, there is no point in trying again */\n\t\tdefault_script_uid_set = true;\n\n\t\tif (set_uid_gid(username, groupname, &default_script_uid, &default_script_gid, true)) {\n\t\t\tif (username || script_security)\n\t\t\t\tdefault_user_fail = true;\n\t\t}\n\t\telse\n\t\t\tdefault_user_fail = false;\n\t}\n\n\treturn default_user_fail;\n}\n\nbool\nset_script_uid_gid(vector_t *strvec, unsigned keyword_offset, uid_t *uid_p, gid_t *gid_p)\n{\n\tchar *username;\n\tchar *groupname;\n\n\tusername = strvec_slot(strvec, keyword_offset);\n\tif (vector_size(strvec) > keyword_offset + 1)\n\t\tgroupname = strvec_slot(strvec, keyword_offset + 1);\n\telse\n\t\tgroupname = NULL;\n\n\treturn set_uid_gid(username, groupname, uid_p, gid_p, false);\n}\n\nvoid\nset_script_params_array(vector_t *strvec, notify_script_t *script, unsigned extra_params)\n{\n\tunsigned num_words = 0;\n\tsize_t len = 0;\n\tchar **word_ptrs;\n\tchar *words;\n\tvector_t *strvec_qe = NULL;\n\tunsigned i;\n\n\t/* Count the number of words, and total string length */\n\tif (vector_size(strvec) >= 2)\n\t\tstrvec_qe = alloc_strvec_quoted_escaped(strvec_slot(strvec, 1));\n\n\tif (!strvec_qe)\n\t\treturn;\n\n\tnum_words = vector_size(strvec_qe);\n\tfor (i = 0; i < num_words; i++)\n\t\tlen += strlen(strvec_slot(strvec_qe, i)) + 1;\n\n\t/* Allocate memory for pointers to words and words themselves */\n\tscript->args = word_ptrs = MALLOC((num_words + extra_params + 1) * sizeof(char *) + len);\n\twords = (char *)word_ptrs + (num_words + extra_params + 1) * sizeof(char *);\n\n\t/* Set up pointers to words, and copy the words */\n\tfor (i = 0; i < num_words; i++) {\n\t\tstrcpy(words, strvec_slot(strvec_qe, i));\n\t\t*(word_ptrs++) = words;\n\t\twords += strlen(words) + 1;\n\t}\n\t*word_ptrs = NULL;\n\n\tscript->num_args = num_words;\n\n\tfree_strvec(strvec_qe);\n}\n\nnotify_script_t*\nnotify_script_init(int extra_params, const char *type)\n{\n\tnotify_script_t *script = MALLOC(sizeof(notify_script_t));\n\tvector_t *strvec_qe;\n\n\t/* We need to reparse the command line, allowing for quoted and escaped strings */\n\tstrvec_qe = alloc_strvec_quoted_escaped(NULL);\n\n\tif (!strvec_qe) {\n\t\tlog_message(LOG_INFO, \"Unable to parse notify script\");\n\t\tFREE(script);\n\t\treturn NULL;\n\t}\n\n\tset_script_params_array(strvec_qe, script, extra_params);\n\tif (!script->args) {\n\t\tlog_message(LOG_INFO, \"Unable to parse script '%s' - ignoring\", FMT_STR_VSLOT(strvec_qe, 1));\n\t\tFREE(script);\n\t\tfree_strvec(strvec_qe);\n\t\treturn NULL;\n\t}\n\n\tscript->flags = 0;\n\n\tif (vector_size(strvec_qe) > 2) {\n\t\tif (set_script_uid_gid(strvec_qe, 2, &script->uid, &script->gid)) {\n\t\t\tlog_message(LOG_INFO, \"Invalid user/group for %s script %s - ignoring\", type, script->args[0]);\n\t\t\tFREE(script->args);\n\t\t\tFREE(script);\n\t\t\tfree_strvec(strvec_qe);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\telse {\n\t\tif (set_default_script_user(NULL, NULL)) {\n\t\t\tlog_message(LOG_INFO, \"Failed to set default user for %s script %s - ignoring\", type, script->args[0]);\n\t\t\tFREE(script->args);\n\t\t\tFREE(script);\n\t\t\tfree_strvec(strvec_qe);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tscript->uid = default_script_uid;\n\t\tscript->gid = default_script_gid;\n\t}\n\n\tfree_strvec(strvec_qe);\n\n\treturn script;\n}\n\nvoid\nadd_script_param(notify_script_t *script, char *param)\n{\n\t/* We store the args as an array of pointers to the args, terminated\n\t * by a NULL pointer, followed by the null terminated strings themselves\n\t */\n\n\tif (script->args[script->num_args + 1]) {\n\t\tlog_message(LOG_INFO, \"notify_fifo_script %s no room to add parameter %s\", script->args[0], param);\n\t\treturn;\n\t}\n\n\t/* Add the extra parameter in the pre-reserved slot at the end */\n\tscript->args[script->num_args++] = param;\n}\n\nvoid\nnotify_resource_release(void)\n{\n\tif (path_is_malloced) {\n\t\tFREE(path);\n\t\tpath_is_malloced = false;\n\t\tpath = NULL;\n\t}\n}\n\nbool\nnotify_script_compare(notify_script_t *a, notify_script_t *b)\n{\n\tint i;\n\n\tif (a->num_args != b->num_args)\n\t\treturn false;\n\tfor (i = 0; i < a->num_args; i++) {\n\t\tif (strcmp(a->args[i], b->args[i]))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n#ifdef THREAD_DUMP\nvoid\nregister_notify_addresses(void)\n{\n\tregister_thread_address(\"child_killed_thread\", child_killed_thread);\n}\n#endif\n", "/*\n * Soft:        Keepalived is a failover program for the LVS project\n *              <www.linuxvirtualserver.org>. It monitor & manipulate\n *              a loadbalanced server pool using multi-layer checks.\n *\n * Part:        Configuration file parser/reader. Place into the dynamic\n *              data structure representation the conf file representing\n *              the loadbalanced server pool.\n *\n * Author:      Alexandre Cassen, <acassen@linux-vs.org>\n *\n *              This program is distributed in the hope that it will be useful,\n *              but WITHOUT ANY WARRANTY; without even the implied warranty of\n *              MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n *              See the GNU General Public License for more details.\n *\n *              This program is free software; you can redistribute it and/or\n *              modify it under the terms of the GNU General Public License\n *              as published by the Free Software Foundation; either version\n *              2 of the License, or (at your option) any later version.\n *\n * Copyright (C) 2001-2017 Alexandre Cassen, <acassen@gmail.com>\n */\n\n#include \"config.h\"\n\n#include <glob.h>\n#include <unistd.h>\n#include <libgen.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <stdbool.h>\n#include <linux/version.h>\n#include <pwd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <math.h>\n#include <inttypes.h>\n\n#include \"parser.h\"\n#include \"memory.h\"\n#include \"logger.h\"\n#include \"rttables.h\"\n#include \"scheduler.h\"\n#include \"notify.h\"\n#include \"list.h\"\n#include \"bitops.h\"\n#include \"utils.h\"\n\n/* #define PARSER_DEBUG */\n\n#define DUMP_KEYWORDS\t0\n\n#define DEF_LINE_END\t\"\\n\"\n\n#define BOB \"{\"\n#define EOB \"}\"\n#define WHITE_SPACE_STR \" \\t\\f\\n\\r\\v\"\n\ntypedef struct _defs {\n\tchar *name;\n\tsize_t name_len;\n\tchar *value;\n\tsize_t value_len;\n\tbool multiline;\n\tchar *(*fn)(void);\n} def_t;\n\n/* global vars */\nvector_t *keywords;\nchar *config_id;\nconst char *WHITE_SPACE = WHITE_SPACE_STR;\n\n/* local vars */\nstatic vector_t *current_keywords;\nstatic FILE *current_stream;\nstatic const char *current_file_name;\nstatic size_t current_file_line_no;\nstatic int sublevel = 0;\nstatic int skip_sublevel = 0;\nstatic list multiline_stack;\nstatic char *buf_extern;\nstatic config_err_t config_err = CONFIG_OK; /* Highest level of config error for --config-test */\n\n/* Parameter definitions */\nstatic list defs;\n\n/* Forward declarations for recursion */\nstatic bool read_line(char *, size_t);\n\nvoid\nreport_config_error(config_err_t err, const char *format, ...)\n{\n\tva_list args;\n\tchar *format_buf = NULL;\n\n\t/* current_file_name will be set if there is more than one config file, in which\n\t * case we need to specify the file name. */\n\tif (current_file_name) {\n\t\t/* \"(file_name:line_no) format\" + '\\0' */\n\t\tformat_buf = MALLOC(1 + strlen(current_file_name) + 1 + 10 + 1 + 1 + strlen(format) + 1);\n\t\tsprintf(format_buf, \"(%s:%zd) %s\", current_file_name, current_file_line_no, format);\n\t} else if (current_file_line_no) {\t/* Set while reading from config files */\n\t\t/* \"(Line line_no) format\" + '\\0' */\n\t\tformat_buf = MALLOC(1 + 5 + 10 + 1 + 1 + strlen(format) + 1);\n\t\tsprintf(format_buf, \"(%s %zd) %s\", \"Line\", current_file_line_no, format);\n\t}\n\n\tva_start(args, format);\n\n\tif (__test_bit(CONFIG_TEST_BIT, &debug)) {\n\t\tvfprintf(stderr, format_buf ? format_buf : format, args);\n\t\tfputc('\\n', stderr);\n\n\t\tif (config_err == CONFIG_OK || config_err < err)\n\t\t\tconfig_err = err;\n\t}\n\telse\n\t\tvlog_message(LOG_INFO, format_buf ? format_buf : format, args);\n\n\tva_end(args);\n\n\tif (format_buf)\n\t\tFREE(format_buf);\n}\n\nconfig_err_t\nget_config_status(void)\n{\n\treturn config_err;\n}\n\nstatic char *\nnull_strvec(const vector_t *strvec, size_t index)\n{\n\tif (index - 1 < vector_size(strvec) && index > 0 && vector_slot(strvec, index - 1))\n\t\treport_config_error(CONFIG_MISSING_PARAMETER, \"*** Configuration line starting `%s` is missing a parameter after keyword `%s` at word position %zu\", vector_slot(strvec, 0) ? (char *)vector_slot(strvec, 0) : \"***MISSING ***\", (char *)vector_slot(strvec, index - 1), index + 1);\n\telse\n\t\treport_config_error(CONFIG_MISSING_PARAMETER, \"*** Configuration line starting `%s` is missing a parameter at word position %zu\", vector_slot(strvec, 0) ? (char *)vector_slot(strvec, 0) : \"***MISSING ***\", index + 1);\n\n\texit(KEEPALIVED_EXIT_CONFIG);\n\n\treturn NULL;\n}\n\nstatic bool\nread_int_func(const char *number, int base, int *res, int min_val, int max_val, __attribute__((unused)) bool ignore_error)\n{\n\tlong val;\n\tchar *endptr;\n\tchar *warn = \"\";\n\n#ifndef _STRICT_CONFIG_\n\tif (ignore_error && !__test_bit(CONFIG_TEST_BIT, &debug))\n\t\twarn = \"WARNING - \";\n#endif\n\n\terrno = 0;\n\tval = strtol(number, &endptr, base);\n\t*res = (int)val;\n\n\tif (*endptr)\n\t\treport_config_error(CONFIG_INVALID_NUMBER, \"%sinvalid number '%s'\", warn, number);\n\telse if (errno == ERANGE || val < INT_MIN || val > INT_MAX)\n\t\treport_config_error(CONFIG_INVALID_NUMBER, \"%snumber '%s' outside integer range\", warn, number);\n\telse if (val < min_val || val > max_val)\n\t\treport_config_error(CONFIG_INVALID_NUMBER, \"number '%s' outside range [%d, %d]\", number, min_val, max_val);\n\telse\n\t\treturn true;\n\n#ifdef _STRICT_CONFIG_\n\treturn false;\n#else\n\treturn ignore_error && val >= min_val && val <= max_val && !__test_bit(CONFIG_TEST_BIT, &debug);\n#endif\n}\n\nstatic bool\nread_unsigned_func(const char *number, int base, unsigned *res, unsigned min_val, unsigned max_val, __attribute__((unused)) bool ignore_error)\n{\n\tunsigned long val;\n\tchar *endptr;\n\tchar *warn = \"\";\n\tsize_t offset;\n\n#ifndef _STRICT_CONFIG_\n\tif (ignore_error && !__test_bit(CONFIG_TEST_BIT, &debug))\n\t\twarn = \"WARNING - \";\n#endif\n\n\t/* In case the string starts with spaces (even in the configuration this\n\t * can be achieved by enclosing the number in quotes - e.g. weight \"  -100\")\n\t * skip any leading whitespace */\n\toffset = strspn(number, WHITE_SPACE);\n\n\terrno = 0;\n\tval = strtoul(number + offset, &endptr, base);\n\t*res = (unsigned)val;\n\n\tif (number[offset] == '-')\n\t\treport_config_error(CONFIG_INVALID_NUMBER, \"%snegative number '%s'\", warn, number);\n\telse if (*endptr)\n\t\treport_config_error(CONFIG_INVALID_NUMBER, \"%sinvalid number '%s'\", warn, number);\n\telse if (errno == ERANGE || val > UINT_MAX)\n\t\treport_config_error(CONFIG_INVALID_NUMBER, \"%snumber '%s' outside unsigned integer range\", warn, number);\n\telse if (val < min_val || val > max_val)\n\t\treport_config_error(CONFIG_INVALID_NUMBER, \"number '%s' outside range [%u, %u]\", number, min_val, max_val);\n\telse\n\t\treturn true;\n\n#ifdef _STRICT_CONFIG_\n\treturn false;\n#else\n\treturn ignore_error && val >= min_val && val <= max_val && !__test_bit(CONFIG_TEST_BIT, &debug);\n#endif\n}\n\nstatic bool\nread_unsigned64_func(const char *number, int base, uint64_t *res, uint64_t min_val, uint64_t max_val, __attribute__((unused)) bool ignore_error)\n{\n\tunsigned long long val;\n\tchar *endptr;\n\tchar *warn = \"\";\n\tsize_t offset;\n\n#ifndef _STRICT_CONFIG_\n\tif (ignore_error && !__test_bit(CONFIG_TEST_BIT, &debug))\n\t\twarn = \"WARNING - \";\n#endif\n\n\t/* In case the string starts with spaces (even in the configuration this\n\t * can be achieved by enclosing the number in quotes - e.g. weight \"  -100\")\n\t * skip any leading whitespace */\n\toffset = strspn(number, WHITE_SPACE);\n\n\terrno = 0;\n\tval = strtoull(number + offset, &endptr, base);\n\t*res = (unsigned)val;\n\n\tif (number[offset] == '-')\n\t\treport_config_error(CONFIG_INVALID_NUMBER, \"%snegative number '%s'\", warn, number);\n\telse if (*endptr)\n\t\treport_config_error(CONFIG_INVALID_NUMBER, \"%sinvalid number '%s'\", warn, number);\n\telse if (errno == ERANGE)\n\t\treport_config_error(CONFIG_INVALID_NUMBER, \"%snumber '%s' outside unsigned 64 bit range\", warn, number);\n\telse if (val < min_val || val > max_val)\n\t\treport_config_error(CONFIG_INVALID_NUMBER, \"number '%s' outside range [%\" PRIu64 \", %\" PRIu64 \"]\", number, min_val, max_val);\n\telse\n\t\treturn true;\n\n#ifdef _STRICT_CONFIG_\n\treturn false;\n#else\n\treturn ignore_error && val >= min_val && val <= max_val && !__test_bit(CONFIG_TEST_BIT, &debug);\n#endif\n}\n\nstatic bool\nread_double_func(const char *number, double *res, double min_val, double max_val, __attribute__((unused)) bool ignore_error)\n{\n\tdouble val;\n\tchar *endptr;\n\tchar *warn = \"\";\n\n#ifndef _STRICT_CONFIG_\n\tif (ignore_error && !__test_bit(CONFIG_TEST_BIT, &debug))\n\t\twarn = \"WARNING - \";\n#endif\n\n\terrno = 0;\n\tval = strtod(number, &endptr);\n\t*res = val;\n\n\tif (*endptr)\n\t\treport_config_error(CONFIG_INVALID_NUMBER, \"%sinvalid number '%s'\", warn, number);\n\telse if (errno == ERANGE)\n\t\treport_config_error(CONFIG_INVALID_NUMBER, \"%snumber '%s' out of range\", warn, number);\n\telse if (val == -HUGE_VAL || val == HUGE_VAL)\t/* +/- Inf */\n\t\treport_config_error(CONFIG_INVALID_NUMBER, \"infinite number '%s'\", number);\n\telse if (!(val <= 0 || val >= 0))\t/* NaN */\n\t\treport_config_error(CONFIG_INVALID_NUMBER, \"not a number '%s'\", number);\n\telse if (val < min_val || val > max_val)\n\t\treport_config_error(CONFIG_INVALID_NUMBER, \"number '%s' outside range [%g, %g]\", number, min_val, max_val);\n\telse\n\t\treturn true;\n\n#ifdef _STRICT_CONFIG_\n\treturn false;\n#else\n\treturn ignore_error && val >= min_val && val <= max_val && !__test_bit(CONFIG_TEST_BIT, &debug);\n#endif\n}\n\nbool\nread_int(const char *str, int *res, int min_val, int max_val, bool ignore_error)\n{\n\treturn read_int_func(str, 10, res, min_val, max_val, ignore_error);\n}\n\nbool\nread_unsigned(const char *str, unsigned *res, unsigned min_val, unsigned max_val, bool ignore_error)\n{\n\treturn read_unsigned_func(str, 10, res, min_val, max_val, ignore_error);\n}\n\nbool\nread_unsigned64(const char *str, uint64_t *res, uint64_t min_val, uint64_t max_val, bool ignore_error)\n{\n\treturn read_unsigned64_func(str, 10, res, min_val, max_val, ignore_error);\n}\n\nbool\nread_double(const char *str, double *res, double min_val, double max_val, bool ignore_error)\n{\n\treturn read_double_func(str, res, min_val, max_val, ignore_error);\n}\n\nbool\nread_int_strvec(const vector_t *strvec, size_t index, int *res, int min_val, int max_val, bool ignore_error)\n{\n\treturn read_int_func(strvec_slot(strvec, index), 10, res, min_val, max_val, ignore_error);\n}\n\nbool\nread_unsigned_strvec(const vector_t *strvec, size_t index, unsigned *res, unsigned min_val, unsigned max_val, bool ignore_error)\n{\n\treturn read_unsigned_func(strvec_slot(strvec, index), 10, res, min_val, max_val, ignore_error);\n}\n\nbool\nread_unsigned64_strvec(const vector_t *strvec, size_t index, uint64_t *res, uint64_t min_val, uint64_t max_val, bool ignore_error)\n{\n\treturn read_unsigned64_func(strvec_slot(strvec, index), 10, res, min_val, max_val, ignore_error);\n}\n\nbool\nread_double_strvec(const vector_t *strvec, size_t index, double *res, double min_val, double max_val, bool ignore_error)\n{\n\treturn read_double_func(strvec_slot(strvec, index), res, min_val, max_val, ignore_error);\n}\n\nbool\nread_unsigned_base_strvec(const vector_t *strvec, size_t index, int base, unsigned *res, unsigned min_val, unsigned max_val, bool ignore_error)\n{\n\treturn read_unsigned_func(strvec_slot(strvec, index), base, res, min_val, max_val, ignore_error);\n}\n\nstatic void\nkeyword_alloc(vector_t *keywords_vec, const char *string, void (*handler) (vector_t *), bool active)\n{\n\tkeyword_t *keyword;\n\n\tvector_alloc_slot(keywords_vec);\n\n\tkeyword = (keyword_t *) MALLOC(sizeof(keyword_t));\n\tkeyword->string = string;\n\tkeyword->handler = handler;\n\tkeyword->active = active;\n\n\tvector_set_slot(keywords_vec, keyword);\n}\n\nstatic void\nkeyword_alloc_sub(vector_t *keywords_vec, const char *string, void (*handler) (vector_t *))\n{\n\tint i = 0;\n\tkeyword_t *keyword;\n\n\t/* fetch last keyword */\n\tkeyword = vector_slot(keywords_vec, vector_size(keywords_vec) - 1);\n\n\t/* Don't install subordinate keywords if configuration block inactive */\n\tif (!keyword->active)\n\t\treturn;\n\n\t/* position to last sub level */\n\tfor (i = 0; i < sublevel; i++)\n\t\tkeyword = vector_slot(keyword->sub, vector_size(keyword->sub) - 1);\n\n\t/* First sub level allocation */\n\tif (!keyword->sub)\n\t\tkeyword->sub = vector_alloc();\n\n\t/* add new sub keyword */\n\tkeyword_alloc(keyword->sub, string, handler, true);\n}\n\n/* Exported helpers */\nvoid\ninstall_sublevel(void)\n{\n\tsublevel++;\n}\n\nvoid\ninstall_sublevel_end(void)\n{\n\tsublevel--;\n}\n\nvoid\ninstall_keyword_root(const char *string, void (*handler) (vector_t *), bool active)\n{\n\t/* If the root keyword is inactive, the handler will still be called,\n\t * but with a NULL strvec */\n\tkeyword_alloc(keywords, string, handler, active);\n}\n\nvoid\ninstall_root_end_handler(void (*handler) (void))\n{\n\tkeyword_t *keyword;\n\n\t/* fetch last keyword */\n\tkeyword = vector_slot(keywords, vector_size(keywords) - 1);\n\n\tif (!keyword->active)\n\t\treturn;\n\n\tkeyword->sub_close_handler = handler;\n}\n\nvoid\ninstall_keyword(const char *string, void (*handler) (vector_t *))\n{\n\tkeyword_alloc_sub(keywords, string, handler);\n}\n\nvoid\ninstall_sublevel_end_handler(void (*handler) (void))\n{\n\tint i = 0;\n\tkeyword_t *keyword;\n\n\t/* fetch last keyword */\n\tkeyword = vector_slot(keywords, vector_size(keywords) - 1);\n\n\tif (!keyword->active)\n\t\treturn;\n\n\t/* position to last sub level */\n\tfor (i = 0; i < sublevel; i++)\n\t\tkeyword = vector_slot(keyword->sub, vector_size(keyword->sub) - 1);\n\tkeyword->sub_close_handler = handler;\n}\n\n#if DUMP_KEYWORDS\nstatic void\ndump_keywords(vector_t *keydump, int level, FILE *fp)\n{\n\tunsigned int i;\n\tkeyword_t *keyword_vec;\n\tchar file_name[22];\n\n\tif (!level) {\n\t\tsnprintf(file_name, sizeof(file_name), \"/tmp/keywords.%d\", getpid());\n\t\tfp = fopen_safe(file_name, \"w\");\n\t\tif (!fp)\n\t\t\treturn;\n\t}\n\n\tfor (i = 0; i < vector_size(keydump); i++) {\n\t\tkeyword_vec = vector_slot(keydump, i);\n\t\tfprintf(fp, \"%*sKeyword : %s (%s)\\n\", level * 2, \"\", keyword_vec->string, keyword_vec->active ? \"active\": \"disabled\");\n\t\tif (keyword_vec->sub)\n\t\t\tdump_keywords(keyword_vec->sub, level + 1, fp);\n\t}\n\n\tif (!level)\n\t\tfclose(fp);\n}\n#endif\n\nstatic void\nfree_keywords(vector_t *keywords_vec)\n{\n\tkeyword_t *keyword_vec;\n\tunsigned int i;\n\n\tfor (i = 0; i < vector_size(keywords_vec); i++) {\n\t\tkeyword_vec = vector_slot(keywords_vec, i);\n\t\tif (keyword_vec->sub)\n\t\t\tfree_keywords(keyword_vec->sub);\n\t\tFREE(keyword_vec);\n\t}\n\tvector_free(keywords_vec);\n}\n\n/* Functions used for standard definitions */\nstatic char *\nget_cwd(void)\n{\n\tchar *dir = MALLOC(PATH_MAX);\n\n\t/* Since keepalived doesn't do a chroot(), we don't need to be concerned\n\t * about (unreachable) - see getcwd(3) man page. */\n\treturn getcwd(dir, PATH_MAX);\n}\n\nstatic char *\nget_instance(void)\n{\n\tchar *conf_id = MALLOC(strlen(config_id) + 1);\n\n\tstrcpy(conf_id, config_id);\n\n\treturn conf_id;\n}\n\nvector_t *\nalloc_strvec_quoted_escaped(char *src)\n{\n\tchar *token;\n\tvector_t *strvec;\n\tchar cur_quote = 0;\n\tchar *ofs_op;\n\tchar *op_buf;\n\tchar *ofs, *ofs1;\n\tchar op_char;\n\n\tif (!src) {\n\t\tif (!buf_extern)\n\t\t\treturn NULL;\n\t\tsrc = buf_extern;\n\t}\n\n\t/* Create a vector and alloc each command piece */\n\tstrvec = vector_alloc();\n\top_buf = MALLOC(MAXBUF);\n\n\tofs = src;\n\twhile (*ofs) {\n\t\t/* Find the next 'word' */\n\t\tofs += strspn(ofs, WHITE_SPACE);\n\t\tif (!*ofs)\n\t\t\tbreak;\n\n\t\tofs_op = op_buf;\n\n\t\twhile (*ofs) {\n\t\t\tofs1 = strpbrk(ofs, cur_quote == '\"' ? \"\\\"\\\\\" : cur_quote == '\\'' ? \"'\\\\\" : WHITE_SPACE_STR \"'\\\"\\\\\");\n\n\t\t\tif (!ofs1) {\n\t\t\t\tsize_t len;\n\t\t\t\tif (cur_quote) {\n\t\t\t\t\treport_config_error(CONFIG_UNMATCHED_QUOTE, \"String '%s': missing terminating %c\", src, cur_quote);\n\t\t\t\t\tgoto err_exit;\n\t\t\t\t}\n\t\t\t\tstrcpy(ofs_op, ofs);\n\t\t\t\tlen =  strlen(ofs);\n\t\t\t\tofs += len;\n\t\t\t\tofs_op += len;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Save the wanted text */\n\t\t\tstrncpy(ofs_op, ofs, ofs1 - ofs);\n\t\t\tofs_op += ofs1 - ofs;\n\t\t\tofs = ofs1;\n\n\t\t\tif (*ofs == '\\\\') {\n\t\t\t\t/* It is a '\\' */\n\t\t\t\tofs++;\n\n\t\t\t\tif (!*ofs) {\n\t\t\t\t\tlog_message(LOG_INFO, \"Missing escape char at end: '%s'\", src);\n\t\t\t\t\tgoto err_exit;\n\t\t\t\t}\n\n\t\t\t\tif (*ofs == 'x' && isxdigit(ofs[1])) {\n\t\t\t\t\top_char = 0;\n\t\t\t\t\tofs++;\n\t\t\t\t\twhile (isxdigit(*ofs)) {\n\t\t\t\t\t\top_char <<= 4;\n\t\t\t\t\t\top_char |= isdigit(*ofs) ? *ofs - '0' : (10 + *ofs - (isupper(*ofs)  ? 'A' : 'a'));\n\t\t\t\t\t\tofs++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (*ofs == 'c' && ofs[1]) {\n\t\t\t\t\top_char = *++ofs & 0x1f;\t/* Convert to control character */\n\t\t\t\t\tofs++;\n\t\t\t\t}\n\t\t\t\telse if (*ofs >= '0' && *ofs <= '7') {\n\t\t\t\t\top_char = *ofs++ - '0';\n\t\t\t\t\tif (*ofs >= '0' && *ofs <= '7') {\n\t\t\t\t\t\top_char <<= 3;\n\t\t\t\t\t\top_char += *ofs++ - '0';\n\t\t\t\t\t}\n\t\t\t\t\tif (*ofs >= '0' && *ofs <= '7') {\n\t\t\t\t\t\top_char <<= 3;\n\t\t\t\t\t\top_char += *ofs++ - '0';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tswitch (*ofs) {\n\t\t\t\t\tcase 'a':\n\t\t\t\t\t\top_char = '\\a';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'b':\n\t\t\t\t\t\top_char = '\\b';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'E':\n\t\t\t\t\t\top_char = 0x1b;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'f':\n\t\t\t\t\t\top_char = '\\f';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'n':\n\t\t\t\t\t\top_char = '\\n';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'r':\n\t\t\t\t\t\top_char = '\\r';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 't':\n\t\t\t\t\t\top_char = '\\t';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'v':\n\t\t\t\t\t\top_char = '\\v';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault: /* \\\"'  */\n\t\t\t\t\t\top_char = *ofs;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tofs++;\n\t\t\t\t}\n\n\t\t\t\t*ofs_op++ = op_char;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (cur_quote) {\n\t\t\t\t/* It's the close quote */\n\t\t\t\tofs++;\n\t\t\t\tcur_quote = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (*ofs == '\"' || *ofs == '\\'') {\n\t\t\t\tcur_quote = *ofs++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\n\t\ttoken = MALLOC(ofs_op - op_buf + 1);\n\t\tmemcpy(token, op_buf, ofs_op - op_buf);\n\t\ttoken[ofs_op - op_buf] = '\\0';\n\n\t\t/* Alloc & set the slot */\n\t\tvector_alloc_slot(strvec);\n\t\tvector_set_slot(strvec, token);\n\t}\n\n\tFREE(op_buf);\n\n\tif (!vector_size(strvec)) {\n\t\tfree_strvec(strvec);\n\t\treturn NULL;\n\t}\n\n\treturn strvec;\n\nerr_exit:\n\tfree_strvec(strvec);\n\tFREE(op_buf);\n\treturn NULL;\n}\n\nvector_t *\nalloc_strvec_r(char *string)\n{\n\tchar *cp, *start, *token;\n\tsize_t str_len;\n\tvector_t *strvec;\n\n\tif (!string)\n\t\treturn NULL;\n\n\t/* Create a vector and alloc each command piece */\n\tstrvec = vector_alloc();\n\n\tcp = string;\n\twhile (true) {\n\t\tcp += strspn(cp, WHITE_SPACE);\n\t\tif (!*cp)\n\t\t\tbreak;\n\n\t\tstart = cp;\n\n\t\t/* Save a quoted string without the \"\"s as a single string */\n\t\tif (*start == '\"') {\n\t\t\tstart++;\n\t\t\tif (!(cp = strchr(start, '\"'))) {\n\t\t\t\treport_config_error(CONFIG_UNMATCHED_QUOTE, \"Unmatched quote: '%s'\", string);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstr_len = (size_t)(cp - start);\n\t\t\tcp++;\n\t\t} else {\n\t\t\tcp += strcspn(start, WHITE_SPACE_STR \"\\\"\");\n\t\t\tstr_len = (size_t)(cp - start);\n\t\t}\n\t\ttoken = MALLOC(str_len + 1);\n\t\tmemcpy(token, start, str_len);\n\t\ttoken[str_len] = '\\0';\n\n\t\t/* Alloc & set the slot */\n\t\tvector_alloc_slot(strvec);\n\t\tvector_set_slot(strvec, token);\n\t}\n\n\tif (!vector_size(strvec)) {\n\t\tfree_strvec(strvec);\n\t\treturn NULL;\n\t}\n\n\treturn strvec;\n}\n\ntypedef struct _seq {\n\tchar *var;\n\tint next;\n\tint last;\n\tint step;\n\tchar *text;\n} seq_t;\n\nstatic list seq_list;\t/* List of seq_t */\n\n#ifdef PARSER_DEBUG\nstatic void\ndump_seqs(void)\n{\n\tseq_t *seq;\n\telement e;\n\n\tLIST_FOREACH(seq_list, seq, e)\n\t\tlog_message(LOG_INFO, \"SEQ: %s => %d -> %d step %d: '%s'\", seq->var, seq->next, seq->last, seq->step, seq->text);\n\tlog_message(LOG_INFO, \"%s\", \"\");\n}\n#endif\n\nstatic void\nfree_seq(void *s)\n{\n\tseq_t *seq = s;\n\n\tFREE(seq->var);\n\tFREE(seq->text);\n\tFREE(seq);\n}\n\nstatic bool\nadd_seq(char *buf)\n{\n\tchar *p = buf + 4;\t\t/* Skip ~SEQ */\n\tlong one, two, three;\n\tlong start, step, end;\n\tseq_t *seq_ent;\n\tchar *var;\n\tchar *var_end;\n\n\tp += strspn(p, \" \\t\");\n\tif (*p++ != '(')\n\t\treturn false;\n\tp += strspn(p, \" \\t\");\n\n\tvar = p;\n\n\tp += strcspn(p, \" \\t,)\");\n\tvar_end = p;\n\tp += strspn(p, \" \\t\");\n\tif (!*p || *p == ')' || p == var) {\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"Invalid ~SEQ definition '%s'\", buf);\n\t\treturn false;\n\t}\n\n\tp++;\n\tdo {\n\t\t// Handle missing number\n\t\tone = strtol(p, &p, 0);\n\t\tp += strspn(p, \" \\t\");\n\t\tif (*p == ')') {\n\t\t\tend = one;\n\t\t\tstep = (end < 1) ? -1 : 1;\n\t\t\tstart = (end < 0) ? -1 : 1;\n\n\t\t\tbreak;\n\t\t}\n\n\t\tif (*p != ',') {\n\t\t\treport_config_error(CONFIG_GENERAL_ERROR, \"Invalid ~SEQ definition '%s'\", buf);\n\t\t\treturn false;\n\t\t}\n\n\t\ttwo = strtol(p + 1, &p, 0);\n\t\tp += strspn(p, \" \\t\");\n\t\tif (*p == ')') {\n\t\t\tstart = one;\n\t\t\tend = two;\n\t\t\tstep = start <= end ? 1 : -1;\n\n\t\t\tbreak;\n\t\t}\n\n\t\tif (*p != ',') {\n\t\t\treport_config_error(CONFIG_GENERAL_ERROR, \"Invalid ~SEQ definition '%s'\", buf);\n\t\t\treturn false;\n\t\t}\n\n\t\tthree = strtol(p + 1, &p, 0);\n\t\tp += strspn(p, \" \\t\");\n\t\tif (*p != ')') {\n\t\t\treport_config_error(CONFIG_GENERAL_ERROR, \"Invalid ~SEQ definition '%s'\", buf);\n\t\t\treturn false;\n\t\t}\n\n\t\tstart = one;\n\t\tstep = two;\n\t\tend = three;\n\n\t\tif (!step ||\n\t\t    (start < end && step < 0) ||\n\t\t    (start > end && step > 0))\n\t\t{\n\t\t\treport_config_error(CONFIG_GENERAL_ERROR, \"Invalid ~SEQ values '%s'\", buf);\n\t\t\treturn false;\n\t\t}\n\t} while (false);\n\n\tp += strspn(p + 1, \" \\t\") + 1;\n\n\tPMALLOC(seq_ent);\n\tseq_ent->var = MALLOC(var_end - var + 1);\n\tstrncpy(seq_ent->var, var, var_end - var);\n\tseq_ent->next = start;\n\tseq_ent->step = step;\n\tseq_ent->last = end;\n\tseq_ent->text = MALLOC(strlen(p) + 1);\n\tstrcpy(seq_ent->text, p);\n\n\tif (!seq_list)\n\t\tseq_list = alloc_list(free_seq, NULL);\n\tlist_add(seq_list, seq_ent);\n\n\treturn true;\n}\n\n#ifdef PARSER_DEBUG\nstatic void\ndump_definitions(void)\n{\n\tdef_t *def;\n\telement e;\n\n\tLIST_FOREACH(defs, def, e)\n\t\tlog_message(LOG_INFO, \"Defn %s = '%s'\", def->name, def->value);\n\tlog_message(LOG_INFO, \"%s\", \"\");\n}\n#endif\n\n/* recursive configuration stream handler */\nstatic int kw_level;\nstatic int block_depth;\n\nstatic bool\nprocess_stream(vector_t *keywords_vec, int need_bob)\n{\n\tunsigned int i;\n\tkeyword_t *keyword_vec;\n\tchar *str;\n\tchar *buf;\n\tvector_t *strvec;\n\tvector_t *prev_keywords = current_keywords;\n\tcurrent_keywords = keywords_vec;\n\tint bob_needed = 0;\n\tbool ret_err = false;\n\tbool ret;\n\n\tbuf = MALLOC(MAXBUF);\n\twhile (read_line(buf, MAXBUF)) {\n\t\tstrvec = alloc_strvec(buf);\n\n\t\tif (!strvec)\n\t\t\tcontinue;\n\n\t\tstr = vector_slot(strvec, 0);\n\n\t\tif (skip_sublevel == -1) {\n\t\t\t/* There wasn't a '{' on the keyword line */\n\t\t\tif (!strcmp(str, BOB)) {\n\t\t\t\t/* We've got the opening '{' now */\n\t\t\t\tskip_sublevel = 1;\n\t\t\t\tneed_bob = 0;\n\t\t\t\tfree_strvec(strvec);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* The skipped keyword doesn't have a {} block, so we no longer want to skip */\n\t\t\tskip_sublevel = 0;\n\t\t}\n\t\tif (skip_sublevel) {\n\t\t\tfor (i = 0; i < vector_size(strvec); i++) {\n\t\t\t\tstr = vector_slot(strvec,i);\n\t\t\t\tif (!strcmp(str,BOB))\n\t\t\t\t\tskip_sublevel++;\n\t\t\t\telse if (!strcmp(str,EOB)) {\n\t\t\t\t\tif (--skip_sublevel == 0)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* If we have reached the outer level of the block and we have\n\t\t\t * nested keyword level, then we need to return to restore the\n\t\t\t * next level up of keywords. */\n\t\t\tif (!strcmp(str, EOB) && skip_sublevel == 0 && kw_level > 0) {\n\t\t\t\tret_err = true;\n\t\t\t\tfree_strvec(strvec);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfree_strvec(strvec);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (need_bob) {\n\t\t\tneed_bob = 0;\n\t\t\tif (!strcmp(str, BOB) && kw_level > 0) {\n\t\t\t\tfree_strvec(strvec);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse\n\t\t\t\treport_config_error(CONFIG_MISSING_BOB, \"Missing '%s' at beginning of configuration block\", BOB);\n\t\t}\n\t\telse if (!strcmp(str, BOB)) {\n\t\t\treport_config_error(CONFIG_UNEXPECTED_BOB, \"Unexpected '%s' - ignoring\", BOB);\n\t\t\tfree_strvec(strvec);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!strcmp(str, EOB) && kw_level > 0) {\n\t\t\tfree_strvec(strvec);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!strncmp(str, \"~SEQ\", 4)) {\n\t\t\tif (!add_seq(buf))\n\t\t\t\treport_config_error(CONFIG_GENERAL_ERROR, \"Invalid ~SEQ specification '%s'\", buf);\n\t\t\tfree_strvec(strvec);\n#ifdef PARSER_DEBUG\n\t\t\tdump_definitions();\n\t\t\tdump_seqs();\n#endif\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (i = 0; i < vector_size(keywords_vec); i++) {\n\t\t\tkeyword_vec = vector_slot(keywords_vec, i);\n\n\t\t\tif (!strcmp(keyword_vec->string, str)) {\n\t\t\t\tif (!keyword_vec->active) {\n\t\t\t\t\tif (!strcmp(vector_slot(strvec, vector_size(strvec)-1), BOB))\n\t\t\t\t\t\tskip_sublevel = 1;\n\t\t\t\t\telse\n\t\t\t\t\t\tskip_sublevel = -1;\n\n\t\t\t\t\t/* Sometimes a process wants to know if another process\n\t\t\t\t\t * has any of a type of configuration. For example, there\n\t\t\t\t\t * is no point starting the VRRP process of there are no\n\t\t\t\t\t * vrrp instances, and so the parent process would be\n\t\t\t\t\t * interested in that. */\n\t\t\t\t\tif (keyword_vec->handler)\n\t\t\t\t\t\t(*keyword_vec->handler)(NULL);\n\t\t\t\t}\n\n\t\t\t\t/* There is an inconsistency here. 'static_ipaddress' for example\n\t\t\t\t * does not have sub levels, but needs a '{' */\n\t\t\t\tif (keyword_vec->sub) {\n\t\t\t\t\t/* Remove a trailing '{' */\n\t\t\t\t\tchar *bob = vector_slot(strvec, vector_size(strvec)-1) ;\n\t\t\t\t\tif (!strcmp(bob, BOB)) {\n\t\t\t\t\t\tvector_unset(strvec, vector_size(strvec)-1);\n\t\t\t\t\t\tFREE(bob);\n\t\t\t\t\t\tbob_needed = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tbob_needed = 1;\n\t\t\t\t}\n\n\t\t\t\tif (keyword_vec->active && keyword_vec->handler) {\n\t\t\t\t\tbuf_extern = buf;\t/* In case the raw line wants to be accessed */\n\t\t\t\t\t(*keyword_vec->handler) (strvec);\n\t\t\t\t}\n\n\t\t\t\tif (keyword_vec->sub) {\n\t\t\t\t\tkw_level++;\n\t\t\t\t\tret = process_stream(keyword_vec->sub, bob_needed);\n\t\t\t\t\tkw_level--;\n\n\t\t\t\t\t/* We mustn't run any close handler if the block was skipped */\n\t\t\t\t\tif (!ret && keyword_vec->active && keyword_vec->sub_close_handler)\n\t\t\t\t\t\t(*keyword_vec->sub_close_handler) ();\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (i >= vector_size(keywords_vec))\n\t\t\treport_config_error(CONFIG_UNKNOWN_KEYWORD, \"Unknown keyword '%s'\", str);\n\n\t\tfree_strvec(strvec);\n\t}\n\n\tcurrent_keywords = prev_keywords;\n\tFREE(buf);\n\treturn ret_err;\n}\n\nstatic bool\nread_conf_file(const char *conf_file)\n{\n\tFILE *stream;\n\tglob_t globbuf;\n\tsize_t i;\n\tint\tres;\n\tstruct stat stb;\n\tunsigned num_matches = 0;\n\n\tglobbuf.gl_offs = 0;\n\tres = glob(conf_file, GLOB_MARK\n#if HAVE_DECL_GLOB_BRACE\n\t\t\t\t\t| GLOB_BRACE\n#endif\n\t\t\t\t\t\t    , NULL, &globbuf);\n\n\tif (res) {\n\t\tif (res == GLOB_NOMATCH)\n\t\t\tlog_message(LOG_INFO, \"No config files matched '%s'.\", conf_file);\n\t\telse\n\t\t\tlog_message(LOG_INFO, \"Error reading config file(s): glob(\\\"%s\\\") returned %d, skipping.\", conf_file, res);\n\t\treturn true;\n\t}\n\n\tfor (i = 0; i < globbuf.gl_pathc; i++) {\n\t\tif (globbuf.gl_pathv[i][strlen(globbuf.gl_pathv[i])-1] == '/') {\n\t\t\t/* This is a directory - so skip */\n\t\t\tcontinue;\n\t\t}\n\n\t\tlog_message(LOG_INFO, \"Opening file '%s'.\", globbuf.gl_pathv[i]);\n\t\tstream = fopen(globbuf.gl_pathv[i], \"r\");\n\t\tif (!stream) {\n\t\t\tlog_message(LOG_INFO, \"Configuration file '%s' open problem (%s) - skipping\"\n\t\t\t\t       , globbuf.gl_pathv[i], strerror(errno));\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Make sure what we have opened is a regular file, and not for example a directory or executable */\n\t\tif (fstat(fileno(stream), &stb) ||\n\t\t    !S_ISREG(stb.st_mode) ||\n\t\t    (stb.st_mode & (S_IXUSR | S_IXGRP | S_IXOTH))) {\n\t\t\tlog_message(LOG_INFO, \"Configuration file '%s' is not a regular non-executable file - skipping\", globbuf.gl_pathv[i]);\n\t\t\tfclose(stream);\n\t\t\tcontinue;\n\t\t}\n\n\t\tnum_matches++;\n\n\t\tcurrent_stream = stream;\n\n\t\t/* We only want to report the file name if there is more than one file used */\n\t\tif (current_file_name || globbuf.gl_pathc > 1)\n\t\t\tcurrent_file_name = globbuf.gl_pathv[i];\n\t\tcurrent_file_line_no = 0;\n\n\t\tint curdir_fd = -1;\n\t\tif (strchr(globbuf.gl_pathv[i], '/')) {\n\t\t\t/* If the filename contains a directory element, change to that directory.\n\t\t\t   The man page open(2) states that fchdir() didn't support O_PATH until Linux 3.5,\n\t\t\t   even though testing on Linux 3.1 shows it appears to work. To be safe, don't\n\t\t\t   use it until Linux 3.5. */\n\t\t\tcurdir_fd = open(\".\", O_RDONLY | O_DIRECTORY\n#if HAVE_DECL_O_PATH && LINUX_VERSION_CODE >= KERNEL_VERSION(3,5,0)\n\t\t\t\t\t\t\t\t     | O_PATH\n#endif\n\t\t\t\t\t\t\t\t\t     );\n\n\t\t\tchar *confpath = strdup(globbuf.gl_pathv[i]);\n\t\t\tdirname(confpath);\n\t\t\tif (chdir(confpath) < 0)\n\t\t\t\tlog_message(LOG_INFO, \"chdir(%s) error (%s)\", confpath, strerror(errno));\n\t\t\tfree(confpath);\n\t\t}\n\n\t\tprocess_stream(current_keywords, 0);\n\t\tfclose(stream);\n\n\t\tfree_list(&seq_list);\n\n\t\t/* If we changed directory, restore the previous directory */\n\t\tif (curdir_fd != -1) {\n\t\t\tif ((res = fchdir(curdir_fd)))\n\t\t\t\tlog_message(LOG_INFO, \"Failed to restore previous directory after include\");\n\t\t\tclose(curdir_fd);\n\t\t\tif (res)\n\t\t\t\treturn true;\n\t\t}\n\t}\n\n\tglobfree(&globbuf);\n\n\tif (!num_matches)\n\t\tlog_message(LOG_INFO, \"No config files matched '%s'.\", conf_file);\n\n\treturn false;\n}\n\nbool check_conf_file(const char *conf_file)\n{\n\tglob_t globbuf;\n\tsize_t i;\n\tbool ret = true;\n\tint res;\n\tstruct stat stb;\n\tunsigned num_matches = 0;\n\n\tglobbuf.gl_offs = 0;\n\tres = glob(conf_file, GLOB_MARK\n#if HAVE_DECL_GLOB_BRACE\n\t\t\t\t\t| GLOB_BRACE\n#endif\n\t\t\t\t\t\t    , NULL, &globbuf);\n\tif (res) {\n\t\treport_config_error(CONFIG_FILE_NOT_FOUND, \"Unable to find configuration file %s (glob returned %d)\", conf_file, res);\n\t\treturn false;\n\t}\n\n\tfor (i = 0; i < globbuf.gl_pathc; i++) {\n\t\tif (globbuf.gl_pathv[i][strlen(globbuf.gl_pathv[i])-1] == '/') {\n\t\t\t/* This is a directory - so skip */\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (access(globbuf.gl_pathv[i], R_OK)) {\n\t\t\tlog_message(LOG_INFO, \"Unable to read configuration file %s\", globbuf.gl_pathv[i]);\n\t\t\tret = false;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Make sure that the file is a regular file, and not for example a directory or executable */\n\t\tif (stat(globbuf.gl_pathv[i], &stb) ||\n\t\t    !S_ISREG(stb.st_mode) ||\n\t\t     (stb.st_mode & (S_IXUSR | S_IXGRP | S_IXOTH))) {\n\t\t\tlog_message(LOG_INFO, \"Configuration file '%s' is not a regular non-executable file\", globbuf.gl_pathv[i]);\n\t\t\tret = false;\n\t\t\tbreak;\n\t\t}\n\n\t\tnum_matches++;\n\t}\n\n\tif (ret) {\n\t\tif (num_matches > 1)\n\t\t\treport_config_error(CONFIG_MULTIPLE_FILES, \"WARNING, more than one file matches configuration file %s, using %s\", conf_file, globbuf.gl_pathv[0]);\n\t\telse if (num_matches == 0) {\n\t\t\treport_config_error(CONFIG_FILE_NOT_FOUND, \"Unable to find configuration file %s\", conf_file);\n\t\t\tret = false;\n\t\t}\n\t}\n\n\tglobfree(&globbuf);\n\n\treturn ret;\n}\n\nstatic bool\ncheck_include(char *buf)\n{\n\tvector_t *strvec;\n\tbool ret = false;\n\tFILE *prev_stream;\n\tconst char *prev_file_name;\n\tsize_t prev_file_line_no;\n\n\t/* Simple check first for include */\n\tif (!strstr(buf, \"include\"))\n\t\treturn false;\n\n\tstrvec = alloc_strvec(buf);\n\n\tif (!strvec)\n\t\treturn false;\n\n\tif(!strcmp(\"include\", vector_slot(strvec, 0)) && vector_size(strvec) == 2) {\n\t\tprev_stream = current_stream;\n\t\tprev_file_name = current_file_name;\n\t\tprev_file_line_no = current_file_line_no;\n\n\t\tread_conf_file(vector_slot(strvec, 1));\n\n\t\tcurrent_stream = prev_stream;\n\t\tcurrent_file_name = prev_file_name;\n\t\tcurrent_file_line_no = prev_file_line_no;\n\n\t\tret = true;\n\t}\n\n\tfree_strvec(strvec);\n\treturn ret;\n}\n\nstatic def_t *\nfind_definition(const char *name, size_t len, bool definition)\n{\n\telement e;\n\tdef_t *def;\n\tconst char *p;\n\tbool using_braces = false;\n\tbool allow_multiline;\n\n\tif (LIST_ISEMPTY(defs))\n\t\treturn NULL;\n\n\tif (!definition && *name == BOB[0]) {\n\t\tusing_braces = true;\n\t\tname++;\n\t}\n\n\tif (!isalpha(*name) && *name != '_')\n\t\treturn NULL;\n\n\tif (!len) {\n\t\tfor (len = 1, p = name + 1; *p != '\\0' && (isalnum(*p) || *p == '_'); len++, p++);\n\n\t\t/* Check we have a suitable end character */\n\t\tif (using_braces && *p != EOB[0])\n\t\t\treturn NULL;\n\n\t\tif (!using_braces && !definition &&\n\t\t     *p != ' ' && *p != '\\t' && *p != '\\0')\n\t\t\treturn NULL;\n\t}\n\n\tif (definition ||\n\t    (!using_braces && name[len] == '\\0') ||\n\t    (using_braces && name[len+1] == '\\0'))\n\t\tallow_multiline = true;\n\telse\n\t\tallow_multiline = false;\n\n\tfor (e = LIST_HEAD(defs); e; ELEMENT_NEXT(e)) {\n\t\tdef = ELEMENT_DATA(e);\n\t\tif (def->name_len == len &&\n\t\t    (allow_multiline || !def->multiline) &&\n\t\t    !strncmp(def->name, name, len))\n\t\t\treturn def;\n\t}\n\n\treturn NULL;\n}\n\nstatic bool\nreplace_param(char *buf, size_t max_len, char **multiline_ptr_ptr)\n{\n\tchar *cur_pos = buf;\n\tsize_t len_used = strlen(buf);\n\tdef_t *def;\n\tchar *s, *d, *e;\n\tssize_t i;\n\tsize_t extra_braces;\n\tsize_t replacing_len;\n\tchar *next_ptr = NULL;\n\tbool found_defn = false;\n\tchar *multiline_ptr = *multiline_ptr_ptr;\n\n\twhile ((cur_pos = strchr(cur_pos, '$')) && cur_pos[1] != '\\0') {\n\t\tif ((def = find_definition(cur_pos + 1, 0, false))) {\n\t\t\tfound_defn = true;\n\t\t\textra_braces = cur_pos[1] == BOB[0] ? 2 : 0;\n\t\t\tnext_ptr = multiline_ptr;\n\n\t\t\t/* We are in a multiline expansion, and now have another\n\t\t\t * one, so save the previous state on the multiline stack */\n\t\t\tif (def->multiline && multiline_ptr) {\n\t\t\t\tif (!LIST_EXISTS(multiline_stack))\n\t\t\t\t\tmultiline_stack = alloc_list(NULL, NULL);\n\t\t\t\tlist_add(multiline_stack, multiline_ptr);\n\t\t\t}\n\n\t\t\tif (def->fn) {\n\t\t\t\t/* This is a standard definition that uses a function for the replacement text */\n\t\t\t\tif (def->value)\n\t\t\t\t\tFREE(def->value);\n\t\t\t\tdef->value = (*def->fn)();\n\t\t\t\tdef->value_len = strlen(def->value);\n\t\t\t}\n\n\t\t\t/* Ensure there is enough room to replace $PARAM or ${PARAM} with value */\n\t\t\tif (def->multiline) {\n\t\t\t\treplacing_len = strcspn(def->value, DEF_LINE_END);\n\t\t\t\tnext_ptr = def->value + replacing_len + 1;\n\t\t\t\tmultiline_ptr = next_ptr;\n\t\t\t}\n\t\t\telse\n\t\t\t\treplacing_len = def->value_len;\n\n\t\t\tif (len_used + replacing_len - (def->name_len + 1 + extra_braces) >= max_len) {\n\t\t\t\tlog_message(LOG_INFO, \"Parameter substitution on line '%s' would exceed maximum line length\", buf);\n\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\t\tif (def->name_len + 1 + extra_braces != replacing_len) {\n\t\t\t\t/* We need to move the existing text */\n\t\t\t\tif (def->name_len + 1 + extra_braces < replacing_len) {\n\t\t\t\t\t/* We are lengthening the buf text */\n\t\t\t\t\ts = cur_pos + strlen(cur_pos);\n\t\t\t\t\td = s - (def->name_len + 1 + extra_braces) + replacing_len;\n\t\t\t\t\te = cur_pos;\n\t\t\t\t\ti = -1;\n\t\t\t\t} else {\n\t\t\t\t\t/* We are shortening the buf text */\n\t\t\t\t\ts = cur_pos + (def->name_len + 1 + extra_braces) - replacing_len;\n\t\t\t\t\td = cur_pos;\n\t\t\t\t\te = cur_pos + strlen(cur_pos);\n\t\t\t\t\ti = 1;\n\t\t\t\t}\n\n\t\t\t\tdo {\n\t\t\t\t\t*d = *s;\n\t\t\t\t\tif (s == e)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\td += i;\n\t\t\t\t\ts += i;\n\t\t\t\t} while (true);\n\n\t\t\t\tlen_used = len_used + replacing_len - (def->name_len + 1 + extra_braces);\n\t\t\t}\n\n\t\t\t/* Now copy the replacement text */\n\t\t\tstrncpy(cur_pos, def->value, replacing_len);\n\n\t\t\tif (def->value[strspn(def->value, \" \\t\")] == '~')\n\t\t\t\tbreak;\n\t\t}\n\t\telse\n\t\t\tcur_pos++;\n\t}\n\n\t/* If we did a replacement, update the multiline_ptr */\n\tif (found_defn)\n\t\t*multiline_ptr_ptr = next_ptr;\n\n\treturn found_defn;\n}\n\nstatic void\nfree_definition(void *d)\n{\n\tdef_t *def = d;\n\n\tFREE(def->name);\n\tFREE_PTR(def->value);\n\tFREE(def);\n}\n\nstatic def_t*\nset_definition(const char *name, const char *value)\n{\n\tdef_t *def;\n\tsize_t name_len = strlen(name);\n\n\tif ((def = find_definition(name, name_len, false))) {\n\t\tFREE(def->value);\n\t\tdef->fn = NULL;\t\t/* Allow a standard definition to be overridden */\n\t}\n\telse {\n\t\tdef = MALLOC(sizeof(*def));\n\t\tdef->name_len = name_len;\n\t\tdef->name = MALLOC(name_len + 1);\n\t\tstrcpy(def->name, name);\n\n\t\tif (!LIST_EXISTS(defs))\n\t\t\tdefs = alloc_list(free_definition, NULL);\n\t\tlist_add(defs, def);\n\t}\n\tdef->value_len = strlen(value);\n\tdef->value = MALLOC(def->value_len + 1);\n\tstrcpy(def->value, value);\n\n#ifdef PARSER_DEBUG\n\tlog_message(LOG_INFO, \"Definition %s now '%s'\", def->name, def->value);\n#endif\n\n\treturn def;\n}\n\n/* A definition is of the form $NAME=TEXT */\nstatic def_t*\ncheck_definition(const char *buf)\n{\n\tconst char *p;\n\tdef_t* def;\n\tsize_t def_name_len;\n\tchar *str;\n\n\tif (buf[0] != '$')\n\t\treturn false;\n\n\tif (!isalpha(buf[1]) && buf[1] != '_')\n\t\treturn NULL;\n\n\tfor (p = buf + 2; *p; p++) {\n\t\tif (*p == '=')\n\t\t\tbreak;\n\t\tif (!isalnum(*p) &&\n\t\t    !isdigit(*p) &&\n\t\t    *p != '_')\n\t\t\treturn NULL;\n\t}\n\n\tdef_name_len = (size_t)(p - &buf[1]);\n\n\tp += strspn(p, \" \\t\");\n\tif (*p != '=')\n\t\treturn NULL;\n\n\tif ((def = find_definition(&buf[1], def_name_len, true))) {\n\t\tFREE(def->value);\n\t\tdef->fn = NULL;\t\t/* Allow a standard definition to be overridden */\n\t}\n\telse {\n\t\tdef = MALLOC(sizeof(*def));\n\t\tdef->name_len = def_name_len;\n\t\tstr = MALLOC(def->name_len + 1);\n\t\tstrncpy(str, &buf[1], def->name_len);\n\t\tstr[def->name_len] = '\\0';\n\t\tdef->name = str;\n\n\t\tif (!LIST_EXISTS(defs))\n\t\t\tdefs = alloc_list(free_definition, NULL);\n\t\tlist_add(defs, def);\n\t}\n\n\t/* Skip leading whitespace */\n\tp += strspn(p + 1, \" \\t\") + 1;\n\tdef->value_len = strlen(p);\n\tif (p[def->value_len - 1] == '\\\\') {\n\t\t/* Remove trailing whitespace */\n\t\twhile (def->value_len >= 2 &&\n\t\t       isblank(p[def->value_len - 2]))\n\t\t\tdef->value_len--;\n\n\t\tif (def->value_len < 2) {\n\t\t\t/* If the string has nothing except spaces and terminating '\\'\n\t\t\t * point to the string terminator. */\n\t\t\tp += def->value_len;\n\t\t\tdef->value_len = 0;\n\t\t}\n\t\tdef->multiline = true;\n\t} else\n\t\tdef->multiline = false;\n\n\tstr = MALLOC(def->value_len + 1);\n\tstrcpy(str, p);\n\tdef->value = str;\n\n\t/* If it a multiline definition, we need to mark the end of the first line\n\t * by overwriting the '\\' with the line end marker. */\n\tif (def->value_len >= 2 && def->multiline)\n\t\tdef->value[def->value_len - 1] = DEF_LINE_END[0];\n\n\treturn def;\n}\n\nstatic void\nadd_std_definition(const char *name, const char *value, char *(*fn)(void))\n{\n\tdef_t* def;\n\n\tdef = MALLOC(sizeof(*def));\n\tdef->name_len = strlen(name);\n\tdef->name = MALLOC(def->name_len + 1);\n\tstrcpy(def->name, name);\n\tif (value) {\n\t\tdef->value_len = strlen(value);\n\t\tdef->value = MALLOC(def->value_len + 1);\n\t\tstrcpy(def->value, value);\n\t}\n\tdef->fn = fn;\n\n\tif (!LIST_EXISTS(defs))\n\t\tdefs = alloc_list(free_definition, NULL);\n\tlist_add(defs, def);\n}\n\nstatic void\nset_std_definitions(void)\n{\n\tadd_std_definition(\"_PWD\", NULL, get_cwd);\n\tadd_std_definition(\"_INSTANCE\", NULL, get_instance);\n}\n\nstatic void\nfree_parser_data(void)\n{\n\tif (LIST_EXISTS(defs))\n\t\tfree_list(&defs);\n\n\tif (LIST_EXISTS(multiline_stack))\n\t\tfree_list(&multiline_stack);\n}\n\n/* decomment() removes comments, the escaping of comment start characters,\n * and leading and trailing whitespace, including whitespace before a\n * terminating \\ character */\nstatic void\ndecomment(char *str)\n{\n\tbool quote = false;\n\tbool cont = false;\n\tchar *skip = NULL;\n\tchar *p = str + strspn(str, \" \\t\");\n\n\t/* Remove leading whitespace */\n\tif (p != str)\n\t\tmemmove(str, p, strlen(p) + 1);\n\n\tp = str;\n\twhile ((p = strpbrk(p, \"!#\\\"\\\\\"))) {\n\t\tif (*p == '\"') {\n\t\t\tif (!skip)\n\t\t\t\tquote = !quote;\n\t\t\tp++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (*p == '\\\\') {\n\t\t\tif (p[1]) {\n\t\t\t\t/* Don't modify quoted strings */\n\t\t\t\tif (!quote && (p[1] == '#' || p[1] == '!')) {\n\t\t\t\t\tmemmove(p, p + 1, strlen(p + 1) + 1);\n\t\t\t\t\tp++;\n\t\t\t\t} else\n\t\t\t\t\tp += 2;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t*p = '\\0';\n\t\t\tcont = true;\n\t\t\tbreak;\n\t\t}\n\t\tif (!quote && !skip && (*p == '!' || *p == '#'))\n\t\t\tskip = p;\n\t\tp++;\n\t}\n\n\tif (quote)\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"Unterminated quote '%s'\", str);\n\n\tif (skip)\n\t\t*skip = '\\0';\n\n\t/* Remove trailing whitespace */\n\tp = str + strlen(str) - 1;\n\twhile (p >= str && isblank(*p))\n\t\t*p-- = '\\0';\n\tif (cont) {\n\t\t*++p = '\\\\';\n\t\t*++p = '\\0';\n\t}\n}\n\nstatic bool\nread_line(char *buf, size_t size)\n{\n\tsize_t len ;\n\tbool eof = false;\n\tsize_t config_id_len;\n\tchar *buf_start;\n\tbool rev_cmp;\n\tsize_t ofs;\n\tbool recheck;\n\tstatic def_t *def = NULL;\n\tstatic char *next_ptr = NULL;\n\tbool multiline_param_def = false;\n\tchar *end;\n\tstatic char *line_residue = NULL;\n\tsize_t skip;\n\tchar *p;\n\n\tconfig_id_len = config_id ? strlen(config_id) : 0;\n\tdo {\n\t\tif (line_residue) {\n\t\t\tstrcpy(buf, line_residue);\n\t\t\tFREE(line_residue);\n\t\t\tline_residue = NULL;\n\t\t}\n\t\telse if (next_ptr) {\n\t\t\t/* We are expanding a multiline parameter, so copy next line */\n\t\t\tend = strchr(next_ptr, DEF_LINE_END[0]);\n\t\t\tif (!end) {\n\t\t\t\tstrcpy(buf, next_ptr);\n\t\t\t\tif (!LIST_ISEMPTY(multiline_stack)) {\n\t\t\t\t\tnext_ptr = LIST_TAIL_DATA(multiline_stack);\n\t\t\t\t\tlist_remove(multiline_stack, multiline_stack->tail);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tnext_ptr = NULL;\n\t\t\t} else {\n\t\t\t\tstrncpy(buf, next_ptr, (size_t)(end - next_ptr));\n\t\t\t\tbuf[end - next_ptr] = '\\0';\n\t\t\t\tnext_ptr = end + 1;\n\t\t\t}\n\t\t}\n\t\telse if (!LIST_ISEMPTY(seq_list)) {\n\t\t\tseq_t *seq = LIST_TAIL_DATA(seq_list);\n\t\t\tchar val[12];\n\t\t\tsnprintf(val, sizeof(val), \"%d\", seq->next);\n#ifdef PARSER_DEBUG\n\t\t\tlog_message(LOG_INFO, \"Processing seq %d of %s for '%s'\",  seq->next, seq->var, seq->text);\n#endif\n\t\t\tset_definition(seq->var, val);\n\t\t\tstrcpy(buf, seq->text);\n\t\t\tseq->next += seq->step;\n\t\t\tif ((seq->step > 0 && seq->next > seq->last) ||\n\t\t\t    (seq->step < 0 && seq->next < seq->last)) {\n#ifdef PARSER_DEBUG\n\t\t\t\tlog_message(LOG_INFO, \"Removing seq %s for '%s'\", seq->var, seq->text);\n#endif\n\t\t\t\tlist_remove(seq_list, seq_list->tail);\n\t\t\t}\n\t\t}\n\t\telse {\nretry:\n\t\t\tif (!fgets(buf, (int)size, current_stream))\n\t\t\t{\n\t\t\t\teof = true;\n\t\t\t\tbuf[0] = '\\0';\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Check if we have read the end of a line */\n\t\t\tlen = strlen(buf);\n\t\t\tif (buf[0] && buf[len-1] == '\\n')\n\t\t\t\tcurrent_file_line_no++;\n\n\t\t\t/* Remove end of line chars */\n\t\t\twhile (len && (buf[len-1] == '\\n' || buf[len-1] == '\\r'))\n\t\t\t\tlen--;\n\n\t\t\t/* Skip blank lines */\n\t\t\tif (!len)\n\t\t\t\tgoto retry;\n\n\t\t\tbuf[len] = '\\0';\n\n\t\t\tdecomment(buf);\n\t\t}\n\n\t\tlen = strlen(buf);\n\n\t\t/* Handle multi-line definitions */\n\t\tif (multiline_param_def) {\n\t\t\t/* Remove trailing whitespace */\n\t\t\tif (len && buf[len-1] == '\\\\') {\n\t\t\t\tlen--;\n\t\t\t\twhile (len >= 1 && isblank(buf[len - 1]))\n\t\t\t\t\tlen--;\n\t\t\t\tbuf[len++] = DEF_LINE_END[0];\n\t\t\t} else {\n\t\t\t\tmultiline_param_def = false;\n\t\t\t\tif (!def->value_len)\n\t\t\t\t\tdef->multiline = false;\n\t\t\t}\n\n\t\t\t/* Don't add blank lines */\n\t\t\tif (len >= 2 ||\n\t\t\t    (len && !multiline_param_def)) {\n\t\t\t\t/* Add the line to the definition */\n\t\t\t\tdef->value = REALLOC(def->value, def->value_len + len + 1);\n\t\t\t\tstrncpy(def->value + def->value_len, buf, len);\n\t\t\t\tdef->value_len += len;\n\t\t\t\tdef->value[def->value_len] = '\\0';\n\t\t\t}\n\n\t\t\tbuf[0] = '\\0';\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (len == 0)\n\t\t\tcontinue;\n\n\t\trecheck = false;\n\t\tdo {\n\t\t\tif (buf[0] == '@') {\n\t\t\t\t/* If the line starts '@', check the following word matches the system id.\n\t\t\t\t   @^ reverses the sense of the match */\n\t\t\t\tif (buf[1] == '^') {\n\t\t\t\t\trev_cmp = true;\n\t\t\t\t\tofs = 2;\n\t\t\t\t} else {\n\t\t\t\t\trev_cmp = false;\n\t\t\t\t\tofs = 1;\n\t\t\t\t}\n\n\t\t\t\t/* We need something after the system_id */\n\t\t\t\tif (!(buf_start = strpbrk(buf + ofs, \" \\t\"))) {\n\t\t\t\t\tbuf[0] = '\\0';\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t/* Check if config_id matches/doesn't match as appropriate */\n\t\t\t\tif ((!config_id ||\n\t\t\t\t     (size_t)(buf_start - (buf + ofs)) != config_id_len ||\n\t\t\t\t     strncmp(buf + ofs, config_id, config_id_len)) != rev_cmp) {\n\t\t\t\t\tbuf[0] = '\\0';\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t/* Remove the @config_id from start of line */\n\t\t\t\tbuf_start += strspn(buf_start, \" \\t\");\n\t\t\t\tlen -= (buf_start - buf);\n\t\t\t\tmemmove(buf, buf_start, len + 1);\n\t\t\t}\n\n\t\t\tif (buf[0] == '$' && (def = check_definition(buf))) {\n\t\t\t\t/* check_definition() saves the definition */\n\t\t\t\tif (def->multiline)\n\t\t\t\t\tmultiline_param_def = true;\n\t\t\t\tbuf[0] = '\\0';\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (buf[0] == '~')\n\t\t\t\tbreak;\n\n\t\t\tif (!LIST_ISEMPTY(defs) && (p = strchr(buf, '$'))) {\n\t\t\t\tif (!replace_param(buf, size, &next_ptr)) {\n\t\t\t\t\t/* If nothing has changed, we don't need to do any more processing */\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (buf[0] == '@')\n\t\t\t\t\trecheck = true;\n\t\t\t\tif (strchr(buf, '$'))\n\t\t\t\t\trecheck = true;\n\t\t\t}\n\t\t} while (recheck);\n\t} while (buf[0] == '\\0' || check_include(buf));\n\n\t/* Search for BOB[0] or EOB[0] not in \"\" */\n\tif (buf[0]) {\n\t\tp = buf;\n\t\tif (p[0] != BOB[0] && p[0] != EOB[0]) {\n\t\t\twhile ((p = strpbrk(p, BOB EOB \"\\\"\"))) {\n\t\t\t\tif (*p != '\"')\n\t\t\t\t\tbreak;\n\n\t\t\t\t/* Skip over anything in \"\"s */\n\t\t\t\tif (!(p = strchr(p + 1, '\"')))\n\t\t\t\t\tbreak;\n\n\t\t\t\tp++;\n\t\t\t}\n\t\t}\n\n\t\tif (p && (p[0] == BOB[0] || p[0] == EOB[0])) {\n\t\t\tif (p == buf)\n\t\t\t\tskip = strspn(p + 1, \" \\t\") + 1;\n\t\t\telse\n\t\t\t\tskip = 0;\n\n\t\t\tif (p[skip]) {\n\t\t\t\t/* Skip trailing whitespace */\n\t\t\t\tlen = strlen(p + skip);\n\t\t\t\twhile (len && (p[skip+len-1] == ' ' || p[skip+len-1] == '\\t'))\n\t\t\t\t\tlen--;\n\t\t\t\tline_residue = MALLOC(len + 1);\n\t\t\t\tp[skip+len] = '\\0';\n\t\t\t\tstrcpy(line_residue, p + skip);\n\t\t\t\tp[skip] = '\\0';\n\t\t\t}\n\t\t}\n\n\t\t/* Skip trailing whitespace */\n\t\tlen = strlen(buf);\n\t\twhile (len && (buf[len-1] == ' ' || buf[len-1] == '\\t'))\n\t\t\tlen--;\n\t\tbuf[len] = '\\0';\n\n\t\t/* Check that we haven't got too many '}'s */\n\t\tif (!strcmp(buf, BOB))\n\t\t\tblock_depth++;\n\t\telse if (!strcmp(buf, EOB)) {\n\t\t\tif (--block_depth < 0) {\n\t\t\t\treport_config_error(CONFIG_UNEXPECTED_EOB, \"Extra '}' found\");\n\t\t\t\tblock_depth = 0;\n\t\t\t}\n\t\t}\n\t}\n\n#ifdef PARSER_DEBUG\n\tlog_message(LOG_INFO, \"read_line(%d): '%s'\", block_depth, buf);\n#endif\n\n\treturn !eof;\n}\n\nvoid\nalloc_value_block(void (*alloc_func) (vector_t *), const char *block_type)\n{\n\tchar *buf;\n\tchar *str = NULL;\n\tvector_t *vec = NULL;\n\tbool first_line = true;\n\n\tbuf = (char *) MALLOC(MAXBUF);\n\twhile (read_line(buf, MAXBUF)) {\n\t\tif (!(vec = alloc_strvec(buf)))\n\t\t\tcontinue;\n\n\t\tif (first_line) {\n\t\t\tfirst_line = false;\n\n\t\t\tif (!strcmp(vector_slot(vec, 0), BOB)) {\n\t\t\t\tfree_strvec(vec);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tlog_message(LOG_INFO, \"'%s' missing from beginning of block %s\", BOB, block_type);\n\t\t}\n\n\t\tstr = vector_slot(vec, 0);\n\t\tif (!strcmp(str, EOB)) {\n\t\t\tfree_strvec(vec);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (vector_size(vec))\n\t\t\t(*alloc_func) (vec);\n\n\t\tfree_strvec(vec);\n\t}\n\tFREE(buf);\n}\n\nstatic vector_t *read_value_block_vec;\nstatic void\nread_value_block_line(vector_t *strvec)\n{\n\tsize_t word;\n\tchar *str;\n\tchar *dup;\n\n\tif (!read_value_block_vec)\n\t\tread_value_block_vec = vector_alloc();\n\n\tvector_foreach_slot(strvec, str, word) {\n\t\tdup = (char *) MALLOC(strlen(str) + 1);\n\t\tstrcpy(dup, str);\n\t\tvector_alloc_slot(read_value_block_vec);\n\t\tvector_set_slot(read_value_block_vec, dup);\n\t}\n}\n\nvector_t *\nread_value_block(vector_t *strvec)\n{\n\tvector_t *ret_vec;\n\n\talloc_value_block(read_value_block_line, vector_slot(strvec,0));\n\n\tret_vec = read_value_block_vec;\n\tread_value_block_vec = NULL;\n\n\treturn ret_vec;\n}\n\nvoid *\nset_value(vector_t *strvec)\n{\n\tchar *str;\n\tsize_t size;\n\tchar *alloc;\n\n\tif (vector_size(strvec) < 2)\n\t\treturn NULL;\n\n\tstr = vector_slot(strvec, 1);\n\tsize = strlen(str);\n\n\talloc = (char *) MALLOC(size + 1);\n\tif (!alloc)\n\t\treturn NULL;\n\n\tmemcpy(alloc, str, size);\n\n\treturn alloc;\n}\n\nbool\nread_timer(vector_t *strvec, size_t index, unsigned long *res, unsigned long min_time, unsigned long max_time, __attribute__((unused)) bool ignore_error)\n{\n\tunsigned long timer;\n\tchar *endptr;\n\tchar *warn = \"\";\n\n#ifndef _STRICT_CONFIG_\n\tif (ignore_error && !__test_bit(CONFIG_TEST_BIT, &debug))\n\t\twarn = \"WARNING - \";\n#endif\n\n\tif (!max_time)\n\t\tmax_time = TIMER_MAX;\n\n\terrno = 0;\n\ttimer = strtoul(vector_slot(strvec, index), &endptr, 10);\n\t*res = (timer > TIMER_MAX ? TIMER_MAX : timer) * TIMER_HZ;\n\n\tif (FMT_STR_VSLOT(strvec, index)[0] == '-')\n\t\treport_config_error(CONFIG_INVALID_NUMBER, \"%snegative number '%s'\", warn, FMT_STR_VSLOT(strvec, index));\n\telse if (*endptr)\n\t\treport_config_error(CONFIG_INVALID_NUMBER, \"%sinvalid number '%s'\", warn, FMT_STR_VSLOT(strvec, index));\n\telse if (errno == ERANGE || timer > TIMER_MAX)\n\t\treport_config_error(CONFIG_INVALID_NUMBER, \"%snumber '%s' outside timer range\", warn, FMT_STR_VSLOT(strvec, index));\n\telse if (timer < min_time || timer > max_time)\n\t\treport_config_error(CONFIG_INVALID_NUMBER, \"number '%s' outside range [%ld, %ld]\", FMT_STR_VSLOT(strvec, index), min_time, max_time ? max_time : TIMER_MAX);\n\telse\n\t\treturn true;\n\n#ifdef _STRICT_CONFIG_\n\treturn false;\n#else\n\treturn ignore_error && timer >= min_time && timer <= max_time && !__test_bit(CONFIG_TEST_BIT, &debug);\n#endif\n}\n\n/* Checks for on/true/yes or off/false/no */\nint\ncheck_true_false(char *str)\n{\n\tif (!strcmp(str, \"true\") || !strcmp(str, \"on\") || !strcmp(str, \"yes\"))\n\t\treturn true;\n\tif (!strcmp(str, \"false\") || !strcmp(str, \"off\") || !strcmp(str, \"no\"))\n\t\treturn false;\n\n\treturn -1;\t/* error */\n}\n\nvoid skip_block(bool need_block_start)\n{\n\t/* Don't process the rest of the configuration block */\n\tif (need_block_start)\n\t\tskip_sublevel = -1;\n\telse\n\t\tskip_sublevel = 1;\n}\n\n/* Data initialization */\nvoid\ninit_data(const char *conf_file, vector_t * (*init_keywords) (void))\n{\n\t/* Init Keywords structure */\n\tkeywords = vector_alloc();\n\n\t(*init_keywords) ();\n\n\t/* Add out standard definitions */\n\tset_std_definitions();\n\n#if DUMP_KEYWORDS\n\t/* Dump configuration */\n\tdump_keywords(keywords, 0, NULL);\n#endif\n\n\t/* Stream handling */\n\tcurrent_keywords = keywords;\n\n\tcurrent_file_name = NULL;\n\tcurrent_file_line_no = 0;\n\n\t/* A parent process may have left these set */\n\tblock_depth = 0;\n\tkw_level = 0;\n\n\tregister_null_strvec_handler(null_strvec);\n\tread_conf_file(conf_file);\n\tunregister_null_strvec_handler();\n\n\t/* Report if there are missing '}'s. If there are missing '{'s it will already have been reported */\n\tif (block_depth > 0)\n\t\treport_config_error(CONFIG_MISSING_EOB, \"There are %d missing '%s's or extra '%s's\", block_depth, EOB, BOB);\n\n\t/* We have finished reading the configuration files, so any configuration\n\t * errors report from now mustn't include a reference to the config file name */\n\tcurrent_file_line_no = 0;\n\n\t/* Close the password database if it was opened */\n\tendpwent();\n\n\tfree_keywords(keywords);\n\tfree_parser_data();\n#ifdef _WITH_VRRP_\n\tclear_rt_names();\n#endif\n\tnotify_resource_release();\n}\n", "/*\n * Soft:        Keepalived is a failover program for the LVS project\n *              <www.linuxvirtualserver.org>. It monitor & manipulate\n *              a loadbalanced server pool using multi-layer checks.\n *\n * Part:        General program utils.\n *\n * Author:      Alexandre Cassen, <acassen@linux-vs.org>\n *\n *              This program is distributed in the hope that it will be useful,\n *              but WITHOUT ANY WARRANTY; without even the implied warranty of\n *              MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n *              See the GNU General Public License for more details.\n *\n *              This program is free software; you can redistribute it and/or\n *              modify it under the terms of the GNU General Public License\n *              as published by the Free Software Foundation; either version\n *              2 of the License, or (at your option) any later version.\n *\n * Copyright (C) 2001-2017 Alexandre Cassen, <acassen@gmail.com>\n */\n\n#include \"config.h\"\n\n/* System includes */\n#include <string.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <stdlib.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <sys/utsname.h>\n#include <stdint.h>\n#include <errno.h>\n#ifdef _WITH_PERF_\n#include <stdio.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/epoll.h>\n#include <sys/inotify.h>\n#endif\n\n#if !defined _HAVE_LIBIPTC_ || defined _LIBIPTC_DYNAMIC_\n#include <signal.h>\n#include <sys/wait.h>\n#endif\n\n#ifdef _WITH_STACKTRACE_\n#include <sys/stat.h>\n#include <execinfo.h>\n#include <memory.h>\n#endif\n\n/* Local includes */\n#include \"utils.h\"\n#include \"memory.h\"\n#include \"utils.h\"\n#include \"signals.h\"\n#include \"bitops.h\"\n#include \"parser.h\"\n#if !defined _HAVE_LIBIPTC_ || defined _LIBIPTC_DYNAMIC_ || defined _WITH_STACKTRACE_ || defined _WITH_PERF_\n#include \"logger.h\"\n#endif\n#if !defined _HAVE_LIBIPTC_ || defined _LIBIPTC_DYNAMIC_\n#include \"process.h\"\n#endif\n\n/* global vars */\nunsigned long debug = 0;\n\n/* Display a buffer into a HEXA formated output */\nvoid\ndump_buffer(char *buff, size_t count, FILE* fp, int indent)\n{\n\tsize_t i, j, c;\n\tbool printnext = true;\n\n\tif (count % 16)\n\t\tc = count + (16 - count % 16);\n\telse\n\t\tc = count;\n\n\tfor (i = 0; i < c; i++) {\n\t\tif (printnext) {\n\t\t\tprintnext = false;\n\t\t\tfprintf(fp, \"%*s%.4zu \", indent, \"\", i & 0xffff);\n\t\t}\n\t\tif (i < count)\n\t\t\tfprintf(fp, \"%3.2x\", buff[i] & 0xff);\n\t\telse\n\t\t\tfprintf(fp, \"   \");\n\t\tif (!((i + 1) % 8)) {\n\t\t\tif ((i + 1) % 16)\n\t\t\t\tfprintf(fp, \" -\");\n\t\t\telse {\n\t\t\t\tfprintf(fp, \"   \");\n\t\t\t\tfor (j = i - 15; j <= i; j++)\n\t\t\t\t\tif (j < count) {\n\t\t\t\t\t\tif ((buff[j] & 0xff) >= 0x20\n\t\t\t\t\t\t    && (buff[j] & 0xff) <= 0x7e)\n\t\t\t\t\t\t\tfprintf(fp, \"%c\",\n\t\t\t\t\t\t\t       buff[j] & 0xff);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tfprintf(fp, \".\");\n\t\t\t\t\t} else\n\t\t\t\t\t\tfprintf(fp, \" \");\n\t\t\t\tfprintf(fp, \"\\n\");\n\t\t\t\tprintnext = true;\n\t\t\t}\n\t\t}\n\t}\n}\n\n#ifdef _WITH_STACKTRACE_\nvoid\nwrite_stacktrace(const char *file_name, const char *str)\n{\n\tint fd;\n\tvoid *buffer[100];\n\tint nptrs;\n\tint i;\n\tchar **strs;\n\n\tnptrs = backtrace(buffer, 100);\n\tif (file_name) {\n\t\tfd = open(file_name, O_WRONLY | O_APPEND | O_CREAT | O_NOFOLLOW, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH);\n\t\tif (str)\n\t\t\tdprintf(fd, \"%s\\n\", str);\n\t\tbacktrace_symbols_fd(buffer, nptrs, fd);\n\t\tif (write(fd, \"\\n\", 1) != 1) {\n\t\t\t/* We don't care, but this stops a warning on Ubuntu */\n\t\t}\n\t\tclose(fd);\n\t} else {\n\t\tif (str)\n\t\t\tlog_message(LOG_INFO, \"%s\", str);\n\t\tstrs = backtrace_symbols(buffer, nptrs);\n\t\tif (strs == NULL) {\n\t\t\tlog_message(LOG_INFO, \"Unable to get stack backtrace\");\n\t\t\treturn;\n\t\t}\n\n\t\t/* We don't need the call to this function, or the first two entries on the stack */\n\t\tfor (i = 1; i < nptrs - 2; i++)\n\t\t\tlog_message(LOG_INFO, \"  %s\", strs[i]);\n\t\tfree(strs);\n\t}\n}\n#endif\n\nchar *\nmake_file_name(const char *name, const char *prog, const char *namespace, const char *instance)\n{\n\tconst char *extn_start;\n\tconst char *dir_end;\n\tsize_t len;\n\tchar *file_name;\n\n\tif (!name)\n\t\treturn NULL;\n\n\tlen = strlen(name);\n\tif (prog)\n\t\tlen += strlen(prog) + 1;\n\tif (namespace)\n\t\tlen += strlen(namespace) + 1;\n\tif (instance)\n\t\tlen += strlen(instance) + 1;\n\n\tfile_name = MALLOC(len + 1);\n\tdir_end = strrchr(name, '/');\n\textn_start = strrchr(dir_end ? dir_end : name, '.');\n\tstrncpy(file_name, name, extn_start ? (size_t)(extn_start - name) : len);\n\n\tif (prog) {\n\t\tstrcat(file_name, \"_\");\n\t\tstrcat(file_name, prog);\n\t}\n\tif (namespace) {\n\t\tstrcat(file_name, \"_\");\n\t\tstrcat(file_name, namespace);\n\t}\n\tif (instance) {\n\t\tstrcat(file_name, \"_\");\n\t\tstrcat(file_name, instance);\n\t}\n\tif (extn_start)\n\t\tstrcat(file_name, extn_start);\n\n\treturn file_name;\n}\n\n#ifdef _WITH_PERF_\nvoid\nrun_perf(const char *process, const char *network_namespace, const char *instance_name)\n{\n\tint ret;\n\tpid_t pid;\n\tchar *orig_name = NULL;\n\tchar *new_name;\n\tconst char *perf_name = \"perf.data\";\n\tint in = -1;\n\tint ep = -1;\n\n\tdo {\n\t\torig_name = MALLOC(PATH_MAX);\n\t\tif (!getcwd(orig_name, PATH_MAX)) {\n\t\t\tlog_message(LOG_INFO, \"Unable to get cwd\");\n\t\t\tbreak;\n\t\t}\n\n#ifdef IN_CLOEXEC\n\t\tin = inotify_init1(IN_CLOEXEC | IN_NONBLOCK);\n#else\n\t\tif ((in = inotify_init()) != -1) {\n\t\t\tfcntl(in, F_SETFD, FD_CLOEXEC | fcntl(n, F_GETFD));\n\t\t\tfcntl(in, F_SETFL, O_NONBLOCK | fcntl(n, F_GETFL));\n\t\t}\n#endif\n\t\tif (in == -1) {\n\t\t\tlog_message(LOG_INFO, \"inotify_init failed %d - %m\", errno);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (inotify_add_watch(in, orig_name, IN_CREATE) == -1) {\n\t\t\tlog_message(LOG_INFO, \"inotify_add_watch of %s failed %d - %m\", orig_name, errno);\n\t\t\tbreak;\n\t\t}\n\n\t\tpid = fork();\n\n\t\tif (pid == -1) {\n\t\t\tlog_message(LOG_INFO, \"fork() for perf failed\");\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Child */\n\t\tif (!pid) {\n\t\t\tchar buf[9];\n\n\t\t\tsnprintf(buf, sizeof buf, \"%d\", getppid());\n\t\t\texeclp(\"perf\", \"perf\", \"record\", \"-p\", buf, \"-q\", \"-g\", \"--call-graph\", \"fp\", NULL);\n\t\t\texit(0);\n\t\t}\n\n\t\t/* Parent */\n\t\tchar buf[sizeof(struct inotify_event) + NAME_MAX + 1];\n\t\tstruct inotify_event *ie = (struct inotify_event*)buf;\n\t\tstruct epoll_event ee = { .events = EPOLLIN, .data.fd = in };\n\n\t\tif ((ep = epoll_create(1)) == -1) {\n\t\t\tlog_message(LOG_INFO, \"perf epoll_create failed errno %d - %m\", errno);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (epoll_ctl(ep, EPOLL_CTL_ADD, in, &ee) == -1) {\n\t\t\tlog_message(LOG_INFO, \"perf epoll_ctl failed errno %d - %m\", errno);\n\t\t\tbreak;\n\t\t}\n\n\t\tdo {\n\t\t\tret = epoll_wait(ep, &ee, 1, 1000);\n\t\t\tif (ret == 0) {\n\t\t\t\tlog_message(LOG_INFO, \"Timed out waiting for creation of %s\", perf_name);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (ret == -1) {\n\t\t\t\tif (errno == EINTR)\n\t\t\t\t\tcontinue;\n\t\t\t\tlog_message(LOG_INFO, \"perf epoll returned errno %d - %m\", errno);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tret = read(in, buf, sizeof(buf));\n\t\t\tif (ret == -1) {\n\t\t\t\tif (errno == EINTR)\n\t\t\t\t\tcontinue;\n\t\t\t\tlog_message(LOG_INFO, \"perf inotify read returned errno %d %m\", errno);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (ret < (int)sizeof(*ie)) {\n\t\t\t\tlog_message(LOG_INFO, \"read returned %d\", ret);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!(ie->mask & IN_CREATE)) {\n\t\t\t\tlog_message(LOG_INFO, \"mask is 0x%x\", ie->mask);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!ie->len) {\n\t\t\t\tlog_message(LOG_INFO, \"perf inotify read returned no len\");\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (strcmp(ie->name, perf_name))\n\t\t\t\tcontinue;\n\n\t\t\t/* Rename the /perf.data file */\n\t\t\tstrcat(orig_name, perf_name);\n\t\t\tnew_name = make_file_name(orig_name, process,\n#if HAVE_DECL_CLONE_NEWNET\n\t\t\t\t\t\t\tnetwork_namespace,\n#else\n\t\t\t\t\t\t\tNULL,\n#endif\n\t\t\t\t\t\t\tinstance_name);\n\n\t\t\tif (rename(orig_name, new_name))\n\t\t\t\tlog_message(LOG_INFO, \"Rename %s to %s failed - %m (%d)\", orig_name, new_name, errno);\n\n\t\t\tFREE(new_name);\n\t\t} while (false);\n\t} while (false);\n\n\tif (ep != -1)\n\t\tclose(ep);\n\tif (in != -1)\n\t\tclose(in);\n\tif (orig_name)\n\t\tFREE(orig_name);\n}\n#endif\n\n/* Compute a checksum */\nuint16_t\nin_csum(const uint16_t *addr, size_t len, uint32_t csum, uint32_t *acc)\n{\n\tregister size_t nleft = len;\n\tconst uint16_t *w = addr;\n\tregister uint16_t answer;\n\tregister uint32_t sum = csum;\n\n\t/*\n\t *  Our algorithm is simple, using a 32 bit accumulator (sum),\n\t *  we add sequential 16 bit words to it, and at the end, fold\n\t *  back all the carry bits from the top 16 bits into the lower\n\t *  16 bits.\n\t */\n\twhile (nleft > 1) {\n\t\tsum += *w++;\n\t\tnleft -= 2;\n\t}\n\n\t/* mop up an odd byte, if necessary */\n\tif (nleft == 1)\n\t\tsum += htons(*(u_char *) w << 8);\n\n\tif (acc)\n\t\t*acc = sum;\n\n\t/*\n\t * add back carry outs from top 16 bits to low 16 bits\n\t */\n\tsum = (sum >> 16) + (sum & 0xffff);\t/* add hi 16 to low 16 */\n\tsum += (sum >> 16);\t\t\t/* add carry */\n\tanswer = (~sum & 0xffff);\t\t/* truncate to 16 bits */\n\treturn (answer);\n}\n\n/* IP network to ascii representation */\nchar *\ninet_ntop2(uint32_t ip)\n{\n\tstatic char buf[16];\n\tunsigned char *bytep;\n\n\tbytep = (unsigned char *) &(ip);\n\tsprintf(buf, \"%d.%d.%d.%d\", bytep[0], bytep[1], bytep[2], bytep[3]);\n\treturn buf;\n}\n\n#ifdef _INCLUDE_UNUSED_CODE_\n/*\n * IP network to ascii representation. To use\n * for multiple IP address convertion into the same call.\n */\nchar *\ninet_ntoa2(uint32_t ip, char *buf)\n{\n\tunsigned char *bytep;\n\n\tbytep = (unsigned char *) &(ip);\n\tsprintf(buf, \"%d.%d.%d.%d\", bytep[0], bytep[1], bytep[2], bytep[3]);\n\treturn buf;\n}\n#endif\n\n/* IP string to network range representation. */\nbool\ninet_stor(const char *addr, uint32_t *range_end)\n{\n\tconst char *cp;\n\tchar *endptr;\n\tunsigned long range;\n\tint family = strchr(addr, ':') ? AF_INET6 : AF_INET;\n\tchar *warn = \"\";\n\n#ifndef _STRICT_CONFIG_\n\tif (!__test_bit(CONFIG_TEST_BIT, &debug))\n\t\twarn = \"WARNING - \";\n#endif\n\n\t/* Return UINT32_MAX to indicate no range */\n\tif (!(cp = strchr(addr, '-'))) {\n\t\t*range_end = UINT32_MAX;\n\t\treturn true;\n\t}\n\n\terrno = 0;\n\trange = strtoul(cp + 1, &endptr, family == AF_INET6 ? 16 : 10);\n\t*range_end = range;\n\n\tif (*endptr)\n\t\treport_config_error(CONFIG_INVALID_NUMBER, \"%sVirtual server group range '%s' has extra characters at end '%s'\", warn, addr, endptr);\n\telse if (errno == ERANGE ||\n\t\t (family == AF_INET6 && range > 0xffff) ||\n\t\t (family == AF_INET && range > 255)) {\n\t\treport_config_error(CONFIG_INVALID_NUMBER, \"Virtual server group range '%s' end '%s' too large\", addr, cp + 1);\n\n\t\t/* Indicate error */\n\t\treturn false;\n\t}\n\telse\n\t\treturn true;\n\n#ifdef _STRICT_CONFIG_\n        return false;\n#else\n        return !__test_bit(CONFIG_TEST_BIT, &debug);\n#endif\n}\n\n/* Domain to sockaddr_storage */\nint\ndomain_stosockaddr(const char *domain, const char *port, struct sockaddr_storage *addr)\n{\n\tstruct addrinfo *res = NULL;\n\tunsigned port_num;\n\n\tif (port) {\n\t\tif (!read_unsigned(port, &port_num, 1, 65535, true)) {\n\t\t\taddr->ss_family = AF_UNSPEC;\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (getaddrinfo(domain, NULL, NULL, &res) != 0 || !res) {\n\t\taddr->ss_family = AF_UNSPEC;\n\t\treturn -1;\n\t}\n\n\taddr->ss_family = (sa_family_t)res->ai_family;\n\n\tif (addr->ss_family == AF_INET6) {\n\t\tstruct sockaddr_in6 *addr6 = (struct sockaddr_in6 *)addr;\n\t\t*addr6 = *(struct sockaddr_in6 *)res->ai_addr;\n\t\tif (port)\n\t\t\taddr6->sin6_port = htons(port_num);\n\t} else {\n\t\tstruct sockaddr_in *addr4 = (struct sockaddr_in *)addr;\n\t\t*addr4 = *(struct sockaddr_in *)res->ai_addr;\n\t\tif (port)\n\t\t\taddr4->sin_port = htons(port_num);\n\t}\n\n\tfreeaddrinfo(res);\n\n\treturn 0;\n}\n\n/* IP string to sockaddr_storage */\nint\ninet_stosockaddr(char *ip, const char *port, struct sockaddr_storage *addr)\n{\n\tvoid *addr_ip;\n\tchar *cp;\n\tchar sav_cp;\n\tunsigned port_num;\n\tint res;\n\n\taddr->ss_family = (strchr(ip, ':')) ? AF_INET6 : AF_INET;\n\n\tif (port) {\n\t\tif (!read_unsigned(port, &port_num, 1, 65535, true)) {\n\t\t\taddr->ss_family = AF_UNSPEC;\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (addr->ss_family == AF_INET6) {\n\t\tstruct sockaddr_in6 *addr6 = (struct sockaddr_in6 *) addr;\n\t\tif (port)\n\t\t\taddr6->sin6_port = htons(port_num);\n\t\taddr_ip = &addr6->sin6_addr;\n\t} else {\n\t\tstruct sockaddr_in *addr4 = (struct sockaddr_in *) addr;\n\t\tif (port)\n\t\t\taddr4->sin_port = htons(port_num);\n\t\taddr_ip = &addr4->sin_addr;\n\t}\n\n\t/* remove range and mask stuff */\n\tif ((cp = strchr(ip, '-')) ||\n\t    (cp = strchr(ip, '/'))) {\n\t\tsav_cp = *cp;\n\t\t*cp = 0;\n\t}\n\n\tres = inet_pton(addr->ss_family, ip, addr_ip);\n\n\t/* restore range and mask stuff */\n\tif (cp)\n\t\t*cp = sav_cp;\n\n\tif (!res) {\n\t\taddr->ss_family = AF_UNSPEC;\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n/* IPv4 to sockaddr_storage */\nvoid\ninet_ip4tosockaddr(struct in_addr *sin_addr, struct sockaddr_storage *addr)\n{\n\tstruct sockaddr_in *addr4 = (struct sockaddr_in *) addr;\n\taddr4->sin_family = AF_INET;\n\taddr4->sin_addr = *sin_addr;\n}\n\n/* IPv6 to sockaddr_storage */\nvoid\ninet_ip6tosockaddr(struct in6_addr *sin_addr, struct sockaddr_storage *addr)\n{\n\tstruct sockaddr_in6 *addr6 = (struct sockaddr_in6 *) addr;\n\taddr6->sin6_family = AF_INET6;\n\taddr6->sin6_addr = *sin_addr;\n}\n\n/* IP network to string representation */\nstatic char *\ninet_sockaddrtos2(struct sockaddr_storage *addr, char *addr_str)\n{\n\tvoid *addr_ip;\n\n\tif (addr->ss_family == AF_INET6) {\n\t\tstruct sockaddr_in6 *addr6 = (struct sockaddr_in6 *) addr;\n\t\taddr_ip = &addr6->sin6_addr;\n\t} else {\n\t\tstruct sockaddr_in *addr4 = (struct sockaddr_in *) addr;\n\t\taddr_ip = &addr4->sin_addr;\n\t}\n\n\tif (!inet_ntop(addr->ss_family, addr_ip, addr_str, INET6_ADDRSTRLEN))\n\t\treturn NULL;\n\n\treturn addr_str;\n}\n\nchar *\ninet_sockaddrtos(struct sockaddr_storage *addr)\n{\n\tstatic char addr_str[INET6_ADDRSTRLEN];\n\tinet_sockaddrtos2(addr, addr_str);\n\treturn addr_str;\n}\n\nuint16_t\ninet_sockaddrport(struct sockaddr_storage *addr)\n{\n\tuint16_t port;\n\n\tif (addr->ss_family == AF_INET6) {\n\t\tstruct sockaddr_in6 *addr6 = (struct sockaddr_in6 *) addr;\n\t\tport = addr6->sin6_port;\n\t} else {\n\t\t/* Note: this might be AF_UNSPEC if it is the sequence number of\n\t\t * a virtual server in a virtual server group */\n\t\tstruct sockaddr_in *addr4 = (struct sockaddr_in *) addr;\n\t\tport = addr4->sin_port;\n\t}\n\n\treturn port;\n}\n\nchar *\ninet_sockaddrtopair(struct sockaddr_storage *addr)\n{\n\tchar addr_str[INET6_ADDRSTRLEN];\n\tstatic char ret[sizeof(addr_str) + 8];\t/* '[' + addr_str + ']' + ':' + 'nnnnn' */\n\n\tinet_sockaddrtos2(addr, addr_str);\n\tsnprintf(ret, sizeof(ret), \"[%s]:%d\"\n\t\t, addr_str\n\t\t, ntohs(inet_sockaddrport(addr)));\n\treturn ret;\n}\n\nchar *\ninet_sockaddrtotrio(struct sockaddr_storage *addr, uint16_t proto)\n{\n\tchar addr_str[INET6_ADDRSTRLEN];\n\tstatic char ret[sizeof(addr_str) + 13];\t/* '[' + addr_str + ']' + ':' + 'sctp' + ':' + 'nnnnn' */\n\tchar *proto_str = proto == IPPROTO_TCP ? \"tcp\" : proto == IPPROTO_UDP ? \"udp\" : proto == IPPROTO_SCTP ? \"sctp\" : proto == 0 ? \"none\" : \"?\";\n\n\tinet_sockaddrtos2(addr, addr_str);\n\tsnprintf(ret, sizeof(ret), \"[%s]:%s:%d\" ,addr_str, proto_str,\n\t\t ntohs(inet_sockaddrport(addr)));\n\treturn ret;\n}\n\nuint32_t\ninet_sockaddrip4(struct sockaddr_storage *addr)\n{\n\tif (addr->ss_family != AF_INET)\n\t\treturn 0xffffffff;\n\n\treturn ((struct sockaddr_in *) addr)->sin_addr.s_addr;\n}\n\nint\ninet_sockaddrip6(struct sockaddr_storage *addr, struct in6_addr *ip6)\n{\n\tif (addr->ss_family != AF_INET6)\n\t\treturn -1;\n\n\t*ip6 = ((struct sockaddr_in6 *) addr)->sin6_addr;\n\treturn 0;\n}\n\n/* IPv6 address compare */\nint\ninet_inaddrcmp(const int family, const void *a, const void *b)\n{\n\tint64_t addr_diff;\n\n\tif (family == AF_INET) {\n\t\taddr_diff = (int64_t)ntohl(*((const uint32_t *) a)) - (int64_t)ntohl(*((const uint32_t *) b));\n\t\tif (addr_diff > 0)\n\t\t\treturn 1;\n\t\tif (addr_diff < 0)\n\t\t\treturn -1;\n\t\treturn 0;\n\t}\n\n\tif (family == AF_INET6) {\n\t\tint i;\n\n\t\tfor (i = 0; i < 4; i++ ) {\n\t\t\taddr_diff = (int64_t)ntohl(((const uint32_t *) (a))[i]) - (int64_t)ntohl(((const uint32_t *) (b))[i]);\n\t\t\tif (addr_diff > 0)\n\t\t\t\treturn 1;\n\t\t\tif (addr_diff < 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn 0;\n\t}\n\n\treturn -2;\n}\n\nint\ninet_sockaddrcmp(const struct sockaddr_storage *a, const struct sockaddr_storage *b)\n{\n\tif (a->ss_family != b->ss_family)\n\t\treturn -2;\n\n\tif (a->ss_family == AF_INET)\n\t\treturn inet_inaddrcmp(a->ss_family,\n\t\t\t\t      &((struct sockaddr_in *) a)->sin_addr,\n\t\t\t\t      &((struct sockaddr_in *) b)->sin_addr);\n\tif (a->ss_family == AF_INET6)\n\t\treturn inet_inaddrcmp(a->ss_family,\n\t\t\t\t      &((struct sockaddr_in6 *) a)->sin6_addr,\n\t\t\t\t      &((struct sockaddr_in6 *) b)->sin6_addr);\n\treturn 0;\n}\n\n\n#ifdef _INCLUDE_UNUSED_CODE_\n/*\n * IP string to network representation\n * Highly inspired from Paul Vixie code.\n */\nint\ninet_ston(const char *addr, uint32_t * dst)\n{\n\tstatic char digits[] = \"0123456789\";\n\tint saw_digit, octets, ch;\n\tu_char tmp[INADDRSZ], *tp;\n\n\tsaw_digit = 0;\n\toctets = 0;\n\t*(tp = tmp) = 0;\n\n\twhile ((ch = *addr++) != '\\0' && ch != '/' && ch != '-') {\n\t\tconst char *pch;\n\t\tif ((pch = strchr(digits, ch)) != NULL) {\n\t\t\tu_int new = *tp * 10 + (pch - digits);\n\t\t\tif (new > 255)\n\t\t\t\treturn 0;\n\t\t\t*tp = new;\n\t\t\tif (!saw_digit) {\n\t\t\t\tif (++octets > 4)\n\t\t\t\t\treturn 0;\n\t\t\t\tsaw_digit = 1;\n\t\t\t}\n\t\t} else if (ch == '.' && saw_digit) {\n\t\t\tif (octets == 4)\n\t\t\t\treturn 0;\n\t\t\t*++tp = 0;\n\t\t\tsaw_digit = 0;\n\t\t} else\n\t\t\treturn 0;\n\t}\n\n\tif (octets < 4)\n\t\treturn 0;\n\n\tmemcpy(dst, tmp, INADDRSZ);\n\treturn 1;\n}\n\n/*\n * Return broadcast address from network and netmask.\n */\nuint32_t\ninet_broadcast(uint32_t network, uint32_t netmask)\n{\n\treturn 0xffffffff - netmask + network;\n}\n\n/*\n * Convert CIDR netmask notation to long notation.\n */\nuint32_t\ninet_cidrtomask(uint8_t cidr)\n{\n\tuint32_t mask = 0;\n\tint b;\n\n\tfor (b = 0; b < cidr; b++)\n\t\tmask |= (1 << (31 - b));\n\treturn ntohl(mask);\n}\n#endif\n\n/* Getting localhost official canonical name */\nchar *\nget_local_name(void)\n{\n\tstruct utsname name;\n\tstruct addrinfo hints, *res = NULL;\n\tchar *canonname = NULL;\n\tsize_t len = 0;\n\n\tmemset(&hints, 0, sizeof(struct addrinfo));\n\thints.ai_flags = AI_CANONNAME;\n\n\tif (uname(&name) < 0)\n\t\treturn NULL;\n\n\tif (getaddrinfo(name.nodename, NULL, &hints, &res) != 0)\n\t\treturn NULL;\n\n\tif (res && res->ai_canonname) {\n\t\tlen = strlen(res->ai_canonname);\n\t\tcanonname = MALLOC(len + 1);\n\t\tif (canonname) {\n\t\t\tmemcpy(canonname, res->ai_canonname, len);\n\t\t}\n\t}\n\n\tfreeaddrinfo(res);\n\n\treturn canonname;\n}\n\n/* String compare with NULL string handling */\nbool\nstring_equal(const char *str1, const char *str2)\n{\n\tif (!str1 && !str2)\n\t\treturn true;\n\tif (!str1 != !str2)\n\t\treturn false;\n\n\treturn !strcmp(str1, str2);\n}\n\n/* We need to use O_NOFOLLOW if opening a file for write, so that a non privileged user can't\n * create a symbolic link from the path to a system file and cause a system file to be overwritten. */\nFILE *fopen_safe(const char *path, const char *mode)\n{\n\tint fd;\n\tFILE *file;\n\tint flags = O_NOFOLLOW | O_CREAT;\n\n\tif (mode[0] == 'r')\n\t\treturn fopen(path, mode);\n\n\tif (mode[0] != 'a' && mode[0] != 'w')\n\t\treturn NULL;\n\n\tif (mode[1] &&\n\t    (mode[1] != '+' || mode[2]))\n\t\treturn NULL;\n\n\tif (mode[0] == 'w')\n\t\tflags |= O_TRUNC;\n\telse\n\t\tflags |= O_APPEND;\n\n\tif (mode[1])\n\t\tflags |= O_RDWR;\n\telse\n\t\tflags |= O_WRONLY;\n\n\tfd = open(path, flags, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH);\n\tif (fd == -1)\n\t\treturn NULL;\n\n\tfile = fdopen (fd, \"w\");\n\tif (!file) {\n\t\tclose(fd);\n\t\treturn NULL;\n\t}\n\n\treturn file;\n}\n\nvoid\nset_std_fd(bool force)\n{\n\tint fd;\n\n\tif (force || __test_bit(DONT_FORK_BIT, &debug)) {\n\t\tfd = open(\"/dev/null\", O_RDWR);\n\t\tif (fd != -1) {\n\t\t\tdup2(fd, STDIN_FILENO);\n\t\t\tdup2(fd, STDOUT_FILENO);\n\t\t\tdup2(fd, STDERR_FILENO);\n\t\t\tif (fd > STDERR_FILENO)\n\t\t\t\tclose(fd);\n\t\t}\n\t}\n\n\tsignal_fd_close(STDERR_FILENO+1);\n}\n\nvoid\nclose_std_fd(void)\n{\n\tclose(STDIN_FILENO);\n\tclose(STDOUT_FILENO);\n\tclose(STDERR_FILENO);\n}\n\n#if !defined _HAVE_LIBIPTC_ || defined _LIBIPTC_DYNAMIC_\nint\nfork_exec(char **argv)\n{\n\tpid_t pid;\n\tint status;\n\tstruct sigaction act, old_act;\n\tint res = 0;\n\n\tact.sa_handler = SIG_DFL;\n\tsigemptyset(&act.sa_mask);\n\tact.sa_flags = 0;\n\n\tsigaction(SIGCHLD, &act, &old_act);\n\n\tif (log_file_name)\n\t\tflush_log_file();\n\n\tpid = local_fork();\n\tif (pid < 0)\n\t\tres = -1;\n\telse if (pid == 0) {\n\t\t/* Child */\n\t\tset_std_fd(false);\n\n\t\tsignal_handler_script();\n\n\t\texecvp(*argv, argv);\n\t\texit(EXIT_FAILURE);\n\t} else {\n\t\t/* Parent */\n\t\twhile (waitpid(pid, &status, 0) != pid);\n\n\t\tif (!WIFEXITED(status) || WEXITSTATUS(status) != EXIT_SUCCESS)\n\t\t\tres = -1;\n\t}\n\n\tsigaction(SIGCHLD, &old_act, NULL);\n\n\treturn res;\n}\n#endif\n\n#if defined _WITH_VRRP_ || defined _WITH_BFD_\nint\nopen_pipe(int pipe_arr[2])\n{\n\t/* Open pipe */\n#ifdef HAVE_PIPE2\n\tif (pipe2(pipe_arr, O_CLOEXEC | O_NONBLOCK) == -1)\n#else\n\tif (pipe(pipe_arr) == -1)\n#endif\n\t\treturn -1;\n\n#ifndef HAVE_PIPE2\n\tfcntl(pipe_arr[0], F_SETFL, O_NONBLOCK | fcntl(pipe_arr[0], F_GETFL));\n\tfcntl(pipe_arr[1], F_SETFL, O_NONBLOCK | fcntl(pipe_arr[1], F_GETFL));\n\n\tfcntl(pipe_arr[0], F_SETFD, FD_CLOEXEC | fcntl(pipe_arr[0], F_GETFD));\n\tfcntl(pipe_arr[1], F_SETFD, FD_CLOEXEC | fcntl(pipe_arr[1], F_GETFD));\n#endif\n\n\treturn 0;\n}\n#endif\n", "/*\n * Soft:        Keepalived is a failover program for the LVS project\n *              <www.linuxvirtualserver.org>. It monitor & manipulate\n *              a loadbalanced server pool using multi-layer checks.\n *\n * Part:        utils.h include file.\n *\n * Author:      Alexandre Cassen, <acassen@linux-vs.org>\n *\n *              This program is distributed in the hope that it will be useful,\n *              but WITHOUT ANY WARRANTY; without even the implied warranty of\n *              MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n *              See the GNU General Public License for more details.\n *\n *              This program is free software; you can redistribute it and/or\n *              modify it under the terms of the GNU General Public License\n *              as published by the Free Software Foundation; either version\n *              2 of the License, or (at your option) any later version.\n *\n * Copyright (C) 2001-2017 Alexandre Cassen, <acassen@gmail.com>\n */\n\n#ifndef _UTILS_H\n#define _UTILS_H\n\n#include \"config.h\"\n\n/* system includes */\n#include <sys/types.h>\n#include <stdint.h>\n#include <stdbool.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <stdio.h>\n\n#include \"vector.h\"\n#ifdef _DEBUG_\n#include \"logger.h\"\n#endif\n\n/* Global debugging logging facilities */\n#ifdef _DEBUG_\n#define DBG(fmt, msg...) log_message(LOG_DEBUG, fmt, ## msg)\n#else\n#define DBG(fmt, msg...)\n#endif\n\n#define STR(x)  #x\n\n#ifdef _WITH_PERF_\ntypedef enum {\n\tPERF_NONE,\n\tPERF_RUN,\n\tPERF_ALL,\n\tPERF_END,\n} perf_t;\n#endif\n\n/* inline stuff */\nstatic inline int __ip6_addr_equal(const struct in6_addr *a1,\n\t\t\t\t   const struct in6_addr *a2)\n{\n\treturn (((a1->s6_addr32[0] ^ a2->s6_addr32[0]) |\n\t\t (a1->s6_addr32[1] ^ a2->s6_addr32[1]) |\n\t\t (a1->s6_addr32[2] ^ a2->s6_addr32[2]) |\n\t\t (a1->s6_addr32[3] ^ a2->s6_addr32[3])) == 0);\n}\n\nstatic inline bool sockstorage_equal(const struct sockaddr_storage *s1,\n\t\t\t\t    const struct sockaddr_storage *s2)\n{\n\tif (s1->ss_family != s2->ss_family)\n\t\treturn false;\n\n\tif (s1->ss_family == AF_INET6) {\n\t\tstruct sockaddr_in6 *a1 = (struct sockaddr_in6 *) s1;\n\t\tstruct sockaddr_in6 *a2 = (struct sockaddr_in6 *) s2;\n\n//\t\tif (IN6_ARE_ADDR_EQUAL(a1, a2) && (a1->sin6_port == a2->sin6_port))\n\t\tif (__ip6_addr_equal(&a1->sin6_addr, &a2->sin6_addr) &&\n\t\t    (a1->sin6_port == a2->sin6_port))\n\t\t\treturn true;\n\t} else if (s1->ss_family == AF_INET) {\n\t\tstruct sockaddr_in *a1 = (struct sockaddr_in *) s1;\n\t\tstruct sockaddr_in *a2 = (struct sockaddr_in *) s2;\n\n\t\tif ((a1->sin_addr.s_addr == a2->sin_addr.s_addr) &&\n\t\t    (a1->sin_port == a2->sin_port))\n\t\t\treturn true;\n\t} else if (s1->ss_family == AF_UNSPEC)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic inline bool inaddr_equal(sa_family_t family, void *addr1, void *addr2)\n{\n\tif (family == AF_INET6) {\n\t\tstruct in6_addr *a1 = (struct in6_addr *) addr1;\n\t\tstruct in6_addr *a2 = (struct in6_addr *) addr2;\n\n\t\tif (__ip6_addr_equal(a1, a2))\n\t\t\treturn true;\n\t} else if (family == AF_INET) {\n\t\tstruct in_addr *a1 = (struct in_addr *) addr1;\n\t\tstruct in_addr *a2 = (struct in_addr *) addr2;\n\n\t\tif (a1->s_addr == a2->s_addr)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic inline uint16_t csum_incremental_update32(const uint16_t old_csum, const uint32_t old_val, const uint32_t new_val)\n{\n\t/* This technique for incremental IP checksum update is described in RFC1624,\n\t * along with accompanying errata */\n\n\tif (old_val == new_val)\n\t\treturn old_csum;\n\n\tuint32_t acc = (~old_csum & 0xffff) + (~(old_val >> 16 ) & 0xffff) + (~old_val & 0xffff);\n\n\tacc += (new_val >> 16) + (new_val & 0xffff);\n\n\t/* finally compute vrrp checksum */\n\tacc = (acc & 0xffff) + (acc >> 16);\n\tacc += acc >> 16;\n\n\treturn ~acc & 0xffff;\n}\n\nstatic inline uint16_t csum_incremental_update16(const uint16_t old_csum, const uint16_t old_val, const uint16_t new_val)\n{\n\t/* This technique for incremental IP checksum update is described in RFC1624,\n\t * along with accompanying errata */\n\n\tif (old_val == new_val)\n\t\treturn old_csum;\n\n\tuint32_t acc = (~old_csum & 0xffff) + (~old_val & 0xffff);\n\n\tacc += new_val;\n\n\t/* finally compute vrrp checksum */\n\tacc = (acc & 0xffff) + (acc >> 16);\n\tacc += acc >> 16;\n\n\treturn ~acc & 0xffff;\n}\n\n/* global vars exported */\nextern unsigned long debug;\n#ifdef _WITH_PERF_\nextern perf_t perf_run;\n#endif\n\n/* Prototypes defs */\nextern void dump_buffer(char *, size_t, FILE *, int);\n#ifdef _WITH_STACKTRACE_\nextern void write_stacktrace(const char *, const char *);\n#endif\nextern char *make_file_name(const char *, const char *, const char *, const char *);\n#ifdef _WITH_PERF_\nextern void run_perf(const char *, const char *, const char *);\n#endif\nextern uint16_t in_csum(const uint16_t *, size_t, uint32_t, uint32_t *);\nextern char *inet_ntop2(uint32_t);\nextern bool inet_stor(const char *, uint32_t *);\nextern int domain_stosockaddr(const char *, const char *, struct sockaddr_storage *);\nextern int inet_stosockaddr(char *, const char *, struct sockaddr_storage *);\nextern void inet_ip4tosockaddr(struct in_addr *, struct sockaddr_storage *);\nextern void inet_ip6tosockaddr(struct in6_addr *, struct sockaddr_storage *);\nextern char *inet_sockaddrtos(struct sockaddr_storage *);\nextern char *inet_sockaddrtopair(struct sockaddr_storage *);\nextern char *inet_sockaddrtotrio(struct sockaddr_storage *, uint16_t);\nextern uint16_t inet_sockaddrport(struct sockaddr_storage *);\nextern uint32_t inet_sockaddrip4(struct sockaddr_storage *);\nextern int inet_sockaddrip6(struct sockaddr_storage *, struct in6_addr *);\nextern int inet_inaddrcmp(int, const void *, const void *);\nextern int inet_sockaddrcmp(const struct sockaddr_storage *, const struct sockaddr_storage *);\nextern char *get_local_name(void);\nextern bool string_equal(const char *, const char *);\nextern FILE *fopen_safe(const char *, const char *);\nextern void set_std_fd(bool);\nextern void close_std_fd(void);\n#if !defined _HAVE_LIBIPTC_ || defined _LIBIPTC_DYNAMIC_\nextern int fork_exec(char **argv);\n#endif\n#if defined _WITH_VRRP_ || defined _WITH_BFD_\nextern int open_pipe(int [2]);\n#endif\n\n#endif\n"], "filenames": ["keepalived/core/main.c", "keepalived/core/pidfile.c", "keepalived/core/smtp.c", "keepalived/vrrp/vrrp_dbus.c", "keepalived/vrrp/vrrp_json.c", "keepalived/vrrp/vrrp_parser.c", "keepalived/vrrp/vrrp_print.c", "keepalived/vrrp/vrrp_scheduler.c", "lib/logger.c", "lib/memory.c", "lib/notify.c", "lib/parser.c", "lib/utils.c", "lib/utils.h"], "buggy_code_start_loc": [1402, 63, 573, 597, 39, 1208, 34, 1137, 81, 624, 239, 458, 126, 184], "buggy_code_end_loc": [1403, 64, 574, 598, 59, 1209, 80, 1138, 82, 625, 240, 463, 790, 184], "fixing_code_start_loc": [1402, 63, 573, 597, 40, 1208, 35, 1137, 81, 624, 239, 458, 126, 185], "fixing_code_end_loc": [1403, 64, 574, 598, 60, 1209, 77, 1138, 82, 625, 240, 463, 832, 186], "type": "CWE-59", "message": "keepalived 2.0.8 didn't check for pathnames with symlinks when writing data to a temporary file upon a call to PrintData or PrintStats. This allowed local users to overwrite arbitrary files if fs.protected_symlinks is set to 0, as demonstrated by a symlink from /tmp/keepalived.data or /tmp/keepalived.stats to /etc/passwd.", "other": {"cve": {"id": "CVE-2018-19044", "sourceIdentifier": "cve@mitre.org", "published": "2018-11-08T20:29:00.323", "lastModified": "2019-08-06T17:15:32.430", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "keepalived 2.0.8 didn't check for pathnames with symlinks when writing data to a temporary file upon a call to PrintData or PrintStats. This allowed local users to overwrite arbitrary files if fs.protected_symlinks is set to 0, as demonstrated by a symlink from /tmp/keepalived.data or /tmp/keepalived.stats to /etc/passwd."}, {"lang": "es", "value": "keepalived 2.0.8 no buscaba nombres de ruta con enlaces simb\u00f3licos al escribir datos en un archivo temporal al llamar a PrintData o PrintStats. Esto permit\u00eda a los usuarios locales sobrescribir archivos arbitrarios si fs.protected_symlinks se establece en 0, tal y como lo demuestra un enlace simb\u00f3lico desde /tmp/keepalived.data o /tmp/keepalived.stats a /etc/passwd."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:H/A:N", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 4.7, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.0, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:M/Au:N/C:N/I:P/A:P", "accessVector": "LOCAL", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 3.3}, "baseSeverity": "LOW", "exploitabilityScore": 3.4, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-59"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:keepalived:keepalived:2.0.8:*:*:*:*:*:*:*", "matchCriteriaId": "41629AA7-851D-438F-8836-0574E4912DF1"}]}]}], "references": [{"url": "https://access.redhat.com/errata/RHSA-2019:2285", "source": "cve@mitre.org"}, {"url": "https://bugzilla.suse.com/show_bug.cgi?id=1015141", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/acassen/keepalived/commit/04f2d32871bb3b11d7dc024039952f2fe2750306", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/acassen/keepalived/issues/1048", "source": "cve@mitre.org", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/201903-01", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/acassen/keepalived/commit/04f2d32871bb3b11d7dc024039952f2fe2750306"}}