{"buggy_code": ["/*\n *  Copyright (C) 2015 Cisco Systems, Inc. and/or its affiliates. All rights reserved.\n *  Copyright (C) 2013 Sourcefire, Inc.\n *\n *  Authors: Steven Morgan <smorgan@sourcefire.com>\n *\n *  This program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License version 2 as\n *  published by the Free Software Foundation.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this program; if not, write to the Free Software\n *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,\n *  MA 02110-1301, USA.\n */\n\n#if HAVE_CONFIG_H\n#include \"clamav-config.h\"\n#endif\n\n#include <errno.h>\n#include \"xar.h\"\n#include \"fmap.h\"\n#if HAVE_LIBXML2\n#ifdef _WIN32\n#ifndef LIBXML_WRITER_ENABLED\n#define LIBXML_WRITER_ENABLED 1\n#endif\n#endif\n#include <libxml/xmlreader.h>\n#include \"clamav.h\"\n#include \"str.h\"\n#include \"scanners.h\"\n#include \"inflate64.h\"\n#include \"lzma_iface.h\"\n\n/*\n   xar_cleanup_temp_file - cleanup after cli_gentempfd\n   parameters:\n     ctx - cli_ctx context pointer\n     fd  - fd to close\n     tmpname - name of file to unlink, address of storage to free\n   returns - CL_SUCCESS or CL_EUNLINK\n */\nstatic int xar_cleanup_temp_file(cli_ctx *ctx, int fd, char * tmpname)\n{\n    int rc = CL_SUCCESS;\n    if (fd > -1)\n        close(fd);\n    if (tmpname != NULL) {\n        if (!ctx->engine->keeptmp) {\n            if (cli_unlink(tmpname)) {\n                cli_dbgmsg(\"cli_scanxar: error unlinking tmpfile %s\\n\", tmpname); \n                rc = CL_EUNLINK;\n            }\n        }\n        free(tmpname);\n    }\n    return rc;\n}\n\n/*\n   xar_get_numeric_from_xml_element - extract xml element value as numeric\n   parameters:\n     reader - xmlTextReaderPtr\n     value - pointer to long to contain the returned value\n   returns - CL_SUCCESS or CL_EFORMAT\n */\nstatic int xar_get_numeric_from_xml_element(xmlTextReaderPtr reader, long * value)\n{\n    const xmlChar * numstr;\n    if (xmlTextReaderRead(reader) == 1 && xmlTextReaderNodeType(reader) == XML_READER_TYPE_TEXT) {\n        numstr = xmlTextReaderConstValue(reader);\n        if (numstr) {\n            *value = atol((const char *)numstr);\n            if (*value < 0) {\n                cli_dbgmsg(\"cli_scanxar: XML element value %li\\n\", *value);\n                return CL_EFORMAT;\n            }\n            return CL_SUCCESS;\n        }\n    }\n    cli_dbgmsg(\"cli_scanxar: No text for XML element\\n\");\n    return CL_EFORMAT;\n}\n\n/*\n  xar_get_checksum_values - extract checksum and hash algorithm from xml element\n  parameters:\n    reader - xmlTextReaderPtr\n    cksum - pointer to char* for returning checksum value.\n    hash - pointer to int for returning checksum algorithm.\n  returns - void\n */\nstatic void xar_get_checksum_values(xmlTextReaderPtr reader, unsigned char ** cksum, int * hash)\n{\n    xmlChar * style = xmlTextReaderGetAttribute(reader, (const xmlChar *)\"style\");\n    const xmlChar * xmlval;\n\n    *hash = XAR_CKSUM_NONE;\n    if (style == NULL) {\n        cli_dbgmsg(\"cli_scaxar: xmlTextReaderGetAttribute no style attribute \"\n                   \"for checksum element\\n\");\n    } else {\n        cli_dbgmsg(\"cli_scanxar: checksum algorithm is %s.\\n\", style);        \n        if (0 == xmlStrcasecmp(style, (const xmlChar *)\"sha1\")) {\n            *hash = XAR_CKSUM_SHA1;\n        } else if (0 == xmlStrcasecmp(style, (const xmlChar *)\"md5\")) {\n            *hash = XAR_CKSUM_MD5;\n        } else {\n            cli_dbgmsg(\"cli_scanxar: checksum algorithm %s is unsupported.\\n\", style);\n            *hash = XAR_CKSUM_OTHER;\n        }\n    }\n    if (style != NULL)\n        xmlFree(style);\n\n    if (xmlTextReaderRead(reader) == 1 && xmlTextReaderNodeType(reader) == XML_READER_TYPE_TEXT) {\n        xmlval = xmlTextReaderConstValue(reader);\n        if (xmlval) {\n            *cksum = xmlStrdup(xmlval); \n            cli_dbgmsg(\"cli_scanxar: checksum value is %s.\\n\", *cksum);\n        } else {\n            *cksum = NULL;\n            cli_dbgmsg(\"cli_scanxar: xmlTextReaderConstValue() returns NULL for checksum value.\\n\");           \n        }\n    }\n    else\n        cli_dbgmsg(\"cli_scanxar: No text for XML checksum element.\\n\");\n}\n\n/*\n   xar_get_toc_data_values - return the values of a <data> or <ea> xml element that represent \n                             an extent of data on the heap.\n   parameters:\n     reader - xmlTextReaderPtr\n     length - pointer to long for returning value of the <length> element.\n     offset - pointer to long for returning value of the <offset> element.\n     size - pointer to long for returning value of the <size> element.\n     encoding - pointer to int for returning indication of the <encoding> style attribute.\n     a_cksum - pointer to char* for return archived checksum value.\n     a_hash - pointer to int for returning archived checksum algorithm.\n     e_cksum - pointer to char* for return extracted checksum value.\n     e_hash - pointer to int for returning extracted checksum algorithm.\n   returns - CL_FORMAT, CL_SUCCESS, CL_BREAK. CL_BREAK indicates no more <data>/<ea> element.\n */\nstatic int xar_get_toc_data_values(xmlTextReaderPtr reader, long *length, long *offset, long *size, int *encoding,\n                                   unsigned char ** a_cksum, int * a_hash, unsigned char ** e_cksum, int * e_hash)\n{\n    const xmlChar *name;\n    int indata = 0, inea = 0;\n    int rc, gotoffset=0, gotlength=0, gotsize=0;\n\n    *a_cksum = NULL;\n    *a_hash = XAR_CKSUM_NONE;\n    *e_cksum = NULL;\n    *e_hash = XAR_CKSUM_NONE;\n    *encoding = CL_TYPE_ANY;\n\n    rc = xmlTextReaderRead(reader);\n    while (rc == 1) {\n        name = xmlTextReaderConstLocalName(reader);\n        if (indata || inea) {\n            /*  cli_dbgmsg(\"cli_scanxar: xmlTextReaderRead read %s\\n\", name); */\n            if (xmlStrEqual(name, (const xmlChar *)\"offset\") && \n                xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT) {\n                if (CL_SUCCESS == xar_get_numeric_from_xml_element(reader, offset))\n                    gotoffset=1;\n\n            } else if (xmlStrEqual(name, (const xmlChar *)\"length\") &&\n                       xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT) {\n                if (CL_SUCCESS == xar_get_numeric_from_xml_element(reader, length))\n                    gotlength=1;\n\n            } else if (xmlStrEqual(name, (const xmlChar *)\"size\") &&\n                       xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT) {\n                if (CL_SUCCESS == xar_get_numeric_from_xml_element(reader, size))\n                    gotsize=1;\n\n            } else if (xmlStrEqual(name, (const xmlChar *)\"archived-checksum\") &&\n                       xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT) {\n                cli_dbgmsg(\"cli_scanxar: <archived-checksum>:\\n\");\n                xar_get_checksum_values(reader, a_cksum, a_hash);\n                \n            } else if ((xmlStrEqual(name, (const xmlChar *)\"extracted-checksum\") ||\n                        xmlStrEqual(name, (const xmlChar *)\"unarchived-checksum\")) &&\n                       xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT) {\n                cli_dbgmsg(\"cli_scanxar: <extracted-checksum>:\\n\");\n                xar_get_checksum_values(reader, e_cksum, e_hash);\n\n            } else if (xmlStrEqual(name, (const xmlChar *)\"encoding\") &&\n                       xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT) {\n                xmlChar * style = xmlTextReaderGetAttribute(reader, (const xmlChar *)\"style\");\n                if (style == NULL) {\n                    cli_dbgmsg(\"cli_scaxar: xmlTextReaderGetAttribute no style attribute \"\n                               \"for encoding element\\n\");\n                    *encoding = CL_TYPE_ANY;\n                } else if (xmlStrEqual(style, (const xmlChar *)\"application/x-gzip\")) {\n                    cli_dbgmsg(\"cli_scanxar: encoding = application/x-gzip.\\n\");\n                    *encoding = CL_TYPE_GZ; \n                } else if (xmlStrEqual(style, (const xmlChar *)\"application/octet-stream\")) {\n                    cli_dbgmsg(\"cli_scanxar: encoding = application/octet-stream.\\n\");\n                    *encoding = CL_TYPE_ANY; \n                } else if (xmlStrEqual(style, (const xmlChar *)\"application/x-bzip2\")) {\n                    cli_dbgmsg(\"cli_scanxar: encoding = application/x-bzip2.\\n\");\n                    *encoding = CL_TYPE_BZ;\n                } else if (xmlStrEqual(style, (const xmlChar *)\"application/x-lzma\")) {\n                    cli_dbgmsg(\"cli_scanxar: encoding = application/x-lzma.\\n\");\n                    *encoding = CL_TYPE_7Z;\n                 } else if (xmlStrEqual(style, (const xmlChar *)\"application/x-xz\")) {\n                    cli_dbgmsg(\"cli_scanxar: encoding = application/x-xz.\\n\");\n                    *encoding = CL_TYPE_XZ;\n                } else {\n                    cli_dbgmsg(\"cli_scaxar: unknown style value=%s for encoding element\\n\", style);\n                    *encoding = CL_TYPE_ANY;\n                }\n                if (style != NULL)\n                    xmlFree(style);\n\n           } else if (indata && xmlStrEqual(name, (const xmlChar *)\"data\") &&\n                       xmlTextReaderNodeType(reader) == XML_READER_TYPE_END_ELEMENT) {\n                break;\n\n            } else if (inea && xmlStrEqual(name, (const xmlChar *)\"ea\") &&\n                       xmlTextReaderNodeType(reader) == XML_READER_TYPE_END_ELEMENT) {\n                break;\n            }\n            \n        } else {\n            if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT) {\n                if (xmlStrEqual(name, (const xmlChar *)\"data\")) {\n                    cli_dbgmsg(\"cli_scanxar: xmlTextReaderRead read <data>\\n\");\n                    indata = 1;\n                } else if (xmlStrEqual(name, (const xmlChar *)\"ea\")) {\n                    cli_dbgmsg(\"cli_scanxar: xmlTextReaderRead read <ea>\\n\");\n                    inea = 1;\n                }\n            } else if ((xmlTextReaderNodeType(reader) == XML_READER_TYPE_END_ELEMENT) &&\n                       xmlStrEqual(name, (const xmlChar *)\"xar\")) {\n                cli_dbgmsg(\"cli_scanxar: finished parsing xar TOC.\\n\");   \n                break;\n            }\n        }\n        rc = xmlTextReaderRead(reader);\n    }\n    \n    if (gotoffset && gotlength && gotsize) {\n        rc = CL_SUCCESS;\n    }\n    else if (0 == gotoffset + gotlength + gotsize)\n        rc = CL_BREAK;\n    else\n        rc = CL_EFORMAT;\n\n    return rc;\n}\n\n/*\n  xar_process_subdocument - check TOC for xml subdocument. If found, extract and\n                            scan in memory.\n  Parameters:\n     reader - xmlTextReaderPtr\n     ctx - pointer to cli_ctx\n  Returns:\n     CL_SUCCESS - subdoc found and clean scan (or virus found and SCAN_ALL), or no subdocument\n     other - error return code from cli_mem_scandesc()\n*/                        \nstatic int xar_scan_subdocuments(xmlTextReaderPtr reader, cli_ctx *ctx)\n{\n    int rc = CL_SUCCESS, subdoc_len, fd;\n    xmlChar * subdoc;\n    const xmlChar *name;\n    char * tmpname;\n\n    while (xmlTextReaderRead(reader) == 1) {\n        name = xmlTextReaderConstLocalName(reader);\n        if (name == NULL) {\n            cli_dbgmsg(\"cli_scanxar: xmlTextReaderConstLocalName() no name.\\n\");\n            rc = CL_EFORMAT;\n            break;\n        }\n        if (xmlStrEqual(name, (const xmlChar *)\"toc\") && \n            xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT)\n            return CL_SUCCESS;\n        if (xmlStrEqual(name, (const xmlChar *)\"subdoc\") && \n            xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT) {\n            subdoc = xmlTextReaderReadInnerXml(reader);\n            if (subdoc == NULL) {\n                cli_dbgmsg(\"cli_scanxar: no content in subdoc element.\\n\");\n                xmlTextReaderNext(reader);\n                continue;\n            }\n            subdoc_len = xmlStrlen(subdoc);\n            cli_dbgmsg(\"cli_scanxar: in-memory scan of xml subdocument, len %i.\\n\", subdoc_len);\n            rc = cli_mem_scandesc(subdoc, subdoc_len, ctx);\n            if (rc == CL_VIRUS && SCAN_ALL)\n                rc = CL_SUCCESS;\n            \n            /* make a file to leave if --leave-temps in effect */\n            if(ctx->engine->keeptmp) {\n                if ((rc = cli_gentempfd(ctx->engine->tmpdir, &tmpname, &fd)) != CL_SUCCESS) {\n                    cli_dbgmsg(\"cli_scanxar: Can't create temporary file for subdocument.\\n\");\n                } else {\n                    cli_dbgmsg(\"cli_scanxar: Writing subdoc to temp file %s.\\n\", tmpname);\n                    if (cli_writen(fd, subdoc, subdoc_len) < 0) {\n                        cli_dbgmsg(\"cli_scanxar: cli_writen error writing subdoc temporary file.\\n\");\n                        rc = CL_EWRITE;\n                    }\n                    rc = xar_cleanup_temp_file(ctx, fd, tmpname);\n                }\n            }\n\n            xmlFree(subdoc);\n            if (rc != CL_SUCCESS)\n                return rc;\n            xmlTextReaderNext(reader);\n        }        \n    }\n    return rc;\n}\n\nstatic void * xar_hash_init(int hash, void **sc, void **mc)\n{\n    if (!sc && !mc)\n        return NULL;\n    switch (hash) {\n    case XAR_CKSUM_SHA1:\n        *sc = cl_hash_init(\"sha1\");\n        if (!(*sc)) {\n            return NULL;\n        }\n\n        return *sc;\n    case XAR_CKSUM_MD5:\n        *mc = cl_hash_init(\"md5\");\n        if (!(*mc)) {\n            return NULL;\n        }\n\n        return *mc;\n    case XAR_CKSUM_OTHER:\n    case XAR_CKSUM_NONE:\n    default:\n        return NULL;\n    }\n}\n\nstatic void xar_hash_update(void * hash_ctx, void * data, unsigned long size, int hash)\n{\n    if (!hash_ctx || !data || !size)\n        return;\n\n    switch (hash) {\n    case XAR_CKSUM_NONE:\n    case XAR_CKSUM_OTHER:\n        return;\n    }\n\n    cl_update_hash(hash_ctx, data, size);\n}\n\nstatic void xar_hash_final(void * hash_ctx, void * result, int hash)\n{\n    if (!hash_ctx || !result)\n        return;\n\n    switch (hash) {\n    case XAR_CKSUM_OTHER:\n    case XAR_CKSUM_NONE:\n        return;\n    }\n\n    cl_finish_hash(hash_ctx, result);\n}\n\nstatic int xar_hash_check(int hash, const void * result, const void * expected)\n{\n    int len;\n\n    if (!result || !expected)\n        return 1;\n    switch (hash) {\n    case XAR_CKSUM_SHA1:\n        len = SHA1_HASH_SIZE;\n        break;\n    case XAR_CKSUM_MD5:\n        len = CLI_HASH_MD5;\n        break;\n    case XAR_CKSUM_OTHER:\n    case XAR_CKSUM_NONE:\n    default:\n        return 1;\n    }\n    return memcmp(result, expected, len);\n}\n\n#endif\n\n/*\n  cli_scanxar - scan an xar archive.\n  Parameters:\n    ctx - pointer to cli_ctx.\n  returns - CL_SUCCESS or CL_ error code.\n*/\n\nint cli_scanxar(cli_ctx *ctx)\n{\n    int rc = CL_SUCCESS;\n    unsigned int cksum_fails = 0;\n    unsigned int extract_errors = 0;\n#if HAVE_LIBXML2\n    int fd = -1;\n    struct xar_header hdr;\n    fmap_t *map = *ctx->fmap;\n    long length, offset, size, at;\n    int encoding;\n    z_stream strm;\n    char *toc, *tmpname;\n    xmlTextReaderPtr reader = NULL;\n    int a_hash, e_hash;\n    unsigned char *a_cksum = NULL, *e_cksum = NULL;\n    void *a_hash_ctx = NULL, *e_hash_ctx = NULL;\n    char result[SHA1_HASH_SIZE];\n\n    memset(&strm, 0x00, sizeof(z_stream));\n\n    /* retrieve xar header */\n    if (fmap_readn(*ctx->fmap, &hdr, 0, sizeof(hdr)) != sizeof(hdr)) {\n        cli_dbgmsg(\"cli_scanxar: Invalid header, too short.\\n\");\n        return CL_EFORMAT;\n    }\n    hdr.magic = be32_to_host(hdr.magic);\n\n    if (hdr.magic == XAR_HEADER_MAGIC) {\n        cli_dbgmsg(\"cli_scanxar: Matched magic\\n\");\n    }\n    else {\n        cli_dbgmsg(\"cli_scanxar: Invalid magic\\n\");\n        return CL_EFORMAT;\n    }\n    hdr.size = be16_to_host(hdr.size);\n    hdr.version = be16_to_host(hdr.version);\n    hdr.toc_length_compressed = be64_to_host(hdr.toc_length_compressed);\n    hdr.toc_length_decompressed = be64_to_host(hdr.toc_length_decompressed);\n    hdr.chksum_alg = be32_to_host(hdr.chksum_alg);\n\n    /* cli_dbgmsg(\"hdr.magic %x\\n\", hdr.magic); */\n    /* cli_dbgmsg(\"hdr.size %i\\n\", hdr.size); */\n    /* cli_dbgmsg(\"hdr.version %i\\n\", hdr.version); */\n    /* cli_dbgmsg(\"hdr.toc_length_compressed %lu\\n\", hdr.toc_length_compressed); */\n    /* cli_dbgmsg(\"hdr.toc_length_decompressed %lu\\n\", hdr.toc_length_decompressed); */\n    /* cli_dbgmsg(\"hdr.chksum_alg %i\\n\", hdr.chksum_alg); */\n \n    /* Uncompress TOC */\n    strm.next_in = (unsigned char *)fmap_need_off_once(*ctx->fmap, hdr.size, hdr.toc_length_compressed);\n    if (strm.next_in == NULL) {\n        cli_dbgmsg(\"cli_scanxar: fmap_need_off_once fails on TOC.\\n\");\n        return CL_EREAD;\n    }\n    strm.avail_in = hdr.toc_length_compressed; \n    toc = cli_malloc(hdr.toc_length_decompressed+1);\n    if (toc == NULL) {\n        cli_dbgmsg(\"cli_scanxar: cli_malloc fails on TOC decompress buffer.\\n\");\n        return CL_EMEM;\n    }\n    toc[hdr.toc_length_decompressed] = '\\0';\n    strm.avail_out = hdr.toc_length_decompressed;\n    strm.next_out = (unsigned char *)toc;\n    rc = inflateInit(&strm);\n    if (rc != Z_OK) {\n        cli_dbgmsg(\"cli_scanxar:inflateInit error %i \\n\", rc);\n        rc = CL_EFORMAT;\n        goto exit_toc;\n    }    \n    rc = inflate(&strm, Z_SYNC_FLUSH);\n    if (rc != Z_OK && rc != Z_STREAM_END) {\n        cli_dbgmsg(\"cli_scanxar:inflate error %i \\n\", rc);\n        rc = CL_EFORMAT;\n        goto exit_toc;\n    }\n    rc = inflateEnd(&strm);\n    if (rc != Z_OK) {\n        cli_dbgmsg(\"cli_scanxar:inflateEnd error %i \\n\", rc);\n        rc = CL_EFORMAT;\n        goto exit_toc;\n    }\n\n    /* cli_dbgmsg(\"cli_scanxar: TOC xml:\\n%s\\n\", toc); */\n    /* printf(\"cli_scanxar: TOC xml:\\n%s\\n\", toc); */\n    /* cli_dbgmsg(\"cli_scanxar: TOC end:\\n\"); */\n    /* printf(\"cli_scanxar: TOC end:\\n\"); */\n\n    /* scan the xml */\n    cli_dbgmsg(\"cli_scanxar: scanning xar TOC xml in memory.\\n\"); \n    rc = cli_mem_scandesc(toc, hdr.toc_length_decompressed, ctx);\n    if (rc != CL_SUCCESS) {\n        if (rc != CL_VIRUS || !SCAN_ALL)\n            goto exit_toc;        \n    }\n\n    /* make a file to leave if --leave-temps in effect */\n    if(ctx->engine->keeptmp) {\n        if ((rc = cli_gentempfd(ctx->engine->tmpdir, &tmpname, &fd)) != CL_SUCCESS) {\n            cli_dbgmsg(\"cli_scanxar: Can't create temporary file for TOC.\\n\");\n            goto exit_toc;\n        }\n        if (cli_writen(fd, toc, hdr.toc_length_decompressed) < 0) {\n            cli_dbgmsg(\"cli_scanxar: cli_writen error writing TOC.\\n\");\n            rc = CL_EWRITE;\n            xar_cleanup_temp_file(ctx, fd, tmpname);\n            goto exit_toc;\n        }\n        rc = xar_cleanup_temp_file(ctx, fd, tmpname);\n        if (rc != CL_SUCCESS)\n            goto exit_toc;\n    }\n\n    reader = xmlReaderForMemory(toc, hdr.toc_length_decompressed, \"noname.xml\", NULL, CLAMAV_MIN_XMLREADER_FLAGS);\n    if (reader == NULL) {\n        cli_dbgmsg(\"cli_scanxar: xmlReaderForMemory error for TOC\\n\");\n        goto exit_toc;\n    }\n\n    rc = xar_scan_subdocuments(reader, ctx);\n    if (rc != CL_SUCCESS) {\n        cli_dbgmsg(\"xar_scan_subdocuments returns %i.\\n\", rc);\n        goto exit_reader;\n    }\n\n    /* Walk the TOC XML and extract files */\n    fd = -1;\n    tmpname = NULL;\n    while (CL_SUCCESS == (rc = xar_get_toc_data_values(reader, &length, &offset, &size, &encoding,\n                                                       &a_cksum, &a_hash, &e_cksum, &e_hash))) {\n        int do_extract_cksum = 1;\n        unsigned char * blockp;\n        void *a_sc, *e_sc;\n        void *a_mc, *e_mc;\n        char * expected;\n\n        /* clean up temp file from previous loop iteration */\n        if (fd > -1 && tmpname) {\n            rc = xar_cleanup_temp_file(ctx, fd, tmpname);\n            if (rc != CL_SUCCESS)\n                goto exit_reader;\n        }\n\n        at = offset + hdr.toc_length_compressed + hdr.size;\n\n        if ((rc = cli_gentempfd(ctx->engine->tmpdir, &tmpname, &fd)) != CL_SUCCESS) {\n            cli_dbgmsg(\"cli_scanxar: Can't generate temporary file.\\n\");\n            goto exit_reader;\n        }\n\n        cli_dbgmsg(\"cli_scanxar: decompress into temp file:\\n%s, size %li,\\n\"\n                   \"from xar heap offset %li length %li\\n\",\n                   tmpname, size, offset, length);\n\n\n        a_hash_ctx = xar_hash_init(a_hash, &a_sc, &a_mc);\n        e_hash_ctx = xar_hash_init(e_hash, &e_sc, &e_mc);\n\n        switch (encoding) {\n        case CL_TYPE_GZ:\n            /* inflate gzip directly because file segments do not contain magic */\n            memset(&strm, 0, sizeof(strm));\n            if ((rc = inflateInit(&strm)) != Z_OK) {\n                cli_dbgmsg(\"cli_scanxar: InflateInit failed: %d\\n\", rc);\n                rc = CL_EFORMAT;\n                extract_errors++;\n                break;\n            }\n            \n            while ((size_t)at < map->len && (unsigned long)at < offset+hdr.toc_length_compressed+hdr.size+length) {\n                unsigned long avail_in;\n                void * next_in;\n                unsigned int bytes = MIN(map->len - at, map->pgsz);\n                bytes = MIN(length, bytes);\n                if(!(strm.next_in = next_in = (void*)fmap_need_off_once(map, at, bytes))) {\n                    cli_dbgmsg(\"cli_scanxar: Can't read %u bytes @ %lu.\\n\", bytes, (long unsigned)at);\n                    inflateEnd(&strm);\n                    rc = CL_EREAD;\n                    goto exit_tmpfile;\n                }\n                at += bytes;\n                strm.avail_in = avail_in = bytes;\n                do {\n                    int inf, outsize = 0;\n                    unsigned char buff[FILEBUFF];\n                    strm.avail_out = sizeof(buff);\n                    strm.next_out = buff;\n                    inf = inflate(&strm, Z_SYNC_FLUSH);\n                    if (inf != Z_OK && inf != Z_STREAM_END && inf != Z_BUF_ERROR) {\n                        cli_dbgmsg(\"cli_scanxar: inflate error %i %s.\\n\", inf, strm.msg?strm.msg:\"\");\n                        rc = CL_EFORMAT;\n                        extract_errors++;\n                        break;\n                    }\n\n                    bytes = sizeof(buff) - strm.avail_out;\n\n                    if (e_hash_ctx != NULL)\n                        xar_hash_update(e_hash_ctx, buff, bytes, e_hash);\n                   \n                    if (cli_writen(fd, buff, bytes) < 0) {\n                        cli_dbgmsg(\"cli_scanxar: cli_writen error file %s.\\n\", tmpname);\n                        inflateEnd(&strm);\n                        rc = CL_EWRITE;\n                        goto exit_tmpfile;\n                    }\n                    outsize += sizeof(buff) - strm.avail_out;\n                    if (cli_checklimits(\"cli_scanxar\", ctx, outsize, 0, 0) != CL_CLEAN) {\n                        break;\n                    }\n                    if (inf == Z_STREAM_END) {\n                        break;\n                    }\n                } while (strm.avail_out == 0);\n\n                if (rc != CL_SUCCESS)\n                    break;\n\n                avail_in -= strm.avail_in;\n                if (a_hash_ctx != NULL)\n                    xar_hash_update(a_hash_ctx, next_in, avail_in, a_hash);\n            }\n\n            inflateEnd(&strm);\n            break;\n        case CL_TYPE_7Z:\n#define CLI_LZMA_OBUF_SIZE 1024*1024\n#define CLI_LZMA_HDR_SIZE LZMA_PROPS_SIZE+8\n#define CLI_LZMA_IBUF_SIZE CLI_LZMA_OBUF_SIZE>>2 /* estimated compression ratio 25% */\n            {\n                struct CLI_LZMA lz;\n                unsigned long in_remaining = length;\n                unsigned long out_size = 0;\n                unsigned char * buff = __lzma_wrap_alloc(NULL, CLI_LZMA_OBUF_SIZE);\n                int lret;\n                \n                memset(&lz, 0, sizeof(lz));\n                if (buff == NULL) {\n                    cli_dbgmsg(\"cli_scanxar: memory request for lzma decompression buffer fails.\\n\");\n                    rc = CL_EMEM;\n                    goto exit_tmpfile;\n                    \n                }\n\n                blockp = (void*)fmap_need_off_once(map, at, CLI_LZMA_HDR_SIZE);\n                if (blockp == NULL) {\n                    char errbuff[128];\n                    cli_strerror(errno, errbuff, sizeof(errbuff));\n                    cli_dbgmsg(\"cli_scanxar: Can't read %li bytes @ %li, errno:%s.\\n\",\n                               length, at, errbuff);\n                    rc = CL_EREAD;\n                    __lzma_wrap_free(NULL, buff);\n                    goto exit_tmpfile;\n                }\n\n                lz.next_in = blockp;\n                lz.avail_in = CLI_LZMA_HDR_SIZE;\n\n                if (a_hash_ctx != NULL)\n                    xar_hash_update(a_hash_ctx, blockp, CLI_LZMA_HDR_SIZE, a_hash);\n\n                lret = cli_LzmaInit(&lz, 0);\n                if (lret != LZMA_RESULT_OK) {\n                    cli_dbgmsg(\"cli_scanxar: cli_LzmaInit() fails: %i.\\n\", lret);\n                    rc = CL_EFORMAT;\n                    __lzma_wrap_free(NULL, buff);\n                    extract_errors++;\n                    break;\n                }\n\n                at += CLI_LZMA_HDR_SIZE;\n                in_remaining -= CLI_LZMA_HDR_SIZE;\n                while ((size_t)at < map->len && (unsigned long)at < offset+hdr.toc_length_compressed+hdr.size+length) {\n                    SizeT avail_in;\n                    SizeT avail_out;\n                    void * next_in;\n                    unsigned long in_consumed;\n\n                    lz.next_out = buff;\n                    lz.avail_out = CLI_LZMA_OBUF_SIZE;\n                    lz.avail_in = avail_in = MIN(CLI_LZMA_IBUF_SIZE, in_remaining);\n                    lz.next_in = next_in = (void*)fmap_need_off_once(map, at, lz.avail_in);\n                    if (lz.next_in == NULL) {\n                        char errbuff[128];\n                        cli_strerror(errno, errbuff, sizeof(errbuff));\n                        cli_dbgmsg(\"cli_scanxar: Can't read %li bytes @ %li, errno: %s.\\n\",\n                                   length, at, errbuff);\n                        rc = CL_EREAD;\n                        __lzma_wrap_free(NULL, buff);\n                        cli_LzmaShutdown(&lz);\n                        goto exit_tmpfile;\n                    }\n\n                    lret = cli_LzmaDecode(&lz);\n                    if (lret != LZMA_RESULT_OK && lret != LZMA_STREAM_END) {\n                        cli_dbgmsg(\"cli_scanxar: cli_LzmaDecode() fails: %i.\\n\", lret);\n                        rc = CL_EFORMAT;\n                        extract_errors++;\n                        break;\n                    }\n\n                    in_consumed = avail_in - lz.avail_in;\n                    in_remaining -= in_consumed;\n                    at += in_consumed;\n                    avail_out = CLI_LZMA_OBUF_SIZE - lz.avail_out;\n                    \n                    if (avail_out == 0)\n                        cli_dbgmsg(\"cli_scanxar: cli_LzmaDecode() produces no output for \"\n                                   \"avail_in %llu, avail_out %llu.\\n\",\n                                   (long long unsigned)avail_in, (long long unsigned)avail_out);\n\n                    if (a_hash_ctx != NULL)\n                        xar_hash_update(a_hash_ctx, next_in, in_consumed, a_hash);                    \n                    if (e_hash_ctx != NULL)\n                        xar_hash_update(e_hash_ctx, buff, avail_out, e_hash);\n\n                    /* Write a decompressed block. */\n                    /* cli_dbgmsg(\"Writing %li bytes to LZMA decompress temp file, \" */\n                    /*            \"consumed %li of %li available compressed bytes.\\n\", */\n                    /*            avail_out, in_consumed, avail_in); */\n\n                    if (cli_writen(fd, buff, avail_out) < 0) {\n                        cli_dbgmsg(\"cli_scanxar: cli_writen error writing lzma temp file for %llu bytes.\\n\",\n                                   (long long unsigned)avail_out);\n                        __lzma_wrap_free(NULL, buff);\n                        cli_LzmaShutdown(&lz);\n                        rc = CL_EWRITE;\n                        goto exit_tmpfile;\n                    }\n\n                    /* Check file size limitation. */\n                    out_size += avail_out;\n                    if (cli_checklimits(\"cli_scanxar\", ctx, out_size, 0, 0) != CL_CLEAN) {\n                        break;\n                    }\n\n                    if (lret == LZMA_STREAM_END)\n                        break;\n                }\n\n                cli_LzmaShutdown(&lz);\n                __lzma_wrap_free(NULL, buff);\n            }\n            break; \n        case CL_TYPE_ANY:\n        default:\n        case CL_TYPE_BZ:\n        case CL_TYPE_XZ:\n            /* for uncompressed, bzip2, xz, and unknown, just pull the file, cli_magic_scandesc does the rest */\n            do_extract_cksum = 0;\n            {\n                unsigned long write_len;\n                \n                if (ctx->engine->maxfilesize)\n                    write_len = MIN((size_t)(ctx->engine->maxfilesize), (size_t)length);\n                else\n                    write_len = length;\n                    \n                if (!(blockp = (void*)fmap_need_off_once(map, at, length))) {\n                    char errbuff[128];\n                    cli_strerror(errno, errbuff, sizeof(errbuff));\n                    cli_dbgmsg(\"cli_scanxar: Can't read %li bytes @ %li, errno:%s.\\n\",\n                               length, at, errbuff);\n                    rc = CL_EREAD;\n                    goto exit_tmpfile;\n                }\n                \n                if (a_hash_ctx != NULL)\n                    xar_hash_update(a_hash_ctx, blockp, length, a_hash);\n                \n                if (cli_writen(fd, blockp, write_len) < 0) {\n                    cli_dbgmsg(\"cli_scanxar: cli_writen error %li bytes @ %li.\\n\", length, at);\n                    rc = CL_EWRITE;\n                    goto exit_tmpfile;\n                }\n                /*break;*/\n            }          \n        }\n\n        if (rc == CL_SUCCESS) {\n            if (a_hash_ctx != NULL) {\n                xar_hash_final(a_hash_ctx, result, a_hash);\n                a_hash_ctx = NULL;\n            } else {\n                cli_dbgmsg(\"cli_scanxar: archived-checksum missing.\\n\");\n                cksum_fails++;\n            }\n            if (a_cksum != NULL) {\n                expected = cli_hex2str((char *)a_cksum);\n                if (xar_hash_check(a_hash, result, expected) != 0) {\n                    cli_dbgmsg(\"cli_scanxar: archived-checksum mismatch.\\n\");\n                    cksum_fails++;\n                } else {\n                    cli_dbgmsg(\"cli_scanxar: archived-checksum matched.\\n\");                \n                }\n                free(expected);\n            }\n\n            if (e_hash_ctx != NULL) {\n                xar_hash_final(e_hash_ctx, result, e_hash);\n                e_hash_ctx = NULL;\n            } else {\n                cli_dbgmsg(\"cli_scanxar: extracted-checksum(unarchived-checksum) missing.\\n\");\n                cksum_fails++;\n            }\n            if (e_cksum != NULL) {\n                if (do_extract_cksum) {\n                    expected = cli_hex2str((char *)e_cksum);\n                    if (xar_hash_check(e_hash, result, expected) != 0) {\n                        cli_dbgmsg(\"cli_scanxar: extracted-checksum mismatch.\\n\");\n                        cksum_fails++;\n                    } else {\n                        cli_dbgmsg(\"cli_scanxar: extracted-checksum matched.\\n\");                \n                    }\n                    free(expected);\n                }\n            }\n        \n            rc = cli_magic_scandesc(fd, ctx);\n            if (rc != CL_SUCCESS) {\n                if (rc == CL_VIRUS) {\n                    cli_dbgmsg(\"cli_scanxar: Infected with %s\\n\", cli_get_last_virus(ctx));\n                    if (!SCAN_ALL)\n                        goto exit_tmpfile;\n                } else if (rc != CL_BREAK) {\n                    cli_dbgmsg(\"cli_scanxar: cli_magic_scandesc error %i\\n\", rc);\n                    goto exit_tmpfile;\n                }\n            }\n        }\n        \n        if (a_cksum != NULL) {\n            xmlFree(a_cksum);\n            a_cksum = NULL;\n        }\n        if (e_cksum != NULL) {\n            xmlFree(e_cksum);\n            e_cksum = NULL;\n        }\n    }\n\n exit_tmpfile:\n    xar_cleanup_temp_file(ctx, fd, tmpname);\n    if (a_hash_ctx != NULL)\n        xar_hash_final(a_hash_ctx, result, a_hash);\n    if (e_hash_ctx != NULL)\n        xar_hash_final(e_hash_ctx, result, e_hash);\n \n exit_reader:\n    if (a_cksum != NULL)\n        xmlFree(a_cksum);   \n    if (e_cksum != NULL)\n        xmlFree(e_cksum);\n    xmlTextReaderClose(reader);\n    xmlFreeTextReader(reader);\n\n exit_toc:\n    free(toc);\n    if (rc == CL_BREAK)\n        rc = CL_SUCCESS;\n#else\n    cli_dbgmsg(\"cli_scanxar: can't scan xar files, need libxml2.\\n\");\n#endif\n    if (cksum_fails + extract_errors != 0) {\n        cli_warnmsg(\"cli_scanxar: %u checksum errors and %u extraction errors, use --debug for more info.\\n\",\n                    cksum_fails, extract_errors);\n    }\n\n    return rc;\n}\n"], "fixing_code": ["/*\n *  Copyright (C) 2015 Cisco Systems, Inc. and/or its affiliates. All rights reserved.\n *  Copyright (C) 2013 Sourcefire, Inc.\n *\n *  Authors: Steven Morgan <smorgan@sourcefire.com>\n *\n *  This program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License version 2 as\n *  published by the Free Software Foundation.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this program; if not, write to the Free Software\n *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,\n *  MA 02110-1301, USA.\n */\n\n#if HAVE_CONFIG_H\n#include \"clamav-config.h\"\n#endif\n\n#include <errno.h>\n#include \"xar.h\"\n#include \"fmap.h\"\n#if HAVE_LIBXML2\n#ifdef _WIN32\n#ifndef LIBXML_WRITER_ENABLED\n#define LIBXML_WRITER_ENABLED 1\n#endif\n#endif\n#include <libxml/xmlreader.h>\n#include \"clamav.h\"\n#include \"str.h\"\n#include \"scanners.h\"\n#include \"inflate64.h\"\n#include \"lzma_iface.h\"\n\n/*\n   xar_cleanup_temp_file - cleanup after cli_gentempfd\n   parameters:\n     ctx - cli_ctx context pointer\n     fd  - fd to close\n     tmpname - name of file to unlink, address of storage to free\n   returns - CL_SUCCESS or CL_EUNLINK\n */\nstatic int xar_cleanup_temp_file(cli_ctx *ctx, int fd, char * tmpname)\n{\n    int rc = CL_SUCCESS;\n    if (fd > -1)\n        close(fd);\n    if (tmpname != NULL) {\n        if (!ctx->engine->keeptmp) {\n            if (cli_unlink(tmpname)) {\n                cli_dbgmsg(\"cli_scanxar: error unlinking tmpfile %s\\n\", tmpname); \n                rc = CL_EUNLINK;\n            }\n        }\n        free(tmpname);\n    }\n    return rc;\n}\n\n/*\n   xar_get_numeric_from_xml_element - extract xml element value as numeric\n   parameters:\n     reader - xmlTextReaderPtr\n     value - pointer to long to contain the returned value\n   returns - CL_SUCCESS or CL_EFORMAT\n */\nstatic int xar_get_numeric_from_xml_element(xmlTextReaderPtr reader, size_t * value)\n{\n    const xmlChar * numstr;\n    ssize_t numval;\n\n    if (xmlTextReaderRead(reader) == 1 && xmlTextReaderNodeType(reader) == XML_READER_TYPE_TEXT) {\n        numstr = xmlTextReaderConstValue(reader);\n        if (numstr) {\n            numval = atol((const char *)numstr);\n            if (numval < 0) {\n                cli_dbgmsg(\"cli_scanxar: XML element value %li\\n\", *value);\n                return CL_EFORMAT;\n            }\n            *value = numval;\n            return CL_SUCCESS;\n        }\n    }\n    cli_dbgmsg(\"cli_scanxar: No text for XML element\\n\");\n    return CL_EFORMAT;\n}\n\n/*\n  xar_get_checksum_values - extract checksum and hash algorithm from xml element\n  parameters:\n    reader - xmlTextReaderPtr\n    cksum - pointer to char* for returning checksum value.\n    hash - pointer to int for returning checksum algorithm.\n  returns - void\n */\nstatic void xar_get_checksum_values(xmlTextReaderPtr reader, unsigned char ** cksum, int * hash)\n{\n    xmlChar * style = xmlTextReaderGetAttribute(reader, (const xmlChar *)\"style\");\n    const xmlChar * xmlval;\n\n    *hash = XAR_CKSUM_NONE;\n    if (style == NULL) {\n        cli_dbgmsg(\"cli_scaxar: xmlTextReaderGetAttribute no style attribute \"\n                   \"for checksum element\\n\");\n    } else {\n        cli_dbgmsg(\"cli_scanxar: checksum algorithm is %s.\\n\", style);        \n        if (0 == xmlStrcasecmp(style, (const xmlChar *)\"sha1\")) {\n            *hash = XAR_CKSUM_SHA1;\n        } else if (0 == xmlStrcasecmp(style, (const xmlChar *)\"md5\")) {\n            *hash = XAR_CKSUM_MD5;\n        } else {\n            cli_dbgmsg(\"cli_scanxar: checksum algorithm %s is unsupported.\\n\", style);\n            *hash = XAR_CKSUM_OTHER;\n        }\n    }\n    if (style != NULL)\n        xmlFree(style);\n\n    if (xmlTextReaderRead(reader) == 1 && xmlTextReaderNodeType(reader) == XML_READER_TYPE_TEXT) {\n        xmlval = xmlTextReaderConstValue(reader);\n        if (xmlval) {\n            cli_dbgmsg(\"cli_scanxar: checksum value is %s.\\n\", xmlval);\n            if (*hash == XAR_CKSUM_SHA1 && xmlStrlen(xmlval) == 2 * CLI_HASHLEN_SHA1 ||\n                *hash == XAR_CKSUM_MD5 && xmlStrlen(xmlval) == 2 * CLI_HASHLEN_MD5)\n                {\n                    *cksum = xmlStrdup(xmlval); \n                } \n            else\n                {\n                    cli_dbgmsg(\"cli_scanxar: checksum type is unknown or length is invalid.\\n\");\n                    *hash = XAR_CKSUM_OTHER;\n                    *cksum = NULL;\n                }\n        } else {\n            *cksum = NULL;\n            cli_dbgmsg(\"cli_scanxar: xmlTextReaderConstValue() returns NULL for checksum value.\\n\");           \n        }\n    }\n    else\n        cli_dbgmsg(\"cli_scanxar: No text for XML checksum element.\\n\");\n}\n\n/*\n   xar_get_toc_data_values - return the values of a <data> or <ea> xml element that represent \n                             an extent of data on the heap.\n   parameters:\n     reader - xmlTextReaderPtr\n     length - pointer to long for returning value of the <length> element.\n     offset - pointer to long for returning value of the <offset> element.\n     size - pointer to long for returning value of the <size> element.\n     encoding - pointer to int for returning indication of the <encoding> style attribute.\n     a_cksum - pointer to char* for return archived checksum value.\n     a_hash - pointer to int for returning archived checksum algorithm.\n     e_cksum - pointer to char* for return extracted checksum value.\n     e_hash - pointer to int for returning extracted checksum algorithm.\n   returns - CL_FORMAT, CL_SUCCESS, CL_BREAK. CL_BREAK indicates no more <data>/<ea> element.\n */\nstatic int xar_get_toc_data_values(xmlTextReaderPtr reader, size_t *length, size_t *offset, size_t *size, int *encoding,\n                                   unsigned char ** a_cksum, int * a_hash, unsigned char ** e_cksum, int * e_hash)\n{\n    const xmlChar *name;\n    int indata = 0, inea = 0;\n    int rc, gotoffset=0, gotlength=0, gotsize=0;\n\n    *a_cksum = NULL;\n    *a_hash = XAR_CKSUM_NONE;\n    *e_cksum = NULL;\n    *e_hash = XAR_CKSUM_NONE;\n    *encoding = CL_TYPE_ANY;\n\n    rc = xmlTextReaderRead(reader);\n    while (rc == 1) {\n        name = xmlTextReaderConstLocalName(reader);\n        if (indata || inea) {\n            /*  cli_dbgmsg(\"cli_scanxar: xmlTextReaderRead read %s\\n\", name); */\n            if (xmlStrEqual(name, (const xmlChar *)\"offset\") && \n                xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT) {\n                if (CL_SUCCESS == xar_get_numeric_from_xml_element(reader, offset))\n                    gotoffset=1;\n\n            } else if (xmlStrEqual(name, (const xmlChar *)\"length\") &&\n                       xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT) {\n                if (CL_SUCCESS == xar_get_numeric_from_xml_element(reader, length))\n                    gotlength=1;\n\n            } else if (xmlStrEqual(name, (const xmlChar *)\"size\") &&\n                       xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT) {\n                if (CL_SUCCESS == xar_get_numeric_from_xml_element(reader, size))\n                    gotsize=1;\n\n            } else if (xmlStrEqual(name, (const xmlChar *)\"archived-checksum\") &&\n                       xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT) {\n                cli_dbgmsg(\"cli_scanxar: <archived-checksum>:\\n\");\n                xar_get_checksum_values(reader, a_cksum, a_hash);\n                \n            } else if ((xmlStrEqual(name, (const xmlChar *)\"extracted-checksum\") ||\n                        xmlStrEqual(name, (const xmlChar *)\"unarchived-checksum\")) &&\n                       xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT) {\n                cli_dbgmsg(\"cli_scanxar: <extracted-checksum>:\\n\");\n                xar_get_checksum_values(reader, e_cksum, e_hash);\n\n            } else if (xmlStrEqual(name, (const xmlChar *)\"encoding\") &&\n                       xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT) {\n                xmlChar * style = xmlTextReaderGetAttribute(reader, (const xmlChar *)\"style\");\n                if (style == NULL) {\n                    cli_dbgmsg(\"cli_scaxar: xmlTextReaderGetAttribute no style attribute \"\n                               \"for encoding element\\n\");\n                    *encoding = CL_TYPE_ANY;\n                } else if (xmlStrEqual(style, (const xmlChar *)\"application/x-gzip\")) {\n                    cli_dbgmsg(\"cli_scanxar: encoding = application/x-gzip.\\n\");\n                    *encoding = CL_TYPE_GZ; \n                } else if (xmlStrEqual(style, (const xmlChar *)\"application/octet-stream\")) {\n                    cli_dbgmsg(\"cli_scanxar: encoding = application/octet-stream.\\n\");\n                    *encoding = CL_TYPE_ANY; \n                } else if (xmlStrEqual(style, (const xmlChar *)\"application/x-bzip2\")) {\n                    cli_dbgmsg(\"cli_scanxar: encoding = application/x-bzip2.\\n\");\n                    *encoding = CL_TYPE_BZ;\n                } else if (xmlStrEqual(style, (const xmlChar *)\"application/x-lzma\")) {\n                    cli_dbgmsg(\"cli_scanxar: encoding = application/x-lzma.\\n\");\n                    *encoding = CL_TYPE_7Z;\n                 } else if (xmlStrEqual(style, (const xmlChar *)\"application/x-xz\")) {\n                    cli_dbgmsg(\"cli_scanxar: encoding = application/x-xz.\\n\");\n                    *encoding = CL_TYPE_XZ;\n                } else {\n                    cli_dbgmsg(\"cli_scaxar: unknown style value=%s for encoding element\\n\", style);\n                    *encoding = CL_TYPE_ANY;\n                }\n                if (style != NULL)\n                    xmlFree(style);\n\n           } else if (indata && xmlStrEqual(name, (const xmlChar *)\"data\") &&\n                       xmlTextReaderNodeType(reader) == XML_READER_TYPE_END_ELEMENT) {\n                break;\n\n            } else if (inea && xmlStrEqual(name, (const xmlChar *)\"ea\") &&\n                       xmlTextReaderNodeType(reader) == XML_READER_TYPE_END_ELEMENT) {\n                break;\n            }\n            \n        } else {\n            if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT) {\n                if (xmlStrEqual(name, (const xmlChar *)\"data\")) {\n                    cli_dbgmsg(\"cli_scanxar: xmlTextReaderRead read <data>\\n\");\n                    indata = 1;\n                } else if (xmlStrEqual(name, (const xmlChar *)\"ea\")) {\n                    cli_dbgmsg(\"cli_scanxar: xmlTextReaderRead read <ea>\\n\");\n                    inea = 1;\n                }\n            } else if ((xmlTextReaderNodeType(reader) == XML_READER_TYPE_END_ELEMENT) &&\n                       xmlStrEqual(name, (const xmlChar *)\"xar\")) {\n                cli_dbgmsg(\"cli_scanxar: finished parsing xar TOC.\\n\");   \n                break;\n            }\n        }\n        rc = xmlTextReaderRead(reader);\n    }\n    \n    if (gotoffset && gotlength && gotsize) {\n        rc = CL_SUCCESS;\n    }\n    else if (0 == gotoffset + gotlength + gotsize)\n        rc = CL_BREAK;\n    else\n        rc = CL_EFORMAT;\n\n    return rc;\n}\n\n/*\n  xar_process_subdocument - check TOC for xml subdocument. If found, extract and\n                            scan in memory.\n  Parameters:\n     reader - xmlTextReaderPtr\n     ctx - pointer to cli_ctx\n  Returns:\n     CL_SUCCESS - subdoc found and clean scan (or virus found and SCAN_ALL), or no subdocument\n     other - error return code from cli_mem_scandesc()\n*/                        \nstatic int xar_scan_subdocuments(xmlTextReaderPtr reader, cli_ctx *ctx)\n{\n    int rc = CL_SUCCESS, subdoc_len, fd;\n    xmlChar * subdoc;\n    const xmlChar *name;\n    char * tmpname;\n\n    while (xmlTextReaderRead(reader) == 1) {\n        name = xmlTextReaderConstLocalName(reader);\n        if (name == NULL) {\n            cli_dbgmsg(\"cli_scanxar: xmlTextReaderConstLocalName() no name.\\n\");\n            rc = CL_EFORMAT;\n            break;\n        }\n        if (xmlStrEqual(name, (const xmlChar *)\"toc\") && \n            xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT)\n            return CL_SUCCESS;\n        if (xmlStrEqual(name, (const xmlChar *)\"subdoc\") && \n            xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT) {\n            subdoc = xmlTextReaderReadInnerXml(reader);\n            if (subdoc == NULL) {\n                cli_dbgmsg(\"cli_scanxar: no content in subdoc element.\\n\");\n                xmlTextReaderNext(reader);\n                continue;\n            }\n            subdoc_len = xmlStrlen(subdoc);\n            cli_dbgmsg(\"cli_scanxar: in-memory scan of xml subdocument, len %i.\\n\", subdoc_len);\n            rc = cli_mem_scandesc(subdoc, subdoc_len, ctx);\n            if (rc == CL_VIRUS && SCAN_ALL)\n                rc = CL_SUCCESS;\n            \n            /* make a file to leave if --leave-temps in effect */\n            if(ctx->engine->keeptmp) {\n                if ((rc = cli_gentempfd(ctx->engine->tmpdir, &tmpname, &fd)) != CL_SUCCESS) {\n                    cli_dbgmsg(\"cli_scanxar: Can't create temporary file for subdocument.\\n\");\n                } else {\n                    cli_dbgmsg(\"cli_scanxar: Writing subdoc to temp file %s.\\n\", tmpname);\n                    if (cli_writen(fd, subdoc, subdoc_len) < 0) {\n                        cli_dbgmsg(\"cli_scanxar: cli_writen error writing subdoc temporary file.\\n\");\n                        rc = CL_EWRITE;\n                    }\n                    rc = xar_cleanup_temp_file(ctx, fd, tmpname);\n                }\n            }\n\n            xmlFree(subdoc);\n            if (rc != CL_SUCCESS)\n                return rc;\n            xmlTextReaderNext(reader);\n        }        \n    }\n    return rc;\n}\n\nstatic void * xar_hash_init(int hash, void **sc, void **mc)\n{\n    if (!sc && !mc)\n        return NULL;\n    switch (hash) {\n    case XAR_CKSUM_SHA1:\n        *sc = cl_hash_init(\"sha1\");\n        if (!(*sc)) {\n            return NULL;\n        }\n\n        return *sc;\n    case XAR_CKSUM_MD5:\n        *mc = cl_hash_init(\"md5\");\n        if (!(*mc)) {\n            return NULL;\n        }\n\n        return *mc;\n    case XAR_CKSUM_OTHER:\n    case XAR_CKSUM_NONE:\n    default:\n        return NULL;\n    }\n}\n\nstatic void xar_hash_update(void * hash_ctx, void * data, unsigned long size, int hash)\n{\n    if (!hash_ctx || !data || !size)\n        return;\n\n    switch (hash) {\n    case XAR_CKSUM_NONE:\n    case XAR_CKSUM_OTHER:\n        return;\n    }\n\n    cl_update_hash(hash_ctx, data, size);\n}\n\nstatic void xar_hash_final(void * hash_ctx, void * result, int hash)\n{\n    if (!hash_ctx || !result)\n        return;\n\n    switch (hash) {\n    case XAR_CKSUM_OTHER:\n    case XAR_CKSUM_NONE:\n        return;\n    }\n\n    cl_finish_hash(hash_ctx, result);\n}\n\nstatic int xar_hash_check(int hash, const void * result, const void * expected)\n{\n    int len;\n\n    if (!result || !expected)\n        return 1;\n    switch (hash) {\n    case XAR_CKSUM_SHA1:\n        len = CLI_HASHLEN_SHA1;\n        break;\n    case XAR_CKSUM_MD5:\n        len = CLI_HASHLEN_MD5;\n        break;\n    case XAR_CKSUM_OTHER:\n    case XAR_CKSUM_NONE:\n    default:\n        return 1;\n    }\n    return memcmp(result, expected, len);\n}\n\n#endif\n\n/*\n  cli_scanxar - scan an xar archive.\n  Parameters:\n    ctx - pointer to cli_ctx.\n  returns - CL_SUCCESS or CL_ error code.\n*/\n\nint cli_scanxar(cli_ctx *ctx)\n{\n    int rc = CL_SUCCESS;\n    unsigned int cksum_fails = 0;\n    unsigned int extract_errors = 0;\n#if HAVE_LIBXML2\n    int fd = -1;\n    struct xar_header hdr;\n    fmap_t *map = *ctx->fmap;\n    size_t length, offset, size, at;\n    int encoding;\n    z_stream strm;\n    char *toc, *tmpname;\n    xmlTextReaderPtr reader = NULL;\n    int a_hash, e_hash;\n    unsigned char *a_cksum = NULL, *e_cksum = NULL;\n    void *a_hash_ctx = NULL, *e_hash_ctx = NULL;\n    char result[SHA1_HASH_SIZE];\n\n    memset(&strm, 0x00, sizeof(z_stream));\n\n    /* retrieve xar header */\n    if (fmap_readn(*ctx->fmap, &hdr, 0, sizeof(hdr)) != sizeof(hdr)) {\n        cli_dbgmsg(\"cli_scanxar: Invalid header, too short.\\n\");\n        return CL_EFORMAT;\n    }\n    hdr.magic = be32_to_host(hdr.magic);\n\n    if (hdr.magic == XAR_HEADER_MAGIC) {\n        cli_dbgmsg(\"cli_scanxar: Matched magic\\n\");\n    }\n    else {\n        cli_dbgmsg(\"cli_scanxar: Invalid magic\\n\");\n        return CL_EFORMAT;\n    }\n    hdr.size = be16_to_host(hdr.size);\n    hdr.version = be16_to_host(hdr.version);\n    hdr.toc_length_compressed = be64_to_host(hdr.toc_length_compressed);\n    hdr.toc_length_decompressed = be64_to_host(hdr.toc_length_decompressed);\n    hdr.chksum_alg = be32_to_host(hdr.chksum_alg);\n\n    /* cli_dbgmsg(\"hdr.magic %x\\n\", hdr.magic); */\n    /* cli_dbgmsg(\"hdr.size %i\\n\", hdr.size); */\n    /* cli_dbgmsg(\"hdr.version %i\\n\", hdr.version); */\n    /* cli_dbgmsg(\"hdr.toc_length_compressed %lu\\n\", hdr.toc_length_compressed); */\n    /* cli_dbgmsg(\"hdr.toc_length_decompressed %lu\\n\", hdr.toc_length_decompressed); */\n    /* cli_dbgmsg(\"hdr.chksum_alg %i\\n\", hdr.chksum_alg); */\n \n    /* Uncompress TOC */\n    strm.next_in = (unsigned char *)fmap_need_off_once(*ctx->fmap, hdr.size, hdr.toc_length_compressed);\n    if (strm.next_in == NULL) {\n        cli_dbgmsg(\"cli_scanxar: fmap_need_off_once fails on TOC.\\n\");\n        return CL_EREAD;\n    }\n    strm.avail_in = hdr.toc_length_compressed; \n    toc = cli_malloc(hdr.toc_length_decompressed+1);\n    if (toc == NULL) {\n        cli_dbgmsg(\"cli_scanxar: cli_malloc fails on TOC decompress buffer.\\n\");\n        return CL_EMEM;\n    }\n    toc[hdr.toc_length_decompressed] = '\\0';\n    strm.avail_out = hdr.toc_length_decompressed;\n    strm.next_out = (unsigned char *)toc;\n    rc = inflateInit(&strm);\n    if (rc != Z_OK) {\n        cli_dbgmsg(\"cli_scanxar:inflateInit error %i \\n\", rc);\n        rc = CL_EFORMAT;\n        goto exit_toc;\n    }    \n    rc = inflate(&strm, Z_SYNC_FLUSH);\n    if (rc != Z_OK && rc != Z_STREAM_END) {\n        cli_dbgmsg(\"cli_scanxar:inflate error %i \\n\", rc);\n        rc = CL_EFORMAT;\n        goto exit_toc;\n    }\n    rc = inflateEnd(&strm);\n    if (rc != Z_OK) {\n        cli_dbgmsg(\"cli_scanxar:inflateEnd error %i \\n\", rc);\n        rc = CL_EFORMAT;\n        goto exit_toc;\n    }\n\n    if (hdr.toc_length_decompressed != strm.total_out) {\n        cli_dbgmsg(\"TOC decompress length %\" PRIu64 \" does not match amount decompressed %lu\\n\",\n                   hdr.toc_length_decompressed, strm.total_out);\n        toc[strm.total_out] = '\\0';\n        hdr.toc_length_decompressed = strm.total_out;\n    }\n\n    /* cli_dbgmsg(\"cli_scanxar: TOC xml:\\n%s\\n\", toc); */\n    /* printf(\"cli_scanxar: TOC xml:\\n%s\\n\", toc); */\n    /* cli_dbgmsg(\"cli_scanxar: TOC end:\\n\"); */\n    /* printf(\"cli_scanxar: TOC end:\\n\"); */\n\n    /* scan the xml */\n    cli_dbgmsg(\"cli_scanxar: scanning xar TOC xml in memory.\\n\"); \n    rc = cli_mem_scandesc(toc, hdr.toc_length_decompressed, ctx);\n    if (rc != CL_SUCCESS) {\n        if (rc != CL_VIRUS || !SCAN_ALL)\n            goto exit_toc;        \n    }\n\n    /* make a file to leave if --leave-temps in effect */\n    if(ctx->engine->keeptmp) {\n        if ((rc = cli_gentempfd(ctx->engine->tmpdir, &tmpname, &fd)) != CL_SUCCESS) {\n            cli_dbgmsg(\"cli_scanxar: Can't create temporary file for TOC.\\n\");\n            goto exit_toc;\n        }\n        if (cli_writen(fd, toc, hdr.toc_length_decompressed) < 0) {\n            cli_dbgmsg(\"cli_scanxar: cli_writen error writing TOC.\\n\");\n            rc = CL_EWRITE;\n            xar_cleanup_temp_file(ctx, fd, tmpname);\n            goto exit_toc;\n        }\n        rc = xar_cleanup_temp_file(ctx, fd, tmpname);\n        if (rc != CL_SUCCESS)\n            goto exit_toc;\n    }\n\n    reader = xmlReaderForMemory(toc, hdr.toc_length_decompressed, \"noname.xml\", NULL, CLAMAV_MIN_XMLREADER_FLAGS);\n    if (reader == NULL) {\n        cli_dbgmsg(\"cli_scanxar: xmlReaderForMemory error for TOC\\n\");\n        goto exit_toc;\n    }\n\n    rc = xar_scan_subdocuments(reader, ctx);\n    if (rc != CL_SUCCESS) {\n        cli_dbgmsg(\"xar_scan_subdocuments returns %i.\\n\", rc);\n        goto exit_reader;\n    }\n\n    /* Walk the TOC XML and extract files */\n    fd = -1;\n    tmpname = NULL;\n    while (CL_SUCCESS == (rc = xar_get_toc_data_values(reader, &length, &offset, &size, &encoding,\n                                                       &a_cksum, &a_hash, &e_cksum, &e_hash))) {\n        int do_extract_cksum = 1;\n        unsigned char * blockp;\n        void *a_sc, *e_sc;\n        void *a_mc, *e_mc;\n        char * expected;\n\n        /* clean up temp file from previous loop iteration */\n        if (fd > -1 && tmpname) {\n            rc = xar_cleanup_temp_file(ctx, fd, tmpname);\n            if (rc != CL_SUCCESS)\n                goto exit_reader;\n        }\n\n        at = offset + hdr.toc_length_compressed + hdr.size;\n\n        if ((rc = cli_gentempfd(ctx->engine->tmpdir, &tmpname, &fd)) != CL_SUCCESS) {\n            cli_dbgmsg(\"cli_scanxar: Can't generate temporary file.\\n\");\n            goto exit_reader;\n        }\n\n        cli_dbgmsg(\"cli_scanxar: decompress into temp file:\\n%s, size %zu,\\n\"\n                   \"from xar heap offset %zu length %zu\\n\",\n                   tmpname, size, offset, length);\n\n\n        a_hash_ctx = xar_hash_init(a_hash, &a_sc, &a_mc);\n        e_hash_ctx = xar_hash_init(e_hash, &e_sc, &e_mc);\n\n        switch (encoding) {\n        case CL_TYPE_GZ:\n            /* inflate gzip directly because file segments do not contain magic */\n            memset(&strm, 0, sizeof(strm));\n            if ((rc = inflateInit(&strm)) != Z_OK) {\n                cli_dbgmsg(\"cli_scanxar: InflateInit failed: %d\\n\", rc);\n                rc = CL_EFORMAT;\n                extract_errors++;\n                break;\n            }\n            \n            while ((size_t)at < map->len && (unsigned long)at < offset+hdr.toc_length_compressed+hdr.size+length) {\n                unsigned long avail_in;\n                void * next_in;\n                unsigned int bytes = MIN(map->len - at, map->pgsz);\n                bytes = MIN(length, bytes);\n                if(!(strm.next_in = next_in = (void*)fmap_need_off_once(map, at, bytes))) {\n                    cli_dbgmsg(\"cli_scanxar: Can't read %u bytes @ %lu.\\n\", bytes, (long unsigned)at);\n                    inflateEnd(&strm);\n                    rc = CL_EREAD;\n                    goto exit_tmpfile;\n                }\n                at += bytes;\n                strm.avail_in = avail_in = bytes;\n                do {\n                    int inf, outsize = 0;\n                    unsigned char buff[FILEBUFF];\n                    strm.avail_out = sizeof(buff);\n                    strm.next_out = buff;\n                    inf = inflate(&strm, Z_SYNC_FLUSH);\n                    if (inf != Z_OK && inf != Z_STREAM_END && inf != Z_BUF_ERROR) {\n                        cli_dbgmsg(\"cli_scanxar: inflate error %i %s.\\n\", inf, strm.msg?strm.msg:\"\");\n                        rc = CL_EFORMAT;\n                        extract_errors++;\n                        break;\n                    }\n\n                    bytes = sizeof(buff) - strm.avail_out;\n\n                    if (e_hash_ctx != NULL)\n                        xar_hash_update(e_hash_ctx, buff, bytes, e_hash);\n                   \n                    if (cli_writen(fd, buff, bytes) < 0) {\n                        cli_dbgmsg(\"cli_scanxar: cli_writen error file %s.\\n\", tmpname);\n                        inflateEnd(&strm);\n                        rc = CL_EWRITE;\n                        goto exit_tmpfile;\n                    }\n                    outsize += sizeof(buff) - strm.avail_out;\n                    if (cli_checklimits(\"cli_scanxar\", ctx, outsize, 0, 0) != CL_CLEAN) {\n                        break;\n                    }\n                    if (inf == Z_STREAM_END) {\n                        break;\n                    }\n                } while (strm.avail_out == 0);\n\n                if (rc != CL_SUCCESS)\n                    break;\n\n                avail_in -= strm.avail_in;\n                if (a_hash_ctx != NULL)\n                    xar_hash_update(a_hash_ctx, next_in, avail_in, a_hash);\n            }\n\n            inflateEnd(&strm);\n            break;\n        case CL_TYPE_7Z:\n#define CLI_LZMA_OBUF_SIZE 1024*1024\n#define CLI_LZMA_HDR_SIZE LZMA_PROPS_SIZE+8\n#define CLI_LZMA_IBUF_SIZE CLI_LZMA_OBUF_SIZE>>2 /* estimated compression ratio 25% */\n            {\n                struct CLI_LZMA lz;\n                unsigned long in_remaining = MIN(length, map->len - at);\n                unsigned long out_size = 0;\n                unsigned char * buff = __lzma_wrap_alloc(NULL, CLI_LZMA_OBUF_SIZE);\n                int lret;\n\n                if (length > in_remaining)\n                    length = in_remaining;\n\n                memset(&lz, 0, sizeof(lz));\n                if (buff == NULL) {\n                    cli_dbgmsg(\"cli_scanxar: memory request for lzma decompression buffer fails.\\n\");\n                    rc = CL_EMEM;\n                    goto exit_tmpfile;\n                    \n                }\n\n                blockp = (void*)fmap_need_off_once(map, at, CLI_LZMA_HDR_SIZE);\n                if (blockp == NULL) {\n                    char errbuff[128];\n                    cli_strerror(errno, errbuff, sizeof(errbuff));\n                    cli_dbgmsg(\"cli_scanxar: Can't read %i bytes @ %li, errno:%s.\\n\",\n                               CLI_LZMA_HDR_SIZE, at, errbuff);\n                    rc = CL_EREAD;\n                    __lzma_wrap_free(NULL, buff);\n                    goto exit_tmpfile;\n                }\n\n                lz.next_in = blockp;\n                lz.avail_in = CLI_LZMA_HDR_SIZE;\n\n                if (a_hash_ctx != NULL)\n                    xar_hash_update(a_hash_ctx, blockp, CLI_LZMA_HDR_SIZE, a_hash);\n\n                lret = cli_LzmaInit(&lz, 0);\n                if (lret != LZMA_RESULT_OK) {\n                    cli_dbgmsg(\"cli_scanxar: cli_LzmaInit() fails: %i.\\n\", lret);\n                    rc = CL_EFORMAT;\n                    __lzma_wrap_free(NULL, buff);\n                    extract_errors++;\n                    break;\n                }\n\n                at += CLI_LZMA_HDR_SIZE;\n                in_remaining -= CLI_LZMA_HDR_SIZE;\n                while ((size_t)at < map->len && (unsigned long)at < offset+hdr.toc_length_compressed+hdr.size+length) {\n                    SizeT avail_in;\n                    SizeT avail_out;\n                    void * next_in;\n                    unsigned long in_consumed;\n\n                    lz.next_out = buff;\n                    lz.avail_out = CLI_LZMA_OBUF_SIZE;\n                    lz.avail_in = avail_in = MIN(CLI_LZMA_IBUF_SIZE, in_remaining);\n                    lz.next_in = next_in = (void*)fmap_need_off_once(map, at, lz.avail_in);\n                    if (lz.next_in == NULL) {\n                        char errbuff[128];\n                        cli_strerror(errno, errbuff, sizeof(errbuff));\n                        cli_dbgmsg(\"cli_scanxar: Can't read %li bytes @ %li, errno: %s.\\n\",\n                                   lz.avail_in, at, errbuff);\n                        rc = CL_EREAD;\n                        __lzma_wrap_free(NULL, buff);\n                        cli_LzmaShutdown(&lz);\n                        goto exit_tmpfile;\n                    }\n\n                    lret = cli_LzmaDecode(&lz);\n                    if (lret != LZMA_RESULT_OK && lret != LZMA_STREAM_END) {\n                        cli_dbgmsg(\"cli_scanxar: cli_LzmaDecode() fails: %i.\\n\", lret);\n                        rc = CL_EFORMAT;\n                        extract_errors++;\n                        break;\n                    }\n\n                    in_consumed = avail_in - lz.avail_in;\n                    in_remaining -= in_consumed;\n                    at += in_consumed;\n                    avail_out = CLI_LZMA_OBUF_SIZE - lz.avail_out;\n                    \n                    if (avail_out == 0)\n                        cli_dbgmsg(\"cli_scanxar: cli_LzmaDecode() produces no output for \"\n                                   \"avail_in %llu, avail_out %llu.\\n\",\n                                   (long long unsigned)avail_in, (long long unsigned)avail_out);\n\n                    if (a_hash_ctx != NULL)\n                        xar_hash_update(a_hash_ctx, next_in, in_consumed, a_hash);                    \n                    if (e_hash_ctx != NULL)\n                        xar_hash_update(e_hash_ctx, buff, avail_out, e_hash);\n\n                    /* Write a decompressed block. */\n                    /* cli_dbgmsg(\"Writing %li bytes to LZMA decompress temp file, \" */\n                    /*            \"consumed %li of %li available compressed bytes.\\n\", */\n                    /*            avail_out, in_consumed, avail_in); */\n\n                    if (cli_writen(fd, buff, avail_out) < 0) {\n                        cli_dbgmsg(\"cli_scanxar: cli_writen error writing lzma temp file for %llu bytes.\\n\",\n                                   (long long unsigned)avail_out);\n                        __lzma_wrap_free(NULL, buff);\n                        cli_LzmaShutdown(&lz);\n                        rc = CL_EWRITE;\n                        goto exit_tmpfile;\n                    }\n\n                    /* Check file size limitation. */\n                    out_size += avail_out;\n                    if (cli_checklimits(\"cli_scanxar\", ctx, out_size, 0, 0) != CL_CLEAN) {\n                        break;\n                    }\n\n                    if (lret == LZMA_STREAM_END)\n                        break;\n                }\n\n                cli_LzmaShutdown(&lz);\n                __lzma_wrap_free(NULL, buff);\n            }\n            break; \n        case CL_TYPE_ANY:\n        default:\n        case CL_TYPE_BZ:\n        case CL_TYPE_XZ:\n            /* for uncompressed, bzip2, xz, and unknown, just pull the file, cli_magic_scandesc does the rest */\n            do_extract_cksum = 0;\n            {\n                size_t writelen = MIN(map->len - at, length);\n\n                if (ctx->engine->maxfilesize)\n                    writelen = MIN((size_t)(ctx->engine->maxfilesize), writelen);\n                    \n                if (!(blockp = (void*)fmap_need_off_once(map, at, writelen))) {\n                    char errbuff[128];\n                    cli_strerror(errno, errbuff, sizeof(errbuff));\n                    cli_dbgmsg(\"cli_scanxar: Can't read %zu bytes @ %zu, errno:%s.\\n\",\n                               writelen, at, errbuff);\n                    rc = CL_EREAD;\n                    goto exit_tmpfile;\n                }\n                \n                if (a_hash_ctx != NULL)\n                    xar_hash_update(a_hash_ctx, blockp, writelen, a_hash);\n                \n                if (cli_writen(fd, blockp, writelen) < 0) {\n                    cli_dbgmsg(\"cli_scanxar: cli_writen error %zu bytes @ %li.\\n\", writelen, at);\n                    rc = CL_EWRITE;\n                    goto exit_tmpfile;\n                }\n                /*break;*/\n            }          \n        } /* end of switch */\n\n        if (rc == CL_SUCCESS) {\n            if (a_hash_ctx != NULL) {\n                xar_hash_final(a_hash_ctx, result, a_hash);\n                a_hash_ctx = NULL;\n            } else {\n                cli_dbgmsg(\"cli_scanxar: archived-checksum missing.\\n\");\n                cksum_fails++;\n            }\n            if (a_cksum != NULL) {\n                expected = cli_hex2str((char *)a_cksum);\n                if (xar_hash_check(a_hash, result, expected) != 0) {\n                    cli_dbgmsg(\"cli_scanxar: archived-checksum mismatch.\\n\");\n                    cksum_fails++;\n                } else {\n                    cli_dbgmsg(\"cli_scanxar: archived-checksum matched.\\n\");                \n                }\n                free(expected);\n            }\n\n            if (e_hash_ctx != NULL) {\n                xar_hash_final(e_hash_ctx, result, e_hash);\n                e_hash_ctx = NULL;\n            } else {\n                cli_dbgmsg(\"cli_scanxar: extracted-checksum(unarchived-checksum) missing.\\n\");\n                cksum_fails++;\n            }\n            if (e_cksum != NULL) {\n                if (do_extract_cksum) {\n                    expected = cli_hex2str((char *)e_cksum);\n                    if (xar_hash_check(e_hash, result, expected) != 0) {\n                        cli_dbgmsg(\"cli_scanxar: extracted-checksum mismatch.\\n\");\n                        cksum_fails++;\n                    } else {\n                        cli_dbgmsg(\"cli_scanxar: extracted-checksum matched.\\n\");                \n                    }\n                    free(expected);\n                }\n            }\n        \n            rc = cli_magic_scandesc(fd, ctx);\n            if (rc != CL_SUCCESS) {\n                if (rc == CL_VIRUS) {\n                    cli_dbgmsg(\"cli_scanxar: Infected with %s\\n\", cli_get_last_virus(ctx));\n                    if (!SCAN_ALL)\n                        goto exit_tmpfile;\n                } else if (rc != CL_BREAK) {\n                    cli_dbgmsg(\"cli_scanxar: cli_magic_scandesc error %i\\n\", rc);\n                    goto exit_tmpfile;\n                }\n            }\n        }\n        \n        if (a_cksum != NULL) {\n            xmlFree(a_cksum);\n            a_cksum = NULL;\n        }\n        if (e_cksum != NULL) {\n            xmlFree(e_cksum);\n            e_cksum = NULL;\n        }\n    }\n\n exit_tmpfile:\n    xar_cleanup_temp_file(ctx, fd, tmpname);\n    if (a_hash_ctx != NULL)\n        xar_hash_final(a_hash_ctx, result, a_hash);\n    if (e_hash_ctx != NULL)\n        xar_hash_final(e_hash_ctx, result, e_hash);\n \n exit_reader:\n    if (a_cksum != NULL)\n        xmlFree(a_cksum);   \n    if (e_cksum != NULL)\n        xmlFree(e_cksum);\n    xmlTextReaderClose(reader);\n    xmlFreeTextReader(reader);\n\n exit_toc:\n    free(toc);\n    if (rc == CL_BREAK)\n        rc = CL_SUCCESS;\n#else\n    cli_dbgmsg(\"cli_scanxar: can't scan xar files, need libxml2.\\n\");\n#endif\n    if (cksum_fails + extract_errors != 0) {\n        cli_dbgmsg(\"cli_scanxar: %u checksum errors and %u extraction errors.\\n\",\n                    cksum_fails, extract_errors);\n    }\n\n    return rc;\n}\n"], "filenames": ["libclamav/xar.c"], "buggy_code_start_loc": [74], "buggy_code_end_loc": [875], "fixing_code_start_loc": [74], "fixing_code_end_loc": [896], "type": "CWE-125", "message": "ClamAV version version 0.99.3 contains a Out of bounds heap memory read vulnerability in XAR parser, function xar_hash_check() that can result in Leaking of memory, may help in developing exploit chains.. This attack appear to be exploitable via The victim must scan a crafted XAR file. This vulnerability appears to have been fixed in after commit d96a6b8bcc7439fa7e3876207aa0a8e79c8451b6.", "other": {"cve": {"id": "CVE-2018-1000085", "sourceIdentifier": "cve@mitre.org", "published": "2018-03-13T15:29:01.113", "lastModified": "2019-03-20T18:30:29.427", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "ClamAV version version 0.99.3 contains a Out of bounds heap memory read vulnerability in XAR parser, function xar_hash_check() that can result in Leaking of memory, may help in developing exploit chains.. This attack appear to be exploitable via The victim must scan a crafted XAR file. This vulnerability appears to have been fixed in after commit d96a6b8bcc7439fa7e3876207aa0a8e79c8451b6."}, {"lang": "es", "value": "ClamAV, versi\u00f3n 0.99.3, contiene una vulnerabilidad de lectura de memoria din\u00e1mica (heap) fuera de l\u00edmites en el analizador XAR, en la funci\u00f3n xar_hash_check() que puede resultar en un filtrado de memoria y ayudar a desarrollar cadenas de exploits. El ataque parece ser explotable si una v\u00edctima escanea un archivo XAR malicioso. La vulnerabilidad parece haber sido solucionada tras el commit con ID d96a6b8bcc7439fa7e3876207aa0a8e79c8451b6."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:clamav:clamav:0.99.3:*:*:*:*:*:*:*", "matchCriteriaId": "AE14FC74-CDE8-4D9B-BAF5-0BE844C9B950"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "16F59A04-14CF-49E2-9973-645477EA09DA"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:12.04:*:*:*:esm:*:*:*", "matchCriteriaId": "8D305F7A-D159-4716-AB26-5E38BB5CD991"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:lts:*:*:*", "matchCriteriaId": "B5A6F2F3-4894-4392-8296-3B8DD2679084"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:lts:*:*:*", "matchCriteriaId": "F7016A2A-8365-4F1A-89A2-7A19F2BCAE5B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:17.10:*:*:*:*:*:*:*", "matchCriteriaId": "9070C9D8-A14A-467F-8253-33B966C16886"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2017/09/29/4", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Mailing List", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/Cisco-Talos/clamav-devel/commit/d96a6b8bcc7439fa7e3876207aa0a8e79c8451b6", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://lists.debian.org/debian-lts-announce/2018/03/msg00011.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/201804-16", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3592-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3592-2/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/Cisco-Talos/clamav-devel/commit/d96a6b8bcc7439fa7e3876207aa0a8e79c8451b6"}}