{"buggy_code": ["/****************************************************************************\n    MP4 input module\n\n    Copyright (C) 2017 Krzysztof Nikiel\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n****************************************************************************/\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <string.h>\n#include <time.h>\n#include <limits.h>\n\n#include \"unicode_support.h\"\n#include \"mp4read.h\"\n\nenum ATOM_TYPE\n{\n    ATOM_STOP = 0 /* end of atoms */ ,\n    ATOM_NAME /* plain atom */ ,\n    ATOM_DESCENT,               /* starts group of children */\n    ATOM_ASCENT,                /* ends group */\n    ATOM_DATA,\n};\ntypedef struct\n{\n    uint16_t opcode;\n    void *data;\n} creator_t;\n\n\nmp4config_t mp4config = { 0 };\n\nstatic FILE *g_fin = NULL;\n\nstatic inline uint32_t bswap32(const uint32_t u32)\n{\n#ifndef WORDS_BIGENDIAN\n#if defined (__GNUC__) && ((__GNUC__ > 4) || ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 3)))\n    return __builtin_bswap32(u32);\n#elif defined (_MSC_VER)\n    return _byteswap_ulong(u32);\n#else\n    return (u32 << 24) | ((u32 << 8) & 0xFF0000) | ((u32 >> 8) & 0xFF00) | (u32 >> 24);\n#endif\n#else\n    return u32;\n#endif\n}\n\nstatic inline uint16_t bswap16(const uint16_t u16)\n{\n#ifndef WORDS_BIGENDIAN\n#if defined (__GNUC__) && ((__GNUC__ > 4) || ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 8)))\n    return __builtin_bswap16(u16);\n#elif defined (_MSC_VER)\n    return _byteswap_ushort(u16);\n#else\n    return (u16 << 8) | (u16 >> 8);\n#endif\n#else\n    return u16;\n#endif\n}\n\nenum {ERR_OK = 0, ERR_FAIL = -1, ERR_UNSUPPORTED = -2};\n\nstatic int datain(void *data, int size)\n{\n    if (fread(data, 1, size, g_fin) != size)\n        return ERR_FAIL;\n    return size;\n}\n\nstatic int stringin(char *txt, int sizemax)\n{\n    int size;\n    for (size = 0; size < sizemax; size++)\n    {\n        if (fread(txt + size, 1, 1, g_fin) != 1)\n            return ERR_FAIL;\n        if (!txt[size])\n            break;\n    }\n    txt[sizemax-1] = '\\0';\n\n    return size;\n}\n\nstatic uint32_t u32in(void)\n{\n    uint32_t u32;\n    datain(&u32, 4);\n    u32 = bswap32(u32);\n    return u32;\n}\n\nstatic uint16_t u16in(void)\n{\n    uint16_t u16;\n    datain(&u16, 2);\n    u16 = bswap16(u16);\n    return u16;\n}\n\nstatic int u8in(void)\n{\n    uint8_t u8;\n    datain(&u8, 1);\n    return u8;\n}\n\nstatic int ftypin(int size)\n{\n    enum {BUFSIZE = 40};\n    char buf[BUFSIZE];\n    uint32_t u32;\n\n    buf[4] = 0;\n    datain(buf, 4);\n    u32 = u32in();\n\n    if (mp4config.verbose.header)\n        fprintf(stderr, \"Brand:\\t\\t\\t%s(version %d)\\n\", buf, u32);\n\n    stringin(buf, BUFSIZE);\n\n    if (mp4config.verbose.header)\n        fprintf(stderr, \"Compatible brands:\\t%s\\n\", buf);\n\n    return size;\n}\n\nenum\n{ SECSINDAY = 24 * 60 * 60 };\nstatic char *mp4time(time_t t)\n{\n    int y;\n\n    // subtract some seconds from the start of 1904 to the start of 1970\n    for (y = 1904; y < 1970; y++)\n    {\n        t -= 365 * SECSINDAY;\n        if (!(y & 3))\n            t -= SECSINDAY;\n    }\n    return ctime(&t);\n}\n\nstatic int mdhdin(int size)\n{\n    // version/flags\n    u32in();\n    // Creation time\n    mp4config.ctime = u32in();\n    // Modification time\n    mp4config.mtime = u32in();\n    // Time scale\n    mp4config.samplerate = u32in();\n    // Duration\n    mp4config.samples = u32in();\n    // Language\n    u16in();\n    // pre_defined\n    u16in();\n\n    return size;\n};\n\nstatic int hdlr1in(int size)\n{\n    uint8_t buf[5];\n\n    buf[4] = 0;\n    // version/flags\n    u32in();\n    // pre_defined\n    u32in();\n    // Component subtype\n    datain(buf, 4);\n    if (mp4config.verbose.header)\n        fprintf(stderr, \"*track media type: '%s': \", buf);\n    if (memcmp(\"soun\", buf, 4))\n    {\n        if (mp4config.verbose.header)\n            fprintf(stderr, \"unsupported, skipping\\n\");\n        return ERR_UNSUPPORTED;\n    }\n    else\n    {\n        if (mp4config.verbose.header)\n            fprintf(stderr, \"OK\\n\");\n    }\n    // reserved\n    u32in();\n    u32in();\n    u32in();\n    // name\n    // null terminate\n    u8in();\n\n    return size;\n};\n\nstatic int stsdin(int size)\n{\n    // version/flags\n    u32in();\n    // Number of entries(one 'mp4a')\n    if (u32in() != 1) //fixme: error handling\n        return ERR_FAIL;\n\n    return size;\n};\n\nstatic int mp4ain(int size)\n{\n    // Reserved (6 bytes)\n    u32in();\n    u16in();\n    // Data reference index\n    u16in();\n    // Version\n    u16in();\n    // Revision level\n    u16in();\n    // Vendor\n    u32in();\n    // Number of channels\n    mp4config.channels = u16in();\n    // Sample size (bits)\n    mp4config.bits = u16in();\n    // Compression ID\n    u16in();\n    // Packet size\n    u16in();\n    // Sample rate (16.16)\n    // fractional framerate, probably not for audio\n    // rate integer part\n    u16in();\n    // rate reminder part\n    u16in();\n\n    return size;\n}\n\n\nstatic uint32_t getsize(void)\n{\n    int cnt;\n    uint32_t size = 0;\n    for (cnt = 0; cnt < 4; cnt++)\n    {\n        int tmp = u8in();\n\n        size <<= 7;\n        size |= (tmp & 0x7f);\n        if (!(tmp & 0x80))\n            break;\n    }\n    return size;\n}\n\nstatic int esdsin(int size)\n{\n    // descriptor tree:\n    // MP4ES_Descriptor\n    //   MP4DecoderConfigDescriptor\n    //      MP4DecSpecificInfoDescriptor\n    //   MP4SLConfigDescriptor\n    enum\n    { TAG_ES = 3, TAG_DC = 4, TAG_DSI = 5, TAG_SLC = 6 };\n\n    // version/flags\n    u32in();\n    if (u8in() != TAG_ES)\n        return ERR_FAIL;\n    getsize();\n    // ESID\n    u16in();\n    // flags(url(bit 6); ocr(5); streamPriority (0-4)):\n    u8in();\n\n    if (u8in() != TAG_DC)\n        return ERR_FAIL;\n    getsize();\n    if (u8in() != 0x40) /* not MPEG-4 audio */\n        return ERR_FAIL;\n    // flags\n    u8in();\n    // buffer size (24 bits)\n    mp4config.buffersize = u16in() << 8;\n    mp4config.buffersize |= u8in();\n    // bitrate\n    mp4config.bitratemax = u32in();\n    mp4config.bitrateavg = u32in();\n\n    if (u8in() != TAG_DSI)\n        return ERR_FAIL;\n    mp4config.asc.size = getsize();\n    if (mp4config.asc.size > sizeof(mp4config.asc.buf))\n        return ERR_FAIL;\n    // get AudioSpecificConfig\n    datain(mp4config.asc.buf, mp4config.asc.size);\n\n    if (u8in() != TAG_SLC)\n        return ERR_FAIL;\n    getsize();\n    // \"predefined\" (no idea)\n    u8in();\n\n    return size;\n}\n\nstatic int sttsin(int size)\n{\n    if (size < 16) //min stts size\n        return ERR_FAIL;\n\n    return size;\n}\n\nstatic int stszin(int size)\n{\n    int cnt;\n    uint32_t ofs;\n\n    // version/flags\n    u32in();\n    // Sample size\n    u32in();\n    // Number of entries\n    mp4config.frame.ents = u32in();\n    // fixme: check atom size\n    mp4config.frame.data = malloc(sizeof(*mp4config.frame.data)\n                                  * (mp4config.frame.ents + 1));\n\n    if (!mp4config.frame.data)\n        return ERR_FAIL;\n\n    ofs = 0;\n    mp4config.frame.data[0] = ofs;\n    for (cnt = 0; cnt < mp4config.frame.ents; cnt++)\n    {\n        uint32_t fsize = u32in();\n\n        ofs += fsize;\n        if (mp4config.frame.maxsize < fsize)\n            mp4config.frame.maxsize = fsize;\n\n        mp4config.frame.data[cnt + 1] = ofs;\n\n        if (ofs < mp4config.frame.data[cnt])\n            return ERR_FAIL;\n    }\n\n    return size;\n}\n\nstatic int stcoin(int size)\n{\n    // version/flags\n    u32in();\n    // Number of entries\n    if (u32in() < 1)\n        return ERR_FAIL;\n    // first chunk offset\n    mp4config.mdatofs = u32in();\n    // ignore the rest\n\n    return size;\n}\n\n#if 0\nstatic int tagtxt(char *tagname, const char *tagtxt)\n{\n    //int txtsize = strlen(tagtxt);\n    int size = 0;\n    //int datasize = txtsize + 16;\n\n#if 0\n    size += u32out(datasize + 8);\n    size += dataout(tagname, 4);\n    size += u32out(datasize);\n    size += dataout(\"data\", 4);\n    size += u32out(1);\n    size += u32out(0);\n    size += dataout(tagtxt, txtsize);\n#endif\n\n    return size;\n}\n\nstatic int tagu32(char *tagname, int n /*number of stored fields*/)\n{\n    //int numsize = n * 4;\n    int size = 0;\n    //int datasize = numsize + 16;\n\n#if 0\n    size += u32out(datasize + 8);\n    size += dataout(tagname, 4);\n    size += u32out(datasize);\n    size += dataout(\"data\", 4);\n    size += u32out(0);\n    size += u32out(0);\n#endif\n\n    return size;\n}\n#endif\n\nstatic int metain(int size)\n{\n    // version/flags\n    u32in();\n\n    return ERR_OK;\n};\n\nstatic int hdlr2in(int size)\n{\n    uint8_t buf[4];\n\n    // version/flags\n    u32in();\n    // Predefined\n    u32in();\n    // Handler type\n    datain(buf, 4);\n    if (memcmp(buf, \"mdir\", 4))\n        return ERR_FAIL;\n    datain(buf, 4);\n    if (memcmp(buf, \"appl\", 4))\n        return ERR_FAIL;\n    // Reserved\n    u32in();\n    u32in();\n    // null terminator\n    u8in();\n\n    return size;\n};\n\nstatic int ilstin(int size)\n{\n    enum {NUMSET = 1, GENRE, EXTAG};\n    int read = 0;\n\n    static struct {\n        char *name;\n        char *id;\n        int flag;\n    } tags[] = {\n        {\"Album       \", \"\\xa9\" \"alb\"},\n        {\"Album Artist\", \"aART\"},\n        {\"Artist      \", \"\\xa9\" \"ART\"},\n        {\"Comment     \", \"\\xa9\" \"cmt\"},\n        {\"Cover image \", \"covr\"},\n        {\"Compilation \", \"cpil\"},\n        {\"Copyright   \", \"cprt\"},\n        {\"Date        \", \"\\xa9\" \"day\"},\n        {\"Disc#       \", \"disk\", NUMSET},\n        {\"Genre       \", \"gnre\", GENRE},\n        {\"Grouping    \", \"\\xa9\" \"grp\"},\n        {\"Lyrics      \", \"\\xa9\" \"lyr\"},\n        {\"Title       \", \"\\xa9\" \"nam\"},\n        {\"Rating      \", \"rtng\"},\n        {\"BPM         \", \"tmpo\"},\n        {\"Encoder     \", \"\\xa9\" \"too\"},\n        {\"Track       \", \"trkn\", NUMSET},\n        {\"Composer    \", \"\\xa9\" \"wrt\"},\n        {0, \"----\", EXTAG},\n        {0},\n    };\n\n    static const char *genres[] = {\n        \"Blues\", \"Classic Rock\", \"Country\", \"Dance\",\n        \"Disco\", \"Funk\", \"Grunge\", \"Hip-Hop\",\n        \"Jazz\", \"Metal\", \"New Age\", \"Oldies\",\n        \"Other\", \"Pop\", \"R&B\", \"Rap\",\n        \"Reggae\", \"Rock\", \"Techno\", \"Industrial\",\n        \"Alternative\", \"Ska\", \"Death Metal\", \"Pranks\",\n        \"Soundtrack\", \"Euro-Techno\", \"Ambient\", \"Trip-Hop\",\n        \"Vocal\", \"Jazz+Funk\", \"Fusion\", \"Trance\",\n        \"Classical\", \"Instrumental\", \"Acid\", \"House\",\n        \"Game\", \"Sound Clip\", \"Gospel\", \"Noise\",\n        \"Alternative Rock\", \"Bass\", \"Soul\", \"Punk\",\n        \"Space\", \"Meditative\", \"Instrumental Pop\", \"Instrumental Rock\",\n        \"Ethnic\", \"Gothic\", \"Darkwave\", \"Techno-Industrial\",\n        \"Electronic\", \"Pop-Folk\", \"Eurodance\", \"Dream\",\n        \"Southern Rock\", \"Comedy\", \"Cult\", \"Gangsta\",\n        \"Top 40\", \"Christian Rap\", \"Pop/Funk\", \"Jungle\",\n        \"Native US\", \"Cabaret\", \"New Wave\", \"Psychadelic\",\n        \"Rave\", \"Showtunes\", \"Trailer\", \"Lo-Fi\",\n        \"Tribal\", \"Acid Punk\", \"Acid Jazz\", \"Polka\",\n        \"Retro\", \"Musical\", \"Rock & Roll\", \"Hard Rock\",\n        \"Folk\", \"Folk-Rock\", \"National Folk\", \"Swing\",\n        \"Fast Fusion\", \"Bebob\", \"Latin\", \"Revival\",\n        \"Celtic\", \"Bluegrass\", \"Avantgarde\", \"Gothic Rock\",\n        \"Progressive Rock\", \"Psychedelic Rock\", \"Symphonic Rock\", \"Slow Rock\",\n        \"Big Band\", \"Chorus\", \"Easy Listening\", \"Acoustic\",\n        \"Humour\", \"Speech\", \"Chanson\", \"Opera\",\n        \"Chamber Music\", \"Sonata\", \"Symphony\", \"Booty Bass\",\n        \"Primus\", \"Porn Groove\", \"Satire\", \"Slow Jam\",\n        \"Club\", \"Tango\", \"Samba\", \"Folklore\",\n        \"Ballad\", \"Power Ballad\", \"Rhythmic Soul\", \"Freestyle\",\n        \"Duet\", \"Punk Rock\", \"Drum Solo\", \"Acapella\",\n        \"Euro-House\", \"Dance Hall\", \"Goa\", \"Drum & Bass\",\n        \"Club - House\", \"Hardcore\", \"Terror\", \"Indie\",\n        \"BritPop\", \"Negerpunk\", \"Polsk Punk\", \"Beat\",\n        \"Christian Gangsta Rap\", \"Heavy Metal\", \"Black Metal\", \"Crossover\",\n        \"Contemporary Christian\", \"Christian Rock\", \"Merengue\", \"Salsa\",\n        \"Thrash Metal\", \"Anime\", \"JPop\", \"Synthpop\",\n        \"Unknown\",\n    };\n\n    fprintf(stderr, \"----------tag list-------------\\n\");\n    while(read < size)\n    {\n        int asize, dsize;\n        uint8_t id[5];\n        int cnt;\n        uint32_t type;\n\n        id[4] = 0;\n\n        asize = u32in();\n        read += asize;\n        asize -= 4;\n        if (datain(id, 4) < 4)\n            return ERR_FAIL;\n        asize -= 4;\n\n        for (cnt = 0; tags[cnt].id; cnt++)\n        {\n            if (!memcmp(id, tags[cnt].id, 4))\n                break;\n        }\n\n        if (tags[cnt].name)\n            fprintf(stderr, \"%s :   \", tags[cnt].name);\n        else\n        {\n            if (tags[cnt].flag != EXTAG)\n                fprintf(stderr, \"'%s'       :   \", id);\n        }\n\n        dsize = u32in();\n        asize -= 4;\n        if (datain(id, 4) < 4)\n            return ERR_FAIL;\n        asize -= 4;\n\n        if (tags[cnt].flag != EXTAG)\n        {\n            if (memcmp(id, \"data\", 4))\n                return ERR_FAIL;\n        }\n        else\n        {\n            int spc;\n\n            if (memcmp(id, \"mean\", 4))\n                goto skip;\n            dsize -= 8;\n            while (dsize > 0)\n            {\n                u8in();\n                asize--;\n                dsize--;\n            }\n            if (asize >= 8)\n            {\n                dsize = u32in() - 8;\n                asize -= 4;\n                if (datain(id, 4) < 4)\n                    return ERR_FAIL;\n                asize -= 4;\n                if (memcmp(id, \"name\", 4))\n                    goto skip;\n                u32in();\n                asize -= 4;\n                dsize -= 4;\n            }\n            spc = 13 - dsize;\n            if (spc < 0) spc = 0;\n            while (dsize > 0)\n            {\n                fprintf(stderr, \"%c\",u8in());\n                asize--;\n                dsize--;\n            }\n            while (spc--)\n                fprintf(stderr, \" \");\n            fprintf(stderr, \":   \");\n            if (asize >= 8)\n            {\n                dsize = u32in() - 8;\n                asize -= 4;\n                if (datain(id, 4) < 4)\n                    return ERR_FAIL;\n                asize -= 4;\n                if (memcmp(id, \"data\", 4))\n                    goto skip;\n                u32in();\n                asize -= 4;\n                dsize -= 4;\n            }\n            while (dsize > 0)\n            {\n                fprintf(stderr, \"%c\",u8in());\n                asize--;\n                dsize--;\n            }\n            fprintf(stderr, \"\\n\");\n\n            goto skip;\n        }\n        type = u32in();\n        asize -= 4;\n        u32in();\n        asize -= 4;\n\n        switch(type)\n        {\n        case 1:\n            while (asize > 0)\n            {\n                fprintf(stderr, \"%c\",u8in());\n                asize--;\n            }\n            break;\n        case 0:\n            switch(tags[cnt].flag)\n            {\n            case NUMSET:\n                u16in();\n                asize -= 2;\n\n                fprintf(stderr, \"%d\", u16in());\n                asize -= 2;\n                fprintf(stderr, \"/%d\", u16in());\n                asize -= 2;\n                break;\n            case GENRE:\n                {\n                    uint8_t gnum = u16in();\n                    asize -= 2;\n                    if (!gnum)\n                       goto skip;\n                    gnum--;\n                    if (gnum >= 147)\n                        gnum = 147;\n                    fprintf(stderr, \"%s\", genres[gnum]);\n                }\n                break;\n            default:\n                while(asize > 0)\n                {\n                    fprintf(stderr, \"%d/\", u16in());\n                    asize-=2;\n                }\n            }\n            break;\n        case 0x15:\n            //fprintf(stderr, \"(8bit data)\");\n            while(asize > 0)\n            {\n                fprintf(stderr, \"%d\", u8in());\n                asize--;\n                if (asize)\n                    fprintf(stderr, \"/\");\n            }\n            break;\n        case 0xd:\n            fprintf(stderr, \"(image data)\");\n            break;\n        default:\n            fprintf(stderr, \"(unknown data type)\");\n            break;\n        }\n        fprintf(stderr, \"\\n\");\n\n    skip:\n        // skip to the end of atom\n        while (asize > 0)\n        {\n            u8in();\n            asize--;\n        }\n    }\n    fprintf(stderr, \"-------------------------------\\n\");\n\n    return size;\n};\n\nstatic creator_t *g_atom = 0;\nstatic int parse(uint32_t *sizemax)\n{\n    long apos = 0;\n    long aposmax = ftell(g_fin) + *sizemax;\n    uint32_t size;\n\n    if (g_atom->opcode != ATOM_NAME)\n    {\n        fprintf(stderr, \"parse error: root is not a 'name' opcode\\n\");\n        return ERR_FAIL;\n    }\n    //fprintf(stderr, \"looking for '%s'\\n\", (char *)g_atom->data);\n\n    // search for atom in the file\n    while (1)\n    {\n        char name[4];\n        uint32_t tmp;\n\n        apos = ftell(g_fin);\n        if (apos >= (aposmax - 8))\n        {\n            fprintf(stderr, \"parse error: atom '%s' not found\\n\", (char *)g_atom->data);\n            return ERR_FAIL;\n        }\n        if ((tmp = u32in()) < 8)\n        {\n            fprintf(stderr, \"invalid atom size %x @%lx\\n\", tmp, ftell(g_fin));\n            return ERR_FAIL;\n        }\n\n        size = tmp;\n        if (datain(name, 4) != 4)\n        {\n            // EOF\n            fprintf(stderr, \"can't read atom name @%lx\\n\", ftell(g_fin));\n            return ERR_FAIL;\n        }\n\n        //fprintf(stderr, \"atom: '%c%c%c%c'(%x)\", name[0],name[1],name[2],name[3], size);\n\n        if (!memcmp(name, g_atom->data, 4))\n        {\n            //fprintf(stderr, \"OK\\n\");\n            break;\n        }\n        //fprintf(stderr, \"\\n\");\n\n        fseek(g_fin, apos + size, SEEK_SET);\n    }\n    *sizemax = size;\n    g_atom++;\n    if (g_atom->opcode == ATOM_DATA)\n    {\n        int err = ((int (*)(int)) g_atom->data)(size - 8);\n        if (err < ERR_OK)\n        {\n            fseek(g_fin, apos + size, SEEK_SET);\n            return err;\n        }\n        g_atom++;\n    }\n    if (g_atom->opcode == ATOM_DESCENT)\n    {\n        long apos = ftell(g_fin);;\n\n        //fprintf(stderr, \"descent\\n\");\n        g_atom++;\n        while (g_atom->opcode != ATOM_STOP)\n        {\n            uint32_t subsize = size - 8;\n            int ret;\n            if (g_atom->opcode == ATOM_ASCENT)\n            {\n                g_atom++;\n                break;\n            }\n            fseek(g_fin, apos, SEEK_SET);\n            if ((ret = parse(&subsize)) < 0)\n                return ret;\n        }\n        //fprintf(stderr, \"ascent\\n\");\n    }\n\n    fseek(g_fin, apos + size, SEEK_SET);\n\n    return ERR_OK;\n}\n\n\n\nstatic int moovin(int sizemax)\n{\n    long apos = ftell(g_fin);\n    uint32_t atomsize;\n    creator_t *old_atom = g_atom;\n    int err, ret = sizemax;\n\n    static creator_t mvhd[] = {\n        {ATOM_NAME, \"mvhd\"},\n        {0}\n    };\n    static creator_t trak[] = {\n        {ATOM_NAME, \"trak\"},\n        {ATOM_DESCENT},\n        {ATOM_NAME, \"tkhd\"},\n        {ATOM_NAME, \"mdia\"},\n        {ATOM_DESCENT},\n        {ATOM_NAME, \"mdhd\"},\n        {ATOM_DATA, mdhdin},\n        {ATOM_NAME, \"hdlr\"},\n        {ATOM_DATA, hdlr1in},\n        {ATOM_NAME, \"minf\"},\n        {ATOM_DESCENT},\n        {ATOM_NAME, \"smhd\"},\n        {ATOM_NAME, \"dinf\"},\n        {ATOM_NAME, \"stbl\"},\n        {ATOM_DESCENT},\n        {ATOM_NAME, \"stsd\"},\n        {ATOM_DATA, stsdin},\n        {ATOM_DESCENT},\n        {ATOM_NAME, \"mp4a\"},\n        {ATOM_DATA, mp4ain},\n        {ATOM_DESCENT},\n        {ATOM_NAME, \"esds\"},\n        {ATOM_DATA, esdsin},\n        {ATOM_ASCENT},\n        {ATOM_ASCENT},\n        {ATOM_NAME, \"stts\"},\n        {ATOM_DATA, sttsin},\n        {ATOM_NAME, \"stsc\"},\n        {ATOM_NAME, \"stsz\"},\n        {ATOM_DATA, stszin},\n        {ATOM_NAME, \"stco\"},\n        {ATOM_DATA, stcoin},\n        {0}\n    };\n\n    g_atom = mvhd;\n    atomsize = sizemax + apos - ftell(g_fin);\n    if (parse(&atomsize) < 0) {\n        g_atom = old_atom;\n        return ERR_FAIL;\n    }\n\n    fseek(g_fin, apos, SEEK_SET);\n\n    while (1)\n    {\n        //fprintf(stderr, \"TRAK\\n\");\n        g_atom = trak;\n        atomsize = sizemax + apos - ftell(g_fin);\n        if (atomsize < 8)\n            break;\n        //fprintf(stderr, \"PARSE(%x)\\n\", atomsize);\n        err = parse(&atomsize);\n        //fprintf(stderr, \"SIZE: %x/%x\\n\", atomsize, sizemax);\n        if (err >= 0)\n            break;\n        if (err != ERR_UNSUPPORTED) {\n            ret = err;\n            break;\n        }\n        //fprintf(stderr, \"UNSUPP\\n\");\n    }\n\n    g_atom = old_atom;\n    return ret;\n}\n\n\nstatic creator_t g_head[] = {\n    {ATOM_NAME, \"ftyp\"},\n    {ATOM_DATA, ftypin},\n    {0}\n};\n\nstatic creator_t g_moov[] = {\n    {ATOM_NAME, \"moov\"},\n    {ATOM_DATA, moovin},\n    //{ATOM_DESCENT},\n    //{ATOM_NAME, \"mvhd\"},\n    {0}\n};\n\nstatic creator_t g_meta1[] = {\n    {ATOM_NAME, \"moov\"},\n    {ATOM_DESCENT},\n    {ATOM_NAME, \"udta\"},\n    {ATOM_DESCENT},\n    {ATOM_NAME, \"meta\"},\n    {ATOM_DATA, metain},\n    {ATOM_DESCENT},\n    {ATOM_NAME, \"hdlr\"},\n    {ATOM_DATA, hdlr2in},\n    {ATOM_NAME, \"ilst\"},\n    {ATOM_DATA, ilstin},\n    {0}\n};\n\nstatic creator_t g_meta2[] = {\n    {ATOM_NAME, \"meta\"},\n    {ATOM_DATA, metain},\n    {ATOM_DESCENT},\n    {ATOM_NAME, \"hdlr\"},\n    {ATOM_DATA, hdlr2in},\n    {ATOM_NAME, \"ilst\"},\n    {ATOM_DATA, ilstin},\n    {0}\n};\n\n\nint mp4read_frame(void)\n{\n    if (mp4config.frame.current >= mp4config.frame.ents)\n        return ERR_FAIL;\n\n    mp4config.bitbuf.size = mp4config.frame.data[mp4config.frame.current + 1]\n        - mp4config.frame.data[mp4config.frame.current];\n\n    if (fread(mp4config.bitbuf.data, 1, mp4config.bitbuf.size, g_fin)\n        != mp4config.bitbuf.size)\n    {\n        fprintf(stderr, \"can't read frame data(frame %d@0x%x)\\n\",\n               mp4config.frame.current,\n               mp4config.frame.data[mp4config.frame.current]);\n\n        return ERR_FAIL;\n    }\n\n    mp4config.frame.current++;\n\n    return ERR_OK;\n}\n\nint mp4read_seek(int framenum)\n{\n    if (framenum > mp4config.frame.ents)\n        return ERR_FAIL;\n    if (fseek(g_fin, mp4config.mdatofs + mp4config.frame.data[framenum], SEEK_SET))\n        return ERR_FAIL;\n\n    mp4config.frame.current = framenum;\n\n    return ERR_OK;\n}\n\nstatic void mp4info(void)\n{\n    fprintf(stderr, \"Modification Time:\\t\\t%s\\n\", mp4time(mp4config.mtime));\n    fprintf(stderr, \"Samplerate:\\t\\t%d\\n\", mp4config.samplerate);\n    fprintf(stderr, \"Total samples:\\t\\t%d\\n\", mp4config.samples);\n    fprintf(stderr, \"Total channels:\\t\\t%d\\n\", mp4config.channels);\n    fprintf(stderr, \"Bits per sample:\\t%d\\n\", mp4config.bits);\n    fprintf(stderr, \"Buffer size:\\t\\t%d\\n\", mp4config.buffersize);\n    fprintf(stderr, \"Max bitrate:\\t\\t%d\\n\", mp4config.bitratemax);\n    fprintf(stderr, \"Average bitrate:\\t%d\\n\", mp4config.bitrateavg);\n    fprintf(stderr, \"Samples per frame:\\t%d\\n\", mp4config.framesamples);\n    fprintf(stderr, \"Frames:\\t\\t\\t%d\\n\", mp4config.frame.ents);\n    fprintf(stderr, \"ASC size:\\t\\t%d\\n\", mp4config.asc.size);\n    fprintf(stderr, \"Duration:\\t\\t%.1f sec\\n\", (float)mp4config.samples/mp4config.samplerate);\n    fprintf(stderr, \"Data offset/size:\\t%x/%x\\n\", mp4config.mdatofs, mp4config.mdatsize);\n}\n\nint mp4read_close(void)\n{\n#define FREE(x) if(x){free(x);x=0;}\n    FREE(mp4config.frame.data);\n    FREE(mp4config.bitbuf.data);\n\n    return ERR_OK;\n}\n\nint mp4read_open(char *name)\n{\n    uint32_t atomsize;\n    int ret;\n\n    mp4read_close();\n\n    g_fin = faad_fopen(name, \"rb\");\n    if (!g_fin)\n        return ERR_FAIL;\n\n    if (mp4config.verbose.header)\n        fprintf(stderr, \"**** MP4 header ****\\n\");\n    g_atom = g_head;\n    atomsize = INT_MAX;\n    if (parse(&atomsize) < 0)\n        goto err;\n    g_atom = g_moov;\n    atomsize = INT_MAX;\n    rewind(g_fin);\n    if ((ret = parse(&atomsize)) < 0)\n    {\n        fprintf(stderr, \"parse:%d\\n\", ret);\n        goto err;\n    }\n\n    // alloc frame buffer\n    mp4config.bitbuf.data = malloc(mp4config.frame.maxsize);\n\n    if (!mp4config.bitbuf.data)\n        goto err;\n\n    if (mp4config.verbose.header)\n    {\n        mp4info();\n        fprintf(stderr, \"********************\\n\");\n    }\n\n    if (mp4config.verbose.tags)\n    {\n        rewind(g_fin);\n        g_atom = g_meta1;\n        atomsize = INT_MAX;\n        ret = parse(&atomsize);\n        if (ret < 0)\n        {\n            rewind(g_fin);\n            g_atom = g_meta2;\n            atomsize = INT_MAX;\n            ret = parse(&atomsize);\n        }\n    }\n\n    return ERR_OK;\nerr:\n    mp4read_close();\n    return ERR_FAIL;\n}\n"], "fixing_code": ["/****************************************************************************\n    MP4 input module\n\n    Copyright (C) 2017 Krzysztof Nikiel\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n****************************************************************************/\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <string.h>\n#include <time.h>\n#include <limits.h>\n\n#include \"unicode_support.h\"\n#include \"mp4read.h\"\n\nenum ATOM_TYPE\n{\n    ATOM_STOP = 0 /* end of atoms */ ,\n    ATOM_NAME /* plain atom */ ,\n    ATOM_DESCENT,               /* starts group of children */\n    ATOM_ASCENT,                /* ends group */\n    ATOM_DATA,\n};\ntypedef struct\n{\n    uint16_t opcode;\n    void *data;\n} creator_t;\n\n\nmp4config_t mp4config = { 0 };\n\nstatic FILE *g_fin = NULL;\n\nstatic inline uint32_t bswap32(const uint32_t u32)\n{\n#ifndef WORDS_BIGENDIAN\n#if defined (__GNUC__) && ((__GNUC__ > 4) || ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 3)))\n    return __builtin_bswap32(u32);\n#elif defined (_MSC_VER)\n    return _byteswap_ulong(u32);\n#else\n    return (u32 << 24) | ((u32 << 8) & 0xFF0000) | ((u32 >> 8) & 0xFF00) | (u32 >> 24);\n#endif\n#else\n    return u32;\n#endif\n}\n\nstatic inline uint16_t bswap16(const uint16_t u16)\n{\n#ifndef WORDS_BIGENDIAN\n#if defined (__GNUC__) && ((__GNUC__ > 4) || ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 8)))\n    return __builtin_bswap16(u16);\n#elif defined (_MSC_VER)\n    return _byteswap_ushort(u16);\n#else\n    return (u16 << 8) | (u16 >> 8);\n#endif\n#else\n    return u16;\n#endif\n}\n\nenum {ERR_OK = 0, ERR_FAIL = -1, ERR_UNSUPPORTED = -2};\n\nstatic int datain(void *data, int size)\n{\n    if (fread(data, 1, size, g_fin) != size)\n        return ERR_FAIL;\n    return size;\n}\n\nstatic int stringin(char *txt, int sizemax)\n{\n    int size;\n    for (size = 0; size < sizemax; size++)\n    {\n        if (fread(txt + size, 1, 1, g_fin) != 1)\n            return ERR_FAIL;\n        if (!txt[size])\n            break;\n    }\n    txt[sizemax-1] = '\\0';\n\n    return size;\n}\n\nstatic uint32_t u32in(void)\n{\n    uint32_t u32;\n    datain(&u32, 4);\n    u32 = bswap32(u32);\n    return u32;\n}\n\nstatic uint16_t u16in(void)\n{\n    uint16_t u16;\n    datain(&u16, 2);\n    u16 = bswap16(u16);\n    return u16;\n}\n\nstatic int u8in(void)\n{\n    uint8_t u8;\n    datain(&u8, 1);\n    return u8;\n}\n\nstatic int ftypin(int size)\n{\n    enum {BUFSIZE = 40};\n    char buf[BUFSIZE];\n    uint32_t u32;\n\n    buf[4] = 0;\n    datain(buf, 4);\n    u32 = u32in();\n\n    if (mp4config.verbose.header)\n        fprintf(stderr, \"Brand:\\t\\t\\t%s(version %d)\\n\", buf, u32);\n\n    stringin(buf, BUFSIZE);\n\n    if (mp4config.verbose.header)\n        fprintf(stderr, \"Compatible brands:\\t%s\\n\", buf);\n\n    return size;\n}\n\nenum\n{ SECSINDAY = 24 * 60 * 60 };\nstatic char *mp4time(time_t t)\n{\n    int y;\n\n    // subtract some seconds from the start of 1904 to the start of 1970\n    for (y = 1904; y < 1970; y++)\n    {\n        t -= 365 * SECSINDAY;\n        if (!(y & 3))\n            t -= SECSINDAY;\n    }\n    return ctime(&t);\n}\n\nstatic int mdhdin(int size)\n{\n    // version/flags\n    u32in();\n    // Creation time\n    mp4config.ctime = u32in();\n    // Modification time\n    mp4config.mtime = u32in();\n    // Time scale\n    mp4config.samplerate = u32in();\n    // Duration\n    mp4config.samples = u32in();\n    // Language\n    u16in();\n    // pre_defined\n    u16in();\n\n    return size;\n};\n\nstatic int hdlr1in(int size)\n{\n    uint8_t buf[5];\n\n    buf[4] = 0;\n    // version/flags\n    u32in();\n    // pre_defined\n    u32in();\n    // Component subtype\n    datain(buf, 4);\n    if (mp4config.verbose.header)\n        fprintf(stderr, \"*track media type: '%s': \", buf);\n    if (memcmp(\"soun\", buf, 4))\n    {\n        if (mp4config.verbose.header)\n            fprintf(stderr, \"unsupported, skipping\\n\");\n        return ERR_UNSUPPORTED;\n    }\n    else\n    {\n        if (mp4config.verbose.header)\n            fprintf(stderr, \"OK\\n\");\n    }\n    // reserved\n    u32in();\n    u32in();\n    u32in();\n    // name\n    // null terminate\n    u8in();\n\n    return size;\n};\n\nstatic int stsdin(int size)\n{\n    // version/flags\n    u32in();\n    // Number of entries(one 'mp4a')\n    if (u32in() != 1) //fixme: error handling\n        return ERR_FAIL;\n\n    return size;\n};\n\nstatic int mp4ain(int size)\n{\n    // Reserved (6 bytes)\n    u32in();\n    u16in();\n    // Data reference index\n    u16in();\n    // Version\n    u16in();\n    // Revision level\n    u16in();\n    // Vendor\n    u32in();\n    // Number of channels\n    mp4config.channels = u16in();\n    // Sample size (bits)\n    mp4config.bits = u16in();\n    // Compression ID\n    u16in();\n    // Packet size\n    u16in();\n    // Sample rate (16.16)\n    // fractional framerate, probably not for audio\n    // rate integer part\n    u16in();\n    // rate reminder part\n    u16in();\n\n    return size;\n}\n\n\nstatic uint32_t getsize(void)\n{\n    int cnt;\n    uint32_t size = 0;\n    for (cnt = 0; cnt < 4; cnt++)\n    {\n        int tmp = u8in();\n\n        size <<= 7;\n        size |= (tmp & 0x7f);\n        if (!(tmp & 0x80))\n            break;\n    }\n    return size;\n}\n\nstatic int esdsin(int size)\n{\n    // descriptor tree:\n    // MP4ES_Descriptor\n    //   MP4DecoderConfigDescriptor\n    //      MP4DecSpecificInfoDescriptor\n    //   MP4SLConfigDescriptor\n    enum\n    { TAG_ES = 3, TAG_DC = 4, TAG_DSI = 5, TAG_SLC = 6 };\n\n    // version/flags\n    u32in();\n    if (u8in() != TAG_ES)\n        return ERR_FAIL;\n    getsize();\n    // ESID\n    u16in();\n    // flags(url(bit 6); ocr(5); streamPriority (0-4)):\n    u8in();\n\n    if (u8in() != TAG_DC)\n        return ERR_FAIL;\n    getsize();\n    if (u8in() != 0x40) /* not MPEG-4 audio */\n        return ERR_FAIL;\n    // flags\n    u8in();\n    // buffer size (24 bits)\n    mp4config.buffersize = u16in() << 8;\n    mp4config.buffersize |= u8in();\n    // bitrate\n    mp4config.bitratemax = u32in();\n    mp4config.bitrateavg = u32in();\n\n    if (u8in() != TAG_DSI)\n        return ERR_FAIL;\n    mp4config.asc.size = getsize();\n    if (mp4config.asc.size > sizeof(mp4config.asc.buf))\n        return ERR_FAIL;\n    // get AudioSpecificConfig\n    datain(mp4config.asc.buf, mp4config.asc.size);\n\n    if (u8in() != TAG_SLC)\n        return ERR_FAIL;\n    getsize();\n    // \"predefined\" (no idea)\n    u8in();\n\n    return size;\n}\n\nstatic int sttsin(int size)\n{\n    if (size < 16) //min stts size\n        return ERR_FAIL;\n\n    return size;\n}\n\nstatic int stszin(int size)\n{\n    int cnt;\n    uint32_t ofs;\n\n    // version/flags\n    u32in();\n    // Sample size\n    u32in();\n    // Number of entries\n    mp4config.frame.ents = u32in();\n\n    if (!(mp4config.frame.ents + 1))\n        return ERR_FAIL;\n\n    mp4config.frame.data = malloc(sizeof(*mp4config.frame.data)\n                                  * (mp4config.frame.ents + 1));\n\n    if (!mp4config.frame.data)\n        return ERR_FAIL;\n\n    ofs = 0;\n    mp4config.frame.data[0] = ofs;\n    for (cnt = 0; cnt < mp4config.frame.ents; cnt++)\n    {\n        uint32_t fsize = u32in();\n\n        ofs += fsize;\n        if (mp4config.frame.maxsize < fsize)\n            mp4config.frame.maxsize = fsize;\n\n        mp4config.frame.data[cnt + 1] = ofs;\n\n        if (ofs < mp4config.frame.data[cnt])\n            return ERR_FAIL;\n    }\n\n    return size;\n}\n\nstatic int stcoin(int size)\n{\n    // version/flags\n    u32in();\n    // Number of entries\n    if (u32in() < 1)\n        return ERR_FAIL;\n    // first chunk offset\n    mp4config.mdatofs = u32in();\n    // ignore the rest\n\n    return size;\n}\n\n#if 0\nstatic int tagtxt(char *tagname, const char *tagtxt)\n{\n    //int txtsize = strlen(tagtxt);\n    int size = 0;\n    //int datasize = txtsize + 16;\n\n#if 0\n    size += u32out(datasize + 8);\n    size += dataout(tagname, 4);\n    size += u32out(datasize);\n    size += dataout(\"data\", 4);\n    size += u32out(1);\n    size += u32out(0);\n    size += dataout(tagtxt, txtsize);\n#endif\n\n    return size;\n}\n\nstatic int tagu32(char *tagname, int n /*number of stored fields*/)\n{\n    //int numsize = n * 4;\n    int size = 0;\n    //int datasize = numsize + 16;\n\n#if 0\n    size += u32out(datasize + 8);\n    size += dataout(tagname, 4);\n    size += u32out(datasize);\n    size += dataout(\"data\", 4);\n    size += u32out(0);\n    size += u32out(0);\n#endif\n\n    return size;\n}\n#endif\n\nstatic int metain(int size)\n{\n    // version/flags\n    u32in();\n\n    return ERR_OK;\n};\n\nstatic int hdlr2in(int size)\n{\n    uint8_t buf[4];\n\n    // version/flags\n    u32in();\n    // Predefined\n    u32in();\n    // Handler type\n    datain(buf, 4);\n    if (memcmp(buf, \"mdir\", 4))\n        return ERR_FAIL;\n    datain(buf, 4);\n    if (memcmp(buf, \"appl\", 4))\n        return ERR_FAIL;\n    // Reserved\n    u32in();\n    u32in();\n    // null terminator\n    u8in();\n\n    return size;\n};\n\nstatic int ilstin(int size)\n{\n    enum {NUMSET = 1, GENRE, EXTAG};\n    int read = 0;\n\n    static struct {\n        char *name;\n        char *id;\n        int flag;\n    } tags[] = {\n        {\"Album       \", \"\\xa9\" \"alb\"},\n        {\"Album Artist\", \"aART\"},\n        {\"Artist      \", \"\\xa9\" \"ART\"},\n        {\"Comment     \", \"\\xa9\" \"cmt\"},\n        {\"Cover image \", \"covr\"},\n        {\"Compilation \", \"cpil\"},\n        {\"Copyright   \", \"cprt\"},\n        {\"Date        \", \"\\xa9\" \"day\"},\n        {\"Disc#       \", \"disk\", NUMSET},\n        {\"Genre       \", \"gnre\", GENRE},\n        {\"Grouping    \", \"\\xa9\" \"grp\"},\n        {\"Lyrics      \", \"\\xa9\" \"lyr\"},\n        {\"Title       \", \"\\xa9\" \"nam\"},\n        {\"Rating      \", \"rtng\"},\n        {\"BPM         \", \"tmpo\"},\n        {\"Encoder     \", \"\\xa9\" \"too\"},\n        {\"Track       \", \"trkn\", NUMSET},\n        {\"Composer    \", \"\\xa9\" \"wrt\"},\n        {0, \"----\", EXTAG},\n        {0},\n    };\n\n    static const char *genres[] = {\n        \"Blues\", \"Classic Rock\", \"Country\", \"Dance\",\n        \"Disco\", \"Funk\", \"Grunge\", \"Hip-Hop\",\n        \"Jazz\", \"Metal\", \"New Age\", \"Oldies\",\n        \"Other\", \"Pop\", \"R&B\", \"Rap\",\n        \"Reggae\", \"Rock\", \"Techno\", \"Industrial\",\n        \"Alternative\", \"Ska\", \"Death Metal\", \"Pranks\",\n        \"Soundtrack\", \"Euro-Techno\", \"Ambient\", \"Trip-Hop\",\n        \"Vocal\", \"Jazz+Funk\", \"Fusion\", \"Trance\",\n        \"Classical\", \"Instrumental\", \"Acid\", \"House\",\n        \"Game\", \"Sound Clip\", \"Gospel\", \"Noise\",\n        \"Alternative Rock\", \"Bass\", \"Soul\", \"Punk\",\n        \"Space\", \"Meditative\", \"Instrumental Pop\", \"Instrumental Rock\",\n        \"Ethnic\", \"Gothic\", \"Darkwave\", \"Techno-Industrial\",\n        \"Electronic\", \"Pop-Folk\", \"Eurodance\", \"Dream\",\n        \"Southern Rock\", \"Comedy\", \"Cult\", \"Gangsta\",\n        \"Top 40\", \"Christian Rap\", \"Pop/Funk\", \"Jungle\",\n        \"Native US\", \"Cabaret\", \"New Wave\", \"Psychadelic\",\n        \"Rave\", \"Showtunes\", \"Trailer\", \"Lo-Fi\",\n        \"Tribal\", \"Acid Punk\", \"Acid Jazz\", \"Polka\",\n        \"Retro\", \"Musical\", \"Rock & Roll\", \"Hard Rock\",\n        \"Folk\", \"Folk-Rock\", \"National Folk\", \"Swing\",\n        \"Fast Fusion\", \"Bebob\", \"Latin\", \"Revival\",\n        \"Celtic\", \"Bluegrass\", \"Avantgarde\", \"Gothic Rock\",\n        \"Progressive Rock\", \"Psychedelic Rock\", \"Symphonic Rock\", \"Slow Rock\",\n        \"Big Band\", \"Chorus\", \"Easy Listening\", \"Acoustic\",\n        \"Humour\", \"Speech\", \"Chanson\", \"Opera\",\n        \"Chamber Music\", \"Sonata\", \"Symphony\", \"Booty Bass\",\n        \"Primus\", \"Porn Groove\", \"Satire\", \"Slow Jam\",\n        \"Club\", \"Tango\", \"Samba\", \"Folklore\",\n        \"Ballad\", \"Power Ballad\", \"Rhythmic Soul\", \"Freestyle\",\n        \"Duet\", \"Punk Rock\", \"Drum Solo\", \"Acapella\",\n        \"Euro-House\", \"Dance Hall\", \"Goa\", \"Drum & Bass\",\n        \"Club - House\", \"Hardcore\", \"Terror\", \"Indie\",\n        \"BritPop\", \"Negerpunk\", \"Polsk Punk\", \"Beat\",\n        \"Christian Gangsta Rap\", \"Heavy Metal\", \"Black Metal\", \"Crossover\",\n        \"Contemporary Christian\", \"Christian Rock\", \"Merengue\", \"Salsa\",\n        \"Thrash Metal\", \"Anime\", \"JPop\", \"Synthpop\",\n        \"Unknown\",\n    };\n\n    fprintf(stderr, \"----------tag list-------------\\n\");\n    while(read < size)\n    {\n        int asize, dsize;\n        uint8_t id[5];\n        int cnt;\n        uint32_t type;\n\n        id[4] = 0;\n\n        asize = u32in();\n        read += asize;\n        asize -= 4;\n        if (datain(id, 4) < 4)\n            return ERR_FAIL;\n        asize -= 4;\n\n        for (cnt = 0; tags[cnt].id; cnt++)\n        {\n            if (!memcmp(id, tags[cnt].id, 4))\n                break;\n        }\n\n        if (tags[cnt].name)\n            fprintf(stderr, \"%s :   \", tags[cnt].name);\n        else\n        {\n            if (tags[cnt].flag != EXTAG)\n                fprintf(stderr, \"'%s'       :   \", id);\n        }\n\n        dsize = u32in();\n        asize -= 4;\n        if (datain(id, 4) < 4)\n            return ERR_FAIL;\n        asize -= 4;\n\n        if (tags[cnt].flag != EXTAG)\n        {\n            if (memcmp(id, \"data\", 4))\n                return ERR_FAIL;\n        }\n        else\n        {\n            int spc;\n\n            if (memcmp(id, \"mean\", 4))\n                goto skip;\n            dsize -= 8;\n            while (dsize > 0)\n            {\n                u8in();\n                asize--;\n                dsize--;\n            }\n            if (asize >= 8)\n            {\n                dsize = u32in() - 8;\n                asize -= 4;\n                if (datain(id, 4) < 4)\n                    return ERR_FAIL;\n                asize -= 4;\n                if (memcmp(id, \"name\", 4))\n                    goto skip;\n                u32in();\n                asize -= 4;\n                dsize -= 4;\n            }\n            spc = 13 - dsize;\n            if (spc < 0) spc = 0;\n            while (dsize > 0)\n            {\n                fprintf(stderr, \"%c\",u8in());\n                asize--;\n                dsize--;\n            }\n            while (spc--)\n                fprintf(stderr, \" \");\n            fprintf(stderr, \":   \");\n            if (asize >= 8)\n            {\n                dsize = u32in() - 8;\n                asize -= 4;\n                if (datain(id, 4) < 4)\n                    return ERR_FAIL;\n                asize -= 4;\n                if (memcmp(id, \"data\", 4))\n                    goto skip;\n                u32in();\n                asize -= 4;\n                dsize -= 4;\n            }\n            while (dsize > 0)\n            {\n                fprintf(stderr, \"%c\",u8in());\n                asize--;\n                dsize--;\n            }\n            fprintf(stderr, \"\\n\");\n\n            goto skip;\n        }\n        type = u32in();\n        asize -= 4;\n        u32in();\n        asize -= 4;\n\n        switch(type)\n        {\n        case 1:\n            while (asize > 0)\n            {\n                fprintf(stderr, \"%c\",u8in());\n                asize--;\n            }\n            break;\n        case 0:\n            switch(tags[cnt].flag)\n            {\n            case NUMSET:\n                u16in();\n                asize -= 2;\n\n                fprintf(stderr, \"%d\", u16in());\n                asize -= 2;\n                fprintf(stderr, \"/%d\", u16in());\n                asize -= 2;\n                break;\n            case GENRE:\n                {\n                    uint8_t gnum = u16in();\n                    asize -= 2;\n                    if (!gnum)\n                       goto skip;\n                    gnum--;\n                    if (gnum >= 147)\n                        gnum = 147;\n                    fprintf(stderr, \"%s\", genres[gnum]);\n                }\n                break;\n            default:\n                while(asize > 0)\n                {\n                    fprintf(stderr, \"%d/\", u16in());\n                    asize-=2;\n                }\n            }\n            break;\n        case 0x15:\n            //fprintf(stderr, \"(8bit data)\");\n            while(asize > 0)\n            {\n                fprintf(stderr, \"%d\", u8in());\n                asize--;\n                if (asize)\n                    fprintf(stderr, \"/\");\n            }\n            break;\n        case 0xd:\n            fprintf(stderr, \"(image data)\");\n            break;\n        default:\n            fprintf(stderr, \"(unknown data type)\");\n            break;\n        }\n        fprintf(stderr, \"\\n\");\n\n    skip:\n        // skip to the end of atom\n        while (asize > 0)\n        {\n            u8in();\n            asize--;\n        }\n    }\n    fprintf(stderr, \"-------------------------------\\n\");\n\n    return size;\n};\n\nstatic creator_t *g_atom = 0;\nstatic int parse(uint32_t *sizemax)\n{\n    long apos = 0;\n    long aposmax = ftell(g_fin) + *sizemax;\n    uint32_t size;\n\n    if (g_atom->opcode != ATOM_NAME)\n    {\n        fprintf(stderr, \"parse error: root is not a 'name' opcode\\n\");\n        return ERR_FAIL;\n    }\n    //fprintf(stderr, \"looking for '%s'\\n\", (char *)g_atom->data);\n\n    // search for atom in the file\n    while (1)\n    {\n        char name[4];\n        uint32_t tmp;\n\n        apos = ftell(g_fin);\n        if (apos >= (aposmax - 8))\n        {\n            fprintf(stderr, \"parse error: atom '%s' not found\\n\", (char *)g_atom->data);\n            return ERR_FAIL;\n        }\n        if ((tmp = u32in()) < 8)\n        {\n            fprintf(stderr, \"invalid atom size %x @%lx\\n\", tmp, ftell(g_fin));\n            return ERR_FAIL;\n        }\n\n        size = tmp;\n        if (datain(name, 4) != 4)\n        {\n            // EOF\n            fprintf(stderr, \"can't read atom name @%lx\\n\", ftell(g_fin));\n            return ERR_FAIL;\n        }\n\n        //fprintf(stderr, \"atom: '%c%c%c%c'(%x)\", name[0],name[1],name[2],name[3], size);\n\n        if (!memcmp(name, g_atom->data, 4))\n        {\n            //fprintf(stderr, \"OK\\n\");\n            break;\n        }\n        //fprintf(stderr, \"\\n\");\n\n        fseek(g_fin, apos + size, SEEK_SET);\n    }\n    *sizemax = size;\n    g_atom++;\n    if (g_atom->opcode == ATOM_DATA)\n    {\n        int err = ((int (*)(int)) g_atom->data)(size - 8);\n        if (err < ERR_OK)\n        {\n            fseek(g_fin, apos + size, SEEK_SET);\n            return err;\n        }\n        g_atom++;\n    }\n    if (g_atom->opcode == ATOM_DESCENT)\n    {\n        long apos = ftell(g_fin);;\n\n        //fprintf(stderr, \"descent\\n\");\n        g_atom++;\n        while (g_atom->opcode != ATOM_STOP)\n        {\n            uint32_t subsize = size - 8;\n            int ret;\n            if (g_atom->opcode == ATOM_ASCENT)\n            {\n                g_atom++;\n                break;\n            }\n            fseek(g_fin, apos, SEEK_SET);\n            if ((ret = parse(&subsize)) < 0)\n                return ret;\n        }\n        //fprintf(stderr, \"ascent\\n\");\n    }\n\n    fseek(g_fin, apos + size, SEEK_SET);\n\n    return ERR_OK;\n}\n\n\n\nstatic int moovin(int sizemax)\n{\n    long apos = ftell(g_fin);\n    uint32_t atomsize;\n    creator_t *old_atom = g_atom;\n    int err, ret = sizemax;\n\n    static creator_t mvhd[] = {\n        {ATOM_NAME, \"mvhd\"},\n        {0}\n    };\n    static creator_t trak[] = {\n        {ATOM_NAME, \"trak\"},\n        {ATOM_DESCENT},\n        {ATOM_NAME, \"tkhd\"},\n        {ATOM_NAME, \"mdia\"},\n        {ATOM_DESCENT},\n        {ATOM_NAME, \"mdhd\"},\n        {ATOM_DATA, mdhdin},\n        {ATOM_NAME, \"hdlr\"},\n        {ATOM_DATA, hdlr1in},\n        {ATOM_NAME, \"minf\"},\n        {ATOM_DESCENT},\n        {ATOM_NAME, \"smhd\"},\n        {ATOM_NAME, \"dinf\"},\n        {ATOM_NAME, \"stbl\"},\n        {ATOM_DESCENT},\n        {ATOM_NAME, \"stsd\"},\n        {ATOM_DATA, stsdin},\n        {ATOM_DESCENT},\n        {ATOM_NAME, \"mp4a\"},\n        {ATOM_DATA, mp4ain},\n        {ATOM_DESCENT},\n        {ATOM_NAME, \"esds\"},\n        {ATOM_DATA, esdsin},\n        {ATOM_ASCENT},\n        {ATOM_ASCENT},\n        {ATOM_NAME, \"stts\"},\n        {ATOM_DATA, sttsin},\n        {ATOM_NAME, \"stsc\"},\n        {ATOM_NAME, \"stsz\"},\n        {ATOM_DATA, stszin},\n        {ATOM_NAME, \"stco\"},\n        {ATOM_DATA, stcoin},\n        {0}\n    };\n\n    g_atom = mvhd;\n    atomsize = sizemax + apos - ftell(g_fin);\n    if (parse(&atomsize) < 0) {\n        g_atom = old_atom;\n        return ERR_FAIL;\n    }\n\n    fseek(g_fin, apos, SEEK_SET);\n\n    while (1)\n    {\n        //fprintf(stderr, \"TRAK\\n\");\n        g_atom = trak;\n        atomsize = sizemax + apos - ftell(g_fin);\n        if (atomsize < 8)\n            break;\n        //fprintf(stderr, \"PARSE(%x)\\n\", atomsize);\n        err = parse(&atomsize);\n        //fprintf(stderr, \"SIZE: %x/%x\\n\", atomsize, sizemax);\n        if (err >= 0)\n            break;\n        if (err != ERR_UNSUPPORTED) {\n            ret = err;\n            break;\n        }\n        //fprintf(stderr, \"UNSUPP\\n\");\n    }\n\n    g_atom = old_atom;\n    return ret;\n}\n\n\nstatic creator_t g_head[] = {\n    {ATOM_NAME, \"ftyp\"},\n    {ATOM_DATA, ftypin},\n    {0}\n};\n\nstatic creator_t g_moov[] = {\n    {ATOM_NAME, \"moov\"},\n    {ATOM_DATA, moovin},\n    //{ATOM_DESCENT},\n    //{ATOM_NAME, \"mvhd\"},\n    {0}\n};\n\nstatic creator_t g_meta1[] = {\n    {ATOM_NAME, \"moov\"},\n    {ATOM_DESCENT},\n    {ATOM_NAME, \"udta\"},\n    {ATOM_DESCENT},\n    {ATOM_NAME, \"meta\"},\n    {ATOM_DATA, metain},\n    {ATOM_DESCENT},\n    {ATOM_NAME, \"hdlr\"},\n    {ATOM_DATA, hdlr2in},\n    {ATOM_NAME, \"ilst\"},\n    {ATOM_DATA, ilstin},\n    {0}\n};\n\nstatic creator_t g_meta2[] = {\n    {ATOM_NAME, \"meta\"},\n    {ATOM_DATA, metain},\n    {ATOM_DESCENT},\n    {ATOM_NAME, \"hdlr\"},\n    {ATOM_DATA, hdlr2in},\n    {ATOM_NAME, \"ilst\"},\n    {ATOM_DATA, ilstin},\n    {0}\n};\n\n\nint mp4read_frame(void)\n{\n    if (mp4config.frame.current >= mp4config.frame.ents)\n        return ERR_FAIL;\n\n    mp4config.bitbuf.size = mp4config.frame.data[mp4config.frame.current + 1]\n        - mp4config.frame.data[mp4config.frame.current];\n\n    if (fread(mp4config.bitbuf.data, 1, mp4config.bitbuf.size, g_fin)\n        != mp4config.bitbuf.size)\n    {\n        fprintf(stderr, \"can't read frame data(frame %d@0x%x)\\n\",\n               mp4config.frame.current,\n               mp4config.frame.data[mp4config.frame.current]);\n\n        return ERR_FAIL;\n    }\n\n    mp4config.frame.current++;\n\n    return ERR_OK;\n}\n\nint mp4read_seek(int framenum)\n{\n    if (framenum > mp4config.frame.ents)\n        return ERR_FAIL;\n    if (fseek(g_fin, mp4config.mdatofs + mp4config.frame.data[framenum], SEEK_SET))\n        return ERR_FAIL;\n\n    mp4config.frame.current = framenum;\n\n    return ERR_OK;\n}\n\nstatic void mp4info(void)\n{\n    fprintf(stderr, \"Modification Time:\\t\\t%s\\n\", mp4time(mp4config.mtime));\n    fprintf(stderr, \"Samplerate:\\t\\t%d\\n\", mp4config.samplerate);\n    fprintf(stderr, \"Total samples:\\t\\t%d\\n\", mp4config.samples);\n    fprintf(stderr, \"Total channels:\\t\\t%d\\n\", mp4config.channels);\n    fprintf(stderr, \"Bits per sample:\\t%d\\n\", mp4config.bits);\n    fprintf(stderr, \"Buffer size:\\t\\t%d\\n\", mp4config.buffersize);\n    fprintf(stderr, \"Max bitrate:\\t\\t%d\\n\", mp4config.bitratemax);\n    fprintf(stderr, \"Average bitrate:\\t%d\\n\", mp4config.bitrateavg);\n    fprintf(stderr, \"Samples per frame:\\t%d\\n\", mp4config.framesamples);\n    fprintf(stderr, \"Frames:\\t\\t\\t%d\\n\", mp4config.frame.ents);\n    fprintf(stderr, \"ASC size:\\t\\t%d\\n\", mp4config.asc.size);\n    fprintf(stderr, \"Duration:\\t\\t%.1f sec\\n\", (float)mp4config.samples/mp4config.samplerate);\n    fprintf(stderr, \"Data offset/size:\\t%x/%x\\n\", mp4config.mdatofs, mp4config.mdatsize);\n}\n\nint mp4read_close(void)\n{\n#define FREE(x) if(x){free(x);x=0;}\n    FREE(mp4config.frame.data);\n    FREE(mp4config.bitbuf.data);\n\n    return ERR_OK;\n}\n\nint mp4read_open(char *name)\n{\n    uint32_t atomsize;\n    int ret;\n\n    mp4read_close();\n\n    g_fin = faad_fopen(name, \"rb\");\n    if (!g_fin)\n        return ERR_FAIL;\n\n    if (mp4config.verbose.header)\n        fprintf(stderr, \"**** MP4 header ****\\n\");\n    g_atom = g_head;\n    atomsize = INT_MAX;\n    if (parse(&atomsize) < 0)\n        goto err;\n    g_atom = g_moov;\n    atomsize = INT_MAX;\n    rewind(g_fin);\n    if ((ret = parse(&atomsize)) < 0)\n    {\n        fprintf(stderr, \"parse:%d\\n\", ret);\n        goto err;\n    }\n\n    // alloc frame buffer\n    mp4config.bitbuf.data = malloc(mp4config.frame.maxsize);\n\n    if (!mp4config.bitbuf.data)\n        goto err;\n\n    if (mp4config.verbose.header)\n    {\n        mp4info();\n        fprintf(stderr, \"********************\\n\");\n    }\n\n    if (mp4config.verbose.tags)\n    {\n        rewind(g_fin);\n        g_atom = g_meta1;\n        atomsize = INT_MAX;\n        ret = parse(&atomsize);\n        if (ret < 0)\n        {\n            rewind(g_fin);\n            g_atom = g_meta2;\n            atomsize = INT_MAX;\n            ret = parse(&atomsize);\n        }\n    }\n\n    return ERR_OK;\nerr:\n    mp4read_close();\n    return ERR_FAIL;\n}\n"], "filenames": ["frontend/mp4read.c"], "buggy_code_start_loc": [347], "buggy_code_end_loc": [348], "fixing_code_start_loc": [347], "fixing_code_end_loc": [351], "type": "CWE-787", "message": "An issue was discovered in faad2 before 2.10.0. A heap-buffer-overflow exists in the function stszin located in mp4read.c. It allows an attacker to cause Code Execution.", "other": {"cve": {"id": "CVE-2021-32272", "sourceIdentifier": "cve@mitre.org", "published": "2021-09-20T16:15:10.143", "lastModified": "2022-04-22T16:20:58.953", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in faad2 before 2.10.0. A heap-buffer-overflow exists in the function stszin located in mp4read.c. It allows an attacker to cause Code Execution."}, {"lang": "es", "value": "Se ha detectado un problema en faad2 anterior a la versi\u00f3n 2.10.0. Se presenta un desbordamiento del b\u00fafer de la pila en la funci\u00f3n stszin ubicada en el archivo mp4read.c. Permite a un atacante causar una Ejecuci\u00f3n de C\u00f3digo"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:faad2_project:faad2:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.10.0", "matchCriteriaId": "AF3BA5A2-CCE7-471A-B083-FD9557B427A9"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}], "references": [{"url": "https://github.com/knik0/faad2/commit/1b71a6ba963d131375f5e489b3b25e36f19f3f24", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/knik0/faad2/issues/57", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Third Party Advisory"]}, {"url": "https://www.debian.org/security/2022/dsa-5109", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/knik0/faad2/commit/1b71a6ba963d131375f5e489b3b25e36f19f3f24"}}