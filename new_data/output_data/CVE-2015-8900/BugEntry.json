{"buggy_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                            H   H  DDDD   RRRR                               %\n%                            H   H  D   D  R   R                              %\n%                            HHHHH  D   D  RRRR                               %\n%                            H   H  D   D  R R                                %\n%                            H   H  DDDD   R  R                               %\n%                                                                             %\n%                                                                             %\n%                   Read/Write Radiance RGBE Image Format                     %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                                 July 1992                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2015 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    http://www.imagemagick.org/script/license.php                            %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/colorspace.h\"\n#include \"MagickCore/colorspace-private.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/property.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/static.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/string-private.h\"\n#include \"MagickCore/module.h\"\n\f\n/*\n  Forward declarations.\n*/\nstatic MagickBooleanType\n  WriteHDRImage(const ImageInfo *,Image *,ExceptionInfo *);\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I s H D R                                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsHDR() returns MagickTrue if the image format type, identified by the\n%  magick string, is Radiance RGBE image format.\n%\n%  The format of the IsHDR method is:\n%\n%      MagickBooleanType IsHDR(const unsigned char *magick,\n%        const size_t length)\n%\n%  A description of each parameter follows:\n%\n%    o magick: compare image format pattern against these bytes.\n%\n%    o length: Specifies the length of the magick string.\n%\n*/\nstatic MagickBooleanType IsHDR(const unsigned char *magick,\n  const size_t length)\n{\n  if (length < 10)\n    return(MagickFalse);\n  if (LocaleNCompare((const char *) magick,\"#?RADIANCE\",10) == 0)\n    return(MagickTrue);\n  if (LocaleNCompare((const char *) magick,\"#?RGBE\",6) == 0)\n    return(MagickTrue);\n  return(MagickFalse);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d H D R I m a g e                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadHDRImage() reads the Radiance RGBE image format and returns it.  It\n%  allocates the memory necessary for the new Image structure and returns a\n%  pointer to the new image.\n%\n%  The format of the ReadHDRImage method is:\n%\n%      Image *ReadHDRImage(const ImageInfo *image_info,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic Image *ReadHDRImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  char\n    format[MaxTextExtent],\n    keyword[MaxTextExtent],\n    tag[MaxTextExtent],\n    value[MaxTextExtent];\n\n  double\n    gamma;\n\n  Image\n    *image;\n\n  int\n    c;\n\n  MagickBooleanType\n    status,\n    value_expected;\n\n  register Quantum\n    *q;\n\n  register ssize_t\n    i,\n    x;\n\n  register unsigned char\n    *p;\n\n  ssize_t\n    count,\n    y;\n\n  unsigned char\n    *end,\n    pixel[4],\n    *pixels;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Decode image header.\n  */\n  image->columns=0;\n  image->rows=0;\n  *format='\\0';\n  c=ReadBlobByte(image);\n  if (c == EOF)\n    {\n      image=DestroyImage(image);\n      return((Image *) NULL);\n    }\n  while (isgraph(c) && (image->columns == 0) && (image->rows == 0))\n  {\n    if (c == (int) '#')\n      {\n        char\n          *comment;\n\n        register char\n          *p;\n\n        size_t\n          length;\n\n        /*\n          Read comment-- any text between # and end-of-line.\n        */\n        length=MaxTextExtent;\n        comment=AcquireString((char *) NULL);\n        for (p=comment; comment != (char *) NULL; p++)\n        {\n          c=ReadBlobByte(image);\n          if ((c == EOF) || (c == (int) '\\n'))\n            break;\n          if ((size_t) (p-comment+1) >= length)\n            {\n              *p='\\0';\n              length<<=1;\n              comment=(char *) ResizeQuantumMemory(comment,length+\n                MaxTextExtent,sizeof(*comment));\n              if (comment == (char *) NULL)\n                break;\n              p=comment+strlen(comment);\n            }\n          *p=(char) c;\n        }\n        if (comment == (char *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        *p='\\0';\n        (void) SetImageProperty(image,\"comment\",comment,exception);\n        comment=DestroyString(comment);\n        c=ReadBlobByte(image);\n      }\n    else\n      if (isalnum(c) == MagickFalse)\n        c=ReadBlobByte(image);\n      else\n        {\n          register char\n            *p;\n\n          /*\n            Determine a keyword and its value.\n          */\n          p=keyword;\n          do\n          {\n            if ((size_t) (p-keyword) < (MaxTextExtent-1))\n              *p++=c;\n            c=ReadBlobByte(image);\n          } while (isalnum(c) || (c == '_'));\n          *p='\\0';\n          value_expected=MagickFalse;\n          while ((isspace((int) ((unsigned char) c)) != 0) || (c == '='))\n          {\n            if (c == '=')\n              value_expected=MagickTrue;\n            c=ReadBlobByte(image);\n          }\n          if (LocaleCompare(keyword,\"Y\") == 0)\n            value_expected=MagickTrue;\n          if (value_expected == MagickFalse)\n            continue;\n          p=value;\n          while ((c != '\\n') && (c != '\\0'))\n          {\n            if ((size_t) (p-value) < (MaxTextExtent-1))\n              *p++=c;\n            c=ReadBlobByte(image);\n          }\n          *p='\\0';\n          /*\n            Assign a value to the specified keyword.\n          */\n          switch (*keyword)\n          {\n            case 'F':\n            case 'f':\n            {\n              if (LocaleCompare(keyword,\"format\") == 0)\n                {\n                  (void) CopyMagickString(format,value,MaxTextExtent);\n                  break;\n                }\n              (void) FormatLocaleString(tag,MaxTextExtent,\"hdr:%s\",keyword);\n              (void) SetImageProperty(image,tag,value,exception);\n              break;\n            }\n            case 'G':\n            case 'g':\n            {\n              if (LocaleCompare(keyword,\"gamma\") == 0)\n                {\n                  image->gamma=StringToDouble(value,(char **) NULL);\n                  break;\n                }\n              (void) FormatLocaleString(tag,MaxTextExtent,\"hdr:%s\",keyword);\n              (void) SetImageProperty(image,tag,value,exception);\n              break;\n            }\n            case 'P':\n            case 'p':\n            {\n              if (LocaleCompare(keyword,\"primaries\") == 0)\n                {\n                  float\n                    chromaticity[6],\n                    white_point[2];\n\n                  (void) sscanf(value,\"%g %g %g %g %g %g %g %g\",\n                    &chromaticity[0],&chromaticity[1],&chromaticity[2],\n                    &chromaticity[3],&chromaticity[4],&chromaticity[5],\n                    &white_point[0],&white_point[1]);\n                  image->chromaticity.red_primary.x=chromaticity[0];\n                  image->chromaticity.red_primary.y=chromaticity[1];\n                  image->chromaticity.green_primary.x=chromaticity[2];\n                  image->chromaticity.green_primary.y=chromaticity[3];\n                  image->chromaticity.blue_primary.x=chromaticity[4];\n                  image->chromaticity.blue_primary.y=chromaticity[5];\n                  image->chromaticity.white_point.x=white_point[0],\n                  image->chromaticity.white_point.y=white_point[1];\n                  break;\n                }\n              (void) FormatLocaleString(tag,MaxTextExtent,\"hdr:%s\",keyword);\n              (void) SetImageProperty(image,tag,value,exception);\n              break;\n            }\n            case 'Y':\n            case 'y':\n            {\n              char\n                target[] = \"Y\";\n\n              if (strcmp(keyword,target) == 0)\n                {\n                  int\n                    height,\n                    width;\n\n                  (void) sscanf(value,\"%d +X %d\",&height,&width);\n                  image->columns=(size_t) width;\n                  image->rows=(size_t) height;\n                  break;\n                }\n              (void) FormatLocaleString(tag,MaxTextExtent,\"hdr:%s\",keyword);\n              (void) SetImageProperty(image,tag,value,exception);\n              break;\n            }\n            default:\n            {\n              (void) FormatLocaleString(tag,MaxTextExtent,\"hdr:%s\",keyword);\n              (void) SetImageProperty(image,tag,value,exception);\n              break;\n            }\n          }\n        }\n    if ((image->columns == 0) && (image->rows == 0))\n      while (isspace((int) ((unsigned char) c)) != 0)\n        c=ReadBlobByte(image);\n  }\n  if ((LocaleCompare(format,\"32-bit_rle_rgbe\") != 0) &&\n      (LocaleCompare(format,\"32-bit_rle_xyze\") != 0))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if ((image->columns == 0) || (image->rows == 0))\n    ThrowReaderException(CorruptImageError,\"NegativeOrZeroImageSize\");\n  (void) SetImageColorspace(image,RGBColorspace,exception);\n  if (LocaleCompare(format,\"32-bit_rle_xyze\") == 0)\n    (void) SetImageColorspace(image,XYZColorspace,exception);\n  image->compression=(image->columns < 8) || (image->columns > 0x7ffff) ?\n    NoCompression : RLECompression;\n  if (image_info->ping != MagickFalse)\n    {\n      (void) CloseBlob(image);\n      return(GetFirstImageInList(image));\n    }\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  /*\n    Read RGBE (red+green+blue+exponent) pixels.\n  */\n  pixels=(unsigned char *) AcquireQuantumMemory(image->columns,4*\n    sizeof(*pixels));\n  if (pixels == (unsigned char *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    if (image->compression != RLECompression)\n      {\n        count=ReadBlob(image,4*image->columns*sizeof(*pixels),pixels);\n        if (count != (ssize_t) (4*image->columns*sizeof(*pixels)))\n          break;\n      }\n    else\n      {\n        count=ReadBlob(image,4*sizeof(*pixel),pixel);\n        if (count != 4)\n          break;\n        if ((size_t) ((((size_t) pixel[2]) << 8) | pixel[3]) != image->columns)\n          {\n            (void) memcpy(pixels,pixel,4*sizeof(*pixel));\n            count=ReadBlob(image,4*(image->columns-1)*sizeof(*pixels),pixels+4);\n            image->compression=NoCompression;\n          }\n        else\n          {\n            p=pixels;\n            for (i=0; i < 4; i++)\n            {\n              end=&pixels[(i+1)*image->columns];\n              while (p < end)\n              {\n                count=ReadBlob(image,2*sizeof(*pixel),pixel);\n                if (count < 1)\n                  break;\n                if (pixel[0] > 128)\n                  {\n                    count=(ssize_t) pixel[0]-128;\n                    if ((count == 0) || (count > (ssize_t) (end-p)))\n                      break;\n                    while (count-- > 0)\n                      *p++=pixel[1];\n                  }\n                else\n                  {\n                    count=(ssize_t) pixel[0];\n                    if ((count == 0) || (count > (ssize_t) (end-p)))\n                      break;\n                    *p++=pixel[1];\n                    if (--count > 0)\n                      {\n                        count=ReadBlob(image,(size_t) count*sizeof(*p),p);\n                        if (count < 1)\n                          break;\n                        p+=count;\n                      }\n                  }\n              }\n            }\n          }\n      }\n    q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      break;\n    i=0;\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      if (image->compression == RLECompression)\n        {\n          pixel[0]=pixels[x];\n          pixel[1]=pixels[x+image->columns];\n          pixel[2]=pixels[x+2*image->columns];\n          pixel[3]=pixels[x+3*image->columns];\n        }\n      else\n        {\n          pixel[0]=pixels[i++];\n          pixel[1]=pixels[i++];\n          pixel[2]=pixels[i++];\n          pixel[3]=pixels[i++];\n        }\n      SetPixelRed(image,0,q);\n      SetPixelGreen(image,0,q);\n      SetPixelBlue(image,0,q);\n      if (pixel[3] != 0)\n        {\n          gamma=pow(2.0,pixel[3]-(128.0+8.0));\n          SetPixelRed(image,ClampToQuantum(QuantumRange*gamma*pixel[0]),q);\n          SetPixelGreen(image,ClampToQuantum(QuantumRange*gamma*pixel[1]),q);\n          SetPixelBlue(image,ClampToQuantum(QuantumRange*gamma*pixel[2]),q);\n        }\n      q+=GetPixelChannels(image);\n    }\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      break;\n    status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n      image->rows);\n    if (status == MagickFalse)\n      break;\n  }\n  pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n  if (EOFBlob(image) != MagickFalse)\n    ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n      image->filename);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e g i s t e r H D R I m a g e                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RegisterHDRImage() adds attributes for the Radiance RGBE image format to the\n%  list of supported formats.  The attributes include the image format tag, a\n%  method to read and/or write the format, whether the format supports the\n%  saving of more than one frame to the same file or blob, whether the format\n%  supports native in-memory I/O, and a brief description of the format.\n%\n%  The format of the RegisterHDRImage method is:\n%\n%      size_t RegisterHDRImage(void)\n%\n*/\nModuleExport size_t RegisterHDRImage(void)\n{\n  MagickInfo\n    *entry;\n\n  entry=SetMagickInfo(\"HDR\");\n  entry->decoder=(DecodeImageHandler *) ReadHDRImage;\n  entry->encoder=(EncodeImageHandler *) WriteHDRImage;\n  entry->description=ConstantString(\"Radiance RGBE image format\");\n  entry->module=ConstantString(\"HDR\");\n  entry->magick=(IsImageFormatHandler *) IsHDR;\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r H D R I m a g e                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnregisterHDRImage() removes format registrations made by the\n%  HDR module from the list of supported formats.\n%\n%  The format of the UnregisterHDRImage method is:\n%\n%      UnregisterHDRImage(void)\n%\n*/\nModuleExport void UnregisterHDRImage(void)\n{\n  (void) UnregisterMagickInfo(\"HDR\");\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   W r i t e H D R I m a g e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WriteHDRImage() writes an image in the Radience RGBE image format.\n%\n%  The format of the WriteHDRImage method is:\n%\n%      MagickBooleanType WriteHDRImage(const ImageInfo *image_info,\n%        Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows.\n%\n%    o image_info: the image info.\n%\n%    o image:  The image.\n%\n*/\n\nstatic size_t HDRWriteRunlengthPixels(Image *image,unsigned char *pixels)\n{\n#define MinimumRunlength 4\n\n  register size_t\n    p,\n    q;\n\n  size_t\n    runlength;\n\n  ssize_t\n    count,\n    previous_count;\n\n  unsigned char\n    pixel[2];\n\n  for (p=0; p < image->columns; )\n  {\n    q=p;\n    runlength=0;\n    previous_count=0;\n    while ((runlength < MinimumRunlength) && (q < image->columns))\n    {\n      q+=runlength;\n      previous_count=(ssize_t) runlength;\n      runlength=1;\n      while ((pixels[q] == pixels[q+runlength]) &&\n             ((q+runlength) < image->columns) && (runlength < 127))\n       runlength++;\n    }\n    if ((previous_count > 1) && (previous_count == (ssize_t) (q-p)))\n      {\n        pixel[0]=(unsigned char) (128+previous_count);\n        pixel[1]=pixels[p];\n        if (WriteBlob(image,2*sizeof(*pixel),pixel) < 1)\n          break;\n        p=q;\n      }\n    while (p < q)\n    {\n      count=(ssize_t) (q-p);\n      if (count > 128)\n        count=128;\n      pixel[0]=(unsigned char) count;\n      if (WriteBlob(image,sizeof(*pixel),pixel) < 1)\n        break;\n      if (WriteBlob(image,(size_t) count*sizeof(*pixel),&pixels[p]) < 1)\n        break;\n      p+=count;\n    }\n    if (runlength >= MinimumRunlength)\n      {\n        pixel[0]=(unsigned char) (128+runlength);\n        pixel[1]=pixels[q];\n        if (WriteBlob(image,2*sizeof(*pixel),pixel) < 1)\n          break;\n        p+=runlength;\n      }\n  }\n  return(p);\n}\n\nstatic MagickBooleanType WriteHDRImage(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n  char\n    header[MaxTextExtent];\n\n  const char\n    *property;\n\n  MagickBooleanType\n    status;\n\n  register const Quantum\n    *p;\n\n  register ssize_t\n    i,\n    x;\n\n  size_t\n    length;\n\n  ssize_t\n    count,\n    y;\n\n  unsigned char\n    pixel[4],\n    *pixels;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  if (IsRGBColorspace(image->colorspace) == MagickFalse)\n    (void) TransformImageColorspace(image,RGBColorspace,exception);\n  /*\n    Write header.\n  */\n  (void) ResetMagickMemory(header,' ',MaxTextExtent);\n  length=CopyMagickString(header,\"#?RGBE\\n\",MaxTextExtent);\n  (void) WriteBlob(image,length,(unsigned char *) header);\n  property=GetImageProperty(image,\"comment\",exception);\n  if ((property != (const char *) NULL) &&\n      (strchr(property,'\\n') == (char *) NULL))\n    {\n      count=FormatLocaleString(header,MaxTextExtent,\"#%s\\n\",property);\n      (void) WriteBlob(image,(size_t) count,(unsigned char *) header);\n    }\n  property=GetImageProperty(image,\"hdr:exposure\",exception);\n  if (property != (const char *) NULL)\n    {\n      count=FormatLocaleString(header,MaxTextExtent,\"EXPOSURE=%g\\n\",\n        strtod(property,(char **) NULL));\n      (void) WriteBlob(image,(size_t) count,(unsigned char *) header);\n    }\n  if (image->gamma != 0.0)\n    {\n      count=FormatLocaleString(header,MaxTextExtent,\"GAMMA=%g\\n\",image->gamma);\n      (void) WriteBlob(image,(size_t) count,(unsigned char *) header);\n    }\n  count=FormatLocaleString(header,MaxTextExtent,\n    \"PRIMARIES=%g %g %g %g %g %g %g %g\\n\",\n    image->chromaticity.red_primary.x,image->chromaticity.red_primary.y,\n    image->chromaticity.green_primary.x,image->chromaticity.green_primary.y,\n    image->chromaticity.blue_primary.x,image->chromaticity.blue_primary.y,\n    image->chromaticity.white_point.x,image->chromaticity.white_point.y);\n  (void) WriteBlob(image,(size_t) count,(unsigned char *) header);\n  length=CopyMagickString(header,\"FORMAT=32-bit_rle_rgbe\\n\\n\",MaxTextExtent);\n  (void) WriteBlob(image,length,(unsigned char *) header);\n  count=FormatLocaleString(header,MaxTextExtent,\"-Y %.20g +X %.20g\\n\",\n    (double) image->rows,(double) image->columns);\n  (void) WriteBlob(image,(size_t) count,(unsigned char *) header);\n  /*\n    Write HDR pixels.\n  */\n  pixels=(unsigned char *) AcquireQuantumMemory(image->columns,4*\n    sizeof(*pixels));\n  if (pixels == (unsigned char *) NULL)\n    ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n    if (p == (const Quantum *) NULL)\n      break;\n    if ((image->columns >= 8) && (image->columns <= 0x7ffff))\n      {\n        pixel[0]=2;\n        pixel[1]=2;\n        pixel[2]=(unsigned char) (image->columns >> 8);\n        pixel[3]=(unsigned char) (image->columns & 0xff);\n        count=WriteBlob(image,4*sizeof(*pixel),pixel);\n        if (count != (ssize_t) (4*sizeof(*pixel)))\n          break;\n      }\n    i=0;\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      double\n        gamma;\n\n      pixel[0]=0;\n      pixel[1]=0;\n      pixel[2]=0;\n      pixel[3]=0;\n      gamma=QuantumScale*GetPixelRed(image,p);\n      if ((QuantumScale*GetPixelGreen(image,p)) > gamma)\n        gamma=QuantumScale*GetPixelGreen(image,p);\n      if ((QuantumScale*GetPixelBlue(image,p)) > gamma)\n        gamma=QuantumScale*GetPixelBlue(image,p);\n      if (gamma > MagickEpsilon)\n        {\n          int\n            exponent;\n\n          gamma=frexp(gamma,&exponent)*256.0/gamma;\n          pixel[0]=(unsigned char) (gamma*QuantumScale*GetPixelRed(image,p));\n          pixel[1]=(unsigned char) (gamma*QuantumScale*GetPixelGreen(image,p));\n          pixel[2]=(unsigned char) (gamma*QuantumScale*GetPixelBlue(image,p));\n          pixel[3]=(unsigned char) (exponent+128);\n        }\n      if ((image->columns >= 8) && (image->columns <= 0x7ffff))\n        {\n          pixels[x]=pixel[0];\n          pixels[x+image->columns]=pixel[1];\n          pixels[x+2*image->columns]=pixel[2];\n          pixels[x+3*image->columns]=pixel[3];\n        }\n      else\n        {\n          pixels[i++]=pixel[0];\n          pixels[i++]=pixel[1];\n          pixels[i++]=pixel[2];\n          pixels[i++]=pixel[3];\n        }\n      p+=GetPixelChannels(image);\n    }\n    if ((image->columns >= 8) && (image->columns <= 0x7ffff))\n      {\n        for (i=0; i < 4; i++)\n          length=HDRWriteRunlengthPixels(image,&pixels[i*image->columns]);\n      }\n    else\n      {\n        count=WriteBlob(image,4*image->columns*sizeof(*pixels),pixels);\n        if (count != (ssize_t) (4*image->columns*sizeof(*pixels)))\n          break;\n      }\n    status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n      image->rows);\n    if (status == MagickFalse)\n      break;\n  }\n  pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}\n"], "fixing_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                            H   H  DDDD   RRRR                               %\n%                            H   H  D   D  R   R                              %\n%                            HHHHH  D   D  RRRR                               %\n%                            H   H  D   D  R R                                %\n%                            H   H  DDDD   R  R                               %\n%                                                                             %\n%                                                                             %\n%                   Read/Write Radiance RGBE Image Format                     %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                                 July 1992                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2015 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    http://www.imagemagick.org/script/license.php                            %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/colorspace.h\"\n#include \"MagickCore/colorspace-private.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/property.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/static.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/string-private.h\"\n#include \"MagickCore/module.h\"\n\f\n/*\n  Forward declarations.\n*/\nstatic MagickBooleanType\n  WriteHDRImage(const ImageInfo *,Image *,ExceptionInfo *);\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I s H D R                                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsHDR() returns MagickTrue if the image format type, identified by the\n%  magick string, is Radiance RGBE image format.\n%\n%  The format of the IsHDR method is:\n%\n%      MagickBooleanType IsHDR(const unsigned char *magick,\n%        const size_t length)\n%\n%  A description of each parameter follows:\n%\n%    o magick: compare image format pattern against these bytes.\n%\n%    o length: Specifies the length of the magick string.\n%\n*/\nstatic MagickBooleanType IsHDR(const unsigned char *magick,\n  const size_t length)\n{\n  if (length < 10)\n    return(MagickFalse);\n  if (LocaleNCompare((const char *) magick,\"#?RADIANCE\",10) == 0)\n    return(MagickTrue);\n  if (LocaleNCompare((const char *) magick,\"#?RGBE\",6) == 0)\n    return(MagickTrue);\n  return(MagickFalse);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d H D R I m a g e                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadHDRImage() reads the Radiance RGBE image format and returns it.  It\n%  allocates the memory necessary for the new Image structure and returns a\n%  pointer to the new image.\n%\n%  The format of the ReadHDRImage method is:\n%\n%      Image *ReadHDRImage(const ImageInfo *image_info,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic Image *ReadHDRImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  char\n    format[MaxTextExtent],\n    keyword[MaxTextExtent],\n    tag[MaxTextExtent],\n    value[MaxTextExtent];\n\n  double\n    gamma;\n\n  Image\n    *image;\n\n  int\n    c;\n\n  MagickBooleanType\n    status,\n    value_expected;\n\n  register Quantum\n    *q;\n\n  register ssize_t\n    i,\n    x;\n\n  register unsigned char\n    *p;\n\n  ssize_t\n    count,\n    y;\n\n  unsigned char\n    *end,\n    pixel[4],\n    *pixels;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Decode image header.\n  */\n  image->columns=0;\n  image->rows=0;\n  *format='\\0';\n  c=ReadBlobByte(image);\n  if (c == EOF)\n    {\n      image=DestroyImage(image);\n      return((Image *) NULL);\n    }\n  while (isgraph(c) && (image->columns == 0) && (image->rows == 0))\n  {\n    if (c == (int) '#')\n      {\n        char\n          *comment;\n\n        register char\n          *p;\n\n        size_t\n          length;\n\n        /*\n          Read comment-- any text between # and end-of-line.\n        */\n        length=MaxTextExtent;\n        comment=AcquireString((char *) NULL);\n        for (p=comment; comment != (char *) NULL; p++)\n        {\n          c=ReadBlobByte(image);\n          if ((c == EOF) || (c == (int) '\\n'))\n            break;\n          if ((size_t) (p-comment+1) >= length)\n            {\n              *p='\\0';\n              length<<=1;\n              comment=(char *) ResizeQuantumMemory(comment,length+\n                MaxTextExtent,sizeof(*comment));\n              if (comment == (char *) NULL)\n                break;\n              p=comment+strlen(comment);\n            }\n          *p=(char) c;\n        }\n        if (comment == (char *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        *p='\\0';\n        (void) SetImageProperty(image,\"comment\",comment,exception);\n        comment=DestroyString(comment);\n        c=ReadBlobByte(image);\n      }\n    else\n      if (isalnum(c) == MagickFalse)\n        c=ReadBlobByte(image);\n      else\n        {\n          register char\n            *p;\n\n          /*\n            Determine a keyword and its value.\n          */\n          p=keyword;\n          do\n          {\n            if ((size_t) (p-keyword) < (MaxTextExtent-1))\n              *p++=c;\n            c=ReadBlobByte(image);\n          } while (isalnum(c) || (c == '_'));\n          *p='\\0';\n          value_expected=MagickFalse;\n          while ((isspace((int) ((unsigned char) c)) != 0) || (c == '='))\n          {\n            if (c == '=')\n              value_expected=MagickTrue;\n            c=ReadBlobByte(image);\n          }\n          if (LocaleCompare(keyword,\"Y\") == 0)\n            value_expected=MagickTrue;\n          if (value_expected == MagickFalse)\n            continue;\n          p=value;\n          while ((c != '\\n') && (c != '\\0') && (c != EOF))\n          {\n            if ((size_t) (p-value) < (MaxTextExtent-1))\n              *p++=c;\n            c=ReadBlobByte(image);\n          }\n          *p='\\0';\n          /*\n            Assign a value to the specified keyword.\n          */\n          switch (*keyword)\n          {\n            case 'F':\n            case 'f':\n            {\n              if (LocaleCompare(keyword,\"format\") == 0)\n                {\n                  (void) CopyMagickString(format,value,MaxTextExtent);\n                  break;\n                }\n              (void) FormatLocaleString(tag,MaxTextExtent,\"hdr:%s\",keyword);\n              (void) SetImageProperty(image,tag,value,exception);\n              break;\n            }\n            case 'G':\n            case 'g':\n            {\n              if (LocaleCompare(keyword,\"gamma\") == 0)\n                {\n                  image->gamma=StringToDouble(value,(char **) NULL);\n                  break;\n                }\n              (void) FormatLocaleString(tag,MaxTextExtent,\"hdr:%s\",keyword);\n              (void) SetImageProperty(image,tag,value,exception);\n              break;\n            }\n            case 'P':\n            case 'p':\n            {\n              if (LocaleCompare(keyword,\"primaries\") == 0)\n                {\n                  float\n                    chromaticity[6],\n                    white_point[2];\n\n                  if (sscanf(value,\"%g %g %g %g %g %g %g %g\",&chromaticity[0],\n                      &chromaticity[1],&chromaticity[2],&chromaticity[3],\n                      &chromaticity[4],&chromaticity[5],&white_point[0],\n                      &white_point[1]) == 8)\n                    {\n                      image->chromaticity.red_primary.x=chromaticity[0];\n                      image->chromaticity.red_primary.y=chromaticity[1];\n                      image->chromaticity.green_primary.x=chromaticity[2];\n                      image->chromaticity.green_primary.y=chromaticity[3];\n                      image->chromaticity.blue_primary.x=chromaticity[4];\n                      image->chromaticity.blue_primary.y=chromaticity[5];\n                      image->chromaticity.white_point.x=white_point[0],\n                      image->chromaticity.white_point.y=white_point[1];\n                    }\n                  break;\n                }\n              (void) FormatLocaleString(tag,MaxTextExtent,\"hdr:%s\",keyword);\n              (void) SetImageProperty(image,tag,value,exception);\n              break;\n            }\n            case 'Y':\n            case 'y':\n            {\n              char\n                target[] = \"Y\";\n\n              if (strcmp(keyword,target) == 0)\n                {\n                  int\n                    height,\n                    width;\n\n                  if (sscanf(value,\"%d +X %d\",&height,&width) == 2)\n                    {\n                      image->columns=(size_t) width;\n                      image->rows=(size_t) height;\n                    }\n                  break;\n                }\n              (void) FormatLocaleString(tag,MaxTextExtent,\"hdr:%s\",keyword);\n              (void) SetImageProperty(image,tag,value,exception);\n              break;\n            }\n            default:\n            {\n              (void) FormatLocaleString(tag,MaxTextExtent,\"hdr:%s\",keyword);\n              (void) SetImageProperty(image,tag,value,exception);\n              break;\n            }\n          }\n        }\n    if ((image->columns == 0) && (image->rows == 0))\n      while (isspace((int) ((unsigned char) c)) != 0)\n        c=ReadBlobByte(image);\n  }\n  if ((LocaleCompare(format,\"32-bit_rle_rgbe\") != 0) &&\n      (LocaleCompare(format,\"32-bit_rle_xyze\") != 0))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if ((image->columns == 0) || (image->rows == 0))\n    ThrowReaderException(CorruptImageError,\"NegativeOrZeroImageSize\");\n  (void) SetImageColorspace(image,RGBColorspace,exception);\n  if (LocaleCompare(format,\"32-bit_rle_xyze\") == 0)\n    (void) SetImageColorspace(image,XYZColorspace,exception);\n  image->compression=(image->columns < 8) || (image->columns > 0x7ffff) ?\n    NoCompression : RLECompression;\n  if (image_info->ping != MagickFalse)\n    {\n      (void) CloseBlob(image);\n      return(GetFirstImageInList(image));\n    }\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  /*\n    Read RGBE (red+green+blue+exponent) pixels.\n  */\n  pixels=(unsigned char *) AcquireQuantumMemory(image->columns,4*\n    sizeof(*pixels));\n  if (pixels == (unsigned char *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    if (image->compression != RLECompression)\n      {\n        count=ReadBlob(image,4*image->columns*sizeof(*pixels),pixels);\n        if (count != (ssize_t) (4*image->columns*sizeof(*pixels)))\n          break;\n      }\n    else\n      {\n        count=ReadBlob(image,4*sizeof(*pixel),pixel);\n        if (count != 4)\n          break;\n        if ((size_t) ((((size_t) pixel[2]) << 8) | pixel[3]) != image->columns)\n          {\n            (void) memcpy(pixels,pixel,4*sizeof(*pixel));\n            count=ReadBlob(image,4*(image->columns-1)*sizeof(*pixels),pixels+4);\n            image->compression=NoCompression;\n          }\n        else\n          {\n            p=pixels;\n            for (i=0; i < 4; i++)\n            {\n              end=&pixels[(i+1)*image->columns];\n              while (p < end)\n              {\n                count=ReadBlob(image,2*sizeof(*pixel),pixel);\n                if (count < 1)\n                  break;\n                if (pixel[0] > 128)\n                  {\n                    count=(ssize_t) pixel[0]-128;\n                    if ((count == 0) || (count > (ssize_t) (end-p)))\n                      break;\n                    while (count-- > 0)\n                      *p++=pixel[1];\n                  }\n                else\n                  {\n                    count=(ssize_t) pixel[0];\n                    if ((count == 0) || (count > (ssize_t) (end-p)))\n                      break;\n                    *p++=pixel[1];\n                    if (--count > 0)\n                      {\n                        count=ReadBlob(image,(size_t) count*sizeof(*p),p);\n                        if (count < 1)\n                          break;\n                        p+=count;\n                      }\n                  }\n              }\n            }\n          }\n      }\n    q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      break;\n    i=0;\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      if (image->compression == RLECompression)\n        {\n          pixel[0]=pixels[x];\n          pixel[1]=pixels[x+image->columns];\n          pixel[2]=pixels[x+2*image->columns];\n          pixel[3]=pixels[x+3*image->columns];\n        }\n      else\n        {\n          pixel[0]=pixels[i++];\n          pixel[1]=pixels[i++];\n          pixel[2]=pixels[i++];\n          pixel[3]=pixels[i++];\n        }\n      SetPixelRed(image,0,q);\n      SetPixelGreen(image,0,q);\n      SetPixelBlue(image,0,q);\n      if (pixel[3] != 0)\n        {\n          gamma=pow(2.0,pixel[3]-(128.0+8.0));\n          SetPixelRed(image,ClampToQuantum(QuantumRange*gamma*pixel[0]),q);\n          SetPixelGreen(image,ClampToQuantum(QuantumRange*gamma*pixel[1]),q);\n          SetPixelBlue(image,ClampToQuantum(QuantumRange*gamma*pixel[2]),q);\n        }\n      q+=GetPixelChannels(image);\n    }\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      break;\n    status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n      image->rows);\n    if (status == MagickFalse)\n      break;\n  }\n  pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n  if (EOFBlob(image) != MagickFalse)\n    ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n      image->filename);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e g i s t e r H D R I m a g e                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RegisterHDRImage() adds attributes for the Radiance RGBE image format to the\n%  list of supported formats.  The attributes include the image format tag, a\n%  method to read and/or write the format, whether the format supports the\n%  saving of more than one frame to the same file or blob, whether the format\n%  supports native in-memory I/O, and a brief description of the format.\n%\n%  The format of the RegisterHDRImage method is:\n%\n%      size_t RegisterHDRImage(void)\n%\n*/\nModuleExport size_t RegisterHDRImage(void)\n{\n  MagickInfo\n    *entry;\n\n  entry=SetMagickInfo(\"HDR\");\n  entry->decoder=(DecodeImageHandler *) ReadHDRImage;\n  entry->encoder=(EncodeImageHandler *) WriteHDRImage;\n  entry->description=ConstantString(\"Radiance RGBE image format\");\n  entry->module=ConstantString(\"HDR\");\n  entry->magick=(IsImageFormatHandler *) IsHDR;\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r H D R I m a g e                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnregisterHDRImage() removes format registrations made by the\n%  HDR module from the list of supported formats.\n%\n%  The format of the UnregisterHDRImage method is:\n%\n%      UnregisterHDRImage(void)\n%\n*/\nModuleExport void UnregisterHDRImage(void)\n{\n  (void) UnregisterMagickInfo(\"HDR\");\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   W r i t e H D R I m a g e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WriteHDRImage() writes an image in the Radience RGBE image format.\n%\n%  The format of the WriteHDRImage method is:\n%\n%      MagickBooleanType WriteHDRImage(const ImageInfo *image_info,\n%        Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows.\n%\n%    o image_info: the image info.\n%\n%    o image:  The image.\n%\n*/\n\nstatic size_t HDRWriteRunlengthPixels(Image *image,unsigned char *pixels)\n{\n#define MinimumRunlength 4\n\n  register size_t\n    p,\n    q;\n\n  size_t\n    runlength;\n\n  ssize_t\n    count,\n    previous_count;\n\n  unsigned char\n    pixel[2];\n\n  for (p=0; p < image->columns; )\n  {\n    q=p;\n    runlength=0;\n    previous_count=0;\n    while ((runlength < MinimumRunlength) && (q < image->columns))\n    {\n      q+=runlength;\n      previous_count=(ssize_t) runlength;\n      runlength=1;\n      while ((pixels[q] == pixels[q+runlength]) &&\n             ((q+runlength) < image->columns) && (runlength < 127))\n       runlength++;\n    }\n    if ((previous_count > 1) && (previous_count == (ssize_t) (q-p)))\n      {\n        pixel[0]=(unsigned char) (128+previous_count);\n        pixel[1]=pixels[p];\n        if (WriteBlob(image,2*sizeof(*pixel),pixel) < 1)\n          break;\n        p=q;\n      }\n    while (p < q)\n    {\n      count=(ssize_t) (q-p);\n      if (count > 128)\n        count=128;\n      pixel[0]=(unsigned char) count;\n      if (WriteBlob(image,sizeof(*pixel),pixel) < 1)\n        break;\n      if (WriteBlob(image,(size_t) count*sizeof(*pixel),&pixels[p]) < 1)\n        break;\n      p+=count;\n    }\n    if (runlength >= MinimumRunlength)\n      {\n        pixel[0]=(unsigned char) (128+runlength);\n        pixel[1]=pixels[q];\n        if (WriteBlob(image,2*sizeof(*pixel),pixel) < 1)\n          break;\n        p+=runlength;\n      }\n  }\n  return(p);\n}\n\nstatic MagickBooleanType WriteHDRImage(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n  char\n    header[MaxTextExtent];\n\n  const char\n    *property;\n\n  MagickBooleanType\n    status;\n\n  register const Quantum\n    *p;\n\n  register ssize_t\n    i,\n    x;\n\n  size_t\n    length;\n\n  ssize_t\n    count,\n    y;\n\n  unsigned char\n    pixel[4],\n    *pixels;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  if (IsRGBColorspace(image->colorspace) == MagickFalse)\n    (void) TransformImageColorspace(image,RGBColorspace,exception);\n  /*\n    Write header.\n  */\n  (void) ResetMagickMemory(header,' ',MaxTextExtent);\n  length=CopyMagickString(header,\"#?RGBE\\n\",MaxTextExtent);\n  (void) WriteBlob(image,length,(unsigned char *) header);\n  property=GetImageProperty(image,\"comment\",exception);\n  if ((property != (const char *) NULL) &&\n      (strchr(property,'\\n') == (char *) NULL))\n    {\n      count=FormatLocaleString(header,MaxTextExtent,\"#%s\\n\",property);\n      (void) WriteBlob(image,(size_t) count,(unsigned char *) header);\n    }\n  property=GetImageProperty(image,\"hdr:exposure\",exception);\n  if (property != (const char *) NULL)\n    {\n      count=FormatLocaleString(header,MaxTextExtent,\"EXPOSURE=%g\\n\",\n        strtod(property,(char **) NULL));\n      (void) WriteBlob(image,(size_t) count,(unsigned char *) header);\n    }\n  if (image->gamma != 0.0)\n    {\n      count=FormatLocaleString(header,MaxTextExtent,\"GAMMA=%g\\n\",image->gamma);\n      (void) WriteBlob(image,(size_t) count,(unsigned char *) header);\n    }\n  count=FormatLocaleString(header,MaxTextExtent,\n    \"PRIMARIES=%g %g %g %g %g %g %g %g\\n\",\n    image->chromaticity.red_primary.x,image->chromaticity.red_primary.y,\n    image->chromaticity.green_primary.x,image->chromaticity.green_primary.y,\n    image->chromaticity.blue_primary.x,image->chromaticity.blue_primary.y,\n    image->chromaticity.white_point.x,image->chromaticity.white_point.y);\n  (void) WriteBlob(image,(size_t) count,(unsigned char *) header);\n  length=CopyMagickString(header,\"FORMAT=32-bit_rle_rgbe\\n\\n\",MaxTextExtent);\n  (void) WriteBlob(image,length,(unsigned char *) header);\n  count=FormatLocaleString(header,MaxTextExtent,\"-Y %.20g +X %.20g\\n\",\n    (double) image->rows,(double) image->columns);\n  (void) WriteBlob(image,(size_t) count,(unsigned char *) header);\n  /*\n    Write HDR pixels.\n  */\n  pixels=(unsigned char *) AcquireQuantumMemory(image->columns,4*\n    sizeof(*pixels));\n  if (pixels == (unsigned char *) NULL)\n    ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n    if (p == (const Quantum *) NULL)\n      break;\n    if ((image->columns >= 8) && (image->columns <= 0x7ffff))\n      {\n        pixel[0]=2;\n        pixel[1]=2;\n        pixel[2]=(unsigned char) (image->columns >> 8);\n        pixel[3]=(unsigned char) (image->columns & 0xff);\n        count=WriteBlob(image,4*sizeof(*pixel),pixel);\n        if (count != (ssize_t) (4*sizeof(*pixel)))\n          break;\n      }\n    i=0;\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      double\n        gamma;\n\n      pixel[0]=0;\n      pixel[1]=0;\n      pixel[2]=0;\n      pixel[3]=0;\n      gamma=QuantumScale*GetPixelRed(image,p);\n      if ((QuantumScale*GetPixelGreen(image,p)) > gamma)\n        gamma=QuantumScale*GetPixelGreen(image,p);\n      if ((QuantumScale*GetPixelBlue(image,p)) > gamma)\n        gamma=QuantumScale*GetPixelBlue(image,p);\n      if (gamma > MagickEpsilon)\n        {\n          int\n            exponent;\n\n          gamma=frexp(gamma,&exponent)*256.0/gamma;\n          pixel[0]=(unsigned char) (gamma*QuantumScale*GetPixelRed(image,p));\n          pixel[1]=(unsigned char) (gamma*QuantumScale*GetPixelGreen(image,p));\n          pixel[2]=(unsigned char) (gamma*QuantumScale*GetPixelBlue(image,p));\n          pixel[3]=(unsigned char) (exponent+128);\n        }\n      if ((image->columns >= 8) && (image->columns <= 0x7ffff))\n        {\n          pixels[x]=pixel[0];\n          pixels[x+image->columns]=pixel[1];\n          pixels[x+2*image->columns]=pixel[2];\n          pixels[x+3*image->columns]=pixel[3];\n        }\n      else\n        {\n          pixels[i++]=pixel[0];\n          pixels[i++]=pixel[1];\n          pixels[i++]=pixel[2];\n          pixels[i++]=pixel[3];\n        }\n      p+=GetPixelChannels(image);\n    }\n    if ((image->columns >= 8) && (image->columns <= 0x7ffff))\n      {\n        for (i=0; i < 4; i++)\n          length=HDRWriteRunlengthPixels(image,&pixels[i*image->columns]);\n      }\n    else\n      {\n        count=WriteBlob(image,4*image->columns*sizeof(*pixels),pixels);\n        if (count != (ssize_t) (4*image->columns*sizeof(*pixels)))\n          break;\n      }\n    status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n      image->rows);\n    if (status == MagickFalse)\n      break;\n  }\n  pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}\n"], "filenames": ["coders/hdr.c"], "buggy_code_start_loc": [281], "buggy_code_end_loc": [359], "fixing_code_start_loc": [281], "fixing_code_end_loc": [363], "type": "CWE-835", "message": "The ReadHDRImage function in coders/hdr.c in ImageMagick 6.x and 7.x allows remote attackers to cause a denial of service (infinite loop) via a crafted HDR file.", "other": {"cve": {"id": "CVE-2015-8900", "sourceIdentifier": "cve@mitre.org", "published": "2017-02-27T22:59:00.167", "lastModified": "2020-07-31T11:39:51.873", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The ReadHDRImage function in coders/hdr.c in ImageMagick 6.x and 7.x allows remote attackers to cause a denial of service (infinite loop) via a crafted HDR file."}, {"lang": "es", "value": "La funci\u00f3n ReadHDRImage en coders/hdr.c en ImageMagick 6.x y 7.x permite a atacantes remotos provocar una denegaci\u00f3n de servicio (bucle infinito) a trav\u00e9s de un archivo HDR manipulado."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-835"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:*:*:*:*:*:*:*:*", "versionStartIncluding": "6.0", "versionEndIncluding": "6.9.3-10", "matchCriteriaId": "6FD438C7-EAFF-4C51-942E-3ED2E335A636"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:*:*:*:*:*:*:*:*", "versionStartIncluding": "7.0.1-0", "versionEndIncluding": "7.0.5-0", "matchCriteriaId": "E3B003B5-BF3B-4D07-8896-E2F292E9FBD9"}]}]}], "references": [{"url": "http://trac.imagemagick.org/changeset/17845", "source": "cve@mitre.org", "tags": ["Broken Link"]}, {"url": "http://trac.imagemagick.org/changeset/17846", "source": "cve@mitre.org", "tags": ["Broken Link"]}, {"url": "http://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=26929", "source": "cve@mitre.org", "tags": ["Exploit", "Patch", "Vendor Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2015/02/26/13", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2016/06/06/2", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1195260", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch"]}, {"url": "https://github.com/ImageMagick/ImageMagick/commit/97aa7d7cfd2027f6ba7ce42caf8b798541b9cdc6", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ImageMagick/ImageMagick/commit/97aa7d7cfd2027f6ba7ce42caf8b798541b9cdc6"}}