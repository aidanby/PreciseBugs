{"buggy_code": ["<?php\n\nnamespace SilverStripe\\Assets\\Shortcodes;\n\nuse Psr\\SimpleCache\\CacheInterface;\nuse SilverStripe\\Assets\\File;\nuse SilverStripe\\Assets\\Image;\nuse SilverStripe\\Assets\\Storage\\AssetStore;\nuse SilverStripe\\Core\\Convert;\nuse SilverStripe\\Core\\Flushable;\nuse SilverStripe\\Core\\Injector\\Injector;\nuse SilverStripe\\View\\HTML;\nuse SilverStripe\\View\\Parsers\\ShortcodeHandler;\nuse SilverStripe\\View\\Parsers\\ShortcodeParser;\n\n/**\n * Class ImageShortcodeProvider\n *\n * @package SilverStripe\\Forms\\HtmlEditor\n */\nclass ImageShortcodeProvider extends FileShortcodeProvider implements ShortcodeHandler, Flushable\n{\n\n    /**\n     * Gets the list of shortcodes provided by this handler\n     *\n     * @return mixed\n     */\n    public static function get_shortcodes()\n    {\n        return ['image'];\n    }\n\n    /**\n     * Replace\"[image id=n]\" shortcode with an image reference.\n     * Permission checks will be enforced by the file routing itself.\n     *\n     * @param array $args Arguments passed to the parser\n     * @param string $content Raw shortcode\n     * @param ShortcodeParser $parser Parser\n     * @param string $shortcode Name of shortcode used to register this handler\n     * @param array $extra Extra arguments\n     * @return string Result of the handled shortcode\n     */\n    public static function handle_shortcode($args, $content, $parser, $shortcode, $extra = [])\n    {\n        $allowSessionGrant = static::config()->allow_session_grant;\n\n        $cache = static::getCache();\n        $cacheKey = static::getCacheKey($args);\n\n        $item = $cache->get($cacheKey);\n        if ($item) {\n            // Initiate a protected asset grant if necessary\n            if (!empty($item['filename']) && $allowSessionGrant) {\n                Injector::inst()->get(AssetStore::class)->grant($item['filename'], $item['hash']);\n            }\n\n            return $item['markup'];\n        }\n\n        // Find appropriate record, with fallback for error handlers\n        $fileFound = true;\n        $record = static::find_shortcode_record($args, $errorCode);\n        if ($errorCode) {\n            $fileFound = false;\n            $record = static::find_error_record($errorCode);\n        }\n        if (!$record) {\n            return null; // There were no suitable matches at all.\n        }\n\n        // Check if a resize is required\n        $width = null;\n        $height = null;\n        $src = $record->getURL($allowSessionGrant);\n        if ($record instanceof Image) {\n            $width = isset($args['width']) ? (int) $args['width'] : null;\n            $height = isset($args['height']) ? (int) $args['height'] : null;\n            $hasCustomDimensions = ($width && $height);\n            if ($hasCustomDimensions && (($width != $record->getWidth()) || ($height != $record->getHeight()))) {\n                $resized = $record->ResizedImage($width, $height);\n                // Make sure that the resized image actually returns an image\n                if ($resized) {\n                    $src = $resized->getURL($allowSessionGrant);\n                }\n            }\n        }\n\n        // Determine whether loading=\"lazy\" is set\n        $args = self::updateLoadingValue($args, $width, $height);\n\n        // Build the HTML tag\n        $attrs = array_merge(\n            // Set overrideable defaults ('alt' must be present regardless of contents)\n            ['src' => '', 'alt' => ''],\n            // Use all other shortcode arguments\n            $args,\n            // But enforce some values\n            ['id' => '', 'src' => $src]\n        );\n\n        // If file was not found then use the Title value from static::find_error_record() for the alt attr\n        if (!$fileFound) {\n            $attrs['alt'] = $record->Title;\n        }\n\n        // Clean out any empty attributes (aside from alt)\n        $attrs = array_filter($attrs, function ($k, $v) {\n            return strlen(trim($v)) || $k === 'alt';\n        }, ARRAY_FILTER_USE_BOTH);\n\n        $markup = HTML::createTag('img', $attrs);\n\n        // cache it for future reference\n        if ($fileFound) {\n            $cache->set($cacheKey, [\n                'markup' => $markup,\n                'filename' => $record instanceof File ? $record->getFilename() : null,\n                'hash' => $record instanceof File ? $record->getHash() : null,\n            ]);\n        }\n\n        return $markup;\n    }\n\n    /**\n     * Regenerates \"[image id=n]\" shortcode with new src attribute prior to being edited within the CMS.\n     *\n     * @param array $args Arguments passed to the parser\n     * @param string $content Raw shortcode\n     * @param ShortcodeParser $parser Parser\n     * @param string $shortcode Name of shortcode used to register this handler\n     * @param array $extra Extra arguments\n     * @return string Result of the handled shortcode\n     */\n    public static function regenerate_shortcode($args, $content, $parser, $shortcode, $extra = [])\n    {\n        // Check if there is a suitable record\n        $record = static::find_shortcode_record($args);\n        if ($record) {\n            $args['src'] = $record->getURL();\n        }\n\n        // Rebuild shortcode\n        $parts = [];\n        foreach ($args as $name => $value) {\n            $htmlValue = Convert::raw2att($value ?: $name);\n            $parts[] = sprintf('%s=\"%s\"', $name, $htmlValue);\n        }\n        return sprintf(\"[%s %s]\", $shortcode, implode(' ', $parts));\n    }\n\n    /**\n     * Helper method to regenerate all shortcode links.\n     *\n     * @param string $value HTML value\n     * @return string value with links resampled\n     */\n    public static function regenerate_html_links($value)\n    {\n        // Create a shortcode generator which only regenerates links\n        $regenerator = ShortcodeParser::get('regenerator');\n        return $regenerator->parse($value);\n    }\n\n    /**\n     * Gets the cache used by this provider\n     *\n     * @return CacheInterface\n     */\n    public static function getCache()\n    {\n        /** @var CacheInterface $cache */\n        return Injector::inst()->get(CacheInterface::class . '.ImageShortcodeProvider');\n    }\n\n    /**\n     * @inheritdoc\n     */\n    protected static function find_error_record($errorCode)\n    {\n        return Image::create([\n            'Title' => _t(__CLASS__ . '.IMAGENOTFOUND', 'Image not found'),\n        ]);\n    }\n\n    /**\n     * Updated the loading attribute which is used to either lazy-load or eager-load images\n     * Eager-load is the default browser behaviour so when eager loading is specified, the\n     * loading attribute is omitted\n     *\n     * @param array $args\n     * @param int|null $width\n     * @param int|null $height\n     * @return array\n     */\n    private static function updateLoadingValue(array $args, ?int $width, ?int $height): array\n    {\n        if (!Image::getLazyLoadingEnabled()) {\n            return $args;\n        }\n        if (isset($args['loading']) && $args['loading'] == 'eager') {\n            // per image override - unset the loading attribute unset to eager load (default browser behaviour)\n            unset($args['loading']);\n        } elseif ($width && $height) {\n            // width and height must be present to prevent content shifting\n            $args['loading'] = 'lazy';\n        }\n        return $args;\n    }\n}\n", "<?php\n\nnamespace SilverStripe\\Assets\\Tests\\Shortcodes;\n\nuse SilverStripe\\Assets\\File;\nuse Silverstripe\\Assets\\Dev\\TestAssetStore;\nuse SilverStripe\\Core\\Config\\Config;\nuse SilverStripe\\Dev\\SapphireTest;\nuse SilverStripe\\View\\Parsers\\ShortcodeParser;\nuse SilverStripe\\Assets\\Image;\nuse SilverStripe\\Assets\\Shortcodes\\ImageShortcodeProvider;\n\n/**\n * @skipUpgrade\n */\nclass ImageShortcodeProviderTest extends SapphireTest\n{\n\n    protected static $fixture_file = '../ImageTest.yml';\n\n    protected function setUp(): void\n    {\n        parent::setUp();\n\n        // Set backend root to /ImageTest\n        TestAssetStore::activate('ImageTest');\n\n        // Copy test images for each of the fixture references\n        $images = Image::get();\n        /** @var Image $image */\n        foreach ($images as $image) {\n            $sourcePath = __DIR__ . '/../ImageTest/' . $image->Name;\n            $image->setFromLocalFile($sourcePath, $image->Filename);\n        }\n    }\n\n    protected function tearDown(): void\n    {\n        TestAssetStore::reset();\n        parent::tearDown();\n    }\n\n    public function testShortcodeHandlerDoesNotFallBackToFileProperties()\n    {\n        $image = $this->objFromFixture(Image::class, 'imageWithTitle');\n        $parser = new ShortcodeParser();\n        $parser->register('image', [ImageShortcodeProvider::class, 'handle_shortcode']);\n\n        $this->assertEquals(\n            sprintf(\n                '<img src=\"%s\" alt=\"\">',\n                $image->Link()\n            ),\n            $parser->parse(sprintf('[image id=%d]', $image->ID))\n        );\n    }\n\n    public function testShortcodeHandlerUsesShortcodeProperties()\n    {\n        $image = $this->objFromFixture(Image::class, 'imageWithTitle');\n        $parser = new ShortcodeParser();\n        $parser->register('image', [ImageShortcodeProvider::class, 'handle_shortcode']);\n\n        $this->assertEquals(\n            sprintf(\n                '<img src=\"%s\" alt=\"Alt content\" title=\"Title content\">',\n                $image->Link()\n            ),\n            $parser->parse(sprintf(\n                '[image id=\"%d\" alt=\"Alt content\" title=\"Title content\"]',\n                $image->ID\n            ))\n        );\n    }\n\n    public function testShortcodeHandlerAddsDefaultAttributes()\n    {\n        $image = $this->objFromFixture(Image::class, 'imageWithoutTitle');\n        $parser = new ShortcodeParser();\n        $parser->register('image', [ImageShortcodeProvider::class, 'handle_shortcode']);\n\n        $this->assertEquals(\n            sprintf(\n                '<img src=\"%s\" alt=\"\">',\n                $image->Link()\n            ),\n            $parser->parse(sprintf(\n                '[image id=\"%d\"]',\n                $image->ID\n            ))\n        );\n    }\n\n    public function testShortcodeHandlerDoesNotResampleToNonIntegerImagesSizes()\n    {\n        $image = $this->objFromFixture(Image::class, 'imageWithoutTitle');\n        $parser = new ShortcodeParser();\n        $parser->register('image', [ImageShortcodeProvider::class, 'handle_shortcode']);\n\n        $this->assertEquals(\n            sprintf(\n                '<img src=\"%s\" alt=\"\" width=\"50%%\" height=\"auto\">',\n                $image->Link()\n            ),\n            $parser->parse(sprintf(\n                '[image id=\"%d\" alt=\"\" width=\"50%%\" height=\"auto\"]',\n                $image->ID\n            ))\n        );\n    }\n\n    public function testShortcodeHandlerFailsGracefully()\n    {\n        $parser = new ShortcodeParser();\n        $parser->register('image', [ImageShortcodeProvider::class, 'handle_shortcode']);\n\n        $nonExistentImageID = File::get()->max('ID') + 1;\n        $expected = '<img alt=\"Image not found\">';\n        $shortcodes = [\n            '[image id=\"' . $nonExistentImageID . '\"]',\n            '[image id=\"' . $nonExistentImageID . '\" alt=\"my-alt-attr\"]',\n        ];\n        foreach ($shortcodes as $shortcode) {\n            $actual = $parser->parse($shortcode);\n            $this->assertEquals($expected, $actual);\n        }\n    }\n\n    public function testMissingImageDoesNotCache()\n    {\n\n        $parser = new ShortcodeParser();\n        $parser->register('image', [ImageShortcodeProvider::class, 'handle_shortcode']);\n\n        $nonExistentImageID = File::get()->max('ID') + 1;\n        $shortcode = '[image id=\"' . $nonExistentImageID . '\"]';\n\n        // make sure cache is not populated from a previous test\n        $cache = ImageShortcodeProvider::getCache();\n        $cache->clear();\n\n        $args = ['id' => (string)$nonExistentImageID];\n        $cacheKey = ImageShortcodeProvider::getCacheKey($args);\n\n        // assert that cache is empty before parsing shortcode\n        $this->assertNull($cache->get($cacheKey));\n\n        $parser->parse($shortcode);\n\n        // assert that cache is still empty after parsing shortcode\n        $this->assertNull($cache->get($cacheKey));\n    }\n\n    public function testLazyLoading()\n    {\n        $parser = new ShortcodeParser();\n        $parser->register('image', [ImageShortcodeProvider::class, 'handle_shortcode']);\n\n        $id = $this->objFromFixture(Image::class, 'imageWithTitle')->ID;\n\n        // regular shortcode\n        $shortcode = '[image id=\"' . $id . '\" width=\"300\" height=\"200\"]';\n        $this->assertStringContainsString('loading=\"lazy\"', $parser->parse($shortcode));\n\n        // missing width\n        $shortcode = '[image id=\"' . $id . '\" height=\"200\"]';\n        $this->assertStringNotContainsString('loading=\"lazy\"', $parser->parse($shortcode));\n\n        // missing height\n        $shortcode = '[image id=\"' . $id . '\" width=\"300\"]';\n        $this->assertStringNotContainsString('loading=\"lazy\"', $parser->parse($shortcode));\n\n        // loading=\"eager\"\n        $shortcode = '[image id=\"' . $id . '\" width=\"300\" height=\"200\" loading=\"eager\"]';\n        $this->assertStringNotContainsString('loading=\"lazy\"', $parser->parse($shortcode));\n\n        // loading=\"nonsense\"\n        $shortcode = '[image id=\"' . $id . '\" width=\"300\" height=\"200\" loading=\"nonsense\"]';\n        $this->assertStringContainsString('loading=\"lazy\"', $parser->parse($shortcode));\n\n        // globally disabled\n        Config::withConfig(function () use ($id, $parser) {\n            Config::modify()->set(Image::class, 'lazy_loading_enabled', false);\n            // clear-provider-cache is so that we don't get a cached result from the 'regular shortcode'\n            // assertion earlier in this function from ImageShortCodeProvider::handle_shortcode()\n            $shortcode = '[image id=\"' . $id . '\" width=\"300\" height=\"200\" clear-provider-cache=\"1\"]';\n            $this->assertStringNotContainsString('loading=\"lazy\"', $parser->parse($shortcode));\n        });\n    }\n}\n"], "fixing_code": ["<?php\n\nnamespace SilverStripe\\Assets\\Shortcodes;\n\nuse Psr\\SimpleCache\\CacheInterface;\nuse SilverStripe\\Assets\\File;\nuse SilverStripe\\Assets\\Image;\nuse SilverStripe\\Assets\\Storage\\AssetStore;\nuse SilverStripe\\Core\\Convert;\nuse SilverStripe\\Core\\Flushable;\nuse SilverStripe\\Core\\Injector\\Injector;\nuse SilverStripe\\View\\HTML;\nuse SilverStripe\\View\\Parsers\\ShortcodeHandler;\nuse SilverStripe\\View\\Parsers\\ShortcodeParser;\n\n/**\n * Class ImageShortcodeProvider\n *\n * @package SilverStripe\\Forms\\HtmlEditor\n */\nclass ImageShortcodeProvider extends FileShortcodeProvider implements ShortcodeHandler, Flushable\n{\n\n    /**\n     * Gets the list of shortcodes provided by this handler\n     *\n     * @return mixed\n     */\n    public static function get_shortcodes()\n    {\n        return ['image'];\n    }\n\n    /**\n     * Replace\"[image id=n]\" shortcode with an image reference.\n     * Permission checks will be enforced by the file routing itself.\n     *\n     * @param array $args Arguments passed to the parser\n     * @param string $content Raw shortcode\n     * @param ShortcodeParser $parser Parser\n     * @param string $shortcode Name of shortcode used to register this handler\n     * @param array $extra Extra arguments\n     * @return string Result of the handled shortcode\n     */\n    public static function handle_shortcode($args, $content, $parser, $shortcode, $extra = [])\n    {\n        $allowSessionGrant = static::config()->allow_session_grant;\n\n        $cache = static::getCache();\n        $cacheKey = static::getCacheKey($args);\n\n        $item = $cache->get($cacheKey);\n        if ($item) {\n            // Initiate a protected asset grant if necessary\n            if (!empty($item['filename']) && $allowSessionGrant) {\n                Injector::inst()->get(AssetStore::class)->grant($item['filename'], $item['hash']);\n            }\n\n            return $item['markup'];\n        }\n\n        // Find appropriate record, with fallback for error handlers\n        $fileFound = true;\n        $record = static::find_shortcode_record($args, $errorCode);\n        if ($errorCode) {\n            $fileFound = false;\n            $record = static::find_error_record($errorCode);\n        }\n        if (!$record) {\n            return null; // There were no suitable matches at all.\n        }\n\n        // Check if a resize is required\n        $width = null;\n        $height = null;\n        $src = $record->getURL($allowSessionGrant);\n        if ($record instanceof Image) {\n            $width = isset($args['width']) ? (int) $args['width'] : null;\n            $height = isset($args['height']) ? (int) $args['height'] : null;\n            $hasCustomDimensions = ($width && $height);\n            if ($hasCustomDimensions && (($width != $record->getWidth()) || ($height != $record->getHeight()))) {\n                $resized = $record->ResizedImage($width, $height);\n                // Make sure that the resized image actually returns an image\n                if ($resized) {\n                    $src = $resized->getURL($allowSessionGrant);\n                }\n            }\n        }\n\n        // Determine whether loading=\"lazy\" is set\n        $args = self::updateLoadingValue($args, $width, $height);\n\n        // Build the HTML tag\n        $attrs = array_merge(\n            // Set overrideable defaults ('alt' must be present regardless of contents)\n            ['src' => '', 'alt' => ''],\n            // Use all other shortcode arguments\n            $args,\n            // But enforce some values\n            ['id' => '', 'src' => $src]\n        );\n\n        // If file was not found then use the Title value from static::find_error_record() for the alt attr\n        if (!$fileFound) {\n            $attrs['alt'] = $record->Title;\n        }\n\n        // Clean out any empty attributes (aside from alt)\n        $attrs = array_filter($attrs, function ($k, $v) {\n            return strlen(trim($v)) || $k === 'alt';\n        }, ARRAY_FILTER_USE_BOTH);\n\n        $markup = HTML::createTag('img', $attrs);\n\n        // cache it for future reference\n        if ($fileFound) {\n            $cache->set($cacheKey, [\n                'markup' => $markup,\n                'filename' => $record instanceof File ? $record->getFilename() : null,\n                'hash' => $record instanceof File ? $record->getHash() : null,\n            ]);\n        }\n\n        return $markup;\n    }\n\n    /**\n     * Regenerates \"[image id=n]\" shortcode with new src attribute prior to being edited within the CMS.\n     *\n     * @param array $args Arguments passed to the parser\n     * @param string $content Raw shortcode\n     * @param ShortcodeParser $parser Parser\n     * @param string $shortcode Name of shortcode used to register this handler\n     * @param array $extra Extra arguments\n     * @return string Result of the handled shortcode\n     */\n    public static function regenerate_shortcode($args, $content, $parser, $shortcode, $extra = [])\n    {\n        $allowSessionGrant = static::config()->allow_session_grant;\n\n        // Check if there is a suitable record\n        $record = static::find_shortcode_record($args);\n        if ($record) {\n            $args['src'] = $record->getURL($allowSessionGrant);\n        }\n\n        // Rebuild shortcode\n        $parts = [];\n        foreach ($args as $name => $value) {\n            $htmlValue = Convert::raw2att($value ?: $name);\n            $parts[] = sprintf('%s=\"%s\"', $name, $htmlValue);\n        }\n        return sprintf(\"[%s %s]\", $shortcode, implode(' ', $parts));\n    }\n\n    /**\n     * Helper method to regenerate all shortcode links.\n     *\n     * @param string $value HTML value\n     * @return string value with links resampled\n     */\n    public static function regenerate_html_links($value)\n    {\n        // Create a shortcode generator which only regenerates links\n        $regenerator = ShortcodeParser::get('regenerator');\n        return $regenerator->parse($value);\n    }\n\n    /**\n     * Gets the cache used by this provider\n     *\n     * @return CacheInterface\n     */\n    public static function getCache()\n    {\n        /** @var CacheInterface $cache */\n        return Injector::inst()->get(CacheInterface::class . '.ImageShortcodeProvider');\n    }\n\n    /**\n     * @inheritdoc\n     */\n    protected static function find_error_record($errorCode)\n    {\n        return Image::create([\n            'Title' => _t(__CLASS__ . '.IMAGENOTFOUND', 'Image not found'),\n        ]);\n    }\n\n    /**\n     * Updated the loading attribute which is used to either lazy-load or eager-load images\n     * Eager-load is the default browser behaviour so when eager loading is specified, the\n     * loading attribute is omitted\n     *\n     * @param array $args\n     * @param int|null $width\n     * @param int|null $height\n     * @return array\n     */\n    private static function updateLoadingValue(array $args, ?int $width, ?int $height): array\n    {\n        if (!Image::getLazyLoadingEnabled()) {\n            return $args;\n        }\n        if (isset($args['loading']) && $args['loading'] == 'eager') {\n            // per image override - unset the loading attribute unset to eager load (default browser behaviour)\n            unset($args['loading']);\n        } elseif ($width && $height) {\n            // width and height must be present to prevent content shifting\n            $args['loading'] = 'lazy';\n        }\n        return $args;\n    }\n}\n", "<?php\n\nnamespace SilverStripe\\Assets\\Tests\\Shortcodes;\n\nuse SilverStripe\\Assets\\File;\nuse Silverstripe\\Assets\\Dev\\TestAssetStore;\nuse SilverStripe\\Assets\\FilenameParsing\\ParsedFileID;\nuse SilverStripe\\Assets\\Storage\\AssetStore;\nuse SilverStripe\\Core\\Config\\Config;\nuse SilverStripe\\Dev\\SapphireTest;\nuse SilverStripe\\View\\Parsers\\ShortcodeParser;\nuse SilverStripe\\Assets\\Image;\nuse SilverStripe\\Assets\\Shortcodes\\ImageShortcodeProvider;\nuse SilverStripe\\Assets\\Shortcodes\\FileShortcodeProvider;\nuse SilverStripe\\Core\\Injector\\Injector;\nuse SilverStripe\\Security\\InheritedPermissions;\nuse SilverStripe\\Security\\Member;\n\n/**\n * @skipUpgrade\n */\nclass ImageShortcodeProviderTest extends SapphireTest\n{\n\n    protected static $fixture_file = '../ImageTest.yml';\n\n    protected function setUp(): void\n    {\n        parent::setUp();\n\n        // Set backend root to /ImageTest\n        TestAssetStore::activate('ImageTest');\n\n        // Copy test images for each of the fixture references\n        $images = Image::get();\n        /** @var Image $image */\n        foreach ($images as $image) {\n            $sourcePath = __DIR__ . '/../ImageTest/' . $image->Name;\n            $image->setFromLocalFile($sourcePath, $image->Filename);\n        }\n    }\n\n    protected function tearDown(): void\n    {\n        TestAssetStore::reset();\n        parent::tearDown();\n    }\n\n    public function testShortcodeHandlerDoesNotFallBackToFileProperties()\n    {\n        $image = $this->objFromFixture(Image::class, 'imageWithTitle');\n        $parser = new ShortcodeParser();\n        $parser->register('image', [ImageShortcodeProvider::class, 'handle_shortcode']);\n\n        $this->assertEquals(\n            sprintf(\n                '<img src=\"%s\" alt=\"\">',\n                $image->Link()\n            ),\n            $parser->parse(sprintf('[image id=%d]', $image->ID))\n        );\n    }\n\n    public function testShortcodeHandlerUsesShortcodeProperties()\n    {\n        $image = $this->objFromFixture(Image::class, 'imageWithTitle');\n        $parser = new ShortcodeParser();\n        $parser->register('image', [ImageShortcodeProvider::class, 'handle_shortcode']);\n\n        $this->assertEquals(\n            sprintf(\n                '<img src=\"%s\" alt=\"Alt content\" title=\"Title content\">',\n                $image->Link()\n            ),\n            $parser->parse(sprintf(\n                '[image id=\"%d\" alt=\"Alt content\" title=\"Title content\"]',\n                $image->ID\n            ))\n        );\n    }\n\n    public function testShortcodeHandlerAddsDefaultAttributes()\n    {\n        $image = $this->objFromFixture(Image::class, 'imageWithoutTitle');\n        $parser = new ShortcodeParser();\n        $parser->register('image', [ImageShortcodeProvider::class, 'handle_shortcode']);\n\n        $this->assertEquals(\n            sprintf(\n                '<img src=\"%s\" alt=\"\">',\n                $image->Link()\n            ),\n            $parser->parse(sprintf(\n                '[image id=\"%d\"]',\n                $image->ID\n            ))\n        );\n    }\n\n    public function testShortcodeHandlerDoesNotResampleToNonIntegerImagesSizes()\n    {\n        $image = $this->objFromFixture(Image::class, 'imageWithoutTitle');\n        $parser = new ShortcodeParser();\n        $parser->register('image', [ImageShortcodeProvider::class, 'handle_shortcode']);\n\n        $this->assertEquals(\n            sprintf(\n                '<img src=\"%s\" alt=\"\" width=\"50%%\" height=\"auto\">',\n                $image->Link()\n            ),\n            $parser->parse(sprintf(\n                '[image id=\"%d\" alt=\"\" width=\"50%%\" height=\"auto\"]',\n                $image->ID\n            ))\n        );\n    }\n\n    public function testShortcodeHandlerFailsGracefully()\n    {\n        $parser = new ShortcodeParser();\n        $parser->register('image', [ImageShortcodeProvider::class, 'handle_shortcode']);\n\n        $nonExistentImageID = File::get()->max('ID') + 1;\n        $expected = '<img alt=\"Image not found\">';\n        $shortcodes = [\n            '[image id=\"' . $nonExistentImageID . '\"]',\n            '[image id=\"' . $nonExistentImageID . '\" alt=\"my-alt-attr\"]',\n        ];\n        foreach ($shortcodes as $shortcode) {\n            $actual = $parser->parse($shortcode);\n            $this->assertEquals($expected, $actual);\n        }\n    }\n\n    public function testMissingImageDoesNotCache()\n    {\n\n        $parser = new ShortcodeParser();\n        $parser->register('image', [ImageShortcodeProvider::class, 'handle_shortcode']);\n\n        $nonExistentImageID = File::get()->max('ID') + 1;\n        $shortcode = '[image id=\"' . $nonExistentImageID . '\"]';\n\n        // make sure cache is not populated from a previous test\n        $cache = ImageShortcodeProvider::getCache();\n        $cache->clear();\n\n        $args = ['id' => (string)$nonExistentImageID];\n        $cacheKey = ImageShortcodeProvider::getCacheKey($args);\n\n        // assert that cache is empty before parsing shortcode\n        $this->assertNull($cache->get($cacheKey));\n\n        $parser->parse($shortcode);\n\n        // assert that cache is still empty after parsing shortcode\n        $this->assertNull($cache->get($cacheKey));\n    }\n\n    public function testLazyLoading()\n    {\n        $parser = new ShortcodeParser();\n        $parser->register('image', [ImageShortcodeProvider::class, 'handle_shortcode']);\n\n        $id = $this->objFromFixture(Image::class, 'imageWithTitle')->ID;\n\n        // regular shortcode\n        $shortcode = '[image id=\"' . $id . '\" width=\"300\" height=\"200\"]';\n        $this->assertStringContainsString('loading=\"lazy\"', $parser->parse($shortcode));\n\n        // missing width\n        $shortcode = '[image id=\"' . $id . '\" height=\"200\"]';\n        $this->assertStringNotContainsString('loading=\"lazy\"', $parser->parse($shortcode));\n\n        // missing height\n        $shortcode = '[image id=\"' . $id . '\" width=\"300\"]';\n        $this->assertStringNotContainsString('loading=\"lazy\"', $parser->parse($shortcode));\n\n        // loading=\"eager\"\n        $shortcode = '[image id=\"' . $id . '\" width=\"300\" height=\"200\" loading=\"eager\"]';\n        $this->assertStringNotContainsString('loading=\"lazy\"', $parser->parse($shortcode));\n\n        // loading=\"nonsense\"\n        $shortcode = '[image id=\"' . $id . '\" width=\"300\" height=\"200\" loading=\"nonsense\"]';\n        $this->assertStringContainsString('loading=\"lazy\"', $parser->parse($shortcode));\n\n        // globally disabled\n        Config::withConfig(function () use ($id, $parser) {\n            Config::modify()->set(Image::class, 'lazy_loading_enabled', false);\n            // clear-provider-cache is so that we don't get a cached result from the 'regular shortcode'\n            // assertion earlier in this function from ImageShortCodeProvider::handle_shortcode()\n            $shortcode = '[image id=\"' . $id . '\" width=\"300\" height=\"200\" clear-provider-cache=\"1\"]';\n            $this->assertStringNotContainsString('loading=\"lazy\"', $parser->parse($shortcode));\n        });\n    }\n\n    public function testRegenerateShortcode()\n    {\n        $assetStore = Injector::inst()->get(AssetStore::class);\n        $member = Member::create();\n        $member->write();\n        // Logout first to throw away the existing session which may have image grants.\n        $this->logOut();\n        $this->logInAs($member);\n        // image is in protected asset store\n        $image = $this->objFromFixture(Image::class, 'imageWithTitle');\n        $image->CanViewType = InheritedPermissions::ONLY_THESE_USERS;\n        $image->write();\n        $url = $image->getUrl(false);\n        $args = [\n            'id' => $image->ID,\n            'src' => $url,\n            'width' => '550',\n            'height' => '366',\n            'class' => 'leftAlone ss-htmleditorfield-file image',\n        ];\n        $shortHash = substr($image->getHash(), 0, 10);\n        $expected = implode(' ', [\n            '[image id=\"' . $image->ID . '\" src=\"/assets/folder/' . $shortHash . '/test-image.png\" width=\"550\"',\n            'height=\"366\" class=\"leftAlone ss-htmleditorfield-file image\"]'\n        ]);\n        $parsedFileID = new ParsedFileID($image->getFilename(), $image->getHash());\n        $html = ImageShortcodeProvider::regenerate_shortcode($args, '', '', 'image');\n        $this->assertSame($expected, $html);\n        $this->assertFalse($assetStore->isGranted($parsedFileID));\n        Config::modify()->set(FileShortcodeProvider::class, 'allow_session_grant', true);\n        $html = ImageShortcodeProvider::regenerate_shortcode($args, '', '', 'image');\n        $this->assertSame($expected, $html);\n        $this->assertTrue($assetStore->isGranted($parsedFileID));\n    }\n}\n"], "filenames": ["src/Shortcodes/ImageShortcodeProvider.php", "tests/php/Shortcodes/ImageShortcodeProviderTest.php"], "buggy_code_start_loc": [138, 6], "buggy_code_end_loc": [143, 189], "fixing_code_start_loc": [139, 7], "fixing_code_end_loc": [145, 231], "type": "CWE-287", "message": "Silverstripe silverstripe/assets through 1.10 is vulnerable to improper access control that allows protected images to be published by changing an existing image short code on website content.", "other": {"cve": {"id": "CVE-2022-29858", "sourceIdentifier": "cve@mitre.org", "published": "2022-06-28T22:15:07.997", "lastModified": "2022-07-08T01:08:03.557", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Silverstripe silverstripe/assets through 1.10 is vulnerable to improper access control that allows protected images to be published by changing an existing image short code on website content."}, {"lang": "es", "value": "Silverstripe silverstripe/assets hasta la versi\u00f3n 1.10 es vulnerable a un control de acceso inadecuado que permite publicar im\u00e1genes protegidas cambiando un c\u00f3digo corto de imagen existente en el contenido del sitio web"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-287"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:silverstripe:assets:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.10.1", "matchCriteriaId": "3949D792-1E48-4E59-8F10-50E3CD3F0745"}]}]}], "references": [{"url": "https://forum.silverstripe.org/c/releases", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "https://github.com/silverstripe/silverstripe-assets/commit/5f6a73b010c01587ffbfb954441f6b7cbb54e767", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/90e17d95-9f2f-44eb-9f26-49fa13a41d5a/", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://www.silverstripe.org/blog/tag/release", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "https://www.silverstripe.org/download/security-releases/", "source": "cve@mitre.org", "tags": ["Not Applicable", "Vendor Advisory"]}, {"url": "https://www.silverstripe.org/download/security-releases/cve-2022-29858", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/silverstripe/silverstripe-assets/commit/5f6a73b010c01587ffbfb954441f6b7cbb54e767"}}