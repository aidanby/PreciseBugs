{"buggy_code": ["$Id: Changelog.txt,v 1.187 2013/06/06 21:36:39 nanard Exp $\nminiUPnP client Changelog.\n\n2013/08/01:\n  define MAXHOSTNAMELEN if not already done\n\n2013/06/06:\n  update upnpreplyparse to allow larger values (128 chars instead of 64)\n\n2013/05/14:\n  Update upnpreplyparse to take into account \"empty\" elements\n  validate upnpreplyparse.c code with \"make check\"\n\n2013/05/03:\n  Fix Solaris build thanks to Maciej Ma\u0142ecki\n\n2013/04/27:\n  Fix testminiwget.sh for BSD\n\n2013/03/23:\n  Fixed Makefile for *BSD\n\n2013/03/11:\n  Update Makefile to use JNAerator version 0.11\n\n2013/02/11:\n  Fix testminiwget.sh for use with dash\n  Use $(DESTDIR) in Makefile\n\nVERSION 1.8 : released 2013/02/06\n\n2012/10/16:\n  fix testminiwget with no IPv6 support\n\n2012/09/27:\n  Rename all include guards to not clash with C99\n  (7.1.3 Reserved identifiers).\n\n2012/08/30:\n  Added -e option to upnpc program (set description for port mappings)\n\n2012/08/29:\n  Python 3 support (thanks to Christopher Foo)\n\n2012/08/11:\n  Fix a memory link in UPNP_GetValidIGD()\n  Try to handle scope id in link local IPv6 URL under MS Windows\n\n2012/07/20:\n  Disable HAS_IP_MREQN on DragonFly BSD\n\n2012/06/28:\n  GetUPNPUrls() now inserts scope into link-local IPv6 addresses\n\n2012/06/23:\n  More error return checks in upnpc.c\n  #define MINIUPNPC_GET_SRC_ADDR enables receivedata() to get scope_id\n  parseURL() now parses IPv6 addresses scope\n  new parameter for miniwget() : IPv6 address scope\n  increment API_VERSION to 9\n\n2012/06/20:\n  fixed CMakeLists.txt\n\n2012/05/29\n  Improvements in testminiwget.sh\n\nVERSION 1.7 : released 2012/05/24\n\n2012/05/01:\n  Cleanup settings of CFLAGS in Makefile\n  Fix signed/unsigned integer comparaisons\n\n2012/04/20:\n  Allow to specify protocol with TCP or UDP for -A option\n\n2012/04/09:\n  Only try to fetch XML description once in UPNP_GetValidIGD()\n  Added -ansi flag to compilation, and fixed C++ comments to ANSI C comments.\n\n2012/04/05:\n  minor improvements to minihttptestserver.c\n\n2012/03/15:\n  upnperrors.c returns valid error string for unrecognized error codes\n\n2012/03/08:\n  make minihttptestserver listen on loopback interface instead of 0.0.0.0\n\n2012/01/25:\n  Maven installation thanks to Alexey Kuznetsov\n\n2012/01/21:\n  Replace WIN32 macro by _WIN32\n\n2012/01/19:\n  Fixes in java wrappers thanks to Alexey Kuznetsov :\n    https://github.com/axet/miniupnp/tree/fix-javatest/miniupnpc\n  Make and install .deb packages (python) thanks to Alexey Kuznetsov :\n    https://github.com/axet/miniupnp/tree/feature-debbuild/miniupnpc\n\n2012/01/07:\n  The multicast interface can now be specified by name with IPv4.\n\n2012/01/02:\n  Install man page\n\n2011/11/25:\n  added header to Port Mappings list in upnpc.c\n\n2011/10/09:\n  Makefile : make clean now removes jnaerator generated files.\n  MINIUPNPC_VERSION in miniupnpc.h (updated by make)\n\n2011/09/12:\n  added rootdescURL to UPNPUrls structure.\n\nVERSION 1.6 : released 2011/07/25\n\n2011/07/25:\n  Update doc for version 1.6 release\n\n2011/06/18:\n  Fix for windows in miniwget.c\n\n2011/06/04:\n  display remote host in port mapping listing\n\n2011/06/03:\n  Fix in make install : there were missing headers\n\n2011/05/26:\n  Fix the socket leak in miniwget thanks to Richard Marsh.\n  Permit to add leaseduration in -a command. Display lease duration.\n\n2011/05/15:\n  Try both LinkLocal and SiteLocal multicast address for SSDP in IPv6\n\n2011/05/09:\n  add a test in testminiwget.sh.\n  more error checking in miniwget.c\n\n2011/05/06:\n  Adding some tool to test and validate miniwget.c\n  simplified and debugged miniwget.c\n\n2011/04/11:\n  moving ReceiveData() to a receivedata.c file.\n  parsing presentation url\n  adding IGD v2 WANIPv6FirewallControl commands\n\n2011/04/10:\n  update of miniupnpcmodule.c\n  comments in miniwget.c, update in testminiwget\n  Adding errors codes from IGD v2\n  new functions in upnpc.c for IGD v2\n\n2011/04/09:\n  Support for litteral ip v6 address in miniwget\n\n2011/04/08:\n  Adding support for urn:schemas-upnp-org:service:WANIPv6FirewallControl:1\n  Updating APIVERSION\n  Supporting IPV6 in upnpDiscover()\n  Adding a -6 option to upnpc command line tool\n\n2011/03/18:\n  miniwget/parseURL() : return an error when url param is null.\n  fixing GetListOfPortMappings()\n\n2011/03/14:\n  upnpDiscover() now reporting an error code.\n  improvements in comments.\n\n2011/03/11:\n  adding miniupnpcstrings.h.cmake and CMakeLists.txt files.\n\n2011/02/15:\n  Implementation of GetListOfPortMappings()\n\n2011/02/07:\n  updates to minixml to support character data starting with spaces\n  minixml now support CDATA\n  upnpreplyparse treats <NewPortListing> specificaly\n  change in simpleUPnPcommand to return the buffer (simplification)\n\n2011/02/06:\n  Added leaseDuration argument to AddPortMapping()\n  Starting to implement GetListOfPortMappings()\n\n2011/01/11:\n  updating wingenminiupnpcstrings.c\n\n2011/01/04:\n  improving updateminiupnpcstrings.sh\n\nVERSION 1.5 : released 2011/01/01\n\n2010/12/21:\n  use NO_GETADDRINFO macro to disable the use of getaddrinfo/freeaddrinfo\n\n2010/12/11:\n  Improvements on getHTTPResponse() code.\n\n2010/12/09:\n  new code for miniwget that handle Chunked transfer encoding\n  using getHTTPResponse() in SOAP call code\n  Adding MANIFEST.in for 'python setup.py bdist_rpm'\n\n2010/11/25:\n  changes to minissdpc.c to compile under Win32.\n  see http://miniupnp.tuxfamily.org/forum/viewtopic.php?t=729\n\n2010/09/17:\n  Various improvement to Makefile from Micha\u0142 G\u00f3rny\n\n2010/08/05:\n  Adding the script \"external-ip.sh\" from Reuben Hawkins\n\n2010/06/09:\n  update to python module to match modification made on 2010/04/05\n  update to Java test code to match modification made on 2010/04/05\n  all UPNP_* function now return an error if the SOAP request failed\n  at HTTP level.\n\n2010/04/17:\n  Using GetBestRoute() under win32 in order to find the\n  right interface to use.\n\n2010/04/12:\n  Retrying with HTTP/1.1 if HTTP/1.0 failed. see\n  http://miniupnp.tuxfamily.org/forum/viewtopic.php?p=1703\n\n2010/04/07:\n  avoid returning duplicates in upnpDiscover()\n\n2010/04/05:\n  Create a connecthostport.h/.c with connecthostport() function\n  and use it in miniwget and miniupnpc.\n  Use getnameinfo() instead of inet_ntop or inet_ntoa\n  Work to make miniupnpc IPV6 compatible...\n  Add java test code.\n  Big changes in order to support device having both WANIPConnection\n  and WANPPPConnection.\n\n2010/04/04:\n  Use getaddrinfo() instead of gethostbyname() in miniwget.\n\n2010/01/06:\n  #define _DARWIN_C_SOURCE for Mac OS X\n\n2009/12/19:\n  Improve MinGW32 build\n\n2009/12/11:\n  adding a MSVC9 project to build the static library and executable\n\n2009/12/10:\n  Fixing some compilation stuff for Windows/MinGW\n\n2009/12/07:\n  adaptations in Makefile and updateminiupnpcstring.sh for AmigaOS\n  some fixes for Windows when using virtual ethernet adapters (it is the\n  case with VMWare installed).\n\n2009/12/04:\n  some fixes for AmigaOS compilation\n  Changed HTTP version to HTTP/1.0 for Soap too (to prevent chunked\n  transfer encoding)\n\n2009/12/03:\n  updating printIDG and testigddescparse.c for debug.\n  modifications to compile under AmigaOS\n  adding a testminiwget program\n  Changed miniwget to advertise itself as HTTP/1.0 to prevent chunked\n  transfer encoding\n\n2009/11/26:\n  fixing updateminiupnpcstrings.sh to take into account\n  which command that does not return an error code.\n\nVERSION 1.4 : released 2009/10/30\n\n2009/10/16:\n  using Py_BEGIN_ALLOW_THREADS and Py_END_ALLOW_THREADS in python module.\n\n2009/10/10:\n  Some fixes for compilation under Solaris\n  compilation fixes : http://miniupnp.tuxfamily.org/forum/viewtopic.php?p=1464\n\n2009/09/21:\n  fixing the code to ignore EINTR during connect() calls.\n\n2009/08/07:\n  Set socket timeout for connect()\n  Some cleanup in miniwget.c\n\n2009/08/04:\n  remove multiple redirections with -d in upnpc.c\n  Print textual error code in upnpc.c\n  Ignore EINTR during the connect() and poll() calls.\n\n2009/07/29:\n  fix in updateminiupnpcstrings.sh if OS name contains \"/\"\n  Sending a correct value for MX: field in SSDP request\n\n2009/07/20:\n  Change the Makefile to compile under Mac OS X\n  Fixed a stackoverflow in getDevicesFromMiniSSDPD()\n\n2009/07/09:\n  Compile under Haiku\n  generate miniupnpcstrings.h.in from miniupnpcstrings.h\n\n2009/06/04:\n  patching to compile under CygWin and cross compile for minGW\n\nVERSION 1.3 :\n\n2009/04/17:\n  updating python module\n  Use strtoull() when using C99\n\n2009/02/28:\n  Fixed miniwget.c for compiling under sun\n\n2008/12/18:\n  cleanup in Makefile (thanks to Paul de Weerd)\n  minissdpc.c : win32 compatibility\n  miniupnpc.c : changed xmlns prefix from 'm' to 'u'\n  Removed NDEBUG (using DEBUG)\n\n2008/10/14:\n  Added the ExternalHost argument to DeletePortMapping()\n\n2008/10/11:\n  Added the ExternalHost argument to AddPortMapping()\n  Put a correct User-Agent: header in HTTP requests.\n\nVERSION 1.2 :\n\n2008/10/07:\n  Update docs\n\n2008/09/25:\n  Integrated sameport patch from Dario Meloni : Added a \"sameport\"\n  argument to upnpDiscover().\n\n2008/07/18:\n  small modif to make Clang happy :)\n\n2008/07/17:\n  #define SOAPPREFIX \"s\" in miniupnpc.c in order to remove SOAP-ENV...\n\n2008/07/14:\n  include declspec.h in installation (to /usr/include/miniupnpc)\n\nVERSION 1.1 :\n\n2008/07/04:\n  standard options for install/ln instead of gnu-specific stuff.\n\n2008/07/03:\n  now builds a .dll and .lib with win32. (mingw32)\n\n2008/04/28:\n  make install now install the binary of the upnpc tool\n\n2008/04/27:\n  added testupnpigd.py\n  added error strings for miniupnpc \"internal\" errors\n  improved python module error/exception reporting.\n\n2008/04/23:\n  Completely rewrite igd_desc_parse.c in order to be compatible with\n  Linksys WAG200G\n  Added testigddescparse\n  updated python module\n\nVERSION 1.0 :\n\n2008/02/21:\n  put some #ifdef DEBUG around DisplayNameValueList()\n\n2008/02/18:\n  Improved error reporting in upnpcommands.c\n  UPNP_GetStatusInfo() returns LastConnectionError\n\n2008/02/16:\n  better error handling in minisoap.c\n  improving display of \"valid IGD found\" in upnpc.c\n\n2008/02/03:\n  Fixing UPNP_GetValidIGD()\n  improved make install :)\n\n2007/12/22:\n  Adding upnperrors.c/h to provide a strupnperror() function\n  used to translate UPnP error codes to string.\n\n2007/12/19:\n  Fixing getDevicesFromMiniSSDPD()\n  improved error reporting of UPnP functions\n\n2007/12/18:\n  It is now possible to specify a different location for MiniSSDPd socket.\n  working with MiniSSDPd is now more efficient.\n  python module improved.\n\n2007/12/16:\n  improving error reporting\n\n2007/12/13:\n  Try to improve compatibility by using HTTP/1.0 instead of 1.1 and\n  XML a bit different for SOAP.\n\n2007/11/25:\n  fixed select() call for linux\n\n2007/11/15:\n  Added -fPIC to CFLAG for better shared library code.\n\n2007/11/02:\n  Fixed a potential socket leak in miniwget2()\n\n2007/10/16:\n  added a parameter to upnpDiscover() in order to allow the use of another\n  interface than the default multicast interface.\n\n2007/10/12:\n  Fixed the creation of symbolic link in Makefile\n\n2007/10/08:\n  Added man page\n\n2007/10/02:\n  fixed memory bug in GetUPNPUrls()\n\n2007/10/01:\n  fixes in the Makefile\n  Added UPNP_GetIGDFromUrl() and adapted the sample program accordingly.\n  Added SONAME in the shared library to please debian :)\n  fixed MS Windows compilation (minissdpd is not available under MS Windows).\n\n2007/09/25:\n  small change to Makefile to be able to install in a different location\n  (default is /usr)\n\n2007/09/24:\n  now compiling both shared and static library\n\n2007/09/19:\n  Cosmetic changes on upnpc.c\n\n2007/09/02:\n  adapting to new miniSSDPd (release version ?)\n\n2007/08/31:\n  Usage of miniSSDPd to skip discovery process.\n\n2007/08/27:\n  fixed python module to allow compilation with Python older than Python 2.4\n\n2007/06/12:\n  Added a python module.\n\n2007/05/19:\n  Fixed compilation under MinGW\n\n2007/05/15:\n  fixed a memory leak in AddPortMapping()\n  Added testupnpreplyparse executable to check the parsing of\n  upnp soap messages\n  minixml now ignore namespace prefixes.\n\n2007/04/26:\n  upnpc now displays external ip address with -s or -l\n\n2007/04/11:\n  changed MINIUPNPC_URL_MAXSIZE to 128 to accomodate the \"BT Voyager 210\"\n\n2007/03/19:\n  cleanup in miniwget.c\n\n2007/03/01:\n  Small typo fix...\n\n2007/01/30:\n  Now parsing the HTTP header from SOAP responses in order to\n  get content-length value.\n\n2007/01/29:\n  Fixed the Soap Query to speedup the HTTP request.\n  added some Win32 DLL stuff...\n\n2007/01/27:\n  Fixed some WIN32 compatibility issues\n\n2006/12/14:\n  Added UPNPIGD_IsConnected() function in miniupnp.c/.h\n  Added UPNP_GetValidIGD() in miniupnp.c/.h\n  cleaned upnpc.c main(). now using UPNP_GetValidIGD()\n\n2006/12/07:\n  Version 1.0-RC1 released\n\n2006/12/03:\n  Minor changes to compile under SunOS/Solaris\n\n2006/11/30:\n  made a minixml parser validator program\n  updated minixml to handle attributes correctly\n\n2006/11/22:\n  Added a -r option to the upnpc sample thanks to Alexander Hubmann.\n\n2006/11/19:\n  Cleanup code to make it more ANSI C compliant\n\n2006/11/10:\n  detect and display local lan address.\n\n2006/11/04:\n  Packets and Bytes Sent/Received are now unsigned int.\n\n2006/11/01:\n  Bug fix thanks to Giuseppe D'Angelo\n\n2006/10/31:\n  C++ compatibility for .h files.\n  Added a way to get ip Address on the LAN used to reach the IGD.\n\n2006/10/25:\n  Added M-SEARCH to the services in the discovery process.\n\n2006/10/22:\n  updated the Makefile to use makedepend, added a \"make install\"\n  update Makefile\n\n2006/10/20:\n  fixing the description url parsing thanks to patch sent by\n  Wayne Dawe.\n  Fixed/translated some comments.\n  Implemented a better discover process, first looking\n  for IGD then for root devices (as some devices only reply to\n  M-SEARCH for root devices).\n\n2006/09/02:\n  added freeUPNPDevlist() function.\n\n2006/08/04:\n  More command line arguments checking\n\n2006/08/01:\n  Added the .bat file to compile under Win32 with minGW32\n\n2006/07/31:\n  Fixed the rootdesc parser (igd_desc_parse.c)\n\n2006/07/20:\n  parseMSEARCHReply() is now returning the ST: line as well\n  starting changes to detect several UPnP devices on the network\n\n2006/07/19:\n  using GetCommonLinkProperties to get down/upload bitrate\n\n", "/* $Id: miniwget.c,v 1.60 2013/10/07 10:03:16 nanard Exp $ */\n/* Project : miniupnp\n * Website : http://miniupnp.free.fr/\n * Author : Thomas Bernard\n * Copyright (c) 2005-2013 Thomas Bernard\n * This software is subject to the conditions detailed in the\n * LICENCE file provided in this distribution. */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n#ifdef _WIN32\n#include <winsock2.h>\n#include <ws2tcpip.h>\n#include <io.h>\n#define MAXHOSTNAMELEN 64\n#define MIN(x,y) (((x)<(y))?(x):(y))\n#define snprintf _snprintf\n#define socklen_t int\n#ifndef strncasecmp\n#if defined(_MSC_VER) && (_MSC_VER >= 1400)\n#define strncasecmp _memicmp\n#else /* defined(_MSC_VER) && (_MSC_VER >= 1400) */\n#define strncasecmp memicmp\n#endif /* defined(_MSC_VER) && (_MSC_VER >= 1400) */\n#endif /* #ifndef strncasecmp */\n#else /* #ifdef _WIN32 */\n#include <unistd.h>\n#include <sys/param.h>\n#if defined(__amigaos__) && !defined(__amigaos4__)\n#define socklen_t int\n#else /* #if defined(__amigaos__) && !defined(__amigaos4__) */\n#include <sys/select.h>\n#endif /* #else defined(__amigaos__) && !defined(__amigaos4__) */\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <net/if.h>\n#include <netdb.h>\n#define closesocket close\n/* defining MINIUPNPC_IGNORE_EINTR enable the ignore of interruptions\n * during the connect() call */\n#define MINIUPNPC_IGNORE_EINTR\n#endif /* #else _WIN32 */\n#if defined(__sun) || defined(sun)\n#define MIN(x,y) (((x)<(y))?(x):(y))\n#endif\n\n#include \"miniupnpcstrings.h\"\n#include \"miniwget.h\"\n#include \"connecthostport.h\"\n#include \"receivedata.h\"\n\n#ifndef MAXHOSTNAMELEN\n#define MAXHOSTNAMELEN 64\n#endif\n\n/*\n * Read a HTTP response from a socket.\n * Process Content-Length and Transfer-encoding headers.\n * return a pointer to the content buffer, which length is saved\n * to the length parameter.\n */\nvoid *\ngetHTTPResponse(int s, int * size)\n{\n\tchar buf[2048];\n\tint n;\n\tint endofheaders = 0;\n\tint chunked = 0;\n\tint content_length = -1;\n\tunsigned int chunksize = 0;\n\tunsigned int bytestocopy = 0;\n\t/* buffers : */\n\tchar * header_buf;\n\tunsigned int header_buf_len = 2048;\n\tunsigned int header_buf_used = 0;\n\tchar * content_buf;\n\tunsigned int content_buf_len = 2048;\n\tunsigned int content_buf_used = 0;\n\tchar chunksize_buf[32];\n\tunsigned int chunksize_buf_index;\n\n\theader_buf = malloc(header_buf_len);\n\tcontent_buf = malloc(content_buf_len);\n\tchunksize_buf[0] = '\\0';\n\tchunksize_buf_index = 0;\n\n\twhile((n = receivedata(s, buf, 2048, 5000, NULL)) > 0)\n\t{\n\t\tif(endofheaders == 0)\n\t\t{\n\t\t\tint i;\n\t\t\tint linestart=0;\n\t\t\tint colon=0;\n\t\t\tint valuestart=0;\n\t\t\tif(header_buf_used + n > header_buf_len) {\n\t\t\t\theader_buf = realloc(header_buf, header_buf_used + n);\n\t\t\t\theader_buf_len = header_buf_used + n;\n\t\t\t}\n\t\t\tmemcpy(header_buf + header_buf_used, buf, n);\n\t\t\theader_buf_used += n;\n\t\t\t/* search for CR LF CR LF (end of headers)\n\t\t\t * recognize also LF LF */\n\t\t\ti = 0;\n\t\t\twhile(i < ((int)header_buf_used-1) && (endofheaders == 0)) {\n\t\t\t\tif(header_buf[i] == '\\r') {\n\t\t\t\t\ti++;\n\t\t\t\t\tif(header_buf[i] == '\\n') {\n\t\t\t\t\t\ti++;\n\t\t\t\t\t\tif(i < (int)header_buf_used && header_buf[i] == '\\r') {\n\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t\tif(i < (int)header_buf_used && header_buf[i] == '\\n') {\n\t\t\t\t\t\t\t\tendofheaders = i+1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if(header_buf[i] == '\\n') {\n\t\t\t\t\ti++;\n\t\t\t\t\tif(header_buf[i] == '\\n') {\n\t\t\t\t\t\tendofheaders = i+1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tif(endofheaders == 0)\n\t\t\t\tcontinue;\n\t\t\t/* parse header lines */\n\t\t\tfor(i = 0; i < endofheaders - 1; i++) {\n\t\t\t\tif(colon <= linestart && header_buf[i]==':')\n\t\t\t\t{\n\t\t\t\t\tcolon = i;\n\t\t\t\t\twhile(i < (endofheaders-1)\n\t\t\t\t\t      && (header_buf[i+1] == ' ' || header_buf[i+1] == '\\t'))\n\t\t\t\t\t\ti++;\n\t\t\t\t\tvaluestart = i + 1;\n\t\t\t\t}\n\t\t\t\t/* detecting end of line */\n\t\t\t\telse if(header_buf[i]=='\\r' || header_buf[i]=='\\n')\n\t\t\t\t{\n\t\t\t\t\tif(colon > linestart && valuestart > colon)\n\t\t\t\t\t{\n#ifdef DEBUG\n\t\t\t\t\t\tprintf(\"header='%.*s', value='%.*s'\\n\",\n\t\t\t\t\t\t       colon-linestart, header_buf+linestart,\n\t\t\t\t\t\t       i-valuestart, header_buf+valuestart);\n#endif\n\t\t\t\t\t\tif(0==strncasecmp(header_buf+linestart, \"content-length\", colon-linestart))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcontent_length = atoi(header_buf+valuestart);\n#ifdef DEBUG\n\t\t\t\t\t\t\tprintf(\"Content-Length: %d\\n\", content_length);\n#endif\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(0==strncasecmp(header_buf+linestart, \"transfer-encoding\", colon-linestart)\n\t\t\t\t\t\t   && 0==strncasecmp(header_buf+valuestart, \"chunked\", 7))\n\t\t\t\t\t\t{\n#ifdef DEBUG\n\t\t\t\t\t\t\tprintf(\"chunked transfer-encoding!\\n\");\n#endif\n\t\t\t\t\t\t\tchunked = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\twhile(header_buf[i]=='\\r' || header_buf[i] == '\\n')\n\t\t\t\t\t\ti++;\n\t\t\t\t\tlinestart = i;\n\t\t\t\t\tcolon = linestart;\n\t\t\t\t\tvaluestart = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* copy the remaining of the received data back to buf */\n\t\t\tn = header_buf_used - endofheaders;\n\t\t\tmemcpy(buf, header_buf + endofheaders, n);\n\t\t\t/* if(headers) */\n\t\t}\n\t\tif(endofheaders)\n\t\t{\n\t\t\t/* content */\n\t\t\tif(chunked)\n\t\t\t{\n\t\t\t\tint i = 0;\n\t\t\t\twhile(i < n)\n\t\t\t\t{\n\t\t\t\t\tif(chunksize == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\t/* reading chunk size */\n\t\t\t\t\t\tif(chunksize_buf_index == 0) {\n\t\t\t\t\t\t\t/* skipping any leading CR LF */\n\t\t\t\t\t\t\tif(i<n && buf[i] == '\\r') i++;\n\t\t\t\t\t\t\tif(i<n && buf[i] == '\\n') i++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\twhile(i<n && isxdigit(buf[i])\n\t\t\t\t\t\t     && chunksize_buf_index < (sizeof(chunksize_buf)-1))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tchunksize_buf[chunksize_buf_index++] = buf[i];\n\t\t\t\t\t\t\tchunksize_buf[chunksize_buf_index] = '\\0';\n\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\twhile(i<n && buf[i] != '\\r' && buf[i] != '\\n')\n\t\t\t\t\t\t\ti++; /* discarding chunk-extension */\n\t\t\t\t\t\tif(i<n && buf[i] == '\\r') i++;\n\t\t\t\t\t\tif(i<n && buf[i] == '\\n') {\n\t\t\t\t\t\t\tunsigned int j;\n\t\t\t\t\t\t\tfor(j = 0; j < chunksize_buf_index; j++) {\n\t\t\t\t\t\t\tif(chunksize_buf[j] >= '0'\n\t\t\t\t\t\t\t   && chunksize_buf[j] <= '9')\n\t\t\t\t\t\t\t\tchunksize = (chunksize << 4) + (chunksize_buf[j] - '0');\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tchunksize = (chunksize << 4) + ((chunksize_buf[j] | 32) - 'a' + 10);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tchunksize_buf[0] = '\\0';\n\t\t\t\t\t\t\tchunksize_buf_index = 0;\n\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t/* not finished to get chunksize */\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n#ifdef DEBUG\n\t\t\t\t\t\tprintf(\"chunksize = %u (%x)\\n\", chunksize, chunksize);\n#endif\n\t\t\t\t\t\tif(chunksize == 0)\n\t\t\t\t\t\t{\n#ifdef DEBUG\n\t\t\t\t\t\t\tprintf(\"end of HTTP content - %d %d\\n\", i, n);\n\t\t\t\t\t\t\t/*printf(\"'%.*s'\\n\", n-i, buf+i);*/\n#endif\n\t\t\t\t\t\t\tgoto end_of_stream;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbytestocopy = ((int)chunksize < (n - i))?chunksize:(unsigned int)(n - i);\n\t\t\t\t\tif((content_buf_used + bytestocopy) > content_buf_len)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(content_length >= (int)(content_buf_used + bytestocopy)) {\n\t\t\t\t\t\t\tcontent_buf_len = content_length;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcontent_buf_len = content_buf_used + bytestocopy;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontent_buf = (char *)realloc((void *)content_buf,\n\t\t\t\t\t\t                              content_buf_len);\n\t\t\t\t\t}\n\t\t\t\t\tmemcpy(content_buf + content_buf_used, buf + i, bytestocopy);\n\t\t\t\t\tcontent_buf_used += bytestocopy;\n\t\t\t\t\ti += bytestocopy;\n\t\t\t\t\tchunksize -= bytestocopy;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* not chunked */\n\t\t\t\tif(content_length > 0\n\t\t\t\t   && (int)(content_buf_used + n) > content_length) {\n\t\t\t\t\t/* skipping additional bytes */\n\t\t\t\t\tn = content_length - content_buf_used;\n\t\t\t\t}\n\t\t\t\tif(content_buf_used + n > content_buf_len)\n\t\t\t\t{\n\t\t\t\t\tif(content_length >= (int)(content_buf_used + n)) {\n\t\t\t\t\t\tcontent_buf_len = content_length;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcontent_buf_len = content_buf_used + n;\n\t\t\t\t\t}\n\t\t\t\t\tcontent_buf = (char *)realloc((void *)content_buf,\n\t\t\t\t\t                              content_buf_len);\n\t\t\t\t}\n\t\t\t\tmemcpy(content_buf + content_buf_used, buf, n);\n\t\t\t\tcontent_buf_used += n;\n\t\t\t}\n\t\t}\n\t\t/* use the Content-Length header value if available */\n\t\tif(content_length > 0 && (int)content_buf_used >= content_length)\n\t\t{\n#ifdef DEBUG\n\t\t\tprintf(\"End of HTTP content\\n\");\n#endif\n\t\t\tbreak;\n\t\t}\n\t}\nend_of_stream:\n\tfree(header_buf); header_buf = NULL;\n\t*size = content_buf_used;\n\tif(content_buf_used == 0)\n\t{\n\t\tfree(content_buf);\n\t\tcontent_buf = NULL;\n\t}\n\treturn content_buf;\n}\n\n/* miniwget3() :\n * do all the work.\n * Return NULL if something failed. */\nstatic void *\nminiwget3(const char * host,\n          unsigned short port, const char * path,\n          int * size, char * addr_str, int addr_str_len,\n          const char * httpversion, unsigned int scope_id)\n{\n\tchar buf[2048];\n    int s;\n\tint n;\n\tint len;\n\tint sent;\n\tvoid * content;\n\n\t*size = 0;\n\ts = connecthostport(host, port, scope_id);\n\tif(s < 0)\n\t\treturn NULL;\n\n\t/* get address for caller ! */\n\tif(addr_str)\n\t{\n\t\tstruct sockaddr_storage saddr;\n\t\tsocklen_t saddrlen;\n\n\t\tsaddrlen = sizeof(saddr);\n\t\tif(getsockname(s, (struct sockaddr *)&saddr, &saddrlen) < 0)\n\t\t{\n\t\t\tperror(\"getsockname\");\n\t\t}\n\t\telse\n\t\t{\n#if defined(__amigaos__) && !defined(__amigaos4__)\n\t/* using INT WINAPI WSAAddressToStringA(LPSOCKADDR, DWORD, LPWSAPROTOCOL_INFOA, LPSTR, LPDWORD);\n     * But his function make a string with the port :  nn.nn.nn.nn:port */\n/*\t\tif(WSAAddressToStringA((SOCKADDR *)&saddr, sizeof(saddr),\n                            NULL, addr_str, (DWORD *)&addr_str_len))\n\t\t{\n\t\t    printf(\"WSAAddressToStringA() failed : %d\\n\", WSAGetLastError());\n\t\t}*/\n\t\t\t/* the following code is only compatible with ip v4 addresses */\n\t\t\tstrncpy(addr_str, inet_ntoa(((struct sockaddr_in *)&saddr)->sin_addr), addr_str_len);\n#else\n#if 0\n\t\t\tif(saddr.sa_family == AF_INET6) {\n\t\t\t\tinet_ntop(AF_INET6,\n\t\t\t\t          &(((struct sockaddr_in6 *)&saddr)->sin6_addr),\n\t\t\t\t          addr_str, addr_str_len);\n\t\t\t} else {\n\t\t\t\tinet_ntop(AF_INET,\n\t\t\t\t          &(((struct sockaddr_in *)&saddr)->sin_addr),\n\t\t\t\t          addr_str, addr_str_len);\n\t\t\t}\n#endif\n\t\t\t/* getnameinfo return ip v6 address with the scope identifier\n\t\t\t * such as : 2a01:e35:8b2b:7330::%4281128194 */\n\t\t\tn = getnameinfo((const struct sockaddr *)&saddr, saddrlen,\n\t\t\t                addr_str, addr_str_len,\n\t\t\t                NULL, 0,\n\t\t\t                NI_NUMERICHOST | NI_NUMERICSERV);\n\t\t\tif(n != 0) {\n#ifdef _WIN32\n\t\t\t\tfprintf(stderr, \"getnameinfo() failed : %d\\n\", n);\n#else\n\t\t\t\tfprintf(stderr, \"getnameinfo() failed : %s\\n\", gai_strerror(n));\n#endif\n\t\t\t}\n#endif\n\t\t}\n#ifdef DEBUG\n\t\tprintf(\"address miniwget : %s\\n\", addr_str);\n#endif\n\t}\n\n\tlen = snprintf(buf, sizeof(buf),\n                 \"GET %s HTTP/%s\\r\\n\"\n\t\t\t     \"Host: %s:%d\\r\\n\"\n\t\t\t\t \"Connection: Close\\r\\n\"\n\t\t\t\t \"User-Agent: \" OS_STRING \", UPnP/1.0, MiniUPnPc/\" MINIUPNPC_VERSION_STRING \"\\r\\n\"\n\n\t\t\t\t \"\\r\\n\",\n\t\t\t   path, httpversion, host, port);\n\tsent = 0;\n\t/* sending the HTTP request */\n\twhile(sent < len)\n\t{\n\t\tn = send(s, buf+sent, len-sent, 0);\n\t\tif(n < 0)\n\t\t{\n\t\t\tperror(\"send\");\n\t\t\tclosesocket(s);\n\t\t\treturn NULL;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsent += n;\n\t\t}\n\t}\n\tcontent = getHTTPResponse(s, size);\n\tclosesocket(s);\n\treturn content;\n}\n\n/* miniwget2() :\n * Call miniwget3(); retry with HTTP/1.1 if 1.0 fails. */\nstatic void *\nminiwget2(const char * host,\n\t\t  unsigned short port, const char * path,\n\t\t  int * size, char * addr_str, int addr_str_len,\n          unsigned int scope_id)\n{\n\tchar * respbuffer;\n\n#if 1\n\trespbuffer = miniwget3(host, port, path, size,\n\t                       addr_str, addr_str_len, \"1.1\", scope_id);\n#else\n\trespbuffer = miniwget3(host, port, path, size,\n\t                       addr_str, addr_str_len, \"1.0\", scope_id);\n\tif (*size == 0)\n\t{\n#ifdef DEBUG\n\t\tprintf(\"Retrying with HTTP/1.1\\n\");\n#endif\n\t\tfree(respbuffer);\n\t\trespbuffer = miniwget3(host, port, path, size,\n\t\t                       addr_str, addr_str_len, \"1.1\", scope_id);\n\t}\n#endif\n\treturn respbuffer;\n}\n\n\n\n\n/* parseURL()\n * arguments :\n *   url :\t\tsource string not modified\n *   hostname :\thostname destination string (size of MAXHOSTNAMELEN+1)\n *   port :\t\tport (destination)\n *   path :\t\tpointer to the path part of the URL\n *\n * Return values :\n *    0 - Failure\n *    1 - Success         */\nint\nparseURL(const char * url,\n         char * hostname, unsigned short * port,\n         char * * path, unsigned int * scope_id)\n{\n\tchar * p1, *p2, *p3;\n\tif(!url)\n\t\treturn 0;\n\tp1 = strstr(url, \"://\");\n\tif(!p1)\n\t\treturn 0;\n\tp1 += 3;\n\tif(  (url[0]!='h') || (url[1]!='t')\n\t   ||(url[2]!='t') || (url[3]!='p'))\n\t\treturn 0;\n\tmemset(hostname, 0, MAXHOSTNAMELEN + 1);\n\tif(*p1 == '[')\n\t{\n\t\t/* IP v6 : http://[2a00:1450:8002::6a]/path/abc */\n\t\tchar * scope;\n\t\tscope = strchr(p1, '%');\n\t\tp2 = strchr(p1, ']');\n\t\tif(p2 && scope && scope < p2 && scope_id) {\n\t\t\t/* parse scope */\n#ifdef IF_NAMESIZE\n\t\t\tchar tmp[IF_NAMESIZE];\n\t\t\tint l;\n\t\t\tscope++;\n\t\t\t/* \"%25\" is just '%' in URL encoding */\n\t\t\tif(scope[0] == '2' && scope[1] == '5')\n\t\t\t\tscope += 2;\t/* skip \"25\" */\n\t\t\tl = p2 - scope;\n\t\t\tif(l >= IF_NAMESIZE)\n\t\t\t\tl = IF_NAMESIZE - 1;\n\t\t\tmemcpy(tmp, scope, l);\n\t\t\ttmp[l] = '\\0';\n\t\t\t*scope_id = if_nametoindex(tmp);\n\t\t\tif(*scope_id == 0) {\n\t\t\t\t*scope_id = (unsigned int)strtoul(tmp, NULL, 10);\n\t\t\t}\n#else\n\t\t\t/* under windows, scope is numerical */\n\t\t\tchar tmp[8];\n\t\t\tint l;\n\t\t\tscope++;\n\t\t\t/* \"%25\" is just '%' in URL encoding */\n\t\t\tif(scope[0] == '2' && scope[1] == '5')\n\t\t\t\tscope += 2;\t/* skip \"25\" */\n\t\t\tl = p2 - scope;\n\t\t\tif(l >= sizeof(tmp))\n\t\t\t\tl = sizeof(tmp) - 1;\n\t\t\tmemcpy(tmp, scope, l);\n\t\t\ttmp[l] = '\\0';\n\t\t\t*scope_id = (unsigned int)strtoul(tmp, NULL, 10);\n#endif\n\t\t}\n\t\tp3 = strchr(p1, '/');\n\t\tif(p2 && p3)\n\t\t{\n\t\t\tp2++;\n\t\t\tstrncpy(hostname, p1, MIN(MAXHOSTNAMELEN, (int)(p2-p1)));\n\t\t\tif(*p2 == ':')\n\t\t\t{\n\t\t\t\t*port = 0;\n\t\t\t\tp2++;\n\t\t\t\twhile( (*p2 >= '0') && (*p2 <= '9'))\n\t\t\t\t{\n\t\t\t\t\t*port *= 10;\n\t\t\t\t\t*port += (unsigned short)(*p2 - '0');\n\t\t\t\t\tp2++;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t*port = 80;\n\t\t\t}\n\t\t\t*path = p3;\n\t\t\treturn 1;\n\t\t}\n\t}\n\tp2 = strchr(p1, ':');\n\tp3 = strchr(p1, '/');\n\tif(!p3)\n\t\treturn 0;\n\tif(!p2 || (p2>p3))\n\t{\n\t\tstrncpy(hostname, p1, MIN(MAXHOSTNAMELEN, (int)(p3-p1)));\n\t\t*port = 80;\n\t}\n\telse\n\t{\n\t\tstrncpy(hostname, p1, MIN(MAXHOSTNAMELEN, (int)(p2-p1)));\n\t\t*port = 0;\n\t\tp2++;\n\t\twhile( (*p2 >= '0') && (*p2 <= '9'))\n\t\t{\n\t\t\t*port *= 10;\n\t\t\t*port += (unsigned short)(*p2 - '0');\n\t\t\tp2++;\n\t\t}\n\t}\n\t*path = p3;\n\treturn 1;\n}\n\nvoid *\nminiwget(const char * url, int * size, unsigned int scope_id)\n{\n\tunsigned short port;\n\tchar * path;\n\t/* protocol://host:port/chemin */\n\tchar hostname[MAXHOSTNAMELEN+1];\n\t*size = 0;\n\tif(!parseURL(url, hostname, &port, &path, &scope_id))\n\t\treturn NULL;\n#ifdef DEBUG\n\tprintf(\"parsed url : hostname='%s' port=%hu path='%s' scope_id=%u\\n\",\n\t       hostname, port, path, scope_id);\n#endif\n\treturn miniwget2(hostname, port, path, size, 0, 0, scope_id);\n}\n\nvoid *\nminiwget_getaddr(const char * url, int * size,\n                 char * addr, int addrlen, unsigned int scope_id)\n{\n\tunsigned short port;\n\tchar * path;\n\t/* protocol://host:port/path */\n\tchar hostname[MAXHOSTNAMELEN+1];\n\t*size = 0;\n\tif(addr)\n\t\taddr[0] = '\\0';\n\tif(!parseURL(url, hostname, &port, &path, &scope_id))\n\t\treturn NULL;\n#ifdef DEBUG\n\tprintf(\"parsed url : hostname='%s' port=%hu path='%s' scope_id=%u\\n\",\n\t       hostname, port, path, scope_id);\n#endif\n\treturn miniwget2(hostname, port, path, size, addr, addrlen, scope_id);\n}\n\n"], "fixing_code": ["$Id: Changelog.txt,v 1.187 2013/06/06 21:36:39 nanard Exp $\nminiUPnP client Changelog.\n\n2013/10/07:\n  fixed potential buffer overrun in miniwget.c\n\n2013/08/01:\n  define MAXHOSTNAMELEN if not already done\n\n2013/06/06:\n  update upnpreplyparse to allow larger values (128 chars instead of 64)\n\n2013/05/14:\n  Update upnpreplyparse to take into account \"empty\" elements\n  validate upnpreplyparse.c code with \"make check\"\n\n2013/05/03:\n  Fix Solaris build thanks to Maciej Ma\u0142ecki\n\n2013/04/27:\n  Fix testminiwget.sh for BSD\n\n2013/03/23:\n  Fixed Makefile for *BSD\n\n2013/03/11:\n  Update Makefile to use JNAerator version 0.11\n\n2013/02/11:\n  Fix testminiwget.sh for use with dash\n  Use $(DESTDIR) in Makefile\n\nVERSION 1.8 : released 2013/02/06\n\n2012/10/16:\n  fix testminiwget with no IPv6 support\n\n2012/09/27:\n  Rename all include guards to not clash with C99\n  (7.1.3 Reserved identifiers).\n\n2012/08/30:\n  Added -e option to upnpc program (set description for port mappings)\n\n2012/08/29:\n  Python 3 support (thanks to Christopher Foo)\n\n2012/08/11:\n  Fix a memory link in UPNP_GetValidIGD()\n  Try to handle scope id in link local IPv6 URL under MS Windows\n\n2012/07/20:\n  Disable HAS_IP_MREQN on DragonFly BSD\n\n2012/06/28:\n  GetUPNPUrls() now inserts scope into link-local IPv6 addresses\n\n2012/06/23:\n  More error return checks in upnpc.c\n  #define MINIUPNPC_GET_SRC_ADDR enables receivedata() to get scope_id\n  parseURL() now parses IPv6 addresses scope\n  new parameter for miniwget() : IPv6 address scope\n  increment API_VERSION to 9\n\n2012/06/20:\n  fixed CMakeLists.txt\n\n2012/05/29\n  Improvements in testminiwget.sh\n\nVERSION 1.7 : released 2012/05/24\n\n2012/05/01:\n  Cleanup settings of CFLAGS in Makefile\n  Fix signed/unsigned integer comparaisons\n\n2012/04/20:\n  Allow to specify protocol with TCP or UDP for -A option\n\n2012/04/09:\n  Only try to fetch XML description once in UPNP_GetValidIGD()\n  Added -ansi flag to compilation, and fixed C++ comments to ANSI C comments.\n\n2012/04/05:\n  minor improvements to minihttptestserver.c\n\n2012/03/15:\n  upnperrors.c returns valid error string for unrecognized error codes\n\n2012/03/08:\n  make minihttptestserver listen on loopback interface instead of 0.0.0.0\n\n2012/01/25:\n  Maven installation thanks to Alexey Kuznetsov\n\n2012/01/21:\n  Replace WIN32 macro by _WIN32\n\n2012/01/19:\n  Fixes in java wrappers thanks to Alexey Kuznetsov :\n    https://github.com/axet/miniupnp/tree/fix-javatest/miniupnpc\n  Make and install .deb packages (python) thanks to Alexey Kuznetsov :\n    https://github.com/axet/miniupnp/tree/feature-debbuild/miniupnpc\n\n2012/01/07:\n  The multicast interface can now be specified by name with IPv4.\n\n2012/01/02:\n  Install man page\n\n2011/11/25:\n  added header to Port Mappings list in upnpc.c\n\n2011/10/09:\n  Makefile : make clean now removes jnaerator generated files.\n  MINIUPNPC_VERSION in miniupnpc.h (updated by make)\n\n2011/09/12:\n  added rootdescURL to UPNPUrls structure.\n\nVERSION 1.6 : released 2011/07/25\n\n2011/07/25:\n  Update doc for version 1.6 release\n\n2011/06/18:\n  Fix for windows in miniwget.c\n\n2011/06/04:\n  display remote host in port mapping listing\n\n2011/06/03:\n  Fix in make install : there were missing headers\n\n2011/05/26:\n  Fix the socket leak in miniwget thanks to Richard Marsh.\n  Permit to add leaseduration in -a command. Display lease duration.\n\n2011/05/15:\n  Try both LinkLocal and SiteLocal multicast address for SSDP in IPv6\n\n2011/05/09:\n  add a test in testminiwget.sh.\n  more error checking in miniwget.c\n\n2011/05/06:\n  Adding some tool to test and validate miniwget.c\n  simplified and debugged miniwget.c\n\n2011/04/11:\n  moving ReceiveData() to a receivedata.c file.\n  parsing presentation url\n  adding IGD v2 WANIPv6FirewallControl commands\n\n2011/04/10:\n  update of miniupnpcmodule.c\n  comments in miniwget.c, update in testminiwget\n  Adding errors codes from IGD v2\n  new functions in upnpc.c for IGD v2\n\n2011/04/09:\n  Support for litteral ip v6 address in miniwget\n\n2011/04/08:\n  Adding support for urn:schemas-upnp-org:service:WANIPv6FirewallControl:1\n  Updating APIVERSION\n  Supporting IPV6 in upnpDiscover()\n  Adding a -6 option to upnpc command line tool\n\n2011/03/18:\n  miniwget/parseURL() : return an error when url param is null.\n  fixing GetListOfPortMappings()\n\n2011/03/14:\n  upnpDiscover() now reporting an error code.\n  improvements in comments.\n\n2011/03/11:\n  adding miniupnpcstrings.h.cmake and CMakeLists.txt files.\n\n2011/02/15:\n  Implementation of GetListOfPortMappings()\n\n2011/02/07:\n  updates to minixml to support character data starting with spaces\n  minixml now support CDATA\n  upnpreplyparse treats <NewPortListing> specificaly\n  change in simpleUPnPcommand to return the buffer (simplification)\n\n2011/02/06:\n  Added leaseDuration argument to AddPortMapping()\n  Starting to implement GetListOfPortMappings()\n\n2011/01/11:\n  updating wingenminiupnpcstrings.c\n\n2011/01/04:\n  improving updateminiupnpcstrings.sh\n\nVERSION 1.5 : released 2011/01/01\n\n2010/12/21:\n  use NO_GETADDRINFO macro to disable the use of getaddrinfo/freeaddrinfo\n\n2010/12/11:\n  Improvements on getHTTPResponse() code.\n\n2010/12/09:\n  new code for miniwget that handle Chunked transfer encoding\n  using getHTTPResponse() in SOAP call code\n  Adding MANIFEST.in for 'python setup.py bdist_rpm'\n\n2010/11/25:\n  changes to minissdpc.c to compile under Win32.\n  see http://miniupnp.tuxfamily.org/forum/viewtopic.php?t=729\n\n2010/09/17:\n  Various improvement to Makefile from Micha\u0142 G\u00f3rny\n\n2010/08/05:\n  Adding the script \"external-ip.sh\" from Reuben Hawkins\n\n2010/06/09:\n  update to python module to match modification made on 2010/04/05\n  update to Java test code to match modification made on 2010/04/05\n  all UPNP_* function now return an error if the SOAP request failed\n  at HTTP level.\n\n2010/04/17:\n  Using GetBestRoute() under win32 in order to find the\n  right interface to use.\n\n2010/04/12:\n  Retrying with HTTP/1.1 if HTTP/1.0 failed. see\n  http://miniupnp.tuxfamily.org/forum/viewtopic.php?p=1703\n\n2010/04/07:\n  avoid returning duplicates in upnpDiscover()\n\n2010/04/05:\n  Create a connecthostport.h/.c with connecthostport() function\n  and use it in miniwget and miniupnpc.\n  Use getnameinfo() instead of inet_ntop or inet_ntoa\n  Work to make miniupnpc IPV6 compatible...\n  Add java test code.\n  Big changes in order to support device having both WANIPConnection\n  and WANPPPConnection.\n\n2010/04/04:\n  Use getaddrinfo() instead of gethostbyname() in miniwget.\n\n2010/01/06:\n  #define _DARWIN_C_SOURCE for Mac OS X\n\n2009/12/19:\n  Improve MinGW32 build\n\n2009/12/11:\n  adding a MSVC9 project to build the static library and executable\n\n2009/12/10:\n  Fixing some compilation stuff for Windows/MinGW\n\n2009/12/07:\n  adaptations in Makefile and updateminiupnpcstring.sh for AmigaOS\n  some fixes for Windows when using virtual ethernet adapters (it is the\n  case with VMWare installed).\n\n2009/12/04:\n  some fixes for AmigaOS compilation\n  Changed HTTP version to HTTP/1.0 for Soap too (to prevent chunked\n  transfer encoding)\n\n2009/12/03:\n  updating printIDG and testigddescparse.c for debug.\n  modifications to compile under AmigaOS\n  adding a testminiwget program\n  Changed miniwget to advertise itself as HTTP/1.0 to prevent chunked\n  transfer encoding\n\n2009/11/26:\n  fixing updateminiupnpcstrings.sh to take into account\n  which command that does not return an error code.\n\nVERSION 1.4 : released 2009/10/30\n\n2009/10/16:\n  using Py_BEGIN_ALLOW_THREADS and Py_END_ALLOW_THREADS in python module.\n\n2009/10/10:\n  Some fixes for compilation under Solaris\n  compilation fixes : http://miniupnp.tuxfamily.org/forum/viewtopic.php?p=1464\n\n2009/09/21:\n  fixing the code to ignore EINTR during connect() calls.\n\n2009/08/07:\n  Set socket timeout for connect()\n  Some cleanup in miniwget.c\n\n2009/08/04:\n  remove multiple redirections with -d in upnpc.c\n  Print textual error code in upnpc.c\n  Ignore EINTR during the connect() and poll() calls.\n\n2009/07/29:\n  fix in updateminiupnpcstrings.sh if OS name contains \"/\"\n  Sending a correct value for MX: field in SSDP request\n\n2009/07/20:\n  Change the Makefile to compile under Mac OS X\n  Fixed a stackoverflow in getDevicesFromMiniSSDPD()\n\n2009/07/09:\n  Compile under Haiku\n  generate miniupnpcstrings.h.in from miniupnpcstrings.h\n\n2009/06/04:\n  patching to compile under CygWin and cross compile for minGW\n\nVERSION 1.3 :\n\n2009/04/17:\n  updating python module\n  Use strtoull() when using C99\n\n2009/02/28:\n  Fixed miniwget.c for compiling under sun\n\n2008/12/18:\n  cleanup in Makefile (thanks to Paul de Weerd)\n  minissdpc.c : win32 compatibility\n  miniupnpc.c : changed xmlns prefix from 'm' to 'u'\n  Removed NDEBUG (using DEBUG)\n\n2008/10/14:\n  Added the ExternalHost argument to DeletePortMapping()\n\n2008/10/11:\n  Added the ExternalHost argument to AddPortMapping()\n  Put a correct User-Agent: header in HTTP requests.\n\nVERSION 1.2 :\n\n2008/10/07:\n  Update docs\n\n2008/09/25:\n  Integrated sameport patch from Dario Meloni : Added a \"sameport\"\n  argument to upnpDiscover().\n\n2008/07/18:\n  small modif to make Clang happy :)\n\n2008/07/17:\n  #define SOAPPREFIX \"s\" in miniupnpc.c in order to remove SOAP-ENV...\n\n2008/07/14:\n  include declspec.h in installation (to /usr/include/miniupnpc)\n\nVERSION 1.1 :\n\n2008/07/04:\n  standard options for install/ln instead of gnu-specific stuff.\n\n2008/07/03:\n  now builds a .dll and .lib with win32. (mingw32)\n\n2008/04/28:\n  make install now install the binary of the upnpc tool\n\n2008/04/27:\n  added testupnpigd.py\n  added error strings for miniupnpc \"internal\" errors\n  improved python module error/exception reporting.\n\n2008/04/23:\n  Completely rewrite igd_desc_parse.c in order to be compatible with\n  Linksys WAG200G\n  Added testigddescparse\n  updated python module\n\nVERSION 1.0 :\n\n2008/02/21:\n  put some #ifdef DEBUG around DisplayNameValueList()\n\n2008/02/18:\n  Improved error reporting in upnpcommands.c\n  UPNP_GetStatusInfo() returns LastConnectionError\n\n2008/02/16:\n  better error handling in minisoap.c\n  improving display of \"valid IGD found\" in upnpc.c\n\n2008/02/03:\n  Fixing UPNP_GetValidIGD()\n  improved make install :)\n\n2007/12/22:\n  Adding upnperrors.c/h to provide a strupnperror() function\n  used to translate UPnP error codes to string.\n\n2007/12/19:\n  Fixing getDevicesFromMiniSSDPD()\n  improved error reporting of UPnP functions\n\n2007/12/18:\n  It is now possible to specify a different location for MiniSSDPd socket.\n  working with MiniSSDPd is now more efficient.\n  python module improved.\n\n2007/12/16:\n  improving error reporting\n\n2007/12/13:\n  Try to improve compatibility by using HTTP/1.0 instead of 1.1 and\n  XML a bit different for SOAP.\n\n2007/11/25:\n  fixed select() call for linux\n\n2007/11/15:\n  Added -fPIC to CFLAG for better shared library code.\n\n2007/11/02:\n  Fixed a potential socket leak in miniwget2()\n\n2007/10/16:\n  added a parameter to upnpDiscover() in order to allow the use of another\n  interface than the default multicast interface.\n\n2007/10/12:\n  Fixed the creation of symbolic link in Makefile\n\n2007/10/08:\n  Added man page\n\n2007/10/02:\n  fixed memory bug in GetUPNPUrls()\n\n2007/10/01:\n  fixes in the Makefile\n  Added UPNP_GetIGDFromUrl() and adapted the sample program accordingly.\n  Added SONAME in the shared library to please debian :)\n  fixed MS Windows compilation (minissdpd is not available under MS Windows).\n\n2007/09/25:\n  small change to Makefile to be able to install in a different location\n  (default is /usr)\n\n2007/09/24:\n  now compiling both shared and static library\n\n2007/09/19:\n  Cosmetic changes on upnpc.c\n\n2007/09/02:\n  adapting to new miniSSDPd (release version ?)\n\n2007/08/31:\n  Usage of miniSSDPd to skip discovery process.\n\n2007/08/27:\n  fixed python module to allow compilation with Python older than Python 2.4\n\n2007/06/12:\n  Added a python module.\n\n2007/05/19:\n  Fixed compilation under MinGW\n\n2007/05/15:\n  fixed a memory leak in AddPortMapping()\n  Added testupnpreplyparse executable to check the parsing of\n  upnp soap messages\n  minixml now ignore namespace prefixes.\n\n2007/04/26:\n  upnpc now displays external ip address with -s or -l\n\n2007/04/11:\n  changed MINIUPNPC_URL_MAXSIZE to 128 to accomodate the \"BT Voyager 210\"\n\n2007/03/19:\n  cleanup in miniwget.c\n\n2007/03/01:\n  Small typo fix...\n\n2007/01/30:\n  Now parsing the HTTP header from SOAP responses in order to\n  get content-length value.\n\n2007/01/29:\n  Fixed the Soap Query to speedup the HTTP request.\n  added some Win32 DLL stuff...\n\n2007/01/27:\n  Fixed some WIN32 compatibility issues\n\n2006/12/14:\n  Added UPNPIGD_IsConnected() function in miniupnp.c/.h\n  Added UPNP_GetValidIGD() in miniupnp.c/.h\n  cleaned upnpc.c main(). now using UPNP_GetValidIGD()\n\n2006/12/07:\n  Version 1.0-RC1 released\n\n2006/12/03:\n  Minor changes to compile under SunOS/Solaris\n\n2006/11/30:\n  made a minixml parser validator program\n  updated minixml to handle attributes correctly\n\n2006/11/22:\n  Added a -r option to the upnpc sample thanks to Alexander Hubmann.\n\n2006/11/19:\n  Cleanup code to make it more ANSI C compliant\n\n2006/11/10:\n  detect and display local lan address.\n\n2006/11/04:\n  Packets and Bytes Sent/Received are now unsigned int.\n\n2006/11/01:\n  Bug fix thanks to Giuseppe D'Angelo\n\n2006/10/31:\n  C++ compatibility for .h files.\n  Added a way to get ip Address on the LAN used to reach the IGD.\n\n2006/10/25:\n  Added M-SEARCH to the services in the discovery process.\n\n2006/10/22:\n  updated the Makefile to use makedepend, added a \"make install\"\n  update Makefile\n\n2006/10/20:\n  fixing the description url parsing thanks to patch sent by\n  Wayne Dawe.\n  Fixed/translated some comments.\n  Implemented a better discover process, first looking\n  for IGD then for root devices (as some devices only reply to\n  M-SEARCH for root devices).\n\n2006/09/02:\n  added freeUPNPDevlist() function.\n\n2006/08/04:\n  More command line arguments checking\n\n2006/08/01:\n  Added the .bat file to compile under Win32 with minGW32\n\n2006/07/31:\n  Fixed the rootdesc parser (igd_desc_parse.c)\n\n2006/07/20:\n  parseMSEARCHReply() is now returning the ST: line as well\n  starting changes to detect several UPnP devices on the network\n\n2006/07/19:\n  using GetCommonLinkProperties to get down/upload bitrate\n\n", "/* $Id: miniwget.c,v 1.60 2013/10/07 10:03:16 nanard Exp $ */\n/* Project : miniupnp\n * Website : http://miniupnp.free.fr/\n * Author : Thomas Bernard\n * Copyright (c) 2005-2013 Thomas Bernard\n * This software is subject to the conditions detailed in the\n * LICENCE file provided in this distribution. */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n#ifdef _WIN32\n#include <winsock2.h>\n#include <ws2tcpip.h>\n#include <io.h>\n#define MAXHOSTNAMELEN 64\n#define MIN(x,y) (((x)<(y))?(x):(y))\n#define snprintf _snprintf\n#define socklen_t int\n#ifndef strncasecmp\n#if defined(_MSC_VER) && (_MSC_VER >= 1400)\n#define strncasecmp _memicmp\n#else /* defined(_MSC_VER) && (_MSC_VER >= 1400) */\n#define strncasecmp memicmp\n#endif /* defined(_MSC_VER) && (_MSC_VER >= 1400) */\n#endif /* #ifndef strncasecmp */\n#else /* #ifdef _WIN32 */\n#include <unistd.h>\n#include <sys/param.h>\n#if defined(__amigaos__) && !defined(__amigaos4__)\n#define socklen_t int\n#else /* #if defined(__amigaos__) && !defined(__amigaos4__) */\n#include <sys/select.h>\n#endif /* #else defined(__amigaos__) && !defined(__amigaos4__) */\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <net/if.h>\n#include <netdb.h>\n#define closesocket close\n/* defining MINIUPNPC_IGNORE_EINTR enable the ignore of interruptions\n * during the connect() call */\n#define MINIUPNPC_IGNORE_EINTR\n#endif /* #else _WIN32 */\n#if defined(__sun) || defined(sun)\n#define MIN(x,y) (((x)<(y))?(x):(y))\n#endif\n\n#include \"miniupnpcstrings.h\"\n#include \"miniwget.h\"\n#include \"connecthostport.h\"\n#include \"receivedata.h\"\n\n#ifndef MAXHOSTNAMELEN\n#define MAXHOSTNAMELEN 64\n#endif\n\n/*\n * Read a HTTP response from a socket.\n * Process Content-Length and Transfer-encoding headers.\n * return a pointer to the content buffer, which length is saved\n * to the length parameter.\n */\nvoid *\ngetHTTPResponse(int s, int * size)\n{\n\tchar buf[2048];\n\tint n;\n\tint endofheaders = 0;\n\tint chunked = 0;\n\tint content_length = -1;\n\tunsigned int chunksize = 0;\n\tunsigned int bytestocopy = 0;\n\t/* buffers : */\n\tchar * header_buf;\n\tunsigned int header_buf_len = 2048;\n\tunsigned int header_buf_used = 0;\n\tchar * content_buf;\n\tunsigned int content_buf_len = 2048;\n\tunsigned int content_buf_used = 0;\n\tchar chunksize_buf[32];\n\tunsigned int chunksize_buf_index;\n\n\theader_buf = malloc(header_buf_len);\n\tcontent_buf = malloc(content_buf_len);\n\tchunksize_buf[0] = '\\0';\n\tchunksize_buf_index = 0;\n\n\twhile((n = receivedata(s, buf, 2048, 5000, NULL)) > 0)\n\t{\n\t\tif(endofheaders == 0)\n\t\t{\n\t\t\tint i;\n\t\t\tint linestart=0;\n\t\t\tint colon=0;\n\t\t\tint valuestart=0;\n\t\t\tif(header_buf_used + n > header_buf_len) {\n\t\t\t\theader_buf = realloc(header_buf, header_buf_used + n);\n\t\t\t\theader_buf_len = header_buf_used + n;\n\t\t\t}\n\t\t\tmemcpy(header_buf + header_buf_used, buf, n);\n\t\t\theader_buf_used += n;\n\t\t\t/* search for CR LF CR LF (end of headers)\n\t\t\t * recognize also LF LF */\n\t\t\ti = 0;\n\t\t\twhile(i < ((int)header_buf_used-1) && (endofheaders == 0)) {\n\t\t\t\tif(header_buf[i] == '\\r') {\n\t\t\t\t\ti++;\n\t\t\t\t\tif(header_buf[i] == '\\n') {\n\t\t\t\t\t\ti++;\n\t\t\t\t\t\tif(i < (int)header_buf_used && header_buf[i] == '\\r') {\n\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t\tif(i < (int)header_buf_used && header_buf[i] == '\\n') {\n\t\t\t\t\t\t\t\tendofheaders = i+1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if(header_buf[i] == '\\n') {\n\t\t\t\t\ti++;\n\t\t\t\t\tif(header_buf[i] == '\\n') {\n\t\t\t\t\t\tendofheaders = i+1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tif(endofheaders == 0)\n\t\t\t\tcontinue;\n\t\t\t/* parse header lines */\n\t\t\tfor(i = 0; i < endofheaders - 1; i++) {\n\t\t\t\tif(colon <= linestart && header_buf[i]==':')\n\t\t\t\t{\n\t\t\t\t\tcolon = i;\n\t\t\t\t\twhile(i < (endofheaders-1)\n\t\t\t\t\t      && (header_buf[i+1] == ' ' || header_buf[i+1] == '\\t'))\n\t\t\t\t\t\ti++;\n\t\t\t\t\tvaluestart = i + 1;\n\t\t\t\t}\n\t\t\t\t/* detecting end of line */\n\t\t\t\telse if(header_buf[i]=='\\r' || header_buf[i]=='\\n')\n\t\t\t\t{\n\t\t\t\t\tif(colon > linestart && valuestart > colon)\n\t\t\t\t\t{\n#ifdef DEBUG\n\t\t\t\t\t\tprintf(\"header='%.*s', value='%.*s'\\n\",\n\t\t\t\t\t\t       colon-linestart, header_buf+linestart,\n\t\t\t\t\t\t       i-valuestart, header_buf+valuestart);\n#endif\n\t\t\t\t\t\tif(0==strncasecmp(header_buf+linestart, \"content-length\", colon-linestart))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcontent_length = atoi(header_buf+valuestart);\n#ifdef DEBUG\n\t\t\t\t\t\t\tprintf(\"Content-Length: %d\\n\", content_length);\n#endif\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(0==strncasecmp(header_buf+linestart, \"transfer-encoding\", colon-linestart)\n\t\t\t\t\t\t   && 0==strncasecmp(header_buf+valuestart, \"chunked\", 7))\n\t\t\t\t\t\t{\n#ifdef DEBUG\n\t\t\t\t\t\t\tprintf(\"chunked transfer-encoding!\\n\");\n#endif\n\t\t\t\t\t\t\tchunked = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\twhile((i < (int)header_buf_used) && (header_buf[i]=='\\r' || header_buf[i] == '\\n'))\n\t\t\t\t\t\ti++;\n\t\t\t\t\tlinestart = i;\n\t\t\t\t\tcolon = linestart;\n\t\t\t\t\tvaluestart = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* copy the remaining of the received data back to buf */\n\t\t\tn = header_buf_used - endofheaders;\n\t\t\tmemcpy(buf, header_buf + endofheaders, n);\n\t\t\t/* if(headers) */\n\t\t}\n\t\tif(endofheaders)\n\t\t{\n\t\t\t/* content */\n\t\t\tif(chunked)\n\t\t\t{\n\t\t\t\tint i = 0;\n\t\t\t\twhile(i < n)\n\t\t\t\t{\n\t\t\t\t\tif(chunksize == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\t/* reading chunk size */\n\t\t\t\t\t\tif(chunksize_buf_index == 0) {\n\t\t\t\t\t\t\t/* skipping any leading CR LF */\n\t\t\t\t\t\t\tif(i<n && buf[i] == '\\r') i++;\n\t\t\t\t\t\t\tif(i<n && buf[i] == '\\n') i++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\twhile(i<n && isxdigit(buf[i])\n\t\t\t\t\t\t     && chunksize_buf_index < (sizeof(chunksize_buf)-1))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tchunksize_buf[chunksize_buf_index++] = buf[i];\n\t\t\t\t\t\t\tchunksize_buf[chunksize_buf_index] = '\\0';\n\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\twhile(i<n && buf[i] != '\\r' && buf[i] != '\\n')\n\t\t\t\t\t\t\ti++; /* discarding chunk-extension */\n\t\t\t\t\t\tif(i<n && buf[i] == '\\r') i++;\n\t\t\t\t\t\tif(i<n && buf[i] == '\\n') {\n\t\t\t\t\t\t\tunsigned int j;\n\t\t\t\t\t\t\tfor(j = 0; j < chunksize_buf_index; j++) {\n\t\t\t\t\t\t\tif(chunksize_buf[j] >= '0'\n\t\t\t\t\t\t\t   && chunksize_buf[j] <= '9')\n\t\t\t\t\t\t\t\tchunksize = (chunksize << 4) + (chunksize_buf[j] - '0');\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tchunksize = (chunksize << 4) + ((chunksize_buf[j] | 32) - 'a' + 10);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tchunksize_buf[0] = '\\0';\n\t\t\t\t\t\t\tchunksize_buf_index = 0;\n\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t/* not finished to get chunksize */\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n#ifdef DEBUG\n\t\t\t\t\t\tprintf(\"chunksize = %u (%x)\\n\", chunksize, chunksize);\n#endif\n\t\t\t\t\t\tif(chunksize == 0)\n\t\t\t\t\t\t{\n#ifdef DEBUG\n\t\t\t\t\t\t\tprintf(\"end of HTTP content - %d %d\\n\", i, n);\n\t\t\t\t\t\t\t/*printf(\"'%.*s'\\n\", n-i, buf+i);*/\n#endif\n\t\t\t\t\t\t\tgoto end_of_stream;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbytestocopy = ((int)chunksize < (n - i))?chunksize:(unsigned int)(n - i);\n\t\t\t\t\tif((content_buf_used + bytestocopy) > content_buf_len)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(content_length >= (int)(content_buf_used + bytestocopy)) {\n\t\t\t\t\t\t\tcontent_buf_len = content_length;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcontent_buf_len = content_buf_used + bytestocopy;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontent_buf = (char *)realloc((void *)content_buf,\n\t\t\t\t\t\t                              content_buf_len);\n\t\t\t\t\t}\n\t\t\t\t\tmemcpy(content_buf + content_buf_used, buf + i, bytestocopy);\n\t\t\t\t\tcontent_buf_used += bytestocopy;\n\t\t\t\t\ti += bytestocopy;\n\t\t\t\t\tchunksize -= bytestocopy;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* not chunked */\n\t\t\t\tif(content_length > 0\n\t\t\t\t   && (int)(content_buf_used + n) > content_length) {\n\t\t\t\t\t/* skipping additional bytes */\n\t\t\t\t\tn = content_length - content_buf_used;\n\t\t\t\t}\n\t\t\t\tif(content_buf_used + n > content_buf_len)\n\t\t\t\t{\n\t\t\t\t\tif(content_length >= (int)(content_buf_used + n)) {\n\t\t\t\t\t\tcontent_buf_len = content_length;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcontent_buf_len = content_buf_used + n;\n\t\t\t\t\t}\n\t\t\t\t\tcontent_buf = (char *)realloc((void *)content_buf,\n\t\t\t\t\t                              content_buf_len);\n\t\t\t\t}\n\t\t\t\tmemcpy(content_buf + content_buf_used, buf, n);\n\t\t\t\tcontent_buf_used += n;\n\t\t\t}\n\t\t}\n\t\t/* use the Content-Length header value if available */\n\t\tif(content_length > 0 && (int)content_buf_used >= content_length)\n\t\t{\n#ifdef DEBUG\n\t\t\tprintf(\"End of HTTP content\\n\");\n#endif\n\t\t\tbreak;\n\t\t}\n\t}\nend_of_stream:\n\tfree(header_buf); header_buf = NULL;\n\t*size = content_buf_used;\n\tif(content_buf_used == 0)\n\t{\n\t\tfree(content_buf);\n\t\tcontent_buf = NULL;\n\t}\n\treturn content_buf;\n}\n\n/* miniwget3() :\n * do all the work.\n * Return NULL if something failed. */\nstatic void *\nminiwget3(const char * host,\n          unsigned short port, const char * path,\n          int * size, char * addr_str, int addr_str_len,\n          const char * httpversion, unsigned int scope_id)\n{\n\tchar buf[2048];\n    int s;\n\tint n;\n\tint len;\n\tint sent;\n\tvoid * content;\n\n\t*size = 0;\n\ts = connecthostport(host, port, scope_id);\n\tif(s < 0)\n\t\treturn NULL;\n\n\t/* get address for caller ! */\n\tif(addr_str)\n\t{\n\t\tstruct sockaddr_storage saddr;\n\t\tsocklen_t saddrlen;\n\n\t\tsaddrlen = sizeof(saddr);\n\t\tif(getsockname(s, (struct sockaddr *)&saddr, &saddrlen) < 0)\n\t\t{\n\t\t\tperror(\"getsockname\");\n\t\t}\n\t\telse\n\t\t{\n#if defined(__amigaos__) && !defined(__amigaos4__)\n\t/* using INT WINAPI WSAAddressToStringA(LPSOCKADDR, DWORD, LPWSAPROTOCOL_INFOA, LPSTR, LPDWORD);\n     * But his function make a string with the port :  nn.nn.nn.nn:port */\n/*\t\tif(WSAAddressToStringA((SOCKADDR *)&saddr, sizeof(saddr),\n                            NULL, addr_str, (DWORD *)&addr_str_len))\n\t\t{\n\t\t    printf(\"WSAAddressToStringA() failed : %d\\n\", WSAGetLastError());\n\t\t}*/\n\t\t\t/* the following code is only compatible with ip v4 addresses */\n\t\t\tstrncpy(addr_str, inet_ntoa(((struct sockaddr_in *)&saddr)->sin_addr), addr_str_len);\n#else\n#if 0\n\t\t\tif(saddr.sa_family == AF_INET6) {\n\t\t\t\tinet_ntop(AF_INET6,\n\t\t\t\t          &(((struct sockaddr_in6 *)&saddr)->sin6_addr),\n\t\t\t\t          addr_str, addr_str_len);\n\t\t\t} else {\n\t\t\t\tinet_ntop(AF_INET,\n\t\t\t\t          &(((struct sockaddr_in *)&saddr)->sin_addr),\n\t\t\t\t          addr_str, addr_str_len);\n\t\t\t}\n#endif\n\t\t\t/* getnameinfo return ip v6 address with the scope identifier\n\t\t\t * such as : 2a01:e35:8b2b:7330::%4281128194 */\n\t\t\tn = getnameinfo((const struct sockaddr *)&saddr, saddrlen,\n\t\t\t                addr_str, addr_str_len,\n\t\t\t                NULL, 0,\n\t\t\t                NI_NUMERICHOST | NI_NUMERICSERV);\n\t\t\tif(n != 0) {\n#ifdef _WIN32\n\t\t\t\tfprintf(stderr, \"getnameinfo() failed : %d\\n\", n);\n#else\n\t\t\t\tfprintf(stderr, \"getnameinfo() failed : %s\\n\", gai_strerror(n));\n#endif\n\t\t\t}\n#endif\n\t\t}\n#ifdef DEBUG\n\t\tprintf(\"address miniwget : %s\\n\", addr_str);\n#endif\n\t}\n\n\tlen = snprintf(buf, sizeof(buf),\n                 \"GET %s HTTP/%s\\r\\n\"\n\t\t\t     \"Host: %s:%d\\r\\n\"\n\t\t\t\t \"Connection: Close\\r\\n\"\n\t\t\t\t \"User-Agent: \" OS_STRING \", UPnP/1.0, MiniUPnPc/\" MINIUPNPC_VERSION_STRING \"\\r\\n\"\n\n\t\t\t\t \"\\r\\n\",\n\t\t\t   path, httpversion, host, port);\n\tsent = 0;\n\t/* sending the HTTP request */\n\twhile(sent < len)\n\t{\n\t\tn = send(s, buf+sent, len-sent, 0);\n\t\tif(n < 0)\n\t\t{\n\t\t\tperror(\"send\");\n\t\t\tclosesocket(s);\n\t\t\treturn NULL;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsent += n;\n\t\t}\n\t}\n\tcontent = getHTTPResponse(s, size);\n\tclosesocket(s);\n\treturn content;\n}\n\n/* miniwget2() :\n * Call miniwget3(); retry with HTTP/1.1 if 1.0 fails. */\nstatic void *\nminiwget2(const char * host,\n\t\t  unsigned short port, const char * path,\n\t\t  int * size, char * addr_str, int addr_str_len,\n          unsigned int scope_id)\n{\n\tchar * respbuffer;\n\n#if 1\n\trespbuffer = miniwget3(host, port, path, size,\n\t                       addr_str, addr_str_len, \"1.1\", scope_id);\n#else\n\trespbuffer = miniwget3(host, port, path, size,\n\t                       addr_str, addr_str_len, \"1.0\", scope_id);\n\tif (*size == 0)\n\t{\n#ifdef DEBUG\n\t\tprintf(\"Retrying with HTTP/1.1\\n\");\n#endif\n\t\tfree(respbuffer);\n\t\trespbuffer = miniwget3(host, port, path, size,\n\t\t                       addr_str, addr_str_len, \"1.1\", scope_id);\n\t}\n#endif\n\treturn respbuffer;\n}\n\n\n\n\n/* parseURL()\n * arguments :\n *   url :\t\tsource string not modified\n *   hostname :\thostname destination string (size of MAXHOSTNAMELEN+1)\n *   port :\t\tport (destination)\n *   path :\t\tpointer to the path part of the URL\n *\n * Return values :\n *    0 - Failure\n *    1 - Success         */\nint\nparseURL(const char * url,\n         char * hostname, unsigned short * port,\n         char * * path, unsigned int * scope_id)\n{\n\tchar * p1, *p2, *p3;\n\tif(!url)\n\t\treturn 0;\n\tp1 = strstr(url, \"://\");\n\tif(!p1)\n\t\treturn 0;\n\tp1 += 3;\n\tif(  (url[0]!='h') || (url[1]!='t')\n\t   ||(url[2]!='t') || (url[3]!='p'))\n\t\treturn 0;\n\tmemset(hostname, 0, MAXHOSTNAMELEN + 1);\n\tif(*p1 == '[')\n\t{\n\t\t/* IP v6 : http://[2a00:1450:8002::6a]/path/abc */\n\t\tchar * scope;\n\t\tscope = strchr(p1, '%');\n\t\tp2 = strchr(p1, ']');\n\t\tif(p2 && scope && scope < p2 && scope_id) {\n\t\t\t/* parse scope */\n#ifdef IF_NAMESIZE\n\t\t\tchar tmp[IF_NAMESIZE];\n\t\t\tint l;\n\t\t\tscope++;\n\t\t\t/* \"%25\" is just '%' in URL encoding */\n\t\t\tif(scope[0] == '2' && scope[1] == '5')\n\t\t\t\tscope += 2;\t/* skip \"25\" */\n\t\t\tl = p2 - scope;\n\t\t\tif(l >= IF_NAMESIZE)\n\t\t\t\tl = IF_NAMESIZE - 1;\n\t\t\tmemcpy(tmp, scope, l);\n\t\t\ttmp[l] = '\\0';\n\t\t\t*scope_id = if_nametoindex(tmp);\n\t\t\tif(*scope_id == 0) {\n\t\t\t\t*scope_id = (unsigned int)strtoul(tmp, NULL, 10);\n\t\t\t}\n#else\n\t\t\t/* under windows, scope is numerical */\n\t\t\tchar tmp[8];\n\t\t\tint l;\n\t\t\tscope++;\n\t\t\t/* \"%25\" is just '%' in URL encoding */\n\t\t\tif(scope[0] == '2' && scope[1] == '5')\n\t\t\t\tscope += 2;\t/* skip \"25\" */\n\t\t\tl = p2 - scope;\n\t\t\tif(l >= sizeof(tmp))\n\t\t\t\tl = sizeof(tmp) - 1;\n\t\t\tmemcpy(tmp, scope, l);\n\t\t\ttmp[l] = '\\0';\n\t\t\t*scope_id = (unsigned int)strtoul(tmp, NULL, 10);\n#endif\n\t\t}\n\t\tp3 = strchr(p1, '/');\n\t\tif(p2 && p3)\n\t\t{\n\t\t\tp2++;\n\t\t\tstrncpy(hostname, p1, MIN(MAXHOSTNAMELEN, (int)(p2-p1)));\n\t\t\tif(*p2 == ':')\n\t\t\t{\n\t\t\t\t*port = 0;\n\t\t\t\tp2++;\n\t\t\t\twhile( (*p2 >= '0') && (*p2 <= '9'))\n\t\t\t\t{\n\t\t\t\t\t*port *= 10;\n\t\t\t\t\t*port += (unsigned short)(*p2 - '0');\n\t\t\t\t\tp2++;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t*port = 80;\n\t\t\t}\n\t\t\t*path = p3;\n\t\t\treturn 1;\n\t\t}\n\t}\n\tp2 = strchr(p1, ':');\n\tp3 = strchr(p1, '/');\n\tif(!p3)\n\t\treturn 0;\n\tif(!p2 || (p2>p3))\n\t{\n\t\tstrncpy(hostname, p1, MIN(MAXHOSTNAMELEN, (int)(p3-p1)));\n\t\t*port = 80;\n\t}\n\telse\n\t{\n\t\tstrncpy(hostname, p1, MIN(MAXHOSTNAMELEN, (int)(p2-p1)));\n\t\t*port = 0;\n\t\tp2++;\n\t\twhile( (*p2 >= '0') && (*p2 <= '9'))\n\t\t{\n\t\t\t*port *= 10;\n\t\t\t*port += (unsigned short)(*p2 - '0');\n\t\t\tp2++;\n\t\t}\n\t}\n\t*path = p3;\n\treturn 1;\n}\n\nvoid *\nminiwget(const char * url, int * size, unsigned int scope_id)\n{\n\tunsigned short port;\n\tchar * path;\n\t/* protocol://host:port/chemin */\n\tchar hostname[MAXHOSTNAMELEN+1];\n\t*size = 0;\n\tif(!parseURL(url, hostname, &port, &path, &scope_id))\n\t\treturn NULL;\n#ifdef DEBUG\n\tprintf(\"parsed url : hostname='%s' port=%hu path='%s' scope_id=%u\\n\",\n\t       hostname, port, path, scope_id);\n#endif\n\treturn miniwget2(hostname, port, path, size, 0, 0, scope_id);\n}\n\nvoid *\nminiwget_getaddr(const char * url, int * size,\n                 char * addr, int addrlen, unsigned int scope_id)\n{\n\tunsigned short port;\n\tchar * path;\n\t/* protocol://host:port/path */\n\tchar hostname[MAXHOSTNAMELEN+1];\n\t*size = 0;\n\tif(addr)\n\t\taddr[0] = '\\0';\n\tif(!parseURL(url, hostname, &port, &path, &scope_id))\n\t\treturn NULL;\n#ifdef DEBUG\n\tprintf(\"parsed url : hostname='%s' port=%hu path='%s' scope_id=%u\\n\",\n\t       hostname, port, path, scope_id);\n#endif\n\treturn miniwget2(hostname, port, path, size, addr, addrlen, scope_id);\n}\n\n"], "filenames": ["miniupnpc/Changelog.txt", "miniupnpc/miniwget.c"], "buggy_code_start_loc": [2, 165], "buggy_code_end_loc": [2, 166], "fixing_code_start_loc": [3, 165], "fixing_code_end_loc": [6, 166], "type": "NVD-CWE-noinfo", "message": "The getHTTPResponse function in miniwget.c in MiniUPnP 1.9 allows remote attackers to cause a denial of service (crash) via crafted headers that trigger an out-of-bounds read.", "other": {"cve": {"id": "CVE-2014-3985", "sourceIdentifier": "cve@mitre.org", "published": "2014-09-11T18:55:06.213", "lastModified": "2020-09-28T14:57:26.363", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The getHTTPResponse function in miniwget.c in MiniUPnP 1.9 allows remote attackers to cause a denial of service (crash) via crafted headers that trigger an out-of-bounds read."}, {"lang": "es", "value": "La funci\u00f3n The getHTTPResponse en miniwget.c en MiniUPnP 1.9 permite a atacantes remotos causar una denegaci\u00f3n de servicio (ca\u00edda) a trav\u00e9s de cabeceras manipuladas que provocan una lectura fuera de rango."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:miniupnp_project:miniupnp:1.9:*:*:*:*:*:*:*", "matchCriteriaId": "3B816B17-B981-4A1D-A931-128D45FB56D7"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:opensuse:12.3:*:*:*:*:*:*:*", "matchCriteriaId": "DFBF430B-0832-44B0-AA0E-BA9E467F7668"}, {"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:opensuse:13.1:*:*:*:*:*:*:*", "matchCriteriaId": "A10BC294-9196-425F-9FB0-B1625465B47F"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-updates/2014-06/msg00039.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://seclists.org/oss-sec/2014/q2/201", "source": "cve@mitre.org", "tags": ["Exploit", "Mailing List", "Third Party Advisory"]}, {"url": "http://seclists.org/oss-sec/2014/q2/496", "source": "cve@mitre.org", "tags": ["Exploit", "Mailing List", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/67152", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1085618", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/miniupnp/miniupnp/commit/3a87aa2f10bd7f1408e1849bdb59c41dd63a9fe9", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/201701-41", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/miniupnp/miniupnp/commit/3a87aa2f10bd7f1408e1849bdb59c41dd63a9fe9"}}