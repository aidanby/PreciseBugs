{"buggy_code": ["import CoreUtils from '../CoreUtils'\nimport Dimensions from '../dimensions/Dimensions'\nimport Graphics from '../Graphics'\nimport Series from '../Series'\nimport Utils from '../../utils/Utils'\nimport Helpers from './Helpers'\n\n/**\n * ApexCharts Legend Class to draw legend.\n *\n * @module Legend\n **/\n\nclass Legend {\n  constructor(ctx, opts) {\n    this.ctx = ctx\n    this.w = ctx.w\n\n    this.onLegendClick = this.onLegendClick.bind(this)\n    this.onLegendHovered = this.onLegendHovered.bind(this)\n\n    this.isBarsDistributed =\n      this.w.config.chart.type === 'bar' &&\n      this.w.config.plotOptions.bar.distributed &&\n      this.w.config.series.length === 1\n\n    this.legendHelpers = new Helpers(this)\n  }\n\n  init() {\n    const w = this.w\n\n    const gl = w.globals\n    const cnf = w.config\n\n    const showLegendAlways =\n      (cnf.legend.showForSingleSeries && gl.series.length === 1) ||\n      this.isBarsDistributed ||\n      gl.series.length > 1\n\n    if ((showLegendAlways || !gl.axisCharts) && cnf.legend.show) {\n      while (gl.dom.elLegendWrap.firstChild) {\n        gl.dom.elLegendWrap.removeChild(gl.dom.elLegendWrap.firstChild)\n      }\n\n      this.drawLegends()\n      if (!Utils.isIE11()) {\n        this.legendHelpers.appendToForeignObject()\n      } else {\n        // IE11 doesn't supports foreignObject, hence append it to <head>\n        document\n          .getElementsByTagName('head')[0]\n          .appendChild(this.legendHelpers.getLegendStyles())\n      }\n\n      if (cnf.legend.position === 'bottom' || cnf.legend.position === 'top') {\n        this.legendAlignHorizontal()\n      } else if (\n        cnf.legend.position === 'right' ||\n        cnf.legend.position === 'left'\n      ) {\n        this.legendAlignVertical()\n      }\n    }\n  }\n\n  drawLegends() {\n    let self = this\n    let w = this.w\n\n    let fontFamily = w.config.legend.fontFamily\n\n    let legendNames = w.globals.seriesNames\n    let fillcolor = w.globals.colors.slice()\n\n    if (w.config.chart.type === 'heatmap') {\n      const ranges = w.config.plotOptions.heatmap.colorScale.ranges\n      legendNames = ranges.map((colorScale) => {\n        return colorScale.name\n          ? colorScale.name\n          : colorScale.from + ' - ' + colorScale.to\n      })\n      fillcolor = ranges.map((color) => color.color)\n    } else if (this.isBarsDistributed) {\n      legendNames = w.globals.labels.slice()\n    }\n    let legendFormatter = w.globals.legendFormatter\n\n    let isLegendInversed = w.config.legend.inverseOrder\n\n    for (\n      let i = isLegendInversed ? legendNames.length - 1 : 0;\n      isLegendInversed ? i >= 0 : i <= legendNames.length - 1;\n      isLegendInversed ? i-- : i++\n    ) {\n      let text = legendFormatter(legendNames[i], { seriesIndex: i, w })\n\n      let collapsedSeries = false\n      let ancillaryCollapsedSeries = false\n      if (w.globals.collapsedSeries.length > 0) {\n        for (let c = 0; c < w.globals.collapsedSeries.length; c++) {\n          if (w.globals.collapsedSeries[c].index === i) {\n            collapsedSeries = true\n          }\n        }\n      }\n\n      if (w.globals.ancillaryCollapsedSeriesIndices.length > 0) {\n        for (\n          let c = 0;\n          c < w.globals.ancillaryCollapsedSeriesIndices.length;\n          c++\n        ) {\n          if (w.globals.ancillaryCollapsedSeriesIndices[c] === i) {\n            ancillaryCollapsedSeries = true\n          }\n        }\n      }\n\n      let elMarker = document.createElement('span')\n      elMarker.classList.add('apexcharts-legend-marker')\n\n      let mOffsetX = w.config.legend.markers.offsetX\n      let mOffsetY = w.config.legend.markers.offsetY\n      let mHeight = w.config.legend.markers.height\n      let mWidth = w.config.legend.markers.width\n      let mBorderWidth = w.config.legend.markers.strokeWidth\n      let mBorderColor = w.config.legend.markers.strokeColor\n      let mBorderRadius = w.config.legend.markers.radius\n\n      let mStyle = elMarker.style\n\n      mStyle.background = fillcolor[i]\n      mStyle.color = fillcolor[i]\n      mStyle.setProperty('background', fillcolor[i], 'important')\n\n      // override fill color with custom legend.markers.fillColors\n      if (\n        w.config.legend.markers.fillColors &&\n        w.config.legend.markers.fillColors[i]\n      ) {\n        mStyle.background = w.config.legend.markers.fillColors[i]\n      }\n\n      // override with data color\n      if (w.globals.seriesColors[i] !== undefined) {\n        mStyle.background = w.globals.seriesColors[i]\n        mStyle.color = w.globals.seriesColors[i]\n      }\n\n      mStyle.height = Array.isArray(mHeight)\n        ? parseFloat(mHeight[i]) + 'px'\n        : parseFloat(mHeight) + 'px'\n      mStyle.width = Array.isArray(mWidth)\n        ? parseFloat(mWidth[i]) + 'px'\n        : parseFloat(mWidth) + 'px'\n      mStyle.left = Array.isArray(mOffsetX) ? mOffsetX[i] : mOffsetX\n      mStyle.top = Array.isArray(mOffsetY) ? mOffsetY[i] : mOffsetY\n      mStyle.borderWidth = Array.isArray(mBorderWidth)\n        ? mBorderWidth[i]\n        : mBorderWidth\n      mStyle.borderColor = Array.isArray(mBorderColor)\n        ? mBorderColor[i]\n        : mBorderColor\n      mStyle.borderRadius = Array.isArray(mBorderRadius)\n        ? parseFloat(mBorderRadius[i]) + 'px'\n        : parseFloat(mBorderRadius) + 'px'\n\n      if (w.config.legend.markers.customHTML) {\n        if (Array.isArray(w.config.legend.markers.customHTML)) {\n          if (w.config.legend.markers.customHTML[i]) {\n            elMarker.innerHTML = w.config.legend.markers.customHTML[i]()\n          }\n        } else {\n          elMarker.innerHTML = w.config.legend.markers.customHTML()\n        }\n      }\n\n      Graphics.setAttrs(elMarker, {\n        rel: i + 1,\n        'data:collapsed': collapsedSeries || ancillaryCollapsedSeries\n      })\n\n      if (collapsedSeries || ancillaryCollapsedSeries) {\n        elMarker.classList.add('apexcharts-inactive-legend')\n      }\n\n      let elLegend = document.createElement('div')\n\n      let elLegendText = document.createElement('span')\n      elLegendText.classList.add('apexcharts-legend-text')\n      elLegendText.innerHTML = Array.isArray(text) ? text.join(' ') : text\n\n      let textColor = w.config.legend.labels.useSeriesColors\n        ? w.globals.colors[i]\n        : w.config.legend.labels.colors\n\n      if (!textColor) {\n        textColor = w.config.chart.foreColor\n      }\n\n      elLegendText.style.color = textColor\n\n      elLegendText.style.fontSize = parseFloat(w.config.legend.fontSize) + 'px'\n      elLegendText.style.fontWeight = w.config.legend.fontWeight\n      elLegendText.style.fontFamily = fontFamily || w.config.chart.fontFamily\n\n      Graphics.setAttrs(elLegendText, {\n        rel: i + 1,\n        i,\n        'data:default-text': encodeURIComponent(text),\n        'data:collapsed': collapsedSeries || ancillaryCollapsedSeries\n      })\n\n      elLegend.appendChild(elMarker)\n      elLegend.appendChild(elLegendText)\n\n      const coreUtils = new CoreUtils(this.ctx)\n      if (!w.config.legend.showForZeroSeries) {\n        const total = coreUtils.getSeriesTotalByIndex(i)\n\n        if (\n          total === 0 &&\n          coreUtils.seriesHaveSameValues(i) &&\n          !coreUtils.isSeriesNull(i) &&\n          w.globals.collapsedSeriesIndices.indexOf(i) === -1 &&\n          w.globals.ancillaryCollapsedSeriesIndices.indexOf(i) === -1\n        ) {\n          elLegend.classList.add('apexcharts-hidden-zero-series')\n        }\n      }\n\n      if (!w.config.legend.showForNullSeries) {\n        if (\n          coreUtils.isSeriesNull(i) &&\n          w.globals.collapsedSeriesIndices.indexOf(i) === -1 &&\n          w.globals.ancillaryCollapsedSeriesIndices.indexOf(i) === -1\n        ) {\n          elLegend.classList.add('apexcharts-hidden-null-series')\n        }\n      }\n\n      w.globals.dom.elLegendWrap.appendChild(elLegend)\n      w.globals.dom.elLegendWrap.classList.add(\n        `apexcharts-align-${w.config.legend.horizontalAlign}`\n      )\n      w.globals.dom.elLegendWrap.classList.add(\n        'position-' + w.config.legend.position\n      )\n\n      elLegend.classList.add('apexcharts-legend-series')\n      elLegend.style.margin = `${w.config.legend.itemMargin.vertical}px ${w.config.legend.itemMargin.horizontal}px`\n      w.globals.dom.elLegendWrap.style.width = w.config.legend.width\n        ? w.config.legend.width + 'px'\n        : ''\n      w.globals.dom.elLegendWrap.style.height = w.config.legend.height\n        ? w.config.legend.height + 'px'\n        : ''\n\n      Graphics.setAttrs(elLegend, {\n        rel: i + 1,\n        seriesName: Utils.escapeString(legendNames[i]),\n        'data:collapsed': collapsedSeries || ancillaryCollapsedSeries\n      })\n\n      if (collapsedSeries || ancillaryCollapsedSeries) {\n        elLegend.classList.add('apexcharts-inactive-legend')\n      }\n\n      if (!w.config.legend.onItemClick.toggleDataSeries) {\n        elLegend.classList.add('apexcharts-no-click')\n      }\n    }\n\n    w.globals.dom.elWrap.addEventListener('click', self.onLegendClick, true)\n\n    if (w.config.legend.onItemHover.highlightDataSeries) {\n      w.globals.dom.elWrap.addEventListener(\n        'mousemove',\n        self.onLegendHovered,\n        true\n      )\n      w.globals.dom.elWrap.addEventListener(\n        'mouseout',\n        self.onLegendHovered,\n        true\n      )\n    }\n  }\n\n  setLegendWrapXY(offsetX, offsetY) {\n    let w = this.w\n\n    let elLegendWrap = w.globals.dom.baseEl.querySelector('.apexcharts-legend')\n\n    const legendRect = elLegendWrap.getBoundingClientRect()\n\n    let x = 0\n    let y = 0\n\n    if (w.config.legend.position === 'bottom') {\n      y = y + (w.globals.svgHeight - legendRect.height / 2)\n    } else if (w.config.legend.position === 'top') {\n      const dim = new Dimensions(this.ctx)\n      const titleH = dim.dimHelpers.getTitleSubtitleCoords('title').height\n      const subtitleH = dim.dimHelpers.getTitleSubtitleCoords('subtitle').height\n\n      y =\n        y +\n        (titleH > 0 ? titleH - 10 : 0) +\n        (subtitleH > 0 ? subtitleH - 10 : 0)\n    }\n\n    elLegendWrap.style.position = 'absolute'\n\n    x = x + offsetX + w.config.legend.offsetX\n    y = y + offsetY + w.config.legend.offsetY\n\n    elLegendWrap.style.left = x + 'px'\n    elLegendWrap.style.top = y + 'px'\n\n    if (w.config.legend.position === 'bottom') {\n      elLegendWrap.style.top = 'auto'\n      elLegendWrap.style.bottom = 5 - w.config.legend.offsetY + 'px'\n    } else if (w.config.legend.position === 'right') {\n      elLegendWrap.style.left = 'auto'\n      elLegendWrap.style.right = 25 + w.config.legend.offsetX + 'px'\n    }\n\n    const fixedHeigthWidth = ['width', 'height']\n    fixedHeigthWidth.forEach((hw) => {\n      if (elLegendWrap.style[hw]) {\n        elLegendWrap.style[hw] = parseInt(w.config.legend[hw], 10) + 'px'\n      }\n    })\n  }\n\n  legendAlignHorizontal() {\n    let w = this.w\n\n    let elLegendWrap = w.globals.dom.baseEl.querySelector('.apexcharts-legend')\n\n    elLegendWrap.style.right = 0\n\n    let lRect = this.legendHelpers.getLegendBBox()\n\n    let dimensions = new Dimensions(this.ctx)\n    let titleRect = dimensions.dimHelpers.getTitleSubtitleCoords('title')\n    let subtitleRect = dimensions.dimHelpers.getTitleSubtitleCoords('subtitle')\n\n    let offsetX = 20\n    let offsetY = 0\n\n    // the whole legend box is set to bottom\n    if (w.config.legend.position === 'bottom') {\n      offsetY = -lRect.clwh / 1.8\n    } else if (w.config.legend.position === 'top') {\n      offsetY =\n        titleRect.height +\n        subtitleRect.height +\n        w.config.title.margin +\n        w.config.subtitle.margin -\n        10\n    }\n\n    this.setLegendWrapXY(offsetX, offsetY)\n  }\n\n  legendAlignVertical() {\n    let w = this.w\n\n    let lRect = this.legendHelpers.getLegendBBox()\n\n    let offsetY = 20\n    let offsetX = 0\n\n    if (w.config.legend.position === 'left') {\n      offsetX = 20\n    }\n\n    if (w.config.legend.position === 'right') {\n      offsetX = w.globals.svgWidth - lRect.clww - 10\n    }\n\n    this.setLegendWrapXY(offsetX, offsetY)\n  }\n\n  onLegendHovered(e) {\n    const w = this.w\n\n    const hoverOverLegend =\n      e.target.classList.contains('apexcharts-legend-text') ||\n      e.target.classList.contains('apexcharts-legend-marker')\n\n    if (w.config.chart.type !== 'heatmap' && !this.isBarsDistributed) {\n      if (\n        !e.target.classList.contains('apexcharts-inactive-legend') &&\n        hoverOverLegend\n      ) {\n        let series = new Series(this.ctx)\n        series.toggleSeriesOnHover(e, e.target)\n      }\n    } else {\n      // for heatmap handling\n      if (hoverOverLegend) {\n        let seriesCnt = parseInt(e.target.getAttribute('rel'), 10) - 1\n        this.ctx.events.fireEvent('legendHover', [this.ctx, seriesCnt, this.w])\n\n        let series = new Series(this.ctx)\n        series.highlightRangeInSeries(e, e.target)\n      }\n    }\n  }\n\n  onLegendClick(e) {\n    const w = this.w\n\n    if (\n      e.target.classList.contains('apexcharts-legend-text') ||\n      e.target.classList.contains('apexcharts-legend-marker')\n    ) {\n      let seriesCnt = parseInt(e.target.getAttribute('rel'), 10) - 1\n      let isHidden = e.target.getAttribute('data:collapsed') === 'true'\n\n      const legendClick = this.w.config.chart.events.legendClick\n      if (typeof legendClick === 'function') {\n        legendClick(this.ctx, seriesCnt, this.w)\n      }\n\n      this.ctx.events.fireEvent('legendClick', [this.ctx, seriesCnt, this.w])\n\n      const markerClick = this.w.config.legend.markers.onClick\n      if (\n        typeof markerClick === 'function' &&\n        e.target.classList.contains('apexcharts-legend-marker')\n      ) {\n        markerClick(this.ctx, seriesCnt, this.w)\n        this.ctx.events.fireEvent('legendMarkerClick', [\n          this.ctx,\n          seriesCnt,\n          this.w\n        ])\n      }\n\n      // for now - just prevent click on heatmap legend - and allow hover only\n      const clickAllowed =\n        w.config.chart.type !== 'treemap' &&\n        w.config.chart.type !== 'heatmap' &&\n        !this.isBarsDistributed\n\n      if (clickAllowed && w.config.legend.onItemClick.toggleDataSeries) {\n        this.legendHelpers.toggleDataSeries(seriesCnt, isHidden)\n      }\n    }\n  }\n}\n\nexport default Legend\n", "import Formatters from '../Formatters'\nimport DateTime from '../../utils/DateTime'\nimport Utils from './Utils'\n\n/**\n * ApexCharts Tooltip.Labels Class to draw texts on the tooltip.\n *\n * @module Tooltip.Labels\n **/\n\nexport default class Labels {\n  constructor(tooltipContext) {\n    this.w = tooltipContext.w\n    this.ctx = tooltipContext.ctx\n    this.ttCtx = tooltipContext\n    this.tooltipUtil = new Utils(tooltipContext)\n  }\n\n  drawSeriesTexts({ shared = true, ttItems, i = 0, j = null, y1, y2, e }) {\n    let w = this.w\n\n    if (w.config.tooltip.custom !== undefined) {\n      this.handleCustomTooltip({ i, j, y1, y2, w })\n    } else {\n      this.toggleActiveInactiveSeries(shared)\n    }\n\n    let values = this.getValuesToPrint({\n      i,\n      j\n    })\n\n    this.printLabels({\n      i,\n      j,\n      values,\n      ttItems,\n      shared,\n      e\n    })\n\n    // Re-calculate tooltip dimensions now that we have drawn the text\n    const tooltipEl = this.ttCtx.getElTooltip()\n\n    this.ttCtx.tooltipRect.ttWidth = tooltipEl.getBoundingClientRect().width\n    this.ttCtx.tooltipRect.ttHeight = tooltipEl.getBoundingClientRect().height\n  }\n\n  printLabels({ i, j, values, ttItems, shared, e }) {\n    const w = this.w\n    let val\n    const { xVal, zVal, xAxisTTVal } = values\n\n    let seriesName = ''\n\n    let pColor = w.globals.colors[i]\n    if (j !== null && w.config.plotOptions.bar.distributed) {\n      pColor = w.globals.colors[j]\n    }\n\n    for (\n      let t = 0, inverset = w.globals.series.length - 1;\n      t < w.globals.series.length;\n      t++, inverset--\n    ) {\n      let f = this.getFormatters(i)\n      seriesName = this.getSeriesName({\n        fn: f.yLbTitleFormatter,\n        index: i,\n        seriesIndex: i,\n        j\n      })\n\n      if (w.config.chart.type === 'treemap') {\n        seriesName = f.yLbTitleFormatter(String(w.config.series[i].data[j].x), {\n          series: w.globals.series,\n          seriesIndex: i,\n          dataPointIndex: j,\n          w\n        })\n      }\n\n      const tIndex = w.config.tooltip.inverseOrder ? inverset : t\n\n      if (w.globals.axisCharts) {\n        const generalFormatter = (index) => {\n          return f.yLbFormatter(w.globals.series[index][j], {\n            series: w.globals.series,\n            seriesIndex: index,\n            dataPointIndex: j,\n            w\n          })\n        }\n        if (shared) {\n          f = this.getFormatters(tIndex)\n\n          seriesName = this.getSeriesName({\n            fn: f.yLbTitleFormatter,\n            index: tIndex,\n            seriesIndex: i,\n            j\n          })\n          pColor = w.globals.colors[tIndex]\n\n          val = generalFormatter(tIndex)\n        } else {\n          if (e && e.target && e.target.getAttribute('fill')) {\n            pColor = e.target.getAttribute('fill')\n          }\n          val = generalFormatter(i)\n        }\n      }\n\n      // for pie / donuts\n      if (j === null) {\n        val = f.yLbFormatter(w.globals.series[i], {\n          ...w,\n          seriesIndex: i,\n          dataPointIndex: i\n        })\n      }\n\n      this.DOMHandling({\n        i,\n        t: tIndex,\n        j,\n        ttItems,\n        values: {\n          val,\n          xVal,\n          xAxisTTVal,\n          zVal\n        },\n        seriesName,\n        shared,\n        pColor\n      })\n    }\n  }\n\n  getFormatters(i) {\n    const w = this.w\n\n    let yLbFormatter = w.globals.yLabelFormatters[i]\n    let yLbTitleFormatter\n\n    if (w.globals.ttVal !== undefined) {\n      if (Array.isArray(w.globals.ttVal)) {\n        yLbFormatter = w.globals.ttVal[i] && w.globals.ttVal[i].formatter\n        yLbTitleFormatter =\n          w.globals.ttVal[i] &&\n          w.globals.ttVal[i].title &&\n          w.globals.ttVal[i].title.formatter\n      } else {\n        yLbFormatter = w.globals.ttVal.formatter\n        if (typeof w.globals.ttVal.title.formatter === 'function') {\n          yLbTitleFormatter = w.globals.ttVal.title.formatter\n        }\n      }\n    } else {\n      yLbTitleFormatter = w.config.tooltip.y.title.formatter\n    }\n\n    if (typeof yLbFormatter !== 'function') {\n      if (w.globals.yLabelFormatters[0]) {\n        yLbFormatter = w.globals.yLabelFormatters[0]\n      } else {\n        yLbFormatter = function(label) {\n          return label\n        }\n      }\n    }\n\n    if (typeof yLbTitleFormatter !== 'function') {\n      yLbTitleFormatter = function(label) {\n        return label\n      }\n    }\n\n    return {\n      yLbFormatter,\n      yLbTitleFormatter\n    }\n  }\n\n  getSeriesName({ fn, index, seriesIndex, j }) {\n    const w = this.w\n    return fn(String(w.globals.seriesNames[index]), {\n      series: w.globals.series,\n      seriesIndex,\n      dataPointIndex: j,\n      w\n    })\n  }\n\n  DOMHandling({ i, t, j, ttItems, values, seriesName, shared, pColor }) {\n    const w = this.w\n    const ttCtx = this.ttCtx\n\n    const { val, xVal, xAxisTTVal, zVal } = values\n\n    let ttItemsChildren = null\n    ttItemsChildren = ttItems[t].children\n\n    if (w.config.tooltip.fillSeriesColor) {\n      //  elTooltip.style.backgroundColor = pColor\n      ttItems[t].style.backgroundColor = pColor\n      ttItemsChildren[0].style.display = 'none'\n    }\n\n    if (ttCtx.showTooltipTitle) {\n      if (ttCtx.tooltipTitle === null) {\n        // get it once if null, and store it in class property\n        ttCtx.tooltipTitle = w.globals.dom.baseEl.querySelector(\n          '.apexcharts-tooltip-title'\n        )\n      }\n      ttCtx.tooltipTitle.innerHTML = xVal\n    }\n\n    // if xaxis tooltip is constructed, we need to replace the innerHTML\n    if (ttCtx.blxaxisTooltip) {\n      ttCtx.xaxisTooltipText.innerHTML = xAxisTTVal !== '' ? xAxisTTVal : xVal\n    }\n\n    const ttYLabel = ttItems[t].querySelector('.apexcharts-tooltip-text-label')\n    if (ttYLabel) {\n      ttYLabel.innerHTML = seriesName ? seriesName : ''\n    }\n    const ttYVal = ttItems[t].querySelector('.apexcharts-tooltip-text-value')\n    if (ttYVal) {\n      ttYVal.innerHTML = typeof val !== 'undefined' ? val : ''\n    }\n\n    if (\n      ttItemsChildren[0] &&\n      ttItemsChildren[0].classList.contains('apexcharts-tooltip-marker')\n    ) {\n      if (\n        w.config.tooltip.marker.fillColors &&\n        Array.isArray(w.config.tooltip.marker.fillColors)\n      ) {\n        pColor = w.config.tooltip.marker.fillColors[t]\n      }\n\n      ttItemsChildren[0].style.backgroundColor = pColor\n    }\n\n    if (!w.config.tooltip.marker.show) {\n      ttItemsChildren[0].style.display = 'none'\n    }\n\n    if (zVal !== null) {\n      const ttZLabel = ttItems[t].querySelector(\n        '.apexcharts-tooltip-text-z-label'\n      )\n      ttZLabel.innerHTML = w.config.tooltip.z.title\n      const ttZVal = ttItems[t].querySelector(\n        '.apexcharts-tooltip-text-z-value'\n      )\n      ttZVal.innerHTML = typeof zVal !== 'undefined' ? zVal : ''\n    }\n\n    if (shared && ttItemsChildren[0]) {\n      // hide when no Val or series collapsed\n      if (\n        typeof val === 'undefined' ||\n        val === null ||\n        w.globals.collapsedSeriesIndices.indexOf(t) > -1\n      ) {\n        ttItemsChildren[0].parentNode.style.display = 'none'\n      } else {\n        ttItemsChildren[0].parentNode.style.display =\n          w.config.tooltip.items.display\n      }\n\n      // TODO: issue #1240 needs to be looked at again. commenting it because this also hides single series values with 0 in it (shared tooltip)\n\n      // if (w.globals.stackedSeriesTotals[j] === 0) {\n      //   // shared tooltip and all values are null, so we need to hide the x value too\n      //   let allYZeroForJ = false\n      //   for (let si = 1; si < w.globals.seriesYvalues.length; si++) {\n      //     if (\n      //       w.globals.seriesYvalues[si][j] ===\n      //       w.globals.seriesYvalues[si - 1][j]\n      //     ) {\n      //       allYZeroForJ = true\n      //     }\n      //   }\n\n      //   if (allYZeroForJ) {\n      //     ttCtx.tooltipTitle.style.display = 'none'\n      //   } else {\n      //     ttCtx.tooltipTitle.style.display = w.config.tooltip.items.display\n      //   }\n      // } else {\n      //   ttCtx.tooltipTitle.style.display = w.config.tooltip.items.display\n      // }\n    }\n  }\n\n  toggleActiveInactiveSeries(shared) {\n    const w = this.w\n    if (shared) {\n      // make all tooltips active\n      this.tooltipUtil.toggleAllTooltipSeriesGroups('enable')\n    } else {\n      // disable all tooltip text groups\n      this.tooltipUtil.toggleAllTooltipSeriesGroups('disable')\n\n      // enable the first tooltip text group\n      let firstTooltipSeriesGroup = w.globals.dom.baseEl.querySelector(\n        '.apexcharts-tooltip-series-group'\n      )\n\n      if (firstTooltipSeriesGroup) {\n        firstTooltipSeriesGroup.classList.add('apexcharts-active')\n        firstTooltipSeriesGroup.style.display = w.config.tooltip.items.display\n      }\n    }\n  }\n\n  getValuesToPrint({ i, j }) {\n    const w = this.w\n    const filteredSeriesX = this.ctx.series.filteredSeriesX()\n\n    let xVal = ''\n    let xAxisTTVal = ''\n    let zVal = null\n    let val = null\n\n    const customFormatterOpts = {\n      series: w.globals.series,\n      seriesIndex: i,\n      dataPointIndex: j,\n      w\n    }\n\n    let zFormatter = w.globals.ttZFormatter\n\n    if (j === null) {\n      val = w.globals.series[i]\n    } else {\n      if (w.globals.isXNumeric && w.config.chart.type !== 'treemap') {\n        xVal = filteredSeriesX[i][j]\n        if (filteredSeriesX[i].length === 0) {\n          // a series (possibly the first one) might be collapsed, so get the next active index\n          const firstActiveSeriesIndex = this.tooltipUtil.getFirstActiveXArray(\n            filteredSeriesX\n          )\n          xVal = filteredSeriesX[firstActiveSeriesIndex][j]\n        }\n      } else {\n        xVal =\n          typeof w.globals.labels[j] !== 'undefined' ? w.globals.labels[j] : ''\n      }\n    }\n\n    let bufferXVal = xVal\n\n    if (w.globals.isXNumeric && w.config.xaxis.type === 'datetime') {\n      let xFormat = new Formatters(this.ctx)\n      xVal = xFormat.xLabelFormat(\n        w.globals.ttKeyFormatter,\n        bufferXVal,\n        bufferXVal,\n        {\n          i: undefined,\n          dateFormatter: new DateTime(this.ctx).formatDate,\n          w: this.w\n        }\n      )\n    } else {\n      if (w.globals.isBarHorizontal) {\n        xVal = w.globals.yLabelFormatters[0](bufferXVal, customFormatterOpts)\n      } else {\n        xVal = w.globals.xLabelFormatter(bufferXVal, customFormatterOpts)\n      }\n    }\n\n    // override default x-axis formatter with tooltip formatter\n    if (w.config.tooltip.x.formatter !== undefined) {\n      xVal = w.globals.ttKeyFormatter(bufferXVal, customFormatterOpts)\n    }\n\n    if (w.globals.seriesZ.length > 0 && w.globals.seriesZ[i].length > 0) {\n      zVal = zFormatter(w.globals.seriesZ[i][j], w)\n    }\n\n    if (typeof w.config.xaxis.tooltip.formatter === 'function') {\n      xAxisTTVal = w.globals.xaxisTooltipFormatter(\n        bufferXVal,\n        customFormatterOpts\n      )\n    } else {\n      xAxisTTVal = xVal\n    }\n\n    return {\n      val: Array.isArray(val) ? val.join(' ') : val,\n      xVal: Array.isArray(xVal) ? xVal.join(' ') : xVal,\n      xAxisTTVal: Array.isArray(xAxisTTVal) ? xAxisTTVal.join(' ') : xAxisTTVal,\n      zVal\n    }\n  }\n\n  handleCustomTooltip({ i, j, y1, y2, w }) {\n    const tooltipEl = this.ttCtx.getElTooltip()\n    let fn = w.config.tooltip.custom\n\n    if (Array.isArray(fn) && fn[i]) {\n      fn = fn[i]\n    }\n\n    // override everything with a custom html tooltip and replace it\n    tooltipEl.innerHTML = fn({\n      ctx: this.ctx,\n      series: w.globals.series,\n      seriesIndex: i,\n      dataPointIndex: j,\n      y1,\n      y2,\n      w\n    })\n  }\n}\n", "/*\n ** Generic functions which are not dependent on ApexCharts\n */\n\nclass Utils {\n  static bind(fn, me) {\n    return function() {\n      return fn.apply(me, arguments)\n    }\n  }\n\n  static isObject(item) {\n    return (\n      item && typeof item === 'object' && !Array.isArray(item) && item != null\n    )\n  }\n\n  static listToArray(list) {\n    let i,\n      array = []\n    for (i = 0; i < list.length; i++) {\n      array[i] = list[i]\n    }\n    return array\n  }\n\n  // to extend defaults with user options\n  // credit: http://stackoverflow.com/questions/27936772/deep-object-merging-in-es6-es7#answer-34749873\n  static extend(target, source) {\n    if (typeof Object.assign !== 'function') {\n      ;(function() {\n        Object.assign = function(target) {\n          'use strict'\n          // We must check against these specific cases.\n          if (target === undefined || target === null) {\n            throw new TypeError('Cannot convert undefined or null to object')\n          }\n\n          let output = Object(target)\n          for (let index = 1; index < arguments.length; index++) {\n            let source = arguments[index]\n            if (source !== undefined && source !== null) {\n              for (let nextKey in source) {\n                if (source.hasOwnProperty(nextKey)) {\n                  output[nextKey] = source[nextKey]\n                }\n              }\n            }\n          }\n          return output\n        }\n      })()\n    }\n\n    let output = Object.assign({}, target)\n    if (this.isObject(target) && this.isObject(source)) {\n      Object.keys(source).forEach((key) => {\n        if (this.isObject(source[key])) {\n          if (!(key in target)) {\n            Object.assign(output, {\n              [key]: source[key]\n            })\n          } else {\n            output[key] = this.extend(target[key], source[key])\n          }\n        } else {\n          Object.assign(output, {\n            [key]: source[key]\n          })\n        }\n      })\n    }\n    return output\n  }\n\n  static extendArray(arrToExtend, resultArr) {\n    let extendedArr = []\n    arrToExtend.map((item) => {\n      extendedArr.push(Utils.extend(resultArr, item))\n    })\n    arrToExtend = extendedArr\n    return arrToExtend\n  }\n\n  // If month counter exceeds 12, it starts again from 1\n  static monthMod(month) {\n    return month % 12\n  }\n\n  static clone(source) {\n    if (Object.prototype.toString.call(source) === '[object Array]') {\n      let cloneResult = []\n      for (let i = 0; i < source.length; i++) {\n        cloneResult[i] = this.clone(source[i])\n      }\n      return cloneResult\n    } else if (Object.prototype.toString.call(source) === '[object Null]') {\n      // fixes an issue where null values were converted to {}\n      return null\n    } else if (Object.prototype.toString.call(source) === '[object Date]') {\n      return source\n    } else if (typeof source === 'object') {\n      let cloneResult = {}\n      for (let prop in source) {\n        if (source.hasOwnProperty(prop)) {\n          cloneResult[prop] = this.clone(source[prop])\n        }\n      }\n      return cloneResult\n    } else {\n      return source\n    }\n  }\n\n  static log10(x) {\n    return Math.log(x) / Math.LN10\n  }\n\n  static roundToBase10(x) {\n    return Math.pow(10, Math.floor(Math.log10(x)))\n  }\n\n  static roundToBase(x, base) {\n    return Math.pow(base, Math.floor(Math.log(x) / Math.log(base)))\n  }\n\n  static parseNumber(val) {\n    if (val === null) return val\n    return parseFloat(val)\n  }\n\n  static randomId() {\n    return (Math.random() + 1).toString(36).substring(4)\n  }\n\n  static noExponents(val) {\n    let data = String(val).split(/[eE]/)\n    if (data.length === 1) return data[0]\n\n    let z = '',\n      sign = val < 0 ? '-' : '',\n      str = data[0].replace('.', ''),\n      mag = Number(data[1]) + 1\n\n    if (mag < 0) {\n      z = sign + '0.'\n      while (mag++) z += '0'\n      return z + str.replace(/^-/, '')\n    }\n    mag -= str.length\n    while (mag--) z += '0'\n    return str + z\n  }\n\n  static getDimensions(el) {\n    const computedStyle = getComputedStyle(el, null)\n\n    let elementHeight = el.clientHeight\n    let elementWidth = el.clientWidth\n    elementHeight -=\n      parseFloat(computedStyle.paddingTop) +\n      parseFloat(computedStyle.paddingBottom)\n    elementWidth -=\n      parseFloat(computedStyle.paddingLeft) +\n      parseFloat(computedStyle.paddingRight)\n\n    return [elementWidth, elementHeight]\n  }\n\n  static getBoundingClientRect(element) {\n    const rect = element.getBoundingClientRect()\n    return {\n      top: rect.top,\n      right: rect.right,\n      bottom: rect.bottom,\n      left: rect.left,\n      width: element.clientWidth,\n      height: element.clientHeight,\n      x: rect.left,\n      y: rect.top\n    }\n  }\n\n  static getLargestStringFromArr(arr) {\n    return arr.reduce((a, b) => {\n      if (Array.isArray(b)) {\n        b = b.reduce((aa, bb) => (aa.length > bb.length ? aa : bb))\n      }\n      return a.length > b.length ? a : b\n    }, 0)\n  }\n\n  // http://stackoverflow.com/questions/5623838/rgb-to-hex-and-hex-to-rgb#answer-12342275\n  static hexToRgba(hex = '#999999', opacity = 0.6) {\n    if (hex.substring(0, 1) !== '#') {\n      hex = '#999999'\n    }\n\n    let h = hex.replace('#', '')\n    h = h.match(new RegExp('(.{' + h.length / 3 + '})', 'g'))\n\n    for (let i = 0; i < h.length; i++) {\n      h[i] = parseInt(h[i].length === 1 ? h[i] + h[i] : h[i], 16)\n    }\n\n    if (typeof opacity !== 'undefined') h.push(opacity)\n\n    return 'rgba(' + h.join(',') + ')'\n  }\n\n  static getOpacityFromRGBA(rgba) {\n    return parseFloat(rgba.replace(/^.*,(.+)\\)/, '$1'))\n  }\n\n  static rgb2hex(rgb) {\n    rgb = rgb.match(\n      /^rgba?[\\s+]?\\([\\s+]?(\\d+)[\\s+]?,[\\s+]?(\\d+)[\\s+]?,[\\s+]?(\\d+)[\\s+]?/i\n    )\n    return rgb && rgb.length === 4\n      ? '#' +\n          ('0' + parseInt(rgb[1], 10).toString(16)).slice(-2) +\n          ('0' + parseInt(rgb[2], 10).toString(16)).slice(-2) +\n          ('0' + parseInt(rgb[3], 10).toString(16)).slice(-2)\n      : ''\n  }\n\n  shadeRGBColor(percent, color) {\n    let f = color.split(','),\n      t = percent < 0 ? 0 : 255,\n      p = percent < 0 ? percent * -1 : percent,\n      R = parseInt(f[0].slice(4), 10),\n      G = parseInt(f[1], 10),\n      B = parseInt(f[2], 10)\n    return (\n      'rgb(' +\n      (Math.round((t - R) * p) + R) +\n      ',' +\n      (Math.round((t - G) * p) + G) +\n      ',' +\n      (Math.round((t - B) * p) + B) +\n      ')'\n    )\n  }\n\n  shadeHexColor(percent, color) {\n    let f = parseInt(color.slice(1), 16),\n      t = percent < 0 ? 0 : 255,\n      p = percent < 0 ? percent * -1 : percent,\n      R = f >> 16,\n      G = (f >> 8) & 0x00ff,\n      B = f & 0x0000ff\n    return (\n      '#' +\n      (\n        0x1000000 +\n        (Math.round((t - R) * p) + R) * 0x10000 +\n        (Math.round((t - G) * p) + G) * 0x100 +\n        (Math.round((t - B) * p) + B)\n      )\n        .toString(16)\n        .slice(1)\n    )\n  }\n\n  // beautiful color shading blending code\n  // http://stackoverflow.com/questions/5560248/programmatically-lighten-or-darken-a-hex-color-or-rgb-and-blend-colors\n  shadeColor(p, color) {\n    if (Utils.isColorHex(color)) {\n      return this.shadeHexColor(p, color)\n    } else {\n      return this.shadeRGBColor(p, color)\n    }\n  }\n\n  static isColorHex(color) {\n    return /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)|(^#[0-9A-F]{8}$)/i.test(color)\n  }\n\n  static polarToCartesian(centerX, centerY, radius, angleInDegrees) {\n    let angleInRadians = ((angleInDegrees - 90) * Math.PI) / 180.0\n\n    return {\n      x: centerX + radius * Math.cos(angleInRadians),\n      y: centerY + radius * Math.sin(angleInRadians)\n    }\n  }\n\n  static escapeString(str, escapeWith = 'x') {\n    let newStr = str.toString().slice()\n    newStr = newStr.replace(\n      /[` ~!@#$%^&*()_|+\\-=?;:'\",.<>{}[\\]\\\\/]/gi,\n      escapeWith\n    )\n    return newStr\n  }\n\n  static negToZero(val) {\n    return val < 0 ? 0 : val\n  }\n\n  static moveIndexInArray(arr, old_index, new_index) {\n    if (new_index >= arr.length) {\n      let k = new_index - arr.length + 1\n      while (k--) {\n        arr.push(undefined)\n      }\n    }\n    arr.splice(new_index, 0, arr.splice(old_index, 1)[0])\n    return arr\n  }\n\n  static extractNumber(s) {\n    return parseFloat(s.replace(/[^\\d.]*/g, ''))\n  }\n\n  static findAncestor(el, cls) {\n    while ((el = el.parentElement) && !el.classList.contains(cls));\n    return el\n  }\n\n  static setELstyles(el, styles) {\n    for (let key in styles) {\n      if (styles.hasOwnProperty(key)) {\n        el.style.key = styles[key]\n      }\n    }\n  }\n\n  static isNumber(value) {\n    return (\n      !isNaN(value) &&\n      parseFloat(Number(value)) === value &&\n      !isNaN(parseInt(value, 10))\n    )\n  }\n\n  static isFloat(n) {\n    return Number(n) === n && n % 1 !== 0\n  }\n\n  static isSafari() {\n    return /^((?!chrome|android).)*safari/i.test(navigator.userAgent)\n  }\n\n  static isFirefox() {\n    return navigator.userAgent.toLowerCase().indexOf('firefox') > -1\n  }\n\n  static isIE11() {\n    if (\n      window.navigator.userAgent.indexOf('MSIE') !== -1 ||\n      window.navigator.appVersion.indexOf('Trident/') > -1\n    ) {\n      return true\n    }\n  }\n\n  static isIE() {\n    let ua = window.navigator.userAgent\n\n    let msie = ua.indexOf('MSIE ')\n    if (msie > 0) {\n      // IE 10 or older => return version number\n      return parseInt(ua.substring(msie + 5, ua.indexOf('.', msie)), 10)\n    }\n\n    let trident = ua.indexOf('Trident/')\n    if (trident > 0) {\n      // IE 11 => return version number\n      let rv = ua.indexOf('rv:')\n      return parseInt(ua.substring(rv + 3, ua.indexOf('.', rv)), 10)\n    }\n\n    let edge = ua.indexOf('Edge/')\n    if (edge > 0) {\n      // Edge (IE 12+) => return version number\n      return parseInt(ua.substring(edge + 5, ua.indexOf('.', edge)), 10)\n    }\n\n    // other browser\n    return false\n  }\n}\n\nexport default Utils\n"], "fixing_code": ["import CoreUtils from '../CoreUtils'\nimport Dimensions from '../dimensions/Dimensions'\nimport Graphics from '../Graphics'\nimport Series from '../Series'\nimport Utils from '../../utils/Utils'\nimport Helpers from './Helpers'\n\n/**\n * ApexCharts Legend Class to draw legend.\n *\n * @module Legend\n **/\n\nclass Legend {\n  constructor(ctx, opts) {\n    this.ctx = ctx\n    this.w = ctx.w\n\n    this.onLegendClick = this.onLegendClick.bind(this)\n    this.onLegendHovered = this.onLegendHovered.bind(this)\n\n    this.isBarsDistributed =\n      this.w.config.chart.type === 'bar' &&\n      this.w.config.plotOptions.bar.distributed &&\n      this.w.config.series.length === 1\n\n    this.legendHelpers = new Helpers(this)\n  }\n\n  init() {\n    const w = this.w\n\n    const gl = w.globals\n    const cnf = w.config\n\n    const showLegendAlways =\n      (cnf.legend.showForSingleSeries && gl.series.length === 1) ||\n      this.isBarsDistributed ||\n      gl.series.length > 1\n\n    if ((showLegendAlways || !gl.axisCharts) && cnf.legend.show) {\n      while (gl.dom.elLegendWrap.firstChild) {\n        gl.dom.elLegendWrap.removeChild(gl.dom.elLegendWrap.firstChild)\n      }\n\n      this.drawLegends()\n      if (!Utils.isIE11()) {\n        this.legendHelpers.appendToForeignObject()\n      } else {\n        // IE11 doesn't supports foreignObject, hence append it to <head>\n        document\n          .getElementsByTagName('head')[0]\n          .appendChild(this.legendHelpers.getLegendStyles())\n      }\n\n      if (cnf.legend.position === 'bottom' || cnf.legend.position === 'top') {\n        this.legendAlignHorizontal()\n      } else if (\n        cnf.legend.position === 'right' ||\n        cnf.legend.position === 'left'\n      ) {\n        this.legendAlignVertical()\n      }\n    }\n  }\n\n  drawLegends() {\n    let self = this\n    let w = this.w\n\n    let fontFamily = w.config.legend.fontFamily\n\n    let legendNames = w.globals.seriesNames\n    let fillcolor = w.globals.colors.slice()\n\n    if (w.config.chart.type === 'heatmap') {\n      const ranges = w.config.plotOptions.heatmap.colorScale.ranges\n      legendNames = ranges.map((colorScale) => {\n        return colorScale.name\n          ? colorScale.name\n          : colorScale.from + ' - ' + colorScale.to\n      })\n      fillcolor = ranges.map((color) => color.color)\n    } else if (this.isBarsDistributed) {\n      legendNames = w.globals.labels.slice()\n    }\n    let legendFormatter = w.globals.legendFormatter\n\n    let isLegendInversed = w.config.legend.inverseOrder\n\n    for (\n      let i = isLegendInversed ? legendNames.length - 1 : 0;\n      isLegendInversed ? i >= 0 : i <= legendNames.length - 1;\n      isLegendInversed ? i-- : i++\n    ) {\n      let text = legendFormatter(legendNames[i], { seriesIndex: i, w })\n\n      let collapsedSeries = false\n      let ancillaryCollapsedSeries = false\n      if (w.globals.collapsedSeries.length > 0) {\n        for (let c = 0; c < w.globals.collapsedSeries.length; c++) {\n          if (w.globals.collapsedSeries[c].index === i) {\n            collapsedSeries = true\n          }\n        }\n      }\n\n      if (w.globals.ancillaryCollapsedSeriesIndices.length > 0) {\n        for (\n          let c = 0;\n          c < w.globals.ancillaryCollapsedSeriesIndices.length;\n          c++\n        ) {\n          if (w.globals.ancillaryCollapsedSeriesIndices[c] === i) {\n            ancillaryCollapsedSeries = true\n          }\n        }\n      }\n\n      let elMarker = document.createElement('span')\n      elMarker.classList.add('apexcharts-legend-marker')\n\n      let mOffsetX = w.config.legend.markers.offsetX\n      let mOffsetY = w.config.legend.markers.offsetY\n      let mHeight = w.config.legend.markers.height\n      let mWidth = w.config.legend.markers.width\n      let mBorderWidth = w.config.legend.markers.strokeWidth\n      let mBorderColor = w.config.legend.markers.strokeColor\n      let mBorderRadius = w.config.legend.markers.radius\n\n      let mStyle = elMarker.style\n\n      mStyle.background = fillcolor[i]\n      mStyle.color = fillcolor[i]\n      mStyle.setProperty('background', fillcolor[i], 'important')\n\n      // override fill color with custom legend.markers.fillColors\n      if (\n        w.config.legend.markers.fillColors &&\n        w.config.legend.markers.fillColors[i]\n      ) {\n        mStyle.background = w.config.legend.markers.fillColors[i]\n      }\n\n      // override with data color\n      if (w.globals.seriesColors[i] !== undefined) {\n        mStyle.background = w.globals.seriesColors[i]\n        mStyle.color = w.globals.seriesColors[i]\n      }\n\n      mStyle.height = Array.isArray(mHeight)\n        ? parseFloat(mHeight[i]) + 'px'\n        : parseFloat(mHeight) + 'px'\n      mStyle.width = Array.isArray(mWidth)\n        ? parseFloat(mWidth[i]) + 'px'\n        : parseFloat(mWidth) + 'px'\n      mStyle.left = Array.isArray(mOffsetX) ? mOffsetX[i] : mOffsetX\n      mStyle.top = Array.isArray(mOffsetY) ? mOffsetY[i] : mOffsetY\n      mStyle.borderWidth = Array.isArray(mBorderWidth)\n        ? mBorderWidth[i]\n        : mBorderWidth\n      mStyle.borderColor = Array.isArray(mBorderColor)\n        ? mBorderColor[i]\n        : mBorderColor\n      mStyle.borderRadius = Array.isArray(mBorderRadius)\n        ? parseFloat(mBorderRadius[i]) + 'px'\n        : parseFloat(mBorderRadius) + 'px'\n\n      if (w.config.legend.markers.customHTML) {\n        if (Array.isArray(w.config.legend.markers.customHTML)) {\n          if (w.config.legend.markers.customHTML[i]) {\n            elMarker.innerHTML = w.config.legend.markers.customHTML[i]()\n          }\n        } else {\n          elMarker.innerHTML = w.config.legend.markers.customHTML()\n        }\n      }\n\n      Graphics.setAttrs(elMarker, {\n        rel: i + 1,\n        'data:collapsed': collapsedSeries || ancillaryCollapsedSeries\n      })\n\n      if (collapsedSeries || ancillaryCollapsedSeries) {\n        elMarker.classList.add('apexcharts-inactive-legend')\n      }\n\n      let elLegend = document.createElement('div')\n\n      let elLegendText = document.createElement('span')\n      elLegendText.classList.add('apexcharts-legend-text')\n      elLegendText.innerHTML = Array.isArray(text) ? Utils.sanitizeDom(text.join(' ')) : Utils.sanitizeDom(text)\n\n      let textColor = w.config.legend.labels.useSeriesColors\n        ? w.globals.colors[i]\n        : w.config.legend.labels.colors\n\n      if (!textColor) {\n        textColor = w.config.chart.foreColor\n      }\n\n      elLegendText.style.color = textColor\n\n      elLegendText.style.fontSize = parseFloat(w.config.legend.fontSize) + 'px'\n      elLegendText.style.fontWeight = w.config.legend.fontWeight\n      elLegendText.style.fontFamily = fontFamily || w.config.chart.fontFamily\n\n      Graphics.setAttrs(elLegendText, {\n        rel: i + 1,\n        i,\n        'data:default-text': encodeURIComponent(text),\n        'data:collapsed': collapsedSeries || ancillaryCollapsedSeries\n      })\n\n      elLegend.appendChild(elMarker)\n      elLegend.appendChild(elLegendText)\n\n      const coreUtils = new CoreUtils(this.ctx)\n      if (!w.config.legend.showForZeroSeries) {\n        const total = coreUtils.getSeriesTotalByIndex(i)\n\n        if (\n          total === 0 &&\n          coreUtils.seriesHaveSameValues(i) &&\n          !coreUtils.isSeriesNull(i) &&\n          w.globals.collapsedSeriesIndices.indexOf(i) === -1 &&\n          w.globals.ancillaryCollapsedSeriesIndices.indexOf(i) === -1\n        ) {\n          elLegend.classList.add('apexcharts-hidden-zero-series')\n        }\n      }\n\n      if (!w.config.legend.showForNullSeries) {\n        if (\n          coreUtils.isSeriesNull(i) &&\n          w.globals.collapsedSeriesIndices.indexOf(i) === -1 &&\n          w.globals.ancillaryCollapsedSeriesIndices.indexOf(i) === -1\n        ) {\n          elLegend.classList.add('apexcharts-hidden-null-series')\n        }\n      }\n\n      w.globals.dom.elLegendWrap.appendChild(elLegend)\n      w.globals.dom.elLegendWrap.classList.add(\n        `apexcharts-align-${w.config.legend.horizontalAlign}`\n      )\n      w.globals.dom.elLegendWrap.classList.add(\n        'position-' + w.config.legend.position\n      )\n\n      elLegend.classList.add('apexcharts-legend-series')\n      elLegend.style.margin = `${w.config.legend.itemMargin.vertical}px ${w.config.legend.itemMargin.horizontal}px`\n      w.globals.dom.elLegendWrap.style.width = w.config.legend.width\n        ? w.config.legend.width + 'px'\n        : ''\n      w.globals.dom.elLegendWrap.style.height = w.config.legend.height\n        ? w.config.legend.height + 'px'\n        : ''\n\n      Graphics.setAttrs(elLegend, {\n        rel: i + 1,\n        seriesName: Utils.escapeString(legendNames[i]),\n        'data:collapsed': collapsedSeries || ancillaryCollapsedSeries\n      })\n\n      if (collapsedSeries || ancillaryCollapsedSeries) {\n        elLegend.classList.add('apexcharts-inactive-legend')\n      }\n\n      if (!w.config.legend.onItemClick.toggleDataSeries) {\n        elLegend.classList.add('apexcharts-no-click')\n      }\n    }\n\n    w.globals.dom.elWrap.addEventListener('click', self.onLegendClick, true)\n\n    if (w.config.legend.onItemHover.highlightDataSeries) {\n      w.globals.dom.elWrap.addEventListener(\n        'mousemove',\n        self.onLegendHovered,\n        true\n      )\n      w.globals.dom.elWrap.addEventListener(\n        'mouseout',\n        self.onLegendHovered,\n        true\n      )\n    }\n  }\n\n  setLegendWrapXY(offsetX, offsetY) {\n    let w = this.w\n\n    let elLegendWrap = w.globals.dom.baseEl.querySelector('.apexcharts-legend')\n\n    const legendRect = elLegendWrap.getBoundingClientRect()\n\n    let x = 0\n    let y = 0\n\n    if (w.config.legend.position === 'bottom') {\n      y = y + (w.globals.svgHeight - legendRect.height / 2)\n    } else if (w.config.legend.position === 'top') {\n      const dim = new Dimensions(this.ctx)\n      const titleH = dim.dimHelpers.getTitleSubtitleCoords('title').height\n      const subtitleH = dim.dimHelpers.getTitleSubtitleCoords('subtitle').height\n\n      y =\n        y +\n        (titleH > 0 ? titleH - 10 : 0) +\n        (subtitleH > 0 ? subtitleH - 10 : 0)\n    }\n\n    elLegendWrap.style.position = 'absolute'\n\n    x = x + offsetX + w.config.legend.offsetX\n    y = y + offsetY + w.config.legend.offsetY\n\n    elLegendWrap.style.left = x + 'px'\n    elLegendWrap.style.top = y + 'px'\n\n    if (w.config.legend.position === 'bottom') {\n      elLegendWrap.style.top = 'auto'\n      elLegendWrap.style.bottom = 5 - w.config.legend.offsetY + 'px'\n    } else if (w.config.legend.position === 'right') {\n      elLegendWrap.style.left = 'auto'\n      elLegendWrap.style.right = 25 + w.config.legend.offsetX + 'px'\n    }\n\n    const fixedHeigthWidth = ['width', 'height']\n    fixedHeigthWidth.forEach((hw) => {\n      if (elLegendWrap.style[hw]) {\n        elLegendWrap.style[hw] = parseInt(w.config.legend[hw], 10) + 'px'\n      }\n    })\n  }\n\n  legendAlignHorizontal() {\n    let w = this.w\n\n    let elLegendWrap = w.globals.dom.baseEl.querySelector('.apexcharts-legend')\n\n    elLegendWrap.style.right = 0\n\n    let lRect = this.legendHelpers.getLegendBBox()\n\n    let dimensions = new Dimensions(this.ctx)\n    let titleRect = dimensions.dimHelpers.getTitleSubtitleCoords('title')\n    let subtitleRect = dimensions.dimHelpers.getTitleSubtitleCoords('subtitle')\n\n    let offsetX = 20\n    let offsetY = 0\n\n    // the whole legend box is set to bottom\n    if (w.config.legend.position === 'bottom') {\n      offsetY = -lRect.clwh / 1.8\n    } else if (w.config.legend.position === 'top') {\n      offsetY =\n        titleRect.height +\n        subtitleRect.height +\n        w.config.title.margin +\n        w.config.subtitle.margin -\n        10\n    }\n\n    this.setLegendWrapXY(offsetX, offsetY)\n  }\n\n  legendAlignVertical() {\n    let w = this.w\n\n    let lRect = this.legendHelpers.getLegendBBox()\n\n    let offsetY = 20\n    let offsetX = 0\n\n    if (w.config.legend.position === 'left') {\n      offsetX = 20\n    }\n\n    if (w.config.legend.position === 'right') {\n      offsetX = w.globals.svgWidth - lRect.clww - 10\n    }\n\n    this.setLegendWrapXY(offsetX, offsetY)\n  }\n\n  onLegendHovered(e) {\n    const w = this.w\n\n    const hoverOverLegend =\n      e.target.classList.contains('apexcharts-legend-text') ||\n      e.target.classList.contains('apexcharts-legend-marker')\n\n    if (w.config.chart.type !== 'heatmap' && !this.isBarsDistributed) {\n      if (\n        !e.target.classList.contains('apexcharts-inactive-legend') &&\n        hoverOverLegend\n      ) {\n        let series = new Series(this.ctx)\n        series.toggleSeriesOnHover(e, e.target)\n      }\n    } else {\n      // for heatmap handling\n      if (hoverOverLegend) {\n        let seriesCnt = parseInt(e.target.getAttribute('rel'), 10) - 1\n        this.ctx.events.fireEvent('legendHover', [this.ctx, seriesCnt, this.w])\n\n        let series = new Series(this.ctx)\n        series.highlightRangeInSeries(e, e.target)\n      }\n    }\n  }\n\n  onLegendClick(e) {\n    const w = this.w\n\n    if (\n      e.target.classList.contains('apexcharts-legend-text') ||\n      e.target.classList.contains('apexcharts-legend-marker')\n    ) {\n      let seriesCnt = parseInt(e.target.getAttribute('rel'), 10) - 1\n      let isHidden = e.target.getAttribute('data:collapsed') === 'true'\n\n      const legendClick = this.w.config.chart.events.legendClick\n      if (typeof legendClick === 'function') {\n        legendClick(this.ctx, seriesCnt, this.w)\n      }\n\n      this.ctx.events.fireEvent('legendClick', [this.ctx, seriesCnt, this.w])\n\n      const markerClick = this.w.config.legend.markers.onClick\n      if (\n        typeof markerClick === 'function' &&\n        e.target.classList.contains('apexcharts-legend-marker')\n      ) {\n        markerClick(this.ctx, seriesCnt, this.w)\n        this.ctx.events.fireEvent('legendMarkerClick', [\n          this.ctx,\n          seriesCnt,\n          this.w\n        ])\n      }\n\n      // for now - just prevent click on heatmap legend - and allow hover only\n      const clickAllowed =\n        w.config.chart.type !== 'treemap' &&\n        w.config.chart.type !== 'heatmap' &&\n        !this.isBarsDistributed\n\n      if (clickAllowed && w.config.legend.onItemClick.toggleDataSeries) {\n        this.legendHelpers.toggleDataSeries(seriesCnt, isHidden)\n      }\n    }\n  }\n}\n\nexport default Legend\n", "import Formatters from '../Formatters'\nimport DateTime from '../../utils/DateTime'\nimport Utils from './Utils'\nimport Utilities from '../../utils/Utils'\n\n/**\n * ApexCharts Tooltip.Labels Class to draw texts on the tooltip.\n *\n * @module Tooltip.Labels\n **/\n\nexport default class Labels {\n  constructor(tooltipContext) {\n    this.w = tooltipContext.w\n    this.ctx = tooltipContext.ctx\n    this.ttCtx = tooltipContext\n    this.tooltipUtil = new Utils(tooltipContext)\n  }\n\n  drawSeriesTexts({ shared = true, ttItems, i = 0, j = null, y1, y2, e }) {\n    let w = this.w\n\n    if (w.config.tooltip.custom !== undefined) {\n      this.handleCustomTooltip({ i, j, y1, y2, w })\n    } else {\n      this.toggleActiveInactiveSeries(shared)\n    }\n\n    let values = this.getValuesToPrint({\n      i,\n      j\n    })\n\n    this.printLabels({\n      i,\n      j,\n      values,\n      ttItems,\n      shared,\n      e\n    })\n\n    // Re-calculate tooltip dimensions now that we have drawn the text\n    const tooltipEl = this.ttCtx.getElTooltip()\n\n    this.ttCtx.tooltipRect.ttWidth = tooltipEl.getBoundingClientRect().width\n    this.ttCtx.tooltipRect.ttHeight = tooltipEl.getBoundingClientRect().height\n  }\n\n  printLabels({ i, j, values, ttItems, shared, e }) {\n    const w = this.w\n    let val\n    const { xVal, zVal, xAxisTTVal } = values\n\n    let seriesName = ''\n\n    let pColor = w.globals.colors[i]\n    if (j !== null && w.config.plotOptions.bar.distributed) {\n      pColor = w.globals.colors[j]\n    }\n\n    for (\n      let t = 0, inverset = w.globals.series.length - 1;\n      t < w.globals.series.length;\n      t++, inverset--\n    ) {\n      let f = this.getFormatters(i)\n      seriesName = this.getSeriesName({\n        fn: f.yLbTitleFormatter,\n        index: i,\n        seriesIndex: i,\n        j\n      })\n\n      if (w.config.chart.type === 'treemap') {\n        seriesName = f.yLbTitleFormatter(String(w.config.series[i].data[j].x), {\n          series: w.globals.series,\n          seriesIndex: i,\n          dataPointIndex: j,\n          w\n        })\n      }\n\n      const tIndex = w.config.tooltip.inverseOrder ? inverset : t\n\n      if (w.globals.axisCharts) {\n        const generalFormatter = (index) => {\n          return f.yLbFormatter(w.globals.series[index][j], {\n            series: w.globals.series,\n            seriesIndex: index,\n            dataPointIndex: j,\n            w\n          })\n        }\n        if (shared) {\n          f = this.getFormatters(tIndex)\n\n          seriesName = this.getSeriesName({\n            fn: f.yLbTitleFormatter,\n            index: tIndex,\n            seriesIndex: i,\n            j\n          })\n          pColor = w.globals.colors[tIndex]\n\n          val = generalFormatter(tIndex)\n        } else {\n          if (e && e.target && e.target.getAttribute('fill')) {\n            pColor = e.target.getAttribute('fill')\n          }\n          val = generalFormatter(i)\n        }\n      }\n\n      // for pie / donuts\n      if (j === null) {\n        val = f.yLbFormatter(w.globals.series[i], {\n          ...w,\n          seriesIndex: i,\n          dataPointIndex: i\n        })\n      }\n\n      this.DOMHandling({\n        i,\n        t: tIndex,\n        j,\n        ttItems,\n        values: {\n          val,\n          xVal,\n          xAxisTTVal,\n          zVal\n        },\n        seriesName,\n        shared,\n        pColor\n      })\n    }\n  }\n\n  getFormatters(i) {\n    const w = this.w\n\n    let yLbFormatter = w.globals.yLabelFormatters[i]\n    let yLbTitleFormatter\n\n    if (w.globals.ttVal !== undefined) {\n      if (Array.isArray(w.globals.ttVal)) {\n        yLbFormatter = w.globals.ttVal[i] && w.globals.ttVal[i].formatter\n        yLbTitleFormatter =\n          w.globals.ttVal[i] &&\n          w.globals.ttVal[i].title &&\n          w.globals.ttVal[i].title.formatter\n      } else {\n        yLbFormatter = w.globals.ttVal.formatter\n        if (typeof w.globals.ttVal.title.formatter === 'function') {\n          yLbTitleFormatter = w.globals.ttVal.title.formatter\n        }\n      }\n    } else {\n      yLbTitleFormatter = w.config.tooltip.y.title.formatter\n    }\n\n    if (typeof yLbFormatter !== 'function') {\n      if (w.globals.yLabelFormatters[0]) {\n        yLbFormatter = w.globals.yLabelFormatters[0]\n      } else {\n        yLbFormatter = function (label) {\n          return label\n        }\n      }\n    }\n\n    if (typeof yLbTitleFormatter !== 'function') {\n      yLbTitleFormatter = function (label) {\n        return label\n      }\n    }\n\n    return {\n      yLbFormatter,\n      yLbTitleFormatter\n    }\n  }\n\n  getSeriesName({ fn, index, seriesIndex, j }) {\n    const w = this.w\n    return fn(String(w.globals.seriesNames[index]), {\n      series: w.globals.series,\n      seriesIndex,\n      dataPointIndex: j,\n      w\n    })\n  }\n\n  DOMHandling({ i, t, j, ttItems, values, seriesName, shared, pColor }) {\n    const w = this.w\n    const ttCtx = this.ttCtx\n\n    Object.keys(values).forEach(key => {\n      if (typeof values[key] == 'string')\n        values[key] = Utilities.sanitizeDom(values[key])\n    })\n\n    const { val, xVal, xAxisTTVal, zVal } = values\n\n    let ttItemsChildren = null\n    ttItemsChildren = ttItems[t].children\n\n    if (w.config.tooltip.fillSeriesColor) {\n      //  elTooltip.style.backgroundColor = pColor\n      ttItems[t].style.backgroundColor = pColor\n      ttItemsChildren[0].style.display = 'none'\n    }\n\n    if (ttCtx.showTooltipTitle) {\n      if (ttCtx.tooltipTitle === null) {\n        // get it once if null, and store it in class property\n        ttCtx.tooltipTitle = w.globals.dom.baseEl.querySelector(\n          '.apexcharts-tooltip-title'\n        )\n      }\n      ttCtx.tooltipTitle.innerHTML = xVal\n    }\n\n    // if xaxis tooltip is constructed, we need to replace the innerHTML\n    if (ttCtx.blxaxisTooltip) {\n      ttCtx.xaxisTooltipText.innerHTML = xAxisTTVal !== '' ? xAxisTTVal : xVal\n    }\n\n    const ttYLabel = ttItems[t].querySelector('.apexcharts-tooltip-text-label')\n    if (ttYLabel) {\n      ttYLabel.innerHTML = seriesName ? Utilities.sanitizeDom(seriesName) : ''\n    }\n    const ttYVal = ttItems[t].querySelector('.apexcharts-tooltip-text-value')\n    if (ttYVal) {\n      ttYVal.innerHTML = typeof val !== 'undefined' ? val : ''\n    }\n\n    if (\n      ttItemsChildren[0] &&\n      ttItemsChildren[0].classList.contains('apexcharts-tooltip-marker')\n    ) {\n      if (\n        w.config.tooltip.marker.fillColors &&\n        Array.isArray(w.config.tooltip.marker.fillColors)\n      ) {\n        pColor = w.config.tooltip.marker.fillColors[t]\n      }\n\n      ttItemsChildren[0].style.backgroundColor = pColor\n    }\n\n    if (!w.config.tooltip.marker.show) {\n      ttItemsChildren[0].style.display = 'none'\n    }\n\n    if (zVal !== null) {\n      const ttZLabel = ttItems[t].querySelector(\n        '.apexcharts-tooltip-text-z-label'\n      )\n      ttZLabel.innerHTML = w.config.tooltip.z.title\n      const ttZVal = ttItems[t].querySelector(\n        '.apexcharts-tooltip-text-z-value'\n      )\n      ttZVal.innerHTML = typeof zVal !== 'undefined' ? zVal : ''\n    }\n\n    if (shared && ttItemsChildren[0]) {\n      // hide when no Val or series collapsed\n      if (\n        typeof val === 'undefined' ||\n        val === null ||\n        w.globals.collapsedSeriesIndices.indexOf(t) > -1\n      ) {\n        ttItemsChildren[0].parentNode.style.display = 'none'\n      } else {\n        ttItemsChildren[0].parentNode.style.display =\n          w.config.tooltip.items.display\n      }\n\n      // TODO: issue #1240 needs to be looked at again. commenting it because this also hides single series values with 0 in it (shared tooltip)\n\n      // if (w.globals.stackedSeriesTotals[j] === 0) {\n      //   // shared tooltip and all values are null, so we need to hide the x value too\n      //   let allYZeroForJ = false\n      //   for (let si = 1; si < w.globals.seriesYvalues.length; si++) {\n      //     if (\n      //       w.globals.seriesYvalues[si][j] ===\n      //       w.globals.seriesYvalues[si - 1][j]\n      //     ) {\n      //       allYZeroForJ = true\n      //     }\n      //   }\n\n      //   if (allYZeroForJ) {\n      //     ttCtx.tooltipTitle.style.display = 'none'\n      //   } else {\n      //     ttCtx.tooltipTitle.style.display = w.config.tooltip.items.display\n      //   }\n      // } else {\n      //   ttCtx.tooltipTitle.style.display = w.config.tooltip.items.display\n      // }\n    }\n  }\n\n  toggleActiveInactiveSeries(shared) {\n    const w = this.w\n    if (shared) {\n      // make all tooltips active\n      this.tooltipUtil.toggleAllTooltipSeriesGroups('enable')\n    } else {\n      // disable all tooltip text groups\n      this.tooltipUtil.toggleAllTooltipSeriesGroups('disable')\n\n      // enable the first tooltip text group\n      let firstTooltipSeriesGroup = w.globals.dom.baseEl.querySelector(\n        '.apexcharts-tooltip-series-group'\n      )\n\n      if (firstTooltipSeriesGroup) {\n        firstTooltipSeriesGroup.classList.add('apexcharts-active')\n        firstTooltipSeriesGroup.style.display = w.config.tooltip.items.display\n      }\n    }\n  }\n\n  getValuesToPrint({ i, j }) {\n    const w = this.w\n    const filteredSeriesX = this.ctx.series.filteredSeriesX()\n\n    let xVal = ''\n    let xAxisTTVal = ''\n    let zVal = null\n    let val = null\n\n    const customFormatterOpts = {\n      series: w.globals.series,\n      seriesIndex: i,\n      dataPointIndex: j,\n      w\n    }\n\n    let zFormatter = w.globals.ttZFormatter\n\n    if (j === null) {\n      val = w.globals.series[i]\n    } else {\n      if (w.globals.isXNumeric && w.config.chart.type !== 'treemap') {\n        xVal = filteredSeriesX[i][j]\n        if (filteredSeriesX[i].length === 0) {\n          // a series (possibly the first one) might be collapsed, so get the next active index\n          const firstActiveSeriesIndex = this.tooltipUtil.getFirstActiveXArray(\n            filteredSeriesX\n          )\n          xVal = filteredSeriesX[firstActiveSeriesIndex][j]\n        }\n      } else {\n        xVal =\n          typeof w.globals.labels[j] !== 'undefined' ? w.globals.labels[j] : ''\n      }\n    }\n\n    let bufferXVal = xVal\n\n    if (w.globals.isXNumeric && w.config.xaxis.type === 'datetime') {\n      let xFormat = new Formatters(this.ctx)\n      xVal = xFormat.xLabelFormat(\n        w.globals.ttKeyFormatter,\n        bufferXVal,\n        bufferXVal,\n        {\n          i: undefined,\n          dateFormatter: new DateTime(this.ctx).formatDate,\n          w: this.w\n        }\n      )\n    } else {\n      if (w.globals.isBarHorizontal) {\n        xVal = w.globals.yLabelFormatters[0](bufferXVal, customFormatterOpts)\n      } else {\n        xVal = w.globals.xLabelFormatter(bufferXVal, customFormatterOpts)\n      }\n    }\n\n    // override default x-axis formatter with tooltip formatter\n    if (w.config.tooltip.x.formatter !== undefined) {\n      xVal = w.globals.ttKeyFormatter(bufferXVal, customFormatterOpts)\n    }\n\n    if (w.globals.seriesZ.length > 0 && w.globals.seriesZ[i].length > 0) {\n      zVal = zFormatter(w.globals.seriesZ[i][j], w)\n    }\n\n    if (typeof w.config.xaxis.tooltip.formatter === 'function') {\n      xAxisTTVal = w.globals.xaxisTooltipFormatter(\n        bufferXVal,\n        customFormatterOpts\n      )\n    } else {\n      xAxisTTVal = xVal\n    }\n\n    return {\n      val: Array.isArray(val) ? val.join(' ') : val,\n      xVal: Array.isArray(xVal) ? xVal.join(' ') : xVal,\n      xAxisTTVal: Array.isArray(xAxisTTVal) ? xAxisTTVal.join(' ') : xAxisTTVal,\n      zVal\n    }\n  }\n\n  handleCustomTooltip({ i, j, y1, y2, w }) {\n    const tooltipEl = this.ttCtx.getElTooltip()\n    let fn = w.config.tooltip.custom\n\n    if (Array.isArray(fn) && fn[i]) {\n      fn = fn[i]\n    }\n\n    // override everything with a custom html tooltip and replace it\n    tooltipEl.innerHTML = fn({\n      ctx: this.ctx,\n      series: w.globals.series,\n      seriesIndex: i,\n      dataPointIndex: j,\n      y1,\n      y2,\n      w\n    })\n  }\n}\n", "/*\n ** Generic functions which are not dependent on ApexCharts\n */\n\nclass Utils {\n  static bind(fn, me) {\n    return function () {\n      return fn.apply(me, arguments)\n    }\n  }\n\n  static isObject(item) {\n    return (\n      item && typeof item === 'object' && !Array.isArray(item) && item != null\n    )\n  }\n\n  static listToArray(list) {\n    let i,\n      array = []\n    for (i = 0; i < list.length; i++) {\n      array[i] = list[i]\n    }\n    return array\n  }\n\n  // to extend defaults with user options\n  // credit: http://stackoverflow.com/questions/27936772/deep-object-merging-in-es6-es7#answer-34749873\n  static extend(target, source) {\n    if (typeof Object.assign !== 'function') {\n      ; (function () {\n        Object.assign = function (target) {\n          'use strict'\n          // We must check against these specific cases.\n          if (target === undefined || target === null) {\n            throw new TypeError('Cannot convert undefined or null to object')\n          }\n\n          let output = Object(target)\n          for (let index = 1; index < arguments.length; index++) {\n            let source = arguments[index]\n            if (source !== undefined && source !== null) {\n              for (let nextKey in source) {\n                if (source.hasOwnProperty(nextKey)) {\n                  output[nextKey] = source[nextKey]\n                }\n              }\n            }\n          }\n          return output\n        }\n      })()\n    }\n\n    let output = Object.assign({}, target)\n    if (this.isObject(target) && this.isObject(source)) {\n      Object.keys(source).forEach((key) => {\n        if (this.isObject(source[key])) {\n          if (!(key in target)) {\n            Object.assign(output, {\n              [key]: source[key]\n            })\n          } else {\n            output[key] = this.extend(target[key], source[key])\n          }\n        } else {\n          Object.assign(output, {\n            [key]: source[key]\n          })\n        }\n      })\n    }\n    return output\n  }\n\n  static extendArray(arrToExtend, resultArr) {\n    let extendedArr = []\n    arrToExtend.map((item) => {\n      extendedArr.push(Utils.extend(resultArr, item))\n    })\n    arrToExtend = extendedArr\n    return arrToExtend\n  }\n\n  // If month counter exceeds 12, it starts again from 1\n  static monthMod(month) {\n    return month % 12\n  }\n\n  static clone(source) {\n    if (Object.prototype.toString.call(source) === '[object Array]') {\n      let cloneResult = []\n      for (let i = 0; i < source.length; i++) {\n        cloneResult[i] = this.clone(source[i])\n      }\n      return cloneResult\n    } else if (Object.prototype.toString.call(source) === '[object Null]') {\n      // fixes an issue where null values were converted to {}\n      return null\n    } else if (Object.prototype.toString.call(source) === '[object Date]') {\n      return source\n    } else if (typeof source === 'object') {\n      let cloneResult = {}\n      for (let prop in source) {\n        if (source.hasOwnProperty(prop)) {\n          cloneResult[prop] = this.clone(source[prop])\n        }\n      }\n      return cloneResult\n    } else {\n      return source\n    }\n  }\n\n  static log10(x) {\n    return Math.log(x) / Math.LN10\n  }\n\n  static roundToBase10(x) {\n    return Math.pow(10, Math.floor(Math.log10(x)))\n  }\n\n  static roundToBase(x, base) {\n    return Math.pow(base, Math.floor(Math.log(x) / Math.log(base)))\n  }\n\n  static parseNumber(val) {\n    if (val === null) return val\n    return parseFloat(val)\n  }\n\n  static randomId() {\n    return (Math.random() + 1).toString(36).substring(4)\n  }\n\n  static noExponents(val) {\n    let data = String(val).split(/[eE]/)\n    if (data.length === 1) return data[0]\n\n    let z = '',\n      sign = val < 0 ? '-' : '',\n      str = data[0].replace('.', ''),\n      mag = Number(data[1]) + 1\n\n    if (mag < 0) {\n      z = sign + '0.'\n      while (mag++) z += '0'\n      return z + str.replace(/^-/, '')\n    }\n    mag -= str.length\n    while (mag--) z += '0'\n    return str + z\n  }\n\n  static getDimensions(el) {\n    const computedStyle = getComputedStyle(el, null)\n\n    let elementHeight = el.clientHeight\n    let elementWidth = el.clientWidth\n    elementHeight -=\n      parseFloat(computedStyle.paddingTop) +\n      parseFloat(computedStyle.paddingBottom)\n    elementWidth -=\n      parseFloat(computedStyle.paddingLeft) +\n      parseFloat(computedStyle.paddingRight)\n\n    return [elementWidth, elementHeight]\n  }\n\n  static getBoundingClientRect(element) {\n    const rect = element.getBoundingClientRect()\n    return {\n      top: rect.top,\n      right: rect.right,\n      bottom: rect.bottom,\n      left: rect.left,\n      width: element.clientWidth,\n      height: element.clientHeight,\n      x: rect.left,\n      y: rect.top\n    }\n  }\n\n  static getLargestStringFromArr(arr) {\n    return arr.reduce((a, b) => {\n      if (Array.isArray(b)) {\n        b = b.reduce((aa, bb) => (aa.length > bb.length ? aa : bb))\n      }\n      return a.length > b.length ? a : b\n    }, 0)\n  }\n\n  // http://stackoverflow.com/questions/5623838/rgb-to-hex-and-hex-to-rgb#answer-12342275\n  static hexToRgba(hex = '#999999', opacity = 0.6) {\n    if (hex.substring(0, 1) !== '#') {\n      hex = '#999999'\n    }\n\n    let h = hex.replace('#', '')\n    h = h.match(new RegExp('(.{' + h.length / 3 + '})', 'g'))\n\n    for (let i = 0; i < h.length; i++) {\n      h[i] = parseInt(h[i].length === 1 ? h[i] + h[i] : h[i], 16)\n    }\n\n    if (typeof opacity !== 'undefined') h.push(opacity)\n\n    return 'rgba(' + h.join(',') + ')'\n  }\n\n  static getOpacityFromRGBA(rgba) {\n    return parseFloat(rgba.replace(/^.*,(.+)\\)/, '$1'))\n  }\n\n  static rgb2hex(rgb) {\n    rgb = rgb.match(\n      /^rgba?[\\s+]?\\([\\s+]?(\\d+)[\\s+]?,[\\s+]?(\\d+)[\\s+]?,[\\s+]?(\\d+)[\\s+]?/i\n    )\n    return rgb && rgb.length === 4\n      ? '#' +\n      ('0' + parseInt(rgb[1], 10).toString(16)).slice(-2) +\n      ('0' + parseInt(rgb[2], 10).toString(16)).slice(-2) +\n      ('0' + parseInt(rgb[3], 10).toString(16)).slice(-2)\n      : ''\n  }\n\n  shadeRGBColor(percent, color) {\n    let f = color.split(','),\n      t = percent < 0 ? 0 : 255,\n      p = percent < 0 ? percent * -1 : percent,\n      R = parseInt(f[0].slice(4), 10),\n      G = parseInt(f[1], 10),\n      B = parseInt(f[2], 10)\n    return (\n      'rgb(' +\n      (Math.round((t - R) * p) + R) +\n      ',' +\n      (Math.round((t - G) * p) + G) +\n      ',' +\n      (Math.round((t - B) * p) + B) +\n      ')'\n    )\n  }\n\n  shadeHexColor(percent, color) {\n    let f = parseInt(color.slice(1), 16),\n      t = percent < 0 ? 0 : 255,\n      p = percent < 0 ? percent * -1 : percent,\n      R = f >> 16,\n      G = (f >> 8) & 0x00ff,\n      B = f & 0x0000ff\n    return (\n      '#' +\n      (\n        0x1000000 +\n        (Math.round((t - R) * p) + R) * 0x10000 +\n        (Math.round((t - G) * p) + G) * 0x100 +\n        (Math.round((t - B) * p) + B)\n      )\n        .toString(16)\n        .slice(1)\n    )\n  }\n\n  // beautiful color shading blending code\n  // http://stackoverflow.com/questions/5560248/programmatically-lighten-or-darken-a-hex-color-or-rgb-and-blend-colors\n  shadeColor(p, color) {\n    if (Utils.isColorHex(color)) {\n      return this.shadeHexColor(p, color)\n    } else {\n      return this.shadeRGBColor(p, color)\n    }\n  }\n\n  static isColorHex(color) {\n    return /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)|(^#[0-9A-F]{8}$)/i.test(color)\n  }\n\n  static polarToCartesian(centerX, centerY, radius, angleInDegrees) {\n    let angleInRadians = ((angleInDegrees - 90) * Math.PI) / 180.0\n\n    return {\n      x: centerX + radius * Math.cos(angleInRadians),\n      y: centerY + radius * Math.sin(angleInRadians)\n    }\n  }\n\n  static escapeString(str, escapeWith = 'x') {\n    let newStr = str.toString().slice()\n    newStr = newStr.replace(\n      /[` ~!@#$%^&*()_|+\\-=?;:'\",.<>{}[\\]\\\\/]/gi,\n      escapeWith\n    )\n    return newStr\n  }\n\n  static negToZero(val) {\n    return val < 0 ? 0 : val\n  }\n\n  static moveIndexInArray(arr, old_index, new_index) {\n    if (new_index >= arr.length) {\n      let k = new_index - arr.length + 1\n      while (k--) {\n        arr.push(undefined)\n      }\n    }\n    arr.splice(new_index, 0, arr.splice(old_index, 1)[0])\n    return arr\n  }\n\n  static extractNumber(s) {\n    return parseFloat(s.replace(/[^\\d.]*/g, ''))\n  }\n\n  static findAncestor(el, cls) {\n    while ((el = el.parentElement) && !el.classList.contains(cls));\n    return el\n  }\n\n  static setELstyles(el, styles) {\n    for (let key in styles) {\n      if (styles.hasOwnProperty(key)) {\n        el.style.key = styles[key]\n      }\n    }\n  }\n\n  static isNumber(value) {\n    return (\n      !isNaN(value) &&\n      parseFloat(Number(value)) === value &&\n      !isNaN(parseInt(value, 10))\n    )\n  }\n\n  static isFloat(n) {\n    return Number(n) === n && n % 1 !== 0\n  }\n\n  static isSafari() {\n    return /^((?!chrome|android).)*safari/i.test(navigator.userAgent)\n  }\n\n  static isFirefox() {\n    return navigator.userAgent.toLowerCase().indexOf('firefox') > -1\n  }\n\n  static isIE11() {\n    if (\n      window.navigator.userAgent.indexOf('MSIE') !== -1 ||\n      window.navigator.appVersion.indexOf('Trident/') > -1\n    ) {\n      return true\n    }\n  }\n\n  static isIE() {\n    let ua = window.navigator.userAgent\n\n    let msie = ua.indexOf('MSIE ')\n    if (msie > 0) {\n      // IE 10 or older => return version number\n      return parseInt(ua.substring(msie + 5, ua.indexOf('.', msie)), 10)\n    }\n\n    let trident = ua.indexOf('Trident/')\n    if (trident > 0) {\n      // IE 11 => return version number\n      let rv = ua.indexOf('rv:')\n      return parseInt(ua.substring(rv + 3, ua.indexOf('.', rv)), 10)\n    }\n\n    let edge = ua.indexOf('Edge/')\n    if (edge > 0) {\n      // Edge (IE 12+) => return version number\n      return parseInt(ua.substring(edge + 5, ua.indexOf('.', edge)), 10)\n    }\n\n    // other browser\n    return false\n  }\n\n  /**\n   * Sanitize dangerous characters in the string to prevent Cross-Site Scripting\n   * @param {string}\n   * string - String to sanitize\n   */\n  static sanitizeDom(string) {\n    return string\n      .replace(/\\&/g, '&amp;')\n      .replace(/\\</g, '&lt;')\n      .replace(/\\>/g, '&gt;')\n      .replace(/\\\"/g, '&quot;')\n  }\n}\n\nexport default Utils\n"], "filenames": ["src/modules/legend/Legend.js", "src/modules/tooltip/Labels.js", "src/utils/Utils.js"], "buggy_code_start_loc": [192, 3, 7], "buggy_code_end_loc": [193, 229, 382], "fixing_code_start_loc": [192, 4, 7], "fixing_code_end_loc": [193, 235, 396], "type": "CWE-79", "message": "The package apexcharts before 3.24.0 are vulnerable to Cross-site Scripting (XSS) via lack of sanitization of graph legend fields.", "other": {"cve": {"id": "CVE-2021-23327", "sourceIdentifier": "report@snyk.io", "published": "2021-02-09T08:15:11.167", "lastModified": "2021-02-13T02:20:19.273", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The package apexcharts before 3.24.0 are vulnerable to Cross-site Scripting (XSS) via lack of sanitization of graph legend fields."}, {"lang": "es", "value": "Los paquetes apexcharts versiones anteriores a 3.24.0, son vulnerables a ataques de tipo Cross-site Scripting (XSS) debido a una falta de saneamiento de los campos de leyenda de gr\u00e1ficos"}], "metrics": {"cvssMetricV31": [{"source": "report@snyk.io", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:L/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 6.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:fusioncharts:apexcharts:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "3.24.0", "matchCriteriaId": "4E188DD9-6E42-44B9-B4AE-0F957ADAC3C3"}]}]}], "references": [{"url": "https://github.com/apexcharts/apexcharts.js/commit/68f3f34d125719b4767614fe0a595cc65bde1d19", "source": "report@snyk.io", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/apexcharts/apexcharts.js/pull/2158", "source": "report@snyk.io", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://snyk.io/vuln/SNYK-JAVA-ORGWEBJARSNPM-1070616", "source": "report@snyk.io", "tags": ["Third Party Advisory"]}, {"url": "https://snyk.io/vuln/SNYK-JS-APEXCHARTS-1062708", "source": "report@snyk.io", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/apexcharts/apexcharts.js/commit/68f3f34d125719b4767614fe0a595cc65bde1d19"}}