{"buggy_code": ["package schema\n\nimport (\n\t\"strings\"\n\n\t\"github.com/answerdev/answer/internal/base/reason\"\n\t\"github.com/answerdev/answer/internal/base/validator\"\n\t\"github.com/answerdev/answer/pkg/converter\"\n\t\"github.com/segmentfault/pacman/errors\"\n)\n\n// SearchTagLikeReq get tag list all request\ntype SearchTagLikeReq struct {\n\t// tag\n\tTag     string `validate:\"omitempty\" form:\"tag\"`\n\tIsAdmin bool   `json:\"-\"`\n}\n\ntype SearchTagsBySlugName struct {\n\tTags    string   `json:\"tags\" form:\"tags\"`\n\tTagList []string `json:\"-\"`\n\tIsAdmin bool     `json:\"-\"`\n}\n\n// GetTagInfoReq get tag info request\ntype GetTagInfoReq struct {\n\t// tag id\n\tID string `validate:\"omitempty\" form:\"id\"`\n\t// tag slug name\n\tName string `validate:\"omitempty,gt=0,lte=35\" form:\"name\"`\n\t// user id\n\tUserID string `json:\"-\"`\n\t// whether user can edit it\n\tCanEdit bool `json:\"-\"`\n\t// whether user can delete it\n\tCanDelete bool `json:\"-\"`\n}\n\ntype GetTamplateTagInfoReq struct {\n\t// tag id\n\tID string `validate:\"omitempty\" form:\"id\"`\n\t// tag slug name\n\tName string `validate:\"omitempty\" form:\"name\"`\n\t// user id\n\tUserID   string `json:\"-\"`\n\tPage     int    `validate:\"omitempty,min=1\" form:\"page\"`\n\tPageSize int    `validate:\"omitempty,min=1\" form:\"page_size\"`\n}\n\nfunc (r *GetTagInfoReq) Check() (errFields []*validator.FormErrorField, err error) {\n\tif len(r.ID) == 0 && len(r.Name) == 0 {\n\t\treturn nil, errors.BadRequest(reason.RequestFormatError)\n\t}\n\tr.Name = strings.ToLower(r.Name)\n\treturn nil, nil\n}\n\n// GetTagResp get tag response\ntype GetTagResp struct {\n\t// tag id\n\tTagID string `json:\"tag_id\"`\n\t// created time\n\tCreatedAt int64 `json:\"created_at\"`\n\t// updated time\n\tUpdatedAt int64 `json:\"updated_at\"`\n\t// slug name\n\tSlugName string `json:\"slug_name\"`\n\t// display name\n\tDisplayName string `json:\"display_name\"`\n\t// excerpt\n\tExcerpt string `json:\"excerpt\"`\n\t// original text\n\tOriginalText string `json:\"original_text\"`\n\t// parsed text\n\tParsedText string `json:\"parsed_text\"`\n\t// description text\n\tDescription string `json:\"description\"`\n\t// follower amount\n\tFollowCount int `json:\"follow_count\"`\n\t// question amount\n\tQuestionCount int `json:\"question_count\"`\n\t// is follower\n\tIsFollower bool `json:\"is_follower\"`\n\t// MemberActions\n\tMemberActions []*PermissionMemberAction `json:\"member_actions\"`\n\t// if main tag slug name is not empty, this tag is synonymous with the main tag\n\tMainTagSlugName string `json:\"main_tag_slug_name\"`\n\tRecommend       bool   `json:\"recommend\"`\n\tReserved        bool   `json:\"reserved\"`\n}\n\nfunc (tr *GetTagResp) GetExcerpt() {\n\texcerpt := strings.TrimSpace(tr.OriginalText)\n\tidx := strings.Index(excerpt, \"\\n\")\n\tif idx >= 0 {\n\t\texcerpt = excerpt[0:idx]\n\t}\n\ttr.Excerpt = excerpt\n}\n\n// GetTagPageResp get tag response\ntype GetTagPageResp struct {\n\t// tag_id\n\tTagID string `json:\"tag_id\"`\n\t// slug_name\n\tSlugName string `json:\"slug_name\"`\n\t// display_name\n\tDisplayName string `json:\"display_name\"`\n\t// excerpt\n\tExcerpt string `json:\"excerpt\"`\n\t// original text\n\tOriginalText string `json:\"original_text\"`\n\t// parsed_text\n\tParsedText string `json:\"parsed_text\"`\n\t// follower amount\n\tFollowCount int `json:\"follow_count\"`\n\t// question amount\n\tQuestionCount int `json:\"question_count\"`\n\t// is follower\n\tIsFollower bool `json:\"is_follower\"`\n\t// created time\n\tCreatedAt int64 `json:\"created_at\"`\n\t// updated time\n\tUpdatedAt int64 `json:\"updated_at\"`\n\tRecommend bool  `json:\"recommend\"`\n\tReserved  bool  `json:\"reserved\"`\n}\n\nfunc (tr *GetTagPageResp) GetExcerpt() {\n\texcerpt := strings.TrimSpace(tr.OriginalText)\n\tidx := strings.Index(excerpt, \"\\n\")\n\tif idx >= 0 {\n\t\texcerpt = excerpt[0:idx]\n\t}\n\ttr.Excerpt = excerpt\n}\n\ntype TagChange struct {\n\tObjectID string     `json:\"object_id\"` // object_id\n\tTags     []*TagItem `json:\"tags\"`      // tags name\n\t// user id\n\tUserID string `json:\"-\"`\n}\n\ntype TagItem struct {\n\t// slug_name\n\tSlugName string `validate:\"omitempty,gt=0,lte=35\" json:\"slug_name\"`\n\t// display_name\n\tDisplayName string `validate:\"omitempty,gt=0,lte=35\" json:\"display_name\"`\n\t// original text\n\tOriginalText string `validate:\"omitempty\" json:\"original_text\"`\n\t// parsed text\n\tParsedText string `json:\"-\"`\n}\n\n// RemoveTagReq delete tag request\ntype RemoveTagReq struct {\n\t// tag_id\n\tTagID string `validate:\"required\" json:\"tag_id\"`\n\t// user id\n\tUserID string `json:\"-\"`\n}\n\n// UpdateTagReq update tag request\ntype UpdateTagReq struct {\n\t// tag_id\n\tTagID string `validate:\"required\" json:\"tag_id\"`\n\t// slug_name\n\tSlugName string `validate:\"omitempty,gt=0,lte=35\" json:\"slug_name\"`\n\t// display_name\n\tDisplayName string `validate:\"omitempty,gt=0,lte=35\" json:\"display_name\"`\n\t// original text\n\tOriginalText string `validate:\"omitempty\" json:\"original_text\"`\n\t// parsed text\n\tParsedText string `json:\"-\"`\n\t// edit summary\n\tEditSummary string `validate:\"omitempty\" json:\"edit_summary\"`\n\t// user id\n\tUserID       string `json:\"-\"`\n\tNoNeedReview bool   `json:\"-\"`\n}\n\nfunc (r *UpdateTagReq) Check() (errFields []*validator.FormErrorField, err error) {\n\tif len(r.EditSummary) == 0 {\n\t\tr.EditSummary = \"tag.edit.summary\"\n\t}\n\tr.ParsedText = converter.Markdown2HTML(r.OriginalText)\n\treturn nil, nil\n}\n\n// UpdateTagResp update tag response\ntype UpdateTagResp struct {\n\tWaitForReview bool `json:\"wait_for_review\"`\n}\n\n// GetTagWithPageReq get tag list page request\ntype GetTagWithPageReq struct {\n\t// page\n\tPage int `validate:\"omitempty,min=1\" form:\"page\"`\n\t// page size\n\tPageSize int `validate:\"omitempty,min=1\" form:\"page_size\"`\n\t// slug_name\n\tSlugName string `validate:\"omitempty,gt=0,lte=35\" form:\"slug_name\"`\n\t// display_name\n\tDisplayName string `validate:\"omitempty,gt=0,lte=35\" form:\"display_name\"`\n\t// query condition\n\tQueryCond string `validate:\"omitempty,oneof=popular name newest\" form:\"query_cond\"`\n\t// user id\n\tUserID string `json:\"-\"`\n}\n\n// GetTagSynonymsReq get tag synonyms request\ntype GetTagSynonymsReq struct {\n\t// tag_id\n\tTagID string `validate:\"required\" form:\"tag_id\"`\n\t// user id\n\tUserID string `json:\"-\"`\n\t// whether user can edit it\n\tCanEdit bool `json:\"-\"`\n}\n\n// GetTagSynonymsResp get tag synonyms response\ntype GetTagSynonymsResp struct {\n\t// synonyms\n\tSynonyms []*TagSynonym `json:\"synonyms\"`\n\t// MemberActions\n\tMemberActions []*PermissionMemberAction `json:\"member_actions\"`\n}\n\ntype TagSynonym struct {\n\t// tag id\n\tTagID string `json:\"tag_id\"`\n\t// slug name\n\tSlugName string `json:\"slug_name\"`\n\t// display name\n\tDisplayName string `json:\"display_name\"`\n\t// if main tag slug name is not empty, this tag is synonymous with the main tag\n\tMainTagSlugName string `json:\"main_tag_slug_name\"`\n}\n\n// UpdateTagSynonymReq update tag request\ntype UpdateTagSynonymReq struct {\n\t// tag_id\n\tTagID string `validate:\"required\" json:\"tag_id\"`\n\t// synonym tag list\n\tSynonymTagList []*TagItem `validate:\"required,dive\" json:\"synonym_tag_list\"`\n\t// user id\n\tUserID string `json:\"-\"`\n}\n\nfunc (req *UpdateTagSynonymReq) Format() {\n\tfor _, item := range req.SynonymTagList {\n\t\titem.SlugName = strings.ToLower(item.SlugName)\n\t}\n}\n\n// GetFollowingTagsResp get following tags response\ntype GetFollowingTagsResp struct {\n\t// tag id\n\tTagID string `json:\"tag_id\"`\n\t// slug name\n\tSlugName string `json:\"slug_name\"`\n\t// display name\n\tDisplayName string `json:\"display_name\"`\n\t// if main tag slug name is not empty, this tag is synonymous with the main tag\n\tMainTagSlugName string `json:\"main_tag_slug_name\"`\n\tRecommend       bool   `json:\"recommend\"`\n\tReserved        bool   `json:\"reserved\"`\n}\n\ntype SearchTagLikeResp struct {\n\tSlugName  string `json:\"slug_name\"`\n\tRecommend bool   `json:\"recommend\"`\n\tReserved  bool   `json:\"reserved\"`\n}\n"], "fixing_code": ["package schema\n\nimport (\n\t\"strings\"\n\n\t\"github.com/answerdev/answer/internal/base/reason\"\n\t\"github.com/answerdev/answer/internal/base/validator\"\n\t\"github.com/answerdev/answer/pkg/converter\"\n\t\"github.com/segmentfault/pacman/errors\"\n)\n\n// SearchTagLikeReq get tag list all request\ntype SearchTagLikeReq struct {\n\t// tag\n\tTag     string `validate:\"omitempty\" form:\"tag\"`\n\tIsAdmin bool   `json:\"-\"`\n}\n\ntype SearchTagsBySlugName struct {\n\tTags    string   `json:\"tags\" form:\"tags\"`\n\tTagList []string `json:\"-\"`\n\tIsAdmin bool     `json:\"-\"`\n}\n\n// GetTagInfoReq get tag info request\ntype GetTagInfoReq struct {\n\t// tag id\n\tID string `validate:\"omitempty\" form:\"id\"`\n\t// tag slug name\n\tName string `validate:\"omitempty,gt=0,lte=35\" form:\"name\"`\n\t// user id\n\tUserID string `json:\"-\"`\n\t// whether user can edit it\n\tCanEdit bool `json:\"-\"`\n\t// whether user can delete it\n\tCanDelete bool `json:\"-\"`\n}\n\ntype GetTamplateTagInfoReq struct {\n\t// tag id\n\tID string `validate:\"omitempty\" form:\"id\"`\n\t// tag slug name\n\tName string `validate:\"omitempty\" form:\"name\"`\n\t// user id\n\tUserID   string `json:\"-\"`\n\tPage     int    `validate:\"omitempty,min=1\" form:\"page\"`\n\tPageSize int    `validate:\"omitempty,min=1\" form:\"page_size\"`\n}\n\nfunc (r *GetTagInfoReq) Check() (errFields []*validator.FormErrorField, err error) {\n\tif len(r.ID) == 0 && len(r.Name) == 0 {\n\t\treturn nil, errors.BadRequest(reason.RequestFormatError)\n\t}\n\tr.Name = strings.ToLower(r.Name)\n\treturn nil, nil\n}\n\n// GetTagResp get tag response\ntype GetTagResp struct {\n\t// tag id\n\tTagID string `json:\"tag_id\"`\n\t// created time\n\tCreatedAt int64 `json:\"created_at\"`\n\t// updated time\n\tUpdatedAt int64 `json:\"updated_at\"`\n\t// slug name\n\tSlugName string `json:\"slug_name\"`\n\t// display name\n\tDisplayName string `json:\"display_name\"`\n\t// excerpt\n\tExcerpt string `json:\"excerpt\"`\n\t// original text\n\tOriginalText string `json:\"original_text\"`\n\t// parsed text\n\tParsedText string `json:\"parsed_text\"`\n\t// description text\n\tDescription string `json:\"description\"`\n\t// follower amount\n\tFollowCount int `json:\"follow_count\"`\n\t// question amount\n\tQuestionCount int `json:\"question_count\"`\n\t// is follower\n\tIsFollower bool `json:\"is_follower\"`\n\t// MemberActions\n\tMemberActions []*PermissionMemberAction `json:\"member_actions\"`\n\t// if main tag slug name is not empty, this tag is synonymous with the main tag\n\tMainTagSlugName string `json:\"main_tag_slug_name\"`\n\tRecommend       bool   `json:\"recommend\"`\n\tReserved        bool   `json:\"reserved\"`\n}\n\nfunc (tr *GetTagResp) GetExcerpt() {\n\texcerpt := strings.TrimSpace(tr.ParsedText)\n\tidx := strings.Index(excerpt, \"\\n\")\n\tif idx >= 0 {\n\t\texcerpt = excerpt[0:idx]\n\t}\n\ttr.Excerpt = excerpt\n}\n\n// GetTagPageResp get tag response\ntype GetTagPageResp struct {\n\t// tag_id\n\tTagID string `json:\"tag_id\"`\n\t// slug_name\n\tSlugName string `json:\"slug_name\"`\n\t// display_name\n\tDisplayName string `json:\"display_name\"`\n\t// excerpt\n\tExcerpt string `json:\"excerpt\"`\n\t// original text\n\tOriginalText string `json:\"original_text\"`\n\t// parsed_text\n\tParsedText string `json:\"parsed_text\"`\n\t// follower amount\n\tFollowCount int `json:\"follow_count\"`\n\t// question amount\n\tQuestionCount int `json:\"question_count\"`\n\t// is follower\n\tIsFollower bool `json:\"is_follower\"`\n\t// created time\n\tCreatedAt int64 `json:\"created_at\"`\n\t// updated time\n\tUpdatedAt int64 `json:\"updated_at\"`\n\tRecommend bool  `json:\"recommend\"`\n\tReserved  bool  `json:\"reserved\"`\n}\n\nfunc (tr *GetTagPageResp) GetExcerpt() {\n\texcerpt := strings.TrimSpace(tr.OriginalText)\n\tidx := strings.Index(excerpt, \"\\n\")\n\tif idx >= 0 {\n\t\texcerpt = excerpt[0:idx]\n\t}\n\ttr.Excerpt = excerpt\n}\n\ntype TagChange struct {\n\tObjectID string     `json:\"object_id\"` // object_id\n\tTags     []*TagItem `json:\"tags\"`      // tags name\n\t// user id\n\tUserID string `json:\"-\"`\n}\n\ntype TagItem struct {\n\t// slug_name\n\tSlugName string `validate:\"omitempty,gt=0,lte=35\" json:\"slug_name\"`\n\t// display_name\n\tDisplayName string `validate:\"omitempty,gt=0,lte=35\" json:\"display_name\"`\n\t// original text\n\tOriginalText string `validate:\"omitempty\" json:\"original_text\"`\n\t// parsed text\n\tParsedText string `json:\"-\"`\n}\n\n// RemoveTagReq delete tag request\ntype RemoveTagReq struct {\n\t// tag_id\n\tTagID string `validate:\"required\" json:\"tag_id\"`\n\t// user id\n\tUserID string `json:\"-\"`\n}\n\n// UpdateTagReq update tag request\ntype UpdateTagReq struct {\n\t// tag_id\n\tTagID string `validate:\"required\" json:\"tag_id\"`\n\t// slug_name\n\tSlugName string `validate:\"omitempty,gt=0,lte=35\" json:\"slug_name\"`\n\t// display_name\n\tDisplayName string `validate:\"omitempty,gt=0,lte=35\" json:\"display_name\"`\n\t// original text\n\tOriginalText string `validate:\"omitempty\" json:\"original_text\"`\n\t// parsed text\n\tParsedText string `json:\"-\"`\n\t// edit summary\n\tEditSummary string `validate:\"omitempty\" json:\"edit_summary\"`\n\t// user id\n\tUserID       string `json:\"-\"`\n\tNoNeedReview bool   `json:\"-\"`\n}\n\nfunc (r *UpdateTagReq) Check() (errFields []*validator.FormErrorField, err error) {\n\tif len(r.EditSummary) == 0 {\n\t\tr.EditSummary = \"tag.edit.summary\"\n\t}\n\tr.ParsedText = converter.Markdown2HTML(r.OriginalText)\n\treturn nil, nil\n}\n\n// UpdateTagResp update tag response\ntype UpdateTagResp struct {\n\tWaitForReview bool `json:\"wait_for_review\"`\n}\n\n// GetTagWithPageReq get tag list page request\ntype GetTagWithPageReq struct {\n\t// page\n\tPage int `validate:\"omitempty,min=1\" form:\"page\"`\n\t// page size\n\tPageSize int `validate:\"omitempty,min=1\" form:\"page_size\"`\n\t// slug_name\n\tSlugName string `validate:\"omitempty,gt=0,lte=35\" form:\"slug_name\"`\n\t// display_name\n\tDisplayName string `validate:\"omitempty,gt=0,lte=35\" form:\"display_name\"`\n\t// query condition\n\tQueryCond string `validate:\"omitempty,oneof=popular name newest\" form:\"query_cond\"`\n\t// user id\n\tUserID string `json:\"-\"`\n}\n\n// GetTagSynonymsReq get tag synonyms request\ntype GetTagSynonymsReq struct {\n\t// tag_id\n\tTagID string `validate:\"required\" form:\"tag_id\"`\n\t// user id\n\tUserID string `json:\"-\"`\n\t// whether user can edit it\n\tCanEdit bool `json:\"-\"`\n}\n\n// GetTagSynonymsResp get tag synonyms response\ntype GetTagSynonymsResp struct {\n\t// synonyms\n\tSynonyms []*TagSynonym `json:\"synonyms\"`\n\t// MemberActions\n\tMemberActions []*PermissionMemberAction `json:\"member_actions\"`\n}\n\ntype TagSynonym struct {\n\t// tag id\n\tTagID string `json:\"tag_id\"`\n\t// slug name\n\tSlugName string `json:\"slug_name\"`\n\t// display name\n\tDisplayName string `json:\"display_name\"`\n\t// if main tag slug name is not empty, this tag is synonymous with the main tag\n\tMainTagSlugName string `json:\"main_tag_slug_name\"`\n}\n\n// UpdateTagSynonymReq update tag request\ntype UpdateTagSynonymReq struct {\n\t// tag_id\n\tTagID string `validate:\"required\" json:\"tag_id\"`\n\t// synonym tag list\n\tSynonymTagList []*TagItem `validate:\"required,dive\" json:\"synonym_tag_list\"`\n\t// user id\n\tUserID string `json:\"-\"`\n}\n\nfunc (req *UpdateTagSynonymReq) Format() {\n\tfor _, item := range req.SynonymTagList {\n\t\titem.SlugName = strings.ToLower(item.SlugName)\n\t}\n}\n\n// GetFollowingTagsResp get following tags response\ntype GetFollowingTagsResp struct {\n\t// tag id\n\tTagID string `json:\"tag_id\"`\n\t// slug name\n\tSlugName string `json:\"slug_name\"`\n\t// display name\n\tDisplayName string `json:\"display_name\"`\n\t// if main tag slug name is not empty, this tag is synonymous with the main tag\n\tMainTagSlugName string `json:\"main_tag_slug_name\"`\n\tRecommend       bool   `json:\"recommend\"`\n\tReserved        bool   `json:\"reserved\"`\n}\n\ntype SearchTagLikeResp struct {\n\tSlugName  string `json:\"slug_name\"`\n\tRecommend bool   `json:\"recommend\"`\n\tReserved  bool   `json:\"reserved\"`\n}\n"], "filenames": ["internal/schema/tag_schema.go"], "buggy_code_start_loc": [93], "buggy_code_end_loc": [94], "fixing_code_start_loc": [93], "fixing_code_end_loc": [94], "type": "CWE-79", "message": "Cross-site Scripting (XSS) - Stored in GitHub repository answerdev/answer prior to 1.0.6.", "other": {"cve": {"id": "CVE-2023-1241", "sourceIdentifier": "security@huntr.dev", "published": "2023-03-07T08:15:09.673", "lastModified": "2023-03-13T15:14:50.587", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Cross-site Scripting (XSS) - Stored in GitHub repository answerdev/answer prior to 1.0.6."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.3, "impactScore": 2.7}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:answer:answer:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.0.6", "matchCriteriaId": "BC30C65B-0A27-4181-94A2-75BDAD7D7145"}]}]}], "references": [{"url": "https://github.com/answerdev/answer/commit/90bfa0dcc7b49482f1d1e31aee3ab073f3c13dd9", "source": "security@huntr.dev", "tags": ["Patch"]}, {"url": "https://huntr.dev/bounties/e0e9b1bb-3025-4b9f-acb4-16a5da28aa3c", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/answerdev/answer/commit/90bfa0dcc7b49482f1d1e31aee3ab073f3c13dd9"}}