{"buggy_code": ["/* libcomps - C alternative to yum.comps library\n * Copyright (C) 2013 Jindrich Luza\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to  Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,\n * USA\n */\n\n#include \"comps_mradix.h\"\n#include <stdio.h>\n\nvoid comps_mrtree_data_destroy(COMPS_MRTreeData * rtd) {\n    free(rtd->key);\n    comps_hslist_destroy(&rtd->data);\n    comps_hslist_destroy(&rtd->subnodes);\n    free(rtd);\n}\n\ninline void comps_mrtree_data_destroy_v(void * rtd) {\n    comps_mrtree_data_destroy((COMPS_MRTreeData*)rtd);\n}\n\nCOMPS_MRTreeData * comps_mrtree_data_create_n(COMPS_MRTree * tree, char * key,\n                                              size_t keylen, void * data) {\n    COMPS_MRTreeData * rtd;\n    if ((rtd = malloc(sizeof(*rtd))) == NULL)\n        return NULL;\n    if ((rtd->key = malloc(sizeof(char) * (keylen+1))) == NULL) {\n        free(rtd);\n        return NULL;\n    }\n    memcpy(rtd->key, key, sizeof(char)*keylen);\n    rtd->key[keylen] = 0;\n    rtd->is_leaf = 1;\n    rtd->data = comps_hslist_create();\n    comps_hslist_init(rtd->data, NULL, tree->data_cloner,\n                                       tree->data_destructor);\n    if (data)\n        comps_hslist_append(rtd->data, data, 0);\n    rtd->subnodes = comps_hslist_create();\n    comps_hslist_init(rtd->subnodes, NULL,\n                                     NULL,\n                                     &comps_mrtree_data_destroy_v);\n    return rtd;\n}\n\nCOMPS_MRTreeData * comps_mrtree_data_create(COMPS_MRTree * tree,\n                                            char * key, void * data) {\n    return comps_mrtree_data_create_n(tree, key, strlen(key), data);\n}\n\n\nCOMPS_MRTree * comps_mrtree_create(void* (*data_constructor)(void*),\n                                   void* (*data_cloner)(void*),\n                                   void (*data_destructor)(void*)) {\n    COMPS_MRTree *ret;\n    if ((ret = malloc(sizeof(COMPS_MRTree))) == NULL)\n        return NULL;\n    ret->subnodes = comps_hslist_create();\n    comps_hslist_init(ret->subnodes, NULL, NULL, &comps_mrtree_data_destroy_v);\n    if (ret->subnodes == NULL) {\n        free(ret);\n        return NULL;\n    }\n    ret->data_constructor = data_constructor;\n    ret->data_cloner = data_cloner;\n    ret->data_destructor = data_destructor;\n    return ret;\n}\n\nvoid comps_mrtree_destroy(COMPS_MRTree * rt) {\n    comps_hslist_destroy(&(rt->subnodes));\n    free(rt);\n}\n\nvoid comps_mrtree_print(COMPS_HSList * hl, unsigned  deep) {\n    COMPS_HSListItem * it;\n    for (it = hl->first; it != NULL; it=it->next) {\n        printf(\"%d %s\\n\",deep, (((COMPS_MRTreeData*)it->data)->key));\n        comps_mrtree_print(((COMPS_MRTreeData*)it->data)->subnodes, deep+1);\n    }\n}\n\nvoid comps_mrtree_values_walk(COMPS_MRTree * rt, void* udata,\n                              void (*walk_f)(void*, void*)) {\n    COMPS_HSList *tmplist, *tmp_subnodes;\n    COMPS_HSListItem *it, *it2;\n    tmplist = comps_hslist_create();\n    comps_hslist_init(tmplist, NULL, NULL, NULL);\n    comps_hslist_append(tmplist, rt->subnodes, 0);\n    while (tmplist->first != NULL) {\n        it = tmplist->first;\n        comps_hslist_remove(tmplist, tmplist->first);\n        tmp_subnodes = (COMPS_HSList*)it->data;\n        free(it);\n        for (it = tmp_subnodes->first; it != NULL; it=it->next) {\n            if (((COMPS_MRTreeData*)it->data)->subnodes->first) {\n                comps_hslist_append(tmplist,\n                                    ((COMPS_MRTreeData*)it->data)->subnodes, 0);\n            }\n            for (it2 = (COMPS_HSListItem*)((COMPS_MRTreeData*)it->data)->data->first;\n                 it2 != NULL; it2 = it2->next) {\n                walk_f(udata, it2->data);\n            }\n        }\n    }\n    comps_hslist_destroy(&tmplist);\n}\n\nCOMPS_MRTree * comps_mrtree_clone(COMPS_MRTree * rt) {\n\n    COMPS_HSList * to_clone, *tmplist, *new_subnodes;\n    COMPS_MRTree * ret;\n    COMPS_HSListItem *it, *it2;\n    COMPS_MRTreeData *rtdata;\n    COMPS_HSList *new_data_list;\n\n    to_clone = comps_hslist_create();\n    comps_hslist_init(to_clone, NULL, NULL, NULL);\n    ret = comps_mrtree_create(rt->data_constructor, rt->data_cloner,\n                              rt->data_destructor);\n\n    for (it = rt->subnodes->first; it != NULL; it = it->next) {\n        rtdata = comps_mrtree_data_create(rt,\n                                      ((COMPS_MRTreeData*)it->data)->key, NULL);\n        new_data_list = comps_hslist_clone(((COMPS_MRTreeData*)it->data)->data);\n        comps_hslist_destroy(&rtdata->data);\n        comps_hslist_destroy(&rtdata->subnodes);\n        rtdata->subnodes = ((COMPS_MRTreeData*)it->data)->subnodes;\n        rtdata->data = new_data_list;\n        comps_hslist_append(ret->subnodes, rtdata, 0);\n\n        comps_hslist_append(to_clone, rtdata, 0);\n    }\n\n\n    while (to_clone->first) {\n        it2 = to_clone->first;\n        tmplist = ((COMPS_MRTreeData*)it2->data)->subnodes;\n        comps_hslist_remove(to_clone, to_clone->first);\n\n        new_subnodes = comps_hslist_create();\n        comps_hslist_init(new_subnodes, NULL, NULL, &comps_mrtree_data_destroy_v);\n        for (it = tmplist->first; it != NULL; it = it->next) {\n            rtdata = comps_mrtree_data_create(rt,\n                                      ((COMPS_MRTreeData*)it->data)->key, NULL);\n            new_data_list = comps_hslist_clone(((COMPS_MRTreeData*)it->data)->data);\n            comps_hslist_destroy(&rtdata->subnodes);\n            comps_hslist_destroy(&rtdata->data);\n            rtdata->subnodes = ((COMPS_MRTreeData*)it->data)->subnodes;\n            rtdata->data = new_data_list;\n            comps_hslist_append(new_subnodes, rtdata, 0);\n\n            comps_hslist_append(to_clone, rtdata, 0);\n        }\n        ((COMPS_MRTreeData*)it2->data)->subnodes = new_subnodes;\n        free(it2);\n    }\n    comps_hslist_destroy(&to_clone);\n    return ret;\n}\n\nvoid comps_mrtree_unite(COMPS_MRTree *rt1, COMPS_MRTree *rt2) {\n    COMPS_HSList *tmplist, *tmp_subnodes;\n    COMPS_HSListItem *it, *it2;\n    struct Pair {\n        COMPS_HSList * subnodes;\n        char * key;\n        char added;\n    } *pair, *parent_pair;\n\n    pair = malloc(sizeof(struct Pair));\n    pair->subnodes = rt2->subnodes;\n    pair->key = NULL;\n\n    tmplist = comps_hslist_create();\n    comps_hslist_init(tmplist, NULL, NULL, &free);\n    comps_hslist_append(tmplist, pair, 0);\n\n    while (tmplist->first != NULL) {\n        it = tmplist->first;\n        comps_hslist_remove(tmplist, tmplist->first);\n        tmp_subnodes = ((struct Pair*)it->data)->subnodes;\n        parent_pair = (struct Pair*) it->data;\n        free(it);\n\n        pair->added = 0;\n        for (it = tmp_subnodes->first; it != NULL; it=it->next) {\n            pair = malloc(sizeof(struct Pair));\n            pair->subnodes = ((COMPS_MRTreeData*)it->data)->subnodes;\n\n            if (parent_pair->key != NULL) {\n                pair->key =\n                    malloc(sizeof(char)\n                           * (strlen(((COMPS_MRTreeData*)it->data)->key)\n                           + strlen(parent_pair->key) + 1));\n                memcpy(pair->key, parent_pair->key,\n                       sizeof(char) * strlen(parent_pair->key));\n                memcpy(pair->key+strlen(parent_pair->key),\n                       ((COMPS_MRTreeData*)it->data)->key,\n                       sizeof(char)*(strlen(((COMPS_MRTreeData*)it->data)->key)+1));\n            } else {\n                pair->key = malloc(sizeof(char)*\n                                (strlen(((COMPS_MRTreeData*)it->data)->key) +\n                                1));\n                memcpy(pair->key, ((COMPS_MRTreeData*)it->data)->key,\n                       sizeof(char)*(strlen(((COMPS_MRTreeData*)it->data)->key)+1));\n            }\n            /* current node has data */\n            if (((COMPS_MRTreeData*)it->data)->data->first != NULL) {\n                for (it2 = ((COMPS_MRTreeData*)it->data)->data->first;\n                     it2 != NULL; it2 = it2->next) {\n                    comps_mrtree_set(rt1, pair->key, it2->data);\n                }\n\n                if (((COMPS_MRTreeData*)it->data)->subnodes->first) {\n                    comps_hslist_append(tmplist, pair, 0);\n                } else {\n                    free(pair->key);\n                    free(pair);\n                }\n            /* current node hasn't data */\n            } else {\n                if (((COMPS_MRTreeData*)it->data)->subnodes->first) {\n                    comps_hslist_append(tmplist, pair, 0);\n                } else {\n                    free(pair->key);\n                    free(pair);\n                }\n            }\n        }\n        free(parent_pair->key);\n        free(parent_pair);\n    }\n    comps_hslist_destroy(&tmplist);\n}\n\nCOMPS_HSList* comps_mrtree_keys(COMPS_MRTree * rt) {\n    COMPS_HSList *tmplist, *tmp_subnodes, *ret;\n    COMPS_HSListItem *it;\n    struct Pair {\n        COMPS_HSList * subnodes;\n        char * key;\n        char added;\n    } *pair, *parent_pair;\n\n    pair = malloc(sizeof(struct Pair));\n    pair->subnodes = rt->subnodes;\n    pair->key = NULL;\n    pair->added = 0;\n\n    tmplist = comps_hslist_create();\n    comps_hslist_init(tmplist, NULL, NULL, &free);\n    ret = comps_hslist_create();\n    comps_hslist_init(ret, NULL, NULL, &free);\n    comps_hslist_append(tmplist, pair, 0);\n\n    while (tmplist->first != NULL) {\n        it = tmplist->first;\n        comps_hslist_remove(tmplist, tmplist->first);\n        tmp_subnodes = ((struct Pair*)it->data)->subnodes;\n        parent_pair = (struct Pair*) it->data;\n        free(it);\n\n        for (it = tmp_subnodes->first; it != NULL; it=it->next) {\n            pair = malloc(sizeof(struct Pair));\n            pair->subnodes = ((COMPS_MRTreeData*)it->data)->subnodes;\n            pair->added = 0;\n\n            if (parent_pair->key != NULL) {\n                pair->key =\n                    malloc(sizeof(char)\n                           * (strlen(((COMPS_MRTreeData*)it->data)->key)\n                           + strlen(parent_pair->key) + 1));\n                memcpy(pair->key, parent_pair->key,\n                       sizeof(char) * strlen(parent_pair->key));\n                memcpy(pair->key+strlen(parent_pair->key),\n                       ((COMPS_MRTreeData*)it->data)->key,\n                       sizeof(char)*(strlen(((COMPS_MRTreeData*)it->data)->key)+1));\n            } else {\n                pair->key = malloc(sizeof(char)*\n                                (strlen(((COMPS_MRTreeData*)it->data)->key) +\n                                1));\n                memcpy(pair->key, ((COMPS_MRTreeData*)it->data)->key,\n                       sizeof(char)*(strlen(((COMPS_MRTreeData*)it->data)->key)+1));\n            }\n            /* current node has data */\n            if (((COMPS_MRTreeData*)it->data)->data->first != NULL) {\n                //printf(\"data not null for |%s|\\n\", pair->key);\n                comps_hslist_append(ret, pair->key, 0);\n                pair->added = 1;\n                if (((COMPS_MRTreeData*)it->data)->subnodes->first != NULL) {\n//                    printf(\"subnodes found\\b\");\n                    comps_hslist_append(tmplist, pair, 0);\n                } else {\n                    free(pair);\n                }\n            /* current node hasn't data */\n            } else {\n                if (((COMPS_MRTreeData*)it->data)->subnodes->first) {\n                    comps_hslist_append(tmplist, pair, 0);\n                } else {\n                    free(pair->key);\n                    free(pair);\n                }\n            }\n        }\n        if (parent_pair->added == 0)\n            free(parent_pair->key);\n        free(parent_pair);\n    }\n    comps_hslist_destroy(&tmplist);\n    return ret;\n}\n\nvoid __comps_mrtree_set(COMPS_MRTree * rt, char * key, size_t len, void * data)\n{\n    static COMPS_HSListItem *it;\n    COMPS_HSList *subnodes;\n    COMPS_MRTreeData *rtd;\n    static COMPS_MRTreeData *rtdata;\n\n    size_t _len, offset=0;\n    unsigned x, found = 0;\n    void *ndata;\n    char ended;//, tmpch;\n\n    if (rt->subnodes == NULL)\n        return;\n    if (rt->data_constructor)\n        ndata = rt->data_constructor(data);\n    else\n        ndata = data;\n\n    subnodes = rt->subnodes;\n    while (offset != len)\n    {\n        found = 0;\n        for (it = subnodes->first; it != NULL; it=it->next) {\n            if (((COMPS_MRTreeData*)it->data)->key[0] == key[offset]) {\n                found = 1;\n                break;\n            }\n        }\n        if (!found) { // not found in subnodes; create new subnode\n            rtd = comps_mrtree_data_create(rt, key+offset, ndata);\n            comps_hslist_append(subnodes, rtd, 0);\n            return;\n        } else {\n            rtdata = (COMPS_MRTreeData*)it->data;\n            ended = 0;\n            for (x=1; ;x++) {\n                if (rtdata->key[x] == 0) ended += 1;\n                if (x == len - offset) ended += 2;\n                if (ended != 0) break;\n                if (key[offset+x] != rtdata->key[x]) break;\n            }\n            if (ended == 3) { //keys equals; append new data\n                comps_hslist_append(rtdata->data, ndata, 0);\n                return;\n            } else if (ended == 2) { //global key ends first; make global leaf\n                comps_hslist_remove(subnodes, it);\n                it->next = NULL;\n                rtd = comps_mrtree_data_create(rt, key+offset,  ndata);\n                comps_hslist_append(subnodes, rtd, 0);\n                ((COMPS_MRTreeData*)subnodes->last->data)->subnodes->last = it;\n                ((COMPS_MRTreeData*)subnodes->last->data)->subnodes->first = it;\n                _len = strlen(key + offset);\n                memmove(rtdata->key,rtdata->key+_len, strlen(rtdata->key) - _len);\n                rtdata->key[strlen(rtdata->key) - _len] = 0;\n                rtdata->key = realloc(rtdata->key,\n                                      sizeof(char)* (strlen(rtdata->key)+1));\n                return;\n            } else if (ended == 1) { //local key ends first; go deeper\n                subnodes = rtdata->subnodes;\n                offset += x;\n            } else { /* keys differ */\n                void *tmpdata = rtdata->data;\n                COMPS_HSList *tmpnodes = rtdata->subnodes;\n\n                int cmpret = strcmp(key+offset+x, rtdata->key+x);\n                rtdata->subnodes = comps_hslist_create();\n                comps_hslist_init(rtdata->subnodes, NULL, NULL,\n                                  &comps_mrtree_data_destroy_v);\n                rtdata->data = NULL;\n                if (cmpret > 0) {\n                    rtd = comps_mrtree_data_create(rt, rtdata->key+x, tmpdata);\n                    comps_hslist_destroy(&rtd->subnodes);\n                    rtd->subnodes = tmpnodes;\n                    comps_hslist_append(rtdata->subnodes, rtd, 0);\n                    rtd = comps_mrtree_data_create(rt, key+offset+x, ndata);\n                    comps_hslist_append(rtdata->subnodes, rtd, 0);\n                } else {\n                    rtd = comps_mrtree_data_create(rt, key+offset+x, ndata);\n                    comps_hslist_append(rtdata->subnodes, rtd, 0);\n                    rtd = comps_mrtree_data_create(rt, rtdata->key+x, tmpdata);\n                    comps_hslist_destroy(&rtd->subnodes);\n                    rtd->subnodes = tmpnodes;\n                    comps_hslist_append(rtdata->subnodes, rtd, 0);\n                }\n                rtdata->key = realloc(rtdata->key, sizeof(char)*(x+1));\n                rtdata->key[x] = 0;\n                return;\n            }\n        }\n    }\n}\n\nvoid comps_mrtree_set(COMPS_MRTree * rt, char * key, void * data)\n{\n    __comps_mrtree_set(rt, key, strlen(key), data);\n}\n\nvoid comps_mrtree_set_n(COMPS_MRTree * rt, char * key, size_t len, void * data)\n{\n    __comps_mrtree_set(rt, key, len, data);\n}\n\nCOMPS_HSList * comps_mrtree_get(COMPS_MRTree * rt, const char * key) {\n    COMPS_HSList * subnodes;\n    COMPS_HSListItem * it = NULL;\n    COMPS_MRTreeData * rtdata;\n    unsigned int offset, len, x;\n    char found, ended;\n\n    len = strlen(key);\n    offset = 0;\n    subnodes = rt->subnodes;\n    while (offset != len) {\n        found = 0;\n        for (it = subnodes->first; it != NULL; it=it->next) {\n            if (((COMPS_MRTreeData*)it->data)->key[0] == key[offset]) {\n                found = 1;\n                break;\n            }\n        }\n        if (!found)\n            return NULL;\n        rtdata = (COMPS_MRTreeData*)it->data;\n\n        for (x=1; ;x++) {\n            ended=0;\n            if (rtdata->key[x] == 0) ended += 1;\n            if (x == len - offset) ended += 2;\n            if (ended != 0) break;\n            if (key[offset+x] != rtdata->key[x]) break;\n        }\n        if (ended == 3) return rtdata->data;\n        else if (ended == 1) offset+=x;\n        else return NULL;\n        subnodes = ((COMPS_MRTreeData*)it->data)->subnodes;\n    }\n    if (it)\n        return ((COMPS_MRTreeData*)it->data)->data;\n    else return NULL;\n}\n\nCOMPS_HSList ** comps_mrtree_getp(COMPS_MRTree * rt, const char * key) {\n    COMPS_HSList * subnodes;\n    COMPS_HSListItem * it = NULL;\n    COMPS_MRTreeData * rtdata;\n    unsigned int offset, len, x;\n    char found, ended;\n\n    len = strlen(key);\n    offset = 0;\n    subnodes = rt->subnodes;\n    while (offset != len) {\n        found = 0;\n        for (it = subnodes->first; it != NULL; it=it->next) {\n            if (((COMPS_MRTreeData*)it->data)->key[0] == key[offset]) {\n                found = 1;\n                break;\n            }\n        }\n        if (!found)\n            return NULL;\n        rtdata = (COMPS_MRTreeData*)it->data;\n\n        for (x=1; ;x++) {\n            ended=0;\n            if (rtdata->key[x] == 0) ended += 1;\n            if (x == len - offset) ended += 2;\n            if (ended != 0) break;\n            if (key[offset+x] != rtdata->key[x]) break;\n        }\n        if (ended == 3) return &rtdata->data;\n        else if (ended == 1) offset+=x;\n        else return NULL;\n        subnodes = ((COMPS_MRTreeData*)it->data)->subnodes;\n    }\n    if (it)\n        return &((COMPS_MRTreeData*)it->data)->data;\n    else return NULL;\n}\n\nvoid comps_mrtree_unset(COMPS_MRTree * rt, const char * key) {\n    COMPS_HSList * subnodes;\n    COMPS_HSListItem * it;\n    COMPS_MRTreeData * rtdata;\n    unsigned int offset, len, x;\n    char found, ended;\n    COMPS_HSList * path;\n\n    struct Relation {\n        COMPS_HSList * parent_nodes;\n        COMPS_HSListItem * child_it;\n    } *relation;\n\n    path = comps_hslist_create();\n    comps_hslist_init(path, NULL, NULL, &free);\n\n    len = strlen(key);\n    offset = 0;\n    subnodes = rt->subnodes;\n    while (offset != len) {\n        found = 0;\n        for (it = subnodes->first; it != NULL; it=it->next) {\n            if (((COMPS_MRTreeData*)it->data)->key[0] == key[offset]) {\n                found = 1;\n                break;\n            }\n        }\n        if (!found) {\n            comps_hslist_destroy(&path);\n            return;\n        }\n        rtdata = (COMPS_MRTreeData*)it->data;\n\n        for (x=1; ;x++) {\n            ended=0;\n            if (rtdata->key[x] == 0) ended += 1;\n            if (x == len - offset) ended += 2;\n            if (ended != 0) break;\n            if (key[offset+x] != rtdata->key[x]) break;\n        }\n        if (ended == 3) {\n            /* remove node from tree only if there's no descendant*/\n            if (rtdata->subnodes->last == NULL) {\n                printf(\"removing all\\n\");\n                comps_hslist_remove(subnodes, it);\n                comps_mrtree_data_destroy(rtdata);\n                free(it);\n            }\n            else {\n                printf(\"removing data only\\n\");\n                comps_hslist_clear(rtdata->data);\n                rtdata->is_leaf = 0;\n            }\n\n            if (path->last == NULL) {\n                comps_hslist_destroy(&path);\n                return;\n            }\n            rtdata = (COMPS_MRTreeData*)\n                     ((struct Relation*)path->last->data)->child_it->data;\n\n            /*remove all predecessor of deleted node (recursive) with no childs*/\n            while (rtdata->subnodes->last == NULL) {\n                printf(\"removing '%s'\\n\", rtdata->key);\n                comps_mrtree_data_destroy(rtdata);\n                comps_hslist_remove(\n                            ((struct Relation*)path->last->data)->parent_nodes,\n                            ((struct Relation*)path->last->data)->child_it);\n                free(((struct Relation*)path->last->data)->child_it);\n                it = path->last;\n                comps_hslist_remove(path, path->last);\n                free(it);\n                rtdata = (COMPS_MRTreeData*)\n                         ((struct Relation*)path->last->data)->child_it->data;\n            }\n            comps_hslist_destroy(&path);\n            return;\n        }\n        else if (ended == 1) offset+=x;\n        else {\n            comps_hslist_destroy(&path);\n            return;\n        }\n        if ((relation = malloc(sizeof(struct Relation))) == NULL) {\n            comps_hslist_destroy(&path);\n            return;\n        }\n        subnodes = ((COMPS_MRTreeData*)it->data)->subnodes;\n        relation->parent_nodes = subnodes;\n        relation->child_it = it;\n        comps_hslist_append(path, (void*)relation, 0);\n    }\n    comps_hslist_destroy(&path);\n    return;\n}\n\nvoid comps_mrtree_clear(COMPS_MRTree * rt) {\n    COMPS_HSListItem *it, *oldit;\n    if (rt == NULL) return;\n    if (rt->subnodes == NULL) return;\n    oldit = rt->subnodes->first;\n    it = (oldit)?oldit->next:NULL;\n    for (;it != NULL; it=it->next) {\n        if (rt->subnodes->data_destructor != NULL)\n            rt->subnodes->data_destructor(oldit->data);\n        free(oldit);\n        oldit = it;\n    }\n    if (oldit) {\n        if (rt->subnodes->data_destructor != NULL)\n            rt->subnodes->data_destructor(oldit->data);\n        free(oldit);\n    }\n}\n", "/* libcomps - C alternative to yum.comps library\n * Copyright (C) 2013 Jindrich Luza\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to  Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,\n * USA\n */\n\n#include \"comps_objmradix.h\"\n#include \"comps_set.h\"\n#include <stdio.h>\n\nvoid comps_objmrtree_data_destroy(COMPS_ObjMRTreeData * rtd) {\n    free(rtd->key);\n    COMPS_OBJECT_DESTROY(rtd->data);\n    comps_hslist_destroy(&rtd->subnodes);\n    free(rtd);\n}\n\ninline void comps_objmrtree_data_destroy_v(void * rtd) {\n    comps_objmrtree_data_destroy((COMPS_ObjMRTreeData*)rtd);\n}\n\nstatic COMPS_ObjMRTreeData * __comps_objmrtree_data_create(char * key,\n                                                    size_t keylen,\n                                                    COMPS_Object *data) {\n\n    COMPS_ObjMRTreeData * rtd;\n    if ((rtd = malloc(sizeof(*rtd))) == NULL)\n        return NULL;\n    if ((rtd->key = malloc(sizeof(char) * (keylen+1))) == NULL) {\n        free(rtd);\n        return NULL;\n    }\n    memcpy(rtd->key, key, sizeof(char)*keylen);\n    rtd->key[keylen] = '\\0';\n    rtd->is_leaf = 1;\n    rtd->data = COMPS_OBJECT_CREATE(COMPS_ObjList, NULL);\n    if (data)\n        comps_objlist_append_x(rtd->data, data);\n    rtd->subnodes = comps_hslist_create();\n    comps_hslist_init(rtd->subnodes, NULL,\n                                     NULL,\n                                     &comps_objmrtree_data_destroy_v);\n    return rtd;\n}\n\nCOMPS_ObjMRTreeData * comps_objmrtree_data_create(char *key, COMPS_Object *data){\n    COMPS_ObjMRTreeData * rtd;\n    rtd = __comps_objmrtree_data_create(key, strlen(key), data);\n    return rtd;\n}\n\nCOMPS_ObjMRTreeData * comps_objmrtree_data_create_n(char * key, unsigned keylen,\n                                                    void * data) {\n    COMPS_ObjMRTreeData * rtd;\n    rtd = __comps_objmrtree_data_create(key, keylen, data);\n    return rtd;\n}\nstatic void comps_objmrtree_create(COMPS_ObjMRTree *rtree, COMPS_Object **args){\n    (void)args;\n    rtree->subnodes = comps_hslist_create();\n    comps_hslist_init(rtree->subnodes, NULL, NULL, &comps_objmrtree_data_destroy_v);\n    if (rtree->subnodes == NULL) {\n        COMPS_OBJECT_DESTROY(rtree);\n        return;\n    }\n    rtree->len = 0;\n}\nvoid comps_objmrtree_create_u(COMPS_Object * obj, COMPS_Object **args) {\n    (void)args;\n    comps_objmrtree_create((COMPS_ObjMRTree*)obj, NULL);\n}\n\nstatic void comps_objmrtree_destroy(COMPS_ObjMRTree * rt) {\n    comps_hslist_destroy(&(rt->subnodes));\n}\nvoid comps_objmrtree_destroy_u(COMPS_Object *obj) {\n    comps_objmrtree_destroy((COMPS_ObjMRTree*)obj);\n}\n\nvoid comps_objmrtree_values_walk(COMPS_ObjMRTree * rt, void* udata,\n                              void (*walk_f)(void*, void*)) {\n    COMPS_HSList *tmplist, *tmp_subnodes;\n    COMPS_HSListItem *it, *it2;\n    tmplist = comps_hslist_create();\n    comps_hslist_init(tmplist, NULL, NULL, NULL);\n    comps_hslist_append(tmplist, rt->subnodes, 0);\n    while (tmplist->first != NULL) {\n        it = tmplist->first;\n        comps_hslist_remove(tmplist, tmplist->first);\n        tmp_subnodes = (COMPS_HSList*)it->data;\n        free(it);\n        for (it = tmp_subnodes->first; it != NULL; it=it->next) {\n            if (((COMPS_ObjMRTreeData*)it->data)->subnodes->first) {\n                comps_hslist_append(tmplist,\n                                    ((COMPS_ObjMRTreeData*)it->data)->subnodes, 0);\n            }\n            for (it2 = (COMPS_HSListItem*)((COMPS_ObjMRTreeData*)it->data)->data->first;\n                 it2 != NULL; it2 = it2->next) {\n                walk_f(udata, it2->data);\n            }\n        }\n    }\n    comps_hslist_destroy(&tmplist);\n}\n\nvoid comps_objmrtree_copy(COMPS_ObjMRTree *ret, COMPS_ObjMRTree *rt){\n    COMPS_HSList * to_clone, *tmplist, *new_subnodes;\n    COMPS_HSListItem *it, *it2;\n    COMPS_ObjMRTreeData *rtdata;\n    COMPS_ObjList *new_data_list;\n\n    to_clone = comps_hslist_create();\n    comps_hslist_init(to_clone, NULL, NULL, NULL);\n\n    for (it = rt->subnodes->first; it != NULL; it = it->next) {\n        rtdata = comps_objmrtree_data_create(\n                                       ((COMPS_ObjMRTreeData*)it->data)->key,\n                                       NULL);\n        new_data_list = (COMPS_ObjList*)\n                        COMPS_OBJECT_COPY(((COMPS_ObjMRTreeData*)it->data)->data);\n        COMPS_OBJECT_DESTROY(&rtdata->data);\n        comps_hslist_destroy(&rtdata->subnodes);\n        rtdata->subnodes = ((COMPS_ObjMRTreeData*)it->data)->subnodes;\n        rtdata->data = new_data_list;\n        comps_hslist_append(ret->subnodes, rtdata, 0);\n\n        comps_hslist_append(to_clone, rtdata, 0);\n    }\n\n    while (to_clone->first) {\n        it2 = to_clone->first;\n        tmplist = ((COMPS_ObjMRTreeData*)it2->data)->subnodes;\n        comps_hslist_remove(to_clone, to_clone->first);\n\n        new_subnodes = comps_hslist_create();\n        comps_hslist_init(new_subnodes, NULL, NULL, &comps_objmrtree_data_destroy_v);\n        for (it = tmplist->first; it != NULL; it = it->next) {\n            rtdata = comps_objmrtree_data_create(\n                                          ((COMPS_ObjMRTreeData*)it->data)->key,\n                                          NULL);\n            new_data_list = (COMPS_ObjList*)\n                            COMPS_OBJECT_COPY(((COMPS_ObjMRTreeData*)it->data)->data);\n\n            comps_hslist_destroy(&rtdata->subnodes);\n            COMPS_OBJECT_DESTROY(rtdata->data);\n            rtdata->subnodes = ((COMPS_ObjMRTreeData*)it->data)->subnodes;\n            rtdata->data = new_data_list;\n            comps_hslist_append(new_subnodes, rtdata, 0);\n\n            comps_hslist_append(to_clone, rtdata, 0);\n        }\n        ((COMPS_ObjMRTreeData*)it2->data)->subnodes = new_subnodes;\n        free(it2);\n    }\n    ret->len = rt->len;\n    comps_hslist_destroy(&to_clone);\n}\nCOMPS_COPY_u(objmrtree, COMPS_ObjMRTree) /*comps_utils.h macro*/\n\nvoid comps_objmrtree_copy_shallow(COMPS_ObjMRTree *ret, COMPS_ObjMRTree *rt){\n    COMPS_HSList * to_clone, *tmplist, *new_subnodes;\n    COMPS_HSListItem *it, *it2;\n    COMPS_ObjMRTreeData *rtdata;\n    COMPS_ObjList *new_data_list;\n\n    to_clone = comps_hslist_create();\n    comps_hslist_init(to_clone, NULL, NULL, NULL);\n\n    for (it = rt->subnodes->first; it != NULL; it = it->next) {\n        rtdata = comps_objmrtree_data_create(\n                                       ((COMPS_ObjMRTreeData*)it->data)->key,\n                                       NULL);\n        new_data_list = (COMPS_ObjList*)\n                        COMPS_OBJECT_COPY(((COMPS_ObjMRTreeData*)it->data)->data);\n        COMPS_OBJECT_DESTROY(&rtdata->data);\n        comps_hslist_destroy(&rtdata->subnodes);\n        rtdata->subnodes = ((COMPS_ObjMRTreeData*)it->data)->subnodes;\n        rtdata->data = new_data_list;\n        comps_hslist_append(ret->subnodes, rtdata, 0);\n\n        comps_hslist_append(to_clone, rtdata, 0);\n    }\n\n    while (to_clone->first) {\n        it2 = to_clone->first;\n        tmplist = ((COMPS_ObjMRTreeData*)it2->data)->subnodes;\n        comps_hslist_remove(to_clone, to_clone->first);\n\n        new_subnodes = comps_hslist_create();\n        comps_hslist_init(new_subnodes, NULL, NULL, &comps_objmrtree_data_destroy_v);\n        for (it = tmplist->first; it != NULL; it = it->next) {\n            rtdata = comps_objmrtree_data_create(\n                                          ((COMPS_ObjMRTreeData*)it->data)->key,\n                                          NULL);\n            new_data_list = ((COMPS_ObjMRTreeData*)it->data)->data;\n\n            comps_hslist_destroy(&rtdata->subnodes);\n            COMPS_OBJECT_DESTROY(rtdata->data);\n            rtdata->subnodes = ((COMPS_ObjMRTreeData*)it->data)->subnodes;\n            rtdata->data = new_data_list;\n            comps_hslist_append(new_subnodes, rtdata, 0);\n\n            comps_hslist_append(to_clone, rtdata, 0);\n        }\n        ((COMPS_ObjMRTreeData*)it2->data)->subnodes = new_subnodes;\n        free(it2);\n    }\n    ret->len = rt->len;\n    comps_hslist_destroy(&to_clone);\n}\n\nCOMPS_ObjMRTree * comps_objmrtree_clone(COMPS_ObjMRTree * rt) {\n    COMPS_HSList * to_clone, *tmplist, *new_subnodes;\n    COMPS_ObjMRTree * ret;\n    COMPS_HSListItem *it, *it2;\n    COMPS_ObjMRTreeData *rtdata;\n    COMPS_ObjList *new_data_list;\n\n    to_clone = comps_hslist_create();\n    comps_hslist_init(to_clone, NULL, NULL, NULL);\n    ret = COMPS_OBJECT_CREATE(COMPS_ObjMRTree, NULL);\n\n    for (it = rt->subnodes->first; it != NULL; it = it->next) {\n        rtdata = comps_objmrtree_data_create(\n                                       ((COMPS_ObjMRTreeData*)it->data)->key,\n                                       NULL);\n        new_data_list = (COMPS_ObjList*)\n                        COMPS_OBJECT_COPY(((COMPS_ObjMRTreeData*)it->data)->data);\n        COMPS_OBJECT_DESTROY(&rtdata->data);\n        comps_hslist_destroy(&rtdata->subnodes);\n        rtdata->subnodes = ((COMPS_ObjMRTreeData*)it->data)->subnodes;\n        rtdata->data = new_data_list;\n        comps_hslist_append(ret->subnodes, rtdata, 0);\n\n        comps_hslist_append(to_clone, rtdata, 0);\n    }\n\n    while (to_clone->first) {\n        it2 = to_clone->first;\n        tmplist = ((COMPS_ObjMRTreeData*)it2->data)->subnodes;\n        comps_hslist_remove(to_clone, to_clone->first);\n\n        new_subnodes = comps_hslist_create();\n        comps_hslist_init(new_subnodes, NULL, NULL, &comps_objmrtree_data_destroy_v);\n        for (it = tmplist->first; it != NULL; it = it->next) {\n            rtdata = comps_objmrtree_data_create(\n                                          ((COMPS_ObjMRTreeData*)it->data)->key,\n                                          NULL);\n            new_data_list = (COMPS_ObjList*)\n                            COMPS_OBJECT_COPY(((COMPS_ObjMRTreeData*)it->data)->data);\n\n            comps_hslist_destroy(&rtdata->subnodes);\n            COMPS_OBJECT_DESTROY(rtdata->data);\n            rtdata->subnodes = ((COMPS_ObjMRTreeData*)it->data)->subnodes;\n            rtdata->data = new_data_list;\n            comps_hslist_append(new_subnodes, rtdata, 0);\n\n            comps_hslist_append(to_clone, rtdata, 0);\n        }\n        ((COMPS_ObjMRTreeData*)it2->data)->subnodes = new_subnodes;\n        free(it2);\n    }\n    ret->len = rt->len;\n    comps_hslist_destroy(&to_clone);\n    return ret;\n}\n\nvoid comps_objmrtree_unite(COMPS_ObjMRTree *rt1, COMPS_ObjMRTree *rt2) {\n    COMPS_HSList *tmplist, *tmp_subnodes;\n    COMPS_HSListItem *it;\n    COMPS_ObjListIt *it2;\n    struct Pair {\n        COMPS_HSList * subnodes;\n        char * key;\n        char added;\n    } *pair, *parent_pair;\n\n    pair = malloc(sizeof(struct Pair));\n    pair->subnodes = rt2->subnodes;\n    pair->key = NULL;\n\n    tmplist = comps_hslist_create();\n    comps_hslist_init(tmplist, NULL, NULL, &free);\n    comps_hslist_append(tmplist, pair, 0);\n\n    while (tmplist->first != NULL) {\n        it = tmplist->first;\n        comps_hslist_remove(tmplist, tmplist->first);\n        tmp_subnodes = ((struct Pair*)it->data)->subnodes;\n        parent_pair = (struct Pair*) it->data;\n        free(it);\n\n        pair->added = 0;\n        for (it = tmp_subnodes->first; it != NULL; it=it->next) {\n            pair = malloc(sizeof(struct Pair));\n            pair->subnodes = ((COMPS_ObjMRTreeData*)it->data)->subnodes;\n\n            if (parent_pair->key != NULL) {\n                pair->key =\n                    malloc(sizeof(char)\n                           * (strlen(((COMPS_ObjMRTreeData*)it->data)->key)\n                           + strlen(parent_pair->key) + 1));\n                memcpy(pair->key, parent_pair->key,\n                       sizeof(char) * strlen(parent_pair->key));\n                memcpy(pair->key+strlen(parent_pair->key),\n                       ((COMPS_ObjMRTreeData*)it->data)->key,\n                       sizeof(char)*(strlen(((COMPS_ObjMRTreeData*)it->data)->key)+1));\n            } else {\n                pair->key = malloc(sizeof(char)*\n                                (strlen(((COMPS_ObjMRTreeData*)it->data)->key) +\n                                1));\n                memcpy(pair->key, ((COMPS_ObjMRTreeData*)it->data)->key,\n                       sizeof(char)*(strlen(((COMPS_ObjMRTreeData*)it->data)->key)+1));\n            }\n            /* current node has data */\n            if (((COMPS_ObjMRTreeData*)it->data)->data->first != NULL) {\n                for (it2 = ((COMPS_ObjMRTreeData*)it->data)->data->first;\n                     it2 != NULL; it2 = it2->next) {\n                    comps_objmrtree_set(rt1, pair->key, it2->comps_obj);\n                }\n\n                if (((COMPS_ObjMRTreeData*)it->data)->subnodes->first) {\n                    comps_hslist_append(tmplist, pair, 0);\n                } else {\n                    free(pair->key);\n                    free(pair);\n                }\n            /* current node hasn't data */\n            } else {\n                if (((COMPS_ObjMRTreeData*)it->data)->subnodes->first) {\n                    comps_hslist_append(tmplist, pair, 0);\n                } else {\n                    free(pair->key);\n                    free(pair);\n                }\n            }\n        }\n        free(parent_pair->key);\n        free(parent_pair);\n    }\n    comps_hslist_destroy(&tmplist);\n}\n\nvoid comps_objmrtree_set_x(COMPS_ObjMRTree *rt, char *key, COMPS_Object *data) {\n    __comps_objmrtree_set(rt, key, strlen(key), data);\n}\nvoid comps_objmrtree_set(COMPS_ObjMRTree *rt, char *key, COMPS_Object *data) {\n    __comps_objmrtree_set(rt, key, strlen(key), comps_object_incref(data));\n}\n\nvoid __comps_objmrtree_set(COMPS_ObjMRTree *rt, char *key,\n                           size_t len, COMPS_Object *ndata) {\n    static COMPS_HSListItem *it;\n    COMPS_HSList *subnodes;\n    COMPS_ObjMRTreeData *rtd;\n    static COMPS_ObjMRTreeData *rtdata;\n\n    size_t _len, offset=0;\n    unsigned x, found = 0;\n    char ended;//, tmpch;\n\n    if (rt->subnodes == NULL)\n        return;\n\n    subnodes = rt->subnodes;\n    while (offset != len)\n    {\n        found = 0;\n        for (it = subnodes->first; it != NULL; it = it->next) {\n            if (((COMPS_ObjMRTreeData*)it->data)->key[0] == key[offset]) {\n                found = 1;\n                break;\n            }\n        }\n        if (!found) { // not found in subnodes; create new subnode\n            rtd = comps_objmrtree_data_create(key+offset, ndata);\n            comps_hslist_append(subnodes, rtd, 0);\n            rt->len++;\n            return;\n        } else {\n            rtdata = (COMPS_ObjMRTreeData*)it->data;\n            ended = 0;\n            for (x=1; ;x++) {\n                if (rtdata->key[x] == 0) ended += 1;\n                if (x == len - offset) ended += 2;\n                if (ended != 0) break;\n                if (key[offset+x] != rtdata->key[x]) break;\n            }\n            if (ended == 3) { //keys equals; append new data\n                comps_objlist_append_x(rtdata->data, ndata);\n                rt->len++;\n                return;\n            } else if (ended == 2) { //global key ends first; make global leaf\n                comps_hslist_remove(subnodes, it);\n                it->next = NULL;\n                rtd = comps_objmrtree_data_create(key+offset, ndata);\n                comps_hslist_append(subnodes, rtd, 0);\n                ((COMPS_ObjMRTreeData*)subnodes->last->data)->subnodes->last = it;\n                ((COMPS_ObjMRTreeData*)subnodes->last->data)->subnodes->first = it;\n                _len = strlen(key + offset);\n                memmove(rtdata->key,rtdata->key + _len,\n                                    strlen(rtdata->key) - _len);\n                rtdata->key[strlen(rtdata->key) - _len] = 0;\n                rtdata->key = realloc(rtdata->key,\n                                      sizeof(char)* (strlen(rtdata->key)+1));\n                rt->len++;\n                return;\n            } else if (ended == 1) { //local key ends first; go deeper\n                subnodes = rtdata->subnodes;\n                offset += x;\n            } else { /* keys differ */\n                COMPS_ObjList *tmpdata = rtdata->data;\n                COMPS_HSList *tmphslist = rtdata->subnodes;\n\n                rtdata->subnodes = comps_hslist_create();\n                comps_hslist_init(rtdata->subnodes, NULL, NULL,\n                                  &comps_objmrtree_data_destroy_v);\n                int cmpret = strcmp(key+offset+x, rtdata->key+x);\n                rtdata->data = COMPS_OBJECT_CREATE(COMPS_ObjList, NULL);\n\n                if (cmpret > 0) {\n                    rtd = comps_objmrtree_data_create(rtdata->key+x,\n                                                      (COMPS_Object*)tmpdata);\n                    comps_hslist_destroy(&rtd->subnodes);\n                    rtd->subnodes = tmphslist;\n\n                    comps_hslist_append(rtdata->subnodes, rtd, 0);\n                    rtd = comps_objmrtree_data_create(key+offset+x,\n                                                     (COMPS_Object*)ndata);\n                    comps_hslist_append(rtdata->subnodes, rtd, 0);\n\n                } else {\n                    rtd = comps_objmrtree_data_create(key+offset+x,\n                                                     (COMPS_Object*)ndata);\n                    comps_hslist_append(rtdata->subnodes, rtd, 0);\n                    rtd = comps_objmrtree_data_create(rtdata->key+x,\n                                                     (COMPS_Object*)tmpdata);\n                    comps_hslist_destroy(&rtd->subnodes);\n                    rtd->subnodes = tmphslist;\n                    comps_hslist_append(rtdata->subnodes, rtd, 0);\n                }\n                rtdata->key = realloc(rtdata->key, sizeof(char)*(x+1));\n                rtdata->key[x] = 0;\n                rt->len++;\n                return;\n            }\n        }\n    }\n}\n\nvoid comps_objmrtree_set_n(COMPS_ObjMRTree *rt, char *key,\n                        size_t len, void *ndata) {\n    __comps_objmrtree_set(rt, key, len, ndata);\n}\n\nCOMPS_ObjList * comps_objmrtree_get(COMPS_ObjMRTree * rt, const char * key) {\n    COMPS_HSList * subnodes;\n    COMPS_HSListItem * it = NULL;\n    COMPS_ObjMRTreeData * rtdata;\n    unsigned int offset, len, x;\n    char found, ended;\n\n    len = strlen(key);\n    offset = 0;\n    subnodes = rt->subnodes;\n    while (offset != len) {\n        found = 0;\n        for (it = subnodes->first; it != NULL; it=it->next) {\n            if (((COMPS_ObjMRTreeData*)it->data)->key[0] == key[offset]) {\n                found = 1;\n                break;\n            }\n        }\n        if (!found)\n            return NULL;\n        rtdata = (COMPS_ObjMRTreeData*)it->data;\n\n        for (x=1; ;x++) {\n            ended=0;\n            if (rtdata->key[x] == 0) ended += 1;\n            if (x == len - offset) ended += 2;\n            if (ended != 0) break;\n            if (key[offset+x] != rtdata->key[x]) break;\n        }\n        if (ended == 3) return (COMPS_ObjList*)\n                               comps_object_incref((COMPS_Object*)rtdata->data);\n        else if (ended == 1) offset+=x;\n        else return NULL;\n        subnodes = ((COMPS_ObjMRTreeData*)it->data)->subnodes;\n    }\n    if (it)\n        return ((COMPS_ObjMRTreeData*)it->data)->data;\n    else return NULL;\n}\n\nvoid comps_objmrtree_unset(COMPS_ObjMRTree * rt, const char * key) {\n    COMPS_HSList * subnodes;\n    COMPS_HSListItem * it;\n    COMPS_ObjMRTreeData * rtdata;\n    unsigned int offset, len, x;\n    char found, ended;\n    COMPS_HSList * path;\n\n    struct Relation {\n        COMPS_HSList * parent_nodes;\n        COMPS_HSListItem * child_it;\n    } *relation;\n\n    path = comps_hslist_create();\n    comps_hslist_init(path, NULL, NULL, &free);\n\n    len = strlen(key);\n    offset = 0;\n    subnodes = rt->subnodes;\n    while (offset != len) {\n        found = 0;\n        for (it = subnodes->first; it != NULL; it=it->next) {\n            if (((COMPS_ObjMRTreeData*)it->data)->key[0] == key[offset]) {\n                found = 1;\n                break;\n            }\n        }\n        if (!found) {\n            comps_hslist_destroy(&path);\n            return;\n        }\n        rtdata = (COMPS_ObjMRTreeData*)it->data;\n\n        for (x=1; ;x++) {\n            ended=0;\n            if (rtdata->key[x] == 0) ended += 1;\n            if (x == len - offset) ended += 2;\n            if (ended != 0) break;\n            if (key[offset+x] != rtdata->key[x]) break;\n        }\n        if (ended == 3) {\n            /* remove node from tree only if there's no descendant*/\n            if (rtdata->subnodes->last == NULL) {\n                comps_hslist_remove(subnodes, it);\n                rt->len -= rtdata->data->len;\n                comps_objmrtree_data_destroy(rtdata);\n                free(it);\n            }\n            else {\n                rt->len -= rtdata->data->len;\n                comps_objlist_clear(rtdata->data);\n                rtdata->is_leaf = 0;\n            }\n\n            if (path->last == NULL) {\n                comps_hslist_destroy(&path);\n                return;\n            }\n            rtdata = (COMPS_ObjMRTreeData*)\n                     ((struct Relation*)path->last->data)->child_it->data;\n\n            /*remove all predecessor of deleted node (recursive) with no childs*/\n            while (rtdata->subnodes->last == NULL) {\n                //printf(\"removing '%s'\\n\", rtdata->key);\n                comps_objmrtree_data_destroy(rtdata);\n                comps_hslist_remove(\n                            ((struct Relation*)path->last->data)->parent_nodes,\n                            ((struct Relation*)path->last->data)->child_it);\n                free(((struct Relation*)path->last->data)->child_it);\n                it = path->last;\n                comps_hslist_remove(path, path->last);\n                free(it);\n                rtdata = (COMPS_ObjMRTreeData*)\n                         ((struct Relation*)path->last->data)->child_it->data;\n            }\n            comps_hslist_destroy(&path);\n            return;\n        }\n        else if (ended == 1) offset+=x;\n        else {\n            comps_hslist_destroy(&path);\n            return;\n        }\n        if ((relation = malloc(sizeof(struct Relation))) == NULL) {\n            comps_hslist_destroy(&path);\n            return;\n        }\n        subnodes = ((COMPS_ObjMRTreeData*)it->data)->subnodes;\n        relation->parent_nodes = subnodes;\n        relation->child_it = it;\n        comps_hslist_append(path, (void*)relation, 0);\n    }\n    comps_hslist_destroy(&path);\n    return;\n}\n\ninline void comps_objmrtree_pair_destroy_v(void * pair) {\n    free(((COMPS_ObjMRTreePair *)pair)->key);\n    free(pair);\n}\n\ninline COMPS_HSList* __comps_objmrtree_all(COMPS_ObjMRTree * rt, char keyvalpair) {\n    COMPS_HSList *to_process, *ret;\n    COMPS_HSListItem *hsit, *oldit;\n    size_t x;\n    struct Pair {\n        char *key;\n        void *data;\n        COMPS_HSList *subnodes;\n    } *pair, *current_pair=NULL;//, *oldpair=NULL;\n    COMPS_ObjMRTreePair *rtpair;\n\n    to_process = comps_hslist_create();\n    comps_hslist_init(to_process, NULL, NULL, &free);\n\n    ret = comps_hslist_create();\n    if (keyvalpair == 0)\n        comps_hslist_init(ret, NULL, NULL, &free);\n    else if (keyvalpair == 1)\n        comps_hslist_init(ret, NULL, NULL, NULL);\n    else\n        comps_hslist_init(ret, NULL, NULL, &comps_objmrtree_pair_destroy_v);\n\n    for (hsit = rt->subnodes->first; hsit != NULL; hsit = hsit->next) {\n        pair = malloc(sizeof(struct Pair));\n        pair->key = __comps_strcpy(((COMPS_ObjMRTreeData*)hsit->data)->key);\n        pair->data = ((COMPS_ObjMRTreeData*)hsit->data)->data;\n        pair->subnodes = ((COMPS_ObjMRTreeData*)hsit->data)->subnodes;\n        comps_hslist_append(to_process, pair, 0);\n    }\n    while (to_process->first) {\n        //oldpair = current_pair;\n        current_pair = to_process->first->data;\n        oldit = to_process->first;\n        comps_hslist_remove(to_process, to_process->first);\n        if (current_pair->data) {\n            if (keyvalpair == 0) {\n                comps_hslist_append(ret, __comps_strcpy(current_pair->key), 0);\n            } else if (keyvalpair == 1) {\n                comps_hslist_append(ret, current_pair->data, 0);\n            } else {\n                rtpair = malloc(sizeof(COMPS_ObjMRTreePair));\n                rtpair->key = __comps_strcpy(current_pair->key);\n                rtpair->data = current_pair->data;\n                comps_hslist_append(ret, rtpair, 0);\n            }\n        }\n        for (hsit = current_pair->subnodes->first, x = 0;\n             hsit != NULL; hsit = hsit->next, x++) {\n            pair = malloc(sizeof(struct Pair));\n            pair->key = __comps_strcat(current_pair->key,\n                                       ((COMPS_ObjMRTreeData*)hsit->data)->key);\n            pair->data = ((COMPS_ObjMRTreeData*)hsit->data)->data;\n            pair->subnodes = ((COMPS_ObjMRTreeData*)hsit->data)->subnodes;\n            comps_hslist_insert_at(to_process, x, pair, 0);\n        }\n        free(current_pair->key);\n        free(current_pair);\n        free(oldit);\n    }\n\n    comps_hslist_destroy(&to_process);\n    return ret;\n}\n\nCOMPS_HSList* comps_objmrtree_keys(COMPS_ObjMRTree * rt) {\n    return __comps_objmrtree_all(rt, 0);\n}\n\nCOMPS_HSList* comps_objmrtree_values(COMPS_ObjMRTree * rt) {\n    return __comps_objmrtree_all(rt, 1);\n}\n\nCOMPS_HSList* comps_objmrtree_pairs(COMPS_ObjMRTree * rt) {\n    return __comps_objmrtree_all(rt, 2);\n}\n\nvoid comps_objmrtree_clear(COMPS_ObjMRTree * rt) {\n    COMPS_HSListItem *it, *oldit;\n    if (rt == NULL) return;\n    if (rt->subnodes == NULL) return;\n    oldit = rt->subnodes->first;\n    it = (oldit)?oldit->next:NULL;\n    for (;it != NULL; it=it->next) {\n        if (rt->subnodes->data_destructor != NULL)\n            rt->subnodes->data_destructor(oldit->data);\n        free(oldit);\n        oldit = it;\n    }\n    if (oldit) {\n        if (rt->subnodes->data_destructor != NULL)\n            rt->subnodes->data_destructor(oldit->data);\n        free(oldit);\n    }\n}\n\nchar comps_objmrtree_paircmp(void *obj1, void *obj2) {\n    if (strcmp(((COMPS_ObjMRTreePair*)obj1)->key,\n               ((COMPS_ObjMRTreePair*)obj2)->key) != 0)\n        return 0;\n    return comps_object_cmp((COMPS_Object*)((COMPS_ObjMRTreePair*)obj1)->data,\n                            (COMPS_Object*)((COMPS_ObjMRTreePair*)obj1)->data);\n}\n\nsigned char comps_objmrtree_cmp(COMPS_ObjMRTree *ort1, COMPS_ObjMRTree *ort2) {\n    COMPS_HSList *values1, *values2;\n    COMPS_HSListItem *it;\n    COMPS_Set *set1, *set2;\n    signed char ret;\n    values1 = comps_objmrtree_pairs(ort1);\n    values2 = comps_objmrtree_pairs(ort2);\n    set1 = comps_set_create();\n    comps_set_init(set1, NULL, NULL, NULL, &comps_objmrtree_paircmp);\n    set2 = comps_set_create();\n    comps_set_init(set2, NULL, NULL, NULL, &comps_objmrtree_paircmp);\n    for (it = values1->first; it != NULL; it = it->next) {\n        comps_set_add(set1, it->data);\n    }\n    for (it = values2->first; it != NULL; it = it->next) {\n        comps_set_add(set2, it->data);\n    }\n\n    ret = comps_set_cmp(set1, set2);\n    comps_set_destroy(&set1);\n    comps_set_destroy(&set2);\n    //printf(\"objmrtree cmp %d\\n\", !ret);\n\n    comps_hslist_destroy(&values1);\n    comps_hslist_destroy(&values2);\n    return !ret;\n}\nCOMPS_CMP_u(objmrtree, COMPS_ObjMRTree)\n\nCOMPS_ObjectInfo COMPS_ObjMRTree_ObjInfo = {\n    .obj_size = sizeof(COMPS_ObjMRTree),\n    .constructor = &comps_objmrtree_create_u,\n    .destructor = &comps_objmrtree_destroy_u,\n    .copy = &comps_objmrtree_copy_u,\n    .obj_cmp = &comps_objmrtree_cmp_u\n};\n", "/* libcomps - C alternative to yum.comps library\n * Copyright (C) 2013 Jindrich Luza\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to  Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,\n * USA\n */\n\n#include \"comps_objradix.h\"\n#include \"comps_set.h\"\n#include <stdio.h>\n\nvoid comps_objrtree_data_destroy(COMPS_ObjRTreeData * rtd) {\n    free(rtd->key);\n    comps_object_destroy(rtd->data);\n    comps_hslist_destroy(&rtd->subnodes);\n    free(rtd);\n}\n\ninline void comps_objrtree_data_destroy_v(void * rtd) {\n    comps_objrtree_data_destroy((COMPS_ObjRTreeData*)rtd);\n}\n\ninline COMPS_ObjRTreeData * __comps_objrtree_data_create(char *key,\n                                                   size_t keylen,\n                                                   COMPS_Object *data){\n    COMPS_ObjRTreeData * rtd;\n    if ((rtd = malloc(sizeof(*rtd))) == NULL)\n        return NULL;\n    if ((rtd->key = malloc(sizeof(char) * (keylen+1))) == NULL) {\n        free(rtd);\n        return NULL;\n    }\n    memcpy(rtd->key, key, sizeof(char)*keylen);\n    rtd->key[keylen] = 0;\n    rtd->data = data;\n    if (data != NULL) {\n        rtd->is_leaf = 1;\n    }\n    rtd->subnodes = comps_hslist_create();\n    comps_hslist_init(rtd->subnodes, NULL, NULL, &comps_objrtree_data_destroy_v);\n    return rtd;\n}\n\nCOMPS_ObjRTreeData * comps_objrtree_data_create(char *key, COMPS_Object *data) {\n    COMPS_ObjRTreeData * rtd;\n    rtd = __comps_objrtree_data_create(key, strlen(key), data);\n    return rtd;\n}\n\nCOMPS_ObjRTreeData * comps_objrtree_data_create_n(char *key, size_t keylen,\n                                                  COMPS_Object *data) {\n    COMPS_ObjRTreeData * rtd;\n    rtd = __comps_objrtree_data_create(key, keylen, data);\n    return rtd;\n}\n\nstatic void comps_objrtree_create(COMPS_ObjRTree *rtree, COMPS_Object **args) {\n    (void)args;\n    rtree->subnodes = comps_hslist_create();\n    comps_hslist_init(rtree->subnodes, NULL, NULL, &comps_objrtree_data_destroy_v);\n    if (rtree->subnodes == NULL) {\n        COMPS_OBJECT_DESTROY(rtree);\n        return;\n    }\n    rtree->len = 0;\n}\nvoid comps_objrtree_create_u(COMPS_Object * obj, COMPS_Object **args) {\n    (void)args;\n    comps_objrtree_create((COMPS_ObjRTree*)obj, NULL);\n}\n\nstatic void comps_objrtree_destroy(COMPS_ObjRTree * rt) {\n    comps_hslist_destroy(&(rt->subnodes));\n}\nvoid comps_objrtree_destroy_u(COMPS_Object *obj) {\n    comps_objrtree_destroy((COMPS_ObjRTree*)obj);\n}\n\nCOMPS_ObjRTree * comps_objrtree_clone(COMPS_ObjRTree *rt) {\n\n    COMPS_HSList *to_clone, *tmplist, *new_subnodes;\n    COMPS_ObjRTree *ret;\n    COMPS_HSListItem *it, *it2;\n    COMPS_ObjRTreeData *rtdata;\n    COMPS_Object *new_data;\n\n    if (!rt) return NULL;\n\n    to_clone = comps_hslist_create();\n    comps_hslist_init(to_clone, NULL, NULL, NULL);\n    ret = COMPS_OBJECT_CREATE(COMPS_ObjRTree, NULL);\n    ret->len = rt->len;\n\n    for (it = rt->subnodes->first; it != NULL; it = it->next) {\n        rtdata = comps_objrtree_data_create(\n                                    ((COMPS_ObjRTreeData*)it->data)->key, NULL);\n        if (((COMPS_ObjRTreeData*)it->data)->data != NULL)\n            new_data = comps_object_copy(((COMPS_ObjRTreeData*)it->data)->data);\n        else\n            new_data = NULL;\n        comps_hslist_destroy(&rtdata->subnodes);\n        rtdata->subnodes = ((COMPS_ObjRTreeData*)it->data)->subnodes;\n        rtdata->data = new_data;\n        comps_hslist_append(ret->subnodes, rtdata, 0);\n        comps_hslist_append(to_clone, rtdata, 0);\n    }\n\n    while (to_clone->first) {\n        it2 = to_clone->first;\n        tmplist = ((COMPS_ObjRTreeData*)it2->data)->subnodes;\n        comps_hslist_remove(to_clone, to_clone->first);\n\n        new_subnodes = comps_hslist_create();\n        comps_hslist_init(new_subnodes, NULL, NULL, &comps_objrtree_data_destroy_v);\n        for (it = tmplist->first; it != NULL; it = it->next) {\n            rtdata = comps_objrtree_data_create(\n                                      ((COMPS_ObjRTreeData*)it->data)->key, NULL);\n            if (((COMPS_ObjRTreeData*)it->data)->data != NULL)\n                new_data = comps_object_copy(((COMPS_ObjRTreeData*)it->data)->data);\n            else\n                new_data = NULL;\n            comps_hslist_destroy(&rtdata->subnodes);\n            rtdata->subnodes = ((COMPS_ObjRTreeData*)it->data)->subnodes;\n            rtdata->data = new_data;\n            comps_hslist_append(new_subnodes, rtdata, 0);\n            comps_hslist_append(to_clone, rtdata, 0);\n        }\n        ((COMPS_ObjRTreeData*)it2->data)->subnodes = new_subnodes;\n        free(it2);\n    }\n    comps_hslist_destroy(&to_clone);\n    return ret;\n}\nvoid comps_objrtree_copy(COMPS_ObjRTree *rt1, COMPS_ObjRTree *rt2){\n    COMPS_HSList *to_clone, *tmplist, *new_subnodes;\n    COMPS_HSListItem *it, *it2;\n    COMPS_ObjRTreeData *rtdata;\n    COMPS_Object *new_data;\n\n    rt1->subnodes = comps_hslist_create();\n    comps_hslist_init(rt1->subnodes, NULL, NULL, &comps_objrtree_data_destroy_v);\n    if (rt1->subnodes == NULL) {\n        COMPS_OBJECT_DESTROY(rt1);\n        return;\n    }\n    rt1->len = 0;\n\n    to_clone = comps_hslist_create();\n    comps_hslist_init(to_clone, NULL, NULL, NULL);\n\n    for (it = rt2->subnodes->first; it != NULL; it = it->next) {\n        rtdata = comps_objrtree_data_create(\n                                    ((COMPS_ObjRTreeData*)it->data)->key, NULL);\n        if (((COMPS_ObjRTreeData*)it->data)->data != NULL)\n            new_data = comps_object_copy(((COMPS_ObjRTreeData*)it->data)->data);\n        else\n            new_data = NULL;\n        comps_hslist_destroy(&rtdata->subnodes);\n        rtdata->subnodes = ((COMPS_ObjRTreeData*)it->data)->subnodes;\n        rtdata->data = new_data;\n        comps_hslist_append(rt1->subnodes, rtdata, 0);\n        comps_hslist_append(to_clone, rtdata, 0);\n    }\n\n    while (to_clone->first) {\n        it2 = to_clone->first;\n        tmplist = ((COMPS_ObjRTreeData*)it2->data)->subnodes;\n        comps_hslist_remove(to_clone, to_clone->first);\n\n        new_subnodes = comps_hslist_create();\n        comps_hslist_init(new_subnodes, NULL, NULL, &comps_objrtree_data_destroy_v);\n        for (it = tmplist->first; it != NULL; it = it->next) {\n            rtdata = comps_objrtree_data_create(\n                                      ((COMPS_ObjRTreeData*)it->data)->key, NULL);\n            if (((COMPS_ObjRTreeData*)it->data)->data != NULL)\n                new_data = comps_object_copy(((COMPS_ObjRTreeData*)it->data)->data);\n            else\n                new_data = NULL;\n            comps_hslist_destroy(&rtdata->subnodes);\n            rtdata->subnodes = ((COMPS_ObjRTreeData*)it->data)->subnodes;\n            rtdata->data = new_data;\n            comps_hslist_append(new_subnodes, rtdata, 0);\n            comps_hslist_append(to_clone, rtdata, 0);\n        }\n        ((COMPS_ObjRTreeData*)it2->data)->subnodes = new_subnodes;\n        free(it2);\n    }\n    comps_hslist_destroy(&to_clone);\n\n}\nCOMPS_COPY_u(objrtree, COMPS_ObjRTree) /*comps_utils.h macro*/\n\nvoid comps_objrtree_copy_shallow(COMPS_ObjRTree *rt1, COMPS_ObjRTree *rt2){\n    COMPS_HSList *to_clone, *tmplist, *new_subnodes;\n    COMPS_HSListItem *it, *it2;\n    COMPS_ObjRTreeData *rtdata;\n    COMPS_Object *new_data;\n\n    rt1->subnodes = comps_hslist_create();\n    comps_hslist_init(rt1->subnodes, NULL, NULL, &comps_objrtree_data_destroy_v);\n    if (rt1->subnodes == NULL) {\n        COMPS_OBJECT_DESTROY(rt1);\n        return;\n    }\n    rt1->len = 0;\n\n    to_clone = comps_hslist_create();\n    comps_hslist_init(to_clone, NULL, NULL, NULL);\n\n    for (it = rt2->subnodes->first; it != NULL; it = it->next) {\n        rtdata = comps_objrtree_data_create(\n                                    ((COMPS_ObjRTreeData*)it->data)->key, NULL);\n        if (((COMPS_ObjRTreeData*)it->data)->data != NULL)\n            new_data = COMPS_OBJECT_INCREF(((COMPS_ObjRTreeData*)it->data)->data);\n        else\n            new_data = NULL;\n        comps_hslist_destroy(&rtdata->subnodes);\n        rtdata->subnodes = ((COMPS_ObjRTreeData*)it->data)->subnodes;\n        rtdata->data = new_data;\n        comps_hslist_append(rt1->subnodes, rtdata, 0);\n        comps_hslist_append(to_clone, rtdata, 0);\n    }\n\n    while (to_clone->first) {\n        it2 = to_clone->first;\n        tmplist = ((COMPS_ObjRTreeData*)it2->data)->subnodes;\n        comps_hslist_remove(to_clone, to_clone->first);\n\n        new_subnodes = comps_hslist_create();\n        comps_hslist_init(new_subnodes, NULL, NULL, &comps_objrtree_data_destroy_v);\n        for (it = tmplist->first; it != NULL; it = it->next) {\n            rtdata = comps_objrtree_data_create(\n                                      ((COMPS_ObjRTreeData*)it->data)->key, NULL);\n            if (((COMPS_ObjRTreeData*)it->data)->data != NULL)\n                new_data = comps_object_incref(((COMPS_ObjRTreeData*)it->data)->data);\n            else\n                new_data = NULL;\n            comps_hslist_destroy(&rtdata->subnodes);\n            rtdata->subnodes = ((COMPS_ObjRTreeData*)it->data)->subnodes;\n            rtdata->data = new_data;\n            comps_hslist_append(new_subnodes, rtdata, 0);\n            comps_hslist_append(to_clone, rtdata, 0);\n        }\n        ((COMPS_ObjRTreeData*)it2->data)->subnodes = new_subnodes;\n        free(it2);\n    }\n    comps_hslist_destroy(&to_clone);\n}\n\nvoid comps_objrtree_values_walk(COMPS_ObjRTree * rt, void* udata,\n                              void (*walk_f)(void*, COMPS_Object*)) {\n    COMPS_HSList *tmplist, *tmp_subnodes;\n    COMPS_HSListItem *it;\n    tmplist = comps_hslist_create();\n    comps_hslist_init(tmplist, NULL, NULL, NULL);\n    comps_hslist_append(tmplist, rt->subnodes, 0);\n    while (tmplist->first != NULL) {\n        it = tmplist->first;\n        comps_hslist_remove(tmplist, tmplist->first);\n        tmp_subnodes = (COMPS_HSList*)it->data;\n        for (it = tmp_subnodes->first; it != NULL; it=it->next) {\n            if (((COMPS_ObjRTreeData*)it->data)->subnodes->first) {\n                comps_hslist_append(tmplist,\n                                    ((COMPS_ObjRTreeData*)it->data)->subnodes, 0);\n            }\n            if (((COMPS_ObjRTreeData*)it->data)->data != NULL) {\n               walk_f(udata, ((COMPS_ObjRTreeData*)it->data)->data);\n            }\n        }\n    }\n    comps_hslist_destroy(&tmplist);\n}\n\nchar comps_objrtree_paircmp(void *obj1, void *obj2) {\n    //printf(\"comparing %s with %s\\n\", ((COMPS_ObjRTreePair*)obj1)->key,\n    //                               ((COMPS_ObjRTreePair*)obj2)->key);\n    if (strcmp(((COMPS_ObjRTreePair*)obj1)->key,\n               ((COMPS_ObjRTreePair*)obj2)->key) != 0)\n        return 0;\n    return comps_object_cmp(((COMPS_ObjRTreePair*)obj1)->data,\n                            ((COMPS_ObjRTreePair*)obj2)->data);\n}\n\n\nsigned char comps_objrtree_cmp(COMPS_ObjRTree *ort1, COMPS_ObjRTree *ort2) {\n    COMPS_HSList *values1, *values2;\n    COMPS_HSListItem *it;\n    COMPS_Set *set1, *set2;\n    signed char ret;\n    values1 = comps_objrtree_pairs(ort1);\n    values2 = comps_objrtree_pairs(ort2);\n    set1 = comps_set_create();\n    comps_set_init(set1, NULL, NULL, NULL, &comps_objrtree_paircmp);\n    set2 = comps_set_create();\n    comps_set_init(set2, NULL, NULL, NULL, &comps_objrtree_paircmp);\n    for (it = values1->first; it != NULL; it = it->next) {\n        comps_set_add(set1, it->data);\n    }\n    for (it = values2->first; it != NULL; it = it->next) {\n        comps_set_add(set2, it->data);\n    }\n\n    ret = comps_set_cmp(set1, set2);\n    comps_set_destroy(&set1);\n    comps_set_destroy(&set2);\n    //printf(\"objrtree cmp %d\\n\", !ret);\n    \n    //char *str;\n    /*for (it = values1->first; it != NULL; it = it->next) {\n        str = comps_object_tostr(((COMPS_ObjRTreePair*)it->data)->data);\n        printf(\"dict item %s=%s\\n\", ((COMPS_ObjRTreePair*)it->data)->key, str);\n        free(str);\n    }\n    printf(\"----------\\n\");\n    for (it = values2->first; it != NULL; it = it->next) {\n        str = comps_object_tostr(((COMPS_ObjRTreePair*)it->data)->data);\n        printf(\"dict item %s=%s\\n\", ((COMPS_ObjRTreePair*)it->data)->key, str);\n        free(str);\n    }\n    printf(\"cmp objrtree ret:%d\\n\", ret);*/\n    comps_hslist_destroy(&values1);\n    comps_hslist_destroy(&values2);\n    return ret==0;\n}\nCOMPS_CMP_u(objrtree, COMPS_ObjRTree)\n\nvoid __comps_objrtree_set(COMPS_ObjRTree *rt, char *key, size_t len,\n                          COMPS_Object *ndata) {\n\n    COMPS_HSListItem *it, *lesser;\n    COMPS_HSList *subnodes;\n    COMPS_ObjRTreeData *rtd;\n    static COMPS_ObjRTreeData *rtdata;\n\n    size_t _len, offset=0;\n    unsigned x, found = 0;\n    char ended;\n\n    //len = strlen(key);\n\n    if (rt->subnodes == NULL)\n        return;\n\n    subnodes = rt->subnodes;\n    while (offset != len)\n    {\n        found = 0;\n        lesser = NULL;\n        for (it = subnodes->first; it != NULL; it=it->next) {\n            if (((COMPS_ObjRTreeData*)it->data)->key[0] == key[offset]) {\n                found = 1;\n                break;\n            } else if (((COMPS_ObjRTreeData*)it->data)->key[0] < key[offset]) {\n                lesser = it;\n            }\n        }\n        if (!found) { // not found in subnodes; create new subnode\n            rtd = comps_objrtree_data_create_n(key+offset, len-offset, ndata);\n            if (!lesser) {\n                comps_hslist_prepend(subnodes, rtd, 0);\n            } else {\n                comps_hslist_insert_after(subnodes, lesser, rtd, 0);\n            }\n            rt->len++;\n            return;\n        } else {\n            rtdata = (COMPS_ObjRTreeData*)it->data;\n            ended = 0;\n            for (x=1; ;x++) {\n                if (rtdata->key[x] == 0) ended += 1;\n                if (x == len - offset) ended += 2;\n                if (ended != 0) break;\n                if (key[offset+x] != rtdata->key[x]) break;\n            }\n            if (ended == 3) { //keys equals; data replacement\n                comps_object_destroy(rtdata->data);\n                rtdata->data = ndata;\n                return;\n            } else if (ended == 2) { //global key ends first; make global leaf\n                //printf(\"ended2\\n\");\n                comps_hslist_remove(subnodes, it);\n                it->next = NULL;\n                rtd = comps_objrtree_data_create_n(key+offset, len-offset, ndata);\n                comps_hslist_append(subnodes, rtd, 0);\n                ((COMPS_ObjRTreeData*)subnodes->last->data)->subnodes->last = it;\n                ((COMPS_ObjRTreeData*)subnodes->last->data)->subnodes->first = it;\n                _len = len - offset;\n\n                memmove(rtdata->key,rtdata->key+_len,\n                        strlen(rtdata->key) - _len);\n                rtdata->key[strlen(rtdata->key) - _len] = 0;\n                rtdata->key = realloc(rtdata->key,\n                                      sizeof(char)* (strlen(rtdata->key)+1));\n                rt->len++;\n                return;\n            } else if (ended == 1) { //local key ends first; go deeper\n                subnodes = rtdata->subnodes;\n                offset += x;\n            } else {\n                COMPS_Object *tmpdata = rtdata->data;\n                COMPS_HSList *tmphslist = rtdata->subnodes;\n                //tmpch = rtdata->key[x];             // split mutual key\n                rtdata->subnodes = comps_hslist_create();\n                comps_hslist_init(rtdata->subnodes, NULL, NULL,\n                                  &comps_objrtree_data_destroy_v);\n                int cmpret = strcmp(key+offset+x, rtdata->key+x);\n                rtdata->data = NULL;\n\n                if (cmpret > 0) {\n                    rtd = comps_objrtree_data_create(rtdata->key+x, tmpdata);\n                    comps_hslist_destroy(&rtd->subnodes);\n                    rtd->subnodes = tmphslist;\n\n                    comps_hslist_append(rtdata->subnodes,rtd, 0);\n                    rtd = comps_objrtree_data_create(key+offset+x, ndata);\n                    comps_hslist_append(rtdata->subnodes, rtd, 0);\n\n                } else {\n                    rtd = comps_objrtree_data_create(key+offset+x, ndata);\n                    comps_hslist_append(rtdata->subnodes, rtd, 0);\n                    rtd = comps_objrtree_data_create(rtdata->key+x, tmpdata);\n                    comps_hslist_destroy(&rtd->subnodes);\n                    rtd->subnodes = tmphslist;\n                    comps_hslist_append(rtdata->subnodes, rtd, 0);\n                }\n                rtdata->key = realloc(rtdata->key, sizeof(char)*(x+1));\n                rtdata->key[x] = 0;\n                rt->len++;\n                return;\n            }\n        }\n    }\n}\n\nvoid comps_objrtree_set_x(COMPS_ObjRTree *rt, char *key, COMPS_Object *data) {\n    __comps_objrtree_set(rt, key, strlen(key), data);\n}\nvoid comps_objrtree_set(COMPS_ObjRTree *rt, char *key, COMPS_Object *data) {\n    __comps_objrtree_set(rt, key, strlen(key), comps_object_incref(data));\n}\nvoid comps_objrtree_set_n(COMPS_ObjRTree *rt, char *key, size_t len,\n                          COMPS_Object *data) {\n    __comps_objrtree_set(rt, key, len, data);\n}\nvoid comps_objrtree_set_nx(COMPS_ObjRTree *rt, char *key, size_t len,\n                           COMPS_Object *data) {\n    __comps_objrtree_set(rt, key, len, comps_object_incref(data));\n}\n\nCOMPS_Object* __comps_objrtree_get(COMPS_ObjRTree * rt, const char * key) {\n    COMPS_HSList * subnodes;\n    COMPS_HSListItem * it = NULL;\n    COMPS_ObjRTreeData * rtdata;\n    unsigned int offset, len, x;\n    char found, ended;\n\n    len = strlen(key);\n    offset = 0;\n    subnodes = rt->subnodes;\n\n    while (offset != len) {\n        found = 0;\n        for (it = subnodes->first; it != NULL; it=it->next) {\n            if (((COMPS_ObjRTreeData*)it->data)->key[0] == key[offset]) {\n                found = 1;\n                break;\n            }\n        }\n        if (!found) {\n            return NULL;\n        }\n        rtdata = (COMPS_ObjRTreeData*)it->data;\n\n        for (x=1; ;x++) {\n            ended=0;\n            if (x == strlen(rtdata->key)) ended += 1;\n            if (x == len-offset) ended += 2;\n            if (ended != 0) break;\n            if (key[offset+x] != rtdata->key[x]) break;\n        }\n        if (ended == 3) {\n            return rtdata->data;\n        }\n        else if (ended == 1) offset+=x;\n        else {\n            return NULL;\n        }\n        subnodes = ((COMPS_ObjRTreeData*)it->data)->subnodes;\n    }\n    if (it != NULL) {\n        return ((COMPS_ObjRTreeData*)it->data)->data;\n    }\n    else {\n        return NULL;\n    }\n}\nCOMPS_Object* comps_objrtree_get(COMPS_ObjRTree * rt, const char * key) {\n    return comps_object_incref(__comps_objrtree_get(rt, key));\n}\nCOMPS_Object* comps_objrtree_get_x(COMPS_ObjRTree * rt, const char * key) {\n    return __comps_objrtree_get(rt, key);\n}\n\nvoid comps_objrtree_unset(COMPS_ObjRTree * rt, const char * key) {\n    COMPS_HSList * subnodes;\n    COMPS_HSListItem * it;\n    COMPS_ObjRTreeData * rtdata;\n    unsigned int offset, len, x;\n    char found, ended;\n    COMPS_HSList * path;\n\n    struct Relation {\n        COMPS_HSList * parent_nodes;\n        COMPS_HSListItem * child_it;\n    } *relation;\n\n    path = comps_hslist_create();\n    comps_hslist_init(path, NULL, NULL, &free);\n\n    len = strlen(key);\n    offset = 0;\n    subnodes = rt->subnodes;\n    while (offset != len) {\n        found = 0;\n        for (it = subnodes->first; it != NULL; it=it->next) {\n            if (((COMPS_ObjRTreeData*)it->data)->key[0] == key[offset]) {\n                found = 1;\n                break;\n            }\n        }\n        if (!found) {\n            comps_hslist_destroy(&path);\n            return;\n        }\n        rtdata = (COMPS_ObjRTreeData*)it->data;\n\n        for (x=1; ;x++) {\n            ended=0;\n            if (rtdata->key[x] == 0) ended += 1;\n            if (x == len - offset) ended += 2;\n            if (ended != 0) break;\n            if (key[offset+x] != rtdata->key[x]) break;\n        }\n        if (ended == 3) {\n            /* remove node from tree only if there's no descendant*/\n            if (rtdata->subnodes->last == NULL) {\n                //printf(\"removing all\\n\");\n                comps_hslist_remove(subnodes, it);\n                comps_objrtree_data_destroy(rtdata);\n                free(it);\n            }\n            else {\n                //printf(\"removing data only\\n\");\n                comps_object_destroy(rtdata->data);\n                rtdata->is_leaf = 0;\n                rtdata->data = NULL;\n            }\n\n            if (path->last == NULL) {\n                comps_hslist_destroy(&path);\n                return;\n            }\n            rtdata = (COMPS_ObjRTreeData*)\n                     ((struct Relation*)path->last->data)->child_it->data;\n\n            /*remove all predecessor of deleted node (recursive) with no childs*/\n            while (rtdata->subnodes->last == NULL) {\n                //printf(\"removing '%s'\\n\", rtdata->key);\n                comps_objrtree_data_destroy(rtdata);\n                comps_hslist_remove(\n                            ((struct Relation*)path->last->data)->parent_nodes,\n                            ((struct Relation*)path->last->data)->child_it);\n                free(((struct Relation*)path->last->data)->child_it);\n                it = path->last;\n                comps_hslist_remove(path, path->last);\n                free(it);\n                rtdata = (COMPS_ObjRTreeData*)\n                         ((struct Relation*)path->last->data)->child_it->data;\n            }\n            comps_hslist_destroy(&path);\n            return;\n        }\n        else if (ended == 1) offset+=x;\n        else {\n            comps_hslist_destroy(&path);\n            return;\n        }\n        if ((relation = malloc(sizeof(struct Relation))) == NULL) {\n            comps_hslist_destroy(&path);\n            return;\n        }\n        subnodes = ((COMPS_ObjRTreeData*)it->data)->subnodes;\n        relation->parent_nodes = subnodes;\n        relation->child_it = it;\n        comps_hslist_append(path, (void*)relation, 0);\n    }\n    comps_hslist_destroy(&path);\n    return;\n}\n\nvoid comps_objrtree_clear(COMPS_ObjRTree * rt) {\n    COMPS_HSListItem *it, *oldit;\n    if (rt==NULL) return;\n    if (rt->subnodes == NULL) return;\n    oldit = rt->subnodes->first;\n    it = (oldit)?oldit->next:NULL;\n    for (;it != NULL; it=it->next) {\n        comps_object_destroy(oldit->data);\n        free(oldit);\n        oldit = it;\n    }\n    if (oldit) {\n        comps_object_destroy(oldit->data);\n        free(oldit);\n    }\n}\n\ninline COMPS_HSList* __comps_objrtree_all(COMPS_ObjRTree * rt, char keyvalpair) {\n    COMPS_HSList *to_process, *ret;\n    COMPS_HSListItem *hsit, *oldit;\n    size_t x;\n    struct Pair {\n        char *key;\n        void *data;\n        COMPS_HSList *subnodes;\n    } *pair, *current_pair=NULL;//, *oldpair=NULL;\n    COMPS_ObjRTreePair *rtpair;\n\n    to_process = comps_hslist_create();\n    comps_hslist_init(to_process, NULL, NULL, &free);\n\n    ret = comps_hslist_create();\n    if (keyvalpair == 0)\n        comps_hslist_init(ret, NULL, NULL, &free);\n    else if (keyvalpair == 1)\n        comps_hslist_init(ret, NULL, NULL, NULL);\n    else\n        comps_hslist_init(ret, NULL, NULL, &comps_objrtree_pair_destroy_v);\n\n    for (hsit = rt->subnodes->first; hsit != NULL; hsit = hsit->next) {\n        pair = malloc(sizeof(struct Pair));\n        pair->key = __comps_strcpy(((COMPS_ObjRTreeData*)hsit->data)->key);\n        pair->data = ((COMPS_ObjRTreeData*)hsit->data)->data;\n        pair->subnodes = ((COMPS_ObjRTreeData*)hsit->data)->subnodes;\n        comps_hslist_append(to_process, pair, 0);\n    }\n    while (to_process->first) {\n        //oldpair = current_pair;\n        current_pair = to_process->first->data;\n        oldit = to_process->first;\n        comps_hslist_remove(to_process, to_process->first);\n        if (current_pair->data) {\n            if (keyvalpair == 0) {\n                comps_hslist_append(ret, __comps_strcpy(current_pair->key), 0);\n            } else if (keyvalpair == 1) {\n                comps_hslist_append(ret, current_pair->data, 0);\n            } else {\n                rtpair = malloc(sizeof(COMPS_ObjRTreePair));\n                rtpair->key = __comps_strcpy(current_pair->key);\n                rtpair->data = current_pair->data;\n                comps_hslist_append(ret, rtpair, 0);\n            }\n        }\n        for (hsit = current_pair->subnodes->first, x = 0;\n             hsit != NULL; hsit = hsit->next, x++) {\n            pair = malloc(sizeof(struct Pair));\n            pair->key = __comps_strcat(current_pair->key,\n                                       ((COMPS_ObjRTreeData*)hsit->data)->key);\n            pair->data = ((COMPS_ObjRTreeData*)hsit->data)->data;\n            pair->subnodes = ((COMPS_ObjRTreeData*)hsit->data)->subnodes;\n            comps_hslist_insert_at(to_process, x, pair, 0);\n        }\n        free(current_pair->key);\n        free(current_pair);\n        free(oldit);\n    }\n\n    comps_hslist_destroy(&to_process);\n    return ret;\n}\n\nvoid comps_objrtree_unite(COMPS_ObjRTree *rt1, COMPS_ObjRTree *rt2) {\n    COMPS_HSList *tmplist, *tmp_subnodes;\n    COMPS_HSListItem *it;\n    struct Pair {\n        COMPS_HSList * subnodes;\n        char * key;\n        char added;\n    } *pair, *parent_pair;\n\n    pair = malloc(sizeof(struct Pair));\n    pair->subnodes = rt2->subnodes;\n    pair->key = NULL;\n\n    tmplist = comps_hslist_create();\n    comps_hslist_init(tmplist, NULL, NULL, &free);\n    comps_hslist_append(tmplist, pair, 0);\n\n    while (tmplist->first != NULL) {\n        it = tmplist->first;\n        comps_hslist_remove(tmplist, tmplist->first);\n        tmp_subnodes = ((struct Pair*)it->data)->subnodes;\n        parent_pair = (struct Pair*) it->data;\n        //printf(\"key-part:%s\\n\", parent_pair->key);\n        free(it);\n\n        //pair->added = 0;\n        for (it = tmp_subnodes->first; it != NULL; it=it->next) {\n            pair = malloc(sizeof(struct Pair));\n            pair->subnodes = ((COMPS_ObjRTreeData*)it->data)->subnodes;\n\n            if (parent_pair->key != NULL) {\n                pair->key = malloc(sizeof(char)\n                               * (strlen(((COMPS_ObjRTreeData*)it->data)->key)\n                               + strlen(parent_pair->key) + 1));\n                memcpy(pair->key, parent_pair->key,\n                       sizeof(char) * strlen(parent_pair->key));\n                memcpy(pair->key + strlen(parent_pair->key),\n                       ((COMPS_ObjRTreeData*)it->data)->key,\n                       sizeof(char)*(strlen(((COMPS_ObjRTreeData*)it->data)->key)+1));\n            } else {\n                pair->key = malloc(sizeof(char)*\n                                (strlen(((COMPS_ObjRTreeData*)it->data)->key) +1));\n                memcpy(pair->key, ((COMPS_ObjRTreeData*)it->data)->key,\n                       sizeof(char)*(strlen(((COMPS_ObjRTreeData*)it->data)->key)+1));\n            }\n            /* current node has data */\n            if (((COMPS_ObjRTreeData*)it->data)->data != NULL) {\n                    comps_objrtree_set(rt1, pair->key,\n                                      (((COMPS_ObjRTreeData*)it->data)->data));\n            }\n            if (((COMPS_ObjRTreeData*)it->data)->subnodes->first) {\n                comps_hslist_append(tmplist, pair, 0);\n            } else {\n                free(pair->key);\n                free(pair);\n            }\n        }\n        free(parent_pair->key);\n        free(parent_pair);\n    }\n    comps_hslist_destroy(&tmplist);\n}\n\nCOMPS_ObjRTree* comps_objrtree_union(COMPS_ObjRTree *rt1, COMPS_ObjRTree *rt2){\n    COMPS_ObjRTree *ret;\n    ret = comps_objrtree_clone(rt1);\n    comps_objrtree_unite(ret, rt2);\n    return ret;\n}\n\n\nCOMPS_HSList* comps_objrtree_keys(COMPS_ObjRTree * rt) {\n    return __comps_objrtree_all(rt, 0);\n}\n\nCOMPS_HSList* comps_objrtree_values(COMPS_ObjRTree * rt) {\n    return __comps_objrtree_all(rt, 1);\n}\n\nCOMPS_HSList* comps_objrtree_pairs(COMPS_ObjRTree * rt) {\n    return __comps_objrtree_all(rt, 2);\n}\n\n\ninline void comps_objrtree_pair_destroy(COMPS_ObjRTreePair * pair) {\n    free(pair->key);\n    free(pair);\n}\n\ninline void comps_objrtree_pair_destroy_v(void * pair) {\n    free(((COMPS_ObjRTreePair *)pair)->key);\n    free(pair);\n}\n\nCOMPS_ObjectInfo COMPS_ObjRTree_ObjInfo = {\n    .obj_size = sizeof(COMPS_ObjRTree),\n    .constructor = &comps_objrtree_create_u,\n    .destructor = &comps_objrtree_destroy_u,\n    .copy = &comps_objrtree_copy_u,\n    .obj_cmp = &comps_objrtree_cmp_u\n};\n", "/* libcomps - C alternative to yum.comps library\n * Copyright (C) 2013 Jindrich Luza\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to  Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,\n * USA\n */\n\n#include \"comps_radix.h\"\n#include \"comps_utils.h\"\n\n#include <stdio.h>\n\nvoid comps_rtree_data_destroy(COMPS_RTreeData * rtd) {\n    free(rtd->key);\n    if ((rtd->data) && (*rtd->data_destructor))\n        (*rtd->data_destructor)(rtd->data);\n    comps_hslist_destroy(&rtd->subnodes);\n    free(rtd);\n}\n\ninline void comps_rtree_data_destroy_v(void * rtd) {\n    comps_rtree_data_destroy((COMPS_RTreeData*)rtd);\n}\n\ninline COMPS_RTreeData * __comps_rtree_data_create(COMPS_RTree *rt, char *key,\n                                                   unsigned int keylen,\n                                                   void *data){\n    COMPS_RTreeData * rtd;\n    if ((rtd = malloc(sizeof(*rtd))) == NULL)\n        return NULL;\n    if ((rtd->key = malloc(sizeof(char) * (keylen+1))) == NULL) {\n        free(rtd);\n        return NULL;\n    }\n    memcpy(rtd->key, key, sizeof(char)*keylen);\n    rtd->key[keylen] = 0;\n    rtd->data = data;\n    if (data != NULL) {\n        rtd->is_leaf = 1;\n    }\n    rtd->data_destructor = &rt->data_destructor;\n    rtd->subnodes = comps_hslist_create();\n    comps_hslist_init(rtd->subnodes, NULL, NULL, &comps_rtree_data_destroy_v);\n    return rtd;\n}\n\nCOMPS_RTreeData * comps_rtree_data_create(COMPS_RTree *rt,char * key,\n                                          void * data) {\n    COMPS_RTreeData * rtd;\n    rtd = __comps_rtree_data_create(rt, key, strlen(key), data);\n    return rtd;\n}\n\nCOMPS_RTreeData * comps_rtree_data_create_n(COMPS_RTree *rt, char * key,\n                                            size_t keylen, void * data) {\n    COMPS_RTreeData * rtd;\n    rtd = __comps_rtree_data_create(rt, key, keylen, data);\n    return rtd;\n}\n\nCOMPS_RTree * comps_rtree_create(void* (*data_constructor)(void*),\n                                 void* (*data_cloner)(void*),\n                                 void (*data_destructor)(void*)) {\n    COMPS_RTree *ret;\n    if ((ret = malloc(sizeof(COMPS_RTree))) == NULL)\n        return NULL;\n    ret->subnodes = comps_hslist_create();\n    comps_hslist_init(ret->subnodes, NULL, NULL, &comps_rtree_data_destroy_v);\n    if (ret->subnodes == NULL) {\n        free(ret);\n        return NULL;\n    }\n    ret->data_constructor = data_constructor;\n    ret->data_cloner = data_cloner;\n    ret->data_destructor = data_destructor;\n    return ret;\n}\n\nvoid comps_rtree_destroy(COMPS_RTree * rt) {\n    if (!rt) return;\n    comps_hslist_destroy(&(rt->subnodes));\n    free(rt);\n}\n\nvoid comps_rtree_print(COMPS_HSList * hl, unsigned  deep) {\n    COMPS_HSListItem * it;\n    for (it = hl->first; it != NULL; it=it->next) {\n        printf(\"%d %s\\n\",deep, (((COMPS_RTreeData*)it->data)->key));\n        comps_rtree_print(((COMPS_RTreeData*)it->data)->subnodes, deep+1);\n    }\n}\n\nCOMPS_RTree * comps_rtree_clone(COMPS_RTree *rt) {\n\n    COMPS_HSList *to_clone, *tmplist, *new_subnodes;\n    COMPS_RTree *ret;\n    COMPS_HSListItem *it, *it2;\n    COMPS_RTreeData *rtdata;\n    void *new_data;\n\n    if (!rt) return NULL;\n\n    to_clone = comps_hslist_create();\n    comps_hslist_init(to_clone, NULL, NULL, NULL);\n    ret = comps_rtree_create(rt->data_constructor, rt->data_cloner,\n                             rt->data_destructor);\n\n\n    for (it = rt->subnodes->first; it != NULL; it = it->next) {\n        rtdata = comps_rtree_data_create(ret,\n                                      ((COMPS_RTreeData*)it->data)->key, NULL);\n        if (((COMPS_RTreeData*)it->data)->data != NULL)\n            new_data = rt->data_cloner(((COMPS_RTreeData*)it->data)->data);\n        else\n            new_data = NULL;\n        comps_hslist_destroy(&rtdata->subnodes);\n        rtdata->subnodes = ((COMPS_RTreeData*)it->data)->subnodes;\n        rtdata->data = new_data;\n        comps_hslist_append(ret->subnodes, rtdata, 0);\n\n        comps_hslist_append(to_clone, rtdata, 0);\n    }\n\n\n    while (to_clone->first) {\n        it2 = to_clone->first;\n        tmplist = ((COMPS_RTreeData*)it2->data)->subnodes;\n        comps_hslist_remove(to_clone, to_clone->first);\n\n        new_subnodes = comps_hslist_create();\n        comps_hslist_init(new_subnodes, NULL, NULL, &comps_rtree_data_destroy_v);\n        for (it = tmplist->first; it != NULL; it = it->next) {\n            rtdata = comps_rtree_data_create(ret,\n                                      ((COMPS_RTreeData*)it->data)->key, NULL);\n            if (((COMPS_RTreeData*)it->data)->data != NULL)\n                new_data = rt->data_cloner(((COMPS_RTreeData*)it->data)->data);\n            else\n                new_data = NULL;\n            comps_hslist_destroy(&rtdata->subnodes);\n            rtdata->subnodes = ((COMPS_RTreeData*)it->data)->subnodes;\n            rtdata->data = new_data;\n            comps_hslist_append(new_subnodes, rtdata, 0);\n\n            comps_hslist_append(to_clone, rtdata, 0);\n        }\n        ((COMPS_RTreeData*)it2->data)->subnodes = new_subnodes;\n        free(it2);\n    }\n    comps_hslist_destroy(&to_clone);\n    return ret;\n}\n\nvoid comps_rtree_values_walk(COMPS_RTree * rt, void* udata,\n                              void (*walk_f)(void*, void*)) {\n    COMPS_HSList *tmplist, *tmp_subnodes;\n    COMPS_HSListItem *it;\n    tmplist = comps_hslist_create();\n    comps_hslist_init(tmplist, NULL, NULL, NULL);\n    comps_hslist_append(tmplist, rt->subnodes, 0);\n    while (tmplist->first != NULL) {\n        it = tmplist->first;\n        comps_hslist_remove(tmplist, tmplist->first);\n        tmp_subnodes = (COMPS_HSList*)it->data;\n        for (it = tmp_subnodes->first; it != NULL; it=it->next) {\n            if (((COMPS_RTreeData*)it->data)->subnodes->first) {\n                comps_hslist_append(tmplist,\n                                    ((COMPS_RTreeData*)it->data)->subnodes, 0);\n            }\n            if (((COMPS_RTreeData*)it->data)->data != NULL) {\n               walk_f(udata, ((COMPS_RTreeData*)it->data)->data);\n            }\n        }\n    }\n    comps_hslist_destroy(&tmplist);\n}\n\nvoid __comps_rtree_set(COMPS_RTree * rt, char * key, size_t len, void * data)\n{\n    COMPS_HSListItem *it, *lesser;\n    COMPS_HSList *subnodes;\n    COMPS_RTreeData *rtd;\n    static COMPS_RTreeData *rtdata;\n\n    size_t offset=0, _len;\n    unsigned x, found = 0;\n    void *ndata;\n    char ended;//, tmpch;\n\n    if (rt->subnodes == NULL)\n        return;\n    if (rt->data_constructor) {\n        ndata = rt->data_constructor(data);\n    } else {\n        ndata = data;\n    }\n\n    subnodes = rt->subnodes;\n    while (offset != len)\n    {\n        found = 0;\n        lesser = NULL;\n        for (it = subnodes->first; it != NULL; it=it->next) {\n            if (((COMPS_RTreeData*)it->data)->key[0] == key[offset]) {\n                found = 1;\n                break;\n            } else if (((COMPS_RTreeData*)it->data)->key[0] < key[offset]) {\n                lesser = it;\n            }\n        }\n        if (!found) { // not found in subnodes; create new subnode\n            rtd = comps_rtree_data_create(rt, key+offset, ndata);\n            if (!lesser) {\n                comps_hslist_prepend(subnodes, rtd, 0);\n            } else {\n                comps_hslist_insert_after(subnodes, lesser, rtd, 0);\n            }\n            return;\n        } else {\n            rtdata = (COMPS_RTreeData*)it->data;\n            ended = 0;\n            for (x=1; ;x++) {\n                if (rtdata->key[x] == 0) ended += 1;\n                if (x == len - offset) ended += 2;\n                if (ended != 0) break;\n                if (key[offset+x] != rtdata->key[x]) break;\n            }\n            if (ended == 3) { //keys equals; data replacement\n                rt->data_destructor(rtdata->data);\n                rtdata->data = ndata;\n                return;\n            } else if (ended == 2) { //global key ends first; make global leaf\n                comps_hslist_remove(subnodes, it);\n                it->next = NULL;\n                rtd = comps_rtree_data_create_n(rt, key+offset,\n                                                len-offset, ndata);\n                comps_hslist_append(subnodes, rtd, 0);\n                ((COMPS_RTreeData*)subnodes->last->data)->subnodes->last = it;\n                ((COMPS_RTreeData*)subnodes->last->data)->subnodes->first = it;\n                _len = len - offset;\n\n                memmove(rtdata->key,rtdata->key + _len,\n                                    strlen(rtdata->key) - _len);\n                rtdata->key[strlen(rtdata->key) - _len] = 0;\n                rtdata->key = realloc(rtdata->key,\n                                      sizeof(char)* (strlen(rtdata->key)+1));\n                return;\n            } else if (ended == 1) { //local key ends first; go deeper\n                subnodes = rtdata->subnodes;\n                offset += x;\n            } else {\n                void *tmpdata = rtdata->data;\n                COMPS_HSList *tmpnodes = rtdata->subnodes;\n\n                int cmpret = strcmp(key+offset+x, rtdata->key+x);\n                rtdata->subnodes = comps_hslist_create();\n                comps_hslist_init(rtdata->subnodes, NULL, NULL,\n                                  &comps_rtree_data_destroy_v);\n                rtdata->data = NULL;\n\n                if (cmpret > 0) {\n                    rtd = comps_rtree_data_create(rt, rtdata->key+x, tmpdata);\n                    comps_hslist_destroy(&rtd->subnodes);\n                    rtd->subnodes = tmpnodes;\n                    comps_hslist_append(rtdata->subnodes, rtd, 0);\n                    rtd = comps_rtree_data_create(rt, key+offset+x, ndata);\n                    comps_hslist_append(rtdata->subnodes, rtd, 0);\n                } else {\n                    rtd = comps_rtree_data_create(rt, key+offset+x, ndata);\n                    comps_hslist_append(rtdata->subnodes, rtd, 0);\n                    rtd = comps_rtree_data_create(rt, rtdata->key+x, tmpdata);\n                    comps_hslist_destroy(&rtd->subnodes);\n                    rtd->subnodes = tmpnodes;\n                    comps_hslist_append(rtdata->subnodes, rtd, 0);\n                }\n                rtdata->key = realloc(rtdata->key, sizeof(char)*(x+1));\n                rtdata->key[x] = 0;\n                return;\n            }\n        }\n    }\n}\n\nvoid comps_rtree_set(COMPS_RTree * rt, char * key, void * data)\n{\n    __comps_rtree_set(rt, key, strlen(key), data);\n}\nvoid comps_rtree_set_n(COMPS_RTree * rt, char * key, size_t keylen, void * data)\n{\n    __comps_rtree_set(rt, key, keylen, data);\n}\n\nvoid* comps_rtree_get(COMPS_RTree * rt, const char * key) {\n    COMPS_HSList * subnodes;\n    COMPS_HSListItem * it = NULL;\n    COMPS_RTreeData * rtdata;\n    unsigned int offset, len, x;\n    char found, ended;\n\n    len = strlen(key);\n    offset = 0;\n    subnodes = rt->subnodes;\n    while (offset != len) {\n        found = 0;\n        for (it = subnodes->first; it != NULL; it=it->next) {\n            if (((COMPS_RTreeData*)it->data)->key[0] == key[offset]) {\n                found = 1;\n                break;\n            }\n        }\n        if (!found) {\n            //printf(\"not found\\n\");\n            return NULL;\n        }\n        rtdata = (COMPS_RTreeData*)it->data;\n\n        for (x=1; ;x++) {\n            ended=0;\n            if (x == strlen(rtdata->key)) ended += 1;\n            if (x == len-offset) ended += 2;\n            if (ended != 0) break;\n            if (key[offset+x] != rtdata->key[x]) break;\n        }\n        //printf(\"ended :%d key :%s|\\n\", ended, rtdata->key);\n        if (ended == 3) return rtdata->data;\n        else if (ended == 1) offset+=x;\n        else return NULL;\n        subnodes = ((COMPS_RTreeData*)it->data)->subnodes;\n    }\n    if (it != NULL)\n        return ((COMPS_RTreeData*)it->data)->data;\n    else return NULL;\n}\n\nvoid comps_rtree_unset(COMPS_RTree * rt, const char * key) {\n    COMPS_HSList * subnodes;\n    COMPS_HSListItem * it;\n    COMPS_RTreeData * rtdata;\n    unsigned int offset, len, x;\n    char found, ended;\n    COMPS_HSList * path;\n\n    struct Relation {\n        COMPS_HSList * parent_nodes;\n        COMPS_HSListItem * child_it;\n    } *relation;\n\n    path = comps_hslist_create();\n    comps_hslist_init(path, NULL, NULL, &free);\n\n    len = strlen(key);\n    offset = 0;\n    subnodes = rt->subnodes;\n    while (offset != len) {\n        found = 0;\n        for (it = subnodes->first; it != NULL; it=it->next) {\n            if (((COMPS_RTreeData*)it->data)->key[0] == key[offset]) {\n                found = 1;\n                break;\n            }\n        }\n        if (!found) {\n            comps_hslist_destroy(&path);\n            return;\n        }\n        rtdata = (COMPS_RTreeData*)it->data;\n\n        for (x=1; ;x++) {\n            ended=0;\n            if (rtdata->key[x] == 0) ended += 1;\n            if (x == len - offset) ended += 2;\n            if (ended != 0) break;\n            if (key[offset+x] != rtdata->key[x]) break;\n        }\n        if (ended == 3) {\n            /* remove node from tree only if there's no descendant*/\n            if (rtdata->subnodes->last == NULL) {\n                //printf(\"removing all\\n\");\n                comps_hslist_remove(subnodes, it);\n                comps_rtree_data_destroy(rtdata);\n                free(it);\n            }\n            else if (rtdata->data_destructor != NULL) {\n                //printf(\"removing data only\\n\");\n                (*rtdata->data_destructor)(rtdata->data);\n                rtdata->is_leaf = 0;\n                rtdata->data = NULL;\n            }\n\n            if (path->last == NULL) {\n                comps_hslist_destroy(&path);\n                return;\n            }\n            rtdata = (COMPS_RTreeData*)\n                     ((struct Relation*)path->last->data)->child_it->data;\n\n            /*remove all predecessor of deleted node (recursive) with no childs*/\n            while (rtdata->subnodes->last == NULL) {\n                //printf(\"removing '%s'\\n\", rtdata->key);\n                comps_rtree_data_destroy(rtdata);\n                comps_hslist_remove(\n                            ((struct Relation*)path->last->data)->parent_nodes,\n                            ((struct Relation*)path->last->data)->child_it);\n                free(((struct Relation*)path->last->data)->child_it);\n                it = path->last;\n                comps_hslist_remove(path, path->last);\n                free(it);\n                rtdata = (COMPS_RTreeData*)\n                         ((struct Relation*)path->last->data)->child_it->data;\n            }\n            comps_hslist_destroy(&path);\n            return;\n        }\n        else if (ended == 1) offset+=x;\n        else {\n            comps_hslist_destroy(&path);\n            return;\n        }\n        if ((relation = malloc(sizeof(struct Relation))) == NULL) {\n            comps_hslist_destroy(&path);\n            return;\n        }\n        subnodes = ((COMPS_RTreeData*)it->data)->subnodes;\n        relation->parent_nodes = subnodes;\n        relation->child_it = it;\n        comps_hslist_append(path, (void*)relation, 0);\n    }\n    comps_hslist_destroy(&path);\n    return;\n}\n\nvoid comps_rtree_clear(COMPS_RTree * rt) {\n    COMPS_HSListItem *it, *oldit;\n    if (rt==NULL) return;\n    if (rt->subnodes == NULL) return;\n    oldit = rt->subnodes->first;\n    it = (oldit)?oldit->next:NULL;\n    for (;it != NULL; it=it->next) {\n        if (rt->subnodes->data_destructor != NULL)\n            rt->subnodes->data_destructor(oldit->data);\n        free(oldit);\n        oldit = it;\n    }\n    if (oldit) {\n        if (rt->subnodes->data_destructor != NULL)\n            rt->subnodes->data_destructor(oldit->data);\n        free(oldit);\n    }\n}\n\ninline COMPS_HSList* __comps_rtree_all(COMPS_RTree * rt, char keyvalpair) {\n    COMPS_HSList *to_process, *ret;\n    COMPS_HSListItem *hsit, *oldit;\n    size_t x;\n    struct Pair {\n        char *key;\n        void *data;\n        COMPS_HSList *subnodes;\n    } *pair, *current_pair=NULL;//, *oldpair=NULL;\n    COMPS_RTreePair *rtpair;\n\n    to_process = comps_hslist_create();\n    comps_hslist_init(to_process, NULL, NULL, &free);\n\n    ret = comps_hslist_create();\n    if (keyvalpair == 0)\n        comps_hslist_init(ret, NULL, NULL, &free);\n    else if (keyvalpair == 1)\n        comps_hslist_init(ret, NULL, NULL, NULL);\n    else\n        comps_hslist_init(ret, NULL, NULL, &comps_rtree_pair_destroy_v);\n\n    for (hsit = rt->subnodes->first; hsit != NULL; hsit = hsit->next) {\n        pair = malloc(sizeof(struct Pair));\n        pair->key = __comps_strcpy(((COMPS_RTreeData*)hsit->data)->key);\n        pair->data = ((COMPS_RTreeData*)hsit->data)->data;\n        pair->subnodes = ((COMPS_RTreeData*)hsit->data)->subnodes;\n        comps_hslist_append(to_process, pair, 0);\n    }\n    while (to_process->first) {\n        //oldpair = current_pair;\n        current_pair = to_process->first->data;\n        oldit = to_process->first;\n        comps_hslist_remove(to_process, to_process->first);\n        if (current_pair->data) {\n            if (keyvalpair == 0) {\n                comps_hslist_append(ret, __comps_strcpy(current_pair->key), 0);\n            } else if (keyvalpair == 1) {\n                comps_hslist_append(ret, current_pair->data, 0);\n            } else {\n                rtpair = malloc(sizeof(COMPS_RTreePair));\n                rtpair->key = __comps_strcpy(current_pair->key);\n                rtpair->data = current_pair->data;\n                comps_hslist_append(ret, rtpair, 0);\n            }\n        }\n        for (hsit = current_pair->subnodes->first, x = 0;\n             hsit != NULL; hsit = hsit->next, x++) {\n            pair = malloc(sizeof(struct Pair));\n            pair->key = __comps_strcat(current_pair->key,\n                                       ((COMPS_RTreeData*)hsit->data)->key);\n            pair->data = ((COMPS_RTreeData*)hsit->data)->data;\n            pair->subnodes = ((COMPS_RTreeData*)hsit->data)->subnodes;\n            comps_hslist_insert_at(to_process, x, pair, 0);\n        }\n        free(current_pair->key);\n        free(current_pair);\n        free(oldit);\n    }\n\n    comps_hslist_destroy(&to_process);\n    return ret;\n}\n\nvoid comps_rtree_unite(COMPS_RTree *rt1, COMPS_RTree *rt2) {\n    COMPS_HSList *tmplist, *tmp_subnodes;\n    COMPS_HSListItem *it;\n    struct Pair {\n        COMPS_HSList * subnodes;\n        char * key;\n        char added;\n    } *pair, *parent_pair;\n\n    pair = malloc(sizeof(struct Pair));\n    pair->subnodes = rt2->subnodes;\n    pair->key = NULL;\n\n    tmplist = comps_hslist_create();\n    comps_hslist_init(tmplist, NULL, NULL, &free);\n    comps_hslist_append(tmplist, pair, 0);\n\n    while (tmplist->first != NULL) {\n        it = tmplist->first;\n        comps_hslist_remove(tmplist, tmplist->first);\n        tmp_subnodes = ((struct Pair*)it->data)->subnodes;\n        parent_pair = (struct Pair*) it->data;\n        free(it);\n\n        for (it = tmp_subnodes->first; it != NULL; it=it->next) {\n            pair = malloc(sizeof(struct Pair));\n            pair->subnodes = ((COMPS_RTreeData*)it->data)->subnodes;\n\n            if (parent_pair->key != NULL) {\n                pair->key = malloc(sizeof(char)\n                               * (strlen(((COMPS_RTreeData*)it->data)->key)\n                               + strlen(parent_pair->key) + 1));\n                memcpy(pair->key, parent_pair->key,\n                       sizeof(char) * strlen(parent_pair->key));\n                memcpy(pair->key + strlen(parent_pair->key),\n                       ((COMPS_RTreeData*)it->data)->key,\n                       sizeof(char)*(strlen(((COMPS_RTreeData*)it->data)->key)+1));\n            } else {\n                pair->key = malloc(sizeof(char)*\n                                (strlen(((COMPS_RTreeData*)it->data)->key) +1));\n                memcpy(pair->key, ((COMPS_RTreeData*)it->data)->key,\n                       sizeof(char)*(strlen(((COMPS_RTreeData*)it->data)->key)+1));\n            }\n            /* current node has data */\n            if (((COMPS_RTreeData*)it->data)->data != NULL) {\n                    comps_rtree_set(rt1,\n                                    pair->key,\n                        rt2->data_cloner(((COMPS_RTreeData*)it->data)->data));\n            }\n            if (((COMPS_RTreeData*)it->data)->subnodes->first) {\n                comps_hslist_append(tmplist, pair, 0);\n            } else {\n                free(pair->key);\n                free(pair);\n            }\n        }\n        free(parent_pair->key);\n        free(parent_pair);\n    }\n    comps_hslist_destroy(&tmplist);\n}\n\nCOMPS_RTree* comps_rtree_union(COMPS_RTree *rt1, COMPS_RTree *rt2){\n    COMPS_RTree *ret;\n    ret = comps_rtree_clone(rt2);\n    comps_rtree_unite(ret, rt1);\n    return ret;\n}\n\n\nCOMPS_HSList* comps_rtree_keys(COMPS_RTree * rt) {\n    return __comps_rtree_all(rt, 0);\n}\n\nCOMPS_HSList* comps_rtree_values(COMPS_RTree * rt) {\n    return __comps_rtree_all(rt, 1);\n}\n\nCOMPS_HSList* comps_rtree_pairs(COMPS_RTree * rt) {\n    return __comps_rtree_all(rt, 2);\n}\n\ninline void comps_rtree_pair_destroy(COMPS_RTreePair * pair) {\n    free(pair->key);\n    free(pair);\n}\n\ninline void comps_rtree_pair_destroy_v(void * pair) {\n    free(((COMPS_RTreePair *)pair)->key);\n    free(pair);\n}\n"], "fixing_code": ["/* libcomps - C alternative to yum.comps library\n * Copyright (C) 2013 Jindrich Luza\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to  Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,\n * USA\n */\n\n#include \"comps_mradix.h\"\n#include <stdio.h>\n\nvoid comps_mrtree_data_destroy(COMPS_MRTreeData * rtd) {\n    free(rtd->key);\n    comps_hslist_destroy(&rtd->data);\n    comps_hslist_destroy(&rtd->subnodes);\n    free(rtd);\n}\n\ninline void comps_mrtree_data_destroy_v(void * rtd) {\n    comps_mrtree_data_destroy((COMPS_MRTreeData*)rtd);\n}\n\nCOMPS_MRTreeData * comps_mrtree_data_create_n(COMPS_MRTree * tree, char * key,\n                                              size_t keylen, void * data) {\n    COMPS_MRTreeData * rtd;\n    if ((rtd = malloc(sizeof(*rtd))) == NULL)\n        return NULL;\n    if ((rtd->key = malloc(sizeof(char) * (keylen+1))) == NULL) {\n        free(rtd);\n        return NULL;\n    }\n    memcpy(rtd->key, key, sizeof(char)*keylen);\n    rtd->key[keylen] = 0;\n    rtd->is_leaf = 1;\n    rtd->data = comps_hslist_create();\n    comps_hslist_init(rtd->data, NULL, tree->data_cloner,\n                                       tree->data_destructor);\n    if (data)\n        comps_hslist_append(rtd->data, data, 0);\n    rtd->subnodes = comps_hslist_create();\n    comps_hslist_init(rtd->subnodes, NULL,\n                                     NULL,\n                                     &comps_mrtree_data_destroy_v);\n    return rtd;\n}\n\nCOMPS_MRTreeData * comps_mrtree_data_create(COMPS_MRTree * tree,\n                                            char * key, void * data) {\n    return comps_mrtree_data_create_n(tree, key, strlen(key), data);\n}\n\n\nCOMPS_MRTree * comps_mrtree_create(void* (*data_constructor)(void*),\n                                   void* (*data_cloner)(void*),\n                                   void (*data_destructor)(void*)) {\n    COMPS_MRTree *ret;\n    if ((ret = malloc(sizeof(COMPS_MRTree))) == NULL)\n        return NULL;\n    ret->subnodes = comps_hslist_create();\n    comps_hslist_init(ret->subnodes, NULL, NULL, &comps_mrtree_data_destroy_v);\n    if (ret->subnodes == NULL) {\n        free(ret);\n        return NULL;\n    }\n    ret->data_constructor = data_constructor;\n    ret->data_cloner = data_cloner;\n    ret->data_destructor = data_destructor;\n    return ret;\n}\n\nvoid comps_mrtree_destroy(COMPS_MRTree * rt) {\n    comps_hslist_destroy(&(rt->subnodes));\n    free(rt);\n}\n\nvoid comps_mrtree_print(COMPS_HSList * hl, unsigned  deep) {\n    COMPS_HSListItem * it;\n    for (it = hl->first; it != NULL; it=it->next) {\n        printf(\"%d %s\\n\",deep, (((COMPS_MRTreeData*)it->data)->key));\n        comps_mrtree_print(((COMPS_MRTreeData*)it->data)->subnodes, deep+1);\n    }\n}\n\nvoid comps_mrtree_values_walk(COMPS_MRTree * rt, void* udata,\n                              void (*walk_f)(void*, void*)) {\n    COMPS_HSList *tmplist, *tmp_subnodes;\n    COMPS_HSListItem *it, *it2;\n    tmplist = comps_hslist_create();\n    comps_hslist_init(tmplist, NULL, NULL, NULL);\n    comps_hslist_append(tmplist, rt->subnodes, 0);\n    while (tmplist->first != NULL) {\n        it = tmplist->first;\n        comps_hslist_remove(tmplist, tmplist->first);\n        tmp_subnodes = (COMPS_HSList*)it->data;\n        free(it);\n        for (it = tmp_subnodes->first; it != NULL; it=it->next) {\n            if (((COMPS_MRTreeData*)it->data)->subnodes->first) {\n                comps_hslist_append(tmplist,\n                                    ((COMPS_MRTreeData*)it->data)->subnodes, 0);\n            }\n            for (it2 = (COMPS_HSListItem*)((COMPS_MRTreeData*)it->data)->data->first;\n                 it2 != NULL; it2 = it2->next) {\n                walk_f(udata, it2->data);\n            }\n        }\n    }\n    comps_hslist_destroy(&tmplist);\n}\n\nCOMPS_MRTree * comps_mrtree_clone(COMPS_MRTree * rt) {\n\n    COMPS_HSList * to_clone, *tmplist, *new_subnodes;\n    COMPS_MRTree * ret;\n    COMPS_HSListItem *it, *it2;\n    COMPS_MRTreeData *rtdata;\n    COMPS_HSList *new_data_list;\n\n    to_clone = comps_hslist_create();\n    comps_hslist_init(to_clone, NULL, NULL, NULL);\n    ret = comps_mrtree_create(rt->data_constructor, rt->data_cloner,\n                              rt->data_destructor);\n\n    for (it = rt->subnodes->first; it != NULL; it = it->next) {\n        rtdata = comps_mrtree_data_create(rt,\n                                      ((COMPS_MRTreeData*)it->data)->key, NULL);\n        new_data_list = comps_hslist_clone(((COMPS_MRTreeData*)it->data)->data);\n        comps_hslist_destroy(&rtdata->data);\n        comps_hslist_destroy(&rtdata->subnodes);\n        rtdata->subnodes = ((COMPS_MRTreeData*)it->data)->subnodes;\n        rtdata->data = new_data_list;\n        comps_hslist_append(ret->subnodes, rtdata, 0);\n\n        comps_hslist_append(to_clone, rtdata, 0);\n    }\n\n\n    while (to_clone->first) {\n        it2 = to_clone->first;\n        tmplist = ((COMPS_MRTreeData*)it2->data)->subnodes;\n        comps_hslist_remove(to_clone, to_clone->first);\n\n        new_subnodes = comps_hslist_create();\n        comps_hslist_init(new_subnodes, NULL, NULL, &comps_mrtree_data_destroy_v);\n        for (it = tmplist->first; it != NULL; it = it->next) {\n            rtdata = comps_mrtree_data_create(rt,\n                                      ((COMPS_MRTreeData*)it->data)->key, NULL);\n            new_data_list = comps_hslist_clone(((COMPS_MRTreeData*)it->data)->data);\n            comps_hslist_destroy(&rtdata->subnodes);\n            comps_hslist_destroy(&rtdata->data);\n            rtdata->subnodes = ((COMPS_MRTreeData*)it->data)->subnodes;\n            rtdata->data = new_data_list;\n            comps_hslist_append(new_subnodes, rtdata, 0);\n\n            comps_hslist_append(to_clone, rtdata, 0);\n        }\n        ((COMPS_MRTreeData*)it2->data)->subnodes = new_subnodes;\n        free(it2);\n    }\n    comps_hslist_destroy(&to_clone);\n    return ret;\n}\n\nvoid comps_mrtree_unite(COMPS_MRTree *rt1, COMPS_MRTree *rt2) {\n    COMPS_HSList *tmplist, *tmp_subnodes;\n    COMPS_HSListItem *it, *it2;\n    struct Pair {\n        COMPS_HSList * subnodes;\n        char * key;\n    } *pair, *parent_pair;\n\n    pair = malloc(sizeof(struct Pair));\n    pair->subnodes = rt2->subnodes;\n    pair->key = NULL;\n\n    tmplist = comps_hslist_create();\n    comps_hslist_init(tmplist, NULL, NULL, &free);\n    comps_hslist_append(tmplist, pair, 0);\n\n    while (tmplist->first != NULL) {\n        it = tmplist->first;\n        comps_hslist_remove(tmplist, tmplist->first);\n        tmp_subnodes = ((struct Pair*)it->data)->subnodes;\n        parent_pair = (struct Pair*) it->data;\n        free(it);\n\n        for (it = tmp_subnodes->first; it != NULL; it=it->next) {\n            pair = malloc(sizeof(struct Pair));\n            pair->subnodes = ((COMPS_MRTreeData*)it->data)->subnodes;\n\n            if (parent_pair->key != NULL) {\n                pair->key =\n                    malloc(sizeof(char)\n                           * (strlen(((COMPS_MRTreeData*)it->data)->key)\n                           + strlen(parent_pair->key) + 1));\n                memcpy(pair->key, parent_pair->key,\n                       sizeof(char) * strlen(parent_pair->key));\n                memcpy(pair->key+strlen(parent_pair->key),\n                       ((COMPS_MRTreeData*)it->data)->key,\n                       sizeof(char)*(strlen(((COMPS_MRTreeData*)it->data)->key)+1));\n            } else {\n                pair->key = malloc(sizeof(char)*\n                                (strlen(((COMPS_MRTreeData*)it->data)->key) +\n                                1));\n                memcpy(pair->key, ((COMPS_MRTreeData*)it->data)->key,\n                       sizeof(char)*(strlen(((COMPS_MRTreeData*)it->data)->key)+1));\n            }\n            /* current node has data */\n            if (((COMPS_MRTreeData*)it->data)->data->first != NULL) {\n                for (it2 = ((COMPS_MRTreeData*)it->data)->data->first;\n                     it2 != NULL; it2 = it2->next) {\n                    comps_mrtree_set(rt1, pair->key, it2->data);\n                }\n\n                if (((COMPS_MRTreeData*)it->data)->subnodes->first) {\n                    comps_hslist_append(tmplist, pair, 0);\n                } else {\n                    free(pair->key);\n                    free(pair);\n                }\n            /* current node hasn't data */\n            } else {\n                if (((COMPS_MRTreeData*)it->data)->subnodes->first) {\n                    comps_hslist_append(tmplist, pair, 0);\n                } else {\n                    free(pair->key);\n                    free(pair);\n                }\n            }\n        }\n        free(parent_pair->key);\n        free(parent_pair);\n    }\n    comps_hslist_destroy(&tmplist);\n}\n\nCOMPS_HSList* comps_mrtree_keys(COMPS_MRTree * rt) {\n    COMPS_HSList *tmplist, *tmp_subnodes, *ret;\n    COMPS_HSListItem *it;\n    struct Pair {\n        COMPS_HSList * subnodes;\n        char * key;\n        char added;\n    } *pair, *parent_pair;\n\n    pair = malloc(sizeof(struct Pair));\n    pair->subnodes = rt->subnodes;\n    pair->key = NULL;\n    pair->added = 0;\n\n    tmplist = comps_hslist_create();\n    comps_hslist_init(tmplist, NULL, NULL, &free);\n    ret = comps_hslist_create();\n    comps_hslist_init(ret, NULL, NULL, &free);\n    comps_hslist_append(tmplist, pair, 0);\n\n    while (tmplist->first != NULL) {\n        it = tmplist->first;\n        comps_hslist_remove(tmplist, tmplist->first);\n        tmp_subnodes = ((struct Pair*)it->data)->subnodes;\n        parent_pair = (struct Pair*) it->data;\n        free(it);\n\n        for (it = tmp_subnodes->first; it != NULL; it=it->next) {\n            pair = malloc(sizeof(struct Pair));\n            pair->subnodes = ((COMPS_MRTreeData*)it->data)->subnodes;\n            pair->added = 0;\n\n            if (parent_pair->key != NULL) {\n                pair->key =\n                    malloc(sizeof(char)\n                           * (strlen(((COMPS_MRTreeData*)it->data)->key)\n                           + strlen(parent_pair->key) + 1));\n                memcpy(pair->key, parent_pair->key,\n                       sizeof(char) * strlen(parent_pair->key));\n                memcpy(pair->key+strlen(parent_pair->key),\n                       ((COMPS_MRTreeData*)it->data)->key,\n                       sizeof(char)*(strlen(((COMPS_MRTreeData*)it->data)->key)+1));\n            } else {\n                pair->key = malloc(sizeof(char)*\n                                (strlen(((COMPS_MRTreeData*)it->data)->key) +\n                                1));\n                memcpy(pair->key, ((COMPS_MRTreeData*)it->data)->key,\n                       sizeof(char)*(strlen(((COMPS_MRTreeData*)it->data)->key)+1));\n            }\n            /* current node has data */\n            if (((COMPS_MRTreeData*)it->data)->data->first != NULL) {\n                //printf(\"data not null for |%s|\\n\", pair->key);\n                comps_hslist_append(ret, pair->key, 0);\n                pair->added = 1;\n                if (((COMPS_MRTreeData*)it->data)->subnodes->first != NULL) {\n//                    printf(\"subnodes found\\b\");\n                    comps_hslist_append(tmplist, pair, 0);\n                } else {\n                    free(pair);\n                }\n            /* current node hasn't data */\n            } else {\n                if (((COMPS_MRTreeData*)it->data)->subnodes->first) {\n                    comps_hslist_append(tmplist, pair, 0);\n                } else {\n                    free(pair->key);\n                    free(pair);\n                }\n            }\n        }\n        if (parent_pair->added == 0)\n            free(parent_pair->key);\n        free(parent_pair);\n    }\n    comps_hslist_destroy(&tmplist);\n    return ret;\n}\n\nvoid __comps_mrtree_set(COMPS_MRTree * rt, char * key, size_t len, void * data)\n{\n    static COMPS_HSListItem *it;\n    COMPS_HSList *subnodes;\n    COMPS_MRTreeData *rtd;\n    static COMPS_MRTreeData *rtdata;\n\n    size_t _len, offset=0;\n    unsigned x, found = 0;\n    void *ndata;\n    char ended;//, tmpch;\n\n    if (rt->subnodes == NULL)\n        return;\n    if (rt->data_constructor)\n        ndata = rt->data_constructor(data);\n    else\n        ndata = data;\n\n    subnodes = rt->subnodes;\n    while (offset != len)\n    {\n        found = 0;\n        for (it = subnodes->first; it != NULL; it=it->next) {\n            if (((COMPS_MRTreeData*)it->data)->key[0] == key[offset]) {\n                found = 1;\n                break;\n            }\n        }\n        if (!found) { // not found in subnodes; create new subnode\n            rtd = comps_mrtree_data_create(rt, key+offset, ndata);\n            comps_hslist_append(subnodes, rtd, 0);\n            return;\n        } else {\n            rtdata = (COMPS_MRTreeData*)it->data;\n            ended = 0;\n            for (x=1; ;x++) {\n                if (rtdata->key[x] == 0) ended += 1;\n                if (x == len - offset) ended += 2;\n                if (ended != 0) break;\n                if (key[offset+x] != rtdata->key[x]) break;\n            }\n            if (ended == 3) { //keys equals; append new data\n                comps_hslist_append(rtdata->data, ndata, 0);\n                return;\n            } else if (ended == 2) { //global key ends first; make global leaf\n                comps_hslist_remove(subnodes, it);\n                it->next = NULL;\n                rtd = comps_mrtree_data_create(rt, key+offset,  ndata);\n                comps_hslist_append(subnodes, rtd, 0);\n                ((COMPS_MRTreeData*)subnodes->last->data)->subnodes->last = it;\n                ((COMPS_MRTreeData*)subnodes->last->data)->subnodes->first = it;\n                _len = strlen(key + offset);\n                memmove(rtdata->key,rtdata->key+_len, strlen(rtdata->key) - _len);\n                rtdata->key[strlen(rtdata->key) - _len] = 0;\n                rtdata->key = realloc(rtdata->key,\n                                      sizeof(char)* (strlen(rtdata->key)+1));\n                return;\n            } else if (ended == 1) { //local key ends first; go deeper\n                subnodes = rtdata->subnodes;\n                offset += x;\n            } else { /* keys differ */\n                void *tmpdata = rtdata->data;\n                COMPS_HSList *tmpnodes = rtdata->subnodes;\n\n                int cmpret = strcmp(key+offset+x, rtdata->key+x);\n                rtdata->subnodes = comps_hslist_create();\n                comps_hslist_init(rtdata->subnodes, NULL, NULL,\n                                  &comps_mrtree_data_destroy_v);\n                rtdata->data = NULL;\n                if (cmpret > 0) {\n                    rtd = comps_mrtree_data_create(rt, rtdata->key+x, tmpdata);\n                    comps_hslist_destroy(&rtd->subnodes);\n                    rtd->subnodes = tmpnodes;\n                    comps_hslist_append(rtdata->subnodes, rtd, 0);\n                    rtd = comps_mrtree_data_create(rt, key+offset+x, ndata);\n                    comps_hslist_append(rtdata->subnodes, rtd, 0);\n                } else {\n                    rtd = comps_mrtree_data_create(rt, key+offset+x, ndata);\n                    comps_hslist_append(rtdata->subnodes, rtd, 0);\n                    rtd = comps_mrtree_data_create(rt, rtdata->key+x, tmpdata);\n                    comps_hslist_destroy(&rtd->subnodes);\n                    rtd->subnodes = tmpnodes;\n                    comps_hslist_append(rtdata->subnodes, rtd, 0);\n                }\n                rtdata->key = realloc(rtdata->key, sizeof(char)*(x+1));\n                rtdata->key[x] = 0;\n                return;\n            }\n        }\n    }\n}\n\nvoid comps_mrtree_set(COMPS_MRTree * rt, char * key, void * data)\n{\n    __comps_mrtree_set(rt, key, strlen(key), data);\n}\n\nvoid comps_mrtree_set_n(COMPS_MRTree * rt, char * key, size_t len, void * data)\n{\n    __comps_mrtree_set(rt, key, len, data);\n}\n\nCOMPS_HSList * comps_mrtree_get(COMPS_MRTree * rt, const char * key) {\n    COMPS_HSList * subnodes;\n    COMPS_HSListItem * it = NULL;\n    COMPS_MRTreeData * rtdata;\n    unsigned int offset, len, x;\n    char found, ended;\n\n    len = strlen(key);\n    offset = 0;\n    subnodes = rt->subnodes;\n    while (offset != len) {\n        found = 0;\n        for (it = subnodes->first; it != NULL; it=it->next) {\n            if (((COMPS_MRTreeData*)it->data)->key[0] == key[offset]) {\n                found = 1;\n                break;\n            }\n        }\n        if (!found)\n            return NULL;\n        rtdata = (COMPS_MRTreeData*)it->data;\n\n        for (x=1; ;x++) {\n            ended=0;\n            if (rtdata->key[x] == 0) ended += 1;\n            if (x == len - offset) ended += 2;\n            if (ended != 0) break;\n            if (key[offset+x] != rtdata->key[x]) break;\n        }\n        if (ended == 3) return rtdata->data;\n        else if (ended == 1) offset+=x;\n        else return NULL;\n        subnodes = ((COMPS_MRTreeData*)it->data)->subnodes;\n    }\n    if (it)\n        return ((COMPS_MRTreeData*)it->data)->data;\n    else return NULL;\n}\n\nCOMPS_HSList ** comps_mrtree_getp(COMPS_MRTree * rt, const char * key) {\n    COMPS_HSList * subnodes;\n    COMPS_HSListItem * it = NULL;\n    COMPS_MRTreeData * rtdata;\n    unsigned int offset, len, x;\n    char found, ended;\n\n    len = strlen(key);\n    offset = 0;\n    subnodes = rt->subnodes;\n    while (offset != len) {\n        found = 0;\n        for (it = subnodes->first; it != NULL; it=it->next) {\n            if (((COMPS_MRTreeData*)it->data)->key[0] == key[offset]) {\n                found = 1;\n                break;\n            }\n        }\n        if (!found)\n            return NULL;\n        rtdata = (COMPS_MRTreeData*)it->data;\n\n        for (x=1; ;x++) {\n            ended=0;\n            if (rtdata->key[x] == 0) ended += 1;\n            if (x == len - offset) ended += 2;\n            if (ended != 0) break;\n            if (key[offset+x] != rtdata->key[x]) break;\n        }\n        if (ended == 3) return &rtdata->data;\n        else if (ended == 1) offset+=x;\n        else return NULL;\n        subnodes = ((COMPS_MRTreeData*)it->data)->subnodes;\n    }\n    if (it)\n        return &((COMPS_MRTreeData*)it->data)->data;\n    else return NULL;\n}\n\nvoid comps_mrtree_unset(COMPS_MRTree * rt, const char * key) {\n    COMPS_HSList * subnodes;\n    COMPS_HSListItem * it;\n    COMPS_MRTreeData * rtdata;\n    unsigned int offset, len, x;\n    char found, ended;\n    COMPS_HSList * path;\n\n    struct Relation {\n        COMPS_HSList * parent_nodes;\n        COMPS_HSListItem * child_it;\n    } *relation;\n\n    path = comps_hslist_create();\n    comps_hslist_init(path, NULL, NULL, &free);\n\n    len = strlen(key);\n    offset = 0;\n    subnodes = rt->subnodes;\n    while (offset != len) {\n        found = 0;\n        for (it = subnodes->first; it != NULL; it=it->next) {\n            if (((COMPS_MRTreeData*)it->data)->key[0] == key[offset]) {\n                found = 1;\n                break;\n            }\n        }\n        if (!found) {\n            comps_hslist_destroy(&path);\n            return;\n        }\n        rtdata = (COMPS_MRTreeData*)it->data;\n\n        for (x=1; ;x++) {\n            ended=0;\n            if (rtdata->key[x] == 0) ended += 1;\n            if (x == len - offset) ended += 2;\n            if (ended != 0) break;\n            if (key[offset+x] != rtdata->key[x]) break;\n        }\n        if (ended == 3) {\n            /* remove node from tree only if there's no descendant*/\n            if (rtdata->subnodes->last == NULL) {\n                printf(\"removing all\\n\");\n                comps_hslist_remove(subnodes, it);\n                comps_mrtree_data_destroy(rtdata);\n                free(it);\n            }\n            else {\n                printf(\"removing data only\\n\");\n                comps_hslist_clear(rtdata->data);\n                rtdata->is_leaf = 0;\n            }\n\n            if (path->last == NULL) {\n                comps_hslist_destroy(&path);\n                return;\n            }\n            rtdata = (COMPS_MRTreeData*)\n                     ((struct Relation*)path->last->data)->child_it->data;\n\n            /*remove all predecessor of deleted node (recursive) with no childs*/\n            while (rtdata->subnodes->last == NULL) {\n                printf(\"removing '%s'\\n\", rtdata->key);\n                comps_mrtree_data_destroy(rtdata);\n                comps_hslist_remove(\n                            ((struct Relation*)path->last->data)->parent_nodes,\n                            ((struct Relation*)path->last->data)->child_it);\n                free(((struct Relation*)path->last->data)->child_it);\n                it = path->last;\n                comps_hslist_remove(path, path->last);\n                free(it);\n                rtdata = (COMPS_MRTreeData*)\n                         ((struct Relation*)path->last->data)->child_it->data;\n            }\n            comps_hslist_destroy(&path);\n            return;\n        }\n        else if (ended == 1) offset+=x;\n        else {\n            comps_hslist_destroy(&path);\n            return;\n        }\n        if ((relation = malloc(sizeof(struct Relation))) == NULL) {\n            comps_hslist_destroy(&path);\n            return;\n        }\n        subnodes = ((COMPS_MRTreeData*)it->data)->subnodes;\n        relation->parent_nodes = subnodes;\n        relation->child_it = it;\n        comps_hslist_append(path, (void*)relation, 0);\n    }\n    comps_hslist_destroy(&path);\n    return;\n}\n\nvoid comps_mrtree_clear(COMPS_MRTree * rt) {\n    COMPS_HSListItem *it, *oldit;\n    if (rt == NULL) return;\n    if (rt->subnodes == NULL) return;\n    oldit = rt->subnodes->first;\n    it = (oldit)?oldit->next:NULL;\n    for (;it != NULL; it=it->next) {\n        if (rt->subnodes->data_destructor != NULL)\n            rt->subnodes->data_destructor(oldit->data);\n        free(oldit);\n        oldit = it;\n    }\n    if (oldit) {\n        if (rt->subnodes->data_destructor != NULL)\n            rt->subnodes->data_destructor(oldit->data);\n        free(oldit);\n    }\n}\n", "/* libcomps - C alternative to yum.comps library\n * Copyright (C) 2013 Jindrich Luza\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to  Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,\n * USA\n */\n\n#include \"comps_objmradix.h\"\n#include \"comps_set.h\"\n#include <stdio.h>\n\nvoid comps_objmrtree_data_destroy(COMPS_ObjMRTreeData * rtd) {\n    free(rtd->key);\n    COMPS_OBJECT_DESTROY(rtd->data);\n    comps_hslist_destroy(&rtd->subnodes);\n    free(rtd);\n}\n\ninline void comps_objmrtree_data_destroy_v(void * rtd) {\n    comps_objmrtree_data_destroy((COMPS_ObjMRTreeData*)rtd);\n}\n\nstatic COMPS_ObjMRTreeData * __comps_objmrtree_data_create(char * key,\n                                                    size_t keylen,\n                                                    COMPS_Object *data) {\n\n    COMPS_ObjMRTreeData * rtd;\n    if ((rtd = malloc(sizeof(*rtd))) == NULL)\n        return NULL;\n    if ((rtd->key = malloc(sizeof(char) * (keylen+1))) == NULL) {\n        free(rtd);\n        return NULL;\n    }\n    memcpy(rtd->key, key, sizeof(char)*keylen);\n    rtd->key[keylen] = '\\0';\n    rtd->is_leaf = 1;\n    rtd->data = COMPS_OBJECT_CREATE(COMPS_ObjList, NULL);\n    if (data)\n        comps_objlist_append_x(rtd->data, data);\n    rtd->subnodes = comps_hslist_create();\n    comps_hslist_init(rtd->subnodes, NULL,\n                                     NULL,\n                                     &comps_objmrtree_data_destroy_v);\n    return rtd;\n}\n\nCOMPS_ObjMRTreeData * comps_objmrtree_data_create(char *key, COMPS_Object *data){\n    COMPS_ObjMRTreeData * rtd;\n    rtd = __comps_objmrtree_data_create(key, strlen(key), data);\n    return rtd;\n}\n\nCOMPS_ObjMRTreeData * comps_objmrtree_data_create_n(char * key, unsigned keylen,\n                                                    void * data) {\n    COMPS_ObjMRTreeData * rtd;\n    rtd = __comps_objmrtree_data_create(key, keylen, data);\n    return rtd;\n}\nstatic void comps_objmrtree_create(COMPS_ObjMRTree *rtree, COMPS_Object **args){\n    (void)args;\n    rtree->subnodes = comps_hslist_create();\n    comps_hslist_init(rtree->subnodes, NULL, NULL, &comps_objmrtree_data_destroy_v);\n    if (rtree->subnodes == NULL) {\n        COMPS_OBJECT_DESTROY(rtree);\n        return;\n    }\n    rtree->len = 0;\n}\nvoid comps_objmrtree_create_u(COMPS_Object * obj, COMPS_Object **args) {\n    (void)args;\n    comps_objmrtree_create((COMPS_ObjMRTree*)obj, NULL);\n}\n\nstatic void comps_objmrtree_destroy(COMPS_ObjMRTree * rt) {\n    comps_hslist_destroy(&(rt->subnodes));\n}\nvoid comps_objmrtree_destroy_u(COMPS_Object *obj) {\n    comps_objmrtree_destroy((COMPS_ObjMRTree*)obj);\n}\n\nvoid comps_objmrtree_values_walk(COMPS_ObjMRTree * rt, void* udata,\n                              void (*walk_f)(void*, void*)) {\n    COMPS_HSList *tmplist, *tmp_subnodes;\n    COMPS_HSListItem *it, *it2;\n    tmplist = comps_hslist_create();\n    comps_hslist_init(tmplist, NULL, NULL, NULL);\n    comps_hslist_append(tmplist, rt->subnodes, 0);\n    while (tmplist->first != NULL) {\n        it = tmplist->first;\n        comps_hslist_remove(tmplist, tmplist->first);\n        tmp_subnodes = (COMPS_HSList*)it->data;\n        free(it);\n        for (it = tmp_subnodes->first; it != NULL; it=it->next) {\n            if (((COMPS_ObjMRTreeData*)it->data)->subnodes->first) {\n                comps_hslist_append(tmplist,\n                                    ((COMPS_ObjMRTreeData*)it->data)->subnodes, 0);\n            }\n            for (it2 = (COMPS_HSListItem*)((COMPS_ObjMRTreeData*)it->data)->data->first;\n                 it2 != NULL; it2 = it2->next) {\n                walk_f(udata, it2->data);\n            }\n        }\n    }\n    comps_hslist_destroy(&tmplist);\n}\n\nvoid comps_objmrtree_copy(COMPS_ObjMRTree *ret, COMPS_ObjMRTree *rt){\n    COMPS_HSList * to_clone, *tmplist, *new_subnodes;\n    COMPS_HSListItem *it, *it2;\n    COMPS_ObjMRTreeData *rtdata;\n    COMPS_ObjList *new_data_list;\n\n    to_clone = comps_hslist_create();\n    comps_hslist_init(to_clone, NULL, NULL, NULL);\n\n    for (it = rt->subnodes->first; it != NULL; it = it->next) {\n        rtdata = comps_objmrtree_data_create(\n                                       ((COMPS_ObjMRTreeData*)it->data)->key,\n                                       NULL);\n        new_data_list = (COMPS_ObjList*)\n                        COMPS_OBJECT_COPY(((COMPS_ObjMRTreeData*)it->data)->data);\n        COMPS_OBJECT_DESTROY(&rtdata->data);\n        comps_hslist_destroy(&rtdata->subnodes);\n        rtdata->subnodes = ((COMPS_ObjMRTreeData*)it->data)->subnodes;\n        rtdata->data = new_data_list;\n        comps_hslist_append(ret->subnodes, rtdata, 0);\n\n        comps_hslist_append(to_clone, rtdata, 0);\n    }\n\n    while (to_clone->first) {\n        it2 = to_clone->first;\n        tmplist = ((COMPS_ObjMRTreeData*)it2->data)->subnodes;\n        comps_hslist_remove(to_clone, to_clone->first);\n\n        new_subnodes = comps_hslist_create();\n        comps_hslist_init(new_subnodes, NULL, NULL, &comps_objmrtree_data_destroy_v);\n        for (it = tmplist->first; it != NULL; it = it->next) {\n            rtdata = comps_objmrtree_data_create(\n                                          ((COMPS_ObjMRTreeData*)it->data)->key,\n                                          NULL);\n            new_data_list = (COMPS_ObjList*)\n                            COMPS_OBJECT_COPY(((COMPS_ObjMRTreeData*)it->data)->data);\n\n            comps_hslist_destroy(&rtdata->subnodes);\n            COMPS_OBJECT_DESTROY(rtdata->data);\n            rtdata->subnodes = ((COMPS_ObjMRTreeData*)it->data)->subnodes;\n            rtdata->data = new_data_list;\n            comps_hslist_append(new_subnodes, rtdata, 0);\n\n            comps_hslist_append(to_clone, rtdata, 0);\n        }\n        ((COMPS_ObjMRTreeData*)it2->data)->subnodes = new_subnodes;\n        free(it2);\n    }\n    ret->len = rt->len;\n    comps_hslist_destroy(&to_clone);\n}\nCOMPS_COPY_u(objmrtree, COMPS_ObjMRTree) /*comps_utils.h macro*/\n\nvoid comps_objmrtree_copy_shallow(COMPS_ObjMRTree *ret, COMPS_ObjMRTree *rt){\n    COMPS_HSList * to_clone, *tmplist, *new_subnodes;\n    COMPS_HSListItem *it, *it2;\n    COMPS_ObjMRTreeData *rtdata;\n    COMPS_ObjList *new_data_list;\n\n    to_clone = comps_hslist_create();\n    comps_hslist_init(to_clone, NULL, NULL, NULL);\n\n    for (it = rt->subnodes->first; it != NULL; it = it->next) {\n        rtdata = comps_objmrtree_data_create(\n                                       ((COMPS_ObjMRTreeData*)it->data)->key,\n                                       NULL);\n        new_data_list = (COMPS_ObjList*)\n                        COMPS_OBJECT_COPY(((COMPS_ObjMRTreeData*)it->data)->data);\n        COMPS_OBJECT_DESTROY(&rtdata->data);\n        comps_hslist_destroy(&rtdata->subnodes);\n        rtdata->subnodes = ((COMPS_ObjMRTreeData*)it->data)->subnodes;\n        rtdata->data = new_data_list;\n        comps_hslist_append(ret->subnodes, rtdata, 0);\n\n        comps_hslist_append(to_clone, rtdata, 0);\n    }\n\n    while (to_clone->first) {\n        it2 = to_clone->first;\n        tmplist = ((COMPS_ObjMRTreeData*)it2->data)->subnodes;\n        comps_hslist_remove(to_clone, to_clone->first);\n\n        new_subnodes = comps_hslist_create();\n        comps_hslist_init(new_subnodes, NULL, NULL, &comps_objmrtree_data_destroy_v);\n        for (it = tmplist->first; it != NULL; it = it->next) {\n            rtdata = comps_objmrtree_data_create(\n                                          ((COMPS_ObjMRTreeData*)it->data)->key,\n                                          NULL);\n            new_data_list = ((COMPS_ObjMRTreeData*)it->data)->data;\n\n            comps_hslist_destroy(&rtdata->subnodes);\n            COMPS_OBJECT_DESTROY(rtdata->data);\n            rtdata->subnodes = ((COMPS_ObjMRTreeData*)it->data)->subnodes;\n            rtdata->data = new_data_list;\n            comps_hslist_append(new_subnodes, rtdata, 0);\n\n            comps_hslist_append(to_clone, rtdata, 0);\n        }\n        ((COMPS_ObjMRTreeData*)it2->data)->subnodes = new_subnodes;\n        free(it2);\n    }\n    ret->len = rt->len;\n    comps_hslist_destroy(&to_clone);\n}\n\nCOMPS_ObjMRTree * comps_objmrtree_clone(COMPS_ObjMRTree * rt) {\n    COMPS_HSList * to_clone, *tmplist, *new_subnodes;\n    COMPS_ObjMRTree * ret;\n    COMPS_HSListItem *it, *it2;\n    COMPS_ObjMRTreeData *rtdata;\n    COMPS_ObjList *new_data_list;\n\n    to_clone = comps_hslist_create();\n    comps_hslist_init(to_clone, NULL, NULL, NULL);\n    ret = COMPS_OBJECT_CREATE(COMPS_ObjMRTree, NULL);\n\n    for (it = rt->subnodes->first; it != NULL; it = it->next) {\n        rtdata = comps_objmrtree_data_create(\n                                       ((COMPS_ObjMRTreeData*)it->data)->key,\n                                       NULL);\n        new_data_list = (COMPS_ObjList*)\n                        COMPS_OBJECT_COPY(((COMPS_ObjMRTreeData*)it->data)->data);\n        COMPS_OBJECT_DESTROY(&rtdata->data);\n        comps_hslist_destroy(&rtdata->subnodes);\n        rtdata->subnodes = ((COMPS_ObjMRTreeData*)it->data)->subnodes;\n        rtdata->data = new_data_list;\n        comps_hslist_append(ret->subnodes, rtdata, 0);\n\n        comps_hslist_append(to_clone, rtdata, 0);\n    }\n\n    while (to_clone->first) {\n        it2 = to_clone->first;\n        tmplist = ((COMPS_ObjMRTreeData*)it2->data)->subnodes;\n        comps_hslist_remove(to_clone, to_clone->first);\n\n        new_subnodes = comps_hslist_create();\n        comps_hslist_init(new_subnodes, NULL, NULL, &comps_objmrtree_data_destroy_v);\n        for (it = tmplist->first; it != NULL; it = it->next) {\n            rtdata = comps_objmrtree_data_create(\n                                          ((COMPS_ObjMRTreeData*)it->data)->key,\n                                          NULL);\n            new_data_list = (COMPS_ObjList*)\n                            COMPS_OBJECT_COPY(((COMPS_ObjMRTreeData*)it->data)->data);\n\n            comps_hslist_destroy(&rtdata->subnodes);\n            COMPS_OBJECT_DESTROY(rtdata->data);\n            rtdata->subnodes = ((COMPS_ObjMRTreeData*)it->data)->subnodes;\n            rtdata->data = new_data_list;\n            comps_hslist_append(new_subnodes, rtdata, 0);\n\n            comps_hslist_append(to_clone, rtdata, 0);\n        }\n        ((COMPS_ObjMRTreeData*)it2->data)->subnodes = new_subnodes;\n        free(it2);\n    }\n    ret->len = rt->len;\n    comps_hslist_destroy(&to_clone);\n    return ret;\n}\n\nvoid comps_objmrtree_unite(COMPS_ObjMRTree *rt1, COMPS_ObjMRTree *rt2) {\n    COMPS_HSList *tmplist, *tmp_subnodes;\n    COMPS_HSListItem *it;\n    COMPS_ObjListIt *it2;\n    struct Pair {\n        COMPS_HSList * subnodes;\n        char * key;\n    } *pair, *parent_pair;\n\n    pair = malloc(sizeof(struct Pair));\n    pair->subnodes = rt2->subnodes;\n    pair->key = NULL;\n\n    tmplist = comps_hslist_create();\n    comps_hslist_init(tmplist, NULL, NULL, &free);\n    comps_hslist_append(tmplist, pair, 0);\n\n    while (tmplist->first != NULL) {\n        it = tmplist->first;\n        comps_hslist_remove(tmplist, tmplist->first);\n        tmp_subnodes = ((struct Pair*)it->data)->subnodes;\n        parent_pair = (struct Pair*) it->data;\n        free(it);\n\n        for (it = tmp_subnodes->first; it != NULL; it=it->next) {\n            pair = malloc(sizeof(struct Pair));\n            pair->subnodes = ((COMPS_ObjMRTreeData*)it->data)->subnodes;\n\n            if (parent_pair->key != NULL) {\n                pair->key =\n                    malloc(sizeof(char)\n                           * (strlen(((COMPS_ObjMRTreeData*)it->data)->key)\n                           + strlen(parent_pair->key) + 1));\n                memcpy(pair->key, parent_pair->key,\n                       sizeof(char) * strlen(parent_pair->key));\n                memcpy(pair->key+strlen(parent_pair->key),\n                       ((COMPS_ObjMRTreeData*)it->data)->key,\n                       sizeof(char)*(strlen(((COMPS_ObjMRTreeData*)it->data)->key)+1));\n            } else {\n                pair->key = malloc(sizeof(char)*\n                                (strlen(((COMPS_ObjMRTreeData*)it->data)->key) +\n                                1));\n                memcpy(pair->key, ((COMPS_ObjMRTreeData*)it->data)->key,\n                       sizeof(char)*(strlen(((COMPS_ObjMRTreeData*)it->data)->key)+1));\n            }\n            /* current node has data */\n            if (((COMPS_ObjMRTreeData*)it->data)->data->first != NULL) {\n                for (it2 = ((COMPS_ObjMRTreeData*)it->data)->data->first;\n                     it2 != NULL; it2 = it2->next) {\n                    comps_objmrtree_set(rt1, pair->key, it2->comps_obj);\n                }\n\n                if (((COMPS_ObjMRTreeData*)it->data)->subnodes->first) {\n                    comps_hslist_append(tmplist, pair, 0);\n                } else {\n                    free(pair->key);\n                    free(pair);\n                }\n            /* current node hasn't data */\n            } else {\n                if (((COMPS_ObjMRTreeData*)it->data)->subnodes->first) {\n                    comps_hslist_append(tmplist, pair, 0);\n                } else {\n                    free(pair->key);\n                    free(pair);\n                }\n            }\n        }\n        free(parent_pair->key);\n        free(parent_pair);\n    }\n    comps_hslist_destroy(&tmplist);\n}\n\nvoid comps_objmrtree_set_x(COMPS_ObjMRTree *rt, char *key, COMPS_Object *data) {\n    __comps_objmrtree_set(rt, key, strlen(key), data);\n}\nvoid comps_objmrtree_set(COMPS_ObjMRTree *rt, char *key, COMPS_Object *data) {\n    __comps_objmrtree_set(rt, key, strlen(key), comps_object_incref(data));\n}\n\nvoid __comps_objmrtree_set(COMPS_ObjMRTree *rt, char *key,\n                           size_t len, COMPS_Object *ndata) {\n    static COMPS_HSListItem *it;\n    COMPS_HSList *subnodes;\n    COMPS_ObjMRTreeData *rtd;\n    static COMPS_ObjMRTreeData *rtdata;\n\n    size_t _len, offset=0;\n    unsigned x, found = 0;\n    char ended;//, tmpch;\n\n    if (rt->subnodes == NULL)\n        return;\n\n    subnodes = rt->subnodes;\n    while (offset != len)\n    {\n        found = 0;\n        for (it = subnodes->first; it != NULL; it = it->next) {\n            if (((COMPS_ObjMRTreeData*)it->data)->key[0] == key[offset]) {\n                found = 1;\n                break;\n            }\n        }\n        if (!found) { // not found in subnodes; create new subnode\n            rtd = comps_objmrtree_data_create(key+offset, ndata);\n            comps_hslist_append(subnodes, rtd, 0);\n            rt->len++;\n            return;\n        } else {\n            rtdata = (COMPS_ObjMRTreeData*)it->data;\n            ended = 0;\n            for (x=1; ;x++) {\n                if (rtdata->key[x] == 0) ended += 1;\n                if (x == len - offset) ended += 2;\n                if (ended != 0) break;\n                if (key[offset+x] != rtdata->key[x]) break;\n            }\n            if (ended == 3) { //keys equals; append new data\n                comps_objlist_append_x(rtdata->data, ndata);\n                rt->len++;\n                return;\n            } else if (ended == 2) { //global key ends first; make global leaf\n                comps_hslist_remove(subnodes, it);\n                it->next = NULL;\n                rtd = comps_objmrtree_data_create(key+offset, ndata);\n                comps_hslist_append(subnodes, rtd, 0);\n                ((COMPS_ObjMRTreeData*)subnodes->last->data)->subnodes->last = it;\n                ((COMPS_ObjMRTreeData*)subnodes->last->data)->subnodes->first = it;\n                _len = strlen(key + offset);\n                memmove(rtdata->key,rtdata->key + _len,\n                                    strlen(rtdata->key) - _len);\n                rtdata->key[strlen(rtdata->key) - _len] = 0;\n                rtdata->key = realloc(rtdata->key,\n                                      sizeof(char)* (strlen(rtdata->key)+1));\n                rt->len++;\n                return;\n            } else if (ended == 1) { //local key ends first; go deeper\n                subnodes = rtdata->subnodes;\n                offset += x;\n            } else { /* keys differ */\n                COMPS_ObjList *tmpdata = rtdata->data;\n                COMPS_HSList *tmphslist = rtdata->subnodes;\n\n                rtdata->subnodes = comps_hslist_create();\n                comps_hslist_init(rtdata->subnodes, NULL, NULL,\n                                  &comps_objmrtree_data_destroy_v);\n                int cmpret = strcmp(key+offset+x, rtdata->key+x);\n                rtdata->data = COMPS_OBJECT_CREATE(COMPS_ObjList, NULL);\n\n                if (cmpret > 0) {\n                    rtd = comps_objmrtree_data_create(rtdata->key+x,\n                                                      (COMPS_Object*)tmpdata);\n                    comps_hslist_destroy(&rtd->subnodes);\n                    rtd->subnodes = tmphslist;\n\n                    comps_hslist_append(rtdata->subnodes, rtd, 0);\n                    rtd = comps_objmrtree_data_create(key+offset+x,\n                                                     (COMPS_Object*)ndata);\n                    comps_hslist_append(rtdata->subnodes, rtd, 0);\n\n                } else {\n                    rtd = comps_objmrtree_data_create(key+offset+x,\n                                                     (COMPS_Object*)ndata);\n                    comps_hslist_append(rtdata->subnodes, rtd, 0);\n                    rtd = comps_objmrtree_data_create(rtdata->key+x,\n                                                     (COMPS_Object*)tmpdata);\n                    comps_hslist_destroy(&rtd->subnodes);\n                    rtd->subnodes = tmphslist;\n                    comps_hslist_append(rtdata->subnodes, rtd, 0);\n                }\n                rtdata->key = realloc(rtdata->key, sizeof(char)*(x+1));\n                rtdata->key[x] = 0;\n                rt->len++;\n                return;\n            }\n        }\n    }\n}\n\nvoid comps_objmrtree_set_n(COMPS_ObjMRTree *rt, char *key,\n                        size_t len, void *ndata) {\n    __comps_objmrtree_set(rt, key, len, ndata);\n}\n\nCOMPS_ObjList * comps_objmrtree_get(COMPS_ObjMRTree * rt, const char * key) {\n    COMPS_HSList * subnodes;\n    COMPS_HSListItem * it = NULL;\n    COMPS_ObjMRTreeData * rtdata;\n    unsigned int offset, len, x;\n    char found, ended;\n\n    len = strlen(key);\n    offset = 0;\n    subnodes = rt->subnodes;\n    while (offset != len) {\n        found = 0;\n        for (it = subnodes->first; it != NULL; it=it->next) {\n            if (((COMPS_ObjMRTreeData*)it->data)->key[0] == key[offset]) {\n                found = 1;\n                break;\n            }\n        }\n        if (!found)\n            return NULL;\n        rtdata = (COMPS_ObjMRTreeData*)it->data;\n\n        for (x=1; ;x++) {\n            ended=0;\n            if (rtdata->key[x] == 0) ended += 1;\n            if (x == len - offset) ended += 2;\n            if (ended != 0) break;\n            if (key[offset+x] != rtdata->key[x]) break;\n        }\n        if (ended == 3) return (COMPS_ObjList*)\n                               comps_object_incref((COMPS_Object*)rtdata->data);\n        else if (ended == 1) offset+=x;\n        else return NULL;\n        subnodes = ((COMPS_ObjMRTreeData*)it->data)->subnodes;\n    }\n    if (it)\n        return ((COMPS_ObjMRTreeData*)it->data)->data;\n    else return NULL;\n}\n\nvoid comps_objmrtree_unset(COMPS_ObjMRTree * rt, const char * key) {\n    COMPS_HSList * subnodes;\n    COMPS_HSListItem * it;\n    COMPS_ObjMRTreeData * rtdata;\n    unsigned int offset, len, x;\n    char found, ended;\n    COMPS_HSList * path;\n\n    struct Relation {\n        COMPS_HSList * parent_nodes;\n        COMPS_HSListItem * child_it;\n    } *relation;\n\n    path = comps_hslist_create();\n    comps_hslist_init(path, NULL, NULL, &free);\n\n    len = strlen(key);\n    offset = 0;\n    subnodes = rt->subnodes;\n    while (offset != len) {\n        found = 0;\n        for (it = subnodes->first; it != NULL; it=it->next) {\n            if (((COMPS_ObjMRTreeData*)it->data)->key[0] == key[offset]) {\n                found = 1;\n                break;\n            }\n        }\n        if (!found) {\n            comps_hslist_destroy(&path);\n            return;\n        }\n        rtdata = (COMPS_ObjMRTreeData*)it->data;\n\n        for (x=1; ;x++) {\n            ended=0;\n            if (rtdata->key[x] == 0) ended += 1;\n            if (x == len - offset) ended += 2;\n            if (ended != 0) break;\n            if (key[offset+x] != rtdata->key[x]) break;\n        }\n        if (ended == 3) {\n            /* remove node from tree only if there's no descendant*/\n            if (rtdata->subnodes->last == NULL) {\n                comps_hslist_remove(subnodes, it);\n                rt->len -= rtdata->data->len;\n                comps_objmrtree_data_destroy(rtdata);\n                free(it);\n            }\n            else {\n                rt->len -= rtdata->data->len;\n                comps_objlist_clear(rtdata->data);\n                rtdata->is_leaf = 0;\n            }\n\n            if (path->last == NULL) {\n                comps_hslist_destroy(&path);\n                return;\n            }\n            rtdata = (COMPS_ObjMRTreeData*)\n                     ((struct Relation*)path->last->data)->child_it->data;\n\n            /*remove all predecessor of deleted node (recursive) with no childs*/\n            while (rtdata->subnodes->last == NULL) {\n                //printf(\"removing '%s'\\n\", rtdata->key);\n                comps_objmrtree_data_destroy(rtdata);\n                comps_hslist_remove(\n                            ((struct Relation*)path->last->data)->parent_nodes,\n                            ((struct Relation*)path->last->data)->child_it);\n                free(((struct Relation*)path->last->data)->child_it);\n                it = path->last;\n                comps_hslist_remove(path, path->last);\n                free(it);\n                rtdata = (COMPS_ObjMRTreeData*)\n                         ((struct Relation*)path->last->data)->child_it->data;\n            }\n            comps_hslist_destroy(&path);\n            return;\n        }\n        else if (ended == 1) offset+=x;\n        else {\n            comps_hslist_destroy(&path);\n            return;\n        }\n        if ((relation = malloc(sizeof(struct Relation))) == NULL) {\n            comps_hslist_destroy(&path);\n            return;\n        }\n        subnodes = ((COMPS_ObjMRTreeData*)it->data)->subnodes;\n        relation->parent_nodes = subnodes;\n        relation->child_it = it;\n        comps_hslist_append(path, (void*)relation, 0);\n    }\n    comps_hslist_destroy(&path);\n    return;\n}\n\ninline void comps_objmrtree_pair_destroy_v(void * pair) {\n    free(((COMPS_ObjMRTreePair *)pair)->key);\n    free(pair);\n}\n\ninline COMPS_HSList* __comps_objmrtree_all(COMPS_ObjMRTree * rt, char keyvalpair) {\n    COMPS_HSList *to_process, *ret;\n    COMPS_HSListItem *hsit, *oldit;\n    size_t x;\n    struct Pair {\n        char *key;\n        void *data;\n        COMPS_HSList *subnodes;\n    } *pair, *current_pair=NULL;//, *oldpair=NULL;\n    COMPS_ObjMRTreePair *rtpair;\n\n    to_process = comps_hslist_create();\n    comps_hslist_init(to_process, NULL, NULL, &free);\n\n    ret = comps_hslist_create();\n    if (keyvalpair == 0)\n        comps_hslist_init(ret, NULL, NULL, &free);\n    else if (keyvalpair == 1)\n        comps_hslist_init(ret, NULL, NULL, NULL);\n    else\n        comps_hslist_init(ret, NULL, NULL, &comps_objmrtree_pair_destroy_v);\n\n    for (hsit = rt->subnodes->first; hsit != NULL; hsit = hsit->next) {\n        pair = malloc(sizeof(struct Pair));\n        pair->key = __comps_strcpy(((COMPS_ObjMRTreeData*)hsit->data)->key);\n        pair->data = ((COMPS_ObjMRTreeData*)hsit->data)->data;\n        pair->subnodes = ((COMPS_ObjMRTreeData*)hsit->data)->subnodes;\n        comps_hslist_append(to_process, pair, 0);\n    }\n    while (to_process->first) {\n        //oldpair = current_pair;\n        current_pair = to_process->first->data;\n        oldit = to_process->first;\n        comps_hslist_remove(to_process, to_process->first);\n        if (current_pair->data) {\n            if (keyvalpair == 0) {\n                comps_hslist_append(ret, __comps_strcpy(current_pair->key), 0);\n            } else if (keyvalpair == 1) {\n                comps_hslist_append(ret, current_pair->data, 0);\n            } else {\n                rtpair = malloc(sizeof(COMPS_ObjMRTreePair));\n                rtpair->key = __comps_strcpy(current_pair->key);\n                rtpair->data = current_pair->data;\n                comps_hslist_append(ret, rtpair, 0);\n            }\n        }\n        for (hsit = current_pair->subnodes->first, x = 0;\n             hsit != NULL; hsit = hsit->next, x++) {\n            pair = malloc(sizeof(struct Pair));\n            pair->key = __comps_strcat(current_pair->key,\n                                       ((COMPS_ObjMRTreeData*)hsit->data)->key);\n            pair->data = ((COMPS_ObjMRTreeData*)hsit->data)->data;\n            pair->subnodes = ((COMPS_ObjMRTreeData*)hsit->data)->subnodes;\n            comps_hslist_insert_at(to_process, x, pair, 0);\n        }\n        free(current_pair->key);\n        free(current_pair);\n        free(oldit);\n    }\n\n    comps_hslist_destroy(&to_process);\n    return ret;\n}\n\nCOMPS_HSList* comps_objmrtree_keys(COMPS_ObjMRTree * rt) {\n    return __comps_objmrtree_all(rt, 0);\n}\n\nCOMPS_HSList* comps_objmrtree_values(COMPS_ObjMRTree * rt) {\n    return __comps_objmrtree_all(rt, 1);\n}\n\nCOMPS_HSList* comps_objmrtree_pairs(COMPS_ObjMRTree * rt) {\n    return __comps_objmrtree_all(rt, 2);\n}\n\nvoid comps_objmrtree_clear(COMPS_ObjMRTree * rt) {\n    COMPS_HSListItem *it, *oldit;\n    if (rt == NULL) return;\n    if (rt->subnodes == NULL) return;\n    oldit = rt->subnodes->first;\n    it = (oldit)?oldit->next:NULL;\n    for (;it != NULL; it=it->next) {\n        if (rt->subnodes->data_destructor != NULL)\n            rt->subnodes->data_destructor(oldit->data);\n        free(oldit);\n        oldit = it;\n    }\n    if (oldit) {\n        if (rt->subnodes->data_destructor != NULL)\n            rt->subnodes->data_destructor(oldit->data);\n        free(oldit);\n    }\n}\n\nchar comps_objmrtree_paircmp(void *obj1, void *obj2) {\n    if (strcmp(((COMPS_ObjMRTreePair*)obj1)->key,\n               ((COMPS_ObjMRTreePair*)obj2)->key) != 0)\n        return 0;\n    return comps_object_cmp((COMPS_Object*)((COMPS_ObjMRTreePair*)obj1)->data,\n                            (COMPS_Object*)((COMPS_ObjMRTreePair*)obj1)->data);\n}\n\nsigned char comps_objmrtree_cmp(COMPS_ObjMRTree *ort1, COMPS_ObjMRTree *ort2) {\n    COMPS_HSList *values1, *values2;\n    COMPS_HSListItem *it;\n    COMPS_Set *set1, *set2;\n    signed char ret;\n    values1 = comps_objmrtree_pairs(ort1);\n    values2 = comps_objmrtree_pairs(ort2);\n    set1 = comps_set_create();\n    comps_set_init(set1, NULL, NULL, NULL, &comps_objmrtree_paircmp);\n    set2 = comps_set_create();\n    comps_set_init(set2, NULL, NULL, NULL, &comps_objmrtree_paircmp);\n    for (it = values1->first; it != NULL; it = it->next) {\n        comps_set_add(set1, it->data);\n    }\n    for (it = values2->first; it != NULL; it = it->next) {\n        comps_set_add(set2, it->data);\n    }\n\n    ret = comps_set_cmp(set1, set2);\n    comps_set_destroy(&set1);\n    comps_set_destroy(&set2);\n    //printf(\"objmrtree cmp %d\\n\", !ret);\n\n    comps_hslist_destroy(&values1);\n    comps_hslist_destroy(&values2);\n    return !ret;\n}\nCOMPS_CMP_u(objmrtree, COMPS_ObjMRTree)\n\nCOMPS_ObjectInfo COMPS_ObjMRTree_ObjInfo = {\n    .obj_size = sizeof(COMPS_ObjMRTree),\n    .constructor = &comps_objmrtree_create_u,\n    .destructor = &comps_objmrtree_destroy_u,\n    .copy = &comps_objmrtree_copy_u,\n    .obj_cmp = &comps_objmrtree_cmp_u\n};\n", "/* libcomps - C alternative to yum.comps library\n * Copyright (C) 2013 Jindrich Luza\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to  Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,\n * USA\n */\n\n#include \"comps_objradix.h\"\n#include \"comps_set.h\"\n#include <stdio.h>\n\nvoid comps_objrtree_data_destroy(COMPS_ObjRTreeData * rtd) {\n    free(rtd->key);\n    comps_object_destroy(rtd->data);\n    comps_hslist_destroy(&rtd->subnodes);\n    free(rtd);\n}\n\ninline void comps_objrtree_data_destroy_v(void * rtd) {\n    comps_objrtree_data_destroy((COMPS_ObjRTreeData*)rtd);\n}\n\ninline COMPS_ObjRTreeData * __comps_objrtree_data_create(char *key,\n                                                   size_t keylen,\n                                                   COMPS_Object *data){\n    COMPS_ObjRTreeData * rtd;\n    if ((rtd = malloc(sizeof(*rtd))) == NULL)\n        return NULL;\n    if ((rtd->key = malloc(sizeof(char) * (keylen+1))) == NULL) {\n        free(rtd);\n        return NULL;\n    }\n    memcpy(rtd->key, key, sizeof(char)*keylen);\n    rtd->key[keylen] = 0;\n    rtd->data = data;\n    if (data != NULL) {\n        rtd->is_leaf = 1;\n    }\n    rtd->subnodes = comps_hslist_create();\n    comps_hslist_init(rtd->subnodes, NULL, NULL, &comps_objrtree_data_destroy_v);\n    return rtd;\n}\n\nCOMPS_ObjRTreeData * comps_objrtree_data_create(char *key, COMPS_Object *data) {\n    COMPS_ObjRTreeData * rtd;\n    rtd = __comps_objrtree_data_create(key, strlen(key), data);\n    return rtd;\n}\n\nCOMPS_ObjRTreeData * comps_objrtree_data_create_n(char *key, size_t keylen,\n                                                  COMPS_Object *data) {\n    COMPS_ObjRTreeData * rtd;\n    rtd = __comps_objrtree_data_create(key, keylen, data);\n    return rtd;\n}\n\nstatic void comps_objrtree_create(COMPS_ObjRTree *rtree, COMPS_Object **args) {\n    (void)args;\n    rtree->subnodes = comps_hslist_create();\n    comps_hslist_init(rtree->subnodes, NULL, NULL, &comps_objrtree_data_destroy_v);\n    if (rtree->subnodes == NULL) {\n        COMPS_OBJECT_DESTROY(rtree);\n        return;\n    }\n    rtree->len = 0;\n}\nvoid comps_objrtree_create_u(COMPS_Object * obj, COMPS_Object **args) {\n    (void)args;\n    comps_objrtree_create((COMPS_ObjRTree*)obj, NULL);\n}\n\nstatic void comps_objrtree_destroy(COMPS_ObjRTree * rt) {\n    comps_hslist_destroy(&(rt->subnodes));\n}\nvoid comps_objrtree_destroy_u(COMPS_Object *obj) {\n    comps_objrtree_destroy((COMPS_ObjRTree*)obj);\n}\n\nCOMPS_ObjRTree * comps_objrtree_clone(COMPS_ObjRTree *rt) {\n\n    COMPS_HSList *to_clone, *tmplist, *new_subnodes;\n    COMPS_ObjRTree *ret;\n    COMPS_HSListItem *it, *it2;\n    COMPS_ObjRTreeData *rtdata;\n    COMPS_Object *new_data;\n\n    if (!rt) return NULL;\n\n    to_clone = comps_hslist_create();\n    comps_hslist_init(to_clone, NULL, NULL, NULL);\n    ret = COMPS_OBJECT_CREATE(COMPS_ObjRTree, NULL);\n    ret->len = rt->len;\n\n    for (it = rt->subnodes->first; it != NULL; it = it->next) {\n        rtdata = comps_objrtree_data_create(\n                                    ((COMPS_ObjRTreeData*)it->data)->key, NULL);\n        if (((COMPS_ObjRTreeData*)it->data)->data != NULL)\n            new_data = comps_object_copy(((COMPS_ObjRTreeData*)it->data)->data);\n        else\n            new_data = NULL;\n        comps_hslist_destroy(&rtdata->subnodes);\n        rtdata->subnodes = ((COMPS_ObjRTreeData*)it->data)->subnodes;\n        rtdata->data = new_data;\n        comps_hslist_append(ret->subnodes, rtdata, 0);\n        comps_hslist_append(to_clone, rtdata, 0);\n    }\n\n    while (to_clone->first) {\n        it2 = to_clone->first;\n        tmplist = ((COMPS_ObjRTreeData*)it2->data)->subnodes;\n        comps_hslist_remove(to_clone, to_clone->first);\n\n        new_subnodes = comps_hslist_create();\n        comps_hslist_init(new_subnodes, NULL, NULL, &comps_objrtree_data_destroy_v);\n        for (it = tmplist->first; it != NULL; it = it->next) {\n            rtdata = comps_objrtree_data_create(\n                                      ((COMPS_ObjRTreeData*)it->data)->key, NULL);\n            if (((COMPS_ObjRTreeData*)it->data)->data != NULL)\n                new_data = comps_object_copy(((COMPS_ObjRTreeData*)it->data)->data);\n            else\n                new_data = NULL;\n            comps_hslist_destroy(&rtdata->subnodes);\n            rtdata->subnodes = ((COMPS_ObjRTreeData*)it->data)->subnodes;\n            rtdata->data = new_data;\n            comps_hslist_append(new_subnodes, rtdata, 0);\n            comps_hslist_append(to_clone, rtdata, 0);\n        }\n        ((COMPS_ObjRTreeData*)it2->data)->subnodes = new_subnodes;\n        free(it2);\n    }\n    comps_hslist_destroy(&to_clone);\n    return ret;\n}\nvoid comps_objrtree_copy(COMPS_ObjRTree *rt1, COMPS_ObjRTree *rt2){\n    COMPS_HSList *to_clone, *tmplist, *new_subnodes;\n    COMPS_HSListItem *it, *it2;\n    COMPS_ObjRTreeData *rtdata;\n    COMPS_Object *new_data;\n\n    rt1->subnodes = comps_hslist_create();\n    comps_hslist_init(rt1->subnodes, NULL, NULL, &comps_objrtree_data_destroy_v);\n    if (rt1->subnodes == NULL) {\n        COMPS_OBJECT_DESTROY(rt1);\n        return;\n    }\n    rt1->len = 0;\n\n    to_clone = comps_hslist_create();\n    comps_hslist_init(to_clone, NULL, NULL, NULL);\n\n    for (it = rt2->subnodes->first; it != NULL; it = it->next) {\n        rtdata = comps_objrtree_data_create(\n                                    ((COMPS_ObjRTreeData*)it->data)->key, NULL);\n        if (((COMPS_ObjRTreeData*)it->data)->data != NULL)\n            new_data = comps_object_copy(((COMPS_ObjRTreeData*)it->data)->data);\n        else\n            new_data = NULL;\n        comps_hslist_destroy(&rtdata->subnodes);\n        rtdata->subnodes = ((COMPS_ObjRTreeData*)it->data)->subnodes;\n        rtdata->data = new_data;\n        comps_hslist_append(rt1->subnodes, rtdata, 0);\n        comps_hslist_append(to_clone, rtdata, 0);\n    }\n\n    while (to_clone->first) {\n        it2 = to_clone->first;\n        tmplist = ((COMPS_ObjRTreeData*)it2->data)->subnodes;\n        comps_hslist_remove(to_clone, to_clone->first);\n\n        new_subnodes = comps_hslist_create();\n        comps_hslist_init(new_subnodes, NULL, NULL, &comps_objrtree_data_destroy_v);\n        for (it = tmplist->first; it != NULL; it = it->next) {\n            rtdata = comps_objrtree_data_create(\n                                      ((COMPS_ObjRTreeData*)it->data)->key, NULL);\n            if (((COMPS_ObjRTreeData*)it->data)->data != NULL)\n                new_data = comps_object_copy(((COMPS_ObjRTreeData*)it->data)->data);\n            else\n                new_data = NULL;\n            comps_hslist_destroy(&rtdata->subnodes);\n            rtdata->subnodes = ((COMPS_ObjRTreeData*)it->data)->subnodes;\n            rtdata->data = new_data;\n            comps_hslist_append(new_subnodes, rtdata, 0);\n            comps_hslist_append(to_clone, rtdata, 0);\n        }\n        ((COMPS_ObjRTreeData*)it2->data)->subnodes = new_subnodes;\n        free(it2);\n    }\n    comps_hslist_destroy(&to_clone);\n\n}\nCOMPS_COPY_u(objrtree, COMPS_ObjRTree) /*comps_utils.h macro*/\n\nvoid comps_objrtree_copy_shallow(COMPS_ObjRTree *rt1, COMPS_ObjRTree *rt2){\n    COMPS_HSList *to_clone, *tmplist, *new_subnodes;\n    COMPS_HSListItem *it, *it2;\n    COMPS_ObjRTreeData *rtdata;\n    COMPS_Object *new_data;\n\n    rt1->subnodes = comps_hslist_create();\n    comps_hslist_init(rt1->subnodes, NULL, NULL, &comps_objrtree_data_destroy_v);\n    if (rt1->subnodes == NULL) {\n        COMPS_OBJECT_DESTROY(rt1);\n        return;\n    }\n    rt1->len = 0;\n\n    to_clone = comps_hslist_create();\n    comps_hslist_init(to_clone, NULL, NULL, NULL);\n\n    for (it = rt2->subnodes->first; it != NULL; it = it->next) {\n        rtdata = comps_objrtree_data_create(\n                                    ((COMPS_ObjRTreeData*)it->data)->key, NULL);\n        if (((COMPS_ObjRTreeData*)it->data)->data != NULL)\n            new_data = COMPS_OBJECT_INCREF(((COMPS_ObjRTreeData*)it->data)->data);\n        else\n            new_data = NULL;\n        comps_hslist_destroy(&rtdata->subnodes);\n        rtdata->subnodes = ((COMPS_ObjRTreeData*)it->data)->subnodes;\n        rtdata->data = new_data;\n        comps_hslist_append(rt1->subnodes, rtdata, 0);\n        comps_hslist_append(to_clone, rtdata, 0);\n    }\n\n    while (to_clone->first) {\n        it2 = to_clone->first;\n        tmplist = ((COMPS_ObjRTreeData*)it2->data)->subnodes;\n        comps_hslist_remove(to_clone, to_clone->first);\n\n        new_subnodes = comps_hslist_create();\n        comps_hslist_init(new_subnodes, NULL, NULL, &comps_objrtree_data_destroy_v);\n        for (it = tmplist->first; it != NULL; it = it->next) {\n            rtdata = comps_objrtree_data_create(\n                                      ((COMPS_ObjRTreeData*)it->data)->key, NULL);\n            if (((COMPS_ObjRTreeData*)it->data)->data != NULL)\n                new_data = comps_object_incref(((COMPS_ObjRTreeData*)it->data)->data);\n            else\n                new_data = NULL;\n            comps_hslist_destroy(&rtdata->subnodes);\n            rtdata->subnodes = ((COMPS_ObjRTreeData*)it->data)->subnodes;\n            rtdata->data = new_data;\n            comps_hslist_append(new_subnodes, rtdata, 0);\n            comps_hslist_append(to_clone, rtdata, 0);\n        }\n        ((COMPS_ObjRTreeData*)it2->data)->subnodes = new_subnodes;\n        free(it2);\n    }\n    comps_hslist_destroy(&to_clone);\n}\n\nvoid comps_objrtree_values_walk(COMPS_ObjRTree * rt, void* udata,\n                              void (*walk_f)(void*, COMPS_Object*)) {\n    COMPS_HSList *tmplist, *tmp_subnodes;\n    COMPS_HSListItem *it;\n    tmplist = comps_hslist_create();\n    comps_hslist_init(tmplist, NULL, NULL, NULL);\n    comps_hslist_append(tmplist, rt->subnodes, 0);\n    while (tmplist->first != NULL) {\n        it = tmplist->first;\n        comps_hslist_remove(tmplist, tmplist->first);\n        tmp_subnodes = (COMPS_HSList*)it->data;\n        for (it = tmp_subnodes->first; it != NULL; it=it->next) {\n            if (((COMPS_ObjRTreeData*)it->data)->subnodes->first) {\n                comps_hslist_append(tmplist,\n                                    ((COMPS_ObjRTreeData*)it->data)->subnodes, 0);\n            }\n            if (((COMPS_ObjRTreeData*)it->data)->data != NULL) {\n               walk_f(udata, ((COMPS_ObjRTreeData*)it->data)->data);\n            }\n        }\n    }\n    comps_hslist_destroy(&tmplist);\n}\n\nchar comps_objrtree_paircmp(void *obj1, void *obj2) {\n    //printf(\"comparing %s with %s\\n\", ((COMPS_ObjRTreePair*)obj1)->key,\n    //                               ((COMPS_ObjRTreePair*)obj2)->key);\n    if (strcmp(((COMPS_ObjRTreePair*)obj1)->key,\n               ((COMPS_ObjRTreePair*)obj2)->key) != 0)\n        return 0;\n    return comps_object_cmp(((COMPS_ObjRTreePair*)obj1)->data,\n                            ((COMPS_ObjRTreePair*)obj2)->data);\n}\n\n\nsigned char comps_objrtree_cmp(COMPS_ObjRTree *ort1, COMPS_ObjRTree *ort2) {\n    COMPS_HSList *values1, *values2;\n    COMPS_HSListItem *it;\n    COMPS_Set *set1, *set2;\n    signed char ret;\n    values1 = comps_objrtree_pairs(ort1);\n    values2 = comps_objrtree_pairs(ort2);\n    set1 = comps_set_create();\n    comps_set_init(set1, NULL, NULL, NULL, &comps_objrtree_paircmp);\n    set2 = comps_set_create();\n    comps_set_init(set2, NULL, NULL, NULL, &comps_objrtree_paircmp);\n    for (it = values1->first; it != NULL; it = it->next) {\n        comps_set_add(set1, it->data);\n    }\n    for (it = values2->first; it != NULL; it = it->next) {\n        comps_set_add(set2, it->data);\n    }\n\n    ret = comps_set_cmp(set1, set2);\n    comps_set_destroy(&set1);\n    comps_set_destroy(&set2);\n    //printf(\"objrtree cmp %d\\n\", !ret);\n    \n    //char *str;\n    /*for (it = values1->first; it != NULL; it = it->next) {\n        str = comps_object_tostr(((COMPS_ObjRTreePair*)it->data)->data);\n        printf(\"dict item %s=%s\\n\", ((COMPS_ObjRTreePair*)it->data)->key, str);\n        free(str);\n    }\n    printf(\"----------\\n\");\n    for (it = values2->first; it != NULL; it = it->next) {\n        str = comps_object_tostr(((COMPS_ObjRTreePair*)it->data)->data);\n        printf(\"dict item %s=%s\\n\", ((COMPS_ObjRTreePair*)it->data)->key, str);\n        free(str);\n    }\n    printf(\"cmp objrtree ret:%d\\n\", ret);*/\n    comps_hslist_destroy(&values1);\n    comps_hslist_destroy(&values2);\n    return ret==0;\n}\nCOMPS_CMP_u(objrtree, COMPS_ObjRTree)\n\nvoid __comps_objrtree_set(COMPS_ObjRTree *rt, char *key, size_t len,\n                          COMPS_Object *ndata) {\n\n    COMPS_HSListItem *it, *lesser;\n    COMPS_HSList *subnodes;\n    COMPS_ObjRTreeData *rtd;\n    static COMPS_ObjRTreeData *rtdata;\n\n    size_t _len, offset=0;\n    unsigned x, found = 0;\n    char ended;\n\n    //len = strlen(key);\n\n    if (rt->subnodes == NULL)\n        return;\n\n    subnodes = rt->subnodes;\n    while (offset != len)\n    {\n        found = 0;\n        lesser = NULL;\n        for (it = subnodes->first; it != NULL; it=it->next) {\n            if (((COMPS_ObjRTreeData*)it->data)->key[0] == key[offset]) {\n                found = 1;\n                break;\n            } else if (((COMPS_ObjRTreeData*)it->data)->key[0] < key[offset]) {\n                lesser = it;\n            }\n        }\n        if (!found) { // not found in subnodes; create new subnode\n            rtd = comps_objrtree_data_create_n(key+offset, len-offset, ndata);\n            if (!lesser) {\n                comps_hslist_prepend(subnodes, rtd, 0);\n            } else {\n                comps_hslist_insert_after(subnodes, lesser, rtd, 0);\n            }\n            rt->len++;\n            return;\n        } else {\n            rtdata = (COMPS_ObjRTreeData*)it->data;\n            ended = 0;\n            for (x=1; ;x++) {\n                if (rtdata->key[x] == 0) ended += 1;\n                if (x == len - offset) ended += 2;\n                if (ended != 0) break;\n                if (key[offset+x] != rtdata->key[x]) break;\n            }\n            if (ended == 3) { //keys equals; data replacement\n                comps_object_destroy(rtdata->data);\n                rtdata->data = ndata;\n                return;\n            } else if (ended == 2) { //global key ends first; make global leaf\n                //printf(\"ended2\\n\");\n                comps_hslist_remove(subnodes, it);\n                it->next = NULL;\n                rtd = comps_objrtree_data_create_n(key+offset, len-offset, ndata);\n                comps_hslist_append(subnodes, rtd, 0);\n                ((COMPS_ObjRTreeData*)subnodes->last->data)->subnodes->last = it;\n                ((COMPS_ObjRTreeData*)subnodes->last->data)->subnodes->first = it;\n                _len = len - offset;\n\n                memmove(rtdata->key,rtdata->key+_len,\n                        strlen(rtdata->key) - _len);\n                rtdata->key[strlen(rtdata->key) - _len] = 0;\n                rtdata->key = realloc(rtdata->key,\n                                      sizeof(char)* (strlen(rtdata->key)+1));\n                rt->len++;\n                return;\n            } else if (ended == 1) { //local key ends first; go deeper\n                subnodes = rtdata->subnodes;\n                offset += x;\n            } else {\n                COMPS_Object *tmpdata = rtdata->data;\n                COMPS_HSList *tmphslist = rtdata->subnodes;\n                //tmpch = rtdata->key[x];             // split mutual key\n                rtdata->subnodes = comps_hslist_create();\n                comps_hslist_init(rtdata->subnodes, NULL, NULL,\n                                  &comps_objrtree_data_destroy_v);\n                int cmpret = strcmp(key+offset+x, rtdata->key+x);\n                rtdata->data = NULL;\n\n                if (cmpret > 0) {\n                    rtd = comps_objrtree_data_create(rtdata->key+x, tmpdata);\n                    comps_hslist_destroy(&rtd->subnodes);\n                    rtd->subnodes = tmphslist;\n\n                    comps_hslist_append(rtdata->subnodes,rtd, 0);\n                    rtd = comps_objrtree_data_create(key+offset+x, ndata);\n                    comps_hslist_append(rtdata->subnodes, rtd, 0);\n\n                } else {\n                    rtd = comps_objrtree_data_create(key+offset+x, ndata);\n                    comps_hslist_append(rtdata->subnodes, rtd, 0);\n                    rtd = comps_objrtree_data_create(rtdata->key+x, tmpdata);\n                    comps_hslist_destroy(&rtd->subnodes);\n                    rtd->subnodes = tmphslist;\n                    comps_hslist_append(rtdata->subnodes, rtd, 0);\n                }\n                rtdata->key = realloc(rtdata->key, sizeof(char)*(x+1));\n                rtdata->key[x] = 0;\n                rt->len++;\n                return;\n            }\n        }\n    }\n}\n\nvoid comps_objrtree_set_x(COMPS_ObjRTree *rt, char *key, COMPS_Object *data) {\n    __comps_objrtree_set(rt, key, strlen(key), data);\n}\nvoid comps_objrtree_set(COMPS_ObjRTree *rt, char *key, COMPS_Object *data) {\n    __comps_objrtree_set(rt, key, strlen(key), comps_object_incref(data));\n}\nvoid comps_objrtree_set_n(COMPS_ObjRTree *rt, char *key, size_t len,\n                          COMPS_Object *data) {\n    __comps_objrtree_set(rt, key, len, data);\n}\nvoid comps_objrtree_set_nx(COMPS_ObjRTree *rt, char *key, size_t len,\n                           COMPS_Object *data) {\n    __comps_objrtree_set(rt, key, len, comps_object_incref(data));\n}\n\nCOMPS_Object* __comps_objrtree_get(COMPS_ObjRTree * rt, const char * key) {\n    COMPS_HSList * subnodes;\n    COMPS_HSListItem * it = NULL;\n    COMPS_ObjRTreeData * rtdata;\n    unsigned int offset, len, x;\n    char found, ended;\n\n    len = strlen(key);\n    offset = 0;\n    subnodes = rt->subnodes;\n\n    while (offset != len) {\n        found = 0;\n        for (it = subnodes->first; it != NULL; it=it->next) {\n            if (((COMPS_ObjRTreeData*)it->data)->key[0] == key[offset]) {\n                found = 1;\n                break;\n            }\n        }\n        if (!found) {\n            return NULL;\n        }\n        rtdata = (COMPS_ObjRTreeData*)it->data;\n\n        for (x=1; ;x++) {\n            ended=0;\n            if (x == strlen(rtdata->key)) ended += 1;\n            if (x == len-offset) ended += 2;\n            if (ended != 0) break;\n            if (key[offset+x] != rtdata->key[x]) break;\n        }\n        if (ended == 3) {\n            return rtdata->data;\n        }\n        else if (ended == 1) offset+=x;\n        else {\n            return NULL;\n        }\n        subnodes = ((COMPS_ObjRTreeData*)it->data)->subnodes;\n    }\n    if (it != NULL) {\n        return ((COMPS_ObjRTreeData*)it->data)->data;\n    }\n    else {\n        return NULL;\n    }\n}\nCOMPS_Object* comps_objrtree_get(COMPS_ObjRTree * rt, const char * key) {\n    return comps_object_incref(__comps_objrtree_get(rt, key));\n}\nCOMPS_Object* comps_objrtree_get_x(COMPS_ObjRTree * rt, const char * key) {\n    return __comps_objrtree_get(rt, key);\n}\n\nvoid comps_objrtree_unset(COMPS_ObjRTree * rt, const char * key) {\n    COMPS_HSList * subnodes;\n    COMPS_HSListItem * it;\n    COMPS_ObjRTreeData * rtdata;\n    unsigned int offset, len, x;\n    char found, ended;\n    COMPS_HSList * path;\n\n    struct Relation {\n        COMPS_HSList * parent_nodes;\n        COMPS_HSListItem * child_it;\n    } *relation;\n\n    path = comps_hslist_create();\n    comps_hslist_init(path, NULL, NULL, &free);\n\n    len = strlen(key);\n    offset = 0;\n    subnodes = rt->subnodes;\n    while (offset != len) {\n        found = 0;\n        for (it = subnodes->first; it != NULL; it=it->next) {\n            if (((COMPS_ObjRTreeData*)it->data)->key[0] == key[offset]) {\n                found = 1;\n                break;\n            }\n        }\n        if (!found) {\n            comps_hslist_destroy(&path);\n            return;\n        }\n        rtdata = (COMPS_ObjRTreeData*)it->data;\n\n        for (x=1; ;x++) {\n            ended=0;\n            if (rtdata->key[x] == 0) ended += 1;\n            if (x == len - offset) ended += 2;\n            if (ended != 0) break;\n            if (key[offset+x] != rtdata->key[x]) break;\n        }\n        if (ended == 3) {\n            /* remove node from tree only if there's no descendant*/\n            if (rtdata->subnodes->last == NULL) {\n                //printf(\"removing all\\n\");\n                comps_hslist_remove(subnodes, it);\n                comps_objrtree_data_destroy(rtdata);\n                free(it);\n            }\n            else {\n                //printf(\"removing data only\\n\");\n                comps_object_destroy(rtdata->data);\n                rtdata->is_leaf = 0;\n                rtdata->data = NULL;\n            }\n\n            if (path->last == NULL) {\n                comps_hslist_destroy(&path);\n                return;\n            }\n            rtdata = (COMPS_ObjRTreeData*)\n                     ((struct Relation*)path->last->data)->child_it->data;\n\n            /*remove all predecessor of deleted node (recursive) with no childs*/\n            while (rtdata->subnodes->last == NULL) {\n                //printf(\"removing '%s'\\n\", rtdata->key);\n                comps_objrtree_data_destroy(rtdata);\n                comps_hslist_remove(\n                            ((struct Relation*)path->last->data)->parent_nodes,\n                            ((struct Relation*)path->last->data)->child_it);\n                free(((struct Relation*)path->last->data)->child_it);\n                it = path->last;\n                comps_hslist_remove(path, path->last);\n                free(it);\n                rtdata = (COMPS_ObjRTreeData*)\n                         ((struct Relation*)path->last->data)->child_it->data;\n            }\n            comps_hslist_destroy(&path);\n            return;\n        }\n        else if (ended == 1) offset+=x;\n        else {\n            comps_hslist_destroy(&path);\n            return;\n        }\n        if ((relation = malloc(sizeof(struct Relation))) == NULL) {\n            comps_hslist_destroy(&path);\n            return;\n        }\n        subnodes = ((COMPS_ObjRTreeData*)it->data)->subnodes;\n        relation->parent_nodes = subnodes;\n        relation->child_it = it;\n        comps_hslist_append(path, (void*)relation, 0);\n    }\n    comps_hslist_destroy(&path);\n    return;\n}\n\nvoid comps_objrtree_clear(COMPS_ObjRTree * rt) {\n    COMPS_HSListItem *it, *oldit;\n    if (rt==NULL) return;\n    if (rt->subnodes == NULL) return;\n    oldit = rt->subnodes->first;\n    it = (oldit)?oldit->next:NULL;\n    for (;it != NULL; it=it->next) {\n        comps_object_destroy(oldit->data);\n        free(oldit);\n        oldit = it;\n    }\n    if (oldit) {\n        comps_object_destroy(oldit->data);\n        free(oldit);\n    }\n}\n\ninline COMPS_HSList* __comps_objrtree_all(COMPS_ObjRTree * rt, char keyvalpair) {\n    COMPS_HSList *to_process, *ret;\n    COMPS_HSListItem *hsit, *oldit;\n    size_t x;\n    struct Pair {\n        char *key;\n        void *data;\n        COMPS_HSList *subnodes;\n    } *pair, *current_pair=NULL;//, *oldpair=NULL;\n    COMPS_ObjRTreePair *rtpair;\n\n    to_process = comps_hslist_create();\n    comps_hslist_init(to_process, NULL, NULL, &free);\n\n    ret = comps_hslist_create();\n    if (keyvalpair == 0)\n        comps_hslist_init(ret, NULL, NULL, &free);\n    else if (keyvalpair == 1)\n        comps_hslist_init(ret, NULL, NULL, NULL);\n    else\n        comps_hslist_init(ret, NULL, NULL, &comps_objrtree_pair_destroy_v);\n\n    for (hsit = rt->subnodes->first; hsit != NULL; hsit = hsit->next) {\n        pair = malloc(sizeof(struct Pair));\n        pair->key = __comps_strcpy(((COMPS_ObjRTreeData*)hsit->data)->key);\n        pair->data = ((COMPS_ObjRTreeData*)hsit->data)->data;\n        pair->subnodes = ((COMPS_ObjRTreeData*)hsit->data)->subnodes;\n        comps_hslist_append(to_process, pair, 0);\n    }\n    while (to_process->first) {\n        //oldpair = current_pair;\n        current_pair = to_process->first->data;\n        oldit = to_process->first;\n        comps_hslist_remove(to_process, to_process->first);\n        if (current_pair->data) {\n            if (keyvalpair == 0) {\n                comps_hslist_append(ret, __comps_strcpy(current_pair->key), 0);\n            } else if (keyvalpair == 1) {\n                comps_hslist_append(ret, current_pair->data, 0);\n            } else {\n                rtpair = malloc(sizeof(COMPS_ObjRTreePair));\n                rtpair->key = __comps_strcpy(current_pair->key);\n                rtpair->data = current_pair->data;\n                comps_hslist_append(ret, rtpair, 0);\n            }\n        }\n        for (hsit = current_pair->subnodes->first, x = 0;\n             hsit != NULL; hsit = hsit->next, x++) {\n            pair = malloc(sizeof(struct Pair));\n            pair->key = __comps_strcat(current_pair->key,\n                                       ((COMPS_ObjRTreeData*)hsit->data)->key);\n            pair->data = ((COMPS_ObjRTreeData*)hsit->data)->data;\n            pair->subnodes = ((COMPS_ObjRTreeData*)hsit->data)->subnodes;\n            comps_hslist_insert_at(to_process, x, pair, 0);\n        }\n        free(current_pair->key);\n        free(current_pair);\n        free(oldit);\n    }\n\n    comps_hslist_destroy(&to_process);\n    return ret;\n}\n\nvoid comps_objrtree_unite(COMPS_ObjRTree *rt1, COMPS_ObjRTree *rt2) {\n    COMPS_HSList *tmplist, *tmp_subnodes;\n    COMPS_HSListItem *it;\n    struct Pair {\n        COMPS_HSList * subnodes;\n        char * key;\n    } *pair, *parent_pair;\n\n    pair = malloc(sizeof(struct Pair));\n    pair->subnodes = rt2->subnodes;\n    pair->key = NULL;\n\n    tmplist = comps_hslist_create();\n    comps_hslist_init(tmplist, NULL, NULL, &free);\n    comps_hslist_append(tmplist, pair, 0);\n\n    while (tmplist->first != NULL) {\n        it = tmplist->first;\n        comps_hslist_remove(tmplist, tmplist->first);\n        tmp_subnodes = ((struct Pair*)it->data)->subnodes;\n        parent_pair = (struct Pair*) it->data;\n        //printf(\"key-part:%s\\n\", parent_pair->key);\n        free(it);\n\n        for (it = tmp_subnodes->first; it != NULL; it=it->next) {\n            pair = malloc(sizeof(struct Pair));\n            pair->subnodes = ((COMPS_ObjRTreeData*)it->data)->subnodes;\n\n            if (parent_pair->key != NULL) {\n                pair->key = malloc(sizeof(char)\n                               * (strlen(((COMPS_ObjRTreeData*)it->data)->key)\n                               + strlen(parent_pair->key) + 1));\n                memcpy(pair->key, parent_pair->key,\n                       sizeof(char) * strlen(parent_pair->key));\n                memcpy(pair->key + strlen(parent_pair->key),\n                       ((COMPS_ObjRTreeData*)it->data)->key,\n                       sizeof(char)*(strlen(((COMPS_ObjRTreeData*)it->data)->key)+1));\n            } else {\n                pair->key = malloc(sizeof(char)*\n                                (strlen(((COMPS_ObjRTreeData*)it->data)->key) +1));\n                memcpy(pair->key, ((COMPS_ObjRTreeData*)it->data)->key,\n                       sizeof(char)*(strlen(((COMPS_ObjRTreeData*)it->data)->key)+1));\n            }\n            /* current node has data */\n            if (((COMPS_ObjRTreeData*)it->data)->data != NULL) {\n                    comps_objrtree_set(rt1, pair->key,\n                                      (((COMPS_ObjRTreeData*)it->data)->data));\n            }\n            if (((COMPS_ObjRTreeData*)it->data)->subnodes->first) {\n                comps_hslist_append(tmplist, pair, 0);\n            } else {\n                free(pair->key);\n                free(pair);\n            }\n        }\n        free(parent_pair->key);\n        free(parent_pair);\n    }\n    comps_hslist_destroy(&tmplist);\n}\n\nCOMPS_ObjRTree* comps_objrtree_union(COMPS_ObjRTree *rt1, COMPS_ObjRTree *rt2){\n    COMPS_ObjRTree *ret;\n    ret = comps_objrtree_clone(rt1);\n    comps_objrtree_unite(ret, rt2);\n    return ret;\n}\n\n\nCOMPS_HSList* comps_objrtree_keys(COMPS_ObjRTree * rt) {\n    return __comps_objrtree_all(rt, 0);\n}\n\nCOMPS_HSList* comps_objrtree_values(COMPS_ObjRTree * rt) {\n    return __comps_objrtree_all(rt, 1);\n}\n\nCOMPS_HSList* comps_objrtree_pairs(COMPS_ObjRTree * rt) {\n    return __comps_objrtree_all(rt, 2);\n}\n\n\ninline void comps_objrtree_pair_destroy(COMPS_ObjRTreePair * pair) {\n    free(pair->key);\n    free(pair);\n}\n\ninline void comps_objrtree_pair_destroy_v(void * pair) {\n    free(((COMPS_ObjRTreePair *)pair)->key);\n    free(pair);\n}\n\nCOMPS_ObjectInfo COMPS_ObjRTree_ObjInfo = {\n    .obj_size = sizeof(COMPS_ObjRTree),\n    .constructor = &comps_objrtree_create_u,\n    .destructor = &comps_objrtree_destroy_u,\n    .copy = &comps_objrtree_copy_u,\n    .obj_cmp = &comps_objrtree_cmp_u\n};\n", "/* libcomps - C alternative to yum.comps library\n * Copyright (C) 2013 Jindrich Luza\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to  Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,\n * USA\n */\n\n#include \"comps_radix.h\"\n#include \"comps_utils.h\"\n\n#include <stdio.h>\n\nvoid comps_rtree_data_destroy(COMPS_RTreeData * rtd) {\n    free(rtd->key);\n    if ((rtd->data) && (*rtd->data_destructor))\n        (*rtd->data_destructor)(rtd->data);\n    comps_hslist_destroy(&rtd->subnodes);\n    free(rtd);\n}\n\ninline void comps_rtree_data_destroy_v(void * rtd) {\n    comps_rtree_data_destroy((COMPS_RTreeData*)rtd);\n}\n\ninline COMPS_RTreeData * __comps_rtree_data_create(COMPS_RTree *rt, char *key,\n                                                   unsigned int keylen,\n                                                   void *data){\n    COMPS_RTreeData * rtd;\n    if ((rtd = malloc(sizeof(*rtd))) == NULL)\n        return NULL;\n    if ((rtd->key = malloc(sizeof(char) * (keylen+1))) == NULL) {\n        free(rtd);\n        return NULL;\n    }\n    memcpy(rtd->key, key, sizeof(char)*keylen);\n    rtd->key[keylen] = 0;\n    rtd->data = data;\n    if (data != NULL) {\n        rtd->is_leaf = 1;\n    }\n    rtd->data_destructor = &rt->data_destructor;\n    rtd->subnodes = comps_hslist_create();\n    comps_hslist_init(rtd->subnodes, NULL, NULL, &comps_rtree_data_destroy_v);\n    return rtd;\n}\n\nCOMPS_RTreeData * comps_rtree_data_create(COMPS_RTree *rt,char * key,\n                                          void * data) {\n    COMPS_RTreeData * rtd;\n    rtd = __comps_rtree_data_create(rt, key, strlen(key), data);\n    return rtd;\n}\n\nCOMPS_RTreeData * comps_rtree_data_create_n(COMPS_RTree *rt, char * key,\n                                            size_t keylen, void * data) {\n    COMPS_RTreeData * rtd;\n    rtd = __comps_rtree_data_create(rt, key, keylen, data);\n    return rtd;\n}\n\nCOMPS_RTree * comps_rtree_create(void* (*data_constructor)(void*),\n                                 void* (*data_cloner)(void*),\n                                 void (*data_destructor)(void*)) {\n    COMPS_RTree *ret;\n    if ((ret = malloc(sizeof(COMPS_RTree))) == NULL)\n        return NULL;\n    ret->subnodes = comps_hslist_create();\n    comps_hslist_init(ret->subnodes, NULL, NULL, &comps_rtree_data_destroy_v);\n    if (ret->subnodes == NULL) {\n        free(ret);\n        return NULL;\n    }\n    ret->data_constructor = data_constructor;\n    ret->data_cloner = data_cloner;\n    ret->data_destructor = data_destructor;\n    return ret;\n}\n\nvoid comps_rtree_destroy(COMPS_RTree * rt) {\n    if (!rt) return;\n    comps_hslist_destroy(&(rt->subnodes));\n    free(rt);\n}\n\nvoid comps_rtree_print(COMPS_HSList * hl, unsigned  deep) {\n    COMPS_HSListItem * it;\n    for (it = hl->first; it != NULL; it=it->next) {\n        printf(\"%d %s\\n\",deep, (((COMPS_RTreeData*)it->data)->key));\n        comps_rtree_print(((COMPS_RTreeData*)it->data)->subnodes, deep+1);\n    }\n}\n\nCOMPS_RTree * comps_rtree_clone(COMPS_RTree *rt) {\n\n    COMPS_HSList *to_clone, *tmplist, *new_subnodes;\n    COMPS_RTree *ret;\n    COMPS_HSListItem *it, *it2;\n    COMPS_RTreeData *rtdata;\n    void *new_data;\n\n    if (!rt) return NULL;\n\n    to_clone = comps_hslist_create();\n    comps_hslist_init(to_clone, NULL, NULL, NULL);\n    ret = comps_rtree_create(rt->data_constructor, rt->data_cloner,\n                             rt->data_destructor);\n\n\n    for (it = rt->subnodes->first; it != NULL; it = it->next) {\n        rtdata = comps_rtree_data_create(ret,\n                                      ((COMPS_RTreeData*)it->data)->key, NULL);\n        if (((COMPS_RTreeData*)it->data)->data != NULL)\n            new_data = rt->data_cloner(((COMPS_RTreeData*)it->data)->data);\n        else\n            new_data = NULL;\n        comps_hslist_destroy(&rtdata->subnodes);\n        rtdata->subnodes = ((COMPS_RTreeData*)it->data)->subnodes;\n        rtdata->data = new_data;\n        comps_hslist_append(ret->subnodes, rtdata, 0);\n\n        comps_hslist_append(to_clone, rtdata, 0);\n    }\n\n\n    while (to_clone->first) {\n        it2 = to_clone->first;\n        tmplist = ((COMPS_RTreeData*)it2->data)->subnodes;\n        comps_hslist_remove(to_clone, to_clone->first);\n\n        new_subnodes = comps_hslist_create();\n        comps_hslist_init(new_subnodes, NULL, NULL, &comps_rtree_data_destroy_v);\n        for (it = tmplist->first; it != NULL; it = it->next) {\n            rtdata = comps_rtree_data_create(ret,\n                                      ((COMPS_RTreeData*)it->data)->key, NULL);\n            if (((COMPS_RTreeData*)it->data)->data != NULL)\n                new_data = rt->data_cloner(((COMPS_RTreeData*)it->data)->data);\n            else\n                new_data = NULL;\n            comps_hslist_destroy(&rtdata->subnodes);\n            rtdata->subnodes = ((COMPS_RTreeData*)it->data)->subnodes;\n            rtdata->data = new_data;\n            comps_hslist_append(new_subnodes, rtdata, 0);\n\n            comps_hslist_append(to_clone, rtdata, 0);\n        }\n        ((COMPS_RTreeData*)it2->data)->subnodes = new_subnodes;\n        free(it2);\n    }\n    comps_hslist_destroy(&to_clone);\n    return ret;\n}\n\nvoid comps_rtree_values_walk(COMPS_RTree * rt, void* udata,\n                              void (*walk_f)(void*, void*)) {\n    COMPS_HSList *tmplist, *tmp_subnodes;\n    COMPS_HSListItem *it;\n    tmplist = comps_hslist_create();\n    comps_hslist_init(tmplist, NULL, NULL, NULL);\n    comps_hslist_append(tmplist, rt->subnodes, 0);\n    while (tmplist->first != NULL) {\n        it = tmplist->first;\n        comps_hslist_remove(tmplist, tmplist->first);\n        tmp_subnodes = (COMPS_HSList*)it->data;\n        for (it = tmp_subnodes->first; it != NULL; it=it->next) {\n            if (((COMPS_RTreeData*)it->data)->subnodes->first) {\n                comps_hslist_append(tmplist,\n                                    ((COMPS_RTreeData*)it->data)->subnodes, 0);\n            }\n            if (((COMPS_RTreeData*)it->data)->data != NULL) {\n               walk_f(udata, ((COMPS_RTreeData*)it->data)->data);\n            }\n        }\n    }\n    comps_hslist_destroy(&tmplist);\n}\n\nvoid __comps_rtree_set(COMPS_RTree * rt, char * key, size_t len, void * data)\n{\n    COMPS_HSListItem *it, *lesser;\n    COMPS_HSList *subnodes;\n    COMPS_RTreeData *rtd;\n    static COMPS_RTreeData *rtdata;\n\n    size_t offset=0, _len;\n    unsigned x, found = 0;\n    void *ndata;\n    char ended;//, tmpch;\n\n    if (rt->subnodes == NULL)\n        return;\n    if (rt->data_constructor) {\n        ndata = rt->data_constructor(data);\n    } else {\n        ndata = data;\n    }\n\n    subnodes = rt->subnodes;\n    while (offset != len)\n    {\n        found = 0;\n        lesser = NULL;\n        for (it = subnodes->first; it != NULL; it=it->next) {\n            if (((COMPS_RTreeData*)it->data)->key[0] == key[offset]) {\n                found = 1;\n                break;\n            } else if (((COMPS_RTreeData*)it->data)->key[0] < key[offset]) {\n                lesser = it;\n            }\n        }\n        if (!found) { // not found in subnodes; create new subnode\n            rtd = comps_rtree_data_create(rt, key+offset, ndata);\n            if (!lesser) {\n                comps_hslist_prepend(subnodes, rtd, 0);\n            } else {\n                comps_hslist_insert_after(subnodes, lesser, rtd, 0);\n            }\n            return;\n        } else {\n            rtdata = (COMPS_RTreeData*)it->data;\n            ended = 0;\n            for (x=1; ;x++) {\n                if (rtdata->key[x] == 0) ended += 1;\n                if (x == len - offset) ended += 2;\n                if (ended != 0) break;\n                if (key[offset+x] != rtdata->key[x]) break;\n            }\n            if (ended == 3) { //keys equals; data replacement\n                rt->data_destructor(rtdata->data);\n                rtdata->data = ndata;\n                return;\n            } else if (ended == 2) { //global key ends first; make global leaf\n                comps_hslist_remove(subnodes, it);\n                it->next = NULL;\n                rtd = comps_rtree_data_create_n(rt, key+offset,\n                                                len-offset, ndata);\n                comps_hslist_append(subnodes, rtd, 0);\n                ((COMPS_RTreeData*)subnodes->last->data)->subnodes->last = it;\n                ((COMPS_RTreeData*)subnodes->last->data)->subnodes->first = it;\n                _len = len - offset;\n\n                memmove(rtdata->key,rtdata->key + _len,\n                                    strlen(rtdata->key) - _len);\n                rtdata->key[strlen(rtdata->key) - _len] = 0;\n                rtdata->key = realloc(rtdata->key,\n                                      sizeof(char)* (strlen(rtdata->key)+1));\n                return;\n            } else if (ended == 1) { //local key ends first; go deeper\n                subnodes = rtdata->subnodes;\n                offset += x;\n            } else {\n                void *tmpdata = rtdata->data;\n                COMPS_HSList *tmpnodes = rtdata->subnodes;\n\n                int cmpret = strcmp(key+offset+x, rtdata->key+x);\n                rtdata->subnodes = comps_hslist_create();\n                comps_hslist_init(rtdata->subnodes, NULL, NULL,\n                                  &comps_rtree_data_destroy_v);\n                rtdata->data = NULL;\n\n                if (cmpret > 0) {\n                    rtd = comps_rtree_data_create(rt, rtdata->key+x, tmpdata);\n                    comps_hslist_destroy(&rtd->subnodes);\n                    rtd->subnodes = tmpnodes;\n                    comps_hslist_append(rtdata->subnodes, rtd, 0);\n                    rtd = comps_rtree_data_create(rt, key+offset+x, ndata);\n                    comps_hslist_append(rtdata->subnodes, rtd, 0);\n                } else {\n                    rtd = comps_rtree_data_create(rt, key+offset+x, ndata);\n                    comps_hslist_append(rtdata->subnodes, rtd, 0);\n                    rtd = comps_rtree_data_create(rt, rtdata->key+x, tmpdata);\n                    comps_hslist_destroy(&rtd->subnodes);\n                    rtd->subnodes = tmpnodes;\n                    comps_hslist_append(rtdata->subnodes, rtd, 0);\n                }\n                rtdata->key = realloc(rtdata->key, sizeof(char)*(x+1));\n                rtdata->key[x] = 0;\n                return;\n            }\n        }\n    }\n}\n\nvoid comps_rtree_set(COMPS_RTree * rt, char * key, void * data)\n{\n    __comps_rtree_set(rt, key, strlen(key), data);\n}\nvoid comps_rtree_set_n(COMPS_RTree * rt, char * key, size_t keylen, void * data)\n{\n    __comps_rtree_set(rt, key, keylen, data);\n}\n\nvoid* comps_rtree_get(COMPS_RTree * rt, const char * key) {\n    COMPS_HSList * subnodes;\n    COMPS_HSListItem * it = NULL;\n    COMPS_RTreeData * rtdata;\n    unsigned int offset, len, x;\n    char found, ended;\n\n    len = strlen(key);\n    offset = 0;\n    subnodes = rt->subnodes;\n    while (offset != len) {\n        found = 0;\n        for (it = subnodes->first; it != NULL; it=it->next) {\n            if (((COMPS_RTreeData*)it->data)->key[0] == key[offset]) {\n                found = 1;\n                break;\n            }\n        }\n        if (!found) {\n            //printf(\"not found\\n\");\n            return NULL;\n        }\n        rtdata = (COMPS_RTreeData*)it->data;\n\n        for (x=1; ;x++) {\n            ended=0;\n            if (x == strlen(rtdata->key)) ended += 1;\n            if (x == len-offset) ended += 2;\n            if (ended != 0) break;\n            if (key[offset+x] != rtdata->key[x]) break;\n        }\n        //printf(\"ended :%d key :%s|\\n\", ended, rtdata->key);\n        if (ended == 3) return rtdata->data;\n        else if (ended == 1) offset+=x;\n        else return NULL;\n        subnodes = ((COMPS_RTreeData*)it->data)->subnodes;\n    }\n    if (it != NULL)\n        return ((COMPS_RTreeData*)it->data)->data;\n    else return NULL;\n}\n\nvoid comps_rtree_unset(COMPS_RTree * rt, const char * key) {\n    COMPS_HSList * subnodes;\n    COMPS_HSListItem * it;\n    COMPS_RTreeData * rtdata;\n    unsigned int offset, len, x;\n    char found, ended;\n    COMPS_HSList * path;\n\n    struct Relation {\n        COMPS_HSList * parent_nodes;\n        COMPS_HSListItem * child_it;\n    } *relation;\n\n    path = comps_hslist_create();\n    comps_hslist_init(path, NULL, NULL, &free);\n\n    len = strlen(key);\n    offset = 0;\n    subnodes = rt->subnodes;\n    while (offset != len) {\n        found = 0;\n        for (it = subnodes->first; it != NULL; it=it->next) {\n            if (((COMPS_RTreeData*)it->data)->key[0] == key[offset]) {\n                found = 1;\n                break;\n            }\n        }\n        if (!found) {\n            comps_hslist_destroy(&path);\n            return;\n        }\n        rtdata = (COMPS_RTreeData*)it->data;\n\n        for (x=1; ;x++) {\n            ended=0;\n            if (rtdata->key[x] == 0) ended += 1;\n            if (x == len - offset) ended += 2;\n            if (ended != 0) break;\n            if (key[offset+x] != rtdata->key[x]) break;\n        }\n        if (ended == 3) {\n            /* remove node from tree only if there's no descendant*/\n            if (rtdata->subnodes->last == NULL) {\n                //printf(\"removing all\\n\");\n                comps_hslist_remove(subnodes, it);\n                comps_rtree_data_destroy(rtdata);\n                free(it);\n            }\n            else if (rtdata->data_destructor != NULL) {\n                //printf(\"removing data only\\n\");\n                (*rtdata->data_destructor)(rtdata->data);\n                rtdata->is_leaf = 0;\n                rtdata->data = NULL;\n            }\n\n            if (path->last == NULL) {\n                comps_hslist_destroy(&path);\n                return;\n            }\n            rtdata = (COMPS_RTreeData*)\n                     ((struct Relation*)path->last->data)->child_it->data;\n\n            /*remove all predecessor of deleted node (recursive) with no childs*/\n            while (rtdata->subnodes->last == NULL) {\n                //printf(\"removing '%s'\\n\", rtdata->key);\n                comps_rtree_data_destroy(rtdata);\n                comps_hslist_remove(\n                            ((struct Relation*)path->last->data)->parent_nodes,\n                            ((struct Relation*)path->last->data)->child_it);\n                free(((struct Relation*)path->last->data)->child_it);\n                it = path->last;\n                comps_hslist_remove(path, path->last);\n                free(it);\n                rtdata = (COMPS_RTreeData*)\n                         ((struct Relation*)path->last->data)->child_it->data;\n            }\n            comps_hslist_destroy(&path);\n            return;\n        }\n        else if (ended == 1) offset+=x;\n        else {\n            comps_hslist_destroy(&path);\n            return;\n        }\n        if ((relation = malloc(sizeof(struct Relation))) == NULL) {\n            comps_hslist_destroy(&path);\n            return;\n        }\n        subnodes = ((COMPS_RTreeData*)it->data)->subnodes;\n        relation->parent_nodes = subnodes;\n        relation->child_it = it;\n        comps_hslist_append(path, (void*)relation, 0);\n    }\n    comps_hslist_destroy(&path);\n    return;\n}\n\nvoid comps_rtree_clear(COMPS_RTree * rt) {\n    COMPS_HSListItem *it, *oldit;\n    if (rt==NULL) return;\n    if (rt->subnodes == NULL) return;\n    oldit = rt->subnodes->first;\n    it = (oldit)?oldit->next:NULL;\n    for (;it != NULL; it=it->next) {\n        if (rt->subnodes->data_destructor != NULL)\n            rt->subnodes->data_destructor(oldit->data);\n        free(oldit);\n        oldit = it;\n    }\n    if (oldit) {\n        if (rt->subnodes->data_destructor != NULL)\n            rt->subnodes->data_destructor(oldit->data);\n        free(oldit);\n    }\n}\n\ninline COMPS_HSList* __comps_rtree_all(COMPS_RTree * rt, char keyvalpair) {\n    COMPS_HSList *to_process, *ret;\n    COMPS_HSListItem *hsit, *oldit;\n    size_t x;\n    struct Pair {\n        char *key;\n        void *data;\n        COMPS_HSList *subnodes;\n    } *pair, *current_pair=NULL;//, *oldpair=NULL;\n    COMPS_RTreePair *rtpair;\n\n    to_process = comps_hslist_create();\n    comps_hslist_init(to_process, NULL, NULL, &free);\n\n    ret = comps_hslist_create();\n    if (keyvalpair == 0)\n        comps_hslist_init(ret, NULL, NULL, &free);\n    else if (keyvalpair == 1)\n        comps_hslist_init(ret, NULL, NULL, NULL);\n    else\n        comps_hslist_init(ret, NULL, NULL, &comps_rtree_pair_destroy_v);\n\n    for (hsit = rt->subnodes->first; hsit != NULL; hsit = hsit->next) {\n        pair = malloc(sizeof(struct Pair));\n        pair->key = __comps_strcpy(((COMPS_RTreeData*)hsit->data)->key);\n        pair->data = ((COMPS_RTreeData*)hsit->data)->data;\n        pair->subnodes = ((COMPS_RTreeData*)hsit->data)->subnodes;\n        comps_hslist_append(to_process, pair, 0);\n    }\n    while (to_process->first) {\n        //oldpair = current_pair;\n        current_pair = to_process->first->data;\n        oldit = to_process->first;\n        comps_hslist_remove(to_process, to_process->first);\n        if (current_pair->data) {\n            if (keyvalpair == 0) {\n                comps_hslist_append(ret, __comps_strcpy(current_pair->key), 0);\n            } else if (keyvalpair == 1) {\n                comps_hslist_append(ret, current_pair->data, 0);\n            } else {\n                rtpair = malloc(sizeof(COMPS_RTreePair));\n                rtpair->key = __comps_strcpy(current_pair->key);\n                rtpair->data = current_pair->data;\n                comps_hslist_append(ret, rtpair, 0);\n            }\n        }\n        for (hsit = current_pair->subnodes->first, x = 0;\n             hsit != NULL; hsit = hsit->next, x++) {\n            pair = malloc(sizeof(struct Pair));\n            pair->key = __comps_strcat(current_pair->key,\n                                       ((COMPS_RTreeData*)hsit->data)->key);\n            pair->data = ((COMPS_RTreeData*)hsit->data)->data;\n            pair->subnodes = ((COMPS_RTreeData*)hsit->data)->subnodes;\n            comps_hslist_insert_at(to_process, x, pair, 0);\n        }\n        free(current_pair->key);\n        free(current_pair);\n        free(oldit);\n    }\n\n    comps_hslist_destroy(&to_process);\n    return ret;\n}\n\nvoid comps_rtree_unite(COMPS_RTree *rt1, COMPS_RTree *rt2) {\n    COMPS_HSList *tmplist, *tmp_subnodes;\n    COMPS_HSListItem *it;\n    struct Pair {\n        COMPS_HSList * subnodes;\n        char * key;\n    } *pair, *parent_pair;\n\n    pair = malloc(sizeof(struct Pair));\n    pair->subnodes = rt2->subnodes;\n    pair->key = NULL;\n\n    tmplist = comps_hslist_create();\n    comps_hslist_init(tmplist, NULL, NULL, &free);\n    comps_hslist_append(tmplist, pair, 0);\n\n    while (tmplist->first != NULL) {\n        it = tmplist->first;\n        comps_hslist_remove(tmplist, tmplist->first);\n        tmp_subnodes = ((struct Pair*)it->data)->subnodes;\n        parent_pair = (struct Pair*) it->data;\n        free(it);\n\n        for (it = tmp_subnodes->first; it != NULL; it=it->next) {\n            pair = malloc(sizeof(struct Pair));\n            pair->subnodes = ((COMPS_RTreeData*)it->data)->subnodes;\n\n            if (parent_pair->key != NULL) {\n                pair->key = malloc(sizeof(char)\n                               * (strlen(((COMPS_RTreeData*)it->data)->key)\n                               + strlen(parent_pair->key) + 1));\n                memcpy(pair->key, parent_pair->key,\n                       sizeof(char) * strlen(parent_pair->key));\n                memcpy(pair->key + strlen(parent_pair->key),\n                       ((COMPS_RTreeData*)it->data)->key,\n                       sizeof(char)*(strlen(((COMPS_RTreeData*)it->data)->key)+1));\n            } else {\n                pair->key = malloc(sizeof(char)*\n                                (strlen(((COMPS_RTreeData*)it->data)->key) +1));\n                memcpy(pair->key, ((COMPS_RTreeData*)it->data)->key,\n                       sizeof(char)*(strlen(((COMPS_RTreeData*)it->data)->key)+1));\n            }\n            /* current node has data */\n            if (((COMPS_RTreeData*)it->data)->data != NULL) {\n                    comps_rtree_set(rt1,\n                                    pair->key,\n                        rt2->data_cloner(((COMPS_RTreeData*)it->data)->data));\n            }\n            if (((COMPS_RTreeData*)it->data)->subnodes->first) {\n                comps_hslist_append(tmplist, pair, 0);\n            } else {\n                free(pair->key);\n                free(pair);\n            }\n        }\n        free(parent_pair->key);\n        free(parent_pair);\n    }\n    comps_hslist_destroy(&tmplist);\n}\n\nCOMPS_RTree* comps_rtree_union(COMPS_RTree *rt1, COMPS_RTree *rt2){\n    COMPS_RTree *ret;\n    ret = comps_rtree_clone(rt2);\n    comps_rtree_unite(ret, rt1);\n    return ret;\n}\n\n\nCOMPS_HSList* comps_rtree_keys(COMPS_RTree * rt) {\n    return __comps_rtree_all(rt, 0);\n}\n\nCOMPS_HSList* comps_rtree_values(COMPS_RTree * rt) {\n    return __comps_rtree_all(rt, 1);\n}\n\nCOMPS_HSList* comps_rtree_pairs(COMPS_RTree * rt) {\n    return __comps_rtree_all(rt, 2);\n}\n\ninline void comps_rtree_pair_destroy(COMPS_RTreePair * pair) {\n    free(pair->key);\n    free(pair);\n}\n\ninline void comps_rtree_pair_destroy_v(void * pair) {\n    free(((COMPS_RTreePair *)pair)->key);\n    free(pair);\n}\n"], "filenames": ["libcomps/src/comps_mradix.c", "libcomps/src/comps_objmradix.c", "libcomps/src/comps_objradix.c", "libcomps/src/comps_radix.c"], "buggy_code_start_loc": [180, 288, 700, 532], "buggy_code_end_loc": [199, 307, 720, 533], "fixing_code_start_loc": [179, 287, 699, 531], "fixing_code_end_loc": [196, 304, 717, 531], "type": "CWE-416", "message": "A use-after-free flaw has been discovered in libcomps before version 0.1.10 in the way ObjMRTrees are merged. An attacker, who is able to make an application read a crafted comps XML file, may be able to crash the application or execute malicious code.", "other": {"cve": {"id": "CVE-2019-3817", "sourceIdentifier": "secalert@redhat.com", "published": "2019-03-27T13:29:01.413", "lastModified": "2019-10-09T23:49:43.413", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "A use-after-free flaw has been discovered in libcomps before version 0.1.10 in the way ObjMRTrees are merged. An attacker, who is able to make an application read a crafted comps XML file, may be able to crash the application or execute malicious code."}, {"lang": "es", "value": "Se ha descubierto un error de uso de memoria previamente liberada en libcomps, en versiones anteriores a la 0.1.10 en la forma en la que se fusionan los ObjMRTrees. Un atacante que sea capaz de hacer que una aplicaci\u00f3n lea un archivo XML comps manipulado podr\u00eda ser capaz de provocar el cierre inesperado de la aplicaci\u00f3n o ejecutar c\u00f3digo malicioso."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}, {"source": "secalert@redhat.com", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:H/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.6, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-416"}]}, {"source": "secalert@redhat.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-416"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:rpm:libcomps:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.1.10", "matchCriteriaId": "0A4B2FD7-CE20-40F0-B6A2-63F7BE0D10CF"}]}]}], "references": [{"url": "https://access.redhat.com/errata/RHSA-2019:3583", "source": "secalert@redhat.com"}, {"url": "https://access.redhat.com/errata/RHSA-2019:3898", "source": "secalert@redhat.com"}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=CVE-2019-3817", "source": "secalert@redhat.com", "tags": ["Exploit", "Issue Tracking", "Vendor Advisory"]}, {"url": "https://github.com/rpm-software-management/libcomps/commit/e3a5d056633677959ad924a51758876d415e7046", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/rpm-software-management/libcomps/issues/41", "source": "secalert@redhat.com", "tags": ["Exploit", "Issue Tracking", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/rpm-software-management/libcomps/commit/e3a5d056633677959ad924a51758876d415e7046"}}