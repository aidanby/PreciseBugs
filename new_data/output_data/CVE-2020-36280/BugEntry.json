{"buggy_code": ["/*====================================================================*\n -  Copyright (C) 2001 Leptonica.  All rights reserved.\n -\n -  Redistribution and use in source and binary forms, with or without\n -  modification, are permitted provided that the following conditions\n -  are met:\n -  1. Redistributions of source code must retain the above copyright\n -     notice, this list of conditions and the following disclaimer.\n -  2. Redistributions in binary form must reproduce the above\n -     copyright notice, this list of conditions and the following\n -     disclaimer in the documentation and/or other materials\n -     provided with the distribution.\n -\n -  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n -  ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n -  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n -  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL ANY\n -  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n -  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n -  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n -  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n -  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n -  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n -  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *====================================================================*/\n\n/*\n *   dewarptest1.c\n *\n *   This exercise functions in dewarp.c for dewarping based on lines\n *   of horizontal text.  It also creates a 24-image pdf of steps\n *   in the process.\n */\n\n#ifdef HAVE_CONFIG_H\n#include <config_auto.h>\n#endif  /* HAVE_CONFIG_H */\n\n#include \"allheaders.h\"\n\n#define   DO_QUAD     1\n#define   DO_CUBIC    0\n#define   DO_QUARTIC  0\n\nl_int32 main(int    argc,\n             char **argv)\n{\nL_DEWARP   *dew1, *dew2;\nL_DEWARPA  *dewa;\nPIX        *pixs, *pixn, *pixg, *pixb, *pixd, *pixt1, *pixt2;\nPIX        *pixs2, *pixn2, *pixg2, *pixb2, *pixd2;\n\n    setLeptDebugOK(1);\n    lept_mkdir(\"lept/model\");\n\n/*    pixs = pixRead(\"1555.007.jpg\"); */\n    pixs = pixRead(\"cat.035.jpg\");\n/*    pixs = pixRead(\"cat.010.jpg\"); */\n\n        /* Normalize for varying background and binarize */\n    pixn = pixBackgroundNormSimple(pixs, NULL, NULL);\n    pixg = pixConvertRGBToGray(pixn, 0.5, 0.3, 0.2);\n    pixb = pixThresholdToBinary(pixg, 130);\n\n        /* Run the basic functions */\n    dewa = dewarpaCreate(2, 30, 1, 10, 30);\n    dewarpaUseBothArrays(dewa, 1);\n    dew1 = dewarpCreate(pixb, 35);\n    dewarpaInsertDewarp(dewa, dew1);\n    dewarpBuildPageModel(dew1, \"/tmp/lept/model/dewarp_model1.pdf\");\n    dewarpaApplyDisparity(dewa, 35, pixg, 200, 0, 0, &pixd,\n                          \"/tmp/lept/model/dewarp_apply1.pdf\");\n\n         /* Write out some of the files to be imaged */\n    lept_rmdir(\"lept/dewtest\");\n    lept_mkdir(\"lept/dewtest\");\n    pixWrite(\"/tmp/lept/dewtest/001.jpg\", pixs, IFF_JFIF_JPEG);\n    pixWrite(\"/tmp/lept/dewtest/002.jpg\", pixn, IFF_JFIF_JPEG);\n    pixWrite(\"/tmp/lept/dewtest/003.jpg\", pixg, IFF_JFIF_JPEG);\n    pixWrite(\"/tmp/lept/dewtest/004.png\", pixb, IFF_TIFF_G4);\n    pixWrite(\"/tmp/lept/dewtest/005.jpg\", pixd, IFF_JFIF_JPEG);\n    pixt1 = pixRead(\"/tmp/lept/dewmod/0020.png\");\n    pixWrite(\"/tmp/lept/dewtest/006.png\", pixt1, IFF_PNG);\n    pixDestroy(&pixt1);\n    pixt1 = pixRead(\"/tmp/lept/dewmod/0030.png\");\n    pixWrite(\"/tmp/lept/dewtest/007.png\", pixt1, IFF_PNG);\n    pixDestroy(&pixt1);\n    pixt1 = pixRead(\"/tmp/lept/dewmod/0060.png\");\n    pixWrite(\"/tmp/lept/dewtest/008.png\", pixt1, IFF_PNG);\n    pixDestroy(&pixt1);\n    pixt1 = pixRead(\"/tmp/lept/dewmod/0070.png\");\n    pixWrite(\"/tmp/lept/dewtest/009.png\", pixt1, IFF_PNG);\n    pixDestroy(&pixt1);\n    pixt1 = pixRead(\"/tmp/lept/dewapply/002.png\");\n    pixWrite(\"/tmp/lept/dewtest/010.png\", pixt1, IFF_PNG);\n    pixDestroy(&pixt1);\n    pixt1 = pixRead(\"/tmp/lept/dewapply/003.png\");\n    pixWrite(\"/tmp/lept/dewtest/011.png\", pixt1, IFF_PNG);\n    pixt2 = pixThresholdToBinary(pixt1, 130);\n    pixWrite(\"/tmp/lept/dewtest/012.png\", pixt2, IFF_TIFF_G4);\n    pixDestroy(&pixt1);\n    pixDestroy(&pixt2);\n    pixt1 = pixRead(\"/tmp/lept/dewmod/0041.png\");\n    pixWrite(\"/tmp/lept/dewtest/013.png\", pixt1, IFF_PNG);\n    pixDestroy(&pixt1);\n    pixt1 = pixRead(\"/tmp/lept/dewmod/0042.png\");\n    pixWrite(\"/tmp/lept/dewtest/014.png\", pixt1, IFF_PNG);\n    pixDestroy(&pixt1);\n    pixt1 = pixRead(\"/tmp/lept/dewmod/0051.png\");\n    pixWrite(\"/tmp/lept/dewtest/015.png\", pixt1, IFF_PNG);\n    pixDestroy(&pixt1);\n    pixt1 = pixRead(\"/tmp/lept/dewmod/0052.png\");\n    pixWrite(\"/tmp/lept/dewtest/016.png\", pixt1, IFF_PNG);\n    pixDestroy(&pixt1);\n\n        /* Normalize another image, that may not have enough textlines\n         * to build an accurate model */\n/*    pixs2 = pixRead(\"1555.003.jpg\");  */\n    pixs2 = pixRead(\"cat.007.jpg\");\n/*    pixs2 = pixRead(\"cat.014.jpg\"); */\n    pixn2 = pixBackgroundNormSimple(pixs2, NULL, NULL);\n    pixg2 = pixConvertRGBToGray(pixn2, 0.5, 0.3, 0.2);\n    pixb2 = pixThresholdToBinary(pixg2, 130);\n\n        /* Apply the previous disparity model to this image */\n    dew2 = dewarpCreate(pixb2, 7);\n    dewarpaInsertDewarp(dewa, dew2);\n    dewarpaInsertRefModels(dewa, 0, 1);\n    dewarpaInfo(stderr, dewa);\n    dewarpaApplyDisparity(dewa, 7, pixg2, 200, 0, 0, &pixd2,\n                          \"/tmp/lept/model/dewarp_apply2.pdf\");\n    dewarpaDestroy(&dewa);\n\n        /* Write out files for the second image */\n    pixWrite(\"/tmp/lept/dewtest/017.jpg\", pixs2, IFF_JFIF_JPEG);\n    pixWrite(\"/tmp/lept/dewtest/018.jpg\", pixg2, IFF_JFIF_JPEG);\n    pixWrite(\"/tmp/lept/dewtest/019.png\", pixb2, IFF_TIFF_G4);\n    pixWrite(\"/tmp/lept/dewtest/020.jpg\", pixd2, IFF_JFIF_JPEG);\n    pixt1 = pixRead(\"/tmp/lept/dewmod/0060.png\");\n    pixWrite(\"/tmp/lept/dewtest/021.png\", pixt1, IFF_PNG);\n    pixDestroy(&pixt1);\n    pixt1 = pixRead(\"/tmp/lept/dewapply/002.png\");\n    pixWrite(\"/tmp/lept/dewtest/022.png\", pixt1, IFF_PNG);\n    pixt2 = pixThresholdToBinary(pixt1, 130);\n    pixWrite(\"/tmp/lept/dewtest/023.png\", pixt2, IFF_TIFF_G4);\n    pixDestroy(&pixt1);\n    pixDestroy(&pixt2);\n    pixt1 = pixRead(\"/tmp/lept/dewmod/0070.png\");\n    pixWrite(\"/tmp/lept/dewtest/024.png\", pixt1, IFF_PNG);\n    pixDestroy(&pixt1);\n    pixt1 = pixRead(\"/tmp/lept/dewapply/003.png\");\n    pixWrite(\"/tmp/lept/dewtest/025.png\", pixt1, IFF_PNG);\n    pixt2 = pixThresholdToBinary(pixt1, 130);\n    pixWrite(\"/tmp/lept/dewtest/026.png\", pixt2, IFF_TIFF_G4);\n    pixDestroy(&pixt1);\n    pixDestroy(&pixt2);\n\n        /* Generate the big pdf file */\n    convertFilesToPdf(\"/tmp/lept/dewtest\", NULL, 135, 1.0, 0, 0, \"Dewarp Test\",\n                      \"/tmp/lept/dewarptest1.pdf\");\n    lept_stderr(\"pdf file made: /tmp/lept/model/dewarptest1.pdf\\n\");\n\n    lept_rmdir(\"lept/dewmod\");\n    lept_rmdir(\"lept/dewtest\");\n    pixDestroy(&pixs);\n    pixDestroy(&pixn);\n    pixDestroy(&pixg);\n    pixDestroy(&pixb);\n    pixDestroy(&pixd);\n    pixDestroy(&pixs2);\n    pixDestroy(&pixn2);\n    pixDestroy(&pixg2);\n    pixDestroy(&pixb2);\n    pixDestroy(&pixd2);\n    return 0;\n}\n", "/*====================================================================*\n -  Copyright (C) 2001 Leptonica.  All rights reserved.\n -\n -  Redistribution and use in source and binary forms, with or without\n -  modification, are permitted provided that the following conditions\n -  are met:\n -  1. Redistributions of source code must retain the above copyright\n -     notice, this list of conditions and the following disclaimer.\n -  2. Redistributions in binary form must reproduce the above\n -     copyright notice, this list of conditions and the following\n -     disclaimer in the documentation and/or other materials\n -     provided with the distribution.\n -\n -  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n -  ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n -  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n -  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL ANY\n -  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n -  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n -  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n -  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n -  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n -  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n -  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *====================================================================*/\n\n/*!\n * \\file tiffio.c\n * <pre>\n *\n *     TIFFClientOpen() wrappers for FILE*:\n *      static tsize_t    lept_read_proc()\n *      static tsize_t    lept_write_proc()\n *      static toff_t     lept_seek_proc()\n *      static int        lept_close_proc()\n *      static toff_t     lept_size_proc()\n *\n *     Reading tiff:\n *             PIX       *pixReadTiff()             [ special top level ]\n *             PIX       *pixReadStreamTiff()\n *      static PIX       *pixReadFromTiffStream()\n *\n *     Writing tiff:\n *             l_int32    pixWriteTiff()            [ special top level ]\n *             l_int32    pixWriteTiffCustom()      [ special top level ]\n *             l_int32    pixWriteStreamTiff()\n *             l_int32    pixWriteStreamTiffWA()\n *      static l_int32    pixWriteToTiffStream()\n *      static l_int32    writeCustomTiffTags()\n *\n *     Reading and writing multipage tiff\n *             PIX       *pixReadFromMultipageTiff()\n *             PIXA      *pixaReadMultipageTiff()   [ special top level ]\n *             l_int32    pixaWriteMultipageTiff()  [ special top level ]\n *             l_int32    writeMultipageTiff()      [ special top level ]\n *             l_int32    writeMultipageTiffSA()\n *\n *     Information about tiff file\n *             l_int32    fprintTiffInfo()\n *             l_int32    tiffGetCount()\n *             l_int32    getTiffResolution()\n *      static l_int32    getTiffStreamResolution()\n *             l_int32    readHeaderTiff()\n *             l_int32    freadHeaderTiff()\n *             l_int32    readHeaderMemTiff()\n *      static l_int32    tiffReadHeaderTiff()\n *             l_int32    findTiffCompression()\n *      static l_int32    getTiffCompressedFormat()\n *\n *     Extraction of tiff g4 data:\n *             l_int32    extractG4DataFromFile()\n *\n *     Open tiff stream from file stream\n *      static TIFF      *fopenTiff()\n *\n *     Wrapper for TIFFOpen:\n *      static TIFF      *openTiff()\n *\n *     Memory I/O: reading memory --> pix and writing pix --> memory\n *             [10 static helper functions]\n *             PIX       *pixReadMemTiff();\n *             PIX       *pixReadMemFromMultipageTiff();\n *             PIXA      *pixaReadMemMultipageTiff()    [ special top level ]\n *             l_int32    pixaWriteMemMultipageTiff()   [ special top level ]\n *             l_int32    pixWriteMemTiff();\n *             l_int32    pixWriteMemTiffCustom();\n *\n *  Note:  To include all necessary functions, use libtiff version 3.7.4\n *         (or later)\n *  Note:  On Windows with 2 bpp or 4 bpp images, the bytes in the\n *         tiff-compressed file depend on the pad bits (but not the\n *         decoded raster image when read).  Because it is sometimes\n *         convenient to use a golden file with a byte-by-byte check\n *         to verify invariance, we set the pad bits to 0 before writing,\n *         in pixWriteToTiffStream().\n * </pre>\n */\n\n#ifdef HAVE_CONFIG_H\n#include <config_auto.h>\n#endif  /* HAVE_CONFIG_H */\n\n#include <string.h>\n#include <math.h>   /* for isnan */\n#include <sys/types.h>\n#ifndef _MSC_VER\n#include <unistd.h>\n#else  /* _MSC_VER */\n#include <io.h>\n#endif  /* _MSC_VER */\n#include <fcntl.h>\n#include \"allheaders.h\"\n\n/* --------------------------------------------*/\n#if  HAVE_LIBTIFF   /* defined in environ.h */\n/* --------------------------------------------*/\n\n#include \"tiff.h\"\n#include \"tiffio.h\"\n\nstatic const l_int32  DefaultResolution = 300;   /* ppi */\nstatic const l_int32  ManyPagesInTiffFile = 3000;  /* warn if big */\n\n    /* Verified that tiflib makes valid g4 files of this size */\nstatic const l_int32  MaxTiffWidth = 1 << 20;  /* 1M pixels */\nstatic const l_int32  MaxTiffHeight = 1 << 20;  /* 1M pixels */\n\n    /* All functions with TIFF interfaces are static. */\nstatic PIX      *pixReadFromTiffStream(TIFF *tif);\nstatic l_int32   getTiffStreamResolution(TIFF *tif, l_int32 *pxres,\n                                         l_int32 *pyres);\nstatic l_int32   tiffReadHeaderTiff(TIFF *tif, l_int32 *pwidth,\n                                    l_int32 *pheight, l_int32 *pbps,\n                                    l_int32 *pspp, l_int32 *pres,\n                                    l_int32 *pcmap, l_int32 *pformat);\nstatic l_int32   writeCustomTiffTags(TIFF *tif, NUMA *natags,\n                                     SARRAY *savals, SARRAY  *satypes,\n                                     NUMA *nasizes);\nstatic l_int32   pixWriteToTiffStream(TIFF *tif, PIX *pix, l_int32 comptype,\n                                      NUMA *natags, SARRAY *savals,\n                                      SARRAY *satypes, NUMA *nasizes);\nstatic TIFF     *fopenTiff(FILE *fp, const char *modestring);\nstatic TIFF     *openTiff(const char *filename, const char *modestring);\n\n    /* Static helper for tiff compression type */\nstatic l_int32   getTiffCompressedFormat(l_uint16 tiffcomp);\n\n    /* Static function for memory I/O */\nstatic TIFF     *fopenTiffMemstream(const char *filename, const char *operation,\n                                    l_uint8 **pdata, size_t *pdatasize);\n\n    /* This structure defines a transform to be performed on a TIFF image\n     * (note that the same transformation can be represented in\n     * several different ways using this structure since\n     * vflip + hflip + counterclockwise == clockwise). */\nstruct tiff_transform {\n    int vflip;    /* if non-zero, image needs a vertical fip */\n    int hflip;    /* if non-zero, image needs a horizontal flip */\n    int rotate;   /* -1 -> counterclockwise 90-degree rotation,\n                      0 -> no rotation\n                      1 -> clockwise 90-degree rotation */\n};\n\n    /* This describes the transformations needed for a given orientation\n     * tag.  The tag values start at 1, so you need to subtract 1 to get a\n     * valid index into this array.  It is only valid when not using\n     * TIFFReadRGBAImageOriented(). */\nstatic struct tiff_transform tiff_orientation_transforms[] = {\n    {0, 0, 0},\n    {0, 1, 0},\n    {1, 1, 0},\n    {1, 0, 0},\n    {0, 1, -1},\n    {0, 0, 1},\n    {0, 1, 1},\n    {0, 0, -1}\n};\n\n    /* Same as above, except that test transformations are only valid\n     * when using TIFFReadRGBAImageOriented().  Transformations\n     * were determined empirically.  See the libtiff mailing list for\n     * more discussion: http://www.asmail.be/msg0054683875.html  */\nstatic struct tiff_transform tiff_partial_orientation_transforms[] = {\n    {0, 0, 0},\n    {0, 0, 0},\n    {0, 0, 0},\n    {0, 0, 0},\n    {0, 1, -1},\n    {0, 1, 1},\n    {1, 0, 1},\n    {0, 1, -1}\n};\n\n\n/*-----------------------------------------------------------------------*\n *             TIFFClientOpen() wrappers for FILE*                       *\n *             Provided by J\u00fcrgen Buchm\u00fcller                             *\n *                                                                       *\n *  We previously used TIFFFdOpen(), which used low-level file           *\n *  descriptors.  It had portability issues with Windows, along          *\n *  with other limitations from lack of stream control operations.       *\n *  These callbacks to TIFFClientOpen() avoid the problems.              *\n *                                                                       *\n *  J\u00fcrgen made the functions use 64 bit file operations where possible  *\n *  or required, namely for seek and size. On Windows there are specific *\n *  _fseeki64() and _ftelli64() functions.  On unix it is common to look *\n *  for a macro _LARGEFILE64_SOURCE being defined, which makes available *\n *  the off64_t type, and to use fseeko() and ftello() in this case.     *\n *-----------------------------------------------------------------------*/\nstatic tsize_t\nlept_read_proc(thandle_t  cookie,\n               tdata_t    buff,\n               tsize_t    size)\n{\n    FILE* fp = (FILE *)cookie;\n    tsize_t done;\n    if (!buff || !cookie || !fp)\n        return (tsize_t)-1;\n    done = fread(buff, 1, size, fp);\n    return done;\n}\n\nstatic tsize_t\nlept_write_proc(thandle_t  cookie,\n                tdata_t    buff,\n                tsize_t    size)\n{\n    FILE* fp = (FILE *)cookie;\n    tsize_t done;\n    if (!buff || !cookie || !fp)\n        return (tsize_t)-1;\n    done = fwrite(buff, 1, size, fp);\n    return done;\n}\n\nstatic toff_t\nlept_seek_proc(thandle_t  cookie,\n               toff_t     offs,\n               int        whence)\n{\n    FILE* fp = (FILE *)cookie;\n#if defined(_MSC_VER)\n    __int64 pos = 0;\n    if (!cookie || !fp)\n        return (tsize_t)-1;\n    switch (whence) {\n    case SEEK_SET:\n        pos = 0;\n        break;\n    case SEEK_CUR:\n        pos = ftell(fp);\n        break;\n    case SEEK_END:\n        _fseeki64(fp, 0, SEEK_END);\n        pos = _ftelli64(fp);\n        break;\n    }\n    pos = (__int64)(pos + offs);\n    _fseeki64(fp, pos, SEEK_SET);\n    if (pos == _ftelli64(fp))\n        return (tsize_t)pos;\n#elif defined(_LARGEFILE64_SOURCE)\n    off64_t pos = 0;\n    if (!cookie || !fp)\n        return (tsize_t)-1;\n    switch (whence) {\n    case SEEK_SET:\n        pos = 0;\n        break;\n    case SEEK_CUR:\n        pos = ftello(fp);\n        break;\n    case SEEK_END:\n        fseeko(fp, 0, SEEK_END);\n        pos = ftello(fp);\n        break;\n    }\n    pos = (off64_t)(pos + offs);\n    fseeko(fp, pos, SEEK_SET);\n    if (pos == ftello(fp))\n        return (tsize_t)pos;\n#else\n    off_t pos = 0;\n    if (!cookie || !fp)\n        return (tsize_t)-1;\n    switch (whence) {\n    case SEEK_SET:\n        pos = 0;\n        break;\n    case SEEK_CUR:\n        pos = ftell(fp);\n        break;\n    case SEEK_END:\n        fseek(fp, 0, SEEK_END);\n        pos = ftell(fp);\n        break;\n    }\n    pos = (off_t)(pos + offs);\n    fseek(fp, pos, SEEK_SET);\n    if (pos == ftell(fp))\n        return (tsize_t)pos;\n#endif\n    return (tsize_t)-1;\n}\n\nstatic int\nlept_close_proc(thandle_t  cookie)\n{\n    FILE* fp = (FILE *)cookie;\n    if (!cookie || !fp)\n        return 0;\n    fseek(fp, 0, SEEK_SET);\n    return 0;\n}\n\nstatic toff_t\nlept_size_proc(thandle_t  cookie)\n{\n    FILE* fp = (FILE *)cookie;\n#if defined(_MSC_VER)\n    __int64 pos;\n    __int64 size;\n    if (!cookie || !fp)\n        return (tsize_t)-1;\n    pos = _ftelli64(fp);\n    _fseeki64(fp, 0, SEEK_END);\n    size = _ftelli64(fp);\n    _fseeki64(fp, pos, SEEK_SET);\n#elif defined(_LARGEFILE64_SOURCE)\n    off64_t pos;\n    off64_t size;\n    if (!fp)\n        return (tsize_t)-1;\n    pos = ftello(fp);\n    fseeko(fp, 0, SEEK_END);\n    size = ftello(fp);\n    fseeko(fp, pos, SEEK_SET);\n#else\n    off_t pos;\n    off_t size;\n    if (!cookie || !fp)\n        return (tsize_t)-1;\n    pos = ftell(fp);\n    fseek(fp, 0, SEEK_END);\n    size = ftell(fp);\n    fseek(fp, pos, SEEK_SET);\n#endif\n    return (toff_t)size;\n}\n\n\n/*--------------------------------------------------------------*\n *                      Reading from file                       *\n *--------------------------------------------------------------*/\n/*!\n * \\brief   pixReadTiff()\n *\n * \\param[in]    filename\n * \\param[in]    n           page number 0 based\n * \\return  pix, or NULL on error\n *\n * <pre>\n * Notes:\n *      (1) This is a version of pixRead(), specialized for tiff\n *          files, that allows specification of the page to be returned\n *      (2) No warning messages on failure, because of how multi-page\n *          TIFF reading works. You are supposed to keep trying until\n *          it stops working.\n * </pre>\n */\nPIX *\npixReadTiff(const char  *filename,\n            l_int32      n)\n{\nFILE  *fp;\nPIX   *pix;\n\n    PROCNAME(\"pixReadTiff\");\n\n    if (!filename)\n        return (PIX *)ERROR_PTR(\"filename not defined\", procName, NULL);\n\n    if ((fp = fopenReadStream(filename)) == NULL)\n        return (PIX *)ERROR_PTR(\"image file not found\", procName, NULL);\n    pix = pixReadStreamTiff(fp, n);\n    fclose(fp);\n    return pix;\n}\n\n\n/*--------------------------------------------------------------*\n *                     Reading from stream                      *\n *--------------------------------------------------------------*/\n/*!\n * \\brief   pixReadStreamTiff()\n *\n * \\param[in]    fp    file stream\n * \\param[in]    n     page number: 0 based\n * \\return  pix, or NULL on error or if there are no more images in the file\n *\n * <pre>\n * Notes:\n *      (1) No warning messages on failure, because of how multi-page\n *          TIFF reading works. You are supposed to keep trying until\n *          it stops working.\n * </pre>\n */\nPIX *\npixReadStreamTiff(FILE    *fp,\n                  l_int32  n)\n{\nPIX   *pix;\nTIFF  *tif;\n\n    PROCNAME(\"pixReadStreamTiff\");\n\n    if (!fp)\n        return (PIX *)ERROR_PTR(\"stream not defined\", procName, NULL);\n\n    if ((tif = fopenTiff(fp, \"r\")) == NULL)\n        return (PIX *)ERROR_PTR(\"tif not opened\", procName, NULL);\n\n    if (TIFFSetDirectory(tif, n) == 0) {\n        TIFFCleanup(tif);\n        return NULL;\n    }\n    if ((pix = pixReadFromTiffStream(tif)) == NULL) {\n        TIFFCleanup(tif);\n        return NULL;\n    }\n    TIFFCleanup(tif);\n    return pix;\n}\n\n\n/*!\n * \\brief   pixReadFromTiffStream()\n *\n * \\param[in]    tif    TIFF handle\n * \\return  pix, or NULL on error\n *\n * <pre>\n * Notes:\n *      (1) We can read the following images (up to 32 bits/pixel):\n *          1 spp (grayscale): 1, 2, 4, 8, 16 bps\n *          1 spp (colormapped): 1, 2, 4, 8 bps\n *          2 spp (gray+alpha): 8 bps\n *          3 spp (rgb) and 4 spp (rgba): 8 or 16 bps\n *      (2) We do not handle 16 bps for spp == 2.\n *      (3) 2 bpp gray+alpha are rasterized as 32 bit/pixel rgba, with\n *          the gray value replicated in r, g and b.\n *      (4) For colormapped images, we support 8 bits/color in the palette.\n *          Tiff colormaps have 16 bits/color, and we reduce them to 8.\n *      (5) Quoting the libtiff documentation at\n *               http://libtiff.maptools.org/libtiff.html\n *          \"libtiff provides a high-level interface for reading image data\n *          from a TIFF file. This interface handles the details of data\n *          organization and format for a wide variety of TIFF files;\n *          at least the large majority of those files that one would\n *          normally encounter. Image data is, by default, returned as\n *          ABGR pixels packed into 32-bit words (8 bits per sample).\n *          Rectangular rasters can be read or data can be intercepted\n *          at an intermediate level and packed into memory in a format\n *          more suitable to the application. The library handles all\n *          the details of the format of data stored on disk and,\n *          in most cases, if any colorspace conversions are required:\n *          bilevel to RGB, greyscale to RGB, CMYK to RGB, YCbCr to RGB,\n *          16-bit samples to 8-bit samples, associated/unassociated alpha,\n *          etc.\"\n * </pre>\n */\nstatic PIX *\npixReadFromTiffStream(TIFF  *tif)\n{\nchar      *text;\nl_uint8   *linebuf, *data, *rowptr;\nl_uint16   spp, bps, photometry, tiffcomp, orientation, sample_fmt;\nl_uint16  *redmap, *greenmap, *bluemap;\nl_int32    d, wpl, bpl, comptype, i, j, k, ncolors, rval, gval, bval, aval;\nl_int32    xres, yres, tiffbpl, packedbpl, halfsize;\nl_uint32   w, h, tiffword, read_oriented;\nl_uint32  *line, *ppixel, *tiffdata, *pixdata;\nPIX       *pix, *pix1;\nPIXCMAP   *cmap;\n\n    PROCNAME(\"pixReadFromTiffStream\");\n\n    if (!tif)\n        return (PIX *)ERROR_PTR(\"tif not defined\", procName, NULL);\n\n    read_oriented = 0;\n\n        /* Only accept uint image data:\n         *   SAMPLEFORMAT_UINT = 1;\n         *   SAMPLEFORMAT_INT = 2;\n         *   SAMPLEFORMAT_IEEEFP = 3;\n         *   SAMPLEFORMAT_VOID = 4;   */\n    TIFFGetFieldDefaulted(tif, TIFFTAG_SAMPLEFORMAT, &sample_fmt);\n    if (sample_fmt != SAMPLEFORMAT_UINT) {\n        L_ERROR(\"sample format = %d is not uint\\n\", procName, sample_fmt);\n        return NULL;\n    }\n\n        /* Can't read tiff in tiled format. For what is involved, see, e.g:\n         *   https://www.cs.rochester.edu/~nelson/courses/vision/\\\n         *     resources/tiff/libtiff.html#Tiles\n         * A tiled tiff can be converted to a normal (strip) tif:\n         *   tiffcp -s <input-tiled-tif> <output-strip-tif>    */\n    if (TIFFIsTiled(tif)) {\n        L_ERROR(\"tiled format is not supported\\n\", procName);\n        return NULL;\n    }\n\n        /* Old style jpeg is not supported.  We tried supporting 8 bpp.\n         * TIFFReadScanline() fails on this format, so we used RGBA\n         * reading, which generates a 4 spp image, and pulled out the\n         * red component.  However, there were problems with double-frees\n         * in cleanup.  For RGB, tiffbpl is exactly half the size that\n         * you would expect for the raster data in a scanline, which\n         * is 3 * w.  */\n    TIFFGetFieldDefaulted(tif, TIFFTAG_COMPRESSION, &tiffcomp);\n    if (tiffcomp == COMPRESSION_OJPEG) {\n        L_ERROR(\"old style jpeg format is not supported\\n\", procName);\n        return NULL;\n    }\n\n        /* Use default fields for bps and spp */\n    TIFFGetFieldDefaulted(tif, TIFFTAG_BITSPERSAMPLE, &bps);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_SAMPLESPERPIXEL, &spp);\n    if (bps != 1 && bps != 2 && bps != 4 && bps != 8 && bps != 16) {\n        L_ERROR(\"invalid bps = %d\\n\", procName, bps);\n        return NULL;\n    }\n    if (spp == 2 && bps != 8) {\n        L_WARNING(\"for 2 spp, only handle 8 bps\\n\", procName);\n        return NULL;\n    }\n    if (spp == 1)\n        d = bps;\n    else if (spp == 2)  /* gray plus alpha */\n        d = 32;  /* will convert to RGBA */\n    else if (spp == 3 || spp == 4)\n        d = 32;\n    else\n        return (PIX *)ERROR_PTR(\"spp not in set {1,2,3,4}\", procName, NULL);\n\n    TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &w);\n    TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &h);\n    if (w > MaxTiffWidth) {\n        L_ERROR(\"width = %d pixels; too large\\n\", procName, w);\n        return NULL;\n    }\n    if (h > MaxTiffHeight) {\n        L_ERROR(\"height = %d pixels; too large\\n\", procName, h);\n        return NULL;\n    }\n\n        /* The relation between the size of a byte buffer required to hold\n           a raster of image pixels (packedbpl) and the size of the tiff\n           buffer (tiffbuf) is either 1:1 or approximately 2:1, depending\n           on how the data is stored and subsampled.  Allow some slop\n           when validating the relation between buffer size and the image\n           parameters w, spp and bps. */\n    tiffbpl = TIFFScanlineSize(tif);\n    packedbpl = (bps * spp * w + 7) / 8;\n    halfsize = L_ABS(2 * tiffbpl - packedbpl) <= 8;\n#if 0\n    if (halfsize)\n        L_INFO(\"packedbpl = %d is approx. twice tiffbpl = %d\\n\", procName,\n               packedbpl, tiffbpl);\n#endif\n    if (tiffbpl != packedbpl && !halfsize) {\n        L_ERROR(\"invalid tiffbpl: tiffbpl = %d, packedbpl = %d, \"\n                \"bps = %d, spp = %d, w = %d\\n\",\n                procName, tiffbpl, packedbpl, bps, spp, w);\n        return NULL;\n    }\n\n    if ((pix = pixCreate(w, h, d)) == NULL)\n        return (PIX *)ERROR_PTR(\"pix not made\", procName, NULL);\n    pixSetInputFormat(pix, IFF_TIFF);\n    data = (l_uint8 *)pixGetData(pix);\n    wpl = pixGetWpl(pix);\n    bpl = 4 * wpl;\n\n    if (spp == 1) {\n        linebuf = (l_uint8 *)LEPT_CALLOC(tiffbpl + 1, sizeof(l_uint8));\n        for (i = 0; i < h; i++) {\n            if (TIFFReadScanline(tif, linebuf, i, 0) < 0) {\n                LEPT_FREE(linebuf);\n                pixDestroy(&pix);\n                return (PIX *)ERROR_PTR(\"line read fail\", procName, NULL);\n            }\n            memcpy(data, linebuf, tiffbpl);\n            data += bpl;\n        }\n        if (bps <= 8)\n            pixEndianByteSwap(pix);\n        else   /* bps == 16 */\n            pixEndianTwoByteSwap(pix);\n        LEPT_FREE(linebuf);\n    } else if (spp == 2 && bps == 8) {  /* gray plus alpha */\n        L_INFO(\"gray+alpha is not supported; converting to RGBA\\n\", procName);\n        pixSetSpp(pix, 4);\n        linebuf = (l_uint8 *)LEPT_CALLOC(tiffbpl + 1, sizeof(l_uint8));\n        pixdata = pixGetData(pix);\n        for (i = 0; i < h; i++) {\n            if (TIFFReadScanline(tif, linebuf, i, 0) < 0) {\n                LEPT_FREE(linebuf);\n                pixDestroy(&pix);\n                return (PIX *)ERROR_PTR(\"line read fail\", procName, NULL);\n            }\n            rowptr = linebuf;\n            ppixel = pixdata + i * wpl;\n            for (j = k = 0; j < w; j++) {\n                    /* Copy gray value into r, g and b */\n                SET_DATA_BYTE(ppixel, COLOR_RED, rowptr[k]);\n                SET_DATA_BYTE(ppixel, COLOR_GREEN, rowptr[k]);\n                SET_DATA_BYTE(ppixel, COLOR_BLUE, rowptr[k++]);\n                SET_DATA_BYTE(ppixel, L_ALPHA_CHANNEL, rowptr[k++]);\n                ppixel++;\n            }\n        }\n        LEPT_FREE(linebuf);\n    } else {  /* rgb and rgba */\n        if ((tiffdata = (l_uint32 *)LEPT_CALLOC((size_t)w * h,\n                                                 sizeof(l_uint32))) == NULL) {\n            pixDestroy(&pix);\n            return (PIX *)ERROR_PTR(\"calloc fail for tiffdata\", procName, NULL);\n        }\n            /* TIFFReadRGBAImageOriented() converts to 8 bps */\n        if (!TIFFReadRGBAImageOriented(tif, w, h, tiffdata,\n                                       ORIENTATION_TOPLEFT, 0)) {\n            LEPT_FREE(tiffdata);\n            pixDestroy(&pix);\n            return (PIX *)ERROR_PTR(\"failed to read tiffdata\", procName, NULL);\n        } else {\n            read_oriented = 1;\n        }\n\n        if (spp == 4) pixSetSpp(pix, 4);\n        line = pixGetData(pix);\n        for (i = 0; i < h; i++, line += wpl) {\n            for (j = 0, ppixel = line; j < w; j++) {\n                    /* TIFFGet* are macros */\n                tiffword = tiffdata[i * w + j];\n                rval = TIFFGetR(tiffword);\n                gval = TIFFGetG(tiffword);\n                bval = TIFFGetB(tiffword);\n                if (spp == 3) {\n                    composeRGBPixel(rval, gval, bval, ppixel);\n                } else {  /* spp == 4 */\n                    aval = TIFFGetA(tiffword);\n                    composeRGBAPixel(rval, gval, bval, aval, ppixel);\n                }\n                ppixel++;\n            }\n        }\n        LEPT_FREE(tiffdata);\n    }\n\n    if (getTiffStreamResolution(tif, &xres, &yres) == 0) {\n        pixSetXRes(pix, xres);\n        pixSetYRes(pix, yres);\n    }\n\n        /* Find and save the compression type */\n    comptype = getTiffCompressedFormat(tiffcomp);\n    pixSetInputFormat(pix, comptype);\n\n    if (TIFFGetField(tif, TIFFTAG_COLORMAP, &redmap, &greenmap, &bluemap)) {\n            /* Save the colormap as a pix cmap.  Because the\n             * tiff colormap components are 16 bit unsigned,\n             * and go from black (0) to white (0xffff), the\n             * the pix cmap takes the most significant byte. */\n        if (bps > 8) {\n            pixDestroy(&pix);\n            return (PIX *)ERROR_PTR(\"colormap size > 256\", procName, NULL);\n        }\n        if ((cmap = pixcmapCreate(bps)) == NULL) {\n            pixDestroy(&pix);\n            return (PIX *)ERROR_PTR(\"colormap not made\", procName, NULL);\n        }\n        ncolors = 1 << bps;\n        for (i = 0; i < ncolors; i++)\n            pixcmapAddColor(cmap, redmap[i] >> 8, greenmap[i] >> 8,\n                            bluemap[i] >> 8);\n        if (pixSetColormap(pix, cmap)) {\n            pixDestroy(&pix);\n            return (PIX *)ERROR_PTR(\"invalid colormap\", procName, NULL);\n        }\n\n            /* Remove the colormap for 1 bpp. */\n        if (bps == 1) {\n            pix1 = pixRemoveColormap(pix, REMOVE_CMAP_BASED_ON_SRC);\n            pixDestroy(&pix);\n            pix = pix1;\n        }\n    } else {   /* No colormap: check photometry and invert if necessary */\n        if (!TIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &photometry)) {\n                /* Guess default photometry setting.  Assume min_is_white\n                 * if compressed 1 bpp; min_is_black otherwise. */\n            if (tiffcomp == COMPRESSION_CCITTFAX3 ||\n                tiffcomp == COMPRESSION_CCITTFAX4 ||\n                tiffcomp == COMPRESSION_CCITTRLE ||\n                tiffcomp == COMPRESSION_CCITTRLEW) {\n                photometry = PHOTOMETRIC_MINISWHITE;\n            } else {\n                photometry = PHOTOMETRIC_MINISBLACK;\n            }\n        }\n        if ((d == 1 && photometry == PHOTOMETRIC_MINISBLACK) ||\n            (d == 8 && photometry == PHOTOMETRIC_MINISWHITE))\n            pixInvert(pix, pix);\n    }\n\n    if (TIFFGetField(tif, TIFFTAG_ORIENTATION, &orientation)) {\n        if (orientation >= 1 && orientation <= 8) {\n            struct tiff_transform *transform = (read_oriented) ?\n                &tiff_partial_orientation_transforms[orientation - 1] :\n                &tiff_orientation_transforms[orientation - 1];\n            if (transform->vflip) pixFlipTB(pix, pix);\n            if (transform->hflip) pixFlipLR(pix, pix);\n            if (transform->rotate) {\n                PIX *oldpix = pix;\n                pix = pixRotate90(oldpix, transform->rotate);\n                pixDestroy(&oldpix);\n            }\n        }\n    }\n\n    text = NULL;\n    TIFFGetField(tif, TIFFTAG_IMAGEDESCRIPTION, &text);\n    if (text) pixSetText(pix, text);\n    return pix;\n}\n\n\n/*--------------------------------------------------------------*\n *                       Writing to file                        *\n *--------------------------------------------------------------*/\n/*!\n * \\brief   pixWriteTiff()\n *\n * \\param[in]    filename   to write to\n * \\param[in]    pix        any depth, colormap will be removed\n * \\param[in]    comptype   IFF_TIFF, IFF_TIFF_RLE, IFF_TIFF_PACKBITS,\n *                          IFF_TIFF_G3, IFF_TIFF_G4,\n *                          IFF_TIFF_LZW, IFF_TIFF_ZIP, IFF_TIFF_JPEG\n * \\param[in]    modestr    \"a\" or \"w\"\n * \\return  0 if OK, 1 on error\n *\n * <pre>\n * Notes:\n *      (1) For multipage tiff, write the first pix with mode \"w\" and\n *          all subsequent pix with mode \"a\".\n *      (2) For multipage tiff, there is considerable overhead in the\n *          machinery to append an image and add the directory entry,\n *          and the time required for each image increases linearly\n *          with the number of images in the file.\n * </pre>\n */\nl_ok\npixWriteTiff(const char  *filename,\n             PIX         *pix,\n             l_int32      comptype,\n             const char  *modestr)\n{\n    return pixWriteTiffCustom(filename, pix, comptype, modestr,\n                              NULL, NULL, NULL, NULL);\n}\n\n\n/*!\n * \\brief   pixWriteTiffCustom()\n *\n * \\param[in]    filename   to write to\n * \\param[in]    pix\n * \\param[in]    comptype   IFF_TIFF, IFF_TIFF_RLE, IFF_TIFF_PACKBITS,\n *                          IFF_TIFF_G3, IFF_TIFF_G4,\n *                          IFF_TIFF_LZW, IFF_TIFF_ZIP, IFF_TIFF_JPEG\n * \\param[in]    modestr    \"a\" or \"w\"\n * \\param[in]    natags [optional] NUMA of custom tiff tags\n * \\param[in]    savals [optional] SARRAY of values\n * \\param[in]    satypes [optional] SARRAY of types\n * \\param[in]    nasizes [optional] NUMA of sizes\n * \\return  0 if OK, 1 on error\n *\n *  Usage:\n *      1 This writes a page image to a tiff file, with optional\n *          extra tags defined in tiff.h\n *      2 For multipage tiff, write the first pix with mode \"w\" and\n *          all subsequent pix with mode \"a\".\n *      3 For the custom tiff tags:\n *          a The three arrays {natags, savals, satypes} must all be\n *              either NULL or defined and of equal size.\n *          b If they are defined, the tags are an array of integers,\n *              the vals are an array of values in string format, and\n *              the types are an array of types in string format.\n *          c All valid tags are definined in tiff.h.\n *          d The types allowed are the set of strings:\n *                \"char*\"\n *                \"l_uint8*\"\n *                \"l_uint16\"\n *                \"l_uint32\"\n *                \"l_int32\"\n *                \"l_float64\"\n *                \"l_uint16-l_uint16\" note the dash; use it between the\n *                                    two l_uint16 vals in the val string\n *              Of these, \"char*\" and \"l_uint16\" are the most commonly used.\n *          e The last array, nasizes, is also optional.  It is for\n *              tags that take an array of bytes for a value, a number of\n *              elements in the array, and a type that is either \"char*\"\n *              or \"l_uint8*\" probably either will work.\n *              Use NULL if there are no such tags.\n *          f VERY IMPORTANT: if there are any tags that require the\n *              extra size value, stored in nasizes, they must be\n *              written first!\n */\nl_ok\npixWriteTiffCustom(const char  *filename,\n                   PIX         *pix,\n                   l_int32      comptype,\n                   const char  *modestr,\n                   NUMA        *natags,\n                   SARRAY      *savals,\n                   SARRAY      *satypes,\n                   NUMA        *nasizes)\n{\nl_int32  ret;\nTIFF    *tif;\n\n    PROCNAME(\"pixWriteTiffCustom\");\n\n    if (!filename)\n        return ERROR_INT(\"filename not defined\", procName, 1);\n    if (!pix)\n        return ERROR_INT(\"pix not defined\", procName, 1);\n\n    if ((tif = openTiff(filename, modestr)) == NULL)\n        return ERROR_INT(\"tif not opened\", procName, 1);\n    ret = pixWriteToTiffStream(tif, pix, comptype, natags, savals,\n                               satypes, nasizes);\n    TIFFClose(tif);\n    return ret;\n}\n\n\n/*--------------------------------------------------------------*\n *                       Writing to stream                      *\n *--------------------------------------------------------------*/\n/*!\n * \\brief   pixWriteStreamTiff()\n *\n * \\param[in]    fp       file stream\n * \\param[in]    pix\n * \\param[in]    comptype IFF_TIFF, IFF_TIFF_RLE, IFF_TIFF_PACKBITS,\n *                        IFF_TIFF_G3, IFF_TIFF_G4,\n *                        IFF_TIFF_LZW, IFF_TIFF_ZIP, IFF_TIFF_JPEG\n * \\return  0 if OK, 1 on error\n *\n * <pre>\n * Notes:\n *      (1) This writes a single image to a file stream opened for writing.\n *      (2) If the pix has a colormap, it is preserved in the output file.\n *      (3) For images with bpp > 1, this resets the comptype, if\n *          necessary, to write uncompressed data.\n *      (4) G3 and G4 are only defined for 1 bpp.\n *      (5) We only allow PACKBITS for bpp = 1, because for bpp > 1\n *          it typically expands images that are not synthetically generated.\n *      (6) G4 compression is typically about twice as good as G3.\n *          G4 is excellent for binary compression of text/line-art,\n *          but terrible for halftones and dithered patterns.  (In\n *          fact, G4 on halftones can give a file that is larger\n *          than uncompressed!)  If a binary image has dithered\n *          regions, it is usually better to compress with png.\n * </pre>\n */\nl_ok\npixWriteStreamTiff(FILE    *fp,\n                   PIX     *pix,\n                   l_int32  comptype)\n{\n    return pixWriteStreamTiffWA(fp, pix, comptype, \"w\");\n}\n\n\n/*!\n * \\brief   pixWriteStreamTiffWA()\n *\n * \\param[in]    fp       file stream opened for append or write\n * \\param[in]    pix\n * \\param[in]    comptype IFF_TIFF, IFF_TIFF_RLE, IFF_TIFF_PACKBITS,\n *                        IFF_TIFF_G3, IFF_TIFF_G4,\n *                        IFF_TIFF_LZW, IFF_TIFF_ZIP, IFF_TIFF_JPEG\n * \\param[in]    modestr  \"w\" or \"a\"\n * \\return  0 if OK, 1 on error\n *\n * <pre>\n * Notes:\n *      (1) See pixWriteStreamTiff()\n * </pre>\n */\nl_ok\npixWriteStreamTiffWA(FILE        *fp,\n                     PIX         *pix,\n                     l_int32      comptype,\n                     const char  *modestr)\n{\nTIFF  *tif;\n\n    PROCNAME(\"pixWriteStreamTiffWA\");\n\n    if (!fp)\n        return ERROR_INT(\"stream not defined\", procName, 1 );\n    if (!pix)\n        return ERROR_INT(\"pix not defined\", procName, 1 );\n    if (strcmp(modestr, \"w\") && strcmp(modestr, \"a\"))\n        return ERROR_INT(\"modestr not 'w' or 'a'\", procName, 1 );\n\n    if (pixGetDepth(pix) != 1 && comptype != IFF_TIFF &&\n        comptype != IFF_TIFF_LZW && comptype != IFF_TIFF_ZIP &&\n        comptype != IFF_TIFF_JPEG) {\n        L_WARNING(\"invalid compression type for bpp > 1\\n\", procName);\n        comptype = IFF_TIFF_ZIP;\n    }\n\n    if ((tif = fopenTiff(fp, modestr)) == NULL)\n        return ERROR_INT(\"tif not opened\", procName, 1);\n\n    if (pixWriteToTiffStream(tif, pix, comptype, NULL, NULL, NULL, NULL)) {\n        TIFFCleanup(tif);\n        return ERROR_INT(\"tif write error\", procName, 1);\n    }\n\n    TIFFCleanup(tif);\n    return 0;\n}\n\n\n/*!\n * \\brief   pixWriteToTiffStream()\n *\n * \\param[in]    tif       data structure, opened to a file\n * \\param[in]    pix\n * \\param[in]    comptype  IFF_TIFF: for any image; no compression\n *                         IFF_TIFF_RLE, IFF_TIFF_PACKBITS: for 1 bpp only\n *                         IFF_TIFF_G4 and IFF_TIFF_G3: for 1 bpp only\n *                         IFF_TIFF_LZW, IFF_TIFF_ZIP: lossless for any image\n *                         IFF_TIFF_JPEG: lossy 8 bpp gray or rgb\n * \\param[in]    natags    [optional] NUMA of custom tiff tags\n * \\param[in]    savals    [optional] SARRAY of values\n * \\param[in]    satypes   [optional] SARRAY of types\n * \\param[in]    nasizes   [optional] NUMA of sizes\n * \\return  0 if OK, 1 on error\n *\n * <pre>\n * Notes:\n *      (1) This static function should only be called through higher\n *          level functions in this file; namely, pixWriteTiffCustom(),\n *          pixWriteTiff(), pixWriteStreamTiff(), pixWriteMemTiff()\n *          and pixWriteMemTiffCustom().\n *      (2) We only allow PACKBITS for bpp = 1, because for bpp > 1\n *          it typically expands images that are not synthetically generated.\n *      (3) See pixWriteTiffCustom() for details on how to use\n *          the last four parameters for customized tiff tags.\n *      (4) The only valid pixel depths in leptonica are 1, 2, 4, 8, 16\n *          and 32.  However, it is possible, and in some cases desirable,\n *          to write out a tiff file using an rgb pix that has 24 bpp.\n *          This can be created by appending the raster data for a 24 bpp\n *          image (with proper scanline padding) directly to a 24 bpp\n *          pix that was created without a data array.  See note in\n *          pixWriteStreamPng() for an example.\n * </pre>\n */\nstatic l_int32\npixWriteToTiffStream(TIFF    *tif,\n                     PIX     *pix,\n                     l_int32  comptype,\n                     NUMA    *natags,\n                     SARRAY  *savals,\n                     SARRAY  *satypes,\n                     NUMA    *nasizes)\n{\nl_uint8   *linebuf, *data;\nl_uint16   redmap[256], greenmap[256], bluemap[256];\nl_int32    w, h, d, spp, i, j, k, wpl, bpl, tiffbpl, ncolors, cmapsize;\nl_int32   *rmap, *gmap, *bmap;\nl_int32    xres, yres;\nl_uint32  *line, *ppixel;\nPIX       *pixt;\nPIXCMAP   *cmap;\nchar      *text;\n\n    PROCNAME(\"pixWriteToTiffStream\");\n\n    if (!tif)\n        return ERROR_INT(\"tif stream not defined\", procName, 1);\n    if (!pix)\n        return ERROR_INT( \"pix not defined\", procName, 1 );\n\n    pixSetPadBits(pix, 0);\n    pixGetDimensions(pix, &w, &h, &d);\n    spp = pixGetSpp(pix);\n    xres = pixGetXRes(pix);\n    yres = pixGetYRes(pix);\n    if (xres == 0) xres = DefaultResolution;\n    if (yres == 0) yres = DefaultResolution;\n\n        /* ------------------ Write out the header -------------  */\n    TIFFSetField(tif, TIFFTAG_RESOLUTIONUNIT, (l_uint32)RESUNIT_INCH);\n    TIFFSetField(tif, TIFFTAG_XRESOLUTION, (l_float64)xres);\n    TIFFSetField(tif, TIFFTAG_YRESOLUTION, (l_float64)yres);\n\n    TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, (l_uint32)w);\n    TIFFSetField(tif, TIFFTAG_IMAGELENGTH, (l_uint32)h);\n    TIFFSetField(tif, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\n\n    if ((text = pixGetText(pix)) != NULL)\n        TIFFSetField(tif, TIFFTAG_IMAGEDESCRIPTION, text);\n\n    if (d == 1 && !pixGetColormap(pix)) {\n            /* If d == 1, preserve the colormap.  Note that when\n             * d == 1 pix with colormaps are read, the colormaps\n             * are removed.  The only pix in leptonica that have\n             * colormaps are made programmatically. */\n        TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISWHITE);\n    } else if ((d == 32 && spp == 3) || d == 24) {\n        TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n        TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, (l_uint16)3);\n        TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE,\n                       (l_uint16)8, (l_uint16)8, (l_uint16)8);\n    } else if (d == 32 && spp == 4) {\n        l_uint16  val[1];\n        val[0] = EXTRASAMPLE_ASSOCALPHA;\n        TIFFSetField(tif, TIFFTAG_EXTRASAMPLES, (l_uint16)1, &val);\n        TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n        TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, (l_uint16)4);\n        TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE,\n                     (l_uint16)8, (l_uint16)8, (l_uint16)8, (l_uint16)8);\n    } else if (d == 16) {  /* we only support spp = 1, bps = 16 */\n        TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\n    } else if ((cmap = pixGetColormap(pix)) == NULL) {\n        TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\n    } else {  /* Save colormap in the tiff; not more than 256 colors */\n        if (d > 8) {\n            L_ERROR(\"d = %d > 8 with colormap!; reducing to 8\\n\", procName, d);\n            d = 8;\n        }\n        pixcmapToArrays(cmap, &rmap, &gmap, &bmap, NULL);\n        ncolors = pixcmapGetCount(cmap);\n        ncolors = L_MIN(256, ncolors);  /* max 256 */\n        cmapsize = 1 << d;\n        cmapsize = L_MIN(256, cmapsize);  /* power of 2; max 256 */\n        if (ncolors > cmapsize) {\n            L_WARNING(\"too many colors in cmap for tiff; truncating\\n\",\n                      procName);\n            ncolors = cmapsize;\n        }\n        for (i = 0; i < ncolors; i++) {\n            redmap[i] = (rmap[i] << 8) | rmap[i];\n            greenmap[i] = (gmap[i] << 8) | gmap[i];\n            bluemap[i] = (bmap[i] << 8) | bmap[i];\n        }\n        for (i = ncolors; i < cmapsize; i++)  /* init, even though not used */\n            redmap[i] = greenmap[i] = bluemap[i] = 0;\n        LEPT_FREE(rmap);\n        LEPT_FREE(gmap);\n        LEPT_FREE(bmap);\n\n        TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_PALETTE);\n        TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, (l_uint16)1);\n        TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, (l_uint16)d);\n        TIFFSetField(tif, TIFFTAG_COLORMAP, redmap, greenmap, bluemap);\n    }\n\n    if (d <= 16) {\n        TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, (l_uint16)d);\n        TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, (l_uint16)1);\n    }\n\n    TIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n    if (comptype == IFF_TIFF) {  /* no compression */\n        TIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_NONE);\n    } else if (comptype == IFF_TIFF_G4) {\n        TIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_CCITTFAX4);\n    } else if (comptype == IFF_TIFF_G3) {\n        TIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_CCITTFAX3);\n    } else if (comptype == IFF_TIFF_RLE) {\n        TIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_CCITTRLE);\n    } else if (comptype == IFF_TIFF_PACKBITS) {\n        TIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_PACKBITS);\n    } else if (comptype == IFF_TIFF_LZW) {\n        TIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_LZW);\n    } else if (comptype == IFF_TIFF_ZIP) {\n        TIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_ADOBE_DEFLATE);\n    } else if (comptype == IFF_TIFF_JPEG) {\n        TIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_JPEG);\n    } else {\n        L_WARNING(\"unknown tiff compression; using none\\n\", procName);\n        TIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_NONE);\n    }\n\n        /* This is a no-op if arrays are NULL */\n    writeCustomTiffTags(tif, natags, savals, satypes, nasizes);\n\n        /* ------------- Write out the image data -------------  */\n    tiffbpl = TIFFScanlineSize(tif);\n    wpl = pixGetWpl(pix);\n    bpl = 4 * wpl;\n    if (tiffbpl > bpl)\n        lept_stderr(\"Big trouble: tiffbpl = %d, bpl = %d\\n\", tiffbpl, bpl);\n    if ((linebuf = (l_uint8 *)LEPT_CALLOC(1, bpl)) == NULL)\n        return ERROR_INT(\"calloc fail for linebuf\", procName, 1);\n\n        /* Use single strip for image */\n    TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, h);\n\n    if (d != 24 && d != 32) {\n        if (d == 16)\n            pixt = pixEndianTwoByteSwapNew(pix);\n        else\n            pixt = pixEndianByteSwapNew(pix);\n        data = (l_uint8 *)pixGetData(pixt);\n        for (i = 0; i < h; i++, data += bpl) {\n            memcpy(linebuf, data, tiffbpl);\n            if (TIFFWriteScanline(tif, linebuf, i, 0) < 0)\n                break;\n        }\n        pixDestroy(&pixt);\n    } else if (d == 24) {  /* See note 4 above: special case of 24 bpp rgb */\n        for (i = 0; i < h; i++) {\n            line = pixGetData(pix) + i * wpl;\n            if (TIFFWriteScanline(tif, (l_uint8 *)line, i, 0) < 0)\n                break;\n        }\n    } else {  /* 32 bpp rgb or rgba */\n        for (i = 0; i < h; i++) {\n            line = pixGetData(pix) + i * wpl;\n            for (j = 0, k = 0, ppixel = line; j < w; j++) {\n                linebuf[k++] = GET_DATA_BYTE(ppixel, COLOR_RED);\n                linebuf[k++] = GET_DATA_BYTE(ppixel, COLOR_GREEN);\n                linebuf[k++] = GET_DATA_BYTE(ppixel, COLOR_BLUE);\n                if (spp == 4)\n                    linebuf[k++] = GET_DATA_BYTE(ppixel, L_ALPHA_CHANNEL);\n                ppixel++;\n            }\n            if (TIFFWriteScanline(tif, linebuf, i, 0) < 0)\n                break;\n        }\n    }\n\n/*    TIFFWriteDirectory(tif); */\n    LEPT_FREE(linebuf);\n\n    return 0;\n}\n\n\n/*!\n * \\brief   writeCustomTiffTags()\n *\n * \\param[in]    tif\n * \\param[in]    natags   [optional] NUMA of custom tiff tags\n * \\param[in]    savals   [optional] SARRAY of values\n * \\param[in]    satypes  [optional] SARRAY of types\n * \\param[in]    nasizes  [optional] NUMA of sizes\n * \\return  0 if OK, 1 on error\n *\n * <pre>\n * Notes:\n *      (1) This static function should be called indirectly through\n *          higher level functions, such as pixWriteTiffCustom(),\n *          which call pixWriteToTiffStream().  See details in\n *          pixWriteTiffCustom() for using the 4 input arrays.\n *      (2) This is a no-op if the first 3 arrays are all NULL.\n *      (3) Otherwise, the first 3 arrays must be defined and all\n *          of equal size.\n *      (4) The fourth array is always optional.\n *      (5) The most commonly used types are \"char*\" and \"u_int16\".\n *          See tiff.h for a full listing of the tiff tags.\n *          Note that many of these tags, in particular the bit tags,\n *          are intended to be private, and cannot be set by this function.\n *          Examples are the STRIPOFFSETS and STRIPBYTECOUNTS tags,\n *          which are bit tags that are automatically set in the header,\n *          and can be extracted using tiffdump.\n * </pre>\n */\nstatic l_int32\nwriteCustomTiffTags(TIFF    *tif,\n                    NUMA    *natags,\n                    SARRAY  *savals,\n                    SARRAY  *satypes,\n                    NUMA    *nasizes)\n{\nchar      *sval, *type;\nl_int32    i, n, ns, size, tagval, val;\nl_float64  dval;\nl_uint32   uval, uval2;\n\n    PROCNAME(\"writeCustomTiffTags\");\n\n    if (!tif)\n        return ERROR_INT(\"tif stream not defined\", procName, 1);\n    if (!natags && !savals && !satypes)\n        return 0;\n    if (!natags || !savals || !satypes)\n        return ERROR_INT(\"not all arrays defined\", procName, 1);\n    n = numaGetCount(natags);\n    if ((sarrayGetCount(savals) != n) || (sarrayGetCount(satypes) != n))\n        return ERROR_INT(\"not all sa the same size\", procName, 1);\n\n        /* The sized arrays (4 args to TIFFSetField) are written first */\n    if (nasizes) {\n        ns = numaGetCount(nasizes);\n        if (ns > n)\n            return ERROR_INT(\"too many 4-arg tag calls\", procName, 1);\n        for (i = 0; i < ns; i++) {\n            numaGetIValue(natags, i, &tagval);\n            sval = sarrayGetString(savals, i, L_NOCOPY);\n            type = sarrayGetString(satypes, i, L_NOCOPY);\n            numaGetIValue(nasizes, i, &size);\n            if (strcmp(type, \"char*\") && strcmp(type, \"l_uint8*\"))\n                L_WARNING(\"array type not char* or l_uint8*; ignore\\n\",\n                          procName);\n            TIFFSetField(tif, tagval, size, sval);\n        }\n    } else {\n        ns = 0;\n    }\n\n        /* The typical tags (3 args to TIFFSetField) are now written */\n    for (i = ns; i < n; i++) {\n        numaGetIValue(natags, i, &tagval);\n        sval = sarrayGetString(savals, i, L_NOCOPY);\n        type = sarrayGetString(satypes, i, L_NOCOPY);\n        if (!strcmp(type, \"char*\") || !strcmp(type, \"const char*\")) {\n            TIFFSetField(tif, tagval, sval);\n        } else if (!strcmp(type, \"l_uint16\")) {\n            if (sscanf(sval, \"%u\", &uval) == 1) {\n                TIFFSetField(tif, tagval, (l_uint16)uval);\n            } else {\n                lept_stderr(\"val %s not of type %s\\n\", sval, type);\n                return ERROR_INT(\"custom tag(s) not written\", procName, 1);\n            }\n        } else if (!strcmp(type, \"l_uint32\")) {\n            if (sscanf(sval, \"%u\", &uval) == 1) {\n                TIFFSetField(tif, tagval, uval);\n            } else {\n                lept_stderr(\"val %s not of type %s\\n\", sval, type);\n                return ERROR_INT(\"custom tag(s) not written\", procName, 1);\n            }\n        } else if (!strcmp(type, \"l_int32\")) {\n            if (sscanf(sval, \"%d\", &val) == 1) {\n                TIFFSetField(tif, tagval, val);\n            } else {\n                lept_stderr(\"val %s not of type %s\\n\", sval, type);\n                return ERROR_INT(\"custom tag(s) not written\", procName, 1);\n            }\n        } else if (!strcmp(type, \"l_float64\")) {\n            if (sscanf(sval, \"%lf\", &dval) == 1) {\n                TIFFSetField(tif, tagval, dval);\n            } else {\n                lept_stderr(\"val %s not of type %s\\n\", sval, type);\n                return ERROR_INT(\"custom tag(s) not written\", procName, 1);\n            }\n        } else if (!strcmp(type, \"l_uint16-l_uint16\")) {\n            if (sscanf(sval, \"%u-%u\", &uval, &uval2) == 2) {\n                TIFFSetField(tif, tagval, (l_uint16)uval, (l_uint16)uval2);\n            } else {\n                lept_stderr(\"val %s not of type %s\\n\", sval, type);\n                return ERROR_INT(\"custom tag(s) not written\", procName, 1);\n            }\n        } else {\n            lept_stderr(\"unknown type %s\\n\",type);\n            return ERROR_INT(\"unknown type; tag(s) not written\", procName, 1);\n        }\n    }\n    return 0;\n}\n\n\n/*--------------------------------------------------------------*\n *               Reading and writing multipage tiff             *\n *--------------------------------------------------------------*/\n/*!\n * \\brief   pixReadFromMultipageTiff()\n *\n * \\param[in]      fname     filename\n * \\param[in,out]  poffset   set offset to 0 for first image\n * \\return  pix, or NULL on error or if previous call returned the last image\n *\n * <pre>\n * Notes:\n *      (1) This allows overhead for traversal of a multipage tiff file\n *          to be linear in the number of images.  This will also work\n *          with a singlepage tiff file.\n *      (2) No TIFF internal data structures are exposed to the caller\n *          (thanks to Jeff Breidenbach).\n *      (3) offset is the byte offset of a particular image in a multipage\n *          tiff file. To get the first image in the file, input the\n *          special offset value of 0.\n *      (4) The offset is updated to point to the next image, for a\n *          subsequent call.\n *      (5) On the last image, the offset returned is 0.  Exit the loop\n *          when the returned offset is 0.\n *      (6) For reading a multipage tiff from a memory buffer, see\n *            pixReadMemFromMultipageTiff()\n *      (7) Example usage for reading all the images in the tif file:\n *            size_t offset = 0;\n *            do {\n *                Pix *pix = pixReadFromMultipageTiff(filename, &offset);\n *                // do something with pix\n *            } while (offset != 0);\n * </pre>\n */\nPIX *\npixReadFromMultipageTiff(const char  *fname,\n                         size_t      *poffset)\n{\nl_int32  retval;\nsize_t   offset;\nPIX     *pix;\nTIFF    *tif;\n\n    PROCNAME(\"pixReadFromMultipageTiff\");\n\n    if (!fname)\n        return (PIX *)ERROR_PTR(\"fname not defined\", procName, NULL);\n    if (!poffset)\n        return (PIX *)ERROR_PTR(\"&offset not defined\", procName, NULL);\n\n    if ((tif = openTiff(fname, \"r\")) == NULL) {\n        L_ERROR(\"tif open failed for %s\\n\", procName, fname);\n        return NULL;\n    }\n\n        /* Set ptrs in the TIFF to the beginning of the image */\n    offset = *poffset;\n    retval = (offset == 0) ? TIFFSetDirectory(tif, 0)\n                            : TIFFSetSubDirectory(tif, offset);\n    if (retval == 0) {\n        TIFFCleanup(tif);\n        return NULL;\n    }\n\n    if ((pix = pixReadFromTiffStream(tif)) == NULL) {\n        TIFFCleanup(tif);\n        return NULL;\n    }\n\n        /* Advance to the next image and return the new offset */\n    TIFFReadDirectory(tif);\n    *poffset = TIFFCurrentDirOffset(tif);\n    TIFFClose(tif);\n    return pix;\n}\n\n\n/*!\n * \\brief   pixaReadMultipageTiff()\n *\n * \\param[in]    filename    input tiff file\n * \\return  pixa of page images, or NULL on error\n */\nPIXA *\npixaReadMultipageTiff(const char  *filename)\n{\nl_int32  i, npages;\nFILE    *fp;\nPIX     *pix;\nPIXA    *pixa;\nTIFF    *tif;\n\n    PROCNAME(\"pixaReadMultipageTiff\");\n\n    if (!filename)\n        return (PIXA *)ERROR_PTR(\"filename not defined\", procName, NULL);\n\n    if ((fp = fopenReadStream(filename)) == NULL)\n        return (PIXA *)ERROR_PTR(\"stream not opened\", procName, NULL);\n    if (fileFormatIsTiff(fp)) {\n        tiffGetCount(fp, &npages);\n        L_INFO(\" Tiff: %d pages\\n\", procName, npages);\n    } else {\n        return (PIXA *)ERROR_PTR(\"file not tiff\", procName, NULL);\n    }\n\n    if ((tif = fopenTiff(fp, \"r\")) == NULL)\n        return (PIXA *)ERROR_PTR(\"tif not opened\", procName, NULL);\n\n    pixa = pixaCreate(npages);\n    pix = NULL;\n    for (i = 0; i < npages; i++) {\n        if ((pix = pixReadFromTiffStream(tif)) != NULL) {\n            pixaAddPix(pixa, pix, L_INSERT);\n        } else {\n            L_WARNING(\"pix not read for page %d\\n\", procName, i);\n        }\n\n            /* Advance to the next directory (i.e., the next image) */\n        if (TIFFReadDirectory(tif) == 0)\n            break;\n    }\n\n    fclose(fp);\n    TIFFCleanup(tif);\n    return pixa;\n}\n\n\n/*!\n * \\brief   pixaWriteMultipageTiff()\n *\n * \\param[in]    fname      input tiff file\n * \\param[in]    pixa       any depth; colormap will be removed\n * \\return  0 if OK, 1 on error\n *\n * <pre>\n * Notes:\n *      (1) The tiff directory overhead is O(n^2).  I have not been\n *          able to reduce it to O(n).  The overhead for n = 2000 is\n *          about 1 second.\n * </pre>\n */\nl_ok\npixaWriteMultipageTiff(const char  *fname,\n                       PIXA        *pixa)\n{\nconst char  *modestr;\nl_int32      i, n;\nPIX         *pix1;\n\n    PROCNAME(\"pixaWriteMultipageTiff\");\n\n    if (!fname)\n        return ERROR_INT(\"fname not defined\", procName, 1);\n    if (!pixa)\n        return ERROR_INT(\"pixa not defined\", procName, 1);\n\n    n = pixaGetCount(pixa);\n    for (i = 0; i < n; i++) {\n        modestr = (i == 0) ? \"w\" : \"a\";\n        pix1 = pixaGetPix(pixa, i, L_CLONE);\n        if (pixGetDepth(pix1) == 1)\n            pixWriteTiff(fname, pix1, IFF_TIFF_G4, modestr);\n        else\n            pixWriteTiff(fname, pix1, IFF_TIFF_ZIP, modestr);\n        pixDestroy(&pix1);\n    }\n\n    return 0;\n}\n\n\n/*!\n * \\brief   writeMultipageTiff()\n *\n * \\param[in]    dirin   input directory\n * \\param[in]    substr  [optional] substring filter on filenames; can be NULL\n * \\param[in]    fileout output multipage tiff file\n * \\return  0 if OK, 1 on error\n *\n * <pre>\n * Notes:\n *      (1) This writes a set of image files in a directory out\n *          as a multipage tiff file.  The images can be in any\n *          initial file format.\n *      (2) Images with a colormap have the colormap removed before\n *          re-encoding as tiff.\n *      (3) All images are encoded losslessly.  Those with 1 bpp are\n *          encoded 'g4'.  The rest are encoded as 'zip' (flate encoding).\n *          Because it is lossless, this is an expensive method for\n *          saving most rgb images.\n *      (4) The tiff directory overhead is quadratic in the number of\n *          images.  To avoid this for very large numbers of images to be\n *          written, apply the method used in pixaWriteMultipageTiff().\n * </pre>\n */\nl_ok\nwriteMultipageTiff(const char  *dirin,\n                   const char  *substr,\n                   const char  *fileout)\n{\nSARRAY  *sa;\n\n    PROCNAME(\"writeMultipageTiff\");\n\n    if (!dirin)\n        return ERROR_INT(\"dirin not defined\", procName, 1);\n    if (!fileout)\n        return ERROR_INT(\"fileout not defined\", procName, 1);\n\n        /* Get all filtered and sorted full pathnames. */\n    sa = getSortedPathnamesInDirectory(dirin, substr, 0, 0);\n\n        /* Generate the tiff file */\n    writeMultipageTiffSA(sa, fileout);\n    sarrayDestroy(&sa);\n    return 0;\n}\n\n\n/*!\n * \\brief   writeMultipageTiffSA()\n *\n * \\param[in]    sa       string array of full path names\n * \\param[in]    fileout  output ps file\n * \\return  0 if OK, 1 on error\n *\n * <pre>\n * Notes:\n *      (1) See writeMultipageTiff()\n * </pre>\n */\nl_ok\nwriteMultipageTiffSA(SARRAY      *sa,\n                     const char  *fileout)\n{\nchar        *fname;\nconst char  *op;\nl_int32      i, nfiles, firstfile, format;\nPIX         *pix;\n\n    PROCNAME(\"writeMultipageTiffSA\");\n\n    if (!sa)\n        return ERROR_INT(\"sa not defined\", procName, 1);\n    if (!fileout)\n        return ERROR_INT(\"fileout not defined\", procName, 1);\n\n    nfiles = sarrayGetCount(sa);\n    firstfile = TRUE;\n    for (i = 0; i < nfiles; i++) {\n        op = (firstfile) ? \"w\" : \"a\";\n        fname = sarrayGetString(sa, i, L_NOCOPY);\n        findFileFormat(fname, &format);\n        if (format == IFF_UNKNOWN) {\n            L_INFO(\"format of %s not known\\n\", procName, fname);\n            continue;\n        }\n\n        if ((pix = pixRead(fname)) == NULL) {\n            L_WARNING(\"pix not made for file: %s\\n\", procName, fname);\n            continue;\n        }\n        if (pixGetDepth(pix) == 1)\n            pixWriteTiff(fileout, pix, IFF_TIFF_G4, op);\n        else\n            pixWriteTiff(fileout, pix, IFF_TIFF_ZIP, op);\n        firstfile = FALSE;\n        pixDestroy(&pix);\n    }\n\n    return 0;\n}\n\n\n/*--------------------------------------------------------------*\n *                    Print info to stream                      *\n *--------------------------------------------------------------*/\n/*!\n * \\brief   fprintTiffInfo()\n *\n * \\param[in]    fpout    stream for output of tag data\n * \\param[in]    tiffile  input\n * \\return  0 if OK; 1 on error\n */\nl_ok\nfprintTiffInfo(FILE        *fpout,\n               const char  *tiffile)\n{\nTIFF  *tif;\n\n    PROCNAME(\"fprintTiffInfo\");\n\n    if (!tiffile)\n        return ERROR_INT(\"tiffile not defined\", procName, 1);\n    if (!fpout)\n        return ERROR_INT(\"stream out not defined\", procName, 1);\n\n    if ((tif = openTiff(tiffile, \"rb\")) == NULL)\n        return ERROR_INT(\"tif not open for read\", procName, 1);\n\n    TIFFPrintDirectory(tif, fpout, 0);\n    TIFFClose(tif);\n\n    return 0;\n}\n\n\n/*--------------------------------------------------------------*\n *                        Get page count                        *\n *--------------------------------------------------------------*/\n/*!\n * \\brief   tiffGetCount()\n *\n * \\param[in]    fp   file stream opened for read\n * \\param[out]   pn   number of images\n * \\return  0 if OK; 1 on error\n */\nl_ok\ntiffGetCount(FILE     *fp,\n             l_int32  *pn)\n{\nl_int32  i;\nTIFF    *tif;\n\n    PROCNAME(\"tiffGetCount\");\n\n    if (!fp)\n        return ERROR_INT(\"stream not defined\", procName, 1);\n    if (!pn)\n        return ERROR_INT(\"&n not defined\", procName, 1);\n    *pn = 0;\n\n    if ((tif = fopenTiff(fp, \"r\")) == NULL)\n        return ERROR_INT(\"tif not open for read\", procName, 1);\n\n    for (i = 1; ; i++) {\n        if (TIFFReadDirectory(tif) == 0)\n            break;\n        if (i == ManyPagesInTiffFile + 1) {\n            L_WARNING(\"big file: more than %d pages\\n\", procName,\n                      ManyPagesInTiffFile);\n        }\n    }\n    *pn = i;\n    TIFFCleanup(tif);\n    return 0;\n}\n\n\n/*--------------------------------------------------------------*\n *                   Get resolution from tif                    *\n *--------------------------------------------------------------*/\n/*!\n * \\brief   getTiffResolution()\n *\n * \\param[in]    fp            file stream opened for read\n * \\param[out]   pxres, pyres  resolution in ppi\n * \\return  0 if OK; 1 on error\n *\n * <pre>\n * Notes:\n *      (1) If neither resolution field is set, this is not an error;\n *          the returned resolution values are 0 (designating 'unknown').\n * </pre>\n */\nl_ok\ngetTiffResolution(FILE     *fp,\n                  l_int32  *pxres,\n                  l_int32  *pyres)\n{\nTIFF  *tif;\n\n    PROCNAME(\"getTiffResolution\");\n\n    if (!pxres || !pyres)\n        return ERROR_INT(\"&xres and &yres not both defined\", procName, 1);\n    *pxres = *pyres = 0;\n    if (!fp)\n        return ERROR_INT(\"stream not opened\", procName, 1);\n\n    if ((tif = fopenTiff(fp, \"r\")) == NULL)\n        return ERROR_INT(\"tif not open for read\", procName, 1);\n    getTiffStreamResolution(tif, pxres, pyres);\n    TIFFCleanup(tif);\n    return 0;\n}\n\n\n/*!\n * \\brief   getTiffStreamResolution()\n *\n * \\param[in]    tif            TIFF handle opened for read\n * \\param[out]   pxres, pyres   resolution in ppi\n * \\return  0 if OK; 1 on error\n *\n * <pre>\n * Notes:\n *      (1) If neither resolution field is set, this is not an error;\n *          the returned resolution values are 0 (designating 'unknown').\n * </pre>\n */\nstatic l_int32\ngetTiffStreamResolution(TIFF     *tif,\n                        l_int32  *pxres,\n                        l_int32  *pyres)\n{\nl_uint16   resunit;\nl_int32    foundxres, foundyres;\nl_float32  fxres, fyres;\n\n    PROCNAME(\"getTiffStreamResolution\");\n\n    if (!tif)\n        return ERROR_INT(\"tif not opened\", procName, 1);\n    if (!pxres || !pyres)\n        return ERROR_INT(\"&xres and &yres not both defined\", procName, 1);\n    *pxres = *pyres = 0;\n\n    TIFFGetFieldDefaulted(tif, TIFFTAG_RESOLUTIONUNIT, &resunit);\n    foundxres = TIFFGetField(tif, TIFFTAG_XRESOLUTION, &fxres);\n    foundyres = TIFFGetField(tif, TIFFTAG_YRESOLUTION, &fyres);\n    if (!foundxres && !foundyres) return 1;\n    if (isnan(fxres) || isnan(fyres)) return 1;\n    if (!foundxres && foundyres)\n        fxres = fyres;\n    else if (foundxres && !foundyres)\n        fyres = fxres;\n\n        /* Avoid overflow into int32; set max fxres and fyres to 5 x 10^8 */\n    if (fxres < 0 || fxres > (1L << 29) || fyres < 0 || fyres > (1L << 29))\n        return ERROR_INT(\"fxres and/or fyres values are invalid\", procName, 1);\n\n    if (resunit == RESUNIT_CENTIMETER) {  /* convert to ppi */\n        *pxres = (l_int32)(2.54 * fxres + 0.5);\n        *pyres = (l_int32)(2.54 * fyres + 0.5);\n    } else {\n        *pxres = (l_int32)fxres;\n        *pyres = (l_int32)fyres;\n    }\n\n    return 0;\n}\n\n\n/*--------------------------------------------------------------*\n *              Get some tiff header information                *\n *--------------------------------------------------------------*/\n/*!\n * \\brief   readHeaderTiff()\n *\n * \\param[in]    filename\n * \\param[in]    n          page image number: 0-based\n * \\param[out]   pw         [optional] width\n * \\param[out]   ph         [optional] height\n * \\param[out]   pbps       [optional] bits per sample -- 1, 2, 4 or 8\n * \\param[out]   pspp       [optional] samples per pixel -- 1 or 3\n * \\param[out]   pres       [optional] resolution in x dir; NULL to ignore\n * \\param[out]   pcmap      [optional] colormap exists; input NULL to ignore\n * \\param[out]   pformat    [optional] tiff format; input NULL to ignore\n * \\return  0 if OK, 1 on error\n *\n * <pre>\n * Notes:\n *      (1) If there is a colormap, cmap is returned as 1; else 0.\n *      (2) If %n is equal to or greater than the number of images, returns 1.\n * </pre>\n */\nl_ok\nreadHeaderTiff(const char *filename,\n               l_int32     n,\n               l_int32    *pw,\n               l_int32    *ph,\n               l_int32    *pbps,\n               l_int32    *pspp,\n               l_int32    *pres,\n               l_int32    *pcmap,\n               l_int32    *pformat)\n{\nl_int32  ret;\nFILE    *fp;\n\n    PROCNAME(\"readHeaderTiff\");\n\n    if (pw) *pw = 0;\n    if (ph) *ph = 0;\n    if (pbps) *pbps = 0;\n    if (pspp) *pspp = 0;\n    if (pres) *pres = 0;\n    if (pcmap) *pcmap = 0;\n    if (pformat) *pformat = 0;\n    if (!filename)\n        return ERROR_INT(\"filename not defined\", procName, 1);\n    if (!pw && !ph && !pbps && !pspp && !pres && !pcmap && !pformat)\n        return ERROR_INT(\"no results requested\", procName, 1);\n\n    if ((fp = fopenReadStream(filename)) == NULL)\n        return ERROR_INT(\"image file not found\", procName, 1);\n    ret = freadHeaderTiff(fp, n, pw, ph, pbps, pspp, pres, pcmap, pformat);\n    fclose(fp);\n    return ret;\n}\n\n\n/*!\n * \\brief   freadHeaderTiff()\n *\n * \\param[in]    fp       file stream\n * \\param[in]    n        page image number: 0-based\n * \\param[out]   pw       [optional] width\n * \\param[out]   ph       [optional] height\n * \\param[out]   pbps     [optional] bits per sample -- 1, 2, 4 or 8\n * \\param[out]   pspp     [optional] samples per pixel -- 1 or 3\n * \\param[out]   pres     [optional] resolution in x dir; NULL to ignore\n * \\param[out]   pcmap    [optional] colormap exists; input NULL to ignore\n * \\param[out]   pformat  [optional] tiff format; input NULL to ignore\n * \\return  0 if OK, 1 on error\n *\n * <pre>\n * Notes:\n *      (1) If there is a colormap, cmap is returned as 1; else 0.\n *      (2) If %n is equal to or greater than the number of images, returns 1.\n * </pre>\n */\nl_ok\nfreadHeaderTiff(FILE     *fp,\n                l_int32   n,\n                l_int32  *pw,\n                l_int32  *ph,\n                l_int32  *pbps,\n                l_int32  *pspp,\n                l_int32  *pres,\n                l_int32  *pcmap,\n                l_int32  *pformat)\n{\nl_int32  i, ret, format;\nTIFF    *tif;\n\n    PROCNAME(\"freadHeaderTiff\");\n\n    if (pw) *pw = 0;\n    if (ph) *ph = 0;\n    if (pbps) *pbps = 0;\n    if (pspp) *pspp = 0;\n    if (pres) *pres = 0;\n    if (pcmap) *pcmap = 0;\n    if (pformat) *pformat = 0;\n    if (!fp)\n        return ERROR_INT(\"stream not defined\", procName, 1);\n    if (n < 0)\n        return ERROR_INT(\"image index must be >= 0\", procName, 1);\n    if (!pw && !ph && !pbps && !pspp && !pres && !pcmap && !pformat)\n        return ERROR_INT(\"no results requested\", procName, 1);\n\n    findFileFormatStream(fp, &format);\n    if (!L_FORMAT_IS_TIFF(format))\n        return ERROR_INT(\"file not tiff format\", procName, 1);\n\n    if ((tif = fopenTiff(fp, \"r\")) == NULL)\n        return ERROR_INT(\"tif not open for read\", procName, 1);\n\n    for (i = 0; i < n; i++) {\n        if (TIFFReadDirectory(tif) == 0)\n            return ERROR_INT(\"image n not found in file\", procName, 1);\n    }\n\n    ret = tiffReadHeaderTiff(tif, pw, ph, pbps, pspp, pres, pcmap, pformat);\n    TIFFCleanup(tif);\n    return ret;\n}\n\n\n/*!\n * \\brief   readHeaderMemTiff()\n *\n * \\param[in]    cdata     const; tiff-encoded\n * \\param[in]    size      size of data\n * \\param[in]    n         page image number: 0-based\n * \\param[out]   pw        [optional] width\n * \\param[out]   ph        [optional] height\n * \\param[out]   pbps      [optional] bits per sample -- 1, 2, 4 or 8\n * \\param[out]   pspp      [optional] samples per pixel -- 1 or 3\n * \\param[out]   pres      [optional] resolution in x dir; NULL to ignore\n * \\param[out]   pcmap     [optional] colormap exists; input NULL to ignore\n * \\param[out]   pformat   [optional] tiff format; input NULL to ignore\n * \\return  0 if OK, 1 on error\n *\n * <pre>\n * Notes:\n *      (1) Use TIFFClose(); TIFFCleanup() doesn't free internal memstream.\n * </pre>\n */\nl_ok\nreadHeaderMemTiff(const l_uint8  *cdata,\n                  size_t          size,\n                  l_int32         n,\n                  l_int32        *pw,\n                  l_int32        *ph,\n                  l_int32        *pbps,\n                  l_int32        *pspp,\n                  l_int32        *pres,\n                  l_int32        *pcmap,\n                  l_int32        *pformat)\n{\nl_uint8  *data;\nl_int32   i, ret;\nTIFF     *tif;\n\n    PROCNAME(\"readHeaderMemTiff\");\n\n    if (pw) *pw = 0;\n    if (ph) *ph = 0;\n    if (pbps) *pbps = 0;\n    if (pspp) *pspp = 0;\n    if (pres) *pres = 0;\n    if (pcmap) *pcmap = 0;\n    if (pformat) *pformat = 0;\n    if (!pw && !ph && !pbps && !pspp && !pres && !pcmap && !pformat)\n        return ERROR_INT(\"no results requested\", procName, 1);\n    if (!cdata)\n        return ERROR_INT(\"cdata not defined\", procName, 1);\n\n        /* Open a tiff stream to memory */\n    data = (l_uint8 *)cdata;  /* we're really not going to change this */\n    if ((tif = fopenTiffMemstream(\"tifferror\", \"r\", &data, &size)) == NULL)\n        return ERROR_INT(\"tiff stream not opened\", procName, 1);\n\n    for (i = 0; i < n; i++) {\n        if (TIFFReadDirectory(tif) == 0) {\n            TIFFClose(tif);\n            return ERROR_INT(\"image n not found in file\", procName, 1);\n        }\n    }\n\n    ret = tiffReadHeaderTiff(tif, pw, ph, pbps, pspp, pres, pcmap, pformat);\n    TIFFClose(tif);\n    return ret;\n}\n\n\n/*!\n * \\brief   tiffReadHeaderTiff()\n *\n * \\param[in]    tif\n * \\param[out]   pw        [optional] width\n * \\param[out]   ph        [optional] height\n * \\param[out]   pbps      [optional] bits per sample -- 1, 2, 4 or 8\n * \\param[out]   pspp      [optional] samples per pixel -- 1 or 3\n * \\param[out]   pres      [optional] resolution in x dir; NULL to ignore\n * \\param[out]   pcmap     [optional] cmap exists; input NULL to ignore\n * \\param[out]   pformat   [optional] tiff format; input NULL to ignore\n * \\return  0 if OK, 1 on error\n */\nstatic l_int32\ntiffReadHeaderTiff(TIFF     *tif,\n                   l_int32  *pw,\n                   l_int32  *ph,\n                   l_int32  *pbps,\n                   l_int32  *pspp,\n                   l_int32  *pres,\n                   l_int32  *pcmap,\n                   l_int32  *pformat)\n{\nl_uint16   tiffcomp;\nl_uint16   bps, spp;\nl_uint16  *rmap, *gmap, *bmap;\nl_int32    xres, yres;\nl_uint32   w, h;\n\n    PROCNAME(\"tiffReadHeaderTiff\");\n\n    if (!tif)\n        return ERROR_INT(\"tif not opened\", procName, 1);\n\n    TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &w);\n    TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &h);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_BITSPERSAMPLE, &bps);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_SAMPLESPERPIXEL, &spp);\n    if (w < 1 || h < 1)\n        return ERROR_INT(\"tif w and h not both > 0\", procName, 1);\n    if (bps != 1 && bps != 2 && bps != 4 && bps != 8 && bps != 16)\n        return ERROR_INT(\"bps not in set {1,2,4,8,16}\", procName, 1);\n    if (spp != 1 && spp != 2 && spp != 3 && spp != 4)\n        return ERROR_INT(\"spp not in set {1,2,3,4}\", procName, 1);\n    if (pw) *pw = w;\n    if (ph) *ph = h;\n    if (pbps) *pbps = bps;\n    if (pspp) *pspp = spp;\n    if (pres) {\n        *pres = 300;  /* default ppi */\n        if (getTiffStreamResolution(tif, &xres, &yres) == 0)\n            *pres = (l_int32)xres;\n    }\n    if (pcmap) {\n        *pcmap = 0;\n        if (TIFFGetField(tif, TIFFTAG_COLORMAP, &rmap, &gmap, &bmap))\n            *pcmap = 1;\n    }\n    if (pformat) {\n        TIFFGetFieldDefaulted(tif, TIFFTAG_COMPRESSION, &tiffcomp);\n        *pformat = getTiffCompressedFormat(tiffcomp);\n    }\n    return 0;\n}\n\n\n/*!\n * \\brief   findTiffCompression()\n *\n * \\param[in]    fp         file stream; must be rewound to BOF\n * \\param[out]   pcomptype  compression type\n * \\return  0 if OK, 1 on error\n *\n * <pre>\n * Notes:\n *      (1) The returned compression type is that defined in\n *          the enum in imageio.h.  It is not the tiff flag value.\n *      (2) The compression type is initialized to IFF_UNKNOWN.\n *          If it is not one of the specified types, the returned\n *          type is IFF_TIFF, which indicates no compression.\n *      (3) When this function is called, the stream must be at BOF.\n *          If the opened stream is to be used again to read the\n *          file, it must be rewound to BOF after calling this function.\n * </pre>\n */\nl_ok\nfindTiffCompression(FILE     *fp,\n                    l_int32  *pcomptype)\n{\nl_uint16  tiffcomp;\nTIFF     *tif;\n\n    PROCNAME(\"findTiffCompression\");\n\n    if (!pcomptype)\n        return ERROR_INT(\"&comptype not defined\", procName, 1);\n    *pcomptype = IFF_UNKNOWN;  /* init */\n    if (!fp)\n        return ERROR_INT(\"stream not defined\", procName, 1);\n\n    if ((tif = fopenTiff(fp, \"r\")) == NULL)\n        return ERROR_INT(\"tif not opened\", procName, 1);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_COMPRESSION, &tiffcomp);\n    *pcomptype = getTiffCompressedFormat(tiffcomp);\n    TIFFCleanup(tif);\n    return 0;\n}\n\n\n/*!\n * \\brief   getTiffCompressedFormat()\n *\n * \\param[in]    tiffcomp    defined in tiff.h\n * \\return  compression format defined in imageio.h\n *\n * <pre>\n * Notes:\n *      (1) The input must be the actual tiff compression type\n *          returned by a tiff library call.  It should always be\n *          a valid tiff type.\n *      (2) The return type is defined in the enum in imageio.h.\n * </pre>\n */\nstatic l_int32\ngetTiffCompressedFormat(l_uint16  tiffcomp)\n{\nl_int32  comptype;\n\n    switch (tiffcomp)\n    {\n    case COMPRESSION_CCITTFAX4:\n        comptype = IFF_TIFF_G4;\n        break;\n    case COMPRESSION_CCITTFAX3:\n        comptype = IFF_TIFF_G3;\n        break;\n    case COMPRESSION_CCITTRLE:\n        comptype = IFF_TIFF_RLE;\n        break;\n    case COMPRESSION_PACKBITS:\n        comptype = IFF_TIFF_PACKBITS;\n        break;\n    case COMPRESSION_LZW:\n        comptype = IFF_TIFF_LZW;\n        break;\n    case COMPRESSION_ADOBE_DEFLATE:\n        comptype = IFF_TIFF_ZIP;\n        break;\n    case COMPRESSION_JPEG:\n        comptype = IFF_TIFF_JPEG;\n        break;\n    default:\n        comptype = IFF_TIFF;\n        break;\n    }\n    return comptype;\n}\n\n\n/*--------------------------------------------------------------*\n *                   Extraction of tiff g4 data                 *\n *--------------------------------------------------------------*/\n/*!\n * \\brief   extractG4DataFromFile()\n *\n * \\param[in]    filein\n * \\param[out]   pdata         binary data of ccitt g4 encoded stream\n * \\param[out]   pnbytes       size of binary data\n * \\param[out]   pw            [optional] image width\n * \\param[out]   ph            [optional] image height\n * \\param[out]   pminisblack   [optional] boolean\n * \\return  0 if OK, 1 on error\n */\nl_ok\nextractG4DataFromFile(const char  *filein,\n                      l_uint8    **pdata,\n                      size_t      *pnbytes,\n                      l_int32     *pw,\n                      l_int32     *ph,\n                      l_int32     *pminisblack)\n{\nl_uint8  *inarray, *data;\nl_uint16  minisblack, comptype;  /* accessors require l_uint16 */\nl_int32   istiff;\nl_uint32  w, h, rowsperstrip;  /* accessors require l_uint32 */\nl_uint32  diroff;\nsize_t    fbytes, nbytes;\nFILE     *fpin;\nTIFF     *tif;\n\n    PROCNAME(\"extractG4DataFromFile\");\n\n    if (!pdata)\n        return ERROR_INT(\"&data not defined\", procName, 1);\n    if (!pnbytes)\n        return ERROR_INT(\"&nbytes not defined\", procName, 1);\n    if (!pw && !ph && !pminisblack)\n        return ERROR_INT(\"no output data requested\", procName, 1);\n    *pdata = NULL;\n    *pnbytes = 0;\n\n    if ((fpin = fopenReadStream(filein)) == NULL)\n        return ERROR_INT(\"stream not opened to file\", procName, 1);\n    istiff = fileFormatIsTiff(fpin);\n    fclose(fpin);\n    if (!istiff)\n        return ERROR_INT(\"filein not tiff\", procName, 1);\n\n    if ((inarray = l_binaryRead(filein, &fbytes)) == NULL)\n        return ERROR_INT(\"inarray not made\", procName, 1);\n\n        /* Get metadata about the image */\n    if ((tif = openTiff(filein, \"rb\")) == NULL) {\n        LEPT_FREE(inarray);\n        return ERROR_INT(\"tif not open for read\", procName, 1);\n    }\n    TIFFGetField(tif, TIFFTAG_COMPRESSION, &comptype);\n    if (comptype != COMPRESSION_CCITTFAX4) {\n        LEPT_FREE(inarray);\n        TIFFClose(tif);\n        return ERROR_INT(\"filein is not g4 compressed\", procName, 1);\n    }\n\n    TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &w);\n    TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &h);\n    TIFFGetField(tif, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);\n    if (h != rowsperstrip)\n        L_WARNING(\"more than 1 strip\\n\", procName);\n    TIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &minisblack);  /* for 1 bpp */\n/*    TIFFPrintDirectory(tif, stderr, 0); */\n    TIFFClose(tif);\n    if (pw) *pw = (l_int32)w;\n    if (ph) *ph = (l_int32)h;\n    if (pminisblack) *pminisblack = (l_int32)minisblack;\n\n        /* The header has 8 bytes: the first 2 are the magic number,\n         * the next 2 are the version, and the last 4 are the\n         * offset to the first directory.  That's what we want here.\n         * We have to test the byte order before decoding 4 bytes! */\n    if (inarray[0] == 0x4d) {  /* big-endian */\n        diroff = (inarray[4] << 24) | (inarray[5] << 16) |\n                 (inarray[6] << 8) | inarray[7];\n    } else  {   /* inarray[0] == 0x49 :  little-endian */\n        diroff = (inarray[7] << 24) | (inarray[6] << 16) |\n                 (inarray[5] << 8) | inarray[4];\n    }\n/*    lept_stderr(\" diroff = %d, %x\\n\", diroff, diroff); */\n\n        /* Extract the ccittg4 encoded data from the tiff file.\n         * We skip the 8 byte header and take nbytes of data,\n         * up to the beginning of the directory (at diroff)  */\n    nbytes = diroff - 8;\n    *pnbytes = nbytes;\n    if ((data = (l_uint8 *)LEPT_CALLOC(nbytes, sizeof(l_uint8))) == NULL) {\n        LEPT_FREE(inarray);\n        return ERROR_INT(\"data not allocated\", procName, 1);\n    }\n    *pdata = data;\n    memcpy(data, inarray + 8, nbytes);\n    LEPT_FREE(inarray);\n\n    return 0;\n}\n\n\n/*--------------------------------------------------------------*\n *               Open tiff stream from file stream              *\n *--------------------------------------------------------------*/\n/*!\n * \\brief   fopenTiff()\n *\n * \\param[in]    fp           file stream\n * \\param[in]    modestring   \"r\", \"w\", ...\n * \\return  tiff data structure, opened for a file descriptor\n *\n * <pre>\n * Notes:\n *      (1) Why is this here?  Leffler did not provide a function that\n *          takes a stream and gives a TIFF.  He only gave one that\n *          generates a TIFF starting with a file descriptor.  So we\n *          need to make it here, because it is useful to have functions\n *          that take a stream as input.\n *      (2) We use TIFFClientOpen() together with a set of static wrapper\n *          functions which map TIFF read, write, seek, close and size.\n *          to functions expecting a cookie of type stream (i.e. FILE *).\n *          This implementation was contributed by J\u00fcrgen Buchm\u00fcller.\n * </pre>\n */\nstatic TIFF *\nfopenTiff(FILE        *fp,\n          const char  *modestring)\n{\n    PROCNAME(\"fopenTiff\");\n\n    if (!fp)\n        return (TIFF *)ERROR_PTR(\"stream not opened\", procName, NULL);\n    if (!modestring)\n        return (TIFF *)ERROR_PTR(\"modestring not defined\", procName, NULL);\n\n    TIFFSetWarningHandler(NULL);  /* disable warnings */\n    TIFFSetErrorHandler(NULL);  /* disable error messages */\n\n    fseek(fp, 0, SEEK_SET);\n    return TIFFClientOpen(\"TIFFstream\", modestring, (thandle_t)fp,\n                          lept_read_proc, lept_write_proc, lept_seek_proc,\n                          lept_close_proc, lept_size_proc, NULL, NULL);\n}\n\n\n/*--------------------------------------------------------------*\n *                      Wrapper for TIFFOpen                    *\n *--------------------------------------------------------------*/\n/*!\n * \\brief   openTiff()\n *\n * \\param[in]    filename\n * \\param[in]    modestring   \"r\", \"w\", ...\n * \\return  tiff data structure\n *\n * <pre>\n * Notes:\n *      (1) This handles multi-platform file naming.\n * </pre>\n */\nstatic TIFF *\nopenTiff(const char  *filename,\n         const char  *modestring)\n{\nchar  *fname;\nTIFF  *tif;\n\n    PROCNAME(\"openTiff\");\n\n    if (!filename)\n        return (TIFF *)ERROR_PTR(\"filename not defined\", procName, NULL);\n    if (!modestring)\n        return (TIFF *)ERROR_PTR(\"modestring not defined\", procName, NULL);\n\n    TIFFSetWarningHandler(NULL);  /* disable warnings */\n    TIFFSetErrorHandler(NULL);  /* disable error messages */\n\n    fname = genPathname(filename, NULL);\n    tif = TIFFOpen(fname, modestring);\n    LEPT_FREE(fname);\n    return tif;\n}\n\n\n/*----------------------------------------------------------------------*\n *     Memory I/O: reading memory --> pix and writing pix --> memory    *\n *----------------------------------------------------------------------*/\n/*  It would be nice to use open_memstream() and fmemopen()\n *  for writing and reading to memory, rsp.  These functions manage\n *  memory for writes and reads that use a file streams interface.\n *  Unfortunately, the tiff library only has an interface for reading\n *  and writing to file descriptors, not to file streams.  The tiff\n *  library procedure is to open a \"tiff stream\" and read/write to it.\n *  The library provides a client interface for managing the I/O\n *  from memory, which requires seven callbacks.  See the TIFFClientOpen\n *  man page for callback signatures.  Adam Langley provided the code\n *  to do this.  */\n\n/*!\n * \\brief   Memory stream buffer used with TIFFClientOpen()\n *\n *  The L_Memstram %buffer has different functions in writing and reading.\n *\n *     * In reading, it is assigned to the data and read from as\n *       the tiff library uncompresses the data and generates the pix.\n *       The %offset points to the current read position in the data,\n *       and the %hw always gives the number of bytes of data.\n *       The %outdata and %outsize ptrs are not used.\n *       When finished, tiffCloseCallback() simply frees the L_Memstream.\n *\n *     * In writing, it accepts the data that the tiff library\n *       produces when a pix is compressed.  the buffer points to a\n *       malloced area of %bufsize bytes.  The current writing position\n *       in the buffer is %offset and the most ever written is %hw.\n *       The buffer is expanded as necessary.  When finished,\n *       tiffCloseCallback() assigns the %outdata and %outsize ptrs\n *       to the %buffer and %bufsize results, and frees the L_Memstream.\n */\nstruct L_Memstream\n{\n    l_uint8   *buffer;    /* expands to hold data when written to;         */\n                          /* fixed size when read from.                    */\n    size_t     bufsize;   /* current size allocated when written to;       */\n                          /* fixed size of input data when read from.      */\n    size_t     offset;    /* byte offset from beginning of buffer.         */\n    size_t     hw;        /* high-water mark; max bytes in buffer.         */\n    l_uint8  **poutdata;  /* input param for writing; data goes here.      */\n    size_t    *poutsize;  /* input param for writing; data size goes here. */\n};\ntypedef struct L_Memstream  L_MEMSTREAM;\n\n\n    /* These are static functions for memory I/O */\nstatic L_MEMSTREAM *memstreamCreateForRead(l_uint8 *indata, size_t pinsize);\nstatic L_MEMSTREAM *memstreamCreateForWrite(l_uint8 **poutdata,\n                                            size_t *poutsize);\nstatic tsize_t tiffReadCallback(thandle_t handle, tdata_t data, tsize_t length);\nstatic tsize_t tiffWriteCallback(thandle_t handle, tdata_t data,\n                                 tsize_t length);\nstatic toff_t tiffSeekCallback(thandle_t handle, toff_t offset, l_int32 whence);\nstatic l_int32 tiffCloseCallback(thandle_t handle);\nstatic toff_t tiffSizeCallback(thandle_t handle);\nstatic l_int32 tiffMapCallback(thandle_t handle, tdata_t *data, toff_t *length);\nstatic void tiffUnmapCallback(thandle_t handle, tdata_t data, toff_t length);\n\n\nstatic L_MEMSTREAM *\nmemstreamCreateForRead(l_uint8  *indata,\n                       size_t    insize)\n{\nL_MEMSTREAM  *mstream;\n\n    mstream = (L_MEMSTREAM *)LEPT_CALLOC(1, sizeof(L_MEMSTREAM));\n    mstream->buffer = indata;   /* handle to input data array */\n    mstream->bufsize = insize;  /* amount of input data */\n    mstream->hw = insize;       /* high-water mark fixed at input data size */\n    mstream->offset = 0;        /* offset always starts at 0 */\n    return mstream;\n}\n\n\nstatic L_MEMSTREAM *\nmemstreamCreateForWrite(l_uint8  **poutdata,\n                        size_t    *poutsize)\n{\nL_MEMSTREAM  *mstream;\n\n    mstream = (L_MEMSTREAM *)LEPT_CALLOC(1, sizeof(L_MEMSTREAM));\n    mstream->buffer = (l_uint8 *)LEPT_CALLOC(8 * 1024, 1);\n    mstream->bufsize = 8 * 1024;\n    mstream->poutdata = poutdata;  /* used only at end of write */\n    mstream->poutsize = poutsize;  /* ditto  */\n    mstream->hw = mstream->offset = 0;\n    return mstream;\n}\n\n\nstatic tsize_t\ntiffReadCallback(thandle_t  handle,\n                 tdata_t    data,\n                 tsize_t    length)\n{\nL_MEMSTREAM  *mstream;\nsize_t        amount;\n\n    mstream = (L_MEMSTREAM *)handle;\n    amount = L_MIN((size_t)length, mstream->hw - mstream->offset);\n\n        /* Fuzzed files can create this condition! */\n    if (mstream->offset + amount < amount ||  /* overflow */\n        mstream->offset + amount > mstream->hw) {\n        lept_stderr(\"Bad file: amount too big: %zu\\n\", amount);\n        return 0;\n    }\n\n    memcpy(data, mstream->buffer + mstream->offset, amount);\n    mstream->offset += amount;\n    return amount;\n}\n\n\nstatic tsize_t\ntiffWriteCallback(thandle_t  handle,\n                  tdata_t    data,\n                  tsize_t    length)\n{\nL_MEMSTREAM  *mstream;\nsize_t        newsize;\n\n        /* reallocNew() uses calloc to initialize the array.\n         * If malloc is used instead, for some of the encoding methods,\n         * not all the data in 'bufsize' bytes in the buffer will\n         * have been initialized by the end of the compression. */\n    mstream = (L_MEMSTREAM *)handle;\n    if (mstream->offset + length > mstream->bufsize) {\n        newsize = 2 * (mstream->offset + length);\n        mstream->buffer = (l_uint8 *)reallocNew((void **)&mstream->buffer,\n                                                mstream->hw, newsize);\n        mstream->bufsize = newsize;\n    }\n\n    memcpy(mstream->buffer + mstream->offset, data, length);\n    mstream->offset += length;\n    mstream->hw = L_MAX(mstream->offset, mstream->hw);\n    return length;\n}\n\n\nstatic toff_t\ntiffSeekCallback(thandle_t  handle,\n                 toff_t     offset,\n                 l_int32    whence)\n{\nL_MEMSTREAM  *mstream;\n\n    PROCNAME(\"tiffSeekCallback\");\n    mstream = (L_MEMSTREAM *)handle;\n    switch (whence) {\n        case SEEK_SET:\n/*            lept_stderr(\"seek_set: offset = %d\\n\", offset); */\n            if((size_t)offset != offset) {  /* size_t overflow on uint32 */\n                return (toff_t)ERROR_INT(\"too large offset value\", procName, 1);\n            }\n            mstream->offset = offset;\n            break;\n        case SEEK_CUR:\n/*            lept_stderr(\"seek_cur: offset = %d\\n\", offset); */\n            mstream->offset += offset;\n            break;\n        case SEEK_END:\n/*            lept_stderr(\"seek end: hw = %d, offset = %d\\n\",\n                    mstream->hw, offset); */\n            mstream->offset = mstream->hw - offset;  /* offset >= 0 */\n            break;\n        default:\n            return (toff_t)ERROR_INT(\"bad whence value\", procName,\n                                     mstream->offset);\n    }\n\n    return mstream->offset;\n}\n\n\nstatic l_int32\ntiffCloseCallback(thandle_t  handle)\n{\nL_MEMSTREAM  *mstream;\n\n    mstream = (L_MEMSTREAM *)handle;\n    if (mstream->poutdata) {   /* writing: save the output data */\n        *mstream->poutdata = mstream->buffer;\n        *mstream->poutsize = mstream->hw;\n    }\n    LEPT_FREE(mstream);  /* never free the buffer! */\n    return 0;\n}\n\n\nstatic toff_t\ntiffSizeCallback(thandle_t  handle)\n{\nL_MEMSTREAM  *mstream;\n\n    mstream = (L_MEMSTREAM *)handle;\n    return mstream->hw;\n}\n\n\nstatic l_int32\ntiffMapCallback(thandle_t  handle,\n                tdata_t   *data,\n                toff_t    *length)\n{\nL_MEMSTREAM  *mstream;\n\n    mstream = (L_MEMSTREAM *)handle;\n    *data = mstream->buffer;\n    *length = mstream->hw;\n    return 0;\n}\n\n\nstatic void\ntiffUnmapCallback(thandle_t  handle,\n                  tdata_t    data,\n                  toff_t     length)\n{\n    return;\n}\n\n\n/*!\n * \\brief   fopenTiffMemstream()\n *\n * \\param[in]    filename    for error output; can be \"\"\n * \\param[in]    operation   \"w\" for write, \"r\" for read\n * \\param[out]   pdata       written data\n * \\param[out]   pdatasize   size of written data\n * \\return  tiff data structure, opened for write to memory\n *\n * <pre>\n * Notes:\n *      (1) This wraps up a number of callbacks for either:\n *            * reading from tiff in memory buffer --> pix\n *            * writing from pix --> tiff in memory buffer\n *      (2) After use, the memstream is automatically destroyed when\n *          TIFFClose() is called.  TIFFCleanup() doesn't free the memstream.\n *      (3) This does not work in append mode, and in write mode it\n *          does not append.\n * </pre>\n */\nstatic TIFF *\nfopenTiffMemstream(const char  *filename,\n                   const char  *operation,\n                   l_uint8    **pdata,\n                   size_t      *pdatasize)\n{\nL_MEMSTREAM  *mstream;\nTIFF         *tif;\n\n    PROCNAME(\"fopenTiffMemstream\");\n\n    if (!filename)\n        return (TIFF *)ERROR_PTR(\"filename not defined\", procName, NULL);\n    if (!operation)\n        return (TIFF *)ERROR_PTR(\"operation not defined\", procName, NULL);\n    if (!pdata)\n        return (TIFF *)ERROR_PTR(\"&data not defined\", procName, NULL);\n    if (!pdatasize)\n        return (TIFF *)ERROR_PTR(\"&datasize not defined\", procName, NULL);\n    if (strcmp(operation, \"r\") && strcmp(operation, \"w\"))\n        return (TIFF *)ERROR_PTR(\"op not 'r' or 'w'\", procName, NULL);\n\n    if (!strcmp(operation, \"r\"))\n        mstream = memstreamCreateForRead(*pdata, *pdatasize);\n    else\n        mstream = memstreamCreateForWrite(pdata, pdatasize);\n\n    TIFFSetWarningHandler(NULL);  /* disable warnings */\n    TIFFSetErrorHandler(NULL);  /* disable error messages */\n\n    tif = TIFFClientOpen(filename, operation, (thandle_t)mstream,\n                         tiffReadCallback, tiffWriteCallback,\n                         tiffSeekCallback, tiffCloseCallback,\n                         tiffSizeCallback, tiffMapCallback,\n                         tiffUnmapCallback);\n    if (!tif)\n        LEPT_FREE(mstream);\n    return tif;\n}\n\n\n/*!\n * \\brief   pixReadMemTiff()\n *\n * \\param[in]    cdata    const; tiff-encoded\n * \\param[in]    size     size of cdata\n * \\param[in]    n        page image number: 0-based\n * \\return  pix, or NULL on error\n *\n * <pre>\n * Notes:\n *      (1) This is a version of pixReadTiff(), where the data is read\n *          from a memory buffer and uncompressed.\n *      (2) Use TIFFClose(); TIFFCleanup() doesn't free internal memstream.\n *      (3) No warning messages on failure, because of how multi-page\n *          TIFF reading works. You are supposed to keep trying until\n *          it stops working.\n *      (4) Tiff directory overhead is linear in the input page number.\n *          If reading many images, use pixReadMemFromMultipageTiff().\n * </pre>\n */\nPIX *\npixReadMemTiff(const l_uint8  *cdata,\n               size_t          size,\n               l_int32         n)\n{\nl_uint8  *data;\nl_int32   i;\nPIX      *pix;\nTIFF     *tif;\n\n    PROCNAME(\"pixReadMemTiff\");\n\n    if (!cdata)\n        return (PIX *)ERROR_PTR(\"cdata not defined\", procName, NULL);\n\n    data = (l_uint8 *)cdata;  /* we're really not going to change this */\n    if ((tif = fopenTiffMemstream(\"tifferror\", \"r\", &data, &size)) == NULL)\n        return (PIX *)ERROR_PTR(\"tiff stream not opened\", procName, NULL);\n\n    pix = NULL;\n    for (i = 0; ; i++) {\n        if (i == n) {\n            if ((pix = pixReadFromTiffStream(tif)) == NULL) {\n                TIFFClose(tif);\n                return NULL;\n            }\n            pixSetInputFormat(pix, IFF_TIFF);\n            break;\n        }\n        if (TIFFReadDirectory(tif) == 0)\n            break;\n        if (i == ManyPagesInTiffFile + 1) {\n            L_WARNING(\"big file: more than %d pages\\n\", procName,\n                      ManyPagesInTiffFile);\n        }\n    }\n\n    TIFFClose(tif);\n    return pix;\n}\n\n\n/*!\n * \\brief   pixReadMemFromMultipageTiff()\n *\n * \\param[in]    cdata      const; tiff-encoded\n * \\param[in]    size       size of cdata\n * \\param[in,out]  poffset  set offset to 0 for first image\n * \\return  pix, or NULL on error or if previous call returned the last image\n *\n * <pre>\n * Notes:\n *      (1) This is a read-from-memory version of pixReadFromMultipageTiff().\n *          See that function for usage.\n *      (2) If reading sequentially from the tiff data, this is more\n *          efficient than pixReadMemTiff(), which has an overhead\n *          proportional to the image index n.\n *      (3) Example usage for reading all the images:\n *            size_t offset = 0;\n *            do {\n *                Pix *pix = pixReadMemFromMultipageTiff(data, size, &offset);\n *                // do something with pix\n *            } while (offset != 0);\n * </pre>\n */\nPIX *\npixReadMemFromMultipageTiff(const l_uint8  *cdata,\n                            size_t          size,\n                            size_t         *poffset)\n{\nl_uint8  *data;\nl_int32   retval;\nsize_t    offset;\nPIX      *pix;\nTIFF     *tif;\n\n    PROCNAME(\"pixReadMemFromMultipageTiff\");\n\n    if (!cdata)\n        return (PIX *)ERROR_PTR(\"cdata not defined\", procName, NULL);\n    if (!poffset)\n        return (PIX *)ERROR_PTR(\"&offset not defined\", procName, NULL);\n\n    data = (l_uint8 *)cdata;  /* we're really not going to change this */\n    if ((tif = fopenTiffMemstream(\"tifferror\", \"r\", &data, &size)) == NULL)\n        return (PIX *)ERROR_PTR(\"tiff stream not opened\", procName, NULL);\n\n        /* Set ptrs in the TIFF to the beginning of the image */\n    offset = *poffset;\n    retval = (offset == 0) ? TIFFSetDirectory(tif, 0)\n                           : TIFFSetSubDirectory(tif, offset);\n    if (retval == 0) {\n        TIFFClose(tif);\n        return NULL;\n    }\n\n    if ((pix = pixReadFromTiffStream(tif)) == NULL) {\n        TIFFClose(tif);\n        return NULL;\n    }\n\n        /* Advance to the next image and return the new offset */\n    TIFFReadDirectory(tif);\n    *poffset = TIFFCurrentDirOffset(tif);\n    TIFFClose(tif);\n    return pix;\n}\n\n\n/*!\n * \\brief   pixaReadMemMultipageTiff()\n *\n * \\param[in]    data    const; multiple pages; tiff-encoded\n * \\param[in]    size    size of cdata\n * \\return  pixa, or NULL on error\n *\n * <pre>\n * Notes:\n *      (1) This is an O(n) read-from-memory version of pixaReadMultipageTiff().\n * </pre>\n */\nPIXA *\npixaReadMemMultipageTiff(const l_uint8  *data,\n                         size_t          size)\n{\nsize_t  offset;\nPIX    *pix;\nPIXA   *pixa;\n\n    PROCNAME(\"pixaReadMemMultipageTiff\");\n\n    if (!data)\n        return (PIXA *)ERROR_PTR(\"data not defined\", procName, NULL);\n\n    offset = 0;\n    pixa = pixaCreate(0);\n    do {\n        pix = pixReadMemFromMultipageTiff(data, size, &offset);\n        pixaAddPix(pixa, pix, L_INSERT);\n    } while (offset != 0);\n    return pixa;\n}\n\n\n/*!\n * \\brief   pixaWriteMemMultipageTiff()\n *\n * \\param[out]    pdata   const; tiff-encoded\n * \\param[out]    psize   size of data\n * \\param[in]     pixa    any depth; colormap will be removed\n * \\return  0 if OK, 1 on error\n *\n * <pre>\n * Notes:\n *      (1) fopenTiffMemstream() does not work in append mode, so we\n *          must work-around with a temporary file.\n *      (2) Getting a file stream from\n *            open_memstream((char **)pdata, psize)\n *          does not work with the tiff directory.\n * </pre>\n */\nl_ok\npixaWriteMemMultipageTiff(l_uint8  **pdata,\n                          size_t    *psize,\n                          PIXA      *pixa)\n{\nconst char  *modestr;\nl_int32      i, n;\nFILE        *fp;\nPIX         *pix1;\n\n    PROCNAME(\"pixaWriteMemMultipageTiff\");\n\n    if (pdata) *pdata = NULL;\n    if (!pdata)\n        return ERROR_INT(\"pdata not defined\", procName, 1);\n    if (!pixa)\n        return ERROR_INT(\"pixa not defined\", procName, 1);\n\n#ifdef _WIN32\n    if ((fp = fopenWriteWinTempfile()) == NULL)\n        return ERROR_INT(\"tmpfile stream not opened\", procName, 1);\n#else\n    if ((fp = tmpfile()) == NULL)\n        return ERROR_INT(\"tmpfile stream not opened\", procName, 1);\n#endif  /* _WIN32 */\n\n    n = pixaGetCount(pixa);\n    for (i = 0; i < n; i++) {\n        modestr = (i == 0) ? \"w\" : \"a\";\n        pix1 = pixaGetPix(pixa, i, L_CLONE);\n        if (pixGetDepth(pix1) == 1)\n            pixWriteStreamTiffWA(fp, pix1, IFF_TIFF_G4, modestr);\n        else\n            pixWriteStreamTiffWA(fp, pix1, IFF_TIFF_ZIP, modestr);\n        pixDestroy(&pix1);\n    }\n\n    rewind(fp);\n    *pdata = l_binaryReadStream(fp, psize);\n    fclose(fp);\n    return 0;\n}\n\n\n/*!\n * \\brief   pixWriteMemTiff()\n *\n * \\param[out]   pdata     data of tiff compressed image\n * \\param[out]   psize     size of returned data\n * \\param[in]    pix\n * \\param[in]    comptype  IFF_TIFF, IFF_TIFF_RLE, IFF_TIFF_PACKBITS,\n *                         IFF_TIFF_G3, IFF_TIFF_G4,\n *                         IFF_TIFF_LZW, IFF_TIFF_ZIP, IFF_TIFF_JPEG\n * \\return  0 if OK, 1 on error\n *\n *  Usage:\n *      1) See pixWriteTiff(.  This version writes to\n *          memory instead of to a file.\n */\nl_ok\npixWriteMemTiff(l_uint8  **pdata,\n                size_t    *psize,\n                PIX       *pix,\n                l_int32    comptype)\n{\n    return pixWriteMemTiffCustom(pdata, psize, pix, comptype,\n                                 NULL, NULL, NULL, NULL);\n}\n\n\n/*!\n * \\brief   pixWriteMemTiffCustom()\n *\n * \\param[out]   pdata     data of tiff compressed image\n * \\param[out]   psize     size of returned data\n * \\param[in]    pix\n * \\param[in]    comptype  IFF_TIFF, IFF_TIFF_RLE, IFF_TIFF_PACKBITS,\n *                         IFF_TIFF_G3, IFF_TIFF_G4,\n *                         IFF_TIFF_LZW, IFF_TIFF_ZIP, IFF_TIFF_JPEG\n * \\param[in]    natags    [optional] NUMA of custom tiff tags\n * \\param[in]    savals    [optional] SARRAY of values\n * \\param[in]    satypes   [optional] SARRAY of types\n * \\param[in]    nasizes   [optional] NUMA of sizes\n * \\return  0 if OK, 1 on error\n *\n *  Usage:\n *      1) See pixWriteTiffCustom(.  This version writes to\n *          memory instead of to a file.\n *      2) Use TIFFClose(); TIFFCleanup( doesn't free internal memstream.\n */\nl_ok\npixWriteMemTiffCustom(l_uint8  **pdata,\n                      size_t    *psize,\n                      PIX       *pix,\n                      l_int32    comptype,\n                      NUMA      *natags,\n                      SARRAY    *savals,\n                      SARRAY    *satypes,\n                      NUMA      *nasizes)\n{\nl_int32  ret;\nTIFF    *tif;\n\n    PROCNAME(\"pixWriteMemTiffCustom\");\n\n    if (!pdata)\n        return ERROR_INT(\"&data not defined\", procName, 1);\n    if (!psize)\n        return ERROR_INT(\"&size not defined\", procName, 1);\n    if (!pix)\n        return ERROR_INT(\"&pix not defined\", procName, 1);\n    if (pixGetDepth(pix) != 1 && comptype != IFF_TIFF &&\n        comptype != IFF_TIFF_LZW && comptype != IFF_TIFF_ZIP &&\n        comptype != IFF_TIFF_JPEG) {\n        L_WARNING(\"invalid compression type for bpp > 1\\n\", procName);\n        comptype = IFF_TIFF_ZIP;\n    }\n\n    if ((tif = fopenTiffMemstream(\"tifferror\", \"w\", pdata, psize)) == NULL)\n        return ERROR_INT(\"tiff stream not opened\", procName, 1);\n    ret = pixWriteToTiffStream(tif, pix, comptype, natags, savals,\n                               satypes, nasizes);\n\n    TIFFClose(tif);\n    return ret;\n}\n\n/* --------------------------------------------*/\n#endif  /* HAVE_LIBTIFF */\n/* --------------------------------------------*/\n"], "fixing_code": ["/*====================================================================*\n -  Copyright (C) 2001 Leptonica.  All rights reserved.\n -\n -  Redistribution and use in source and binary forms, with or without\n -  modification, are permitted provided that the following conditions\n -  are met:\n -  1. Redistributions of source code must retain the above copyright\n -     notice, this list of conditions and the following disclaimer.\n -  2. Redistributions in binary form must reproduce the above\n -     copyright notice, this list of conditions and the following\n -     disclaimer in the documentation and/or other materials\n -     provided with the distribution.\n -\n -  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n -  ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n -  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n -  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL ANY\n -  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n -  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n -  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n -  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n -  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n -  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n -  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *====================================================================*/\n\n/*\n *   dewarptest1.c\n *\n *   This exercise functions in dewarp.c for dewarping based on lines\n *   of horizontal text.  It also creates a 24-image pdf of steps\n *   in the process.\n */\n\n#ifdef HAVE_CONFIG_H\n#include <config_auto.h>\n#endif  /* HAVE_CONFIG_H */\n\n#include \"allheaders.h\"\n\n#define   DO_QUAD     1\n#define   DO_CUBIC    0\n#define   DO_QUARTIC  0\n\nl_int32 main(int    argc,\n             char **argv)\n{\nL_DEWARP   *dew1, *dew2;\nL_DEWARPA  *dewa;\nPIX        *pixs, *pixn, *pixg, *pixb, *pixd, *pixt1, *pixt2;\nPIX        *pixs2, *pixn2, *pixg2, *pixb2, *pixd2;\n\n    setLeptDebugOK(1);\n    lept_mkdir(\"lept/model\");\n    lept_rmdir(\"lept/dewmod\");\n    lept_mkdir(\"lept/dewmod\");\n\n/*    pixs = pixRead(\"1555.007.jpg\"); */\n    pixs = pixRead(\"cat.035.jpg\");\n/*    pixs = pixRead(\"cat.010.jpg\"); */\n\n        /* Normalize for varying background and binarize */\n    pixn = pixBackgroundNormSimple(pixs, NULL, NULL);\n    pixg = pixConvertRGBToGray(pixn, 0.5, 0.3, 0.2);\n    pixb = pixThresholdToBinary(pixg, 130);\n\n        /* Run the basic functions */\n    dewa = dewarpaCreate(2, 30, 1, 10, 30);\n    dewarpaUseBothArrays(dewa, 1);\n    dew1 = dewarpCreate(pixb, 35);\n    dewarpaInsertDewarp(dewa, dew1);\n    dewarpBuildPageModel(dew1, \"/tmp/lept/model/dewarp_model1.pdf\");\n    dewarpaApplyDisparity(dewa, 35, pixg, 200, 0, 0, &pixd,\n                          \"/tmp/lept/model/dewarp_apply1.pdf\");\n\n         /* Write out some of the files to be imaged */\n    lept_rmdir(\"lept/dewtest\");\n    lept_mkdir(\"lept/dewtest\");\n    pixWrite(\"/tmp/lept/dewtest/001.jpg\", pixs, IFF_JFIF_JPEG);\n    pixWrite(\"/tmp/lept/dewtest/002.jpg\", pixn, IFF_JFIF_JPEG);\n    pixWrite(\"/tmp/lept/dewtest/003.jpg\", pixg, IFF_JFIF_JPEG);\n    pixWrite(\"/tmp/lept/dewtest/004.png\", pixb, IFF_TIFF_G4);\n    pixWrite(\"/tmp/lept/dewtest/005.jpg\", pixd, IFF_JFIF_JPEG);\n    pixt1 = pixRead(\"/tmp/lept/dewmod/0020.png\");\n    pixWrite(\"/tmp/lept/dewtest/006.png\", pixt1, IFF_PNG);\n    pixDestroy(&pixt1);\n    pixt1 = pixRead(\"/tmp/lept/dewmod/0030.png\");\n    pixWrite(\"/tmp/lept/dewtest/007.png\", pixt1, IFF_PNG);\n    pixDestroy(&pixt1);\n    pixt1 = pixRead(\"/tmp/lept/dewmod/0060.png\");\n    pixWrite(\"/tmp/lept/dewtest/008.png\", pixt1, IFF_PNG);\n    pixDestroy(&pixt1);\n    pixt1 = pixRead(\"/tmp/lept/dewmod/0070.png\");\n    pixWrite(\"/tmp/lept/dewtest/009.png\", pixt1, IFF_PNG);\n    pixDestroy(&pixt1);\n    pixt1 = pixRead(\"/tmp/lept/dewapply/002.png\");\n    pixWrite(\"/tmp/lept/dewtest/010.png\", pixt1, IFF_PNG);\n    pixDestroy(&pixt1);\n    pixt1 = pixRead(\"/tmp/lept/dewapply/003.png\");\n    pixWrite(\"/tmp/lept/dewtest/011.png\", pixt1, IFF_PNG);\n    pixt2 = pixThresholdToBinary(pixt1, 130);\n    pixWrite(\"/tmp/lept/dewtest/012.png\", pixt2, IFF_TIFF_G4);\n    pixDestroy(&pixt1);\n    pixDestroy(&pixt2);\n    pixt1 = pixRead(\"/tmp/lept/dewmod/0041.png\");\n    pixWrite(\"/tmp/lept/dewtest/013.png\", pixt1, IFF_PNG);\n    pixDestroy(&pixt1);\n    pixt1 = pixRead(\"/tmp/lept/dewmod/0042.png\");\n    pixWrite(\"/tmp/lept/dewtest/014.png\", pixt1, IFF_PNG);\n    pixDestroy(&pixt1);\n    pixt1 = pixRead(\"/tmp/lept/dewmod/0051.png\");\n    pixWrite(\"/tmp/lept/dewtest/015.png\", pixt1, IFF_PNG);\n    pixDestroy(&pixt1);\n    pixt1 = pixRead(\"/tmp/lept/dewmod/0052.png\");\n    pixWrite(\"/tmp/lept/dewtest/016.png\", pixt1, IFF_PNG);\n    pixDestroy(&pixt1);\n\n        /* Normalize another image, that may not have enough textlines\n         * to build an accurate model */\n/*    pixs2 = pixRead(\"1555.003.jpg\");  */\n    pixs2 = pixRead(\"cat.007.jpg\");\n/*    pixs2 = pixRead(\"cat.014.jpg\"); */\n    pixn2 = pixBackgroundNormSimple(pixs2, NULL, NULL);\n    pixg2 = pixConvertRGBToGray(pixn2, 0.5, 0.3, 0.2);\n    pixb2 = pixThresholdToBinary(pixg2, 130);\n\n        /* Apply the previous disparity model to this image */\n    dew2 = dewarpCreate(pixb2, 7);\n    dewarpaInsertDewarp(dewa, dew2);\n    dewarpaInsertRefModels(dewa, 0, 1);\n    dewarpaInfo(stderr, dewa);\n    dewarpaApplyDisparity(dewa, 7, pixg2, 200, 0, 0, &pixd2,\n                          \"/tmp/lept/model/dewarp_apply2.pdf\");\n    dewarpaDestroy(&dewa);\n\n        /* Write out files for the second image */\n    pixWrite(\"/tmp/lept/dewtest/017.jpg\", pixs2, IFF_JFIF_JPEG);\n    pixWrite(\"/tmp/lept/dewtest/018.jpg\", pixg2, IFF_JFIF_JPEG);\n    pixWrite(\"/tmp/lept/dewtest/019.png\", pixb2, IFF_TIFF_G4);\n    pixWrite(\"/tmp/lept/dewtest/020.jpg\", pixd2, IFF_JFIF_JPEG);\n    pixt1 = pixRead(\"/tmp/lept/dewmod/0060.png\");\n    pixWrite(\"/tmp/lept/dewtest/021.png\", pixt1, IFF_PNG);\n    pixDestroy(&pixt1);\n    pixt1 = pixRead(\"/tmp/lept/dewapply/002.png\");\n    pixWrite(\"/tmp/lept/dewtest/022.png\", pixt1, IFF_PNG);\n    pixt2 = pixThresholdToBinary(pixt1, 130);\n    pixWrite(\"/tmp/lept/dewtest/023.png\", pixt2, IFF_TIFF_G4);\n    pixDestroy(&pixt1);\n    pixDestroy(&pixt2);\n    pixt1 = pixRead(\"/tmp/lept/dewmod/0070.png\");\n    pixWrite(\"/tmp/lept/dewtest/024.png\", pixt1, IFF_PNG);\n    pixDestroy(&pixt1);\n    pixt1 = pixRead(\"/tmp/lept/dewapply/003.png\");\n    pixWrite(\"/tmp/lept/dewtest/025.png\", pixt1, IFF_PNG);\n    pixt2 = pixThresholdToBinary(pixt1, 130);\n    pixWrite(\"/tmp/lept/dewtest/026.png\", pixt2, IFF_TIFF_G4);\n    pixDestroy(&pixt1);\n    pixDestroy(&pixt2);\n\n        /* Generate the big pdf file */\n    convertFilesToPdf(\"/tmp/lept/dewtest\", NULL, 135, 1.0, 0, 0, \"Dewarp Test\",\n                      \"/tmp/lept/dewarptest1.pdf\");\n    lept_stderr(\"pdf file made: /tmp/lept/model/dewarptest1.pdf\\n\");\n\n    pixDestroy(&pixs);\n    pixDestroy(&pixn);\n    pixDestroy(&pixg);\n    pixDestroy(&pixb);\n    pixDestroy(&pixd);\n    pixDestroy(&pixs2);\n    pixDestroy(&pixn2);\n    pixDestroy(&pixg2);\n    pixDestroy(&pixb2);\n    pixDestroy(&pixd2);\n    return 0;\n}\n", "/*====================================================================*\n -  Copyright (C) 2001 Leptonica.  All rights reserved.\n -\n -  Redistribution and use in source and binary forms, with or without\n -  modification, are permitted provided that the following conditions\n -  are met:\n -  1. Redistributions of source code must retain the above copyright\n -     notice, this list of conditions and the following disclaimer.\n -  2. Redistributions in binary form must reproduce the above\n -     copyright notice, this list of conditions and the following\n -     disclaimer in the documentation and/or other materials\n -     provided with the distribution.\n -\n -  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n -  ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n -  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n -  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL ANY\n -  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n -  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n -  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n -  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n -  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n -  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n -  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *====================================================================*/\n\n/*!\n * \\file tiffio.c\n * <pre>\n *\n *     TIFFClientOpen() wrappers for FILE*:\n *      static tsize_t    lept_read_proc()\n *      static tsize_t    lept_write_proc()\n *      static toff_t     lept_seek_proc()\n *      static int        lept_close_proc()\n *      static toff_t     lept_size_proc()\n *\n *     Reading tiff:\n *             PIX       *pixReadTiff()             [ special top level ]\n *             PIX       *pixReadStreamTiff()\n *      static PIX       *pixReadFromTiffStream()\n *\n *     Writing tiff:\n *             l_int32    pixWriteTiff()            [ special top level ]\n *             l_int32    pixWriteTiffCustom()      [ special top level ]\n *             l_int32    pixWriteStreamTiff()\n *             l_int32    pixWriteStreamTiffWA()\n *      static l_int32    pixWriteToTiffStream()\n *      static l_int32    writeCustomTiffTags()\n *\n *     Reading and writing multipage tiff\n *             PIX       *pixReadFromMultipageTiff()\n *             PIXA      *pixaReadMultipageTiff()   [ special top level ]\n *             l_int32    pixaWriteMultipageTiff()  [ special top level ]\n *             l_int32    writeMultipageTiff()      [ special top level ]\n *             l_int32    writeMultipageTiffSA()\n *\n *     Information about tiff file\n *             l_int32    fprintTiffInfo()\n *             l_int32    tiffGetCount()\n *             l_int32    getTiffResolution()\n *      static l_int32    getTiffStreamResolution()\n *             l_int32    readHeaderTiff()\n *             l_int32    freadHeaderTiff()\n *             l_int32    readHeaderMemTiff()\n *      static l_int32    tiffReadHeaderTiff()\n *             l_int32    findTiffCompression()\n *      static l_int32    getTiffCompressedFormat()\n *\n *     Extraction of tiff g4 data:\n *             l_int32    extractG4DataFromFile()\n *\n *     Open tiff stream from file stream\n *      static TIFF      *fopenTiff()\n *\n *     Wrapper for TIFFOpen:\n *      static TIFF      *openTiff()\n *\n *     Memory I/O: reading memory --> pix and writing pix --> memory\n *             [10 static helper functions]\n *             PIX       *pixReadMemTiff();\n *             PIX       *pixReadMemFromMultipageTiff();\n *             PIXA      *pixaReadMemMultipageTiff()    [ special top level ]\n *             l_int32    pixaWriteMemMultipageTiff()   [ special top level ]\n *             l_int32    pixWriteMemTiff();\n *             l_int32    pixWriteMemTiffCustom();\n *\n *  Note:  To include all necessary functions, use libtiff version 3.7.4\n *         (or later)\n *  Note:  On Windows with 2 bpp or 4 bpp images, the bytes in the\n *         tiff-compressed file depend on the pad bits (but not the\n *         decoded raster image when read).  Because it is sometimes\n *         convenient to use a golden file with a byte-by-byte check\n *         to verify invariance, we set the pad bits to 0 before writing,\n *         in pixWriteToTiffStream().\n * </pre>\n */\n\n#ifdef HAVE_CONFIG_H\n#include <config_auto.h>\n#endif  /* HAVE_CONFIG_H */\n\n#include <string.h>\n#include <math.h>   /* for isnan */\n#include <sys/types.h>\n#ifndef _MSC_VER\n#include <unistd.h>\n#else  /* _MSC_VER */\n#include <io.h>\n#endif  /* _MSC_VER */\n#include <fcntl.h>\n#include \"allheaders.h\"\n\n/* --------------------------------------------*/\n#if  HAVE_LIBTIFF   /* defined in environ.h */\n/* --------------------------------------------*/\n\n#include \"tiff.h\"\n#include \"tiffio.h\"\n\nstatic const l_int32  DefaultResolution = 300;   /* ppi */\nstatic const l_int32  ManyPagesInTiffFile = 3000;  /* warn if big */\n\n    /* Verified that tiflib makes valid g4 files of this size */\nstatic const l_int32  MaxTiffWidth = 1 << 20;  /* 1M pixels */\nstatic const l_int32  MaxTiffHeight = 1 << 20;  /* 1M pixels */\n\n    /* All functions with TIFF interfaces are static. */\nstatic PIX      *pixReadFromTiffStream(TIFF *tif);\nstatic l_int32   getTiffStreamResolution(TIFF *tif, l_int32 *pxres,\n                                         l_int32 *pyres);\nstatic l_int32   tiffReadHeaderTiff(TIFF *tif, l_int32 *pwidth,\n                                    l_int32 *pheight, l_int32 *pbps,\n                                    l_int32 *pspp, l_int32 *pres,\n                                    l_int32 *pcmap, l_int32 *pformat);\nstatic l_int32   writeCustomTiffTags(TIFF *tif, NUMA *natags,\n                                     SARRAY *savals, SARRAY  *satypes,\n                                     NUMA *nasizes);\nstatic l_int32   pixWriteToTiffStream(TIFF *tif, PIX *pix, l_int32 comptype,\n                                      NUMA *natags, SARRAY *savals,\n                                      SARRAY *satypes, NUMA *nasizes);\nstatic TIFF     *fopenTiff(FILE *fp, const char *modestring);\nstatic TIFF     *openTiff(const char *filename, const char *modestring);\n\n    /* Static helper for tiff compression type */\nstatic l_int32   getTiffCompressedFormat(l_uint16 tiffcomp);\n\n    /* Static function for memory I/O */\nstatic TIFF     *fopenTiffMemstream(const char *filename, const char *operation,\n                                    l_uint8 **pdata, size_t *pdatasize);\n\n    /* This structure defines a transform to be performed on a TIFF image\n     * (note that the same transformation can be represented in\n     * several different ways using this structure since\n     * vflip + hflip + counterclockwise == clockwise). */\nstruct tiff_transform {\n    int vflip;    /* if non-zero, image needs a vertical fip */\n    int hflip;    /* if non-zero, image needs a horizontal flip */\n    int rotate;   /* -1 -> counterclockwise 90-degree rotation,\n                      0 -> no rotation\n                      1 -> clockwise 90-degree rotation */\n};\n\n    /* This describes the transformations needed for a given orientation\n     * tag.  The tag values start at 1, so you need to subtract 1 to get a\n     * valid index into this array.  It is only valid when not using\n     * TIFFReadRGBAImageOriented(). */\nstatic struct tiff_transform tiff_orientation_transforms[] = {\n    {0, 0, 0},\n    {0, 1, 0},\n    {1, 1, 0},\n    {1, 0, 0},\n    {0, 1, -1},\n    {0, 0, 1},\n    {0, 1, 1},\n    {0, 0, -1}\n};\n\n    /* Same as above, except that test transformations are only valid\n     * when using TIFFReadRGBAImageOriented().  Transformations\n     * were determined empirically.  See the libtiff mailing list for\n     * more discussion: http://www.asmail.be/msg0054683875.html  */\nstatic struct tiff_transform tiff_partial_orientation_transforms[] = {\n    {0, 0, 0},\n    {0, 0, 0},\n    {0, 0, 0},\n    {0, 0, 0},\n    {0, 1, -1},\n    {0, 1, 1},\n    {1, 0, 1},\n    {0, 1, -1}\n};\n\n\n/*-----------------------------------------------------------------------*\n *             TIFFClientOpen() wrappers for FILE*                       *\n *             Provided by J\u00fcrgen Buchm\u00fcller                             *\n *                                                                       *\n *  We previously used TIFFFdOpen(), which used low-level file           *\n *  descriptors.  It had portability issues with Windows, along          *\n *  with other limitations from lack of stream control operations.       *\n *  These callbacks to TIFFClientOpen() avoid the problems.              *\n *                                                                       *\n *  J\u00fcrgen made the functions use 64 bit file operations where possible  *\n *  or required, namely for seek and size. On Windows there are specific *\n *  _fseeki64() and _ftelli64() functions.  On unix it is common to look *\n *  for a macro _LARGEFILE64_SOURCE being defined, which makes available *\n *  the off64_t type, and to use fseeko() and ftello() in this case.     *\n *-----------------------------------------------------------------------*/\nstatic tsize_t\nlept_read_proc(thandle_t  cookie,\n               tdata_t    buff,\n               tsize_t    size)\n{\n    FILE* fp = (FILE *)cookie;\n    tsize_t done;\n    if (!buff || !cookie || !fp)\n        return (tsize_t)-1;\n    done = fread(buff, 1, size, fp);\n    return done;\n}\n\nstatic tsize_t\nlept_write_proc(thandle_t  cookie,\n                tdata_t    buff,\n                tsize_t    size)\n{\n    FILE* fp = (FILE *)cookie;\n    tsize_t done;\n    if (!buff || !cookie || !fp)\n        return (tsize_t)-1;\n    done = fwrite(buff, 1, size, fp);\n    return done;\n}\n\nstatic toff_t\nlept_seek_proc(thandle_t  cookie,\n               toff_t     offs,\n               int        whence)\n{\n    FILE* fp = (FILE *)cookie;\n#if defined(_MSC_VER)\n    __int64 pos = 0;\n    if (!cookie || !fp)\n        return (tsize_t)-1;\n    switch (whence) {\n    case SEEK_SET:\n        pos = 0;\n        break;\n    case SEEK_CUR:\n        pos = ftell(fp);\n        break;\n    case SEEK_END:\n        _fseeki64(fp, 0, SEEK_END);\n        pos = _ftelli64(fp);\n        break;\n    }\n    pos = (__int64)(pos + offs);\n    _fseeki64(fp, pos, SEEK_SET);\n    if (pos == _ftelli64(fp))\n        return (tsize_t)pos;\n#elif defined(_LARGEFILE64_SOURCE)\n    off64_t pos = 0;\n    if (!cookie || !fp)\n        return (tsize_t)-1;\n    switch (whence) {\n    case SEEK_SET:\n        pos = 0;\n        break;\n    case SEEK_CUR:\n        pos = ftello(fp);\n        break;\n    case SEEK_END:\n        fseeko(fp, 0, SEEK_END);\n        pos = ftello(fp);\n        break;\n    }\n    pos = (off64_t)(pos + offs);\n    fseeko(fp, pos, SEEK_SET);\n    if (pos == ftello(fp))\n        return (tsize_t)pos;\n#else\n    off_t pos = 0;\n    if (!cookie || !fp)\n        return (tsize_t)-1;\n    switch (whence) {\n    case SEEK_SET:\n        pos = 0;\n        break;\n    case SEEK_CUR:\n        pos = ftell(fp);\n        break;\n    case SEEK_END:\n        fseek(fp, 0, SEEK_END);\n        pos = ftell(fp);\n        break;\n    }\n    pos = (off_t)(pos + offs);\n    fseek(fp, pos, SEEK_SET);\n    if (pos == ftell(fp))\n        return (tsize_t)pos;\n#endif\n    return (tsize_t)-1;\n}\n\nstatic int\nlept_close_proc(thandle_t  cookie)\n{\n    FILE* fp = (FILE *)cookie;\n    if (!cookie || !fp)\n        return 0;\n    fseek(fp, 0, SEEK_SET);\n    return 0;\n}\n\nstatic toff_t\nlept_size_proc(thandle_t  cookie)\n{\n    FILE* fp = (FILE *)cookie;\n#if defined(_MSC_VER)\n    __int64 pos;\n    __int64 size;\n    if (!cookie || !fp)\n        return (tsize_t)-1;\n    pos = _ftelli64(fp);\n    _fseeki64(fp, 0, SEEK_END);\n    size = _ftelli64(fp);\n    _fseeki64(fp, pos, SEEK_SET);\n#elif defined(_LARGEFILE64_SOURCE)\n    off64_t pos;\n    off64_t size;\n    if (!fp)\n        return (tsize_t)-1;\n    pos = ftello(fp);\n    fseeko(fp, 0, SEEK_END);\n    size = ftello(fp);\n    fseeko(fp, pos, SEEK_SET);\n#else\n    off_t pos;\n    off_t size;\n    if (!cookie || !fp)\n        return (tsize_t)-1;\n    pos = ftell(fp);\n    fseek(fp, 0, SEEK_END);\n    size = ftell(fp);\n    fseek(fp, pos, SEEK_SET);\n#endif\n    return (toff_t)size;\n}\n\n\n/*--------------------------------------------------------------*\n *                      Reading from file                       *\n *--------------------------------------------------------------*/\n/*!\n * \\brief   pixReadTiff()\n *\n * \\param[in]    filename\n * \\param[in]    n           page number 0 based\n * \\return  pix, or NULL on error\n *\n * <pre>\n * Notes:\n *      (1) This is a version of pixRead(), specialized for tiff\n *          files, that allows specification of the page to be returned\n *      (2) No warning messages on failure, because of how multi-page\n *          TIFF reading works. You are supposed to keep trying until\n *          it stops working.\n * </pre>\n */\nPIX *\npixReadTiff(const char  *filename,\n            l_int32      n)\n{\nFILE  *fp;\nPIX   *pix;\n\n    PROCNAME(\"pixReadTiff\");\n\n    if (!filename)\n        return (PIX *)ERROR_PTR(\"filename not defined\", procName, NULL);\n\n    if ((fp = fopenReadStream(filename)) == NULL)\n        return (PIX *)ERROR_PTR(\"image file not found\", procName, NULL);\n    pix = pixReadStreamTiff(fp, n);\n    fclose(fp);\n    return pix;\n}\n\n\n/*--------------------------------------------------------------*\n *                     Reading from stream                      *\n *--------------------------------------------------------------*/\n/*!\n * \\brief   pixReadStreamTiff()\n *\n * \\param[in]    fp    file stream\n * \\param[in]    n     page number: 0 based\n * \\return  pix, or NULL on error or if there are no more images in the file\n *\n * <pre>\n * Notes:\n *      (1) No warning messages on failure, because of how multi-page\n *          TIFF reading works. You are supposed to keep trying until\n *          it stops working.\n * </pre>\n */\nPIX *\npixReadStreamTiff(FILE    *fp,\n                  l_int32  n)\n{\nPIX   *pix;\nTIFF  *tif;\n\n    PROCNAME(\"pixReadStreamTiff\");\n\n    if (!fp)\n        return (PIX *)ERROR_PTR(\"stream not defined\", procName, NULL);\n\n    if ((tif = fopenTiff(fp, \"r\")) == NULL)\n        return (PIX *)ERROR_PTR(\"tif not opened\", procName, NULL);\n\n    if (TIFFSetDirectory(tif, n) == 0) {\n        TIFFCleanup(tif);\n        return NULL;\n    }\n    if ((pix = pixReadFromTiffStream(tif)) == NULL) {\n        TIFFCleanup(tif);\n        return NULL;\n    }\n    TIFFCleanup(tif);\n    return pix;\n}\n\n\n/*!\n * \\brief   pixReadFromTiffStream()\n *\n * \\param[in]    tif    TIFF handle\n * \\return  pix, or NULL on error\n *\n * <pre>\n * Notes:\n *      (1) We can read the following images (up to 32 bits/pixel):\n *          1 spp (grayscale): 1, 2, 4, 8, 16 bps\n *          1 spp (colormapped): 1, 2, 4, 8 bps\n *          2 spp (gray+alpha): 8 bps\n *          3 spp (rgb) and 4 spp (rgba): 8 or 16 bps\n *      (2) We do not handle 16 bps for spp == 2.\n *      (3) 2 bpp gray+alpha are rasterized as 32 bit/pixel rgba, with\n *          the gray value replicated in r, g and b.\n *      (4) For colormapped images, we support 8 bits/color in the palette.\n *          Tiff colormaps have 16 bits/color, and we reduce them to 8.\n *      (5) Quoting the libtiff documentation at\n *               http://libtiff.maptools.org/libtiff.html\n *          \"libtiff provides a high-level interface for reading image data\n *          from a TIFF file. This interface handles the details of data\n *          organization and format for a wide variety of TIFF files;\n *          at least the large majority of those files that one would\n *          normally encounter. Image data is, by default, returned as\n *          ABGR pixels packed into 32-bit words (8 bits per sample).\n *          Rectangular rasters can be read or data can be intercepted\n *          at an intermediate level and packed into memory in a format\n *          more suitable to the application. The library handles all\n *          the details of the format of data stored on disk and,\n *          in most cases, if any colorspace conversions are required:\n *          bilevel to RGB, greyscale to RGB, CMYK to RGB, YCbCr to RGB,\n *          16-bit samples to 8-bit samples, associated/unassociated alpha,\n *          etc.\"\n * </pre>\n */\nstatic PIX *\npixReadFromTiffStream(TIFF  *tif)\n{\nchar      *text;\nl_uint8   *linebuf, *data, *rowptr;\nl_uint16   spp, bps, photometry, tiffcomp, orientation, sample_fmt;\nl_uint16  *redmap, *greenmap, *bluemap;\nl_int32    d, wpl, bpl, comptype, i, j, k, ncolors, rval, gval, bval, aval;\nl_int32    xres, yres, tiffbpl, packedbpl, halfsize;\nl_uint32   w, h, tiffword, read_oriented;\nl_uint32  *line, *ppixel, *tiffdata, *pixdata;\nPIX       *pix, *pix1;\nPIXCMAP   *cmap;\n\n    PROCNAME(\"pixReadFromTiffStream\");\n\n    if (!tif)\n        return (PIX *)ERROR_PTR(\"tif not defined\", procName, NULL);\n\n    read_oriented = 0;\n\n        /* Only accept uint image data:\n         *   SAMPLEFORMAT_UINT = 1;\n         *   SAMPLEFORMAT_INT = 2;\n         *   SAMPLEFORMAT_IEEEFP = 3;\n         *   SAMPLEFORMAT_VOID = 4;   */\n    TIFFGetFieldDefaulted(tif, TIFFTAG_SAMPLEFORMAT, &sample_fmt);\n    if (sample_fmt != SAMPLEFORMAT_UINT) {\n        L_ERROR(\"sample format = %d is not uint\\n\", procName, sample_fmt);\n        return NULL;\n    }\n\n        /* Can't read tiff in tiled format. For what is involved, see, e.g:\n         *   https://www.cs.rochester.edu/~nelson/courses/vision/\\\n         *     resources/tiff/libtiff.html#Tiles\n         * A tiled tiff can be converted to a normal (strip) tif:\n         *   tiffcp -s <input-tiled-tif> <output-strip-tif>    */\n    if (TIFFIsTiled(tif)) {\n        L_ERROR(\"tiled format is not supported\\n\", procName);\n        return NULL;\n    }\n\n        /* Old style jpeg is not supported.  We tried supporting 8 bpp.\n         * TIFFReadScanline() fails on this format, so we used RGBA\n         * reading, which generates a 4 spp image, and pulled out the\n         * red component.  However, there were problems with double-frees\n         * in cleanup.  For RGB, tiffbpl is exactly half the size that\n         * you would expect for the raster data in a scanline, which\n         * is 3 * w.  */\n    TIFFGetFieldDefaulted(tif, TIFFTAG_COMPRESSION, &tiffcomp);\n    if (tiffcomp == COMPRESSION_OJPEG) {\n        L_ERROR(\"old style jpeg format is not supported\\n\", procName);\n        return NULL;\n    }\n\n        /* Use default fields for bps and spp */\n    TIFFGetFieldDefaulted(tif, TIFFTAG_BITSPERSAMPLE, &bps);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_SAMPLESPERPIXEL, &spp);\n    if (bps != 1 && bps != 2 && bps != 4 && bps != 8 && bps != 16) {\n        L_ERROR(\"invalid bps = %d\\n\", procName, bps);\n        return NULL;\n    }\n    if (spp == 2 && bps != 8) {\n        L_WARNING(\"for 2 spp, only handle 8 bps\\n\", procName);\n        return NULL;\n    }\n    if (spp == 1)\n        d = bps;\n    else if (spp == 2)  /* gray plus alpha */\n        d = 32;  /* will convert to RGBA */\n    else if (spp == 3 || spp == 4)\n        d = 32;\n    else\n        return (PIX *)ERROR_PTR(\"spp not in set {1,2,3,4}\", procName, NULL);\n\n    TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &w);\n    TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &h);\n    if (w > MaxTiffWidth) {\n        L_ERROR(\"width = %d pixels; too large\\n\", procName, w);\n        return NULL;\n    }\n    if (h > MaxTiffHeight) {\n        L_ERROR(\"height = %d pixels; too large\\n\", procName, h);\n        return NULL;\n    }\n\n        /* The relation between the size of a byte buffer required to hold\n           a raster of image pixels (packedbpl) and the size of the tiff\n           buffer (tiffbuf) is either 1:1 or approximately 2:1, depending\n           on how the data is stored and subsampled.  Allow some slop\n           when validating the relation between buffer size and the image\n           parameters w, spp and bps. */\n    tiffbpl = TIFFScanlineSize(tif);\n    packedbpl = (bps * spp * w + 7) / 8;\n    halfsize = L_ABS(2 * tiffbpl - packedbpl) <= 8;\n#if 0\n    if (halfsize)\n        L_INFO(\"packedbpl = %d is approx. twice tiffbpl = %d\\n\", procName,\n               packedbpl, tiffbpl);\n#endif\n    if (tiffbpl != packedbpl && !halfsize) {\n        L_ERROR(\"invalid tiffbpl: tiffbpl = %d, packedbpl = %d, \"\n                \"bps = %d, spp = %d, w = %d\\n\",\n                procName, tiffbpl, packedbpl, bps, spp, w);\n        return NULL;\n    }\n\n    if ((pix = pixCreate(w, h, d)) == NULL)\n        return (PIX *)ERROR_PTR(\"pix not made\", procName, NULL);\n    pixSetInputFormat(pix, IFF_TIFF);\n    data = (l_uint8 *)pixGetData(pix);\n    wpl = pixGetWpl(pix);\n    bpl = 4 * wpl;\n\n    if (spp == 1) {\n        linebuf = (l_uint8 *)LEPT_CALLOC(tiffbpl + 1, sizeof(l_uint8));\n        for (i = 0; i < h; i++) {\n            if (TIFFReadScanline(tif, linebuf, i, 0) < 0) {\n                LEPT_FREE(linebuf);\n                pixDestroy(&pix);\n                return (PIX *)ERROR_PTR(\"line read fail\", procName, NULL);\n            }\n            memcpy(data, linebuf, tiffbpl);\n            data += bpl;\n        }\n        if (bps <= 8)\n            pixEndianByteSwap(pix);\n        else   /* bps == 16 */\n            pixEndianTwoByteSwap(pix);\n        LEPT_FREE(linebuf);\n    } else if (spp == 2 && bps == 8) {  /* gray plus alpha */\n        L_INFO(\"gray+alpha is not supported; converting to RGBA\\n\", procName);\n        pixSetSpp(pix, 4);\n        linebuf = (l_uint8 *)LEPT_CALLOC(2 * tiffbpl + 1, sizeof(l_uint8));\n        pixdata = pixGetData(pix);\n        for (i = 0; i < h; i++) {\n            if (TIFFReadScanline(tif, linebuf, i, 0) < 0) {\n                LEPT_FREE(linebuf);\n                pixDestroy(&pix);\n                return (PIX *)ERROR_PTR(\"line read fail\", procName, NULL);\n            }\n            rowptr = linebuf;\n            ppixel = pixdata + i * wpl;\n            for (j = k = 0; j < w; j++) {\n                    /* Copy gray value into r, g and b */\n                SET_DATA_BYTE(ppixel, COLOR_RED, rowptr[k]);\n                SET_DATA_BYTE(ppixel, COLOR_GREEN, rowptr[k]);\n                SET_DATA_BYTE(ppixel, COLOR_BLUE, rowptr[k++]);\n                SET_DATA_BYTE(ppixel, L_ALPHA_CHANNEL, rowptr[k++]);\n                ppixel++;\n            }\n        }\n        LEPT_FREE(linebuf);\n    } else {  /* rgb and rgba */\n        if ((tiffdata = (l_uint32 *)LEPT_CALLOC((size_t)w * h,\n                                                 sizeof(l_uint32))) == NULL) {\n            pixDestroy(&pix);\n            return (PIX *)ERROR_PTR(\"calloc fail for tiffdata\", procName, NULL);\n        }\n            /* TIFFReadRGBAImageOriented() converts to 8 bps */\n        if (!TIFFReadRGBAImageOriented(tif, w, h, tiffdata,\n                                       ORIENTATION_TOPLEFT, 0)) {\n            LEPT_FREE(tiffdata);\n            pixDestroy(&pix);\n            return (PIX *)ERROR_PTR(\"failed to read tiffdata\", procName, NULL);\n        } else {\n            read_oriented = 1;\n        }\n\n        if (spp == 4) pixSetSpp(pix, 4);\n        line = pixGetData(pix);\n        for (i = 0; i < h; i++, line += wpl) {\n            for (j = 0, ppixel = line; j < w; j++) {\n                    /* TIFFGet* are macros */\n                tiffword = tiffdata[i * w + j];\n                rval = TIFFGetR(tiffword);\n                gval = TIFFGetG(tiffword);\n                bval = TIFFGetB(tiffword);\n                if (spp == 3) {\n                    composeRGBPixel(rval, gval, bval, ppixel);\n                } else {  /* spp == 4 */\n                    aval = TIFFGetA(tiffword);\n                    composeRGBAPixel(rval, gval, bval, aval, ppixel);\n                }\n                ppixel++;\n            }\n        }\n        LEPT_FREE(tiffdata);\n    }\n\n    if (getTiffStreamResolution(tif, &xres, &yres) == 0) {\n        pixSetXRes(pix, xres);\n        pixSetYRes(pix, yres);\n    }\n\n        /* Find and save the compression type */\n    comptype = getTiffCompressedFormat(tiffcomp);\n    pixSetInputFormat(pix, comptype);\n\n    if (TIFFGetField(tif, TIFFTAG_COLORMAP, &redmap, &greenmap, &bluemap)) {\n            /* Save the colormap as a pix cmap.  Because the\n             * tiff colormap components are 16 bit unsigned,\n             * and go from black (0) to white (0xffff), the\n             * the pix cmap takes the most significant byte. */\n        if (bps > 8) {\n            pixDestroy(&pix);\n            return (PIX *)ERROR_PTR(\"colormap size > 256\", procName, NULL);\n        }\n        if ((cmap = pixcmapCreate(bps)) == NULL) {\n            pixDestroy(&pix);\n            return (PIX *)ERROR_PTR(\"colormap not made\", procName, NULL);\n        }\n        ncolors = 1 << bps;\n        for (i = 0; i < ncolors; i++)\n            pixcmapAddColor(cmap, redmap[i] >> 8, greenmap[i] >> 8,\n                            bluemap[i] >> 8);\n        if (pixSetColormap(pix, cmap)) {\n            pixDestroy(&pix);\n            return (PIX *)ERROR_PTR(\"invalid colormap\", procName, NULL);\n        }\n\n            /* Remove the colormap for 1 bpp. */\n        if (bps == 1) {\n            pix1 = pixRemoveColormap(pix, REMOVE_CMAP_BASED_ON_SRC);\n            pixDestroy(&pix);\n            pix = pix1;\n        }\n    } else {   /* No colormap: check photometry and invert if necessary */\n        if (!TIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &photometry)) {\n                /* Guess default photometry setting.  Assume min_is_white\n                 * if compressed 1 bpp; min_is_black otherwise. */\n            if (tiffcomp == COMPRESSION_CCITTFAX3 ||\n                tiffcomp == COMPRESSION_CCITTFAX4 ||\n                tiffcomp == COMPRESSION_CCITTRLE ||\n                tiffcomp == COMPRESSION_CCITTRLEW) {\n                photometry = PHOTOMETRIC_MINISWHITE;\n            } else {\n                photometry = PHOTOMETRIC_MINISBLACK;\n            }\n        }\n        if ((d == 1 && photometry == PHOTOMETRIC_MINISBLACK) ||\n            (d == 8 && photometry == PHOTOMETRIC_MINISWHITE))\n            pixInvert(pix, pix);\n    }\n\n    if (TIFFGetField(tif, TIFFTAG_ORIENTATION, &orientation)) {\n        if (orientation >= 1 && orientation <= 8) {\n            struct tiff_transform *transform = (read_oriented) ?\n                &tiff_partial_orientation_transforms[orientation - 1] :\n                &tiff_orientation_transforms[orientation - 1];\n            if (transform->vflip) pixFlipTB(pix, pix);\n            if (transform->hflip) pixFlipLR(pix, pix);\n            if (transform->rotate) {\n                PIX *oldpix = pix;\n                pix = pixRotate90(oldpix, transform->rotate);\n                pixDestroy(&oldpix);\n            }\n        }\n    }\n\n    text = NULL;\n    TIFFGetField(tif, TIFFTAG_IMAGEDESCRIPTION, &text);\n    if (text) pixSetText(pix, text);\n    return pix;\n}\n\n\n/*--------------------------------------------------------------*\n *                       Writing to file                        *\n *--------------------------------------------------------------*/\n/*!\n * \\brief   pixWriteTiff()\n *\n * \\param[in]    filename   to write to\n * \\param[in]    pix        any depth, colormap will be removed\n * \\param[in]    comptype   IFF_TIFF, IFF_TIFF_RLE, IFF_TIFF_PACKBITS,\n *                          IFF_TIFF_G3, IFF_TIFF_G4,\n *                          IFF_TIFF_LZW, IFF_TIFF_ZIP, IFF_TIFF_JPEG\n * \\param[in]    modestr    \"a\" or \"w\"\n * \\return  0 if OK, 1 on error\n *\n * <pre>\n * Notes:\n *      (1) For multipage tiff, write the first pix with mode \"w\" and\n *          all subsequent pix with mode \"a\".\n *      (2) For multipage tiff, there is considerable overhead in the\n *          machinery to append an image and add the directory entry,\n *          and the time required for each image increases linearly\n *          with the number of images in the file.\n * </pre>\n */\nl_ok\npixWriteTiff(const char  *filename,\n             PIX         *pix,\n             l_int32      comptype,\n             const char  *modestr)\n{\n    return pixWriteTiffCustom(filename, pix, comptype, modestr,\n                              NULL, NULL, NULL, NULL);\n}\n\n\n/*!\n * \\brief   pixWriteTiffCustom()\n *\n * \\param[in]    filename   to write to\n * \\param[in]    pix\n * \\param[in]    comptype   IFF_TIFF, IFF_TIFF_RLE, IFF_TIFF_PACKBITS,\n *                          IFF_TIFF_G3, IFF_TIFF_G4,\n *                          IFF_TIFF_LZW, IFF_TIFF_ZIP, IFF_TIFF_JPEG\n * \\param[in]    modestr    \"a\" or \"w\"\n * \\param[in]    natags [optional] NUMA of custom tiff tags\n * \\param[in]    savals [optional] SARRAY of values\n * \\param[in]    satypes [optional] SARRAY of types\n * \\param[in]    nasizes [optional] NUMA of sizes\n * \\return  0 if OK, 1 on error\n *\n *  Usage:\n *      1 This writes a page image to a tiff file, with optional\n *          extra tags defined in tiff.h\n *      2 For multipage tiff, write the first pix with mode \"w\" and\n *          all subsequent pix with mode \"a\".\n *      3 For the custom tiff tags:\n *          a The three arrays {natags, savals, satypes} must all be\n *              either NULL or defined and of equal size.\n *          b If they are defined, the tags are an array of integers,\n *              the vals are an array of values in string format, and\n *              the types are an array of types in string format.\n *          c All valid tags are definined in tiff.h.\n *          d The types allowed are the set of strings:\n *                \"char*\"\n *                \"l_uint8*\"\n *                \"l_uint16\"\n *                \"l_uint32\"\n *                \"l_int32\"\n *                \"l_float64\"\n *                \"l_uint16-l_uint16\" note the dash; use it between the\n *                                    two l_uint16 vals in the val string\n *              Of these, \"char*\" and \"l_uint16\" are the most commonly used.\n *          e The last array, nasizes, is also optional.  It is for\n *              tags that take an array of bytes for a value, a number of\n *              elements in the array, and a type that is either \"char*\"\n *              or \"l_uint8*\" probably either will work.\n *              Use NULL if there are no such tags.\n *          f VERY IMPORTANT: if there are any tags that require the\n *              extra size value, stored in nasizes, they must be\n *              written first!\n */\nl_ok\npixWriteTiffCustom(const char  *filename,\n                   PIX         *pix,\n                   l_int32      comptype,\n                   const char  *modestr,\n                   NUMA        *natags,\n                   SARRAY      *savals,\n                   SARRAY      *satypes,\n                   NUMA        *nasizes)\n{\nl_int32  ret;\nTIFF    *tif;\n\n    PROCNAME(\"pixWriteTiffCustom\");\n\n    if (!filename)\n        return ERROR_INT(\"filename not defined\", procName, 1);\n    if (!pix)\n        return ERROR_INT(\"pix not defined\", procName, 1);\n\n    if ((tif = openTiff(filename, modestr)) == NULL)\n        return ERROR_INT(\"tif not opened\", procName, 1);\n    ret = pixWriteToTiffStream(tif, pix, comptype, natags, savals,\n                               satypes, nasizes);\n    TIFFClose(tif);\n    return ret;\n}\n\n\n/*--------------------------------------------------------------*\n *                       Writing to stream                      *\n *--------------------------------------------------------------*/\n/*!\n * \\brief   pixWriteStreamTiff()\n *\n * \\param[in]    fp       file stream\n * \\param[in]    pix\n * \\param[in]    comptype IFF_TIFF, IFF_TIFF_RLE, IFF_TIFF_PACKBITS,\n *                        IFF_TIFF_G3, IFF_TIFF_G4,\n *                        IFF_TIFF_LZW, IFF_TIFF_ZIP, IFF_TIFF_JPEG\n * \\return  0 if OK, 1 on error\n *\n * <pre>\n * Notes:\n *      (1) This writes a single image to a file stream opened for writing.\n *      (2) If the pix has a colormap, it is preserved in the output file.\n *      (3) For images with bpp > 1, this resets the comptype, if\n *          necessary, to write uncompressed data.\n *      (4) G3 and G4 are only defined for 1 bpp.\n *      (5) We only allow PACKBITS for bpp = 1, because for bpp > 1\n *          it typically expands images that are not synthetically generated.\n *      (6) G4 compression is typically about twice as good as G3.\n *          G4 is excellent for binary compression of text/line-art,\n *          but terrible for halftones and dithered patterns.  (In\n *          fact, G4 on halftones can give a file that is larger\n *          than uncompressed!)  If a binary image has dithered\n *          regions, it is usually better to compress with png.\n * </pre>\n */\nl_ok\npixWriteStreamTiff(FILE    *fp,\n                   PIX     *pix,\n                   l_int32  comptype)\n{\n    return pixWriteStreamTiffWA(fp, pix, comptype, \"w\");\n}\n\n\n/*!\n * \\brief   pixWriteStreamTiffWA()\n *\n * \\param[in]    fp       file stream opened for append or write\n * \\param[in]    pix\n * \\param[in]    comptype IFF_TIFF, IFF_TIFF_RLE, IFF_TIFF_PACKBITS,\n *                        IFF_TIFF_G3, IFF_TIFF_G4,\n *                        IFF_TIFF_LZW, IFF_TIFF_ZIP, IFF_TIFF_JPEG\n * \\param[in]    modestr  \"w\" or \"a\"\n * \\return  0 if OK, 1 on error\n *\n * <pre>\n * Notes:\n *      (1) See pixWriteStreamTiff()\n * </pre>\n */\nl_ok\npixWriteStreamTiffWA(FILE        *fp,\n                     PIX         *pix,\n                     l_int32      comptype,\n                     const char  *modestr)\n{\nTIFF  *tif;\n\n    PROCNAME(\"pixWriteStreamTiffWA\");\n\n    if (!fp)\n        return ERROR_INT(\"stream not defined\", procName, 1 );\n    if (!pix)\n        return ERROR_INT(\"pix not defined\", procName, 1 );\n    if (strcmp(modestr, \"w\") && strcmp(modestr, \"a\"))\n        return ERROR_INT(\"modestr not 'w' or 'a'\", procName, 1 );\n\n    if (pixGetDepth(pix) != 1 && comptype != IFF_TIFF &&\n        comptype != IFF_TIFF_LZW && comptype != IFF_TIFF_ZIP &&\n        comptype != IFF_TIFF_JPEG) {\n        L_WARNING(\"invalid compression type for bpp > 1\\n\", procName);\n        comptype = IFF_TIFF_ZIP;\n    }\n\n    if ((tif = fopenTiff(fp, modestr)) == NULL)\n        return ERROR_INT(\"tif not opened\", procName, 1);\n\n    if (pixWriteToTiffStream(tif, pix, comptype, NULL, NULL, NULL, NULL)) {\n        TIFFCleanup(tif);\n        return ERROR_INT(\"tif write error\", procName, 1);\n    }\n\n    TIFFCleanup(tif);\n    return 0;\n}\n\n\n/*!\n * \\brief   pixWriteToTiffStream()\n *\n * \\param[in]    tif       data structure, opened to a file\n * \\param[in]    pix\n * \\param[in]    comptype  IFF_TIFF: for any image; no compression\n *                         IFF_TIFF_RLE, IFF_TIFF_PACKBITS: for 1 bpp only\n *                         IFF_TIFF_G4 and IFF_TIFF_G3: for 1 bpp only\n *                         IFF_TIFF_LZW, IFF_TIFF_ZIP: lossless for any image\n *                         IFF_TIFF_JPEG: lossy 8 bpp gray or rgb\n * \\param[in]    natags    [optional] NUMA of custom tiff tags\n * \\param[in]    savals    [optional] SARRAY of values\n * \\param[in]    satypes   [optional] SARRAY of types\n * \\param[in]    nasizes   [optional] NUMA of sizes\n * \\return  0 if OK, 1 on error\n *\n * <pre>\n * Notes:\n *      (1) This static function should only be called through higher\n *          level functions in this file; namely, pixWriteTiffCustom(),\n *          pixWriteTiff(), pixWriteStreamTiff(), pixWriteMemTiff()\n *          and pixWriteMemTiffCustom().\n *      (2) We only allow PACKBITS for bpp = 1, because for bpp > 1\n *          it typically expands images that are not synthetically generated.\n *      (3) See pixWriteTiffCustom() for details on how to use\n *          the last four parameters for customized tiff tags.\n *      (4) The only valid pixel depths in leptonica are 1, 2, 4, 8, 16\n *          and 32.  However, it is possible, and in some cases desirable,\n *          to write out a tiff file using an rgb pix that has 24 bpp.\n *          This can be created by appending the raster data for a 24 bpp\n *          image (with proper scanline padding) directly to a 24 bpp\n *          pix that was created without a data array.  See note in\n *          pixWriteStreamPng() for an example.\n * </pre>\n */\nstatic l_int32\npixWriteToTiffStream(TIFF    *tif,\n                     PIX     *pix,\n                     l_int32  comptype,\n                     NUMA    *natags,\n                     SARRAY  *savals,\n                     SARRAY  *satypes,\n                     NUMA    *nasizes)\n{\nl_uint8   *linebuf, *data;\nl_uint16   redmap[256], greenmap[256], bluemap[256];\nl_int32    w, h, d, spp, i, j, k, wpl, bpl, tiffbpl, ncolors, cmapsize;\nl_int32   *rmap, *gmap, *bmap;\nl_int32    xres, yres;\nl_uint32  *line, *ppixel;\nPIX       *pixt;\nPIXCMAP   *cmap;\nchar      *text;\n\n    PROCNAME(\"pixWriteToTiffStream\");\n\n    if (!tif)\n        return ERROR_INT(\"tif stream not defined\", procName, 1);\n    if (!pix)\n        return ERROR_INT( \"pix not defined\", procName, 1 );\n\n    pixSetPadBits(pix, 0);\n    pixGetDimensions(pix, &w, &h, &d);\n    spp = pixGetSpp(pix);\n    xres = pixGetXRes(pix);\n    yres = pixGetYRes(pix);\n    if (xres == 0) xres = DefaultResolution;\n    if (yres == 0) yres = DefaultResolution;\n\n        /* ------------------ Write out the header -------------  */\n    TIFFSetField(tif, TIFFTAG_RESOLUTIONUNIT, (l_uint32)RESUNIT_INCH);\n    TIFFSetField(tif, TIFFTAG_XRESOLUTION, (l_float64)xres);\n    TIFFSetField(tif, TIFFTAG_YRESOLUTION, (l_float64)yres);\n\n    TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, (l_uint32)w);\n    TIFFSetField(tif, TIFFTAG_IMAGELENGTH, (l_uint32)h);\n    TIFFSetField(tif, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\n\n    if ((text = pixGetText(pix)) != NULL)\n        TIFFSetField(tif, TIFFTAG_IMAGEDESCRIPTION, text);\n\n    if (d == 1 && !pixGetColormap(pix)) {\n            /* If d == 1, preserve the colormap.  Note that when\n             * d == 1 pix with colormaps are read, the colormaps\n             * are removed.  The only pix in leptonica that have\n             * colormaps are made programmatically. */\n        TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISWHITE);\n    } else if ((d == 32 && spp == 3) || d == 24) {\n        TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n        TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, (l_uint16)3);\n        TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE,\n                       (l_uint16)8, (l_uint16)8, (l_uint16)8);\n    } else if (d == 32 && spp == 4) {\n        l_uint16  val[1];\n        val[0] = EXTRASAMPLE_ASSOCALPHA;\n        TIFFSetField(tif, TIFFTAG_EXTRASAMPLES, (l_uint16)1, &val);\n        TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n        TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, (l_uint16)4);\n        TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE,\n                     (l_uint16)8, (l_uint16)8, (l_uint16)8, (l_uint16)8);\n    } else if (d == 16) {  /* we only support spp = 1, bps = 16 */\n        TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\n    } else if ((cmap = pixGetColormap(pix)) == NULL) {\n        TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\n    } else {  /* Save colormap in the tiff; not more than 256 colors */\n        if (d > 8) {\n            L_ERROR(\"d = %d > 8 with colormap!; reducing to 8\\n\", procName, d);\n            d = 8;\n        }\n        pixcmapToArrays(cmap, &rmap, &gmap, &bmap, NULL);\n        ncolors = pixcmapGetCount(cmap);\n        ncolors = L_MIN(256, ncolors);  /* max 256 */\n        cmapsize = 1 << d;\n        cmapsize = L_MIN(256, cmapsize);  /* power of 2; max 256 */\n        if (ncolors > cmapsize) {\n            L_WARNING(\"too many colors in cmap for tiff; truncating\\n\",\n                      procName);\n            ncolors = cmapsize;\n        }\n        for (i = 0; i < ncolors; i++) {\n            redmap[i] = (rmap[i] << 8) | rmap[i];\n            greenmap[i] = (gmap[i] << 8) | gmap[i];\n            bluemap[i] = (bmap[i] << 8) | bmap[i];\n        }\n        for (i = ncolors; i < cmapsize; i++)  /* init, even though not used */\n            redmap[i] = greenmap[i] = bluemap[i] = 0;\n        LEPT_FREE(rmap);\n        LEPT_FREE(gmap);\n        LEPT_FREE(bmap);\n\n        TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_PALETTE);\n        TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, (l_uint16)1);\n        TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, (l_uint16)d);\n        TIFFSetField(tif, TIFFTAG_COLORMAP, redmap, greenmap, bluemap);\n    }\n\n    if (d <= 16) {\n        TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, (l_uint16)d);\n        TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, (l_uint16)1);\n    }\n\n    TIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n    if (comptype == IFF_TIFF) {  /* no compression */\n        TIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_NONE);\n    } else if (comptype == IFF_TIFF_G4) {\n        TIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_CCITTFAX4);\n    } else if (comptype == IFF_TIFF_G3) {\n        TIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_CCITTFAX3);\n    } else if (comptype == IFF_TIFF_RLE) {\n        TIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_CCITTRLE);\n    } else if (comptype == IFF_TIFF_PACKBITS) {\n        TIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_PACKBITS);\n    } else if (comptype == IFF_TIFF_LZW) {\n        TIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_LZW);\n    } else if (comptype == IFF_TIFF_ZIP) {\n        TIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_ADOBE_DEFLATE);\n    } else if (comptype == IFF_TIFF_JPEG) {\n        TIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_JPEG);\n    } else {\n        L_WARNING(\"unknown tiff compression; using none\\n\", procName);\n        TIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_NONE);\n    }\n\n        /* This is a no-op if arrays are NULL */\n    writeCustomTiffTags(tif, natags, savals, satypes, nasizes);\n\n        /* ------------- Write out the image data -------------  */\n    tiffbpl = TIFFScanlineSize(tif);\n    wpl = pixGetWpl(pix);\n    bpl = 4 * wpl;\n    if (tiffbpl > bpl)\n        lept_stderr(\"Big trouble: tiffbpl = %d, bpl = %d\\n\", tiffbpl, bpl);\n    if ((linebuf = (l_uint8 *)LEPT_CALLOC(1, bpl)) == NULL)\n        return ERROR_INT(\"calloc fail for linebuf\", procName, 1);\n\n        /* Use single strip for image */\n    TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, h);\n\n    if (d != 24 && d != 32) {\n        if (d == 16)\n            pixt = pixEndianTwoByteSwapNew(pix);\n        else\n            pixt = pixEndianByteSwapNew(pix);\n        data = (l_uint8 *)pixGetData(pixt);\n        for (i = 0; i < h; i++, data += bpl) {\n            memcpy(linebuf, data, tiffbpl);\n            if (TIFFWriteScanline(tif, linebuf, i, 0) < 0)\n                break;\n        }\n        pixDestroy(&pixt);\n    } else if (d == 24) {  /* See note 4 above: special case of 24 bpp rgb */\n        for (i = 0; i < h; i++) {\n            line = pixGetData(pix) + i * wpl;\n            if (TIFFWriteScanline(tif, (l_uint8 *)line, i, 0) < 0)\n                break;\n        }\n    } else {  /* 32 bpp rgb or rgba */\n        for (i = 0; i < h; i++) {\n            line = pixGetData(pix) + i * wpl;\n            for (j = 0, k = 0, ppixel = line; j < w; j++) {\n                linebuf[k++] = GET_DATA_BYTE(ppixel, COLOR_RED);\n                linebuf[k++] = GET_DATA_BYTE(ppixel, COLOR_GREEN);\n                linebuf[k++] = GET_DATA_BYTE(ppixel, COLOR_BLUE);\n                if (spp == 4)\n                    linebuf[k++] = GET_DATA_BYTE(ppixel, L_ALPHA_CHANNEL);\n                ppixel++;\n            }\n            if (TIFFWriteScanline(tif, linebuf, i, 0) < 0)\n                break;\n        }\n    }\n\n/*    TIFFWriteDirectory(tif); */\n    LEPT_FREE(linebuf);\n\n    return 0;\n}\n\n\n/*!\n * \\brief   writeCustomTiffTags()\n *\n * \\param[in]    tif\n * \\param[in]    natags   [optional] NUMA of custom tiff tags\n * \\param[in]    savals   [optional] SARRAY of values\n * \\param[in]    satypes  [optional] SARRAY of types\n * \\param[in]    nasizes  [optional] NUMA of sizes\n * \\return  0 if OK, 1 on error\n *\n * <pre>\n * Notes:\n *      (1) This static function should be called indirectly through\n *          higher level functions, such as pixWriteTiffCustom(),\n *          which call pixWriteToTiffStream().  See details in\n *          pixWriteTiffCustom() for using the 4 input arrays.\n *      (2) This is a no-op if the first 3 arrays are all NULL.\n *      (3) Otherwise, the first 3 arrays must be defined and all\n *          of equal size.\n *      (4) The fourth array is always optional.\n *      (5) The most commonly used types are \"char*\" and \"u_int16\".\n *          See tiff.h for a full listing of the tiff tags.\n *          Note that many of these tags, in particular the bit tags,\n *          are intended to be private, and cannot be set by this function.\n *          Examples are the STRIPOFFSETS and STRIPBYTECOUNTS tags,\n *          which are bit tags that are automatically set in the header,\n *          and can be extracted using tiffdump.\n * </pre>\n */\nstatic l_int32\nwriteCustomTiffTags(TIFF    *tif,\n                    NUMA    *natags,\n                    SARRAY  *savals,\n                    SARRAY  *satypes,\n                    NUMA    *nasizes)\n{\nchar      *sval, *type;\nl_int32    i, n, ns, size, tagval, val;\nl_float64  dval;\nl_uint32   uval, uval2;\n\n    PROCNAME(\"writeCustomTiffTags\");\n\n    if (!tif)\n        return ERROR_INT(\"tif stream not defined\", procName, 1);\n    if (!natags && !savals && !satypes)\n        return 0;\n    if (!natags || !savals || !satypes)\n        return ERROR_INT(\"not all arrays defined\", procName, 1);\n    n = numaGetCount(natags);\n    if ((sarrayGetCount(savals) != n) || (sarrayGetCount(satypes) != n))\n        return ERROR_INT(\"not all sa the same size\", procName, 1);\n\n        /* The sized arrays (4 args to TIFFSetField) are written first */\n    if (nasizes) {\n        ns = numaGetCount(nasizes);\n        if (ns > n)\n            return ERROR_INT(\"too many 4-arg tag calls\", procName, 1);\n        for (i = 0; i < ns; i++) {\n            numaGetIValue(natags, i, &tagval);\n            sval = sarrayGetString(savals, i, L_NOCOPY);\n            type = sarrayGetString(satypes, i, L_NOCOPY);\n            numaGetIValue(nasizes, i, &size);\n            if (strcmp(type, \"char*\") && strcmp(type, \"l_uint8*\"))\n                L_WARNING(\"array type not char* or l_uint8*; ignore\\n\",\n                          procName);\n            TIFFSetField(tif, tagval, size, sval);\n        }\n    } else {\n        ns = 0;\n    }\n\n        /* The typical tags (3 args to TIFFSetField) are now written */\n    for (i = ns; i < n; i++) {\n        numaGetIValue(natags, i, &tagval);\n        sval = sarrayGetString(savals, i, L_NOCOPY);\n        type = sarrayGetString(satypes, i, L_NOCOPY);\n        if (!strcmp(type, \"char*\") || !strcmp(type, \"const char*\")) {\n            TIFFSetField(tif, tagval, sval);\n        } else if (!strcmp(type, \"l_uint16\")) {\n            if (sscanf(sval, \"%u\", &uval) == 1) {\n                TIFFSetField(tif, tagval, (l_uint16)uval);\n            } else {\n                lept_stderr(\"val %s not of type %s\\n\", sval, type);\n                return ERROR_INT(\"custom tag(s) not written\", procName, 1);\n            }\n        } else if (!strcmp(type, \"l_uint32\")) {\n            if (sscanf(sval, \"%u\", &uval) == 1) {\n                TIFFSetField(tif, tagval, uval);\n            } else {\n                lept_stderr(\"val %s not of type %s\\n\", sval, type);\n                return ERROR_INT(\"custom tag(s) not written\", procName, 1);\n            }\n        } else if (!strcmp(type, \"l_int32\")) {\n            if (sscanf(sval, \"%d\", &val) == 1) {\n                TIFFSetField(tif, tagval, val);\n            } else {\n                lept_stderr(\"val %s not of type %s\\n\", sval, type);\n                return ERROR_INT(\"custom tag(s) not written\", procName, 1);\n            }\n        } else if (!strcmp(type, \"l_float64\")) {\n            if (sscanf(sval, \"%lf\", &dval) == 1) {\n                TIFFSetField(tif, tagval, dval);\n            } else {\n                lept_stderr(\"val %s not of type %s\\n\", sval, type);\n                return ERROR_INT(\"custom tag(s) not written\", procName, 1);\n            }\n        } else if (!strcmp(type, \"l_uint16-l_uint16\")) {\n            if (sscanf(sval, \"%u-%u\", &uval, &uval2) == 2) {\n                TIFFSetField(tif, tagval, (l_uint16)uval, (l_uint16)uval2);\n            } else {\n                lept_stderr(\"val %s not of type %s\\n\", sval, type);\n                return ERROR_INT(\"custom tag(s) not written\", procName, 1);\n            }\n        } else {\n            lept_stderr(\"unknown type %s\\n\",type);\n            return ERROR_INT(\"unknown type; tag(s) not written\", procName, 1);\n        }\n    }\n    return 0;\n}\n\n\n/*--------------------------------------------------------------*\n *               Reading and writing multipage tiff             *\n *--------------------------------------------------------------*/\n/*!\n * \\brief   pixReadFromMultipageTiff()\n *\n * \\param[in]      fname     filename\n * \\param[in,out]  poffset   set offset to 0 for first image\n * \\return  pix, or NULL on error or if previous call returned the last image\n *\n * <pre>\n * Notes:\n *      (1) This allows overhead for traversal of a multipage tiff file\n *          to be linear in the number of images.  This will also work\n *          with a singlepage tiff file.\n *      (2) No TIFF internal data structures are exposed to the caller\n *          (thanks to Jeff Breidenbach).\n *      (3) offset is the byte offset of a particular image in a multipage\n *          tiff file. To get the first image in the file, input the\n *          special offset value of 0.\n *      (4) The offset is updated to point to the next image, for a\n *          subsequent call.\n *      (5) On the last image, the offset returned is 0.  Exit the loop\n *          when the returned offset is 0.\n *      (6) For reading a multipage tiff from a memory buffer, see\n *            pixReadMemFromMultipageTiff()\n *      (7) Example usage for reading all the images in the tif file:\n *            size_t offset = 0;\n *            do {\n *                Pix *pix = pixReadFromMultipageTiff(filename, &offset);\n *                // do something with pix\n *            } while (offset != 0);\n * </pre>\n */\nPIX *\npixReadFromMultipageTiff(const char  *fname,\n                         size_t      *poffset)\n{\nl_int32  retval;\nsize_t   offset;\nPIX     *pix;\nTIFF    *tif;\n\n    PROCNAME(\"pixReadFromMultipageTiff\");\n\n    if (!fname)\n        return (PIX *)ERROR_PTR(\"fname not defined\", procName, NULL);\n    if (!poffset)\n        return (PIX *)ERROR_PTR(\"&offset not defined\", procName, NULL);\n\n    if ((tif = openTiff(fname, \"r\")) == NULL) {\n        L_ERROR(\"tif open failed for %s\\n\", procName, fname);\n        return NULL;\n    }\n\n        /* Set ptrs in the TIFF to the beginning of the image */\n    offset = *poffset;\n    retval = (offset == 0) ? TIFFSetDirectory(tif, 0)\n                            : TIFFSetSubDirectory(tif, offset);\n    if (retval == 0) {\n        TIFFCleanup(tif);\n        return NULL;\n    }\n\n    if ((pix = pixReadFromTiffStream(tif)) == NULL) {\n        TIFFCleanup(tif);\n        return NULL;\n    }\n\n        /* Advance to the next image and return the new offset */\n    TIFFReadDirectory(tif);\n    *poffset = TIFFCurrentDirOffset(tif);\n    TIFFClose(tif);\n    return pix;\n}\n\n\n/*!\n * \\brief   pixaReadMultipageTiff()\n *\n * \\param[in]    filename    input tiff file\n * \\return  pixa of page images, or NULL on error\n */\nPIXA *\npixaReadMultipageTiff(const char  *filename)\n{\nl_int32  i, npages;\nFILE    *fp;\nPIX     *pix;\nPIXA    *pixa;\nTIFF    *tif;\n\n    PROCNAME(\"pixaReadMultipageTiff\");\n\n    if (!filename)\n        return (PIXA *)ERROR_PTR(\"filename not defined\", procName, NULL);\n\n    if ((fp = fopenReadStream(filename)) == NULL)\n        return (PIXA *)ERROR_PTR(\"stream not opened\", procName, NULL);\n    if (fileFormatIsTiff(fp)) {\n        tiffGetCount(fp, &npages);\n        L_INFO(\" Tiff: %d pages\\n\", procName, npages);\n    } else {\n        return (PIXA *)ERROR_PTR(\"file not tiff\", procName, NULL);\n    }\n\n    if ((tif = fopenTiff(fp, \"r\")) == NULL)\n        return (PIXA *)ERROR_PTR(\"tif not opened\", procName, NULL);\n\n    pixa = pixaCreate(npages);\n    pix = NULL;\n    for (i = 0; i < npages; i++) {\n        if ((pix = pixReadFromTiffStream(tif)) != NULL) {\n            pixaAddPix(pixa, pix, L_INSERT);\n        } else {\n            L_WARNING(\"pix not read for page %d\\n\", procName, i);\n        }\n\n            /* Advance to the next directory (i.e., the next image) */\n        if (TIFFReadDirectory(tif) == 0)\n            break;\n    }\n\n    fclose(fp);\n    TIFFCleanup(tif);\n    return pixa;\n}\n\n\n/*!\n * \\brief   pixaWriteMultipageTiff()\n *\n * \\param[in]    fname      input tiff file\n * \\param[in]    pixa       any depth; colormap will be removed\n * \\return  0 if OK, 1 on error\n *\n * <pre>\n * Notes:\n *      (1) The tiff directory overhead is O(n^2).  I have not been\n *          able to reduce it to O(n).  The overhead for n = 2000 is\n *          about 1 second.\n * </pre>\n */\nl_ok\npixaWriteMultipageTiff(const char  *fname,\n                       PIXA        *pixa)\n{\nconst char  *modestr;\nl_int32      i, n;\nPIX         *pix1;\n\n    PROCNAME(\"pixaWriteMultipageTiff\");\n\n    if (!fname)\n        return ERROR_INT(\"fname not defined\", procName, 1);\n    if (!pixa)\n        return ERROR_INT(\"pixa not defined\", procName, 1);\n\n    n = pixaGetCount(pixa);\n    for (i = 0; i < n; i++) {\n        modestr = (i == 0) ? \"w\" : \"a\";\n        pix1 = pixaGetPix(pixa, i, L_CLONE);\n        if (pixGetDepth(pix1) == 1)\n            pixWriteTiff(fname, pix1, IFF_TIFF_G4, modestr);\n        else\n            pixWriteTiff(fname, pix1, IFF_TIFF_ZIP, modestr);\n        pixDestroy(&pix1);\n    }\n\n    return 0;\n}\n\n\n/*!\n * \\brief   writeMultipageTiff()\n *\n * \\param[in]    dirin   input directory\n * \\param[in]    substr  [optional] substring filter on filenames; can be NULL\n * \\param[in]    fileout output multipage tiff file\n * \\return  0 if OK, 1 on error\n *\n * <pre>\n * Notes:\n *      (1) This writes a set of image files in a directory out\n *          as a multipage tiff file.  The images can be in any\n *          initial file format.\n *      (2) Images with a colormap have the colormap removed before\n *          re-encoding as tiff.\n *      (3) All images are encoded losslessly.  Those with 1 bpp are\n *          encoded 'g4'.  The rest are encoded as 'zip' (flate encoding).\n *          Because it is lossless, this is an expensive method for\n *          saving most rgb images.\n *      (4) The tiff directory overhead is quadratic in the number of\n *          images.  To avoid this for very large numbers of images to be\n *          written, apply the method used in pixaWriteMultipageTiff().\n * </pre>\n */\nl_ok\nwriteMultipageTiff(const char  *dirin,\n                   const char  *substr,\n                   const char  *fileout)\n{\nSARRAY  *sa;\n\n    PROCNAME(\"writeMultipageTiff\");\n\n    if (!dirin)\n        return ERROR_INT(\"dirin not defined\", procName, 1);\n    if (!fileout)\n        return ERROR_INT(\"fileout not defined\", procName, 1);\n\n        /* Get all filtered and sorted full pathnames. */\n    sa = getSortedPathnamesInDirectory(dirin, substr, 0, 0);\n\n        /* Generate the tiff file */\n    writeMultipageTiffSA(sa, fileout);\n    sarrayDestroy(&sa);\n    return 0;\n}\n\n\n/*!\n * \\brief   writeMultipageTiffSA()\n *\n * \\param[in]    sa       string array of full path names\n * \\param[in]    fileout  output ps file\n * \\return  0 if OK, 1 on error\n *\n * <pre>\n * Notes:\n *      (1) See writeMultipageTiff()\n * </pre>\n */\nl_ok\nwriteMultipageTiffSA(SARRAY      *sa,\n                     const char  *fileout)\n{\nchar        *fname;\nconst char  *op;\nl_int32      i, nfiles, firstfile, format;\nPIX         *pix;\n\n    PROCNAME(\"writeMultipageTiffSA\");\n\n    if (!sa)\n        return ERROR_INT(\"sa not defined\", procName, 1);\n    if (!fileout)\n        return ERROR_INT(\"fileout not defined\", procName, 1);\n\n    nfiles = sarrayGetCount(sa);\n    firstfile = TRUE;\n    for (i = 0; i < nfiles; i++) {\n        op = (firstfile) ? \"w\" : \"a\";\n        fname = sarrayGetString(sa, i, L_NOCOPY);\n        findFileFormat(fname, &format);\n        if (format == IFF_UNKNOWN) {\n            L_INFO(\"format of %s not known\\n\", procName, fname);\n            continue;\n        }\n\n        if ((pix = pixRead(fname)) == NULL) {\n            L_WARNING(\"pix not made for file: %s\\n\", procName, fname);\n            continue;\n        }\n        if (pixGetDepth(pix) == 1)\n            pixWriteTiff(fileout, pix, IFF_TIFF_G4, op);\n        else\n            pixWriteTiff(fileout, pix, IFF_TIFF_ZIP, op);\n        firstfile = FALSE;\n        pixDestroy(&pix);\n    }\n\n    return 0;\n}\n\n\n/*--------------------------------------------------------------*\n *                    Print info to stream                      *\n *--------------------------------------------------------------*/\n/*!\n * \\brief   fprintTiffInfo()\n *\n * \\param[in]    fpout    stream for output of tag data\n * \\param[in]    tiffile  input\n * \\return  0 if OK; 1 on error\n */\nl_ok\nfprintTiffInfo(FILE        *fpout,\n               const char  *tiffile)\n{\nTIFF  *tif;\n\n    PROCNAME(\"fprintTiffInfo\");\n\n    if (!tiffile)\n        return ERROR_INT(\"tiffile not defined\", procName, 1);\n    if (!fpout)\n        return ERROR_INT(\"stream out not defined\", procName, 1);\n\n    if ((tif = openTiff(tiffile, \"rb\")) == NULL)\n        return ERROR_INT(\"tif not open for read\", procName, 1);\n\n    TIFFPrintDirectory(tif, fpout, 0);\n    TIFFClose(tif);\n\n    return 0;\n}\n\n\n/*--------------------------------------------------------------*\n *                        Get page count                        *\n *--------------------------------------------------------------*/\n/*!\n * \\brief   tiffGetCount()\n *\n * \\param[in]    fp   file stream opened for read\n * \\param[out]   pn   number of images\n * \\return  0 if OK; 1 on error\n */\nl_ok\ntiffGetCount(FILE     *fp,\n             l_int32  *pn)\n{\nl_int32  i;\nTIFF    *tif;\n\n    PROCNAME(\"tiffGetCount\");\n\n    if (!fp)\n        return ERROR_INT(\"stream not defined\", procName, 1);\n    if (!pn)\n        return ERROR_INT(\"&n not defined\", procName, 1);\n    *pn = 0;\n\n    if ((tif = fopenTiff(fp, \"r\")) == NULL)\n        return ERROR_INT(\"tif not open for read\", procName, 1);\n\n    for (i = 1; ; i++) {\n        if (TIFFReadDirectory(tif) == 0)\n            break;\n        if (i == ManyPagesInTiffFile + 1) {\n            L_WARNING(\"big file: more than %d pages\\n\", procName,\n                      ManyPagesInTiffFile);\n        }\n    }\n    *pn = i;\n    TIFFCleanup(tif);\n    return 0;\n}\n\n\n/*--------------------------------------------------------------*\n *                   Get resolution from tif                    *\n *--------------------------------------------------------------*/\n/*!\n * \\brief   getTiffResolution()\n *\n * \\param[in]    fp            file stream opened for read\n * \\param[out]   pxres, pyres  resolution in ppi\n * \\return  0 if OK; 1 on error\n *\n * <pre>\n * Notes:\n *      (1) If neither resolution field is set, this is not an error;\n *          the returned resolution values are 0 (designating 'unknown').\n * </pre>\n */\nl_ok\ngetTiffResolution(FILE     *fp,\n                  l_int32  *pxres,\n                  l_int32  *pyres)\n{\nTIFF  *tif;\n\n    PROCNAME(\"getTiffResolution\");\n\n    if (!pxres || !pyres)\n        return ERROR_INT(\"&xres and &yres not both defined\", procName, 1);\n    *pxres = *pyres = 0;\n    if (!fp)\n        return ERROR_INT(\"stream not opened\", procName, 1);\n\n    if ((tif = fopenTiff(fp, \"r\")) == NULL)\n        return ERROR_INT(\"tif not open for read\", procName, 1);\n    getTiffStreamResolution(tif, pxres, pyres);\n    TIFFCleanup(tif);\n    return 0;\n}\n\n\n/*!\n * \\brief   getTiffStreamResolution()\n *\n * \\param[in]    tif            TIFF handle opened for read\n * \\param[out]   pxres, pyres   resolution in ppi\n * \\return  0 if OK; 1 on error\n *\n * <pre>\n * Notes:\n *      (1) If neither resolution field is set, this is not an error;\n *          the returned resolution values are 0 (designating 'unknown').\n * </pre>\n */\nstatic l_int32\ngetTiffStreamResolution(TIFF     *tif,\n                        l_int32  *pxres,\n                        l_int32  *pyres)\n{\nl_uint16   resunit;\nl_int32    foundxres, foundyres;\nl_float32  fxres, fyres;\n\n    PROCNAME(\"getTiffStreamResolution\");\n\n    if (!tif)\n        return ERROR_INT(\"tif not opened\", procName, 1);\n    if (!pxres || !pyres)\n        return ERROR_INT(\"&xres and &yres not both defined\", procName, 1);\n    *pxres = *pyres = 0;\n\n    TIFFGetFieldDefaulted(tif, TIFFTAG_RESOLUTIONUNIT, &resunit);\n    foundxres = TIFFGetField(tif, TIFFTAG_XRESOLUTION, &fxres);\n    foundyres = TIFFGetField(tif, TIFFTAG_YRESOLUTION, &fyres);\n    if (!foundxres && !foundyres) return 1;\n    if (isnan(fxres) || isnan(fyres)) return 1;\n    if (!foundxres && foundyres)\n        fxres = fyres;\n    else if (foundxres && !foundyres)\n        fyres = fxres;\n\n        /* Avoid overflow into int32; set max fxres and fyres to 5 x 10^8 */\n    if (fxres < 0 || fxres > (1L << 29) || fyres < 0 || fyres > (1L << 29))\n        return ERROR_INT(\"fxres and/or fyres values are invalid\", procName, 1);\n\n    if (resunit == RESUNIT_CENTIMETER) {  /* convert to ppi */\n        *pxres = (l_int32)(2.54 * fxres + 0.5);\n        *pyres = (l_int32)(2.54 * fyres + 0.5);\n    } else {\n        *pxres = (l_int32)fxres;\n        *pyres = (l_int32)fyres;\n    }\n\n    return 0;\n}\n\n\n/*--------------------------------------------------------------*\n *              Get some tiff header information                *\n *--------------------------------------------------------------*/\n/*!\n * \\brief   readHeaderTiff()\n *\n * \\param[in]    filename\n * \\param[in]    n          page image number: 0-based\n * \\param[out]   pw         [optional] width\n * \\param[out]   ph         [optional] height\n * \\param[out]   pbps       [optional] bits per sample -- 1, 2, 4 or 8\n * \\param[out]   pspp       [optional] samples per pixel -- 1 or 3\n * \\param[out]   pres       [optional] resolution in x dir; NULL to ignore\n * \\param[out]   pcmap      [optional] colormap exists; input NULL to ignore\n * \\param[out]   pformat    [optional] tiff format; input NULL to ignore\n * \\return  0 if OK, 1 on error\n *\n * <pre>\n * Notes:\n *      (1) If there is a colormap, cmap is returned as 1; else 0.\n *      (2) If %n is equal to or greater than the number of images, returns 1.\n * </pre>\n */\nl_ok\nreadHeaderTiff(const char *filename,\n               l_int32     n,\n               l_int32    *pw,\n               l_int32    *ph,\n               l_int32    *pbps,\n               l_int32    *pspp,\n               l_int32    *pres,\n               l_int32    *pcmap,\n               l_int32    *pformat)\n{\nl_int32  ret;\nFILE    *fp;\n\n    PROCNAME(\"readHeaderTiff\");\n\n    if (pw) *pw = 0;\n    if (ph) *ph = 0;\n    if (pbps) *pbps = 0;\n    if (pspp) *pspp = 0;\n    if (pres) *pres = 0;\n    if (pcmap) *pcmap = 0;\n    if (pformat) *pformat = 0;\n    if (!filename)\n        return ERROR_INT(\"filename not defined\", procName, 1);\n    if (!pw && !ph && !pbps && !pspp && !pres && !pcmap && !pformat)\n        return ERROR_INT(\"no results requested\", procName, 1);\n\n    if ((fp = fopenReadStream(filename)) == NULL)\n        return ERROR_INT(\"image file not found\", procName, 1);\n    ret = freadHeaderTiff(fp, n, pw, ph, pbps, pspp, pres, pcmap, pformat);\n    fclose(fp);\n    return ret;\n}\n\n\n/*!\n * \\brief   freadHeaderTiff()\n *\n * \\param[in]    fp       file stream\n * \\param[in]    n        page image number: 0-based\n * \\param[out]   pw       [optional] width\n * \\param[out]   ph       [optional] height\n * \\param[out]   pbps     [optional] bits per sample -- 1, 2, 4 or 8\n * \\param[out]   pspp     [optional] samples per pixel -- 1 or 3\n * \\param[out]   pres     [optional] resolution in x dir; NULL to ignore\n * \\param[out]   pcmap    [optional] colormap exists; input NULL to ignore\n * \\param[out]   pformat  [optional] tiff format; input NULL to ignore\n * \\return  0 if OK, 1 on error\n *\n * <pre>\n * Notes:\n *      (1) If there is a colormap, cmap is returned as 1; else 0.\n *      (2) If %n is equal to or greater than the number of images, returns 1.\n * </pre>\n */\nl_ok\nfreadHeaderTiff(FILE     *fp,\n                l_int32   n,\n                l_int32  *pw,\n                l_int32  *ph,\n                l_int32  *pbps,\n                l_int32  *pspp,\n                l_int32  *pres,\n                l_int32  *pcmap,\n                l_int32  *pformat)\n{\nl_int32  i, ret, format;\nTIFF    *tif;\n\n    PROCNAME(\"freadHeaderTiff\");\n\n    if (pw) *pw = 0;\n    if (ph) *ph = 0;\n    if (pbps) *pbps = 0;\n    if (pspp) *pspp = 0;\n    if (pres) *pres = 0;\n    if (pcmap) *pcmap = 0;\n    if (pformat) *pformat = 0;\n    if (!fp)\n        return ERROR_INT(\"stream not defined\", procName, 1);\n    if (n < 0)\n        return ERROR_INT(\"image index must be >= 0\", procName, 1);\n    if (!pw && !ph && !pbps && !pspp && !pres && !pcmap && !pformat)\n        return ERROR_INT(\"no results requested\", procName, 1);\n\n    findFileFormatStream(fp, &format);\n    if (!L_FORMAT_IS_TIFF(format))\n        return ERROR_INT(\"file not tiff format\", procName, 1);\n\n    if ((tif = fopenTiff(fp, \"r\")) == NULL)\n        return ERROR_INT(\"tif not open for read\", procName, 1);\n\n    for (i = 0; i < n; i++) {\n        if (TIFFReadDirectory(tif) == 0)\n            return ERROR_INT(\"image n not found in file\", procName, 1);\n    }\n\n    ret = tiffReadHeaderTiff(tif, pw, ph, pbps, pspp, pres, pcmap, pformat);\n    TIFFCleanup(tif);\n    return ret;\n}\n\n\n/*!\n * \\brief   readHeaderMemTiff()\n *\n * \\param[in]    cdata     const; tiff-encoded\n * \\param[in]    size      size of data\n * \\param[in]    n         page image number: 0-based\n * \\param[out]   pw        [optional] width\n * \\param[out]   ph        [optional] height\n * \\param[out]   pbps      [optional] bits per sample -- 1, 2, 4 or 8\n * \\param[out]   pspp      [optional] samples per pixel -- 1 or 3\n * \\param[out]   pres      [optional] resolution in x dir; NULL to ignore\n * \\param[out]   pcmap     [optional] colormap exists; input NULL to ignore\n * \\param[out]   pformat   [optional] tiff format; input NULL to ignore\n * \\return  0 if OK, 1 on error\n *\n * <pre>\n * Notes:\n *      (1) Use TIFFClose(); TIFFCleanup() doesn't free internal memstream.\n * </pre>\n */\nl_ok\nreadHeaderMemTiff(const l_uint8  *cdata,\n                  size_t          size,\n                  l_int32         n,\n                  l_int32        *pw,\n                  l_int32        *ph,\n                  l_int32        *pbps,\n                  l_int32        *pspp,\n                  l_int32        *pres,\n                  l_int32        *pcmap,\n                  l_int32        *pformat)\n{\nl_uint8  *data;\nl_int32   i, ret;\nTIFF     *tif;\n\n    PROCNAME(\"readHeaderMemTiff\");\n\n    if (pw) *pw = 0;\n    if (ph) *ph = 0;\n    if (pbps) *pbps = 0;\n    if (pspp) *pspp = 0;\n    if (pres) *pres = 0;\n    if (pcmap) *pcmap = 0;\n    if (pformat) *pformat = 0;\n    if (!pw && !ph && !pbps && !pspp && !pres && !pcmap && !pformat)\n        return ERROR_INT(\"no results requested\", procName, 1);\n    if (!cdata)\n        return ERROR_INT(\"cdata not defined\", procName, 1);\n\n        /* Open a tiff stream to memory */\n    data = (l_uint8 *)cdata;  /* we're really not going to change this */\n    if ((tif = fopenTiffMemstream(\"tifferror\", \"r\", &data, &size)) == NULL)\n        return ERROR_INT(\"tiff stream not opened\", procName, 1);\n\n    for (i = 0; i < n; i++) {\n        if (TIFFReadDirectory(tif) == 0) {\n            TIFFClose(tif);\n            return ERROR_INT(\"image n not found in file\", procName, 1);\n        }\n    }\n\n    ret = tiffReadHeaderTiff(tif, pw, ph, pbps, pspp, pres, pcmap, pformat);\n    TIFFClose(tif);\n    return ret;\n}\n\n\n/*!\n * \\brief   tiffReadHeaderTiff()\n *\n * \\param[in]    tif\n * \\param[out]   pw        [optional] width\n * \\param[out]   ph        [optional] height\n * \\param[out]   pbps      [optional] bits per sample -- 1, 2, 4 or 8\n * \\param[out]   pspp      [optional] samples per pixel -- 1 or 3\n * \\param[out]   pres      [optional] resolution in x dir; NULL to ignore\n * \\param[out]   pcmap     [optional] cmap exists; input NULL to ignore\n * \\param[out]   pformat   [optional] tiff format; input NULL to ignore\n * \\return  0 if OK, 1 on error\n */\nstatic l_int32\ntiffReadHeaderTiff(TIFF     *tif,\n                   l_int32  *pw,\n                   l_int32  *ph,\n                   l_int32  *pbps,\n                   l_int32  *pspp,\n                   l_int32  *pres,\n                   l_int32  *pcmap,\n                   l_int32  *pformat)\n{\nl_uint16   tiffcomp;\nl_uint16   bps, spp;\nl_uint16  *rmap, *gmap, *bmap;\nl_int32    xres, yres;\nl_uint32   w, h;\n\n    PROCNAME(\"tiffReadHeaderTiff\");\n\n    if (!tif)\n        return ERROR_INT(\"tif not opened\", procName, 1);\n\n    TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &w);\n    TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &h);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_BITSPERSAMPLE, &bps);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_SAMPLESPERPIXEL, &spp);\n    if (w < 1 || h < 1)\n        return ERROR_INT(\"tif w and h not both > 0\", procName, 1);\n    if (bps != 1 && bps != 2 && bps != 4 && bps != 8 && bps != 16)\n        return ERROR_INT(\"bps not in set {1,2,4,8,16}\", procName, 1);\n    if (spp != 1 && spp != 2 && spp != 3 && spp != 4)\n        return ERROR_INT(\"spp not in set {1,2,3,4}\", procName, 1);\n    if (pw) *pw = w;\n    if (ph) *ph = h;\n    if (pbps) *pbps = bps;\n    if (pspp) *pspp = spp;\n    if (pres) {\n        *pres = 300;  /* default ppi */\n        if (getTiffStreamResolution(tif, &xres, &yres) == 0)\n            *pres = (l_int32)xres;\n    }\n    if (pcmap) {\n        *pcmap = 0;\n        if (TIFFGetField(tif, TIFFTAG_COLORMAP, &rmap, &gmap, &bmap))\n            *pcmap = 1;\n    }\n    if (pformat) {\n        TIFFGetFieldDefaulted(tif, TIFFTAG_COMPRESSION, &tiffcomp);\n        *pformat = getTiffCompressedFormat(tiffcomp);\n    }\n    return 0;\n}\n\n\n/*!\n * \\brief   findTiffCompression()\n *\n * \\param[in]    fp         file stream; must be rewound to BOF\n * \\param[out]   pcomptype  compression type\n * \\return  0 if OK, 1 on error\n *\n * <pre>\n * Notes:\n *      (1) The returned compression type is that defined in\n *          the enum in imageio.h.  It is not the tiff flag value.\n *      (2) The compression type is initialized to IFF_UNKNOWN.\n *          If it is not one of the specified types, the returned\n *          type is IFF_TIFF, which indicates no compression.\n *      (3) When this function is called, the stream must be at BOF.\n *          If the opened stream is to be used again to read the\n *          file, it must be rewound to BOF after calling this function.\n * </pre>\n */\nl_ok\nfindTiffCompression(FILE     *fp,\n                    l_int32  *pcomptype)\n{\nl_uint16  tiffcomp;\nTIFF     *tif;\n\n    PROCNAME(\"findTiffCompression\");\n\n    if (!pcomptype)\n        return ERROR_INT(\"&comptype not defined\", procName, 1);\n    *pcomptype = IFF_UNKNOWN;  /* init */\n    if (!fp)\n        return ERROR_INT(\"stream not defined\", procName, 1);\n\n    if ((tif = fopenTiff(fp, \"r\")) == NULL)\n        return ERROR_INT(\"tif not opened\", procName, 1);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_COMPRESSION, &tiffcomp);\n    *pcomptype = getTiffCompressedFormat(tiffcomp);\n    TIFFCleanup(tif);\n    return 0;\n}\n\n\n/*!\n * \\brief   getTiffCompressedFormat()\n *\n * \\param[in]    tiffcomp    defined in tiff.h\n * \\return  compression format defined in imageio.h\n *\n * <pre>\n * Notes:\n *      (1) The input must be the actual tiff compression type\n *          returned by a tiff library call.  It should always be\n *          a valid tiff type.\n *      (2) The return type is defined in the enum in imageio.h.\n * </pre>\n */\nstatic l_int32\ngetTiffCompressedFormat(l_uint16  tiffcomp)\n{\nl_int32  comptype;\n\n    switch (tiffcomp)\n    {\n    case COMPRESSION_CCITTFAX4:\n        comptype = IFF_TIFF_G4;\n        break;\n    case COMPRESSION_CCITTFAX3:\n        comptype = IFF_TIFF_G3;\n        break;\n    case COMPRESSION_CCITTRLE:\n        comptype = IFF_TIFF_RLE;\n        break;\n    case COMPRESSION_PACKBITS:\n        comptype = IFF_TIFF_PACKBITS;\n        break;\n    case COMPRESSION_LZW:\n        comptype = IFF_TIFF_LZW;\n        break;\n    case COMPRESSION_ADOBE_DEFLATE:\n        comptype = IFF_TIFF_ZIP;\n        break;\n    case COMPRESSION_JPEG:\n        comptype = IFF_TIFF_JPEG;\n        break;\n    default:\n        comptype = IFF_TIFF;\n        break;\n    }\n    return comptype;\n}\n\n\n/*--------------------------------------------------------------*\n *                   Extraction of tiff g4 data                 *\n *--------------------------------------------------------------*/\n/*!\n * \\brief   extractG4DataFromFile()\n *\n * \\param[in]    filein\n * \\param[out]   pdata         binary data of ccitt g4 encoded stream\n * \\param[out]   pnbytes       size of binary data\n * \\param[out]   pw            [optional] image width\n * \\param[out]   ph            [optional] image height\n * \\param[out]   pminisblack   [optional] boolean\n * \\return  0 if OK, 1 on error\n */\nl_ok\nextractG4DataFromFile(const char  *filein,\n                      l_uint8    **pdata,\n                      size_t      *pnbytes,\n                      l_int32     *pw,\n                      l_int32     *ph,\n                      l_int32     *pminisblack)\n{\nl_uint8  *inarray, *data;\nl_uint16  minisblack, comptype;  /* accessors require l_uint16 */\nl_int32   istiff;\nl_uint32  w, h, rowsperstrip;  /* accessors require l_uint32 */\nl_uint32  diroff;\nsize_t    fbytes, nbytes;\nFILE     *fpin;\nTIFF     *tif;\n\n    PROCNAME(\"extractG4DataFromFile\");\n\n    if (!pdata)\n        return ERROR_INT(\"&data not defined\", procName, 1);\n    if (!pnbytes)\n        return ERROR_INT(\"&nbytes not defined\", procName, 1);\n    if (!pw && !ph && !pminisblack)\n        return ERROR_INT(\"no output data requested\", procName, 1);\n    *pdata = NULL;\n    *pnbytes = 0;\n\n    if ((fpin = fopenReadStream(filein)) == NULL)\n        return ERROR_INT(\"stream not opened to file\", procName, 1);\n    istiff = fileFormatIsTiff(fpin);\n    fclose(fpin);\n    if (!istiff)\n        return ERROR_INT(\"filein not tiff\", procName, 1);\n\n    if ((inarray = l_binaryRead(filein, &fbytes)) == NULL)\n        return ERROR_INT(\"inarray not made\", procName, 1);\n\n        /* Get metadata about the image */\n    if ((tif = openTiff(filein, \"rb\")) == NULL) {\n        LEPT_FREE(inarray);\n        return ERROR_INT(\"tif not open for read\", procName, 1);\n    }\n    TIFFGetField(tif, TIFFTAG_COMPRESSION, &comptype);\n    if (comptype != COMPRESSION_CCITTFAX4) {\n        LEPT_FREE(inarray);\n        TIFFClose(tif);\n        return ERROR_INT(\"filein is not g4 compressed\", procName, 1);\n    }\n\n    TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &w);\n    TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &h);\n    TIFFGetField(tif, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);\n    if (h != rowsperstrip)\n        L_WARNING(\"more than 1 strip\\n\", procName);\n    TIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &minisblack);  /* for 1 bpp */\n/*    TIFFPrintDirectory(tif, stderr, 0); */\n    TIFFClose(tif);\n    if (pw) *pw = (l_int32)w;\n    if (ph) *ph = (l_int32)h;\n    if (pminisblack) *pminisblack = (l_int32)minisblack;\n\n        /* The header has 8 bytes: the first 2 are the magic number,\n         * the next 2 are the version, and the last 4 are the\n         * offset to the first directory.  That's what we want here.\n         * We have to test the byte order before decoding 4 bytes! */\n    if (inarray[0] == 0x4d) {  /* big-endian */\n        diroff = (inarray[4] << 24) | (inarray[5] << 16) |\n                 (inarray[6] << 8) | inarray[7];\n    } else  {   /* inarray[0] == 0x49 :  little-endian */\n        diroff = (inarray[7] << 24) | (inarray[6] << 16) |\n                 (inarray[5] << 8) | inarray[4];\n    }\n/*    lept_stderr(\" diroff = %d, %x\\n\", diroff, diroff); */\n\n        /* Extract the ccittg4 encoded data from the tiff file.\n         * We skip the 8 byte header and take nbytes of data,\n         * up to the beginning of the directory (at diroff)  */\n    nbytes = diroff - 8;\n    *pnbytes = nbytes;\n    if ((data = (l_uint8 *)LEPT_CALLOC(nbytes, sizeof(l_uint8))) == NULL) {\n        LEPT_FREE(inarray);\n        return ERROR_INT(\"data not allocated\", procName, 1);\n    }\n    *pdata = data;\n    memcpy(data, inarray + 8, nbytes);\n    LEPT_FREE(inarray);\n\n    return 0;\n}\n\n\n/*--------------------------------------------------------------*\n *               Open tiff stream from file stream              *\n *--------------------------------------------------------------*/\n/*!\n * \\brief   fopenTiff()\n *\n * \\param[in]    fp           file stream\n * \\param[in]    modestring   \"r\", \"w\", ...\n * \\return  tiff data structure, opened for a file descriptor\n *\n * <pre>\n * Notes:\n *      (1) Why is this here?  Leffler did not provide a function that\n *          takes a stream and gives a TIFF.  He only gave one that\n *          generates a TIFF starting with a file descriptor.  So we\n *          need to make it here, because it is useful to have functions\n *          that take a stream as input.\n *      (2) We use TIFFClientOpen() together with a set of static wrapper\n *          functions which map TIFF read, write, seek, close and size.\n *          to functions expecting a cookie of type stream (i.e. FILE *).\n *          This implementation was contributed by J\u00fcrgen Buchm\u00fcller.\n * </pre>\n */\nstatic TIFF *\nfopenTiff(FILE        *fp,\n          const char  *modestring)\n{\n    PROCNAME(\"fopenTiff\");\n\n    if (!fp)\n        return (TIFF *)ERROR_PTR(\"stream not opened\", procName, NULL);\n    if (!modestring)\n        return (TIFF *)ERROR_PTR(\"modestring not defined\", procName, NULL);\n\n    TIFFSetWarningHandler(NULL);  /* disable warnings */\n    TIFFSetErrorHandler(NULL);  /* disable error messages */\n\n    fseek(fp, 0, SEEK_SET);\n    return TIFFClientOpen(\"TIFFstream\", modestring, (thandle_t)fp,\n                          lept_read_proc, lept_write_proc, lept_seek_proc,\n                          lept_close_proc, lept_size_proc, NULL, NULL);\n}\n\n\n/*--------------------------------------------------------------*\n *                      Wrapper for TIFFOpen                    *\n *--------------------------------------------------------------*/\n/*!\n * \\brief   openTiff()\n *\n * \\param[in]    filename\n * \\param[in]    modestring   \"r\", \"w\", ...\n * \\return  tiff data structure\n *\n * <pre>\n * Notes:\n *      (1) This handles multi-platform file naming.\n * </pre>\n */\nstatic TIFF *\nopenTiff(const char  *filename,\n         const char  *modestring)\n{\nchar  *fname;\nTIFF  *tif;\n\n    PROCNAME(\"openTiff\");\n\n    if (!filename)\n        return (TIFF *)ERROR_PTR(\"filename not defined\", procName, NULL);\n    if (!modestring)\n        return (TIFF *)ERROR_PTR(\"modestring not defined\", procName, NULL);\n\n    TIFFSetWarningHandler(NULL);  /* disable warnings */\n    TIFFSetErrorHandler(NULL);  /* disable error messages */\n\n    fname = genPathname(filename, NULL);\n    tif = TIFFOpen(fname, modestring);\n    LEPT_FREE(fname);\n    return tif;\n}\n\n\n/*----------------------------------------------------------------------*\n *     Memory I/O: reading memory --> pix and writing pix --> memory    *\n *----------------------------------------------------------------------*/\n/*  It would be nice to use open_memstream() and fmemopen()\n *  for writing and reading to memory, rsp.  These functions manage\n *  memory for writes and reads that use a file streams interface.\n *  Unfortunately, the tiff library only has an interface for reading\n *  and writing to file descriptors, not to file streams.  The tiff\n *  library procedure is to open a \"tiff stream\" and read/write to it.\n *  The library provides a client interface for managing the I/O\n *  from memory, which requires seven callbacks.  See the TIFFClientOpen\n *  man page for callback signatures.  Adam Langley provided the code\n *  to do this.  */\n\n/*!\n * \\brief   Memory stream buffer used with TIFFClientOpen()\n *\n *  The L_Memstram %buffer has different functions in writing and reading.\n *\n *     * In reading, it is assigned to the data and read from as\n *       the tiff library uncompresses the data and generates the pix.\n *       The %offset points to the current read position in the data,\n *       and the %hw always gives the number of bytes of data.\n *       The %outdata and %outsize ptrs are not used.\n *       When finished, tiffCloseCallback() simply frees the L_Memstream.\n *\n *     * In writing, it accepts the data that the tiff library\n *       produces when a pix is compressed.  the buffer points to a\n *       malloced area of %bufsize bytes.  The current writing position\n *       in the buffer is %offset and the most ever written is %hw.\n *       The buffer is expanded as necessary.  When finished,\n *       tiffCloseCallback() assigns the %outdata and %outsize ptrs\n *       to the %buffer and %bufsize results, and frees the L_Memstream.\n */\nstruct L_Memstream\n{\n    l_uint8   *buffer;    /* expands to hold data when written to;         */\n                          /* fixed size when read from.                    */\n    size_t     bufsize;   /* current size allocated when written to;       */\n                          /* fixed size of input data when read from.      */\n    size_t     offset;    /* byte offset from beginning of buffer.         */\n    size_t     hw;        /* high-water mark; max bytes in buffer.         */\n    l_uint8  **poutdata;  /* input param for writing; data goes here.      */\n    size_t    *poutsize;  /* input param for writing; data size goes here. */\n};\ntypedef struct L_Memstream  L_MEMSTREAM;\n\n\n    /* These are static functions for memory I/O */\nstatic L_MEMSTREAM *memstreamCreateForRead(l_uint8 *indata, size_t pinsize);\nstatic L_MEMSTREAM *memstreamCreateForWrite(l_uint8 **poutdata,\n                                            size_t *poutsize);\nstatic tsize_t tiffReadCallback(thandle_t handle, tdata_t data, tsize_t length);\nstatic tsize_t tiffWriteCallback(thandle_t handle, tdata_t data,\n                                 tsize_t length);\nstatic toff_t tiffSeekCallback(thandle_t handle, toff_t offset, l_int32 whence);\nstatic l_int32 tiffCloseCallback(thandle_t handle);\nstatic toff_t tiffSizeCallback(thandle_t handle);\nstatic l_int32 tiffMapCallback(thandle_t handle, tdata_t *data, toff_t *length);\nstatic void tiffUnmapCallback(thandle_t handle, tdata_t data, toff_t length);\n\n\nstatic L_MEMSTREAM *\nmemstreamCreateForRead(l_uint8  *indata,\n                       size_t    insize)\n{\nL_MEMSTREAM  *mstream;\n\n    mstream = (L_MEMSTREAM *)LEPT_CALLOC(1, sizeof(L_MEMSTREAM));\n    mstream->buffer = indata;   /* handle to input data array */\n    mstream->bufsize = insize;  /* amount of input data */\n    mstream->hw = insize;       /* high-water mark fixed at input data size */\n    mstream->offset = 0;        /* offset always starts at 0 */\n    return mstream;\n}\n\n\nstatic L_MEMSTREAM *\nmemstreamCreateForWrite(l_uint8  **poutdata,\n                        size_t    *poutsize)\n{\nL_MEMSTREAM  *mstream;\n\n    mstream = (L_MEMSTREAM *)LEPT_CALLOC(1, sizeof(L_MEMSTREAM));\n    mstream->buffer = (l_uint8 *)LEPT_CALLOC(8 * 1024, 1);\n    mstream->bufsize = 8 * 1024;\n    mstream->poutdata = poutdata;  /* used only at end of write */\n    mstream->poutsize = poutsize;  /* ditto  */\n    mstream->hw = mstream->offset = 0;\n    return mstream;\n}\n\n\nstatic tsize_t\ntiffReadCallback(thandle_t  handle,\n                 tdata_t    data,\n                 tsize_t    length)\n{\nL_MEMSTREAM  *mstream;\nsize_t        amount;\n\n    mstream = (L_MEMSTREAM *)handle;\n    amount = L_MIN((size_t)length, mstream->hw - mstream->offset);\n\n        /* Fuzzed files can create this condition! */\n    if (mstream->offset + amount < amount ||  /* overflow */\n        mstream->offset + amount > mstream->hw) {\n        lept_stderr(\"Bad file: amount too big: %zu\\n\", amount);\n        return 0;\n    }\n\n    memcpy(data, mstream->buffer + mstream->offset, amount);\n    mstream->offset += amount;\n    return amount;\n}\n\n\nstatic tsize_t\ntiffWriteCallback(thandle_t  handle,\n                  tdata_t    data,\n                  tsize_t    length)\n{\nL_MEMSTREAM  *mstream;\nsize_t        newsize;\n\n        /* reallocNew() uses calloc to initialize the array.\n         * If malloc is used instead, for some of the encoding methods,\n         * not all the data in 'bufsize' bytes in the buffer will\n         * have been initialized by the end of the compression. */\n    mstream = (L_MEMSTREAM *)handle;\n    if (mstream->offset + length > mstream->bufsize) {\n        newsize = 2 * (mstream->offset + length);\n        mstream->buffer = (l_uint8 *)reallocNew((void **)&mstream->buffer,\n                                                mstream->hw, newsize);\n        mstream->bufsize = newsize;\n    }\n\n    memcpy(mstream->buffer + mstream->offset, data, length);\n    mstream->offset += length;\n    mstream->hw = L_MAX(mstream->offset, mstream->hw);\n    return length;\n}\n\n\nstatic toff_t\ntiffSeekCallback(thandle_t  handle,\n                 toff_t     offset,\n                 l_int32    whence)\n{\nL_MEMSTREAM  *mstream;\n\n    PROCNAME(\"tiffSeekCallback\");\n    mstream = (L_MEMSTREAM *)handle;\n    switch (whence) {\n        case SEEK_SET:\n/*            lept_stderr(\"seek_set: offset = %d\\n\", offset); */\n            if((size_t)offset != offset) {  /* size_t overflow on uint32 */\n                return (toff_t)ERROR_INT(\"too large offset value\", procName, 1);\n            }\n            mstream->offset = offset;\n            break;\n        case SEEK_CUR:\n/*            lept_stderr(\"seek_cur: offset = %d\\n\", offset); */\n            mstream->offset += offset;\n            break;\n        case SEEK_END:\n/*            lept_stderr(\"seek end: hw = %d, offset = %d\\n\",\n                    mstream->hw, offset); */\n            mstream->offset = mstream->hw - offset;  /* offset >= 0 */\n            break;\n        default:\n            return (toff_t)ERROR_INT(\"bad whence value\", procName,\n                                     mstream->offset);\n    }\n\n    return mstream->offset;\n}\n\n\nstatic l_int32\ntiffCloseCallback(thandle_t  handle)\n{\nL_MEMSTREAM  *mstream;\n\n    mstream = (L_MEMSTREAM *)handle;\n    if (mstream->poutdata) {   /* writing: save the output data */\n        *mstream->poutdata = mstream->buffer;\n        *mstream->poutsize = mstream->hw;\n    }\n    LEPT_FREE(mstream);  /* never free the buffer! */\n    return 0;\n}\n\n\nstatic toff_t\ntiffSizeCallback(thandle_t  handle)\n{\nL_MEMSTREAM  *mstream;\n\n    mstream = (L_MEMSTREAM *)handle;\n    return mstream->hw;\n}\n\n\nstatic l_int32\ntiffMapCallback(thandle_t  handle,\n                tdata_t   *data,\n                toff_t    *length)\n{\nL_MEMSTREAM  *mstream;\n\n    mstream = (L_MEMSTREAM *)handle;\n    *data = mstream->buffer;\n    *length = mstream->hw;\n    return 0;\n}\n\n\nstatic void\ntiffUnmapCallback(thandle_t  handle,\n                  tdata_t    data,\n                  toff_t     length)\n{\n    return;\n}\n\n\n/*!\n * \\brief   fopenTiffMemstream()\n *\n * \\param[in]    filename    for error output; can be \"\"\n * \\param[in]    operation   \"w\" for write, \"r\" for read\n * \\param[out]   pdata       written data\n * \\param[out]   pdatasize   size of written data\n * \\return  tiff data structure, opened for write to memory\n *\n * <pre>\n * Notes:\n *      (1) This wraps up a number of callbacks for either:\n *            * reading from tiff in memory buffer --> pix\n *            * writing from pix --> tiff in memory buffer\n *      (2) After use, the memstream is automatically destroyed when\n *          TIFFClose() is called.  TIFFCleanup() doesn't free the memstream.\n *      (3) This does not work in append mode, and in write mode it\n *          does not append.\n * </pre>\n */\nstatic TIFF *\nfopenTiffMemstream(const char  *filename,\n                   const char  *operation,\n                   l_uint8    **pdata,\n                   size_t      *pdatasize)\n{\nL_MEMSTREAM  *mstream;\nTIFF         *tif;\n\n    PROCNAME(\"fopenTiffMemstream\");\n\n    if (!filename)\n        return (TIFF *)ERROR_PTR(\"filename not defined\", procName, NULL);\n    if (!operation)\n        return (TIFF *)ERROR_PTR(\"operation not defined\", procName, NULL);\n    if (!pdata)\n        return (TIFF *)ERROR_PTR(\"&data not defined\", procName, NULL);\n    if (!pdatasize)\n        return (TIFF *)ERROR_PTR(\"&datasize not defined\", procName, NULL);\n    if (strcmp(operation, \"r\") && strcmp(operation, \"w\"))\n        return (TIFF *)ERROR_PTR(\"op not 'r' or 'w'\", procName, NULL);\n\n    if (!strcmp(operation, \"r\"))\n        mstream = memstreamCreateForRead(*pdata, *pdatasize);\n    else\n        mstream = memstreamCreateForWrite(pdata, pdatasize);\n\n    TIFFSetWarningHandler(NULL);  /* disable warnings */\n    TIFFSetErrorHandler(NULL);  /* disable error messages */\n\n    tif = TIFFClientOpen(filename, operation, (thandle_t)mstream,\n                         tiffReadCallback, tiffWriteCallback,\n                         tiffSeekCallback, tiffCloseCallback,\n                         tiffSizeCallback, tiffMapCallback,\n                         tiffUnmapCallback);\n    if (!tif)\n        LEPT_FREE(mstream);\n    return tif;\n}\n\n\n/*!\n * \\brief   pixReadMemTiff()\n *\n * \\param[in]    cdata    const; tiff-encoded\n * \\param[in]    size     size of cdata\n * \\param[in]    n        page image number: 0-based\n * \\return  pix, or NULL on error\n *\n * <pre>\n * Notes:\n *      (1) This is a version of pixReadTiff(), where the data is read\n *          from a memory buffer and uncompressed.\n *      (2) Use TIFFClose(); TIFFCleanup() doesn't free internal memstream.\n *      (3) No warning messages on failure, because of how multi-page\n *          TIFF reading works. You are supposed to keep trying until\n *          it stops working.\n *      (4) Tiff directory overhead is linear in the input page number.\n *          If reading many images, use pixReadMemFromMultipageTiff().\n * </pre>\n */\nPIX *\npixReadMemTiff(const l_uint8  *cdata,\n               size_t          size,\n               l_int32         n)\n{\nl_uint8  *data;\nl_int32   i;\nPIX      *pix;\nTIFF     *tif;\n\n    PROCNAME(\"pixReadMemTiff\");\n\n    if (!cdata)\n        return (PIX *)ERROR_PTR(\"cdata not defined\", procName, NULL);\n\n    data = (l_uint8 *)cdata;  /* we're really not going to change this */\n    if ((tif = fopenTiffMemstream(\"tifferror\", \"r\", &data, &size)) == NULL)\n        return (PIX *)ERROR_PTR(\"tiff stream not opened\", procName, NULL);\n\n    pix = NULL;\n    for (i = 0; ; i++) {\n        if (i == n) {\n            if ((pix = pixReadFromTiffStream(tif)) == NULL) {\n                TIFFClose(tif);\n                return NULL;\n            }\n            pixSetInputFormat(pix, IFF_TIFF);\n            break;\n        }\n        if (TIFFReadDirectory(tif) == 0)\n            break;\n        if (i == ManyPagesInTiffFile + 1) {\n            L_WARNING(\"big file: more than %d pages\\n\", procName,\n                      ManyPagesInTiffFile);\n        }\n    }\n\n    TIFFClose(tif);\n    return pix;\n}\n\n\n/*!\n * \\brief   pixReadMemFromMultipageTiff()\n *\n * \\param[in]    cdata      const; tiff-encoded\n * \\param[in]    size       size of cdata\n * \\param[in,out]  poffset  set offset to 0 for first image\n * \\return  pix, or NULL on error or if previous call returned the last image\n *\n * <pre>\n * Notes:\n *      (1) This is a read-from-memory version of pixReadFromMultipageTiff().\n *          See that function for usage.\n *      (2) If reading sequentially from the tiff data, this is more\n *          efficient than pixReadMemTiff(), which has an overhead\n *          proportional to the image index n.\n *      (3) Example usage for reading all the images:\n *            size_t offset = 0;\n *            do {\n *                Pix *pix = pixReadMemFromMultipageTiff(data, size, &offset);\n *                // do something with pix\n *            } while (offset != 0);\n * </pre>\n */\nPIX *\npixReadMemFromMultipageTiff(const l_uint8  *cdata,\n                            size_t          size,\n                            size_t         *poffset)\n{\nl_uint8  *data;\nl_int32   retval;\nsize_t    offset;\nPIX      *pix;\nTIFF     *tif;\n\n    PROCNAME(\"pixReadMemFromMultipageTiff\");\n\n    if (!cdata)\n        return (PIX *)ERROR_PTR(\"cdata not defined\", procName, NULL);\n    if (!poffset)\n        return (PIX *)ERROR_PTR(\"&offset not defined\", procName, NULL);\n\n    data = (l_uint8 *)cdata;  /* we're really not going to change this */\n    if ((tif = fopenTiffMemstream(\"tifferror\", \"r\", &data, &size)) == NULL)\n        return (PIX *)ERROR_PTR(\"tiff stream not opened\", procName, NULL);\n\n        /* Set ptrs in the TIFF to the beginning of the image */\n    offset = *poffset;\n    retval = (offset == 0) ? TIFFSetDirectory(tif, 0)\n                           : TIFFSetSubDirectory(tif, offset);\n    if (retval == 0) {\n        TIFFClose(tif);\n        return NULL;\n    }\n\n    if ((pix = pixReadFromTiffStream(tif)) == NULL) {\n        TIFFClose(tif);\n        return NULL;\n    }\n\n        /* Advance to the next image and return the new offset */\n    TIFFReadDirectory(tif);\n    *poffset = TIFFCurrentDirOffset(tif);\n    TIFFClose(tif);\n    return pix;\n}\n\n\n/*!\n * \\brief   pixaReadMemMultipageTiff()\n *\n * \\param[in]    data    const; multiple pages; tiff-encoded\n * \\param[in]    size    size of cdata\n * \\return  pixa, or NULL on error\n *\n * <pre>\n * Notes:\n *      (1) This is an O(n) read-from-memory version of pixaReadMultipageTiff().\n * </pre>\n */\nPIXA *\npixaReadMemMultipageTiff(const l_uint8  *data,\n                         size_t          size)\n{\nsize_t  offset;\nPIX    *pix;\nPIXA   *pixa;\n\n    PROCNAME(\"pixaReadMemMultipageTiff\");\n\n    if (!data)\n        return (PIXA *)ERROR_PTR(\"data not defined\", procName, NULL);\n\n    offset = 0;\n    pixa = pixaCreate(0);\n    do {\n        pix = pixReadMemFromMultipageTiff(data, size, &offset);\n        pixaAddPix(pixa, pix, L_INSERT);\n    } while (offset != 0);\n    return pixa;\n}\n\n\n/*!\n * \\brief   pixaWriteMemMultipageTiff()\n *\n * \\param[out]    pdata   const; tiff-encoded\n * \\param[out]    psize   size of data\n * \\param[in]     pixa    any depth; colormap will be removed\n * \\return  0 if OK, 1 on error\n *\n * <pre>\n * Notes:\n *      (1) fopenTiffMemstream() does not work in append mode, so we\n *          must work-around with a temporary file.\n *      (2) Getting a file stream from\n *            open_memstream((char **)pdata, psize)\n *          does not work with the tiff directory.\n * </pre>\n */\nl_ok\npixaWriteMemMultipageTiff(l_uint8  **pdata,\n                          size_t    *psize,\n                          PIXA      *pixa)\n{\nconst char  *modestr;\nl_int32      i, n;\nFILE        *fp;\nPIX         *pix1;\n\n    PROCNAME(\"pixaWriteMemMultipageTiff\");\n\n    if (pdata) *pdata = NULL;\n    if (!pdata)\n        return ERROR_INT(\"pdata not defined\", procName, 1);\n    if (!pixa)\n        return ERROR_INT(\"pixa not defined\", procName, 1);\n\n#ifdef _WIN32\n    if ((fp = fopenWriteWinTempfile()) == NULL)\n        return ERROR_INT(\"tmpfile stream not opened\", procName, 1);\n#else\n    if ((fp = tmpfile()) == NULL)\n        return ERROR_INT(\"tmpfile stream not opened\", procName, 1);\n#endif  /* _WIN32 */\n\n    n = pixaGetCount(pixa);\n    for (i = 0; i < n; i++) {\n        modestr = (i == 0) ? \"w\" : \"a\";\n        pix1 = pixaGetPix(pixa, i, L_CLONE);\n        if (pixGetDepth(pix1) == 1)\n            pixWriteStreamTiffWA(fp, pix1, IFF_TIFF_G4, modestr);\n        else\n            pixWriteStreamTiffWA(fp, pix1, IFF_TIFF_ZIP, modestr);\n        pixDestroy(&pix1);\n    }\n\n    rewind(fp);\n    *pdata = l_binaryReadStream(fp, psize);\n    fclose(fp);\n    return 0;\n}\n\n\n/*!\n * \\brief   pixWriteMemTiff()\n *\n * \\param[out]   pdata     data of tiff compressed image\n * \\param[out]   psize     size of returned data\n * \\param[in]    pix\n * \\param[in]    comptype  IFF_TIFF, IFF_TIFF_RLE, IFF_TIFF_PACKBITS,\n *                         IFF_TIFF_G3, IFF_TIFF_G4,\n *                         IFF_TIFF_LZW, IFF_TIFF_ZIP, IFF_TIFF_JPEG\n * \\return  0 if OK, 1 on error\n *\n *  Usage:\n *      1) See pixWriteTiff(.  This version writes to\n *          memory instead of to a file.\n */\nl_ok\npixWriteMemTiff(l_uint8  **pdata,\n                size_t    *psize,\n                PIX       *pix,\n                l_int32    comptype)\n{\n    return pixWriteMemTiffCustom(pdata, psize, pix, comptype,\n                                 NULL, NULL, NULL, NULL);\n}\n\n\n/*!\n * \\brief   pixWriteMemTiffCustom()\n *\n * \\param[out]   pdata     data of tiff compressed image\n * \\param[out]   psize     size of returned data\n * \\param[in]    pix\n * \\param[in]    comptype  IFF_TIFF, IFF_TIFF_RLE, IFF_TIFF_PACKBITS,\n *                         IFF_TIFF_G3, IFF_TIFF_G4,\n *                         IFF_TIFF_LZW, IFF_TIFF_ZIP, IFF_TIFF_JPEG\n * \\param[in]    natags    [optional] NUMA of custom tiff tags\n * \\param[in]    savals    [optional] SARRAY of values\n * \\param[in]    satypes   [optional] SARRAY of types\n * \\param[in]    nasizes   [optional] NUMA of sizes\n * \\return  0 if OK, 1 on error\n *\n *  Usage:\n *      1) See pixWriteTiffCustom(.  This version writes to\n *          memory instead of to a file.\n *      2) Use TIFFClose(); TIFFCleanup( doesn't free internal memstream.\n */\nl_ok\npixWriteMemTiffCustom(l_uint8  **pdata,\n                      size_t    *psize,\n                      PIX       *pix,\n                      l_int32    comptype,\n                      NUMA      *natags,\n                      SARRAY    *savals,\n                      SARRAY    *satypes,\n                      NUMA      *nasizes)\n{\nl_int32  ret;\nTIFF    *tif;\n\n    PROCNAME(\"pixWriteMemTiffCustom\");\n\n    if (!pdata)\n        return ERROR_INT(\"&data not defined\", procName, 1);\n    if (!psize)\n        return ERROR_INT(\"&size not defined\", procName, 1);\n    if (!pix)\n        return ERROR_INT(\"&pix not defined\", procName, 1);\n    if (pixGetDepth(pix) != 1 && comptype != IFF_TIFF &&\n        comptype != IFF_TIFF_LZW && comptype != IFF_TIFF_ZIP &&\n        comptype != IFF_TIFF_JPEG) {\n        L_WARNING(\"invalid compression type for bpp > 1\\n\", procName);\n        comptype = IFF_TIFF_ZIP;\n    }\n\n    if ((tif = fopenTiffMemstream(\"tifferror\", \"w\", pdata, psize)) == NULL)\n        return ERROR_INT(\"tiff stream not opened\", procName, 1);\n    ret = pixWriteToTiffStream(tif, pix, comptype, natags, savals,\n                               satypes, nasizes);\n\n    TIFFClose(tif);\n    return ret;\n}\n\n/* --------------------------------------------*/\n#endif  /* HAVE_LIBTIFF */\n/* --------------------------------------------*/\n"], "filenames": ["prog/dewarptest1.c", "src/tiffio.c"], "buggy_code_start_loc": [54, 605], "buggy_code_end_loc": [165, 606], "fixing_code_start_loc": [55, 605], "fixing_code_end_loc": [164, 606], "type": "CWE-125", "message": "Leptonica before 1.80.0 allows a heap-based buffer over-read in pixReadFromTiffStream, related to tiffio.c.", "other": {"cve": {"id": "CVE-2020-36280", "sourceIdentifier": "cve@mitre.org", "published": "2021-03-12T00:15:12.787", "lastModified": "2021-12-03T17:38:51.197", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Leptonica before 1.80.0 allows a heap-based buffer over-read in pixReadFromTiffStream, related to tiffio.c."}, {"lang": "es", "value": "Leptonica versiones anteriores a 1.80.0, permite una lectura excesiva del b\u00fafer en la regi\u00f3n heap de la memoria en la funci\u00f3n  pixReadFromTiffStream, relacionado con el archivo tiffio.c"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:leptonica:leptonica:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.80.0", "matchCriteriaId": "1616069D-AF01-4FED-83F7-80566DF507D7"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:32:*:*:*:*:*:*:*", "matchCriteriaId": "36D96259-24BD-44E2-96D9-78CE1D41F956"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:33:*:*:*:*:*:*:*", "matchCriteriaId": "E460AA51-FCDA-46B9-AE97-E6676AA5E194"}]}]}], "references": [{"url": "https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=23654", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/DanBloomberg/leptonica/commit/5ba34b1fe741d69d43a6c8cf767756997eadd87c", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/DanBloomberg/leptonica/compare/1.79.0...1.80.0", "source": "cve@mitre.org", "tags": ["Patch", "Release Notes", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/JQUEA2X6UTH4DMYCMZAWE2QQLN5YANUA/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/RD5AIWHWE334HGYZJR2U3I3JYKSSO2LW/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202107-53", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/DanBloomberg/leptonica/commit/5ba34b1fe741d69d43a6c8cf767756997eadd87c"}}