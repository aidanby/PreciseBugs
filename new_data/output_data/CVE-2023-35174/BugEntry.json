{"buggy_code": ["defmodule Livebook.Utils do\n  @moduledoc false\n\n  require Logger\n\n  @type id :: binary()\n\n  @doc \"\"\"\n  Generates a random binary id.\n  \"\"\"\n  @spec random_id() :: id()\n  def random_id() do\n    :crypto.strong_rand_bytes(20) |> Base.encode32(case: :lower)\n  end\n\n  @doc \"\"\"\n  Generates a random short binary id.\n  \"\"\"\n  @spec random_short_id() :: id()\n  def random_short_id() do\n    :crypto.strong_rand_bytes(5) |> Base.encode32(case: :lower)\n  end\n\n  @doc \"\"\"\n  Generates a random cookie for a distributed node.\n  \"\"\"\n  @spec random_cookie() :: atom()\n  def random_cookie() do\n    :\"c_#{Base.url_encode64(:crypto.strong_rand_bytes(39))}\"\n  end\n\n  @doc \"\"\"\n  Generates a random binary id that includes node information.\n\n  ## Format\n\n  The id is formed from the following binary parts:\n\n    * 16B - hashed node name\n    * 9B - random bytes\n\n  The binary is base32 encoded.\n  \"\"\"\n  @spec random_node_aware_id() :: id()\n  def random_node_aware_id() do\n    node_part = node_hash(node())\n    random_part = :crypto.strong_rand_bytes(9)\n    binary = <<node_part::binary, random_part::binary>>\n    # 16B + 9B = 25B is suitable for base32 encoding without padding\n    Base.encode32(binary, case: :lower)\n  end\n\n  # Note: the result is always 16 bytes long\n  defp node_hash(node) do\n    content = Atom.to_string(node)\n    :erlang.md5(content)\n  end\n\n  @doc \"\"\"\n  Extracts node name from the given node aware id.\n\n  The node in question must be connected, otherwise it won't be found.\n  \"\"\"\n  @spec node_from_node_aware_id(id()) :: {:ok, node()} | :error\n  def node_from_node_aware_id(id) do\n    binary = Base.decode32!(id, case: :lower)\n    <<node_part::binary-size(16), _random_part::binary-size(9)>> = binary\n\n    known_nodes = [node() | Node.list()]\n\n    Enum.find_value(known_nodes, :error, fn node ->\n      node_hash(node) == node_part && {:ok, node}\n    end)\n  end\n\n  @doc \"\"\"\n  Returns the host part of a node.\n  \"\"\"\n  @spec node_host() :: binary()\n  def node_host do\n    [_, host] = node() |> Atom.to_string() |> :binary.split(\"@\")\n    host\n  end\n\n  @doc \"\"\"\n  Registers the given process under `name` for the time of `fun` evaluation.\n  \"\"\"\n  @spec temporarily_register(pid(), atom(), (... -> any())) :: any()\n  def temporarily_register(pid, name, fun) do\n    Process.register(pid, name)\n    fun.()\n  after\n    Process.unregister(name)\n  end\n\n  @doc \"\"\"\n  Returns a function that accesses list items by the given id.\n\n  ## Examples\n\n      iex> list = [%{id: 1, name: \"Jake\"}, %{id: 2, name: \"Amy\"}]\n      iex> get_in(list, [Livebook.Utils.access_by_id(2), Access.key(:name)])\n      \"Amy\"\n\n      iex> list = [%{id: 1, name: \"Jake\"}, %{id: 2, name: \"Amy\"}]\n      iex> put_in(list, [Livebook.Utils.access_by_id(2), Access.key(:name)], \"Amy Santiago\")\n      [%{id: 1, name: \"Jake\"}, %{id: 2, name: \"Amy Santiago\"}]\n\n  An error is raised if the accessed structure is not a list:\n\n      iex> get_in(%{}, [Livebook.Utils.access_by_id(1)])\n      ** (RuntimeError) Livebook.Utils.access_by_id/1 expected a list, got: %{}\n  \"\"\"\n  @spec access_by_id(term()) ::\n          Access.access_fun(data :: struct() | map(), current_value :: term())\n  def access_by_id(id) do\n    fn\n      :get, data, next when is_list(data) ->\n        data\n        |> Enum.find(fn item -> item.id == id end)\n        |> next.()\n\n      :get_and_update, data, next when is_list(data) ->\n        case Enum.split_while(data, fn item -> item.id != id end) do\n          {prev, [item | cons]} ->\n            case next.(item) do\n              {get, update} ->\n                {get, prev ++ [update | cons]}\n\n              :pop ->\n                {item, prev ++ cons}\n            end\n\n          _ ->\n            {nil, data}\n        end\n\n      _op, data, _next ->\n        raise \"Livebook.Utils.access_by_id/1 expected a list, got: #{inspect(data)}\"\n    end\n  end\n\n  @doc \"\"\"\n  Validates if the given URL is syntactically valid.\n\n  ## Examples\n\n      iex> Livebook.Utils.valid_url?(\"not_a_url\")\n      false\n\n      iex> Livebook.Utils.valid_url?(\"https://example.com\")\n      true\n\n      iex> Livebook.Utils.valid_url?(\"http://localhost\")\n      true\n\n      iex> Livebook.Utils.valid_url?(\"http://\")\n      false\n  \"\"\"\n  @spec valid_url?(String.t()) :: boolean()\n  def valid_url?(url) do\n    uri = URI.parse(url)\n    uri.scheme != nil and uri.host not in [nil, \"\"]\n  end\n\n  @doc ~S\"\"\"\n  Validates if the given string forms valid CLI flags.\n\n  ## Examples\n\n      iex> Livebook.Utils.valid_cli_flags?(\"\")\n      true\n\n      iex> Livebook.Utils.valid_cli_flags?(\"--arg1 value --arg2 'value'\")\n      true\n\n      iex> Livebook.Utils.valid_cli_flags?(\"--arg1 \\\"\")\n      false\n  \"\"\"\n  @spec valid_cli_flags?(String.t()) :: boolean()\n  def valid_cli_flags?(flags) do\n    try do\n      OptionParser.split(flags)\n      true\n    rescue\n      _ -> false\n    end\n  end\n\n  @doc \"\"\"\n  Changes the first letter in the given string to upper case.\n\n  ## Examples\n\n      iex> Livebook.Utils.upcase_first(\"sippin tea\")\n      \"Sippin tea\"\n\n      iex> Livebook.Utils.upcase_first(\"short URL\")\n      \"Short URL\"\n\n      iex> Livebook.Utils.upcase_first(\"\")\n      \"\"\n  \"\"\"\n  @spec upcase_first(String.t()) :: String.t()\n  def upcase_first(string) do\n    {first, rest} = String.split_at(string, 1)\n    String.upcase(first) <> rest\n  end\n\n  @doc \"\"\"\n  Changes the first letter in the given string to lower case.\n\n  ## Examples\n\n      iex> Livebook.Utils.downcase_first(\"Sippin tea\")\n      \"sippin tea\"\n\n      iex> Livebook.Utils.downcase_first(\"Short URL\")\n      \"short URL\"\n\n      iex> Livebook.Utils.downcase_first(\"\")\n      \"\"\n  \"\"\"\n  @spec downcase_first(String.t()) :: String.t()\n  def downcase_first(string) do\n    {first, rest} = String.split_at(string, 1)\n    String.downcase(first) <> rest\n  end\n\n  @doc \"\"\"\n  Expands a relative path in terms of the given URL.\n\n  ## Examples\n\n      iex> Livebook.Utils.expand_url(\"file:///home/user/lib/file.ex\", \"../root.ex\")\n      \"file:///home/user/root.ex\"\n\n      iex> Livebook.Utils.expand_url(\"https://example.com/lib/file.ex?token=supersecret\", \"../root.ex\")\n      \"https://example.com/root.ex?token=supersecret\"\n  \"\"\"\n  @spec expand_url(String.t(), String.t()) :: String.t()\n  def expand_url(url, relative_path) do\n    url\n    |> URI.parse()\n    |> Map.update!(:path, fn path ->\n      Livebook.FileSystem.Utils.resolve_unix_like_path(path, relative_path)\n    end)\n    |> URI.to_string()\n  end\n\n  @doc ~S\"\"\"\n  Wraps the given line into lines that fit in `width` characters.\n\n  Words longer than `width` are not broken apart.\n\n  ## Examples\n\n      iex> Livebook.Utils.wrap_line(\"cat on the roof\", 7)\n      \"cat on\\nthe\\nroof\"\n\n      iex> Livebook.Utils.wrap_line(\"cat in the cup\", 7)\n      \"cat in\\nthe cup\"\n\n      iex> Livebook.Utils.wrap_line(\"cat in the cup\", 2)\n      \"cat\\nin\\nthe\\ncup\"\n  \"\"\"\n  @spec wrap_line(String.t(), pos_integer()) :: String.t()\n  def wrap_line(line, width) do\n    line\n    |> String.split()\n    |> Enum.reduce({[[]], 0}, fn part, {[group | groups], group_size} ->\n      size = String.length(part)\n\n      cond do\n        group == [] ->\n          {[[part] | groups], size}\n\n        group_size + 1 + size <= width ->\n          {[[part, \" \" | group] | groups], group_size + 1 + size}\n\n        true ->\n          {[[part], group | groups], size}\n      end\n    end)\n    |> elem(0)\n    |> Enum.map(&Enum.reverse/1)\n    |> Enum.reverse()\n    |> Enum.intersperse(\"\\n\")\n    |> IO.iodata_to_binary()\n  end\n\n  @doc \"\"\"\n  Reads file contents and encodes it into a data URL.\n  \"\"\"\n  @spec read_as_data_url!(Path.t()) :: binary()\n  def read_as_data_url!(path) do\n    content = File.read!(path)\n    mime = MIME.from_path(path)\n    data = Base.encode64(content)\n    \"data:#{mime};base64,#{data}\"\n  end\n\n  @doc \"\"\"\n  Opens the given `url` in the browser.\n  \"\"\"\n  def browser_open(url) do\n    win_cmd_args = [\"/c\", \"start\", String.replace(url, \"&\", \"^&\")]\n\n    cmd_args =\n      case :os.type() do\n        {:win32, _} ->\n          {\"cmd\", win_cmd_args}\n\n        {:unix, :darwin} ->\n          {\"open\", [url]}\n\n        {:unix, _} ->\n          cond do\n            System.find_executable(\"xdg-open\") -> {\"xdg-open\", [url]}\n            # When inside WSL\n            System.find_executable(\"cmd.exe\") -> {\"cmd.exe\", win_cmd_args}\n            true -> nil\n          end\n      end\n\n    case cmd_args do\n      {cmd, args} -> System.cmd(cmd, args)\n      nil -> Logger.warning(\"could not open the browser, no open command found in the system\")\n    end\n\n    :ok\n  end\n\n  @doc \"\"\"\n  Splits the given string at the last occurrence of `pattern`.\n\n  ## Examples\n\n      iex> Livebook.Utils.split_at_last_occurrence(\"1,2,3\", \",\")\n      {:ok, \"1,2\", \"3\"}\n\n      iex> Livebook.Utils.split_at_last_occurrence(\"123\", \",\")\n      :error\n  \"\"\"\n  @spec split_at_last_occurrence(String.t(), String.pattern()) ::\n          {:ok, left :: String.t(), right :: String.t()} | :error\n  def split_at_last_occurrence(string, pattern) when is_binary(string) do\n    case :binary.matches(string, pattern) do\n      [] ->\n        :error\n\n      parts ->\n        {start, _} = List.last(parts)\n        size = byte_size(string)\n        {:ok, binary_part(string, 0, start), binary_part(string, start + 1, size - start - 1)}\n    end\n  end\n\n  @doc ~S\"\"\"\n  Finds CR characters and removes leading text in the same line.\n\n  Note that trailing CRs are kept.\n\n  ## Examples\n\n      iex> Livebook.Utils.apply_rewind(\"Hola\\nHmm\\rHey\")\n      \"Hola\\nHey\"\n\n      iex> Livebook.Utils.apply_rewind(\"\\rHey\")\n      \"Hey\"\n\n      iex> Livebook.Utils.apply_rewind(\"Hola\\r\\nHey\\r\")\n      \"Hola\\r\\nHey\\r\"\n  \"\"\"\n  @spec apply_rewind(String.t()) :: String.t()\n  def apply_rewind(text) when is_binary(text) do\n    apply_rewind(text, \"\", \"\")\n  end\n\n  defp apply_rewind(<<?\\n, rest::binary>>, acc, line),\n    do: apply_rewind(rest, <<acc::binary, line::binary, ?\\n>>, \"\")\n\n  defp apply_rewind(<<?\\r, byte, rest::binary>>, acc, _line) when byte != ?\\n,\n    do: apply_rewind(rest, acc, <<byte>>)\n\n  defp apply_rewind(<<byte, rest::binary>>, acc, line),\n    do: apply_rewind(rest, acc, <<line::binary, byte>>)\n\n  defp apply_rewind(\"\", acc, line), do: acc <> line\n\n  @doc ~S\"\"\"\n  Limits `text` to last `max_lines`.\n\n  Replaces the removed lines with `\"...\"`.\n\n  ## Examples\n\n      iex> Livebook.Utils.cap_lines(\"Line 1\\nLine 2\\nLine 3\\nLine 4\", 2)\n      \"...\\nLine 3\\nLine 4\"\n\n      iex> Livebook.Utils.cap_lines(\"Line 1\\nLine 2\", 2)\n      \"Line 1\\nLine 2\"\n\n      iex> Livebook.Utils.cap_lines(\"Line 1\\nLine 2\", 3)\n      \"Line 1\\nLine 2\"\n  \"\"\"\n  @spec cap_lines(String.t(), non_neg_integer()) :: String.t()\n  def cap_lines(text, max_lines) do\n    text\n    |> :binary.matches(\"\\n\")\n    |> Enum.at(-max_lines)\n    |> case do\n      nil ->\n        text\n\n      {pos, _len} ->\n        <<_ignore::binary-size(pos), rest::binary>> = text\n        \"...\" <> rest\n    end\n  end\n\n  @doc \"\"\"\n  Returns a URL (including localhost) to import the given `url` as a notebook.\n\n      iex> Livebook.Utils.notebook_import_url(\"https://example.com/foo.livemd\")\n      \"http://localhost:4002/import?url=https%3A%2F%2Fexample.com%2Ffoo.livemd\"\n\n      iex> Livebook.Utils.notebook_import_url(\"https://my_host\", \"https://example.com/foo.livemd\")\n      \"https://my_host/import?url=https%3A%2F%2Fexample.com%2Ffoo.livemd\"\n\n  \"\"\"\n  def notebook_import_url(base_url \\\\ LivebookWeb.Endpoint.access_struct_url(), url) do\n    base_url\n    |> URI.parse()\n    |> Map.replace!(:path, \"/import\")\n    |> URI.append_query(\"url=#{URI.encode_www_form(url)}\")\n    |> URI.to_string()\n  end\n\n  @doc \"\"\"\n  Returns a URL (including localhost) to open the given `path` as a notebook\n\n      iex> Livebook.Utils.notebook_open_url(\"/data/foo.livemd\")\n      \"http://localhost:4002/open?path=%2Fdata%2Ffoo.livemd\"\n\n      iex> Livebook.Utils.notebook_open_url(\"https://my_host\", \"/data/foo.livemd\")\n      \"https://my_host/open?path=%2Fdata%2Ffoo.livemd\"\n\n  \"\"\"\n  def notebook_open_url(base_url \\\\ LivebookWeb.Endpoint.access_struct_url(), path) do\n    base_url\n    |> URI.parse()\n    |> Map.replace!(:path, \"/open\")\n    |> URI.append_query(\"path=#{URI.encode_www_form(path)}\")\n    |> URI.to_string()\n  end\n\n  @doc \"\"\"\n  Formats the given number of bytes into a human-friendly text.\n\n  ## Examples\n\n      iex> Livebook.Utils.format_bytes(0)\n      \"0 B\"\n\n      iex> Livebook.Utils.format_bytes(900)\n      \"900 B\"\n\n      iex> Livebook.Utils.format_bytes(1100)\n      \"1.1 KB\"\n\n      iex> Livebook.Utils.format_bytes(1_228_800)\n      \"1.2 MB\"\n\n      iex> Livebook.Utils.format_bytes(1_363_148_800)\n      \"1.4 GB\"\n\n      iex> Livebook.Utils.format_bytes(1_503_238_553_600)\n      \"1.5 TB\"\n\n  \"\"\"\n  @spec format_bytes(non_neg_integer()) :: String.t()\n  def format_bytes(bytes) when is_integer(bytes) do\n    cond do\n      bytes >= memory_unit(:TB) -> format_bytes(bytes, :TB)\n      bytes >= memory_unit(:GB) -> format_bytes(bytes, :GB)\n      bytes >= memory_unit(:MB) -> format_bytes(bytes, :MB)\n      bytes >= memory_unit(:KB) -> format_bytes(bytes, :KB)\n      true -> format_bytes(bytes, :B)\n    end\n  end\n\n  defp format_bytes(bytes, :B) when is_integer(bytes), do: \"#{bytes} B\"\n\n  defp format_bytes(bytes, unit) when is_integer(bytes) do\n    value = bytes / memory_unit(unit)\n    \"#{:erlang.float_to_binary(value, decimals: 1)} #{unit}\"\n  end\n\n  defp memory_unit(:TB), do: 1_000_000_000_000\n  defp memory_unit(:GB), do: 1_000_000_000\n  defp memory_unit(:MB), do: 1_000_000\n  defp memory_unit(:KB), do: 1_000\n\n  @doc \"\"\"\n  Gets the port for an existing listener.\n\n  The listener references usually follow the pattern `plug.HTTP`\n  and `plug.HTTPS`.\n  \"\"\"\n  @spec get_port(:ranch.ref(), :inet.port_number()) :: :inet.port_number()\n  def get_port(ref, default) do\n    try do\n      :ranch.get_addr(ref)\n    rescue\n      _ -> default\n    else\n      {_, port} when is_integer(port) -> port\n      _ -> default\n    end\n  end\n\n  @doc \"\"\"\n  Converts the given IP address into a valid hostname.\n\n  ## Examples\n\n      iex> Livebook.Utils.ip_to_host({192, 168, 0, 1})\n      \"192.168.0.1\"\n\n      iex> Livebook.Utils.ip_to_host({127, 0, 0, 1})\n      \"localhost\"\n\n      iex> Livebook.Utils.ip_to_host({0, 0, 0, 0})\n      \"0.0.0.0\"\n  \"\"\"\n  @spec ip_to_host(:inet.ip_address()) :: String.t()\n  def ip_to_host(ip)\n\n  def ip_to_host({127, 0, 0, 1}), do: \"localhost\"\n\n  def ip_to_host(ip) do\n    ip |> :inet.ntoa() |> List.to_string()\n  end\nend\n", "if Mix.target() == :app do\n  defmodule LivebookApp do\n    use GenServer\n\n    def start_link(arg) do\n      GenServer.start_link(__MODULE__, arg, name: __MODULE__)\n    end\n\n    @impl true\n    def init(_) do\n      {:ok, pid} = ElixirKit.start()\n      ref = Process.monitor(pid)\n      {:ok, %{ref: ref}}\n    end\n\n    @impl true\n    def handle_info({:event, \"open\", url}, state) do\n      open(url)\n      {:noreply, state}\n    end\n\n    @impl true\n    def handle_info({:DOWN, ref, :process, _, :shutdown}, state) when ref == state.ref do\n      Livebook.Config.shutdown()\n      {:noreply, state}\n    end\n\n    defp open(\"\") do\n      open(LivebookWeb.Endpoint.access_url())\n    end\n\n    defp open(\"file://\" <> path) do\n      path\n      |> Livebook.Utils.notebook_open_url()\n      |> open()\n    end\n\n    defp open(\"livebook://\" <> rest) do\n      \"https://#{rest}\"\n      |> Livebook.Utils.notebook_import_url()\n      |> open()\n    end\n\n    defp open(url) do\n      Livebook.Utils.browser_open(url)\n    end\n  end\nend\n"], "fixing_code": ["defmodule Livebook.Utils do\n  @moduledoc false\n\n  require Logger\n\n  @type id :: binary()\n\n  @doc \"\"\"\n  Generates a random binary id.\n  \"\"\"\n  @spec random_id() :: id()\n  def random_id() do\n    :crypto.strong_rand_bytes(20) |> Base.encode32(case: :lower)\n  end\n\n  @doc \"\"\"\n  Generates a random short binary id.\n  \"\"\"\n  @spec random_short_id() :: id()\n  def random_short_id() do\n    :crypto.strong_rand_bytes(5) |> Base.encode32(case: :lower)\n  end\n\n  @doc \"\"\"\n  Generates a random cookie for a distributed node.\n  \"\"\"\n  @spec random_cookie() :: atom()\n  def random_cookie() do\n    :\"c_#{Base.url_encode64(:crypto.strong_rand_bytes(39))}\"\n  end\n\n  @doc \"\"\"\n  Generates a random binary id that includes node information.\n\n  ## Format\n\n  The id is formed from the following binary parts:\n\n    * 16B - hashed node name\n    * 9B - random bytes\n\n  The binary is base32 encoded.\n  \"\"\"\n  @spec random_node_aware_id() :: id()\n  def random_node_aware_id() do\n    node_part = node_hash(node())\n    random_part = :crypto.strong_rand_bytes(9)\n    binary = <<node_part::binary, random_part::binary>>\n    # 16B + 9B = 25B is suitable for base32 encoding without padding\n    Base.encode32(binary, case: :lower)\n  end\n\n  # Note: the result is always 16 bytes long\n  defp node_hash(node) do\n    content = Atom.to_string(node)\n    :erlang.md5(content)\n  end\n\n  @doc \"\"\"\n  Extracts node name from the given node aware id.\n\n  The node in question must be connected, otherwise it won't be found.\n  \"\"\"\n  @spec node_from_node_aware_id(id()) :: {:ok, node()} | :error\n  def node_from_node_aware_id(id) do\n    binary = Base.decode32!(id, case: :lower)\n    <<node_part::binary-size(16), _random_part::binary-size(9)>> = binary\n\n    known_nodes = [node() | Node.list()]\n\n    Enum.find_value(known_nodes, :error, fn node ->\n      node_hash(node) == node_part && {:ok, node}\n    end)\n  end\n\n  @doc \"\"\"\n  Returns the host part of a node.\n  \"\"\"\n  @spec node_host() :: binary()\n  def node_host do\n    [_, host] = node() |> Atom.to_string() |> :binary.split(\"@\")\n    host\n  end\n\n  @doc \"\"\"\n  Registers the given process under `name` for the time of `fun` evaluation.\n  \"\"\"\n  @spec temporarily_register(pid(), atom(), (... -> any())) :: any()\n  def temporarily_register(pid, name, fun) do\n    Process.register(pid, name)\n    fun.()\n  after\n    Process.unregister(name)\n  end\n\n  @doc \"\"\"\n  Returns a function that accesses list items by the given id.\n\n  ## Examples\n\n      iex> list = [%{id: 1, name: \"Jake\"}, %{id: 2, name: \"Amy\"}]\n      iex> get_in(list, [Livebook.Utils.access_by_id(2), Access.key(:name)])\n      \"Amy\"\n\n      iex> list = [%{id: 1, name: \"Jake\"}, %{id: 2, name: \"Amy\"}]\n      iex> put_in(list, [Livebook.Utils.access_by_id(2), Access.key(:name)], \"Amy Santiago\")\n      [%{id: 1, name: \"Jake\"}, %{id: 2, name: \"Amy Santiago\"}]\n\n  An error is raised if the accessed structure is not a list:\n\n      iex> get_in(%{}, [Livebook.Utils.access_by_id(1)])\n      ** (RuntimeError) Livebook.Utils.access_by_id/1 expected a list, got: %{}\n  \"\"\"\n  @spec access_by_id(term()) ::\n          Access.access_fun(data :: struct() | map(), current_value :: term())\n  def access_by_id(id) do\n    fn\n      :get, data, next when is_list(data) ->\n        data\n        |> Enum.find(fn item -> item.id == id end)\n        |> next.()\n\n      :get_and_update, data, next when is_list(data) ->\n        case Enum.split_while(data, fn item -> item.id != id end) do\n          {prev, [item | cons]} ->\n            case next.(item) do\n              {get, update} ->\n                {get, prev ++ [update | cons]}\n\n              :pop ->\n                {item, prev ++ cons}\n            end\n\n          _ ->\n            {nil, data}\n        end\n\n      _op, data, _next ->\n        raise \"Livebook.Utils.access_by_id/1 expected a list, got: #{inspect(data)}\"\n    end\n  end\n\n  @doc \"\"\"\n  Validates if the given URL is syntactically valid.\n\n  ## Examples\n\n      iex> Livebook.Utils.valid_url?(\"not_a_url\")\n      false\n\n      iex> Livebook.Utils.valid_url?(\"https://example.com\")\n      true\n\n      iex> Livebook.Utils.valid_url?(\"http://localhost\")\n      true\n\n      iex> Livebook.Utils.valid_url?(\"http://\")\n      false\n  \"\"\"\n  @spec valid_url?(String.t()) :: boolean()\n  def valid_url?(url) do\n    uri = URI.parse(url)\n    uri.scheme != nil and uri.host not in [nil, \"\"]\n  end\n\n  @doc ~S\"\"\"\n  Validates if the given string forms valid CLI flags.\n\n  ## Examples\n\n      iex> Livebook.Utils.valid_cli_flags?(\"\")\n      true\n\n      iex> Livebook.Utils.valid_cli_flags?(\"--arg1 value --arg2 'value'\")\n      true\n\n      iex> Livebook.Utils.valid_cli_flags?(\"--arg1 \\\"\")\n      false\n  \"\"\"\n  @spec valid_cli_flags?(String.t()) :: boolean()\n  def valid_cli_flags?(flags) do\n    try do\n      OptionParser.split(flags)\n      true\n    rescue\n      _ -> false\n    end\n  end\n\n  @doc \"\"\"\n  Changes the first letter in the given string to upper case.\n\n  ## Examples\n\n      iex> Livebook.Utils.upcase_first(\"sippin tea\")\n      \"Sippin tea\"\n\n      iex> Livebook.Utils.upcase_first(\"short URL\")\n      \"Short URL\"\n\n      iex> Livebook.Utils.upcase_first(\"\")\n      \"\"\n  \"\"\"\n  @spec upcase_first(String.t()) :: String.t()\n  def upcase_first(string) do\n    {first, rest} = String.split_at(string, 1)\n    String.upcase(first) <> rest\n  end\n\n  @doc \"\"\"\n  Changes the first letter in the given string to lower case.\n\n  ## Examples\n\n      iex> Livebook.Utils.downcase_first(\"Sippin tea\")\n      \"sippin tea\"\n\n      iex> Livebook.Utils.downcase_first(\"Short URL\")\n      \"short URL\"\n\n      iex> Livebook.Utils.downcase_first(\"\")\n      \"\"\n  \"\"\"\n  @spec downcase_first(String.t()) :: String.t()\n  def downcase_first(string) do\n    {first, rest} = String.split_at(string, 1)\n    String.downcase(first) <> rest\n  end\n\n  @doc \"\"\"\n  Expands a relative path in terms of the given URL.\n\n  ## Examples\n\n      iex> Livebook.Utils.expand_url(\"file:///home/user/lib/file.ex\", \"../root.ex\")\n      \"file:///home/user/root.ex\"\n\n      iex> Livebook.Utils.expand_url(\"https://example.com/lib/file.ex?token=supersecret\", \"../root.ex\")\n      \"https://example.com/root.ex?token=supersecret\"\n  \"\"\"\n  @spec expand_url(String.t(), String.t()) :: String.t()\n  def expand_url(url, relative_path) do\n    url\n    |> URI.parse()\n    |> Map.update!(:path, fn path ->\n      Livebook.FileSystem.Utils.resolve_unix_like_path(path, relative_path)\n    end)\n    |> URI.to_string()\n  end\n\n  @doc ~S\"\"\"\n  Wraps the given line into lines that fit in `width` characters.\n\n  Words longer than `width` are not broken apart.\n\n  ## Examples\n\n      iex> Livebook.Utils.wrap_line(\"cat on the roof\", 7)\n      \"cat on\\nthe\\nroof\"\n\n      iex> Livebook.Utils.wrap_line(\"cat in the cup\", 7)\n      \"cat in\\nthe cup\"\n\n      iex> Livebook.Utils.wrap_line(\"cat in the cup\", 2)\n      \"cat\\nin\\nthe\\ncup\"\n  \"\"\"\n  @spec wrap_line(String.t(), pos_integer()) :: String.t()\n  def wrap_line(line, width) do\n    line\n    |> String.split()\n    |> Enum.reduce({[[]], 0}, fn part, {[group | groups], group_size} ->\n      size = String.length(part)\n\n      cond do\n        group == [] ->\n          {[[part] | groups], size}\n\n        group_size + 1 + size <= width ->\n          {[[part, \" \" | group] | groups], group_size + 1 + size}\n\n        true ->\n          {[[part], group | groups], size}\n      end\n    end)\n    |> elem(0)\n    |> Enum.map(&Enum.reverse/1)\n    |> Enum.reverse()\n    |> Enum.intersperse(\"\\n\")\n    |> IO.iodata_to_binary()\n  end\n\n  @doc \"\"\"\n  Reads file contents and encodes it into a data URL.\n  \"\"\"\n  @spec read_as_data_url!(Path.t()) :: binary()\n  def read_as_data_url!(path) do\n    content = File.read!(path)\n    mime = MIME.from_path(path)\n    data = Base.encode64(content)\n    \"data:#{mime};base64,#{data}\"\n  end\n\n  @doc \"\"\"\n  Expands URL received from the Desktop App for opening in the browser.\n  \"\"\"\n  def expand_desktop_url(\"\") do\n    LivebookWeb.Endpoint.access_url()\n  end\n\n  def expand_desktop_url(\"/settings\") do\n    to_string(%{LivebookWeb.Endpoint.access_struct_url() | path: \"/settings\"})\n  end\n\n  def expand_desktop_url(\"file://\" <> path) do\n    notebook_open_url(path)\n  end\n\n  def expand_desktop_url(\"livebook://\" <> rest) do\n    notebook_import_url(\"https://#{rest}\")\n  end\n\n  @doc \"\"\"\n  Opens the given `url` in the browser.\n  \"\"\"\n  def browser_open(url) do\n    win_cmd_args = [\"/c\", \"start\", String.replace(url, \"&\", \"^&\")]\n\n    cmd_args =\n      case :os.type() do\n        {:win32, _} ->\n          {\"cmd\", win_cmd_args}\n\n        {:unix, :darwin} ->\n          {\"open\", [url]}\n\n        {:unix, _} ->\n          cond do\n            System.find_executable(\"xdg-open\") ->\n              {\"xdg-open\", [url]}\n\n            # When inside WSL\n            System.find_executable(\"cmd.exe\") ->\n              {\"cmd.exe\", win_cmd_args}\n\n            true ->\n              nil\n          end\n      end\n\n    case cmd_args do\n      {cmd, args} -> System.cmd(cmd, args)\n      nil -> Logger.warning(\"could not open the browser, no open command found in the system\")\n    end\n\n    :ok\n  end\n\n  @doc \"\"\"\n  Splits the given string at the last occurrence of `pattern`.\n\n  ## Examples\n\n      iex> Livebook.Utils.split_at_last_occurrence(\"1,2,3\", \",\")\n      {:ok, \"1,2\", \"3\"}\n\n      iex> Livebook.Utils.split_at_last_occurrence(\"123\", \",\")\n      :error\n  \"\"\"\n  @spec split_at_last_occurrence(String.t(), String.pattern()) ::\n          {:ok, left :: String.t(), right :: String.t()} | :error\n  def split_at_last_occurrence(string, pattern) when is_binary(string) do\n    case :binary.matches(string, pattern) do\n      [] ->\n        :error\n\n      parts ->\n        {start, _} = List.last(parts)\n        size = byte_size(string)\n        {:ok, binary_part(string, 0, start), binary_part(string, start + 1, size - start - 1)}\n    end\n  end\n\n  @doc ~S\"\"\"\n  Finds CR characters and removes leading text in the same line.\n\n  Note that trailing CRs are kept.\n\n  ## Examples\n\n      iex> Livebook.Utils.apply_rewind(\"Hola\\nHmm\\rHey\")\n      \"Hola\\nHey\"\n\n      iex> Livebook.Utils.apply_rewind(\"\\rHey\")\n      \"Hey\"\n\n      iex> Livebook.Utils.apply_rewind(\"Hola\\r\\nHey\\r\")\n      \"Hola\\r\\nHey\\r\"\n  \"\"\"\n  @spec apply_rewind(String.t()) :: String.t()\n  def apply_rewind(text) when is_binary(text) do\n    apply_rewind(text, \"\", \"\")\n  end\n\n  defp apply_rewind(<<?\\n, rest::binary>>, acc, line),\n    do: apply_rewind(rest, <<acc::binary, line::binary, ?\\n>>, \"\")\n\n  defp apply_rewind(<<?\\r, byte, rest::binary>>, acc, _line) when byte != ?\\n,\n    do: apply_rewind(rest, acc, <<byte>>)\n\n  defp apply_rewind(<<byte, rest::binary>>, acc, line),\n    do: apply_rewind(rest, acc, <<line::binary, byte>>)\n\n  defp apply_rewind(\"\", acc, line), do: acc <> line\n\n  @doc ~S\"\"\"\n  Limits `text` to last `max_lines`.\n\n  Replaces the removed lines with `\"...\"`.\n\n  ## Examples\n\n      iex> Livebook.Utils.cap_lines(\"Line 1\\nLine 2\\nLine 3\\nLine 4\", 2)\n      \"...\\nLine 3\\nLine 4\"\n\n      iex> Livebook.Utils.cap_lines(\"Line 1\\nLine 2\", 2)\n      \"Line 1\\nLine 2\"\n\n      iex> Livebook.Utils.cap_lines(\"Line 1\\nLine 2\", 3)\n      \"Line 1\\nLine 2\"\n  \"\"\"\n  @spec cap_lines(String.t(), non_neg_integer()) :: String.t()\n  def cap_lines(text, max_lines) do\n    text\n    |> :binary.matches(\"\\n\")\n    |> Enum.at(-max_lines)\n    |> case do\n      nil ->\n        text\n\n      {pos, _len} ->\n        <<_ignore::binary-size(pos), rest::binary>> = text\n        \"...\" <> rest\n    end\n  end\n\n  @doc \"\"\"\n  Returns a URL (including localhost) to import the given `url` as a notebook.\n\n      iex> Livebook.Utils.notebook_import_url(\"https://example.com/foo.livemd\")\n      \"http://localhost:4002/import?url=https%3A%2F%2Fexample.com%2Ffoo.livemd\"\n\n      iex> Livebook.Utils.notebook_import_url(\"https://my_host\", \"https://example.com/foo.livemd\")\n      \"https://my_host/import?url=https%3A%2F%2Fexample.com%2Ffoo.livemd\"\n\n  \"\"\"\n  def notebook_import_url(base_url \\\\ LivebookWeb.Endpoint.access_struct_url(), url) do\n    base_url\n    |> URI.parse()\n    |> Map.replace!(:path, \"/import\")\n    |> URI.append_query(\"url=#{URI.encode_www_form(url)}\")\n    |> URI.to_string()\n  end\n\n  @doc \"\"\"\n  Returns a URL (including localhost) to open the given `path` as a notebook\n\n      iex> Livebook.Utils.notebook_open_url(\"/data/foo.livemd\")\n      \"http://localhost:4002/open?path=%2Fdata%2Ffoo.livemd\"\n\n      iex> Livebook.Utils.notebook_open_url(\"https://my_host\", \"/data/foo.livemd\")\n      \"https://my_host/open?path=%2Fdata%2Ffoo.livemd\"\n\n  \"\"\"\n  def notebook_open_url(base_url \\\\ LivebookWeb.Endpoint.access_struct_url(), path) do\n    base_url\n    |> URI.parse()\n    |> Map.replace!(:path, \"/open\")\n    |> URI.append_query(\"path=#{URI.encode_www_form(path)}\")\n    |> URI.to_string()\n  end\n\n  @doc \"\"\"\n  Formats the given number of bytes into a human-friendly text.\n\n  ## Examples\n\n      iex> Livebook.Utils.format_bytes(0)\n      \"0 B\"\n\n      iex> Livebook.Utils.format_bytes(900)\n      \"900 B\"\n\n      iex> Livebook.Utils.format_bytes(1100)\n      \"1.1 KB\"\n\n      iex> Livebook.Utils.format_bytes(1_228_800)\n      \"1.2 MB\"\n\n      iex> Livebook.Utils.format_bytes(1_363_148_800)\n      \"1.4 GB\"\n\n      iex> Livebook.Utils.format_bytes(1_503_238_553_600)\n      \"1.5 TB\"\n\n  \"\"\"\n  @spec format_bytes(non_neg_integer()) :: String.t()\n  def format_bytes(bytes) when is_integer(bytes) do\n    cond do\n      bytes >= memory_unit(:TB) -> format_bytes(bytes, :TB)\n      bytes >= memory_unit(:GB) -> format_bytes(bytes, :GB)\n      bytes >= memory_unit(:MB) -> format_bytes(bytes, :MB)\n      bytes >= memory_unit(:KB) -> format_bytes(bytes, :KB)\n      true -> format_bytes(bytes, :B)\n    end\n  end\n\n  defp format_bytes(bytes, :B) when is_integer(bytes), do: \"#{bytes} B\"\n\n  defp format_bytes(bytes, unit) when is_integer(bytes) do\n    value = bytes / memory_unit(unit)\n    \"#{:erlang.float_to_binary(value, decimals: 1)} #{unit}\"\n  end\n\n  defp memory_unit(:TB), do: 1_000_000_000_000\n  defp memory_unit(:GB), do: 1_000_000_000\n  defp memory_unit(:MB), do: 1_000_000\n  defp memory_unit(:KB), do: 1_000\n\n  @doc \"\"\"\n  Gets the port for an existing listener.\n\n  The listener references usually follow the pattern `plug.HTTP`\n  and `plug.HTTPS`.\n  \"\"\"\n  @spec get_port(:ranch.ref(), :inet.port_number()) :: :inet.port_number()\n  def get_port(ref, default) do\n    try do\n      :ranch.get_addr(ref)\n    rescue\n      _ -> default\n    else\n      {_, port} when is_integer(port) -> port\n      _ -> default\n    end\n  end\n\n  @doc \"\"\"\n  Converts the given IP address into a valid hostname.\n\n  ## Examples\n\n      iex> Livebook.Utils.ip_to_host({192, 168, 0, 1})\n      \"192.168.0.1\"\n\n      iex> Livebook.Utils.ip_to_host({127, 0, 0, 1})\n      \"localhost\"\n\n      iex> Livebook.Utils.ip_to_host({0, 0, 0, 0})\n      \"0.0.0.0\"\n  \"\"\"\n  @spec ip_to_host(:inet.ip_address()) :: String.t()\n  def ip_to_host(ip)\n\n  def ip_to_host({127, 0, 0, 1}), do: \"localhost\"\n\n  def ip_to_host(ip) do\n    ip |> :inet.ntoa() |> List.to_string()\n  end\nend\n", "if Mix.target() == :app do\n  defmodule LivebookApp do\n    use GenServer\n\n    def start_link(arg) do\n      GenServer.start_link(__MODULE__, arg, name: __MODULE__)\n    end\n\n    @impl true\n    def init(_) do\n      {:ok, pid} = ElixirKit.start()\n      ref = Process.monitor(pid)\n      {:ok, %{ref: ref}}\n    end\n\n    @impl true\n    def handle_info({:event, \"open\", url}, state) do\n      url\n      |> Livebook.Utils.expand_desktop_url()\n      |> Livebook.Utils.browser_open()\n\n      {:noreply, state}\n    end\n\n    @impl true\n    def handle_info({:DOWN, ref, :process, _, :shutdown}, state) when ref == state.ref do\n      Livebook.Config.shutdown()\n      {:noreply, state}\n    end\n  end\nend\n"], "filenames": ["lib/livebook/utils.ex", "lib/livebook_app.ex"], "buggy_code_start_loc": [303, 18], "buggy_code_end_loc": [323, 47], "fixing_code_start_loc": [304, 18], "fixing_code_end_loc": [347, 29], "type": "CWE-78", "message": "Livebook is a web application for writing interactive and collaborative code notebooks. On Windows, it is possible to open a `livebook://` link from a browser which opens Livebook Desktop and triggers arbitrary code execution on victim's machine. Any user using Livebook Desktop on Windows is potentially vulnerable to arbitrary code execution when they expect Livebook to be opened from browser. This vulnerability has been fixed in version 0.8.2 and 0.9.3.\n\n", "other": {"cve": {"id": "CVE-2023-35174", "sourceIdentifier": "security-advisories@github.com", "published": "2023-06-22T14:15:09.517", "lastModified": "2023-06-29T20:20:14.797", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Livebook is a web application for writing interactive and collaborative code notebooks. On Windows, it is possible to open a `livebook://` link from a browser which opens Livebook Desktop and triggers arbitrary code execution on victim's machine. Any user using Livebook Desktop on Windows is potentially vulnerable to arbitrary code execution when they expect Livebook to be opened from browser. This vulnerability has been fixed in version 0.8.2 and 0.9.3.\n\n"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:H/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "HIGH", "availabilityImpact": "LOW", "baseScore": 8.6, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 4.7}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-78"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-78"}]}], "configurations": [{"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:livebook:livebook:*:*:*:*:*:*:*:*", "versionStartIncluding": "0.8.0", "versionEndExcluding": "0.8.2", "matchCriteriaId": "0BFE3DF8-01D2-4B07-A6D3-161E54A3AA22"}, {"vulnerable": true, "criteria": "cpe:2.3:a:livebook:livebook:*:*:*:*:*:*:*:*", "versionStartIncluding": "0.9.0", "versionEndExcluding": "0.9.3", "matchCriteriaId": "1417F052-3C0B-4BF5-AA92-2154895E67DD"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:o:microsoft:windows:-:*:*:*:*:*:*:*", "matchCriteriaId": "A2572D17-1DE6-457B-99CC-64AFD54487EA"}]}]}], "references": [{"url": "https://github.com/livebook-dev/livebook/commit/2e11b59f677c6ed3b6aa82dad412a8b3406ffdf1", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/livebook-dev/livebook/commit/beb10daaadcc765f0380e436bd7cd5f74cf086c8", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/livebook-dev/livebook/releases/tag/v0.8.2", "source": "security-advisories@github.com", "tags": ["Release Notes"]}, {"url": "https://github.com/livebook-dev/livebook/releases/tag/v0.9.3", "source": "security-advisories@github.com", "tags": ["Release Notes"]}, {"url": "https://github.com/livebook-dev/livebook/security/advisories/GHSA-564w-97r7-c6p9", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/livebook-dev/livebook/commit/2e11b59f677c6ed3b6aa82dad412a8b3406ffdf1"}}