{"buggy_code": ["/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * spell.c: code for spell checking\n *\n * See spellfile.c for the Vim spell file format.\n *\n * The spell checking mechanism uses a tree (aka trie).  Each node in the tree\n * has a list of bytes that can appear (siblings).  For each byte there is a\n * pointer to the node with the byte that follows in the word (child).\n *\n * A NUL byte is used where the word may end.  The bytes are sorted, so that\n * binary searching can be used and the NUL bytes are at the start.  The\n * number of possible bytes is stored before the list of bytes.\n *\n * The tree uses two arrays: \"byts\" stores the characters, \"idxs\" stores\n * either the next index or flags.  The tree starts at index 0.  For example,\n * to lookup \"vi\" this sequence is followed:\n *\ti = 0\n *\tlen = byts[i]\n *\tn = where \"v\" appears in byts[i + 1] to byts[i + len]\n *\ti = idxs[n]\n *\tlen = byts[i]\n *\tn = where \"i\" appears in byts[i + 1] to byts[i + len]\n *\ti = idxs[n]\n *\tlen = byts[i]\n *\tfind that byts[i + 1] is 0, idxs[i + 1] has flags for \"vi\".\n *\n * There are two word trees: one with case-folded words and one with words in\n * original case.  The second one is only used for keep-case words and is\n * usually small.\n *\n * There is one additional tree for when not all prefixes are applied when\n * generating the .spl file.  This tree stores all the possible prefixes, as\n * if they were words.  At each word (prefix) end the prefix nr is stored, the\n * following word must support this prefix nr.  And the condition nr is\n * stored, used to lookup the condition that the word must match with.\n *\n * Thanks to Olaf Seibert for providing an example implementation of this tree\n * and the compression mechanism.\n * LZ trie ideas:\n *\thttp://www.irb.hr/hr/home/ristov/papers/RistovLZtrieRevision1.pdf\n * More papers: http://www-igm.univ-mlv.fr/~laporte/publi_en.html\n *\n * Matching involves checking the caps type: Onecap ALLCAP KeepCap.\n *\n * Why doesn't Vim use aspell/ispell/myspell/etc.?\n * See \":help develop-spell\".\n */\n\n#define IN_SPELL_C\n#include \"vim.h\"\n\n#if defined(FEAT_SPELL) || defined(PROTO)\n\n#ifndef UNIX\t\t// it's in os_unix.h for Unix\n# include <time.h>\t// for time_t\n#endif\n\n#define REGION_ALL 0xff\t\t// word valid in all regions\n\n// Result values.  Lower number is accepted over higher one.\n#define SP_BANNED\t(-1)\n#define SP_OK\t\t0\n#define SP_RARE\t\t1\n#define SP_LOCAL\t2\n#define SP_BAD\t\t3\n\n/*\n * Structure to store info for word matching.\n */\ntypedef struct matchinf_S\n{\n    langp_T\t*mi_lp;\t\t\t// info for language and region\n\n    // pointers to original text to be checked\n    char_u\t*mi_word;\t\t// start of word being checked\n    char_u\t*mi_end;\t\t// end of matching word so far\n    char_u\t*mi_fend;\t\t// next char to be added to mi_fword\n    char_u\t*mi_cend;\t\t// char after what was used for\n\t\t\t\t\t// mi_capflags\n\n    // case-folded text\n    char_u\tmi_fword[MAXWLEN + 1];\t// mi_word case-folded\n    int\t\tmi_fwordlen;\t\t// nr of valid bytes in mi_fword\n\n    // for when checking word after a prefix\n    int\t\tmi_prefarridx;\t\t// index in sl_pidxs with list of\n\t\t\t\t\t// affixID/condition\n    int\t\tmi_prefcnt;\t\t// number of entries at mi_prefarridx\n    int\t\tmi_prefixlen;\t\t// byte length of prefix\n    int\t\tmi_cprefixlen;\t\t// byte length of prefix in original\n\t\t\t\t\t// case\n\n    // for when checking a compound word\n    int\t\tmi_compoff;\t\t// start of following word offset\n    char_u\tmi_compflags[MAXWLEN];\t// flags for compound words used\n    int\t\tmi_complen;\t\t// nr of compound words used\n    int\t\tmi_compextra;\t\t// nr of COMPOUNDROOT words\n\n    // others\n    int\t\tmi_result;\t\t// result so far: SP_BAD, SP_OK, etc.\n    int\t\tmi_capflags;\t\t// WF_ONECAP WF_ALLCAP WF_KEEPCAP\n    win_T\t*mi_win;\t\t// buffer being checked\n\n    // for NOBREAK\n    int\t\tmi_result2;\t\t// \"mi_result\" without following word\n    char_u\t*mi_end2;\t\t// \"mi_end\" without following word\n} matchinf_T;\n\n\nstatic int spell_mb_isword_class(int cl, win_T *wp);\n\n// mode values for find_word\n#define FIND_FOLDWORD\t    0\t// find word case-folded\n#define FIND_KEEPWORD\t    1\t// find keep-case word\n#define FIND_PREFIX\t    2\t// find word after prefix\n#define FIND_COMPOUND\t    3\t// find case-folded compound word\n#define FIND_KEEPCOMPOUND   4\t// find keep-case compound word\n\nstatic void find_word(matchinf_T *mip, int mode);\nstatic void find_prefix(matchinf_T *mip, int mode);\nstatic int fold_more(matchinf_T *mip);\nstatic void spell_load_cb(char_u *fname, void *cookie);\nstatic int count_syllables(slang_T *slang, char_u *word);\nstatic void clear_midword(win_T *buf);\nstatic void use_midword(slang_T *lp, win_T *buf);\nstatic int find_region(char_u *rp, char_u *region);\nstatic void spell_soundfold_sofo(slang_T *slang, char_u *inword, char_u *res);\nstatic void spell_soundfold_sal(slang_T *slang, char_u *inword, char_u *res);\nstatic void spell_soundfold_wsal(slang_T *slang, char_u *inword, char_u *res);\nstatic void dump_word(slang_T *slang, char_u *word, char_u *pat, int *dir, int round, int flags, linenr_T lnum);\nstatic linenr_T dump_prefixes(slang_T *slang, char_u *word, char_u *pat, int *dir, int round, int flags, linenr_T startlnum);\n\n/*\n * Main spell-checking function.\n * \"ptr\" points to a character that could be the start of a word.\n * \"*attrp\" is set to the highlight index for a badly spelled word.  For a\n * non-word or when it's OK it remains unchanged.\n * This must only be called when 'spelllang' is not empty.\n *\n * \"capcol\" is used to check for a Capitalised word after the end of a\n * sentence.  If it's zero then perform the check.  Return the column where to\n * check next, or -1 when no sentence end was found.  If it's NULL then don't\n * worry.\n *\n * Returns the length of the word in bytes, also when it's OK, so that the\n * caller can skip over the word.\n */\n    int\nspell_check(\n    win_T\t*wp,\t\t// current window\n    char_u\t*ptr,\n    hlf_T\t*attrp,\n    int\t\t*capcol,\t// column to check for Capital\n    int\t\tdocount)\t// count good words\n{\n    matchinf_T\tmi;\t\t// Most things are put in \"mi\" so that it can\n\t\t\t\t// be passed to functions quickly.\n    int\t\tnrlen = 0;\t// found a number first\n    int\t\tc;\n    int\t\twrongcaplen = 0;\n    int\t\tlpi;\n    int\t\tcount_word = docount;\n    int\t\tuse_camel_case = *wp->w_s->b_p_spo != NUL;\n    int\t\tcamel_case = 0;\n\n    // A word never starts at a space or a control character.  Return quickly\n    // then, skipping over the character.\n    if (*ptr <= ' ')\n\treturn 1;\n\n    // Return here when loading language files failed.\n    if (wp->w_s->b_langp.ga_len == 0)\n\treturn 1;\n\n    CLEAR_FIELD(mi);\n\n    // A number is always OK.  Also skip hexadecimal numbers 0xFF99 and\n    // 0X99FF.  But always do check spelling to find \"3GPP\" and \"11\n    // julifeest\".\n    if (*ptr >= '0' && *ptr <= '9')\n    {\n\tif (*ptr == '0' && (ptr[1] == 'b' || ptr[1] == 'B'))\n\t    mi.mi_end = skipbin(ptr + 2);\n\telse if (*ptr == '0' && (ptr[1] == 'x' || ptr[1] == 'X'))\n\t    mi.mi_end = skiphex(ptr + 2);\n\telse\n\t    mi.mi_end = skipdigits(ptr);\n\tnrlen = (int)(mi.mi_end - ptr);\n    }\n\n    // Find the normal end of the word (until the next non-word character).\n    mi.mi_word = ptr;\n    mi.mi_fend = ptr;\n    if (spell_iswordp(mi.mi_fend, wp))\n    {\n\tint prev_upper;\n\tint this_upper = FALSE;  // init for gcc\n\n\tif (use_camel_case)\n\t{\n\t    c = PTR2CHAR(mi.mi_fend);\n\t    this_upper = SPELL_ISUPPER(c);\n\t}\n\n\tdo\n\t{\n\t    MB_PTR_ADV(mi.mi_fend);\n\t    if (use_camel_case)\n\t    {\n\t\tprev_upper = this_upper;\n\t\tc = PTR2CHAR(mi.mi_fend);\n\t\tthis_upper = SPELL_ISUPPER(c);\n\t\tcamel_case = !prev_upper && this_upper;\n\t    }\n\t} while (*mi.mi_fend != NUL && spell_iswordp(mi.mi_fend, wp)\n\t\t\t\t\t\t\t       && !camel_case);\n\n\tif (capcol != NULL && *capcol == 0 && wp->w_s->b_cap_prog != NULL)\n\t{\n\t    // Check word starting with capital letter.\n\t    c = PTR2CHAR(ptr);\n\t    if (!SPELL_ISUPPER(c))\n\t\twrongcaplen = (int)(mi.mi_fend - ptr);\n\t}\n    }\n    if (capcol != NULL)\n\t*capcol = -1;\n\n    // We always use the characters up to the next non-word character,\n    // also for bad words.\n    mi.mi_end = mi.mi_fend;\n\n    // Check caps type later.\n    mi.mi_capflags = 0;\n    mi.mi_cend = NULL;\n    mi.mi_win = wp;\n\n    // case-fold the word with one non-word character, so that we can check\n    // for the word end.\n    if (*mi.mi_fend != NUL)\n\tMB_PTR_ADV(mi.mi_fend);\n\n    (void)spell_casefold(wp, ptr, (int)(mi.mi_fend - ptr), mi.mi_fword,\n\t\t\t\t\t\t\t     MAXWLEN + 1);\n    mi.mi_fwordlen = (int)STRLEN(mi.mi_fword);\n\n    if (camel_case && mi.mi_fwordlen > 0)\n\t// Introduce a fake word end space into the folded word.\n\tmi.mi_fword[mi.mi_fwordlen - 1] = ' ';\n\n    // The word is bad unless we recognize it.\n    mi.mi_result = SP_BAD;\n    mi.mi_result2 = SP_BAD;\n\n    /*\n     * Loop over the languages specified in 'spelllang'.\n     * We check them all, because a word may be matched longer in another\n     * language.\n     */\n    for (lpi = 0; lpi < wp->w_s->b_langp.ga_len; ++lpi)\n    {\n\tmi.mi_lp = LANGP_ENTRY(wp->w_s->b_langp, lpi);\n\n\t// If reloading fails the language is still in the list but everything\n\t// has been cleared.\n\tif (mi.mi_lp->lp_slang->sl_fidxs == NULL)\n\t    continue;\n\n\t// Check for a matching word in case-folded words.\n\tfind_word(&mi, FIND_FOLDWORD);\n\n\t// Check for a matching word in keep-case words.\n\tfind_word(&mi, FIND_KEEPWORD);\n\n\t// Check for matching prefixes.\n\tfind_prefix(&mi, FIND_FOLDWORD);\n\n\t// For a NOBREAK language, may want to use a word without a following\n\t// word as a backup.\n\tif (mi.mi_lp->lp_slang->sl_nobreak && mi.mi_result == SP_BAD\n\t\t\t\t\t\t   && mi.mi_result2 != SP_BAD)\n\t{\n\t    mi.mi_result = mi.mi_result2;\n\t    mi.mi_end = mi.mi_end2;\n\t}\n\n\t// Count the word in the first language where it's found to be OK.\n\tif (count_word && mi.mi_result == SP_OK)\n\t{\n\t    count_common_word(mi.mi_lp->lp_slang, ptr,\n\t\t\t\t\t\t   (int)(mi.mi_end - ptr), 1);\n\t    count_word = FALSE;\n\t}\n    }\n\n    if (mi.mi_result != SP_OK)\n    {\n\t// If we found a number skip over it.  Allows for \"42nd\".  Do flag\n\t// rare and local words, e.g., \"3GPP\".\n\tif (nrlen > 0)\n\t{\n\t    if (mi.mi_result == SP_BAD || mi.mi_result == SP_BANNED)\n\t\treturn nrlen;\n\t}\n\n\t// When we are at a non-word character there is no error, just\n\t// skip over the character (try looking for a word after it).\n\telse if (!spell_iswordp_nmw(ptr, wp))\n\t{\n\t    if (capcol != NULL && wp->w_s->b_cap_prog != NULL)\n\t    {\n\t\tregmatch_T\tregmatch;\n\t\tint\t\tr;\n\n\t\t// Check for end of sentence.\n\t\tregmatch.regprog = wp->w_s->b_cap_prog;\n\t\tregmatch.rm_ic = FALSE;\n\t\tr = vim_regexec(&regmatch, ptr, 0);\n\t\twp->w_s->b_cap_prog = regmatch.regprog;\n\t\tif (r)\n\t\t    *capcol = (int)(regmatch.endp[0] - ptr);\n\t    }\n\n\t    if (has_mbyte)\n\t\treturn (*mb_ptr2len)(ptr);\n\t    return 1;\n\t}\n\telse if (mi.mi_end == ptr)\n\t    // Always include at least one character.  Required for when there\n\t    // is a mixup in \"midword\".\n\t    MB_PTR_ADV(mi.mi_end);\n\telse if (mi.mi_result == SP_BAD\n\t\t&& LANGP_ENTRY(wp->w_s->b_langp, 0)->lp_slang->sl_nobreak)\n\t{\n\t    char_u\t*p, *fp;\n\t    int\t\tsave_result = mi.mi_result;\n\n\t    // First language in 'spelllang' is NOBREAK.  Find first position\n\t    // at which any word would be valid.\n\t    mi.mi_lp = LANGP_ENTRY(wp->w_s->b_langp, 0);\n\t    if (mi.mi_lp->lp_slang->sl_fidxs != NULL)\n\t    {\n\t\tp = mi.mi_word;\n\t\tfp = mi.mi_fword;\n\t\tfor (;;)\n\t\t{\n\t\t    MB_PTR_ADV(p);\n\t\t    MB_PTR_ADV(fp);\n\t\t    if (p >= mi.mi_end)\n\t\t\tbreak;\n\t\t    mi.mi_compoff = (int)(fp - mi.mi_fword);\n\t\t    find_word(&mi, FIND_COMPOUND);\n\t\t    if (mi.mi_result != SP_BAD)\n\t\t    {\n\t\t\tmi.mi_end = p;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t\tmi.mi_result = save_result;\n\t    }\n\t}\n\n\tif (mi.mi_result == SP_BAD || mi.mi_result == SP_BANNED)\n\t    *attrp = HLF_SPB;\n\telse if (mi.mi_result == SP_RARE)\n\t    *attrp = HLF_SPR;\n\telse\n\t    *attrp = HLF_SPL;\n    }\n\n    if (wrongcaplen > 0 && (mi.mi_result == SP_OK || mi.mi_result == SP_RARE))\n    {\n\t// Report SpellCap only when the word isn't badly spelled.\n\t*attrp = HLF_SPC;\n\treturn wrongcaplen;\n    }\n\n    return (int)(mi.mi_end - ptr);\n}\n\n/*\n * Check if the word at \"mip->mi_word\" is in the tree.\n * When \"mode\" is FIND_FOLDWORD check in fold-case word tree.\n * When \"mode\" is FIND_KEEPWORD check in keep-case word tree.\n * When \"mode\" is FIND_PREFIX check for word after prefix in fold-case word\n * tree.\n *\n * For a match mip->mi_result is updated.\n */\n    static void\nfind_word(matchinf_T *mip, int mode)\n{\n    idx_T\tarridx = 0;\n    int\t\tendlen[MAXWLEN];    // length at possible word endings\n    idx_T\tendidx[MAXWLEN];    // possible word endings\n    int\t\tendidxcnt = 0;\n    int\t\tlen;\n    int\t\twlen = 0;\n    int\t\tflen;\n    int\t\tc;\n    char_u\t*ptr;\n    idx_T\tlo, hi, m;\n    char_u\t*s;\n    char_u\t*p;\n    int\t\tres = SP_BAD;\n    slang_T\t*slang = mip->mi_lp->lp_slang;\n    unsigned\tflags;\n    char_u\t*byts;\n    idx_T\t*idxs;\n    int\t\tword_ends;\n    int\t\tprefix_found;\n    int\t\tnobreak_result;\n\n    if (mode == FIND_KEEPWORD || mode == FIND_KEEPCOMPOUND)\n    {\n\t// Check for word with matching case in keep-case tree.\n\tptr = mip->mi_word;\n\tflen = 9999;\t\t    // no case folding, always enough bytes\n\tbyts = slang->sl_kbyts;\n\tidxs = slang->sl_kidxs;\n\n\tif (mode == FIND_KEEPCOMPOUND)\n\t    // Skip over the previously found word(s).\n\t    wlen += mip->mi_compoff;\n    }\n    else\n    {\n\t// Check for case-folded in case-folded tree.\n\tptr = mip->mi_fword;\n\tflen = mip->mi_fwordlen;    // available case-folded bytes\n\tbyts = slang->sl_fbyts;\n\tidxs = slang->sl_fidxs;\n\n\tif (mode == FIND_PREFIX)\n\t{\n\t    // Skip over the prefix.\n\t    wlen = mip->mi_prefixlen;\n\t    flen -= mip->mi_prefixlen;\n\t}\n\telse if (mode == FIND_COMPOUND)\n\t{\n\t    // Skip over the previously found word(s).\n\t    wlen = mip->mi_compoff;\n\t    flen -= mip->mi_compoff;\n\t}\n\n    }\n\n    if (byts == NULL)\n\treturn;\t\t\t// array is empty\n\n    /*\n     * Repeat advancing in the tree until:\n     * - there is a byte that doesn't match,\n     * - we reach the end of the tree,\n     * - or we reach the end of the line.\n     */\n    for (;;)\n    {\n\tif (flen <= 0 && *mip->mi_fend != NUL)\n\t    flen = fold_more(mip);\n\n\tlen = byts[arridx++];\n\n\t// If the first possible byte is a zero the word could end here.\n\t// Remember this index, we first check for the longest word.\n\tif (byts[arridx] == 0)\n\t{\n\t    if (endidxcnt == MAXWLEN)\n\t    {\n\t\t// Must be a corrupted spell file.\n\t\temsg(_(e_format_error_in_spell_file));\n\t\treturn;\n\t    }\n\t    endlen[endidxcnt] = wlen;\n\t    endidx[endidxcnt++] = arridx++;\n\t    --len;\n\n\t    // Skip over the zeros, there can be several flag/region\n\t    // combinations.\n\t    while (len > 0 && byts[arridx] == 0)\n\t    {\n\t\t++arridx;\n\t\t--len;\n\t    }\n\t    if (len == 0)\n\t\tbreak;\t    // no children, word must end here\n\t}\n\n\t// Stop looking at end of the line.\n\tif (ptr[wlen] == NUL)\n\t    break;\n\n\t// Perform a binary search in the list of accepted bytes.\n\tc = ptr[wlen];\n\tif (c == TAB)\t    // <Tab> is handled like <Space>\n\t    c = ' ';\n\tlo = arridx;\n\thi = arridx + len - 1;\n\twhile (lo < hi)\n\t{\n\t    m = (lo + hi) / 2;\n\t    if (byts[m] > c)\n\t\thi = m - 1;\n\t    else if (byts[m] < c)\n\t\tlo = m + 1;\n\t    else\n\t    {\n\t\tlo = hi = m;\n\t\tbreak;\n\t    }\n\t}\n\n\t// Stop if there is no matching byte.\n\tif (hi < lo || byts[lo] != c)\n\t    break;\n\n\t// Continue at the child (if there is one).\n\tarridx = idxs[lo];\n\t++wlen;\n\t--flen;\n\n\t// One space in the good word may stand for several spaces in the\n\t// checked word.\n\tif (c == ' ')\n\t{\n\t    for (;;)\n\t    {\n\t\tif (flen <= 0 && *mip->mi_fend != NUL)\n\t\t    flen = fold_more(mip);\n\t\tif (ptr[wlen] != ' ' && ptr[wlen] != TAB)\n\t\t    break;\n\t\t++wlen;\n\t\t--flen;\n\t    }\n\t}\n    }\n\n    /*\n     * Verify that one of the possible endings is valid.  Try the longest\n     * first.\n     */\n    while (endidxcnt > 0)\n    {\n\t--endidxcnt;\n\tarridx = endidx[endidxcnt];\n\twlen = endlen[endidxcnt];\n\n\tif ((*mb_head_off)(ptr, ptr + wlen) > 0)\n\t    continue;\t    // not at first byte of character\n\tif (spell_iswordp(ptr + wlen, mip->mi_win))\n\t{\n\t    if (slang->sl_compprog == NULL && !slang->sl_nobreak)\n\t\tcontinue;\t    // next char is a word character\n\t    word_ends = FALSE;\n\t}\n\telse\n\t    word_ends = TRUE;\n\t// The prefix flag is before compound flags.  Once a valid prefix flag\n\t// has been found we try compound flags.\n\tprefix_found = FALSE;\n\n\tif (mode != FIND_KEEPWORD && has_mbyte)\n\t{\n\t    // Compute byte length in original word, length may change\n\t    // when folding case.  This can be slow, take a shortcut when the\n\t    // case-folded word is equal to the keep-case word.\n\t    p = mip->mi_word;\n\t    if (STRNCMP(ptr, p, wlen) != 0)\n\t    {\n\t\tfor (s = ptr; s < ptr + wlen; MB_PTR_ADV(s))\n\t\t    MB_PTR_ADV(p);\n\t\twlen = (int)(p - mip->mi_word);\n\t    }\n\t}\n\n\t// Check flags and region.  For FIND_PREFIX check the condition and\n\t// prefix ID.\n\t// Repeat this if there are more flags/region alternatives until there\n\t// is a match.\n\tres = SP_BAD;\n\tfor (len = byts[arridx - 1]; len > 0 && byts[arridx] == 0;\n\t\t\t\t\t\t\t      --len, ++arridx)\n\t{\n\t    flags = idxs[arridx];\n\n\t    // For the fold-case tree check that the case of the checked word\n\t    // matches with what the word in the tree requires.\n\t    // For keep-case tree the case is always right.  For prefixes we\n\t    // don't bother to check.\n\t    if (mode == FIND_FOLDWORD)\n\t    {\n\t\tif (mip->mi_cend != mip->mi_word + wlen)\n\t\t{\n\t\t    // mi_capflags was set for a different word length, need\n\t\t    // to do it again.\n\t\t    mip->mi_cend = mip->mi_word + wlen;\n\t\t    mip->mi_capflags = captype(mip->mi_word, mip->mi_cend);\n\t\t}\n\n\t\tif (mip->mi_capflags == WF_KEEPCAP\n\t\t\t\t|| !spell_valid_case(mip->mi_capflags, flags))\n\t\t    continue;\n\t    }\n\n\t    // When mode is FIND_PREFIX the word must support the prefix:\n\t    // check the prefix ID and the condition.  Do that for the list at\n\t    // mip->mi_prefarridx that find_prefix() filled.\n\t    else if (mode == FIND_PREFIX && !prefix_found)\n\t    {\n\t\tc = valid_word_prefix(mip->mi_prefcnt, mip->mi_prefarridx,\n\t\t\t\t    flags,\n\t\t\t\t    mip->mi_word + mip->mi_cprefixlen, slang,\n\t\t\t\t    FALSE);\n\t\tif (c == 0)\n\t\t    continue;\n\n\t\t// Use the WF_RARE flag for a rare prefix.\n\t\tif (c & WF_RAREPFX)\n\t\t    flags |= WF_RARE;\n\t\tprefix_found = TRUE;\n\t    }\n\n\t    if (slang->sl_nobreak)\n\t    {\n\t\tif ((mode == FIND_COMPOUND || mode == FIND_KEEPCOMPOUND)\n\t\t\t&& (flags & WF_BANNED) == 0)\n\t\t{\n\t\t    // NOBREAK: found a valid following word.  That's all we\n\t\t    // need to know, so return.\n\t\t    mip->mi_result = SP_OK;\n\t\t    break;\n\t\t}\n\t    }\n\n\t    else if ((mode == FIND_COMPOUND || mode == FIND_KEEPCOMPOUND\n\t\t\t\t\t\t\t\t|| !word_ends))\n\t    {\n\t\t// If there is no compound flag or the word is shorter than\n\t\t// COMPOUNDMIN reject it quickly.\n\t\t// Makes you wonder why someone puts a compound flag on a word\n\t\t// that's too short...  Myspell compatibility requires this\n\t\t// anyway.\n\t\tif (((unsigned)flags >> 24) == 0\n\t\t\t     || wlen - mip->mi_compoff < slang->sl_compminlen)\n\t\t    continue;\n\t\t// For multi-byte chars check character length against\n\t\t// COMPOUNDMIN.\n\t\tif (has_mbyte\n\t\t\t&& slang->sl_compminlen > 0\n\t\t\t&& mb_charlen_len(mip->mi_word + mip->mi_compoff,\n\t\t\t\twlen - mip->mi_compoff) < slang->sl_compminlen)\n\t\t\tcontinue;\n\n\t\t// Limit the number of compound words to COMPOUNDWORDMAX if no\n\t\t// maximum for syllables is specified.\n\t\tif (!word_ends && mip->mi_complen + mip->mi_compextra + 2\n\t\t\t\t\t\t\t   > slang->sl_compmax\n\t\t\t\t\t   && slang->sl_compsylmax == MAXWLEN)\n\t\t    continue;\n\n\t\t// Don't allow compounding on a side where an affix was added,\n\t\t// unless COMPOUNDPERMITFLAG was used.\n\t\tif (mip->mi_complen > 0 && (flags & WF_NOCOMPBEF))\n\t\t    continue;\n\t\tif (!word_ends && (flags & WF_NOCOMPAFT))\n\t\t    continue;\n\n\t\t// Quickly check if compounding is possible with this flag.\n\t\tif (!byte_in_str(mip->mi_complen == 0\n\t\t\t\t\t? slang->sl_compstartflags\n\t\t\t\t\t: slang->sl_compallflags,\n\t\t\t\t\t    ((unsigned)flags >> 24)))\n\t\t    continue;\n\n\t\t// If there is a match with a CHECKCOMPOUNDPATTERN rule\n\t\t// discard the compound word.\n\t\tif (match_checkcompoundpattern(ptr, wlen, &slang->sl_comppat))\n\t\t    continue;\n\n\t\tif (mode == FIND_COMPOUND)\n\t\t{\n\t\t    int\t    capflags;\n\n\t\t    // Need to check the caps type of the appended compound\n\t\t    // word.\n\t\t    if (has_mbyte && STRNCMP(ptr, mip->mi_word,\n\t\t\t\t\t\t\tmip->mi_compoff) != 0)\n\t\t    {\n\t\t\t// case folding may have changed the length\n\t\t\tp = mip->mi_word;\n\t\t\tfor (s = ptr; s < ptr + mip->mi_compoff; MB_PTR_ADV(s))\n\t\t\t    MB_PTR_ADV(p);\n\t\t    }\n\t\t    else\n\t\t\tp = mip->mi_word + mip->mi_compoff;\n\t\t    capflags = captype(p, mip->mi_word + wlen);\n\t\t    if (capflags == WF_KEEPCAP || (capflags == WF_ALLCAP\n\t\t\t\t\t\t && (flags & WF_FIXCAP) != 0))\n\t\t\tcontinue;\n\n\t\t    if (capflags != WF_ALLCAP)\n\t\t    {\n\t\t\t// When the character before the word is a word\n\t\t\t// character we do not accept a Onecap word.  We do\n\t\t\t// accept a no-caps word, even when the dictionary\n\t\t\t// word specifies ONECAP.\n\t\t\tMB_PTR_BACK(mip->mi_word, p);\n\t\t\tif (spell_iswordp_nmw(p, mip->mi_win)\n\t\t\t\t? capflags == WF_ONECAP\n\t\t\t\t: (flags & WF_ONECAP) != 0\n\t\t\t\t\t\t     && capflags != WF_ONECAP)\n\t\t\t    continue;\n\t\t    }\n\t\t}\n\n\t\t// If the word ends the sequence of compound flags of the\n\t\t// words must match with one of the COMPOUNDRULE items and\n\t\t// the number of syllables must not be too large.\n\t\tmip->mi_compflags[mip->mi_complen] = ((unsigned)flags >> 24);\n\t\tmip->mi_compflags[mip->mi_complen + 1] = NUL;\n\t\tif (word_ends)\n\t\t{\n\t\t    char_u\tfword[MAXWLEN];\n\n\t\t    if (slang->sl_compsylmax < MAXWLEN)\n\t\t    {\n\t\t\t// \"fword\" is only needed for checking syllables.\n\t\t\tif (ptr == mip->mi_word)\n\t\t\t    (void)spell_casefold(mip->mi_win,\n\t\t\t\t\t\t    ptr, wlen, fword, MAXWLEN);\n\t\t\telse\n\t\t\t    vim_strncpy(fword, ptr, endlen[endidxcnt]);\n\t\t    }\n\t\t    if (!can_compound(slang, fword, mip->mi_compflags))\n\t\t\tcontinue;\n\t\t}\n\t\telse if (slang->sl_comprules != NULL\n\t\t\t     && !match_compoundrule(slang, mip->mi_compflags))\n\t\t    // The compound flags collected so far do not match any\n\t\t    // COMPOUNDRULE, discard the compounded word.\n\t\t    continue;\n\t    }\n\n\t    // Check NEEDCOMPOUND: can't use word without compounding.\n\t    else if (flags & WF_NEEDCOMP)\n\t\tcontinue;\n\n\t    nobreak_result = SP_OK;\n\n\t    if (!word_ends)\n\t    {\n\t\tint\tsave_result = mip->mi_result;\n\t\tchar_u\t*save_end = mip->mi_end;\n\t\tlangp_T\t*save_lp = mip->mi_lp;\n\t\tint\tlpi;\n\n\t\t// Check that a valid word follows.  If there is one and we\n\t\t// are compounding, it will set \"mi_result\", thus we are\n\t\t// always finished here.  For NOBREAK we only check that a\n\t\t// valid word follows.\n\t\t// Recursive!\n\t\tif (slang->sl_nobreak)\n\t\t    mip->mi_result = SP_BAD;\n\n\t\t// Find following word in case-folded tree.\n\t\tmip->mi_compoff = endlen[endidxcnt];\n\t\tif (has_mbyte && mode == FIND_KEEPWORD)\n\t\t{\n\t\t    // Compute byte length in case-folded word from \"wlen\":\n\t\t    // byte length in keep-case word.  Length may change when\n\t\t    // folding case.  This can be slow, take a shortcut when\n\t\t    // the case-folded word is equal to the keep-case word.\n\t\t    p = mip->mi_fword;\n\t\t    if (STRNCMP(ptr, p, wlen) != 0)\n\t\t    {\n\t\t\tfor (s = ptr; s < ptr + wlen; MB_PTR_ADV(s))\n\t\t\t    MB_PTR_ADV(p);\n\t\t\tmip->mi_compoff = (int)(p - mip->mi_fword);\n\t\t    }\n\t\t}\n#if 0 // Disabled, see below\n\t\tc = mip->mi_compoff;\n#endif\n\t\t++mip->mi_complen;\n\t\tif (flags & WF_COMPROOT)\n\t\t    ++mip->mi_compextra;\n\n\t\t// For NOBREAK we need to try all NOBREAK languages, at least\n\t\t// to find the \".add\" file(s).\n\t\tfor (lpi = 0; lpi < mip->mi_win->w_s->b_langp.ga_len; ++lpi)\n\t\t{\n\t\t    if (slang->sl_nobreak)\n\t\t    {\n\t\t\tmip->mi_lp = LANGP_ENTRY(mip->mi_win->w_s->b_langp, lpi);\n\t\t\tif (mip->mi_lp->lp_slang->sl_fidxs == NULL\n\t\t\t\t\t || !mip->mi_lp->lp_slang->sl_nobreak)\n\t\t\t    continue;\n\t\t    }\n\n\t\t    find_word(mip, FIND_COMPOUND);\n\n\t\t    // When NOBREAK any word that matches is OK.  Otherwise we\n\t\t    // need to find the longest match, thus try with keep-case\n\t\t    // and prefix too.\n\t\t    if (!slang->sl_nobreak || mip->mi_result == SP_BAD)\n\t\t    {\n\t\t\t// Find following word in keep-case tree.\n\t\t\tmip->mi_compoff = wlen;\n\t\t\tfind_word(mip, FIND_KEEPCOMPOUND);\n\n#if 0\t    // Disabled, a prefix must not appear halfway a compound word,\n\t    // unless the COMPOUNDPERMITFLAG is used and then it can't be a\n\t    // postponed prefix.\n\t\t\tif (!slang->sl_nobreak || mip->mi_result == SP_BAD)\n\t\t\t{\n\t\t\t    // Check for following word with prefix.\n\t\t\t    mip->mi_compoff = c;\n\t\t\t    find_prefix(mip, FIND_COMPOUND);\n\t\t\t}\n#endif\n\t\t    }\n\n\t\t    if (!slang->sl_nobreak)\n\t\t\tbreak;\n\t\t}\n\t\t--mip->mi_complen;\n\t\tif (flags & WF_COMPROOT)\n\t\t    --mip->mi_compextra;\n\t\tmip->mi_lp = save_lp;\n\n\t\tif (slang->sl_nobreak)\n\t\t{\n\t\t    nobreak_result = mip->mi_result;\n\t\t    mip->mi_result = save_result;\n\t\t    mip->mi_end = save_end;\n\t\t}\n\t\telse\n\t\t{\n\t\t    if (mip->mi_result == SP_OK)\n\t\t\tbreak;\n\t\t    continue;\n\t\t}\n\t    }\n\n\t    if (flags & WF_BANNED)\n\t\tres = SP_BANNED;\n\t    else if (flags & WF_REGION)\n\t    {\n\t\t// Check region.\n\t\tif ((mip->mi_lp->lp_region & (flags >> 16)) != 0)\n\t\t    res = SP_OK;\n\t\telse\n\t\t    res = SP_LOCAL;\n\t    }\n\t    else if (flags & WF_RARE)\n\t\tres = SP_RARE;\n\t    else\n\t\tres = SP_OK;\n\n\t    // Always use the longest match and the best result.  For NOBREAK\n\t    // we separately keep the longest match without a following good\n\t    // word as a fall-back.\n\t    if (nobreak_result == SP_BAD)\n\t    {\n\t\tif (mip->mi_result2 > res)\n\t\t{\n\t\t    mip->mi_result2 = res;\n\t\t    mip->mi_end2 = mip->mi_word + wlen;\n\t\t}\n\t\telse if (mip->mi_result2 == res\n\t\t\t\t\t&& mip->mi_end2 < mip->mi_word + wlen)\n\t\t    mip->mi_end2 = mip->mi_word + wlen;\n\t    }\n\t    else if (mip->mi_result > res)\n\t    {\n\t\tmip->mi_result = res;\n\t\tmip->mi_end = mip->mi_word + wlen;\n\t    }\n\t    else if (mip->mi_result == res && mip->mi_end < mip->mi_word + wlen)\n\t\tmip->mi_end = mip->mi_word + wlen;\n\n\t    if (mip->mi_result == SP_OK)\n\t\tbreak;\n\t}\n\n\tif (mip->mi_result == SP_OK)\n\t    break;\n    }\n}\n\n/*\n * Return TRUE if there is a match between the word ptr[wlen] and\n * CHECKCOMPOUNDPATTERN rules, assuming that we will concatenate with another\n * word.\n * A match means that the first part of CHECKCOMPOUNDPATTERN matches at the\n * end of ptr[wlen] and the second part matches after it.\n */\n    int\nmatch_checkcompoundpattern(\n    char_u\t*ptr,\n    int\t\twlen,\n    garray_T\t*gap)  // &sl_comppat\n{\n    int\t\ti;\n    char_u\t*p;\n    int\t\tlen;\n\n    for (i = 0; i + 1 < gap->ga_len; i += 2)\n    {\n\tp = ((char_u **)gap->ga_data)[i + 1];\n\tif (STRNCMP(ptr + wlen, p, STRLEN(p)) == 0)\n\t{\n\t    // Second part matches at start of following compound word, now\n\t    // check if first part matches at end of previous word.\n\t    p = ((char_u **)gap->ga_data)[i];\n\t    len = (int)STRLEN(p);\n\t    if (len <= wlen && STRNCMP(ptr + wlen - len, p, len) == 0)\n\t\treturn TRUE;\n\t}\n    }\n    return FALSE;\n}\n\n/*\n * Return TRUE if \"flags\" is a valid sequence of compound flags and \"word\"\n * does not have too many syllables.\n */\n    int\ncan_compound(slang_T *slang, char_u *word, char_u *flags)\n{\n    char_u\tuflags[MAXWLEN * 2];\n    int\t\ti;\n    char_u\t*p;\n\n    if (slang->sl_compprog == NULL)\n\treturn FALSE;\n    if (enc_utf8)\n    {\n\t// Need to convert the single byte flags to utf8 characters.\n\tp = uflags;\n\tfor (i = 0; flags[i] != NUL; ++i)\n\t    p += utf_char2bytes(flags[i], p);\n\t*p = NUL;\n\tp = uflags;\n    }\n    else\n\tp = flags;\n    if (!vim_regexec_prog(&slang->sl_compprog, FALSE, p, 0))\n\treturn FALSE;\n\n    // Count the number of syllables.  This may be slow, do it last.  If there\n    // are too many syllables AND the number of compound words is above\n    // COMPOUNDWORDMAX then compounding is not allowed.\n    if (slang->sl_compsylmax < MAXWLEN\n\t\t       && count_syllables(slang, word) > slang->sl_compsylmax)\n\treturn (int)STRLEN(flags) < slang->sl_compmax;\n    return TRUE;\n}\n\n/*\n * Return TRUE if the compound flags in compflags[] match the start of any\n * compound rule.  This is used to stop trying a compound if the flags\n * collected so far can't possibly match any compound rule.\n * Caller must check that slang->sl_comprules is not NULL.\n */\n    int\nmatch_compoundrule(slang_T *slang, char_u *compflags)\n{\n    char_u\t*p;\n    int\t\ti;\n    int\t\tc;\n\n    // loop over all the COMPOUNDRULE entries\n    for (p = slang->sl_comprules; *p != NUL; ++p)\n    {\n\t// loop over the flags in the compound word we have made, match\n\t// them against the current rule entry\n\tfor (i = 0; ; ++i)\n\t{\n\t    c = compflags[i];\n\t    if (c == NUL)\n\t\t// found a rule that matches for the flags we have so far\n\t\treturn TRUE;\n\t    if (*p == '/' || *p == NUL)\n\t\tbreak;  // end of rule, it's too short\n\t    if (*p == '[')\n\t    {\n\t\tint match = FALSE;\n\n\t\t// compare against all the flags in []\n\t\t++p;\n\t\twhile (*p != ']' && *p != NUL)\n\t\t    if (*p++ == c)\n\t\t\tmatch = TRUE;\n\t\tif (!match)\n\t\t    break;  // none matches\n\t    }\n\t    else if (*p != c)\n\t\tbreak;  // flag of word doesn't match flag in pattern\n\t    ++p;\n\t}\n\n\t// Skip to the next \"/\", where the next pattern starts.\n\tp = vim_strchr(p, '/');\n\tif (p == NULL)\n\t    break;\n    }\n\n    // Checked all the rules and none of them match the flags, so there\n    // can't possibly be a compound starting with these flags.\n    return FALSE;\n}\n\n/*\n * Return non-zero if the prefix indicated by \"arridx\" matches with the prefix\n * ID in \"flags\" for the word \"word\".\n * The WF_RAREPFX flag is included in the return value for a rare prefix.\n */\n    int\nvalid_word_prefix(\n    int\t\ttotprefcnt,\t// nr of prefix IDs\n    int\t\tarridx,\t\t// idx in sl_pidxs[]\n    int\t\tflags,\n    char_u\t*word,\n    slang_T\t*slang,\n    int\t\tcond_req)\t// only use prefixes with a condition\n{\n    int\t\tprefcnt;\n    int\t\tpidx;\n    regprog_T\t**rp;\n    int\t\tprefid;\n\n    prefid = (unsigned)flags >> 24;\n    for (prefcnt = totprefcnt - 1; prefcnt >= 0; --prefcnt)\n    {\n\tpidx = slang->sl_pidxs[arridx + prefcnt];\n\n\t// Check the prefix ID.\n\tif (prefid != (pidx & 0xff))\n\t    continue;\n\n\t// Check if the prefix doesn't combine and the word already has a\n\t// suffix.\n\tif ((flags & WF_HAS_AFF) && (pidx & WF_PFX_NC))\n\t    continue;\n\n\t// Check the condition, if there is one.  The condition index is\n\t// stored in the two bytes above the prefix ID byte.\n\trp = &slang->sl_prefprog[((unsigned)pidx >> 8) & 0xffff];\n\tif (*rp != NULL)\n\t{\n\t    if (!vim_regexec_prog(rp, FALSE, word, 0))\n\t\tcontinue;\n\t}\n\telse if (cond_req)\n\t    continue;\n\n\t// It's a match!  Return the WF_ flags.\n\treturn pidx;\n    }\n    return 0;\n}\n\n/*\n * Check if the word at \"mip->mi_word\" has a matching prefix.\n * If it does, then check the following word.\n *\n * If \"mode\" is \"FIND_COMPOUND\" then do the same after another word, find a\n * prefix in a compound word.\n *\n * For a match mip->mi_result is updated.\n */\n    static void\nfind_prefix(matchinf_T *mip, int mode)\n{\n    idx_T\tarridx = 0;\n    int\t\tlen;\n    int\t\twlen = 0;\n    int\t\tflen;\n    int\t\tc;\n    char_u\t*ptr;\n    idx_T\tlo, hi, m;\n    slang_T\t*slang = mip->mi_lp->lp_slang;\n    char_u\t*byts;\n    idx_T\t*idxs;\n\n    byts = slang->sl_pbyts;\n    if (byts == NULL)\n\treturn;\t\t\t// array is empty\n\n    // We use the case-folded word here, since prefixes are always\n    // case-folded.\n    ptr = mip->mi_fword;\n    flen = mip->mi_fwordlen;    // available case-folded bytes\n    if (mode == FIND_COMPOUND)\n    {\n\t// Skip over the previously found word(s).\n\tptr += mip->mi_compoff;\n\tflen -= mip->mi_compoff;\n    }\n    idxs = slang->sl_pidxs;\n\n    /*\n     * Repeat advancing in the tree until:\n     * - there is a byte that doesn't match,\n     * - we reach the end of the tree,\n     * - or we reach the end of the line.\n     */\n    for (;;)\n    {\n\tif (flen == 0 && *mip->mi_fend != NUL)\n\t    flen = fold_more(mip);\n\n\tlen = byts[arridx++];\n\n\t// If the first possible byte is a zero the prefix could end here.\n\t// Check if the following word matches and supports the prefix.\n\tif (byts[arridx] == 0)\n\t{\n\t    // There can be several prefixes with different conditions.  We\n\t    // try them all, since we don't know which one will give the\n\t    // longest match.  The word is the same each time, pass the list\n\t    // of possible prefixes to find_word().\n\t    mip->mi_prefarridx = arridx;\n\t    mip->mi_prefcnt = len;\n\t    while (len > 0 && byts[arridx] == 0)\n\t    {\n\t\t++arridx;\n\t\t--len;\n\t    }\n\t    mip->mi_prefcnt -= len;\n\n\t    // Find the word that comes after the prefix.\n\t    mip->mi_prefixlen = wlen;\n\t    if (mode == FIND_COMPOUND)\n\t\t// Skip over the previously found word(s).\n\t\tmip->mi_prefixlen += mip->mi_compoff;\n\n\t    if (has_mbyte)\n\t    {\n\t\t// Case-folded length may differ from original length.\n\t\tmip->mi_cprefixlen = nofold_len(mip->mi_fword,\n\t\t\t\t\t     mip->mi_prefixlen, mip->mi_word);\n\t    }\n\t    else\n\t\tmip->mi_cprefixlen = mip->mi_prefixlen;\n\t    find_word(mip, FIND_PREFIX);\n\n\n\t    if (len == 0)\n\t\tbreak;\t    // no children, word must end here\n\t}\n\n\t// Stop looking at end of the line.\n\tif (ptr[wlen] == NUL)\n\t    break;\n\n\t// Perform a binary search in the list of accepted bytes.\n\tc = ptr[wlen];\n\tlo = arridx;\n\thi = arridx + len - 1;\n\twhile (lo < hi)\n\t{\n\t    m = (lo + hi) / 2;\n\t    if (byts[m] > c)\n\t\thi = m - 1;\n\t    else if (byts[m] < c)\n\t\tlo = m + 1;\n\t    else\n\t    {\n\t\tlo = hi = m;\n\t\tbreak;\n\t    }\n\t}\n\n\t// Stop if there is no matching byte.\n\tif (hi < lo || byts[lo] != c)\n\t    break;\n\n\t// Continue at the child (if there is one).\n\tarridx = idxs[lo];\n\t++wlen;\n\t--flen;\n    }\n}\n\n/*\n * Need to fold at least one more character.  Do until next non-word character\n * for efficiency.  Include the non-word character too.\n * Return the length of the folded chars in bytes.\n */\n    static int\nfold_more(matchinf_T *mip)\n{\n    int\t\tflen;\n    char_u\t*p;\n\n    p = mip->mi_fend;\n    do\n\tMB_PTR_ADV(mip->mi_fend);\n    while (*mip->mi_fend != NUL && spell_iswordp(mip->mi_fend, mip->mi_win));\n\n    // Include the non-word character so that we can check for the word end.\n    if (*mip->mi_fend != NUL)\n\tMB_PTR_ADV(mip->mi_fend);\n\n    (void)spell_casefold(mip->mi_win, p, (int)(mip->mi_fend - p),\n\t\t\t     mip->mi_fword + mip->mi_fwordlen,\n\t\t\t     MAXWLEN - mip->mi_fwordlen);\n    flen = (int)STRLEN(mip->mi_fword + mip->mi_fwordlen);\n    mip->mi_fwordlen += flen;\n    return flen;\n}\n\n/*\n * Check case flags for a word.  Return TRUE if the word has the requested\n * case.\n */\n    int\nspell_valid_case(\n    int\t    wordflags,\t    // flags for the checked word.\n    int\t    treeflags)\t    // flags for the word in the spell tree\n{\n    return ((wordflags == WF_ALLCAP && (treeflags & WF_FIXCAP) == 0)\n\t    || ((treeflags & (WF_ALLCAP | WF_KEEPCAP)) == 0\n\t\t&& ((treeflags & WF_ONECAP) == 0\n\t\t\t\t\t   || (wordflags & WF_ONECAP) != 0)));\n}\n\n/*\n * Return TRUE if spell checking is enabled for \"wp\".\n */\n    int\nspell_check_window(win_T *wp)\n{\n    return wp->w_p_spell\n\t\t&& *wp->w_s->b_p_spl != NUL\n\t\t&& wp->w_s->b_langp.ga_len > 0\n\t\t&& *(char **)(wp->w_s->b_langp.ga_data) != NULL;\n}\n\n/*\n * Return TRUE and give an error if spell checking is not enabled.\n */\n    static int\nno_spell_checking(win_T *wp)\n{\n    if (spell_check_window(wp))\n\treturn FALSE;\n    emsg(_(e_spell_checking_is_not_possible));\n    return TRUE;\n}\n\n/*\n * Move to next spell error.\n * \"curline\" is FALSE for \"[s\", \"]s\", \"[S\" and \"]S\".\n * \"curline\" is TRUE to find word under/after cursor in the same line.\n * For Insert mode completion \"dir\" is BACKWARD and \"curline\" is TRUE: move\n * to after badly spelled word before the cursor.\n * Return 0 if not found, length of the badly spelled word otherwise.\n */\n    int\nspell_move_to(\n    win_T\t*wp,\n    int\t\tdir,\t\t// FORWARD or BACKWARD\n    int\t\tallwords,\t// TRUE for \"[s\"/\"]s\", FALSE for \"[S\"/\"]S\"\n    int\t\tcurline,\n    hlf_T\t*attrp)\t\t// return: attributes of bad word or NULL\n\t\t\t\t// (only when \"dir\" is FORWARD)\n{\n    linenr_T\tlnum;\n    pos_T\tfound_pos;\n    int\t\tfound_len = 0;\n    char_u\t*line;\n    char_u\t*p;\n    char_u\t*endp;\n    hlf_T\tattr = 0;\n    int\t\tlen;\n#ifdef FEAT_SYN_HL\n    int\t\thas_syntax = syntax_present(wp);\n#endif\n    int\t\tcol;\n    int\t\tcan_spell;\n    char_u\t*buf = NULL;\n    int\t\tbuflen = 0;\n    int\t\tskip = 0;\n    int\t\tcapcol = -1;\n    int\t\tfound_one = FALSE;\n    int\t\twrapped = FALSE;\n\n    if (no_spell_checking(wp))\n\treturn 0;\n\n    /*\n     * Start looking for bad word at the start of the line, because we can't\n     * start halfway a word, we don't know where it starts or ends.\n     *\n     * When searching backwards, we continue in the line to find the last\n     * bad word (in the cursor line: before the cursor).\n     *\n     * We concatenate the start of the next line, so that wrapped words work\n     * (e.g. \"et<line-break>cetera\").  Doesn't work when searching backwards\n     * though...\n     */\n    lnum = wp->w_cursor.lnum;\n    CLEAR_POS(&found_pos);\n\n    while (!got_int)\n    {\n\tint empty_line;\n\n\tline = ml_get_buf(wp->w_buffer, lnum, FALSE);\n\n\tlen = (int)STRLEN(line);\n\tif (buflen < len + MAXWLEN + 2)\n\t{\n\t    vim_free(buf);\n\t    buflen = len + MAXWLEN + 2;\n\t    buf = alloc(buflen);\n\t    if (buf == NULL)\n\t\tbreak;\n\t}\n\n\t// In first line check first word for Capital.\n\tif (lnum == 1)\n\t    capcol = 0;\n\n\t// For checking first word with a capital skip white space.\n\tif (capcol == 0)\n\t    capcol = getwhitecols(line);\n\telse if (curline && wp == curwin)\n\t{\n\t    // For spellbadword(): check if first word needs a capital.\n\t    col = getwhitecols(line);\n\t    if (check_need_cap(lnum, col))\n\t\tcapcol = col;\n\n\t    // Need to get the line again, may have looked at the previous\n\t    // one.\n\t    line = ml_get_buf(wp->w_buffer, lnum, FALSE);\n\t}\n\n\t// Copy the line into \"buf\" and append the start of the next line if\n\t// possible.  Note: this ml_get_buf() may make \"line\" invalid, check\n\t// for empty line first.\n\tempty_line = *skipwhite(line) == NUL;\n\tSTRCPY(buf, line);\n\tif (lnum < wp->w_buffer->b_ml.ml_line_count)\n\t    spell_cat_line(buf + STRLEN(buf),\n\t\t\t  ml_get_buf(wp->w_buffer, lnum + 1, FALSE), MAXWLEN);\n\n\tp = buf + skip;\n\tendp = buf + len;\n\twhile (p < endp)\n\t{\n\t    // When searching backward don't search after the cursor.  Unless\n\t    // we wrapped around the end of the buffer.\n\t    if (dir == BACKWARD\n\t\t    && lnum == wp->w_cursor.lnum\n\t\t    && !wrapped\n\t\t    && (colnr_T)(p - buf) >= wp->w_cursor.col)\n\t\tbreak;\n\n\t    // start of word\n\t    attr = HLF_COUNT;\n\t    len = spell_check(wp, p, &attr, &capcol, FALSE);\n\n\t    if (attr != HLF_COUNT)\n\t    {\n\t\t// We found a bad word.  Check the attribute.\n\t\tif (allwords || attr == HLF_SPB)\n\t\t{\n\t\t    // When searching forward only accept a bad word after\n\t\t    // the cursor.\n\t\t    if (dir == BACKWARD\n\t\t\t    || lnum != wp->w_cursor.lnum\n\t\t\t    || (wrapped\n\t\t\t\t|| (colnr_T)(curline ? p - buf + len\n\t\t\t\t\t\t     : p - buf)\n\t\t\t\t\t\t  > wp->w_cursor.col))\n\t\t    {\n#ifdef FEAT_SYN_HL\n\t\t\tif (has_syntax)\n\t\t\t{\n\t\t\t    col = (int)(p - buf);\n\t\t\t    (void)syn_get_id(wp, lnum, (colnr_T)col,\n\t\t\t\t\t\t    FALSE, &can_spell, FALSE);\n\t\t\t    if (!can_spell)\n\t\t\t\tattr = HLF_COUNT;\n\t\t\t}\n\t\t\telse\n#endif\n\t\t\t    can_spell = TRUE;\n\n\t\t\tif (can_spell)\n\t\t\t{\n\t\t\t    found_one = TRUE;\n\t\t\t    found_pos.lnum = lnum;\n\t\t\t    found_pos.col = (int)(p - buf);\n\t\t\t    found_pos.coladd = 0;\n\t\t\t    if (dir == FORWARD)\n\t\t\t    {\n\t\t\t\t// No need to search further.\n\t\t\t\twp->w_cursor = found_pos;\n\t\t\t\tvim_free(buf);\n\t\t\t\tif (attrp != NULL)\n\t\t\t\t    *attrp = attr;\n\t\t\t\treturn len;\n\t\t\t    }\n\t\t\t    else if (curline)\n\t\t\t\t// Insert mode completion: put cursor after\n\t\t\t\t// the bad word.\n\t\t\t\tfound_pos.col += len;\n\t\t\t    found_len = len;\n\t\t\t}\n\t\t    }\n\t\t    else\n\t\t\tfound_one = TRUE;\n\t\t}\n\t    }\n\n\t    // advance to character after the word\n\t    p += len;\n\t    capcol -= len;\n\t}\n\n\tif (dir == BACKWARD && found_pos.lnum != 0)\n\t{\n\t    // Use the last match in the line (before the cursor).\n\t    wp->w_cursor = found_pos;\n\t    vim_free(buf);\n\t    return found_len;\n\t}\n\n\tif (curline)\n\t    break;\t// only check cursor line\n\n\t// If we are back at the starting line and searched it again there\n\t// is no match, give up.\n\tif (lnum == wp->w_cursor.lnum && wrapped)\n\t    break;\n\n\t// Advance to next line.\n\tif (dir == BACKWARD)\n\t{\n\t    if (lnum > 1)\n\t\t--lnum;\n\t    else if (!p_ws)\n\t\tbreak;\t    // at first line and 'nowrapscan'\n\t    else\n\t    {\n\t\t// Wrap around to the end of the buffer.  May search the\n\t\t// starting line again and accept the last match.\n\t\tlnum = wp->w_buffer->b_ml.ml_line_count;\n\t\twrapped = TRUE;\n\t\tif (!shortmess(SHM_SEARCH))\n\t\t    give_warning((char_u *)_(top_bot_msg), TRUE);\n\t    }\n\t    capcol = -1;\n\t}\n\telse\n\t{\n\t    if (lnum < wp->w_buffer->b_ml.ml_line_count)\n\t\t++lnum;\n\t    else if (!p_ws)\n\t\tbreak;\t    // at first line and 'nowrapscan'\n\t    else\n\t    {\n\t\t// Wrap around to the start of the buffer.  May search the\n\t\t// starting line again and accept the first match.\n\t\tlnum = 1;\n\t\twrapped = TRUE;\n\t\tif (!shortmess(SHM_SEARCH))\n\t\t    give_warning((char_u *)_(bot_top_msg), TRUE);\n\t    }\n\n\t    // If we are back at the starting line and there is no match then\n\t    // give up.\n\t    if (lnum == wp->w_cursor.lnum && !found_one)\n\t\tbreak;\n\n\t    // Skip the characters at the start of the next line that were\n\t    // included in a match crossing line boundaries.\n\t    if (attr == HLF_COUNT)\n\t\tskip = (int)(p - endp);\n\t    else\n\t\tskip = 0;\n\n\t    // Capcol skips over the inserted space.\n\t    --capcol;\n\n\t    // But after empty line check first word in next line\n\t    if (empty_line)\n\t\tcapcol = 0;\n\t}\n\n\tline_breakcheck();\n    }\n\n    vim_free(buf);\n    return 0;\n}\n\n/*\n * For spell checking: concatenate the start of the following line \"line\" into\n * \"buf\", blanking-out special characters.  Copy less than \"maxlen\" bytes.\n * Keep the blanks at the start of the next line, this is used in win_line()\n * to skip those bytes if the word was OK.\n */\n    void\nspell_cat_line(char_u *buf, char_u *line, int maxlen)\n{\n    char_u\t*p;\n    int\t\tn;\n\n    p = skipwhite(line);\n    while (vim_strchr((char_u *)\"*#/\\\"\\t\", *p) != NULL)\n\tp = skipwhite(p + 1);\n\n    if (*p != NUL)\n    {\n\t// Only worth concatenating if there is something else than spaces to\n\t// concatenate.\n\tn = (int)(p - line) + 1;\n\tif (n < maxlen - 1)\n\t{\n\t    vim_memset(buf, ' ', n);\n\t    vim_strncpy(buf +  n, p, maxlen - 1 - n);\n\t}\n    }\n}\n\n/*\n * Structure used for the cookie argument of do_in_runtimepath().\n */\ntypedef struct spelload_S\n{\n    char_u  sl_lang[MAXWLEN + 1];\t// language name\n    slang_T *sl_slang;\t\t\t// resulting slang_T struct\n    int\t    sl_nobreak;\t\t\t// NOBREAK language found\n} spelload_T;\n\n/*\n * Load word list(s) for \"lang\" from Vim spell file(s).\n * \"lang\" must be the language without the region: e.g., \"en\".\n */\n    static void\nspell_load_lang(char_u *lang)\n{\n    char_u\tfname_enc[85];\n    int\t\tr;\n    spelload_T\tsl;\n    int\t\tround;\n\n    // Copy the language name to pass it to spell_load_cb() as a cookie.\n    // It's truncated when an error is detected.\n    STRCPY(sl.sl_lang, lang);\n    sl.sl_slang = NULL;\n    sl.sl_nobreak = FALSE;\n\n    // Disallow deleting the current buffer.  Autocommands can do weird things\n    // and cause \"lang\" to be freed.\n    ++curbuf->b_locked;\n\n    // We may retry when no spell file is found for the language, an\n    // autocommand may load it then.\n    for (round = 1; round <= 2; ++round)\n    {\n\t/*\n\t * Find the first spell file for \"lang\" in 'runtimepath' and load it.\n\t */\n\tvim_snprintf((char *)fname_enc, sizeof(fname_enc) - 5,\n#ifdef VMS\n\t\t\t\t\t\"spell/%s_%s.spl\",\n#else\n\t\t\t\t\t\"spell/%s.%s.spl\",\n#endif\n\t\t\t\t\t\t\t   lang, spell_enc());\n\tr = do_in_runtimepath(fname_enc, 0, spell_load_cb, &sl);\n\n\tif (r == FAIL && *sl.sl_lang != NUL)\n\t{\n\t    // Try loading the ASCII version.\n\t    vim_snprintf((char *)fname_enc, sizeof(fname_enc) - 5,\n#ifdef VMS\n\t\t\t\t\t\t  \"spell/%s_ascii.spl\",\n#else\n\t\t\t\t\t\t  \"spell/%s.ascii.spl\",\n#endif\n\t\t\t\t\t\t\t\t\tlang);\n\t    r = do_in_runtimepath(fname_enc, 0, spell_load_cb, &sl);\n\n\t    if (r == FAIL && *sl.sl_lang != NUL && round == 1\n\t\t    && apply_autocmds(EVENT_SPELLFILEMISSING, lang,\n\t\t\t\t\t      curbuf->b_fname, FALSE, curbuf))\n\t\tcontinue;\n\t    break;\n\t}\n\tbreak;\n    }\n\n    if (r == FAIL)\n    {\n\tsmsg(\n#ifdef VMS\n\t_(\"Warning: Cannot find word list \\\"%s_%s.spl\\\" or \\\"%s_ascii.spl\\\"\"),\n#else\n\t_(\"Warning: Cannot find word list \\\"%s.%s.spl\\\" or \\\"%s.ascii.spl\\\"\"),\n#endif\n\t\t\t\t\t\t     lang, spell_enc(), lang);\n    }\n    else if (sl.sl_slang != NULL)\n    {\n\t// At least one file was loaded, now load ALL the additions.\n\tSTRCPY(fname_enc + STRLEN(fname_enc) - 3, \"add.spl\");\n\tdo_in_runtimepath(fname_enc, DIP_ALL, spell_load_cb, &sl);\n    }\n\n    --curbuf->b_locked;\n}\n\n/*\n * Return the encoding used for spell checking: Use 'encoding', except that we\n * use \"latin1\" for \"latin9\".  And limit to 60 characters (just in case).\n */\n    char_u *\nspell_enc(void)\n{\n\n    if (STRLEN(p_enc) < 60 && STRCMP(p_enc, \"iso-8859-15\") != 0)\n\treturn p_enc;\n    return (char_u *)\"latin1\";\n}\n\n/*\n * Get the name of the .spl file for the internal wordlist into\n * \"fname[MAXPATHL]\".\n */\n    static void\nint_wordlist_spl(char_u *fname)\n{\n    vim_snprintf((char *)fname, MAXPATHL, SPL_FNAME_TMPL,\n\t\t\t\t\t\t  int_wordlist, spell_enc());\n}\n\n/*\n * Allocate a new slang_T for language \"lang\".  \"lang\" can be NULL.\n * Caller must fill \"sl_next\".\n */\n    slang_T *\nslang_alloc(char_u *lang)\n{\n    slang_T *lp;\n\n    lp = ALLOC_CLEAR_ONE(slang_T);\n    if (lp != NULL)\n    {\n\tif (lang != NULL)\n\t    lp->sl_name = vim_strsave(lang);\n\tga_init2(&lp->sl_rep, sizeof(fromto_T), 10);\n\tga_init2(&lp->sl_repsal, sizeof(fromto_T), 10);\n\tlp->sl_compmax = MAXWLEN;\n\tlp->sl_compsylmax = MAXWLEN;\n\thash_init(&lp->sl_wordcount);\n    }\n\n    return lp;\n}\n\n/*\n * Free the contents of an slang_T and the structure itself.\n */\n    void\nslang_free(slang_T *lp)\n{\n    vim_free(lp->sl_name);\n    vim_free(lp->sl_fname);\n    slang_clear(lp);\n    vim_free(lp);\n}\n\n/*\n * Clear an slang_T so that the file can be reloaded.\n */\n    void\nslang_clear(slang_T *lp)\n{\n    garray_T\t*gap;\n    fromto_T\t*ftp;\n    salitem_T\t*smp;\n    int\t\ti;\n    int\t\tround;\n\n    VIM_CLEAR(lp->sl_fbyts);\n    VIM_CLEAR(lp->sl_kbyts);\n    VIM_CLEAR(lp->sl_pbyts);\n\n    VIM_CLEAR(lp->sl_fidxs);\n    VIM_CLEAR(lp->sl_kidxs);\n    VIM_CLEAR(lp->sl_pidxs);\n\n    for (round = 1; round <= 2; ++round)\n    {\n\tgap = round == 1 ? &lp->sl_rep : &lp->sl_repsal;\n\twhile (gap->ga_len > 0)\n\t{\n\t    ftp = &((fromto_T *)gap->ga_data)[--gap->ga_len];\n\t    vim_free(ftp->ft_from);\n\t    vim_free(ftp->ft_to);\n\t}\n\tga_clear(gap);\n    }\n\n    gap = &lp->sl_sal;\n    if (lp->sl_sofo)\n    {\n\t// \"ga_len\" is set to 1 without adding an item for latin1\n\tif (gap->ga_data != NULL)\n\t    // SOFOFROM and SOFOTO items: free lists of wide characters.\n\t    for (i = 0; i < gap->ga_len; ++i)\n\t\tvim_free(((int **)gap->ga_data)[i]);\n    }\n    else\n\t// SAL items: free salitem_T items\n\twhile (gap->ga_len > 0)\n\t{\n\t    smp = &((salitem_T *)gap->ga_data)[--gap->ga_len];\n\t    vim_free(smp->sm_lead);\n\t    // Don't free sm_oneof and sm_rules, they point into sm_lead.\n\t    vim_free(smp->sm_to);\n\t    vim_free(smp->sm_lead_w);\n\t    vim_free(smp->sm_oneof_w);\n\t    vim_free(smp->sm_to_w);\n\t}\n    ga_clear(gap);\n\n    for (i = 0; i < lp->sl_prefixcnt; ++i)\n\tvim_regfree(lp->sl_prefprog[i]);\n    lp->sl_prefixcnt = 0;\n    VIM_CLEAR(lp->sl_prefprog);\n\n    VIM_CLEAR(lp->sl_info);\n\n    VIM_CLEAR(lp->sl_midword);\n\n    vim_regfree(lp->sl_compprog);\n    lp->sl_compprog = NULL;\n    VIM_CLEAR(lp->sl_comprules);\n    VIM_CLEAR(lp->sl_compstartflags);\n    VIM_CLEAR(lp->sl_compallflags);\n\n    VIM_CLEAR(lp->sl_syllable);\n    ga_clear(&lp->sl_syl_items);\n\n    ga_clear_strings(&lp->sl_comppat);\n\n    hash_clear_all(&lp->sl_wordcount, WC_KEY_OFF);\n    hash_init(&lp->sl_wordcount);\n\n    hash_clear_all(&lp->sl_map_hash, 0);\n\n    // Clear info from .sug file.\n    slang_clear_sug(lp);\n\n    lp->sl_compmax = MAXWLEN;\n    lp->sl_compminlen = 0;\n    lp->sl_compsylmax = MAXWLEN;\n    lp->sl_regions[0] = NUL;\n}\n\n/*\n * Clear the info from the .sug file in \"lp\".\n */\n    void\nslang_clear_sug(slang_T *lp)\n{\n    VIM_CLEAR(lp->sl_sbyts);\n    VIM_CLEAR(lp->sl_sidxs);\n    close_spellbuf(lp->sl_sugbuf);\n    lp->sl_sugbuf = NULL;\n    lp->sl_sugloaded = FALSE;\n    lp->sl_sugtime = 0;\n}\n\n/*\n * Load one spell file and store the info into a slang_T.\n * Invoked through do_in_runtimepath().\n */\n    static void\nspell_load_cb(char_u *fname, void *cookie)\n{\n    spelload_T\t*slp = (spelload_T *)cookie;\n    slang_T\t*slang;\n\n    slang = spell_load_file(fname, slp->sl_lang, NULL, FALSE);\n    if (slang != NULL)\n    {\n\t// When a previously loaded file has NOBREAK also use it for the\n\t// \".add\" files.\n\tif (slp->sl_nobreak && slang->sl_add)\n\t    slang->sl_nobreak = TRUE;\n\telse if (slang->sl_nobreak)\n\t    slp->sl_nobreak = TRUE;\n\n\tslp->sl_slang = slang;\n    }\n}\n\n\n/*\n * Add a word to the hashtable of common words.\n * If it's already there then the counter is increased.\n */\n    void\ncount_common_word(\n    slang_T\t*lp,\n    char_u\t*word,\n    int\t\tlen,\t    // word length, -1 for up to NUL\n    int\t\tcount)\t    // 1 to count once, 10 to init\n{\n    hash_T\thash;\n    hashitem_T\t*hi;\n    wordcount_T\t*wc;\n    char_u\tbuf[MAXWLEN];\n    char_u\t*p;\n\n    if (len == -1)\n\tp = word;\n    else if (len >= MAXWLEN)\n\treturn;\n    else\n    {\n\tvim_strncpy(buf, word, len);\n\tp = buf;\n    }\n\n    hash = hash_hash(p);\n    hi = hash_lookup(&lp->sl_wordcount, p, hash);\n    if (HASHITEM_EMPTY(hi))\n    {\n\twc = alloc(sizeof(wordcount_T) + STRLEN(p));\n\tif (wc == NULL)\n\t    return;\n\tSTRCPY(wc->wc_word, p);\n\twc->wc_count = count;\n\thash_add_item(&lp->sl_wordcount, hi, wc->wc_word, hash);\n    }\n    else\n    {\n\twc = HI2WC(hi);\n\tif ((wc->wc_count += count) < (unsigned)count)\t// check for overflow\n\t    wc->wc_count = MAXWORDCOUNT;\n    }\n}\n\n/*\n * Return TRUE if byte \"n\" appears in \"str\".\n * Like strchr() but independent of locale.\n */\n    int\nbyte_in_str(char_u *str, int n)\n{\n    char_u\t*p;\n\n    for (p = str; *p != NUL; ++p)\n\tif (*p == n)\n\t    return TRUE;\n    return FALSE;\n}\n\n#define SY_MAXLEN   30\ntypedef struct syl_item_S\n{\n    char_u\tsy_chars[SY_MAXLEN];\t    // the sequence of chars\n    int\t\tsy_len;\n} syl_item_T;\n\n/*\n * Truncate \"slang->sl_syllable\" at the first slash and put the following items\n * in \"slang->sl_syl_items\".\n */\n    int\ninit_syl_tab(slang_T *slang)\n{\n    char_u\t*p;\n    char_u\t*s;\n    int\t\tl;\n    syl_item_T\t*syl;\n\n    ga_init2(&slang->sl_syl_items, sizeof(syl_item_T), 4);\n    p = vim_strchr(slang->sl_syllable, '/');\n    while (p != NULL)\n    {\n\t*p++ = NUL;\n\tif (*p == NUL)\t    // trailing slash\n\t    break;\n\ts = p;\n\tp = vim_strchr(p, '/');\n\tif (p == NULL)\n\t    l = (int)STRLEN(s);\n\telse\n\t    l = (int)(p - s);\n\tif (l >= SY_MAXLEN)\n\t    return SP_FORMERROR;\n\tif (ga_grow(&slang->sl_syl_items, 1) == FAIL)\n\t    return SP_OTHERERROR;\n\tsyl = ((syl_item_T *)slang->sl_syl_items.ga_data)\n\t\t\t\t\t       + slang->sl_syl_items.ga_len++;\n\tvim_strncpy(syl->sy_chars, s, l);\n\tsyl->sy_len = l;\n    }\n    return OK;\n}\n\n/*\n * Count the number of syllables in \"word\".\n * When \"word\" contains spaces the syllables after the last space are counted.\n * Returns zero if syllables are not defines.\n */\n    static int\ncount_syllables(slang_T *slang, char_u *word)\n{\n    int\t\tcnt = 0;\n    int\t\tskip = FALSE;\n    char_u\t*p;\n    int\t\tlen;\n    int\t\ti;\n    syl_item_T\t*syl;\n    int\t\tc;\n\n    if (slang->sl_syllable == NULL)\n\treturn 0;\n\n    for (p = word; *p != NUL; p += len)\n    {\n\t// When running into a space reset counter.\n\tif (*p == ' ')\n\t{\n\t    len = 1;\n\t    cnt = 0;\n\t    continue;\n\t}\n\n\t// Find longest match of syllable items.\n\tlen = 0;\n\tfor (i = 0; i < slang->sl_syl_items.ga_len; ++i)\n\t{\n\t    syl = ((syl_item_T *)slang->sl_syl_items.ga_data) + i;\n\t    if (syl->sy_len > len\n\t\t\t       && STRNCMP(p, syl->sy_chars, syl->sy_len) == 0)\n\t\tlen = syl->sy_len;\n\t}\n\tif (len != 0)\t// found a match, count syllable\n\t{\n\t    ++cnt;\n\t    skip = FALSE;\n\t}\n\telse\n\t{\n\t    // No recognized syllable item, at least a syllable char then?\n\t    c = mb_ptr2char(p);\n\t    len = (*mb_ptr2len)(p);\n\t    if (vim_strchr(slang->sl_syllable, c) == NULL)\n\t\tskip = FALSE;\t    // No, search for next syllable\n\t    else if (!skip)\n\t    {\n\t\t++cnt;\t\t    // Yes, count it\n\t\tskip = TRUE;\t    // don't count following syllable chars\n\t    }\n\t}\n    }\n    return cnt;\n}\n\n/*\n * Parse 'spelllang' and set w_s->b_langp accordingly.\n * Returns NULL if it's OK, an untranslated error message otherwise.\n */\n    char *\ndid_set_spelllang(win_T *wp)\n{\n    garray_T\tga;\n    char_u\t*splp;\n    char_u\t*region;\n    char_u\tregion_cp[3];\n    int\t\tfilename;\n    int\t\tregion_mask;\n    slang_T\t*slang;\n    int\t\tc;\n    char_u\tlang[MAXWLEN + 1];\n    char_u\tspf_name[MAXPATHL];\n    int\t\tlen;\n    char_u\t*p;\n    int\t\tround;\n    char_u\t*spf;\n    char_u\t*use_region = NULL;\n    int\t\tdont_use_region = FALSE;\n    int\t\tnobreak = FALSE;\n    int\t\ti, j;\n    langp_T\t*lp, *lp2;\n    static int\trecursive = FALSE;\n    char\t*ret_msg = NULL;\n    char_u\t*spl_copy;\n    bufref_T\tbufref;\n\n    set_bufref(&bufref, wp->w_buffer);\n\n    // We don't want to do this recursively.  May happen when a language is\n    // not available and the SpellFileMissing autocommand opens a new buffer\n    // in which 'spell' is set.\n    if (recursive)\n\treturn NULL;\n    recursive = TRUE;\n\n    ga_init2(&ga, sizeof(langp_T), 2);\n    clear_midword(wp);\n\n    // Make a copy of 'spelllang', the SpellFileMissing autocommands may change\n    // it under our fingers.\n    spl_copy = vim_strsave(wp->w_s->b_p_spl);\n    if (spl_copy == NULL)\n\tgoto theend;\n\n    wp->w_s->b_cjk = 0;\n\n    // Loop over comma separated language names.\n    for (splp = spl_copy; *splp != NUL; )\n    {\n\t// Get one language name.\n\tcopy_option_part(&splp, lang, MAXWLEN, \",\");\n\tregion = NULL;\n\tlen = (int)STRLEN(lang);\n\n\tif (!valid_spelllang(lang))\n\t    continue;\n\n\tif (STRCMP(lang, \"cjk\") == 0)\n\t{\n\t    wp->w_s->b_cjk = 1;\n\t    continue;\n\t}\n\n\t// If the name ends in \".spl\" use it as the name of the spell file.\n\t// If there is a region name let \"region\" point to it and remove it\n\t// from the name.\n\tif (len > 4 && fnamecmp(lang + len - 4, \".spl\") == 0)\n\t{\n\t    filename = TRUE;\n\n\t    // Locate a region and remove it from the file name.\n\t    p = vim_strchr(gettail(lang), '_');\n\t    if (p != NULL && ASCII_ISALPHA(p[1]) && ASCII_ISALPHA(p[2])\n\t\t\t\t\t\t      && !ASCII_ISALPHA(p[3]))\n\t    {\n\t\tvim_strncpy(region_cp, p + 1, 2);\n\t\tmch_memmove(p, p + 3, len - (p - lang) - 2);\n\t\tregion = region_cp;\n\t    }\n\t    else\n\t\tdont_use_region = TRUE;\n\n\t    // Check if we loaded this language before.\n\t    FOR_ALL_SPELL_LANGS(slang)\n\t\tif (fullpathcmp(lang, slang->sl_fname, FALSE, TRUE) == FPC_SAME)\n\t\t    break;\n\t}\n\telse\n\t{\n\t    filename = FALSE;\n\t    if (len > 3 && lang[len - 3] == '_')\n\t    {\n\t\tregion = lang + len - 2;\n\t\tlen -= 3;\n\t\tlang[len] = NUL;\n\t    }\n\t    else\n\t\tdont_use_region = TRUE;\n\n\t    // Check if we loaded this language before.\n\t    FOR_ALL_SPELL_LANGS(slang)\n\t\tif (STRICMP(lang, slang->sl_name) == 0)\n\t\t    break;\n\t}\n\n\tif (region != NULL)\n\t{\n\t    // If the region differs from what was used before then don't\n\t    // use it for 'spellfile'.\n\t    if (use_region != NULL && STRCMP(region, use_region) != 0)\n\t\tdont_use_region = TRUE;\n\t    use_region = region;\n\t}\n\n\t// If not found try loading the language now.\n\tif (slang == NULL)\n\t{\n\t    if (filename)\n\t\t(void)spell_load_file(lang, lang, NULL, FALSE);\n\t    else\n\t    {\n\t\tspell_load_lang(lang);\n\t\t// SpellFileMissing autocommands may do anything, including\n\t\t// destroying the buffer we are using...\n\t\tif (!bufref_valid(&bufref))\n\t\t{\n\t\t    ret_msg = N_(e_spellfilemising_autocommand_deleted_buffer);\n\t\t    goto theend;\n\t\t}\n\t    }\n\t}\n\n\t/*\n\t * Loop over the languages, there can be several files for \"lang\".\n\t */\n\tFOR_ALL_SPELL_LANGS(slang)\n\t    if (filename ? fullpathcmp(lang, slang->sl_fname, FALSE, TRUE)\n\t\t\t\t\t\t\t\t    == FPC_SAME\n\t\t\t : STRICMP(lang, slang->sl_name) == 0)\n\t    {\n\t\tregion_mask = REGION_ALL;\n\t\tif (!filename && region != NULL)\n\t\t{\n\t\t    // find region in sl_regions\n\t\t    c = find_region(slang->sl_regions, region);\n\t\t    if (c == REGION_ALL)\n\t\t    {\n\t\t\tif (slang->sl_add)\n\t\t\t{\n\t\t\t    if (*slang->sl_regions != NUL)\n\t\t\t\t// This addition file is for other regions.\n\t\t\t\tregion_mask = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t    // This is probably an error.  Give a warning and\n\t\t\t    // accept the words anyway.\n\t\t\t    smsg(_(\"Warning: region %s not supported\"),\n\t\t\t\t\t\t\t\t      region);\n\t\t    }\n\t\t    else\n\t\t\tregion_mask = 1 << c;\n\t\t}\n\n\t\tif (region_mask != 0)\n\t\t{\n\t\t    if (ga_grow(&ga, 1) == FAIL)\n\t\t    {\n\t\t\tga_clear(&ga);\n\t\t\tret_msg = e_out_of_memory;\n\t\t\tgoto theend;\n\t\t    }\n\t\t    LANGP_ENTRY(ga, ga.ga_len)->lp_slang = slang;\n\t\t    LANGP_ENTRY(ga, ga.ga_len)->lp_region = region_mask;\n\t\t    ++ga.ga_len;\n\t\t    use_midword(slang, wp);\n\t\t    if (slang->sl_nobreak)\n\t\t\tnobreak = TRUE;\n\t\t}\n\t    }\n    }\n\n    // round 0: load int_wordlist, if possible.\n    // round 1: load first name in 'spellfile'.\n    // round 2: load second name in 'spellfile.\n    // etc.\n    spf = curwin->w_s->b_p_spf;\n    for (round = 0; round == 0 || *spf != NUL; ++round)\n    {\n\tif (round == 0)\n\t{\n\t    // Internal wordlist, if there is one.\n\t    if (int_wordlist == NULL)\n\t\tcontinue;\n\t    int_wordlist_spl(spf_name);\n\t}\n\telse\n\t{\n\t    // One entry in 'spellfile'.\n\t    copy_option_part(&spf, spf_name, MAXPATHL - 5, \",\");\n\t    STRCAT(spf_name, \".spl\");\n\n\t    // If it was already found above then skip it.\n\t    for (c = 0; c < ga.ga_len; ++c)\n\t    {\n\t\tp = LANGP_ENTRY(ga, c)->lp_slang->sl_fname;\n\t\tif (p != NULL && fullpathcmp(spf_name, p, FALSE, TRUE)\n\t\t\t\t\t\t\t\t== FPC_SAME)\n\t\t    break;\n\t    }\n\t    if (c < ga.ga_len)\n\t\tcontinue;\n\t}\n\n\t// Check if it was loaded already.\n\tFOR_ALL_SPELL_LANGS(slang)\n\t    if (fullpathcmp(spf_name, slang->sl_fname, FALSE, TRUE)\n\t\t\t\t\t\t\t\t== FPC_SAME)\n\t\tbreak;\n\tif (slang == NULL)\n\t{\n\t    // Not loaded, try loading it now.  The language name includes the\n\t    // region name, the region is ignored otherwise.  for int_wordlist\n\t    // use an arbitrary name.\n\t    if (round == 0)\n\t\tSTRCPY(lang, \"internal wordlist\");\n\t    else\n\t    {\n\t\tvim_strncpy(lang, gettail(spf_name), MAXWLEN);\n\t\tp = vim_strchr(lang, '.');\n\t\tif (p != NULL)\n\t\t    *p = NUL;\t// truncate at \".encoding.add\"\n\t    }\n\t    slang = spell_load_file(spf_name, lang, NULL, TRUE);\n\n\t    // If one of the languages has NOBREAK we assume the addition\n\t    // files also have this.\n\t    if (slang != NULL && nobreak)\n\t\tslang->sl_nobreak = TRUE;\n\t}\n\tif (slang != NULL && ga_grow(&ga, 1) == OK)\n\t{\n\t    region_mask = REGION_ALL;\n\t    if (use_region != NULL && !dont_use_region)\n\t    {\n\t\t// find region in sl_regions\n\t\tc = find_region(slang->sl_regions, use_region);\n\t\tif (c != REGION_ALL)\n\t\t    region_mask = 1 << c;\n\t\telse if (*slang->sl_regions != NUL)\n\t\t    // This spell file is for other regions.\n\t\t    region_mask = 0;\n\t    }\n\n\t    if (region_mask != 0)\n\t    {\n\t\tLANGP_ENTRY(ga, ga.ga_len)->lp_slang = slang;\n\t\tLANGP_ENTRY(ga, ga.ga_len)->lp_sallang = NULL;\n\t\tLANGP_ENTRY(ga, ga.ga_len)->lp_replang = NULL;\n\t\tLANGP_ENTRY(ga, ga.ga_len)->lp_region = region_mask;\n\t\t++ga.ga_len;\n\t\tuse_midword(slang, wp);\n\t    }\n\t}\n    }\n\n    // Everything is fine, store the new b_langp value.\n    ga_clear(&wp->w_s->b_langp);\n    wp->w_s->b_langp = ga;\n\n    // For each language figure out what language to use for sound folding and\n    // REP items.  If the language doesn't support it itself use another one\n    // with the same name.  E.g. for \"en-math\" use \"en\".\n    for (i = 0; i < ga.ga_len; ++i)\n    {\n\tlp = LANGP_ENTRY(ga, i);\n\n\t// sound folding\n\tif (lp->lp_slang->sl_sal.ga_len > 0)\n\t    // language does sound folding itself\n\t    lp->lp_sallang = lp->lp_slang;\n\telse\n\t    // find first similar language that does sound folding\n\t    for (j = 0; j < ga.ga_len; ++j)\n\t    {\n\t\tlp2 = LANGP_ENTRY(ga, j);\n\t\tif (lp2->lp_slang->sl_sal.ga_len > 0\n\t\t\t&& STRNCMP(lp->lp_slang->sl_name,\n\t\t\t\t\t      lp2->lp_slang->sl_name, 2) == 0)\n\t\t{\n\t\t    lp->lp_sallang = lp2->lp_slang;\n\t\t    break;\n\t\t}\n\t    }\n\n\t// REP items\n\tif (lp->lp_slang->sl_rep.ga_len > 0)\n\t    // language has REP items itself\n\t    lp->lp_replang = lp->lp_slang;\n\telse\n\t    // find first similar language that has REP items\n\t    for (j = 0; j < ga.ga_len; ++j)\n\t    {\n\t\tlp2 = LANGP_ENTRY(ga, j);\n\t\tif (lp2->lp_slang->sl_rep.ga_len > 0\n\t\t\t&& STRNCMP(lp->lp_slang->sl_name,\n\t\t\t\t\t      lp2->lp_slang->sl_name, 2) == 0)\n\t\t{\n\t\t    lp->lp_replang = lp2->lp_slang;\n\t\t    break;\n\t\t}\n\t    }\n    }\n    redraw_win_later(wp, UPD_NOT_VALID);\n\ntheend:\n    vim_free(spl_copy);\n    recursive = FALSE;\n    return ret_msg;\n}\n\n/*\n * Clear the midword characters for buffer \"buf\".\n */\n    static void\nclear_midword(win_T *wp)\n{\n    CLEAR_FIELD(wp->w_s->b_spell_ismw);\n    VIM_CLEAR(wp->w_s->b_spell_ismw_mb);\n}\n\n/*\n * Use the \"sl_midword\" field of language \"lp\" for buffer \"buf\".\n * They add up to any currently used midword characters.\n */\n    static void\nuse_midword(slang_T *lp, win_T *wp)\n{\n    char_u\t*p;\n\n    if (lp->sl_midword == NULL)\t    // there aren't any\n\treturn;\n\n    for (p = lp->sl_midword; *p != NUL; )\n\tif (has_mbyte)\n\t{\n\t    int\t    c, l, n;\n\t    char_u  *bp;\n\n\t    c = mb_ptr2char(p);\n\t    l = (*mb_ptr2len)(p);\n\t    if (c < 256 && l <= 2)\n\t\twp->w_s->b_spell_ismw[c] = TRUE;\n\t    else if (wp->w_s->b_spell_ismw_mb == NULL)\n\t\t// First multi-byte char in \"b_spell_ismw_mb\".\n\t\twp->w_s->b_spell_ismw_mb = vim_strnsave(p, l);\n\t    else\n\t    {\n\t\t// Append multi-byte chars to \"b_spell_ismw_mb\".\n\t\tn = (int)STRLEN(wp->w_s->b_spell_ismw_mb);\n\t\tbp = vim_strnsave(wp->w_s->b_spell_ismw_mb, n + l);\n\t\tif (bp != NULL)\n\t\t{\n\t\t    vim_free(wp->w_s->b_spell_ismw_mb);\n\t\t    wp->w_s->b_spell_ismw_mb = bp;\n\t\t    vim_strncpy(bp + n, p, l);\n\t\t}\n\t    }\n\t    p += l;\n\t}\n\telse\n\t    wp->w_s->b_spell_ismw[*p++] = TRUE;\n}\n\n/*\n * Find the region \"region[2]\" in \"rp\" (points to \"sl_regions\").\n * Each region is simply stored as the two characters of its name.\n * Returns the index if found (first is 0), REGION_ALL if not found.\n */\n    static int\nfind_region(char_u *rp, char_u *region)\n{\n    int\t\ti;\n\n    for (i = 0; ; i += 2)\n    {\n\tif (rp[i] == NUL)\n\t    return REGION_ALL;\n\tif (rp[i] == region[0] && rp[i + 1] == region[1])\n\t    break;\n    }\n    return i / 2;\n}\n\n/*\n * Return case type of word:\n * w word\t0\n * Word\t\tWF_ONECAP\n * W WORD\tWF_ALLCAP\n * WoRd\twOrd\tWF_KEEPCAP\n */\n    int\ncaptype(\n    char_u\t*word,\n    char_u\t*end)\t    // When NULL use up to NUL byte.\n{\n    char_u\t*p;\n    int\t\tc;\n    int\t\tfirstcap;\n    int\t\tallcap;\n    int\t\tpast_second = FALSE;\t// past second word char\n\n    // find first letter\n    for (p = word; !spell_iswordp_nmw(p, curwin); MB_PTR_ADV(p))\n\tif (end == NULL ? *p == NUL : p >= end)\n\t    return 0;\t    // only non-word characters, illegal word\n    if (has_mbyte)\n\tc = mb_ptr2char_adv(&p);\n    else\n\tc = *p++;\n    firstcap = allcap = SPELL_ISUPPER(c);\n\n    /*\n     * Need to check all letters to find a word with mixed upper/lower.\n     * But a word with an upper char only at start is a ONECAP.\n     */\n    for ( ; end == NULL ? *p != NUL : p < end; MB_PTR_ADV(p))\n\tif (spell_iswordp_nmw(p, curwin))\n\t{\n\t    c = PTR2CHAR(p);\n\t    if (!SPELL_ISUPPER(c))\n\t    {\n\t\t// UUl -> KEEPCAP\n\t\tif (past_second && allcap)\n\t\t    return WF_KEEPCAP;\n\t\tallcap = FALSE;\n\t    }\n\t    else if (!allcap)\n\t\t// UlU -> KEEPCAP\n\t\treturn WF_KEEPCAP;\n\t    past_second = TRUE;\n\t}\n\n    if (allcap)\n\treturn WF_ALLCAP;\n    if (firstcap)\n\treturn WF_ONECAP;\n    return 0;\n}\n\n/*\n * Delete the internal wordlist and its .spl file.\n */\n    void\nspell_delete_wordlist(void)\n{\n    char_u\tfname[MAXPATHL];\n\n    if (int_wordlist != NULL)\n    {\n\tmch_remove(int_wordlist);\n\tint_wordlist_spl(fname);\n\tmch_remove(fname);\n\tVIM_CLEAR(int_wordlist);\n    }\n}\n\n/*\n * Free all languages.\n */\n    void\nspell_free_all(void)\n{\n    slang_T\t*slang;\n    buf_T\t*buf;\n\n    // Go through all buffers and handle 'spelllang'. <VN>\n    FOR_ALL_BUFFERS(buf)\n\tga_clear(&buf->b_s.b_langp);\n\n    while (first_lang != NULL)\n    {\n\tslang = first_lang;\n\tfirst_lang = slang->sl_next;\n\tslang_free(slang);\n    }\n\n    spell_delete_wordlist();\n\n    VIM_CLEAR(repl_to);\n    VIM_CLEAR(repl_from);\n}\n\n/*\n * Clear all spelling tables and reload them.\n * Used after 'encoding' is set and when \":mkspell\" was used.\n */\n    void\nspell_reload(void)\n{\n    win_T\t*wp;\n\n    // Initialize the table for spell_iswordp().\n    init_spell_chartab();\n\n    // Unload all allocated memory.\n    spell_free_all();\n\n    // Go through all buffers and handle 'spelllang'.\n    FOR_ALL_WINDOWS(wp)\n    {\n\t// Only load the wordlists when 'spelllang' is set and there is a\n\t// window for this buffer in which 'spell' is set.\n\tif (*wp->w_s->b_p_spl != NUL)\n\t{\n\t\tif (wp->w_p_spell)\n\t\t{\n\t\t    (void)did_set_spelllang(wp);\n\t\t    break;\n\t\t}\n\t}\n    }\n}\n\n/*\n * Open a spell buffer.  This is a nameless buffer that is not in the buffer\n * list and only contains text lines.  Can use a swapfile to reduce memory\n * use.\n * Most other fields are invalid!  Esp. watch out for string options being\n * NULL and there is no undo info.\n * Returns NULL when out of memory.\n */\n    buf_T *\nopen_spellbuf(void)\n{\n    buf_T\t*buf;\n\n    buf = ALLOC_CLEAR_ONE(buf_T);\n    if (buf != NULL)\n    {\n\tbuf->b_spell = TRUE;\n\tbuf->b_p_swf = TRUE;\t// may create a swap file\n#ifdef FEAT_CRYPT\n\tbuf->b_p_key = empty_option;\n#endif\n\tml_open(buf);\n\tml_open_file(buf);\t// create swap file now\n    }\n    return buf;\n}\n\n/*\n * Close the buffer used for spell info.\n */\n    void\nclose_spellbuf(buf_T *buf)\n{\n    if (buf != NULL)\n    {\n\tml_close(buf, TRUE);\n\tvim_free(buf);\n    }\n}\n\n/*\n * Init the chartab used for spelling for ASCII.\n */\n    void\nclear_spell_chartab(spelltab_T *sp)\n{\n    int\t\ti;\n\n    // Init everything to FALSE (zero).\n    CLEAR_FIELD(sp->st_isw);\n    CLEAR_FIELD(sp->st_isu);\n    for (i = 0; i < 256; ++i)\n    {\n\tsp->st_fold[i] = i;\n\tsp->st_upper[i] = i;\n    }\n\n    // We include digits.  A word shouldn't start with a digit, but handling\n    // that is done separately.\n    for (i = '0'; i <= '9'; ++i)\n\tsp->st_isw[i] = TRUE;\n    for (i = 'A'; i <= 'Z'; ++i)\n    {\n\tsp->st_isw[i] = TRUE;\n\tsp->st_isu[i] = TRUE;\n\tsp->st_fold[i] = i + 0x20;\n    }\n    for (i = 'a'; i <= 'z'; ++i)\n    {\n\tsp->st_isw[i] = TRUE;\n\tsp->st_upper[i] = i - 0x20;\n    }\n}\n\n/*\n * Init the chartab used for spelling.  Only depends on 'encoding'.\n * Called once while starting up and when 'encoding' changes.\n * The default is to use isalpha(), but the spell file should define the word\n * characters to make it possible that 'encoding' differs from the current\n * locale.  For utf-8 we don't use isalpha() but our own functions.\n */\n    void\ninit_spell_chartab(void)\n{\n    int\t    i;\n\n    did_set_spelltab = FALSE;\n    clear_spell_chartab(&spelltab);\n    if (enc_dbcs)\n    {\n\t// DBCS: assume double-wide characters are word characters.\n\tfor (i = 128; i <= 255; ++i)\n\t    if (MB_BYTE2LEN(i) == 2)\n\t\tspelltab.st_isw[i] = TRUE;\n    }\n    else if (enc_utf8)\n    {\n\tfor (i = 128; i < 256; ++i)\n\t{\n\t    int f = utf_fold(i);\n\t    int u = utf_toupper(i);\n\n\t    spelltab.st_isu[i] = utf_isupper(i);\n\t    spelltab.st_isw[i] = spelltab.st_isu[i] || utf_islower(i);\n\t    // The folded/upper-cased value is different between latin1 and\n\t    // utf8 for 0xb5, causing E763 for no good reason.  Use the latin1\n\t    // value for utf-8 to avoid this.\n\t    spelltab.st_fold[i] = (f < 256) ? f : i;\n\t    spelltab.st_upper[i] = (u < 256) ? u : i;\n\t}\n    }\n    else\n    {\n\t// Rough guess: use locale-dependent library functions.\n\tfor (i = 128; i < 256; ++i)\n\t{\n\t    if (MB_ISUPPER(i))\n\t    {\n\t\tspelltab.st_isw[i] = TRUE;\n\t\tspelltab.st_isu[i] = TRUE;\n\t\tspelltab.st_fold[i] = MB_TOLOWER(i);\n\t    }\n\t    else if (MB_ISLOWER(i))\n\t    {\n\t\tspelltab.st_isw[i] = TRUE;\n\t\tspelltab.st_upper[i] = MB_TOUPPER(i);\n\t    }\n\t}\n    }\n}\n\n\n/*\n * Return TRUE if \"p\" points to a word character.\n * As a special case we see \"midword\" characters as word character when it is\n * followed by a word character.  This finds they'there but not 'they there'.\n * Thus this only works properly when past the first character of the word.\n */\n    int\nspell_iswordp(\n    char_u\t*p,\n    win_T\t*wp)\t    // buffer used\n{\n    char_u\t*s;\n    int\t\tl;\n    int\t\tc;\n\n    if (has_mbyte)\n    {\n\tl = mb_ptr2len(p);\n\ts = p;\n\tif (l == 1)\n\t{\n\t    // be quick for ASCII\n\t    if (wp->w_s->b_spell_ismw[*p])\n\t\ts = p + 1;\t\t// skip a mid-word character\n\t}\n\telse\n\t{\n\t    c = mb_ptr2char(p);\n\t    if (c < 256 ? wp->w_s->b_spell_ismw[c]\n\t\t    : (wp->w_s->b_spell_ismw_mb != NULL\n\t\t\t   && vim_strchr(wp->w_s->b_spell_ismw_mb, c) != NULL))\n\t\ts = p + l;\n\t}\n\n\tc = mb_ptr2char(s);\n\tif (c > 255)\n\t    return spell_mb_isword_class(mb_get_class(s), wp);\n\treturn spelltab.st_isw[c];\n    }\n\n    return spelltab.st_isw[wp->w_s->b_spell_ismw[*p] ? p[1] : p[0]];\n}\n\n/*\n * Return TRUE if \"p\" points to a word character.\n * Unlike spell_iswordp() this doesn't check for \"midword\" characters.\n */\n    int\nspell_iswordp_nmw(char_u *p, win_T *wp)\n{\n    int\t\tc;\n\n    if (has_mbyte)\n    {\n\tc = mb_ptr2char(p);\n\tif (c > 255)\n\t    return spell_mb_isword_class(mb_get_class(p), wp);\n\treturn spelltab.st_isw[c];\n    }\n    return spelltab.st_isw[*p];\n}\n\n/*\n * Return TRUE if word class indicates a word character.\n * Only for characters above 255.\n * Unicode subscript and superscript are not considered word characters.\n * See also dbcs_class() and utf_class() in mbyte.c.\n */\n    static int\nspell_mb_isword_class(int cl, win_T *wp)\n{\n    if (wp->w_s->b_cjk)\n\t// East Asian characters are not considered word characters.\n\treturn cl == 2 || cl == 0x2800;\n    return cl >= 2 && cl != 0x2070 && cl != 0x2080 && cl != 3;\n}\n\n/*\n * Return TRUE if \"p\" points to a word character.\n * Wide version of spell_iswordp().\n */\n    static int\nspell_iswordp_w(int *p, win_T *wp)\n{\n    int\t\t*s;\n\n    if (*p < 256 ? wp->w_s->b_spell_ismw[*p]\n\t\t : (wp->w_s->b_spell_ismw_mb != NULL\n\t\t\t     && vim_strchr(wp->w_s->b_spell_ismw_mb, *p) != NULL))\n\ts = p + 1;\n    else\n\ts = p;\n\n    if (*s > 255)\n    {\n\tif (enc_utf8)\n\t    return spell_mb_isword_class(utf_class(*s), wp);\n\tif (enc_dbcs)\n\t    return spell_mb_isword_class(\n\t\t\t\tdbcs_class((unsigned)*s >> 8, *s & 0xff), wp);\n\treturn 0;\n    }\n    return spelltab.st_isw[*s];\n}\n\n/*\n * Case-fold \"str[len]\" into \"buf[buflen]\".  The result is NUL terminated.\n * Uses the character definitions from the .spl file.\n * When using a multi-byte 'encoding' the length may change!\n * Returns FAIL when something wrong.\n */\n    int\nspell_casefold(\n    win_T\t*wp,\n    char_u\t*str,\n    int\t\tlen,\n    char_u\t*buf,\n    int\t\tbuflen)\n{\n    int\t\ti;\n\n    if (len >= buflen)\n    {\n\tbuf[0] = NUL;\n\treturn FAIL;\t\t// result will not fit\n    }\n\n    if (has_mbyte)\n    {\n\tint\touti = 0;\n\tchar_u\t*p;\n\tint\tc;\n\n\t// Fold one character at a time.\n\tfor (p = str; p < str + len; )\n\t{\n\t    if (outi + MB_MAXBYTES > buflen)\n\t    {\n\t\tbuf[outi] = NUL;\n\t\treturn FAIL;\n\t    }\n\t    c = mb_cptr2char_adv(&p);\n\n\t    // Exception: greek capital sigma 0x03A3 folds to 0x03C3, except\n\t    // when it is the last character in a word, then it folds to\n\t    // 0x03C2.\n\t    if (c == 0x03a3 || c == 0x03c2)\n\t    {\n\t\tif (p == str + len || !spell_iswordp(p, wp))\n\t\t    c = 0x03c2;\n\t\telse\n\t\t    c = 0x03c3;\n\t    }\n\t    else\n\t\tc = SPELL_TOFOLD(c);\n\n\t    outi += mb_char2bytes(c, buf + outi);\n\t}\n\tbuf[outi] = NUL;\n    }\n    else\n    {\n\t// Be quick for non-multibyte encodings.\n\tfor (i = 0; i < len; ++i)\n\t    buf[i] = spelltab.st_fold[str[i]];\n\tbuf[i] = NUL;\n    }\n\n    return OK;\n}\n\n/*\n * Check if the word at line \"lnum\" column \"col\" is required to start with a\n * capital.  This uses 'spellcapcheck' of the current buffer.\n */\n    int\ncheck_need_cap(linenr_T lnum, colnr_T col)\n{\n    int\t\tneed_cap = FALSE;\n    char_u\t*line;\n    char_u\t*line_copy = NULL;\n    char_u\t*p;\n    colnr_T\tendcol;\n    regmatch_T\tregmatch;\n\n    if (curwin->w_s->b_cap_prog == NULL)\n\treturn FALSE;\n\n    line = ml_get_curline();\n    endcol = 0;\n    if (getwhitecols(line) >= (int)col)\n    {\n\t// At start of line, check if previous line is empty or sentence\n\t// ends there.\n\tif (lnum == 1)\n\t    need_cap = TRUE;\n\telse\n\t{\n\t    line = ml_get(lnum - 1);\n\t    if (*skipwhite(line) == NUL)\n\t\tneed_cap = TRUE;\n\t    else\n\t    {\n\t\t// Append a space in place of the line break.\n\t\tline_copy = concat_str(line, (char_u *)\" \");\n\t\tline = line_copy;\n\t\tendcol = (colnr_T)STRLEN(line);\n\t    }\n\t}\n    }\n    else\n\tendcol = col;\n\n    if (endcol > 0)\n    {\n\t// Check if sentence ends before the bad word.\n\tregmatch.regprog = curwin->w_s->b_cap_prog;\n\tregmatch.rm_ic = FALSE;\n\tp = line + endcol;\n\tfor (;;)\n\t{\n\t    MB_PTR_BACK(line, p);\n\t    if (p == line || spell_iswordp_nmw(p, curwin))\n\t\tbreak;\n\t    if (vim_regexec(&regmatch, p, 0)\n\t\t\t\t\t && regmatch.endp[0] == line + endcol)\n\t    {\n\t\tneed_cap = TRUE;\n\t\tbreak;\n\t    }\n\t}\n\tcurwin->w_s->b_cap_prog = regmatch.regprog;\n    }\n\n    vim_free(line_copy);\n\n    return need_cap;\n}\n\n\n/*\n * \":spellrepall\"\n */\n    void\nex_spellrepall(exarg_T *eap UNUSED)\n{\n    pos_T\tpos = curwin->w_cursor;\n    char_u\t*frompat;\n    int\t\taddlen;\n    char_u\t*line;\n    char_u\t*p;\n    int\t\tsave_ws = p_ws;\n    linenr_T\tprev_lnum = 0;\n\n    if (repl_from == NULL || repl_to == NULL)\n    {\n\temsg(_(e_no_previous_spell_replacement));\n\treturn;\n    }\n    addlen = (int)(STRLEN(repl_to) - STRLEN(repl_from));\n\n    frompat = alloc(STRLEN(repl_from) + 7);\n    if (frompat == NULL)\n\treturn;\n    sprintf((char *)frompat, \"\\\\V\\\\<%s\\\\>\", repl_from);\n    p_ws = FALSE;\n\n    sub_nsubs = 0;\n    sub_nlines = 0;\n    curwin->w_cursor.lnum = 0;\n    while (!got_int)\n    {\n\tif (do_search(NULL, '/', '/', frompat, 1L, SEARCH_KEEP, NULL) == 0\n\t\t\t\t\t\t   || u_save_cursor() == FAIL)\n\t    break;\n\n\t// Only replace when the right word isn't there yet.  This happens\n\t// when changing \"etc\" to \"etc.\".\n\tline = ml_get_curline();\n\tif (addlen <= 0 || STRNCMP(line + curwin->w_cursor.col,\n\t\t\t\t\t       repl_to, STRLEN(repl_to)) != 0)\n\t{\n\t    p = alloc(STRLEN(line) + addlen + 1);\n\t    if (p == NULL)\n\t\tbreak;\n\t    mch_memmove(p, line, curwin->w_cursor.col);\n\t    STRCPY(p + curwin->w_cursor.col, repl_to);\n\t    STRCAT(p, line + curwin->w_cursor.col + STRLEN(repl_from));\n\t    ml_replace(curwin->w_cursor.lnum, p, FALSE);\n\t    changed_bytes(curwin->w_cursor.lnum, curwin->w_cursor.col);\n#if defined(FEAT_PROP_POPUP)\n\t    if (curbuf->b_has_textprop && addlen != 0)\n\t\tadjust_prop_columns(curwin->w_cursor.lnum,\n\t\t\t\t curwin->w_cursor.col, addlen, APC_SUBSTITUTE);\n#endif\n\n\t    if (curwin->w_cursor.lnum != prev_lnum)\n\t    {\n\t\t++sub_nlines;\n\t\tprev_lnum = curwin->w_cursor.lnum;\n\t    }\n\t    ++sub_nsubs;\n\t}\n\tcurwin->w_cursor.col += (colnr_T)STRLEN(repl_to);\n    }\n\n    p_ws = save_ws;\n    curwin->w_cursor = pos;\n    vim_free(frompat);\n\n    if (sub_nsubs == 0)\n\tsemsg(_(e_not_found_str), repl_from);\n    else\n\tdo_sub_msg(FALSE);\n}\n\n/*\n * Make a copy of \"word\", with the first letter upper or lower cased, to\n * \"wcopy[MAXWLEN]\".  \"word\" must not be empty.\n * The result is NUL terminated.\n */\n    void\nonecap_copy(\n    char_u\t*word,\n    char_u\t*wcopy,\n    int\t\tupper)\t    // TRUE: first letter made upper case\n{\n    char_u\t*p;\n    int\t\tc;\n    int\t\tl;\n\n    p = word;\n    if (has_mbyte)\n\tc = mb_cptr2char_adv(&p);\n    else\n\tc = *p++;\n    if (upper)\n\tc = SPELL_TOUPPER(c);\n    else\n\tc = SPELL_TOFOLD(c);\n    if (has_mbyte)\n\tl = mb_char2bytes(c, wcopy);\n    else\n    {\n\tl = 1;\n\twcopy[0] = c;\n    }\n    vim_strncpy(wcopy + l, p, MAXWLEN - l - 1);\n}\n\n/*\n * Make a copy of \"word\" with all the letters upper cased into\n * \"wcopy[MAXWLEN]\".  The result is NUL terminated.\n */\n    void\nallcap_copy(char_u *word, char_u *wcopy)\n{\n    char_u\t*s;\n    char_u\t*d;\n    int\t\tc;\n\n    d = wcopy;\n    for (s = word; *s != NUL; )\n    {\n\tif (has_mbyte)\n\t    c = mb_cptr2char_adv(&s);\n\telse\n\t    c = *s++;\n\n\t// We only change 0xdf to SS when we are certain latin1 is used.  It\n\t// would cause weird errors in other 8-bit encodings.\n\tif (enc_latin1like && c == 0xdf)\n\t{\n\t    c = 'S';\n\t    if (d - wcopy >= MAXWLEN - 1)\n\t\tbreak;\n\t    *d++ = c;\n\t}\n\telse\n\t    c = SPELL_TOUPPER(c);\n\n\tif (has_mbyte)\n\t{\n\t    if (d - wcopy >= MAXWLEN - MB_MAXBYTES)\n\t\tbreak;\n\t    d += mb_char2bytes(c, d);\n\t}\n\telse\n\t{\n\t    if (d - wcopy >= MAXWLEN - 1)\n\t\tbreak;\n\t    *d++ = c;\n\t}\n    }\n    *d = NUL;\n}\n\n/*\n * Case-folding may change the number of bytes: Count nr of chars in\n * fword[flen] and return the byte length of that many chars in \"word\".\n */\n    int\nnofold_len(char_u *fword, int flen, char_u *word)\n{\n    char_u\t*p;\n    int\t\ti = 0;\n\n    for (p = fword; p < fword + flen; MB_PTR_ADV(p))\n\t++i;\n    for (p = word; i > 0; MB_PTR_ADV(p))\n\t--i;\n    return (int)(p - word);\n}\n\n/*\n * Copy \"fword\" to \"cword\", fixing case according to \"flags\".\n */\n    void\nmake_case_word(char_u *fword, char_u *cword, int flags)\n{\n    if (flags & WF_ALLCAP)\n\t// Make it all upper-case\n\tallcap_copy(fword, cword);\n    else if (flags & WF_ONECAP)\n\t// Make the first letter upper-case\n\tonecap_copy(fword, cword, TRUE);\n    else\n\t// Use goodword as-is.\n\tSTRCPY(cword, fword);\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Soundfold a string, for soundfold().\n * Result is in allocated memory, NULL for an error.\n */\n    char_u *\neval_soundfold(char_u *word)\n{\n    langp_T\t*lp;\n    char_u\tsound[MAXWLEN];\n    int\t\tlpi;\n\n    if (curwin->w_p_spell && *curwin->w_s->b_p_spl != NUL)\n\t// Use the sound-folding of the first language that supports it.\n\tfor (lpi = 0; lpi < curwin->w_s->b_langp.ga_len; ++lpi)\n\t{\n\t    lp = LANGP_ENTRY(curwin->w_s->b_langp, lpi);\n\t    if (lp->lp_slang->sl_sal.ga_len > 0)\n\t    {\n\t\t// soundfold the word\n\t\tspell_soundfold(lp->lp_slang, word, FALSE, sound);\n\t\treturn vim_strsave(sound);\n\t    }\n\t}\n\n    // No language with sound folding, return word as-is.\n    return vim_strsave(word);\n}\n#endif\n\n/*\n * Turn \"inword\" into its sound-a-like equivalent in \"res[MAXWLEN]\".\n *\n * There are many ways to turn a word into a sound-a-like representation.  The\n * oldest is Soundex (1918!).   A nice overview can be found in \"Approximate\n * swedish name matching - survey and test of different algorithms\" by Klas\n * Erikson.\n *\n * We support two methods:\n * 1. SOFOFROM/SOFOTO do a simple character mapping.\n * 2. SAL items define a more advanced sound-folding (and much slower).\n */\n    void\nspell_soundfold(\n    slang_T\t*slang,\n    char_u\t*inword,\n    int\t\tfolded,\t    // \"inword\" is already case-folded\n    char_u\t*res)\n{\n    char_u\tfword[MAXWLEN];\n    char_u\t*word;\n\n    if (slang->sl_sofo)\n\t// SOFOFROM and SOFOTO used\n\tspell_soundfold_sofo(slang, inword, res);\n    else\n    {\n\t// SAL items used.  Requires the word to be case-folded.\n\tif (folded)\n\t    word = inword;\n\telse\n\t{\n\t    (void)spell_casefold(curwin,\n\t\t\t\t  inword, (int)STRLEN(inword), fword, MAXWLEN);\n\t    word = fword;\n\t}\n\n\tif (has_mbyte)\n\t    spell_soundfold_wsal(slang, word, res);\n\telse\n\t    spell_soundfold_sal(slang, word, res);\n    }\n}\n\n/*\n * Perform sound folding of \"inword\" into \"res\" according to SOFOFROM and\n * SOFOTO lines.\n */\n    static void\nspell_soundfold_sofo(slang_T *slang, char_u *inword, char_u *res)\n{\n    char_u\t*s;\n    int\t\tri = 0;\n    int\t\tc;\n\n    if (has_mbyte)\n    {\n\tint\tprevc = 0;\n\tint\t*ip;\n\n\t// The sl_sal_first[] table contains the translation for chars up to\n\t// 255, sl_sal the rest.\n\tfor (s = inword; *s != NUL; )\n\t{\n\t    c = mb_cptr2char_adv(&s);\n\t    if (enc_utf8 ? utf_class(c) == 0 : VIM_ISWHITE(c))\n\t\tc = ' ';\n\t    else if (c < 256)\n\t\tc = slang->sl_sal_first[c];\n\t    else\n\t    {\n\t\tip = ((int **)slang->sl_sal.ga_data)[c & 0xff];\n\t\tif (ip == NULL)\t\t// empty list, can't match\n\t\t    c = NUL;\n\t\telse\n\t\t    for (;;)\t\t// find \"c\" in the list\n\t\t    {\n\t\t\tif (*ip == 0)\t// not found\n\t\t\t{\n\t\t\t    c = NUL;\n\t\t\t    break;\n\t\t\t}\n\t\t\tif (*ip == c)\t// match!\n\t\t\t{\n\t\t\t    c = ip[1];\n\t\t\t    break;\n\t\t\t}\n\t\t\tip += 2;\n\t\t    }\n\t    }\n\n\t    if (c != NUL && c != prevc)\n\t    {\n\t\tri += mb_char2bytes(c, res + ri);\n\t\tif (ri + MB_MAXBYTES > MAXWLEN)\n\t\t    break;\n\t\tprevc = c;\n\t    }\n\t}\n    }\n    else\n    {\n\t// The sl_sal_first[] table contains the translation.\n\tfor (s = inword; (c = *s) != NUL; ++s)\n\t{\n\t    if (VIM_ISWHITE(c))\n\t\tc = ' ';\n\t    else\n\t\tc = slang->sl_sal_first[c];\n\t    if (c != NUL && (ri == 0 || res[ri - 1] != c))\n\t\tres[ri++] = c;\n\t}\n    }\n\n    res[ri] = NUL;\n}\n\n    static void\nspell_soundfold_sal(slang_T *slang, char_u *inword, char_u *res)\n{\n    salitem_T\t*smp;\n    char_u\tword[MAXWLEN];\n    char_u\t*s = inword;\n    char_u\t*t;\n    char_u\t*pf;\n    int\t\ti, j, z;\n    int\t\treslen;\n    int\t\tn, k = 0;\n    int\t\tz0;\n    int\t\tk0;\n    int\t\tn0;\n    int\t\tc;\n    int\t\tpri;\n    int\t\tp0 = -333;\n    int\t\tc0;\n\n    // Remove accents, if wanted.  We actually remove all non-word characters.\n    // But keep white space.  We need a copy, the word may be changed here.\n    if (slang->sl_rem_accents)\n    {\n\tt = word;\n\twhile (*s != NUL)\n\t{\n\t    if (VIM_ISWHITE(*s))\n\t    {\n\t\t*t++ = ' ';\n\t\ts = skipwhite(s);\n\t    }\n\t    else\n\t    {\n\t\tif (spell_iswordp_nmw(s, curwin))\n\t\t    *t++ = *s;\n\t\t++s;\n\t    }\n\t}\n\t*t = NUL;\n    }\n    else\n\tvim_strncpy(word, s, MAXWLEN - 1);\n\n    smp = (salitem_T *)slang->sl_sal.ga_data;\n\n    /*\n     * This comes from Aspell phonet.cpp.  Converted from C++ to C.\n     * Changed to keep spaces.\n     */\n    i = reslen = z = 0;\n    while ((c = word[i]) != NUL)\n    {\n\t// Start with the first rule that has the character in the word.\n\tn = slang->sl_sal_first[c];\n\tz0 = 0;\n\n\tif (n >= 0)\n\t{\n\t    // check all rules for the same letter\n\t    for (; (s = smp[n].sm_lead)[0] == c; ++n)\n\t    {\n\t\t// Quickly skip entries that don't match the word.  Most\n\t\t// entries are less than three chars, optimize for that.\n\t\tk = smp[n].sm_leadlen;\n\t\tif (k > 1)\n\t\t{\n\t\t    if (word[i + 1] != s[1])\n\t\t\tcontinue;\n\t\t    if (k > 2)\n\t\t    {\n\t\t\tfor (j = 2; j < k; ++j)\n\t\t\t    if (word[i + j] != s[j])\n\t\t\t\tbreak;\n\t\t\tif (j < k)\n\t\t\t    continue;\n\t\t    }\n\t\t}\n\n\t\tif ((pf = smp[n].sm_oneof) != NULL)\n\t\t{\n\t\t    // Check for match with one of the chars in \"sm_oneof\".\n\t\t    while (*pf != NUL && *pf != word[i + k])\n\t\t\t++pf;\n\t\t    if (*pf == NUL)\n\t\t\tcontinue;\n\t\t    ++k;\n\t\t}\n\t\ts = smp[n].sm_rules;\n\t\tpri = 5;    // default priority\n\n\t\tp0 = *s;\n\t\tk0 = k;\n\t\twhile (*s == '-' && k > 1)\n\t\t{\n\t\t    k--;\n\t\t    s++;\n\t\t}\n\t\tif (*s == '<')\n\t\t    s++;\n\t\tif (VIM_ISDIGIT(*s))\n\t\t{\n\t\t    // determine priority\n\t\t    pri = *s - '0';\n\t\t    s++;\n\t\t}\n\t\tif (*s == '^' && *(s + 1) == '^')\n\t\t    s++;\n\n\t\tif (*s == NUL\n\t\t\t|| (*s == '^'\n\t\t\t    && (i == 0 || !(word[i - 1] == ' '\n\t\t\t\t      || spell_iswordp(word + i - 1, curwin)))\n\t\t\t    && (*(s + 1) != '$'\n\t\t\t\t|| (!spell_iswordp(word + i + k0, curwin))))\n\t\t\t|| (*s == '$' && i > 0\n\t\t\t    && spell_iswordp(word + i - 1, curwin)\n\t\t\t    && (!spell_iswordp(word + i + k0, curwin))))\n\t\t{\n\t\t    // search for followup rules, if:\n\t\t    // followup and k > 1  and  NO '-' in searchstring\n\t\t    c0 = word[i + k - 1];\n\t\t    n0 = slang->sl_sal_first[c0];\n\n\t\t    if (slang->sl_followup && k > 1 && n0 >= 0\n\t\t\t\t\t   && p0 != '-' && word[i + k] != NUL)\n\t\t    {\n\t\t\t// test follow-up rule for \"word[i + k]\"\n\t\t\tfor ( ; (s = smp[n0].sm_lead)[0] == c0; ++n0)\n\t\t\t{\n\t\t\t    // Quickly skip entries that don't match the word.\n\t\t\t    //\n\t\t\t    k0 = smp[n0].sm_leadlen;\n\t\t\t    if (k0 > 1)\n\t\t\t    {\n\t\t\t\tif (word[i + k] != s[1])\n\t\t\t\t    continue;\n\t\t\t\tif (k0 > 2)\n\t\t\t\t{\n\t\t\t\t    pf = word + i + k + 1;\n\t\t\t\t    for (j = 2; j < k0; ++j)\n\t\t\t\t\tif (*pf++ != s[j])\n\t\t\t\t\t    break;\n\t\t\t\t    if (j < k0)\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t    }\n\t\t\t    k0 += k - 1;\n\n\t\t\t    if ((pf = smp[n0].sm_oneof) != NULL)\n\t\t\t    {\n\t\t\t\t// Check for match with one of the chars in\n\t\t\t\t// \"sm_oneof\".\n\t\t\t\twhile (*pf != NUL && *pf != word[i + k0])\n\t\t\t\t    ++pf;\n\t\t\t\tif (*pf == NUL)\n\t\t\t\t    continue;\n\t\t\t\t++k0;\n\t\t\t    }\n\n\t\t\t    p0 = 5;\n\t\t\t    s = smp[n0].sm_rules;\n\t\t\t    while (*s == '-')\n\t\t\t    {\n\t\t\t\t// \"k0\" gets NOT reduced because\n\t\t\t\t// \"if (k0 == k)\"\n\t\t\t\ts++;\n\t\t\t    }\n\t\t\t    if (*s == '<')\n\t\t\t\ts++;\n\t\t\t    if (VIM_ISDIGIT(*s))\n\t\t\t    {\n\t\t\t\tp0 = *s - '0';\n\t\t\t\ts++;\n\t\t\t    }\n\n\t\t\t    if (*s == NUL\n\t\t\t\t    // *s == '^' cuts\n\t\t\t\t    || (*s == '$'\n\t\t\t\t\t    && !spell_iswordp(word + i + k0,\n\t\t\t\t\t\t\t\t     curwin)))\n\t\t\t    {\n\t\t\t\tif (k0 == k)\n\t\t\t\t    // this is just a piece of the string\n\t\t\t\t    continue;\n\n\t\t\t\tif (p0 < pri)\n\t\t\t\t    // priority too low\n\t\t\t\t    continue;\n\t\t\t\t// rule fits; stop search\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t}\n\n\t\t\tif (p0 >= pri && smp[n0].sm_lead[0] == c0)\n\t\t\t    continue;\n\t\t    }\n\n\t\t    // replace string\n\t\t    s = smp[n].sm_to;\n\t\t    if (s == NULL)\n\t\t\ts = (char_u *)\"\";\n\t\t    pf = smp[n].sm_rules;\n\t\t    p0 = (vim_strchr(pf, '<') != NULL) ? 1 : 0;\n\t\t    if (p0 == 1 && z == 0)\n\t\t    {\n\t\t\t// rule with '<' is used\n\t\t\tif (reslen > 0 && *s != NUL && (res[reslen - 1] == c\n\t\t\t\t\t\t    || res[reslen - 1] == *s))\n\t\t\t    reslen--;\n\t\t\tz0 = 1;\n\t\t\tz = 1;\n\t\t\tk0 = 0;\n\t\t\twhile (*s != NUL && word[i + k0] != NUL)\n\t\t\t{\n\t\t\t    word[i + k0] = *s;\n\t\t\t    k0++;\n\t\t\t    s++;\n\t\t\t}\n\t\t\tif (k > k0)\n\t\t\t    STRMOVE(word + i + k0, word + i + k);\n\n\t\t\t// new \"actual letter\"\n\t\t\tc = word[i];\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t// no '<' rule used\n\t\t\ti += k - 1;\n\t\t\tz = 0;\n\t\t\twhile (*s != NUL && s[1] != NUL && reslen < MAXWLEN)\n\t\t\t{\n\t\t\t    if (reslen == 0 || res[reslen - 1] != *s)\n\t\t\t\tres[reslen++] = *s;\n\t\t\t    s++;\n\t\t\t}\n\t\t\t// new \"actual letter\"\n\t\t\tc = *s;\n\t\t\tif (strstr((char *)pf, \"^^\") != NULL)\n\t\t\t{\n\t\t\t    if (c != NUL)\n\t\t\t\tres[reslen++] = c;\n\t\t\t    STRMOVE(word, word + i + 1);\n\t\t\t    i = 0;\n\t\t\t    z0 = 1;\n\t\t\t}\n\t\t    }\n\t\t    break;\n\t\t}\n\t    }\n\t}\n\telse if (VIM_ISWHITE(c))\n\t{\n\t    c = ' ';\n\t    k = 1;\n\t}\n\n\tif (z0 == 0)\n\t{\n\t    if (k && !p0 && reslen < MAXWLEN && c != NUL\n\t\t    && (!slang->sl_collapse || reslen == 0\n\t\t\t\t\t\t     || res[reslen - 1] != c))\n\t\t// condense only double letters\n\t\tres[reslen++] = c;\n\n\t    i++;\n\t    z = 0;\n\t    k = 0;\n\t}\n    }\n\n    res[reslen] = NUL;\n}\n\n/*\n * Turn \"inword\" into its sound-a-like equivalent in \"res[MAXWLEN]\".\n * Multi-byte version of spell_soundfold().\n */\n    static void\nspell_soundfold_wsal(slang_T *slang, char_u *inword, char_u *res)\n{\n    salitem_T\t*smp = (salitem_T *)slang->sl_sal.ga_data;\n    int\t\tword[MAXWLEN];\n    int\t\twres[MAXWLEN];\n    int\t\tl;\n    char_u\t*s;\n    int\t\t*ws;\n    char_u\t*t;\n    int\t\t*pf;\n    int\t\ti, j, z;\n    int\t\treslen;\n    int\t\tn, k = 0;\n    int\t\tz0;\n    int\t\tk0;\n    int\t\tn0;\n    int\t\tc;\n    int\t\tpri;\n    int\t\tp0 = -333;\n    int\t\tc0;\n    int\t\tdid_white = FALSE;\n    int\t\twordlen;\n\n\n    /*\n     * Convert the multi-byte string to a wide-character string.\n     * Remove accents, if wanted.  We actually remove all non-word characters.\n     * But keep white space.\n     */\n    wordlen = 0;\n    for (s = inword; *s != NUL; )\n    {\n\tt = s;\n\tc = mb_cptr2char_adv(&s);\n\tif (slang->sl_rem_accents)\n\t{\n\t    if (enc_utf8 ? utf_class(c) == 0 : VIM_ISWHITE(c))\n\t    {\n\t\tif (did_white)\n\t\t    continue;\n\t\tc = ' ';\n\t\tdid_white = TRUE;\n\t    }\n\t    else\n\t    {\n\t\tdid_white = FALSE;\n\t\tif (!spell_iswordp_nmw(t, curwin))\n\t\t    continue;\n\t    }\n\t}\n\tword[wordlen++] = c;\n    }\n    word[wordlen] = NUL;\n\n    /*\n     * This algorithm comes from Aspell phonet.cpp.\n     * Converted from C++ to C.  Added support for multi-byte chars.\n     * Changed to keep spaces.\n     */\n    i = reslen = z = 0;\n    while ((c = word[i]) != NUL)\n    {\n\t// Start with the first rule that has the character in the word.\n\tn = slang->sl_sal_first[c & 0xff];\n\tz0 = 0;\n\n\tif (n >= 0)\n\t{\n\t    // Check all rules for the same index byte.\n\t    // If c is 0x300 need extra check for the end of the array, as\n\t    // (c & 0xff) is NUL.\n\t    for (; ((ws = smp[n].sm_lead_w)[0] & 0xff) == (c & 0xff)\n\t\t\t\t\t\t\t && ws[0] != NUL; ++n)\n\t    {\n\t\t// Quickly skip entries that don't match the word.  Most\n\t\t// entries are less than three chars, optimize for that.\n\t\tif (c != ws[0])\n\t\t    continue;\n\t\tk = smp[n].sm_leadlen;\n\t\tif (k > 1)\n\t\t{\n\t\t    if (word[i + 1] != ws[1])\n\t\t\tcontinue;\n\t\t    if (k > 2)\n\t\t    {\n\t\t\tfor (j = 2; j < k; ++j)\n\t\t\t    if (word[i + j] != ws[j])\n\t\t\t\tbreak;\n\t\t\tif (j < k)\n\t\t\t    continue;\n\t\t    }\n\t\t}\n\n\t\tif ((pf = smp[n].sm_oneof_w) != NULL)\n\t\t{\n\t\t    // Check for match with one of the chars in \"sm_oneof\".\n\t\t    while (*pf != NUL && *pf != word[i + k])\n\t\t\t++pf;\n\t\t    if (*pf == NUL)\n\t\t\tcontinue;\n\t\t    ++k;\n\t\t}\n\t\ts = smp[n].sm_rules;\n\t\tpri = 5;    // default priority\n\n\t\tp0 = *s;\n\t\tk0 = k;\n\t\twhile (*s == '-' && k > 1)\n\t\t{\n\t\t    k--;\n\t\t    s++;\n\t\t}\n\t\tif (*s == '<')\n\t\t    s++;\n\t\tif (VIM_ISDIGIT(*s))\n\t\t{\n\t\t    // determine priority\n\t\t    pri = *s - '0';\n\t\t    s++;\n\t\t}\n\t\tif (*s == '^' && *(s + 1) == '^')\n\t\t    s++;\n\n\t\tif (*s == NUL\n\t\t\t|| (*s == '^'\n\t\t\t    && (i == 0 || !(word[i - 1] == ' '\n\t\t\t\t    || spell_iswordp_w(word + i - 1, curwin)))\n\t\t\t    && (*(s + 1) != '$'\n\t\t\t\t|| (!spell_iswordp_w(word + i + k0, curwin))))\n\t\t\t|| (*s == '$' && i > 0\n\t\t\t    && spell_iswordp_w(word + i - 1, curwin)\n\t\t\t    && (!spell_iswordp_w(word + i + k0, curwin))))\n\t\t{\n\t\t    // search for followup rules, if:\n\t\t    // followup and k > 1  and  NO '-' in searchstring\n\t\t    c0 = word[i + k - 1];\n\t\t    n0 = slang->sl_sal_first[c0 & 0xff];\n\n\t\t    if (slang->sl_followup && k > 1 && n0 >= 0\n\t\t\t\t\t   && p0 != '-' && word[i + k] != NUL)\n\t\t    {\n\t\t\t// Test follow-up rule for \"word[i + k]\"; loop over\n\t\t\t// all entries with the same index byte.\n\t\t\tfor ( ; ((ws = smp[n0].sm_lead_w)[0] & 0xff)\n\t\t\t\t\t\t\t == (c0 & 0xff); ++n0)\n\t\t\t{\n\t\t\t    // Quickly skip entries that don't match the word.\n\t\t\t    if (c0 != ws[0])\n\t\t\t\tcontinue;\n\t\t\t    k0 = smp[n0].sm_leadlen;\n\t\t\t    if (k0 > 1)\n\t\t\t    {\n\t\t\t\tif (word[i + k] != ws[1])\n\t\t\t\t    continue;\n\t\t\t\tif (k0 > 2)\n\t\t\t\t{\n\t\t\t\t    pf = word + i + k + 1;\n\t\t\t\t    for (j = 2; j < k0; ++j)\n\t\t\t\t\tif (*pf++ != ws[j])\n\t\t\t\t\t    break;\n\t\t\t\t    if (j < k0)\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t    }\n\t\t\t    k0 += k - 1;\n\n\t\t\t    if ((pf = smp[n0].sm_oneof_w) != NULL)\n\t\t\t    {\n\t\t\t\t// Check for match with one of the chars in\n\t\t\t\t// \"sm_oneof\".\n\t\t\t\twhile (*pf != NUL && *pf != word[i + k0])\n\t\t\t\t    ++pf;\n\t\t\t\tif (*pf == NUL)\n\t\t\t\t    continue;\n\t\t\t\t++k0;\n\t\t\t    }\n\n\t\t\t    p0 = 5;\n\t\t\t    s = smp[n0].sm_rules;\n\t\t\t    while (*s == '-')\n\t\t\t    {\n\t\t\t\t// \"k0\" gets NOT reduced because\n\t\t\t\t// \"if (k0 == k)\"\n\t\t\t\ts++;\n\t\t\t    }\n\t\t\t    if (*s == '<')\n\t\t\t\ts++;\n\t\t\t    if (VIM_ISDIGIT(*s))\n\t\t\t    {\n\t\t\t\tp0 = *s - '0';\n\t\t\t\ts++;\n\t\t\t    }\n\n\t\t\t    if (*s == NUL\n\t\t\t\t    // *s == '^' cuts\n\t\t\t\t    || (*s == '$'\n\t\t\t\t\t && !spell_iswordp_w(word + i + k0,\n\t\t\t\t\t\t\t\t     curwin)))\n\t\t\t    {\n\t\t\t\tif (k0 == k)\n\t\t\t\t    // this is just a piece of the string\n\t\t\t\t    continue;\n\n\t\t\t\tif (p0 < pri)\n\t\t\t\t    // priority too low\n\t\t\t\t    continue;\n\t\t\t\t// rule fits; stop search\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t}\n\n\t\t\tif (p0 >= pri && (smp[n0].sm_lead_w[0] & 0xff)\n\t\t\t\t\t\t\t       == (c0 & 0xff))\n\t\t\t    continue;\n\t\t    }\n\n\t\t    // replace string\n\t\t    ws = smp[n].sm_to_w;\n\t\t    s = smp[n].sm_rules;\n\t\t    p0 = (vim_strchr(s, '<') != NULL) ? 1 : 0;\n\t\t    if (p0 == 1 && z == 0)\n\t\t    {\n\t\t\t// rule with '<' is used\n\t\t\tif (reslen > 0 && ws != NULL && *ws != NUL\n\t\t\t\t&& (wres[reslen - 1] == c\n\t\t\t\t\t\t    || wres[reslen - 1] == *ws))\n\t\t\t    reslen--;\n\t\t\tz0 = 1;\n\t\t\tz = 1;\n\t\t\tk0 = 0;\n\t\t\tif (ws != NULL)\n\t\t\t    while (*ws != NUL && word[i + k0] != NUL)\n\t\t\t    {\n\t\t\t\tword[i + k0] = *ws;\n\t\t\t\tk0++;\n\t\t\t\tws++;\n\t\t\t    }\n\t\t\tif (k > k0)\n\t\t\t    mch_memmove(word + i + k0, word + i + k,\n\t\t\t\t    sizeof(int) * (wordlen - (i + k) + 1));\n\n\t\t\t// new \"actual letter\"\n\t\t\tc = word[i];\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t// no '<' rule used\n\t\t\ti += k - 1;\n\t\t\tz = 0;\n\t\t\tif (ws != NULL)\n\t\t\t    while (*ws != NUL && ws[1] != NUL\n\t\t\t\t\t\t\t  && reslen < MAXWLEN)\n\t\t\t    {\n\t\t\t\tif (reslen == 0 || wres[reslen - 1] != *ws)\n\t\t\t\t    wres[reslen++] = *ws;\n\t\t\t\tws++;\n\t\t\t    }\n\t\t\t// new \"actual letter\"\n\t\t\tif (ws == NULL)\n\t\t\t    c = NUL;\n\t\t\telse\n\t\t\t    c = *ws;\n\t\t\tif (strstr((char *)s, \"^^\") != NULL)\n\t\t\t{\n\t\t\t    if (c != NUL)\n\t\t\t\twres[reslen++] = c;\n\t\t\t    mch_memmove(word, word + i + 1,\n\t\t\t\t       sizeof(int) * (wordlen - (i + 1) + 1));\n\t\t\t    i = 0;\n\t\t\t    z0 = 1;\n\t\t\t}\n\t\t    }\n\t\t    break;\n\t\t}\n\t    }\n\t}\n\telse if (VIM_ISWHITE(c))\n\t{\n\t    c = ' ';\n\t    k = 1;\n\t}\n\n\tif (z0 == 0)\n\t{\n\t    if (k && !p0 && reslen < MAXWLEN && c != NUL\n\t\t    && (!slang->sl_collapse || reslen == 0\n\t\t\t\t\t\t     || wres[reslen - 1] != c))\n\t\t// condense only double letters\n\t\twres[reslen++] = c;\n\n\t    i++;\n\t    z = 0;\n\t    k = 0;\n\t}\n    }\n\n    // Convert wide characters in \"wres\" to a multi-byte string in \"res\".\n    l = 0;\n    for (n = 0; n < reslen; ++n)\n    {\n\tl += mb_char2bytes(wres[n], res + l);\n\tif (l + MB_MAXBYTES > MAXWLEN)\n\t    break;\n    }\n    res[l] = NUL;\n}\n\n/*\n * \":spellinfo\"\n */\n    void\nex_spellinfo(exarg_T *eap UNUSED)\n{\n    int\t\tlpi;\n    langp_T\t*lp;\n    char_u\t*p;\n\n    if (no_spell_checking(curwin))\n\treturn;\n\n    msg_start();\n    for (lpi = 0; lpi < curwin->w_s->b_langp.ga_len && !got_int; ++lpi)\n    {\n\tlp = LANGP_ENTRY(curwin->w_s->b_langp, lpi);\n\tmsg_puts(\"file: \");\n\tmsg_puts((char *)lp->lp_slang->sl_fname);\n\tmsg_putchar('\\n');\n\tp = lp->lp_slang->sl_info;\n\tif (p != NULL)\n\t{\n\t    msg_puts((char *)p);\n\t    msg_putchar('\\n');\n\t}\n    }\n    msg_end();\n}\n\n#define DUMPFLAG_KEEPCASE   1\t// round 2: keep-case tree\n#define DUMPFLAG_COUNT\t    2\t// include word count\n#define DUMPFLAG_ICASE\t    4\t// ignore case when finding matches\n#define DUMPFLAG_ONECAP\t    8\t// pattern starts with capital\n#define DUMPFLAG_ALLCAP\t    16\t// pattern is all capitals\n\n/*\n * \":spelldump\"\n */\n    void\nex_spelldump(exarg_T *eap)\n{\n    char_u  *spl;\n    long    dummy;\n\n    if (no_spell_checking(curwin))\n\treturn;\n    (void)get_option_value((char_u*)\"spl\", &dummy, &spl, NULL, OPT_LOCAL);\n\n    // Create a new empty buffer in a new window.\n    do_cmdline_cmd((char_u *)\"new\");\n\n    // enable spelling locally in the new window\n    set_option_value_give_err((char_u*)\"spell\", TRUE, (char_u*)\"\", OPT_LOCAL);\n    set_option_value_give_err((char_u*)\"spl\",  dummy, spl, OPT_LOCAL);\n    vim_free(spl);\n\n    if (!BUFEMPTY())\n\treturn;\n\n    spell_dump_compl(NULL, 0, NULL, eap->forceit ? DUMPFLAG_COUNT : 0);\n\n    // Delete the empty line that we started with.\n    if (curbuf->b_ml.ml_line_count > 1)\n\tml_delete(curbuf->b_ml.ml_line_count);\n\n    redraw_later(UPD_NOT_VALID);\n}\n\n/*\n * Go through all possible words and:\n * 1. When \"pat\" is NULL: dump a list of all words in the current buffer.\n *\t\"ic\" and \"dir\" are not used.\n * 2. When \"pat\" is not NULL: add matching words to insert mode completion.\n */\n    void\nspell_dump_compl(\n    char_u\t*pat,\t    // leading part of the word\n    int\t\tic,\t    // ignore case\n    int\t\t*dir,\t    // direction for adding matches\n    int\t\tdumpflags_arg)\t// DUMPFLAG_*\n{\n    langp_T\t*lp;\n    slang_T\t*slang;\n    idx_T\tarridx[MAXWLEN];\n    int\t\tcuri[MAXWLEN];\n    char_u\tword[MAXWLEN];\n    int\t\tc;\n    char_u\t*byts;\n    idx_T\t*idxs;\n    linenr_T\tlnum = 0;\n    int\t\tround;\n    int\t\tdepth;\n    int\t\tn;\n    int\t\tflags;\n    char_u\t*region_names = NULL;\t    // region names being used\n    int\t\tdo_region = TRUE;\t    // dump region names and numbers\n    char_u\t*p;\n    int\t\tlpi;\n    int\t\tdumpflags = dumpflags_arg;\n    int\t\tpatlen;\n\n    // When ignoring case or when the pattern starts with capital pass this on\n    // to dump_word().\n    if (pat != NULL)\n    {\n\tif (ic)\n\t    dumpflags |= DUMPFLAG_ICASE;\n\telse\n\t{\n\t    n = captype(pat, NULL);\n\t    if (n == WF_ONECAP)\n\t\tdumpflags |= DUMPFLAG_ONECAP;\n\t    else if (n == WF_ALLCAP && (int)STRLEN(pat) > mb_ptr2len(pat))\n\t\tdumpflags |= DUMPFLAG_ALLCAP;\n\t}\n    }\n\n    // Find out if we can support regions: All languages must support the same\n    // regions or none at all.\n    for (lpi = 0; lpi < curwin->w_s->b_langp.ga_len; ++lpi)\n    {\n\tlp = LANGP_ENTRY(curwin->w_s->b_langp, lpi);\n\tp = lp->lp_slang->sl_regions;\n\tif (p[0] != 0)\n\t{\n\t    if (region_names == NULL)\t    // first language with regions\n\t\tregion_names = p;\n\t    else if (STRCMP(region_names, p) != 0)\n\t    {\n\t\tdo_region = FALSE;\t    // region names are different\n\t\tbreak;\n\t    }\n\t}\n    }\n\n    if (do_region && region_names != NULL)\n    {\n\tif (pat == NULL)\n\t{\n\t    vim_snprintf((char *)IObuff, IOSIZE, \"/regions=%s\", region_names);\n\t    ml_append(lnum++, IObuff, (colnr_T)0, FALSE);\n\t}\n    }\n    else\n\tdo_region = FALSE;\n\n    /*\n     * Loop over all files loaded for the entries in 'spelllang'.\n     */\n    for (lpi = 0; lpi < curwin->w_s->b_langp.ga_len; ++lpi)\n    {\n\tlp = LANGP_ENTRY(curwin->w_s->b_langp, lpi);\n\tslang = lp->lp_slang;\n\tif (slang->sl_fbyts == NULL)\t    // reloading failed\n\t    continue;\n\n\tif (pat == NULL)\n\t{\n\t    vim_snprintf((char *)IObuff, IOSIZE, \"# file: %s\", slang->sl_fname);\n\t    ml_append(lnum++, IObuff, (colnr_T)0, FALSE);\n\t}\n\n\t// When matching with a pattern and there are no prefixes only use\n\t// parts of the tree that match \"pat\".\n\tif (pat != NULL && slang->sl_pbyts == NULL)\n\t    patlen = (int)STRLEN(pat);\n\telse\n\t    patlen = -1;\n\n\t// round 1: case-folded tree\n\t// round 2: keep-case tree\n\tfor (round = 1; round <= 2; ++round)\n\t{\n\t    if (round == 1)\n\t    {\n\t\tdumpflags &= ~DUMPFLAG_KEEPCASE;\n\t\tbyts = slang->sl_fbyts;\n\t\tidxs = slang->sl_fidxs;\n\t    }\n\t    else\n\t    {\n\t\tdumpflags |= DUMPFLAG_KEEPCASE;\n\t\tbyts = slang->sl_kbyts;\n\t\tidxs = slang->sl_kidxs;\n\t    }\n\t    if (byts == NULL)\n\t\tcontinue;\t\t// array is empty\n\n\t    depth = 0;\n\t    arridx[0] = 0;\n\t    curi[0] = 1;\n\t    while (depth >= 0 && !got_int\n\t\t\t\t  && (pat == NULL || !ins_compl_interrupted()))\n\t    {\n\t\tif (curi[depth] > byts[arridx[depth]])\n\t\t{\n\t\t    // Done all bytes at this node, go up one level.\n\t\t    --depth;\n\t\t    line_breakcheck();\n\t\t    ins_compl_check_keys(50, FALSE);\n\t\t}\n\t\telse\n\t\t{\n\t\t    // Do one more byte at this node.\n\t\t    n = arridx[depth] + curi[depth];\n\t\t    ++curi[depth];\n\t\t    c = byts[n];\n\t\t    if (c == 0 || depth >= MAXWLEN - 1)\n\t\t    {\n\t\t\t// End of word or reached maximum length, deal with the\n\t\t\t// word.\n\t\t\t// Don't use keep-case words in the fold-case tree,\n\t\t\t// they will appear in the keep-case tree.\n\t\t\t// Only use the word when the region matches.\n\t\t\tflags = (int)idxs[n];\n\t\t\tif ((round == 2 || (flags & WF_KEEPCAP) == 0)\n\t\t\t\t&& (flags & WF_NEEDCOMP) == 0\n\t\t\t\t&& (do_region\n\t\t\t\t    || (flags & WF_REGION) == 0\n\t\t\t\t    || (((unsigned)flags >> 16)\n\t\t\t\t\t\t       & lp->lp_region) != 0))\n\t\t\t{\n\t\t\t    word[depth] = NUL;\n\t\t\t    if (!do_region)\n\t\t\t\tflags &= ~WF_REGION;\n\n\t\t\t    // Dump the basic word if there is no prefix or\n\t\t\t    // when it's the first one.\n\t\t\t    c = (unsigned)flags >> 24;\n\t\t\t    if (c == 0 || curi[depth] == 2)\n\t\t\t    {\n\t\t\t\tdump_word(slang, word, pat, dir,\n\t\t\t\t\t\t      dumpflags, flags, lnum);\n\t\t\t\tif (pat == NULL)\n\t\t\t\t    ++lnum;\n\t\t\t    }\n\n\t\t\t    // Apply the prefix, if there is one.\n\t\t\t    if (c != 0)\n\t\t\t\tlnum = dump_prefixes(slang, word, pat, dir,\n\t\t\t\t\t\t      dumpflags, flags, lnum);\n\t\t\t}\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t// Normal char, go one level deeper.\n\t\t\tword[depth++] = c;\n\t\t\tarridx[depth] = idxs[n];\n\t\t\tcuri[depth] = 1;\n\n\t\t\t// Check if this character matches with the pattern.\n\t\t\t// If not skip the whole tree below it.\n\t\t\t// Always ignore case here, dump_word() will check\n\t\t\t// proper case later.  This isn't exactly right when\n\t\t\t// length changes for multi-byte characters with\n\t\t\t// ignore case...\n\t\t\tif (depth <= patlen\n\t\t\t\t\t&& MB_STRNICMP(word, pat, depth) != 0)\n\t\t\t    --depth;\n\t\t    }\n\t\t}\n\t    }\n\t}\n    }\n}\n\n/*\n * Dump one word: apply case modifications and append a line to the buffer.\n * When \"lnum\" is zero add insert mode completion.\n */\n    static void\ndump_word(\n    slang_T\t*slang,\n    char_u\t*word,\n    char_u\t*pat,\n    int\t\t*dir,\n    int\t\tdumpflags,\n    int\t\twordflags,\n    linenr_T\tlnum)\n{\n    int\t\tkeepcap = FALSE;\n    char_u\t*p;\n    char_u\t*tw;\n    char_u\tcword[MAXWLEN];\n    char_u\tbadword[MAXWLEN + 10];\n    int\t\ti;\n    int\t\tflags = wordflags;\n\n    if (dumpflags & DUMPFLAG_ONECAP)\n\tflags |= WF_ONECAP;\n    if (dumpflags & DUMPFLAG_ALLCAP)\n\tflags |= WF_ALLCAP;\n\n    if ((dumpflags & DUMPFLAG_KEEPCASE) == 0 && (flags & WF_CAPMASK) != 0)\n    {\n\t// Need to fix case according to \"flags\".\n\tmake_case_word(word, cword, flags);\n\tp = cword;\n    }\n    else\n    {\n\tp = word;\n\tif ((dumpflags & DUMPFLAG_KEEPCASE)\n\t\t&& ((captype(word, NULL) & WF_KEEPCAP) == 0\n\t\t\t\t\t\t || (flags & WF_FIXCAP) != 0))\n\t    keepcap = TRUE;\n    }\n    tw = p;\n\n    if (pat == NULL)\n    {\n\t// Add flags and regions after a slash.\n\tif ((flags & (WF_BANNED | WF_RARE | WF_REGION)) || keepcap)\n\t{\n\t    STRCPY(badword, p);\n\t    STRCAT(badword, \"/\");\n\t    if (keepcap)\n\t\tSTRCAT(badword, \"=\");\n\t    if (flags & WF_BANNED)\n\t\tSTRCAT(badword, \"!\");\n\t    else if (flags & WF_RARE)\n\t\tSTRCAT(badword, \"?\");\n\t    if (flags & WF_REGION)\n\t\tfor (i = 0; i < 7; ++i)\n\t\t    if (flags & (0x10000 << i))\n\t\t\tsprintf((char *)badword + STRLEN(badword), \"%d\", i + 1);\n\t    p = badword;\n\t}\n\n\tif (dumpflags & DUMPFLAG_COUNT)\n\t{\n\t    hashitem_T  *hi;\n\n\t    // Include the word count for \":spelldump!\".\n\t    hi = hash_find(&slang->sl_wordcount, tw);\n\t    if (!HASHITEM_EMPTY(hi))\n\t    {\n\t\tvim_snprintf((char *)IObuff, IOSIZE, \"%s\\t%d\",\n\t\t\t\t\t\t     tw, HI2WC(hi)->wc_count);\n\t\tp = IObuff;\n\t    }\n\t}\n\n\tml_append(lnum, p, (colnr_T)0, FALSE);\n    }\n    else if (((dumpflags & DUMPFLAG_ICASE)\n\t\t    ? MB_STRNICMP(p, pat, STRLEN(pat)) == 0\n\t\t    : STRNCMP(p, pat, STRLEN(pat)) == 0)\n\t\t&& ins_compl_add_infercase(p, (int)STRLEN(p),\n\t\t\t\t\t  p_ic, NULL, *dir, FALSE) == OK)\n\t// if dir was BACKWARD then honor it just once\n\t*dir = FORWARD;\n}\n\n/*\n * For \":spelldump\": Find matching prefixes for \"word\".  Prepend each to\n * \"word\" and append a line to the buffer.\n * When \"lnum\" is zero add insert mode completion.\n * Return the updated line number.\n */\n    static linenr_T\ndump_prefixes(\n    slang_T\t*slang,\n    char_u\t*word,\t    // case-folded word\n    char_u\t*pat,\n    int\t\t*dir,\n    int\t\tdumpflags,\n    int\t\tflags,\t    // flags with prefix ID\n    linenr_T\tstartlnum)\n{\n    idx_T\tarridx[MAXWLEN];\n    int\t\tcuri[MAXWLEN];\n    char_u\tprefix[MAXWLEN];\n    char_u\tword_up[MAXWLEN];\n    int\t\thas_word_up = FALSE;\n    int\t\tc;\n    char_u\t*byts;\n    idx_T\t*idxs;\n    linenr_T\tlnum = startlnum;\n    int\t\tdepth;\n    int\t\tn;\n    int\t\tlen;\n    int\t\ti;\n\n    // If the word starts with a lower-case letter make the word with an\n    // upper-case letter in word_up[].\n    c = PTR2CHAR(word);\n    if (SPELL_TOUPPER(c) != c)\n    {\n\tonecap_copy(word, word_up, TRUE);\n\thas_word_up = TRUE;\n    }\n\n    byts = slang->sl_pbyts;\n    idxs = slang->sl_pidxs;\n    if (byts != NULL)\t\t// array not is empty\n    {\n\t/*\n\t * Loop over all prefixes, building them byte-by-byte in prefix[].\n\t * When at the end of a prefix check that it supports \"flags\".\n\t */\n\tdepth = 0;\n\tarridx[0] = 0;\n\tcuri[0] = 1;\n\twhile (depth >= 0 && !got_int)\n\t{\n\t    n = arridx[depth];\n\t    len = byts[n];\n\t    if (curi[depth] > len)\n\t    {\n\t\t// Done all bytes at this node, go up one level.\n\t\t--depth;\n\t\tline_breakcheck();\n\t    }\n\t    else\n\t    {\n\t\t// Do one more byte at this node.\n\t\tn += curi[depth];\n\t\t++curi[depth];\n\t\tc = byts[n];\n\t\tif (c == 0)\n\t\t{\n\t\t    // End of prefix, find out how many IDs there are.\n\t\t    for (i = 1; i < len; ++i)\n\t\t\tif (byts[n + i] != 0)\n\t\t\t    break;\n\t\t    curi[depth] += i - 1;\n\n\t\t    c = valid_word_prefix(i, n, flags, word, slang, FALSE);\n\t\t    if (c != 0)\n\t\t    {\n\t\t\tvim_strncpy(prefix + depth, word, MAXWLEN - depth - 1);\n\t\t\tdump_word(slang, prefix, pat, dir, dumpflags,\n\t\t\t\t(c & WF_RAREPFX) ? (flags | WF_RARE)\n\t\t\t\t\t\t\t       : flags, lnum);\n\t\t\tif (lnum != 0)\n\t\t\t    ++lnum;\n\t\t    }\n\n\t\t    // Check for prefix that matches the word when the\n\t\t    // first letter is upper-case, but only if the prefix has\n\t\t    // a condition.\n\t\t    if (has_word_up)\n\t\t    {\n\t\t\tc = valid_word_prefix(i, n, flags, word_up, slang,\n\t\t\t\t\t\t\t\t\tTRUE);\n\t\t\tif (c != 0)\n\t\t\t{\n\t\t\t    vim_strncpy(prefix + depth, word_up,\n\t\t\t\t\t\t\t MAXWLEN - depth - 1);\n\t\t\t    dump_word(slang, prefix, pat, dir, dumpflags,\n\t\t\t\t    (c & WF_RAREPFX) ? (flags | WF_RARE)\n\t\t\t\t\t\t\t       : flags, lnum);\n\t\t\t    if (lnum != 0)\n\t\t\t\t++lnum;\n\t\t\t}\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    // Normal char, go one level deeper.\n\t\t    prefix[depth++] = c;\n\t\t    arridx[depth] = idxs[n];\n\t\t    curi[depth] = 1;\n\t\t}\n\t    }\n\t}\n    }\n\n    return lnum;\n}\n\n/*\n * Move \"p\" to the end of word \"start\".\n * Uses the spell-checking word characters.\n */\n    char_u *\nspell_to_word_end(char_u *start, win_T *win)\n{\n    char_u  *p = start;\n\n    while (*p != NUL && spell_iswordp(p, win))\n\tMB_PTR_ADV(p);\n    return p;\n}\n\n/*\n * For Insert mode completion CTRL-X s:\n * Find start of the word in front of column \"startcol\".\n * We don't check if it is badly spelled, with completion we can only change\n * the word in front of the cursor.\n * Returns the column number of the word.\n */\n    int\nspell_word_start(int startcol)\n{\n    char_u\t*line;\n    char_u\t*p;\n    int\t\tcol = 0;\n\n    if (no_spell_checking(curwin))\n\treturn startcol;\n\n    // Find a word character before \"startcol\".\n    line = ml_get_curline();\n    for (p = line + startcol; p > line; )\n    {\n\tMB_PTR_BACK(line, p);\n\tif (spell_iswordp_nmw(p, curwin))\n\t    break;\n    }\n\n    // Go back to start of the word.\n    while (p > line)\n    {\n\tcol = (int)(p - line);\n\tMB_PTR_BACK(line, p);\n\tif (!spell_iswordp(p, curwin))\n\t    break;\n\tcol = 0;\n    }\n\n    return col;\n}\n\n/*\n * Need to check for 'spellcapcheck' now, the word is removed before\n * expand_spelling() is called.  Therefore the ugly global variable.\n */\nstatic int spell_expand_need_cap;\n\n    void\nspell_expand_check_cap(colnr_T col)\n{\n    spell_expand_need_cap = check_need_cap(curwin->w_cursor.lnum, col);\n}\n\n/*\n * Get list of spelling suggestions.\n * Used for Insert mode completion CTRL-X ?.\n * Returns the number of matches.  The matches are in \"matchp[]\", array of\n * allocated strings.\n */\n    int\nexpand_spelling(\n    linenr_T\tlnum UNUSED,\n    char_u\t*pat,\n    char_u\t***matchp)\n{\n    garray_T\tga;\n\n    spell_suggest_list(&ga, pat, 100, spell_expand_need_cap, TRUE);\n    *matchp = ga.ga_data;\n    return ga.ga_len;\n}\n\n/*\n * Return TRUE if \"val\" is a valid 'spelllang' value.\n */\n    int\nvalid_spelllang(char_u *val)\n{\n    return valid_name(val, \".-_,@\");\n}\n\n/*\n * Return TRUE if \"val\" is a valid 'spellfile' value.\n */\n    int\nvalid_spellfile(char_u *val)\n{\n    char_u *s;\n\n    for (s = val; *s != NUL; ++s)\n\tif (!vim_is_fname_char(*s))\n\t    return FALSE;\n    return TRUE;\n}\n\n/*\n * Handle side effects of setting 'spell'.\n * Return an error message or NULL for success.\n */\n    char *\ndid_set_spell_option(int is_spellfile)\n{\n    char    *errmsg = NULL;\n    win_T   *wp;\n    int\t    l;\n\n    if (is_spellfile)\n    {\n\tl = (int)STRLEN(curwin->w_s->b_p_spf);\n\tif (l > 0 && (l < 4\n\t\t\t|| STRCMP(curwin->w_s->b_p_spf + l - 4, \".add\") != 0))\n\t    errmsg = e_invalid_argument;\n    }\n\n    if (errmsg == NULL)\n    {\n\tFOR_ALL_WINDOWS(wp)\n\t    if (wp->w_buffer == curbuf && wp->w_p_spell)\n\t    {\n\t\terrmsg = did_set_spelllang(wp);\n\t\tbreak;\n\t    }\n    }\n    return errmsg;\n}\n\n/*\n * Set curbuf->b_cap_prog to the regexp program for 'spellcapcheck'.\n * Return error message when failed, NULL when OK.\n */\n    char *\ncompile_cap_prog(synblock_T *synblock)\n{\n    regprog_T   *rp = synblock->b_cap_prog;\n    char_u\t*re;\n\n    if (synblock->b_p_spc == NULL || *synblock->b_p_spc == NUL)\n\tsynblock->b_cap_prog = NULL;\n    else\n    {\n\t// Prepend a ^ so that we only match at one column\n\tre = concat_str((char_u *)\"^\", synblock->b_p_spc);\n\tif (re != NULL)\n\t{\n\t    synblock->b_cap_prog = vim_regcomp(re, RE_MAGIC);\n\t    vim_free(re);\n\t    if (synblock->b_cap_prog == NULL)\n\t    {\n\t\tsynblock->b_cap_prog = rp; // restore the previous program\n\t\treturn e_invalid_argument;\n\t    }\n\t}\n    }\n\n    vim_regfree(rp);\n    return NULL;\n}\n\n#endif  // FEAT_SPELL\n", "\" Test spell checking\n\" Note: this file uses latin1 encoding, but is used with utf-8 encoding.\n\nsource check.vim\nCheckFeature spell\n\nsource screendump.vim\n\nfunc TearDown()\n  set nospell\n  call delete('Xtest.aff')\n  call delete('Xtest.dic')\n  call delete('Xtest.latin1.add')\n  call delete('Xtest.latin1.add.spl')\n  call delete('Xtest.latin1.spl')\n  call delete('Xtest.latin1.sug')\n  \" set 'encoding' to clear the word list\n  set encoding=utf-8\nendfunc\n\nfunc Test_wrap_search()\n  new\n  call setline(1, ['The', '', 'A plong line with two zpelling mistakes', '', 'End'])\n  set spell wrapscan\n  normal ]s\n  call assert_equal('plong', expand('<cword>'))\n  normal ]s\n  call assert_equal('zpelling', expand('<cword>'))\n  normal ]s\n  call assert_equal('plong', expand('<cword>'))\n  bwipe!\n  set nospell\nendfunc\n\nfunc Test_curswant()\n  new\n  call setline(1, ['Another plong line', 'abcdefghijklmnopq'])\n  set spell wrapscan\n  normal 0]s\n  call assert_equal('plong', expand('<cword>'))\n  normal j\n  call assert_equal(9, getcurpos()[2])\n  normal 0[s\n  call assert_equal('plong', expand('<cword>'))\n  normal j\n  call assert_equal(9, getcurpos()[2])\n\n  normal 0]S\n  call assert_equal('plong', expand('<cword>'))\n  normal j\n  call assert_equal(9, getcurpos()[2])\n  normal 0[S\n  call assert_equal('plong', expand('<cword>'))\n  normal j\n  call assert_equal(9, getcurpos()[2])\n\n  normal 1G0\n  call assert_equal('plong', spellbadword()[0])\n  normal j\n  call assert_equal(9, getcurpos()[2])\n\n  bwipe!\n  set nospell\nendfunc\n\nfunc Test_z_equal_on_invalid_utf8_word()\n  split\n  set spell\n  call setline(1, \"\\xff\")\n  norm z=\n  set nospell\n  bwipe!\nendfunc\n\nfunc Test_z_equal_on_single_character()\n  \" this was decrementing the index below zero\n  new\n  norm a0\\\u0118\n  norm zW\n  norm \u0016z=\n\n  bwipe!\nendfunc\n\n\" Test spellbadword() with argument\nfunc Test_spellbadword()\n  set spell\n\n  call assert_equal(['bycycle', 'bad'],  spellbadword('My bycycle.'))\n  call assert_equal(['another', 'caps'], 'A sentence. another sentence'->spellbadword())\n\n  call assert_equal(['TheCamelWord', 'bad'], 'TheCamelWord asdf'->spellbadword())\n  set spelloptions=camel\n  call assert_equal(['asdf', 'bad'], 'TheCamelWord asdf'->spellbadword())\n  set spelloptions=\n\n  set spelllang=en\n  call assert_equal(['', ''],            spellbadword('centre'))\n  call assert_equal(['', ''],            spellbadword('center'))\n  set spelllang=en_us\n  call assert_equal(['centre', 'local'], spellbadword('centre'))\n  call assert_equal(['', ''],            spellbadword('center'))\n  set spelllang=en_gb\n  call assert_equal(['', ''],            spellbadword('centre'))\n  call assert_equal(['center', 'local'], spellbadword('center'))\n\n  \" Create a small word list to test that spellbadword('...')\n  \" can return ['...', 'rare'].\n  e Xwords\n  insert\nfoo\nfoobar/?\n.\n   w!\n   mkspell! Xwords.spl Xwords\n   set spelllang=Xwords.spl\n   call assert_equal(['foobar', 'rare'], spellbadword('foo foobar'))\n\n  \" Typo should be detected even without the 'spell' option.\n  set spelllang=en_gb nospell\n  call assert_equal(['', ''], spellbadword('centre'))\n  call assert_equal(['bycycle', 'bad'], spellbadword('My bycycle.'))\n  call assert_equal(['another', 'caps'], spellbadword('A sentence. another sentence'))\n\n  set spelllang=\n  call assert_fails(\"call spellbadword('maxch')\", 'E756:')\n  call assert_fails(\"spelldump\", 'E756:')\n\n  call delete('Xwords.spl')\n  call delete('Xwords')\n  set spelllang&\n  set spell&\nendfunc\n\nfunc Test_spell_file_missing()\n  let s:spell_file_missing = 0\n  augroup TestSpellFileMissing\n    autocmd! SpellFileMissing * let s:spell_file_missing += 1\n  augroup END\n\n  set spell spelllang=ab_cd\n  let messages = GetMessages()\n  call assert_equal('Warning: Cannot find word list \"ab.utf-8.spl\" or \"ab.ascii.spl\"', messages[-1])\n  call assert_equal(1, s:spell_file_missing)\n\n  new XTestSpellFileMissing\n  augroup TestSpellFileMissing\n    autocmd! SpellFileMissing * bwipe\n  augroup END\n  call assert_fails('set spell spelllang=ab_cd', 'E937:')\n\n  \" clean up\n  augroup TestSpellFileMissing\n    autocmd! SpellFileMissing\n  augroup END\n  augroup! TestSpellFileMissing\n  unlet s:spell_file_missing\n  set spell& spelllang&\n  %bwipe!\nendfunc\n\nfunc Test_spelldump()\n  \" In case the spell file is not found avoid getting the download dialog, we\n  \" would get stuck at the prompt.\n  let g:en_not_found = 0\n  augroup TestSpellFileMissing\n    au! SpellFileMissing * let g:en_not_found = 1\n  augroup END\n  set spell spelllang=en\n  spellrare! emacs\n  if g:en_not_found\n    call assert_report(\"Could not find English spell file\")\n  else\n    spelldump\n\n    \" Check assumption about region: 1: us, 2: au, 3: ca, 4: gb, 5: nz.\n    call assert_equal('/regions=usaucagbnz', getline(1))\n    call assert_notequal(0, search('^theater/1$'))    \" US English only.\n    call assert_notequal(0, search('^theatre/2345$')) \" AU, CA, GB or NZ English.\n\n    call assert_notequal(0, search('^emacs/?$'))      \" ? for a rare word.\n    call assert_notequal(0, search('^the the/!$'))    \" ! for a wrong word.\n  endif\n\n  \" clean up\n  unlet g:en_not_found\n  augroup TestSpellFileMissing\n    autocmd! SpellFileMissing\n  augroup END\n  augroup! TestSpellFileMissing\n  bwipe\n  set spell&\nendfunc\n\nfunc Test_spelldump_bang()\n  new\n  call setline(1, 'This is a sample sentence.')\n  redraw\n\n  \" In case the spell file is not found avoid getting the download dialog, we\n  \" would get stuck at the prompt.\n  let g:en_not_found = 0\n  augroup TestSpellFileMissing\n    au! SpellFileMissing * let g:en_not_found = 1\n  augroup END\n\n  set spell\n\n  if g:en_not_found\n    call assert_report(\"Could not find English spell file\")\n  else\n    redraw\n    spelldump!\n\n    \" :spelldump! includes the number of times a word was found while updating\n    \" the screen.\n    \" Common word count starts at 10, regular word count starts at 0.\n    call assert_notequal(0, search(\"^is\\t11$\"))    \" common word found once.\n    call assert_notequal(0, search(\"^the\\t10$\"))   \" common word never found.\n    call assert_notequal(0, search(\"^sample\\t1$\")) \" regular word found once.\n    call assert_equal(0, search(\"^screen\\t\"))      \" regular word never found.\n  endif\n\n  \" clean up\n  unlet g:en_not_found\n  augroup TestSpellFileMissing\n    autocmd! SpellFileMissing\n  augroup END\n  augroup! TestSpellFileMissing\n  %bwipe!\n  set spell&\nendfunc\n\nfunc Test_spelllang_inv_region()\n  set spell spelllang=en_xx\n  let messages = GetMessages()\n  call assert_equal('Warning: region xx not supported', messages[-1])\n  set spell& spelllang&\nendfunc\n\nfunc Test_compl_with_CTRL_X_CTRL_K_using_spell()\n  \" When spell checking is enabled and 'dictionary' is empty,\n  \" CTRL-X CTRL-K in insert mode completes using the spelling dictionary.\n  new\n  set spell spelllang=en dictionary=\n\n  set ignorecase\n  call feedkeys(\"Senglis\\<c-x>\\<c-k>\\<esc>\", 'tnx')\n  call assert_equal(['English'], getline(1, '$'))\n  call feedkeys(\"SEnglis\\<c-x>\\<c-k>\\<esc>\", 'tnx')\n  call assert_equal(['English'], getline(1, '$'))\n\n  set noignorecase\n  call feedkeys(\"Senglis\\<c-x>\\<c-k>\\<esc>\", 'tnx')\n  call assert_equal(['englis'], getline(1, '$'))\n  call feedkeys(\"SEnglis\\<c-x>\\<c-k>\\<esc>\", 'tnx')\n  call assert_equal(['English'], getline(1, '$'))\n\n  set spelllang=en_us\n  call feedkeys(\"Stheat\\<c-x>\\<c-k>\\<esc>\", 'tnx')\n  call assert_equal(['theater'], getline(1, '$'))\n  set spelllang=en_gb\n  call feedkeys(\"Stheat\\<c-x>\\<c-k>\\<esc>\", 'tnx')\n  \" FIXME: commented out, expected theatre bug got theater. See issue #7025.\n  \" call assert_equal(['theatre'], getline(1, '$'))\n\n  bwipe!\n  set spell& spelllang& dictionary& ignorecase&\nendfunc\n\nfunc Test_spellreall()\n  new\n  set spell\n  call assert_fails('spellrepall', 'E752:')\n  call setline(1, ['A speling mistake. The same speling mistake.',\n        \\                'Another speling mistake.'])\n  call feedkeys(']s1z=', 'tx')\n  call assert_equal('A spelling mistake. The same speling mistake.', getline(1))\n  call assert_equal('Another speling mistake.', getline(2))\n  spellrepall\n  call assert_equal('A spelling mistake. The same spelling mistake.', getline(1))\n  call assert_equal('Another spelling mistake.', getline(2))\n  call assert_fails('spellrepall', 'E753:')\n  set spell&\n  bwipe!\nendfunc\n\nfunc Test_spell_dump_word_length()\n  \" this was running over MAXWLEN\n  new\n  noremap 0 0a0zW0000000\n  sil! norm \u00160z=0\u0018\u000b\n  sil norm 0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n  sil! norm \u00160z=0\u0018\u000b\n\n  bwipe!\n  nunmap 0\nendfunc\n\n\" Test spellsuggest({word} [, {max} [, {capital}]])\nfunc Test_spellsuggest()\n  \" Verify suggestions are given even when spell checking is not enabled.\n  set nospell\n  call assert_equal(['march', 'March'], spellsuggest('marrch', 2))\n\n  set spell\n\n  \" With 1 argument.\n  call assert_equal(['march', 'March'], spellsuggest('marrch')[0:1])\n\n  \" With 2 arguments.\n  call assert_equal(['march', 'March'], spellsuggest('marrch', 2))\n\n  \" With 3 arguments.\n  call assert_equal(['march'], spellsuggest('marrch', 1, 0))\n  call assert_equal(['March'], spellsuggest('marrch', 1, 1))\n\n  \" Test with digits and hyphen.\n  call assert_equal('Carbon-14', spellsuggest('Carbon-15')[0])\n\n  \" Comment taken from spellsuggest.c explains the following test cases:\n  \"\n  \" If there are more UPPER than lower case letters suggest an\n  \" ALLCAP word.  Otherwise, if the first letter is UPPER then\n  \" suggest ONECAP.  Exception: \"ALl\" most likely should be \"All\",\n  \" require three upper case letters.\n  call assert_equal(['THIRD', 'third'], spellsuggest('thIRD', 2))\n  call assert_equal(['third', 'THIRD'], spellsuggest('tHIrd', 2))\n  call assert_equal(['Third'], spellsuggest('THird', 1))\n  call assert_equal(['All'],      spellsuggest('ALl', 1))\n\n  \" Special suggestion for repeated 'the the'.\n  call assert_inrange(0, 2, index(spellsuggest('the the',   3), 'the'))\n  call assert_inrange(0, 2, index(spellsuggest('the   the', 3), 'the'))\n  call assert_inrange(0, 2, index(spellsuggest('The the',   3), 'The'))\n\n  call assert_fails(\"call spellsuggest('maxch', [])\", 'E745:')\n  call assert_fails(\"call spellsuggest('maxch', 2, [])\", 'E745:')\n\n  set spelllang=\n  call assert_fails(\"call spellsuggest('maxch')\", 'E756:')\n  set spelllang&\n\n  set spell&\nendfunc\n\n\" Test 'spellsuggest' option with methods fast, best and double.\nfunc Test_spellsuggest_option_methods()\n  set spell\n\n  for e in ['latin1', 'utf-8']\n    exe 'set encoding=' .. e\n\n    set spellsuggest=fast\n    call assert_equal(['Stick', 'Stitch'], spellsuggest('Stich', 2), e)\n\n    \" With best or double option, \"Stitch\" should become the top suggestion\n    \" because of better phonetic matching.\n    set spellsuggest=best\n    call assert_equal(['Stitch', 'Stick'], spellsuggest('Stich', 2), e)\n\n    set spellsuggest=double\n    call assert_equal(['Stitch', 'Stick'], spellsuggest('Stich', 2), e)\n  endfor\n\n  set spell& spellsuggest& encoding&\nendfunc\n\n\" Test 'spellsuggest' option with value file:{filename}\nfunc Test_spellsuggest_option_file()\n  set spell spellsuggest=file:Xspellsuggest\n  call writefile(['emacs/vim',\n        \\         'theribal/terrible',\n        \\         'teribal/terrrible',\n        \\         'terribal'],\n        \\         'Xspellsuggest')\n\n  call assert_equal(['vim'],      spellsuggest('emacs', 2))\n  call assert_equal(['terrible'], spellsuggest('theribal',2))\n\n  \" If the suggestion is misspelled (*terrrible* with 3 r),\n  \" it should not be proposed.\n  \" The entry for \"terribal\" should be ignored because of missing slash.\n  call assert_equal([], spellsuggest('teribal', 2))\n  call assert_equal([], spellsuggest('terribal', 2))\n\n  set spell spellsuggest=best,file:Xspellsuggest\n  call assert_equal(['vim', 'Emacs'],       spellsuggest('emacs', 2))\n  call assert_equal(['terrible', 'tribal'], spellsuggest('theribal', 2))\n  call assert_equal(['tribal'],             spellsuggest('teribal', 1))\n  call assert_equal(['tribal'],             spellsuggest('terribal', 1))\n\n  call delete('Xspellsuggest')\n  call assert_fails(\"call spellsuggest('vim')\", \"E484: Can't open file Xspellsuggest\")\n\n  set spellsuggest& spell&\nendfunc\n\n\" Test 'spellsuggest' option with value {number}\n\" to limit the number of suggestions\nfunc Test_spellsuggest_option_number()\n  set spell spellsuggest=2,best\n  new\n\n  \" We limited the number of suggestions to 2, so selecting\n  \" the 1st and 2nd suggestion should correct the word, but\n  \" selecting a 3rd suggestion should do nothing.\n  call setline(1, 'A baord')\n  norm $1z=\n  call assert_equal('A board', getline(1))\n\n  call setline(1, 'A baord')\n  norm $2z=\n  call assert_equal('A bard', getline(1))\n\n  call setline(1, 'A baord')\n  norm $3z=\n  call assert_equal('A baord', getline(1))\n\n  let a = execute('norm $z=')\n  call assert_equal(\n  \\    \"\\n\"\n  \\ .. \"Change \\\"baord\\\" to:\\n\"\n  \\ .. \" 1 \\\"board\\\"\\n\"\n  \\ .. \" 2 \\\"bard\\\"\\n\"\n  \\ .. \"Type number and <Enter> or click with the mouse (q or empty cancels): \", a)\n\n  set spell spellsuggest=0\n  call assert_equal(\"\\nSorry, no suggestions\", execute('norm $z='))\n\n  \" Unlike z=, function spellsuggest(...) should not be affected by the\n  \" max number of suggestions (2) set by the 'spellsuggest' option.\n  call assert_equal(['board', 'bard', 'broad'], spellsuggest('baord', 3))\n\n  set spellsuggest& spell&\n  bwipe!\nendfunc\n\n\" Test 'spellsuggest' option with value expr:{expr}\nfunc Test_spellsuggest_option_expr()\n  \" A silly 'spellsuggest' function which makes suggestions all uppercase\n  \" and makes the score of each suggestion the length of the suggested word.\n  \" So shorter suggestions are preferred.\n  func MySuggest()\n    let spellsuggest_save = &spellsuggest\n    set spellsuggest=3,best\n    let result = map(spellsuggest(v:val, 3), \"[toupper(v:val), len(v:val)]\")\n    let &spellsuggest = spellsuggest_save\n    return result\n  endfunc\n\n  set spell spellsuggest=expr:MySuggest()\n  call assert_equal(['BARD', 'BOARD', 'BROAD'], spellsuggest('baord', 3))\n\n  new\n  call setline(1, 'baord')\n  let a = execute('norm z=')\n  call assert_equal(\n  \\    \"\\n\"\n  \\ .. \"Change \\\"baord\\\" to:\\n\"\n  \\ .. \" 1 \\\"BARD\\\"\\n\"\n  \\ .. \" 2 \\\"BOARD\\\"\\n\"\n  \\ .. \" 3 \\\"BROAD\\\"\\n\"\n  \\ .. \"Type number and <Enter> or click with the mouse (q or empty cancels): \", a)\n\n  \" With verbose, z= should show the score i.e. word length with\n  \" our SpellSuggest() function.\n  set verbose=1\n  let a = execute('norm z=')\n  call assert_equal(\n  \\    \"\\n\"\n  \\ .. \"Change \\\"baord\\\" to:\\n\"\n  \\ .. \" 1 \\\"BARD\\\"                      (4 - 0)\\n\"\n  \\ .. \" 2 \\\"BOARD\\\"                     (5 - 0)\\n\"\n  \\ .. \" 3 \\\"BROAD\\\"                     (5 - 0)\\n\"\n  \\ .. \"Type number and <Enter> or click with the mouse (q or empty cancels): \", a)\n\n  set spell& spellsuggest& verbose&\n  bwipe!\nendfunc\n\n\" Test for 'spellsuggest' expr errors\nfunc Test_spellsuggest_expr_errors()\n  \" 'spellsuggest'\n  func MySuggest()\n    return range(3)\n  endfunc\n  set spell spellsuggest=expr:MySuggest()\n  call assert_equal([], spellsuggest('baord', 3))\n\n  \" Test for 'spellsuggest' expression returning a non-list value\n  func! MySuggest2()\n    return 'good'\n  endfunc\n  set spellsuggest=expr:MySuggest2()\n  call assert_equal([], spellsuggest('baord'))\n\n  \" Test for 'spellsuggest' expression returning a list with dict values\n  func! MySuggest3()\n    return [[{}, {}]]\n  endfunc\n  set spellsuggest=expr:MySuggest3()\n  call assert_fails(\"call spellsuggest('baord')\", 'E731:')\n\n  set nospell spellsuggest&\n  delfunc MySuggest\n  delfunc MySuggest2\n  delfunc MySuggest3\nendfunc\n\nfunc Test_spellsuggest_timeout()\n  set spellsuggest=timeout:30\n  set spellsuggest=timeout:-123\n  set spellsuggest=timeout:999999\n  call assert_fails('set spellsuggest=timeout', 'E474:')\n  call assert_fails('set spellsuggest=timeout:x', 'E474:')\n  call assert_fails('set spellsuggest=timeout:-x', 'E474:')\n  call assert_fails('set spellsuggest=timeout:--9', 'E474:')\nendfunc\n\nfunc Test_spellsuggest_visual_end_of_line()\n  let enc_save = &encoding\n  set encoding=iso8859\n\n  \" This was reading beyond the end of the line.\n  norm R00000000000\n  sil norm \u00160\n  sil! norm \u0016i00000)\n  sil! norm \u0016i00000)\n  call feedkeys(\"\\<CR>\")\n  norm z=\n\n  let &encoding = enc_save\nendfunc\n\nfunc Test_spellinfo()\n  new\n  let runtime = substitute($VIMRUNTIME, '\\\\', '/', 'g')\n\n  set enc=latin1 spell spelllang=en\n  call assert_match(\"^\\nfile: \" .. runtime .. \"/spell/en.latin1.spl\\n$\", execute('spellinfo'))\n\n  set enc=cp1250 spell spelllang=en\n  call assert_match(\"^\\nfile: \" .. runtime .. \"/spell/en.ascii.spl\\n$\", execute('spellinfo'))\n\n  set enc=utf-8 spell spelllang=en\n  call assert_match(\"^\\nfile: \" .. runtime .. \"/spell/en.utf-8.spl\\n$\", execute('spellinfo'))\n\n  set enc=latin1 spell spelllang=en_us,en_nz\n  call assert_match(\"^\\n\" .\n                 \\  \"file: \" .. runtime .. \"/spell/en.latin1.spl\\n\" .\n                 \\  \"file: \" .. runtime.. \"/spell/en.latin1.spl\\n$\", execute('spellinfo'))\n\n  set spell spelllang=\n  call assert_fails('spellinfo', 'E756:')\n\n  set nospell spelllang=en\n  call assert_fails('spellinfo', 'E756:')\n\n  call assert_fails('set spelllang=foo/bar', 'E474:')\n  call assert_fails('set spelllang=foo\\ bar', 'E474:')\n  call assert_fails(\"set spelllang=foo\\\\\\nbar\", 'E474:')\n  call assert_fails(\"set spelllang=foo\\\\\\rbar\", 'E474:')\n  call assert_fails(\"set spelllang=foo+bar\", 'E474:')\n\n  set enc& spell& spelllang&\n  bwipe\nendfunc\n\nfunc Test_zz_basic()\n  call LoadAffAndDic(g:test_data_aff1, g:test_data_dic1)\n  call RunGoodBad(\"wrong OK puts. Test the end\",\n        \\ \"bad: inputs comment ok Ok. test d\\xE9\\xF4l end the\",\n        \\[\"Comment\", \"deol\", \"d\\xE9\\xF4r\", \"input\", \"OK\", \"output\", \"outputs\", \"outtest\", \"put\", \"puts\",\n        \\  \"test\", \"testen\", \"testn\", \"the end\", \"uk\", \"wrong\"],\n        \\[\n        \\   [\"bad\", [\"put\", \"uk\", \"OK\"]],\n        \\   [\"inputs\", [\"input\", \"puts\", \"outputs\"]],\n        \\   [\"comment\", [\"Comment\", \"outtest\", \"the end\"]],\n        \\   [\"ok\", [\"OK\", \"uk\", \"put\"]],\n        \\   [\"Ok\", [\"OK\", \"Uk\", \"Put\"]],\n        \\   [\"test\", [\"Test\", \"testn\", \"testen\"]],\n        \\   [\"d\\xE9\\xF4l\", [\"deol\", \"d\\xE9\\xF4r\", \"test\"]],\n        \\   [\"end\", [\"put\", \"uk\", \"test\"]],\n        \\   [\"the\", [\"put\", \"uk\", \"test\"]],\n        \\ ]\n        \\ )\n\n  call assert_equal(\"gebletegek\", soundfold('goobledygoook'))\n  call assert_equal(\"kepereneven\", 'k\u00f3op\u00ebr\u02d9n\u00f4ven'->soundfold())\n  call assert_equal(\"everles gesvets etele\", soundfold('oeverloos gezwets edale'))\nendfunc\n\n\" Postponed prefixes\nfunc Test_zz_prefixes()\n  call LoadAffAndDic(g:test_data_aff2, g:test_data_dic1)\n  call RunGoodBad(\"puts\",\n        \\ \"bad: inputs comment ok Ok end the. test d\\xE9\\xF4l\",\n        \\ [\"Comment\", \"deol\", \"d\\xE9\\xF4r\", \"OK\", \"put\", \"input\", \"output\", \"puts\", \"outputs\", \"test\", \"outtest\", \"testen\", \"testn\", \"the end\", \"uk\", \"wrong\"],\n        \\ [\n        \\   [\"bad\", [\"put\", \"uk\", \"OK\"]],\n        \\   [\"inputs\", [\"input\", \"puts\", \"outputs\"]],\n        \\   [\"comment\", [\"Comment\"]],\n        \\   [\"ok\", [\"OK\", \"uk\", \"put\"]],\n        \\   [\"Ok\", [\"OK\", \"Uk\", \"Put\"]],\n        \\   [\"end\", [\"put\", \"uk\", \"deol\"]],\n        \\   [\"the\", [\"put\", \"uk\", \"test\"]],\n        \\   [\"test\", [\"Test\", \"testn\", \"testen\"]],\n        \\   [\"d\\xE9\\xF4l\", [\"deol\", \"d\\xE9\\xF4r\", \"test\"]],\n        \\ ])\nendfunc\n\n\"Compound words\nfunc Test_zz_compound()\n  call LoadAffAndDic(g:test_data_aff3, g:test_data_dic3)\n  call RunGoodBad(\"foo m\\xEF foobar foofoobar barfoo barbarfoo\",\n        \\ \"bad: bar la foom\\xEF barm\\xEF m\\xEFfoo m\\xEFbar m\\xEFm\\xEF lala m\\xEFla lam\\xEF foola labar\",\n        \\ [\"foo\", \"m\\xEF\"],\n        \\ [\n        \\   [\"bad\", [\"foo\", \"m\\xEF\"]],\n        \\   [\"bar\", [\"barfoo\", \"foobar\", \"foo\"]],\n        \\   [\"la\", [\"m\\xEF\", \"foo\"]],\n        \\   [\"foom\\xEF\", [\"foo m\\xEF\", \"foo\", \"foofoo\"]],\n        \\   [\"barm\\xEF\", [\"barfoo\", \"m\\xEF\", \"barbar\"]],\n        \\   [\"m\\xEFfoo\", [\"m\\xEF foo\", \"foo\", \"foofoo\"]],\n        \\   [\"m\\xEFbar\", [\"foobar\", \"barbar\", \"m\\xEF\"]],\n        \\   [\"m\\xEFm\\xEF\", [\"m\\xEF m\\xEF\", \"m\\xEF\"]],\n        \\   [\"lala\", []],\n        \\   [\"m\\xEFla\", [\"m\\xEF\", \"m\\xEF m\\xEF\"]],\n        \\   [\"lam\\xEF\", [\"m\\xEF\", \"m\\xEF m\\xEF\"]],\n        \\   [\"foola\", [\"foo\", \"foobar\", \"foofoo\"]],\n        \\   [\"labar\", [\"barbar\", \"foobar\"]],\n        \\ ])\n\n  call LoadAffAndDic(g:test_data_aff4, g:test_data_dic4)\n  call RunGoodBad(\"word util bork prebork start end wordutil wordutils pro-ok bork borkbork borkborkbork borkborkborkbork borkborkborkborkbork tomato tomatotomato startend startword startwordword startwordend startwordwordend startwordwordwordend prebork preborkbork preborkborkbork nouword\",\n        \\ \"bad: wordutilize pro borkborkborkborkborkbork tomatotomatotomato endstart endend startstart wordend wordstart preborkprebork  preborkpreborkbork startwordwordwordwordend borkpreborkpreborkbork utilsbork  startnouword\",\n        \\ [\"bork\", \"prebork\", \"end\", \"pro-ok\", \"start\", \"tomato\", \"util\", \"utilize\", \"utils\", \"word\", \"nouword\"],\n        \\ [\n        \\   [\"bad\", [\"end\", \"bork\", \"word\"]],\n        \\   [\"wordutilize\", [\"word utilize\", \"wordutils\", \"wordutil\"]],\n        \\   [\"pro\", [\"bork\", \"word\", \"end\"]],\n        \\   [\"borkborkborkborkborkbork\", [\"bork borkborkborkborkbork\", \"borkbork borkborkborkbork\", \"borkborkbork borkborkbork\"]],\n        \\   [\"tomatotomatotomato\", [\"tomato tomatotomato\", \"tomatotomato tomato\", \"tomato tomato tomato\"]],\n        \\   [\"endstart\", [\"end start\", \"start\"]],\n        \\   [\"endend\", [\"end end\", \"end\"]],\n        \\   [\"startstart\", [\"start start\"]],\n        \\   [\"wordend\", [\"word end\", \"word\", \"wordword\"]],\n        \\   [\"wordstart\", [\"word start\", \"bork start\"]],\n        \\   [\"preborkprebork\", [\"prebork prebork\", \"preborkbork\", \"preborkborkbork\"]],\n        \\   [\"preborkpreborkbork\", [\"prebork preborkbork\", \"preborkborkbork\", \"preborkborkborkbork\"]],\n        \\   [\"startwordwordwordwordend\", [\"startwordwordwordword end\", \"startwordwordwordword\", \"start wordwordwordword end\"]],\n        \\   [\"borkpreborkpreborkbork\", [\"bork preborkpreborkbork\", \"bork prebork preborkbork\", \"bork preborkprebork bork\"]],\n        \\   [\"utilsbork\", [\"utilbork\", \"utils bork\", \"util bork\"]],\n        \\   [\"startnouword\", [\"start nouword\", \"startword\", \"startborkword\"]],\n        \\ ])\n\nendfunc\n\n\"Test affix flags with two characters\nfunc Test_zz_affix()\n  call LoadAffAndDic(g:test_data_aff5, g:test_data_dic5)\n  call RunGoodBad(\"fooa1 fooa\\xE9 bar prebar barbork prebarbork  startprebar start end startend  startmiddleend nouend\",\n        \\ \"bad: foo fooa2 prabar probarbirk middle startmiddle middleend endstart startprobar startnouend\",\n        \\ [\"bar\", \"barbork\", \"end\", \"fooa1\", \"fooa\\xE9\", \"nouend\", \"prebar\", \"prebarbork\", \"start\"],\n        \\ [\n        \\   [\"bad\", [\"bar\", \"end\", \"fooa1\"]],\n        \\   [\"foo\", [\"fooa1\", \"fooa\\xE9\", \"bar\"]],\n        \\   [\"fooa2\", [\"fooa1\", \"fooa\\xE9\", \"bar\"]],\n        \\   [\"prabar\", [\"prebar\", \"bar\", \"bar bar\"]],\n        \\   [\"probarbirk\", [\"prebarbork\"]],\n        \\   [\"middle\", []],\n        \\   [\"startmiddle\", [\"startmiddleend\", \"startmiddlebar\"]],\n        \\   [\"middleend\", []],\n        \\   [\"endstart\", [\"end start\", \"start\"]],\n        \\   [\"startprobar\", [\"startprebar\", \"start prebar\", \"startbar\"]],\n        \\   [\"startnouend\", [\"start nouend\", \"startend\"]],\n        \\ ])\n\n  call LoadAffAndDic(g:test_data_aff6, g:test_data_dic6)\n  call RunGoodBad(\"meea1 meea\\xE9 bar prebar barbork prebarbork  leadprebar lead end leadend  leadmiddleend\",\n        \\  \"bad: mee meea2 prabar probarbirk middle leadmiddle middleend endlead leadprobar\",\n        \\ [\"bar\", \"barbork\", \"end\", \"lead\", \"meea1\", \"meea\\xE9\", \"prebar\", \"prebarbork\"],\n        \\ [\n        \\   [\"bad\", [\"bar\", \"end\", \"lead\"]],\n        \\   [\"mee\", [\"meea1\", \"meea\\xE9\", \"bar\"]],\n        \\   [\"meea2\", [\"meea1\", \"meea\\xE9\", \"lead\"]],\n        \\   [\"prabar\", [\"prebar\", \"bar\", \"leadbar\"]],\n        \\   [\"probarbirk\", [\"prebarbork\"]],\n        \\   [\"middle\", []],\n        \\   [\"leadmiddle\", [\"leadmiddleend\", \"leadmiddlebar\"]],\n        \\   [\"middleend\", []],\n        \\   [\"endlead\", [\"end lead\", \"lead\", \"end end\"]],\n        \\   [\"leadprobar\", [\"leadprebar\", \"lead prebar\", \"leadbar\"]],\n        \\ ])\n\n  call LoadAffAndDic(g:test_data_aff7, g:test_data_dic7)\n  call RunGoodBad(\"meea1 meezero meea\\xE9 bar prebar barmeat prebarmeat  leadprebar lead tail leadtail  leadmiddletail\",\n        \\ \"bad: mee meea2 prabar probarmaat middle leadmiddle middletail taillead leadprobar\",\n        \\ [\"bar\", \"barmeat\", \"lead\", \"meea1\", \"meea\\xE9\", \"meezero\", \"prebar\", \"prebarmeat\", \"tail\"],\n        \\ [\n        \\   [\"bad\", [\"bar\", \"lead\", \"tail\"]],\n        \\   [\"mee\", [\"meea1\", \"meea\\xE9\", \"bar\"]],\n        \\   [\"meea2\", [\"meea1\", \"meea\\xE9\", \"lead\"]],\n        \\   [\"prabar\", [\"prebar\", \"bar\", \"leadbar\"]],\n        \\   [\"probarmaat\", [\"prebarmeat\"]],\n        \\   [\"middle\", []],\n        \\   [\"leadmiddle\", [\"leadmiddlebar\"]],\n        \\   [\"middletail\", []],\n        \\   [\"taillead\", [\"tail lead\", \"tail\"]],\n        \\   [\"leadprobar\", [\"leadprebar\", \"lead prebar\", \"leadbar\"]],\n        \\ ])\nendfunc\n\nfunc Test_zz_NOSLITSUGS()\n  call LoadAffAndDic(g:test_data_aff8, g:test_data_dic8)\n  call RunGoodBad(\"foo bar faabar\", \"bad: foobar barfoo\",\n        \\ [\"bar\", \"faabar\", \"foo\"],\n        \\ [\n        \\   [\"bad\", [\"bar\", \"foo\"]],\n        \\   [\"foobar\", [\"faabar\", \"foo bar\", \"bar\"]],\n        \\   [\"barfoo\", [\"bar foo\", \"bar\", \"foo\"]],\n        \\ ])\nendfunc\n\n\" Numbers\nfunc Test_zz_Numbers()\n  call LoadAffAndDic(g:test_data_aff9, g:test_data_dic9)\n  call RunGoodBad(\"0b1011 0777 1234 0x01ff\", \"\",\n        \\ [\"bar\", \"foo\"],\n        \\ [\n        \\ ])\nendfunc\n\n\" Affix flags\nfunc Test_zz_affix_flags()\n  call LoadAffAndDic(g:test_data_aff10, g:test_data_dic10)\n  call RunGoodBad(\"drink drinkable drinkables drinktable drinkabletable\",\n\t\\ \"bad: drinks drinkstable drinkablestable\",\n        \\ [\"drink\", \"drinkable\", \"drinkables\", \"table\"],\n        \\ [['bad', []],\n\t\\ ['drinks', ['drink']],\n\t\\ ['drinkstable', ['drinktable', 'drinkable', 'drink table']],\n        \\ ['drinkablestable', ['drinkabletable', 'drinkables table', 'drinkable table']],\n\t\\ ])\nendfunc\n\nfunction FirstSpellWord()\n  call feedkeys(\"/^start:\\n\", 'tx')\n  normal ]smm\n  let [str, a] = spellbadword()\n  return str\nendfunc\n\nfunction SecondSpellWord()\n  normal `m]s\n  let [str, a] = spellbadword()\n  return str\nendfunc\n\n\"Test with SAL instead of SOFO items; test automatic reloading\nfunc Test_zz_sal_and_addition()\n  set enc=latin1\n  set spellfile=\n  call writefile(g:test_data_dic1, \"Xtest.dic\", 'D')\n  call writefile(g:test_data_aff_sal, \"Xtest.aff\", 'D')\n  mkspell! Xtest Xtest\n  set spl=Xtest.latin1.spl spell\n  call assert_equal('kbltykk', soundfold('goobledygoook'))\n  call assert_equal('kprnfn', soundfold('k\u00f3op\u00ebr\u02d9n\u00f4ven'))\n  call assert_equal('*fls kswts tl', soundfold('oeverloos gezwets edale'))\n\n  \"also use an addition file\n  call writefile([\"/regions=usgbnz\", \"elequint/2\", \"elekwint/3\"], \"Xtest.latin1.add\", 'D')\n  mkspell! Xtest.latin1.add.spl Xtest.latin1.add\n\n  bwipe!\n  call setline(1, [\"start: elequint test elekwint test elekwent asdf\"])\n\n  set spellfile=Xtest.latin1.add\n  call assert_equal(\"elekwent\", FirstSpellWord())\n\n  set spl=Xtest_us.latin1.spl\n  call assert_equal(\"elequint\", FirstSpellWord())\n  call assert_equal(\"elekwint\", SecondSpellWord())\n\n  set spl=Xtest_gb.latin1.spl\n  call assert_equal(\"elekwint\", FirstSpellWord())\n  call assert_equal(\"elekwent\", SecondSpellWord())\n\n  set spl=Xtest_nz.latin1.spl\n  call assert_equal(\"elequint\", FirstSpellWord())\n  call assert_equal(\"elekwent\", SecondSpellWord())\n\n  set spl=Xtest_ca.latin1.spl\n  call assert_equal(\"elequint\", FirstSpellWord())\n  call assert_equal(\"elekwint\", SecondSpellWord())\n\n  bwipe!\n  set spellfile=\n  set spl&\nendfunc\n\nfunc Test_spellfile_value()\n  set spellfile=Xdir/Xtest.latin1.add\n  set spellfile=Xdir/Xtest.utf-8.add,Xtest_other.add\nendfunc\n\nfunc Test_region_error()\n  messages clear\n  call writefile([\"/regions=usgbnz\", \"elequint/0\"], \"Xtest.latin1.add\", 'D')\n  mkspell! Xtest.latin1.add.spl Xtest.latin1.add\n  call assert_match('Invalid region nr in Xtest.latin1.add line 2: 0', execute('messages'))\n  call delete('Xtest.latin1.add.spl')\nendfunc\n\n\" Check using z= in new buffer (crash fixed by patch 7.4a.028).\nfunc Test_zeq_crash()\n  new\n  set maxmem=512 spell\n  call feedkeys('iasd\u001bz=:\\\"', 'tx')\n\n  bwipe!\nendfunc\n\n\" Check that z= works even when 'nospell' is set.  This test uses one of the\n\" tests in Test_spellsuggest_option_number() just to verify that z= basically\n\" works and that \"E756: Spell checking is not enabled\" is not generated.\nfunc Test_zeq_nospell()\n  new\n  set nospell spellsuggest=1,best\n  call setline(1, 'A baord')\n  try\n    norm $1z=\n    call assert_equal('A board', getline(1))\n  catch\n    call assert_report(\"Caught exception: \" . v:exception)\n  endtry\n  set spell& spellsuggest&\n  bwipe!\nendfunc\n\n\" Check that \"E756: Spell checking is not possible\" is reported when z= is\n\" executed and 'spelllang' is empty.\nfunc Test_zeq_no_spelllang()\n  new\n  set spelllang= spellsuggest=1,best\n  call setline(1, 'A baord')\n  call assert_fails('normal $1z=', 'E756:')\n  set spelllang& spellsuggest&\n  bwipe!\nendfunc\n\n\" Check handling a word longer than MAXWLEN.\nfunc Test_spell_long_word()\n  set enc=utf-8\n  new\n  call setline(1, \"d\\xCC\\xB4\\xCC\\xBD\\xCD\\x88\\xCD\\x94a\\xCC\\xB5\\xCD\\x84\\xCD\\x84\\xCC\\xA8\\xCD\\x9Cr\\xCC\\xB5\\xCC\\x8E\\xCD\\x85\\xCD\\x85k\\xCC\\xB6\\xCC\\x89\\xCC\\x9D \\xCC\\xB6\\xCC\\x83\\xCC\\x8F\\xCC\\xA4\\xCD\\x8Ef\\xCC\\xB7\\xCC\\x81\\xCC\\x80\\xCC\\xA9\\xCC\\xB0\\xCC\\xAC\\xCC\\xA2\\xCD\\x95\\xCD\\x87\\xCD\\x8D\\xCC\\x9E\\xCD\\x99\\xCC\\xAD\\xCC\\xAB\\xCC\\x97\\xCC\\xBBo\\xCC\\xB6\\xCC\\x84\\xCC\\x95\\xCC\\x8C\\xCC\\x8B\\xCD\\x9B\\xCD\\x9C\\xCC\\xAFr\\xCC\\xB7\\xCC\\x94\\xCD\\x83\\xCD\\x97\\xCC\\x8C\\xCC\\x82\\xCD\\x82\\xCD\\x80\\xCD\\x91\\xCC\\x80\\xCC\\xBE\\xCC\\x82\\xCC\\x8F\\xCC\\xA3\\xCD\\x85\\xCC\\xAE\\xCD\\x8D\\xCD\\x99\\xCC\\xBC\\xCC\\xAB\\xCC\\xA7\\xCD\\x88c\\xCC\\xB7\\xCD\\x83\\xCC\\x84\\xCD\\x92\\xCC\\x86\\xCC\\x83\\xCC\\x88\\xCC\\x92\\xCC\\x94\\xCC\\xBE\\xCC\\x9D\\xCC\\xAF\\xCC\\x98\\xCC\\x9D\\xCC\\xBB\\xCD\\x8E\\xCC\\xBB\\xCC\\xB3\\xCC\\xA3\\xCD\\x8E\\xCD\\x99\\xCC\\xA5\\xCC\\xAD\\xCC\\x99\\xCC\\xB9\\xCC\\xAE\\xCC\\xA5\\xCC\\x9E\\xCD\\x88\\xCC\\xAE\\xCC\\x9E\\xCC\\xA9\\xCC\\x97\\xCC\\xBC\\xCC\\x99\\xCC\\xA5\\xCD\\x87\\xCC\\x97\\xCD\\x8E\\xCD\\x94\\xCC\\x99\\xCC\\x9D\\xCC\\x96\\xCD\\x94\\xCC\\xAB\\xCC\\xA7\\xCC\\xA5\\xCC\\x98\\xCC\\xBB\\xCC\\xAF\\xCC\\xABe\\xCC\\xB7\\xCC\\x8E\\xCC\\x82\\xCD\\x86\\xCD\\x9B\\xCC\\x94\\xCD\\x83\\xCC\\x85\\xCD\\x8A\\xCD\\x8C\\xCC\\x8B\\xCD\\x92\\xCD\\x91\\xCC\\x8F\\xCC\\x81\\xCD\\x95\\xCC\\xA2\\xCC\\xB9\\xCC\\xB2\\xCD\\x9C\\xCC\\xB1\\xCC\\xA6\\xCC\\xB3\\xCC\\xAF\\xCC\\xAE\\xCC\\x9C\\xCD\\x99s\\xCC\\xB8\\xCC\\x8C\\xCC\\x8E\\xCC\\x87\\xCD\\x81\\xCD\\x82\\xCC\\x86\\xCD\\x8C\\xCD\\x8C\\xCC\\x8B\\xCC\\x84\\xCC\\x8C\\xCD\\x84\\xCD\\x9B\\xCD\\x86\\xCC\\x93\\xCD\\x90\\xCC\\x85\\xCC\\x94\\xCD\\x98\\xCD\\x84\\xCD\\x92\\xCD\\x8B\\xCC\\x90\\xCC\\x83\\xCC\\x8F\\xCD\\x84\\xCD\\x81\\xCD\\x9B\\xCC\\x90\\xCD\\x81\\xCC\\x8F\\xCC\\xBD\\xCC\\x88\\xCC\\xBF\\xCC\\x88\\xCC\\x84\\xCC\\x8E\\xCD\\x99\\xCD\\x94\\xCC\\x99\\xCD\\x99\\xCC\\xB0\\xCC\\xA8\\xCC\\xA3\\xCC\\xA8\\xCC\\x96\\xCC\\x99\\xCC\\xAE\\xCC\\xBC\\xCC\\x99\\xCD\\x9A\\xCC\\xB2\\xCC\\xB1\\xCC\\x9F\\xCC\\xBB\\xCC\\xA6\\xCD\\x85\\xCC\\xAA\\xCD\\x89\\xCC\\x9D\\xCC\\x99\\xCD\\x96\\xCC\\xB1\\xCC\\xB1\\xCC\\x99\\xCC\\xA6\\xCC\\xA5\\xCD\\x95\\xCC\\xB2\\xCC\\xA0\\xCD\\x99 within\")\n  set spell spelllang=en\n  redraw\n  redraw!\n  bwipe!\n  set nospell\nendfunc\n\nfunc Test_spellsuggest_too_deep()\n  \" This was incrementing \"depth\" over MAXWLEN.\n  new\n  norm \u0016s000G00\u00fd000000000000\n  sil norm ..vzG................vvzG0     v z=\n  bwipe!\nendfunc\n\nfunc Test_spell_good_word_invalid()\n  \" This was adding a word with a 0x02 byte, which causes havoc.\n  enew\n  norm o0\n  sil! norm rzzWs00\u0002/\n  2\n  sil! norm VzGprzzW\n  sil! norm z=\n\n  bwipe!\nendfunc\n\nfunc Test_spell_good_word_slash()\n  \" This caused E1280.\n  new\n  norm afoo /\n  1\n  norm zG\n\n  bwipe!\nendfunc\n\nfunc LoadAffAndDic(aff_contents, dic_contents)\n  set enc=latin1\n  set spellfile=\n  call writefile(a:aff_contents, \"Xtest.aff\")\n  call writefile(a:dic_contents, \"Xtest.dic\")\n  \" Generate a .spl file from a .dic and .aff file.\n  mkspell! Xtest Xtest\n  \" use that spell file\n  set spl=Xtest.latin1.spl spell\nendfunc\n\nfunc ListWords()\n  spelldump\n  %yank\n  quit\n  return split(@\", \"\\n\")\nendfunc\n\nfunc TestGoodBadBase()\n  exe '1;/^good:'\n  normal 0f:]s\n  let prevbad = ''\n  let result = []\n  while 1\n    let [bad, a] = spellbadword()\n    if bad == '' || bad == prevbad || bad == 'badend'\n      break\n    endif\n    let prevbad = bad\n    let lst = bad->spellsuggest(3)\n    normal mm\n\n    call add(result, [bad, lst])\n    normal `m]s\n  endwhile\n  return result\nendfunc\n\nfunc RunGoodBad(good, bad, expected_words, expected_bad_words)\n  bwipe!\n  call setline(1, [\"good: \", a:good,  a:bad, \" badend \"])\n  let words = ListWords()\n  call assert_equal(a:expected_words, words[1:-1])\n  let bad_words = TestGoodBadBase()\n  call assert_equal(a:expected_bad_words, bad_words)\n  bwipe!\nendfunc\n\nfunc Test_spell_screendump()\n  CheckScreendump\n\n  let lines =<< trim END\n       call setline(1, [\n             \\ \"This is some text without any spell errors.  Everything\",\n             \\ \"should just be black, nothing wrong here.\",\n             \\ \"\",\n             \\ \"This line has a sepll error. and missing caps.\",\n             \\ \"And and this is the the duplication.\",\n             \\ \"with missing caps here.\",\n             \\ ])\n       set spell spelllang=en_nz\n  END\n  call writefile(lines, 'XtestSpell', 'D')\n  let buf = RunVimInTerminal('-S XtestSpell', {'rows': 8})\n  call VerifyScreenDump(buf, 'Test_spell_1', {})\n\n  \" clean up\n  call StopVimInTerminal(buf)\nendfunc\n\nfunc Test_spell_screendump_spellcap()\n  CheckScreendump\n\n  let lines =<< trim END\n       call setline(1, [\n             \\ \"   This line has a sepll error. and missing caps and trailing spaces.   \",\n             \\ \"another missing cap here.\",\n             \\ \"\",\n             \\ \"and here.\",\n             \\ \"    \",\n             \\ \"and here.\"\n             \\ ])\n       set spell spelllang=en\n  END\n  call writefile(lines, 'XtestSpellCap', 'D')\n  let buf = RunVimInTerminal('-S XtestSpellCap', {'rows': 8})\n  call VerifyScreenDump(buf, 'Test_spell_2', {})\n\n  \" After adding word missing Cap in next line is updated\n  call term_sendkeys(buf, \"3GANot\\<Esc>\")\n  call VerifyScreenDump(buf, 'Test_spell_3', {})\n\n  \" Deleting a full stop removes missing Cap in next line\n  call term_sendkeys(buf, \"5Gddk$x\")\n  call VerifyScreenDump(buf, 'Test_spell_4', {})\n\n  \" Undo also updates the next line (go to command line to remove message)\n  call term_sendkeys(buf, \"u:\\<Esc>\")\n  call VerifyScreenDump(buf, 'Test_spell_5', {})\n\n  \" clean up\n  call StopVimInTerminal(buf)\nendfunc\n\nfunc Test_spell_compatible()\n  CheckScreendump\n\n  let lines =<< trim END\n       call setline(1, [\n             \\ \"test \"->repeat(20),\n             \\ \"\",\n             \\ \"end\",\n             \\ ])\n       set spell cpo+=$\n  END\n  call writefile(lines, 'XtestSpellComp', 'D')\n  let buf = RunVimInTerminal('-S XtestSpellComp', {'rows': 8})\n\n  call term_sendkeys(buf, \"51|C\")\n  call VerifyScreenDump(buf, 'Test_spell_compatible_1', {})\n\n  call term_sendkeys(buf, \"x\")\n  call VerifyScreenDump(buf, 'Test_spell_compatible_2', {})\n\n  \" clean up\n  call StopVimInTerminal(buf)\nendfunc\n\nlet g:test_data_aff1 = [\n      \\\"SET ISO8859-1\",\n      \\\"TRY esianrtolcdugmphbyfvkwjkqxz-\\xEB\\xE9\\xE8\\xEA\\xEF\\xEE\\xE4\\xE0\\xE2\\xF6\\xFC\\xFB'ESIANRTOLCDUGMPHBYFVKWJKQXZ\",\n      \\\"\",\n      \\\"FOL  \\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\\xE6\\xE7\\xE8\\xE9\\xEA\\xEB\\xEC\\xED\\xEE\\xEF\\xF0\\xF1\\xF2\\xF3\\xF4\\xF5\\xF6\\xF8\\xF9\\xFA\\xFB\\xFC\\xFD\\xFE\\xDF\\xFF\",\n      \\\"LOW  \\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\\xE6\\xE7\\xE8\\xE9\\xEA\\xEB\\xEC\\xED\\xEE\\xEF\\xF0\\xF1\\xF2\\xF3\\xF4\\xF5\\xF6\\xF8\\xF9\\xFA\\xFB\\xFC\\xFD\\xFE\\xDF\\xFF\",\n      \\\"UPP  \\xC0\\xC1\\xC2\\xC3\\xC4\\xC5\\xC6\\xC7\\xC8\\xC9\\xCA\\xCB\\xCC\\xCD\\xCE\\xCF\\xD0\\xD1\\xD2\\xD3\\xD4\\xD5\\xD6\\xD8\\xD9\\xDA\\xDB\\xDC\\xDD\\xDE\\xDF\\xFF\",\n      \\\"\",\n      \\\"SOFOFROM abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\\xE6\\xE7\\xE8\\xE9\\xEA\\xEB\\xEC\\xED\\xEE\\xEF\\xF0\\xF1\\xF2\\xF3\\xF4\\xF5\\xF6\\xF8\\xF9\\xFA\\xFB\\xFC\\xFD\\xFE\\xDF\\xFF\\xC0\\xC1\\xC2\\xC3\\xC4\\xC5\\xC6\\xC7\\xC8\\xC9\\xCA\\xCB\\xCC\\xCD\\xCE\\xCF\\xD0\\xD1\\xD2\\xD3\\xD4\\xD5\\xD6\\xD8\\xD9\\xDA\\xDB\\xDC\\xDD\\xDE\\xBF\",\n      \\\"SOFOTO   ebctefghejklnnepkrstevvkesebctefghejklnnepkrstevvkeseeeeeeeceeeeeeeedneeeeeeeeeeepseeeeeeeeceeeeeeeedneeeeeeeeeeep?\",\n      \\\"\",\n      \\\"MIDWORD\\t'-\",\n      \\\"\",\n      \\\"KEP =\",\n      \\\"RAR ?\",\n      \\\"BAD !\",\n      \\\"\",\n      \\\"PFX I N 1\",\n      \\\"PFX I 0 in .\",\n      \\\"\",\n      \\\"PFX O Y 1\",\n      \\\"PFX O 0 out .\",\n      \\\"\",\n      \\\"SFX S Y 2\",\n      \\\"SFX S 0 s [^s]\",\n      \\\"SFX S 0 es s\",\n      \\\"\",\n      \\\"SFX N N 3\",\n      \\\"SFX N 0 en [^n]\",\n      \\\"SFX N 0 nen n\",\n      \\\"SFX N 0 n .\",\n      \\\"\",\n      \\\"REP 3\",\n      \\\"REP g ch\",\n      \\\"REP ch g\",\n      \\\"REP svp s.v.p.\",\n      \\\"\",\n      \\\"MAP 9\",\n      \\\"MAP a\\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\",\n      \\\"MAP e\\xE8\\xE9\\xEA\\xEB\",\n      \\\"MAP i\\xEC\\xED\\xEE\\xEF\",\n      \\\"MAP o\\xF2\\xF3\\xF4\\xF5\\xF6\",\n      \\\"MAP u\\xF9\\xFA\\xFB\\xFC\",\n      \\\"MAP n\\xF1\",\n      \\\"MAP c\\xE7\",\n      \\\"MAP y\\xFF\\xFD\",\n      \\\"MAP s\\xDF\",\n      \\ ]\nlet g:test_data_dic1 = [\n      \\\"123456\",\n      \\\"test/NO\",\n      \\\"# comment\",\n      \\\"wrong\",\n      \\\"Comment\",\n      \\\"OK\",\n      \\\"uk\",\n      \\\"put/ISO\",\n      \\\"the end\",\n      \\\"deol\",\n      \\\"d\\xE9\\xF4r\",\n      \\ ]\nlet g:test_data_aff2 = [\n      \\\"SET ISO8859-1\",\n      \\\"\",\n      \\\"FOL  \\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\\xE6\\xE7\\xE8\\xE9\\xEA\\xEB\\xEC\\xED\\xEE\\xEF\\xF0\\xF1\\xF2\\xF3\\xF4\\xF5\\xF6\\xF8\\xF9\\xFA\\xFB\\xFC\\xFD\\xFE\\xDF\\xFF\",\n      \\\"LOW  \\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\\xE6\\xE7\\xE8\\xE9\\xEA\\xEB\\xEC\\xED\\xEE\\xEF\\xF0\\xF1\\xF2\\xF3\\xF4\\xF5\\xF6\\xF8\\xF9\\xFA\\xFB\\xFC\\xFD\\xFE\\xDF\\xFF\",\n      \\\"UPP  \\xC0\\xC1\\xC2\\xC3\\xC4\\xC5\\xC6\\xC7\\xC8\\xC9\\xCA\\xCB\\xCC\\xCD\\xCE\\xCF\\xD0\\xD1\\xD2\\xD3\\xD4\\xD5\\xD6\\xD8\\xD9\\xDA\\xDB\\xDC\\xDD\\xDE\\xDF\\xFF\",\n      \\\"\",\n      \\\"PFXPOSTPONE\",\n      \\\"\",\n      \\\"MIDWORD\\t'-\",\n      \\\"\",\n      \\\"KEP =\",\n      \\\"RAR ?\",\n      \\\"BAD !\",\n      \\\"\",\n      \\\"PFX I N 1\",\n      \\\"PFX I 0 in .\",\n      \\\"\",\n      \\\"PFX O Y 1\",\n      \\\"PFX O 0 out [a-z]\",\n      \\\"\",\n      \\\"SFX S Y 2\",\n      \\\"SFX S 0 s [^s]\",\n      \\\"SFX S 0 es s\",\n      \\\"\",\n      \\\"SFX N N 3\",\n      \\\"SFX N 0 en [^n]\",\n      \\\"SFX N 0 nen n\",\n      \\\"SFX N 0 n .\",\n      \\\"\",\n      \\\"REP 3\",\n      \\\"REP g ch\",\n      \\\"REP ch g\",\n      \\\"REP svp s.v.p.\",\n      \\\"\",\n      \\\"MAP 9\",\n      \\\"MAP a\\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\",\n      \\\"MAP e\\xE8\\xE9\\xEA\\xEB\",\n      \\\"MAP i\\xEC\\xED\\xEE\\xEF\",\n      \\\"MAP o\\xF2\\xF3\\xF4\\xF5\\xF6\",\n      \\\"MAP u\\xF9\\xFA\\xFB\\xFC\",\n      \\\"MAP n\\xF1\",\n      \\\"MAP c\\xE7\",\n      \\\"MAP y\\xFF\\xFD\",\n      \\\"MAP s\\xDF\",\n      \\ ]\nlet g:test_data_aff3 = [\n      \\\"SET ISO8859-1\",\n      \\\"\",\n      \\\"COMPOUNDMIN 3\",\n      \\\"COMPOUNDRULE m*\",\n      \\\"NEEDCOMPOUND x\",\n      \\ ]\nlet g:test_data_dic3 = [\n      \\\"1234\",\n      \\\"foo/m\",\n      \\\"bar/mx\",\n      \\\"m\\xEF/m\",\n      \\\"la/mx\",\n      \\ ]\nlet g:test_data_aff4 = [\n      \\\"SET ISO8859-1\",\n      \\\"\",\n      \\\"FOL  \\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\\xE6\\xE7\\xE8\\xE9\\xEA\\xEB\\xEC\\xED\\xEE\\xEF\\xF0\\xF1\\xF2\\xF3\\xF4\\xF5\\xF6\\xF8\\xF9\\xFA\\xFB\\xFC\\xFD\\xFE\\xDF\\xFF\",\n      \\\"LOW  \\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\\xE6\\xE7\\xE8\\xE9\\xEA\\xEB\\xEC\\xED\\xEE\\xEF\\xF0\\xF1\\xF2\\xF3\\xF4\\xF5\\xF6\\xF8\\xF9\\xFA\\xFB\\xFC\\xFD\\xFE\\xDF\\xFF\",\n      \\\"UPP  \\xC0\\xC1\\xC2\\xC3\\xC4\\xC5\\xC6\\xC7\\xC8\\xC9\\xCA\\xCB\\xCC\\xCD\\xCE\\xCF\\xD0\\xD1\\xD2\\xD3\\xD4\\xD5\\xD6\\xD8\\xD9\\xDA\\xDB\\xDC\\xDD\\xDE\\xDF\\xFF\",\n      \\\"\",\n      \\\"COMPOUNDRULE m+\",\n      \\\"COMPOUNDRULE sm*e\",\n      \\\"COMPOUNDRULE sm+\",\n      \\\"COMPOUNDMIN 3\",\n      \\\"COMPOUNDWORDMAX 3\",\n      \\\"COMPOUNDFORBIDFLAG t\",\n      \\\"\",\n      \\\"COMPOUNDSYLMAX 5\",\n      \\\"SYLLABLE a\\xE1e\\xE9i\\xEDo\\xF3\\xF6\\xF5u\\xFA\\xFC\\xFBy/aa/au/ea/ee/ei/ie/oa/oe/oo/ou/uu/ui\",\n      \\\"\",\n      \\\"MAP 9\",\n      \\\"MAP a\\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\",\n      \\\"MAP e\\xE8\\xE9\\xEA\\xEB\",\n      \\\"MAP i\\xEC\\xED\\xEE\\xEF\",\n      \\\"MAP o\\xF2\\xF3\\xF4\\xF5\\xF6\",\n      \\\"MAP u\\xF9\\xFA\\xFB\\xFC\",\n      \\\"MAP n\\xF1\",\n      \\\"MAP c\\xE7\",\n      \\\"MAP y\\xFF\\xFD\",\n      \\\"MAP s\\xDF\",\n      \\\"\",\n      \\\"NEEDAFFIX x\",\n      \\\"\",\n      \\\"PFXPOSTPONE\",\n      \\\"\",\n      \\\"MIDWORD '-\",\n      \\\"\",\n      \\\"SFX q N 1\",\n      \\\"SFX q   0    -ok .\",\n      \\\"\",\n      \\\"SFX a Y 2\",\n      \\\"SFX a 0 s .\",\n      \\\"SFX a 0 ize/t .\",\n      \\\"\",\n      \\\"PFX p N 1\",\n      \\\"PFX p 0 pre .\",\n      \\\"\",\n      \\\"PFX P N 1\",\n      \\\"PFX P 0 nou .\",\n      \\ ]\nlet g:test_data_dic4 = [\n      \\\"1234\",\n      \\\"word/mP\",\n      \\\"util/am\",\n      \\\"pro/xq\",\n      \\\"tomato/m\",\n      \\\"bork/mp\",\n      \\\"start/s\",\n      \\\"end/e\",\n      \\ ]\nlet g:test_data_aff5 = [\n      \\\"SET ISO8859-1\",\n      \\\"\",\n      \\\"FLAG long\",\n      \\\"\",\n      \\\"NEEDAFFIX !!\",\n      \\\"\",\n      \\\"COMPOUNDRULE ssmm*ee\",\n      \\\"\",\n      \\\"NEEDCOMPOUND xx\",\n      \\\"COMPOUNDPERMITFLAG pp\",\n      \\\"\",\n      \\\"SFX 13 Y 1\",\n      \\\"SFX 13 0 bork .\",\n      \\\"\",\n      \\\"SFX a1 Y 1\",\n      \\\"SFX a1 0 a1 .\",\n      \\\"\",\n      \\\"SFX a\\xE9 Y 1\",\n      \\\"SFX a\\xE9 0 a\\xE9 .\",\n      \\\"\",\n      \\\"PFX zz Y 1\",\n      \\\"PFX zz 0 pre/pp .\",\n      \\\"\",\n      \\\"PFX yy Y 1\",\n      \\\"PFX yy 0 nou .\",\n      \\ ]\nlet g:test_data_dic5 = [\n      \\\"1234\",\n      \\\"foo/a1a\\xE9!!\",\n      \\\"bar/zz13ee\",\n      \\\"start/ss\",\n      \\\"end/eeyy\",\n      \\\"middle/mmxx\",\n      \\ ]\nlet g:test_data_aff6 = [\n      \\\"SET ISO8859-1\",\n      \\\"\",\n      \\\"FLAG caplong\",\n      \\\"\",\n      \\\"NEEDAFFIX A!\",\n      \\\"\",\n      \\\"COMPOUNDRULE sMm*Ee\",\n      \\\"\",\n      \\\"NEEDCOMPOUND Xx\",\n      \\\"\",\n      \\\"COMPOUNDPERMITFLAG p\",\n      \\\"\",\n      \\\"SFX N3 Y 1\",\n      \\\"SFX N3 0 bork .\",\n      \\\"\",\n      \\\"SFX A1 Y 1\",\n      \\\"SFX A1 0 a1 .\",\n      \\\"\",\n      \\\"SFX A\\xE9 Y 1\",\n      \\\"SFX A\\xE9 0 a\\xE9 .\",\n      \\\"\",\n      \\\"PFX Zz Y 1\",\n      \\\"PFX Zz 0 pre/p .\",\n      \\ ]\nlet g:test_data_dic6 = [\n      \\\"1234\",\n      \\\"mee/A1A\\xE9A!\",\n      \\\"bar/ZzN3Ee\",\n      \\\"lead/s\",\n      \\\"end/Ee\",\n      \\\"middle/MmXx\",\n      \\ ]\nlet g:test_data_aff7 = [\n      \\\"SET ISO8859-1\",\n      \\\"\",\n      \\\"FLAG num\",\n      \\\"\",\n      \\\"NEEDAFFIX 9999\",\n      \\\"\",\n      \\\"COMPOUNDRULE 2,77*123\",\n      \\\"\",\n      \\\"NEEDCOMPOUND 1\",\n      \\\"COMPOUNDPERMITFLAG 432\",\n      \\\"\",\n      \\\"SFX 61003 Y 1\",\n      \\\"SFX 61003 0 meat .\",\n      \\\"\",\n      \\\"SFX 0 Y 1\",\n      \\\"SFX 0 0 zero .\",\n      \\\"\",\n      \\\"SFX 391 Y 1\",\n      \\\"SFX 391 0 a1 .\",\n      \\\"\",\n      \\\"SFX 111 Y 1\",\n      \\\"SFX 111 0 a\\xE9 .\",\n      \\\"\",\n      \\\"PFX 17 Y 1\",\n      \\\"PFX 17 0 pre/432 .\",\n      \\ ]\nlet g:test_data_dic7 = [\n      \\\"1234\",\n      \\\"mee/0,391,111,9999\",\n      \\\"bar/17,61003,123\",\n      \\\"lead/2\",\n      \\\"tail/123\",\n      \\\"middle/77,1\",\n      \\ ]\nlet g:test_data_aff8 = [\n      \\\"SET ISO8859-1\",\n      \\\"\",\n      \\\"NOSPLITSUGS\",\n      \\ ]\nlet g:test_data_dic8 = [\n      \\\"1234\",\n      \\\"foo\",\n      \\\"bar\",\n      \\\"faabar\",\n      \\ ]\nlet g:test_data_aff9 = [\n      \\ ]\nlet g:test_data_dic9 = [\n      \\\"1234\",\n      \\\"foo\",\n      \\\"bar\",\n      \\ ]\nlet g:test_data_aff10 = [\n      \\\"COMPOUNDRULE se\",\n      \\\"COMPOUNDPERMITFLAG p\",\n      \\\"\",\n      \\\"SFX A Y 1\",\n      \\\"SFX A 0 able/Mp .\",\n      \\\"\",\n      \\\"SFX M Y 1\",\n      \\\"SFX M 0 s .\",\n      \\ ]\nlet g:test_data_dic10 = [\n      \\\"1234\",\n      \\\"drink/As\",\n      \\\"table/e\",\n      \\ ]\nlet g:test_data_aff_sal = [\n      \\\"SET ISO8859-1\",\n      \\\"TRY esianrtolcdugmphbyfvkwjkqxz-\\xEB\\xE9\\xE8\\xEA\\xEF\\xEE\\xE4\\xE0\\xE2\\xF6\\xFC\\xFB'ESIANRTOLCDUGMPHBYFVKWJKQXZ\",\n      \\\"\",\n      \\\"FOL  \\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\\xE6\\xE7\\xE8\\xE9\\xEA\\xEB\\xEC\\xED\\xEE\\xEF\\xF0\\xF1\\xF2\\xF3\\xF4\\xF5\\xF6\\xF8\\xF9\\xFA\\xFB\\xFC\\xFD\\xFE\\xDF\\xFF\",\n      \\\"LOW  \\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\\xE6\\xE7\\xE8\\xE9\\xEA\\xEB\\xEC\\xED\\xEE\\xEF\\xF0\\xF1\\xF2\\xF3\\xF4\\xF5\\xF6\\xF8\\xF9\\xFA\\xFB\\xFC\\xFD\\xFE\\xDF\\xFF\",\n      \\\"UPP  \\xC0\\xC1\\xC2\\xC3\\xC4\\xC5\\xC6\\xC7\\xC8\\xC9\\xCA\\xCB\\xCC\\xCD\\xCE\\xCF\\xD0\\xD1\\xD2\\xD3\\xD4\\xD5\\xD6\\xD8\\xD9\\xDA\\xDB\\xDC\\xDD\\xDE\\xDF\\xFF\",\n      \\\"\",\n      \\\"MIDWORD\\t'-\",\n      \\\"\",\n      \\\"KEP =\",\n      \\\"RAR ?\",\n      \\\"BAD !\",\n      \\\"\",\n      \\\"PFX I N 1\",\n      \\\"PFX I 0 in .\",\n      \\\"\",\n      \\\"PFX O Y 1\",\n      \\\"PFX O 0 out .\",\n      \\\"\",\n      \\\"SFX S Y 2\",\n      \\\"SFX S 0 s [^s]\",\n      \\\"SFX S 0 es s\",\n      \\\"\",\n      \\\"SFX N N 3\",\n      \\\"SFX N 0 en [^n]\",\n      \\\"SFX N 0 nen n\",\n      \\\"SFX N 0 n .\",\n      \\\"\",\n      \\\"REP 3\",\n      \\\"REP g ch\",\n      \\\"REP ch g\",\n      \\\"REP svp s.v.p.\",\n      \\\"\",\n      \\\"MAP 9\",\n      \\\"MAP a\\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\",\n      \\\"MAP e\\xE8\\xE9\\xEA\\xEB\",\n      \\\"MAP i\\xEC\\xED\\xEE\\xEF\",\n      \\\"MAP o\\xF2\\xF3\\xF4\\xF5\\xF6\",\n      \\\"MAP u\\xF9\\xFA\\xFB\\xFC\",\n      \\\"MAP n\\xF1\",\n      \\\"MAP c\\xE7\",\n      \\\"MAP y\\xFF\\xFD\",\n      \\\"MAP s\\xDF\",\n      \\\"\",\n      \\\"SAL AH(AEIOUY)-^         *H\",\n      \\\"SAL AR(AEIOUY)-^         *R\",\n      \\\"SAL A(HR)^               *\",\n      \\\"SAL A^                   *\",\n      \\\"SAL AH(AEIOUY)-          H\",\n      \\\"SAL AR(AEIOUY)-          R\",\n      \\\"SAL A(HR)                _\",\n      \\\"SAL \\xC0^                   *\",\n      \\\"SAL \\xC5^                   *\",\n      \\\"SAL BB-                  _\",\n      \\\"SAL B                    B\",\n      \\\"SAL CQ-                  _\",\n      \\\"SAL CIA                  X\",\n      \\\"SAL CH                   X\",\n      \\\"SAL C(EIY)-              S\",\n      \\\"SAL CK                   K\",\n      \\\"SAL COUGH^               KF\",\n      \\\"SAL CC<                  C\",\n      \\\"SAL C                    K\",\n      \\\"SAL DG(EIY)              K\",\n      \\\"SAL DD-                  _\",\n      \\\"SAL D                    T\",\n      \\\"SAL \\xC9<                   E\",\n      \\\"SAL EH(AEIOUY)-^         *H\",\n      \\\"SAL ER(AEIOUY)-^         *R\",\n      \\\"SAL E(HR)^               *\",\n      \\\"SAL ENOUGH^$             *NF\",\n      \\\"SAL E^                   *\",\n      \\\"SAL EH(AEIOUY)-          H\",\n      \\\"SAL ER(AEIOUY)-          R\",\n      \\\"SAL E(HR)                _\",\n      \\\"SAL FF-                  _\",\n      \\\"SAL F                    F\",\n      \\\"SAL GN^                  N\",\n      \\\"SAL GN$                  N\",\n      \\\"SAL GNS$                 NS\",\n      \\\"SAL GNED$                N\",\n      \\\"SAL GH(AEIOUY)-          K\",\n      \\\"SAL GH                   _\",\n      \\\"SAL GG9                  K\",\n      \\\"SAL G                    K\",\n      \\\"SAL H                    H\",\n      \\\"SAL IH(AEIOUY)-^         *H\",\n      \\\"SAL IR(AEIOUY)-^         *R\",\n      \\\"SAL I(HR)^               *\",\n      \\\"SAL I^                   *\",\n      \\\"SAL ING6                 N\",\n      \\\"SAL IH(AEIOUY)-          H\",\n      \\\"SAL IR(AEIOUY)-          R\",\n      \\\"SAL I(HR)                _\",\n      \\\"SAL J                    K\",\n      \\\"SAL KN^                  N\",\n      \\\"SAL KK-                  _\",\n      \\\"SAL K                    K\",\n      \\\"SAL LAUGH^               LF\",\n      \\\"SAL LL-                  _\",\n      \\\"SAL L                    L\",\n      \\\"SAL MB$                  M\",\n      \\\"SAL MM                   M\",\n      \\\"SAL M                    M\",\n      \\\"SAL NN-                  _\",\n      \\\"SAL N                    N\",\n      \\\"SAL OH(AEIOUY)-^         *H\",\n      \\\"SAL OR(AEIOUY)-^         *R\",\n      \\\"SAL O(HR)^               *\",\n      \\\"SAL O^                   *\",\n      \\\"SAL OH(AEIOUY)-          H\",\n      \\\"SAL OR(AEIOUY)-          R\",\n      \\\"SAL O(HR)                _\",\n      \\\"SAL PH                   F\",\n      \\\"SAL PN^                  N\",\n      \\\"SAL PP-                  _\",\n      \\\"SAL P                    P\",\n      \\\"SAL Q                    K\",\n      \\\"SAL RH^                  R\",\n      \\\"SAL ROUGH^               RF\",\n      \\\"SAL RR-                  _\",\n      \\\"SAL R                    R\",\n      \\\"SAL SCH(EOU)-            SK\",\n      \\\"SAL SC(IEY)-             S\",\n      \\\"SAL SH                   X\",\n      \\\"SAL SI(AO)-              X\",\n      \\\"SAL SS-                  _\",\n      \\\"SAL S                    S\",\n      \\\"SAL TI(AO)-              X\",\n      \\\"SAL TH                   @\",\n      \\\"SAL TCH--                _\",\n      \\\"SAL TOUGH^               TF\",\n      \\\"SAL TT-                  _\",\n      \\\"SAL T                    T\",\n      \\\"SAL UH(AEIOUY)-^         *H\",\n      \\\"SAL UR(AEIOUY)-^         *R\",\n      \\\"SAL U(HR)^               *\",\n      \\\"SAL U^                   *\",\n      \\\"SAL UH(AEIOUY)-          H\",\n      \\\"SAL UR(AEIOUY)-          R\",\n      \\\"SAL U(HR)                _\",\n      \\\"SAL V^                   W\",\n      \\\"SAL V                    F\",\n      \\\"SAL WR^                  R\",\n      \\\"SAL WH^                  W\",\n      \\\"SAL W(AEIOU)-            W\",\n      \\\"SAL X^                   S\",\n      \\\"SAL X                    KS\",\n      \\\"SAL Y(AEIOU)-            Y\",\n      \\\"SAL ZZ-                  _\",\n      \\\"SAL Z                    S\",\n      \\ ]\n\n\" vim: shiftwidth=2 sts=2 expandtab\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 8.2 and 9.0 can be found with \":help version9\".\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion == NULL)\n    {\n#ifdef BUILD_DATE\n\tchar *date_time = BUILD_DATE;\n#else\n\tchar *date_time = __DATE__ \" \" __TIME__;\n#endif\n\tchar *msg = _(\"%s (%s, compiled %s)\");\n\tsize_t len = strlen(msg)\n\t\t    + strlen(VIM_VERSION_LONG_ONLY)\n\t\t    + strlen(VIM_VERSION_DATE_ONLY)\n\t\t    + strlen(date_time);\n\n\tlongVersion = alloc(len);\n\tif (longVersion == NULL)\n\t    longVersion = VIM_VERSION_LONG;\n\telse\n\t    vim_snprintf(longVersion, len, msg,\n\t\t      VIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n    }\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n\t\"++builtin_terms\",\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n\t\"+cindent\",\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n\t\"+cmdline_info\",\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n\t\"-ebcdic\",\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n\t\"+file_in_path\",\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n\t\"+float\",\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n\t\"-footer\",\n\t// only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n\t\"+jumplist\",\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n\t\"+lispindent\",\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n#  ifdef DYNAMIC_GPM\n\t\"+mouse_gpm/dyn\",\n#  else\n\t\"+mouse_gpm\",\n#  endif\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n\t\"+path_extra\",\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n\t\"+smartindent\",\n#ifdef FEAT_SODIUM\n# ifdef DYNAMIC_SODIUM\n\t\"+sodium/dyn\",\n# else\n\t\"+sodium\",\n# endif\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n\t\"+tag_binary\",\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n\t\"+textobjects\",\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n\t\"+title\",\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+vim9script\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n\t\"+wildignore\",\n\t\"+wildmenu\",\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#if defined(MSWIN)\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#elif defined(HAVE_XPM)\n\t\"+xpm\",\n#else\n\t\"-xpm\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# if defined(USE_XSMP_INTERACT)\n\t\"+xsmp_interact\",\n# elif defined(USE_XSMP)\n\t\"+xsmp\",\n# else\n\t\"-xsmp\",\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    881,\n/**/\n    880,\n/**/\n    879,\n/**/\n    878,\n/**/\n    877,\n/**/\n    876,\n/**/\n    875,\n/**/\n    874,\n/**/\n    873,\n/**/\n    872,\n/**/\n    871,\n/**/\n    870,\n/**/\n    869,\n/**/\n    868,\n/**/\n    867,\n/**/\n    866,\n/**/\n    865,\n/**/\n    864,\n/**/\n    863,\n/**/\n    862,\n/**/\n    861,\n/**/\n    860,\n/**/\n    859,\n/**/\n    858,\n/**/\n    857,\n/**/\n    856,\n/**/\n    855,\n/**/\n    854,\n/**/\n    853,\n/**/\n    852,\n/**/\n    851,\n/**/\n    850,\n/**/\n    849,\n/**/\n    848,\n/**/\n    847,\n/**/\n    846,\n/**/\n    845,\n/**/\n    844,\n/**/\n    843,\n/**/\n    842,\n/**/\n    841,\n/**/\n    840,\n/**/\n    839,\n/**/\n    838,\n/**/\n    837,\n/**/\n    836,\n/**/\n    835,\n/**/\n    834,\n/**/\n    833,\n/**/\n    832,\n/**/\n    831,\n/**/\n    830,\n/**/\n    829,\n/**/\n    828,\n/**/\n    827,\n/**/\n    826,\n/**/\n    825,\n/**/\n    824,\n/**/\n    823,\n/**/\n    822,\n/**/\n    821,\n/**/\n    820,\n/**/\n    819,\n/**/\n    818,\n/**/\n    817,\n/**/\n    816,\n/**/\n    815,\n/**/\n    814,\n/**/\n    813,\n/**/\n    812,\n/**/\n    811,\n/**/\n    810,\n/**/\n    809,\n/**/\n    808,\n/**/\n    807,\n/**/\n    806,\n/**/\n    805,\n/**/\n    804,\n/**/\n    803,\n/**/\n    802,\n/**/\n    801,\n/**/\n    800,\n/**/\n    799,\n/**/\n    798,\n/**/\n    797,\n/**/\n    796,\n/**/\n    795,\n/**/\n    794,\n/**/\n    793,\n/**/\n    792,\n/**/\n    791,\n/**/\n    790,\n/**/\n    789,\n/**/\n    788,\n/**/\n    787,\n/**/\n    786,\n/**/\n    785,\n/**/\n    784,\n/**/\n    783,\n/**/\n    782,\n/**/\n    781,\n/**/\n    780,\n/**/\n    779,\n/**/\n    778,\n/**/\n    777,\n/**/\n    776,\n/**/\n    775,\n/**/\n    774,\n/**/\n    773,\n/**/\n    772,\n/**/\n    771,\n/**/\n    770,\n/**/\n    769,\n/**/\n    768,\n/**/\n    767,\n/**/\n    766,\n/**/\n    765,\n/**/\n    764,\n/**/\n    763,\n/**/\n    762,\n/**/\n    761,\n/**/\n    760,\n/**/\n    759,\n/**/\n    758,\n/**/\n    757,\n/**/\n    756,\n/**/\n    755,\n/**/\n    754,\n/**/\n    753,\n/**/\n    752,\n/**/\n    751,\n/**/\n    750,\n/**/\n    749,\n/**/\n    748,\n/**/\n    747,\n/**/\n    746,\n/**/\n    745,\n/**/\n    744,\n/**/\n    743,\n/**/\n    742,\n/**/\n    741,\n/**/\n    740,\n/**/\n    739,\n/**/\n    738,\n/**/\n    737,\n/**/\n    736,\n/**/\n    735,\n/**/\n    734,\n/**/\n    733,\n/**/\n    732,\n/**/\n    731,\n/**/\n    730,\n/**/\n    729,\n/**/\n    728,\n/**/\n    727,\n/**/\n    726,\n/**/\n    725,\n/**/\n    724,\n/**/\n    723,\n/**/\n    722,\n/**/\n    721,\n/**/\n    720,\n/**/\n    719,\n/**/\n    718,\n/**/\n    717,\n/**/\n    716,\n/**/\n    715,\n/**/\n    714,\n/**/\n    713,\n/**/\n    712,\n/**/\n    711,\n/**/\n    710,\n/**/\n    709,\n/**/\n    708,\n/**/\n    707,\n/**/\n    706,\n/**/\n    705,\n/**/\n    704,\n/**/\n    703,\n/**/\n    702,\n/**/\n    701,\n/**/\n    700,\n/**/\n    699,\n/**/\n    698,\n/**/\n    697,\n/**/\n    696,\n/**/\n    695,\n/**/\n    694,\n/**/\n    693,\n/**/\n    692,\n/**/\n    691,\n/**/\n    690,\n/**/\n    689,\n/**/\n    688,\n/**/\n    687,\n/**/\n    686,\n/**/\n    685,\n/**/\n    684,\n/**/\n    683,\n/**/\n    682,\n/**/\n    681,\n/**/\n    680,\n/**/\n    679,\n/**/\n    678,\n/**/\n    677,\n/**/\n    676,\n/**/\n    675,\n/**/\n    674,\n/**/\n    673,\n/**/\n    672,\n/**/\n    671,\n/**/\n    670,\n/**/\n    669,\n/**/\n    668,\n/**/\n    667,\n/**/\n    666,\n/**/\n    665,\n/**/\n    664,\n/**/\n    663,\n/**/\n    662,\n/**/\n    661,\n/**/\n    660,\n/**/\n    659,\n/**/\n    658,\n/**/\n    657,\n/**/\n    656,\n/**/\n    655,\n/**/\n    654,\n/**/\n    653,\n/**/\n    652,\n/**/\n    651,\n/**/\n    650,\n/**/\n    649,\n/**/\n    648,\n/**/\n    647,\n/**/\n    646,\n/**/\n    645,\n/**/\n    644,\n/**/\n    643,\n/**/\n    642,\n/**/\n    641,\n/**/\n    640,\n/**/\n    639,\n/**/\n    638,\n/**/\n    637,\n/**/\n    636,\n/**/\n    635,\n/**/\n    634,\n/**/\n    633,\n/**/\n    632,\n/**/\n    631,\n/**/\n    630,\n/**/\n    629,\n/**/\n    628,\n/**/\n    627,\n/**/\n    626,\n/**/\n    625,\n/**/\n    624,\n/**/\n    623,\n/**/\n    622,\n/**/\n    621,\n/**/\n    620,\n/**/\n    619,\n/**/\n    618,\n/**/\n    617,\n/**/\n    616,\n/**/\n    615,\n/**/\n    614,\n/**/\n    613,\n/**/\n    612,\n/**/\n    611,\n/**/\n    610,\n/**/\n    609,\n/**/\n    608,\n/**/\n    607,\n/**/\n    606,\n/**/\n    605,\n/**/\n    604,\n/**/\n    603,\n/**/\n    602,\n/**/\n    601,\n/**/\n    600,\n/**/\n    599,\n/**/\n    598,\n/**/\n    597,\n/**/\n    596,\n/**/\n    595,\n/**/\n    594,\n/**/\n    593,\n/**/\n    592,\n/**/\n    591,\n/**/\n    590,\n/**/\n    589,\n/**/\n    588,\n/**/\n    587,\n/**/\n    586,\n/**/\n    585,\n/**/\n    584,\n/**/\n    583,\n/**/\n    582,\n/**/\n    581,\n/**/\n    580,\n/**/\n    579,\n/**/\n    578,\n/**/\n    577,\n/**/\n    576,\n/**/\n    575,\n/**/\n    574,\n/**/\n    573,\n/**/\n    572,\n/**/\n    571,\n/**/\n    570,\n/**/\n    569,\n/**/\n    568,\n/**/\n    567,\n/**/\n    566,\n/**/\n    565,\n/**/\n    564,\n/**/\n    563,\n/**/\n    562,\n/**/\n    561,\n/**/\n    560,\n/**/\n    559,\n/**/\n    558,\n/**/\n    557,\n/**/\n    556,\n/**/\n    555,\n/**/\n    554,\n/**/\n    553,\n/**/\n    552,\n/**/\n    551,\n/**/\n    550,\n/**/\n    549,\n/**/\n    548,\n/**/\n    547,\n/**/\n    546,\n/**/\n    545,\n/**/\n    544,\n/**/\n    543,\n/**/\n    542,\n/**/\n    541,\n/**/\n    540,\n/**/\n    539,\n/**/\n    538,\n/**/\n    537,\n/**/\n    536,\n/**/\n    535,\n/**/\n    534,\n/**/\n    533,\n/**/\n    532,\n/**/\n    531,\n/**/\n    530,\n/**/\n    529,\n/**/\n    528,\n/**/\n    527,\n/**/\n    526,\n/**/\n    525,\n/**/\n    524,\n/**/\n    523,\n/**/\n    522,\n/**/\n    521,\n/**/\n    520,\n/**/\n    519,\n/**/\n    518,\n/**/\n    517,\n/**/\n    516,\n/**/\n    515,\n/**/\n    514,\n/**/\n    513,\n/**/\n    512,\n/**/\n    511,\n/**/\n    510,\n/**/\n    509,\n/**/\n    508,\n/**/\n    507,\n/**/\n    506,\n/**/\n    505,\n/**/\n    504,\n/**/\n    503,\n/**/\n    502,\n/**/\n    501,\n/**/\n    500,\n/**/\n    499,\n/**/\n    498,\n/**/\n    497,\n/**/\n    496,\n/**/\n    495,\n/**/\n    494,\n/**/\n    493,\n/**/\n    492,\n/**/\n    491,\n/**/\n    490,\n/**/\n    489,\n/**/\n    488,\n/**/\n    487,\n/**/\n    486,\n/**/\n    485,\n/**/\n    484,\n/**/\n    483,\n/**/\n    482,\n/**/\n    481,\n/**/\n    480,\n/**/\n    479,\n/**/\n    478,\n/**/\n    477,\n/**/\n    476,\n/**/\n    475,\n/**/\n    474,\n/**/\n    473,\n/**/\n    472,\n/**/\n    471,\n/**/\n    470,\n/**/\n    469,\n/**/\n    468,\n/**/\n    467,\n/**/\n    466,\n/**/\n    465,\n/**/\n    464,\n/**/\n    463,\n/**/\n    462,\n/**/\n    461,\n/**/\n    460,\n/**/\n    459,\n/**/\n    458,\n/**/\n    457,\n/**/\n    456,\n/**/\n    455,\n/**/\n    454,\n/**/\n    453,\n/**/\n    452,\n/**/\n    451,\n/**/\n    450,\n/**/\n    449,\n/**/\n    448,\n/**/\n    447,\n/**/\n    446,\n/**/\n    445,\n/**/\n    444,\n/**/\n    443,\n/**/\n    442,\n/**/\n    441,\n/**/\n    440,\n/**/\n    439,\n/**/\n    438,\n/**/\n    437,\n/**/\n    436,\n/**/\n    435,\n/**/\n    434,\n/**/\n    433,\n/**/\n    432,\n/**/\n    431,\n/**/\n    430,\n/**/\n    429,\n/**/\n    428,\n/**/\n    427,\n/**/\n    426,\n/**/\n    425,\n/**/\n    424,\n/**/\n    423,\n/**/\n    422,\n/**/\n    421,\n/**/\n    420,\n/**/\n    419,\n/**/\n    418,\n/**/\n    417,\n/**/\n    416,\n/**/\n    415,\n/**/\n    414,\n/**/\n    413,\n/**/\n    412,\n/**/\n    411,\n/**/\n    410,\n/**/\n    409,\n/**/\n    408,\n/**/\n    407,\n/**/\n    406,\n/**/\n    405,\n/**/\n    404,\n/**/\n    403,\n/**/\n    402,\n/**/\n    401,\n/**/\n    400,\n/**/\n    399,\n/**/\n    398,\n/**/\n    397,\n/**/\n    396,\n/**/\n    395,\n/**/\n    394,\n/**/\n    393,\n/**/\n    392,\n/**/\n    391,\n/**/\n    390,\n/**/\n    389,\n/**/\n    388,\n/**/\n    387,\n/**/\n    386,\n/**/\n    385,\n/**/\n    384,\n/**/\n    383,\n/**/\n    382,\n/**/\n    381,\n/**/\n    380,\n/**/\n    379,\n/**/\n    378,\n/**/\n    377,\n/**/\n    376,\n/**/\n    375,\n/**/\n    374,\n/**/\n    373,\n/**/\n    372,\n/**/\n    371,\n/**/\n    370,\n/**/\n    369,\n/**/\n    368,\n/**/\n    367,\n/**/\n    366,\n/**/\n    365,\n/**/\n    364,\n/**/\n    363,\n/**/\n    362,\n/**/\n    361,\n/**/\n    360,\n/**/\n    359,\n/**/\n    358,\n/**/\n    357,\n/**/\n    356,\n/**/\n    355,\n/**/\n    354,\n/**/\n    353,\n/**/\n    352,\n/**/\n    351,\n/**/\n    350,\n/**/\n    349,\n/**/\n    348,\n/**/\n    347,\n/**/\n    346,\n/**/\n    345,\n/**/\n    344,\n/**/\n    343,\n/**/\n    342,\n/**/\n    341,\n/**/\n    340,\n/**/\n    339,\n/**/\n    338,\n/**/\n    337,\n/**/\n    336,\n/**/\n    335,\n/**/\n    334,\n/**/\n    333,\n/**/\n    332,\n/**/\n    331,\n/**/\n    330,\n/**/\n    329,\n/**/\n    328,\n/**/\n    327,\n/**/\n    326,\n/**/\n    325,\n/**/\n    324,\n/**/\n    323,\n/**/\n    322,\n/**/\n    321,\n/**/\n    320,\n/**/\n    319,\n/**/\n    318,\n/**/\n    317,\n/**/\n    316,\n/**/\n    315,\n/**/\n    314,\n/**/\n    313,\n/**/\n    312,\n/**/\n    311,\n/**/\n    310,\n/**/\n    309,\n/**/\n    308,\n/**/\n    307,\n/**/\n    306,\n/**/\n    305,\n/**/\n    304,\n/**/\n    303,\n/**/\n    302,\n/**/\n    301,\n/**/\n    300,\n/**/\n    299,\n/**/\n    298,\n/**/\n    297,\n/**/\n    296,\n/**/\n    295,\n/**/\n    294,\n/**/\n    293,\n/**/\n    292,\n/**/\n    291,\n/**/\n    290,\n/**/\n    289,\n/**/\n    288,\n/**/\n    287,\n/**/\n    286,\n/**/\n    285,\n/**/\n    284,\n/**/\n    283,\n/**/\n    282,\n/**/\n    281,\n/**/\n    280,\n/**/\n    279,\n/**/\n    278,\n/**/\n    277,\n/**/\n    276,\n/**/\n    275,\n/**/\n    274,\n/**/\n    273,\n/**/\n    272,\n/**/\n    271,\n/**/\n    270,\n/**/\n    269,\n/**/\n    268,\n/**/\n    267,\n/**/\n    266,\n/**/\n    265,\n/**/\n    264,\n/**/\n    263,\n/**/\n    262,\n/**/\n    261,\n/**/\n    260,\n/**/\n    259,\n/**/\n    258,\n/**/\n    257,\n/**/\n    256,\n/**/\n    255,\n/**/\n    254,\n/**/\n    253,\n/**/\n    252,\n/**/\n    251,\n/**/\n    250,\n/**/\n    249,\n/**/\n    248,\n/**/\n    247,\n/**/\n    246,\n/**/\n    245,\n/**/\n    244,\n/**/\n    243,\n/**/\n    242,\n/**/\n    241,\n/**/\n    240,\n/**/\n    239,\n/**/\n    238,\n/**/\n    237,\n/**/\n    236,\n/**/\n    235,\n/**/\n    234,\n/**/\n    233,\n/**/\n    232,\n/**/\n    231,\n/**/\n    230,\n/**/\n    229,\n/**/\n    228,\n/**/\n    227,\n/**/\n    226,\n/**/\n    225,\n/**/\n    224,\n/**/\n    223,\n/**/\n    222,\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    for (;;)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (l == h)\n\t    break;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + ((item_count % ncol) ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#if defined(FEAT_HUGE)\n    msg_puts(_(\"\\nHuge version \"));\n#elif defined(FEAT_NORMAL)\n    msg_puts(_(\"\\nNormal version \"));\n#else\n    msg_puts(_(\"\\nTiny version \"));\n#endif\n#if !defined(FEAT_GUI)\n    msg_puts(_(\"without GUI.\"));\n#elif defined(FEAT_GUI_GTK)\n# if defined(USE_GTK3)\n    msg_puts(_(\"with GTK3 GUI.\"));\n# elif defined(FEAT_GUI_GNOME)\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n# else\n     msg_puts(_(\"with GTK2 GUI.\"));\n# endif\n#elif defined(FEAT_GUI_MOTIF)\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#elif defined(FEAT_GUI_HAIKU)\n    msg_puts(_(\"with Haiku GUI.\"));\n#elif defined(FEAT_GUI_PHOTON)\n    msg_puts(_(\"with Photon GUI.\"));\n#elif defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version9<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n"], "fixing_code": ["/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * spell.c: code for spell checking\n *\n * See spellfile.c for the Vim spell file format.\n *\n * The spell checking mechanism uses a tree (aka trie).  Each node in the tree\n * has a list of bytes that can appear (siblings).  For each byte there is a\n * pointer to the node with the byte that follows in the word (child).\n *\n * A NUL byte is used where the word may end.  The bytes are sorted, so that\n * binary searching can be used and the NUL bytes are at the start.  The\n * number of possible bytes is stored before the list of bytes.\n *\n * The tree uses two arrays: \"byts\" stores the characters, \"idxs\" stores\n * either the next index or flags.  The tree starts at index 0.  For example,\n * to lookup \"vi\" this sequence is followed:\n *\ti = 0\n *\tlen = byts[i]\n *\tn = where \"v\" appears in byts[i + 1] to byts[i + len]\n *\ti = idxs[n]\n *\tlen = byts[i]\n *\tn = where \"i\" appears in byts[i + 1] to byts[i + len]\n *\ti = idxs[n]\n *\tlen = byts[i]\n *\tfind that byts[i + 1] is 0, idxs[i + 1] has flags for \"vi\".\n *\n * There are two word trees: one with case-folded words and one with words in\n * original case.  The second one is only used for keep-case words and is\n * usually small.\n *\n * There is one additional tree for when not all prefixes are applied when\n * generating the .spl file.  This tree stores all the possible prefixes, as\n * if they were words.  At each word (prefix) end the prefix nr is stored, the\n * following word must support this prefix nr.  And the condition nr is\n * stored, used to lookup the condition that the word must match with.\n *\n * Thanks to Olaf Seibert for providing an example implementation of this tree\n * and the compression mechanism.\n * LZ trie ideas:\n *\thttp://www.irb.hr/hr/home/ristov/papers/RistovLZtrieRevision1.pdf\n * More papers: http://www-igm.univ-mlv.fr/~laporte/publi_en.html\n *\n * Matching involves checking the caps type: Onecap ALLCAP KeepCap.\n *\n * Why doesn't Vim use aspell/ispell/myspell/etc.?\n * See \":help develop-spell\".\n */\n\n#define IN_SPELL_C\n#include \"vim.h\"\n\n#if defined(FEAT_SPELL) || defined(PROTO)\n\n#ifndef UNIX\t\t// it's in os_unix.h for Unix\n# include <time.h>\t// for time_t\n#endif\n\n#define REGION_ALL 0xff\t\t// word valid in all regions\n\n// Result values.  Lower number is accepted over higher one.\n#define SP_BANNED\t(-1)\n#define SP_OK\t\t0\n#define SP_RARE\t\t1\n#define SP_LOCAL\t2\n#define SP_BAD\t\t3\n\n/*\n * Structure to store info for word matching.\n */\ntypedef struct matchinf_S\n{\n    langp_T\t*mi_lp;\t\t\t// info for language and region\n\n    // pointers to original text to be checked\n    char_u\t*mi_word;\t\t// start of word being checked\n    char_u\t*mi_end;\t\t// end of matching word so far\n    char_u\t*mi_fend;\t\t// next char to be added to mi_fword\n    char_u\t*mi_cend;\t\t// char after what was used for\n\t\t\t\t\t// mi_capflags\n\n    // case-folded text\n    char_u\tmi_fword[MAXWLEN + 1];\t// mi_word case-folded\n    int\t\tmi_fwordlen;\t\t// nr of valid bytes in mi_fword\n\n    // for when checking word after a prefix\n    int\t\tmi_prefarridx;\t\t// index in sl_pidxs with list of\n\t\t\t\t\t// affixID/condition\n    int\t\tmi_prefcnt;\t\t// number of entries at mi_prefarridx\n    int\t\tmi_prefixlen;\t\t// byte length of prefix\n    int\t\tmi_cprefixlen;\t\t// byte length of prefix in original\n\t\t\t\t\t// case\n\n    // for when checking a compound word\n    int\t\tmi_compoff;\t\t// start of following word offset\n    char_u\tmi_compflags[MAXWLEN];\t// flags for compound words used\n    int\t\tmi_complen;\t\t// nr of compound words used\n    int\t\tmi_compextra;\t\t// nr of COMPOUNDROOT words\n\n    // others\n    int\t\tmi_result;\t\t// result so far: SP_BAD, SP_OK, etc.\n    int\t\tmi_capflags;\t\t// WF_ONECAP WF_ALLCAP WF_KEEPCAP\n    win_T\t*mi_win;\t\t// buffer being checked\n\n    // for NOBREAK\n    int\t\tmi_result2;\t\t// \"mi_result\" without following word\n    char_u\t*mi_end2;\t\t// \"mi_end\" without following word\n} matchinf_T;\n\n\nstatic int spell_mb_isword_class(int cl, win_T *wp);\n\n// mode values for find_word\n#define FIND_FOLDWORD\t    0\t// find word case-folded\n#define FIND_KEEPWORD\t    1\t// find keep-case word\n#define FIND_PREFIX\t    2\t// find word after prefix\n#define FIND_COMPOUND\t    3\t// find case-folded compound word\n#define FIND_KEEPCOMPOUND   4\t// find keep-case compound word\n\nstatic void find_word(matchinf_T *mip, int mode);\nstatic void find_prefix(matchinf_T *mip, int mode);\nstatic int fold_more(matchinf_T *mip);\nstatic void spell_load_cb(char_u *fname, void *cookie);\nstatic int count_syllables(slang_T *slang, char_u *word);\nstatic void clear_midword(win_T *buf);\nstatic void use_midword(slang_T *lp, win_T *buf);\nstatic int find_region(char_u *rp, char_u *region);\nstatic void spell_soundfold_sofo(slang_T *slang, char_u *inword, char_u *res);\nstatic void spell_soundfold_sal(slang_T *slang, char_u *inword, char_u *res);\nstatic void spell_soundfold_wsal(slang_T *slang, char_u *inword, char_u *res);\nstatic void dump_word(slang_T *slang, char_u *word, char_u *pat, int *dir, int round, int flags, linenr_T lnum);\nstatic linenr_T dump_prefixes(slang_T *slang, char_u *word, char_u *pat, int *dir, int round, int flags, linenr_T startlnum);\n\n/*\n * Main spell-checking function.\n * \"ptr\" points to a character that could be the start of a word.\n * \"*attrp\" is set to the highlight index for a badly spelled word.  For a\n * non-word or when it's OK it remains unchanged.\n * This must only be called when 'spelllang' is not empty.\n *\n * \"capcol\" is used to check for a Capitalised word after the end of a\n * sentence.  If it's zero then perform the check.  Return the column where to\n * check next, or -1 when no sentence end was found.  If it's NULL then don't\n * worry.\n *\n * Returns the length of the word in bytes, also when it's OK, so that the\n * caller can skip over the word.\n */\n    int\nspell_check(\n    win_T\t*wp,\t\t// current window\n    char_u\t*ptr,\n    hlf_T\t*attrp,\n    int\t\t*capcol,\t// column to check for Capital\n    int\t\tdocount)\t// count good words\n{\n    matchinf_T\tmi;\t\t// Most things are put in \"mi\" so that it can\n\t\t\t\t// be passed to functions quickly.\n    int\t\tnrlen = 0;\t// found a number first\n    int\t\tc;\n    int\t\twrongcaplen = 0;\n    int\t\tlpi;\n    int\t\tcount_word = docount;\n    int\t\tuse_camel_case = *wp->w_s->b_p_spo != NUL;\n    int\t\tcamel_case = 0;\n\n    // A word never starts at a space or a control character.  Return quickly\n    // then, skipping over the character.\n    if (*ptr <= ' ')\n\treturn 1;\n\n    // Return here when loading language files failed.\n    if (wp->w_s->b_langp.ga_len == 0)\n\treturn 1;\n\n    CLEAR_FIELD(mi);\n\n    // A number is always OK.  Also skip hexadecimal numbers 0xFF99 and\n    // 0X99FF.  But always do check spelling to find \"3GPP\" and \"11\n    // julifeest\".\n    if (*ptr >= '0' && *ptr <= '9')\n    {\n\tif (*ptr == '0' && (ptr[1] == 'b' || ptr[1] == 'B'))\n\t    mi.mi_end = skipbin(ptr + 2);\n\telse if (*ptr == '0' && (ptr[1] == 'x' || ptr[1] == 'X'))\n\t    mi.mi_end = skiphex(ptr + 2);\n\telse\n\t    mi.mi_end = skipdigits(ptr);\n\tnrlen = (int)(mi.mi_end - ptr);\n    }\n\n    // Find the normal end of the word (until the next non-word character).\n    mi.mi_word = ptr;\n    mi.mi_fend = ptr;\n    if (spell_iswordp(mi.mi_fend, wp))\n    {\n\tint prev_upper;\n\tint this_upper = FALSE;  // init for gcc\n\n\tif (use_camel_case)\n\t{\n\t    c = PTR2CHAR(mi.mi_fend);\n\t    this_upper = SPELL_ISUPPER(c);\n\t}\n\n\tdo\n\t{\n\t    MB_PTR_ADV(mi.mi_fend);\n\t    if (use_camel_case)\n\t    {\n\t\tprev_upper = this_upper;\n\t\tc = PTR2CHAR(mi.mi_fend);\n\t\tthis_upper = SPELL_ISUPPER(c);\n\t\tcamel_case = !prev_upper && this_upper;\n\t    }\n\t} while (*mi.mi_fend != NUL && spell_iswordp(mi.mi_fend, wp)\n\t\t\t\t\t\t\t       && !camel_case);\n\n\tif (capcol != NULL && *capcol == 0 && wp->w_s->b_cap_prog != NULL)\n\t{\n\t    // Check word starting with capital letter.\n\t    c = PTR2CHAR(ptr);\n\t    if (!SPELL_ISUPPER(c))\n\t\twrongcaplen = (int)(mi.mi_fend - ptr);\n\t}\n    }\n    if (capcol != NULL)\n\t*capcol = -1;\n\n    // We always use the characters up to the next non-word character,\n    // also for bad words.\n    mi.mi_end = mi.mi_fend;\n\n    // Check caps type later.\n    mi.mi_capflags = 0;\n    mi.mi_cend = NULL;\n    mi.mi_win = wp;\n\n    // case-fold the word with one non-word character, so that we can check\n    // for the word end.\n    if (*mi.mi_fend != NUL)\n\tMB_PTR_ADV(mi.mi_fend);\n\n    (void)spell_casefold(wp, ptr, (int)(mi.mi_fend - ptr), mi.mi_fword,\n\t\t\t\t\t\t\t     MAXWLEN + 1);\n    mi.mi_fwordlen = (int)STRLEN(mi.mi_fword);\n\n    if (camel_case && mi.mi_fwordlen > 0)\n\t// Introduce a fake word end space into the folded word.\n\tmi.mi_fword[mi.mi_fwordlen - 1] = ' ';\n\n    // The word is bad unless we recognize it.\n    mi.mi_result = SP_BAD;\n    mi.mi_result2 = SP_BAD;\n\n    /*\n     * Loop over the languages specified in 'spelllang'.\n     * We check them all, because a word may be matched longer in another\n     * language.\n     */\n    for (lpi = 0; lpi < wp->w_s->b_langp.ga_len; ++lpi)\n    {\n\tmi.mi_lp = LANGP_ENTRY(wp->w_s->b_langp, lpi);\n\n\t// If reloading fails the language is still in the list but everything\n\t// has been cleared.\n\tif (mi.mi_lp->lp_slang->sl_fidxs == NULL)\n\t    continue;\n\n\t// Check for a matching word in case-folded words.\n\tfind_word(&mi, FIND_FOLDWORD);\n\n\t// Check for a matching word in keep-case words.\n\tfind_word(&mi, FIND_KEEPWORD);\n\n\t// Check for matching prefixes.\n\tfind_prefix(&mi, FIND_FOLDWORD);\n\n\t// For a NOBREAK language, may want to use a word without a following\n\t// word as a backup.\n\tif (mi.mi_lp->lp_slang->sl_nobreak && mi.mi_result == SP_BAD\n\t\t\t\t\t\t   && mi.mi_result2 != SP_BAD)\n\t{\n\t    mi.mi_result = mi.mi_result2;\n\t    mi.mi_end = mi.mi_end2;\n\t}\n\n\t// Count the word in the first language where it's found to be OK.\n\tif (count_word && mi.mi_result == SP_OK)\n\t{\n\t    count_common_word(mi.mi_lp->lp_slang, ptr,\n\t\t\t\t\t\t   (int)(mi.mi_end - ptr), 1);\n\t    count_word = FALSE;\n\t}\n    }\n\n    if (mi.mi_result != SP_OK)\n    {\n\t// If we found a number skip over it.  Allows for \"42nd\".  Do flag\n\t// rare and local words, e.g., \"3GPP\".\n\tif (nrlen > 0)\n\t{\n\t    if (mi.mi_result == SP_BAD || mi.mi_result == SP_BANNED)\n\t\treturn nrlen;\n\t}\n\n\t// When we are at a non-word character there is no error, just\n\t// skip over the character (try looking for a word after it).\n\telse if (!spell_iswordp_nmw(ptr, wp))\n\t{\n\t    if (capcol != NULL && wp->w_s->b_cap_prog != NULL)\n\t    {\n\t\tregmatch_T\tregmatch;\n\t\tint\t\tr;\n\n\t\t// Check for end of sentence.\n\t\tregmatch.regprog = wp->w_s->b_cap_prog;\n\t\tregmatch.rm_ic = FALSE;\n\t\tr = vim_regexec(&regmatch, ptr, 0);\n\t\twp->w_s->b_cap_prog = regmatch.regprog;\n\t\tif (r)\n\t\t    *capcol = (int)(regmatch.endp[0] - ptr);\n\t    }\n\n\t    if (has_mbyte)\n\t\treturn (*mb_ptr2len)(ptr);\n\t    return 1;\n\t}\n\telse if (mi.mi_end == ptr)\n\t    // Always include at least one character.  Required for when there\n\t    // is a mixup in \"midword\".\n\t    MB_PTR_ADV(mi.mi_end);\n\telse if (mi.mi_result == SP_BAD\n\t\t&& LANGP_ENTRY(wp->w_s->b_langp, 0)->lp_slang->sl_nobreak)\n\t{\n\t    char_u\t*p, *fp;\n\t    int\t\tsave_result = mi.mi_result;\n\n\t    // First language in 'spelllang' is NOBREAK.  Find first position\n\t    // at which any word would be valid.\n\t    mi.mi_lp = LANGP_ENTRY(wp->w_s->b_langp, 0);\n\t    if (mi.mi_lp->lp_slang->sl_fidxs != NULL)\n\t    {\n\t\tp = mi.mi_word;\n\t\tfp = mi.mi_fword;\n\t\tfor (;;)\n\t\t{\n\t\t    MB_PTR_ADV(p);\n\t\t    MB_PTR_ADV(fp);\n\t\t    if (p >= mi.mi_end)\n\t\t\tbreak;\n\t\t    mi.mi_compoff = (int)(fp - mi.mi_fword);\n\t\t    find_word(&mi, FIND_COMPOUND);\n\t\t    if (mi.mi_result != SP_BAD)\n\t\t    {\n\t\t\tmi.mi_end = p;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t\tmi.mi_result = save_result;\n\t    }\n\t}\n\n\tif (mi.mi_result == SP_BAD || mi.mi_result == SP_BANNED)\n\t    *attrp = HLF_SPB;\n\telse if (mi.mi_result == SP_RARE)\n\t    *attrp = HLF_SPR;\n\telse\n\t    *attrp = HLF_SPL;\n    }\n\n    if (wrongcaplen > 0 && (mi.mi_result == SP_OK || mi.mi_result == SP_RARE))\n    {\n\t// Report SpellCap only when the word isn't badly spelled.\n\t*attrp = HLF_SPC;\n\treturn wrongcaplen;\n    }\n\n    return (int)(mi.mi_end - ptr);\n}\n\n/*\n * Check if the word at \"mip->mi_word\" is in the tree.\n * When \"mode\" is FIND_FOLDWORD check in fold-case word tree.\n * When \"mode\" is FIND_KEEPWORD check in keep-case word tree.\n * When \"mode\" is FIND_PREFIX check for word after prefix in fold-case word\n * tree.\n *\n * For a match mip->mi_result is updated.\n */\n    static void\nfind_word(matchinf_T *mip, int mode)\n{\n    idx_T\tarridx = 0;\n    int\t\tendlen[MAXWLEN];    // length at possible word endings\n    idx_T\tendidx[MAXWLEN];    // possible word endings\n    int\t\tendidxcnt = 0;\n    int\t\tlen;\n    int\t\twlen = 0;\n    int\t\tflen;\n    int\t\tc;\n    char_u\t*ptr;\n    idx_T\tlo, hi, m;\n    char_u\t*s;\n    char_u\t*p;\n    int\t\tres = SP_BAD;\n    slang_T\t*slang = mip->mi_lp->lp_slang;\n    unsigned\tflags;\n    char_u\t*byts;\n    idx_T\t*idxs;\n    int\t\tword_ends;\n    int\t\tprefix_found;\n    int\t\tnobreak_result;\n\n    if (mode == FIND_KEEPWORD || mode == FIND_KEEPCOMPOUND)\n    {\n\t// Check for word with matching case in keep-case tree.\n\tptr = mip->mi_word;\n\tflen = 9999;\t\t    // no case folding, always enough bytes\n\tbyts = slang->sl_kbyts;\n\tidxs = slang->sl_kidxs;\n\n\tif (mode == FIND_KEEPCOMPOUND)\n\t    // Skip over the previously found word(s).\n\t    wlen += mip->mi_compoff;\n    }\n    else\n    {\n\t// Check for case-folded in case-folded tree.\n\tptr = mip->mi_fword;\n\tflen = mip->mi_fwordlen;    // available case-folded bytes\n\tbyts = slang->sl_fbyts;\n\tidxs = slang->sl_fidxs;\n\n\tif (mode == FIND_PREFIX)\n\t{\n\t    // Skip over the prefix.\n\t    wlen = mip->mi_prefixlen;\n\t    flen -= mip->mi_prefixlen;\n\t}\n\telse if (mode == FIND_COMPOUND)\n\t{\n\t    // Skip over the previously found word(s).\n\t    wlen = mip->mi_compoff;\n\t    flen -= mip->mi_compoff;\n\t}\n\n    }\n\n    if (byts == NULL)\n\treturn;\t\t\t// array is empty\n\n    /*\n     * Repeat advancing in the tree until:\n     * - there is a byte that doesn't match,\n     * - we reach the end of the tree,\n     * - or we reach the end of the line.\n     */\n    for (;;)\n    {\n\tif (flen <= 0 && *mip->mi_fend != NUL)\n\t    flen = fold_more(mip);\n\n\tlen = byts[arridx++];\n\n\t// If the first possible byte is a zero the word could end here.\n\t// Remember this index, we first check for the longest word.\n\tif (byts[arridx] == 0)\n\t{\n\t    if (endidxcnt == MAXWLEN)\n\t    {\n\t\t// Must be a corrupted spell file.\n\t\temsg(_(e_format_error_in_spell_file));\n\t\treturn;\n\t    }\n\t    endlen[endidxcnt] = wlen;\n\t    endidx[endidxcnt++] = arridx++;\n\t    --len;\n\n\t    // Skip over the zeros, there can be several flag/region\n\t    // combinations.\n\t    while (len > 0 && byts[arridx] == 0)\n\t    {\n\t\t++arridx;\n\t\t--len;\n\t    }\n\t    if (len == 0)\n\t\tbreak;\t    // no children, word must end here\n\t}\n\n\t// Stop looking at end of the line.\n\tif (ptr[wlen] == NUL)\n\t    break;\n\n\t// Perform a binary search in the list of accepted bytes.\n\tc = ptr[wlen];\n\tif (c == TAB)\t    // <Tab> is handled like <Space>\n\t    c = ' ';\n\tlo = arridx;\n\thi = arridx + len - 1;\n\twhile (lo < hi)\n\t{\n\t    m = (lo + hi) / 2;\n\t    if (byts[m] > c)\n\t\thi = m - 1;\n\t    else if (byts[m] < c)\n\t\tlo = m + 1;\n\t    else\n\t    {\n\t\tlo = hi = m;\n\t\tbreak;\n\t    }\n\t}\n\n\t// Stop if there is no matching byte.\n\tif (hi < lo || byts[lo] != c)\n\t    break;\n\n\t// Continue at the child (if there is one).\n\tarridx = idxs[lo];\n\t++wlen;\n\t--flen;\n\n\t// One space in the good word may stand for several spaces in the\n\t// checked word.\n\tif (c == ' ')\n\t{\n\t    for (;;)\n\t    {\n\t\tif (flen <= 0 && *mip->mi_fend != NUL)\n\t\t    flen = fold_more(mip);\n\t\tif (ptr[wlen] != ' ' && ptr[wlen] != TAB)\n\t\t    break;\n\t\t++wlen;\n\t\t--flen;\n\t    }\n\t}\n    }\n\n    /*\n     * Verify that one of the possible endings is valid.  Try the longest\n     * first.\n     */\n    while (endidxcnt > 0)\n    {\n\t--endidxcnt;\n\tarridx = endidx[endidxcnt];\n\twlen = endlen[endidxcnt];\n\n\tif ((*mb_head_off)(ptr, ptr + wlen) > 0)\n\t    continue;\t    // not at first byte of character\n\tif (spell_iswordp(ptr + wlen, mip->mi_win))\n\t{\n\t    if (slang->sl_compprog == NULL && !slang->sl_nobreak)\n\t\tcontinue;\t    // next char is a word character\n\t    word_ends = FALSE;\n\t}\n\telse\n\t    word_ends = TRUE;\n\t// The prefix flag is before compound flags.  Once a valid prefix flag\n\t// has been found we try compound flags.\n\tprefix_found = FALSE;\n\n\tif (mode != FIND_KEEPWORD && has_mbyte)\n\t{\n\t    // Compute byte length in original word, length may change\n\t    // when folding case.  This can be slow, take a shortcut when the\n\t    // case-folded word is equal to the keep-case word.\n\t    p = mip->mi_word;\n\t    if (STRNCMP(ptr, p, wlen) != 0)\n\t    {\n\t\tfor (s = ptr; s < ptr + wlen; MB_PTR_ADV(s))\n\t\t    MB_PTR_ADV(p);\n\t\twlen = (int)(p - mip->mi_word);\n\t    }\n\t}\n\n\t// Check flags and region.  For FIND_PREFIX check the condition and\n\t// prefix ID.\n\t// Repeat this if there are more flags/region alternatives until there\n\t// is a match.\n\tres = SP_BAD;\n\tfor (len = byts[arridx - 1]; len > 0 && byts[arridx] == 0;\n\t\t\t\t\t\t\t      --len, ++arridx)\n\t{\n\t    flags = idxs[arridx];\n\n\t    // For the fold-case tree check that the case of the checked word\n\t    // matches with what the word in the tree requires.\n\t    // For keep-case tree the case is always right.  For prefixes we\n\t    // don't bother to check.\n\t    if (mode == FIND_FOLDWORD)\n\t    {\n\t\tif (mip->mi_cend != mip->mi_word + wlen)\n\t\t{\n\t\t    // mi_capflags was set for a different word length, need\n\t\t    // to do it again.\n\t\t    mip->mi_cend = mip->mi_word + wlen;\n\t\t    mip->mi_capflags = captype(mip->mi_word, mip->mi_cend);\n\t\t}\n\n\t\tif (mip->mi_capflags == WF_KEEPCAP\n\t\t\t\t|| !spell_valid_case(mip->mi_capflags, flags))\n\t\t    continue;\n\t    }\n\n\t    // When mode is FIND_PREFIX the word must support the prefix:\n\t    // check the prefix ID and the condition.  Do that for the list at\n\t    // mip->mi_prefarridx that find_prefix() filled.\n\t    else if (mode == FIND_PREFIX && !prefix_found)\n\t    {\n\t\tc = valid_word_prefix(mip->mi_prefcnt, mip->mi_prefarridx,\n\t\t\t\t    flags,\n\t\t\t\t    mip->mi_word + mip->mi_cprefixlen, slang,\n\t\t\t\t    FALSE);\n\t\tif (c == 0)\n\t\t    continue;\n\n\t\t// Use the WF_RARE flag for a rare prefix.\n\t\tif (c & WF_RAREPFX)\n\t\t    flags |= WF_RARE;\n\t\tprefix_found = TRUE;\n\t    }\n\n\t    if (slang->sl_nobreak)\n\t    {\n\t\tif ((mode == FIND_COMPOUND || mode == FIND_KEEPCOMPOUND)\n\t\t\t&& (flags & WF_BANNED) == 0)\n\t\t{\n\t\t    // NOBREAK: found a valid following word.  That's all we\n\t\t    // need to know, so return.\n\t\t    mip->mi_result = SP_OK;\n\t\t    break;\n\t\t}\n\t    }\n\n\t    else if ((mode == FIND_COMPOUND || mode == FIND_KEEPCOMPOUND\n\t\t\t\t\t\t\t\t|| !word_ends))\n\t    {\n\t\t// If there is no compound flag or the word is shorter than\n\t\t// COMPOUNDMIN reject it quickly.\n\t\t// Makes you wonder why someone puts a compound flag on a word\n\t\t// that's too short...  Myspell compatibility requires this\n\t\t// anyway.\n\t\tif (((unsigned)flags >> 24) == 0\n\t\t\t     || wlen - mip->mi_compoff < slang->sl_compminlen)\n\t\t    continue;\n\t\t// For multi-byte chars check character length against\n\t\t// COMPOUNDMIN.\n\t\tif (has_mbyte\n\t\t\t&& slang->sl_compminlen > 0\n\t\t\t&& mb_charlen_len(mip->mi_word + mip->mi_compoff,\n\t\t\t\twlen - mip->mi_compoff) < slang->sl_compminlen)\n\t\t\tcontinue;\n\n\t\t// Limit the number of compound words to COMPOUNDWORDMAX if no\n\t\t// maximum for syllables is specified.\n\t\tif (!word_ends && mip->mi_complen + mip->mi_compextra + 2\n\t\t\t\t\t\t\t   > slang->sl_compmax\n\t\t\t\t\t   && slang->sl_compsylmax == MAXWLEN)\n\t\t    continue;\n\n\t\t// Don't allow compounding on a side where an affix was added,\n\t\t// unless COMPOUNDPERMITFLAG was used.\n\t\tif (mip->mi_complen > 0 && (flags & WF_NOCOMPBEF))\n\t\t    continue;\n\t\tif (!word_ends && (flags & WF_NOCOMPAFT))\n\t\t    continue;\n\n\t\t// Quickly check if compounding is possible with this flag.\n\t\tif (!byte_in_str(mip->mi_complen == 0\n\t\t\t\t\t? slang->sl_compstartflags\n\t\t\t\t\t: slang->sl_compallflags,\n\t\t\t\t\t    ((unsigned)flags >> 24)))\n\t\t    continue;\n\n\t\t// If there is a match with a CHECKCOMPOUNDPATTERN rule\n\t\t// discard the compound word.\n\t\tif (match_checkcompoundpattern(ptr, wlen, &slang->sl_comppat))\n\t\t    continue;\n\n\t\tif (mode == FIND_COMPOUND)\n\t\t{\n\t\t    int\t    capflags;\n\n\t\t    // Need to check the caps type of the appended compound\n\t\t    // word.\n\t\t    if (has_mbyte && STRNCMP(ptr, mip->mi_word,\n\t\t\t\t\t\t\tmip->mi_compoff) != 0)\n\t\t    {\n\t\t\t// case folding may have changed the length\n\t\t\tp = mip->mi_word;\n\t\t\tfor (s = ptr; s < ptr + mip->mi_compoff; MB_PTR_ADV(s))\n\t\t\t    MB_PTR_ADV(p);\n\t\t    }\n\t\t    else\n\t\t\tp = mip->mi_word + mip->mi_compoff;\n\t\t    capflags = captype(p, mip->mi_word + wlen);\n\t\t    if (capflags == WF_KEEPCAP || (capflags == WF_ALLCAP\n\t\t\t\t\t\t && (flags & WF_FIXCAP) != 0))\n\t\t\tcontinue;\n\n\t\t    if (capflags != WF_ALLCAP)\n\t\t    {\n\t\t\t// When the character before the word is a word\n\t\t\t// character we do not accept a Onecap word.  We do\n\t\t\t// accept a no-caps word, even when the dictionary\n\t\t\t// word specifies ONECAP.\n\t\t\tMB_PTR_BACK(mip->mi_word, p);\n\t\t\tif (spell_iswordp_nmw(p, mip->mi_win)\n\t\t\t\t? capflags == WF_ONECAP\n\t\t\t\t: (flags & WF_ONECAP) != 0\n\t\t\t\t\t\t     && capflags != WF_ONECAP)\n\t\t\t    continue;\n\t\t    }\n\t\t}\n\n\t\t// If the word ends the sequence of compound flags of the\n\t\t// words must match with one of the COMPOUNDRULE items and\n\t\t// the number of syllables must not be too large.\n\t\tmip->mi_compflags[mip->mi_complen] = ((unsigned)flags >> 24);\n\t\tmip->mi_compflags[mip->mi_complen + 1] = NUL;\n\t\tif (word_ends)\n\t\t{\n\t\t    char_u\tfword[MAXWLEN];\n\n\t\t    if (slang->sl_compsylmax < MAXWLEN)\n\t\t    {\n\t\t\t// \"fword\" is only needed for checking syllables.\n\t\t\tif (ptr == mip->mi_word)\n\t\t\t    (void)spell_casefold(mip->mi_win,\n\t\t\t\t\t\t    ptr, wlen, fword, MAXWLEN);\n\t\t\telse\n\t\t\t    vim_strncpy(fword, ptr, endlen[endidxcnt]);\n\t\t    }\n\t\t    if (!can_compound(slang, fword, mip->mi_compflags))\n\t\t\tcontinue;\n\t\t}\n\t\telse if (slang->sl_comprules != NULL\n\t\t\t     && !match_compoundrule(slang, mip->mi_compflags))\n\t\t    // The compound flags collected so far do not match any\n\t\t    // COMPOUNDRULE, discard the compounded word.\n\t\t    continue;\n\t    }\n\n\t    // Check NEEDCOMPOUND: can't use word without compounding.\n\t    else if (flags & WF_NEEDCOMP)\n\t\tcontinue;\n\n\t    nobreak_result = SP_OK;\n\n\t    if (!word_ends)\n\t    {\n\t\tint\tsave_result = mip->mi_result;\n\t\tchar_u\t*save_end = mip->mi_end;\n\t\tlangp_T\t*save_lp = mip->mi_lp;\n\t\tint\tlpi;\n\n\t\t// Check that a valid word follows.  If there is one and we\n\t\t// are compounding, it will set \"mi_result\", thus we are\n\t\t// always finished here.  For NOBREAK we only check that a\n\t\t// valid word follows.\n\t\t// Recursive!\n\t\tif (slang->sl_nobreak)\n\t\t    mip->mi_result = SP_BAD;\n\n\t\t// Find following word in case-folded tree.\n\t\tmip->mi_compoff = endlen[endidxcnt];\n\t\tif (has_mbyte && mode == FIND_KEEPWORD)\n\t\t{\n\t\t    // Compute byte length in case-folded word from \"wlen\":\n\t\t    // byte length in keep-case word.  Length may change when\n\t\t    // folding case.  This can be slow, take a shortcut when\n\t\t    // the case-folded word is equal to the keep-case word.\n\t\t    p = mip->mi_fword;\n\t\t    if (STRNCMP(ptr, p, wlen) != 0)\n\t\t    {\n\t\t\tfor (s = ptr; s < ptr + wlen; MB_PTR_ADV(s))\n\t\t\t    MB_PTR_ADV(p);\n\t\t\tmip->mi_compoff = (int)(p - mip->mi_fword);\n\t\t    }\n\t\t}\n#if 0 // Disabled, see below\n\t\tc = mip->mi_compoff;\n#endif\n\t\t++mip->mi_complen;\n\t\tif (flags & WF_COMPROOT)\n\t\t    ++mip->mi_compextra;\n\n\t\t// For NOBREAK we need to try all NOBREAK languages, at least\n\t\t// to find the \".add\" file(s).\n\t\tfor (lpi = 0; lpi < mip->mi_win->w_s->b_langp.ga_len; ++lpi)\n\t\t{\n\t\t    if (slang->sl_nobreak)\n\t\t    {\n\t\t\tmip->mi_lp = LANGP_ENTRY(mip->mi_win->w_s->b_langp, lpi);\n\t\t\tif (mip->mi_lp->lp_slang->sl_fidxs == NULL\n\t\t\t\t\t || !mip->mi_lp->lp_slang->sl_nobreak)\n\t\t\t    continue;\n\t\t    }\n\n\t\t    find_word(mip, FIND_COMPOUND);\n\n\t\t    // When NOBREAK any word that matches is OK.  Otherwise we\n\t\t    // need to find the longest match, thus try with keep-case\n\t\t    // and prefix too.\n\t\t    if (!slang->sl_nobreak || mip->mi_result == SP_BAD)\n\t\t    {\n\t\t\t// Find following word in keep-case tree.\n\t\t\tmip->mi_compoff = wlen;\n\t\t\tfind_word(mip, FIND_KEEPCOMPOUND);\n\n#if 0\t    // Disabled, a prefix must not appear halfway a compound word,\n\t    // unless the COMPOUNDPERMITFLAG is used and then it can't be a\n\t    // postponed prefix.\n\t\t\tif (!slang->sl_nobreak || mip->mi_result == SP_BAD)\n\t\t\t{\n\t\t\t    // Check for following word with prefix.\n\t\t\t    mip->mi_compoff = c;\n\t\t\t    find_prefix(mip, FIND_COMPOUND);\n\t\t\t}\n#endif\n\t\t    }\n\n\t\t    if (!slang->sl_nobreak)\n\t\t\tbreak;\n\t\t}\n\t\t--mip->mi_complen;\n\t\tif (flags & WF_COMPROOT)\n\t\t    --mip->mi_compextra;\n\t\tmip->mi_lp = save_lp;\n\n\t\tif (slang->sl_nobreak)\n\t\t{\n\t\t    nobreak_result = mip->mi_result;\n\t\t    mip->mi_result = save_result;\n\t\t    mip->mi_end = save_end;\n\t\t}\n\t\telse\n\t\t{\n\t\t    if (mip->mi_result == SP_OK)\n\t\t\tbreak;\n\t\t    continue;\n\t\t}\n\t    }\n\n\t    if (flags & WF_BANNED)\n\t\tres = SP_BANNED;\n\t    else if (flags & WF_REGION)\n\t    {\n\t\t// Check region.\n\t\tif ((mip->mi_lp->lp_region & (flags >> 16)) != 0)\n\t\t    res = SP_OK;\n\t\telse\n\t\t    res = SP_LOCAL;\n\t    }\n\t    else if (flags & WF_RARE)\n\t\tres = SP_RARE;\n\t    else\n\t\tres = SP_OK;\n\n\t    // Always use the longest match and the best result.  For NOBREAK\n\t    // we separately keep the longest match without a following good\n\t    // word as a fall-back.\n\t    if (nobreak_result == SP_BAD)\n\t    {\n\t\tif (mip->mi_result2 > res)\n\t\t{\n\t\t    mip->mi_result2 = res;\n\t\t    mip->mi_end2 = mip->mi_word + wlen;\n\t\t}\n\t\telse if (mip->mi_result2 == res\n\t\t\t\t\t&& mip->mi_end2 < mip->mi_word + wlen)\n\t\t    mip->mi_end2 = mip->mi_word + wlen;\n\t    }\n\t    else if (mip->mi_result > res)\n\t    {\n\t\tmip->mi_result = res;\n\t\tmip->mi_end = mip->mi_word + wlen;\n\t    }\n\t    else if (mip->mi_result == res && mip->mi_end < mip->mi_word + wlen)\n\t\tmip->mi_end = mip->mi_word + wlen;\n\n\t    if (mip->mi_result == SP_OK)\n\t\tbreak;\n\t}\n\n\tif (mip->mi_result == SP_OK)\n\t    break;\n    }\n}\n\n/*\n * Return TRUE if there is a match between the word ptr[wlen] and\n * CHECKCOMPOUNDPATTERN rules, assuming that we will concatenate with another\n * word.\n * A match means that the first part of CHECKCOMPOUNDPATTERN matches at the\n * end of ptr[wlen] and the second part matches after it.\n */\n    int\nmatch_checkcompoundpattern(\n    char_u\t*ptr,\n    int\t\twlen,\n    garray_T\t*gap)  // &sl_comppat\n{\n    int\t\ti;\n    char_u\t*p;\n    int\t\tlen;\n\n    for (i = 0; i + 1 < gap->ga_len; i += 2)\n    {\n\tp = ((char_u **)gap->ga_data)[i + 1];\n\tif (STRNCMP(ptr + wlen, p, STRLEN(p)) == 0)\n\t{\n\t    // Second part matches at start of following compound word, now\n\t    // check if first part matches at end of previous word.\n\t    p = ((char_u **)gap->ga_data)[i];\n\t    len = (int)STRLEN(p);\n\t    if (len <= wlen && STRNCMP(ptr + wlen - len, p, len) == 0)\n\t\treturn TRUE;\n\t}\n    }\n    return FALSE;\n}\n\n/*\n * Return TRUE if \"flags\" is a valid sequence of compound flags and \"word\"\n * does not have too many syllables.\n */\n    int\ncan_compound(slang_T *slang, char_u *word, char_u *flags)\n{\n    char_u\tuflags[MAXWLEN * 2];\n    int\t\ti;\n    char_u\t*p;\n\n    if (slang->sl_compprog == NULL)\n\treturn FALSE;\n    if (enc_utf8)\n    {\n\t// Need to convert the single byte flags to utf8 characters.\n\tp = uflags;\n\tfor (i = 0; flags[i] != NUL; ++i)\n\t    p += utf_char2bytes(flags[i], p);\n\t*p = NUL;\n\tp = uflags;\n    }\n    else\n\tp = flags;\n    if (!vim_regexec_prog(&slang->sl_compprog, FALSE, p, 0))\n\treturn FALSE;\n\n    // Count the number of syllables.  This may be slow, do it last.  If there\n    // are too many syllables AND the number of compound words is above\n    // COMPOUNDWORDMAX then compounding is not allowed.\n    if (slang->sl_compsylmax < MAXWLEN\n\t\t       && count_syllables(slang, word) > slang->sl_compsylmax)\n\treturn (int)STRLEN(flags) < slang->sl_compmax;\n    return TRUE;\n}\n\n/*\n * Return TRUE if the compound flags in compflags[] match the start of any\n * compound rule.  This is used to stop trying a compound if the flags\n * collected so far can't possibly match any compound rule.\n * Caller must check that slang->sl_comprules is not NULL.\n */\n    int\nmatch_compoundrule(slang_T *slang, char_u *compflags)\n{\n    char_u\t*p;\n    int\t\ti;\n    int\t\tc;\n\n    // loop over all the COMPOUNDRULE entries\n    for (p = slang->sl_comprules; *p != NUL; ++p)\n    {\n\t// loop over the flags in the compound word we have made, match\n\t// them against the current rule entry\n\tfor (i = 0; ; ++i)\n\t{\n\t    c = compflags[i];\n\t    if (c == NUL)\n\t\t// found a rule that matches for the flags we have so far\n\t\treturn TRUE;\n\t    if (*p == '/' || *p == NUL)\n\t\tbreak;  // end of rule, it's too short\n\t    if (*p == '[')\n\t    {\n\t\tint match = FALSE;\n\n\t\t// compare against all the flags in []\n\t\t++p;\n\t\twhile (*p != ']' && *p != NUL)\n\t\t    if (*p++ == c)\n\t\t\tmatch = TRUE;\n\t\tif (!match)\n\t\t    break;  // none matches\n\t    }\n\t    else if (*p != c)\n\t\tbreak;  // flag of word doesn't match flag in pattern\n\t    ++p;\n\t}\n\n\t// Skip to the next \"/\", where the next pattern starts.\n\tp = vim_strchr(p, '/');\n\tif (p == NULL)\n\t    break;\n    }\n\n    // Checked all the rules and none of them match the flags, so there\n    // can't possibly be a compound starting with these flags.\n    return FALSE;\n}\n\n/*\n * Return non-zero if the prefix indicated by \"arridx\" matches with the prefix\n * ID in \"flags\" for the word \"word\".\n * The WF_RAREPFX flag is included in the return value for a rare prefix.\n */\n    int\nvalid_word_prefix(\n    int\t\ttotprefcnt,\t// nr of prefix IDs\n    int\t\tarridx,\t\t// idx in sl_pidxs[]\n    int\t\tflags,\n    char_u\t*word,\n    slang_T\t*slang,\n    int\t\tcond_req)\t// only use prefixes with a condition\n{\n    int\t\tprefcnt;\n    int\t\tpidx;\n    regprog_T\t**rp;\n    int\t\tprefid;\n\n    prefid = (unsigned)flags >> 24;\n    for (prefcnt = totprefcnt - 1; prefcnt >= 0; --prefcnt)\n    {\n\tpidx = slang->sl_pidxs[arridx + prefcnt];\n\n\t// Check the prefix ID.\n\tif (prefid != (pidx & 0xff))\n\t    continue;\n\n\t// Check if the prefix doesn't combine and the word already has a\n\t// suffix.\n\tif ((flags & WF_HAS_AFF) && (pidx & WF_PFX_NC))\n\t    continue;\n\n\t// Check the condition, if there is one.  The condition index is\n\t// stored in the two bytes above the prefix ID byte.\n\trp = &slang->sl_prefprog[((unsigned)pidx >> 8) & 0xffff];\n\tif (*rp != NULL)\n\t{\n\t    if (!vim_regexec_prog(rp, FALSE, word, 0))\n\t\tcontinue;\n\t}\n\telse if (cond_req)\n\t    continue;\n\n\t// It's a match!  Return the WF_ flags.\n\treturn pidx;\n    }\n    return 0;\n}\n\n/*\n * Check if the word at \"mip->mi_word\" has a matching prefix.\n * If it does, then check the following word.\n *\n * If \"mode\" is \"FIND_COMPOUND\" then do the same after another word, find a\n * prefix in a compound word.\n *\n * For a match mip->mi_result is updated.\n */\n    static void\nfind_prefix(matchinf_T *mip, int mode)\n{\n    idx_T\tarridx = 0;\n    int\t\tlen;\n    int\t\twlen = 0;\n    int\t\tflen;\n    int\t\tc;\n    char_u\t*ptr;\n    idx_T\tlo, hi, m;\n    slang_T\t*slang = mip->mi_lp->lp_slang;\n    char_u\t*byts;\n    idx_T\t*idxs;\n\n    byts = slang->sl_pbyts;\n    if (byts == NULL)\n\treturn;\t\t\t// array is empty\n\n    // We use the case-folded word here, since prefixes are always\n    // case-folded.\n    ptr = mip->mi_fword;\n    flen = mip->mi_fwordlen;    // available case-folded bytes\n    if (mode == FIND_COMPOUND)\n    {\n\t// Skip over the previously found word(s).\n\tptr += mip->mi_compoff;\n\tflen -= mip->mi_compoff;\n    }\n    idxs = slang->sl_pidxs;\n\n    /*\n     * Repeat advancing in the tree until:\n     * - there is a byte that doesn't match,\n     * - we reach the end of the tree,\n     * - or we reach the end of the line.\n     */\n    for (;;)\n    {\n\tif (flen == 0 && *mip->mi_fend != NUL)\n\t    flen = fold_more(mip);\n\n\tlen = byts[arridx++];\n\n\t// If the first possible byte is a zero the prefix could end here.\n\t// Check if the following word matches and supports the prefix.\n\tif (byts[arridx] == 0)\n\t{\n\t    // There can be several prefixes with different conditions.  We\n\t    // try them all, since we don't know which one will give the\n\t    // longest match.  The word is the same each time, pass the list\n\t    // of possible prefixes to find_word().\n\t    mip->mi_prefarridx = arridx;\n\t    mip->mi_prefcnt = len;\n\t    while (len > 0 && byts[arridx] == 0)\n\t    {\n\t\t++arridx;\n\t\t--len;\n\t    }\n\t    mip->mi_prefcnt -= len;\n\n\t    // Find the word that comes after the prefix.\n\t    mip->mi_prefixlen = wlen;\n\t    if (mode == FIND_COMPOUND)\n\t\t// Skip over the previously found word(s).\n\t\tmip->mi_prefixlen += mip->mi_compoff;\n\n\t    if (has_mbyte)\n\t    {\n\t\t// Case-folded length may differ from original length.\n\t\tmip->mi_cprefixlen = nofold_len(mip->mi_fword,\n\t\t\t\t\t     mip->mi_prefixlen, mip->mi_word);\n\t    }\n\t    else\n\t\tmip->mi_cprefixlen = mip->mi_prefixlen;\n\t    find_word(mip, FIND_PREFIX);\n\n\n\t    if (len == 0)\n\t\tbreak;\t    // no children, word must end here\n\t}\n\n\t// Stop looking at end of the line.\n\tif (ptr[wlen] == NUL)\n\t    break;\n\n\t// Perform a binary search in the list of accepted bytes.\n\tc = ptr[wlen];\n\tlo = arridx;\n\thi = arridx + len - 1;\n\twhile (lo < hi)\n\t{\n\t    m = (lo + hi) / 2;\n\t    if (byts[m] > c)\n\t\thi = m - 1;\n\t    else if (byts[m] < c)\n\t\tlo = m + 1;\n\t    else\n\t    {\n\t\tlo = hi = m;\n\t\tbreak;\n\t    }\n\t}\n\n\t// Stop if there is no matching byte.\n\tif (hi < lo || byts[lo] != c)\n\t    break;\n\n\t// Continue at the child (if there is one).\n\tarridx = idxs[lo];\n\t++wlen;\n\t--flen;\n    }\n}\n\n/*\n * Need to fold at least one more character.  Do until next non-word character\n * for efficiency.  Include the non-word character too.\n * Return the length of the folded chars in bytes.\n */\n    static int\nfold_more(matchinf_T *mip)\n{\n    int\t\tflen;\n    char_u\t*p;\n\n    p = mip->mi_fend;\n    do\n\tMB_PTR_ADV(mip->mi_fend);\n    while (*mip->mi_fend != NUL && spell_iswordp(mip->mi_fend, mip->mi_win));\n\n    // Include the non-word character so that we can check for the word end.\n    if (*mip->mi_fend != NUL)\n\tMB_PTR_ADV(mip->mi_fend);\n\n    (void)spell_casefold(mip->mi_win, p, (int)(mip->mi_fend - p),\n\t\t\t     mip->mi_fword + mip->mi_fwordlen,\n\t\t\t     MAXWLEN - mip->mi_fwordlen);\n    flen = (int)STRLEN(mip->mi_fword + mip->mi_fwordlen);\n    mip->mi_fwordlen += flen;\n    return flen;\n}\n\n/*\n * Check case flags for a word.  Return TRUE if the word has the requested\n * case.\n */\n    int\nspell_valid_case(\n    int\t    wordflags,\t    // flags for the checked word.\n    int\t    treeflags)\t    // flags for the word in the spell tree\n{\n    return ((wordflags == WF_ALLCAP && (treeflags & WF_FIXCAP) == 0)\n\t    || ((treeflags & (WF_ALLCAP | WF_KEEPCAP)) == 0\n\t\t&& ((treeflags & WF_ONECAP) == 0\n\t\t\t\t\t   || (wordflags & WF_ONECAP) != 0)));\n}\n\n/*\n * Return TRUE if spell checking is enabled for \"wp\".\n */\n    int\nspell_check_window(win_T *wp)\n{\n    return wp->w_p_spell\n\t\t&& *wp->w_s->b_p_spl != NUL\n\t\t&& wp->w_s->b_langp.ga_len > 0\n\t\t&& *(char **)(wp->w_s->b_langp.ga_data) != NULL;\n}\n\n/*\n * Return TRUE and give an error if spell checking is not enabled.\n */\n    static int\nno_spell_checking(win_T *wp)\n{\n    if (spell_check_window(wp))\n\treturn FALSE;\n    emsg(_(e_spell_checking_is_not_possible));\n    return TRUE;\n}\n\n/*\n * Move to next spell error.\n * \"curline\" is FALSE for \"[s\", \"]s\", \"[S\" and \"]S\".\n * \"curline\" is TRUE to find word under/after cursor in the same line.\n * For Insert mode completion \"dir\" is BACKWARD and \"curline\" is TRUE: move\n * to after badly spelled word before the cursor.\n * Return 0 if not found, length of the badly spelled word otherwise.\n */\n    int\nspell_move_to(\n    win_T\t*wp,\n    int\t\tdir,\t\t// FORWARD or BACKWARD\n    int\t\tallwords,\t// TRUE for \"[s\"/\"]s\", FALSE for \"[S\"/\"]S\"\n    int\t\tcurline,\n    hlf_T\t*attrp)\t\t// return: attributes of bad word or NULL\n\t\t\t\t// (only when \"dir\" is FORWARD)\n{\n    linenr_T\tlnum;\n    pos_T\tfound_pos;\n    int\t\tfound_len = 0;\n    char_u\t*line;\n    char_u\t*p;\n    char_u\t*endp;\n    hlf_T\tattr = 0;\n    int\t\tlen;\n#ifdef FEAT_SYN_HL\n    int\t\thas_syntax = syntax_present(wp);\n#endif\n    int\t\tcol;\n    int\t\tcan_spell;\n    char_u\t*buf = NULL;\n    int\t\tbuflen = 0;\n    int\t\tskip = 0;\n    int\t\tcapcol = -1;\n    int\t\tfound_one = FALSE;\n    int\t\twrapped = FALSE;\n\n    if (no_spell_checking(wp))\n\treturn 0;\n\n    /*\n     * Start looking for bad word at the start of the line, because we can't\n     * start halfway a word, we don't know where it starts or ends.\n     *\n     * When searching backwards, we continue in the line to find the last\n     * bad word (in the cursor line: before the cursor).\n     *\n     * We concatenate the start of the next line, so that wrapped words work\n     * (e.g. \"et<line-break>cetera\").  Doesn't work when searching backwards\n     * though...\n     */\n    lnum = wp->w_cursor.lnum;\n    CLEAR_POS(&found_pos);\n\n    while (!got_int)\n    {\n\tint empty_line;\n\n\tline = ml_get_buf(wp->w_buffer, lnum, FALSE);\n\n\tlen = (int)STRLEN(line);\n\tif (buflen < len + MAXWLEN + 2)\n\t{\n\t    vim_free(buf);\n\t    buflen = len + MAXWLEN + 2;\n\t    buf = alloc(buflen);\n\t    if (buf == NULL)\n\t\tbreak;\n\t}\n\n\t// In first line check first word for Capital.\n\tif (lnum == 1)\n\t    capcol = 0;\n\n\t// For checking first word with a capital skip white space.\n\tif (capcol == 0)\n\t    capcol = getwhitecols(line);\n\telse if (curline && wp == curwin)\n\t{\n\t    // For spellbadword(): check if first word needs a capital.\n\t    col = getwhitecols(line);\n\t    if (check_need_cap(lnum, col))\n\t\tcapcol = col;\n\n\t    // Need to get the line again, may have looked at the previous\n\t    // one.\n\t    line = ml_get_buf(wp->w_buffer, lnum, FALSE);\n\t}\n\n\t// Copy the line into \"buf\" and append the start of the next line if\n\t// possible.  Note: this ml_get_buf() may make \"line\" invalid, check\n\t// for empty line first.\n\tempty_line = *skipwhite(line) == NUL;\n\tSTRCPY(buf, line);\n\tif (lnum < wp->w_buffer->b_ml.ml_line_count)\n\t    spell_cat_line(buf + STRLEN(buf),\n\t\t\t  ml_get_buf(wp->w_buffer, lnum + 1, FALSE), MAXWLEN);\n\n\tp = buf + skip;\n\tendp = buf + len;\n\twhile (p < endp)\n\t{\n\t    // When searching backward don't search after the cursor.  Unless\n\t    // we wrapped around the end of the buffer.\n\t    if (dir == BACKWARD\n\t\t    && lnum == wp->w_cursor.lnum\n\t\t    && !wrapped\n\t\t    && (colnr_T)(p - buf) >= wp->w_cursor.col)\n\t\tbreak;\n\n\t    // start of word\n\t    attr = HLF_COUNT;\n\t    len = spell_check(wp, p, &attr, &capcol, FALSE);\n\n\t    if (attr != HLF_COUNT)\n\t    {\n\t\t// We found a bad word.  Check the attribute.\n\t\tif (allwords || attr == HLF_SPB)\n\t\t{\n\t\t    // When searching forward only accept a bad word after\n\t\t    // the cursor.\n\t\t    if (dir == BACKWARD\n\t\t\t    || lnum != wp->w_cursor.lnum\n\t\t\t    || (wrapped\n\t\t\t\t|| (colnr_T)(curline ? p - buf + len\n\t\t\t\t\t\t     : p - buf)\n\t\t\t\t\t\t  > wp->w_cursor.col))\n\t\t    {\n#ifdef FEAT_SYN_HL\n\t\t\tif (has_syntax)\n\t\t\t{\n\t\t\t    col = (int)(p - buf);\n\t\t\t    (void)syn_get_id(wp, lnum, (colnr_T)col,\n\t\t\t\t\t\t    FALSE, &can_spell, FALSE);\n\t\t\t    if (!can_spell)\n\t\t\t\tattr = HLF_COUNT;\n\t\t\t}\n\t\t\telse\n#endif\n\t\t\t    can_spell = TRUE;\n\n\t\t\tif (can_spell)\n\t\t\t{\n\t\t\t    found_one = TRUE;\n\t\t\t    found_pos.lnum = lnum;\n\t\t\t    found_pos.col = (int)(p - buf);\n\t\t\t    found_pos.coladd = 0;\n\t\t\t    if (dir == FORWARD)\n\t\t\t    {\n\t\t\t\t// No need to search further.\n\t\t\t\twp->w_cursor = found_pos;\n\t\t\t\tvim_free(buf);\n\t\t\t\tif (attrp != NULL)\n\t\t\t\t    *attrp = attr;\n\t\t\t\treturn len;\n\t\t\t    }\n\t\t\t    else if (curline)\n\t\t\t\t// Insert mode completion: put cursor after\n\t\t\t\t// the bad word.\n\t\t\t\tfound_pos.col += len;\n\t\t\t    found_len = len;\n\t\t\t}\n\t\t    }\n\t\t    else\n\t\t\tfound_one = TRUE;\n\t\t}\n\t    }\n\n\t    // advance to character after the word\n\t    p += len;\n\t    capcol -= len;\n\t}\n\n\tif (dir == BACKWARD && found_pos.lnum != 0)\n\t{\n\t    // Use the last match in the line (before the cursor).\n\t    wp->w_cursor = found_pos;\n\t    vim_free(buf);\n\t    return found_len;\n\t}\n\n\tif (curline)\n\t    break;\t// only check cursor line\n\n\t// If we are back at the starting line and searched it again there\n\t// is no match, give up.\n\tif (lnum == wp->w_cursor.lnum && wrapped)\n\t    break;\n\n\t// Advance to next line.\n\tif (dir == BACKWARD)\n\t{\n\t    if (lnum > 1)\n\t\t--lnum;\n\t    else if (!p_ws)\n\t\tbreak;\t    // at first line and 'nowrapscan'\n\t    else\n\t    {\n\t\t// Wrap around to the end of the buffer.  May search the\n\t\t// starting line again and accept the last match.\n\t\tlnum = wp->w_buffer->b_ml.ml_line_count;\n\t\twrapped = TRUE;\n\t\tif (!shortmess(SHM_SEARCH))\n\t\t    give_warning((char_u *)_(top_bot_msg), TRUE);\n\t    }\n\t    capcol = -1;\n\t}\n\telse\n\t{\n\t    if (lnum < wp->w_buffer->b_ml.ml_line_count)\n\t\t++lnum;\n\t    else if (!p_ws)\n\t\tbreak;\t    // at first line and 'nowrapscan'\n\t    else\n\t    {\n\t\t// Wrap around to the start of the buffer.  May search the\n\t\t// starting line again and accept the first match.\n\t\tlnum = 1;\n\t\twrapped = TRUE;\n\t\tif (!shortmess(SHM_SEARCH))\n\t\t    give_warning((char_u *)_(bot_top_msg), TRUE);\n\t    }\n\n\t    // If we are back at the starting line and there is no match then\n\t    // give up.\n\t    if (lnum == wp->w_cursor.lnum && !found_one)\n\t\tbreak;\n\n\t    // Skip the characters at the start of the next line that were\n\t    // included in a match crossing line boundaries.\n\t    if (attr == HLF_COUNT)\n\t\tskip = (int)(p - endp);\n\t    else\n\t\tskip = 0;\n\n\t    // Capcol skips over the inserted space.\n\t    --capcol;\n\n\t    // But after empty line check first word in next line\n\t    if (empty_line)\n\t\tcapcol = 0;\n\t}\n\n\tline_breakcheck();\n    }\n\n    vim_free(buf);\n    return 0;\n}\n\n/*\n * For spell checking: concatenate the start of the following line \"line\" into\n * \"buf\", blanking-out special characters.  Copy less than \"maxlen\" bytes.\n * Keep the blanks at the start of the next line, this is used in win_line()\n * to skip those bytes if the word was OK.\n */\n    void\nspell_cat_line(char_u *buf, char_u *line, int maxlen)\n{\n    char_u\t*p;\n    int\t\tn;\n\n    p = skipwhite(line);\n    while (vim_strchr((char_u *)\"*#/\\\"\\t\", *p) != NULL)\n\tp = skipwhite(p + 1);\n\n    if (*p != NUL)\n    {\n\t// Only worth concatenating if there is something else than spaces to\n\t// concatenate.\n\tn = (int)(p - line) + 1;\n\tif (n < maxlen - 1)\n\t{\n\t    vim_memset(buf, ' ', n);\n\t    vim_strncpy(buf +  n, p, maxlen - 1 - n);\n\t}\n    }\n}\n\n/*\n * Structure used for the cookie argument of do_in_runtimepath().\n */\ntypedef struct spelload_S\n{\n    char_u  sl_lang[MAXWLEN + 1];\t// language name\n    slang_T *sl_slang;\t\t\t// resulting slang_T struct\n    int\t    sl_nobreak;\t\t\t// NOBREAK language found\n} spelload_T;\n\n/*\n * Load word list(s) for \"lang\" from Vim spell file(s).\n * \"lang\" must be the language without the region: e.g., \"en\".\n */\n    static void\nspell_load_lang(char_u *lang)\n{\n    char_u\tfname_enc[85];\n    int\t\tr;\n    spelload_T\tsl;\n    int\t\tround;\n\n    // Copy the language name to pass it to spell_load_cb() as a cookie.\n    // It's truncated when an error is detected.\n    STRCPY(sl.sl_lang, lang);\n    sl.sl_slang = NULL;\n    sl.sl_nobreak = FALSE;\n\n    // Disallow deleting the current buffer.  Autocommands can do weird things\n    // and cause \"lang\" to be freed.\n    ++curbuf->b_locked;\n\n    // We may retry when no spell file is found for the language, an\n    // autocommand may load it then.\n    for (round = 1; round <= 2; ++round)\n    {\n\t/*\n\t * Find the first spell file for \"lang\" in 'runtimepath' and load it.\n\t */\n\tvim_snprintf((char *)fname_enc, sizeof(fname_enc) - 5,\n#ifdef VMS\n\t\t\t\t\t\"spell/%s_%s.spl\",\n#else\n\t\t\t\t\t\"spell/%s.%s.spl\",\n#endif\n\t\t\t\t\t\t\t   lang, spell_enc());\n\tr = do_in_runtimepath(fname_enc, 0, spell_load_cb, &sl);\n\n\tif (r == FAIL && *sl.sl_lang != NUL)\n\t{\n\t    // Try loading the ASCII version.\n\t    vim_snprintf((char *)fname_enc, sizeof(fname_enc) - 5,\n#ifdef VMS\n\t\t\t\t\t\t  \"spell/%s_ascii.spl\",\n#else\n\t\t\t\t\t\t  \"spell/%s.ascii.spl\",\n#endif\n\t\t\t\t\t\t\t\t\tlang);\n\t    r = do_in_runtimepath(fname_enc, 0, spell_load_cb, &sl);\n\n\t    if (r == FAIL && *sl.sl_lang != NUL && round == 1\n\t\t    && apply_autocmds(EVENT_SPELLFILEMISSING, lang,\n\t\t\t\t\t      curbuf->b_fname, FALSE, curbuf))\n\t\tcontinue;\n\t    break;\n\t}\n\tbreak;\n    }\n\n    if (r == FAIL)\n    {\n\tsmsg(\n#ifdef VMS\n\t_(\"Warning: Cannot find word list \\\"%s_%s.spl\\\" or \\\"%s_ascii.spl\\\"\"),\n#else\n\t_(\"Warning: Cannot find word list \\\"%s.%s.spl\\\" or \\\"%s.ascii.spl\\\"\"),\n#endif\n\t\t\t\t\t\t     lang, spell_enc(), lang);\n    }\n    else if (sl.sl_slang != NULL)\n    {\n\t// At least one file was loaded, now load ALL the additions.\n\tSTRCPY(fname_enc + STRLEN(fname_enc) - 3, \"add.spl\");\n\tdo_in_runtimepath(fname_enc, DIP_ALL, spell_load_cb, &sl);\n    }\n\n    --curbuf->b_locked;\n}\n\n/*\n * Return the encoding used for spell checking: Use 'encoding', except that we\n * use \"latin1\" for \"latin9\".  And limit to 60 characters (just in case).\n */\n    char_u *\nspell_enc(void)\n{\n\n    if (STRLEN(p_enc) < 60 && STRCMP(p_enc, \"iso-8859-15\") != 0)\n\treturn p_enc;\n    return (char_u *)\"latin1\";\n}\n\n/*\n * Get the name of the .spl file for the internal wordlist into\n * \"fname[MAXPATHL]\".\n */\n    static void\nint_wordlist_spl(char_u *fname)\n{\n    vim_snprintf((char *)fname, MAXPATHL, SPL_FNAME_TMPL,\n\t\t\t\t\t\t  int_wordlist, spell_enc());\n}\n\n/*\n * Allocate a new slang_T for language \"lang\".  \"lang\" can be NULL.\n * Caller must fill \"sl_next\".\n */\n    slang_T *\nslang_alloc(char_u *lang)\n{\n    slang_T *lp;\n\n    lp = ALLOC_CLEAR_ONE(slang_T);\n    if (lp != NULL)\n    {\n\tif (lang != NULL)\n\t    lp->sl_name = vim_strsave(lang);\n\tga_init2(&lp->sl_rep, sizeof(fromto_T), 10);\n\tga_init2(&lp->sl_repsal, sizeof(fromto_T), 10);\n\tlp->sl_compmax = MAXWLEN;\n\tlp->sl_compsylmax = MAXWLEN;\n\thash_init(&lp->sl_wordcount);\n    }\n\n    return lp;\n}\n\n/*\n * Free the contents of an slang_T and the structure itself.\n */\n    void\nslang_free(slang_T *lp)\n{\n    vim_free(lp->sl_name);\n    vim_free(lp->sl_fname);\n    slang_clear(lp);\n    vim_free(lp);\n}\n\n/*\n * Clear an slang_T so that the file can be reloaded.\n */\n    void\nslang_clear(slang_T *lp)\n{\n    garray_T\t*gap;\n    fromto_T\t*ftp;\n    salitem_T\t*smp;\n    int\t\ti;\n    int\t\tround;\n\n    VIM_CLEAR(lp->sl_fbyts);\n    VIM_CLEAR(lp->sl_kbyts);\n    VIM_CLEAR(lp->sl_pbyts);\n\n    VIM_CLEAR(lp->sl_fidxs);\n    VIM_CLEAR(lp->sl_kidxs);\n    VIM_CLEAR(lp->sl_pidxs);\n\n    for (round = 1; round <= 2; ++round)\n    {\n\tgap = round == 1 ? &lp->sl_rep : &lp->sl_repsal;\n\twhile (gap->ga_len > 0)\n\t{\n\t    ftp = &((fromto_T *)gap->ga_data)[--gap->ga_len];\n\t    vim_free(ftp->ft_from);\n\t    vim_free(ftp->ft_to);\n\t}\n\tga_clear(gap);\n    }\n\n    gap = &lp->sl_sal;\n    if (lp->sl_sofo)\n    {\n\t// \"ga_len\" is set to 1 without adding an item for latin1\n\tif (gap->ga_data != NULL)\n\t    // SOFOFROM and SOFOTO items: free lists of wide characters.\n\t    for (i = 0; i < gap->ga_len; ++i)\n\t\tvim_free(((int **)gap->ga_data)[i]);\n    }\n    else\n\t// SAL items: free salitem_T items\n\twhile (gap->ga_len > 0)\n\t{\n\t    smp = &((salitem_T *)gap->ga_data)[--gap->ga_len];\n\t    vim_free(smp->sm_lead);\n\t    // Don't free sm_oneof and sm_rules, they point into sm_lead.\n\t    vim_free(smp->sm_to);\n\t    vim_free(smp->sm_lead_w);\n\t    vim_free(smp->sm_oneof_w);\n\t    vim_free(smp->sm_to_w);\n\t}\n    ga_clear(gap);\n\n    for (i = 0; i < lp->sl_prefixcnt; ++i)\n\tvim_regfree(lp->sl_prefprog[i]);\n    lp->sl_prefixcnt = 0;\n    VIM_CLEAR(lp->sl_prefprog);\n\n    VIM_CLEAR(lp->sl_info);\n\n    VIM_CLEAR(lp->sl_midword);\n\n    vim_regfree(lp->sl_compprog);\n    lp->sl_compprog = NULL;\n    VIM_CLEAR(lp->sl_comprules);\n    VIM_CLEAR(lp->sl_compstartflags);\n    VIM_CLEAR(lp->sl_compallflags);\n\n    VIM_CLEAR(lp->sl_syllable);\n    ga_clear(&lp->sl_syl_items);\n\n    ga_clear_strings(&lp->sl_comppat);\n\n    hash_clear_all(&lp->sl_wordcount, WC_KEY_OFF);\n    hash_init(&lp->sl_wordcount);\n\n    hash_clear_all(&lp->sl_map_hash, 0);\n\n    // Clear info from .sug file.\n    slang_clear_sug(lp);\n\n    lp->sl_compmax = MAXWLEN;\n    lp->sl_compminlen = 0;\n    lp->sl_compsylmax = MAXWLEN;\n    lp->sl_regions[0] = NUL;\n}\n\n/*\n * Clear the info from the .sug file in \"lp\".\n */\n    void\nslang_clear_sug(slang_T *lp)\n{\n    VIM_CLEAR(lp->sl_sbyts);\n    VIM_CLEAR(lp->sl_sidxs);\n    close_spellbuf(lp->sl_sugbuf);\n    lp->sl_sugbuf = NULL;\n    lp->sl_sugloaded = FALSE;\n    lp->sl_sugtime = 0;\n}\n\n/*\n * Load one spell file and store the info into a slang_T.\n * Invoked through do_in_runtimepath().\n */\n    static void\nspell_load_cb(char_u *fname, void *cookie)\n{\n    spelload_T\t*slp = (spelload_T *)cookie;\n    slang_T\t*slang;\n\n    slang = spell_load_file(fname, slp->sl_lang, NULL, FALSE);\n    if (slang != NULL)\n    {\n\t// When a previously loaded file has NOBREAK also use it for the\n\t// \".add\" files.\n\tif (slp->sl_nobreak && slang->sl_add)\n\t    slang->sl_nobreak = TRUE;\n\telse if (slang->sl_nobreak)\n\t    slp->sl_nobreak = TRUE;\n\n\tslp->sl_slang = slang;\n    }\n}\n\n\n/*\n * Add a word to the hashtable of common words.\n * If it's already there then the counter is increased.\n */\n    void\ncount_common_word(\n    slang_T\t*lp,\n    char_u\t*word,\n    int\t\tlen,\t    // word length, -1 for up to NUL\n    int\t\tcount)\t    // 1 to count once, 10 to init\n{\n    hash_T\thash;\n    hashitem_T\t*hi;\n    wordcount_T\t*wc;\n    char_u\tbuf[MAXWLEN];\n    char_u\t*p;\n\n    if (len == -1)\n\tp = word;\n    else if (len >= MAXWLEN)\n\treturn;\n    else\n    {\n\tvim_strncpy(buf, word, len);\n\tp = buf;\n    }\n\n    hash = hash_hash(p);\n    hi = hash_lookup(&lp->sl_wordcount, p, hash);\n    if (HASHITEM_EMPTY(hi))\n    {\n\twc = alloc(sizeof(wordcount_T) + STRLEN(p));\n\tif (wc == NULL)\n\t    return;\n\tSTRCPY(wc->wc_word, p);\n\twc->wc_count = count;\n\thash_add_item(&lp->sl_wordcount, hi, wc->wc_word, hash);\n    }\n    else\n    {\n\twc = HI2WC(hi);\n\tif ((wc->wc_count += count) < (unsigned)count)\t// check for overflow\n\t    wc->wc_count = MAXWORDCOUNT;\n    }\n}\n\n/*\n * Return TRUE if byte \"n\" appears in \"str\".\n * Like strchr() but independent of locale.\n */\n    int\nbyte_in_str(char_u *str, int n)\n{\n    char_u\t*p;\n\n    for (p = str; *p != NUL; ++p)\n\tif (*p == n)\n\t    return TRUE;\n    return FALSE;\n}\n\n#define SY_MAXLEN   30\ntypedef struct syl_item_S\n{\n    char_u\tsy_chars[SY_MAXLEN];\t    // the sequence of chars\n    int\t\tsy_len;\n} syl_item_T;\n\n/*\n * Truncate \"slang->sl_syllable\" at the first slash and put the following items\n * in \"slang->sl_syl_items\".\n */\n    int\ninit_syl_tab(slang_T *slang)\n{\n    char_u\t*p;\n    char_u\t*s;\n    int\t\tl;\n    syl_item_T\t*syl;\n\n    ga_init2(&slang->sl_syl_items, sizeof(syl_item_T), 4);\n    p = vim_strchr(slang->sl_syllable, '/');\n    while (p != NULL)\n    {\n\t*p++ = NUL;\n\tif (*p == NUL)\t    // trailing slash\n\t    break;\n\ts = p;\n\tp = vim_strchr(p, '/');\n\tif (p == NULL)\n\t    l = (int)STRLEN(s);\n\telse\n\t    l = (int)(p - s);\n\tif (l >= SY_MAXLEN)\n\t    return SP_FORMERROR;\n\tif (ga_grow(&slang->sl_syl_items, 1) == FAIL)\n\t    return SP_OTHERERROR;\n\tsyl = ((syl_item_T *)slang->sl_syl_items.ga_data)\n\t\t\t\t\t       + slang->sl_syl_items.ga_len++;\n\tvim_strncpy(syl->sy_chars, s, l);\n\tsyl->sy_len = l;\n    }\n    return OK;\n}\n\n/*\n * Count the number of syllables in \"word\".\n * When \"word\" contains spaces the syllables after the last space are counted.\n * Returns zero if syllables are not defines.\n */\n    static int\ncount_syllables(slang_T *slang, char_u *word)\n{\n    int\t\tcnt = 0;\n    int\t\tskip = FALSE;\n    char_u\t*p;\n    int\t\tlen;\n    int\t\ti;\n    syl_item_T\t*syl;\n    int\t\tc;\n\n    if (slang->sl_syllable == NULL)\n\treturn 0;\n\n    for (p = word; *p != NUL; p += len)\n    {\n\t// When running into a space reset counter.\n\tif (*p == ' ')\n\t{\n\t    len = 1;\n\t    cnt = 0;\n\t    continue;\n\t}\n\n\t// Find longest match of syllable items.\n\tlen = 0;\n\tfor (i = 0; i < slang->sl_syl_items.ga_len; ++i)\n\t{\n\t    syl = ((syl_item_T *)slang->sl_syl_items.ga_data) + i;\n\t    if (syl->sy_len > len\n\t\t\t       && STRNCMP(p, syl->sy_chars, syl->sy_len) == 0)\n\t\tlen = syl->sy_len;\n\t}\n\tif (len != 0)\t// found a match, count syllable\n\t{\n\t    ++cnt;\n\t    skip = FALSE;\n\t}\n\telse\n\t{\n\t    // No recognized syllable item, at least a syllable char then?\n\t    c = mb_ptr2char(p);\n\t    len = (*mb_ptr2len)(p);\n\t    if (vim_strchr(slang->sl_syllable, c) == NULL)\n\t\tskip = FALSE;\t    // No, search for next syllable\n\t    else if (!skip)\n\t    {\n\t\t++cnt;\t\t    // Yes, count it\n\t\tskip = TRUE;\t    // don't count following syllable chars\n\t    }\n\t}\n    }\n    return cnt;\n}\n\n/*\n * Parse 'spelllang' and set w_s->b_langp accordingly.\n * Returns NULL if it's OK, an untranslated error message otherwise.\n */\n    char *\ndid_set_spelllang(win_T *wp)\n{\n    garray_T\tga;\n    char_u\t*splp;\n    char_u\t*region;\n    char_u\tregion_cp[3];\n    int\t\tfilename;\n    int\t\tregion_mask;\n    slang_T\t*slang;\n    int\t\tc;\n    char_u\tlang[MAXWLEN + 1];\n    char_u\tspf_name[MAXPATHL];\n    int\t\tlen;\n    char_u\t*p;\n    int\t\tround;\n    char_u\t*spf;\n    char_u\t*use_region = NULL;\n    int\t\tdont_use_region = FALSE;\n    int\t\tnobreak = FALSE;\n    int\t\ti, j;\n    langp_T\t*lp, *lp2;\n    static int\trecursive = FALSE;\n    char\t*ret_msg = NULL;\n    char_u\t*spl_copy;\n    bufref_T\tbufref;\n\n    set_bufref(&bufref, wp->w_buffer);\n\n    // We don't want to do this recursively.  May happen when a language is\n    // not available and the SpellFileMissing autocommand opens a new buffer\n    // in which 'spell' is set.\n    if (recursive)\n\treturn NULL;\n    recursive = TRUE;\n\n    ga_init2(&ga, sizeof(langp_T), 2);\n    clear_midword(wp);\n\n    // Make a copy of 'spelllang', the SpellFileMissing autocommands may change\n    // it under our fingers.\n    spl_copy = vim_strsave(wp->w_s->b_p_spl);\n    if (spl_copy == NULL)\n\tgoto theend;\n\n    wp->w_s->b_cjk = 0;\n\n    // Loop over comma separated language names.\n    for (splp = spl_copy; *splp != NUL; )\n    {\n\t// Get one language name.\n\tcopy_option_part(&splp, lang, MAXWLEN, \",\");\n\tregion = NULL;\n\tlen = (int)STRLEN(lang);\n\n\tif (!valid_spelllang(lang))\n\t    continue;\n\n\tif (STRCMP(lang, \"cjk\") == 0)\n\t{\n\t    wp->w_s->b_cjk = 1;\n\t    continue;\n\t}\n\n\t// If the name ends in \".spl\" use it as the name of the spell file.\n\t// If there is a region name let \"region\" point to it and remove it\n\t// from the name.\n\tif (len > 4 && fnamecmp(lang + len - 4, \".spl\") == 0)\n\t{\n\t    filename = TRUE;\n\n\t    // Locate a region and remove it from the file name.\n\t    p = vim_strchr(gettail(lang), '_');\n\t    if (p != NULL && ASCII_ISALPHA(p[1]) && ASCII_ISALPHA(p[2])\n\t\t\t\t\t\t      && !ASCII_ISALPHA(p[3]))\n\t    {\n\t\tvim_strncpy(region_cp, p + 1, 2);\n\t\tmch_memmove(p, p + 3, len - (p - lang) - 2);\n\t\tregion = region_cp;\n\t    }\n\t    else\n\t\tdont_use_region = TRUE;\n\n\t    // Check if we loaded this language before.\n\t    FOR_ALL_SPELL_LANGS(slang)\n\t\tif (fullpathcmp(lang, slang->sl_fname, FALSE, TRUE) == FPC_SAME)\n\t\t    break;\n\t}\n\telse\n\t{\n\t    filename = FALSE;\n\t    if (len > 3 && lang[len - 3] == '_')\n\t    {\n\t\tregion = lang + len - 2;\n\t\tlen -= 3;\n\t\tlang[len] = NUL;\n\t    }\n\t    else\n\t\tdont_use_region = TRUE;\n\n\t    // Check if we loaded this language before.\n\t    FOR_ALL_SPELL_LANGS(slang)\n\t\tif (STRICMP(lang, slang->sl_name) == 0)\n\t\t    break;\n\t}\n\n\tif (region != NULL)\n\t{\n\t    // If the region differs from what was used before then don't\n\t    // use it for 'spellfile'.\n\t    if (use_region != NULL && STRCMP(region, use_region) != 0)\n\t\tdont_use_region = TRUE;\n\t    use_region = region;\n\t}\n\n\t// If not found try loading the language now.\n\tif (slang == NULL)\n\t{\n\t    if (filename)\n\t\t(void)spell_load_file(lang, lang, NULL, FALSE);\n\t    else\n\t    {\n\t\tspell_load_lang(lang);\n\t\t// SpellFileMissing autocommands may do anything, including\n\t\t// destroying the buffer we are using or closing the window.\n\t\tif (!bufref_valid(&bufref) || !win_valid_any_tab(wp))\n\t\t{\n\t\t    ret_msg = N_(e_spellfilemising_autocommand_deleted_buffer);\n\t\t    goto theend;\n\t\t}\n\t    }\n\t}\n\n\t/*\n\t * Loop over the languages, there can be several files for \"lang\".\n\t */\n\tFOR_ALL_SPELL_LANGS(slang)\n\t    if (filename ? fullpathcmp(lang, slang->sl_fname, FALSE, TRUE)\n\t\t\t\t\t\t\t\t    == FPC_SAME\n\t\t\t : STRICMP(lang, slang->sl_name) == 0)\n\t    {\n\t\tregion_mask = REGION_ALL;\n\t\tif (!filename && region != NULL)\n\t\t{\n\t\t    // find region in sl_regions\n\t\t    c = find_region(slang->sl_regions, region);\n\t\t    if (c == REGION_ALL)\n\t\t    {\n\t\t\tif (slang->sl_add)\n\t\t\t{\n\t\t\t    if (*slang->sl_regions != NUL)\n\t\t\t\t// This addition file is for other regions.\n\t\t\t\tregion_mask = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t    // This is probably an error.  Give a warning and\n\t\t\t    // accept the words anyway.\n\t\t\t    smsg(_(\"Warning: region %s not supported\"),\n\t\t\t\t\t\t\t\t      region);\n\t\t    }\n\t\t    else\n\t\t\tregion_mask = 1 << c;\n\t\t}\n\n\t\tif (region_mask != 0)\n\t\t{\n\t\t    if (ga_grow(&ga, 1) == FAIL)\n\t\t    {\n\t\t\tga_clear(&ga);\n\t\t\tret_msg = e_out_of_memory;\n\t\t\tgoto theend;\n\t\t    }\n\t\t    LANGP_ENTRY(ga, ga.ga_len)->lp_slang = slang;\n\t\t    LANGP_ENTRY(ga, ga.ga_len)->lp_region = region_mask;\n\t\t    ++ga.ga_len;\n\t\t    use_midword(slang, wp);\n\t\t    if (slang->sl_nobreak)\n\t\t\tnobreak = TRUE;\n\t\t}\n\t    }\n    }\n\n    // round 0: load int_wordlist, if possible.\n    // round 1: load first name in 'spellfile'.\n    // round 2: load second name in 'spellfile.\n    // etc.\n    spf = curwin->w_s->b_p_spf;\n    for (round = 0; round == 0 || *spf != NUL; ++round)\n    {\n\tif (round == 0)\n\t{\n\t    // Internal wordlist, if there is one.\n\t    if (int_wordlist == NULL)\n\t\tcontinue;\n\t    int_wordlist_spl(spf_name);\n\t}\n\telse\n\t{\n\t    // One entry in 'spellfile'.\n\t    copy_option_part(&spf, spf_name, MAXPATHL - 5, \",\");\n\t    STRCAT(spf_name, \".spl\");\n\n\t    // If it was already found above then skip it.\n\t    for (c = 0; c < ga.ga_len; ++c)\n\t    {\n\t\tp = LANGP_ENTRY(ga, c)->lp_slang->sl_fname;\n\t\tif (p != NULL && fullpathcmp(spf_name, p, FALSE, TRUE)\n\t\t\t\t\t\t\t\t== FPC_SAME)\n\t\t    break;\n\t    }\n\t    if (c < ga.ga_len)\n\t\tcontinue;\n\t}\n\n\t// Check if it was loaded already.\n\tFOR_ALL_SPELL_LANGS(slang)\n\t    if (fullpathcmp(spf_name, slang->sl_fname, FALSE, TRUE)\n\t\t\t\t\t\t\t\t== FPC_SAME)\n\t\tbreak;\n\tif (slang == NULL)\n\t{\n\t    // Not loaded, try loading it now.  The language name includes the\n\t    // region name, the region is ignored otherwise.  for int_wordlist\n\t    // use an arbitrary name.\n\t    if (round == 0)\n\t\tSTRCPY(lang, \"internal wordlist\");\n\t    else\n\t    {\n\t\tvim_strncpy(lang, gettail(spf_name), MAXWLEN);\n\t\tp = vim_strchr(lang, '.');\n\t\tif (p != NULL)\n\t\t    *p = NUL;\t// truncate at \".encoding.add\"\n\t    }\n\t    slang = spell_load_file(spf_name, lang, NULL, TRUE);\n\n\t    // If one of the languages has NOBREAK we assume the addition\n\t    // files also have this.\n\t    if (slang != NULL && nobreak)\n\t\tslang->sl_nobreak = TRUE;\n\t}\n\tif (slang != NULL && ga_grow(&ga, 1) == OK)\n\t{\n\t    region_mask = REGION_ALL;\n\t    if (use_region != NULL && !dont_use_region)\n\t    {\n\t\t// find region in sl_regions\n\t\tc = find_region(slang->sl_regions, use_region);\n\t\tif (c != REGION_ALL)\n\t\t    region_mask = 1 << c;\n\t\telse if (*slang->sl_regions != NUL)\n\t\t    // This spell file is for other regions.\n\t\t    region_mask = 0;\n\t    }\n\n\t    if (region_mask != 0)\n\t    {\n\t\tLANGP_ENTRY(ga, ga.ga_len)->lp_slang = slang;\n\t\tLANGP_ENTRY(ga, ga.ga_len)->lp_sallang = NULL;\n\t\tLANGP_ENTRY(ga, ga.ga_len)->lp_replang = NULL;\n\t\tLANGP_ENTRY(ga, ga.ga_len)->lp_region = region_mask;\n\t\t++ga.ga_len;\n\t\tuse_midword(slang, wp);\n\t    }\n\t}\n    }\n\n    // Everything is fine, store the new b_langp value.\n    ga_clear(&wp->w_s->b_langp);\n    wp->w_s->b_langp = ga;\n\n    // For each language figure out what language to use for sound folding and\n    // REP items.  If the language doesn't support it itself use another one\n    // with the same name.  E.g. for \"en-math\" use \"en\".\n    for (i = 0; i < ga.ga_len; ++i)\n    {\n\tlp = LANGP_ENTRY(ga, i);\n\n\t// sound folding\n\tif (lp->lp_slang->sl_sal.ga_len > 0)\n\t    // language does sound folding itself\n\t    lp->lp_sallang = lp->lp_slang;\n\telse\n\t    // find first similar language that does sound folding\n\t    for (j = 0; j < ga.ga_len; ++j)\n\t    {\n\t\tlp2 = LANGP_ENTRY(ga, j);\n\t\tif (lp2->lp_slang->sl_sal.ga_len > 0\n\t\t\t&& STRNCMP(lp->lp_slang->sl_name,\n\t\t\t\t\t      lp2->lp_slang->sl_name, 2) == 0)\n\t\t{\n\t\t    lp->lp_sallang = lp2->lp_slang;\n\t\t    break;\n\t\t}\n\t    }\n\n\t// REP items\n\tif (lp->lp_slang->sl_rep.ga_len > 0)\n\t    // language has REP items itself\n\t    lp->lp_replang = lp->lp_slang;\n\telse\n\t    // find first similar language that has REP items\n\t    for (j = 0; j < ga.ga_len; ++j)\n\t    {\n\t\tlp2 = LANGP_ENTRY(ga, j);\n\t\tif (lp2->lp_slang->sl_rep.ga_len > 0\n\t\t\t&& STRNCMP(lp->lp_slang->sl_name,\n\t\t\t\t\t      lp2->lp_slang->sl_name, 2) == 0)\n\t\t{\n\t\t    lp->lp_replang = lp2->lp_slang;\n\t\t    break;\n\t\t}\n\t    }\n    }\n    redraw_win_later(wp, UPD_NOT_VALID);\n\ntheend:\n    vim_free(spl_copy);\n    recursive = FALSE;\n    return ret_msg;\n}\n\n/*\n * Clear the midword characters for buffer \"buf\".\n */\n    static void\nclear_midword(win_T *wp)\n{\n    CLEAR_FIELD(wp->w_s->b_spell_ismw);\n    VIM_CLEAR(wp->w_s->b_spell_ismw_mb);\n}\n\n/*\n * Use the \"sl_midword\" field of language \"lp\" for buffer \"buf\".\n * They add up to any currently used midword characters.\n */\n    static void\nuse_midword(slang_T *lp, win_T *wp)\n{\n    char_u\t*p;\n\n    if (lp->sl_midword == NULL)\t    // there aren't any\n\treturn;\n\n    for (p = lp->sl_midword; *p != NUL; )\n\tif (has_mbyte)\n\t{\n\t    int\t    c, l, n;\n\t    char_u  *bp;\n\n\t    c = mb_ptr2char(p);\n\t    l = (*mb_ptr2len)(p);\n\t    if (c < 256 && l <= 2)\n\t\twp->w_s->b_spell_ismw[c] = TRUE;\n\t    else if (wp->w_s->b_spell_ismw_mb == NULL)\n\t\t// First multi-byte char in \"b_spell_ismw_mb\".\n\t\twp->w_s->b_spell_ismw_mb = vim_strnsave(p, l);\n\t    else\n\t    {\n\t\t// Append multi-byte chars to \"b_spell_ismw_mb\".\n\t\tn = (int)STRLEN(wp->w_s->b_spell_ismw_mb);\n\t\tbp = vim_strnsave(wp->w_s->b_spell_ismw_mb, n + l);\n\t\tif (bp != NULL)\n\t\t{\n\t\t    vim_free(wp->w_s->b_spell_ismw_mb);\n\t\t    wp->w_s->b_spell_ismw_mb = bp;\n\t\t    vim_strncpy(bp + n, p, l);\n\t\t}\n\t    }\n\t    p += l;\n\t}\n\telse\n\t    wp->w_s->b_spell_ismw[*p++] = TRUE;\n}\n\n/*\n * Find the region \"region[2]\" in \"rp\" (points to \"sl_regions\").\n * Each region is simply stored as the two characters of its name.\n * Returns the index if found (first is 0), REGION_ALL if not found.\n */\n    static int\nfind_region(char_u *rp, char_u *region)\n{\n    int\t\ti;\n\n    for (i = 0; ; i += 2)\n    {\n\tif (rp[i] == NUL)\n\t    return REGION_ALL;\n\tif (rp[i] == region[0] && rp[i + 1] == region[1])\n\t    break;\n    }\n    return i / 2;\n}\n\n/*\n * Return case type of word:\n * w word\t0\n * Word\t\tWF_ONECAP\n * W WORD\tWF_ALLCAP\n * WoRd\twOrd\tWF_KEEPCAP\n */\n    int\ncaptype(\n    char_u\t*word,\n    char_u\t*end)\t    // When NULL use up to NUL byte.\n{\n    char_u\t*p;\n    int\t\tc;\n    int\t\tfirstcap;\n    int\t\tallcap;\n    int\t\tpast_second = FALSE;\t// past second word char\n\n    // find first letter\n    for (p = word; !spell_iswordp_nmw(p, curwin); MB_PTR_ADV(p))\n\tif (end == NULL ? *p == NUL : p >= end)\n\t    return 0;\t    // only non-word characters, illegal word\n    if (has_mbyte)\n\tc = mb_ptr2char_adv(&p);\n    else\n\tc = *p++;\n    firstcap = allcap = SPELL_ISUPPER(c);\n\n    /*\n     * Need to check all letters to find a word with mixed upper/lower.\n     * But a word with an upper char only at start is a ONECAP.\n     */\n    for ( ; end == NULL ? *p != NUL : p < end; MB_PTR_ADV(p))\n\tif (spell_iswordp_nmw(p, curwin))\n\t{\n\t    c = PTR2CHAR(p);\n\t    if (!SPELL_ISUPPER(c))\n\t    {\n\t\t// UUl -> KEEPCAP\n\t\tif (past_second && allcap)\n\t\t    return WF_KEEPCAP;\n\t\tallcap = FALSE;\n\t    }\n\t    else if (!allcap)\n\t\t// UlU -> KEEPCAP\n\t\treturn WF_KEEPCAP;\n\t    past_second = TRUE;\n\t}\n\n    if (allcap)\n\treturn WF_ALLCAP;\n    if (firstcap)\n\treturn WF_ONECAP;\n    return 0;\n}\n\n/*\n * Delete the internal wordlist and its .spl file.\n */\n    void\nspell_delete_wordlist(void)\n{\n    char_u\tfname[MAXPATHL];\n\n    if (int_wordlist != NULL)\n    {\n\tmch_remove(int_wordlist);\n\tint_wordlist_spl(fname);\n\tmch_remove(fname);\n\tVIM_CLEAR(int_wordlist);\n    }\n}\n\n/*\n * Free all languages.\n */\n    void\nspell_free_all(void)\n{\n    slang_T\t*slang;\n    buf_T\t*buf;\n\n    // Go through all buffers and handle 'spelllang'. <VN>\n    FOR_ALL_BUFFERS(buf)\n\tga_clear(&buf->b_s.b_langp);\n\n    while (first_lang != NULL)\n    {\n\tslang = first_lang;\n\tfirst_lang = slang->sl_next;\n\tslang_free(slang);\n    }\n\n    spell_delete_wordlist();\n\n    VIM_CLEAR(repl_to);\n    VIM_CLEAR(repl_from);\n}\n\n/*\n * Clear all spelling tables and reload them.\n * Used after 'encoding' is set and when \":mkspell\" was used.\n */\n    void\nspell_reload(void)\n{\n    win_T\t*wp;\n\n    // Initialize the table for spell_iswordp().\n    init_spell_chartab();\n\n    // Unload all allocated memory.\n    spell_free_all();\n\n    // Go through all buffers and handle 'spelllang'.\n    FOR_ALL_WINDOWS(wp)\n    {\n\t// Only load the wordlists when 'spelllang' is set and there is a\n\t// window for this buffer in which 'spell' is set.\n\tif (*wp->w_s->b_p_spl != NUL)\n\t{\n\t\tif (wp->w_p_spell)\n\t\t{\n\t\t    (void)did_set_spelllang(wp);\n\t\t    break;\n\t\t}\n\t}\n    }\n}\n\n/*\n * Open a spell buffer.  This is a nameless buffer that is not in the buffer\n * list and only contains text lines.  Can use a swapfile to reduce memory\n * use.\n * Most other fields are invalid!  Esp. watch out for string options being\n * NULL and there is no undo info.\n * Returns NULL when out of memory.\n */\n    buf_T *\nopen_spellbuf(void)\n{\n    buf_T\t*buf;\n\n    buf = ALLOC_CLEAR_ONE(buf_T);\n    if (buf != NULL)\n    {\n\tbuf->b_spell = TRUE;\n\tbuf->b_p_swf = TRUE;\t// may create a swap file\n#ifdef FEAT_CRYPT\n\tbuf->b_p_key = empty_option;\n#endif\n\tml_open(buf);\n\tml_open_file(buf);\t// create swap file now\n    }\n    return buf;\n}\n\n/*\n * Close the buffer used for spell info.\n */\n    void\nclose_spellbuf(buf_T *buf)\n{\n    if (buf != NULL)\n    {\n\tml_close(buf, TRUE);\n\tvim_free(buf);\n    }\n}\n\n/*\n * Init the chartab used for spelling for ASCII.\n */\n    void\nclear_spell_chartab(spelltab_T *sp)\n{\n    int\t\ti;\n\n    // Init everything to FALSE (zero).\n    CLEAR_FIELD(sp->st_isw);\n    CLEAR_FIELD(sp->st_isu);\n    for (i = 0; i < 256; ++i)\n    {\n\tsp->st_fold[i] = i;\n\tsp->st_upper[i] = i;\n    }\n\n    // We include digits.  A word shouldn't start with a digit, but handling\n    // that is done separately.\n    for (i = '0'; i <= '9'; ++i)\n\tsp->st_isw[i] = TRUE;\n    for (i = 'A'; i <= 'Z'; ++i)\n    {\n\tsp->st_isw[i] = TRUE;\n\tsp->st_isu[i] = TRUE;\n\tsp->st_fold[i] = i + 0x20;\n    }\n    for (i = 'a'; i <= 'z'; ++i)\n    {\n\tsp->st_isw[i] = TRUE;\n\tsp->st_upper[i] = i - 0x20;\n    }\n}\n\n/*\n * Init the chartab used for spelling.  Only depends on 'encoding'.\n * Called once while starting up and when 'encoding' changes.\n * The default is to use isalpha(), but the spell file should define the word\n * characters to make it possible that 'encoding' differs from the current\n * locale.  For utf-8 we don't use isalpha() but our own functions.\n */\n    void\ninit_spell_chartab(void)\n{\n    int\t    i;\n\n    did_set_spelltab = FALSE;\n    clear_spell_chartab(&spelltab);\n    if (enc_dbcs)\n    {\n\t// DBCS: assume double-wide characters are word characters.\n\tfor (i = 128; i <= 255; ++i)\n\t    if (MB_BYTE2LEN(i) == 2)\n\t\tspelltab.st_isw[i] = TRUE;\n    }\n    else if (enc_utf8)\n    {\n\tfor (i = 128; i < 256; ++i)\n\t{\n\t    int f = utf_fold(i);\n\t    int u = utf_toupper(i);\n\n\t    spelltab.st_isu[i] = utf_isupper(i);\n\t    spelltab.st_isw[i] = spelltab.st_isu[i] || utf_islower(i);\n\t    // The folded/upper-cased value is different between latin1 and\n\t    // utf8 for 0xb5, causing E763 for no good reason.  Use the latin1\n\t    // value for utf-8 to avoid this.\n\t    spelltab.st_fold[i] = (f < 256) ? f : i;\n\t    spelltab.st_upper[i] = (u < 256) ? u : i;\n\t}\n    }\n    else\n    {\n\t// Rough guess: use locale-dependent library functions.\n\tfor (i = 128; i < 256; ++i)\n\t{\n\t    if (MB_ISUPPER(i))\n\t    {\n\t\tspelltab.st_isw[i] = TRUE;\n\t\tspelltab.st_isu[i] = TRUE;\n\t\tspelltab.st_fold[i] = MB_TOLOWER(i);\n\t    }\n\t    else if (MB_ISLOWER(i))\n\t    {\n\t\tspelltab.st_isw[i] = TRUE;\n\t\tspelltab.st_upper[i] = MB_TOUPPER(i);\n\t    }\n\t}\n    }\n}\n\n\n/*\n * Return TRUE if \"p\" points to a word character.\n * As a special case we see \"midword\" characters as word character when it is\n * followed by a word character.  This finds they'there but not 'they there'.\n * Thus this only works properly when past the first character of the word.\n */\n    int\nspell_iswordp(\n    char_u\t*p,\n    win_T\t*wp)\t    // buffer used\n{\n    char_u\t*s;\n    int\t\tl;\n    int\t\tc;\n\n    if (has_mbyte)\n    {\n\tl = mb_ptr2len(p);\n\ts = p;\n\tif (l == 1)\n\t{\n\t    // be quick for ASCII\n\t    if (wp->w_s->b_spell_ismw[*p])\n\t\ts = p + 1;\t\t// skip a mid-word character\n\t}\n\telse\n\t{\n\t    c = mb_ptr2char(p);\n\t    if (c < 256 ? wp->w_s->b_spell_ismw[c]\n\t\t    : (wp->w_s->b_spell_ismw_mb != NULL\n\t\t\t   && vim_strchr(wp->w_s->b_spell_ismw_mb, c) != NULL))\n\t\ts = p + l;\n\t}\n\n\tc = mb_ptr2char(s);\n\tif (c > 255)\n\t    return spell_mb_isword_class(mb_get_class(s), wp);\n\treturn spelltab.st_isw[c];\n    }\n\n    return spelltab.st_isw[wp->w_s->b_spell_ismw[*p] ? p[1] : p[0]];\n}\n\n/*\n * Return TRUE if \"p\" points to a word character.\n * Unlike spell_iswordp() this doesn't check for \"midword\" characters.\n */\n    int\nspell_iswordp_nmw(char_u *p, win_T *wp)\n{\n    int\t\tc;\n\n    if (has_mbyte)\n    {\n\tc = mb_ptr2char(p);\n\tif (c > 255)\n\t    return spell_mb_isword_class(mb_get_class(p), wp);\n\treturn spelltab.st_isw[c];\n    }\n    return spelltab.st_isw[*p];\n}\n\n/*\n * Return TRUE if word class indicates a word character.\n * Only for characters above 255.\n * Unicode subscript and superscript are not considered word characters.\n * See also dbcs_class() and utf_class() in mbyte.c.\n */\n    static int\nspell_mb_isword_class(int cl, win_T *wp)\n{\n    if (wp->w_s->b_cjk)\n\t// East Asian characters are not considered word characters.\n\treturn cl == 2 || cl == 0x2800;\n    return cl >= 2 && cl != 0x2070 && cl != 0x2080 && cl != 3;\n}\n\n/*\n * Return TRUE if \"p\" points to a word character.\n * Wide version of spell_iswordp().\n */\n    static int\nspell_iswordp_w(int *p, win_T *wp)\n{\n    int\t\t*s;\n\n    if (*p < 256 ? wp->w_s->b_spell_ismw[*p]\n\t\t : (wp->w_s->b_spell_ismw_mb != NULL\n\t\t\t     && vim_strchr(wp->w_s->b_spell_ismw_mb, *p) != NULL))\n\ts = p + 1;\n    else\n\ts = p;\n\n    if (*s > 255)\n    {\n\tif (enc_utf8)\n\t    return spell_mb_isword_class(utf_class(*s), wp);\n\tif (enc_dbcs)\n\t    return spell_mb_isword_class(\n\t\t\t\tdbcs_class((unsigned)*s >> 8, *s & 0xff), wp);\n\treturn 0;\n    }\n    return spelltab.st_isw[*s];\n}\n\n/*\n * Case-fold \"str[len]\" into \"buf[buflen]\".  The result is NUL terminated.\n * Uses the character definitions from the .spl file.\n * When using a multi-byte 'encoding' the length may change!\n * Returns FAIL when something wrong.\n */\n    int\nspell_casefold(\n    win_T\t*wp,\n    char_u\t*str,\n    int\t\tlen,\n    char_u\t*buf,\n    int\t\tbuflen)\n{\n    int\t\ti;\n\n    if (len >= buflen)\n    {\n\tbuf[0] = NUL;\n\treturn FAIL;\t\t// result will not fit\n    }\n\n    if (has_mbyte)\n    {\n\tint\touti = 0;\n\tchar_u\t*p;\n\tint\tc;\n\n\t// Fold one character at a time.\n\tfor (p = str; p < str + len; )\n\t{\n\t    if (outi + MB_MAXBYTES > buflen)\n\t    {\n\t\tbuf[outi] = NUL;\n\t\treturn FAIL;\n\t    }\n\t    c = mb_cptr2char_adv(&p);\n\n\t    // Exception: greek capital sigma 0x03A3 folds to 0x03C3, except\n\t    // when it is the last character in a word, then it folds to\n\t    // 0x03C2.\n\t    if (c == 0x03a3 || c == 0x03c2)\n\t    {\n\t\tif (p == str + len || !spell_iswordp(p, wp))\n\t\t    c = 0x03c2;\n\t\telse\n\t\t    c = 0x03c3;\n\t    }\n\t    else\n\t\tc = SPELL_TOFOLD(c);\n\n\t    outi += mb_char2bytes(c, buf + outi);\n\t}\n\tbuf[outi] = NUL;\n    }\n    else\n    {\n\t// Be quick for non-multibyte encodings.\n\tfor (i = 0; i < len; ++i)\n\t    buf[i] = spelltab.st_fold[str[i]];\n\tbuf[i] = NUL;\n    }\n\n    return OK;\n}\n\n/*\n * Check if the word at line \"lnum\" column \"col\" is required to start with a\n * capital.  This uses 'spellcapcheck' of the current buffer.\n */\n    int\ncheck_need_cap(linenr_T lnum, colnr_T col)\n{\n    int\t\tneed_cap = FALSE;\n    char_u\t*line;\n    char_u\t*line_copy = NULL;\n    char_u\t*p;\n    colnr_T\tendcol;\n    regmatch_T\tregmatch;\n\n    if (curwin->w_s->b_cap_prog == NULL)\n\treturn FALSE;\n\n    line = ml_get_curline();\n    endcol = 0;\n    if (getwhitecols(line) >= (int)col)\n    {\n\t// At start of line, check if previous line is empty or sentence\n\t// ends there.\n\tif (lnum == 1)\n\t    need_cap = TRUE;\n\telse\n\t{\n\t    line = ml_get(lnum - 1);\n\t    if (*skipwhite(line) == NUL)\n\t\tneed_cap = TRUE;\n\t    else\n\t    {\n\t\t// Append a space in place of the line break.\n\t\tline_copy = concat_str(line, (char_u *)\" \");\n\t\tline = line_copy;\n\t\tendcol = (colnr_T)STRLEN(line);\n\t    }\n\t}\n    }\n    else\n\tendcol = col;\n\n    if (endcol > 0)\n    {\n\t// Check if sentence ends before the bad word.\n\tregmatch.regprog = curwin->w_s->b_cap_prog;\n\tregmatch.rm_ic = FALSE;\n\tp = line + endcol;\n\tfor (;;)\n\t{\n\t    MB_PTR_BACK(line, p);\n\t    if (p == line || spell_iswordp_nmw(p, curwin))\n\t\tbreak;\n\t    if (vim_regexec(&regmatch, p, 0)\n\t\t\t\t\t && regmatch.endp[0] == line + endcol)\n\t    {\n\t\tneed_cap = TRUE;\n\t\tbreak;\n\t    }\n\t}\n\tcurwin->w_s->b_cap_prog = regmatch.regprog;\n    }\n\n    vim_free(line_copy);\n\n    return need_cap;\n}\n\n\n/*\n * \":spellrepall\"\n */\n    void\nex_spellrepall(exarg_T *eap UNUSED)\n{\n    pos_T\tpos = curwin->w_cursor;\n    char_u\t*frompat;\n    int\t\taddlen;\n    char_u\t*line;\n    char_u\t*p;\n    int\t\tsave_ws = p_ws;\n    linenr_T\tprev_lnum = 0;\n\n    if (repl_from == NULL || repl_to == NULL)\n    {\n\temsg(_(e_no_previous_spell_replacement));\n\treturn;\n    }\n    addlen = (int)(STRLEN(repl_to) - STRLEN(repl_from));\n\n    frompat = alloc(STRLEN(repl_from) + 7);\n    if (frompat == NULL)\n\treturn;\n    sprintf((char *)frompat, \"\\\\V\\\\<%s\\\\>\", repl_from);\n    p_ws = FALSE;\n\n    sub_nsubs = 0;\n    sub_nlines = 0;\n    curwin->w_cursor.lnum = 0;\n    while (!got_int)\n    {\n\tif (do_search(NULL, '/', '/', frompat, 1L, SEARCH_KEEP, NULL) == 0\n\t\t\t\t\t\t   || u_save_cursor() == FAIL)\n\t    break;\n\n\t// Only replace when the right word isn't there yet.  This happens\n\t// when changing \"etc\" to \"etc.\".\n\tline = ml_get_curline();\n\tif (addlen <= 0 || STRNCMP(line + curwin->w_cursor.col,\n\t\t\t\t\t       repl_to, STRLEN(repl_to)) != 0)\n\t{\n\t    p = alloc(STRLEN(line) + addlen + 1);\n\t    if (p == NULL)\n\t\tbreak;\n\t    mch_memmove(p, line, curwin->w_cursor.col);\n\t    STRCPY(p + curwin->w_cursor.col, repl_to);\n\t    STRCAT(p, line + curwin->w_cursor.col + STRLEN(repl_from));\n\t    ml_replace(curwin->w_cursor.lnum, p, FALSE);\n\t    changed_bytes(curwin->w_cursor.lnum, curwin->w_cursor.col);\n#if defined(FEAT_PROP_POPUP)\n\t    if (curbuf->b_has_textprop && addlen != 0)\n\t\tadjust_prop_columns(curwin->w_cursor.lnum,\n\t\t\t\t curwin->w_cursor.col, addlen, APC_SUBSTITUTE);\n#endif\n\n\t    if (curwin->w_cursor.lnum != prev_lnum)\n\t    {\n\t\t++sub_nlines;\n\t\tprev_lnum = curwin->w_cursor.lnum;\n\t    }\n\t    ++sub_nsubs;\n\t}\n\tcurwin->w_cursor.col += (colnr_T)STRLEN(repl_to);\n    }\n\n    p_ws = save_ws;\n    curwin->w_cursor = pos;\n    vim_free(frompat);\n\n    if (sub_nsubs == 0)\n\tsemsg(_(e_not_found_str), repl_from);\n    else\n\tdo_sub_msg(FALSE);\n}\n\n/*\n * Make a copy of \"word\", with the first letter upper or lower cased, to\n * \"wcopy[MAXWLEN]\".  \"word\" must not be empty.\n * The result is NUL terminated.\n */\n    void\nonecap_copy(\n    char_u\t*word,\n    char_u\t*wcopy,\n    int\t\tupper)\t    // TRUE: first letter made upper case\n{\n    char_u\t*p;\n    int\t\tc;\n    int\t\tl;\n\n    p = word;\n    if (has_mbyte)\n\tc = mb_cptr2char_adv(&p);\n    else\n\tc = *p++;\n    if (upper)\n\tc = SPELL_TOUPPER(c);\n    else\n\tc = SPELL_TOFOLD(c);\n    if (has_mbyte)\n\tl = mb_char2bytes(c, wcopy);\n    else\n    {\n\tl = 1;\n\twcopy[0] = c;\n    }\n    vim_strncpy(wcopy + l, p, MAXWLEN - l - 1);\n}\n\n/*\n * Make a copy of \"word\" with all the letters upper cased into\n * \"wcopy[MAXWLEN]\".  The result is NUL terminated.\n */\n    void\nallcap_copy(char_u *word, char_u *wcopy)\n{\n    char_u\t*s;\n    char_u\t*d;\n    int\t\tc;\n\n    d = wcopy;\n    for (s = word; *s != NUL; )\n    {\n\tif (has_mbyte)\n\t    c = mb_cptr2char_adv(&s);\n\telse\n\t    c = *s++;\n\n\t// We only change 0xdf to SS when we are certain latin1 is used.  It\n\t// would cause weird errors in other 8-bit encodings.\n\tif (enc_latin1like && c == 0xdf)\n\t{\n\t    c = 'S';\n\t    if (d - wcopy >= MAXWLEN - 1)\n\t\tbreak;\n\t    *d++ = c;\n\t}\n\telse\n\t    c = SPELL_TOUPPER(c);\n\n\tif (has_mbyte)\n\t{\n\t    if (d - wcopy >= MAXWLEN - MB_MAXBYTES)\n\t\tbreak;\n\t    d += mb_char2bytes(c, d);\n\t}\n\telse\n\t{\n\t    if (d - wcopy >= MAXWLEN - 1)\n\t\tbreak;\n\t    *d++ = c;\n\t}\n    }\n    *d = NUL;\n}\n\n/*\n * Case-folding may change the number of bytes: Count nr of chars in\n * fword[flen] and return the byte length of that many chars in \"word\".\n */\n    int\nnofold_len(char_u *fword, int flen, char_u *word)\n{\n    char_u\t*p;\n    int\t\ti = 0;\n\n    for (p = fword; p < fword + flen; MB_PTR_ADV(p))\n\t++i;\n    for (p = word; i > 0; MB_PTR_ADV(p))\n\t--i;\n    return (int)(p - word);\n}\n\n/*\n * Copy \"fword\" to \"cword\", fixing case according to \"flags\".\n */\n    void\nmake_case_word(char_u *fword, char_u *cword, int flags)\n{\n    if (flags & WF_ALLCAP)\n\t// Make it all upper-case\n\tallcap_copy(fword, cword);\n    else if (flags & WF_ONECAP)\n\t// Make the first letter upper-case\n\tonecap_copy(fword, cword, TRUE);\n    else\n\t// Use goodword as-is.\n\tSTRCPY(cword, fword);\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Soundfold a string, for soundfold().\n * Result is in allocated memory, NULL for an error.\n */\n    char_u *\neval_soundfold(char_u *word)\n{\n    langp_T\t*lp;\n    char_u\tsound[MAXWLEN];\n    int\t\tlpi;\n\n    if (curwin->w_p_spell && *curwin->w_s->b_p_spl != NUL)\n\t// Use the sound-folding of the first language that supports it.\n\tfor (lpi = 0; lpi < curwin->w_s->b_langp.ga_len; ++lpi)\n\t{\n\t    lp = LANGP_ENTRY(curwin->w_s->b_langp, lpi);\n\t    if (lp->lp_slang->sl_sal.ga_len > 0)\n\t    {\n\t\t// soundfold the word\n\t\tspell_soundfold(lp->lp_slang, word, FALSE, sound);\n\t\treturn vim_strsave(sound);\n\t    }\n\t}\n\n    // No language with sound folding, return word as-is.\n    return vim_strsave(word);\n}\n#endif\n\n/*\n * Turn \"inword\" into its sound-a-like equivalent in \"res[MAXWLEN]\".\n *\n * There are many ways to turn a word into a sound-a-like representation.  The\n * oldest is Soundex (1918!).   A nice overview can be found in \"Approximate\n * swedish name matching - survey and test of different algorithms\" by Klas\n * Erikson.\n *\n * We support two methods:\n * 1. SOFOFROM/SOFOTO do a simple character mapping.\n * 2. SAL items define a more advanced sound-folding (and much slower).\n */\n    void\nspell_soundfold(\n    slang_T\t*slang,\n    char_u\t*inword,\n    int\t\tfolded,\t    // \"inword\" is already case-folded\n    char_u\t*res)\n{\n    char_u\tfword[MAXWLEN];\n    char_u\t*word;\n\n    if (slang->sl_sofo)\n\t// SOFOFROM and SOFOTO used\n\tspell_soundfold_sofo(slang, inword, res);\n    else\n    {\n\t// SAL items used.  Requires the word to be case-folded.\n\tif (folded)\n\t    word = inword;\n\telse\n\t{\n\t    (void)spell_casefold(curwin,\n\t\t\t\t  inword, (int)STRLEN(inword), fword, MAXWLEN);\n\t    word = fword;\n\t}\n\n\tif (has_mbyte)\n\t    spell_soundfold_wsal(slang, word, res);\n\telse\n\t    spell_soundfold_sal(slang, word, res);\n    }\n}\n\n/*\n * Perform sound folding of \"inword\" into \"res\" according to SOFOFROM and\n * SOFOTO lines.\n */\n    static void\nspell_soundfold_sofo(slang_T *slang, char_u *inword, char_u *res)\n{\n    char_u\t*s;\n    int\t\tri = 0;\n    int\t\tc;\n\n    if (has_mbyte)\n    {\n\tint\tprevc = 0;\n\tint\t*ip;\n\n\t// The sl_sal_first[] table contains the translation for chars up to\n\t// 255, sl_sal the rest.\n\tfor (s = inword; *s != NUL; )\n\t{\n\t    c = mb_cptr2char_adv(&s);\n\t    if (enc_utf8 ? utf_class(c) == 0 : VIM_ISWHITE(c))\n\t\tc = ' ';\n\t    else if (c < 256)\n\t\tc = slang->sl_sal_first[c];\n\t    else\n\t    {\n\t\tip = ((int **)slang->sl_sal.ga_data)[c & 0xff];\n\t\tif (ip == NULL)\t\t// empty list, can't match\n\t\t    c = NUL;\n\t\telse\n\t\t    for (;;)\t\t// find \"c\" in the list\n\t\t    {\n\t\t\tif (*ip == 0)\t// not found\n\t\t\t{\n\t\t\t    c = NUL;\n\t\t\t    break;\n\t\t\t}\n\t\t\tif (*ip == c)\t// match!\n\t\t\t{\n\t\t\t    c = ip[1];\n\t\t\t    break;\n\t\t\t}\n\t\t\tip += 2;\n\t\t    }\n\t    }\n\n\t    if (c != NUL && c != prevc)\n\t    {\n\t\tri += mb_char2bytes(c, res + ri);\n\t\tif (ri + MB_MAXBYTES > MAXWLEN)\n\t\t    break;\n\t\tprevc = c;\n\t    }\n\t}\n    }\n    else\n    {\n\t// The sl_sal_first[] table contains the translation.\n\tfor (s = inword; (c = *s) != NUL; ++s)\n\t{\n\t    if (VIM_ISWHITE(c))\n\t\tc = ' ';\n\t    else\n\t\tc = slang->sl_sal_first[c];\n\t    if (c != NUL && (ri == 0 || res[ri - 1] != c))\n\t\tres[ri++] = c;\n\t}\n    }\n\n    res[ri] = NUL;\n}\n\n    static void\nspell_soundfold_sal(slang_T *slang, char_u *inword, char_u *res)\n{\n    salitem_T\t*smp;\n    char_u\tword[MAXWLEN];\n    char_u\t*s = inword;\n    char_u\t*t;\n    char_u\t*pf;\n    int\t\ti, j, z;\n    int\t\treslen;\n    int\t\tn, k = 0;\n    int\t\tz0;\n    int\t\tk0;\n    int\t\tn0;\n    int\t\tc;\n    int\t\tpri;\n    int\t\tp0 = -333;\n    int\t\tc0;\n\n    // Remove accents, if wanted.  We actually remove all non-word characters.\n    // But keep white space.  We need a copy, the word may be changed here.\n    if (slang->sl_rem_accents)\n    {\n\tt = word;\n\twhile (*s != NUL)\n\t{\n\t    if (VIM_ISWHITE(*s))\n\t    {\n\t\t*t++ = ' ';\n\t\ts = skipwhite(s);\n\t    }\n\t    else\n\t    {\n\t\tif (spell_iswordp_nmw(s, curwin))\n\t\t    *t++ = *s;\n\t\t++s;\n\t    }\n\t}\n\t*t = NUL;\n    }\n    else\n\tvim_strncpy(word, s, MAXWLEN - 1);\n\n    smp = (salitem_T *)slang->sl_sal.ga_data;\n\n    /*\n     * This comes from Aspell phonet.cpp.  Converted from C++ to C.\n     * Changed to keep spaces.\n     */\n    i = reslen = z = 0;\n    while ((c = word[i]) != NUL)\n    {\n\t// Start with the first rule that has the character in the word.\n\tn = slang->sl_sal_first[c];\n\tz0 = 0;\n\n\tif (n >= 0)\n\t{\n\t    // check all rules for the same letter\n\t    for (; (s = smp[n].sm_lead)[0] == c; ++n)\n\t    {\n\t\t// Quickly skip entries that don't match the word.  Most\n\t\t// entries are less than three chars, optimize for that.\n\t\tk = smp[n].sm_leadlen;\n\t\tif (k > 1)\n\t\t{\n\t\t    if (word[i + 1] != s[1])\n\t\t\tcontinue;\n\t\t    if (k > 2)\n\t\t    {\n\t\t\tfor (j = 2; j < k; ++j)\n\t\t\t    if (word[i + j] != s[j])\n\t\t\t\tbreak;\n\t\t\tif (j < k)\n\t\t\t    continue;\n\t\t    }\n\t\t}\n\n\t\tif ((pf = smp[n].sm_oneof) != NULL)\n\t\t{\n\t\t    // Check for match with one of the chars in \"sm_oneof\".\n\t\t    while (*pf != NUL && *pf != word[i + k])\n\t\t\t++pf;\n\t\t    if (*pf == NUL)\n\t\t\tcontinue;\n\t\t    ++k;\n\t\t}\n\t\ts = smp[n].sm_rules;\n\t\tpri = 5;    // default priority\n\n\t\tp0 = *s;\n\t\tk0 = k;\n\t\twhile (*s == '-' && k > 1)\n\t\t{\n\t\t    k--;\n\t\t    s++;\n\t\t}\n\t\tif (*s == '<')\n\t\t    s++;\n\t\tif (VIM_ISDIGIT(*s))\n\t\t{\n\t\t    // determine priority\n\t\t    pri = *s - '0';\n\t\t    s++;\n\t\t}\n\t\tif (*s == '^' && *(s + 1) == '^')\n\t\t    s++;\n\n\t\tif (*s == NUL\n\t\t\t|| (*s == '^'\n\t\t\t    && (i == 0 || !(word[i - 1] == ' '\n\t\t\t\t      || spell_iswordp(word + i - 1, curwin)))\n\t\t\t    && (*(s + 1) != '$'\n\t\t\t\t|| (!spell_iswordp(word + i + k0, curwin))))\n\t\t\t|| (*s == '$' && i > 0\n\t\t\t    && spell_iswordp(word + i - 1, curwin)\n\t\t\t    && (!spell_iswordp(word + i + k0, curwin))))\n\t\t{\n\t\t    // search for followup rules, if:\n\t\t    // followup and k > 1  and  NO '-' in searchstring\n\t\t    c0 = word[i + k - 1];\n\t\t    n0 = slang->sl_sal_first[c0];\n\n\t\t    if (slang->sl_followup && k > 1 && n0 >= 0\n\t\t\t\t\t   && p0 != '-' && word[i + k] != NUL)\n\t\t    {\n\t\t\t// test follow-up rule for \"word[i + k]\"\n\t\t\tfor ( ; (s = smp[n0].sm_lead)[0] == c0; ++n0)\n\t\t\t{\n\t\t\t    // Quickly skip entries that don't match the word.\n\t\t\t    //\n\t\t\t    k0 = smp[n0].sm_leadlen;\n\t\t\t    if (k0 > 1)\n\t\t\t    {\n\t\t\t\tif (word[i + k] != s[1])\n\t\t\t\t    continue;\n\t\t\t\tif (k0 > 2)\n\t\t\t\t{\n\t\t\t\t    pf = word + i + k + 1;\n\t\t\t\t    for (j = 2; j < k0; ++j)\n\t\t\t\t\tif (*pf++ != s[j])\n\t\t\t\t\t    break;\n\t\t\t\t    if (j < k0)\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t    }\n\t\t\t    k0 += k - 1;\n\n\t\t\t    if ((pf = smp[n0].sm_oneof) != NULL)\n\t\t\t    {\n\t\t\t\t// Check for match with one of the chars in\n\t\t\t\t// \"sm_oneof\".\n\t\t\t\twhile (*pf != NUL && *pf != word[i + k0])\n\t\t\t\t    ++pf;\n\t\t\t\tif (*pf == NUL)\n\t\t\t\t    continue;\n\t\t\t\t++k0;\n\t\t\t    }\n\n\t\t\t    p0 = 5;\n\t\t\t    s = smp[n0].sm_rules;\n\t\t\t    while (*s == '-')\n\t\t\t    {\n\t\t\t\t// \"k0\" gets NOT reduced because\n\t\t\t\t// \"if (k0 == k)\"\n\t\t\t\ts++;\n\t\t\t    }\n\t\t\t    if (*s == '<')\n\t\t\t\ts++;\n\t\t\t    if (VIM_ISDIGIT(*s))\n\t\t\t    {\n\t\t\t\tp0 = *s - '0';\n\t\t\t\ts++;\n\t\t\t    }\n\n\t\t\t    if (*s == NUL\n\t\t\t\t    // *s == '^' cuts\n\t\t\t\t    || (*s == '$'\n\t\t\t\t\t    && !spell_iswordp(word + i + k0,\n\t\t\t\t\t\t\t\t     curwin)))\n\t\t\t    {\n\t\t\t\tif (k0 == k)\n\t\t\t\t    // this is just a piece of the string\n\t\t\t\t    continue;\n\n\t\t\t\tif (p0 < pri)\n\t\t\t\t    // priority too low\n\t\t\t\t    continue;\n\t\t\t\t// rule fits; stop search\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t}\n\n\t\t\tif (p0 >= pri && smp[n0].sm_lead[0] == c0)\n\t\t\t    continue;\n\t\t    }\n\n\t\t    // replace string\n\t\t    s = smp[n].sm_to;\n\t\t    if (s == NULL)\n\t\t\ts = (char_u *)\"\";\n\t\t    pf = smp[n].sm_rules;\n\t\t    p0 = (vim_strchr(pf, '<') != NULL) ? 1 : 0;\n\t\t    if (p0 == 1 && z == 0)\n\t\t    {\n\t\t\t// rule with '<' is used\n\t\t\tif (reslen > 0 && *s != NUL && (res[reslen - 1] == c\n\t\t\t\t\t\t    || res[reslen - 1] == *s))\n\t\t\t    reslen--;\n\t\t\tz0 = 1;\n\t\t\tz = 1;\n\t\t\tk0 = 0;\n\t\t\twhile (*s != NUL && word[i + k0] != NUL)\n\t\t\t{\n\t\t\t    word[i + k0] = *s;\n\t\t\t    k0++;\n\t\t\t    s++;\n\t\t\t}\n\t\t\tif (k > k0)\n\t\t\t    STRMOVE(word + i + k0, word + i + k);\n\n\t\t\t// new \"actual letter\"\n\t\t\tc = word[i];\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t// no '<' rule used\n\t\t\ti += k - 1;\n\t\t\tz = 0;\n\t\t\twhile (*s != NUL && s[1] != NUL && reslen < MAXWLEN)\n\t\t\t{\n\t\t\t    if (reslen == 0 || res[reslen - 1] != *s)\n\t\t\t\tres[reslen++] = *s;\n\t\t\t    s++;\n\t\t\t}\n\t\t\t// new \"actual letter\"\n\t\t\tc = *s;\n\t\t\tif (strstr((char *)pf, \"^^\") != NULL)\n\t\t\t{\n\t\t\t    if (c != NUL)\n\t\t\t\tres[reslen++] = c;\n\t\t\t    STRMOVE(word, word + i + 1);\n\t\t\t    i = 0;\n\t\t\t    z0 = 1;\n\t\t\t}\n\t\t    }\n\t\t    break;\n\t\t}\n\t    }\n\t}\n\telse if (VIM_ISWHITE(c))\n\t{\n\t    c = ' ';\n\t    k = 1;\n\t}\n\n\tif (z0 == 0)\n\t{\n\t    if (k && !p0 && reslen < MAXWLEN && c != NUL\n\t\t    && (!slang->sl_collapse || reslen == 0\n\t\t\t\t\t\t     || res[reslen - 1] != c))\n\t\t// condense only double letters\n\t\tres[reslen++] = c;\n\n\t    i++;\n\t    z = 0;\n\t    k = 0;\n\t}\n    }\n\n    res[reslen] = NUL;\n}\n\n/*\n * Turn \"inword\" into its sound-a-like equivalent in \"res[MAXWLEN]\".\n * Multi-byte version of spell_soundfold().\n */\n    static void\nspell_soundfold_wsal(slang_T *slang, char_u *inword, char_u *res)\n{\n    salitem_T\t*smp = (salitem_T *)slang->sl_sal.ga_data;\n    int\t\tword[MAXWLEN];\n    int\t\twres[MAXWLEN];\n    int\t\tl;\n    char_u\t*s;\n    int\t\t*ws;\n    char_u\t*t;\n    int\t\t*pf;\n    int\t\ti, j, z;\n    int\t\treslen;\n    int\t\tn, k = 0;\n    int\t\tz0;\n    int\t\tk0;\n    int\t\tn0;\n    int\t\tc;\n    int\t\tpri;\n    int\t\tp0 = -333;\n    int\t\tc0;\n    int\t\tdid_white = FALSE;\n    int\t\twordlen;\n\n\n    /*\n     * Convert the multi-byte string to a wide-character string.\n     * Remove accents, if wanted.  We actually remove all non-word characters.\n     * But keep white space.\n     */\n    wordlen = 0;\n    for (s = inword; *s != NUL; )\n    {\n\tt = s;\n\tc = mb_cptr2char_adv(&s);\n\tif (slang->sl_rem_accents)\n\t{\n\t    if (enc_utf8 ? utf_class(c) == 0 : VIM_ISWHITE(c))\n\t    {\n\t\tif (did_white)\n\t\t    continue;\n\t\tc = ' ';\n\t\tdid_white = TRUE;\n\t    }\n\t    else\n\t    {\n\t\tdid_white = FALSE;\n\t\tif (!spell_iswordp_nmw(t, curwin))\n\t\t    continue;\n\t    }\n\t}\n\tword[wordlen++] = c;\n    }\n    word[wordlen] = NUL;\n\n    /*\n     * This algorithm comes from Aspell phonet.cpp.\n     * Converted from C++ to C.  Added support for multi-byte chars.\n     * Changed to keep spaces.\n     */\n    i = reslen = z = 0;\n    while ((c = word[i]) != NUL)\n    {\n\t// Start with the first rule that has the character in the word.\n\tn = slang->sl_sal_first[c & 0xff];\n\tz0 = 0;\n\n\tif (n >= 0)\n\t{\n\t    // Check all rules for the same index byte.\n\t    // If c is 0x300 need extra check for the end of the array, as\n\t    // (c & 0xff) is NUL.\n\t    for (; ((ws = smp[n].sm_lead_w)[0] & 0xff) == (c & 0xff)\n\t\t\t\t\t\t\t && ws[0] != NUL; ++n)\n\t    {\n\t\t// Quickly skip entries that don't match the word.  Most\n\t\t// entries are less than three chars, optimize for that.\n\t\tif (c != ws[0])\n\t\t    continue;\n\t\tk = smp[n].sm_leadlen;\n\t\tif (k > 1)\n\t\t{\n\t\t    if (word[i + 1] != ws[1])\n\t\t\tcontinue;\n\t\t    if (k > 2)\n\t\t    {\n\t\t\tfor (j = 2; j < k; ++j)\n\t\t\t    if (word[i + j] != ws[j])\n\t\t\t\tbreak;\n\t\t\tif (j < k)\n\t\t\t    continue;\n\t\t    }\n\t\t}\n\n\t\tif ((pf = smp[n].sm_oneof_w) != NULL)\n\t\t{\n\t\t    // Check for match with one of the chars in \"sm_oneof\".\n\t\t    while (*pf != NUL && *pf != word[i + k])\n\t\t\t++pf;\n\t\t    if (*pf == NUL)\n\t\t\tcontinue;\n\t\t    ++k;\n\t\t}\n\t\ts = smp[n].sm_rules;\n\t\tpri = 5;    // default priority\n\n\t\tp0 = *s;\n\t\tk0 = k;\n\t\twhile (*s == '-' && k > 1)\n\t\t{\n\t\t    k--;\n\t\t    s++;\n\t\t}\n\t\tif (*s == '<')\n\t\t    s++;\n\t\tif (VIM_ISDIGIT(*s))\n\t\t{\n\t\t    // determine priority\n\t\t    pri = *s - '0';\n\t\t    s++;\n\t\t}\n\t\tif (*s == '^' && *(s + 1) == '^')\n\t\t    s++;\n\n\t\tif (*s == NUL\n\t\t\t|| (*s == '^'\n\t\t\t    && (i == 0 || !(word[i - 1] == ' '\n\t\t\t\t    || spell_iswordp_w(word + i - 1, curwin)))\n\t\t\t    && (*(s + 1) != '$'\n\t\t\t\t|| (!spell_iswordp_w(word + i + k0, curwin))))\n\t\t\t|| (*s == '$' && i > 0\n\t\t\t    && spell_iswordp_w(word + i - 1, curwin)\n\t\t\t    && (!spell_iswordp_w(word + i + k0, curwin))))\n\t\t{\n\t\t    // search for followup rules, if:\n\t\t    // followup and k > 1  and  NO '-' in searchstring\n\t\t    c0 = word[i + k - 1];\n\t\t    n0 = slang->sl_sal_first[c0 & 0xff];\n\n\t\t    if (slang->sl_followup && k > 1 && n0 >= 0\n\t\t\t\t\t   && p0 != '-' && word[i + k] != NUL)\n\t\t    {\n\t\t\t// Test follow-up rule for \"word[i + k]\"; loop over\n\t\t\t// all entries with the same index byte.\n\t\t\tfor ( ; ((ws = smp[n0].sm_lead_w)[0] & 0xff)\n\t\t\t\t\t\t\t == (c0 & 0xff); ++n0)\n\t\t\t{\n\t\t\t    // Quickly skip entries that don't match the word.\n\t\t\t    if (c0 != ws[0])\n\t\t\t\tcontinue;\n\t\t\t    k0 = smp[n0].sm_leadlen;\n\t\t\t    if (k0 > 1)\n\t\t\t    {\n\t\t\t\tif (word[i + k] != ws[1])\n\t\t\t\t    continue;\n\t\t\t\tif (k0 > 2)\n\t\t\t\t{\n\t\t\t\t    pf = word + i + k + 1;\n\t\t\t\t    for (j = 2; j < k0; ++j)\n\t\t\t\t\tif (*pf++ != ws[j])\n\t\t\t\t\t    break;\n\t\t\t\t    if (j < k0)\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t    }\n\t\t\t    k0 += k - 1;\n\n\t\t\t    if ((pf = smp[n0].sm_oneof_w) != NULL)\n\t\t\t    {\n\t\t\t\t// Check for match with one of the chars in\n\t\t\t\t// \"sm_oneof\".\n\t\t\t\twhile (*pf != NUL && *pf != word[i + k0])\n\t\t\t\t    ++pf;\n\t\t\t\tif (*pf == NUL)\n\t\t\t\t    continue;\n\t\t\t\t++k0;\n\t\t\t    }\n\n\t\t\t    p0 = 5;\n\t\t\t    s = smp[n0].sm_rules;\n\t\t\t    while (*s == '-')\n\t\t\t    {\n\t\t\t\t// \"k0\" gets NOT reduced because\n\t\t\t\t// \"if (k0 == k)\"\n\t\t\t\ts++;\n\t\t\t    }\n\t\t\t    if (*s == '<')\n\t\t\t\ts++;\n\t\t\t    if (VIM_ISDIGIT(*s))\n\t\t\t    {\n\t\t\t\tp0 = *s - '0';\n\t\t\t\ts++;\n\t\t\t    }\n\n\t\t\t    if (*s == NUL\n\t\t\t\t    // *s == '^' cuts\n\t\t\t\t    || (*s == '$'\n\t\t\t\t\t && !spell_iswordp_w(word + i + k0,\n\t\t\t\t\t\t\t\t     curwin)))\n\t\t\t    {\n\t\t\t\tif (k0 == k)\n\t\t\t\t    // this is just a piece of the string\n\t\t\t\t    continue;\n\n\t\t\t\tif (p0 < pri)\n\t\t\t\t    // priority too low\n\t\t\t\t    continue;\n\t\t\t\t// rule fits; stop search\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t}\n\n\t\t\tif (p0 >= pri && (smp[n0].sm_lead_w[0] & 0xff)\n\t\t\t\t\t\t\t       == (c0 & 0xff))\n\t\t\t    continue;\n\t\t    }\n\n\t\t    // replace string\n\t\t    ws = smp[n].sm_to_w;\n\t\t    s = smp[n].sm_rules;\n\t\t    p0 = (vim_strchr(s, '<') != NULL) ? 1 : 0;\n\t\t    if (p0 == 1 && z == 0)\n\t\t    {\n\t\t\t// rule with '<' is used\n\t\t\tif (reslen > 0 && ws != NULL && *ws != NUL\n\t\t\t\t&& (wres[reslen - 1] == c\n\t\t\t\t\t\t    || wres[reslen - 1] == *ws))\n\t\t\t    reslen--;\n\t\t\tz0 = 1;\n\t\t\tz = 1;\n\t\t\tk0 = 0;\n\t\t\tif (ws != NULL)\n\t\t\t    while (*ws != NUL && word[i + k0] != NUL)\n\t\t\t    {\n\t\t\t\tword[i + k0] = *ws;\n\t\t\t\tk0++;\n\t\t\t\tws++;\n\t\t\t    }\n\t\t\tif (k > k0)\n\t\t\t    mch_memmove(word + i + k0, word + i + k,\n\t\t\t\t    sizeof(int) * (wordlen - (i + k) + 1));\n\n\t\t\t// new \"actual letter\"\n\t\t\tc = word[i];\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t// no '<' rule used\n\t\t\ti += k - 1;\n\t\t\tz = 0;\n\t\t\tif (ws != NULL)\n\t\t\t    while (*ws != NUL && ws[1] != NUL\n\t\t\t\t\t\t\t  && reslen < MAXWLEN)\n\t\t\t    {\n\t\t\t\tif (reslen == 0 || wres[reslen - 1] != *ws)\n\t\t\t\t    wres[reslen++] = *ws;\n\t\t\t\tws++;\n\t\t\t    }\n\t\t\t// new \"actual letter\"\n\t\t\tif (ws == NULL)\n\t\t\t    c = NUL;\n\t\t\telse\n\t\t\t    c = *ws;\n\t\t\tif (strstr((char *)s, \"^^\") != NULL)\n\t\t\t{\n\t\t\t    if (c != NUL)\n\t\t\t\twres[reslen++] = c;\n\t\t\t    mch_memmove(word, word + i + 1,\n\t\t\t\t       sizeof(int) * (wordlen - (i + 1) + 1));\n\t\t\t    i = 0;\n\t\t\t    z0 = 1;\n\t\t\t}\n\t\t    }\n\t\t    break;\n\t\t}\n\t    }\n\t}\n\telse if (VIM_ISWHITE(c))\n\t{\n\t    c = ' ';\n\t    k = 1;\n\t}\n\n\tif (z0 == 0)\n\t{\n\t    if (k && !p0 && reslen < MAXWLEN && c != NUL\n\t\t    && (!slang->sl_collapse || reslen == 0\n\t\t\t\t\t\t     || wres[reslen - 1] != c))\n\t\t// condense only double letters\n\t\twres[reslen++] = c;\n\n\t    i++;\n\t    z = 0;\n\t    k = 0;\n\t}\n    }\n\n    // Convert wide characters in \"wres\" to a multi-byte string in \"res\".\n    l = 0;\n    for (n = 0; n < reslen; ++n)\n    {\n\tl += mb_char2bytes(wres[n], res + l);\n\tif (l + MB_MAXBYTES > MAXWLEN)\n\t    break;\n    }\n    res[l] = NUL;\n}\n\n/*\n * \":spellinfo\"\n */\n    void\nex_spellinfo(exarg_T *eap UNUSED)\n{\n    int\t\tlpi;\n    langp_T\t*lp;\n    char_u\t*p;\n\n    if (no_spell_checking(curwin))\n\treturn;\n\n    msg_start();\n    for (lpi = 0; lpi < curwin->w_s->b_langp.ga_len && !got_int; ++lpi)\n    {\n\tlp = LANGP_ENTRY(curwin->w_s->b_langp, lpi);\n\tmsg_puts(\"file: \");\n\tmsg_puts((char *)lp->lp_slang->sl_fname);\n\tmsg_putchar('\\n');\n\tp = lp->lp_slang->sl_info;\n\tif (p != NULL)\n\t{\n\t    msg_puts((char *)p);\n\t    msg_putchar('\\n');\n\t}\n    }\n    msg_end();\n}\n\n#define DUMPFLAG_KEEPCASE   1\t// round 2: keep-case tree\n#define DUMPFLAG_COUNT\t    2\t// include word count\n#define DUMPFLAG_ICASE\t    4\t// ignore case when finding matches\n#define DUMPFLAG_ONECAP\t    8\t// pattern starts with capital\n#define DUMPFLAG_ALLCAP\t    16\t// pattern is all capitals\n\n/*\n * \":spelldump\"\n */\n    void\nex_spelldump(exarg_T *eap)\n{\n    char_u  *spl;\n    long    dummy;\n\n    if (no_spell_checking(curwin))\n\treturn;\n    (void)get_option_value((char_u*)\"spl\", &dummy, &spl, NULL, OPT_LOCAL);\n\n    // Create a new empty buffer in a new window.\n    do_cmdline_cmd((char_u *)\"new\");\n\n    // enable spelling locally in the new window\n    set_option_value_give_err((char_u*)\"spell\", TRUE, (char_u*)\"\", OPT_LOCAL);\n    set_option_value_give_err((char_u*)\"spl\",  dummy, spl, OPT_LOCAL);\n    vim_free(spl);\n\n    if (!BUFEMPTY())\n\treturn;\n\n    spell_dump_compl(NULL, 0, NULL, eap->forceit ? DUMPFLAG_COUNT : 0);\n\n    // Delete the empty line that we started with.\n    if (curbuf->b_ml.ml_line_count > 1)\n\tml_delete(curbuf->b_ml.ml_line_count);\n\n    redraw_later(UPD_NOT_VALID);\n}\n\n/*\n * Go through all possible words and:\n * 1. When \"pat\" is NULL: dump a list of all words in the current buffer.\n *\t\"ic\" and \"dir\" are not used.\n * 2. When \"pat\" is not NULL: add matching words to insert mode completion.\n */\n    void\nspell_dump_compl(\n    char_u\t*pat,\t    // leading part of the word\n    int\t\tic,\t    // ignore case\n    int\t\t*dir,\t    // direction for adding matches\n    int\t\tdumpflags_arg)\t// DUMPFLAG_*\n{\n    langp_T\t*lp;\n    slang_T\t*slang;\n    idx_T\tarridx[MAXWLEN];\n    int\t\tcuri[MAXWLEN];\n    char_u\tword[MAXWLEN];\n    int\t\tc;\n    char_u\t*byts;\n    idx_T\t*idxs;\n    linenr_T\tlnum = 0;\n    int\t\tround;\n    int\t\tdepth;\n    int\t\tn;\n    int\t\tflags;\n    char_u\t*region_names = NULL;\t    // region names being used\n    int\t\tdo_region = TRUE;\t    // dump region names and numbers\n    char_u\t*p;\n    int\t\tlpi;\n    int\t\tdumpflags = dumpflags_arg;\n    int\t\tpatlen;\n\n    // When ignoring case or when the pattern starts with capital pass this on\n    // to dump_word().\n    if (pat != NULL)\n    {\n\tif (ic)\n\t    dumpflags |= DUMPFLAG_ICASE;\n\telse\n\t{\n\t    n = captype(pat, NULL);\n\t    if (n == WF_ONECAP)\n\t\tdumpflags |= DUMPFLAG_ONECAP;\n\t    else if (n == WF_ALLCAP && (int)STRLEN(pat) > mb_ptr2len(pat))\n\t\tdumpflags |= DUMPFLAG_ALLCAP;\n\t}\n    }\n\n    // Find out if we can support regions: All languages must support the same\n    // regions or none at all.\n    for (lpi = 0; lpi < curwin->w_s->b_langp.ga_len; ++lpi)\n    {\n\tlp = LANGP_ENTRY(curwin->w_s->b_langp, lpi);\n\tp = lp->lp_slang->sl_regions;\n\tif (p[0] != 0)\n\t{\n\t    if (region_names == NULL)\t    // first language with regions\n\t\tregion_names = p;\n\t    else if (STRCMP(region_names, p) != 0)\n\t    {\n\t\tdo_region = FALSE;\t    // region names are different\n\t\tbreak;\n\t    }\n\t}\n    }\n\n    if (do_region && region_names != NULL)\n    {\n\tif (pat == NULL)\n\t{\n\t    vim_snprintf((char *)IObuff, IOSIZE, \"/regions=%s\", region_names);\n\t    ml_append(lnum++, IObuff, (colnr_T)0, FALSE);\n\t}\n    }\n    else\n\tdo_region = FALSE;\n\n    /*\n     * Loop over all files loaded for the entries in 'spelllang'.\n     */\n    for (lpi = 0; lpi < curwin->w_s->b_langp.ga_len; ++lpi)\n    {\n\tlp = LANGP_ENTRY(curwin->w_s->b_langp, lpi);\n\tslang = lp->lp_slang;\n\tif (slang->sl_fbyts == NULL)\t    // reloading failed\n\t    continue;\n\n\tif (pat == NULL)\n\t{\n\t    vim_snprintf((char *)IObuff, IOSIZE, \"# file: %s\", slang->sl_fname);\n\t    ml_append(lnum++, IObuff, (colnr_T)0, FALSE);\n\t}\n\n\t// When matching with a pattern and there are no prefixes only use\n\t// parts of the tree that match \"pat\".\n\tif (pat != NULL && slang->sl_pbyts == NULL)\n\t    patlen = (int)STRLEN(pat);\n\telse\n\t    patlen = -1;\n\n\t// round 1: case-folded tree\n\t// round 2: keep-case tree\n\tfor (round = 1; round <= 2; ++round)\n\t{\n\t    if (round == 1)\n\t    {\n\t\tdumpflags &= ~DUMPFLAG_KEEPCASE;\n\t\tbyts = slang->sl_fbyts;\n\t\tidxs = slang->sl_fidxs;\n\t    }\n\t    else\n\t    {\n\t\tdumpflags |= DUMPFLAG_KEEPCASE;\n\t\tbyts = slang->sl_kbyts;\n\t\tidxs = slang->sl_kidxs;\n\t    }\n\t    if (byts == NULL)\n\t\tcontinue;\t\t// array is empty\n\n\t    depth = 0;\n\t    arridx[0] = 0;\n\t    curi[0] = 1;\n\t    while (depth >= 0 && !got_int\n\t\t\t\t  && (pat == NULL || !ins_compl_interrupted()))\n\t    {\n\t\tif (curi[depth] > byts[arridx[depth]])\n\t\t{\n\t\t    // Done all bytes at this node, go up one level.\n\t\t    --depth;\n\t\t    line_breakcheck();\n\t\t    ins_compl_check_keys(50, FALSE);\n\t\t}\n\t\telse\n\t\t{\n\t\t    // Do one more byte at this node.\n\t\t    n = arridx[depth] + curi[depth];\n\t\t    ++curi[depth];\n\t\t    c = byts[n];\n\t\t    if (c == 0 || depth >= MAXWLEN - 1)\n\t\t    {\n\t\t\t// End of word or reached maximum length, deal with the\n\t\t\t// word.\n\t\t\t// Don't use keep-case words in the fold-case tree,\n\t\t\t// they will appear in the keep-case tree.\n\t\t\t// Only use the word when the region matches.\n\t\t\tflags = (int)idxs[n];\n\t\t\tif ((round == 2 || (flags & WF_KEEPCAP) == 0)\n\t\t\t\t&& (flags & WF_NEEDCOMP) == 0\n\t\t\t\t&& (do_region\n\t\t\t\t    || (flags & WF_REGION) == 0\n\t\t\t\t    || (((unsigned)flags >> 16)\n\t\t\t\t\t\t       & lp->lp_region) != 0))\n\t\t\t{\n\t\t\t    word[depth] = NUL;\n\t\t\t    if (!do_region)\n\t\t\t\tflags &= ~WF_REGION;\n\n\t\t\t    // Dump the basic word if there is no prefix or\n\t\t\t    // when it's the first one.\n\t\t\t    c = (unsigned)flags >> 24;\n\t\t\t    if (c == 0 || curi[depth] == 2)\n\t\t\t    {\n\t\t\t\tdump_word(slang, word, pat, dir,\n\t\t\t\t\t\t      dumpflags, flags, lnum);\n\t\t\t\tif (pat == NULL)\n\t\t\t\t    ++lnum;\n\t\t\t    }\n\n\t\t\t    // Apply the prefix, if there is one.\n\t\t\t    if (c != 0)\n\t\t\t\tlnum = dump_prefixes(slang, word, pat, dir,\n\t\t\t\t\t\t      dumpflags, flags, lnum);\n\t\t\t}\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t// Normal char, go one level deeper.\n\t\t\tword[depth++] = c;\n\t\t\tarridx[depth] = idxs[n];\n\t\t\tcuri[depth] = 1;\n\n\t\t\t// Check if this character matches with the pattern.\n\t\t\t// If not skip the whole tree below it.\n\t\t\t// Always ignore case here, dump_word() will check\n\t\t\t// proper case later.  This isn't exactly right when\n\t\t\t// length changes for multi-byte characters with\n\t\t\t// ignore case...\n\t\t\tif (depth <= patlen\n\t\t\t\t\t&& MB_STRNICMP(word, pat, depth) != 0)\n\t\t\t    --depth;\n\t\t    }\n\t\t}\n\t    }\n\t}\n    }\n}\n\n/*\n * Dump one word: apply case modifications and append a line to the buffer.\n * When \"lnum\" is zero add insert mode completion.\n */\n    static void\ndump_word(\n    slang_T\t*slang,\n    char_u\t*word,\n    char_u\t*pat,\n    int\t\t*dir,\n    int\t\tdumpflags,\n    int\t\twordflags,\n    linenr_T\tlnum)\n{\n    int\t\tkeepcap = FALSE;\n    char_u\t*p;\n    char_u\t*tw;\n    char_u\tcword[MAXWLEN];\n    char_u\tbadword[MAXWLEN + 10];\n    int\t\ti;\n    int\t\tflags = wordflags;\n\n    if (dumpflags & DUMPFLAG_ONECAP)\n\tflags |= WF_ONECAP;\n    if (dumpflags & DUMPFLAG_ALLCAP)\n\tflags |= WF_ALLCAP;\n\n    if ((dumpflags & DUMPFLAG_KEEPCASE) == 0 && (flags & WF_CAPMASK) != 0)\n    {\n\t// Need to fix case according to \"flags\".\n\tmake_case_word(word, cword, flags);\n\tp = cword;\n    }\n    else\n    {\n\tp = word;\n\tif ((dumpflags & DUMPFLAG_KEEPCASE)\n\t\t&& ((captype(word, NULL) & WF_KEEPCAP) == 0\n\t\t\t\t\t\t || (flags & WF_FIXCAP) != 0))\n\t    keepcap = TRUE;\n    }\n    tw = p;\n\n    if (pat == NULL)\n    {\n\t// Add flags and regions after a slash.\n\tif ((flags & (WF_BANNED | WF_RARE | WF_REGION)) || keepcap)\n\t{\n\t    STRCPY(badword, p);\n\t    STRCAT(badword, \"/\");\n\t    if (keepcap)\n\t\tSTRCAT(badword, \"=\");\n\t    if (flags & WF_BANNED)\n\t\tSTRCAT(badword, \"!\");\n\t    else if (flags & WF_RARE)\n\t\tSTRCAT(badword, \"?\");\n\t    if (flags & WF_REGION)\n\t\tfor (i = 0; i < 7; ++i)\n\t\t    if (flags & (0x10000 << i))\n\t\t\tsprintf((char *)badword + STRLEN(badword), \"%d\", i + 1);\n\t    p = badword;\n\t}\n\n\tif (dumpflags & DUMPFLAG_COUNT)\n\t{\n\t    hashitem_T  *hi;\n\n\t    // Include the word count for \":spelldump!\".\n\t    hi = hash_find(&slang->sl_wordcount, tw);\n\t    if (!HASHITEM_EMPTY(hi))\n\t    {\n\t\tvim_snprintf((char *)IObuff, IOSIZE, \"%s\\t%d\",\n\t\t\t\t\t\t     tw, HI2WC(hi)->wc_count);\n\t\tp = IObuff;\n\t    }\n\t}\n\n\tml_append(lnum, p, (colnr_T)0, FALSE);\n    }\n    else if (((dumpflags & DUMPFLAG_ICASE)\n\t\t    ? MB_STRNICMP(p, pat, STRLEN(pat)) == 0\n\t\t    : STRNCMP(p, pat, STRLEN(pat)) == 0)\n\t\t&& ins_compl_add_infercase(p, (int)STRLEN(p),\n\t\t\t\t\t  p_ic, NULL, *dir, FALSE) == OK)\n\t// if dir was BACKWARD then honor it just once\n\t*dir = FORWARD;\n}\n\n/*\n * For \":spelldump\": Find matching prefixes for \"word\".  Prepend each to\n * \"word\" and append a line to the buffer.\n * When \"lnum\" is zero add insert mode completion.\n * Return the updated line number.\n */\n    static linenr_T\ndump_prefixes(\n    slang_T\t*slang,\n    char_u\t*word,\t    // case-folded word\n    char_u\t*pat,\n    int\t\t*dir,\n    int\t\tdumpflags,\n    int\t\tflags,\t    // flags with prefix ID\n    linenr_T\tstartlnum)\n{\n    idx_T\tarridx[MAXWLEN];\n    int\t\tcuri[MAXWLEN];\n    char_u\tprefix[MAXWLEN];\n    char_u\tword_up[MAXWLEN];\n    int\t\thas_word_up = FALSE;\n    int\t\tc;\n    char_u\t*byts;\n    idx_T\t*idxs;\n    linenr_T\tlnum = startlnum;\n    int\t\tdepth;\n    int\t\tn;\n    int\t\tlen;\n    int\t\ti;\n\n    // If the word starts with a lower-case letter make the word with an\n    // upper-case letter in word_up[].\n    c = PTR2CHAR(word);\n    if (SPELL_TOUPPER(c) != c)\n    {\n\tonecap_copy(word, word_up, TRUE);\n\thas_word_up = TRUE;\n    }\n\n    byts = slang->sl_pbyts;\n    idxs = slang->sl_pidxs;\n    if (byts != NULL)\t\t// array not is empty\n    {\n\t/*\n\t * Loop over all prefixes, building them byte-by-byte in prefix[].\n\t * When at the end of a prefix check that it supports \"flags\".\n\t */\n\tdepth = 0;\n\tarridx[0] = 0;\n\tcuri[0] = 1;\n\twhile (depth >= 0 && !got_int)\n\t{\n\t    n = arridx[depth];\n\t    len = byts[n];\n\t    if (curi[depth] > len)\n\t    {\n\t\t// Done all bytes at this node, go up one level.\n\t\t--depth;\n\t\tline_breakcheck();\n\t    }\n\t    else\n\t    {\n\t\t// Do one more byte at this node.\n\t\tn += curi[depth];\n\t\t++curi[depth];\n\t\tc = byts[n];\n\t\tif (c == 0)\n\t\t{\n\t\t    // End of prefix, find out how many IDs there are.\n\t\t    for (i = 1; i < len; ++i)\n\t\t\tif (byts[n + i] != 0)\n\t\t\t    break;\n\t\t    curi[depth] += i - 1;\n\n\t\t    c = valid_word_prefix(i, n, flags, word, slang, FALSE);\n\t\t    if (c != 0)\n\t\t    {\n\t\t\tvim_strncpy(prefix + depth, word, MAXWLEN - depth - 1);\n\t\t\tdump_word(slang, prefix, pat, dir, dumpflags,\n\t\t\t\t(c & WF_RAREPFX) ? (flags | WF_RARE)\n\t\t\t\t\t\t\t       : flags, lnum);\n\t\t\tif (lnum != 0)\n\t\t\t    ++lnum;\n\t\t    }\n\n\t\t    // Check for prefix that matches the word when the\n\t\t    // first letter is upper-case, but only if the prefix has\n\t\t    // a condition.\n\t\t    if (has_word_up)\n\t\t    {\n\t\t\tc = valid_word_prefix(i, n, flags, word_up, slang,\n\t\t\t\t\t\t\t\t\tTRUE);\n\t\t\tif (c != 0)\n\t\t\t{\n\t\t\t    vim_strncpy(prefix + depth, word_up,\n\t\t\t\t\t\t\t MAXWLEN - depth - 1);\n\t\t\t    dump_word(slang, prefix, pat, dir, dumpflags,\n\t\t\t\t    (c & WF_RAREPFX) ? (flags | WF_RARE)\n\t\t\t\t\t\t\t       : flags, lnum);\n\t\t\t    if (lnum != 0)\n\t\t\t\t++lnum;\n\t\t\t}\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    // Normal char, go one level deeper.\n\t\t    prefix[depth++] = c;\n\t\t    arridx[depth] = idxs[n];\n\t\t    curi[depth] = 1;\n\t\t}\n\t    }\n\t}\n    }\n\n    return lnum;\n}\n\n/*\n * Move \"p\" to the end of word \"start\".\n * Uses the spell-checking word characters.\n */\n    char_u *\nspell_to_word_end(char_u *start, win_T *win)\n{\n    char_u  *p = start;\n\n    while (*p != NUL && spell_iswordp(p, win))\n\tMB_PTR_ADV(p);\n    return p;\n}\n\n/*\n * For Insert mode completion CTRL-X s:\n * Find start of the word in front of column \"startcol\".\n * We don't check if it is badly spelled, with completion we can only change\n * the word in front of the cursor.\n * Returns the column number of the word.\n */\n    int\nspell_word_start(int startcol)\n{\n    char_u\t*line;\n    char_u\t*p;\n    int\t\tcol = 0;\n\n    if (no_spell_checking(curwin))\n\treturn startcol;\n\n    // Find a word character before \"startcol\".\n    line = ml_get_curline();\n    for (p = line + startcol; p > line; )\n    {\n\tMB_PTR_BACK(line, p);\n\tif (spell_iswordp_nmw(p, curwin))\n\t    break;\n    }\n\n    // Go back to start of the word.\n    while (p > line)\n    {\n\tcol = (int)(p - line);\n\tMB_PTR_BACK(line, p);\n\tif (!spell_iswordp(p, curwin))\n\t    break;\n\tcol = 0;\n    }\n\n    return col;\n}\n\n/*\n * Need to check for 'spellcapcheck' now, the word is removed before\n * expand_spelling() is called.  Therefore the ugly global variable.\n */\nstatic int spell_expand_need_cap;\n\n    void\nspell_expand_check_cap(colnr_T col)\n{\n    spell_expand_need_cap = check_need_cap(curwin->w_cursor.lnum, col);\n}\n\n/*\n * Get list of spelling suggestions.\n * Used for Insert mode completion CTRL-X ?.\n * Returns the number of matches.  The matches are in \"matchp[]\", array of\n * allocated strings.\n */\n    int\nexpand_spelling(\n    linenr_T\tlnum UNUSED,\n    char_u\t*pat,\n    char_u\t***matchp)\n{\n    garray_T\tga;\n\n    spell_suggest_list(&ga, pat, 100, spell_expand_need_cap, TRUE);\n    *matchp = ga.ga_data;\n    return ga.ga_len;\n}\n\n/*\n * Return TRUE if \"val\" is a valid 'spelllang' value.\n */\n    int\nvalid_spelllang(char_u *val)\n{\n    return valid_name(val, \".-_,@\");\n}\n\n/*\n * Return TRUE if \"val\" is a valid 'spellfile' value.\n */\n    int\nvalid_spellfile(char_u *val)\n{\n    char_u *s;\n\n    for (s = val; *s != NUL; ++s)\n\tif (!vim_is_fname_char(*s))\n\t    return FALSE;\n    return TRUE;\n}\n\n/*\n * Handle side effects of setting 'spell'.\n * Return an error message or NULL for success.\n */\n    char *\ndid_set_spell_option(int is_spellfile)\n{\n    char    *errmsg = NULL;\n    win_T   *wp;\n    int\t    l;\n\n    if (is_spellfile)\n    {\n\tl = (int)STRLEN(curwin->w_s->b_p_spf);\n\tif (l > 0 && (l < 4\n\t\t\t|| STRCMP(curwin->w_s->b_p_spf + l - 4, \".add\") != 0))\n\t    errmsg = e_invalid_argument;\n    }\n\n    if (errmsg == NULL)\n    {\n\tFOR_ALL_WINDOWS(wp)\n\t    if (wp->w_buffer == curbuf && wp->w_p_spell)\n\t    {\n\t\terrmsg = did_set_spelllang(wp);\n\t\tbreak;\n\t    }\n    }\n    return errmsg;\n}\n\n/*\n * Set curbuf->b_cap_prog to the regexp program for 'spellcapcheck'.\n * Return error message when failed, NULL when OK.\n */\n    char *\ncompile_cap_prog(synblock_T *synblock)\n{\n    regprog_T   *rp = synblock->b_cap_prog;\n    char_u\t*re;\n\n    if (synblock->b_p_spc == NULL || *synblock->b_p_spc == NUL)\n\tsynblock->b_cap_prog = NULL;\n    else\n    {\n\t// Prepend a ^ so that we only match at one column\n\tre = concat_str((char_u *)\"^\", synblock->b_p_spc);\n\tif (re != NULL)\n\t{\n\t    synblock->b_cap_prog = vim_regcomp(re, RE_MAGIC);\n\t    vim_free(re);\n\t    if (synblock->b_cap_prog == NULL)\n\t    {\n\t\tsynblock->b_cap_prog = rp; // restore the previous program\n\t\treturn e_invalid_argument;\n\t    }\n\t}\n    }\n\n    vim_regfree(rp);\n    return NULL;\n}\n\n#endif  // FEAT_SPELL\n", "\" Test spell checking\n\" Note: this file uses latin1 encoding, but is used with utf-8 encoding.\n\nsource check.vim\nCheckFeature spell\n\nsource screendump.vim\n\nfunc TearDown()\n  set nospell\n  call delete('Xtest.aff')\n  call delete('Xtest.dic')\n  call delete('Xtest.latin1.add')\n  call delete('Xtest.latin1.add.spl')\n  call delete('Xtest.latin1.spl')\n  call delete('Xtest.latin1.sug')\n  \" set 'encoding' to clear the word list\n  set encoding=utf-8\nendfunc\n\nfunc Test_wrap_search()\n  new\n  call setline(1, ['The', '', 'A plong line with two zpelling mistakes', '', 'End'])\n  set spell wrapscan\n  normal ]s\n  call assert_equal('plong', expand('<cword>'))\n  normal ]s\n  call assert_equal('zpelling', expand('<cword>'))\n  normal ]s\n  call assert_equal('plong', expand('<cword>'))\n  bwipe!\n  set nospell\nendfunc\n\nfunc Test_curswant()\n  new\n  call setline(1, ['Another plong line', 'abcdefghijklmnopq'])\n  set spell wrapscan\n  normal 0]s\n  call assert_equal('plong', expand('<cword>'))\n  normal j\n  call assert_equal(9, getcurpos()[2])\n  normal 0[s\n  call assert_equal('plong', expand('<cword>'))\n  normal j\n  call assert_equal(9, getcurpos()[2])\n\n  normal 0]S\n  call assert_equal('plong', expand('<cword>'))\n  normal j\n  call assert_equal(9, getcurpos()[2])\n  normal 0[S\n  call assert_equal('plong', expand('<cword>'))\n  normal j\n  call assert_equal(9, getcurpos()[2])\n\n  normal 1G0\n  call assert_equal('plong', spellbadword()[0])\n  normal j\n  call assert_equal(9, getcurpos()[2])\n\n  bwipe!\n  set nospell\nendfunc\n\nfunc Test_z_equal_on_invalid_utf8_word()\n  split\n  set spell\n  call setline(1, \"\\xff\")\n  norm z=\n  set nospell\n  bwipe!\nendfunc\n\nfunc Test_z_equal_on_single_character()\n  \" this was decrementing the index below zero\n  new\n  norm a0\\\u0118\n  norm zW\n  norm \u0016z=\n\n  bwipe!\nendfunc\n\n\" Test spellbadword() with argument\nfunc Test_spellbadword()\n  set spell\n\n  call assert_equal(['bycycle', 'bad'],  spellbadword('My bycycle.'))\n  call assert_equal(['another', 'caps'], 'A sentence. another sentence'->spellbadword())\n\n  call assert_equal(['TheCamelWord', 'bad'], 'TheCamelWord asdf'->spellbadword())\n  set spelloptions=camel\n  call assert_equal(['asdf', 'bad'], 'TheCamelWord asdf'->spellbadword())\n  set spelloptions=\n\n  set spelllang=en\n  call assert_equal(['', ''],            spellbadword('centre'))\n  call assert_equal(['', ''],            spellbadword('center'))\n  set spelllang=en_us\n  call assert_equal(['centre', 'local'], spellbadword('centre'))\n  call assert_equal(['', ''],            spellbadword('center'))\n  set spelllang=en_gb\n  call assert_equal(['', ''],            spellbadword('centre'))\n  call assert_equal(['center', 'local'], spellbadword('center'))\n\n  \" Create a small word list to test that spellbadword('...')\n  \" can return ['...', 'rare'].\n  e Xwords\n  insert\nfoo\nfoobar/?\n.\n   w!\n   mkspell! Xwords.spl Xwords\n   set spelllang=Xwords.spl\n   call assert_equal(['foobar', 'rare'], spellbadword('foo foobar'))\n\n  \" Typo should be detected even without the 'spell' option.\n  set spelllang=en_gb nospell\n  call assert_equal(['', ''], spellbadword('centre'))\n  call assert_equal(['bycycle', 'bad'], spellbadword('My bycycle.'))\n  call assert_equal(['another', 'caps'], spellbadword('A sentence. another sentence'))\n\n  set spelllang=\n  call assert_fails(\"call spellbadword('maxch')\", 'E756:')\n  call assert_fails(\"spelldump\", 'E756:')\n\n  call delete('Xwords.spl')\n  call delete('Xwords')\n  set spelllang&\n  set spell&\nendfunc\n\nfunc Test_spell_file_missing()\n  let s:spell_file_missing = 0\n  augroup TestSpellFileMissing\n    autocmd! SpellFileMissing * let s:spell_file_missing += 1\n  augroup END\n\n  set spell spelllang=ab_cd\n  let messages = GetMessages()\n  call assert_equal('Warning: Cannot find word list \"ab.utf-8.spl\" or \"ab.ascii.spl\"', messages[-1])\n  call assert_equal(1, s:spell_file_missing)\n\n  new XTestSpellFileMissing\n  augroup TestSpellFileMissing\n    autocmd! SpellFileMissing * bwipe\n  augroup END\n  call assert_fails('set spell spelllang=ab_cd', 'E937:')\n\n  \" clean up\n  augroup TestSpellFileMissing\n    autocmd! SpellFileMissing\n  augroup END\n  augroup! TestSpellFileMissing\n  unlet s:spell_file_missing\n  set spell& spelllang&\n  %bwipe!\nendfunc\n\nfunc Test_spell_file_missing_bwipe()\n  \" this was using a window that was wiped out in a SpellFileMissing autocmd\n  set spelllang=xy\n  au SpellFileMissing * n0\n  set spell\n  au SpellFileMissing * bw\n  snext somefile\n\n  au! SpellFileMissing\n  bwipe!\n  set nospell spelllang=en\nendfunc\n\nfunc Test_spelldump()\n  \" In case the spell file is not found avoid getting the download dialog, we\n  \" would get stuck at the prompt.\n  let g:en_not_found = 0\n  augroup TestSpellFileMissing\n    au! SpellFileMissing * let g:en_not_found = 1\n  augroup END\n  set spell spelllang=en\n  spellrare! emacs\n  if g:en_not_found\n    call assert_report(\"Could not find English spell file\")\n  else\n    spelldump\n\n    \" Check assumption about region: 1: us, 2: au, 3: ca, 4: gb, 5: nz.\n    call assert_equal('/regions=usaucagbnz', getline(1))\n    call assert_notequal(0, search('^theater/1$'))    \" US English only.\n    call assert_notequal(0, search('^theatre/2345$')) \" AU, CA, GB or NZ English.\n\n    call assert_notequal(0, search('^emacs/?$'))      \" ? for a rare word.\n    call assert_notequal(0, search('^the the/!$'))    \" ! for a wrong word.\n  endif\n\n  \" clean up\n  unlet g:en_not_found\n  augroup TestSpellFileMissing\n    autocmd! SpellFileMissing\n  augroup END\n  augroup! TestSpellFileMissing\n  bwipe\n  set spell&\nendfunc\n\nfunc Test_spelldump_bang()\n  new\n  call setline(1, 'This is a sample sentence.')\n  redraw\n\n  \" In case the spell file is not found avoid getting the download dialog, we\n  \" would get stuck at the prompt.\n  let g:en_not_found = 0\n  augroup TestSpellFileMissing\n    au! SpellFileMissing * let g:en_not_found = 1\n  augroup END\n\n  set spell\n\n  if g:en_not_found\n    call assert_report(\"Could not find English spell file\")\n  else\n    redraw\n    spelldump!\n\n    \" :spelldump! includes the number of times a word was found while updating\n    \" the screen.\n    \" Common word count starts at 10, regular word count starts at 0.\n    call assert_notequal(0, search(\"^is\\t11$\"))    \" common word found once.\n    call assert_notequal(0, search(\"^the\\t10$\"))   \" common word never found.\n    call assert_notequal(0, search(\"^sample\\t1$\")) \" regular word found once.\n    call assert_equal(0, search(\"^screen\\t\"))      \" regular word never found.\n  endif\n\n  \" clean up\n  unlet g:en_not_found\n  augroup TestSpellFileMissing\n    autocmd! SpellFileMissing\n  augroup END\n  augroup! TestSpellFileMissing\n  %bwipe!\n  set spell&\nendfunc\n\nfunc Test_spelllang_inv_region()\n  set spell spelllang=en_xx\n  let messages = GetMessages()\n  call assert_equal('Warning: region xx not supported', messages[-1])\n  set spell& spelllang&\nendfunc\n\nfunc Test_compl_with_CTRL_X_CTRL_K_using_spell()\n  \" When spell checking is enabled and 'dictionary' is empty,\n  \" CTRL-X CTRL-K in insert mode completes using the spelling dictionary.\n  new\n  set spell spelllang=en dictionary=\n\n  set ignorecase\n  call feedkeys(\"Senglis\\<c-x>\\<c-k>\\<esc>\", 'tnx')\n  call assert_equal(['English'], getline(1, '$'))\n  call feedkeys(\"SEnglis\\<c-x>\\<c-k>\\<esc>\", 'tnx')\n  call assert_equal(['English'], getline(1, '$'))\n\n  set noignorecase\n  call feedkeys(\"Senglis\\<c-x>\\<c-k>\\<esc>\", 'tnx')\n  call assert_equal(['englis'], getline(1, '$'))\n  call feedkeys(\"SEnglis\\<c-x>\\<c-k>\\<esc>\", 'tnx')\n  call assert_equal(['English'], getline(1, '$'))\n\n  set spelllang=en_us\n  call feedkeys(\"Stheat\\<c-x>\\<c-k>\\<esc>\", 'tnx')\n  call assert_equal(['theater'], getline(1, '$'))\n  set spelllang=en_gb\n  call feedkeys(\"Stheat\\<c-x>\\<c-k>\\<esc>\", 'tnx')\n  \" FIXME: commented out, expected theatre bug got theater. See issue #7025.\n  \" call assert_equal(['theatre'], getline(1, '$'))\n\n  bwipe!\n  set spell& spelllang& dictionary& ignorecase&\nendfunc\n\nfunc Test_spellreall()\n  new\n  set spell\n  call assert_fails('spellrepall', 'E752:')\n  call setline(1, ['A speling mistake. The same speling mistake.',\n        \\                'Another speling mistake.'])\n  call feedkeys(']s1z=', 'tx')\n  call assert_equal('A spelling mistake. The same speling mistake.', getline(1))\n  call assert_equal('Another speling mistake.', getline(2))\n  spellrepall\n  call assert_equal('A spelling mistake. The same spelling mistake.', getline(1))\n  call assert_equal('Another spelling mistake.', getline(2))\n  call assert_fails('spellrepall', 'E753:')\n  set spell&\n  bwipe!\nendfunc\n\nfunc Test_spell_dump_word_length()\n  \" this was running over MAXWLEN\n  new\n  noremap 0 0a0zW0000000\n  sil! norm \u00160z=0\u0018\u000b\n  sil norm 0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n  sil! norm \u00160z=0\u0018\u000b\n\n  bwipe!\n  nunmap 0\nendfunc\n\n\" Test spellsuggest({word} [, {max} [, {capital}]])\nfunc Test_spellsuggest()\n  \" Verify suggestions are given even when spell checking is not enabled.\n  set nospell\n  call assert_equal(['march', 'March'], spellsuggest('marrch', 2))\n\n  set spell\n\n  \" With 1 argument.\n  call assert_equal(['march', 'March'], spellsuggest('marrch')[0:1])\n\n  \" With 2 arguments.\n  call assert_equal(['march', 'March'], spellsuggest('marrch', 2))\n\n  \" With 3 arguments.\n  call assert_equal(['march'], spellsuggest('marrch', 1, 0))\n  call assert_equal(['March'], spellsuggest('marrch', 1, 1))\n\n  \" Test with digits and hyphen.\n  call assert_equal('Carbon-14', spellsuggest('Carbon-15')[0])\n\n  \" Comment taken from spellsuggest.c explains the following test cases:\n  \"\n  \" If there are more UPPER than lower case letters suggest an\n  \" ALLCAP word.  Otherwise, if the first letter is UPPER then\n  \" suggest ONECAP.  Exception: \"ALl\" most likely should be \"All\",\n  \" require three upper case letters.\n  call assert_equal(['THIRD', 'third'], spellsuggest('thIRD', 2))\n  call assert_equal(['third', 'THIRD'], spellsuggest('tHIrd', 2))\n  call assert_equal(['Third'], spellsuggest('THird', 1))\n  call assert_equal(['All'],      spellsuggest('ALl', 1))\n\n  \" Special suggestion for repeated 'the the'.\n  call assert_inrange(0, 2, index(spellsuggest('the the',   3), 'the'))\n  call assert_inrange(0, 2, index(spellsuggest('the   the', 3), 'the'))\n  call assert_inrange(0, 2, index(spellsuggest('The the',   3), 'The'))\n\n  call assert_fails(\"call spellsuggest('maxch', [])\", 'E745:')\n  call assert_fails(\"call spellsuggest('maxch', 2, [])\", 'E745:')\n\n  set spelllang=\n  call assert_fails(\"call spellsuggest('maxch')\", 'E756:')\n  set spelllang&\n\n  set spell&\nendfunc\n\n\" Test 'spellsuggest' option with methods fast, best and double.\nfunc Test_spellsuggest_option_methods()\n  set spell\n\n  for e in ['latin1', 'utf-8']\n    exe 'set encoding=' .. e\n\n    set spellsuggest=fast\n    call assert_equal(['Stick', 'Stitch'], spellsuggest('Stich', 2), e)\n\n    \" With best or double option, \"Stitch\" should become the top suggestion\n    \" because of better phonetic matching.\n    set spellsuggest=best\n    call assert_equal(['Stitch', 'Stick'], spellsuggest('Stich', 2), e)\n\n    set spellsuggest=double\n    call assert_equal(['Stitch', 'Stick'], spellsuggest('Stich', 2), e)\n  endfor\n\n  set spell& spellsuggest& encoding&\nendfunc\n\n\" Test 'spellsuggest' option with value file:{filename}\nfunc Test_spellsuggest_option_file()\n  set spell spellsuggest=file:Xspellsuggest\n  call writefile(['emacs/vim',\n        \\         'theribal/terrible',\n        \\         'teribal/terrrible',\n        \\         'terribal'],\n        \\         'Xspellsuggest')\n\n  call assert_equal(['vim'],      spellsuggest('emacs', 2))\n  call assert_equal(['terrible'], spellsuggest('theribal',2))\n\n  \" If the suggestion is misspelled (*terrrible* with 3 r),\n  \" it should not be proposed.\n  \" The entry for \"terribal\" should be ignored because of missing slash.\n  call assert_equal([], spellsuggest('teribal', 2))\n  call assert_equal([], spellsuggest('terribal', 2))\n\n  set spell spellsuggest=best,file:Xspellsuggest\n  call assert_equal(['vim', 'Emacs'],       spellsuggest('emacs', 2))\n  call assert_equal(['terrible', 'tribal'], spellsuggest('theribal', 2))\n  call assert_equal(['tribal'],             spellsuggest('teribal', 1))\n  call assert_equal(['tribal'],             spellsuggest('terribal', 1))\n\n  call delete('Xspellsuggest')\n  call assert_fails(\"call spellsuggest('vim')\", \"E484: Can't open file Xspellsuggest\")\n\n  set spellsuggest& spell&\nendfunc\n\n\" Test 'spellsuggest' option with value {number}\n\" to limit the number of suggestions\nfunc Test_spellsuggest_option_number()\n  set spell spellsuggest=2,best\n  new\n\n  \" We limited the number of suggestions to 2, so selecting\n  \" the 1st and 2nd suggestion should correct the word, but\n  \" selecting a 3rd suggestion should do nothing.\n  call setline(1, 'A baord')\n  norm $1z=\n  call assert_equal('A board', getline(1))\n\n  call setline(1, 'A baord')\n  norm $2z=\n  call assert_equal('A bard', getline(1))\n\n  call setline(1, 'A baord')\n  norm $3z=\n  call assert_equal('A baord', getline(1))\n\n  let a = execute('norm $z=')\n  call assert_equal(\n  \\    \"\\n\"\n  \\ .. \"Change \\\"baord\\\" to:\\n\"\n  \\ .. \" 1 \\\"board\\\"\\n\"\n  \\ .. \" 2 \\\"bard\\\"\\n\"\n  \\ .. \"Type number and <Enter> or click with the mouse (q or empty cancels): \", a)\n\n  set spell spellsuggest=0\n  call assert_equal(\"\\nSorry, no suggestions\", execute('norm $z='))\n\n  \" Unlike z=, function spellsuggest(...) should not be affected by the\n  \" max number of suggestions (2) set by the 'spellsuggest' option.\n  call assert_equal(['board', 'bard', 'broad'], spellsuggest('baord', 3))\n\n  set spellsuggest& spell&\n  bwipe!\nendfunc\n\n\" Test 'spellsuggest' option with value expr:{expr}\nfunc Test_spellsuggest_option_expr()\n  \" A silly 'spellsuggest' function which makes suggestions all uppercase\n  \" and makes the score of each suggestion the length of the suggested word.\n  \" So shorter suggestions are preferred.\n  func MySuggest()\n    let spellsuggest_save = &spellsuggest\n    set spellsuggest=3,best\n    let result = map(spellsuggest(v:val, 3), \"[toupper(v:val), len(v:val)]\")\n    let &spellsuggest = spellsuggest_save\n    return result\n  endfunc\n\n  set spell spellsuggest=expr:MySuggest()\n  call assert_equal(['BARD', 'BOARD', 'BROAD'], spellsuggest('baord', 3))\n\n  new\n  call setline(1, 'baord')\n  let a = execute('norm z=')\n  call assert_equal(\n  \\    \"\\n\"\n  \\ .. \"Change \\\"baord\\\" to:\\n\"\n  \\ .. \" 1 \\\"BARD\\\"\\n\"\n  \\ .. \" 2 \\\"BOARD\\\"\\n\"\n  \\ .. \" 3 \\\"BROAD\\\"\\n\"\n  \\ .. \"Type number and <Enter> or click with the mouse (q or empty cancels): \", a)\n\n  \" With verbose, z= should show the score i.e. word length with\n  \" our SpellSuggest() function.\n  set verbose=1\n  let a = execute('norm z=')\n  call assert_equal(\n  \\    \"\\n\"\n  \\ .. \"Change \\\"baord\\\" to:\\n\"\n  \\ .. \" 1 \\\"BARD\\\"                      (4 - 0)\\n\"\n  \\ .. \" 2 \\\"BOARD\\\"                     (5 - 0)\\n\"\n  \\ .. \" 3 \\\"BROAD\\\"                     (5 - 0)\\n\"\n  \\ .. \"Type number and <Enter> or click with the mouse (q or empty cancels): \", a)\n\n  set spell& spellsuggest& verbose&\n  bwipe!\nendfunc\n\n\" Test for 'spellsuggest' expr errors\nfunc Test_spellsuggest_expr_errors()\n  \" 'spellsuggest'\n  func MySuggest()\n    return range(3)\n  endfunc\n  set spell spellsuggest=expr:MySuggest()\n  call assert_equal([], spellsuggest('baord', 3))\n\n  \" Test for 'spellsuggest' expression returning a non-list value\n  func! MySuggest2()\n    return 'good'\n  endfunc\n  set spellsuggest=expr:MySuggest2()\n  call assert_equal([], spellsuggest('baord'))\n\n  \" Test for 'spellsuggest' expression returning a list with dict values\n  func! MySuggest3()\n    return [[{}, {}]]\n  endfunc\n  set spellsuggest=expr:MySuggest3()\n  call assert_fails(\"call spellsuggest('baord')\", 'E731:')\n\n  set nospell spellsuggest&\n  delfunc MySuggest\n  delfunc MySuggest2\n  delfunc MySuggest3\nendfunc\n\nfunc Test_spellsuggest_timeout()\n  set spellsuggest=timeout:30\n  set spellsuggest=timeout:-123\n  set spellsuggest=timeout:999999\n  call assert_fails('set spellsuggest=timeout', 'E474:')\n  call assert_fails('set spellsuggest=timeout:x', 'E474:')\n  call assert_fails('set spellsuggest=timeout:-x', 'E474:')\n  call assert_fails('set spellsuggest=timeout:--9', 'E474:')\nendfunc\n\nfunc Test_spellsuggest_visual_end_of_line()\n  let enc_save = &encoding\n  set encoding=iso8859\n\n  \" This was reading beyond the end of the line.\n  norm R00000000000\n  sil norm \u00160\n  sil! norm \u0016i00000)\n  sil! norm \u0016i00000)\n  call feedkeys(\"\\<CR>\")\n  norm z=\n\n  let &encoding = enc_save\nendfunc\n\nfunc Test_spellinfo()\n  new\n  let runtime = substitute($VIMRUNTIME, '\\\\', '/', 'g')\n\n  set enc=latin1 spell spelllang=en\n  call assert_match(\"^\\nfile: \" .. runtime .. \"/spell/en.latin1.spl\\n$\", execute('spellinfo'))\n\n  set enc=cp1250 spell spelllang=en\n  call assert_match(\"^\\nfile: \" .. runtime .. \"/spell/en.ascii.spl\\n$\", execute('spellinfo'))\n\n  set enc=utf-8 spell spelllang=en\n  call assert_match(\"^\\nfile: \" .. runtime .. \"/spell/en.utf-8.spl\\n$\", execute('spellinfo'))\n\n  set enc=latin1 spell spelllang=en_us,en_nz\n  call assert_match(\"^\\n\" .\n                 \\  \"file: \" .. runtime .. \"/spell/en.latin1.spl\\n\" .\n                 \\  \"file: \" .. runtime.. \"/spell/en.latin1.spl\\n$\", execute('spellinfo'))\n\n  set spell spelllang=\n  call assert_fails('spellinfo', 'E756:')\n\n  set nospell spelllang=en\n  call assert_fails('spellinfo', 'E756:')\n\n  call assert_fails('set spelllang=foo/bar', 'E474:')\n  call assert_fails('set spelllang=foo\\ bar', 'E474:')\n  call assert_fails(\"set spelllang=foo\\\\\\nbar\", 'E474:')\n  call assert_fails(\"set spelllang=foo\\\\\\rbar\", 'E474:')\n  call assert_fails(\"set spelllang=foo+bar\", 'E474:')\n\n  set enc& spell& spelllang&\n  bwipe\nendfunc\n\nfunc Test_zz_basic()\n  call LoadAffAndDic(g:test_data_aff1, g:test_data_dic1)\n  call RunGoodBad(\"wrong OK puts. Test the end\",\n        \\ \"bad: inputs comment ok Ok. test d\\xE9\\xF4l end the\",\n        \\[\"Comment\", \"deol\", \"d\\xE9\\xF4r\", \"input\", \"OK\", \"output\", \"outputs\", \"outtest\", \"put\", \"puts\",\n        \\  \"test\", \"testen\", \"testn\", \"the end\", \"uk\", \"wrong\"],\n        \\[\n        \\   [\"bad\", [\"put\", \"uk\", \"OK\"]],\n        \\   [\"inputs\", [\"input\", \"puts\", \"outputs\"]],\n        \\   [\"comment\", [\"Comment\", \"outtest\", \"the end\"]],\n        \\   [\"ok\", [\"OK\", \"uk\", \"put\"]],\n        \\   [\"Ok\", [\"OK\", \"Uk\", \"Put\"]],\n        \\   [\"test\", [\"Test\", \"testn\", \"testen\"]],\n        \\   [\"d\\xE9\\xF4l\", [\"deol\", \"d\\xE9\\xF4r\", \"test\"]],\n        \\   [\"end\", [\"put\", \"uk\", \"test\"]],\n        \\   [\"the\", [\"put\", \"uk\", \"test\"]],\n        \\ ]\n        \\ )\n\n  call assert_equal(\"gebletegek\", soundfold('goobledygoook'))\n  call assert_equal(\"kepereneven\", 'k\u00f3op\u00ebr\u02d9n\u00f4ven'->soundfold())\n  call assert_equal(\"everles gesvets etele\", soundfold('oeverloos gezwets edale'))\nendfunc\n\n\" Postponed prefixes\nfunc Test_zz_prefixes()\n  call LoadAffAndDic(g:test_data_aff2, g:test_data_dic1)\n  call RunGoodBad(\"puts\",\n        \\ \"bad: inputs comment ok Ok end the. test d\\xE9\\xF4l\",\n        \\ [\"Comment\", \"deol\", \"d\\xE9\\xF4r\", \"OK\", \"put\", \"input\", \"output\", \"puts\", \"outputs\", \"test\", \"outtest\", \"testen\", \"testn\", \"the end\", \"uk\", \"wrong\"],\n        \\ [\n        \\   [\"bad\", [\"put\", \"uk\", \"OK\"]],\n        \\   [\"inputs\", [\"input\", \"puts\", \"outputs\"]],\n        \\   [\"comment\", [\"Comment\"]],\n        \\   [\"ok\", [\"OK\", \"uk\", \"put\"]],\n        \\   [\"Ok\", [\"OK\", \"Uk\", \"Put\"]],\n        \\   [\"end\", [\"put\", \"uk\", \"deol\"]],\n        \\   [\"the\", [\"put\", \"uk\", \"test\"]],\n        \\   [\"test\", [\"Test\", \"testn\", \"testen\"]],\n        \\   [\"d\\xE9\\xF4l\", [\"deol\", \"d\\xE9\\xF4r\", \"test\"]],\n        \\ ])\nendfunc\n\n\"Compound words\nfunc Test_zz_compound()\n  call LoadAffAndDic(g:test_data_aff3, g:test_data_dic3)\n  call RunGoodBad(\"foo m\\xEF foobar foofoobar barfoo barbarfoo\",\n        \\ \"bad: bar la foom\\xEF barm\\xEF m\\xEFfoo m\\xEFbar m\\xEFm\\xEF lala m\\xEFla lam\\xEF foola labar\",\n        \\ [\"foo\", \"m\\xEF\"],\n        \\ [\n        \\   [\"bad\", [\"foo\", \"m\\xEF\"]],\n        \\   [\"bar\", [\"barfoo\", \"foobar\", \"foo\"]],\n        \\   [\"la\", [\"m\\xEF\", \"foo\"]],\n        \\   [\"foom\\xEF\", [\"foo m\\xEF\", \"foo\", \"foofoo\"]],\n        \\   [\"barm\\xEF\", [\"barfoo\", \"m\\xEF\", \"barbar\"]],\n        \\   [\"m\\xEFfoo\", [\"m\\xEF foo\", \"foo\", \"foofoo\"]],\n        \\   [\"m\\xEFbar\", [\"foobar\", \"barbar\", \"m\\xEF\"]],\n        \\   [\"m\\xEFm\\xEF\", [\"m\\xEF m\\xEF\", \"m\\xEF\"]],\n        \\   [\"lala\", []],\n        \\   [\"m\\xEFla\", [\"m\\xEF\", \"m\\xEF m\\xEF\"]],\n        \\   [\"lam\\xEF\", [\"m\\xEF\", \"m\\xEF m\\xEF\"]],\n        \\   [\"foola\", [\"foo\", \"foobar\", \"foofoo\"]],\n        \\   [\"labar\", [\"barbar\", \"foobar\"]],\n        \\ ])\n\n  call LoadAffAndDic(g:test_data_aff4, g:test_data_dic4)\n  call RunGoodBad(\"word util bork prebork start end wordutil wordutils pro-ok bork borkbork borkborkbork borkborkborkbork borkborkborkborkbork tomato tomatotomato startend startword startwordword startwordend startwordwordend startwordwordwordend prebork preborkbork preborkborkbork nouword\",\n        \\ \"bad: wordutilize pro borkborkborkborkborkbork tomatotomatotomato endstart endend startstart wordend wordstart preborkprebork  preborkpreborkbork startwordwordwordwordend borkpreborkpreborkbork utilsbork  startnouword\",\n        \\ [\"bork\", \"prebork\", \"end\", \"pro-ok\", \"start\", \"tomato\", \"util\", \"utilize\", \"utils\", \"word\", \"nouword\"],\n        \\ [\n        \\   [\"bad\", [\"end\", \"bork\", \"word\"]],\n        \\   [\"wordutilize\", [\"word utilize\", \"wordutils\", \"wordutil\"]],\n        \\   [\"pro\", [\"bork\", \"word\", \"end\"]],\n        \\   [\"borkborkborkborkborkbork\", [\"bork borkborkborkborkbork\", \"borkbork borkborkborkbork\", \"borkborkbork borkborkbork\"]],\n        \\   [\"tomatotomatotomato\", [\"tomato tomatotomato\", \"tomatotomato tomato\", \"tomato tomato tomato\"]],\n        \\   [\"endstart\", [\"end start\", \"start\"]],\n        \\   [\"endend\", [\"end end\", \"end\"]],\n        \\   [\"startstart\", [\"start start\"]],\n        \\   [\"wordend\", [\"word end\", \"word\", \"wordword\"]],\n        \\   [\"wordstart\", [\"word start\", \"bork start\"]],\n        \\   [\"preborkprebork\", [\"prebork prebork\", \"preborkbork\", \"preborkborkbork\"]],\n        \\   [\"preborkpreborkbork\", [\"prebork preborkbork\", \"preborkborkbork\", \"preborkborkborkbork\"]],\n        \\   [\"startwordwordwordwordend\", [\"startwordwordwordword end\", \"startwordwordwordword\", \"start wordwordwordword end\"]],\n        \\   [\"borkpreborkpreborkbork\", [\"bork preborkpreborkbork\", \"bork prebork preborkbork\", \"bork preborkprebork bork\"]],\n        \\   [\"utilsbork\", [\"utilbork\", \"utils bork\", \"util bork\"]],\n        \\   [\"startnouword\", [\"start nouword\", \"startword\", \"startborkword\"]],\n        \\ ])\n\nendfunc\n\n\"Test affix flags with two characters\nfunc Test_zz_affix()\n  call LoadAffAndDic(g:test_data_aff5, g:test_data_dic5)\n  call RunGoodBad(\"fooa1 fooa\\xE9 bar prebar barbork prebarbork  startprebar start end startend  startmiddleend nouend\",\n        \\ \"bad: foo fooa2 prabar probarbirk middle startmiddle middleend endstart startprobar startnouend\",\n        \\ [\"bar\", \"barbork\", \"end\", \"fooa1\", \"fooa\\xE9\", \"nouend\", \"prebar\", \"prebarbork\", \"start\"],\n        \\ [\n        \\   [\"bad\", [\"bar\", \"end\", \"fooa1\"]],\n        \\   [\"foo\", [\"fooa1\", \"fooa\\xE9\", \"bar\"]],\n        \\   [\"fooa2\", [\"fooa1\", \"fooa\\xE9\", \"bar\"]],\n        \\   [\"prabar\", [\"prebar\", \"bar\", \"bar bar\"]],\n        \\   [\"probarbirk\", [\"prebarbork\"]],\n        \\   [\"middle\", []],\n        \\   [\"startmiddle\", [\"startmiddleend\", \"startmiddlebar\"]],\n        \\   [\"middleend\", []],\n        \\   [\"endstart\", [\"end start\", \"start\"]],\n        \\   [\"startprobar\", [\"startprebar\", \"start prebar\", \"startbar\"]],\n        \\   [\"startnouend\", [\"start nouend\", \"startend\"]],\n        \\ ])\n\n  call LoadAffAndDic(g:test_data_aff6, g:test_data_dic6)\n  call RunGoodBad(\"meea1 meea\\xE9 bar prebar barbork prebarbork  leadprebar lead end leadend  leadmiddleend\",\n        \\  \"bad: mee meea2 prabar probarbirk middle leadmiddle middleend endlead leadprobar\",\n        \\ [\"bar\", \"barbork\", \"end\", \"lead\", \"meea1\", \"meea\\xE9\", \"prebar\", \"prebarbork\"],\n        \\ [\n        \\   [\"bad\", [\"bar\", \"end\", \"lead\"]],\n        \\   [\"mee\", [\"meea1\", \"meea\\xE9\", \"bar\"]],\n        \\   [\"meea2\", [\"meea1\", \"meea\\xE9\", \"lead\"]],\n        \\   [\"prabar\", [\"prebar\", \"bar\", \"leadbar\"]],\n        \\   [\"probarbirk\", [\"prebarbork\"]],\n        \\   [\"middle\", []],\n        \\   [\"leadmiddle\", [\"leadmiddleend\", \"leadmiddlebar\"]],\n        \\   [\"middleend\", []],\n        \\   [\"endlead\", [\"end lead\", \"lead\", \"end end\"]],\n        \\   [\"leadprobar\", [\"leadprebar\", \"lead prebar\", \"leadbar\"]],\n        \\ ])\n\n  call LoadAffAndDic(g:test_data_aff7, g:test_data_dic7)\n  call RunGoodBad(\"meea1 meezero meea\\xE9 bar prebar barmeat prebarmeat  leadprebar lead tail leadtail  leadmiddletail\",\n        \\ \"bad: mee meea2 prabar probarmaat middle leadmiddle middletail taillead leadprobar\",\n        \\ [\"bar\", \"barmeat\", \"lead\", \"meea1\", \"meea\\xE9\", \"meezero\", \"prebar\", \"prebarmeat\", \"tail\"],\n        \\ [\n        \\   [\"bad\", [\"bar\", \"lead\", \"tail\"]],\n        \\   [\"mee\", [\"meea1\", \"meea\\xE9\", \"bar\"]],\n        \\   [\"meea2\", [\"meea1\", \"meea\\xE9\", \"lead\"]],\n        \\   [\"prabar\", [\"prebar\", \"bar\", \"leadbar\"]],\n        \\   [\"probarmaat\", [\"prebarmeat\"]],\n        \\   [\"middle\", []],\n        \\   [\"leadmiddle\", [\"leadmiddlebar\"]],\n        \\   [\"middletail\", []],\n        \\   [\"taillead\", [\"tail lead\", \"tail\"]],\n        \\   [\"leadprobar\", [\"leadprebar\", \"lead prebar\", \"leadbar\"]],\n        \\ ])\nendfunc\n\nfunc Test_zz_NOSLITSUGS()\n  call LoadAffAndDic(g:test_data_aff8, g:test_data_dic8)\n  call RunGoodBad(\"foo bar faabar\", \"bad: foobar barfoo\",\n        \\ [\"bar\", \"faabar\", \"foo\"],\n        \\ [\n        \\   [\"bad\", [\"bar\", \"foo\"]],\n        \\   [\"foobar\", [\"faabar\", \"foo bar\", \"bar\"]],\n        \\   [\"barfoo\", [\"bar foo\", \"bar\", \"foo\"]],\n        \\ ])\nendfunc\n\n\" Numbers\nfunc Test_zz_Numbers()\n  call LoadAffAndDic(g:test_data_aff9, g:test_data_dic9)\n  call RunGoodBad(\"0b1011 0777 1234 0x01ff\", \"\",\n        \\ [\"bar\", \"foo\"],\n        \\ [\n        \\ ])\nendfunc\n\n\" Affix flags\nfunc Test_zz_affix_flags()\n  call LoadAffAndDic(g:test_data_aff10, g:test_data_dic10)\n  call RunGoodBad(\"drink drinkable drinkables drinktable drinkabletable\",\n\t\\ \"bad: drinks drinkstable drinkablestable\",\n        \\ [\"drink\", \"drinkable\", \"drinkables\", \"table\"],\n        \\ [['bad', []],\n\t\\ ['drinks', ['drink']],\n\t\\ ['drinkstable', ['drinktable', 'drinkable', 'drink table']],\n        \\ ['drinkablestable', ['drinkabletable', 'drinkables table', 'drinkable table']],\n\t\\ ])\nendfunc\n\nfunction FirstSpellWord()\n  call feedkeys(\"/^start:\\n\", 'tx')\n  normal ]smm\n  let [str, a] = spellbadword()\n  return str\nendfunc\n\nfunction SecondSpellWord()\n  normal `m]s\n  let [str, a] = spellbadword()\n  return str\nendfunc\n\n\"Test with SAL instead of SOFO items; test automatic reloading\nfunc Test_zz_sal_and_addition()\n  set enc=latin1\n  set spellfile=\n  call writefile(g:test_data_dic1, \"Xtest.dic\", 'D')\n  call writefile(g:test_data_aff_sal, \"Xtest.aff\", 'D')\n  mkspell! Xtest Xtest\n  set spl=Xtest.latin1.spl spell\n  call assert_equal('kbltykk', soundfold('goobledygoook'))\n  call assert_equal('kprnfn', soundfold('k\u00f3op\u00ebr\u02d9n\u00f4ven'))\n  call assert_equal('*fls kswts tl', soundfold('oeverloos gezwets edale'))\n\n  \"also use an addition file\n  call writefile([\"/regions=usgbnz\", \"elequint/2\", \"elekwint/3\"], \"Xtest.latin1.add\", 'D')\n  mkspell! Xtest.latin1.add.spl Xtest.latin1.add\n\n  bwipe!\n  call setline(1, [\"start: elequint test elekwint test elekwent asdf\"])\n\n  set spellfile=Xtest.latin1.add\n  call assert_equal(\"elekwent\", FirstSpellWord())\n\n  set spl=Xtest_us.latin1.spl\n  call assert_equal(\"elequint\", FirstSpellWord())\n  call assert_equal(\"elekwint\", SecondSpellWord())\n\n  set spl=Xtest_gb.latin1.spl\n  call assert_equal(\"elekwint\", FirstSpellWord())\n  call assert_equal(\"elekwent\", SecondSpellWord())\n\n  set spl=Xtest_nz.latin1.spl\n  call assert_equal(\"elequint\", FirstSpellWord())\n  call assert_equal(\"elekwent\", SecondSpellWord())\n\n  set spl=Xtest_ca.latin1.spl\n  call assert_equal(\"elequint\", FirstSpellWord())\n  call assert_equal(\"elekwint\", SecondSpellWord())\n\n  bwipe!\n  set spellfile=\n  set spl&\nendfunc\n\nfunc Test_spellfile_value()\n  set spellfile=Xdir/Xtest.latin1.add\n  set spellfile=Xdir/Xtest.utf-8.add,Xtest_other.add\nendfunc\n\nfunc Test_region_error()\n  messages clear\n  call writefile([\"/regions=usgbnz\", \"elequint/0\"], \"Xtest.latin1.add\", 'D')\n  mkspell! Xtest.latin1.add.spl Xtest.latin1.add\n  call assert_match('Invalid region nr in Xtest.latin1.add line 2: 0', execute('messages'))\n  call delete('Xtest.latin1.add.spl')\nendfunc\n\n\" Check using z= in new buffer (crash fixed by patch 7.4a.028).\nfunc Test_zeq_crash()\n  new\n  set maxmem=512 spell\n  call feedkeys('iasd\u001bz=:\\\"', 'tx')\n\n  bwipe!\nendfunc\n\n\" Check that z= works even when 'nospell' is set.  This test uses one of the\n\" tests in Test_spellsuggest_option_number() just to verify that z= basically\n\" works and that \"E756: Spell checking is not enabled\" is not generated.\nfunc Test_zeq_nospell()\n  new\n  set nospell spellsuggest=1,best\n  call setline(1, 'A baord')\n  try\n    norm $1z=\n    call assert_equal('A board', getline(1))\n  catch\n    call assert_report(\"Caught exception: \" . v:exception)\n  endtry\n  set spell& spellsuggest&\n  bwipe!\nendfunc\n\n\" Check that \"E756: Spell checking is not possible\" is reported when z= is\n\" executed and 'spelllang' is empty.\nfunc Test_zeq_no_spelllang()\n  new\n  set spelllang= spellsuggest=1,best\n  call setline(1, 'A baord')\n  call assert_fails('normal $1z=', 'E756:')\n  set spelllang& spellsuggest&\n  bwipe!\nendfunc\n\n\" Check handling a word longer than MAXWLEN.\nfunc Test_spell_long_word()\n  set enc=utf-8\n  new\n  call setline(1, \"d\\xCC\\xB4\\xCC\\xBD\\xCD\\x88\\xCD\\x94a\\xCC\\xB5\\xCD\\x84\\xCD\\x84\\xCC\\xA8\\xCD\\x9Cr\\xCC\\xB5\\xCC\\x8E\\xCD\\x85\\xCD\\x85k\\xCC\\xB6\\xCC\\x89\\xCC\\x9D \\xCC\\xB6\\xCC\\x83\\xCC\\x8F\\xCC\\xA4\\xCD\\x8Ef\\xCC\\xB7\\xCC\\x81\\xCC\\x80\\xCC\\xA9\\xCC\\xB0\\xCC\\xAC\\xCC\\xA2\\xCD\\x95\\xCD\\x87\\xCD\\x8D\\xCC\\x9E\\xCD\\x99\\xCC\\xAD\\xCC\\xAB\\xCC\\x97\\xCC\\xBBo\\xCC\\xB6\\xCC\\x84\\xCC\\x95\\xCC\\x8C\\xCC\\x8B\\xCD\\x9B\\xCD\\x9C\\xCC\\xAFr\\xCC\\xB7\\xCC\\x94\\xCD\\x83\\xCD\\x97\\xCC\\x8C\\xCC\\x82\\xCD\\x82\\xCD\\x80\\xCD\\x91\\xCC\\x80\\xCC\\xBE\\xCC\\x82\\xCC\\x8F\\xCC\\xA3\\xCD\\x85\\xCC\\xAE\\xCD\\x8D\\xCD\\x99\\xCC\\xBC\\xCC\\xAB\\xCC\\xA7\\xCD\\x88c\\xCC\\xB7\\xCD\\x83\\xCC\\x84\\xCD\\x92\\xCC\\x86\\xCC\\x83\\xCC\\x88\\xCC\\x92\\xCC\\x94\\xCC\\xBE\\xCC\\x9D\\xCC\\xAF\\xCC\\x98\\xCC\\x9D\\xCC\\xBB\\xCD\\x8E\\xCC\\xBB\\xCC\\xB3\\xCC\\xA3\\xCD\\x8E\\xCD\\x99\\xCC\\xA5\\xCC\\xAD\\xCC\\x99\\xCC\\xB9\\xCC\\xAE\\xCC\\xA5\\xCC\\x9E\\xCD\\x88\\xCC\\xAE\\xCC\\x9E\\xCC\\xA9\\xCC\\x97\\xCC\\xBC\\xCC\\x99\\xCC\\xA5\\xCD\\x87\\xCC\\x97\\xCD\\x8E\\xCD\\x94\\xCC\\x99\\xCC\\x9D\\xCC\\x96\\xCD\\x94\\xCC\\xAB\\xCC\\xA7\\xCC\\xA5\\xCC\\x98\\xCC\\xBB\\xCC\\xAF\\xCC\\xABe\\xCC\\xB7\\xCC\\x8E\\xCC\\x82\\xCD\\x86\\xCD\\x9B\\xCC\\x94\\xCD\\x83\\xCC\\x85\\xCD\\x8A\\xCD\\x8C\\xCC\\x8B\\xCD\\x92\\xCD\\x91\\xCC\\x8F\\xCC\\x81\\xCD\\x95\\xCC\\xA2\\xCC\\xB9\\xCC\\xB2\\xCD\\x9C\\xCC\\xB1\\xCC\\xA6\\xCC\\xB3\\xCC\\xAF\\xCC\\xAE\\xCC\\x9C\\xCD\\x99s\\xCC\\xB8\\xCC\\x8C\\xCC\\x8E\\xCC\\x87\\xCD\\x81\\xCD\\x82\\xCC\\x86\\xCD\\x8C\\xCD\\x8C\\xCC\\x8B\\xCC\\x84\\xCC\\x8C\\xCD\\x84\\xCD\\x9B\\xCD\\x86\\xCC\\x93\\xCD\\x90\\xCC\\x85\\xCC\\x94\\xCD\\x98\\xCD\\x84\\xCD\\x92\\xCD\\x8B\\xCC\\x90\\xCC\\x83\\xCC\\x8F\\xCD\\x84\\xCD\\x81\\xCD\\x9B\\xCC\\x90\\xCD\\x81\\xCC\\x8F\\xCC\\xBD\\xCC\\x88\\xCC\\xBF\\xCC\\x88\\xCC\\x84\\xCC\\x8E\\xCD\\x99\\xCD\\x94\\xCC\\x99\\xCD\\x99\\xCC\\xB0\\xCC\\xA8\\xCC\\xA3\\xCC\\xA8\\xCC\\x96\\xCC\\x99\\xCC\\xAE\\xCC\\xBC\\xCC\\x99\\xCD\\x9A\\xCC\\xB2\\xCC\\xB1\\xCC\\x9F\\xCC\\xBB\\xCC\\xA6\\xCD\\x85\\xCC\\xAA\\xCD\\x89\\xCC\\x9D\\xCC\\x99\\xCD\\x96\\xCC\\xB1\\xCC\\xB1\\xCC\\x99\\xCC\\xA6\\xCC\\xA5\\xCD\\x95\\xCC\\xB2\\xCC\\xA0\\xCD\\x99 within\")\n  set spell spelllang=en\n  redraw\n  redraw!\n  bwipe!\n  set nospell\nendfunc\n\nfunc Test_spellsuggest_too_deep()\n  \" This was incrementing \"depth\" over MAXWLEN.\n  new\n  norm \u0016s000G00\u00fd000000000000\n  sil norm ..vzG................vvzG0     v z=\n  bwipe!\nendfunc\n\nfunc Test_spell_good_word_invalid()\n  \" This was adding a word with a 0x02 byte, which causes havoc.\n  enew\n  norm o0\n  sil! norm rzzWs00\u0002/\n  2\n  sil! norm VzGprzzW\n  sil! norm z=\n\n  bwipe!\nendfunc\n\nfunc Test_spell_good_word_slash()\n  \" This caused E1280.\n  new\n  norm afoo /\n  1\n  norm zG\n\n  bwipe!\nendfunc\n\nfunc LoadAffAndDic(aff_contents, dic_contents)\n  set enc=latin1\n  set spellfile=\n  call writefile(a:aff_contents, \"Xtest.aff\")\n  call writefile(a:dic_contents, \"Xtest.dic\")\n  \" Generate a .spl file from a .dic and .aff file.\n  mkspell! Xtest Xtest\n  \" use that spell file\n  set spl=Xtest.latin1.spl spell\nendfunc\n\nfunc ListWords()\n  spelldump\n  %yank\n  quit\n  return split(@\", \"\\n\")\nendfunc\n\nfunc TestGoodBadBase()\n  exe '1;/^good:'\n  normal 0f:]s\n  let prevbad = ''\n  let result = []\n  while 1\n    let [bad, a] = spellbadword()\n    if bad == '' || bad == prevbad || bad == 'badend'\n      break\n    endif\n    let prevbad = bad\n    let lst = bad->spellsuggest(3)\n    normal mm\n\n    call add(result, [bad, lst])\n    normal `m]s\n  endwhile\n  return result\nendfunc\n\nfunc RunGoodBad(good, bad, expected_words, expected_bad_words)\n  bwipe!\n  call setline(1, [\"good: \", a:good,  a:bad, \" badend \"])\n  let words = ListWords()\n  call assert_equal(a:expected_words, words[1:-1])\n  let bad_words = TestGoodBadBase()\n  call assert_equal(a:expected_bad_words, bad_words)\n  bwipe!\nendfunc\n\nfunc Test_spell_screendump()\n  CheckScreendump\n\n  let lines =<< trim END\n       call setline(1, [\n             \\ \"This is some text without any spell errors.  Everything\",\n             \\ \"should just be black, nothing wrong here.\",\n             \\ \"\",\n             \\ \"This line has a sepll error. and missing caps.\",\n             \\ \"And and this is the the duplication.\",\n             \\ \"with missing caps here.\",\n             \\ ])\n       set spell spelllang=en_nz\n  END\n  call writefile(lines, 'XtestSpell', 'D')\n  let buf = RunVimInTerminal('-S XtestSpell', {'rows': 8})\n  call VerifyScreenDump(buf, 'Test_spell_1', {})\n\n  \" clean up\n  call StopVimInTerminal(buf)\nendfunc\n\nfunc Test_spell_screendump_spellcap()\n  CheckScreendump\n\n  let lines =<< trim END\n       call setline(1, [\n             \\ \"   This line has a sepll error. and missing caps and trailing spaces.   \",\n             \\ \"another missing cap here.\",\n             \\ \"\",\n             \\ \"and here.\",\n             \\ \"    \",\n             \\ \"and here.\"\n             \\ ])\n       set spell spelllang=en\n  END\n  call writefile(lines, 'XtestSpellCap', 'D')\n  let buf = RunVimInTerminal('-S XtestSpellCap', {'rows': 8})\n  call VerifyScreenDump(buf, 'Test_spell_2', {})\n\n  \" After adding word missing Cap in next line is updated\n  call term_sendkeys(buf, \"3GANot\\<Esc>\")\n  call VerifyScreenDump(buf, 'Test_spell_3', {})\n\n  \" Deleting a full stop removes missing Cap in next line\n  call term_sendkeys(buf, \"5Gddk$x\")\n  call VerifyScreenDump(buf, 'Test_spell_4', {})\n\n  \" Undo also updates the next line (go to command line to remove message)\n  call term_sendkeys(buf, \"u:\\<Esc>\")\n  call VerifyScreenDump(buf, 'Test_spell_5', {})\n\n  \" clean up\n  call StopVimInTerminal(buf)\nendfunc\n\nfunc Test_spell_compatible()\n  CheckScreendump\n\n  let lines =<< trim END\n       call setline(1, [\n             \\ \"test \"->repeat(20),\n             \\ \"\",\n             \\ \"end\",\n             \\ ])\n       set spell cpo+=$\n  END\n  call writefile(lines, 'XtestSpellComp', 'D')\n  let buf = RunVimInTerminal('-S XtestSpellComp', {'rows': 8})\n\n  call term_sendkeys(buf, \"51|C\")\n  call VerifyScreenDump(buf, 'Test_spell_compatible_1', {})\n\n  call term_sendkeys(buf, \"x\")\n  call VerifyScreenDump(buf, 'Test_spell_compatible_2', {})\n\n  \" clean up\n  call StopVimInTerminal(buf)\nendfunc\n\nlet g:test_data_aff1 = [\n      \\\"SET ISO8859-1\",\n      \\\"TRY esianrtolcdugmphbyfvkwjkqxz-\\xEB\\xE9\\xE8\\xEA\\xEF\\xEE\\xE4\\xE0\\xE2\\xF6\\xFC\\xFB'ESIANRTOLCDUGMPHBYFVKWJKQXZ\",\n      \\\"\",\n      \\\"FOL  \\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\\xE6\\xE7\\xE8\\xE9\\xEA\\xEB\\xEC\\xED\\xEE\\xEF\\xF0\\xF1\\xF2\\xF3\\xF4\\xF5\\xF6\\xF8\\xF9\\xFA\\xFB\\xFC\\xFD\\xFE\\xDF\\xFF\",\n      \\\"LOW  \\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\\xE6\\xE7\\xE8\\xE9\\xEA\\xEB\\xEC\\xED\\xEE\\xEF\\xF0\\xF1\\xF2\\xF3\\xF4\\xF5\\xF6\\xF8\\xF9\\xFA\\xFB\\xFC\\xFD\\xFE\\xDF\\xFF\",\n      \\\"UPP  \\xC0\\xC1\\xC2\\xC3\\xC4\\xC5\\xC6\\xC7\\xC8\\xC9\\xCA\\xCB\\xCC\\xCD\\xCE\\xCF\\xD0\\xD1\\xD2\\xD3\\xD4\\xD5\\xD6\\xD8\\xD9\\xDA\\xDB\\xDC\\xDD\\xDE\\xDF\\xFF\",\n      \\\"\",\n      \\\"SOFOFROM abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\\xE6\\xE7\\xE8\\xE9\\xEA\\xEB\\xEC\\xED\\xEE\\xEF\\xF0\\xF1\\xF2\\xF3\\xF4\\xF5\\xF6\\xF8\\xF9\\xFA\\xFB\\xFC\\xFD\\xFE\\xDF\\xFF\\xC0\\xC1\\xC2\\xC3\\xC4\\xC5\\xC6\\xC7\\xC8\\xC9\\xCA\\xCB\\xCC\\xCD\\xCE\\xCF\\xD0\\xD1\\xD2\\xD3\\xD4\\xD5\\xD6\\xD8\\xD9\\xDA\\xDB\\xDC\\xDD\\xDE\\xBF\",\n      \\\"SOFOTO   ebctefghejklnnepkrstevvkesebctefghejklnnepkrstevvkeseeeeeeeceeeeeeeedneeeeeeeeeeepseeeeeeeeceeeeeeeedneeeeeeeeeeep?\",\n      \\\"\",\n      \\\"MIDWORD\\t'-\",\n      \\\"\",\n      \\\"KEP =\",\n      \\\"RAR ?\",\n      \\\"BAD !\",\n      \\\"\",\n      \\\"PFX I N 1\",\n      \\\"PFX I 0 in .\",\n      \\\"\",\n      \\\"PFX O Y 1\",\n      \\\"PFX O 0 out .\",\n      \\\"\",\n      \\\"SFX S Y 2\",\n      \\\"SFX S 0 s [^s]\",\n      \\\"SFX S 0 es s\",\n      \\\"\",\n      \\\"SFX N N 3\",\n      \\\"SFX N 0 en [^n]\",\n      \\\"SFX N 0 nen n\",\n      \\\"SFX N 0 n .\",\n      \\\"\",\n      \\\"REP 3\",\n      \\\"REP g ch\",\n      \\\"REP ch g\",\n      \\\"REP svp s.v.p.\",\n      \\\"\",\n      \\\"MAP 9\",\n      \\\"MAP a\\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\",\n      \\\"MAP e\\xE8\\xE9\\xEA\\xEB\",\n      \\\"MAP i\\xEC\\xED\\xEE\\xEF\",\n      \\\"MAP o\\xF2\\xF3\\xF4\\xF5\\xF6\",\n      \\\"MAP u\\xF9\\xFA\\xFB\\xFC\",\n      \\\"MAP n\\xF1\",\n      \\\"MAP c\\xE7\",\n      \\\"MAP y\\xFF\\xFD\",\n      \\\"MAP s\\xDF\",\n      \\ ]\nlet g:test_data_dic1 = [\n      \\\"123456\",\n      \\\"test/NO\",\n      \\\"# comment\",\n      \\\"wrong\",\n      \\\"Comment\",\n      \\\"OK\",\n      \\\"uk\",\n      \\\"put/ISO\",\n      \\\"the end\",\n      \\\"deol\",\n      \\\"d\\xE9\\xF4r\",\n      \\ ]\nlet g:test_data_aff2 = [\n      \\\"SET ISO8859-1\",\n      \\\"\",\n      \\\"FOL  \\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\\xE6\\xE7\\xE8\\xE9\\xEA\\xEB\\xEC\\xED\\xEE\\xEF\\xF0\\xF1\\xF2\\xF3\\xF4\\xF5\\xF6\\xF8\\xF9\\xFA\\xFB\\xFC\\xFD\\xFE\\xDF\\xFF\",\n      \\\"LOW  \\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\\xE6\\xE7\\xE8\\xE9\\xEA\\xEB\\xEC\\xED\\xEE\\xEF\\xF0\\xF1\\xF2\\xF3\\xF4\\xF5\\xF6\\xF8\\xF9\\xFA\\xFB\\xFC\\xFD\\xFE\\xDF\\xFF\",\n      \\\"UPP  \\xC0\\xC1\\xC2\\xC3\\xC4\\xC5\\xC6\\xC7\\xC8\\xC9\\xCA\\xCB\\xCC\\xCD\\xCE\\xCF\\xD0\\xD1\\xD2\\xD3\\xD4\\xD5\\xD6\\xD8\\xD9\\xDA\\xDB\\xDC\\xDD\\xDE\\xDF\\xFF\",\n      \\\"\",\n      \\\"PFXPOSTPONE\",\n      \\\"\",\n      \\\"MIDWORD\\t'-\",\n      \\\"\",\n      \\\"KEP =\",\n      \\\"RAR ?\",\n      \\\"BAD !\",\n      \\\"\",\n      \\\"PFX I N 1\",\n      \\\"PFX I 0 in .\",\n      \\\"\",\n      \\\"PFX O Y 1\",\n      \\\"PFX O 0 out [a-z]\",\n      \\\"\",\n      \\\"SFX S Y 2\",\n      \\\"SFX S 0 s [^s]\",\n      \\\"SFX S 0 es s\",\n      \\\"\",\n      \\\"SFX N N 3\",\n      \\\"SFX N 0 en [^n]\",\n      \\\"SFX N 0 nen n\",\n      \\\"SFX N 0 n .\",\n      \\\"\",\n      \\\"REP 3\",\n      \\\"REP g ch\",\n      \\\"REP ch g\",\n      \\\"REP svp s.v.p.\",\n      \\\"\",\n      \\\"MAP 9\",\n      \\\"MAP a\\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\",\n      \\\"MAP e\\xE8\\xE9\\xEA\\xEB\",\n      \\\"MAP i\\xEC\\xED\\xEE\\xEF\",\n      \\\"MAP o\\xF2\\xF3\\xF4\\xF5\\xF6\",\n      \\\"MAP u\\xF9\\xFA\\xFB\\xFC\",\n      \\\"MAP n\\xF1\",\n      \\\"MAP c\\xE7\",\n      \\\"MAP y\\xFF\\xFD\",\n      \\\"MAP s\\xDF\",\n      \\ ]\nlet g:test_data_aff3 = [\n      \\\"SET ISO8859-1\",\n      \\\"\",\n      \\\"COMPOUNDMIN 3\",\n      \\\"COMPOUNDRULE m*\",\n      \\\"NEEDCOMPOUND x\",\n      \\ ]\nlet g:test_data_dic3 = [\n      \\\"1234\",\n      \\\"foo/m\",\n      \\\"bar/mx\",\n      \\\"m\\xEF/m\",\n      \\\"la/mx\",\n      \\ ]\nlet g:test_data_aff4 = [\n      \\\"SET ISO8859-1\",\n      \\\"\",\n      \\\"FOL  \\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\\xE6\\xE7\\xE8\\xE9\\xEA\\xEB\\xEC\\xED\\xEE\\xEF\\xF0\\xF1\\xF2\\xF3\\xF4\\xF5\\xF6\\xF8\\xF9\\xFA\\xFB\\xFC\\xFD\\xFE\\xDF\\xFF\",\n      \\\"LOW  \\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\\xE6\\xE7\\xE8\\xE9\\xEA\\xEB\\xEC\\xED\\xEE\\xEF\\xF0\\xF1\\xF2\\xF3\\xF4\\xF5\\xF6\\xF8\\xF9\\xFA\\xFB\\xFC\\xFD\\xFE\\xDF\\xFF\",\n      \\\"UPP  \\xC0\\xC1\\xC2\\xC3\\xC4\\xC5\\xC6\\xC7\\xC8\\xC9\\xCA\\xCB\\xCC\\xCD\\xCE\\xCF\\xD0\\xD1\\xD2\\xD3\\xD4\\xD5\\xD6\\xD8\\xD9\\xDA\\xDB\\xDC\\xDD\\xDE\\xDF\\xFF\",\n      \\\"\",\n      \\\"COMPOUNDRULE m+\",\n      \\\"COMPOUNDRULE sm*e\",\n      \\\"COMPOUNDRULE sm+\",\n      \\\"COMPOUNDMIN 3\",\n      \\\"COMPOUNDWORDMAX 3\",\n      \\\"COMPOUNDFORBIDFLAG t\",\n      \\\"\",\n      \\\"COMPOUNDSYLMAX 5\",\n      \\\"SYLLABLE a\\xE1e\\xE9i\\xEDo\\xF3\\xF6\\xF5u\\xFA\\xFC\\xFBy/aa/au/ea/ee/ei/ie/oa/oe/oo/ou/uu/ui\",\n      \\\"\",\n      \\\"MAP 9\",\n      \\\"MAP a\\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\",\n      \\\"MAP e\\xE8\\xE9\\xEA\\xEB\",\n      \\\"MAP i\\xEC\\xED\\xEE\\xEF\",\n      \\\"MAP o\\xF2\\xF3\\xF4\\xF5\\xF6\",\n      \\\"MAP u\\xF9\\xFA\\xFB\\xFC\",\n      \\\"MAP n\\xF1\",\n      \\\"MAP c\\xE7\",\n      \\\"MAP y\\xFF\\xFD\",\n      \\\"MAP s\\xDF\",\n      \\\"\",\n      \\\"NEEDAFFIX x\",\n      \\\"\",\n      \\\"PFXPOSTPONE\",\n      \\\"\",\n      \\\"MIDWORD '-\",\n      \\\"\",\n      \\\"SFX q N 1\",\n      \\\"SFX q   0    -ok .\",\n      \\\"\",\n      \\\"SFX a Y 2\",\n      \\\"SFX a 0 s .\",\n      \\\"SFX a 0 ize/t .\",\n      \\\"\",\n      \\\"PFX p N 1\",\n      \\\"PFX p 0 pre .\",\n      \\\"\",\n      \\\"PFX P N 1\",\n      \\\"PFX P 0 nou .\",\n      \\ ]\nlet g:test_data_dic4 = [\n      \\\"1234\",\n      \\\"word/mP\",\n      \\\"util/am\",\n      \\\"pro/xq\",\n      \\\"tomato/m\",\n      \\\"bork/mp\",\n      \\\"start/s\",\n      \\\"end/e\",\n      \\ ]\nlet g:test_data_aff5 = [\n      \\\"SET ISO8859-1\",\n      \\\"\",\n      \\\"FLAG long\",\n      \\\"\",\n      \\\"NEEDAFFIX !!\",\n      \\\"\",\n      \\\"COMPOUNDRULE ssmm*ee\",\n      \\\"\",\n      \\\"NEEDCOMPOUND xx\",\n      \\\"COMPOUNDPERMITFLAG pp\",\n      \\\"\",\n      \\\"SFX 13 Y 1\",\n      \\\"SFX 13 0 bork .\",\n      \\\"\",\n      \\\"SFX a1 Y 1\",\n      \\\"SFX a1 0 a1 .\",\n      \\\"\",\n      \\\"SFX a\\xE9 Y 1\",\n      \\\"SFX a\\xE9 0 a\\xE9 .\",\n      \\\"\",\n      \\\"PFX zz Y 1\",\n      \\\"PFX zz 0 pre/pp .\",\n      \\\"\",\n      \\\"PFX yy Y 1\",\n      \\\"PFX yy 0 nou .\",\n      \\ ]\nlet g:test_data_dic5 = [\n      \\\"1234\",\n      \\\"foo/a1a\\xE9!!\",\n      \\\"bar/zz13ee\",\n      \\\"start/ss\",\n      \\\"end/eeyy\",\n      \\\"middle/mmxx\",\n      \\ ]\nlet g:test_data_aff6 = [\n      \\\"SET ISO8859-1\",\n      \\\"\",\n      \\\"FLAG caplong\",\n      \\\"\",\n      \\\"NEEDAFFIX A!\",\n      \\\"\",\n      \\\"COMPOUNDRULE sMm*Ee\",\n      \\\"\",\n      \\\"NEEDCOMPOUND Xx\",\n      \\\"\",\n      \\\"COMPOUNDPERMITFLAG p\",\n      \\\"\",\n      \\\"SFX N3 Y 1\",\n      \\\"SFX N3 0 bork .\",\n      \\\"\",\n      \\\"SFX A1 Y 1\",\n      \\\"SFX A1 0 a1 .\",\n      \\\"\",\n      \\\"SFX A\\xE9 Y 1\",\n      \\\"SFX A\\xE9 0 a\\xE9 .\",\n      \\\"\",\n      \\\"PFX Zz Y 1\",\n      \\\"PFX Zz 0 pre/p .\",\n      \\ ]\nlet g:test_data_dic6 = [\n      \\\"1234\",\n      \\\"mee/A1A\\xE9A!\",\n      \\\"bar/ZzN3Ee\",\n      \\\"lead/s\",\n      \\\"end/Ee\",\n      \\\"middle/MmXx\",\n      \\ ]\nlet g:test_data_aff7 = [\n      \\\"SET ISO8859-1\",\n      \\\"\",\n      \\\"FLAG num\",\n      \\\"\",\n      \\\"NEEDAFFIX 9999\",\n      \\\"\",\n      \\\"COMPOUNDRULE 2,77*123\",\n      \\\"\",\n      \\\"NEEDCOMPOUND 1\",\n      \\\"COMPOUNDPERMITFLAG 432\",\n      \\\"\",\n      \\\"SFX 61003 Y 1\",\n      \\\"SFX 61003 0 meat .\",\n      \\\"\",\n      \\\"SFX 0 Y 1\",\n      \\\"SFX 0 0 zero .\",\n      \\\"\",\n      \\\"SFX 391 Y 1\",\n      \\\"SFX 391 0 a1 .\",\n      \\\"\",\n      \\\"SFX 111 Y 1\",\n      \\\"SFX 111 0 a\\xE9 .\",\n      \\\"\",\n      \\\"PFX 17 Y 1\",\n      \\\"PFX 17 0 pre/432 .\",\n      \\ ]\nlet g:test_data_dic7 = [\n      \\\"1234\",\n      \\\"mee/0,391,111,9999\",\n      \\\"bar/17,61003,123\",\n      \\\"lead/2\",\n      \\\"tail/123\",\n      \\\"middle/77,1\",\n      \\ ]\nlet g:test_data_aff8 = [\n      \\\"SET ISO8859-1\",\n      \\\"\",\n      \\\"NOSPLITSUGS\",\n      \\ ]\nlet g:test_data_dic8 = [\n      \\\"1234\",\n      \\\"foo\",\n      \\\"bar\",\n      \\\"faabar\",\n      \\ ]\nlet g:test_data_aff9 = [\n      \\ ]\nlet g:test_data_dic9 = [\n      \\\"1234\",\n      \\\"foo\",\n      \\\"bar\",\n      \\ ]\nlet g:test_data_aff10 = [\n      \\\"COMPOUNDRULE se\",\n      \\\"COMPOUNDPERMITFLAG p\",\n      \\\"\",\n      \\\"SFX A Y 1\",\n      \\\"SFX A 0 able/Mp .\",\n      \\\"\",\n      \\\"SFX M Y 1\",\n      \\\"SFX M 0 s .\",\n      \\ ]\nlet g:test_data_dic10 = [\n      \\\"1234\",\n      \\\"drink/As\",\n      \\\"table/e\",\n      \\ ]\nlet g:test_data_aff_sal = [\n      \\\"SET ISO8859-1\",\n      \\\"TRY esianrtolcdugmphbyfvkwjkqxz-\\xEB\\xE9\\xE8\\xEA\\xEF\\xEE\\xE4\\xE0\\xE2\\xF6\\xFC\\xFB'ESIANRTOLCDUGMPHBYFVKWJKQXZ\",\n      \\\"\",\n      \\\"FOL  \\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\\xE6\\xE7\\xE8\\xE9\\xEA\\xEB\\xEC\\xED\\xEE\\xEF\\xF0\\xF1\\xF2\\xF3\\xF4\\xF5\\xF6\\xF8\\xF9\\xFA\\xFB\\xFC\\xFD\\xFE\\xDF\\xFF\",\n      \\\"LOW  \\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\\xE6\\xE7\\xE8\\xE9\\xEA\\xEB\\xEC\\xED\\xEE\\xEF\\xF0\\xF1\\xF2\\xF3\\xF4\\xF5\\xF6\\xF8\\xF9\\xFA\\xFB\\xFC\\xFD\\xFE\\xDF\\xFF\",\n      \\\"UPP  \\xC0\\xC1\\xC2\\xC3\\xC4\\xC5\\xC6\\xC7\\xC8\\xC9\\xCA\\xCB\\xCC\\xCD\\xCE\\xCF\\xD0\\xD1\\xD2\\xD3\\xD4\\xD5\\xD6\\xD8\\xD9\\xDA\\xDB\\xDC\\xDD\\xDE\\xDF\\xFF\",\n      \\\"\",\n      \\\"MIDWORD\\t'-\",\n      \\\"\",\n      \\\"KEP =\",\n      \\\"RAR ?\",\n      \\\"BAD !\",\n      \\\"\",\n      \\\"PFX I N 1\",\n      \\\"PFX I 0 in .\",\n      \\\"\",\n      \\\"PFX O Y 1\",\n      \\\"PFX O 0 out .\",\n      \\\"\",\n      \\\"SFX S Y 2\",\n      \\\"SFX S 0 s [^s]\",\n      \\\"SFX S 0 es s\",\n      \\\"\",\n      \\\"SFX N N 3\",\n      \\\"SFX N 0 en [^n]\",\n      \\\"SFX N 0 nen n\",\n      \\\"SFX N 0 n .\",\n      \\\"\",\n      \\\"REP 3\",\n      \\\"REP g ch\",\n      \\\"REP ch g\",\n      \\\"REP svp s.v.p.\",\n      \\\"\",\n      \\\"MAP 9\",\n      \\\"MAP a\\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\",\n      \\\"MAP e\\xE8\\xE9\\xEA\\xEB\",\n      \\\"MAP i\\xEC\\xED\\xEE\\xEF\",\n      \\\"MAP o\\xF2\\xF3\\xF4\\xF5\\xF6\",\n      \\\"MAP u\\xF9\\xFA\\xFB\\xFC\",\n      \\\"MAP n\\xF1\",\n      \\\"MAP c\\xE7\",\n      \\\"MAP y\\xFF\\xFD\",\n      \\\"MAP s\\xDF\",\n      \\\"\",\n      \\\"SAL AH(AEIOUY)-^         *H\",\n      \\\"SAL AR(AEIOUY)-^         *R\",\n      \\\"SAL A(HR)^               *\",\n      \\\"SAL A^                   *\",\n      \\\"SAL AH(AEIOUY)-          H\",\n      \\\"SAL AR(AEIOUY)-          R\",\n      \\\"SAL A(HR)                _\",\n      \\\"SAL \\xC0^                   *\",\n      \\\"SAL \\xC5^                   *\",\n      \\\"SAL BB-                  _\",\n      \\\"SAL B                    B\",\n      \\\"SAL CQ-                  _\",\n      \\\"SAL CIA                  X\",\n      \\\"SAL CH                   X\",\n      \\\"SAL C(EIY)-              S\",\n      \\\"SAL CK                   K\",\n      \\\"SAL COUGH^               KF\",\n      \\\"SAL CC<                  C\",\n      \\\"SAL C                    K\",\n      \\\"SAL DG(EIY)              K\",\n      \\\"SAL DD-                  _\",\n      \\\"SAL D                    T\",\n      \\\"SAL \\xC9<                   E\",\n      \\\"SAL EH(AEIOUY)-^         *H\",\n      \\\"SAL ER(AEIOUY)-^         *R\",\n      \\\"SAL E(HR)^               *\",\n      \\\"SAL ENOUGH^$             *NF\",\n      \\\"SAL E^                   *\",\n      \\\"SAL EH(AEIOUY)-          H\",\n      \\\"SAL ER(AEIOUY)-          R\",\n      \\\"SAL E(HR)                _\",\n      \\\"SAL FF-                  _\",\n      \\\"SAL F                    F\",\n      \\\"SAL GN^                  N\",\n      \\\"SAL GN$                  N\",\n      \\\"SAL GNS$                 NS\",\n      \\\"SAL GNED$                N\",\n      \\\"SAL GH(AEIOUY)-          K\",\n      \\\"SAL GH                   _\",\n      \\\"SAL GG9                  K\",\n      \\\"SAL G                    K\",\n      \\\"SAL H                    H\",\n      \\\"SAL IH(AEIOUY)-^         *H\",\n      \\\"SAL IR(AEIOUY)-^         *R\",\n      \\\"SAL I(HR)^               *\",\n      \\\"SAL I^                   *\",\n      \\\"SAL ING6                 N\",\n      \\\"SAL IH(AEIOUY)-          H\",\n      \\\"SAL IR(AEIOUY)-          R\",\n      \\\"SAL I(HR)                _\",\n      \\\"SAL J                    K\",\n      \\\"SAL KN^                  N\",\n      \\\"SAL KK-                  _\",\n      \\\"SAL K                    K\",\n      \\\"SAL LAUGH^               LF\",\n      \\\"SAL LL-                  _\",\n      \\\"SAL L                    L\",\n      \\\"SAL MB$                  M\",\n      \\\"SAL MM                   M\",\n      \\\"SAL M                    M\",\n      \\\"SAL NN-                  _\",\n      \\\"SAL N                    N\",\n      \\\"SAL OH(AEIOUY)-^         *H\",\n      \\\"SAL OR(AEIOUY)-^         *R\",\n      \\\"SAL O(HR)^               *\",\n      \\\"SAL O^                   *\",\n      \\\"SAL OH(AEIOUY)-          H\",\n      \\\"SAL OR(AEIOUY)-          R\",\n      \\\"SAL O(HR)                _\",\n      \\\"SAL PH                   F\",\n      \\\"SAL PN^                  N\",\n      \\\"SAL PP-                  _\",\n      \\\"SAL P                    P\",\n      \\\"SAL Q                    K\",\n      \\\"SAL RH^                  R\",\n      \\\"SAL ROUGH^               RF\",\n      \\\"SAL RR-                  _\",\n      \\\"SAL R                    R\",\n      \\\"SAL SCH(EOU)-            SK\",\n      \\\"SAL SC(IEY)-             S\",\n      \\\"SAL SH                   X\",\n      \\\"SAL SI(AO)-              X\",\n      \\\"SAL SS-                  _\",\n      \\\"SAL S                    S\",\n      \\\"SAL TI(AO)-              X\",\n      \\\"SAL TH                   @\",\n      \\\"SAL TCH--                _\",\n      \\\"SAL TOUGH^               TF\",\n      \\\"SAL TT-                  _\",\n      \\\"SAL T                    T\",\n      \\\"SAL UH(AEIOUY)-^         *H\",\n      \\\"SAL UR(AEIOUY)-^         *R\",\n      \\\"SAL U(HR)^               *\",\n      \\\"SAL U^                   *\",\n      \\\"SAL UH(AEIOUY)-          H\",\n      \\\"SAL UR(AEIOUY)-          R\",\n      \\\"SAL U(HR)                _\",\n      \\\"SAL V^                   W\",\n      \\\"SAL V                    F\",\n      \\\"SAL WR^                  R\",\n      \\\"SAL WH^                  W\",\n      \\\"SAL W(AEIOU)-            W\",\n      \\\"SAL X^                   S\",\n      \\\"SAL X                    KS\",\n      \\\"SAL Y(AEIOU)-            Y\",\n      \\\"SAL ZZ-                  _\",\n      \\\"SAL Z                    S\",\n      \\ ]\n\n\" vim: shiftwidth=2 sts=2 expandtab\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 8.2 and 9.0 can be found with \":help version9\".\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion == NULL)\n    {\n#ifdef BUILD_DATE\n\tchar *date_time = BUILD_DATE;\n#else\n\tchar *date_time = __DATE__ \" \" __TIME__;\n#endif\n\tchar *msg = _(\"%s (%s, compiled %s)\");\n\tsize_t len = strlen(msg)\n\t\t    + strlen(VIM_VERSION_LONG_ONLY)\n\t\t    + strlen(VIM_VERSION_DATE_ONLY)\n\t\t    + strlen(date_time);\n\n\tlongVersion = alloc(len);\n\tif (longVersion == NULL)\n\t    longVersion = VIM_VERSION_LONG;\n\telse\n\t    vim_snprintf(longVersion, len, msg,\n\t\t      VIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n    }\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n\t\"++builtin_terms\",\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n\t\"+cindent\",\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n\t\"+cmdline_info\",\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n\t\"-ebcdic\",\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n\t\"+file_in_path\",\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n\t\"+float\",\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n\t\"-footer\",\n\t// only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n\t\"+jumplist\",\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n\t\"+lispindent\",\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n#  ifdef DYNAMIC_GPM\n\t\"+mouse_gpm/dyn\",\n#  else\n\t\"+mouse_gpm\",\n#  endif\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n\t\"+path_extra\",\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n\t\"+smartindent\",\n#ifdef FEAT_SODIUM\n# ifdef DYNAMIC_SODIUM\n\t\"+sodium/dyn\",\n# else\n\t\"+sodium\",\n# endif\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n\t\"+tag_binary\",\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n\t\"+textobjects\",\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n\t\"+title\",\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+vim9script\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n\t\"+wildignore\",\n\t\"+wildmenu\",\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#if defined(MSWIN)\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#elif defined(HAVE_XPM)\n\t\"+xpm\",\n#else\n\t\"-xpm\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# if defined(USE_XSMP_INTERACT)\n\t\"+xsmp_interact\",\n# elif defined(USE_XSMP)\n\t\"+xsmp\",\n# else\n\t\"-xsmp\",\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    882,\n/**/\n    881,\n/**/\n    880,\n/**/\n    879,\n/**/\n    878,\n/**/\n    877,\n/**/\n    876,\n/**/\n    875,\n/**/\n    874,\n/**/\n    873,\n/**/\n    872,\n/**/\n    871,\n/**/\n    870,\n/**/\n    869,\n/**/\n    868,\n/**/\n    867,\n/**/\n    866,\n/**/\n    865,\n/**/\n    864,\n/**/\n    863,\n/**/\n    862,\n/**/\n    861,\n/**/\n    860,\n/**/\n    859,\n/**/\n    858,\n/**/\n    857,\n/**/\n    856,\n/**/\n    855,\n/**/\n    854,\n/**/\n    853,\n/**/\n    852,\n/**/\n    851,\n/**/\n    850,\n/**/\n    849,\n/**/\n    848,\n/**/\n    847,\n/**/\n    846,\n/**/\n    845,\n/**/\n    844,\n/**/\n    843,\n/**/\n    842,\n/**/\n    841,\n/**/\n    840,\n/**/\n    839,\n/**/\n    838,\n/**/\n    837,\n/**/\n    836,\n/**/\n    835,\n/**/\n    834,\n/**/\n    833,\n/**/\n    832,\n/**/\n    831,\n/**/\n    830,\n/**/\n    829,\n/**/\n    828,\n/**/\n    827,\n/**/\n    826,\n/**/\n    825,\n/**/\n    824,\n/**/\n    823,\n/**/\n    822,\n/**/\n    821,\n/**/\n    820,\n/**/\n    819,\n/**/\n    818,\n/**/\n    817,\n/**/\n    816,\n/**/\n    815,\n/**/\n    814,\n/**/\n    813,\n/**/\n    812,\n/**/\n    811,\n/**/\n    810,\n/**/\n    809,\n/**/\n    808,\n/**/\n    807,\n/**/\n    806,\n/**/\n    805,\n/**/\n    804,\n/**/\n    803,\n/**/\n    802,\n/**/\n    801,\n/**/\n    800,\n/**/\n    799,\n/**/\n    798,\n/**/\n    797,\n/**/\n    796,\n/**/\n    795,\n/**/\n    794,\n/**/\n    793,\n/**/\n    792,\n/**/\n    791,\n/**/\n    790,\n/**/\n    789,\n/**/\n    788,\n/**/\n    787,\n/**/\n    786,\n/**/\n    785,\n/**/\n    784,\n/**/\n    783,\n/**/\n    782,\n/**/\n    781,\n/**/\n    780,\n/**/\n    779,\n/**/\n    778,\n/**/\n    777,\n/**/\n    776,\n/**/\n    775,\n/**/\n    774,\n/**/\n    773,\n/**/\n    772,\n/**/\n    771,\n/**/\n    770,\n/**/\n    769,\n/**/\n    768,\n/**/\n    767,\n/**/\n    766,\n/**/\n    765,\n/**/\n    764,\n/**/\n    763,\n/**/\n    762,\n/**/\n    761,\n/**/\n    760,\n/**/\n    759,\n/**/\n    758,\n/**/\n    757,\n/**/\n    756,\n/**/\n    755,\n/**/\n    754,\n/**/\n    753,\n/**/\n    752,\n/**/\n    751,\n/**/\n    750,\n/**/\n    749,\n/**/\n    748,\n/**/\n    747,\n/**/\n    746,\n/**/\n    745,\n/**/\n    744,\n/**/\n    743,\n/**/\n    742,\n/**/\n    741,\n/**/\n    740,\n/**/\n    739,\n/**/\n    738,\n/**/\n    737,\n/**/\n    736,\n/**/\n    735,\n/**/\n    734,\n/**/\n    733,\n/**/\n    732,\n/**/\n    731,\n/**/\n    730,\n/**/\n    729,\n/**/\n    728,\n/**/\n    727,\n/**/\n    726,\n/**/\n    725,\n/**/\n    724,\n/**/\n    723,\n/**/\n    722,\n/**/\n    721,\n/**/\n    720,\n/**/\n    719,\n/**/\n    718,\n/**/\n    717,\n/**/\n    716,\n/**/\n    715,\n/**/\n    714,\n/**/\n    713,\n/**/\n    712,\n/**/\n    711,\n/**/\n    710,\n/**/\n    709,\n/**/\n    708,\n/**/\n    707,\n/**/\n    706,\n/**/\n    705,\n/**/\n    704,\n/**/\n    703,\n/**/\n    702,\n/**/\n    701,\n/**/\n    700,\n/**/\n    699,\n/**/\n    698,\n/**/\n    697,\n/**/\n    696,\n/**/\n    695,\n/**/\n    694,\n/**/\n    693,\n/**/\n    692,\n/**/\n    691,\n/**/\n    690,\n/**/\n    689,\n/**/\n    688,\n/**/\n    687,\n/**/\n    686,\n/**/\n    685,\n/**/\n    684,\n/**/\n    683,\n/**/\n    682,\n/**/\n    681,\n/**/\n    680,\n/**/\n    679,\n/**/\n    678,\n/**/\n    677,\n/**/\n    676,\n/**/\n    675,\n/**/\n    674,\n/**/\n    673,\n/**/\n    672,\n/**/\n    671,\n/**/\n    670,\n/**/\n    669,\n/**/\n    668,\n/**/\n    667,\n/**/\n    666,\n/**/\n    665,\n/**/\n    664,\n/**/\n    663,\n/**/\n    662,\n/**/\n    661,\n/**/\n    660,\n/**/\n    659,\n/**/\n    658,\n/**/\n    657,\n/**/\n    656,\n/**/\n    655,\n/**/\n    654,\n/**/\n    653,\n/**/\n    652,\n/**/\n    651,\n/**/\n    650,\n/**/\n    649,\n/**/\n    648,\n/**/\n    647,\n/**/\n    646,\n/**/\n    645,\n/**/\n    644,\n/**/\n    643,\n/**/\n    642,\n/**/\n    641,\n/**/\n    640,\n/**/\n    639,\n/**/\n    638,\n/**/\n    637,\n/**/\n    636,\n/**/\n    635,\n/**/\n    634,\n/**/\n    633,\n/**/\n    632,\n/**/\n    631,\n/**/\n    630,\n/**/\n    629,\n/**/\n    628,\n/**/\n    627,\n/**/\n    626,\n/**/\n    625,\n/**/\n    624,\n/**/\n    623,\n/**/\n    622,\n/**/\n    621,\n/**/\n    620,\n/**/\n    619,\n/**/\n    618,\n/**/\n    617,\n/**/\n    616,\n/**/\n    615,\n/**/\n    614,\n/**/\n    613,\n/**/\n    612,\n/**/\n    611,\n/**/\n    610,\n/**/\n    609,\n/**/\n    608,\n/**/\n    607,\n/**/\n    606,\n/**/\n    605,\n/**/\n    604,\n/**/\n    603,\n/**/\n    602,\n/**/\n    601,\n/**/\n    600,\n/**/\n    599,\n/**/\n    598,\n/**/\n    597,\n/**/\n    596,\n/**/\n    595,\n/**/\n    594,\n/**/\n    593,\n/**/\n    592,\n/**/\n    591,\n/**/\n    590,\n/**/\n    589,\n/**/\n    588,\n/**/\n    587,\n/**/\n    586,\n/**/\n    585,\n/**/\n    584,\n/**/\n    583,\n/**/\n    582,\n/**/\n    581,\n/**/\n    580,\n/**/\n    579,\n/**/\n    578,\n/**/\n    577,\n/**/\n    576,\n/**/\n    575,\n/**/\n    574,\n/**/\n    573,\n/**/\n    572,\n/**/\n    571,\n/**/\n    570,\n/**/\n    569,\n/**/\n    568,\n/**/\n    567,\n/**/\n    566,\n/**/\n    565,\n/**/\n    564,\n/**/\n    563,\n/**/\n    562,\n/**/\n    561,\n/**/\n    560,\n/**/\n    559,\n/**/\n    558,\n/**/\n    557,\n/**/\n    556,\n/**/\n    555,\n/**/\n    554,\n/**/\n    553,\n/**/\n    552,\n/**/\n    551,\n/**/\n    550,\n/**/\n    549,\n/**/\n    548,\n/**/\n    547,\n/**/\n    546,\n/**/\n    545,\n/**/\n    544,\n/**/\n    543,\n/**/\n    542,\n/**/\n    541,\n/**/\n    540,\n/**/\n    539,\n/**/\n    538,\n/**/\n    537,\n/**/\n    536,\n/**/\n    535,\n/**/\n    534,\n/**/\n    533,\n/**/\n    532,\n/**/\n    531,\n/**/\n    530,\n/**/\n    529,\n/**/\n    528,\n/**/\n    527,\n/**/\n    526,\n/**/\n    525,\n/**/\n    524,\n/**/\n    523,\n/**/\n    522,\n/**/\n    521,\n/**/\n    520,\n/**/\n    519,\n/**/\n    518,\n/**/\n    517,\n/**/\n    516,\n/**/\n    515,\n/**/\n    514,\n/**/\n    513,\n/**/\n    512,\n/**/\n    511,\n/**/\n    510,\n/**/\n    509,\n/**/\n    508,\n/**/\n    507,\n/**/\n    506,\n/**/\n    505,\n/**/\n    504,\n/**/\n    503,\n/**/\n    502,\n/**/\n    501,\n/**/\n    500,\n/**/\n    499,\n/**/\n    498,\n/**/\n    497,\n/**/\n    496,\n/**/\n    495,\n/**/\n    494,\n/**/\n    493,\n/**/\n    492,\n/**/\n    491,\n/**/\n    490,\n/**/\n    489,\n/**/\n    488,\n/**/\n    487,\n/**/\n    486,\n/**/\n    485,\n/**/\n    484,\n/**/\n    483,\n/**/\n    482,\n/**/\n    481,\n/**/\n    480,\n/**/\n    479,\n/**/\n    478,\n/**/\n    477,\n/**/\n    476,\n/**/\n    475,\n/**/\n    474,\n/**/\n    473,\n/**/\n    472,\n/**/\n    471,\n/**/\n    470,\n/**/\n    469,\n/**/\n    468,\n/**/\n    467,\n/**/\n    466,\n/**/\n    465,\n/**/\n    464,\n/**/\n    463,\n/**/\n    462,\n/**/\n    461,\n/**/\n    460,\n/**/\n    459,\n/**/\n    458,\n/**/\n    457,\n/**/\n    456,\n/**/\n    455,\n/**/\n    454,\n/**/\n    453,\n/**/\n    452,\n/**/\n    451,\n/**/\n    450,\n/**/\n    449,\n/**/\n    448,\n/**/\n    447,\n/**/\n    446,\n/**/\n    445,\n/**/\n    444,\n/**/\n    443,\n/**/\n    442,\n/**/\n    441,\n/**/\n    440,\n/**/\n    439,\n/**/\n    438,\n/**/\n    437,\n/**/\n    436,\n/**/\n    435,\n/**/\n    434,\n/**/\n    433,\n/**/\n    432,\n/**/\n    431,\n/**/\n    430,\n/**/\n    429,\n/**/\n    428,\n/**/\n    427,\n/**/\n    426,\n/**/\n    425,\n/**/\n    424,\n/**/\n    423,\n/**/\n    422,\n/**/\n    421,\n/**/\n    420,\n/**/\n    419,\n/**/\n    418,\n/**/\n    417,\n/**/\n    416,\n/**/\n    415,\n/**/\n    414,\n/**/\n    413,\n/**/\n    412,\n/**/\n    411,\n/**/\n    410,\n/**/\n    409,\n/**/\n    408,\n/**/\n    407,\n/**/\n    406,\n/**/\n    405,\n/**/\n    404,\n/**/\n    403,\n/**/\n    402,\n/**/\n    401,\n/**/\n    400,\n/**/\n    399,\n/**/\n    398,\n/**/\n    397,\n/**/\n    396,\n/**/\n    395,\n/**/\n    394,\n/**/\n    393,\n/**/\n    392,\n/**/\n    391,\n/**/\n    390,\n/**/\n    389,\n/**/\n    388,\n/**/\n    387,\n/**/\n    386,\n/**/\n    385,\n/**/\n    384,\n/**/\n    383,\n/**/\n    382,\n/**/\n    381,\n/**/\n    380,\n/**/\n    379,\n/**/\n    378,\n/**/\n    377,\n/**/\n    376,\n/**/\n    375,\n/**/\n    374,\n/**/\n    373,\n/**/\n    372,\n/**/\n    371,\n/**/\n    370,\n/**/\n    369,\n/**/\n    368,\n/**/\n    367,\n/**/\n    366,\n/**/\n    365,\n/**/\n    364,\n/**/\n    363,\n/**/\n    362,\n/**/\n    361,\n/**/\n    360,\n/**/\n    359,\n/**/\n    358,\n/**/\n    357,\n/**/\n    356,\n/**/\n    355,\n/**/\n    354,\n/**/\n    353,\n/**/\n    352,\n/**/\n    351,\n/**/\n    350,\n/**/\n    349,\n/**/\n    348,\n/**/\n    347,\n/**/\n    346,\n/**/\n    345,\n/**/\n    344,\n/**/\n    343,\n/**/\n    342,\n/**/\n    341,\n/**/\n    340,\n/**/\n    339,\n/**/\n    338,\n/**/\n    337,\n/**/\n    336,\n/**/\n    335,\n/**/\n    334,\n/**/\n    333,\n/**/\n    332,\n/**/\n    331,\n/**/\n    330,\n/**/\n    329,\n/**/\n    328,\n/**/\n    327,\n/**/\n    326,\n/**/\n    325,\n/**/\n    324,\n/**/\n    323,\n/**/\n    322,\n/**/\n    321,\n/**/\n    320,\n/**/\n    319,\n/**/\n    318,\n/**/\n    317,\n/**/\n    316,\n/**/\n    315,\n/**/\n    314,\n/**/\n    313,\n/**/\n    312,\n/**/\n    311,\n/**/\n    310,\n/**/\n    309,\n/**/\n    308,\n/**/\n    307,\n/**/\n    306,\n/**/\n    305,\n/**/\n    304,\n/**/\n    303,\n/**/\n    302,\n/**/\n    301,\n/**/\n    300,\n/**/\n    299,\n/**/\n    298,\n/**/\n    297,\n/**/\n    296,\n/**/\n    295,\n/**/\n    294,\n/**/\n    293,\n/**/\n    292,\n/**/\n    291,\n/**/\n    290,\n/**/\n    289,\n/**/\n    288,\n/**/\n    287,\n/**/\n    286,\n/**/\n    285,\n/**/\n    284,\n/**/\n    283,\n/**/\n    282,\n/**/\n    281,\n/**/\n    280,\n/**/\n    279,\n/**/\n    278,\n/**/\n    277,\n/**/\n    276,\n/**/\n    275,\n/**/\n    274,\n/**/\n    273,\n/**/\n    272,\n/**/\n    271,\n/**/\n    270,\n/**/\n    269,\n/**/\n    268,\n/**/\n    267,\n/**/\n    266,\n/**/\n    265,\n/**/\n    264,\n/**/\n    263,\n/**/\n    262,\n/**/\n    261,\n/**/\n    260,\n/**/\n    259,\n/**/\n    258,\n/**/\n    257,\n/**/\n    256,\n/**/\n    255,\n/**/\n    254,\n/**/\n    253,\n/**/\n    252,\n/**/\n    251,\n/**/\n    250,\n/**/\n    249,\n/**/\n    248,\n/**/\n    247,\n/**/\n    246,\n/**/\n    245,\n/**/\n    244,\n/**/\n    243,\n/**/\n    242,\n/**/\n    241,\n/**/\n    240,\n/**/\n    239,\n/**/\n    238,\n/**/\n    237,\n/**/\n    236,\n/**/\n    235,\n/**/\n    234,\n/**/\n    233,\n/**/\n    232,\n/**/\n    231,\n/**/\n    230,\n/**/\n    229,\n/**/\n    228,\n/**/\n    227,\n/**/\n    226,\n/**/\n    225,\n/**/\n    224,\n/**/\n    223,\n/**/\n    222,\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    for (;;)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (l == h)\n\t    break;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + ((item_count % ncol) ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#if defined(FEAT_HUGE)\n    msg_puts(_(\"\\nHuge version \"));\n#elif defined(FEAT_NORMAL)\n    msg_puts(_(\"\\nNormal version \"));\n#else\n    msg_puts(_(\"\\nTiny version \"));\n#endif\n#if !defined(FEAT_GUI)\n    msg_puts(_(\"without GUI.\"));\n#elif defined(FEAT_GUI_GTK)\n# if defined(USE_GTK3)\n    msg_puts(_(\"with GTK3 GUI.\"));\n# elif defined(FEAT_GUI_GNOME)\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n# else\n     msg_puts(_(\"with GTK2 GUI.\"));\n# endif\n#elif defined(FEAT_GUI_MOTIF)\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#elif defined(FEAT_GUI_HAIKU)\n    msg_puts(_(\"with Haiku GUI.\"));\n#elif defined(FEAT_GUI_PHOTON)\n    msg_puts(_(\"with Photon GUI.\"));\n#elif defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version9<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n"], "filenames": ["src/spell.c", "src/testdir/test_spell.vim", "src/version.c"], "buggy_code_start_loc": [2113, 159, 697], "buggy_code_end_loc": [2115, 159, 697], "fixing_code_start_loc": [2113, 160, 698], "fixing_code_end_loc": [2115, 173, 700], "type": "CWE-416", "message": "Use After Free in GitHub repository vim/vim prior to 9.0.0882.", "other": {"cve": {"id": "CVE-2022-4292", "sourceIdentifier": "security@huntr.dev", "published": "2022-12-05T19:15:10.460", "lastModified": "2023-05-03T12:16:42.000", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Use After Free in GitHub repository vim/vim prior to 9.0.0882."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-416"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-416"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:vim:vim:*:*:*:*:*:*:*:*", "versionEndExcluding": "9.0.0882", "matchCriteriaId": "FBC28741-B225-4DA7-9474-CEE34595AC82"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:netapp:ontap_select_deploy_administration_utility:-:*:*:*:*:*:*:*", "matchCriteriaId": "E7CF3019-975D-40BB-A8A4-894E62BD3797"}]}]}], "references": [{"url": "https://github.com/vim/vim/commit/c3d27ada14acd02db357f2d16347acc22cb17e93", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/da3d4c47-e57a-451e-993d-9df0ed31f57b", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/WYC22GGZ6QA66HLNLHCTAJU265TT3O33/", "source": "security@huntr.dev"}, {"url": "https://security.gentoo.org/glsa/202305-16", "source": "security@huntr.dev"}, {"url": "https://security.netapp.com/advisory/ntap-20230113-0005/", "source": "security@huntr.dev", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/vim/vim/commit/c3d27ada14acd02db357f2d16347acc22cb17e93"}}