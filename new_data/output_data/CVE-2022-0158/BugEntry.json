{"buggy_code": ["\" Tests for Vim9 script expressions\n\nsource check.vim\nsource vim9.vim\n\nlet g:cond = v:false\ndef FuncOne(arg: number): string\n  return 'yes'\nenddef\ndef FuncTwo(arg: number): number\n  return 123\nenddef\n\n\" test cond ? expr : expr\ndef Test_expr1_trinary()\n  var lines =<< trim END\n      assert_equal('one', true ? 'one' : 'two')\n      assert_equal('one', 1 ?\n                            'one' :\n                            'two')\n      if has('float')\n        assert_equal('one', !!0.1 ? 'one' : 'two')\n      endif\n      assert_equal('one', !!'x' ? 'one' : 'two')\n      assert_equal('one', !!'x'\n                            ? 'one'\n                            : 'two')\n      assert_equal('one', !!0z1234 ? 'one' : 'two')\n      assert_equal('one', !![0] ? 'one' : 'two')\n      assert_equal('one', !!{x: 0} ? 'one' : 'two')\n      var name = 1\n      assert_equal('one', name ? 'one' : 'two')\n\n      assert_equal('two', false ? 'one' : 'two')\n      assert_equal('two', 0 ? 'one' : 'two')\n      if has('float')\n        assert_equal('two', !!0.0 ? 'one' : 'two')\n      endif\n      assert_equal('two', !!'' ? 'one' : 'two')\n      assert_equal('two', !!0z ? 'one' : 'two')\n      assert_equal('two', !![] ? 'one' : 'two')\n      assert_equal('two', !!{} ? 'one' : 'two')\n      name = 0\n      assert_equal('two', name ? 'one' : 'two')\n\n      echo ['a'] + (1 ? ['b'] : ['c']\n                )\n      echo ['a'] + (1 ? ['b'] : ['c'] # comment\n                )\n\n      # with constant condition expression is not evaluated \n      assert_equal('one', 1 ? 'one' : xxx)\n\n      var Some: func = function('len')\n      var Other: func = function('winnr')\n      var Res: func = g:atrue ? Some : Other\n      assert_equal(function('len'), Res)\n\n      var RetOne: func(string): number = function('len')\n      var RetTwo: func(string): number = function('charcol')\n      var RetThat: func = g:atrue ? RetOne : RetTwo\n      assert_equal(function('len'), RetThat)\n\n      var X = FuncOne\n      var Y = FuncTwo\n      var Z = g:cond ? FuncOne : FuncTwo\n      assert_equal(123, Z(3))\n  END\n  CheckDefAndScriptSuccess(lines)\nenddef\n\ndef Test_expr1_trinary_vimscript()\n  # check line continuation\n  var lines =<< trim END\n      var name = 1\n      \t\t? 'yes'\n\t\t: 'no'\n      assert_equal('yes', name)\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  lines =<< trim END\n      var name = v:false\n      \t\t? 'yes'\n\t\t: 'no'\n      assert_equal('no', name)\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  lines =<< trim END\n      var name = v:false ?\n      \t\t'yes' :\n\t\t'no'\n      assert_equal('no', name)\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  lines =<< trim END\n      var name = v:false ?  # comment\n      \t\t'yes' :\n                # comment\n\t\t'no' # comment\n      assert_equal('no', name)\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  # check white space\n  lines =<< trim END\n      var name = v:true?1:2\n  END\n  CheckDefAndScriptFailure(lines, 'E1004: White space required before and after ''?'' at \"?1:2\"', 1)\n\n  lines =<< trim END\n      var name = v:true? 1 : 2\n  END\n  CheckDefAndScriptFailure(lines, 'E1004:', 1)\n\n  lines =<< trim END\n      var name = v:true ?1 : 2\n  END\n  CheckDefAndScriptFailure(lines, 'E1004:', 1)\n\n  lines =<< trim END\n      var name = v:true ? 1: 2\n  END\n  CheckDefAndScriptFailure(lines, 'E1004: White space required before and after '':'' at \": 2\"', 1)\n\n  lines =<< trim END\n      var name = v:true ? 1 :2\n  END\n  CheckDefAndScriptFailure(lines, 'E1004:', 1)\n\n  lines =<< trim END\n      var name = 'x' ? 1 : 2\n  END\n  CheckDefAndScriptFailure(lines, 'E1135:', 1)\n\n  lines =<< trim END\n      var name = [] ? 1 : 2\n  END\n  CheckDefExecAndScriptFailure(lines, 'E745:', 1)\n\n  lines =<< trim END\n      var name = {} ? 1 : 2\n  END\n  CheckDefExecAndScriptFailure(lines, 'E728:', 1)\n\n  # check after failure eval_flags is reset\n  lines =<< trim END\n      try\n        eval('0 ? 1: 2')\n      catch\n      endtry\n      assert_equal(v:true, eval(string(v:true)))\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  lines =<< trim END\n      try\n        eval('0 ? 1 :2')\n      catch\n      endtry\n      assert_equal(v:true, eval(string(v:true)))\n  END\n  CheckDefAndScriptSuccess(lines)\nenddef\n\nfunc Test_expr1_trinary_fails()\n  call CheckDefAndScriptFailure([\"var x = 1 ? 'one'\"], \"Missing ':' after '?'\", 1)\n\n  let msg = \"White space required before and after '?'\"\n  call CheckDefAndScriptFailure([\"var x = 1? 'one' : 'two'\"], msg, 1)\n  call CheckDefAndScriptFailure([\"var x = 1 ?'one' : 'two'\"], msg, 1)\n  call CheckDefAndScriptFailure([\"var x = 1?'one' : 'two'\"], msg, 1)\n  let lines =<< trim END\n    var x = 1\n     ?'one' : 'two'\n     # comment\n  END\n  call CheckDefAndScriptFailure(lines, 'E1004: White space required before and after ''?'' at \"?''one'' : ''two''\"', 2)\n\n  let msg = \"White space required before and after ':'\"\n  call CheckDefAndScriptFailure([\"var x = 1 ? 'one': 'two'\"], msg, 1)\n  call CheckDefAndScriptFailure([\"var x = 1 ? 'one' :'two'\"], msg, 1)\n  call CheckDefAndScriptFailure([\"var x = 1 ? 'one':'two'\"], msg, 1)\n  let lines =<< trim END\n    var x = 1 ? 'one'\n          :'two'\n          # Comment\n  END\n  call CheckDefAndScriptFailure(lines, 'E1004: White space required before and after '':'' at \":''two''\"', 2)\n\n  call CheckDefAndScriptFailure([\"var x = 'x' ? 'one' : 'two'\"], 'E1135:', 1)\n  call CheckDefAndScriptFailure([\"var x = 0z1234 ? 'one' : 'two'\"], 'E974:', 1)\n  call CheckDefExecAndScriptFailure([\"var x = [] ? 'one' : 'two'\"], 'E745:', 1)\n  call CheckDefExecAndScriptFailure([\"var x = {} ? 'one' : 'two'\"], 'E728:', 1)\n\n  call CheckDefExecFailure([\"var x = false ? \"], 'E1097:', 3)\n  call CheckScriptFailure(['vim9script', \"var x = false ? \"], 'E15:', 2)\n  call CheckDefExecFailure([\"var x = false ? 'one' : \"], 'E1097:', 3)\n  call CheckScriptFailure(['vim9script', \"var x = false ? 'one' : \"], 'E15:', 2)\n\n  call CheckDefExecAndScriptFailure([\"var x = true ? xxx : 'foo'\"], ['E1001:', 'E121:'], 1)\n  call CheckDefExecAndScriptFailure([\"var x = false ? 'foo' : xxx\"], ['E1001:', 'E121:'], 1)\n\n  if has('float')\n    call CheckDefAndScriptFailure([\"var x = 0.1 ? 'one' : 'two'\"], 'E805:', 1)\n  endif\n\n  \" missing argument detected even when common type is used\n  call CheckDefAndScriptFailure([\n\t\\ 'var X = FuncOne',\n\t\\ 'var Y = FuncTwo',\n\t\\ 'var Z = g:cond ? FuncOne : FuncTwo',\n\t\\ 'Z()'], 'E119:', 4)\nendfunc\n\ndef Test_expr1_falsy()\n  var lines =<< trim END\n      assert_equal(v:true, v:true ?? 456)\n      assert_equal(123, 123 ?? 456)\n      assert_equal('yes', 'yes' ?? 456)\n      assert_equal([1], [1] ?? 456)\n      assert_equal({one: 1}, {one: 1} ?? 456)\n      if has('float')\n        assert_equal(0.1, 0.1 ?? 456)\n      endif\n\n      assert_equal(456, v:false ?? 456)\n      assert_equal(456, 0 ?? 456)\n      assert_equal(456, '' ?? 456)\n      assert_equal(456, [] ?? 456)\n      assert_equal(456, {} ?? 456)\n      if has('float')\n        assert_equal(456, 0.0 ?? 456)\n      endif\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  var msg = \"White space required before and after '??'\"\n  call CheckDefAndScriptFailure([\"var x = 1?? 'one' : 'two'\"], msg, 1)\n  call CheckDefAndScriptFailure([\"var x = 1 ??'one' : 'two'\"], msg, 1)\n  call CheckDefAndScriptFailure([\"var x = 1??'one' : 'two'\"], msg, 1)\n  lines =<< trim END\n    var x = 1\n      ??'one' : 'two'\n      #comment\n  END\n  CheckDefAndScriptFailure(lines, 'E1004: White space required before and after ''??'' at \"??''one'' : ''two''\"', 2)\nenddef\n\ndef Record(val: any): any\n  g:vals->add(val)\n  return val\nenddef\n\n\" test ||\ndef Test_expr2()\n  var lines =<< trim END\n      assert_equal(true, 1 || 0)\n      assert_equal(true, 0 ||\n                        0 ||\n                        1)\n      assert_equal(true, 0 ||\n\t\t\t0 ||\n\t\t\t!!7)\n      assert_equal(false, 0 || 0)\n      assert_equal(false, 0\n                        || 0)\n      assert_equal(false, 0 || false)\n\n      g:vals = []\n      assert_equal(true, Record(1) || Record(3))\n      assert_equal([1], g:vals)\n\n      g:vals = []\n      assert_equal(true, Record(0) || Record(1))\n      assert_equal([0, 1], g:vals)\n\n      g:vals = []\n      assert_equal(true, Record(0) || Record(true))\n      assert_equal([0, true], g:vals)\n\n      g:vals = []\n      assert_equal(true, Record(0)\n                          || Record(1)\n                          || Record(0))\n      assert_equal([0, 1], g:vals)\n\n      g:vals = []\n      assert_equal(true, Record(0)\n\t\t\t  || Record(true)\n\t\t\t  || Record(0))\n      assert_equal([0, true], g:vals)\n\n      g:vals = []\n      assert_equal(true, Record(true) || Record(false))\n      assert_equal([true], g:vals)\n\n      g:vals = []\n      assert_equal(false, Record(0) || Record(false) || Record(0))\n      assert_equal([0, false, 0], g:vals)\n\n      g:vals = []\n      var x = 1\n      if x || true\n        g:vals = [1]\n      endif\n      assert_equal([1], g:vals)\n\n      g:vals = []\n      x = 3\n      if true || x\n        g:vals = [1]\n      endif\n      assert_equal([1], g:vals)\n  END\n  CheckDefAndScriptSuccess(lines)\nenddef\n\ndef Test_expr2_vimscript()\n  # check line continuation\n  var lines =<< trim END\n      var name = 0\n      \t\t|| 1\n      assert_equal(true, name)\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  lines =<< trim END\n      var name = v:false\n      \t\t|| v:true\n      \t\t|| v:false\n      assert_equal(v:true, name)\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  lines =<< trim END\n      var name = v:false ||\n      \t\tv:true ||\n\t\tv:false\n      assert_equal(v:true, name)\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  lines =<< trim END\n      var name = v:false || # comment\n                # comment\n      \t\tv:true ||\n                # comment\n\t\tv:false # comment\n      assert_equal(v:true, name)\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  # check white space\n  lines =<< trim END\n      var name = v:true||v:true\n  END\n  CheckDefExecAndScriptFailure(lines, 'E1004: White space required before and after ''||'' at \"||v:true\"', 1)\n\n  lines =<< trim END\n      var name = v:true ||v:true\n  END\n  CheckDefAndScriptFailure(lines, 'E1004:', 1)\n\n  lines =<< trim END\n      var name = v:true|| v:true\n  END\n  CheckDefAndScriptFailure(lines, 'E1004:', 1)\nenddef\n\ndef Test_expr2_fails()\n  var msg = \"White space required before and after '||'\"\n  call CheckDefAndScriptFailure([\"var x = 1||0\"], msg, 1)\n  call CheckDefAndScriptFailure([\"var x = 1 ||0\"], msg, 1)\n  call CheckDefAndScriptFailure([\"var x = 1|| 0\"], msg, 1)\n\n  call CheckDefFailure([\"var x = false || \"], 'E1097:', 3)\n  call CheckScriptFailure(['vim9script', \"var x = false || \"], 'E15:', 2)\n\n  # script does not fail, the second expression is skipped\n  call CheckDefFailure([\"var x = 1 || xxx\"], 'E1001:', 1)\n\n  call CheckDefAndScriptFailure([\"var x = [] || false\"], ['E1012:', 'E745:'], 1)\n\n  call CheckDefAndScriptFailure([\"if 'yes' || 0\", 'echo 0', 'endif'], ['E1012: Type mismatch; expected bool but got string', 'E1135: Using a String as a Bool'], 1)\n\n  call CheckDefAndScriptFailure([\"var x = 3 || false\"], ['E1012:', 'E1023:'], 1)\n  call CheckDefAndScriptFailure([\"var x = false || 3\"], ['E1012:', 'E1023:'], 1)\n\n  call CheckDefAndScriptFailure([\"if 3\"], 'E1023:', 1)\n  call CheckDefExecAndScriptFailure(['var x = 3', 'if x', 'endif'], 'E1023:', 2)\n\n  call CheckDefAndScriptFailure([\"var x = [] || false\"], ['E1012: Type mismatch; expected bool but got list<unknown>', 'E745:'], 1)\n\n  var lines =<< trim END\n    vim9script\n    echo false\n      ||true\n    # comment\n  END\n  CheckScriptFailure(lines, 'E1004: White space required before and after ''||'' at \"||true\"', 3)\n\n  lines =<< trim END\n      var x = false\n              || false\n              || a.b\n  END\n  CheckDefFailure(lines, 'E1001:', 3)\nenddef\n\n\" test &&\ndef Test_expr3()\n  var lines =<< trim END\n      assert_equal(false, 1 && 0)\n      assert_equal(false, 0 &&\n                    0 &&\n                    1)\n      assert_equal(true, 1\n                        && true\n                        && 1)\n      assert_equal(false, 0 && 0)\n      assert_equal(false, 0 && false)\n      assert_equal(true, 1 && true)\n\n      g:vals = []\n      assert_equal(true, Record(true) && Record(1))\n      assert_equal([true, 1], g:vals)\n\n      g:vals = []\n      assert_equal(true, Record(1) && Record(true))\n      assert_equal([1, true], g:vals)\n\n      g:vals = []\n      assert_equal(false, Record(0) && Record(1))\n      assert_equal([0], g:vals)\n\n      g:vals = []\n      assert_equal(false, Record(0) && Record(1) && Record(0))\n      assert_equal([0], g:vals)\n\n      g:vals = []\n      assert_equal(false, Record(0) && Record(4) && Record(0))\n      assert_equal([0], g:vals)\n\n      g:vals = []\n      assert_equal(false, Record(1) && Record(true) && Record(0))\n      assert_equal([1, true, 0], g:vals)\n  END\n  CheckDefAndScriptSuccess(lines)\nenddef\n\ndef Test_expr3_vimscript()\n  # check line continuation\n  var lines =<< trim END\n      var name = 0\n      \t\t&& 1\n      assert_equal(false, name)\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  lines =<< trim END\n      var name = v:true\n      \t\t&& v:true\n      \t\t&& v:true\n      assert_equal(v:true, name)\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  lines =<< trim END\n      var name = v:true &&\n      \t\tv:true &&\n      \t\tv:true\n      assert_equal(v:true, name)\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  lines =<< trim END\n      var name = v:true &&  # comment\n                # comment\n      \t\tv:true &&\n                # comment\n      \t\tv:true\n      assert_equal(v:true, name)\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  # check white space\n  lines =<< trim END\n      var name = v:true&&v:true\n  END\n  CheckDefAndScriptFailure(lines, 'E1004:', 1)\n\n  lines =<< trim END\n      var name = v:true &&v:true\n  END\n  CheckDefAndScriptFailure(lines, 'E1004: White space required before and after ''&&'' at \"&&v:true\"', 1)\n\n  lines =<< trim END\n      var name = v:true&& v:true\n  END\n  CheckDefAndScriptFailure(lines, 'E1004:', 1)\nenddef\n\ndef Test_expr3_fails()\n  var msg = \"White space required before and after '&&'\"\n  CheckDefAndScriptFailure([\"var x = 1&&0\"], msg, 1)\n  CheckDefAndScriptFailure([\"var x = 1 &&0\"], msg, 1)\n  CheckDefAndScriptFailure([\"var x = 1&& 0\"], msg, 1)\n  var lines =<< trim END\n    var x = 1\n      &&0\n    # comment\n  END\n  CheckDefAndScriptFailure(lines, 'E1004: White space required before and after ''&&'' at \"&&0\"', 2)\n\n  g:vals = []\n  CheckDefAndScriptFailure([\"if 'yes' && 0\", 'echo 0', 'endif'], ['E1012: Type mismatch; expected bool but got string', 'E1135: Using a String as a Bool'], 1)\n\n  CheckDefExecAndScriptFailure(['assert_equal(false, Record(1) && Record(4) && Record(0))'], 'E1023: Using a Number as a Bool: 4', 1)\n\n  lines =<< trim END\n      if 3\n          && true\n      endif\n  END\n  CheckDefAndScriptFailure(lines, ['E1012:', 'E1023:'], 1)\n\n  lines =<< trim END\n      if true\n          && 3\n      endif\n  END\n  CheckDefAndScriptFailure(lines, ['E1012:', 'E1023:'], 2)\n\n  lines =<< trim END\n      if 'yes'\n          && true\n      endif\n  END\n  CheckDefAndScriptFailure(lines, ['E1012:', 'E1135: Using a String as a Bool'], 1)\nenddef\n\n\" global variables to use for tests with the \"any\" type\nlet atrue = v:true\nlet afalse = v:false\nlet anone = v:none\nlet anull = v:null\nlet anint = 10\nlet theone = 1\nlet thefour = 4\nif has('float')\n  let afloat = 0.1\nendif\nlet astring = 'asdf'\nlet ablob = 0z01ab\nlet alist = [2, 3, 4]\nlet adict = #{aaa: 2, bbb: 8}\n\n\" test == comperator\ndef Test_expr4_equal()\n  var lines =<< trim END\n      var trueVar = true\n      var falseVar = false\n      assert_equal(true, true == true)\n      assert_equal(false, true ==\n                            false)\n      assert_equal(true, true\n                            == trueVar)\n      assert_equal(false, true == falseVar)\n      assert_equal(true, true == g:atrue)\n      assert_equal(false, g:atrue == false)\n\n      assert_equal(true, v:none == v:none)\n      assert_equal(false, v:none == v:null)\n      assert_equal(true, g:anone == v:none)\n      assert_equal(true, null == v:null)\n      assert_equal(true, null == g:anull)\n      assert_equal(false, v:none == g:anull)\n\n      var nr0 = 0\n      var nr61 = 61\n      assert_equal(false, 2 == 0)\n      assert_equal(false, 2 == nr0)\n      assert_equal(true, 61 == 61)\n      assert_equal(true, 61 == nr61)\n      assert_equal(true, g:anint == 10)\n      assert_equal(false, 61 == g:anint)\n\n      if has('float')\n        var ff = 0.3\n        assert_equal(true, ff == 0.3)\n        assert_equal(false, 0.4 == ff)\n        assert_equal(true, 0.1 == g:afloat)\n        assert_equal(false, g:afloat == 0.3)\n\n        ff = 3.0\n        assert_equal(true, ff == 3)\n        assert_equal(true, 3 == ff)\n        ff = 3.1\n        assert_equal(false, ff == 3)\n        assert_equal(false, 3 == ff)\n      endif\n\n      assert_equal(true, 'abc' == 'abc')\n      assert_equal(false, 'xyz' == 'abc')\n      assert_equal(true, g:astring == 'asdf')\n      assert_equal(false, 'xyz' == g:astring)\n\n      assert_equal(false, 'abc' == 'aBc')\n      assert_equal(false, 'abc' ==# 'aBc')\n      assert_equal(true, 'abc' ==? 'aBc')\n\n      assert_equal(false, 'abc' == 'ABC')\n      set ignorecase\n      assert_equal(false, 'abc' == 'ABC')\n      assert_equal(false, 'abc' ==# 'ABC')\n      assert_equal(true, 'abc' ==? 'ABC')\n      set noignorecase\n\n      var bb = 0z3f\n      assert_equal(true, 0z3f == bb)\n      assert_equal(false, bb == 0z4f)\n      assert_equal(true, g:ablob == 0z01ab)\n      assert_equal(false, 0z3f == g:ablob)\n\n      assert_equal(true, [1, 2, 3] == [1, 2, 3])\n      assert_equal(false, [1, 2, 3] == [2, 3, 1])\n      assert_equal(true, [2, 3, 4] == g:alist)\n      assert_equal(false, g:alist == [2, 3, 1])\n      assert_equal(false, [1, 2, 3] == [])\n      assert_equal(false, [1, 2, 3] == ['1', '2', '3'])\n\n      assert_equal(true, {one: 1, two: 2} == {one: 1, two: 2})\n      assert_equal(false, {one: 1, two: 2} == {one: 2, two: 2})\n      assert_equal(false, {one: 1, two: 2} == {two: 2})\n      assert_equal(false, {one: 1, two: 2} == {})\n      assert_equal(true, g:adict == {bbb: 8, aaa: 2})\n      assert_equal(false, {ccc: 9, aaa: 2} == g:adict)\n\n      assert_equal(true, function('g:Test_expr4_equal') == function('g:Test_expr4_equal'))\n      assert_equal(false, function('g:Test_expr4_equal') == function('g:Test_expr4_is'))\n\n      assert_equal(true, function('g:Test_expr4_equal', [123]) == function('g:Test_expr4_equal', [123]))\n      assert_equal(false, function('g:Test_expr4_equal', [123]) == function('g:Test_expr4_is', [123]))\n      assert_equal(false, function('g:Test_expr4_equal', [123]) == function('g:Test_expr4_equal', [999]))\n\n      if true\n        var OneFunc: func\n        var TwoFunc: func\n        OneFunc = function('len')\n        TwoFunc = function('len')\n        assert_equal(true, OneFunc('abc') == TwoFunc('123'))\n      endif\n\n      # check this doesn't fail when skipped\n      if false\n        var OneFunc: func\n        var TwoFunc: func\n        OneFunc = function('len')\n        TwoFunc = function('len')\n        assert_equal(true, OneFunc('abc') == TwoFunc('123'))\n      endif\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  CheckDefAndScriptFailure([\"var x = 'a' == xxx\"], ['E1001:', 'E121:'], 1)\n  CheckDefFailure([\"var x = 'a' == \"], 'E1097:', 3)\n  CheckScriptFailure(['vim9script', \"var x = 'a' == \"], 'E15:', 2)\n\n  CheckDefExecAndScriptFailure(['var items: any', 'eval 1 + 1', 'eval 2 + 2', 'if items == []', 'endif'], ['E691:', 'E1072:'], 4)\n\n  CheckDefExecAndScriptFailure(['var x: any = \"a\"', 'echo x == true'], 'E1072: Cannot compare string with bool', 2)\n  CheckDefExecAndScriptFailure([\"var x: any = true\", 'echo x == \"\"'], 'E1072: Cannot compare bool with string', 2)\n  CheckDefExecAndScriptFailure([\"var x: any = 99\", 'echo x == true'], ['E1138', 'E1072:'], 2)\n  CheckDefExecAndScriptFailure([\"var x: any = 'a'\", 'echo x == 99'], ['E1030:', 'E1072:'], 2)\n\n  lines =<< trim END\n      vim9script\n      var n: any = 2\n      def Compare()\n        eval n == '3'\n        g:notReached = false\n      enddef\n      g:notReached = true\n      Compare()\n  END\n  CheckScriptFailure(lines, 'E1030: Using a String as a Number: \"3\"')\n  assert_true(g:notReached)\n\n  if has('float')\n    lines =<< trim END\n        vim9script\n        var n: any = 2.2\n        def Compare()\n          eval n == '3'\n          g:notReached = false\n        enddef\n        g:notReached = true\n        Compare()\n    END\n    CheckScriptFailure(lines, 'E892: Using a String as a Float')\n    assert_true(g:notReached)\n  endif\n\n  unlet g:notReached\nenddef\n\ndef Test_expr4_wrong_type()\n  for op in ['>', '>=', '<', '<=', '=~', '!~']\n    CheckDefExecAndScriptFailure([\n        \"var a: any = 'a'\",\n        'var b: any = true',\n        'echo a ' .. op .. ' b'], 'E1072:', 3)\n  endfor\n  for op in ['>', '>=', '<', '<=']\n    CheckDefExecAndScriptFailure([\n        \"var n: any = 2\",\n        'echo n ' .. op .. ' \"3\"'], ['E1030:', 'E1072:'], 2)\n  endfor\n  for op in ['=~', '!~']\n    CheckDefExecAndScriptFailure([\n        \"var n: any = 2\",\n        'echo n ' .. op .. ' \"3\"'], 'E1072:', 2)\n  endfor\n\n  CheckDefAndScriptFailure([\n      'echo v:none == true'], 'E1072:', 1)\n  CheckDefAndScriptFailure([\n      'echo false >= true'], 'E1072:', 1)\n  CheckDefExecAndScriptFailure([\n      \"var n: any = v:none\",\n      'echo n == true'], 'E1072:', 2)\n  CheckDefExecAndScriptFailure([\n      \"var n: any = v:none\",\n      'echo n < true'], 'E1072:', 2)\nenddef\n\n\" test != comperator\ndef Test_expr4_notequal()\n  var lines =<< trim END\n      var trueVar = true\n      var falseVar = false\n      assert_equal(false, true != true)\n      assert_equal(true, true !=\n                            false)\n      assert_equal(false, true\n                            != trueVar)\n      assert_equal(true, true != falseVar)\n      assert_equal(false, true != g:atrue)\n      assert_equal(true, g:atrue != false)\n\n      assert_equal(false, v:none != v:none)\n      assert_equal(true, v:none != v:null)\n      assert_equal(false, g:anone != v:none)\n      assert_equal(true, v:none != g:anull)\n\n      var nr55 = 55\n      var nr0 = 55\n      assert_equal(true, 2 != 0)\n      assert_equal(true, 2 != nr0)\n      assert_equal(false, 55 != 55)\n      assert_equal(false, 55 != nr55)\n      assert_equal(false, g:anint != 10)\n      assert_equal(true, 61 != g:anint)\n\n      if has('float')\n        var ff = 0.3\n        assert_equal(false, 0.3 != ff)\n        assert_equal(true, 0.4 != ff)\n        assert_equal(false, 0.1 != g:afloat)\n        assert_equal(true, g:afloat != 0.3)\n\n        ff = 3.0\n        assert_equal(false, ff != 3)\n        assert_equal(false, 3 != ff)\n        ff = 3.1\n        assert_equal(true, ff != 3)\n        assert_equal(true, 3 != ff)\n      endif\n\n      assert_equal(false, 'abc' != 'abc')\n      assert_equal(true, 'xyz' != 'abc')\n      assert_equal(false, g:astring != 'asdf')\n      assert_equal(true, 'xyz' != g:astring)\n\n      assert_equal(true, 'abc' != 'ABC')\n      set ignorecase\n      assert_equal(true, 'abc' != 'ABC')\n      assert_equal(true, 'abc' !=# 'ABC')\n      assert_equal(false, 'abc' !=? 'ABC')\n      set noignorecase\n\n      var bb = 0z3f\n      assert_equal(false, 0z3f != bb)\n      assert_equal(true, bb != 0z4f)\n      assert_equal(false, g:ablob != 0z01ab)\n      assert_equal(true, 0z3f != g:ablob)\n\n      assert_equal(false, [1, 2, 3] != [1, 2, 3])\n      assert_equal(true, [1, 2, 3] != [2, 3, 1])\n      assert_equal(false, [2, 3, 4] != g:alist)\n      assert_equal(true, g:alist != [2, 3, 1])\n      assert_equal(true, [1, 2, 3] != [])\n      assert_equal(true, [1, 2, 3] != ['1', '2', '3'])\n\n      assert_equal(false, {one: 1, two: 2} != {one: 1, two: 2})\n      assert_equal(true, {one: 1, two: 2} != {one: 2, two: 2})\n      assert_equal(true, {one: 1, two: 2} != {two: 2})\n      assert_equal(true, {one: 1, two: 2} != {})\n      assert_equal(false, g:adict != {bbb: 8, aaa: 2})\n      assert_equal(true, {ccc: 9, aaa: 2} != g:adict)\n\n      assert_equal(false, function('g:Test_expr4_equal') != function('g:Test_expr4_equal'))\n      assert_equal(true, function('g:Test_expr4_equal') != function('g:Test_expr4_is'))\n\n      assert_equal(false, function('g:Test_expr4_equal', [123]) != function('g:Test_expr4_equal', [123]))\n      assert_equal(true, function('g:Test_expr4_equal', [123]) != function('g:Test_expr4_is', [123]))\n      assert_equal(true, function('g:Test_expr4_equal', [123]) != function('g:Test_expr4_equal', [999]))\n  END\n  CheckDefAndScriptSuccess(lines)\nenddef\n\n\" test > comperator\ndef Test_expr4_greater()\n  var lines =<< trim END\n      assert_true(2 > 0)\n      assert_true(2 >\n                    1)\n      assert_false(2 > 2)\n      assert_false(2 > 3)\n      var nr2 = 2\n      assert_true(nr2 > 0)\n      assert_true(nr2 >\n                    1)\n      assert_false(nr2 > 2)\n      assert_false(nr2\n                        > 3)\n      if has('float')\n        var ff = 2.0\n        assert_true(ff > 0.0)\n        assert_true(ff > 1.0)\n        assert_false(ff > 2.0)\n        assert_false(ff > 3.0)\n      endif\n  END\n  CheckDefAndScriptSuccess(lines)\nenddef\n\n\" test >= comperator\ndef Test_expr4_greaterequal()\n  var lines =<< trim END\n      assert_true(2 >= 0)\n      assert_true(2 >=\n                            2)\n      assert_false(2 >= 3)\n      var nr2 = 2\n      assert_true(nr2 >= 0)\n      assert_true(nr2 >= 2)\n      assert_false(nr2 >= 3)\n      if has('float')\n        var ff = 2.0\n        assert_true(ff >= 0.0)\n        assert_true(ff >= 2.0)\n        assert_false(ff >= 3.0)\n      endif\n  END\n  CheckDefAndScriptSuccess(lines)\nenddef\n\n\" test < comperator\ndef Test_expr4_smaller()\n  var lines =<< trim END\n      assert_false(2 < 0)\n      assert_false(2 <\n                            2)\n      assert_true(2\n                    < 3)\n      var nr2 = 2\n      assert_false(nr2 < 0)\n      assert_false(nr2 < 2)\n      assert_true(nr2 < 3)\n      if has('float')\n        var ff = 2.0\n        assert_false(ff < 0.0)\n        assert_false(ff < 2.0)\n        assert_true(ff < 3.0)\n      endif\n  END\n  CheckDefAndScriptSuccess(lines)\nenddef\n\n\" test <= comperator\ndef Test_expr4_smallerequal()\n  var lines =<< trim END\n      assert_false(2 <= 0)\n      assert_false(2 <=\n                            1)\n      assert_true(2\n                    <= 2)\n      assert_true(2 <= 3)\n      var nr2 = 2\n      assert_false(nr2 <= 0)\n      assert_false(nr2 <= 1)\n      assert_true(nr2 <= 2)\n      assert_true(nr2 <= 3)\n      if has('float')\n        var ff = 2.0\n        assert_false(ff <= 0.0)\n        assert_false(ff <= 1.0)\n        assert_true(ff <= 2.0)\n        assert_true(ff <= 3.0)\n      endif\n  END\n  CheckDefAndScriptSuccess(lines)\nenddef\n\n\" test =~ comperator\ndef Test_expr4_match()\n  var lines =<< trim END\n      assert_equal(false, '2' =~ '0')\n      assert_equal(false, ''\n                             =~ '0')\n      assert_equal(true, '2' =~\n                            '[0-9]')\n      set ignorecase\n      assert_equal(false, 'abc' =~ 'ABC')\n      assert_equal(false, 'abc' =~# 'ABC')\n      assert_equal(true, 'abc' =~? 'ABC')\n      set noignorecase\n  END\n  CheckDefAndScriptSuccess(lines)\nenddef\n\n\" test !~ comperator\ndef Test_expr4_nomatch()\n  var lines =<< trim END\n      assert_equal(true, '2' !~ '0')\n      assert_equal(true, ''\n                            !~ '0')\n      assert_equal(false, '2' !~\n                            '[0-9]')\n  END\n  CheckDefAndScriptSuccess(lines)\nenddef\n\n\" test is comperator\ndef Test_expr4_is()\n  var lines =<< trim END\n      var mylist = [2]\n      assert_false(mylist is [2])\n      var other = mylist\n      assert_true(mylist is\n                    other)\n\n      var myblob = 0z1234\n      assert_false(myblob\n                            is 0z1234)\n      var otherblob = myblob\n      assert_true(myblob is otherblob)\n  END\n  CheckDefAndScriptSuccess(lines)\nenddef\n\n\" test isnot comperator\ndef Test_expr4_isnot()\n  var lines =<< trim END\n      var mylist = [2]\n      assert_true('2' isnot '0')\n      assert_true(mylist isnot [2])\n      var other = mylist\n      assert_false(mylist isnot\n                            other)\n\n      var myblob = 0z1234\n      assert_true(myblob\n                    isnot 0z1234)\n      var otherblob = myblob\n      assert_false(myblob isnot otherblob)\n  END\n  CheckDefAndScriptSuccess(lines)\nenddef\n\ndef RetVoid()\n  var x = 1\nenddef\n\ndef Test_expr4_vim9script()\n  # check line continuation\n  var lines =<< trim END\n      var name = 0\n      \t\t< 1\n      assert_equal(true, name)\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  lines =<< trim END\n      var name = 123\n                # comment\n      \t\t!= 123\n      assert_equal(false, name)\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  lines =<< trim END\n      var name = 123 ==\n      \t\t\t123\n      assert_equal(true, name)\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  lines =<< trim END\n      var list = [1, 2, 3]\n      var name = list\n      \t\tis list\n      assert_equal(true, name)\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  lines =<< trim END\n      var list = [1, 2, 3]\n      var name = list # comment\n                 # comment\n      \t\tis list\n      assert_equal(true, name)\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  lines =<< trim END\n      var myblob = 0z1234\n      var name = myblob\n      \t\tisnot 0z11\n      assert_equal(true, name)\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  # spot check mismatching types\n  lines =<< trim END\n      echo '' == 0\n  END\n  CheckDefAndScriptFailure(lines, 'E1072:', 1)\n\n  lines =<< trim END\n      echo v:true > v:false\n  END\n  CheckDefAndScriptFailure(lines, 'Cannot compare bool with bool', 1)\n\n  lines =<< trim END\n      echo 123 is 123\n  END\n  CheckDefAndScriptFailure(lines, 'Cannot use \"is\" with number', 1)\n\n  # check missing white space\n  lines =<< trim END\n    echo 2>3\n  END\n  CheckDefAndScriptFailure(lines, 'E1004: White space required before and after ''>'' at \">3\"', 1)\n\n  lines =<< trim END\n    echo 2 >3\n  END\n  CheckDefAndScriptFailure(lines, 'E1004:', 1)\n\n  lines =<< trim END\n    echo 2> 3\n  END\n  CheckDefAndScriptFailure(lines, 'E1004:', 1)\n\n  lines =<< trim END\n    echo 2!=3\n  END\n  CheckDefAndScriptFailure(lines, 'E1004:', 1)\n\n  lines =<< trim END\n    echo 2 !=3\n  END\n  CheckDefAndScriptFailure(lines, 'E1004: White space required before and after ''!='' at \"!=3\"', 1)\n\n  lines =<< trim END\n    echo 2!= 3\n  END\n  CheckDefAndScriptFailure(lines, 'E1004:', 1)\n\n  for op in ['==', '>', '>=', '<', '<=', '=~', '!~', 'is', 'isnot']\n    lines = [\"echo 'aaa'\", op .. \"'bbb'\", '# comment']\n    var msg = printf(\"E1004: White space required before and after '%s'\", op)\n    CheckDefAndScriptFailure(lines, msg, 2)\n  endfor\n\n  lines =<< trim END\n    echo len('xxx') == 3\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  lines =<< trim END\n    var line = 'abc'\n    echo line[1] =~ '\\w'\n  END\n  CheckDefAndScriptSuccess(lines)\nenddef\n\nfunc Test_expr4_fails()\n  let msg = \"White space required before and after '>'\"\n  call CheckDefAndScriptFailure([\"var x = 1>2\"], msg, 1)\n  call CheckDefAndScriptFailure([\"var x = 1 >2\"], msg, 1)\n  call CheckDefAndScriptFailure([\"var x = 1> 2\"], msg, 1)\n\n  let msg = \"White space required before and after '=='\"\n  call CheckDefAndScriptFailure([\"var x = 1==2\"], msg, 1)\n  call CheckDefAndScriptFailure([\"var x = 1 ==2\"], msg, 1)\n  call CheckDefAndScriptFailure([\"var x = 1== 2\"], msg, 1)\n\n  let msg = \"White space required before and after 'is'\"\n  call CheckDefAndScriptFailure([\"var x = '1'is'2'\"], msg, 1)\n  call CheckDefAndScriptFailure([\"var x = '1' is'2'\"], msg, 1)\n  call CheckDefAndScriptFailure([\"var x = '1'is '2'\"], msg, 1)\n\n  let msg = \"White space required before and after 'isnot'\"\n  call CheckDefAndScriptFailure([\"var x = '1'isnot'2'\"], msg, 1)\n  call CheckDefAndScriptFailure([\"var x = '1' isnot'2'\"], msg, 1)\n  call CheckDefAndScriptFailure([\"var x = '1'isnot '2'\"], msg, 1)\n\n  call CheckDefAndScriptFailure([\"var x = 1 is# 2\"], 'E15:', 1)\n  call CheckDefAndScriptFailure([\"var x = 1 is? 2\"], 'E15:', 1)\n  call CheckDefAndScriptFailure([\"var x = 1 isnot# 2\"], 'E15:', 1)\n  call CheckDefAndScriptFailure([\"var x = 1 isnot? 2\"], 'E15:', 1)\n\n  call CheckDefAndScriptFailure([\"var x = 1 == '2'\"], 'Cannot compare number with string', 1)\n  call CheckDefAndScriptFailure([\"var x = '1' == 2\"], 'Cannot compare string with number', 1)\n  call CheckDefAndScriptFailure([\"var x = 1 == RetVoid()\"], 'Cannot compare number with void', 1)\n  call CheckDefAndScriptFailure([\"var x = RetVoid() == 1\"], 'Cannot compare void with number', 1)\n\n  call CheckDefAndScriptFailure([\"var x = true > false\"], 'Cannot compare bool with bool', 1)\n  call CheckDefAndScriptFailure([\"var x = true >= false\"], 'Cannot compare bool with bool', 1)\n  call CheckDefAndScriptFailure([\"var x = true < false\"], 'Cannot compare bool with bool', 1)\n  call CheckDefAndScriptFailure([\"var x = true <= false\"], 'Cannot compare bool with bool', 1)\n  call CheckDefAndScriptFailure([\"var x = true =~ false\"], 'Cannot compare bool with bool', 1)\n  call CheckDefAndScriptFailure([\"var x = true !~ false\"], 'Cannot compare bool with bool', 1)\n  call CheckDefAndScriptFailure([\"var x = true is false\"], 'Cannot use \"is\" with bool', 1)\n  call CheckDefAndScriptFailure([\"var x = true isnot false\"], 'Cannot use \"isnot\" with bool', 1)\n\n  call CheckDefAndScriptFailure([\"var x = v:none is v:null\"], 'Cannot use \"is\" with special', 1)\n  call CheckDefAndScriptFailure([\"var x = v:none isnot v:null\"], 'Cannot use \"isnot\" with special', 1)\n  call CheckDefAndScriptFailure([\"var x = 123 is 123\"], 'Cannot use \"is\" with number', 1)\n  call CheckDefAndScriptFailure([\"var x = 123 isnot 123\"], 'Cannot use \"isnot\" with number', 1)\n  if has('float')\n    call CheckDefAndScriptFailure([\"var x = 1.3 is 1.3\"], 'Cannot use \"is\" with float', 1)\n    call CheckDefAndScriptFailure([\"var x = 1.3 isnot 1.3\"], 'Cannot use \"isnot\" with float', 1)\n  endif\n\n  call CheckDefAndScriptFailure([\"var x = 0za1 > 0z34\"], 'Cannot compare blob with blob', 1)\n  call CheckDefAndScriptFailure([\"var x = 0za1 >= 0z34\"], 'Cannot compare blob with blob', 1)\n  call CheckDefAndScriptFailure([\"var x = 0za1 < 0z34\"], 'Cannot compare blob with blob', 1)\n  call CheckDefAndScriptFailure([\"var x = 0za1 <= 0z34\"], 'Cannot compare blob with blob', 1)\n  call CheckDefAndScriptFailure([\"var x = 0za1 =~ 0z34\"], 'Cannot compare blob with blob', 1)\n  call CheckDefAndScriptFailure([\"var x = 0za1 !~ 0z34\"], 'Cannot compare blob with blob', 1)\n\n  call CheckDefAndScriptFailure([\"var x = [13] > [88]\"], 'Cannot compare list with list', 1)\n  call CheckDefAndScriptFailure([\"var x = [13] >= [88]\"], 'Cannot compare list with list', 1)\n  call CheckDefAndScriptFailure([\"var x = [13] < [88]\"], 'Cannot compare list with list', 1)\n  call CheckDefAndScriptFailure([\"var x = [13] <= [88]\"], 'Cannot compare list with list', 1)\n  call CheckDefAndScriptFailure([\"var x = [13] =~ [88]\"], 'Cannot compare list with list', 1)\n  call CheckDefAndScriptFailure([\"var x = [13] !~ [88]\"], 'Cannot compare list with list', 1)\n\n  call CheckDefAndScriptFailure(['var j: job', 'var chan: channel', 'var r = j == chan'], 'Cannot compare job with channel', 3)\n  call CheckDefAndScriptFailure(['var j: job', 'var x: list<any>', 'var r = j == x'], 'Cannot compare job with list', 3)\n  call CheckDefAndScriptFailure(['var j: job', 'var Xx: func', 'var r = j == Xx'], 'Cannot compare job with func', 3)\n  call CheckDefAndScriptFailure(['var j: job', 'var Xx: func', 'var r = j == Xx'], 'Cannot compare job with func', 3)\nendfunc\n\n\" test addition, subtraction, concatenation\ndef Test_expr5()\n  var lines =<< trim END\n      assert_equal(66, 60 + 6)\n      assert_equal(70, 60 +\n                            g:anint)\n      assert_equal(9, g:thefour\n                            + 5)\n      assert_equal(14, g:thefour + g:anint)\n      assert_equal([1, 2, 3, 4], [1] + g:alist)\n\n      assert_equal(54, 60 - 6)\n      assert_equal(50, 60 -\n                        g:anint)\n      assert_equal(-1, g:thefour\n                            - 5)\n      assert_equal(-6, g:thefour - g:anint)\n\n      assert_equal('hello', 'hel' .. 'lo')\n      assert_equal('hello 123', 'hello ' ..\n                                            123)\n      assert_equal('hello 123', 'hello '\n                                    ..  123)\n      assert_equal('123 hello', 123 .. ' hello')\n      assert_equal('123456', 123 .. 456)\n\n      assert_equal('atrue', 'a' .. true)\n      assert_equal('afalse', 'a' .. false)\n      assert_equal('anull', 'a' .. v:null)\n      assert_equal('av:none', 'a' .. v:none)\n      if has('float')\n        assert_equal('a0.123', 'a' .. 0.123)\n      endif\n\n      assert_equal(3, 1 + [2, 3, 4][0])\n      assert_equal(5, 2 + {key: 3}['key'])\n\n      set digraph\n      assert_equal('val: true', 'val: ' .. &digraph)\n      set nodigraph\n      assert_equal('val: false', 'val: ' .. &digraph)\n\n      assert_equal([1, 2, 3, 4], [1, 2] + [3, 4])\n      assert_equal(0z11223344, 0z1122 + 0z3344)\n      assert_equal(0z112201ab, 0z1122\n                                    + g:ablob)\n      assert_equal(0z01ab3344, g:ablob + 0z3344)\n      assert_equal(0z01ab01ab, g:ablob + g:ablob)\n\n      # concatenate non-constant to constant\n      var save_path = &path\n      &path = 'b'\n      assert_equal('ab', 'a' .. &path)\n      &path = save_path\n\n      @b = 'b'\n      assert_equal('ab', 'a' .. @b)\n\n      $ENVVAR = 'env'\n      assert_equal('aenv', 'a' .. $ENVVAR)\n\n      assert_equal('val', '' .. {key: 'val'}['key'])\n  END\n  CheckDefAndScriptSuccess(lines)\nenddef\n\ndef Test_expr5_vim9script()\n  # check line continuation\n  var lines =<< trim END\n      var name = 11\n      \t\t+ 77\n\t\t- 22\n      assert_equal(66, name)\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  lines =<< trim END\n      var name = 11 +\n\t\t  77 -\n\t\t  22\n      assert_equal(66, name)\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  lines =<< trim END\n      var name = 11 +  # comment\n\t\t  77 -\n                  # comment\n\t\t  22\n      assert_equal(66, name)\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  lines =<< trim END\n      var name = 'one'\n      \t\t.. 'two'\n      assert_equal('onetwo', name)\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  lines =<< trim END\n      echo 'abc' is# 'abc'\n  END\n  CheckDefAndScriptFailure(lines, 'E15:', 1)\n\n  lines =<< trim END\n      echo {} - 22\n  END\n  CheckDefAndScriptFailure(lines, ['E1036:', 'E728:'], 1)\n\n  lines =<< trim END\n      echo [] - 33\n  END\n  CheckDefAndScriptFailure(lines, ['E1036:', 'E745:'], 1)\n\n  lines =<< trim END\n      echo 0z1234 - 44\n  END\n  CheckDefAndScriptFailure(lines, ['E1036', 'E974:'], 1)\n\n  lines =<< trim END\n      echo 'abc' is? 'abc'\n  END\n  CheckDefAndScriptFailure(lines, 'E15:', 1)\n\n  lines =<< trim END\n      echo 'abc' isnot# 'abc'\n  END\n  CheckDefAndScriptFailure(lines, 'E15:', 1)\n\n  lines =<< trim END\n      echo 'abc' isnot? 'abc'\n  END\n  CheckDefAndScriptFailure(lines, 'E15:', 1)\n\n  # check white space\n  lines =<< trim END\n      echo 5+6\n  END\n  CheckDefAndScriptFailure(lines, 'E1004:', 1)\n  lines =<< trim END\n      echo 5 +6\n  END\n  CheckDefAndScriptFailure(lines, 'E1004:', 1)\n\n  lines =<< trim END\n      echo 5+ 6\n  END\n  CheckDefAndScriptFailure(lines, 'E1004:', 1)\n\n  lines =<< trim END\n      echo 'a'..'b'\n  END\n  CheckDefAndScriptFailure(lines, 'E1004: White space required before and after ''..'' at \"..''b''\"', 1)\n\n  lines =<< trim END\n      echo 'a' ..'b'\n  END\n  CheckDefAndScriptFailure(lines, 'E1004:', 1)\n\n  lines =<< trim END\n      echo 'a'.. 'b'\n  END\n  CheckDefAndScriptFailure(lines, 'E1004: White space required before and after ''..'' at \".. ''b''\"', 1)\n\n  lines =<< trim END\n      echo 'a'\n          ..'b'\n      # comment\n  END\n  CheckDefAndScriptFailure(lines, 'E1004: White space required before and after ''..'' at \"..''b''\"', 2)\n\n  # check invalid string concatenation\n  lines =<< trim END\n      echo 'a' .. [1]\n  END\n  CheckDefAndScriptFailure(lines, ['E1105:', 'E730:'], 1)\n\n  lines =<< trim END\n      echo 'a' .. {a: 1}\n  END\n  CheckDefAndScriptFailure(lines, ['E1105:', 'E731:'], 1)\n\n  lines =<< trim END\n      echo 'a' .. test_void()\n  END\n  CheckDefAndScriptFailure(lines, ['E1105:', 'E908:'], 1)\n\n  lines =<< trim END\n      echo 'a' .. 0z33\n  END\n  CheckDefAndScriptFailure(lines, ['E1105:', 'E976:'], 1)\n\n  lines =<< trim END\n      echo 'a' .. function('len')\n  END\n  CheckDefAndScriptFailure(lines, ['E1105:', 'E729:'], 1)\n\n  lines =<< trim END\n      new\n      ['']->setline(1)\n      /pattern\n\n      eval 0\n      bwipe!\n  END\n  CheckDefAndScriptFailure(lines, \"E1004: White space required before and after '/' at \\\"/pattern\", 3)\n\n  for op in ['+', '-']\n    lines = ['var x = 1', op .. '2', '# comment']\n    var msg = printf(\"E1004: White space required before and after '%s' at \\\"%s2\\\"\", op, op)\n    CheckDefAndScriptFailure(lines, msg, 2)\n  endfor\nenddef\n\ndef Test_expr5_vim9script_channel()\n  if !has('channel')\n    MissingFeature 'channel'\n  else\n    var lines =<< trim END\n        echo 'a' .. test_null_job()\n    END\n    CheckDefAndScriptFailure(lines, ['E1105:', 'E908:'], 1)\n    lines =<< trim END\n        echo 'a' .. test_null_channel()\n    END\n    CheckDefAndScriptFailure(lines, ['E1105:', 'E908:'], 1)\n  endif\nenddef\n\ndef Test_expr5_float()\n  if !has('float')\n    MissingFeature 'float'\n  else\n    var lines =<< trim END\n        assert_equal(66.0, 60.0 + 6.0)\n        assert_equal(66.0, 60.0 + 6)\n        assert_equal(66.0, 60 +\n                             6.0)\n        assert_equal(5.1, g:afloat\n                            + 5)\n        assert_equal(8.1, 8 + g:afloat)\n        assert_equal(10.1, g:anint + g:afloat)\n        assert_equal(10.1, g:afloat + g:anint)\n\n        assert_equal(54.0, 60.0 - 6.0)\n        assert_equal(54.0, 60.0\n                                - 6)\n        assert_equal(54.0, 60 - 6.0)\n        assert_equal(-4.9, g:afloat - 5)\n        assert_equal(7.9, 8 - g:afloat)\n        assert_equal(9.9, g:anint - g:afloat)\n        assert_equal(-9.9, g:afloat - g:anint)\n    END\n    CheckDefAndScriptSuccess(lines)\n  endif\nenddef\n\nfunc Test_expr5_fails()\n  let msg = \"White space required before and after '+'\"\n  call CheckDefAndScriptFailure([\"var x = 1+2\"], msg, 1)\n  call CheckDefAndScriptFailure([\"var x = 1 +2\"], msg, 1)\n  call CheckDefAndScriptFailure([\"var x = 1+ 2\"], msg, 1)\n\n  let msg = \"White space required before and after '-'\"\n  call CheckDefAndScriptFailure([\"var x = 1-2\"], msg, 1)\n  call CheckDefAndScriptFailure([\"var x = 1 -2\"], msg, 1)\n  call CheckDefAndScriptFailure([\"var x = 1- 2\"], msg, 1)\n\n  let msg = \"White space required before and after '..'\"\n  call CheckDefAndScriptFailure([\"var x = '1'..'2'\"], msg, 1)\n  call CheckDefAndScriptFailure([\"var x = '1' ..'2'\"], msg, 1)\n  call CheckDefAndScriptFailure([\"var x = '1'.. '2'\"], msg, 1)\n\n  call CheckDefAndScriptFailure([\"var x = 0z1122 + 33\"], ['E1051:', 'E974:'], 1)\n  call CheckDefAndScriptFailure([\"var x = 0z1122 + [3]\"], ['E1051:', 'E974:'], 1)\n  call CheckDefAndScriptFailure([\"var x = 0z1122 + 'asd'\"], ['E1051:', 'E974:'], 1)\n  call CheckDefAndScriptFailure([\"var x = 33 + 0z1122\"], ['E1051:', 'E974:'], 1)\n  call CheckDefAndScriptFailure([\"var x = [3] + 0z1122\"], ['E1051:', 'E745:'], 1)\n  call CheckDefAndScriptFailure([\"var x = 'asdf' + 0z1122\"], ['E1051:', 'E1030:'], 1)\n  call CheckDefAndScriptFailure([\"var x = 6 + xxx\"], ['E1001:', 'E121:'], 1)\n\n  call CheckDefAndScriptFailure([\"var x = 'a' .. [1]\"], ['E1105:', 'E730:'], 1)\n  call CheckDefAndScriptFailure([\"var x = 'a' .. {a: 1}\"], ['E1105:', 'E731:'], 1)\n  call CheckDefAndScriptFailure([\"var x = 'a' .. test_void()\"], ['E1105:', 'E908:'], 1)\n  call CheckDefAndScriptFailure([\"var x = 'a' .. 0z32\"], ['E1105:', 'E976:'], 1)\n  call CheckDefAndScriptFailure([\"var x = 'a' .. function('len')\"], ['E1105:', 'E729:'], 1)\n  call CheckDefAndScriptFailure([\"var x = 'a' .. function('len', ['a'])\"], ['E1105:', 'E729:'], 1)\n\n  call CheckDefAndScriptFailure(['var x = 1 + v:none'], ['E1051:', 'E611:'], 1)\n  call CheckDefAndScriptFailure(['var x = 1 + v:null'], ['E1051:', 'E611:'], 1)\n  call CheckDefAndScriptFailure(['var x = 1 + v:true'], ['E1051:', 'E1138:'], 1)\n  call CheckDefAndScriptFailure(['var x = 1 + v:false'], ['E1051:', 'E1138:'], 1)\n  call CheckDefAndScriptFailure(['var x = 1 + true'], ['E1051:', 'E1138:'], 1)\n  call CheckDefAndScriptFailure(['var x = 1 + false'], ['E1051:', 'E1138:'], 1)\nendfunc\n\nfunc Test_expr5_fails_channel()\n  CheckFeature channel\n  call CheckDefAndScriptFailure([\"var x = 'a' .. test_null_job()\"], ['E1105:', 'E908:'], 1)\n  call CheckDefAndScriptFailure([\"var x = 'a' .. test_null_channel()\"], ['E1105:', 'E908:'], 1)\nendfunc\n\ndef Test_expr5_list_add()\n  var lines =<< trim END\n      # concatenating two lists with same member types is OK\n      var d = {}\n      for i in ['a'] + ['b']\n        d = {[i]: 0}\n      endfor\n\n      # concatenating two lists with different member types results in \"any\"\n      var dany = {}\n      for i in ['a'] + [12]\n        dany[i] = i\n      endfor\n      assert_equal({a: 'a', 12: 12}, dany)\n\n      # result of glob() is \"any\", runtime type check\n      var sl: list<string> = glob('*.txt', false, true) + ['']\n  END\n  CheckDefAndScriptSuccess(lines)\nenddef\n\n\" test multiply, divide, modulo\ndef Test_expr6()\n  var lines =<< trim END\n      assert_equal(36, 6 * 6)\n      assert_equal(24, 6 *\n                            g:thefour)\n      assert_equal(24, g:thefour\n                            * 6)\n      assert_equal(40, g:anint * g:thefour)\n\n      assert_equal(10, 60 / 6)\n      assert_equal(6, 60 /\n                            g:anint)\n      assert_equal(1, g:anint / 6)\n      assert_equal(2, g:anint\n                            / g:thefour)\n\n      assert_equal(5, 11 % 6)\n      assert_equal(4, g:anint % 6)\n      assert_equal(3, 13 %\n                            g:anint)\n      assert_equal(2, g:anint\n                            % g:thefour)\n\n      assert_equal(4, 6 * 4 / 6)\n\n      var x = [2]\n      var y = [3]\n      assert_equal(5, x[0] + y[0])\n      assert_equal(6, x[0] * y[0])\n      if has('float')\n        var xf = [2.0]\n        var yf = [3.0]\n        assert_equal(5.0, xf[0]\n                            + yf[0])\n        assert_equal(6.0, xf[0]\n                            * yf[0])\n      endif\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  CheckDefAndScriptFailure([\"var x = 6 * xxx\"], ['E1001:', 'E121:'], 1)\n  CheckDefFailure([\"var d = 6 * \"], 'E1097:', 3)\n  CheckScriptFailure(['vim9script', \"var d = 6 * \"], 'E15:', 2)\n\n  CheckDefExecAndScriptFailure(['echo 1 / 0'], 'E1154', 1)\n  CheckDefExecAndScriptFailure(['echo 1 % 0'], 'E1154', 1)\n\n  lines =<< trim END\n    var n = 0\n    eval 1 / n\n  END\n  CheckDefExecAndScriptFailure(lines, 'E1154', 2)\n\n  lines =<< trim END\n    var n = 0\n    eval 1 % n\n  END\n  CheckDefExecAndScriptFailure(lines, 'E1154', 2)\nenddef\n\ndef Test_expr6_vim9script()\n  # check line continuation\n  var lines =<< trim END\n      var name = 11\n      \t\t* 22\n\t\t/ 3\n      assert_equal(80, name)\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  lines =<< trim END\n      var name = 25\n      \t\t% 10\n      assert_equal(5, name)\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  lines =<< trim END\n      var name = 25\n                # comment\n\n                # comment\n      \t\t% 10\n      assert_equal(5, name)\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  lines =<< trim END\n      var name = 11 *\n      \t\t22 /\n\t\t3\n      assert_equal(80, name)\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  # check white space\n  lines =<< trim END\n      echo 5*6\n  END\n  CheckDefAndScriptFailure(lines, 'E1004:', 1)\n\n  lines =<< trim END\n      echo 5 *6\n  END\n  CheckDefAndScriptFailure(lines, 'E1004:', 1)\n\n  lines =<< trim END\n      echo 5* 6\n  END\n  CheckDefAndScriptFailure(lines, 'E1004:', 1)\nenddef\n\ndef Test_expr6_float()\n  if !has('float')\n    MissingFeature 'float'\n  else\n    var lines =<< trim END\n        assert_equal(36.0, 6.0 * 6)\n        assert_equal(36.0, 6 *\n                               6.0)\n        assert_equal(36.0, 6.0 * 6.0)\n        assert_equal(1.0, g:afloat * g:anint)\n\n        assert_equal(10.0, 60 / 6.0)\n        assert_equal(10.0, 60.0 /\n                            6)\n        assert_equal(10.0, 60.0 / 6.0)\n        assert_equal(0.01, g:afloat / g:anint)\n\n        assert_equal(4.0, 6.0 * 4 / 6)\n        assert_equal(4.0, 6 *\n                            4.0 /\n                            6)\n        assert_equal(4.0, 6 * 4 / 6.0)\n        assert_equal(4.0, 6.0 * 4.0 / 6)\n        assert_equal(4.0, 6 * 4.0 / 6.0)\n        assert_equal(4.0, 6.0 * 4 / 6.0)\n        assert_equal(4.0, 6.0 * 4.0 / 6.0)\n\n        assert_equal(4.0, 6.0 * 4.0 / 6.0)\n    END\n    CheckDefAndScriptSuccess(lines)\n  endif\nenddef\n\nfunc Test_expr6_fails()\n  let msg = \"White space required before and after '*'\"\n  call CheckDefAndScriptFailure([\"var x = 1*2\"], msg, 1)\n  call CheckDefAndScriptFailure([\"var x = 1 *2\"], msg, 1)\n  call CheckDefAndScriptFailure([\"var x = 1* 2\"], msg, 1)\n\n  let msg = \"White space required before and after '/'\"\n  call CheckDefAndScriptFailure([\"var x = 1/2\"], msg, 1)\n  call CheckDefAndScriptFailure([\"var x = 1 /2\"], msg, 1)\n  call CheckDefAndScriptFailure([\"var x = 1/ 2\"], msg, 1)\n\n  let msg = \"White space required before and after '%'\"\n  call CheckDefAndScriptFailure([\"var x = 1%2\"], msg, 1)\n  call CheckDefAndScriptFailure([\"var x = 1 %2\"], msg, 1)\n  call CheckDefAndScriptFailure([\"var x = 1% 2\"], msg, 1)\n\n  call CheckDefAndScriptFailure([\"var x = '1' * '2'\"], ['E1036:', 'E1030:'], 1)\n  call CheckDefAndScriptFailure([\"var x = '1' / '2'\"], ['E1036:', 'E1030:'], 1)\n  call CheckDefAndScriptFailure([\"var x = '1' % '2'\"], ['E1035:', 'E1030:'], 1)\n\n  call CheckDefAndScriptFailure([\"var x = 0z01 * 0z12\"], ['E1036:', 'E974:'], 1)\n  call CheckDefAndScriptFailure([\"var x = 0z01 / 0z12\"], ['E1036:', 'E974:'], 1)\n  call CheckDefAndScriptFailure([\"var x = 0z01 % 0z12\"], ['E1035:', 'E974:'], 1)\n\n  call CheckDefAndScriptFailure([\"var x = [1] * [2]\"], ['E1036:', 'E745:'], 1)\n  call CheckDefAndScriptFailure([\"var x = [1] / [2]\"], ['E1036:', 'E745:'], 1)\n  call CheckDefAndScriptFailure([\"var x = [1] % [2]\"], ['E1035:', 'E745:'], 1)\n\n  call CheckDefAndScriptFailure([\"var x = {one: 1} * {two: 2}\"], ['E1036:', 'E728:'], 1)\n  call CheckDefAndScriptFailure([\"var x = {one: 1} / {two: 2}\"], ['E1036:', 'E728:'], 1)\n  call CheckDefAndScriptFailure([\"var x = {one: 1} % {two: 2}\"], ['E1035:', 'E728:'], 1)\n\n  call CheckDefAndScriptFailure([\"var x = 0xff[1]\"], ['E1107:', 'E1062:'], 1)\n  if has('float')\n    call CheckDefAndScriptFailure([\"var x = 0.7[1]\"], ['E1107:', 'E806:'], 1)\n  endif\n\n  for op in ['*', '/', '%']\n    let lines = ['var x = 1', op .. '2', '# comment']\n    let msg = printf(\"E1004: White space required before and after '%s' at \\\"%s2\\\"\", op, op)\n    call CheckDefAndScriptFailure(lines, msg, 2)\n  endfor\nendfunc\n\nfunc Test_expr6_float_fails()\n  CheckFeature float\n  call CheckDefAndScriptFailure([\"var x = 1.0 % 2\"], ['E1035:', 'E804:'], 1)\nendfunc\n\n\" define here to use old style parsing\nif has('float')\n  let g:float_zero = 0.0\n  let g:float_neg = -9.8\n  let g:float_big = 9.9e99\nendif\nlet g:blob_empty = 0z\nlet g:blob_one = 0z01\nlet g:blob_long = 0z0102.0304\n\nlet g:string_empty = ''\nlet g:string_short = 'x'\nlet g:string_long = 'abcdefghijklm'\nlet g:string_special = \"ab\\ncd\\ref\\ekk\"\n\nlet g:special_true = v:true\nlet g:special_false = v:false\nlet g:special_null = v:null\nlet g:special_none = v:none\n\nlet g:list_empty = []\nlet g:list_mixed = [1, 'b', v:false]\n\nlet g:dict_empty = {}\nlet g:dict_one = #{one: 1}\n\nlet $TESTVAR = 'testvar'\n\n\" type casts\ndef Test_expr7t()\n  var lines =<< trim END\n      var ls: list<string> = ['a', <string>g:string_empty]\n      var ln: list<number> = [<number>g:anint, <number>g:thefour]\n      var nr = <number>234\n      assert_equal(234, nr)\n      var b: bool = <bool>1\n      assert_equal(true, b)\n      var text =\n            <string>\n              'text'\n      if false\n        text = <number>'xxx'\n      endif\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  CheckDefAndScriptFailure([\"var x = <nr>123\"], 'E1010:', 1)\n  CheckDefFailure([\"var x = <number>\"], 'E1097:', 3)\n  CheckDefFailure([\"var x = <number>string(1)\"], 'E1012:', 1)\n  CheckScriptFailure(['vim9script', \"var x = <number>\"], 'E15:', 2)\n  CheckDefAndScriptFailure([\"var x = <number >123\"], 'E1068:', 1)\n  CheckDefAndScriptFailure([\"var x = <number 123\"], 'E1104:', 1)\nenddef\n\n\" test low level expression\ndef Test_expr7_number()\n  # number constant\n  var lines =<< trim END\n      assert_equal(0, 0)\n      assert_equal(654, 0654)\n\n      assert_equal(6, 0x6)\n      assert_equal(15, 0xf)\n      assert_equal(255, 0xff)\n  END\n  CheckDefAndScriptSuccess(lines)\nenddef\n\ndef Test_expr7_float()\n  # float constant\n  if !has('float')\n    MissingFeature 'float'\n  else\n    var lines =<< trim END\n        assert_equal(g:float_zero, .0)\n        assert_equal(g:float_zero, 0.0)\n        assert_equal(g:float_neg, -9.8)\n        assert_equal(g:float_big, 9.9e99)\n    END\n    CheckDefAndScriptSuccess(lines)\n  endif\nenddef\n\ndef Test_expr7_blob()\n  # blob constant\n  var lines =<< trim END\n      assert_equal(g:blob_empty, 0z)\n      assert_equal(g:blob_one, 0z01)\n      assert_equal(g:blob_long, 0z0102.0304)\n\n      var testblob = 0z010203\n      assert_equal(0x01, testblob[0])\n      assert_equal(0x02, testblob[1])\n      assert_equal(0x03, testblob[-1])\n      assert_equal(0x02, testblob[-2])\n\n      assert_equal(0z01, testblob[0 : 0])\n      assert_equal(0z0102, testblob[0 : 1])\n      assert_equal(0z010203, testblob[0 : 2])\n      assert_equal(0z010203, testblob[0 : ])\n      assert_equal(0z0203, testblob[1 : ])\n      assert_equal(0z0203, testblob[1 : 2])\n      assert_equal(0z0203, testblob[1 : -1])\n      assert_equal(0z03, testblob[-1 : -1])\n      assert_equal(0z02, testblob[-2 : -2])\n\n      # blob slice accepts out of range\n      assert_equal(0z, testblob[3 : 3])\n      assert_equal(0z, testblob[0 : -4])\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  CheckDefAndScriptFailure([\"var x = 0z123\"], 'E973:', 1)\nenddef\n\ndef Test_expr7_string()\n  # string constant\n  var lines =<< trim END\n      assert_equal(g:string_empty, '')\n      assert_equal(g:string_empty, \"\")\n      assert_equal(g:string_short, 'x')\n      assert_equal(g:string_short, \"x\")\n      assert_equal(g:string_long, 'abcdefghijklm')\n      assert_equal(g:string_long, \"abcdefghijklm\")\n      assert_equal(g:string_special, \"ab\\ncd\\ref\\ekk\")\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  CheckDefAndScriptFailure(['var x = \"abc'], 'E114:', 1)\n  CheckDefAndScriptFailure([\"var x = 'abc\"], 'E115:', 1)\nenddef\n\ndef Test_expr7_vimvar()\n  v:errors = []\n  var errs: list<string> = v:errors\n  CheckDefFailure(['var errs: list<number> = v:errors'], 'E1012:')\n\n  var old: list<string> = v:oldfiles\n  CheckDefFailure(['var old: list<number> = v:oldfiles'], 'E1012:')\n\n  var compl: dict<string> = v:completed_item\n  CheckDefFailure(['var compl: dict<number> = v:completed_item'], 'E1012:')\n\n  var args: list<string> = v:argv\n  CheckDefFailure(['var args: list<number> = v:argv'], 'E1012:')\n\n  var colors: dict<string> = v:colornames\n  CheckDefFailure(['var colors: dict<number> = v:colornames'], 'E1012:')\n\n  CheckDefFailure([\"var old: list<number> = v:oldfiles\"], 'E1012: Type mismatch; expected list<number> but got list<string>', 1)\n  CheckScriptFailure(['vim9script', 'v:oldfiles = [\"foo\"]', \"var old: list<number> = v:oldfiles\"], 'E1012: Type mismatch; expected list<number> but got list<string>', 3)\n  new\n  exec \"normal! afoo fo\\<C-N>\\<Esc>\"\n  CheckDefExecAndScriptFailure([\"var old: dict<number> = v:completed_item\"], 'E1012: Type mismatch; expected dict<number> but got dict<string>', 1)\n  bwipe!\nenddef\n\ndef Test_expr7_special()\n  # special constant\n  var lines =<< trim END\n      assert_equal(g:special_true, true)\n      assert_equal(g:special_false, false)\n      assert_equal(g:special_true, v:true)\n      assert_equal(g:special_false, v:false)\n      assert_equal(v:true, true)\n      assert_equal(v:false, false)\n\n      assert_equal(true, !false)\n      assert_equal(false, !true)\n      assert_equal(true, !0)\n      assert_equal(false, !1)\n      assert_equal(false, !!false)\n      assert_equal(true, !!true)\n      assert_equal(false, !!0)\n      assert_equal(true, !!1)\n\n      var t = true\n      var f = false\n      assert_equal(true, t)\n      assert_equal(false, f)\n\n      assert_equal(g:special_null, v:null)\n      assert_equal(g:special_null, null)\n      assert_equal(g:special_none, v:none)\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  CheckDefAndScriptFailure(['v:true = true'], 'E46:', 1)\n  CheckDefAndScriptFailure(['v:true = false'], 'E46:', 1)\n  CheckDefAndScriptFailure(['v:false = true'], 'E46:', 1)\n  CheckDefAndScriptFailure(['v:null = 11'], 'E46:', 1)\n  CheckDefAndScriptFailure(['v:none = 22'], 'E46:', 1)\nenddef\n\ndef Test_expr7_list()\n  # list\n  var lines =<< trim END\n      assert_equal(g:list_empty, [])\n      assert_equal(g:list_empty, [  ])\n\n      var numbers: list<number> = [1, 2, 3]\n      numbers = [1]\n      numbers = []\n\n      var strings: list<string> = ['a', 'b', 'c']\n      strings = ['x']\n      strings = []\n\n      var mixed: list<any> = [1, 'b', false,]\n      assert_equal(g:list_mixed, mixed)\n      assert_equal('b', mixed[1])\n\n      echo [1,\n            2] [3,\n                    4]\n\n      var llstring: list<list<string>> = [['text'], []]\n      llstring = [[], ['text']]\n      llstring = [[], []]\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  var rangelist: list<number> = range(3)\n  g:rangelist = range(3)\n  CheckDefExecAndScriptFailure([\"var x: list<string> = g:rangelist\"], 'E1012: Type mismatch; expected list<string> but got list<number>', 1)\n\n  CheckDefAndScriptFailure([\"var x = 1234[3]\"], ['E1107:', 'E1062:'], 1)\n  CheckDefExecAndScriptFailure([\"var x = g:anint[3]\"], 'E1062:', 1)\n\n  CheckDefAndScriptFailure([\"var x = g:list_mixed[xxx]\"], ['E1001:', 'E121:'], 1)\n\n  CheckDefAndScriptFailure([\"var x = [1,2,3]\"], 'E1069:', 1)\n  CheckDefAndScriptFailure([\"var x = [1 ,2, 3]\"], 'E1068:', 1)\n\n  CheckDefExecAndScriptFailure([\"echo 1\", \"var x = [][0]\", \"echo 3\"], 'E684:', 2)\n\n  CheckDefExecAndScriptFailure([\"var x = g:list_mixed['xx']\"], ['E1012:', 'E1030:'], 1)\n  CheckDefFailure([\"var x = g:list_mixed[\"], 'E1097:', 3)\n  CheckScriptFailure(['vim9script', \"var x = g:list_mixed[\"], 'E15:', 2)\n  CheckDefFailure([\"var x = g:list_mixed[0\"], 'E1097:', 3)\n  CheckScriptFailure(['vim9script', \"var x = g:list_mixed[0\"], 'E111:', 2)\n  CheckDefExecAndScriptFailure([\"var x = g:list_empty[3]\"], 'E684:', 1)\n  CheckDefExecAndScriptFailure([\"var l: list<number> = [234, 'x']\"], 'E1012:', 1)\n  CheckDefExecAndScriptFailure([\"var l: list<number> = ['x', 234]\"], 'E1012:', 1)\n  CheckDefExecAndScriptFailure([\"var l: list<string> = [234, 'x']\"], 'E1012:', 1)\n  CheckDefExecAndScriptFailure([\"var l: list<string> = ['x', 123]\"], 'E1012:', 1)\n\n  lines =<< trim END\n      var datalist: list<string>\n      def Main()\n        datalist += ['x'.\n      enddef\n      Main()\n  END\n  CheckDefAndScriptFailure(lines, 'E1127:')\n\n  lines =<< trim END\n      var numbers = [1, 2, 3, 4]\n      var a = 1\n      var b = 2\n  END\n  CheckDefAndScriptFailure(lines + ['echo numbers[1:b]'],\n      'E1004: White space required before and after '':'' at \":b]\"', 4)\n  CheckDefAndScriptFailure(lines + ['echo numbers[1: b]'], 'E1004:', 4)\n  CheckDefAndScriptFailure(lines + ['echo numbers[a :b]'], 'E1004:', 4)\nenddef\n\ndef Test_expr7_list_vim9script()\n  var lines =<< trim END\n      var l = [\n\t\t11,\n\t\t22,\n\t\t]\n      assert_equal([11, 22], l)\n\n      echo [1,\n\t    2] [3,\n\t\t    4]\n\n      echo [1, # comment\n            # comment\n\t    2] [3,\n            # comment\n\t\t    4]\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  lines =<< trim END\n      var l = [11,\n\t\t22]\n      assert_equal([11, 22], l)\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  lines =<< trim END\n      var l = [11,22]\n  END\n  CheckDefAndScriptFailure(lines, 'E1069:', 1)\n\n  lines =<< trim END\n      var l = [11 , 22]\n  END\n  CheckDefAndScriptFailure(lines, 'E1068:', 1)\n\n  lines =<< trim END\n    var l: list<number> = [234, 'x']\n  END\n  CheckDefAndScriptFailure(lines, 'E1012:', 1)\n\n  lines =<< trim END\n    var l: list<number> = ['x', 234]\n  END\n  CheckDefAndScriptFailure(lines, 'E1012:', 1)\n\n  lines =<< trim END\n    var l: list<string> = ['x', 234]\n  END\n  CheckDefAndScriptFailure(lines, 'E1012:', 1)\n\n  lines =<< trim END\n    var l: list<string> = [234, 'x']\n  END\n  CheckDefAndScriptFailure(lines, 'E1012:', 1)\n\n  lines =<< trim END\n      def Failing()\n        job_stop()\n      enddef\n      var list = [Failing]\n  END\n  if has('channel')\n    CheckDefAndScriptFailure(lines, 'E119:', 0)\n  else\n    CheckDefAndScriptFailure(lines, 'E117:', 0)\n  endif\nenddef\n\ndef LambdaWithComments(): func\n  return (x) =>\n            # some comment\n            x == 1\n            # some comment\n            ||\n            x == 2\nenddef\n\ndef LambdaUsingArg(x: number): func\n  return () =>\n            # some comment\n            x == 1\n            # some comment\n            ||\n            x == 2\nenddef\n\ndef Test_expr7_lambda()\n  var lines =<< trim END\n      var La = () => 'result'\n      # comment\n      assert_equal('result', La())\n      assert_equal([1, 3, 5], [1, 2, 3]->map((key, val) => key + val))\n\n      # line continuation inside lambda with \"cond ? expr : expr\" works\n      var ll = range(3)\n      var dll = mapnew(ll, (k, v) => v % 2 ? {\n                ['111']: 111 } : {}\n            )\n      assert_equal([{}, {111: 111}, {}], dll)\n\n      # comment halfway an expression\n      var Ref = () => 4\n      # comment\n      + 6\n      assert_equal(10, Ref())\n\n      ll = range(3)\n      map(ll, (k, v) => v == 8 || v\n                    == 9\n                    || v % 2 ? 111 : 222\n            )\n      assert_equal([222, 111, 222], ll)\n\n      ll = range(3)\n      map(ll, (k, v) => v != 8 && v\n                    != 9\n                    && v % 2 == 0 ? 111 : 222\n            )\n      assert_equal([111, 222, 111], ll)\n\n      var dl = [{key: 0}, {key: 22}]->filter(( _, v) => !!v['key'] )\n      assert_equal([{key: 22}], dl)\n\n      dl = [{key: 12}, {['foo']: 34}]\n      assert_equal([{key: 12}], filter(dl,\n            (_, v) => has_key(v, 'key') ? v['key'] == 12 : 0))\n\n      assert_equal(false, LambdaWithComments()(0))\n      assert_equal(true, LambdaWithComments()(1))\n      assert_equal(true, LambdaWithComments()(2))\n      assert_equal(false, LambdaWithComments()(3))\n\n      assert_equal(false, LambdaUsingArg(0)())\n      assert_equal(true, LambdaUsingArg(1)())\n\n      var res = map([1, 2, 3], (i: number, v: number) => i + v)\n      assert_equal([1, 3, 5], res)\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  CheckDefAndScriptFailure([\"var Ref = (a)=>a + 1\"], 'E1004:')\n  CheckDefAndScriptFailure([\"var Ref = (a)=> a + 1\"], 'E1004: White space required before and after ''=>'' at \"=> a + 1\"')\n  CheckDefAndScriptFailure([\"var Ref = (a) =>a + 1\"], 'E1004:')\n  CheckDefAndScriptFailure([\"var Ref = (a) =< a + 1\"], ['E1001:', 'E121:'])\n  CheckDefAndScriptFailure([\"var Ref = (a: int) => a + 1\"], 'E1010:')\n  CheckDefAndScriptFailure([\"var Ref = (a): int => a + 1\"], 'E1010:')\n\n  CheckDefAndScriptFailure([\"filter([1, 2], (k,v) => 1)\"], 'E1069:', 1)\n  # error is in first line of the lambda\n  CheckDefAndScriptFailure([\"var L = (a) => a + b\"], 'E1001:', 0)\n\n  assert_equal('xxxyyy', 'xxx'->((a, b) => a .. b)('yyy'))\n\n  CheckDefExecFailure([\"var s = 'asdf'->((a) => a)('x')\"], 'E118:')\n  CheckDefExecFailure([\"var s = 'asdf'->((a) => a)('x', 'y')\"], 'E118:')\n  CheckDefAndScriptFailure([\"echo 'asdf'->((a) => a)(x)\"], ['E1001:', 'E121:'], 1)\n\n  CheckDefAndScriptSuccess(['var Fx = (a) => ({k1: 0,', ' k2: 1})'])\n  CheckDefAndScriptFailure(['var Fx = (a) => ({k1: 0', ' k2: 1})'], 'E722:', 2)\n  CheckDefAndScriptFailure(['var Fx = (a) => ({k1: 0,', ' k2 1})'], 'E720:', 2)\n\n  CheckDefAndScriptSuccess(['var Fx = (a) => [0,', ' 1]'])\n  CheckDefAndScriptFailure(['var Fx = (a) => [0', ' 1]'], 'E696:', 2)\n\n  # no error for existing script variable when checking for lambda\n  lines =<< trim END\n    var name = 0\n    eval (name + 2) / 3\n  END\n  CheckDefAndScriptSuccess(lines)\nenddef\n\ndef Test_expr7_lambda_block()\n  var lines =<< trim END\n      var Func = (s: string): string => {\n                      return 'hello ' .. s\n                    }\n      assert_equal('hello there', Func('there'))\n\n      var ll = range(3)\n      var dll = mapnew(ll, (k, v): string => {\n          if v % 2\n            return 'yes'\n          endif\n          return 'no'\n        })\n      assert_equal(['no', 'yes', 'no'], dll)\n\n      # ignored_inline(0, (_) => {\n      #   echo 'body'\n      # })\n\n      sandbox var Safe = (nr: number): number => {\n          return nr + 7\n        }\n      assert_equal(10, Safe(3))\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  lines =<< trim END\n      map([1, 2], (k, v) => { redrawt })\n  END\n  CheckDefAndScriptFailure(lines, 'E488')\n\n  lines =<< trim END\n      var Func = (nr: int) => {\n              echo nr\n            }\n  END\n  CheckDefAndScriptFailure(lines, 'E1010', 1)\n\n  lines =<< trim END\n      var Func = (nr: number): int => {\n              return nr\n            }\n  END\n  CheckDefAndScriptFailure(lines, 'E1010', 1)\n\n  lines =<< trim END\n      var Func = (nr: number): int => {\n              return nr\n  END\n  CheckDefFailure(lines, 'E1171', 0)  # line nr is function start\n  CheckScriptFailure(['vim9script'] + lines, 'E1171', 2)\n\n  lines =<< trim END\n      var Func = (nr: number): int => {\n          var ll =<< ENDIT\n             nothing\n  END\n  CheckDefFailure(lines, 'E1145: Missing heredoc end marker: ENDIT', 0)\n  CheckScriptFailure(['vim9script'] + lines, 'E1145: Missing heredoc end marker: ENDIT', 2)\nenddef\n\ndef NewLambdaWithComments(): func\n  return (x) =>\n            # some comment\n            x == 1\n            # some comment\n            ||\n            x == 2\nenddef\n\ndef NewLambdaUsingArg(x: number): func\n  return () =>\n            # some comment\n            x == 1\n            # some comment\n            ||\n            x == 2\nenddef\n\ndef Test_expr7_new_lambda()\n  var lines =<< trim END\n      var La = () => 'result'\n      assert_equal('result', La())\n      assert_equal([1, 3, 5], [1, 2, 3]->map((key, val) => key + val))\n\n      # line continuation inside lambda with \"cond ? expr : expr\" works\n      var ll = range(3)\n      var dll = mapnew(ll, (k, v) => v % 2 ? {\n                ['111']: 111 } : {}\n            )\n      assert_equal([{}, {111: 111}, {}], dll)\n\n      ll = range(3)\n      map(ll, (k, v) => v == 8 || v\n                    == 9\n                    || v % 2 ? 111 : 222\n            )\n      assert_equal([222, 111, 222], ll)\n\n      ll = range(3)\n      map(ll, (k, v) => v != 8 && v\n                    != 9\n                    && v % 2 == 0 ? 111 : 222\n            )\n      assert_equal([111, 222, 111], ll)\n\n      var dl = [{key: 0}, {key: 22}]->filter(( _, v) => !!v['key'] )\n      assert_equal([{key: 22}], dl)\n\n      dl = [{key: 12}, {['foo']: 34}]\n      assert_equal([{key: 12}], filter(dl,\n            (_, v) => has_key(v, 'key') ? v['key'] == 12 : 0))\n\n      assert_equal(false, NewLambdaWithComments()(0))\n      assert_equal(true, NewLambdaWithComments()(1))\n      assert_equal(true, NewLambdaWithComments()(2))\n      assert_equal(false, NewLambdaWithComments()(3))\n\n      assert_equal(false, NewLambdaUsingArg(0)())\n      assert_equal(true, NewLambdaUsingArg(1)())\n\n      var res = map([1, 2, 3], (i: number, v: number) => i + v)\n      assert_equal([1, 3, 5], res)\n\n      # Lambda returning a dict\n      var Lmb = () => ({key: 42})\n      assert_equal({key: 42}, Lmb())\n\n      var RefOne: func(number): string = (a: number): string => 'x'\n      var RefTwo: func(number): any = (a: number): any => 'x'\n\n      var Fx = (a) => ({k1: 0,\n                         k2: 1})\n      var Fy = (a) => [0,\n                       1]\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  CheckDefAndScriptFailure([\"var Ref = (a)=>a + 1\"], 'E1004:')\n  CheckDefAndScriptFailure([\"var Ref = (a)=> a + 1\"], 'E1004:')\n  CheckDefAndScriptFailure([\"var Ref = (a) =>a + 1\"],\n      'E1004: White space required before and after ''=>'' at \" =>a + 1\"')\n\n  CheckDefAndScriptFailure([\"var Ref: func(number): number = (a: number): string => 'x'\"], 'E1012:')\n  CheckDefAndScriptFailure([\"var Ref: func(number): string = (a: number): string => 99\"], 'E1012:')\n\n  CheckDefAndScriptFailure([\"filter([1, 2], (k,v) => 1)\"], 'E1069:', 1)\n  # error is in first line of the lambda\n  CheckDefAndScriptFailure([\"var L = (a) -> a + b\"], ['E1001:', 'E121:'], 1)\n\n  assert_equal('xxxyyy', 'xxx'->((a, b) => a .. b)('yyy'))\n\n  CheckDefExecFailure([\"var s = 'asdf'->((a) => a)('x')\"],\n        'E118: Too many arguments for function:')\n  CheckDefExecFailure([\"var s = 'asdf'->((a) => a)('x', 'y')\"],\n        'E118: Too many arguments for function:')\n  CheckDefFailure([\"echo 'asdf'->((a) => a)(x)\"], 'E1001:', 1)\n\n  CheckDefAndScriptFailure(['var Fx = (a) => ({k1: 0', ' k2: 1})'], 'E722:', 2)\n  CheckDefAndScriptFailure(['var Fx = (a) => ({k1: 0,', ' k2 1})'], 'E720:', 2)\n\n  CheckDefAndScriptFailure(['var Fx = (a) => [0', ' 1]'], 'E696:', 2)\nenddef\n\ndef Test_expr7_lambda_vim9script()\n  var lines =<< trim END\n      var v = 10->((a) =>\n\t    a\n\t      + 2\n            )()\n      assert_equal(12, v)\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  # nested lambda with line breaks\n  lines =<< trim END\n      search('\"', 'cW', 0, 0, () =>\n\tsynstack('.', col('.'))\n          ->mapnew((_, v) => synIDattr(v, 'name'))->len())\n  END\n  CheckDefAndScriptSuccess(lines)\nenddef\n\ndef Test_expr7_funcref()\n  var lines =<< trim END\n      def RetNumber(): number\n        return 123\n      enddef\n      var FuncRef = RetNumber\n      assert_equal(123, FuncRef())\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      func g:GlobalFunc()\n        return 'global'\n      endfunc\n      func s:ScriptFunc()\n        return 'script'\n      endfunc\n      def Test()\n        var Ref = g:GlobalFunc\n        assert_equal('global', Ref())\n        Ref = GlobalFunc\n        assert_equal('global', Ref())\n\n        Ref = s:ScriptFunc\n        assert_equal('script', Ref())\n        Ref = ScriptFunc\n        assert_equal('script', Ref())\n      enddef\n      Test()\n  END\n  CheckScriptSuccess(lines)\nenddef\n\nlet g:test_space_dict = {'': 'empty', ' ': 'space'}\nlet g:test_hash_dict = #{one: 1, two: 2}\n\ndef Test_expr7_dict()\n  # dictionary\n  var lines =<< trim END\n      assert_equal(g:dict_empty, {})\n      assert_equal(g:dict_empty, {  })\n      assert_equal(g:dict_one, {['one']: 1})\n      var key = 'one'\n      var val = 1\n      assert_equal(g:dict_one, {[key]: val})\n\n      var numbers: dict<number> = {a: 1, b: 2, c: 3}\n      numbers = {a: 1}\n      numbers = {}\n\n      var strings: dict<string> = {a: 'a', b: 'b', c: 'c'}\n      strings = {a: 'x'}\n      strings = {}\n\n      var dash = {xx-x: 8}\n      assert_equal({['xx-x']: 8}, dash)\n\n      var dnr = {8: 8}\n      assert_equal({['8']: 8}, dnr)\n\n      var mixed: dict<any> = {a: 'a', b: 42}\n      mixed = {a: 'x'}\n      mixed = {a: 234}\n      mixed = {}\n\n      var dictlist: dict<list<string>> = {absent: [], present: ['hi']}\n      dictlist = {absent: ['hi'], present: []}\n      dictlist = {absent: [], present: []}\n\n      var dictdict: dict<dict<string>> = {one: {a: 'text'}, two: {}}\n      dictdict = {one: {}, two: {a: 'text'}}\n      dictdict = {one: {}, two: {}}\n\n      assert_equal({['']: 0}, {[matchstr('string', 'wont match')]: 0})\n\n      assert_equal(g:test_space_dict, {['']: 'empty', [' ']: 'space'})\n      assert_equal(g:test_hash_dict, {one: 1, two: 2})\n\n      assert_equal({['a a']: 1, ['b/c']: 2}, {'a a': 1, \"b/c\": 2})\n\n      var d = {a: () => 3, b: () => 7}\n      assert_equal(3, d.a())\n      assert_equal(7, d.b())\n\n      var cd = { # comment\n                key: 'val' # comment\n               }\n\n      # different types used for the key\n      var dkeys = {['key']: 'string',\n                   [12]: 'numberexpr',\n                   34: 'number',\n                   [true]: 'bool'} \n      assert_equal('string', dkeys['key'])\n      assert_equal('numberexpr', dkeys[12])\n      assert_equal('number', dkeys[34])\n      assert_equal('bool', dkeys[true])\n      if has('float')\n        dkeys = {[1.2]: 'floatexpr', [3.4]: 'float'}\n        assert_equal('floatexpr', dkeys[1.2])\n        assert_equal('float', dkeys[3.4])\n      endif\n\n      # automatic conversion from number to string\n      var n = 123\n      var dictnr = {[n]: 1}\n\n      # comment to start fold is OK\n      var x1: number #{{ fold\n      var x2 = 9 #{{ fold\n  END\n  CheckDefAndScriptSuccess(lines)\n \n  # legacy syntax doesn't work\n  CheckDefAndScriptFailure([\"var x = #{key: 8}\"], 'E1170:', 1)\n  CheckDefAndScriptFailure([\"var x = 'a' #{a: 1}\"], 'E1170:', 1)\n  CheckDefAndScriptFailure([\"var x = 'a' .. #{a: 1}\"], 'E1170:', 1)\n  CheckDefAndScriptFailure([\"var x = true ? #{a: 1}\"], 'E1170:', 1)\n\n  CheckDefAndScriptFailure([\"var x = {a:8}\"], 'E1069:', 1)\n  CheckDefAndScriptFailure([\"var x = {a : 8}\"], 'E1068:', 1)\n  CheckDefAndScriptFailure([\"var x = {a :8}\"], 'E1068:', 1)\n  CheckDefAndScriptFailure([\"var x = {a: 8 , b: 9}\"], 'E1068:', 1)\n  CheckDefAndScriptFailure([\"var x = {a: 1,b: 2}\"], 'E1069:', 1)\n\n  CheckDefAndScriptFailure([\"var x = {xxx}\"], 'E720:', 1)\n  CheckDefAndScriptFailure([\"var x = {xxx: 1\", \"var y = 2\"], 'E722:', 2)\n  CheckDefFailure([\"var x = {xxx: 1,\"], 'E723:', 2)\n  CheckScriptFailure(['vim9script', \"var x = {xxx: 1,\"], 'E723:', 2)\n  CheckDefAndScriptFailure([\"var x = {['a']: xxx}\"], ['E1001:', 'E121:'], 1)\n  CheckDefAndScriptFailure([\"var x = {a: 1, a: 2}\"], 'E721:', 1)\n  CheckDefExecAndScriptFailure([\"var x = g:anint.member\"], ['E715:', 'E488:'], 1)\n  CheckDefExecAndScriptFailure([\"var x = g:dict_empty.member\"], 'E716:', 1)\n\n  CheckDefExecAndScriptFailure(['var x: dict<number> = {a: 234, b: \"1\"}'], 'E1012:', 1)\n  CheckDefExecAndScriptFailure(['var x: dict<number> = {a: \"x\", b: 134}'], 'E1012:', 1)\n  CheckDefExecAndScriptFailure(['var x: dict<string> = {a: 234, b: \"1\"}'], 'E1012:', 1)\n  CheckDefExecAndScriptFailure(['var x: dict<string> = {a: \"x\", b: 134}'], 'E1012:', 1)\n\n  # invalid types for the key\n  CheckDefAndScriptFailure([\"var x = {[[1, 2]]: 0}\"], ['E1105:', 'E730:'], 1)\n\n  CheckDefFailure(['var x = ({'], 'E723:', 2)\n  CheckScriptFailure(['vim9script', 'var x = ({'], 'E723:', 2)\n  CheckDefExecAndScriptFailure(['{}[getftype(\"file\")]'], 'E716: Key not present in Dictionary: \"\"', 1)\nenddef\n\ndef Test_expr7_dict_vim9script()\n  var lines =<< trim END\n      var d = {\n\t\t['one']:\n\t\t   1,\n\t\t['two']: 2,\n\t\t   }\n      assert_equal({one: 1, two: 2}, d)\n\n      d = {  # comment\n\t\t['one']:\n                # comment\n\n\t\t   1,\n                # comment\n                # comment\n\t\t['two']: 2,\n\t\t   }\n      assert_equal({one: 1, two: 2}, d)\n\n      var dd = {k: 123->len()}\n      assert_equal(3, dd.k)\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  lines =<< trim END\n      var d = { [\"one\"]: \"one\", [\"two\"]: \"two\", }\n      assert_equal({one: 'one', two: 'two'}, d)\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  lines =<< trim END\n      var d = {one: 1,\n\t\ttwo: 2,\n\t       }\n      assert_equal({one: 1, two: 2}, d)\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  lines =<< trim END\n      var d = {one:1, two: 2}\n  END\n  CheckDefAndScriptFailure(lines, 'E1069:', 1)\n\n  lines =<< trim END\n      var d = {one: 1,two: 2}\n  END\n  CheckDefAndScriptFailure(lines, 'E1069:', 1)\n\n  lines =<< trim END\n      var d = {one : 1}\n  END\n  CheckDefAndScriptFailure(lines, 'E1068:', 1)\n\n  lines =<< trim END\n      var d = {one:1}\n  END\n  CheckDefAndScriptFailure(lines, 'E1069:', 1)\n\n  lines =<< trim END\n      var d = {one: 1 , two: 2}\n  END\n  CheckDefAndScriptFailure(lines, 'E1068:', 1)\n\n  lines =<< trim END\n    var l: dict<number> = {a: 234, b: 'x'}\n  END\n  CheckDefAndScriptFailure(lines, 'E1012:', 1)\n\n  lines =<< trim END\n    var l: dict<number> = {a: 'x', b: 234}\n  END\n  CheckDefAndScriptFailure(lines, 'E1012:', 1)\n\n  lines =<< trim END\n    var l: dict<string> = {a: 'x', b: 234}\n  END\n  CheckDefAndScriptFailure(lines, 'E1012:', 1)\n\n  lines =<< trim END\n    var l: dict<string> = {a: 234, b: 'x'}\n  END\n  CheckDefAndScriptFailure(lines, 'E1012:', 1)\n\n  lines =<< trim END\n    var d = {['a']: 234, ['b': 'x'}\n  END\n  CheckDefAndScriptFailure(lines, 'E1139:', 1)\n\n  lines =<< trim END\n    def Func()\n      var d = {['a']: 234, ['b': 'x'}\n    enddef\n    defcompile\n  END\n  CheckDefAndScriptFailure(lines, 'E1139:', 0)\n\n  lines =<< trim END\n    var d = {'a':\n  END\n  CheckDefFailure(lines, 'E723:', 2)\n  CheckScriptFailure(['vim9script'] + lines, 'E15:', 2)\n\n  lines =<< trim END\n    def Func()\n      var d = {'a':\n    enddef\n    defcompile\n  END\n  CheckDefAndScriptFailure(lines, 'E723:', 0)\n\n  lines =<< trim END\n      def Failing()\n        job_stop()\n      enddef\n      var dict = {name: Failing}\n  END\n  if has('channel')\n    CheckDefAndScriptFailure(lines, 'E119:', 0)\n  else\n    CheckDefAndScriptFailure(lines, 'E117:', 0)\n  endif\n\n  lines =<< trim END\n      vim9script\n      var x = 99\n      assert_equal({x: 99}, s:)\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Test_expr7_dict_in_block()\n  var lines =<< trim END\n      vim9script\n      command MyCommand {\n          echo {\n              k: 0, }\n      }\n      MyCommand\n\n      command YourCommand {\n         g:global = {\n           key: 'value' }\n         }\n      YourCommand\n      assert_equal({key: 'value'}, g:global)\n      unlet g:global\n  END\n  CheckScriptSuccess(lines)\n\n  delcommand MyCommand\n  delcommand YourCommand\nenddef\n\ndef Test_expr7_call_2bool()\n  var lines =<< trim END\n      vim9script\n\n      def BrokenCall(nr: number, mode: bool, use: string): void\n        assert_equal(3, nr)\n        assert_equal(false, mode)\n        assert_equal('ab', use)\n      enddef\n\n      def TestBrokenCall(): void\n        BrokenCall(3, 0, 'ab')\n      enddef\n\n      TestBrokenCall()\n  END\n  CheckScriptSuccess(lines)\nenddef\n\nlet g:oneString = 'one'\n\ndef Test_expr_member()\n  var lines =<< trim END\n      assert_equal(1, g:dict_one.one)\n      var d: dict<number> = g:dict_one\n      assert_equal(1, d['one'])\n      assert_equal(1, d[\n                      'one'\n                      ])\n      assert_equal(1, d\n            .one)\n      d = {1: 1, _: 2}\n      assert_equal(1, d\n            .1)\n      assert_equal(2, d\n            ._)\n\n      # getting the one member should clear the dict after getting the item\n      assert_equal('one', {one: 'one'}.one)\n      assert_equal('one', {one: 'one'}[g:oneString])\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  CheckDefAndScriptFailure([\"var x = g:dict_one.#$!\"], ['E1002:', 'E15:'], 1)\n  CheckDefExecAndScriptFailure([\"var d: dict<any>\", \"echo d['a']\"], 'E716:', 2)\n  CheckDefExecAndScriptFailure([\"var d: dict<number>\", \"d = g:list_empty\"], 'E1012: Type mismatch; expected dict<number> but got list<unknown>', 2)\nenddef\n\ndef Test_expr7_any_index_slice()\n  var lines =<< trim END\n    # getting the one member should clear the list only after getting the item\n    assert_equal('bbb', ['aaa', 'bbb', 'ccc'][1])\n\n    # string is permissive, index out of range accepted\n    g:teststring = 'abcdef'\n    assert_equal('b', g:teststring[1])\n    assert_equal('f', g:teststring[-1])\n    assert_equal('', g:teststring[99])\n\n    assert_equal('b', g:teststring[1 : 1])\n    assert_equal('bcdef', g:teststring[1 :])\n    assert_equal('abcd', g:teststring[: 3])\n    assert_equal('cdef', g:teststring[-4 :])\n    assert_equal('abcdef', g:teststring[-9 :])\n    assert_equal('abcd', g:teststring[: -3])\n    assert_equal('', g:teststring[: -9])\n\n    # composing characters are included\n    g:teststring = 'a\u0300e\u0301u\u0302'\n    assert_equal('a\u0300', g:teststring[0])\n    assert_equal('e\u0301', g:teststring[1])\n    assert_equal('u\u0302', g:teststring[2])\n    assert_equal('', g:teststring[3])\n    assert_equal('', g:teststring[4])\n\n    assert_equal('u\u0302', g:teststring[-1])\n    assert_equal('e\u0301', g:teststring[-2])\n    assert_equal('a\u0300', g:teststring[-3])\n    assert_equal('', g:teststring[-4])\n    assert_equal('', g:teststring[-5])\n\n    assert_equal('a\u0300', g:teststring[0 : 0])\n    assert_equal('e\u0301', g:teststring[1 : 1])\n    assert_equal('a\u0300e\u0301', g:teststring[0 : 1])\n    assert_equal('a\u0300e\u0301u\u0302', g:teststring[0 : -1])\n    assert_equal('a\u0300e\u0301', g:teststring[0 : -2])\n    assert_equal('a\u0300', g:teststring[0 : -3])\n    assert_equal('', g:teststring[0 : -4])\n    assert_equal('', g:teststring[0 : -5])\n    assert_equal('a\u0300e\u0301u\u0302', g:teststring[ : ])\n    assert_equal('a\u0300e\u0301u\u0302', g:teststring[0 : ])\n    assert_equal('e\u0301u\u0302', g:teststring[1 : ])\n    assert_equal('u\u0302', g:teststring[2 : ])\n    assert_equal('', g:teststring[3 : ])\n    assert_equal('', g:teststring[4 : ])\n\n    # blob index cannot be out of range\n    g:testblob = 0z01ab\n    assert_equal(0x01, g:testblob[0])\n    assert_equal(0xab, g:testblob[1])\n    assert_equal(0xab, g:testblob[-1])\n    assert_equal(0x01, g:testblob[-2])\n\n    # blob slice accepts out of range\n    assert_equal(0z01ab, g:testblob[0 : 1])\n    assert_equal(0z01, g:testblob[0 : 0])\n    assert_equal(0z01, g:testblob[-2 : -2])\n    assert_equal(0zab, g:testblob[1 : 1])\n    assert_equal(0zab, g:testblob[-1 : -1])\n    assert_equal(0z, g:testblob[2 : 2])\n    assert_equal(0z, g:testblob[0 : -3])\n\n    # list index cannot be out of range\n    g:testlist = [0, 1, 2, 3]\n    assert_equal(0, g:testlist[0])\n    assert_equal(1, g:testlist[1])\n    assert_equal(3, g:testlist[3])\n    assert_equal(3, g:testlist[-1])\n    assert_equal(0, g:testlist[-4])\n    assert_equal(1, g:testlist[g:theone])\n\n    # list slice accepts out of range\n    assert_equal([0], g:testlist[0 : 0])\n    assert_equal([3], g:testlist[3 : 3])\n    assert_equal([0, 1], g:testlist[0 : 1])\n    assert_equal([0, 1, 2, 3], g:testlist[0 : 3])\n    assert_equal([0, 1, 2, 3], g:testlist[0 : 9])\n    assert_equal([], g:testlist[-1 : 1])\n    assert_equal([1], g:testlist[-3 : 1])\n    assert_equal([0, 1], g:testlist[-4 : 1])\n    assert_equal([0, 1], g:testlist[-9 : 1])\n    assert_equal([1, 2, 3], g:testlist[1 : -1])\n    assert_equal([1], g:testlist[1 : -3])\n    assert_equal([], g:testlist[1 : -4])\n    assert_equal([], g:testlist[1 : -9])\n\n    g:testdict = {a: 1, b: 2}\n    assert_equal(1, g:testdict['a'])\n    assert_equal(2, g:testdict['b'])\n  END\n\n  CheckDefAndScriptSuccess(lines)\n\n  CheckDefExecAndScriptFailure(['echo g:testblob[2]'], 'E979:', 1)\n  CheckDefExecAndScriptFailure(['echo g:testblob[-3]'], 'E979:', 1)\n\n  CheckDefExecAndScriptFailure(['echo g:testlist[4]'], 'E684: list index out of range: 4', 1)\n  CheckDefExecAndScriptFailure(['echo g:testlist[-5]'], 'E684:', 1)\n\n  CheckDefExecAndScriptFailure(['echo g:testdict[\"a\" : \"b\"]'], 'E719:', 1)\n  CheckDefExecAndScriptFailure(['echo g:testdict[1]'], 'E716:', 1)\n\n  unlet g:teststring\n  unlet g:testblob\n  unlet g:testlist\nenddef\n\ndef Test_expr_member_vim9script()\n  var lines =<< trim END\n      var d = {one:\n      \t\t'one',\n\t\ttwo: 'two',\n\t\t1: 1,\n\t\t_: 2}\n      assert_equal('one', d.one)\n      assert_equal('one', d\n                            .one)\n      assert_equal(1, d\n                            .1)\n      assert_equal(2, d\n                            ._)\n      assert_equal('one', d[\n\t\t\t    'one'\n\t\t\t    ])\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  lines =<< trim END\n      var l = [1,\n\t\t  2,\n\t\t  3, 4\n\t\t  ]\n      assert_equal(2, l[\n\t\t\t    1\n\t\t\t    ])\n      assert_equal([2, 3], l[1 : 2])\n      assert_equal([1, 2, 3], l[\n\t\t\t\t:\n\t\t\t\t2\n\t\t\t\t])\n      assert_equal([3, 4], l[\n\t\t\t\t2\n\t\t\t\t:\n\t\t\t\t])\n  END\n  CheckDefAndScriptSuccess(lines)\nenddef\n\ndef SetSomeVar()\n  b:someVar = &fdm\nenddef\n\ndef Test_expr7_option()\n  var lines =<< trim END\n      # option\n      set ts=11\n      assert_equal(11, &ts)\n      &ts = 9\n      assert_equal(9, &ts)\n      set ts=8\n      set grepprg=some\\ text\n      assert_equal('some text', &grepprg)\n      &grepprg = test_null_string()\n      assert_equal('', &grepprg)\n      set grepprg&\n\n      # check matching type\n      var bval: bool = &tgc\n      var nval: number = &ts\n      var sval: string = &path\n\n      # check v_lock is cleared (requires using valgrind, doesn't always show)\n      SetSomeVar()\n      b:someVar = 0\n      unlet b:someVar\n  END\n  CheckDefAndScriptSuccess(lines)\nenddef\n\ndef Test_expr7_environment()\n  var lines =<< trim END\n      # environment variable\n      assert_equal('testvar', $TESTVAR)\n      assert_equal('', $ASDF_ASD_XXX)\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  CheckDefAndScriptFailure([\"var x = $$$\"], ['E1002:', 'E15:'], 1)\nenddef\n\ndef Test_expr7_register()\n  var lines =<< trim END\n      @a = 'register a'\n      assert_equal('register a', @a)\n\n      var fname = expand('%')\n      assert_equal(fname, @%)\n\n      feedkeys(\":echo 'some'\\<CR>\", \"xt\")\n      assert_equal(\"echo 'some'\", @:)\n\n      normal axyz\n      assert_equal(\"xyz\", @.)\n\n      @/ = 'slash'\n      assert_equal('slash', @/)\n\n      @= = 'equal'\n      assert_equal('equal', @=)\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  CheckDefAndScriptFailure([\"@. = 'yes'\"], ['E354:', 'E488:'], 1)\nenddef\n\n\" This is slow when run under valgrind.\ndef Test_expr7_namespace()\n  var lines =<< trim END\n      g:some_var = 'some'\n      assert_equal('some', get(g:, 'some_var'))\n      assert_equal('some', get(g:, 'some_var', 'xxx'))\n      assert_equal('xxx', get(g:, 'no_var', 'xxx'))\n      unlet g:some_var\n\n      b:some_var = 'some'\n      assert_equal('some', get(b:, 'some_var'))\n      assert_equal('some', get(b:, 'some_var', 'xxx'))\n      assert_equal('xxx', get(b:, 'no_var', 'xxx'))\n      unlet b:some_var\n\n      w:some_var = 'some'\n      assert_equal('some', get(w:, 'some_var'))\n      assert_equal('some', get(w:, 'some_var', 'xxx'))\n      assert_equal('xxx', get(w:, 'no_var', 'xxx'))\n      unlet w:some_var\n\n      t:some_var = 'some'\n      assert_equal('some', get(t:, 'some_var'))\n      assert_equal('some', get(t:, 'some_var', 'xxx'))\n      assert_equal('xxx', get(t:, 'no_var', 'xxx'))\n      unlet t:some_var\n  END\n  CheckDefAndScriptSuccess(lines)\nenddef\n\ndef Test_expr7_namespace_loop_def()\n  var lines =<< trim END\n      # check using g: in a for loop more than DO_NOT_FREE_CNT times\n      var exists = 0\n      var exists_not = 0\n      for i in range(100000)\n        if has_key(g:, 'does-not-exist')\n          exists += 1\n        else\n          exists_not += 1\n        endif\n      endfor\n      assert_equal(0, exists)\n      assert_equal(100000, exists_not)\n  END\n  CheckDefSuccess(lines)\nenddef\n\n\" NOTE: this is known to be slow.  To skip use:\n\"   :let $TEST_SKIP_PAT = 'Test_expr7_namespace_loop_script'\ndef Test_expr7_namespace_loop_script()\n  var lines =<< trim END\n      vim9script\n      # check using g: in a for loop more than DO_NOT_FREE_CNT times\n      var exists = 0\n      var exists_not = 0\n      for i in range(100000)\n        if has_key(g:, 'does-not-exist')\n          exists += 1\n        else\n          exists_not += 1\n        endif\n      endfor\n      assert_equal(0, exists)\n      assert_equal(100000, exists_not)\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Test_expr7_parens()\n  # (expr)\n  var lines =<< trim END\n      assert_equal(4, (6 * 4) / 6)\n      assert_equal(0, 6 * ( 4 / 6 ))\n\n      assert_equal(6, +6)\n      assert_equal(-6, -6)\n      assert_equal(false, !-3)\n      assert_equal(true, !+0)\n\n      assert_equal(7, 5 + (\n                    2))\n      assert_equal(7, 5 + (\n                    2\n                    ))\n      assert_equal(7, 5 + ( # comment\n                    2))\n      assert_equal(7, 5 + ( # comment\n                    # comment\n                    2))\n\n      var s = (\n\t\t'one'\n\t\t..\n\t\t'two'\n\t\t)\n      assert_equal('onetwo', s)\n  END\n  CheckDefAndScriptSuccess(lines)\nenddef\n\ndef Test_expr7_negate_add()\n  var lines =<< trim END\n      assert_equal(-99, -99)\n      assert_equal(-99, - 99)\n      assert_equal(99, +99)\n\n      var nr = 88\n      assert_equal(-88, -nr)\n      assert_equal(-88, - nr)\n      assert_equal(88, + nr)\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  lines =<< trim END\n    var n = 12\n    echo ++n\n  END\n  CheckDefAndScriptFailure(lines, 'E15:')\n  lines =<< trim END\n    var n = 12\n    echo --n\n  END\n  CheckDefAndScriptFailure(lines, 'E15:')\n  lines =<< trim END\n    var n = 12\n    echo +-n\n  END\n  CheckDefAndScriptFailure(lines, 'E15:')\n  lines =<< trim END\n    var n = 12\n    echo -+n\n  END\n  CheckDefAndScriptFailure(lines, 'E15:')\n  lines =<< trim END\n    var n = 12\n    echo - -n\n  END\n  CheckDefAndScriptFailure(lines, 'E15:')\n  lines =<< trim END\n    var n = 12\n    echo + +n\n  END\n  CheckDefAndScriptFailure(lines, 'E15:')\nenddef\n\ndef LegacyReturn(): string\n  legacy return #{key: 'ok'}.key\nenddef\n\ndef Test_expr7_legacy_script()\n  var lines =<< trim END\n      let s:legacy = 'legacy'\n      def GetLocal(): string\n        return legacy\n      enddef\n      def GetLocalPrefix(): string\n        return s:legacy\n      enddef\n      call assert_equal('legacy', GetLocal())\n      call assert_equal('legacy', GetLocalPrefix())\n  END\n  CheckScriptSuccess(lines)\n\n  assert_equal('ok', LegacyReturn())\n\n  lines =<< trim END\n      vim9script \n      def GetNumber(): number   \n          legacy return range(3)->map('v:val + 1') \n      enddef \n      echo GetNumber()\n  END\n  CheckScriptFailure(lines, 'E1012: Type mismatch; expected number but got list<number>')\nenddef\n\ndef Echo(arg: any): string\n  return arg\nenddef\n\ndef s:Echo4Arg(arg: any): string\n  return arg\nenddef\n\ndef Test_expr7_call()\n  var lines =<< trim END\n      assert_equal('yes', 'yes'->Echo())\n      assert_equal(true, !range(5)->empty())\n      assert_equal([0, 1, 2], 3->range())\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  assert_equal('yes', 'yes'\n                        ->s:Echo4Arg())\n\n  CheckDefAndScriptFailure([\"var x = 'yes'->Echo\"], 'E107:', 1)\n  CheckDefAndScriptFailure([\n       \"var x = substitute ('x', 'x', 'x', 'x')\"\n       ], ['E1001:', 'E121:'], 1)\n  CheckDefAndScriptFailure([\"var Ref = function('len' [1, 2])\"], ['E1123:', 'E116:'], 1)\n\n  var auto_lines =<< trim END\n      def g:some#func(): string\n\treturn 'found'\n      enddef\n  END\n  mkdir('Xruntime/autoload', 'p')\n  writefile(auto_lines, 'Xruntime/autoload/some.vim')\n  var save_rtp = &rtp\n  &rtp = getcwd() .. '/Xruntime,' .. &rtp\n  assert_equal('found', g:some#func())\n  assert_equal('found', some#func())\n\n  &rtp = save_rtp\n  delete('Xruntime', 'rf')\nenddef\n\ndef Test_expr7_method_call()\n  var lines =<< trim END\n      new\n      setline(1, ['first', 'last'])\n      'second'->append(1)\n      \"third\"->append(2)\n      assert_equal(['first', 'second', 'third', 'last'], getline(1, '$'))\n      bwipe!\n\n      var bufnr = bufnr()\n      var loclist = [{bufnr: bufnr, lnum: 42, col: 17, text: 'wrong'}]\n      loclist->setloclist(0)\n      assert_equal([{bufnr: bufnr,\n                    lnum: 42,\n                    end_lnum: 0,\n                    col: 17,\n                    end_col: 0,\n                    text: 'wrong',\n                    pattern: '',\n                    valid: 1,\n                    vcol: 0,\n                    nr: 0,\n                    type: '',\n                    module: ''}\n                    ], getloclist(0))\n\n      var result: bool = get({n: 0}, 'n', 0)\n      assert_equal(false, result)\n\n      assert_equal('+string+', 'string'->((s) => '+' .. s .. '+')())\n      assert_equal('-text-', 'text'->((s, c) => c .. s .. c)('-'))\n\n      var Join = (l) => join(l, 'x')\n      assert_equal('axb', ['a', 'b']->(Join)())\n      \n      var sorted = [3, 1, 2]\n                    -> sort()\n      assert_equal([1, 2, 3], sorted)\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  lines =<< trim END\n    def RetVoid()\n    enddef\n    RetVoid()->byteidx(3)\n  END\n  CheckDefExecFailure(lines, 'E1013:')\nenddef\n\n\ndef Test_expr7_not()\n  var lines =<< trim END\n      assert_equal(true, !'')\n      assert_equal(true, ![])\n      assert_equal(false, !'asdf')\n      assert_equal(false, ![2])\n      assert_equal(true, !!'asdf')\n      assert_equal(true, !![2])\n\n      assert_equal(true, ! false)\n      assert_equal(true, !! true)\n      assert_equal(true, ! ! true)\n      assert_equal(true, !!! false)\n      assert_equal(true, ! ! ! false)\n\n      g:true = true\n      g:false = false\n      assert_equal(true, ! g:false)\n      assert_equal(true, !! g:true)\n      assert_equal(true, ! ! g:true)\n      assert_equal(true, !!! g:false)\n      assert_equal(true, ! ! ! g:false)\n      unlet g:true\n      unlet g:false\n\n      assert_equal(true, !test_null_partial())\n      assert_equal(false, !() => 'yes')\n\n      assert_equal(true, !test_null_dict())\n      assert_equal(true, !{})\n      assert_equal(false, !{yes: 'no'})\n\n      if has('channel')\n\tassert_equal(true, !test_null_job())\n\tassert_equal(true, !test_null_channel())\n      endif\n\n      assert_equal(true, !test_null_blob())\n      assert_equal(true, !0z)\n      assert_equal(false, !0z01)\n\n      assert_equal(true, !test_void())\n      assert_equal(true, !test_unknown())\n\n      assert_equal(false, ![1, 2, 3]->reverse())\n      assert_equal(true, ![]->reverse())\n  END\n  CheckDefAndScriptSuccess(lines)\nenddef\n\nlet g:anumber = 42\n\ndef Test_expr7_negate()\n  var lines =<< trim END\n      var nr = 1\n      assert_equal(-1, -nr)\n      assert_equal(-42, -g:anumber)\n  END\n  CheckDefAndScriptSuccess(lines)\nenddef\n\nfunc Test_expr7_fails()\n  call CheckDefFailure([\"var x = (12\"], \"E1097:\", 3)\n  call CheckScriptFailure(['vim9script', \"var x = (12\"], 'E110:', 2)\n\n  call CheckDefAndScriptFailure([\"var x = -'xx'\"], \"E1030:\", 1)\n  call CheckDefAndScriptFailure([\"var x = +'xx'\"], \"E1030:\", 1)\n  call CheckDefAndScriptFailure([\"var x = -0z12\"], \"E974:\", 1)\n  call CheckDefExecAndScriptFailure([\"var x = -[8]\"], [\"E1012:\", 'E745:'], 1)\n  call CheckDefExecAndScriptFailure([\"var x = -{a: 1}\"], [\"E1012:\", 'E728:'], 1)\n\n  call CheckDefAndScriptFailure([\"var x = @\"], \"E1002:\", 1)\n  call CheckDefAndScriptFailure([\"var x = @<\"], \"E354:\", 1)\n\n  call CheckDefFailure([\"var x = [1, 2\"], \"E697:\", 2)\n  call CheckScriptFailure(['vim9script', \"var x = [1, 2\"], 'E696:', 2)\n\n  call CheckDefAndScriptFailure([\"var x = [notfound]\"], [\"E1001:\", 'E121:'], 1)\n\n  call CheckDefAndScriptFailure([\"var X = () => 123)\"], 'E488:', 1)\n  call CheckDefAndScriptFailure([\"var x = 123->((x) => x + 5)\"], \"E107:\", 1)\n\n  call CheckDefAndScriptFailure([\"var x = &notexist\"], 'E113:', 1)\n  call CheckDefAndScriptFailure([\"&grepprg = [343]\"], ['E1012:', 'E730:'], 1)\n\n  call CheckDefExecAndScriptFailure([\"echo s:doesnt_exist\"], 'E121:', 1)\n  call CheckDefExecAndScriptFailure([\"echo g:doesnt_exist\"], 'E121:', 1)\n\n  call CheckDefAndScriptFailure([\"echo a:somevar\"], ['E1075:', 'E121:'], 1)\n  call CheckDefAndScriptFailure([\"echo l:somevar\"], ['E1075:', 'E121:'], 1)\n  call CheckDefAndScriptFailure([\"echo x:somevar\"], ['E1075:', 'E121:'], 1)\n\n  call CheckDefExecAndScriptFailure([\"var x = +g:astring\"], ['E1012:', 'E1030:'], 1)\n  call CheckDefExecAndScriptFailure([\"var x = +g:ablob\"], ['E1012:', 'E974:'], 1)\n  call CheckDefExecAndScriptFailure([\"var x = +g:alist\"], ['E1012:', 'E745:'], 1)\n  call CheckDefExecAndScriptFailure([\"var x = +g:adict\"], ['E1012:', 'E728:'], 1)\n\n  call CheckDefAndScriptFailure([\"var x = ''\", \"var y = x.memb\"], ['E1229: Expected dictionary for using key \"memb\", but got string', 'E488:'], 2)\n\n  call CheckDefAndScriptFailure([\"'yes'->\", \"Echo()\"], ['E488: Trailing characters: ->', 'E260: Missing name after ->'], 1)\n\n  call CheckDefExecFailure([\"[1, 2->len()\"], 'E697:', 2)\n  call CheckScriptFailure(['vim9script', \"[1, 2->len()\"], 'E696:', 2)\n\n  call CheckDefFailure([\"{a: 1->len()\"], 'E723:', 2)\n  call CheckScriptFailure(['vim9script', \"{a: 1->len()\"], 'E722:', 2)\n\n  call CheckDefExecFailure([\"{['a']: 1->len()\"], 'E723:', 2)\n  call CheckScriptFailure(['vim9script', \"{['a']: 1->len()\"], 'E722:', 2)\nendfunc\n\nlet g:Funcrefs = [function('add')]\n\nfunc CallMe(arg)\n  return a:arg\nendfunc\n\nfunc CallMe2(one, two)\n  return a:one .. a:two\nendfunc\n\ndef Test_expr7_trailing()\n  var lines =<< trim END\n      # user function call\n      assert_equal(123, g:CallMe(123))\n      assert_equal(123, g:CallMe(  123))\n      assert_equal(123, g:CallMe(123  ))\n      assert_equal('yesno', g:CallMe2('yes', 'no'))\n      assert_equal('yesno', g:CallMe2( 'yes', 'no' ))\n      assert_equal('nothing', g:CallMe('nothing'))\n\n      # partial call\n      var Part = function('g:CallMe')\n      assert_equal('yes', Part('yes'))\n\n      # funcref call, using list index\n      var l = []\n      g:Funcrefs[0](l, 2)\n      assert_equal([2], l)\n\n      # method call\n      l = [2, 5, 6]\n      l->map((k, v) => k + v)\n      assert_equal([2, 6, 8], l)\n\n      # lambda method call\n      l = [2, 5]\n      l->((ll) => add(ll, 8))()\n      assert_equal([2, 5, 8], l)\n\n      # dict member\n      var d = {key: 123}\n      assert_equal(123, d.key)\n  END\n  CheckDefAndScriptSuccess(lines)\nenddef\n\ndef Test_expr7_string_subscript()\n  var lines =<< trim END\n    var text = 'abcdef'\n    assert_equal('f', text[-1])\n    assert_equal('a', text[0])\n    assert_equal('e', text[4])\n    assert_equal('f', text[5])\n    assert_equal('', text[6])\n\n    text = '\u00e1b\u00e7d\u00eb'\n    assert_equal('\u00eb', text[-1])\n    assert_equal('d', text[-2])\n    assert_equal('\u00e7', text[-3])\n    assert_equal('b', text[-4])\n    assert_equal('\u00e1', text[-5])\n    assert_equal('', text[-6])\n\n    text = '\u00e1b\u00e7d\u00ebf'\n    assert_equal('', text[-999])\n    assert_equal('f', text[-1])\n    assert_equal('\u00e1', text[0])\n    assert_equal('b', text[1])\n    assert_equal('\u00e7', text[2])\n    assert_equal('d', text[3])\n    assert_equal('\u00eb', text[4])\n    assert_equal('f', text[5])\n    assert_equal('', text[6])\n    assert_equal('', text[999])\n\n    assert_equal('\u00e1b\u00e7d\u00ebf', text[0 : -1])\n    assert_equal('\u00e1b\u00e7d\u00ebf', text[0 : -1])\n    assert_equal('\u00e1b\u00e7d\u00ebf', text[0 : -1])\n    assert_equal('\u00e1b\u00e7d\u00ebf', text[0 : -1])\n    assert_equal('\u00e1b\u00e7d\u00ebf', text[0\n                  : -1])\n    assert_equal('\u00e1b\u00e7d\u00ebf', text[0 :\n                  -1])\n    assert_equal('\u00e1b\u00e7d\u00ebf', text[0 : -1\n                  ])\n    assert_equal('b\u00e7d\u00ebf', text[1 : -1])\n    assert_equal('\u00e7d\u00ebf', text[2 : -1])\n    assert_equal('d\u00ebf', text[3 : -1])\n    assert_equal('\u00ebf', text[4 : -1])\n    assert_equal('f', text[5 : -1])\n    assert_equal('', text[6 : -1])\n    assert_equal('', text[999 : -1])\n\n    assert_equal('\u00e1b\u00e7d', text[: 3])\n    assert_equal('b\u00e7d\u00ebf', text[1 :])\n    assert_equal('\u00e1b\u00e7d\u00ebf', text[:])\n\n    assert_equal('a', g:astring[0])\n    assert_equal('sd', g:astring[1 : 2])\n    assert_equal('asdf', g:astring[:])\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  lines =<< trim END\n      var d = 'asdf'[1 :\n  END\n  CheckDefFailure(lines, 'E1097:', 3)\n  CheckScriptFailure(['vim9script'] + lines, 'E15:', 2)\n\n  lines =<< trim END\n      var d = 'asdf'[1 : xxx]\n  END\n  CheckDefAndScriptFailure(lines, ['E1001:', 'E121:'], 1)\n\n  lines =<< trim END\n      var d = 'asdf'[1 : 2\n  END\n  CheckDefFailure(lines, 'E1097:', 3)\n  CheckScriptFailure(['vim9script'] + lines, 'E111:', 2)\n\n  lines =<< trim END\n      var d = 'asdf'[1 : 2\n      echo d\n  END\n  CheckDefAndScriptFailure(lines, 'E111:', 2)\n\n  lines =<< trim END\n      var d = 'asdf'['1']\n      echo d\n  END\n  CheckDefAndScriptFailure(lines, ['E1012: Type mismatch; expected number but got string', 'E1030: Using a String as a Number: \"1\"'], 1)\n\n  lines =<< trim END\n      var d = 'asdf'['1' : 2]\n      echo d\n  END\n  CheckDefAndScriptFailure(lines, ['E1012: Type mismatch; expected number but got string', 'E1030: Using a String as a Number: \"1\"'], 1)\n\n  lines =<< trim END\n      var d = 'asdf'[1 : '2']\n      echo d\n  END\n  CheckDefAndScriptFailure(lines, ['E1012: Type mismatch; expected number but got string', 'E1030: Using a String as a Number: \"2\"'], 1)\nenddef\n\ndef Test_expr7_list_subscript()\n  var lines =<< trim END\n      var list = [0, 1, 2, 3, 4]\n      assert_equal(0, list[0])\n      assert_equal(4, list[4])\n      assert_equal(4, list[-1])\n      assert_equal(0, list[-5])\n\n      assert_equal([0, 1, 2, 3, 4], list[0 : 4])\n      assert_equal([0, 1, 2, 3, 4], list[:])\n      assert_equal([1, 2, 3, 4], list[1 :])\n      assert_equal([2, 3, 4], list[2 : -1])\n      assert_equal([4], list[4 : -1])\n      assert_equal([], list[5 : -1])\n      assert_equal([], list[999 : -1])\n      assert_equal([1, 2, 3, 4], list[g:theone : g:thefour])\n\n      assert_equal([0, 1, 2, 3], list[0 : 3])\n      assert_equal([0], list[0 : 0])\n      assert_equal([0, 1, 2, 3, 4], list[0 : -1])\n      assert_equal([0, 1, 2], list[0 : -3])\n      assert_equal([0], list[0 : -5])\n      assert_equal([], list[0 : -6])\n      assert_equal([], list[0 : -99])\n\n      assert_equal(2, g:alist[0])\n      assert_equal([2, 3, 4], g:alist[:])\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  lines = ['var l = [0, 1, 2]', 'echo l[g:astring : g:theone]']\n  CheckDefExecAndScriptFailure(lines, ['E1012:', 'E1030:'], 2)\n\n  lines =<< trim END\n      var ld = []\n      def Func()\n        eval ld[0].key\n      enddef\n      defcompile\n  END\n  CheckDefAndScriptSuccess(lines)\nenddef\n\ndef Test_expr7_dict_subscript()\n  var lines =<< trim END\n      var l = [{lnum: 2}, {lnum: 1}]\n      var res = l[0].lnum > l[1].lnum\n      assert_true(res)\n\n      assert_equal(2, g:adict['aaa'])\n      assert_equal(8, g:adict.bbb)\n\n      var dd = {}\n      def Func1()\n        eval dd.key1.key2\n      enddef\n      def Func2()\n        eval dd['key1'].key2\n      enddef\n      defcompile\n  END\n  CheckDefAndScriptSuccess(lines)\nenddef\n\ndef Test_expr7_blob_subscript()\n  var lines =<< trim END\n      var b = 0z112233\n      assert_equal(0x11, b[0])\n      assert_equal(0z112233, b[:])\n\n      assert_equal(0x01, g:ablob[0])\n      assert_equal(0z01ab, g:ablob[:])\n  END\n  CheckDefAndScriptSuccess(lines)\nenddef\n\ndef Test_expr7_subscript_linebreak()\n  var lines =<< trim END\n      var range = range(\n                    3)\n      var l = range\n            ->mapnew('string(v:key)')\n      assert_equal(['0', '1', '2'], l)\n\n      l = range\n            ->mapnew('string(v:key)')\n      assert_equal(['0', '1', '2'], l)\n\n      l = range # comment\n            ->mapnew('string(v:key)')\n      assert_equal(['0', '1', '2'], l)\n\n      l = range\n\n            ->mapnew('string(v:key)')\n      assert_equal(['0', '1', '2'], l)\n\n      l = range\n            # comment\n            ->mapnew('string(v:key)')\n      assert_equal(['0', '1', '2'], l)\n\n      assert_equal('1', l[\n            1])\n\n      var d = {one: 33}\n      assert_equal(33, d\n            .one)\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  lines =<< trim END\n      var d = {one: 33}\n      assert_equal(33, d.\n            one)\n  END\n  CheckDefAndScriptFailure(lines, ['E1127:', 'E116:'], 2)\nenddef\n\nfunc Test_expr7_trailing_fails()\n  call CheckDefAndScriptFailure(['var l = [2]', 'l->((ll) => add(ll, 8))'], 'E107:', 2)\n  call CheckDefAndScriptFailure(['var l = [2]', 'l->((ll) => add(ll, 8)) ()'], 'E274:', 2)\nendfunc\n\nfunc Test_expr_fails()\n  call CheckDefAndScriptFailure([\"var x = '1'is2\"], 'E488:', 1)\n  call CheckDefAndScriptFailure([\"var x = '1'isnot2\"], 'E488:', 1)\n\n  call CheckDefAndScriptFailure([\"CallMe ('yes')\"], ['E476:', 'E492:'], 1)\n\n  call CheckDefAndScriptFailure([\"CallMe2('yes','no')\"], 'E1069:', 1)\n\n  call CheckDefAndScriptFailure([\"v:nosuch += 3\"], ['E1001:', 'E121:'], 1)\n  call CheckDefAndScriptFailure([\"var v:statusmsg = ''\"], 'E1016: Cannot declare a v: variable:', 1)\n  call CheckDefAndScriptFailure([\"var asdf = v:nosuch\"], ['E1001:', 'E121:'], 1)\n\n  call CheckDefFailure([\"echo len('asdf'\"], 'E110:', 2)\n  call CheckScriptFailure(['vim9script', \"echo len('asdf'\"], 'E116:', 2)\n\n  call CheckDefAndScriptFailure([\"echo Func0123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789()\"], ['E1011:', 'E117:'], 1)\n  call CheckDefAndScriptFailure([\"echo doesnotexist()\"], 'E117:', 1)\nendfunc\n\n\" vim: shiftwidth=2 sts=2 expandtab\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion == NULL)\n    {\n#ifdef BUILD_DATE\n\tchar *date_time = BUILD_DATE;\n#else\n\tchar *date_time = __DATE__ \" \" __TIME__;\n#endif\n\tchar *msg = _(\"%s (%s, compiled %s)\");\n\tsize_t len = strlen(msg)\n\t\t    + strlen(VIM_VERSION_LONG_ONLY)\n\t\t    + strlen(VIM_VERSION_DATE_ONLY)\n\t\t    + strlen(date_time);\n\n\tlongVersion = alloc(len);\n\tif (longVersion == NULL)\n\t    longVersion = VIM_VERSION_LONG;\n\telse\n\t    vim_snprintf(longVersion, len, msg,\n\t\t      VIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n    }\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n#ifdef NO_BUILTIN_TCAPS\n\t\"-builtin_terms\",\n#endif\n#ifdef SOME_BUILTIN_TCAPS\n\t\"+builtin_terms\",\n#endif\n#ifdef ALL_BUILTIN_TCAPS\n\t\"++builtin_terms\",\n#endif\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n#ifdef FEAT_CINDENT\n\t\"+cindent\",\n#else\n\t\"-cindent\",\n#endif\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n#ifdef FEAT_CMDL_INFO\n\t\"+cmdline_info\",\n#else\n\t\"-cmdline_info\",\n#endif\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n#ifdef EBCDIC\n\t\"+ebcdic\",\n#else\n\t\"-ebcdic\",\n#endif\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n#ifdef FEAT_SEARCHPATH\n\t\"+file_in_path\",\n#else\n\t\"-file_in_path\",\n#endif\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n#ifdef FEAT_FLOAT\n\t\"+float\",\n#else\n\t\"-float\",\n#endif\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n#ifdef FEAT_FOOTER\n\t\"+footer\",\n#else\n\t\"-footer\",\n#endif\n\t    // only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n\t\"+jumplist\",\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n#ifdef FEAT_LISP\n\t\"+lispindent\",\n#else\n\t\"-lispindent\",\n#endif\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n\t\"+mouse_gpm\",\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n#ifdef FEAT_PATH_EXTRA\n\t\"+path_extra\",\n#else\n\t\"-path_extra\",\n#endif\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n#ifdef FEAT_SMARTINDENT\n\t\"+smartindent\",\n#else\n\t\"-smartindent\",\n#endif\n#ifdef FEAT_SODIUM\n\t\"+sodium\",\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n#ifdef FEAT_TAG_BINS\n\t\"+tag_binary\",\n#else\n\t\"-tag_binary\",\n#endif\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n#ifdef FEAT_TEXTOBJ\n\t\"+textobjects\",\n#else\n\t\"-textobjects\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n\t\"+title\",\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+vim9script\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n#ifdef FEAT_WILDIGN\n\t\"+wildignore\",\n#else\n\t\"-wildignore\",\n#endif\n#ifdef FEAT_WILDMENU\n\t\"+wildmenu\",\n#else\n\t\"-wildmenu\",\n#endif\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#ifdef MSWIN\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#else\n# ifdef HAVE_XPM\n\t\"+xpm\",\n# else\n\t\"-xpm\",\n# endif\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef USE_XSMP_INTERACT\n\t\"+xsmp_interact\",\n# else\n#  ifdef USE_XSMP\n\t\"+xsmp\",\n#  else\n\t\"-xsmp\",\n#  endif\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    4048,\n/**/\n    4047,\n/**/\n    4046,\n/**/\n    4045,\n/**/\n    4044,\n/**/\n    4043,\n/**/\n    4042,\n/**/\n    4041,\n/**/\n    4040,\n/**/\n    4039,\n/**/\n    4038,\n/**/\n    4037,\n/**/\n    4036,\n/**/\n    4035,\n/**/\n    4034,\n/**/\n    4033,\n/**/\n    4032,\n/**/\n    4031,\n/**/\n    4030,\n/**/\n    4029,\n/**/\n    4028,\n/**/\n    4027,\n/**/\n    4026,\n/**/\n    4025,\n/**/\n    4024,\n/**/\n    4023,\n/**/\n    4022,\n/**/\n    4021,\n/**/\n    4020,\n/**/\n    4019,\n/**/\n    4018,\n/**/\n    4017,\n/**/\n    4016,\n/**/\n    4015,\n/**/\n    4014,\n/**/\n    4013,\n/**/\n    4012,\n/**/\n    4011,\n/**/\n    4010,\n/**/\n    4009,\n/**/\n    4008,\n/**/\n    4007,\n/**/\n    4006,\n/**/\n    4005,\n/**/\n    4004,\n/**/\n    4003,\n/**/\n    4002,\n/**/\n    4001,\n/**/\n    4000,\n/**/\n    3999,\n/**/\n    3998,\n/**/\n    3997,\n/**/\n    3996,\n/**/\n    3995,\n/**/\n    3994,\n/**/\n    3993,\n/**/\n    3992,\n/**/\n    3991,\n/**/\n    3990,\n/**/\n    3989,\n/**/\n    3988,\n/**/\n    3987,\n/**/\n    3986,\n/**/\n    3985,\n/**/\n    3984,\n/**/\n    3983,\n/**/\n    3982,\n/**/\n    3981,\n/**/\n    3980,\n/**/\n    3979,\n/**/\n    3978,\n/**/\n    3977,\n/**/\n    3976,\n/**/\n    3975,\n/**/\n    3974,\n/**/\n    3973,\n/**/\n    3972,\n/**/\n    3971,\n/**/\n    3970,\n/**/\n    3969,\n/**/\n    3968,\n/**/\n    3967,\n/**/\n    3966,\n/**/\n    3965,\n/**/\n    3964,\n/**/\n    3963,\n/**/\n    3962,\n/**/\n    3961,\n/**/\n    3960,\n/**/\n    3959,\n/**/\n    3958,\n/**/\n    3957,\n/**/\n    3956,\n/**/\n    3955,\n/**/\n    3954,\n/**/\n    3953,\n/**/\n    3952,\n/**/\n    3951,\n/**/\n    3950,\n/**/\n    3949,\n/**/\n    3948,\n/**/\n    3947,\n/**/\n    3946,\n/**/\n    3945,\n/**/\n    3944,\n/**/\n    3943,\n/**/\n    3942,\n/**/\n    3941,\n/**/\n    3940,\n/**/\n    3939,\n/**/\n    3938,\n/**/\n    3937,\n/**/\n    3936,\n/**/\n    3935,\n/**/\n    3934,\n/**/\n    3933,\n/**/\n    3932,\n/**/\n    3931,\n/**/\n    3930,\n/**/\n    3929,\n/**/\n    3928,\n/**/\n    3927,\n/**/\n    3926,\n/**/\n    3925,\n/**/\n    3924,\n/**/\n    3923,\n/**/\n    3922,\n/**/\n    3921,\n/**/\n    3920,\n/**/\n    3919,\n/**/\n    3918,\n/**/\n    3917,\n/**/\n    3916,\n/**/\n    3915,\n/**/\n    3914,\n/**/\n    3913,\n/**/\n    3912,\n/**/\n    3911,\n/**/\n    3910,\n/**/\n    3909,\n/**/\n    3908,\n/**/\n    3907,\n/**/\n    3906,\n/**/\n    3905,\n/**/\n    3904,\n/**/\n    3903,\n/**/\n    3902,\n/**/\n    3901,\n/**/\n    3900,\n/**/\n    3899,\n/**/\n    3898,\n/**/\n    3897,\n/**/\n    3896,\n/**/\n    3895,\n/**/\n    3894,\n/**/\n    3893,\n/**/\n    3892,\n/**/\n    3891,\n/**/\n    3890,\n/**/\n    3889,\n/**/\n    3888,\n/**/\n    3887,\n/**/\n    3886,\n/**/\n    3885,\n/**/\n    3884,\n/**/\n    3883,\n/**/\n    3882,\n/**/\n    3881,\n/**/\n    3880,\n/**/\n    3879,\n/**/\n    3878,\n/**/\n    3877,\n/**/\n    3876,\n/**/\n    3875,\n/**/\n    3874,\n/**/\n    3873,\n/**/\n    3872,\n/**/\n    3871,\n/**/\n    3870,\n/**/\n    3869,\n/**/\n    3868,\n/**/\n    3867,\n/**/\n    3866,\n/**/\n    3865,\n/**/\n    3864,\n/**/\n    3863,\n/**/\n    3862,\n/**/\n    3861,\n/**/\n    3860,\n/**/\n    3859,\n/**/\n    3858,\n/**/\n    3857,\n/**/\n    3856,\n/**/\n    3855,\n/**/\n    3854,\n/**/\n    3853,\n/**/\n    3852,\n/**/\n    3851,\n/**/\n    3850,\n/**/\n    3849,\n/**/\n    3848,\n/**/\n    3847,\n/**/\n    3846,\n/**/\n    3845,\n/**/\n    3844,\n/**/\n    3843,\n/**/\n    3842,\n/**/\n    3841,\n/**/\n    3840,\n/**/\n    3839,\n/**/\n    3838,\n/**/\n    3837,\n/**/\n    3836,\n/**/\n    3835,\n/**/\n    3834,\n/**/\n    3833,\n/**/\n    3832,\n/**/\n    3831,\n/**/\n    3830,\n/**/\n    3829,\n/**/\n    3828,\n/**/\n    3827,\n/**/\n    3826,\n/**/\n    3825,\n/**/\n    3824,\n/**/\n    3823,\n/**/\n    3822,\n/**/\n    3821,\n/**/\n    3820,\n/**/\n    3819,\n/**/\n    3818,\n/**/\n    3817,\n/**/\n    3816,\n/**/\n    3815,\n/**/\n    3814,\n/**/\n    3813,\n/**/\n    3812,\n/**/\n    3811,\n/**/\n    3810,\n/**/\n    3809,\n/**/\n    3808,\n/**/\n    3807,\n/**/\n    3806,\n/**/\n    3805,\n/**/\n    3804,\n/**/\n    3803,\n/**/\n    3802,\n/**/\n    3801,\n/**/\n    3800,\n/**/\n    3799,\n/**/\n    3798,\n/**/\n    3797,\n/**/\n    3796,\n/**/\n    3795,\n/**/\n    3794,\n/**/\n    3793,\n/**/\n    3792,\n/**/\n    3791,\n/**/\n    3790,\n/**/\n    3789,\n/**/\n    3788,\n/**/\n    3787,\n/**/\n    3786,\n/**/\n    3785,\n/**/\n    3784,\n/**/\n    3783,\n/**/\n    3782,\n/**/\n    3781,\n/**/\n    3780,\n/**/\n    3779,\n/**/\n    3778,\n/**/\n    3777,\n/**/\n    3776,\n/**/\n    3775,\n/**/\n    3774,\n/**/\n    3773,\n/**/\n    3772,\n/**/\n    3771,\n/**/\n    3770,\n/**/\n    3769,\n/**/\n    3768,\n/**/\n    3767,\n/**/\n    3766,\n/**/\n    3765,\n/**/\n    3764,\n/**/\n    3763,\n/**/\n    3762,\n/**/\n    3761,\n/**/\n    3760,\n/**/\n    3759,\n/**/\n    3758,\n/**/\n    3757,\n/**/\n    3756,\n/**/\n    3755,\n/**/\n    3754,\n/**/\n    3753,\n/**/\n    3752,\n/**/\n    3751,\n/**/\n    3750,\n/**/\n    3749,\n/**/\n    3748,\n/**/\n    3747,\n/**/\n    3746,\n/**/\n    3745,\n/**/\n    3744,\n/**/\n    3743,\n/**/\n    3742,\n/**/\n    3741,\n/**/\n    3740,\n/**/\n    3739,\n/**/\n    3738,\n/**/\n    3737,\n/**/\n    3736,\n/**/\n    3735,\n/**/\n    3734,\n/**/\n    3733,\n/**/\n    3732,\n/**/\n    3731,\n/**/\n    3730,\n/**/\n    3729,\n/**/\n    3728,\n/**/\n    3727,\n/**/\n    3726,\n/**/\n    3725,\n/**/\n    3724,\n/**/\n    3723,\n/**/\n    3722,\n/**/\n    3721,\n/**/\n    3720,\n/**/\n    3719,\n/**/\n    3718,\n/**/\n    3717,\n/**/\n    3716,\n/**/\n    3715,\n/**/\n    3714,\n/**/\n    3713,\n/**/\n    3712,\n/**/\n    3711,\n/**/\n    3710,\n/**/\n    3709,\n/**/\n    3708,\n/**/\n    3707,\n/**/\n    3706,\n/**/\n    3705,\n/**/\n    3704,\n/**/\n    3703,\n/**/\n    3702,\n/**/\n    3701,\n/**/\n    3700,\n/**/\n    3699,\n/**/\n    3698,\n/**/\n    3697,\n/**/\n    3696,\n/**/\n    3695,\n/**/\n    3694,\n/**/\n    3693,\n/**/\n    3692,\n/**/\n    3691,\n/**/\n    3690,\n/**/\n    3689,\n/**/\n    3688,\n/**/\n    3687,\n/**/\n    3686,\n/**/\n    3685,\n/**/\n    3684,\n/**/\n    3683,\n/**/\n    3682,\n/**/\n    3681,\n/**/\n    3680,\n/**/\n    3679,\n/**/\n    3678,\n/**/\n    3677,\n/**/\n    3676,\n/**/\n    3675,\n/**/\n    3674,\n/**/\n    3673,\n/**/\n    3672,\n/**/\n    3671,\n/**/\n    3670,\n/**/\n    3669,\n/**/\n    3668,\n/**/\n    3667,\n/**/\n    3666,\n/**/\n    3665,\n/**/\n    3664,\n/**/\n    3663,\n/**/\n    3662,\n/**/\n    3661,\n/**/\n    3660,\n/**/\n    3659,\n/**/\n    3658,\n/**/\n    3657,\n/**/\n    3656,\n/**/\n    3655,\n/**/\n    3654,\n/**/\n    3653,\n/**/\n    3652,\n/**/\n    3651,\n/**/\n    3650,\n/**/\n    3649,\n/**/\n    3648,\n/**/\n    3647,\n/**/\n    3646,\n/**/\n    3645,\n/**/\n    3644,\n/**/\n    3643,\n/**/\n    3642,\n/**/\n    3641,\n/**/\n    3640,\n/**/\n    3639,\n/**/\n    3638,\n/**/\n    3637,\n/**/\n    3636,\n/**/\n    3635,\n/**/\n    3634,\n/**/\n    3633,\n/**/\n    3632,\n/**/\n    3631,\n/**/\n    3630,\n/**/\n    3629,\n/**/\n    3628,\n/**/\n    3627,\n/**/\n    3626,\n/**/\n    3625,\n/**/\n    3624,\n/**/\n    3623,\n/**/\n    3622,\n/**/\n    3621,\n/**/\n    3620,\n/**/\n    3619,\n/**/\n    3618,\n/**/\n    3617,\n/**/\n    3616,\n/**/\n    3615,\n/**/\n    3614,\n/**/\n    3613,\n/**/\n    3612,\n/**/\n    3611,\n/**/\n    3610,\n/**/\n    3609,\n/**/\n    3608,\n/**/\n    3607,\n/**/\n    3606,\n/**/\n    3605,\n/**/\n    3604,\n/**/\n    3603,\n/**/\n    3602,\n/**/\n    3601,\n/**/\n    3600,\n/**/\n    3599,\n/**/\n    3598,\n/**/\n    3597,\n/**/\n    3596,\n/**/\n    3595,\n/**/\n    3594,\n/**/\n    3593,\n/**/\n    3592,\n/**/\n    3591,\n/**/\n    3590,\n/**/\n    3589,\n/**/\n    3588,\n/**/\n    3587,\n/**/\n    3586,\n/**/\n    3585,\n/**/\n    3584,\n/**/\n    3583,\n/**/\n    3582,\n/**/\n    3581,\n/**/\n    3580,\n/**/\n    3579,\n/**/\n    3578,\n/**/\n    3577,\n/**/\n    3576,\n/**/\n    3575,\n/**/\n    3574,\n/**/\n    3573,\n/**/\n    3572,\n/**/\n    3571,\n/**/\n    3570,\n/**/\n    3569,\n/**/\n    3568,\n/**/\n    3567,\n/**/\n    3566,\n/**/\n    3565,\n/**/\n    3564,\n/**/\n    3563,\n/**/\n    3562,\n/**/\n    3561,\n/**/\n    3560,\n/**/\n    3559,\n/**/\n    3558,\n/**/\n    3557,\n/**/\n    3556,\n/**/\n    3555,\n/**/\n    3554,\n/**/\n    3553,\n/**/\n    3552,\n/**/\n    3551,\n/**/\n    3550,\n/**/\n    3549,\n/**/\n    3548,\n/**/\n    3547,\n/**/\n    3546,\n/**/\n    3545,\n/**/\n    3544,\n/**/\n    3543,\n/**/\n    3542,\n/**/\n    3541,\n/**/\n    3540,\n/**/\n    3539,\n/**/\n    3538,\n/**/\n    3537,\n/**/\n    3536,\n/**/\n    3535,\n/**/\n    3534,\n/**/\n    3533,\n/**/\n    3532,\n/**/\n    3531,\n/**/\n    3530,\n/**/\n    3529,\n/**/\n    3528,\n/**/\n    3527,\n/**/\n    3526,\n/**/\n    3525,\n/**/\n    3524,\n/**/\n    3523,\n/**/\n    3522,\n/**/\n    3521,\n/**/\n    3520,\n/**/\n    3519,\n/**/\n    3518,\n/**/\n    3517,\n/**/\n    3516,\n/**/\n    3515,\n/**/\n    3514,\n/**/\n    3513,\n/**/\n    3512,\n/**/\n    3511,\n/**/\n    3510,\n/**/\n    3509,\n/**/\n    3508,\n/**/\n    3507,\n/**/\n    3506,\n/**/\n    3505,\n/**/\n    3504,\n/**/\n    3503,\n/**/\n    3502,\n/**/\n    3501,\n/**/\n    3500,\n/**/\n    3499,\n/**/\n    3498,\n/**/\n    3497,\n/**/\n    3496,\n/**/\n    3495,\n/**/\n    3494,\n/**/\n    3493,\n/**/\n    3492,\n/**/\n    3491,\n/**/\n    3490,\n/**/\n    3489,\n/**/\n    3488,\n/**/\n    3487,\n/**/\n    3486,\n/**/\n    3485,\n/**/\n    3484,\n/**/\n    3483,\n/**/\n    3482,\n/**/\n    3481,\n/**/\n    3480,\n/**/\n    3479,\n/**/\n    3478,\n/**/\n    3477,\n/**/\n    3476,\n/**/\n    3475,\n/**/\n    3474,\n/**/\n    3473,\n/**/\n    3472,\n/**/\n    3471,\n/**/\n    3470,\n/**/\n    3469,\n/**/\n    3468,\n/**/\n    3467,\n/**/\n    3466,\n/**/\n    3465,\n/**/\n    3464,\n/**/\n    3463,\n/**/\n    3462,\n/**/\n    3461,\n/**/\n    3460,\n/**/\n    3459,\n/**/\n    3458,\n/**/\n    3457,\n/**/\n    3456,\n/**/\n    3455,\n/**/\n    3454,\n/**/\n    3453,\n/**/\n    3452,\n/**/\n    3451,\n/**/\n    3450,\n/**/\n    3449,\n/**/\n    3448,\n/**/\n    3447,\n/**/\n    3446,\n/**/\n    3445,\n/**/\n    3444,\n/**/\n    3443,\n/**/\n    3442,\n/**/\n    3441,\n/**/\n    3440,\n/**/\n    3439,\n/**/\n    3438,\n/**/\n    3437,\n/**/\n    3436,\n/**/\n    3435,\n/**/\n    3434,\n/**/\n    3433,\n/**/\n    3432,\n/**/\n    3431,\n/**/\n    3430,\n/**/\n    3429,\n/**/\n    3428,\n/**/\n    3427,\n/**/\n    3426,\n/**/\n    3425,\n/**/\n    3424,\n/**/\n    3423,\n/**/\n    3422,\n/**/\n    3421,\n/**/\n    3420,\n/**/\n    3419,\n/**/\n    3418,\n/**/\n    3417,\n/**/\n    3416,\n/**/\n    3415,\n/**/\n    3414,\n/**/\n    3413,\n/**/\n    3412,\n/**/\n    3411,\n/**/\n    3410,\n/**/\n    3409,\n/**/\n    3408,\n/**/\n    3407,\n/**/\n    3406,\n/**/\n    3405,\n/**/\n    3404,\n/**/\n    3403,\n/**/\n    3402,\n/**/\n    3401,\n/**/\n    3400,\n/**/\n    3399,\n/**/\n    3398,\n/**/\n    3397,\n/**/\n    3396,\n/**/\n    3395,\n/**/\n    3394,\n/**/\n    3393,\n/**/\n    3392,\n/**/\n    3391,\n/**/\n    3390,\n/**/\n    3389,\n/**/\n    3388,\n/**/\n    3387,\n/**/\n    3386,\n/**/\n    3385,\n/**/\n    3384,\n/**/\n    3383,\n/**/\n    3382,\n/**/\n    3381,\n/**/\n    3380,\n/**/\n    3379,\n/**/\n    3378,\n/**/\n    3377,\n/**/\n    3376,\n/**/\n    3375,\n/**/\n    3374,\n/**/\n    3373,\n/**/\n    3372,\n/**/\n    3371,\n/**/\n    3370,\n/**/\n    3369,\n/**/\n    3368,\n/**/\n    3367,\n/**/\n    3366,\n/**/\n    3365,\n/**/\n    3364,\n/**/\n    3363,\n/**/\n    3362,\n/**/\n    3361,\n/**/\n    3360,\n/**/\n    3359,\n/**/\n    3358,\n/**/\n    3357,\n/**/\n    3356,\n/**/\n    3355,\n/**/\n    3354,\n/**/\n    3353,\n/**/\n    3352,\n/**/\n    3351,\n/**/\n    3350,\n/**/\n    3349,\n/**/\n    3348,\n/**/\n    3347,\n/**/\n    3346,\n/**/\n    3345,\n/**/\n    3344,\n/**/\n    3343,\n/**/\n    3342,\n/**/\n    3341,\n/**/\n    3340,\n/**/\n    3339,\n/**/\n    3338,\n/**/\n    3337,\n/**/\n    3336,\n/**/\n    3335,\n/**/\n    3334,\n/**/\n    3333,\n/**/\n    3332,\n/**/\n    3331,\n/**/\n    3330,\n/**/\n    3329,\n/**/\n    3328,\n/**/\n    3327,\n/**/\n    3326,\n/**/\n    3325,\n/**/\n    3324,\n/**/\n    3323,\n/**/\n    3322,\n/**/\n    3321,\n/**/\n    3320,\n/**/\n    3319,\n/**/\n    3318,\n/**/\n    3317,\n/**/\n    3316,\n/**/\n    3315,\n/**/\n    3314,\n/**/\n    3313,\n/**/\n    3312,\n/**/\n    3311,\n/**/\n    3310,\n/**/\n    3309,\n/**/\n    3308,\n/**/\n    3307,\n/**/\n    3306,\n/**/\n    3305,\n/**/\n    3304,\n/**/\n    3303,\n/**/\n    3302,\n/**/\n    3301,\n/**/\n    3300,\n/**/\n    3299,\n/**/\n    3298,\n/**/\n    3297,\n/**/\n    3296,\n/**/\n    3295,\n/**/\n    3294,\n/**/\n    3293,\n/**/\n    3292,\n/**/\n    3291,\n/**/\n    3290,\n/**/\n    3289,\n/**/\n    3288,\n/**/\n    3287,\n/**/\n    3286,\n/**/\n    3285,\n/**/\n    3284,\n/**/\n    3283,\n/**/\n    3282,\n/**/\n    3281,\n/**/\n    3280,\n/**/\n    3279,\n/**/\n    3278,\n/**/\n    3277,\n/**/\n    3276,\n/**/\n    3275,\n/**/\n    3274,\n/**/\n    3273,\n/**/\n    3272,\n/**/\n    3271,\n/**/\n    3270,\n/**/\n    3269,\n/**/\n    3268,\n/**/\n    3267,\n/**/\n    3266,\n/**/\n    3265,\n/**/\n    3264,\n/**/\n    3263,\n/**/\n    3262,\n/**/\n    3261,\n/**/\n    3260,\n/**/\n    3259,\n/**/\n    3258,\n/**/\n    3257,\n/**/\n    3256,\n/**/\n    3255,\n/**/\n    3254,\n/**/\n    3253,\n/**/\n    3252,\n/**/\n    3251,\n/**/\n    3250,\n/**/\n    3249,\n/**/\n    3248,\n/**/\n    3247,\n/**/\n    3246,\n/**/\n    3245,\n/**/\n    3244,\n/**/\n    3243,\n/**/\n    3242,\n/**/\n    3241,\n/**/\n    3240,\n/**/\n    3239,\n/**/\n    3238,\n/**/\n    3237,\n/**/\n    3236,\n/**/\n    3235,\n/**/\n    3234,\n/**/\n    3233,\n/**/\n    3232,\n/**/\n    3231,\n/**/\n    3230,\n/**/\n    3229,\n/**/\n    3228,\n/**/\n    3227,\n/**/\n    3226,\n/**/\n    3225,\n/**/\n    3224,\n/**/\n    3223,\n/**/\n    3222,\n/**/\n    3221,\n/**/\n    3220,\n/**/\n    3219,\n/**/\n    3218,\n/**/\n    3217,\n/**/\n    3216,\n/**/\n    3215,\n/**/\n    3214,\n/**/\n    3213,\n/**/\n    3212,\n/**/\n    3211,\n/**/\n    3210,\n/**/\n    3209,\n/**/\n    3208,\n/**/\n    3207,\n/**/\n    3206,\n/**/\n    3205,\n/**/\n    3204,\n/**/\n    3203,\n/**/\n    3202,\n/**/\n    3201,\n/**/\n    3200,\n/**/\n    3199,\n/**/\n    3198,\n/**/\n    3197,\n/**/\n    3196,\n/**/\n    3195,\n/**/\n    3194,\n/**/\n    3193,\n/**/\n    3192,\n/**/\n    3191,\n/**/\n    3190,\n/**/\n    3189,\n/**/\n    3188,\n/**/\n    3187,\n/**/\n    3186,\n/**/\n    3185,\n/**/\n    3184,\n/**/\n    3183,\n/**/\n    3182,\n/**/\n    3181,\n/**/\n    3180,\n/**/\n    3179,\n/**/\n    3178,\n/**/\n    3177,\n/**/\n    3176,\n/**/\n    3175,\n/**/\n    3174,\n/**/\n    3173,\n/**/\n    3172,\n/**/\n    3171,\n/**/\n    3170,\n/**/\n    3169,\n/**/\n    3168,\n/**/\n    3167,\n/**/\n    3166,\n/**/\n    3165,\n/**/\n    3164,\n/**/\n    3163,\n/**/\n    3162,\n/**/\n    3161,\n/**/\n    3160,\n/**/\n    3159,\n/**/\n    3158,\n/**/\n    3157,\n/**/\n    3156,\n/**/\n    3155,\n/**/\n    3154,\n/**/\n    3153,\n/**/\n    3152,\n/**/\n    3151,\n/**/\n    3150,\n/**/\n    3149,\n/**/\n    3148,\n/**/\n    3147,\n/**/\n    3146,\n/**/\n    3145,\n/**/\n    3144,\n/**/\n    3143,\n/**/\n    3142,\n/**/\n    3141,\n/**/\n    3140,\n/**/\n    3139,\n/**/\n    3138,\n/**/\n    3137,\n/**/\n    3136,\n/**/\n    3135,\n/**/\n    3134,\n/**/\n    3133,\n/**/\n    3132,\n/**/\n    3131,\n/**/\n    3130,\n/**/\n    3129,\n/**/\n    3128,\n/**/\n    3127,\n/**/\n    3126,\n/**/\n    3125,\n/**/\n    3124,\n/**/\n    3123,\n/**/\n    3122,\n/**/\n    3121,\n/**/\n    3120,\n/**/\n    3119,\n/**/\n    3118,\n/**/\n    3117,\n/**/\n    3116,\n/**/\n    3115,\n/**/\n    3114,\n/**/\n    3113,\n/**/\n    3112,\n/**/\n    3111,\n/**/\n    3110,\n/**/\n    3109,\n/**/\n    3108,\n/**/\n    3107,\n/**/\n    3106,\n/**/\n    3105,\n/**/\n    3104,\n/**/\n    3103,\n/**/\n    3102,\n/**/\n    3101,\n/**/\n    3100,\n/**/\n    3099,\n/**/\n    3098,\n/**/\n    3097,\n/**/\n    3096,\n/**/\n    3095,\n/**/\n    3094,\n/**/\n    3093,\n/**/\n    3092,\n/**/\n    3091,\n/**/\n    3090,\n/**/\n    3089,\n/**/\n    3088,\n/**/\n    3087,\n/**/\n    3086,\n/**/\n    3085,\n/**/\n    3084,\n/**/\n    3083,\n/**/\n    3082,\n/**/\n    3081,\n/**/\n    3080,\n/**/\n    3079,\n/**/\n    3078,\n/**/\n    3077,\n/**/\n    3076,\n/**/\n    3075,\n/**/\n    3074,\n/**/\n    3073,\n/**/\n    3072,\n/**/\n    3071,\n/**/\n    3070,\n/**/\n    3069,\n/**/\n    3068,\n/**/\n    3067,\n/**/\n    3066,\n/**/\n    3065,\n/**/\n    3064,\n/**/\n    3063,\n/**/\n    3062,\n/**/\n    3061,\n/**/\n    3060,\n/**/\n    3059,\n/**/\n    3058,\n/**/\n    3057,\n/**/\n    3056,\n/**/\n    3055,\n/**/\n    3054,\n/**/\n    3053,\n/**/\n    3052,\n/**/\n    3051,\n/**/\n    3050,\n/**/\n    3049,\n/**/\n    3048,\n/**/\n    3047,\n/**/\n    3046,\n/**/\n    3045,\n/**/\n    3044,\n/**/\n    3043,\n/**/\n    3042,\n/**/\n    3041,\n/**/\n    3040,\n/**/\n    3039,\n/**/\n    3038,\n/**/\n    3037,\n/**/\n    3036,\n/**/\n    3035,\n/**/\n    3034,\n/**/\n    3033,\n/**/\n    3032,\n/**/\n    3031,\n/**/\n    3030,\n/**/\n    3029,\n/**/\n    3028,\n/**/\n    3027,\n/**/\n    3026,\n/**/\n    3025,\n/**/\n    3024,\n/**/\n    3023,\n/**/\n    3022,\n/**/\n    3021,\n/**/\n    3020,\n/**/\n    3019,\n/**/\n    3018,\n/**/\n    3017,\n/**/\n    3016,\n/**/\n    3015,\n/**/\n    3014,\n/**/\n    3013,\n/**/\n    3012,\n/**/\n    3011,\n/**/\n    3010,\n/**/\n    3009,\n/**/\n    3008,\n/**/\n    3007,\n/**/\n    3006,\n/**/\n    3005,\n/**/\n    3004,\n/**/\n    3003,\n/**/\n    3002,\n/**/\n    3001,\n/**/\n    3000,\n/**/\n    2999,\n/**/\n    2998,\n/**/\n    2997,\n/**/\n    2996,\n/**/\n    2995,\n/**/\n    2994,\n/**/\n    2993,\n/**/\n    2992,\n/**/\n    2991,\n/**/\n    2990,\n/**/\n    2989,\n/**/\n    2988,\n/**/\n    2987,\n/**/\n    2986,\n/**/\n    2985,\n/**/\n    2984,\n/**/\n    2983,\n/**/\n    2982,\n/**/\n    2981,\n/**/\n    2980,\n/**/\n    2979,\n/**/\n    2978,\n/**/\n    2977,\n/**/\n    2976,\n/**/\n    2975,\n/**/\n    2974,\n/**/\n    2973,\n/**/\n    2972,\n/**/\n    2971,\n/**/\n    2970,\n/**/\n    2969,\n/**/\n    2968,\n/**/\n    2967,\n/**/\n    2966,\n/**/\n    2965,\n/**/\n    2964,\n/**/\n    2963,\n/**/\n    2962,\n/**/\n    2961,\n/**/\n    2960,\n/**/\n    2959,\n/**/\n    2958,\n/**/\n    2957,\n/**/\n    2956,\n/**/\n    2955,\n/**/\n    2954,\n/**/\n    2953,\n/**/\n    2952,\n/**/\n    2951,\n/**/\n    2950,\n/**/\n    2949,\n/**/\n    2948,\n/**/\n    2947,\n/**/\n    2946,\n/**/\n    2945,\n/**/\n    2944,\n/**/\n    2943,\n/**/\n    2942,\n/**/\n    2941,\n/**/\n    2940,\n/**/\n    2939,\n/**/\n    2938,\n/**/\n    2937,\n/**/\n    2936,\n/**/\n    2935,\n/**/\n    2934,\n/**/\n    2933,\n/**/\n    2932,\n/**/\n    2931,\n/**/\n    2930,\n/**/\n    2929,\n/**/\n    2928,\n/**/\n    2927,\n/**/\n    2926,\n/**/\n    2925,\n/**/\n    2924,\n/**/\n    2923,\n/**/\n    2922,\n/**/\n    2921,\n/**/\n    2920,\n/**/\n    2919,\n/**/\n    2918,\n/**/\n    2917,\n/**/\n    2916,\n/**/\n    2915,\n/**/\n    2914,\n/**/\n    2913,\n/**/\n    2912,\n/**/\n    2911,\n/**/\n    2910,\n/**/\n    2909,\n/**/\n    2908,\n/**/\n    2907,\n/**/\n    2906,\n/**/\n    2905,\n/**/\n    2904,\n/**/\n    2903,\n/**/\n    2902,\n/**/\n    2901,\n/**/\n    2900,\n/**/\n    2899,\n/**/\n    2898,\n/**/\n    2897,\n/**/\n    2896,\n/**/\n    2895,\n/**/\n    2894,\n/**/\n    2893,\n/**/\n    2892,\n/**/\n    2891,\n/**/\n    2890,\n/**/\n    2889,\n/**/\n    2888,\n/**/\n    2887,\n/**/\n    2886,\n/**/\n    2885,\n/**/\n    2884,\n/**/\n    2883,\n/**/\n    2882,\n/**/\n    2881,\n/**/\n    2880,\n/**/\n    2879,\n/**/\n    2878,\n/**/\n    2877,\n/**/\n    2876,\n/**/\n    2875,\n/**/\n    2874,\n/**/\n    2873,\n/**/\n    2872,\n/**/\n    2871,\n/**/\n    2870,\n/**/\n    2869,\n/**/\n    2868,\n/**/\n    2867,\n/**/\n    2866,\n/**/\n    2865,\n/**/\n    2864,\n/**/\n    2863,\n/**/\n    2862,\n/**/\n    2861,\n/**/\n    2860,\n/**/\n    2859,\n/**/\n    2858,\n/**/\n    2857,\n/**/\n    2856,\n/**/\n    2855,\n/**/\n    2854,\n/**/\n    2853,\n/**/\n    2852,\n/**/\n    2851,\n/**/\n    2850,\n/**/\n    2849,\n/**/\n    2848,\n/**/\n    2847,\n/**/\n    2846,\n/**/\n    2845,\n/**/\n    2844,\n/**/\n    2843,\n/**/\n    2842,\n/**/\n    2841,\n/**/\n    2840,\n/**/\n    2839,\n/**/\n    2838,\n/**/\n    2837,\n/**/\n    2836,\n/**/\n    2835,\n/**/\n    2834,\n/**/\n    2833,\n/**/\n    2832,\n/**/\n    2831,\n/**/\n    2830,\n/**/\n    2829,\n/**/\n    2828,\n/**/\n    2827,\n/**/\n    2826,\n/**/\n    2825,\n/**/\n    2824,\n/**/\n    2823,\n/**/\n    2822,\n/**/\n    2821,\n/**/\n    2820,\n/**/\n    2819,\n/**/\n    2818,\n/**/\n    2817,\n/**/\n    2816,\n/**/\n    2815,\n/**/\n    2814,\n/**/\n    2813,\n/**/\n    2812,\n/**/\n    2811,\n/**/\n    2810,\n/**/\n    2809,\n/**/\n    2808,\n/**/\n    2807,\n/**/\n    2806,\n/**/\n    2805,\n/**/\n    2804,\n/**/\n    2803,\n/**/\n    2802,\n/**/\n    2801,\n/**/\n    2800,\n/**/\n    2799,\n/**/\n    2798,\n/**/\n    2797,\n/**/\n    2796,\n/**/\n    2795,\n/**/\n    2794,\n/**/\n    2793,\n/**/\n    2792,\n/**/\n    2791,\n/**/\n    2790,\n/**/\n    2789,\n/**/\n    2788,\n/**/\n    2787,\n/**/\n    2786,\n/**/\n    2785,\n/**/\n    2784,\n/**/\n    2783,\n/**/\n    2782,\n/**/\n    2781,\n/**/\n    2780,\n/**/\n    2779,\n/**/\n    2778,\n/**/\n    2777,\n/**/\n    2776,\n/**/\n    2775,\n/**/\n    2774,\n/**/\n    2773,\n/**/\n    2772,\n/**/\n    2771,\n/**/\n    2770,\n/**/\n    2769,\n/**/\n    2768,\n/**/\n    2767,\n/**/\n    2766,\n/**/\n    2765,\n/**/\n    2764,\n/**/\n    2763,\n/**/\n    2762,\n/**/\n    2761,\n/**/\n    2760,\n/**/\n    2759,\n/**/\n    2758,\n/**/\n    2757,\n/**/\n    2756,\n/**/\n    2755,\n/**/\n    2754,\n/**/\n    2753,\n/**/\n    2752,\n/**/\n    2751,\n/**/\n    2750,\n/**/\n    2749,\n/**/\n    2748,\n/**/\n    2747,\n/**/\n    2746,\n/**/\n    2745,\n/**/\n    2744,\n/**/\n    2743,\n/**/\n    2742,\n/**/\n    2741,\n/**/\n    2740,\n/**/\n    2739,\n/**/\n    2738,\n/**/\n    2737,\n/**/\n    2736,\n/**/\n    2735,\n/**/\n    2734,\n/**/\n    2733,\n/**/\n    2732,\n/**/\n    2731,\n/**/\n    2730,\n/**/\n    2729,\n/**/\n    2728,\n/**/\n    2727,\n/**/\n    2726,\n/**/\n    2725,\n/**/\n    2724,\n/**/\n    2723,\n/**/\n    2722,\n/**/\n    2721,\n/**/\n    2720,\n/**/\n    2719,\n/**/\n    2718,\n/**/\n    2717,\n/**/\n    2716,\n/**/\n    2715,\n/**/\n    2714,\n/**/\n    2713,\n/**/\n    2712,\n/**/\n    2711,\n/**/\n    2710,\n/**/\n    2709,\n/**/\n    2708,\n/**/\n    2707,\n/**/\n    2706,\n/**/\n    2705,\n/**/\n    2704,\n/**/\n    2703,\n/**/\n    2702,\n/**/\n    2701,\n/**/\n    2700,\n/**/\n    2699,\n/**/\n    2698,\n/**/\n    2697,\n/**/\n    2696,\n/**/\n    2695,\n/**/\n    2694,\n/**/\n    2693,\n/**/\n    2692,\n/**/\n    2691,\n/**/\n    2690,\n/**/\n    2689,\n/**/\n    2688,\n/**/\n    2687,\n/**/\n    2686,\n/**/\n    2685,\n/**/\n    2684,\n/**/\n    2683,\n/**/\n    2682,\n/**/\n    2681,\n/**/\n    2680,\n/**/\n    2679,\n/**/\n    2678,\n/**/\n    2677,\n/**/\n    2676,\n/**/\n    2675,\n/**/\n    2674,\n/**/\n    2673,\n/**/\n    2672,\n/**/\n    2671,\n/**/\n    2670,\n/**/\n    2669,\n/**/\n    2668,\n/**/\n    2667,\n/**/\n    2666,\n/**/\n    2665,\n/**/\n    2664,\n/**/\n    2663,\n/**/\n    2662,\n/**/\n    2661,\n/**/\n    2660,\n/**/\n    2659,\n/**/\n    2658,\n/**/\n    2657,\n/**/\n    2656,\n/**/\n    2655,\n/**/\n    2654,\n/**/\n    2653,\n/**/\n    2652,\n/**/\n    2651,\n/**/\n    2650,\n/**/\n    2649,\n/**/\n    2648,\n/**/\n    2647,\n/**/\n    2646,\n/**/\n    2645,\n/**/\n    2644,\n/**/\n    2643,\n/**/\n    2642,\n/**/\n    2641,\n/**/\n    2640,\n/**/\n    2639,\n/**/\n    2638,\n/**/\n    2637,\n/**/\n    2636,\n/**/\n    2635,\n/**/\n    2634,\n/**/\n    2633,\n/**/\n    2632,\n/**/\n    2631,\n/**/\n    2630,\n/**/\n    2629,\n/**/\n    2628,\n/**/\n    2627,\n/**/\n    2626,\n/**/\n    2625,\n/**/\n    2624,\n/**/\n    2623,\n/**/\n    2622,\n/**/\n    2621,\n/**/\n    2620,\n/**/\n    2619,\n/**/\n    2618,\n/**/\n    2617,\n/**/\n    2616,\n/**/\n    2615,\n/**/\n    2614,\n/**/\n    2613,\n/**/\n    2612,\n/**/\n    2611,\n/**/\n    2610,\n/**/\n    2609,\n/**/\n    2608,\n/**/\n    2607,\n/**/\n    2606,\n/**/\n    2605,\n/**/\n    2604,\n/**/\n    2603,\n/**/\n    2602,\n/**/\n    2601,\n/**/\n    2600,\n/**/\n    2599,\n/**/\n    2598,\n/**/\n    2597,\n/**/\n    2596,\n/**/\n    2595,\n/**/\n    2594,\n/**/\n    2593,\n/**/\n    2592,\n/**/\n    2591,\n/**/\n    2590,\n/**/\n    2589,\n/**/\n    2588,\n/**/\n    2587,\n/**/\n    2586,\n/**/\n    2585,\n/**/\n    2584,\n/**/\n    2583,\n/**/\n    2582,\n/**/\n    2581,\n/**/\n    2580,\n/**/\n    2579,\n/**/\n    2578,\n/**/\n    2577,\n/**/\n    2576,\n/**/\n    2575,\n/**/\n    2574,\n/**/\n    2573,\n/**/\n    2572,\n/**/\n    2571,\n/**/\n    2570,\n/**/\n    2569,\n/**/\n    2568,\n/**/\n    2567,\n/**/\n    2566,\n/**/\n    2565,\n/**/\n    2564,\n/**/\n    2563,\n/**/\n    2562,\n/**/\n    2561,\n/**/\n    2560,\n/**/\n    2559,\n/**/\n    2558,\n/**/\n    2557,\n/**/\n    2556,\n/**/\n    2555,\n/**/\n    2554,\n/**/\n    2553,\n/**/\n    2552,\n/**/\n    2551,\n/**/\n    2550,\n/**/\n    2549,\n/**/\n    2548,\n/**/\n    2547,\n/**/\n    2546,\n/**/\n    2545,\n/**/\n    2544,\n/**/\n    2543,\n/**/\n    2542,\n/**/\n    2541,\n/**/\n    2540,\n/**/\n    2539,\n/**/\n    2538,\n/**/\n    2537,\n/**/\n    2536,\n/**/\n    2535,\n/**/\n    2534,\n/**/\n    2533,\n/**/\n    2532,\n/**/\n    2531,\n/**/\n    2530,\n/**/\n    2529,\n/**/\n    2528,\n/**/\n    2527,\n/**/\n    2526,\n/**/\n    2525,\n/**/\n    2524,\n/**/\n    2523,\n/**/\n    2522,\n/**/\n    2521,\n/**/\n    2520,\n/**/\n    2519,\n/**/\n    2518,\n/**/\n    2517,\n/**/\n    2516,\n/**/\n    2515,\n/**/\n    2514,\n/**/\n    2513,\n/**/\n    2512,\n/**/\n    2511,\n/**/\n    2510,\n/**/\n    2509,\n/**/\n    2508,\n/**/\n    2507,\n/**/\n    2506,\n/**/\n    2505,\n/**/\n    2504,\n/**/\n    2503,\n/**/\n    2502,\n/**/\n    2501,\n/**/\n    2500,\n/**/\n    2499,\n/**/\n    2498,\n/**/\n    2497,\n/**/\n    2496,\n/**/\n    2495,\n/**/\n    2494,\n/**/\n    2493,\n/**/\n    2492,\n/**/\n    2491,\n/**/\n    2490,\n/**/\n    2489,\n/**/\n    2488,\n/**/\n    2487,\n/**/\n    2486,\n/**/\n    2485,\n/**/\n    2484,\n/**/\n    2483,\n/**/\n    2482,\n/**/\n    2481,\n/**/\n    2480,\n/**/\n    2479,\n/**/\n    2478,\n/**/\n    2477,\n/**/\n    2476,\n/**/\n    2475,\n/**/\n    2474,\n/**/\n    2473,\n/**/\n    2472,\n/**/\n    2471,\n/**/\n    2470,\n/**/\n    2469,\n/**/\n    2468,\n/**/\n    2467,\n/**/\n    2466,\n/**/\n    2465,\n/**/\n    2464,\n/**/\n    2463,\n/**/\n    2462,\n/**/\n    2461,\n/**/\n    2460,\n/**/\n    2459,\n/**/\n    2458,\n/**/\n    2457,\n/**/\n    2456,\n/**/\n    2455,\n/**/\n    2454,\n/**/\n    2453,\n/**/\n    2452,\n/**/\n    2451,\n/**/\n    2450,\n/**/\n    2449,\n/**/\n    2448,\n/**/\n    2447,\n/**/\n    2446,\n/**/\n    2445,\n/**/\n    2444,\n/**/\n    2443,\n/**/\n    2442,\n/**/\n    2441,\n/**/\n    2440,\n/**/\n    2439,\n/**/\n    2438,\n/**/\n    2437,\n/**/\n    2436,\n/**/\n    2435,\n/**/\n    2434,\n/**/\n    2433,\n/**/\n    2432,\n/**/\n    2431,\n/**/\n    2430,\n/**/\n    2429,\n/**/\n    2428,\n/**/\n    2427,\n/**/\n    2426,\n/**/\n    2425,\n/**/\n    2424,\n/**/\n    2423,\n/**/\n    2422,\n/**/\n    2421,\n/**/\n    2420,\n/**/\n    2419,\n/**/\n    2418,\n/**/\n    2417,\n/**/\n    2416,\n/**/\n    2415,\n/**/\n    2414,\n/**/\n    2413,\n/**/\n    2412,\n/**/\n    2411,\n/**/\n    2410,\n/**/\n    2409,\n/**/\n    2408,\n/**/\n    2407,\n/**/\n    2406,\n/**/\n    2405,\n/**/\n    2404,\n/**/\n    2403,\n/**/\n    2402,\n/**/\n    2401,\n/**/\n    2400,\n/**/\n    2399,\n/**/\n    2398,\n/**/\n    2397,\n/**/\n    2396,\n/**/\n    2395,\n/**/\n    2394,\n/**/\n    2393,\n/**/\n    2392,\n/**/\n    2391,\n/**/\n    2390,\n/**/\n    2389,\n/**/\n    2388,\n/**/\n    2387,\n/**/\n    2386,\n/**/\n    2385,\n/**/\n    2384,\n/**/\n    2383,\n/**/\n    2382,\n/**/\n    2381,\n/**/\n    2380,\n/**/\n    2379,\n/**/\n    2378,\n/**/\n    2377,\n/**/\n    2376,\n/**/\n    2375,\n/**/\n    2374,\n/**/\n    2373,\n/**/\n    2372,\n/**/\n    2371,\n/**/\n    2370,\n/**/\n    2369,\n/**/\n    2368,\n/**/\n    2367,\n/**/\n    2366,\n/**/\n    2365,\n/**/\n    2364,\n/**/\n    2363,\n/**/\n    2362,\n/**/\n    2361,\n/**/\n    2360,\n/**/\n    2359,\n/**/\n    2358,\n/**/\n    2357,\n/**/\n    2356,\n/**/\n    2355,\n/**/\n    2354,\n/**/\n    2353,\n/**/\n    2352,\n/**/\n    2351,\n/**/\n    2350,\n/**/\n    2349,\n/**/\n    2348,\n/**/\n    2347,\n/**/\n    2346,\n/**/\n    2345,\n/**/\n    2344,\n/**/\n    2343,\n/**/\n    2342,\n/**/\n    2341,\n/**/\n    2340,\n/**/\n    2339,\n/**/\n    2338,\n/**/\n    2337,\n/**/\n    2336,\n/**/\n    2335,\n/**/\n    2334,\n/**/\n    2333,\n/**/\n    2332,\n/**/\n    2331,\n/**/\n    2330,\n/**/\n    2329,\n/**/\n    2328,\n/**/\n    2327,\n/**/\n    2326,\n/**/\n    2325,\n/**/\n    2324,\n/**/\n    2323,\n/**/\n    2322,\n/**/\n    2321,\n/**/\n    2320,\n/**/\n    2319,\n/**/\n    2318,\n/**/\n    2317,\n/**/\n    2316,\n/**/\n    2315,\n/**/\n    2314,\n/**/\n    2313,\n/**/\n    2312,\n/**/\n    2311,\n/**/\n    2310,\n/**/\n    2309,\n/**/\n    2308,\n/**/\n    2307,\n/**/\n    2306,\n/**/\n    2305,\n/**/\n    2304,\n/**/\n    2303,\n/**/\n    2302,\n/**/\n    2301,\n/**/\n    2300,\n/**/\n    2299,\n/**/\n    2298,\n/**/\n    2297,\n/**/\n    2296,\n/**/\n    2295,\n/**/\n    2294,\n/**/\n    2293,\n/**/\n    2292,\n/**/\n    2291,\n/**/\n    2290,\n/**/\n    2289,\n/**/\n    2288,\n/**/\n    2287,\n/**/\n    2286,\n/**/\n    2285,\n/**/\n    2284,\n/**/\n    2283,\n/**/\n    2282,\n/**/\n    2281,\n/**/\n    2280,\n/**/\n    2279,\n/**/\n    2278,\n/**/\n    2277,\n/**/\n    2276,\n/**/\n    2275,\n/**/\n    2274,\n/**/\n    2273,\n/**/\n    2272,\n/**/\n    2271,\n/**/\n    2270,\n/**/\n    2269,\n/**/\n    2268,\n/**/\n    2267,\n/**/\n    2266,\n/**/\n    2265,\n/**/\n    2264,\n/**/\n    2263,\n/**/\n    2262,\n/**/\n    2261,\n/**/\n    2260,\n/**/\n    2259,\n/**/\n    2258,\n/**/\n    2257,\n/**/\n    2256,\n/**/\n    2255,\n/**/\n    2254,\n/**/\n    2253,\n/**/\n    2252,\n/**/\n    2251,\n/**/\n    2250,\n/**/\n    2249,\n/**/\n    2248,\n/**/\n    2247,\n/**/\n    2246,\n/**/\n    2245,\n/**/\n    2244,\n/**/\n    2243,\n/**/\n    2242,\n/**/\n    2241,\n/**/\n    2240,\n/**/\n    2239,\n/**/\n    2238,\n/**/\n    2237,\n/**/\n    2236,\n/**/\n    2235,\n/**/\n    2234,\n/**/\n    2233,\n/**/\n    2232,\n/**/\n    2231,\n/**/\n    2230,\n/**/\n    2229,\n/**/\n    2228,\n/**/\n    2227,\n/**/\n    2226,\n/**/\n    2225,\n/**/\n    2224,\n/**/\n    2223,\n/**/\n    2222,\n/**/\n    2221,\n/**/\n    2220,\n/**/\n    2219,\n/**/\n    2218,\n/**/\n    2217,\n/**/\n    2216,\n/**/\n    2215,\n/**/\n    2214,\n/**/\n    2213,\n/**/\n    2212,\n/**/\n    2211,\n/**/\n    2210,\n/**/\n    2209,\n/**/\n    2208,\n/**/\n    2207,\n/**/\n    2206,\n/**/\n    2205,\n/**/\n    2204,\n/**/\n    2203,\n/**/\n    2202,\n/**/\n    2201,\n/**/\n    2200,\n/**/\n    2199,\n/**/\n    2198,\n/**/\n    2197,\n/**/\n    2196,\n/**/\n    2195,\n/**/\n    2194,\n/**/\n    2193,\n/**/\n    2192,\n/**/\n    2191,\n/**/\n    2190,\n/**/\n    2189,\n/**/\n    2188,\n/**/\n    2187,\n/**/\n    2186,\n/**/\n    2185,\n/**/\n    2184,\n/**/\n    2183,\n/**/\n    2182,\n/**/\n    2181,\n/**/\n    2180,\n/**/\n    2179,\n/**/\n    2178,\n/**/\n    2177,\n/**/\n    2176,\n/**/\n    2175,\n/**/\n    2174,\n/**/\n    2173,\n/**/\n    2172,\n/**/\n    2171,\n/**/\n    2170,\n/**/\n    2169,\n/**/\n    2168,\n/**/\n    2167,\n/**/\n    2166,\n/**/\n    2165,\n/**/\n    2164,\n/**/\n    2163,\n/**/\n    2162,\n/**/\n    2161,\n/**/\n    2160,\n/**/\n    2159,\n/**/\n    2158,\n/**/\n    2157,\n/**/\n    2156,\n/**/\n    2155,\n/**/\n    2154,\n/**/\n    2153,\n/**/\n    2152,\n/**/\n    2151,\n/**/\n    2150,\n/**/\n    2149,\n/**/\n    2148,\n/**/\n    2147,\n/**/\n    2146,\n/**/\n    2145,\n/**/\n    2144,\n/**/\n    2143,\n/**/\n    2142,\n/**/\n    2141,\n/**/\n    2140,\n/**/\n    2139,\n/**/\n    2138,\n/**/\n    2137,\n/**/\n    2136,\n/**/\n    2135,\n/**/\n    2134,\n/**/\n    2133,\n/**/\n    2132,\n/**/\n    2131,\n/**/\n    2130,\n/**/\n    2129,\n/**/\n    2128,\n/**/\n    2127,\n/**/\n    2126,\n/**/\n    2125,\n/**/\n    2124,\n/**/\n    2123,\n/**/\n    2122,\n/**/\n    2121,\n/**/\n    2120,\n/**/\n    2119,\n/**/\n    2118,\n/**/\n    2117,\n/**/\n    2116,\n/**/\n    2115,\n/**/\n    2114,\n/**/\n    2113,\n/**/\n    2112,\n/**/\n    2111,\n/**/\n    2110,\n/**/\n    2109,\n/**/\n    2108,\n/**/\n    2107,\n/**/\n    2106,\n/**/\n    2105,\n/**/\n    2104,\n/**/\n    2103,\n/**/\n    2102,\n/**/\n    2101,\n/**/\n    2100,\n/**/\n    2099,\n/**/\n    2098,\n/**/\n    2097,\n/**/\n    2096,\n/**/\n    2095,\n/**/\n    2094,\n/**/\n    2093,\n/**/\n    2092,\n/**/\n    2091,\n/**/\n    2090,\n/**/\n    2089,\n/**/\n    2088,\n/**/\n    2087,\n/**/\n    2086,\n/**/\n    2085,\n/**/\n    2084,\n/**/\n    2083,\n/**/\n    2082,\n/**/\n    2081,\n/**/\n    2080,\n/**/\n    2079,\n/**/\n    2078,\n/**/\n    2077,\n/**/\n    2076,\n/**/\n    2075,\n/**/\n    2074,\n/**/\n    2073,\n/**/\n    2072,\n/**/\n    2071,\n/**/\n    2070,\n/**/\n    2069,\n/**/\n    2068,\n/**/\n    2067,\n/**/\n    2066,\n/**/\n    2065,\n/**/\n    2064,\n/**/\n    2063,\n/**/\n    2062,\n/**/\n    2061,\n/**/\n    2060,\n/**/\n    2059,\n/**/\n    2058,\n/**/\n    2057,\n/**/\n    2056,\n/**/\n    2055,\n/**/\n    2054,\n/**/\n    2053,\n/**/\n    2052,\n/**/\n    2051,\n/**/\n    2050,\n/**/\n    2049,\n/**/\n    2048,\n/**/\n    2047,\n/**/\n    2046,\n/**/\n    2045,\n/**/\n    2044,\n/**/\n    2043,\n/**/\n    2042,\n/**/\n    2041,\n/**/\n    2040,\n/**/\n    2039,\n/**/\n    2038,\n/**/\n    2037,\n/**/\n    2036,\n/**/\n    2035,\n/**/\n    2034,\n/**/\n    2033,\n/**/\n    2032,\n/**/\n    2031,\n/**/\n    2030,\n/**/\n    2029,\n/**/\n    2028,\n/**/\n    2027,\n/**/\n    2026,\n/**/\n    2025,\n/**/\n    2024,\n/**/\n    2023,\n/**/\n    2022,\n/**/\n    2021,\n/**/\n    2020,\n/**/\n    2019,\n/**/\n    2018,\n/**/\n    2017,\n/**/\n    2016,\n/**/\n    2015,\n/**/\n    2014,\n/**/\n    2013,\n/**/\n    2012,\n/**/\n    2011,\n/**/\n    2010,\n/**/\n    2009,\n/**/\n    2008,\n/**/\n    2007,\n/**/\n    2006,\n/**/\n    2005,\n/**/\n    2004,\n/**/\n    2003,\n/**/\n    2002,\n/**/\n    2001,\n/**/\n    2000,\n/**/\n    1999,\n/**/\n    1998,\n/**/\n    1997,\n/**/\n    1996,\n/**/\n    1995,\n/**/\n    1994,\n/**/\n    1993,\n/**/\n    1992,\n/**/\n    1991,\n/**/\n    1990,\n/**/\n    1989,\n/**/\n    1988,\n/**/\n    1987,\n/**/\n    1986,\n/**/\n    1985,\n/**/\n    1984,\n/**/\n    1983,\n/**/\n    1982,\n/**/\n    1981,\n/**/\n    1980,\n/**/\n    1979,\n/**/\n    1978,\n/**/\n    1977,\n/**/\n    1976,\n/**/\n    1975,\n/**/\n    1974,\n/**/\n    1973,\n/**/\n    1972,\n/**/\n    1971,\n/**/\n    1970,\n/**/\n    1969,\n/**/\n    1968,\n/**/\n    1967,\n/**/\n    1966,\n/**/\n    1965,\n/**/\n    1964,\n/**/\n    1963,\n/**/\n    1962,\n/**/\n    1961,\n/**/\n    1960,\n/**/\n    1959,\n/**/\n    1958,\n/**/\n    1957,\n/**/\n    1956,\n/**/\n    1955,\n/**/\n    1954,\n/**/\n    1953,\n/**/\n    1952,\n/**/\n    1951,\n/**/\n    1950,\n/**/\n    1949,\n/**/\n    1948,\n/**/\n    1947,\n/**/\n    1946,\n/**/\n    1945,\n/**/\n    1944,\n/**/\n    1943,\n/**/\n    1942,\n/**/\n    1941,\n/**/\n    1940,\n/**/\n    1939,\n/**/\n    1938,\n/**/\n    1937,\n/**/\n    1936,\n/**/\n    1935,\n/**/\n    1934,\n/**/\n    1933,\n/**/\n    1932,\n/**/\n    1931,\n/**/\n    1930,\n/**/\n    1929,\n/**/\n    1928,\n/**/\n    1927,\n/**/\n    1926,\n/**/\n    1925,\n/**/\n    1924,\n/**/\n    1923,\n/**/\n    1922,\n/**/\n    1921,\n/**/\n    1920,\n/**/\n    1919,\n/**/\n    1918,\n/**/\n    1917,\n/**/\n    1916,\n/**/\n    1915,\n/**/\n    1914,\n/**/\n    1913,\n/**/\n    1912,\n/**/\n    1911,\n/**/\n    1910,\n/**/\n    1909,\n/**/\n    1908,\n/**/\n    1907,\n/**/\n    1906,\n/**/\n    1905,\n/**/\n    1904,\n/**/\n    1903,\n/**/\n    1902,\n/**/\n    1901,\n/**/\n    1900,\n/**/\n    1899,\n/**/\n    1898,\n/**/\n    1897,\n/**/\n    1896,\n/**/\n    1895,\n/**/\n    1894,\n/**/\n    1893,\n/**/\n    1892,\n/**/\n    1891,\n/**/\n    1890,\n/**/\n    1889,\n/**/\n    1888,\n/**/\n    1887,\n/**/\n    1886,\n/**/\n    1885,\n/**/\n    1884,\n/**/\n    1883,\n/**/\n    1882,\n/**/\n    1881,\n/**/\n    1880,\n/**/\n    1879,\n/**/\n    1878,\n/**/\n    1877,\n/**/\n    1876,\n/**/\n    1875,\n/**/\n    1874,\n/**/\n    1873,\n/**/\n    1872,\n/**/\n    1871,\n/**/\n    1870,\n/**/\n    1869,\n/**/\n    1868,\n/**/\n    1867,\n/**/\n    1866,\n/**/\n    1865,\n/**/\n    1864,\n/**/\n    1863,\n/**/\n    1862,\n/**/\n    1861,\n/**/\n    1860,\n/**/\n    1859,\n/**/\n    1858,\n/**/\n    1857,\n/**/\n    1856,\n/**/\n    1855,\n/**/\n    1854,\n/**/\n    1853,\n/**/\n    1852,\n/**/\n    1851,\n/**/\n    1850,\n/**/\n    1849,\n/**/\n    1848,\n/**/\n    1847,\n/**/\n    1846,\n/**/\n    1845,\n/**/\n    1844,\n/**/\n    1843,\n/**/\n    1842,\n/**/\n    1841,\n/**/\n    1840,\n/**/\n    1839,\n/**/\n    1838,\n/**/\n    1837,\n/**/\n    1836,\n/**/\n    1835,\n/**/\n    1834,\n/**/\n    1833,\n/**/\n    1832,\n/**/\n    1831,\n/**/\n    1830,\n/**/\n    1829,\n/**/\n    1828,\n/**/\n    1827,\n/**/\n    1826,\n/**/\n    1825,\n/**/\n    1824,\n/**/\n    1823,\n/**/\n    1822,\n/**/\n    1821,\n/**/\n    1820,\n/**/\n    1819,\n/**/\n    1818,\n/**/\n    1817,\n/**/\n    1816,\n/**/\n    1815,\n/**/\n    1814,\n/**/\n    1813,\n/**/\n    1812,\n/**/\n    1811,\n/**/\n    1810,\n/**/\n    1809,\n/**/\n    1808,\n/**/\n    1807,\n/**/\n    1806,\n/**/\n    1805,\n/**/\n    1804,\n/**/\n    1803,\n/**/\n    1802,\n/**/\n    1801,\n/**/\n    1800,\n/**/\n    1799,\n/**/\n    1798,\n/**/\n    1797,\n/**/\n    1796,\n/**/\n    1795,\n/**/\n    1794,\n/**/\n    1793,\n/**/\n    1792,\n/**/\n    1791,\n/**/\n    1790,\n/**/\n    1789,\n/**/\n    1788,\n/**/\n    1787,\n/**/\n    1786,\n/**/\n    1785,\n/**/\n    1784,\n/**/\n    1783,\n/**/\n    1782,\n/**/\n    1781,\n/**/\n    1780,\n/**/\n    1779,\n/**/\n    1778,\n/**/\n    1777,\n/**/\n    1776,\n/**/\n    1775,\n/**/\n    1774,\n/**/\n    1773,\n/**/\n    1772,\n/**/\n    1771,\n/**/\n    1770,\n/**/\n    1769,\n/**/\n    1768,\n/**/\n    1767,\n/**/\n    1766,\n/**/\n    1765,\n/**/\n    1764,\n/**/\n    1763,\n/**/\n    1762,\n/**/\n    1761,\n/**/\n    1760,\n/**/\n    1759,\n/**/\n    1758,\n/**/\n    1757,\n/**/\n    1756,\n/**/\n    1755,\n/**/\n    1754,\n/**/\n    1753,\n/**/\n    1752,\n/**/\n    1751,\n/**/\n    1750,\n/**/\n    1749,\n/**/\n    1748,\n/**/\n    1747,\n/**/\n    1746,\n/**/\n    1745,\n/**/\n    1744,\n/**/\n    1743,\n/**/\n    1742,\n/**/\n    1741,\n/**/\n    1740,\n/**/\n    1739,\n/**/\n    1738,\n/**/\n    1737,\n/**/\n    1736,\n/**/\n    1735,\n/**/\n    1734,\n/**/\n    1733,\n/**/\n    1732,\n/**/\n    1731,\n/**/\n    1730,\n/**/\n    1729,\n/**/\n    1728,\n/**/\n    1727,\n/**/\n    1726,\n/**/\n    1725,\n/**/\n    1724,\n/**/\n    1723,\n/**/\n    1722,\n/**/\n    1721,\n/**/\n    1720,\n/**/\n    1719,\n/**/\n    1718,\n/**/\n    1717,\n/**/\n    1716,\n/**/\n    1715,\n/**/\n    1714,\n/**/\n    1713,\n/**/\n    1712,\n/**/\n    1711,\n/**/\n    1710,\n/**/\n    1709,\n/**/\n    1708,\n/**/\n    1707,\n/**/\n    1706,\n/**/\n    1705,\n/**/\n    1704,\n/**/\n    1703,\n/**/\n    1702,\n/**/\n    1701,\n/**/\n    1700,\n/**/\n    1699,\n/**/\n    1698,\n/**/\n    1697,\n/**/\n    1696,\n/**/\n    1695,\n/**/\n    1694,\n/**/\n    1693,\n/**/\n    1692,\n/**/\n    1691,\n/**/\n    1690,\n/**/\n    1689,\n/**/\n    1688,\n/**/\n    1687,\n/**/\n    1686,\n/**/\n    1685,\n/**/\n    1684,\n/**/\n    1683,\n/**/\n    1682,\n/**/\n    1681,\n/**/\n    1680,\n/**/\n    1679,\n/**/\n    1678,\n/**/\n    1677,\n/**/\n    1676,\n/**/\n    1675,\n/**/\n    1674,\n/**/\n    1673,\n/**/\n    1672,\n/**/\n    1671,\n/**/\n    1670,\n/**/\n    1669,\n/**/\n    1668,\n/**/\n    1667,\n/**/\n    1666,\n/**/\n    1665,\n/**/\n    1664,\n/**/\n    1663,\n/**/\n    1662,\n/**/\n    1661,\n/**/\n    1660,\n/**/\n    1659,\n/**/\n    1658,\n/**/\n    1657,\n/**/\n    1656,\n/**/\n    1655,\n/**/\n    1654,\n/**/\n    1653,\n/**/\n    1652,\n/**/\n    1651,\n/**/\n    1650,\n/**/\n    1649,\n/**/\n    1648,\n/**/\n    1647,\n/**/\n    1646,\n/**/\n    1645,\n/**/\n    1644,\n/**/\n    1643,\n/**/\n    1642,\n/**/\n    1641,\n/**/\n    1640,\n/**/\n    1639,\n/**/\n    1638,\n/**/\n    1637,\n/**/\n    1636,\n/**/\n    1635,\n/**/\n    1634,\n/**/\n    1633,\n/**/\n    1632,\n/**/\n    1631,\n/**/\n    1630,\n/**/\n    1629,\n/**/\n    1628,\n/**/\n    1627,\n/**/\n    1626,\n/**/\n    1625,\n/**/\n    1624,\n/**/\n    1623,\n/**/\n    1622,\n/**/\n    1621,\n/**/\n    1620,\n/**/\n    1619,\n/**/\n    1618,\n/**/\n    1617,\n/**/\n    1616,\n/**/\n    1615,\n/**/\n    1614,\n/**/\n    1613,\n/**/\n    1612,\n/**/\n    1611,\n/**/\n    1610,\n/**/\n    1609,\n/**/\n    1608,\n/**/\n    1607,\n/**/\n    1606,\n/**/\n    1605,\n/**/\n    1604,\n/**/\n    1603,\n/**/\n    1602,\n/**/\n    1601,\n/**/\n    1600,\n/**/\n    1599,\n/**/\n    1598,\n/**/\n    1597,\n/**/\n    1596,\n/**/\n    1595,\n/**/\n    1594,\n/**/\n    1593,\n/**/\n    1592,\n/**/\n    1591,\n/**/\n    1590,\n/**/\n    1589,\n/**/\n    1588,\n/**/\n    1587,\n/**/\n    1586,\n/**/\n    1585,\n/**/\n    1584,\n/**/\n    1583,\n/**/\n    1582,\n/**/\n    1581,\n/**/\n    1580,\n/**/\n    1579,\n/**/\n    1578,\n/**/\n    1577,\n/**/\n    1576,\n/**/\n    1575,\n/**/\n    1574,\n/**/\n    1573,\n/**/\n    1572,\n/**/\n    1571,\n/**/\n    1570,\n/**/\n    1569,\n/**/\n    1568,\n/**/\n    1567,\n/**/\n    1566,\n/**/\n    1565,\n/**/\n    1564,\n/**/\n    1563,\n/**/\n    1562,\n/**/\n    1561,\n/**/\n    1560,\n/**/\n    1559,\n/**/\n    1558,\n/**/\n    1557,\n/**/\n    1556,\n/**/\n    1555,\n/**/\n    1554,\n/**/\n    1553,\n/**/\n    1552,\n/**/\n    1551,\n/**/\n    1550,\n/**/\n    1549,\n/**/\n    1548,\n/**/\n    1547,\n/**/\n    1546,\n/**/\n    1545,\n/**/\n    1544,\n/**/\n    1543,\n/**/\n    1542,\n/**/\n    1541,\n/**/\n    1540,\n/**/\n    1539,\n/**/\n    1538,\n/**/\n    1537,\n/**/\n    1536,\n/**/\n    1535,\n/**/\n    1534,\n/**/\n    1533,\n/**/\n    1532,\n/**/\n    1531,\n/**/\n    1530,\n/**/\n    1529,\n/**/\n    1528,\n/**/\n    1527,\n/**/\n    1526,\n/**/\n    1525,\n/**/\n    1524,\n/**/\n    1523,\n/**/\n    1522,\n/**/\n    1521,\n/**/\n    1520,\n/**/\n    1519,\n/**/\n    1518,\n/**/\n    1517,\n/**/\n    1516,\n/**/\n    1515,\n/**/\n    1514,\n/**/\n    1513,\n/**/\n    1512,\n/**/\n    1511,\n/**/\n    1510,\n/**/\n    1509,\n/**/\n    1508,\n/**/\n    1507,\n/**/\n    1506,\n/**/\n    1505,\n/**/\n    1504,\n/**/\n    1503,\n/**/\n    1502,\n/**/\n    1501,\n/**/\n    1500,\n/**/\n    1499,\n/**/\n    1498,\n/**/\n    1497,\n/**/\n    1496,\n/**/\n    1495,\n/**/\n    1494,\n/**/\n    1493,\n/**/\n    1492,\n/**/\n    1491,\n/**/\n    1490,\n/**/\n    1489,\n/**/\n    1488,\n/**/\n    1487,\n/**/\n    1486,\n/**/\n    1485,\n/**/\n    1484,\n/**/\n    1483,\n/**/\n    1482,\n/**/\n    1481,\n/**/\n    1480,\n/**/\n    1479,\n/**/\n    1478,\n/**/\n    1477,\n/**/\n    1476,\n/**/\n    1475,\n/**/\n    1474,\n/**/\n    1473,\n/**/\n    1472,\n/**/\n    1471,\n/**/\n    1470,\n/**/\n    1469,\n/**/\n    1468,\n/**/\n    1467,\n/**/\n    1466,\n/**/\n    1465,\n/**/\n    1464,\n/**/\n    1463,\n/**/\n    1462,\n/**/\n    1461,\n/**/\n    1460,\n/**/\n    1459,\n/**/\n    1458,\n/**/\n    1457,\n/**/\n    1456,\n/**/\n    1455,\n/**/\n    1454,\n/**/\n    1453,\n/**/\n    1452,\n/**/\n    1451,\n/**/\n    1450,\n/**/\n    1449,\n/**/\n    1448,\n/**/\n    1447,\n/**/\n    1446,\n/**/\n    1445,\n/**/\n    1444,\n/**/\n    1443,\n/**/\n    1442,\n/**/\n    1441,\n/**/\n    1440,\n/**/\n    1439,\n/**/\n    1438,\n/**/\n    1437,\n/**/\n    1436,\n/**/\n    1435,\n/**/\n    1434,\n/**/\n    1433,\n/**/\n    1432,\n/**/\n    1431,\n/**/\n    1430,\n/**/\n    1429,\n/**/\n    1428,\n/**/\n    1427,\n/**/\n    1426,\n/**/\n    1425,\n/**/\n    1424,\n/**/\n    1423,\n/**/\n    1422,\n/**/\n    1421,\n/**/\n    1420,\n/**/\n    1419,\n/**/\n    1418,\n/**/\n    1417,\n/**/\n    1416,\n/**/\n    1415,\n/**/\n    1414,\n/**/\n    1413,\n/**/\n    1412,\n/**/\n    1411,\n/**/\n    1410,\n/**/\n    1409,\n/**/\n    1408,\n/**/\n    1407,\n/**/\n    1406,\n/**/\n    1405,\n/**/\n    1404,\n/**/\n    1403,\n/**/\n    1402,\n/**/\n    1401,\n/**/\n    1400,\n/**/\n    1399,\n/**/\n    1398,\n/**/\n    1397,\n/**/\n    1396,\n/**/\n    1395,\n/**/\n    1394,\n/**/\n    1393,\n/**/\n    1392,\n/**/\n    1391,\n/**/\n    1390,\n/**/\n    1389,\n/**/\n    1388,\n/**/\n    1387,\n/**/\n    1386,\n/**/\n    1385,\n/**/\n    1384,\n/**/\n    1383,\n/**/\n    1382,\n/**/\n    1381,\n/**/\n    1380,\n/**/\n    1379,\n/**/\n    1378,\n/**/\n    1377,\n/**/\n    1376,\n/**/\n    1375,\n/**/\n    1374,\n/**/\n    1373,\n/**/\n    1372,\n/**/\n    1371,\n/**/\n    1370,\n/**/\n    1369,\n/**/\n    1368,\n/**/\n    1367,\n/**/\n    1366,\n/**/\n    1365,\n/**/\n    1364,\n/**/\n    1363,\n/**/\n    1362,\n/**/\n    1361,\n/**/\n    1360,\n/**/\n    1359,\n/**/\n    1358,\n/**/\n    1357,\n/**/\n    1356,\n/**/\n    1355,\n/**/\n    1354,\n/**/\n    1353,\n/**/\n    1352,\n/**/\n    1351,\n/**/\n    1350,\n/**/\n    1349,\n/**/\n    1348,\n/**/\n    1347,\n/**/\n    1346,\n/**/\n    1345,\n/**/\n    1344,\n/**/\n    1343,\n/**/\n    1342,\n/**/\n    1341,\n/**/\n    1340,\n/**/\n    1339,\n/**/\n    1338,\n/**/\n    1337,\n/**/\n    1336,\n/**/\n    1335,\n/**/\n    1334,\n/**/\n    1333,\n/**/\n    1332,\n/**/\n    1331,\n/**/\n    1330,\n/**/\n    1329,\n/**/\n    1328,\n/**/\n    1327,\n/**/\n    1326,\n/**/\n    1325,\n/**/\n    1324,\n/**/\n    1323,\n/**/\n    1322,\n/**/\n    1321,\n/**/\n    1320,\n/**/\n    1319,\n/**/\n    1318,\n/**/\n    1317,\n/**/\n    1316,\n/**/\n    1315,\n/**/\n    1314,\n/**/\n    1313,\n/**/\n    1312,\n/**/\n    1311,\n/**/\n    1310,\n/**/\n    1309,\n/**/\n    1308,\n/**/\n    1307,\n/**/\n    1306,\n/**/\n    1305,\n/**/\n    1304,\n/**/\n    1303,\n/**/\n    1302,\n/**/\n    1301,\n/**/\n    1300,\n/**/\n    1299,\n/**/\n    1298,\n/**/\n    1297,\n/**/\n    1296,\n/**/\n    1295,\n/**/\n    1294,\n/**/\n    1293,\n/**/\n    1292,\n/**/\n    1291,\n/**/\n    1290,\n/**/\n    1289,\n/**/\n    1288,\n/**/\n    1287,\n/**/\n    1286,\n/**/\n    1285,\n/**/\n    1284,\n/**/\n    1283,\n/**/\n    1282,\n/**/\n    1281,\n/**/\n    1280,\n/**/\n    1279,\n/**/\n    1278,\n/**/\n    1277,\n/**/\n    1276,\n/**/\n    1275,\n/**/\n    1274,\n/**/\n    1273,\n/**/\n    1272,\n/**/\n    1271,\n/**/\n    1270,\n/**/\n    1269,\n/**/\n    1268,\n/**/\n    1267,\n/**/\n    1266,\n/**/\n    1265,\n/**/\n    1264,\n/**/\n    1263,\n/**/\n    1262,\n/**/\n    1261,\n/**/\n    1260,\n/**/\n    1259,\n/**/\n    1258,\n/**/\n    1257,\n/**/\n    1256,\n/**/\n    1255,\n/**/\n    1254,\n/**/\n    1253,\n/**/\n    1252,\n/**/\n    1251,\n/**/\n    1250,\n/**/\n    1249,\n/**/\n    1248,\n/**/\n    1247,\n/**/\n    1246,\n/**/\n    1245,\n/**/\n    1244,\n/**/\n    1243,\n/**/\n    1242,\n/**/\n    1241,\n/**/\n    1240,\n/**/\n    1239,\n/**/\n    1238,\n/**/\n    1237,\n/**/\n    1236,\n/**/\n    1235,\n/**/\n    1234,\n/**/\n    1233,\n/**/\n    1232,\n/**/\n    1231,\n/**/\n    1230,\n/**/\n    1229,\n/**/\n    1228,\n/**/\n    1227,\n/**/\n    1226,\n/**/\n    1225,\n/**/\n    1224,\n/**/\n    1223,\n/**/\n    1222,\n/**/\n    1221,\n/**/\n    1220,\n/**/\n    1219,\n/**/\n    1218,\n/**/\n    1217,\n/**/\n    1216,\n/**/\n    1215,\n/**/\n    1214,\n/**/\n    1213,\n/**/\n    1212,\n/**/\n    1211,\n/**/\n    1210,\n/**/\n    1209,\n/**/\n    1208,\n/**/\n    1207,\n/**/\n    1206,\n/**/\n    1205,\n/**/\n    1204,\n/**/\n    1203,\n/**/\n    1202,\n/**/\n    1201,\n/**/\n    1200,\n/**/\n    1199,\n/**/\n    1198,\n/**/\n    1197,\n/**/\n    1196,\n/**/\n    1195,\n/**/\n    1194,\n/**/\n    1193,\n/**/\n    1192,\n/**/\n    1191,\n/**/\n    1190,\n/**/\n    1189,\n/**/\n    1188,\n/**/\n    1187,\n/**/\n    1186,\n/**/\n    1185,\n/**/\n    1184,\n/**/\n    1183,\n/**/\n    1182,\n/**/\n    1181,\n/**/\n    1180,\n/**/\n    1179,\n/**/\n    1178,\n/**/\n    1177,\n/**/\n    1176,\n/**/\n    1175,\n/**/\n    1174,\n/**/\n    1173,\n/**/\n    1172,\n/**/\n    1171,\n/**/\n    1170,\n/**/\n    1169,\n/**/\n    1168,\n/**/\n    1167,\n/**/\n    1166,\n/**/\n    1165,\n/**/\n    1164,\n/**/\n    1163,\n/**/\n    1162,\n/**/\n    1161,\n/**/\n    1160,\n/**/\n    1159,\n/**/\n    1158,\n/**/\n    1157,\n/**/\n    1156,\n/**/\n    1155,\n/**/\n    1154,\n/**/\n    1153,\n/**/\n    1152,\n/**/\n    1151,\n/**/\n    1150,\n/**/\n    1149,\n/**/\n    1148,\n/**/\n    1147,\n/**/\n    1146,\n/**/\n    1145,\n/**/\n    1144,\n/**/\n    1143,\n/**/\n    1142,\n/**/\n    1141,\n/**/\n    1140,\n/**/\n    1139,\n/**/\n    1138,\n/**/\n    1137,\n/**/\n    1136,\n/**/\n    1135,\n/**/\n    1134,\n/**/\n    1133,\n/**/\n    1132,\n/**/\n    1131,\n/**/\n    1130,\n/**/\n    1129,\n/**/\n    1128,\n/**/\n    1127,\n/**/\n    1126,\n/**/\n    1125,\n/**/\n    1124,\n/**/\n    1123,\n/**/\n    1122,\n/**/\n    1121,\n/**/\n    1120,\n/**/\n    1119,\n/**/\n    1118,\n/**/\n    1117,\n/**/\n    1116,\n/**/\n    1115,\n/**/\n    1114,\n/**/\n    1113,\n/**/\n    1112,\n/**/\n    1111,\n/**/\n    1110,\n/**/\n    1109,\n/**/\n    1108,\n/**/\n    1107,\n/**/\n    1106,\n/**/\n    1105,\n/**/\n    1104,\n/**/\n    1103,\n/**/\n    1102,\n/**/\n    1101,\n/**/\n    1100,\n/**/\n    1099,\n/**/\n    1098,\n/**/\n    1097,\n/**/\n    1096,\n/**/\n    1095,\n/**/\n    1094,\n/**/\n    1093,\n/**/\n    1092,\n/**/\n    1091,\n/**/\n    1090,\n/**/\n    1089,\n/**/\n    1088,\n/**/\n    1087,\n/**/\n    1086,\n/**/\n    1085,\n/**/\n    1084,\n/**/\n    1083,\n/**/\n    1082,\n/**/\n    1081,\n/**/\n    1080,\n/**/\n    1079,\n/**/\n    1078,\n/**/\n    1077,\n/**/\n    1076,\n/**/\n    1075,\n/**/\n    1074,\n/**/\n    1073,\n/**/\n    1072,\n/**/\n    1071,\n/**/\n    1070,\n/**/\n    1069,\n/**/\n    1068,\n/**/\n    1067,\n/**/\n    1066,\n/**/\n    1065,\n/**/\n    1064,\n/**/\n    1063,\n/**/\n    1062,\n/**/\n    1061,\n/**/\n    1060,\n/**/\n    1059,\n/**/\n    1058,\n/**/\n    1057,\n/**/\n    1056,\n/**/\n    1055,\n/**/\n    1054,\n/**/\n    1053,\n/**/\n    1052,\n/**/\n    1051,\n/**/\n    1050,\n/**/\n    1049,\n/**/\n    1048,\n/**/\n    1047,\n/**/\n    1046,\n/**/\n    1045,\n/**/\n    1044,\n/**/\n    1043,\n/**/\n    1042,\n/**/\n    1041,\n/**/\n    1040,\n/**/\n    1039,\n/**/\n    1038,\n/**/\n    1037,\n/**/\n    1036,\n/**/\n    1035,\n/**/\n    1034,\n/**/\n    1033,\n/**/\n    1032,\n/**/\n    1031,\n/**/\n    1030,\n/**/\n    1029,\n/**/\n    1028,\n/**/\n    1027,\n/**/\n    1026,\n/**/\n    1025,\n/**/\n    1024,\n/**/\n    1023,\n/**/\n    1022,\n/**/\n    1021,\n/**/\n    1020,\n/**/\n    1019,\n/**/\n    1018,\n/**/\n    1017,\n/**/\n    1016,\n/**/\n    1015,\n/**/\n    1014,\n/**/\n    1013,\n/**/\n    1012,\n/**/\n    1011,\n/**/\n    1010,\n/**/\n    1009,\n/**/\n    1008,\n/**/\n    1007,\n/**/\n    1006,\n/**/\n    1005,\n/**/\n    1004,\n/**/\n    1003,\n/**/\n    1002,\n/**/\n    1001,\n/**/\n    1000,\n/**/\n    999,\n/**/\n    998,\n/**/\n    997,\n/**/\n    996,\n/**/\n    995,\n/**/\n    994,\n/**/\n    993,\n/**/\n    992,\n/**/\n    991,\n/**/\n    990,\n/**/\n    989,\n/**/\n    988,\n/**/\n    987,\n/**/\n    986,\n/**/\n    985,\n/**/\n    984,\n/**/\n    983,\n/**/\n    982,\n/**/\n    981,\n/**/\n    980,\n/**/\n    979,\n/**/\n    978,\n/**/\n    977,\n/**/\n    976,\n/**/\n    975,\n/**/\n    974,\n/**/\n    973,\n/**/\n    972,\n/**/\n    971,\n/**/\n    970,\n/**/\n    969,\n/**/\n    968,\n/**/\n    967,\n/**/\n    966,\n/**/\n    965,\n/**/\n    964,\n/**/\n    963,\n/**/\n    962,\n/**/\n    961,\n/**/\n    960,\n/**/\n    959,\n/**/\n    958,\n/**/\n    957,\n/**/\n    956,\n/**/\n    955,\n/**/\n    954,\n/**/\n    953,\n/**/\n    952,\n/**/\n    951,\n/**/\n    950,\n/**/\n    949,\n/**/\n    948,\n/**/\n    947,\n/**/\n    946,\n/**/\n    945,\n/**/\n    944,\n/**/\n    943,\n/**/\n    942,\n/**/\n    941,\n/**/\n    940,\n/**/\n    939,\n/**/\n    938,\n/**/\n    937,\n/**/\n    936,\n/**/\n    935,\n/**/\n    934,\n/**/\n    933,\n/**/\n    932,\n/**/\n    931,\n/**/\n    930,\n/**/\n    929,\n/**/\n    928,\n/**/\n    927,\n/**/\n    926,\n/**/\n    925,\n/**/\n    924,\n/**/\n    923,\n/**/\n    922,\n/**/\n    921,\n/**/\n    920,\n/**/\n    919,\n/**/\n    918,\n/**/\n    917,\n/**/\n    916,\n/**/\n    915,\n/**/\n    914,\n/**/\n    913,\n/**/\n    912,\n/**/\n    911,\n/**/\n    910,\n/**/\n    909,\n/**/\n    908,\n/**/\n    907,\n/**/\n    906,\n/**/\n    905,\n/**/\n    904,\n/**/\n    903,\n/**/\n    902,\n/**/\n    901,\n/**/\n    900,\n/**/\n    899,\n/**/\n    898,\n/**/\n    897,\n/**/\n    896,\n/**/\n    895,\n/**/\n    894,\n/**/\n    893,\n/**/\n    892,\n/**/\n    891,\n/**/\n    890,\n/**/\n    889,\n/**/\n    888,\n/**/\n    887,\n/**/\n    886,\n/**/\n    885,\n/**/\n    884,\n/**/\n    883,\n/**/\n    882,\n/**/\n    881,\n/**/\n    880,\n/**/\n    879,\n/**/\n    878,\n/**/\n    877,\n/**/\n    876,\n/**/\n    875,\n/**/\n    874,\n/**/\n    873,\n/**/\n    872,\n/**/\n    871,\n/**/\n    870,\n/**/\n    869,\n/**/\n    868,\n/**/\n    867,\n/**/\n    866,\n/**/\n    865,\n/**/\n    864,\n/**/\n    863,\n/**/\n    862,\n/**/\n    861,\n/**/\n    860,\n/**/\n    859,\n/**/\n    858,\n/**/\n    857,\n/**/\n    856,\n/**/\n    855,\n/**/\n    854,\n/**/\n    853,\n/**/\n    852,\n/**/\n    851,\n/**/\n    850,\n/**/\n    849,\n/**/\n    848,\n/**/\n    847,\n/**/\n    846,\n/**/\n    845,\n/**/\n    844,\n/**/\n    843,\n/**/\n    842,\n/**/\n    841,\n/**/\n    840,\n/**/\n    839,\n/**/\n    838,\n/**/\n    837,\n/**/\n    836,\n/**/\n    835,\n/**/\n    834,\n/**/\n    833,\n/**/\n    832,\n/**/\n    831,\n/**/\n    830,\n/**/\n    829,\n/**/\n    828,\n/**/\n    827,\n/**/\n    826,\n/**/\n    825,\n/**/\n    824,\n/**/\n    823,\n/**/\n    822,\n/**/\n    821,\n/**/\n    820,\n/**/\n    819,\n/**/\n    818,\n/**/\n    817,\n/**/\n    816,\n/**/\n    815,\n/**/\n    814,\n/**/\n    813,\n/**/\n    812,\n/**/\n    811,\n/**/\n    810,\n/**/\n    809,\n/**/\n    808,\n/**/\n    807,\n/**/\n    806,\n/**/\n    805,\n/**/\n    804,\n/**/\n    803,\n/**/\n    802,\n/**/\n    801,\n/**/\n    800,\n/**/\n    799,\n/**/\n    798,\n/**/\n    797,\n/**/\n    796,\n/**/\n    795,\n/**/\n    794,\n/**/\n    793,\n/**/\n    792,\n/**/\n    791,\n/**/\n    790,\n/**/\n    789,\n/**/\n    788,\n/**/\n    787,\n/**/\n    786,\n/**/\n    785,\n/**/\n    784,\n/**/\n    783,\n/**/\n    782,\n/**/\n    781,\n/**/\n    780,\n/**/\n    779,\n/**/\n    778,\n/**/\n    777,\n/**/\n    776,\n/**/\n    775,\n/**/\n    774,\n/**/\n    773,\n/**/\n    772,\n/**/\n    771,\n/**/\n    770,\n/**/\n    769,\n/**/\n    768,\n/**/\n    767,\n/**/\n    766,\n/**/\n    765,\n/**/\n    764,\n/**/\n    763,\n/**/\n    762,\n/**/\n    761,\n/**/\n    760,\n/**/\n    759,\n/**/\n    758,\n/**/\n    757,\n/**/\n    756,\n/**/\n    755,\n/**/\n    754,\n/**/\n    753,\n/**/\n    752,\n/**/\n    751,\n/**/\n    750,\n/**/\n    749,\n/**/\n    748,\n/**/\n    747,\n/**/\n    746,\n/**/\n    745,\n/**/\n    744,\n/**/\n    743,\n/**/\n    742,\n/**/\n    741,\n/**/\n    740,\n/**/\n    739,\n/**/\n    738,\n/**/\n    737,\n/**/\n    736,\n/**/\n    735,\n/**/\n    734,\n/**/\n    733,\n/**/\n    732,\n/**/\n    731,\n/**/\n    730,\n/**/\n    729,\n/**/\n    728,\n/**/\n    727,\n/**/\n    726,\n/**/\n    725,\n/**/\n    724,\n/**/\n    723,\n/**/\n    722,\n/**/\n    721,\n/**/\n    720,\n/**/\n    719,\n/**/\n    718,\n/**/\n    717,\n/**/\n    716,\n/**/\n    715,\n/**/\n    714,\n/**/\n    713,\n/**/\n    712,\n/**/\n    711,\n/**/\n    710,\n/**/\n    709,\n/**/\n    708,\n/**/\n    707,\n/**/\n    706,\n/**/\n    705,\n/**/\n    704,\n/**/\n    703,\n/**/\n    702,\n/**/\n    701,\n/**/\n    700,\n/**/\n    699,\n/**/\n    698,\n/**/\n    697,\n/**/\n    696,\n/**/\n    695,\n/**/\n    694,\n/**/\n    693,\n/**/\n    692,\n/**/\n    691,\n/**/\n    690,\n/**/\n    689,\n/**/\n    688,\n/**/\n    687,\n/**/\n    686,\n/**/\n    685,\n/**/\n    684,\n/**/\n    683,\n/**/\n    682,\n/**/\n    681,\n/**/\n    680,\n/**/\n    679,\n/**/\n    678,\n/**/\n    677,\n/**/\n    676,\n/**/\n    675,\n/**/\n    674,\n/**/\n    673,\n/**/\n    672,\n/**/\n    671,\n/**/\n    670,\n/**/\n    669,\n/**/\n    668,\n/**/\n    667,\n/**/\n    666,\n/**/\n    665,\n/**/\n    664,\n/**/\n    663,\n/**/\n    662,\n/**/\n    661,\n/**/\n    660,\n/**/\n    659,\n/**/\n    658,\n/**/\n    657,\n/**/\n    656,\n/**/\n    655,\n/**/\n    654,\n/**/\n    653,\n/**/\n    652,\n/**/\n    651,\n/**/\n    650,\n/**/\n    649,\n/**/\n    648,\n/**/\n    647,\n/**/\n    646,\n/**/\n    645,\n/**/\n    644,\n/**/\n    643,\n/**/\n    642,\n/**/\n    641,\n/**/\n    640,\n/**/\n    639,\n/**/\n    638,\n/**/\n    637,\n/**/\n    636,\n/**/\n    635,\n/**/\n    634,\n/**/\n    633,\n/**/\n    632,\n/**/\n    631,\n/**/\n    630,\n/**/\n    629,\n/**/\n    628,\n/**/\n    627,\n/**/\n    626,\n/**/\n    625,\n/**/\n    624,\n/**/\n    623,\n/**/\n    622,\n/**/\n    621,\n/**/\n    620,\n/**/\n    619,\n/**/\n    618,\n/**/\n    617,\n/**/\n    616,\n/**/\n    615,\n/**/\n    614,\n/**/\n    613,\n/**/\n    612,\n/**/\n    611,\n/**/\n    610,\n/**/\n    609,\n/**/\n    608,\n/**/\n    607,\n/**/\n    606,\n/**/\n    605,\n/**/\n    604,\n/**/\n    603,\n/**/\n    602,\n/**/\n    601,\n/**/\n    600,\n/**/\n    599,\n/**/\n    598,\n/**/\n    597,\n/**/\n    596,\n/**/\n    595,\n/**/\n    594,\n/**/\n    593,\n/**/\n    592,\n/**/\n    591,\n/**/\n    590,\n/**/\n    589,\n/**/\n    588,\n/**/\n    587,\n/**/\n    586,\n/**/\n    585,\n/**/\n    584,\n/**/\n    583,\n/**/\n    582,\n/**/\n    581,\n/**/\n    580,\n/**/\n    579,\n/**/\n    578,\n/**/\n    577,\n/**/\n    576,\n/**/\n    575,\n/**/\n    574,\n/**/\n    573,\n/**/\n    572,\n/**/\n    571,\n/**/\n    570,\n/**/\n    569,\n/**/\n    568,\n/**/\n    567,\n/**/\n    566,\n/**/\n    565,\n/**/\n    564,\n/**/\n    563,\n/**/\n    562,\n/**/\n    561,\n/**/\n    560,\n/**/\n    559,\n/**/\n    558,\n/**/\n    557,\n/**/\n    556,\n/**/\n    555,\n/**/\n    554,\n/**/\n    553,\n/**/\n    552,\n/**/\n    551,\n/**/\n    550,\n/**/\n    549,\n/**/\n    548,\n/**/\n    547,\n/**/\n    546,\n/**/\n    545,\n/**/\n    544,\n/**/\n    543,\n/**/\n    542,\n/**/\n    541,\n/**/\n    540,\n/**/\n    539,\n/**/\n    538,\n/**/\n    537,\n/**/\n    536,\n/**/\n    535,\n/**/\n    534,\n/**/\n    533,\n/**/\n    532,\n/**/\n    531,\n/**/\n    530,\n/**/\n    529,\n/**/\n    528,\n/**/\n    527,\n/**/\n    526,\n/**/\n    525,\n/**/\n    524,\n/**/\n    523,\n/**/\n    522,\n/**/\n    521,\n/**/\n    520,\n/**/\n    519,\n/**/\n    518,\n/**/\n    517,\n/**/\n    516,\n/**/\n    515,\n/**/\n    514,\n/**/\n    513,\n/**/\n    512,\n/**/\n    511,\n/**/\n    510,\n/**/\n    509,\n/**/\n    508,\n/**/\n    507,\n/**/\n    506,\n/**/\n    505,\n/**/\n    504,\n/**/\n    503,\n/**/\n    502,\n/**/\n    501,\n/**/\n    500,\n/**/\n    499,\n/**/\n    498,\n/**/\n    497,\n/**/\n    496,\n/**/\n    495,\n/**/\n    494,\n/**/\n    493,\n/**/\n    492,\n/**/\n    491,\n/**/\n    490,\n/**/\n    489,\n/**/\n    488,\n/**/\n    487,\n/**/\n    486,\n/**/\n    485,\n/**/\n    484,\n/**/\n    483,\n/**/\n    482,\n/**/\n    481,\n/**/\n    480,\n/**/\n    479,\n/**/\n    478,\n/**/\n    477,\n/**/\n    476,\n/**/\n    475,\n/**/\n    474,\n/**/\n    473,\n/**/\n    472,\n/**/\n    471,\n/**/\n    470,\n/**/\n    469,\n/**/\n    468,\n/**/\n    467,\n/**/\n    466,\n/**/\n    465,\n/**/\n    464,\n/**/\n    463,\n/**/\n    462,\n/**/\n    461,\n/**/\n    460,\n/**/\n    459,\n/**/\n    458,\n/**/\n    457,\n/**/\n    456,\n/**/\n    455,\n/**/\n    454,\n/**/\n    453,\n/**/\n    452,\n/**/\n    451,\n/**/\n    450,\n/**/\n    449,\n/**/\n    448,\n/**/\n    447,\n/**/\n    446,\n/**/\n    445,\n/**/\n    444,\n/**/\n    443,\n/**/\n    442,\n/**/\n    441,\n/**/\n    440,\n/**/\n    439,\n/**/\n    438,\n/**/\n    437,\n/**/\n    436,\n/**/\n    435,\n/**/\n    434,\n/**/\n    433,\n/**/\n    432,\n/**/\n    431,\n/**/\n    430,\n/**/\n    429,\n/**/\n    428,\n/**/\n    427,\n/**/\n    426,\n/**/\n    425,\n/**/\n    424,\n/**/\n    423,\n/**/\n    422,\n/**/\n    421,\n/**/\n    420,\n/**/\n    419,\n/**/\n    418,\n/**/\n    417,\n/**/\n    416,\n/**/\n    415,\n/**/\n    414,\n/**/\n    413,\n/**/\n    412,\n/**/\n    411,\n/**/\n    410,\n/**/\n    409,\n/**/\n    408,\n/**/\n    407,\n/**/\n    406,\n/**/\n    405,\n/**/\n    404,\n/**/\n    403,\n/**/\n    402,\n/**/\n    401,\n/**/\n    400,\n/**/\n    399,\n/**/\n    398,\n/**/\n    397,\n/**/\n    396,\n/**/\n    395,\n/**/\n    394,\n/**/\n    393,\n/**/\n    392,\n/**/\n    391,\n/**/\n    390,\n/**/\n    389,\n/**/\n    388,\n/**/\n    387,\n/**/\n    386,\n/**/\n    385,\n/**/\n    384,\n/**/\n    383,\n/**/\n    382,\n/**/\n    381,\n/**/\n    380,\n/**/\n    379,\n/**/\n    378,\n/**/\n    377,\n/**/\n    376,\n/**/\n    375,\n/**/\n    374,\n/**/\n    373,\n/**/\n    372,\n/**/\n    371,\n/**/\n    370,\n/**/\n    369,\n/**/\n    368,\n/**/\n    367,\n/**/\n    366,\n/**/\n    365,\n/**/\n    364,\n/**/\n    363,\n/**/\n    362,\n/**/\n    361,\n/**/\n    360,\n/**/\n    359,\n/**/\n    358,\n/**/\n    357,\n/**/\n    356,\n/**/\n    355,\n/**/\n    354,\n/**/\n    353,\n/**/\n    352,\n/**/\n    351,\n/**/\n    350,\n/**/\n    349,\n/**/\n    348,\n/**/\n    347,\n/**/\n    346,\n/**/\n    345,\n/**/\n    344,\n/**/\n    343,\n/**/\n    342,\n/**/\n    341,\n/**/\n    340,\n/**/\n    339,\n/**/\n    338,\n/**/\n    337,\n/**/\n    336,\n/**/\n    335,\n/**/\n    334,\n/**/\n    333,\n/**/\n    332,\n/**/\n    331,\n/**/\n    330,\n/**/\n    329,\n/**/\n    328,\n/**/\n    327,\n/**/\n    326,\n/**/\n    325,\n/**/\n    324,\n/**/\n    323,\n/**/\n    322,\n/**/\n    321,\n/**/\n    320,\n/**/\n    319,\n/**/\n    318,\n/**/\n    317,\n/**/\n    316,\n/**/\n    315,\n/**/\n    314,\n/**/\n    313,\n/**/\n    312,\n/**/\n    311,\n/**/\n    310,\n/**/\n    309,\n/**/\n    308,\n/**/\n    307,\n/**/\n    306,\n/**/\n    305,\n/**/\n    304,\n/**/\n    303,\n/**/\n    302,\n/**/\n    301,\n/**/\n    300,\n/**/\n    299,\n/**/\n    298,\n/**/\n    297,\n/**/\n    296,\n/**/\n    295,\n/**/\n    294,\n/**/\n    293,\n/**/\n    292,\n/**/\n    291,\n/**/\n    290,\n/**/\n    289,\n/**/\n    288,\n/**/\n    287,\n/**/\n    286,\n/**/\n    285,\n/**/\n    284,\n/**/\n    283,\n/**/\n    282,\n/**/\n    281,\n/**/\n    280,\n/**/\n    279,\n/**/\n    278,\n/**/\n    277,\n/**/\n    276,\n/**/\n    275,\n/**/\n    274,\n/**/\n    273,\n/**/\n    272,\n/**/\n    271,\n/**/\n    270,\n/**/\n    269,\n/**/\n    268,\n/**/\n    267,\n/**/\n    266,\n/**/\n    265,\n/**/\n    264,\n/**/\n    263,\n/**/\n    262,\n/**/\n    261,\n/**/\n    260,\n/**/\n    259,\n/**/\n    258,\n/**/\n    257,\n/**/\n    256,\n/**/\n    255,\n/**/\n    254,\n/**/\n    253,\n/**/\n    252,\n/**/\n    251,\n/**/\n    250,\n/**/\n    249,\n/**/\n    248,\n/**/\n    247,\n/**/\n    246,\n/**/\n    245,\n/**/\n    244,\n/**/\n    243,\n/**/\n    242,\n/**/\n    241,\n/**/\n    240,\n/**/\n    239,\n/**/\n    238,\n/**/\n    237,\n/**/\n    236,\n/**/\n    235,\n/**/\n    234,\n/**/\n    233,\n/**/\n    232,\n/**/\n    231,\n/**/\n    230,\n/**/\n    229,\n/**/\n    228,\n/**/\n    227,\n/**/\n    226,\n/**/\n    225,\n/**/\n    224,\n/**/\n    223,\n/**/\n    222,\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    while (l < h)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + (item_count % ncol ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#ifdef FEAT_HUGE\n    msg_puts(_(\"\\nHuge version \"));\n#else\n# ifdef FEAT_BIG\n    msg_puts(_(\"\\nBig version \"));\n# else\n#  ifdef FEAT_NORMAL\n    msg_puts(_(\"\\nNormal version \"));\n#  else\n#   ifdef FEAT_SMALL\n    msg_puts(_(\"\\nSmall version \"));\n#   else\n    msg_puts(_(\"\\nTiny version \"));\n#   endif\n#  endif\n# endif\n#endif\n#ifndef FEAT_GUI\n    msg_puts(_(\"without GUI.\"));\n#else\n# ifdef FEAT_GUI_GTK\n#  ifdef USE_GTK3\n    msg_puts(_(\"with GTK3 GUI.\"));\n#  else\n#   ifdef FEAT_GUI_GNOME\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n#   else\n     msg_puts(_(\"with GTK2 GUI.\"));\n#   endif\n# endif\n# else\n#  ifdef FEAT_GUI_MOTIF\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#  else\n#   ifdef FEAT_GUI_ATHENA\n#    ifdef FEAT_GUI_NEXTAW\n    msg_puts(_(\"with X11-neXtaw GUI.\"));\n#    else\n    msg_puts(_(\"with X11-Athena GUI.\"));\n#    endif\n#   else\n#    ifdef FEAT_GUI_HAIKU\n    msg_puts(_(\"with Haiku GUI.\"));\n#    else\n#     ifdef FEAT_GUI_PHOTON\n    msg_puts(_(\"with Photon GUI.\"));\n#     else\n#      if defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#      endif\n#     endif\n#    endif\n#   endif\n#  endif\n# endif\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version8<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * vim9cmds.c: Dealing with compiled function expressions\n */\n\n#define USING_FLOAT_STUFF\n#include \"vim.h\"\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n\n// When not generating protos this is included in proto.h\n#ifdef PROTO\n# include \"vim9.h\"\n#endif\n\n/*\n * Generate code for any ppconst entries.\n */\n    int\ngenerate_ppconst(cctx_T *cctx, ppconst_T *ppconst)\n{\n    int\t    i;\n    int\t    ret = OK;\n    int\t    save_skip = cctx->ctx_skip;\n\n    cctx->ctx_skip = SKIP_NOT;\n    for (i = 0; i < ppconst->pp_used; ++i)\n\tif (generate_tv_PUSH(cctx, &ppconst->pp_tv[i]) == FAIL)\n\t    ret = FAIL;\n    ppconst->pp_used = 0;\n    cctx->ctx_skip = save_skip;\n    return ret;\n}\n\n/*\n * Check that the last item of \"ppconst\" is a bool, if there is an item.\n */\n    static int\ncheck_ppconst_bool(ppconst_T *ppconst)\n{\n    if (ppconst->pp_used > 0)\n    {\n\ttypval_T    *tv = &ppconst->pp_tv[ppconst->pp_used - 1];\n\twhere_T\t    where = WHERE_INIT;\n\n\treturn check_typval_type(&t_bool, tv, where);\n    }\n    return OK;\n}\n\n/*\n * Clear ppconst constants.  Used when failing.\n */\n    void\nclear_ppconst(ppconst_T *ppconst)\n{\n    int\t    i;\n\n    for (i = 0; i < ppconst->pp_used; ++i)\n\tclear_tv(&ppconst->pp_tv[i]);\n    ppconst->pp_used = 0;\n}\n\n/*\n * Compile getting a member from a list/dict/string/blob.  Stack has the\n * indexable value and the index or the two indexes of a slice.\n * \"keeping_dict\" is used for dict[func](arg) to pass dict to func.\n */\n    int\ncompile_member(int is_slice, int *keeping_dict, cctx_T *cctx)\n{\n    type2_T\t*typep;\n    garray_T\t*stack = &cctx->ctx_type_stack;\n    vartype_T\tvartype;\n    type_T\t*idxtype;\n\n    // We can index a list, dict and blob.  If we don't know the type\n    // we can use the index value type.  If we still don't know use an \"ANY\"\n    // instruction.\n    // TODO: what about the decl type?\n    typep = (((type2_T *)stack->ga_data) + stack->ga_len - (is_slice ? 3 : 2));\n    vartype = typep->type_curr->tt_type;\n    idxtype = (((type2_T *)stack->ga_data) + stack->ga_len - 1)->type_curr;\n    // If the index is a string, the variable must be a Dict.\n    if ((typep->type_curr == &t_any || typep->type_curr == &t_unknown)\n\t\t\t\t\t\t       && idxtype == &t_string)\n\tvartype = VAR_DICT;\n    if (vartype == VAR_STRING || vartype == VAR_LIST || vartype == VAR_BLOB)\n    {\n\tif (need_type(idxtype, &t_number, -1, 0, cctx, FALSE, FALSE) == FAIL)\n\t    return FAIL;\n\tif (is_slice)\n\t{\n\t    idxtype = get_type_on_stack(cctx, 1);\n\t    if (need_type(idxtype, &t_number, -2, 0, cctx,\n\t\t\t\t\t\t\t FALSE, FALSE) == FAIL)\n\t\treturn FAIL;\n\t}\n    }\n\n    if (vartype == VAR_DICT)\n    {\n\tif (is_slice)\n\t{\n\t    emsg(_(e_cannot_slice_dictionary));\n\t    return FAIL;\n\t}\n\tif (typep->type_curr->tt_type == VAR_DICT)\n\t{\n\t    typep->type_curr = typep->type_curr->tt_member;\n\t    if (typep->type_curr == &t_unknown)\n\t\t// empty dict was used\n\t\ttypep->type_curr = &t_any;\n\t    if (typep->type_decl->tt_type == VAR_DICT)\n\t    {\n\t\ttypep->type_decl = typep->type_decl->tt_member;\n\t\tif (typep->type_decl == &t_unknown)\n\t\t    // empty dict was used\n\t\t    typep->type_decl = &t_any;\n\t    }\n\t    else\n\t\ttypep->type_decl = typep->type_curr;\n\t}\n\telse\n\t{\n\t    if (need_type(typep->type_curr, &t_dict_any, -2, 0, cctx,\n\t\t\t\t\t\t\t FALSE, FALSE) == FAIL)\n\t\treturn FAIL;\n\t    typep->type_curr = &t_any;\n\t    typep->type_decl = &t_any;\n\t}\n\tif (may_generate_2STRING(-1, FALSE, cctx) == FAIL)\n\t    return FAIL;\n\tif (generate_instr_drop(cctx, ISN_MEMBER, 1) == FAIL)\n\t    return FAIL;\n\tif (keeping_dict != NULL)\n\t    *keeping_dict = TRUE;\n    }\n    else if (vartype == VAR_STRING)\n    {\n\ttypep->type_curr = &t_string;\n\ttypep->type_decl = &t_string;\n\tif ((is_slice\n\t\t? generate_instr_drop(cctx, ISN_STRSLICE, 2)\n\t\t: generate_instr_drop(cctx, ISN_STRINDEX, 1)) == FAIL)\n\t    return FAIL;\n    }\n    else if (vartype == VAR_BLOB)\n    {\n\tif (is_slice)\n\t{\n\t    typep->type_curr = &t_blob;\n\t    typep->type_decl = &t_blob;\n\t    if (generate_instr_drop(cctx, ISN_BLOBSLICE, 2) == FAIL)\n\t\treturn FAIL;\n\t}\n\telse\n\t{\n\t    typep->type_curr = &t_number;\n\t    typep->type_decl = &t_number;\n\t    if (generate_instr_drop(cctx, ISN_BLOBINDEX, 1) == FAIL)\n\t\treturn FAIL;\n\t}\n    }\n    else if (vartype == VAR_LIST || typep->type_curr == &t_any\n\t\t\t\t\t     || typep->type_curr == &t_unknown)\n    {\n\tif (is_slice)\n\t{\n\t    if (generate_instr_drop(cctx,\n\t\t     vartype == VAR_LIST ?  ISN_LISTSLICE : ISN_ANYSLICE,\n\t\t\t\t\t\t\t    2) == FAIL)\n\t\treturn FAIL;\n\t}\n\telse\n\t{\n\t    if (typep->type_curr->tt_type == VAR_LIST)\n\t    {\n\t\ttypep->type_curr = typep->type_curr->tt_member;\n\t\tif (typep->type_curr == &t_unknown)\n\t\t    // empty list was used\n\t\t    typep->type_curr = &t_any;\n\t\tif (typep->type_decl->tt_type == VAR_LIST)\n\t\t{\n\t\t    typep->type_decl = typep->type_decl->tt_member;\n\t\t    if (typep->type_decl == &t_unknown)\n\t\t\t// empty list was used\n\t\t\ttypep->type_decl = &t_any;\n\t\t}\n\t\telse\n\t\t\ttypep->type_decl = typep->type_curr;\n\t    }\n\t    if (generate_instr_drop(cctx,\n\t\t\tvartype == VAR_LIST ?  ISN_LISTINDEX : ISN_ANYINDEX, 1)\n\t\t\t\t\t\t\t\t       == FAIL)\n\t\treturn FAIL;\n\t}\n    }\n    else\n    {\n\tswitch (vartype)\n\t{\n\t    case VAR_FUNC:\n\t    case VAR_PARTIAL:\n\t\temsg(_(e_cannot_index_a_funcref));\n\t\tbreak;\n\t    case VAR_BOOL:\n\t    case VAR_SPECIAL:\n\t    case VAR_JOB:\n\t    case VAR_CHANNEL:\n\t    case VAR_INSTR:\n\t    case VAR_UNKNOWN:\n\t    case VAR_ANY:\n\t    case VAR_VOID:\n\t\temsg(_(e_cannot_index_special_variable));\n\t\tbreak;\n\t    default:\n\t\temsg(_(e_string_list_dict_or_blob_required));\n\t}\n\treturn FAIL;\n    }\n    return OK;\n}\n\n/*\n * Generate an instruction to load script-local variable \"name\", without the\n * leading \"s:\".\n * Also finds imported variables.\n */\n    int\ncompile_load_scriptvar(\n\tcctx_T *cctx,\n\tchar_u *name,\t    // variable NUL terminated\n\tchar_u *start,\t    // start of variable\n\tchar_u **end,\t    // end of variable, may be NULL\n\tint    error)\t    // when TRUE may give error\n{\n    scriptitem_T    *si;\n    int\t\t    idx;\n    imported_T\t    *import;\n\n    if (!SCRIPT_ID_VALID(current_sctx.sc_sid))\n\treturn FAIL;\n    si = SCRIPT_ITEM(current_sctx.sc_sid);\n    idx = get_script_item_idx(current_sctx.sc_sid, name, 0, cctx);\n    if (idx == -1 || si->sn_version != SCRIPT_VERSION_VIM9)\n    {\n\t// variable is not in sn_var_vals: old style script.\n\treturn generate_OLDSCRIPT(cctx, ISN_LOADS, name, current_sctx.sc_sid,\n\t\t\t\t\t\t\t\t       &t_any);\n    }\n    if (idx >= 0)\n    {\n\tsvar_T\t\t*sv = ((svar_T *)si->sn_var_vals.ga_data) + idx;\n\n\tgenerate_VIM9SCRIPT(cctx, ISN_LOADSCRIPT,\n\t\t\t\t\tcurrent_sctx.sc_sid, idx, sv->sv_type);\n\treturn OK;\n    }\n\n    import = end == NULL ? NULL : find_imported(name, 0, cctx);\n    if (import != NULL)\n    {\n\tchar_u\t*p = skipwhite(*end);\n\tchar_u\t*exp_name;\n\tint\tcc;\n\tufunc_T\t*ufunc;\n\ttype_T\t*type;\n\n\t// Need to lookup the member.\n\tif (*p != '.')\n\t{\n\t    semsg(_(e_expected_dot_after_name_str), start);\n\t    return FAIL;\n\t}\n\t++p;\n\tif (VIM_ISWHITE(*p))\n\t{\n\t    emsg(_(e_no_white_space_allowed_after_dot));\n\t    return FAIL;\n\t}\n\n\t// isolate one name\n\texp_name = p;\n\twhile (eval_isnamec(*p))\n\t    ++p;\n\tcc = *p;\n\t*p = NUL;\n\n\tidx = find_exported(import->imp_sid, exp_name, &ufunc, &type,\n\t\t\t\t\t\t\t\t   cctx, TRUE);\n\t*p = cc;\n\tp = skipwhite(p);\n\t*end = p;\n\n\tif (idx < 0)\n\t{\n\t    if (ufunc != NULL)\n\t    {\n\t\t// function call or function reference\n\t\tgenerate_PUSHFUNC(cctx, ufunc->uf_name, NULL);\n\t\treturn OK;\n\t    }\n\t    return FAIL;\n\t}\n\n\tgenerate_VIM9SCRIPT(cctx, ISN_LOADSCRIPT,\n\t\timport->imp_sid,\n\t\tidx,\n\t\ttype);\n\treturn OK;\n    }\n\n    if (error)\n\tsemsg(_(e_item_not_found_str), name);\n    return FAIL;\n}\n\n    static int\ngenerate_funcref(cctx_T *cctx, char_u *name)\n{\n    ufunc_T *ufunc = find_func(name, FALSE, cctx);\n\n    if (ufunc == NULL)\n\treturn FAIL;\n\n    // Need to compile any default values to get the argument types.\n    if (func_needs_compiling(ufunc, COMPILE_TYPE(ufunc))\n\t    && compile_def_function(ufunc, TRUE, COMPILE_TYPE(ufunc), NULL)\n\t\t\t\t\t\t\t\t       == FAIL)\n\treturn FAIL;\n    return generate_PUSHFUNC(cctx, ufunc->uf_name, ufunc->uf_func_type);\n}\n\n/*\n * Compile a variable name into a load instruction.\n * \"end\" points to just after the name.\n * \"is_expr\" is TRUE when evaluating an expression, might be a funcref.\n * When \"error\" is FALSE do not give an error when not found.\n */\n    int\ncompile_load(\n\tchar_u **arg,\n\tchar_u *end_arg,\n\tcctx_T\t*cctx,\n\tint\tis_expr,\n\tint\terror)\n{\n    type_T\t*type;\n    char_u\t*name = NULL;\n    char_u\t*end = end_arg;\n    int\t\tres = FAIL;\n    int\t\tprev_called_emsg = called_emsg;\n\n    if (*(*arg + 1) == ':')\n    {\n\tif (end <= *arg + 2)\n\t{\n\t    isntype_T  isn_type;\n\n\t    // load dictionary of namespace\n\t    switch (**arg)\n\t    {\n\t\tcase 'g': isn_type = ISN_LOADGDICT; break;\n\t\tcase 'w': isn_type = ISN_LOADWDICT; break;\n\t\tcase 't': isn_type = ISN_LOADTDICT; break;\n\t\tcase 'b': isn_type = ISN_LOADBDICT; break;\n\t\tdefault:\n\t\t    semsg(_(e_namespace_not_supported_str), *arg);\n\t\t    goto theend;\n\t    }\n\t    if (generate_instr_type(cctx, isn_type, &t_dict_any) == NULL)\n\t\tgoto theend;\n\t    res = OK;\n\t}\n\telse\n\t{\n\t    isntype_T  isn_type = ISN_DROP;\n\n\t    // load namespaced variable\n\t    name = vim_strnsave(*arg + 2, end - (*arg + 2));\n\t    if (name == NULL)\n\t\treturn FAIL;\n\n\t    switch (**arg)\n\t    {\n\t\tcase 'v': res = generate_LOADV(cctx, name, error);\n\t\t\t  break;\n\t\tcase 's': if (is_expr && ASCII_ISUPPER(*name)\n\t\t\t\t       && find_func(name, FALSE, cctx) != NULL)\n\t\t\t      res = generate_funcref(cctx, name);\n\t\t\t  else\n\t\t\t      res = compile_load_scriptvar(cctx, name,\n\t\t\t\t\t\t\t    NULL, &end, error);\n\t\t\t  break;\n\t\tcase 'g': if (vim_strchr(name, AUTOLOAD_CHAR) == NULL)\n\t\t\t  {\n\t\t\t      if (is_expr && ASCII_ISUPPER(*name)\n\t\t\t\t       && find_func(name, FALSE, cctx) != NULL)\n\t\t\t\t  res = generate_funcref(cctx, name);\n\t\t\t      else\n\t\t\t\t  isn_type = ISN_LOADG;\n\t\t\t  }\n\t\t\t  else\n\t\t\t  {\n\t\t\t      isn_type = ISN_LOADAUTO;\n\t\t\t      vim_free(name);\n\t\t\t      name = vim_strnsave(*arg, end - *arg);\n\t\t\t      if (name == NULL)\n\t\t\t\t  return FAIL;\n\t\t\t  }\n\t\t\t  break;\n\t\tcase 'w': isn_type = ISN_LOADW; break;\n\t\tcase 't': isn_type = ISN_LOADT; break;\n\t\tcase 'b': isn_type = ISN_LOADB; break;\n\t\tdefault:  // cannot happen, just in case\n\t\t\t  semsg(_(e_namespace_not_supported_str), *arg);\n\t\t\t  goto theend;\n\t    }\n\t    if (isn_type != ISN_DROP)\n\t    {\n\t\t// Global, Buffer-local, Window-local and Tabpage-local\n\t\t// variables can be defined later, thus we don't check if it\n\t\t// exists, give an error at runtime.\n\t\tres = generate_LOAD(cctx, isn_type, 0, name, &t_any);\n\t    }\n\t}\n    }\n    else\n    {\n\tsize_t\t    len = end - *arg;\n\tint\t    idx;\n\tint\t    gen_load = FALSE;\n\tint\t    gen_load_outer = 0;\n\n\tname = vim_strnsave(*arg, end - *arg);\n\tif (name == NULL)\n\t    return FAIL;\n\n\tif (vim_strchr(name, AUTOLOAD_CHAR) != NULL)\n\t{\n\t    script_autoload(name, FALSE);\n\t    res = generate_LOAD(cctx, ISN_LOADAUTO, 0, name, &t_any);\n\t}\n\telse if (arg_exists(*arg, len, &idx, &type, &gen_load_outer, cctx)\n\t\t\t\t\t\t\t\t\t == OK)\n\t{\n\t    if (gen_load_outer == 0)\n\t\tgen_load = TRUE;\n\t}\n\telse\n\t{\n\t    lvar_T lvar;\n\n\t    if (lookup_local(*arg, len, &lvar, cctx) == OK)\n\t    {\n\t\ttype = lvar.lv_type;\n\t\tidx = lvar.lv_idx;\n\t\tif (lvar.lv_from_outer != 0)\n\t\t    gen_load_outer = lvar.lv_from_outer;\n\t\telse\n\t\t    gen_load = TRUE;\n\t    }\n\t    else\n\t    {\n\t\t// \"var\" can be script-local even without using \"s:\" if it\n\t\t// already exists in a Vim9 script or when it's imported.\n\t\tif (script_var_exists(*arg, len, cctx) == OK\n\t\t\t|| find_imported(name, 0, cctx) != NULL)\n\t\t   res = compile_load_scriptvar(cctx, name, *arg, &end, FALSE);\n\n\t\t// When evaluating an expression and the name starts with an\n\t\t// uppercase letter it can be a user defined function.\n\t\t// generate_funcref() will fail if the function can't be found.\n\t\tif (res == FAIL && is_expr && ASCII_ISUPPER(*name))\n\t\t    res = generate_funcref(cctx, name);\n\t    }\n\t}\n\tif (gen_load)\n\t    res = generate_LOAD(cctx, ISN_LOAD, idx, NULL, type);\n\tif (gen_load_outer > 0)\n\t{\n\t    res = generate_LOADOUTER(cctx, idx, gen_load_outer, type);\n\t    cctx->ctx_outer_used = TRUE;\n\t}\n    }\n\n    *arg = end;\n\ntheend:\n    if (res == FAIL && error && called_emsg == prev_called_emsg)\n\tsemsg(_(e_variable_not_found_str), name);\n    vim_free(name);\n    return res;\n}\n\n/*\n * Compile a string in a ISN_PUSHS instruction into an ISN_INSTR.\n * Returns FAIL if compilation fails.\n */\n    static int\ncompile_string(isn_T *isn, cctx_T *cctx)\n{\n    char_u\t*s = isn->isn_arg.string;\n    garray_T\tsave_ga = cctx->ctx_instr;\n    int\t\texpr_res;\n    int\t\ttrailing_error;\n    int\t\tinstr_count;\n    isn_T\t*instr = NULL;\n\n    // Remove the string type from the stack.\n    --cctx->ctx_type_stack.ga_len;\n\n    // Temporarily reset the list of instructions so that the jump labels are\n    // correct.\n    cctx->ctx_instr.ga_len = 0;\n    cctx->ctx_instr.ga_maxlen = 0;\n    cctx->ctx_instr.ga_data = NULL;\n    expr_res = compile_expr0(&s, cctx);\n    s = skipwhite(s);\n    trailing_error = *s != NUL;\n\n    if (expr_res == FAIL || trailing_error\n\t\t\t\t       || GA_GROW_FAILS(&cctx->ctx_instr, 1))\n    {\n\tif (trailing_error)\n\t    semsg(_(e_trailing_characters_str), s);\n\tclear_instr_ga(&cctx->ctx_instr);\n\tcctx->ctx_instr = save_ga;\n\t++cctx->ctx_type_stack.ga_len;\n\treturn FAIL;\n    }\n\n    // Move the generated instructions into the ISN_INSTR instruction, then\n    // restore the list of instructions.\n    instr_count = cctx->ctx_instr.ga_len;\n    instr = cctx->ctx_instr.ga_data;\n    instr[instr_count].isn_type = ISN_FINISH;\n\n    cctx->ctx_instr = save_ga;\n    vim_free(isn->isn_arg.string);\n    isn->isn_type = ISN_INSTR;\n    isn->isn_arg.instr = instr;\n    return OK;\n}\n\n/*\n * Compile the argument expressions.\n * \"arg\" points to just after the \"(\" and is advanced to after the \")\"\n */\n    static int\ncompile_arguments(char_u **arg, cctx_T *cctx, int *argcount, int is_searchpair)\n{\n    char_u  *p = *arg;\n    char_u  *whitep = *arg;\n    int\t    must_end = FALSE;\n    int\t    instr_count;\n\n    for (;;)\n    {\n\tif (may_get_next_line(whitep, &p, cctx) == FAIL)\n\t    goto failret;\n\tif (*p == ')')\n\t{\n\t    *arg = p + 1;\n\t    return OK;\n\t}\n\tif (must_end)\n\t{\n\t    semsg(_(e_missing_comma_before_argument_str), p);\n\t    return FAIL;\n\t}\n\n\tinstr_count = cctx->ctx_instr.ga_len;\n\tif (compile_expr0(&p, cctx) == FAIL)\n\t    return FAIL;\n\t++*argcount;\n\n\tif (is_searchpair && *argcount == 5\n\t\t&& cctx->ctx_instr.ga_len == instr_count + 1)\n\t{\n\t    isn_T *isn = ((isn_T *)cctx->ctx_instr.ga_data) + instr_count;\n\n\t    // {skip} argument of searchpair() can be compiled if not empty\n\t    if (isn->isn_type == ISN_PUSHS && *isn->isn_arg.string != NUL)\n\t\tcompile_string(isn, cctx);\n\t}\n\n\tif (*p != ',' && *skipwhite(p) == ',')\n\t{\n\t    semsg(_(e_no_white_space_allowed_before_str_str), \",\", p);\n\t    p = skipwhite(p);\n\t}\n\tif (*p == ',')\n\t{\n\t    ++p;\n\t    if (*p != NUL && !VIM_ISWHITE(*p))\n\t\tsemsg(_(e_white_space_required_after_str_str), \",\", p - 1);\n\t}\n\telse\n\t    must_end = TRUE;\n\twhitep = p;\n\tp = skipwhite(p);\n    }\nfailret:\n    emsg(_(e_missing_closing_paren));\n    return FAIL;\n}\n\n/*\n * Compile a function call:  name(arg1, arg2)\n * \"arg\" points to \"name\", \"arg + varlen\" to the \"(\".\n * \"argcount_init\" is 1 for \"value->method()\"\n * Instructions:\n *\tEVAL arg1\n *\tEVAL arg2\n *\tBCALL / DCALL / UCALL\n */\n    static int\ncompile_call(\n\tchar_u\t    **arg,\n\tsize_t\t    varlen,\n\tcctx_T\t    *cctx,\n\tppconst_T   *ppconst,\n\tint\t    argcount_init)\n{\n    char_u\t*name = *arg;\n    char_u\t*p;\n    int\t\targcount = argcount_init;\n    char_u\tnamebuf[100];\n    char_u\tfname_buf[FLEN_FIXED + 1];\n    char_u\t*tofree = NULL;\n    int\t\terror = FCERR_NONE;\n    ufunc_T\t*ufunc = NULL;\n    int\t\tres = FAIL;\n    int\t\tis_autoload;\n    int\t\tis_searchpair;\n\n    // We can evaluate \"has('name')\" at compile time.\n    // We always evaluate \"exists_compiled()\" at compile time.\n    if ((varlen == 3 && STRNCMP(*arg, \"has\", 3) == 0)\n\t    || (varlen == 15 && STRNCMP(*arg, \"exists_compiled\", 6) == 0))\n    {\n\tchar_u\t    *s = skipwhite(*arg + varlen + 1);\n\ttypval_T    argvars[2];\n\tint\t    is_has = **arg == 'h';\n\n\targvars[0].v_type = VAR_UNKNOWN;\n\tif (*s == '\"')\n\t    (void)eval_string(&s, &argvars[0], TRUE);\n\telse if (*s == '\\'')\n\t    (void)eval_lit_string(&s, &argvars[0], TRUE);\n\ts = skipwhite(s);\n\tif (*s == ')' && argvars[0].v_type == VAR_STRING\n\t       && ((is_has && !dynamic_feature(argvars[0].vval.v_string))\n\t\t    || !is_has))\n\t{\n\t    typval_T\t*tv = &ppconst->pp_tv[ppconst->pp_used];\n\n\t    *arg = s + 1;\n\t    argvars[1].v_type = VAR_UNKNOWN;\n\t    tv->v_type = VAR_NUMBER;\n\t    tv->vval.v_number = 0;\n\t    if (is_has)\n\t\tf_has(argvars, tv);\n\t    else\n\t\tf_exists(argvars, tv);\n\t    clear_tv(&argvars[0]);\n\t    ++ppconst->pp_used;\n\t    return OK;\n\t}\n\tclear_tv(&argvars[0]);\n\tif (!is_has)\n\t{\n\t    emsg(_(e_argument_of_exists_compiled_must_be_literal_string));\n\t    return FAIL;\n\t}\n    }\n\n    if (generate_ppconst(cctx, ppconst) == FAIL)\n\treturn FAIL;\n\n    if (varlen >= sizeof(namebuf))\n    {\n\tsemsg(_(e_name_too_long_str), name);\n\treturn FAIL;\n    }\n    vim_strncpy(namebuf, *arg, varlen);\n    name = fname_trans_sid(namebuf, fname_buf, &tofree, &error);\n\n    // We handle the \"skip\" argument of searchpair() and searchpairpos()\n    // differently.\n    is_searchpair = (varlen == 6 && STRNCMP(*arg, \"search\", 6) == 0)\n\t         || (varlen == 9 && STRNCMP(*arg, \"searchpos\", 9) == 0)\n\t        || (varlen == 10 && STRNCMP(*arg, \"searchpair\", 10) == 0)\n\t        || (varlen == 13 && STRNCMP(*arg, \"searchpairpos\", 13) == 0);\n\n    *arg = skipwhite(*arg + varlen + 1);\n    if (compile_arguments(arg, cctx, &argcount, is_searchpair) == FAIL)\n\tgoto theend;\n\n    is_autoload = vim_strchr(name, AUTOLOAD_CHAR) != NULL;\n    if (ASCII_ISLOWER(*name) && name[1] != ':' && !is_autoload)\n    {\n\tint\t    idx;\n\n\t// builtin function\n\tidx = find_internal_func(name);\n\tif (idx >= 0)\n\t{\n\t    if (STRCMP(name, \"flatten\") == 0)\n\t    {\n\t\temsg(_(e_cannot_use_flatten_in_vim9_script));\n\t\tgoto theend;\n\t    }\n\n\t    if (STRCMP(name, \"add\") == 0 && argcount == 2)\n\t    {\n\t\ttype_T\t    *type = get_type_on_stack(cctx, 1);\n\n\t\t// add() can be compiled to instructions if we know the type\n\t\tif (type->tt_type == VAR_LIST)\n\t\t{\n\t\t    // inline \"add(list, item)\" so that the type can be checked\n\t\t    res = generate_LISTAPPEND(cctx);\n\t\t    idx = -1;\n\t\t}\n\t\telse if (type->tt_type == VAR_BLOB)\n\t\t{\n\t\t    // inline \"add(blob, nr)\" so that the type can be checked\n\t\t    res = generate_BLOBAPPEND(cctx);\n\t\t    idx = -1;\n\t\t}\n\t    }\n\n\t    if (idx >= 0)\n\t\tres = generate_BCALL(cctx, idx, argcount, argcount_init == 1);\n\t}\n\telse\n\t    semsg(_(e_unknown_function_str), namebuf);\n\tgoto theend;\n    }\n\n    // An argument or local variable can be a function reference, this\n    // overrules a function name.\n    if (lookup_local(namebuf, varlen, NULL, cctx) == FAIL\n\t    && arg_exists(namebuf, varlen, NULL, NULL, NULL, cctx) != OK)\n    {\n\t// If we can find the function by name generate the right call.\n\t// Skip global functions here, a local funcref takes precedence.\n\tufunc = find_func(name, FALSE, cctx);\n\tif (ufunc != NULL && !func_is_global(ufunc))\n\t{\n\t    res = generate_CALL(cctx, ufunc, argcount);\n\t    goto theend;\n\t}\n    }\n\n    // If the name is a variable, load it and use PCALL.\n    // Not for g:Func(), we don't know if it is a variable or not.\n    // Not for eome#Func(), it will be loaded later.\n    p = namebuf;\n    if (STRNCMP(namebuf, \"g:\", 2) != 0 && !is_autoload\n\t    && compile_load(&p, namebuf + varlen, cctx, FALSE, FALSE) == OK)\n    {\n\ttype_T\t    *type = get_type_on_stack(cctx, 0);\n\n\tres = generate_PCALL(cctx, argcount, namebuf, type, FALSE);\n\tgoto theend;\n    }\n\n    // If we can find a global function by name generate the right call.\n    if (ufunc != NULL)\n    {\n\tres = generate_CALL(cctx, ufunc, argcount);\n\tgoto theend;\n    }\n\n    // A global function may be defined only later.  Need to figure out at\n    // runtime.  Also handles a FuncRef at runtime.\n    if (STRNCMP(namebuf, \"g:\", 2) == 0 || is_autoload)\n\tres = generate_UCALL(cctx, name, argcount);\n    else\n\tsemsg(_(e_unknown_function_str), namebuf);\n\ntheend:\n    vim_free(tofree);\n    return res;\n}\n\n// like NAMESPACE_CHAR but with 'a' and 'l'.\n#define VIM9_NAMESPACE_CHAR\t(char_u *)\"bgstvw\"\n\n/*\n * Find the end of a variable or function name.  Unlike find_name_end() this\n * does not recognize magic braces.\n * When \"use_namespace\" is TRUE recognize \"b:\", \"s:\", etc.\n * Return a pointer to just after the name.  Equal to \"arg\" if there is no\n * valid name.\n */\n    char_u *\nto_name_end(char_u *arg, int use_namespace)\n{\n    char_u\t*p;\n\n    // Quick check for valid starting character.\n    if (!eval_isnamec1(*arg))\n\treturn arg;\n\n    for (p = arg + 1; *p != NUL && eval_isnamec(*p); MB_PTR_ADV(p))\n\t// Include a namespace such as \"s:var\" and \"v:var\".  But \"n:\" is not\n\t// and can be used in slice \"[n:]\".\n\tif (*p == ':' && (p != arg + 1\n\t\t\t     || !use_namespace\n\t\t\t     || vim_strchr(VIM9_NAMESPACE_CHAR, *arg) == NULL))\n\t    break;\n    return p;\n}\n\n/*\n * Like to_name_end() but also skip over a list or dict constant.\n * Also accept \"<SNR>123_Func\".\n * This intentionally does not handle line continuation.\n */\n    char_u *\nto_name_const_end(char_u *arg)\n{\n    char_u\t*p = arg;\n    typval_T\trettv;\n\n    if (STRNCMP(p, \"<SNR>\", 5) == 0)\n\tp = skipdigits(p + 5);\n    p = to_name_end(p, TRUE);\n    if (p == arg && *arg == '[')\n    {\n\n\t// Can be \"[1, 2, 3]->Func()\".\n\tif (eval_list(&p, &rettv, NULL, FALSE) == FAIL)\n\t    p = arg;\n    }\n    return p;\n}\n\n/*\n * parse a list: [expr, expr]\n * \"*arg\" points to the '['.\n * ppconst->pp_is_const is set if all items are a constant.\n */\n    static int\ncompile_list(char_u **arg, cctx_T *cctx, ppconst_T *ppconst)\n{\n    char_u\t*p = skipwhite(*arg + 1);\n    char_u\t*whitep = *arg + 1;\n    int\t\tcount = 0;\n    int\t\tis_const;\n    int\t\tis_all_const = TRUE;\t// reset when non-const encountered\n\n    for (;;)\n    {\n\tif (may_get_next_line(whitep, &p, cctx) == FAIL)\n\t{\n\t    semsg(_(e_missing_end_of_list_rsb_str), *arg);\n\t    return FAIL;\n\t}\n\tif (*p == ',')\n\t{\n\t    semsg(_(e_no_white_space_allowed_before_str_str), \",\", p);\n\t    return FAIL;\n\t}\n\tif (*p == ']')\n\t{\n\t    ++p;\n\t    break;\n\t}\n\tif (compile_expr0_ext(&p, cctx, &is_const) == FAIL)\n\t    return FAIL;\n\tif (!is_const)\n\t    is_all_const = FALSE;\n\t++count;\n\tif (*p == ',')\n\t{\n\t    ++p;\n\t    if (*p != ']' && !IS_WHITE_OR_NUL(*p))\n\t    {\n\t\tsemsg(_(e_white_space_required_after_str_str), \",\", p - 1);\n\t\treturn FAIL;\n\t    }\n\t}\n\twhitep = p;\n\tp = skipwhite(p);\n    }\n    *arg = p;\n\n    ppconst->pp_is_const = is_all_const;\n    return generate_NEWLIST(cctx, count);\n}\n\n/*\n * Parse a lambda: \"(arg, arg) => expr\"\n * \"*arg\" points to the '('.\n * Returns OK/FAIL when a lambda is recognized, NOTDONE if it's not a lambda.\n */\n    static int\ncompile_lambda(char_u **arg, cctx_T *cctx)\n{\n    int\t\tr;\n    typval_T\trettv;\n    ufunc_T\t*ufunc;\n    evalarg_T\tevalarg;\n\n    init_evalarg(&evalarg);\n    evalarg.eval_flags = EVAL_EVALUATE;\n    evalarg.eval_cctx = cctx;\n\n    // Get the funcref in \"rettv\".\n    r = get_lambda_tv(arg, &rettv, TRUE, &evalarg);\n    if (r != OK)\n    {\n\tclear_evalarg(&evalarg, NULL);\n\treturn r;\n    }\n\n    // \"rettv\" will now be a partial referencing the function.\n    ufunc = rettv.vval.v_partial->pt_func;\n    ++ufunc->uf_refcount;\n    clear_tv(&rettv);\n\n    // Compile it here to get the return type.  The return type is optional,\n    // when it's missing use t_unknown.  This is recognized in\n    // compile_return().\n    if (ufunc->uf_ret_type->tt_type == VAR_VOID)\n\tufunc->uf_ret_type = &t_unknown;\n    compile_def_function(ufunc, FALSE, cctx->ctx_compile_type, cctx);\n\n    // When the outer function is compiled for profiling or debugging, the\n    // lambda may be called without profiling or debugging.  Compile it here in\n    // the right context.\n    if (cctx->ctx_compile_type == CT_DEBUG\n#ifdef FEAT_PROFILE\n\t    || cctx->ctx_compile_type == CT_PROFILE\n#endif\n       )\n\tcompile_def_function(ufunc, FALSE, CT_NONE, cctx);\n\n    // The last entry in evalarg.eval_tofree_ga is a copy of the last line and\n    // \"*arg\" may point into it.  Point into the original line to avoid a\n    // dangling pointer.\n    if (evalarg.eval_using_cmdline)\n    {\n\tgarray_T    *gap = &evalarg.eval_tofree_ga;\n\tsize_t\t    off = *arg - ((char_u **)gap->ga_data)[gap->ga_len - 1];\n\n\t*arg = ((char_u **)cctx->ctx_ufunc->uf_lines.ga_data)[cctx->ctx_lnum]\n\t\t\t\t\t\t\t\t\t + off;\n    }\n\n    clear_evalarg(&evalarg, NULL);\n\n    if (ufunc->uf_def_status == UF_COMPILED)\n    {\n\t// The return type will now be known.\n\tset_function_type(ufunc);\n\n\t// The function reference count will be 1.  When the ISN_FUNCREF\n\t// instruction is deleted the reference count is decremented and the\n\t// function is freed.\n\treturn generate_FUNCREF(cctx, ufunc);\n    }\n\n    func_ptr_unref(ufunc);\n    return FAIL;\n}\n\n/*\n * Get a lambda and compile it.  Uses Vim9 syntax.\n */\n    int\nget_lambda_tv_and_compile(\n\tchar_u\t    **arg,\n\ttypval_T    *rettv,\n\tint\t    types_optional,\n\tevalarg_T   *evalarg)\n{\n    int\t\tr;\n    ufunc_T\t*ufunc;\n    int\t\tsave_sc_version = current_sctx.sc_version;\n\n    // Get the funcref in \"rettv\".\n    current_sctx.sc_version = SCRIPT_VERSION_VIM9;\n    r = get_lambda_tv(arg, rettv, types_optional, evalarg);\n    current_sctx.sc_version = save_sc_version;\n    if (r != OK)\n\treturn r;\n\n    // \"rettv\" will now be a partial referencing the function.\n    ufunc = rettv->vval.v_partial->pt_func;\n\n    // Compile it here to get the return type.  The return type is optional,\n    // when it's missing use t_unknown.  This is recognized in\n    // compile_return().\n    if (ufunc->uf_ret_type == NULL || ufunc->uf_ret_type->tt_type == VAR_VOID)\n\tufunc->uf_ret_type = &t_unknown;\n    compile_def_function(ufunc, FALSE, CT_NONE, NULL);\n\n    if (ufunc->uf_def_status == UF_COMPILED)\n    {\n\t// The return type will now be known.\n\tset_function_type(ufunc);\n\treturn OK;\n    }\n    clear_tv(rettv);\n    return FAIL;\n}\n\n/*\n * parse a dict: {key: val, [key]: val}\n * \"*arg\" points to the '{'.\n * ppconst->pp_is_const is set if all item values are a constant.\n */\n    static int\ncompile_dict(char_u **arg, cctx_T *cctx, ppconst_T *ppconst)\n{\n    garray_T\t*instr = &cctx->ctx_instr;\n    int\t\tcount = 0;\n    dict_T\t*d = dict_alloc();\n    dictitem_T\t*item;\n    char_u\t*whitep = *arg + 1;\n    char_u\t*p;\n    int\t\tis_const;\n    int\t\tis_all_const = TRUE;\t// reset when non-const encountered\n\n    if (d == NULL)\n\treturn FAIL;\n    if (generate_ppconst(cctx, ppconst) == FAIL)\n\treturn FAIL;\n    for (;;)\n    {\n\tchar_u\t    *key = NULL;\n\n\tif (may_get_next_line(whitep, arg, cctx) == FAIL)\n\t{\n\t    *arg = NULL;\n\t    goto failret;\n\t}\n\n\tif (**arg == '}')\n\t    break;\n\n\tif (**arg == '[')\n\t{\n\t    isn_T\t*isn;\n\n\t    // {[expr]: value} uses an evaluated key.\n\t    *arg = skipwhite(*arg + 1);\n\t    if (compile_expr0(arg, cctx) == FAIL)\n\t\treturn FAIL;\n\t    isn = ((isn_T *)instr->ga_data) + instr->ga_len - 1;\n\t    if (isn->isn_type == ISN_PUSHNR)\n\t    {\n\t\tchar buf[NUMBUFLEN];\n\n\t\t// Convert to string at compile time.\n\t\tvim_snprintf(buf, NUMBUFLEN, \"%lld\", isn->isn_arg.number);\n\t\tisn->isn_type = ISN_PUSHS;\n\t\tisn->isn_arg.string = vim_strsave((char_u *)buf);\n\t    }\n\t    if (isn->isn_type == ISN_PUSHS)\n\t\tkey = isn->isn_arg.string;\n\t    else if (may_generate_2STRING(-1, FALSE, cctx) == FAIL)\n\t\treturn FAIL;\n\t    *arg = skipwhite(*arg);\n\t    if (**arg != ']')\n\t    {\n\t\temsg(_(e_missing_matching_bracket_after_dict_key));\n\t\treturn FAIL;\n\t    }\n\t    ++*arg;\n\t}\n\telse\n\t{\n\t    // {\"name\": value},\n\t    // {'name': value},\n\t    // {name: value} use \"name\" as a literal key\n\t    key = get_literal_key(arg);\n\t    if (key == NULL)\n\t\treturn FAIL;\n\t    if (generate_PUSHS(cctx, &key) == FAIL)\n\t\treturn FAIL;\n\t}\n\n\t// Check for duplicate keys, if using string keys.\n\tif (key != NULL)\n\t{\n\t    item = dict_find(d, key, -1);\n\t    if (item != NULL)\n\t    {\n\t\tsemsg(_(e_duplicate_key_in_dicitonary), key);\n\t\tgoto failret;\n\t    }\n\t    item = dictitem_alloc(key);\n\t    if (item != NULL)\n\t    {\n\t\titem->di_tv.v_type = VAR_UNKNOWN;\n\t\titem->di_tv.v_lock = 0;\n\t\tif (dict_add(d, item) == FAIL)\n\t\t    dictitem_free(item);\n\t    }\n\t}\n\n\tif (**arg != ':')\n\t{\n\t    if (*skipwhite(*arg) == ':')\n\t\tsemsg(_(e_no_white_space_allowed_before_str_str), \":\", *arg);\n\t    else\n\t\tsemsg(_(e_missing_colon_in_dictionary), *arg);\n\t    return FAIL;\n\t}\n\twhitep = *arg + 1;\n\tif (!IS_WHITE_OR_NUL(*whitep))\n\t{\n\t    semsg(_(e_white_space_required_after_str_str), \":\", *arg);\n\t    return FAIL;\n\t}\n\n\tif (may_get_next_line(whitep, arg, cctx) == FAIL)\n\t{\n\t    *arg = NULL;\n\t    goto failret;\n\t}\n\n\tif (compile_expr0_ext(arg, cctx, &is_const) == FAIL)\n\t    return FAIL;\n\tif (!is_const)\n\t    is_all_const = FALSE;\n\t++count;\n\n\twhitep = *arg;\n\tif (may_get_next_line(whitep, arg, cctx) == FAIL)\n\t{\n\t    *arg = NULL;\n\t    goto failret;\n\t}\n\tif (**arg == '}')\n\t    break;\n\tif (**arg != ',')\n\t{\n\t    semsg(_(e_missing_comma_in_dictionary), *arg);\n\t    goto failret;\n\t}\n\tif (IS_WHITE_OR_NUL(*whitep))\n\t{\n\t    semsg(_(e_no_white_space_allowed_before_str_str), \",\", whitep);\n\t    return FAIL;\n\t}\n\twhitep = *arg + 1;\n\tif (!IS_WHITE_OR_NUL(*whitep))\n\t{\n\t    semsg(_(e_white_space_required_after_str_str), \",\", *arg);\n\t    return FAIL;\n\t}\n\t*arg = skipwhite(whitep);\n    }\n\n    *arg = *arg + 1;\n\n    // Allow for following comment, after at least one space.\n    p = skipwhite(*arg);\n    if (VIM_ISWHITE(**arg) && vim9_comment_start(p))\n\t*arg += STRLEN(*arg);\n\n    dict_unref(d);\n    ppconst->pp_is_const = is_all_const;\n    return generate_NEWDICT(cctx, count);\n\nfailret:\n    if (*arg == NULL)\n    {\n\tsemsg(_(e_missing_dict_end), _(\"[end of lines]\"));\n\t*arg = (char_u *)\"\";\n    }\n    dict_unref(d);\n    return FAIL;\n}\n\n/*\n * Compile \"&option\".\n */\n    static int\ncompile_get_option(char_u **arg, cctx_T *cctx)\n{\n    typval_T\trettv;\n    char_u\t*start = *arg;\n    int\t\tret;\n\n    // parse the option and get the current value to get the type.\n    rettv.v_type = VAR_UNKNOWN;\n    ret = eval_option(arg, &rettv, TRUE);\n    if (ret == OK)\n    {\n\t// include the '&' in the name, eval_option() expects it.\n\tchar_u\t*name = vim_strnsave(start, *arg - start);\n\ttype_T\t*type = rettv.v_type == VAR_BOOL ? &t_bool\n\t\t\t  : rettv.v_type == VAR_NUMBER ? &t_number : &t_string;\n\n\tret = generate_LOAD(cctx, ISN_LOADOPT, 0, name, type);\n\tvim_free(name);\n    }\n    clear_tv(&rettv);\n\n    return ret;\n}\n\n/*\n * Compile \"$VAR\".\n */\n    static int\ncompile_get_env(char_u **arg, cctx_T *cctx)\n{\n    char_u\t*start = *arg;\n    int\t\tlen;\n    int\t\tret;\n    char_u\t*name;\n\n    ++*arg;\n    len = get_env_len(arg);\n    if (len == 0)\n    {\n\tsemsg(_(e_syntax_error_at_str), start - 1);\n\treturn FAIL;\n    }\n\n    // include the '$' in the name, eval_env_var() expects it.\n    name = vim_strnsave(start, len + 1);\n    ret = generate_LOAD(cctx, ISN_LOADENV, 0, name, &t_string);\n    vim_free(name);\n    return ret;\n}\n\n/*\n * Compile \"@r\".\n */\n    static int\ncompile_get_register(char_u **arg, cctx_T *cctx)\n{\n    int\t\tret;\n\n    ++*arg;\n    if (**arg == NUL)\n    {\n\tsemsg(_(e_syntax_error_at_str), *arg - 1);\n\treturn FAIL;\n    }\n    if (!valid_yank_reg(**arg, FALSE))\n    {\n\temsg_invreg(**arg);\n\treturn FAIL;\n    }\n    ret = generate_LOAD(cctx, ISN_LOADREG, **arg, NULL, &t_string);\n    ++*arg;\n    return ret;\n}\n\n/*\n * Apply leading '!', '-' and '+' to constant \"rettv\".\n * When \"numeric_only\" is TRUE do not apply '!'.\n */\n    static int\napply_leader(typval_T *rettv, int numeric_only, char_u *start, char_u **end)\n{\n    char_u *p = *end;\n\n    // this works from end to start\n    while (p > start)\n    {\n\t--p;\n\tif (*p == '-' || *p == '+')\n\t{\n\t    // only '-' has an effect, for '+' we only check the type\n#ifdef FEAT_FLOAT\n\t    if (rettv->v_type == VAR_FLOAT)\n\t    {\n\t\tif (*p == '-')\n\t\t    rettv->vval.v_float = -rettv->vval.v_float;\n\t    }\n\t    else\n#endif\n\t    {\n\t\tvarnumber_T\tval;\n\t\tint\t\terror = FALSE;\n\n\t\t// tv_get_number_chk() accepts a string, but we don't want that\n\t\t// here\n\t\tif (check_not_string(rettv) == FAIL)\n\t\t    return FAIL;\n\t\tval = tv_get_number_chk(rettv, &error);\n\t\tclear_tv(rettv);\n\t\tif (error)\n\t\t    return FAIL;\n\t\tif (*p == '-')\n\t\t    val = -val;\n\t\trettv->v_type = VAR_NUMBER;\n\t\trettv->vval.v_number = val;\n\t    }\n\t}\n\telse if (numeric_only)\n\t{\n\t    ++p;\n\t    break;\n\t}\n\telse if (*p == '!')\n\t{\n\t    int v = tv2bool(rettv);\n\n\t    // '!' is permissive in the type.\n\t    clear_tv(rettv);\n\t    rettv->v_type = VAR_BOOL;\n\t    rettv->vval.v_number = v ? VVAL_FALSE : VVAL_TRUE;\n\t}\n    }\n    *end = p;\n    return OK;\n}\n\n/*\n * Recognize v: variables that are constants and set \"rettv\".\n */\n    static void\nget_vim_constant(char_u **arg, typval_T *rettv)\n{\n    if (STRNCMP(*arg, \"v:true\", 6) == 0)\n    {\n\trettv->v_type = VAR_BOOL;\n\trettv->vval.v_number = VVAL_TRUE;\n\t*arg += 6;\n    }\n    else if (STRNCMP(*arg, \"v:false\", 7) == 0)\n    {\n\trettv->v_type = VAR_BOOL;\n\trettv->vval.v_number = VVAL_FALSE;\n\t*arg += 7;\n    }\n    else if (STRNCMP(*arg, \"v:null\", 6) == 0)\n    {\n\trettv->v_type = VAR_SPECIAL;\n\trettv->vval.v_number = VVAL_NULL;\n\t*arg += 6;\n    }\n    else if (STRNCMP(*arg, \"v:none\", 6) == 0)\n    {\n\trettv->v_type = VAR_SPECIAL;\n\trettv->vval.v_number = VVAL_NONE;\n\t*arg += 6;\n    }\n}\n\n    exprtype_T\nget_compare_type(char_u *p, int *len, int *type_is)\n{\n    exprtype_T\ttype = EXPR_UNKNOWN;\n    int\t\ti;\n\n    switch (p[0])\n    {\n\tcase '=':   if (p[1] == '=')\n\t\t\ttype = EXPR_EQUAL;\n\t\t    else if (p[1] == '~')\n\t\t\ttype = EXPR_MATCH;\n\t\t    break;\n\tcase '!':   if (p[1] == '=')\n\t\t\ttype = EXPR_NEQUAL;\n\t\t    else if (p[1] == '~')\n\t\t\ttype = EXPR_NOMATCH;\n\t\t    break;\n\tcase '>':   if (p[1] != '=')\n\t\t    {\n\t\t\ttype = EXPR_GREATER;\n\t\t\t*len = 1;\n\t\t    }\n\t\t    else\n\t\t\ttype = EXPR_GEQUAL;\n\t\t    break;\n\tcase '<':   if (p[1] != '=')\n\t\t    {\n\t\t\ttype = EXPR_SMALLER;\n\t\t\t*len = 1;\n\t\t    }\n\t\t    else\n\t\t\ttype = EXPR_SEQUAL;\n\t\t    break;\n\tcase 'i':   if (p[1] == 's')\n\t\t    {\n\t\t\t// \"is\" and \"isnot\"; but not a prefix of a name\n\t\t\tif (p[2] == 'n' && p[3] == 'o' && p[4] == 't')\n\t\t\t    *len = 5;\n\t\t\ti = p[*len];\n\t\t\tif (!isalnum(i) && i != '_')\n\t\t\t{\n\t\t\t    type = *len == 2 ? EXPR_IS : EXPR_ISNOT;\n\t\t\t    *type_is = TRUE;\n\t\t\t}\n\t\t    }\n\t\t    break;\n    }\n    return type;\n}\n\n/*\n * Skip over an expression, ignoring most errors.\n */\n    void\nskip_expr_cctx(char_u **arg, cctx_T *cctx)\n{\n    evalarg_T\tevalarg;\n\n    init_evalarg(&evalarg);\n    evalarg.eval_cctx = cctx;\n    skip_expr(arg, &evalarg);\n    clear_evalarg(&evalarg, NULL);\n}\n\n/*\n * Check that the top of the type stack has a type that can be used as a\n * condition.  Give an error and return FAIL if not.\n */\n    int\nbool_on_stack(cctx_T *cctx)\n{\n    type_T\t*type;\n\n    type = get_type_on_stack(cctx, 0);\n    if (type == &t_bool)\n\treturn OK;\n\n    if (type == &t_any\n\t    || type == &t_unknown\n\t    || type == &t_number\n\t    || type == &t_number_bool)\n\t// Number 0 and 1 are OK to use as a bool.  \"any\" could also be a bool.\n\t// This requires a runtime type check.\n\treturn generate_COND2BOOL(cctx);\n\n    return need_type(type, &t_bool, -1, 0, cctx, FALSE, FALSE);\n}\n\n/*\n * Give the \"white on both sides\" error, taking the operator from \"p[len]\".\n */\n    void\nerror_white_both(char_u *op, int len)\n{\n    char_u\tbuf[10];\n\n    vim_strncpy(buf, op, len);\n    semsg(_(e_white_space_required_before_and_after_str_at_str), buf, op);\n}\n\n/*\n * Compile code to apply '-', '+' and '!'.\n * When \"numeric_only\" is TRUE do not apply '!'.\n */\n    static int\ncompile_leader(cctx_T *cctx, int numeric_only, char_u *start, char_u **end)\n{\n    char_u\t*p = *end;\n\n    // this works from end to start\n    while (p > start)\n    {\n\t--p;\n\twhile (VIM_ISWHITE(*p))\n\t    --p;\n\tif (*p == '-' || *p == '+')\n\t{\n\t    int\t\tnegate = *p == '-';\n\t    isn_T\t*isn;\n\t    type_T\t*type;\n\n\t    type = get_type_on_stack(cctx, 0);\n\t    if (type != &t_float && need_type(type, &t_number,\n\t\t\t\t\t    -1, 0, cctx, FALSE, FALSE) == FAIL)\n\t\treturn FAIL;\n\n\t    while (p > start && (p[-1] == '-' || p[-1] == '+'))\n\t    {\n\t\t--p;\n\t\tif (*p == '-')\n\t\t    negate = !negate;\n\t    }\n\t    // only '-' has an effect, for '+' we only check the type\n\t    if (negate)\n\t    {\n\t\tisn = generate_instr(cctx, ISN_NEGATENR);\n\t\tif (isn == NULL)\n\t\t    return FAIL;\n\t    }\n\t}\n\telse if (numeric_only)\n\t{\n\t    ++p;\n\t    break;\n\t}\n\telse\n\t{\n\t    int  invert = *p == '!';\n\n\t    while (p > start && (p[-1] == '!' || VIM_ISWHITE(p[-1])))\n\t    {\n\t\tif (p[-1] == '!')\n\t\t    invert = !invert;\n\t\t--p;\n\t    }\n\t    if (generate_2BOOL(cctx, invert, -1) == FAIL)\n\t\treturn FAIL;\n\t}\n    }\n    *end = p;\n    return OK;\n}\n\n/*\n * Compile \"(expression)\": recursive!\n * Return FAIL/OK.\n */\n    static int\ncompile_parenthesis(char_u **arg, cctx_T *cctx, ppconst_T *ppconst)\n{\n    int\t    ret;\n    char_u  *p = *arg + 1;\n\n    if (may_get_next_line_error(p, arg, cctx) == FAIL)\n\treturn FAIL;\n    if (ppconst->pp_used <= PPSIZE - 10)\n    {\n\tret = compile_expr1(arg, cctx, ppconst);\n    }\n    else\n    {\n\t// Not enough space in ppconst, flush constants.\n\tif (generate_ppconst(cctx, ppconst) == FAIL)\n\t    return FAIL;\n\tret = compile_expr0(arg, cctx);\n    }\n    if (may_get_next_line_error(*arg, arg, cctx) == FAIL)\n\treturn FAIL;\n    if (**arg == ')')\n\t++*arg;\n    else if (ret == OK)\n    {\n\temsg(_(e_missing_closing_paren));\n\tret = FAIL;\n    }\n    return ret;\n}\n\n/*\n * Compile whatever comes after \"name\" or \"name()\".\n * Advances \"*arg\" only when something was recognized.\n */\n    static int\ncompile_subscript(\n\tchar_u **arg,\n\tcctx_T *cctx,\n\tchar_u *start_leader,\n\tchar_u **end_leader,\n\tppconst_T *ppconst)\n{\n    char_u\t*name_start = *end_leader;\n    int\t\tkeeping_dict = FALSE;\n\n    for (;;)\n    {\n\tchar_u *p = skipwhite(*arg);\n\n\tif (*p == NUL || (VIM_ISWHITE(**arg) && vim9_comment_start(p)))\n\t{\n\t    char_u *next = peek_next_line_from_context(cctx);\n\n\t    // If a following line starts with \"->{\" or \"->X\" advance to that\n\t    // line, so that a line break before \"->\" is allowed.\n\t    // Also if a following line starts with \".x\".\n\t    if (next != NULL &&\n\t\t    ((next[0] == '-' && next[1] == '>'\n\t\t\t\t && (next[2] == '{'\n\t\t\t\t       || ASCII_ISALPHA(*skipwhite(next + 2))))\n\t\t    || (next[0] == '.' && eval_isdictc(next[1]))))\n\t    {\n\t\tnext = next_line_from_context(cctx, TRUE);\n\t\tif (next == NULL)\n\t\t    return FAIL;\n\t\t*arg = next;\n\t\tp = skipwhite(*arg);\n\t    }\n\t}\n\n\t// Do not skip over white space to find the \"(\", \"execute 'x' (expr)\"\n\t// is not a function call.\n\tif (**arg == '(')\n\t{\n\t    type_T\t*type;\n\t    int\t\targcount = 0;\n\n\t    if (generate_ppconst(cctx, ppconst) == FAIL)\n\t\treturn FAIL;\n\t    ppconst->pp_is_const = FALSE;\n\n\t    // funcref(arg)\n\t    type = get_type_on_stack(cctx, 0);\n\n\t    *arg = skipwhite(p + 1);\n\t    if (compile_arguments(arg, cctx, &argcount, FALSE) == FAIL)\n\t\treturn FAIL;\n\t    if (generate_PCALL(cctx, argcount, name_start, type, TRUE) == FAIL)\n\t\treturn FAIL;\n\t    if (keeping_dict)\n\t    {\n\t\tkeeping_dict = FALSE;\n\t\tif (generate_instr(cctx, ISN_CLEARDICT) == NULL)\n\t\t    return FAIL;\n\t    }\n\t}\n\telse if (*p == '-' && p[1] == '>')\n\t{\n\t    char_u *pstart = p;\n\n\t    if (generate_ppconst(cctx, ppconst) == FAIL)\n\t\treturn FAIL;\n\t    ppconst->pp_is_const = FALSE;\n\n\t    // something->method()\n\t    // Apply the '!', '-' and '+' first:\n\t    //   -1.0->func() works like (-1.0)->func()\n\t    if (compile_leader(cctx, TRUE, start_leader, end_leader) == FAIL)\n\t\treturn FAIL;\n\n\t    p += 2;\n\t    *arg = skipwhite(p);\n\t    // No line break supported right after \"->\".\n\t    if (**arg == '(')\n\t    {\n\t\tint\t    argcount = 1;\n\t\tgarray_T    *stack = &cctx->ctx_type_stack;\n\t\tint\t    type_idx_start = stack->ga_len;\n\t\ttype_T\t    *type;\n\t\tint\t    expr_isn_start = cctx->ctx_instr.ga_len;\n\t\tint\t    expr_isn_end;\n\t\tint\t    arg_isn_count;\n\n\t\t// Funcref call:  list->(Refs[2])(arg)\n\t\t// or lambda:\t  list->((arg) => expr)(arg)\n\t\t//\n\t\t// Fist compile the function expression.\n\t\tif (compile_parenthesis(arg, cctx, ppconst) == FAIL)\n\t\t    return FAIL;\n\n\t\t// Remember the next instruction index, where the instructions\n\t\t// for arguments are being written.\n\t\texpr_isn_end = cctx->ctx_instr.ga_len;\n\n\t\t// Compile the arguments.\n\t\tif (**arg != '(')\n\t\t{\n\t\t    if (*skipwhite(*arg) == '(')\n\t\t\temsg(_(e_no_white_space_allowed_before_parenthesis));\n\t\t    else\n\t\t\tsemsg(_(e_missing_parenthesis_str), *arg);\n\t\t    return FAIL;\n\t\t}\n\t\t*arg = skipwhite(*arg + 1);\n\t\tif (compile_arguments(arg, cctx, &argcount, FALSE) == FAIL)\n\t\t    return FAIL;\n\n\t\t// Move the instructions for the arguments to before the\n\t\t// instructions of the expression and move the type of the\n\t\t// expression after the argument types.  This is what ISN_PCALL\n\t\t// expects.\n\t\targ_isn_count = cctx->ctx_instr.ga_len - expr_isn_end;\n\t\tif (arg_isn_count > 0)\n\t\t{\n\t\t    int\t    expr_isn_count = expr_isn_end - expr_isn_start;\n\t\t    isn_T   *isn = ALLOC_MULT(isn_T, expr_isn_count);\n\t\t    type_T  *decl_type;\n\t\t    type2_T  *typep;\n\n\t\t    if (isn == NULL)\n\t\t\treturn FAIL;\n\t\t    mch_memmove(isn, ((isn_T *)cctx->ctx_instr.ga_data)\n\t\t\t\t\t\t\t      + expr_isn_start,\n\t\t\t\t\t       sizeof(isn_T) * expr_isn_count);\n\t\t    mch_memmove(((isn_T *)cctx->ctx_instr.ga_data)\n\t\t\t\t\t\t\t      + expr_isn_start,\n\t\t\t     ((isn_T *)cctx->ctx_instr.ga_data) + expr_isn_end,\n\t\t\t\t\t\tsizeof(isn_T) * arg_isn_count);\n\t\t    mch_memmove(((isn_T *)cctx->ctx_instr.ga_data)\n\t\t\t\t\t      + expr_isn_start + arg_isn_count,\n\t\t\t\t\t  isn, sizeof(isn_T) * expr_isn_count);\n\t\t    vim_free(isn);\n\n\t\t    typep = ((type2_T *)stack->ga_data) + type_idx_start;\n\t\t    type = typep->type_curr;\n\t\t    decl_type = typep->type_decl;\n\t\t    mch_memmove(((type2_T *)stack->ga_data) + type_idx_start,\n\t\t\t      ((type2_T *)stack->ga_data) + type_idx_start + 1,\n\t\t\t      sizeof(type2_T)\n\t\t\t\t       * (stack->ga_len - type_idx_start - 1));\n\t\t    typep = ((type2_T *)stack->ga_data) + stack->ga_len - 1;\n\t\t    typep->type_curr = type;\n\t\t    typep->type_decl = decl_type;\n\t\t}\n\n\t\ttype = get_type_on_stack(cctx, 0);\n\t\tif (generate_PCALL(cctx, argcount, p - 2, type, FALSE) == FAIL)\n\t\t    return FAIL;\n\t    }\n\t    else\n\t    {\n\t\t// method call:  list->method()\n\t\tp = *arg;\n\t\tif (!eval_isnamec1(*p))\n\t\t{\n\t\t    semsg(_(e_trailing_characters_str), pstart);\n\t\t    return FAIL;\n\t\t}\n\t\tif (ASCII_ISALPHA(*p) && p[1] == ':')\n\t\t    p += 2;\n\t\tfor ( ; eval_isnamec(*p); ++p)\n\t\t    ;\n\t\tif (*p != '(')\n\t\t{\n\t\t    semsg(_(e_missing_parenthesis_str), *arg);\n\t\t    return FAIL;\n\t\t}\n\t\tif (compile_call(arg, p - *arg, cctx, ppconst, 1) == FAIL)\n\t\t    return FAIL;\n\t    }\n\t    if (keeping_dict)\n\t    {\n\t\tkeeping_dict = FALSE;\n\t\tif (generate_instr(cctx, ISN_CLEARDICT) == NULL)\n\t\t    return FAIL;\n\t    }\n\t}\n\telse if (**arg == '[')\n\t{\n\t    int\t\tis_slice = FALSE;\n\n\t    // list index: list[123]\n\t    // dict member: dict[key]\n\t    // string index: text[123]\n\t    // blob index: blob[123]\n\t    if (generate_ppconst(cctx, ppconst) == FAIL)\n\t\treturn FAIL;\n\t    ppconst->pp_is_const = FALSE;\n\n\t    ++p;\n\t    if (may_get_next_line_error(p, arg, cctx) == FAIL)\n\t\treturn FAIL;\n\t    if (**arg == ':')\n\t    {\n\t\t// missing first index is equal to zero\n\t\tgenerate_PUSHNR(cctx, 0);\n\t    }\n\t    else\n\t    {\n\t\tif (compile_expr0(arg, cctx) == FAIL)\n\t\t    return FAIL;\n\t\tif (**arg == ':')\n\t\t{\n\t\t    semsg(_(e_white_space_required_before_and_after_str_at_str),\n\t\t\t\t\t\t\t\t    \":\", *arg);\n\t\t    return FAIL;\n\t\t}\n\t\tif (may_get_next_line_error(*arg, arg, cctx) == FAIL)\n\t\t    return FAIL;\n\t\t*arg = skipwhite(*arg);\n\t    }\n\t    if (**arg == ':')\n\t    {\n\t\tis_slice = TRUE;\n\t\t++*arg;\n\t\tif (!IS_WHITE_OR_NUL(**arg) && **arg != ']')\n\t\t{\n\t\t    semsg(_(e_white_space_required_before_and_after_str_at_str),\n\t\t\t\t\t\t\t\t    \":\", *arg);\n\t\t    return FAIL;\n\t\t}\n\t\tif (may_get_next_line_error(*arg, arg, cctx) == FAIL)\n\t\t    return FAIL;\n\t\tif (**arg == ']')\n\t\t    // missing second index is equal to end of string\n\t\t    generate_PUSHNR(cctx, -1);\n\t\telse\n\t\t{\n\t\t    if (compile_expr0(arg, cctx) == FAIL)\n\t\t\treturn FAIL;\n\t\t    if (may_get_next_line_error(*arg, arg, cctx) == FAIL)\n\t\t\treturn FAIL;\n\t\t    *arg = skipwhite(*arg);\n\t\t}\n\t    }\n\n\t    if (**arg != ']')\n\t    {\n\t\temsg(_(e_missing_closing_square_brace));\n\t\treturn FAIL;\n\t    }\n\t    *arg = *arg + 1;\n\n\t    if (keeping_dict)\n\t    {\n\t\tkeeping_dict = FALSE;\n\t\tif (generate_instr(cctx, ISN_CLEARDICT) == NULL)\n\t\t    return FAIL;\n\t    }\n\t    if (compile_member(is_slice, &keeping_dict, cctx) == FAIL)\n\t\treturn FAIL;\n\t}\n\telse if (*p == '.' && p[1] != '.')\n\t{\n\t    // dictionary member: dict.name\n\t    if (generate_ppconst(cctx, ppconst) == FAIL)\n\t\treturn FAIL;\n\t    ppconst->pp_is_const = FALSE;\n\n\t    *arg = p + 1;\n\t    if (IS_WHITE_OR_NUL(**arg))\n\t    {\n\t\temsg(_(e_missing_name_after_dot));\n\t\treturn FAIL;\n\t    }\n\t    p = *arg;\n\t    if (eval_isdictc(*p))\n\t\twhile (eval_isnamec(*p))\n\t\t    MB_PTR_ADV(p);\n\t    if (p == *arg)\n\t    {\n\t\tsemsg(_(e_syntax_error_at_str), *arg);\n\t\treturn FAIL;\n\t    }\n\t    if (keeping_dict && generate_instr(cctx, ISN_CLEARDICT) == NULL)\n\t\treturn FAIL;\n\t    if (generate_STRINGMEMBER(cctx, *arg, p - *arg) == FAIL)\n\t\treturn FAIL;\n\t    keeping_dict = TRUE;\n\t    *arg = p;\n\t}\n\telse\n\t    break;\n    }\n\n    // Turn \"dict.Func\" into a partial for \"Func\" bound to \"dict\".\n    // This needs to be done at runtime to be able to check the type.\n    if (keeping_dict && generate_instr(cctx, ISN_USEDICT) == NULL)\n\treturn FAIL;\n\n    return OK;\n}\n\n/*\n * Compile an expression at \"*arg\" and add instructions to \"cctx->ctx_instr\".\n * \"arg\" is advanced until after the expression, skipping white space.\n *\n * If the value is a constant \"ppconst->pp_used\" will be non-zero.\n * Before instructions are generated, any values in \"ppconst\" will generated.\n *\n * This is the compiling equivalent of eval1(), eval2(), etc.\n */\n\n/*\n *  number\t\tnumber constant\n *  0zFFFFFFFF\t\tBlob constant\n *  \"string\"\t\tstring constant\n *  'string'\t\tliteral string constant\n *  &option-name\toption value\n *  @r\t\t\tregister contents\n *  identifier\t\tvariable value\n *  function()\t\tfunction call\n *  $VAR\t\tenvironment variable\n *  (expression)\tnested expression\n *  [expr, expr]\tList\n *  {key: val, [key]: val}   Dictionary\n *\n *  Also handle:\n *  ! in front\t\tlogical NOT\n *  - in front\t\tunary minus\n *  + in front\t\tunary plus (ignored)\n *  trailing (arg)\tfuncref/partial call\n *  trailing []\t\tsubscript in String or List\n *  trailing .name\tentry in Dictionary\n *  trailing ->name()\tmethod call\n */\n    static int\ncompile_expr8(\n\tchar_u **arg,\n\tcctx_T *cctx,\n\tppconst_T *ppconst)\n{\n    char_u\t*start_leader, *end_leader;\n    int\t\tret = OK;\n    typval_T\t*rettv = &ppconst->pp_tv[ppconst->pp_used];\n    int\t\tused_before = ppconst->pp_used;\n\n    ppconst->pp_is_const = FALSE;\n\n    /*\n     * Skip '!', '-' and '+' characters.  They are handled later.\n     */\n    start_leader = *arg;\n    if (eval_leader(arg, TRUE) == FAIL)\n\treturn FAIL;\n    end_leader = *arg;\n\n    rettv->v_type = VAR_UNKNOWN;\n    switch (**arg)\n    {\n\t/*\n\t * Number constant.\n\t */\n\tcase '0':\t// also for blob starting with 0z\n\tcase '1':\n\tcase '2':\n\tcase '3':\n\tcase '4':\n\tcase '5':\n\tcase '6':\n\tcase '7':\n\tcase '8':\n\tcase '9':\n\tcase '.':   if (eval_number(arg, rettv, TRUE, FALSE) == FAIL)\n\t\t\treturn FAIL;\n\t\t    // Apply \"-\" and \"+\" just before the number now, right to\n\t\t    // left.  Matters especially when \"->\" follows.  Stops at\n\t\t    // '!'.\n\t\t    if (apply_leader(rettv, TRUE,\n\t\t\t\t\t    start_leader, &end_leader) == FAIL)\n\t\t    {\n\t\t\tclear_tv(rettv);\n\t\t\treturn FAIL;\n\t\t    }\n\t\t    break;\n\n\t/*\n\t * String constant: \"string\".\n\t */\n\tcase '\"':   if (eval_string(arg, rettv, TRUE) == FAIL)\n\t\t\treturn FAIL;\n\t\t    break;\n\n\t/*\n\t * Literal string constant: 'str''ing'.\n\t */\n\tcase '\\'':  if (eval_lit_string(arg, rettv, TRUE) == FAIL)\n\t\t\treturn FAIL;\n\t\t    break;\n\n\t/*\n\t * Constant Vim variable.\n\t */\n\tcase 'v':   get_vim_constant(arg, rettv);\n\t\t    ret = NOTDONE;\n\t\t    break;\n\n\t/*\n\t * \"true\" constant\n\t */\n\tcase 't':   if (STRNCMP(*arg, \"true\", 4) == 0\n\t\t\t\t\t\t   && !eval_isnamec((*arg)[4]))\n\t\t    {\n\t\t\t*arg += 4;\n\t\t\trettv->v_type = VAR_BOOL;\n\t\t\trettv->vval.v_number = VVAL_TRUE;\n\t\t    }\n\t\t    else\n\t\t\tret = NOTDONE;\n\t\t    break;\n\n\t/*\n\t * \"false\" constant\n\t */\n\tcase 'f':   if (STRNCMP(*arg, \"false\", 5) == 0\n\t\t\t\t\t\t   && !eval_isnamec((*arg)[5]))\n\t\t    {\n\t\t\t*arg += 5;\n\t\t\trettv->v_type = VAR_BOOL;\n\t\t\trettv->vval.v_number = VVAL_FALSE;\n\t\t    }\n\t\t    else\n\t\t\tret = NOTDONE;\n\t\t    break;\n\n\t/*\n\t * \"null\" constant\n\t */\n\tcase 'n':   if (STRNCMP(*arg, \"null\", 4) == 0\n\t\t\t\t\t\t   && !eval_isnamec((*arg)[4]))\n\t\t    {\n\t\t\t*arg += 4;\n\t\t\trettv->v_type = VAR_SPECIAL;\n\t\t\trettv->vval.v_number = VVAL_NULL;\n\t\t    }\n\t\t    else\n\t\t\tret = NOTDONE;\n\t\t    break;\n\n\t/*\n\t * List: [expr, expr]\n\t */\n\tcase '[':   if (generate_ppconst(cctx, ppconst) == FAIL)\n\t\t\treturn FAIL;\n\t\t    ret = compile_list(arg, cctx, ppconst);\n\t\t    break;\n\n\t/*\n\t * Dictionary: {'key': val, 'key': val}\n\t */\n\tcase '{':   if (generate_ppconst(cctx, ppconst) == FAIL)\n\t\t\treturn FAIL;\n\t\t    ret = compile_dict(arg, cctx, ppconst);\n\t\t    break;\n\n\t/*\n\t * Option value: &name\n\t */\n\tcase '&':\tif (generate_ppconst(cctx, ppconst) == FAIL)\n\t\t\t    return FAIL;\n\t\t\tret = compile_get_option(arg, cctx);\n\t\t\tbreak;\n\n\t/*\n\t * Environment variable: $VAR.\n\t */\n\tcase '$':\tif (generate_ppconst(cctx, ppconst) == FAIL)\n\t\t\t    return FAIL;\n\t\t\tret = compile_get_env(arg, cctx);\n\t\t\tbreak;\n\n\t/*\n\t * Register contents: @r.\n\t */\n\tcase '@':\tif (generate_ppconst(cctx, ppconst) == FAIL)\n\t\t\t    return FAIL;\n\t\t\tret = compile_get_register(arg, cctx);\n\t\t\tbreak;\n\t/*\n\t * nested expression: (expression).\n\t * lambda: (arg, arg) => expr\n\t * funcref: (arg, arg) => { statement }\n\t */\n\tcase '(':   // if compile_lambda returns NOTDONE then it must be (expr)\n\t\t    ret = compile_lambda(arg, cctx);\n\t\t    if (ret == NOTDONE)\n\t\t\tret = compile_parenthesis(arg, cctx, ppconst);\n\t\t    break;\n\n\tdefault:    ret = NOTDONE;\n\t\t    break;\n    }\n    if (ret == FAIL)\n\treturn FAIL;\n\n    if (rettv->v_type != VAR_UNKNOWN && used_before == ppconst->pp_used)\n    {\n\tif (cctx->ctx_skip == SKIP_YES)\n\t    clear_tv(rettv);\n\telse\n\t    // A constant expression can possibly be handled compile time,\n\t    // return the value instead of generating code.\n\t    ++ppconst->pp_used;\n    }\n    else if (ret == NOTDONE)\n    {\n\tchar_u\t    *p;\n\tint\t    r;\n\n\tif (!eval_isnamec1(**arg))\n\t{\n\t    if (!vim9_bad_comment(*arg))\n\t    {\n\t\tif (ends_excmd(*skipwhite(*arg)))\n\t\t    semsg(_(e_empty_expression_str), *arg);\n\t\telse\n\t\t    semsg(_(e_name_expected_str), *arg);\n\t    }\n\t    return FAIL;\n\t}\n\n\t// \"name\" or \"name()\"\n\tp = to_name_end(*arg, TRUE);\n\tif (p - *arg == (size_t)1 && **arg == '_')\n\t{\n\t    emsg(_(e_cannot_use_underscore_here));\n\t    return FAIL;\n\t}\n\n\tif (*p == '(')\n\t{\n\t    r = compile_call(arg, p - *arg, cctx, ppconst, 0);\n\t}\n\telse\n\t{\n\t    if (cctx->ctx_skip != SKIP_YES\n\t\t\t\t    && generate_ppconst(cctx, ppconst) == FAIL)\n\t\treturn FAIL;\n\t    r = compile_load(arg, p, cctx, TRUE, TRUE);\n\t}\n\tif (r == FAIL)\n\t    return FAIL;\n    }\n\n    // Handle following \"[]\", \".member\", etc.\n    // Then deal with prefixed '-', '+' and '!', if not done already.\n    if (compile_subscript(arg, cctx, start_leader, &end_leader,\n\t\t\t\t\t\t\t     ppconst) == FAIL)\n\treturn FAIL;\n    if (ppconst->pp_used > 0)\n    {\n\t// apply the '!', '-' and '+' before the constant\n\trettv = &ppconst->pp_tv[ppconst->pp_used - 1];\n\tif (apply_leader(rettv, FALSE, start_leader, &end_leader) == FAIL)\n\t    return FAIL;\n\treturn OK;\n    }\n    if (compile_leader(cctx, FALSE, start_leader, &end_leader) == FAIL)\n\treturn FAIL;\n    return OK;\n}\n\n/*\n * <type>expr8: runtime type check / conversion\n */\n    static int\ncompile_expr7(char_u **arg, cctx_T *cctx, ppconst_T *ppconst)\n{\n    type_T *want_type = NULL;\n\n    // Recognize <type>\n    if (**arg == '<' && eval_isnamec1((*arg)[1]))\n    {\n\t++*arg;\n\twant_type = parse_type(arg, cctx->ctx_type_list, TRUE);\n\tif (want_type == NULL)\n\t    return FAIL;\n\n\tif (**arg != '>')\n\t{\n\t    if (*skipwhite(*arg) == '>')\n\t\tsemsg(_(e_no_white_space_allowed_before_str_str), \">\", *arg);\n\t    else\n\t\temsg(_(e_missing_gt));\n\t    return FAIL;\n\t}\n\t++*arg;\n\tif (may_get_next_line_error(*arg, arg, cctx) == FAIL)\n\t    return FAIL;\n    }\n\n    if (compile_expr8(arg, cctx, ppconst) == FAIL)\n\treturn FAIL;\n\n    if (want_type != NULL)\n    {\n\ttype_T\t    *actual;\n\twhere_T\t    where = WHERE_INIT;\n\n\tgenerate_ppconst(cctx, ppconst);\n\tactual = get_type_on_stack(cctx, 0);\n\tif (check_type_maybe(want_type, actual, FALSE, where) != OK)\n\t{\n\t    if (need_type(actual, want_type, -1, 0, cctx, FALSE, FALSE)\n\t\t\t\t\t\t\t\t       == FAIL)\n\t\treturn FAIL;\n\t}\n    }\n\n    return OK;\n}\n\n/*\n *\t*\tnumber multiplication\n *\t/\tnumber division\n *\t%\tnumber modulo\n */\n    static int\ncompile_expr6(char_u **arg, cctx_T *cctx, ppconst_T *ppconst)\n{\n    char_u\t*op;\n    char_u\t*next;\n    int\t\tppconst_used = ppconst->pp_used;\n\n    // get the first expression\n    if (compile_expr7(arg, cctx, ppconst) == FAIL)\n\treturn FAIL;\n\n    /*\n     * Repeat computing, until no \"*\", \"/\" or \"%\" is following.\n     */\n    for (;;)\n    {\n\top = may_peek_next_line(cctx, *arg, &next);\n\tif (*op != '*' && *op != '/' && *op != '%')\n\t    break;\n\tif (next != NULL)\n\t{\n\t    *arg = next_line_from_context(cctx, TRUE);\n\t    op = skipwhite(*arg);\n\t}\n\n\tif (!IS_WHITE_OR_NUL(**arg) || !IS_WHITE_OR_NUL(op[1]))\n\t{\n\t    error_white_both(op, 1);\n\t    return FAIL;\n\t}\n\tif (may_get_next_line_error(op + 1, arg, cctx) == FAIL)\n\t    return FAIL;\n\n\t// get the second expression\n\tif (compile_expr7(arg, cctx, ppconst) == FAIL)\n\t    return FAIL;\n\n\tif (ppconst->pp_used == ppconst_used + 2\n\t\t&& ppconst->pp_tv[ppconst_used].v_type == VAR_NUMBER\n\t\t&& ppconst->pp_tv[ppconst_used + 1].v_type == VAR_NUMBER)\n\t{\n\t    typval_T\t    *tv1 = &ppconst->pp_tv[ppconst_used];\n\t    typval_T\t    *tv2 = &ppconst->pp_tv[ppconst_used + 1];\n\t    varnumber_T\t    res = 0;\n\t    int\t\t    failed = FALSE;\n\n\t    // both are numbers: compute the result\n\t    switch (*op)\n\t    {\n\t\tcase '*': res = tv1->vval.v_number * tv2->vval.v_number;\n\t\t\t  break;\n\t\tcase '/': res = num_divide(tv1->vval.v_number,\n\t\t\t\t\t\t  tv2->vval.v_number, &failed);\n\t\t\t  break;\n\t\tcase '%': res = num_modulus(tv1->vval.v_number,\n\t\t\t\t\t\t  tv2->vval.v_number, &failed);\n\t\t\t  break;\n\t    }\n\t    if (failed)\n\t\treturn FAIL;\n\t    tv1->vval.v_number = res;\n\t    --ppconst->pp_used;\n\t}\n\telse\n\t{\n\t    generate_ppconst(cctx, ppconst);\n\t    generate_two_op(cctx, op);\n\t}\n    }\n\n    return OK;\n}\n\n/*\n *      +\tnumber addition or list/blobl concatenation\n *      -\tnumber subtraction\n *      ..\tstring concatenation\n */\n    static int\ncompile_expr5(char_u **arg, cctx_T *cctx, ppconst_T *ppconst)\n{\n    char_u\t*op;\n    char_u\t*next;\n    int\t\toplen;\n    int\t\tppconst_used = ppconst->pp_used;\n\n    // get the first variable\n    if (compile_expr6(arg, cctx, ppconst) == FAIL)\n\treturn FAIL;\n\n    /*\n     * Repeat computing, until no \"+\", \"-\" or \"..\" is following.\n     */\n    for (;;)\n    {\n\top = may_peek_next_line(cctx, *arg, &next);\n\tif (*op != '+' && *op != '-' && !(*op == '.' && *(op + 1) == '.'))\n\t    break;\n\tif (op[0] == op[1] && *op != '.' && next)\n\t    // Finding \"++\" or \"--\" on the next line is a separate command.\n\t    // But \"..\" is concatenation.\n\t    break;\n\toplen = (*op == '.' ? 2 : 1);\n\tif (next != NULL)\n\t{\n\t    *arg = next_line_from_context(cctx, TRUE);\n\t    op = skipwhite(*arg);\n\t}\n\n\tif (!IS_WHITE_OR_NUL(**arg) || !IS_WHITE_OR_NUL(op[oplen]))\n\t{\n\t    error_white_both(op, oplen);\n\t    return FAIL;\n\t}\n\n\tif (may_get_next_line_error(op + oplen, arg, cctx) == FAIL)\n\t    return FAIL;\n\n\t// get the second expression\n\tif (compile_expr6(arg, cctx, ppconst) == FAIL)\n\t    return FAIL;\n\n\tif (ppconst->pp_used == ppconst_used + 2\n\t\t&& (*op == '.'\n\t\t    ? (ppconst->pp_tv[ppconst_used].v_type == VAR_STRING\n\t\t    && ppconst->pp_tv[ppconst_used + 1].v_type == VAR_STRING)\n\t\t    : (ppconst->pp_tv[ppconst_used].v_type == VAR_NUMBER\n\t\t    && ppconst->pp_tv[ppconst_used + 1].v_type == VAR_NUMBER)))\n\t{\n\t    typval_T *tv1 = &ppconst->pp_tv[ppconst_used];\n\t    typval_T *tv2 = &ppconst->pp_tv[ppconst_used + 1];\n\n\t    // concat/subtract/add constant numbers\n\t    if (*op == '+')\n\t\ttv1->vval.v_number = tv1->vval.v_number + tv2->vval.v_number;\n\t    else if (*op == '-')\n\t\ttv1->vval.v_number = tv1->vval.v_number - tv2->vval.v_number;\n\t    else\n\t    {\n\t\t// concatenate constant strings\n\t\tchar_u *s1 = tv1->vval.v_string;\n\t\tchar_u *s2 = tv2->vval.v_string;\n\t\tsize_t len1 = STRLEN(s1);\n\n\t\ttv1->vval.v_string = alloc((int)(len1 + STRLEN(s2) + 1));\n\t\tif (tv1->vval.v_string == NULL)\n\t\t{\n\t\t    clear_ppconst(ppconst);\n\t\t    return FAIL;\n\t\t}\n\t\tmch_memmove(tv1->vval.v_string, s1, len1);\n\t\tSTRCPY(tv1->vval.v_string + len1, s2);\n\t\tvim_free(s1);\n\t\tvim_free(s2);\n\t    }\n\t    --ppconst->pp_used;\n\t}\n\telse\n\t{\n\t    generate_ppconst(cctx, ppconst);\n\t    ppconst->pp_is_const = FALSE;\n\t    if (*op == '.')\n\t    {\n\t\tif (may_generate_2STRING(-2, FALSE, cctx) == FAIL\n\t\t\t|| may_generate_2STRING(-1, FALSE, cctx) == FAIL)\n\t\t    return FAIL;\n\t\tgenerate_instr_drop(cctx, ISN_CONCAT, 1);\n\t    }\n\t    else\n\t\tgenerate_two_op(cctx, op);\n\t}\n    }\n\n    return OK;\n}\n\n/*\n * expr5a == expr5b\n * expr5a =~ expr5b\n * expr5a != expr5b\n * expr5a !~ expr5b\n * expr5a > expr5b\n * expr5a >= expr5b\n * expr5a < expr5b\n * expr5a <= expr5b\n * expr5a is expr5b\n * expr5a isnot expr5b\n *\n * Produces instructions:\n *\tEVAL expr5a\t\tPush result of \"expr5a\"\n *\tEVAL expr5b\t\tPush result of \"expr5b\"\n *\tCOMPARE\t\t\tone of the compare instructions\n */\n    static int\ncompile_expr4(char_u **arg, cctx_T *cctx, ppconst_T *ppconst)\n{\n    exprtype_T\ttype = EXPR_UNKNOWN;\n    char_u\t*p;\n    char_u\t*next;\n    int\t\tlen = 2;\n    int\t\ttype_is = FALSE;\n    int\t\tppconst_used = ppconst->pp_used;\n\n    // get the first variable\n    if (compile_expr5(arg, cctx, ppconst) == FAIL)\n\treturn FAIL;\n\n    p = may_peek_next_line(cctx, *arg, &next);\n    type = get_compare_type(p, &len, &type_is);\n\n    /*\n     * If there is a comparative operator, use it.\n     */\n    if (type != EXPR_UNKNOWN)\n    {\n\tint ic = FALSE;  // Default: do not ignore case\n\n\tif (next != NULL)\n\t{\n\t    *arg = next_line_from_context(cctx, TRUE);\n\t    p = skipwhite(*arg);\n\t}\n\tif (type_is && (p[len] == '?' || p[len] == '#'))\n\t{\n\t    semsg(_(e_invalid_expression_str), *arg);\n\t    return FAIL;\n\t}\n\t// extra question mark appended: ignore case\n\tif (p[len] == '?')\n\t{\n\t    ic = TRUE;\n\t    ++len;\n\t}\n\t// extra '#' appended: match case (ignored)\n\telse if (p[len] == '#')\n\t    ++len;\n\t// nothing appended: match case\n\n\tif (!IS_WHITE_OR_NUL(**arg) || !IS_WHITE_OR_NUL(p[len]))\n\t{\n\t    error_white_both(p, len);\n\t    return FAIL;\n\t}\n\n\t// get the second variable\n\tif (may_get_next_line_error(p + len, arg, cctx) == FAIL)\n\t    return FAIL;\n\n\tif (compile_expr5(arg, cctx, ppconst) == FAIL)\n\t    return FAIL;\n\n\tif (ppconst->pp_used == ppconst_used + 2)\n\t{\n\t    typval_T *\ttv1 = &ppconst->pp_tv[ppconst->pp_used - 2];\n\t    typval_T\t*tv2 = &ppconst->pp_tv[ppconst->pp_used - 1];\n\t    int\t\tret;\n\n\t    // Both sides are a constant, compute the result now.\n\t    // First check for a valid combination of types, this is more\n\t    // strict than typval_compare().\n\t    if (check_compare_types(type, tv1, tv2) == FAIL)\n\t\tret = FAIL;\n\t    else\n\t    {\n\t\tret = typval_compare(tv1, tv2, type, ic);\n\t\ttv1->v_type = VAR_BOOL;\n\t\ttv1->vval.v_number = tv1->vval.v_number\n\t\t\t\t\t\t      ? VVAL_TRUE : VVAL_FALSE;\n\t\tclear_tv(tv2);\n\t\t--ppconst->pp_used;\n\t    }\n\t    return ret;\n\t}\n\n\tgenerate_ppconst(cctx, ppconst);\n\treturn generate_COMPARE(cctx, type, ic);\n    }\n\n    return OK;\n}\n\nstatic int compile_expr3(char_u **arg,  cctx_T *cctx, ppconst_T *ppconst);\n\n/*\n * Compile || or &&.\n */\n    static int\ncompile_and_or(\n\tchar_u **arg,\n\tcctx_T\t*cctx,\n\tchar\t*op,\n\tppconst_T *ppconst,\n\tint\tppconst_used UNUSED)\n{\n    char_u\t*next;\n    char_u\t*p = may_peek_next_line(cctx, *arg, &next);\n    int\t\topchar = *op;\n\n    if (p[0] == opchar && p[1] == opchar)\n    {\n\tgarray_T\t*instr = &cctx->ctx_instr;\n\tgarray_T\tend_ga;\n\tint\t\tsave_skip = cctx->ctx_skip;\n\n\t/*\n\t * Repeat until there is no following \"||\" or \"&&\"\n\t */\n\tga_init2(&end_ga, sizeof(int), 10);\n\twhile (p[0] == opchar && p[1] == opchar)\n\t{\n\t    long\tstart_lnum = SOURCING_LNUM;\n\t    long\tsave_sourcing_lnum;\n\t    int\t\tstart_ctx_lnum = cctx->ctx_lnum;\n\t    int\t\tsave_lnum;\n\t    int\t\tconst_used;\n\t    int\t\tstatus;\n\t    jumpwhen_T\tjump_when = opchar == '|'\n\t\t\t\t      ? JUMP_IF_COND_TRUE : JUMP_IF_COND_FALSE;\n\n\t    if (next != NULL)\n\t    {\n\t\t*arg = next_line_from_context(cctx, TRUE);\n\t\tp = skipwhite(*arg);\n\t    }\n\n\t    if (!IS_WHITE_OR_NUL(**arg) || !IS_WHITE_OR_NUL(p[2]))\n\t    {\n\t\tsemsg(_(e_white_space_required_before_and_after_str_at_str),\n\t\t\t\t\t\t\t\t\top, p);\n\t\tga_clear(&end_ga);\n\t\treturn FAIL;\n\t    }\n\n\t    save_sourcing_lnum = SOURCING_LNUM;\n\t    SOURCING_LNUM = start_lnum;\n\t    save_lnum = cctx->ctx_lnum;\n\t    cctx->ctx_lnum = start_ctx_lnum;\n\n\t    status = check_ppconst_bool(ppconst);\n\t    if (status != FAIL)\n\t    {\n\t\t// Use the last ppconst if possible.\n\t\tif (ppconst->pp_used > 0)\n\t\t{\n\t\t    typval_T\t*tv = &ppconst->pp_tv[ppconst->pp_used - 1];\n\t\t    int\t\tis_true = tv2bool(tv);\n\n\t\t    if ((is_true && opchar == '|')\n\t\t\t\t\t\t|| (!is_true && opchar == '&'))\n\t\t    {\n\t\t\t// For \"false && expr\" and \"true || expr\" the \"expr\"\n\t\t\t// does not need to be evaluated.\n\t\t\tcctx->ctx_skip = SKIP_YES;\n\t\t\tclear_tv(tv);\n\t\t\ttv->v_type = VAR_BOOL;\n\t\t\ttv->vval.v_number = is_true ? VVAL_TRUE : VVAL_FALSE;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t// For \"true && expr\" and \"false || expr\" only \"expr\"\n\t\t\t// needs to be evaluated.\n\t\t\t--ppconst->pp_used;\n\t\t\tjump_when = JUMP_NEVER;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    // Every part must evaluate to a bool.\n\t\t    status = bool_on_stack(cctx);\n\t\t}\n\t    }\n\t    if (status != FAIL)\n\t\tstatus = ga_grow(&end_ga, 1);\n\t    cctx->ctx_lnum = save_lnum;\n\t    if (status == FAIL)\n\t    {\n\t\tga_clear(&end_ga);\n\t\treturn FAIL;\n\t    }\n\n\t    if (jump_when != JUMP_NEVER)\n\t    {\n\t\tif (cctx->ctx_skip != SKIP_YES)\n\t\t{\n\t\t    *(((int *)end_ga.ga_data) + end_ga.ga_len) = instr->ga_len;\n\t\t    ++end_ga.ga_len;\n\t\t}\n\t\tgenerate_JUMP(cctx, jump_when, 0);\n\t    }\n\n\t    // eval the next expression\n\t    SOURCING_LNUM = save_sourcing_lnum;\n\t    if (may_get_next_line_error(p + 2, arg, cctx) == FAIL)\n\t    {\n\t\tga_clear(&end_ga);\n\t\treturn FAIL;\n\t    }\n\n\t    const_used = ppconst->pp_used;\n\t    if ((opchar == '|' ? compile_expr3(arg, cctx, ppconst)\n\t\t\t\t  : compile_expr4(arg, cctx, ppconst)) == FAIL)\n\t    {\n\t\tga_clear(&end_ga);\n\t\treturn FAIL;\n\t    }\n\n\t    // \"0 || 1\" results in true, \"1 && 0\" results in false.\n\t    if (ppconst->pp_used == const_used + 1)\n\t    {\n\t\ttypval_T\t*tv = &ppconst->pp_tv[ppconst->pp_used - 1];\n\n\t\tif (tv->v_type == VAR_NUMBER\n\t\t\t && (tv->vval.v_number == 1 || tv->vval.v_number == 0))\n\t\t{\n\t\t    tv->vval.v_number = tv->vval.v_number == 1\n\t\t\t\t\t\t      ? VVAL_TRUE : VVAL_FALSE;\n\t\t    tv->v_type = VAR_BOOL;\n\t\t}\n\t    }\n\n\t    p = may_peek_next_line(cctx, *arg, &next);\n\t}\n\n\tif (check_ppconst_bool(ppconst) == FAIL)\n\t{\n\t    ga_clear(&end_ga);\n\t    return FAIL;\n\t}\n\n\tif (cctx->ctx_skip != SKIP_YES && ppconst->pp_used == 0)\n\t    // Every part must evaluate to a bool.\n\t    if (bool_on_stack(cctx) == FAIL)\n\t    {\n\t\tga_clear(&end_ga);\n\t\treturn FAIL;\n\t    }\n\n\tif (end_ga.ga_len > 0)\n\t{\n\t    // Fill in the end label in all jumps.\n\t    generate_ppconst(cctx, ppconst);\n\t    while (end_ga.ga_len > 0)\n\t    {\n\t\tisn_T\t*isn;\n\n\t\t--end_ga.ga_len;\n\t\tisn = ((isn_T *)instr->ga_data)\n\t\t\t\t  + *(((int *)end_ga.ga_data) + end_ga.ga_len);\n\t\tisn->isn_arg.jump.jump_where = instr->ga_len;\n\t    }\n\t}\n\tga_clear(&end_ga);\n\n\tcctx->ctx_skip = save_skip;\n    }\n\n    return OK;\n}\n\n/*\n * expr4a && expr4a && expr4a\t    logical AND\n *\n * Produces instructions:\n *\tEVAL expr4a\t\tPush result of \"expr4a\"\n *\tCOND2BOOL\t\tconvert to bool if needed\n *\tJUMP_IF_COND_FALSE end\n *\tEVAL expr4b\t\tPush result of \"expr4b\"\n *\tJUMP_IF_COND_FALSE end\n *\tEVAL expr4c\t\tPush result of \"expr4c\"\n * end:\n */\n    static int\ncompile_expr3(char_u **arg, cctx_T *cctx, ppconst_T *ppconst)\n{\n    int\t\tppconst_used = ppconst->pp_used;\n\n    // get the first variable\n    if (compile_expr4(arg, cctx, ppconst) == FAIL)\n\treturn FAIL;\n\n    // || and && work almost the same\n    return compile_and_or(arg, cctx, \"&&\", ppconst, ppconst_used);\n}\n\n/*\n * expr3a || expr3b || expr3c\t    logical OR\n *\n * Produces instructions:\n *\tEVAL expr3a\t\tPush result of \"expr3a\"\n *\tCOND2BOOL\t\tconvert to bool if needed\n *\tJUMP_IF_COND_TRUE end\n *\tEVAL expr3b\t\tPush result of \"expr3b\"\n *\tJUMP_IF_COND_TRUE end\n *\tEVAL expr3c\t\tPush result of \"expr3c\"\n * end:\n */\n    static int\ncompile_expr2(char_u **arg, cctx_T *cctx, ppconst_T *ppconst)\n{\n    int\t\tppconst_used = ppconst->pp_used;\n\n    // eval the first expression\n    if (compile_expr3(arg, cctx, ppconst) == FAIL)\n\treturn FAIL;\n\n    // || and && work almost the same\n    return compile_and_or(arg, cctx, \"||\", ppconst, ppconst_used);\n}\n\n/*\n * Toplevel expression: expr2 ? expr1a : expr1b\n * Produces instructions:\n *\tEVAL expr2\t\tPush result of \"expr2\"\n *      JUMP_IF_FALSE alt\tjump if false\n *      EVAL expr1a\n *      JUMP_ALWAYS end\n * alt:\tEVAL expr1b\n * end:\n *\n * Toplevel expression: expr2 ?? expr1\n * Produces instructions:\n *\tEVAL expr2\t\t    Push result of \"expr2\"\n *      JUMP_AND_KEEP_IF_TRUE end   jump if true\n *      EVAL expr1\n * end:\n */\n    int\ncompile_expr1(char_u **arg, cctx_T *cctx, ppconst_T *ppconst)\n{\n    char_u\t*p;\n    int\t\tppconst_used = ppconst->pp_used;\n    char_u\t*next;\n\n    // Ignore all kinds of errors when not producing code.\n    if (cctx->ctx_skip == SKIP_YES)\n    {\n\tskip_expr_cctx(arg, cctx);\n\treturn OK;\n    }\n\n    // Evaluate the first expression.\n    if (compile_expr2(arg, cctx, ppconst) == FAIL)\n\treturn FAIL;\n\n    p = may_peek_next_line(cctx, *arg, &next);\n    if (*p == '?')\n    {\n\tint\t\top_falsy = p[1] == '?';\n\tgarray_T\t*instr = &cctx->ctx_instr;\n\tgarray_T\t*stack = &cctx->ctx_type_stack;\n\tint\t\talt_idx = instr->ga_len;\n\tint\t\tend_idx = 0;\n\tisn_T\t\t*isn;\n\ttype_T\t\t*type1 = NULL;\n\tint\t\thas_const_expr = FALSE;\n\tint\t\tconst_value = FALSE;\n\tint\t\tsave_skip = cctx->ctx_skip;\n\n\tif (next != NULL)\n\t{\n\t    *arg = next_line_from_context(cctx, TRUE);\n\t    p = skipwhite(*arg);\n\t}\n\n\tif (!IS_WHITE_OR_NUL(**arg) || !IS_WHITE_OR_NUL(p[1 + op_falsy]))\n\t{\n\t    semsg(_(e_white_space_required_before_and_after_str_at_str),\n\t\t\t\t\t\t     op_falsy ? \"??\" : \"?\", p);\n\t    return FAIL;\n\t}\n\n\tif (ppconst->pp_used == ppconst_used + 1)\n\t{\n\t    // the condition is a constant, we know whether the ? or the :\n\t    // expression is to be evaluated.\n\t    has_const_expr = TRUE;\n\t    if (op_falsy)\n\t\tconst_value = tv2bool(&ppconst->pp_tv[ppconst_used]);\n\t    else\n\t    {\n\t\tint error = FALSE;\n\n\t\tconst_value = tv_get_bool_chk(&ppconst->pp_tv[ppconst_used],\n\t\t\t\t\t\t\t\t       &error);\n\t\tif (error)\n\t\t    return FAIL;\n\t    }\n\t    cctx->ctx_skip = save_skip == SKIP_YES ||\n\t\t (op_falsy ? const_value : !const_value) ? SKIP_YES : SKIP_NOT;\n\n\t    if (op_falsy && cctx->ctx_skip == SKIP_YES)\n\t\t// \"left ?? right\" and \"left\" is truthy: produce \"left\"\n\t\tgenerate_ppconst(cctx, ppconst);\n\t    else\n\t    {\n\t\tclear_tv(&ppconst->pp_tv[ppconst_used]);\n\t\t--ppconst->pp_used;\n\t    }\n\t}\n\telse\n\t{\n\t    generate_ppconst(cctx, ppconst);\n\t    if (op_falsy)\n\t\tend_idx = instr->ga_len;\n\t    generate_JUMP(cctx, op_falsy\n\t\t\t\t   ? JUMP_AND_KEEP_IF_TRUE : JUMP_IF_FALSE, 0);\n\t    if (op_falsy)\n\t\ttype1 = get_type_on_stack(cctx, -1);\n\t}\n\n\t// evaluate the second expression; any type is accepted\n\tif (may_get_next_line_error(p + 1 + op_falsy, arg, cctx) == FAIL)\n\t    return FAIL;\n\tif (compile_expr1(arg, cctx, ppconst) == FAIL)\n\t    return FAIL;\n\n\tif (!has_const_expr)\n\t{\n\t    generate_ppconst(cctx, ppconst);\n\n\t    if (!op_falsy)\n\t    {\n\t\t// remember the type and drop it\n\t\ttype1 = get_type_on_stack(cctx, 0);\n\t\t--stack->ga_len;\n\n\t\tend_idx = instr->ga_len;\n\t\tgenerate_JUMP(cctx, JUMP_ALWAYS, 0);\n\n\t\t// jump here from JUMP_IF_FALSE\n\t\tisn = ((isn_T *)instr->ga_data) + alt_idx;\n\t\tisn->isn_arg.jump.jump_where = instr->ga_len;\n\t    }\n\t}\n\n\tif (!op_falsy)\n\t{\n\t    // Check for the \":\".\n\t    p = may_peek_next_line(cctx, *arg, &next);\n\t    if (*p != ':')\n\t    {\n\t\temsg(_(e_missing_colon_after_questionmark));\n\t\treturn FAIL;\n\t    }\n\t    if (next != NULL)\n\t    {\n\t\t*arg = next_line_from_context(cctx, TRUE);\n\t\tp = skipwhite(*arg);\n\t    }\n\n\t    if (!IS_WHITE_OR_NUL(**arg) || !IS_WHITE_OR_NUL(p[1]))\n\t    {\n\t\tsemsg(_(e_white_space_required_before_and_after_str_at_str),\n\t\t\t\t\t\t\t\t       \":\", p);\n\t\treturn FAIL;\n\t    }\n\n\t    // evaluate the third expression\n\t    if (has_const_expr)\n\t\tcctx->ctx_skip = save_skip == SKIP_YES || const_value\n\t\t\t\t\t\t\t ? SKIP_YES : SKIP_NOT;\n\t    if (may_get_next_line_error(p + 1, arg, cctx) == FAIL)\n\t\treturn FAIL;\n\t    if (compile_expr1(arg, cctx, ppconst) == FAIL)\n\t\treturn FAIL;\n\t}\n\n\tif (!has_const_expr)\n\t{\n\t    type_T\t**typep;\n\n\t    generate_ppconst(cctx, ppconst);\n\t    ppconst->pp_is_const = FALSE;\n\n\t    // If the types differ, the result has a more generic type.\n\t    typep = &((((type2_T *)stack->ga_data)\n\t\t\t\t\t      + stack->ga_len - 1)->type_curr);\n\t    common_type(type1, *typep, typep, cctx->ctx_type_list);\n\n\t    // jump here from JUMP_ALWAYS or JUMP_AND_KEEP_IF_TRUE\n\t    isn = ((isn_T *)instr->ga_data) + end_idx;\n\t    isn->isn_arg.jump.jump_where = instr->ga_len;\n\t}\n\n\tcctx->ctx_skip = save_skip;\n    }\n    return OK;\n}\n\n/*\n * Toplevel expression.\n * Sets \"is_const\" (if not NULL) to indicate the value is a constant.\n * Returns OK or FAIL.\n */\n    int\ncompile_expr0_ext(char_u **arg,  cctx_T *cctx, int *is_const)\n{\n    ppconst_T\tppconst;\n\n    CLEAR_FIELD(ppconst);\n    if (compile_expr1(arg, cctx, &ppconst) == FAIL)\n    {\n\tclear_ppconst(&ppconst);\n\treturn FAIL;\n    }\n    if (is_const != NULL)\n\t*is_const = ppconst.pp_used > 0 || ppconst.pp_is_const;\n    if (generate_ppconst(cctx, &ppconst) == FAIL)\n\treturn FAIL;\n    return OK;\n}\n\n/*\n * Toplevel expression.\n */\n    int\ncompile_expr0(char_u **arg,  cctx_T *cctx)\n{\n    return compile_expr0_ext(arg, cctx, NULL);\n}\n\n\n#endif // defined(FEAT_EVAL)\n"], "fixing_code": ["\" Tests for Vim9 script expressions\n\nsource check.vim\nsource vim9.vim\n\nlet g:cond = v:false\ndef FuncOne(arg: number): string\n  return 'yes'\nenddef\ndef FuncTwo(arg: number): number\n  return 123\nenddef\n\n\" test cond ? expr : expr\ndef Test_expr1_trinary()\n  var lines =<< trim END\n      assert_equal('one', true ? 'one' : 'two')\n      assert_equal('one', 1 ?\n                            'one' :\n                            'two')\n      if has('float')\n        assert_equal('one', !!0.1 ? 'one' : 'two')\n      endif\n      assert_equal('one', !!'x' ? 'one' : 'two')\n      assert_equal('one', !!'x'\n                            ? 'one'\n                            : 'two')\n      assert_equal('one', !!0z1234 ? 'one' : 'two')\n      assert_equal('one', !![0] ? 'one' : 'two')\n      assert_equal('one', !!{x: 0} ? 'one' : 'two')\n      var name = 1\n      assert_equal('one', name ? 'one' : 'two')\n\n      assert_equal('two', false ? 'one' : 'two')\n      assert_equal('two', 0 ? 'one' : 'two')\n      if has('float')\n        assert_equal('two', !!0.0 ? 'one' : 'two')\n      endif\n      assert_equal('two', !!'' ? 'one' : 'two')\n      assert_equal('two', !!0z ? 'one' : 'two')\n      assert_equal('two', !![] ? 'one' : 'two')\n      assert_equal('two', !!{} ? 'one' : 'two')\n      name = 0\n      assert_equal('two', name ? 'one' : 'two')\n\n      echo ['a'] + (1 ? ['b'] : ['c']\n                )\n      echo ['a'] + (1 ? ['b'] : ['c'] # comment\n                )\n\n      # with constant condition expression is not evaluated \n      assert_equal('one', 1 ? 'one' : xxx)\n\n      var Some: func = function('len')\n      var Other: func = function('winnr')\n      var Res: func = g:atrue ? Some : Other\n      assert_equal(function('len'), Res)\n\n      var RetOne: func(string): number = function('len')\n      var RetTwo: func(string): number = function('charcol')\n      var RetThat: func = g:atrue ? RetOne : RetTwo\n      assert_equal(function('len'), RetThat)\n\n      var X = FuncOne\n      var Y = FuncTwo\n      var Z = g:cond ? FuncOne : FuncTwo\n      assert_equal(123, Z(3))\n  END\n  CheckDefAndScriptSuccess(lines)\nenddef\n\ndef Test_expr1_trinary_vimscript()\n  # check line continuation\n  var lines =<< trim END\n      var name = 1\n      \t\t? 'yes'\n\t\t: 'no'\n      assert_equal('yes', name)\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  lines =<< trim END\n      var name = v:false\n      \t\t? 'yes'\n\t\t: 'no'\n      assert_equal('no', name)\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  lines =<< trim END\n      var name = v:false ?\n      \t\t'yes' :\n\t\t'no'\n      assert_equal('no', name)\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  lines =<< trim END\n      var name = v:false ?  # comment\n      \t\t'yes' :\n                # comment\n\t\t'no' # comment\n      assert_equal('no', name)\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  # check white space\n  lines =<< trim END\n      var name = v:true?1:2\n  END\n  CheckDefAndScriptFailure(lines, 'E1004: White space required before and after ''?'' at \"?1:2\"', 1)\n\n  lines =<< trim END\n      var name = v:true? 1 : 2\n  END\n  CheckDefAndScriptFailure(lines, 'E1004:', 1)\n\n  lines =<< trim END\n      var name = v:true ?1 : 2\n  END\n  CheckDefAndScriptFailure(lines, 'E1004:', 1)\n\n  lines =<< trim END\n      var name = v:true ? 1: 2\n  END\n  CheckDefAndScriptFailure(lines, 'E1004: White space required before and after '':'' at \": 2\"', 1)\n\n  lines =<< trim END\n      var name = v:true ? 1 :2\n  END\n  CheckDefAndScriptFailure(lines, 'E1004:', 1)\n\n  lines =<< trim END\n      var name = 'x' ? 1 : 2\n  END\n  CheckDefAndScriptFailure(lines, 'E1135:', 1)\n\n  lines =<< trim END\n      var name = [] ? 1 : 2\n  END\n  CheckDefExecAndScriptFailure(lines, 'E745:', 1)\n\n  lines =<< trim END\n      var name = {} ? 1 : 2\n  END\n  CheckDefExecAndScriptFailure(lines, 'E728:', 1)\n\n  # check after failure eval_flags is reset\n  lines =<< trim END\n      try\n        eval('0 ? 1: 2')\n      catch\n      endtry\n      assert_equal(v:true, eval(string(v:true)))\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  lines =<< trim END\n      try\n        eval('0 ? 1 :2')\n      catch\n      endtry\n      assert_equal(v:true, eval(string(v:true)))\n  END\n  CheckDefAndScriptSuccess(lines)\nenddef\n\nfunc Test_expr1_trinary_fails()\n  call CheckDefAndScriptFailure([\"var x = 1 ? 'one'\"], \"Missing ':' after '?'\", 1)\n\n  let msg = \"White space required before and after '?'\"\n  call CheckDefAndScriptFailure([\"var x = 1? 'one' : 'two'\"], msg, 1)\n  call CheckDefAndScriptFailure([\"var x = 1 ?'one' : 'two'\"], msg, 1)\n  call CheckDefAndScriptFailure([\"var x = 1?'one' : 'two'\"], msg, 1)\n  let lines =<< trim END\n    var x = 1\n     ?'one' : 'two'\n     # comment\n  END\n  call CheckDefAndScriptFailure(lines, 'E1004: White space required before and after ''?'' at \"?''one'' : ''two''\"', 2)\n\n  let msg = \"White space required before and after ':'\"\n  call CheckDefAndScriptFailure([\"var x = 1 ? 'one': 'two'\"], msg, 1)\n  call CheckDefAndScriptFailure([\"var x = 1 ? 'one' :'two'\"], msg, 1)\n  call CheckDefAndScriptFailure([\"var x = 1 ? 'one':'two'\"], msg, 1)\n  let lines =<< trim END\n    var x = 1 ? 'one'\n          :'two'\n          # Comment\n  END\n  call CheckDefAndScriptFailure(lines, 'E1004: White space required before and after '':'' at \":''two''\"', 2)\n\n  call CheckDefAndScriptFailure([\"var x = 'x' ? 'one' : 'two'\"], 'E1135:', 1)\n  call CheckDefAndScriptFailure([\"var x = 0z1234 ? 'one' : 'two'\"], 'E974:', 1)\n  call CheckDefExecAndScriptFailure([\"var x = [] ? 'one' : 'two'\"], 'E745:', 1)\n  call CheckDefExecAndScriptFailure([\"var x = {} ? 'one' : 'two'\"], 'E728:', 1)\n\n  call CheckDefExecFailure([\"var x = false ? \"], 'E1097:', 3)\n  call CheckScriptFailure(['vim9script', \"var x = false ? \"], 'E15:', 2)\n  call CheckDefExecFailure([\"var x = false ? 'one' : \"], 'E1097:', 3)\n  call CheckScriptFailure(['vim9script', \"var x = false ? 'one' : \"], 'E15:', 2)\n\n  call CheckDefExecAndScriptFailure([\"var x = true ? xxx : 'foo'\"], ['E1001:', 'E121:'], 1)\n  call CheckDefExecAndScriptFailure([\"var x = false ? 'foo' : xxx\"], ['E1001:', 'E121:'], 1)\n\n  if has('float')\n    call CheckDefAndScriptFailure([\"var x = 0.1 ? 'one' : 'two'\"], 'E805:', 1)\n  endif\n\n  \" missing argument detected even when common type is used\n  call CheckDefAndScriptFailure([\n\t\\ 'var X = FuncOne',\n\t\\ 'var Y = FuncTwo',\n\t\\ 'var Z = g:cond ? FuncOne : FuncTwo',\n\t\\ 'Z()'], 'E119:', 4)\nendfunc\n\ndef Test_expr1_falsy()\n  var lines =<< trim END\n      assert_equal(v:true, v:true ?? 456)\n      assert_equal(123, 123 ?? 456)\n      assert_equal('yes', 'yes' ?? 456)\n      assert_equal([1], [1] ?? 456)\n      assert_equal({one: 1}, {one: 1} ?? 456)\n      if has('float')\n        assert_equal(0.1, 0.1 ?? 456)\n      endif\n\n      assert_equal(456, v:false ?? 456)\n      assert_equal(456, 0 ?? 456)\n      assert_equal(456, '' ?? 456)\n      assert_equal(456, [] ?? 456)\n      assert_equal(456, {} ?? 456)\n      if has('float')\n        assert_equal(456, 0.0 ?? 456)\n      endif\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  var msg = \"White space required before and after '??'\"\n  call CheckDefAndScriptFailure([\"var x = 1?? 'one' : 'two'\"], msg, 1)\n  call CheckDefAndScriptFailure([\"var x = 1 ??'one' : 'two'\"], msg, 1)\n  call CheckDefAndScriptFailure([\"var x = 1??'one' : 'two'\"], msg, 1)\n  lines =<< trim END\n    var x = 1\n      ??'one' : 'two'\n      #comment\n  END\n  CheckDefAndScriptFailure(lines, 'E1004: White space required before and after ''??'' at \"??''one'' : ''two''\"', 2)\nenddef\n\ndef Record(val: any): any\n  g:vals->add(val)\n  return val\nenddef\n\n\" test ||\ndef Test_expr2()\n  var lines =<< trim END\n      assert_equal(true, 1 || 0)\n      assert_equal(true, 0 ||\n                        0 ||\n                        1)\n      assert_equal(true, 0 ||\n\t\t\t0 ||\n\t\t\t!!7)\n      assert_equal(false, 0 || 0)\n      assert_equal(false, 0\n                        || 0)\n      assert_equal(false, 0 || false)\n\n      g:vals = []\n      assert_equal(true, Record(1) || Record(3))\n      assert_equal([1], g:vals)\n\n      g:vals = []\n      assert_equal(true, Record(0) || Record(1))\n      assert_equal([0, 1], g:vals)\n\n      g:vals = []\n      assert_equal(true, Record(0) || Record(true))\n      assert_equal([0, true], g:vals)\n\n      g:vals = []\n      assert_equal(true, Record(0)\n                          || Record(1)\n                          || Record(0))\n      assert_equal([0, 1], g:vals)\n\n      g:vals = []\n      assert_equal(true, Record(0)\n\t\t\t  || Record(true)\n\t\t\t  || Record(0))\n      assert_equal([0, true], g:vals)\n\n      g:vals = []\n      assert_equal(true, Record(true) || Record(false))\n      assert_equal([true], g:vals)\n\n      g:vals = []\n      assert_equal(false, Record(0) || Record(false) || Record(0))\n      assert_equal([0, false, 0], g:vals)\n\n      g:vals = []\n      var x = 1\n      if x || true\n        g:vals = [1]\n      endif\n      assert_equal([1], g:vals)\n\n      g:vals = []\n      x = 3\n      if true || x\n        g:vals = [1]\n      endif\n      assert_equal([1], g:vals)\n  END\n  CheckDefAndScriptSuccess(lines)\nenddef\n\ndef Test_expr2_vimscript()\n  # check line continuation\n  var lines =<< trim END\n      var name = 0\n      \t\t|| 1\n      assert_equal(true, name)\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  lines =<< trim END\n      var name = v:false\n      \t\t|| v:true\n      \t\t|| v:false\n      assert_equal(v:true, name)\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  lines =<< trim END\n      var name = v:false ||\n      \t\tv:true ||\n\t\tv:false\n      assert_equal(v:true, name)\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  lines =<< trim END\n      var name = v:false || # comment\n                # comment\n      \t\tv:true ||\n                # comment\n\t\tv:false # comment\n      assert_equal(v:true, name)\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  # check white space\n  lines =<< trim END\n      var name = v:true||v:true\n  END\n  CheckDefExecAndScriptFailure(lines, 'E1004: White space required before and after ''||'' at \"||v:true\"', 1)\n\n  lines =<< trim END\n      var name = v:true ||v:true\n  END\n  CheckDefAndScriptFailure(lines, 'E1004:', 1)\n\n  lines =<< trim END\n      var name = v:true|| v:true\n  END\n  CheckDefAndScriptFailure(lines, 'E1004:', 1)\nenddef\n\ndef Test_expr2_fails()\n  var msg = \"White space required before and after '||'\"\n  call CheckDefAndScriptFailure([\"var x = 1||0\"], msg, 1)\n  call CheckDefAndScriptFailure([\"var x = 1 ||0\"], msg, 1)\n  call CheckDefAndScriptFailure([\"var x = 1|| 0\"], msg, 1)\n\n  call CheckDefFailure([\"var x = false || \"], 'E1097:', 3)\n  call CheckScriptFailure(['vim9script', \"var x = false || \"], 'E15:', 2)\n\n  # script does not fail, the second expression is skipped\n  call CheckDefFailure([\"var x = 1 || xxx\"], 'E1001:', 1)\n\n  call CheckDefAndScriptFailure([\"var x = [] || false\"], ['E1012:', 'E745:'], 1)\n\n  call CheckDefAndScriptFailure([\"if 'yes' || 0\", 'echo 0', 'endif'], ['E1012: Type mismatch; expected bool but got string', 'E1135: Using a String as a Bool'], 1)\n\n  call CheckDefAndScriptFailure([\"var x = 3 || false\"], ['E1012:', 'E1023:'], 1)\n  call CheckDefAndScriptFailure([\"var x = false || 3\"], ['E1012:', 'E1023:'], 1)\n\n  call CheckDefAndScriptFailure([\"if 3\"], 'E1023:', 1)\n  call CheckDefExecAndScriptFailure(['var x = 3', 'if x', 'endif'], 'E1023:', 2)\n\n  call CheckDefAndScriptFailure([\"var x = [] || false\"], ['E1012: Type mismatch; expected bool but got list<unknown>', 'E745:'], 1)\n\n  var lines =<< trim END\n    vim9script\n    echo false\n      ||true\n    # comment\n  END\n  CheckScriptFailure(lines, 'E1004: White space required before and after ''||'' at \"||true\"', 3)\n\n  lines =<< trim END\n      var x = false\n              || false\n              || a.b\n  END\n  CheckDefFailure(lines, 'E1001:', 3)\nenddef\n\n\" test &&\ndef Test_expr3()\n  var lines =<< trim END\n      assert_equal(false, 1 && 0)\n      assert_equal(false, 0 &&\n                    0 &&\n                    1)\n      assert_equal(true, 1\n                        && true\n                        && 1)\n      assert_equal(false, 0 && 0)\n      assert_equal(false, 0 && false)\n      assert_equal(true, 1 && true)\n\n      g:vals = []\n      assert_equal(true, Record(true) && Record(1))\n      assert_equal([true, 1], g:vals)\n\n      g:vals = []\n      assert_equal(true, Record(1) && Record(true))\n      assert_equal([1, true], g:vals)\n\n      g:vals = []\n      assert_equal(false, Record(0) && Record(1))\n      assert_equal([0], g:vals)\n\n      g:vals = []\n      assert_equal(false, Record(0) && Record(1) && Record(0))\n      assert_equal([0], g:vals)\n\n      g:vals = []\n      assert_equal(false, Record(0) && Record(4) && Record(0))\n      assert_equal([0], g:vals)\n\n      g:vals = []\n      assert_equal(false, Record(1) && Record(true) && Record(0))\n      assert_equal([1, true, 0], g:vals)\n  END\n  CheckDefAndScriptSuccess(lines)\nenddef\n\ndef Test_expr3_vimscript()\n  # check line continuation\n  var lines =<< trim END\n      var name = 0\n      \t\t&& 1\n      assert_equal(false, name)\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  lines =<< trim END\n      var name = v:true\n      \t\t&& v:true\n      \t\t&& v:true\n      assert_equal(v:true, name)\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  lines =<< trim END\n      var name = v:true &&\n      \t\tv:true &&\n      \t\tv:true\n      assert_equal(v:true, name)\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  lines =<< trim END\n      var name = v:true &&  # comment\n                # comment\n      \t\tv:true &&\n                # comment\n      \t\tv:true\n      assert_equal(v:true, name)\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  # check white space\n  lines =<< trim END\n      var name = v:true&&v:true\n  END\n  CheckDefAndScriptFailure(lines, 'E1004:', 1)\n\n  lines =<< trim END\n      var name = v:true &&v:true\n  END\n  CheckDefAndScriptFailure(lines, 'E1004: White space required before and after ''&&'' at \"&&v:true\"', 1)\n\n  lines =<< trim END\n      var name = v:true&& v:true\n  END\n  CheckDefAndScriptFailure(lines, 'E1004:', 1)\nenddef\n\ndef Test_expr3_fails()\n  var msg = \"White space required before and after '&&'\"\n  CheckDefAndScriptFailure([\"var x = 1&&0\"], msg, 1)\n  CheckDefAndScriptFailure([\"var x = 1 &&0\"], msg, 1)\n  CheckDefAndScriptFailure([\"var x = 1&& 0\"], msg, 1)\n  var lines =<< trim END\n    var x = 1\n      &&0\n    # comment\n  END\n  CheckDefAndScriptFailure(lines, 'E1004: White space required before and after ''&&'' at \"&&0\"', 2)\n\n  g:vals = []\n  CheckDefAndScriptFailure([\"if 'yes' && 0\", 'echo 0', 'endif'], ['E1012: Type mismatch; expected bool but got string', 'E1135: Using a String as a Bool'], 1)\n\n  CheckDefExecAndScriptFailure(['assert_equal(false, Record(1) && Record(4) && Record(0))'], 'E1023: Using a Number as a Bool: 4', 1)\n\n  lines =<< trim END\n      if 3\n          && true\n      endif\n  END\n  CheckDefAndScriptFailure(lines, ['E1012:', 'E1023:'], 1)\n\n  lines =<< trim END\n      if true\n          && 3\n      endif\n  END\n  CheckDefAndScriptFailure(lines, ['E1012:', 'E1023:'], 2)\n\n  lines =<< trim END\n      if 'yes'\n          && true\n      endif\n  END\n  CheckDefAndScriptFailure(lines, ['E1012:', 'E1135: Using a String as a Bool'], 1)\nenddef\n\n\" global variables to use for tests with the \"any\" type\nlet atrue = v:true\nlet afalse = v:false\nlet anone = v:none\nlet anull = v:null\nlet anint = 10\nlet theone = 1\nlet thefour = 4\nif has('float')\n  let afloat = 0.1\nendif\nlet astring = 'asdf'\nlet ablob = 0z01ab\nlet alist = [2, 3, 4]\nlet adict = #{aaa: 2, bbb: 8}\n\n\" test == comperator\ndef Test_expr4_equal()\n  var lines =<< trim END\n      var trueVar = true\n      var falseVar = false\n      assert_equal(true, true == true)\n      assert_equal(false, true ==\n                            false)\n      assert_equal(true, true\n                            == trueVar)\n      assert_equal(false, true == falseVar)\n      assert_equal(true, true == g:atrue)\n      assert_equal(false, g:atrue == false)\n\n      assert_equal(true, v:none == v:none)\n      assert_equal(false, v:none == v:null)\n      assert_equal(true, g:anone == v:none)\n      assert_equal(true, null == v:null)\n      assert_equal(true, null == g:anull)\n      assert_equal(false, v:none == g:anull)\n\n      var nr0 = 0\n      var nr61 = 61\n      assert_equal(false, 2 == 0)\n      assert_equal(false, 2 == nr0)\n      assert_equal(true, 61 == 61)\n      assert_equal(true, 61 == nr61)\n      assert_equal(true, g:anint == 10)\n      assert_equal(false, 61 == g:anint)\n\n      if has('float')\n        var ff = 0.3\n        assert_equal(true, ff == 0.3)\n        assert_equal(false, 0.4 == ff)\n        assert_equal(true, 0.1 == g:afloat)\n        assert_equal(false, g:afloat == 0.3)\n\n        ff = 3.0\n        assert_equal(true, ff == 3)\n        assert_equal(true, 3 == ff)\n        ff = 3.1\n        assert_equal(false, ff == 3)\n        assert_equal(false, 3 == ff)\n      endif\n\n      assert_equal(true, 'abc' == 'abc')\n      assert_equal(false, 'xyz' == 'abc')\n      assert_equal(true, g:astring == 'asdf')\n      assert_equal(false, 'xyz' == g:astring)\n\n      assert_equal(false, 'abc' == 'aBc')\n      assert_equal(false, 'abc' ==# 'aBc')\n      assert_equal(true, 'abc' ==? 'aBc')\n\n      assert_equal(false, 'abc' == 'ABC')\n      set ignorecase\n      assert_equal(false, 'abc' == 'ABC')\n      assert_equal(false, 'abc' ==# 'ABC')\n      assert_equal(true, 'abc' ==? 'ABC')\n      set noignorecase\n\n      var bb = 0z3f\n      assert_equal(true, 0z3f == bb)\n      assert_equal(false, bb == 0z4f)\n      assert_equal(true, g:ablob == 0z01ab)\n      assert_equal(false, 0z3f == g:ablob)\n\n      assert_equal(true, [1, 2, 3] == [1, 2, 3])\n      assert_equal(false, [1, 2, 3] == [2, 3, 1])\n      assert_equal(true, [2, 3, 4] == g:alist)\n      assert_equal(false, g:alist == [2, 3, 1])\n      assert_equal(false, [1, 2, 3] == [])\n      assert_equal(false, [1, 2, 3] == ['1', '2', '3'])\n\n      assert_equal(true, {one: 1, two: 2} == {one: 1, two: 2})\n      assert_equal(false, {one: 1, two: 2} == {one: 2, two: 2})\n      assert_equal(false, {one: 1, two: 2} == {two: 2})\n      assert_equal(false, {one: 1, two: 2} == {})\n      assert_equal(true, g:adict == {bbb: 8, aaa: 2})\n      assert_equal(false, {ccc: 9, aaa: 2} == g:adict)\n\n      assert_equal(true, function('g:Test_expr4_equal') == function('g:Test_expr4_equal'))\n      assert_equal(false, function('g:Test_expr4_equal') == function('g:Test_expr4_is'))\n\n      assert_equal(true, function('g:Test_expr4_equal', [123]) == function('g:Test_expr4_equal', [123]))\n      assert_equal(false, function('g:Test_expr4_equal', [123]) == function('g:Test_expr4_is', [123]))\n      assert_equal(false, function('g:Test_expr4_equal', [123]) == function('g:Test_expr4_equal', [999]))\n\n      if true\n        var OneFunc: func\n        var TwoFunc: func\n        OneFunc = function('len')\n        TwoFunc = function('len')\n        assert_equal(true, OneFunc('abc') == TwoFunc('123'))\n      endif\n\n      # check this doesn't fail when skipped\n      if false\n        var OneFunc: func\n        var TwoFunc: func\n        OneFunc = function('len')\n        TwoFunc = function('len')\n        assert_equal(true, OneFunc('abc') == TwoFunc('123'))\n      endif\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  CheckDefAndScriptFailure([\"var x = 'a' == xxx\"], ['E1001:', 'E121:'], 1)\n  CheckDefFailure([\"var x = 'a' == \"], 'E1097:', 3)\n  CheckScriptFailure(['vim9script', \"var x = 'a' == \"], 'E15:', 2)\n\n  CheckDefExecAndScriptFailure(['var items: any', 'eval 1 + 1', 'eval 2 + 2', 'if items == []', 'endif'], ['E691:', 'E1072:'], 4)\n\n  CheckDefExecAndScriptFailure(['var x: any = \"a\"', 'echo x == true'], 'E1072: Cannot compare string with bool', 2)\n  CheckDefExecAndScriptFailure([\"var x: any = true\", 'echo x == \"\"'], 'E1072: Cannot compare bool with string', 2)\n  CheckDefExecAndScriptFailure([\"var x: any = 99\", 'echo x == true'], ['E1138', 'E1072:'], 2)\n  CheckDefExecAndScriptFailure([\"var x: any = 'a'\", 'echo x == 99'], ['E1030:', 'E1072:'], 2)\n\n  lines =<< trim END\n      vim9script\n      var n: any = 2\n      def Compare()\n        eval n == '3'\n        g:notReached = false\n      enddef\n      g:notReached = true\n      Compare()\n  END\n  CheckScriptFailure(lines, 'E1030: Using a String as a Number: \"3\"')\n  assert_true(g:notReached)\n\n  if has('float')\n    lines =<< trim END\n        vim9script\n        var n: any = 2.2\n        def Compare()\n          eval n == '3'\n          g:notReached = false\n        enddef\n        g:notReached = true\n        Compare()\n    END\n    CheckScriptFailure(lines, 'E892: Using a String as a Float')\n    assert_true(g:notReached)\n  endif\n\n  unlet g:notReached\nenddef\n\ndef Test_expr4_wrong_type()\n  for op in ['>', '>=', '<', '<=', '=~', '!~']\n    CheckDefExecAndScriptFailure([\n        \"var a: any = 'a'\",\n        'var b: any = true',\n        'echo a ' .. op .. ' b'], 'E1072:', 3)\n  endfor\n  for op in ['>', '>=', '<', '<=']\n    CheckDefExecAndScriptFailure([\n        \"var n: any = 2\",\n        'echo n ' .. op .. ' \"3\"'], ['E1030:', 'E1072:'], 2)\n  endfor\n  for op in ['=~', '!~']\n    CheckDefExecAndScriptFailure([\n        \"var n: any = 2\",\n        'echo n ' .. op .. ' \"3\"'], 'E1072:', 2)\n  endfor\n\n  CheckDefAndScriptFailure([\n      'echo v:none == true'], 'E1072:', 1)\n  CheckDefAndScriptFailure([\n      'echo false >= true'], 'E1072:', 1)\n  CheckDefExecAndScriptFailure([\n      \"var n: any = v:none\",\n      'echo n == true'], 'E1072:', 2)\n  CheckDefExecAndScriptFailure([\n      \"var n: any = v:none\",\n      'echo n < true'], 'E1072:', 2)\nenddef\n\n\" test != comperator\ndef Test_expr4_notequal()\n  var lines =<< trim END\n      var trueVar = true\n      var falseVar = false\n      assert_equal(false, true != true)\n      assert_equal(true, true !=\n                            false)\n      assert_equal(false, true\n                            != trueVar)\n      assert_equal(true, true != falseVar)\n      assert_equal(false, true != g:atrue)\n      assert_equal(true, g:atrue != false)\n\n      assert_equal(false, v:none != v:none)\n      assert_equal(true, v:none != v:null)\n      assert_equal(false, g:anone != v:none)\n      assert_equal(true, v:none != g:anull)\n\n      var nr55 = 55\n      var nr0 = 55\n      assert_equal(true, 2 != 0)\n      assert_equal(true, 2 != nr0)\n      assert_equal(false, 55 != 55)\n      assert_equal(false, 55 != nr55)\n      assert_equal(false, g:anint != 10)\n      assert_equal(true, 61 != g:anint)\n\n      if has('float')\n        var ff = 0.3\n        assert_equal(false, 0.3 != ff)\n        assert_equal(true, 0.4 != ff)\n        assert_equal(false, 0.1 != g:afloat)\n        assert_equal(true, g:afloat != 0.3)\n\n        ff = 3.0\n        assert_equal(false, ff != 3)\n        assert_equal(false, 3 != ff)\n        ff = 3.1\n        assert_equal(true, ff != 3)\n        assert_equal(true, 3 != ff)\n      endif\n\n      assert_equal(false, 'abc' != 'abc')\n      assert_equal(true, 'xyz' != 'abc')\n      assert_equal(false, g:astring != 'asdf')\n      assert_equal(true, 'xyz' != g:astring)\n\n      assert_equal(true, 'abc' != 'ABC')\n      set ignorecase\n      assert_equal(true, 'abc' != 'ABC')\n      assert_equal(true, 'abc' !=# 'ABC')\n      assert_equal(false, 'abc' !=? 'ABC')\n      set noignorecase\n\n      var bb = 0z3f\n      assert_equal(false, 0z3f != bb)\n      assert_equal(true, bb != 0z4f)\n      assert_equal(false, g:ablob != 0z01ab)\n      assert_equal(true, 0z3f != g:ablob)\n\n      assert_equal(false, [1, 2, 3] != [1, 2, 3])\n      assert_equal(true, [1, 2, 3] != [2, 3, 1])\n      assert_equal(false, [2, 3, 4] != g:alist)\n      assert_equal(true, g:alist != [2, 3, 1])\n      assert_equal(true, [1, 2, 3] != [])\n      assert_equal(true, [1, 2, 3] != ['1', '2', '3'])\n\n      assert_equal(false, {one: 1, two: 2} != {one: 1, two: 2})\n      assert_equal(true, {one: 1, two: 2} != {one: 2, two: 2})\n      assert_equal(true, {one: 1, two: 2} != {two: 2})\n      assert_equal(true, {one: 1, two: 2} != {})\n      assert_equal(false, g:adict != {bbb: 8, aaa: 2})\n      assert_equal(true, {ccc: 9, aaa: 2} != g:adict)\n\n      assert_equal(false, function('g:Test_expr4_equal') != function('g:Test_expr4_equal'))\n      assert_equal(true, function('g:Test_expr4_equal') != function('g:Test_expr4_is'))\n\n      assert_equal(false, function('g:Test_expr4_equal', [123]) != function('g:Test_expr4_equal', [123]))\n      assert_equal(true, function('g:Test_expr4_equal', [123]) != function('g:Test_expr4_is', [123]))\n      assert_equal(true, function('g:Test_expr4_equal', [123]) != function('g:Test_expr4_equal', [999]))\n  END\n  CheckDefAndScriptSuccess(lines)\nenddef\n\n\" test > comperator\ndef Test_expr4_greater()\n  var lines =<< trim END\n      assert_true(2 > 0)\n      assert_true(2 >\n                    1)\n      assert_false(2 > 2)\n      assert_false(2 > 3)\n      var nr2 = 2\n      assert_true(nr2 > 0)\n      assert_true(nr2 >\n                    1)\n      assert_false(nr2 > 2)\n      assert_false(nr2\n                        > 3)\n      if has('float')\n        var ff = 2.0\n        assert_true(ff > 0.0)\n        assert_true(ff > 1.0)\n        assert_false(ff > 2.0)\n        assert_false(ff > 3.0)\n      endif\n  END\n  CheckDefAndScriptSuccess(lines)\nenddef\n\n\" test >= comperator\ndef Test_expr4_greaterequal()\n  var lines =<< trim END\n      assert_true(2 >= 0)\n      assert_true(2 >=\n                            2)\n      assert_false(2 >= 3)\n      var nr2 = 2\n      assert_true(nr2 >= 0)\n      assert_true(nr2 >= 2)\n      assert_false(nr2 >= 3)\n      if has('float')\n        var ff = 2.0\n        assert_true(ff >= 0.0)\n        assert_true(ff >= 2.0)\n        assert_false(ff >= 3.0)\n      endif\n  END\n  CheckDefAndScriptSuccess(lines)\nenddef\n\n\" test < comperator\ndef Test_expr4_smaller()\n  var lines =<< trim END\n      assert_false(2 < 0)\n      assert_false(2 <\n                            2)\n      assert_true(2\n                    < 3)\n      var nr2 = 2\n      assert_false(nr2 < 0)\n      assert_false(nr2 < 2)\n      assert_true(nr2 < 3)\n      if has('float')\n        var ff = 2.0\n        assert_false(ff < 0.0)\n        assert_false(ff < 2.0)\n        assert_true(ff < 3.0)\n      endif\n  END\n  CheckDefAndScriptSuccess(lines)\nenddef\n\n\" test <= comperator\ndef Test_expr4_smallerequal()\n  var lines =<< trim END\n      assert_false(2 <= 0)\n      assert_false(2 <=\n                            1)\n      assert_true(2\n                    <= 2)\n      assert_true(2 <= 3)\n      var nr2 = 2\n      assert_false(nr2 <= 0)\n      assert_false(nr2 <= 1)\n      assert_true(nr2 <= 2)\n      assert_true(nr2 <= 3)\n      if has('float')\n        var ff = 2.0\n        assert_false(ff <= 0.0)\n        assert_false(ff <= 1.0)\n        assert_true(ff <= 2.0)\n        assert_true(ff <= 3.0)\n      endif\n  END\n  CheckDefAndScriptSuccess(lines)\nenddef\n\n\" test =~ comperator\ndef Test_expr4_match()\n  var lines =<< trim END\n      assert_equal(false, '2' =~ '0')\n      assert_equal(false, ''\n                             =~ '0')\n      assert_equal(true, '2' =~\n                            '[0-9]')\n      set ignorecase\n      assert_equal(false, 'abc' =~ 'ABC')\n      assert_equal(false, 'abc' =~# 'ABC')\n      assert_equal(true, 'abc' =~? 'ABC')\n      set noignorecase\n  END\n  CheckDefAndScriptSuccess(lines)\nenddef\n\n\" test !~ comperator\ndef Test_expr4_nomatch()\n  var lines =<< trim END\n      assert_equal(true, '2' !~ '0')\n      assert_equal(true, ''\n                            !~ '0')\n      assert_equal(false, '2' !~\n                            '[0-9]')\n  END\n  CheckDefAndScriptSuccess(lines)\nenddef\n\n\" test is comperator\ndef Test_expr4_is()\n  var lines =<< trim END\n      var mylist = [2]\n      assert_false(mylist is [2])\n      var other = mylist\n      assert_true(mylist is\n                    other)\n\n      var myblob = 0z1234\n      assert_false(myblob\n                            is 0z1234)\n      var otherblob = myblob\n      assert_true(myblob is otherblob)\n  END\n  CheckDefAndScriptSuccess(lines)\nenddef\n\n\" test isnot comperator\ndef Test_expr4_isnot()\n  var lines =<< trim END\n      var mylist = [2]\n      assert_true('2' isnot '0')\n      assert_true(mylist isnot [2])\n      var other = mylist\n      assert_false(mylist isnot\n                            other)\n\n      var myblob = 0z1234\n      assert_true(myblob\n                    isnot 0z1234)\n      var otherblob = myblob\n      assert_false(myblob isnot otherblob)\n  END\n  CheckDefAndScriptSuccess(lines)\nenddef\n\ndef RetVoid()\n  var x = 1\nenddef\n\ndef Test_expr4_vim9script()\n  # check line continuation\n  var lines =<< trim END\n      var name = 0\n      \t\t< 1\n      assert_equal(true, name)\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  lines =<< trim END\n      var name = 123\n                # comment\n      \t\t!= 123\n      assert_equal(false, name)\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  lines =<< trim END\n      var name = 123 ==\n      \t\t\t123\n      assert_equal(true, name)\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  lines =<< trim END\n      var list = [1, 2, 3]\n      var name = list\n      \t\tis list\n      assert_equal(true, name)\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  lines =<< trim END\n      var list = [1, 2, 3]\n      var name = list # comment\n                 # comment\n      \t\tis list\n      assert_equal(true, name)\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  lines =<< trim END\n      var myblob = 0z1234\n      var name = myblob\n      \t\tisnot 0z11\n      assert_equal(true, name)\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  # spot check mismatching types\n  lines =<< trim END\n      echo '' == 0\n  END\n  CheckDefAndScriptFailure(lines, 'E1072:', 1)\n\n  lines =<< trim END\n      echo v:true > v:false\n  END\n  CheckDefAndScriptFailure(lines, 'Cannot compare bool with bool', 1)\n\n  lines =<< trim END\n      echo 123 is 123\n  END\n  CheckDefAndScriptFailure(lines, 'Cannot use \"is\" with number', 1)\n\n  # check missing white space\n  lines =<< trim END\n    echo 2>3\n  END\n  CheckDefAndScriptFailure(lines, 'E1004: White space required before and after ''>'' at \">3\"', 1)\n\n  lines =<< trim END\n    echo 2 >3\n  END\n  CheckDefAndScriptFailure(lines, 'E1004:', 1)\n\n  lines =<< trim END\n    echo 2> 3\n  END\n  CheckDefAndScriptFailure(lines, 'E1004:', 1)\n\n  lines =<< trim END\n    echo 2!=3\n  END\n  CheckDefAndScriptFailure(lines, 'E1004:', 1)\n\n  lines =<< trim END\n    echo 2 !=3\n  END\n  CheckDefAndScriptFailure(lines, 'E1004: White space required before and after ''!='' at \"!=3\"', 1)\n\n  lines =<< trim END\n    echo 2!= 3\n  END\n  CheckDefAndScriptFailure(lines, 'E1004:', 1)\n\n  for op in ['==', '>', '>=', '<', '<=', '=~', '!~', 'is', 'isnot']\n    lines = [\"echo 'aaa'\", op .. \"'bbb'\", '# comment']\n    var msg = printf(\"E1004: White space required before and after '%s'\", op)\n    CheckDefAndScriptFailure(lines, msg, 2)\n  endfor\n\n  lines =<< trim END\n    echo len('xxx') == 3\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  lines =<< trim END\n    var line = 'abc'\n    echo line[1] =~ '\\w'\n  END\n  CheckDefAndScriptSuccess(lines)\nenddef\n\nfunc Test_expr4_fails()\n  let msg = \"White space required before and after '>'\"\n  call CheckDefAndScriptFailure([\"var x = 1>2\"], msg, 1)\n  call CheckDefAndScriptFailure([\"var x = 1 >2\"], msg, 1)\n  call CheckDefAndScriptFailure([\"var x = 1> 2\"], msg, 1)\n\n  let msg = \"White space required before and after '=='\"\n  call CheckDefAndScriptFailure([\"var x = 1==2\"], msg, 1)\n  call CheckDefAndScriptFailure([\"var x = 1 ==2\"], msg, 1)\n  call CheckDefAndScriptFailure([\"var x = 1== 2\"], msg, 1)\n\n  let msg = \"White space required before and after 'is'\"\n  call CheckDefAndScriptFailure([\"var x = '1'is'2'\"], msg, 1)\n  call CheckDefAndScriptFailure([\"var x = '1' is'2'\"], msg, 1)\n  call CheckDefAndScriptFailure([\"var x = '1'is '2'\"], msg, 1)\n\n  let msg = \"White space required before and after 'isnot'\"\n  call CheckDefAndScriptFailure([\"var x = '1'isnot'2'\"], msg, 1)\n  call CheckDefAndScriptFailure([\"var x = '1' isnot'2'\"], msg, 1)\n  call CheckDefAndScriptFailure([\"var x = '1'isnot '2'\"], msg, 1)\n\n  call CheckDefAndScriptFailure([\"var x = 1 is# 2\"], 'E15:', 1)\n  call CheckDefAndScriptFailure([\"var x = 1 is? 2\"], 'E15:', 1)\n  call CheckDefAndScriptFailure([\"var x = 1 isnot# 2\"], 'E15:', 1)\n  call CheckDefAndScriptFailure([\"var x = 1 isnot? 2\"], 'E15:', 1)\n\n  call CheckDefAndScriptFailure([\"var x = 1 == '2'\"], 'Cannot compare number with string', 1)\n  call CheckDefAndScriptFailure([\"var x = '1' == 2\"], 'Cannot compare string with number', 1)\n  call CheckDefAndScriptFailure([\"var x = 1 == RetVoid()\"], 'Cannot compare number with void', 1)\n  call CheckDefAndScriptFailure([\"var x = RetVoid() == 1\"], 'Cannot compare void with number', 1)\n\n  call CheckDefAndScriptFailure([\"var x = true > false\"], 'Cannot compare bool with bool', 1)\n  call CheckDefAndScriptFailure([\"var x = true >= false\"], 'Cannot compare bool with bool', 1)\n  call CheckDefAndScriptFailure([\"var x = true < false\"], 'Cannot compare bool with bool', 1)\n  call CheckDefAndScriptFailure([\"var x = true <= false\"], 'Cannot compare bool with bool', 1)\n  call CheckDefAndScriptFailure([\"var x = true =~ false\"], 'Cannot compare bool with bool', 1)\n  call CheckDefAndScriptFailure([\"var x = true !~ false\"], 'Cannot compare bool with bool', 1)\n  call CheckDefAndScriptFailure([\"var x = true is false\"], 'Cannot use \"is\" with bool', 1)\n  call CheckDefAndScriptFailure([\"var x = true isnot false\"], 'Cannot use \"isnot\" with bool', 1)\n\n  call CheckDefAndScriptFailure([\"var x = v:none is v:null\"], 'Cannot use \"is\" with special', 1)\n  call CheckDefAndScriptFailure([\"var x = v:none isnot v:null\"], 'Cannot use \"isnot\" with special', 1)\n  call CheckDefAndScriptFailure([\"var x = 123 is 123\"], 'Cannot use \"is\" with number', 1)\n  call CheckDefAndScriptFailure([\"var x = 123 isnot 123\"], 'Cannot use \"isnot\" with number', 1)\n  if has('float')\n    call CheckDefAndScriptFailure([\"var x = 1.3 is 1.3\"], 'Cannot use \"is\" with float', 1)\n    call CheckDefAndScriptFailure([\"var x = 1.3 isnot 1.3\"], 'Cannot use \"isnot\" with float', 1)\n  endif\n\n  call CheckDefAndScriptFailure([\"var x = 0za1 > 0z34\"], 'Cannot compare blob with blob', 1)\n  call CheckDefAndScriptFailure([\"var x = 0za1 >= 0z34\"], 'Cannot compare blob with blob', 1)\n  call CheckDefAndScriptFailure([\"var x = 0za1 < 0z34\"], 'Cannot compare blob with blob', 1)\n  call CheckDefAndScriptFailure([\"var x = 0za1 <= 0z34\"], 'Cannot compare blob with blob', 1)\n  call CheckDefAndScriptFailure([\"var x = 0za1 =~ 0z34\"], 'Cannot compare blob with blob', 1)\n  call CheckDefAndScriptFailure([\"var x = 0za1 !~ 0z34\"], 'Cannot compare blob with blob', 1)\n\n  call CheckDefAndScriptFailure([\"var x = [13] > [88]\"], 'Cannot compare list with list', 1)\n  call CheckDefAndScriptFailure([\"var x = [13] >= [88]\"], 'Cannot compare list with list', 1)\n  call CheckDefAndScriptFailure([\"var x = [13] < [88]\"], 'Cannot compare list with list', 1)\n  call CheckDefAndScriptFailure([\"var x = [13] <= [88]\"], 'Cannot compare list with list', 1)\n  call CheckDefAndScriptFailure([\"var x = [13] =~ [88]\"], 'Cannot compare list with list', 1)\n  call CheckDefAndScriptFailure([\"var x = [13] !~ [88]\"], 'Cannot compare list with list', 1)\n\n  call CheckDefAndScriptFailure(['var j: job', 'var chan: channel', 'var r = j == chan'], 'Cannot compare job with channel', 3)\n  call CheckDefAndScriptFailure(['var j: job', 'var x: list<any>', 'var r = j == x'], 'Cannot compare job with list', 3)\n  call CheckDefAndScriptFailure(['var j: job', 'var Xx: func', 'var r = j == Xx'], 'Cannot compare job with func', 3)\n  call CheckDefAndScriptFailure(['var j: job', 'var Xx: func', 'var r = j == Xx'], 'Cannot compare job with func', 3)\nendfunc\n\n\" test addition, subtraction, concatenation\ndef Test_expr5()\n  var lines =<< trim END\n      assert_equal(66, 60 + 6)\n      assert_equal(70, 60 +\n                            g:anint)\n      assert_equal(9, g:thefour\n                            + 5)\n      assert_equal(14, g:thefour + g:anint)\n      assert_equal([1, 2, 3, 4], [1] + g:alist)\n\n      assert_equal(54, 60 - 6)\n      assert_equal(50, 60 -\n                        g:anint)\n      assert_equal(-1, g:thefour\n                            - 5)\n      assert_equal(-6, g:thefour - g:anint)\n\n      assert_equal('hello', 'hel' .. 'lo')\n      assert_equal('hello 123', 'hello ' ..\n                                            123)\n      assert_equal('hello 123', 'hello '\n                                    ..  123)\n      assert_equal('123 hello', 123 .. ' hello')\n      assert_equal('123456', 123 .. 456)\n\n      assert_equal('atrue', 'a' .. true)\n      assert_equal('afalse', 'a' .. false)\n      assert_equal('anull', 'a' .. v:null)\n      assert_equal('av:none', 'a' .. v:none)\n      if has('float')\n        assert_equal('a0.123', 'a' .. 0.123)\n      endif\n\n      assert_equal(3, 1 + [2, 3, 4][0])\n      assert_equal(5, 2 + {key: 3}['key'])\n\n      set digraph\n      assert_equal('val: true', 'val: ' .. &digraph)\n      set nodigraph\n      assert_equal('val: false', 'val: ' .. &digraph)\n\n      assert_equal([1, 2, 3, 4], [1, 2] + [3, 4])\n      assert_equal(0z11223344, 0z1122 + 0z3344)\n      assert_equal(0z112201ab, 0z1122\n                                    + g:ablob)\n      assert_equal(0z01ab3344, g:ablob + 0z3344)\n      assert_equal(0z01ab01ab, g:ablob + g:ablob)\n\n      # concatenate non-constant to constant\n      var save_path = &path\n      &path = 'b'\n      assert_equal('ab', 'a' .. &path)\n      &path = save_path\n\n      @b = 'b'\n      assert_equal('ab', 'a' .. @b)\n\n      $ENVVAR = 'env'\n      assert_equal('aenv', 'a' .. $ENVVAR)\n\n      assert_equal('val', '' .. {key: 'val'}['key'])\n  END\n  CheckDefAndScriptSuccess(lines)\nenddef\n\ndef Test_expr5_vim9script()\n  # check line continuation\n  var lines =<< trim END\n      var name = 11\n      \t\t+ 77\n\t\t- 22\n      assert_equal(66, name)\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  lines =<< trim END\n      var name = 11 +\n\t\t  77 -\n\t\t  22\n      assert_equal(66, name)\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  lines =<< trim END\n      var name = 11 +  # comment\n\t\t  77 -\n                  # comment\n\t\t  22\n      assert_equal(66, name)\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  lines =<< trim END\n      var name = 'one'\n      \t\t.. 'two'\n      assert_equal('onetwo', name)\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  lines =<< trim END\n      echo 'abc' is# 'abc'\n  END\n  CheckDefAndScriptFailure(lines, 'E15:', 1)\n\n  lines =<< trim END\n      echo {} - 22\n  END\n  CheckDefAndScriptFailure(lines, ['E1036:', 'E728:'], 1)\n\n  lines =<< trim END\n      echo [] - 33\n  END\n  CheckDefAndScriptFailure(lines, ['E1036:', 'E745:'], 1)\n\n  lines =<< trim END\n      echo 0z1234 - 44\n  END\n  CheckDefAndScriptFailure(lines, ['E1036', 'E974:'], 1)\n\n  lines =<< trim END\n      echo 'abc' is? 'abc'\n  END\n  CheckDefAndScriptFailure(lines, 'E15:', 1)\n\n  lines =<< trim END\n      echo 'abc' isnot# 'abc'\n  END\n  CheckDefAndScriptFailure(lines, 'E15:', 1)\n\n  lines =<< trim END\n      echo 'abc' isnot? 'abc'\n  END\n  CheckDefAndScriptFailure(lines, 'E15:', 1)\n\n  # check white space\n  lines =<< trim END\n      echo 5+6\n  END\n  CheckDefAndScriptFailure(lines, 'E1004:', 1)\n  lines =<< trim END\n      echo 5 +6\n  END\n  CheckDefAndScriptFailure(lines, 'E1004:', 1)\n\n  lines =<< trim END\n      echo 5+ 6\n  END\n  CheckDefAndScriptFailure(lines, 'E1004:', 1)\n\n  lines =<< trim END\n      echo 'a'..'b'\n  END\n  CheckDefAndScriptFailure(lines, 'E1004: White space required before and after ''..'' at \"..''b''\"', 1)\n\n  lines =<< trim END\n      echo 'a' ..'b'\n  END\n  CheckDefAndScriptFailure(lines, 'E1004:', 1)\n\n  lines =<< trim END\n      echo 'a'.. 'b'\n  END\n  CheckDefAndScriptFailure(lines, 'E1004: White space required before and after ''..'' at \".. ''b''\"', 1)\n\n  lines =<< trim END\n      echo 'a'\n          ..'b'\n      # comment\n  END\n  CheckDefAndScriptFailure(lines, 'E1004: White space required before and after ''..'' at \"..''b''\"', 2)\n\n  # check invalid string concatenation\n  lines =<< trim END\n      echo 'a' .. [1]\n  END\n  CheckDefAndScriptFailure(lines, ['E1105:', 'E730:'], 1)\n\n  lines =<< trim END\n      echo 'a' .. {a: 1}\n  END\n  CheckDefAndScriptFailure(lines, ['E1105:', 'E731:'], 1)\n\n  lines =<< trim END\n      echo 'a' .. test_void()\n  END\n  CheckDefAndScriptFailure(lines, ['E1105:', 'E908:'], 1)\n\n  lines =<< trim END\n      echo 'a' .. 0z33\n  END\n  CheckDefAndScriptFailure(lines, ['E1105:', 'E976:'], 1)\n\n  lines =<< trim END\n      echo 'a' .. function('len')\n  END\n  CheckDefAndScriptFailure(lines, ['E1105:', 'E729:'], 1)\n\n  lines =<< trim END\n      new\n      ['']->setline(1)\n      /pattern\n\n      eval 0\n      bwipe!\n  END\n  CheckDefAndScriptFailure(lines, \"E1004: White space required before and after '/' at \\\"/pattern\", 3)\n\n  for op in ['+', '-']\n    lines = ['var x = 1', op .. '2', '# comment']\n    var msg = printf(\"E1004: White space required before and after '%s' at \\\"%s2\\\"\", op, op)\n    CheckDefAndScriptFailure(lines, msg, 2)\n  endfor\nenddef\n\ndef Test_expr5_vim9script_channel()\n  if !has('channel')\n    MissingFeature 'channel'\n  else\n    var lines =<< trim END\n        echo 'a' .. test_null_job()\n    END\n    CheckDefAndScriptFailure(lines, ['E1105:', 'E908:'], 1)\n    lines =<< trim END\n        echo 'a' .. test_null_channel()\n    END\n    CheckDefAndScriptFailure(lines, ['E1105:', 'E908:'], 1)\n  endif\nenddef\n\ndef Test_expr5_float()\n  if !has('float')\n    MissingFeature 'float'\n  else\n    var lines =<< trim END\n        assert_equal(66.0, 60.0 + 6.0)\n        assert_equal(66.0, 60.0 + 6)\n        assert_equal(66.0, 60 +\n                             6.0)\n        assert_equal(5.1, g:afloat\n                            + 5)\n        assert_equal(8.1, 8 + g:afloat)\n        assert_equal(10.1, g:anint + g:afloat)\n        assert_equal(10.1, g:afloat + g:anint)\n\n        assert_equal(54.0, 60.0 - 6.0)\n        assert_equal(54.0, 60.0\n                                - 6)\n        assert_equal(54.0, 60 - 6.0)\n        assert_equal(-4.9, g:afloat - 5)\n        assert_equal(7.9, 8 - g:afloat)\n        assert_equal(9.9, g:anint - g:afloat)\n        assert_equal(-9.9, g:afloat - g:anint)\n    END\n    CheckDefAndScriptSuccess(lines)\n  endif\nenddef\n\nfunc Test_expr5_fails()\n  let msg = \"White space required before and after '+'\"\n  call CheckDefAndScriptFailure([\"var x = 1+2\"], msg, 1)\n  call CheckDefAndScriptFailure([\"var x = 1 +2\"], msg, 1)\n  call CheckDefAndScriptFailure([\"var x = 1+ 2\"], msg, 1)\n\n  let msg = \"White space required before and after '-'\"\n  call CheckDefAndScriptFailure([\"var x = 1-2\"], msg, 1)\n  call CheckDefAndScriptFailure([\"var x = 1 -2\"], msg, 1)\n  call CheckDefAndScriptFailure([\"var x = 1- 2\"], msg, 1)\n\n  let msg = \"White space required before and after '..'\"\n  call CheckDefAndScriptFailure([\"var x = '1'..'2'\"], msg, 1)\n  call CheckDefAndScriptFailure([\"var x = '1' ..'2'\"], msg, 1)\n  call CheckDefAndScriptFailure([\"var x = '1'.. '2'\"], msg, 1)\n\n  call CheckDefAndScriptFailure([\"var x = 0z1122 + 33\"], ['E1051:', 'E974:'], 1)\n  call CheckDefAndScriptFailure([\"var x = 0z1122 + [3]\"], ['E1051:', 'E974:'], 1)\n  call CheckDefAndScriptFailure([\"var x = 0z1122 + 'asd'\"], ['E1051:', 'E974:'], 1)\n  call CheckDefAndScriptFailure([\"var x = 33 + 0z1122\"], ['E1051:', 'E974:'], 1)\n  call CheckDefAndScriptFailure([\"var x = [3] + 0z1122\"], ['E1051:', 'E745:'], 1)\n  call CheckDefAndScriptFailure([\"var x = 'asdf' + 0z1122\"], ['E1051:', 'E1030:'], 1)\n  call CheckDefAndScriptFailure([\"var x = 6 + xxx\"], ['E1001:', 'E121:'], 1)\n\n  call CheckDefAndScriptFailure([\"var x = 'a' .. [1]\"], ['E1105:', 'E730:'], 1)\n  call CheckDefAndScriptFailure([\"var x = 'a' .. {a: 1}\"], ['E1105:', 'E731:'], 1)\n  call CheckDefAndScriptFailure([\"var x = 'a' .. test_void()\"], ['E1105:', 'E908:'], 1)\n  call CheckDefAndScriptFailure([\"var x = 'a' .. 0z32\"], ['E1105:', 'E976:'], 1)\n  call CheckDefAndScriptFailure([\"var x = 'a' .. function('len')\"], ['E1105:', 'E729:'], 1)\n  call CheckDefAndScriptFailure([\"var x = 'a' .. function('len', ['a'])\"], ['E1105:', 'E729:'], 1)\n\n  call CheckDefAndScriptFailure(['var x = 1 + v:none'], ['E1051:', 'E611:'], 1)\n  call CheckDefAndScriptFailure(['var x = 1 + v:null'], ['E1051:', 'E611:'], 1)\n  call CheckDefAndScriptFailure(['var x = 1 + v:true'], ['E1051:', 'E1138:'], 1)\n  call CheckDefAndScriptFailure(['var x = 1 + v:false'], ['E1051:', 'E1138:'], 1)\n  call CheckDefAndScriptFailure(['var x = 1 + true'], ['E1051:', 'E1138:'], 1)\n  call CheckDefAndScriptFailure(['var x = 1 + false'], ['E1051:', 'E1138:'], 1)\nendfunc\n\nfunc Test_expr5_fails_channel()\n  CheckFeature channel\n  call CheckDefAndScriptFailure([\"var x = 'a' .. test_null_job()\"], ['E1105:', 'E908:'], 1)\n  call CheckDefAndScriptFailure([\"var x = 'a' .. test_null_channel()\"], ['E1105:', 'E908:'], 1)\nendfunc\n\ndef Test_expr5_list_add()\n  var lines =<< trim END\n      # concatenating two lists with same member types is OK\n      var d = {}\n      for i in ['a'] + ['b']\n        d = {[i]: 0}\n      endfor\n\n      # concatenating two lists with different member types results in \"any\"\n      var dany = {}\n      for i in ['a'] + [12]\n        dany[i] = i\n      endfor\n      assert_equal({a: 'a', 12: 12}, dany)\n\n      # result of glob() is \"any\", runtime type check\n      var sl: list<string> = glob('*.txt', false, true) + ['']\n  END\n  CheckDefAndScriptSuccess(lines)\nenddef\n\n\" test multiply, divide, modulo\ndef Test_expr6()\n  var lines =<< trim END\n      assert_equal(36, 6 * 6)\n      assert_equal(24, 6 *\n                            g:thefour)\n      assert_equal(24, g:thefour\n                            * 6)\n      assert_equal(40, g:anint * g:thefour)\n\n      assert_equal(10, 60 / 6)\n      assert_equal(6, 60 /\n                            g:anint)\n      assert_equal(1, g:anint / 6)\n      assert_equal(2, g:anint\n                            / g:thefour)\n\n      assert_equal(5, 11 % 6)\n      assert_equal(4, g:anint % 6)\n      assert_equal(3, 13 %\n                            g:anint)\n      assert_equal(2, g:anint\n                            % g:thefour)\n\n      assert_equal(4, 6 * 4 / 6)\n\n      var x = [2]\n      var y = [3]\n      assert_equal(5, x[0] + y[0])\n      assert_equal(6, x[0] * y[0])\n      if has('float')\n        var xf = [2.0]\n        var yf = [3.0]\n        assert_equal(5.0, xf[0]\n                            + yf[0])\n        assert_equal(6.0, xf[0]\n                            * yf[0])\n      endif\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  CheckDefAndScriptFailure([\"var x = 6 * xxx\"], ['E1001:', 'E121:'], 1)\n  CheckDefFailure([\"var d = 6 * \"], 'E1097:', 3)\n  CheckScriptFailure(['vim9script', \"var d = 6 * \"], 'E15:', 2)\n\n  CheckDefExecAndScriptFailure(['echo 1 / 0'], 'E1154', 1)\n  CheckDefExecAndScriptFailure(['echo 1 % 0'], 'E1154', 1)\n\n  lines =<< trim END\n    var n = 0\n    eval 1 / n\n  END\n  CheckDefExecAndScriptFailure(lines, 'E1154', 2)\n\n  lines =<< trim END\n    var n = 0\n    eval 1 % n\n  END\n  CheckDefExecAndScriptFailure(lines, 'E1154', 2)\nenddef\n\ndef Test_expr6_vim9script()\n  # check line continuation\n  var lines =<< trim END\n      var name = 11\n      \t\t* 22\n\t\t/ 3\n      assert_equal(80, name)\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  lines =<< trim END\n      var name = 25\n      \t\t% 10\n      assert_equal(5, name)\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  lines =<< trim END\n      var name = 25\n                # comment\n\n                # comment\n      \t\t% 10\n      assert_equal(5, name)\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  lines =<< trim END\n      var name = 11 *\n      \t\t22 /\n\t\t3\n      assert_equal(80, name)\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  # check white space\n  lines =<< trim END\n      echo 5*6\n  END\n  CheckDefAndScriptFailure(lines, 'E1004:', 1)\n\n  lines =<< trim END\n      echo 5 *6\n  END\n  CheckDefAndScriptFailure(lines, 'E1004:', 1)\n\n  lines =<< trim END\n      echo 5* 6\n  END\n  CheckDefAndScriptFailure(lines, 'E1004:', 1)\nenddef\n\ndef Test_expr6_float()\n  if !has('float')\n    MissingFeature 'float'\n  else\n    var lines =<< trim END\n        assert_equal(36.0, 6.0 * 6)\n        assert_equal(36.0, 6 *\n                               6.0)\n        assert_equal(36.0, 6.0 * 6.0)\n        assert_equal(1.0, g:afloat * g:anint)\n\n        assert_equal(10.0, 60 / 6.0)\n        assert_equal(10.0, 60.0 /\n                            6)\n        assert_equal(10.0, 60.0 / 6.0)\n        assert_equal(0.01, g:afloat / g:anint)\n\n        assert_equal(4.0, 6.0 * 4 / 6)\n        assert_equal(4.0, 6 *\n                            4.0 /\n                            6)\n        assert_equal(4.0, 6 * 4 / 6.0)\n        assert_equal(4.0, 6.0 * 4.0 / 6)\n        assert_equal(4.0, 6 * 4.0 / 6.0)\n        assert_equal(4.0, 6.0 * 4 / 6.0)\n        assert_equal(4.0, 6.0 * 4.0 / 6.0)\n\n        assert_equal(4.0, 6.0 * 4.0 / 6.0)\n    END\n    CheckDefAndScriptSuccess(lines)\n  endif\nenddef\n\nfunc Test_expr6_fails()\n  let msg = \"White space required before and after '*'\"\n  call CheckDefAndScriptFailure([\"var x = 1*2\"], msg, 1)\n  call CheckDefAndScriptFailure([\"var x = 1 *2\"], msg, 1)\n  call CheckDefAndScriptFailure([\"var x = 1* 2\"], msg, 1)\n\n  let msg = \"White space required before and after '/'\"\n  call CheckDefAndScriptFailure([\"var x = 1/2\"], msg, 1)\n  call CheckDefAndScriptFailure([\"var x = 1 /2\"], msg, 1)\n  call CheckDefAndScriptFailure([\"var x = 1/ 2\"], msg, 1)\n\n  let msg = \"White space required before and after '%'\"\n  call CheckDefAndScriptFailure([\"var x = 1%2\"], msg, 1)\n  call CheckDefAndScriptFailure([\"var x = 1 %2\"], msg, 1)\n  call CheckDefAndScriptFailure([\"var x = 1% 2\"], msg, 1)\n\n  call CheckDefAndScriptFailure([\"var x = '1' * '2'\"], ['E1036:', 'E1030:'], 1)\n  call CheckDefAndScriptFailure([\"var x = '1' / '2'\"], ['E1036:', 'E1030:'], 1)\n  call CheckDefAndScriptFailure([\"var x = '1' % '2'\"], ['E1035:', 'E1030:'], 1)\n\n  call CheckDefAndScriptFailure([\"var x = 0z01 * 0z12\"], ['E1036:', 'E974:'], 1)\n  call CheckDefAndScriptFailure([\"var x = 0z01 / 0z12\"], ['E1036:', 'E974:'], 1)\n  call CheckDefAndScriptFailure([\"var x = 0z01 % 0z12\"], ['E1035:', 'E974:'], 1)\n\n  call CheckDefAndScriptFailure([\"var x = [1] * [2]\"], ['E1036:', 'E745:'], 1)\n  call CheckDefAndScriptFailure([\"var x = [1] / [2]\"], ['E1036:', 'E745:'], 1)\n  call CheckDefAndScriptFailure([\"var x = [1] % [2]\"], ['E1035:', 'E745:'], 1)\n\n  call CheckDefAndScriptFailure([\"var x = {one: 1} * {two: 2}\"], ['E1036:', 'E728:'], 1)\n  call CheckDefAndScriptFailure([\"var x = {one: 1} / {two: 2}\"], ['E1036:', 'E728:'], 1)\n  call CheckDefAndScriptFailure([\"var x = {one: 1} % {two: 2}\"], ['E1035:', 'E728:'], 1)\n\n  call CheckDefAndScriptFailure([\"var x = 0xff[1]\"], ['E1107:', 'E1062:'], 1)\n  if has('float')\n    call CheckDefAndScriptFailure([\"var x = 0.7[1]\"], ['E1107:', 'E806:'], 1)\n  endif\n\n  for op in ['*', '/', '%']\n    let lines = ['var x = 1', op .. '2', '# comment']\n    let msg = printf(\"E1004: White space required before and after '%s' at \\\"%s2\\\"\", op, op)\n    call CheckDefAndScriptFailure(lines, msg, 2)\n  endfor\nendfunc\n\nfunc Test_expr6_float_fails()\n  CheckFeature float\n  call CheckDefAndScriptFailure([\"var x = 1.0 % 2\"], ['E1035:', 'E804:'], 1)\nendfunc\n\n\" define here to use old style parsing\nif has('float')\n  let g:float_zero = 0.0\n  let g:float_neg = -9.8\n  let g:float_big = 9.9e99\nendif\nlet g:blob_empty = 0z\nlet g:blob_one = 0z01\nlet g:blob_long = 0z0102.0304\n\nlet g:string_empty = ''\nlet g:string_short = 'x'\nlet g:string_long = 'abcdefghijklm'\nlet g:string_special = \"ab\\ncd\\ref\\ekk\"\n\nlet g:special_true = v:true\nlet g:special_false = v:false\nlet g:special_null = v:null\nlet g:special_none = v:none\n\nlet g:list_empty = []\nlet g:list_mixed = [1, 'b', v:false]\n\nlet g:dict_empty = {}\nlet g:dict_one = #{one: 1}\n\nlet $TESTVAR = 'testvar'\n\n\" type casts\ndef Test_expr7t()\n  var lines =<< trim END\n      var ls: list<string> = ['a', <string>g:string_empty]\n      var ln: list<number> = [<number>g:anint, <number>g:thefour]\n      var nr = <number>234\n      assert_equal(234, nr)\n      var b: bool = <bool>1\n      assert_equal(true, b)\n      var text =\n            <string>\n              'text'\n      if false\n        text = <number>'xxx'\n      endif\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  CheckDefAndScriptFailure([\"var x = <nr>123\"], 'E1010:', 1)\n  CheckDefFailure([\"var x = <number>\"], 'E1097:', 3)\n  CheckDefFailure([\"var x = <number>string(1)\"], 'E1012:', 1)\n  CheckScriptFailure(['vim9script', \"var x = <number>\"], 'E15:', 2)\n  CheckDefAndScriptFailure([\"var x = <number >123\"], 'E1068:', 1)\n  CheckDefAndScriptFailure([\"var x = <number 123\"], 'E1104:', 1)\nenddef\n\n\" test low level expression\ndef Test_expr7_number()\n  # number constant\n  var lines =<< trim END\n      assert_equal(0, 0)\n      assert_equal(654, 0654)\n\n      assert_equal(6, 0x6)\n      assert_equal(15, 0xf)\n      assert_equal(255, 0xff)\n  END\n  CheckDefAndScriptSuccess(lines)\nenddef\n\ndef Test_expr7_float()\n  # float constant\n  if !has('float')\n    MissingFeature 'float'\n  else\n    var lines =<< trim END\n        assert_equal(g:float_zero, .0)\n        assert_equal(g:float_zero, 0.0)\n        assert_equal(g:float_neg, -9.8)\n        assert_equal(g:float_big, 9.9e99)\n    END\n    CheckDefAndScriptSuccess(lines)\n  endif\nenddef\n\ndef Test_expr7_blob()\n  # blob constant\n  var lines =<< trim END\n      assert_equal(g:blob_empty, 0z)\n      assert_equal(g:blob_one, 0z01)\n      assert_equal(g:blob_long, 0z0102.0304)\n\n      var testblob = 0z010203\n      assert_equal(0x01, testblob[0])\n      assert_equal(0x02, testblob[1])\n      assert_equal(0x03, testblob[-1])\n      assert_equal(0x02, testblob[-2])\n\n      assert_equal(0z01, testblob[0 : 0])\n      assert_equal(0z0102, testblob[0 : 1])\n      assert_equal(0z010203, testblob[0 : 2])\n      assert_equal(0z010203, testblob[0 : ])\n      assert_equal(0z0203, testblob[1 : ])\n      assert_equal(0z0203, testblob[1 : 2])\n      assert_equal(0z0203, testblob[1 : -1])\n      assert_equal(0z03, testblob[-1 : -1])\n      assert_equal(0z02, testblob[-2 : -2])\n\n      # blob slice accepts out of range\n      assert_equal(0z, testblob[3 : 3])\n      assert_equal(0z, testblob[0 : -4])\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  CheckDefAndScriptFailure([\"var x = 0z123\"], 'E973:', 1)\nenddef\n\ndef Test_expr7_string()\n  # string constant\n  var lines =<< trim END\n      assert_equal(g:string_empty, '')\n      assert_equal(g:string_empty, \"\")\n      assert_equal(g:string_short, 'x')\n      assert_equal(g:string_short, \"x\")\n      assert_equal(g:string_long, 'abcdefghijklm')\n      assert_equal(g:string_long, \"abcdefghijklm\")\n      assert_equal(g:string_special, \"ab\\ncd\\ref\\ekk\")\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  CheckDefAndScriptFailure(['var x = \"abc'], 'E114:', 1)\n  CheckDefAndScriptFailure([\"var x = 'abc\"], 'E115:', 1)\nenddef\n\ndef Test_expr7_vimvar()\n  v:errors = []\n  var errs: list<string> = v:errors\n  CheckDefFailure(['var errs: list<number> = v:errors'], 'E1012:')\n\n  var old: list<string> = v:oldfiles\n  CheckDefFailure(['var old: list<number> = v:oldfiles'], 'E1012:')\n\n  var compl: dict<string> = v:completed_item\n  CheckDefFailure(['var compl: dict<number> = v:completed_item'], 'E1012:')\n\n  var args: list<string> = v:argv\n  CheckDefFailure(['var args: list<number> = v:argv'], 'E1012:')\n\n  var colors: dict<string> = v:colornames\n  CheckDefFailure(['var colors: dict<number> = v:colornames'], 'E1012:')\n\n  CheckDefFailure([\"var old: list<number> = v:oldfiles\"], 'E1012: Type mismatch; expected list<number> but got list<string>', 1)\n  CheckScriptFailure(['vim9script', 'v:oldfiles = [\"foo\"]', \"var old: list<number> = v:oldfiles\"], 'E1012: Type mismatch; expected list<number> but got list<string>', 3)\n  new\n  exec \"normal! afoo fo\\<C-N>\\<Esc>\"\n  CheckDefExecAndScriptFailure([\"var old: dict<number> = v:completed_item\"], 'E1012: Type mismatch; expected dict<number> but got dict<string>', 1)\n  bwipe!\nenddef\n\ndef Test_expr7_special()\n  # special constant\n  var lines =<< trim END\n      assert_equal(g:special_true, true)\n      assert_equal(g:special_false, false)\n      assert_equal(g:special_true, v:true)\n      assert_equal(g:special_false, v:false)\n      assert_equal(v:true, true)\n      assert_equal(v:false, false)\n\n      assert_equal(true, !false)\n      assert_equal(false, !true)\n      assert_equal(true, !0)\n      assert_equal(false, !1)\n      assert_equal(false, !!false)\n      assert_equal(true, !!true)\n      assert_equal(false, !!0)\n      assert_equal(true, !!1)\n\n      var t = true\n      var f = false\n      assert_equal(true, t)\n      assert_equal(false, f)\n\n      assert_equal(g:special_null, v:null)\n      assert_equal(g:special_null, null)\n      assert_equal(g:special_none, v:none)\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  CheckDefAndScriptFailure(['v:true = true'], 'E46:', 1)\n  CheckDefAndScriptFailure(['v:true = false'], 'E46:', 1)\n  CheckDefAndScriptFailure(['v:false = true'], 'E46:', 1)\n  CheckDefAndScriptFailure(['v:null = 11'], 'E46:', 1)\n  CheckDefAndScriptFailure(['v:none = 22'], 'E46:', 1)\nenddef\n\ndef Test_expr7_list()\n  # list\n  var lines =<< trim END\n      assert_equal(g:list_empty, [])\n      assert_equal(g:list_empty, [  ])\n\n      var numbers: list<number> = [1, 2, 3]\n      numbers = [1]\n      numbers = []\n\n      var strings: list<string> = ['a', 'b', 'c']\n      strings = ['x']\n      strings = []\n\n      var mixed: list<any> = [1, 'b', false,]\n      assert_equal(g:list_mixed, mixed)\n      assert_equal('b', mixed[1])\n\n      echo [1,\n            2] [3,\n                    4]\n\n      var llstring: list<list<string>> = [['text'], []]\n      llstring = [[], ['text']]\n      llstring = [[], []]\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  var rangelist: list<number> = range(3)\n  g:rangelist = range(3)\n  CheckDefExecAndScriptFailure([\"var x: list<string> = g:rangelist\"], 'E1012: Type mismatch; expected list<string> but got list<number>', 1)\n\n  CheckDefAndScriptFailure([\"var x = 1234[3]\"], ['E1107:', 'E1062:'], 1)\n  CheckDefExecAndScriptFailure([\"var x = g:anint[3]\"], 'E1062:', 1)\n\n  CheckDefAndScriptFailure([\"var x = g:list_mixed[xxx]\"], ['E1001:', 'E121:'], 1)\n\n  CheckDefAndScriptFailure([\"var x = [1,2,3]\"], 'E1069:', 1)\n  CheckDefAndScriptFailure([\"var x = [1 ,2, 3]\"], 'E1068:', 1)\n\n  CheckDefExecAndScriptFailure([\"echo 1\", \"var x = [][0]\", \"echo 3\"], 'E684:', 2)\n\n  CheckDefExecAndScriptFailure([\"var x = g:list_mixed['xx']\"], ['E1012:', 'E1030:'], 1)\n  CheckDefFailure([\"var x = g:list_mixed[\"], 'E1097:', 3)\n  CheckScriptFailure(['vim9script', \"var x = g:list_mixed[\"], 'E15:', 2)\n  CheckDefFailure([\"var x = g:list_mixed[0\"], 'E1097:', 3)\n  CheckScriptFailure(['vim9script', \"var x = g:list_mixed[0\"], 'E111:', 2)\n  CheckDefExecAndScriptFailure([\"var x = g:list_empty[3]\"], 'E684:', 1)\n  CheckDefExecAndScriptFailure([\"var l: list<number> = [234, 'x']\"], 'E1012:', 1)\n  CheckDefExecAndScriptFailure([\"var l: list<number> = ['x', 234]\"], 'E1012:', 1)\n  CheckDefExecAndScriptFailure([\"var l: list<string> = [234, 'x']\"], 'E1012:', 1)\n  CheckDefExecAndScriptFailure([\"var l: list<string> = ['x', 123]\"], 'E1012:', 1)\n\n  lines =<< trim END\n      var datalist: list<string>\n      def Main()\n        datalist += ['x'.\n      enddef\n      Main()\n  END\n  CheckDefAndScriptFailure(lines, 'E1127:')\n\n  lines =<< trim END\n      var numbers = [1, 2, 3, 4]\n      var a = 1\n      var b = 2\n  END\n  CheckDefAndScriptFailure(lines + ['echo numbers[1:b]'],\n      'E1004: White space required before and after '':'' at \":b]\"', 4)\n  CheckDefAndScriptFailure(lines + ['echo numbers[1: b]'], 'E1004:', 4)\n  CheckDefAndScriptFailure(lines + ['echo numbers[a :b]'], 'E1004:', 4)\nenddef\n\ndef Test_expr7_list_vim9script()\n  var lines =<< trim END\n      var l = [\n\t\t11,\n\t\t22,\n\t\t]\n      assert_equal([11, 22], l)\n\n      echo [1,\n\t    2] [3,\n\t\t    4]\n\n      echo [1, # comment\n            # comment\n\t    2] [3,\n            # comment\n\t\t    4]\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  lines =<< trim END\n      var l = [11,\n\t\t22]\n      assert_equal([11, 22], l)\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  lines =<< trim END\n      var l = [11,22]\n  END\n  CheckDefAndScriptFailure(lines, 'E1069:', 1)\n\n  lines =<< trim END\n      var l = [11 , 22]\n  END\n  CheckDefAndScriptFailure(lines, 'E1068:', 1)\n\n  lines =<< trim END\n    var l: list<number> = [234, 'x']\n  END\n  CheckDefAndScriptFailure(lines, 'E1012:', 1)\n\n  lines =<< trim END\n    var l: list<number> = ['x', 234]\n  END\n  CheckDefAndScriptFailure(lines, 'E1012:', 1)\n\n  lines =<< trim END\n    var l: list<string> = ['x', 234]\n  END\n  CheckDefAndScriptFailure(lines, 'E1012:', 1)\n\n  lines =<< trim END\n    var l: list<string> = [234, 'x']\n  END\n  CheckDefAndScriptFailure(lines, 'E1012:', 1)\n\n  lines =<< trim END\n      def Failing()\n        job_stop()\n      enddef\n      var list = [Failing]\n  END\n  if has('channel')\n    CheckDefAndScriptFailure(lines, 'E119:', 0)\n  else\n    CheckDefAndScriptFailure(lines, 'E117:', 0)\n  endif\nenddef\n\ndef LambdaWithComments(): func\n  return (x) =>\n            # some comment\n            x == 1\n            # some comment\n            ||\n            x == 2\nenddef\n\ndef LambdaUsingArg(x: number): func\n  return () =>\n            # some comment\n            x == 1\n            # some comment\n            ||\n            x == 2\nenddef\n\ndef Test_expr7_lambda()\n  var lines =<< trim END\n      var La = () => 'result'\n      # comment\n      assert_equal('result', La())\n      assert_equal([1, 3, 5], [1, 2, 3]->map((key, val) => key + val))\n\n      # line continuation inside lambda with \"cond ? expr : expr\" works\n      var ll = range(3)\n      var dll = mapnew(ll, (k, v) => v % 2 ? {\n                ['111']: 111 } : {}\n            )\n      assert_equal([{}, {111: 111}, {}], dll)\n\n      # comment halfway an expression\n      var Ref = () => 4\n      # comment\n      + 6\n      assert_equal(10, Ref())\n\n      ll = range(3)\n      map(ll, (k, v) => v == 8 || v\n                    == 9\n                    || v % 2 ? 111 : 222\n            )\n      assert_equal([222, 111, 222], ll)\n\n      ll = range(3)\n      map(ll, (k, v) => v != 8 && v\n                    != 9\n                    && v % 2 == 0 ? 111 : 222\n            )\n      assert_equal([111, 222, 111], ll)\n\n      var dl = [{key: 0}, {key: 22}]->filter(( _, v) => !!v['key'] )\n      assert_equal([{key: 22}], dl)\n\n      dl = [{key: 12}, {['foo']: 34}]\n      assert_equal([{key: 12}], filter(dl,\n            (_, v) => has_key(v, 'key') ? v['key'] == 12 : 0))\n\n      assert_equal(false, LambdaWithComments()(0))\n      assert_equal(true, LambdaWithComments()(1))\n      assert_equal(true, LambdaWithComments()(2))\n      assert_equal(false, LambdaWithComments()(3))\n\n      assert_equal(false, LambdaUsingArg(0)())\n      assert_equal(true, LambdaUsingArg(1)())\n\n      var res = map([1, 2, 3], (i: number, v: number) => i + v)\n      assert_equal([1, 3, 5], res)\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  CheckDefAndScriptFailure([\"var Ref = (a)=>a + 1\"], 'E1004:')\n  CheckDefAndScriptFailure([\"var Ref = (a)=> a + 1\"], 'E1004: White space required before and after ''=>'' at \"=> a + 1\"')\n  CheckDefAndScriptFailure([\"var Ref = (a) =>a + 1\"], 'E1004:')\n  CheckDefAndScriptFailure([\"var Ref = (a) =< a + 1\"], ['E1001:', 'E121:'])\n  CheckDefAndScriptFailure([\"var Ref = (a: int) => a + 1\"], 'E1010:')\n  CheckDefAndScriptFailure([\"var Ref = (a): int => a + 1\"], 'E1010:')\n\n  CheckDefAndScriptFailure([\"filter([1, 2], (k,v) => 1)\"], 'E1069:', 1)\n  # error is in first line of the lambda\n  CheckDefAndScriptFailure([\"var L = (a) => a + b\"], 'E1001:', 0)\n\n  assert_equal('xxxyyy', 'xxx'->((a, b) => a .. b)('yyy'))\n\n  CheckDefExecFailure([\"var s = 'asdf'->((a) => a)('x')\"], 'E118:')\n  CheckDefExecFailure([\"var s = 'asdf'->((a) => a)('x', 'y')\"], 'E118:')\n  CheckDefAndScriptFailure([\"echo 'asdf'->((a) => a)(x)\"], ['E1001:', 'E121:'], 1)\n\n  CheckDefAndScriptSuccess(['var Fx = (a) => ({k1: 0,', ' k2: 1})'])\n  CheckDefAndScriptFailure(['var Fx = (a) => ({k1: 0', ' k2: 1})'], 'E722:', 2)\n  CheckDefAndScriptFailure(['var Fx = (a) => ({k1: 0,', ' k2 1})'], 'E720:', 2)\n\n  CheckDefAndScriptSuccess(['var Fx = (a) => [0,', ' 1]'])\n  CheckDefAndScriptFailure(['var Fx = (a) => [0', ' 1]'], 'E696:', 2)\n\n  # no error for existing script variable when checking for lambda\n  lines =<< trim END\n    var name = 0\n    eval (name + 2) / 3\n  END\n  CheckDefAndScriptSuccess(lines)\nenddef\n\ndef Test_expr7_lambda_block()\n  var lines =<< trim END\n      var Func = (s: string): string => {\n                      return 'hello ' .. s\n                    }\n      assert_equal('hello there', Func('there'))\n\n      var ll = range(3)\n      var dll = mapnew(ll, (k, v): string => {\n          if v % 2\n            return 'yes'\n          endif\n          return 'no'\n        })\n      assert_equal(['no', 'yes', 'no'], dll)\n\n      # ignored_inline(0, (_) => {\n      #   echo 'body'\n      # })\n\n      sandbox var Safe = (nr: number): number => {\n          return nr + 7\n        }\n      assert_equal(10, Safe(3))\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  lines =<< trim END\n      map([1, 2], (k, v) => { redrawt })\n  END\n  CheckDefAndScriptFailure(lines, 'E488')\n\n  lines =<< trim END\n      var Func = (nr: int) => {\n              echo nr\n            }\n  END\n  CheckDefAndScriptFailure(lines, 'E1010', 1)\n\n  lines =<< trim END\n      var Func = (nr: number): int => {\n              return nr\n            }\n  END\n  CheckDefAndScriptFailure(lines, 'E1010', 1)\n\n  lines =<< trim END\n      var Func = (nr: number): int => {\n              return nr\n  END\n  CheckDefFailure(lines, 'E1171', 0)  # line nr is function start\n  CheckScriptFailure(['vim9script'] + lines, 'E1171', 2)\n\n  lines =<< trim END\n      var Func = (nr: number): int => {\n          var ll =<< ENDIT\n             nothing\n  END\n  CheckDefFailure(lines, 'E1145: Missing heredoc end marker: ENDIT', 0)\n  CheckScriptFailure(['vim9script'] + lines, 'E1145: Missing heredoc end marker: ENDIT', 2)\nenddef\n\ndef NewLambdaWithComments(): func\n  return (x) =>\n            # some comment\n            x == 1\n            # some comment\n            ||\n            x == 2\nenddef\n\ndef NewLambdaUsingArg(x: number): func\n  return () =>\n            # some comment\n            x == 1\n            # some comment\n            ||\n            x == 2\nenddef\n\ndef Test_expr7_new_lambda()\n  var lines =<< trim END\n      var La = () => 'result'\n      assert_equal('result', La())\n      assert_equal([1, 3, 5], [1, 2, 3]->map((key, val) => key + val))\n\n      # line continuation inside lambda with \"cond ? expr : expr\" works\n      var ll = range(3)\n      var dll = mapnew(ll, (k, v) => v % 2 ? {\n                ['111']: 111 } : {}\n            )\n      assert_equal([{}, {111: 111}, {}], dll)\n\n      ll = range(3)\n      map(ll, (k, v) => v == 8 || v\n                    == 9\n                    || v % 2 ? 111 : 222\n            )\n      assert_equal([222, 111, 222], ll)\n\n      ll = range(3)\n      map(ll, (k, v) => v != 8 && v\n                    != 9\n                    && v % 2 == 0 ? 111 : 222\n            )\n      assert_equal([111, 222, 111], ll)\n\n      var dl = [{key: 0}, {key: 22}]->filter(( _, v) => !!v['key'] )\n      assert_equal([{key: 22}], dl)\n\n      dl = [{key: 12}, {['foo']: 34}]\n      assert_equal([{key: 12}], filter(dl,\n            (_, v) => has_key(v, 'key') ? v['key'] == 12 : 0))\n\n      assert_equal(false, NewLambdaWithComments()(0))\n      assert_equal(true, NewLambdaWithComments()(1))\n      assert_equal(true, NewLambdaWithComments()(2))\n      assert_equal(false, NewLambdaWithComments()(3))\n\n      assert_equal(false, NewLambdaUsingArg(0)())\n      assert_equal(true, NewLambdaUsingArg(1)())\n\n      var res = map([1, 2, 3], (i: number, v: number) => i + v)\n      assert_equal([1, 3, 5], res)\n\n      # Lambda returning a dict\n      var Lmb = () => ({key: 42})\n      assert_equal({key: 42}, Lmb())\n\n      var RefOne: func(number): string = (a: number): string => 'x'\n      var RefTwo: func(number): any = (a: number): any => 'x'\n\n      var Fx = (a) => ({k1: 0,\n                         k2: 1})\n      var Fy = (a) => [0,\n                       1]\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  CheckDefAndScriptFailure([\"var Ref = (a)=>a + 1\"], 'E1004:')\n  CheckDefAndScriptFailure([\"var Ref = (a)=> a + 1\"], 'E1004:')\n  CheckDefAndScriptFailure([\"var Ref = (a) =>a + 1\"],\n      'E1004: White space required before and after ''=>'' at \" =>a + 1\"')\n\n  CheckDefAndScriptFailure([\"var Ref: func(number): number = (a: number): string => 'x'\"], 'E1012:')\n  CheckDefAndScriptFailure([\"var Ref: func(number): string = (a: number): string => 99\"], 'E1012:')\n\n  CheckDefAndScriptFailure([\"filter([1, 2], (k,v) => 1)\"], 'E1069:', 1)\n  # error is in first line of the lambda\n  CheckDefAndScriptFailure([\"var L = (a) -> a + b\"], ['E1001:', 'E121:'], 1)\n\n  assert_equal('xxxyyy', 'xxx'->((a, b) => a .. b)('yyy'))\n\n  CheckDefExecFailure([\"var s = 'asdf'->((a) => a)('x')\"],\n        'E118: Too many arguments for function:')\n  CheckDefExecFailure([\"var s = 'asdf'->((a) => a)('x', 'y')\"],\n        'E118: Too many arguments for function:')\n  CheckDefFailure([\"echo 'asdf'->((a) => a)(x)\"], 'E1001:', 1)\n\n  CheckDefAndScriptFailure(['var Fx = (a) => ({k1: 0', ' k2: 1})'], 'E722:', 2)\n  CheckDefAndScriptFailure(['var Fx = (a) => ({k1: 0,', ' k2 1})'], 'E720:', 2)\n\n  CheckDefAndScriptFailure(['var Fx = (a) => [0', ' 1]'], 'E696:', 2)\nenddef\n\ndef Test_expr7_lambda_vim9script()\n  var lines =<< trim END\n      var v = 10->((a) =>\n\t    a\n\t      + 2\n            )()\n      assert_equal(12, v)\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  # nested lambda with line breaks\n  lines =<< trim END\n      search('\"', 'cW', 0, 0, () =>\n\tsynstack('.', col('.'))\n          ->mapnew((_, v) => synIDattr(v, 'name'))->len())\n  END\n  CheckDefAndScriptSuccess(lines)\nenddef\n\ndef Test_expr7_funcref()\n  var lines =<< trim END\n      def RetNumber(): number\n        return 123\n      enddef\n      var FuncRef = RetNumber\n      assert_equal(123, FuncRef())\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      func g:GlobalFunc()\n        return 'global'\n      endfunc\n      func s:ScriptFunc()\n        return 'script'\n      endfunc\n      def Test()\n        var Ref = g:GlobalFunc\n        assert_equal('global', Ref())\n        Ref = GlobalFunc\n        assert_equal('global', Ref())\n\n        Ref = s:ScriptFunc\n        assert_equal('script', Ref())\n        Ref = ScriptFunc\n        assert_equal('script', Ref())\n      enddef\n      Test()\n  END\n  CheckScriptSuccess(lines)\nenddef\n\nlet g:test_space_dict = {'': 'empty', ' ': 'space'}\nlet g:test_hash_dict = #{one: 1, two: 2}\n\ndef Test_expr7_dict()\n  # dictionary\n  var lines =<< trim END\n      assert_equal(g:dict_empty, {})\n      assert_equal(g:dict_empty, {  })\n      assert_equal(g:dict_one, {['one']: 1})\n      var key = 'one'\n      var val = 1\n      assert_equal(g:dict_one, {[key]: val})\n\n      var numbers: dict<number> = {a: 1, b: 2, c: 3}\n      numbers = {a: 1}\n      numbers = {}\n\n      var strings: dict<string> = {a: 'a', b: 'b', c: 'c'}\n      strings = {a: 'x'}\n      strings = {}\n\n      var dash = {xx-x: 8}\n      assert_equal({['xx-x']: 8}, dash)\n\n      var dnr = {8: 8}\n      assert_equal({['8']: 8}, dnr)\n\n      var mixed: dict<any> = {a: 'a', b: 42}\n      mixed = {a: 'x'}\n      mixed = {a: 234}\n      mixed = {}\n\n      var dictlist: dict<list<string>> = {absent: [], present: ['hi']}\n      dictlist = {absent: ['hi'], present: []}\n      dictlist = {absent: [], present: []}\n\n      var dictdict: dict<dict<string>> = {one: {a: 'text'}, two: {}}\n      dictdict = {one: {}, two: {a: 'text'}}\n      dictdict = {one: {}, two: {}}\n\n      assert_equal({['']: 0}, {[matchstr('string', 'wont match')]: 0})\n\n      assert_equal(g:test_space_dict, {['']: 'empty', [' ']: 'space'})\n      assert_equal(g:test_hash_dict, {one: 1, two: 2})\n\n      assert_equal({['a a']: 1, ['b/c']: 2}, {'a a': 1, \"b/c\": 2})\n\n      var d = {a: () => 3, b: () => 7}\n      assert_equal(3, d.a())\n      assert_equal(7, d.b())\n\n      var cd = { # comment\n                key: 'val' # comment\n               }\n\n      # different types used for the key\n      var dkeys = {['key']: 'string',\n                   [12]: 'numberexpr',\n                   34: 'number',\n                   [true]: 'bool'} \n      assert_equal('string', dkeys['key'])\n      assert_equal('numberexpr', dkeys[12])\n      assert_equal('number', dkeys[34])\n      assert_equal('bool', dkeys[true])\n      if has('float')\n        dkeys = {[1.2]: 'floatexpr', [3.4]: 'float'}\n        assert_equal('floatexpr', dkeys[1.2])\n        assert_equal('float', dkeys[3.4])\n      endif\n\n      # automatic conversion from number to string\n      var n = 123\n      var dictnr = {[n]: 1}\n\n      # comment to start fold is OK\n      var x1: number #{{ fold\n      var x2 = 9 #{{ fold\n  END\n  CheckDefAndScriptSuccess(lines)\n \n  # legacy syntax doesn't work\n  CheckDefAndScriptFailure([\"var x = #{key: 8}\"], 'E1170:', 1)\n  CheckDefAndScriptFailure([\"var x = 'a' #{a: 1}\"], 'E1170:', 1)\n  CheckDefAndScriptFailure([\"var x = 'a' .. #{a: 1}\"], 'E1170:', 1)\n  CheckDefAndScriptFailure([\"var x = true ? #{a: 1}\"], 'E1170:', 1)\n\n  CheckDefAndScriptFailure([\"var x = {a:8}\"], 'E1069:', 1)\n  CheckDefAndScriptFailure([\"var x = {a : 8}\"], 'E1068:', 1)\n  CheckDefAndScriptFailure([\"var x = {a :8}\"], 'E1068:', 1)\n  CheckDefAndScriptFailure([\"var x = {a: 8 , b: 9}\"], 'E1068:', 1)\n  CheckDefAndScriptFailure([\"var x = {a: 1,b: 2}\"], 'E1069:', 1)\n\n  CheckDefAndScriptFailure([\"var x = {xxx}\"], 'E720:', 1)\n  CheckDefAndScriptFailure([\"var x = {xxx: 1\", \"var y = 2\"], 'E722:', 2)\n  CheckDefFailure([\"var x = {xxx: 1,\"], 'E723:', 2)\n  CheckScriptFailure(['vim9script', \"var x = {xxx: 1,\"], 'E723:', 2)\n  CheckDefAndScriptFailure([\"var x = {['a']: xxx}\"], ['E1001:', 'E121:'], 1)\n  CheckDefAndScriptFailure([\"var x = {a: 1, a: 2}\"], 'E721:', 1)\n  CheckDefExecAndScriptFailure([\"var x = g:anint.member\"], ['E715:', 'E488:'], 1)\n  CheckDefExecAndScriptFailure([\"var x = g:dict_empty.member\"], 'E716:', 1)\n\n  CheckDefExecAndScriptFailure(['var x: dict<number> = {a: 234, b: \"1\"}'], 'E1012:', 1)\n  CheckDefExecAndScriptFailure(['var x: dict<number> = {a: \"x\", b: 134}'], 'E1012:', 1)\n  CheckDefExecAndScriptFailure(['var x: dict<string> = {a: 234, b: \"1\"}'], 'E1012:', 1)\n  CheckDefExecAndScriptFailure(['var x: dict<string> = {a: \"x\", b: 134}'], 'E1012:', 1)\n\n  # invalid types for the key\n  CheckDefAndScriptFailure([\"var x = {[[1, 2]]: 0}\"], ['E1105:', 'E730:'], 1)\n\n  CheckDefFailure(['var x = ({'], 'E723:', 2)\n  CheckScriptFailure(['vim9script', 'var x = ({'], 'E723:', 2)\n  CheckDefExecAndScriptFailure(['{}[getftype(\"file\")]'], 'E716: Key not present in Dictionary: \"\"', 1)\nenddef\n\ndef Test_expr7_dict_vim9script()\n  var lines =<< trim END\n      var d = {\n\t\t['one']:\n\t\t   1,\n\t\t['two']: 2,\n\t\t   }\n      assert_equal({one: 1, two: 2}, d)\n\n      d = {  # comment\n\t\t['one']:\n                # comment\n\n\t\t   1,\n                # comment\n                # comment\n\t\t['two']: 2,\n\t\t   }\n      assert_equal({one: 1, two: 2}, d)\n\n      var dd = {k: 123->len()}\n      assert_equal(3, dd.k)\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  lines =<< trim END\n      var d = { [\"one\"]: \"one\", [\"two\"]: \"two\", }\n      assert_equal({one: 'one', two: 'two'}, d)\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  lines =<< trim END\n      var d = {one: 1,\n\t\ttwo: 2,\n\t       }\n      assert_equal({one: 1, two: 2}, d)\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  lines =<< trim END\n      var d = {one:1, two: 2}\n  END\n  CheckDefAndScriptFailure(lines, 'E1069:', 1)\n\n  lines =<< trim END\n      var d = {one: 1,two: 2}\n  END\n  CheckDefAndScriptFailure(lines, 'E1069:', 1)\n\n  lines =<< trim END\n      var d = {one : 1}\n  END\n  CheckDefAndScriptFailure(lines, 'E1068:', 1)\n\n  lines =<< trim END\n      var d = {one:1}\n  END\n  CheckDefAndScriptFailure(lines, 'E1069:', 1)\n\n  lines =<< trim END\n      var d = {one: 1 , two: 2}\n  END\n  CheckDefAndScriptFailure(lines, 'E1068:', 1)\n\n  lines =<< trim END\n    var l: dict<number> = {a: 234, b: 'x'}\n  END\n  CheckDefAndScriptFailure(lines, 'E1012:', 1)\n\n  lines =<< trim END\n    var l: dict<number> = {a: 'x', b: 234}\n  END\n  CheckDefAndScriptFailure(lines, 'E1012:', 1)\n\n  lines =<< trim END\n    var l: dict<string> = {a: 'x', b: 234}\n  END\n  CheckDefAndScriptFailure(lines, 'E1012:', 1)\n\n  lines =<< trim END\n    var l: dict<string> = {a: 234, b: 'x'}\n  END\n  CheckDefAndScriptFailure(lines, 'E1012:', 1)\n\n  lines =<< trim END\n    var d = {['a']: 234, ['b': 'x'}\n  END\n  CheckDefAndScriptFailure(lines, 'E1139:', 1)\n\n  lines =<< trim END\n    def Func()\n      var d = {['a']: 234, ['b': 'x'}\n    enddef\n    defcompile\n  END\n  CheckDefAndScriptFailure(lines, 'E1139:', 0)\n\n  lines =<< trim END\n    var d = {'a':\n  END\n  CheckDefFailure(lines, 'E723:', 2)\n  CheckScriptFailure(['vim9script'] + lines, 'E15:', 2)\n\n  lines =<< trim END\n    def Func()\n      var d = {'a':\n    enddef\n    defcompile\n  END\n  CheckDefAndScriptFailure(lines, 'E723:', 0)\n\n  lines =<< trim END\n      def Failing()\n        job_stop()\n      enddef\n      var dict = {name: Failing}\n  END\n  if has('channel')\n    CheckDefAndScriptFailure(lines, 'E119:', 0)\n  else\n    CheckDefAndScriptFailure(lines, 'E117:', 0)\n  endif\n\n  lines =<< trim END\n      vim9script\n      var x = 99\n      assert_equal({x: 99}, s:)\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Test_expr7_dict_in_block()\n  var lines =<< trim END\n      vim9script\n      command MyCommand {\n          echo {\n              k: 0, }\n      }\n      MyCommand\n\n      command YourCommand {\n         g:global = {\n           key: 'value' }\n         }\n      YourCommand\n      assert_equal({key: 'value'}, g:global)\n      unlet g:global\n  END\n  CheckScriptSuccess(lines)\n\n  delcommand MyCommand\n  delcommand YourCommand\nenddef\n\ndef Test_expr7_call_2bool()\n  var lines =<< trim END\n      vim9script\n\n      def BrokenCall(nr: number, mode: bool, use: string): void\n        assert_equal(3, nr)\n        assert_equal(false, mode)\n        assert_equal('ab', use)\n      enddef\n\n      def TestBrokenCall(): void\n        BrokenCall(3, 0, 'ab')\n      enddef\n\n      TestBrokenCall()\n  END\n  CheckScriptSuccess(lines)\nenddef\n\nlet g:oneString = 'one'\n\ndef Test_expr_member()\n  var lines =<< trim END\n      assert_equal(1, g:dict_one.one)\n      var d: dict<number> = g:dict_one\n      assert_equal(1, d['one'])\n      assert_equal(1, d[\n                      'one'\n                      ])\n      assert_equal(1, d\n            .one)\n      d = {1: 1, _: 2}\n      assert_equal(1, d\n            .1)\n      assert_equal(2, d\n            ._)\n\n      # getting the one member should clear the dict after getting the item\n      assert_equal('one', {one: 'one'}.one)\n      assert_equal('one', {one: 'one'}[g:oneString])\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  CheckDefAndScriptFailure([\"var x = g:dict_one.#$!\"], ['E1002:', 'E15:'], 1)\n  CheckDefExecAndScriptFailure([\"var d: dict<any>\", \"echo d['a']\"], 'E716:', 2)\n  CheckDefExecAndScriptFailure([\"var d: dict<number>\", \"d = g:list_empty\"], 'E1012: Type mismatch; expected dict<number> but got list<unknown>', 2)\nenddef\n\ndef Test_expr7_any_index_slice()\n  var lines =<< trim END\n    # getting the one member should clear the list only after getting the item\n    assert_equal('bbb', ['aaa', 'bbb', 'ccc'][1])\n\n    # string is permissive, index out of range accepted\n    g:teststring = 'abcdef'\n    assert_equal('b', g:teststring[1])\n    assert_equal('f', g:teststring[-1])\n    assert_equal('', g:teststring[99])\n\n    assert_equal('b', g:teststring[1 : 1])\n    assert_equal('bcdef', g:teststring[1 :])\n    assert_equal('abcd', g:teststring[: 3])\n    assert_equal('cdef', g:teststring[-4 :])\n    assert_equal('abcdef', g:teststring[-9 :])\n    assert_equal('abcd', g:teststring[: -3])\n    assert_equal('', g:teststring[: -9])\n\n    # composing characters are included\n    g:teststring = 'a\u0300e\u0301u\u0302'\n    assert_equal('a\u0300', g:teststring[0])\n    assert_equal('e\u0301', g:teststring[1])\n    assert_equal('u\u0302', g:teststring[2])\n    assert_equal('', g:teststring[3])\n    assert_equal('', g:teststring[4])\n\n    assert_equal('u\u0302', g:teststring[-1])\n    assert_equal('e\u0301', g:teststring[-2])\n    assert_equal('a\u0300', g:teststring[-3])\n    assert_equal('', g:teststring[-4])\n    assert_equal('', g:teststring[-5])\n\n    assert_equal('a\u0300', g:teststring[0 : 0])\n    assert_equal('e\u0301', g:teststring[1 : 1])\n    assert_equal('a\u0300e\u0301', g:teststring[0 : 1])\n    assert_equal('a\u0300e\u0301u\u0302', g:teststring[0 : -1])\n    assert_equal('a\u0300e\u0301', g:teststring[0 : -2])\n    assert_equal('a\u0300', g:teststring[0 : -3])\n    assert_equal('', g:teststring[0 : -4])\n    assert_equal('', g:teststring[0 : -5])\n    assert_equal('a\u0300e\u0301u\u0302', g:teststring[ : ])\n    assert_equal('a\u0300e\u0301u\u0302', g:teststring[0 : ])\n    assert_equal('e\u0301u\u0302', g:teststring[1 : ])\n    assert_equal('u\u0302', g:teststring[2 : ])\n    assert_equal('', g:teststring[3 : ])\n    assert_equal('', g:teststring[4 : ])\n\n    # blob index cannot be out of range\n    g:testblob = 0z01ab\n    assert_equal(0x01, g:testblob[0])\n    assert_equal(0xab, g:testblob[1])\n    assert_equal(0xab, g:testblob[-1])\n    assert_equal(0x01, g:testblob[-2])\n\n    # blob slice accepts out of range\n    assert_equal(0z01ab, g:testblob[0 : 1])\n    assert_equal(0z01, g:testblob[0 : 0])\n    assert_equal(0z01, g:testblob[-2 : -2])\n    assert_equal(0zab, g:testblob[1 : 1])\n    assert_equal(0zab, g:testblob[-1 : -1])\n    assert_equal(0z, g:testblob[2 : 2])\n    assert_equal(0z, g:testblob[0 : -3])\n\n    # list index cannot be out of range\n    g:testlist = [0, 1, 2, 3]\n    assert_equal(0, g:testlist[0])\n    assert_equal(1, g:testlist[1])\n    assert_equal(3, g:testlist[3])\n    assert_equal(3, g:testlist[-1])\n    assert_equal(0, g:testlist[-4])\n    assert_equal(1, g:testlist[g:theone])\n\n    # list slice accepts out of range\n    assert_equal([0], g:testlist[0 : 0])\n    assert_equal([3], g:testlist[3 : 3])\n    assert_equal([0, 1], g:testlist[0 : 1])\n    assert_equal([0, 1, 2, 3], g:testlist[0 : 3])\n    assert_equal([0, 1, 2, 3], g:testlist[0 : 9])\n    assert_equal([], g:testlist[-1 : 1])\n    assert_equal([1], g:testlist[-3 : 1])\n    assert_equal([0, 1], g:testlist[-4 : 1])\n    assert_equal([0, 1], g:testlist[-9 : 1])\n    assert_equal([1, 2, 3], g:testlist[1 : -1])\n    assert_equal([1], g:testlist[1 : -3])\n    assert_equal([], g:testlist[1 : -4])\n    assert_equal([], g:testlist[1 : -9])\n\n    g:testdict = {a: 1, b: 2}\n    assert_equal(1, g:testdict['a'])\n    assert_equal(2, g:testdict['b'])\n  END\n\n  CheckDefAndScriptSuccess(lines)\n\n  CheckDefExecAndScriptFailure(['echo g:testblob[2]'], 'E979:', 1)\n  CheckDefExecAndScriptFailure(['echo g:testblob[-3]'], 'E979:', 1)\n\n  CheckDefExecAndScriptFailure(['echo g:testlist[4]'], 'E684: list index out of range: 4', 1)\n  CheckDefExecAndScriptFailure(['echo g:testlist[-5]'], 'E684:', 1)\n\n  CheckDefExecAndScriptFailure(['echo g:testdict[\"a\" : \"b\"]'], 'E719:', 1)\n  CheckDefExecAndScriptFailure(['echo g:testdict[1]'], 'E716:', 1)\n\n  unlet g:teststring\n  unlet g:testblob\n  unlet g:testlist\nenddef\n\ndef Test_expr_member_vim9script()\n  var lines =<< trim END\n      var d = {one:\n      \t\t'one',\n\t\ttwo: 'two',\n\t\t1: 1,\n\t\t_: 2}\n      assert_equal('one', d.one)\n      assert_equal('one', d\n                            .one)\n      assert_equal(1, d\n                            .1)\n      assert_equal(2, d\n                            ._)\n      assert_equal('one', d[\n\t\t\t    'one'\n\t\t\t    ])\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  lines =<< trim END\n      var l = [1,\n\t\t  2,\n\t\t  3, 4\n\t\t  ]\n      assert_equal(2, l[\n\t\t\t    1\n\t\t\t    ])\n      assert_equal([2, 3], l[1 : 2])\n      assert_equal([1, 2, 3], l[\n\t\t\t\t:\n\t\t\t\t2\n\t\t\t\t])\n      assert_equal([3, 4], l[\n\t\t\t\t2\n\t\t\t\t:\n\t\t\t\t])\n  END\n  CheckDefAndScriptSuccess(lines)\nenddef\n\ndef SetSomeVar()\n  b:someVar = &fdm\nenddef\n\ndef Test_expr7_option()\n  var lines =<< trim END\n      # option\n      set ts=11\n      assert_equal(11, &ts)\n      &ts = 9\n      assert_equal(9, &ts)\n      set ts=8\n      set grepprg=some\\ text\n      assert_equal('some text', &grepprg)\n      &grepprg = test_null_string()\n      assert_equal('', &grepprg)\n      set grepprg&\n\n      # check matching type\n      var bval: bool = &tgc\n      var nval: number = &ts\n      var sval: string = &path\n\n      # check v_lock is cleared (requires using valgrind, doesn't always show)\n      SetSomeVar()\n      b:someVar = 0\n      unlet b:someVar\n  END\n  CheckDefAndScriptSuccess(lines)\nenddef\n\ndef Test_expr7_environment()\n  var lines =<< trim END\n      # environment variable\n      assert_equal('testvar', $TESTVAR)\n      assert_equal('', $ASDF_ASD_XXX)\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  CheckDefAndScriptFailure([\"var x = $$$\"], ['E1002:', 'E15:'], 1)\n  CheckDefAndScriptFailure([\"$\"], ['E1002:', 'E15:'], 1)\nenddef\n\ndef Test_expr7_register()\n  var lines =<< trim END\n      @a = 'register a'\n      assert_equal('register a', @a)\n\n      var fname = expand('%')\n      assert_equal(fname, @%)\n\n      feedkeys(\":echo 'some'\\<CR>\", \"xt\")\n      assert_equal(\"echo 'some'\", @:)\n\n      normal axyz\n      assert_equal(\"xyz\", @.)\n\n      @/ = 'slash'\n      assert_equal('slash', @/)\n\n      @= = 'equal'\n      assert_equal('equal', @=)\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  CheckDefAndScriptFailure([\"@. = 'yes'\"], ['E354:', 'E488:'], 1)\nenddef\n\n\" This is slow when run under valgrind.\ndef Test_expr7_namespace()\n  var lines =<< trim END\n      g:some_var = 'some'\n      assert_equal('some', get(g:, 'some_var'))\n      assert_equal('some', get(g:, 'some_var', 'xxx'))\n      assert_equal('xxx', get(g:, 'no_var', 'xxx'))\n      unlet g:some_var\n\n      b:some_var = 'some'\n      assert_equal('some', get(b:, 'some_var'))\n      assert_equal('some', get(b:, 'some_var', 'xxx'))\n      assert_equal('xxx', get(b:, 'no_var', 'xxx'))\n      unlet b:some_var\n\n      w:some_var = 'some'\n      assert_equal('some', get(w:, 'some_var'))\n      assert_equal('some', get(w:, 'some_var', 'xxx'))\n      assert_equal('xxx', get(w:, 'no_var', 'xxx'))\n      unlet w:some_var\n\n      t:some_var = 'some'\n      assert_equal('some', get(t:, 'some_var'))\n      assert_equal('some', get(t:, 'some_var', 'xxx'))\n      assert_equal('xxx', get(t:, 'no_var', 'xxx'))\n      unlet t:some_var\n  END\n  CheckDefAndScriptSuccess(lines)\nenddef\n\ndef Test_expr7_namespace_loop_def()\n  var lines =<< trim END\n      # check using g: in a for loop more than DO_NOT_FREE_CNT times\n      var exists = 0\n      var exists_not = 0\n      for i in range(100000)\n        if has_key(g:, 'does-not-exist')\n          exists += 1\n        else\n          exists_not += 1\n        endif\n      endfor\n      assert_equal(0, exists)\n      assert_equal(100000, exists_not)\n  END\n  CheckDefSuccess(lines)\nenddef\n\n\" NOTE: this is known to be slow.  To skip use:\n\"   :let $TEST_SKIP_PAT = 'Test_expr7_namespace_loop_script'\ndef Test_expr7_namespace_loop_script()\n  var lines =<< trim END\n      vim9script\n      # check using g: in a for loop more than DO_NOT_FREE_CNT times\n      var exists = 0\n      var exists_not = 0\n      for i in range(100000)\n        if has_key(g:, 'does-not-exist')\n          exists += 1\n        else\n          exists_not += 1\n        endif\n      endfor\n      assert_equal(0, exists)\n      assert_equal(100000, exists_not)\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Test_expr7_parens()\n  # (expr)\n  var lines =<< trim END\n      assert_equal(4, (6 * 4) / 6)\n      assert_equal(0, 6 * ( 4 / 6 ))\n\n      assert_equal(6, +6)\n      assert_equal(-6, -6)\n      assert_equal(false, !-3)\n      assert_equal(true, !+0)\n\n      assert_equal(7, 5 + (\n                    2))\n      assert_equal(7, 5 + (\n                    2\n                    ))\n      assert_equal(7, 5 + ( # comment\n                    2))\n      assert_equal(7, 5 + ( # comment\n                    # comment\n                    2))\n\n      var s = (\n\t\t'one'\n\t\t..\n\t\t'two'\n\t\t)\n      assert_equal('onetwo', s)\n  END\n  CheckDefAndScriptSuccess(lines)\nenddef\n\ndef Test_expr7_negate_add()\n  var lines =<< trim END\n      assert_equal(-99, -99)\n      assert_equal(-99, - 99)\n      assert_equal(99, +99)\n\n      var nr = 88\n      assert_equal(-88, -nr)\n      assert_equal(-88, - nr)\n      assert_equal(88, + nr)\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  lines =<< trim END\n    var n = 12\n    echo ++n\n  END\n  CheckDefAndScriptFailure(lines, 'E15:')\n  lines =<< trim END\n    var n = 12\n    echo --n\n  END\n  CheckDefAndScriptFailure(lines, 'E15:')\n  lines =<< trim END\n    var n = 12\n    echo +-n\n  END\n  CheckDefAndScriptFailure(lines, 'E15:')\n  lines =<< trim END\n    var n = 12\n    echo -+n\n  END\n  CheckDefAndScriptFailure(lines, 'E15:')\n  lines =<< trim END\n    var n = 12\n    echo - -n\n  END\n  CheckDefAndScriptFailure(lines, 'E15:')\n  lines =<< trim END\n    var n = 12\n    echo + +n\n  END\n  CheckDefAndScriptFailure(lines, 'E15:')\nenddef\n\ndef LegacyReturn(): string\n  legacy return #{key: 'ok'}.key\nenddef\n\ndef Test_expr7_legacy_script()\n  var lines =<< trim END\n      let s:legacy = 'legacy'\n      def GetLocal(): string\n        return legacy\n      enddef\n      def GetLocalPrefix(): string\n        return s:legacy\n      enddef\n      call assert_equal('legacy', GetLocal())\n      call assert_equal('legacy', GetLocalPrefix())\n  END\n  CheckScriptSuccess(lines)\n\n  assert_equal('ok', LegacyReturn())\n\n  lines =<< trim END\n      vim9script \n      def GetNumber(): number   \n          legacy return range(3)->map('v:val + 1') \n      enddef \n      echo GetNumber()\n  END\n  CheckScriptFailure(lines, 'E1012: Type mismatch; expected number but got list<number>')\nenddef\n\ndef Echo(arg: any): string\n  return arg\nenddef\n\ndef s:Echo4Arg(arg: any): string\n  return arg\nenddef\n\ndef Test_expr7_call()\n  var lines =<< trim END\n      assert_equal('yes', 'yes'->Echo())\n      assert_equal(true, !range(5)->empty())\n      assert_equal([0, 1, 2], 3->range())\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  assert_equal('yes', 'yes'\n                        ->s:Echo4Arg())\n\n  CheckDefAndScriptFailure([\"var x = 'yes'->Echo\"], 'E107:', 1)\n  CheckDefAndScriptFailure([\n       \"var x = substitute ('x', 'x', 'x', 'x')\"\n       ], ['E1001:', 'E121:'], 1)\n  CheckDefAndScriptFailure([\"var Ref = function('len' [1, 2])\"], ['E1123:', 'E116:'], 1)\n\n  var auto_lines =<< trim END\n      def g:some#func(): string\n\treturn 'found'\n      enddef\n  END\n  mkdir('Xruntime/autoload', 'p')\n  writefile(auto_lines, 'Xruntime/autoload/some.vim')\n  var save_rtp = &rtp\n  &rtp = getcwd() .. '/Xruntime,' .. &rtp\n  assert_equal('found', g:some#func())\n  assert_equal('found', some#func())\n\n  &rtp = save_rtp\n  delete('Xruntime', 'rf')\nenddef\n\ndef Test_expr7_method_call()\n  var lines =<< trim END\n      new\n      setline(1, ['first', 'last'])\n      'second'->append(1)\n      \"third\"->append(2)\n      assert_equal(['first', 'second', 'third', 'last'], getline(1, '$'))\n      bwipe!\n\n      var bufnr = bufnr()\n      var loclist = [{bufnr: bufnr, lnum: 42, col: 17, text: 'wrong'}]\n      loclist->setloclist(0)\n      assert_equal([{bufnr: bufnr,\n                    lnum: 42,\n                    end_lnum: 0,\n                    col: 17,\n                    end_col: 0,\n                    text: 'wrong',\n                    pattern: '',\n                    valid: 1,\n                    vcol: 0,\n                    nr: 0,\n                    type: '',\n                    module: ''}\n                    ], getloclist(0))\n\n      var result: bool = get({n: 0}, 'n', 0)\n      assert_equal(false, result)\n\n      assert_equal('+string+', 'string'->((s) => '+' .. s .. '+')())\n      assert_equal('-text-', 'text'->((s, c) => c .. s .. c)('-'))\n\n      var Join = (l) => join(l, 'x')\n      assert_equal('axb', ['a', 'b']->(Join)())\n      \n      var sorted = [3, 1, 2]\n                    -> sort()\n      assert_equal([1, 2, 3], sorted)\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  lines =<< trim END\n    def RetVoid()\n    enddef\n    RetVoid()->byteidx(3)\n  END\n  CheckDefExecFailure(lines, 'E1013:')\nenddef\n\n\ndef Test_expr7_not()\n  var lines =<< trim END\n      assert_equal(true, !'')\n      assert_equal(true, ![])\n      assert_equal(false, !'asdf')\n      assert_equal(false, ![2])\n      assert_equal(true, !!'asdf')\n      assert_equal(true, !![2])\n\n      assert_equal(true, ! false)\n      assert_equal(true, !! true)\n      assert_equal(true, ! ! true)\n      assert_equal(true, !!! false)\n      assert_equal(true, ! ! ! false)\n\n      g:true = true\n      g:false = false\n      assert_equal(true, ! g:false)\n      assert_equal(true, !! g:true)\n      assert_equal(true, ! ! g:true)\n      assert_equal(true, !!! g:false)\n      assert_equal(true, ! ! ! g:false)\n      unlet g:true\n      unlet g:false\n\n      assert_equal(true, !test_null_partial())\n      assert_equal(false, !() => 'yes')\n\n      assert_equal(true, !test_null_dict())\n      assert_equal(true, !{})\n      assert_equal(false, !{yes: 'no'})\n\n      if has('channel')\n\tassert_equal(true, !test_null_job())\n\tassert_equal(true, !test_null_channel())\n      endif\n\n      assert_equal(true, !test_null_blob())\n      assert_equal(true, !0z)\n      assert_equal(false, !0z01)\n\n      assert_equal(true, !test_void())\n      assert_equal(true, !test_unknown())\n\n      assert_equal(false, ![1, 2, 3]->reverse())\n      assert_equal(true, ![]->reverse())\n  END\n  CheckDefAndScriptSuccess(lines)\nenddef\n\nlet g:anumber = 42\n\ndef Test_expr7_negate()\n  var lines =<< trim END\n      var nr = 1\n      assert_equal(-1, -nr)\n      assert_equal(-42, -g:anumber)\n  END\n  CheckDefAndScriptSuccess(lines)\nenddef\n\nfunc Test_expr7_fails()\n  call CheckDefFailure([\"var x = (12\"], \"E1097:\", 3)\n  call CheckScriptFailure(['vim9script', \"var x = (12\"], 'E110:', 2)\n\n  call CheckDefAndScriptFailure([\"var x = -'xx'\"], \"E1030:\", 1)\n  call CheckDefAndScriptFailure([\"var x = +'xx'\"], \"E1030:\", 1)\n  call CheckDefAndScriptFailure([\"var x = -0z12\"], \"E974:\", 1)\n  call CheckDefExecAndScriptFailure([\"var x = -[8]\"], [\"E1012:\", 'E745:'], 1)\n  call CheckDefExecAndScriptFailure([\"var x = -{a: 1}\"], [\"E1012:\", 'E728:'], 1)\n\n  call CheckDefAndScriptFailure([\"var x = @\"], \"E1002:\", 1)\n  call CheckDefAndScriptFailure([\"var x = @<\"], \"E354:\", 1)\n\n  call CheckDefFailure([\"var x = [1, 2\"], \"E697:\", 2)\n  call CheckScriptFailure(['vim9script', \"var x = [1, 2\"], 'E696:', 2)\n\n  call CheckDefAndScriptFailure([\"var x = [notfound]\"], [\"E1001:\", 'E121:'], 1)\n\n  call CheckDefAndScriptFailure([\"var X = () => 123)\"], 'E488:', 1)\n  call CheckDefAndScriptFailure([\"var x = 123->((x) => x + 5)\"], \"E107:\", 1)\n\n  call CheckDefAndScriptFailure([\"var x = &notexist\"], 'E113:', 1)\n  call CheckDefAndScriptFailure([\"&grepprg = [343]\"], ['E1012:', 'E730:'], 1)\n\n  call CheckDefExecAndScriptFailure([\"echo s:doesnt_exist\"], 'E121:', 1)\n  call CheckDefExecAndScriptFailure([\"echo g:doesnt_exist\"], 'E121:', 1)\n\n  call CheckDefAndScriptFailure([\"echo a:somevar\"], ['E1075:', 'E121:'], 1)\n  call CheckDefAndScriptFailure([\"echo l:somevar\"], ['E1075:', 'E121:'], 1)\n  call CheckDefAndScriptFailure([\"echo x:somevar\"], ['E1075:', 'E121:'], 1)\n\n  call CheckDefExecAndScriptFailure([\"var x = +g:astring\"], ['E1012:', 'E1030:'], 1)\n  call CheckDefExecAndScriptFailure([\"var x = +g:ablob\"], ['E1012:', 'E974:'], 1)\n  call CheckDefExecAndScriptFailure([\"var x = +g:alist\"], ['E1012:', 'E745:'], 1)\n  call CheckDefExecAndScriptFailure([\"var x = +g:adict\"], ['E1012:', 'E728:'], 1)\n\n  call CheckDefAndScriptFailure([\"var x = ''\", \"var y = x.memb\"], ['E1229: Expected dictionary for using key \"memb\", but got string', 'E488:'], 2)\n\n  call CheckDefAndScriptFailure([\"'yes'->\", \"Echo()\"], ['E488: Trailing characters: ->', 'E260: Missing name after ->'], 1)\n\n  call CheckDefExecFailure([\"[1, 2->len()\"], 'E697:', 2)\n  call CheckScriptFailure(['vim9script', \"[1, 2->len()\"], 'E696:', 2)\n\n  call CheckDefFailure([\"{a: 1->len()\"], 'E723:', 2)\n  call CheckScriptFailure(['vim9script', \"{a: 1->len()\"], 'E722:', 2)\n\n  call CheckDefExecFailure([\"{['a']: 1->len()\"], 'E723:', 2)\n  call CheckScriptFailure(['vim9script', \"{['a']: 1->len()\"], 'E722:', 2)\nendfunc\n\nlet g:Funcrefs = [function('add')]\n\nfunc CallMe(arg)\n  return a:arg\nendfunc\n\nfunc CallMe2(one, two)\n  return a:one .. a:two\nendfunc\n\ndef Test_expr7_trailing()\n  var lines =<< trim END\n      # user function call\n      assert_equal(123, g:CallMe(123))\n      assert_equal(123, g:CallMe(  123))\n      assert_equal(123, g:CallMe(123  ))\n      assert_equal('yesno', g:CallMe2('yes', 'no'))\n      assert_equal('yesno', g:CallMe2( 'yes', 'no' ))\n      assert_equal('nothing', g:CallMe('nothing'))\n\n      # partial call\n      var Part = function('g:CallMe')\n      assert_equal('yes', Part('yes'))\n\n      # funcref call, using list index\n      var l = []\n      g:Funcrefs[0](l, 2)\n      assert_equal([2], l)\n\n      # method call\n      l = [2, 5, 6]\n      l->map((k, v) => k + v)\n      assert_equal([2, 6, 8], l)\n\n      # lambda method call\n      l = [2, 5]\n      l->((ll) => add(ll, 8))()\n      assert_equal([2, 5, 8], l)\n\n      # dict member\n      var d = {key: 123}\n      assert_equal(123, d.key)\n  END\n  CheckDefAndScriptSuccess(lines)\nenddef\n\ndef Test_expr7_string_subscript()\n  var lines =<< trim END\n    var text = 'abcdef'\n    assert_equal('f', text[-1])\n    assert_equal('a', text[0])\n    assert_equal('e', text[4])\n    assert_equal('f', text[5])\n    assert_equal('', text[6])\n\n    text = '\u00e1b\u00e7d\u00eb'\n    assert_equal('\u00eb', text[-1])\n    assert_equal('d', text[-2])\n    assert_equal('\u00e7', text[-3])\n    assert_equal('b', text[-4])\n    assert_equal('\u00e1', text[-5])\n    assert_equal('', text[-6])\n\n    text = '\u00e1b\u00e7d\u00ebf'\n    assert_equal('', text[-999])\n    assert_equal('f', text[-1])\n    assert_equal('\u00e1', text[0])\n    assert_equal('b', text[1])\n    assert_equal('\u00e7', text[2])\n    assert_equal('d', text[3])\n    assert_equal('\u00eb', text[4])\n    assert_equal('f', text[5])\n    assert_equal('', text[6])\n    assert_equal('', text[999])\n\n    assert_equal('\u00e1b\u00e7d\u00ebf', text[0 : -1])\n    assert_equal('\u00e1b\u00e7d\u00ebf', text[0 : -1])\n    assert_equal('\u00e1b\u00e7d\u00ebf', text[0 : -1])\n    assert_equal('\u00e1b\u00e7d\u00ebf', text[0 : -1])\n    assert_equal('\u00e1b\u00e7d\u00ebf', text[0\n                  : -1])\n    assert_equal('\u00e1b\u00e7d\u00ebf', text[0 :\n                  -1])\n    assert_equal('\u00e1b\u00e7d\u00ebf', text[0 : -1\n                  ])\n    assert_equal('b\u00e7d\u00ebf', text[1 : -1])\n    assert_equal('\u00e7d\u00ebf', text[2 : -1])\n    assert_equal('d\u00ebf', text[3 : -1])\n    assert_equal('\u00ebf', text[4 : -1])\n    assert_equal('f', text[5 : -1])\n    assert_equal('', text[6 : -1])\n    assert_equal('', text[999 : -1])\n\n    assert_equal('\u00e1b\u00e7d', text[: 3])\n    assert_equal('b\u00e7d\u00ebf', text[1 :])\n    assert_equal('\u00e1b\u00e7d\u00ebf', text[:])\n\n    assert_equal('a', g:astring[0])\n    assert_equal('sd', g:astring[1 : 2])\n    assert_equal('asdf', g:astring[:])\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  lines =<< trim END\n      var d = 'asdf'[1 :\n  END\n  CheckDefFailure(lines, 'E1097:', 3)\n  CheckScriptFailure(['vim9script'] + lines, 'E15:', 2)\n\n  lines =<< trim END\n      var d = 'asdf'[1 : xxx]\n  END\n  CheckDefAndScriptFailure(lines, ['E1001:', 'E121:'], 1)\n\n  lines =<< trim END\n      var d = 'asdf'[1 : 2\n  END\n  CheckDefFailure(lines, 'E1097:', 3)\n  CheckScriptFailure(['vim9script'] + lines, 'E111:', 2)\n\n  lines =<< trim END\n      var d = 'asdf'[1 : 2\n      echo d\n  END\n  CheckDefAndScriptFailure(lines, 'E111:', 2)\n\n  lines =<< trim END\n      var d = 'asdf'['1']\n      echo d\n  END\n  CheckDefAndScriptFailure(lines, ['E1012: Type mismatch; expected number but got string', 'E1030: Using a String as a Number: \"1\"'], 1)\n\n  lines =<< trim END\n      var d = 'asdf'['1' : 2]\n      echo d\n  END\n  CheckDefAndScriptFailure(lines, ['E1012: Type mismatch; expected number but got string', 'E1030: Using a String as a Number: \"1\"'], 1)\n\n  lines =<< trim END\n      var d = 'asdf'[1 : '2']\n      echo d\n  END\n  CheckDefAndScriptFailure(lines, ['E1012: Type mismatch; expected number but got string', 'E1030: Using a String as a Number: \"2\"'], 1)\nenddef\n\ndef Test_expr7_list_subscript()\n  var lines =<< trim END\n      var list = [0, 1, 2, 3, 4]\n      assert_equal(0, list[0])\n      assert_equal(4, list[4])\n      assert_equal(4, list[-1])\n      assert_equal(0, list[-5])\n\n      assert_equal([0, 1, 2, 3, 4], list[0 : 4])\n      assert_equal([0, 1, 2, 3, 4], list[:])\n      assert_equal([1, 2, 3, 4], list[1 :])\n      assert_equal([2, 3, 4], list[2 : -1])\n      assert_equal([4], list[4 : -1])\n      assert_equal([], list[5 : -1])\n      assert_equal([], list[999 : -1])\n      assert_equal([1, 2, 3, 4], list[g:theone : g:thefour])\n\n      assert_equal([0, 1, 2, 3], list[0 : 3])\n      assert_equal([0], list[0 : 0])\n      assert_equal([0, 1, 2, 3, 4], list[0 : -1])\n      assert_equal([0, 1, 2], list[0 : -3])\n      assert_equal([0], list[0 : -5])\n      assert_equal([], list[0 : -6])\n      assert_equal([], list[0 : -99])\n\n      assert_equal(2, g:alist[0])\n      assert_equal([2, 3, 4], g:alist[:])\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  lines = ['var l = [0, 1, 2]', 'echo l[g:astring : g:theone]']\n  CheckDefExecAndScriptFailure(lines, ['E1012:', 'E1030:'], 2)\n\n  lines =<< trim END\n      var ld = []\n      def Func()\n        eval ld[0].key\n      enddef\n      defcompile\n  END\n  CheckDefAndScriptSuccess(lines)\nenddef\n\ndef Test_expr7_dict_subscript()\n  var lines =<< trim END\n      var l = [{lnum: 2}, {lnum: 1}]\n      var res = l[0].lnum > l[1].lnum\n      assert_true(res)\n\n      assert_equal(2, g:adict['aaa'])\n      assert_equal(8, g:adict.bbb)\n\n      var dd = {}\n      def Func1()\n        eval dd.key1.key2\n      enddef\n      def Func2()\n        eval dd['key1'].key2\n      enddef\n      defcompile\n  END\n  CheckDefAndScriptSuccess(lines)\nenddef\n\ndef Test_expr7_blob_subscript()\n  var lines =<< trim END\n      var b = 0z112233\n      assert_equal(0x11, b[0])\n      assert_equal(0z112233, b[:])\n\n      assert_equal(0x01, g:ablob[0])\n      assert_equal(0z01ab, g:ablob[:])\n  END\n  CheckDefAndScriptSuccess(lines)\nenddef\n\ndef Test_expr7_subscript_linebreak()\n  var lines =<< trim END\n      var range = range(\n                    3)\n      var l = range\n            ->mapnew('string(v:key)')\n      assert_equal(['0', '1', '2'], l)\n\n      l = range\n            ->mapnew('string(v:key)')\n      assert_equal(['0', '1', '2'], l)\n\n      l = range # comment\n            ->mapnew('string(v:key)')\n      assert_equal(['0', '1', '2'], l)\n\n      l = range\n\n            ->mapnew('string(v:key)')\n      assert_equal(['0', '1', '2'], l)\n\n      l = range\n            # comment\n            ->mapnew('string(v:key)')\n      assert_equal(['0', '1', '2'], l)\n\n      assert_equal('1', l[\n            1])\n\n      var d = {one: 33}\n      assert_equal(33, d\n            .one)\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  lines =<< trim END\n      var d = {one: 33}\n      assert_equal(33, d.\n            one)\n  END\n  CheckDefAndScriptFailure(lines, ['E1127:', 'E116:'], 2)\nenddef\n\nfunc Test_expr7_trailing_fails()\n  call CheckDefAndScriptFailure(['var l = [2]', 'l->((ll) => add(ll, 8))'], 'E107:', 2)\n  call CheckDefAndScriptFailure(['var l = [2]', 'l->((ll) => add(ll, 8)) ()'], 'E274:', 2)\nendfunc\n\nfunc Test_expr_fails()\n  call CheckDefAndScriptFailure([\"var x = '1'is2\"], 'E488:', 1)\n  call CheckDefAndScriptFailure([\"var x = '1'isnot2\"], 'E488:', 1)\n\n  call CheckDefAndScriptFailure([\"CallMe ('yes')\"], ['E476:', 'E492:'], 1)\n\n  call CheckDefAndScriptFailure([\"CallMe2('yes','no')\"], 'E1069:', 1)\n\n  call CheckDefAndScriptFailure([\"v:nosuch += 3\"], ['E1001:', 'E121:'], 1)\n  call CheckDefAndScriptFailure([\"var v:statusmsg = ''\"], 'E1016: Cannot declare a v: variable:', 1)\n  call CheckDefAndScriptFailure([\"var asdf = v:nosuch\"], ['E1001:', 'E121:'], 1)\n\n  call CheckDefFailure([\"echo len('asdf'\"], 'E110:', 2)\n  call CheckScriptFailure(['vim9script', \"echo len('asdf'\"], 'E116:', 2)\n\n  call CheckDefAndScriptFailure([\"echo Func0123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789()\"], ['E1011:', 'E117:'], 1)\n  call CheckDefAndScriptFailure([\"echo doesnotexist()\"], 'E117:', 1)\nendfunc\n\n\" vim: shiftwidth=2 sts=2 expandtab\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion == NULL)\n    {\n#ifdef BUILD_DATE\n\tchar *date_time = BUILD_DATE;\n#else\n\tchar *date_time = __DATE__ \" \" __TIME__;\n#endif\n\tchar *msg = _(\"%s (%s, compiled %s)\");\n\tsize_t len = strlen(msg)\n\t\t    + strlen(VIM_VERSION_LONG_ONLY)\n\t\t    + strlen(VIM_VERSION_DATE_ONLY)\n\t\t    + strlen(date_time);\n\n\tlongVersion = alloc(len);\n\tif (longVersion == NULL)\n\t    longVersion = VIM_VERSION_LONG;\n\telse\n\t    vim_snprintf(longVersion, len, msg,\n\t\t      VIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n    }\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n#ifdef NO_BUILTIN_TCAPS\n\t\"-builtin_terms\",\n#endif\n#ifdef SOME_BUILTIN_TCAPS\n\t\"+builtin_terms\",\n#endif\n#ifdef ALL_BUILTIN_TCAPS\n\t\"++builtin_terms\",\n#endif\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n#ifdef FEAT_CINDENT\n\t\"+cindent\",\n#else\n\t\"-cindent\",\n#endif\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n#ifdef FEAT_CMDL_INFO\n\t\"+cmdline_info\",\n#else\n\t\"-cmdline_info\",\n#endif\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n#ifdef EBCDIC\n\t\"+ebcdic\",\n#else\n\t\"-ebcdic\",\n#endif\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n#ifdef FEAT_SEARCHPATH\n\t\"+file_in_path\",\n#else\n\t\"-file_in_path\",\n#endif\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n#ifdef FEAT_FLOAT\n\t\"+float\",\n#else\n\t\"-float\",\n#endif\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n#ifdef FEAT_FOOTER\n\t\"+footer\",\n#else\n\t\"-footer\",\n#endif\n\t    // only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n\t\"+jumplist\",\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n#ifdef FEAT_LISP\n\t\"+lispindent\",\n#else\n\t\"-lispindent\",\n#endif\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n\t\"+mouse_gpm\",\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n#ifdef FEAT_PATH_EXTRA\n\t\"+path_extra\",\n#else\n\t\"-path_extra\",\n#endif\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n#ifdef FEAT_SMARTINDENT\n\t\"+smartindent\",\n#else\n\t\"-smartindent\",\n#endif\n#ifdef FEAT_SODIUM\n\t\"+sodium\",\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n#ifdef FEAT_TAG_BINS\n\t\"+tag_binary\",\n#else\n\t\"-tag_binary\",\n#endif\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n#ifdef FEAT_TEXTOBJ\n\t\"+textobjects\",\n#else\n\t\"-textobjects\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n\t\"+title\",\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+vim9script\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n#ifdef FEAT_WILDIGN\n\t\"+wildignore\",\n#else\n\t\"-wildignore\",\n#endif\n#ifdef FEAT_WILDMENU\n\t\"+wildmenu\",\n#else\n\t\"-wildmenu\",\n#endif\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#ifdef MSWIN\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#else\n# ifdef HAVE_XPM\n\t\"+xpm\",\n# else\n\t\"-xpm\",\n# endif\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef USE_XSMP_INTERACT\n\t\"+xsmp_interact\",\n# else\n#  ifdef USE_XSMP\n\t\"+xsmp\",\n#  else\n\t\"-xsmp\",\n#  endif\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    4049,\n/**/\n    4048,\n/**/\n    4047,\n/**/\n    4046,\n/**/\n    4045,\n/**/\n    4044,\n/**/\n    4043,\n/**/\n    4042,\n/**/\n    4041,\n/**/\n    4040,\n/**/\n    4039,\n/**/\n    4038,\n/**/\n    4037,\n/**/\n    4036,\n/**/\n    4035,\n/**/\n    4034,\n/**/\n    4033,\n/**/\n    4032,\n/**/\n    4031,\n/**/\n    4030,\n/**/\n    4029,\n/**/\n    4028,\n/**/\n    4027,\n/**/\n    4026,\n/**/\n    4025,\n/**/\n    4024,\n/**/\n    4023,\n/**/\n    4022,\n/**/\n    4021,\n/**/\n    4020,\n/**/\n    4019,\n/**/\n    4018,\n/**/\n    4017,\n/**/\n    4016,\n/**/\n    4015,\n/**/\n    4014,\n/**/\n    4013,\n/**/\n    4012,\n/**/\n    4011,\n/**/\n    4010,\n/**/\n    4009,\n/**/\n    4008,\n/**/\n    4007,\n/**/\n    4006,\n/**/\n    4005,\n/**/\n    4004,\n/**/\n    4003,\n/**/\n    4002,\n/**/\n    4001,\n/**/\n    4000,\n/**/\n    3999,\n/**/\n    3998,\n/**/\n    3997,\n/**/\n    3996,\n/**/\n    3995,\n/**/\n    3994,\n/**/\n    3993,\n/**/\n    3992,\n/**/\n    3991,\n/**/\n    3990,\n/**/\n    3989,\n/**/\n    3988,\n/**/\n    3987,\n/**/\n    3986,\n/**/\n    3985,\n/**/\n    3984,\n/**/\n    3983,\n/**/\n    3982,\n/**/\n    3981,\n/**/\n    3980,\n/**/\n    3979,\n/**/\n    3978,\n/**/\n    3977,\n/**/\n    3976,\n/**/\n    3975,\n/**/\n    3974,\n/**/\n    3973,\n/**/\n    3972,\n/**/\n    3971,\n/**/\n    3970,\n/**/\n    3969,\n/**/\n    3968,\n/**/\n    3967,\n/**/\n    3966,\n/**/\n    3965,\n/**/\n    3964,\n/**/\n    3963,\n/**/\n    3962,\n/**/\n    3961,\n/**/\n    3960,\n/**/\n    3959,\n/**/\n    3958,\n/**/\n    3957,\n/**/\n    3956,\n/**/\n    3955,\n/**/\n    3954,\n/**/\n    3953,\n/**/\n    3952,\n/**/\n    3951,\n/**/\n    3950,\n/**/\n    3949,\n/**/\n    3948,\n/**/\n    3947,\n/**/\n    3946,\n/**/\n    3945,\n/**/\n    3944,\n/**/\n    3943,\n/**/\n    3942,\n/**/\n    3941,\n/**/\n    3940,\n/**/\n    3939,\n/**/\n    3938,\n/**/\n    3937,\n/**/\n    3936,\n/**/\n    3935,\n/**/\n    3934,\n/**/\n    3933,\n/**/\n    3932,\n/**/\n    3931,\n/**/\n    3930,\n/**/\n    3929,\n/**/\n    3928,\n/**/\n    3927,\n/**/\n    3926,\n/**/\n    3925,\n/**/\n    3924,\n/**/\n    3923,\n/**/\n    3922,\n/**/\n    3921,\n/**/\n    3920,\n/**/\n    3919,\n/**/\n    3918,\n/**/\n    3917,\n/**/\n    3916,\n/**/\n    3915,\n/**/\n    3914,\n/**/\n    3913,\n/**/\n    3912,\n/**/\n    3911,\n/**/\n    3910,\n/**/\n    3909,\n/**/\n    3908,\n/**/\n    3907,\n/**/\n    3906,\n/**/\n    3905,\n/**/\n    3904,\n/**/\n    3903,\n/**/\n    3902,\n/**/\n    3901,\n/**/\n    3900,\n/**/\n    3899,\n/**/\n    3898,\n/**/\n    3897,\n/**/\n    3896,\n/**/\n    3895,\n/**/\n    3894,\n/**/\n    3893,\n/**/\n    3892,\n/**/\n    3891,\n/**/\n    3890,\n/**/\n    3889,\n/**/\n    3888,\n/**/\n    3887,\n/**/\n    3886,\n/**/\n    3885,\n/**/\n    3884,\n/**/\n    3883,\n/**/\n    3882,\n/**/\n    3881,\n/**/\n    3880,\n/**/\n    3879,\n/**/\n    3878,\n/**/\n    3877,\n/**/\n    3876,\n/**/\n    3875,\n/**/\n    3874,\n/**/\n    3873,\n/**/\n    3872,\n/**/\n    3871,\n/**/\n    3870,\n/**/\n    3869,\n/**/\n    3868,\n/**/\n    3867,\n/**/\n    3866,\n/**/\n    3865,\n/**/\n    3864,\n/**/\n    3863,\n/**/\n    3862,\n/**/\n    3861,\n/**/\n    3860,\n/**/\n    3859,\n/**/\n    3858,\n/**/\n    3857,\n/**/\n    3856,\n/**/\n    3855,\n/**/\n    3854,\n/**/\n    3853,\n/**/\n    3852,\n/**/\n    3851,\n/**/\n    3850,\n/**/\n    3849,\n/**/\n    3848,\n/**/\n    3847,\n/**/\n    3846,\n/**/\n    3845,\n/**/\n    3844,\n/**/\n    3843,\n/**/\n    3842,\n/**/\n    3841,\n/**/\n    3840,\n/**/\n    3839,\n/**/\n    3838,\n/**/\n    3837,\n/**/\n    3836,\n/**/\n    3835,\n/**/\n    3834,\n/**/\n    3833,\n/**/\n    3832,\n/**/\n    3831,\n/**/\n    3830,\n/**/\n    3829,\n/**/\n    3828,\n/**/\n    3827,\n/**/\n    3826,\n/**/\n    3825,\n/**/\n    3824,\n/**/\n    3823,\n/**/\n    3822,\n/**/\n    3821,\n/**/\n    3820,\n/**/\n    3819,\n/**/\n    3818,\n/**/\n    3817,\n/**/\n    3816,\n/**/\n    3815,\n/**/\n    3814,\n/**/\n    3813,\n/**/\n    3812,\n/**/\n    3811,\n/**/\n    3810,\n/**/\n    3809,\n/**/\n    3808,\n/**/\n    3807,\n/**/\n    3806,\n/**/\n    3805,\n/**/\n    3804,\n/**/\n    3803,\n/**/\n    3802,\n/**/\n    3801,\n/**/\n    3800,\n/**/\n    3799,\n/**/\n    3798,\n/**/\n    3797,\n/**/\n    3796,\n/**/\n    3795,\n/**/\n    3794,\n/**/\n    3793,\n/**/\n    3792,\n/**/\n    3791,\n/**/\n    3790,\n/**/\n    3789,\n/**/\n    3788,\n/**/\n    3787,\n/**/\n    3786,\n/**/\n    3785,\n/**/\n    3784,\n/**/\n    3783,\n/**/\n    3782,\n/**/\n    3781,\n/**/\n    3780,\n/**/\n    3779,\n/**/\n    3778,\n/**/\n    3777,\n/**/\n    3776,\n/**/\n    3775,\n/**/\n    3774,\n/**/\n    3773,\n/**/\n    3772,\n/**/\n    3771,\n/**/\n    3770,\n/**/\n    3769,\n/**/\n    3768,\n/**/\n    3767,\n/**/\n    3766,\n/**/\n    3765,\n/**/\n    3764,\n/**/\n    3763,\n/**/\n    3762,\n/**/\n    3761,\n/**/\n    3760,\n/**/\n    3759,\n/**/\n    3758,\n/**/\n    3757,\n/**/\n    3756,\n/**/\n    3755,\n/**/\n    3754,\n/**/\n    3753,\n/**/\n    3752,\n/**/\n    3751,\n/**/\n    3750,\n/**/\n    3749,\n/**/\n    3748,\n/**/\n    3747,\n/**/\n    3746,\n/**/\n    3745,\n/**/\n    3744,\n/**/\n    3743,\n/**/\n    3742,\n/**/\n    3741,\n/**/\n    3740,\n/**/\n    3739,\n/**/\n    3738,\n/**/\n    3737,\n/**/\n    3736,\n/**/\n    3735,\n/**/\n    3734,\n/**/\n    3733,\n/**/\n    3732,\n/**/\n    3731,\n/**/\n    3730,\n/**/\n    3729,\n/**/\n    3728,\n/**/\n    3727,\n/**/\n    3726,\n/**/\n    3725,\n/**/\n    3724,\n/**/\n    3723,\n/**/\n    3722,\n/**/\n    3721,\n/**/\n    3720,\n/**/\n    3719,\n/**/\n    3718,\n/**/\n    3717,\n/**/\n    3716,\n/**/\n    3715,\n/**/\n    3714,\n/**/\n    3713,\n/**/\n    3712,\n/**/\n    3711,\n/**/\n    3710,\n/**/\n    3709,\n/**/\n    3708,\n/**/\n    3707,\n/**/\n    3706,\n/**/\n    3705,\n/**/\n    3704,\n/**/\n    3703,\n/**/\n    3702,\n/**/\n    3701,\n/**/\n    3700,\n/**/\n    3699,\n/**/\n    3698,\n/**/\n    3697,\n/**/\n    3696,\n/**/\n    3695,\n/**/\n    3694,\n/**/\n    3693,\n/**/\n    3692,\n/**/\n    3691,\n/**/\n    3690,\n/**/\n    3689,\n/**/\n    3688,\n/**/\n    3687,\n/**/\n    3686,\n/**/\n    3685,\n/**/\n    3684,\n/**/\n    3683,\n/**/\n    3682,\n/**/\n    3681,\n/**/\n    3680,\n/**/\n    3679,\n/**/\n    3678,\n/**/\n    3677,\n/**/\n    3676,\n/**/\n    3675,\n/**/\n    3674,\n/**/\n    3673,\n/**/\n    3672,\n/**/\n    3671,\n/**/\n    3670,\n/**/\n    3669,\n/**/\n    3668,\n/**/\n    3667,\n/**/\n    3666,\n/**/\n    3665,\n/**/\n    3664,\n/**/\n    3663,\n/**/\n    3662,\n/**/\n    3661,\n/**/\n    3660,\n/**/\n    3659,\n/**/\n    3658,\n/**/\n    3657,\n/**/\n    3656,\n/**/\n    3655,\n/**/\n    3654,\n/**/\n    3653,\n/**/\n    3652,\n/**/\n    3651,\n/**/\n    3650,\n/**/\n    3649,\n/**/\n    3648,\n/**/\n    3647,\n/**/\n    3646,\n/**/\n    3645,\n/**/\n    3644,\n/**/\n    3643,\n/**/\n    3642,\n/**/\n    3641,\n/**/\n    3640,\n/**/\n    3639,\n/**/\n    3638,\n/**/\n    3637,\n/**/\n    3636,\n/**/\n    3635,\n/**/\n    3634,\n/**/\n    3633,\n/**/\n    3632,\n/**/\n    3631,\n/**/\n    3630,\n/**/\n    3629,\n/**/\n    3628,\n/**/\n    3627,\n/**/\n    3626,\n/**/\n    3625,\n/**/\n    3624,\n/**/\n    3623,\n/**/\n    3622,\n/**/\n    3621,\n/**/\n    3620,\n/**/\n    3619,\n/**/\n    3618,\n/**/\n    3617,\n/**/\n    3616,\n/**/\n    3615,\n/**/\n    3614,\n/**/\n    3613,\n/**/\n    3612,\n/**/\n    3611,\n/**/\n    3610,\n/**/\n    3609,\n/**/\n    3608,\n/**/\n    3607,\n/**/\n    3606,\n/**/\n    3605,\n/**/\n    3604,\n/**/\n    3603,\n/**/\n    3602,\n/**/\n    3601,\n/**/\n    3600,\n/**/\n    3599,\n/**/\n    3598,\n/**/\n    3597,\n/**/\n    3596,\n/**/\n    3595,\n/**/\n    3594,\n/**/\n    3593,\n/**/\n    3592,\n/**/\n    3591,\n/**/\n    3590,\n/**/\n    3589,\n/**/\n    3588,\n/**/\n    3587,\n/**/\n    3586,\n/**/\n    3585,\n/**/\n    3584,\n/**/\n    3583,\n/**/\n    3582,\n/**/\n    3581,\n/**/\n    3580,\n/**/\n    3579,\n/**/\n    3578,\n/**/\n    3577,\n/**/\n    3576,\n/**/\n    3575,\n/**/\n    3574,\n/**/\n    3573,\n/**/\n    3572,\n/**/\n    3571,\n/**/\n    3570,\n/**/\n    3569,\n/**/\n    3568,\n/**/\n    3567,\n/**/\n    3566,\n/**/\n    3565,\n/**/\n    3564,\n/**/\n    3563,\n/**/\n    3562,\n/**/\n    3561,\n/**/\n    3560,\n/**/\n    3559,\n/**/\n    3558,\n/**/\n    3557,\n/**/\n    3556,\n/**/\n    3555,\n/**/\n    3554,\n/**/\n    3553,\n/**/\n    3552,\n/**/\n    3551,\n/**/\n    3550,\n/**/\n    3549,\n/**/\n    3548,\n/**/\n    3547,\n/**/\n    3546,\n/**/\n    3545,\n/**/\n    3544,\n/**/\n    3543,\n/**/\n    3542,\n/**/\n    3541,\n/**/\n    3540,\n/**/\n    3539,\n/**/\n    3538,\n/**/\n    3537,\n/**/\n    3536,\n/**/\n    3535,\n/**/\n    3534,\n/**/\n    3533,\n/**/\n    3532,\n/**/\n    3531,\n/**/\n    3530,\n/**/\n    3529,\n/**/\n    3528,\n/**/\n    3527,\n/**/\n    3526,\n/**/\n    3525,\n/**/\n    3524,\n/**/\n    3523,\n/**/\n    3522,\n/**/\n    3521,\n/**/\n    3520,\n/**/\n    3519,\n/**/\n    3518,\n/**/\n    3517,\n/**/\n    3516,\n/**/\n    3515,\n/**/\n    3514,\n/**/\n    3513,\n/**/\n    3512,\n/**/\n    3511,\n/**/\n    3510,\n/**/\n    3509,\n/**/\n    3508,\n/**/\n    3507,\n/**/\n    3506,\n/**/\n    3505,\n/**/\n    3504,\n/**/\n    3503,\n/**/\n    3502,\n/**/\n    3501,\n/**/\n    3500,\n/**/\n    3499,\n/**/\n    3498,\n/**/\n    3497,\n/**/\n    3496,\n/**/\n    3495,\n/**/\n    3494,\n/**/\n    3493,\n/**/\n    3492,\n/**/\n    3491,\n/**/\n    3490,\n/**/\n    3489,\n/**/\n    3488,\n/**/\n    3487,\n/**/\n    3486,\n/**/\n    3485,\n/**/\n    3484,\n/**/\n    3483,\n/**/\n    3482,\n/**/\n    3481,\n/**/\n    3480,\n/**/\n    3479,\n/**/\n    3478,\n/**/\n    3477,\n/**/\n    3476,\n/**/\n    3475,\n/**/\n    3474,\n/**/\n    3473,\n/**/\n    3472,\n/**/\n    3471,\n/**/\n    3470,\n/**/\n    3469,\n/**/\n    3468,\n/**/\n    3467,\n/**/\n    3466,\n/**/\n    3465,\n/**/\n    3464,\n/**/\n    3463,\n/**/\n    3462,\n/**/\n    3461,\n/**/\n    3460,\n/**/\n    3459,\n/**/\n    3458,\n/**/\n    3457,\n/**/\n    3456,\n/**/\n    3455,\n/**/\n    3454,\n/**/\n    3453,\n/**/\n    3452,\n/**/\n    3451,\n/**/\n    3450,\n/**/\n    3449,\n/**/\n    3448,\n/**/\n    3447,\n/**/\n    3446,\n/**/\n    3445,\n/**/\n    3444,\n/**/\n    3443,\n/**/\n    3442,\n/**/\n    3441,\n/**/\n    3440,\n/**/\n    3439,\n/**/\n    3438,\n/**/\n    3437,\n/**/\n    3436,\n/**/\n    3435,\n/**/\n    3434,\n/**/\n    3433,\n/**/\n    3432,\n/**/\n    3431,\n/**/\n    3430,\n/**/\n    3429,\n/**/\n    3428,\n/**/\n    3427,\n/**/\n    3426,\n/**/\n    3425,\n/**/\n    3424,\n/**/\n    3423,\n/**/\n    3422,\n/**/\n    3421,\n/**/\n    3420,\n/**/\n    3419,\n/**/\n    3418,\n/**/\n    3417,\n/**/\n    3416,\n/**/\n    3415,\n/**/\n    3414,\n/**/\n    3413,\n/**/\n    3412,\n/**/\n    3411,\n/**/\n    3410,\n/**/\n    3409,\n/**/\n    3408,\n/**/\n    3407,\n/**/\n    3406,\n/**/\n    3405,\n/**/\n    3404,\n/**/\n    3403,\n/**/\n    3402,\n/**/\n    3401,\n/**/\n    3400,\n/**/\n    3399,\n/**/\n    3398,\n/**/\n    3397,\n/**/\n    3396,\n/**/\n    3395,\n/**/\n    3394,\n/**/\n    3393,\n/**/\n    3392,\n/**/\n    3391,\n/**/\n    3390,\n/**/\n    3389,\n/**/\n    3388,\n/**/\n    3387,\n/**/\n    3386,\n/**/\n    3385,\n/**/\n    3384,\n/**/\n    3383,\n/**/\n    3382,\n/**/\n    3381,\n/**/\n    3380,\n/**/\n    3379,\n/**/\n    3378,\n/**/\n    3377,\n/**/\n    3376,\n/**/\n    3375,\n/**/\n    3374,\n/**/\n    3373,\n/**/\n    3372,\n/**/\n    3371,\n/**/\n    3370,\n/**/\n    3369,\n/**/\n    3368,\n/**/\n    3367,\n/**/\n    3366,\n/**/\n    3365,\n/**/\n    3364,\n/**/\n    3363,\n/**/\n    3362,\n/**/\n    3361,\n/**/\n    3360,\n/**/\n    3359,\n/**/\n    3358,\n/**/\n    3357,\n/**/\n    3356,\n/**/\n    3355,\n/**/\n    3354,\n/**/\n    3353,\n/**/\n    3352,\n/**/\n    3351,\n/**/\n    3350,\n/**/\n    3349,\n/**/\n    3348,\n/**/\n    3347,\n/**/\n    3346,\n/**/\n    3345,\n/**/\n    3344,\n/**/\n    3343,\n/**/\n    3342,\n/**/\n    3341,\n/**/\n    3340,\n/**/\n    3339,\n/**/\n    3338,\n/**/\n    3337,\n/**/\n    3336,\n/**/\n    3335,\n/**/\n    3334,\n/**/\n    3333,\n/**/\n    3332,\n/**/\n    3331,\n/**/\n    3330,\n/**/\n    3329,\n/**/\n    3328,\n/**/\n    3327,\n/**/\n    3326,\n/**/\n    3325,\n/**/\n    3324,\n/**/\n    3323,\n/**/\n    3322,\n/**/\n    3321,\n/**/\n    3320,\n/**/\n    3319,\n/**/\n    3318,\n/**/\n    3317,\n/**/\n    3316,\n/**/\n    3315,\n/**/\n    3314,\n/**/\n    3313,\n/**/\n    3312,\n/**/\n    3311,\n/**/\n    3310,\n/**/\n    3309,\n/**/\n    3308,\n/**/\n    3307,\n/**/\n    3306,\n/**/\n    3305,\n/**/\n    3304,\n/**/\n    3303,\n/**/\n    3302,\n/**/\n    3301,\n/**/\n    3300,\n/**/\n    3299,\n/**/\n    3298,\n/**/\n    3297,\n/**/\n    3296,\n/**/\n    3295,\n/**/\n    3294,\n/**/\n    3293,\n/**/\n    3292,\n/**/\n    3291,\n/**/\n    3290,\n/**/\n    3289,\n/**/\n    3288,\n/**/\n    3287,\n/**/\n    3286,\n/**/\n    3285,\n/**/\n    3284,\n/**/\n    3283,\n/**/\n    3282,\n/**/\n    3281,\n/**/\n    3280,\n/**/\n    3279,\n/**/\n    3278,\n/**/\n    3277,\n/**/\n    3276,\n/**/\n    3275,\n/**/\n    3274,\n/**/\n    3273,\n/**/\n    3272,\n/**/\n    3271,\n/**/\n    3270,\n/**/\n    3269,\n/**/\n    3268,\n/**/\n    3267,\n/**/\n    3266,\n/**/\n    3265,\n/**/\n    3264,\n/**/\n    3263,\n/**/\n    3262,\n/**/\n    3261,\n/**/\n    3260,\n/**/\n    3259,\n/**/\n    3258,\n/**/\n    3257,\n/**/\n    3256,\n/**/\n    3255,\n/**/\n    3254,\n/**/\n    3253,\n/**/\n    3252,\n/**/\n    3251,\n/**/\n    3250,\n/**/\n    3249,\n/**/\n    3248,\n/**/\n    3247,\n/**/\n    3246,\n/**/\n    3245,\n/**/\n    3244,\n/**/\n    3243,\n/**/\n    3242,\n/**/\n    3241,\n/**/\n    3240,\n/**/\n    3239,\n/**/\n    3238,\n/**/\n    3237,\n/**/\n    3236,\n/**/\n    3235,\n/**/\n    3234,\n/**/\n    3233,\n/**/\n    3232,\n/**/\n    3231,\n/**/\n    3230,\n/**/\n    3229,\n/**/\n    3228,\n/**/\n    3227,\n/**/\n    3226,\n/**/\n    3225,\n/**/\n    3224,\n/**/\n    3223,\n/**/\n    3222,\n/**/\n    3221,\n/**/\n    3220,\n/**/\n    3219,\n/**/\n    3218,\n/**/\n    3217,\n/**/\n    3216,\n/**/\n    3215,\n/**/\n    3214,\n/**/\n    3213,\n/**/\n    3212,\n/**/\n    3211,\n/**/\n    3210,\n/**/\n    3209,\n/**/\n    3208,\n/**/\n    3207,\n/**/\n    3206,\n/**/\n    3205,\n/**/\n    3204,\n/**/\n    3203,\n/**/\n    3202,\n/**/\n    3201,\n/**/\n    3200,\n/**/\n    3199,\n/**/\n    3198,\n/**/\n    3197,\n/**/\n    3196,\n/**/\n    3195,\n/**/\n    3194,\n/**/\n    3193,\n/**/\n    3192,\n/**/\n    3191,\n/**/\n    3190,\n/**/\n    3189,\n/**/\n    3188,\n/**/\n    3187,\n/**/\n    3186,\n/**/\n    3185,\n/**/\n    3184,\n/**/\n    3183,\n/**/\n    3182,\n/**/\n    3181,\n/**/\n    3180,\n/**/\n    3179,\n/**/\n    3178,\n/**/\n    3177,\n/**/\n    3176,\n/**/\n    3175,\n/**/\n    3174,\n/**/\n    3173,\n/**/\n    3172,\n/**/\n    3171,\n/**/\n    3170,\n/**/\n    3169,\n/**/\n    3168,\n/**/\n    3167,\n/**/\n    3166,\n/**/\n    3165,\n/**/\n    3164,\n/**/\n    3163,\n/**/\n    3162,\n/**/\n    3161,\n/**/\n    3160,\n/**/\n    3159,\n/**/\n    3158,\n/**/\n    3157,\n/**/\n    3156,\n/**/\n    3155,\n/**/\n    3154,\n/**/\n    3153,\n/**/\n    3152,\n/**/\n    3151,\n/**/\n    3150,\n/**/\n    3149,\n/**/\n    3148,\n/**/\n    3147,\n/**/\n    3146,\n/**/\n    3145,\n/**/\n    3144,\n/**/\n    3143,\n/**/\n    3142,\n/**/\n    3141,\n/**/\n    3140,\n/**/\n    3139,\n/**/\n    3138,\n/**/\n    3137,\n/**/\n    3136,\n/**/\n    3135,\n/**/\n    3134,\n/**/\n    3133,\n/**/\n    3132,\n/**/\n    3131,\n/**/\n    3130,\n/**/\n    3129,\n/**/\n    3128,\n/**/\n    3127,\n/**/\n    3126,\n/**/\n    3125,\n/**/\n    3124,\n/**/\n    3123,\n/**/\n    3122,\n/**/\n    3121,\n/**/\n    3120,\n/**/\n    3119,\n/**/\n    3118,\n/**/\n    3117,\n/**/\n    3116,\n/**/\n    3115,\n/**/\n    3114,\n/**/\n    3113,\n/**/\n    3112,\n/**/\n    3111,\n/**/\n    3110,\n/**/\n    3109,\n/**/\n    3108,\n/**/\n    3107,\n/**/\n    3106,\n/**/\n    3105,\n/**/\n    3104,\n/**/\n    3103,\n/**/\n    3102,\n/**/\n    3101,\n/**/\n    3100,\n/**/\n    3099,\n/**/\n    3098,\n/**/\n    3097,\n/**/\n    3096,\n/**/\n    3095,\n/**/\n    3094,\n/**/\n    3093,\n/**/\n    3092,\n/**/\n    3091,\n/**/\n    3090,\n/**/\n    3089,\n/**/\n    3088,\n/**/\n    3087,\n/**/\n    3086,\n/**/\n    3085,\n/**/\n    3084,\n/**/\n    3083,\n/**/\n    3082,\n/**/\n    3081,\n/**/\n    3080,\n/**/\n    3079,\n/**/\n    3078,\n/**/\n    3077,\n/**/\n    3076,\n/**/\n    3075,\n/**/\n    3074,\n/**/\n    3073,\n/**/\n    3072,\n/**/\n    3071,\n/**/\n    3070,\n/**/\n    3069,\n/**/\n    3068,\n/**/\n    3067,\n/**/\n    3066,\n/**/\n    3065,\n/**/\n    3064,\n/**/\n    3063,\n/**/\n    3062,\n/**/\n    3061,\n/**/\n    3060,\n/**/\n    3059,\n/**/\n    3058,\n/**/\n    3057,\n/**/\n    3056,\n/**/\n    3055,\n/**/\n    3054,\n/**/\n    3053,\n/**/\n    3052,\n/**/\n    3051,\n/**/\n    3050,\n/**/\n    3049,\n/**/\n    3048,\n/**/\n    3047,\n/**/\n    3046,\n/**/\n    3045,\n/**/\n    3044,\n/**/\n    3043,\n/**/\n    3042,\n/**/\n    3041,\n/**/\n    3040,\n/**/\n    3039,\n/**/\n    3038,\n/**/\n    3037,\n/**/\n    3036,\n/**/\n    3035,\n/**/\n    3034,\n/**/\n    3033,\n/**/\n    3032,\n/**/\n    3031,\n/**/\n    3030,\n/**/\n    3029,\n/**/\n    3028,\n/**/\n    3027,\n/**/\n    3026,\n/**/\n    3025,\n/**/\n    3024,\n/**/\n    3023,\n/**/\n    3022,\n/**/\n    3021,\n/**/\n    3020,\n/**/\n    3019,\n/**/\n    3018,\n/**/\n    3017,\n/**/\n    3016,\n/**/\n    3015,\n/**/\n    3014,\n/**/\n    3013,\n/**/\n    3012,\n/**/\n    3011,\n/**/\n    3010,\n/**/\n    3009,\n/**/\n    3008,\n/**/\n    3007,\n/**/\n    3006,\n/**/\n    3005,\n/**/\n    3004,\n/**/\n    3003,\n/**/\n    3002,\n/**/\n    3001,\n/**/\n    3000,\n/**/\n    2999,\n/**/\n    2998,\n/**/\n    2997,\n/**/\n    2996,\n/**/\n    2995,\n/**/\n    2994,\n/**/\n    2993,\n/**/\n    2992,\n/**/\n    2991,\n/**/\n    2990,\n/**/\n    2989,\n/**/\n    2988,\n/**/\n    2987,\n/**/\n    2986,\n/**/\n    2985,\n/**/\n    2984,\n/**/\n    2983,\n/**/\n    2982,\n/**/\n    2981,\n/**/\n    2980,\n/**/\n    2979,\n/**/\n    2978,\n/**/\n    2977,\n/**/\n    2976,\n/**/\n    2975,\n/**/\n    2974,\n/**/\n    2973,\n/**/\n    2972,\n/**/\n    2971,\n/**/\n    2970,\n/**/\n    2969,\n/**/\n    2968,\n/**/\n    2967,\n/**/\n    2966,\n/**/\n    2965,\n/**/\n    2964,\n/**/\n    2963,\n/**/\n    2962,\n/**/\n    2961,\n/**/\n    2960,\n/**/\n    2959,\n/**/\n    2958,\n/**/\n    2957,\n/**/\n    2956,\n/**/\n    2955,\n/**/\n    2954,\n/**/\n    2953,\n/**/\n    2952,\n/**/\n    2951,\n/**/\n    2950,\n/**/\n    2949,\n/**/\n    2948,\n/**/\n    2947,\n/**/\n    2946,\n/**/\n    2945,\n/**/\n    2944,\n/**/\n    2943,\n/**/\n    2942,\n/**/\n    2941,\n/**/\n    2940,\n/**/\n    2939,\n/**/\n    2938,\n/**/\n    2937,\n/**/\n    2936,\n/**/\n    2935,\n/**/\n    2934,\n/**/\n    2933,\n/**/\n    2932,\n/**/\n    2931,\n/**/\n    2930,\n/**/\n    2929,\n/**/\n    2928,\n/**/\n    2927,\n/**/\n    2926,\n/**/\n    2925,\n/**/\n    2924,\n/**/\n    2923,\n/**/\n    2922,\n/**/\n    2921,\n/**/\n    2920,\n/**/\n    2919,\n/**/\n    2918,\n/**/\n    2917,\n/**/\n    2916,\n/**/\n    2915,\n/**/\n    2914,\n/**/\n    2913,\n/**/\n    2912,\n/**/\n    2911,\n/**/\n    2910,\n/**/\n    2909,\n/**/\n    2908,\n/**/\n    2907,\n/**/\n    2906,\n/**/\n    2905,\n/**/\n    2904,\n/**/\n    2903,\n/**/\n    2902,\n/**/\n    2901,\n/**/\n    2900,\n/**/\n    2899,\n/**/\n    2898,\n/**/\n    2897,\n/**/\n    2896,\n/**/\n    2895,\n/**/\n    2894,\n/**/\n    2893,\n/**/\n    2892,\n/**/\n    2891,\n/**/\n    2890,\n/**/\n    2889,\n/**/\n    2888,\n/**/\n    2887,\n/**/\n    2886,\n/**/\n    2885,\n/**/\n    2884,\n/**/\n    2883,\n/**/\n    2882,\n/**/\n    2881,\n/**/\n    2880,\n/**/\n    2879,\n/**/\n    2878,\n/**/\n    2877,\n/**/\n    2876,\n/**/\n    2875,\n/**/\n    2874,\n/**/\n    2873,\n/**/\n    2872,\n/**/\n    2871,\n/**/\n    2870,\n/**/\n    2869,\n/**/\n    2868,\n/**/\n    2867,\n/**/\n    2866,\n/**/\n    2865,\n/**/\n    2864,\n/**/\n    2863,\n/**/\n    2862,\n/**/\n    2861,\n/**/\n    2860,\n/**/\n    2859,\n/**/\n    2858,\n/**/\n    2857,\n/**/\n    2856,\n/**/\n    2855,\n/**/\n    2854,\n/**/\n    2853,\n/**/\n    2852,\n/**/\n    2851,\n/**/\n    2850,\n/**/\n    2849,\n/**/\n    2848,\n/**/\n    2847,\n/**/\n    2846,\n/**/\n    2845,\n/**/\n    2844,\n/**/\n    2843,\n/**/\n    2842,\n/**/\n    2841,\n/**/\n    2840,\n/**/\n    2839,\n/**/\n    2838,\n/**/\n    2837,\n/**/\n    2836,\n/**/\n    2835,\n/**/\n    2834,\n/**/\n    2833,\n/**/\n    2832,\n/**/\n    2831,\n/**/\n    2830,\n/**/\n    2829,\n/**/\n    2828,\n/**/\n    2827,\n/**/\n    2826,\n/**/\n    2825,\n/**/\n    2824,\n/**/\n    2823,\n/**/\n    2822,\n/**/\n    2821,\n/**/\n    2820,\n/**/\n    2819,\n/**/\n    2818,\n/**/\n    2817,\n/**/\n    2816,\n/**/\n    2815,\n/**/\n    2814,\n/**/\n    2813,\n/**/\n    2812,\n/**/\n    2811,\n/**/\n    2810,\n/**/\n    2809,\n/**/\n    2808,\n/**/\n    2807,\n/**/\n    2806,\n/**/\n    2805,\n/**/\n    2804,\n/**/\n    2803,\n/**/\n    2802,\n/**/\n    2801,\n/**/\n    2800,\n/**/\n    2799,\n/**/\n    2798,\n/**/\n    2797,\n/**/\n    2796,\n/**/\n    2795,\n/**/\n    2794,\n/**/\n    2793,\n/**/\n    2792,\n/**/\n    2791,\n/**/\n    2790,\n/**/\n    2789,\n/**/\n    2788,\n/**/\n    2787,\n/**/\n    2786,\n/**/\n    2785,\n/**/\n    2784,\n/**/\n    2783,\n/**/\n    2782,\n/**/\n    2781,\n/**/\n    2780,\n/**/\n    2779,\n/**/\n    2778,\n/**/\n    2777,\n/**/\n    2776,\n/**/\n    2775,\n/**/\n    2774,\n/**/\n    2773,\n/**/\n    2772,\n/**/\n    2771,\n/**/\n    2770,\n/**/\n    2769,\n/**/\n    2768,\n/**/\n    2767,\n/**/\n    2766,\n/**/\n    2765,\n/**/\n    2764,\n/**/\n    2763,\n/**/\n    2762,\n/**/\n    2761,\n/**/\n    2760,\n/**/\n    2759,\n/**/\n    2758,\n/**/\n    2757,\n/**/\n    2756,\n/**/\n    2755,\n/**/\n    2754,\n/**/\n    2753,\n/**/\n    2752,\n/**/\n    2751,\n/**/\n    2750,\n/**/\n    2749,\n/**/\n    2748,\n/**/\n    2747,\n/**/\n    2746,\n/**/\n    2745,\n/**/\n    2744,\n/**/\n    2743,\n/**/\n    2742,\n/**/\n    2741,\n/**/\n    2740,\n/**/\n    2739,\n/**/\n    2738,\n/**/\n    2737,\n/**/\n    2736,\n/**/\n    2735,\n/**/\n    2734,\n/**/\n    2733,\n/**/\n    2732,\n/**/\n    2731,\n/**/\n    2730,\n/**/\n    2729,\n/**/\n    2728,\n/**/\n    2727,\n/**/\n    2726,\n/**/\n    2725,\n/**/\n    2724,\n/**/\n    2723,\n/**/\n    2722,\n/**/\n    2721,\n/**/\n    2720,\n/**/\n    2719,\n/**/\n    2718,\n/**/\n    2717,\n/**/\n    2716,\n/**/\n    2715,\n/**/\n    2714,\n/**/\n    2713,\n/**/\n    2712,\n/**/\n    2711,\n/**/\n    2710,\n/**/\n    2709,\n/**/\n    2708,\n/**/\n    2707,\n/**/\n    2706,\n/**/\n    2705,\n/**/\n    2704,\n/**/\n    2703,\n/**/\n    2702,\n/**/\n    2701,\n/**/\n    2700,\n/**/\n    2699,\n/**/\n    2698,\n/**/\n    2697,\n/**/\n    2696,\n/**/\n    2695,\n/**/\n    2694,\n/**/\n    2693,\n/**/\n    2692,\n/**/\n    2691,\n/**/\n    2690,\n/**/\n    2689,\n/**/\n    2688,\n/**/\n    2687,\n/**/\n    2686,\n/**/\n    2685,\n/**/\n    2684,\n/**/\n    2683,\n/**/\n    2682,\n/**/\n    2681,\n/**/\n    2680,\n/**/\n    2679,\n/**/\n    2678,\n/**/\n    2677,\n/**/\n    2676,\n/**/\n    2675,\n/**/\n    2674,\n/**/\n    2673,\n/**/\n    2672,\n/**/\n    2671,\n/**/\n    2670,\n/**/\n    2669,\n/**/\n    2668,\n/**/\n    2667,\n/**/\n    2666,\n/**/\n    2665,\n/**/\n    2664,\n/**/\n    2663,\n/**/\n    2662,\n/**/\n    2661,\n/**/\n    2660,\n/**/\n    2659,\n/**/\n    2658,\n/**/\n    2657,\n/**/\n    2656,\n/**/\n    2655,\n/**/\n    2654,\n/**/\n    2653,\n/**/\n    2652,\n/**/\n    2651,\n/**/\n    2650,\n/**/\n    2649,\n/**/\n    2648,\n/**/\n    2647,\n/**/\n    2646,\n/**/\n    2645,\n/**/\n    2644,\n/**/\n    2643,\n/**/\n    2642,\n/**/\n    2641,\n/**/\n    2640,\n/**/\n    2639,\n/**/\n    2638,\n/**/\n    2637,\n/**/\n    2636,\n/**/\n    2635,\n/**/\n    2634,\n/**/\n    2633,\n/**/\n    2632,\n/**/\n    2631,\n/**/\n    2630,\n/**/\n    2629,\n/**/\n    2628,\n/**/\n    2627,\n/**/\n    2626,\n/**/\n    2625,\n/**/\n    2624,\n/**/\n    2623,\n/**/\n    2622,\n/**/\n    2621,\n/**/\n    2620,\n/**/\n    2619,\n/**/\n    2618,\n/**/\n    2617,\n/**/\n    2616,\n/**/\n    2615,\n/**/\n    2614,\n/**/\n    2613,\n/**/\n    2612,\n/**/\n    2611,\n/**/\n    2610,\n/**/\n    2609,\n/**/\n    2608,\n/**/\n    2607,\n/**/\n    2606,\n/**/\n    2605,\n/**/\n    2604,\n/**/\n    2603,\n/**/\n    2602,\n/**/\n    2601,\n/**/\n    2600,\n/**/\n    2599,\n/**/\n    2598,\n/**/\n    2597,\n/**/\n    2596,\n/**/\n    2595,\n/**/\n    2594,\n/**/\n    2593,\n/**/\n    2592,\n/**/\n    2591,\n/**/\n    2590,\n/**/\n    2589,\n/**/\n    2588,\n/**/\n    2587,\n/**/\n    2586,\n/**/\n    2585,\n/**/\n    2584,\n/**/\n    2583,\n/**/\n    2582,\n/**/\n    2581,\n/**/\n    2580,\n/**/\n    2579,\n/**/\n    2578,\n/**/\n    2577,\n/**/\n    2576,\n/**/\n    2575,\n/**/\n    2574,\n/**/\n    2573,\n/**/\n    2572,\n/**/\n    2571,\n/**/\n    2570,\n/**/\n    2569,\n/**/\n    2568,\n/**/\n    2567,\n/**/\n    2566,\n/**/\n    2565,\n/**/\n    2564,\n/**/\n    2563,\n/**/\n    2562,\n/**/\n    2561,\n/**/\n    2560,\n/**/\n    2559,\n/**/\n    2558,\n/**/\n    2557,\n/**/\n    2556,\n/**/\n    2555,\n/**/\n    2554,\n/**/\n    2553,\n/**/\n    2552,\n/**/\n    2551,\n/**/\n    2550,\n/**/\n    2549,\n/**/\n    2548,\n/**/\n    2547,\n/**/\n    2546,\n/**/\n    2545,\n/**/\n    2544,\n/**/\n    2543,\n/**/\n    2542,\n/**/\n    2541,\n/**/\n    2540,\n/**/\n    2539,\n/**/\n    2538,\n/**/\n    2537,\n/**/\n    2536,\n/**/\n    2535,\n/**/\n    2534,\n/**/\n    2533,\n/**/\n    2532,\n/**/\n    2531,\n/**/\n    2530,\n/**/\n    2529,\n/**/\n    2528,\n/**/\n    2527,\n/**/\n    2526,\n/**/\n    2525,\n/**/\n    2524,\n/**/\n    2523,\n/**/\n    2522,\n/**/\n    2521,\n/**/\n    2520,\n/**/\n    2519,\n/**/\n    2518,\n/**/\n    2517,\n/**/\n    2516,\n/**/\n    2515,\n/**/\n    2514,\n/**/\n    2513,\n/**/\n    2512,\n/**/\n    2511,\n/**/\n    2510,\n/**/\n    2509,\n/**/\n    2508,\n/**/\n    2507,\n/**/\n    2506,\n/**/\n    2505,\n/**/\n    2504,\n/**/\n    2503,\n/**/\n    2502,\n/**/\n    2501,\n/**/\n    2500,\n/**/\n    2499,\n/**/\n    2498,\n/**/\n    2497,\n/**/\n    2496,\n/**/\n    2495,\n/**/\n    2494,\n/**/\n    2493,\n/**/\n    2492,\n/**/\n    2491,\n/**/\n    2490,\n/**/\n    2489,\n/**/\n    2488,\n/**/\n    2487,\n/**/\n    2486,\n/**/\n    2485,\n/**/\n    2484,\n/**/\n    2483,\n/**/\n    2482,\n/**/\n    2481,\n/**/\n    2480,\n/**/\n    2479,\n/**/\n    2478,\n/**/\n    2477,\n/**/\n    2476,\n/**/\n    2475,\n/**/\n    2474,\n/**/\n    2473,\n/**/\n    2472,\n/**/\n    2471,\n/**/\n    2470,\n/**/\n    2469,\n/**/\n    2468,\n/**/\n    2467,\n/**/\n    2466,\n/**/\n    2465,\n/**/\n    2464,\n/**/\n    2463,\n/**/\n    2462,\n/**/\n    2461,\n/**/\n    2460,\n/**/\n    2459,\n/**/\n    2458,\n/**/\n    2457,\n/**/\n    2456,\n/**/\n    2455,\n/**/\n    2454,\n/**/\n    2453,\n/**/\n    2452,\n/**/\n    2451,\n/**/\n    2450,\n/**/\n    2449,\n/**/\n    2448,\n/**/\n    2447,\n/**/\n    2446,\n/**/\n    2445,\n/**/\n    2444,\n/**/\n    2443,\n/**/\n    2442,\n/**/\n    2441,\n/**/\n    2440,\n/**/\n    2439,\n/**/\n    2438,\n/**/\n    2437,\n/**/\n    2436,\n/**/\n    2435,\n/**/\n    2434,\n/**/\n    2433,\n/**/\n    2432,\n/**/\n    2431,\n/**/\n    2430,\n/**/\n    2429,\n/**/\n    2428,\n/**/\n    2427,\n/**/\n    2426,\n/**/\n    2425,\n/**/\n    2424,\n/**/\n    2423,\n/**/\n    2422,\n/**/\n    2421,\n/**/\n    2420,\n/**/\n    2419,\n/**/\n    2418,\n/**/\n    2417,\n/**/\n    2416,\n/**/\n    2415,\n/**/\n    2414,\n/**/\n    2413,\n/**/\n    2412,\n/**/\n    2411,\n/**/\n    2410,\n/**/\n    2409,\n/**/\n    2408,\n/**/\n    2407,\n/**/\n    2406,\n/**/\n    2405,\n/**/\n    2404,\n/**/\n    2403,\n/**/\n    2402,\n/**/\n    2401,\n/**/\n    2400,\n/**/\n    2399,\n/**/\n    2398,\n/**/\n    2397,\n/**/\n    2396,\n/**/\n    2395,\n/**/\n    2394,\n/**/\n    2393,\n/**/\n    2392,\n/**/\n    2391,\n/**/\n    2390,\n/**/\n    2389,\n/**/\n    2388,\n/**/\n    2387,\n/**/\n    2386,\n/**/\n    2385,\n/**/\n    2384,\n/**/\n    2383,\n/**/\n    2382,\n/**/\n    2381,\n/**/\n    2380,\n/**/\n    2379,\n/**/\n    2378,\n/**/\n    2377,\n/**/\n    2376,\n/**/\n    2375,\n/**/\n    2374,\n/**/\n    2373,\n/**/\n    2372,\n/**/\n    2371,\n/**/\n    2370,\n/**/\n    2369,\n/**/\n    2368,\n/**/\n    2367,\n/**/\n    2366,\n/**/\n    2365,\n/**/\n    2364,\n/**/\n    2363,\n/**/\n    2362,\n/**/\n    2361,\n/**/\n    2360,\n/**/\n    2359,\n/**/\n    2358,\n/**/\n    2357,\n/**/\n    2356,\n/**/\n    2355,\n/**/\n    2354,\n/**/\n    2353,\n/**/\n    2352,\n/**/\n    2351,\n/**/\n    2350,\n/**/\n    2349,\n/**/\n    2348,\n/**/\n    2347,\n/**/\n    2346,\n/**/\n    2345,\n/**/\n    2344,\n/**/\n    2343,\n/**/\n    2342,\n/**/\n    2341,\n/**/\n    2340,\n/**/\n    2339,\n/**/\n    2338,\n/**/\n    2337,\n/**/\n    2336,\n/**/\n    2335,\n/**/\n    2334,\n/**/\n    2333,\n/**/\n    2332,\n/**/\n    2331,\n/**/\n    2330,\n/**/\n    2329,\n/**/\n    2328,\n/**/\n    2327,\n/**/\n    2326,\n/**/\n    2325,\n/**/\n    2324,\n/**/\n    2323,\n/**/\n    2322,\n/**/\n    2321,\n/**/\n    2320,\n/**/\n    2319,\n/**/\n    2318,\n/**/\n    2317,\n/**/\n    2316,\n/**/\n    2315,\n/**/\n    2314,\n/**/\n    2313,\n/**/\n    2312,\n/**/\n    2311,\n/**/\n    2310,\n/**/\n    2309,\n/**/\n    2308,\n/**/\n    2307,\n/**/\n    2306,\n/**/\n    2305,\n/**/\n    2304,\n/**/\n    2303,\n/**/\n    2302,\n/**/\n    2301,\n/**/\n    2300,\n/**/\n    2299,\n/**/\n    2298,\n/**/\n    2297,\n/**/\n    2296,\n/**/\n    2295,\n/**/\n    2294,\n/**/\n    2293,\n/**/\n    2292,\n/**/\n    2291,\n/**/\n    2290,\n/**/\n    2289,\n/**/\n    2288,\n/**/\n    2287,\n/**/\n    2286,\n/**/\n    2285,\n/**/\n    2284,\n/**/\n    2283,\n/**/\n    2282,\n/**/\n    2281,\n/**/\n    2280,\n/**/\n    2279,\n/**/\n    2278,\n/**/\n    2277,\n/**/\n    2276,\n/**/\n    2275,\n/**/\n    2274,\n/**/\n    2273,\n/**/\n    2272,\n/**/\n    2271,\n/**/\n    2270,\n/**/\n    2269,\n/**/\n    2268,\n/**/\n    2267,\n/**/\n    2266,\n/**/\n    2265,\n/**/\n    2264,\n/**/\n    2263,\n/**/\n    2262,\n/**/\n    2261,\n/**/\n    2260,\n/**/\n    2259,\n/**/\n    2258,\n/**/\n    2257,\n/**/\n    2256,\n/**/\n    2255,\n/**/\n    2254,\n/**/\n    2253,\n/**/\n    2252,\n/**/\n    2251,\n/**/\n    2250,\n/**/\n    2249,\n/**/\n    2248,\n/**/\n    2247,\n/**/\n    2246,\n/**/\n    2245,\n/**/\n    2244,\n/**/\n    2243,\n/**/\n    2242,\n/**/\n    2241,\n/**/\n    2240,\n/**/\n    2239,\n/**/\n    2238,\n/**/\n    2237,\n/**/\n    2236,\n/**/\n    2235,\n/**/\n    2234,\n/**/\n    2233,\n/**/\n    2232,\n/**/\n    2231,\n/**/\n    2230,\n/**/\n    2229,\n/**/\n    2228,\n/**/\n    2227,\n/**/\n    2226,\n/**/\n    2225,\n/**/\n    2224,\n/**/\n    2223,\n/**/\n    2222,\n/**/\n    2221,\n/**/\n    2220,\n/**/\n    2219,\n/**/\n    2218,\n/**/\n    2217,\n/**/\n    2216,\n/**/\n    2215,\n/**/\n    2214,\n/**/\n    2213,\n/**/\n    2212,\n/**/\n    2211,\n/**/\n    2210,\n/**/\n    2209,\n/**/\n    2208,\n/**/\n    2207,\n/**/\n    2206,\n/**/\n    2205,\n/**/\n    2204,\n/**/\n    2203,\n/**/\n    2202,\n/**/\n    2201,\n/**/\n    2200,\n/**/\n    2199,\n/**/\n    2198,\n/**/\n    2197,\n/**/\n    2196,\n/**/\n    2195,\n/**/\n    2194,\n/**/\n    2193,\n/**/\n    2192,\n/**/\n    2191,\n/**/\n    2190,\n/**/\n    2189,\n/**/\n    2188,\n/**/\n    2187,\n/**/\n    2186,\n/**/\n    2185,\n/**/\n    2184,\n/**/\n    2183,\n/**/\n    2182,\n/**/\n    2181,\n/**/\n    2180,\n/**/\n    2179,\n/**/\n    2178,\n/**/\n    2177,\n/**/\n    2176,\n/**/\n    2175,\n/**/\n    2174,\n/**/\n    2173,\n/**/\n    2172,\n/**/\n    2171,\n/**/\n    2170,\n/**/\n    2169,\n/**/\n    2168,\n/**/\n    2167,\n/**/\n    2166,\n/**/\n    2165,\n/**/\n    2164,\n/**/\n    2163,\n/**/\n    2162,\n/**/\n    2161,\n/**/\n    2160,\n/**/\n    2159,\n/**/\n    2158,\n/**/\n    2157,\n/**/\n    2156,\n/**/\n    2155,\n/**/\n    2154,\n/**/\n    2153,\n/**/\n    2152,\n/**/\n    2151,\n/**/\n    2150,\n/**/\n    2149,\n/**/\n    2148,\n/**/\n    2147,\n/**/\n    2146,\n/**/\n    2145,\n/**/\n    2144,\n/**/\n    2143,\n/**/\n    2142,\n/**/\n    2141,\n/**/\n    2140,\n/**/\n    2139,\n/**/\n    2138,\n/**/\n    2137,\n/**/\n    2136,\n/**/\n    2135,\n/**/\n    2134,\n/**/\n    2133,\n/**/\n    2132,\n/**/\n    2131,\n/**/\n    2130,\n/**/\n    2129,\n/**/\n    2128,\n/**/\n    2127,\n/**/\n    2126,\n/**/\n    2125,\n/**/\n    2124,\n/**/\n    2123,\n/**/\n    2122,\n/**/\n    2121,\n/**/\n    2120,\n/**/\n    2119,\n/**/\n    2118,\n/**/\n    2117,\n/**/\n    2116,\n/**/\n    2115,\n/**/\n    2114,\n/**/\n    2113,\n/**/\n    2112,\n/**/\n    2111,\n/**/\n    2110,\n/**/\n    2109,\n/**/\n    2108,\n/**/\n    2107,\n/**/\n    2106,\n/**/\n    2105,\n/**/\n    2104,\n/**/\n    2103,\n/**/\n    2102,\n/**/\n    2101,\n/**/\n    2100,\n/**/\n    2099,\n/**/\n    2098,\n/**/\n    2097,\n/**/\n    2096,\n/**/\n    2095,\n/**/\n    2094,\n/**/\n    2093,\n/**/\n    2092,\n/**/\n    2091,\n/**/\n    2090,\n/**/\n    2089,\n/**/\n    2088,\n/**/\n    2087,\n/**/\n    2086,\n/**/\n    2085,\n/**/\n    2084,\n/**/\n    2083,\n/**/\n    2082,\n/**/\n    2081,\n/**/\n    2080,\n/**/\n    2079,\n/**/\n    2078,\n/**/\n    2077,\n/**/\n    2076,\n/**/\n    2075,\n/**/\n    2074,\n/**/\n    2073,\n/**/\n    2072,\n/**/\n    2071,\n/**/\n    2070,\n/**/\n    2069,\n/**/\n    2068,\n/**/\n    2067,\n/**/\n    2066,\n/**/\n    2065,\n/**/\n    2064,\n/**/\n    2063,\n/**/\n    2062,\n/**/\n    2061,\n/**/\n    2060,\n/**/\n    2059,\n/**/\n    2058,\n/**/\n    2057,\n/**/\n    2056,\n/**/\n    2055,\n/**/\n    2054,\n/**/\n    2053,\n/**/\n    2052,\n/**/\n    2051,\n/**/\n    2050,\n/**/\n    2049,\n/**/\n    2048,\n/**/\n    2047,\n/**/\n    2046,\n/**/\n    2045,\n/**/\n    2044,\n/**/\n    2043,\n/**/\n    2042,\n/**/\n    2041,\n/**/\n    2040,\n/**/\n    2039,\n/**/\n    2038,\n/**/\n    2037,\n/**/\n    2036,\n/**/\n    2035,\n/**/\n    2034,\n/**/\n    2033,\n/**/\n    2032,\n/**/\n    2031,\n/**/\n    2030,\n/**/\n    2029,\n/**/\n    2028,\n/**/\n    2027,\n/**/\n    2026,\n/**/\n    2025,\n/**/\n    2024,\n/**/\n    2023,\n/**/\n    2022,\n/**/\n    2021,\n/**/\n    2020,\n/**/\n    2019,\n/**/\n    2018,\n/**/\n    2017,\n/**/\n    2016,\n/**/\n    2015,\n/**/\n    2014,\n/**/\n    2013,\n/**/\n    2012,\n/**/\n    2011,\n/**/\n    2010,\n/**/\n    2009,\n/**/\n    2008,\n/**/\n    2007,\n/**/\n    2006,\n/**/\n    2005,\n/**/\n    2004,\n/**/\n    2003,\n/**/\n    2002,\n/**/\n    2001,\n/**/\n    2000,\n/**/\n    1999,\n/**/\n    1998,\n/**/\n    1997,\n/**/\n    1996,\n/**/\n    1995,\n/**/\n    1994,\n/**/\n    1993,\n/**/\n    1992,\n/**/\n    1991,\n/**/\n    1990,\n/**/\n    1989,\n/**/\n    1988,\n/**/\n    1987,\n/**/\n    1986,\n/**/\n    1985,\n/**/\n    1984,\n/**/\n    1983,\n/**/\n    1982,\n/**/\n    1981,\n/**/\n    1980,\n/**/\n    1979,\n/**/\n    1978,\n/**/\n    1977,\n/**/\n    1976,\n/**/\n    1975,\n/**/\n    1974,\n/**/\n    1973,\n/**/\n    1972,\n/**/\n    1971,\n/**/\n    1970,\n/**/\n    1969,\n/**/\n    1968,\n/**/\n    1967,\n/**/\n    1966,\n/**/\n    1965,\n/**/\n    1964,\n/**/\n    1963,\n/**/\n    1962,\n/**/\n    1961,\n/**/\n    1960,\n/**/\n    1959,\n/**/\n    1958,\n/**/\n    1957,\n/**/\n    1956,\n/**/\n    1955,\n/**/\n    1954,\n/**/\n    1953,\n/**/\n    1952,\n/**/\n    1951,\n/**/\n    1950,\n/**/\n    1949,\n/**/\n    1948,\n/**/\n    1947,\n/**/\n    1946,\n/**/\n    1945,\n/**/\n    1944,\n/**/\n    1943,\n/**/\n    1942,\n/**/\n    1941,\n/**/\n    1940,\n/**/\n    1939,\n/**/\n    1938,\n/**/\n    1937,\n/**/\n    1936,\n/**/\n    1935,\n/**/\n    1934,\n/**/\n    1933,\n/**/\n    1932,\n/**/\n    1931,\n/**/\n    1930,\n/**/\n    1929,\n/**/\n    1928,\n/**/\n    1927,\n/**/\n    1926,\n/**/\n    1925,\n/**/\n    1924,\n/**/\n    1923,\n/**/\n    1922,\n/**/\n    1921,\n/**/\n    1920,\n/**/\n    1919,\n/**/\n    1918,\n/**/\n    1917,\n/**/\n    1916,\n/**/\n    1915,\n/**/\n    1914,\n/**/\n    1913,\n/**/\n    1912,\n/**/\n    1911,\n/**/\n    1910,\n/**/\n    1909,\n/**/\n    1908,\n/**/\n    1907,\n/**/\n    1906,\n/**/\n    1905,\n/**/\n    1904,\n/**/\n    1903,\n/**/\n    1902,\n/**/\n    1901,\n/**/\n    1900,\n/**/\n    1899,\n/**/\n    1898,\n/**/\n    1897,\n/**/\n    1896,\n/**/\n    1895,\n/**/\n    1894,\n/**/\n    1893,\n/**/\n    1892,\n/**/\n    1891,\n/**/\n    1890,\n/**/\n    1889,\n/**/\n    1888,\n/**/\n    1887,\n/**/\n    1886,\n/**/\n    1885,\n/**/\n    1884,\n/**/\n    1883,\n/**/\n    1882,\n/**/\n    1881,\n/**/\n    1880,\n/**/\n    1879,\n/**/\n    1878,\n/**/\n    1877,\n/**/\n    1876,\n/**/\n    1875,\n/**/\n    1874,\n/**/\n    1873,\n/**/\n    1872,\n/**/\n    1871,\n/**/\n    1870,\n/**/\n    1869,\n/**/\n    1868,\n/**/\n    1867,\n/**/\n    1866,\n/**/\n    1865,\n/**/\n    1864,\n/**/\n    1863,\n/**/\n    1862,\n/**/\n    1861,\n/**/\n    1860,\n/**/\n    1859,\n/**/\n    1858,\n/**/\n    1857,\n/**/\n    1856,\n/**/\n    1855,\n/**/\n    1854,\n/**/\n    1853,\n/**/\n    1852,\n/**/\n    1851,\n/**/\n    1850,\n/**/\n    1849,\n/**/\n    1848,\n/**/\n    1847,\n/**/\n    1846,\n/**/\n    1845,\n/**/\n    1844,\n/**/\n    1843,\n/**/\n    1842,\n/**/\n    1841,\n/**/\n    1840,\n/**/\n    1839,\n/**/\n    1838,\n/**/\n    1837,\n/**/\n    1836,\n/**/\n    1835,\n/**/\n    1834,\n/**/\n    1833,\n/**/\n    1832,\n/**/\n    1831,\n/**/\n    1830,\n/**/\n    1829,\n/**/\n    1828,\n/**/\n    1827,\n/**/\n    1826,\n/**/\n    1825,\n/**/\n    1824,\n/**/\n    1823,\n/**/\n    1822,\n/**/\n    1821,\n/**/\n    1820,\n/**/\n    1819,\n/**/\n    1818,\n/**/\n    1817,\n/**/\n    1816,\n/**/\n    1815,\n/**/\n    1814,\n/**/\n    1813,\n/**/\n    1812,\n/**/\n    1811,\n/**/\n    1810,\n/**/\n    1809,\n/**/\n    1808,\n/**/\n    1807,\n/**/\n    1806,\n/**/\n    1805,\n/**/\n    1804,\n/**/\n    1803,\n/**/\n    1802,\n/**/\n    1801,\n/**/\n    1800,\n/**/\n    1799,\n/**/\n    1798,\n/**/\n    1797,\n/**/\n    1796,\n/**/\n    1795,\n/**/\n    1794,\n/**/\n    1793,\n/**/\n    1792,\n/**/\n    1791,\n/**/\n    1790,\n/**/\n    1789,\n/**/\n    1788,\n/**/\n    1787,\n/**/\n    1786,\n/**/\n    1785,\n/**/\n    1784,\n/**/\n    1783,\n/**/\n    1782,\n/**/\n    1781,\n/**/\n    1780,\n/**/\n    1779,\n/**/\n    1778,\n/**/\n    1777,\n/**/\n    1776,\n/**/\n    1775,\n/**/\n    1774,\n/**/\n    1773,\n/**/\n    1772,\n/**/\n    1771,\n/**/\n    1770,\n/**/\n    1769,\n/**/\n    1768,\n/**/\n    1767,\n/**/\n    1766,\n/**/\n    1765,\n/**/\n    1764,\n/**/\n    1763,\n/**/\n    1762,\n/**/\n    1761,\n/**/\n    1760,\n/**/\n    1759,\n/**/\n    1758,\n/**/\n    1757,\n/**/\n    1756,\n/**/\n    1755,\n/**/\n    1754,\n/**/\n    1753,\n/**/\n    1752,\n/**/\n    1751,\n/**/\n    1750,\n/**/\n    1749,\n/**/\n    1748,\n/**/\n    1747,\n/**/\n    1746,\n/**/\n    1745,\n/**/\n    1744,\n/**/\n    1743,\n/**/\n    1742,\n/**/\n    1741,\n/**/\n    1740,\n/**/\n    1739,\n/**/\n    1738,\n/**/\n    1737,\n/**/\n    1736,\n/**/\n    1735,\n/**/\n    1734,\n/**/\n    1733,\n/**/\n    1732,\n/**/\n    1731,\n/**/\n    1730,\n/**/\n    1729,\n/**/\n    1728,\n/**/\n    1727,\n/**/\n    1726,\n/**/\n    1725,\n/**/\n    1724,\n/**/\n    1723,\n/**/\n    1722,\n/**/\n    1721,\n/**/\n    1720,\n/**/\n    1719,\n/**/\n    1718,\n/**/\n    1717,\n/**/\n    1716,\n/**/\n    1715,\n/**/\n    1714,\n/**/\n    1713,\n/**/\n    1712,\n/**/\n    1711,\n/**/\n    1710,\n/**/\n    1709,\n/**/\n    1708,\n/**/\n    1707,\n/**/\n    1706,\n/**/\n    1705,\n/**/\n    1704,\n/**/\n    1703,\n/**/\n    1702,\n/**/\n    1701,\n/**/\n    1700,\n/**/\n    1699,\n/**/\n    1698,\n/**/\n    1697,\n/**/\n    1696,\n/**/\n    1695,\n/**/\n    1694,\n/**/\n    1693,\n/**/\n    1692,\n/**/\n    1691,\n/**/\n    1690,\n/**/\n    1689,\n/**/\n    1688,\n/**/\n    1687,\n/**/\n    1686,\n/**/\n    1685,\n/**/\n    1684,\n/**/\n    1683,\n/**/\n    1682,\n/**/\n    1681,\n/**/\n    1680,\n/**/\n    1679,\n/**/\n    1678,\n/**/\n    1677,\n/**/\n    1676,\n/**/\n    1675,\n/**/\n    1674,\n/**/\n    1673,\n/**/\n    1672,\n/**/\n    1671,\n/**/\n    1670,\n/**/\n    1669,\n/**/\n    1668,\n/**/\n    1667,\n/**/\n    1666,\n/**/\n    1665,\n/**/\n    1664,\n/**/\n    1663,\n/**/\n    1662,\n/**/\n    1661,\n/**/\n    1660,\n/**/\n    1659,\n/**/\n    1658,\n/**/\n    1657,\n/**/\n    1656,\n/**/\n    1655,\n/**/\n    1654,\n/**/\n    1653,\n/**/\n    1652,\n/**/\n    1651,\n/**/\n    1650,\n/**/\n    1649,\n/**/\n    1648,\n/**/\n    1647,\n/**/\n    1646,\n/**/\n    1645,\n/**/\n    1644,\n/**/\n    1643,\n/**/\n    1642,\n/**/\n    1641,\n/**/\n    1640,\n/**/\n    1639,\n/**/\n    1638,\n/**/\n    1637,\n/**/\n    1636,\n/**/\n    1635,\n/**/\n    1634,\n/**/\n    1633,\n/**/\n    1632,\n/**/\n    1631,\n/**/\n    1630,\n/**/\n    1629,\n/**/\n    1628,\n/**/\n    1627,\n/**/\n    1626,\n/**/\n    1625,\n/**/\n    1624,\n/**/\n    1623,\n/**/\n    1622,\n/**/\n    1621,\n/**/\n    1620,\n/**/\n    1619,\n/**/\n    1618,\n/**/\n    1617,\n/**/\n    1616,\n/**/\n    1615,\n/**/\n    1614,\n/**/\n    1613,\n/**/\n    1612,\n/**/\n    1611,\n/**/\n    1610,\n/**/\n    1609,\n/**/\n    1608,\n/**/\n    1607,\n/**/\n    1606,\n/**/\n    1605,\n/**/\n    1604,\n/**/\n    1603,\n/**/\n    1602,\n/**/\n    1601,\n/**/\n    1600,\n/**/\n    1599,\n/**/\n    1598,\n/**/\n    1597,\n/**/\n    1596,\n/**/\n    1595,\n/**/\n    1594,\n/**/\n    1593,\n/**/\n    1592,\n/**/\n    1591,\n/**/\n    1590,\n/**/\n    1589,\n/**/\n    1588,\n/**/\n    1587,\n/**/\n    1586,\n/**/\n    1585,\n/**/\n    1584,\n/**/\n    1583,\n/**/\n    1582,\n/**/\n    1581,\n/**/\n    1580,\n/**/\n    1579,\n/**/\n    1578,\n/**/\n    1577,\n/**/\n    1576,\n/**/\n    1575,\n/**/\n    1574,\n/**/\n    1573,\n/**/\n    1572,\n/**/\n    1571,\n/**/\n    1570,\n/**/\n    1569,\n/**/\n    1568,\n/**/\n    1567,\n/**/\n    1566,\n/**/\n    1565,\n/**/\n    1564,\n/**/\n    1563,\n/**/\n    1562,\n/**/\n    1561,\n/**/\n    1560,\n/**/\n    1559,\n/**/\n    1558,\n/**/\n    1557,\n/**/\n    1556,\n/**/\n    1555,\n/**/\n    1554,\n/**/\n    1553,\n/**/\n    1552,\n/**/\n    1551,\n/**/\n    1550,\n/**/\n    1549,\n/**/\n    1548,\n/**/\n    1547,\n/**/\n    1546,\n/**/\n    1545,\n/**/\n    1544,\n/**/\n    1543,\n/**/\n    1542,\n/**/\n    1541,\n/**/\n    1540,\n/**/\n    1539,\n/**/\n    1538,\n/**/\n    1537,\n/**/\n    1536,\n/**/\n    1535,\n/**/\n    1534,\n/**/\n    1533,\n/**/\n    1532,\n/**/\n    1531,\n/**/\n    1530,\n/**/\n    1529,\n/**/\n    1528,\n/**/\n    1527,\n/**/\n    1526,\n/**/\n    1525,\n/**/\n    1524,\n/**/\n    1523,\n/**/\n    1522,\n/**/\n    1521,\n/**/\n    1520,\n/**/\n    1519,\n/**/\n    1518,\n/**/\n    1517,\n/**/\n    1516,\n/**/\n    1515,\n/**/\n    1514,\n/**/\n    1513,\n/**/\n    1512,\n/**/\n    1511,\n/**/\n    1510,\n/**/\n    1509,\n/**/\n    1508,\n/**/\n    1507,\n/**/\n    1506,\n/**/\n    1505,\n/**/\n    1504,\n/**/\n    1503,\n/**/\n    1502,\n/**/\n    1501,\n/**/\n    1500,\n/**/\n    1499,\n/**/\n    1498,\n/**/\n    1497,\n/**/\n    1496,\n/**/\n    1495,\n/**/\n    1494,\n/**/\n    1493,\n/**/\n    1492,\n/**/\n    1491,\n/**/\n    1490,\n/**/\n    1489,\n/**/\n    1488,\n/**/\n    1487,\n/**/\n    1486,\n/**/\n    1485,\n/**/\n    1484,\n/**/\n    1483,\n/**/\n    1482,\n/**/\n    1481,\n/**/\n    1480,\n/**/\n    1479,\n/**/\n    1478,\n/**/\n    1477,\n/**/\n    1476,\n/**/\n    1475,\n/**/\n    1474,\n/**/\n    1473,\n/**/\n    1472,\n/**/\n    1471,\n/**/\n    1470,\n/**/\n    1469,\n/**/\n    1468,\n/**/\n    1467,\n/**/\n    1466,\n/**/\n    1465,\n/**/\n    1464,\n/**/\n    1463,\n/**/\n    1462,\n/**/\n    1461,\n/**/\n    1460,\n/**/\n    1459,\n/**/\n    1458,\n/**/\n    1457,\n/**/\n    1456,\n/**/\n    1455,\n/**/\n    1454,\n/**/\n    1453,\n/**/\n    1452,\n/**/\n    1451,\n/**/\n    1450,\n/**/\n    1449,\n/**/\n    1448,\n/**/\n    1447,\n/**/\n    1446,\n/**/\n    1445,\n/**/\n    1444,\n/**/\n    1443,\n/**/\n    1442,\n/**/\n    1441,\n/**/\n    1440,\n/**/\n    1439,\n/**/\n    1438,\n/**/\n    1437,\n/**/\n    1436,\n/**/\n    1435,\n/**/\n    1434,\n/**/\n    1433,\n/**/\n    1432,\n/**/\n    1431,\n/**/\n    1430,\n/**/\n    1429,\n/**/\n    1428,\n/**/\n    1427,\n/**/\n    1426,\n/**/\n    1425,\n/**/\n    1424,\n/**/\n    1423,\n/**/\n    1422,\n/**/\n    1421,\n/**/\n    1420,\n/**/\n    1419,\n/**/\n    1418,\n/**/\n    1417,\n/**/\n    1416,\n/**/\n    1415,\n/**/\n    1414,\n/**/\n    1413,\n/**/\n    1412,\n/**/\n    1411,\n/**/\n    1410,\n/**/\n    1409,\n/**/\n    1408,\n/**/\n    1407,\n/**/\n    1406,\n/**/\n    1405,\n/**/\n    1404,\n/**/\n    1403,\n/**/\n    1402,\n/**/\n    1401,\n/**/\n    1400,\n/**/\n    1399,\n/**/\n    1398,\n/**/\n    1397,\n/**/\n    1396,\n/**/\n    1395,\n/**/\n    1394,\n/**/\n    1393,\n/**/\n    1392,\n/**/\n    1391,\n/**/\n    1390,\n/**/\n    1389,\n/**/\n    1388,\n/**/\n    1387,\n/**/\n    1386,\n/**/\n    1385,\n/**/\n    1384,\n/**/\n    1383,\n/**/\n    1382,\n/**/\n    1381,\n/**/\n    1380,\n/**/\n    1379,\n/**/\n    1378,\n/**/\n    1377,\n/**/\n    1376,\n/**/\n    1375,\n/**/\n    1374,\n/**/\n    1373,\n/**/\n    1372,\n/**/\n    1371,\n/**/\n    1370,\n/**/\n    1369,\n/**/\n    1368,\n/**/\n    1367,\n/**/\n    1366,\n/**/\n    1365,\n/**/\n    1364,\n/**/\n    1363,\n/**/\n    1362,\n/**/\n    1361,\n/**/\n    1360,\n/**/\n    1359,\n/**/\n    1358,\n/**/\n    1357,\n/**/\n    1356,\n/**/\n    1355,\n/**/\n    1354,\n/**/\n    1353,\n/**/\n    1352,\n/**/\n    1351,\n/**/\n    1350,\n/**/\n    1349,\n/**/\n    1348,\n/**/\n    1347,\n/**/\n    1346,\n/**/\n    1345,\n/**/\n    1344,\n/**/\n    1343,\n/**/\n    1342,\n/**/\n    1341,\n/**/\n    1340,\n/**/\n    1339,\n/**/\n    1338,\n/**/\n    1337,\n/**/\n    1336,\n/**/\n    1335,\n/**/\n    1334,\n/**/\n    1333,\n/**/\n    1332,\n/**/\n    1331,\n/**/\n    1330,\n/**/\n    1329,\n/**/\n    1328,\n/**/\n    1327,\n/**/\n    1326,\n/**/\n    1325,\n/**/\n    1324,\n/**/\n    1323,\n/**/\n    1322,\n/**/\n    1321,\n/**/\n    1320,\n/**/\n    1319,\n/**/\n    1318,\n/**/\n    1317,\n/**/\n    1316,\n/**/\n    1315,\n/**/\n    1314,\n/**/\n    1313,\n/**/\n    1312,\n/**/\n    1311,\n/**/\n    1310,\n/**/\n    1309,\n/**/\n    1308,\n/**/\n    1307,\n/**/\n    1306,\n/**/\n    1305,\n/**/\n    1304,\n/**/\n    1303,\n/**/\n    1302,\n/**/\n    1301,\n/**/\n    1300,\n/**/\n    1299,\n/**/\n    1298,\n/**/\n    1297,\n/**/\n    1296,\n/**/\n    1295,\n/**/\n    1294,\n/**/\n    1293,\n/**/\n    1292,\n/**/\n    1291,\n/**/\n    1290,\n/**/\n    1289,\n/**/\n    1288,\n/**/\n    1287,\n/**/\n    1286,\n/**/\n    1285,\n/**/\n    1284,\n/**/\n    1283,\n/**/\n    1282,\n/**/\n    1281,\n/**/\n    1280,\n/**/\n    1279,\n/**/\n    1278,\n/**/\n    1277,\n/**/\n    1276,\n/**/\n    1275,\n/**/\n    1274,\n/**/\n    1273,\n/**/\n    1272,\n/**/\n    1271,\n/**/\n    1270,\n/**/\n    1269,\n/**/\n    1268,\n/**/\n    1267,\n/**/\n    1266,\n/**/\n    1265,\n/**/\n    1264,\n/**/\n    1263,\n/**/\n    1262,\n/**/\n    1261,\n/**/\n    1260,\n/**/\n    1259,\n/**/\n    1258,\n/**/\n    1257,\n/**/\n    1256,\n/**/\n    1255,\n/**/\n    1254,\n/**/\n    1253,\n/**/\n    1252,\n/**/\n    1251,\n/**/\n    1250,\n/**/\n    1249,\n/**/\n    1248,\n/**/\n    1247,\n/**/\n    1246,\n/**/\n    1245,\n/**/\n    1244,\n/**/\n    1243,\n/**/\n    1242,\n/**/\n    1241,\n/**/\n    1240,\n/**/\n    1239,\n/**/\n    1238,\n/**/\n    1237,\n/**/\n    1236,\n/**/\n    1235,\n/**/\n    1234,\n/**/\n    1233,\n/**/\n    1232,\n/**/\n    1231,\n/**/\n    1230,\n/**/\n    1229,\n/**/\n    1228,\n/**/\n    1227,\n/**/\n    1226,\n/**/\n    1225,\n/**/\n    1224,\n/**/\n    1223,\n/**/\n    1222,\n/**/\n    1221,\n/**/\n    1220,\n/**/\n    1219,\n/**/\n    1218,\n/**/\n    1217,\n/**/\n    1216,\n/**/\n    1215,\n/**/\n    1214,\n/**/\n    1213,\n/**/\n    1212,\n/**/\n    1211,\n/**/\n    1210,\n/**/\n    1209,\n/**/\n    1208,\n/**/\n    1207,\n/**/\n    1206,\n/**/\n    1205,\n/**/\n    1204,\n/**/\n    1203,\n/**/\n    1202,\n/**/\n    1201,\n/**/\n    1200,\n/**/\n    1199,\n/**/\n    1198,\n/**/\n    1197,\n/**/\n    1196,\n/**/\n    1195,\n/**/\n    1194,\n/**/\n    1193,\n/**/\n    1192,\n/**/\n    1191,\n/**/\n    1190,\n/**/\n    1189,\n/**/\n    1188,\n/**/\n    1187,\n/**/\n    1186,\n/**/\n    1185,\n/**/\n    1184,\n/**/\n    1183,\n/**/\n    1182,\n/**/\n    1181,\n/**/\n    1180,\n/**/\n    1179,\n/**/\n    1178,\n/**/\n    1177,\n/**/\n    1176,\n/**/\n    1175,\n/**/\n    1174,\n/**/\n    1173,\n/**/\n    1172,\n/**/\n    1171,\n/**/\n    1170,\n/**/\n    1169,\n/**/\n    1168,\n/**/\n    1167,\n/**/\n    1166,\n/**/\n    1165,\n/**/\n    1164,\n/**/\n    1163,\n/**/\n    1162,\n/**/\n    1161,\n/**/\n    1160,\n/**/\n    1159,\n/**/\n    1158,\n/**/\n    1157,\n/**/\n    1156,\n/**/\n    1155,\n/**/\n    1154,\n/**/\n    1153,\n/**/\n    1152,\n/**/\n    1151,\n/**/\n    1150,\n/**/\n    1149,\n/**/\n    1148,\n/**/\n    1147,\n/**/\n    1146,\n/**/\n    1145,\n/**/\n    1144,\n/**/\n    1143,\n/**/\n    1142,\n/**/\n    1141,\n/**/\n    1140,\n/**/\n    1139,\n/**/\n    1138,\n/**/\n    1137,\n/**/\n    1136,\n/**/\n    1135,\n/**/\n    1134,\n/**/\n    1133,\n/**/\n    1132,\n/**/\n    1131,\n/**/\n    1130,\n/**/\n    1129,\n/**/\n    1128,\n/**/\n    1127,\n/**/\n    1126,\n/**/\n    1125,\n/**/\n    1124,\n/**/\n    1123,\n/**/\n    1122,\n/**/\n    1121,\n/**/\n    1120,\n/**/\n    1119,\n/**/\n    1118,\n/**/\n    1117,\n/**/\n    1116,\n/**/\n    1115,\n/**/\n    1114,\n/**/\n    1113,\n/**/\n    1112,\n/**/\n    1111,\n/**/\n    1110,\n/**/\n    1109,\n/**/\n    1108,\n/**/\n    1107,\n/**/\n    1106,\n/**/\n    1105,\n/**/\n    1104,\n/**/\n    1103,\n/**/\n    1102,\n/**/\n    1101,\n/**/\n    1100,\n/**/\n    1099,\n/**/\n    1098,\n/**/\n    1097,\n/**/\n    1096,\n/**/\n    1095,\n/**/\n    1094,\n/**/\n    1093,\n/**/\n    1092,\n/**/\n    1091,\n/**/\n    1090,\n/**/\n    1089,\n/**/\n    1088,\n/**/\n    1087,\n/**/\n    1086,\n/**/\n    1085,\n/**/\n    1084,\n/**/\n    1083,\n/**/\n    1082,\n/**/\n    1081,\n/**/\n    1080,\n/**/\n    1079,\n/**/\n    1078,\n/**/\n    1077,\n/**/\n    1076,\n/**/\n    1075,\n/**/\n    1074,\n/**/\n    1073,\n/**/\n    1072,\n/**/\n    1071,\n/**/\n    1070,\n/**/\n    1069,\n/**/\n    1068,\n/**/\n    1067,\n/**/\n    1066,\n/**/\n    1065,\n/**/\n    1064,\n/**/\n    1063,\n/**/\n    1062,\n/**/\n    1061,\n/**/\n    1060,\n/**/\n    1059,\n/**/\n    1058,\n/**/\n    1057,\n/**/\n    1056,\n/**/\n    1055,\n/**/\n    1054,\n/**/\n    1053,\n/**/\n    1052,\n/**/\n    1051,\n/**/\n    1050,\n/**/\n    1049,\n/**/\n    1048,\n/**/\n    1047,\n/**/\n    1046,\n/**/\n    1045,\n/**/\n    1044,\n/**/\n    1043,\n/**/\n    1042,\n/**/\n    1041,\n/**/\n    1040,\n/**/\n    1039,\n/**/\n    1038,\n/**/\n    1037,\n/**/\n    1036,\n/**/\n    1035,\n/**/\n    1034,\n/**/\n    1033,\n/**/\n    1032,\n/**/\n    1031,\n/**/\n    1030,\n/**/\n    1029,\n/**/\n    1028,\n/**/\n    1027,\n/**/\n    1026,\n/**/\n    1025,\n/**/\n    1024,\n/**/\n    1023,\n/**/\n    1022,\n/**/\n    1021,\n/**/\n    1020,\n/**/\n    1019,\n/**/\n    1018,\n/**/\n    1017,\n/**/\n    1016,\n/**/\n    1015,\n/**/\n    1014,\n/**/\n    1013,\n/**/\n    1012,\n/**/\n    1011,\n/**/\n    1010,\n/**/\n    1009,\n/**/\n    1008,\n/**/\n    1007,\n/**/\n    1006,\n/**/\n    1005,\n/**/\n    1004,\n/**/\n    1003,\n/**/\n    1002,\n/**/\n    1001,\n/**/\n    1000,\n/**/\n    999,\n/**/\n    998,\n/**/\n    997,\n/**/\n    996,\n/**/\n    995,\n/**/\n    994,\n/**/\n    993,\n/**/\n    992,\n/**/\n    991,\n/**/\n    990,\n/**/\n    989,\n/**/\n    988,\n/**/\n    987,\n/**/\n    986,\n/**/\n    985,\n/**/\n    984,\n/**/\n    983,\n/**/\n    982,\n/**/\n    981,\n/**/\n    980,\n/**/\n    979,\n/**/\n    978,\n/**/\n    977,\n/**/\n    976,\n/**/\n    975,\n/**/\n    974,\n/**/\n    973,\n/**/\n    972,\n/**/\n    971,\n/**/\n    970,\n/**/\n    969,\n/**/\n    968,\n/**/\n    967,\n/**/\n    966,\n/**/\n    965,\n/**/\n    964,\n/**/\n    963,\n/**/\n    962,\n/**/\n    961,\n/**/\n    960,\n/**/\n    959,\n/**/\n    958,\n/**/\n    957,\n/**/\n    956,\n/**/\n    955,\n/**/\n    954,\n/**/\n    953,\n/**/\n    952,\n/**/\n    951,\n/**/\n    950,\n/**/\n    949,\n/**/\n    948,\n/**/\n    947,\n/**/\n    946,\n/**/\n    945,\n/**/\n    944,\n/**/\n    943,\n/**/\n    942,\n/**/\n    941,\n/**/\n    940,\n/**/\n    939,\n/**/\n    938,\n/**/\n    937,\n/**/\n    936,\n/**/\n    935,\n/**/\n    934,\n/**/\n    933,\n/**/\n    932,\n/**/\n    931,\n/**/\n    930,\n/**/\n    929,\n/**/\n    928,\n/**/\n    927,\n/**/\n    926,\n/**/\n    925,\n/**/\n    924,\n/**/\n    923,\n/**/\n    922,\n/**/\n    921,\n/**/\n    920,\n/**/\n    919,\n/**/\n    918,\n/**/\n    917,\n/**/\n    916,\n/**/\n    915,\n/**/\n    914,\n/**/\n    913,\n/**/\n    912,\n/**/\n    911,\n/**/\n    910,\n/**/\n    909,\n/**/\n    908,\n/**/\n    907,\n/**/\n    906,\n/**/\n    905,\n/**/\n    904,\n/**/\n    903,\n/**/\n    902,\n/**/\n    901,\n/**/\n    900,\n/**/\n    899,\n/**/\n    898,\n/**/\n    897,\n/**/\n    896,\n/**/\n    895,\n/**/\n    894,\n/**/\n    893,\n/**/\n    892,\n/**/\n    891,\n/**/\n    890,\n/**/\n    889,\n/**/\n    888,\n/**/\n    887,\n/**/\n    886,\n/**/\n    885,\n/**/\n    884,\n/**/\n    883,\n/**/\n    882,\n/**/\n    881,\n/**/\n    880,\n/**/\n    879,\n/**/\n    878,\n/**/\n    877,\n/**/\n    876,\n/**/\n    875,\n/**/\n    874,\n/**/\n    873,\n/**/\n    872,\n/**/\n    871,\n/**/\n    870,\n/**/\n    869,\n/**/\n    868,\n/**/\n    867,\n/**/\n    866,\n/**/\n    865,\n/**/\n    864,\n/**/\n    863,\n/**/\n    862,\n/**/\n    861,\n/**/\n    860,\n/**/\n    859,\n/**/\n    858,\n/**/\n    857,\n/**/\n    856,\n/**/\n    855,\n/**/\n    854,\n/**/\n    853,\n/**/\n    852,\n/**/\n    851,\n/**/\n    850,\n/**/\n    849,\n/**/\n    848,\n/**/\n    847,\n/**/\n    846,\n/**/\n    845,\n/**/\n    844,\n/**/\n    843,\n/**/\n    842,\n/**/\n    841,\n/**/\n    840,\n/**/\n    839,\n/**/\n    838,\n/**/\n    837,\n/**/\n    836,\n/**/\n    835,\n/**/\n    834,\n/**/\n    833,\n/**/\n    832,\n/**/\n    831,\n/**/\n    830,\n/**/\n    829,\n/**/\n    828,\n/**/\n    827,\n/**/\n    826,\n/**/\n    825,\n/**/\n    824,\n/**/\n    823,\n/**/\n    822,\n/**/\n    821,\n/**/\n    820,\n/**/\n    819,\n/**/\n    818,\n/**/\n    817,\n/**/\n    816,\n/**/\n    815,\n/**/\n    814,\n/**/\n    813,\n/**/\n    812,\n/**/\n    811,\n/**/\n    810,\n/**/\n    809,\n/**/\n    808,\n/**/\n    807,\n/**/\n    806,\n/**/\n    805,\n/**/\n    804,\n/**/\n    803,\n/**/\n    802,\n/**/\n    801,\n/**/\n    800,\n/**/\n    799,\n/**/\n    798,\n/**/\n    797,\n/**/\n    796,\n/**/\n    795,\n/**/\n    794,\n/**/\n    793,\n/**/\n    792,\n/**/\n    791,\n/**/\n    790,\n/**/\n    789,\n/**/\n    788,\n/**/\n    787,\n/**/\n    786,\n/**/\n    785,\n/**/\n    784,\n/**/\n    783,\n/**/\n    782,\n/**/\n    781,\n/**/\n    780,\n/**/\n    779,\n/**/\n    778,\n/**/\n    777,\n/**/\n    776,\n/**/\n    775,\n/**/\n    774,\n/**/\n    773,\n/**/\n    772,\n/**/\n    771,\n/**/\n    770,\n/**/\n    769,\n/**/\n    768,\n/**/\n    767,\n/**/\n    766,\n/**/\n    765,\n/**/\n    764,\n/**/\n    763,\n/**/\n    762,\n/**/\n    761,\n/**/\n    760,\n/**/\n    759,\n/**/\n    758,\n/**/\n    757,\n/**/\n    756,\n/**/\n    755,\n/**/\n    754,\n/**/\n    753,\n/**/\n    752,\n/**/\n    751,\n/**/\n    750,\n/**/\n    749,\n/**/\n    748,\n/**/\n    747,\n/**/\n    746,\n/**/\n    745,\n/**/\n    744,\n/**/\n    743,\n/**/\n    742,\n/**/\n    741,\n/**/\n    740,\n/**/\n    739,\n/**/\n    738,\n/**/\n    737,\n/**/\n    736,\n/**/\n    735,\n/**/\n    734,\n/**/\n    733,\n/**/\n    732,\n/**/\n    731,\n/**/\n    730,\n/**/\n    729,\n/**/\n    728,\n/**/\n    727,\n/**/\n    726,\n/**/\n    725,\n/**/\n    724,\n/**/\n    723,\n/**/\n    722,\n/**/\n    721,\n/**/\n    720,\n/**/\n    719,\n/**/\n    718,\n/**/\n    717,\n/**/\n    716,\n/**/\n    715,\n/**/\n    714,\n/**/\n    713,\n/**/\n    712,\n/**/\n    711,\n/**/\n    710,\n/**/\n    709,\n/**/\n    708,\n/**/\n    707,\n/**/\n    706,\n/**/\n    705,\n/**/\n    704,\n/**/\n    703,\n/**/\n    702,\n/**/\n    701,\n/**/\n    700,\n/**/\n    699,\n/**/\n    698,\n/**/\n    697,\n/**/\n    696,\n/**/\n    695,\n/**/\n    694,\n/**/\n    693,\n/**/\n    692,\n/**/\n    691,\n/**/\n    690,\n/**/\n    689,\n/**/\n    688,\n/**/\n    687,\n/**/\n    686,\n/**/\n    685,\n/**/\n    684,\n/**/\n    683,\n/**/\n    682,\n/**/\n    681,\n/**/\n    680,\n/**/\n    679,\n/**/\n    678,\n/**/\n    677,\n/**/\n    676,\n/**/\n    675,\n/**/\n    674,\n/**/\n    673,\n/**/\n    672,\n/**/\n    671,\n/**/\n    670,\n/**/\n    669,\n/**/\n    668,\n/**/\n    667,\n/**/\n    666,\n/**/\n    665,\n/**/\n    664,\n/**/\n    663,\n/**/\n    662,\n/**/\n    661,\n/**/\n    660,\n/**/\n    659,\n/**/\n    658,\n/**/\n    657,\n/**/\n    656,\n/**/\n    655,\n/**/\n    654,\n/**/\n    653,\n/**/\n    652,\n/**/\n    651,\n/**/\n    650,\n/**/\n    649,\n/**/\n    648,\n/**/\n    647,\n/**/\n    646,\n/**/\n    645,\n/**/\n    644,\n/**/\n    643,\n/**/\n    642,\n/**/\n    641,\n/**/\n    640,\n/**/\n    639,\n/**/\n    638,\n/**/\n    637,\n/**/\n    636,\n/**/\n    635,\n/**/\n    634,\n/**/\n    633,\n/**/\n    632,\n/**/\n    631,\n/**/\n    630,\n/**/\n    629,\n/**/\n    628,\n/**/\n    627,\n/**/\n    626,\n/**/\n    625,\n/**/\n    624,\n/**/\n    623,\n/**/\n    622,\n/**/\n    621,\n/**/\n    620,\n/**/\n    619,\n/**/\n    618,\n/**/\n    617,\n/**/\n    616,\n/**/\n    615,\n/**/\n    614,\n/**/\n    613,\n/**/\n    612,\n/**/\n    611,\n/**/\n    610,\n/**/\n    609,\n/**/\n    608,\n/**/\n    607,\n/**/\n    606,\n/**/\n    605,\n/**/\n    604,\n/**/\n    603,\n/**/\n    602,\n/**/\n    601,\n/**/\n    600,\n/**/\n    599,\n/**/\n    598,\n/**/\n    597,\n/**/\n    596,\n/**/\n    595,\n/**/\n    594,\n/**/\n    593,\n/**/\n    592,\n/**/\n    591,\n/**/\n    590,\n/**/\n    589,\n/**/\n    588,\n/**/\n    587,\n/**/\n    586,\n/**/\n    585,\n/**/\n    584,\n/**/\n    583,\n/**/\n    582,\n/**/\n    581,\n/**/\n    580,\n/**/\n    579,\n/**/\n    578,\n/**/\n    577,\n/**/\n    576,\n/**/\n    575,\n/**/\n    574,\n/**/\n    573,\n/**/\n    572,\n/**/\n    571,\n/**/\n    570,\n/**/\n    569,\n/**/\n    568,\n/**/\n    567,\n/**/\n    566,\n/**/\n    565,\n/**/\n    564,\n/**/\n    563,\n/**/\n    562,\n/**/\n    561,\n/**/\n    560,\n/**/\n    559,\n/**/\n    558,\n/**/\n    557,\n/**/\n    556,\n/**/\n    555,\n/**/\n    554,\n/**/\n    553,\n/**/\n    552,\n/**/\n    551,\n/**/\n    550,\n/**/\n    549,\n/**/\n    548,\n/**/\n    547,\n/**/\n    546,\n/**/\n    545,\n/**/\n    544,\n/**/\n    543,\n/**/\n    542,\n/**/\n    541,\n/**/\n    540,\n/**/\n    539,\n/**/\n    538,\n/**/\n    537,\n/**/\n    536,\n/**/\n    535,\n/**/\n    534,\n/**/\n    533,\n/**/\n    532,\n/**/\n    531,\n/**/\n    530,\n/**/\n    529,\n/**/\n    528,\n/**/\n    527,\n/**/\n    526,\n/**/\n    525,\n/**/\n    524,\n/**/\n    523,\n/**/\n    522,\n/**/\n    521,\n/**/\n    520,\n/**/\n    519,\n/**/\n    518,\n/**/\n    517,\n/**/\n    516,\n/**/\n    515,\n/**/\n    514,\n/**/\n    513,\n/**/\n    512,\n/**/\n    511,\n/**/\n    510,\n/**/\n    509,\n/**/\n    508,\n/**/\n    507,\n/**/\n    506,\n/**/\n    505,\n/**/\n    504,\n/**/\n    503,\n/**/\n    502,\n/**/\n    501,\n/**/\n    500,\n/**/\n    499,\n/**/\n    498,\n/**/\n    497,\n/**/\n    496,\n/**/\n    495,\n/**/\n    494,\n/**/\n    493,\n/**/\n    492,\n/**/\n    491,\n/**/\n    490,\n/**/\n    489,\n/**/\n    488,\n/**/\n    487,\n/**/\n    486,\n/**/\n    485,\n/**/\n    484,\n/**/\n    483,\n/**/\n    482,\n/**/\n    481,\n/**/\n    480,\n/**/\n    479,\n/**/\n    478,\n/**/\n    477,\n/**/\n    476,\n/**/\n    475,\n/**/\n    474,\n/**/\n    473,\n/**/\n    472,\n/**/\n    471,\n/**/\n    470,\n/**/\n    469,\n/**/\n    468,\n/**/\n    467,\n/**/\n    466,\n/**/\n    465,\n/**/\n    464,\n/**/\n    463,\n/**/\n    462,\n/**/\n    461,\n/**/\n    460,\n/**/\n    459,\n/**/\n    458,\n/**/\n    457,\n/**/\n    456,\n/**/\n    455,\n/**/\n    454,\n/**/\n    453,\n/**/\n    452,\n/**/\n    451,\n/**/\n    450,\n/**/\n    449,\n/**/\n    448,\n/**/\n    447,\n/**/\n    446,\n/**/\n    445,\n/**/\n    444,\n/**/\n    443,\n/**/\n    442,\n/**/\n    441,\n/**/\n    440,\n/**/\n    439,\n/**/\n    438,\n/**/\n    437,\n/**/\n    436,\n/**/\n    435,\n/**/\n    434,\n/**/\n    433,\n/**/\n    432,\n/**/\n    431,\n/**/\n    430,\n/**/\n    429,\n/**/\n    428,\n/**/\n    427,\n/**/\n    426,\n/**/\n    425,\n/**/\n    424,\n/**/\n    423,\n/**/\n    422,\n/**/\n    421,\n/**/\n    420,\n/**/\n    419,\n/**/\n    418,\n/**/\n    417,\n/**/\n    416,\n/**/\n    415,\n/**/\n    414,\n/**/\n    413,\n/**/\n    412,\n/**/\n    411,\n/**/\n    410,\n/**/\n    409,\n/**/\n    408,\n/**/\n    407,\n/**/\n    406,\n/**/\n    405,\n/**/\n    404,\n/**/\n    403,\n/**/\n    402,\n/**/\n    401,\n/**/\n    400,\n/**/\n    399,\n/**/\n    398,\n/**/\n    397,\n/**/\n    396,\n/**/\n    395,\n/**/\n    394,\n/**/\n    393,\n/**/\n    392,\n/**/\n    391,\n/**/\n    390,\n/**/\n    389,\n/**/\n    388,\n/**/\n    387,\n/**/\n    386,\n/**/\n    385,\n/**/\n    384,\n/**/\n    383,\n/**/\n    382,\n/**/\n    381,\n/**/\n    380,\n/**/\n    379,\n/**/\n    378,\n/**/\n    377,\n/**/\n    376,\n/**/\n    375,\n/**/\n    374,\n/**/\n    373,\n/**/\n    372,\n/**/\n    371,\n/**/\n    370,\n/**/\n    369,\n/**/\n    368,\n/**/\n    367,\n/**/\n    366,\n/**/\n    365,\n/**/\n    364,\n/**/\n    363,\n/**/\n    362,\n/**/\n    361,\n/**/\n    360,\n/**/\n    359,\n/**/\n    358,\n/**/\n    357,\n/**/\n    356,\n/**/\n    355,\n/**/\n    354,\n/**/\n    353,\n/**/\n    352,\n/**/\n    351,\n/**/\n    350,\n/**/\n    349,\n/**/\n    348,\n/**/\n    347,\n/**/\n    346,\n/**/\n    345,\n/**/\n    344,\n/**/\n    343,\n/**/\n    342,\n/**/\n    341,\n/**/\n    340,\n/**/\n    339,\n/**/\n    338,\n/**/\n    337,\n/**/\n    336,\n/**/\n    335,\n/**/\n    334,\n/**/\n    333,\n/**/\n    332,\n/**/\n    331,\n/**/\n    330,\n/**/\n    329,\n/**/\n    328,\n/**/\n    327,\n/**/\n    326,\n/**/\n    325,\n/**/\n    324,\n/**/\n    323,\n/**/\n    322,\n/**/\n    321,\n/**/\n    320,\n/**/\n    319,\n/**/\n    318,\n/**/\n    317,\n/**/\n    316,\n/**/\n    315,\n/**/\n    314,\n/**/\n    313,\n/**/\n    312,\n/**/\n    311,\n/**/\n    310,\n/**/\n    309,\n/**/\n    308,\n/**/\n    307,\n/**/\n    306,\n/**/\n    305,\n/**/\n    304,\n/**/\n    303,\n/**/\n    302,\n/**/\n    301,\n/**/\n    300,\n/**/\n    299,\n/**/\n    298,\n/**/\n    297,\n/**/\n    296,\n/**/\n    295,\n/**/\n    294,\n/**/\n    293,\n/**/\n    292,\n/**/\n    291,\n/**/\n    290,\n/**/\n    289,\n/**/\n    288,\n/**/\n    287,\n/**/\n    286,\n/**/\n    285,\n/**/\n    284,\n/**/\n    283,\n/**/\n    282,\n/**/\n    281,\n/**/\n    280,\n/**/\n    279,\n/**/\n    278,\n/**/\n    277,\n/**/\n    276,\n/**/\n    275,\n/**/\n    274,\n/**/\n    273,\n/**/\n    272,\n/**/\n    271,\n/**/\n    270,\n/**/\n    269,\n/**/\n    268,\n/**/\n    267,\n/**/\n    266,\n/**/\n    265,\n/**/\n    264,\n/**/\n    263,\n/**/\n    262,\n/**/\n    261,\n/**/\n    260,\n/**/\n    259,\n/**/\n    258,\n/**/\n    257,\n/**/\n    256,\n/**/\n    255,\n/**/\n    254,\n/**/\n    253,\n/**/\n    252,\n/**/\n    251,\n/**/\n    250,\n/**/\n    249,\n/**/\n    248,\n/**/\n    247,\n/**/\n    246,\n/**/\n    245,\n/**/\n    244,\n/**/\n    243,\n/**/\n    242,\n/**/\n    241,\n/**/\n    240,\n/**/\n    239,\n/**/\n    238,\n/**/\n    237,\n/**/\n    236,\n/**/\n    235,\n/**/\n    234,\n/**/\n    233,\n/**/\n    232,\n/**/\n    231,\n/**/\n    230,\n/**/\n    229,\n/**/\n    228,\n/**/\n    227,\n/**/\n    226,\n/**/\n    225,\n/**/\n    224,\n/**/\n    223,\n/**/\n    222,\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    while (l < h)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + (item_count % ncol ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#ifdef FEAT_HUGE\n    msg_puts(_(\"\\nHuge version \"));\n#else\n# ifdef FEAT_BIG\n    msg_puts(_(\"\\nBig version \"));\n# else\n#  ifdef FEAT_NORMAL\n    msg_puts(_(\"\\nNormal version \"));\n#  else\n#   ifdef FEAT_SMALL\n    msg_puts(_(\"\\nSmall version \"));\n#   else\n    msg_puts(_(\"\\nTiny version \"));\n#   endif\n#  endif\n# endif\n#endif\n#ifndef FEAT_GUI\n    msg_puts(_(\"without GUI.\"));\n#else\n# ifdef FEAT_GUI_GTK\n#  ifdef USE_GTK3\n    msg_puts(_(\"with GTK3 GUI.\"));\n#  else\n#   ifdef FEAT_GUI_GNOME\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n#   else\n     msg_puts(_(\"with GTK2 GUI.\"));\n#   endif\n# endif\n# else\n#  ifdef FEAT_GUI_MOTIF\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#  else\n#   ifdef FEAT_GUI_ATHENA\n#    ifdef FEAT_GUI_NEXTAW\n    msg_puts(_(\"with X11-neXtaw GUI.\"));\n#    else\n    msg_puts(_(\"with X11-Athena GUI.\"));\n#    endif\n#   else\n#    ifdef FEAT_GUI_HAIKU\n    msg_puts(_(\"with Haiku GUI.\"));\n#    else\n#     ifdef FEAT_GUI_PHOTON\n    msg_puts(_(\"with Photon GUI.\"));\n#     else\n#      if defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#      endif\n#     endif\n#    endif\n#   endif\n#  endif\n# endif\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version8<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * vim9cmds.c: Dealing with compiled function expressions\n */\n\n#define USING_FLOAT_STUFF\n#include \"vim.h\"\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n\n// When not generating protos this is included in proto.h\n#ifdef PROTO\n# include \"vim9.h\"\n#endif\n\n/*\n * Generate code for any ppconst entries.\n */\n    int\ngenerate_ppconst(cctx_T *cctx, ppconst_T *ppconst)\n{\n    int\t    i;\n    int\t    ret = OK;\n    int\t    save_skip = cctx->ctx_skip;\n\n    cctx->ctx_skip = SKIP_NOT;\n    for (i = 0; i < ppconst->pp_used; ++i)\n\tif (generate_tv_PUSH(cctx, &ppconst->pp_tv[i]) == FAIL)\n\t    ret = FAIL;\n    ppconst->pp_used = 0;\n    cctx->ctx_skip = save_skip;\n    return ret;\n}\n\n/*\n * Check that the last item of \"ppconst\" is a bool, if there is an item.\n */\n    static int\ncheck_ppconst_bool(ppconst_T *ppconst)\n{\n    if (ppconst->pp_used > 0)\n    {\n\ttypval_T    *tv = &ppconst->pp_tv[ppconst->pp_used - 1];\n\twhere_T\t    where = WHERE_INIT;\n\n\treturn check_typval_type(&t_bool, tv, where);\n    }\n    return OK;\n}\n\n/*\n * Clear ppconst constants.  Used when failing.\n */\n    void\nclear_ppconst(ppconst_T *ppconst)\n{\n    int\t    i;\n\n    for (i = 0; i < ppconst->pp_used; ++i)\n\tclear_tv(&ppconst->pp_tv[i]);\n    ppconst->pp_used = 0;\n}\n\n/*\n * Compile getting a member from a list/dict/string/blob.  Stack has the\n * indexable value and the index or the two indexes of a slice.\n * \"keeping_dict\" is used for dict[func](arg) to pass dict to func.\n */\n    int\ncompile_member(int is_slice, int *keeping_dict, cctx_T *cctx)\n{\n    type2_T\t*typep;\n    garray_T\t*stack = &cctx->ctx_type_stack;\n    vartype_T\tvartype;\n    type_T\t*idxtype;\n\n    // We can index a list, dict and blob.  If we don't know the type\n    // we can use the index value type.  If we still don't know use an \"ANY\"\n    // instruction.\n    // TODO: what about the decl type?\n    typep = (((type2_T *)stack->ga_data) + stack->ga_len - (is_slice ? 3 : 2));\n    vartype = typep->type_curr->tt_type;\n    idxtype = (((type2_T *)stack->ga_data) + stack->ga_len - 1)->type_curr;\n    // If the index is a string, the variable must be a Dict.\n    if ((typep->type_curr == &t_any || typep->type_curr == &t_unknown)\n\t\t\t\t\t\t       && idxtype == &t_string)\n\tvartype = VAR_DICT;\n    if (vartype == VAR_STRING || vartype == VAR_LIST || vartype == VAR_BLOB)\n    {\n\tif (need_type(idxtype, &t_number, -1, 0, cctx, FALSE, FALSE) == FAIL)\n\t    return FAIL;\n\tif (is_slice)\n\t{\n\t    idxtype = get_type_on_stack(cctx, 1);\n\t    if (need_type(idxtype, &t_number, -2, 0, cctx,\n\t\t\t\t\t\t\t FALSE, FALSE) == FAIL)\n\t\treturn FAIL;\n\t}\n    }\n\n    if (vartype == VAR_DICT)\n    {\n\tif (is_slice)\n\t{\n\t    emsg(_(e_cannot_slice_dictionary));\n\t    return FAIL;\n\t}\n\tif (typep->type_curr->tt_type == VAR_DICT)\n\t{\n\t    typep->type_curr = typep->type_curr->tt_member;\n\t    if (typep->type_curr == &t_unknown)\n\t\t// empty dict was used\n\t\ttypep->type_curr = &t_any;\n\t    if (typep->type_decl->tt_type == VAR_DICT)\n\t    {\n\t\ttypep->type_decl = typep->type_decl->tt_member;\n\t\tif (typep->type_decl == &t_unknown)\n\t\t    // empty dict was used\n\t\t    typep->type_decl = &t_any;\n\t    }\n\t    else\n\t\ttypep->type_decl = typep->type_curr;\n\t}\n\telse\n\t{\n\t    if (need_type(typep->type_curr, &t_dict_any, -2, 0, cctx,\n\t\t\t\t\t\t\t FALSE, FALSE) == FAIL)\n\t\treturn FAIL;\n\t    typep->type_curr = &t_any;\n\t    typep->type_decl = &t_any;\n\t}\n\tif (may_generate_2STRING(-1, FALSE, cctx) == FAIL)\n\t    return FAIL;\n\tif (generate_instr_drop(cctx, ISN_MEMBER, 1) == FAIL)\n\t    return FAIL;\n\tif (keeping_dict != NULL)\n\t    *keeping_dict = TRUE;\n    }\n    else if (vartype == VAR_STRING)\n    {\n\ttypep->type_curr = &t_string;\n\ttypep->type_decl = &t_string;\n\tif ((is_slice\n\t\t? generate_instr_drop(cctx, ISN_STRSLICE, 2)\n\t\t: generate_instr_drop(cctx, ISN_STRINDEX, 1)) == FAIL)\n\t    return FAIL;\n    }\n    else if (vartype == VAR_BLOB)\n    {\n\tif (is_slice)\n\t{\n\t    typep->type_curr = &t_blob;\n\t    typep->type_decl = &t_blob;\n\t    if (generate_instr_drop(cctx, ISN_BLOBSLICE, 2) == FAIL)\n\t\treturn FAIL;\n\t}\n\telse\n\t{\n\t    typep->type_curr = &t_number;\n\t    typep->type_decl = &t_number;\n\t    if (generate_instr_drop(cctx, ISN_BLOBINDEX, 1) == FAIL)\n\t\treturn FAIL;\n\t}\n    }\n    else if (vartype == VAR_LIST || typep->type_curr == &t_any\n\t\t\t\t\t     || typep->type_curr == &t_unknown)\n    {\n\tif (is_slice)\n\t{\n\t    if (generate_instr_drop(cctx,\n\t\t     vartype == VAR_LIST ?  ISN_LISTSLICE : ISN_ANYSLICE,\n\t\t\t\t\t\t\t    2) == FAIL)\n\t\treturn FAIL;\n\t}\n\telse\n\t{\n\t    if (typep->type_curr->tt_type == VAR_LIST)\n\t    {\n\t\ttypep->type_curr = typep->type_curr->tt_member;\n\t\tif (typep->type_curr == &t_unknown)\n\t\t    // empty list was used\n\t\t    typep->type_curr = &t_any;\n\t\tif (typep->type_decl->tt_type == VAR_LIST)\n\t\t{\n\t\t    typep->type_decl = typep->type_decl->tt_member;\n\t\t    if (typep->type_decl == &t_unknown)\n\t\t\t// empty list was used\n\t\t\ttypep->type_decl = &t_any;\n\t\t}\n\t\telse\n\t\t\ttypep->type_decl = typep->type_curr;\n\t    }\n\t    if (generate_instr_drop(cctx,\n\t\t\tvartype == VAR_LIST ?  ISN_LISTINDEX : ISN_ANYINDEX, 1)\n\t\t\t\t\t\t\t\t       == FAIL)\n\t\treturn FAIL;\n\t}\n    }\n    else\n    {\n\tswitch (vartype)\n\t{\n\t    case VAR_FUNC:\n\t    case VAR_PARTIAL:\n\t\temsg(_(e_cannot_index_a_funcref));\n\t\tbreak;\n\t    case VAR_BOOL:\n\t    case VAR_SPECIAL:\n\t    case VAR_JOB:\n\t    case VAR_CHANNEL:\n\t    case VAR_INSTR:\n\t    case VAR_UNKNOWN:\n\t    case VAR_ANY:\n\t    case VAR_VOID:\n\t\temsg(_(e_cannot_index_special_variable));\n\t\tbreak;\n\t    default:\n\t\temsg(_(e_string_list_dict_or_blob_required));\n\t}\n\treturn FAIL;\n    }\n    return OK;\n}\n\n/*\n * Generate an instruction to load script-local variable \"name\", without the\n * leading \"s:\".\n * Also finds imported variables.\n */\n    int\ncompile_load_scriptvar(\n\tcctx_T *cctx,\n\tchar_u *name,\t    // variable NUL terminated\n\tchar_u *start,\t    // start of variable\n\tchar_u **end,\t    // end of variable, may be NULL\n\tint    error)\t    // when TRUE may give error\n{\n    scriptitem_T    *si;\n    int\t\t    idx;\n    imported_T\t    *import;\n\n    if (!SCRIPT_ID_VALID(current_sctx.sc_sid))\n\treturn FAIL;\n    si = SCRIPT_ITEM(current_sctx.sc_sid);\n    idx = get_script_item_idx(current_sctx.sc_sid, name, 0, cctx);\n    if (idx == -1 || si->sn_version != SCRIPT_VERSION_VIM9)\n    {\n\t// variable is not in sn_var_vals: old style script.\n\treturn generate_OLDSCRIPT(cctx, ISN_LOADS, name, current_sctx.sc_sid,\n\t\t\t\t\t\t\t\t       &t_any);\n    }\n    if (idx >= 0)\n    {\n\tsvar_T\t\t*sv = ((svar_T *)si->sn_var_vals.ga_data) + idx;\n\n\tgenerate_VIM9SCRIPT(cctx, ISN_LOADSCRIPT,\n\t\t\t\t\tcurrent_sctx.sc_sid, idx, sv->sv_type);\n\treturn OK;\n    }\n\n    import = end == NULL ? NULL : find_imported(name, 0, cctx);\n    if (import != NULL)\n    {\n\tchar_u\t*p = skipwhite(*end);\n\tchar_u\t*exp_name;\n\tint\tcc;\n\tufunc_T\t*ufunc;\n\ttype_T\t*type;\n\n\t// Need to lookup the member.\n\tif (*p != '.')\n\t{\n\t    semsg(_(e_expected_dot_after_name_str), start);\n\t    return FAIL;\n\t}\n\t++p;\n\tif (VIM_ISWHITE(*p))\n\t{\n\t    emsg(_(e_no_white_space_allowed_after_dot));\n\t    return FAIL;\n\t}\n\n\t// isolate one name\n\texp_name = p;\n\twhile (eval_isnamec(*p))\n\t    ++p;\n\tcc = *p;\n\t*p = NUL;\n\n\tidx = find_exported(import->imp_sid, exp_name, &ufunc, &type,\n\t\t\t\t\t\t\t\t   cctx, TRUE);\n\t*p = cc;\n\tp = skipwhite(p);\n\t*end = p;\n\n\tif (idx < 0)\n\t{\n\t    if (ufunc != NULL)\n\t    {\n\t\t// function call or function reference\n\t\tgenerate_PUSHFUNC(cctx, ufunc->uf_name, NULL);\n\t\treturn OK;\n\t    }\n\t    return FAIL;\n\t}\n\n\tgenerate_VIM9SCRIPT(cctx, ISN_LOADSCRIPT,\n\t\timport->imp_sid,\n\t\tidx,\n\t\ttype);\n\treturn OK;\n    }\n\n    if (error)\n\tsemsg(_(e_item_not_found_str), name);\n    return FAIL;\n}\n\n    static int\ngenerate_funcref(cctx_T *cctx, char_u *name)\n{\n    ufunc_T *ufunc = find_func(name, FALSE, cctx);\n\n    if (ufunc == NULL)\n\treturn FAIL;\n\n    // Need to compile any default values to get the argument types.\n    if (func_needs_compiling(ufunc, COMPILE_TYPE(ufunc))\n\t    && compile_def_function(ufunc, TRUE, COMPILE_TYPE(ufunc), NULL)\n\t\t\t\t\t\t\t\t       == FAIL)\n\treturn FAIL;\n    return generate_PUSHFUNC(cctx, ufunc->uf_name, ufunc->uf_func_type);\n}\n\n/*\n * Compile a variable name into a load instruction.\n * \"end\" points to just after the name.\n * \"is_expr\" is TRUE when evaluating an expression, might be a funcref.\n * When \"error\" is FALSE do not give an error when not found.\n */\n    int\ncompile_load(\n\tchar_u **arg,\n\tchar_u *end_arg,\n\tcctx_T\t*cctx,\n\tint\tis_expr,\n\tint\terror)\n{\n    type_T\t*type;\n    char_u\t*name = NULL;\n    char_u\t*end = end_arg;\n    int\t\tres = FAIL;\n    int\t\tprev_called_emsg = called_emsg;\n\n    if (*(*arg + 1) == ':')\n    {\n\tif (end <= *arg + 2)\n\t{\n\t    isntype_T  isn_type;\n\n\t    // load dictionary of namespace\n\t    switch (**arg)\n\t    {\n\t\tcase 'g': isn_type = ISN_LOADGDICT; break;\n\t\tcase 'w': isn_type = ISN_LOADWDICT; break;\n\t\tcase 't': isn_type = ISN_LOADTDICT; break;\n\t\tcase 'b': isn_type = ISN_LOADBDICT; break;\n\t\tdefault:\n\t\t    semsg(_(e_namespace_not_supported_str), *arg);\n\t\t    goto theend;\n\t    }\n\t    if (generate_instr_type(cctx, isn_type, &t_dict_any) == NULL)\n\t\tgoto theend;\n\t    res = OK;\n\t}\n\telse\n\t{\n\t    isntype_T  isn_type = ISN_DROP;\n\n\t    // load namespaced variable\n\t    name = vim_strnsave(*arg + 2, end - (*arg + 2));\n\t    if (name == NULL)\n\t\treturn FAIL;\n\n\t    switch (**arg)\n\t    {\n\t\tcase 'v': res = generate_LOADV(cctx, name, error);\n\t\t\t  break;\n\t\tcase 's': if (is_expr && ASCII_ISUPPER(*name)\n\t\t\t\t       && find_func(name, FALSE, cctx) != NULL)\n\t\t\t      res = generate_funcref(cctx, name);\n\t\t\t  else\n\t\t\t      res = compile_load_scriptvar(cctx, name,\n\t\t\t\t\t\t\t    NULL, &end, error);\n\t\t\t  break;\n\t\tcase 'g': if (vim_strchr(name, AUTOLOAD_CHAR) == NULL)\n\t\t\t  {\n\t\t\t      if (is_expr && ASCII_ISUPPER(*name)\n\t\t\t\t       && find_func(name, FALSE, cctx) != NULL)\n\t\t\t\t  res = generate_funcref(cctx, name);\n\t\t\t      else\n\t\t\t\t  isn_type = ISN_LOADG;\n\t\t\t  }\n\t\t\t  else\n\t\t\t  {\n\t\t\t      isn_type = ISN_LOADAUTO;\n\t\t\t      vim_free(name);\n\t\t\t      name = vim_strnsave(*arg, end - *arg);\n\t\t\t      if (name == NULL)\n\t\t\t\t  return FAIL;\n\t\t\t  }\n\t\t\t  break;\n\t\tcase 'w': isn_type = ISN_LOADW; break;\n\t\tcase 't': isn_type = ISN_LOADT; break;\n\t\tcase 'b': isn_type = ISN_LOADB; break;\n\t\tdefault:  // cannot happen, just in case\n\t\t\t  semsg(_(e_namespace_not_supported_str), *arg);\n\t\t\t  goto theend;\n\t    }\n\t    if (isn_type != ISN_DROP)\n\t    {\n\t\t// Global, Buffer-local, Window-local and Tabpage-local\n\t\t// variables can be defined later, thus we don't check if it\n\t\t// exists, give an error at runtime.\n\t\tres = generate_LOAD(cctx, isn_type, 0, name, &t_any);\n\t    }\n\t}\n    }\n    else\n    {\n\tsize_t\t    len = end - *arg;\n\tint\t    idx;\n\tint\t    gen_load = FALSE;\n\tint\t    gen_load_outer = 0;\n\n\tname = vim_strnsave(*arg, end - *arg);\n\tif (name == NULL)\n\t    return FAIL;\n\n\tif (vim_strchr(name, AUTOLOAD_CHAR) != NULL)\n\t{\n\t    script_autoload(name, FALSE);\n\t    res = generate_LOAD(cctx, ISN_LOADAUTO, 0, name, &t_any);\n\t}\n\telse if (arg_exists(*arg, len, &idx, &type, &gen_load_outer, cctx)\n\t\t\t\t\t\t\t\t\t == OK)\n\t{\n\t    if (gen_load_outer == 0)\n\t\tgen_load = TRUE;\n\t}\n\telse\n\t{\n\t    lvar_T lvar;\n\n\t    if (lookup_local(*arg, len, &lvar, cctx) == OK)\n\t    {\n\t\ttype = lvar.lv_type;\n\t\tidx = lvar.lv_idx;\n\t\tif (lvar.lv_from_outer != 0)\n\t\t    gen_load_outer = lvar.lv_from_outer;\n\t\telse\n\t\t    gen_load = TRUE;\n\t    }\n\t    else\n\t    {\n\t\t// \"var\" can be script-local even without using \"s:\" if it\n\t\t// already exists in a Vim9 script or when it's imported.\n\t\tif (script_var_exists(*arg, len, cctx) == OK\n\t\t\t|| find_imported(name, 0, cctx) != NULL)\n\t\t   res = compile_load_scriptvar(cctx, name, *arg, &end, FALSE);\n\n\t\t// When evaluating an expression and the name starts with an\n\t\t// uppercase letter it can be a user defined function.\n\t\t// generate_funcref() will fail if the function can't be found.\n\t\tif (res == FAIL && is_expr && ASCII_ISUPPER(*name))\n\t\t    res = generate_funcref(cctx, name);\n\t    }\n\t}\n\tif (gen_load)\n\t    res = generate_LOAD(cctx, ISN_LOAD, idx, NULL, type);\n\tif (gen_load_outer > 0)\n\t{\n\t    res = generate_LOADOUTER(cctx, idx, gen_load_outer, type);\n\t    cctx->ctx_outer_used = TRUE;\n\t}\n    }\n\n    *arg = end;\n\ntheend:\n    if (res == FAIL && error && called_emsg == prev_called_emsg)\n\tsemsg(_(e_variable_not_found_str), name);\n    vim_free(name);\n    return res;\n}\n\n/*\n * Compile a string in a ISN_PUSHS instruction into an ISN_INSTR.\n * Returns FAIL if compilation fails.\n */\n    static int\ncompile_string(isn_T *isn, cctx_T *cctx)\n{\n    char_u\t*s = isn->isn_arg.string;\n    garray_T\tsave_ga = cctx->ctx_instr;\n    int\t\texpr_res;\n    int\t\ttrailing_error;\n    int\t\tinstr_count;\n    isn_T\t*instr = NULL;\n\n    // Remove the string type from the stack.\n    --cctx->ctx_type_stack.ga_len;\n\n    // Temporarily reset the list of instructions so that the jump labels are\n    // correct.\n    cctx->ctx_instr.ga_len = 0;\n    cctx->ctx_instr.ga_maxlen = 0;\n    cctx->ctx_instr.ga_data = NULL;\n    expr_res = compile_expr0(&s, cctx);\n    s = skipwhite(s);\n    trailing_error = *s != NUL;\n\n    if (expr_res == FAIL || trailing_error\n\t\t\t\t       || GA_GROW_FAILS(&cctx->ctx_instr, 1))\n    {\n\tif (trailing_error)\n\t    semsg(_(e_trailing_characters_str), s);\n\tclear_instr_ga(&cctx->ctx_instr);\n\tcctx->ctx_instr = save_ga;\n\t++cctx->ctx_type_stack.ga_len;\n\treturn FAIL;\n    }\n\n    // Move the generated instructions into the ISN_INSTR instruction, then\n    // restore the list of instructions.\n    instr_count = cctx->ctx_instr.ga_len;\n    instr = cctx->ctx_instr.ga_data;\n    instr[instr_count].isn_type = ISN_FINISH;\n\n    cctx->ctx_instr = save_ga;\n    vim_free(isn->isn_arg.string);\n    isn->isn_type = ISN_INSTR;\n    isn->isn_arg.instr = instr;\n    return OK;\n}\n\n/*\n * Compile the argument expressions.\n * \"arg\" points to just after the \"(\" and is advanced to after the \")\"\n */\n    static int\ncompile_arguments(char_u **arg, cctx_T *cctx, int *argcount, int is_searchpair)\n{\n    char_u  *p = *arg;\n    char_u  *whitep = *arg;\n    int\t    must_end = FALSE;\n    int\t    instr_count;\n\n    for (;;)\n    {\n\tif (may_get_next_line(whitep, &p, cctx) == FAIL)\n\t    goto failret;\n\tif (*p == ')')\n\t{\n\t    *arg = p + 1;\n\t    return OK;\n\t}\n\tif (must_end)\n\t{\n\t    semsg(_(e_missing_comma_before_argument_str), p);\n\t    return FAIL;\n\t}\n\n\tinstr_count = cctx->ctx_instr.ga_len;\n\tif (compile_expr0(&p, cctx) == FAIL)\n\t    return FAIL;\n\t++*argcount;\n\n\tif (is_searchpair && *argcount == 5\n\t\t&& cctx->ctx_instr.ga_len == instr_count + 1)\n\t{\n\t    isn_T *isn = ((isn_T *)cctx->ctx_instr.ga_data) + instr_count;\n\n\t    // {skip} argument of searchpair() can be compiled if not empty\n\t    if (isn->isn_type == ISN_PUSHS && *isn->isn_arg.string != NUL)\n\t\tcompile_string(isn, cctx);\n\t}\n\n\tif (*p != ',' && *skipwhite(p) == ',')\n\t{\n\t    semsg(_(e_no_white_space_allowed_before_str_str), \",\", p);\n\t    p = skipwhite(p);\n\t}\n\tif (*p == ',')\n\t{\n\t    ++p;\n\t    if (*p != NUL && !VIM_ISWHITE(*p))\n\t\tsemsg(_(e_white_space_required_after_str_str), \",\", p - 1);\n\t}\n\telse\n\t    must_end = TRUE;\n\twhitep = p;\n\tp = skipwhite(p);\n    }\nfailret:\n    emsg(_(e_missing_closing_paren));\n    return FAIL;\n}\n\n/*\n * Compile a function call:  name(arg1, arg2)\n * \"arg\" points to \"name\", \"arg + varlen\" to the \"(\".\n * \"argcount_init\" is 1 for \"value->method()\"\n * Instructions:\n *\tEVAL arg1\n *\tEVAL arg2\n *\tBCALL / DCALL / UCALL\n */\n    static int\ncompile_call(\n\tchar_u\t    **arg,\n\tsize_t\t    varlen,\n\tcctx_T\t    *cctx,\n\tppconst_T   *ppconst,\n\tint\t    argcount_init)\n{\n    char_u\t*name = *arg;\n    char_u\t*p;\n    int\t\targcount = argcount_init;\n    char_u\tnamebuf[100];\n    char_u\tfname_buf[FLEN_FIXED + 1];\n    char_u\t*tofree = NULL;\n    int\t\terror = FCERR_NONE;\n    ufunc_T\t*ufunc = NULL;\n    int\t\tres = FAIL;\n    int\t\tis_autoload;\n    int\t\tis_searchpair;\n\n    // We can evaluate \"has('name')\" at compile time.\n    // We always evaluate \"exists_compiled()\" at compile time.\n    if ((varlen == 3 && STRNCMP(*arg, \"has\", 3) == 0)\n\t    || (varlen == 15 && STRNCMP(*arg, \"exists_compiled\", 6) == 0))\n    {\n\tchar_u\t    *s = skipwhite(*arg + varlen + 1);\n\ttypval_T    argvars[2];\n\tint\t    is_has = **arg == 'h';\n\n\targvars[0].v_type = VAR_UNKNOWN;\n\tif (*s == '\"')\n\t    (void)eval_string(&s, &argvars[0], TRUE);\n\telse if (*s == '\\'')\n\t    (void)eval_lit_string(&s, &argvars[0], TRUE);\n\ts = skipwhite(s);\n\tif (*s == ')' && argvars[0].v_type == VAR_STRING\n\t       && ((is_has && !dynamic_feature(argvars[0].vval.v_string))\n\t\t    || !is_has))\n\t{\n\t    typval_T\t*tv = &ppconst->pp_tv[ppconst->pp_used];\n\n\t    *arg = s + 1;\n\t    argvars[1].v_type = VAR_UNKNOWN;\n\t    tv->v_type = VAR_NUMBER;\n\t    tv->vval.v_number = 0;\n\t    if (is_has)\n\t\tf_has(argvars, tv);\n\t    else\n\t\tf_exists(argvars, tv);\n\t    clear_tv(&argvars[0]);\n\t    ++ppconst->pp_used;\n\t    return OK;\n\t}\n\tclear_tv(&argvars[0]);\n\tif (!is_has)\n\t{\n\t    emsg(_(e_argument_of_exists_compiled_must_be_literal_string));\n\t    return FAIL;\n\t}\n    }\n\n    if (generate_ppconst(cctx, ppconst) == FAIL)\n\treturn FAIL;\n\n    if (varlen >= sizeof(namebuf))\n    {\n\tsemsg(_(e_name_too_long_str), name);\n\treturn FAIL;\n    }\n    vim_strncpy(namebuf, *arg, varlen);\n    name = fname_trans_sid(namebuf, fname_buf, &tofree, &error);\n\n    // We handle the \"skip\" argument of searchpair() and searchpairpos()\n    // differently.\n    is_searchpair = (varlen == 6 && STRNCMP(*arg, \"search\", 6) == 0)\n\t         || (varlen == 9 && STRNCMP(*arg, \"searchpos\", 9) == 0)\n\t        || (varlen == 10 && STRNCMP(*arg, \"searchpair\", 10) == 0)\n\t        || (varlen == 13 && STRNCMP(*arg, \"searchpairpos\", 13) == 0);\n\n    *arg = skipwhite(*arg + varlen + 1);\n    if (compile_arguments(arg, cctx, &argcount, is_searchpair) == FAIL)\n\tgoto theend;\n\n    is_autoload = vim_strchr(name, AUTOLOAD_CHAR) != NULL;\n    if (ASCII_ISLOWER(*name) && name[1] != ':' && !is_autoload)\n    {\n\tint\t    idx;\n\n\t// builtin function\n\tidx = find_internal_func(name);\n\tif (idx >= 0)\n\t{\n\t    if (STRCMP(name, \"flatten\") == 0)\n\t    {\n\t\temsg(_(e_cannot_use_flatten_in_vim9_script));\n\t\tgoto theend;\n\t    }\n\n\t    if (STRCMP(name, \"add\") == 0 && argcount == 2)\n\t    {\n\t\ttype_T\t    *type = get_type_on_stack(cctx, 1);\n\n\t\t// add() can be compiled to instructions if we know the type\n\t\tif (type->tt_type == VAR_LIST)\n\t\t{\n\t\t    // inline \"add(list, item)\" so that the type can be checked\n\t\t    res = generate_LISTAPPEND(cctx);\n\t\t    idx = -1;\n\t\t}\n\t\telse if (type->tt_type == VAR_BLOB)\n\t\t{\n\t\t    // inline \"add(blob, nr)\" so that the type can be checked\n\t\t    res = generate_BLOBAPPEND(cctx);\n\t\t    idx = -1;\n\t\t}\n\t    }\n\n\t    if (idx >= 0)\n\t\tres = generate_BCALL(cctx, idx, argcount, argcount_init == 1);\n\t}\n\telse\n\t    semsg(_(e_unknown_function_str), namebuf);\n\tgoto theend;\n    }\n\n    // An argument or local variable can be a function reference, this\n    // overrules a function name.\n    if (lookup_local(namebuf, varlen, NULL, cctx) == FAIL\n\t    && arg_exists(namebuf, varlen, NULL, NULL, NULL, cctx) != OK)\n    {\n\t// If we can find the function by name generate the right call.\n\t// Skip global functions here, a local funcref takes precedence.\n\tufunc = find_func(name, FALSE, cctx);\n\tif (ufunc != NULL && !func_is_global(ufunc))\n\t{\n\t    res = generate_CALL(cctx, ufunc, argcount);\n\t    goto theend;\n\t}\n    }\n\n    // If the name is a variable, load it and use PCALL.\n    // Not for g:Func(), we don't know if it is a variable or not.\n    // Not for eome#Func(), it will be loaded later.\n    p = namebuf;\n    if (STRNCMP(namebuf, \"g:\", 2) != 0 && !is_autoload\n\t    && compile_load(&p, namebuf + varlen, cctx, FALSE, FALSE) == OK)\n    {\n\ttype_T\t    *type = get_type_on_stack(cctx, 0);\n\n\tres = generate_PCALL(cctx, argcount, namebuf, type, FALSE);\n\tgoto theend;\n    }\n\n    // If we can find a global function by name generate the right call.\n    if (ufunc != NULL)\n    {\n\tres = generate_CALL(cctx, ufunc, argcount);\n\tgoto theend;\n    }\n\n    // A global function may be defined only later.  Need to figure out at\n    // runtime.  Also handles a FuncRef at runtime.\n    if (STRNCMP(namebuf, \"g:\", 2) == 0 || is_autoload)\n\tres = generate_UCALL(cctx, name, argcount);\n    else\n\tsemsg(_(e_unknown_function_str), namebuf);\n\ntheend:\n    vim_free(tofree);\n    return res;\n}\n\n// like NAMESPACE_CHAR but with 'a' and 'l'.\n#define VIM9_NAMESPACE_CHAR\t(char_u *)\"bgstvw\"\n\n/*\n * Find the end of a variable or function name.  Unlike find_name_end() this\n * does not recognize magic braces.\n * When \"use_namespace\" is TRUE recognize \"b:\", \"s:\", etc.\n * Return a pointer to just after the name.  Equal to \"arg\" if there is no\n * valid name.\n */\n    char_u *\nto_name_end(char_u *arg, int use_namespace)\n{\n    char_u\t*p;\n\n    // Quick check for valid starting character.\n    if (!eval_isnamec1(*arg))\n\treturn arg;\n\n    for (p = arg + 1; *p != NUL && eval_isnamec(*p); MB_PTR_ADV(p))\n\t// Include a namespace such as \"s:var\" and \"v:var\".  But \"n:\" is not\n\t// and can be used in slice \"[n:]\".\n\tif (*p == ':' && (p != arg + 1\n\t\t\t     || !use_namespace\n\t\t\t     || vim_strchr(VIM9_NAMESPACE_CHAR, *arg) == NULL))\n\t    break;\n    return p;\n}\n\n/*\n * Like to_name_end() but also skip over a list or dict constant.\n * Also accept \"<SNR>123_Func\".\n * This intentionally does not handle line continuation.\n */\n    char_u *\nto_name_const_end(char_u *arg)\n{\n    char_u\t*p = arg;\n    typval_T\trettv;\n\n    if (STRNCMP(p, \"<SNR>\", 5) == 0)\n\tp = skipdigits(p + 5);\n    p = to_name_end(p, TRUE);\n    if (p == arg && *arg == '[')\n    {\n\n\t// Can be \"[1, 2, 3]->Func()\".\n\tif (eval_list(&p, &rettv, NULL, FALSE) == FAIL)\n\t    p = arg;\n    }\n    return p;\n}\n\n/*\n * parse a list: [expr, expr]\n * \"*arg\" points to the '['.\n * ppconst->pp_is_const is set if all items are a constant.\n */\n    static int\ncompile_list(char_u **arg, cctx_T *cctx, ppconst_T *ppconst)\n{\n    char_u\t*p = skipwhite(*arg + 1);\n    char_u\t*whitep = *arg + 1;\n    int\t\tcount = 0;\n    int\t\tis_const;\n    int\t\tis_all_const = TRUE;\t// reset when non-const encountered\n\n    for (;;)\n    {\n\tif (may_get_next_line(whitep, &p, cctx) == FAIL)\n\t{\n\t    semsg(_(e_missing_end_of_list_rsb_str), *arg);\n\t    return FAIL;\n\t}\n\tif (*p == ',')\n\t{\n\t    semsg(_(e_no_white_space_allowed_before_str_str), \",\", p);\n\t    return FAIL;\n\t}\n\tif (*p == ']')\n\t{\n\t    ++p;\n\t    break;\n\t}\n\tif (compile_expr0_ext(&p, cctx, &is_const) == FAIL)\n\t    return FAIL;\n\tif (!is_const)\n\t    is_all_const = FALSE;\n\t++count;\n\tif (*p == ',')\n\t{\n\t    ++p;\n\t    if (*p != ']' && !IS_WHITE_OR_NUL(*p))\n\t    {\n\t\tsemsg(_(e_white_space_required_after_str_str), \",\", p - 1);\n\t\treturn FAIL;\n\t    }\n\t}\n\twhitep = p;\n\tp = skipwhite(p);\n    }\n    *arg = p;\n\n    ppconst->pp_is_const = is_all_const;\n    return generate_NEWLIST(cctx, count);\n}\n\n/*\n * Parse a lambda: \"(arg, arg) => expr\"\n * \"*arg\" points to the '('.\n * Returns OK/FAIL when a lambda is recognized, NOTDONE if it's not a lambda.\n */\n    static int\ncompile_lambda(char_u **arg, cctx_T *cctx)\n{\n    int\t\tr;\n    typval_T\trettv;\n    ufunc_T\t*ufunc;\n    evalarg_T\tevalarg;\n\n    init_evalarg(&evalarg);\n    evalarg.eval_flags = EVAL_EVALUATE;\n    evalarg.eval_cctx = cctx;\n\n    // Get the funcref in \"rettv\".\n    r = get_lambda_tv(arg, &rettv, TRUE, &evalarg);\n    if (r != OK)\n    {\n\tclear_evalarg(&evalarg, NULL);\n\treturn r;\n    }\n\n    // \"rettv\" will now be a partial referencing the function.\n    ufunc = rettv.vval.v_partial->pt_func;\n    ++ufunc->uf_refcount;\n    clear_tv(&rettv);\n\n    // Compile it here to get the return type.  The return type is optional,\n    // when it's missing use t_unknown.  This is recognized in\n    // compile_return().\n    if (ufunc->uf_ret_type->tt_type == VAR_VOID)\n\tufunc->uf_ret_type = &t_unknown;\n    compile_def_function(ufunc, FALSE, cctx->ctx_compile_type, cctx);\n\n    // When the outer function is compiled for profiling or debugging, the\n    // lambda may be called without profiling or debugging.  Compile it here in\n    // the right context.\n    if (cctx->ctx_compile_type == CT_DEBUG\n#ifdef FEAT_PROFILE\n\t    || cctx->ctx_compile_type == CT_PROFILE\n#endif\n       )\n\tcompile_def_function(ufunc, FALSE, CT_NONE, cctx);\n\n    // The last entry in evalarg.eval_tofree_ga is a copy of the last line and\n    // \"*arg\" may point into it.  Point into the original line to avoid a\n    // dangling pointer.\n    if (evalarg.eval_using_cmdline)\n    {\n\tgarray_T    *gap = &evalarg.eval_tofree_ga;\n\tsize_t\t    off = *arg - ((char_u **)gap->ga_data)[gap->ga_len - 1];\n\n\t*arg = ((char_u **)cctx->ctx_ufunc->uf_lines.ga_data)[cctx->ctx_lnum]\n\t\t\t\t\t\t\t\t\t + off;\n    }\n\n    clear_evalarg(&evalarg, NULL);\n\n    if (ufunc->uf_def_status == UF_COMPILED)\n    {\n\t// The return type will now be known.\n\tset_function_type(ufunc);\n\n\t// The function reference count will be 1.  When the ISN_FUNCREF\n\t// instruction is deleted the reference count is decremented and the\n\t// function is freed.\n\treturn generate_FUNCREF(cctx, ufunc);\n    }\n\n    func_ptr_unref(ufunc);\n    return FAIL;\n}\n\n/*\n * Get a lambda and compile it.  Uses Vim9 syntax.\n */\n    int\nget_lambda_tv_and_compile(\n\tchar_u\t    **arg,\n\ttypval_T    *rettv,\n\tint\t    types_optional,\n\tevalarg_T   *evalarg)\n{\n    int\t\tr;\n    ufunc_T\t*ufunc;\n    int\t\tsave_sc_version = current_sctx.sc_version;\n\n    // Get the funcref in \"rettv\".\n    current_sctx.sc_version = SCRIPT_VERSION_VIM9;\n    r = get_lambda_tv(arg, rettv, types_optional, evalarg);\n    current_sctx.sc_version = save_sc_version;\n    if (r != OK)\n\treturn r;\n\n    // \"rettv\" will now be a partial referencing the function.\n    ufunc = rettv->vval.v_partial->pt_func;\n\n    // Compile it here to get the return type.  The return type is optional,\n    // when it's missing use t_unknown.  This is recognized in\n    // compile_return().\n    if (ufunc->uf_ret_type == NULL || ufunc->uf_ret_type->tt_type == VAR_VOID)\n\tufunc->uf_ret_type = &t_unknown;\n    compile_def_function(ufunc, FALSE, CT_NONE, NULL);\n\n    if (ufunc->uf_def_status == UF_COMPILED)\n    {\n\t// The return type will now be known.\n\tset_function_type(ufunc);\n\treturn OK;\n    }\n    clear_tv(rettv);\n    return FAIL;\n}\n\n/*\n * parse a dict: {key: val, [key]: val}\n * \"*arg\" points to the '{'.\n * ppconst->pp_is_const is set if all item values are a constant.\n */\n    static int\ncompile_dict(char_u **arg, cctx_T *cctx, ppconst_T *ppconst)\n{\n    garray_T\t*instr = &cctx->ctx_instr;\n    int\t\tcount = 0;\n    dict_T\t*d = dict_alloc();\n    dictitem_T\t*item;\n    char_u\t*whitep = *arg + 1;\n    char_u\t*p;\n    int\t\tis_const;\n    int\t\tis_all_const = TRUE;\t// reset when non-const encountered\n\n    if (d == NULL)\n\treturn FAIL;\n    if (generate_ppconst(cctx, ppconst) == FAIL)\n\treturn FAIL;\n    for (;;)\n    {\n\tchar_u\t    *key = NULL;\n\n\tif (may_get_next_line(whitep, arg, cctx) == FAIL)\n\t{\n\t    *arg = NULL;\n\t    goto failret;\n\t}\n\n\tif (**arg == '}')\n\t    break;\n\n\tif (**arg == '[')\n\t{\n\t    isn_T\t*isn;\n\n\t    // {[expr]: value} uses an evaluated key.\n\t    *arg = skipwhite(*arg + 1);\n\t    if (compile_expr0(arg, cctx) == FAIL)\n\t\treturn FAIL;\n\t    isn = ((isn_T *)instr->ga_data) + instr->ga_len - 1;\n\t    if (isn->isn_type == ISN_PUSHNR)\n\t    {\n\t\tchar buf[NUMBUFLEN];\n\n\t\t// Convert to string at compile time.\n\t\tvim_snprintf(buf, NUMBUFLEN, \"%lld\", isn->isn_arg.number);\n\t\tisn->isn_type = ISN_PUSHS;\n\t\tisn->isn_arg.string = vim_strsave((char_u *)buf);\n\t    }\n\t    if (isn->isn_type == ISN_PUSHS)\n\t\tkey = isn->isn_arg.string;\n\t    else if (may_generate_2STRING(-1, FALSE, cctx) == FAIL)\n\t\treturn FAIL;\n\t    *arg = skipwhite(*arg);\n\t    if (**arg != ']')\n\t    {\n\t\temsg(_(e_missing_matching_bracket_after_dict_key));\n\t\treturn FAIL;\n\t    }\n\t    ++*arg;\n\t}\n\telse\n\t{\n\t    // {\"name\": value},\n\t    // {'name': value},\n\t    // {name: value} use \"name\" as a literal key\n\t    key = get_literal_key(arg);\n\t    if (key == NULL)\n\t\treturn FAIL;\n\t    if (generate_PUSHS(cctx, &key) == FAIL)\n\t\treturn FAIL;\n\t}\n\n\t// Check for duplicate keys, if using string keys.\n\tif (key != NULL)\n\t{\n\t    item = dict_find(d, key, -1);\n\t    if (item != NULL)\n\t    {\n\t\tsemsg(_(e_duplicate_key_in_dicitonary), key);\n\t\tgoto failret;\n\t    }\n\t    item = dictitem_alloc(key);\n\t    if (item != NULL)\n\t    {\n\t\titem->di_tv.v_type = VAR_UNKNOWN;\n\t\titem->di_tv.v_lock = 0;\n\t\tif (dict_add(d, item) == FAIL)\n\t\t    dictitem_free(item);\n\t    }\n\t}\n\n\tif (**arg != ':')\n\t{\n\t    if (*skipwhite(*arg) == ':')\n\t\tsemsg(_(e_no_white_space_allowed_before_str_str), \":\", *arg);\n\t    else\n\t\tsemsg(_(e_missing_colon_in_dictionary), *arg);\n\t    return FAIL;\n\t}\n\twhitep = *arg + 1;\n\tif (!IS_WHITE_OR_NUL(*whitep))\n\t{\n\t    semsg(_(e_white_space_required_after_str_str), \":\", *arg);\n\t    return FAIL;\n\t}\n\n\tif (may_get_next_line(whitep, arg, cctx) == FAIL)\n\t{\n\t    *arg = NULL;\n\t    goto failret;\n\t}\n\n\tif (compile_expr0_ext(arg, cctx, &is_const) == FAIL)\n\t    return FAIL;\n\tif (!is_const)\n\t    is_all_const = FALSE;\n\t++count;\n\n\twhitep = *arg;\n\tif (may_get_next_line(whitep, arg, cctx) == FAIL)\n\t{\n\t    *arg = NULL;\n\t    goto failret;\n\t}\n\tif (**arg == '}')\n\t    break;\n\tif (**arg != ',')\n\t{\n\t    semsg(_(e_missing_comma_in_dictionary), *arg);\n\t    goto failret;\n\t}\n\tif (IS_WHITE_OR_NUL(*whitep))\n\t{\n\t    semsg(_(e_no_white_space_allowed_before_str_str), \",\", whitep);\n\t    return FAIL;\n\t}\n\twhitep = *arg + 1;\n\tif (!IS_WHITE_OR_NUL(*whitep))\n\t{\n\t    semsg(_(e_white_space_required_after_str_str), \",\", *arg);\n\t    return FAIL;\n\t}\n\t*arg = skipwhite(whitep);\n    }\n\n    *arg = *arg + 1;\n\n    // Allow for following comment, after at least one space.\n    p = skipwhite(*arg);\n    if (VIM_ISWHITE(**arg) && vim9_comment_start(p))\n\t*arg += STRLEN(*arg);\n\n    dict_unref(d);\n    ppconst->pp_is_const = is_all_const;\n    return generate_NEWDICT(cctx, count);\n\nfailret:\n    if (*arg == NULL)\n    {\n\tsemsg(_(e_missing_dict_end), _(\"[end of lines]\"));\n\t*arg = (char_u *)\"\";\n    }\n    dict_unref(d);\n    return FAIL;\n}\n\n/*\n * Compile \"&option\".\n */\n    static int\ncompile_get_option(char_u **arg, cctx_T *cctx)\n{\n    typval_T\trettv;\n    char_u\t*start = *arg;\n    int\t\tret;\n\n    // parse the option and get the current value to get the type.\n    rettv.v_type = VAR_UNKNOWN;\n    ret = eval_option(arg, &rettv, TRUE);\n    if (ret == OK)\n    {\n\t// include the '&' in the name, eval_option() expects it.\n\tchar_u\t*name = vim_strnsave(start, *arg - start);\n\ttype_T\t*type = rettv.v_type == VAR_BOOL ? &t_bool\n\t\t\t  : rettv.v_type == VAR_NUMBER ? &t_number : &t_string;\n\n\tret = generate_LOAD(cctx, ISN_LOADOPT, 0, name, type);\n\tvim_free(name);\n    }\n    clear_tv(&rettv);\n\n    return ret;\n}\n\n/*\n * Compile \"$VAR\".\n */\n    static int\ncompile_get_env(char_u **arg, cctx_T *cctx)\n{\n    char_u\t*start = *arg;\n    int\t\tlen;\n    int\t\tret;\n    char_u\t*name;\n\n    ++*arg;\n    len = get_env_len(arg);\n    if (len == 0)\n    {\n\tsemsg(_(e_syntax_error_at_str), start);\n\treturn FAIL;\n    }\n\n    // include the '$' in the name, eval_env_var() expects it.\n    name = vim_strnsave(start, len + 1);\n    ret = generate_LOAD(cctx, ISN_LOADENV, 0, name, &t_string);\n    vim_free(name);\n    return ret;\n}\n\n/*\n * Compile \"@r\".\n */\n    static int\ncompile_get_register(char_u **arg, cctx_T *cctx)\n{\n    int\t\tret;\n\n    ++*arg;\n    if (**arg == NUL)\n    {\n\tsemsg(_(e_syntax_error_at_str), *arg - 1);\n\treturn FAIL;\n    }\n    if (!valid_yank_reg(**arg, FALSE))\n    {\n\temsg_invreg(**arg);\n\treturn FAIL;\n    }\n    ret = generate_LOAD(cctx, ISN_LOADREG, **arg, NULL, &t_string);\n    ++*arg;\n    return ret;\n}\n\n/*\n * Apply leading '!', '-' and '+' to constant \"rettv\".\n * When \"numeric_only\" is TRUE do not apply '!'.\n */\n    static int\napply_leader(typval_T *rettv, int numeric_only, char_u *start, char_u **end)\n{\n    char_u *p = *end;\n\n    // this works from end to start\n    while (p > start)\n    {\n\t--p;\n\tif (*p == '-' || *p == '+')\n\t{\n\t    // only '-' has an effect, for '+' we only check the type\n#ifdef FEAT_FLOAT\n\t    if (rettv->v_type == VAR_FLOAT)\n\t    {\n\t\tif (*p == '-')\n\t\t    rettv->vval.v_float = -rettv->vval.v_float;\n\t    }\n\t    else\n#endif\n\t    {\n\t\tvarnumber_T\tval;\n\t\tint\t\terror = FALSE;\n\n\t\t// tv_get_number_chk() accepts a string, but we don't want that\n\t\t// here\n\t\tif (check_not_string(rettv) == FAIL)\n\t\t    return FAIL;\n\t\tval = tv_get_number_chk(rettv, &error);\n\t\tclear_tv(rettv);\n\t\tif (error)\n\t\t    return FAIL;\n\t\tif (*p == '-')\n\t\t    val = -val;\n\t\trettv->v_type = VAR_NUMBER;\n\t\trettv->vval.v_number = val;\n\t    }\n\t}\n\telse if (numeric_only)\n\t{\n\t    ++p;\n\t    break;\n\t}\n\telse if (*p == '!')\n\t{\n\t    int v = tv2bool(rettv);\n\n\t    // '!' is permissive in the type.\n\t    clear_tv(rettv);\n\t    rettv->v_type = VAR_BOOL;\n\t    rettv->vval.v_number = v ? VVAL_FALSE : VVAL_TRUE;\n\t}\n    }\n    *end = p;\n    return OK;\n}\n\n/*\n * Recognize v: variables that are constants and set \"rettv\".\n */\n    static void\nget_vim_constant(char_u **arg, typval_T *rettv)\n{\n    if (STRNCMP(*arg, \"v:true\", 6) == 0)\n    {\n\trettv->v_type = VAR_BOOL;\n\trettv->vval.v_number = VVAL_TRUE;\n\t*arg += 6;\n    }\n    else if (STRNCMP(*arg, \"v:false\", 7) == 0)\n    {\n\trettv->v_type = VAR_BOOL;\n\trettv->vval.v_number = VVAL_FALSE;\n\t*arg += 7;\n    }\n    else if (STRNCMP(*arg, \"v:null\", 6) == 0)\n    {\n\trettv->v_type = VAR_SPECIAL;\n\trettv->vval.v_number = VVAL_NULL;\n\t*arg += 6;\n    }\n    else if (STRNCMP(*arg, \"v:none\", 6) == 0)\n    {\n\trettv->v_type = VAR_SPECIAL;\n\trettv->vval.v_number = VVAL_NONE;\n\t*arg += 6;\n    }\n}\n\n    exprtype_T\nget_compare_type(char_u *p, int *len, int *type_is)\n{\n    exprtype_T\ttype = EXPR_UNKNOWN;\n    int\t\ti;\n\n    switch (p[0])\n    {\n\tcase '=':   if (p[1] == '=')\n\t\t\ttype = EXPR_EQUAL;\n\t\t    else if (p[1] == '~')\n\t\t\ttype = EXPR_MATCH;\n\t\t    break;\n\tcase '!':   if (p[1] == '=')\n\t\t\ttype = EXPR_NEQUAL;\n\t\t    else if (p[1] == '~')\n\t\t\ttype = EXPR_NOMATCH;\n\t\t    break;\n\tcase '>':   if (p[1] != '=')\n\t\t    {\n\t\t\ttype = EXPR_GREATER;\n\t\t\t*len = 1;\n\t\t    }\n\t\t    else\n\t\t\ttype = EXPR_GEQUAL;\n\t\t    break;\n\tcase '<':   if (p[1] != '=')\n\t\t    {\n\t\t\ttype = EXPR_SMALLER;\n\t\t\t*len = 1;\n\t\t    }\n\t\t    else\n\t\t\ttype = EXPR_SEQUAL;\n\t\t    break;\n\tcase 'i':   if (p[1] == 's')\n\t\t    {\n\t\t\t// \"is\" and \"isnot\"; but not a prefix of a name\n\t\t\tif (p[2] == 'n' && p[3] == 'o' && p[4] == 't')\n\t\t\t    *len = 5;\n\t\t\ti = p[*len];\n\t\t\tif (!isalnum(i) && i != '_')\n\t\t\t{\n\t\t\t    type = *len == 2 ? EXPR_IS : EXPR_ISNOT;\n\t\t\t    *type_is = TRUE;\n\t\t\t}\n\t\t    }\n\t\t    break;\n    }\n    return type;\n}\n\n/*\n * Skip over an expression, ignoring most errors.\n */\n    void\nskip_expr_cctx(char_u **arg, cctx_T *cctx)\n{\n    evalarg_T\tevalarg;\n\n    init_evalarg(&evalarg);\n    evalarg.eval_cctx = cctx;\n    skip_expr(arg, &evalarg);\n    clear_evalarg(&evalarg, NULL);\n}\n\n/*\n * Check that the top of the type stack has a type that can be used as a\n * condition.  Give an error and return FAIL if not.\n */\n    int\nbool_on_stack(cctx_T *cctx)\n{\n    type_T\t*type;\n\n    type = get_type_on_stack(cctx, 0);\n    if (type == &t_bool)\n\treturn OK;\n\n    if (type == &t_any\n\t    || type == &t_unknown\n\t    || type == &t_number\n\t    || type == &t_number_bool)\n\t// Number 0 and 1 are OK to use as a bool.  \"any\" could also be a bool.\n\t// This requires a runtime type check.\n\treturn generate_COND2BOOL(cctx);\n\n    return need_type(type, &t_bool, -1, 0, cctx, FALSE, FALSE);\n}\n\n/*\n * Give the \"white on both sides\" error, taking the operator from \"p[len]\".\n */\n    void\nerror_white_both(char_u *op, int len)\n{\n    char_u\tbuf[10];\n\n    vim_strncpy(buf, op, len);\n    semsg(_(e_white_space_required_before_and_after_str_at_str), buf, op);\n}\n\n/*\n * Compile code to apply '-', '+' and '!'.\n * When \"numeric_only\" is TRUE do not apply '!'.\n */\n    static int\ncompile_leader(cctx_T *cctx, int numeric_only, char_u *start, char_u **end)\n{\n    char_u\t*p = *end;\n\n    // this works from end to start\n    while (p > start)\n    {\n\t--p;\n\twhile (VIM_ISWHITE(*p))\n\t    --p;\n\tif (*p == '-' || *p == '+')\n\t{\n\t    int\t\tnegate = *p == '-';\n\t    isn_T\t*isn;\n\t    type_T\t*type;\n\n\t    type = get_type_on_stack(cctx, 0);\n\t    if (type != &t_float && need_type(type, &t_number,\n\t\t\t\t\t    -1, 0, cctx, FALSE, FALSE) == FAIL)\n\t\treturn FAIL;\n\n\t    while (p > start && (p[-1] == '-' || p[-1] == '+'))\n\t    {\n\t\t--p;\n\t\tif (*p == '-')\n\t\t    negate = !negate;\n\t    }\n\t    // only '-' has an effect, for '+' we only check the type\n\t    if (negate)\n\t    {\n\t\tisn = generate_instr(cctx, ISN_NEGATENR);\n\t\tif (isn == NULL)\n\t\t    return FAIL;\n\t    }\n\t}\n\telse if (numeric_only)\n\t{\n\t    ++p;\n\t    break;\n\t}\n\telse\n\t{\n\t    int  invert = *p == '!';\n\n\t    while (p > start && (p[-1] == '!' || VIM_ISWHITE(p[-1])))\n\t    {\n\t\tif (p[-1] == '!')\n\t\t    invert = !invert;\n\t\t--p;\n\t    }\n\t    if (generate_2BOOL(cctx, invert, -1) == FAIL)\n\t\treturn FAIL;\n\t}\n    }\n    *end = p;\n    return OK;\n}\n\n/*\n * Compile \"(expression)\": recursive!\n * Return FAIL/OK.\n */\n    static int\ncompile_parenthesis(char_u **arg, cctx_T *cctx, ppconst_T *ppconst)\n{\n    int\t    ret;\n    char_u  *p = *arg + 1;\n\n    if (may_get_next_line_error(p, arg, cctx) == FAIL)\n\treturn FAIL;\n    if (ppconst->pp_used <= PPSIZE - 10)\n    {\n\tret = compile_expr1(arg, cctx, ppconst);\n    }\n    else\n    {\n\t// Not enough space in ppconst, flush constants.\n\tif (generate_ppconst(cctx, ppconst) == FAIL)\n\t    return FAIL;\n\tret = compile_expr0(arg, cctx);\n    }\n    if (may_get_next_line_error(*arg, arg, cctx) == FAIL)\n\treturn FAIL;\n    if (**arg == ')')\n\t++*arg;\n    else if (ret == OK)\n    {\n\temsg(_(e_missing_closing_paren));\n\tret = FAIL;\n    }\n    return ret;\n}\n\n/*\n * Compile whatever comes after \"name\" or \"name()\".\n * Advances \"*arg\" only when something was recognized.\n */\n    static int\ncompile_subscript(\n\tchar_u **arg,\n\tcctx_T *cctx,\n\tchar_u *start_leader,\n\tchar_u **end_leader,\n\tppconst_T *ppconst)\n{\n    char_u\t*name_start = *end_leader;\n    int\t\tkeeping_dict = FALSE;\n\n    for (;;)\n    {\n\tchar_u *p = skipwhite(*arg);\n\n\tif (*p == NUL || (VIM_ISWHITE(**arg) && vim9_comment_start(p)))\n\t{\n\t    char_u *next = peek_next_line_from_context(cctx);\n\n\t    // If a following line starts with \"->{\" or \"->X\" advance to that\n\t    // line, so that a line break before \"->\" is allowed.\n\t    // Also if a following line starts with \".x\".\n\t    if (next != NULL &&\n\t\t    ((next[0] == '-' && next[1] == '>'\n\t\t\t\t && (next[2] == '{'\n\t\t\t\t       || ASCII_ISALPHA(*skipwhite(next + 2))))\n\t\t    || (next[0] == '.' && eval_isdictc(next[1]))))\n\t    {\n\t\tnext = next_line_from_context(cctx, TRUE);\n\t\tif (next == NULL)\n\t\t    return FAIL;\n\t\t*arg = next;\n\t\tp = skipwhite(*arg);\n\t    }\n\t}\n\n\t// Do not skip over white space to find the \"(\", \"execute 'x' (expr)\"\n\t// is not a function call.\n\tif (**arg == '(')\n\t{\n\t    type_T\t*type;\n\t    int\t\targcount = 0;\n\n\t    if (generate_ppconst(cctx, ppconst) == FAIL)\n\t\treturn FAIL;\n\t    ppconst->pp_is_const = FALSE;\n\n\t    // funcref(arg)\n\t    type = get_type_on_stack(cctx, 0);\n\n\t    *arg = skipwhite(p + 1);\n\t    if (compile_arguments(arg, cctx, &argcount, FALSE) == FAIL)\n\t\treturn FAIL;\n\t    if (generate_PCALL(cctx, argcount, name_start, type, TRUE) == FAIL)\n\t\treturn FAIL;\n\t    if (keeping_dict)\n\t    {\n\t\tkeeping_dict = FALSE;\n\t\tif (generate_instr(cctx, ISN_CLEARDICT) == NULL)\n\t\t    return FAIL;\n\t    }\n\t}\n\telse if (*p == '-' && p[1] == '>')\n\t{\n\t    char_u *pstart = p;\n\n\t    if (generate_ppconst(cctx, ppconst) == FAIL)\n\t\treturn FAIL;\n\t    ppconst->pp_is_const = FALSE;\n\n\t    // something->method()\n\t    // Apply the '!', '-' and '+' first:\n\t    //   -1.0->func() works like (-1.0)->func()\n\t    if (compile_leader(cctx, TRUE, start_leader, end_leader) == FAIL)\n\t\treturn FAIL;\n\n\t    p += 2;\n\t    *arg = skipwhite(p);\n\t    // No line break supported right after \"->\".\n\t    if (**arg == '(')\n\t    {\n\t\tint\t    argcount = 1;\n\t\tgarray_T    *stack = &cctx->ctx_type_stack;\n\t\tint\t    type_idx_start = stack->ga_len;\n\t\ttype_T\t    *type;\n\t\tint\t    expr_isn_start = cctx->ctx_instr.ga_len;\n\t\tint\t    expr_isn_end;\n\t\tint\t    arg_isn_count;\n\n\t\t// Funcref call:  list->(Refs[2])(arg)\n\t\t// or lambda:\t  list->((arg) => expr)(arg)\n\t\t//\n\t\t// Fist compile the function expression.\n\t\tif (compile_parenthesis(arg, cctx, ppconst) == FAIL)\n\t\t    return FAIL;\n\n\t\t// Remember the next instruction index, where the instructions\n\t\t// for arguments are being written.\n\t\texpr_isn_end = cctx->ctx_instr.ga_len;\n\n\t\t// Compile the arguments.\n\t\tif (**arg != '(')\n\t\t{\n\t\t    if (*skipwhite(*arg) == '(')\n\t\t\temsg(_(e_no_white_space_allowed_before_parenthesis));\n\t\t    else\n\t\t\tsemsg(_(e_missing_parenthesis_str), *arg);\n\t\t    return FAIL;\n\t\t}\n\t\t*arg = skipwhite(*arg + 1);\n\t\tif (compile_arguments(arg, cctx, &argcount, FALSE) == FAIL)\n\t\t    return FAIL;\n\n\t\t// Move the instructions for the arguments to before the\n\t\t// instructions of the expression and move the type of the\n\t\t// expression after the argument types.  This is what ISN_PCALL\n\t\t// expects.\n\t\targ_isn_count = cctx->ctx_instr.ga_len - expr_isn_end;\n\t\tif (arg_isn_count > 0)\n\t\t{\n\t\t    int\t    expr_isn_count = expr_isn_end - expr_isn_start;\n\t\t    isn_T   *isn = ALLOC_MULT(isn_T, expr_isn_count);\n\t\t    type_T  *decl_type;\n\t\t    type2_T  *typep;\n\n\t\t    if (isn == NULL)\n\t\t\treturn FAIL;\n\t\t    mch_memmove(isn, ((isn_T *)cctx->ctx_instr.ga_data)\n\t\t\t\t\t\t\t      + expr_isn_start,\n\t\t\t\t\t       sizeof(isn_T) * expr_isn_count);\n\t\t    mch_memmove(((isn_T *)cctx->ctx_instr.ga_data)\n\t\t\t\t\t\t\t      + expr_isn_start,\n\t\t\t     ((isn_T *)cctx->ctx_instr.ga_data) + expr_isn_end,\n\t\t\t\t\t\tsizeof(isn_T) * arg_isn_count);\n\t\t    mch_memmove(((isn_T *)cctx->ctx_instr.ga_data)\n\t\t\t\t\t      + expr_isn_start + arg_isn_count,\n\t\t\t\t\t  isn, sizeof(isn_T) * expr_isn_count);\n\t\t    vim_free(isn);\n\n\t\t    typep = ((type2_T *)stack->ga_data) + type_idx_start;\n\t\t    type = typep->type_curr;\n\t\t    decl_type = typep->type_decl;\n\t\t    mch_memmove(((type2_T *)stack->ga_data) + type_idx_start,\n\t\t\t      ((type2_T *)stack->ga_data) + type_idx_start + 1,\n\t\t\t      sizeof(type2_T)\n\t\t\t\t       * (stack->ga_len - type_idx_start - 1));\n\t\t    typep = ((type2_T *)stack->ga_data) + stack->ga_len - 1;\n\t\t    typep->type_curr = type;\n\t\t    typep->type_decl = decl_type;\n\t\t}\n\n\t\ttype = get_type_on_stack(cctx, 0);\n\t\tif (generate_PCALL(cctx, argcount, p - 2, type, FALSE) == FAIL)\n\t\t    return FAIL;\n\t    }\n\t    else\n\t    {\n\t\t// method call:  list->method()\n\t\tp = *arg;\n\t\tif (!eval_isnamec1(*p))\n\t\t{\n\t\t    semsg(_(e_trailing_characters_str), pstart);\n\t\t    return FAIL;\n\t\t}\n\t\tif (ASCII_ISALPHA(*p) && p[1] == ':')\n\t\t    p += 2;\n\t\tfor ( ; eval_isnamec(*p); ++p)\n\t\t    ;\n\t\tif (*p != '(')\n\t\t{\n\t\t    semsg(_(e_missing_parenthesis_str), *arg);\n\t\t    return FAIL;\n\t\t}\n\t\tif (compile_call(arg, p - *arg, cctx, ppconst, 1) == FAIL)\n\t\t    return FAIL;\n\t    }\n\t    if (keeping_dict)\n\t    {\n\t\tkeeping_dict = FALSE;\n\t\tif (generate_instr(cctx, ISN_CLEARDICT) == NULL)\n\t\t    return FAIL;\n\t    }\n\t}\n\telse if (**arg == '[')\n\t{\n\t    int\t\tis_slice = FALSE;\n\n\t    // list index: list[123]\n\t    // dict member: dict[key]\n\t    // string index: text[123]\n\t    // blob index: blob[123]\n\t    if (generate_ppconst(cctx, ppconst) == FAIL)\n\t\treturn FAIL;\n\t    ppconst->pp_is_const = FALSE;\n\n\t    ++p;\n\t    if (may_get_next_line_error(p, arg, cctx) == FAIL)\n\t\treturn FAIL;\n\t    if (**arg == ':')\n\t    {\n\t\t// missing first index is equal to zero\n\t\tgenerate_PUSHNR(cctx, 0);\n\t    }\n\t    else\n\t    {\n\t\tif (compile_expr0(arg, cctx) == FAIL)\n\t\t    return FAIL;\n\t\tif (**arg == ':')\n\t\t{\n\t\t    semsg(_(e_white_space_required_before_and_after_str_at_str),\n\t\t\t\t\t\t\t\t    \":\", *arg);\n\t\t    return FAIL;\n\t\t}\n\t\tif (may_get_next_line_error(*arg, arg, cctx) == FAIL)\n\t\t    return FAIL;\n\t\t*arg = skipwhite(*arg);\n\t    }\n\t    if (**arg == ':')\n\t    {\n\t\tis_slice = TRUE;\n\t\t++*arg;\n\t\tif (!IS_WHITE_OR_NUL(**arg) && **arg != ']')\n\t\t{\n\t\t    semsg(_(e_white_space_required_before_and_after_str_at_str),\n\t\t\t\t\t\t\t\t    \":\", *arg);\n\t\t    return FAIL;\n\t\t}\n\t\tif (may_get_next_line_error(*arg, arg, cctx) == FAIL)\n\t\t    return FAIL;\n\t\tif (**arg == ']')\n\t\t    // missing second index is equal to end of string\n\t\t    generate_PUSHNR(cctx, -1);\n\t\telse\n\t\t{\n\t\t    if (compile_expr0(arg, cctx) == FAIL)\n\t\t\treturn FAIL;\n\t\t    if (may_get_next_line_error(*arg, arg, cctx) == FAIL)\n\t\t\treturn FAIL;\n\t\t    *arg = skipwhite(*arg);\n\t\t}\n\t    }\n\n\t    if (**arg != ']')\n\t    {\n\t\temsg(_(e_missing_closing_square_brace));\n\t\treturn FAIL;\n\t    }\n\t    *arg = *arg + 1;\n\n\t    if (keeping_dict)\n\t    {\n\t\tkeeping_dict = FALSE;\n\t\tif (generate_instr(cctx, ISN_CLEARDICT) == NULL)\n\t\t    return FAIL;\n\t    }\n\t    if (compile_member(is_slice, &keeping_dict, cctx) == FAIL)\n\t\treturn FAIL;\n\t}\n\telse if (*p == '.' && p[1] != '.')\n\t{\n\t    // dictionary member: dict.name\n\t    if (generate_ppconst(cctx, ppconst) == FAIL)\n\t\treturn FAIL;\n\t    ppconst->pp_is_const = FALSE;\n\n\t    *arg = p + 1;\n\t    if (IS_WHITE_OR_NUL(**arg))\n\t    {\n\t\temsg(_(e_missing_name_after_dot));\n\t\treturn FAIL;\n\t    }\n\t    p = *arg;\n\t    if (eval_isdictc(*p))\n\t\twhile (eval_isnamec(*p))\n\t\t    MB_PTR_ADV(p);\n\t    if (p == *arg)\n\t    {\n\t\tsemsg(_(e_syntax_error_at_str), *arg);\n\t\treturn FAIL;\n\t    }\n\t    if (keeping_dict && generate_instr(cctx, ISN_CLEARDICT) == NULL)\n\t\treturn FAIL;\n\t    if (generate_STRINGMEMBER(cctx, *arg, p - *arg) == FAIL)\n\t\treturn FAIL;\n\t    keeping_dict = TRUE;\n\t    *arg = p;\n\t}\n\telse\n\t    break;\n    }\n\n    // Turn \"dict.Func\" into a partial for \"Func\" bound to \"dict\".\n    // This needs to be done at runtime to be able to check the type.\n    if (keeping_dict && generate_instr(cctx, ISN_USEDICT) == NULL)\n\treturn FAIL;\n\n    return OK;\n}\n\n/*\n * Compile an expression at \"*arg\" and add instructions to \"cctx->ctx_instr\".\n * \"arg\" is advanced until after the expression, skipping white space.\n *\n * If the value is a constant \"ppconst->pp_used\" will be non-zero.\n * Before instructions are generated, any values in \"ppconst\" will generated.\n *\n * This is the compiling equivalent of eval1(), eval2(), etc.\n */\n\n/*\n *  number\t\tnumber constant\n *  0zFFFFFFFF\t\tBlob constant\n *  \"string\"\t\tstring constant\n *  'string'\t\tliteral string constant\n *  &option-name\toption value\n *  @r\t\t\tregister contents\n *  identifier\t\tvariable value\n *  function()\t\tfunction call\n *  $VAR\t\tenvironment variable\n *  (expression)\tnested expression\n *  [expr, expr]\tList\n *  {key: val, [key]: val}   Dictionary\n *\n *  Also handle:\n *  ! in front\t\tlogical NOT\n *  - in front\t\tunary minus\n *  + in front\t\tunary plus (ignored)\n *  trailing (arg)\tfuncref/partial call\n *  trailing []\t\tsubscript in String or List\n *  trailing .name\tentry in Dictionary\n *  trailing ->name()\tmethod call\n */\n    static int\ncompile_expr8(\n\tchar_u **arg,\n\tcctx_T *cctx,\n\tppconst_T *ppconst)\n{\n    char_u\t*start_leader, *end_leader;\n    int\t\tret = OK;\n    typval_T\t*rettv = &ppconst->pp_tv[ppconst->pp_used];\n    int\t\tused_before = ppconst->pp_used;\n\n    ppconst->pp_is_const = FALSE;\n\n    /*\n     * Skip '!', '-' and '+' characters.  They are handled later.\n     */\n    start_leader = *arg;\n    if (eval_leader(arg, TRUE) == FAIL)\n\treturn FAIL;\n    end_leader = *arg;\n\n    rettv->v_type = VAR_UNKNOWN;\n    switch (**arg)\n    {\n\t/*\n\t * Number constant.\n\t */\n\tcase '0':\t// also for blob starting with 0z\n\tcase '1':\n\tcase '2':\n\tcase '3':\n\tcase '4':\n\tcase '5':\n\tcase '6':\n\tcase '7':\n\tcase '8':\n\tcase '9':\n\tcase '.':   if (eval_number(arg, rettv, TRUE, FALSE) == FAIL)\n\t\t\treturn FAIL;\n\t\t    // Apply \"-\" and \"+\" just before the number now, right to\n\t\t    // left.  Matters especially when \"->\" follows.  Stops at\n\t\t    // '!'.\n\t\t    if (apply_leader(rettv, TRUE,\n\t\t\t\t\t    start_leader, &end_leader) == FAIL)\n\t\t    {\n\t\t\tclear_tv(rettv);\n\t\t\treturn FAIL;\n\t\t    }\n\t\t    break;\n\n\t/*\n\t * String constant: \"string\".\n\t */\n\tcase '\"':   if (eval_string(arg, rettv, TRUE) == FAIL)\n\t\t\treturn FAIL;\n\t\t    break;\n\n\t/*\n\t * Literal string constant: 'str''ing'.\n\t */\n\tcase '\\'':  if (eval_lit_string(arg, rettv, TRUE) == FAIL)\n\t\t\treturn FAIL;\n\t\t    break;\n\n\t/*\n\t * Constant Vim variable.\n\t */\n\tcase 'v':   get_vim_constant(arg, rettv);\n\t\t    ret = NOTDONE;\n\t\t    break;\n\n\t/*\n\t * \"true\" constant\n\t */\n\tcase 't':   if (STRNCMP(*arg, \"true\", 4) == 0\n\t\t\t\t\t\t   && !eval_isnamec((*arg)[4]))\n\t\t    {\n\t\t\t*arg += 4;\n\t\t\trettv->v_type = VAR_BOOL;\n\t\t\trettv->vval.v_number = VVAL_TRUE;\n\t\t    }\n\t\t    else\n\t\t\tret = NOTDONE;\n\t\t    break;\n\n\t/*\n\t * \"false\" constant\n\t */\n\tcase 'f':   if (STRNCMP(*arg, \"false\", 5) == 0\n\t\t\t\t\t\t   && !eval_isnamec((*arg)[5]))\n\t\t    {\n\t\t\t*arg += 5;\n\t\t\trettv->v_type = VAR_BOOL;\n\t\t\trettv->vval.v_number = VVAL_FALSE;\n\t\t    }\n\t\t    else\n\t\t\tret = NOTDONE;\n\t\t    break;\n\n\t/*\n\t * \"null\" constant\n\t */\n\tcase 'n':   if (STRNCMP(*arg, \"null\", 4) == 0\n\t\t\t\t\t\t   && !eval_isnamec((*arg)[4]))\n\t\t    {\n\t\t\t*arg += 4;\n\t\t\trettv->v_type = VAR_SPECIAL;\n\t\t\trettv->vval.v_number = VVAL_NULL;\n\t\t    }\n\t\t    else\n\t\t\tret = NOTDONE;\n\t\t    break;\n\n\t/*\n\t * List: [expr, expr]\n\t */\n\tcase '[':   if (generate_ppconst(cctx, ppconst) == FAIL)\n\t\t\treturn FAIL;\n\t\t    ret = compile_list(arg, cctx, ppconst);\n\t\t    break;\n\n\t/*\n\t * Dictionary: {'key': val, 'key': val}\n\t */\n\tcase '{':   if (generate_ppconst(cctx, ppconst) == FAIL)\n\t\t\treturn FAIL;\n\t\t    ret = compile_dict(arg, cctx, ppconst);\n\t\t    break;\n\n\t/*\n\t * Option value: &name\n\t */\n\tcase '&':\tif (generate_ppconst(cctx, ppconst) == FAIL)\n\t\t\t    return FAIL;\n\t\t\tret = compile_get_option(arg, cctx);\n\t\t\tbreak;\n\n\t/*\n\t * Environment variable: $VAR.\n\t */\n\tcase '$':\tif (generate_ppconst(cctx, ppconst) == FAIL)\n\t\t\t    return FAIL;\n\t\t\tret = compile_get_env(arg, cctx);\n\t\t\tbreak;\n\n\t/*\n\t * Register contents: @r.\n\t */\n\tcase '@':\tif (generate_ppconst(cctx, ppconst) == FAIL)\n\t\t\t    return FAIL;\n\t\t\tret = compile_get_register(arg, cctx);\n\t\t\tbreak;\n\t/*\n\t * nested expression: (expression).\n\t * lambda: (arg, arg) => expr\n\t * funcref: (arg, arg) => { statement }\n\t */\n\tcase '(':   // if compile_lambda returns NOTDONE then it must be (expr)\n\t\t    ret = compile_lambda(arg, cctx);\n\t\t    if (ret == NOTDONE)\n\t\t\tret = compile_parenthesis(arg, cctx, ppconst);\n\t\t    break;\n\n\tdefault:    ret = NOTDONE;\n\t\t    break;\n    }\n    if (ret == FAIL)\n\treturn FAIL;\n\n    if (rettv->v_type != VAR_UNKNOWN && used_before == ppconst->pp_used)\n    {\n\tif (cctx->ctx_skip == SKIP_YES)\n\t    clear_tv(rettv);\n\telse\n\t    // A constant expression can possibly be handled compile time,\n\t    // return the value instead of generating code.\n\t    ++ppconst->pp_used;\n    }\n    else if (ret == NOTDONE)\n    {\n\tchar_u\t    *p;\n\tint\t    r;\n\n\tif (!eval_isnamec1(**arg))\n\t{\n\t    if (!vim9_bad_comment(*arg))\n\t    {\n\t\tif (ends_excmd(*skipwhite(*arg)))\n\t\t    semsg(_(e_empty_expression_str), *arg);\n\t\telse\n\t\t    semsg(_(e_name_expected_str), *arg);\n\t    }\n\t    return FAIL;\n\t}\n\n\t// \"name\" or \"name()\"\n\tp = to_name_end(*arg, TRUE);\n\tif (p - *arg == (size_t)1 && **arg == '_')\n\t{\n\t    emsg(_(e_cannot_use_underscore_here));\n\t    return FAIL;\n\t}\n\n\tif (*p == '(')\n\t{\n\t    r = compile_call(arg, p - *arg, cctx, ppconst, 0);\n\t}\n\telse\n\t{\n\t    if (cctx->ctx_skip != SKIP_YES\n\t\t\t\t    && generate_ppconst(cctx, ppconst) == FAIL)\n\t\treturn FAIL;\n\t    r = compile_load(arg, p, cctx, TRUE, TRUE);\n\t}\n\tif (r == FAIL)\n\t    return FAIL;\n    }\n\n    // Handle following \"[]\", \".member\", etc.\n    // Then deal with prefixed '-', '+' and '!', if not done already.\n    if (compile_subscript(arg, cctx, start_leader, &end_leader,\n\t\t\t\t\t\t\t     ppconst) == FAIL)\n\treturn FAIL;\n    if (ppconst->pp_used > 0)\n    {\n\t// apply the '!', '-' and '+' before the constant\n\trettv = &ppconst->pp_tv[ppconst->pp_used - 1];\n\tif (apply_leader(rettv, FALSE, start_leader, &end_leader) == FAIL)\n\t    return FAIL;\n\treturn OK;\n    }\n    if (compile_leader(cctx, FALSE, start_leader, &end_leader) == FAIL)\n\treturn FAIL;\n    return OK;\n}\n\n/*\n * <type>expr8: runtime type check / conversion\n */\n    static int\ncompile_expr7(char_u **arg, cctx_T *cctx, ppconst_T *ppconst)\n{\n    type_T *want_type = NULL;\n\n    // Recognize <type>\n    if (**arg == '<' && eval_isnamec1((*arg)[1]))\n    {\n\t++*arg;\n\twant_type = parse_type(arg, cctx->ctx_type_list, TRUE);\n\tif (want_type == NULL)\n\t    return FAIL;\n\n\tif (**arg != '>')\n\t{\n\t    if (*skipwhite(*arg) == '>')\n\t\tsemsg(_(e_no_white_space_allowed_before_str_str), \">\", *arg);\n\t    else\n\t\temsg(_(e_missing_gt));\n\t    return FAIL;\n\t}\n\t++*arg;\n\tif (may_get_next_line_error(*arg, arg, cctx) == FAIL)\n\t    return FAIL;\n    }\n\n    if (compile_expr8(arg, cctx, ppconst) == FAIL)\n\treturn FAIL;\n\n    if (want_type != NULL)\n    {\n\ttype_T\t    *actual;\n\twhere_T\t    where = WHERE_INIT;\n\n\tgenerate_ppconst(cctx, ppconst);\n\tactual = get_type_on_stack(cctx, 0);\n\tif (check_type_maybe(want_type, actual, FALSE, where) != OK)\n\t{\n\t    if (need_type(actual, want_type, -1, 0, cctx, FALSE, FALSE)\n\t\t\t\t\t\t\t\t       == FAIL)\n\t\treturn FAIL;\n\t}\n    }\n\n    return OK;\n}\n\n/*\n *\t*\tnumber multiplication\n *\t/\tnumber division\n *\t%\tnumber modulo\n */\n    static int\ncompile_expr6(char_u **arg, cctx_T *cctx, ppconst_T *ppconst)\n{\n    char_u\t*op;\n    char_u\t*next;\n    int\t\tppconst_used = ppconst->pp_used;\n\n    // get the first expression\n    if (compile_expr7(arg, cctx, ppconst) == FAIL)\n\treturn FAIL;\n\n    /*\n     * Repeat computing, until no \"*\", \"/\" or \"%\" is following.\n     */\n    for (;;)\n    {\n\top = may_peek_next_line(cctx, *arg, &next);\n\tif (*op != '*' && *op != '/' && *op != '%')\n\t    break;\n\tif (next != NULL)\n\t{\n\t    *arg = next_line_from_context(cctx, TRUE);\n\t    op = skipwhite(*arg);\n\t}\n\n\tif (!IS_WHITE_OR_NUL(**arg) || !IS_WHITE_OR_NUL(op[1]))\n\t{\n\t    error_white_both(op, 1);\n\t    return FAIL;\n\t}\n\tif (may_get_next_line_error(op + 1, arg, cctx) == FAIL)\n\t    return FAIL;\n\n\t// get the second expression\n\tif (compile_expr7(arg, cctx, ppconst) == FAIL)\n\t    return FAIL;\n\n\tif (ppconst->pp_used == ppconst_used + 2\n\t\t&& ppconst->pp_tv[ppconst_used].v_type == VAR_NUMBER\n\t\t&& ppconst->pp_tv[ppconst_used + 1].v_type == VAR_NUMBER)\n\t{\n\t    typval_T\t    *tv1 = &ppconst->pp_tv[ppconst_used];\n\t    typval_T\t    *tv2 = &ppconst->pp_tv[ppconst_used + 1];\n\t    varnumber_T\t    res = 0;\n\t    int\t\t    failed = FALSE;\n\n\t    // both are numbers: compute the result\n\t    switch (*op)\n\t    {\n\t\tcase '*': res = tv1->vval.v_number * tv2->vval.v_number;\n\t\t\t  break;\n\t\tcase '/': res = num_divide(tv1->vval.v_number,\n\t\t\t\t\t\t  tv2->vval.v_number, &failed);\n\t\t\t  break;\n\t\tcase '%': res = num_modulus(tv1->vval.v_number,\n\t\t\t\t\t\t  tv2->vval.v_number, &failed);\n\t\t\t  break;\n\t    }\n\t    if (failed)\n\t\treturn FAIL;\n\t    tv1->vval.v_number = res;\n\t    --ppconst->pp_used;\n\t}\n\telse\n\t{\n\t    generate_ppconst(cctx, ppconst);\n\t    generate_two_op(cctx, op);\n\t}\n    }\n\n    return OK;\n}\n\n/*\n *      +\tnumber addition or list/blobl concatenation\n *      -\tnumber subtraction\n *      ..\tstring concatenation\n */\n    static int\ncompile_expr5(char_u **arg, cctx_T *cctx, ppconst_T *ppconst)\n{\n    char_u\t*op;\n    char_u\t*next;\n    int\t\toplen;\n    int\t\tppconst_used = ppconst->pp_used;\n\n    // get the first variable\n    if (compile_expr6(arg, cctx, ppconst) == FAIL)\n\treturn FAIL;\n\n    /*\n     * Repeat computing, until no \"+\", \"-\" or \"..\" is following.\n     */\n    for (;;)\n    {\n\top = may_peek_next_line(cctx, *arg, &next);\n\tif (*op != '+' && *op != '-' && !(*op == '.' && *(op + 1) == '.'))\n\t    break;\n\tif (op[0] == op[1] && *op != '.' && next)\n\t    // Finding \"++\" or \"--\" on the next line is a separate command.\n\t    // But \"..\" is concatenation.\n\t    break;\n\toplen = (*op == '.' ? 2 : 1);\n\tif (next != NULL)\n\t{\n\t    *arg = next_line_from_context(cctx, TRUE);\n\t    op = skipwhite(*arg);\n\t}\n\n\tif (!IS_WHITE_OR_NUL(**arg) || !IS_WHITE_OR_NUL(op[oplen]))\n\t{\n\t    error_white_both(op, oplen);\n\t    return FAIL;\n\t}\n\n\tif (may_get_next_line_error(op + oplen, arg, cctx) == FAIL)\n\t    return FAIL;\n\n\t// get the second expression\n\tif (compile_expr6(arg, cctx, ppconst) == FAIL)\n\t    return FAIL;\n\n\tif (ppconst->pp_used == ppconst_used + 2\n\t\t&& (*op == '.'\n\t\t    ? (ppconst->pp_tv[ppconst_used].v_type == VAR_STRING\n\t\t    && ppconst->pp_tv[ppconst_used + 1].v_type == VAR_STRING)\n\t\t    : (ppconst->pp_tv[ppconst_used].v_type == VAR_NUMBER\n\t\t    && ppconst->pp_tv[ppconst_used + 1].v_type == VAR_NUMBER)))\n\t{\n\t    typval_T *tv1 = &ppconst->pp_tv[ppconst_used];\n\t    typval_T *tv2 = &ppconst->pp_tv[ppconst_used + 1];\n\n\t    // concat/subtract/add constant numbers\n\t    if (*op == '+')\n\t\ttv1->vval.v_number = tv1->vval.v_number + tv2->vval.v_number;\n\t    else if (*op == '-')\n\t\ttv1->vval.v_number = tv1->vval.v_number - tv2->vval.v_number;\n\t    else\n\t    {\n\t\t// concatenate constant strings\n\t\tchar_u *s1 = tv1->vval.v_string;\n\t\tchar_u *s2 = tv2->vval.v_string;\n\t\tsize_t len1 = STRLEN(s1);\n\n\t\ttv1->vval.v_string = alloc((int)(len1 + STRLEN(s2) + 1));\n\t\tif (tv1->vval.v_string == NULL)\n\t\t{\n\t\t    clear_ppconst(ppconst);\n\t\t    return FAIL;\n\t\t}\n\t\tmch_memmove(tv1->vval.v_string, s1, len1);\n\t\tSTRCPY(tv1->vval.v_string + len1, s2);\n\t\tvim_free(s1);\n\t\tvim_free(s2);\n\t    }\n\t    --ppconst->pp_used;\n\t}\n\telse\n\t{\n\t    generate_ppconst(cctx, ppconst);\n\t    ppconst->pp_is_const = FALSE;\n\t    if (*op == '.')\n\t    {\n\t\tif (may_generate_2STRING(-2, FALSE, cctx) == FAIL\n\t\t\t|| may_generate_2STRING(-1, FALSE, cctx) == FAIL)\n\t\t    return FAIL;\n\t\tgenerate_instr_drop(cctx, ISN_CONCAT, 1);\n\t    }\n\t    else\n\t\tgenerate_two_op(cctx, op);\n\t}\n    }\n\n    return OK;\n}\n\n/*\n * expr5a == expr5b\n * expr5a =~ expr5b\n * expr5a != expr5b\n * expr5a !~ expr5b\n * expr5a > expr5b\n * expr5a >= expr5b\n * expr5a < expr5b\n * expr5a <= expr5b\n * expr5a is expr5b\n * expr5a isnot expr5b\n *\n * Produces instructions:\n *\tEVAL expr5a\t\tPush result of \"expr5a\"\n *\tEVAL expr5b\t\tPush result of \"expr5b\"\n *\tCOMPARE\t\t\tone of the compare instructions\n */\n    static int\ncompile_expr4(char_u **arg, cctx_T *cctx, ppconst_T *ppconst)\n{\n    exprtype_T\ttype = EXPR_UNKNOWN;\n    char_u\t*p;\n    char_u\t*next;\n    int\t\tlen = 2;\n    int\t\ttype_is = FALSE;\n    int\t\tppconst_used = ppconst->pp_used;\n\n    // get the first variable\n    if (compile_expr5(arg, cctx, ppconst) == FAIL)\n\treturn FAIL;\n\n    p = may_peek_next_line(cctx, *arg, &next);\n    type = get_compare_type(p, &len, &type_is);\n\n    /*\n     * If there is a comparative operator, use it.\n     */\n    if (type != EXPR_UNKNOWN)\n    {\n\tint ic = FALSE;  // Default: do not ignore case\n\n\tif (next != NULL)\n\t{\n\t    *arg = next_line_from_context(cctx, TRUE);\n\t    p = skipwhite(*arg);\n\t}\n\tif (type_is && (p[len] == '?' || p[len] == '#'))\n\t{\n\t    semsg(_(e_invalid_expression_str), *arg);\n\t    return FAIL;\n\t}\n\t// extra question mark appended: ignore case\n\tif (p[len] == '?')\n\t{\n\t    ic = TRUE;\n\t    ++len;\n\t}\n\t// extra '#' appended: match case (ignored)\n\telse if (p[len] == '#')\n\t    ++len;\n\t// nothing appended: match case\n\n\tif (!IS_WHITE_OR_NUL(**arg) || !IS_WHITE_OR_NUL(p[len]))\n\t{\n\t    error_white_both(p, len);\n\t    return FAIL;\n\t}\n\n\t// get the second variable\n\tif (may_get_next_line_error(p + len, arg, cctx) == FAIL)\n\t    return FAIL;\n\n\tif (compile_expr5(arg, cctx, ppconst) == FAIL)\n\t    return FAIL;\n\n\tif (ppconst->pp_used == ppconst_used + 2)\n\t{\n\t    typval_T *\ttv1 = &ppconst->pp_tv[ppconst->pp_used - 2];\n\t    typval_T\t*tv2 = &ppconst->pp_tv[ppconst->pp_used - 1];\n\t    int\t\tret;\n\n\t    // Both sides are a constant, compute the result now.\n\t    // First check for a valid combination of types, this is more\n\t    // strict than typval_compare().\n\t    if (check_compare_types(type, tv1, tv2) == FAIL)\n\t\tret = FAIL;\n\t    else\n\t    {\n\t\tret = typval_compare(tv1, tv2, type, ic);\n\t\ttv1->v_type = VAR_BOOL;\n\t\ttv1->vval.v_number = tv1->vval.v_number\n\t\t\t\t\t\t      ? VVAL_TRUE : VVAL_FALSE;\n\t\tclear_tv(tv2);\n\t\t--ppconst->pp_used;\n\t    }\n\t    return ret;\n\t}\n\n\tgenerate_ppconst(cctx, ppconst);\n\treturn generate_COMPARE(cctx, type, ic);\n    }\n\n    return OK;\n}\n\nstatic int compile_expr3(char_u **arg,  cctx_T *cctx, ppconst_T *ppconst);\n\n/*\n * Compile || or &&.\n */\n    static int\ncompile_and_or(\n\tchar_u **arg,\n\tcctx_T\t*cctx,\n\tchar\t*op,\n\tppconst_T *ppconst,\n\tint\tppconst_used UNUSED)\n{\n    char_u\t*next;\n    char_u\t*p = may_peek_next_line(cctx, *arg, &next);\n    int\t\topchar = *op;\n\n    if (p[0] == opchar && p[1] == opchar)\n    {\n\tgarray_T\t*instr = &cctx->ctx_instr;\n\tgarray_T\tend_ga;\n\tint\t\tsave_skip = cctx->ctx_skip;\n\n\t/*\n\t * Repeat until there is no following \"||\" or \"&&\"\n\t */\n\tga_init2(&end_ga, sizeof(int), 10);\n\twhile (p[0] == opchar && p[1] == opchar)\n\t{\n\t    long\tstart_lnum = SOURCING_LNUM;\n\t    long\tsave_sourcing_lnum;\n\t    int\t\tstart_ctx_lnum = cctx->ctx_lnum;\n\t    int\t\tsave_lnum;\n\t    int\t\tconst_used;\n\t    int\t\tstatus;\n\t    jumpwhen_T\tjump_when = opchar == '|'\n\t\t\t\t      ? JUMP_IF_COND_TRUE : JUMP_IF_COND_FALSE;\n\n\t    if (next != NULL)\n\t    {\n\t\t*arg = next_line_from_context(cctx, TRUE);\n\t\tp = skipwhite(*arg);\n\t    }\n\n\t    if (!IS_WHITE_OR_NUL(**arg) || !IS_WHITE_OR_NUL(p[2]))\n\t    {\n\t\tsemsg(_(e_white_space_required_before_and_after_str_at_str),\n\t\t\t\t\t\t\t\t\top, p);\n\t\tga_clear(&end_ga);\n\t\treturn FAIL;\n\t    }\n\n\t    save_sourcing_lnum = SOURCING_LNUM;\n\t    SOURCING_LNUM = start_lnum;\n\t    save_lnum = cctx->ctx_lnum;\n\t    cctx->ctx_lnum = start_ctx_lnum;\n\n\t    status = check_ppconst_bool(ppconst);\n\t    if (status != FAIL)\n\t    {\n\t\t// Use the last ppconst if possible.\n\t\tif (ppconst->pp_used > 0)\n\t\t{\n\t\t    typval_T\t*tv = &ppconst->pp_tv[ppconst->pp_used - 1];\n\t\t    int\t\tis_true = tv2bool(tv);\n\n\t\t    if ((is_true && opchar == '|')\n\t\t\t\t\t\t|| (!is_true && opchar == '&'))\n\t\t    {\n\t\t\t// For \"false && expr\" and \"true || expr\" the \"expr\"\n\t\t\t// does not need to be evaluated.\n\t\t\tcctx->ctx_skip = SKIP_YES;\n\t\t\tclear_tv(tv);\n\t\t\ttv->v_type = VAR_BOOL;\n\t\t\ttv->vval.v_number = is_true ? VVAL_TRUE : VVAL_FALSE;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t// For \"true && expr\" and \"false || expr\" only \"expr\"\n\t\t\t// needs to be evaluated.\n\t\t\t--ppconst->pp_used;\n\t\t\tjump_when = JUMP_NEVER;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    // Every part must evaluate to a bool.\n\t\t    status = bool_on_stack(cctx);\n\t\t}\n\t    }\n\t    if (status != FAIL)\n\t\tstatus = ga_grow(&end_ga, 1);\n\t    cctx->ctx_lnum = save_lnum;\n\t    if (status == FAIL)\n\t    {\n\t\tga_clear(&end_ga);\n\t\treturn FAIL;\n\t    }\n\n\t    if (jump_when != JUMP_NEVER)\n\t    {\n\t\tif (cctx->ctx_skip != SKIP_YES)\n\t\t{\n\t\t    *(((int *)end_ga.ga_data) + end_ga.ga_len) = instr->ga_len;\n\t\t    ++end_ga.ga_len;\n\t\t}\n\t\tgenerate_JUMP(cctx, jump_when, 0);\n\t    }\n\n\t    // eval the next expression\n\t    SOURCING_LNUM = save_sourcing_lnum;\n\t    if (may_get_next_line_error(p + 2, arg, cctx) == FAIL)\n\t    {\n\t\tga_clear(&end_ga);\n\t\treturn FAIL;\n\t    }\n\n\t    const_used = ppconst->pp_used;\n\t    if ((opchar == '|' ? compile_expr3(arg, cctx, ppconst)\n\t\t\t\t  : compile_expr4(arg, cctx, ppconst)) == FAIL)\n\t    {\n\t\tga_clear(&end_ga);\n\t\treturn FAIL;\n\t    }\n\n\t    // \"0 || 1\" results in true, \"1 && 0\" results in false.\n\t    if (ppconst->pp_used == const_used + 1)\n\t    {\n\t\ttypval_T\t*tv = &ppconst->pp_tv[ppconst->pp_used - 1];\n\n\t\tif (tv->v_type == VAR_NUMBER\n\t\t\t && (tv->vval.v_number == 1 || tv->vval.v_number == 0))\n\t\t{\n\t\t    tv->vval.v_number = tv->vval.v_number == 1\n\t\t\t\t\t\t      ? VVAL_TRUE : VVAL_FALSE;\n\t\t    tv->v_type = VAR_BOOL;\n\t\t}\n\t    }\n\n\t    p = may_peek_next_line(cctx, *arg, &next);\n\t}\n\n\tif (check_ppconst_bool(ppconst) == FAIL)\n\t{\n\t    ga_clear(&end_ga);\n\t    return FAIL;\n\t}\n\n\tif (cctx->ctx_skip != SKIP_YES && ppconst->pp_used == 0)\n\t    // Every part must evaluate to a bool.\n\t    if (bool_on_stack(cctx) == FAIL)\n\t    {\n\t\tga_clear(&end_ga);\n\t\treturn FAIL;\n\t    }\n\n\tif (end_ga.ga_len > 0)\n\t{\n\t    // Fill in the end label in all jumps.\n\t    generate_ppconst(cctx, ppconst);\n\t    while (end_ga.ga_len > 0)\n\t    {\n\t\tisn_T\t*isn;\n\n\t\t--end_ga.ga_len;\n\t\tisn = ((isn_T *)instr->ga_data)\n\t\t\t\t  + *(((int *)end_ga.ga_data) + end_ga.ga_len);\n\t\tisn->isn_arg.jump.jump_where = instr->ga_len;\n\t    }\n\t}\n\tga_clear(&end_ga);\n\n\tcctx->ctx_skip = save_skip;\n    }\n\n    return OK;\n}\n\n/*\n * expr4a && expr4a && expr4a\t    logical AND\n *\n * Produces instructions:\n *\tEVAL expr4a\t\tPush result of \"expr4a\"\n *\tCOND2BOOL\t\tconvert to bool if needed\n *\tJUMP_IF_COND_FALSE end\n *\tEVAL expr4b\t\tPush result of \"expr4b\"\n *\tJUMP_IF_COND_FALSE end\n *\tEVAL expr4c\t\tPush result of \"expr4c\"\n * end:\n */\n    static int\ncompile_expr3(char_u **arg, cctx_T *cctx, ppconst_T *ppconst)\n{\n    int\t\tppconst_used = ppconst->pp_used;\n\n    // get the first variable\n    if (compile_expr4(arg, cctx, ppconst) == FAIL)\n\treturn FAIL;\n\n    // || and && work almost the same\n    return compile_and_or(arg, cctx, \"&&\", ppconst, ppconst_used);\n}\n\n/*\n * expr3a || expr3b || expr3c\t    logical OR\n *\n * Produces instructions:\n *\tEVAL expr3a\t\tPush result of \"expr3a\"\n *\tCOND2BOOL\t\tconvert to bool if needed\n *\tJUMP_IF_COND_TRUE end\n *\tEVAL expr3b\t\tPush result of \"expr3b\"\n *\tJUMP_IF_COND_TRUE end\n *\tEVAL expr3c\t\tPush result of \"expr3c\"\n * end:\n */\n    static int\ncompile_expr2(char_u **arg, cctx_T *cctx, ppconst_T *ppconst)\n{\n    int\t\tppconst_used = ppconst->pp_used;\n\n    // eval the first expression\n    if (compile_expr3(arg, cctx, ppconst) == FAIL)\n\treturn FAIL;\n\n    // || and && work almost the same\n    return compile_and_or(arg, cctx, \"||\", ppconst, ppconst_used);\n}\n\n/*\n * Toplevel expression: expr2 ? expr1a : expr1b\n * Produces instructions:\n *\tEVAL expr2\t\tPush result of \"expr2\"\n *      JUMP_IF_FALSE alt\tjump if false\n *      EVAL expr1a\n *      JUMP_ALWAYS end\n * alt:\tEVAL expr1b\n * end:\n *\n * Toplevel expression: expr2 ?? expr1\n * Produces instructions:\n *\tEVAL expr2\t\t    Push result of \"expr2\"\n *      JUMP_AND_KEEP_IF_TRUE end   jump if true\n *      EVAL expr1\n * end:\n */\n    int\ncompile_expr1(char_u **arg, cctx_T *cctx, ppconst_T *ppconst)\n{\n    char_u\t*p;\n    int\t\tppconst_used = ppconst->pp_used;\n    char_u\t*next;\n\n    // Ignore all kinds of errors when not producing code.\n    if (cctx->ctx_skip == SKIP_YES)\n    {\n\tskip_expr_cctx(arg, cctx);\n\treturn OK;\n    }\n\n    // Evaluate the first expression.\n    if (compile_expr2(arg, cctx, ppconst) == FAIL)\n\treturn FAIL;\n\n    p = may_peek_next_line(cctx, *arg, &next);\n    if (*p == '?')\n    {\n\tint\t\top_falsy = p[1] == '?';\n\tgarray_T\t*instr = &cctx->ctx_instr;\n\tgarray_T\t*stack = &cctx->ctx_type_stack;\n\tint\t\talt_idx = instr->ga_len;\n\tint\t\tend_idx = 0;\n\tisn_T\t\t*isn;\n\ttype_T\t\t*type1 = NULL;\n\tint\t\thas_const_expr = FALSE;\n\tint\t\tconst_value = FALSE;\n\tint\t\tsave_skip = cctx->ctx_skip;\n\n\tif (next != NULL)\n\t{\n\t    *arg = next_line_from_context(cctx, TRUE);\n\t    p = skipwhite(*arg);\n\t}\n\n\tif (!IS_WHITE_OR_NUL(**arg) || !IS_WHITE_OR_NUL(p[1 + op_falsy]))\n\t{\n\t    semsg(_(e_white_space_required_before_and_after_str_at_str),\n\t\t\t\t\t\t     op_falsy ? \"??\" : \"?\", p);\n\t    return FAIL;\n\t}\n\n\tif (ppconst->pp_used == ppconst_used + 1)\n\t{\n\t    // the condition is a constant, we know whether the ? or the :\n\t    // expression is to be evaluated.\n\t    has_const_expr = TRUE;\n\t    if (op_falsy)\n\t\tconst_value = tv2bool(&ppconst->pp_tv[ppconst_used]);\n\t    else\n\t    {\n\t\tint error = FALSE;\n\n\t\tconst_value = tv_get_bool_chk(&ppconst->pp_tv[ppconst_used],\n\t\t\t\t\t\t\t\t       &error);\n\t\tif (error)\n\t\t    return FAIL;\n\t    }\n\t    cctx->ctx_skip = save_skip == SKIP_YES ||\n\t\t (op_falsy ? const_value : !const_value) ? SKIP_YES : SKIP_NOT;\n\n\t    if (op_falsy && cctx->ctx_skip == SKIP_YES)\n\t\t// \"left ?? right\" and \"left\" is truthy: produce \"left\"\n\t\tgenerate_ppconst(cctx, ppconst);\n\t    else\n\t    {\n\t\tclear_tv(&ppconst->pp_tv[ppconst_used]);\n\t\t--ppconst->pp_used;\n\t    }\n\t}\n\telse\n\t{\n\t    generate_ppconst(cctx, ppconst);\n\t    if (op_falsy)\n\t\tend_idx = instr->ga_len;\n\t    generate_JUMP(cctx, op_falsy\n\t\t\t\t   ? JUMP_AND_KEEP_IF_TRUE : JUMP_IF_FALSE, 0);\n\t    if (op_falsy)\n\t\ttype1 = get_type_on_stack(cctx, -1);\n\t}\n\n\t// evaluate the second expression; any type is accepted\n\tif (may_get_next_line_error(p + 1 + op_falsy, arg, cctx) == FAIL)\n\t    return FAIL;\n\tif (compile_expr1(arg, cctx, ppconst) == FAIL)\n\t    return FAIL;\n\n\tif (!has_const_expr)\n\t{\n\t    generate_ppconst(cctx, ppconst);\n\n\t    if (!op_falsy)\n\t    {\n\t\t// remember the type and drop it\n\t\ttype1 = get_type_on_stack(cctx, 0);\n\t\t--stack->ga_len;\n\n\t\tend_idx = instr->ga_len;\n\t\tgenerate_JUMP(cctx, JUMP_ALWAYS, 0);\n\n\t\t// jump here from JUMP_IF_FALSE\n\t\tisn = ((isn_T *)instr->ga_data) + alt_idx;\n\t\tisn->isn_arg.jump.jump_where = instr->ga_len;\n\t    }\n\t}\n\n\tif (!op_falsy)\n\t{\n\t    // Check for the \":\".\n\t    p = may_peek_next_line(cctx, *arg, &next);\n\t    if (*p != ':')\n\t    {\n\t\temsg(_(e_missing_colon_after_questionmark));\n\t\treturn FAIL;\n\t    }\n\t    if (next != NULL)\n\t    {\n\t\t*arg = next_line_from_context(cctx, TRUE);\n\t\tp = skipwhite(*arg);\n\t    }\n\n\t    if (!IS_WHITE_OR_NUL(**arg) || !IS_WHITE_OR_NUL(p[1]))\n\t    {\n\t\tsemsg(_(e_white_space_required_before_and_after_str_at_str),\n\t\t\t\t\t\t\t\t       \":\", p);\n\t\treturn FAIL;\n\t    }\n\n\t    // evaluate the third expression\n\t    if (has_const_expr)\n\t\tcctx->ctx_skip = save_skip == SKIP_YES || const_value\n\t\t\t\t\t\t\t ? SKIP_YES : SKIP_NOT;\n\t    if (may_get_next_line_error(p + 1, arg, cctx) == FAIL)\n\t\treturn FAIL;\n\t    if (compile_expr1(arg, cctx, ppconst) == FAIL)\n\t\treturn FAIL;\n\t}\n\n\tif (!has_const_expr)\n\t{\n\t    type_T\t**typep;\n\n\t    generate_ppconst(cctx, ppconst);\n\t    ppconst->pp_is_const = FALSE;\n\n\t    // If the types differ, the result has a more generic type.\n\t    typep = &((((type2_T *)stack->ga_data)\n\t\t\t\t\t      + stack->ga_len - 1)->type_curr);\n\t    common_type(type1, *typep, typep, cctx->ctx_type_list);\n\n\t    // jump here from JUMP_ALWAYS or JUMP_AND_KEEP_IF_TRUE\n\t    isn = ((isn_T *)instr->ga_data) + end_idx;\n\t    isn->isn_arg.jump.jump_where = instr->ga_len;\n\t}\n\n\tcctx->ctx_skip = save_skip;\n    }\n    return OK;\n}\n\n/*\n * Toplevel expression.\n * Sets \"is_const\" (if not NULL) to indicate the value is a constant.\n * Returns OK or FAIL.\n */\n    int\ncompile_expr0_ext(char_u **arg,  cctx_T *cctx, int *is_const)\n{\n    ppconst_T\tppconst;\n\n    CLEAR_FIELD(ppconst);\n    if (compile_expr1(arg, cctx, &ppconst) == FAIL)\n    {\n\tclear_ppconst(&ppconst);\n\treturn FAIL;\n    }\n    if (is_const != NULL)\n\t*is_const = ppconst.pp_used > 0 || ppconst.pp_is_const;\n    if (generate_ppconst(cctx, &ppconst) == FAIL)\n\treturn FAIL;\n    return OK;\n}\n\n/*\n * Toplevel expression.\n */\n    int\ncompile_expr0(char_u **arg,  cctx_T *cctx)\n{\n    return compile_expr0_ext(arg, cctx, NULL);\n}\n\n\n#endif // defined(FEAT_EVAL)\n"], "filenames": ["src/testdir/test_vim9_expr.vim", "src/version.c", "src/vim9expr.c"], "buggy_code_start_loc": [2855, 752, 1236], "buggy_code_end_loc": [2855, 752, 1237], "fixing_code_start_loc": [2856, 753, 1236], "fixing_code_end_loc": [2857, 755, 1237], "type": "CWE-122", "message": "vim is vulnerable to Heap-based Buffer Overflow", "other": {"cve": {"id": "CVE-2022-0158", "sourceIdentifier": "security@huntr.dev", "published": "2022-01-10T16:15:09.853", "lastModified": "2022-08-26T17:46:03.853", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "vim is vulnerable to Heap-based Buffer Overflow"}, {"lang": "es", "value": "vim es vulnerable a un Desbordamiento del B\u00fafer en la regi\u00f3n Heap de la Memoria"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:L/I:N/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 3.3, "baseSeverity": "LOW"}, "exploitabilityScore": 1.8, "impactScore": 1.4}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "HIGH", "baseScore": 6.8, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.5, "impactScore": 4.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-122"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:vim:vim:*:*:*:*:*:*:*:*", "versionEndExcluding": "8.2.4049", "matchCriteriaId": "FBB22028-8FAF-4E55-8461-A7AEB58D763D"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:34:*:*:*:*:*:*:*", "matchCriteriaId": "A930E247-0B43-43CB-98FF-6CE7B8189835"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:35:*:*:*:*:*:*:*", "matchCriteriaId": "80E516C0-98A4-4ADE-B69F-66A772E2BAAA"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:apple:macos:*:*:*:*:*:*:*:*", "versionEndExcluding": "12.3", "matchCriteriaId": "9060C1B6-F101-46AE-8B08-6D6951304916"}, {"vulnerable": true, "criteria": "cpe:2.3:o:apple:macos:*:*:*:*:*:*:*:*", "versionStartIncluding": "11.0", "versionEndExcluding": "11.6.8", "matchCriteriaId": "21572D24-45CE-4FF4-8AFD-E13E1FE853B1"}]}]}], "references": [{"url": "http://seclists.org/fulldisclosure/2022/Jul/13", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://seclists.org/fulldisclosure/2022/Mar/29", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2022/01/15/1", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://github.com/vim/vim/commit/5f25c3855071bd7e26255c68bf458b1b5cf92f39", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/ac5d7005-07c6-4a0a-b251-ba9cdbf6738b", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/3FH2J57GDA2WMBS6J56F6QQRA6BXQQFZ/", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/HD5S2FC2HF22A7XQXK2XXIR46EARVWIM/", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202208-32", "source": "security@huntr.dev", "tags": ["Third Party Advisory"]}, {"url": "https://support.apple.com/kb/HT213183", "source": "security@huntr.dev", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://support.apple.com/kb/HT213344", "source": "security@huntr.dev", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/vim/vim/commit/5f25c3855071bd7e26255c68bf458b1b5cf92f39"}}