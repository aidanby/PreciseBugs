{"buggy_code": ["/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2021\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / ISO Media File Format sub-project\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include <gpac/internal/isomedia_dev.h>\n#include <gpac/network.h>\n#include <gpac/thread.h>\n\n#ifndef GPAC_DISABLE_ISOM\n\n/**************************************************************\n\t\tSome Local functions for movie creation\n**************************************************************/\nGF_Err gf_isom_parse_root_box(GF_Box **outBox, GF_BitStream *bs, u32 *boxType, u64 *bytesExpected, Bool progressive_mode);\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\nGF_Err MergeFragment(GF_MovieFragmentBox *moof, GF_ISOFile *mov)\n{\n\tGF_Err e;\n\tu32 i, j;\n\tu64 MaxDur;\n\tGF_TrackFragmentBox *traf;\n\tGF_TrackBox *trak;\n\tu64 base_data_offset;\n\n\tMaxDur = 0;\n\n\t//we shall have a MOOV and its MVEX BEFORE any MOOF\n\tif (!mov->moov || !mov->moov->mvex) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Error: %s not received before merging fragment\\n\", mov->moov ? \"mvex\" : \"moov\" ));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\t//and all fragments should be continous but:\n\t//- dash with dependent representations may likely give R1(moofSN 1, 3, 5, 7) plus R2(moofSN 2, 4, 6, 8)\n\t//- smooth muxed in a single file may end up with V(1),A(1), V(2),A(2) ...\n\t//we do not throw an error if not as we may still want to be able to concatenate dependent representations in DASH and\n\tif (mov->NextMoofNumber && moof->mfhd && (mov->NextMoofNumber >= moof->mfhd->sequence_number)) {\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[iso file] wrong sequence number: got %d but last one was %d\\n\", moof->mfhd->sequence_number, mov->NextMoofNumber));\n\t}\n\n\tbase_data_offset = mov->current_top_box_start;\n\tif (moof->compressed_diff)\n\t\tbase_data_offset -= moof->compressed_diff;\n\n\ti=0;\n\twhile ((traf = (GF_TrackFragmentBox*)gf_list_enum(moof->TrackList, &i))) {\n\t\tif (!traf->tfhd) {\n\t\t\ttrak = NULL;\n\t\t\ttraf->trex = NULL;\n\t\t} else if (mov->is_smooth) {\n\t\t\ttrak = gf_list_get(mov->moov->trackList, 0);\n\t\t\ttraf->trex = (GF_TrackExtendsBox*)gf_list_get(mov->moov->mvex->TrackExList, 0);\n\t\t\tassert(traf->trex);\n\t\t\ttraf->trex->trackID = trak->Header->trackID = traf->tfhd->trackID;\n\t\t} else {\n\t\t\ttrak = gf_isom_get_track_from_id(mov->moov, traf->tfhd->trackID);\n\t\t\tj=0;\n\t\t\twhile ((traf->trex = (GF_TrackExtendsBox*)gf_list_enum(mov->moov->mvex->TrackExList, &j))) {\n\t\t\t\tif (traf->trex->trackID == traf->tfhd->trackID) break;\n\t\t\t\ttraf->trex = NULL;\n\t\t\t}\n\t\t}\n\n\t\tif (!trak || !traf->trex) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Error: Cannot find fragment track with ID %d\\n\", traf->tfhd ? traf->tfhd->trackID : 0));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\n\t\te = MergeTrack(trak, traf, moof, mov->current_top_box_start, moof->compressed_diff, &base_data_offset, !trak->first_traf_merged);\n\t\tif (e) return e;\n\n\t\ttrak->present_in_scalable_segment = 1;\n\n\t\t//update trak duration\n\t\tSetTrackDuration(trak);\n\t\tif (trak->Header->duration > MaxDur)\n\t\t\tMaxDur = trak->Header->duration;\n\n\t\ttrak->first_traf_merged = GF_TRUE;\n\t}\n\n\tif (moof->child_boxes) {\n\t\tGF_Box *a;\n\t\ti = 0;\n\t\twhile ((a = (GF_Box *)gf_list_enum(moof->child_boxes, &i))) {\n\t\t\tif (a->type == GF_ISOM_BOX_TYPE_PSSH) {\n\t\t\t\tGF_ProtectionSystemHeaderBox *pssh = (GF_ProtectionSystemHeaderBox *)gf_isom_box_new_parent(&mov->moov->child_boxes, GF_ISOM_BOX_TYPE_PSSH);\n\t\t\t\tif (!pssh) return GF_OUT_OF_MEM;\n\t\t\t\tmemmove(pssh->SystemID, ((GF_ProtectionSystemHeaderBox *)a)->SystemID, 16);\n\t\t\t\tif (((GF_ProtectionSystemHeaderBox *)a)->KIDs && ((GF_ProtectionSystemHeaderBox *)a)->KID_count > 0) {\n\t\t\t\t\tpssh->KID_count = ((GF_ProtectionSystemHeaderBox *)a)->KID_count;\n\t\t\t\t\tpssh->KIDs = (bin128 *)gf_malloc(pssh->KID_count*sizeof(bin128));\n\t\t\t\t\tif (!pssh->KIDs) return GF_OUT_OF_MEM;\n\n\t\t\t\t\tmemmove(pssh->KIDs, ((GF_ProtectionSystemHeaderBox *)a)->KIDs, pssh->KID_count*sizeof(bin128));\n\t\t\t\t}\n\t\t\t\tpssh->private_data_size = ((GF_ProtectionSystemHeaderBox *)a)->private_data_size;\n\t\t\t\tpssh->private_data = (u8 *)gf_malloc(pssh->private_data_size*sizeof(char));\n\t\t\t\tif (!pssh->private_data) return GF_OUT_OF_MEM;\n\t\t\t\tmemmove(pssh->private_data, ((GF_ProtectionSystemHeaderBox *)a)->private_data, pssh->private_data_size);\n\t\t\t}\n\t\t}\n\t}\n\n\tmov->NextMoofNumber = moof->mfhd ? moof->mfhd->sequence_number : 0;\n\t//update movie duration\n\tif (mov->moov->mvhd->duration < MaxDur) mov->moov->mvhd->duration = MaxDur;\n\treturn GF_OK;\n}\n\nstatic void FixTrackID(GF_ISOFile *mov)\n{\n\tif (!mov->moov) return;\n\n\tif (gf_list_count(mov->moov->trackList) == 1 && gf_list_count(mov->moof->TrackList) == 1) {\n\t\tGF_TrackFragmentBox *traf = (GF_TrackFragmentBox*)gf_list_get(mov->moof->TrackList, 0);\n\t\tGF_TrackBox *trak = (GF_TrackBox*)gf_list_get(mov->moov->trackList, 0);\n\t\tif (!traf->tfhd || !trak->Header) return;\n\t\tif ((traf->tfhd->trackID != trak->Header->trackID)) {\n\t\t\tif (!mov->is_smooth) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Warning: trackID of MOOF/TRAF(%u) is not the same as MOOV/TRAK(%u). Trying to fix.\\n\", traf->tfhd->trackID, trak->Header->trackID));\n\t\t\t} else {\n\t\t\t\ttrak->Header->trackID = traf->tfhd->trackID;\n\t\t\t}\n\t\t\ttraf->tfhd->trackID = trak->Header->trackID;\n\t\t}\n\t}\n}\n\nstatic void FixSDTPInTRAF(GF_MovieFragmentBox *moof)\n{\n\tu32 k;\n\tif (!moof)\n\t\treturn;\n\n\tfor (k = 0; k < gf_list_count(moof->TrackList); k++) {\n\t\tGF_TrackFragmentBox *traf = gf_list_get(moof->TrackList, k);\n\t\tif (traf->sdtp) {\n\t\t\tGF_TrackFragmentRunBox *trun;\n\t\t\tu32 j = 0, sample_index = 0;\n\n\t\t\tif (traf->sdtp->sampleCount == gf_list_count(traf->TrackRuns)) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Warning: TRAF box of track id=%u contains a SDTP. Converting to TRUN sample flags.\\n\", traf->tfhd->trackID));\n\t\t\t}\n\n\t\t\twhile ((trun = (GF_TrackFragmentRunBox*)gf_list_enum(traf->TrackRuns, &j))) {\n\t\t\t\tu32 i;\n\t\t\t\ttrun->flags |= GF_ISOM_TRUN_FLAGS;\n\t\t\t\tfor (i=0; i<trun->nb_samples; i++) {\n\t\t\t\t\tGF_TrunEntry *entry = &trun->samples[i];\n\t\t\t\t\tconst u8 info = traf->sdtp->sample_info[sample_index];\n\t\t\t\t\tentry->flags |= GF_ISOM_GET_FRAG_DEPEND_FLAGS(info >> 6, info >> 4, info >> 2, info);\n\t\t\t\t\tsample_index++;\n\t\t\t\t\tif (sample_index > traf->sdtp->sampleCount) {\n\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Error: TRAF box of track id=%u contained an inconsistent SDTP.\\n\", traf->tfhd->trackID));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (sample_index < traf->sdtp->sampleCount) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Error: TRAF box of track id=%u list less samples than SDTP.\\n\", traf->tfhd->trackID));\n\t\t\t}\n\t\t\tgf_isom_box_del_parent(&traf->child_boxes, (GF_Box*)traf->sdtp);\n\t\t\ttraf->sdtp = NULL;\n\t\t}\n\t}\n}\n\nvoid gf_isom_push_mdat_end(GF_ISOFile *mov, u64 mdat_end)\n{\n\tu32 i, count;\n\tif (!mov || !mov->moov) return;\n\t\n\tcount = gf_list_count(mov->moov->trackList);\n\tfor (i=0; i<count; i++) {\n\t\tu32 j;\n\t\tGF_TrafToSampleMap *traf_map;\n\t\tGF_TrackBox *trak = gf_list_get(mov->moov->trackList, i);\n\t\tif (!trak->Media->information->sampleTable->traf_map) continue;\n\n\t\ttraf_map = trak->Media->information->sampleTable->traf_map;\n\t\tfor (j=traf_map->nb_entries; j>0; j--) {\n\t\t\tif (!traf_map->frag_starts[j-1].mdat_end) {\n\t\t\t\ttraf_map->frag_starts[j-1].mdat_end = mdat_end;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\n#ifdef GF_ENABLE_CTRN\nstatic void gf_isom_setup_traf_inheritance(GF_ISOFile *mov)\n{\n\tu32 i, count;\n\tif (!mov->moov->mvex)\n\t\treturn;\n\tcount = gf_list_count(mov->moov->trackList);\n\n\tfor (i=0; i<count; i++) {\n\t\tu32 refTrackNum=0;\n\t\tgf_isom_get_reference(mov, i+1, GF_ISOM_REF_TRIN, 1, &refTrackNum);\n\t\tif (refTrackNum) {\n\t\t\tGF_ISOTrackID tkid = gf_isom_get_track_id(mov, i+1);\n\t\t\tGF_ISOTrackID reftkid = gf_isom_get_track_id(mov, refTrackNum);\n\t\t\tGF_TrackExtendsBox *trex = GetTrex(mov->moov, tkid);\n\t\t\tif (trex) trex->inherit_from_traf_id = reftkid;\n\t\t}\n\t}\n}\n#endif\n\n#endif\n\n//for now we only use regular sample to group internally (except when dumping), not the pattern version\n//we unrill the pattern and replace the compact version with a regular one\nstatic void convert_compact_sample_groups(GF_List *child_boxes, GF_List *sampleGroups)\n{\n\tu32 i;\n\tfor (i=0; i<gf_list_count(sampleGroups); i++) {\n\t\tu32 j;\n\t\tGF_SampleGroupBox *sbgp;\n\t\tGF_CompactSampleGroupBox *csgp = gf_list_get(sampleGroups, i);\n\t\tif (csgp->type != GF_ISOM_BOX_TYPE_CSGP) continue;\n\n\t\tgf_list_rem(sampleGroups, i);\n\t\tgf_list_del_item(child_boxes, csgp);\n\n\t\tsbgp = (GF_SampleGroupBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_SBGP);\n\t\tgf_list_insert(sampleGroups, sbgp, i);\n\t\tgf_list_add(child_boxes, sbgp);\n\t\ti--;\n\n\t\tsbgp->grouping_type = csgp->grouping_type;\n\t\tif (csgp->grouping_type_parameter) {\n\t\t\tsbgp->grouping_type_parameter = csgp->grouping_type_parameter;\n\t\t\tsbgp->version = 1;\n\t\t}\n\t\tsbgp->entry_count = 0;\n\t\tfor (j=0; j<csgp->pattern_count; j++) {\n\t\t\tu32 k=0;\n\t\t\tu32 nb_samples = csgp->patterns[j].sample_count;\n\t\t\t//unroll the pattern\n\t\t\twhile (nb_samples) {\n\t\t\t\tu32 nb_same_index=1;\n\t\t\t\tu32 sg_idx = csgp->patterns[j].sample_group_description_indices[k];\n\t\t\t\twhile (nb_same_index+k<csgp->patterns[j].length) {\n\t\t\t\t\tif (csgp->patterns[j].sample_group_description_indices[k+nb_same_index] != sg_idx)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tnb_same_index++;\n\t\t\t\t}\n\t\t\t\tsbgp->sample_entries = gf_realloc(sbgp->sample_entries, sizeof(GF_SampleGroupEntry) * (sbgp->entry_count+1));\n\t\t\t\tif (nb_same_index>nb_samples)\n\t\t\t\t\tnb_same_index = nb_samples;\n\n\t\t\t\tsbgp->sample_entries[sbgp->entry_count].sample_count = nb_same_index;\n\t\t\t\tsbgp->sample_entries[sbgp->entry_count].group_description_index = sg_idx;\n\t\t\t\tnb_samples -= nb_same_index;\n\t\t\t\tsbgp->entry_count++;\n\t\t\t\tk+= nb_same_index;\n\t\t\t\tif (k==csgp->patterns[j].length)\n\t\t\t\t\tk = 0;\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nstatic GF_Err gf_isom_parse_movie_boxes_internal(GF_ISOFile *mov, u32 *boxType, u64 *bytesMissing, Bool progressive_mode)\n{\n\tGF_Box *a;\n\tu64 totSize, mdat_end=0;\n\tGF_Err e = GF_OK;\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (mov->single_moof_mode && mov->single_moof_state == 2) {\n\t\treturn e;\n\t}\n\n\t/*restart from where we stopped last*/\n\ttotSize = mov->current_top_box_start;\n\tif (mov->bytes_removed) {\n\t\tassert(totSize >= mov->bytes_removed);\n\t\ttotSize -= mov->bytes_removed;\n\t}\n\tgf_bs_seek(mov->movieFileMap->bs, totSize);\n#endif\n\n\n\t/*while we have some data, parse our boxes*/\n\twhile (gf_bs_available(mov->movieFileMap->bs)) {\n\t\t*bytesMissing = 0;\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\t\tmov->current_top_box_start = gf_bs_get_position(mov->movieFileMap->bs) + mov->bytes_removed;\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[iso file] Parsing a top-level box at position %d\\n\", mov->current_top_box_start));\n#endif\n\n\t\te = gf_isom_parse_root_box(&a, mov->movieFileMap->bs, boxType, bytesMissing, progressive_mode);\n\n\t\tif (e >= 0) {\n\n\t\t} else if (e == GF_ISOM_INCOMPLETE_FILE) {\n\t\t\t/*our mdat is uncomplete, only valid for READ ONLY files...*/\n\t\t\tif (mov->openMode != GF_ISOM_OPEN_READ) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Incomplete MDAT while file is not read-only\\n\"));\n\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\t}\n\t\t\tif ((mov->openMode == GF_ISOM_OPEN_READ) && !progressive_mode) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Incomplete file while reading for dump - aborting parsing\\n\"));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\treturn e;\n\t\t} else {\n\t\t\treturn e;\n\t\t}\n\n\t\tswitch (a->type) {\n\t\t/*MOOV box*/\n\t\tcase GF_ISOM_BOX_TYPE_MOOV:\n\t\t\tif (mov->moov) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Duplicate MOOV detected!\\n\"));\n\t\t\t\tgf_isom_box_del(a);\n\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\t}\n\t\t\tmov->moov = (GF_MovieBox *)a;\n\t\t\tmov->original_moov_offset = mov->current_top_box_start;\n\t\t\t/*set our pointer to the movie*/\n\t\t\tmov->moov->mov = mov;\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\t\tif (mov->moov->mvex) mov->moov->mvex->mov = mov;\n\n#ifdef GF_ENABLE_CTRN\n\t\t\tif (! (mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG)) {\n\t\t\t\tgf_isom_setup_traf_inheritance(mov);\n\t\t\t}\n#endif\n\n#endif\n\t\t\te = gf_list_add(mov->TopBoxes, a);\n\t\t\tif (e) return e;\n\n\t\t\ttotSize += a->size;\n\n            if (!mov->moov->mvhd) {\n                GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing MovieHeaderBox\\n\"));\n                return GF_ISOM_INVALID_FILE;\n            }\n\n            if (mov->meta) {\n\t\t\t\tgf_isom_meta_restore_items_ref(mov, mov->meta);\n\t\t\t}\n\n\t\t\t//dump senc info in dump mode\n\t\t\tif (mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG) {\n\t\t\t\tu32 k;\n\t\t\t\tfor (k=0; k<gf_list_count(mov->moov->trackList); k++) {\n\t\t\t\t\tGF_TrackBox *trak = (GF_TrackBox *)gf_list_get(mov->moov->trackList, k);\n\n\t\t\t\t\tif (trak->sample_encryption) {\n\t\t\t\t\t\te = senc_Parse(mov->movieFileMap->bs, trak, NULL, trak->sample_encryption);\n\t\t\t\t\t\tif (e) return e;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tu32 k;\n\t\t\t\tfor (k=0; k<gf_list_count(mov->moov->trackList); k++) {\n\t\t\t\t\tGF_TrackBox *trak = (GF_TrackBox *)gf_list_get(mov->moov->trackList, k);\n\t\t\t\t\tif (trak->Media->information->sampleTable->sampleGroups) {\n\t\t\t\t\t\tconvert_compact_sample_groups(trak->Media->information->sampleTable->child_boxes, trak->Media->information->sampleTable->sampleGroups);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n            if (mdat_end && mov->signal_frag_bounds && !(mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG) ) {\n                gf_isom_push_mdat_end(mov, mdat_end);\n                mdat_end=0;\n            }\n\t\t\tbreak;\n\n\t\t/*META box*/\n\t\tcase GF_ISOM_BOX_TYPE_META:\n\t\t\tif (mov->meta) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Duplicate META detected!\\n\"));\n\t\t\t\tgf_isom_box_del(a);\n\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\t}\n\t\t\tmov->meta = (GF_MetaBox *)a;\n\t\t\tmov->original_meta_offset = mov->current_top_box_start;\n\t\t\te = gf_list_add(mov->TopBoxes, a);\n\t\t\tif (e) {\n\t\t\t\treturn e;\n\t\t\t}\n\t\t\ttotSize += a->size;\n            if (mov->moov) {\n\t\t\t\tgf_isom_meta_restore_items_ref(mov, mov->meta);\n\t\t\t}\n\t\t\tbreak;\n\n\t\t/*we only keep the MDAT in READ for dump purposes*/\n\t\tcase GF_ISOM_BOX_TYPE_MDAT:\n\t\t\tif (!mov->first_data_toplevel_offset) {\n\t\t\t\tmov->first_data_toplevel_offset = mov->current_top_box_start;\n\t\t\t\tmov->first_data_toplevel_size = a->size;\n\t\t\t}\n\t\t\ttotSize += a->size;\n\t\t\tif (mov->openMode == GF_ISOM_OPEN_READ) {\n\t\t\t\tif (!mov->mdat) {\n\t\t\t\t\tmov->mdat = (GF_MediaDataBox *) a;\n\t\t\t\t\te = gf_list_add(mov->TopBoxes, mov->mdat);\n\t\t\t\t\tif (e) {\n\t\t\t\t\t\treturn e;\n\t\t\t\t\t}\n\t\t\t\t}\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\t\t\t\telse if (mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG) gf_list_add(mov->TopBoxes, a);\n#endif\n\t\t\t\telse gf_isom_box_del(a); //in other modes we don't care\n\n\n\t\t\t\tif (mov->signal_frag_bounds && !(mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG) ) {\n                    mdat_end = gf_bs_get_position(mov->movieFileMap->bs);\n                    if (mov->moov) {\n                        gf_isom_push_mdat_end(mov, mdat_end);\n                        mdat_end=0;\n                    }\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*if we don't have any MDAT yet, create one (edit-write mode)\n\t\t\tWe only work with one mdat, but we're puting it at the place\n\t\t\tof the first mdat found when opening a file for editing*/\n\t\t\telse if (!mov->mdat && (mov->openMode != GF_ISOM_OPEN_READ) && (mov->openMode != GF_ISOM_OPEN_KEEP_FRAGMENTS)) {\n\t\t\t\tgf_isom_box_del(a);\n\t\t\t\tmov->mdat = (GF_MediaDataBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_MDAT);\n\t\t\t\tif (!mov->mdat) return GF_OUT_OF_MEM;\n\t\t\t\te = gf_list_add(mov->TopBoxes, mov->mdat);\n\t\t\t\tif (e) {\n\t\t\t\t\treturn e;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tgf_isom_box_del(a);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_FTYP:\n\t\t\t/*ONE AND ONLY ONE FTYP*/\n\t\t\tif (mov->brand) {\n\t\t\t\tgf_isom_box_del(a);\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Duplicate 'ftyp' detected!\\n\"));\n\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\t}\n\t\t\tmov->brand = (GF_FileTypeBox *)a;\n\t\t\ttotSize += a->size;\n\t\t\te = gf_list_add(mov->TopBoxes, a);\n\t\t\tif (e) return e;\n\t\t\tbreak;\n\n\t\tcase GF_ISOM_BOX_TYPE_OTYP:\n\t\t\t/*ONE AND ONLY ONE FTYP*/\n\t\t\tif (mov->otyp) {\n\t\t\t\tgf_isom_box_del(a);\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Duplicate 'otyp' detected!\\n\"));\n\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\t}\n\n\t\t\tif (mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG) {\n\t\t\t\tmov->otyp = (GF_Box *)a;\n\t\t\t\ttotSize += a->size;\n\t\t\t\te = gf_list_add(mov->TopBoxes, a);\n\t\t\t\tif (e) return e;\n\t\t\t} else {\n\t\t\t\tGF_FileTypeBox *brand = (GF_FileTypeBox *) gf_isom_box_find_child(a->child_boxes, GF_ISOM_BOX_TYPE_FTYP);\n\t\t\t\tif (brand) {\n\t\t\t\t\ts32 pos;\n\t\t\t\t\tgf_list_del_item(a->child_boxes, brand);\n\t\t\t\t\tpos = gf_list_del_item(mov->TopBoxes, mov->brand);\n\t\t\t\t\tgf_isom_box_del((GF_Box *) mov->brand);\n\t\t\t\t\tmov->brand = brand;\n\t\t\t\t\tif (pos<0) pos=0;\n\t\t\t\t\tgf_list_insert(mov->TopBoxes, brand, pos);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase GF_ISOM_BOX_TYPE_PDIN:\n\t\t\t/*ONE AND ONLY ONE PDIN*/\n\t\t\tif (mov->pdin) {\n\t\t\t\tgf_isom_box_del(a);\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Duplicate 'pdin'' detected!\\n\"));\n\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\t}\n\t\t\tmov->pdin = (GF_ProgressiveDownloadBox *) a;\n\t\t\ttotSize += a->size;\n\t\t\te = gf_list_add(mov->TopBoxes, a);\n\t\t\tif (e) return e;\n\t\t\tbreak;\n\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\t\tcase GF_ISOM_BOX_TYPE_STYP:\n\t\t{\n\t\t\tu32 brand = ((GF_FileTypeBox *)a)->majorBrand;\n\t\t\tswitch (brand) {\n\t\t\tcase GF_ISOM_BRAND_SISX:\n\t\t\tcase GF_ISOM_BRAND_RISX:\n\t\t\tcase GF_ISOM_BRAND_SSSS:\n\t\t\t\tmov->is_index_segment = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t/*fall-through*/\n\n\t\tcase GF_ISOM_BOX_TYPE_SIDX:\n\t\tcase GF_ISOM_BOX_TYPE_SSIX:\n\t\t\tif (mov->moov && !mov->first_data_toplevel_offset) {\n\t\t\t\tmov->first_data_toplevel_offset = mov->current_top_box_start;\n\t\t\t\tmov->first_data_toplevel_size = a->size;\n\t\t\t}\n\t\t\ttotSize += a->size;\n\t\t\tif (mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG) {\n\t\t\t\te = gf_list_add(mov->TopBoxes, a);\n\t\t\t\tif (e) return e;\n\t\t\t} else if (mov->signal_frag_bounds && !(mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG)  && (mov->openMode!=GF_ISOM_OPEN_KEEP_FRAGMENTS)\n\t\t\t) {\n\t\t\t\tif (a->type==GF_ISOM_BOX_TYPE_SIDX) {\n\t\t\t\t\tif (mov->root_sidx) gf_isom_box_del( (GF_Box *) mov->root_sidx);\n\t\t\t\t\tmov->root_sidx = (GF_SegmentIndexBox *) a;\n\t\t\t\t\tmov->sidx_start_offset = mov->current_top_box_start;\n\t\t\t\t\tmov->sidx_end_offset = gf_bs_get_position(mov->movieFileMap->bs);\n\n\t\t\t\t}\n\t\t\t\telse if (a->type==GF_ISOM_BOX_TYPE_STYP) {\n\t\t\t\t\tmov->styp_start_offset = mov->current_top_box_start;\n\n\t\t\t\t\tif (mov->seg_styp) gf_isom_box_del(mov->seg_styp);\n\t\t\t\t\tmov->seg_styp = a;\n\t\t\t\t} else if (a->type==GF_ISOM_BOX_TYPE_SSIX) {\n\t\t\t\t\tif (mov->seg_ssix) gf_isom_box_del(mov->seg_ssix);\n\t\t\t\t\tmov->seg_ssix = a;\n\t\t\t\t} else {\n\t\t\t\t\tgf_isom_box_del(a);\n\t\t\t\t}\n\t\t\t\tgf_isom_push_mdat_end(mov, mov->current_top_box_start);\n\t\t\t} else if (!mov->NextMoofNumber && (a->type==GF_ISOM_BOX_TYPE_SIDX)) {\n\t\t\t\tif (mov->main_sidx) gf_isom_box_del( (GF_Box *) mov->main_sidx);\n\t\t\t\tmov->main_sidx = (GF_SegmentIndexBox *) a;\n\t\t\t\tmov->main_sidx_end_pos = mov->current_top_box_start + a->size;\n\t\t\t} else {\n\t\t\t\tgf_isom_box_del(a);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase GF_ISOM_BOX_TYPE_MOOF:\n\t\t\t//no support for inplace rewrite for fragmented files\n\t\t\tgf_isom_disable_inplace_rewrite(mov);\n\t\t\tif (!mov->moov) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Movie fragment but no moov (yet) - possibly broken parsing!\\n\"));\n\t\t\t}\n\t\t\tif (mov->single_moof_mode) {\n\t\t\t\tmov->single_moof_state++;\n\t\t\t\tif (mov->single_moof_state > 1) {\n\t\t\t\t\tgf_isom_box_del(a);\n\t\t\t\t\treturn GF_OK;\n\t\t\t\t}\n\t\t\t}\n\t\t\t((GF_MovieFragmentBox *)a)->mov = mov;\n\n\t\t\ttotSize += a->size;\n\t\t\tmov->moof = (GF_MovieFragmentBox *) a;\n\n\t\t\t/*some smooth streaming streams contain a SDTP under the TRAF: this is incorrect, convert it*/\n\t\t\tFixTrackID(mov);\n\t\t\tif (! (mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG)) {\n\t\t\t\tFixSDTPInTRAF(mov->moof);\n\t\t\t} else {\n\t\t\t\tu32 k;\n\t\t\t\tfor (k=0; k<gf_list_count(mov->moof->TrackList); k++) {\n\t\t\t\t\tGF_TrackFragmentBox *traf = (GF_TrackFragmentBox *)gf_list_get(mov->moof->TrackList, k);\n\t\t\t\t\tif (traf->sampleGroups) {\n\t\t\t\t\t\tconvert_compact_sample_groups(traf->child_boxes, traf->sampleGroups);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*read & debug: store at root level*/\n\t\t\tif (mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG) {\n\t\t\t\tu32 k;\n\t\t\t\tgf_list_add(mov->TopBoxes, a);\n\t\t\t\t/*also update pointers to trex for debug*/\n\t\t\t\tif (mov->moov) {\n\t\t\t\t\tfor (k=0; k<gf_list_count(mov->moof->TrackList); k++) {\n\t\t\t\t\t\tGF_TrackFragmentBox *traf = gf_list_get(mov->moof->TrackList, k);\n\t\t\t\t\t\tif (traf->tfhd && mov->moov->mvex && mov->moov->mvex->TrackExList) {\n\t\t\t\t\t\t\tGF_TrackBox *trak = gf_isom_get_track_from_id(mov->moov, traf->tfhd->trackID);\n\t\t\t\t\t\t\tu32 j=0;\n\t\t\t\t\t\t\twhile ((traf->trex = (GF_TrackExtendsBox*)gf_list_enum(mov->moov->mvex->TrackExList, &j))) {\n\t\t\t\t\t\t\t\tif (traf->trex->trackID == traf->tfhd->trackID) {\n\t\t\t\t\t\t\t\t\tif (!traf->trex->track) traf->trex->track = trak;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\ttraf->trex = NULL;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//we should only parse senc/psec when no saiz/saio is present, otherwise we fetch the info directly\n\t\t\t\t\t\tif (traf->trex && traf->tfhd && traf->trex->track && traf->sample_encryption) {\n\t\t\t\t\t\t\tGF_TrackBox *trak = GetTrackbyID(mov->moov, traf->tfhd->trackID);\n\t\t\t\t\t\t\ttrak->current_traf_stsd_idx = traf->tfhd->sample_desc_index ? traf->tfhd->sample_desc_index : traf->trex->def_sample_desc_index;\n\t\t\t\t\t\t\te = senc_Parse(mov->movieFileMap->bs, trak, traf, traf->sample_encryption);\n\t\t\t\t\t\t\tif (e) return e;\n\t\t\t\t\t\t\ttrak->current_traf_stsd_idx = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor (k=0; k<gf_list_count(mov->moof->TrackList); k++) {\n\t\t\t\t\t\tGF_TrackFragmentBox *traf = gf_list_get(mov->moof->TrackList, k);\n\t\t\t\t\t\tif (traf->sample_encryption) {\n\t\t\t\t\t\t\te = senc_Parse(mov->movieFileMap->bs, NULL, traf, traf->sample_encryption);\n\t\t\t\t\t\t\tif (e) return e;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t} else if (mov->openMode==GF_ISOM_OPEN_KEEP_FRAGMENTS) {\n\t\t\t\tmov->NextMoofNumber = mov->moof->mfhd->sequence_number+1;\n\t\t\t\tmov->moof = NULL;\n\t\t\t\tgf_isom_box_del(a);\n\t\t\t} else {\n\t\t\t\t/*merge all info*/\n\t\t\t\te = MergeFragment((GF_MovieFragmentBox *)a, mov);\n\t\t\t\tgf_isom_box_del(a);\n\t\t\t\tif (e) return e;\n\t\t\t}\n\n\t\t\t//done with moov\n\t\t\tif (mov->root_sidx) {\n\t\t\t\tgf_isom_box_del((GF_Box *) mov->root_sidx);\n\t\t\t\tmov->root_sidx = NULL;\n\t\t\t}\n\t\t\tif (mov->root_ssix) {\n\t\t\t\tgf_isom_box_del(mov->seg_ssix);\n\t\t\t\tmov->root_ssix = NULL;\n\t\t\t}\n\t\t\tif (mov->seg_styp) {\n\t\t\t\tgf_isom_box_del(mov->seg_styp);\n\t\t\t\tmov->seg_styp = NULL;\n\t\t\t}\n\t\t\tmov->sidx_start_offset = 0;\n\t\t\tmov->sidx_end_offset = 0;\n\t\t\tmov->styp_start_offset = 0;\n\t\t\tbreak;\n#endif\n\t\tcase GF_ISOM_BOX_TYPE_UNKNOWN:\n\t\t{\n\t\t\tGF_UnknownBox *box = (GF_UnknownBox*)a;\n\t\t\tif (box->original_4cc == GF_ISOM_BOX_TYPE_JP) {\n\t\t\t\tu8 *c = (u8 *) box->data;\n\t\t\t\tif ((box->dataSize==4) && (GF_4CC(c[0],c[1],c[2],c[3])==(u32)0x0D0A870A))\n\t\t\t\t\tmov->is_jp2 = 1;\n\t\t\t\tgf_isom_box_del(a);\n\t\t\t} else {\n\t\t\t\te = gf_list_add(mov->TopBoxes, a);\n\t\t\t\tif (e) return e;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase GF_ISOM_BOX_TYPE_PRFT:\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\t\tif (!(mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG)) {\n\t\t\t\t//keep the last one read\n\t\t\t\tif (mov->last_producer_ref_time)\n\t\t\t\t\tgf_isom_box_del(a);\n\t\t\t\telse\n\t\t\t\t\tmov->last_producer_ref_time = (GF_ProducerReferenceTimeBox *)a;\n\t\t\t\tbreak;\n\t\t\t}\n#endif\n\t\t//fallthrough\n\n\t\tdefault:\n\t\t\ttotSize += a->size;\n\t\t\te = gf_list_add(mov->TopBoxes, a);\n\t\t\tif (e) return e;\n\t\t\tbreak;\n\t\t}\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\t\t/*remember where we left, in case we append an entire number of movie fragments*/\n\t\tmov->current_top_box_start = gf_bs_get_position(mov->movieFileMap->bs) + mov->bytes_removed;\n#endif\n\t}\n\n\t/*we need at least moov or meta*/\n\tif (!mov->moov && !mov->meta\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t        && !mov->moof && !mov->is_index_segment\n#endif\n\t   ) {\n\t\treturn GF_ISOM_INCOMPLETE_FILE;\n\t}\n\t/*we MUST have movie header*/\n\tif (!gf_opts_get_bool(\"core\", \"no-check\")) {\n\t\tif (mov->moov && !mov->moov->mvhd) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing MVHD in MOOV!\\n\"));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\n\t\t/*we MUST have meta handler*/\n\t\tif (mov->meta && !mov->meta->handler) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing handler in META!\\n\"));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n\tif (mov->moov) {\n\t\t/*set the default interleaving time*/\n\t\tmov->interleavingTime = mov->moov->mvhd->timeScale;\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\t\t/*in edit mode with successfully loaded fragments, delete all fragment signaling since\n\t\tfile is no longer fragmented*/\n\t\tif ((mov->openMode > GF_ISOM_OPEN_READ) && (mov->openMode != GF_ISOM_OPEN_KEEP_FRAGMENTS) && mov->moov->mvex) {\n\t\t\tgf_isom_box_del_parent(&mov->moov->child_boxes, (GF_Box *)mov->moov->mvex);\n\t\t\tmov->moov->mvex = NULL;\n\t\t}\n#endif\n\n\t}\n\n\t//create a default mdat if none was found\n\tif (!mov->mdat && (mov->openMode != GF_ISOM_OPEN_READ) && (mov->openMode != GF_ISOM_OPEN_KEEP_FRAGMENTS)) {\n\t\tmov->mdat = (GF_MediaDataBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_MDAT);\n\t\tif (!mov->mdat) return GF_OUT_OF_MEM;\n\t\te = gf_list_add(mov->TopBoxes, mov->mdat);\n\t\tif (e) return e;\n\t}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\treturn GF_OK;\n}\n\nGF_Err gf_isom_parse_movie_boxes(GF_ISOFile *mov, u32 *boxType, u64 *bytesMissing, Bool progressive_mode)\n{\n\tGF_Err e;\n\tGF_Blob *blob = NULL;\n\n\t//if associated file is a blob, lock blob before parsing !\n\tif (mov->movieFileMap && ((mov->movieFileMap->type == GF_ISOM_DATA_MEM) || (mov->movieFileMap->type == GF_ISOM_DATA_FILE))) {\n\t\tblob = ((GF_FileDataMap *)mov->movieFileMap)->blob;\n\t}\n\n\tif (blob)\n\t\tgf_mx_p(blob->mx);\n\n\te = gf_isom_parse_movie_boxes_internal(mov, boxType, bytesMissing, progressive_mode);\n\n\tif (blob)\n\t\tgf_mx_v(blob->mx);\n\treturn e;\n\n}\n\nGF_ISOFile *gf_isom_new_movie()\n{\n\tGF_ISOFile *mov = (GF_ISOFile*)gf_malloc(sizeof(GF_ISOFile));\n\tif (mov == NULL) {\n\t\tgf_isom_set_last_error(NULL, GF_OUT_OF_MEM);\n\t\treturn NULL;\n\t}\n\tmemset(mov, 0, sizeof(GF_ISOFile));\n\n\t/*init the boxes*/\n\tmov->TopBoxes = gf_list_new();\n\tif (!mov->TopBoxes) {\n\t\tgf_isom_set_last_error(NULL, GF_OUT_OF_MEM);\n\t\tgf_free(mov);\n\t\treturn NULL;\n\t}\n\n\t/*default storage mode is flat*/\n\tmov->storageMode = GF_ISOM_STORE_FLAT;\n\tmov->es_id_default_sync = -1;\n\treturn mov;\n}\n\n//Create and parse the movie for READ - EDIT only\nGF_ISOFile *gf_isom_open_file(const char *fileName, GF_ISOOpenMode OpenMode, const char *tmp_dir)\n{\n\tGF_Err e;\n\tu64 bytes;\n\tGF_ISOFile *mov = gf_isom_new_movie();\n\tif (!mov || !fileName) return NULL;\n\n\tmov->fileName = gf_strdup(fileName);\n\tmov->openMode = OpenMode;\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (OpenMode==GF_ISOM_OPEN_READ_DUMP)\n\t\tmov->store_traf_map = GF_TRUE;\n#endif\n\n\tif ( (OpenMode == GF_ISOM_OPEN_READ) || (OpenMode == GF_ISOM_OPEN_READ_DUMP) || (OpenMode == GF_ISOM_OPEN_READ_EDIT) ) {\n\t\tif (OpenMode == GF_ISOM_OPEN_READ_EDIT) {\n\t\t\tmov->openMode = GF_ISOM_OPEN_READ_EDIT;\n\n\t\t\t// create a memory edit map in case we add samples, typically during import\n\t\t\te = gf_isom_datamap_new(NULL, tmp_dir, GF_ISOM_DATA_MAP_WRITE, & mov->editFileMap);\n\t\t\tif (e) {\n\t\t\t\tgf_isom_set_last_error(NULL, e);\n\t\t\t\tgf_isom_delete_movie(mov);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t} else {\n\t\t\tmov->openMode = GF_ISOM_OPEN_READ;\n\t\t}\n\t\tmov->es_id_default_sync = -1;\n\t\t//for open, we do it the regular way and let the GF_DataMap assign the appropriate struct\n\t\t//this can be FILE (the only one supported...) as well as remote\n\t\t//(HTTP, ...),not suported yet\n\t\t//the bitstream IS PART OF the GF_DataMap\n\t\t//as this is read-only, use a FileMapping. this is the only place where\n\t\t//we use file mapping\n\t\te = gf_isom_datamap_new(fileName, NULL, GF_ISOM_DATA_MAP_READ_ONLY, &mov->movieFileMap);\n\t\tif (e) {\n\t\t\tgf_isom_set_last_error(NULL, e);\n\t\t\tgf_isom_delete_movie(mov);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (OpenMode == GF_ISOM_OPEN_READ_DUMP) {\n\t\t\tmov->FragmentsFlags |= GF_ISOM_FRAG_READ_DEBUG;\n\t\t}\n\t} else {\n\n#ifdef GPAC_DISABLE_ISOM_WRITE\n\t\t//not allowed for READ_ONLY lib\n\t\tgf_isom_delete_movie(mov);\n\t\tgf_isom_set_last_error(NULL, GF_ISOM_INVALID_MODE);\n\t\treturn NULL;\n\n#else\n\n\t\t//set a default output name for edited file\n\t\tmov->finalName = (char*)gf_malloc(strlen(fileName) + 5);\n\t\tif (!mov->finalName) {\n\t\t\tgf_isom_set_last_error(NULL, GF_OUT_OF_MEM);\n\t\t\tgf_isom_delete_movie(mov);\n\t\t\treturn NULL;\n\t\t}\n\t\tstrcpy(mov->finalName, \"out_\");\n\t\tstrcat(mov->finalName, fileName);\n\n\t\t//open the original file with edit tag\n\t\te = gf_isom_datamap_new(fileName, NULL, GF_ISOM_DATA_MAP_EDIT, &mov->movieFileMap);\n\t\t//if the file doesn't exist, we assume it's wanted and create one from scratch\n\t\tif (e) {\n\t\t\tgf_isom_set_last_error(NULL, e);\n\t\t\tgf_isom_delete_movie(mov);\n\t\t\treturn NULL;\n\t\t}\n\t\t//and create a temp fileName for the edit\n\t\te = gf_isom_datamap_new(\"_gpac_isobmff_tmp_edit\", tmp_dir, GF_ISOM_DATA_MAP_WRITE, & mov->editFileMap);\n\t\tif (e) {\n\t\t\tgf_isom_set_last_error(NULL, e);\n\t\t\tgf_isom_delete_movie(mov);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tmov->es_id_default_sync = -1;\n\n#endif\n\t}\n\n\t//OK, let's parse the movie...\n\tmov->LastError = gf_isom_parse_movie_boxes(mov, NULL, &bytes, 0);\n\n#if 0\n\tif (!mov->LastError && (OpenMode == GF_ISOM_OPEN_CAT_FRAGMENTS)) {\n\t\tgf_isom_datamap_del(mov->movieFileMap);\n\t\t/*reopen the movie file map in cat mode*/\n\t\tmov->LastError = gf_isom_datamap_new(fileName, tmp_dir, GF_ISOM_DATA_MAP_CAT, & mov->movieFileMap);\n\t}\n#endif\n\n\tif (mov->LastError) {\n\t\tgf_isom_set_last_error(NULL, mov->LastError);\n\t\tgf_isom_delete_movie(mov);\n\t\treturn NULL;\n\t}\n\n\tmov->nb_box_init_seg = gf_list_count(mov->TopBoxes);\n\treturn mov;\n}\n\nGF_Err gf_isom_set_write_callback(GF_ISOFile *mov,\n \t\t\tGF_Err (*on_block_out)(void *cbk, u8 *data, u32 block_size),\n\t\t\tGF_Err (*on_block_patch)(void *usr_data, u8 *block, u32 block_size, u64 block_offset, Bool is_insert),\n \t\t\tvoid *usr_data,\n \t\t\tu32 block_size)\n{\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\tif (mov->finalName && !strcmp(mov->finalName, \"_gpac_isobmff_redirect\")) {}\n\telse if (mov->fileName && !strcmp(mov->fileName, \"_gpac_isobmff_redirect\")) {}\n\telse return GF_BAD_PARAM;\n\tmov->on_block_out = on_block_out;\n\tmov->on_block_patch = on_block_patch;\n\tmov->on_block_out_usr_data = usr_data;\n\tmov->on_block_out_block_size = block_size;\n\treturn GF_OK;\n#else\n\treturn GF_NOT_SUPPORTED;\n#endif\n}\n\n\nu64 gf_isom_get_mp4time()\n{\n\tu32 calctime, msec;\n\tu64 ret;\n\tgf_utc_time_since_1970(&calctime, &msec);\n\tcalctime += GF_ISOM_MAC_TIME_OFFSET;\n\tret = calctime;\n\treturn ret;\n}\n\nvoid gf_isom_delete_movie(GF_ISOFile *mov)\n{\n\tif (!mov) return;\n\n\t//these are our two main files\n\tif (mov->movieFileMap) gf_isom_datamap_del(mov->movieFileMap);\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\tif (mov->editFileMap) {\n\t\tgf_isom_datamap_del(mov->editFileMap);\n\t}\n\tif (mov->finalName) gf_free(mov->finalName);\n#endif\n\n\tgf_isom_box_array_del(mov->TopBoxes);\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tgf_isom_box_array_del(mov->moof_list);\n\tif (mov->mfra)\n\t\tgf_isom_box_del((GF_Box*)mov->mfra);\n\tif (mov->sidx_pts_store)\n\t\tgf_free(mov->sidx_pts_store);\n\tif (mov->sidx_pts_next_store)\n\t\tgf_free(mov->sidx_pts_next_store);\n\n\tif (mov->main_sidx)\n\t\tgf_isom_box_del((GF_Box*)mov->main_sidx);\n\n\tif (mov->block_buffer)\n\t\tgf_free(mov->block_buffer);\n#endif\n\tif (mov->last_producer_ref_time)\n\t\tgf_isom_box_del((GF_Box *) mov->last_producer_ref_time);\n\tif (mov->fileName) gf_free(mov->fileName);\n\tgf_free(mov);\n}\n\nGF_TrackBox *gf_isom_get_track_from_id(GF_MovieBox *moov, GF_ISOTrackID trackID)\n{\n\tu32 i, count;\n\tif (!moov || !trackID) return NULL;\n\n\tcount = gf_list_count(moov->trackList);\n\tfor (i = 0; i<count; i++) {\n\t\tGF_TrackBox *trak = (GF_TrackBox*)gf_list_get(moov->trackList, i);\n\t\tif (trak->Header->trackID == trackID) return trak;\n\t}\n\treturn NULL;\n}\n\nGF_TrackBox *gf_isom_get_track_from_original_id(GF_MovieBox *moov, u32 originalID, u32 originalFile)\n{\n\tu32 i, count;\n\tif (!moov || !originalID) return NULL;\n\n\tcount = gf_list_count(moov->trackList);\n\tfor (i = 0; i<count; i++) {\n\t\tGF_TrackBox *trak = (GF_TrackBox*)gf_list_get(moov->trackList, i);\n\t\tif ((trak->originalFile == originalFile) && (trak->originalID == originalID)) return trak;\n\t}\n\treturn NULL;\n}\n\nGF_TrackBox *gf_isom_get_track_from_file(GF_ISOFile *movie, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\tif (!movie) return NULL;\n\ttrak = gf_isom_get_track(movie->moov, trackNumber);\n\tif (!trak) movie->LastError = GF_BAD_PARAM;\n\treturn trak;\n}\n\n\n//WARNING: MOVIETIME IS EXPRESSED IN MEDIA TS\nGF_Err GetMediaTime(GF_TrackBox *trak, Bool force_non_empty, u64 movieTime, u64 *MediaTime, s64 *SegmentStartTime, s64 *MediaOffset, u8 *useEdit, u64 *next_edit_start_plus_one)\n{\n#if 0\n\tGF_Err e;\n\tu32 sampleNumber, prevSampleNumber;\n\tu64 firstDTS;\n#endif\n\tu32 i, count;\n\tBool last_is_empty = 0;\n\tu64 time, lastSampleTime;\n\ts64 mtime;\n\tGF_EdtsEntry *ent;\n\tDouble scale_ts;\n\tGF_SampleTableBox *stbl = trak->Media->information->sampleTable;\n\n\tif (next_edit_start_plus_one) *next_edit_start_plus_one = 0;\n\t*useEdit = 1;\n\t*MediaTime = 0;\n\t//no segment yet...\n\t*SegmentStartTime = -1;\n\t*MediaOffset = -1;\n\tif (!trak->moov->mvhd->timeScale || !trak->Media->mediaHeader->timeScale || !stbl->SampleSize) {\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\t//no samples...\n\tif (!stbl->SampleSize->sampleCount) {\n\t\tlastSampleTime = 0;\n\t} else {\n\t\tlastSampleTime = trak->Media->mediaHeader->duration;\n\t}\n\n\t//No edits, 1 to 1 mapping\n\tif (! trak->editBox || !trak->editBox->editList) {\n\t\t*MediaTime = movieTime;\n\t\t//check this is in our media time line\n\t\tif ((*MediaTime > lastSampleTime)\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\t        && !trak->moov->mov->moof\n#endif\n\t\t   ) {\n\t\t\t*MediaTime = lastSampleTime;\n\t\t}\n\t\t*useEdit = 0;\n\t\treturn GF_OK;\n\t}\n\t//browse the edit list and get the time\n\tscale_ts = trak->Media->mediaHeader->timeScale;\n\tscale_ts /= trak->moov->mvhd->timeScale;\n\n\ttime = 0;\n\tent = NULL;\n\tcount=gf_list_count(trak->editBox->editList->entryList);\n\tfor (i=0; i<count; i++) {\n\t\tent = (GF_EdtsEntry *)gf_list_get(trak->editBox->editList->entryList, i);\n\t\tif ( (time + ent->segmentDuration) * scale_ts > movieTime) {\n\t\t\tif (!force_non_empty || (ent->mediaTime >= 0)) {\n\t\t\t\tif (next_edit_start_plus_one) *next_edit_start_plus_one = 1 + (u64) ((time + ent->segmentDuration) * scale_ts);\n\t\t\t\tgoto ent_found;\n\t\t\t}\n\t\t}\n\t\ttime += ent->segmentDuration;\n\t\tlast_is_empty = ent->segmentDuration ? 0 : 1;\n\t}\n\n\tif (last_is_empty) {\n\t\tent = (GF_EdtsEntry *)gf_list_last(trak->editBox->editList->entryList);\n\t\tif (ent->mediaRate == 0x10000) {\n\t\t\t*MediaTime = movieTime + ent->mediaTime;\n\t\t} else {\n\t\t\tent = (GF_EdtsEntry *)gf_list_get(trak->editBox->editList->entryList, 0);\n\t\t\tif (ent->mediaRate == -0x10000) {\n\t\t\t\tu64 dur = (u64) (ent->segmentDuration * scale_ts);\n\t\t\t\t*MediaTime = (movieTime > dur) ? (movieTime-dur) : 0;\n\t\t\t}\n\t\t}\n\t\t*useEdit = 0;\n\t\treturn GF_OK;\n\t}\n\n\n\t//we had nothing in the list (strange file but compliant...)\n\t//return the 1 to 1 mapped vale of the last media sample\n\tif (!ent) {\n\t\t*MediaTime = movieTime;\n\t\t//check this is in our media time line\n\t\tif (*MediaTime > lastSampleTime) *MediaTime = lastSampleTime;\n\t\t*useEdit = 0;\n\t\treturn GF_OK;\n\t}\n\t//request for a bigger time that what we can give: return the last sample (undefined behavior...)\n\t*MediaTime = lastSampleTime;\n\treturn GF_OK;\n\nent_found:\n\t//OK, we found our entry, set the SegmentTime\n\t*SegmentStartTime = time;\n\n\t//we request an empty list, there's no media here...\n\tif (ent->mediaTime < 0) {\n\t\t*MediaTime = 0;\n\t\treturn GF_OK;\n\t}\n\t//we request a dwell edit\n\tif (! ent->mediaRate) {\n\t\t*MediaTime = ent->mediaTime;\n\t\t//no media offset\n\t\t*MediaOffset = 0;\n\t\t*useEdit = 2;\n\t\treturn GF_OK;\n\t}\n\n\t/*WARNING: this can be \"-1\" when doing searchForward mode (to prevent jumping to next entry)*/\n\tmtime = ent->mediaTime + movieTime - (time * trak->Media->mediaHeader->timeScale / trak->moov->mvhd->timeScale);\n\tif (mtime<0) mtime = 0;\n\t*MediaTime = (u64) mtime;\n\t*MediaOffset = ent->mediaTime;\n\n#if 0\n\t//\n\t//Sanity check: is the requested time valid ? This is to cope with wrong EditLists\n\t//we have the translated time, but we need to make sure we have a sample at this time ...\n\t//we have to find a COMPOSITION time\n\te = stbl_findEntryForTime(stbl, (u32) *MediaTime, 1, &sampleNumber, &prevSampleNumber);\n\tif (e) return e;\n\n\t//first case: our time is after the last sample DTS (it's a broken editList somehow)\n\t//set the media time to the last sample\n\tif (!sampleNumber && !prevSampleNumber) {\n\t\t*MediaTime = lastSampleTime;\n\t\treturn GF_OK;\n\t}\n\t//get the appropriated sample\n\tif (!sampleNumber) sampleNumber = prevSampleNumber;\n\n\tstbl_GetSampleDTS(stbl->TimeToSample, sampleNumber, &DTS);\n\tCTS = 0;\n\tif (stbl->CompositionOffset) stbl_GetSampleCTS(stbl->CompositionOffset, sampleNumber, &CTS);\n\n\t//now get the entry sample (the entry time gives the CTS, and we need the DTS\n\te = stbl_findEntryForTime(stbl, (u32) ent->mediaTime, 0, &sampleNumber, &prevSampleNumber);\n\tif (e) return e;\n\n\t//oops, the mediaTime indicates a sample that is not in our media !\n\tif (!sampleNumber && !prevSampleNumber) {\n\t\t*MediaTime = lastSampleTime;\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\tif (!sampleNumber) sampleNumber = prevSampleNumber;\n\n\tstbl_GetSampleDTS(stbl->TimeToSample, sampleNumber, &firstDTS);\n\n\t//and store the \"time offset\" of the desired sample in this segment\n\t//this is weird, used to rebuild the timeStamp when reading from the track, not the\n\t//media ...\n\t*MediaOffset = firstDTS;\n#endif\n\treturn GF_OK;\n}\n\nGF_Err GetNextMediaTime(GF_TrackBox *trak, u64 movieTime, u64 *OutMovieTime)\n{\n\tu32 i;\n\tu64 time;\n\tGF_EdtsEntry *ent;\n\n\t*OutMovieTime = 0;\n\tif (! trak->editBox || !trak->editBox->editList) return GF_BAD_PARAM;\n\n\ttime = 0;\n\tent = NULL;\n\ti=0;\n\twhile ((ent = (GF_EdtsEntry *)gf_list_enum(trak->editBox->editList->entryList, &i))) {\n\t\tif (time * trak->Media->mediaHeader->timeScale >= movieTime * trak->moov->mvhd->timeScale) {\n\t\t\t/*skip empty edits*/\n\t\t\tif (ent->mediaTime >= 0) {\n\t\t\t\t*OutMovieTime = time * trak->Media->mediaHeader->timeScale / trak->moov->mvhd->timeScale;\n\t\t\t\tif (*OutMovieTime>0) *OutMovieTime -= 1;\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t}\n\t\ttime += ent->segmentDuration;\n\t}\n\t//request for a bigger time that what we can give: return the last sample (undefined behavior...)\n\t*OutMovieTime = trak->moov->mvhd->duration;\n\treturn GF_EOS;\n}\n\nGF_Err GetPrevMediaTime(GF_TrackBox *trak, u64 movieTime, u64 *OutMovieTime)\n{\n\tu32 i;\n\tu64 time;\n\tGF_EdtsEntry *ent;\n\n\t*OutMovieTime = 0;\n\tif (! trak->editBox || !trak->editBox->editList) return GF_BAD_PARAM;\n\n\ttime = 0;\n\tent = NULL;\n\ti=0;\n\twhile ((ent = (GF_EdtsEntry *)gf_list_enum(trak->editBox->editList->entryList, &i))) {\n\t\tif (ent->mediaTime == -1) {\n\t\t\tif ( (time + ent->segmentDuration) * trak->Media->mediaHeader->timeScale >= movieTime * trak->moov->mvhd->timeScale) {\n\t\t\t\t*OutMovieTime = time * trak->Media->mediaHeader->timeScale / trak->moov->mvhd->timeScale;\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\t/*get the first entry whose end is greater than or equal to the desired time*/\n\t\ttime += ent->segmentDuration;\n\t\tif ( time * trak->Media->mediaHeader->timeScale >= movieTime * trak->moov->mvhd->timeScale) {\n\t\t\t*OutMovieTime = time * trak->Media->mediaHeader->timeScale / trak->moov->mvhd->timeScale;\n\t\t\treturn GF_OK;\n\t\t}\n\t}\n\t*OutMovieTime = 0;\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err gf_isom_insert_moov(GF_ISOFile *file)\n{\n\tGF_MovieHeaderBox *mvhd;\n\tif (file->moov) return GF_OK;\n\n\t//OK, create our boxes (mvhd, iods, ...)\n\tfile->moov = (GF_MovieBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_MOOV);\n\tif (!file->moov) return GF_OUT_OF_MEM;\n\tfile->moov->mov = file;\n\t//Header SetUp\n\tmvhd = (GF_MovieHeaderBox *) gf_isom_box_new_parent(&file->moov->child_boxes, GF_ISOM_BOX_TYPE_MVHD);\n\tif (!mvhd) return GF_OUT_OF_MEM;\n\n\tif (gf_sys_is_test_mode() ) {\n\t\tmvhd->creationTime = mvhd->modificationTime = 0;\n\t} else {\n\t\tu64 now = gf_isom_get_mp4time();\n\t\tmvhd->creationTime = now;\n\t\tif (!file->keep_utc)\n\t\t\tmvhd->modificationTime = now;\n\t}\n\n\tmvhd->nextTrackID = 1;\n\t//600 is our default movie TimeScale\n\tmvhd->timeScale = 600;\n\n\tfile->interleavingTime = mvhd->timeScale;\n\tmoov_on_child_box((GF_Box*)file->moov, (GF_Box *)mvhd, GF_FALSE);\n\tgf_list_add(file->TopBoxes, file->moov);\n\treturn GF_OK;\n}\n\n//Create the movie for WRITE only\nGF_ISOFile *gf_isom_create_movie(const char *fileName, GF_ISOOpenMode OpenMode, const char *tmp_dir)\n{\n\tGF_Err e;\n\n\tGF_ISOFile *mov = gf_isom_new_movie();\n\tif (!mov) return NULL;\n\tmov->openMode = OpenMode;\n\t//then set up our movie\n\n\t//in WRITE, the input dataMap is ALWAYS NULL\n\tmov->movieFileMap = NULL;\n\n\t//but we have the edit one\n\tif (OpenMode == GF_ISOM_OPEN_WRITE) {\n\t\tconst char *ext;\n\t\t//THIS IS NOT A TEMP FILE, WRITE mode is used for \"live capture\"\n\t\t//this file will be the final file...\n\t\tmov->fileName = fileName ? gf_strdup(fileName) : NULL;\n\t\te = gf_isom_datamap_new(fileName, NULL, GF_ISOM_DATA_MAP_WRITE, &mov->editFileMap);\n\t\tif (e) goto err_exit;\n\n\t\t/*brand is set to ISOM or QT by default - it may be touched until sample data is added to track*/\n\t\text = gf_file_ext_start(fileName);\n\t\tif (ext && (!strnicmp(ext, \".mov\", 4) || !strnicmp(ext, \".qt\", 3))) {\n\t\t\tgf_isom_set_brand_info((GF_ISOFile *) mov, GF_ISOM_BRAND_QT, 512);\n\t\t} else {\n\t\t\tgf_isom_set_brand_info((GF_ISOFile *) mov, GF_ISOM_BRAND_ISOM, 1);\n\t\t}\n\t} else {\n\t\t//we are in EDIT mode but we are creating the file -> temp file\n\t\tmov->finalName = fileName ? gf_strdup(fileName) : NULL;\n\t\te = gf_isom_datamap_new(\"_gpac_isobmff_tmp_edit\", tmp_dir, GF_ISOM_DATA_MAP_WRITE, &mov->editFileMap);\n\t\tif (e) {\n\t\t\tgf_isom_set_last_error(NULL, e);\n\t\t\tgf_isom_delete_movie(mov);\n\t\t\treturn NULL;\n\t\t}\n\t\t//brand is set to ISOM by default\n\t\tgf_isom_set_brand_info( (GF_ISOFile *) mov, GF_ISOM_BRAND_ISOM, 1);\n\t}\n\n\t//create an MDAT\n\tmov->mdat = (GF_MediaDataBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_MDAT);\n\tif (!mov->mdat) {\n\t\tgf_isom_set_last_error(NULL, GF_OUT_OF_MEM);\n\t\tgf_isom_delete_movie(mov);\n\t\treturn NULL;\n\t}\n\tgf_list_add(mov->TopBoxes, mov->mdat);\n\n\t//default behavior is capture mode, no interleaving (eg, no rewrite of mdat)\n\tmov->storageMode = GF_ISOM_STORE_FLAT;\n\treturn mov;\n\nerr_exit:\n\tgf_isom_set_last_error(NULL, e);\n\tif (mov) gf_isom_delete_movie(mov);\n\treturn NULL;\n}\n\nGF_EdtsEntry *CreateEditEntry(u64 EditDuration, u64 MediaTime, u8 EditMode)\n{\n\tGF_EdtsEntry *ent;\n\n\tent = (GF_EdtsEntry*)gf_malloc(sizeof(GF_EdtsEntry));\n\tif (!ent) return NULL;\n\n\tswitch (EditMode) {\n\tcase GF_ISOM_EDIT_EMPTY:\n\t\tent->mediaRate = 0x10000;\n\t\tent->mediaTime = -1;\n\t\tbreak;\n\n\tcase GF_ISOM_EDIT_DWELL:\n\t\tent->mediaRate = 0;\n\t\tent->mediaTime = MediaTime;\n\t\tbreak;\n\tdefault:\n\t\tent->mediaRate = 0x10000;\n\t\tent->mediaTime = MediaTime;\n\t\tbreak;\n\t}\n\tent->segmentDuration = EditDuration;\n\treturn ent;\n}\n\nGF_Err gf_isom_add_subsample_info(GF_SubSampleInformationBox *sub_samples, u32 sampleNumber, u32 subSampleSize, u8 priority, u32 reserved, Bool discardable)\n{\n\tu32 i, count, last_sample;\n\tGF_SubSampleInfoEntry *pSamp;\n\tGF_SubSampleEntry *pSubSamp;\n\n\tpSamp = NULL;\n\tlast_sample = 0;\n\tcount = gf_list_count(sub_samples->Samples);\n\tfor (i=0; i<count; i++) {\n\t\tpSamp = (GF_SubSampleInfoEntry*) gf_list_get(sub_samples->Samples, i);\n\t\t/*TODO - do we need to support insertion of subsample info ?*/\n\t\tif (last_sample + pSamp->sample_delta > sampleNumber) return GF_NOT_SUPPORTED;\n\t\tif (last_sample + pSamp->sample_delta == sampleNumber) break;\n\t\tlast_sample += pSamp->sample_delta;\n\t\tpSamp = NULL;\n\t}\n\n\tif (!pSamp) {\n\t\tGF_SAFEALLOC(pSamp, GF_SubSampleInfoEntry);\n\t\tif (!pSamp) return GF_OUT_OF_MEM;\n\t\tpSamp->SubSamples = gf_list_new();\n\t\tif (!pSamp->SubSamples ) {\n\t\t\tgf_free(pSamp);\n\t\t\treturn GF_OUT_OF_MEM;\n\t\t}\n\t\tpSamp->sample_delta = sampleNumber - last_sample;\n\t\tgf_list_add(sub_samples->Samples, pSamp);\n\t}\n\n\tif ((subSampleSize>0xFFFF) && !sub_samples->version) {\n\t\tsub_samples->version = 1;\n\t}\n\t/*remove last subsample info*/\n\tif (!subSampleSize) {\n\t\tpSubSamp = gf_list_last(pSamp->SubSamples);\n\t\tgf_list_rem_last(pSamp->SubSamples);\n\t\tgf_free(pSubSamp);\n\t\tif (!gf_list_count(pSamp->SubSamples)) {\n\t\t\tgf_list_del_item(sub_samples->Samples, pSamp);\n\t\t\tgf_list_del(pSamp->SubSamples);\n\t\t\tgf_free(pSamp);\n\t\t}\n\t\treturn GF_OK;\n\t}\n\t/*add subsample*/\n\tGF_SAFEALLOC(pSubSamp, GF_SubSampleEntry);\n\tif (!pSubSamp) return GF_OUT_OF_MEM;\n\tpSubSamp->subsample_size = subSampleSize;\n\tpSubSamp->subsample_priority = priority;\n\tpSubSamp->reserved = reserved;\n\tpSubSamp->discardable = discardable;\n\treturn gf_list_add(pSamp->SubSamples, pSubSamp);\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n#if 0 //unused\nu32 gf_isom_sample_get_subsamples_count(GF_ISOFile *movie, u32 track)\n{\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(movie, track);\n\tif (!track) return 0;\n\tif (!trak->Media || !trak->Media->information->sampleTable || !trak->Media->information->sampleTable->sub_samples) return 0;\n\treturn gf_list_count(trak->Media->information->sampleTable->sub_samples);\n}\n#endif\n\nBool gf_isom_get_subsample_types(GF_ISOFile *movie, u32 track, u32 subs_index, u32 *flags)\n{\n\tGF_SubSampleInformationBox *sub_samples=NULL;\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(movie, track);\n\n\tif (!track || !subs_index) return GF_FALSE;\n\tif (!trak->Media || !trak->Media->information->sampleTable || !trak->Media->information->sampleTable->sub_samples) return GF_FALSE;\n\tsub_samples = gf_list_get(trak->Media->information->sampleTable->sub_samples, subs_index-1);\n\tif (!sub_samples) return GF_FALSE;\n\t*flags = sub_samples->flags;\n\treturn GF_TRUE;\n}\n\nu32 gf_isom_sample_get_subsample_entry(GF_ISOFile *movie, u32 track, u32 sampleNumber, u32 flags, GF_SubSampleInfoEntry **sub_sample)\n{\n\tu32 i, count, last_sample;\n\tGF_SubSampleInformationBox *sub_samples=NULL;\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(movie, track);\n\tif (sub_sample) *sub_sample = NULL;\n\tif (!track) return 0;\n\tif (!trak->Media || !trak->Media->information->sampleTable || !trak->Media->information->sampleTable->sub_samples) return 0;\n\tcount = gf_list_count(trak->Media->information->sampleTable->sub_samples);\n\tfor (i=0; i<count; i++) {\n\t\tsub_samples = gf_list_get(trak->Media->information->sampleTable->sub_samples, i);\n\t\tif (sub_samples->flags==flags) break;\n\t\tsub_samples = NULL;\n\t}\n\tif (!sub_samples) return 0;\n\n\tlast_sample = 0;\n\tcount = gf_list_count(sub_samples->Samples);\n\tfor (i=0; i<count; i++) {\n\t\tGF_SubSampleInfoEntry *pSamp = (GF_SubSampleInfoEntry *) gf_list_get(sub_samples->Samples, i);\n\t\tif (last_sample + pSamp->sample_delta == sampleNumber) {\n\t\t\tif (sub_sample) *sub_sample = pSamp;\n\t\t\treturn gf_list_count(pSamp->SubSamples);\n\t\t}\n\t\tlast_sample += pSamp->sample_delta;\n\t}\n\treturn 0;\n}\n#endif /*GPAC_DISABLE_ISOM*/\n"], "fixing_code": ["/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2021\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / ISO Media File Format sub-project\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include <gpac/internal/isomedia_dev.h>\n#include <gpac/network.h>\n#include <gpac/thread.h>\n\n#ifndef GPAC_DISABLE_ISOM\n\n/**************************************************************\n\t\tSome Local functions for movie creation\n**************************************************************/\nGF_Err gf_isom_parse_root_box(GF_Box **outBox, GF_BitStream *bs, u32 *boxType, u64 *bytesExpected, Bool progressive_mode);\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\nGF_Err MergeFragment(GF_MovieFragmentBox *moof, GF_ISOFile *mov)\n{\n\tGF_Err e;\n\tu32 i, j;\n\tu64 MaxDur;\n\tGF_TrackFragmentBox *traf;\n\tGF_TrackBox *trak;\n\tu64 base_data_offset;\n\n\tMaxDur = 0;\n\n\t//we shall have a MOOV and its MVEX BEFORE any MOOF\n\tif (!mov->moov || !mov->moov->mvex) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Error: %s not received before merging fragment\\n\", mov->moov ? \"mvex\" : \"moov\" ));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\t//and all fragments should be continous but:\n\t//- dash with dependent representations may likely give R1(moofSN 1, 3, 5, 7) plus R2(moofSN 2, 4, 6, 8)\n\t//- smooth muxed in a single file may end up with V(1),A(1), V(2),A(2) ...\n\t//we do not throw an error if not as we may still want to be able to concatenate dependent representations in DASH and\n\tif (mov->NextMoofNumber && moof->mfhd && (mov->NextMoofNumber >= moof->mfhd->sequence_number)) {\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[iso file] wrong sequence number: got %d but last one was %d\\n\", moof->mfhd->sequence_number, mov->NextMoofNumber));\n\t}\n\n\tbase_data_offset = mov->current_top_box_start;\n\tif (moof->compressed_diff)\n\t\tbase_data_offset -= moof->compressed_diff;\n\n\ti=0;\n\twhile ((traf = (GF_TrackFragmentBox*)gf_list_enum(moof->TrackList, &i))) {\n\t\tif (!traf->tfhd) {\n\t\t\ttrak = NULL;\n\t\t\ttraf->trex = NULL;\n\t\t} else if (mov->is_smooth) {\n\t\t\ttrak = gf_list_get(mov->moov->trackList, 0);\n\t\t\ttraf->trex = (GF_TrackExtendsBox*)gf_list_get(mov->moov->mvex->TrackExList, 0);\n\t\t\tassert(traf->trex);\n\t\t\ttraf->trex->trackID = trak->Header->trackID = traf->tfhd->trackID;\n\t\t} else {\n\t\t\ttrak = gf_isom_get_track_from_id(mov->moov, traf->tfhd->trackID);\n\t\t\tj=0;\n\t\t\twhile ((traf->trex = (GF_TrackExtendsBox*)gf_list_enum(mov->moov->mvex->TrackExList, &j))) {\n\t\t\t\tif (traf->trex->trackID == traf->tfhd->trackID) break;\n\t\t\t\ttraf->trex = NULL;\n\t\t\t}\n\t\t}\n\n\t\tif (!trak || !traf->trex) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Error: Cannot find fragment track with ID %d\\n\", traf->tfhd ? traf->tfhd->trackID : 0));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\n\t\te = MergeTrack(trak, traf, moof, mov->current_top_box_start, moof->compressed_diff, &base_data_offset, !trak->first_traf_merged);\n\t\tif (e) return e;\n\n\t\ttrak->present_in_scalable_segment = 1;\n\n\t\t//update trak duration\n\t\tSetTrackDuration(trak);\n\t\tif (trak->Header->duration > MaxDur)\n\t\t\tMaxDur = trak->Header->duration;\n\n\t\ttrak->first_traf_merged = GF_TRUE;\n\t}\n\n\tif (moof->child_boxes) {\n\t\tGF_Box *a;\n\t\ti = 0;\n\t\twhile ((a = (GF_Box *)gf_list_enum(moof->child_boxes, &i))) {\n\t\t\tif (a->type == GF_ISOM_BOX_TYPE_PSSH) {\n\t\t\t\tGF_ProtectionSystemHeaderBox *pssh = (GF_ProtectionSystemHeaderBox *)gf_isom_box_new_parent(&mov->moov->child_boxes, GF_ISOM_BOX_TYPE_PSSH);\n\t\t\t\tif (!pssh) return GF_OUT_OF_MEM;\n\t\t\t\tmemmove(pssh->SystemID, ((GF_ProtectionSystemHeaderBox *)a)->SystemID, 16);\n\t\t\t\tif (((GF_ProtectionSystemHeaderBox *)a)->KIDs && ((GF_ProtectionSystemHeaderBox *)a)->KID_count > 0) {\n\t\t\t\t\tpssh->KID_count = ((GF_ProtectionSystemHeaderBox *)a)->KID_count;\n\t\t\t\t\tpssh->KIDs = (bin128 *)gf_malloc(pssh->KID_count*sizeof(bin128));\n\t\t\t\t\tif (!pssh->KIDs) return GF_OUT_OF_MEM;\n\n\t\t\t\t\tmemmove(pssh->KIDs, ((GF_ProtectionSystemHeaderBox *)a)->KIDs, pssh->KID_count*sizeof(bin128));\n\t\t\t\t}\n\t\t\t\tpssh->private_data_size = ((GF_ProtectionSystemHeaderBox *)a)->private_data_size;\n\t\t\t\tpssh->private_data = (u8 *)gf_malloc(pssh->private_data_size*sizeof(char));\n\t\t\t\tif (!pssh->private_data) return GF_OUT_OF_MEM;\n\t\t\t\tmemmove(pssh->private_data, ((GF_ProtectionSystemHeaderBox *)a)->private_data, pssh->private_data_size);\n\t\t\t}\n\t\t}\n\t}\n\n\tmov->NextMoofNumber = moof->mfhd ? moof->mfhd->sequence_number : 0;\n\t//update movie duration\n\tif (mov->moov->mvhd->duration < MaxDur) mov->moov->mvhd->duration = MaxDur;\n\treturn GF_OK;\n}\n\nstatic void FixTrackID(GF_ISOFile *mov)\n{\n\tif (!mov->moov) return;\n\n\tif (gf_list_count(mov->moov->trackList) == 1 && gf_list_count(mov->moof->TrackList) == 1) {\n\t\tGF_TrackFragmentBox *traf = (GF_TrackFragmentBox*)gf_list_get(mov->moof->TrackList, 0);\n\t\tGF_TrackBox *trak = (GF_TrackBox*)gf_list_get(mov->moov->trackList, 0);\n\t\tif (!traf->tfhd || !trak->Header) return;\n\t\tif ((traf->tfhd->trackID != trak->Header->trackID)) {\n\t\t\tif (!mov->is_smooth) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Warning: trackID of MOOF/TRAF(%u) is not the same as MOOV/TRAK(%u). Trying to fix.\\n\", traf->tfhd->trackID, trak->Header->trackID));\n\t\t\t} else {\n\t\t\t\ttrak->Header->trackID = traf->tfhd->trackID;\n\t\t\t}\n\t\t\ttraf->tfhd->trackID = trak->Header->trackID;\n\t\t}\n\t}\n}\n\nstatic void FixSDTPInTRAF(GF_MovieFragmentBox *moof)\n{\n\tu32 k;\n\tif (!moof)\n\t\treturn;\n\n\tfor (k = 0; k < gf_list_count(moof->TrackList); k++) {\n\t\tGF_TrackFragmentBox *traf = gf_list_get(moof->TrackList, k);\n\t\tif (traf->sdtp) {\n\t\t\tGF_TrackFragmentRunBox *trun;\n\t\t\tu32 j = 0, sample_index = 0;\n\n\t\t\tif (traf->sdtp->sampleCount == gf_list_count(traf->TrackRuns)) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Warning: TRAF box of track id=%u contains a SDTP. Converting to TRUN sample flags.\\n\", traf->tfhd->trackID));\n\t\t\t}\n\n\t\t\twhile ((trun = (GF_TrackFragmentRunBox*)gf_list_enum(traf->TrackRuns, &j))) {\n\t\t\t\tu32 i;\n\t\t\t\ttrun->flags |= GF_ISOM_TRUN_FLAGS;\n\t\t\t\tfor (i=0; i<trun->nb_samples; i++) {\n\t\t\t\t\tGF_TrunEntry *entry = &trun->samples[i];\n\t\t\t\t\tconst u8 info = traf->sdtp->sample_info[sample_index];\n\t\t\t\t\tentry->flags |= GF_ISOM_GET_FRAG_DEPEND_FLAGS(info >> 6, info >> 4, info >> 2, info);\n\t\t\t\t\tsample_index++;\n\t\t\t\t\tif (sample_index > traf->sdtp->sampleCount) {\n\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Error: TRAF box of track id=%u contained an inconsistent SDTP.\\n\", traf->tfhd->trackID));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (sample_index < traf->sdtp->sampleCount) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Error: TRAF box of track id=%u list less samples than SDTP.\\n\", traf->tfhd->trackID));\n\t\t\t}\n\t\t\tgf_isom_box_del_parent(&traf->child_boxes, (GF_Box*)traf->sdtp);\n\t\t\ttraf->sdtp = NULL;\n\t\t}\n\t}\n}\n\nvoid gf_isom_push_mdat_end(GF_ISOFile *mov, u64 mdat_end)\n{\n\tu32 i, count;\n\tif (!mov || !mov->moov) return;\n\t\n\tcount = gf_list_count(mov->moov->trackList);\n\tfor (i=0; i<count; i++) {\n\t\tu32 j;\n\t\tGF_TrafToSampleMap *traf_map;\n\t\tGF_TrackBox *trak = gf_list_get(mov->moov->trackList, i);\n\t\tif (!trak->Media->information->sampleTable->traf_map) continue;\n\n\t\ttraf_map = trak->Media->information->sampleTable->traf_map;\n\t\tfor (j=traf_map->nb_entries; j>0; j--) {\n\t\t\tif (!traf_map->frag_starts[j-1].mdat_end) {\n\t\t\t\ttraf_map->frag_starts[j-1].mdat_end = mdat_end;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\n#ifdef GF_ENABLE_CTRN\nstatic void gf_isom_setup_traf_inheritance(GF_ISOFile *mov)\n{\n\tu32 i, count;\n\tif (!mov->moov->mvex)\n\t\treturn;\n\tcount = gf_list_count(mov->moov->trackList);\n\n\tfor (i=0; i<count; i++) {\n\t\tu32 refTrackNum=0;\n\t\tgf_isom_get_reference(mov, i+1, GF_ISOM_REF_TRIN, 1, &refTrackNum);\n\t\tif (refTrackNum) {\n\t\t\tGF_ISOTrackID tkid = gf_isom_get_track_id(mov, i+1);\n\t\t\tGF_ISOTrackID reftkid = gf_isom_get_track_id(mov, refTrackNum);\n\t\t\tGF_TrackExtendsBox *trex = GetTrex(mov->moov, tkid);\n\t\t\tif (trex) trex->inherit_from_traf_id = reftkid;\n\t\t}\n\t}\n}\n#endif\n\n#endif\n\n//for now we only use regular sample to group internally (except when dumping), not the pattern version\n//we unrill the pattern and replace the compact version with a regular one\nstatic void convert_compact_sample_groups(GF_List *child_boxes, GF_List *sampleGroups)\n{\n\tu32 i;\n\tfor (i=0; i<gf_list_count(sampleGroups); i++) {\n\t\tu32 j;\n\t\tGF_SampleGroupBox *sbgp;\n\t\tGF_CompactSampleGroupBox *csgp = gf_list_get(sampleGroups, i);\n\t\tif (csgp->type != GF_ISOM_BOX_TYPE_CSGP) continue;\n\n\t\tgf_list_rem(sampleGroups, i);\n\t\tgf_list_del_item(child_boxes, csgp);\n\n\t\tsbgp = (GF_SampleGroupBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_SBGP);\n\t\tgf_list_insert(sampleGroups, sbgp, i);\n\t\tgf_list_add(child_boxes, sbgp);\n\t\ti--;\n\n\t\tsbgp->grouping_type = csgp->grouping_type;\n\t\tif (csgp->grouping_type_parameter) {\n\t\t\tsbgp->grouping_type_parameter = csgp->grouping_type_parameter;\n\t\t\tsbgp->version = 1;\n\t\t}\n\t\tsbgp->entry_count = 0;\n\t\tfor (j=0; j<csgp->pattern_count; j++) {\n\t\t\tu32 k=0;\n\t\t\tu32 nb_samples = csgp->patterns[j].sample_count;\n\t\t\t//unroll the pattern\n\t\t\twhile (nb_samples) {\n\t\t\t\tu32 nb_same_index=1;\n\t\t\t\tu32 sg_idx = csgp->patterns[j].sample_group_description_indices[k];\n\t\t\t\twhile (nb_same_index+k<csgp->patterns[j].length) {\n\t\t\t\t\tif (csgp->patterns[j].sample_group_description_indices[k+nb_same_index] != sg_idx)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tnb_same_index++;\n\t\t\t\t}\n\t\t\t\tsbgp->sample_entries = gf_realloc(sbgp->sample_entries, sizeof(GF_SampleGroupEntry) * (sbgp->entry_count+1));\n\t\t\t\tif (nb_same_index>nb_samples)\n\t\t\t\t\tnb_same_index = nb_samples;\n\n\t\t\t\tsbgp->sample_entries[sbgp->entry_count].sample_count = nb_same_index;\n\t\t\t\tsbgp->sample_entries[sbgp->entry_count].group_description_index = sg_idx;\n\t\t\t\tnb_samples -= nb_same_index;\n\t\t\t\tsbgp->entry_count++;\n\t\t\t\tk+= nb_same_index;\n\t\t\t\tif (k==csgp->patterns[j].length)\n\t\t\t\t\tk = 0;\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nstatic GF_Err gf_isom_parse_movie_boxes_internal(GF_ISOFile *mov, u32 *boxType, u64 *bytesMissing, Bool progressive_mode)\n{\n\tGF_Box *a;\n\tu64 totSize, mdat_end=0;\n\tGF_Err e = GF_OK;\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (mov->single_moof_mode && mov->single_moof_state == 2) {\n\t\treturn e;\n\t}\n\n\t/*restart from where we stopped last*/\n\ttotSize = mov->current_top_box_start;\n\tif (mov->bytes_removed) {\n\t\tassert(totSize >= mov->bytes_removed);\n\t\ttotSize -= mov->bytes_removed;\n\t}\n\tgf_bs_seek(mov->movieFileMap->bs, totSize);\n#endif\n\n\n\t/*while we have some data, parse our boxes*/\n\twhile (gf_bs_available(mov->movieFileMap->bs)) {\n\t\t*bytesMissing = 0;\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\t\tmov->current_top_box_start = gf_bs_get_position(mov->movieFileMap->bs) + mov->bytes_removed;\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[iso file] Parsing a top-level box at position %d\\n\", mov->current_top_box_start));\n#endif\n\n\t\te = gf_isom_parse_root_box(&a, mov->movieFileMap->bs, boxType, bytesMissing, progressive_mode);\n\n\t\tif (e >= 0) {\n\n\t\t} else if (e == GF_ISOM_INCOMPLETE_FILE) {\n\t\t\t/*our mdat is uncomplete, only valid for READ ONLY files...*/\n\t\t\tif (mov->openMode != GF_ISOM_OPEN_READ) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Incomplete MDAT while file is not read-only\\n\"));\n\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\t}\n\t\t\tif ((mov->openMode == GF_ISOM_OPEN_READ) && !progressive_mode) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Incomplete file while reading for dump - aborting parsing\\n\"));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\treturn e;\n\t\t} else {\n\t\t\treturn e;\n\t\t}\n\n\t\tswitch (a->type) {\n\t\t/*MOOV box*/\n\t\tcase GF_ISOM_BOX_TYPE_MOOV:\n\t\t\tif (mov->moov) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Duplicate MOOV detected!\\n\"));\n\t\t\t\tgf_isom_box_del(a);\n\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\t}\n\t\t\tmov->moov = (GF_MovieBox *)a;\n\t\t\tmov->original_moov_offset = mov->current_top_box_start;\n\t\t\t/*set our pointer to the movie*/\n\t\t\tmov->moov->mov = mov;\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\t\tif (mov->moov->mvex) mov->moov->mvex->mov = mov;\n\n#ifdef GF_ENABLE_CTRN\n\t\t\tif (! (mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG)) {\n\t\t\t\tgf_isom_setup_traf_inheritance(mov);\n\t\t\t}\n#endif\n\n#endif\n\t\t\te = gf_list_add(mov->TopBoxes, a);\n\t\t\tif (e) return e;\n\n\t\t\ttotSize += a->size;\n\n            if (!mov->moov->mvhd) {\n                GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing MovieHeaderBox\\n\"));\n                return GF_ISOM_INVALID_FILE;\n            }\n\n            if (mov->meta) {\n\t\t\t\tgf_isom_meta_restore_items_ref(mov, mov->meta);\n\t\t\t}\n\n\t\t\t//dump senc info in dump mode\n\t\t\tif (mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG) {\n\t\t\t\tu32 k;\n\t\t\t\tfor (k=0; k<gf_list_count(mov->moov->trackList); k++) {\n\t\t\t\t\tGF_TrackBox *trak = (GF_TrackBox *)gf_list_get(mov->moov->trackList, k);\n\n\t\t\t\t\tif (trak->sample_encryption) {\n\t\t\t\t\t\te = senc_Parse(mov->movieFileMap->bs, trak, NULL, trak->sample_encryption);\n\t\t\t\t\t\tif (e) return e;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tu32 k;\n\t\t\t\tfor (k=0; k<gf_list_count(mov->moov->trackList); k++) {\n\t\t\t\t\tGF_TrackBox *trak = (GF_TrackBox *)gf_list_get(mov->moov->trackList, k);\n\t\t\t\t\tif (trak->Media->information->sampleTable->sampleGroups) {\n\t\t\t\t\t\tconvert_compact_sample_groups(trak->Media->information->sampleTable->child_boxes, trak->Media->information->sampleTable->sampleGroups);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n            if (mdat_end && mov->signal_frag_bounds && !(mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG) ) {\n                gf_isom_push_mdat_end(mov, mdat_end);\n                mdat_end=0;\n            }\n\t\t\tbreak;\n\n\t\t/*META box*/\n\t\tcase GF_ISOM_BOX_TYPE_META:\n\t\t\tif (mov->meta) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Duplicate META detected!\\n\"));\n\t\t\t\tgf_isom_box_del(a);\n\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\t}\n\t\t\tmov->meta = (GF_MetaBox *)a;\n\t\t\tmov->original_meta_offset = mov->current_top_box_start;\n\t\t\te = gf_list_add(mov->TopBoxes, a);\n\t\t\tif (e) {\n\t\t\t\treturn e;\n\t\t\t}\n\t\t\ttotSize += a->size;\n            if (mov->moov) {\n\t\t\t\tgf_isom_meta_restore_items_ref(mov, mov->meta);\n\t\t\t}\n\t\t\tbreak;\n\n\t\t/*we only keep the MDAT in READ for dump purposes*/\n\t\tcase GF_ISOM_BOX_TYPE_MDAT:\n\t\t\tif (!mov->first_data_toplevel_offset) {\n\t\t\t\tmov->first_data_toplevel_offset = mov->current_top_box_start;\n\t\t\t\tmov->first_data_toplevel_size = a->size;\n\t\t\t}\n\t\t\ttotSize += a->size;\n\t\t\tif (mov->openMode == GF_ISOM_OPEN_READ) {\n\t\t\t\tif (!mov->mdat) {\n\t\t\t\t\tmov->mdat = (GF_MediaDataBox *) a;\n\t\t\t\t\te = gf_list_add(mov->TopBoxes, mov->mdat);\n\t\t\t\t\tif (e) {\n\t\t\t\t\t\treturn e;\n\t\t\t\t\t}\n\t\t\t\t}\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\t\t\t\telse if (mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG) gf_list_add(mov->TopBoxes, a);\n#endif\n\t\t\t\telse gf_isom_box_del(a); //in other modes we don't care\n\n\n\t\t\t\tif (mov->signal_frag_bounds && !(mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG) ) {\n                    mdat_end = gf_bs_get_position(mov->movieFileMap->bs);\n                    if (mov->moov) {\n                        gf_isom_push_mdat_end(mov, mdat_end);\n                        mdat_end=0;\n                    }\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*if we don't have any MDAT yet, create one (edit-write mode)\n\t\t\tWe only work with one mdat, but we're puting it at the place\n\t\t\tof the first mdat found when opening a file for editing*/\n\t\t\telse if (!mov->mdat && (mov->openMode != GF_ISOM_OPEN_READ) && (mov->openMode != GF_ISOM_OPEN_KEEP_FRAGMENTS)) {\n\t\t\t\tgf_isom_box_del(a);\n\t\t\t\tmov->mdat = (GF_MediaDataBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_MDAT);\n\t\t\t\tif (!mov->mdat) return GF_OUT_OF_MEM;\n\t\t\t\te = gf_list_add(mov->TopBoxes, mov->mdat);\n\t\t\t\tif (e) {\n\t\t\t\t\treturn e;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tgf_isom_box_del(a);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_FTYP:\n\t\t\t/*ONE AND ONLY ONE FTYP*/\n\t\t\tif (mov->brand) {\n\t\t\t\tgf_isom_box_del(a);\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Duplicate 'ftyp' detected!\\n\"));\n\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\t}\n\t\t\tmov->brand = (GF_FileTypeBox *)a;\n\t\t\ttotSize += a->size;\n\t\t\te = gf_list_add(mov->TopBoxes, a);\n\t\t\tif (e) return e;\n\t\t\tbreak;\n\n\t\tcase GF_ISOM_BOX_TYPE_OTYP:\n\t\t\t/*ONE AND ONLY ONE FTYP*/\n\t\t\tif (mov->otyp) {\n\t\t\t\tgf_isom_box_del(a);\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Duplicate 'otyp' detected!\\n\"));\n\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\t}\n\n\t\t\tif (mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG) {\n\t\t\t\tmov->otyp = (GF_Box *)a;\n\t\t\t\ttotSize += a->size;\n\t\t\t\te = gf_list_add(mov->TopBoxes, a);\n\t\t\t\tif (e) return e;\n\t\t\t} else {\n\t\t\t\tGF_FileTypeBox *brand = (GF_FileTypeBox *) gf_isom_box_find_child(a->child_boxes, GF_ISOM_BOX_TYPE_FTYP);\n\t\t\t\tif (brand) {\n\t\t\t\t\ts32 pos;\n\t\t\t\t\tgf_list_del_item(a->child_boxes, brand);\n\t\t\t\t\tpos = gf_list_del_item(mov->TopBoxes, mov->brand);\n\t\t\t\t\tgf_isom_box_del((GF_Box *) mov->brand);\n\t\t\t\t\tmov->brand = brand;\n\t\t\t\t\tif (pos<0) pos=0;\n\t\t\t\t\tgf_list_insert(mov->TopBoxes, brand, pos);\n\t\t\t\t}\n\t\t\t\tgf_isom_box_del(a);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase GF_ISOM_BOX_TYPE_PDIN:\n\t\t\t/*ONE AND ONLY ONE PDIN*/\n\t\t\tif (mov->pdin) {\n\t\t\t\tgf_isom_box_del(a);\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Duplicate 'pdin'' detected!\\n\"));\n\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\t}\n\t\t\tmov->pdin = (GF_ProgressiveDownloadBox *) a;\n\t\t\ttotSize += a->size;\n\t\t\te = gf_list_add(mov->TopBoxes, a);\n\t\t\tif (e) return e;\n\t\t\tbreak;\n\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\t\tcase GF_ISOM_BOX_TYPE_STYP:\n\t\t{\n\t\t\tu32 brand = ((GF_FileTypeBox *)a)->majorBrand;\n\t\t\tswitch (brand) {\n\t\t\tcase GF_ISOM_BRAND_SISX:\n\t\t\tcase GF_ISOM_BRAND_RISX:\n\t\t\tcase GF_ISOM_BRAND_SSSS:\n\t\t\t\tmov->is_index_segment = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t/*fall-through*/\n\n\t\tcase GF_ISOM_BOX_TYPE_SIDX:\n\t\tcase GF_ISOM_BOX_TYPE_SSIX:\n\t\t\tif (mov->moov && !mov->first_data_toplevel_offset) {\n\t\t\t\tmov->first_data_toplevel_offset = mov->current_top_box_start;\n\t\t\t\tmov->first_data_toplevel_size = a->size;\n\t\t\t}\n\t\t\ttotSize += a->size;\n\t\t\tif (mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG) {\n\t\t\t\te = gf_list_add(mov->TopBoxes, a);\n\t\t\t\tif (e) return e;\n\t\t\t} else if (mov->signal_frag_bounds && !(mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG)  && (mov->openMode!=GF_ISOM_OPEN_KEEP_FRAGMENTS)\n\t\t\t) {\n\t\t\t\tif (a->type==GF_ISOM_BOX_TYPE_SIDX) {\n\t\t\t\t\tif (mov->root_sidx) gf_isom_box_del( (GF_Box *) mov->root_sidx);\n\t\t\t\t\tmov->root_sidx = (GF_SegmentIndexBox *) a;\n\t\t\t\t\tmov->sidx_start_offset = mov->current_top_box_start;\n\t\t\t\t\tmov->sidx_end_offset = gf_bs_get_position(mov->movieFileMap->bs);\n\n\t\t\t\t}\n\t\t\t\telse if (a->type==GF_ISOM_BOX_TYPE_STYP) {\n\t\t\t\t\tmov->styp_start_offset = mov->current_top_box_start;\n\n\t\t\t\t\tif (mov->seg_styp) gf_isom_box_del(mov->seg_styp);\n\t\t\t\t\tmov->seg_styp = a;\n\t\t\t\t} else if (a->type==GF_ISOM_BOX_TYPE_SSIX) {\n\t\t\t\t\tif (mov->seg_ssix) gf_isom_box_del(mov->seg_ssix);\n\t\t\t\t\tmov->seg_ssix = a;\n\t\t\t\t} else {\n\t\t\t\t\tgf_isom_box_del(a);\n\t\t\t\t}\n\t\t\t\tgf_isom_push_mdat_end(mov, mov->current_top_box_start);\n\t\t\t} else if (!mov->NextMoofNumber && (a->type==GF_ISOM_BOX_TYPE_SIDX)) {\n\t\t\t\tif (mov->main_sidx) gf_isom_box_del( (GF_Box *) mov->main_sidx);\n\t\t\t\tmov->main_sidx = (GF_SegmentIndexBox *) a;\n\t\t\t\tmov->main_sidx_end_pos = mov->current_top_box_start + a->size;\n\t\t\t} else {\n\t\t\t\tgf_isom_box_del(a);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase GF_ISOM_BOX_TYPE_MOOF:\n\t\t\t//no support for inplace rewrite for fragmented files\n\t\t\tgf_isom_disable_inplace_rewrite(mov);\n\t\t\tif (!mov->moov) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Movie fragment but no moov (yet) - possibly broken parsing!\\n\"));\n\t\t\t}\n\t\t\tif (mov->single_moof_mode) {\n\t\t\t\tmov->single_moof_state++;\n\t\t\t\tif (mov->single_moof_state > 1) {\n\t\t\t\t\tgf_isom_box_del(a);\n\t\t\t\t\treturn GF_OK;\n\t\t\t\t}\n\t\t\t}\n\t\t\t((GF_MovieFragmentBox *)a)->mov = mov;\n\n\t\t\ttotSize += a->size;\n\t\t\tmov->moof = (GF_MovieFragmentBox *) a;\n\n\t\t\t/*some smooth streaming streams contain a SDTP under the TRAF: this is incorrect, convert it*/\n\t\t\tFixTrackID(mov);\n\t\t\tif (! (mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG)) {\n\t\t\t\tFixSDTPInTRAF(mov->moof);\n\t\t\t} else {\n\t\t\t\tu32 k;\n\t\t\t\tfor (k=0; k<gf_list_count(mov->moof->TrackList); k++) {\n\t\t\t\t\tGF_TrackFragmentBox *traf = (GF_TrackFragmentBox *)gf_list_get(mov->moof->TrackList, k);\n\t\t\t\t\tif (traf->sampleGroups) {\n\t\t\t\t\t\tconvert_compact_sample_groups(traf->child_boxes, traf->sampleGroups);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*read & debug: store at root level*/\n\t\t\tif (mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG) {\n\t\t\t\tu32 k;\n\t\t\t\tgf_list_add(mov->TopBoxes, a);\n\t\t\t\t/*also update pointers to trex for debug*/\n\t\t\t\tif (mov->moov) {\n\t\t\t\t\tfor (k=0; k<gf_list_count(mov->moof->TrackList); k++) {\n\t\t\t\t\t\tGF_TrackFragmentBox *traf = gf_list_get(mov->moof->TrackList, k);\n\t\t\t\t\t\tif (traf->tfhd && mov->moov->mvex && mov->moov->mvex->TrackExList) {\n\t\t\t\t\t\t\tGF_TrackBox *trak = gf_isom_get_track_from_id(mov->moov, traf->tfhd->trackID);\n\t\t\t\t\t\t\tu32 j=0;\n\t\t\t\t\t\t\twhile ((traf->trex = (GF_TrackExtendsBox*)gf_list_enum(mov->moov->mvex->TrackExList, &j))) {\n\t\t\t\t\t\t\t\tif (traf->trex->trackID == traf->tfhd->trackID) {\n\t\t\t\t\t\t\t\t\tif (!traf->trex->track) traf->trex->track = trak;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\ttraf->trex = NULL;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//we should only parse senc/psec when no saiz/saio is present, otherwise we fetch the info directly\n\t\t\t\t\t\tif (traf->trex && traf->tfhd && traf->trex->track && traf->sample_encryption) {\n\t\t\t\t\t\t\tGF_TrackBox *trak = GetTrackbyID(mov->moov, traf->tfhd->trackID);\n\t\t\t\t\t\t\ttrak->current_traf_stsd_idx = traf->tfhd->sample_desc_index ? traf->tfhd->sample_desc_index : traf->trex->def_sample_desc_index;\n\t\t\t\t\t\t\te = senc_Parse(mov->movieFileMap->bs, trak, traf, traf->sample_encryption);\n\t\t\t\t\t\t\tif (e) return e;\n\t\t\t\t\t\t\ttrak->current_traf_stsd_idx = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor (k=0; k<gf_list_count(mov->moof->TrackList); k++) {\n\t\t\t\t\t\tGF_TrackFragmentBox *traf = gf_list_get(mov->moof->TrackList, k);\n\t\t\t\t\t\tif (traf->sample_encryption) {\n\t\t\t\t\t\t\te = senc_Parse(mov->movieFileMap->bs, NULL, traf, traf->sample_encryption);\n\t\t\t\t\t\t\tif (e) return e;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t} else if (mov->openMode==GF_ISOM_OPEN_KEEP_FRAGMENTS) {\n\t\t\t\tmov->NextMoofNumber = mov->moof->mfhd->sequence_number+1;\n\t\t\t\tmov->moof = NULL;\n\t\t\t\tgf_isom_box_del(a);\n\t\t\t} else {\n\t\t\t\t/*merge all info*/\n\t\t\t\te = MergeFragment((GF_MovieFragmentBox *)a, mov);\n\t\t\t\tgf_isom_box_del(a);\n\t\t\t\tif (e) return e;\n\t\t\t}\n\n\t\t\t//done with moov\n\t\t\tif (mov->root_sidx) {\n\t\t\t\tgf_isom_box_del((GF_Box *) mov->root_sidx);\n\t\t\t\tmov->root_sidx = NULL;\n\t\t\t}\n\t\t\tif (mov->root_ssix) {\n\t\t\t\tgf_isom_box_del(mov->seg_ssix);\n\t\t\t\tmov->root_ssix = NULL;\n\t\t\t}\n\t\t\tif (mov->seg_styp) {\n\t\t\t\tgf_isom_box_del(mov->seg_styp);\n\t\t\t\tmov->seg_styp = NULL;\n\t\t\t}\n\t\t\tmov->sidx_start_offset = 0;\n\t\t\tmov->sidx_end_offset = 0;\n\t\t\tmov->styp_start_offset = 0;\n\t\t\tbreak;\n#endif\n\t\tcase GF_ISOM_BOX_TYPE_UNKNOWN:\n\t\t{\n\t\t\tGF_UnknownBox *box = (GF_UnknownBox*)a;\n\t\t\tif (box->original_4cc == GF_ISOM_BOX_TYPE_JP) {\n\t\t\t\tu8 *c = (u8 *) box->data;\n\t\t\t\tif ((box->dataSize==4) && (GF_4CC(c[0],c[1],c[2],c[3])==(u32)0x0D0A870A))\n\t\t\t\t\tmov->is_jp2 = 1;\n\t\t\t\tgf_isom_box_del(a);\n\t\t\t} else {\n\t\t\t\te = gf_list_add(mov->TopBoxes, a);\n\t\t\t\tif (e) return e;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase GF_ISOM_BOX_TYPE_PRFT:\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\t\tif (!(mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG)) {\n\t\t\t\t//keep the last one read\n\t\t\t\tif (mov->last_producer_ref_time)\n\t\t\t\t\tgf_isom_box_del(a);\n\t\t\t\telse\n\t\t\t\t\tmov->last_producer_ref_time = (GF_ProducerReferenceTimeBox *)a;\n\t\t\t\tbreak;\n\t\t\t}\n#endif\n\t\t//fallthrough\n\n\t\tdefault:\n\t\t\ttotSize += a->size;\n\t\t\te = gf_list_add(mov->TopBoxes, a);\n\t\t\tif (e) return e;\n\t\t\tbreak;\n\t\t}\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\t\t/*remember where we left, in case we append an entire number of movie fragments*/\n\t\tmov->current_top_box_start = gf_bs_get_position(mov->movieFileMap->bs) + mov->bytes_removed;\n#endif\n\t}\n\n\t/*we need at least moov or meta*/\n\tif (!mov->moov && !mov->meta\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t        && !mov->moof && !mov->is_index_segment\n#endif\n\t   ) {\n\t\treturn GF_ISOM_INCOMPLETE_FILE;\n\t}\n\t/*we MUST have movie header*/\n\tif (!gf_opts_get_bool(\"core\", \"no-check\")) {\n\t\tif (mov->moov && !mov->moov->mvhd) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing MVHD in MOOV!\\n\"));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\n\t\t/*we MUST have meta handler*/\n\t\tif (mov->meta && !mov->meta->handler) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing handler in META!\\n\"));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n\tif (mov->moov) {\n\t\t/*set the default interleaving time*/\n\t\tmov->interleavingTime = mov->moov->mvhd->timeScale;\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\t\t/*in edit mode with successfully loaded fragments, delete all fragment signaling since\n\t\tfile is no longer fragmented*/\n\t\tif ((mov->openMode > GF_ISOM_OPEN_READ) && (mov->openMode != GF_ISOM_OPEN_KEEP_FRAGMENTS) && mov->moov->mvex) {\n\t\t\tgf_isom_box_del_parent(&mov->moov->child_boxes, (GF_Box *)mov->moov->mvex);\n\t\t\tmov->moov->mvex = NULL;\n\t\t}\n#endif\n\n\t}\n\n\t//create a default mdat if none was found\n\tif (!mov->mdat && (mov->openMode != GF_ISOM_OPEN_READ) && (mov->openMode != GF_ISOM_OPEN_KEEP_FRAGMENTS)) {\n\t\tmov->mdat = (GF_MediaDataBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_MDAT);\n\t\tif (!mov->mdat) return GF_OUT_OF_MEM;\n\t\te = gf_list_add(mov->TopBoxes, mov->mdat);\n\t\tif (e) return e;\n\t}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\treturn GF_OK;\n}\n\nGF_Err gf_isom_parse_movie_boxes(GF_ISOFile *mov, u32 *boxType, u64 *bytesMissing, Bool progressive_mode)\n{\n\tGF_Err e;\n\tGF_Blob *blob = NULL;\n\n\t//if associated file is a blob, lock blob before parsing !\n\tif (mov->movieFileMap && ((mov->movieFileMap->type == GF_ISOM_DATA_MEM) || (mov->movieFileMap->type == GF_ISOM_DATA_FILE))) {\n\t\tblob = ((GF_FileDataMap *)mov->movieFileMap)->blob;\n\t}\n\n\tif (blob)\n\t\tgf_mx_p(blob->mx);\n\n\te = gf_isom_parse_movie_boxes_internal(mov, boxType, bytesMissing, progressive_mode);\n\n\tif (blob)\n\t\tgf_mx_v(blob->mx);\n\treturn e;\n\n}\n\nGF_ISOFile *gf_isom_new_movie()\n{\n\tGF_ISOFile *mov = (GF_ISOFile*)gf_malloc(sizeof(GF_ISOFile));\n\tif (mov == NULL) {\n\t\tgf_isom_set_last_error(NULL, GF_OUT_OF_MEM);\n\t\treturn NULL;\n\t}\n\tmemset(mov, 0, sizeof(GF_ISOFile));\n\n\t/*init the boxes*/\n\tmov->TopBoxes = gf_list_new();\n\tif (!mov->TopBoxes) {\n\t\tgf_isom_set_last_error(NULL, GF_OUT_OF_MEM);\n\t\tgf_free(mov);\n\t\treturn NULL;\n\t}\n\n\t/*default storage mode is flat*/\n\tmov->storageMode = GF_ISOM_STORE_FLAT;\n\tmov->es_id_default_sync = -1;\n\treturn mov;\n}\n\n//Create and parse the movie for READ - EDIT only\nGF_ISOFile *gf_isom_open_file(const char *fileName, GF_ISOOpenMode OpenMode, const char *tmp_dir)\n{\n\tGF_Err e;\n\tu64 bytes;\n\tGF_ISOFile *mov = gf_isom_new_movie();\n\tif (!mov || !fileName) return NULL;\n\n\tmov->fileName = gf_strdup(fileName);\n\tmov->openMode = OpenMode;\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (OpenMode==GF_ISOM_OPEN_READ_DUMP)\n\t\tmov->store_traf_map = GF_TRUE;\n#endif\n\n\tif ( (OpenMode == GF_ISOM_OPEN_READ) || (OpenMode == GF_ISOM_OPEN_READ_DUMP) || (OpenMode == GF_ISOM_OPEN_READ_EDIT) ) {\n\t\tif (OpenMode == GF_ISOM_OPEN_READ_EDIT) {\n\t\t\tmov->openMode = GF_ISOM_OPEN_READ_EDIT;\n\n\t\t\t// create a memory edit map in case we add samples, typically during import\n\t\t\te = gf_isom_datamap_new(NULL, tmp_dir, GF_ISOM_DATA_MAP_WRITE, & mov->editFileMap);\n\t\t\tif (e) {\n\t\t\t\tgf_isom_set_last_error(NULL, e);\n\t\t\t\tgf_isom_delete_movie(mov);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t} else {\n\t\t\tmov->openMode = GF_ISOM_OPEN_READ;\n\t\t}\n\t\tmov->es_id_default_sync = -1;\n\t\t//for open, we do it the regular way and let the GF_DataMap assign the appropriate struct\n\t\t//this can be FILE (the only one supported...) as well as remote\n\t\t//(HTTP, ...),not suported yet\n\t\t//the bitstream IS PART OF the GF_DataMap\n\t\t//as this is read-only, use a FileMapping. this is the only place where\n\t\t//we use file mapping\n\t\te = gf_isom_datamap_new(fileName, NULL, GF_ISOM_DATA_MAP_READ_ONLY, &mov->movieFileMap);\n\t\tif (e) {\n\t\t\tgf_isom_set_last_error(NULL, e);\n\t\t\tgf_isom_delete_movie(mov);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (OpenMode == GF_ISOM_OPEN_READ_DUMP) {\n\t\t\tmov->FragmentsFlags |= GF_ISOM_FRAG_READ_DEBUG;\n\t\t}\n\t} else {\n\n#ifdef GPAC_DISABLE_ISOM_WRITE\n\t\t//not allowed for READ_ONLY lib\n\t\tgf_isom_delete_movie(mov);\n\t\tgf_isom_set_last_error(NULL, GF_ISOM_INVALID_MODE);\n\t\treturn NULL;\n\n#else\n\n\t\t//set a default output name for edited file\n\t\tmov->finalName = (char*)gf_malloc(strlen(fileName) + 5);\n\t\tif (!mov->finalName) {\n\t\t\tgf_isom_set_last_error(NULL, GF_OUT_OF_MEM);\n\t\t\tgf_isom_delete_movie(mov);\n\t\t\treturn NULL;\n\t\t}\n\t\tstrcpy(mov->finalName, \"out_\");\n\t\tstrcat(mov->finalName, fileName);\n\n\t\t//open the original file with edit tag\n\t\te = gf_isom_datamap_new(fileName, NULL, GF_ISOM_DATA_MAP_EDIT, &mov->movieFileMap);\n\t\t//if the file doesn't exist, we assume it's wanted and create one from scratch\n\t\tif (e) {\n\t\t\tgf_isom_set_last_error(NULL, e);\n\t\t\tgf_isom_delete_movie(mov);\n\t\t\treturn NULL;\n\t\t}\n\t\t//and create a temp fileName for the edit\n\t\te = gf_isom_datamap_new(\"_gpac_isobmff_tmp_edit\", tmp_dir, GF_ISOM_DATA_MAP_WRITE, & mov->editFileMap);\n\t\tif (e) {\n\t\t\tgf_isom_set_last_error(NULL, e);\n\t\t\tgf_isom_delete_movie(mov);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tmov->es_id_default_sync = -1;\n\n#endif\n\t}\n\n\t//OK, let's parse the movie...\n\tmov->LastError = gf_isom_parse_movie_boxes(mov, NULL, &bytes, 0);\n\n#if 0\n\tif (!mov->LastError && (OpenMode == GF_ISOM_OPEN_CAT_FRAGMENTS)) {\n\t\tgf_isom_datamap_del(mov->movieFileMap);\n\t\t/*reopen the movie file map in cat mode*/\n\t\tmov->LastError = gf_isom_datamap_new(fileName, tmp_dir, GF_ISOM_DATA_MAP_CAT, & mov->movieFileMap);\n\t}\n#endif\n\n\tif (mov->LastError) {\n\t\tgf_isom_set_last_error(NULL, mov->LastError);\n\t\tgf_isom_delete_movie(mov);\n\t\treturn NULL;\n\t}\n\n\tmov->nb_box_init_seg = gf_list_count(mov->TopBoxes);\n\treturn mov;\n}\n\nGF_Err gf_isom_set_write_callback(GF_ISOFile *mov,\n \t\t\tGF_Err (*on_block_out)(void *cbk, u8 *data, u32 block_size),\n\t\t\tGF_Err (*on_block_patch)(void *usr_data, u8 *block, u32 block_size, u64 block_offset, Bool is_insert),\n \t\t\tvoid *usr_data,\n \t\t\tu32 block_size)\n{\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\tif (mov->finalName && !strcmp(mov->finalName, \"_gpac_isobmff_redirect\")) {}\n\telse if (mov->fileName && !strcmp(mov->fileName, \"_gpac_isobmff_redirect\")) {}\n\telse return GF_BAD_PARAM;\n\tmov->on_block_out = on_block_out;\n\tmov->on_block_patch = on_block_patch;\n\tmov->on_block_out_usr_data = usr_data;\n\tmov->on_block_out_block_size = block_size;\n\treturn GF_OK;\n#else\n\treturn GF_NOT_SUPPORTED;\n#endif\n}\n\n\nu64 gf_isom_get_mp4time()\n{\n\tu32 calctime, msec;\n\tu64 ret;\n\tgf_utc_time_since_1970(&calctime, &msec);\n\tcalctime += GF_ISOM_MAC_TIME_OFFSET;\n\tret = calctime;\n\treturn ret;\n}\n\nvoid gf_isom_delete_movie(GF_ISOFile *mov)\n{\n\tif (!mov) return;\n\n\t//these are our two main files\n\tif (mov->movieFileMap) gf_isom_datamap_del(mov->movieFileMap);\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\tif (mov->editFileMap) {\n\t\tgf_isom_datamap_del(mov->editFileMap);\n\t}\n\tif (mov->finalName) gf_free(mov->finalName);\n#endif\n\n\tgf_isom_box_array_del(mov->TopBoxes);\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tgf_isom_box_array_del(mov->moof_list);\n\tif (mov->mfra)\n\t\tgf_isom_box_del((GF_Box*)mov->mfra);\n\tif (mov->sidx_pts_store)\n\t\tgf_free(mov->sidx_pts_store);\n\tif (mov->sidx_pts_next_store)\n\t\tgf_free(mov->sidx_pts_next_store);\n\n\tif (mov->main_sidx)\n\t\tgf_isom_box_del((GF_Box*)mov->main_sidx);\n\n\tif (mov->block_buffer)\n\t\tgf_free(mov->block_buffer);\n#endif\n\tif (mov->last_producer_ref_time)\n\t\tgf_isom_box_del((GF_Box *) mov->last_producer_ref_time);\n\tif (mov->fileName) gf_free(mov->fileName);\n\tgf_free(mov);\n}\n\nGF_TrackBox *gf_isom_get_track_from_id(GF_MovieBox *moov, GF_ISOTrackID trackID)\n{\n\tu32 i, count;\n\tif (!moov || !trackID) return NULL;\n\n\tcount = gf_list_count(moov->trackList);\n\tfor (i = 0; i<count; i++) {\n\t\tGF_TrackBox *trak = (GF_TrackBox*)gf_list_get(moov->trackList, i);\n\t\tif (trak->Header->trackID == trackID) return trak;\n\t}\n\treturn NULL;\n}\n\nGF_TrackBox *gf_isom_get_track_from_original_id(GF_MovieBox *moov, u32 originalID, u32 originalFile)\n{\n\tu32 i, count;\n\tif (!moov || !originalID) return NULL;\n\n\tcount = gf_list_count(moov->trackList);\n\tfor (i = 0; i<count; i++) {\n\t\tGF_TrackBox *trak = (GF_TrackBox*)gf_list_get(moov->trackList, i);\n\t\tif ((trak->originalFile == originalFile) && (trak->originalID == originalID)) return trak;\n\t}\n\treturn NULL;\n}\n\nGF_TrackBox *gf_isom_get_track_from_file(GF_ISOFile *movie, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\tif (!movie) return NULL;\n\ttrak = gf_isom_get_track(movie->moov, trackNumber);\n\tif (!trak) movie->LastError = GF_BAD_PARAM;\n\treturn trak;\n}\n\n\n//WARNING: MOVIETIME IS EXPRESSED IN MEDIA TS\nGF_Err GetMediaTime(GF_TrackBox *trak, Bool force_non_empty, u64 movieTime, u64 *MediaTime, s64 *SegmentStartTime, s64 *MediaOffset, u8 *useEdit, u64 *next_edit_start_plus_one)\n{\n#if 0\n\tGF_Err e;\n\tu32 sampleNumber, prevSampleNumber;\n\tu64 firstDTS;\n#endif\n\tu32 i, count;\n\tBool last_is_empty = 0;\n\tu64 time, lastSampleTime;\n\ts64 mtime;\n\tGF_EdtsEntry *ent;\n\tDouble scale_ts;\n\tGF_SampleTableBox *stbl = trak->Media->information->sampleTable;\n\n\tif (next_edit_start_plus_one) *next_edit_start_plus_one = 0;\n\t*useEdit = 1;\n\t*MediaTime = 0;\n\t//no segment yet...\n\t*SegmentStartTime = -1;\n\t*MediaOffset = -1;\n\tif (!trak->moov->mvhd->timeScale || !trak->Media->mediaHeader->timeScale || !stbl->SampleSize) {\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\t//no samples...\n\tif (!stbl->SampleSize->sampleCount) {\n\t\tlastSampleTime = 0;\n\t} else {\n\t\tlastSampleTime = trak->Media->mediaHeader->duration;\n\t}\n\n\t//No edits, 1 to 1 mapping\n\tif (! trak->editBox || !trak->editBox->editList) {\n\t\t*MediaTime = movieTime;\n\t\t//check this is in our media time line\n\t\tif ((*MediaTime > lastSampleTime)\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\t        && !trak->moov->mov->moof\n#endif\n\t\t   ) {\n\t\t\t*MediaTime = lastSampleTime;\n\t\t}\n\t\t*useEdit = 0;\n\t\treturn GF_OK;\n\t}\n\t//browse the edit list and get the time\n\tscale_ts = trak->Media->mediaHeader->timeScale;\n\tscale_ts /= trak->moov->mvhd->timeScale;\n\n\ttime = 0;\n\tent = NULL;\n\tcount=gf_list_count(trak->editBox->editList->entryList);\n\tfor (i=0; i<count; i++) {\n\t\tent = (GF_EdtsEntry *)gf_list_get(trak->editBox->editList->entryList, i);\n\t\tif ( (time + ent->segmentDuration) * scale_ts > movieTime) {\n\t\t\tif (!force_non_empty || (ent->mediaTime >= 0)) {\n\t\t\t\tif (next_edit_start_plus_one) *next_edit_start_plus_one = 1 + (u64) ((time + ent->segmentDuration) * scale_ts);\n\t\t\t\tgoto ent_found;\n\t\t\t}\n\t\t}\n\t\ttime += ent->segmentDuration;\n\t\tlast_is_empty = ent->segmentDuration ? 0 : 1;\n\t}\n\n\tif (last_is_empty) {\n\t\tent = (GF_EdtsEntry *)gf_list_last(trak->editBox->editList->entryList);\n\t\tif (ent->mediaRate == 0x10000) {\n\t\t\t*MediaTime = movieTime + ent->mediaTime;\n\t\t} else {\n\t\t\tent = (GF_EdtsEntry *)gf_list_get(trak->editBox->editList->entryList, 0);\n\t\t\tif (ent->mediaRate == -0x10000) {\n\t\t\t\tu64 dur = (u64) (ent->segmentDuration * scale_ts);\n\t\t\t\t*MediaTime = (movieTime > dur) ? (movieTime-dur) : 0;\n\t\t\t}\n\t\t}\n\t\t*useEdit = 0;\n\t\treturn GF_OK;\n\t}\n\n\n\t//we had nothing in the list (strange file but compliant...)\n\t//return the 1 to 1 mapped vale of the last media sample\n\tif (!ent) {\n\t\t*MediaTime = movieTime;\n\t\t//check this is in our media time line\n\t\tif (*MediaTime > lastSampleTime) *MediaTime = lastSampleTime;\n\t\t*useEdit = 0;\n\t\treturn GF_OK;\n\t}\n\t//request for a bigger time that what we can give: return the last sample (undefined behavior...)\n\t*MediaTime = lastSampleTime;\n\treturn GF_OK;\n\nent_found:\n\t//OK, we found our entry, set the SegmentTime\n\t*SegmentStartTime = time;\n\n\t//we request an empty list, there's no media here...\n\tif (ent->mediaTime < 0) {\n\t\t*MediaTime = 0;\n\t\treturn GF_OK;\n\t}\n\t//we request a dwell edit\n\tif (! ent->mediaRate) {\n\t\t*MediaTime = ent->mediaTime;\n\t\t//no media offset\n\t\t*MediaOffset = 0;\n\t\t*useEdit = 2;\n\t\treturn GF_OK;\n\t}\n\n\t/*WARNING: this can be \"-1\" when doing searchForward mode (to prevent jumping to next entry)*/\n\tmtime = ent->mediaTime + movieTime - (time * trak->Media->mediaHeader->timeScale / trak->moov->mvhd->timeScale);\n\tif (mtime<0) mtime = 0;\n\t*MediaTime = (u64) mtime;\n\t*MediaOffset = ent->mediaTime;\n\n#if 0\n\t//\n\t//Sanity check: is the requested time valid ? This is to cope with wrong EditLists\n\t//we have the translated time, but we need to make sure we have a sample at this time ...\n\t//we have to find a COMPOSITION time\n\te = stbl_findEntryForTime(stbl, (u32) *MediaTime, 1, &sampleNumber, &prevSampleNumber);\n\tif (e) return e;\n\n\t//first case: our time is after the last sample DTS (it's a broken editList somehow)\n\t//set the media time to the last sample\n\tif (!sampleNumber && !prevSampleNumber) {\n\t\t*MediaTime = lastSampleTime;\n\t\treturn GF_OK;\n\t}\n\t//get the appropriated sample\n\tif (!sampleNumber) sampleNumber = prevSampleNumber;\n\n\tstbl_GetSampleDTS(stbl->TimeToSample, sampleNumber, &DTS);\n\tCTS = 0;\n\tif (stbl->CompositionOffset) stbl_GetSampleCTS(stbl->CompositionOffset, sampleNumber, &CTS);\n\n\t//now get the entry sample (the entry time gives the CTS, and we need the DTS\n\te = stbl_findEntryForTime(stbl, (u32) ent->mediaTime, 0, &sampleNumber, &prevSampleNumber);\n\tif (e) return e;\n\n\t//oops, the mediaTime indicates a sample that is not in our media !\n\tif (!sampleNumber && !prevSampleNumber) {\n\t\t*MediaTime = lastSampleTime;\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\tif (!sampleNumber) sampleNumber = prevSampleNumber;\n\n\tstbl_GetSampleDTS(stbl->TimeToSample, sampleNumber, &firstDTS);\n\n\t//and store the \"time offset\" of the desired sample in this segment\n\t//this is weird, used to rebuild the timeStamp when reading from the track, not the\n\t//media ...\n\t*MediaOffset = firstDTS;\n#endif\n\treturn GF_OK;\n}\n\nGF_Err GetNextMediaTime(GF_TrackBox *trak, u64 movieTime, u64 *OutMovieTime)\n{\n\tu32 i;\n\tu64 time;\n\tGF_EdtsEntry *ent;\n\n\t*OutMovieTime = 0;\n\tif (! trak->editBox || !trak->editBox->editList) return GF_BAD_PARAM;\n\n\ttime = 0;\n\tent = NULL;\n\ti=0;\n\twhile ((ent = (GF_EdtsEntry *)gf_list_enum(trak->editBox->editList->entryList, &i))) {\n\t\tif (time * trak->Media->mediaHeader->timeScale >= movieTime * trak->moov->mvhd->timeScale) {\n\t\t\t/*skip empty edits*/\n\t\t\tif (ent->mediaTime >= 0) {\n\t\t\t\t*OutMovieTime = time * trak->Media->mediaHeader->timeScale / trak->moov->mvhd->timeScale;\n\t\t\t\tif (*OutMovieTime>0) *OutMovieTime -= 1;\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t}\n\t\ttime += ent->segmentDuration;\n\t}\n\t//request for a bigger time that what we can give: return the last sample (undefined behavior...)\n\t*OutMovieTime = trak->moov->mvhd->duration;\n\treturn GF_EOS;\n}\n\nGF_Err GetPrevMediaTime(GF_TrackBox *trak, u64 movieTime, u64 *OutMovieTime)\n{\n\tu32 i;\n\tu64 time;\n\tGF_EdtsEntry *ent;\n\n\t*OutMovieTime = 0;\n\tif (! trak->editBox || !trak->editBox->editList) return GF_BAD_PARAM;\n\n\ttime = 0;\n\tent = NULL;\n\ti=0;\n\twhile ((ent = (GF_EdtsEntry *)gf_list_enum(trak->editBox->editList->entryList, &i))) {\n\t\tif (ent->mediaTime == -1) {\n\t\t\tif ( (time + ent->segmentDuration) * trak->Media->mediaHeader->timeScale >= movieTime * trak->moov->mvhd->timeScale) {\n\t\t\t\t*OutMovieTime = time * trak->Media->mediaHeader->timeScale / trak->moov->mvhd->timeScale;\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\t/*get the first entry whose end is greater than or equal to the desired time*/\n\t\ttime += ent->segmentDuration;\n\t\tif ( time * trak->Media->mediaHeader->timeScale >= movieTime * trak->moov->mvhd->timeScale) {\n\t\t\t*OutMovieTime = time * trak->Media->mediaHeader->timeScale / trak->moov->mvhd->timeScale;\n\t\t\treturn GF_OK;\n\t\t}\n\t}\n\t*OutMovieTime = 0;\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err gf_isom_insert_moov(GF_ISOFile *file)\n{\n\tGF_MovieHeaderBox *mvhd;\n\tif (file->moov) return GF_OK;\n\n\t//OK, create our boxes (mvhd, iods, ...)\n\tfile->moov = (GF_MovieBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_MOOV);\n\tif (!file->moov) return GF_OUT_OF_MEM;\n\tfile->moov->mov = file;\n\t//Header SetUp\n\tmvhd = (GF_MovieHeaderBox *) gf_isom_box_new_parent(&file->moov->child_boxes, GF_ISOM_BOX_TYPE_MVHD);\n\tif (!mvhd) return GF_OUT_OF_MEM;\n\n\tif (gf_sys_is_test_mode() ) {\n\t\tmvhd->creationTime = mvhd->modificationTime = 0;\n\t} else {\n\t\tu64 now = gf_isom_get_mp4time();\n\t\tmvhd->creationTime = now;\n\t\tif (!file->keep_utc)\n\t\t\tmvhd->modificationTime = now;\n\t}\n\n\tmvhd->nextTrackID = 1;\n\t//600 is our default movie TimeScale\n\tmvhd->timeScale = 600;\n\n\tfile->interleavingTime = mvhd->timeScale;\n\tmoov_on_child_box((GF_Box*)file->moov, (GF_Box *)mvhd, GF_FALSE);\n\tgf_list_add(file->TopBoxes, file->moov);\n\treturn GF_OK;\n}\n\n//Create the movie for WRITE only\nGF_ISOFile *gf_isom_create_movie(const char *fileName, GF_ISOOpenMode OpenMode, const char *tmp_dir)\n{\n\tGF_Err e;\n\n\tGF_ISOFile *mov = gf_isom_new_movie();\n\tif (!mov) return NULL;\n\tmov->openMode = OpenMode;\n\t//then set up our movie\n\n\t//in WRITE, the input dataMap is ALWAYS NULL\n\tmov->movieFileMap = NULL;\n\n\t//but we have the edit one\n\tif (OpenMode == GF_ISOM_OPEN_WRITE) {\n\t\tconst char *ext;\n\t\t//THIS IS NOT A TEMP FILE, WRITE mode is used for \"live capture\"\n\t\t//this file will be the final file...\n\t\tmov->fileName = fileName ? gf_strdup(fileName) : NULL;\n\t\te = gf_isom_datamap_new(fileName, NULL, GF_ISOM_DATA_MAP_WRITE, &mov->editFileMap);\n\t\tif (e) goto err_exit;\n\n\t\t/*brand is set to ISOM or QT by default - it may be touched until sample data is added to track*/\n\t\text = gf_file_ext_start(fileName);\n\t\tif (ext && (!strnicmp(ext, \".mov\", 4) || !strnicmp(ext, \".qt\", 3))) {\n\t\t\tgf_isom_set_brand_info((GF_ISOFile *) mov, GF_ISOM_BRAND_QT, 512);\n\t\t} else {\n\t\t\tgf_isom_set_brand_info((GF_ISOFile *) mov, GF_ISOM_BRAND_ISOM, 1);\n\t\t}\n\t} else {\n\t\t//we are in EDIT mode but we are creating the file -> temp file\n\t\tmov->finalName = fileName ? gf_strdup(fileName) : NULL;\n\t\te = gf_isom_datamap_new(\"_gpac_isobmff_tmp_edit\", tmp_dir, GF_ISOM_DATA_MAP_WRITE, &mov->editFileMap);\n\t\tif (e) {\n\t\t\tgf_isom_set_last_error(NULL, e);\n\t\t\tgf_isom_delete_movie(mov);\n\t\t\treturn NULL;\n\t\t}\n\t\t//brand is set to ISOM by default\n\t\tgf_isom_set_brand_info( (GF_ISOFile *) mov, GF_ISOM_BRAND_ISOM, 1);\n\t}\n\n\t//create an MDAT\n\tmov->mdat = (GF_MediaDataBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_MDAT);\n\tif (!mov->mdat) {\n\t\tgf_isom_set_last_error(NULL, GF_OUT_OF_MEM);\n\t\tgf_isom_delete_movie(mov);\n\t\treturn NULL;\n\t}\n\tgf_list_add(mov->TopBoxes, mov->mdat);\n\n\t//default behavior is capture mode, no interleaving (eg, no rewrite of mdat)\n\tmov->storageMode = GF_ISOM_STORE_FLAT;\n\treturn mov;\n\nerr_exit:\n\tgf_isom_set_last_error(NULL, e);\n\tif (mov) gf_isom_delete_movie(mov);\n\treturn NULL;\n}\n\nGF_EdtsEntry *CreateEditEntry(u64 EditDuration, u64 MediaTime, u8 EditMode)\n{\n\tGF_EdtsEntry *ent;\n\n\tent = (GF_EdtsEntry*)gf_malloc(sizeof(GF_EdtsEntry));\n\tif (!ent) return NULL;\n\n\tswitch (EditMode) {\n\tcase GF_ISOM_EDIT_EMPTY:\n\t\tent->mediaRate = 0x10000;\n\t\tent->mediaTime = -1;\n\t\tbreak;\n\n\tcase GF_ISOM_EDIT_DWELL:\n\t\tent->mediaRate = 0;\n\t\tent->mediaTime = MediaTime;\n\t\tbreak;\n\tdefault:\n\t\tent->mediaRate = 0x10000;\n\t\tent->mediaTime = MediaTime;\n\t\tbreak;\n\t}\n\tent->segmentDuration = EditDuration;\n\treturn ent;\n}\n\nGF_Err gf_isom_add_subsample_info(GF_SubSampleInformationBox *sub_samples, u32 sampleNumber, u32 subSampleSize, u8 priority, u32 reserved, Bool discardable)\n{\n\tu32 i, count, last_sample;\n\tGF_SubSampleInfoEntry *pSamp;\n\tGF_SubSampleEntry *pSubSamp;\n\n\tpSamp = NULL;\n\tlast_sample = 0;\n\tcount = gf_list_count(sub_samples->Samples);\n\tfor (i=0; i<count; i++) {\n\t\tpSamp = (GF_SubSampleInfoEntry*) gf_list_get(sub_samples->Samples, i);\n\t\t/*TODO - do we need to support insertion of subsample info ?*/\n\t\tif (last_sample + pSamp->sample_delta > sampleNumber) return GF_NOT_SUPPORTED;\n\t\tif (last_sample + pSamp->sample_delta == sampleNumber) break;\n\t\tlast_sample += pSamp->sample_delta;\n\t\tpSamp = NULL;\n\t}\n\n\tif (!pSamp) {\n\t\tGF_SAFEALLOC(pSamp, GF_SubSampleInfoEntry);\n\t\tif (!pSamp) return GF_OUT_OF_MEM;\n\t\tpSamp->SubSamples = gf_list_new();\n\t\tif (!pSamp->SubSamples ) {\n\t\t\tgf_free(pSamp);\n\t\t\treturn GF_OUT_OF_MEM;\n\t\t}\n\t\tpSamp->sample_delta = sampleNumber - last_sample;\n\t\tgf_list_add(sub_samples->Samples, pSamp);\n\t}\n\n\tif ((subSampleSize>0xFFFF) && !sub_samples->version) {\n\t\tsub_samples->version = 1;\n\t}\n\t/*remove last subsample info*/\n\tif (!subSampleSize) {\n\t\tpSubSamp = gf_list_last(pSamp->SubSamples);\n\t\tgf_list_rem_last(pSamp->SubSamples);\n\t\tgf_free(pSubSamp);\n\t\tif (!gf_list_count(pSamp->SubSamples)) {\n\t\t\tgf_list_del_item(sub_samples->Samples, pSamp);\n\t\t\tgf_list_del(pSamp->SubSamples);\n\t\t\tgf_free(pSamp);\n\t\t}\n\t\treturn GF_OK;\n\t}\n\t/*add subsample*/\n\tGF_SAFEALLOC(pSubSamp, GF_SubSampleEntry);\n\tif (!pSubSamp) return GF_OUT_OF_MEM;\n\tpSubSamp->subsample_size = subSampleSize;\n\tpSubSamp->subsample_priority = priority;\n\tpSubSamp->reserved = reserved;\n\tpSubSamp->discardable = discardable;\n\treturn gf_list_add(pSamp->SubSamples, pSubSamp);\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n#if 0 //unused\nu32 gf_isom_sample_get_subsamples_count(GF_ISOFile *movie, u32 track)\n{\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(movie, track);\n\tif (!track) return 0;\n\tif (!trak->Media || !trak->Media->information->sampleTable || !trak->Media->information->sampleTable->sub_samples) return 0;\n\treturn gf_list_count(trak->Media->information->sampleTable->sub_samples);\n}\n#endif\n\nBool gf_isom_get_subsample_types(GF_ISOFile *movie, u32 track, u32 subs_index, u32 *flags)\n{\n\tGF_SubSampleInformationBox *sub_samples=NULL;\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(movie, track);\n\n\tif (!track || !subs_index) return GF_FALSE;\n\tif (!trak->Media || !trak->Media->information->sampleTable || !trak->Media->information->sampleTable->sub_samples) return GF_FALSE;\n\tsub_samples = gf_list_get(trak->Media->information->sampleTable->sub_samples, subs_index-1);\n\tif (!sub_samples) return GF_FALSE;\n\t*flags = sub_samples->flags;\n\treturn GF_TRUE;\n}\n\nu32 gf_isom_sample_get_subsample_entry(GF_ISOFile *movie, u32 track, u32 sampleNumber, u32 flags, GF_SubSampleInfoEntry **sub_sample)\n{\n\tu32 i, count, last_sample;\n\tGF_SubSampleInformationBox *sub_samples=NULL;\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(movie, track);\n\tif (sub_sample) *sub_sample = NULL;\n\tif (!track) return 0;\n\tif (!trak->Media || !trak->Media->information->sampleTable || !trak->Media->information->sampleTable->sub_samples) return 0;\n\tcount = gf_list_count(trak->Media->information->sampleTable->sub_samples);\n\tfor (i=0; i<count; i++) {\n\t\tsub_samples = gf_list_get(trak->Media->information->sampleTable->sub_samples, i);\n\t\tif (sub_samples->flags==flags) break;\n\t\tsub_samples = NULL;\n\t}\n\tif (!sub_samples) return 0;\n\n\tlast_sample = 0;\n\tcount = gf_list_count(sub_samples->Samples);\n\tfor (i=0; i<count; i++) {\n\t\tGF_SubSampleInfoEntry *pSamp = (GF_SubSampleInfoEntry *) gf_list_get(sub_samples->Samples, i);\n\t\tif (last_sample + pSamp->sample_delta == sampleNumber) {\n\t\t\tif (sub_sample) *sub_sample = pSamp;\n\t\t\treturn gf_list_count(pSamp->SubSamples);\n\t\t}\n\t\tlast_sample += pSamp->sample_delta;\n\t}\n\treturn 0;\n}\n#endif /*GPAC_DISABLE_ISOM*/\n"], "filenames": ["src/isomedia/isom_intern.c"], "buggy_code_start_loc": [499], "buggy_code_end_loc": [499], "fixing_code_start_loc": [500], "fixing_code_end_loc": [501], "type": "CWE-401", "message": "Memory leak in the def_parent_box_new function in MP4Box in GPAC 1.0.1 allows attackers to read memory via a crafted file.", "other": {"cve": {"id": "CVE-2021-33364", "sourceIdentifier": "cve@mitre.org", "published": "2021-09-13T19:15:13.987", "lastModified": "2023-05-27T04:15:15.633", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Memory leak in the def_parent_box_new function in MP4Box in GPAC 1.0.1 allows attackers to read memory via a crafted file."}, {"lang": "es", "value": "Un p\u00e9rdida de memoria en la funci\u00f3n def_parent_box_new de MP4Box en GPAC 1.0.1, permite a atacantes leer memoria por medio de un archivo dise\u00f1ado"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:N/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-401"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:gpac:gpac:1.0.1:*:*:*:*:*:*:*", "matchCriteriaId": "82DD2D40-0A05-48FD-940D-32B4D8B51AB3"}]}]}], "references": [{"url": "https://github.com/gpac/gpac/commit/fe5155cf047252d1c4cb91602048bfa682af0ea7", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/gpac/gpac/issues/1783", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://www.debian.org/security/2023/dsa-5411", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/gpac/gpac/commit/fe5155cf047252d1c4cb91602048bfa682af0ea7"}}