{"buggy_code": ["/*\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * Copyright (C) Jonathan Naylor G4KLX (g4klx@g4klx.demon.co.uk)\n */\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/socket.h>\n#include <linux/in.h>\n#include <linux/kernel.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/sockios.h>\n#include <linux/net.h>\n#include <linux/slab.h>\n#include <net/ax25.h>\n#include <linux/inet.h>\n#include <linux/netdevice.h>\n#include <linux/skbuff.h>\n#include <net/sock.h>\n#include <net/tcp_states.h>\n#include <asm/system.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/interrupt.h>\n#include <net/rose.h>\n\nstatic int rose_create_facilities(unsigned char *buffer, struct rose_sock *rose);\n\n/*\n *\tThis routine purges all of the queues of frames.\n */\nvoid rose_clear_queues(struct sock *sk)\n{\n\tskb_queue_purge(&sk->sk_write_queue);\n\tskb_queue_purge(&rose_sk(sk)->ack_queue);\n}\n\n/*\n * This routine purges the input queue of those frames that have been\n * acknowledged. This replaces the boxes labelled \"V(a) <- N(r)\" on the\n * SDL diagram.\n */\nvoid rose_frames_acked(struct sock *sk, unsigned short nr)\n{\n\tstruct sk_buff *skb;\n\tstruct rose_sock *rose = rose_sk(sk);\n\n\t/*\n\t * Remove all the ack-ed frames from the ack queue.\n\t */\n\tif (rose->va != nr) {\n\t\twhile (skb_peek(&rose->ack_queue) != NULL && rose->va != nr) {\n\t\t\tskb = skb_dequeue(&rose->ack_queue);\n\t\t\tkfree_skb(skb);\n\t\t\trose->va = (rose->va + 1) % ROSE_MODULUS;\n\t\t}\n\t}\n}\n\nvoid rose_requeue_frames(struct sock *sk)\n{\n\tstruct sk_buff *skb, *skb_prev = NULL;\n\n\t/*\n\t * Requeue all the un-ack-ed frames on the output queue to be picked\n\t * up by rose_kick. This arrangement handles the possibility of an\n\t * empty output queue.\n\t */\n\twhile ((skb = skb_dequeue(&rose_sk(sk)->ack_queue)) != NULL) {\n\t\tif (skb_prev == NULL)\n\t\t\tskb_queue_head(&sk->sk_write_queue, skb);\n\t\telse\n\t\t\tskb_append(skb_prev, skb, &sk->sk_write_queue);\n\t\tskb_prev = skb;\n\t}\n}\n\n/*\n *\tValidate that the value of nr is between va and vs. Return true or\n *\tfalse for testing.\n */\nint rose_validate_nr(struct sock *sk, unsigned short nr)\n{\n\tstruct rose_sock *rose = rose_sk(sk);\n\tunsigned short vc = rose->va;\n\n\twhile (vc != rose->vs) {\n\t\tif (nr == vc) return 1;\n\t\tvc = (vc + 1) % ROSE_MODULUS;\n\t}\n\n\treturn nr == rose->vs;\n}\n\n/*\n *  This routine is called when the packet layer internally generates a\n *  control frame.\n */\nvoid rose_write_internal(struct sock *sk, int frametype)\n{\n\tstruct rose_sock *rose = rose_sk(sk);\n\tstruct sk_buff *skb;\n\tunsigned char  *dptr;\n\tunsigned char  lci1, lci2;\n\tchar buffer[100];\n\tint len, faclen = 0;\n\n\tlen = AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN + 1;\n\n\tswitch (frametype) {\n\tcase ROSE_CALL_REQUEST:\n\t\tlen   += 1 + ROSE_ADDR_LEN + ROSE_ADDR_LEN;\n\t\tfaclen = rose_create_facilities(buffer, rose);\n\t\tlen   += faclen;\n\t\tbreak;\n\tcase ROSE_CALL_ACCEPTED:\n\tcase ROSE_CLEAR_REQUEST:\n\tcase ROSE_RESET_REQUEST:\n\t\tlen   += 2;\n\t\tbreak;\n\t}\n\n\tif ((skb = alloc_skb(len, GFP_ATOMIC)) == NULL)\n\t\treturn;\n\n\t/*\n\t *\tSpace for AX.25 header and PID.\n\t */\n\tskb_reserve(skb, AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + 1);\n\n\tdptr = skb_put(skb, skb_tailroom(skb));\n\n\tlci1 = (rose->lci >> 8) & 0x0F;\n\tlci2 = (rose->lci >> 0) & 0xFF;\n\n\tswitch (frametype) {\n\tcase ROSE_CALL_REQUEST:\n\t\t*dptr++ = ROSE_GFI | lci1;\n\t\t*dptr++ = lci2;\n\t\t*dptr++ = frametype;\n\t\t*dptr++ = 0xAA;\n\t\tmemcpy(dptr, &rose->dest_addr,  ROSE_ADDR_LEN);\n\t\tdptr   += ROSE_ADDR_LEN;\n\t\tmemcpy(dptr, &rose->source_addr, ROSE_ADDR_LEN);\n\t\tdptr   += ROSE_ADDR_LEN;\n\t\tmemcpy(dptr, buffer, faclen);\n\t\tdptr   += faclen;\n\t\tbreak;\n\n\tcase ROSE_CALL_ACCEPTED:\n\t\t*dptr++ = ROSE_GFI | lci1;\n\t\t*dptr++ = lci2;\n\t\t*dptr++ = frametype;\n\t\t*dptr++ = 0x00;\t\t/* Address length */\n\t\t*dptr++ = 0;\t\t/* Facilities length */\n\t\tbreak;\n\n\tcase ROSE_CLEAR_REQUEST:\n\t\t*dptr++ = ROSE_GFI | lci1;\n\t\t*dptr++ = lci2;\n\t\t*dptr++ = frametype;\n\t\t*dptr++ = rose->cause;\n\t\t*dptr++ = rose->diagnostic;\n\t\tbreak;\n\n\tcase ROSE_RESET_REQUEST:\n\t\t*dptr++ = ROSE_GFI | lci1;\n\t\t*dptr++ = lci2;\n\t\t*dptr++ = frametype;\n\t\t*dptr++ = ROSE_DTE_ORIGINATED;\n\t\t*dptr++ = 0;\n\t\tbreak;\n\n\tcase ROSE_RR:\n\tcase ROSE_RNR:\n\t\t*dptr++ = ROSE_GFI | lci1;\n\t\t*dptr++ = lci2;\n\t\t*dptr   = frametype;\n\t\t*dptr++ |= (rose->vr << 5) & 0xE0;\n\t\tbreak;\n\n\tcase ROSE_CLEAR_CONFIRMATION:\n\tcase ROSE_RESET_CONFIRMATION:\n\t\t*dptr++ = ROSE_GFI | lci1;\n\t\t*dptr++ = lci2;\n\t\t*dptr++  = frametype;\n\t\tbreak;\n\n\tdefault:\n\t\tprintk(KERN_ERR \"ROSE: rose_write_internal - invalid frametype %02X\\n\", frametype);\n\t\tkfree_skb(skb);\n\t\treturn;\n\t}\n\n\trose_transmit_link(skb, rose->neighbour);\n}\n\nint rose_decode(struct sk_buff *skb, int *ns, int *nr, int *q, int *d, int *m)\n{\n\tunsigned char *frame;\n\n\tframe = skb->data;\n\n\t*ns = *nr = *q = *d = *m = 0;\n\n\tswitch (frame[2]) {\n\tcase ROSE_CALL_REQUEST:\n\tcase ROSE_CALL_ACCEPTED:\n\tcase ROSE_CLEAR_REQUEST:\n\tcase ROSE_CLEAR_CONFIRMATION:\n\tcase ROSE_RESET_REQUEST:\n\tcase ROSE_RESET_CONFIRMATION:\n\t\treturn frame[2];\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif ((frame[2] & 0x1F) == ROSE_RR  ||\n\t    (frame[2] & 0x1F) == ROSE_RNR) {\n\t\t*nr = (frame[2] >> 5) & 0x07;\n\t\treturn frame[2] & 0x1F;\n\t}\n\n\tif ((frame[2] & 0x01) == ROSE_DATA) {\n\t\t*q  = (frame[0] & ROSE_Q_BIT) == ROSE_Q_BIT;\n\t\t*d  = (frame[0] & ROSE_D_BIT) == ROSE_D_BIT;\n\t\t*m  = (frame[2] & ROSE_M_BIT) == ROSE_M_BIT;\n\t\t*nr = (frame[2] >> 5) & 0x07;\n\t\t*ns = (frame[2] >> 1) & 0x07;\n\t\treturn ROSE_DATA;\n\t}\n\n\treturn ROSE_ILLEGAL;\n}\n\nstatic int rose_parse_national(unsigned char *p, struct rose_facilities_struct *facilities, int len)\n{\n\tunsigned char *pt;\n\tunsigned char l, lg, n = 0;\n\tint fac_national_digis_received = 0;\n\n\tdo {\n\t\tswitch (*p & 0xC0) {\n\t\tcase 0x00:\n\t\t\tp   += 2;\n\t\t\tn   += 2;\n\t\t\tlen -= 2;\n\t\t\tbreak;\n\n\t\tcase 0x40:\n\t\t\tif (*p == FAC_NATIONAL_RAND)\n\t\t\t\tfacilities->rand = ((p[1] << 8) & 0xFF00) + ((p[2] << 0) & 0x00FF);\n\t\t\tp   += 3;\n\t\t\tn   += 3;\n\t\t\tlen -= 3;\n\t\t\tbreak;\n\n\t\tcase 0x80:\n\t\t\tp   += 4;\n\t\t\tn   += 4;\n\t\t\tlen -= 4;\n\t\t\tbreak;\n\n\t\tcase 0xC0:\n\t\t\tl = p[1];\n\t\t\tif (*p == FAC_NATIONAL_DEST_DIGI) {\n\t\t\t\tif (!fac_national_digis_received) {\n\t\t\t\t\tmemcpy(&facilities->source_digis[0], p + 2, AX25_ADDR_LEN);\n\t\t\t\t\tfacilities->source_ndigis = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (*p == FAC_NATIONAL_SRC_DIGI) {\n\t\t\t\tif (!fac_national_digis_received) {\n\t\t\t\t\tmemcpy(&facilities->dest_digis[0], p + 2, AX25_ADDR_LEN);\n\t\t\t\t\tfacilities->dest_ndigis = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (*p == FAC_NATIONAL_FAIL_CALL) {\n\t\t\t\tmemcpy(&facilities->fail_call, p + 2, AX25_ADDR_LEN);\n\t\t\t}\n\t\t\telse if (*p == FAC_NATIONAL_FAIL_ADD) {\n\t\t\t\tmemcpy(&facilities->fail_addr, p + 3, ROSE_ADDR_LEN);\n\t\t\t}\n\t\t\telse if (*p == FAC_NATIONAL_DIGIS) {\n\t\t\t\tfac_national_digis_received = 1;\n\t\t\t\tfacilities->source_ndigis = 0;\n\t\t\t\tfacilities->dest_ndigis   = 0;\n\t\t\t\tfor (pt = p + 2, lg = 0 ; lg < l ; pt += AX25_ADDR_LEN, lg += AX25_ADDR_LEN) {\n\t\t\t\t\tif (pt[6] & AX25_HBIT)\n\t\t\t\t\t\tmemcpy(&facilities->dest_digis[facilities->dest_ndigis++], pt, AX25_ADDR_LEN);\n\t\t\t\t\telse\n\t\t\t\t\t\tmemcpy(&facilities->source_digis[facilities->source_ndigis++], pt, AX25_ADDR_LEN);\n\t\t\t\t}\n\t\t\t}\n\t\t\tp   += l + 2;\n\t\t\tn   += l + 2;\n\t\t\tlen -= l + 2;\n\t\t\tbreak;\n\t\t}\n\t} while (*p != 0x00 && len > 0);\n\n\treturn n;\n}\n\nstatic int rose_parse_ccitt(unsigned char *p, struct rose_facilities_struct *facilities, int len)\n{\n\tunsigned char l, n = 0;\n\tchar callsign[11];\n\n\tdo {\n\t\tswitch (*p & 0xC0) {\n\t\tcase 0x00:\n\t\t\tp   += 2;\n\t\t\tn   += 2;\n\t\t\tlen -= 2;\n\t\t\tbreak;\n\n\t\tcase 0x40:\n\t\t\tp   += 3;\n\t\t\tn   += 3;\n\t\t\tlen -= 3;\n\t\t\tbreak;\n\n\t\tcase 0x80:\n\t\t\tp   += 4;\n\t\t\tn   += 4;\n\t\t\tlen -= 4;\n\t\t\tbreak;\n\n\t\tcase 0xC0:\n\t\t\tl = p[1];\n\t\t\tif (*p == FAC_CCITT_DEST_NSAP) {\n\t\t\t\tmemcpy(&facilities->source_addr, p + 7, ROSE_ADDR_LEN);\n\t\t\t\tmemcpy(callsign, p + 12,   l - 10);\n\t\t\t\tcallsign[l - 10] = '\\0';\n\t\t\t\tasc2ax(&facilities->source_call, callsign);\n\t\t\t}\n\t\t\tif (*p == FAC_CCITT_SRC_NSAP) {\n\t\t\t\tmemcpy(&facilities->dest_addr, p + 7, ROSE_ADDR_LEN);\n\t\t\t\tmemcpy(callsign, p + 12, l - 10);\n\t\t\t\tcallsign[l - 10] = '\\0';\n\t\t\t\tasc2ax(&facilities->dest_call, callsign);\n\t\t\t}\n\t\t\tp   += l + 2;\n\t\t\tn   += l + 2;\n\t\t\tlen -= l + 2;\n\t\t\tbreak;\n\t\t}\n\t} while (*p != 0x00 && len > 0);\n\n\treturn n;\n}\n\nint rose_parse_facilities(unsigned char *p,\n\tstruct rose_facilities_struct *facilities)\n{\n\tint facilities_len, len;\n\n\tfacilities_len = *p++;\n\n\tif (facilities_len == 0)\n\t\treturn 0;\n\n\twhile (facilities_len > 0) {\n\t\tif (*p == 0x00) {\n\t\t\tfacilities_len--;\n\t\t\tp++;\n\n\t\t\tswitch (*p) {\n\t\t\tcase FAC_NATIONAL:\t\t/* National */\n\t\t\t\tlen = rose_parse_national(p + 1, facilities, facilities_len - 1);\n\t\t\t\tfacilities_len -= len + 1;\n\t\t\t\tp += len + 1;\n\t\t\t\tbreak;\n\n\t\t\tcase FAC_CCITT:\t\t/* CCITT */\n\t\t\t\tlen = rose_parse_ccitt(p + 1, facilities, facilities_len - 1);\n\t\t\t\tfacilities_len -= len + 1;\n\t\t\t\tp += len + 1;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tprintk(KERN_DEBUG \"ROSE: rose_parse_facilities - unknown facilities family %02X\\n\", *p);\n\t\t\t\tfacilities_len--;\n\t\t\t\tp++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else\n\t\t\tbreak;\t/* Error in facilities format */\n\t}\n\n\treturn 1;\n}\n\nstatic int rose_create_facilities(unsigned char *buffer, struct rose_sock *rose)\n{\n\tunsigned char *p = buffer + 1;\n\tchar *callsign;\n\tchar buf[11];\n\tint len, nb;\n\n\t/* National Facilities */\n\tif (rose->rand != 0 || rose->source_ndigis == 1 || rose->dest_ndigis == 1) {\n\t\t*p++ = 0x00;\n\t\t*p++ = FAC_NATIONAL;\n\n\t\tif (rose->rand != 0) {\n\t\t\t*p++ = FAC_NATIONAL_RAND;\n\t\t\t*p++ = (rose->rand >> 8) & 0xFF;\n\t\t\t*p++ = (rose->rand >> 0) & 0xFF;\n\t\t}\n\n\t\t/* Sent before older facilities */\n\t\tif ((rose->source_ndigis > 0) || (rose->dest_ndigis > 0)) {\n\t\t\tint maxdigi = 0;\n\t\t\t*p++ = FAC_NATIONAL_DIGIS;\n\t\t\t*p++ = AX25_ADDR_LEN * (rose->source_ndigis + rose->dest_ndigis);\n\t\t\tfor (nb = 0 ; nb < rose->source_ndigis ; nb++) {\n\t\t\t\tif (++maxdigi >= ROSE_MAX_DIGIS)\n\t\t\t\t\tbreak;\n\t\t\t\tmemcpy(p, &rose->source_digis[nb], AX25_ADDR_LEN);\n\t\t\t\tp[6] |= AX25_HBIT;\n\t\t\t\tp += AX25_ADDR_LEN;\n\t\t\t}\n\t\t\tfor (nb = 0 ; nb < rose->dest_ndigis ; nb++) {\n\t\t\t\tif (++maxdigi >= ROSE_MAX_DIGIS)\n\t\t\t\t\tbreak;\n\t\t\t\tmemcpy(p, &rose->dest_digis[nb], AX25_ADDR_LEN);\n\t\t\t\tp[6] &= ~AX25_HBIT;\n\t\t\t\tp += AX25_ADDR_LEN;\n\t\t\t}\n\t\t}\n\n\t\t/* For compatibility */\n\t\tif (rose->source_ndigis > 0) {\n\t\t\t*p++ = FAC_NATIONAL_SRC_DIGI;\n\t\t\t*p++ = AX25_ADDR_LEN;\n\t\t\tmemcpy(p, &rose->source_digis[0], AX25_ADDR_LEN);\n\t\t\tp   += AX25_ADDR_LEN;\n\t\t}\n\n\t\t/* For compatibility */\n\t\tif (rose->dest_ndigis > 0) {\n\t\t\t*p++ = FAC_NATIONAL_DEST_DIGI;\n\t\t\t*p++ = AX25_ADDR_LEN;\n\t\t\tmemcpy(p, &rose->dest_digis[0], AX25_ADDR_LEN);\n\t\t\tp   += AX25_ADDR_LEN;\n\t\t}\n\t}\n\n\t*p++ = 0x00;\n\t*p++ = FAC_CCITT;\n\n\t*p++ = FAC_CCITT_DEST_NSAP;\n\n\tcallsign = ax2asc(buf, &rose->dest_call);\n\n\t*p++ = strlen(callsign) + 10;\n\t*p++ = (strlen(callsign) + 9) * 2;\t\t/* ??? */\n\n\t*p++ = 0x47; *p++ = 0x00; *p++ = 0x11;\n\t*p++ = ROSE_ADDR_LEN * 2;\n\tmemcpy(p, &rose->dest_addr, ROSE_ADDR_LEN);\n\tp   += ROSE_ADDR_LEN;\n\n\tmemcpy(p, callsign, strlen(callsign));\n\tp   += strlen(callsign);\n\n\t*p++ = FAC_CCITT_SRC_NSAP;\n\n\tcallsign = ax2asc(buf, &rose->source_call);\n\n\t*p++ = strlen(callsign) + 10;\n\t*p++ = (strlen(callsign) + 9) * 2;\t\t/* ??? */\n\n\t*p++ = 0x47; *p++ = 0x00; *p++ = 0x11;\n\t*p++ = ROSE_ADDR_LEN * 2;\n\tmemcpy(p, &rose->source_addr, ROSE_ADDR_LEN);\n\tp   += ROSE_ADDR_LEN;\n\n\tmemcpy(p, callsign, strlen(callsign));\n\tp   += strlen(callsign);\n\n\tlen       = p - buffer;\n\tbuffer[0] = len - 1;\n\n\treturn len;\n}\n\nvoid rose_disconnect(struct sock *sk, int reason, int cause, int diagnostic)\n{\n\tstruct rose_sock *rose = rose_sk(sk);\n\n\trose_stop_timer(sk);\n\trose_stop_idletimer(sk);\n\n\trose_clear_queues(sk);\n\n\trose->lci   = 0;\n\trose->state = ROSE_STATE_0;\n\n\tif (cause != -1)\n\t\trose->cause = cause;\n\n\tif (diagnostic != -1)\n\t\trose->diagnostic = diagnostic;\n\n\tsk->sk_state     = TCP_CLOSE;\n\tsk->sk_err       = reason;\n\tsk->sk_shutdown |= SEND_SHUTDOWN;\n\n\tif (!sock_flag(sk, SOCK_DEAD)) {\n\t\tsk->sk_state_change(sk);\n\t\tsock_set_flag(sk, SOCK_DEAD);\n\t}\n}\n"], "fixing_code": ["/*\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * Copyright (C) Jonathan Naylor G4KLX (g4klx@g4klx.demon.co.uk)\n */\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/socket.h>\n#include <linux/in.h>\n#include <linux/kernel.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/sockios.h>\n#include <linux/net.h>\n#include <linux/slab.h>\n#include <net/ax25.h>\n#include <linux/inet.h>\n#include <linux/netdevice.h>\n#include <linux/skbuff.h>\n#include <net/sock.h>\n#include <net/tcp_states.h>\n#include <asm/system.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/interrupt.h>\n#include <net/rose.h>\n\nstatic int rose_create_facilities(unsigned char *buffer, struct rose_sock *rose);\n\n/*\n *\tThis routine purges all of the queues of frames.\n */\nvoid rose_clear_queues(struct sock *sk)\n{\n\tskb_queue_purge(&sk->sk_write_queue);\n\tskb_queue_purge(&rose_sk(sk)->ack_queue);\n}\n\n/*\n * This routine purges the input queue of those frames that have been\n * acknowledged. This replaces the boxes labelled \"V(a) <- N(r)\" on the\n * SDL diagram.\n */\nvoid rose_frames_acked(struct sock *sk, unsigned short nr)\n{\n\tstruct sk_buff *skb;\n\tstruct rose_sock *rose = rose_sk(sk);\n\n\t/*\n\t * Remove all the ack-ed frames from the ack queue.\n\t */\n\tif (rose->va != nr) {\n\t\twhile (skb_peek(&rose->ack_queue) != NULL && rose->va != nr) {\n\t\t\tskb = skb_dequeue(&rose->ack_queue);\n\t\t\tkfree_skb(skb);\n\t\t\trose->va = (rose->va + 1) % ROSE_MODULUS;\n\t\t}\n\t}\n}\n\nvoid rose_requeue_frames(struct sock *sk)\n{\n\tstruct sk_buff *skb, *skb_prev = NULL;\n\n\t/*\n\t * Requeue all the un-ack-ed frames on the output queue to be picked\n\t * up by rose_kick. This arrangement handles the possibility of an\n\t * empty output queue.\n\t */\n\twhile ((skb = skb_dequeue(&rose_sk(sk)->ack_queue)) != NULL) {\n\t\tif (skb_prev == NULL)\n\t\t\tskb_queue_head(&sk->sk_write_queue, skb);\n\t\telse\n\t\t\tskb_append(skb_prev, skb, &sk->sk_write_queue);\n\t\tskb_prev = skb;\n\t}\n}\n\n/*\n *\tValidate that the value of nr is between va and vs. Return true or\n *\tfalse for testing.\n */\nint rose_validate_nr(struct sock *sk, unsigned short nr)\n{\n\tstruct rose_sock *rose = rose_sk(sk);\n\tunsigned short vc = rose->va;\n\n\twhile (vc != rose->vs) {\n\t\tif (nr == vc) return 1;\n\t\tvc = (vc + 1) % ROSE_MODULUS;\n\t}\n\n\treturn nr == rose->vs;\n}\n\n/*\n *  This routine is called when the packet layer internally generates a\n *  control frame.\n */\nvoid rose_write_internal(struct sock *sk, int frametype)\n{\n\tstruct rose_sock *rose = rose_sk(sk);\n\tstruct sk_buff *skb;\n\tunsigned char  *dptr;\n\tunsigned char  lci1, lci2;\n\tchar buffer[100];\n\tint len, faclen = 0;\n\n\tlen = AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN + 1;\n\n\tswitch (frametype) {\n\tcase ROSE_CALL_REQUEST:\n\t\tlen   += 1 + ROSE_ADDR_LEN + ROSE_ADDR_LEN;\n\t\tfaclen = rose_create_facilities(buffer, rose);\n\t\tlen   += faclen;\n\t\tbreak;\n\tcase ROSE_CALL_ACCEPTED:\n\tcase ROSE_CLEAR_REQUEST:\n\tcase ROSE_RESET_REQUEST:\n\t\tlen   += 2;\n\t\tbreak;\n\t}\n\n\tif ((skb = alloc_skb(len, GFP_ATOMIC)) == NULL)\n\t\treturn;\n\n\t/*\n\t *\tSpace for AX.25 header and PID.\n\t */\n\tskb_reserve(skb, AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + 1);\n\n\tdptr = skb_put(skb, skb_tailroom(skb));\n\n\tlci1 = (rose->lci >> 8) & 0x0F;\n\tlci2 = (rose->lci >> 0) & 0xFF;\n\n\tswitch (frametype) {\n\tcase ROSE_CALL_REQUEST:\n\t\t*dptr++ = ROSE_GFI | lci1;\n\t\t*dptr++ = lci2;\n\t\t*dptr++ = frametype;\n\t\t*dptr++ = 0xAA;\n\t\tmemcpy(dptr, &rose->dest_addr,  ROSE_ADDR_LEN);\n\t\tdptr   += ROSE_ADDR_LEN;\n\t\tmemcpy(dptr, &rose->source_addr, ROSE_ADDR_LEN);\n\t\tdptr   += ROSE_ADDR_LEN;\n\t\tmemcpy(dptr, buffer, faclen);\n\t\tdptr   += faclen;\n\t\tbreak;\n\n\tcase ROSE_CALL_ACCEPTED:\n\t\t*dptr++ = ROSE_GFI | lci1;\n\t\t*dptr++ = lci2;\n\t\t*dptr++ = frametype;\n\t\t*dptr++ = 0x00;\t\t/* Address length */\n\t\t*dptr++ = 0;\t\t/* Facilities length */\n\t\tbreak;\n\n\tcase ROSE_CLEAR_REQUEST:\n\t\t*dptr++ = ROSE_GFI | lci1;\n\t\t*dptr++ = lci2;\n\t\t*dptr++ = frametype;\n\t\t*dptr++ = rose->cause;\n\t\t*dptr++ = rose->diagnostic;\n\t\tbreak;\n\n\tcase ROSE_RESET_REQUEST:\n\t\t*dptr++ = ROSE_GFI | lci1;\n\t\t*dptr++ = lci2;\n\t\t*dptr++ = frametype;\n\t\t*dptr++ = ROSE_DTE_ORIGINATED;\n\t\t*dptr++ = 0;\n\t\tbreak;\n\n\tcase ROSE_RR:\n\tcase ROSE_RNR:\n\t\t*dptr++ = ROSE_GFI | lci1;\n\t\t*dptr++ = lci2;\n\t\t*dptr   = frametype;\n\t\t*dptr++ |= (rose->vr << 5) & 0xE0;\n\t\tbreak;\n\n\tcase ROSE_CLEAR_CONFIRMATION:\n\tcase ROSE_RESET_CONFIRMATION:\n\t\t*dptr++ = ROSE_GFI | lci1;\n\t\t*dptr++ = lci2;\n\t\t*dptr++  = frametype;\n\t\tbreak;\n\n\tdefault:\n\t\tprintk(KERN_ERR \"ROSE: rose_write_internal - invalid frametype %02X\\n\", frametype);\n\t\tkfree_skb(skb);\n\t\treturn;\n\t}\n\n\trose_transmit_link(skb, rose->neighbour);\n}\n\nint rose_decode(struct sk_buff *skb, int *ns, int *nr, int *q, int *d, int *m)\n{\n\tunsigned char *frame;\n\n\tframe = skb->data;\n\n\t*ns = *nr = *q = *d = *m = 0;\n\n\tswitch (frame[2]) {\n\tcase ROSE_CALL_REQUEST:\n\tcase ROSE_CALL_ACCEPTED:\n\tcase ROSE_CLEAR_REQUEST:\n\tcase ROSE_CLEAR_CONFIRMATION:\n\tcase ROSE_RESET_REQUEST:\n\tcase ROSE_RESET_CONFIRMATION:\n\t\treturn frame[2];\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif ((frame[2] & 0x1F) == ROSE_RR  ||\n\t    (frame[2] & 0x1F) == ROSE_RNR) {\n\t\t*nr = (frame[2] >> 5) & 0x07;\n\t\treturn frame[2] & 0x1F;\n\t}\n\n\tif ((frame[2] & 0x01) == ROSE_DATA) {\n\t\t*q  = (frame[0] & ROSE_Q_BIT) == ROSE_Q_BIT;\n\t\t*d  = (frame[0] & ROSE_D_BIT) == ROSE_D_BIT;\n\t\t*m  = (frame[2] & ROSE_M_BIT) == ROSE_M_BIT;\n\t\t*nr = (frame[2] >> 5) & 0x07;\n\t\t*ns = (frame[2] >> 1) & 0x07;\n\t\treturn ROSE_DATA;\n\t}\n\n\treturn ROSE_ILLEGAL;\n}\n\nstatic int rose_parse_national(unsigned char *p, struct rose_facilities_struct *facilities, int len)\n{\n\tunsigned char *pt;\n\tunsigned char l, lg, n = 0;\n\tint fac_national_digis_received = 0;\n\n\tdo {\n\t\tswitch (*p & 0xC0) {\n\t\tcase 0x00:\n\t\t\tp   += 2;\n\t\t\tn   += 2;\n\t\t\tlen -= 2;\n\t\t\tbreak;\n\n\t\tcase 0x40:\n\t\t\tif (*p == FAC_NATIONAL_RAND)\n\t\t\t\tfacilities->rand = ((p[1] << 8) & 0xFF00) + ((p[2] << 0) & 0x00FF);\n\t\t\tp   += 3;\n\t\t\tn   += 3;\n\t\t\tlen -= 3;\n\t\t\tbreak;\n\n\t\tcase 0x80:\n\t\t\tp   += 4;\n\t\t\tn   += 4;\n\t\t\tlen -= 4;\n\t\t\tbreak;\n\n\t\tcase 0xC0:\n\t\t\tl = p[1];\n\t\t\tif (*p == FAC_NATIONAL_DEST_DIGI) {\n\t\t\t\tif (!fac_national_digis_received) {\n\t\t\t\t\tmemcpy(&facilities->source_digis[0], p + 2, AX25_ADDR_LEN);\n\t\t\t\t\tfacilities->source_ndigis = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (*p == FAC_NATIONAL_SRC_DIGI) {\n\t\t\t\tif (!fac_national_digis_received) {\n\t\t\t\t\tmemcpy(&facilities->dest_digis[0], p + 2, AX25_ADDR_LEN);\n\t\t\t\t\tfacilities->dest_ndigis = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (*p == FAC_NATIONAL_FAIL_CALL) {\n\t\t\t\tmemcpy(&facilities->fail_call, p + 2, AX25_ADDR_LEN);\n\t\t\t}\n\t\t\telse if (*p == FAC_NATIONAL_FAIL_ADD) {\n\t\t\t\tmemcpy(&facilities->fail_addr, p + 3, ROSE_ADDR_LEN);\n\t\t\t}\n\t\t\telse if (*p == FAC_NATIONAL_DIGIS) {\n\t\t\t\tfac_national_digis_received = 1;\n\t\t\t\tfacilities->source_ndigis = 0;\n\t\t\t\tfacilities->dest_ndigis   = 0;\n\t\t\t\tfor (pt = p + 2, lg = 0 ; lg < l ; pt += AX25_ADDR_LEN, lg += AX25_ADDR_LEN) {\n\t\t\t\t\tif (pt[6] & AX25_HBIT) {\n\t\t\t\t\t\tif (facilities->dest_ndigis >= ROSE_MAX_DIGIS)\n\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\tmemcpy(&facilities->dest_digis[facilities->dest_ndigis++], pt, AX25_ADDR_LEN);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (facilities->source_ndigis >= ROSE_MAX_DIGIS)\n\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\tmemcpy(&facilities->source_digis[facilities->source_ndigis++], pt, AX25_ADDR_LEN);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tp   += l + 2;\n\t\t\tn   += l + 2;\n\t\t\tlen -= l + 2;\n\t\t\tbreak;\n\t\t}\n\t} while (*p != 0x00 && len > 0);\n\n\treturn n;\n}\n\nstatic int rose_parse_ccitt(unsigned char *p, struct rose_facilities_struct *facilities, int len)\n{\n\tunsigned char l, n = 0;\n\tchar callsign[11];\n\n\tdo {\n\t\tswitch (*p & 0xC0) {\n\t\tcase 0x00:\n\t\t\tp   += 2;\n\t\t\tn   += 2;\n\t\t\tlen -= 2;\n\t\t\tbreak;\n\n\t\tcase 0x40:\n\t\t\tp   += 3;\n\t\t\tn   += 3;\n\t\t\tlen -= 3;\n\t\t\tbreak;\n\n\t\tcase 0x80:\n\t\t\tp   += 4;\n\t\t\tn   += 4;\n\t\t\tlen -= 4;\n\t\t\tbreak;\n\n\t\tcase 0xC0:\n\t\t\tl = p[1];\n\n\t\t\t/* Prevent overflows*/\n\t\t\tif (l < 10 || l > 20)\n\t\t\t\treturn -1;\n\n\t\t\tif (*p == FAC_CCITT_DEST_NSAP) {\n\t\t\t\tmemcpy(&facilities->source_addr, p + 7, ROSE_ADDR_LEN);\n\t\t\t\tmemcpy(callsign, p + 12,   l - 10);\n\t\t\t\tcallsign[l - 10] = '\\0';\n\t\t\t\tasc2ax(&facilities->source_call, callsign);\n\t\t\t}\n\t\t\tif (*p == FAC_CCITT_SRC_NSAP) {\n\t\t\t\tmemcpy(&facilities->dest_addr, p + 7, ROSE_ADDR_LEN);\n\t\t\t\tmemcpy(callsign, p + 12, l - 10);\n\t\t\t\tcallsign[l - 10] = '\\0';\n\t\t\t\tasc2ax(&facilities->dest_call, callsign);\n\t\t\t}\n\t\t\tp   += l + 2;\n\t\t\tn   += l + 2;\n\t\t\tlen -= l + 2;\n\t\t\tbreak;\n\t\t}\n\t} while (*p != 0x00 && len > 0);\n\n\treturn n;\n}\n\nint rose_parse_facilities(unsigned char *p,\n\tstruct rose_facilities_struct *facilities)\n{\n\tint facilities_len, len;\n\n\tfacilities_len = *p++;\n\n\tif (facilities_len == 0)\n\t\treturn 0;\n\n\twhile (facilities_len > 0) {\n\t\tif (*p == 0x00) {\n\t\t\tfacilities_len--;\n\t\t\tp++;\n\n\t\t\tswitch (*p) {\n\t\t\tcase FAC_NATIONAL:\t\t/* National */\n\t\t\t\tlen = rose_parse_national(p + 1, facilities, facilities_len - 1);\n\t\t\t\tif (len < 0)\n\t\t\t\t\treturn 0;\n\t\t\t\tfacilities_len -= len + 1;\n\t\t\t\tp += len + 1;\n\t\t\t\tbreak;\n\n\t\t\tcase FAC_CCITT:\t\t/* CCITT */\n\t\t\t\tlen = rose_parse_ccitt(p + 1, facilities, facilities_len - 1);\n\t\t\t\tif (len < 0)\n\t\t\t\t\treturn 0;\n\t\t\t\tfacilities_len -= len + 1;\n\t\t\t\tp += len + 1;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tprintk(KERN_DEBUG \"ROSE: rose_parse_facilities - unknown facilities family %02X\\n\", *p);\n\t\t\t\tfacilities_len--;\n\t\t\t\tp++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else\n\t\t\tbreak;\t/* Error in facilities format */\n\t}\n\n\treturn 1;\n}\n\nstatic int rose_create_facilities(unsigned char *buffer, struct rose_sock *rose)\n{\n\tunsigned char *p = buffer + 1;\n\tchar *callsign;\n\tchar buf[11];\n\tint len, nb;\n\n\t/* National Facilities */\n\tif (rose->rand != 0 || rose->source_ndigis == 1 || rose->dest_ndigis == 1) {\n\t\t*p++ = 0x00;\n\t\t*p++ = FAC_NATIONAL;\n\n\t\tif (rose->rand != 0) {\n\t\t\t*p++ = FAC_NATIONAL_RAND;\n\t\t\t*p++ = (rose->rand >> 8) & 0xFF;\n\t\t\t*p++ = (rose->rand >> 0) & 0xFF;\n\t\t}\n\n\t\t/* Sent before older facilities */\n\t\tif ((rose->source_ndigis > 0) || (rose->dest_ndigis > 0)) {\n\t\t\tint maxdigi = 0;\n\t\t\t*p++ = FAC_NATIONAL_DIGIS;\n\t\t\t*p++ = AX25_ADDR_LEN * (rose->source_ndigis + rose->dest_ndigis);\n\t\t\tfor (nb = 0 ; nb < rose->source_ndigis ; nb++) {\n\t\t\t\tif (++maxdigi >= ROSE_MAX_DIGIS)\n\t\t\t\t\tbreak;\n\t\t\t\tmemcpy(p, &rose->source_digis[nb], AX25_ADDR_LEN);\n\t\t\t\tp[6] |= AX25_HBIT;\n\t\t\t\tp += AX25_ADDR_LEN;\n\t\t\t}\n\t\t\tfor (nb = 0 ; nb < rose->dest_ndigis ; nb++) {\n\t\t\t\tif (++maxdigi >= ROSE_MAX_DIGIS)\n\t\t\t\t\tbreak;\n\t\t\t\tmemcpy(p, &rose->dest_digis[nb], AX25_ADDR_LEN);\n\t\t\t\tp[6] &= ~AX25_HBIT;\n\t\t\t\tp += AX25_ADDR_LEN;\n\t\t\t}\n\t\t}\n\n\t\t/* For compatibility */\n\t\tif (rose->source_ndigis > 0) {\n\t\t\t*p++ = FAC_NATIONAL_SRC_DIGI;\n\t\t\t*p++ = AX25_ADDR_LEN;\n\t\t\tmemcpy(p, &rose->source_digis[0], AX25_ADDR_LEN);\n\t\t\tp   += AX25_ADDR_LEN;\n\t\t}\n\n\t\t/* For compatibility */\n\t\tif (rose->dest_ndigis > 0) {\n\t\t\t*p++ = FAC_NATIONAL_DEST_DIGI;\n\t\t\t*p++ = AX25_ADDR_LEN;\n\t\t\tmemcpy(p, &rose->dest_digis[0], AX25_ADDR_LEN);\n\t\t\tp   += AX25_ADDR_LEN;\n\t\t}\n\t}\n\n\t*p++ = 0x00;\n\t*p++ = FAC_CCITT;\n\n\t*p++ = FAC_CCITT_DEST_NSAP;\n\n\tcallsign = ax2asc(buf, &rose->dest_call);\n\n\t*p++ = strlen(callsign) + 10;\n\t*p++ = (strlen(callsign) + 9) * 2;\t\t/* ??? */\n\n\t*p++ = 0x47; *p++ = 0x00; *p++ = 0x11;\n\t*p++ = ROSE_ADDR_LEN * 2;\n\tmemcpy(p, &rose->dest_addr, ROSE_ADDR_LEN);\n\tp   += ROSE_ADDR_LEN;\n\n\tmemcpy(p, callsign, strlen(callsign));\n\tp   += strlen(callsign);\n\n\t*p++ = FAC_CCITT_SRC_NSAP;\n\n\tcallsign = ax2asc(buf, &rose->source_call);\n\n\t*p++ = strlen(callsign) + 10;\n\t*p++ = (strlen(callsign) + 9) * 2;\t\t/* ??? */\n\n\t*p++ = 0x47; *p++ = 0x00; *p++ = 0x11;\n\t*p++ = ROSE_ADDR_LEN * 2;\n\tmemcpy(p, &rose->source_addr, ROSE_ADDR_LEN);\n\tp   += ROSE_ADDR_LEN;\n\n\tmemcpy(p, callsign, strlen(callsign));\n\tp   += strlen(callsign);\n\n\tlen       = p - buffer;\n\tbuffer[0] = len - 1;\n\n\treturn len;\n}\n\nvoid rose_disconnect(struct sock *sk, int reason, int cause, int diagnostic)\n{\n\tstruct rose_sock *rose = rose_sk(sk);\n\n\trose_stop_timer(sk);\n\trose_stop_idletimer(sk);\n\n\trose_clear_queues(sk);\n\n\trose->lci   = 0;\n\trose->state = ROSE_STATE_0;\n\n\tif (cause != -1)\n\t\trose->cause = cause;\n\n\tif (diagnostic != -1)\n\t\trose->diagnostic = diagnostic;\n\n\tsk->sk_state     = TCP_CLOSE;\n\tsk->sk_err       = reason;\n\tsk->sk_shutdown |= SEND_SHUTDOWN;\n\n\tif (!sock_flag(sk, SOCK_DEAD)) {\n\t\tsk->sk_state_change(sk);\n\t\tsock_set_flag(sk, SOCK_DEAD);\n\t}\n}\n"], "filenames": ["net/rose/rose_subr.c"], "buggy_code_start_loc": [293], "buggy_code_end_loc": [381], "fixing_code_start_loc": [293], "fixing_code_end_loc": [396], "type": "CWE-20", "message": "The rose_parse_ccitt function in net/rose/rose_subr.c in the Linux kernel before 2.6.39 does not validate the FAC_CCITT_DEST_NSAP and FAC_CCITT_SRC_NSAP fields, which allows remote attackers to (1) cause a denial of service (integer underflow, heap memory corruption, and panic) via a small length value in data sent to a ROSE socket, or (2) conduct stack-based buffer overflow attacks via a large length value in data sent to a ROSE socket.", "other": {"cve": {"id": "CVE-2011-4913", "sourceIdentifier": "secalert@redhat.com", "published": "2012-06-21T23:55:02.410", "lastModified": "2023-02-13T01:22:00.570", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The rose_parse_ccitt function in net/rose/rose_subr.c in the Linux kernel before 2.6.39 does not validate the FAC_CCITT_DEST_NSAP and FAC_CCITT_SRC_NSAP fields, which allows remote attackers to (1) cause a denial of service (integer underflow, heap memory corruption, and panic) via a small length value in data sent to a ROSE socket, or (2) conduct stack-based buffer overflow attacks via a large length value in data sent to a ROSE socket."}, {"lang": "es", "value": "La funci\u00f3n rose_parse_ccitt en la net/rose/rose_subr.c en el kernel de Linux en versiones anteriores a la v2.6.39 no valida los campos FAC_CCITT_DEST_NSAP y FAC_CCITT_SRC_NSAP, lo que permite a atacantes remotos (1) provocar una denegaci\u00f3n de servicio (desbordamiento de enteros, corrupci\u00f3n de memoria din\u00e1mica, y 'panic' del kernel) a trav\u00e9s de un valor de longitud peque\u00f1a en los datos enviados a un 'socket' ROSE, o (2) llevar a cabo ataques de desbordamiento de pila basados ??en buffer a trav\u00e9s de un valor de longitud demasiado grande en los datos enviados a un 'socket' ROSE."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:C", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 7.8}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:novell:suse_linux_enterprise_server:10.0:sp4:*:*:ltss:*:*:*", "matchCriteriaId": "1D421F7F-A203-4868-846D-3A057610D399"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.6.38.8", "matchCriteriaId": "57A0A2B0-3B9F-40C2-8C7A-CD9590B51315"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.38:*:*:*:*:*:*:*", "matchCriteriaId": "7462DB6D-E0A6-4DBB-8E21-66B875184FFC"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.38:rc1:*:*:*:*:*:*", "matchCriteriaId": "2DDCB342-4F5F-4BF1-9624-882BBC57330D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.38:rc2:*:*:*:*:*:*", "matchCriteriaId": "C3AB4113-BF83-4587-8A85-0E4FECEE7D9B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.38:rc3:*:*:*:*:*:*", "matchCriteriaId": "4B57F5AD-A697-4090-89B9-81BC12993A1A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.38:rc4:*:*:*:*:*:*", "matchCriteriaId": "CA141BCB-A705-4DF5-9EED-746B62C86111"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.38:rc5:*:*:*:*:*:*", "matchCriteriaId": "E9ECE134-58A3-4B9D-B9B3-F836C0EDD64C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.38:rc6:*:*:*:*:*:*", "matchCriteriaId": "56186720-6B4C-4D71-85C5-7EAC5C5D84A1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.38:rc7:*:*:*:*:*:*", "matchCriteriaId": "9BBB4630-CBED-43B9-B203-BE65BBF011AA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.38:rc8:*:*:*:*:*:*", "matchCriteriaId": "FD375A78-63D7-441A-9FB0-7BC878AB4EDD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.38.1:*:*:*:*:*:*:*", "matchCriteriaId": "A5BEFFDD-02BB-4A05-8372-891DBDB9AC5A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.38.2:*:*:*:*:*:*:*", "matchCriteriaId": "766E193D-819C-42EA-8411-AE0013AC15FA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.38.3:*:*:*:*:*:*:*", "matchCriteriaId": "3B39B6AF-6A83-48C2-BED2-79228F8513A6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.38.4:*:*:*:*:*:*:*", "matchCriteriaId": "CD8A68D1-DFE9-4ADB-9FB8-4D69AB4CAFF8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.38.5:*:*:*:*:*:*:*", "matchCriteriaId": "0D6EF951-AF15-4C30-A3A5-3392AA61813C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.38.6:*:*:*:*:*:*:*", "matchCriteriaId": "15154FA0-65DC-4855-AC70-3ACF92313F49"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.38.7:*:*:*:*:*:*:*", "matchCriteriaId": "F4B3A9F4-A61F-4919-A173-3E459F0C5AF8"}]}]}], "references": [{"url": "http://ftp.osuosl.org/pub/linux/kernel/v2.6/ChangeLog-2.6.39", "source": "secalert@redhat.com", "tags": ["Broken Link"]}, {"url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git%3Ba=commit%3Bh=be20250c13f88375345ad99950190685eda51eb8", "source": "secalert@redhat.com"}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2015-04/msg00020.html", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2011/12/28/2", "source": "secalert@redhat.com"}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=770777", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "VDB Entry"]}, {"url": "https://github.com/torvalds/linux/commit/be20250c13f88375345ad99950190685eda51eb8", "source": "secalert@redhat.com", "tags": ["Exploit", "Patch"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/be20250c13f88375345ad99950190685eda51eb8"}}