{"buggy_code": ["package edu.stanford.nlp.ie.machinereading.common;\n\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\n\nimport org.w3c.dom.Document;\nimport org.w3c.dom.NamedNodeMap;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.SAXException;\n\n/**\n * Generic DOM reader for an XML file\n */\npublic class DomReader {\n\n\t/**\n\t * Searches (recursively) for the first child that has the given name\n\t */\n\tprotected static Node getChildByName(Node node, String name) {\n\t\tNodeList children = node.getChildNodes();\n\n\t\t// this node matches\n\t\tif (node.getNodeName().equals(name))\n\t\t\treturn node;\n\n\t\t// search children\n\t\tfor (int i = 0; i < children.getLength(); i++) {\n\t\t\tNode found = getChildByName(children.item(i), name);\n\t\t\tif (found != null)\n\t\t\t\treturn found;\n\t\t}\n\n\t\t// failed\n\t\treturn null;\n\t}\n\n\t/**\n\t * Searches for all immediate children with the given name\n\t */\n\tprotected static List<Node> getChildrenByName(Node node, String name) {\n\t\tList<Node> matches = new ArrayList<>();\n\t\tNodeList children = node.getChildNodes();\n\n\t\t// search children\n\t\tfor (int i = 0; i < children.getLength(); i++) {\n\t\t\tNode child = children.item(i);\n\t\t\tif (child.getNodeName().equals(name)) {\n\t\t\t\tmatches.add(child);\n\t\t\t}\n\t\t}\n\n\t\treturn matches;\n\t}\n\n\t/**\n\t * Searches for children that have the given attribute\n\t */\n\tprotected static Node getChildByAttribute(Node node, String attributeName, String attributeValue) {\n\t\tNodeList children = node.getChildNodes();\n\t\tNamedNodeMap attribs = node.getAttributes();\n\t\tNode attribute = null;\n\n\t\t// this node matches\n\t\tif (attribs != null && (attribute = attribs.getNamedItem(attributeName)) != null\n\t\t\t\t&& attribute.getNodeValue().equals(attributeValue))\n\t\t\treturn node;\n\n\t\t// search children\n\t\tfor (int i = 0; i < children.getLength(); i++) {\n\t\t\tNode found = getChildByAttribute(children.item(i), attributeName, attributeValue);\n\t\t\tif (found != null)\n\t\t\t\treturn found;\n\t\t}\n\n\t\t// failed\n\t\treturn null;\n\t}\n\n\t/**\n\t * Searches for children that have the given name and attribute\n\t */\n\tprotected static Node getChildByNameAndAttribute(Node node, String name, String attributeName, String attributeValue) {\n\t\tNodeList children = node.getChildNodes();\n\t\tNamedNodeMap attribs = node.getAttributes();\n\t\tNode attribute = null;\n\n\t\t// this node matches\n\t\tif (node.getNodeName().equals(name) && attribs != null\n\t\t\t\t&& (attribute = attribs.getNamedItem(attributeName)) != null\n\t\t\t\t&& attribute.getNodeValue().equals(attributeValue))\n\t\t\treturn node;\n\n\t\t// search children\n\t\tfor (int i = 0; i < children.getLength(); i++) {\n\t\t\tNode found = getChildByAttribute(children.item(i), attributeName, attributeValue);\n\t\t\tif (found != null)\n\t\t\t\treturn found;\n\t\t}\n\n\t\t// failed\n\t\treturn null;\n\t}\n\n\t/**\n\t * Fetches the value of a given attribute\n\t */\n\tpublic static String getAttributeValue(Node node, String attributeName) {\n\t\ttry {\n\t\t\treturn node.getAttributes().getNamedItem(attributeName).getNodeValue();\n\t\t} catch (Exception e) {\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Constructs one Document from an XML file\n\t */\n\tpublic static Document readDocument(File f) throws IOException, SAXException, ParserConfigurationException {\n\t\tDocument document = null;\n\n\t\tDocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n\t\t// factory.setValidating(true);\n\t\t// factory.setNamespaceAware(true);\n\n\t\ttry {\n\t\t\tDocumentBuilder builder = factory.newDocumentBuilder();\n\t\t\tdocument = builder.parse(f);\n\n\t\t\t// displayDocument(document);\n\n\t\t} catch (SAXException sxe) {\n\t\t\t// Error generated during parsing)\n\t\t\tException x = sxe;\n\t\t\tif (sxe.getException() != null)\n\t\t\t\tx = sxe.getException();\n\t\t\tx.printStackTrace();\n\t\t\tthrow sxe;\n\t\t} catch (ParserConfigurationException pce) {\n\t\t\t// Parser with specified options can't be built\n\t\t\tpce.printStackTrace();\n\t\t\tthrow pce;\n\t\t} catch (IOException ioe) {\n\t\t\t// I/O error\n\t\t\tioe.printStackTrace();\n\t\t\tthrow ioe;\n\t\t}\n\n\t\treturn document;\n\t} // readDocument\n}\n", "package edu.stanford.nlp.semgraph.semgrex.ssurgeon;\n\nimport java.io.*;\nimport java.util.*;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport java.text.DateFormat;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.transform.OutputKeys;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.stream.StreamResult;\n\nimport edu.stanford.nlp.util.StringUtils;\nimport edu.stanford.nlp.util.logging.RedwoodConfiguration;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\n\nimport edu.stanford.nlp.trees.GrammaticalRelation;\nimport edu.stanford.nlp.semgraph.SemanticGraph;\nimport edu.stanford.nlp.semgraph.SemanticGraphUtils;\nimport edu.stanford.nlp.semgraph.semgrex.ssurgeon.pred.*;\nimport edu.stanford.nlp.semgraph.semgrex.SemgrexPattern;\nimport edu.stanford.nlp.util.Generics;\nimport edu.stanford.nlp.util.logging.Redwood;\n\n\n/**\n * This is the primary class for loading and saving out Ssurgeon patterns.\n * This is also the class that maintains the current list of resources loaded into Ssurgeon: any pattern\n * loaded can reference these resources.\n *\n * @author Eric Yeh\n */\npublic class Ssurgeon  {\n\n  private static final boolean VERBOSE = false;\n\n  // singleton, to ensure all use the same resources\n  private static Ssurgeon instance = null;\n\n  private Ssurgeon() {}\n\n  public static Ssurgeon inst() {\n    synchronized(Ssurgeon.class) {\n      if (instance == null)\n        instance = new Ssurgeon();\n    }\n    return instance;\n  }\n\n  // Logging to file facilities.\n  // The prefix is used to append stuff in front of the logging messages\n  /** A logger for this class */\n  private static final Redwood.RedwoodChannels log = Redwood.channels(Ssurgeon.class);\n\n  private String logPrefix = null;\n  public void initLog(File logFilePath) throws IOException {\n    RedwoodConfiguration.empty()\n      .handlers(RedwoodConfiguration.Handlers.chain(\n        RedwoodConfiguration.Handlers.showAllChannels(), RedwoodConfiguration.Handlers.stderr),\n        RedwoodConfiguration.Handlers.file(logFilePath.toString())\n      ).apply();\n    // fh.setFormatter(new NewlineLogFormatter());\n\n    System.out.println(\"Starting Ssurgeon log, at \"+logFilePath.getAbsolutePath()+\" date=\" + DateFormat.getDateInstance(DateFormat.FULL).format(new Date()));\n    log.info(\"Starting Ssurgeon log, date=\" + DateFormat.getDateInstance(DateFormat.FULL).format(new Date()));\n  }\n\n  public void setLogPrefix(String logPrefix) {\n    this.logPrefix = logPrefix;\n  }\n\n\n\n  /**\n   * Given a list of SsurgeonPattern edit scripts, and a SemanticGraph\n   * to operate over, returns a list of expansions of that graph, with\n   * the result of each edit applied against a copy of the graph.\n   */\n  public  List<SemanticGraph> expandFromPatterns(List<SsurgeonPattern> patternList, SemanticGraph sg) throws Exception {\n    List<SemanticGraph> retList = new ArrayList<>();\n    for (SsurgeonPattern pattern :patternList) {\n      Collection<SemanticGraph> generated = pattern.execute(sg);\n      for (SemanticGraph orderedGraph : generated) {\n        //orderedGraph.vertexList(true);\n        //orderedGraph.edgeList(true);\n        retList.add(orderedGraph);\n        System.out.println(\"\\ncompact = \"+orderedGraph.toCompactString());\n        System.out.println(\"regular=\" + orderedGraph);\n      }\n\n      if (generated.size() > 0) {\n        if (log != null) {\n          log.info(\"* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\");\n          log.info(\"Pre remove duplicates, num=\"+generated.size());\n        }\n        SemanticGraphUtils.removeDuplicates(generated, sg);\n        if (log != null) {\n          log.info(\"Expand from patterns\");\n          if (logPrefix != null) log.info(logPrefix);\n          log.info(\"Pattern = '\"+pattern.getUID()+\"' generated \"+generated.size()+\" matches\");\n          log.info(\"= = = = = = = = = =\\nSrc graph:\\n\" + sg + \"\\n= = = = = = = = = =\\n\");\n          int index=1;\n          for (SemanticGraph genSg : generated) {\n            log.info(\"REWRITE \"+(index++));\n            log.info(genSg.toString());\n            log.info(\". . . . .\\n\");\n          }\n        }\n      }\n    }\n    return retList;\n  }\n\n  /**\n   * Similar to the expandFromPatterns, but performs an exhaustive\n   * search, performing simplifications on the graphs until exhausted.\n   *\n   * TODO: ensure cycles do not occur\n   * NOTE: put in an arbitrary depth limit of 3, to prevent churning way too much (heuristic)\n   *\n   */\n  public  Collection<SemanticGraph> exhaustFromPatterns(List<SsurgeonPattern> patternList, SemanticGraph sg) throws Exception {\n    Collection<SemanticGraph> generated = exhaustFromPatterns(patternList, sg, 1);\n    if (generated.size() > 1) {\n      if (log != null)\n        log.info(\"Before remove dupe, size=\"+generated.size());\n      generated = SemanticGraphUtils.removeDuplicates(generated, sg);\n      if (log != null)\n        log.info(\"AFTER remove dupe, size=\"+generated.size());\n    }\n    return generated;\n  }\n  private  List<SemanticGraph> exhaustFromPatterns(List<SsurgeonPattern> patternList, SemanticGraph sg, int depth) throws Exception {\n    List<SemanticGraph> retList = new ArrayList<>();\n    for (SsurgeonPattern pattern : patternList) {\n      Collection<SemanticGraph> generated = pattern.execute(sg);\n      for (SemanticGraph modGraph : generated) {\n        //modGraph = SemanticGraphUtils.resetVerticeOrdering(modGraph);\n        //modGraph.vertexList(true);\n        //modGraph.edgeList(true);\n        retList.add(modGraph);\n      }\n\n      if (log != null && generated.size() > 0) {\n        log.info(\"* * * * * * * * * ** * * * * * * * * *\");\n        log.info(\"Exhaust from patterns, depth=\"+depth);\n        if (logPrefix != null) log.info(logPrefix);\n        log.info(\"Pattern = '\"+pattern.getUID()+\"' generated \"+generated.size()+\" matches\");\n        log.info(\"= = = = = = = = = =\\nSrc graph:\\n\"+sg.toString()+\"\\n= = = = = = = = = =\\n\");\n        int index=1;\n        for (SemanticGraph genSg : generated) {\n          log.info(\"REWRITE \"+(index++));\n          log.info(genSg.toString());\n          log.info(\". . . . .\\n\");\n        }\n      }\n    }\n\n    if (retList.size() > 0) {\n      List<SemanticGraph> referenceList = new ArrayList<>(retList);\n      for (SemanticGraph childGraph : referenceList) {\n        if (depth < 3)\n          retList.addAll(exhaustFromPatterns(patternList, childGraph, depth + 1));\n      }\n    }\n    return retList;\n  }\n\n\n  /**\n   * Given a path to a file, converts it into a SsurgeonPattern\n   * TODO: finish implementing this stub.\n   */\n  public static SsurgeonPattern getOperationFromFile(String path) {\n    return null;\n  }\n\n  //\n  // Resource management\n  //\n  private Map<String, SsurgeonWordlist> wordListResources = Generics.newHashMap();\n\n  /**\n   * Places the given word list resource under the given ID.\n   * Note: can overwrite existing one in place.\n   */\n  private void addResource(SsurgeonWordlist resource) {\n    wordListResources.put(resource.getID(), resource);\n  }\n\n  /**\n   * Returns the given resource with the id.\n   * If does not exist, will throw exception.\n   */\n  public SsurgeonWordlist getResource(String id) {\n    return wordListResources.get(id);\n  }\n\n  public Collection<SsurgeonWordlist> getResources() {\n    return wordListResources.values();\n  }\n\n\n  public static final String GOV_NODENAME_ARG = \"-gov\";\n  public static final String DEP_NODENAME_ARG = \"-dep\";\n  public static final String EDGE_NAME_ARG = \"-edge\";\n  public static final String NODENAME_ARG = \"-node\";\n  public static final String RELN_ARG = \"-reln\";\n  public static final String NODE_PROTO_ARG = \"-nodearg\";\n  public static final String WEIGHT_ARG = \"-weight\";\n  public static final String NAME_ARG = \"-name\";\n\n\n  // args for Ssurgeon edits, allowing us to not\n  // worry about arg order (and to make things appear less confusing)\n  protected static class SsurgeonArgs {\n    // Below are values keyed by Semgrex name\n    public String govNodeName = null;\n\n    public String dep = null;\n\n    public String edge = null;\n\n    public String reln = null;\n\n    public String node = null;\n\n    // below are string representations of the intended values\n    public String nodeString = null;\n\n    public double weight = 1.0;\n\n    public String name = null;\n  }\n\n  /**\n   * This is a specialized args parser, as we want to split on\n   * whitespace, but retain everything inside quotes, so we can pass\n   * in hashmaps in String form.\n   */\n  private static String[] parseArgs(String argsString) {\n    List<String> retList = new ArrayList<>();\n    String patternString = \"(?:[^\\\\s\\\\\\\"]++|\\\\\\\"[^\\\\\\\"]*+\\\\\\\"|(\\\\\\\"))++\";\n    Pattern pattern = Pattern.compile(patternString);\n    Matcher matcher = pattern.matcher(argsString);\n    while (matcher.find()) {\n      if (matcher.group(1) == null) {\n        String matched = matcher.group();\n        if (matched.charAt(0) == '\"' &&\n            matched.charAt(matched.length()-1) == '\"')\n          retList.add(matched.substring(1, matched.length()-1));\n        else\n          retList.add(matched);\n      }  else\n        throw new IllegalArgumentException(\"Unmatched quote in string to parse\");\n    }\n    return retList.toArray(StringUtils.EMPTY_STRING_ARRAY);\n  }\n\n  /**\n   * Given a string entry, converts it into a SsurgeonEdit object.\n   */\n  public static SsurgeonEdit parseEditLine(String editLine) {\n    // Extract the operation name first\n    String[] tuples1 = editLine.split(\"\\\\s+\", 2);\n    if (tuples1.length < 2) {\n      throw new IllegalArgumentException(\"Error in SsurgeonEdit.parseEditLine: invalid number of arguments\");\n    }\n    String command = tuples1[0];\n    String[] argsArray = parseArgs(tuples1[1]);\n    SsurgeonArgs argsBox = new SsurgeonArgs();\n\n    for (int argIndex = 0; argIndex < argsArray.length; ++argIndex) {\n      switch (argsArray[argIndex]) {\n        case GOV_NODENAME_ARG:\n          argsBox.govNodeName = argsArray[argIndex + 1];\n          argIndex += 2;\n          break;\n        case DEP_NODENAME_ARG:\n          argsBox.dep = argsArray[argIndex + 1];\n          argIndex += 2;\n          break;\n        case EDGE_NAME_ARG:\n          argsBox.edge = argsArray[argIndex + 1];\n          argIndex += 2;\n          break;\n        case RELN_ARG:\n          argsBox.reln = argsArray[argIndex + 1];\n          argIndex += 2;\n          break;\n        case NODENAME_ARG:\n          argsBox.node = argsArray[argIndex + 1];\n          argIndex += 2;\n          break;\n        case NODE_PROTO_ARG:\n          argsBox.nodeString = argsArray[argIndex + 1];\n          argIndex += 2;\n          break;\n        case WEIGHT_ARG:\n          argsBox.weight = Double.valueOf(argsArray[argIndex + 1]);\n          argIndex += 2;\n          break;\n        case NAME_ARG:\n          argsBox.name = argsArray[argIndex + 1];\n          argIndex += 2;\n          break;\n        default:\n          throw new IllegalArgumentException(\"Parsing Ssurgeon args: unknown flag \" + argsArray[argIndex]);\n      }\n    }\n\n\n    // Parse the arguments based upon the type of command to execute.\n    // TODO: this logic really should be moved into the individual classes.  The string-->class\n    // mappings should also be stored in more appropriate data structure.\n    SsurgeonEdit retEdit;\n    if (command.equalsIgnoreCase(AddDep.LABEL)) {\n      retEdit = AddDep.createEngAddDep(argsBox.govNodeName, argsBox.reln, argsBox.nodeString);\n    } else if (command.equalsIgnoreCase(AddNode.LABEL)) {\n      retEdit = AddNode.createAddNode(argsBox.nodeString, argsBox.name);\n    } else if (command.equalsIgnoreCase(AddEdge.LABEL)) {\n      retEdit = AddEdge.createEngAddEdge(argsBox.govNodeName, argsBox.dep, argsBox.reln);\n    } else if (command.equalsIgnoreCase(DeleteGraphFromNode.LABEL)) {\n      retEdit = new DeleteGraphFromNode(argsBox.node);\n    } else if (command.equalsIgnoreCase(RemoveEdge.LABEL)) {\n      retEdit = new RemoveEdge(GrammaticalRelation.valueOf(argsBox.reln), argsBox.govNodeName, argsBox.dep);\n    } else if (command.equalsIgnoreCase(RemoveNamedEdge.LABEL)) {\n      retEdit = new RemoveNamedEdge(argsBox.edge, argsBox.govNodeName, argsBox.dep);\n    } else if (command.equalsIgnoreCase(SetRoots.LABEL)) {\n      String[] names = tuples1[1].split(\"\\\\s+\");\n      List<String> newRoots = Arrays.asList(names);\n      retEdit = new SetRoots(newRoots);\n    } else if (command.equalsIgnoreCase(KillNonRootedNodes.LABEL)) {\n      retEdit = new KillNonRootedNodes();\n    } else if (command.equalsIgnoreCase(KillAllIncomingEdges.LABEL)) {\n      retEdit = new KillAllIncomingEdges(argsBox.node);\n    } else {\n      throw new IllegalArgumentException(\"Error in SsurgeonEdit.parseEditLine: command '\"+command+\"' is not supported\");\n    }\n    return retEdit;\n  }\n\n  //public static SsurgeonPattern fromXML(String xmlString) throws Exception {\n  //SAXBuilder builder = new SAXBuilder();\n  //Document jdomDoc = builder.build(xmlString);\n  //jdomDoc.getRootElement().getChildren(SsurgeonPattern.SSURGEON_ELEM_TAG);\n  //}\n\n  /**\n   * Given a target filepath and a list of Ssurgeon patterns, writes them out as XML forms.\n   */\n  public static void writeToFile(File tgtFile, List<SsurgeonPattern> patterns) {\n    try {\n      Document domDoc = createPatternXMLDoc(patterns);\n      if (domDoc != null) {\n        Transformer tformer = TransformerFactory.newInstance().newTransformer();\n        tformer.setOutputProperty(OutputKeys.INDENT, \"yes\");\n        tformer.transform(new DOMSource(domDoc), new StreamResult(tgtFile));\n      } else {\n        log.warning(\"Was not able to create XML document for pattern list, file not written.\");\n      }\n    } catch (Exception e) {\n      log.error(Ssurgeon.class.getName(), \"writeToFile\");\n      log.error(e);\n    }\n  }\n\n  public static String writeToString(SsurgeonPattern pattern) {\n    try {\n      List<SsurgeonPattern> patterns = new LinkedList<>();\n      patterns.add(pattern);\n      Document domDoc = createPatternXMLDoc(patterns);\n      if (domDoc != null) {\n        Transformer tformer = TransformerFactory.newInstance().newTransformer();\n        tformer.setOutputProperty(OutputKeys.INDENT, \"yes\");\n        StringWriter sw = new StringWriter();\n        tformer.transform(new DOMSource(domDoc), new StreamResult(sw));\n        return sw.toString();\n      } else {\n        log.warning(\"Was not able to create XML document for pattern list.\");\n      }\n    } catch (Exception e) {\n      log.info(\"Error in writeToString, could not process pattern=\"+pattern);\n      log.info(e);\n      return null;\n    }\n    return \"\";\n  }\n\n\n  private static Document createPatternXMLDoc(List<SsurgeonPattern> patterns) {\n    try {\n      DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n      DocumentBuilder db = dbf.newDocumentBuilder();\n      Document domDoc = db.newDocument();\n      Element rootElt = domDoc.createElement(SsurgeonPattern.ELT_LIST_TAG);\n      domDoc.appendChild(rootElt);\n      int ordinal = 1;\n      for (SsurgeonPattern pattern : patterns) {\n        Element patElt = domDoc.createElement(SsurgeonPattern.SSURGEON_ELEM_TAG);\n        patElt.setAttribute(SsurgeonPattern.ORDINAL_ATTR, String.valueOf(ordinal));\n        Element semgrexElt = domDoc.createElement(SsurgeonPattern.SEMGREX_ELEM_TAG);\n        semgrexElt.appendChild(domDoc.createTextNode(pattern.getSemgrexPattern().pattern()));\n        patElt.appendChild(semgrexElt);\n        Element uidElem = domDoc.createElement(SsurgeonPattern.UID_ELEM_TAG);\n        uidElem.appendChild(domDoc.createTextNode(pattern.getUID()));\n        patElt.appendChild(uidElem);\n        Element notesElem = domDoc.createElement(SsurgeonPattern.NOTES_ELEM_TAG);\n        notesElem.appendChild(domDoc.createTextNode(pattern.getNotes()));\n        patElt.appendChild(notesElem);\n\n        SemanticGraph semgrexGraph = pattern.getSemgrexGraph();\n        if (semgrexGraph != null) {\n          Element patNode = domDoc.createElement(SsurgeonPattern.SEMGREX_GRAPH_ELEM_TAG);\n          patNode.appendChild(domDoc.createTextNode(semgrexGraph.toCompactString()));\n        }\n        Element editList = domDoc.createElement(SsurgeonPattern.EDIT_LIST_ELEM_TAG);\n        patElt.appendChild(editList);\n        int editOrdinal = 1;\n        for (SsurgeonEdit edit : pattern.getEditScript()) {\n          Element editElem = domDoc.createElement(SsurgeonPattern.EDIT_ELEM_TAG);\n          editElem.setAttribute(SsurgeonPattern.ORDINAL_ATTR, String.valueOf(editOrdinal));\n          editElem.appendChild(domDoc.createTextNode(edit.toEditString()));\n          editList.appendChild(editElem);\n          editOrdinal++;\n        }\n        rootElt.appendChild(patElt);\n        ordinal++;\n      }\n      return domDoc;\n    } catch (Exception e) {\n      log.error(Ssurgeon.class.getName(), \"createPatternXML\");\n      log.error(e);\n      return null;\n    }\n  }\n\n\n  /**\n   * Given a path to a file containing a list of SsurgeonPatterns, returns\n   *\n   * TODO: deal with resources\n   * @throws Exception\n   */\n  @SuppressWarnings(\"unchecked\")\n  public List<SsurgeonPattern> readFromFile(File file) throws Exception {\n    List<SsurgeonPattern> retList = new ArrayList<>();\n    Document doc = DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(file);\n\n    if (VERBOSE)\n      System.out.println(\"Reading ssurgeon file=\"+file.getAbsolutePath());\n\n    NodeList patternNodes = doc.getElementsByTagName(SsurgeonPattern.SSURGEON_ELEM_TAG);\n    for (int i=0; i<patternNodes.getLength(); i++) {\n      Node node = patternNodes.item(i);\n      if (node.getNodeType() == Node.ELEMENT_NODE) {\n        Element elt = (Element) node;\n        SsurgeonPattern pattern = ssurgeonPatternFromXML(elt);\n        retList.add(pattern);\n      }\n    }\n\n    NodeList resourceNodes = doc.getElementsByTagName(SsurgeonPattern.RESOURCE_TAG);\n    for (int i=0; i < resourceNodes.getLength(); i++) {\n      Node node = patternNodes.item(i);\n      if (node.getNodeType() == Node.ELEMENT_NODE) {\n        Element resourceElt = (Element) node;\n        SsurgeonWordlist wlRsrc = new SsurgeonWordlist(resourceElt);\n        addResource(wlRsrc);\n      }\n    }\n\n    return retList;\n  }\n\n  /**\n   * Reads all Ssurgeon patterns from file.\n   * @throws Exception\n   */\n  public List<SsurgeonPattern> readFromDirectory(File dir) throws Exception {\n    if (!dir.isDirectory()) throw new Exception(\"Given path not a directory, path=\"+dir.getAbsolutePath());\n    if (VERBOSE)\n      System.out.println(\"Reading Ssurgeon patterns from directory = \"+dir.getAbsolutePath());\n    File[] files = dir.listFiles((dir1, name) -> name.toLowerCase().endsWith(\".xml\"));\n    List<SsurgeonPattern> patterns = new ArrayList<>();\n    for (File file : files) {\n      try {\n        patterns.addAll(readFromFile(file));\n      } catch (Exception e) {\n        log.error(e);\n      }\n    }\n    return patterns;\n  }\n\n  /**\n   * Given the root Element for a SemgrexPattern (SSURGEON_ELEM_TAG), converts\n   * it into its corresponding SemgrexPattern object.\n   * @throws Exception\n   */\n  @SuppressWarnings(\"unchecked\")\n  public static SsurgeonPattern ssurgeonPatternFromXML(Element elt) throws Exception {\n    String uid = getTagText(elt, SsurgeonPattern.UID_ELEM_TAG);\n    String notes = getTagText(elt, SsurgeonPattern.NOTES_ELEM_TAG);\n    String semgrexString = getTagText(elt, SsurgeonPattern.SEMGREX_ELEM_TAG);\n    SemgrexPattern semgrexPattern = SemgrexPattern.compile(semgrexString);\n    SsurgeonPattern retPattern = new SsurgeonPattern(uid, semgrexPattern);\n    retPattern.setNotes(notes);\n    NodeList editNodes = elt.getElementsByTagName(SsurgeonPattern.EDIT_LIST_ELEM_TAG);\n    for (int i=0; i<editNodes.getLength(); i++) {\n      Node node = editNodes.item(i);\n      if (node.getNodeType() == Node.ELEMENT_NODE) {\n        Element editElt = (Element) node;\n        String editVal = getEltText(editElt);\n        retPattern.addEdit(Ssurgeon.parseEditLine(editVal));\n      }\n    }\n\n\n    // If predicate available, parse\n    Element predElt = getFirstTag(elt, SsurgeonPattern.PREDICATE_TAG);\n    if (predElt != null) {\n      SsurgPred pred = assemblePredFromXML(getFirstChildElement(predElt));\n      retPattern.setPredicate(pred);\n    }\n    return retPattern;\n  }\n\n  /**\n   * Constructs a {@code SsurgPred} structure from file, given the root element.\n   * @throws Exception\n   */\n  public static SsurgPred assemblePredFromXML(Element elt) throws Exception {\n    String eltName = elt.getTagName();\n    switch (eltName) {\n      case SsurgeonPattern.PREDICATE_AND_TAG:\n        SsurgAndPred andPred = new SsurgAndPred();\n        for (Element childElt : getChildElements(elt)) {\n          SsurgPred childPred = assemblePredFromXML(childElt);\n          andPred.add(childPred);\n          return andPred;\n        }\n        break;\n      case SsurgeonPattern.PREDICATE_OR_TAG:\n        SsurgOrPred orPred = new SsurgOrPred();\n        for (Element childElt : getChildElements(elt)) {\n          SsurgPred childPred = assemblePredFromXML(childElt);\n          orPred.add(childPred);\n          return orPred;\n        }\n        break;\n      case SsurgeonPattern.PRED_WORDLIST_TEST_TAG:\n        String id = elt.getAttribute(SsurgeonPattern.PRED_ID_ATTR);\n        String resourceID = elt.getAttribute(\"resourceID\");\n        String typeStr = elt.getAttribute(\"type\");\n        String matchName = getEltText(elt).trim(); // node name to match on\n\n        if (matchName == null) {\n          throw new Exception(\"Could not find match name for \" + elt);\n        }\n        if (id == null) {\n          throw new Exception(\"No ID attribute for element = \" + elt);\n        }\n        return new WordlistTest(id, resourceID, typeStr, matchName);\n    }\n\n    // Not a valid node, error out!\n    throw new Exception(\"Invalid node encountered during Ssurgeon predicate processing, node name=\"+eltName);\n  }\n\n\n\n  /**\n   * Reads in the test file and prints readable to string (for debugging).\n   * Input file consists of semantic graphs, in compact form.\n   */\n  public void testRead(File tgtDirPath) throws Exception {\n    List<SsurgeonPattern> patterns = readFromDirectory(tgtDirPath);\n\n    System.out.println(\"Patterns, num = \"+patterns.size());\n    int num = 1;\n    for (SsurgeonPattern pattern : patterns) {\n      System.out.println(\"\\n# \"+(num++));\n      System.out.println(pattern);\n    }\n\n    System.out.println(\"\\n\\nRESOURCES \");\n    for (SsurgeonWordlist rsrc : inst().getResources()) {\n      System.out.println(rsrc+\"* * * * *\");\n    }\n\n    BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n    boolean runFlag = true;\n    Ssurgeon.inst().initLog(new File(\"./ssurgeon_run.log\"));\n    while (runFlag) {\n      try {\n        System.out.println(\"Enter a sentence:\");\n        String line = in.readLine();\n        if (line.isEmpty()) {\n          System.exit(0);\n        }\n        System.out.println(\"Parsing...\");\n        SemanticGraph sg = SemanticGraph.valueOf(line);\n        System.out.println(\"Graph = \"+sg);\n        Collection<SemanticGraph> generated = Ssurgeon.inst().exhaustFromPatterns(patterns, sg);\n        System.out.println(\"# generated = \"+generated.size());\n        int index = 1;\n        for (SemanticGraph gsg : generated) {\n          System.out.println(\"\\n# \"+index);\n          System.out.println(gsg);\n          index++;\n        }\n      } catch (Exception e) {\n        log.error(e);\n      }\n    }\n  }\n\n\n  /*\n   * XML convenience routines\n   */\n  // todo [cdm 2016]: Aren't some of these methods available as generic XML methods elsewhere??\n\n  /**\n   * For the given element, returns the text for the first child Element with\n   * the given tag.\n   */\n  public static String getTagText(Element element, String tag) {\n    try {\n      // From root element, identify first with tag, then find the\n      // first child under that, which we treat as a TEXT node.\n      Element firstElt = getFirstTag(element, tag);\n      if (firstElt == null) return \"\";\n      return getEltText(firstElt);\n    } catch (Exception e) {\n      log.warning(\"Exception thrown attempting to get tag text for tag=\"+tag+\", from element=\"+element);\n    }\n    return \"\";\n  }\n\n  /**\n   * For a given Element, treats the first child as a text element\n   * and returns its value.\n   */\n  public static String getEltText(Element element) {\n    try {\n      NodeList childNodeList = element.getChildNodes();\n      if (childNodeList.getLength() == 0) return \"\";\n      return childNodeList.item(0).getNodeValue();\n    } catch (Exception e) {\n      log.warning(\"Exception e=\" + e.getMessage() + \" thrown calling getEltText on element=\" + element);\n    }\n    return \"\";\n  }\n\n  /**\n   * For the given element, finds the first child Element with the given tag.\n   */\n  private static Element getFirstTag(Element element, String tag) {\n    try {\n      NodeList nodeList = element.getElementsByTagName(tag);\n      if (nodeList.getLength() == 0) return null;\n      for (int i=0; i < nodeList.getLength(); i++) {\n        Node node = nodeList.item(i);\n        if (node.getNodeType() == Node.ELEMENT_NODE)\n          return (Element) node;\n      }\n    } catch (Exception e) {\n      log.warning(\"Error getting first tag \"+tag+\" under element=\"+element);\n    }\n    return null;\n  }\n\n  /**\n   * Returns the first child whose node type is Element under the given Element.\n   */\n  private static Element getFirstChildElement(Element element) {\n    try {\n      NodeList nodeList = element.getChildNodes();\n      for (int i=0; i<nodeList.getLength(); i++) {\n        Node node = nodeList.item(i);\n        if (node.getNodeType() == Node.ELEMENT_NODE)\n          return (Element) node;\n      }\n    } catch (Exception e) {\n      log.warning(\"Error getting first child Element for element=\" + element+\", exception=\" + e);\n    }\n    return null;\n  }\n\n\n  /**\n   * Returns all of the Element typed children from the given element.  Note: disregards\n   * other node types.\n   */\n  private static List<Element> getChildElements(Element element) {\n    LinkedList<Element> childElements = new LinkedList<>();\n    try {\n      NodeList nodeList = element.getChildNodes();\n      for (int i=0; i<nodeList.getLength(); i++) {\n        Node node = nodeList.item(i);\n        if (node.getNodeType() == Node.ELEMENT_NODE) {\n          childElements.add((Element) node);\n        }\n      }\n    } catch (Exception e) {\n      log.warning(\"Exception thrown getting all children for element=\" + element+ \", e=\" + e);\n    }\n    return childElements;\n  }\n\n  /*\n   * Main class evocation stuff\n   */\n\n\n  public enum RUNTYPE {\n    interactive, // interactively test contents of pattern directory against entered sentences\n    testinfo // test against a given infofile (RTE), generating rewrites for hypotheses\n  }\n\n\n  public static class ArgsBox {\n    public RUNTYPE type = RUNTYPE.interactive;\n\n    public String patternDirStr = null;\n    public File patternDir = null;\n\n    public String info = null;\n    public File infoPath = null;\n\n    public void init() {\n      patternDir = new File(patternDirStr);\n      if (type == RUNTYPE.testinfo)\n        infoPath = new File(info);\n    }\n\n    @Override\n    public String toString() {\n      StringWriter buf = new StringWriter();\n      buf.write(\"type =\"+type+\"\\n\");\n      buf.write(\"pattern dir = \"+patternDir.getAbsolutePath());\n      if (type == RUNTYPE.testinfo) {\n        buf.write(\"info file = \"+info);\n        if (info != null)\n          buf.write(\", path = \"+infoPath.getAbsolutePath());\n      }\n      return buf.toString();\n    }\n  }\n\n  protected static ArgsBox argsBox = new ArgsBox();\n\n  /**\n   * Performs a simple test and print of a given file.\n   * Usage Ssurgeon [-info infoFile] -patterns patternDir [-type interactive|testinfo]\n   */\n  public static void main(String[] args) {\n    for (int argIndex = 0; argIndex < args.length; ++argIndex) {\n      if (args[argIndex].equalsIgnoreCase(\"-info\")) {\n        argsBox.info = args[argIndex + 1];\n        argIndex += 2;\n      } else if (args[argIndex].equalsIgnoreCase(\"-patterns\")) {\n        argsBox.patternDirStr = args[argIndex + 1];\n        argIndex += 2;\n      } else if (args[argIndex].equalsIgnoreCase(\"-type\")) {\n        argsBox.type = RUNTYPE.valueOf(args[argIndex + 1]);\n        argIndex += 2;\n      }\n    }\n    if (argsBox.patternDirStr == null) {\n      throw new IllegalArgumentException(\"Need to give a pattern location with -patterns\");\n    }\n    argsBox.init();\n\n    System.out.println(argsBox);\n    try {\n      if (argsBox.type == RUNTYPE.interactive) {\n        Ssurgeon.inst().testRead(argsBox.patternDir);\n      }\n    } catch (Exception e) {\n      log.error(e);\n    }\n  }\n\n}\n"], "fixing_code": ["package edu.stanford.nlp.ie.machinereading.common;\n\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\n\nimport org.w3c.dom.Document;\nimport org.w3c.dom.NamedNodeMap;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.SAXException;\n\nimport edu.stanford.nlp.util.XMLUtils;\n\n/**\n * Generic DOM reader for an XML file\n */\npublic class DomReader {\n\n\t/**\n\t * Searches (recursively) for the first child that has the given name\n\t */\n\tprotected static Node getChildByName(Node node, String name) {\n\t\tNodeList children = node.getChildNodes();\n\n\t\t// this node matches\n\t\tif (node.getNodeName().equals(name))\n\t\t\treturn node;\n\n\t\t// search children\n\t\tfor (int i = 0; i < children.getLength(); i++) {\n\t\t\tNode found = getChildByName(children.item(i), name);\n\t\t\tif (found != null)\n\t\t\t\treturn found;\n\t\t}\n\n\t\t// failed\n\t\treturn null;\n\t}\n\n\t/**\n\t * Searches for all immediate children with the given name\n\t */\n\tprotected static List<Node> getChildrenByName(Node node, String name) {\n\t\tList<Node> matches = new ArrayList<>();\n\t\tNodeList children = node.getChildNodes();\n\n\t\t// search children\n\t\tfor (int i = 0; i < children.getLength(); i++) {\n\t\t\tNode child = children.item(i);\n\t\t\tif (child.getNodeName().equals(name)) {\n\t\t\t\tmatches.add(child);\n\t\t\t}\n\t\t}\n\n\t\treturn matches;\n\t}\n\n\t/**\n\t * Searches for children that have the given attribute\n\t */\n\tprotected static Node getChildByAttribute(Node node, String attributeName, String attributeValue) {\n\t\tNodeList children = node.getChildNodes();\n\t\tNamedNodeMap attribs = node.getAttributes();\n\t\tNode attribute = null;\n\n\t\t// this node matches\n\t\tif (attribs != null && (attribute = attribs.getNamedItem(attributeName)) != null\n\t\t\t\t&& attribute.getNodeValue().equals(attributeValue))\n\t\t\treturn node;\n\n\t\t// search children\n\t\tfor (int i = 0; i < children.getLength(); i++) {\n\t\t\tNode found = getChildByAttribute(children.item(i), attributeName, attributeValue);\n\t\t\tif (found != null)\n\t\t\t\treturn found;\n\t\t}\n\n\t\t// failed\n\t\treturn null;\n\t}\n\n\t/**\n\t * Searches for children that have the given name and attribute\n\t */\n\tprotected static Node getChildByNameAndAttribute(Node node, String name, String attributeName, String attributeValue) {\n\t\tNodeList children = node.getChildNodes();\n\t\tNamedNodeMap attribs = node.getAttributes();\n\t\tNode attribute = null;\n\n\t\t// this node matches\n\t\tif (node.getNodeName().equals(name) && attribs != null\n\t\t\t\t&& (attribute = attribs.getNamedItem(attributeName)) != null\n\t\t\t\t&& attribute.getNodeValue().equals(attributeValue))\n\t\t\treturn node;\n\n\t\t// search children\n\t\tfor (int i = 0; i < children.getLength(); i++) {\n\t\t\tNode found = getChildByAttribute(children.item(i), attributeName, attributeValue);\n\t\t\tif (found != null)\n\t\t\t\treturn found;\n\t\t}\n\n\t\t// failed\n\t\treturn null;\n\t}\n\n\t/**\n\t * Fetches the value of a given attribute\n\t */\n\tpublic static String getAttributeValue(Node node, String attributeName) {\n\t\ttry {\n\t\t\treturn node.getAttributes().getNamedItem(attributeName).getNodeValue();\n\t\t} catch (Exception e) {\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Constructs one Document from an XML file\n\t */\n\tpublic static Document readDocument(File f) throws IOException, SAXException, ParserConfigurationException {\n\t\tDocument document = null;\n\n\t\tDocumentBuilderFactory factory = XMLUtils.safeDocumentBuilderFactory();\n\t\t// factory.setValidating(true);\n\t\t// factory.setNamespaceAware(true);\n\n\t\ttry {\n\t\t\tDocumentBuilder builder = factory.newDocumentBuilder();\n\t\t\tdocument = builder.parse(f);\n\n\t\t\t// displayDocument(document);\n\n\t\t} catch (SAXException sxe) {\n\t\t\t// Error generated during parsing)\n\t\t\tException x = sxe;\n\t\t\tif (sxe.getException() != null)\n\t\t\t\tx = sxe.getException();\n\t\t\tx.printStackTrace();\n\t\t\tthrow sxe;\n\t\t} catch (ParserConfigurationException pce) {\n\t\t\t// Parser with specified options can't be built\n\t\t\tpce.printStackTrace();\n\t\t\tthrow pce;\n\t\t} catch (IOException ioe) {\n\t\t\t// I/O error\n\t\t\tioe.printStackTrace();\n\t\t\tthrow ioe;\n\t\t}\n\n\t\treturn document;\n\t} // readDocument\n}\n", "package edu.stanford.nlp.semgraph.semgrex.ssurgeon;\n\nimport java.io.*;\nimport java.util.*;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport java.text.DateFormat;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.transform.OutputKeys;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.stream.StreamResult;\n\nimport edu.stanford.nlp.util.StringUtils;\nimport edu.stanford.nlp.util.logging.RedwoodConfiguration;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\n\nimport edu.stanford.nlp.trees.GrammaticalRelation;\nimport edu.stanford.nlp.semgraph.SemanticGraph;\nimport edu.stanford.nlp.semgraph.SemanticGraphUtils;\nimport edu.stanford.nlp.semgraph.semgrex.ssurgeon.pred.*;\nimport edu.stanford.nlp.semgraph.semgrex.SemgrexPattern;\nimport edu.stanford.nlp.util.Generics;\nimport edu.stanford.nlp.util.XMLUtils;\nimport edu.stanford.nlp.util.logging.Redwood;\n\n\n/**\n * This is the primary class for loading and saving out Ssurgeon patterns.\n * This is also the class that maintains the current list of resources loaded into Ssurgeon: any pattern\n * loaded can reference these resources.\n *\n * @author Eric Yeh\n */\npublic class Ssurgeon  {\n\n  private static final boolean VERBOSE = false;\n\n  // singleton, to ensure all use the same resources\n  private static Ssurgeon instance = null;\n\n  private Ssurgeon() {}\n\n  public static Ssurgeon inst() {\n    synchronized(Ssurgeon.class) {\n      if (instance == null)\n        instance = new Ssurgeon();\n    }\n    return instance;\n  }\n\n  // Logging to file facilities.\n  // The prefix is used to append stuff in front of the logging messages\n  /** A logger for this class */\n  private static final Redwood.RedwoodChannels log = Redwood.channels(Ssurgeon.class);\n\n  private String logPrefix = null;\n  public void initLog(File logFilePath) throws IOException {\n    RedwoodConfiguration.empty()\n      .handlers(RedwoodConfiguration.Handlers.chain(\n        RedwoodConfiguration.Handlers.showAllChannels(), RedwoodConfiguration.Handlers.stderr),\n        RedwoodConfiguration.Handlers.file(logFilePath.toString())\n      ).apply();\n    // fh.setFormatter(new NewlineLogFormatter());\n\n    System.out.println(\"Starting Ssurgeon log, at \"+logFilePath.getAbsolutePath()+\" date=\" + DateFormat.getDateInstance(DateFormat.FULL).format(new Date()));\n    log.info(\"Starting Ssurgeon log, date=\" + DateFormat.getDateInstance(DateFormat.FULL).format(new Date()));\n  }\n\n  public void setLogPrefix(String logPrefix) {\n    this.logPrefix = logPrefix;\n  }\n\n\n\n  /**\n   * Given a list of SsurgeonPattern edit scripts, and a SemanticGraph\n   * to operate over, returns a list of expansions of that graph, with\n   * the result of each edit applied against a copy of the graph.\n   */\n  public  List<SemanticGraph> expandFromPatterns(List<SsurgeonPattern> patternList, SemanticGraph sg) throws Exception {\n    List<SemanticGraph> retList = new ArrayList<>();\n    for (SsurgeonPattern pattern :patternList) {\n      Collection<SemanticGraph> generated = pattern.execute(sg);\n      for (SemanticGraph orderedGraph : generated) {\n        //orderedGraph.vertexList(true);\n        //orderedGraph.edgeList(true);\n        retList.add(orderedGraph);\n        System.out.println(\"\\ncompact = \"+orderedGraph.toCompactString());\n        System.out.println(\"regular=\" + orderedGraph);\n      }\n\n      if (generated.size() > 0) {\n        if (log != null) {\n          log.info(\"* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\");\n          log.info(\"Pre remove duplicates, num=\"+generated.size());\n        }\n        SemanticGraphUtils.removeDuplicates(generated, sg);\n        if (log != null) {\n          log.info(\"Expand from patterns\");\n          if (logPrefix != null) log.info(logPrefix);\n          log.info(\"Pattern = '\"+pattern.getUID()+\"' generated \"+generated.size()+\" matches\");\n          log.info(\"= = = = = = = = = =\\nSrc graph:\\n\" + sg + \"\\n= = = = = = = = = =\\n\");\n          int index=1;\n          for (SemanticGraph genSg : generated) {\n            log.info(\"REWRITE \"+(index++));\n            log.info(genSg.toString());\n            log.info(\". . . . .\\n\");\n          }\n        }\n      }\n    }\n    return retList;\n  }\n\n  /**\n   * Similar to the expandFromPatterns, but performs an exhaustive\n   * search, performing simplifications on the graphs until exhausted.\n   *\n   * TODO: ensure cycles do not occur\n   * NOTE: put in an arbitrary depth limit of 3, to prevent churning way too much (heuristic)\n   *\n   */\n  public  Collection<SemanticGraph> exhaustFromPatterns(List<SsurgeonPattern> patternList, SemanticGraph sg) throws Exception {\n    Collection<SemanticGraph> generated = exhaustFromPatterns(patternList, sg, 1);\n    if (generated.size() > 1) {\n      if (log != null)\n        log.info(\"Before remove dupe, size=\"+generated.size());\n      generated = SemanticGraphUtils.removeDuplicates(generated, sg);\n      if (log != null)\n        log.info(\"AFTER remove dupe, size=\"+generated.size());\n    }\n    return generated;\n  }\n  private  List<SemanticGraph> exhaustFromPatterns(List<SsurgeonPattern> patternList, SemanticGraph sg, int depth) throws Exception {\n    List<SemanticGraph> retList = new ArrayList<>();\n    for (SsurgeonPattern pattern : patternList) {\n      Collection<SemanticGraph> generated = pattern.execute(sg);\n      for (SemanticGraph modGraph : generated) {\n        //modGraph = SemanticGraphUtils.resetVerticeOrdering(modGraph);\n        //modGraph.vertexList(true);\n        //modGraph.edgeList(true);\n        retList.add(modGraph);\n      }\n\n      if (log != null && generated.size() > 0) {\n        log.info(\"* * * * * * * * * ** * * * * * * * * *\");\n        log.info(\"Exhaust from patterns, depth=\"+depth);\n        if (logPrefix != null) log.info(logPrefix);\n        log.info(\"Pattern = '\"+pattern.getUID()+\"' generated \"+generated.size()+\" matches\");\n        log.info(\"= = = = = = = = = =\\nSrc graph:\\n\"+sg.toString()+\"\\n= = = = = = = = = =\\n\");\n        int index=1;\n        for (SemanticGraph genSg : generated) {\n          log.info(\"REWRITE \"+(index++));\n          log.info(genSg.toString());\n          log.info(\". . . . .\\n\");\n        }\n      }\n    }\n\n    if (retList.size() > 0) {\n      List<SemanticGraph> referenceList = new ArrayList<>(retList);\n      for (SemanticGraph childGraph : referenceList) {\n        if (depth < 3)\n          retList.addAll(exhaustFromPatterns(patternList, childGraph, depth + 1));\n      }\n    }\n    return retList;\n  }\n\n\n  /**\n   * Given a path to a file, converts it into a SsurgeonPattern\n   * TODO: finish implementing this stub.\n   */\n  public static SsurgeonPattern getOperationFromFile(String path) {\n    return null;\n  }\n\n  //\n  // Resource management\n  //\n  private Map<String, SsurgeonWordlist> wordListResources = Generics.newHashMap();\n\n  /**\n   * Places the given word list resource under the given ID.\n   * Note: can overwrite existing one in place.\n   */\n  private void addResource(SsurgeonWordlist resource) {\n    wordListResources.put(resource.getID(), resource);\n  }\n\n  /**\n   * Returns the given resource with the id.\n   * If does not exist, will throw exception.\n   */\n  public SsurgeonWordlist getResource(String id) {\n    return wordListResources.get(id);\n  }\n\n  public Collection<SsurgeonWordlist> getResources() {\n    return wordListResources.values();\n  }\n\n\n  public static final String GOV_NODENAME_ARG = \"-gov\";\n  public static final String DEP_NODENAME_ARG = \"-dep\";\n  public static final String EDGE_NAME_ARG = \"-edge\";\n  public static final String NODENAME_ARG = \"-node\";\n  public static final String RELN_ARG = \"-reln\";\n  public static final String NODE_PROTO_ARG = \"-nodearg\";\n  public static final String WEIGHT_ARG = \"-weight\";\n  public static final String NAME_ARG = \"-name\";\n\n\n  // args for Ssurgeon edits, allowing us to not\n  // worry about arg order (and to make things appear less confusing)\n  protected static class SsurgeonArgs {\n    // Below are values keyed by Semgrex name\n    public String govNodeName = null;\n\n    public String dep = null;\n\n    public String edge = null;\n\n    public String reln = null;\n\n    public String node = null;\n\n    // below are string representations of the intended values\n    public String nodeString = null;\n\n    public double weight = 1.0;\n\n    public String name = null;\n  }\n\n  /**\n   * This is a specialized args parser, as we want to split on\n   * whitespace, but retain everything inside quotes, so we can pass\n   * in hashmaps in String form.\n   */\n  private static String[] parseArgs(String argsString) {\n    List<String> retList = new ArrayList<>();\n    String patternString = \"(?:[^\\\\s\\\\\\\"]++|\\\\\\\"[^\\\\\\\"]*+\\\\\\\"|(\\\\\\\"))++\";\n    Pattern pattern = Pattern.compile(patternString);\n    Matcher matcher = pattern.matcher(argsString);\n    while (matcher.find()) {\n      if (matcher.group(1) == null) {\n        String matched = matcher.group();\n        if (matched.charAt(0) == '\"' &&\n            matched.charAt(matched.length()-1) == '\"')\n          retList.add(matched.substring(1, matched.length()-1));\n        else\n          retList.add(matched);\n      }  else\n        throw new IllegalArgumentException(\"Unmatched quote in string to parse\");\n    }\n    return retList.toArray(StringUtils.EMPTY_STRING_ARRAY);\n  }\n\n  /**\n   * Given a string entry, converts it into a SsurgeonEdit object.\n   */\n  public static SsurgeonEdit parseEditLine(String editLine) {\n    // Extract the operation name first\n    String[] tuples1 = editLine.split(\"\\\\s+\", 2);\n    if (tuples1.length < 2) {\n      throw new IllegalArgumentException(\"Error in SsurgeonEdit.parseEditLine: invalid number of arguments\");\n    }\n    String command = tuples1[0];\n    String[] argsArray = parseArgs(tuples1[1]);\n    SsurgeonArgs argsBox = new SsurgeonArgs();\n\n    for (int argIndex = 0; argIndex < argsArray.length; ++argIndex) {\n      switch (argsArray[argIndex]) {\n        case GOV_NODENAME_ARG:\n          argsBox.govNodeName = argsArray[argIndex + 1];\n          argIndex += 2;\n          break;\n        case DEP_NODENAME_ARG:\n          argsBox.dep = argsArray[argIndex + 1];\n          argIndex += 2;\n          break;\n        case EDGE_NAME_ARG:\n          argsBox.edge = argsArray[argIndex + 1];\n          argIndex += 2;\n          break;\n        case RELN_ARG:\n          argsBox.reln = argsArray[argIndex + 1];\n          argIndex += 2;\n          break;\n        case NODENAME_ARG:\n          argsBox.node = argsArray[argIndex + 1];\n          argIndex += 2;\n          break;\n        case NODE_PROTO_ARG:\n          argsBox.nodeString = argsArray[argIndex + 1];\n          argIndex += 2;\n          break;\n        case WEIGHT_ARG:\n          argsBox.weight = Double.valueOf(argsArray[argIndex + 1]);\n          argIndex += 2;\n          break;\n        case NAME_ARG:\n          argsBox.name = argsArray[argIndex + 1];\n          argIndex += 2;\n          break;\n        default:\n          throw new IllegalArgumentException(\"Parsing Ssurgeon args: unknown flag \" + argsArray[argIndex]);\n      }\n    }\n\n\n    // Parse the arguments based upon the type of command to execute.\n    // TODO: this logic really should be moved into the individual classes.  The string-->class\n    // mappings should also be stored in more appropriate data structure.\n    SsurgeonEdit retEdit;\n    if (command.equalsIgnoreCase(AddDep.LABEL)) {\n      retEdit = AddDep.createEngAddDep(argsBox.govNodeName, argsBox.reln, argsBox.nodeString);\n    } else if (command.equalsIgnoreCase(AddNode.LABEL)) {\n      retEdit = AddNode.createAddNode(argsBox.nodeString, argsBox.name);\n    } else if (command.equalsIgnoreCase(AddEdge.LABEL)) {\n      retEdit = AddEdge.createEngAddEdge(argsBox.govNodeName, argsBox.dep, argsBox.reln);\n    } else if (command.equalsIgnoreCase(DeleteGraphFromNode.LABEL)) {\n      retEdit = new DeleteGraphFromNode(argsBox.node);\n    } else if (command.equalsIgnoreCase(RemoveEdge.LABEL)) {\n      retEdit = new RemoveEdge(GrammaticalRelation.valueOf(argsBox.reln), argsBox.govNodeName, argsBox.dep);\n    } else if (command.equalsIgnoreCase(RemoveNamedEdge.LABEL)) {\n      retEdit = new RemoveNamedEdge(argsBox.edge, argsBox.govNodeName, argsBox.dep);\n    } else if (command.equalsIgnoreCase(SetRoots.LABEL)) {\n      String[] names = tuples1[1].split(\"\\\\s+\");\n      List<String> newRoots = Arrays.asList(names);\n      retEdit = new SetRoots(newRoots);\n    } else if (command.equalsIgnoreCase(KillNonRootedNodes.LABEL)) {\n      retEdit = new KillNonRootedNodes();\n    } else if (command.equalsIgnoreCase(KillAllIncomingEdges.LABEL)) {\n      retEdit = new KillAllIncomingEdges(argsBox.node);\n    } else {\n      throw new IllegalArgumentException(\"Error in SsurgeonEdit.parseEditLine: command '\"+command+\"' is not supported\");\n    }\n    return retEdit;\n  }\n\n  //public static SsurgeonPattern fromXML(String xmlString) throws Exception {\n  //SAXBuilder builder = new SAXBuilder();\n  //Document jdomDoc = builder.build(xmlString);\n  //jdomDoc.getRootElement().getChildren(SsurgeonPattern.SSURGEON_ELEM_TAG);\n  //}\n\n  /**\n   * Given a target filepath and a list of Ssurgeon patterns, writes them out as XML forms.\n   */\n  public static void writeToFile(File tgtFile, List<SsurgeonPattern> patterns) {\n    try {\n      Document domDoc = createPatternXMLDoc(patterns);\n      if (domDoc != null) {\n        Transformer tformer = TransformerFactory.newInstance().newTransformer();\n        tformer.setOutputProperty(OutputKeys.INDENT, \"yes\");\n        tformer.transform(new DOMSource(domDoc), new StreamResult(tgtFile));\n      } else {\n        log.warning(\"Was not able to create XML document for pattern list, file not written.\");\n      }\n    } catch (Exception e) {\n      log.error(Ssurgeon.class.getName(), \"writeToFile\");\n      log.error(e);\n    }\n  }\n\n  public static String writeToString(SsurgeonPattern pattern) {\n    try {\n      List<SsurgeonPattern> patterns = new LinkedList<>();\n      patterns.add(pattern);\n      Document domDoc = createPatternXMLDoc(patterns);\n      if (domDoc != null) {\n        Transformer tformer = TransformerFactory.newInstance().newTransformer();\n        tformer.setOutputProperty(OutputKeys.INDENT, \"yes\");\n        StringWriter sw = new StringWriter();\n        tformer.transform(new DOMSource(domDoc), new StreamResult(sw));\n        return sw.toString();\n      } else {\n        log.warning(\"Was not able to create XML document for pattern list.\");\n      }\n    } catch (Exception e) {\n      log.info(\"Error in writeToString, could not process pattern=\"+pattern);\n      log.info(e);\n      return null;\n    }\n    return \"\";\n  }\n\n\n  private static Document createPatternXMLDoc(List<SsurgeonPattern> patterns) {\n    try {\n      DocumentBuilderFactory dbf = XMLUtils.safeDocumentBuilderFactory();\n      DocumentBuilder db = dbf.newDocumentBuilder();\n      Document domDoc = db.newDocument();\n      Element rootElt = domDoc.createElement(SsurgeonPattern.ELT_LIST_TAG);\n      domDoc.appendChild(rootElt);\n      int ordinal = 1;\n      for (SsurgeonPattern pattern : patterns) {\n        Element patElt = domDoc.createElement(SsurgeonPattern.SSURGEON_ELEM_TAG);\n        patElt.setAttribute(SsurgeonPattern.ORDINAL_ATTR, String.valueOf(ordinal));\n        Element semgrexElt = domDoc.createElement(SsurgeonPattern.SEMGREX_ELEM_TAG);\n        semgrexElt.appendChild(domDoc.createTextNode(pattern.getSemgrexPattern().pattern()));\n        patElt.appendChild(semgrexElt);\n        Element uidElem = domDoc.createElement(SsurgeonPattern.UID_ELEM_TAG);\n        uidElem.appendChild(domDoc.createTextNode(pattern.getUID()));\n        patElt.appendChild(uidElem);\n        Element notesElem = domDoc.createElement(SsurgeonPattern.NOTES_ELEM_TAG);\n        notesElem.appendChild(domDoc.createTextNode(pattern.getNotes()));\n        patElt.appendChild(notesElem);\n\n        SemanticGraph semgrexGraph = pattern.getSemgrexGraph();\n        if (semgrexGraph != null) {\n          Element patNode = domDoc.createElement(SsurgeonPattern.SEMGREX_GRAPH_ELEM_TAG);\n          patNode.appendChild(domDoc.createTextNode(semgrexGraph.toCompactString()));\n        }\n        Element editList = domDoc.createElement(SsurgeonPattern.EDIT_LIST_ELEM_TAG);\n        patElt.appendChild(editList);\n        int editOrdinal = 1;\n        for (SsurgeonEdit edit : pattern.getEditScript()) {\n          Element editElem = domDoc.createElement(SsurgeonPattern.EDIT_ELEM_TAG);\n          editElem.setAttribute(SsurgeonPattern.ORDINAL_ATTR, String.valueOf(editOrdinal));\n          editElem.appendChild(domDoc.createTextNode(edit.toEditString()));\n          editList.appendChild(editElem);\n          editOrdinal++;\n        }\n        rootElt.appendChild(patElt);\n        ordinal++;\n      }\n      return domDoc;\n    } catch (Exception e) {\n      log.error(Ssurgeon.class.getName(), \"createPatternXML\");\n      log.error(e);\n      return null;\n    }\n  }\n\n\n  /**\n   * Given a path to a file containing a list of SsurgeonPatterns, returns\n   *\n   * TODO: deal with resources\n   * @throws Exception\n   */\n  @SuppressWarnings(\"unchecked\")\n  public List<SsurgeonPattern> readFromFile(File file) throws Exception {\n    List<SsurgeonPattern> retList = new ArrayList<>();\n    Document doc = XMLUtils.safeDocumentBuilderFactory().newDocumentBuilder().parse(file);\n\n    if (VERBOSE)\n      System.out.println(\"Reading ssurgeon file=\"+file.getAbsolutePath());\n\n    NodeList patternNodes = doc.getElementsByTagName(SsurgeonPattern.SSURGEON_ELEM_TAG);\n    for (int i=0; i<patternNodes.getLength(); i++) {\n      Node node = patternNodes.item(i);\n      if (node.getNodeType() == Node.ELEMENT_NODE) {\n        Element elt = (Element) node;\n        SsurgeonPattern pattern = ssurgeonPatternFromXML(elt);\n        retList.add(pattern);\n      }\n    }\n\n    NodeList resourceNodes = doc.getElementsByTagName(SsurgeonPattern.RESOURCE_TAG);\n    for (int i=0; i < resourceNodes.getLength(); i++) {\n      Node node = patternNodes.item(i);\n      if (node.getNodeType() == Node.ELEMENT_NODE) {\n        Element resourceElt = (Element) node;\n        SsurgeonWordlist wlRsrc = new SsurgeonWordlist(resourceElt);\n        addResource(wlRsrc);\n      }\n    }\n\n    return retList;\n  }\n\n  /**\n   * Reads all Ssurgeon patterns from file.\n   * @throws Exception\n   */\n  public List<SsurgeonPattern> readFromDirectory(File dir) throws Exception {\n    if (!dir.isDirectory()) throw new Exception(\"Given path not a directory, path=\"+dir.getAbsolutePath());\n    if (VERBOSE)\n      System.out.println(\"Reading Ssurgeon patterns from directory = \"+dir.getAbsolutePath());\n    File[] files = dir.listFiles((dir1, name) -> name.toLowerCase().endsWith(\".xml\"));\n    List<SsurgeonPattern> patterns = new ArrayList<>();\n    for (File file : files) {\n      try {\n        patterns.addAll(readFromFile(file));\n      } catch (Exception e) {\n        log.error(e);\n      }\n    }\n    return patterns;\n  }\n\n  /**\n   * Given the root Element for a SemgrexPattern (SSURGEON_ELEM_TAG), converts\n   * it into its corresponding SemgrexPattern object.\n   * @throws Exception\n   */\n  @SuppressWarnings(\"unchecked\")\n  public static SsurgeonPattern ssurgeonPatternFromXML(Element elt) throws Exception {\n    String uid = getTagText(elt, SsurgeonPattern.UID_ELEM_TAG);\n    String notes = getTagText(elt, SsurgeonPattern.NOTES_ELEM_TAG);\n    String semgrexString = getTagText(elt, SsurgeonPattern.SEMGREX_ELEM_TAG);\n    SemgrexPattern semgrexPattern = SemgrexPattern.compile(semgrexString);\n    SsurgeonPattern retPattern = new SsurgeonPattern(uid, semgrexPattern);\n    retPattern.setNotes(notes);\n    NodeList editNodes = elt.getElementsByTagName(SsurgeonPattern.EDIT_LIST_ELEM_TAG);\n    for (int i=0; i<editNodes.getLength(); i++) {\n      Node node = editNodes.item(i);\n      if (node.getNodeType() == Node.ELEMENT_NODE) {\n        Element editElt = (Element) node;\n        String editVal = getEltText(editElt);\n        retPattern.addEdit(Ssurgeon.parseEditLine(editVal));\n      }\n    }\n\n\n    // If predicate available, parse\n    Element predElt = getFirstTag(elt, SsurgeonPattern.PREDICATE_TAG);\n    if (predElt != null) {\n      SsurgPred pred = assemblePredFromXML(getFirstChildElement(predElt));\n      retPattern.setPredicate(pred);\n    }\n    return retPattern;\n  }\n\n  /**\n   * Constructs a {@code SsurgPred} structure from file, given the root element.\n   * @throws Exception\n   */\n  public static SsurgPred assemblePredFromXML(Element elt) throws Exception {\n    String eltName = elt.getTagName();\n    switch (eltName) {\n      case SsurgeonPattern.PREDICATE_AND_TAG:\n        SsurgAndPred andPred = new SsurgAndPred();\n        for (Element childElt : getChildElements(elt)) {\n          SsurgPred childPred = assemblePredFromXML(childElt);\n          andPred.add(childPred);\n          return andPred;\n        }\n        break;\n      case SsurgeonPattern.PREDICATE_OR_TAG:\n        SsurgOrPred orPred = new SsurgOrPred();\n        for (Element childElt : getChildElements(elt)) {\n          SsurgPred childPred = assemblePredFromXML(childElt);\n          orPred.add(childPred);\n          return orPred;\n        }\n        break;\n      case SsurgeonPattern.PRED_WORDLIST_TEST_TAG:\n        String id = elt.getAttribute(SsurgeonPattern.PRED_ID_ATTR);\n        String resourceID = elt.getAttribute(\"resourceID\");\n        String typeStr = elt.getAttribute(\"type\");\n        String matchName = getEltText(elt).trim(); // node name to match on\n\n        if (matchName == null) {\n          throw new Exception(\"Could not find match name for \" + elt);\n        }\n        if (id == null) {\n          throw new Exception(\"No ID attribute for element = \" + elt);\n        }\n        return new WordlistTest(id, resourceID, typeStr, matchName);\n    }\n\n    // Not a valid node, error out!\n    throw new Exception(\"Invalid node encountered during Ssurgeon predicate processing, node name=\"+eltName);\n  }\n\n\n\n  /**\n   * Reads in the test file and prints readable to string (for debugging).\n   * Input file consists of semantic graphs, in compact form.\n   */\n  public void testRead(File tgtDirPath) throws Exception {\n    List<SsurgeonPattern> patterns = readFromDirectory(tgtDirPath);\n\n    System.out.println(\"Patterns, num = \"+patterns.size());\n    int num = 1;\n    for (SsurgeonPattern pattern : patterns) {\n      System.out.println(\"\\n# \"+(num++));\n      System.out.println(pattern);\n    }\n\n    System.out.println(\"\\n\\nRESOURCES \");\n    for (SsurgeonWordlist rsrc : inst().getResources()) {\n      System.out.println(rsrc+\"* * * * *\");\n    }\n\n    BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n    boolean runFlag = true;\n    Ssurgeon.inst().initLog(new File(\"./ssurgeon_run.log\"));\n    while (runFlag) {\n      try {\n        System.out.println(\"Enter a sentence:\");\n        String line = in.readLine();\n        if (line.isEmpty()) {\n          System.exit(0);\n        }\n        System.out.println(\"Parsing...\");\n        SemanticGraph sg = SemanticGraph.valueOf(line);\n        System.out.println(\"Graph = \"+sg);\n        Collection<SemanticGraph> generated = Ssurgeon.inst().exhaustFromPatterns(patterns, sg);\n        System.out.println(\"# generated = \"+generated.size());\n        int index = 1;\n        for (SemanticGraph gsg : generated) {\n          System.out.println(\"\\n# \"+index);\n          System.out.println(gsg);\n          index++;\n        }\n      } catch (Exception e) {\n        log.error(e);\n      }\n    }\n  }\n\n\n  /*\n   * XML convenience routines\n   */\n  // todo [cdm 2016]: Aren't some of these methods available as generic XML methods elsewhere??\n\n  /**\n   * For the given element, returns the text for the first child Element with\n   * the given tag.\n   */\n  public static String getTagText(Element element, String tag) {\n    try {\n      // From root element, identify first with tag, then find the\n      // first child under that, which we treat as a TEXT node.\n      Element firstElt = getFirstTag(element, tag);\n      if (firstElt == null) return \"\";\n      return getEltText(firstElt);\n    } catch (Exception e) {\n      log.warning(\"Exception thrown attempting to get tag text for tag=\"+tag+\", from element=\"+element);\n    }\n    return \"\";\n  }\n\n  /**\n   * For a given Element, treats the first child as a text element\n   * and returns its value.\n   */\n  public static String getEltText(Element element) {\n    try {\n      NodeList childNodeList = element.getChildNodes();\n      if (childNodeList.getLength() == 0) return \"\";\n      return childNodeList.item(0).getNodeValue();\n    } catch (Exception e) {\n      log.warning(\"Exception e=\" + e.getMessage() + \" thrown calling getEltText on element=\" + element);\n    }\n    return \"\";\n  }\n\n  /**\n   * For the given element, finds the first child Element with the given tag.\n   */\n  private static Element getFirstTag(Element element, String tag) {\n    try {\n      NodeList nodeList = element.getElementsByTagName(tag);\n      if (nodeList.getLength() == 0) return null;\n      for (int i=0; i < nodeList.getLength(); i++) {\n        Node node = nodeList.item(i);\n        if (node.getNodeType() == Node.ELEMENT_NODE)\n          return (Element) node;\n      }\n    } catch (Exception e) {\n      log.warning(\"Error getting first tag \"+tag+\" under element=\"+element);\n    }\n    return null;\n  }\n\n  /**\n   * Returns the first child whose node type is Element under the given Element.\n   */\n  private static Element getFirstChildElement(Element element) {\n    try {\n      NodeList nodeList = element.getChildNodes();\n      for (int i=0; i<nodeList.getLength(); i++) {\n        Node node = nodeList.item(i);\n        if (node.getNodeType() == Node.ELEMENT_NODE)\n          return (Element) node;\n      }\n    } catch (Exception e) {\n      log.warning(\"Error getting first child Element for element=\" + element+\", exception=\" + e);\n    }\n    return null;\n  }\n\n\n  /**\n   * Returns all of the Element typed children from the given element.  Note: disregards\n   * other node types.\n   */\n  private static List<Element> getChildElements(Element element) {\n    LinkedList<Element> childElements = new LinkedList<>();\n    try {\n      NodeList nodeList = element.getChildNodes();\n      for (int i=0; i<nodeList.getLength(); i++) {\n        Node node = nodeList.item(i);\n        if (node.getNodeType() == Node.ELEMENT_NODE) {\n          childElements.add((Element) node);\n        }\n      }\n    } catch (Exception e) {\n      log.warning(\"Exception thrown getting all children for element=\" + element+ \", e=\" + e);\n    }\n    return childElements;\n  }\n\n  /*\n   * Main class evocation stuff\n   */\n\n\n  public enum RUNTYPE {\n    interactive, // interactively test contents of pattern directory against entered sentences\n    testinfo // test against a given infofile (RTE), generating rewrites for hypotheses\n  }\n\n\n  public static class ArgsBox {\n    public RUNTYPE type = RUNTYPE.interactive;\n\n    public String patternDirStr = null;\n    public File patternDir = null;\n\n    public String info = null;\n    public File infoPath = null;\n\n    public void init() {\n      patternDir = new File(patternDirStr);\n      if (type == RUNTYPE.testinfo)\n        infoPath = new File(info);\n    }\n\n    @Override\n    public String toString() {\n      StringWriter buf = new StringWriter();\n      buf.write(\"type =\"+type+\"\\n\");\n      buf.write(\"pattern dir = \"+patternDir.getAbsolutePath());\n      if (type == RUNTYPE.testinfo) {\n        buf.write(\"info file = \"+info);\n        if (info != null)\n          buf.write(\", path = \"+infoPath.getAbsolutePath());\n      }\n      return buf.toString();\n    }\n  }\n\n  protected static ArgsBox argsBox = new ArgsBox();\n\n  /**\n   * Performs a simple test and print of a given file.\n   * Usage Ssurgeon [-info infoFile] -patterns patternDir [-type interactive|testinfo]\n   */\n  public static void main(String[] args) {\n    for (int argIndex = 0; argIndex < args.length; ++argIndex) {\n      if (args[argIndex].equalsIgnoreCase(\"-info\")) {\n        argsBox.info = args[argIndex + 1];\n        argIndex += 2;\n      } else if (args[argIndex].equalsIgnoreCase(\"-patterns\")) {\n        argsBox.patternDirStr = args[argIndex + 1];\n        argIndex += 2;\n      } else if (args[argIndex].equalsIgnoreCase(\"-type\")) {\n        argsBox.type = RUNTYPE.valueOf(args[argIndex + 1]);\n        argIndex += 2;\n      }\n    }\n    if (argsBox.patternDirStr == null) {\n      throw new IllegalArgumentException(\"Need to give a pattern location with -patterns\");\n    }\n    argsBox.init();\n\n    System.out.println(argsBox);\n    try {\n      if (argsBox.type == RUNTYPE.interactive) {\n        Ssurgeon.inst().testRead(argsBox.patternDir);\n      }\n    } catch (Exception e) {\n      log.error(e);\n    }\n  }\n\n}\n"], "filenames": ["src/edu/stanford/nlp/ie/machinereading/common/DomReader.java", "src/edu/stanford/nlp/semgraph/semgrex/ssurgeon/Ssurgeon.java"], "buggy_code_start_loc": [17, 29], "buggy_code_end_loc": [131, 456], "fixing_code_start_loc": [18, 30], "fixing_code_end_loc": [133, 457], "type": "CWE-611", "message": "corenlp is vulnerable to Improper Restriction of XML External Entity Reference", "other": {"cve": {"id": "CVE-2021-3878", "sourceIdentifier": "security@huntr.dev", "published": "2021-10-15T14:15:07.857", "lastModified": "2021-10-20T19:55:08.027", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "corenlp is vulnerable to Improper Restriction of XML External Entity Reference"}, {"lang": "es", "value": "corenlp es vulnerable a una restricci\u00f3n inapropiada de la Referencia de Entidad Externa XML"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-611"}]}, {"source": "security@huntr.dev", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-611"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:stanford:corenlp:*:*:*:*:*:*:*:*", "versionEndExcluding": "4.3.0", "matchCriteriaId": "89215FDF-7A4B-4743-B7ED-163FCE116DBE"}]}]}], "references": [{"url": "https://github.com/stanfordnlp/corenlp/commit/e5bbe135a02a74b952396751ed3015e8b8252e99", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/a11c889b-ccff-4fea-9e29-963a23a63dd2", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/stanfordnlp/corenlp/commit/e5bbe135a02a74b952396751ed3015e8b8252e99"}}