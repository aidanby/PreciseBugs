{"buggy_code": ["/*\n * Apple HTTP Live Streaming demuxer\n * Copyright (c) 2010 Martin Storsjo\n * Copyright (c) 2013 Anssi Hannula\n *\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n/**\n * @file\n * Apple HTTP Live Streaming demuxer\n * http://tools.ietf.org/html/draft-pantos-http-live-streaming\n */\n\n#include \"libavutil/avstring.h\"\n#include \"libavutil/avassert.h\"\n#include \"libavutil/intreadwrite.h\"\n#include \"libavutil/mathematics.h\"\n#include \"libavutil/opt.h\"\n#include \"libavutil/dict.h\"\n#include \"libavutil/time.h\"\n#include \"avformat.h\"\n#include \"internal.h\"\n#include \"avio_internal.h\"\n#include \"id3v2.h\"\n\n#define INITIAL_BUFFER_SIZE 32768\n\n#define MAX_FIELD_LEN 64\n#define MAX_CHARACTERISTICS_LEN 512\n\n#define MPEG_TIME_BASE 90000\n#define MPEG_TIME_BASE_Q (AVRational){1, MPEG_TIME_BASE}\n\n/*\n * An apple http stream consists of a playlist with media segment files,\n * played sequentially. There may be several playlists with the same\n * video content, in different bandwidth variants, that are played in\n * parallel (preferably only one bandwidth variant at a time). In this case,\n * the user supplied the url to a main playlist that only lists the variant\n * playlists.\n *\n * If the main playlist doesn't point at any variants, we still create\n * one anonymous toplevel variant for this, to maintain the structure.\n */\n\nenum KeyType {\n    KEY_NONE,\n    KEY_AES_128,\n    KEY_SAMPLE_AES\n};\n\nstruct segment {\n    int64_t duration;\n    int64_t url_offset;\n    int64_t size;\n    char *url;\n    char *key;\n    enum KeyType key_type;\n    uint8_t iv[16];\n    /* associated Media Initialization Section, treated as a segment */\n    struct segment *init_section;\n};\n\nstruct rendition;\n\nenum PlaylistType {\n    PLS_TYPE_UNSPECIFIED,\n    PLS_TYPE_EVENT,\n    PLS_TYPE_VOD\n};\n\n/*\n * Each playlist has its own demuxer. If it currently is active,\n * it has an open AVIOContext too, and potentially an AVPacket\n * containing the next packet from this stream.\n */\nstruct playlist {\n    char url[MAX_URL_SIZE];\n    AVIOContext pb;\n    uint8_t* read_buffer;\n    AVIOContext *input;\n    AVFormatContext *parent;\n    int index;\n    AVFormatContext *ctx;\n    AVPacket pkt;\n    int has_noheader_flag;\n\n    /* main demuxer streams associated with this playlist\n     * indexed by the subdemuxer stream indexes */\n    AVStream **main_streams;\n    int n_main_streams;\n\n    int finished;\n    enum PlaylistType type;\n    int64_t target_duration;\n    int start_seq_no;\n    int n_segments;\n    struct segment **segments;\n    int needed, cur_needed;\n    int cur_seq_no;\n    int64_t cur_seg_offset;\n    int64_t last_load_time;\n\n    /* Currently active Media Initialization Section */\n    struct segment *cur_init_section;\n    uint8_t *init_sec_buf;\n    unsigned int init_sec_buf_size;\n    unsigned int init_sec_data_len;\n    unsigned int init_sec_buf_read_offset;\n\n    char key_url[MAX_URL_SIZE];\n    uint8_t key[16];\n\n    /* ID3 timestamp handling (elementary audio streams have ID3 timestamps\n     * (and possibly other ID3 tags) in the beginning of each segment) */\n    int is_id3_timestamped; /* -1: not yet known */\n    int64_t id3_mpegts_timestamp; /* in mpegts tb */\n    int64_t id3_offset; /* in stream original tb */\n    uint8_t* id3_buf; /* temp buffer for id3 parsing */\n    unsigned int id3_buf_size;\n    AVDictionary *id3_initial; /* data from first id3 tag */\n    int id3_found; /* ID3 tag found at some point */\n    int id3_changed; /* ID3 tag data has changed at some point */\n    ID3v2ExtraMeta *id3_deferred_extra; /* stored here until subdemuxer is opened */\n\n    int64_t seek_timestamp;\n    int seek_flags;\n    int seek_stream_index; /* into subdemuxer stream array */\n\n    /* Renditions associated with this playlist, if any.\n     * Alternative rendition playlists have a single rendition associated\n     * with them, and variant main Media Playlists may have\n     * multiple (playlist-less) renditions associated with them. */\n    int n_renditions;\n    struct rendition **renditions;\n\n    /* Media Initialization Sections (EXT-X-MAP) associated with this\n     * playlist, if any. */\n    int n_init_sections;\n    struct segment **init_sections;\n};\n\n/*\n * Renditions are e.g. alternative subtitle or audio streams.\n * The rendition may either be an external playlist or it may be\n * contained in the main Media Playlist of the variant (in which case\n * playlist is NULL).\n */\nstruct rendition {\n    enum AVMediaType type;\n    struct playlist *playlist;\n    char group_id[MAX_FIELD_LEN];\n    char language[MAX_FIELD_LEN];\n    char name[MAX_FIELD_LEN];\n    int disposition;\n};\n\nstruct variant {\n    int bandwidth;\n\n    /* every variant contains at least the main Media Playlist in index 0 */\n    int n_playlists;\n    struct playlist **playlists;\n\n    char audio_group[MAX_FIELD_LEN];\n    char video_group[MAX_FIELD_LEN];\n    char subtitles_group[MAX_FIELD_LEN];\n};\n\ntypedef struct HLSContext {\n    AVClass *class;\n    AVFormatContext *ctx;\n    int n_variants;\n    struct variant **variants;\n    int n_playlists;\n    struct playlist **playlists;\n    int n_renditions;\n    struct rendition **renditions;\n\n    int cur_seq_no;\n    int live_start_index;\n    int first_packet;\n    int64_t first_timestamp;\n    int64_t cur_timestamp;\n    AVIOInterruptCB *interrupt_callback;\n    char *user_agent;                    ///< holds HTTP user agent set as an AVOption to the HTTP protocol context\n    char *cookies;                       ///< holds HTTP cookie values set in either the initial response or as an AVOption to the HTTP protocol context\n    char *headers;                       ///< holds HTTP headers set as an AVOption to the HTTP protocol context\n    char *http_proxy;                    ///< holds the address of the HTTP proxy server\n    AVDictionary *avio_opts;\n    int strict_std_compliance;\n} HLSContext;\n\nstatic int read_chomp_line(AVIOContext *s, char *buf, int maxlen)\n{\n    int len = ff_get_line(s, buf, maxlen);\n    while (len > 0 && av_isspace(buf[len - 1]))\n        buf[--len] = '\\0';\n    return len;\n}\n\nstatic void free_segment_list(struct playlist *pls)\n{\n    int i;\n    for (i = 0; i < pls->n_segments; i++) {\n        av_freep(&pls->segments[i]->key);\n        av_freep(&pls->segments[i]->url);\n        av_freep(&pls->segments[i]);\n    }\n    av_freep(&pls->segments);\n    pls->n_segments = 0;\n}\n\nstatic void free_init_section_list(struct playlist *pls)\n{\n    int i;\n    for (i = 0; i < pls->n_init_sections; i++) {\n        av_freep(&pls->init_sections[i]->url);\n        av_freep(&pls->init_sections[i]);\n    }\n    av_freep(&pls->init_sections);\n    pls->n_init_sections = 0;\n}\n\nstatic void free_playlist_list(HLSContext *c)\n{\n    int i;\n    for (i = 0; i < c->n_playlists; i++) {\n        struct playlist *pls = c->playlists[i];\n        free_segment_list(pls);\n        free_init_section_list(pls);\n        av_freep(&pls->main_streams);\n        av_freep(&pls->renditions);\n        av_freep(&pls->id3_buf);\n        av_dict_free(&pls->id3_initial);\n        ff_id3v2_free_extra_meta(&pls->id3_deferred_extra);\n        av_freep(&pls->init_sec_buf);\n        av_packet_unref(&pls->pkt);\n        av_freep(&pls->pb.buffer);\n        if (pls->input)\n            ff_format_io_close(c->ctx, &pls->input);\n        if (pls->ctx) {\n            pls->ctx->pb = NULL;\n            avformat_close_input(&pls->ctx);\n        }\n        av_free(pls);\n    }\n    av_freep(&c->playlists);\n    av_freep(&c->cookies);\n    av_freep(&c->user_agent);\n    av_freep(&c->headers);\n    av_freep(&c->http_proxy);\n    c->n_playlists = 0;\n}\n\nstatic void free_variant_list(HLSContext *c)\n{\n    int i;\n    for (i = 0; i < c->n_variants; i++) {\n        struct variant *var = c->variants[i];\n        av_freep(&var->playlists);\n        av_free(var);\n    }\n    av_freep(&c->variants);\n    c->n_variants = 0;\n}\n\nstatic void free_rendition_list(HLSContext *c)\n{\n    int i;\n    for (i = 0; i < c->n_renditions; i++)\n        av_freep(&c->renditions[i]);\n    av_freep(&c->renditions);\n    c->n_renditions = 0;\n}\n\n/*\n * Used to reset a statically allocated AVPacket to a clean slate,\n * containing no data.\n */\nstatic void reset_packet(AVPacket *pkt)\n{\n    av_init_packet(pkt);\n    pkt->data = NULL;\n}\n\nstatic struct playlist *new_playlist(HLSContext *c, const char *url,\n                                     const char *base)\n{\n    struct playlist *pls = av_mallocz(sizeof(struct playlist));\n    if (!pls)\n        return NULL;\n    reset_packet(&pls->pkt);\n    ff_make_absolute_url(pls->url, sizeof(pls->url), base, url);\n    pls->seek_timestamp = AV_NOPTS_VALUE;\n\n    pls->is_id3_timestamped = -1;\n    pls->id3_mpegts_timestamp = AV_NOPTS_VALUE;\n\n    dynarray_add(&c->playlists, &c->n_playlists, pls);\n    return pls;\n}\n\nstruct variant_info {\n    char bandwidth[20];\n    /* variant group ids: */\n    char audio[MAX_FIELD_LEN];\n    char video[MAX_FIELD_LEN];\n    char subtitles[MAX_FIELD_LEN];\n};\n\nstatic struct variant *new_variant(HLSContext *c, struct variant_info *info,\n                                   const char *url, const char *base)\n{\n    struct variant *var;\n    struct playlist *pls;\n\n    pls = new_playlist(c, url, base);\n    if (!pls)\n        return NULL;\n\n    var = av_mallocz(sizeof(struct variant));\n    if (!var)\n        return NULL;\n\n    if (info) {\n        var->bandwidth = atoi(info->bandwidth);\n        strcpy(var->audio_group, info->audio);\n        strcpy(var->video_group, info->video);\n        strcpy(var->subtitles_group, info->subtitles);\n    }\n\n    dynarray_add(&c->variants, &c->n_variants, var);\n    dynarray_add(&var->playlists, &var->n_playlists, pls);\n    return var;\n}\n\nstatic void handle_variant_args(struct variant_info *info, const char *key,\n                                int key_len, char **dest, int *dest_len)\n{\n    if (!strncmp(key, \"BANDWIDTH=\", key_len)) {\n        *dest     =        info->bandwidth;\n        *dest_len = sizeof(info->bandwidth);\n    } else if (!strncmp(key, \"AUDIO=\", key_len)) {\n        *dest     =        info->audio;\n        *dest_len = sizeof(info->audio);\n    } else if (!strncmp(key, \"VIDEO=\", key_len)) {\n        *dest     =        info->video;\n        *dest_len = sizeof(info->video);\n    } else if (!strncmp(key, \"SUBTITLES=\", key_len)) {\n        *dest     =        info->subtitles;\n        *dest_len = sizeof(info->subtitles);\n    }\n}\n\nstruct key_info {\n     char uri[MAX_URL_SIZE];\n     char method[11];\n     char iv[35];\n};\n\nstatic void handle_key_args(struct key_info *info, const char *key,\n                            int key_len, char **dest, int *dest_len)\n{\n    if (!strncmp(key, \"METHOD=\", key_len)) {\n        *dest     =        info->method;\n        *dest_len = sizeof(info->method);\n    } else if (!strncmp(key, \"URI=\", key_len)) {\n        *dest     =        info->uri;\n        *dest_len = sizeof(info->uri);\n    } else if (!strncmp(key, \"IV=\", key_len)) {\n        *dest     =        info->iv;\n        *dest_len = sizeof(info->iv);\n    }\n}\n\nstruct init_section_info {\n    char uri[MAX_URL_SIZE];\n    char byterange[32];\n};\n\nstatic struct segment *new_init_section(struct playlist *pls,\n                                        struct init_section_info *info,\n                                        const char *url_base)\n{\n    struct segment *sec;\n    char *ptr;\n    char tmp_str[MAX_URL_SIZE];\n\n    if (!info->uri[0])\n        return NULL;\n\n    sec = av_mallocz(sizeof(*sec));\n    if (!sec)\n        return NULL;\n\n    ff_make_absolute_url(tmp_str, sizeof(tmp_str), url_base, info->uri);\n    sec->url = av_strdup(tmp_str);\n    if (!sec->url) {\n        av_free(sec);\n        return NULL;\n    }\n\n    if (info->byterange[0]) {\n        sec->size = strtoll(info->byterange, NULL, 10);\n        ptr = strchr(info->byterange, '@');\n        if (ptr)\n            sec->url_offset = strtoll(ptr+1, NULL, 10);\n    } else {\n        /* the entire file is the init section */\n        sec->size = -1;\n    }\n\n    dynarray_add(&pls->init_sections, &pls->n_init_sections, sec);\n\n    return sec;\n}\n\nstatic void handle_init_section_args(struct init_section_info *info, const char *key,\n                                           int key_len, char **dest, int *dest_len)\n{\n    if (!strncmp(key, \"URI=\", key_len)) {\n        *dest     =        info->uri;\n        *dest_len = sizeof(info->uri);\n    } else if (!strncmp(key, \"BYTERANGE=\", key_len)) {\n        *dest     =        info->byterange;\n        *dest_len = sizeof(info->byterange);\n    }\n}\n\nstruct rendition_info {\n    char type[16];\n    char uri[MAX_URL_SIZE];\n    char group_id[MAX_FIELD_LEN];\n    char language[MAX_FIELD_LEN];\n    char assoc_language[MAX_FIELD_LEN];\n    char name[MAX_FIELD_LEN];\n    char defaultr[4];\n    char forced[4];\n    char characteristics[MAX_CHARACTERISTICS_LEN];\n};\n\nstatic struct rendition *new_rendition(HLSContext *c, struct rendition_info *info,\n                                      const char *url_base)\n{\n    struct rendition *rend;\n    enum AVMediaType type = AVMEDIA_TYPE_UNKNOWN;\n    char *characteristic;\n    char *chr_ptr;\n    char *saveptr;\n\n    if (!strcmp(info->type, \"AUDIO\"))\n        type = AVMEDIA_TYPE_AUDIO;\n    else if (!strcmp(info->type, \"VIDEO\"))\n        type = AVMEDIA_TYPE_VIDEO;\n    else if (!strcmp(info->type, \"SUBTITLES\"))\n        type = AVMEDIA_TYPE_SUBTITLE;\n    else if (!strcmp(info->type, \"CLOSED-CAPTIONS\"))\n        /* CLOSED-CAPTIONS is ignored since we do not support CEA-608 CC in\n         * AVC SEI RBSP anyway */\n        return NULL;\n\n    if (type == AVMEDIA_TYPE_UNKNOWN)\n        return NULL;\n\n    /* URI is mandatory for subtitles as per spec */\n    if (type == AVMEDIA_TYPE_SUBTITLE && !info->uri[0])\n        return NULL;\n\n    /* TODO: handle subtitles (each segment has to parsed separately) */\n    if (c->strict_std_compliance > FF_COMPLIANCE_EXPERIMENTAL)\n        if (type == AVMEDIA_TYPE_SUBTITLE)\n            return NULL;\n\n    rend = av_mallocz(sizeof(struct rendition));\n    if (!rend)\n        return NULL;\n\n    dynarray_add(&c->renditions, &c->n_renditions, rend);\n\n    rend->type = type;\n    strcpy(rend->group_id, info->group_id);\n    strcpy(rend->language, info->language);\n    strcpy(rend->name, info->name);\n\n    /* add the playlist if this is an external rendition */\n    if (info->uri[0]) {\n        rend->playlist = new_playlist(c, info->uri, url_base);\n        if (rend->playlist)\n            dynarray_add(&rend->playlist->renditions,\n                         &rend->playlist->n_renditions, rend);\n    }\n\n    if (info->assoc_language[0]) {\n        int langlen = strlen(rend->language);\n        if (langlen < sizeof(rend->language) - 3) {\n            rend->language[langlen] = ',';\n            strncpy(rend->language + langlen + 1, info->assoc_language,\n                    sizeof(rend->language) - langlen - 2);\n        }\n    }\n\n    if (!strcmp(info->defaultr, \"YES\"))\n        rend->disposition |= AV_DISPOSITION_DEFAULT;\n    if (!strcmp(info->forced, \"YES\"))\n        rend->disposition |= AV_DISPOSITION_FORCED;\n\n    chr_ptr = info->characteristics;\n    while ((characteristic = av_strtok(chr_ptr, \",\", &saveptr))) {\n        if (!strcmp(characteristic, \"public.accessibility.describes-music-and-sound\"))\n            rend->disposition |= AV_DISPOSITION_HEARING_IMPAIRED;\n        else if (!strcmp(characteristic, \"public.accessibility.describes-video\"))\n            rend->disposition |= AV_DISPOSITION_VISUAL_IMPAIRED;\n\n        chr_ptr = NULL;\n    }\n\n    return rend;\n}\n\nstatic void handle_rendition_args(struct rendition_info *info, const char *key,\n                                  int key_len, char **dest, int *dest_len)\n{\n    if (!strncmp(key, \"TYPE=\", key_len)) {\n        *dest     =        info->type;\n        *dest_len = sizeof(info->type);\n    } else if (!strncmp(key, \"URI=\", key_len)) {\n        *dest     =        info->uri;\n        *dest_len = sizeof(info->uri);\n    } else if (!strncmp(key, \"GROUP-ID=\", key_len)) {\n        *dest     =        info->group_id;\n        *dest_len = sizeof(info->group_id);\n    } else if (!strncmp(key, \"LANGUAGE=\", key_len)) {\n        *dest     =        info->language;\n        *dest_len = sizeof(info->language);\n    } else if (!strncmp(key, \"ASSOC-LANGUAGE=\", key_len)) {\n        *dest     =        info->assoc_language;\n        *dest_len = sizeof(info->assoc_language);\n    } else if (!strncmp(key, \"NAME=\", key_len)) {\n        *dest     =        info->name;\n        *dest_len = sizeof(info->name);\n    } else if (!strncmp(key, \"DEFAULT=\", key_len)) {\n        *dest     =        info->defaultr;\n        *dest_len = sizeof(info->defaultr);\n    } else if (!strncmp(key, \"FORCED=\", key_len)) {\n        *dest     =        info->forced;\n        *dest_len = sizeof(info->forced);\n    } else if (!strncmp(key, \"CHARACTERISTICS=\", key_len)) {\n        *dest     =        info->characteristics;\n        *dest_len = sizeof(info->characteristics);\n    }\n    /*\n     * ignored:\n     * - AUTOSELECT: client may autoselect based on e.g. system language\n     * - INSTREAM-ID: EIA-608 closed caption number (\"CC1\"..\"CC4\")\n     */\n}\n\n/* used by parse_playlist to allocate a new variant+playlist when the\n * playlist is detected to be a Media Playlist (not Master Playlist)\n * and we have no parent Master Playlist (parsing of which would have\n * allocated the variant and playlist already)\n * *pls == NULL  => Master Playlist or parentless Media Playlist\n * *pls != NULL => parented Media Playlist, playlist+variant allocated */\nstatic int ensure_playlist(HLSContext *c, struct playlist **pls, const char *url)\n{\n    if (*pls)\n        return 0;\n    if (!new_variant(c, NULL, url, NULL))\n        return AVERROR(ENOMEM);\n    *pls = c->playlists[c->n_playlists - 1];\n    return 0;\n}\n\nstatic void update_options(char **dest, const char *name, void *src)\n{\n    av_freep(dest);\n    av_opt_get(src, name, AV_OPT_SEARCH_CHILDREN, (uint8_t**)dest);\n    if (*dest && !strlen(*dest))\n        av_freep(dest);\n}\n\nstatic int open_url(AVFormatContext *s, AVIOContext **pb, const char *url,\n                    AVDictionary *opts, AVDictionary *opts2, int *is_http)\n{\n    HLSContext *c = s->priv_data;\n    AVDictionary *tmp = NULL;\n    const char *proto_name = NULL;\n    int ret;\n\n    av_dict_copy(&tmp, opts, 0);\n    av_dict_copy(&tmp, opts2, 0);\n\n    if (av_strstart(url, \"crypto\", NULL)) {\n        if (url[6] == '+' || url[6] == ':')\n            proto_name = avio_find_protocol_name(url + 7);\n    }\n\n    if (!proto_name)\n        proto_name = avio_find_protocol_name(url);\n\n    if (!proto_name)\n        return AVERROR_INVALIDDATA;\n\n    // only http(s) & file are allowed\n    if (!av_strstart(proto_name, \"http\", NULL) && !av_strstart(proto_name, \"file\", NULL))\n        return AVERROR_INVALIDDATA;\n    if (!strncmp(proto_name, url, strlen(proto_name)) && url[strlen(proto_name)] == ':')\n        ;\n    else if (av_strstart(url, \"crypto\", NULL) && !strncmp(proto_name, url + 7, strlen(proto_name)) && url[7 + strlen(proto_name)] == ':')\n        ;\n    else if (strcmp(proto_name, \"file\") || !strncmp(url, \"file,\", 5))\n        return AVERROR_INVALIDDATA;\n\n    ret = s->io_open(s, pb, url, AVIO_FLAG_READ, &tmp);\n    if (ret >= 0) {\n        // update cookies on http response with setcookies.\n        char *new_cookies = NULL;\n\n        if (!(s->flags & AVFMT_FLAG_CUSTOM_IO))\n            av_opt_get(*pb, \"cookies\", AV_OPT_SEARCH_CHILDREN, (uint8_t**)&new_cookies);\n\n        if (new_cookies) {\n            av_free(c->cookies);\n            c->cookies = new_cookies;\n        }\n\n        av_dict_set(&opts, \"cookies\", c->cookies, 0);\n    }\n\n    av_dict_free(&tmp);\n\n    if (is_http)\n        *is_http = av_strstart(proto_name, \"http\", NULL);\n\n    return ret;\n}\n\nstatic int parse_playlist(HLSContext *c, const char *url,\n                          struct playlist *pls, AVIOContext *in)\n{\n    int ret = 0, is_segment = 0, is_variant = 0;\n    int64_t duration = 0;\n    enum KeyType key_type = KEY_NONE;\n    uint8_t iv[16] = \"\";\n    int has_iv = 0;\n    char key[MAX_URL_SIZE] = \"\";\n    char line[MAX_URL_SIZE];\n    const char *ptr;\n    int close_in = 0;\n    int64_t seg_offset = 0;\n    int64_t seg_size = -1;\n    uint8_t *new_url = NULL;\n    struct variant_info variant_info;\n    char tmp_str[MAX_URL_SIZE];\n    struct segment *cur_init_section = NULL;\n\n    if (!in) {\n#if 1\n        AVDictionary *opts = NULL;\n        close_in = 1;\n        /* Some HLS servers don't like being sent the range header */\n        av_dict_set(&opts, \"seekable\", \"0\", 0);\n\n        // broker prior HTTP options that should be consistent across requests\n        av_dict_set(&opts, \"user_agent\", c->user_agent, 0);\n        av_dict_set(&opts, \"cookies\", c->cookies, 0);\n        av_dict_set(&opts, \"headers\", c->headers, 0);\n        av_dict_set(&opts, \"http_proxy\", c->http_proxy, 0);\n\n        ret = c->ctx->io_open(c->ctx, &in, url, AVIO_FLAG_READ, &opts);\n        av_dict_free(&opts);\n        if (ret < 0)\n            return ret;\n#else\n        ret = open_in(c, &in, url);\n        if (ret < 0)\n            return ret;\n        close_in = 1;\n#endif\n    }\n\n    if (av_opt_get(in, \"location\", AV_OPT_SEARCH_CHILDREN, &new_url) >= 0)\n        url = new_url;\n\n    read_chomp_line(in, line, sizeof(line));\n    if (strcmp(line, \"#EXTM3U\")) {\n        ret = AVERROR_INVALIDDATA;\n        goto fail;\n    }\n\n    if (pls) {\n        free_segment_list(pls);\n        pls->finished = 0;\n        pls->type = PLS_TYPE_UNSPECIFIED;\n    }\n    while (!avio_feof(in)) {\n        read_chomp_line(in, line, sizeof(line));\n        if (av_strstart(line, \"#EXT-X-STREAM-INF:\", &ptr)) {\n            is_variant = 1;\n            memset(&variant_info, 0, sizeof(variant_info));\n            ff_parse_key_value(ptr, (ff_parse_key_val_cb) handle_variant_args,\n                               &variant_info);\n        } else if (av_strstart(line, \"#EXT-X-KEY:\", &ptr)) {\n            struct key_info info = {{0}};\n            ff_parse_key_value(ptr, (ff_parse_key_val_cb) handle_key_args,\n                               &info);\n            key_type = KEY_NONE;\n            has_iv = 0;\n            if (!strcmp(info.method, \"AES-128\"))\n                key_type = KEY_AES_128;\n            if (!strcmp(info.method, \"SAMPLE-AES\"))\n                key_type = KEY_SAMPLE_AES;\n            if (!strncmp(info.iv, \"0x\", 2) || !strncmp(info.iv, \"0X\", 2)) {\n                ff_hex_to_data(iv, info.iv + 2);\n                has_iv = 1;\n            }\n            av_strlcpy(key, info.uri, sizeof(key));\n        } else if (av_strstart(line, \"#EXT-X-MEDIA:\", &ptr)) {\n            struct rendition_info info = {{0}};\n            ff_parse_key_value(ptr, (ff_parse_key_val_cb) handle_rendition_args,\n                               &info);\n            new_rendition(c, &info, url);\n        } else if (av_strstart(line, \"#EXT-X-TARGETDURATION:\", &ptr)) {\n            ret = ensure_playlist(c, &pls, url);\n            if (ret < 0)\n                goto fail;\n            pls->target_duration = strtoll(ptr, NULL, 10) * AV_TIME_BASE;\n        } else if (av_strstart(line, \"#EXT-X-MEDIA-SEQUENCE:\", &ptr)) {\n            ret = ensure_playlist(c, &pls, url);\n            if (ret < 0)\n                goto fail;\n            pls->start_seq_no = atoi(ptr);\n        } else if (av_strstart(line, \"#EXT-X-PLAYLIST-TYPE:\", &ptr)) {\n            ret = ensure_playlist(c, &pls, url);\n            if (ret < 0)\n                goto fail;\n            if (!strcmp(ptr, \"EVENT\"))\n                pls->type = PLS_TYPE_EVENT;\n            else if (!strcmp(ptr, \"VOD\"))\n                pls->type = PLS_TYPE_VOD;\n        } else if (av_strstart(line, \"#EXT-X-MAP:\", &ptr)) {\n            struct init_section_info info = {{0}};\n            ret = ensure_playlist(c, &pls, url);\n            if (ret < 0)\n                goto fail;\n            ff_parse_key_value(ptr, (ff_parse_key_val_cb) handle_init_section_args,\n                               &info);\n            cur_init_section = new_init_section(pls, &info, url);\n        } else if (av_strstart(line, \"#EXT-X-ENDLIST\", &ptr)) {\n            if (pls)\n                pls->finished = 1;\n        } else if (av_strstart(line, \"#EXTINF:\", &ptr)) {\n            is_segment = 1;\n            duration   = atof(ptr) * AV_TIME_BASE;\n        } else if (av_strstart(line, \"#EXT-X-BYTERANGE:\", &ptr)) {\n            seg_size = strtoll(ptr, NULL, 10);\n            ptr = strchr(ptr, '@');\n            if (ptr)\n                seg_offset = strtoll(ptr+1, NULL, 10);\n        } else if (av_strstart(line, \"#\", NULL)) {\n            continue;\n        } else if (line[0]) {\n            if (is_variant) {\n                if (!new_variant(c, &variant_info, line, url)) {\n                    ret = AVERROR(ENOMEM);\n                    goto fail;\n                }\n                is_variant = 0;\n            }\n            if (is_segment) {\n                struct segment *seg;\n                if (!pls) {\n                    if (!new_variant(c, 0, url, NULL)) {\n                        ret = AVERROR(ENOMEM);\n                        goto fail;\n                    }\n                    pls = c->playlists[c->n_playlists - 1];\n                }\n                seg = av_malloc(sizeof(struct segment));\n                if (!seg) {\n                    ret = AVERROR(ENOMEM);\n                    goto fail;\n                }\n                seg->duration = duration;\n                seg->key_type = key_type;\n                if (has_iv) {\n                    memcpy(seg->iv, iv, sizeof(iv));\n                } else {\n                    int seq = pls->start_seq_no + pls->n_segments;\n                    memset(seg->iv, 0, sizeof(seg->iv));\n                    AV_WB32(seg->iv + 12, seq);\n                }\n\n                if (key_type != KEY_NONE) {\n                    ff_make_absolute_url(tmp_str, sizeof(tmp_str), url, key);\n                    seg->key = av_strdup(tmp_str);\n                    if (!seg->key) {\n                        av_free(seg);\n                        ret = AVERROR(ENOMEM);\n                        goto fail;\n                    }\n                } else {\n                    seg->key = NULL;\n                }\n\n                ff_make_absolute_url(tmp_str, sizeof(tmp_str), url, line);\n                seg->url = av_strdup(tmp_str);\n                if (!seg->url) {\n                    av_free(seg->key);\n                    av_free(seg);\n                    ret = AVERROR(ENOMEM);\n                    goto fail;\n                }\n\n                dynarray_add(&pls->segments, &pls->n_segments, seg);\n                is_segment = 0;\n\n                seg->size = seg_size;\n                if (seg_size >= 0) {\n                    seg->url_offset = seg_offset;\n                    seg_offset += seg_size;\n                    seg_size = -1;\n                } else {\n                    seg->url_offset = 0;\n                    seg_offset = 0;\n                }\n\n                seg->init_section = cur_init_section;\n            }\n        }\n    }\n    if (pls)\n        pls->last_load_time = av_gettime_relative();\n\nfail:\n    av_free(new_url);\n    if (close_in)\n        ff_format_io_close(c->ctx, &in);\n    return ret;\n}\n\nstatic struct segment *current_segment(struct playlist *pls)\n{\n    return pls->segments[pls->cur_seq_no - pls->start_seq_no];\n}\n\nenum ReadFromURLMode {\n    READ_NORMAL,\n    READ_COMPLETE,\n};\n\nstatic int read_from_url(struct playlist *pls, struct segment *seg,\n                         uint8_t *buf, int buf_size,\n                         enum ReadFromURLMode mode)\n{\n    int ret;\n\n     /* limit read if the segment was only a part of a file */\n    if (seg->size >= 0)\n        buf_size = FFMIN(buf_size, seg->size - pls->cur_seg_offset);\n\n    if (mode == READ_COMPLETE) {\n        ret = avio_read(pls->input, buf, buf_size);\n        if (ret != buf_size)\n            av_log(NULL, AV_LOG_ERROR, \"Could not read complete segment.\\n\");\n    } else\n        ret = avio_read(pls->input, buf, buf_size);\n\n    if (ret > 0)\n        pls->cur_seg_offset += ret;\n\n    return ret;\n}\n\n/* Parse the raw ID3 data and pass contents to caller */\nstatic void parse_id3(AVFormatContext *s, AVIOContext *pb,\n                      AVDictionary **metadata, int64_t *dts,\n                      ID3v2ExtraMetaAPIC **apic, ID3v2ExtraMeta **extra_meta)\n{\n    static const char id3_priv_owner_ts[] = \"com.apple.streaming.transportStreamTimestamp\";\n    ID3v2ExtraMeta *meta;\n\n    ff_id3v2_read_dict(pb, metadata, ID3v2_DEFAULT_MAGIC, extra_meta);\n    for (meta = *extra_meta; meta; meta = meta->next) {\n        if (!strcmp(meta->tag, \"PRIV\")) {\n            ID3v2ExtraMetaPRIV *priv = meta->data;\n            if (priv->datasize == 8 && !strcmp(priv->owner, id3_priv_owner_ts)) {\n                /* 33-bit MPEG timestamp */\n                int64_t ts = AV_RB64(priv->data);\n                av_log(s, AV_LOG_DEBUG, \"HLS ID3 audio timestamp %\"PRId64\"\\n\", ts);\n                if ((ts & ~((1ULL << 33) - 1)) == 0)\n                    *dts = ts;\n                else\n                    av_log(s, AV_LOG_ERROR, \"Invalid HLS ID3 audio timestamp %\"PRId64\"\\n\", ts);\n            }\n        } else if (!strcmp(meta->tag, \"APIC\") && apic)\n            *apic = meta->data;\n    }\n}\n\n/* Check if the ID3 metadata contents have changed */\nstatic int id3_has_changed_values(struct playlist *pls, AVDictionary *metadata,\n                                  ID3v2ExtraMetaAPIC *apic)\n{\n    AVDictionaryEntry *entry = NULL;\n    AVDictionaryEntry *oldentry;\n    /* check that no keys have changed values */\n    while ((entry = av_dict_get(metadata, \"\", entry, AV_DICT_IGNORE_SUFFIX))) {\n        oldentry = av_dict_get(pls->id3_initial, entry->key, NULL, AV_DICT_MATCH_CASE);\n        if (!oldentry || strcmp(oldentry->value, entry->value) != 0)\n            return 1;\n    }\n\n    /* check if apic appeared */\n    if (apic && (pls->ctx->nb_streams != 2 || !pls->ctx->streams[1]->attached_pic.data))\n        return 1;\n\n    if (apic) {\n        int size = pls->ctx->streams[1]->attached_pic.size;\n        if (size != apic->buf->size - AV_INPUT_BUFFER_PADDING_SIZE)\n            return 1;\n\n        if (memcmp(apic->buf->data, pls->ctx->streams[1]->attached_pic.data, size) != 0)\n            return 1;\n    }\n\n    return 0;\n}\n\n/* Parse ID3 data and handle the found data */\nstatic void handle_id3(AVIOContext *pb, struct playlist *pls)\n{\n    AVDictionary *metadata = NULL;\n    ID3v2ExtraMetaAPIC *apic = NULL;\n    ID3v2ExtraMeta *extra_meta = NULL;\n    int64_t timestamp = AV_NOPTS_VALUE;\n\n    parse_id3(pls->ctx, pb, &metadata, &timestamp, &apic, &extra_meta);\n\n    if (timestamp != AV_NOPTS_VALUE) {\n        pls->id3_mpegts_timestamp = timestamp;\n        pls->id3_offset = 0;\n    }\n\n    if (!pls->id3_found) {\n        /* initial ID3 tags */\n        av_assert0(!pls->id3_deferred_extra);\n        pls->id3_found = 1;\n\n        /* get picture attachment and set text metadata */\n        if (pls->ctx->nb_streams)\n            ff_id3v2_parse_apic(pls->ctx, &extra_meta);\n        else\n            /* demuxer not yet opened, defer picture attachment */\n            pls->id3_deferred_extra = extra_meta;\n\n        av_dict_copy(&pls->ctx->metadata, metadata, 0);\n        pls->id3_initial = metadata;\n\n    } else {\n        if (!pls->id3_changed && id3_has_changed_values(pls, metadata, apic)) {\n            avpriv_report_missing_feature(pls->ctx, \"Changing ID3 metadata in HLS audio elementary stream\");\n            pls->id3_changed = 1;\n        }\n        av_dict_free(&metadata);\n    }\n\n    if (!pls->id3_deferred_extra)\n        ff_id3v2_free_extra_meta(&extra_meta);\n}\n\nstatic void intercept_id3(struct playlist *pls, uint8_t *buf,\n                         int buf_size, int *len)\n{\n    /* intercept id3 tags, we do not want to pass them to the raw\n     * demuxer on all segment switches */\n    int bytes;\n    int id3_buf_pos = 0;\n    int fill_buf = 0;\n    struct segment *seg = current_segment(pls);\n\n    /* gather all the id3 tags */\n    while (1) {\n        /* see if we can retrieve enough data for ID3 header */\n        if (*len < ID3v2_HEADER_SIZE && buf_size >= ID3v2_HEADER_SIZE) {\n            bytes = read_from_url(pls, seg, buf + *len, ID3v2_HEADER_SIZE - *len, READ_COMPLETE);\n            if (bytes > 0) {\n\n                if (bytes == ID3v2_HEADER_SIZE - *len)\n                    /* no EOF yet, so fill the caller buffer again after\n                     * we have stripped the ID3 tags */\n                    fill_buf = 1;\n\n                *len += bytes;\n\n            } else if (*len <= 0) {\n                /* error/EOF */\n                *len = bytes;\n                fill_buf = 0;\n            }\n        }\n\n        if (*len < ID3v2_HEADER_SIZE)\n            break;\n\n        if (ff_id3v2_match(buf, ID3v2_DEFAULT_MAGIC)) {\n            int64_t maxsize = seg->size >= 0 ? seg->size : 1024*1024;\n            int taglen = ff_id3v2_tag_len(buf);\n            int tag_got_bytes = FFMIN(taglen, *len);\n            int remaining = taglen - tag_got_bytes;\n\n            if (taglen > maxsize) {\n                av_log(pls->ctx, AV_LOG_ERROR, \"Too large HLS ID3 tag (%d > %\"PRId64\" bytes)\\n\",\n                       taglen, maxsize);\n                break;\n            }\n\n            /*\n             * Copy the id3 tag to our temporary id3 buffer.\n             * We could read a small id3 tag directly without memcpy, but\n             * we would still need to copy the large tags, and handling\n             * both of those cases together with the possibility for multiple\n             * tags would make the handling a bit complex.\n             */\n            pls->id3_buf = av_fast_realloc(pls->id3_buf, &pls->id3_buf_size, id3_buf_pos + taglen);\n            if (!pls->id3_buf)\n                break;\n            memcpy(pls->id3_buf + id3_buf_pos, buf, tag_got_bytes);\n            id3_buf_pos += tag_got_bytes;\n\n            /* strip the intercepted bytes */\n            *len -= tag_got_bytes;\n            memmove(buf, buf + tag_got_bytes, *len);\n            av_log(pls->ctx, AV_LOG_DEBUG, \"Stripped %d HLS ID3 bytes\\n\", tag_got_bytes);\n\n            if (remaining > 0) {\n                /* read the rest of the tag in */\n                if (read_from_url(pls, seg, pls->id3_buf + id3_buf_pos, remaining, READ_COMPLETE) != remaining)\n                    break;\n                id3_buf_pos += remaining;\n                av_log(pls->ctx, AV_LOG_DEBUG, \"Stripped additional %d HLS ID3 bytes\\n\", remaining);\n            }\n\n        } else {\n            /* no more ID3 tags */\n            break;\n        }\n    }\n\n    /* re-fill buffer for the caller unless EOF */\n    if (*len >= 0 && (fill_buf || *len == 0)) {\n        bytes = read_from_url(pls, seg, buf + *len, buf_size - *len, READ_NORMAL);\n\n        /* ignore error if we already had some data */\n        if (bytes >= 0)\n            *len += bytes;\n        else if (*len == 0)\n            *len = bytes;\n    }\n\n    if (pls->id3_buf) {\n        /* Now parse all the ID3 tags */\n        AVIOContext id3ioctx;\n        ffio_init_context(&id3ioctx, pls->id3_buf, id3_buf_pos, 0, NULL, NULL, NULL, NULL);\n        handle_id3(&id3ioctx, pls);\n    }\n\n    if (pls->is_id3_timestamped == -1)\n        pls->is_id3_timestamped = (pls->id3_mpegts_timestamp != AV_NOPTS_VALUE);\n}\n\nstatic int open_input(HLSContext *c, struct playlist *pls, struct segment *seg)\n{\n    AVDictionary *opts = NULL;\n    int ret;\n    int is_http = 0;\n\n    // broker prior HTTP options that should be consistent across requests\n    av_dict_set(&opts, \"user_agent\", c->user_agent, 0);\n    av_dict_set(&opts, \"cookies\", c->cookies, 0);\n    av_dict_set(&opts, \"headers\", c->headers, 0);\n    av_dict_set(&opts, \"http_proxy\", c->http_proxy, 0);\n    av_dict_set(&opts, \"seekable\", \"0\", 0);\n\n    if (seg->size >= 0) {\n        /* try to restrict the HTTP request to the part we want\n         * (if this is in fact a HTTP request) */\n        av_dict_set_int(&opts, \"offset\", seg->url_offset, 0);\n        av_dict_set_int(&opts, \"end_offset\", seg->url_offset + seg->size, 0);\n    }\n\n    av_log(pls->parent, AV_LOG_VERBOSE, \"HLS request for url '%s', offset %\"PRId64\", playlist %d\\n\",\n           seg->url, seg->url_offset, pls->index);\n\n    if (seg->key_type == KEY_NONE) {\n        ret = open_url(pls->parent, &pls->input, seg->url, c->avio_opts, opts, &is_http);\n    } else if (seg->key_type == KEY_AES_128) {\n        AVDictionary *opts2 = NULL;\n        char iv[33], key[33], url[MAX_URL_SIZE];\n        if (strcmp(seg->key, pls->key_url)) {\n            AVIOContext *pb;\n            if (open_url(pls->parent, &pb, seg->key, c->avio_opts, opts, NULL) == 0) {\n                ret = avio_read(pb, pls->key, sizeof(pls->key));\n                if (ret != sizeof(pls->key)) {\n                    av_log(NULL, AV_LOG_ERROR, \"Unable to read key file %s\\n\",\n                           seg->key);\n                }\n                ff_format_io_close(pls->parent, &pb);\n            } else {\n                av_log(NULL, AV_LOG_ERROR, \"Unable to open key file %s\\n\",\n                       seg->key);\n            }\n            av_strlcpy(pls->key_url, seg->key, sizeof(pls->key_url));\n        }\n        ff_data_to_hex(iv, seg->iv, sizeof(seg->iv), 0);\n        ff_data_to_hex(key, pls->key, sizeof(pls->key), 0);\n        iv[32] = key[32] = '\\0';\n        if (strstr(seg->url, \"://\"))\n            snprintf(url, sizeof(url), \"crypto+%s\", seg->url);\n        else\n            snprintf(url, sizeof(url), \"crypto:%s\", seg->url);\n\n        av_dict_copy(&opts2, c->avio_opts, 0);\n        av_dict_set(&opts2, \"key\", key, 0);\n        av_dict_set(&opts2, \"iv\", iv, 0);\n\n        ret = open_url(pls->parent, &pls->input, url, opts2, opts, &is_http);\n\n        av_dict_free(&opts2);\n\n        if (ret < 0) {\n            goto cleanup;\n        }\n        ret = 0;\n    } else if (seg->key_type == KEY_SAMPLE_AES) {\n        av_log(pls->parent, AV_LOG_ERROR,\n               \"SAMPLE-AES encryption is not supported yet\\n\");\n        ret = AVERROR_PATCHWELCOME;\n    }\n    else\n      ret = AVERROR(ENOSYS);\n\n    /* Seek to the requested position. If this was a HTTP request, the offset\n     * should already be where want it to, but this allows e.g. local testing\n     * without a HTTP server.\n     *\n     * This is not done for HTTP at all as avio_seek() does internal bookkeeping\n     * of file offset which is out-of-sync with the actual offset when \"offset\"\n     * AVOption is used with http protocol, causing the seek to not be a no-op\n     * as would be expected. Wrong offset received from the server will not be\n     * noticed without the call, though.\n     */\n    if (ret == 0 && !is_http && seg->key_type == KEY_NONE && seg->url_offset) {\n        int64_t seekret = avio_seek(pls->input, seg->url_offset, SEEK_SET);\n        if (seekret < 0) {\n            av_log(pls->parent, AV_LOG_ERROR, \"Unable to seek to offset %\"PRId64\" of HLS segment '%s'\\n\", seg->url_offset, seg->url);\n            ret = seekret;\n            ff_format_io_close(pls->parent, &pls->input);\n        }\n    }\n\ncleanup:\n    av_dict_free(&opts);\n    pls->cur_seg_offset = 0;\n    return ret;\n}\n\nstatic int update_init_section(struct playlist *pls, struct segment *seg)\n{\n    static const int max_init_section_size = 1024*1024;\n    HLSContext *c = pls->parent->priv_data;\n    int64_t sec_size;\n    int64_t urlsize;\n    int ret;\n\n    if (seg->init_section == pls->cur_init_section)\n        return 0;\n\n    pls->cur_init_section = NULL;\n\n    if (!seg->init_section)\n        return 0;\n\n    ret = open_input(c, pls, seg->init_section);\n    if (ret < 0) {\n        av_log(pls->parent, AV_LOG_WARNING,\n               \"Failed to open an initialization section in playlist %d\\n\",\n               pls->index);\n        return ret;\n    }\n\n    if (seg->init_section->size >= 0)\n        sec_size = seg->init_section->size;\n    else if ((urlsize = avio_size(pls->input)) >= 0)\n        sec_size = urlsize;\n    else\n        sec_size = max_init_section_size;\n\n    av_log(pls->parent, AV_LOG_DEBUG,\n           \"Downloading an initialization section of size %\"PRId64\"\\n\",\n           sec_size);\n\n    sec_size = FFMIN(sec_size, max_init_section_size);\n\n    av_fast_malloc(&pls->init_sec_buf, &pls->init_sec_buf_size, sec_size);\n\n    ret = read_from_url(pls, seg->init_section, pls->init_sec_buf,\n                        pls->init_sec_buf_size, READ_COMPLETE);\n    ff_format_io_close(pls->parent, &pls->input);\n\n    if (ret < 0)\n        return ret;\n\n    pls->cur_init_section = seg->init_section;\n    pls->init_sec_data_len = ret;\n    pls->init_sec_buf_read_offset = 0;\n\n    /* spec says audio elementary streams do not have media initialization\n     * sections, so there should be no ID3 timestamps */\n    pls->is_id3_timestamped = 0;\n\n    return 0;\n}\n\nstatic int64_t default_reload_interval(struct playlist *pls)\n{\n    return pls->n_segments > 0 ?\n                          pls->segments[pls->n_segments - 1]->duration :\n                          pls->target_duration;\n}\n\nstatic int read_data(void *opaque, uint8_t *buf, int buf_size)\n{\n    struct playlist *v = opaque;\n    HLSContext *c = v->parent->priv_data;\n    int ret, i;\n    int just_opened = 0;\n\nrestart:\n    if (!v->needed)\n        return AVERROR_EOF;\n\n    if (!v->input) {\n        int64_t reload_interval;\n        struct segment *seg;\n\n        /* Check that the playlist is still needed before opening a new\n         * segment. */\n        if (v->ctx && v->ctx->nb_streams) {\n            v->needed = 0;\n            for (i = 0; i < v->n_main_streams; i++) {\n                if (v->main_streams[i]->discard < AVDISCARD_ALL) {\n                    v->needed = 1;\n                    break;\n                }\n            }\n        }\n        if (!v->needed) {\n            av_log(v->parent, AV_LOG_INFO, \"No longer receiving playlist %d\\n\",\n                v->index);\n            return AVERROR_EOF;\n        }\n\n        /* If this is a live stream and the reload interval has elapsed since\n         * the last playlist reload, reload the playlists now. */\n        reload_interval = default_reload_interval(v);\n\nreload:\n        if (!v->finished &&\n            av_gettime_relative() - v->last_load_time >= reload_interval) {\n            if ((ret = parse_playlist(c, v->url, v, NULL)) < 0) {\n                av_log(v->parent, AV_LOG_WARNING, \"Failed to reload playlist %d\\n\",\n                       v->index);\n                return ret;\n            }\n            /* If we need to reload the playlist again below (if\n             * there's still no more segments), switch to a reload\n             * interval of half the target duration. */\n            reload_interval = v->target_duration / 2;\n        }\n        if (v->cur_seq_no < v->start_seq_no) {\n            av_log(NULL, AV_LOG_WARNING,\n                   \"skipping %d segments ahead, expired from playlists\\n\",\n                   v->start_seq_no - v->cur_seq_no);\n            v->cur_seq_no = v->start_seq_no;\n        }\n        if (v->cur_seq_no >= v->start_seq_no + v->n_segments) {\n            if (v->finished)\n                return AVERROR_EOF;\n            while (av_gettime_relative() - v->last_load_time < reload_interval) {\n                if (ff_check_interrupt(c->interrupt_callback))\n                    return AVERROR_EXIT;\n                av_usleep(100*1000);\n            }\n            /* Enough time has elapsed since the last reload */\n            goto reload;\n        }\n\n        seg = current_segment(v);\n\n        /* load/update Media Initialization Section, if any */\n        ret = update_init_section(v, seg);\n        if (ret)\n            return ret;\n\n        ret = open_input(c, v, seg);\n        if (ret < 0) {\n            if (ff_check_interrupt(c->interrupt_callback))\n                return AVERROR_EXIT;\n            av_log(v->parent, AV_LOG_WARNING, \"Failed to open segment of playlist %d\\n\",\n                   v->index);\n            v->cur_seq_no += 1;\n            goto reload;\n        }\n        just_opened = 1;\n    }\n\n    if (v->init_sec_buf_read_offset < v->init_sec_data_len) {\n        /* Push init section out first before first actual segment */\n        int copy_size = FFMIN(v->init_sec_data_len - v->init_sec_buf_read_offset, buf_size);\n        memcpy(buf, v->init_sec_buf, copy_size);\n        v->init_sec_buf_read_offset += copy_size;\n        return copy_size;\n    }\n\n    ret = read_from_url(v, current_segment(v), buf, buf_size, READ_NORMAL);\n    if (ret > 0) {\n        if (just_opened && v->is_id3_timestamped != 0) {\n            /* Intercept ID3 tags here, elementary audio streams are required\n             * to convey timestamps using them in the beginning of each segment. */\n            intercept_id3(v, buf, buf_size, &ret);\n        }\n\n        return ret;\n    }\n    ff_format_io_close(v->parent, &v->input);\n    v->cur_seq_no++;\n\n    c->cur_seq_no = v->cur_seq_no;\n\n    goto restart;\n}\n\nstatic void add_renditions_to_variant(HLSContext *c, struct variant *var,\n                                      enum AVMediaType type, const char *group_id)\n{\n    int i;\n\n    for (i = 0; i < c->n_renditions; i++) {\n        struct rendition *rend = c->renditions[i];\n\n        if (rend->type == type && !strcmp(rend->group_id, group_id)) {\n\n            if (rend->playlist)\n                /* rendition is an external playlist\n                 * => add the playlist to the variant */\n                dynarray_add(&var->playlists, &var->n_playlists, rend->playlist);\n            else\n                /* rendition is part of the variant main Media Playlist\n                 * => add the rendition to the main Media Playlist */\n                dynarray_add(&var->playlists[0]->renditions,\n                             &var->playlists[0]->n_renditions,\n                             rend);\n        }\n    }\n}\n\nstatic void add_metadata_from_renditions(AVFormatContext *s, struct playlist *pls,\n                                         enum AVMediaType type)\n{\n    int rend_idx = 0;\n    int i;\n\n    for (i = 0; i < pls->n_main_streams; i++) {\n        AVStream *st = pls->main_streams[i];\n\n        if (st->codecpar->codec_type != type)\n            continue;\n\n        for (; rend_idx < pls->n_renditions; rend_idx++) {\n            struct rendition *rend = pls->renditions[rend_idx];\n\n            if (rend->type != type)\n                continue;\n\n            if (rend->language[0])\n                av_dict_set(&st->metadata, \"language\", rend->language, 0);\n            if (rend->name[0])\n                av_dict_set(&st->metadata, \"comment\", rend->name, 0);\n\n            st->disposition |= rend->disposition;\n        }\n        if (rend_idx >=pls->n_renditions)\n            break;\n    }\n}\n\n/* if timestamp was in valid range: returns 1 and sets seq_no\n * if not: returns 0 and sets seq_no to closest segment */\nstatic int find_timestamp_in_playlist(HLSContext *c, struct playlist *pls,\n                                      int64_t timestamp, int *seq_no)\n{\n    int i;\n    int64_t pos = c->first_timestamp == AV_NOPTS_VALUE ?\n                  0 : c->first_timestamp;\n\n    if (timestamp < pos) {\n        *seq_no = pls->start_seq_no;\n        return 0;\n    }\n\n    for (i = 0; i < pls->n_segments; i++) {\n        int64_t diff = pos + pls->segments[i]->duration - timestamp;\n        if (diff > 0) {\n            *seq_no = pls->start_seq_no + i;\n            return 1;\n        }\n        pos += pls->segments[i]->duration;\n    }\n\n    *seq_no = pls->start_seq_no + pls->n_segments - 1;\n\n    return 0;\n}\n\nstatic int select_cur_seq_no(HLSContext *c, struct playlist *pls)\n{\n    int seq_no;\n\n    if (!pls->finished && !c->first_packet &&\n        av_gettime_relative() - pls->last_load_time >= default_reload_interval(pls))\n        /* reload the playlist since it was suspended */\n        parse_playlist(c, pls->url, pls, NULL);\n\n    /* If playback is already in progress (we are just selecting a new\n     * playlist) and this is a complete file, find the matching segment\n     * by counting durations. */\n    if (pls->finished && c->cur_timestamp != AV_NOPTS_VALUE) {\n        find_timestamp_in_playlist(c, pls, c->cur_timestamp, &seq_no);\n        return seq_no;\n    }\n\n    if (!pls->finished) {\n        if (!c->first_packet && /* we are doing a segment selection during playback */\n            c->cur_seq_no >= pls->start_seq_no &&\n            c->cur_seq_no < pls->start_seq_no + pls->n_segments)\n            /* While spec 3.4.3 says that we cannot assume anything about the\n             * content at the same sequence number on different playlists,\n             * in practice this seems to work and doing it otherwise would\n             * require us to download a segment to inspect its timestamps. */\n            return c->cur_seq_no;\n\n        /* If this is a live stream, start live_start_index segments from the\n         * start or end */\n        if (c->live_start_index < 0)\n            return pls->start_seq_no + FFMAX(pls->n_segments + c->live_start_index, 0);\n        else\n            return pls->start_seq_no + FFMIN(c->live_start_index, pls->n_segments - 1);\n    }\n\n    /* Otherwise just start on the first segment. */\n    return pls->start_seq_no;\n}\n\nstatic int save_avio_options(AVFormatContext *s)\n{\n    HLSContext *c = s->priv_data;\n    static const char *opts[] = {\n        \"headers\", \"http_proxy\", \"user_agent\", \"user-agent\", \"cookies\", NULL };\n    const char **opt = opts;\n    uint8_t *buf;\n    int ret = 0;\n\n    while (*opt) {\n        if (av_opt_get(s->pb, *opt, AV_OPT_SEARCH_CHILDREN | AV_OPT_ALLOW_NULL, &buf) >= 0) {\n            ret = av_dict_set(&c->avio_opts, *opt, buf,\n                              AV_DICT_DONT_STRDUP_VAL);\n            if (ret < 0)\n                return ret;\n        }\n        opt++;\n    }\n\n    return ret;\n}\n\nstatic int nested_io_open(AVFormatContext *s, AVIOContext **pb, const char *url,\n                          int flags, AVDictionary **opts)\n{\n    av_log(s, AV_LOG_ERROR,\n           \"A HLS playlist item '%s' referred to an external file '%s'. \"\n           \"Opening this file was forbidden for security reasons\\n\",\n           s->filename, url);\n    return AVERROR(EPERM);\n}\n\nstatic void add_stream_to_programs(AVFormatContext *s, struct playlist *pls, AVStream *stream)\n{\n    HLSContext *c = s->priv_data;\n    int i, j;\n    int bandwidth = -1;\n\n    for (i = 0; i < c->n_variants; i++) {\n        struct variant *v = c->variants[i];\n\n        for (j = 0; j < v->n_playlists; j++) {\n            if (v->playlists[j] != pls)\n                continue;\n\n            av_program_add_stream_index(s, i, stream->index);\n\n            if (bandwidth < 0)\n                bandwidth = v->bandwidth;\n            else if (bandwidth != v->bandwidth)\n                bandwidth = -1; /* stream in multiple variants with different bandwidths */\n        }\n    }\n\n    if (bandwidth >= 0)\n        av_dict_set_int(&stream->metadata, \"variant_bitrate\", bandwidth, 0);\n}\n\nstatic int set_stream_info_from_input_stream(AVStream *st, struct playlist *pls, AVStream *ist)\n{\n    int err;\n\n    err = avcodec_parameters_copy(st->codecpar, ist->codecpar);\n    if (err < 0)\n        return err;\n\n    if (pls->is_id3_timestamped) /* custom timestamps via id3 */\n        avpriv_set_pts_info(st, 33, 1, MPEG_TIME_BASE);\n    else\n        avpriv_set_pts_info(st, ist->pts_wrap_bits, ist->time_base.num, ist->time_base.den);\n\n    st->internal->need_context_update = 1;\n\n    return 0;\n}\n\n/* add new subdemuxer streams to our context, if any */\nstatic int update_streams_from_subdemuxer(AVFormatContext *s, struct playlist *pls)\n{\n    int err;\n\n    while (pls->n_main_streams < pls->ctx->nb_streams) {\n        int ist_idx = pls->n_main_streams;\n        AVStream *st = avformat_new_stream(s, NULL);\n        AVStream *ist = pls->ctx->streams[ist_idx];\n\n        if (!st)\n            return AVERROR(ENOMEM);\n\n        st->id = pls->index;\n        dynarray_add(&pls->main_streams, &pls->n_main_streams, st);\n\n        add_stream_to_programs(s, pls, st);\n\n        err = set_stream_info_from_input_stream(st, pls, ist);\n        if (err < 0)\n            return err;\n    }\n\n    return 0;\n}\n\nstatic void update_noheader_flag(AVFormatContext *s)\n{\n    HLSContext *c = s->priv_data;\n    int flag_needed = 0;\n    int i;\n\n    for (i = 0; i < c->n_playlists; i++) {\n        struct playlist *pls = c->playlists[i];\n\n        if (pls->has_noheader_flag) {\n            flag_needed = 1;\n            break;\n        }\n    }\n\n    if (flag_needed)\n        s->ctx_flags |= AVFMTCTX_NOHEADER;\n    else\n        s->ctx_flags &= ~AVFMTCTX_NOHEADER;\n}\n\nstatic int hls_close(AVFormatContext *s)\n{\n    HLSContext *c = s->priv_data;\n\n    free_playlist_list(c);\n    free_variant_list(c);\n    free_rendition_list(c);\n\n    av_dict_free(&c->avio_opts);\n\n    return 0;\n}\n\nstatic int hls_read_header(AVFormatContext *s)\n{\n    void *u = (s->flags & AVFMT_FLAG_CUSTOM_IO) ? NULL : s->pb;\n    HLSContext *c = s->priv_data;\n    int ret = 0, i;\n    int highest_cur_seq_no = 0;\n\n    c->ctx                = s;\n    c->interrupt_callback = &s->interrupt_callback;\n    c->strict_std_compliance = s->strict_std_compliance;\n\n    c->first_packet = 1;\n    c->first_timestamp = AV_NOPTS_VALUE;\n    c->cur_timestamp = AV_NOPTS_VALUE;\n\n    if (u) {\n        // get the previous user agent & set back to null if string size is zero\n        update_options(&c->user_agent, \"user_agent\", u);\n\n        // get the previous cookies & set back to null if string size is zero\n        update_options(&c->cookies, \"cookies\", u);\n\n        // get the previous headers & set back to null if string size is zero\n        update_options(&c->headers, \"headers\", u);\n\n        // get the previous http proxt & set back to null if string size is zero\n        update_options(&c->http_proxy, \"http_proxy\", u);\n    }\n\n    if ((ret = parse_playlist(c, s->filename, NULL, s->pb)) < 0)\n        goto fail;\n\n    if ((ret = save_avio_options(s)) < 0)\n        goto fail;\n\n    /* Some HLS servers don't like being sent the range header */\n    av_dict_set(&c->avio_opts, \"seekable\", \"0\", 0);\n\n    if (c->n_variants == 0) {\n        av_log(NULL, AV_LOG_WARNING, \"Empty playlist\\n\");\n        ret = AVERROR_EOF;\n        goto fail;\n    }\n    /* If the playlist only contained playlists (Master Playlist),\n     * parse each individual playlist. */\n    if (c->n_playlists > 1 || c->playlists[0]->n_segments == 0) {\n        for (i = 0; i < c->n_playlists; i++) {\n            struct playlist *pls = c->playlists[i];\n            if ((ret = parse_playlist(c, pls->url, pls, NULL)) < 0)\n                goto fail;\n        }\n    }\n\n    if (c->variants[0]->playlists[0]->n_segments == 0) {\n        av_log(NULL, AV_LOG_WARNING, \"Empty playlist\\n\");\n        ret = AVERROR_EOF;\n        goto fail;\n    }\n\n    /* If this isn't a live stream, calculate the total duration of the\n     * stream. */\n    if (c->variants[0]->playlists[0]->finished) {\n        int64_t duration = 0;\n        for (i = 0; i < c->variants[0]->playlists[0]->n_segments; i++)\n            duration += c->variants[0]->playlists[0]->segments[i]->duration;\n        s->duration = duration;\n    }\n\n    /* Associate renditions with variants */\n    for (i = 0; i < c->n_variants; i++) {\n        struct variant *var = c->variants[i];\n\n        if (var->audio_group[0])\n            add_renditions_to_variant(c, var, AVMEDIA_TYPE_AUDIO, var->audio_group);\n        if (var->video_group[0])\n            add_renditions_to_variant(c, var, AVMEDIA_TYPE_VIDEO, var->video_group);\n        if (var->subtitles_group[0])\n            add_renditions_to_variant(c, var, AVMEDIA_TYPE_SUBTITLE, var->subtitles_group);\n    }\n\n    /* Create a program for each variant */\n    for (i = 0; i < c->n_variants; i++) {\n        struct variant *v = c->variants[i];\n        AVProgram *program;\n\n        program = av_new_program(s, i);\n        if (!program)\n            goto fail;\n        av_dict_set_int(&program->metadata, \"variant_bitrate\", v->bandwidth, 0);\n    }\n\n    /* Select the starting segments */\n    for (i = 0; i < c->n_playlists; i++) {\n        struct playlist *pls = c->playlists[i];\n\n        if (pls->n_segments == 0)\n            continue;\n\n        pls->cur_seq_no = select_cur_seq_no(c, pls);\n        highest_cur_seq_no = FFMAX(highest_cur_seq_no, pls->cur_seq_no);\n    }\n\n    /* Open the demuxer for each playlist */\n    for (i = 0; i < c->n_playlists; i++) {\n        struct playlist *pls = c->playlists[i];\n        AVInputFormat *in_fmt = NULL;\n\n        if (!(pls->ctx = avformat_alloc_context())) {\n            ret = AVERROR(ENOMEM);\n            goto fail;\n        }\n\n        if (pls->n_segments == 0)\n            continue;\n\n        pls->index  = i;\n        pls->needed = 1;\n        pls->parent = s;\n\n        /*\n         * If this is a live stream and this playlist looks like it is one segment\n         * behind, try to sync it up so that every substream starts at the same\n         * time position (so e.g. avformat_find_stream_info() will see packets from\n         * all active streams within the first few seconds). This is not very generic,\n         * though, as the sequence numbers are technically independent.\n         */\n        if (!pls->finished && pls->cur_seq_no == highest_cur_seq_no - 1 &&\n            highest_cur_seq_no < pls->start_seq_no + pls->n_segments) {\n            pls->cur_seq_no = highest_cur_seq_no;\n        }\n\n        pls->read_buffer = av_malloc(INITIAL_BUFFER_SIZE);\n        if (!pls->read_buffer){\n            ret = AVERROR(ENOMEM);\n            avformat_free_context(pls->ctx);\n            pls->ctx = NULL;\n            goto fail;\n        }\n        ffio_init_context(&pls->pb, pls->read_buffer, INITIAL_BUFFER_SIZE, 0, pls,\n                          read_data, NULL, NULL);\n        pls->pb.seekable = 0;\n        ret = av_probe_input_buffer(&pls->pb, &in_fmt, pls->segments[0]->url,\n                                    NULL, 0, 0);\n        if (ret < 0) {\n            /* Free the ctx - it isn't initialized properly at this point,\n             * so avformat_close_input shouldn't be called. If\n             * avformat_open_input fails below, it frees and zeros the\n             * context, so it doesn't need any special treatment like this. */\n            av_log(s, AV_LOG_ERROR, \"Error when loading first segment '%s'\\n\", pls->segments[0]->url);\n            avformat_free_context(pls->ctx);\n            pls->ctx = NULL;\n            goto fail;\n        }\n        pls->ctx->pb       = &pls->pb;\n        pls->ctx->io_open  = nested_io_open;\n        pls->ctx->flags   |= s->flags & ~AVFMT_FLAG_CUSTOM_IO;\n\n        if ((ret = ff_copy_whiteblacklists(pls->ctx, s)) < 0)\n            goto fail;\n\n        ret = avformat_open_input(&pls->ctx, pls->segments[0]->url, in_fmt, NULL);\n        if (ret < 0)\n            goto fail;\n\n        if (pls->id3_deferred_extra && pls->ctx->nb_streams == 1) {\n            ff_id3v2_parse_apic(pls->ctx, &pls->id3_deferred_extra);\n            avformat_queue_attached_pictures(pls->ctx);\n            ff_id3v2_free_extra_meta(&pls->id3_deferred_extra);\n            pls->id3_deferred_extra = NULL;\n        }\n\n        if (pls->is_id3_timestamped == -1)\n            av_log(s, AV_LOG_WARNING, \"No expected HTTP requests have been made\\n\");\n\n        /*\n         * For ID3 timestamped raw audio streams we need to detect the packet\n         * durations to calculate timestamps in fill_timing_for_id3_timestamped_stream(),\n         * but for other streams we can rely on our user calling avformat_find_stream_info()\n         * on us if they want to.\n         */\n        if (pls->is_id3_timestamped) {\n            ret = avformat_find_stream_info(pls->ctx, NULL);\n            if (ret < 0)\n                goto fail;\n        }\n\n        pls->has_noheader_flag = !!(pls->ctx->ctx_flags & AVFMTCTX_NOHEADER);\n\n        /* Create new AVStreams for each stream in this playlist */\n        ret = update_streams_from_subdemuxer(s, pls);\n        if (ret < 0)\n            goto fail;\n\n        add_metadata_from_renditions(s, pls, AVMEDIA_TYPE_AUDIO);\n        add_metadata_from_renditions(s, pls, AVMEDIA_TYPE_VIDEO);\n        add_metadata_from_renditions(s, pls, AVMEDIA_TYPE_SUBTITLE);\n    }\n\n    update_noheader_flag(s);\n\n    return 0;\nfail:\n    hls_close(s);\n    return ret;\n}\n\nstatic int recheck_discard_flags(AVFormatContext *s, int first)\n{\n    HLSContext *c = s->priv_data;\n    int i, changed = 0;\n\n    /* Check if any new streams are needed */\n    for (i = 0; i < c->n_playlists; i++)\n        c->playlists[i]->cur_needed = 0;\n\n    for (i = 0; i < s->nb_streams; i++) {\n        AVStream *st = s->streams[i];\n        struct playlist *pls = c->playlists[s->streams[i]->id];\n        if (st->discard < AVDISCARD_ALL)\n            pls->cur_needed = 1;\n    }\n    for (i = 0; i < c->n_playlists; i++) {\n        struct playlist *pls = c->playlists[i];\n        if (pls->cur_needed && !pls->needed) {\n            pls->needed = 1;\n            changed = 1;\n            pls->cur_seq_no = select_cur_seq_no(c, pls);\n            pls->pb.eof_reached = 0;\n            if (c->cur_timestamp != AV_NOPTS_VALUE) {\n                /* catch up */\n                pls->seek_timestamp = c->cur_timestamp;\n                pls->seek_flags = AVSEEK_FLAG_ANY;\n                pls->seek_stream_index = -1;\n            }\n            av_log(s, AV_LOG_INFO, \"Now receiving playlist %d, segment %d\\n\", i, pls->cur_seq_no);\n        } else if (first && !pls->cur_needed && pls->needed) {\n            if (pls->input)\n                ff_format_io_close(pls->parent, &pls->input);\n            pls->needed = 0;\n            changed = 1;\n            av_log(s, AV_LOG_INFO, \"No longer receiving playlist %d\\n\", i);\n        }\n    }\n    return changed;\n}\n\nstatic void fill_timing_for_id3_timestamped_stream(struct playlist *pls)\n{\n    if (pls->id3_offset >= 0) {\n        pls->pkt.dts = pls->id3_mpegts_timestamp +\n                                 av_rescale_q(pls->id3_offset,\n                                              pls->ctx->streams[pls->pkt.stream_index]->time_base,\n                                              MPEG_TIME_BASE_Q);\n        if (pls->pkt.duration)\n            pls->id3_offset += pls->pkt.duration;\n        else\n            pls->id3_offset = -1;\n    } else {\n        /* there have been packets with unknown duration\n         * since the last id3 tag, should not normally happen */\n        pls->pkt.dts = AV_NOPTS_VALUE;\n    }\n\n    if (pls->pkt.duration)\n        pls->pkt.duration = av_rescale_q(pls->pkt.duration,\n                                         pls->ctx->streams[pls->pkt.stream_index]->time_base,\n                                         MPEG_TIME_BASE_Q);\n\n    pls->pkt.pts = AV_NOPTS_VALUE;\n}\n\nstatic AVRational get_timebase(struct playlist *pls)\n{\n    if (pls->is_id3_timestamped)\n        return MPEG_TIME_BASE_Q;\n\n    return pls->ctx->streams[pls->pkt.stream_index]->time_base;\n}\n\nstatic int compare_ts_with_wrapdetect(int64_t ts_a, struct playlist *pls_a,\n                                      int64_t ts_b, struct playlist *pls_b)\n{\n    int64_t scaled_ts_a = av_rescale_q(ts_a, get_timebase(pls_a), MPEG_TIME_BASE_Q);\n    int64_t scaled_ts_b = av_rescale_q(ts_b, get_timebase(pls_b), MPEG_TIME_BASE_Q);\n\n    return av_compare_mod(scaled_ts_a, scaled_ts_b, 1LL << 33);\n}\n\nstatic int hls_read_packet(AVFormatContext *s, AVPacket *pkt)\n{\n    HLSContext *c = s->priv_data;\n    int ret, i, minplaylist = -1;\n\n    recheck_discard_flags(s, c->first_packet);\n    c->first_packet = 0;\n\n    for (i = 0; i < c->n_playlists; i++) {\n        struct playlist *pls = c->playlists[i];\n        /* Make sure we've got one buffered packet from each open playlist\n         * stream */\n        if (pls->needed && !pls->pkt.data) {\n            while (1) {\n                int64_t ts_diff;\n                AVRational tb;\n                ret = av_read_frame(pls->ctx, &pls->pkt);\n                if (ret < 0) {\n                    if (!avio_feof(&pls->pb) && ret != AVERROR_EOF)\n                        return ret;\n                    reset_packet(&pls->pkt);\n                    break;\n                } else {\n                    /* stream_index check prevents matching picture attachments etc. */\n                    if (pls->is_id3_timestamped && pls->pkt.stream_index == 0) {\n                        /* audio elementary streams are id3 timestamped */\n                        fill_timing_for_id3_timestamped_stream(pls);\n                    }\n\n                    if (c->first_timestamp == AV_NOPTS_VALUE &&\n                        pls->pkt.dts       != AV_NOPTS_VALUE)\n                        c->first_timestamp = av_rescale_q(pls->pkt.dts,\n                            get_timebase(pls), AV_TIME_BASE_Q);\n                }\n\n                if (pls->seek_timestamp == AV_NOPTS_VALUE)\n                    break;\n\n                if (pls->seek_stream_index < 0 ||\n                    pls->seek_stream_index == pls->pkt.stream_index) {\n\n                    if (pls->pkt.dts == AV_NOPTS_VALUE) {\n                        pls->seek_timestamp = AV_NOPTS_VALUE;\n                        break;\n                    }\n\n                    tb = get_timebase(pls);\n                    ts_diff = av_rescale_rnd(pls->pkt.dts, AV_TIME_BASE,\n                                            tb.den, AV_ROUND_DOWN) -\n                            pls->seek_timestamp;\n                    if (ts_diff >= 0 && (pls->seek_flags  & AVSEEK_FLAG_ANY ||\n                                        pls->pkt.flags & AV_PKT_FLAG_KEY)) {\n                        pls->seek_timestamp = AV_NOPTS_VALUE;\n                        break;\n                    }\n                }\n                av_packet_unref(&pls->pkt);\n                reset_packet(&pls->pkt);\n            }\n        }\n        /* Check if this stream has the packet with the lowest dts */\n        if (pls->pkt.data) {\n            struct playlist *minpls = minplaylist < 0 ?\n                                     NULL : c->playlists[minplaylist];\n            if (minplaylist < 0) {\n                minplaylist = i;\n            } else {\n                int64_t dts     =    pls->pkt.dts;\n                int64_t mindts  = minpls->pkt.dts;\n\n                if (dts == AV_NOPTS_VALUE ||\n                    (mindts != AV_NOPTS_VALUE && compare_ts_with_wrapdetect(dts, pls, mindts, minpls) < 0))\n                    minplaylist = i;\n            }\n        }\n    }\n\n    /* If we got a packet, return it */\n    if (minplaylist >= 0) {\n        struct playlist *pls = c->playlists[minplaylist];\n        AVStream *ist;\n        AVStream *st;\n\n        ret = update_streams_from_subdemuxer(s, pls);\n        if (ret < 0) {\n            av_packet_unref(&pls->pkt);\n            reset_packet(&pls->pkt);\n            return ret;\n        }\n\n        /* check if noheader flag has been cleared by the subdemuxer */\n        if (pls->has_noheader_flag && !(pls->ctx->ctx_flags & AVFMTCTX_NOHEADER)) {\n            pls->has_noheader_flag = 0;\n            update_noheader_flag(s);\n        }\n\n        if (pls->pkt.stream_index >= pls->n_main_streams) {\n            av_log(s, AV_LOG_ERROR, \"stream index inconsistency: index %d, %d main streams, %d subdemuxer streams\\n\",\n                   pls->pkt.stream_index, pls->n_main_streams, pls->ctx->nb_streams);\n            av_packet_unref(&pls->pkt);\n            reset_packet(&pls->pkt);\n            return AVERROR_BUG;\n        }\n\n        ist = pls->ctx->streams[pls->pkt.stream_index];\n        st = pls->main_streams[pls->pkt.stream_index];\n\n        *pkt = pls->pkt;\n        pkt->stream_index = st->index;\n        reset_packet(&c->playlists[minplaylist]->pkt);\n\n        if (pkt->dts != AV_NOPTS_VALUE)\n            c->cur_timestamp = av_rescale_q(pkt->dts,\n                                            ist->time_base,\n                                            AV_TIME_BASE_Q);\n\n        /* There may be more situations where this would be useful, but this at least\n         * handles newly probed codecs properly (i.e. request_probe by mpegts). */\n        if (ist->codecpar->codec_id != st->codecpar->codec_id) {\n            ret = set_stream_info_from_input_stream(st, pls, ist);\n            if (ret < 0) {\n                av_packet_unref(pkt);\n                return ret;\n            }\n        }\n\n        return 0;\n    }\n    return AVERROR_EOF;\n}\n\nstatic int hls_read_seek(AVFormatContext *s, int stream_index,\n                               int64_t timestamp, int flags)\n{\n    HLSContext *c = s->priv_data;\n    struct playlist *seek_pls = NULL;\n    int i, seq_no;\n    int j;\n    int stream_subdemuxer_index;\n    int64_t first_timestamp, seek_timestamp, duration;\n\n    if ((flags & AVSEEK_FLAG_BYTE) ||\n        !(c->variants[0]->playlists[0]->finished || c->variants[0]->playlists[0]->type == PLS_TYPE_EVENT))\n        return AVERROR(ENOSYS);\n\n    first_timestamp = c->first_timestamp == AV_NOPTS_VALUE ?\n                      0 : c->first_timestamp;\n\n    seek_timestamp = av_rescale_rnd(timestamp, AV_TIME_BASE,\n                                    s->streams[stream_index]->time_base.den,\n                                    flags & AVSEEK_FLAG_BACKWARD ?\n                                    AV_ROUND_DOWN : AV_ROUND_UP);\n\n    duration = s->duration == AV_NOPTS_VALUE ?\n               0 : s->duration;\n\n    if (0 < duration && duration < seek_timestamp - first_timestamp)\n        return AVERROR(EIO);\n\n    /* find the playlist with the specified stream */\n    for (i = 0; i < c->n_playlists; i++) {\n        struct playlist *pls = c->playlists[i];\n        for (j = 0; j < pls->n_main_streams; j++) {\n            if (pls->main_streams[j] == s->streams[stream_index]) {\n                seek_pls = pls;\n                stream_subdemuxer_index = j;\n                break;\n            }\n        }\n    }\n    /* check if the timestamp is valid for the playlist with the\n     * specified stream index */\n    if (!seek_pls || !find_timestamp_in_playlist(c, seek_pls, seek_timestamp, &seq_no))\n        return AVERROR(EIO);\n\n    /* set segment now so we do not need to search again below */\n    seek_pls->cur_seq_no = seq_no;\n    seek_pls->seek_stream_index = stream_subdemuxer_index;\n\n    for (i = 0; i < c->n_playlists; i++) {\n        /* Reset reading */\n        struct playlist *pls = c->playlists[i];\n        if (pls->input)\n            ff_format_io_close(pls->parent, &pls->input);\n        av_packet_unref(&pls->pkt);\n        reset_packet(&pls->pkt);\n        pls->pb.eof_reached = 0;\n        /* Clear any buffered data */\n        pls->pb.buf_end = pls->pb.buf_ptr = pls->pb.buffer;\n        /* Reset the pos, to let the mpegts demuxer know we've seeked. */\n        pls->pb.pos = 0;\n        /* Flush the packet queue of the subdemuxer. */\n        ff_read_frame_flush(pls->ctx);\n\n        pls->seek_timestamp = seek_timestamp;\n        pls->seek_flags = flags;\n\n        if (pls != seek_pls) {\n            /* set closest segment seq_no for playlists not handled above */\n            find_timestamp_in_playlist(c, pls, seek_timestamp, &pls->cur_seq_no);\n            /* seek the playlist to the given position without taking\n             * keyframes into account since this playlist does not have the\n             * specified stream where we should look for the keyframes */\n            pls->seek_stream_index = -1;\n            pls->seek_flags |= AVSEEK_FLAG_ANY;\n        }\n    }\n\n    c->cur_timestamp = seek_timestamp;\n\n    return 0;\n}\n\nstatic int hls_probe(AVProbeData *p)\n{\n    /* Require #EXTM3U at the start, and either one of the ones below\n     * somewhere for a proper match. */\n    if (strncmp(p->buf, \"#EXTM3U\", 7))\n        return 0;\n\n    if (strstr(p->buf, \"#EXT-X-STREAM-INF:\")     ||\n        strstr(p->buf, \"#EXT-X-TARGETDURATION:\") ||\n        strstr(p->buf, \"#EXT-X-MEDIA-SEQUENCE:\"))\n        return AVPROBE_SCORE_MAX;\n    return 0;\n}\n\n#define OFFSET(x) offsetof(HLSContext, x)\n#define FLAGS AV_OPT_FLAG_DECODING_PARAM\nstatic const AVOption hls_options[] = {\n    {\"live_start_index\", \"segment index to start live streams at (negative values are from the end)\",\n        OFFSET(live_start_index), AV_OPT_TYPE_INT, {.i64 = -3}, INT_MIN, INT_MAX, FLAGS},\n    {NULL}\n};\n\nstatic const AVClass hls_class = {\n    .class_name = \"hls,applehttp\",\n    .item_name  = av_default_item_name,\n    .option     = hls_options,\n    .version    = LIBAVUTIL_VERSION_INT,\n};\n\nAVInputFormat ff_hls_demuxer = {\n    .name           = \"hls,applehttp\",\n    .long_name      = NULL_IF_CONFIG_SMALL(\"Apple HTTP Live Streaming\"),\n    .priv_class     = &hls_class,\n    .priv_data_size = sizeof(HLSContext),\n    .read_probe     = hls_probe,\n    .read_header    = hls_read_header,\n    .read_packet    = hls_read_packet,\n    .read_close     = hls_close,\n    .read_seek      = hls_read_seek,\n};\n"], "fixing_code": ["/*\n * Apple HTTP Live Streaming demuxer\n * Copyright (c) 2010 Martin Storsjo\n * Copyright (c) 2013 Anssi Hannula\n *\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n/**\n * @file\n * Apple HTTP Live Streaming demuxer\n * http://tools.ietf.org/html/draft-pantos-http-live-streaming\n */\n\n#include \"libavutil/avstring.h\"\n#include \"libavutil/avassert.h\"\n#include \"libavutil/intreadwrite.h\"\n#include \"libavutil/mathematics.h\"\n#include \"libavutil/opt.h\"\n#include \"libavutil/dict.h\"\n#include \"libavutil/time.h\"\n#include \"avformat.h\"\n#include \"internal.h\"\n#include \"avio_internal.h\"\n#include \"id3v2.h\"\n\n#define INITIAL_BUFFER_SIZE 32768\n\n#define MAX_FIELD_LEN 64\n#define MAX_CHARACTERISTICS_LEN 512\n\n#define MPEG_TIME_BASE 90000\n#define MPEG_TIME_BASE_Q (AVRational){1, MPEG_TIME_BASE}\n\n/*\n * An apple http stream consists of a playlist with media segment files,\n * played sequentially. There may be several playlists with the same\n * video content, in different bandwidth variants, that are played in\n * parallel (preferably only one bandwidth variant at a time). In this case,\n * the user supplied the url to a main playlist that only lists the variant\n * playlists.\n *\n * If the main playlist doesn't point at any variants, we still create\n * one anonymous toplevel variant for this, to maintain the structure.\n */\n\nenum KeyType {\n    KEY_NONE,\n    KEY_AES_128,\n    KEY_SAMPLE_AES\n};\n\nstruct segment {\n    int64_t duration;\n    int64_t url_offset;\n    int64_t size;\n    char *url;\n    char *key;\n    enum KeyType key_type;\n    uint8_t iv[16];\n    /* associated Media Initialization Section, treated as a segment */\n    struct segment *init_section;\n};\n\nstruct rendition;\n\nenum PlaylistType {\n    PLS_TYPE_UNSPECIFIED,\n    PLS_TYPE_EVENT,\n    PLS_TYPE_VOD\n};\n\n/*\n * Each playlist has its own demuxer. If it currently is active,\n * it has an open AVIOContext too, and potentially an AVPacket\n * containing the next packet from this stream.\n */\nstruct playlist {\n    char url[MAX_URL_SIZE];\n    AVIOContext pb;\n    uint8_t* read_buffer;\n    AVIOContext *input;\n    AVFormatContext *parent;\n    int index;\n    AVFormatContext *ctx;\n    AVPacket pkt;\n    int has_noheader_flag;\n\n    /* main demuxer streams associated with this playlist\n     * indexed by the subdemuxer stream indexes */\n    AVStream **main_streams;\n    int n_main_streams;\n\n    int finished;\n    enum PlaylistType type;\n    int64_t target_duration;\n    int start_seq_no;\n    int n_segments;\n    struct segment **segments;\n    int needed, cur_needed;\n    int cur_seq_no;\n    int64_t cur_seg_offset;\n    int64_t last_load_time;\n\n    /* Currently active Media Initialization Section */\n    struct segment *cur_init_section;\n    uint8_t *init_sec_buf;\n    unsigned int init_sec_buf_size;\n    unsigned int init_sec_data_len;\n    unsigned int init_sec_buf_read_offset;\n\n    char key_url[MAX_URL_SIZE];\n    uint8_t key[16];\n\n    /* ID3 timestamp handling (elementary audio streams have ID3 timestamps\n     * (and possibly other ID3 tags) in the beginning of each segment) */\n    int is_id3_timestamped; /* -1: not yet known */\n    int64_t id3_mpegts_timestamp; /* in mpegts tb */\n    int64_t id3_offset; /* in stream original tb */\n    uint8_t* id3_buf; /* temp buffer for id3 parsing */\n    unsigned int id3_buf_size;\n    AVDictionary *id3_initial; /* data from first id3 tag */\n    int id3_found; /* ID3 tag found at some point */\n    int id3_changed; /* ID3 tag data has changed at some point */\n    ID3v2ExtraMeta *id3_deferred_extra; /* stored here until subdemuxer is opened */\n\n    int64_t seek_timestamp;\n    int seek_flags;\n    int seek_stream_index; /* into subdemuxer stream array */\n\n    /* Renditions associated with this playlist, if any.\n     * Alternative rendition playlists have a single rendition associated\n     * with them, and variant main Media Playlists may have\n     * multiple (playlist-less) renditions associated with them. */\n    int n_renditions;\n    struct rendition **renditions;\n\n    /* Media Initialization Sections (EXT-X-MAP) associated with this\n     * playlist, if any. */\n    int n_init_sections;\n    struct segment **init_sections;\n};\n\n/*\n * Renditions are e.g. alternative subtitle or audio streams.\n * The rendition may either be an external playlist or it may be\n * contained in the main Media Playlist of the variant (in which case\n * playlist is NULL).\n */\nstruct rendition {\n    enum AVMediaType type;\n    struct playlist *playlist;\n    char group_id[MAX_FIELD_LEN];\n    char language[MAX_FIELD_LEN];\n    char name[MAX_FIELD_LEN];\n    int disposition;\n};\n\nstruct variant {\n    int bandwidth;\n\n    /* every variant contains at least the main Media Playlist in index 0 */\n    int n_playlists;\n    struct playlist **playlists;\n\n    char audio_group[MAX_FIELD_LEN];\n    char video_group[MAX_FIELD_LEN];\n    char subtitles_group[MAX_FIELD_LEN];\n};\n\ntypedef struct HLSContext {\n    AVClass *class;\n    AVFormatContext *ctx;\n    int n_variants;\n    struct variant **variants;\n    int n_playlists;\n    struct playlist **playlists;\n    int n_renditions;\n    struct rendition **renditions;\n\n    int cur_seq_no;\n    int live_start_index;\n    int first_packet;\n    int64_t first_timestamp;\n    int64_t cur_timestamp;\n    AVIOInterruptCB *interrupt_callback;\n    char *user_agent;                    ///< holds HTTP user agent set as an AVOption to the HTTP protocol context\n    char *cookies;                       ///< holds HTTP cookie values set in either the initial response or as an AVOption to the HTTP protocol context\n    char *headers;                       ///< holds HTTP headers set as an AVOption to the HTTP protocol context\n    char *http_proxy;                    ///< holds the address of the HTTP proxy server\n    AVDictionary *avio_opts;\n    int strict_std_compliance;\n    char *allowed_extensions;\n} HLSContext;\n\nstatic int read_chomp_line(AVIOContext *s, char *buf, int maxlen)\n{\n    int len = ff_get_line(s, buf, maxlen);\n    while (len > 0 && av_isspace(buf[len - 1]))\n        buf[--len] = '\\0';\n    return len;\n}\n\nstatic void free_segment_list(struct playlist *pls)\n{\n    int i;\n    for (i = 0; i < pls->n_segments; i++) {\n        av_freep(&pls->segments[i]->key);\n        av_freep(&pls->segments[i]->url);\n        av_freep(&pls->segments[i]);\n    }\n    av_freep(&pls->segments);\n    pls->n_segments = 0;\n}\n\nstatic void free_init_section_list(struct playlist *pls)\n{\n    int i;\n    for (i = 0; i < pls->n_init_sections; i++) {\n        av_freep(&pls->init_sections[i]->url);\n        av_freep(&pls->init_sections[i]);\n    }\n    av_freep(&pls->init_sections);\n    pls->n_init_sections = 0;\n}\n\nstatic void free_playlist_list(HLSContext *c)\n{\n    int i;\n    for (i = 0; i < c->n_playlists; i++) {\n        struct playlist *pls = c->playlists[i];\n        free_segment_list(pls);\n        free_init_section_list(pls);\n        av_freep(&pls->main_streams);\n        av_freep(&pls->renditions);\n        av_freep(&pls->id3_buf);\n        av_dict_free(&pls->id3_initial);\n        ff_id3v2_free_extra_meta(&pls->id3_deferred_extra);\n        av_freep(&pls->init_sec_buf);\n        av_packet_unref(&pls->pkt);\n        av_freep(&pls->pb.buffer);\n        if (pls->input)\n            ff_format_io_close(c->ctx, &pls->input);\n        if (pls->ctx) {\n            pls->ctx->pb = NULL;\n            avformat_close_input(&pls->ctx);\n        }\n        av_free(pls);\n    }\n    av_freep(&c->playlists);\n    av_freep(&c->cookies);\n    av_freep(&c->user_agent);\n    av_freep(&c->headers);\n    av_freep(&c->http_proxy);\n    c->n_playlists = 0;\n}\n\nstatic void free_variant_list(HLSContext *c)\n{\n    int i;\n    for (i = 0; i < c->n_variants; i++) {\n        struct variant *var = c->variants[i];\n        av_freep(&var->playlists);\n        av_free(var);\n    }\n    av_freep(&c->variants);\n    c->n_variants = 0;\n}\n\nstatic void free_rendition_list(HLSContext *c)\n{\n    int i;\n    for (i = 0; i < c->n_renditions; i++)\n        av_freep(&c->renditions[i]);\n    av_freep(&c->renditions);\n    c->n_renditions = 0;\n}\n\n/*\n * Used to reset a statically allocated AVPacket to a clean slate,\n * containing no data.\n */\nstatic void reset_packet(AVPacket *pkt)\n{\n    av_init_packet(pkt);\n    pkt->data = NULL;\n}\n\nstatic struct playlist *new_playlist(HLSContext *c, const char *url,\n                                     const char *base)\n{\n    struct playlist *pls = av_mallocz(sizeof(struct playlist));\n    if (!pls)\n        return NULL;\n    reset_packet(&pls->pkt);\n    ff_make_absolute_url(pls->url, sizeof(pls->url), base, url);\n    pls->seek_timestamp = AV_NOPTS_VALUE;\n\n    pls->is_id3_timestamped = -1;\n    pls->id3_mpegts_timestamp = AV_NOPTS_VALUE;\n\n    dynarray_add(&c->playlists, &c->n_playlists, pls);\n    return pls;\n}\n\nstruct variant_info {\n    char bandwidth[20];\n    /* variant group ids: */\n    char audio[MAX_FIELD_LEN];\n    char video[MAX_FIELD_LEN];\n    char subtitles[MAX_FIELD_LEN];\n};\n\nstatic struct variant *new_variant(HLSContext *c, struct variant_info *info,\n                                   const char *url, const char *base)\n{\n    struct variant *var;\n    struct playlist *pls;\n\n    pls = new_playlist(c, url, base);\n    if (!pls)\n        return NULL;\n\n    var = av_mallocz(sizeof(struct variant));\n    if (!var)\n        return NULL;\n\n    if (info) {\n        var->bandwidth = atoi(info->bandwidth);\n        strcpy(var->audio_group, info->audio);\n        strcpy(var->video_group, info->video);\n        strcpy(var->subtitles_group, info->subtitles);\n    }\n\n    dynarray_add(&c->variants, &c->n_variants, var);\n    dynarray_add(&var->playlists, &var->n_playlists, pls);\n    return var;\n}\n\nstatic void handle_variant_args(struct variant_info *info, const char *key,\n                                int key_len, char **dest, int *dest_len)\n{\n    if (!strncmp(key, \"BANDWIDTH=\", key_len)) {\n        *dest     =        info->bandwidth;\n        *dest_len = sizeof(info->bandwidth);\n    } else if (!strncmp(key, \"AUDIO=\", key_len)) {\n        *dest     =        info->audio;\n        *dest_len = sizeof(info->audio);\n    } else if (!strncmp(key, \"VIDEO=\", key_len)) {\n        *dest     =        info->video;\n        *dest_len = sizeof(info->video);\n    } else if (!strncmp(key, \"SUBTITLES=\", key_len)) {\n        *dest     =        info->subtitles;\n        *dest_len = sizeof(info->subtitles);\n    }\n}\n\nstruct key_info {\n     char uri[MAX_URL_SIZE];\n     char method[11];\n     char iv[35];\n};\n\nstatic void handle_key_args(struct key_info *info, const char *key,\n                            int key_len, char **dest, int *dest_len)\n{\n    if (!strncmp(key, \"METHOD=\", key_len)) {\n        *dest     =        info->method;\n        *dest_len = sizeof(info->method);\n    } else if (!strncmp(key, \"URI=\", key_len)) {\n        *dest     =        info->uri;\n        *dest_len = sizeof(info->uri);\n    } else if (!strncmp(key, \"IV=\", key_len)) {\n        *dest     =        info->iv;\n        *dest_len = sizeof(info->iv);\n    }\n}\n\nstruct init_section_info {\n    char uri[MAX_URL_SIZE];\n    char byterange[32];\n};\n\nstatic struct segment *new_init_section(struct playlist *pls,\n                                        struct init_section_info *info,\n                                        const char *url_base)\n{\n    struct segment *sec;\n    char *ptr;\n    char tmp_str[MAX_URL_SIZE];\n\n    if (!info->uri[0])\n        return NULL;\n\n    sec = av_mallocz(sizeof(*sec));\n    if (!sec)\n        return NULL;\n\n    ff_make_absolute_url(tmp_str, sizeof(tmp_str), url_base, info->uri);\n    sec->url = av_strdup(tmp_str);\n    if (!sec->url) {\n        av_free(sec);\n        return NULL;\n    }\n\n    if (info->byterange[0]) {\n        sec->size = strtoll(info->byterange, NULL, 10);\n        ptr = strchr(info->byterange, '@');\n        if (ptr)\n            sec->url_offset = strtoll(ptr+1, NULL, 10);\n    } else {\n        /* the entire file is the init section */\n        sec->size = -1;\n    }\n\n    dynarray_add(&pls->init_sections, &pls->n_init_sections, sec);\n\n    return sec;\n}\n\nstatic void handle_init_section_args(struct init_section_info *info, const char *key,\n                                           int key_len, char **dest, int *dest_len)\n{\n    if (!strncmp(key, \"URI=\", key_len)) {\n        *dest     =        info->uri;\n        *dest_len = sizeof(info->uri);\n    } else if (!strncmp(key, \"BYTERANGE=\", key_len)) {\n        *dest     =        info->byterange;\n        *dest_len = sizeof(info->byterange);\n    }\n}\n\nstruct rendition_info {\n    char type[16];\n    char uri[MAX_URL_SIZE];\n    char group_id[MAX_FIELD_LEN];\n    char language[MAX_FIELD_LEN];\n    char assoc_language[MAX_FIELD_LEN];\n    char name[MAX_FIELD_LEN];\n    char defaultr[4];\n    char forced[4];\n    char characteristics[MAX_CHARACTERISTICS_LEN];\n};\n\nstatic struct rendition *new_rendition(HLSContext *c, struct rendition_info *info,\n                                      const char *url_base)\n{\n    struct rendition *rend;\n    enum AVMediaType type = AVMEDIA_TYPE_UNKNOWN;\n    char *characteristic;\n    char *chr_ptr;\n    char *saveptr;\n\n    if (!strcmp(info->type, \"AUDIO\"))\n        type = AVMEDIA_TYPE_AUDIO;\n    else if (!strcmp(info->type, \"VIDEO\"))\n        type = AVMEDIA_TYPE_VIDEO;\n    else if (!strcmp(info->type, \"SUBTITLES\"))\n        type = AVMEDIA_TYPE_SUBTITLE;\n    else if (!strcmp(info->type, \"CLOSED-CAPTIONS\"))\n        /* CLOSED-CAPTIONS is ignored since we do not support CEA-608 CC in\n         * AVC SEI RBSP anyway */\n        return NULL;\n\n    if (type == AVMEDIA_TYPE_UNKNOWN)\n        return NULL;\n\n    /* URI is mandatory for subtitles as per spec */\n    if (type == AVMEDIA_TYPE_SUBTITLE && !info->uri[0])\n        return NULL;\n\n    /* TODO: handle subtitles (each segment has to parsed separately) */\n    if (c->strict_std_compliance > FF_COMPLIANCE_EXPERIMENTAL)\n        if (type == AVMEDIA_TYPE_SUBTITLE)\n            return NULL;\n\n    rend = av_mallocz(sizeof(struct rendition));\n    if (!rend)\n        return NULL;\n\n    dynarray_add(&c->renditions, &c->n_renditions, rend);\n\n    rend->type = type;\n    strcpy(rend->group_id, info->group_id);\n    strcpy(rend->language, info->language);\n    strcpy(rend->name, info->name);\n\n    /* add the playlist if this is an external rendition */\n    if (info->uri[0]) {\n        rend->playlist = new_playlist(c, info->uri, url_base);\n        if (rend->playlist)\n            dynarray_add(&rend->playlist->renditions,\n                         &rend->playlist->n_renditions, rend);\n    }\n\n    if (info->assoc_language[0]) {\n        int langlen = strlen(rend->language);\n        if (langlen < sizeof(rend->language) - 3) {\n            rend->language[langlen] = ',';\n            strncpy(rend->language + langlen + 1, info->assoc_language,\n                    sizeof(rend->language) - langlen - 2);\n        }\n    }\n\n    if (!strcmp(info->defaultr, \"YES\"))\n        rend->disposition |= AV_DISPOSITION_DEFAULT;\n    if (!strcmp(info->forced, \"YES\"))\n        rend->disposition |= AV_DISPOSITION_FORCED;\n\n    chr_ptr = info->characteristics;\n    while ((characteristic = av_strtok(chr_ptr, \",\", &saveptr))) {\n        if (!strcmp(characteristic, \"public.accessibility.describes-music-and-sound\"))\n            rend->disposition |= AV_DISPOSITION_HEARING_IMPAIRED;\n        else if (!strcmp(characteristic, \"public.accessibility.describes-video\"))\n            rend->disposition |= AV_DISPOSITION_VISUAL_IMPAIRED;\n\n        chr_ptr = NULL;\n    }\n\n    return rend;\n}\n\nstatic void handle_rendition_args(struct rendition_info *info, const char *key,\n                                  int key_len, char **dest, int *dest_len)\n{\n    if (!strncmp(key, \"TYPE=\", key_len)) {\n        *dest     =        info->type;\n        *dest_len = sizeof(info->type);\n    } else if (!strncmp(key, \"URI=\", key_len)) {\n        *dest     =        info->uri;\n        *dest_len = sizeof(info->uri);\n    } else if (!strncmp(key, \"GROUP-ID=\", key_len)) {\n        *dest     =        info->group_id;\n        *dest_len = sizeof(info->group_id);\n    } else if (!strncmp(key, \"LANGUAGE=\", key_len)) {\n        *dest     =        info->language;\n        *dest_len = sizeof(info->language);\n    } else if (!strncmp(key, \"ASSOC-LANGUAGE=\", key_len)) {\n        *dest     =        info->assoc_language;\n        *dest_len = sizeof(info->assoc_language);\n    } else if (!strncmp(key, \"NAME=\", key_len)) {\n        *dest     =        info->name;\n        *dest_len = sizeof(info->name);\n    } else if (!strncmp(key, \"DEFAULT=\", key_len)) {\n        *dest     =        info->defaultr;\n        *dest_len = sizeof(info->defaultr);\n    } else if (!strncmp(key, \"FORCED=\", key_len)) {\n        *dest     =        info->forced;\n        *dest_len = sizeof(info->forced);\n    } else if (!strncmp(key, \"CHARACTERISTICS=\", key_len)) {\n        *dest     =        info->characteristics;\n        *dest_len = sizeof(info->characteristics);\n    }\n    /*\n     * ignored:\n     * - AUTOSELECT: client may autoselect based on e.g. system language\n     * - INSTREAM-ID: EIA-608 closed caption number (\"CC1\"..\"CC4\")\n     */\n}\n\n/* used by parse_playlist to allocate a new variant+playlist when the\n * playlist is detected to be a Media Playlist (not Master Playlist)\n * and we have no parent Master Playlist (parsing of which would have\n * allocated the variant and playlist already)\n * *pls == NULL  => Master Playlist or parentless Media Playlist\n * *pls != NULL => parented Media Playlist, playlist+variant allocated */\nstatic int ensure_playlist(HLSContext *c, struct playlist **pls, const char *url)\n{\n    if (*pls)\n        return 0;\n    if (!new_variant(c, NULL, url, NULL))\n        return AVERROR(ENOMEM);\n    *pls = c->playlists[c->n_playlists - 1];\n    return 0;\n}\n\nstatic void update_options(char **dest, const char *name, void *src)\n{\n    av_freep(dest);\n    av_opt_get(src, name, AV_OPT_SEARCH_CHILDREN, (uint8_t**)dest);\n    if (*dest && !strlen(*dest))\n        av_freep(dest);\n}\n\nstatic int open_url(AVFormatContext *s, AVIOContext **pb, const char *url,\n                    AVDictionary *opts, AVDictionary *opts2, int *is_http)\n{\n    HLSContext *c = s->priv_data;\n    AVDictionary *tmp = NULL;\n    const char *proto_name = NULL;\n    int ret;\n\n    av_dict_copy(&tmp, opts, 0);\n    av_dict_copy(&tmp, opts2, 0);\n\n    if (av_strstart(url, \"crypto\", NULL)) {\n        if (url[6] == '+' || url[6] == ':')\n            proto_name = avio_find_protocol_name(url + 7);\n    }\n\n    if (!proto_name)\n        proto_name = avio_find_protocol_name(url);\n\n    if (!proto_name)\n        return AVERROR_INVALIDDATA;\n\n    // only http(s) & file are allowed\n    if (av_strstart(proto_name, \"file\", NULL)) {\n        if (strcmp(c->allowed_extensions, \"ALL\") && !av_match_ext(url, c->allowed_extensions)) {\n            av_log(s, AV_LOG_ERROR,\n                \"Filename extension of \\'%s\\' is not a common multimedia extension, blocked for security reasons.\\n\"\n                \"If you wish to override this adjust allowed_extensions, you can set it to \\'ALL\\' to allow all\\n\",\n                url);\n            return AVERROR_INVALIDDATA;\n        }\n    } else if (av_strstart(proto_name, \"http\", NULL)) {\n        ;\n    } else\n        return AVERROR_INVALIDDATA;\n\n    if (!strncmp(proto_name, url, strlen(proto_name)) && url[strlen(proto_name)] == ':')\n        ;\n    else if (av_strstart(url, \"crypto\", NULL) && !strncmp(proto_name, url + 7, strlen(proto_name)) && url[7 + strlen(proto_name)] == ':')\n        ;\n    else if (strcmp(proto_name, \"file\") || !strncmp(url, \"file,\", 5))\n        return AVERROR_INVALIDDATA;\n\n    ret = s->io_open(s, pb, url, AVIO_FLAG_READ, &tmp);\n    if (ret >= 0) {\n        // update cookies on http response with setcookies.\n        char *new_cookies = NULL;\n\n        if (!(s->flags & AVFMT_FLAG_CUSTOM_IO))\n            av_opt_get(*pb, \"cookies\", AV_OPT_SEARCH_CHILDREN, (uint8_t**)&new_cookies);\n\n        if (new_cookies) {\n            av_free(c->cookies);\n            c->cookies = new_cookies;\n        }\n\n        av_dict_set(&opts, \"cookies\", c->cookies, 0);\n    }\n\n    av_dict_free(&tmp);\n\n    if (is_http)\n        *is_http = av_strstart(proto_name, \"http\", NULL);\n\n    return ret;\n}\n\nstatic int parse_playlist(HLSContext *c, const char *url,\n                          struct playlist *pls, AVIOContext *in)\n{\n    int ret = 0, is_segment = 0, is_variant = 0;\n    int64_t duration = 0;\n    enum KeyType key_type = KEY_NONE;\n    uint8_t iv[16] = \"\";\n    int has_iv = 0;\n    char key[MAX_URL_SIZE] = \"\";\n    char line[MAX_URL_SIZE];\n    const char *ptr;\n    int close_in = 0;\n    int64_t seg_offset = 0;\n    int64_t seg_size = -1;\n    uint8_t *new_url = NULL;\n    struct variant_info variant_info;\n    char tmp_str[MAX_URL_SIZE];\n    struct segment *cur_init_section = NULL;\n\n    if (!in) {\n#if 1\n        AVDictionary *opts = NULL;\n        close_in = 1;\n        /* Some HLS servers don't like being sent the range header */\n        av_dict_set(&opts, \"seekable\", \"0\", 0);\n\n        // broker prior HTTP options that should be consistent across requests\n        av_dict_set(&opts, \"user_agent\", c->user_agent, 0);\n        av_dict_set(&opts, \"cookies\", c->cookies, 0);\n        av_dict_set(&opts, \"headers\", c->headers, 0);\n        av_dict_set(&opts, \"http_proxy\", c->http_proxy, 0);\n\n        ret = c->ctx->io_open(c->ctx, &in, url, AVIO_FLAG_READ, &opts);\n        av_dict_free(&opts);\n        if (ret < 0)\n            return ret;\n#else\n        ret = open_in(c, &in, url);\n        if (ret < 0)\n            return ret;\n        close_in = 1;\n#endif\n    }\n\n    if (av_opt_get(in, \"location\", AV_OPT_SEARCH_CHILDREN, &new_url) >= 0)\n        url = new_url;\n\n    read_chomp_line(in, line, sizeof(line));\n    if (strcmp(line, \"#EXTM3U\")) {\n        ret = AVERROR_INVALIDDATA;\n        goto fail;\n    }\n\n    if (pls) {\n        free_segment_list(pls);\n        pls->finished = 0;\n        pls->type = PLS_TYPE_UNSPECIFIED;\n    }\n    while (!avio_feof(in)) {\n        read_chomp_line(in, line, sizeof(line));\n        if (av_strstart(line, \"#EXT-X-STREAM-INF:\", &ptr)) {\n            is_variant = 1;\n            memset(&variant_info, 0, sizeof(variant_info));\n            ff_parse_key_value(ptr, (ff_parse_key_val_cb) handle_variant_args,\n                               &variant_info);\n        } else if (av_strstart(line, \"#EXT-X-KEY:\", &ptr)) {\n            struct key_info info = {{0}};\n            ff_parse_key_value(ptr, (ff_parse_key_val_cb) handle_key_args,\n                               &info);\n            key_type = KEY_NONE;\n            has_iv = 0;\n            if (!strcmp(info.method, \"AES-128\"))\n                key_type = KEY_AES_128;\n            if (!strcmp(info.method, \"SAMPLE-AES\"))\n                key_type = KEY_SAMPLE_AES;\n            if (!strncmp(info.iv, \"0x\", 2) || !strncmp(info.iv, \"0X\", 2)) {\n                ff_hex_to_data(iv, info.iv + 2);\n                has_iv = 1;\n            }\n            av_strlcpy(key, info.uri, sizeof(key));\n        } else if (av_strstart(line, \"#EXT-X-MEDIA:\", &ptr)) {\n            struct rendition_info info = {{0}};\n            ff_parse_key_value(ptr, (ff_parse_key_val_cb) handle_rendition_args,\n                               &info);\n            new_rendition(c, &info, url);\n        } else if (av_strstart(line, \"#EXT-X-TARGETDURATION:\", &ptr)) {\n            ret = ensure_playlist(c, &pls, url);\n            if (ret < 0)\n                goto fail;\n            pls->target_duration = strtoll(ptr, NULL, 10) * AV_TIME_BASE;\n        } else if (av_strstart(line, \"#EXT-X-MEDIA-SEQUENCE:\", &ptr)) {\n            ret = ensure_playlist(c, &pls, url);\n            if (ret < 0)\n                goto fail;\n            pls->start_seq_no = atoi(ptr);\n        } else if (av_strstart(line, \"#EXT-X-PLAYLIST-TYPE:\", &ptr)) {\n            ret = ensure_playlist(c, &pls, url);\n            if (ret < 0)\n                goto fail;\n            if (!strcmp(ptr, \"EVENT\"))\n                pls->type = PLS_TYPE_EVENT;\n            else if (!strcmp(ptr, \"VOD\"))\n                pls->type = PLS_TYPE_VOD;\n        } else if (av_strstart(line, \"#EXT-X-MAP:\", &ptr)) {\n            struct init_section_info info = {{0}};\n            ret = ensure_playlist(c, &pls, url);\n            if (ret < 0)\n                goto fail;\n            ff_parse_key_value(ptr, (ff_parse_key_val_cb) handle_init_section_args,\n                               &info);\n            cur_init_section = new_init_section(pls, &info, url);\n        } else if (av_strstart(line, \"#EXT-X-ENDLIST\", &ptr)) {\n            if (pls)\n                pls->finished = 1;\n        } else if (av_strstart(line, \"#EXTINF:\", &ptr)) {\n            is_segment = 1;\n            duration   = atof(ptr) * AV_TIME_BASE;\n        } else if (av_strstart(line, \"#EXT-X-BYTERANGE:\", &ptr)) {\n            seg_size = strtoll(ptr, NULL, 10);\n            ptr = strchr(ptr, '@');\n            if (ptr)\n                seg_offset = strtoll(ptr+1, NULL, 10);\n        } else if (av_strstart(line, \"#\", NULL)) {\n            continue;\n        } else if (line[0]) {\n            if (is_variant) {\n                if (!new_variant(c, &variant_info, line, url)) {\n                    ret = AVERROR(ENOMEM);\n                    goto fail;\n                }\n                is_variant = 0;\n            }\n            if (is_segment) {\n                struct segment *seg;\n                if (!pls) {\n                    if (!new_variant(c, 0, url, NULL)) {\n                        ret = AVERROR(ENOMEM);\n                        goto fail;\n                    }\n                    pls = c->playlists[c->n_playlists - 1];\n                }\n                seg = av_malloc(sizeof(struct segment));\n                if (!seg) {\n                    ret = AVERROR(ENOMEM);\n                    goto fail;\n                }\n                seg->duration = duration;\n                seg->key_type = key_type;\n                if (has_iv) {\n                    memcpy(seg->iv, iv, sizeof(iv));\n                } else {\n                    int seq = pls->start_seq_no + pls->n_segments;\n                    memset(seg->iv, 0, sizeof(seg->iv));\n                    AV_WB32(seg->iv + 12, seq);\n                }\n\n                if (key_type != KEY_NONE) {\n                    ff_make_absolute_url(tmp_str, sizeof(tmp_str), url, key);\n                    seg->key = av_strdup(tmp_str);\n                    if (!seg->key) {\n                        av_free(seg);\n                        ret = AVERROR(ENOMEM);\n                        goto fail;\n                    }\n                } else {\n                    seg->key = NULL;\n                }\n\n                ff_make_absolute_url(tmp_str, sizeof(tmp_str), url, line);\n                seg->url = av_strdup(tmp_str);\n                if (!seg->url) {\n                    av_free(seg->key);\n                    av_free(seg);\n                    ret = AVERROR(ENOMEM);\n                    goto fail;\n                }\n\n                dynarray_add(&pls->segments, &pls->n_segments, seg);\n                is_segment = 0;\n\n                seg->size = seg_size;\n                if (seg_size >= 0) {\n                    seg->url_offset = seg_offset;\n                    seg_offset += seg_size;\n                    seg_size = -1;\n                } else {\n                    seg->url_offset = 0;\n                    seg_offset = 0;\n                }\n\n                seg->init_section = cur_init_section;\n            }\n        }\n    }\n    if (pls)\n        pls->last_load_time = av_gettime_relative();\n\nfail:\n    av_free(new_url);\n    if (close_in)\n        ff_format_io_close(c->ctx, &in);\n    return ret;\n}\n\nstatic struct segment *current_segment(struct playlist *pls)\n{\n    return pls->segments[pls->cur_seq_no - pls->start_seq_no];\n}\n\nenum ReadFromURLMode {\n    READ_NORMAL,\n    READ_COMPLETE,\n};\n\nstatic int read_from_url(struct playlist *pls, struct segment *seg,\n                         uint8_t *buf, int buf_size,\n                         enum ReadFromURLMode mode)\n{\n    int ret;\n\n     /* limit read if the segment was only a part of a file */\n    if (seg->size >= 0)\n        buf_size = FFMIN(buf_size, seg->size - pls->cur_seg_offset);\n\n    if (mode == READ_COMPLETE) {\n        ret = avio_read(pls->input, buf, buf_size);\n        if (ret != buf_size)\n            av_log(NULL, AV_LOG_ERROR, \"Could not read complete segment.\\n\");\n    } else\n        ret = avio_read(pls->input, buf, buf_size);\n\n    if (ret > 0)\n        pls->cur_seg_offset += ret;\n\n    return ret;\n}\n\n/* Parse the raw ID3 data and pass contents to caller */\nstatic void parse_id3(AVFormatContext *s, AVIOContext *pb,\n                      AVDictionary **metadata, int64_t *dts,\n                      ID3v2ExtraMetaAPIC **apic, ID3v2ExtraMeta **extra_meta)\n{\n    static const char id3_priv_owner_ts[] = \"com.apple.streaming.transportStreamTimestamp\";\n    ID3v2ExtraMeta *meta;\n\n    ff_id3v2_read_dict(pb, metadata, ID3v2_DEFAULT_MAGIC, extra_meta);\n    for (meta = *extra_meta; meta; meta = meta->next) {\n        if (!strcmp(meta->tag, \"PRIV\")) {\n            ID3v2ExtraMetaPRIV *priv = meta->data;\n            if (priv->datasize == 8 && !strcmp(priv->owner, id3_priv_owner_ts)) {\n                /* 33-bit MPEG timestamp */\n                int64_t ts = AV_RB64(priv->data);\n                av_log(s, AV_LOG_DEBUG, \"HLS ID3 audio timestamp %\"PRId64\"\\n\", ts);\n                if ((ts & ~((1ULL << 33) - 1)) == 0)\n                    *dts = ts;\n                else\n                    av_log(s, AV_LOG_ERROR, \"Invalid HLS ID3 audio timestamp %\"PRId64\"\\n\", ts);\n            }\n        } else if (!strcmp(meta->tag, \"APIC\") && apic)\n            *apic = meta->data;\n    }\n}\n\n/* Check if the ID3 metadata contents have changed */\nstatic int id3_has_changed_values(struct playlist *pls, AVDictionary *metadata,\n                                  ID3v2ExtraMetaAPIC *apic)\n{\n    AVDictionaryEntry *entry = NULL;\n    AVDictionaryEntry *oldentry;\n    /* check that no keys have changed values */\n    while ((entry = av_dict_get(metadata, \"\", entry, AV_DICT_IGNORE_SUFFIX))) {\n        oldentry = av_dict_get(pls->id3_initial, entry->key, NULL, AV_DICT_MATCH_CASE);\n        if (!oldentry || strcmp(oldentry->value, entry->value) != 0)\n            return 1;\n    }\n\n    /* check if apic appeared */\n    if (apic && (pls->ctx->nb_streams != 2 || !pls->ctx->streams[1]->attached_pic.data))\n        return 1;\n\n    if (apic) {\n        int size = pls->ctx->streams[1]->attached_pic.size;\n        if (size != apic->buf->size - AV_INPUT_BUFFER_PADDING_SIZE)\n            return 1;\n\n        if (memcmp(apic->buf->data, pls->ctx->streams[1]->attached_pic.data, size) != 0)\n            return 1;\n    }\n\n    return 0;\n}\n\n/* Parse ID3 data and handle the found data */\nstatic void handle_id3(AVIOContext *pb, struct playlist *pls)\n{\n    AVDictionary *metadata = NULL;\n    ID3v2ExtraMetaAPIC *apic = NULL;\n    ID3v2ExtraMeta *extra_meta = NULL;\n    int64_t timestamp = AV_NOPTS_VALUE;\n\n    parse_id3(pls->ctx, pb, &metadata, &timestamp, &apic, &extra_meta);\n\n    if (timestamp != AV_NOPTS_VALUE) {\n        pls->id3_mpegts_timestamp = timestamp;\n        pls->id3_offset = 0;\n    }\n\n    if (!pls->id3_found) {\n        /* initial ID3 tags */\n        av_assert0(!pls->id3_deferred_extra);\n        pls->id3_found = 1;\n\n        /* get picture attachment and set text metadata */\n        if (pls->ctx->nb_streams)\n            ff_id3v2_parse_apic(pls->ctx, &extra_meta);\n        else\n            /* demuxer not yet opened, defer picture attachment */\n            pls->id3_deferred_extra = extra_meta;\n\n        av_dict_copy(&pls->ctx->metadata, metadata, 0);\n        pls->id3_initial = metadata;\n\n    } else {\n        if (!pls->id3_changed && id3_has_changed_values(pls, metadata, apic)) {\n            avpriv_report_missing_feature(pls->ctx, \"Changing ID3 metadata in HLS audio elementary stream\");\n            pls->id3_changed = 1;\n        }\n        av_dict_free(&metadata);\n    }\n\n    if (!pls->id3_deferred_extra)\n        ff_id3v2_free_extra_meta(&extra_meta);\n}\n\nstatic void intercept_id3(struct playlist *pls, uint8_t *buf,\n                         int buf_size, int *len)\n{\n    /* intercept id3 tags, we do not want to pass them to the raw\n     * demuxer on all segment switches */\n    int bytes;\n    int id3_buf_pos = 0;\n    int fill_buf = 0;\n    struct segment *seg = current_segment(pls);\n\n    /* gather all the id3 tags */\n    while (1) {\n        /* see if we can retrieve enough data for ID3 header */\n        if (*len < ID3v2_HEADER_SIZE && buf_size >= ID3v2_HEADER_SIZE) {\n            bytes = read_from_url(pls, seg, buf + *len, ID3v2_HEADER_SIZE - *len, READ_COMPLETE);\n            if (bytes > 0) {\n\n                if (bytes == ID3v2_HEADER_SIZE - *len)\n                    /* no EOF yet, so fill the caller buffer again after\n                     * we have stripped the ID3 tags */\n                    fill_buf = 1;\n\n                *len += bytes;\n\n            } else if (*len <= 0) {\n                /* error/EOF */\n                *len = bytes;\n                fill_buf = 0;\n            }\n        }\n\n        if (*len < ID3v2_HEADER_SIZE)\n            break;\n\n        if (ff_id3v2_match(buf, ID3v2_DEFAULT_MAGIC)) {\n            int64_t maxsize = seg->size >= 0 ? seg->size : 1024*1024;\n            int taglen = ff_id3v2_tag_len(buf);\n            int tag_got_bytes = FFMIN(taglen, *len);\n            int remaining = taglen - tag_got_bytes;\n\n            if (taglen > maxsize) {\n                av_log(pls->ctx, AV_LOG_ERROR, \"Too large HLS ID3 tag (%d > %\"PRId64\" bytes)\\n\",\n                       taglen, maxsize);\n                break;\n            }\n\n            /*\n             * Copy the id3 tag to our temporary id3 buffer.\n             * We could read a small id3 tag directly without memcpy, but\n             * we would still need to copy the large tags, and handling\n             * both of those cases together with the possibility for multiple\n             * tags would make the handling a bit complex.\n             */\n            pls->id3_buf = av_fast_realloc(pls->id3_buf, &pls->id3_buf_size, id3_buf_pos + taglen);\n            if (!pls->id3_buf)\n                break;\n            memcpy(pls->id3_buf + id3_buf_pos, buf, tag_got_bytes);\n            id3_buf_pos += tag_got_bytes;\n\n            /* strip the intercepted bytes */\n            *len -= tag_got_bytes;\n            memmove(buf, buf + tag_got_bytes, *len);\n            av_log(pls->ctx, AV_LOG_DEBUG, \"Stripped %d HLS ID3 bytes\\n\", tag_got_bytes);\n\n            if (remaining > 0) {\n                /* read the rest of the tag in */\n                if (read_from_url(pls, seg, pls->id3_buf + id3_buf_pos, remaining, READ_COMPLETE) != remaining)\n                    break;\n                id3_buf_pos += remaining;\n                av_log(pls->ctx, AV_LOG_DEBUG, \"Stripped additional %d HLS ID3 bytes\\n\", remaining);\n            }\n\n        } else {\n            /* no more ID3 tags */\n            break;\n        }\n    }\n\n    /* re-fill buffer for the caller unless EOF */\n    if (*len >= 0 && (fill_buf || *len == 0)) {\n        bytes = read_from_url(pls, seg, buf + *len, buf_size - *len, READ_NORMAL);\n\n        /* ignore error if we already had some data */\n        if (bytes >= 0)\n            *len += bytes;\n        else if (*len == 0)\n            *len = bytes;\n    }\n\n    if (pls->id3_buf) {\n        /* Now parse all the ID3 tags */\n        AVIOContext id3ioctx;\n        ffio_init_context(&id3ioctx, pls->id3_buf, id3_buf_pos, 0, NULL, NULL, NULL, NULL);\n        handle_id3(&id3ioctx, pls);\n    }\n\n    if (pls->is_id3_timestamped == -1)\n        pls->is_id3_timestamped = (pls->id3_mpegts_timestamp != AV_NOPTS_VALUE);\n}\n\nstatic int open_input(HLSContext *c, struct playlist *pls, struct segment *seg)\n{\n    AVDictionary *opts = NULL;\n    int ret;\n    int is_http = 0;\n\n    // broker prior HTTP options that should be consistent across requests\n    av_dict_set(&opts, \"user_agent\", c->user_agent, 0);\n    av_dict_set(&opts, \"cookies\", c->cookies, 0);\n    av_dict_set(&opts, \"headers\", c->headers, 0);\n    av_dict_set(&opts, \"http_proxy\", c->http_proxy, 0);\n    av_dict_set(&opts, \"seekable\", \"0\", 0);\n\n    if (seg->size >= 0) {\n        /* try to restrict the HTTP request to the part we want\n         * (if this is in fact a HTTP request) */\n        av_dict_set_int(&opts, \"offset\", seg->url_offset, 0);\n        av_dict_set_int(&opts, \"end_offset\", seg->url_offset + seg->size, 0);\n    }\n\n    av_log(pls->parent, AV_LOG_VERBOSE, \"HLS request for url '%s', offset %\"PRId64\", playlist %d\\n\",\n           seg->url, seg->url_offset, pls->index);\n\n    if (seg->key_type == KEY_NONE) {\n        ret = open_url(pls->parent, &pls->input, seg->url, c->avio_opts, opts, &is_http);\n    } else if (seg->key_type == KEY_AES_128) {\n        AVDictionary *opts2 = NULL;\n        char iv[33], key[33], url[MAX_URL_SIZE];\n        if (strcmp(seg->key, pls->key_url)) {\n            AVIOContext *pb;\n            if (open_url(pls->parent, &pb, seg->key, c->avio_opts, opts, NULL) == 0) {\n                ret = avio_read(pb, pls->key, sizeof(pls->key));\n                if (ret != sizeof(pls->key)) {\n                    av_log(NULL, AV_LOG_ERROR, \"Unable to read key file %s\\n\",\n                           seg->key);\n                }\n                ff_format_io_close(pls->parent, &pb);\n            } else {\n                av_log(NULL, AV_LOG_ERROR, \"Unable to open key file %s\\n\",\n                       seg->key);\n            }\n            av_strlcpy(pls->key_url, seg->key, sizeof(pls->key_url));\n        }\n        ff_data_to_hex(iv, seg->iv, sizeof(seg->iv), 0);\n        ff_data_to_hex(key, pls->key, sizeof(pls->key), 0);\n        iv[32] = key[32] = '\\0';\n        if (strstr(seg->url, \"://\"))\n            snprintf(url, sizeof(url), \"crypto+%s\", seg->url);\n        else\n            snprintf(url, sizeof(url), \"crypto:%s\", seg->url);\n\n        av_dict_copy(&opts2, c->avio_opts, 0);\n        av_dict_set(&opts2, \"key\", key, 0);\n        av_dict_set(&opts2, \"iv\", iv, 0);\n\n        ret = open_url(pls->parent, &pls->input, url, opts2, opts, &is_http);\n\n        av_dict_free(&opts2);\n\n        if (ret < 0) {\n            goto cleanup;\n        }\n        ret = 0;\n    } else if (seg->key_type == KEY_SAMPLE_AES) {\n        av_log(pls->parent, AV_LOG_ERROR,\n               \"SAMPLE-AES encryption is not supported yet\\n\");\n        ret = AVERROR_PATCHWELCOME;\n    }\n    else\n      ret = AVERROR(ENOSYS);\n\n    /* Seek to the requested position. If this was a HTTP request, the offset\n     * should already be where want it to, but this allows e.g. local testing\n     * without a HTTP server.\n     *\n     * This is not done for HTTP at all as avio_seek() does internal bookkeeping\n     * of file offset which is out-of-sync with the actual offset when \"offset\"\n     * AVOption is used with http protocol, causing the seek to not be a no-op\n     * as would be expected. Wrong offset received from the server will not be\n     * noticed without the call, though.\n     */\n    if (ret == 0 && !is_http && seg->key_type == KEY_NONE && seg->url_offset) {\n        int64_t seekret = avio_seek(pls->input, seg->url_offset, SEEK_SET);\n        if (seekret < 0) {\n            av_log(pls->parent, AV_LOG_ERROR, \"Unable to seek to offset %\"PRId64\" of HLS segment '%s'\\n\", seg->url_offset, seg->url);\n            ret = seekret;\n            ff_format_io_close(pls->parent, &pls->input);\n        }\n    }\n\ncleanup:\n    av_dict_free(&opts);\n    pls->cur_seg_offset = 0;\n    return ret;\n}\n\nstatic int update_init_section(struct playlist *pls, struct segment *seg)\n{\n    static const int max_init_section_size = 1024*1024;\n    HLSContext *c = pls->parent->priv_data;\n    int64_t sec_size;\n    int64_t urlsize;\n    int ret;\n\n    if (seg->init_section == pls->cur_init_section)\n        return 0;\n\n    pls->cur_init_section = NULL;\n\n    if (!seg->init_section)\n        return 0;\n\n    ret = open_input(c, pls, seg->init_section);\n    if (ret < 0) {\n        av_log(pls->parent, AV_LOG_WARNING,\n               \"Failed to open an initialization section in playlist %d\\n\",\n               pls->index);\n        return ret;\n    }\n\n    if (seg->init_section->size >= 0)\n        sec_size = seg->init_section->size;\n    else if ((urlsize = avio_size(pls->input)) >= 0)\n        sec_size = urlsize;\n    else\n        sec_size = max_init_section_size;\n\n    av_log(pls->parent, AV_LOG_DEBUG,\n           \"Downloading an initialization section of size %\"PRId64\"\\n\",\n           sec_size);\n\n    sec_size = FFMIN(sec_size, max_init_section_size);\n\n    av_fast_malloc(&pls->init_sec_buf, &pls->init_sec_buf_size, sec_size);\n\n    ret = read_from_url(pls, seg->init_section, pls->init_sec_buf,\n                        pls->init_sec_buf_size, READ_COMPLETE);\n    ff_format_io_close(pls->parent, &pls->input);\n\n    if (ret < 0)\n        return ret;\n\n    pls->cur_init_section = seg->init_section;\n    pls->init_sec_data_len = ret;\n    pls->init_sec_buf_read_offset = 0;\n\n    /* spec says audio elementary streams do not have media initialization\n     * sections, so there should be no ID3 timestamps */\n    pls->is_id3_timestamped = 0;\n\n    return 0;\n}\n\nstatic int64_t default_reload_interval(struct playlist *pls)\n{\n    return pls->n_segments > 0 ?\n                          pls->segments[pls->n_segments - 1]->duration :\n                          pls->target_duration;\n}\n\nstatic int read_data(void *opaque, uint8_t *buf, int buf_size)\n{\n    struct playlist *v = opaque;\n    HLSContext *c = v->parent->priv_data;\n    int ret, i;\n    int just_opened = 0;\n\nrestart:\n    if (!v->needed)\n        return AVERROR_EOF;\n\n    if (!v->input) {\n        int64_t reload_interval;\n        struct segment *seg;\n\n        /* Check that the playlist is still needed before opening a new\n         * segment. */\n        if (v->ctx && v->ctx->nb_streams) {\n            v->needed = 0;\n            for (i = 0; i < v->n_main_streams; i++) {\n                if (v->main_streams[i]->discard < AVDISCARD_ALL) {\n                    v->needed = 1;\n                    break;\n                }\n            }\n        }\n        if (!v->needed) {\n            av_log(v->parent, AV_LOG_INFO, \"No longer receiving playlist %d\\n\",\n                v->index);\n            return AVERROR_EOF;\n        }\n\n        /* If this is a live stream and the reload interval has elapsed since\n         * the last playlist reload, reload the playlists now. */\n        reload_interval = default_reload_interval(v);\n\nreload:\n        if (!v->finished &&\n            av_gettime_relative() - v->last_load_time >= reload_interval) {\n            if ((ret = parse_playlist(c, v->url, v, NULL)) < 0) {\n                av_log(v->parent, AV_LOG_WARNING, \"Failed to reload playlist %d\\n\",\n                       v->index);\n                return ret;\n            }\n            /* If we need to reload the playlist again below (if\n             * there's still no more segments), switch to a reload\n             * interval of half the target duration. */\n            reload_interval = v->target_duration / 2;\n        }\n        if (v->cur_seq_no < v->start_seq_no) {\n            av_log(NULL, AV_LOG_WARNING,\n                   \"skipping %d segments ahead, expired from playlists\\n\",\n                   v->start_seq_no - v->cur_seq_no);\n            v->cur_seq_no = v->start_seq_no;\n        }\n        if (v->cur_seq_no >= v->start_seq_no + v->n_segments) {\n            if (v->finished)\n                return AVERROR_EOF;\n            while (av_gettime_relative() - v->last_load_time < reload_interval) {\n                if (ff_check_interrupt(c->interrupt_callback))\n                    return AVERROR_EXIT;\n                av_usleep(100*1000);\n            }\n            /* Enough time has elapsed since the last reload */\n            goto reload;\n        }\n\n        seg = current_segment(v);\n\n        /* load/update Media Initialization Section, if any */\n        ret = update_init_section(v, seg);\n        if (ret)\n            return ret;\n\n        ret = open_input(c, v, seg);\n        if (ret < 0) {\n            if (ff_check_interrupt(c->interrupt_callback))\n                return AVERROR_EXIT;\n            av_log(v->parent, AV_LOG_WARNING, \"Failed to open segment of playlist %d\\n\",\n                   v->index);\n            v->cur_seq_no += 1;\n            goto reload;\n        }\n        just_opened = 1;\n    }\n\n    if (v->init_sec_buf_read_offset < v->init_sec_data_len) {\n        /* Push init section out first before first actual segment */\n        int copy_size = FFMIN(v->init_sec_data_len - v->init_sec_buf_read_offset, buf_size);\n        memcpy(buf, v->init_sec_buf, copy_size);\n        v->init_sec_buf_read_offset += copy_size;\n        return copy_size;\n    }\n\n    ret = read_from_url(v, current_segment(v), buf, buf_size, READ_NORMAL);\n    if (ret > 0) {\n        if (just_opened && v->is_id3_timestamped != 0) {\n            /* Intercept ID3 tags here, elementary audio streams are required\n             * to convey timestamps using them in the beginning of each segment. */\n            intercept_id3(v, buf, buf_size, &ret);\n        }\n\n        return ret;\n    }\n    ff_format_io_close(v->parent, &v->input);\n    v->cur_seq_no++;\n\n    c->cur_seq_no = v->cur_seq_no;\n\n    goto restart;\n}\n\nstatic void add_renditions_to_variant(HLSContext *c, struct variant *var,\n                                      enum AVMediaType type, const char *group_id)\n{\n    int i;\n\n    for (i = 0; i < c->n_renditions; i++) {\n        struct rendition *rend = c->renditions[i];\n\n        if (rend->type == type && !strcmp(rend->group_id, group_id)) {\n\n            if (rend->playlist)\n                /* rendition is an external playlist\n                 * => add the playlist to the variant */\n                dynarray_add(&var->playlists, &var->n_playlists, rend->playlist);\n            else\n                /* rendition is part of the variant main Media Playlist\n                 * => add the rendition to the main Media Playlist */\n                dynarray_add(&var->playlists[0]->renditions,\n                             &var->playlists[0]->n_renditions,\n                             rend);\n        }\n    }\n}\n\nstatic void add_metadata_from_renditions(AVFormatContext *s, struct playlist *pls,\n                                         enum AVMediaType type)\n{\n    int rend_idx = 0;\n    int i;\n\n    for (i = 0; i < pls->n_main_streams; i++) {\n        AVStream *st = pls->main_streams[i];\n\n        if (st->codecpar->codec_type != type)\n            continue;\n\n        for (; rend_idx < pls->n_renditions; rend_idx++) {\n            struct rendition *rend = pls->renditions[rend_idx];\n\n            if (rend->type != type)\n                continue;\n\n            if (rend->language[0])\n                av_dict_set(&st->metadata, \"language\", rend->language, 0);\n            if (rend->name[0])\n                av_dict_set(&st->metadata, \"comment\", rend->name, 0);\n\n            st->disposition |= rend->disposition;\n        }\n        if (rend_idx >=pls->n_renditions)\n            break;\n    }\n}\n\n/* if timestamp was in valid range: returns 1 and sets seq_no\n * if not: returns 0 and sets seq_no to closest segment */\nstatic int find_timestamp_in_playlist(HLSContext *c, struct playlist *pls,\n                                      int64_t timestamp, int *seq_no)\n{\n    int i;\n    int64_t pos = c->first_timestamp == AV_NOPTS_VALUE ?\n                  0 : c->first_timestamp;\n\n    if (timestamp < pos) {\n        *seq_no = pls->start_seq_no;\n        return 0;\n    }\n\n    for (i = 0; i < pls->n_segments; i++) {\n        int64_t diff = pos + pls->segments[i]->duration - timestamp;\n        if (diff > 0) {\n            *seq_no = pls->start_seq_no + i;\n            return 1;\n        }\n        pos += pls->segments[i]->duration;\n    }\n\n    *seq_no = pls->start_seq_no + pls->n_segments - 1;\n\n    return 0;\n}\n\nstatic int select_cur_seq_no(HLSContext *c, struct playlist *pls)\n{\n    int seq_no;\n\n    if (!pls->finished && !c->first_packet &&\n        av_gettime_relative() - pls->last_load_time >= default_reload_interval(pls))\n        /* reload the playlist since it was suspended */\n        parse_playlist(c, pls->url, pls, NULL);\n\n    /* If playback is already in progress (we are just selecting a new\n     * playlist) and this is a complete file, find the matching segment\n     * by counting durations. */\n    if (pls->finished && c->cur_timestamp != AV_NOPTS_VALUE) {\n        find_timestamp_in_playlist(c, pls, c->cur_timestamp, &seq_no);\n        return seq_no;\n    }\n\n    if (!pls->finished) {\n        if (!c->first_packet && /* we are doing a segment selection during playback */\n            c->cur_seq_no >= pls->start_seq_no &&\n            c->cur_seq_no < pls->start_seq_no + pls->n_segments)\n            /* While spec 3.4.3 says that we cannot assume anything about the\n             * content at the same sequence number on different playlists,\n             * in practice this seems to work and doing it otherwise would\n             * require us to download a segment to inspect its timestamps. */\n            return c->cur_seq_no;\n\n        /* If this is a live stream, start live_start_index segments from the\n         * start or end */\n        if (c->live_start_index < 0)\n            return pls->start_seq_no + FFMAX(pls->n_segments + c->live_start_index, 0);\n        else\n            return pls->start_seq_no + FFMIN(c->live_start_index, pls->n_segments - 1);\n    }\n\n    /* Otherwise just start on the first segment. */\n    return pls->start_seq_no;\n}\n\nstatic int save_avio_options(AVFormatContext *s)\n{\n    HLSContext *c = s->priv_data;\n    static const char *opts[] = {\n        \"headers\", \"http_proxy\", \"user_agent\", \"user-agent\", \"cookies\", NULL };\n    const char **opt = opts;\n    uint8_t *buf;\n    int ret = 0;\n\n    while (*opt) {\n        if (av_opt_get(s->pb, *opt, AV_OPT_SEARCH_CHILDREN | AV_OPT_ALLOW_NULL, &buf) >= 0) {\n            ret = av_dict_set(&c->avio_opts, *opt, buf,\n                              AV_DICT_DONT_STRDUP_VAL);\n            if (ret < 0)\n                return ret;\n        }\n        opt++;\n    }\n\n    return ret;\n}\n\nstatic int nested_io_open(AVFormatContext *s, AVIOContext **pb, const char *url,\n                          int flags, AVDictionary **opts)\n{\n    av_log(s, AV_LOG_ERROR,\n           \"A HLS playlist item '%s' referred to an external file '%s'. \"\n           \"Opening this file was forbidden for security reasons\\n\",\n           s->filename, url);\n    return AVERROR(EPERM);\n}\n\nstatic void add_stream_to_programs(AVFormatContext *s, struct playlist *pls, AVStream *stream)\n{\n    HLSContext *c = s->priv_data;\n    int i, j;\n    int bandwidth = -1;\n\n    for (i = 0; i < c->n_variants; i++) {\n        struct variant *v = c->variants[i];\n\n        for (j = 0; j < v->n_playlists; j++) {\n            if (v->playlists[j] != pls)\n                continue;\n\n            av_program_add_stream_index(s, i, stream->index);\n\n            if (bandwidth < 0)\n                bandwidth = v->bandwidth;\n            else if (bandwidth != v->bandwidth)\n                bandwidth = -1; /* stream in multiple variants with different bandwidths */\n        }\n    }\n\n    if (bandwidth >= 0)\n        av_dict_set_int(&stream->metadata, \"variant_bitrate\", bandwidth, 0);\n}\n\nstatic int set_stream_info_from_input_stream(AVStream *st, struct playlist *pls, AVStream *ist)\n{\n    int err;\n\n    err = avcodec_parameters_copy(st->codecpar, ist->codecpar);\n    if (err < 0)\n        return err;\n\n    if (pls->is_id3_timestamped) /* custom timestamps via id3 */\n        avpriv_set_pts_info(st, 33, 1, MPEG_TIME_BASE);\n    else\n        avpriv_set_pts_info(st, ist->pts_wrap_bits, ist->time_base.num, ist->time_base.den);\n\n    st->internal->need_context_update = 1;\n\n    return 0;\n}\n\n/* add new subdemuxer streams to our context, if any */\nstatic int update_streams_from_subdemuxer(AVFormatContext *s, struct playlist *pls)\n{\n    int err;\n\n    while (pls->n_main_streams < pls->ctx->nb_streams) {\n        int ist_idx = pls->n_main_streams;\n        AVStream *st = avformat_new_stream(s, NULL);\n        AVStream *ist = pls->ctx->streams[ist_idx];\n\n        if (!st)\n            return AVERROR(ENOMEM);\n\n        st->id = pls->index;\n        dynarray_add(&pls->main_streams, &pls->n_main_streams, st);\n\n        add_stream_to_programs(s, pls, st);\n\n        err = set_stream_info_from_input_stream(st, pls, ist);\n        if (err < 0)\n            return err;\n    }\n\n    return 0;\n}\n\nstatic void update_noheader_flag(AVFormatContext *s)\n{\n    HLSContext *c = s->priv_data;\n    int flag_needed = 0;\n    int i;\n\n    for (i = 0; i < c->n_playlists; i++) {\n        struct playlist *pls = c->playlists[i];\n\n        if (pls->has_noheader_flag) {\n            flag_needed = 1;\n            break;\n        }\n    }\n\n    if (flag_needed)\n        s->ctx_flags |= AVFMTCTX_NOHEADER;\n    else\n        s->ctx_flags &= ~AVFMTCTX_NOHEADER;\n}\n\nstatic int hls_close(AVFormatContext *s)\n{\n    HLSContext *c = s->priv_data;\n\n    free_playlist_list(c);\n    free_variant_list(c);\n    free_rendition_list(c);\n\n    av_dict_free(&c->avio_opts);\n\n    return 0;\n}\n\nstatic int hls_read_header(AVFormatContext *s)\n{\n    void *u = (s->flags & AVFMT_FLAG_CUSTOM_IO) ? NULL : s->pb;\n    HLSContext *c = s->priv_data;\n    int ret = 0, i;\n    int highest_cur_seq_no = 0;\n\n    c->ctx                = s;\n    c->interrupt_callback = &s->interrupt_callback;\n    c->strict_std_compliance = s->strict_std_compliance;\n\n    c->first_packet = 1;\n    c->first_timestamp = AV_NOPTS_VALUE;\n    c->cur_timestamp = AV_NOPTS_VALUE;\n\n    if (u) {\n        // get the previous user agent & set back to null if string size is zero\n        update_options(&c->user_agent, \"user_agent\", u);\n\n        // get the previous cookies & set back to null if string size is zero\n        update_options(&c->cookies, \"cookies\", u);\n\n        // get the previous headers & set back to null if string size is zero\n        update_options(&c->headers, \"headers\", u);\n\n        // get the previous http proxt & set back to null if string size is zero\n        update_options(&c->http_proxy, \"http_proxy\", u);\n    }\n\n    if ((ret = parse_playlist(c, s->filename, NULL, s->pb)) < 0)\n        goto fail;\n\n    if ((ret = save_avio_options(s)) < 0)\n        goto fail;\n\n    /* Some HLS servers don't like being sent the range header */\n    av_dict_set(&c->avio_opts, \"seekable\", \"0\", 0);\n\n    if (c->n_variants == 0) {\n        av_log(NULL, AV_LOG_WARNING, \"Empty playlist\\n\");\n        ret = AVERROR_EOF;\n        goto fail;\n    }\n    /* If the playlist only contained playlists (Master Playlist),\n     * parse each individual playlist. */\n    if (c->n_playlists > 1 || c->playlists[0]->n_segments == 0) {\n        for (i = 0; i < c->n_playlists; i++) {\n            struct playlist *pls = c->playlists[i];\n            if ((ret = parse_playlist(c, pls->url, pls, NULL)) < 0)\n                goto fail;\n        }\n    }\n\n    if (c->variants[0]->playlists[0]->n_segments == 0) {\n        av_log(NULL, AV_LOG_WARNING, \"Empty playlist\\n\");\n        ret = AVERROR_EOF;\n        goto fail;\n    }\n\n    /* If this isn't a live stream, calculate the total duration of the\n     * stream. */\n    if (c->variants[0]->playlists[0]->finished) {\n        int64_t duration = 0;\n        for (i = 0; i < c->variants[0]->playlists[0]->n_segments; i++)\n            duration += c->variants[0]->playlists[0]->segments[i]->duration;\n        s->duration = duration;\n    }\n\n    /* Associate renditions with variants */\n    for (i = 0; i < c->n_variants; i++) {\n        struct variant *var = c->variants[i];\n\n        if (var->audio_group[0])\n            add_renditions_to_variant(c, var, AVMEDIA_TYPE_AUDIO, var->audio_group);\n        if (var->video_group[0])\n            add_renditions_to_variant(c, var, AVMEDIA_TYPE_VIDEO, var->video_group);\n        if (var->subtitles_group[0])\n            add_renditions_to_variant(c, var, AVMEDIA_TYPE_SUBTITLE, var->subtitles_group);\n    }\n\n    /* Create a program for each variant */\n    for (i = 0; i < c->n_variants; i++) {\n        struct variant *v = c->variants[i];\n        AVProgram *program;\n\n        program = av_new_program(s, i);\n        if (!program)\n            goto fail;\n        av_dict_set_int(&program->metadata, \"variant_bitrate\", v->bandwidth, 0);\n    }\n\n    /* Select the starting segments */\n    for (i = 0; i < c->n_playlists; i++) {\n        struct playlist *pls = c->playlists[i];\n\n        if (pls->n_segments == 0)\n            continue;\n\n        pls->cur_seq_no = select_cur_seq_no(c, pls);\n        highest_cur_seq_no = FFMAX(highest_cur_seq_no, pls->cur_seq_no);\n    }\n\n    /* Open the demuxer for each playlist */\n    for (i = 0; i < c->n_playlists; i++) {\n        struct playlist *pls = c->playlists[i];\n        AVInputFormat *in_fmt = NULL;\n\n        if (!(pls->ctx = avformat_alloc_context())) {\n            ret = AVERROR(ENOMEM);\n            goto fail;\n        }\n\n        if (pls->n_segments == 0)\n            continue;\n\n        pls->index  = i;\n        pls->needed = 1;\n        pls->parent = s;\n\n        /*\n         * If this is a live stream and this playlist looks like it is one segment\n         * behind, try to sync it up so that every substream starts at the same\n         * time position (so e.g. avformat_find_stream_info() will see packets from\n         * all active streams within the first few seconds). This is not very generic,\n         * though, as the sequence numbers are technically independent.\n         */\n        if (!pls->finished && pls->cur_seq_no == highest_cur_seq_no - 1 &&\n            highest_cur_seq_no < pls->start_seq_no + pls->n_segments) {\n            pls->cur_seq_no = highest_cur_seq_no;\n        }\n\n        pls->read_buffer = av_malloc(INITIAL_BUFFER_SIZE);\n        if (!pls->read_buffer){\n            ret = AVERROR(ENOMEM);\n            avformat_free_context(pls->ctx);\n            pls->ctx = NULL;\n            goto fail;\n        }\n        ffio_init_context(&pls->pb, pls->read_buffer, INITIAL_BUFFER_SIZE, 0, pls,\n                          read_data, NULL, NULL);\n        pls->pb.seekable = 0;\n        ret = av_probe_input_buffer(&pls->pb, &in_fmt, pls->segments[0]->url,\n                                    NULL, 0, 0);\n        if (ret < 0) {\n            /* Free the ctx - it isn't initialized properly at this point,\n             * so avformat_close_input shouldn't be called. If\n             * avformat_open_input fails below, it frees and zeros the\n             * context, so it doesn't need any special treatment like this. */\n            av_log(s, AV_LOG_ERROR, \"Error when loading first segment '%s'\\n\", pls->segments[0]->url);\n            avformat_free_context(pls->ctx);\n            pls->ctx = NULL;\n            goto fail;\n        }\n        pls->ctx->pb       = &pls->pb;\n        pls->ctx->io_open  = nested_io_open;\n        pls->ctx->flags   |= s->flags & ~AVFMT_FLAG_CUSTOM_IO;\n\n        if ((ret = ff_copy_whiteblacklists(pls->ctx, s)) < 0)\n            goto fail;\n\n        ret = avformat_open_input(&pls->ctx, pls->segments[0]->url, in_fmt, NULL);\n        if (ret < 0)\n            goto fail;\n\n        if (pls->id3_deferred_extra && pls->ctx->nb_streams == 1) {\n            ff_id3v2_parse_apic(pls->ctx, &pls->id3_deferred_extra);\n            avformat_queue_attached_pictures(pls->ctx);\n            ff_id3v2_free_extra_meta(&pls->id3_deferred_extra);\n            pls->id3_deferred_extra = NULL;\n        }\n\n        if (pls->is_id3_timestamped == -1)\n            av_log(s, AV_LOG_WARNING, \"No expected HTTP requests have been made\\n\");\n\n        /*\n         * For ID3 timestamped raw audio streams we need to detect the packet\n         * durations to calculate timestamps in fill_timing_for_id3_timestamped_stream(),\n         * but for other streams we can rely on our user calling avformat_find_stream_info()\n         * on us if they want to.\n         */\n        if (pls->is_id3_timestamped) {\n            ret = avformat_find_stream_info(pls->ctx, NULL);\n            if (ret < 0)\n                goto fail;\n        }\n\n        pls->has_noheader_flag = !!(pls->ctx->ctx_flags & AVFMTCTX_NOHEADER);\n\n        /* Create new AVStreams for each stream in this playlist */\n        ret = update_streams_from_subdemuxer(s, pls);\n        if (ret < 0)\n            goto fail;\n\n        add_metadata_from_renditions(s, pls, AVMEDIA_TYPE_AUDIO);\n        add_metadata_from_renditions(s, pls, AVMEDIA_TYPE_VIDEO);\n        add_metadata_from_renditions(s, pls, AVMEDIA_TYPE_SUBTITLE);\n    }\n\n    update_noheader_flag(s);\n\n    return 0;\nfail:\n    hls_close(s);\n    return ret;\n}\n\nstatic int recheck_discard_flags(AVFormatContext *s, int first)\n{\n    HLSContext *c = s->priv_data;\n    int i, changed = 0;\n\n    /* Check if any new streams are needed */\n    for (i = 0; i < c->n_playlists; i++)\n        c->playlists[i]->cur_needed = 0;\n\n    for (i = 0; i < s->nb_streams; i++) {\n        AVStream *st = s->streams[i];\n        struct playlist *pls = c->playlists[s->streams[i]->id];\n        if (st->discard < AVDISCARD_ALL)\n            pls->cur_needed = 1;\n    }\n    for (i = 0; i < c->n_playlists; i++) {\n        struct playlist *pls = c->playlists[i];\n        if (pls->cur_needed && !pls->needed) {\n            pls->needed = 1;\n            changed = 1;\n            pls->cur_seq_no = select_cur_seq_no(c, pls);\n            pls->pb.eof_reached = 0;\n            if (c->cur_timestamp != AV_NOPTS_VALUE) {\n                /* catch up */\n                pls->seek_timestamp = c->cur_timestamp;\n                pls->seek_flags = AVSEEK_FLAG_ANY;\n                pls->seek_stream_index = -1;\n            }\n            av_log(s, AV_LOG_INFO, \"Now receiving playlist %d, segment %d\\n\", i, pls->cur_seq_no);\n        } else if (first && !pls->cur_needed && pls->needed) {\n            if (pls->input)\n                ff_format_io_close(pls->parent, &pls->input);\n            pls->needed = 0;\n            changed = 1;\n            av_log(s, AV_LOG_INFO, \"No longer receiving playlist %d\\n\", i);\n        }\n    }\n    return changed;\n}\n\nstatic void fill_timing_for_id3_timestamped_stream(struct playlist *pls)\n{\n    if (pls->id3_offset >= 0) {\n        pls->pkt.dts = pls->id3_mpegts_timestamp +\n                                 av_rescale_q(pls->id3_offset,\n                                              pls->ctx->streams[pls->pkt.stream_index]->time_base,\n                                              MPEG_TIME_BASE_Q);\n        if (pls->pkt.duration)\n            pls->id3_offset += pls->pkt.duration;\n        else\n            pls->id3_offset = -1;\n    } else {\n        /* there have been packets with unknown duration\n         * since the last id3 tag, should not normally happen */\n        pls->pkt.dts = AV_NOPTS_VALUE;\n    }\n\n    if (pls->pkt.duration)\n        pls->pkt.duration = av_rescale_q(pls->pkt.duration,\n                                         pls->ctx->streams[pls->pkt.stream_index]->time_base,\n                                         MPEG_TIME_BASE_Q);\n\n    pls->pkt.pts = AV_NOPTS_VALUE;\n}\n\nstatic AVRational get_timebase(struct playlist *pls)\n{\n    if (pls->is_id3_timestamped)\n        return MPEG_TIME_BASE_Q;\n\n    return pls->ctx->streams[pls->pkt.stream_index]->time_base;\n}\n\nstatic int compare_ts_with_wrapdetect(int64_t ts_a, struct playlist *pls_a,\n                                      int64_t ts_b, struct playlist *pls_b)\n{\n    int64_t scaled_ts_a = av_rescale_q(ts_a, get_timebase(pls_a), MPEG_TIME_BASE_Q);\n    int64_t scaled_ts_b = av_rescale_q(ts_b, get_timebase(pls_b), MPEG_TIME_BASE_Q);\n\n    return av_compare_mod(scaled_ts_a, scaled_ts_b, 1LL << 33);\n}\n\nstatic int hls_read_packet(AVFormatContext *s, AVPacket *pkt)\n{\n    HLSContext *c = s->priv_data;\n    int ret, i, minplaylist = -1;\n\n    recheck_discard_flags(s, c->first_packet);\n    c->first_packet = 0;\n\n    for (i = 0; i < c->n_playlists; i++) {\n        struct playlist *pls = c->playlists[i];\n        /* Make sure we've got one buffered packet from each open playlist\n         * stream */\n        if (pls->needed && !pls->pkt.data) {\n            while (1) {\n                int64_t ts_diff;\n                AVRational tb;\n                ret = av_read_frame(pls->ctx, &pls->pkt);\n                if (ret < 0) {\n                    if (!avio_feof(&pls->pb) && ret != AVERROR_EOF)\n                        return ret;\n                    reset_packet(&pls->pkt);\n                    break;\n                } else {\n                    /* stream_index check prevents matching picture attachments etc. */\n                    if (pls->is_id3_timestamped && pls->pkt.stream_index == 0) {\n                        /* audio elementary streams are id3 timestamped */\n                        fill_timing_for_id3_timestamped_stream(pls);\n                    }\n\n                    if (c->first_timestamp == AV_NOPTS_VALUE &&\n                        pls->pkt.dts       != AV_NOPTS_VALUE)\n                        c->first_timestamp = av_rescale_q(pls->pkt.dts,\n                            get_timebase(pls), AV_TIME_BASE_Q);\n                }\n\n                if (pls->seek_timestamp == AV_NOPTS_VALUE)\n                    break;\n\n                if (pls->seek_stream_index < 0 ||\n                    pls->seek_stream_index == pls->pkt.stream_index) {\n\n                    if (pls->pkt.dts == AV_NOPTS_VALUE) {\n                        pls->seek_timestamp = AV_NOPTS_VALUE;\n                        break;\n                    }\n\n                    tb = get_timebase(pls);\n                    ts_diff = av_rescale_rnd(pls->pkt.dts, AV_TIME_BASE,\n                                            tb.den, AV_ROUND_DOWN) -\n                            pls->seek_timestamp;\n                    if (ts_diff >= 0 && (pls->seek_flags  & AVSEEK_FLAG_ANY ||\n                                        pls->pkt.flags & AV_PKT_FLAG_KEY)) {\n                        pls->seek_timestamp = AV_NOPTS_VALUE;\n                        break;\n                    }\n                }\n                av_packet_unref(&pls->pkt);\n                reset_packet(&pls->pkt);\n            }\n        }\n        /* Check if this stream has the packet with the lowest dts */\n        if (pls->pkt.data) {\n            struct playlist *minpls = minplaylist < 0 ?\n                                     NULL : c->playlists[minplaylist];\n            if (minplaylist < 0) {\n                minplaylist = i;\n            } else {\n                int64_t dts     =    pls->pkt.dts;\n                int64_t mindts  = minpls->pkt.dts;\n\n                if (dts == AV_NOPTS_VALUE ||\n                    (mindts != AV_NOPTS_VALUE && compare_ts_with_wrapdetect(dts, pls, mindts, minpls) < 0))\n                    minplaylist = i;\n            }\n        }\n    }\n\n    /* If we got a packet, return it */\n    if (minplaylist >= 0) {\n        struct playlist *pls = c->playlists[minplaylist];\n        AVStream *ist;\n        AVStream *st;\n\n        ret = update_streams_from_subdemuxer(s, pls);\n        if (ret < 0) {\n            av_packet_unref(&pls->pkt);\n            reset_packet(&pls->pkt);\n            return ret;\n        }\n\n        /* check if noheader flag has been cleared by the subdemuxer */\n        if (pls->has_noheader_flag && !(pls->ctx->ctx_flags & AVFMTCTX_NOHEADER)) {\n            pls->has_noheader_flag = 0;\n            update_noheader_flag(s);\n        }\n\n        if (pls->pkt.stream_index >= pls->n_main_streams) {\n            av_log(s, AV_LOG_ERROR, \"stream index inconsistency: index %d, %d main streams, %d subdemuxer streams\\n\",\n                   pls->pkt.stream_index, pls->n_main_streams, pls->ctx->nb_streams);\n            av_packet_unref(&pls->pkt);\n            reset_packet(&pls->pkt);\n            return AVERROR_BUG;\n        }\n\n        ist = pls->ctx->streams[pls->pkt.stream_index];\n        st = pls->main_streams[pls->pkt.stream_index];\n\n        *pkt = pls->pkt;\n        pkt->stream_index = st->index;\n        reset_packet(&c->playlists[minplaylist]->pkt);\n\n        if (pkt->dts != AV_NOPTS_VALUE)\n            c->cur_timestamp = av_rescale_q(pkt->dts,\n                                            ist->time_base,\n                                            AV_TIME_BASE_Q);\n\n        /* There may be more situations where this would be useful, but this at least\n         * handles newly probed codecs properly (i.e. request_probe by mpegts). */\n        if (ist->codecpar->codec_id != st->codecpar->codec_id) {\n            ret = set_stream_info_from_input_stream(st, pls, ist);\n            if (ret < 0) {\n                av_packet_unref(pkt);\n                return ret;\n            }\n        }\n\n        return 0;\n    }\n    return AVERROR_EOF;\n}\n\nstatic int hls_read_seek(AVFormatContext *s, int stream_index,\n                               int64_t timestamp, int flags)\n{\n    HLSContext *c = s->priv_data;\n    struct playlist *seek_pls = NULL;\n    int i, seq_no;\n    int j;\n    int stream_subdemuxer_index;\n    int64_t first_timestamp, seek_timestamp, duration;\n\n    if ((flags & AVSEEK_FLAG_BYTE) ||\n        !(c->variants[0]->playlists[0]->finished || c->variants[0]->playlists[0]->type == PLS_TYPE_EVENT))\n        return AVERROR(ENOSYS);\n\n    first_timestamp = c->first_timestamp == AV_NOPTS_VALUE ?\n                      0 : c->first_timestamp;\n\n    seek_timestamp = av_rescale_rnd(timestamp, AV_TIME_BASE,\n                                    s->streams[stream_index]->time_base.den,\n                                    flags & AVSEEK_FLAG_BACKWARD ?\n                                    AV_ROUND_DOWN : AV_ROUND_UP);\n\n    duration = s->duration == AV_NOPTS_VALUE ?\n               0 : s->duration;\n\n    if (0 < duration && duration < seek_timestamp - first_timestamp)\n        return AVERROR(EIO);\n\n    /* find the playlist with the specified stream */\n    for (i = 0; i < c->n_playlists; i++) {\n        struct playlist *pls = c->playlists[i];\n        for (j = 0; j < pls->n_main_streams; j++) {\n            if (pls->main_streams[j] == s->streams[stream_index]) {\n                seek_pls = pls;\n                stream_subdemuxer_index = j;\n                break;\n            }\n        }\n    }\n    /* check if the timestamp is valid for the playlist with the\n     * specified stream index */\n    if (!seek_pls || !find_timestamp_in_playlist(c, seek_pls, seek_timestamp, &seq_no))\n        return AVERROR(EIO);\n\n    /* set segment now so we do not need to search again below */\n    seek_pls->cur_seq_no = seq_no;\n    seek_pls->seek_stream_index = stream_subdemuxer_index;\n\n    for (i = 0; i < c->n_playlists; i++) {\n        /* Reset reading */\n        struct playlist *pls = c->playlists[i];\n        if (pls->input)\n            ff_format_io_close(pls->parent, &pls->input);\n        av_packet_unref(&pls->pkt);\n        reset_packet(&pls->pkt);\n        pls->pb.eof_reached = 0;\n        /* Clear any buffered data */\n        pls->pb.buf_end = pls->pb.buf_ptr = pls->pb.buffer;\n        /* Reset the pos, to let the mpegts demuxer know we've seeked. */\n        pls->pb.pos = 0;\n        /* Flush the packet queue of the subdemuxer. */\n        ff_read_frame_flush(pls->ctx);\n\n        pls->seek_timestamp = seek_timestamp;\n        pls->seek_flags = flags;\n\n        if (pls != seek_pls) {\n            /* set closest segment seq_no for playlists not handled above */\n            find_timestamp_in_playlist(c, pls, seek_timestamp, &pls->cur_seq_no);\n            /* seek the playlist to the given position without taking\n             * keyframes into account since this playlist does not have the\n             * specified stream where we should look for the keyframes */\n            pls->seek_stream_index = -1;\n            pls->seek_flags |= AVSEEK_FLAG_ANY;\n        }\n    }\n\n    c->cur_timestamp = seek_timestamp;\n\n    return 0;\n}\n\nstatic int hls_probe(AVProbeData *p)\n{\n    /* Require #EXTM3U at the start, and either one of the ones below\n     * somewhere for a proper match. */\n    if (strncmp(p->buf, \"#EXTM3U\", 7))\n        return 0;\n\n    if (strstr(p->buf, \"#EXT-X-STREAM-INF:\")     ||\n        strstr(p->buf, \"#EXT-X-TARGETDURATION:\") ||\n        strstr(p->buf, \"#EXT-X-MEDIA-SEQUENCE:\"))\n        return AVPROBE_SCORE_MAX;\n    return 0;\n}\n\n#define OFFSET(x) offsetof(HLSContext, x)\n#define FLAGS AV_OPT_FLAG_DECODING_PARAM\nstatic const AVOption hls_options[] = {\n    {\"live_start_index\", \"segment index to start live streams at (negative values are from the end)\",\n        OFFSET(live_start_index), AV_OPT_TYPE_INT, {.i64 = -3}, INT_MIN, INT_MAX, FLAGS},\n    {\"allowed_extensions\", \"List of file extensions that hls is allowed to access\",\n        OFFSET(allowed_extensions), AV_OPT_TYPE_STRING,\n        {.str = \"3gp,aac,avi,flac,mkv,m3u8,m4a,m4s,m4v,mpg,mov,mp2,mp3,mp4,mpeg,mpegts,ogg,ogv,oga,ts,vob,wav\"},\n        INT_MIN, INT_MAX, FLAGS},\n    {NULL}\n};\n\nstatic const AVClass hls_class = {\n    .class_name = \"hls,applehttp\",\n    .item_name  = av_default_item_name,\n    .option     = hls_options,\n    .version    = LIBAVUTIL_VERSION_INT,\n};\n\nAVInputFormat ff_hls_demuxer = {\n    .name           = \"hls,applehttp\",\n    .long_name      = NULL_IF_CONFIG_SMALL(\"Apple HTTP Live Streaming\"),\n    .priv_class     = &hls_class,\n    .priv_data_size = sizeof(HLSContext),\n    .read_probe     = hls_probe,\n    .read_header    = hls_read_header,\n    .read_packet    = hls_read_packet,\n    .read_close     = hls_close,\n    .read_seek      = hls_read_seek,\n};\n"], "filenames": ["libavformat/hls.c"], "buggy_code_start_loc": [206], "buggy_code_end_loc": [2136], "fixing_code_start_loc": [207], "fixing_code_end_loc": [2153], "type": "CWE-200", "message": "FFmpeg before 2.8.12, 3.0.x and 3.1.x before 3.1.9, 3.2.x before 3.2.6, and 3.3.x before 3.3.2 does not properly restrict HTTP Live Streaming filename extensions and demuxer names, which allows attackers to read arbitrary files via crafted playlist data.", "other": {"cve": {"id": "CVE-2017-9993", "sourceIdentifier": "cve@mitre.org", "published": "2017-06-28T06:29:00.520", "lastModified": "2019-03-26T17:56:24.007", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "FFmpeg before 2.8.12, 3.0.x and 3.1.x before 3.1.9, 3.2.x before 3.2.6, and 3.3.x before 3.3.2 does not properly restrict HTTP Live Streaming filename extensions and demuxer names, which allows attackers to read arbitrary files via crafted playlist data."}, {"lang": "es", "value": "Ffmpeg en sus versiones anteriores a la 2.8.12, 3.0.x y 3.1.x en sus versiones anteriores a la 3.1.9, 3.2.x en sus versiones anteriores a la 3.2.6, y 3.3.x en sus versiones anteriores a la 3.3.2 no restringe adecuadamente nombre de archivos con extensiones HTTP Live Streaming y nombres Demuxer, lo que permite a un atacante remoto leer archivo aleatorios mediante la manipulaci\u00f3n de los datos de la lista de reproducci\u00f3n."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-200"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.8.12", "matchCriteriaId": "941B47E5-FDBB-437A-8A4D-A9788019E5EC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.0", "versionEndExcluding": "3.1.9", "matchCriteriaId": "D3930B41-D5FD-4CA5-8DCD-8B7DE6E9CD88"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.2", "versionEndExcluding": "3.2.6", "matchCriteriaId": "B42EDB69-32DF-497C-9745-8367E7DFE85F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.3", "versionEndExcluding": "3.3.2", "matchCriteriaId": "733D6A4C-79F5-4DE0-A89F-A6DB8D3B7CE0"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}], "references": [{"url": "http://www.debian.org/security/2017/dsa-3957", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/99315", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/FFmpeg/FFmpeg/commit/189ff4219644532bdfa7bab28dfedaee4d6d4021", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/FFmpeg/FFmpeg/commit/a5d849b149ca67ced2d271dc84db0bc95a548abb", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2019/01/msg00006.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/FFmpeg/FFmpeg/commit/189ff4219644532bdfa7bab28dfedaee4d6d4021"}}