{"buggy_code": ["========================\n0.0.43\n========================\n\n- improved `flowinstance.newmessage(data)` method\n\n========================\n0.0.42\n========================\n\n- added support for JSON schemas\n- added Total Messaging Service\n- added `jsonschemas` directory\n- added `schema.jsonschema(name)` method\n- added `JSONSCHEMA()` method\n- added `NEWJSONSCHEMA()` method\n- added `NEWPUBLISH()` method\n- added `NEWSUBSCRIBE()` method\n- added `PUBLISH()` method\n- added `SUBSCRIBE()` method\n- added `UNSUBSCRIBE()` method\n- added `watcher` event for the main process in `debug` or `release` mode with the watcher\n- added HTML escaping for meta tags\n- added `WebSocketClient.destroy()` method\n- added new command `refresh_cmd`\n- added `allow_totalapilogger {Boolean}` option to the configuration\n- added `allow_totalapi {Boolean}` option to the configuration\n- added `allow_tms {Boolean}` option to the configuration\n- added `secret_tms {String}` option to the configuration\n- added `schema.jsonschema_define()` method\n- added `flowstream.load(components, design, [callback])` method\n- added `flowstream.unload(components, design, [callback])` method\n- added new delegate `flowstream.onreconfigure = function(instance) {}`\n- added new delegate `flowstream.onconnect = function(instance) {}`\n- added new delegate `flowstream.ondisconnect = function(instance) {}`\n- added new delegate `flowstream.onregister = function(component) {}`\n- added new delegate `flowstream.onunregister = function(component) {}`\n- added `uistream.load(components, design, [callback])` method\n- added `uistream.unload(components, design, [callback])` method\n- added new delegate `uistream.onreconfigure = function(instance) {}`\n- added new delegate `uistream.onconnect = function(instance) {}`\n- added new delegate `uistream.ondisconnect = function(instance) {}`\n- added new delegate `uistream.onregister = function(component) {}`\n- added new delegate `uistream.onunregister = function(component) {}`\n- fixed `Mail.attachmentfs()`\n- fixed dynamic routing\n- fixed security issue when parsing query arguments (reported by <https://github.com/fl4x>)\n- extended `schema.addTask()` by adding a new argument `callback`\n- added new method `flowstream.newmessage(data)`\n- added new method `flowstream_instance.newmessage(data)`\n- added `String.toJSONSchema(name, url)`\n- added `bundles.debug` enables watcher for `.src` directory only\n\n========================\n0.0.41\n========================\n\n- added TypeScript support\n- added support for static files in threads\n- fixed logging in threads by Tomas Novak\n- added `insecure` option to the `REQUEST()` method\n- added `builder.insecure()` method to the `RESTBuilder` instance\n- added `profile` type to the LDAP options\n- extended `base64` by adding support for `content-type;base64,data` format\n- updated `schema.define(key, type, required, [default_error_message])`\n- fixed `String.encrypt_uid()`\n- fixed `$.keys` in schemas with multiple operations\n- fixed wildcard routing combinated with dynamic arguments\n\n========================\n0.0.40\n========================\n\n- added `U.reader().list()` method\n- added `Array.findValue()`\n- added async/await mechanism to TextDB\n- added async/await mechanism to RESTBuilder\n- threads supports views\n- improved error handling in `TotalAPI()`\n- improved `Database.scalar()` by adding new argument\n- improved `QueryBuilder.in()` and `QueryBuilder.notin()`\n- fixed UTF8 chars in multi-part parser\n- fixed `NOSQL().autofill()`\n- fixed converting date via `Date.setTimeZone()`\n- fixed XML comments in `String.parseXML()`\n- fixed `Name` type in `Schemas`\n- fixed sorting in `U.reader()`\n\n========================\n0.0.39\n========================\n\n- added a new alias `request.proxy()` to `response.proxy()`\n- added `LDAP(opt, callback)` method for obtaining of users, groups or user profile (experimental)\n- added `U.normalize(path)` that normalizes path by adding `/` to begin and end of the phrase\n- added `U.link(path1, path2, pathN)` for creating of links\n- added `PATH.join()` alias to `Path.join()`\n- added `DEF.blacklist` object that performs IP blacklist\n- updated `filestorage.save()` by adding support for importing files from URL address\n- updated built-in session `AUTH()` mechanism by adding `options.strict {Boolean}` option\n- updated `$.extend([data], [callback])` method in SchemaOptions by adding `callback` argument that enables async processing\n- removed `allow_debug` option\n- fixed `abort` event for incoming `request`\n- fixed `controller.json()` method\n- fixed `array.quicksort()` method\n- fixed `controller.invalid()`, added missing second argument called `error` (optional)\n- fixed error handling in `TotalAPI`\n- fixed cookies transfering while redirecting in the `REQUEST()` method (can be disable via `opt.nocookies = true`)\n- fixed `language` in `WebSocketClient`\n- fixed merging files with the `auto` value defined in `versions`\n- fixed encoding in `content-disposition` header\n- fixed `UNAUTHORIZED()`\n- fixed `after` argument in the `PROXY()` and `res.proxy()` methods\n- improved error handling in WebSocket\n- improved HTTP caching in merged files\n- improved unit-testing\n- improved timeouts in the API endpoints\n\n========================\n0.0.38\n========================\n\n- added `PAUSE(is_paused)` method that can pause loading of all Total.js dependencies\n- added dynamic delegates for receiving of messages in FlowStream in the form `instance.mesage_<INPUT_NAME>`\n- added `response.proxy(target, [copypath], [after], [timeout])`\n- improved some parts of code\n- improved `MIDDLEWARE(name, fn, [assign], [first])` method\n- fixed measuring dimension for `.gif` images\n- fixed `BACKUP()` method (a problem with sockets)\n- fixed potential remote code execution in `U.set()` founded by [Snyk](https://snyk.io/vuln)\n- fixed routing with camel-Case URL addresses\n- fixed sending of messages via inline registered components in FlowStream\n- fixed a problem with FileStorage and opened file descriptors\n\n========================\n0.0.37\n========================\n\n- added CSRF\n\t- `CONF.secret_csrf`\n\t- `CONF.default_csrf_maxage`\n\t- `DEF.onCSRFcreate(req)`\n\t- `DEF.onCSRFcheck(req)`\n\t- `req.csrf()` generates a token\n\t- `controller.csrf()` generates a token\n\t- `@{csrf}` generates a token in View engine\n\t- `schema.csrf()` enables csrf for schemas and their routes\n\t- new `csrf` flag in `ROUTE()` method\n\t- `csrf` verification via `x-csrf-token` header or via URL argument `?csrf=TOKEN`\n\t- `RESTBuilder.csrf(token)`\n- added `HTMLMAIL(address, subject, body, [language], [callback])` for sending of raw HTML mail messages\n- added `NPMINSTALL(name, callback)` for installing of 3rd party NPM dependencies\n- added `FILESTORAGE().image()` method for reading of images\n- `CONF.default_errorbuilder_errors` for handling of all HTTP errors via ErrorBuilder\n- decreased `default_interval_websocket_ping` to `1` minute (from `3`)\n- improved image cache in `FILESTORAGE()`\n- fixed `message` with `closing bytes` in WebSocket and `WEBSOCKETCLIENT()`\n- fixed `@{resource()}` method in View engine\n- fixed read stream in `FILESTORAGE()`\n\n========================\n0.0.36\n========================\n\n- improved HTTP cache\n- fixed parsing of schema keys in `PATCH` method\n- fixed predefined session functionality (a problem with cache)\n- fixed `API` routes with empty model\n\n========================\n0.0.35\n========================\n\n- extended `EXEC()` by adding support for `Tasks` and `Operations`\n- fixed `DELETE` method for the schemas, now it works same like `PATCH` method\n- fixed `FlowStream.use()` method\n- fixed pausing of outputs/inputs in `FlowStream`\n- fixed inputs in `FlowStream`\n- fixed command injection in `Image.pipe()` and `Image.stream()`\n- fixed parsing of uploaded files (sometimes was the writeable stream unclosed)\n- fixed execution of system routes\n\n========================\n0.0.31\n========================\n\n- added `CONF.default_errorbuilder_forxhr` key (default: `true`)\n- errors in requests with `xhr` are serialized via ErrorBuilder\n- fixed reconnecting in `WEBSOCKETCLIENT()`\n- fixed `$.success()` and `$.done()` used in chaining", "'use strict';\n\nconst Dns = require('dns');\nconst Url = require('url');\nconst Http = require('http');\nconst Https = require('https');\nconst Path = require('path');\nconst Fs = require('fs');\nconst Crypto = require('crypto');\nconst Zlib = require('zlib');\nconst Tls = require('tls');\nconst Net = require('net');\nconst KeepAlive = new Http.Agent({ keepAlive: true, timeout: 60000 });\nconst KeepAliveHttps = new Https.Agent({ keepAlive: true, timeout: 60000 });\nconst SKIPBODYENCRYPTOR = { ':': 1, '\"': 1, '[': 1, ']': 1, '\\'': 1, '_': 1, '{': 1, '}': 1, '&': 1, '=': 1, '+': 1, '-': 1, '\\\\': 1, '/': 1, ',': 1 };\nconst REG_EMPTYBUFFER = /\\0|%00|\\\\u0000/g;\nconst REG_EMPTYBUFFER_TEST = /\\0|%00|\\\\u0000/;\n\nconst COMPRESS = { gzip: 1, deflate: 1 };\nconst CONCAT = [null, null];\nconst SKIPPORTS = { '80': 1, '443': 1 };\n\nconst COMPARER = function(a, b) {\n\tif (!a && b)\n\t\treturn -1;\n\tif (a && !b)\n\t\treturn 1;\n\tif (a === b)\n\t\treturn 0;\n\treturn global.Intl.Collator().compare(a, b);\n};\n\nconst COMPARER_DESC = function(a, b) {\n\n\tif (!a && b)\n\t\treturn 1;\n\n\tif (a && !b)\n\t\treturn -1;\n\n\tif (a === b)\n\t\treturn 0;\n\n\tvar val = global.Intl.Collator().compare(a, b);\n\treturn val ? val * -1 : 0;\n};\n\nif (!global.framework_utils)\n\tglobal.framework_utils = exports;\n\nconst Internal = require('./internal');\nvar regexpSTATIC = /\\.\\w{2,8}($|\\?)+/;\nconst regexpTRIM = /^[\\s]+|[\\s]+$/g;\nconst regexpDATE = /(\\d{1,2}\\.\\d{1,2}\\.\\d{4})|(\\d{4}-\\d{1,2}-\\d{1,2})|(\\d{1,2}:\\d{1,2}(:\\d{1,2})?)/g;\nconst regexpDATEFORMAT = /YYYY|yyyy|YY|yy|MMMM|MMM|MM|M|dddd|DDDD|DDD|ddd|DD|dd|D|d|HH|H|hh|h|mm|m|ss|s|a|ww|w/g;\nconst regexpSTRINGFORMAT = /\\{\\d+\\}/g;\nconst regexpPATH = /\\\\/g;\nconst regexpTags = /<\\/?[^>]+(>|$)/g;\nconst regexpDiacritics = /[^\\u0000-\\u007e]/g;\nconst regexpUA = /[a-z]+/gi;\nconst regexpXML = /\\w+=\".*?\"/g;\nconst regexpDECODE = /&#?[a-z0-9]+;/g;\nconst regexpARG = /\\{{1,2}[a-z0-9_.-\\s]+\\}{1,2}/gi;\nconst regexpINTEGER = /(^-|\\s-)?[0-9]+/g;\nconst regexpFLOAT = /(^-|\\s-)?[0-9.,]+/g;\nconst regexpSEARCH = /[^a-zA-Z\u00e1-\u017e\u00c1-\u017d\\d\\s:]/g;\nconst regexpTERMINAL = /[\\w\\S]+/g;\nconst regexpCONFIGURE = /\\[\\w+\\]/g;\nconst regexpY = /y/g;\nconst regexpN = /\\n/g;\nconst regexpCHARS = /\\W|_/g;\nconst regexpCHINA = /[\\u3400-\\u9FBF]/;\nconst regexpLINES = /\\n|\\r|\\r\\n/;\nconst regexpBASE64 = /^([A-Za-z0-9+/]{4})*([A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{2}==)?$/;\nconst regexpBASE64_2 = /^|,([A-Za-z0-9+/]{4})*([A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{2}==)?$/;\nconst ENCODING = 'utf8';\nconst NEWLINE = '\\r\\n';\nconst isWindows = require('os').platform().substring(0, 3).toLowerCase() === 'win';\nconst DIACRITICSMAP = {};\nconst ALPHA_INDEX = { '&lt': '<', '&gt': '>', '&quot': '\"', '&apos': '\\'', '&amp': '&', '&lt;': '<', '&gt;': '>', '&quot;': '\"', '&apos;': '\\'', '&amp;': '&' };\nconst STREAMPIPE = { end: false };\nconst CT = 'Content-Type';\nconst CRC32TABLE = '00000000,77073096,EE0E612C,990951BA,076DC419,706AF48F,E963A535,9E6495A3,0EDB8832,79DCB8A4,E0D5E91E,97D2D988,09B64C2B,7EB17CBD,E7B82D07,90BF1D91,1DB71064,6AB020F2,F3B97148,84BE41DE,1ADAD47D,6DDDE4EB,F4D4B551,83D385C7,136C9856,646BA8C0,FD62F97A,8A65C9EC,14015C4F,63066CD9,FA0F3D63,8D080DF5,3B6E20C8,4C69105E,D56041E4,A2677172,3C03E4D1,4B04D447,D20D85FD,A50AB56B,35B5A8FA,42B2986C,DBBBC9D6,ACBCF940,32D86CE3,45DF5C75,DCD60DCF,ABD13D59,26D930AC,51DE003A,C8D75180,BFD06116,21B4F4B5,56B3C423,CFBA9599,B8BDA50F,2802B89E,5F058808,C60CD9B2,B10BE924,2F6F7C87,58684C11,C1611DAB,B6662D3D,76DC4190,01DB7106,98D220BC,EFD5102A,71B18589,06B6B51F,9FBFE4A5,E8B8D433,7807C9A2,0F00F934,9609A88E,E10E9818,7F6A0DBB,086D3D2D,91646C97,E6635C01,6B6B51F4,1C6C6162,856530D8,F262004E,6C0695ED,1B01A57B,8208F4C1,F50FC457,65B0D9C6,12B7E950,8BBEB8EA,FCB9887C,62DD1DDF,15DA2D49,8CD37CF3,FBD44C65,4DB26158,3AB551CE,A3BC0074,D4BB30E2,4ADFA541,3DD895D7,A4D1C46D,D3D6F4FB,4369E96A,346ED9FC,AD678846,DA60B8D0,44042D73,33031DE5,AA0A4C5F,DD0D7CC9,5005713C,270241AA,BE0B1010,C90C2086,5768B525,206F85B3,B966D409,CE61E49F,5EDEF90E,29D9C998,B0D09822,C7D7A8B4,59B33D17,2EB40D81,B7BD5C3B,C0BA6CAD,EDB88320,9ABFB3B6,03B6E20C,74B1D29A,EAD54739,9DD277AF,04DB2615,73DC1683,E3630B12,94643B84,0D6D6A3E,7A6A5AA8,E40ECF0B,9309FF9D,0A00AE27,7D079EB1,F00F9344,8708A3D2,1E01F268,6906C2FE,F762575D,806567CB,196C3671,6E6B06E7,FED41B76,89D32BE0,10DA7A5A,67DD4ACC,F9B9DF6F,8EBEEFF9,17B7BE43,60B08ED5,D6D6A3E8,A1D1937E,38D8C2C4,4FDFF252,D1BB67F1,A6BC5767,3FB506DD,48B2364B,D80D2BDA,AF0A1B4C,36034AF6,41047A60,DF60EFC3,A867DF55,316E8EEF,4669BE79,CB61B38C,BC66831A,256FD2A0,5268E236,CC0C7795,BB0B4703,220216B9,5505262F,C5BA3BBE,B2BD0B28,2BB45A92,5CB36A04,C2D7FFA7,B5D0CF31,2CD99E8B,5BDEAE1D,9B64C2B0,EC63F226,756AA39C,026D930A,9C0906A9,EB0E363F,72076785,05005713,95BF4A82,E2B87A14,7BB12BAE,0CB61B38,92D28E9B,E5D5BE0D,7CDCEFB7,0BDBDF21,86D3D2D4,F1D4E242,68DDB3F8,1FDA836E,81BE16CD,F6B9265B,6FB077E1,18B74777,88085AE6,FF0F6A70,66063BCA,11010B5C,8F659EFF,F862AE69,616BFFD3,166CCF45,A00AE278,D70DD2EE,4E048354,3903B3C2,A7672661,D06016F7,4969474D,3E6E77DB,AED16A4A,D9D65ADC,40DF0B66,37D83BF0,A9BCAE53,DEBB9EC5,47B2CF7F,30B5FFE9,BDBDF21C,CABAC28A,53B39330,24B4A3A6,BAD03605,CDD70693,54DE5729,23D967BF,B3667A2E,C4614AB8,5D681B02,2A6F2B94,B40BBE37,C30C8EA1,5A05DF1B,2D02EF8D'.split(',').map(s => parseInt(s, 16));\nconst REGISARR = /\\[\\d+\\]|\\[\\]$/;\nconst REGREPLACEARR = /\\[\\]/g;\nconst PROXYBLACKLIST = { 'localhost': 1, '127.0.0.1': 1, '0.0.0.0': 1 };\nconst PROXYOPTIONS = { headers: {}, method: 'CONNECT', agent: false };\nconst PROXYTLS = { headers: {}};\nconst PROXYOPTIONSHTTP = {};\nconst REG_ROOT = /@\\{#\\}(\\/)?/g;\nconst REG_NOREMAP = /@\\{noremap\\}(\\n)?/g;\nconst REG_REMAP = /href=\".*?\"|src=\".*?\"/gi;\nconst REG_AJAX = /('|\")+(!)?(GET|POST|PUT|DELETE|PATCH)\\s(\\(.*?\\)\\s)?\\//g;\nconst REG_URLEXT = /(https|http|wss|ws|file):\\/\\/|\\/\\/[a-z0-9]|[a-z]:/i;\nconst REG_TEXTAPPLICATION = /text|application/i;\nconst REG_TIME = /am|pm/i;\nconst REG_XMLKEY = /\\[|\\]|:|\\.|_/g;\nconst HEADEREND = Buffer.from('\\r\\n\\r\\n', 'ascii');\nconst HEADERCHECK = 'Content-Disposition: form-data;'.toLowerCase();\n\nexports.MONTHS = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];\nexports.DAYS = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];\n\nvar DIACRITICS=[{b:' ',c:'\\u00a0'},{b:'0',c:'\\u07c0'},{b:'A',c:'\\u24b6\\uff21\\u00c0\\u00c1\\u00c2\\u1ea6\\u1ea4\\u1eaa\\u1ea8\\u00c3\\u0100\\u0102\\u1eb0\\u1eae\\u1eb4\\u1eb2\\u0226\\u01e0\\u00c4\\u01de\\u1ea2\\u00c5\\u01fa\\u01cd\\u0200\\u0202\\u1ea0\\u1eac\\u1eb6\\u1e00\\u0104\\u023a\\u2c6f'},{b:'AA',c:'\\ua732'},{b:'AE',c:'\\u00c6\\u01fc\\u01e2'},{b:'AO',c:'\\ua734'},{b:'AU',c:'\\ua736'},{b:'AV',c:'\\ua738\\ua73a'},{b:'AY',c:'\\ua73c'},{b:'B',c:'\\u24b7\\uff22\\u1e02\\u1e04\\u1e06\\u0243\\u0181'},{b:'C',c:'\\u24b8\\uff23\\ua73e\\u1e08\\u0106C\\u0108\\u010a\\u010c\\u00c7\\u0187\\u023b'},{b:'D',c:'\\u24b9\\uff24\\u1e0a\\u010e\\u1e0c\\u1e10\\u1e12\\u1e0e\\u0110\\u018a\\u0189\\u1d05\\ua779'},{b:'Dh',c:'\\u00d0'},{b:'DZ',c:'\\u01f1\\u01c4'},{b:'Dz',c:'\\u01f2\\u01c5'},{b:'E',c:'\\u025b\\u24ba\\uff25\\u00c8\\u00c9\\u00ca\\u1ec0\\u1ebe\\u1ec4\\u1ec2\\u1ebc\\u0112\\u1e14\\u1e16\\u0114\\u0116\\u00cb\\u1eba\\u011a\\u0204\\u0206\\u1eb8\\u1ec6\\u0228\\u1e1c\\u0118\\u1e18\\u1e1a\\u0190\\u018e\\u1d07'},{b:'F',c:'\\ua77c\\u24bb\\uff26\\u1e1e\\u0191\\ua77b'}, {b:'G',c:'\\u24bc\\uff27\\u01f4\\u011c\\u1e20\\u011e\\u0120\\u01e6\\u0122\\u01e4\\u0193\\ua7a0\\ua77d\\ua77e\\u0262'},{b:'H',c:'\\u24bd\\uff28\\u0124\\u1e22\\u1e26\\u021e\\u1e24\\u1e28\\u1e2a\\u0126\\u2c67\\u2c75\\ua78d'},{b:'I',c:'\\u24be\\uff29\\u00cc\\u00cd\\u00ce\\u0128\\u012a\\u012c\\u0130\\u00cf\\u1e2e\\u1ec8\\u01cf\\u0208\\u020a\\u1eca\\u012e\\u1e2c\\u0197'},{b:'J',c:'\\u24bf\\uff2a\\u0134\\u0248\\u0237'},{b:'K',c:'\\u24c0\\uff2b\\u1e30\\u01e8\\u1e32\\u0136\\u1e34\\u0198\\u2c69\\ua740\\ua742\\ua744\\ua7a2'},{b:'L',c:'\\u24c1\\uff2c\\u013f\\u0139\\u013d\\u1e36\\u1e38\\u013b\\u1e3c\\u1e3a\\u0141\\u023d\\u2c62\\u2c60\\ua748\\ua746\\ua780'}, {b:'LJ',c:'\\u01c7'},{b:'Lj',c:'\\u01c8'},{b:'M',c:'\\u24c2\\uff2d\\u1e3e\\u1e40\\u1e42\\u2c6e\\u019c\\u03fb'},{b:'N',c:'\\ua7a4\\u0220\\u24c3\\uff2e\\u01f8\\u0143\\u00d1\\u1e44\\u0147\\u1e46\\u0145\\u1e4a\\u1e48\\u019d\\ua790\\u1d0e'},{b:'NJ',c:'\\u01ca'},{b:'Nj',c:'\\u01cb'},{b:'O',c:'\\u24c4\\uff2f\\u00d2\\u00d3\\u00d4\\u1ed2\\u1ed0\\u1ed6\\u1ed4\\u00d5\\u1e4c\\u022c\\u1e4e\\u014c\\u1e50\\u1e52\\u014e\\u022e\\u0230\\u00d6\\u022a\\u1ece\\u0150\\u01d1\\u020c\\u020e\\u01a0\\u1edc\\u1eda\\u1ee0\\u1ede\\u1ee2\\u1ecc\\u1ed8\\u01ea\\u01ec\\u00d8\\u01fe\\u0186\\u019f\\ua74a\\ua74c'}, {b:'OE',c:'\\u0152'},{b:'OI',c:'\\u01a2'},{b:'OO',c:'\\ua74e'},{b:'OU',c:'\\u0222'},{b:'P',c:'\\u24c5\\uff30\\u1e54\\u1e56\\u01a4\\u2c63\\ua750\\ua752\\ua754'},{b:'Q',c:'\\u24c6\\uff31\\ua756\\ua758\\u024a'},{b:'R',c:'\\u24c7\\uff32\\u0154\\u1e58\\u0158\\u0210\\u0212\\u1e5a\\u1e5c\\u0156\\u1e5e\\u024c\\u2c64\\ua75a\\ua7a6\\ua782'},{b:'S',c:'\\u24c8\\uff33\\u1e9e\\u015a\\u1e64\\u015c\\u1e60\\u0160\\u1e66\\u1e62\\u1e68\\u0218\\u015e\\u2c7e\\ua7a8\\ua784'},{b:'T',c:'\\u24c9\\uff34\\u1e6a\\u0164\\u1e6c\\u021a\\u0162\\u1e70\\u1e6e\\u0166\\u01ac\\u01ae\\u023e\\ua786'}, {b:'Th',c:'\\u00de'},{b:'TZ',c:'\\ua728'},{b:'U',c:'\\u24ca\\uff35\\u00d9\\u00da\\u00db\\u0168\\u1e78\\u016a\\u1e7a\\u016c\\u00dc\\u01db\\u01d7\\u01d5\\u01d9\\u1ee6\\u016e\\u0170\\u01d3\\u0214\\u0216\\u01af\\u1eea\\u1ee8\\u1eee\\u1eec\\u1ef0\\u1ee4\\u1e72\\u0172\\u1e76\\u1e74\\u0244'},{b:'V',c:'\\u24cb\\uff36\\u1e7c\\u1e7e\\u01b2\\ua75e\\u0245'},{b:'VY',c:'\\ua760'},{b:'W',c:'\\u24cc\\uff37\\u1e80\\u1e82\\u0174\\u1e86\\u1e84\\u1e88\\u2c72'},{b:'X',c:'\\u24cd\\uff38\\u1e8a\\u1e8c'},{b:'Y',c:'\\u24ce\\uff39\\u1ef2\\u00dd\\u0176\\u1ef8\\u0232\\u1e8e\\u0178\\u1ef6\\u1ef4\\u01b3\\u024e\\u1efe'}, {b:'Z',c:'\\u24cf\\uff3a\\u0179\\u1e90\\u017b\\u017d\\u1e92\\u1e94\\u01b5\\u0224\\u2c7f\\u2c6b\\ua762'},{b:'a',c:'\\u24d0\\uff41\\u1e9a\\u00e0\\u00e1\\u00e2\\u1ea7\\u1ea5\\u1eab\\u1ea9\\u00e3\\u0101\\u0103\\u1eb1\\u1eaf\\u1eb5\\u1eb3\\u0227\\u01e1\\u00e4\\u01df\\u1ea3\\u00e5\\u01fb\\u01ce\\u0201\\u0203\\u1ea1\\u1ead\\u1eb7\\u1e01\\u0105\\u2c65\\u0250\\u0251'},{b:'aa',c:'\\ua733'},{b:'ae',c:'\\u00e6\\u01fd\\u01e3'},{b:'ao',c:'\\ua735'},{b:'au',c:'\\ua737'},{b:'av',c:'\\ua739\\ua73b'},{b:'ay',c:'\\ua73d'}, {b:'b',c:'\\u24d1\\uff42\\u1e03\\u1e05\\u1e07\\u0180\\u0183\\u0253\\u0182'},{b:'c',c:'\\uff43\\u24d2\\u0107\\u0109\\u010b\\u010d\\u00e7\\u1e09\\u0188\\u023c\\ua73f\\u2184'},{b:'d',c:'\\u24d3\\uff44\\u1e0b\\u010f\\u1e0d\\u1e11\\u1e13\\u1e0f\\u0111\\u018c\\u0256\\u0257\\u018b\\u13e7\\u0501\\ua7aa'},{b:'dh',c:'\\u00f0'},{b:'dz',c:'\\u01f3\\u01c6'},{b:'e',c:'\\u24d4\\uff45\\u00e8\\u00e9\\u00ea\\u1ec1\\u1ebf\\u1ec5\\u1ec3\\u1ebd\\u0113\\u1e15\\u1e17\\u0115\\u0117\\u00eb\\u1ebb\\u011b\\u0205\\u0207\\u1eb9\\u1ec7\\u0229\\u1e1d\\u0119\\u1e19\\u1e1b\\u0247\\u01dd'}, {b:'f',c:'\\u24d5\\uff46\\u1e1f\\u0192'},{b:'ff',c:'\\ufb00'},{b:'fi',c:'\\ufb01'},{b:'fl',c:'\\ufb02'},{b:'ffi',c:'\\ufb03'},{b:'ffl',c:'\\ufb04'},{b:'g',c:'\\u24d6\\uff47\\u01f5\\u011d\\u1e21\\u011f\\u0121\\u01e7\\u0123\\u01e5\\u0260\\ua7a1\\ua77f\\u1d79'},{b:'h',c:'\\u24d7\\uff48\\u0125\\u1e23\\u1e27\\u021f\\u1e25\\u1e29\\u1e2b\\u1e96\\u0127\\u2c68\\u2c76\\u0265'},{b:'hv',c:'\\u0195'},{b:'i',c:'\\u24d8\\uff49\\u00ec\\u00ed\\u00ee\\u0129\\u012b\\u012d\\u00ef\\u1e2f\\u1ec9\\u01d0\\u0209\\u020b\\u1ecb\\u012f\\u1e2d\\u0268\\u0131'}, {b:'j',c:'\\u24d9\\uff4a\\u0135\\u01f0\\u0249'},{b:'k',c:'\\u24da\\uff4b\\u1e31\\u01e9\\u1e33\\u0137\\u1e35\\u0199\\u2c6a\\ua741\\ua743\\ua745\\ua7a3'},{b:'l',c:'\\u24db\\uff4c\\u0140\\u013a\\u013e\\u1e37\\u1e39\\u013c\\u1e3d\\u1e3b\\u017f\\u0142\\u019a\\u026b\\u2c61\\ua749\\ua781\\ua747\\u026d'},{b:'lj',c:'\\u01c9'},{b:'m',c:'\\u24dc\\uff4d\\u1e3f\\u1e41\\u1e43\\u0271\\u026f'},{b:'n',c:'\\u24dd\\uff4e\\u01f9\\u0144\\u00f1\\u1e45\\u0148\\u1e47\\u0146\\u1e4b\\u1e49\\u019e\\u0272\\u0149\\ua791\\ua7a5\\u043b\\u0509'},{b:'nj', c:'\\u01cc'},{b:'o',c:'\\u24de\\uff4f\\u00f2\\u00f3\\u00f4\\u1ed3\\u1ed1\\u1ed7\\u1ed5\\u00f5\\u1e4d\\u022d\\u1e4f\\u014d\\u1e51\\u1e53\\u014f\\u022f\\u0231\\u00f6\\u022b\\u1ecf\\u0151\\u01d2\\u020d\\u020f\\u01a1\\u1edd\\u1edb\\u1ee1\\u1edf\\u1ee3\\u1ecd\\u1ed9\\u01eb\\u01ed\\u00f8\\u01ff\\ua74b\\ua74d\\u0275\\u0254\\u1d11'},{b:'oe',c:'\\u0153'},{b:'oi',c:'\\u01a3'},{b:'oo',c:'\\ua74f'},{b:'ou',c:'\\u0223'},{b:'p',c:'\\u24df\\uff50\\u1e55\\u1e57\\u01a5\\u1d7d\\ua751\\ua753\\ua755\\u03c1'},{b:'q',c:'\\u24e0\\uff51\\u024b\\ua757\\ua759'}, {b:'r',c:'\\u24e1\\uff52\\u0155\\u1e59\\u0159\\u0211\\u0213\\u1e5b\\u1e5d\\u0157\\u1e5f\\u024d\\u027d\\ua75b\\ua7a7\\ua783'},{b:'s',c:'\\u24e2\\uff53\\u015b\\u1e65\\u015d\\u1e61\\u0161\\u1e67\\u1e63\\u1e69\\u0219\\u015f\\u023f\\ua7a9\\ua785\\u1e9b\\u0282'},{b:'ss',c:'\\u00df'},{b:'t',c:'\\u24e3\\uff54\\u1e6b\\u1e97\\u0165\\u1e6d\\u021b\\u0163\\u1e71\\u1e6f\\u0167\\u01ad\\u0288\\u2c66\\ua787'},{b:'th',c:'\\u00fe'},{b:'tz',c:'\\ua729'},{b:'u',c:'\\u24e4\\uff55\\u00f9\\u00fa\\u00fb\\u0169\\u1e79\\u016b\\u1e7b\\u016d\\u00fc\\u01dc\\u01d8\\u01d6\\u01da\\u1ee7\\u016f\\u0171\\u01d4\\u0215\\u0217\\u01b0\\u1eeb\\u1ee9\\u1eef\\u1eed\\u1ef1\\u1ee5\\u1e73\\u0173\\u1e77\\u1e75\\u0289'}, {b:'v',c:'\\u24e5\\uff56\\u1e7d\\u1e7f\\u028b\\ua75f\\u028c'},{b:'vy',c:'\\ua761'},{b:'w',c:'\\u24e6\\uff57\\u1e81\\u1e83\\u0175\\u1e87\\u1e85\\u1e98\\u1e89\\u2c73'},{b:'x',c:'\\u24e7\\uff58\\u1e8b\\u1e8d'},{b:'y',c:'\\u24e8\\uff59\\u1ef3\\u00fd\\u0177\\u1ef9\\u0233\\u1e8f\\u00ff\\u1ef7\\u1e99\\u1ef5\\u01b4\\u024f\\u1eff'},{b:'z',c:'\\u24e9\\uff5a\\u017a\\u1e91\\u017c\\u017e\\u1e93\\u1e95\\u01b6\\u0225\\u0240\\u2c6c\\ua763'}];\nvar UPLOADINDEXER = 1;\n\nfor (var i=0; i <DIACRITICS.length; i+=1)\n\tfor (var chars=DIACRITICS[i].c,j=0;j<chars.length;j+=1)\n\t\tDIACRITICSMAP[chars[j]]=DIACRITICS[i].b;\n\nconst DP = Date.prototype;\nconst SP = String.prototype;\nconst NP = Number.prototype;\n\nDIACRITICS = null;\n\nvar CONTENTTYPES = {\n\taac: 'audio/aac',\n\tai: 'application/postscript',\n\tappcache: 'text/cache-manifest',\n\tavi: 'video/avi',\n\tbin: 'application/octet-stream',\n\tbmp: 'image/bmp',\n\tcoffee: 'text/coffeescript',\n\tcss: 'text/css',\n\tcsv: 'text/csv',\n\tdoc: 'application/msword',\n\tdocx: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',\n\tdtd: 'application/xml-dtd',\n\teps: 'application/postscript',\n\texe: 'application/octet-stream',\n\tflac: 'audio/x-flac',\n\tgeojson: 'application/json',\n\tgif: 'image/gif',\n\tgzip: 'application/x-gzip',\n\theic: 'image/heic',\n\theif: 'image/heif',\n\thtm: 'text/html',\n\thtml: 'text/html',\n\tico: 'image/x-icon',\n\tics: 'text/calendar',\n\tifb: 'text/calendar',\n\tjpe: 'image/jpeg',\n\tjpeg: 'image/jpeg',\n\tjpg: 'image/jpeg',\n\tjs: 'text/javascript',\n\tjson: 'application/json',\n\tjsx: 'text/jsx',\n\tless: 'text/css',\n\tm4a: 'audio/mp4a-latm',\n\tm4v: 'video/x-m4v',\n\tmanifest: 'text/cache-manifest',\n\tmd: 'text/x-markdown',\n\tmid: 'audio/midi',\n\tmidi: 'audio/midi',\n\tmjs: 'text/javascript',\n\tmov: 'video/quicktime',\n\tmp3: 'audio/mpeg',\n\tmp4: 'video/mp4',\n\tmpe: 'video/mpeg',\n\tmpeg: 'video/mpeg',\n\tmpg: 'video/mpeg',\n\tmpga: 'audio/mpeg',\n\tmtl: 'text/plain',\n\tmv4: 'video/mv4',\n\tobj: 'text/plain',\n\togg: 'application/ogg',\n\togv: 'video/ogg',\n\tpackage: 'text/plain',\n\tpdf: 'application/pdf',\n\tpng: 'image/png',\n\tppt: 'application/vnd.ms-powerpoint',\n\tpptx: 'application/vnd.ms-powerpoint',\n\tps: 'application/postscript',\n\trar: 'application/x-rar-compressed',\n\trtf: 'text/rtf',\n\tsass: 'text/css',\n\tscss: 'text/css',\n\tsh: 'application/x-sh',\n\tstl: 'application/sla',\n\tsvg: 'image/svg+xml',\n\tswf: 'application/x-shockwave-flash',\n\ttar: 'application/x-tar',\n\ttif: 'image/tiff',\n\ttiff: 'image/tiff',\n\ttxt: 'text/plain',\n\tsql: 'text/plain',\n\twav: 'audio/x-wav',\n\twebm: 'video/webm',\n\twebp: 'image/webp',\n\twoff: 'application/font-woff',\n\twoff2: 'application/font-woff2',\n\txht: 'application/xhtml+xml',\n\txhtml: 'application/xhtml+xml',\n\txls: 'application/vnd.ms-excel',\n\txlsx: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',\n\txml: 'application/xml',\n\txpm: 'image/x-xpixmap',\n\txsl: 'application/xml',\n\txslt: 'application/xslt+xml',\n\tzip: 'application/zip'\n};\n\nvar dnscache = {};\nvar datetimeformat = {};\n\nglobal.DIFFARR = exports.diffarr = function(prop, db, form) {\n\n\tvar an = [];\n\tvar au = [];\n\tvar ar = [];\n\tvar is, oa, ob;\n\n\tfor (var i = 0; i < db.length; i++) {\n\t\toa = db[i];\n\t\tis = false;\n\t\tfor (var j = 0; j < form.length; j++) {\n\t\t\tob = form[j];\n\t\t\tif (oa[prop] == ob[prop]) {\n\t\t\t\tau.push({ db: oa, form: ob });\n\t\t\t\tis = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!is)\n\t\t\tar.push(oa[prop]);\n\t}\n\n\tfor (var i = 0; i < form.length; i++) {\n\t\tob = form[i];\n\t\tis = false;\n\t\tfor (var j = 0; j < db.length; j++) {\n\t\t\toa = db[j];\n\t\t\tif (ob[prop] == oa[prop]) {\n\t\t\t\tis = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!is)\n\t\t\tan.push(ob);\n\t}\n\n\tvar obj = {};\n\tobj.add = an;\n\tobj.upd = au;\n\tobj.rem = ar;\n\treturn obj;\n};\n\nexports.toURLEncode = function(value) {\n\tvar builder = [];\n\n\tfor (var key in value) {\n\t\tvar val = value[key];\n\n\t\tif (val == null || val === '')\n\t\t\tcontinue;\n\n\t\tvar type = typeof(val);\n\t\tswitch (type) {\n\t\t\tcase 'string':\n\t\t\t\tbuilder.push(key + '=' + encodeURIComponent(val));\n\t\t\t\tbreak;\n\t\t\tcase 'date':\n\t\t\t\tbuilder.push(key + '=' + encodeURIComponent(val.format('utc')));\n\t\t\t\tbreak;\n\t\t\tcase 'boolean':\n\t\t\tcase 'number':\n\t\t\t\tbuilder.push(key + '=' + val);\n\t\t\t\tbreak;\n\t\t\tcase 'object':\n\t\t\t\tif (val instanceof Array)\n\t\t\t\t\tbuilder.push(key + '=' + encodeURIComponent(val.join(',')));\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn builder.length ? builder.join('&') : '';\n};\n\nexports.resolve = function(url, callback, param) {\n\n\tvar uri;\n\n\ttry {\n\t\turi = Url.parse(url);\n\t} catch (e) {\n\t\tcallback(e);\n\t\treturn;\n\t}\n\n\tvar cache = dnscache[uri.host];\n\n\tif (!callback)\n\t\treturn cache;\n\n\tif (cache) {\n\t\turi.host = cache[0];\n\t\tcallback(null, uri, param, cache);\n\t\treturn;\n\t}\n\n\tDns.resolve4(uri.hostname, function(e, addresses) {\n\t\tif (e)\n\t\t\tsetImmediate(dnsresolve_callback, uri, callback, param);\n\t\telse {\n\t\t\tdnscache[uri.host] = addresses;\n\t\t\turi.host = addresses[0];\n\t\t\tcallback(null, uri, param, addresses);\n\t\t}\n\t});\n};\n\nfunction dnsresolve_callback(uri, callback, param) {\n\tDns.resolve4(uri.hostname, function(e, addresses) {\n\t\tif (addresses && addresses.length) {\n\t\t\tdnscache[uri.host] = addresses;\n\t\t\turi.host = addresses[0];\n\t\t}\n\t\tcallback(e, uri, param, addresses);\n\t});\n}\n\nsetImmediate(function() {\n\tglobal.F && NEWCOMMAND('clear_dnscache', function() {\n\t\tdnscache = {};\n\t});\n});\n\nexports.keywords = function(content, forSearch, alternative, max_count, max_length, min_length) {\n\n\tif (forSearch === undefined)\n\t\tforSearch = true;\n\n\tmin_length = min_length || 2;\n\tmax_count = max_count || 200;\n\tmax_length = max_length || 20;\n\n\tvar words = [];\n\n\tif (content instanceof Array) {\n\t\tfor (var i = 0, length = content.length; i < length; i++) {\n\t\t\tif (!content[i])\n\t\t\t\tcontinue;\n\t\t\tvar tmp = (forSearch ? content[i].toASCII().toLowerCase().replace(regexpY, 'i') : content[i].toLowerCase()).replace(regexpN, ' ').split(' ');\n\t\t\tif (!tmp || !tmp.length)\n\t\t\t\tcontinue;\n\t\t\tfor (var j = 0, jl = tmp.length; j < jl; j++)\n\t\t\t\twords.push(tmp[j]);\n\t\t}\n\t} else\n\t\twords = (forSearch ? content.toASCII().toLowerCase().replace(regexpY, 'i') : content.toLowerCase()).replace(regexpN, ' ').split(' ');\n\n\tif (!words)\n\t\twords = [];\n\n\tvar dic = {};\n\tvar counter = 0;\n\n\tfor (var i = 0, length = words.length; i < length; i++) {\n\n\t\tvar word = words[i].trim().replace(regexpCHARS, keywordscleaner);\n\n\t\tif (regexpCHINA.test(word)) {\n\n\t\t\tvar tmpw = word.split('', max_count);\n\n\t\t\tfor (var j = 0; j < tmpw.length; j++) {\n\t\t\t\tword = tmpw[j];\n\t\t\t\tif (dic[word])\n\t\t\t\t\tdic[word]++;\n\t\t\t\telse\n\t\t\t\t\tdic[word] = 1;\n\t\t\t\tcounter++;\n\t\t\t}\n\n\t\t\tif (counter >= max_count)\n\t\t\t\tbreak;\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (word.length < min_length)\n\t\t\tcontinue;\n\n\t\tif (counter >= max_count)\n\t\t\tbreak;\n\n\t\t// Gets 80% length of word\n\t\tif (alternative) {\n\t\t\tvar size = (word.length / 100) * 80;\n\t\t\tif (size > min_length + 1)\n\t\t\t\tword = word.substring(0, size);\n\t\t}\n\n\t\tif (word.length < min_length || word.length > max_length)\n\t\t\tcontinue;\n\n\t\tif (dic[word])\n\t\t\tdic[word]++;\n\t\telse\n\t\t\tdic[word] = 1;\n\n\t\tcounter++;\n\t}\n\n\tvar keys = Object.keys(dic);\n\n\tkeys.sort(function(a, b) {\n\t\tvar countA = dic[a];\n\t\tvar countB = dic[b];\n\t\treturn countA > countB ? -1 : countA < countB ? 1 : 0;\n\t});\n\n\treturn keys;\n};\n\nfunction keywordscleaner(c) {\n\treturn c.charCodeAt(0) < 200 ? '' : c;\n}\n\nfunction parseProxy(p) {\n\tvar key = 'proxy_' + p;\n\tif (F.temporary.other[key])\n\t\treturn F.temporary.other[key];\n\n\tif (p.indexOf('://') === -1)\n\t\tp = 'http://' + p;\n\n\tvar obj = Url.parse(p);\n\n\tif (obj.auth)\n\t\tobj._auth = 'Basic ' + Buffer.from(obj.auth).toString('base64');\n\n\tobj.port = +obj.port;\n\n\tif (p.indexOf('https:') !== -1) {\n\t\tobj.rejectUnauthorized = false;\n\t\tobj.requestCert = true;\n\t}\n\n\treturn F.temporary.other[key] = obj;\n}\n\nglobal.REQUEST = function(opt, callback) {\n\n\tvar options = { length: 0, timeout: opt.timeout || CONF.default_restbuilder_timeout, encoding: opt.encoding || ENCODING, callback: opt.callback || NOOP, post: true, redirect: 0 };\n\tvar proxy;\n\n\tif (callback)\n\t\topt.callback = callback;\n\n\tif (global.F)\n\t\tglobal.F.stats.performance.external++;\n\n\tif (opt.headers)\n\t\topt.headers = exports.extend({}, opt.headers);\n\telse\n\t\topt.headers = {};\n\n\tif (!opt.method)\n\t\topt.method = 'GET';\n\n\toptions.$totalinit = opt;\n\n\t// opt.encrypt {String}\n\t// opt.limit in kB\n\t// opt.key {Buffer}\n\t// opt.cert {Buffer}\n\t// opt.onprogress(percentage)\n\t// opt.ondata(chunk, percentage)\n\n\tif (opt.ondata)\n\t\toptions.ondata = opt.ondata;\n\n\tif (opt.onprogress)\n\t\toptions.onprogress = opt.onprogress;\n\n\tif (opt.proxy)\n\t\tproxy = parseProxy(opt.proxy);\n\n\tif (opt.xhr)\n\t\topt.headers['X-Requested-With'] = 'XMLHttpRequest';\n\n\toptions.response = opt.response ? opt.response : {};\n\toptions.response.body = '';\n\toptions.iserror = false;\n\n\tif (opt.resolve || opt.dnscache)\n\t\toptions.resolve = true;\n\n\tif (opt.custom)\n\t\toptions.custom = true;\n\n\tif (opt.noredirect)\n\t\toptions.noredirect = true;\n\n\tif (opt.keepalive)\n\t\toptions.keepalive = true;\n\n\tif (opt.type) {\n\t\tswitch (opt.type) {\n\t\t\tcase 'plain':\n\t\t\t\topt.headers[CT] = 'text/plain';\n\t\t\t\tbreak;\n\t\t\tcase 'html':\n\t\t\t\topt.headers[CT] = 'text/html';\n\t\t\t\tbreak;\n\t\t\tcase 'raw':\n\t\t\t\topt.headers[CT] = 'application/octet-stream';\n\t\t\t\tbreak;\n\t\t\tcase 'json':\n\t\t\t\topt.headers[CT] = 'application/json';\n\t\t\t\tbreak;\n\t\t\tcase 'urlencoded':\n\t\t\t\topt.headers[CT] = 'application/x-www-form-urlencoded';\n\t\t\t\tbreak;\n\t\t\tcase 'xml':\n\t\t\t\topt.headers[CT] = 'text/xml';\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (opt.files) {\n\t\toptions.boundary = '----TOTALFILE_' + Math.random().toString(36).substring(3);\n\t\topt.headers[CT] = 'multipart/form-data; boundary=' + options.boundary;\n\t\toptions.files = opt.files;\n\t\toptions.upload = true;\n\n\t\t// Must be object { key: value }\n\t\tif (opt.body)\n\t\t\toptions.body = opt.body;\n\n\t} else {\n\t\tif (opt.body) {\n\t\t\tif (!(opt.body instanceof Buffer)) {\n\t\t\t\tif (opt.encrypt) {\n\t\t\t\t\topt.body = exports.encrypt_data(opt.body, opt.encrypt);\n\t\t\t\t\topt.headers['X-Encryption'] = 'a';\n\t\t\t\t}\n\t\t\t\topt.body = Buffer.from(opt.body, ENCODING);\n\t\t\t}\n\t\t\topt.headers['Content-Length'] = opt.body.length;\n\t\t}\n\t\toptions.body = opt.body;\n\t}\n\n\tif (opt.cookies) {\n\t\tvar builder = '';\n\t\tfor (var m in opt.cookies)\n\t\t\tbuilder += (builder ? '; ' : '') + m + '=' + opt.cookies[m];\n\t\tif (builder)\n\t\t\topt.headers.Cookie = builder;\n\t}\n\n\tif (opt.query) {\n\t\tif (typeof(opt.query) !== 'string')\n\t\t\topt.query = U.toURLEncode(opt.query);\n\t\tif (opt.url) {\n\t\t\tif (opt.url.lastIndexOf('?') === -1)\n\t\t\t\topt.url += '?' + opt.query;\n\t\t\telse\n\t\t\t\topt.url += '&' + opt.query;\n\t\t} else if (opt.unixsocket.path) {\n\t\t\tif (opt.unixsocket.path.lastIndexOf('?') === -1)\n\t\t\t\topt.unixsocket.path += '?' + opt.query;\n\t\t\telse\n\t\t\t\topt.unixsocket.path += '&' + opt.query;\n\t\t}\n\t}\n\n\tvar uri = opt.unixsocket ? { socketPath: opt.unixsocket.socket, path: opt.unixsocket.path } : Url.parse(opt.url);\n\n\tif ((opt.unixsocket && !uri.socketPath) || (!opt.unixsocket && (!uri.hostname || !uri.host))) {\n\t\toptions.response.canceled = true;\n\t\topt.callback && opt.callback('Invalid hostname', options.response);\n\t\treturn;\n\t}\n\n\turi.method = opt.method;\n\turi.headers = opt.headers;\n\n\tif (options.insecure) {\n\t\turi.rejectUnauthorized = false;\n\t\turi.requestCert = true;\n\t}\n\n\toptions.uri = uri;\n\toptions.opt = opt;\n\n\tif (opt.key)\n\t\turi.key = opt.key;\n\n\tif (opt.cert)\n\t\turi.cert = opt.cert;\n\n\tif (opt.dhparam)\n\t\turi.dhparam = opt.dhparam;\n\n\tif (options.resolve && (opt.unixsocket || (uri.hostname === 'localhost' || uri.hostname.charCodeAt(0) < 64)))\n\t\toptions.resolve = false;\n\n\tif (!opt.unixsocket && CONF.default_proxy && !proxy && !PROXYBLACKLIST[uri.hostname])\n\t\tproxy = parseProxy(CONF.default_proxy);\n\n\tif (!opt.unixsocket && proxy && (uri.hostname === 'localhost' || uri.hostname === '127.0.0.1'))\n\t\tproxy = null;\n\n\toptions.proxy = proxy;\n\n\tif (proxy && uri.protocol === 'https:') {\n\t\tproxy.tls = true;\n\t\turi.agent = new ProxyAgent(options);\n\t\turi.agent.request = Http.request;\n\t\turi.agent.createSocket = createSecureSocket;\n\t\turi.agent.defaultPort = 443;\n\t}\n\n\tif (options.keepalive && !options.proxy) {\n\t\tif (uri.protocol === 'https:') {\n\t\t\tif (!uri.port)\n\t\t\t\turi.port = 443;\n\t\t\turi.agent = KeepAliveHttps;\n\t\t} else\n\t\t\turi.agent = KeepAlive;\n\t} else\n\t\turi.agent = null;\n\n\tif (proxy)\n\t\trequest_call(uri, options);\n\telse if (options.resolve)\n\t\texports.resolve(opt.url, request_resolve, options);\n\telse\n\t\trequest_call(uri, options);\n};\n\nfunction request_resolve(err, uri, options, origin) {\n\tif (!err) {\n\t\toptions.uri.host = uri.host;\n\t\toptions.origin = origin;\n\t}\n\trequest_call(options.uri, options);\n}\n\nfunction ProxyAgent(options) {\n\tvar self = this;\n\tself.options = options;\n\tself.maxSockets = Http.Agent.defaultMaxSockets;\n\tself.requests = [];\n}\n\nconst PAP = ProxyAgent.prototype;\n\nPAP.createConnection = function(pending) {\n\tvar self = this;\n\tself.createSocket(pending, function(socket) {\n\t\tpending.request.onSocket(socket);\n\t});\n};\n\nPAP.createSocket = function(options, callback) {\n\n\tvar self = this;\n\tvar proxy = self.options.proxy;\n\tvar uri = self.options.uri;\n\n\tPROXYOPTIONS.host = proxy.hostname;\n\tPROXYOPTIONS.port = proxy.port;\n\tPROXYOPTIONS.path = PROXYOPTIONS.headers.host = uri.hostname + ':' + (uri.port || '443');\n\n\tif (proxy._auth)\n\t\tPROXYOPTIONS.headers['Proxy-Authorization'] = proxy._auth;\n\n\tvar req = self.request(PROXYOPTIONS);\n\treq.setTimeout(10000);\n\treq.on('response', proxyagent_response);\n\treq.on('connect', function(res, socket) {\n\n\t\tif (res.statusCode === 200) {\n\t\t\tsocket.$req = req;\n\t\t\tcallback(socket);\n\t\t} else {\n\t\t\tvar err = new Error('Proxy could not be established (maybe a problem in auth), code: ' + res.statusCode);\n\t\t\terr.code = 'ECONNRESET';\n\t\t\treq.destroy && req.destroy();\n\t\t\treq = null;\n\t\t\tself.requests = null;\n\t\t\tself.options = null;\n\t\t}\n\n\t});\n\n\treq.on('error', function(err) {\n\t\tvar e = new Error('Request Proxy \"proxy {0} --> target {1}\": {2}'.format(PROXYOPTIONS.host + ':' + proxy.port, PROXYOPTIONS.path, err.toString()));\n\t\te.code = err.code;\n\t\treq.destroy && req.destroy();\n\t\treq = null;\n\t\tself.requests = null;\n\t\tself.options = null;\n\t});\n\n\treq.end();\n};\n\nfunction proxyagent_response(res) {\n\tres.upgrade = true;\n}\n\nPAP.addRequest = function(req, options) {\n\tthis.createConnection({ host: options.host, port: options.port, request: req });\n};\n\nfunction createSecureSocket(options, callback) {\n\tvar self = this;\n\tPAP.createSocket.call(self, options, function(socket) {\n\t\tPROXYTLS.servername = self.options.uri.hostname;\n\t\tPROXYTLS.headers = self.options.uri.headers;\n\t\tPROXYTLS.socket = socket;\n\t\tvar tls = Tls.connect(0, PROXYTLS);\n\t\tcallback(tls);\n\t});\n}\n\nfunction request_call(uri, options) {\n\n\tvar opt;\n\n\tif (options.proxy && !options.proxy.tls) {\n\t\topt = PROXYOPTIONSHTTP;\n\t\topt.port = options.proxy.port;\n\t\topt.host = options.proxy.hostname;\n\t\topt.path = uri.href;\n\t\topt.headers = uri.headers;\n\t\topt.method = uri.method;\n\t\topt.headers.host = uri.host;\n\t\tif (options.proxy._auth)\n\t\t\topt.headers['Proxy-Authorization'] = options.proxy._auth;\n\t} else\n\t\topt = uri;\n\n\tvar connection = uri.protocol === 'https:' ? Https : Http;\n\tvar req = opt.method === 'GET' ? connection.get(opt, request_response) : connection.request(opt, request_response);\n\n\treq.$options = options;\n\treq.$uri = uri;\n\n\tif (!options.callback) {\n\t\treq.on('error', NOOP);\n\t\treturn;\n\t}\n\n\treq.on('error', request_process_error);\n\toptions.timeoutid && clearTimeout(options.timeoutid);\n\toptions.timeoutid = setTimeout(request_process_timeout, options.timeout, req);\n\n\treq.on('response', request_assign_res);\n\n\tif (options.upload) {\n\t\toptions.first = true;\n\t\toptions.files.wait(function(file, next) {\n\t\t\trequest_writefile(req, options, file, next);\n\t\t}, function() {\n\n\t\t\tif (options.iserror)\n\t\t\t\treturn;\n\n\t\t\tif (options.body) {\n\t\t\t\tfor (var key in options.body) {\n\t\t\t\t\tvar value = options.body[key];\n\t\t\t\t\tif (value != null) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\treq.write((options.first ? '' : NEWLINE) + '--' + options.boundary + NEWLINE + 'Content-Disposition: form-data; name=\"' + key + '\"' + NEWLINE + NEWLINE + value);\n\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\trequest_process_error.apply(req, e);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (options.first)\n\t\t\t\t\t\t\toptions.first = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treq.end(NEWLINE + '--' + options.boundary + '--');\n\t\t});\n\t} else\n\t\treq.end(options.body);\n}\n\nfunction request_process_error(err) {\n\tvar options = this.$options;\n\toptions.iserror = true;\n\tif (options.callback && !options.done) {\n\t\tif (options.timeoutid) {\n\t\t\tclearTimeout(options.timeoutid);\n\t\t\toptions.timeoutid = null;\n\t\t}\n\t\toptions.canceled = true;\n\t\toptions.response.status = 0;\n\t\toptions.response.host = this.$uri.host;\n\t\toptions.callback(err, options.response);\n\t\toptions.callback = null;\n\t}\n}\n\nfunction request_process_timeout(req) {\n\tvar options = req.$options;\n\toptions.iserror = true;\n\tif (options.callback) {\n\t\tif (options.timeoutid) {\n\t\t\tclearTimeout(options.timeoutid);\n\t\t\toptions.timeoutid = null;\n\t\t}\n\t\treq.socket.destroy();\n\t\treq.socket.end();\n\t\treq.destroy();\n\t\toptions.response.status = 408;\n\t\toptions.response.host = req.$uri.host;\n\t\toptions.canceled = true;\n\t\toptions.callback(exports.httpstatus(408), options.response);\n\t\toptions.callback = null;\n\t}\n}\n\nfunction request_process_ok() {\n\tvar options = this.req.$options;\n\tif (options.timeoutid) {\n\t\tclearTimeout(options.timeoutid);\n\t\toptions.timeoutid = null;\n\t}\n}\n\nfunction request_assign_res(response) {\n\tresponse.req = this;\n}\n\nfunction request_writefile(req, options, file, next) {\n\n\tif (options.iserror) {\n\t\tnext();\n\t\treturn;\n\t}\n\n\tvar isbuffer = file.buffer instanceof Buffer;\n\tvar filename = (isbuffer ? file.name : exports.getName(file.filename));\n\n\treq.write((options.first ? '' : NEWLINE) + '--' + options.boundary + NEWLINE + 'Content-Disposition: form-data; name=\"' + file.name + '\"; filename=\"' + filename + '\"' + NEWLINE + 'Content-Type: ' + exports.getContentType(exports.getExtension(filename)) + NEWLINE + NEWLINE);\n\n\tif (options.first)\n\t\toptions.first = false;\n\n\tif (isbuffer) {\n\t\ttry {\n\t\t\treq.write(file.buffer);\n\t\t} catch (e) {\n\t\t\trequest_process_error.apply(req, e);\n\t\t}\n\t\tnext();\n\t} else {\n\t\tvar stream = Fs.createReadStream(file.filename);\n\t\tstream.once('close', next);\n\t\tstream.pipe(req, STREAMPIPE);\n\t}\n}\n\nfunction request_response(res) {\n\n\tvar options = this.$options;\n\tvar uri = this.$uri;\n\n\tres._buffer = null;\n\tres._bufferlength = 0;\n\n\t// We have redirect\n\tif (res.statusCode === 301 || res.statusCode === 302) {\n\n\t\tif (options.noredirect) {\n\t\t\toptions.timeoutid && clearTimeout(options.timeoutid);\n\t\t\toptions.canceled = true;\n\t\t\tif (options.callback) {\n\t\t\t\toptions.response.origin = options.origin;\n\t\t\t\toptions.response.status = res.statusCode;\n\t\t\t\toptions.response.headers = res.headers;\n\t\t\t\tif (options.custom) {\n\t\t\t\t\toptions.response.stream = res;\n\t\t\t\t\toptions.callback(null, options.response);\n\t\t\t\t} else {\n\t\t\t\t\toptions.response.host = uri.host;\n\t\t\t\t\toptions.response.headers = res.headers;\n\t\t\t\t\toptions.callback(null, options.response);\n\t\t\t\t}\n\t\t\t\toptions.callback = null;\n\t\t\t}\n\n\t\t\tres.req.removeAllListeners();\n\t\t\tres.removeAllListeners();\n\t\t\tres.req = null;\n\t\t\tres = null;\n\t\t\treturn;\n\t\t}\n\n\t\tif (options.redirect > (options.redirects || 3)) {\n\n\t\t\toptions.timeoutid && clearTimeout(options.timeoutid);\n\t\t\toptions.canceled = true;\n\t\t\toptions.response.origin = options.origin;\n\t\t\toptions.response.headers = res.headers;\n\n\t\t\tif (options.callback) {\n\t\t\t\tif (options.custom) {\n\t\t\t\t\toptions.response.status = res.statusCode;\n\t\t\t\t\toptions.response.stream = res;\n\t\t\t\t\toptions.callback('Too many redirects', options.response);\n\t\t\t\t} else {\n\t\t\t\t\toptions.response.status = 0;\n\t\t\t\t\toptions.response.host = uri.host;\n\t\t\t\t\toptions.callback('Too many redirects', options.response);\n\t\t\t\t}\n\t\t\t\toptions.callback = null;\n\t\t\t}\n\n\t\t\tres.req.removeAllListeners();\n\t\t\tres.removeAllListeners();\n\t\t\tres.req = null;\n\t\t\tres = null;\n\t\t\treturn;\n\t\t}\n\n\t\toptions.redirect++;\n\n\t\tvar loc = res.headers.location;\n\t\tvar proto = loc.substring(0, 6);\n\n\t\tif (proto !== 'http:/' && proto !== 'https:')\n\t\t\tloc = uri.protocol + '//' + uri.hostname + (uri.port && !SKIPPORTS[uri.port] ? (':' + uri.port) : '') + loc;\n\n\t\tvar tmp = Url.parse(loc);\n\t\ttmp.headers = uri.headers;\n\n\t\t// Transfers cookies\n\t\tif (!options.nocookies) {\n\t\t\tvar cookies = res.headers['set-cookie'];\n\t\t\tif (cookies) {\n\n\t\t\t\tif (options.$totalinit.cook && !options.$totalinit.cookies)\n\t\t\t\t\toptions.$totalinit.cookies = {};\n\n\t\t\t\tif (!options.cookies)\n\t\t\t\t\toptions.cookies = {};\n\n\t\t\t\tfor (var i = 0; i < cookies.length; i++) {\n\t\t\t\t\tvar cookie = cookies[i];\n\t\t\t\t\tvar index = cookie.indexOf(';');\n\t\t\t\t\tif (index !== -1){\n\t\t\t\t\t\tcookie = cookie.substring(0, index);\n\t\t\t\t\t\tindex = cookie.indexOf('=');\n\t\t\t\t\t\tif (index !== -1) {\n\t\t\t\t\t\t\tvar key = decodeURIComponent(cookie.substring(0, index));\n\t\t\t\t\t\t\toptions.cookies[key] = decodeURIComponent(cookie.substring(index + 1));\n\t\t\t\t\t\t\tif (options.$totalinit.cookies)\n\t\t\t\t\t\t\t\toptions.$totalinit.cookies[key] = options.cookies[key];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tvar builder = '';\n\t\t\t\tfor (var m in options.cookies)\n\t\t\t\t\tbuilder += (builder ? '; ' : '') + encodeURIComponent(m) + '=' + encodeURIComponent(options.cookies[m]);\n\n\t\t\t\tif (tmp.headers.cookie)\n\t\t\t\t\ttmp.headers.cookie = builder;\n\t\t\t\telse\n\t\t\t\t\ttmp.headers.Cookie = builder;\n\t\t\t}\n\t\t}\n\n\t\t// tmp.agent = false;\n\t\ttmp.method = uri.method;\n\n\t\tres.req.removeAllListeners();\n\t\tres.req = null;\n\n\t\tif (options.proxy && tmp.protocol === 'https:') {\n\t\t\t// TLS?\n\t\t\toptions.proxy.tls = true;\n\t\t\toptions.uri = tmp;\n\t\t\toptions.uri.agent = new ProxyAgent(options);\n\t\t\toptions.uri.agent.request = Http.request;\n\t\t\toptions.uri.agent.createSocket = createSecureSocket;\n\t\t\toptions.uri.agent.defaultPort = 443;\n\t\t}\n\n\t\tif (!options.resolve) {\n\t\t\tres.removeAllListeners();\n\t\t\tres = null;\n\t\t\treturn request_call(tmp, options);\n\t\t}\n\n\t\texports.resolve(tmp, function(err, u, param, origin) {\n\t\t\tif (!err) {\n\t\t\t\ttmp.host = u.host;\n\t\t\t\toptions.origin = origin;\n\t\t\t}\n\t\t\tres.removeAllListeners();\n\t\t\tres = null;\n\t\t\trequest_call(tmp, options);\n\t\t});\n\n\t\treturn;\n\t}\n\n\toptions.length = +res.headers['content-length'] || 0;\n\n\t// Shared cookies\n\tif (options.$totalinit.cook) {\n\n\t\tif (!options.$totalinit.cookies)\n\t\t\toptions.$totalinit.cookies = {};\n\n\t\tvar arr = (res.headers['set-cookie'] || '');\n\n\t\t// Only the one value\n\t\tif (arr && !(arr instanceof Array))\n\t\t\tarr = [arr];\n\n\t\tif (arr instanceof Array) {\n\t\t\tfor (var i = 0; i < arr.length; i++) {\n\t\t\t\tvar line = arr[i];\n\t\t\t\tvar end = line.indexOf(';');\n\t\t\t\tif (end === -1)\n\t\t\t\t\tend = line.length;\n\t\t\t\tline = line.substring(0, end);\n\t\t\t\tvar index = line.indexOf('=');\n\t\t\t\tif (index !== -1)\n\t\t\t\t\toptions.$totalinit.cookies[line.substring(0, index)] = decodeURIComponent(line.substring(index + 1));\n\t\t\t}\n\t\t}\n\t}\n\n\tif (res.statusCode === 204) {\n\t\toptions.done = true;\n\t\tif (options.custom) {\n\t\t\toptions.timeoutid && clearTimeout(options.timeoutid);\n\t\t\toptions.response.origin = options.origin;\n\t\t\toptions.response.status = res.statusCode;\n\t\t\toptions.response.headers = res.headers;\n\t\t\toptions.response.stream = res;\n\t\t\toptions.callback(null, options.response);\n\t\t\toptions.callback = null;\n\t\t} else\n\t\t\trequest_process_end.call(res);\n\t\treturn;\n\t}\n\n\toptions.timeoutid && res.once('data', request_process_ok);\n\n\tvar encoding = res.headers['content-encoding'] || '';\n\tif (encoding)\n\t\tencoding = encoding.split(',')[0];\n\n\tif (options.custom) {\n\t\toptions.timeoutid && clearTimeout(options.timeoutid);\n\t\toptions.response.origin = options.origin;\n\t\toptions.response.status = res.statusCode;\n\t\toptions.response.headers = res.headers;\n\t\toptions.response.stream = res;\n\t\toptions.callback && options.callback(null, options.response);\n\t\toptions.callback = null;\n\t} else {\n\t\tif (COMPRESS[encoding]) {\n\t\t\tvar zlib = encoding === 'gzip' ? Zlib.createGunzip() : Zlib.createInflate();\n\t\t\tzlib._buffer = res.buffer;\n\t\t\tzlib.headers = res.headers;\n\t\t\tzlib.statusCode = res.statusCode;\n\t\t\tzlib.res = res;\n\t\t\tzlib.on('data', request_process_data);\n\t\t\tzlib.on('end', request_process_end);\n\t\t\tres.pipe(zlib);\n\t\t} else {\n\t\t\tres.on('data', request_process_data);\n\t\t\tres.on('end', request_process_end);\n\t\t}\n\t}\n\n\tres.resume();\n}\n\nfunction request_process_data(chunk) {\n\tvar self = this;\n\t// Is Zlib\n\tif (!self.req)\n\t\tself = self.res;\n\tvar options = self.req.$options;\n\tif (options.canceled || (options.limit && self._bufferlength > options.limit))\n\t\treturn;\n\tif (self._buffer) {\n\t\tCONCAT[0] = self._buffer;\n\t\tCONCAT[1] = chunk;\n\t\tself._buffer = Buffer.concat(CONCAT);\n\t} else\n\t\tself._buffer = chunk;\n\tself._bufferlength += chunk.length;\n\toptions.ondata && options.ondata(chunk, options.length ? (self._bufferlength / options.length) * 100 : 0);\n\toptions.onprogress && options.onprogress(options.length ? (self._bufferlength / options.length) * 100 : 0);\n}\n\nfunction request_process_end() {\n\n\tvar res = this;\n\n\t// Is Zlib\n\tif (!res.req)\n\t\tres = res.res;\n\n\tvar self = res;\n\tvar options = self.req.$options;\n\tvar uri = self.req.$uri;\n\tvar data;\n\n\toptions.socket && options.uri.agent.destroy();\n\toptions.timeoutid && clearTimeout(options.timeoutid);\n\n\tif (options.canceled)\n\t\treturn;\n\n\tvar ct = self.headers['content-type'];\n\n\tif (!ct || REG_TEXTAPPLICATION.test(ct)) {\n\t\tdata = self._buffer ? options.encoding === 'binary' ? self._buffer : self._buffer.toString(options.encoding) : '';\n\t\tif (options.opt.encrypt && typeof(data) === 'string')\n\t\t\tdata = exports.decrypt_data(data, options.opt.encrypt);\n\t} else\n\t\tdata = self._buffer;\n\n\toptions.canceled = true;\n\tself._buffer = undefined;\n\n\tif (options.callback) {\n\t\toptions.response.origin = options.origin;\n\t\toptions.response.headers = self.headers;\n\t\toptions.response.body = data;\n\t\toptions.response.status = self.statusCode;\n\t\toptions.response.host = uri.host || uri.socketPath;\n\t\toptions.response.cookies = options.cookies;\n\t\toptions.callback(null, options.response);\n\t\toptions.callback = null;\n\t}\n\n\tif (res.statusCode !== 204) {\n\t\tres.req && res.req.removeAllListeners();\n\t\tres.removeAllListeners();\n\t}\n}\n\nexports.btoa = function(str) {\n\treturn (str instanceof Buffer) ? str.toString('base64') : Buffer.from(str.toString(), 'utf8').toString('base64');\n};\n\nexports.atob = function(str) {\n\treturn Buffer.from(str, 'base64').toString('utf8');\n};\n\n/**\n * Trim string properties\n * @param {Object} obj\n * @return {Object}\n */\nexports.trim = function(obj, clean) {\n\n\tif (!obj)\n\t\treturn obj;\n\n\tvar type = typeof(obj);\n\tif (type === 'string') {\n\t\tobj = obj.trim();\n\t\treturn clean && !obj ? undefined : obj;\n\t}\n\n\tif (obj instanceof Array) {\n\t\tfor (var i = 0, length = obj.length; i < length; i++) {\n\n\t\t\tvar item = obj[i];\n\t\t\ttype = typeof(item);\n\n\t\t\tif (type === 'object') {\n\t\t\t\texports.trim(item, clean);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (type !== 'string')\n\t\t\t\tcontinue;\n\n\t\t\tobj[i] = item.trim();\n\t\t\tif (clean && !obj[i])\n\t\t\t\tobj[i] = undefined;\n\t\t}\n\n\t\treturn obj;\n\t}\n\n\tif (type !== 'object')\n\t\treturn obj;\n\n\tfor (var key in obj) {\n\t\tvar val = obj[key];\n\t\tvar type = typeof(val);\n\t\tif (type === 'object') {\n\t\t\texports.trim(val, clean);\n\t\t\tcontinue;\n\t\t} else if (type !== 'string')\n\t\t\tcontinue;\n\t\tobj[key] = val.trim();\n\t\tif (clean && !obj[key])\n\t\t\tobj[key] = undefined;\n\t}\n\n\treturn obj;\n};\n\n/**\n * Noop function\n * @return {Function} Empty function.\n */\nglobal.NOOP = function() {};\n\n/**\n * Read HTTP status\n * @param  {Number} code HTTP code status.\n * @param  {Boolean} addCode Add code number to HTTP status.\n * @return {String}\n */\nexports.httpstatus = function(code, addCode) {\n\tif (addCode === undefined)\n\t\taddCode = true;\n\treturn (addCode ? code + ': ' : '') + Http.STATUS_CODES[code];\n};\n\n/**\n * Extend object\n * @param {Object} target Target object.\n * @param {Object} source Source object.\n * @param {Boolean} rewrite Rewrite exists values (optional, default true).\n * @return {Object} Modified object.\n */\nexports.extend = function(target, source, rewrite) {\n\n\tif (!target || !source)\n\t\treturn target;\n\n\tif (typeof(target) !== 'object' || typeof(source) !== 'object')\n\t\treturn target;\n\n\tif (rewrite === undefined)\n\t\trewrite = true;\n\n\tfor (var key in source) {\n\t\tif (rewrite || target[key] === undefined)\n\t\t\ttarget[key] = exports.clone(source[key]);\n\t}\n\n\treturn target;\n};\n\nexports.extend_headers = function(first, second) {\n\tvar keys = Object.keys(first);\n\tvar headers = {};\n\n\tvar i = keys.length;\n\twhile (i--)\n\t\theaders[keys[i]] = first[keys[i]];\n\n\tkeys = Object.keys(second);\n\ti = keys.length;\n\n\twhile (i--)\n\t\theaders[keys[i]] = second[keys[i]];\n\n\treturn headers;\n};\n\nexports.extend_headers2 = function(first, second) {\n\tvar keys = Object.keys(second);\n\tvar i = keys.length;\n\twhile (i--)\n\t\tfirst[keys[i]] = second[keys[i]];\n\treturn first;\n};\n\n/**\n * Clones object\n * @param {Object} obj\n * @param {Object} skip Optional, can be only object e.g. { name: true, age: true }.\n * @param {Boolean} skipFunctions It doesn't clone functions, optional --> default false.\n * @return {Object}\n */\nglobal.CLONE = exports.clone = function(obj, skip, skipFunctions) {\n\n\tif (!obj)\n\t\treturn obj;\n\n\tvar type = typeof(obj);\n\tif (type !== 'object' || obj instanceof Date || obj instanceof Error)\n\t\treturn obj;\n\n\tvar length;\n\tvar o;\n\n\tif (obj instanceof Array) {\n\n\t\tlength = obj.length;\n\t\to = new Array(length);\n\n\t\tfor (var i = 0; i < length; i++) {\n\t\t\ttype = typeof(obj[i]);\n\t\t\tif (type !== 'object' || obj[i] instanceof Date || obj[i] instanceof Error) {\n\t\t\t\tif (skipFunctions && type === 'function')\n\t\t\t\t\tcontinue;\n\t\t\t\to[i] = obj[i];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\to[i] = exports.clone(obj[i], skip, skipFunctions);\n\t\t}\n\n\t\treturn o;\n\t}\n\n\to = {};\n\n\tfor (var m in obj) {\n\n\t\tif (skip && skip[m])\n\t\t\tcontinue;\n\n\t\tvar val = obj[m];\n\n\t\tif (val instanceof Buffer) {\n\t\t\tvar copy = Buffer.alloc(val.length);\n\t\t\tval.copy(copy);\n\t\t\to[m] = copy;\n\t\t\tcontinue;\n\t\t}\n\n\t\tvar type = typeof(val);\n\t\tif (type !== 'object' || val instanceof Date || val instanceof Error) {\n\t\t\tif (skipFunctions && type === 'function')\n\t\t\t\tcontinue;\n\t\t\to[m] = val;\n\t\t\tcontinue;\n\t\t}\n\n\t\to[m] = exports.clone(obj[m], skip, skipFunctions);\n\t}\n\n\treturn o;\n};\n\n/**\n * Copy values from object to object\n * @param {Object} source Object source\n * @param {Object} target Object target (optional)\n * @return {Object} Modified object.\n */\nexports.copy = function(source, target) {\n\n\tif (target === undefined)\n\t\treturn exports.extend({}, source, true);\n\n\tif (!target || !source || typeof(target) !== 'object' || typeof(source) !== 'object')\n\t\treturn target;\n\n\tfor (var key in source) {\n\t\tif (target[key] !== undefined)\n\t\t\ttarget[key] = exports.clone(source[key]);\n\t}\n\n\treturn target;\n};\n\n/**\n * Reduces an object\n * @param {Object} source Source object.\n * @param {String Array or Object} prop Other properties than these ones will be removed.\n * @param {Boolean} reverse Reverse reducing (prop will be removed), default: false.\n * @return {Object}\n */\nexports.reduce = function(source, prop, reverse) {\n\n\tif (!(prop instanceof Array)) {\n\t\tif (typeof(prop) === 'object')\n\t\t\treturn exports.reduce(source, Object.keys(prop), reverse);\n\t}\n\n\tif (source instanceof Array) {\n\t\tvar arr = [];\n\t\tfor (var i = 0, length = source.length; i < length; i++)\n\t\t\tarr.push(exports.reduce(source[i], prop, reverse));\n\t\treturn arr;\n\t}\n\n\tvar output = {};\n\n\tfor (var o in source) {\n\t\tif (reverse) {\n\t\t\tif (prop.indexOf(o) === -1)\n\t\t\t\toutput[o] = source[o];\n\t\t} else {\n\t\t\tif (prop.indexOf(o) !== -1)\n\t\t\t\toutput[o] = source[o];\n\t\t}\n\t}\n\n\treturn output;\n};\n\n/**\n * Checks if is relative url\n * @param {String} url\n * @return {Boolean}\n */\nexports.isrelative = function(url) {\n\treturn !(url.substring(0, 2) === '//' || url.indexOf('http://') !== -1 || url.indexOf('https://') !== -1);\n};\n\n/**\n * Streamer method\n * @param {String/Buffer} beg\n * @param {String/Buffer} end\n * @param {Function(value, index)} callback\n */\nexports.streamer = function(beg, end, callback, skip, stream, raw) {\n\n\tif (typeof(end) === 'function') {\n\t\tstream = skip;\n\t\tskip = callback;\n\t\tcallback = end;\n\t\tend = undefined;\n\t}\n\n\tif (typeof(skip) === 'object') {\n\t\tstream = skip;\n\t\tskip = 0;\n\t}\n\n\tvar indexer = 0;\n\tvar buffer = Buffer.alloc(0);\n\tvar canceled = false;\n\tvar fn;\n\n\tif (skip === undefined)\n\t\tskip = 0;\n\n\tif (!(beg instanceof Buffer))\n\t\tbeg = Buffer.from(beg, 'utf8');\n\n\tif (end && !(end instanceof Buffer))\n\t\tend = Buffer.from(end, 'utf8');\n\n\tif (!end) {\n\t\tvar length = beg.length;\n\t\tfn = function(chunk) {\n\n\t\t\tif (!chunk || canceled)\n\t\t\t\treturn;\n\n\t\t\tCONCAT[0] = buffer;\n\t\t\tCONCAT[1] = chunk;\n\n\t\t\tvar f = 0;\n\n\t\t\tif (buffer.length) {\n\t\t\t\tf = buffer.length - beg.length;\n\t\t\t\tif (f < 0)\n\t\t\t\t\tf = 0;\n\t\t\t}\n\n\t\t\tbuffer = Buffer.concat(CONCAT);\n\n\t\t\tvar index = buffer.indexOf(beg, f);\n\t\t\tif (index === -1)\n\t\t\t\treturn;\n\n\t\t\twhile (index !== -1) {\n\n\t\t\t\tif (skip)\n\t\t\t\t\tskip--;\n\t\t\t\telse {\n\t\t\t\t\tif (callback(raw ? buffer.slice(0, index + length) : buffer.toString('utf8', 0, index + length), indexer++) === false)\n\t\t\t\t\t\tcanceled = true;\n\t\t\t\t}\n\n\t\t\t\tif (canceled)\n\t\t\t\t\treturn;\n\n\t\t\t\tbuffer = buffer.slice(index + length);\n\t\t\t\tindex = buffer.indexOf(beg);\n\t\t\t\tif (index === -1)\n\t\t\t\t\treturn;\n\t\t\t}\n\t\t};\n\n\t\tstream && stream.on('end', () => fn(beg));\n\t\treturn fn;\n\t}\n\n\tvar blength = beg.length;\n\tvar elength = end.length;\n\tvar bi = -1;\n\tvar ei = -1;\n\tvar is = false;\n\n\tfn = function(chunk) {\n\n\t\tif (!chunk || canceled)\n\t\t\treturn;\n\n\t\tCONCAT[0] = buffer;\n\t\tCONCAT[1] = chunk;\n\t\tbuffer = Buffer.concat(CONCAT);\n\n\t\tif (!is) {\n\t\t\tvar f = CONCAT[0].length - beg.length;\n\t\t\tif (f < 0)\n\t\t\t\tf = 0;\n\t\t\tbi = buffer.indexOf(beg, f);\n\t\t\tif (bi === -1)\n\t\t\t\treturn;\n\t\t\tis = true;\n\t\t}\n\n\t\tif (is) {\n\t\t\tei = buffer.indexOf(end, bi + blength);\n\t\t\tif (ei === -1)\n\t\t\t\treturn;\n\t\t}\n\n\t\twhile (bi !== -1) {\n\n\t\t\tif (skip)\n\t\t\t\tskip--;\n\t\t\telse {\n\t\t\t\tif (callback(raw ? buffer.slice(bi, ei + elength) : buffer.toString('utf8', bi, ei + elength), indexer++) === false)\n\t\t\t\t\tcanceled = true;\n\t\t\t}\n\n\t\t\tif (canceled)\n\t\t\t\treturn;\n\n\t\t\tbuffer = buffer.slice(ei + elength);\n\t\t\tis = false;\n\t\t\tbi = buffer.indexOf(beg);\n\t\t\tif (bi === -1)\n\t\t\t\treturn;\n\t\t\tis = true;\n\t\t\tei = buffer.indexOf(end, bi + blength);\n\t\t\tif (ei === -1)\n\t\t\t\treturn;\n\t\t}\n\t};\n\n\tstream && stream.on('end', () => fn(end));\n\treturn fn;\n};\n\nexports.streamer2 = function(beg, end, callback, skip, stream) {\n\treturn exports.streamer(beg, end, callback, skip, stream, true);\n};\n\n/**\n * HTML encode string\n * @param {String} str\n * @return {String}\n */\nexports.encode = function(str) {\n\n\tif (str == null)\n\t\treturn '';\n\n\tvar type = typeof(str);\n\tif (type !== 'string')\n\t\tstr = str.toString();\n\n\treturn str.encode();\n};\n\n/**\n * HTML decode string\n * @param {String} str\n * @return {String}\n */\nexports.decode = function(str) {\n\n\tif (str == null)\n\t\treturn '';\n\n\tvar type = typeof(str);\n\tif (type !== 'string')\n\t\tstr = str.toString();\n\n\treturn str.decode();\n};\n\n/**\n * Checks if URL contains file extension.\n * @param {String} url\n * @return {Boolean}\n */\nexports.isStaticFile = function(url) {\n\tvar index = url.indexOf('.', url.length - 8);\n\treturn index !== -1;\n};\n\n/**\n * Converts Value to number\n * @param {Object} obj Value to convert.\n * @param {Number} def Default value (default: 0).\n * @return {Number}\n */\nexports.parseInt = function(obj, def) {\n\tif (obj == null || obj === '')\n\t\treturn def === undefined ? 0 : def;\n\tvar type = typeof(obj);\n\treturn type === 'number' ? obj : (type !== 'string' ? obj.toString() : obj).parseInt(def);\n};\n\nexports.parseBoolean = function(obj, def) {\n\tif (obj == null)\n\t\treturn def === undefined ? false : def;\n\tvar type = typeof(obj);\n\treturn type === 'boolean' ? obj : type === 'number' ? obj > 0 : (type !== 'string' ? obj.toString() : obj).parseBoolean(def);\n};\n\n/**\n * Converts Value to float number\n * @param {Object} obj Value to convert.\n * @param {Number} def Default value (default: 0).\n * @return {Number}\n */\nexports.parseFloat = function(obj, def) {\n\tif (obj == null || obj === '')\n\t\treturn def === undefined ? 0 : def;\n\tvar type = typeof(obj);\n\treturn type === 'number' ? obj : (type !== 'string' ? obj.toString() : obj).parseFloat(def);\n};\n\n/**\n * Check if the object is Date\n * @param {Object} obj\n * @return {Boolean}\n */\nexports.isDate = function(obj) {\n\treturn obj instanceof Date && !isNaN(obj.getTime()) ? true : false;\n};\n\n/**\n * Get ContentType from file extension.\n * @param {String} ext File extension.\n * @return {String}\n */\nexports.getContentType = function(ext) {\n\tif (ext[0] === '.')\n\t\text = ext.substring(1);\n\treturn CONTENTTYPES[ext] || 'application/octet-stream';\n};\n\n/**\n * Get extension from filename\n * @param {String} filename\n * @return {String}\n */\nexports.getExtension = function(filename, raw) {\n\tvar end = filename.length;\n\tfor (var i = filename.length - 1; i > 0; i--) {\n\t\tvar c = filename[i];\n\t\tif (c === ' ' || c === '?')\n\t\t\tend = i;\n\t\telse if (c === '.') {\n\t\t\tc = filename.substring(i + 1, end);\n\t\t\treturn raw ? c : c.toLowerCase();\n\t\t}\n\t\telse if (c === '/' || c === '\\\\')\n\t\t\treturn '';\n\t}\n\treturn '';\n};\n\n/**\n * Get base name from path\n * @param {String} path\n * @return {String}\n */\nexports.getName = function(path) {\n\tvar l = path.length - 1;\n\tvar c = path[l];\n\tif (c === '/' || c === '\\\\')\n\t\tpath = path.substring(0, l);\n\tvar index = path.lastIndexOf('/');\n\tif (index !== -1)\n\t\treturn path.substring(index + 1);\n\tindex = path.lastIndexOf('\\\\');\n\treturn index === -1 ? path : path.substring(index + 1);\n};\n\n/**\n * Add a new content type to content types\n * @param {String} ext File extension.\n * @param {String} type Content type (example: application/json).\n */\nexports.setContentType = function(ext, type) {\n\tif (ext[0] === '.')\n\t\text = ext.substring(1);\n\n\tif (ext.length > 8) {\n\t\tvar tmp = regexpSTATIC.toString().replace(/,\\d+\\}/, ',' + ext.length + '}').substring(1);\n\t\tregexpSTATIC = new RegExp(tmp.substring(0, tmp.length - 1));\n\t}\n\n\tCONTENTTYPES[ext] = type;\n\treturn true;\n};\n\nexports.normalize = function(path) {\n\tif (path[0] !== '/')\n\t\tpath = '/' + path;\n\tif (path[path.length - 1] !== '/')\n\t\tpath += '/';\n\treturn path;\n};\n\nexports.link = function() {\n\tvar builder = '';\n\tfor (var i = 0; i < arguments.length; i++) {\n\n\t\tvar url = arguments[i];\n\t\tvar between = '';\n\n\t\tif (builder) {\n\t\t\tvar c = builder[builder.length - 1];\n\t\t\tif (c === '/') {\n\t\t\t\tif (url[0] === '/')\n\t\t\t\t\turl = url.substring(1);\n\t\t\t} else {\n\t\t\t\tif (url[0] !== '/')\n\t\t\t\t\tbetween = '/';\n\t\t\t}\n\t\t} else\n\t\t\tbetween = '';\n\n\t\tbuilder += between + url;\n\t}\n\treturn builder;\n};\n\nexports.path = function(path, delimiter) {\n\tif (!path)\n\t\tpath = '';\n\tdelimiter = delimiter || '/';\n\treturn path[path.length - 1] === delimiter ? path : path + delimiter;\n};\n\nexports.join = function() {\n\tvar path = [''];\n\n\tfor (var i = 0; i < arguments.length; i++) {\n\t\tvar current = arguments[i];\n\t\tif (current) {\n\t\t\tif (current[0] === '/')\n\t\t\t\tcurrent = current.substring(1);\n\t\t\tvar l = current.length - 1;\n\t\t\tif (current[l] === '/')\n\t\t\t\tcurrent = current.substring(0, l);\n\t\t\tpath.push(current);\n\t\t}\n\t}\n\n\tpath = path.join('/');\n\treturn !isWindows ? path : path.indexOf(':') > -1 ? path.substring(1) : path;\n};\n\n/**\n * Prepares Windows path to UNIX like format\n * @internal\n * @param {String} path\n * @return {String}\n */\nexports.$normalize = function(path) {\n\treturn isWindows ? path.replace(regexpPATH, '/') : path;\n};\n\nconst RANDOM_STRING = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split('');\nconst RANDOM_NUMBER = '0123456789';\n\nexports.random_string = function(max) {\n\tvar builder = '';\n\tfor (var i = 0; i < max; i++) {\n\t\tvar index = Math.floor(Math.random() * RANDOM_STRING.length);\n\t\tbuilder += RANDOM_STRING[index];\n\t}\n\treturn builder;\n};\n\nexports.random_number = function(max) {\n\tvar builder = '';\n\tfor (var i = 0; i < max; i++) {\n\t\tvar index = Math.floor(Math.random() * RANDOM_NUMBER.length);\n\t\tif (!i && !index)\n\t\t\tindex++;\n\t\tbuilder += RANDOM_NUMBER[index];\n\t}\n\treturn builder;\n};\n\nexports.random = function(max, min) {\n\tmax = (max || 100000);\n\tmin = (min || 0);\n\treturn Math.floor(Math.random() * (max - min + 1)) + min;\n};\n\nfunction rnd() {\n\treturn Math.floor(Math.random() * 65536).toString(36);\n}\n\nglobal.GUID = exports.GUID = function(max) {\n\tmax = max || 40;\n\tvar str = '';\n\tfor (var i = 0; i < (max / 3) + 1; i++)\n\t\tstr += rnd();\n\treturn str.substring(0, max);\n};\n\nfunction validate_builder_default(name, value, entity) {\n\n\tvar type = typeof(value);\n\n\tif (entity.type === 12)\n\t\treturn value != null && type === 'object' && !(value instanceof Array);\n\n\tif (entity.type === 11)\n\t\treturn type === 'number';\n\n\t// Enum + KeyValue + Custom (8+9+10)\n\tif (entity.type > 7)\n\t\treturn value !== undefined;\n\n\tswitch (entity.subtype) {\n\t\tcase 'uid':\n\t\t\treturn value.isUID();\n\t\tcase 'zip':\n\t\t\treturn value.isZIP();\n\t\tcase 'email':\n\t\t\treturn value.isEmail();\n\t\tcase 'json':\n\t\t\treturn value.isJSON();\n\t\tcase 'url':\n\t\t\treturn value.isURL();\n\t\tcase 'phone':\n\t\t\treturn value.isPhone();\n\t\tcase 'base64':\n\t\t\treturn value.isBase64(true);\n\t}\n\n\tif (type === 'number')\n\t\treturn value > 0;\n\n\tif (type === 'string' || value instanceof Array)\n\t\treturn value.length > 0;\n\n\tif (type === 'boolean')\n\t\treturn value === true;\n\n\tif (value == null)\n\t\treturn false;\n\n\tif (value instanceof Date)\n\t\treturn value.toString()[0] !== 'I'; // Invalid Date\n\n\treturn true;\n}\n\nexports.validate_builder = function(model, error, schema, path, index, $, pluspath) {\n\n\tvar current = path ? path + '.' : '';\n\tvar properties = $ ? ($.keys || schema.properties) : schema.properties;\n\tvar result;\n\n\tif (!pluspath)\n\t\tpluspath = '';\n\n\tif (model == null)\n\t\tmodel = {};\n\n\tfor (var i = 0; i < properties.length; i++) {\n\n\t\tvar name = properties[i];\n\t\tvar TYPE = schema.schema[name];\n\t\tif (!TYPE)\n\t\t\tcontinue;\n\n\t\tif (TYPE.can && !TYPE.can(model, model.$$workflow || EMPTYOBJECT))\n\t\t\tcontinue;\n\n\t\tvar value = model[name];\n\t\tvar type = typeof(value);\n\t\tvar prefix = schema.resourcePrefix ? (schema.resourcePrefix + name) : name;\n\n\t\tif (value === undefined) {\n\t\t\terror.push(pluspath + name, '@', current + name, undefined, prefix);\n\t\t\tcontinue;\n\t\t} else if (type === 'function')\n\t\t\tvalue = model[name]();\n\n\t\tif (TYPE.isArray) {\n\t\t\tif (TYPE.type === 7 && value instanceof Array && value.length) {\n\t\t\t\tvar nestedschema = GETSCHEMA(TYPE.raw);\n\t\t\t\tif (nestedschema) {\n\t\t\t\t\tfor (var j = 0, jl = value.length; j < jl; j++)\n\t\t\t\t\t\texports.validate_builder(value[j], error, nestedschema, current + name + '[' + j + ']', j, undefined, pluspath);\n\t\t\t\t} else\n\t\t\t\t\tthrow new Error('Nested schema \"{0}\" not found in \"{1}\".'.format(TYPE.raw, schema.parent.name));\n\t\t\t} else {\n\n\t\t\t\tif (!TYPE.required)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tresult = TYPE.validate ? TYPE.validate(value, model) : null;\n\t\t\t\tif (result == null) {\n\t\t\t\t\tresult = value instanceof Array ? value.length > 0 : false;\n\t\t\t\t\tif (result == null || result === true)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\ttype = typeof(result);\n\t\t\t\tif (type === 'string') {\n\t\t\t\t\tif (result[0] === '@')\n\t\t\t\t\t\terror.push(pluspath + name, TYPE.invalid, current + name, index, schema.resourcePrefix + result.substring(1));\n\t\t\t\t\telse\n\t\t\t\t\t\terror.push(pluspath + name, result, current + name, index, prefix);\n\t\t\t\t} else if (type === 'boolean')\n\t\t\t\t\t!result && error.push(pluspath + name, TYPE.invalid, current + name, index, prefix);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (TYPE.type === 7) {\n\n\t\t\tif (!value && !TYPE.required)\n\t\t\t\tcontinue;\n\n\t\t\t// Another schema\n\t\t\tresult = TYPE.validate ? TYPE.validate(value, model) : null;\n\n\t\t\tif (result == null) {\n\t\t\t\tvar nestedschema = GETSCHEMA(TYPE.raw);\n\t\t\t\tif (nestedschema)\n\t\t\t\t\texports.validate_builder(value, error, nestedschema, current + name, undefined, undefined, pluspath);\n\t\t\t\telse\n\t\t\t\t\tthrow new Error('Nested schema \"{0}\" not found in \"{1}\".'.format(TYPE.raw, schema.parent.name));\n\t\t\t} else {\n\t\t\t\ttype = typeof(result);\n\t\t\t\tif (type === 'string') {\n\t\t\t\t\tif (result[0] === '@')\n\t\t\t\t\t\terror.push(pluspath + name, TYPE.invalid, current + name, index, schema.resourcePrefix + result.substring(1));\n\t\t\t\t\telse\n\t\t\t\t\t\terror.push(pluspath + name, result, current + name, index, prefix);\n\t\t\t\t} else if (type === 'boolean')\n\t\t\t\t\t!result && error.push(pluspath + name, TYPE.invalid, current + name, index, prefix);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!TYPE.required)\n\t\t\tcontinue;\n\n\t\tresult = TYPE.validate ? TYPE.validate(value, model) : null;\n\t\tif (result == null) {\n\t\t\tresult = validate_builder_default(name, value, TYPE);\n\t\t\tif (result == null || result === true)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\ttype = typeof(result);\n\n\t\tif (type === 'string') {\n\t\t\tif (result[0] === '@')\n\t\t\t\terror.push(pluspath + name, TYPE.invalid, current + name, index, schema.resourcePrefix + result.substring(1));\n\t\t\telse\n\t\t\t\terror.push(pluspath + name, result, current + name, index, prefix);\n\t\t} else if (type === 'boolean')\n\t\t\t!result && error.push(pluspath + name, TYPE.invalid, current + name, index, prefix);\n\t}\n\n\treturn error;\n};\n\n/**\n * Combine paths\n * @return {String}\n */\nexports.combine = function() {\n\n\tvar p = F.directory;\n\n\tfor (var i = 0, length = arguments.length; i < length; i++) {\n\t\tvar v = arguments[i];\n\t\tif (!v)\n\t\t\tcontinue;\n\t\tif (v[0] === '/')\n\t\t\tv = v.substring(1);\n\n\t\tif (v[0] === '~')\n\t\t\tp = v.substring(1);\n\t\telse\n\t\t\tp += (p[p.length - 1] !== '/' ? '/' : '') + v;\n\t}\n\treturn exports.$normalize(p);\n};\n\n/**\n * Simple XML parser\n * @param {String} xml\n * @return {Object}\n */\nexports.parseXML = function(xml, replace) {\n\treturn xml.parseXML(replace);\n};\n\nfunction jsonparser(key, value) {\n\treturn typeof(value) === 'string' && value.isJSONDate() ? new Date(value) : value;\n}\n\n/**\n * Get WebSocket frame\n * @author Jozef Gula <gula.jozef@gmail.com>\n * @param {Number} code\n * @param {Buffer or String} message\n * @param {Hexa} type\n * @return {Buffer}\n */\nexports.getWebSocketFrame = function(code, message, type, compress, mask) {\n\n\tif (mask)\n\t\tmask = ((Math.random() * 214748364) >> 0) + 1;\n\n\tvar messageBuffer = getWebSocketFrameMessageBytes(code, message);\n\tvar lengthBuffer = getWebSocketFrameLengthBytes(messageBuffer.length);\n\tvar lengthMask = mask ? 4 : 0;\n\tvar frameBuffer = Buffer.alloc(1 + lengthBuffer.length + messageBuffer.length + lengthMask);\n\n\tframeBuffer[0] = 0x80 | type;\n\n\tif (compress)\n\t\tframeBuffer[0] |= 0x40;\n\n\tlengthBuffer.copy(frameBuffer, 1, 0, lengthBuffer.length);\n\n\tif (mask) {\n\t\tvar offset = lengthBuffer.length + 1;\n\t\tframeBuffer[1] |= 0x80;\n\t\tframeBuffer.writeInt32BE(mask, offset);\n\t\tfor (var i = 0; i < messageBuffer.length; i++)\n\t\t\tmessageBuffer[i] = messageBuffer[i] ^ frameBuffer[offset + (i % 4)];\n\t}\n\n\tmessageBuffer.copy(frameBuffer, lengthBuffer.length + 1 + lengthMask, 0, messageBuffer.length);\n\treturn frameBuffer;\n};\n\n/**\n * Get bytes of WebSocket frame message\n * @author Jozef Gula <gula.jozef@gmail.com>\n * @param  {Number} code\n * @param  {Buffer or String} message\n * @return {Buffer}\n */\nfunction getWebSocketFrameMessageBytes(code, message) {\n\n\tvar index = code ? 2 : 0;\n\tvar binary = message instanceof Int8Array || message instanceof Buffer;\n\tvar length = message.length;\n\n\tvar messageBuffer = Buffer.alloc(length + index);\n\n\tfor (var i = 0; i < length; i++) {\n\t\tif (binary)\n\t\t\tmessageBuffer[i + index] = message[i];\n\t\telse\n\t\t\tmessageBuffer[i + index] = message.charCodeAt(i);\n\t}\n\n\tif (code) {\n\t\tmessageBuffer[0] = code >> 8;\n\t\tmessageBuffer[1] = code;\n\t}\n\n\treturn messageBuffer;\n}\n\n/**\n * Get length of WebSocket frame\n * @author Jozef Gula <gula.jozef@gmail.com>\n * @param  {Number} length\n * @return {Number}\n */\nfunction getWebSocketFrameLengthBytes(length) {\n\tvar lengthBuffer = null;\n\n\tif (length <= 125) {\n\t\tlengthBuffer = Buffer.alloc(1);\n\t\tlengthBuffer[0] = length;\n\t\treturn lengthBuffer;\n\t}\n\n\tif (length <= 65535) {\n\t\tlengthBuffer = Buffer.alloc(3);\n\t\tlengthBuffer[0] = 126;\n\t\tlengthBuffer[1] = (length >> 8) & 255;\n\t\tlengthBuffer[2] = (length) & 255;\n\t\treturn lengthBuffer;\n\t}\n\n\tlengthBuffer = Buffer.alloc(9);\n\n\tlengthBuffer[0] = 127;\n\tlengthBuffer[1] = 0x00;\n\tlengthBuffer[2] = 0x00;\n\tlengthBuffer[3] = 0x00;\n\tlengthBuffer[4] = 0x00;\n\tlengthBuffer[5] = (length >> 24) & 255;\n\tlengthBuffer[6] = (length >> 16) & 255;\n\tlengthBuffer[7] = (length >> 8) & 255;\n\tlengthBuffer[8] = (length) & 255;\n\n\treturn lengthBuffer;\n}\n\n/**\n * GPS distance in KM\n * @param  {Number} lat1\n * @param  {Number} lon1\n * @param  {Number} lat2\n * @param  {Number} lon2\n * @return {Number}\n */\nexports.distance = function(lat1, lon1, lat2, lon2) {\n\tvar R = 6371;\n\tvar dLat = (lat2 - lat1).toRad();\n\tvar dLon = (lon2 - lon1).toRad();\n\tvar a = Math.sin(dLat / 2) * Math.sin(dLat / 2) + Math.cos(lat1.toRad()) * Math.cos(lat2.toRad()) * Math.sin(dLon / 2) * Math.sin(dLon / 2);\n\tvar c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n\treturn (R * c).floor(3);\n};\n\nfunction ls(path, callback, advanced, filter) {\n\tvar filelist = new FileList();\n\tvar tmp;\n\n\tfilelist.advanced = advanced;\n\tfilelist.onComplete = callback;\n\n\tif (typeof(filter) === 'string') {\n\t\ttmp = filter.toLowerCase();\n\t\tfilelist.onFilter = function(filename, is) {\n\t\t\treturn is ? true : filename.toLowerCase().indexOf(tmp) !== -1;\n\t\t};\n\t} else if (filter && filter.test) {\n\t\t// regexp\n\t\ttmp = filter;\n\t\tfilelist.onFilter = function(filename, is) {\n\t\t\treturn is ? true : tmp.test(filename);\n\t\t};\n\t} else\n\t\tfilelist.onFilter = filter || null;\n\n\tfilelist.walk(path);\n}\n\n/**\n * Directory listing\n * @param {String} path Path.\n * @param {Function(files, directories)} callback Callback\n * @param {Function(filename, isDirectory) or String or RegExp} filter Custom filter (optional).\n */\nexports.ls = function(path, callback, filter) {\n\tls(path, callback, false, filter);\n};\n\n/**\n * Advanced Directory listing\n * @param {String} path Path.\n * @param {Function(files, directories)} callback Callback\n * @param {Function(filename ,isDirectory) or String or RegExp} filter Custom filter (optional).\n */\nexports.ls2 = function(path, callback, filter) {\n\tls(path, callback, true, filter);\n};\n\nDP.setTimeZone = function(timezone) {\n\n\tvar dt = new Date(this.toLocaleString('en-US', { timeZone: timezone }));\n\n\tvar offset = dt + '';\n\tvar index = offset.indexOf('GMT');\n\tvar op = offset.substring(index + 3, index + 4);\n\tvar count = offset.substring(index + 4, index + 9);\n\tvar h = +count.substring(0, 2);\n\tvar m = +count.substring(2);\n\n\tif (op === '+') {\n\t\th && dt.setHours(dt.getHours() + h);\n\t\tm && dt.setMinutes(dt.getMinutes() + m);\n\t} else {\n\t\th && dt.setHours(dt.getHours() - h);\n\t\tm && dt.setMinutes(dt.getMinutes() - m);\n\t}\n\n\treturn dt;\n};\n\n/**\n * Date difference\n * @param  {Date/Number/String} date Optional.\n * @param  {String} type Date type: minutes, seconds, hours, days, months, years\n * @return {Number}\n */\nDP.diff = function(date, type) {\n\n\tif (arguments.length === 1) {\n\t\ttype = date;\n\t\tdate = Date.now();\n\t} else {\n\t\tvar to = typeof(date);\n\t\tif (to === 'string')\n\t\t\tdate = Date.parse(date);\n\t\telse if (exports.isDate(date))\n\t\t\tdate = date.getTime();\n\t}\n\n\tvar r = this.getTime() - date;\n\n\tswitch (type) {\n\t\tcase 's':\n\t\tcase 'ss':\n\t\tcase 'second':\n\t\tcase 'seconds':\n\t\t\treturn Math.ceil(r / 1000);\n\t\tcase 'm':\n\t\tcase 'mm':\n\t\tcase 'minute':\n\t\tcase 'minutes':\n\t\t\treturn Math.ceil((r / 1000) / 60);\n\t\tcase 'h':\n\t\tcase 'hh':\n\t\tcase 'hour':\n\t\tcase 'hours':\n\t\t\treturn Math.ceil(((r / 1000) / 60) / 60);\n\t\tcase 'd':\n\t\tcase 'dd':\n\t\tcase 'day':\n\t\tcase 'days':\n\t\t\treturn Math.ceil((((r / 1000) / 60) / 60) / 24);\n\t\tcase 'M':\n\t\tcase 'MM':\n\t\tcase 'month':\n\t\tcase 'months':\n\t\t\t// avg: 28 days per month\n\t\t\treturn Math.ceil((((r / 1000) / 60) / 60) / (24 * 28));\n\n\t\tcase 'y':\n\t\tcase 'yyyy':\n\t\tcase 'year':\n\t\tcase 'years':\n\t\t\t// avg: 28 days per month\n\t\t\treturn Math.ceil((((r / 1000) / 60) / 60) / (24 * 28 * 12));\n\t}\n\n\treturn NaN;\n};\n\nDP.add = function(type, value) {\n\n\tvar self = this;\n\n\tif (type.constructor === Number)\n\t\treturn new Date(self.getTime() + (type - type % 1));\n\n\tif (value === undefined) {\n\t\tvar arr = type.split(' ');\n\t\ttype = arr[1];\n\t\tvalue = exports.parseInt(arr[0]);\n\t}\n\n\tvar dt = new Date(self.getTime());\n\n\tswitch(type) {\n\t\tcase 's':\n\t\tcase 'ss':\n\t\tcase 'sec':\n\t\tcase 'second':\n\t\tcase 'seconds':\n\t\t\tdt.setUTCSeconds(dt.getUTCSeconds() + value);\n\t\t\treturn dt;\n\t\tcase 'm':\n\t\tcase 'mm':\n\t\tcase 'minute':\n\t\tcase 'min':\n\t\tcase 'minutes':\n\t\t\tdt.setUTCMinutes(dt.getUTCMinutes() + value);\n\t\t\treturn dt;\n\t\tcase 'h':\n\t\tcase 'hh':\n\t\tcase 'hour':\n\t\tcase 'hours':\n\t\t\tdt.setUTCHours(dt.getUTCHours() + value);\n\t\t\treturn dt;\n\t\tcase 'd':\n\t\tcase 'dd':\n\t\tcase 'day':\n\t\tcase 'days':\n\t\t\tdt.setUTCDate(dt.getUTCDate() + value);\n\t\t\treturn dt;\n\t\tcase 'w':\n\t\tcase 'ww':\n\t\tcase 'week':\n\t\tcase 'weeks':\n\t\t\tdt.setUTCDate(dt.getUTCDate() + (value * 7));\n\t\t\treturn dt;\n\t\tcase 'M':\n\t\tcase 'MM':\n\t\tcase 'month':\n\t\tcase 'months':\n\t\t\tdt.setUTCMonth(dt.getUTCMonth() + value);\n\t\t\treturn dt;\n\t\tcase 'y':\n\t\tcase 'yyyy':\n\t\tcase 'year':\n\t\tcase 'years':\n\t\t\tdt.setUTCFullYear(dt.getUTCFullYear() + value);\n\t\t\treturn dt;\n\t}\n\treturn dt;\n};\n\nDP.extend = function(date) {\n\tvar dt = new Date(this);\n\tvar match = date.match(regexpDATE);\n\n\tif (!match)\n\t\treturn dt;\n\n\tfor (var i = 0, length = match.length; i < length; i++) {\n\t\tvar m = match[i];\n\t\tvar arr, tmp;\n\n\t\tif (m.indexOf(':') !== -1) {\n\n\t\t\tarr = m.split(':');\n\t\t\ttmp = +arr[0];\n\t\t\ttmp >= 0 && dt.setUTCHours(tmp);\n\n\t\t\tif (arr[1]) {\n\t\t\t\ttmp = +arr[1];\n\t\t\t\ttmp >= 0 && dt.setUTCMinutes(tmp);\n\t\t\t}\n\n\t\t\tif (arr[2]) {\n\t\t\t\ttmp = +arr[2];\n\t\t\t\ttmp >= 0 && dt.setUTCSeconds(tmp);\n\t\t\t}\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (m.indexOf('-') !== -1) {\n\t\t\tarr = m.split('-');\n\n\t\t\ttmp = +arr[0];\n\t\t\ttmp && dt.setUTCFullYear(tmp);\n\n\t\t\tif (arr[1]) {\n\t\t\t\ttmp = +arr[1];\n\t\t\t\ttmp >= 0 && dt.setUTCMonth(tmp - 1);\n\t\t\t}\n\n\t\t\tif (arr[2]) {\n\t\t\t\ttmp = +arr[2];\n\t\t\t\ttmp >= 0 && dt.setUTCDate(tmp);\n\t\t\t}\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (m.indexOf('.') !== -1) {\n\t\t\tarr = m.split('.');\n\n\t\t\tif (arr[2]) {\n\t\t\t\ttmp = +arr[2];\n\t\t\t\t!isNaN(tmp) && dt.setUTCFullYear(tmp);\n\t\t\t}\n\n\t\t\tif (arr[1]) {\n\t\t\t\ttmp = +arr[1];\n\t\t\t\t!isNaN(tmp) && dt.setUTCMonth(tmp - 1);\n\t\t\t}\n\n\t\t\ttmp = +arr[0];\n\t\t\t!isNaN(tmp) && dt.setUTCDate(tmp);\n\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\treturn dt;\n};\n\n/**\n * Format datetime\n * @param {String} format\n * @return {String}\n */\nDP.format = function(format, resource) {\n\n\tif (!format)\n\t\treturn this.getUTCFullYear() + '-' + (this.getUTCMonth() + 1).toString().padLeft(2, '0') + '-' + this.getUTCDate().toString().padLeft(2, '0') + 'T' + this.getUTCHours().toString().padLeft(2, '0') + ':' + this.getUTCMinutes().toString().padLeft(2, '0') + ':' + this.getUTCSeconds().toString().padLeft(2, '0') + '.' + this.getUTCMilliseconds().toString().padLeft(3, '0') + 'Z';\n\n\tif (datetimeformat[format])\n\t\treturn datetimeformat[format](this, resource);\n\n\tvar key = format;\n\tvar half = false;\n\n\tif (format && format[0] === '!') {\n\t\thalf = true;\n\t\tformat = format.substring(1);\n\t}\n\n\tvar beg = '\\'+';\n\tvar end = '+\\'';\n\tvar before = [];\n\n\tvar ismm = false;\n\tvar isdd = false;\n\tvar isww = false;\n\n\tformat = format.replace(regexpDATEFORMAT, function(key) {\n\t\tswitch (key) {\n\t\t\tcase 'yyyy':\n\t\t\tcase 'YYYY':\n\t\t\t\treturn beg + 'd.getFullYear()' + end;\n\t\t\tcase 'yy':\n\t\t\tcase 'YY':\n\t\t\t\treturn beg + 'd.getFullYear().toString().substring(2)' + end;\n\t\t\tcase 'MMM':\n\t\t\t\tismm = true;\n\t\t\t\treturn beg + '(RESOURCE(resource, mm) || mm).substring(0, 3)' + end;\n\t\t\tcase 'MMMM':\n\t\t\t\tismm = true;\n\t\t\t\treturn beg + '(RESOURCE(resource, mm) || mm)' + end;\n\t\t\tcase 'MM':\n\t\t\t\treturn beg + '(d.getMonth() + 1).toString().padLeft(2, \\'0\\')' + end;\n\t\t\tcase 'M':\n\t\t\t\treturn beg + '(d.getMonth() + 1)' + end;\n\t\t\tcase 'ddd':\n\t\t\tcase 'DDD':\n\t\t\t\tisdd = true;\n\t\t\t\treturn beg + '(RESOURCE(resource, dd) || dd).substring(0, 2).toUpperCase()' + end;\n\t\t\tcase 'dddd':\n\t\t\tcase 'DDDD':\n\t\t\t\tisdd = true;\n\t\t\t\treturn beg + '(RESOURCE(resource, dd) || dd)' + end;\n\t\t\tcase 'dd':\n\t\t\tcase 'DD':\n\t\t\t\treturn beg + 'd.getDate().toString().padLeft(2, \\'0\\')' + end;\n\t\t\tcase 'd':\n\t\t\tcase 'D':\n\t\t\t\treturn beg + 'd.getDate()' + end;\n\t\t\tcase 'HH':\n\t\t\tcase 'hh':\n\t\t\t\treturn beg + (half ? 'framework_utils.$pmam(d.getHours()).toString().padLeft(2, \\'0\\')' : 'd.getHours().toString().padLeft(2, \\'0\\')') + end;\n\t\t\tcase 'H':\n\t\t\tcase 'h':\n\t\t\t\treturn beg + (half ? 'framework_utils(d.getHours())' : 'd.getHours()') + end;\n\t\t\tcase 'mm':\n\t\t\t\treturn beg + 'd.getMinutes().toString().padLeft(2, \\'0\\')' + end;\n\t\t\tcase 'm':\n\t\t\t\treturn beg + 'd.getMinutes()' + end;\n\t\t\tcase 'ss':\n\t\t\t\treturn beg + 'd.getSeconds().toString().padLeft(2, \\'0\\')' + end;\n\t\t\tcase 's':\n\t\t\t\treturn beg + 'd.getSeconds()' + end;\n\t\t\tcase 'w':\n\t\t\tcase 'ww':\n\t\t\t\tisww = true;\n\t\t\t\treturn beg + (key === 'ww' ? 'ww.toString().padLeft(2, \\'0\\')' : 'ww') + end;\n\t\t\tcase 'a':\n\t\t\t\tvar b = \"'PM':'AM'\";\n\t\t\t\treturn beg + '(d.getHours() >= 12 ? ' + b + ')' + end;\n\t\t}\n\t});\n\n\tismm && before.push('var mm = framework_utils.MONTHS[d.getMonth()];');\n\tisdd && before.push('var dd = framework_utils.DAYS[d.getDay()];');\n\tisww && before.push('var ww = new Date(+d);ww.setHours(0, 0, 0);ww.setDate(ww.getDate() + 4 - (ww.getDay() || 7));ww = Math.ceil((((ww - new Date(ww.getFullYear(), 0, 1)) / 8.64e7) + 1) / 7);');\n\n\tdatetimeformat[key] = new Function('d', 'resource', before.join('\\n') + 'return \\'' + format + '\\';');\n\treturn datetimeformat[key](this, resource);\n};\n\nexports.$pmam = function(value) {\n\treturn value >= 12 ? value - 12 : value;\n};\n\nDP.toUTC = function(ticks) {\n\tvar dt = this.getTime() + this.getTimezoneOffset() * 60000;\n\treturn ticks ? dt : new Date(dt);\n};\n\n// +v2.2.0 parses JSON dates as dates and this is the fallback for backward compatibility\nDP.parseDate = function() {\n\treturn this;\n};\n\nSP.isJSONDate = function() {\n\tvar l = this.length - 1;\n\treturn l > 22 && l < 30 && this[l] === 'Z' && this[10] === 'T' && this[4] === '-' && this[13] === ':' && this[16] === ':';\n};\n\nSP.ROOT = function(noremap) {\n\n\tvar str = this;\n\n\tstr = str.replace(REG_NOREMAP, function() {\n\t\tnoremap = true;\n\t\treturn '';\n\t}).replace(REG_ROOT, $urlmaker);\n\n\tif (!noremap && CONF.default_root)\n\t\tstr = str.replace(REG_REMAP, $urlremap).replace(REG_AJAX, $urlajax);\n\n\treturn str;\n};\n\nfunction $urlremap(text) {\n\tvar pos = text[0] === 'h' ? 6 : 5;\n\treturn REG_URLEXT.test(text) ? text : ((text[0] === 'h' ? 'href' : 'src') + '=\"' + CONF.default_root + (text[pos] === '/' ? text.substring(pos + 1) : text));\n}\n\nfunction $urlajax(text) {\n\treturn text.substring(0, text.length - 1) + CONF.default_root;\n}\n\nfunction $urlmaker(text) {\n\tvar c = text[4];\n\treturn CONF.default_root ? CONF.default_root : (c || '');\n}\n\nif (!SP.trim) {\n\tSP.trim = function() {\n\t\treturn this.replace(regexpTRIM, '');\n\t};\n}\n\n/**\n * Checks if the string starts with the text\n * @see {@link http://docs.totaljs.com/SP/#SP.startsWith|Documentation}\n * @param {String} text Text to find.\n * @param {Boolean/Number} ignoreCase Ingore case sensitive or position in the string.\n * @return {Boolean}\n */\nSP.startsWith = function(text, ignoreCase) {\n\tvar self = this;\n\tvar length = text.length;\n\tvar tmp;\n\n\tif (ignoreCase === true) {\n\t\ttmp = self.substring(0, length);\n\t\treturn tmp.length === length && tmp.toLowerCase() === text.toLowerCase();\n\t}\n\n\tif (ignoreCase)\n\t\ttmp = self.substr(ignoreCase, length);\n\telse\n\t\ttmp = self.substring(0, length);\n\n\treturn tmp.length === length && tmp === text;\n};\n\n/**\n * Checks if the string ends with the text\n * @see {@link http://docs.totaljs.com/SP/#SP.endsWith|Documentation}\n * @param {String} text Text to find.\n * @param {Boolean/Number} ignoreCase Ingore case sensitive or position in the string.\n * @return {Boolean}\n */\nSP.endsWith = function(text, ignoreCase) {\n\tvar self = this;\n\tvar length = text.length;\n\tvar tmp;\n\n\tif (ignoreCase === true) {\n\t\ttmp = self.substring(self.length - length);\n\t\treturn tmp.length === length && tmp.toLowerCase() === text.toLowerCase();\n\t}\n\n\tif (ignoreCase)\n\t\ttmp = self.substr((self.length - ignoreCase) - length, length);\n\telse\n\t\ttmp = self.substring(self.length - length);\n\n\treturn tmp.length === length && tmp === text;\n};\n\nSP.replacer = function(find, text) {\n\tvar self = this;\n\tvar beg = self.indexOf(find);\n\treturn beg === -1 ? self : (self.substring(0, beg) + text + self.substring(beg + find.length));\n};\n\n/**\n * Hash string\n * @param {String} type Hash type.\n * @param {String} salt Optional, salt.\n * @return {String}\n */\nSP.hash = function(type, salt) {\n\tvar str = salt ? this + salt : this;\n\tswitch (type) {\n\t\tcase 'md5':\n\t\t\treturn str.md5();\n\t\tcase 'sha1':\n\t\t\treturn str.sha1();\n\t\tcase 'sha256':\n\t\t\treturn str.sha256();\n\t\tcase 'sha512':\n\t\t\treturn str.sha512();\n\t\tcase 'crc32':\n\t\t\treturn str.crc32();\n\t\tcase 'crc32unsigned':\n\t\t\treturn str.crc32(true);\n\t\tdefault:\n\t\t\tvar val = string_hash(str);\n\t\t\treturn type === true ? val >>> 0 : val;\n\t}\n};\n\nglobal.HASH = function(value, type) {\n\treturn value.hash(type ? type : true);\n};\n\nSP.makeid = function() {\n\treturn this.hash(true).toString(36);\n};\n\nSP.crc32 = function(unsigned) {\n\tvar crc = -1;\n\tfor (var i = 0, length = this.length; i < length; i++)\n\t\tcrc = (crc >>> 8) ^ CRC32TABLE[(crc ^ this.charCodeAt(i)) & 0xFF];\n\tvar val = crc ^ (-1);\n\treturn unsigned ? val >>> 0 : val;\n};\n\nfunction string_hash(s, convert) {\n\tvar hash = 0;\n\tif (s.length === 0)\n\t\treturn convert ? '' : hash;\n\tfor (var i = 0, l = s.length; i < l; i++) {\n\t\tvar char = s.charCodeAt(i);\n\t\thash = ((hash << 5) - hash) + char;\n\t\thash |= 0;\n\t}\n\treturn hash;\n}\n\nSP.count = function(text) {\n\tvar index = 0;\n\tvar count = 0;\n\tdo {\n\t\tindex = this.indexOf(text, index + text.length);\n\t\tif (index > 0)\n\t\t\tcount++;\n\t} while (index > 0);\n\treturn count;\n};\n\nSP.parseComponent = function(tags) {\n\n\tvar html = this;\n\tvar beg = -1;\n\tvar end = -1;\n\tvar output = {};\n\n\tfor (var key in tags) {\n\n\t\tvar tagbeg = tags[key];\n\t\tvar tagindex = tagbeg.indexOf(' ');\n\n\t\tif (tagindex === -1)\n\t\t\ttagindex = tagbeg.length - 1;\n\n\t\tvar tagend = '</' + tagbeg.substring(1, tagindex) + '>';\n\t\tvar tagbeg2 = '<' + tagend.substring(2);\n\n\t\tbeg = html.indexOf(tagbeg);\n\n\t\tif (beg !== -1) {\n\n\t\t\tvar count = 0;\n\t\t\tend = -1;\n\n\t\t\tfor (var j = (beg + tagbeg.length); j < html.length; j++) {\n\t\t\t\tvar a = html.substring(j, j + tagbeg2.length);\n\t\t\t\tif (a === tagbeg2) {\n\t\t\t\t\tcount++;\n\t\t\t\t} else {\n\t\t\t\t\tif (html.substring(j, j + tagend.length) === tagend) {\n\t\t\t\t\t\tif (count) {\n\t\t\t\t\t\t\tcount--;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tend = j;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (end !== -1) {\n\t\t\t\tvar tmp = html.substring(html.indexOf('>', beg) + 1, end);\n\t\t\t\thtml = html.replace(html.substring(beg, end + tagend.length), '').trim();\n\t\t\t\toutput[key] = tmp.trim();\n\t\t\t}\n\n\t\t}\n\t}\n\n\treturn output;\n};\n\nSP.parseXML = function(replace) {\n\n\tvar xml = this;\n\tvar beg = -1;\n\tvar end = 0;\n\tvar tmp = 0;\n\tvar current = [];\n\tvar obj = {};\n\tvar from = -1;\n\n\twhile (true) {\n\t\tbeg = xml.indexOf('<![CDATA[', beg);\n\t\tif (beg === -1)\n\t\t\tbreak;\n\t\tend = xml.indexOf(']]>', beg + 9);\n\t\txml = xml.substring(0, beg) + xml.substring(beg + 9, end).trim().encode() + xml.substring(end + 3);\n\t\tbeg += 9;\n\t}\n\n\tbeg = -1;\n\tend = 0;\n\n\twhile (true) {\n\n\t\tbeg = xml.indexOf('<', beg + 1);\n\t\tif (beg === -1)\n\t\t\tbreak;\n\n\t\tend = xml.indexOf('>', beg + 1);\n\t\tif (end === -1)\n\t\t\tbreak;\n\n\t\tvar el = xml.substring(beg, end + 1);\n\t\tvar c = el[1];\n\n\t\tif (el.substring(0, 4) === '<!--') {\n\t\t\tbeg = end + 3;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (c === '?' || c === '/') {\n\n\t\t\tvar o = current.pop();\n\n\t\t\tif (from === -1 || o !== el.substring(2, el.length - 1))\n\t\t\t\tcontinue;\n\n\t\t\tvar path = (current.length ? current.join('.') + '.' : '') + o;\n\t\t\tvar value = xml.substring(from, beg).decode();\n\n\t\t\tif (replace)\n\t\t\t\tpath = path.replace(REG_XMLKEY, '_');\n\n\t\t\tif (obj[path] === undefined)\n\t\t\t\tobj[path] = value;\n\t\t\telse if (obj[path] instanceof Array)\n\t\t\t\tobj[path].push(value);\n\t\t\telse\n\t\t\t\tobj[path] = [obj[path], value];\n\n\t\t\tfrom = -1;\n\t\t\tcontinue;\n\t\t}\n\n\t\ttmp = el.indexOf(' ');\n\t\tvar hasAttributes = true;\n\n\t\tif (tmp === -1) {\n\t\t\ttmp = el.length - 1;\n\t\t\thasAttributes = false;\n\t\t}\n\n\t\tfrom = beg + el.length;\n\n\t\tvar isSingle = el[el.length - 2] === '/';\n\t\tvar name = el.substring(1, tmp);\n\n\t\tif (!isSingle)\n\t\t\tcurrent.push(name);\n\n\t\tif (!hasAttributes)\n\t\t\tcontinue;\n\n\t\tvar match = el.match(regexpXML);\n\t\tif (!match)\n\t\t\tcontinue;\n\n\t\tvar attr = {};\n\t\tvar length = match.length;\n\n\t\tfor (var i = 0; i < length; i++) {\n\t\t\tvar index = match[i].indexOf('\"');\n\t\t\tattr[match[i].substring(0, index - 1)] = match[i].substring(index + 1, match[i].length - 1).decode();\n\t\t}\n\n\t\tvar k = current.join('.') + (isSingle ? '.' + name : '') + '[]';\n\t\tif (replace)\n\t\t\tk = k.replace(REG_XMLKEY, '_');\n\t\tobj[k] = attr;\n\t}\n\n\treturn obj;\n};\n\nSP.parseJSON = function(date) {\n\ttry {\n\t\treturn JSON.parse(this, date ? jsonparser : undefined);\n\t} catch (e) {}\n};\n\nfunction parseQueryArgumentsDecode(val) {\n\ttry {\n\t\treturn decodeURIComponent(val);\n\t} catch (e) {\n\t\treturn '';\n\t}\n}\n\nconst QUERY_ALLOWED = { '45': 1, '95': 1, 46: 1, '91': 1, '93': 1 };\n\nSP.parseEncoded = function() {\n\n\tvar str = this + '&';\n\tvar obj = {};\n\tvar key = '';\n\tvar val = '';\n\tvar is = false;\n\tvar decodev = false;\n\tvar decodek = false;\n\tvar count = 0;\n\tvar pos = 0;\n\n\tfor (var i = 0; i < str.length; i++) {\n\t\tvar n = str.charCodeAt(i);\n\n\t\tif (n === 38) {\n\n\t\t\tif (key) {\n\t\t\t\tif (pos < i)\n\t\t\t\t\tval += str.substring(pos, i);\n\n\t\t\t\tif (decodev)\n\t\t\t\t\tval = parseQueryArgumentsDecode(val);\n\n\t\t\t\tif (decodek)\n\t\t\t\t\tkey = parseQueryArgumentsDecode(key);\n\n\t\t\t\tobj[key] = val;\n\t\t\t}\n\n\t\t\tif (key)\n\t\t\t\tkey = '';\n\n\t\t\tif (val)\n\t\t\t\tval = '';\n\n\t\t\tpos = i + 1;\n\t\t\tis = false;\n\t\t\tdecodek = false;\n\t\t\tdecodev = false;\n\n\t\t\tif ((count++) >= CONF.default_request_maxkeys)\n\t\t\t\tbreak;\n\n\t\t} else {\n\n\t\t\tif (n === 61) {\n\t\t\t\tif ((i - pos) > CONF.default_request_maxkey)\n\t\t\t\t\tkey = '';\n\t\t\t\telse {\n\t\t\t\t\tif (pos < i)\n\t\t\t\t\t\tkey += str.substring(pos, i);\n\t\t\t\t\tpos = i + 1;\n\t\t\t\t\tis = true;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!is) {\n\t\t\t\tvar can = false;\n\t\t\t\tif (n > 47 && n < 58)\n\t\t\t\t\tcan = true;\n\t\t\t\telse if ((n > 64 && n < 91) || (n > 96 && n < 123))\n\t\t\t\t\tcan = true;\n\t\t\t\telse if (QUERY_ALLOWED[n])\n\t\t\t\t\tcan = true;\n\t\t\t\tif (!can)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (n === 43) {\n\t\t\t\tif (is)\n\t\t\t\t\tval += str.substring(pos, i) + ' ';\n\t\t\t\telse\n\t\t\t\t\tkey += str.substring(pos, i) + ' ';\n\t\t\t\tpos = i + 1;\n\t\t\t}\n\n\t\t\tif (n === 37) {\n\t\t\t\tif (str.charCodeAt(i + 1) === 48 && str.charCodeAt(i + 2) === 48)\n\t\t\t\t\tpos = i + 3;\n\t\t\t\telse if (is) {\n\t\t\t\t\tif (!decodev)\n\t\t\t\t\t\tdecodev = true;\n\t\t\t\t} else {\n\t\t\t\t\tif (!decodev)\n\t\t\t\t\t\tdecodek = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn obj;\n};\n\nSP.parseUA = function(structured) {\n\n\tvar ua = this;\n\n\tif (!ua)\n\t\treturn '';\n\n\tvar arr = ua.match(regexpUA);\n\tvar uid = '';\n\n\tif (arr) {\n\n\t\tvar data = {};\n\n\t\tfor (var i = 0; i < arr.length; i++) {\n\n\t\t\tif (arr[i] === 'like' && arr[i + 1] === 'Gecko') {\n\t\t\t\ti += 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tvar key = arr[i].toLowerCase();\n\t\t\tif (key === 'like')\n\t\t\t\tbreak;\n\n\t\t\tswitch (key) {\n\t\t\t\tcase 'linux':\n\t\t\t\tcase 'windows':\n\t\t\t\tcase 'mac':\n\t\t\t\tcase 'symbian':\n\t\t\t\tcase 'symbos':\n\t\t\t\tcase 'tizen':\n\t\t\t\tcase 'android':\n\t\t\t\t\tdata[arr[i]] = 2;\n\t\t\t\t\tif (key === 'tizen' || key === 'android')\n\t\t\t\t\t\tdata.Mobile = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'webos':\n\t\t\t\t\tdata.WebOS = 2;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'media':\n\t\t\t\tcase 'center':\n\t\t\t\tcase 'tv':\n\t\t\t\tcase 'smarttv':\n\t\t\t\tcase 'smart':\n\t\t\t\t\tdata[arr[i]] = 5;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'iemobile':\n\t\t\t\tcase 'mobile':\n\t\t\t\t\tdata[arr[i]] = 1;\n\t\t\t\t\tdata.Mobile = 3;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'ipad':\n\t\t\t\tcase 'ipod':\n\t\t\t\tcase 'iphone':\n\t\t\t\t\tdata.iOS = 2;\n\t\t\t\t\tdata.Mobile = 3;\n\t\t\t\t\tdata[arr[i]] = 1;\n\t\t\t\t\tif (key === 'ipad')\n\t\t\t\t\t\tdata.Tablet = 4;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'phone':\n\t\t\t\t\tdata.Mobile = 3;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'tizenbrowser':\n\t\t\t\tcase 'blackberry':\n\t\t\t\tcase 'mini':\n\t\t\t\t\tdata.Mobile = 3;\n\t\t\t\t\tdata[arr[i]] = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'samsungbrowser':\n\t\t\t\tcase 'chrome':\n\t\t\t\tcase 'firefox':\n\t\t\t\tcase 'msie':\n\t\t\t\tcase 'opera':\n\t\t\t\tcase 'brave':\n\t\t\t\tcase 'vivaldi':\n\t\t\t\tcase 'outlook':\n\t\t\t\tcase 'safari':\n\t\t\t\tcase 'mail':\n\t\t\t\tcase 'edge':\n\t\t\t\tcase 'maxthon':\n\t\t\t\tcase 'electron':\n\t\t\t\t\tdata[arr[i]] = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'trident':\n\t\t\t\t\tdata.MSIE = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'opr':\n\t\t\t\t\tdata.Opera = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'tablet':\n\t\t\t\t\tdata.Tablet = 4;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (data.MSIE) {\n\t\t\tdata.IE = 1;\n\t\t\tdelete data.MSIE;\n\t\t}\n\n\t\tif (data.WebOS || data.Android)\n\t\t\tdelete data.Linux;\n\n\t\tif (data.IEMobile) {\n\t\t\tif (data.Android)\n\t\t\t\tdelete data.Android;\n\t\t\tif (data.Safari)\n\t\t\t\tdelete data.Safari;\n\t\t\tif (data.Chrome)\n\t\t\t\tdelete data.Chrome;\n\t\t} else if (data.MSIE) {\n\t\t\tif (data.Chrome)\n\t\t\t\tdelete data.Chrome;\n\t\t\tif (data.Safari)\n\t\t\t\tdelete data.Safari;\n\t\t} else if (data.Edge) {\n\t\t\tif (data.Chrome)\n\t\t\t\tdelete data.Chrome;\n\t\t\tif (data.Safari)\n\t\t\t\tdelete data.Safari;\n\t\t} else if (data.Opera || data.Electron) {\n\t\t\tif (data.Chrome)\n\t\t\t\tdelete data.Chrome;\n\t\t\tif (data.Safari)\n\t\t\t\tdelete data.Safari;\n\t\t} else if (data.Chrome) {\n\t\t\tif (data.Safari)\n\t\t\t\tdelete data.Safari;\n\t\t\tif (data.SamsungBrowser)\n\t\t\t\tdelete data.SamsungBrowser;\n\t\t} else if (data.SamsungBrowser) {\n\t\t\tif (data.Safari)\n\t\t\t\tdelete data.Safari;\n\t\t}\n\n\t\tif (structured) {\n\t\t\tvar output = { os: '', browser: '', device: 'desktop' };\n\n\t\t\tif (data.Tablet)\n\t\t\t\toutput.device = 'tablet';\n\t\t\telse if (data.Mobile)\n\t\t\t\toutput.device = 'mobile';\n\n\t\t\tfor (var key in data) {\n\t\t\t\tvar val = data[key];\n\t\t\t\tswitch (val) {\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\toutput.browser += (output.browser ? ' ' : '') + key;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\toutput.os += (output.os ? ' ' : '') + key;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 5:\n\t\t\t\t\t\toutput.device = 'tv';\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn output;\n\t\t}\n\n\t\tuid = Object.keys(data).join(' ');\n\t}\n\n\treturn uid;\n};\n\nSP.parseCSV = function(delimiter) {\n\n\tif (!delimiter)\n\t\tdelimiter = ',';\n\n\tvar delimiterstring = '\"';\n\tvar t = this;\n\tvar scope;\n\tvar tmp = {};\n\tvar index = 1;\n\tvar data = [];\n\tvar current = 'a';\n\n\tfor (var i = 0; i < t.length; i++) {\n\t\tvar c = t[i];\n\n\t\tif (!scope) {\n\n\t\t\tif (c === '\\n' || c === '\\r') {\n\t\t\t\ttmp && data.push(tmp);\n\t\t\t\tindex = 1;\n\t\t\t\tcurrent = 'a';\n\t\t\t\ttmp = null;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (c === delimiter) {\n\t\t\t\tcurrent = String.fromCharCode(97 + index);\n\t\t\t\tindex++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (c === delimiterstring) {\n\t\t\t// Check escaped quotes\n\t\t\tif (scope && t[i + 1] === delimiterstring) {\n\t\t\t\ti++;\n\t\t\t} else {\n\t\t\t\tscope = c === scope ? '' : c;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (!tmp)\n\t\t\ttmp = {};\n\n\t\tif (tmp[current])\n\t\t\ttmp[current] += c;\n\t\telse\n\t\t\ttmp[current] = c;\n\t}\n\n\ttmp && data.push(tmp);\n\treturn data;\n};\n\nSP.parseTerminal = function(fields, fn, skip, take) {\n\n\tvar lines = this.split('\\n');\n\n\tif (typeof(fields) === 'function') {\n\t\ttake = skip;\n\t\tskip = fn;\n\t\tfn = fields;\n\t\tparseTerminal2(lines, fn, skip, take);\n\t\treturn this;\n\t}\n\n\tif (skip === undefined)\n\t\tskip = 0;\n\tif (take === undefined)\n\t\ttake = lines.length;\n\n\tvar headers = [];\n\tvar indexer = 0;\n\tvar line = lines[0];\n\n\tif (!line) {\n\t\tline = lines[1];\n\t\tskip++;\n\t}\n\n\tif (!line) {\n\t\tline = lines[2];\n\t\tskip++;\n\t}\n\n\tif (!line)\n\t\treturn this;\n\n\tvar fieldslength = fields.length;\n\tvar tmp;\n\n\tfor (var i = 0, length = fieldslength; i < length; i++) {\n\t\tvar field = fields[i];\n\n\t\tvar beg = -1;\n\t\tvar end = -1;\n\t\tvar type = typeof(field);\n\n\t\tif (type === 'object' && field.test) {\n\t\t\ttmp = line.match(field);\n\t\t\tif (tmp) {\n\t\t\t\tbeg = tmp.index;\n\t\t\t\tend = beg + tmp.toString().length;\n\t\t\t} else {\n\t\t\t\tbeg = -1;\n\t\t\t\tend = -1;\n\t\t\t}\n\t\t} else if (type === 'string') {\n\t\t\ttmp = line.indexOf(field);\n\t\t\tif (tmp === -1) {\n\t\t\t\tbeg = -1;\n\t\t\t\tend = -1;\n\t\t\t} else {\n\t\t\t\tbeg = tmp;\n\t\t\t\tend = line.indexOf(' ', beg + field.length);\n\t\t\t}\n\t\t}\n\n\t\theaders.push({ beg: beg, end: end });\n\t}\n\n\tfor (var i = skip + 1, length = skip + 1 + take; i < length; i++) {\n\n\t\tvar line = lines[i];\n\t\tif (!line)\n\t\t\tcontinue;\n\n\t\tvar arr = [];\n\t\tvar is = false;\n\t\tvar beg;\n\n\t\tfor (var j = 0; j < fieldslength; j++) {\n\t\t\tvar header = headers[j];\n\t\t\tif (header.beg !== -1) {\n\t\t\t\tis = true;\n\t\t\t\tbeg = 0;\n\n\t\t\t\tfor (var k = header.beg; k > -1; k--) {\n\t\t\t\t\tif (line[k] === ' ') {\n\t\t\t\t\t\tbeg = k + 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tarr.push(line.substring(beg, header.end === -1 ? undefined : header.end).trim());\n\t\t\t} else\n\t\t\t\tarr.push('');\n\t\t}\n\n\t\tis && fn(arr, indexer++, length, i);\n\t}\n\n\treturn this;\n};\n\nfunction parseTerminal2(lines, fn, skip, take) {\n\tvar indexer = 0;\n\n\tif (skip === undefined)\n\t\tskip = 0;\n\tif (take === undefined)\n\t\ttake = lines.length;\n\n\tfor (var i = skip, length = skip + take; i < length; i++) {\n\t\tvar line = lines[i];\n\t\tif (!line)\n\t\t\tcontinue;\n\t\tvar m = line.match(regexpTERMINAL);\n\t\tm && fn(m, indexer++, length, i);\n\t}\n}\n\nfunction parseDateFormat(format, val) {\n\n\tvar tmp = [];\n\tvar tmpformat = [];\n\tvar prev = '';\n\tvar prevformat = '';\n\tvar allowed = { y: 1, Y: 1, M: 1, m: 1, d: 1, D: 1, H: 1, s: 1, a: 1, w: 1 };\n\n\tfor (var i = 0; i < format.length; i++) {\n\n\t\tvar c = format[i];\n\n\t\tif (!allowed[c])\n\t\t\tcontinue;\n\n\t\tif (prev !== c) {\n\t\t\tprevformat && tmpformat.push(prevformat);\n\t\t\tprevformat = c;\n\t\t\tprev = c;\n\t\t} else\n\t\t\tprevformat += c;\n\t}\n\n\tprev = '';\n\n\tfor (var i = 0; i < val.length; i++) {\n\t\tvar code = val.charCodeAt(i);\n\t\tif (code >= 48 && code <= 57)\n\t\t\tprev += val[i];\n\t}\n\n\tprevformat && tmpformat.push(prevformat);\n\n\tvar f = 0;\n\tfor (var i = 0; i < tmpformat.length; i++) {\n\t\tvar l = tmpformat[i].length;\n\t\ttmp.push(prev.substring(f, f + l));\n\t\tf += l;\n\t}\n\n\tvar dt = {};\n\n\tfor (var i = 0; i < tmpformat.length; i++) {\n\t\tvar type = tmpformat[i];\n\t\tif (tmp[i])\n\t\t\tdt[type[0]] = +tmp[i];\n\t}\n\n\tvar h = dt.h || dt.H;\n\n\tif (h != null) {\n\t\tvar ampm = val.match(REG_TIME);\n\t\tif (ampm && ampm[0].toLowerCase() === 'pm')\n\t\t\th += 12;\n\t}\n\n\treturn new Date((dt.y || dt.Y) || 0, (dt.M || 1) - 1, dt.d || dt.D || 0, h || 0, dt.m || 0, dt.s || 0);\n}\n\nSP.parseDate = function(format) {\n\n\tif (format)\n\t\treturn parseDateFormat(format, this);\n\n\tvar self = this.trim();\n\tvar lc = self.charCodeAt(self.length - 1);\n\n\t// Classic date\n\tif (lc === 41)\n\t\treturn new Date(self);\n\n\t// JSON format\n\tif (lc === 90)\n\t\treturn new Date(Date.parse(self));\n\n\tvar arr = self.indexOf(' ') === -1 ? self.split('T') : self.split(' ');\n\tvar index = arr[0].indexOf(':');\n\tvar length = arr[0].length;\n\n\tif (index !== -1) {\n\t\tvar tmp = arr[1];\n\t\tarr[1] = arr[0];\n\t\tarr[0] = tmp;\n\t}\n\n\tif (arr[0] === undefined)\n\t\tarr[0] = '';\n\n\tvar noTime = arr[1] === undefined ? true : arr[1].length === 0;\n\n\tfor (var i = 0; i < length; i++) {\n\t\tvar c = arr[0].charCodeAt(i);\n\t\tif (c === 45 || c === 46 || (c > 47 && c < 58))\n\t\t\tcontinue;\n\t\tif (noTime)\n\t\t\treturn new Date(self);\n\t}\n\n\tif (arr[1] === undefined)\n\t\tarr[1] = '00:00:00';\n\n\tvar firstDay = arr[0].indexOf('-') === -1;\n\n\tvar date = (arr[0] || '').split(firstDay ? '.' : '-');\n\tvar time = (arr[1] || '').split(':');\n\tvar parsed = [];\n\n\tif (date.length < 4 && time.length < 2)\n\t\treturn new Date(self);\n\n\tindex = (time[2] || '').indexOf('.');\n\n\t// milliseconds\n\tif (index !== -1) {\n\t\ttime[3] = time[2].substring(index + 1);\n\t\ttime[2] = time[2].substring(0, index);\n\t} else\n\t\ttime[3] = '0';\n\n\tparsed.push(+date[firstDay ? 2 : 0]); // year\n\tparsed.push(+date[1]); // month\n\tparsed.push(+date[firstDay ? 0 : 2]); // day\n\tparsed.push(+time[0]); // hours\n\tparsed.push(+time[1]); // minutes\n\tparsed.push(+time[2]); // seconds\n\tparsed.push(+time[3]); // miliseconds\n\n\tvar def = new Date();\n\n\tfor (var i = 0, length = parsed.length; i < length; i++) {\n\t\tif (isNaN(parsed[i]))\n\t\t\tparsed[i] = 0;\n\n\t\tvar value = parsed[i];\n\t\tif (value !== 0)\n\t\t\tcontinue;\n\n\t\tswitch (i) {\n\t\t\tcase 0:\n\t\t\t\tif (value <= 0)\n\t\t\t\t\tparsed[i] = def.getFullYear();\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tif (value <= 0)\n\t\t\t\t\tparsed[i] = def.getMonth() + 1;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tif (value <= 0)\n\t\t\t\t\tparsed[i] = def.getDate();\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn new Date(parsed[0], parsed[1] - 1, parsed[2], parsed[3], parsed[4] - NOW.getTimezoneOffset(), parsed[5]);\n};\n\nSP.parseDateExpiration = function() {\n\tvar self = this;\n\n\tvar arr = self.split(' ');\n\tvar dt = new Date();\n\tvar length = arr.length;\n\n\tfor (var i = 0; i < length; i += 2) {\n\t\tvar num = arr[i].parseInt();\n\t\tif (num === 0)\n\t\t\tcontinue;\n\t\tvar type = arr[i + 1];\n\t\tif (type)\n\t\t\tdt = dt.add(type, num);\n\t}\n\n\treturn dt;\n};\n\nvar configurereplace = function(text) {\n\tvar val = CONF[text.substring(1, text.length - 1)];\n\treturn val == null ? '' : val;\n};\n\nSP.env = function() {\n\treturn this.replace(regexpCONFIGURE, configurereplace);\n};\n\n/**\n * Parse configuration from a string\n * @param {Object} def\n * @onerr {Function} error handling\n * @return {Object}\n */\nSP.parseConfig = function(def, onerr) {\n\n\tif (typeof(def) === 'function') {\n\t\tonerr = def;\n\t\tdef = null;\n\t}\n\n\tvar arr = this.split('\\n');\n\tvar length = arr.length;\n\tvar obj = def ? exports.extend({}, def) : {};\n\tvar subtype;\n\tvar name;\n\tvar index;\n\tvar value;\n\n\tfor (var i = 0; i < length; i++) {\n\n\t\tvar str = arr[i];\n\t\tif (!str || str[0] === '#' || str.substring(0, 2) === '//')\n\t\t\tcontinue;\n\n\t\tindex = str.indexOf(':');\n\t\tif (index === -1) {\n\t\t\tindex = str.indexOf('\\t:');\n\t\t\tif (index === -1)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tname = str.substring(0, index).trim();\n\t\tvalue = str.substring(index + 2).trim();\n\n\t\tindex = name.indexOf('(');\n\t\tif (index !== -1) {\n\t\t\tsubtype = name.substring(index + 1, name.indexOf(')')).trim().toLowerCase();\n\t\t\tname = name.substring(0, index).trim();\n\t\t} else\n\t\t\tsubtype = '';\n\n\t\tswitch (subtype) {\n\t\t\tcase 'string':\n\t\t\t\tobj[name] = value;\n\t\t\t\tbreak;\n\t\t\tcase 'number':\n\t\t\tcase 'float':\n\t\t\tcase 'double':\n\t\t\tcase 'currency':\n\t\t\t\tobj[name] = value.isNumber(true) ? value.parseFloat2() : value.parseInt2();\n\t\t\t\tbreak;\n\t\t\tcase 'boolean':\n\t\t\tcase 'bool':\n\t\t\t\tobj[name] = (/true|on|1|enabled/i).test(value);\n\t\t\t\tbreak;\n\t\t\tcase 'config':\n\t\t\t\tobj[name] = CONF[value];\n\t\t\t\tbreak;\n\t\t\tcase 'eval':\n\t\t\tcase 'object':\n\t\t\tcase 'array':\n\t\t\t\ttry {\n\t\t\t\t\tobj[name] = new Function('return ' + value)();\n\t\t\t\t} catch (e) {\n\t\t\t\t\tif (onerr)\n\t\t\t\t\t\tonerr(e, arr[i]);\n\t\t\t\t\telse\n\t\t\t\t\t\tthrow new Error('A value of \"{0}\" can\\'t be converted to \"{1}\": '.format(name, subtype) + e.toString());\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'json':\n\t\t\t\tobj[name] = value.parseJSON(true);\n\t\t\t\tbreak;\n\t\t\tcase 'env':\n\t\t\tcase 'environment':\n\t\t\t\tobj[name] = process.env[value];\n\t\t\t\tbreak;\n\t\t\tcase 'date':\n\t\t\tcase 'time':\n\t\t\tcase 'datetime':\n\t\t\t\tobj[name] = value.parseDate();\n\t\t\t\tbreak;\n\t\t\tcase 'random':\n\t\t\t\tobj[name] = GUID((value || '0').parseInt() || 10);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tobj[name] = value;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn obj;\n};\n\nSP.format = function() {\n\tvar arg = arguments;\n\treturn this.replace(regexpSTRINGFORMAT, function(text) {\n\t\tvar value = arg[+text.substring(1, text.length - 1)];\n\t\treturn value == null ? '' : value;\n\t});\n};\n\nSP.encrypt_uid = function(key) {\n\treturn exports.encrypt_uid(this, key);\n};\n\nSP.decrypt_uid = function(key) {\n\treturn exports.decrypt_uid(this, key);\n};\n\nSP.encode = function() {\n\tvar output = '';\n\tfor (var i = 0, length = this.length; i < length; i++) {\n\t\tvar c = this[i];\n\t\tswitch (c) {\n\t\t\tcase '<':\n\t\t\t\toutput += '&lt;';\n\t\t\t\tbreak;\n\t\t\tcase '>':\n\t\t\t\toutput += '&gt;';\n\t\t\t\tbreak;\n\t\t\tcase '\"':\n\t\t\t\toutput += '&quot;';\n\t\t\t\tbreak;\n\t\t\tcase '\\'':\n\t\t\t\toutput += '&apos;';\n\t\t\t\tbreak;\n\t\t\tcase '&':\n\t\t\t\toutput += '&amp;';\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\toutput += c;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn output;\n};\n\nSP.decode = function() {\n\treturn this.replace(regexpDECODE, function(s) {\n\t\tif (s.charAt(1) !== '#')\n\t\t\treturn ALPHA_INDEX[s] || s;\n\t\tvar code = s[2].toLowerCase() === 'x' ? parseInt(s.substr(3), 16) : parseInt(s.substr(2));\n\t\treturn !code || code < -32768 || code > 65535 ? '' : String.fromCharCode(code);\n\t});\n};\n\nSP.arg = SP.args = function(obj, encode, def) {\n\tif (typeof(encode) === 'string')\n\t\tdef = encode;\n\treturn this.replace(regexpARG, function(text) {\n\t\t// Is double?\n\t\tvar l = text[1] === '{' ? 2 : 1;\n\t\tvar val = obj[text.substring(l, text.length - l).trim()];\n\t\tif (encode && encode === 'json')\n\t\t\treturn JSON.stringify(val);\n\t\treturn val == null ? (def == null ? text : def) : encode ? encode === 'html' ? (val + '').encode() : encodeURIComponent(val + '') : val;\n\t});\n};\n\nSP.max = function(length, chars) {\n\tvar str = this;\n\tif (chars == null)\n\t\tchars = '...';\n\treturn str.length > length ? str.substring(0, length - chars.length) + chars : str;\n};\n\nSP.isJSON = function() {\n\tvar self = this;\n\tif (self.length <= 1)\n\t\treturn false;\n\n\tvar l = self.length - 1;\n\tvar a;\n\tvar b;\n\tvar i = 0;\n\n\twhile (true) {\n\t\ta = self[i++];\n\t\tif (a === ' ' || a === '\\n' || a === '\\r' || a === '\\t')\n\t\t\tcontinue;\n\t\tbreak;\n\t}\n\n\twhile (true) {\n\t\tb = self[l--];\n\t\tif (b === ' ' || b === '\\n' || b === '\\r' || b === '\\t')\n\t\t\tcontinue;\n\t\tbreak;\n\t}\n\n\treturn (a === '\"' && b === '\"') || (a === '[' && b === ']') || (a === '{' && b === '}') || (a.charCodeAt(0) > 47 && b.charCodeAt(0) < 57);\n};\n\nSP.isURL = function() {\n\treturn this.length <= 7 ? false : DEF.validators.url.test(this);\n};\n\nSP.isZIP = function() {\n\treturn DEF.validators.zip.test(this);\n};\n\nSP.isEmail = function() {\n\treturn this.length <= 4 ? false : DEF.validators.email.test(this);\n};\n\nSP.isPhone = function() {\n\treturn this.length < 6 ? false : DEF.validators.phone.test(this);\n};\n\nSP.isBase64 = function(isdata) {\n\n\tvar str = this;\n\tvar count = str.length;\n\n\tif (isdata) {\n\t\tvar index = str.indexOf(';base64,');\n\t\tif (index !== -1)\n\t\t\tcount -= (index + 8);\n\t}\n\n\treturn count % 4 === 0 && (isdata ? regexpBASE64_2.test(str) : regexpBASE64.test(str));\n};\n\nSP.isUID = function() {\n\tvar str = this;\n\n\tif (str.length < 12 && str.length > 25)\n\t\treturn false;\n\n\tvar is = DEF.validators.uid.test(str);\n\tif (is) {\n\n\t\tvar sum;\n\t\tvar beg;\n\t\tvar end;\n\t\tvar e = str[str.length - 1];\n\n\t\tif (e === 'b' || e === 'c' || e === 'd') {\n\t\t\tsum = str[str.length - 2];\n\t\t\tbeg = +str[str.length - 3];\n\t\t\tend = str.length - 5;\n\t\t\tvar tmp = e === 'c' || e === 'd' ? (+str.substring(beg, end)) : parseInt(str.substring(beg, end), 16);\n\t\t\treturn sum === (tmp % 2 ? '1' : '0');\n\t\t} else if (e === 'a') {\n\t\t\tsum = str[str.length - 2];\n\t\t\tbeg = 6;\n\t\t\tend = str.length - 4;\n\t\t} else {\n\t\t\tsum = str[str.length - 1];\n\t\t\tbeg = 10;\n\t\t\tend = str.length - 4;\n\t\t}\n\n\t\twhile (beg++ < end) {\n\t\t\tif (str[beg] !== '0') {\n\t\t\t\tif (((+str.substring(beg, end)) % 2 ? '1' : '0') === sum)\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n};\n\nSP.parseUID = function() {\n\tvar self = this;\n\tvar obj = {};\n\tvar hash;\n\tvar e = self[self.length - 1];\n\n\tif (e === 'b' || e === 'c' || e === 'd') {\n\t\tend = +self[self.length - 3];\n\t\tvar ticks = ((e === 'b' ? (+self.substring(0, end)) : parseInt(self.substring(0, end), e=== 'd' ? 36 : 16)) * 1000 * 60) + 1580511600000; // 1.1.2020\n\t\tobj.date = new Date(ticks);\n\t\tbeg = end;\n\t\tend = self.length - 5;\n\t\thash = +self.substring(end + 3, end + 4);\n\t\tobj.century = Math.floor((obj.date.getFullYear() - 1) / 100) + 1;\n\t\tobj.hash = self.substring(end, end + 2);\n\t} else if (e === 'a') {\n\t\tvar ticks = ((+self.substring(0, 6)) * 1000 * 60) + 1548975600000; // old 1.1.2019\n\t\tobj.date = new Date(ticks);\n\t\tbeg = 7;\n\t\tend = self.length - 4;\n\t\thash = +self.substring(end + 2, end + 3);\n\t\tobj.century = Math.floor((obj.date.getFullYear() - 1) / 100) + 1;\n\t\tobj.hash = self.substring(end, end + 2);\n\t} else {\n\t\tvar y = self.substring(0, 2);\n\t\tvar M = self.substring(2, 4);\n\t\tvar d = self.substring(4, 6);\n\t\tvar H = self.substring(6, 8);\n\t\tvar m = self.substring(8, 10);\n\n\t\tobj.date = new Date(+('20' + y), (+M) - 1, +d, +H, +m, 0);\n\n\t\tvar beg = 0;\n\t\tvar end = 0;\n\t\tvar index = 10;\n\n\t\twhile (true) {\n\n\t\t\tvar c = self[index];\n\n\t\t\tif (!c)\n\t\t\t\tbreak;\n\n\t\t\tif (!beg && c !== '0')\n\t\t\t\tbeg = index;\n\n\t\t\tif (c.charCodeAt(0) > 96) {\n\t\t\t\tend = index;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tindex++;\n\t\t}\n\n\t\tobj.century = self.substring(end + 4);\n\n\t\tif (obj.century) {\n\t\t\tobj.century = 20 + (+obj.century);\n\t\t\tobj.date.setYear(obj.date.getFullYear() + 100);\n\t\t} else\n\t\t\tobj.century = 21;\n\n\t\thash = +self.substring(end + 3, end + 4);\n\t\tobj.hash = self.substring(end, end + 3);\n\t}\n\n\tobj.index = +self.substring(beg, end);\n\tobj.valid = (obj.index % 2 ? 1 : 0) === hash;\n\treturn obj;\n};\n\nSP.parseENV = function() {\n\n\tvar arr = this.split(regexpLINES);\n\tvar obj = {};\n\n\tfor (var i = 0; i < arr.length; i++) {\n\t\tvar line = arr[i];\n\t\tif (!line || line.substring(0, 2) === '//' || line[0] === '#')\n\t\t\tcontinue;\n\n\t\tvar index = line.indexOf('=');\n\t\tif (index === -1)\n\t\t\tcontinue;\n\n\t\tvar key = line.substring(0, index);\n\t\tvar val = line.substring(index + 1).replace(/\\\\n/g, '\\n');\n\t\tvar end = val.length - 1;\n\n\t\tif ((val[0] === '\"' && val[end] === '\"') || (val[0] === '\\'' && val[end] === '\\''))\n\t\t\tval = val.substring(1, end);\n\t\telse\n\t\t\tval = val.trim();\n\n\t\tobj[key] = val;\n\t}\n\n\treturn obj;\n};\n\nSP.parseInt = function(def) {\n\tvar str = this.trim();\n\tvar num = +str;\n\treturn isNaN(num) ? (def === undefined ? 0 : def) : num;\n};\n\nSP.parseInt2 = function(def) {\n\tvar num = this.match(regexpINTEGER);\n\treturn num ? +num[0] : (def === undefined ? 0 : def);\n};\n\nSP.parseFloat2 = function(def) {\n\tvar num = this.match(regexpFLOAT);\n\treturn num ? +num[0].toString().replace(/,/g, '.') : (def === undefined ? 0 : def);\n};\n\nSP.parseBoolean = function() {\n\tvar self = this.toLowerCase();\n\treturn self === 'true' || self === '1' || self === 'on';\n};\n\nSP.parseFloat = function(def) {\n\tvar str = this.trim();\n\tif (str.indexOf(',') !== -1)\n\t\tstr = str.replace(',', '.');\n\tvar num = +str;\n\treturn isNaN(num) ? (def === undefined ? 0 : def) : num;\n};\n\nSP.capitalize = function(first) {\n\n\tif (first)\n\t\treturn (this[0] || '').toUpperCase() + this.substring(1);\n\n\tvar builder = '';\n\tvar c;\n\n\tfor (var i = 0, length = this.length; i < length; i++) {\n\t\tvar c = this[i - 1];\n\t\tif (!c || (c === ' ' || c === '\\t' || c === '\\n'))\n\t\t\tc = this[i].toUpperCase();\n\t\telse\n\t\t\tc = this[i];\n\t\tbuilder += c;\n\t}\n\n\treturn builder;\n};\n\nSP.toUnicode = function() {\n\tvar output = '';\n\tfor (var i = 0; i < this.length; i++) {\n\t\tvar c = this[i].charCodeAt(0);\n\t\tif(c > 126 || c < 32)\n\t\t\toutput += '\\\\u' + ('000' + c.toString(16)).substr(-4);\n\t\telse\n\t\t\toutput += this[i];\n\t}\n\treturn output;\n};\n\nSP.fromUnicode = function() {\n\tvar output = '';\n\tfor (var i = 0; i < this.length; i++) {\n\t\tif (this[i] === '\\\\' && this[i + 1] === 'u') {\n\t\t\toutput += String.fromCharCode(parseInt(this[i + 2] + this[i + 3] + this[i + 4] + this[i + 5], 16));\n\t\t\ti += 5;\n\t\t} else\n\t\t\toutput += this[i];\n\t}\n\treturn output;\n};\n\nSP.sha1 = function(salt) {\n\tvar hash = Crypto.createHash('sha1');\n\thash.update(this + (salt || ''), ENCODING);\n\treturn hash.digest('hex');\n};\n\nSP.sha256 = function(salt) {\n\tvar hash = Crypto.createHash('sha256');\n\thash.update(this + (salt || ''), ENCODING);\n\treturn hash.digest('hex');\n};\n\nSP.sha512 = function(salt) {\n\tvar hash = Crypto.createHash('sha512');\n\thash.update(this + (salt || ''), ENCODING);\n\treturn hash.digest('hex');\n};\n\nSP.md5 = function(salt) {\n\tvar hash = Crypto.createHash('md5');\n\thash.update(this + (salt || ''), ENCODING);\n\treturn hash.digest('hex');\n};\n\nSP.toSearch = function() {\n\tvar str = this.replace(regexpSEARCH, '').trim().toLowerCase().toASCII();\n\tvar buf = [];\n\tvar prev = '';\n\tfor (var i = 0, length = str.length; i < length; i++) {\n\t\tvar c = str[i];\n\t\tif (c === 'y')\n\t\t\tc = 'i';\n\t\tif (c === prev)\n\t\t\tcontinue;\n\t\tprev = c;\n\t\tbuf.push(c);\n\t}\n\n\treturn buf.join('');\n};\n\nSP.toKeywords = SP.keywords = function(forSearch, alternative, max_count, max_length, min_length) {\n\treturn exports.keywords(this, forSearch, alternative, max_count, max_length, min_length);\n};\n\nfunction checksum(val) {\n\tvar sum = 0;\n\tfor (var i = 0; i < val.length; i++)\n\t\tsum += val.charCodeAt(i);\n\treturn sum;\n}\n\nSP.encrypt = function(key, isUnique, secret) {\n\tvar str = '0' + this;\n\tvar data_count = str.length;\n\tvar key_count = key.length;\n\tvar random = isUnique ? exports.random(120) + 40 : 65;\n\tvar count = data_count + (random % key_count);\n\tvar values = [];\n\tvar index = 0;\n\n\tvalues[0] = String.fromCharCode(random);\n\n\tvar counter = this.length + key.length;\n\n\tfor (var i = count - 1; i > 0; i--) {\n\t\tindex = str.charCodeAt(i % data_count);\n\t\tvalues[i] = String.fromCharCode(index ^ (key.charCodeAt(i % key_count) ^ random));\n\t}\n\n\tstr = Buffer.from(counter + '=' + values.join(''), ENCODING).toString('hex');\n\tvar sum = 0;\n\n\tfor (var i = 0; i < str.length; i++)\n\t\tsum += str.charCodeAt(i);\n\n\treturn (sum + checksum((secret || CONF.secret) + key)) + '-' + str;\n};\n\nSP.decrypt = function(key, secret) {\n\n\tvar index = this.indexOf('-');\n\tif (index === -1)\n\t\treturn null;\n\n\tvar cs = +this.substring(0, index);\n\tif (!cs || isNaN(cs))\n\t\treturn null;\n\n\tvar hash = this.substring(index + 1);\n\tvar sum = checksum((secret || CONF.secret) + key);\n\tfor (var i = 0; i < hash.length; i++)\n\t\tsum += hash.charCodeAt(i);\n\n\tif (sum !== cs)\n\t\treturn null;\n\n\tvar values = Buffer.from(hash, 'hex').toString(ENCODING);\n\tvar index = values.indexOf('=');\n\tif (index === -1)\n\t\treturn null;\n\n\tvar counter = +values.substring(0, index);\n\tif (isNaN(counter))\n\t\treturn null;\n\n\tvalues = values.substring(index + 1);\n\n\tvar count = values.length;\n\tvar random = values.charCodeAt(0);\n\tvar key_count = key.length;\n\tvar data_count = count - (random % key_count);\n\tvar decrypt_data = [];\n\n\tfor (var i = data_count - 1; i > 0; i--) {\n\t\tindex = values.charCodeAt(i) ^ (random ^ key.charCodeAt(i % key_count));\n\t\tdecrypt_data[i] = String.fromCharCode(index);\n\t}\n\n\tvar val = decrypt_data.join('');\n\treturn counter !== (val.length + key.length) ? null : val;\n};\n\nexports.encrypt_data = function(value, key, encode) {\n\n\tvar builder = [];\n\tvar index = 0;\n\tvar length = key.length;\n\n\tfor (var i = 0; i < value.length; i++) {\n\n\t\tif (SKIPBODYENCRYPTOR[value[i]]) {\n\t\t\tbuilder.push(value[i]);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (index === length)\n\t\t\tindex = 0;\n\n\t\tvar a = value.charCodeAt(i) + 2;\n\t\tvar b = key.charCodeAt(index++);\n\t\tvar t = (a + b).toString(36);\n\t\tbuilder.push(t.length + t);\n\t}\n\n\tvar mask = Buffer.alloc(4);\n\tmask.writeInt32BE((Math.random() * 214748364) >> 0);\n\n\tvar buffer = Buffer.from(builder.join(''));\n\tfor (var i = 0; i < buffer.length; i++)\n\t\tbuffer[i] = buffer[i] ^ mask[i % 4];\n\n\tvar buf = Buffer.concat([mask, buffer]);\n\treturn encode === 'buffer' ? buf : buf.toString(encode || 'base64');\n};\n\nexports.decrypt_data = function(value, key, encode) {\n\n\ttry {\n\t\tvalue = value instanceof Buffer ? value : Buffer.from(value, encode || 'base64');\n\t} catch (e) {\n\t\treturn null;\n\t}\n\n\tvar index = 0;\n\tvar length = key.length;\n\tvar builder = [];\n\tvar mask = Buffer.alloc(4);\n\tvar buffer = Buffer.alloc(value.length - 4);\n\tmask.writeInt32BE(value.readInt32BE(0));\n\n\tfor (var i = 4; i < value.length; i++)\n\t\tbuffer[i - 4] = value[i] ^ mask[i % 4];\n\n\tvalue = buffer.toString('utf8');\n\n\tfor (var i = 0; i < value.length; i++) {\n\n\t\tvar c = value[i];\n\n\t\tif (SKIPBODYENCRYPTOR[c]) {\n\t\t\tbuilder.push(c);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (index === length)\n\t\t\tindex = 0;\n\n\t\tvar l = +value.charAt(i);\n\t\tvar code = parseInt(value.substring(i + 1, i + 1 + l), 36);\n\t\tvar b = key.charCodeAt(index++);\n\t\tbuilder.push(String.fromCharCode(code - b - 2));\n\t\ti += l;\n\t}\n\n\treturn builder.join('');\n};\n\nexports.encrypt_uid = function(val, key) {\n\n\tvar num = typeof(val) === 'number';\n\tvar sum = 0;\n\n\tif (!key)\n\t\tkey = CONF.secret;\n\n\tval = val + '';\n\n\tfor (var i = 0; i < val.length; i++)\n\t\tsum += val.charCodeAt(i);\n\n\tfor (var i = 0; i < key.length; i++)\n\t\tsum += key.charCodeAt(i);\n\n\treturn (num ? 'n' : 'x') + (CONF.secret_uid + val + sum + key).crc32(true).toString(32) + 'x' + val;\n};\n\nexports.decrypt_uid = function(val, key) {\n\tvar num = val[0] === 'n';\n\tvar raw = val.substring(val.indexOf('x', 1) + 1);\n\n\tif (num)\n\t\traw = +raw;\n\n\treturn exports.encrypt_uid(raw, key) === val ? raw : null;\n};\n\nexports.encrypt_crypto = function(type, key, value) {\n\tif (!F.temporary.keys[key])\n\t\tF.temporary.keys[key] = Buffer.from(key);\n\tvar cipher = Crypto.createCipheriv(type, F.temporary.keys[key], CONF.default_crypto_iv);\n\tCONCAT[0] = cipher.update(value);\n\tCONCAT[1] = cipher.final();\n\treturn Buffer.concat(CONCAT);\n};\n\nexports.decrypt_crypto = function(type, key, value) {\n\tif (!F.temporary.keys[key])\n\t\tF.temporary.keys[key] = Buffer.from(key);\n\tvar decipher = Crypto.createDecipheriv(type, F.temporary.keys[key], CONF.default_crypto_iv);\n\ttry {\n\t\tCONCAT[0] = decipher.update(value);\n\t\tCONCAT[1] = decipher.final();\n\t\treturn Buffer.concat(CONCAT);\n\t} catch (e) {}\n};\n\nSP.base64ToFile = function(filename, callback) {\n\tvar self = this;\n\tvar index = self.indexOf(',');\n\tif (index === -1)\n\t\tindex = 0;\n\telse\n\t\tindex++;\n\tFs.writeFile(filename, self.substring(index), 'base64', callback || NOOP);\n\treturn this;\n};\n\nSP.base64ToBuffer = function() {\n\tvar self = this;\n\n\tvar index = self.indexOf(',');\n\tif (index === -1)\n\t\tindex = 0;\n\telse\n\t\tindex++;\n\n\treturn Buffer.from(self.substring(index), 'base64');\n};\n\nSP.base64ContentType = function() {\n\tvar self = this;\n\tvar index = self.indexOf(';');\n\treturn index === -1 ? '' : self.substring(5, index);\n};\n\nvar toascii = c => DIACRITICSMAP[c] || c;\n\nSP.toASCII = function() {\n\treturn this.replace(regexpDiacritics, toascii);\n};\n\nSP.indent = function(max, c) {\n\tvar plus = '';\n\tif (c === undefined)\n\t\tc = ' ';\n\twhile (max--)\n\t\tplus += c;\n\treturn plus + this;\n};\n\nSP.isNumber = function(isDecimal) {\n\n\tvar self = this;\n\tvar length = self.length;\n\n\tif (!length)\n\t\treturn false;\n\n\tisDecimal = isDecimal || false;\n\n\tfor (var i = 0; i < length; i++) {\n\t\tvar ascii = self.charCodeAt(i);\n\n\t\tif (isDecimal) {\n\t\t\tif (ascii === 44 || ascii === 46) {\n\t\t\t\tisDecimal = false;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (ascii < 48 || ascii > 57)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n};\n\nif (!SP.padLeft) {\n\tSP.padLeft = function(max, c) {\n\t\tvar self = this;\n\t\tvar len = max - self.length;\n\t\tif (len < 0)\n\t\t\treturn self;\n\t\tif (c === undefined)\n\t\t\tc = ' ';\n\t\twhile (len--)\n\t\t\tself = c + self;\n\t\treturn self;\n\t};\n}\n\n\nif (!SP.padRight) {\n\tSP.padRight = function(max, c) {\n\t\tvar self = this;\n\t\tvar len = max - self.length;\n\t\tif (len < 0)\n\t\t\treturn self;\n\t\tif (c === undefined)\n\t\t\tc = ' ';\n\t\twhile (len--)\n\t\t\tself += c;\n\t\treturn self;\n\t};\n}\n\nSP.insert = function(index, value) {\n\tvar str = this;\n\tvar a = str.substring(0, index);\n\tvar b = value.toString() + str.substring(index);\n\treturn a + b;\n};\n\n/**\n * Create a link from String\n * @param  {Number} max A maximum length, default: 60 and optional.\n * @return {String}\n */\nSP.slug = function(max) {\n\tmax = max || 60;\n\n\tvar self = this.trim().toLowerCase().toASCII();\n\tvar builder = '';\n\tvar length = self.length;\n\n\tfor (var i = 0; i < length; i++) {\n\t\tvar c = self[i];\n\t\tvar code = self.charCodeAt(i);\n\n\t\tif (code > 540){\n\t\t\tbuilder = '';\n\t\t\tbreak;\n\t\t}\n\n\t\tif (builder.length >= max)\n\t\t\tbreak;\n\n\t\tif (code > 31 && code < 48) {\n\t\t\tif (builder[builder.length - 1] !== '-')\n\t\t\t\tbuilder += '-';\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ((code > 47 && code < 58) || (code > 94 && code < 123))\n\t\t\tbuilder += c;\n\t}\n\n\tif (builder.length > 1) {\n\t\tlength = builder.length - 1;\n\t\treturn builder[length] === '-' ? builder.substring(0, length) : builder;\n\t} else if (!length)\n\t\treturn '';\n\n\tlength = self.length;\n\tself = self.replace(/\\s/g, '');\n\tbuilder = self.crc32(true).toString(36) + '';\n\treturn self[0].charCodeAt(0).toString(32) + builder + self[self.length - 1].charCodeAt(0).toString(32) + length;\n};\n\nSP.pluralize = function(zero, one, few, other) {\n\treturn this.parseInt().pluralize(zero, one, few, other);\n};\n\nSP.isBoolean = function() {\n\tvar self = this.toLowerCase();\n\treturn (self === 'true' || self === 'false') ? true : false;\n};\n\n/**\n* Remove all Html Tags from a string\n* @return {string}\n*/\nSP.removeTags = function() {\n\treturn this.replace(regexpTags, '');\n};\n\nNP.between = function(condition, otherwise) {\n\n\tvar val = this;\n\n\tfor (var key in condition) {\n\n\t\tvar arr = key.split('-');\n\n\t\tvar a = arr[0] ? +arr[0] : null;\n\t\tvar b = arr[1] ? +arr[1] : null;\n\n\t\tif (a != null && b !== null) {\n\t\t\tif (val >= a && val <= b)\n\t\t\t\treturn condition[key];\n\t\t} else if (a != null) {\n\t\t\tif (val >= a)\n\t\t\t\treturn condition[key];\n\t\t} else if (b != null)\n\t\t\tif (val <= b)\n\t\t\t\treturn condition[key];\n\t}\n\n\treturn otherwise;\n};\n\nNP.floor = function(decimals) {\n\treturn Math.floor(this * Math.pow(10, decimals)) / Math.pow(10, decimals);\n};\n\nNP.fixed = function(decimals) {\n\treturn +this.toFixed(decimals);\n};\n\nNP.padLeft = function(max, c) {\n\treturn this.toString().padLeft(max, c || '0');\n};\n\nNP.padRight = function(max, c) {\n\treturn this.toString().padRight(max, c || '0');\n};\n\nNP.round = function(precision) {\n\tvar m = Math.pow(10, precision) || 1;\n\treturn Math.round(this * m) / m;\n};\n\nNP.currency = function(currency, a, b, c) {\n\tvar curr = DEF.currencies[currency || 'default'];\n\treturn curr ? curr(this, a, b, c) : this.format(2);\n};\n\n/**\n * Async decrements\n * @param {Function(index, next)} fn\n * @param {Function} callback\n * @return {Number}\n */\nNP.async = function(fn, callback) {\n\tvar number = this;\n\tif (number)\n\t\tfn(number--, () => setImmediate(() => number.async(fn, callback)));\n\telse\n\t\tcallback && callback();\n\treturn number;\n};\n\n/**\n * Format number\n * @param {Number} decimals Maximum decimal numbers\n * @param {String} separator Number separator, default ' '\n * @param {String} separatorDecimal Decimal separator, default '.' if number separator is ',' or ' '.\n * @return {String}\n */\nNP.format = function(decimals, separator, separatorDecimal) {\n\n\tvar self = this;\n\tvar num = self.toString();\n\tvar dec = '';\n\tvar output = '';\n\tvar minus = num[0] === '-' ? '-' : '';\n\tif (minus)\n\t\tnum = num.substring(1);\n\n\tvar index = num.indexOf('.');\n\n\tif (typeof(decimals) === 'string') {\n\t\tvar tmp = separator;\n\t\tseparator = decimals;\n\t\tdecimals = tmp;\n\t}\n\n\tif (separator === undefined)\n\t\tseparator = ' ';\n\n\tif (index !== -1) {\n\t\tdec = num.substring(index + 1);\n\t\tnum = num.substring(0, index);\n\t}\n\n\tindex = -1;\n\tfor (var i = num.length - 1; i >= 0; i--) {\n\t\tindex++;\n\t\tif (index > 0 && index % 3 === 0)\n\t\t\toutput = separator + output;\n\t\toutput = num[i] + output;\n\t}\n\n\tif (decimals || dec.length) {\n\t\tif (dec.length > decimals)\n\t\t\tdec = dec.substring(0, decimals || 0);\n\t\telse\n\t\t\tdec = dec.padRight(decimals || 0, '0');\n\t}\n\n\tif (dec.length && separatorDecimal === undefined)\n\t\tseparatorDecimal = separator === '.' ? ',' : '.';\n\n\treturn minus + output + (dec.length ? separatorDecimal + dec : '');\n};\n\nNP.add = function(value, decimals) {\n\n\tif (value == null)\n\t\treturn this;\n\n\tif (typeof(value) === 'number')\n\t\treturn this + value;\n\n\tvar first = value.charCodeAt(0);\n\tvar is = false;\n\n\tif (first < 48 || first > 57) {\n\t\tis = true;\n\t\tvalue = value.substring(1);\n\t}\n\n\tvar length = value.length;\n\tvar num;\n\n\tif (value[length - 1] === '%') {\n\t\tvalue = value.substring(0, length - 1);\n\t\tif (is) {\n\t\t\tvar val = value.parseFloat();\n\t\t\tswitch (first) {\n\t\t\t\tcase 42:\n\t\t\t\t\tnum = this * ((this / 100) * val);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 43:\n\t\t\t\t\tnum = this + ((this / 100) * val);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 45:\n\t\t\t\t\tnum = this - ((this / 100) * val);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 47:\n\t\t\t\t\tnum = this / ((this / 100) * val);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\treturn decimals !== undefined ? num.floor(decimals) : num;\n\t\t} else {\n\t\t\tnum = (this / 100) * value.parseFloat();\n\t\t\treturn decimals !== undefined ? num.floor(decimals) : num;\n\t\t}\n\n\t} else\n\t\tnum = value.parseFloat();\n\n\tswitch (first) {\n\t\tcase 42:\n\t\t\tnum = this * num;\n\t\t\tbreak;\n\t\tcase 43:\n\t\t\tnum = this + num;\n\t\t\tbreak;\n\t\tcase 45:\n\t\t\tnum = this - num;\n\t\t\tbreak;\n\t\tcase 47:\n\t\t\tnum = this / num;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tnum = this;\n\t\t\tbreak;\n\t}\n\n\tif (decimals !== undefined)\n\t\treturn num.floor(decimals);\n\n\treturn num;\n};\n\nNP.pluralize = function(zero, one, few, other) {\n\n\tvar num = this;\n\tvar value = '';\n\n\tif (num == 0)\n\t\tvalue = zero || '';\n\telse if (num == 1)\n\t\tvalue = one || '';\n\telse if (num > 1 && num < 5)\n\t\tvalue = few || '';\n\telse\n\t\tvalue = other;\n\n\tvar beg = value.indexOf('#');\n\tif (beg === -1)\n\t\treturn value;\n\n\tvar end = value.lastIndexOf('#');\n\tvar format = value.substring(beg, end + 1);\n\treturn num.format(format) + value.replace(format, '');\n};\n\nNP.hex = function(length) {\n\tvar str = this.toString(16).toUpperCase();\n\twhile(str.length < length)\n\t\tstr = '0' + str;\n\treturn str;\n};\n\nNP.VAT = function(percentage, decimals, includedVAT) {\n\tvar num = this;\n\tvar type = typeof(decimals);\n\n\tif (type === 'boolean') {\n\t\tvar tmp = includedVAT;\n\t\tincludedVAT = decimals;\n\t\tdecimals = tmp;\n\t\ttype = typeof(decimals);\n\t}\n\n\tif (type === 'undefined')\n\t\tdecimals = 2;\n\n\treturn !percentage || !num ? num.round(decimals) : includedVAT ? (num / ((percentage / 100) + 1)).round(decimals) : (num * ((percentage / 100) + 1)).round(decimals);\n};\n\nNP.discount = function(percentage, decimals) {\n\tvar num = this;\n\tif (decimals === undefined)\n\t\tdecimals = 2;\n\treturn !num || !percentage ? num : (num - (num / 100) * percentage).floor(decimals);\n};\n\nNP.parseDate = function(plus) {\n\treturn new Date(this + (plus || 0));\n};\n\nif (!NP.toRad) {\n\tNP.toRad = function () {\n\t\treturn this * Math.PI / 180;\n\t};\n}\n\nNP.filesize = function(decimals, type) {\n\n\tif (typeof(decimals) === 'string') {\n\t\tvar tmp = type;\n\t\ttype = decimals;\n\t\tdecimals = tmp;\n\t}\n\n\tvar value;\n\n\t// this === bytes\n\tswitch (type) {\n\t\tcase 'bytes':\n\t\t\tvalue = this;\n\t\t\tbreak;\n\t\tcase 'KB':\n\t\t\tvalue = this / 1024;\n\t\t\tbreak;\n\t\tcase 'MB':\n\t\t\tvalue = filesizehelper(this, 2);\n\t\t\tbreak;\n\t\tcase 'GB':\n\t\t\tvalue = filesizehelper(this, 3);\n\t\t\tbreak;\n\t\tcase 'TB':\n\t\t\tvalue = filesizehelper(this, 4);\n\t\t\tbreak;\n\t\tdefault:\n\n\t\t\ttype = 'bytes';\n\t\t\tvalue = this;\n\n\t\t\tif (value > 1023) {\n\t\t\t\tvalue = value / 1024;\n\t\t\t\ttype = 'KB';\n\t\t\t}\n\n\t\t\tif (value > 1023) {\n\t\t\t\tvalue = value / 1024;\n\t\t\t\ttype = 'MB';\n\t\t\t}\n\n\t\t\tif (value > 1023) {\n\t\t\t\tvalue = value / 1024;\n\t\t\t\ttype = 'GB';\n\t\t\t}\n\n\t\t\tif (value > 1023) {\n\t\t\t\tvalue = value / 1024;\n\t\t\t\ttype = 'TB';\n\t\t\t}\n\n\t\t\tbreak;\n\t}\n\n\ttype = ' ' + type;\n\treturn (decimals === undefined ? value.format(2).replace('.00', '') : value.format(decimals)) + type;\n};\n\nfunction filesizehelper(number, count) {\n\twhile (count--) {\n\t\tnumber = number / 1024;\n\t\tif (number.toFixed(3) === '0.000')\n\t\t\treturn 0;\n\t}\n\treturn number;\n}\n\nvar AP = Array.prototype;\n\n/**\n * Take items from array\n * @param {Number} count\n * @return {Array}\n */\nAP.take = function(count) {\n\tvar arr = [];\n\tvar self = this;\n\tfor (var i = 0; i < self.length; i++) {\n\t\tarr.push(self[i]);\n\t\tif (arr.length >= count)\n\t\t\treturn arr;\n\t}\n\treturn arr;\n};\n\n/**\n * First item in array\n * @param {Object} def Default value.\n * @return {Object}\n */\nAP.first = function(def) {\n\tvar item = this[0];\n\treturn item === undefined ? def : item;\n};\n\n/**\n * Create object from Array\n * @param {String} name Optional, property name.\n * @return {Object}\n */\nAP.toObject = function(name) {\n\n\tvar self = this;\n\tvar obj = {};\n\n\tfor (var i = 0; i < self.length; i++) {\n\t\tvar item = self[i];\n\t\tif (name)\n\t\t\tobj[item[name]] = item;\n\t\telse\n\t\t\tobj[item] = true;\n\t}\n\n\treturn obj;\n};\n\n/**\n * Last item in array\n * @param {Object} def Default value.\n * @return {Object}\n */\nAP.last = function(def) {\n\tvar item = this[this.length - 1];\n\treturn item === undefined ? def : item;\n};\n\nAP.quicksort = function(sort) {\n\n\tvar self = this;\n\tif (self.length < 2)\n\t\treturn self;\n\n\t// Backward compatibility\n\tif (!sort) {\n\t\tself.sort(COMPARER);\n\t\treturn self;\n\t}\n\n\t// Backward compatibility\n\tif (sort === true) {\n\t\tself.sort(COMPARER_DESC);\n\t\treturn self;\n\t}\n\n\tif (arguments[1] === true || arguments[1] === 2)\n\t\tsort += '_desc';\n\n\tshellsort(self, exports.sortcomparer(sort));\n\treturn self;\n};\n\nexports.sortcomparer = function(sort) {\n\n\tvar key = 'sort_' + sort;\n\tvar meta = F.temporary.other[key];\n\n\tif (!meta) {\n\t\tmeta = [];\n\t\tsort = sort.replace(/\\s/g, '').split(',');\n\t\tfor (var i = 0; i < sort.length; i++) {\n\t\t\tvar tmp = sort[i].split((/_(desc|asc)/));\n\t\t\tvar obj = { name: tmp[0], type: null, desc: tmp[1] === 'desc' };\n\t\t\tif (tmp[0].indexOf('.') !== -1)\n\t\t\t\tobj.read = new Function('val', 'return val.' + tmp[0].replace(/\\./g, '?.'));\n\t\t\tmeta.push(obj);\n\t\t}\n\t\tF.temporary.other[key] = meta;\n\t}\n\n\treturn function(a, b) {\n\t\tfor (var i = 0; i < meta.length; i++) {\n\t\t\tvar col = meta[i];\n\t\t\tvar va = col.read ? col.read(a) : a[col.name];\n\t\t\tvar vb = col.read ? col.read(b) : b[col.name];\n\n\t\t\tif (!col.type) {\n\t\t\t\tif (va != null)\n\t\t\t\t\tcol.type = va instanceof Date ? 4 : typeof(va);\n\t\t\t\telse if (vb != null)\n\t\t\t\t\tcol.type = vb instanceof Date ? 4: typeof(vb);\n\t\t\t\tswitch (col.type) {\n\t\t\t\t\tcase 'string':\n\t\t\t\t\t\tcol.type = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'number':\n\t\t\t\t\t\tcol.type = 2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'boolean':\n\t\t\t\t\t\tcol.type = 3;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'object':\n\t\t\t\t\t\tcol.type = 5;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (col.type) {\n\t\t\t\tswitch (col.type) {\n\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\ttmp = col.desc ? COMPARER_DESC(va, vb) : COMPARER(va, vb);\n\t\t\t\t\t\tif (tmp)\n\t\t\t\t\t\t\treturn tmp;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\ttmp = va > vb ? (col.desc ? -1 : 1) : va < vb ? (col.desc ? 1 : -1) : 0;\n\t\t\t\t\t\tif (tmp)\n\t\t\t\t\t\t\treturn tmp;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 3:\n\t\t\t\t\t\ttmp = va === true && vb === false ? (col.desc ? -1 : 1) : va === false && vb === true ? (col.desc ? 1 : -1) : 0;\n\t\t\t\t\t\tif (tmp)\n\t\t\t\t\t\t\treturn tmp;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 4:\n\n\t\t\t\t\t\tif (!va && !vb)\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tif (va && !vb)\n\t\t\t\t\t\t\treturn col.desc ? -1 : 1;\n\n\t\t\t\t\t\tif (!va && vb)\n\t\t\t\t\t\t\treturn col.desc ? 1 : -1;\n\n\t\t\t\t\t\tif (!va.getTime)\n\t\t\t\t\t\t\tva = new Date(va);\n\n\t\t\t\t\t\tif (!vb.getTime)\n\t\t\t\t\t\t\tvb = new Date(vb);\n\n\t\t\t\t\t\ttmp = va > vb ? (col.desc ? -1 : 1) : va < vb ? (col.desc ? 1 : -1) : 0;\n\n\t\t\t\t\t\tif (tmp)\n\t\t\t\t\t\t\treturn tmp;\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\treturn 0;\n\t\t}\n\n\t\treturn 0;\n\t};\n};\n\nAP.trim = function() {\n\tvar self = this;\n\tvar output = [];\n\tfor (var i = 0, length = self.length; i < length; i++) {\n\t\tif (typeof(self[i]) === 'string')\n\t\t\tself[i] = self[i].trim();\n\t\tself[i] && output.push(self[i]);\n\t}\n\treturn output;\n};\n\n/**\n * Skip items from array\n * @param {Number} count\n * @return {Array}\n */\nAP.skip = function(count) {\n\tvar arr = [];\n\tvar self = this;\n\tvar length = self.length;\n\tfor (var i = 0; i < length; i++)\n\t\ti >= count && arr.push(self[i]);\n\treturn arr;\n};\n\n/**\n * Find items in Array\n * @param {Function(item, index) or String/Object} cb\n * @param {Object} value Optional.\n * @return {Array}\n */\nAP.findAll = function(cb, value) {\n\n\tvar self = this;\n\tvar selected = [];\n\tvar isFN = typeof(cb) === 'function';\n\tvar isV = value !== undefined;\n\n\tfor (var i = 0, length = self.length; i < length; i++) {\n\n\t\tif (isFN) {\n\t\t\tcb.call(self, self[i], i) && selected.push(self[i]);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (isV) {\n\t\t\tself[i] && self[i][cb] === value && selected.push(self[i]);\n\t\t\tcontinue;\n\t\t}\n\n\t\tself[i] === cb && selected.push(self[i]);\n\t}\n\n\treturn selected;\n};\n\nAP.findValue = function(cb, value, path, def) {\n\tvar index = this.findIndex(cb, value);\n\tif (index !== -1) {\n\t\tvar item = this[index][path];\n\t\treturn item == null ? def : item;\n\t}\n\treturn def;\n};\n\nAP.findItem = function(cb, value) {\n\tvar self = this;\n\tvar index = self.findIndex(cb, value);\n\tif (index === -1)\n\t\treturn null;\n\treturn self[index];\n};\n\nAP.findIndex = function(cb, value) {\n\n\tvar self = this;\n\tvar isFN = typeof(cb) === 'function';\n\tvar isV = value !== undefined;\n\n\tfor (var i = 0, length = self.length; i < length; i++) {\n\n\t\tif (isFN) {\n\t\t\tif (cb.call(self, self[i], i))\n\t\t\t\treturn i;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (isV) {\n\t\t\tif (self[i] && self[i][cb] === value)\n\t\t\t\treturn i;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (self[i] === cb)\n\t\t\treturn i;\n\t}\n\n\treturn -1;\n};\n\n/**\n * Remove items from Array\n * @param {Function(item, index) or Object} cb\n * @param {Object} value Optional.\n * @return {Array}\n */\nAP.remove = function(cb, value) {\n\n\tvar self = this;\n\tvar arr = [];\n\tvar isFN = typeof(cb) === 'function';\n\tvar isV = value !== undefined;\n\n\tfor (var i = 0, length = self.length; i < length; i++) {\n\n\t\tif (isFN) {\n\t\t\t!cb.call(self, self[i], i) && arr.push(self[i]);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (isV) {\n\t\t\tself[i] && self[i][cb] !== value && arr.push(self[i]);\n\t\t\tcontinue;\n\t\t}\n\n\t\tself[i] !== cb && arr.push(self[i]);\n\t}\n\treturn arr;\n};\n\nAP.wait = function(onItem, callback, thread, tmp) {\n\n\tvar self = this;\n\tvar init = false;\n\n\t// INIT\n\tif (!tmp) {\n\n\t\tif (typeof(callback) !== 'function') {\n\t\t\tthread = callback;\n\t\t\tcallback = null;\n\t\t}\n\n\t\ttmp = {};\n\t\ttmp.pending = 0;\n\t\ttmp.index = 0;\n\t\ttmp.thread = thread;\n\n\t\t// thread === Boolean then array has to be removed item by item\n\n\t\tinit = true;\n\t}\n\n\tvar item = thread === true ? self.shift() : self[tmp.index++];\n\tif (item === undefined) {\n\t\tif (!tmp.pending) {\n\t\t\tcallback && callback();\n\t\t\ttmp.cancel = true;\n\t\t}\n\t\treturn self;\n\t}\n\n\ttmp.pending++;\n\tonItem.call(self, item, () => setImmediate(next_wait, self, onItem, callback, thread, tmp), tmp.index);\n\n\tif (!init || tmp.thread === 1)\n\t\treturn self;\n\n\tfor (var i = 1; i < tmp.thread; i++)\n\t\tself.wait(onItem, callback, 1, tmp);\n\n\treturn self;\n};\n\nfunction next_wait(self, onItem, callback, thread, tmp) {\n\ttmp.pending--;\n\tself.wait(onItem, callback, thread, tmp);\n}\n\n/**\n * Creates a function async list\n * @param {Function} callback Optional\n * @return {Array}\n */\nAP.async = function(thread, callback, pending) {\n\n\tvar self = this;\n\n\tif (typeof(thread) === 'function') {\n\t\tcallback = thread;\n\t\tthread = 1;\n\t} else if (thread === undefined)\n\t\tthread = 1;\n\n\tif (pending === undefined)\n\t\tpending = 0;\n\n\tvar item = self.shift();\n\tif (item === undefined) {\n\t\tif (!pending) {\n\t\t\tpending = undefined;\n\t\t\tcallback && callback();\n\t\t}\n\t\treturn self;\n\t}\n\n\tfor (var i = 0; i < thread; i++) {\n\n\t\tif (i)\n\t\t\titem = self.shift();\n\n\t\tpending++;\n\t\titem(function() {\n\t\t\tsetImmediate(function() {\n\t\t\t\tpending--;\n\t\t\t\tself.async(1, callback, pending);\n\t\t\t});\n\t\t});\n\t}\n\n\treturn self;\n};\n\n// Fisher-Yates shuffle\nAP.random = function(item) {\n\tif (item)\n\t\treturn this[exports.random(this.length - 1)];\n\tfor (var i = this.length - 1; i > 0; i--) {\n\t\tvar j = Math.floor(Math.random() * (i + 1));\n\t\tvar temp = this[i];\n\t\tthis[i] = this[j];\n\t\tthis[j] = temp;\n\t}\n\treturn this;\n};\n\nAP.limit = function(max, fn, callback, index) {\n\n\tif (index === undefined)\n\t\tindex = 0;\n\n\tvar current = [];\n\tvar self = this;\n\tvar length = index + max;\n\n\tfor (var i = index; i < length; i++) {\n\t\tvar item = self[i];\n\n\t\tif (item !== undefined) {\n\t\t\tcurrent.push(item);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!current.length) {\n\t\t\tcallback && callback();\n\t\t\treturn self;\n\t\t}\n\n\t\tfn(current, () => callback && callback(), index, index + max);\n\t\treturn self;\n\t}\n\n\tif (!current.length) {\n\t\tcallback && callback();\n\t\treturn self;\n\t}\n\n\tfn(current, function() {\n\t\tif (length < self.length)\n\t\t\tself.limit(max, fn, callback, length);\n\t\telse\n\t\t\tcallback && callback();\n\t}, index, index + max);\n\n\treturn self;\n};\n\nArrayBuffer.prototype.toBuffer = function() {\n\tvar buf = new Buffer(this.byteLength);\n\tvar view = new Uint8Array(this);\n\tfor (var i = 0; i < buf.length; ++i)\n\t\tbuf[i] = view[i];\n\treturn buf;\n};\n\nfunction FileList() {\n\tthis.pending = [];\n\tthis.pendingDirectory = [];\n\tthis.directory = [];\n\tthis.file = [];\n\tthis.onComplete = null;\n\tthis.onFilter = null;\n\tthis.advanced = false;\n}\n\nconst FLP = FileList.prototype;\n\nFLP.reset = function() {\n\tthis.file.length = 0;\n\tthis.directory.length = 0;\n\tthis.pendingDirectory.length = 0;\n\treturn this;\n};\n\nFLP.walk = function(directory) {\n\n\tvar self = this;\n\n\tif (directory instanceof Array) {\n\t\tvar length = directory.length;\n\t\tfor (var i = 0; i < length; i++)\n\t\t\tself.pendingDirectory.push(directory[i]);\n\t\tself.next();\n\t\treturn;\n\t}\n\n\tFs.readdir(directory, function(err, arr) {\n\t\tif (err)\n\t\t\treturn self.next();\n\t\tvar length = arr.length;\n\t\tfor (var i = 0; i < length; i++)\n\t\t\tself.pending.push(Path.join(directory, arr[i]));\n\t\tself.next();\n\t});\n};\n\nFLP.stat = function(path) {\n\tvar self = this;\n\n\tFs.stat(path, function(err, stats) {\n\n\t\tif (err)\n\t\t\treturn self.next();\n\n\t\tif (stats.isDirectory()) {\n\t\t\tpath = self.clean(path);\n\t\t\tif (!self.onFilter || self.onFilter(path, true)) {\n\t\t\t\tself.directory.push(path);\n\t\t\t\tself.pendingDirectory.push(path);\n\t\t\t}\n\t\t} else if (!self.onFilter || self.onFilter(path, false))\n\t\t\tself.file.push(self.advanced ? { filename: path, stats: stats } : path);\n\n\t\tself.next();\n\t});\n};\n\nFLP.clean = function(path) {\n\treturn path[path.length - 1] === Path.sep ? path : path + Path.sep;\n};\n\nFLP.next = function() {\n\tvar self = this;\n\n\tif (self.pending.length) {\n\t\tvar item = self.pending.shift();\n\t\tself.stat(item);\n\t\treturn;\n\t}\n\n\tif (self.pendingDirectory.length) {\n\t\tvar directory = self.pendingDirectory.shift();\n\t\tself.walk(directory);\n\t\treturn;\n\t}\n\n\tself.onComplete(self.file, self.directory);\n};\n\nexports.sync = function(fn, owner) {\n\treturn function() {\n\n\t\tvar args = [].slice.call(arguments);\n\t\tvar params;\n\t\tvar callback;\n\t\tvar executed = false;\n\t\tvar self = owner || this;\n\n\t\targs.push(function() {\n\t\t\tparams = arguments;\n\t\t\tif (!executed && callback) {\n\t\t\t\texecuted = true;\n\t\t\t\tcallback.apply(self, params);\n\t\t\t}\n\t\t});\n\n\t\tfn.apply(self, args);\n\n\t\treturn function(cb) {\n\t\t\tcallback = cb;\n\t\t\tif (!executed && params) {\n\t\t\t\texecuted = true;\n\t\t\t\tcallback.apply(self, params);\n\t\t\t}\n\t\t};\n\t};\n};\n\nexports.sync2 = function(fn, owner) {\n\treturn (function() {\n\n\t\tvar params;\n\t\tvar callback;\n\t\tvar executed = false;\n\t\tvar self = owner || this;\n\t\tvar args = [].slice.call(arguments);\n\n\t\targs.push(function() {\n\t\t\tparams = arguments;\n\t\t\tif (!executed && callback) {\n\t\t\t\texecuted = true;\n\t\t\t\tcallback.apply(self, params);\n\t\t\t}\n\t\t});\n\n\t\tfn.apply(self, args);\n\n\t\treturn function(cb) {\n\t\t\tcallback = cb;\n\t\t\tif (!executed && params) {\n\t\t\t\texecuted = true;\n\t\t\t\tcallback.apply(self, params);\n\t\t\t}\n\t\t};\n\t})();\n};\n\nexports.async = function(fn, isApply) {\n\tvar context = this;\n\treturn function(complete) {\n\n\t\tvar self = this;\n\t\tvar argv;\n\n\t\tif (arguments.length) {\n\n\t\t\tif (isApply) {\n\t\t\t\t// index.js/Subscribe.prototype.doExecute\n\t\t\t\targv = arguments[1];\n\t\t\t} else {\n\t\t\t\targv = [];\n\t\t\t\tfor (var i = 1; i < arguments.length; i++)\n\t\t\t\t\targv.push(arguments[i]);\n\t\t\t}\n\t\t} else\n\t\t\targv = new Array(0);\n\n\t\tvar generator = fn.apply(context, argv);\n\t\tnext(null);\n\n\t\tfunction next(err, result) {\n\n\t\t\tvar g, type;\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\tvar can = err ? false : true;\n\t\t\t\tswitch (can) {\n\t\t\t\t\tcase true:\n\t\t\t\t\t\tg = generator.next(result);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase false:\n\t\t\t\t\t\tg = generator.throw(err);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t} catch (e) {\n\n\t\t\t\tif (!complete)\n\t\t\t\t\treturn;\n\n\t\t\t\ttype = typeof(complete);\n\n\t\t\t\tif (type === 'object' && complete.isController) {\n\t\t\t\t\tif (e instanceof ErrorBuilder)\n\t\t\t\t\t\tcomplete.content(e);\n\t\t\t\t\telse\n\t\t\t\t\t\tcomplete.view500(e);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\ttype === 'function' && setImmediate(() => complete(e));\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (g.done) {\n\t\t\t\ttypeof(complete) === 'function' && complete(null, g.value);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar promise = g.value instanceof Promise;\n\n\t\t\tif (typeof(g.value) !== 'function' && !promise) {\n\t\t\t\tnext.call(self, null, g.value);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\tif (promise) {\n\t\t\t\t\tg.value.then((value) => next.call(self, null, value));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tg.value.call(self, function() {\n\t\t\t\t\tnext.apply(self, arguments);\n\t\t\t\t});\n\n\t\t\t} catch (e) {\n\t\t\t\tsetImmediate(() => next.call(self, e));\n\t\t\t}\n\t\t}\n\n\t\treturn generator.value;\n\t};\n};\n\n// MIT\n// Written by Jozef Gula\n// Optimized by Peter Sirka\nconst CACHE_GML1 = [null, null, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];\nconst CACHE_GML2 = [null, null, null, null, null, null, null, null];\nexports.getMessageLength = function(data, isLE) {\n\n\tvar length = data[1] & 0x7f;\n\n\tif (length === 126) {\n\t\tif (data.length < 4)\n\t\t\treturn -1;\n\t\tCACHE_GML1[0] = data[3];\n\t\tCACHE_GML1[1] = data[2];\n\t\treturn converBytesToInt64(CACHE_GML1, 0, isLE);\n\t}\n\n\tif (length === 127) {\n\t\tif (data.Length < 10)\n\t\t\treturn -1;\n\t\tCACHE_GML2[0] = data[9];\n\t\tCACHE_GML2[1] = data[8];\n\t\tCACHE_GML2[2] = data[7];\n\t\tCACHE_GML2[3] = data[6];\n\t\tCACHE_GML2[4] = data[5];\n\t\tCACHE_GML2[5] = data[4];\n\t\tCACHE_GML2[6] = data[3];\n\t\tCACHE_GML2[7] = data[2];\n\t\treturn converBytesToInt64(CACHE_GML2, 0, isLE);\n\t}\n\n\treturn length;\n};\n\n// MIT\n// Written by Jozef Gula\nfunction converBytesToInt64(data, startIndex, isLE) {\n\treturn isLE ? (data[startIndex] | (data[startIndex + 1] << 0x08) | (data[startIndex + 2] << 0x10) | (data[startIndex + 3] << 0x18) | (data[startIndex + 4] << 0x20) | (data[startIndex + 5] << 0x28) | (data[startIndex + 6] << 0x30) | (data[startIndex + 7] << 0x38)) : ((data[startIndex + 7] << 0x20) | (data[startIndex + 6] << 0x28) | (data[startIndex + 5] << 0x30) | (data[startIndex + 4] << 0x38) | (data[startIndex + 3]) | (data[startIndex + 2] << 0x08) | (data[startIndex + 1] << 0x10) | (data[startIndex] << 0x18));\n}\n\nexports.queuecache = {};\n\nfunction queue_next(name) {\n\n\tvar item = exports.queuecache[name];\n\tif (!item)\n\t\treturn;\n\n\titem.running--;\n\n\tif (item.running < 0)\n\t\titem.running = 0;\n\n\tif (item.pending.length) {\n\t\tvar fn = item.pending.shift();\n\t\tif (fn) {\n\t\t\titem.running++;\n\t\t\tsetImmediate(queue_next_callback, fn, name);\n\t\t} else\n\t\t\titem.running = 0;\n\t}\n}\n\nfunction queue_next_callback(fn, name) {\n\tfn(() => queue_next(name));\n}\n\nexports.json2replacer = function(key, value) {\n\tif (value != null)\n\t\treturn value;\n};\n\n/**\n * Queue list\n * @param {String} name\n * @param {Number} max Maximum stack.\n * @param {Function(next)} fn\n */\nexports.queue = function(name, max, fn) {\n\n\tif (!fn)\n\t\treturn false;\n\n\tif (!max) {\n\t\tfn(NOOP);\n\t\treturn true;\n\t}\n\n\tif (!exports.queuecache[name])\n\t\texports.queuecache[name] = { limit: max, running: 0, pending: [] };\n\n\tvar item = exports.queuecache[name];\n\tif (item.running >= item.limit) {\n\t\titem.pending.push(fn);\n\t\treturn false;\n\t}\n\n\titem.running++;\n\tsetImmediate(queue_next_callback, fn, name);\n\treturn true;\n};\n\nexports.minify_css = function(val) {\n\treturn Internal.compile_css(val);\n};\n\nexports.minify_js = function(val) {\n\treturn Internal.compile_javascript(val);\n};\n\nexports.minify_html = function(val) {\n\treturn Internal.compile_html(val);\n};\n\nexports.parseTheme = function(value) {\n\tif (value[0] !== '=')\n\t\treturn '';\n\tvar index = value.indexOf('/', 2);\n\tif (index === -1)\n\t\treturn '';\n\tvalue = value.substring(1, index);\n\treturn value === '?' ? CONF.default_theme : value;\n};\n\nexports.set = function(obj, path, value) {\n\tvar cachekey = 'S+' + path;\n\n\tif (F.temporary.other[cachekey])\n\t\treturn F.temporary.other[cachekey](obj, value);\n\n\tvar arr = parsepath(path);\n\tvar builder = [];\n\n\tfor (var i = 0; i < arr.length - 1; i++) {\n\t\tvar type = arr[i + 1] ? (REGISARR.test(arr[i + 1]) ? '[]' : '{}') : '{}';\n\t\tvar p = 'w' + (arr[i][0] === '[' ? '' : '.') + arr[i];\n\t\tbuilder.push('if(typeof(' + p + ')!==\\'object\\'||' + p + '==null)' + p + '=' + type + ';');\n\t}\n\n\tvar v = arr[arr.length - 1];\n\tvar ispush = v.lastIndexOf('[]') !== -1;\n\tvar a = builder.join(';') + ';var v=typeof(a)===\\'function\\'?a(U.get(b)):a;w' + (v[0] === '[' ? '' : '.') + (ispush ? v.replace(REGREPLACEARR, '.push(v)') : (v + '=v')) + ';return v';\n\n\tif ((/__proto__|constructor|prototype|eval/).test(a))\n\t\tthrow new Error('Potential vulnerability');\n\n\tvar fn = new Function('w', 'a', 'b', a);\n\tF.temporary.other[cachekey] = fn;\n\tfn(obj, value, path);\n};\n\nexports.get = function(obj, path) {\n\n\tvar cachekey = 'G=' + path;\n\n\tif (F.temporary.other[cachekey])\n\t\treturn F.temporary.other[cachekey](obj);\n\n\tvar arr = parsepath(path);\n\tvar builder = [];\n\n\tfor (var i = 0, length = arr.length - 1; i < length; i++)\n\t\tbuilder.push('if(!w' + (!arr[i] || arr[i][0] === '[' ? '' : '.') + arr[i] + ')return');\n\n\tvar v = arr[arr.length - 1];\n\tvar fn = (new Function('w', builder.join(';') + ';return w' + (v[0] === '[' ? '' : '.') + v));\n\tF.temporary.other[cachekey] = fn;\n\treturn fn(obj);\n};\n\nfunction parsepath(path) {\n\n\tvar arr = path.split('.');\n\tvar builder = [];\n\tvar all = [];\n\n\tfor (var i = 0; i < arr.length; i++) {\n\t\tvar p = arr[i];\n\t\tvar index = p.indexOf('[');\n\t\tif (index === -1) {\n\t\t\tif (p.indexOf('-') === -1) {\n\t\t\t\tall.push(p);\n\t\t\t\tbuilder.push(all.join('.'));\n\t\t\t} else {\n\t\t\t\tvar a = all.splice(all.length - 1);\n\t\t\t\tall.push(a + '[\\'' + p + '\\']');\n\t\t\t\tbuilder.push(all.join('.'));\n\t\t\t}\n\t\t} else {\n\t\t\tif (p.indexOf('-') === -1) {\n\t\t\t\tall.push(p.substring(0, index));\n\t\t\t\tbuilder.push(all.join('.'));\n\t\t\t\tall.splice(all.length - 1);\n\t\t\t\tall.push(p);\n\t\t\t\tbuilder.push(all.join('.'));\n\t\t\t} else {\n\t\t\t\tall.push('[\\'' + p.substring(0, index) + '\\']');\n\t\t\t\tbuilder.push(all.join(''));\n\t\t\t\tall.push(p.substring(index));\n\t\t\t\tbuilder.push(all.join(''));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn builder;\n}\n\nglobal.sync = exports.sync;\nglobal.sync2 = exports.sync2;\n\n// =============================================\n// SHELL SORT IMPLEMENTATION OF ALGORITHM\n// =============================================\n\nfunction _shellInsertionSort(list, length, gapSize, fn) {\n\tvar temp, i, j;\n\tfor (i = gapSize; i < length; i += gapSize ) {\n\t\tj = i;\n\t\twhile(j > 0 && fn(list[j - gapSize], list[j]) === 1) {\n\t\t\ttemp = list[j];\n\t\t\tlist[j] = list[j - gapSize];\n\t\t\tlist[j - gapSize] = temp;\n\t\t\tj -= gapSize;\n\t\t}\n\t}\n}\n\nfunction shellsort(arr, fn) {\n\tvar length = arr.length;\n\tvar gapSize = Math.floor(length / 2);\n\twhile(gapSize) {\n\t\t_shellInsertionSort(arr, length, gapSize, fn);\n\t\tgapSize = Math.floor(gapSize / 2);\n\t}\n\treturn arr;\n}\n\nfunction EventEmitter2(obj) {\n\tif (obj) {\n\t\t!obj.emit && EventEmitter2.extend(obj);\n\t\treturn obj;\n\t} else\n\t\tthis.$events = {};\n}\n\nconst EE2P = EventEmitter2.prototype;\n\nEE2P.emit = function(name, a, b, c, d, e, f, g) {\n\n\tif (!this.$events)\n\t\treturn this;\n\n\tvar evt = this.$events[name];\n\tif (evt) {\n\t\tvar clean = false;\n\t\tfor (var i = 0, length = evt.length; i < length; i++) {\n\t\t\tif (evt[i].$once)\n\t\t\t\tclean = true;\n\t\t\tevt[i].call(this, a, b, c, d, e, f, g);\n\t\t}\n\t\tif (clean) {\n\t\t\tevt = evt.remove(n => n.$once);\n\t\t\tif (evt.length)\n\t\t\t\tthis.$events[name] = evt;\n\t\t\telse\n\t\t\t\tthis.$events[name] = undefined;\n\t\t}\n\t}\n\treturn this;\n};\n\nEE2P.on = function(name, fn) {\n\tif (!this.$events)\n\t\tthis.$events = {};\n\tif (this.$events[name])\n\t\tthis.$events[name].push(fn);\n\telse\n\t\tthis.$events[name] = [fn];\n\treturn this;\n};\n\nEE2P.once = function(name, fn) {\n\tfn.$once = true;\n\treturn this.on(name, fn);\n};\n\nEE2P.removeListener = function(name, fn) {\n\tif (this.$events) {\n\t\tvar evt = this.$events[name];\n\t\tif (evt) {\n\t\t\tevt = evt.remove(n => n === fn);\n\t\t\tif (evt.length)\n\t\t\t\tthis.$events[name] = evt;\n\t\t\telse\n\t\t\t\tthis.$events[name] = undefined;\n\t\t}\n\t}\n\treturn this;\n};\n\nEE2P.removeAllListeners = function(name) {\n\tif (this.$events) {\n\t\tif (name === true)\n\t\t\tthis.$events = EMPTYOBJECT;\n\t\telse if (name)\n\t\t\tthis.$events[name] = undefined;\n\t\telse\n\t\t\tthis.$events = {};\n\t}\n\treturn this;\n};\n\nEventEmitter2.extend = function(obj) {\n\tobj.emit = EE2P.emit;\n\tobj.on = EE2P.on;\n\tobj.once = EE2P.once;\n\tobj.removeListener = EE2P.removeListener;\n\tobj.removeAllListeners = EE2P.removeAllListeners;\n};\n\nexports.EventEmitter2 = EventEmitter2;\n\nfunction Chunker(name, max) {\n\tthis.name = name;\n\tthis.max = max || 50;\n\tthis.index = 0;\n\tthis.filename = '{0}-'.format(name);\n\tthis.stack = [];\n\tthis.flushing = 0;\n\tthis.pages = 0;\n\tthis.count = 0;\n\tthis.percentage = 0;\n\tthis.autoremove = true;\n\tthis.compress = true;\n\tthis.filename = PATH.temp(this.filename);\n}\n\nconst CHP = Chunker.prototype;\n\nCHP.append = CHP.write = function(obj) {\n\tvar self = this;\n\n\tself.stack.push(obj);\n\n\tvar tmp = self.stack.length;\n\n\tif (tmp >= self.max) {\n\n\t\tself.flushing++;\n\t\tself.pages++;\n\t\tself.count += tmp;\n\n\t\tvar index = (self.index++);\n\n\t\tif (self.compress) {\n\t\t\tZlib.deflate(Buffer.from(JSON.stringify(self.stack), ENCODING), function(err, buffer) {\n\t\t\t\tFs.writeFile(self.filename + index + '.chunker', buffer, () => self.flushing--);\n\t\t\t});\n\t\t} else\n\t\t\tFs.writeFile(self.filename + index + '.chunker', JSON.stringify(self.stack), () => self.flushing--);\n\n\t\tself.stack = [];\n\t}\n\n\treturn self;\n};\n\nCHP.end = function() {\n\tvar self = this;\n\tvar tmp = self.stack.length;\n\tif (tmp) {\n\t\tself.flushing++;\n\t\tself.pages++;\n\t\tself.count += tmp;\n\n\t\tvar index = (self.index++);\n\n\t\tif (self.compress) {\n\t\t\tZlib.deflate(Buffer.from(JSON.stringify(self.stack), ENCODING), function(err, buffer) {\n\t\t\t\tFs.writeFile(self.filename + index + '.chunker', buffer, () => self.flushing--);\n\t\t\t});\n\t\t} else\n\t\t\tFs.writeFile(self.filename + index + '.chunker', JSON.stringify(self.stack), () => self.flushing--);\n\n\t\tself.stack = [];\n\t}\n\n\treturn self;\n};\n\nCHP.each = function(onItem, onEnd, indexer) {\n\n\tvar self = this;\n\n\tif (indexer == null) {\n\t\tself.percentage = 0;\n\t\tindexer = 0;\n\t}\n\n\tif (indexer >= self.index)\n\t\treturn onEnd && onEnd();\n\n\tself.read(indexer++, function(err, items) {\n\t\tself.percentage = Math.ceil((indexer / self.pages) * 100);\n\t\tonItem(items, () => self.each(onItem, onEnd, indexer), indexer - 1);\n\t});\n\n\treturn self;\n};\n\nCHP.read = function(index, callback) {\n\tvar self = this;\n\n\tif (self.flushing) {\n\t\tself.flushing_timeout = setTimeout(() => self.read(index, callback), 300);\n\t\treturn;\n\t}\n\n\tvar filename = self.filename + index + '.chunker';\n\n\tFs.readFile(filename, function(err, data) {\n\n\t\tif (err) {\n\t\t\tcallback(null, EMPTYARRAY);\n\t\t\treturn;\n\t\t}\n\n\t\tif (self.compress) {\n\t\t\tZlib.inflate(data, function(err, data) {\n\t\t\t\tif (err) {\n\t\t\t\t\tcallback(null, EMPTYARRAY);\n\t\t\t\t} else {\n\t\t\t\t\tself.autoremove && Fs.unlink(filename, NOOP);\n\t\t\t\t\tcallback(null, data.toString('utf8').parseJSON(true));\n\t\t\t\t}\n\t\t\t});\n\t\t} else {\n\t\t\tself.autoremove && Fs.unlink(filename, NOOP);\n\t\t\tcallback(null, data.toString('utf8').parseJSON(true));\n\t\t}\n\t});\n\n\treturn self;\n};\n\nCHP.clear = function() {\n\tvar files = [];\n\tfor (var i = 0; i < this.index; i++)\n\t\tfiles.push(this.filename + i + '.chunker');\n\tfiles.wait((filename, next) => Fs.unlink(filename, next));\n\treturn this;\n};\n\nCHP.destroy = function() {\n\tthis.clear();\n\tthis.indexer = 0;\n\tthis.flushing = 0;\n\tclearTimeout(this.flushing_timeout);\n\tthis.stack = null;\n\treturn this;\n};\n\nexports.chunker = function(name, max) {\n\treturn new Chunker(name, max);\n};\n\nexports.Chunker = Chunker;\n\nexports.ObjectToArray = function(obj) {\n\tif (obj == null)\n\t\treturn EMPTYARRAY;\n\tvar output = [];\n\tfor (var key in obj)\n\t\toutput.push({ key: key, value: obj[key]});\n\treturn output;\n};\n\nexports.createBufferSize = (size) => Buffer.alloc(size || 0);\nexports.createBuffer = (val, type) => Buffer.from(val || '', type);\n\nfunction Callback(count, callback) {\n\tthis.pending = count;\n\tthis.$callback = callback;\n}\nconst CP = Callback.prototype;\n\nCP.done = function(callback) {\n\tthis.$callback = callback;\n\treturn this;\n};\n\nCP.next = function() {\n\tvar self = this;\n\tself.pending--;\n\tif (!self.pending && self.$callback) {\n\t\tself.$callback();\n\t\tself.$callback = null;\n\t}\n\treturn self;\n};\n\nglobal.Callback = Callback;\n\nexports.Callback = function(count, callback) {\n\treturn new Callback(count, callback);\n};\n\nfunction Reader() {\n\tvar t = this;\n\t// t.tmp;\n\tt.$add = function(builder) {\n\t\tvar b = require('./textdb-builder').make();\n\t\tbuilder.options.filter = builder.options.filter && builder.options.filter.length ? builder.options.filter.join('&&') : 'true';\n\t\tb.assign(builder.options);\n\n\t\tif (builder.$)\n\t\t\tb.$resolve = builder.$resolve;\n\t\telse\n\t\t\tb.$callback = builder.$callback;\n\n\t\tif (t.reader)\n\t\t\tt.reader.add(b);\n\t\telse {\n\t\t\tt.reader = require('./textdb-reader').make();\n\t\t\tt.reader.add(b);\n\t\t\tt.reader.prepare();\n\t\t}\n\t};\n\n\tt.push = function(data) {\n\t\tif (t.reader) {\n\t\t\tif (data)\n\t\t\t\tt.reader.compare(data instanceof Array ? data : [data]);\n\t\t\telse\n\t\t\t\tt.reader.done();\n\t\t} else\n\t\t\tsetImmediate(t.push, data);\n\t};\n\n}\n\nconst RP = Reader.prototype;\n\nRP.done = function() {\n\tvar self = this;\n\tself.reader.done();\n\treturn self;\n};\n\nRP.reset = function() {\n\tvar self = this;\n\tself.reader.reset();\n\treturn self;\n};\n\nRP.find = function() {\n\tvar self = this;\n\tvar builder = require('./textdb-wrapper').makebuilder();\n\tbuilder.command = 'find';\n\tsetImmediate(self.$add, builder);\n\treturn builder;\n};\n\nfunction listing(builder, items, response) {\n\tvar skip = builder.options.skip || 0;\n\tvar take = builder.options.take || 0;\n\treturn { page: skip && take ? ((skip / take) + 1) : 1, pages: response.count && take ? Math.ceil(response.count / take) : response.count ? 1 : 0, limit: take, count: response.count, items: items || [] };\n}\n\nRP.list = function() {\n\tvar self = this;\n\tvar builder = require('./textdb-wrapper').makebuilder();\n\tbuilder.command = 'find';\n\tbuilder.parent = {};\n\tbuilder.$callback = function(err, response, meta) {\n\t\tif (builder.parent.$) {\n\t\t\tif (err)\n\t\t\t\tbuilder.parent.$.invalid(err);\n\t\t\telse\n\t\t\t\tbuilder.parent.$resolve(response);\n\t\t} else if (builder.parent.$callback)\n\t\t\tbuilder.parent.$callback(err, listing(builder, response, meta), meta);\n\t};\n\tsetImmediate(self.$add, builder);\n\treturn builder;\n};\n\nRP.read = function() {\n\tvar self = this;\n\tvar builder = require('./textdb-wrapper').makebuilder();\n\tbuilder.command = 'find';\n\tbuilder.options.take = 1;\n\tbuilder.options.first = 1;\n\tsetImmediate(self.$add, builder);\n\treturn builder;\n};\n\nRP.count = function() {\n\tvar builder = this.find();\n\tbuilder.options.scalar = 'arg.count++';\n\tbuilder.options.scalararg = { count: 0 };\n\treturn builder;\n};\n\nRP.scalar = function(type, key, key2) {\n\tvar builder = this.find();\n\n\tif (key == null) {\n\t\tkey = type;\n\t\ttype = '*';\n\t}\n\n\tswitch (type) {\n\t\tcase 'group':\n\t\t\tbuilder.options.scalar = key2 ? 'if (doc.{0}!=null){tmp.val=doc.{0};arg[tmp.val]=(arg[tmp.val]||0)+(doc.{1}||0)}'.format(key, key2) : 'if (doc.{0}!=null){tmp.val=doc.{0};arg[tmp.val]=(arg[tmp.val]||0)+1}'.format(key);\n\t\t\tbuilder.options.scalararg = {};\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t// min, max, sum, count\n\t\t\tif (key2) {\n\t\t\t\tbuilder.options.scalar = 'var k=doc.' + key + '+\\'\\';if (arg[k]){tmp.bk=doc.' + key2 + '||0;' + (type === 'max' ? 'if(tmp.bk>arg[k])arg[k]=tmp.bk' : type === 'min' ? 'if(tmp.bk<arg[k])arg[k]=tmp.bk' : 'arg[k]+=tmp.bk') + '}else{arg[k]=doc.' + key2 + '||0}';\n\t\t\t} else {\n\t\t\t\tbuilder.options.scalar = 'if (doc.{0}!=null){tmp.val=doc.{0};arg.count+=1;arg.min=arg.min==null?tmp.val:arg.min>tmp.val?tmp.val:arg.min;arg.max=arg.max==null?tmp.val:arg.max<tmp.val?tmp.val:arg.max;if(!(tmp.val instanceof Date))arg.sum+=tmp.val}'.format(key);\n\t\t\t\tbuilder.options.scalararg = { count: 0, sum: 0 };\n\t\t\t}\n\t\t\tbreak;\n\t}\n\treturn builder;\n};\n\nRP.stats = function(groupfield, datefield, key, type) {\n\tvar builder = this.find();\n\tbuilder.options.scalar = 'if (doc.{0}!=null&&doc.{2}!=null&&doc.{1} instanceof Date){tmp.val=doc.{2};tmp.group=doc.{0};tmp.date=doc.{1}.format(\\'{3}\\');if(!arg[tmp.group])arg[tmp.group]={};if(!arg[tmp.group][tmp.date])arg[tmp.group][tmp.date]={min:null,max:null,count:0};tmp.cur=arg[tmp.group][tmp.date];tmp.cur.count++;if(tmp.cur.max==null){tmp.cur.max=tmp.val}else if(tmp.cur.max<tmp.val){tmp.cur.max=tmp.val}if(tmp.cur.min==null){tmp.cur.min=tmp.val}else if(tmp.cur.min>tmp.val){tmp.cur.min=tmp.val}}'.format(groupfield, datefield, key, type === 'hourly' ? 'yyyyMMddHH' : type === 'monthly' ? 'yyyyMM' : type === 'yearly' ? 'yyyy' : 'yyyyMMdd');\n\tbuilder.options.scalararg = {};\n\treturn builder;\n};\n\nexports.reader = function(items) {\n\tvar instance = new Reader();\n\tif (items) {\n\t\tinstance.push(items);\n\t\tinstance.push(null);\n\t}\n\treturn instance;\n};\n\nglobal.WAIT = function(fnValid, fnCallback, timeout, interval) {\n\n\tif (fnValid() === true)\n\t\treturn fnCallback(null, true);\n\n\tvar id_timeout = null;\n\tvar id_interval = setInterval(function() {\n\n\t\tif (fnValid() === true) {\n\t\t\tclearInterval(id_interval);\n\t\t\tclearTimeout(id_timeout);\n\t\t\tfnCallback && fnCallback(null, true);\n\t\t}\n\n\t}, interval || 500);\n\n\tid_timeout = setTimeout(function() {\n\t\tclearInterval(id_interval);\n\t\tfnCallback && fnCallback(new Error('Timeout.'), false);\n\t}, timeout || 5000);\n};\n\n// Author: Peter \u0160irka\n// License: MIT\nfunction MultipartParser(multipart, stream, callback) {\n\n\tif (UPLOADINDEXER > 9999999999)\n\t\tUPLOADINDEXER = 1;\n\n\tvar self = this;\n\n\tself.buffer = null;\n\tself.header = Buffer.from(multipart, 'ascii');\n\tself.length = self.header.length;\n\tself.tmp = PATH.temp((F.clusterid || '') + 'upload_');\n\n\t// 0: nothing\n\t// 1: head\n\t// 2: data\n\t// 3: file\n\tself.step = 0;\n\n\t// Meta data\n\tself.sizes = { total: 0, files: 0, data: 0, parts: 0 };\n\tself.limits = { total: 0, files: 0, data: 0, parts: 0 };\n\tself.current = {};\n\tself.body = {};\n\tself.files = [];\n\tself.size = 0;\n\n\tself.ondata = function(chunk) {\n\t\tself.size += chunk.length;\n\t\tif (self.buffer) {\n\t\t\tCONCAT[0] = self.buffer;\n\t\t\tCONCAT[1] = chunk;\n\t\t\tself.buffer = Buffer.concat(CONCAT);\n\t\t\tself.parse(1);\n\t\t} else {\n\t\t\tself.buffer = chunk;\n\t\t\tself.parse(0);\n\t\t}\n\t};\n\n\tself.onend = function() {\n\t\tself.isend = true;\n\t\tself.checkready();\n\t};\n\n\tself.onclose = () => self.free('3: Request closed');\n\tself.callback = callback;\n\tself.stream = stream;\n\tself.stream.on('data', self.ondata);\n\tself.stream.on('end', self.onend);\n\t// self.stream.on('close', self.onclose);\n\tself.stream.on('abort', self.onclose);\n}\n\nMultipartParser.prototype.free = function(err) {\n\tvar self = this;\n\n\tif (!self.stream)\n\t\treturn;\n\n\tself.stream.removeListener('data', self.ondata);\n\tself.stream.removeListener('end', self.onend);\n\t// self.stream.removeListener('close', self.onclose);\n\tself.stream.removeListener('abort', self.onclose);\n\tself.current.stream && self.current.stream.end();\n\tself.stream = null;\n\tself.buffer = null;\n\tself.callback && self.callback(err, self);\n};\n\nMultipartParser.prototype.parse = function(type) {\n\tvar self = this;\n\tswitch (self.step) {\n\t\tcase 0: // no data, tries to parse meta\n\t\t\tself.parse_meta(type);\n\t\t\tbreak;\n\t\tcase 1: // part found\n\t\t\tself.parse_head();\n\t\t\tbreak;\n\t\tcase 2: // part data\n\t\t\tself.parse_data();\n\t\t\tbreak;\n\t\tcase 3: // part file\n\t\t\tself.parse_file();\n\t\t\tbreak;\n\t}\n};\n\nMultipartParser.prototype.parse_meta = function(type) {\n\n\tvar self = this;\n\n\tvar fromindex = type === 1 ? (self.buffer.length - self.header.length) : 0;\n\tif (fromindex < 0)\n\t\tfromindex = 0;\n\n\tvar index = type === 2 ? 0 : self.buffer.indexOf(self.header, fromindex);\n\n\tif (index === -1)\n\t\treturn;\n\n\t// Is end?\n\tif (self.buffer[index + self.length - 1] === 45) {\n\t\tself.current.stream && self.current.stream.end();\n\t\tself.current.stream = null;\n\t\treturn;\n\t}\n\n\tself.sizes.parts++;\n\n\tif (self.limits.parts && self.sizes.parts > self.limits.parts) {\n\t\tself.kill('1: Count of parts is too large');\n\t\treturn;\n\t}\n\n\tself.buffer = self.buffer.slice(self.length + 2);\n\tself.step = 1;\n\tself.parse();\n\n};\n\nMultipartParser.prototype.kill = function(err) {\n\tthis.free(err);\n};\n\nvar multipartfileready = function() {\n\tthis.$mpfile.ready = true;\n\tthis.$mpfile = null;\n\tthis.$mpinstance.checkready();\n\tthis.$mpinstance = null;\n};\n\nMultipartParser.prototype.checkready = function() {\n\n\tvar self = this;\n\n\tif (!self.stream || !self.isend)\n\t\treturn;\n\n\tfor (var i = 0; i < self.files.length; i++) {\n\t\tif (!self.files[i].ready)\n\t\t\treturn;\n\t}\n\n\tself.free();\n};\n\nMultipartParser.prototype.parse_head = function() {\n\n\tvar self = this;\n\tvar index = self.buffer.indexOf(HEADEREND);\n\n\tif (index === -1)\n\t\treturn;\n\n\tvar header = self.buffer.slice(0, index).toString('utf8').trim();\n\tif (header.substring(0, HEADERCHECK.length).toLowerCase() !== HEADERCHECK) {\n\t\tself.kill('7:');\n\t\treturn;\n\t}\n\n\theader = header.substring(HEADERCHECK.length).trim();\n\n\tvar beg = header.indexOf('filename=\"');\n\tvar isfile = beg !== -1;\n\n\tself.current.filename = isfile ? header.substring(beg + 10, header.indexOf('\"', beg + 10)).trim() : null;\n\n\tif (isfile && !self.current.filename)\n\t\treturn;\n\n\tbeg = header.indexOf('name=\"');\n\tif (beg === -1) {\n\t\tself.kill('2: Invalid part header');\n\t\treturn;\n\t}\n\n\tself.current.name = header.substring(beg + 6, header.indexOf('\"', beg + 6));\n\tself.current.size = 0;\n\n\tif (isfile) {\n\n\t\tif (REG_EMPTYBUFFER_TEST.test(self.current.filename))\n\t\t\tself.current.filename = self.current.filename.replace(REG_EMPTYBUFFER, '');\n\n\t\tvar type = header.match(/content-type:\\s.*?((\\r\\n)|$)/i);\n\t\tif (type) {\n\t\t\tself.current.type = type[0].substring(14);\n\t\t\tself.current.width = 0;\n\t\t\tself.current.height = 0;\n\t\t\tswitch (self.current.type) {\n\t\t\t\tcase 'image/svg+xml':\n\t\t\t\tcase 'image/svg':\n\t\t\t\t\tself.current.measure = 'measureSVG';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'image/jpeg':\n\t\t\t\tcase 'image/jpg':\n\t\t\t\t\tself.current.measure = 'measureJPG';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'image/png':\n\t\t\t\t\tself.current.measure = 'measurePNG';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'image/gif':\n\t\t\t\t\tself.current.measure = 'measureGIF';\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tself.current.measure = null;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (self.current.stream) {\n\t\t\tself.current.stream.end();\n\t\t\tself.current.stream = null;\n\t\t}\n\n\t\tif (!type) {\n\t\t\tself.kill('2: Invalid part header');\n\t\t\treturn;\n\t\t}\n\n\t\tself.current.path = self.tmp + (UPLOADINDEXER++) + '.bin';\n\t\tself.current.stream = Fs.createWriteStream(self.current.path);\n\t\tvar file = { path: self.current.path, name: self.current.name, filename: self.current.filename, size: 0, type: self.current.type, width: 0, height: 0 };\n\t\tself.current.file = file;\n\t\tself.current.stream.$mpfile = file;\n\t\tself.current.stream.$mpinstance = self;\n\t\tself.current.stream.on('close', multipartfileready);\n\t} else\n\t\tself.current.file = null;\n\n\tself.buffer = self.buffer.slice(index + HEADEREND.length);\n\tself.step = isfile ? 3 : 2;\n\tself.current.size = 0;\n\tself.parse();\n};\n\nMultipartParser.prototype.parse_file = function() {\n\n\tvar self = this;\n\tvar index = self.buffer.indexOf(self.header);\n\tvar tmp;\n\n\tif (self.current.measure) {\n\t\ttmp = framework_image[self.current.measure](self.buffer);\n\t\tif (tmp) {\n\t\t\tself.current.file.width = tmp.width;\n\t\t\tself.current.file.height = tmp.height;\n\t\t}\n\t\tself.current.measure = null;\n\t}\n\n\tif (index !== -1) {\n\n\t\tself.current.size += index - 4;\n\t\tself.current.file.size += index - 4;\n\t\tself.sizes.total += index - 4;\n\t\tself.sizes.files += index - 4;\n\n\t\tif (self.limits.files && self.sizes.files > self.limits.files) {\n\t\t\tself.kill('4: File body is too large');\n\t\t\treturn;\n\t\t}\n\n\t\tif (self.limits.total && self.sizes.total > self.limits.total) {\n\t\t\tself.kill('6: Stream is too large');\n\t\t\treturn;\n\t\t}\n\n\t\tvar data = self.buffer.slice(0, index - 4);\n\t\tself.current.stream.end(data);\n\t\tself.current.stream = null;\n\t\tself.files.push(self.current.file);\n\t\tself.buffer = self.buffer.slice(index);\n\t\tself.current.file = null;\n\t\tself.step = 0;\n\t\tself.parse(2);\n\n\t} else {\n\n\t\tvar length = self.buffer.length;\n\n\t\tself.current.size += length;\n\t\tself.current.file.size += length;\n\t\tself.sizes.total += length;\n\t\tself.sizes.files += length;\n\n\t\tif (self.limits.files && self.sizes.files > self.limits.files) {\n\t\t\tself.kill('4: File body is too large');\n\t\t\treturn;\n\t\t}\n\n\t\tif (self.limits.total && self.sizes.total > self.limits.total) {\n\t\t\tself.kill('6: Stream is too large');\n\t\t\treturn;\n\t\t}\n\n\t\tself.current.stream.write(self.buffer);\n\t\tself.buffer = null;\n\t}\n};\n\nMultipartParser.prototype.parse_data = function() {\n\tvar self = this;\n\tvar index = self.buffer.indexOf(self.header);\n\n\tif (index !== -1) {\n\n\t\tself.sizes.total += index - 2;\n\t\tself.sizes.data += index - 2;\n\n\t\tif (self.limits.data && self.sizes.data > self.limits.data) {\n\t\t\tself.kill('5: Data are too large');\n\t\t\treturn;\n\t\t}\n\n\t\tif (self.limits.total && self.sizes.total > self.limits.total) {\n\t\t\tself.kill('6: Stream is too large');\n\t\t\treturn;\n\t\t}\n\n\t\tvar val = self.buffer.slice(0, index - 4).toString('utf8');\n\n\t\tif (REG_EMPTYBUFFER_TEST.test(val))\n\t\t\tval = val.replace(REG_EMPTYBUFFER, '');\n\n\t\tself.body[self.current.name] = val;\n\t\tself.buffer = self.buffer.slice(index);\n\t\tself.step = 0;\n\t\tself.parse(true);\n\n\t} else {\n\n\t\tself.current.size += self.buffer.length;\n\n\t\tif (self.limits.data && self.current.size > self.limits.data) {\n\t\t\tself.kill('5: Data are too large');\n\t\t\treturn;\n\t\t}\n\n\t\tif (self.limits.total && (self.sizes.total + self.current.size) > self.limits.total) {\n\t\t\tself.kill('6: Stream is too large');\n\t\t\treturn;\n\t\t}\n\n\t}\n};\n\nvar measuring = {};\n\nfunction showtime(name) {\n\n\tvar arr = measuring[name];\n\tvar min = null;\n\tvar max = null;\n\tvar sum = 0;\n\n\tfor (var i = 0; i < arr.length; i++) {\n\n\t\tvar val = arr[i];\n\n\t\tif (min == null || min > val)\n\t\t\tmin = val;\n\n\t\tif (max == null || max < val)\n\t\t\tmax = val;\n\n\t\tsum += val;\n\t}\n\n\tconsole.log(name, 'avg:', (sum / arr.length).floor(2), 'max:', max, 'min:', min);\n}\n\nexports.measure = function(name, timeout) {\n\tvar key = '_' + name;\n\tif (measuring[key]) {\n\t\tvar diff = Date.now() - measuring[key];\n\t\tif (!measuring[name])\n\t\t\tmeasuring[name] = [];\n\t\tmeasuring[name].push(diff);\n\t\tmeasuring[key] = 0;\n\t} else\n\t\tmeasuring[key] = Date.now();\n\tsetTimeout(showtime, timeout || 1000, name);\n};\n\nexports.multipartparser = function(multipart, stream, callback) {\n\treturn new MultipartParser(multipart, stream, callback);\n};\n\nvar QUERIFYMETHODS = { GET: 1, POST: 1, DELETE: 1, PUT: 1, PATCH: 1, API: 1 };\n\nglobal.QUERIFY = function(url, obj) {\n\n\tif (typeof(url) !== 'string') {\n\t\tobj = url;\n\t\turl = '';\n\t}\n\n\tif (!obj)\n\t\treturn url;\n\n\tvar arg = [];\n\tvar keys = Object.keys(obj);\n\n\tfor (var i = 0; i < keys.length; i++) {\n\n\t\tvar key = keys[i];\n\t\tvar val = obj[key];\n\t\tif (val != null) {\n\n\t\t\tif (val instanceof Date)\n\t\t\t\tval = val.toISOString();\n\t\t\telse if (val instanceof Array)\n\t\t\t\tval = val.join(',');\n\n\t\t\tval = val + '';\n\t\t\tval && arg.push(encodeURIComponent(key) + '=' + encodeURIComponent(val));\n\t\t}\n\t}\n\n\tif (url) {\n\t\tvar arr = url.split(' ');\n\t\tvar index = QUERIFYMETHODS[arr[0]] ? 1 : 0;\n\t\tarr[index] += (arr[index].indexOf('?') === -1 ? '?' : '&') + arg.join('&');\n\t\treturn arr.join(' ');\n\t}\n\n\treturn '?' + arg.join('&');\n};\n\nexports.connect = function(opt, callback) {\n\n\t// opt.secure {Boolean}\n\t// opt.host\n\t// opt.port\n\t// opt.timeout\n\n\tvar opt = CLONE(opt);\n\tvar tls = opt.tls;\n\tvar meta = {};\n\tvar timeout;\n\n\tmeta.opt = opt;\n\tmeta.tls = tls;\n\n\tdelete opt.tls;\n\n\tvar close = function() {\n\n\t\tif (meta.socket1) {\n\t\t\tmeta.socket1.removeAllListeners();\n\t\t\tmeta.socket1.end();\n\t\t\tmeta.socket1.destroy();\n\t\t\tmeta.socket1 = null;\n\t\t}\n\n\t\tif (meta.socket2) {\n\t\t\tmeta.socket2.removeAllListeners();\n\t\t\tmeta.socket2.end();\n\t\t\tmeta.socket2.destroy();\n\t\t\tmeta.socket2 = null;\n\t\t}\n\n\t};\n\n\tvar error = function(err) {\n\t\tcallback && callback(err);\n\t\tcallback = null;\n\t\tclose();\n\t};\n\n\tif (opt.timeout)\n\t\ttimeout = setTimeout(() => error(new Error('Timeout')), opt.timeout);\n\n\tmeta.destroy = meta.close = close;\n\tmeta.write = function(data) {\n\t\tmeta.socket.write(data);\n\t};\n\n\tmeta.ondata = function(fn) {\n\t\tmeta.socket.on('data', fn);\n\t};\n\n\tmeta.onend = function(fn) {\n\t\tmeta.socket.on('destroy', fn);\n\t};\n\n\tvar done = function() {\n\n\t\tif (!callback)\n\t\t\treturn;\n\n\t\tif (opt.tls) {\n\t\t\tif (!meta.socket2) {\n\t\t\t\ttls.socket = meta.socket1;\n\t\t\t\tmeta.socket2 = Tls.connect(tls, done);\n\t\t\t\tmeta.socket2.on('error', error);\n\t\t\t\tmeta.socket2.on('clientError', error);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tmeta.socket = meta.socket2 || meta.socket1;\n\t\ttimeout && clearTimeout(timeout);\n\t\ttimeout = null;\n\t\tcallback && callback(null, meta);\n\t\tcallback = null;\n\t};\n\n\tif (opt.secure)\n\t\tmeta.socket1 = Tls.connect(opt, done);\n\telse\n\t\tmeta.socket1 = Net.createConnection(opt.port, opt.host, done);\n\n\tmeta.socket1.on('error', error);\n\tmeta.socket1.on('clientError', error);\n};\n\nString.prototype.toJSONSchema = function(name, url) {\n\n\tvar obj = {};\n\tvar p = (url || CONF.url || 'https://schemas.totaljs.com/');\n\n\tif (p[p.length - 1] !== '/')\n\t\tp += '/';\n\n\tobj.$id = p + (name || (HASH(this) + '')) + '.json';\n\tobj.$schema = 'https://json-schema.org/draft/2020-12/schema';\n\tobj.type = 'object';\n\tobj.properties = {};\n\n\tvar prop = this.split(',');\n\tvar required = [];\n\n\tfor (var i = 0; i < prop.length; i++) {\n\n\t\tvar arr = prop[i].split(':');\n\t\tvar tmp;\n\n\t\tif (arr[0][0] === '!' || arr[0][0] === '*') {\n\t\t\t// required\n\t\t\tarr[0] = arr[0].substring(1);\n\t\t\trequired.push(arr[0]);\n\t\t}\n\n\t\tvar type = arr[1].toLowerCase().trim();\n\t\tvar size = 0;\n\t\tvar isarr = type[0] === '[';\n\t\tif (isarr)\n\t\t\ttype = type.substring(1, type.length - 1);\n\n\t\tvar index = type.indexOf('(');\n\t\tif (index !== -1) {\n\t\t\tsize = +type.substring(index + 1, type.length - 1).trim();\n\t\t\ttype = type.substring(0, index);\n\t\t}\n\n\t\tswitch (type) {\n\t\t\tcase 'string':\n\t\t\tcase 'uid':\n\t\t\t\ttmp = {};\n\t\t\t\tif (isarr) {\n\t\t\t\t\ttmp.type = 'array';\n\t\t\t\t\ttmp.items = { type: 'string' };\n\t\t\t\t\tif (size)\n\t\t\t\t\t\ttmp.items.maxLength = size;\n\t\t\t\t} else {\n\t\t\t\t\ttmp.type = 'string';\n\t\t\t\t\tif (size)\n\t\t\t\t\t\ttmp.maxLength = size;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'number':\n\t\t\tcase 'number2':\n\t\t\tcase 'float':\n\t\t\tcase 'decimal':\n\t\t\t\ttmp = {};\n\t\t\t\tif (isarr) {\n\t\t\t\t\ttmp.type = 'array';\n\t\t\t\t\ttmp.items = { type: 'number' };\n\t\t\t\t} else {\n\t\t\t\t\ttmp.type = 'number';\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'bool':\n\t\t\tcase 'boolean':\n\t\t\t\ttmp = {};\n\t\t\t\tif (isarr) {\n\t\t\t\t\ttmp.type = 'array';\n\t\t\t\t\ttmp.items = { type: 'boolean' };\n\t\t\t\t} else\n\t\t\t\t\ttmp.type = 'boolean';\n\t\t\t\tbreak;\n\t\t\tcase 'date':\n\t\t\t\ttmp = {};\n\t\t\t\tif (isarr) {\n\t\t\t\t\ttmp.type = 'array';\n\t\t\t\t\ttmp.items = { type: 'date' };\n\t\t\t\t} else\n\t\t\t\t\ttmp.type = 'date';\n\t\t\t\tbreak;\n\t\t}\n\t\tif (tmp)\n\t\t\tobj.properties[arr[0].trim()] = tmp;\n\t}\n\n\tif (required.length)\n\t\tobj.required = required;\n\n\treturn obj;\n};\n\n!global.F && require('./index');"], "fixing_code": ["========================\n0.0.43\n========================\n\n- improved `flowinstance.newmessage(data)` method\n- removed method `U.set()`\n- removed method `U.get()`\n- removed method `U.sync()` and `global.sync()`\n- removed method `U.sync2()` and `global.sync2()`\n\n========================\n0.0.42\n========================\n\n- added support for JSON schemas\n- added Total Messaging Service\n- added `jsonschemas` directory\n- added `schema.jsonschema(name)` method\n- added `JSONSCHEMA()` method\n- added `NEWJSONSCHEMA()` method\n- added `NEWPUBLISH()` method\n- added `NEWSUBSCRIBE()` method\n- added `PUBLISH()` method\n- added `SUBSCRIBE()` method\n- added `UNSUBSCRIBE()` method\n- added `watcher` event for the main process in `debug` or `release` mode with the watcher\n- added HTML escaping for meta tags\n- added `WebSocketClient.destroy()` method\n- added new command `refresh_cmd`\n- added `allow_totalapilogger {Boolean}` option to the configuration\n- added `allow_totalapi {Boolean}` option to the configuration\n- added `allow_tms {Boolean}` option to the configuration\n- added `secret_tms {String}` option to the configuration\n- added `schema.jsonschema_define()` method\n- added `flowstream.load(components, design, [callback])` method\n- added `flowstream.unload(components, design, [callback])` method\n- added new delegate `flowstream.onreconfigure = function(instance) {}`\n- added new delegate `flowstream.onconnect = function(instance) {}`\n- added new delegate `flowstream.ondisconnect = function(instance) {}`\n- added new delegate `flowstream.onregister = function(component) {}`\n- added new delegate `flowstream.onunregister = function(component) {}`\n- added `uistream.load(components, design, [callback])` method\n- added `uistream.unload(components, design, [callback])` method\n- added new delegate `uistream.onreconfigure = function(instance) {}`\n- added new delegate `uistream.onconnect = function(instance) {}`\n- added new delegate `uistream.ondisconnect = function(instance) {}`\n- added new delegate `uistream.onregister = function(component) {}`\n- added new delegate `uistream.onunregister = function(component) {}`\n- fixed `Mail.attachmentfs()`\n- fixed dynamic routing\n- fixed security issue when parsing query arguments (reported by <https://github.com/fl4x>)\n- extended `schema.addTask()` by adding a new argument `callback`\n- added new method `flowstream.newmessage(data)`\n- added new method `flowstream_instance.newmessage(data)`\n- added `String.toJSONSchema(name, url)`\n- added `bundles.debug` enables watcher for `.src` directory only\n\n========================\n0.0.41\n========================\n\n- added TypeScript support\n- added support for static files in threads\n- fixed logging in threads by Tomas Novak\n- added `insecure` option to the `REQUEST()` method\n- added `builder.insecure()` method to the `RESTBuilder` instance\n- added `profile` type to the LDAP options\n- extended `base64` by adding support for `content-type;base64,data` format\n- updated `schema.define(key, type, required, [default_error_message])`\n- fixed `String.encrypt_uid()`\n- fixed `$.keys` in schemas with multiple operations\n- fixed wildcard routing combinated with dynamic arguments\n\n========================\n0.0.40\n========================\n\n- added `U.reader().list()` method\n- added `Array.findValue()`\n- added async/await mechanism to TextDB\n- added async/await mechanism to RESTBuilder\n- threads supports views\n- improved error handling in `TotalAPI()`\n- improved `Database.scalar()` by adding new argument\n- improved `QueryBuilder.in()` and `QueryBuilder.notin()`\n- fixed UTF8 chars in multi-part parser\n- fixed `NOSQL().autofill()`\n- fixed converting date via `Date.setTimeZone()`\n- fixed XML comments in `String.parseXML()`\n- fixed `Name` type in `Schemas`\n- fixed sorting in `U.reader()`\n\n========================\n0.0.39\n========================\n\n- added a new alias `request.proxy()` to `response.proxy()`\n- added `LDAP(opt, callback)` method for obtaining of users, groups or user profile (experimental)\n- added `U.normalize(path)` that normalizes path by adding `/` to begin and end of the phrase\n- added `U.link(path1, path2, pathN)` for creating of links\n- added `PATH.join()` alias to `Path.join()`\n- added `DEF.blacklist` object that performs IP blacklist\n- updated `filestorage.save()` by adding support for importing files from URL address\n- updated built-in session `AUTH()` mechanism by adding `options.strict {Boolean}` option\n- updated `$.extend([data], [callback])` method in SchemaOptions by adding `callback` argument that enables async processing\n- removed `allow_debug` option\n- fixed `abort` event for incoming `request`\n- fixed `controller.json()` method\n- fixed `array.quicksort()` method\n- fixed `controller.invalid()`, added missing second argument called `error` (optional)\n- fixed error handling in `TotalAPI`\n- fixed cookies transfering while redirecting in the `REQUEST()` method (can be disable via `opt.nocookies = true`)\n- fixed `language` in `WebSocketClient`\n- fixed merging files with the `auto` value defined in `versions`\n- fixed encoding in `content-disposition` header\n- fixed `UNAUTHORIZED()`\n- fixed `after` argument in the `PROXY()` and `res.proxy()` methods\n- improved error handling in WebSocket\n- improved HTTP caching in merged files\n- improved unit-testing\n- improved timeouts in the API endpoints\n\n========================\n0.0.38\n========================\n\n- added `PAUSE(is_paused)` method that can pause loading of all Total.js dependencies\n- added dynamic delegates for receiving of messages in FlowStream in the form `instance.mesage_<INPUT_NAME>`\n- added `response.proxy(target, [copypath], [after], [timeout])`\n- improved some parts of code\n- improved `MIDDLEWARE(name, fn, [assign], [first])` method\n- fixed measuring dimension for `.gif` images\n- fixed `BACKUP()` method (a problem with sockets)\n- fixed potential remote code execution in `U.set()` founded by [Snyk](https://snyk.io/vuln)\n- fixed routing with camel-Case URL addresses\n- fixed sending of messages via inline registered components in FlowStream\n- fixed a problem with FileStorage and opened file descriptors\n\n========================\n0.0.37\n========================\n\n- added CSRF\n\t- `CONF.secret_csrf`\n\t- `CONF.default_csrf_maxage`\n\t- `DEF.onCSRFcreate(req)`\n\t- `DEF.onCSRFcheck(req)`\n\t- `req.csrf()` generates a token\n\t- `controller.csrf()` generates a token\n\t- `@{csrf}` generates a token in View engine\n\t- `schema.csrf()` enables csrf for schemas and their routes\n\t- new `csrf` flag in `ROUTE()` method\n\t- `csrf` verification via `x-csrf-token` header or via URL argument `?csrf=TOKEN`\n\t- `RESTBuilder.csrf(token)`\n- added `HTMLMAIL(address, subject, body, [language], [callback])` for sending of raw HTML mail messages\n- added `NPMINSTALL(name, callback)` for installing of 3rd party NPM dependencies\n- added `FILESTORAGE().image()` method for reading of images\n- `CONF.default_errorbuilder_errors` for handling of all HTTP errors via ErrorBuilder\n- decreased `default_interval_websocket_ping` to `1` minute (from `3`)\n- improved image cache in `FILESTORAGE()`\n- fixed `message` with `closing bytes` in WebSocket and `WEBSOCKETCLIENT()`\n- fixed `@{resource()}` method in View engine\n- fixed read stream in `FILESTORAGE()`\n\n========================\n0.0.36\n========================\n\n- improved HTTP cache\n- fixed parsing of schema keys in `PATCH` method\n- fixed predefined session functionality (a problem with cache)\n- fixed `API` routes with empty model\n\n========================\n0.0.35\n========================\n\n- extended `EXEC()` by adding support for `Tasks` and `Operations`\n- fixed `DELETE` method for the schemas, now it works same like `PATCH` method\n- fixed `FlowStream.use()` method\n- fixed pausing of outputs/inputs in `FlowStream`\n- fixed inputs in `FlowStream`\n- fixed command injection in `Image.pipe()` and `Image.stream()`\n- fixed parsing of uploaded files (sometimes was the writeable stream unclosed)\n- fixed execution of system routes\n\n========================\n0.0.31\n========================\n\n- added `CONF.default_errorbuilder_forxhr` key (default: `true`)\n- errors in requests with `xhr` are serialized via ErrorBuilder\n- fixed reconnecting in `WEBSOCKETCLIENT()`\n- fixed `$.success()` and `$.done()` used in chaining", "'use strict';\n\nconst Dns = require('dns');\nconst Url = require('url');\nconst Http = require('http');\nconst Https = require('https');\nconst Path = require('path');\nconst Fs = require('fs');\nconst Crypto = require('crypto');\nconst Zlib = require('zlib');\nconst Tls = require('tls');\nconst Net = require('net');\nconst KeepAlive = new Http.Agent({ keepAlive: true, timeout: 60000 });\nconst KeepAliveHttps = new Https.Agent({ keepAlive: true, timeout: 60000 });\nconst SKIPBODYENCRYPTOR = { ':': 1, '\"': 1, '[': 1, ']': 1, '\\'': 1, '_': 1, '{': 1, '}': 1, '&': 1, '=': 1, '+': 1, '-': 1, '\\\\': 1, '/': 1, ',': 1 };\nconst REG_EMPTYBUFFER = /\\0|%00|\\\\u0000/g;\nconst REG_EMPTYBUFFER_TEST = /\\0|%00|\\\\u0000/;\n\nconst COMPRESS = { gzip: 1, deflate: 1 };\nconst CONCAT = [null, null];\nconst SKIPPORTS = { '80': 1, '443': 1 };\n\nconst COMPARER = function(a, b) {\n\tif (!a && b)\n\t\treturn -1;\n\tif (a && !b)\n\t\treturn 1;\n\tif (a === b)\n\t\treturn 0;\n\treturn global.Intl.Collator().compare(a, b);\n};\n\nconst COMPARER_DESC = function(a, b) {\n\n\tif (!a && b)\n\t\treturn 1;\n\n\tif (a && !b)\n\t\treturn -1;\n\n\tif (a === b)\n\t\treturn 0;\n\n\tvar val = global.Intl.Collator().compare(a, b);\n\treturn val ? val * -1 : 0;\n};\n\nif (!global.framework_utils)\n\tglobal.framework_utils = exports;\n\nconst Internal = require('./internal');\nvar regexpSTATIC = /\\.\\w{2,8}($|\\?)+/;\nconst regexpTRIM = /^[\\s]+|[\\s]+$/g;\nconst regexpDATE = /(\\d{1,2}\\.\\d{1,2}\\.\\d{4})|(\\d{4}-\\d{1,2}-\\d{1,2})|(\\d{1,2}:\\d{1,2}(:\\d{1,2})?)/g;\nconst regexpDATEFORMAT = /YYYY|yyyy|YY|yy|MMMM|MMM|MM|M|dddd|DDDD|DDD|ddd|DD|dd|D|d|HH|H|hh|h|mm|m|ss|s|a|ww|w/g;\nconst regexpSTRINGFORMAT = /\\{\\d+\\}/g;\nconst regexpPATH = /\\\\/g;\nconst regexpTags = /<\\/?[^>]+(>|$)/g;\nconst regexpDiacritics = /[^\\u0000-\\u007e]/g;\nconst regexpUA = /[a-z]+/gi;\nconst regexpXML = /\\w+=\".*?\"/g;\nconst regexpDECODE = /&#?[a-z0-9]+;/g;\nconst regexpARG = /\\{{1,2}[a-z0-9_.-\\s]+\\}{1,2}/gi;\nconst regexpINTEGER = /(^-|\\s-)?[0-9]+/g;\nconst regexpFLOAT = /(^-|\\s-)?[0-9.,]+/g;\nconst regexpSEARCH = /[^a-zA-Z\u00e1-\u017e\u00c1-\u017d\\d\\s:]/g;\nconst regexpTERMINAL = /[\\w\\S]+/g;\nconst regexpCONFIGURE = /\\[\\w+\\]/g;\nconst regexpY = /y/g;\nconst regexpN = /\\n/g;\nconst regexpCHARS = /\\W|_/g;\nconst regexpCHINA = /[\\u3400-\\u9FBF]/;\nconst regexpLINES = /\\n|\\r|\\r\\n/;\nconst regexpBASE64 = /^([A-Za-z0-9+/]{4})*([A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{2}==)?$/;\nconst regexpBASE64_2 = /^|,([A-Za-z0-9+/]{4})*([A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{2}==)?$/;\nconst ENCODING = 'utf8';\nconst NEWLINE = '\\r\\n';\nconst isWindows = require('os').platform().substring(0, 3).toLowerCase() === 'win';\nconst DIACRITICSMAP = {};\nconst ALPHA_INDEX = { '&lt': '<', '&gt': '>', '&quot': '\"', '&apos': '\\'', '&amp': '&', '&lt;': '<', '&gt;': '>', '&quot;': '\"', '&apos;': '\\'', '&amp;': '&' };\nconst STREAMPIPE = { end: false };\nconst CT = 'Content-Type';\nconst CRC32TABLE = '00000000,77073096,EE0E612C,990951BA,076DC419,706AF48F,E963A535,9E6495A3,0EDB8832,79DCB8A4,E0D5E91E,97D2D988,09B64C2B,7EB17CBD,E7B82D07,90BF1D91,1DB71064,6AB020F2,F3B97148,84BE41DE,1ADAD47D,6DDDE4EB,F4D4B551,83D385C7,136C9856,646BA8C0,FD62F97A,8A65C9EC,14015C4F,63066CD9,FA0F3D63,8D080DF5,3B6E20C8,4C69105E,D56041E4,A2677172,3C03E4D1,4B04D447,D20D85FD,A50AB56B,35B5A8FA,42B2986C,DBBBC9D6,ACBCF940,32D86CE3,45DF5C75,DCD60DCF,ABD13D59,26D930AC,51DE003A,C8D75180,BFD06116,21B4F4B5,56B3C423,CFBA9599,B8BDA50F,2802B89E,5F058808,C60CD9B2,B10BE924,2F6F7C87,58684C11,C1611DAB,B6662D3D,76DC4190,01DB7106,98D220BC,EFD5102A,71B18589,06B6B51F,9FBFE4A5,E8B8D433,7807C9A2,0F00F934,9609A88E,E10E9818,7F6A0DBB,086D3D2D,91646C97,E6635C01,6B6B51F4,1C6C6162,856530D8,F262004E,6C0695ED,1B01A57B,8208F4C1,F50FC457,65B0D9C6,12B7E950,8BBEB8EA,FCB9887C,62DD1DDF,15DA2D49,8CD37CF3,FBD44C65,4DB26158,3AB551CE,A3BC0074,D4BB30E2,4ADFA541,3DD895D7,A4D1C46D,D3D6F4FB,4369E96A,346ED9FC,AD678846,DA60B8D0,44042D73,33031DE5,AA0A4C5F,DD0D7CC9,5005713C,270241AA,BE0B1010,C90C2086,5768B525,206F85B3,B966D409,CE61E49F,5EDEF90E,29D9C998,B0D09822,C7D7A8B4,59B33D17,2EB40D81,B7BD5C3B,C0BA6CAD,EDB88320,9ABFB3B6,03B6E20C,74B1D29A,EAD54739,9DD277AF,04DB2615,73DC1683,E3630B12,94643B84,0D6D6A3E,7A6A5AA8,E40ECF0B,9309FF9D,0A00AE27,7D079EB1,F00F9344,8708A3D2,1E01F268,6906C2FE,F762575D,806567CB,196C3671,6E6B06E7,FED41B76,89D32BE0,10DA7A5A,67DD4ACC,F9B9DF6F,8EBEEFF9,17B7BE43,60B08ED5,D6D6A3E8,A1D1937E,38D8C2C4,4FDFF252,D1BB67F1,A6BC5767,3FB506DD,48B2364B,D80D2BDA,AF0A1B4C,36034AF6,41047A60,DF60EFC3,A867DF55,316E8EEF,4669BE79,CB61B38C,BC66831A,256FD2A0,5268E236,CC0C7795,BB0B4703,220216B9,5505262F,C5BA3BBE,B2BD0B28,2BB45A92,5CB36A04,C2D7FFA7,B5D0CF31,2CD99E8B,5BDEAE1D,9B64C2B0,EC63F226,756AA39C,026D930A,9C0906A9,EB0E363F,72076785,05005713,95BF4A82,E2B87A14,7BB12BAE,0CB61B38,92D28E9B,E5D5BE0D,7CDCEFB7,0BDBDF21,86D3D2D4,F1D4E242,68DDB3F8,1FDA836E,81BE16CD,F6B9265B,6FB077E1,18B74777,88085AE6,FF0F6A70,66063BCA,11010B5C,8F659EFF,F862AE69,616BFFD3,166CCF45,A00AE278,D70DD2EE,4E048354,3903B3C2,A7672661,D06016F7,4969474D,3E6E77DB,AED16A4A,D9D65ADC,40DF0B66,37D83BF0,A9BCAE53,DEBB9EC5,47B2CF7F,30B5FFE9,BDBDF21C,CABAC28A,53B39330,24B4A3A6,BAD03605,CDD70693,54DE5729,23D967BF,B3667A2E,C4614AB8,5D681B02,2A6F2B94,B40BBE37,C30C8EA1,5A05DF1B,2D02EF8D'.split(',').map(s => parseInt(s, 16));\nconst REGISARR = /\\[\\d+\\]|\\[\\]$/;\nconst REGREPLACEARR = /\\[\\]/g;\nconst PROXYBLACKLIST = { 'localhost': 1, '127.0.0.1': 1, '0.0.0.0': 1 };\nconst PROXYOPTIONS = { headers: {}, method: 'CONNECT', agent: false };\nconst PROXYTLS = { headers: {}};\nconst PROXYOPTIONSHTTP = {};\nconst REG_ROOT = /@\\{#\\}(\\/)?/g;\nconst REG_NOREMAP = /@\\{noremap\\}(\\n)?/g;\nconst REG_REMAP = /href=\".*?\"|src=\".*?\"/gi;\nconst REG_AJAX = /('|\")+(!)?(GET|POST|PUT|DELETE|PATCH)\\s(\\(.*?\\)\\s)?\\//g;\nconst REG_URLEXT = /(https|http|wss|ws|file):\\/\\/|\\/\\/[a-z0-9]|[a-z]:/i;\nconst REG_TEXTAPPLICATION = /text|application/i;\nconst REG_TIME = /am|pm/i;\nconst REG_XMLKEY = /\\[|\\]|:|\\.|_/g;\nconst HEADEREND = Buffer.from('\\r\\n\\r\\n', 'ascii');\nconst HEADERCHECK = 'Content-Disposition: form-data;'.toLowerCase();\n\nexports.MONTHS = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];\nexports.DAYS = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];\n\nvar DIACRITICS=[{b:' ',c:'\\u00a0'},{b:'0',c:'\\u07c0'},{b:'A',c:'\\u24b6\\uff21\\u00c0\\u00c1\\u00c2\\u1ea6\\u1ea4\\u1eaa\\u1ea8\\u00c3\\u0100\\u0102\\u1eb0\\u1eae\\u1eb4\\u1eb2\\u0226\\u01e0\\u00c4\\u01de\\u1ea2\\u00c5\\u01fa\\u01cd\\u0200\\u0202\\u1ea0\\u1eac\\u1eb6\\u1e00\\u0104\\u023a\\u2c6f'},{b:'AA',c:'\\ua732'},{b:'AE',c:'\\u00c6\\u01fc\\u01e2'},{b:'AO',c:'\\ua734'},{b:'AU',c:'\\ua736'},{b:'AV',c:'\\ua738\\ua73a'},{b:'AY',c:'\\ua73c'},{b:'B',c:'\\u24b7\\uff22\\u1e02\\u1e04\\u1e06\\u0243\\u0181'},{b:'C',c:'\\u24b8\\uff23\\ua73e\\u1e08\\u0106C\\u0108\\u010a\\u010c\\u00c7\\u0187\\u023b'},{b:'D',c:'\\u24b9\\uff24\\u1e0a\\u010e\\u1e0c\\u1e10\\u1e12\\u1e0e\\u0110\\u018a\\u0189\\u1d05\\ua779'},{b:'Dh',c:'\\u00d0'},{b:'DZ',c:'\\u01f1\\u01c4'},{b:'Dz',c:'\\u01f2\\u01c5'},{b:'E',c:'\\u025b\\u24ba\\uff25\\u00c8\\u00c9\\u00ca\\u1ec0\\u1ebe\\u1ec4\\u1ec2\\u1ebc\\u0112\\u1e14\\u1e16\\u0114\\u0116\\u00cb\\u1eba\\u011a\\u0204\\u0206\\u1eb8\\u1ec6\\u0228\\u1e1c\\u0118\\u1e18\\u1e1a\\u0190\\u018e\\u1d07'},{b:'F',c:'\\ua77c\\u24bb\\uff26\\u1e1e\\u0191\\ua77b'}, {b:'G',c:'\\u24bc\\uff27\\u01f4\\u011c\\u1e20\\u011e\\u0120\\u01e6\\u0122\\u01e4\\u0193\\ua7a0\\ua77d\\ua77e\\u0262'},{b:'H',c:'\\u24bd\\uff28\\u0124\\u1e22\\u1e26\\u021e\\u1e24\\u1e28\\u1e2a\\u0126\\u2c67\\u2c75\\ua78d'},{b:'I',c:'\\u24be\\uff29\\u00cc\\u00cd\\u00ce\\u0128\\u012a\\u012c\\u0130\\u00cf\\u1e2e\\u1ec8\\u01cf\\u0208\\u020a\\u1eca\\u012e\\u1e2c\\u0197'},{b:'J',c:'\\u24bf\\uff2a\\u0134\\u0248\\u0237'},{b:'K',c:'\\u24c0\\uff2b\\u1e30\\u01e8\\u1e32\\u0136\\u1e34\\u0198\\u2c69\\ua740\\ua742\\ua744\\ua7a2'},{b:'L',c:'\\u24c1\\uff2c\\u013f\\u0139\\u013d\\u1e36\\u1e38\\u013b\\u1e3c\\u1e3a\\u0141\\u023d\\u2c62\\u2c60\\ua748\\ua746\\ua780'}, {b:'LJ',c:'\\u01c7'},{b:'Lj',c:'\\u01c8'},{b:'M',c:'\\u24c2\\uff2d\\u1e3e\\u1e40\\u1e42\\u2c6e\\u019c\\u03fb'},{b:'N',c:'\\ua7a4\\u0220\\u24c3\\uff2e\\u01f8\\u0143\\u00d1\\u1e44\\u0147\\u1e46\\u0145\\u1e4a\\u1e48\\u019d\\ua790\\u1d0e'},{b:'NJ',c:'\\u01ca'},{b:'Nj',c:'\\u01cb'},{b:'O',c:'\\u24c4\\uff2f\\u00d2\\u00d3\\u00d4\\u1ed2\\u1ed0\\u1ed6\\u1ed4\\u00d5\\u1e4c\\u022c\\u1e4e\\u014c\\u1e50\\u1e52\\u014e\\u022e\\u0230\\u00d6\\u022a\\u1ece\\u0150\\u01d1\\u020c\\u020e\\u01a0\\u1edc\\u1eda\\u1ee0\\u1ede\\u1ee2\\u1ecc\\u1ed8\\u01ea\\u01ec\\u00d8\\u01fe\\u0186\\u019f\\ua74a\\ua74c'}, {b:'OE',c:'\\u0152'},{b:'OI',c:'\\u01a2'},{b:'OO',c:'\\ua74e'},{b:'OU',c:'\\u0222'},{b:'P',c:'\\u24c5\\uff30\\u1e54\\u1e56\\u01a4\\u2c63\\ua750\\ua752\\ua754'},{b:'Q',c:'\\u24c6\\uff31\\ua756\\ua758\\u024a'},{b:'R',c:'\\u24c7\\uff32\\u0154\\u1e58\\u0158\\u0210\\u0212\\u1e5a\\u1e5c\\u0156\\u1e5e\\u024c\\u2c64\\ua75a\\ua7a6\\ua782'},{b:'S',c:'\\u24c8\\uff33\\u1e9e\\u015a\\u1e64\\u015c\\u1e60\\u0160\\u1e66\\u1e62\\u1e68\\u0218\\u015e\\u2c7e\\ua7a8\\ua784'},{b:'T',c:'\\u24c9\\uff34\\u1e6a\\u0164\\u1e6c\\u021a\\u0162\\u1e70\\u1e6e\\u0166\\u01ac\\u01ae\\u023e\\ua786'}, {b:'Th',c:'\\u00de'},{b:'TZ',c:'\\ua728'},{b:'U',c:'\\u24ca\\uff35\\u00d9\\u00da\\u00db\\u0168\\u1e78\\u016a\\u1e7a\\u016c\\u00dc\\u01db\\u01d7\\u01d5\\u01d9\\u1ee6\\u016e\\u0170\\u01d3\\u0214\\u0216\\u01af\\u1eea\\u1ee8\\u1eee\\u1eec\\u1ef0\\u1ee4\\u1e72\\u0172\\u1e76\\u1e74\\u0244'},{b:'V',c:'\\u24cb\\uff36\\u1e7c\\u1e7e\\u01b2\\ua75e\\u0245'},{b:'VY',c:'\\ua760'},{b:'W',c:'\\u24cc\\uff37\\u1e80\\u1e82\\u0174\\u1e86\\u1e84\\u1e88\\u2c72'},{b:'X',c:'\\u24cd\\uff38\\u1e8a\\u1e8c'},{b:'Y',c:'\\u24ce\\uff39\\u1ef2\\u00dd\\u0176\\u1ef8\\u0232\\u1e8e\\u0178\\u1ef6\\u1ef4\\u01b3\\u024e\\u1efe'}, {b:'Z',c:'\\u24cf\\uff3a\\u0179\\u1e90\\u017b\\u017d\\u1e92\\u1e94\\u01b5\\u0224\\u2c7f\\u2c6b\\ua762'},{b:'a',c:'\\u24d0\\uff41\\u1e9a\\u00e0\\u00e1\\u00e2\\u1ea7\\u1ea5\\u1eab\\u1ea9\\u00e3\\u0101\\u0103\\u1eb1\\u1eaf\\u1eb5\\u1eb3\\u0227\\u01e1\\u00e4\\u01df\\u1ea3\\u00e5\\u01fb\\u01ce\\u0201\\u0203\\u1ea1\\u1ead\\u1eb7\\u1e01\\u0105\\u2c65\\u0250\\u0251'},{b:'aa',c:'\\ua733'},{b:'ae',c:'\\u00e6\\u01fd\\u01e3'},{b:'ao',c:'\\ua735'},{b:'au',c:'\\ua737'},{b:'av',c:'\\ua739\\ua73b'},{b:'ay',c:'\\ua73d'}, {b:'b',c:'\\u24d1\\uff42\\u1e03\\u1e05\\u1e07\\u0180\\u0183\\u0253\\u0182'},{b:'c',c:'\\uff43\\u24d2\\u0107\\u0109\\u010b\\u010d\\u00e7\\u1e09\\u0188\\u023c\\ua73f\\u2184'},{b:'d',c:'\\u24d3\\uff44\\u1e0b\\u010f\\u1e0d\\u1e11\\u1e13\\u1e0f\\u0111\\u018c\\u0256\\u0257\\u018b\\u13e7\\u0501\\ua7aa'},{b:'dh',c:'\\u00f0'},{b:'dz',c:'\\u01f3\\u01c6'},{b:'e',c:'\\u24d4\\uff45\\u00e8\\u00e9\\u00ea\\u1ec1\\u1ebf\\u1ec5\\u1ec3\\u1ebd\\u0113\\u1e15\\u1e17\\u0115\\u0117\\u00eb\\u1ebb\\u011b\\u0205\\u0207\\u1eb9\\u1ec7\\u0229\\u1e1d\\u0119\\u1e19\\u1e1b\\u0247\\u01dd'}, {b:'f',c:'\\u24d5\\uff46\\u1e1f\\u0192'},{b:'ff',c:'\\ufb00'},{b:'fi',c:'\\ufb01'},{b:'fl',c:'\\ufb02'},{b:'ffi',c:'\\ufb03'},{b:'ffl',c:'\\ufb04'},{b:'g',c:'\\u24d6\\uff47\\u01f5\\u011d\\u1e21\\u011f\\u0121\\u01e7\\u0123\\u01e5\\u0260\\ua7a1\\ua77f\\u1d79'},{b:'h',c:'\\u24d7\\uff48\\u0125\\u1e23\\u1e27\\u021f\\u1e25\\u1e29\\u1e2b\\u1e96\\u0127\\u2c68\\u2c76\\u0265'},{b:'hv',c:'\\u0195'},{b:'i',c:'\\u24d8\\uff49\\u00ec\\u00ed\\u00ee\\u0129\\u012b\\u012d\\u00ef\\u1e2f\\u1ec9\\u01d0\\u0209\\u020b\\u1ecb\\u012f\\u1e2d\\u0268\\u0131'}, {b:'j',c:'\\u24d9\\uff4a\\u0135\\u01f0\\u0249'},{b:'k',c:'\\u24da\\uff4b\\u1e31\\u01e9\\u1e33\\u0137\\u1e35\\u0199\\u2c6a\\ua741\\ua743\\ua745\\ua7a3'},{b:'l',c:'\\u24db\\uff4c\\u0140\\u013a\\u013e\\u1e37\\u1e39\\u013c\\u1e3d\\u1e3b\\u017f\\u0142\\u019a\\u026b\\u2c61\\ua749\\ua781\\ua747\\u026d'},{b:'lj',c:'\\u01c9'},{b:'m',c:'\\u24dc\\uff4d\\u1e3f\\u1e41\\u1e43\\u0271\\u026f'},{b:'n',c:'\\u24dd\\uff4e\\u01f9\\u0144\\u00f1\\u1e45\\u0148\\u1e47\\u0146\\u1e4b\\u1e49\\u019e\\u0272\\u0149\\ua791\\ua7a5\\u043b\\u0509'},{b:'nj', c:'\\u01cc'},{b:'o',c:'\\u24de\\uff4f\\u00f2\\u00f3\\u00f4\\u1ed3\\u1ed1\\u1ed7\\u1ed5\\u00f5\\u1e4d\\u022d\\u1e4f\\u014d\\u1e51\\u1e53\\u014f\\u022f\\u0231\\u00f6\\u022b\\u1ecf\\u0151\\u01d2\\u020d\\u020f\\u01a1\\u1edd\\u1edb\\u1ee1\\u1edf\\u1ee3\\u1ecd\\u1ed9\\u01eb\\u01ed\\u00f8\\u01ff\\ua74b\\ua74d\\u0275\\u0254\\u1d11'},{b:'oe',c:'\\u0153'},{b:'oi',c:'\\u01a3'},{b:'oo',c:'\\ua74f'},{b:'ou',c:'\\u0223'},{b:'p',c:'\\u24df\\uff50\\u1e55\\u1e57\\u01a5\\u1d7d\\ua751\\ua753\\ua755\\u03c1'},{b:'q',c:'\\u24e0\\uff51\\u024b\\ua757\\ua759'}, {b:'r',c:'\\u24e1\\uff52\\u0155\\u1e59\\u0159\\u0211\\u0213\\u1e5b\\u1e5d\\u0157\\u1e5f\\u024d\\u027d\\ua75b\\ua7a7\\ua783'},{b:'s',c:'\\u24e2\\uff53\\u015b\\u1e65\\u015d\\u1e61\\u0161\\u1e67\\u1e63\\u1e69\\u0219\\u015f\\u023f\\ua7a9\\ua785\\u1e9b\\u0282'},{b:'ss',c:'\\u00df'},{b:'t',c:'\\u24e3\\uff54\\u1e6b\\u1e97\\u0165\\u1e6d\\u021b\\u0163\\u1e71\\u1e6f\\u0167\\u01ad\\u0288\\u2c66\\ua787'},{b:'th',c:'\\u00fe'},{b:'tz',c:'\\ua729'},{b:'u',c:'\\u24e4\\uff55\\u00f9\\u00fa\\u00fb\\u0169\\u1e79\\u016b\\u1e7b\\u016d\\u00fc\\u01dc\\u01d8\\u01d6\\u01da\\u1ee7\\u016f\\u0171\\u01d4\\u0215\\u0217\\u01b0\\u1eeb\\u1ee9\\u1eef\\u1eed\\u1ef1\\u1ee5\\u1e73\\u0173\\u1e77\\u1e75\\u0289'}, {b:'v',c:'\\u24e5\\uff56\\u1e7d\\u1e7f\\u028b\\ua75f\\u028c'},{b:'vy',c:'\\ua761'},{b:'w',c:'\\u24e6\\uff57\\u1e81\\u1e83\\u0175\\u1e87\\u1e85\\u1e98\\u1e89\\u2c73'},{b:'x',c:'\\u24e7\\uff58\\u1e8b\\u1e8d'},{b:'y',c:'\\u24e8\\uff59\\u1ef3\\u00fd\\u0177\\u1ef9\\u0233\\u1e8f\\u00ff\\u1ef7\\u1e99\\u1ef5\\u01b4\\u024f\\u1eff'},{b:'z',c:'\\u24e9\\uff5a\\u017a\\u1e91\\u017c\\u017e\\u1e93\\u1e95\\u01b6\\u0225\\u0240\\u2c6c\\ua763'}];\nvar UPLOADINDEXER = 1;\n\nfor (var i=0; i <DIACRITICS.length; i+=1)\n\tfor (var chars=DIACRITICS[i].c,j=0;j<chars.length;j+=1)\n\t\tDIACRITICSMAP[chars[j]]=DIACRITICS[i].b;\n\nconst DP = Date.prototype;\nconst SP = String.prototype;\nconst NP = Number.prototype;\n\nDIACRITICS = null;\n\nvar CONTENTTYPES = {\n\taac: 'audio/aac',\n\tai: 'application/postscript',\n\tappcache: 'text/cache-manifest',\n\tavi: 'video/avi',\n\tbin: 'application/octet-stream',\n\tbmp: 'image/bmp',\n\tcoffee: 'text/coffeescript',\n\tcss: 'text/css',\n\tcsv: 'text/csv',\n\tdoc: 'application/msword',\n\tdocx: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',\n\tdtd: 'application/xml-dtd',\n\teps: 'application/postscript',\n\texe: 'application/octet-stream',\n\tflac: 'audio/x-flac',\n\tgeojson: 'application/json',\n\tgif: 'image/gif',\n\tgzip: 'application/x-gzip',\n\theic: 'image/heic',\n\theif: 'image/heif',\n\thtm: 'text/html',\n\thtml: 'text/html',\n\tico: 'image/x-icon',\n\tics: 'text/calendar',\n\tifb: 'text/calendar',\n\tjpe: 'image/jpeg',\n\tjpeg: 'image/jpeg',\n\tjpg: 'image/jpeg',\n\tjs: 'text/javascript',\n\tjson: 'application/json',\n\tjsx: 'text/jsx',\n\tless: 'text/css',\n\tm4a: 'audio/mp4a-latm',\n\tm4v: 'video/x-m4v',\n\tmanifest: 'text/cache-manifest',\n\tmd: 'text/x-markdown',\n\tmid: 'audio/midi',\n\tmidi: 'audio/midi',\n\tmjs: 'text/javascript',\n\tmov: 'video/quicktime',\n\tmp3: 'audio/mpeg',\n\tmp4: 'video/mp4',\n\tmpe: 'video/mpeg',\n\tmpeg: 'video/mpeg',\n\tmpg: 'video/mpeg',\n\tmpga: 'audio/mpeg',\n\tmtl: 'text/plain',\n\tmv4: 'video/mv4',\n\tobj: 'text/plain',\n\togg: 'application/ogg',\n\togv: 'video/ogg',\n\tpackage: 'text/plain',\n\tpdf: 'application/pdf',\n\tpng: 'image/png',\n\tppt: 'application/vnd.ms-powerpoint',\n\tpptx: 'application/vnd.ms-powerpoint',\n\tps: 'application/postscript',\n\trar: 'application/x-rar-compressed',\n\trtf: 'text/rtf',\n\tsass: 'text/css',\n\tscss: 'text/css',\n\tsh: 'application/x-sh',\n\tstl: 'application/sla',\n\tsvg: 'image/svg+xml',\n\tswf: 'application/x-shockwave-flash',\n\ttar: 'application/x-tar',\n\ttif: 'image/tiff',\n\ttiff: 'image/tiff',\n\ttxt: 'text/plain',\n\tsql: 'text/plain',\n\twav: 'audio/x-wav',\n\twebm: 'video/webm',\n\twebp: 'image/webp',\n\twoff: 'application/font-woff',\n\twoff2: 'application/font-woff2',\n\txht: 'application/xhtml+xml',\n\txhtml: 'application/xhtml+xml',\n\txls: 'application/vnd.ms-excel',\n\txlsx: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',\n\txml: 'application/xml',\n\txpm: 'image/x-xpixmap',\n\txsl: 'application/xml',\n\txslt: 'application/xslt+xml',\n\tzip: 'application/zip'\n};\n\nvar dnscache = {};\nvar datetimeformat = {};\n\nglobal.DIFFARR = exports.diffarr = function(prop, db, form) {\n\n\tvar an = [];\n\tvar au = [];\n\tvar ar = [];\n\tvar is, oa, ob;\n\n\tfor (var i = 0; i < db.length; i++) {\n\t\toa = db[i];\n\t\tis = false;\n\t\tfor (var j = 0; j < form.length; j++) {\n\t\t\tob = form[j];\n\t\t\tif (oa[prop] == ob[prop]) {\n\t\t\t\tau.push({ db: oa, form: ob });\n\t\t\t\tis = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!is)\n\t\t\tar.push(oa[prop]);\n\t}\n\n\tfor (var i = 0; i < form.length; i++) {\n\t\tob = form[i];\n\t\tis = false;\n\t\tfor (var j = 0; j < db.length; j++) {\n\t\t\toa = db[j];\n\t\t\tif (ob[prop] == oa[prop]) {\n\t\t\t\tis = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!is)\n\t\t\tan.push(ob);\n\t}\n\n\tvar obj = {};\n\tobj.add = an;\n\tobj.upd = au;\n\tobj.rem = ar;\n\treturn obj;\n};\n\nexports.toURLEncode = function(value) {\n\tvar builder = [];\n\n\tfor (var key in value) {\n\t\tvar val = value[key];\n\n\t\tif (val == null || val === '')\n\t\t\tcontinue;\n\n\t\tvar type = typeof(val);\n\t\tswitch (type) {\n\t\t\tcase 'string':\n\t\t\t\tbuilder.push(key + '=' + encodeURIComponent(val));\n\t\t\t\tbreak;\n\t\t\tcase 'date':\n\t\t\t\tbuilder.push(key + '=' + encodeURIComponent(val.format('utc')));\n\t\t\t\tbreak;\n\t\t\tcase 'boolean':\n\t\t\tcase 'number':\n\t\t\t\tbuilder.push(key + '=' + val);\n\t\t\t\tbreak;\n\t\t\tcase 'object':\n\t\t\t\tif (val instanceof Array)\n\t\t\t\t\tbuilder.push(key + '=' + encodeURIComponent(val.join(',')));\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn builder.length ? builder.join('&') : '';\n};\n\nexports.resolve = function(url, callback, param) {\n\n\tvar uri;\n\n\ttry {\n\t\turi = Url.parse(url);\n\t} catch (e) {\n\t\tcallback(e);\n\t\treturn;\n\t}\n\n\tvar cache = dnscache[uri.host];\n\n\tif (!callback)\n\t\treturn cache;\n\n\tif (cache) {\n\t\turi.host = cache[0];\n\t\tcallback(null, uri, param, cache);\n\t\treturn;\n\t}\n\n\tDns.resolve4(uri.hostname, function(e, addresses) {\n\t\tif (e)\n\t\t\tsetImmediate(dnsresolve_callback, uri, callback, param);\n\t\telse {\n\t\t\tdnscache[uri.host] = addresses;\n\t\t\turi.host = addresses[0];\n\t\t\tcallback(null, uri, param, addresses);\n\t\t}\n\t});\n};\n\nfunction dnsresolve_callback(uri, callback, param) {\n\tDns.resolve4(uri.hostname, function(e, addresses) {\n\t\tif (addresses && addresses.length) {\n\t\t\tdnscache[uri.host] = addresses;\n\t\t\turi.host = addresses[0];\n\t\t}\n\t\tcallback(e, uri, param, addresses);\n\t});\n}\n\nsetImmediate(function() {\n\tglobal.F && NEWCOMMAND('clear_dnscache', function() {\n\t\tdnscache = {};\n\t});\n});\n\nexports.keywords = function(content, forSearch, alternative, max_count, max_length, min_length) {\n\n\tif (forSearch === undefined)\n\t\tforSearch = true;\n\n\tmin_length = min_length || 2;\n\tmax_count = max_count || 200;\n\tmax_length = max_length || 20;\n\n\tvar words = [];\n\n\tif (content instanceof Array) {\n\t\tfor (var i = 0, length = content.length; i < length; i++) {\n\t\t\tif (!content[i])\n\t\t\t\tcontinue;\n\t\t\tvar tmp = (forSearch ? content[i].toASCII().toLowerCase().replace(regexpY, 'i') : content[i].toLowerCase()).replace(regexpN, ' ').split(' ');\n\t\t\tif (!tmp || !tmp.length)\n\t\t\t\tcontinue;\n\t\t\tfor (var j = 0, jl = tmp.length; j < jl; j++)\n\t\t\t\twords.push(tmp[j]);\n\t\t}\n\t} else\n\t\twords = (forSearch ? content.toASCII().toLowerCase().replace(regexpY, 'i') : content.toLowerCase()).replace(regexpN, ' ').split(' ');\n\n\tif (!words)\n\t\twords = [];\n\n\tvar dic = {};\n\tvar counter = 0;\n\n\tfor (var i = 0, length = words.length; i < length; i++) {\n\n\t\tvar word = words[i].trim().replace(regexpCHARS, keywordscleaner);\n\n\t\tif (regexpCHINA.test(word)) {\n\n\t\t\tvar tmpw = word.split('', max_count);\n\n\t\t\tfor (var j = 0; j < tmpw.length; j++) {\n\t\t\t\tword = tmpw[j];\n\t\t\t\tif (dic[word])\n\t\t\t\t\tdic[word]++;\n\t\t\t\telse\n\t\t\t\t\tdic[word] = 1;\n\t\t\t\tcounter++;\n\t\t\t}\n\n\t\t\tif (counter >= max_count)\n\t\t\t\tbreak;\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (word.length < min_length)\n\t\t\tcontinue;\n\n\t\tif (counter >= max_count)\n\t\t\tbreak;\n\n\t\t// Gets 80% length of word\n\t\tif (alternative) {\n\t\t\tvar size = (word.length / 100) * 80;\n\t\t\tif (size > min_length + 1)\n\t\t\t\tword = word.substring(0, size);\n\t\t}\n\n\t\tif (word.length < min_length || word.length > max_length)\n\t\t\tcontinue;\n\n\t\tif (dic[word])\n\t\t\tdic[word]++;\n\t\telse\n\t\t\tdic[word] = 1;\n\n\t\tcounter++;\n\t}\n\n\tvar keys = Object.keys(dic);\n\n\tkeys.sort(function(a, b) {\n\t\tvar countA = dic[a];\n\t\tvar countB = dic[b];\n\t\treturn countA > countB ? -1 : countA < countB ? 1 : 0;\n\t});\n\n\treturn keys;\n};\n\nfunction keywordscleaner(c) {\n\treturn c.charCodeAt(0) < 200 ? '' : c;\n}\n\nfunction parseProxy(p) {\n\tvar key = 'proxy_' + p;\n\tif (F.temporary.other[key])\n\t\treturn F.temporary.other[key];\n\n\tif (p.indexOf('://') === -1)\n\t\tp = 'http://' + p;\n\n\tvar obj = Url.parse(p);\n\n\tif (obj.auth)\n\t\tobj._auth = 'Basic ' + Buffer.from(obj.auth).toString('base64');\n\n\tobj.port = +obj.port;\n\n\tif (p.indexOf('https:') !== -1) {\n\t\tobj.rejectUnauthorized = false;\n\t\tobj.requestCert = true;\n\t}\n\n\treturn F.temporary.other[key] = obj;\n}\n\nglobal.REQUEST = function(opt, callback) {\n\n\tvar options = { length: 0, timeout: opt.timeout || CONF.default_restbuilder_timeout, encoding: opt.encoding || ENCODING, callback: opt.callback || NOOP, post: true, redirect: 0 };\n\tvar proxy;\n\n\tif (callback)\n\t\topt.callback = callback;\n\n\tif (global.F)\n\t\tglobal.F.stats.performance.external++;\n\n\tif (opt.headers)\n\t\topt.headers = exports.extend({}, opt.headers);\n\telse\n\t\topt.headers = {};\n\n\tif (!opt.method)\n\t\topt.method = 'GET';\n\n\toptions.$totalinit = opt;\n\n\t// opt.encrypt {String}\n\t// opt.limit in kB\n\t// opt.key {Buffer}\n\t// opt.cert {Buffer}\n\t// opt.onprogress(percentage)\n\t// opt.ondata(chunk, percentage)\n\n\tif (opt.ondata)\n\t\toptions.ondata = opt.ondata;\n\n\tif (opt.onprogress)\n\t\toptions.onprogress = opt.onprogress;\n\n\tif (opt.proxy)\n\t\tproxy = parseProxy(opt.proxy);\n\n\tif (opt.xhr)\n\t\topt.headers['X-Requested-With'] = 'XMLHttpRequest';\n\n\toptions.response = opt.response ? opt.response : {};\n\toptions.response.body = '';\n\toptions.iserror = false;\n\n\tif (opt.resolve || opt.dnscache)\n\t\toptions.resolve = true;\n\n\tif (opt.custom)\n\t\toptions.custom = true;\n\n\tif (opt.noredirect)\n\t\toptions.noredirect = true;\n\n\tif (opt.keepalive)\n\t\toptions.keepalive = true;\n\n\tif (opt.type) {\n\t\tswitch (opt.type) {\n\t\t\tcase 'plain':\n\t\t\t\topt.headers[CT] = 'text/plain';\n\t\t\t\tbreak;\n\t\t\tcase 'html':\n\t\t\t\topt.headers[CT] = 'text/html';\n\t\t\t\tbreak;\n\t\t\tcase 'raw':\n\t\t\t\topt.headers[CT] = 'application/octet-stream';\n\t\t\t\tbreak;\n\t\t\tcase 'json':\n\t\t\t\topt.headers[CT] = 'application/json';\n\t\t\t\tbreak;\n\t\t\tcase 'urlencoded':\n\t\t\t\topt.headers[CT] = 'application/x-www-form-urlencoded';\n\t\t\t\tbreak;\n\t\t\tcase 'xml':\n\t\t\t\topt.headers[CT] = 'text/xml';\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (opt.files) {\n\t\toptions.boundary = '----TOTALFILE_' + Math.random().toString(36).substring(3);\n\t\topt.headers[CT] = 'multipart/form-data; boundary=' + options.boundary;\n\t\toptions.files = opt.files;\n\t\toptions.upload = true;\n\n\t\t// Must be object { key: value }\n\t\tif (opt.body)\n\t\t\toptions.body = opt.body;\n\n\t} else {\n\t\tif (opt.body) {\n\t\t\tif (!(opt.body instanceof Buffer)) {\n\t\t\t\tif (opt.encrypt) {\n\t\t\t\t\topt.body = exports.encrypt_data(opt.body, opt.encrypt);\n\t\t\t\t\topt.headers['X-Encryption'] = 'a';\n\t\t\t\t}\n\t\t\t\topt.body = Buffer.from(opt.body, ENCODING);\n\t\t\t}\n\t\t\topt.headers['Content-Length'] = opt.body.length;\n\t\t}\n\t\toptions.body = opt.body;\n\t}\n\n\tif (opt.cookies) {\n\t\tvar builder = '';\n\t\tfor (var m in opt.cookies)\n\t\t\tbuilder += (builder ? '; ' : '') + m + '=' + opt.cookies[m];\n\t\tif (builder)\n\t\t\topt.headers.Cookie = builder;\n\t}\n\n\tif (opt.query) {\n\t\tif (typeof(opt.query) !== 'string')\n\t\t\topt.query = U.toURLEncode(opt.query);\n\t\tif (opt.url) {\n\t\t\tif (opt.url.lastIndexOf('?') === -1)\n\t\t\t\topt.url += '?' + opt.query;\n\t\t\telse\n\t\t\t\topt.url += '&' + opt.query;\n\t\t} else if (opt.unixsocket.path) {\n\t\t\tif (opt.unixsocket.path.lastIndexOf('?') === -1)\n\t\t\t\topt.unixsocket.path += '?' + opt.query;\n\t\t\telse\n\t\t\t\topt.unixsocket.path += '&' + opt.query;\n\t\t}\n\t}\n\n\tvar uri = opt.unixsocket ? { socketPath: opt.unixsocket.socket, path: opt.unixsocket.path } : Url.parse(opt.url);\n\n\tif ((opt.unixsocket && !uri.socketPath) || (!opt.unixsocket && (!uri.hostname || !uri.host))) {\n\t\toptions.response.canceled = true;\n\t\topt.callback && opt.callback('Invalid hostname', options.response);\n\t\treturn;\n\t}\n\n\turi.method = opt.method;\n\turi.headers = opt.headers;\n\n\tif (options.insecure) {\n\t\turi.rejectUnauthorized = false;\n\t\turi.requestCert = true;\n\t}\n\n\toptions.uri = uri;\n\toptions.opt = opt;\n\n\tif (opt.key)\n\t\turi.key = opt.key;\n\n\tif (opt.cert)\n\t\turi.cert = opt.cert;\n\n\tif (opt.dhparam)\n\t\turi.dhparam = opt.dhparam;\n\n\tif (options.resolve && (opt.unixsocket || (uri.hostname === 'localhost' || uri.hostname.charCodeAt(0) < 64)))\n\t\toptions.resolve = false;\n\n\tif (!opt.unixsocket && CONF.default_proxy && !proxy && !PROXYBLACKLIST[uri.hostname])\n\t\tproxy = parseProxy(CONF.default_proxy);\n\n\tif (!opt.unixsocket && proxy && (uri.hostname === 'localhost' || uri.hostname === '127.0.0.1'))\n\t\tproxy = null;\n\n\toptions.proxy = proxy;\n\n\tif (proxy && uri.protocol === 'https:') {\n\t\tproxy.tls = true;\n\t\turi.agent = new ProxyAgent(options);\n\t\turi.agent.request = Http.request;\n\t\turi.agent.createSocket = createSecureSocket;\n\t\turi.agent.defaultPort = 443;\n\t}\n\n\tif (options.keepalive && !options.proxy) {\n\t\tif (uri.protocol === 'https:') {\n\t\t\tif (!uri.port)\n\t\t\t\turi.port = 443;\n\t\t\turi.agent = KeepAliveHttps;\n\t\t} else\n\t\t\turi.agent = KeepAlive;\n\t} else\n\t\turi.agent = null;\n\n\tif (proxy)\n\t\trequest_call(uri, options);\n\telse if (options.resolve)\n\t\texports.resolve(opt.url, request_resolve, options);\n\telse\n\t\trequest_call(uri, options);\n};\n\nfunction request_resolve(err, uri, options, origin) {\n\tif (!err) {\n\t\toptions.uri.host = uri.host;\n\t\toptions.origin = origin;\n\t}\n\trequest_call(options.uri, options);\n}\n\nfunction ProxyAgent(options) {\n\tvar self = this;\n\tself.options = options;\n\tself.maxSockets = Http.Agent.defaultMaxSockets;\n\tself.requests = [];\n}\n\nconst PAP = ProxyAgent.prototype;\n\nPAP.createConnection = function(pending) {\n\tvar self = this;\n\tself.createSocket(pending, function(socket) {\n\t\tpending.request.onSocket(socket);\n\t});\n};\n\nPAP.createSocket = function(options, callback) {\n\n\tvar self = this;\n\tvar proxy = self.options.proxy;\n\tvar uri = self.options.uri;\n\n\tPROXYOPTIONS.host = proxy.hostname;\n\tPROXYOPTIONS.port = proxy.port;\n\tPROXYOPTIONS.path = PROXYOPTIONS.headers.host = uri.hostname + ':' + (uri.port || '443');\n\n\tif (proxy._auth)\n\t\tPROXYOPTIONS.headers['Proxy-Authorization'] = proxy._auth;\n\n\tvar req = self.request(PROXYOPTIONS);\n\treq.setTimeout(10000);\n\treq.on('response', proxyagent_response);\n\treq.on('connect', function(res, socket) {\n\n\t\tif (res.statusCode === 200) {\n\t\t\tsocket.$req = req;\n\t\t\tcallback(socket);\n\t\t} else {\n\t\t\tvar err = new Error('Proxy could not be established (maybe a problem in auth), code: ' + res.statusCode);\n\t\t\terr.code = 'ECONNRESET';\n\t\t\treq.destroy && req.destroy();\n\t\t\treq = null;\n\t\t\tself.requests = null;\n\t\t\tself.options = null;\n\t\t}\n\n\t});\n\n\treq.on('error', function(err) {\n\t\tvar e = new Error('Request Proxy \"proxy {0} --> target {1}\": {2}'.format(PROXYOPTIONS.host + ':' + proxy.port, PROXYOPTIONS.path, err.toString()));\n\t\te.code = err.code;\n\t\treq.destroy && req.destroy();\n\t\treq = null;\n\t\tself.requests = null;\n\t\tself.options = null;\n\t});\n\n\treq.end();\n};\n\nfunction proxyagent_response(res) {\n\tres.upgrade = true;\n}\n\nPAP.addRequest = function(req, options) {\n\tthis.createConnection({ host: options.host, port: options.port, request: req });\n};\n\nfunction createSecureSocket(options, callback) {\n\tvar self = this;\n\tPAP.createSocket.call(self, options, function(socket) {\n\t\tPROXYTLS.servername = self.options.uri.hostname;\n\t\tPROXYTLS.headers = self.options.uri.headers;\n\t\tPROXYTLS.socket = socket;\n\t\tvar tls = Tls.connect(0, PROXYTLS);\n\t\tcallback(tls);\n\t});\n}\n\nfunction request_call(uri, options) {\n\n\tvar opt;\n\n\tif (options.proxy && !options.proxy.tls) {\n\t\topt = PROXYOPTIONSHTTP;\n\t\topt.port = options.proxy.port;\n\t\topt.host = options.proxy.hostname;\n\t\topt.path = uri.href;\n\t\topt.headers = uri.headers;\n\t\topt.method = uri.method;\n\t\topt.headers.host = uri.host;\n\t\tif (options.proxy._auth)\n\t\t\topt.headers['Proxy-Authorization'] = options.proxy._auth;\n\t} else\n\t\topt = uri;\n\n\tvar connection = uri.protocol === 'https:' ? Https : Http;\n\tvar req = opt.method === 'GET' ? connection.get(opt, request_response) : connection.request(opt, request_response);\n\n\treq.$options = options;\n\treq.$uri = uri;\n\n\tif (!options.callback) {\n\t\treq.on('error', NOOP);\n\t\treturn;\n\t}\n\n\treq.on('error', request_process_error);\n\toptions.timeoutid && clearTimeout(options.timeoutid);\n\toptions.timeoutid = setTimeout(request_process_timeout, options.timeout, req);\n\n\treq.on('response', request_assign_res);\n\n\tif (options.upload) {\n\t\toptions.first = true;\n\t\toptions.files.wait(function(file, next) {\n\t\t\trequest_writefile(req, options, file, next);\n\t\t}, function() {\n\n\t\t\tif (options.iserror)\n\t\t\t\treturn;\n\n\t\t\tif (options.body) {\n\t\t\t\tfor (var key in options.body) {\n\t\t\t\t\tvar value = options.body[key];\n\t\t\t\t\tif (value != null) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\treq.write((options.first ? '' : NEWLINE) + '--' + options.boundary + NEWLINE + 'Content-Disposition: form-data; name=\"' + key + '\"' + NEWLINE + NEWLINE + value);\n\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\trequest_process_error.apply(req, e);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (options.first)\n\t\t\t\t\t\t\toptions.first = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treq.end(NEWLINE + '--' + options.boundary + '--');\n\t\t});\n\t} else\n\t\treq.end(options.body);\n}\n\nfunction request_process_error(err) {\n\tvar options = this.$options;\n\toptions.iserror = true;\n\tif (options.callback && !options.done) {\n\t\tif (options.timeoutid) {\n\t\t\tclearTimeout(options.timeoutid);\n\t\t\toptions.timeoutid = null;\n\t\t}\n\t\toptions.canceled = true;\n\t\toptions.response.status = 0;\n\t\toptions.response.host = this.$uri.host;\n\t\toptions.callback(err, options.response);\n\t\toptions.callback = null;\n\t}\n}\n\nfunction request_process_timeout(req) {\n\tvar options = req.$options;\n\toptions.iserror = true;\n\tif (options.callback) {\n\t\tif (options.timeoutid) {\n\t\t\tclearTimeout(options.timeoutid);\n\t\t\toptions.timeoutid = null;\n\t\t}\n\t\treq.socket.destroy();\n\t\treq.socket.end();\n\t\treq.destroy();\n\t\toptions.response.status = 408;\n\t\toptions.response.host = req.$uri.host;\n\t\toptions.canceled = true;\n\t\toptions.callback(exports.httpstatus(408), options.response);\n\t\toptions.callback = null;\n\t}\n}\n\nfunction request_process_ok() {\n\tvar options = this.req.$options;\n\tif (options.timeoutid) {\n\t\tclearTimeout(options.timeoutid);\n\t\toptions.timeoutid = null;\n\t}\n}\n\nfunction request_assign_res(response) {\n\tresponse.req = this;\n}\n\nfunction request_writefile(req, options, file, next) {\n\n\tif (options.iserror) {\n\t\tnext();\n\t\treturn;\n\t}\n\n\tvar isbuffer = file.buffer instanceof Buffer;\n\tvar filename = (isbuffer ? file.name : exports.getName(file.filename));\n\n\treq.write((options.first ? '' : NEWLINE) + '--' + options.boundary + NEWLINE + 'Content-Disposition: form-data; name=\"' + file.name + '\"; filename=\"' + filename + '\"' + NEWLINE + 'Content-Type: ' + exports.getContentType(exports.getExtension(filename)) + NEWLINE + NEWLINE);\n\n\tif (options.first)\n\t\toptions.first = false;\n\n\tif (isbuffer) {\n\t\ttry {\n\t\t\treq.write(file.buffer);\n\t\t} catch (e) {\n\t\t\trequest_process_error.apply(req, e);\n\t\t}\n\t\tnext();\n\t} else {\n\t\tvar stream = Fs.createReadStream(file.filename);\n\t\tstream.once('close', next);\n\t\tstream.pipe(req, STREAMPIPE);\n\t}\n}\n\nfunction request_response(res) {\n\n\tvar options = this.$options;\n\tvar uri = this.$uri;\n\n\tres._buffer = null;\n\tres._bufferlength = 0;\n\n\t// We have redirect\n\tif (res.statusCode === 301 || res.statusCode === 302) {\n\n\t\tif (options.noredirect) {\n\t\t\toptions.timeoutid && clearTimeout(options.timeoutid);\n\t\t\toptions.canceled = true;\n\t\t\tif (options.callback) {\n\t\t\t\toptions.response.origin = options.origin;\n\t\t\t\toptions.response.status = res.statusCode;\n\t\t\t\toptions.response.headers = res.headers;\n\t\t\t\tif (options.custom) {\n\t\t\t\t\toptions.response.stream = res;\n\t\t\t\t\toptions.callback(null, options.response);\n\t\t\t\t} else {\n\t\t\t\t\toptions.response.host = uri.host;\n\t\t\t\t\toptions.response.headers = res.headers;\n\t\t\t\t\toptions.callback(null, options.response);\n\t\t\t\t}\n\t\t\t\toptions.callback = null;\n\t\t\t}\n\n\t\t\tres.req.removeAllListeners();\n\t\t\tres.removeAllListeners();\n\t\t\tres.req = null;\n\t\t\tres = null;\n\t\t\treturn;\n\t\t}\n\n\t\tif (options.redirect > (options.redirects || 3)) {\n\n\t\t\toptions.timeoutid && clearTimeout(options.timeoutid);\n\t\t\toptions.canceled = true;\n\t\t\toptions.response.origin = options.origin;\n\t\t\toptions.response.headers = res.headers;\n\n\t\t\tif (options.callback) {\n\t\t\t\tif (options.custom) {\n\t\t\t\t\toptions.response.status = res.statusCode;\n\t\t\t\t\toptions.response.stream = res;\n\t\t\t\t\toptions.callback('Too many redirects', options.response);\n\t\t\t\t} else {\n\t\t\t\t\toptions.response.status = 0;\n\t\t\t\t\toptions.response.host = uri.host;\n\t\t\t\t\toptions.callback('Too many redirects', options.response);\n\t\t\t\t}\n\t\t\t\toptions.callback = null;\n\t\t\t}\n\n\t\t\tres.req.removeAllListeners();\n\t\t\tres.removeAllListeners();\n\t\t\tres.req = null;\n\t\t\tres = null;\n\t\t\treturn;\n\t\t}\n\n\t\toptions.redirect++;\n\n\t\tvar loc = res.headers.location;\n\t\tvar proto = loc.substring(0, 6);\n\n\t\tif (proto !== 'http:/' && proto !== 'https:')\n\t\t\tloc = uri.protocol + '//' + uri.hostname + (uri.port && !SKIPPORTS[uri.port] ? (':' + uri.port) : '') + loc;\n\n\t\tvar tmp = Url.parse(loc);\n\t\ttmp.headers = uri.headers;\n\n\t\t// Transfers cookies\n\t\tif (!options.nocookies) {\n\t\t\tvar cookies = res.headers['set-cookie'];\n\t\t\tif (cookies) {\n\n\t\t\t\tif (options.$totalinit.cook && !options.$totalinit.cookies)\n\t\t\t\t\toptions.$totalinit.cookies = {};\n\n\t\t\t\tif (!options.cookies)\n\t\t\t\t\toptions.cookies = {};\n\n\t\t\t\tfor (var i = 0; i < cookies.length; i++) {\n\t\t\t\t\tvar cookie = cookies[i];\n\t\t\t\t\tvar index = cookie.indexOf(';');\n\t\t\t\t\tif (index !== -1){\n\t\t\t\t\t\tcookie = cookie.substring(0, index);\n\t\t\t\t\t\tindex = cookie.indexOf('=');\n\t\t\t\t\t\tif (index !== -1) {\n\t\t\t\t\t\t\tvar key = decodeURIComponent(cookie.substring(0, index));\n\t\t\t\t\t\t\toptions.cookies[key] = decodeURIComponent(cookie.substring(index + 1));\n\t\t\t\t\t\t\tif (options.$totalinit.cookies)\n\t\t\t\t\t\t\t\toptions.$totalinit.cookies[key] = options.cookies[key];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tvar builder = '';\n\t\t\t\tfor (var m in options.cookies)\n\t\t\t\t\tbuilder += (builder ? '; ' : '') + encodeURIComponent(m) + '=' + encodeURIComponent(options.cookies[m]);\n\n\t\t\t\tif (tmp.headers.cookie)\n\t\t\t\t\ttmp.headers.cookie = builder;\n\t\t\t\telse\n\t\t\t\t\ttmp.headers.Cookie = builder;\n\t\t\t}\n\t\t}\n\n\t\t// tmp.agent = false;\n\t\ttmp.method = uri.method;\n\n\t\tres.req.removeAllListeners();\n\t\tres.req = null;\n\n\t\tif (options.proxy && tmp.protocol === 'https:') {\n\t\t\t// TLS?\n\t\t\toptions.proxy.tls = true;\n\t\t\toptions.uri = tmp;\n\t\t\toptions.uri.agent = new ProxyAgent(options);\n\t\t\toptions.uri.agent.request = Http.request;\n\t\t\toptions.uri.agent.createSocket = createSecureSocket;\n\t\t\toptions.uri.agent.defaultPort = 443;\n\t\t}\n\n\t\tif (!options.resolve) {\n\t\t\tres.removeAllListeners();\n\t\t\tres = null;\n\t\t\treturn request_call(tmp, options);\n\t\t}\n\n\t\texports.resolve(tmp, function(err, u, param, origin) {\n\t\t\tif (!err) {\n\t\t\t\ttmp.host = u.host;\n\t\t\t\toptions.origin = origin;\n\t\t\t}\n\t\t\tres.removeAllListeners();\n\t\t\tres = null;\n\t\t\trequest_call(tmp, options);\n\t\t});\n\n\t\treturn;\n\t}\n\n\toptions.length = +res.headers['content-length'] || 0;\n\n\t// Shared cookies\n\tif (options.$totalinit.cook) {\n\n\t\tif (!options.$totalinit.cookies)\n\t\t\toptions.$totalinit.cookies = {};\n\n\t\tvar arr = (res.headers['set-cookie'] || '');\n\n\t\t// Only the one value\n\t\tif (arr && !(arr instanceof Array))\n\t\t\tarr = [arr];\n\n\t\tif (arr instanceof Array) {\n\t\t\tfor (var i = 0; i < arr.length; i++) {\n\t\t\t\tvar line = arr[i];\n\t\t\t\tvar end = line.indexOf(';');\n\t\t\t\tif (end === -1)\n\t\t\t\t\tend = line.length;\n\t\t\t\tline = line.substring(0, end);\n\t\t\t\tvar index = line.indexOf('=');\n\t\t\t\tif (index !== -1)\n\t\t\t\t\toptions.$totalinit.cookies[line.substring(0, index)] = decodeURIComponent(line.substring(index + 1));\n\t\t\t}\n\t\t}\n\t}\n\n\tif (res.statusCode === 204) {\n\t\toptions.done = true;\n\t\tif (options.custom) {\n\t\t\toptions.timeoutid && clearTimeout(options.timeoutid);\n\t\t\toptions.response.origin = options.origin;\n\t\t\toptions.response.status = res.statusCode;\n\t\t\toptions.response.headers = res.headers;\n\t\t\toptions.response.stream = res;\n\t\t\toptions.callback(null, options.response);\n\t\t\toptions.callback = null;\n\t\t} else\n\t\t\trequest_process_end.call(res);\n\t\treturn;\n\t}\n\n\toptions.timeoutid && res.once('data', request_process_ok);\n\n\tvar encoding = res.headers['content-encoding'] || '';\n\tif (encoding)\n\t\tencoding = encoding.split(',')[0];\n\n\tif (options.custom) {\n\t\toptions.timeoutid && clearTimeout(options.timeoutid);\n\t\toptions.response.origin = options.origin;\n\t\toptions.response.status = res.statusCode;\n\t\toptions.response.headers = res.headers;\n\t\toptions.response.stream = res;\n\t\toptions.callback && options.callback(null, options.response);\n\t\toptions.callback = null;\n\t} else {\n\t\tif (COMPRESS[encoding]) {\n\t\t\tvar zlib = encoding === 'gzip' ? Zlib.createGunzip() : Zlib.createInflate();\n\t\t\tzlib._buffer = res.buffer;\n\t\t\tzlib.headers = res.headers;\n\t\t\tzlib.statusCode = res.statusCode;\n\t\t\tzlib.res = res;\n\t\t\tzlib.on('data', request_process_data);\n\t\t\tzlib.on('end', request_process_end);\n\t\t\tres.pipe(zlib);\n\t\t} else {\n\t\t\tres.on('data', request_process_data);\n\t\t\tres.on('end', request_process_end);\n\t\t}\n\t}\n\n\tres.resume();\n}\n\nfunction request_process_data(chunk) {\n\tvar self = this;\n\t// Is Zlib\n\tif (!self.req)\n\t\tself = self.res;\n\tvar options = self.req.$options;\n\tif (options.canceled || (options.limit && self._bufferlength > options.limit))\n\t\treturn;\n\tif (self._buffer) {\n\t\tCONCAT[0] = self._buffer;\n\t\tCONCAT[1] = chunk;\n\t\tself._buffer = Buffer.concat(CONCAT);\n\t} else\n\t\tself._buffer = chunk;\n\tself._bufferlength += chunk.length;\n\toptions.ondata && options.ondata(chunk, options.length ? (self._bufferlength / options.length) * 100 : 0);\n\toptions.onprogress && options.onprogress(options.length ? (self._bufferlength / options.length) * 100 : 0);\n}\n\nfunction request_process_end() {\n\n\tvar res = this;\n\n\t// Is Zlib\n\tif (!res.req)\n\t\tres = res.res;\n\n\tvar self = res;\n\tvar options = self.req.$options;\n\tvar uri = self.req.$uri;\n\tvar data;\n\n\toptions.socket && options.uri.agent.destroy();\n\toptions.timeoutid && clearTimeout(options.timeoutid);\n\n\tif (options.canceled)\n\t\treturn;\n\n\tvar ct = self.headers['content-type'];\n\n\tif (!ct || REG_TEXTAPPLICATION.test(ct)) {\n\t\tdata = self._buffer ? options.encoding === 'binary' ? self._buffer : self._buffer.toString(options.encoding) : '';\n\t\tif (options.opt.encrypt && typeof(data) === 'string')\n\t\t\tdata = exports.decrypt_data(data, options.opt.encrypt);\n\t} else\n\t\tdata = self._buffer;\n\n\toptions.canceled = true;\n\tself._buffer = undefined;\n\n\tif (options.callback) {\n\t\toptions.response.origin = options.origin;\n\t\toptions.response.headers = self.headers;\n\t\toptions.response.body = data;\n\t\toptions.response.status = self.statusCode;\n\t\toptions.response.host = uri.host || uri.socketPath;\n\t\toptions.response.cookies = options.cookies;\n\t\toptions.callback(null, options.response);\n\t\toptions.callback = null;\n\t}\n\n\tif (res.statusCode !== 204) {\n\t\tres.req && res.req.removeAllListeners();\n\t\tres.removeAllListeners();\n\t}\n}\n\nexports.btoa = function(str) {\n\treturn (str instanceof Buffer) ? str.toString('base64') : Buffer.from(str.toString(), 'utf8').toString('base64');\n};\n\nexports.atob = function(str) {\n\treturn Buffer.from(str, 'base64').toString('utf8');\n};\n\n/**\n * Trim string properties\n * @param {Object} obj\n * @return {Object}\n */\nexports.trim = function(obj, clean) {\n\n\tif (!obj)\n\t\treturn obj;\n\n\tvar type = typeof(obj);\n\tif (type === 'string') {\n\t\tobj = obj.trim();\n\t\treturn clean && !obj ? undefined : obj;\n\t}\n\n\tif (obj instanceof Array) {\n\t\tfor (var i = 0, length = obj.length; i < length; i++) {\n\n\t\t\tvar item = obj[i];\n\t\t\ttype = typeof(item);\n\n\t\t\tif (type === 'object') {\n\t\t\t\texports.trim(item, clean);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (type !== 'string')\n\t\t\t\tcontinue;\n\n\t\t\tobj[i] = item.trim();\n\t\t\tif (clean && !obj[i])\n\t\t\t\tobj[i] = undefined;\n\t\t}\n\n\t\treturn obj;\n\t}\n\n\tif (type !== 'object')\n\t\treturn obj;\n\n\tfor (var key in obj) {\n\t\tvar val = obj[key];\n\t\tvar type = typeof(val);\n\t\tif (type === 'object') {\n\t\t\texports.trim(val, clean);\n\t\t\tcontinue;\n\t\t} else if (type !== 'string')\n\t\t\tcontinue;\n\t\tobj[key] = val.trim();\n\t\tif (clean && !obj[key])\n\t\t\tobj[key] = undefined;\n\t}\n\n\treturn obj;\n};\n\n/**\n * Noop function\n * @return {Function} Empty function.\n */\nglobal.NOOP = function() {};\n\n/**\n * Read HTTP status\n * @param  {Number} code HTTP code status.\n * @param  {Boolean} addCode Add code number to HTTP status.\n * @return {String}\n */\nexports.httpstatus = function(code, addCode) {\n\tif (addCode === undefined)\n\t\taddCode = true;\n\treturn (addCode ? code + ': ' : '') + Http.STATUS_CODES[code];\n};\n\n/**\n * Extend object\n * @param {Object} target Target object.\n * @param {Object} source Source object.\n * @param {Boolean} rewrite Rewrite exists values (optional, default true).\n * @return {Object} Modified object.\n */\nexports.extend = function(target, source, rewrite) {\n\n\tif (!target || !source)\n\t\treturn target;\n\n\tif (typeof(target) !== 'object' || typeof(source) !== 'object')\n\t\treturn target;\n\n\tif (rewrite === undefined)\n\t\trewrite = true;\n\n\tfor (var key in source) {\n\t\tif (rewrite || target[key] === undefined)\n\t\t\ttarget[key] = exports.clone(source[key]);\n\t}\n\n\treturn target;\n};\n\nexports.extend_headers = function(first, second) {\n\tvar keys = Object.keys(first);\n\tvar headers = {};\n\n\tvar i = keys.length;\n\twhile (i--)\n\t\theaders[keys[i]] = first[keys[i]];\n\n\tkeys = Object.keys(second);\n\ti = keys.length;\n\n\twhile (i--)\n\t\theaders[keys[i]] = second[keys[i]];\n\n\treturn headers;\n};\n\nexports.extend_headers2 = function(first, second) {\n\tvar keys = Object.keys(second);\n\tvar i = keys.length;\n\twhile (i--)\n\t\tfirst[keys[i]] = second[keys[i]];\n\treturn first;\n};\n\n/**\n * Clones object\n * @param {Object} obj\n * @param {Object} skip Optional, can be only object e.g. { name: true, age: true }.\n * @param {Boolean} skipFunctions It doesn't clone functions, optional --> default false.\n * @return {Object}\n */\nglobal.CLONE = exports.clone = function(obj, skip, skipFunctions) {\n\n\tif (!obj)\n\t\treturn obj;\n\n\tvar type = typeof(obj);\n\tif (type !== 'object' || obj instanceof Date || obj instanceof Error)\n\t\treturn obj;\n\n\tvar length;\n\tvar o;\n\n\tif (obj instanceof Array) {\n\n\t\tlength = obj.length;\n\t\to = new Array(length);\n\n\t\tfor (var i = 0; i < length; i++) {\n\t\t\ttype = typeof(obj[i]);\n\t\t\tif (type !== 'object' || obj[i] instanceof Date || obj[i] instanceof Error) {\n\t\t\t\tif (skipFunctions && type === 'function')\n\t\t\t\t\tcontinue;\n\t\t\t\to[i] = obj[i];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\to[i] = exports.clone(obj[i], skip, skipFunctions);\n\t\t}\n\n\t\treturn o;\n\t}\n\n\to = {};\n\n\tfor (var m in obj) {\n\n\t\tif (skip && skip[m])\n\t\t\tcontinue;\n\n\t\tvar val = obj[m];\n\n\t\tif (val instanceof Buffer) {\n\t\t\tvar copy = Buffer.alloc(val.length);\n\t\t\tval.copy(copy);\n\t\t\to[m] = copy;\n\t\t\tcontinue;\n\t\t}\n\n\t\tvar type = typeof(val);\n\t\tif (type !== 'object' || val instanceof Date || val instanceof Error) {\n\t\t\tif (skipFunctions && type === 'function')\n\t\t\t\tcontinue;\n\t\t\to[m] = val;\n\t\t\tcontinue;\n\t\t}\n\n\t\to[m] = exports.clone(obj[m], skip, skipFunctions);\n\t}\n\n\treturn o;\n};\n\n/**\n * Copy values from object to object\n * @param {Object} source Object source\n * @param {Object} target Object target (optional)\n * @return {Object} Modified object.\n */\nexports.copy = function(source, target) {\n\n\tif (target === undefined)\n\t\treturn exports.extend({}, source, true);\n\n\tif (!target || !source || typeof(target) !== 'object' || typeof(source) !== 'object')\n\t\treturn target;\n\n\tfor (var key in source) {\n\t\tif (target[key] !== undefined)\n\t\t\ttarget[key] = exports.clone(source[key]);\n\t}\n\n\treturn target;\n};\n\n/**\n * Reduces an object\n * @param {Object} source Source object.\n * @param {String Array or Object} prop Other properties than these ones will be removed.\n * @param {Boolean} reverse Reverse reducing (prop will be removed), default: false.\n * @return {Object}\n */\nexports.reduce = function(source, prop, reverse) {\n\n\tif (!(prop instanceof Array)) {\n\t\tif (typeof(prop) === 'object')\n\t\t\treturn exports.reduce(source, Object.keys(prop), reverse);\n\t}\n\n\tif (source instanceof Array) {\n\t\tvar arr = [];\n\t\tfor (var i = 0, length = source.length; i < length; i++)\n\t\t\tarr.push(exports.reduce(source[i], prop, reverse));\n\t\treturn arr;\n\t}\n\n\tvar output = {};\n\n\tfor (var o in source) {\n\t\tif (reverse) {\n\t\t\tif (prop.indexOf(o) === -1)\n\t\t\t\toutput[o] = source[o];\n\t\t} else {\n\t\t\tif (prop.indexOf(o) !== -1)\n\t\t\t\toutput[o] = source[o];\n\t\t}\n\t}\n\n\treturn output;\n};\n\n/**\n * Checks if is relative url\n * @param {String} url\n * @return {Boolean}\n */\nexports.isrelative = function(url) {\n\treturn !(url.substring(0, 2) === '//' || url.indexOf('http://') !== -1 || url.indexOf('https://') !== -1);\n};\n\n/**\n * Streamer method\n * @param {String/Buffer} beg\n * @param {String/Buffer} end\n * @param {Function(value, index)} callback\n */\nexports.streamer = function(beg, end, callback, skip, stream, raw) {\n\n\tif (typeof(end) === 'function') {\n\t\tstream = skip;\n\t\tskip = callback;\n\t\tcallback = end;\n\t\tend = undefined;\n\t}\n\n\tif (typeof(skip) === 'object') {\n\t\tstream = skip;\n\t\tskip = 0;\n\t}\n\n\tvar indexer = 0;\n\tvar buffer = Buffer.alloc(0);\n\tvar canceled = false;\n\tvar fn;\n\n\tif (skip === undefined)\n\t\tskip = 0;\n\n\tif (!(beg instanceof Buffer))\n\t\tbeg = Buffer.from(beg, 'utf8');\n\n\tif (end && !(end instanceof Buffer))\n\t\tend = Buffer.from(end, 'utf8');\n\n\tif (!end) {\n\t\tvar length = beg.length;\n\t\tfn = function(chunk) {\n\n\t\t\tif (!chunk || canceled)\n\t\t\t\treturn;\n\n\t\t\tCONCAT[0] = buffer;\n\t\t\tCONCAT[1] = chunk;\n\n\t\t\tvar f = 0;\n\n\t\t\tif (buffer.length) {\n\t\t\t\tf = buffer.length - beg.length;\n\t\t\t\tif (f < 0)\n\t\t\t\t\tf = 0;\n\t\t\t}\n\n\t\t\tbuffer = Buffer.concat(CONCAT);\n\n\t\t\tvar index = buffer.indexOf(beg, f);\n\t\t\tif (index === -1)\n\t\t\t\treturn;\n\n\t\t\twhile (index !== -1) {\n\n\t\t\t\tif (skip)\n\t\t\t\t\tskip--;\n\t\t\t\telse {\n\t\t\t\t\tif (callback(raw ? buffer.slice(0, index + length) : buffer.toString('utf8', 0, index + length), indexer++) === false)\n\t\t\t\t\t\tcanceled = true;\n\t\t\t\t}\n\n\t\t\t\tif (canceled)\n\t\t\t\t\treturn;\n\n\t\t\t\tbuffer = buffer.slice(index + length);\n\t\t\t\tindex = buffer.indexOf(beg);\n\t\t\t\tif (index === -1)\n\t\t\t\t\treturn;\n\t\t\t}\n\t\t};\n\n\t\tstream && stream.on('end', () => fn(beg));\n\t\treturn fn;\n\t}\n\n\tvar blength = beg.length;\n\tvar elength = end.length;\n\tvar bi = -1;\n\tvar ei = -1;\n\tvar is = false;\n\n\tfn = function(chunk) {\n\n\t\tif (!chunk || canceled)\n\t\t\treturn;\n\n\t\tCONCAT[0] = buffer;\n\t\tCONCAT[1] = chunk;\n\t\tbuffer = Buffer.concat(CONCAT);\n\n\t\tif (!is) {\n\t\t\tvar f = CONCAT[0].length - beg.length;\n\t\t\tif (f < 0)\n\t\t\t\tf = 0;\n\t\t\tbi = buffer.indexOf(beg, f);\n\t\t\tif (bi === -1)\n\t\t\t\treturn;\n\t\t\tis = true;\n\t\t}\n\n\t\tif (is) {\n\t\t\tei = buffer.indexOf(end, bi + blength);\n\t\t\tif (ei === -1)\n\t\t\t\treturn;\n\t\t}\n\n\t\twhile (bi !== -1) {\n\n\t\t\tif (skip)\n\t\t\t\tskip--;\n\t\t\telse {\n\t\t\t\tif (callback(raw ? buffer.slice(bi, ei + elength) : buffer.toString('utf8', bi, ei + elength), indexer++) === false)\n\t\t\t\t\tcanceled = true;\n\t\t\t}\n\n\t\t\tif (canceled)\n\t\t\t\treturn;\n\n\t\t\tbuffer = buffer.slice(ei + elength);\n\t\t\tis = false;\n\t\t\tbi = buffer.indexOf(beg);\n\t\t\tif (bi === -1)\n\t\t\t\treturn;\n\t\t\tis = true;\n\t\t\tei = buffer.indexOf(end, bi + blength);\n\t\t\tif (ei === -1)\n\t\t\t\treturn;\n\t\t}\n\t};\n\n\tstream && stream.on('end', () => fn(end));\n\treturn fn;\n};\n\nexports.streamer2 = function(beg, end, callback, skip, stream) {\n\treturn exports.streamer(beg, end, callback, skip, stream, true);\n};\n\n/**\n * HTML encode string\n * @param {String} str\n * @return {String}\n */\nexports.encode = function(str) {\n\n\tif (str == null)\n\t\treturn '';\n\n\tvar type = typeof(str);\n\tif (type !== 'string')\n\t\tstr = str.toString();\n\n\treturn str.encode();\n};\n\n/**\n * HTML decode string\n * @param {String} str\n * @return {String}\n */\nexports.decode = function(str) {\n\n\tif (str == null)\n\t\treturn '';\n\n\tvar type = typeof(str);\n\tif (type !== 'string')\n\t\tstr = str.toString();\n\n\treturn str.decode();\n};\n\n/**\n * Checks if URL contains file extension.\n * @param {String} url\n * @return {Boolean}\n */\nexports.isStaticFile = function(url) {\n\tvar index = url.indexOf('.', url.length - 8);\n\treturn index !== -1;\n};\n\n/**\n * Converts Value to number\n * @param {Object} obj Value to convert.\n * @param {Number} def Default value (default: 0).\n * @return {Number}\n */\nexports.parseInt = function(obj, def) {\n\tif (obj == null || obj === '')\n\t\treturn def === undefined ? 0 : def;\n\tvar type = typeof(obj);\n\treturn type === 'number' ? obj : (type !== 'string' ? obj.toString() : obj).parseInt(def);\n};\n\nexports.parseBoolean = function(obj, def) {\n\tif (obj == null)\n\t\treturn def === undefined ? false : def;\n\tvar type = typeof(obj);\n\treturn type === 'boolean' ? obj : type === 'number' ? obj > 0 : (type !== 'string' ? obj.toString() : obj).parseBoolean(def);\n};\n\n/**\n * Converts Value to float number\n * @param {Object} obj Value to convert.\n * @param {Number} def Default value (default: 0).\n * @return {Number}\n */\nexports.parseFloat = function(obj, def) {\n\tif (obj == null || obj === '')\n\t\treturn def === undefined ? 0 : def;\n\tvar type = typeof(obj);\n\treturn type === 'number' ? obj : (type !== 'string' ? obj.toString() : obj).parseFloat(def);\n};\n\n/**\n * Check if the object is Date\n * @param {Object} obj\n * @return {Boolean}\n */\nexports.isDate = function(obj) {\n\treturn obj instanceof Date && !isNaN(obj.getTime()) ? true : false;\n};\n\n/**\n * Get ContentType from file extension.\n * @param {String} ext File extension.\n * @return {String}\n */\nexports.getContentType = function(ext) {\n\tif (ext[0] === '.')\n\t\text = ext.substring(1);\n\treturn CONTENTTYPES[ext] || 'application/octet-stream';\n};\n\n/**\n * Get extension from filename\n * @param {String} filename\n * @return {String}\n */\nexports.getExtension = function(filename, raw) {\n\tvar end = filename.length;\n\tfor (var i = filename.length - 1; i > 0; i--) {\n\t\tvar c = filename[i];\n\t\tif (c === ' ' || c === '?')\n\t\t\tend = i;\n\t\telse if (c === '.') {\n\t\t\tc = filename.substring(i + 1, end);\n\t\t\treturn raw ? c : c.toLowerCase();\n\t\t}\n\t\telse if (c === '/' || c === '\\\\')\n\t\t\treturn '';\n\t}\n\treturn '';\n};\n\n/**\n * Get base name from path\n * @param {String} path\n * @return {String}\n */\nexports.getName = function(path) {\n\tvar l = path.length - 1;\n\tvar c = path[l];\n\tif (c === '/' || c === '\\\\')\n\t\tpath = path.substring(0, l);\n\tvar index = path.lastIndexOf('/');\n\tif (index !== -1)\n\t\treturn path.substring(index + 1);\n\tindex = path.lastIndexOf('\\\\');\n\treturn index === -1 ? path : path.substring(index + 1);\n};\n\n/**\n * Add a new content type to content types\n * @param {String} ext File extension.\n * @param {String} type Content type (example: application/json).\n */\nexports.setContentType = function(ext, type) {\n\tif (ext[0] === '.')\n\t\text = ext.substring(1);\n\n\tif (ext.length > 8) {\n\t\tvar tmp = regexpSTATIC.toString().replace(/,\\d+\\}/, ',' + ext.length + '}').substring(1);\n\t\tregexpSTATIC = new RegExp(tmp.substring(0, tmp.length - 1));\n\t}\n\n\tCONTENTTYPES[ext] = type;\n\treturn true;\n};\n\nexports.normalize = function(path) {\n\tif (path[0] !== '/')\n\t\tpath = '/' + path;\n\tif (path[path.length - 1] !== '/')\n\t\tpath += '/';\n\treturn path;\n};\n\nexports.link = function() {\n\tvar builder = '';\n\tfor (var i = 0; i < arguments.length; i++) {\n\n\t\tvar url = arguments[i];\n\t\tvar between = '';\n\n\t\tif (builder) {\n\t\t\tvar c = builder[builder.length - 1];\n\t\t\tif (c === '/') {\n\t\t\t\tif (url[0] === '/')\n\t\t\t\t\turl = url.substring(1);\n\t\t\t} else {\n\t\t\t\tif (url[0] !== '/')\n\t\t\t\t\tbetween = '/';\n\t\t\t}\n\t\t} else\n\t\t\tbetween = '';\n\n\t\tbuilder += between + url;\n\t}\n\treturn builder;\n};\n\nexports.path = function(path, delimiter) {\n\tif (!path)\n\t\tpath = '';\n\tdelimiter = delimiter || '/';\n\treturn path[path.length - 1] === delimiter ? path : path + delimiter;\n};\n\nexports.join = function() {\n\tvar path = [''];\n\n\tfor (var i = 0; i < arguments.length; i++) {\n\t\tvar current = arguments[i];\n\t\tif (current) {\n\t\t\tif (current[0] === '/')\n\t\t\t\tcurrent = current.substring(1);\n\t\t\tvar l = current.length - 1;\n\t\t\tif (current[l] === '/')\n\t\t\t\tcurrent = current.substring(0, l);\n\t\t\tpath.push(current);\n\t\t}\n\t}\n\n\tpath = path.join('/');\n\treturn !isWindows ? path : path.indexOf(':') > -1 ? path.substring(1) : path;\n};\n\n/**\n * Prepares Windows path to UNIX like format\n * @internal\n * @param {String} path\n * @return {String}\n */\nexports.$normalize = function(path) {\n\treturn isWindows ? path.replace(regexpPATH, '/') : path;\n};\n\nconst RANDOM_STRING = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split('');\nconst RANDOM_NUMBER = '0123456789';\n\nexports.random_string = function(max) {\n\tvar builder = '';\n\tfor (var i = 0; i < max; i++) {\n\t\tvar index = Math.floor(Math.random() * RANDOM_STRING.length);\n\t\tbuilder += RANDOM_STRING[index];\n\t}\n\treturn builder;\n};\n\nexports.random_number = function(max) {\n\tvar builder = '';\n\tfor (var i = 0; i < max; i++) {\n\t\tvar index = Math.floor(Math.random() * RANDOM_NUMBER.length);\n\t\tif (!i && !index)\n\t\t\tindex++;\n\t\tbuilder += RANDOM_NUMBER[index];\n\t}\n\treturn builder;\n};\n\nexports.random = function(max, min) {\n\tmax = (max || 100000);\n\tmin = (min || 0);\n\treturn Math.floor(Math.random() * (max - min + 1)) + min;\n};\n\nfunction rnd() {\n\treturn Math.floor(Math.random() * 65536).toString(36);\n}\n\nglobal.GUID = exports.GUID = function(max) {\n\tmax = max || 40;\n\tvar str = '';\n\tfor (var i = 0; i < (max / 3) + 1; i++)\n\t\tstr += rnd();\n\treturn str.substring(0, max);\n};\n\nfunction validate_builder_default(name, value, entity) {\n\n\tvar type = typeof(value);\n\n\tif (entity.type === 12)\n\t\treturn value != null && type === 'object' && !(value instanceof Array);\n\n\tif (entity.type === 11)\n\t\treturn type === 'number';\n\n\t// Enum + KeyValue + Custom (8+9+10)\n\tif (entity.type > 7)\n\t\treturn value !== undefined;\n\n\tswitch (entity.subtype) {\n\t\tcase 'uid':\n\t\t\treturn value.isUID();\n\t\tcase 'zip':\n\t\t\treturn value.isZIP();\n\t\tcase 'email':\n\t\t\treturn value.isEmail();\n\t\tcase 'json':\n\t\t\treturn value.isJSON();\n\t\tcase 'url':\n\t\t\treturn value.isURL();\n\t\tcase 'phone':\n\t\t\treturn value.isPhone();\n\t\tcase 'base64':\n\t\t\treturn value.isBase64(true);\n\t}\n\n\tif (type === 'number')\n\t\treturn value > 0;\n\n\tif (type === 'string' || value instanceof Array)\n\t\treturn value.length > 0;\n\n\tif (type === 'boolean')\n\t\treturn value === true;\n\n\tif (value == null)\n\t\treturn false;\n\n\tif (value instanceof Date)\n\t\treturn value.toString()[0] !== 'I'; // Invalid Date\n\n\treturn true;\n}\n\nexports.validate_builder = function(model, error, schema, path, index, $, pluspath) {\n\n\tvar current = path ? path + '.' : '';\n\tvar properties = $ ? ($.keys || schema.properties) : schema.properties;\n\tvar result;\n\n\tif (!pluspath)\n\t\tpluspath = '';\n\n\tif (model == null)\n\t\tmodel = {};\n\n\tfor (var i = 0; i < properties.length; i++) {\n\n\t\tvar name = properties[i];\n\t\tvar TYPE = schema.schema[name];\n\t\tif (!TYPE)\n\t\t\tcontinue;\n\n\t\tif (TYPE.can && !TYPE.can(model, model.$$workflow || EMPTYOBJECT))\n\t\t\tcontinue;\n\n\t\tvar value = model[name];\n\t\tvar type = typeof(value);\n\t\tvar prefix = schema.resourcePrefix ? (schema.resourcePrefix + name) : name;\n\n\t\tif (value === undefined) {\n\t\t\terror.push(pluspath + name, '@', current + name, undefined, prefix);\n\t\t\tcontinue;\n\t\t} else if (type === 'function')\n\t\t\tvalue = model[name]();\n\n\t\tif (TYPE.isArray) {\n\t\t\tif (TYPE.type === 7 && value instanceof Array && value.length) {\n\t\t\t\tvar nestedschema = GETSCHEMA(TYPE.raw);\n\t\t\t\tif (nestedschema) {\n\t\t\t\t\tfor (var j = 0, jl = value.length; j < jl; j++)\n\t\t\t\t\t\texports.validate_builder(value[j], error, nestedschema, current + name + '[' + j + ']', j, undefined, pluspath);\n\t\t\t\t} else\n\t\t\t\t\tthrow new Error('Nested schema \"{0}\" not found in \"{1}\".'.format(TYPE.raw, schema.parent.name));\n\t\t\t} else {\n\n\t\t\t\tif (!TYPE.required)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tresult = TYPE.validate ? TYPE.validate(value, model) : null;\n\t\t\t\tif (result == null) {\n\t\t\t\t\tresult = value instanceof Array ? value.length > 0 : false;\n\t\t\t\t\tif (result == null || result === true)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\ttype = typeof(result);\n\t\t\t\tif (type === 'string') {\n\t\t\t\t\tif (result[0] === '@')\n\t\t\t\t\t\terror.push(pluspath + name, TYPE.invalid, current + name, index, schema.resourcePrefix + result.substring(1));\n\t\t\t\t\telse\n\t\t\t\t\t\terror.push(pluspath + name, result, current + name, index, prefix);\n\t\t\t\t} else if (type === 'boolean')\n\t\t\t\t\t!result && error.push(pluspath + name, TYPE.invalid, current + name, index, prefix);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (TYPE.type === 7) {\n\n\t\t\tif (!value && !TYPE.required)\n\t\t\t\tcontinue;\n\n\t\t\t// Another schema\n\t\t\tresult = TYPE.validate ? TYPE.validate(value, model) : null;\n\n\t\t\tif (result == null) {\n\t\t\t\tvar nestedschema = GETSCHEMA(TYPE.raw);\n\t\t\t\tif (nestedschema)\n\t\t\t\t\texports.validate_builder(value, error, nestedschema, current + name, undefined, undefined, pluspath);\n\t\t\t\telse\n\t\t\t\t\tthrow new Error('Nested schema \"{0}\" not found in \"{1}\".'.format(TYPE.raw, schema.parent.name));\n\t\t\t} else {\n\t\t\t\ttype = typeof(result);\n\t\t\t\tif (type === 'string') {\n\t\t\t\t\tif (result[0] === '@')\n\t\t\t\t\t\terror.push(pluspath + name, TYPE.invalid, current + name, index, schema.resourcePrefix + result.substring(1));\n\t\t\t\t\telse\n\t\t\t\t\t\terror.push(pluspath + name, result, current + name, index, prefix);\n\t\t\t\t} else if (type === 'boolean')\n\t\t\t\t\t!result && error.push(pluspath + name, TYPE.invalid, current + name, index, prefix);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!TYPE.required)\n\t\t\tcontinue;\n\n\t\tresult = TYPE.validate ? TYPE.validate(value, model) : null;\n\t\tif (result == null) {\n\t\t\tresult = validate_builder_default(name, value, TYPE);\n\t\t\tif (result == null || result === true)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\ttype = typeof(result);\n\n\t\tif (type === 'string') {\n\t\t\tif (result[0] === '@')\n\t\t\t\terror.push(pluspath + name, TYPE.invalid, current + name, index, schema.resourcePrefix + result.substring(1));\n\t\t\telse\n\t\t\t\terror.push(pluspath + name, result, current + name, index, prefix);\n\t\t} else if (type === 'boolean')\n\t\t\t!result && error.push(pluspath + name, TYPE.invalid, current + name, index, prefix);\n\t}\n\n\treturn error;\n};\n\n/**\n * Combine paths\n * @return {String}\n */\nexports.combine = function() {\n\n\tvar p = F.directory;\n\n\tfor (var i = 0, length = arguments.length; i < length; i++) {\n\t\tvar v = arguments[i];\n\t\tif (!v)\n\t\t\tcontinue;\n\t\tif (v[0] === '/')\n\t\t\tv = v.substring(1);\n\n\t\tif (v[0] === '~')\n\t\t\tp = v.substring(1);\n\t\telse\n\t\t\tp += (p[p.length - 1] !== '/' ? '/' : '') + v;\n\t}\n\treturn exports.$normalize(p);\n};\n\n/**\n * Simple XML parser\n * @param {String} xml\n * @return {Object}\n */\nexports.parseXML = function(xml, replace) {\n\treturn xml.parseXML(replace);\n};\n\nfunction jsonparser(key, value) {\n\treturn typeof(value) === 'string' && value.isJSONDate() ? new Date(value) : value;\n}\n\n/**\n * Get WebSocket frame\n * @author Jozef Gula <gula.jozef@gmail.com>\n * @param {Number} code\n * @param {Buffer or String} message\n * @param {Hexa} type\n * @return {Buffer}\n */\nexports.getWebSocketFrame = function(code, message, type, compress, mask) {\n\n\tif (mask)\n\t\tmask = ((Math.random() * 214748364) >> 0) + 1;\n\n\tvar messageBuffer = getWebSocketFrameMessageBytes(code, message);\n\tvar lengthBuffer = getWebSocketFrameLengthBytes(messageBuffer.length);\n\tvar lengthMask = mask ? 4 : 0;\n\tvar frameBuffer = Buffer.alloc(1 + lengthBuffer.length + messageBuffer.length + lengthMask);\n\n\tframeBuffer[0] = 0x80 | type;\n\n\tif (compress)\n\t\tframeBuffer[0] |= 0x40;\n\n\tlengthBuffer.copy(frameBuffer, 1, 0, lengthBuffer.length);\n\n\tif (mask) {\n\t\tvar offset = lengthBuffer.length + 1;\n\t\tframeBuffer[1] |= 0x80;\n\t\tframeBuffer.writeInt32BE(mask, offset);\n\t\tfor (var i = 0; i < messageBuffer.length; i++)\n\t\t\tmessageBuffer[i] = messageBuffer[i] ^ frameBuffer[offset + (i % 4)];\n\t}\n\n\tmessageBuffer.copy(frameBuffer, lengthBuffer.length + 1 + lengthMask, 0, messageBuffer.length);\n\treturn frameBuffer;\n};\n\n/**\n * Get bytes of WebSocket frame message\n * @author Jozef Gula <gula.jozef@gmail.com>\n * @param  {Number} code\n * @param  {Buffer or String} message\n * @return {Buffer}\n */\nfunction getWebSocketFrameMessageBytes(code, message) {\n\n\tvar index = code ? 2 : 0;\n\tvar binary = message instanceof Int8Array || message instanceof Buffer;\n\tvar length = message.length;\n\n\tvar messageBuffer = Buffer.alloc(length + index);\n\n\tfor (var i = 0; i < length; i++) {\n\t\tif (binary)\n\t\t\tmessageBuffer[i + index] = message[i];\n\t\telse\n\t\t\tmessageBuffer[i + index] = message.charCodeAt(i);\n\t}\n\n\tif (code) {\n\t\tmessageBuffer[0] = code >> 8;\n\t\tmessageBuffer[1] = code;\n\t}\n\n\treturn messageBuffer;\n}\n\n/**\n * Get length of WebSocket frame\n * @author Jozef Gula <gula.jozef@gmail.com>\n * @param  {Number} length\n * @return {Number}\n */\nfunction getWebSocketFrameLengthBytes(length) {\n\tvar lengthBuffer = null;\n\n\tif (length <= 125) {\n\t\tlengthBuffer = Buffer.alloc(1);\n\t\tlengthBuffer[0] = length;\n\t\treturn lengthBuffer;\n\t}\n\n\tif (length <= 65535) {\n\t\tlengthBuffer = Buffer.alloc(3);\n\t\tlengthBuffer[0] = 126;\n\t\tlengthBuffer[1] = (length >> 8) & 255;\n\t\tlengthBuffer[2] = (length) & 255;\n\t\treturn lengthBuffer;\n\t}\n\n\tlengthBuffer = Buffer.alloc(9);\n\n\tlengthBuffer[0] = 127;\n\tlengthBuffer[1] = 0x00;\n\tlengthBuffer[2] = 0x00;\n\tlengthBuffer[3] = 0x00;\n\tlengthBuffer[4] = 0x00;\n\tlengthBuffer[5] = (length >> 24) & 255;\n\tlengthBuffer[6] = (length >> 16) & 255;\n\tlengthBuffer[7] = (length >> 8) & 255;\n\tlengthBuffer[8] = (length) & 255;\n\n\treturn lengthBuffer;\n}\n\n/**\n * GPS distance in KM\n * @param  {Number} lat1\n * @param  {Number} lon1\n * @param  {Number} lat2\n * @param  {Number} lon2\n * @return {Number}\n */\nexports.distance = function(lat1, lon1, lat2, lon2) {\n\tvar R = 6371;\n\tvar dLat = (lat2 - lat1).toRad();\n\tvar dLon = (lon2 - lon1).toRad();\n\tvar a = Math.sin(dLat / 2) * Math.sin(dLat / 2) + Math.cos(lat1.toRad()) * Math.cos(lat2.toRad()) * Math.sin(dLon / 2) * Math.sin(dLon / 2);\n\tvar c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n\treturn (R * c).floor(3);\n};\n\nfunction ls(path, callback, advanced, filter) {\n\tvar filelist = new FileList();\n\tvar tmp;\n\n\tfilelist.advanced = advanced;\n\tfilelist.onComplete = callback;\n\n\tif (typeof(filter) === 'string') {\n\t\ttmp = filter.toLowerCase();\n\t\tfilelist.onFilter = function(filename, is) {\n\t\t\treturn is ? true : filename.toLowerCase().indexOf(tmp) !== -1;\n\t\t};\n\t} else if (filter && filter.test) {\n\t\t// regexp\n\t\ttmp = filter;\n\t\tfilelist.onFilter = function(filename, is) {\n\t\t\treturn is ? true : tmp.test(filename);\n\t\t};\n\t} else\n\t\tfilelist.onFilter = filter || null;\n\n\tfilelist.walk(path);\n}\n\n/**\n * Directory listing\n * @param {String} path Path.\n * @param {Function(files, directories)} callback Callback\n * @param {Function(filename, isDirectory) or String or RegExp} filter Custom filter (optional).\n */\nexports.ls = function(path, callback, filter) {\n\tls(path, callback, false, filter);\n};\n\n/**\n * Advanced Directory listing\n * @param {String} path Path.\n * @param {Function(files, directories)} callback Callback\n * @param {Function(filename ,isDirectory) or String or RegExp} filter Custom filter (optional).\n */\nexports.ls2 = function(path, callback, filter) {\n\tls(path, callback, true, filter);\n};\n\nDP.setTimeZone = function(timezone) {\n\n\tvar dt = new Date(this.toLocaleString('en-US', { timeZone: timezone }));\n\n\tvar offset = dt + '';\n\tvar index = offset.indexOf('GMT');\n\tvar op = offset.substring(index + 3, index + 4);\n\tvar count = offset.substring(index + 4, index + 9);\n\tvar h = +count.substring(0, 2);\n\tvar m = +count.substring(2);\n\n\tif (op === '+') {\n\t\th && dt.setHours(dt.getHours() + h);\n\t\tm && dt.setMinutes(dt.getMinutes() + m);\n\t} else {\n\t\th && dt.setHours(dt.getHours() - h);\n\t\tm && dt.setMinutes(dt.getMinutes() - m);\n\t}\n\n\treturn dt;\n};\n\n/**\n * Date difference\n * @param  {Date/Number/String} date Optional.\n * @param  {String} type Date type: minutes, seconds, hours, days, months, years\n * @return {Number}\n */\nDP.diff = function(date, type) {\n\n\tif (arguments.length === 1) {\n\t\ttype = date;\n\t\tdate = Date.now();\n\t} else {\n\t\tvar to = typeof(date);\n\t\tif (to === 'string')\n\t\t\tdate = Date.parse(date);\n\t\telse if (exports.isDate(date))\n\t\t\tdate = date.getTime();\n\t}\n\n\tvar r = this.getTime() - date;\n\n\tswitch (type) {\n\t\tcase 's':\n\t\tcase 'ss':\n\t\tcase 'second':\n\t\tcase 'seconds':\n\t\t\treturn Math.ceil(r / 1000);\n\t\tcase 'm':\n\t\tcase 'mm':\n\t\tcase 'minute':\n\t\tcase 'minutes':\n\t\t\treturn Math.ceil((r / 1000) / 60);\n\t\tcase 'h':\n\t\tcase 'hh':\n\t\tcase 'hour':\n\t\tcase 'hours':\n\t\t\treturn Math.ceil(((r / 1000) / 60) / 60);\n\t\tcase 'd':\n\t\tcase 'dd':\n\t\tcase 'day':\n\t\tcase 'days':\n\t\t\treturn Math.ceil((((r / 1000) / 60) / 60) / 24);\n\t\tcase 'M':\n\t\tcase 'MM':\n\t\tcase 'month':\n\t\tcase 'months':\n\t\t\t// avg: 28 days per month\n\t\t\treturn Math.ceil((((r / 1000) / 60) / 60) / (24 * 28));\n\n\t\tcase 'y':\n\t\tcase 'yyyy':\n\t\tcase 'year':\n\t\tcase 'years':\n\t\t\t// avg: 28 days per month\n\t\t\treturn Math.ceil((((r / 1000) / 60) / 60) / (24 * 28 * 12));\n\t}\n\n\treturn NaN;\n};\n\nDP.add = function(type, value) {\n\n\tvar self = this;\n\n\tif (type.constructor === Number)\n\t\treturn new Date(self.getTime() + (type - type % 1));\n\n\tif (value === undefined) {\n\t\tvar arr = type.split(' ');\n\t\ttype = arr[1];\n\t\tvalue = exports.parseInt(arr[0]);\n\t}\n\n\tvar dt = new Date(self.getTime());\n\n\tswitch(type) {\n\t\tcase 's':\n\t\tcase 'ss':\n\t\tcase 'sec':\n\t\tcase 'second':\n\t\tcase 'seconds':\n\t\t\tdt.setUTCSeconds(dt.getUTCSeconds() + value);\n\t\t\treturn dt;\n\t\tcase 'm':\n\t\tcase 'mm':\n\t\tcase 'minute':\n\t\tcase 'min':\n\t\tcase 'minutes':\n\t\t\tdt.setUTCMinutes(dt.getUTCMinutes() + value);\n\t\t\treturn dt;\n\t\tcase 'h':\n\t\tcase 'hh':\n\t\tcase 'hour':\n\t\tcase 'hours':\n\t\t\tdt.setUTCHours(dt.getUTCHours() + value);\n\t\t\treturn dt;\n\t\tcase 'd':\n\t\tcase 'dd':\n\t\tcase 'day':\n\t\tcase 'days':\n\t\t\tdt.setUTCDate(dt.getUTCDate() + value);\n\t\t\treturn dt;\n\t\tcase 'w':\n\t\tcase 'ww':\n\t\tcase 'week':\n\t\tcase 'weeks':\n\t\t\tdt.setUTCDate(dt.getUTCDate() + (value * 7));\n\t\t\treturn dt;\n\t\tcase 'M':\n\t\tcase 'MM':\n\t\tcase 'month':\n\t\tcase 'months':\n\t\t\tdt.setUTCMonth(dt.getUTCMonth() + value);\n\t\t\treturn dt;\n\t\tcase 'y':\n\t\tcase 'yyyy':\n\t\tcase 'year':\n\t\tcase 'years':\n\t\t\tdt.setUTCFullYear(dt.getUTCFullYear() + value);\n\t\t\treturn dt;\n\t}\n\treturn dt;\n};\n\nDP.extend = function(date) {\n\tvar dt = new Date(this);\n\tvar match = date.match(regexpDATE);\n\n\tif (!match)\n\t\treturn dt;\n\n\tfor (var i = 0, length = match.length; i < length; i++) {\n\t\tvar m = match[i];\n\t\tvar arr, tmp;\n\n\t\tif (m.indexOf(':') !== -1) {\n\n\t\t\tarr = m.split(':');\n\t\t\ttmp = +arr[0];\n\t\t\ttmp >= 0 && dt.setUTCHours(tmp);\n\n\t\t\tif (arr[1]) {\n\t\t\t\ttmp = +arr[1];\n\t\t\t\ttmp >= 0 && dt.setUTCMinutes(tmp);\n\t\t\t}\n\n\t\t\tif (arr[2]) {\n\t\t\t\ttmp = +arr[2];\n\t\t\t\ttmp >= 0 && dt.setUTCSeconds(tmp);\n\t\t\t}\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (m.indexOf('-') !== -1) {\n\t\t\tarr = m.split('-');\n\n\t\t\ttmp = +arr[0];\n\t\t\ttmp && dt.setUTCFullYear(tmp);\n\n\t\t\tif (arr[1]) {\n\t\t\t\ttmp = +arr[1];\n\t\t\t\ttmp >= 0 && dt.setUTCMonth(tmp - 1);\n\t\t\t}\n\n\t\t\tif (arr[2]) {\n\t\t\t\ttmp = +arr[2];\n\t\t\t\ttmp >= 0 && dt.setUTCDate(tmp);\n\t\t\t}\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (m.indexOf('.') !== -1) {\n\t\t\tarr = m.split('.');\n\n\t\t\tif (arr[2]) {\n\t\t\t\ttmp = +arr[2];\n\t\t\t\t!isNaN(tmp) && dt.setUTCFullYear(tmp);\n\t\t\t}\n\n\t\t\tif (arr[1]) {\n\t\t\t\ttmp = +arr[1];\n\t\t\t\t!isNaN(tmp) && dt.setUTCMonth(tmp - 1);\n\t\t\t}\n\n\t\t\ttmp = +arr[0];\n\t\t\t!isNaN(tmp) && dt.setUTCDate(tmp);\n\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\treturn dt;\n};\n\n/**\n * Format datetime\n * @param {String} format\n * @return {String}\n */\nDP.format = function(format, resource) {\n\n\tif (!format)\n\t\treturn this.getUTCFullYear() + '-' + (this.getUTCMonth() + 1).toString().padLeft(2, '0') + '-' + this.getUTCDate().toString().padLeft(2, '0') + 'T' + this.getUTCHours().toString().padLeft(2, '0') + ':' + this.getUTCMinutes().toString().padLeft(2, '0') + ':' + this.getUTCSeconds().toString().padLeft(2, '0') + '.' + this.getUTCMilliseconds().toString().padLeft(3, '0') + 'Z';\n\n\tif (datetimeformat[format])\n\t\treturn datetimeformat[format](this, resource);\n\n\tvar key = format;\n\tvar half = false;\n\n\tif (format && format[0] === '!') {\n\t\thalf = true;\n\t\tformat = format.substring(1);\n\t}\n\n\tvar beg = '\\'+';\n\tvar end = '+\\'';\n\tvar before = [];\n\n\tvar ismm = false;\n\tvar isdd = false;\n\tvar isww = false;\n\n\tformat = format.replace(regexpDATEFORMAT, function(key) {\n\t\tswitch (key) {\n\t\t\tcase 'yyyy':\n\t\t\tcase 'YYYY':\n\t\t\t\treturn beg + 'd.getFullYear()' + end;\n\t\t\tcase 'yy':\n\t\t\tcase 'YY':\n\t\t\t\treturn beg + 'd.getFullYear().toString().substring(2)' + end;\n\t\t\tcase 'MMM':\n\t\t\t\tismm = true;\n\t\t\t\treturn beg + '(RESOURCE(resource, mm) || mm).substring(0, 3)' + end;\n\t\t\tcase 'MMMM':\n\t\t\t\tismm = true;\n\t\t\t\treturn beg + '(RESOURCE(resource, mm) || mm)' + end;\n\t\t\tcase 'MM':\n\t\t\t\treturn beg + '(d.getMonth() + 1).toString().padLeft(2, \\'0\\')' + end;\n\t\t\tcase 'M':\n\t\t\t\treturn beg + '(d.getMonth() + 1)' + end;\n\t\t\tcase 'ddd':\n\t\t\tcase 'DDD':\n\t\t\t\tisdd = true;\n\t\t\t\treturn beg + '(RESOURCE(resource, dd) || dd).substring(0, 2).toUpperCase()' + end;\n\t\t\tcase 'dddd':\n\t\t\tcase 'DDDD':\n\t\t\t\tisdd = true;\n\t\t\t\treturn beg + '(RESOURCE(resource, dd) || dd)' + end;\n\t\t\tcase 'dd':\n\t\t\tcase 'DD':\n\t\t\t\treturn beg + 'd.getDate().toString().padLeft(2, \\'0\\')' + end;\n\t\t\tcase 'd':\n\t\t\tcase 'D':\n\t\t\t\treturn beg + 'd.getDate()' + end;\n\t\t\tcase 'HH':\n\t\t\tcase 'hh':\n\t\t\t\treturn beg + (half ? 'framework_utils.$pmam(d.getHours()).toString().padLeft(2, \\'0\\')' : 'd.getHours().toString().padLeft(2, \\'0\\')') + end;\n\t\t\tcase 'H':\n\t\t\tcase 'h':\n\t\t\t\treturn beg + (half ? 'framework_utils(d.getHours())' : 'd.getHours()') + end;\n\t\t\tcase 'mm':\n\t\t\t\treturn beg + 'd.getMinutes().toString().padLeft(2, \\'0\\')' + end;\n\t\t\tcase 'm':\n\t\t\t\treturn beg + 'd.getMinutes()' + end;\n\t\t\tcase 'ss':\n\t\t\t\treturn beg + 'd.getSeconds().toString().padLeft(2, \\'0\\')' + end;\n\t\t\tcase 's':\n\t\t\t\treturn beg + 'd.getSeconds()' + end;\n\t\t\tcase 'w':\n\t\t\tcase 'ww':\n\t\t\t\tisww = true;\n\t\t\t\treturn beg + (key === 'ww' ? 'ww.toString().padLeft(2, \\'0\\')' : 'ww') + end;\n\t\t\tcase 'a':\n\t\t\t\tvar b = \"'PM':'AM'\";\n\t\t\t\treturn beg + '(d.getHours() >= 12 ? ' + b + ')' + end;\n\t\t}\n\t});\n\n\tismm && before.push('var mm = framework_utils.MONTHS[d.getMonth()];');\n\tisdd && before.push('var dd = framework_utils.DAYS[d.getDay()];');\n\tisww && before.push('var ww = new Date(+d);ww.setHours(0, 0, 0);ww.setDate(ww.getDate() + 4 - (ww.getDay() || 7));ww = Math.ceil((((ww - new Date(ww.getFullYear(), 0, 1)) / 8.64e7) + 1) / 7);');\n\n\tdatetimeformat[key] = new Function('d', 'resource', before.join('\\n') + 'return \\'' + format + '\\';');\n\treturn datetimeformat[key](this, resource);\n};\n\nexports.$pmam = function(value) {\n\treturn value >= 12 ? value - 12 : value;\n};\n\nDP.toUTC = function(ticks) {\n\tvar dt = this.getTime() + this.getTimezoneOffset() * 60000;\n\treturn ticks ? dt : new Date(dt);\n};\n\n// +v2.2.0 parses JSON dates as dates and this is the fallback for backward compatibility\nDP.parseDate = function() {\n\treturn this;\n};\n\nSP.isJSONDate = function() {\n\tvar l = this.length - 1;\n\treturn l > 22 && l < 30 && this[l] === 'Z' && this[10] === 'T' && this[4] === '-' && this[13] === ':' && this[16] === ':';\n};\n\nSP.ROOT = function(noremap) {\n\n\tvar str = this;\n\n\tstr = str.replace(REG_NOREMAP, function() {\n\t\tnoremap = true;\n\t\treturn '';\n\t}).replace(REG_ROOT, $urlmaker);\n\n\tif (!noremap && CONF.default_root)\n\t\tstr = str.replace(REG_REMAP, $urlremap).replace(REG_AJAX, $urlajax);\n\n\treturn str;\n};\n\nfunction $urlremap(text) {\n\tvar pos = text[0] === 'h' ? 6 : 5;\n\treturn REG_URLEXT.test(text) ? text : ((text[0] === 'h' ? 'href' : 'src') + '=\"' + CONF.default_root + (text[pos] === '/' ? text.substring(pos + 1) : text));\n}\n\nfunction $urlajax(text) {\n\treturn text.substring(0, text.length - 1) + CONF.default_root;\n}\n\nfunction $urlmaker(text) {\n\tvar c = text[4];\n\treturn CONF.default_root ? CONF.default_root : (c || '');\n}\n\nif (!SP.trim) {\n\tSP.trim = function() {\n\t\treturn this.replace(regexpTRIM, '');\n\t};\n}\n\n/**\n * Checks if the string starts with the text\n * @see {@link http://docs.totaljs.com/SP/#SP.startsWith|Documentation}\n * @param {String} text Text to find.\n * @param {Boolean/Number} ignoreCase Ingore case sensitive or position in the string.\n * @return {Boolean}\n */\nSP.startsWith = function(text, ignoreCase) {\n\tvar self = this;\n\tvar length = text.length;\n\tvar tmp;\n\n\tif (ignoreCase === true) {\n\t\ttmp = self.substring(0, length);\n\t\treturn tmp.length === length && tmp.toLowerCase() === text.toLowerCase();\n\t}\n\n\tif (ignoreCase)\n\t\ttmp = self.substr(ignoreCase, length);\n\telse\n\t\ttmp = self.substring(0, length);\n\n\treturn tmp.length === length && tmp === text;\n};\n\n/**\n * Checks if the string ends with the text\n * @see {@link http://docs.totaljs.com/SP/#SP.endsWith|Documentation}\n * @param {String} text Text to find.\n * @param {Boolean/Number} ignoreCase Ingore case sensitive or position in the string.\n * @return {Boolean}\n */\nSP.endsWith = function(text, ignoreCase) {\n\tvar self = this;\n\tvar length = text.length;\n\tvar tmp;\n\n\tif (ignoreCase === true) {\n\t\ttmp = self.substring(self.length - length);\n\t\treturn tmp.length === length && tmp.toLowerCase() === text.toLowerCase();\n\t}\n\n\tif (ignoreCase)\n\t\ttmp = self.substr((self.length - ignoreCase) - length, length);\n\telse\n\t\ttmp = self.substring(self.length - length);\n\n\treturn tmp.length === length && tmp === text;\n};\n\nSP.replacer = function(find, text) {\n\tvar self = this;\n\tvar beg = self.indexOf(find);\n\treturn beg === -1 ? self : (self.substring(0, beg) + text + self.substring(beg + find.length));\n};\n\n/**\n * Hash string\n * @param {String} type Hash type.\n * @param {String} salt Optional, salt.\n * @return {String}\n */\nSP.hash = function(type, salt) {\n\tvar str = salt ? this + salt : this;\n\tswitch (type) {\n\t\tcase 'md5':\n\t\t\treturn str.md5();\n\t\tcase 'sha1':\n\t\t\treturn str.sha1();\n\t\tcase 'sha256':\n\t\t\treturn str.sha256();\n\t\tcase 'sha512':\n\t\t\treturn str.sha512();\n\t\tcase 'crc32':\n\t\t\treturn str.crc32();\n\t\tcase 'crc32unsigned':\n\t\t\treturn str.crc32(true);\n\t\tdefault:\n\t\t\tvar val = string_hash(str);\n\t\t\treturn type === true ? val >>> 0 : val;\n\t}\n};\n\nglobal.HASH = function(value, type) {\n\treturn value.hash(type ? type : true);\n};\n\nSP.makeid = function() {\n\treturn this.hash(true).toString(36);\n};\n\nSP.crc32 = function(unsigned) {\n\tvar crc = -1;\n\tfor (var i = 0, length = this.length; i < length; i++)\n\t\tcrc = (crc >>> 8) ^ CRC32TABLE[(crc ^ this.charCodeAt(i)) & 0xFF];\n\tvar val = crc ^ (-1);\n\treturn unsigned ? val >>> 0 : val;\n};\n\nfunction string_hash(s, convert) {\n\tvar hash = 0;\n\tif (s.length === 0)\n\t\treturn convert ? '' : hash;\n\tfor (var i = 0, l = s.length; i < l; i++) {\n\t\tvar char = s.charCodeAt(i);\n\t\thash = ((hash << 5) - hash) + char;\n\t\thash |= 0;\n\t}\n\treturn hash;\n}\n\nSP.count = function(text) {\n\tvar index = 0;\n\tvar count = 0;\n\tdo {\n\t\tindex = this.indexOf(text, index + text.length);\n\t\tif (index > 0)\n\t\t\tcount++;\n\t} while (index > 0);\n\treturn count;\n};\n\nSP.parseComponent = function(tags) {\n\n\tvar html = this;\n\tvar beg = -1;\n\tvar end = -1;\n\tvar output = {};\n\n\tfor (var key in tags) {\n\n\t\tvar tagbeg = tags[key];\n\t\tvar tagindex = tagbeg.indexOf(' ');\n\n\t\tif (tagindex === -1)\n\t\t\ttagindex = tagbeg.length - 1;\n\n\t\tvar tagend = '</' + tagbeg.substring(1, tagindex) + '>';\n\t\tvar tagbeg2 = '<' + tagend.substring(2);\n\n\t\tbeg = html.indexOf(tagbeg);\n\n\t\tif (beg !== -1) {\n\n\t\t\tvar count = 0;\n\t\t\tend = -1;\n\n\t\t\tfor (var j = (beg + tagbeg.length); j < html.length; j++) {\n\t\t\t\tvar a = html.substring(j, j + tagbeg2.length);\n\t\t\t\tif (a === tagbeg2) {\n\t\t\t\t\tcount++;\n\t\t\t\t} else {\n\t\t\t\t\tif (html.substring(j, j + tagend.length) === tagend) {\n\t\t\t\t\t\tif (count) {\n\t\t\t\t\t\t\tcount--;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tend = j;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (end !== -1) {\n\t\t\t\tvar tmp = html.substring(html.indexOf('>', beg) + 1, end);\n\t\t\t\thtml = html.replace(html.substring(beg, end + tagend.length), '').trim();\n\t\t\t\toutput[key] = tmp.trim();\n\t\t\t}\n\n\t\t}\n\t}\n\n\treturn output;\n};\n\nSP.parseXML = function(replace) {\n\n\tvar xml = this;\n\tvar beg = -1;\n\tvar end = 0;\n\tvar tmp = 0;\n\tvar current = [];\n\tvar obj = {};\n\tvar from = -1;\n\n\twhile (true) {\n\t\tbeg = xml.indexOf('<![CDATA[', beg);\n\t\tif (beg === -1)\n\t\t\tbreak;\n\t\tend = xml.indexOf(']]>', beg + 9);\n\t\txml = xml.substring(0, beg) + xml.substring(beg + 9, end).trim().encode() + xml.substring(end + 3);\n\t\tbeg += 9;\n\t}\n\n\tbeg = -1;\n\tend = 0;\n\n\twhile (true) {\n\n\t\tbeg = xml.indexOf('<', beg + 1);\n\t\tif (beg === -1)\n\t\t\tbreak;\n\n\t\tend = xml.indexOf('>', beg + 1);\n\t\tif (end === -1)\n\t\t\tbreak;\n\n\t\tvar el = xml.substring(beg, end + 1);\n\t\tvar c = el[1];\n\n\t\tif (el.substring(0, 4) === '<!--') {\n\t\t\tbeg = end + 3;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (c === '?' || c === '/') {\n\n\t\t\tvar o = current.pop();\n\n\t\t\tif (from === -1 || o !== el.substring(2, el.length - 1))\n\t\t\t\tcontinue;\n\n\t\t\tvar path = (current.length ? current.join('.') + '.' : '') + o;\n\t\t\tvar value = xml.substring(from, beg).decode();\n\n\t\t\tif (replace)\n\t\t\t\tpath = path.replace(REG_XMLKEY, '_');\n\n\t\t\tif (obj[path] === undefined)\n\t\t\t\tobj[path] = value;\n\t\t\telse if (obj[path] instanceof Array)\n\t\t\t\tobj[path].push(value);\n\t\t\telse\n\t\t\t\tobj[path] = [obj[path], value];\n\n\t\t\tfrom = -1;\n\t\t\tcontinue;\n\t\t}\n\n\t\ttmp = el.indexOf(' ');\n\t\tvar hasAttributes = true;\n\n\t\tif (tmp === -1) {\n\t\t\ttmp = el.length - 1;\n\t\t\thasAttributes = false;\n\t\t}\n\n\t\tfrom = beg + el.length;\n\n\t\tvar isSingle = el[el.length - 2] === '/';\n\t\tvar name = el.substring(1, tmp);\n\n\t\tif (!isSingle)\n\t\t\tcurrent.push(name);\n\n\t\tif (!hasAttributes)\n\t\t\tcontinue;\n\n\t\tvar match = el.match(regexpXML);\n\t\tif (!match)\n\t\t\tcontinue;\n\n\t\tvar attr = {};\n\t\tvar length = match.length;\n\n\t\tfor (var i = 0; i < length; i++) {\n\t\t\tvar index = match[i].indexOf('\"');\n\t\t\tattr[match[i].substring(0, index - 1)] = match[i].substring(index + 1, match[i].length - 1).decode();\n\t\t}\n\n\t\tvar k = current.join('.') + (isSingle ? '.' + name : '') + '[]';\n\t\tif (replace)\n\t\t\tk = k.replace(REG_XMLKEY, '_');\n\t\tobj[k] = attr;\n\t}\n\n\treturn obj;\n};\n\nSP.parseJSON = function(date) {\n\ttry {\n\t\treturn JSON.parse(this, date ? jsonparser : undefined);\n\t} catch (e) {}\n};\n\nfunction parseQueryArgumentsDecode(val) {\n\ttry {\n\t\treturn decodeURIComponent(val);\n\t} catch (e) {\n\t\treturn '';\n\t}\n}\n\nconst QUERY_ALLOWED = { '45': 1, '95': 1, 46: 1, '91': 1, '93': 1 };\n\nSP.parseEncoded = function() {\n\n\tvar str = this + '&';\n\tvar obj = {};\n\tvar key = '';\n\tvar val = '';\n\tvar is = false;\n\tvar decodev = false;\n\tvar decodek = false;\n\tvar count = 0;\n\tvar pos = 0;\n\n\tfor (var i = 0; i < str.length; i++) {\n\t\tvar n = str.charCodeAt(i);\n\n\t\tif (n === 38) {\n\n\t\t\tif (key) {\n\t\t\t\tif (pos < i)\n\t\t\t\t\tval += str.substring(pos, i);\n\n\t\t\t\tif (decodev)\n\t\t\t\t\tval = parseQueryArgumentsDecode(val);\n\n\t\t\t\tif (decodek)\n\t\t\t\t\tkey = parseQueryArgumentsDecode(key);\n\n\t\t\t\tobj[key] = val;\n\t\t\t}\n\n\t\t\tif (key)\n\t\t\t\tkey = '';\n\n\t\t\tif (val)\n\t\t\t\tval = '';\n\n\t\t\tpos = i + 1;\n\t\t\tis = false;\n\t\t\tdecodek = false;\n\t\t\tdecodev = false;\n\n\t\t\tif ((count++) >= CONF.default_request_maxkeys)\n\t\t\t\tbreak;\n\n\t\t} else {\n\n\t\t\tif (n === 61) {\n\t\t\t\tif ((i - pos) > CONF.default_request_maxkey)\n\t\t\t\t\tkey = '';\n\t\t\t\telse {\n\t\t\t\t\tif (pos < i)\n\t\t\t\t\t\tkey += str.substring(pos, i);\n\t\t\t\t\tpos = i + 1;\n\t\t\t\t\tis = true;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!is) {\n\t\t\t\tvar can = false;\n\t\t\t\tif (n > 47 && n < 58)\n\t\t\t\t\tcan = true;\n\t\t\t\telse if ((n > 64 && n < 91) || (n > 96 && n < 123))\n\t\t\t\t\tcan = true;\n\t\t\t\telse if (QUERY_ALLOWED[n])\n\t\t\t\t\tcan = true;\n\t\t\t\tif (!can)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (n === 43) {\n\t\t\t\tif (is)\n\t\t\t\t\tval += str.substring(pos, i) + ' ';\n\t\t\t\telse\n\t\t\t\t\tkey += str.substring(pos, i) + ' ';\n\t\t\t\tpos = i + 1;\n\t\t\t}\n\n\t\t\tif (n === 37) {\n\t\t\t\tif (str.charCodeAt(i + 1) === 48 && str.charCodeAt(i + 2) === 48)\n\t\t\t\t\tpos = i + 3;\n\t\t\t\telse if (is) {\n\t\t\t\t\tif (!decodev)\n\t\t\t\t\t\tdecodev = true;\n\t\t\t\t} else {\n\t\t\t\t\tif (!decodev)\n\t\t\t\t\t\tdecodek = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn obj;\n};\n\nSP.parseUA = function(structured) {\n\n\tvar ua = this;\n\n\tif (!ua)\n\t\treturn '';\n\n\tvar arr = ua.match(regexpUA);\n\tvar uid = '';\n\n\tif (arr) {\n\n\t\tvar data = {};\n\n\t\tfor (var i = 0; i < arr.length; i++) {\n\n\t\t\tif (arr[i] === 'like' && arr[i + 1] === 'Gecko') {\n\t\t\t\ti += 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tvar key = arr[i].toLowerCase();\n\t\t\tif (key === 'like')\n\t\t\t\tbreak;\n\n\t\t\tswitch (key) {\n\t\t\t\tcase 'linux':\n\t\t\t\tcase 'windows':\n\t\t\t\tcase 'mac':\n\t\t\t\tcase 'symbian':\n\t\t\t\tcase 'symbos':\n\t\t\t\tcase 'tizen':\n\t\t\t\tcase 'android':\n\t\t\t\t\tdata[arr[i]] = 2;\n\t\t\t\t\tif (key === 'tizen' || key === 'android')\n\t\t\t\t\t\tdata.Mobile = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'webos':\n\t\t\t\t\tdata.WebOS = 2;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'media':\n\t\t\t\tcase 'center':\n\t\t\t\tcase 'tv':\n\t\t\t\tcase 'smarttv':\n\t\t\t\tcase 'smart':\n\t\t\t\t\tdata[arr[i]] = 5;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'iemobile':\n\t\t\t\tcase 'mobile':\n\t\t\t\t\tdata[arr[i]] = 1;\n\t\t\t\t\tdata.Mobile = 3;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'ipad':\n\t\t\t\tcase 'ipod':\n\t\t\t\tcase 'iphone':\n\t\t\t\t\tdata.iOS = 2;\n\t\t\t\t\tdata.Mobile = 3;\n\t\t\t\t\tdata[arr[i]] = 1;\n\t\t\t\t\tif (key === 'ipad')\n\t\t\t\t\t\tdata.Tablet = 4;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'phone':\n\t\t\t\t\tdata.Mobile = 3;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'tizenbrowser':\n\t\t\t\tcase 'blackberry':\n\t\t\t\tcase 'mini':\n\t\t\t\t\tdata.Mobile = 3;\n\t\t\t\t\tdata[arr[i]] = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'samsungbrowser':\n\t\t\t\tcase 'chrome':\n\t\t\t\tcase 'firefox':\n\t\t\t\tcase 'msie':\n\t\t\t\tcase 'opera':\n\t\t\t\tcase 'brave':\n\t\t\t\tcase 'vivaldi':\n\t\t\t\tcase 'outlook':\n\t\t\t\tcase 'safari':\n\t\t\t\tcase 'mail':\n\t\t\t\tcase 'edge':\n\t\t\t\tcase 'maxthon':\n\t\t\t\tcase 'electron':\n\t\t\t\t\tdata[arr[i]] = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'trident':\n\t\t\t\t\tdata.MSIE = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'opr':\n\t\t\t\t\tdata.Opera = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'tablet':\n\t\t\t\t\tdata.Tablet = 4;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (data.MSIE) {\n\t\t\tdata.IE = 1;\n\t\t\tdelete data.MSIE;\n\t\t}\n\n\t\tif (data.WebOS || data.Android)\n\t\t\tdelete data.Linux;\n\n\t\tif (data.IEMobile) {\n\t\t\tif (data.Android)\n\t\t\t\tdelete data.Android;\n\t\t\tif (data.Safari)\n\t\t\t\tdelete data.Safari;\n\t\t\tif (data.Chrome)\n\t\t\t\tdelete data.Chrome;\n\t\t} else if (data.MSIE) {\n\t\t\tif (data.Chrome)\n\t\t\t\tdelete data.Chrome;\n\t\t\tif (data.Safari)\n\t\t\t\tdelete data.Safari;\n\t\t} else if (data.Edge) {\n\t\t\tif (data.Chrome)\n\t\t\t\tdelete data.Chrome;\n\t\t\tif (data.Safari)\n\t\t\t\tdelete data.Safari;\n\t\t} else if (data.Opera || data.Electron) {\n\t\t\tif (data.Chrome)\n\t\t\t\tdelete data.Chrome;\n\t\t\tif (data.Safari)\n\t\t\t\tdelete data.Safari;\n\t\t} else if (data.Chrome) {\n\t\t\tif (data.Safari)\n\t\t\t\tdelete data.Safari;\n\t\t\tif (data.SamsungBrowser)\n\t\t\t\tdelete data.SamsungBrowser;\n\t\t} else if (data.SamsungBrowser) {\n\t\t\tif (data.Safari)\n\t\t\t\tdelete data.Safari;\n\t\t}\n\n\t\tif (structured) {\n\t\t\tvar output = { os: '', browser: '', device: 'desktop' };\n\n\t\t\tif (data.Tablet)\n\t\t\t\toutput.device = 'tablet';\n\t\t\telse if (data.Mobile)\n\t\t\t\toutput.device = 'mobile';\n\n\t\t\tfor (var key in data) {\n\t\t\t\tvar val = data[key];\n\t\t\t\tswitch (val) {\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\toutput.browser += (output.browser ? ' ' : '') + key;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\toutput.os += (output.os ? ' ' : '') + key;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 5:\n\t\t\t\t\t\toutput.device = 'tv';\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn output;\n\t\t}\n\n\t\tuid = Object.keys(data).join(' ');\n\t}\n\n\treturn uid;\n};\n\nSP.parseCSV = function(delimiter) {\n\n\tif (!delimiter)\n\t\tdelimiter = ',';\n\n\tvar delimiterstring = '\"';\n\tvar t = this;\n\tvar scope;\n\tvar tmp = {};\n\tvar index = 1;\n\tvar data = [];\n\tvar current = 'a';\n\n\tfor (var i = 0; i < t.length; i++) {\n\t\tvar c = t[i];\n\n\t\tif (!scope) {\n\n\t\t\tif (c === '\\n' || c === '\\r') {\n\t\t\t\ttmp && data.push(tmp);\n\t\t\t\tindex = 1;\n\t\t\t\tcurrent = 'a';\n\t\t\t\ttmp = null;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (c === delimiter) {\n\t\t\t\tcurrent = String.fromCharCode(97 + index);\n\t\t\t\tindex++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (c === delimiterstring) {\n\t\t\t// Check escaped quotes\n\t\t\tif (scope && t[i + 1] === delimiterstring) {\n\t\t\t\ti++;\n\t\t\t} else {\n\t\t\t\tscope = c === scope ? '' : c;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (!tmp)\n\t\t\ttmp = {};\n\n\t\tif (tmp[current])\n\t\t\ttmp[current] += c;\n\t\telse\n\t\t\ttmp[current] = c;\n\t}\n\n\ttmp && data.push(tmp);\n\treturn data;\n};\n\nSP.parseTerminal = function(fields, fn, skip, take) {\n\n\tvar lines = this.split('\\n');\n\n\tif (typeof(fields) === 'function') {\n\t\ttake = skip;\n\t\tskip = fn;\n\t\tfn = fields;\n\t\tparseTerminal2(lines, fn, skip, take);\n\t\treturn this;\n\t}\n\n\tif (skip === undefined)\n\t\tskip = 0;\n\tif (take === undefined)\n\t\ttake = lines.length;\n\n\tvar headers = [];\n\tvar indexer = 0;\n\tvar line = lines[0];\n\n\tif (!line) {\n\t\tline = lines[1];\n\t\tskip++;\n\t}\n\n\tif (!line) {\n\t\tline = lines[2];\n\t\tskip++;\n\t}\n\n\tif (!line)\n\t\treturn this;\n\n\tvar fieldslength = fields.length;\n\tvar tmp;\n\n\tfor (var i = 0, length = fieldslength; i < length; i++) {\n\t\tvar field = fields[i];\n\n\t\tvar beg = -1;\n\t\tvar end = -1;\n\t\tvar type = typeof(field);\n\n\t\tif (type === 'object' && field.test) {\n\t\t\ttmp = line.match(field);\n\t\t\tif (tmp) {\n\t\t\t\tbeg = tmp.index;\n\t\t\t\tend = beg + tmp.toString().length;\n\t\t\t} else {\n\t\t\t\tbeg = -1;\n\t\t\t\tend = -1;\n\t\t\t}\n\t\t} else if (type === 'string') {\n\t\t\ttmp = line.indexOf(field);\n\t\t\tif (tmp === -1) {\n\t\t\t\tbeg = -1;\n\t\t\t\tend = -1;\n\t\t\t} else {\n\t\t\t\tbeg = tmp;\n\t\t\t\tend = line.indexOf(' ', beg + field.length);\n\t\t\t}\n\t\t}\n\n\t\theaders.push({ beg: beg, end: end });\n\t}\n\n\tfor (var i = skip + 1, length = skip + 1 + take; i < length; i++) {\n\n\t\tvar line = lines[i];\n\t\tif (!line)\n\t\t\tcontinue;\n\n\t\tvar arr = [];\n\t\tvar is = false;\n\t\tvar beg;\n\n\t\tfor (var j = 0; j < fieldslength; j++) {\n\t\t\tvar header = headers[j];\n\t\t\tif (header.beg !== -1) {\n\t\t\t\tis = true;\n\t\t\t\tbeg = 0;\n\n\t\t\t\tfor (var k = header.beg; k > -1; k--) {\n\t\t\t\t\tif (line[k] === ' ') {\n\t\t\t\t\t\tbeg = k + 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tarr.push(line.substring(beg, header.end === -1 ? undefined : header.end).trim());\n\t\t\t} else\n\t\t\t\tarr.push('');\n\t\t}\n\n\t\tis && fn(arr, indexer++, length, i);\n\t}\n\n\treturn this;\n};\n\nfunction parseTerminal2(lines, fn, skip, take) {\n\tvar indexer = 0;\n\n\tif (skip === undefined)\n\t\tskip = 0;\n\tif (take === undefined)\n\t\ttake = lines.length;\n\n\tfor (var i = skip, length = skip + take; i < length; i++) {\n\t\tvar line = lines[i];\n\t\tif (!line)\n\t\t\tcontinue;\n\t\tvar m = line.match(regexpTERMINAL);\n\t\tm && fn(m, indexer++, length, i);\n\t}\n}\n\nfunction parseDateFormat(format, val) {\n\n\tvar tmp = [];\n\tvar tmpformat = [];\n\tvar prev = '';\n\tvar prevformat = '';\n\tvar allowed = { y: 1, Y: 1, M: 1, m: 1, d: 1, D: 1, H: 1, s: 1, a: 1, w: 1 };\n\n\tfor (var i = 0; i < format.length; i++) {\n\n\t\tvar c = format[i];\n\n\t\tif (!allowed[c])\n\t\t\tcontinue;\n\n\t\tif (prev !== c) {\n\t\t\tprevformat && tmpformat.push(prevformat);\n\t\t\tprevformat = c;\n\t\t\tprev = c;\n\t\t} else\n\t\t\tprevformat += c;\n\t}\n\n\tprev = '';\n\n\tfor (var i = 0; i < val.length; i++) {\n\t\tvar code = val.charCodeAt(i);\n\t\tif (code >= 48 && code <= 57)\n\t\t\tprev += val[i];\n\t}\n\n\tprevformat && tmpformat.push(prevformat);\n\n\tvar f = 0;\n\tfor (var i = 0; i < tmpformat.length; i++) {\n\t\tvar l = tmpformat[i].length;\n\t\ttmp.push(prev.substring(f, f + l));\n\t\tf += l;\n\t}\n\n\tvar dt = {};\n\n\tfor (var i = 0; i < tmpformat.length; i++) {\n\t\tvar type = tmpformat[i];\n\t\tif (tmp[i])\n\t\t\tdt[type[0]] = +tmp[i];\n\t}\n\n\tvar h = dt.h || dt.H;\n\n\tif (h != null) {\n\t\tvar ampm = val.match(REG_TIME);\n\t\tif (ampm && ampm[0].toLowerCase() === 'pm')\n\t\t\th += 12;\n\t}\n\n\treturn new Date((dt.y || dt.Y) || 0, (dt.M || 1) - 1, dt.d || dt.D || 0, h || 0, dt.m || 0, dt.s || 0);\n}\n\nSP.parseDate = function(format) {\n\n\tif (format)\n\t\treturn parseDateFormat(format, this);\n\n\tvar self = this.trim();\n\tvar lc = self.charCodeAt(self.length - 1);\n\n\t// Classic date\n\tif (lc === 41)\n\t\treturn new Date(self);\n\n\t// JSON format\n\tif (lc === 90)\n\t\treturn new Date(Date.parse(self));\n\n\tvar arr = self.indexOf(' ') === -1 ? self.split('T') : self.split(' ');\n\tvar index = arr[0].indexOf(':');\n\tvar length = arr[0].length;\n\n\tif (index !== -1) {\n\t\tvar tmp = arr[1];\n\t\tarr[1] = arr[0];\n\t\tarr[0] = tmp;\n\t}\n\n\tif (arr[0] === undefined)\n\t\tarr[0] = '';\n\n\tvar noTime = arr[1] === undefined ? true : arr[1].length === 0;\n\n\tfor (var i = 0; i < length; i++) {\n\t\tvar c = arr[0].charCodeAt(i);\n\t\tif (c === 45 || c === 46 || (c > 47 && c < 58))\n\t\t\tcontinue;\n\t\tif (noTime)\n\t\t\treturn new Date(self);\n\t}\n\n\tif (arr[1] === undefined)\n\t\tarr[1] = '00:00:00';\n\n\tvar firstDay = arr[0].indexOf('-') === -1;\n\n\tvar date = (arr[0] || '').split(firstDay ? '.' : '-');\n\tvar time = (arr[1] || '').split(':');\n\tvar parsed = [];\n\n\tif (date.length < 4 && time.length < 2)\n\t\treturn new Date(self);\n\n\tindex = (time[2] || '').indexOf('.');\n\n\t// milliseconds\n\tif (index !== -1) {\n\t\ttime[3] = time[2].substring(index + 1);\n\t\ttime[2] = time[2].substring(0, index);\n\t} else\n\t\ttime[3] = '0';\n\n\tparsed.push(+date[firstDay ? 2 : 0]); // year\n\tparsed.push(+date[1]); // month\n\tparsed.push(+date[firstDay ? 0 : 2]); // day\n\tparsed.push(+time[0]); // hours\n\tparsed.push(+time[1]); // minutes\n\tparsed.push(+time[2]); // seconds\n\tparsed.push(+time[3]); // miliseconds\n\n\tvar def = new Date();\n\n\tfor (var i = 0, length = parsed.length; i < length; i++) {\n\t\tif (isNaN(parsed[i]))\n\t\t\tparsed[i] = 0;\n\n\t\tvar value = parsed[i];\n\t\tif (value !== 0)\n\t\t\tcontinue;\n\n\t\tswitch (i) {\n\t\t\tcase 0:\n\t\t\t\tif (value <= 0)\n\t\t\t\t\tparsed[i] = def.getFullYear();\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tif (value <= 0)\n\t\t\t\t\tparsed[i] = def.getMonth() + 1;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tif (value <= 0)\n\t\t\t\t\tparsed[i] = def.getDate();\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn new Date(parsed[0], parsed[1] - 1, parsed[2], parsed[3], parsed[4] - NOW.getTimezoneOffset(), parsed[5]);\n};\n\nSP.parseDateExpiration = function() {\n\tvar self = this;\n\n\tvar arr = self.split(' ');\n\tvar dt = new Date();\n\tvar length = arr.length;\n\n\tfor (var i = 0; i < length; i += 2) {\n\t\tvar num = arr[i].parseInt();\n\t\tif (num === 0)\n\t\t\tcontinue;\n\t\tvar type = arr[i + 1];\n\t\tif (type)\n\t\t\tdt = dt.add(type, num);\n\t}\n\n\treturn dt;\n};\n\nvar configurereplace = function(text) {\n\tvar val = CONF[text.substring(1, text.length - 1)];\n\treturn val == null ? '' : val;\n};\n\nSP.env = function() {\n\treturn this.replace(regexpCONFIGURE, configurereplace);\n};\n\n/**\n * Parse configuration from a string\n * @param {Object} def\n * @onerr {Function} error handling\n * @return {Object}\n */\nSP.parseConfig = function(def, onerr) {\n\n\tif (typeof(def) === 'function') {\n\t\tonerr = def;\n\t\tdef = null;\n\t}\n\n\tvar arr = this.split('\\n');\n\tvar length = arr.length;\n\tvar obj = def ? exports.extend({}, def) : {};\n\tvar subtype;\n\tvar name;\n\tvar index;\n\tvar value;\n\n\tfor (var i = 0; i < length; i++) {\n\n\t\tvar str = arr[i];\n\t\tif (!str || str[0] === '#' || str.substring(0, 2) === '//')\n\t\t\tcontinue;\n\n\t\tindex = str.indexOf(':');\n\t\tif (index === -1) {\n\t\t\tindex = str.indexOf('\\t:');\n\t\t\tif (index === -1)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tname = str.substring(0, index).trim();\n\t\tvalue = str.substring(index + 2).trim();\n\n\t\tindex = name.indexOf('(');\n\t\tif (index !== -1) {\n\t\t\tsubtype = name.substring(index + 1, name.indexOf(')')).trim().toLowerCase();\n\t\t\tname = name.substring(0, index).trim();\n\t\t} else\n\t\t\tsubtype = '';\n\n\t\tswitch (subtype) {\n\t\t\tcase 'string':\n\t\t\t\tobj[name] = value;\n\t\t\t\tbreak;\n\t\t\tcase 'number':\n\t\t\tcase 'float':\n\t\t\tcase 'double':\n\t\t\tcase 'currency':\n\t\t\t\tobj[name] = value.isNumber(true) ? value.parseFloat2() : value.parseInt2();\n\t\t\t\tbreak;\n\t\t\tcase 'boolean':\n\t\t\tcase 'bool':\n\t\t\t\tobj[name] = (/true|on|1|enabled/i).test(value);\n\t\t\t\tbreak;\n\t\t\tcase 'config':\n\t\t\t\tobj[name] = CONF[value];\n\t\t\t\tbreak;\n\t\t\tcase 'eval':\n\t\t\tcase 'object':\n\t\t\tcase 'array':\n\t\t\t\ttry {\n\t\t\t\t\tobj[name] = new Function('return ' + value)();\n\t\t\t\t} catch (e) {\n\t\t\t\t\tif (onerr)\n\t\t\t\t\t\tonerr(e, arr[i]);\n\t\t\t\t\telse\n\t\t\t\t\t\tthrow new Error('A value of \"{0}\" can\\'t be converted to \"{1}\": '.format(name, subtype) + e.toString());\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'json':\n\t\t\t\tobj[name] = value.parseJSON(true);\n\t\t\t\tbreak;\n\t\t\tcase 'env':\n\t\t\tcase 'environment':\n\t\t\t\tobj[name] = process.env[value];\n\t\t\t\tbreak;\n\t\t\tcase 'date':\n\t\t\tcase 'time':\n\t\t\tcase 'datetime':\n\t\t\t\tobj[name] = value.parseDate();\n\t\t\t\tbreak;\n\t\t\tcase 'random':\n\t\t\t\tobj[name] = GUID((value || '0').parseInt() || 10);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tobj[name] = value;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn obj;\n};\n\nSP.format = function() {\n\tvar arg = arguments;\n\treturn this.replace(regexpSTRINGFORMAT, function(text) {\n\t\tvar value = arg[+text.substring(1, text.length - 1)];\n\t\treturn value == null ? '' : value;\n\t});\n};\n\nSP.encrypt_uid = function(key) {\n\treturn exports.encrypt_uid(this, key);\n};\n\nSP.decrypt_uid = function(key) {\n\treturn exports.decrypt_uid(this, key);\n};\n\nSP.encode = function() {\n\tvar output = '';\n\tfor (var i = 0, length = this.length; i < length; i++) {\n\t\tvar c = this[i];\n\t\tswitch (c) {\n\t\t\tcase '<':\n\t\t\t\toutput += '&lt;';\n\t\t\t\tbreak;\n\t\t\tcase '>':\n\t\t\t\toutput += '&gt;';\n\t\t\t\tbreak;\n\t\t\tcase '\"':\n\t\t\t\toutput += '&quot;';\n\t\t\t\tbreak;\n\t\t\tcase '\\'':\n\t\t\t\toutput += '&apos;';\n\t\t\t\tbreak;\n\t\t\tcase '&':\n\t\t\t\toutput += '&amp;';\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\toutput += c;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn output;\n};\n\nSP.decode = function() {\n\treturn this.replace(regexpDECODE, function(s) {\n\t\tif (s.charAt(1) !== '#')\n\t\t\treturn ALPHA_INDEX[s] || s;\n\t\tvar code = s[2].toLowerCase() === 'x' ? parseInt(s.substr(3), 16) : parseInt(s.substr(2));\n\t\treturn !code || code < -32768 || code > 65535 ? '' : String.fromCharCode(code);\n\t});\n};\n\nSP.arg = SP.args = function(obj, encode, def) {\n\tif (typeof(encode) === 'string')\n\t\tdef = encode;\n\treturn this.replace(regexpARG, function(text) {\n\t\t// Is double?\n\t\tvar l = text[1] === '{' ? 2 : 1;\n\t\tvar val = obj[text.substring(l, text.length - l).trim()];\n\t\tif (encode && encode === 'json')\n\t\t\treturn JSON.stringify(val);\n\t\treturn val == null ? (def == null ? text : def) : encode ? encode === 'html' ? (val + '').encode() : encodeURIComponent(val + '') : val;\n\t});\n};\n\nSP.max = function(length, chars) {\n\tvar str = this;\n\tif (chars == null)\n\t\tchars = '...';\n\treturn str.length > length ? str.substring(0, length - chars.length) + chars : str;\n};\n\nSP.isJSON = function() {\n\tvar self = this;\n\tif (self.length <= 1)\n\t\treturn false;\n\n\tvar l = self.length - 1;\n\tvar a;\n\tvar b;\n\tvar i = 0;\n\n\twhile (true) {\n\t\ta = self[i++];\n\t\tif (a === ' ' || a === '\\n' || a === '\\r' || a === '\\t')\n\t\t\tcontinue;\n\t\tbreak;\n\t}\n\n\twhile (true) {\n\t\tb = self[l--];\n\t\tif (b === ' ' || b === '\\n' || b === '\\r' || b === '\\t')\n\t\t\tcontinue;\n\t\tbreak;\n\t}\n\n\treturn (a === '\"' && b === '\"') || (a === '[' && b === ']') || (a === '{' && b === '}') || (a.charCodeAt(0) > 47 && b.charCodeAt(0) < 57);\n};\n\nSP.isURL = function() {\n\treturn this.length <= 7 ? false : DEF.validators.url.test(this);\n};\n\nSP.isZIP = function() {\n\treturn DEF.validators.zip.test(this);\n};\n\nSP.isEmail = function() {\n\treturn this.length <= 4 ? false : DEF.validators.email.test(this);\n};\n\nSP.isPhone = function() {\n\treturn this.length < 6 ? false : DEF.validators.phone.test(this);\n};\n\nSP.isBase64 = function(isdata) {\n\n\tvar str = this;\n\tvar count = str.length;\n\n\tif (isdata) {\n\t\tvar index = str.indexOf(';base64,');\n\t\tif (index !== -1)\n\t\t\tcount -= (index + 8);\n\t}\n\n\treturn count % 4 === 0 && (isdata ? regexpBASE64_2.test(str) : regexpBASE64.test(str));\n};\n\nSP.isUID = function() {\n\tvar str = this;\n\n\tif (str.length < 12 && str.length > 25)\n\t\treturn false;\n\n\tvar is = DEF.validators.uid.test(str);\n\tif (is) {\n\n\t\tvar sum;\n\t\tvar beg;\n\t\tvar end;\n\t\tvar e = str[str.length - 1];\n\n\t\tif (e === 'b' || e === 'c' || e === 'd') {\n\t\t\tsum = str[str.length - 2];\n\t\t\tbeg = +str[str.length - 3];\n\t\t\tend = str.length - 5;\n\t\t\tvar tmp = e === 'c' || e === 'd' ? (+str.substring(beg, end)) : parseInt(str.substring(beg, end), 16);\n\t\t\treturn sum === (tmp % 2 ? '1' : '0');\n\t\t} else if (e === 'a') {\n\t\t\tsum = str[str.length - 2];\n\t\t\tbeg = 6;\n\t\t\tend = str.length - 4;\n\t\t} else {\n\t\t\tsum = str[str.length - 1];\n\t\t\tbeg = 10;\n\t\t\tend = str.length - 4;\n\t\t}\n\n\t\twhile (beg++ < end) {\n\t\t\tif (str[beg] !== '0') {\n\t\t\t\tif (((+str.substring(beg, end)) % 2 ? '1' : '0') === sum)\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n};\n\nSP.parseUID = function() {\n\tvar self = this;\n\tvar obj = {};\n\tvar hash;\n\tvar e = self[self.length - 1];\n\n\tif (e === 'b' || e === 'c' || e === 'd') {\n\t\tend = +self[self.length - 3];\n\t\tvar ticks = ((e === 'b' ? (+self.substring(0, end)) : parseInt(self.substring(0, end), e=== 'd' ? 36 : 16)) * 1000 * 60) + 1580511600000; // 1.1.2020\n\t\tobj.date = new Date(ticks);\n\t\tbeg = end;\n\t\tend = self.length - 5;\n\t\thash = +self.substring(end + 3, end + 4);\n\t\tobj.century = Math.floor((obj.date.getFullYear() - 1) / 100) + 1;\n\t\tobj.hash = self.substring(end, end + 2);\n\t} else if (e === 'a') {\n\t\tvar ticks = ((+self.substring(0, 6)) * 1000 * 60) + 1548975600000; // old 1.1.2019\n\t\tobj.date = new Date(ticks);\n\t\tbeg = 7;\n\t\tend = self.length - 4;\n\t\thash = +self.substring(end + 2, end + 3);\n\t\tobj.century = Math.floor((obj.date.getFullYear() - 1) / 100) + 1;\n\t\tobj.hash = self.substring(end, end + 2);\n\t} else {\n\t\tvar y = self.substring(0, 2);\n\t\tvar M = self.substring(2, 4);\n\t\tvar d = self.substring(4, 6);\n\t\tvar H = self.substring(6, 8);\n\t\tvar m = self.substring(8, 10);\n\n\t\tobj.date = new Date(+('20' + y), (+M) - 1, +d, +H, +m, 0);\n\n\t\tvar beg = 0;\n\t\tvar end = 0;\n\t\tvar index = 10;\n\n\t\twhile (true) {\n\n\t\t\tvar c = self[index];\n\n\t\t\tif (!c)\n\t\t\t\tbreak;\n\n\t\t\tif (!beg && c !== '0')\n\t\t\t\tbeg = index;\n\n\t\t\tif (c.charCodeAt(0) > 96) {\n\t\t\t\tend = index;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tindex++;\n\t\t}\n\n\t\tobj.century = self.substring(end + 4);\n\n\t\tif (obj.century) {\n\t\t\tobj.century = 20 + (+obj.century);\n\t\t\tobj.date.setYear(obj.date.getFullYear() + 100);\n\t\t} else\n\t\t\tobj.century = 21;\n\n\t\thash = +self.substring(end + 3, end + 4);\n\t\tobj.hash = self.substring(end, end + 3);\n\t}\n\n\tobj.index = +self.substring(beg, end);\n\tobj.valid = (obj.index % 2 ? 1 : 0) === hash;\n\treturn obj;\n};\n\nSP.parseENV = function() {\n\n\tvar arr = this.split(regexpLINES);\n\tvar obj = {};\n\n\tfor (var i = 0; i < arr.length; i++) {\n\t\tvar line = arr[i];\n\t\tif (!line || line.substring(0, 2) === '//' || line[0] === '#')\n\t\t\tcontinue;\n\n\t\tvar index = line.indexOf('=');\n\t\tif (index === -1)\n\t\t\tcontinue;\n\n\t\tvar key = line.substring(0, index);\n\t\tvar val = line.substring(index + 1).replace(/\\\\n/g, '\\n');\n\t\tvar end = val.length - 1;\n\n\t\tif ((val[0] === '\"' && val[end] === '\"') || (val[0] === '\\'' && val[end] === '\\''))\n\t\t\tval = val.substring(1, end);\n\t\telse\n\t\t\tval = val.trim();\n\n\t\tobj[key] = val;\n\t}\n\n\treturn obj;\n};\n\nSP.parseInt = function(def) {\n\tvar str = this.trim();\n\tvar num = +str;\n\treturn isNaN(num) ? (def === undefined ? 0 : def) : num;\n};\n\nSP.parseInt2 = function(def) {\n\tvar num = this.match(regexpINTEGER);\n\treturn num ? +num[0] : (def === undefined ? 0 : def);\n};\n\nSP.parseFloat2 = function(def) {\n\tvar num = this.match(regexpFLOAT);\n\treturn num ? +num[0].toString().replace(/,/g, '.') : (def === undefined ? 0 : def);\n};\n\nSP.parseBoolean = function() {\n\tvar self = this.toLowerCase();\n\treturn self === 'true' || self === '1' || self === 'on';\n};\n\nSP.parseFloat = function(def) {\n\tvar str = this.trim();\n\tif (str.indexOf(',') !== -1)\n\t\tstr = str.replace(',', '.');\n\tvar num = +str;\n\treturn isNaN(num) ? (def === undefined ? 0 : def) : num;\n};\n\nSP.capitalize = function(first) {\n\n\tif (first)\n\t\treturn (this[0] || '').toUpperCase() + this.substring(1);\n\n\tvar builder = '';\n\tvar c;\n\n\tfor (var i = 0, length = this.length; i < length; i++) {\n\t\tvar c = this[i - 1];\n\t\tif (!c || (c === ' ' || c === '\\t' || c === '\\n'))\n\t\t\tc = this[i].toUpperCase();\n\t\telse\n\t\t\tc = this[i];\n\t\tbuilder += c;\n\t}\n\n\treturn builder;\n};\n\nSP.toUnicode = function() {\n\tvar output = '';\n\tfor (var i = 0; i < this.length; i++) {\n\t\tvar c = this[i].charCodeAt(0);\n\t\tif(c > 126 || c < 32)\n\t\t\toutput += '\\\\u' + ('000' + c.toString(16)).substr(-4);\n\t\telse\n\t\t\toutput += this[i];\n\t}\n\treturn output;\n};\n\nSP.fromUnicode = function() {\n\tvar output = '';\n\tfor (var i = 0; i < this.length; i++) {\n\t\tif (this[i] === '\\\\' && this[i + 1] === 'u') {\n\t\t\toutput += String.fromCharCode(parseInt(this[i + 2] + this[i + 3] + this[i + 4] + this[i + 5], 16));\n\t\t\ti += 5;\n\t\t} else\n\t\t\toutput += this[i];\n\t}\n\treturn output;\n};\n\nSP.sha1 = function(salt) {\n\tvar hash = Crypto.createHash('sha1');\n\thash.update(this + (salt || ''), ENCODING);\n\treturn hash.digest('hex');\n};\n\nSP.sha256 = function(salt) {\n\tvar hash = Crypto.createHash('sha256');\n\thash.update(this + (salt || ''), ENCODING);\n\treturn hash.digest('hex');\n};\n\nSP.sha512 = function(salt) {\n\tvar hash = Crypto.createHash('sha512');\n\thash.update(this + (salt || ''), ENCODING);\n\treturn hash.digest('hex');\n};\n\nSP.md5 = function(salt) {\n\tvar hash = Crypto.createHash('md5');\n\thash.update(this + (salt || ''), ENCODING);\n\treturn hash.digest('hex');\n};\n\nSP.toSearch = function() {\n\tvar str = this.replace(regexpSEARCH, '').trim().toLowerCase().toASCII();\n\tvar buf = [];\n\tvar prev = '';\n\tfor (var i = 0, length = str.length; i < length; i++) {\n\t\tvar c = str[i];\n\t\tif (c === 'y')\n\t\t\tc = 'i';\n\t\tif (c === prev)\n\t\t\tcontinue;\n\t\tprev = c;\n\t\tbuf.push(c);\n\t}\n\n\treturn buf.join('');\n};\n\nSP.toKeywords = SP.keywords = function(forSearch, alternative, max_count, max_length, min_length) {\n\treturn exports.keywords(this, forSearch, alternative, max_count, max_length, min_length);\n};\n\nfunction checksum(val) {\n\tvar sum = 0;\n\tfor (var i = 0; i < val.length; i++)\n\t\tsum += val.charCodeAt(i);\n\treturn sum;\n}\n\nSP.encrypt = function(key, isUnique, secret) {\n\tvar str = '0' + this;\n\tvar data_count = str.length;\n\tvar key_count = key.length;\n\tvar random = isUnique ? exports.random(120) + 40 : 65;\n\tvar count = data_count + (random % key_count);\n\tvar values = [];\n\tvar index = 0;\n\n\tvalues[0] = String.fromCharCode(random);\n\n\tvar counter = this.length + key.length;\n\n\tfor (var i = count - 1; i > 0; i--) {\n\t\tindex = str.charCodeAt(i % data_count);\n\t\tvalues[i] = String.fromCharCode(index ^ (key.charCodeAt(i % key_count) ^ random));\n\t}\n\n\tstr = Buffer.from(counter + '=' + values.join(''), ENCODING).toString('hex');\n\tvar sum = 0;\n\n\tfor (var i = 0; i < str.length; i++)\n\t\tsum += str.charCodeAt(i);\n\n\treturn (sum + checksum((secret || CONF.secret) + key)) + '-' + str;\n};\n\nSP.decrypt = function(key, secret) {\n\n\tvar index = this.indexOf('-');\n\tif (index === -1)\n\t\treturn null;\n\n\tvar cs = +this.substring(0, index);\n\tif (!cs || isNaN(cs))\n\t\treturn null;\n\n\tvar hash = this.substring(index + 1);\n\tvar sum = checksum((secret || CONF.secret) + key);\n\tfor (var i = 0; i < hash.length; i++)\n\t\tsum += hash.charCodeAt(i);\n\n\tif (sum !== cs)\n\t\treturn null;\n\n\tvar values = Buffer.from(hash, 'hex').toString(ENCODING);\n\tvar index = values.indexOf('=');\n\tif (index === -1)\n\t\treturn null;\n\n\tvar counter = +values.substring(0, index);\n\tif (isNaN(counter))\n\t\treturn null;\n\n\tvalues = values.substring(index + 1);\n\n\tvar count = values.length;\n\tvar random = values.charCodeAt(0);\n\tvar key_count = key.length;\n\tvar data_count = count - (random % key_count);\n\tvar decrypt_data = [];\n\n\tfor (var i = data_count - 1; i > 0; i--) {\n\t\tindex = values.charCodeAt(i) ^ (random ^ key.charCodeAt(i % key_count));\n\t\tdecrypt_data[i] = String.fromCharCode(index);\n\t}\n\n\tvar val = decrypt_data.join('');\n\treturn counter !== (val.length + key.length) ? null : val;\n};\n\nexports.encrypt_data = function(value, key, encode) {\n\n\tvar builder = [];\n\tvar index = 0;\n\tvar length = key.length;\n\n\tfor (var i = 0; i < value.length; i++) {\n\n\t\tif (SKIPBODYENCRYPTOR[value[i]]) {\n\t\t\tbuilder.push(value[i]);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (index === length)\n\t\t\tindex = 0;\n\n\t\tvar a = value.charCodeAt(i) + 2;\n\t\tvar b = key.charCodeAt(index++);\n\t\tvar t = (a + b).toString(36);\n\t\tbuilder.push(t.length + t);\n\t}\n\n\tvar mask = Buffer.alloc(4);\n\tmask.writeInt32BE((Math.random() * 214748364) >> 0);\n\n\tvar buffer = Buffer.from(builder.join(''));\n\tfor (var i = 0; i < buffer.length; i++)\n\t\tbuffer[i] = buffer[i] ^ mask[i % 4];\n\n\tvar buf = Buffer.concat([mask, buffer]);\n\treturn encode === 'buffer' ? buf : buf.toString(encode || 'base64');\n};\n\nexports.decrypt_data = function(value, key, encode) {\n\n\ttry {\n\t\tvalue = value instanceof Buffer ? value : Buffer.from(value, encode || 'base64');\n\t} catch (e) {\n\t\treturn null;\n\t}\n\n\tvar index = 0;\n\tvar length = key.length;\n\tvar builder = [];\n\tvar mask = Buffer.alloc(4);\n\tvar buffer = Buffer.alloc(value.length - 4);\n\tmask.writeInt32BE(value.readInt32BE(0));\n\n\tfor (var i = 4; i < value.length; i++)\n\t\tbuffer[i - 4] = value[i] ^ mask[i % 4];\n\n\tvalue = buffer.toString('utf8');\n\n\tfor (var i = 0; i < value.length; i++) {\n\n\t\tvar c = value[i];\n\n\t\tif (SKIPBODYENCRYPTOR[c]) {\n\t\t\tbuilder.push(c);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (index === length)\n\t\t\tindex = 0;\n\n\t\tvar l = +value.charAt(i);\n\t\tvar code = parseInt(value.substring(i + 1, i + 1 + l), 36);\n\t\tvar b = key.charCodeAt(index++);\n\t\tbuilder.push(String.fromCharCode(code - b - 2));\n\t\ti += l;\n\t}\n\n\treturn builder.join('');\n};\n\nexports.encrypt_uid = function(val, key) {\n\n\tvar num = typeof(val) === 'number';\n\tvar sum = 0;\n\n\tif (!key)\n\t\tkey = CONF.secret;\n\n\tval = val + '';\n\n\tfor (var i = 0; i < val.length; i++)\n\t\tsum += val.charCodeAt(i);\n\n\tfor (var i = 0; i < key.length; i++)\n\t\tsum += key.charCodeAt(i);\n\n\treturn (num ? 'n' : 'x') + (CONF.secret_uid + val + sum + key).crc32(true).toString(32) + 'x' + val;\n};\n\nexports.decrypt_uid = function(val, key) {\n\tvar num = val[0] === 'n';\n\tvar raw = val.substring(val.indexOf('x', 1) + 1);\n\n\tif (num)\n\t\traw = +raw;\n\n\treturn exports.encrypt_uid(raw, key) === val ? raw : null;\n};\n\nexports.encrypt_crypto = function(type, key, value) {\n\tif (!F.temporary.keys[key])\n\t\tF.temporary.keys[key] = Buffer.from(key);\n\tvar cipher = Crypto.createCipheriv(type, F.temporary.keys[key], CONF.default_crypto_iv);\n\tCONCAT[0] = cipher.update(value);\n\tCONCAT[1] = cipher.final();\n\treturn Buffer.concat(CONCAT);\n};\n\nexports.decrypt_crypto = function(type, key, value) {\n\tif (!F.temporary.keys[key])\n\t\tF.temporary.keys[key] = Buffer.from(key);\n\tvar decipher = Crypto.createDecipheriv(type, F.temporary.keys[key], CONF.default_crypto_iv);\n\ttry {\n\t\tCONCAT[0] = decipher.update(value);\n\t\tCONCAT[1] = decipher.final();\n\t\treturn Buffer.concat(CONCAT);\n\t} catch (e) {}\n};\n\nSP.base64ToFile = function(filename, callback) {\n\tvar self = this;\n\tvar index = self.indexOf(',');\n\tif (index === -1)\n\t\tindex = 0;\n\telse\n\t\tindex++;\n\tFs.writeFile(filename, self.substring(index), 'base64', callback || NOOP);\n\treturn this;\n};\n\nSP.base64ToBuffer = function() {\n\tvar self = this;\n\n\tvar index = self.indexOf(',');\n\tif (index === -1)\n\t\tindex = 0;\n\telse\n\t\tindex++;\n\n\treturn Buffer.from(self.substring(index), 'base64');\n};\n\nSP.base64ContentType = function() {\n\tvar self = this;\n\tvar index = self.indexOf(';');\n\treturn index === -1 ? '' : self.substring(5, index);\n};\n\nvar toascii = c => DIACRITICSMAP[c] || c;\n\nSP.toASCII = function() {\n\treturn this.replace(regexpDiacritics, toascii);\n};\n\nSP.indent = function(max, c) {\n\tvar plus = '';\n\tif (c === undefined)\n\t\tc = ' ';\n\twhile (max--)\n\t\tplus += c;\n\treturn plus + this;\n};\n\nSP.isNumber = function(isDecimal) {\n\n\tvar self = this;\n\tvar length = self.length;\n\n\tif (!length)\n\t\treturn false;\n\n\tisDecimal = isDecimal || false;\n\n\tfor (var i = 0; i < length; i++) {\n\t\tvar ascii = self.charCodeAt(i);\n\n\t\tif (isDecimal) {\n\t\t\tif (ascii === 44 || ascii === 46) {\n\t\t\t\tisDecimal = false;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (ascii < 48 || ascii > 57)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n};\n\nif (!SP.padLeft) {\n\tSP.padLeft = function(max, c) {\n\t\tvar self = this;\n\t\tvar len = max - self.length;\n\t\tif (len < 0)\n\t\t\treturn self;\n\t\tif (c === undefined)\n\t\t\tc = ' ';\n\t\twhile (len--)\n\t\t\tself = c + self;\n\t\treturn self;\n\t};\n}\n\n\nif (!SP.padRight) {\n\tSP.padRight = function(max, c) {\n\t\tvar self = this;\n\t\tvar len = max - self.length;\n\t\tif (len < 0)\n\t\t\treturn self;\n\t\tif (c === undefined)\n\t\t\tc = ' ';\n\t\twhile (len--)\n\t\t\tself += c;\n\t\treturn self;\n\t};\n}\n\nSP.insert = function(index, value) {\n\tvar str = this;\n\tvar a = str.substring(0, index);\n\tvar b = value.toString() + str.substring(index);\n\treturn a + b;\n};\n\n/**\n * Create a link from String\n * @param  {Number} max A maximum length, default: 60 and optional.\n * @return {String}\n */\nSP.slug = function(max) {\n\tmax = max || 60;\n\n\tvar self = this.trim().toLowerCase().toASCII();\n\tvar builder = '';\n\tvar length = self.length;\n\n\tfor (var i = 0; i < length; i++) {\n\t\tvar c = self[i];\n\t\tvar code = self.charCodeAt(i);\n\n\t\tif (code > 540){\n\t\t\tbuilder = '';\n\t\t\tbreak;\n\t\t}\n\n\t\tif (builder.length >= max)\n\t\t\tbreak;\n\n\t\tif (code > 31 && code < 48) {\n\t\t\tif (builder[builder.length - 1] !== '-')\n\t\t\t\tbuilder += '-';\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ((code > 47 && code < 58) || (code > 94 && code < 123))\n\t\t\tbuilder += c;\n\t}\n\n\tif (builder.length > 1) {\n\t\tlength = builder.length - 1;\n\t\treturn builder[length] === '-' ? builder.substring(0, length) : builder;\n\t} else if (!length)\n\t\treturn '';\n\n\tlength = self.length;\n\tself = self.replace(/\\s/g, '');\n\tbuilder = self.crc32(true).toString(36) + '';\n\treturn self[0].charCodeAt(0).toString(32) + builder + self[self.length - 1].charCodeAt(0).toString(32) + length;\n};\n\nSP.pluralize = function(zero, one, few, other) {\n\treturn this.parseInt().pluralize(zero, one, few, other);\n};\n\nSP.isBoolean = function() {\n\tvar self = this.toLowerCase();\n\treturn (self === 'true' || self === 'false') ? true : false;\n};\n\n/**\n* Remove all Html Tags from a string\n* @return {string}\n*/\nSP.removeTags = function() {\n\treturn this.replace(regexpTags, '');\n};\n\nNP.between = function(condition, otherwise) {\n\n\tvar val = this;\n\n\tfor (var key in condition) {\n\n\t\tvar arr = key.split('-');\n\n\t\tvar a = arr[0] ? +arr[0] : null;\n\t\tvar b = arr[1] ? +arr[1] : null;\n\n\t\tif (a != null && b !== null) {\n\t\t\tif (val >= a && val <= b)\n\t\t\t\treturn condition[key];\n\t\t} else if (a != null) {\n\t\t\tif (val >= a)\n\t\t\t\treturn condition[key];\n\t\t} else if (b != null)\n\t\t\tif (val <= b)\n\t\t\t\treturn condition[key];\n\t}\n\n\treturn otherwise;\n};\n\nNP.floor = function(decimals) {\n\treturn Math.floor(this * Math.pow(10, decimals)) / Math.pow(10, decimals);\n};\n\nNP.fixed = function(decimals) {\n\treturn +this.toFixed(decimals);\n};\n\nNP.padLeft = function(max, c) {\n\treturn this.toString().padLeft(max, c || '0');\n};\n\nNP.padRight = function(max, c) {\n\treturn this.toString().padRight(max, c || '0');\n};\n\nNP.round = function(precision) {\n\tvar m = Math.pow(10, precision) || 1;\n\treturn Math.round(this * m) / m;\n};\n\nNP.currency = function(currency, a, b, c) {\n\tvar curr = DEF.currencies[currency || 'default'];\n\treturn curr ? curr(this, a, b, c) : this.format(2);\n};\n\n/**\n * Async decrements\n * @param {Function(index, next)} fn\n * @param {Function} callback\n * @return {Number}\n */\nNP.async = function(fn, callback) {\n\tvar number = this;\n\tif (number)\n\t\tfn(number--, () => setImmediate(() => number.async(fn, callback)));\n\telse\n\t\tcallback && callback();\n\treturn number;\n};\n\n/**\n * Format number\n * @param {Number} decimals Maximum decimal numbers\n * @param {String} separator Number separator, default ' '\n * @param {String} separatorDecimal Decimal separator, default '.' if number separator is ',' or ' '.\n * @return {String}\n */\nNP.format = function(decimals, separator, separatorDecimal) {\n\n\tvar self = this;\n\tvar num = self.toString();\n\tvar dec = '';\n\tvar output = '';\n\tvar minus = num[0] === '-' ? '-' : '';\n\tif (minus)\n\t\tnum = num.substring(1);\n\n\tvar index = num.indexOf('.');\n\n\tif (typeof(decimals) === 'string') {\n\t\tvar tmp = separator;\n\t\tseparator = decimals;\n\t\tdecimals = tmp;\n\t}\n\n\tif (separator === undefined)\n\t\tseparator = ' ';\n\n\tif (index !== -1) {\n\t\tdec = num.substring(index + 1);\n\t\tnum = num.substring(0, index);\n\t}\n\n\tindex = -1;\n\tfor (var i = num.length - 1; i >= 0; i--) {\n\t\tindex++;\n\t\tif (index > 0 && index % 3 === 0)\n\t\t\toutput = separator + output;\n\t\toutput = num[i] + output;\n\t}\n\n\tif (decimals || dec.length) {\n\t\tif (dec.length > decimals)\n\t\t\tdec = dec.substring(0, decimals || 0);\n\t\telse\n\t\t\tdec = dec.padRight(decimals || 0, '0');\n\t}\n\n\tif (dec.length && separatorDecimal === undefined)\n\t\tseparatorDecimal = separator === '.' ? ',' : '.';\n\n\treturn minus + output + (dec.length ? separatorDecimal + dec : '');\n};\n\nNP.add = function(value, decimals) {\n\n\tif (value == null)\n\t\treturn this;\n\n\tif (typeof(value) === 'number')\n\t\treturn this + value;\n\n\tvar first = value.charCodeAt(0);\n\tvar is = false;\n\n\tif (first < 48 || first > 57) {\n\t\tis = true;\n\t\tvalue = value.substring(1);\n\t}\n\n\tvar length = value.length;\n\tvar num;\n\n\tif (value[length - 1] === '%') {\n\t\tvalue = value.substring(0, length - 1);\n\t\tif (is) {\n\t\t\tvar val = value.parseFloat();\n\t\t\tswitch (first) {\n\t\t\t\tcase 42:\n\t\t\t\t\tnum = this * ((this / 100) * val);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 43:\n\t\t\t\t\tnum = this + ((this / 100) * val);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 45:\n\t\t\t\t\tnum = this - ((this / 100) * val);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 47:\n\t\t\t\t\tnum = this / ((this / 100) * val);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\treturn decimals !== undefined ? num.floor(decimals) : num;\n\t\t} else {\n\t\t\tnum = (this / 100) * value.parseFloat();\n\t\t\treturn decimals !== undefined ? num.floor(decimals) : num;\n\t\t}\n\n\t} else\n\t\tnum = value.parseFloat();\n\n\tswitch (first) {\n\t\tcase 42:\n\t\t\tnum = this * num;\n\t\t\tbreak;\n\t\tcase 43:\n\t\t\tnum = this + num;\n\t\t\tbreak;\n\t\tcase 45:\n\t\t\tnum = this - num;\n\t\t\tbreak;\n\t\tcase 47:\n\t\t\tnum = this / num;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tnum = this;\n\t\t\tbreak;\n\t}\n\n\tif (decimals !== undefined)\n\t\treturn num.floor(decimals);\n\n\treturn num;\n};\n\nNP.pluralize = function(zero, one, few, other) {\n\n\tvar num = this;\n\tvar value = '';\n\n\tif (num == 0)\n\t\tvalue = zero || '';\n\telse if (num == 1)\n\t\tvalue = one || '';\n\telse if (num > 1 && num < 5)\n\t\tvalue = few || '';\n\telse\n\t\tvalue = other;\n\n\tvar beg = value.indexOf('#');\n\tif (beg === -1)\n\t\treturn value;\n\n\tvar end = value.lastIndexOf('#');\n\tvar format = value.substring(beg, end + 1);\n\treturn num.format(format) + value.replace(format, '');\n};\n\nNP.hex = function(length) {\n\tvar str = this.toString(16).toUpperCase();\n\twhile(str.length < length)\n\t\tstr = '0' + str;\n\treturn str;\n};\n\nNP.VAT = function(percentage, decimals, includedVAT) {\n\tvar num = this;\n\tvar type = typeof(decimals);\n\n\tif (type === 'boolean') {\n\t\tvar tmp = includedVAT;\n\t\tincludedVAT = decimals;\n\t\tdecimals = tmp;\n\t\ttype = typeof(decimals);\n\t}\n\n\tif (type === 'undefined')\n\t\tdecimals = 2;\n\n\treturn !percentage || !num ? num.round(decimals) : includedVAT ? (num / ((percentage / 100) + 1)).round(decimals) : (num * ((percentage / 100) + 1)).round(decimals);\n};\n\nNP.discount = function(percentage, decimals) {\n\tvar num = this;\n\tif (decimals === undefined)\n\t\tdecimals = 2;\n\treturn !num || !percentage ? num : (num - (num / 100) * percentage).floor(decimals);\n};\n\nNP.parseDate = function(plus) {\n\treturn new Date(this + (plus || 0));\n};\n\nif (!NP.toRad) {\n\tNP.toRad = function () {\n\t\treturn this * Math.PI / 180;\n\t};\n}\n\nNP.filesize = function(decimals, type) {\n\n\tif (typeof(decimals) === 'string') {\n\t\tvar tmp = type;\n\t\ttype = decimals;\n\t\tdecimals = tmp;\n\t}\n\n\tvar value;\n\n\t// this === bytes\n\tswitch (type) {\n\t\tcase 'bytes':\n\t\t\tvalue = this;\n\t\t\tbreak;\n\t\tcase 'KB':\n\t\t\tvalue = this / 1024;\n\t\t\tbreak;\n\t\tcase 'MB':\n\t\t\tvalue = filesizehelper(this, 2);\n\t\t\tbreak;\n\t\tcase 'GB':\n\t\t\tvalue = filesizehelper(this, 3);\n\t\t\tbreak;\n\t\tcase 'TB':\n\t\t\tvalue = filesizehelper(this, 4);\n\t\t\tbreak;\n\t\tdefault:\n\n\t\t\ttype = 'bytes';\n\t\t\tvalue = this;\n\n\t\t\tif (value > 1023) {\n\t\t\t\tvalue = value / 1024;\n\t\t\t\ttype = 'KB';\n\t\t\t}\n\n\t\t\tif (value > 1023) {\n\t\t\t\tvalue = value / 1024;\n\t\t\t\ttype = 'MB';\n\t\t\t}\n\n\t\t\tif (value > 1023) {\n\t\t\t\tvalue = value / 1024;\n\t\t\t\ttype = 'GB';\n\t\t\t}\n\n\t\t\tif (value > 1023) {\n\t\t\t\tvalue = value / 1024;\n\t\t\t\ttype = 'TB';\n\t\t\t}\n\n\t\t\tbreak;\n\t}\n\n\ttype = ' ' + type;\n\treturn (decimals === undefined ? value.format(2).replace('.00', '') : value.format(decimals)) + type;\n};\n\nfunction filesizehelper(number, count) {\n\twhile (count--) {\n\t\tnumber = number / 1024;\n\t\tif (number.toFixed(3) === '0.000')\n\t\t\treturn 0;\n\t}\n\treturn number;\n}\n\nvar AP = Array.prototype;\n\n/**\n * Take items from array\n * @param {Number} count\n * @return {Array}\n */\nAP.take = function(count) {\n\tvar arr = [];\n\tvar self = this;\n\tfor (var i = 0; i < self.length; i++) {\n\t\tarr.push(self[i]);\n\t\tif (arr.length >= count)\n\t\t\treturn arr;\n\t}\n\treturn arr;\n};\n\n/**\n * First item in array\n * @param {Object} def Default value.\n * @return {Object}\n */\nAP.first = function(def) {\n\tvar item = this[0];\n\treturn item === undefined ? def : item;\n};\n\n/**\n * Create object from Array\n * @param {String} name Optional, property name.\n * @return {Object}\n */\nAP.toObject = function(name) {\n\n\tvar self = this;\n\tvar obj = {};\n\n\tfor (var i = 0; i < self.length; i++) {\n\t\tvar item = self[i];\n\t\tif (name)\n\t\t\tobj[item[name]] = item;\n\t\telse\n\t\t\tobj[item] = true;\n\t}\n\n\treturn obj;\n};\n\n/**\n * Last item in array\n * @param {Object} def Default value.\n * @return {Object}\n */\nAP.last = function(def) {\n\tvar item = this[this.length - 1];\n\treturn item === undefined ? def : item;\n};\n\nAP.quicksort = function(sort) {\n\n\tvar self = this;\n\tif (self.length < 2)\n\t\treturn self;\n\n\t// Backward compatibility\n\tif (!sort) {\n\t\tself.sort(COMPARER);\n\t\treturn self;\n\t}\n\n\t// Backward compatibility\n\tif (sort === true) {\n\t\tself.sort(COMPARER_DESC);\n\t\treturn self;\n\t}\n\n\tif (arguments[1] === true || arguments[1] === 2)\n\t\tsort += '_desc';\n\n\tshellsort(self, exports.sortcomparer(sort));\n\treturn self;\n};\n\nexports.sortcomparer = function(sort) {\n\n\tvar key = 'sort_' + sort;\n\tvar meta = F.temporary.other[key];\n\n\tif (!meta) {\n\t\tmeta = [];\n\t\tsort = sort.replace(/\\s/g, '').split(',');\n\t\tfor (var i = 0; i < sort.length; i++) {\n\t\t\tvar tmp = sort[i].split((/_(desc|asc)/));\n\t\t\tvar obj = { name: tmp[0], type: null, desc: tmp[1] === 'desc' };\n\t\t\tif (tmp[0].indexOf('.') !== -1)\n\t\t\t\tobj.read = new Function('val', 'return val.' + tmp[0].replace(/\\./g, '?.'));\n\t\t\tmeta.push(obj);\n\t\t}\n\t\tF.temporary.other[key] = meta;\n\t}\n\n\treturn function(a, b) {\n\t\tfor (var i = 0; i < meta.length; i++) {\n\t\t\tvar col = meta[i];\n\t\t\tvar va = col.read ? col.read(a) : a[col.name];\n\t\t\tvar vb = col.read ? col.read(b) : b[col.name];\n\n\t\t\tif (!col.type) {\n\t\t\t\tif (va != null)\n\t\t\t\t\tcol.type = va instanceof Date ? 4 : typeof(va);\n\t\t\t\telse if (vb != null)\n\t\t\t\t\tcol.type = vb instanceof Date ? 4: typeof(vb);\n\t\t\t\tswitch (col.type) {\n\t\t\t\t\tcase 'string':\n\t\t\t\t\t\tcol.type = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'number':\n\t\t\t\t\t\tcol.type = 2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'boolean':\n\t\t\t\t\t\tcol.type = 3;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'object':\n\t\t\t\t\t\tcol.type = 5;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (col.type) {\n\t\t\t\tswitch (col.type) {\n\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\ttmp = col.desc ? COMPARER_DESC(va, vb) : COMPARER(va, vb);\n\t\t\t\t\t\tif (tmp)\n\t\t\t\t\t\t\treturn tmp;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\ttmp = va > vb ? (col.desc ? -1 : 1) : va < vb ? (col.desc ? 1 : -1) : 0;\n\t\t\t\t\t\tif (tmp)\n\t\t\t\t\t\t\treturn tmp;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 3:\n\t\t\t\t\t\ttmp = va === true && vb === false ? (col.desc ? -1 : 1) : va === false && vb === true ? (col.desc ? 1 : -1) : 0;\n\t\t\t\t\t\tif (tmp)\n\t\t\t\t\t\t\treturn tmp;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 4:\n\n\t\t\t\t\t\tif (!va && !vb)\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tif (va && !vb)\n\t\t\t\t\t\t\treturn col.desc ? -1 : 1;\n\n\t\t\t\t\t\tif (!va && vb)\n\t\t\t\t\t\t\treturn col.desc ? 1 : -1;\n\n\t\t\t\t\t\tif (!va.getTime)\n\t\t\t\t\t\t\tva = new Date(va);\n\n\t\t\t\t\t\tif (!vb.getTime)\n\t\t\t\t\t\t\tvb = new Date(vb);\n\n\t\t\t\t\t\ttmp = va > vb ? (col.desc ? -1 : 1) : va < vb ? (col.desc ? 1 : -1) : 0;\n\n\t\t\t\t\t\tif (tmp)\n\t\t\t\t\t\t\treturn tmp;\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\treturn 0;\n\t\t}\n\n\t\treturn 0;\n\t};\n};\n\nAP.trim = function() {\n\tvar self = this;\n\tvar output = [];\n\tfor (var i = 0, length = self.length; i < length; i++) {\n\t\tif (typeof(self[i]) === 'string')\n\t\t\tself[i] = self[i].trim();\n\t\tself[i] && output.push(self[i]);\n\t}\n\treturn output;\n};\n\n/**\n * Skip items from array\n * @param {Number} count\n * @return {Array}\n */\nAP.skip = function(count) {\n\tvar arr = [];\n\tvar self = this;\n\tvar length = self.length;\n\tfor (var i = 0; i < length; i++)\n\t\ti >= count && arr.push(self[i]);\n\treturn arr;\n};\n\n/**\n * Find items in Array\n * @param {Function(item, index) or String/Object} cb\n * @param {Object} value Optional.\n * @return {Array}\n */\nAP.findAll = function(cb, value) {\n\n\tvar self = this;\n\tvar selected = [];\n\tvar isFN = typeof(cb) === 'function';\n\tvar isV = value !== undefined;\n\n\tfor (var i = 0, length = self.length; i < length; i++) {\n\n\t\tif (isFN) {\n\t\t\tcb.call(self, self[i], i) && selected.push(self[i]);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (isV) {\n\t\t\tself[i] && self[i][cb] === value && selected.push(self[i]);\n\t\t\tcontinue;\n\t\t}\n\n\t\tself[i] === cb && selected.push(self[i]);\n\t}\n\n\treturn selected;\n};\n\nAP.findValue = function(cb, value, path, def) {\n\tvar index = this.findIndex(cb, value);\n\tif (index !== -1) {\n\t\tvar item = this[index][path];\n\t\treturn item == null ? def : item;\n\t}\n\treturn def;\n};\n\nAP.findItem = function(cb, value) {\n\tvar self = this;\n\tvar index = self.findIndex(cb, value);\n\tif (index === -1)\n\t\treturn null;\n\treturn self[index];\n};\n\nAP.findIndex = function(cb, value) {\n\n\tvar self = this;\n\tvar isFN = typeof(cb) === 'function';\n\tvar isV = value !== undefined;\n\n\tfor (var i = 0, length = self.length; i < length; i++) {\n\n\t\tif (isFN) {\n\t\t\tif (cb.call(self, self[i], i))\n\t\t\t\treturn i;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (isV) {\n\t\t\tif (self[i] && self[i][cb] === value)\n\t\t\t\treturn i;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (self[i] === cb)\n\t\t\treturn i;\n\t}\n\n\treturn -1;\n};\n\n/**\n * Remove items from Array\n * @param {Function(item, index) or Object} cb\n * @param {Object} value Optional.\n * @return {Array}\n */\nAP.remove = function(cb, value) {\n\n\tvar self = this;\n\tvar arr = [];\n\tvar isFN = typeof(cb) === 'function';\n\tvar isV = value !== undefined;\n\n\tfor (var i = 0, length = self.length; i < length; i++) {\n\n\t\tif (isFN) {\n\t\t\t!cb.call(self, self[i], i) && arr.push(self[i]);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (isV) {\n\t\t\tself[i] && self[i][cb] !== value && arr.push(self[i]);\n\t\t\tcontinue;\n\t\t}\n\n\t\tself[i] !== cb && arr.push(self[i]);\n\t}\n\treturn arr;\n};\n\nAP.wait = function(onItem, callback, thread, tmp) {\n\n\tvar self = this;\n\tvar init = false;\n\n\t// INIT\n\tif (!tmp) {\n\n\t\tif (typeof(callback) !== 'function') {\n\t\t\tthread = callback;\n\t\t\tcallback = null;\n\t\t}\n\n\t\ttmp = {};\n\t\ttmp.pending = 0;\n\t\ttmp.index = 0;\n\t\ttmp.thread = thread;\n\n\t\t// thread === Boolean then array has to be removed item by item\n\n\t\tinit = true;\n\t}\n\n\tvar item = thread === true ? self.shift() : self[tmp.index++];\n\tif (item === undefined) {\n\t\tif (!tmp.pending) {\n\t\t\tcallback && callback();\n\t\t\ttmp.cancel = true;\n\t\t}\n\t\treturn self;\n\t}\n\n\ttmp.pending++;\n\tonItem.call(self, item, () => setImmediate(next_wait, self, onItem, callback, thread, tmp), tmp.index);\n\n\tif (!init || tmp.thread === 1)\n\t\treturn self;\n\n\tfor (var i = 1; i < tmp.thread; i++)\n\t\tself.wait(onItem, callback, 1, tmp);\n\n\treturn self;\n};\n\nfunction next_wait(self, onItem, callback, thread, tmp) {\n\ttmp.pending--;\n\tself.wait(onItem, callback, thread, tmp);\n}\n\n/**\n * Creates a function async list\n * @param {Function} callback Optional\n * @return {Array}\n */\nAP.async = function(thread, callback, pending) {\n\n\tvar self = this;\n\n\tif (typeof(thread) === 'function') {\n\t\tcallback = thread;\n\t\tthread = 1;\n\t} else if (thread === undefined)\n\t\tthread = 1;\n\n\tif (pending === undefined)\n\t\tpending = 0;\n\n\tvar item = self.shift();\n\tif (item === undefined) {\n\t\tif (!pending) {\n\t\t\tpending = undefined;\n\t\t\tcallback && callback();\n\t\t}\n\t\treturn self;\n\t}\n\n\tfor (var i = 0; i < thread; i++) {\n\n\t\tif (i)\n\t\t\titem = self.shift();\n\n\t\tpending++;\n\t\titem(function() {\n\t\t\tsetImmediate(function() {\n\t\t\t\tpending--;\n\t\t\t\tself.async(1, callback, pending);\n\t\t\t});\n\t\t});\n\t}\n\n\treturn self;\n};\n\n// Fisher-Yates shuffle\nAP.random = function(item) {\n\tif (item)\n\t\treturn this[exports.random(this.length - 1)];\n\tfor (var i = this.length - 1; i > 0; i--) {\n\t\tvar j = Math.floor(Math.random() * (i + 1));\n\t\tvar temp = this[i];\n\t\tthis[i] = this[j];\n\t\tthis[j] = temp;\n\t}\n\treturn this;\n};\n\nAP.limit = function(max, fn, callback, index) {\n\n\tif (index === undefined)\n\t\tindex = 0;\n\n\tvar current = [];\n\tvar self = this;\n\tvar length = index + max;\n\n\tfor (var i = index; i < length; i++) {\n\t\tvar item = self[i];\n\n\t\tif (item !== undefined) {\n\t\t\tcurrent.push(item);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!current.length) {\n\t\t\tcallback && callback();\n\t\t\treturn self;\n\t\t}\n\n\t\tfn(current, () => callback && callback(), index, index + max);\n\t\treturn self;\n\t}\n\n\tif (!current.length) {\n\t\tcallback && callback();\n\t\treturn self;\n\t}\n\n\tfn(current, function() {\n\t\tif (length < self.length)\n\t\t\tself.limit(max, fn, callback, length);\n\t\telse\n\t\t\tcallback && callback();\n\t}, index, index + max);\n\n\treturn self;\n};\n\nArrayBuffer.prototype.toBuffer = function() {\n\tvar buf = new Buffer(this.byteLength);\n\tvar view = new Uint8Array(this);\n\tfor (var i = 0; i < buf.length; ++i)\n\t\tbuf[i] = view[i];\n\treturn buf;\n};\n\nfunction FileList() {\n\tthis.pending = [];\n\tthis.pendingDirectory = [];\n\tthis.directory = [];\n\tthis.file = [];\n\tthis.onComplete = null;\n\tthis.onFilter = null;\n\tthis.advanced = false;\n}\n\nconst FLP = FileList.prototype;\n\nFLP.reset = function() {\n\tthis.file.length = 0;\n\tthis.directory.length = 0;\n\tthis.pendingDirectory.length = 0;\n\treturn this;\n};\n\nFLP.walk = function(directory) {\n\n\tvar self = this;\n\n\tif (directory instanceof Array) {\n\t\tvar length = directory.length;\n\t\tfor (var i = 0; i < length; i++)\n\t\t\tself.pendingDirectory.push(directory[i]);\n\t\tself.next();\n\t\treturn;\n\t}\n\n\tFs.readdir(directory, function(err, arr) {\n\t\tif (err)\n\t\t\treturn self.next();\n\t\tvar length = arr.length;\n\t\tfor (var i = 0; i < length; i++)\n\t\t\tself.pending.push(Path.join(directory, arr[i]));\n\t\tself.next();\n\t});\n};\n\nFLP.stat = function(path) {\n\tvar self = this;\n\n\tFs.stat(path, function(err, stats) {\n\n\t\tif (err)\n\t\t\treturn self.next();\n\n\t\tif (stats.isDirectory()) {\n\t\t\tpath = self.clean(path);\n\t\t\tif (!self.onFilter || self.onFilter(path, true)) {\n\t\t\t\tself.directory.push(path);\n\t\t\t\tself.pendingDirectory.push(path);\n\t\t\t}\n\t\t} else if (!self.onFilter || self.onFilter(path, false))\n\t\t\tself.file.push(self.advanced ? { filename: path, stats: stats } : path);\n\n\t\tself.next();\n\t});\n};\n\nFLP.clean = function(path) {\n\treturn path[path.length - 1] === Path.sep ? path : path + Path.sep;\n};\n\nFLP.next = function() {\n\tvar self = this;\n\n\tif (self.pending.length) {\n\t\tvar item = self.pending.shift();\n\t\tself.stat(item);\n\t\treturn;\n\t}\n\n\tif (self.pendingDirectory.length) {\n\t\tvar directory = self.pendingDirectory.shift();\n\t\tself.walk(directory);\n\t\treturn;\n\t}\n\n\tself.onComplete(self.file, self.directory);\n};\n\nexports.async = function(fn, isApply) {\n\tvar context = this;\n\treturn function(complete) {\n\n\t\tvar self = this;\n\t\tvar argv;\n\n\t\tif (arguments.length) {\n\n\t\t\tif (isApply) {\n\t\t\t\t// index.js/Subscribe.prototype.doExecute\n\t\t\t\targv = arguments[1];\n\t\t\t} else {\n\t\t\t\targv = [];\n\t\t\t\tfor (var i = 1; i < arguments.length; i++)\n\t\t\t\t\targv.push(arguments[i]);\n\t\t\t}\n\t\t} else\n\t\t\targv = new Array(0);\n\n\t\tvar generator = fn.apply(context, argv);\n\t\tnext(null);\n\n\t\tfunction next(err, result) {\n\n\t\t\tvar g, type;\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\tvar can = err ? false : true;\n\t\t\t\tswitch (can) {\n\t\t\t\t\tcase true:\n\t\t\t\t\t\tg = generator.next(result);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase false:\n\t\t\t\t\t\tg = generator.throw(err);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t} catch (e) {\n\n\t\t\t\tif (!complete)\n\t\t\t\t\treturn;\n\n\t\t\t\ttype = typeof(complete);\n\n\t\t\t\tif (type === 'object' && complete.isController) {\n\t\t\t\t\tif (e instanceof ErrorBuilder)\n\t\t\t\t\t\tcomplete.content(e);\n\t\t\t\t\telse\n\t\t\t\t\t\tcomplete.view500(e);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\ttype === 'function' && setImmediate(() => complete(e));\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (g.done) {\n\t\t\t\ttypeof(complete) === 'function' && complete(null, g.value);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar promise = g.value instanceof Promise;\n\n\t\t\tif (typeof(g.value) !== 'function' && !promise) {\n\t\t\t\tnext.call(self, null, g.value);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\tif (promise) {\n\t\t\t\t\tg.value.then((value) => next.call(self, null, value));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tg.value.call(self, function() {\n\t\t\t\t\tnext.apply(self, arguments);\n\t\t\t\t});\n\n\t\t\t} catch (e) {\n\t\t\t\tsetImmediate(() => next.call(self, e));\n\t\t\t}\n\t\t}\n\n\t\treturn generator.value;\n\t};\n};\n\n// MIT\n// Written by Jozef Gula\n// Optimized by Peter Sirka\nconst CACHE_GML1 = [null, null, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];\nconst CACHE_GML2 = [null, null, null, null, null, null, null, null];\nexports.getMessageLength = function(data, isLE) {\n\n\tvar length = data[1] & 0x7f;\n\n\tif (length === 126) {\n\t\tif (data.length < 4)\n\t\t\treturn -1;\n\t\tCACHE_GML1[0] = data[3];\n\t\tCACHE_GML1[1] = data[2];\n\t\treturn converBytesToInt64(CACHE_GML1, 0, isLE);\n\t}\n\n\tif (length === 127) {\n\t\tif (data.Length < 10)\n\t\t\treturn -1;\n\t\tCACHE_GML2[0] = data[9];\n\t\tCACHE_GML2[1] = data[8];\n\t\tCACHE_GML2[2] = data[7];\n\t\tCACHE_GML2[3] = data[6];\n\t\tCACHE_GML2[4] = data[5];\n\t\tCACHE_GML2[5] = data[4];\n\t\tCACHE_GML2[6] = data[3];\n\t\tCACHE_GML2[7] = data[2];\n\t\treturn converBytesToInt64(CACHE_GML2, 0, isLE);\n\t}\n\n\treturn length;\n};\n\n// MIT\n// Written by Jozef Gula\nfunction converBytesToInt64(data, startIndex, isLE) {\n\treturn isLE ? (data[startIndex] | (data[startIndex + 1] << 0x08) | (data[startIndex + 2] << 0x10) | (data[startIndex + 3] << 0x18) | (data[startIndex + 4] << 0x20) | (data[startIndex + 5] << 0x28) | (data[startIndex + 6] << 0x30) | (data[startIndex + 7] << 0x38)) : ((data[startIndex + 7] << 0x20) | (data[startIndex + 6] << 0x28) | (data[startIndex + 5] << 0x30) | (data[startIndex + 4] << 0x38) | (data[startIndex + 3]) | (data[startIndex + 2] << 0x08) | (data[startIndex + 1] << 0x10) | (data[startIndex] << 0x18));\n}\n\nexports.queuecache = {};\n\nfunction queue_next(name) {\n\n\tvar item = exports.queuecache[name];\n\tif (!item)\n\t\treturn;\n\n\titem.running--;\n\n\tif (item.running < 0)\n\t\titem.running = 0;\n\n\tif (item.pending.length) {\n\t\tvar fn = item.pending.shift();\n\t\tif (fn) {\n\t\t\titem.running++;\n\t\t\tsetImmediate(queue_next_callback, fn, name);\n\t\t} else\n\t\t\titem.running = 0;\n\t}\n}\n\nfunction queue_next_callback(fn, name) {\n\tfn(() => queue_next(name));\n}\n\nexports.json2replacer = function(key, value) {\n\tif (value != null)\n\t\treturn value;\n};\n\n/**\n * Queue list\n * @param {String} name\n * @param {Number} max Maximum stack.\n * @param {Function(next)} fn\n */\nexports.queue = function(name, max, fn) {\n\n\tif (!fn)\n\t\treturn false;\n\n\tif (!max) {\n\t\tfn(NOOP);\n\t\treturn true;\n\t}\n\n\tif (!exports.queuecache[name])\n\t\texports.queuecache[name] = { limit: max, running: 0, pending: [] };\n\n\tvar item = exports.queuecache[name];\n\tif (item.running >= item.limit) {\n\t\titem.pending.push(fn);\n\t\treturn false;\n\t}\n\n\titem.running++;\n\tsetImmediate(queue_next_callback, fn, name);\n\treturn true;\n};\n\nexports.minify_css = function(val) {\n\treturn Internal.compile_css(val);\n};\n\nexports.minify_js = function(val) {\n\treturn Internal.compile_javascript(val);\n};\n\nexports.minify_html = function(val) {\n\treturn Internal.compile_html(val);\n};\n\nexports.parseTheme = function(value) {\n\tif (value[0] !== '=')\n\t\treturn '';\n\tvar index = value.indexOf('/', 2);\n\tif (index === -1)\n\t\treturn '';\n\tvalue = value.substring(1, index);\n\treturn value === '?' ? CONF.default_theme : value;\n};\n\n// =============================================\n// SHELL SORT IMPLEMENTATION OF ALGORITHM\n// =============================================\n\nfunction _shellInsertionSort(list, length, gapSize, fn) {\n\tvar temp, i, j;\n\tfor (i = gapSize; i < length; i += gapSize ) {\n\t\tj = i;\n\t\twhile(j > 0 && fn(list[j - gapSize], list[j]) === 1) {\n\t\t\ttemp = list[j];\n\t\t\tlist[j] = list[j - gapSize];\n\t\t\tlist[j - gapSize] = temp;\n\t\t\tj -= gapSize;\n\t\t}\n\t}\n}\n\nfunction shellsort(arr, fn) {\n\tvar length = arr.length;\n\tvar gapSize = Math.floor(length / 2);\n\twhile(gapSize) {\n\t\t_shellInsertionSort(arr, length, gapSize, fn);\n\t\tgapSize = Math.floor(gapSize / 2);\n\t}\n\treturn arr;\n}\n\nfunction EventEmitter2(obj) {\n\tif (obj) {\n\t\t!obj.emit && EventEmitter2.extend(obj);\n\t\treturn obj;\n\t} else\n\t\tthis.$events = {};\n}\n\nconst EE2P = EventEmitter2.prototype;\n\nEE2P.emit = function(name, a, b, c, d, e, f, g) {\n\n\tif (!this.$events)\n\t\treturn this;\n\n\tvar evt = this.$events[name];\n\tif (evt) {\n\t\tvar clean = false;\n\t\tfor (var i = 0, length = evt.length; i < length; i++) {\n\t\t\tif (evt[i].$once)\n\t\t\t\tclean = true;\n\t\t\tevt[i].call(this, a, b, c, d, e, f, g);\n\t\t}\n\t\tif (clean) {\n\t\t\tevt = evt.remove(n => n.$once);\n\t\t\tif (evt.length)\n\t\t\t\tthis.$events[name] = evt;\n\t\t\telse\n\t\t\t\tthis.$events[name] = undefined;\n\t\t}\n\t}\n\treturn this;\n};\n\nEE2P.on = function(name, fn) {\n\tif (!this.$events)\n\t\tthis.$events = {};\n\tif (this.$events[name])\n\t\tthis.$events[name].push(fn);\n\telse\n\t\tthis.$events[name] = [fn];\n\treturn this;\n};\n\nEE2P.once = function(name, fn) {\n\tfn.$once = true;\n\treturn this.on(name, fn);\n};\n\nEE2P.removeListener = function(name, fn) {\n\tif (this.$events) {\n\t\tvar evt = this.$events[name];\n\t\tif (evt) {\n\t\t\tevt = evt.remove(n => n === fn);\n\t\t\tif (evt.length)\n\t\t\t\tthis.$events[name] = evt;\n\t\t\telse\n\t\t\t\tthis.$events[name] = undefined;\n\t\t}\n\t}\n\treturn this;\n};\n\nEE2P.removeAllListeners = function(name) {\n\tif (this.$events) {\n\t\tif (name === true)\n\t\t\tthis.$events = EMPTYOBJECT;\n\t\telse if (name)\n\t\t\tthis.$events[name] = undefined;\n\t\telse\n\t\t\tthis.$events = {};\n\t}\n\treturn this;\n};\n\nEventEmitter2.extend = function(obj) {\n\tobj.emit = EE2P.emit;\n\tobj.on = EE2P.on;\n\tobj.once = EE2P.once;\n\tobj.removeListener = EE2P.removeListener;\n\tobj.removeAllListeners = EE2P.removeAllListeners;\n};\n\nexports.EventEmitter2 = EventEmitter2;\n\nfunction Chunker(name, max) {\n\tthis.name = name;\n\tthis.max = max || 50;\n\tthis.index = 0;\n\tthis.filename = '{0}-'.format(name);\n\tthis.stack = [];\n\tthis.flushing = 0;\n\tthis.pages = 0;\n\tthis.count = 0;\n\tthis.percentage = 0;\n\tthis.autoremove = true;\n\tthis.compress = true;\n\tthis.filename = PATH.temp(this.filename);\n}\n\nconst CHP = Chunker.prototype;\n\nCHP.append = CHP.write = function(obj) {\n\tvar self = this;\n\n\tself.stack.push(obj);\n\n\tvar tmp = self.stack.length;\n\n\tif (tmp >= self.max) {\n\n\t\tself.flushing++;\n\t\tself.pages++;\n\t\tself.count += tmp;\n\n\t\tvar index = (self.index++);\n\n\t\tif (self.compress) {\n\t\t\tZlib.deflate(Buffer.from(JSON.stringify(self.stack), ENCODING), function(err, buffer) {\n\t\t\t\tFs.writeFile(self.filename + index + '.chunker', buffer, () => self.flushing--);\n\t\t\t});\n\t\t} else\n\t\t\tFs.writeFile(self.filename + index + '.chunker', JSON.stringify(self.stack), () => self.flushing--);\n\n\t\tself.stack = [];\n\t}\n\n\treturn self;\n};\n\nCHP.end = function() {\n\tvar self = this;\n\tvar tmp = self.stack.length;\n\tif (tmp) {\n\t\tself.flushing++;\n\t\tself.pages++;\n\t\tself.count += tmp;\n\n\t\tvar index = (self.index++);\n\n\t\tif (self.compress) {\n\t\t\tZlib.deflate(Buffer.from(JSON.stringify(self.stack), ENCODING), function(err, buffer) {\n\t\t\t\tFs.writeFile(self.filename + index + '.chunker', buffer, () => self.flushing--);\n\t\t\t});\n\t\t} else\n\t\t\tFs.writeFile(self.filename + index + '.chunker', JSON.stringify(self.stack), () => self.flushing--);\n\n\t\tself.stack = [];\n\t}\n\n\treturn self;\n};\n\nCHP.each = function(onItem, onEnd, indexer) {\n\n\tvar self = this;\n\n\tif (indexer == null) {\n\t\tself.percentage = 0;\n\t\tindexer = 0;\n\t}\n\n\tif (indexer >= self.index)\n\t\treturn onEnd && onEnd();\n\n\tself.read(indexer++, function(err, items) {\n\t\tself.percentage = Math.ceil((indexer / self.pages) * 100);\n\t\tonItem(items, () => self.each(onItem, onEnd, indexer), indexer - 1);\n\t});\n\n\treturn self;\n};\n\nCHP.read = function(index, callback) {\n\tvar self = this;\n\n\tif (self.flushing) {\n\t\tself.flushing_timeout = setTimeout(() => self.read(index, callback), 300);\n\t\treturn;\n\t}\n\n\tvar filename = self.filename + index + '.chunker';\n\n\tFs.readFile(filename, function(err, data) {\n\n\t\tif (err) {\n\t\t\tcallback(null, EMPTYARRAY);\n\t\t\treturn;\n\t\t}\n\n\t\tif (self.compress) {\n\t\t\tZlib.inflate(data, function(err, data) {\n\t\t\t\tif (err) {\n\t\t\t\t\tcallback(null, EMPTYARRAY);\n\t\t\t\t} else {\n\t\t\t\t\tself.autoremove && Fs.unlink(filename, NOOP);\n\t\t\t\t\tcallback(null, data.toString('utf8').parseJSON(true));\n\t\t\t\t}\n\t\t\t});\n\t\t} else {\n\t\t\tself.autoremove && Fs.unlink(filename, NOOP);\n\t\t\tcallback(null, data.toString('utf8').parseJSON(true));\n\t\t}\n\t});\n\n\treturn self;\n};\n\nCHP.clear = function() {\n\tvar files = [];\n\tfor (var i = 0; i < this.index; i++)\n\t\tfiles.push(this.filename + i + '.chunker');\n\tfiles.wait((filename, next) => Fs.unlink(filename, next));\n\treturn this;\n};\n\nCHP.destroy = function() {\n\tthis.clear();\n\tthis.indexer = 0;\n\tthis.flushing = 0;\n\tclearTimeout(this.flushing_timeout);\n\tthis.stack = null;\n\treturn this;\n};\n\nexports.chunker = function(name, max) {\n\treturn new Chunker(name, max);\n};\n\nexports.Chunker = Chunker;\n\nexports.ObjectToArray = function(obj) {\n\tif (obj == null)\n\t\treturn EMPTYARRAY;\n\tvar output = [];\n\tfor (var key in obj)\n\t\toutput.push({ key: key, value: obj[key]});\n\treturn output;\n};\n\nexports.createBufferSize = (size) => Buffer.alloc(size || 0);\nexports.createBuffer = (val, type) => Buffer.from(val || '', type);\n\nfunction Callback(count, callback) {\n\tthis.pending = count;\n\tthis.$callback = callback;\n}\nconst CP = Callback.prototype;\n\nCP.done = function(callback) {\n\tthis.$callback = callback;\n\treturn this;\n};\n\nCP.next = function() {\n\tvar self = this;\n\tself.pending--;\n\tif (!self.pending && self.$callback) {\n\t\tself.$callback();\n\t\tself.$callback = null;\n\t}\n\treturn self;\n};\n\nglobal.Callback = Callback;\n\nexports.Callback = function(count, callback) {\n\treturn new Callback(count, callback);\n};\n\nfunction Reader() {\n\tvar t = this;\n\t// t.tmp;\n\tt.$add = function(builder) {\n\t\tvar b = require('./textdb-builder').make();\n\t\tbuilder.options.filter = builder.options.filter && builder.options.filter.length ? builder.options.filter.join('&&') : 'true';\n\t\tb.assign(builder.options);\n\n\t\tif (builder.$)\n\t\t\tb.$resolve = builder.$resolve;\n\t\telse\n\t\t\tb.$callback = builder.$callback;\n\n\t\tif (t.reader)\n\t\t\tt.reader.add(b);\n\t\telse {\n\t\t\tt.reader = require('./textdb-reader').make();\n\t\t\tt.reader.add(b);\n\t\t\tt.reader.prepare();\n\t\t}\n\t};\n\n\tt.push = function(data) {\n\t\tif (t.reader) {\n\t\t\tif (data)\n\t\t\t\tt.reader.compare(data instanceof Array ? data : [data]);\n\t\t\telse\n\t\t\t\tt.reader.done();\n\t\t} else\n\t\t\tsetImmediate(t.push, data);\n\t};\n\n}\n\nconst RP = Reader.prototype;\n\nRP.done = function() {\n\tvar self = this;\n\tself.reader.done();\n\treturn self;\n};\n\nRP.reset = function() {\n\tvar self = this;\n\tself.reader.reset();\n\treturn self;\n};\n\nRP.find = function() {\n\tvar self = this;\n\tvar builder = require('./textdb-wrapper').makebuilder();\n\tbuilder.command = 'find';\n\tsetImmediate(self.$add, builder);\n\treturn builder;\n};\n\nfunction listing(builder, items, response) {\n\tvar skip = builder.options.skip || 0;\n\tvar take = builder.options.take || 0;\n\treturn { page: skip && take ? ((skip / take) + 1) : 1, pages: response.count && take ? Math.ceil(response.count / take) : response.count ? 1 : 0, limit: take, count: response.count, items: items || [] };\n}\n\nRP.list = function() {\n\tvar self = this;\n\tvar builder = require('./textdb-wrapper').makebuilder();\n\tbuilder.command = 'find';\n\tbuilder.parent = {};\n\tbuilder.$callback = function(err, response, meta) {\n\t\tif (builder.parent.$) {\n\t\t\tif (err)\n\t\t\t\tbuilder.parent.$.invalid(err);\n\t\t\telse\n\t\t\t\tbuilder.parent.$resolve(response);\n\t\t} else if (builder.parent.$callback)\n\t\t\tbuilder.parent.$callback(err, listing(builder, response, meta), meta);\n\t};\n\tsetImmediate(self.$add, builder);\n\treturn builder;\n};\n\nRP.read = function() {\n\tvar self = this;\n\tvar builder = require('./textdb-wrapper').makebuilder();\n\tbuilder.command = 'find';\n\tbuilder.options.take = 1;\n\tbuilder.options.first = 1;\n\tsetImmediate(self.$add, builder);\n\treturn builder;\n};\n\nRP.count = function() {\n\tvar builder = this.find();\n\tbuilder.options.scalar = 'arg.count++';\n\tbuilder.options.scalararg = { count: 0 };\n\treturn builder;\n};\n\nRP.scalar = function(type, key, key2) {\n\tvar builder = this.find();\n\n\tif (key == null) {\n\t\tkey = type;\n\t\ttype = '*';\n\t}\n\n\tswitch (type) {\n\t\tcase 'group':\n\t\t\tbuilder.options.scalar = key2 ? 'if (doc.{0}!=null){tmp.val=doc.{0};arg[tmp.val]=(arg[tmp.val]||0)+(doc.{1}||0)}'.format(key, key2) : 'if (doc.{0}!=null){tmp.val=doc.{0};arg[tmp.val]=(arg[tmp.val]||0)+1}'.format(key);\n\t\t\tbuilder.options.scalararg = {};\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t// min, max, sum, count\n\t\t\tif (key2) {\n\t\t\t\tbuilder.options.scalar = 'var k=doc.' + key + '+\\'\\';if (arg[k]){tmp.bk=doc.' + key2 + '||0;' + (type === 'max' ? 'if(tmp.bk>arg[k])arg[k]=tmp.bk' : type === 'min' ? 'if(tmp.bk<arg[k])arg[k]=tmp.bk' : 'arg[k]+=tmp.bk') + '}else{arg[k]=doc.' + key2 + '||0}';\n\t\t\t} else {\n\t\t\t\tbuilder.options.scalar = 'if (doc.{0}!=null){tmp.val=doc.{0};arg.count+=1;arg.min=arg.min==null?tmp.val:arg.min>tmp.val?tmp.val:arg.min;arg.max=arg.max==null?tmp.val:arg.max<tmp.val?tmp.val:arg.max;if(!(tmp.val instanceof Date))arg.sum+=tmp.val}'.format(key);\n\t\t\t\tbuilder.options.scalararg = { count: 0, sum: 0 };\n\t\t\t}\n\t\t\tbreak;\n\t}\n\treturn builder;\n};\n\nRP.stats = function(groupfield, datefield, key, type) {\n\tvar builder = this.find();\n\tbuilder.options.scalar = 'if (doc.{0}!=null&&doc.{2}!=null&&doc.{1} instanceof Date){tmp.val=doc.{2};tmp.group=doc.{0};tmp.date=doc.{1}.format(\\'{3}\\');if(!arg[tmp.group])arg[tmp.group]={};if(!arg[tmp.group][tmp.date])arg[tmp.group][tmp.date]={min:null,max:null,count:0};tmp.cur=arg[tmp.group][tmp.date];tmp.cur.count++;if(tmp.cur.max==null){tmp.cur.max=tmp.val}else if(tmp.cur.max<tmp.val){tmp.cur.max=tmp.val}if(tmp.cur.min==null){tmp.cur.min=tmp.val}else if(tmp.cur.min>tmp.val){tmp.cur.min=tmp.val}}'.format(groupfield, datefield, key, type === 'hourly' ? 'yyyyMMddHH' : type === 'monthly' ? 'yyyyMM' : type === 'yearly' ? 'yyyy' : 'yyyyMMdd');\n\tbuilder.options.scalararg = {};\n\treturn builder;\n};\n\nexports.reader = function(items) {\n\tvar instance = new Reader();\n\tif (items) {\n\t\tinstance.push(items);\n\t\tinstance.push(null);\n\t}\n\treturn instance;\n};\n\nglobal.WAIT = function(fnValid, fnCallback, timeout, interval) {\n\n\tif (fnValid() === true)\n\t\treturn fnCallback(null, true);\n\n\tvar id_timeout = null;\n\tvar id_interval = setInterval(function() {\n\n\t\tif (fnValid() === true) {\n\t\t\tclearInterval(id_interval);\n\t\t\tclearTimeout(id_timeout);\n\t\t\tfnCallback && fnCallback(null, true);\n\t\t}\n\n\t}, interval || 500);\n\n\tid_timeout = setTimeout(function() {\n\t\tclearInterval(id_interval);\n\t\tfnCallback && fnCallback(new Error('Timeout.'), false);\n\t}, timeout || 5000);\n};\n\n// Author: Peter \u0160irka\n// License: MIT\nfunction MultipartParser(multipart, stream, callback) {\n\n\tif (UPLOADINDEXER > 9999999999)\n\t\tUPLOADINDEXER = 1;\n\n\tvar self = this;\n\n\tself.buffer = null;\n\tself.header = Buffer.from(multipart, 'ascii');\n\tself.length = self.header.length;\n\tself.tmp = PATH.temp((F.clusterid || '') + 'upload_');\n\n\t// 0: nothing\n\t// 1: head\n\t// 2: data\n\t// 3: file\n\tself.step = 0;\n\n\t// Meta data\n\tself.sizes = { total: 0, files: 0, data: 0, parts: 0 };\n\tself.limits = { total: 0, files: 0, data: 0, parts: 0 };\n\tself.current = {};\n\tself.body = {};\n\tself.files = [];\n\tself.size = 0;\n\n\tself.ondata = function(chunk) {\n\t\tself.size += chunk.length;\n\t\tif (self.buffer) {\n\t\t\tCONCAT[0] = self.buffer;\n\t\t\tCONCAT[1] = chunk;\n\t\t\tself.buffer = Buffer.concat(CONCAT);\n\t\t\tself.parse(1);\n\t\t} else {\n\t\t\tself.buffer = chunk;\n\t\t\tself.parse(0);\n\t\t}\n\t};\n\n\tself.onend = function() {\n\t\tself.isend = true;\n\t\tself.checkready();\n\t};\n\n\tself.onclose = () => self.free('3: Request closed');\n\tself.callback = callback;\n\tself.stream = stream;\n\tself.stream.on('data', self.ondata);\n\tself.stream.on('end', self.onend);\n\t// self.stream.on('close', self.onclose);\n\tself.stream.on('abort', self.onclose);\n}\n\nMultipartParser.prototype.free = function(err) {\n\tvar self = this;\n\n\tif (!self.stream)\n\t\treturn;\n\n\tself.stream.removeListener('data', self.ondata);\n\tself.stream.removeListener('end', self.onend);\n\t// self.stream.removeListener('close', self.onclose);\n\tself.stream.removeListener('abort', self.onclose);\n\tself.current.stream && self.current.stream.end();\n\tself.stream = null;\n\tself.buffer = null;\n\tself.callback && self.callback(err, self);\n};\n\nMultipartParser.prototype.parse = function(type) {\n\tvar self = this;\n\tswitch (self.step) {\n\t\tcase 0: // no data, tries to parse meta\n\t\t\tself.parse_meta(type);\n\t\t\tbreak;\n\t\tcase 1: // part found\n\t\t\tself.parse_head();\n\t\t\tbreak;\n\t\tcase 2: // part data\n\t\t\tself.parse_data();\n\t\t\tbreak;\n\t\tcase 3: // part file\n\t\t\tself.parse_file();\n\t\t\tbreak;\n\t}\n};\n\nMultipartParser.prototype.parse_meta = function(type) {\n\n\tvar self = this;\n\n\tvar fromindex = type === 1 ? (self.buffer.length - self.header.length) : 0;\n\tif (fromindex < 0)\n\t\tfromindex = 0;\n\n\tvar index = type === 2 ? 0 : self.buffer.indexOf(self.header, fromindex);\n\n\tif (index === -1)\n\t\treturn;\n\n\t// Is end?\n\tif (self.buffer[index + self.length - 1] === 45) {\n\t\tself.current.stream && self.current.stream.end();\n\t\tself.current.stream = null;\n\t\treturn;\n\t}\n\n\tself.sizes.parts++;\n\n\tif (self.limits.parts && self.sizes.parts > self.limits.parts) {\n\t\tself.kill('1: Count of parts is too large');\n\t\treturn;\n\t}\n\n\tself.buffer = self.buffer.slice(self.length + 2);\n\tself.step = 1;\n\tself.parse();\n\n};\n\nMultipartParser.prototype.kill = function(err) {\n\tthis.free(err);\n};\n\nvar multipartfileready = function() {\n\tthis.$mpfile.ready = true;\n\tthis.$mpfile = null;\n\tthis.$mpinstance.checkready();\n\tthis.$mpinstance = null;\n};\n\nMultipartParser.prototype.checkready = function() {\n\n\tvar self = this;\n\n\tif (!self.stream || !self.isend)\n\t\treturn;\n\n\tfor (var i = 0; i < self.files.length; i++) {\n\t\tif (!self.files[i].ready)\n\t\t\treturn;\n\t}\n\n\tself.free();\n};\n\nMultipartParser.prototype.parse_head = function() {\n\n\tvar self = this;\n\tvar index = self.buffer.indexOf(HEADEREND);\n\n\tif (index === -1)\n\t\treturn;\n\n\tvar header = self.buffer.slice(0, index).toString('utf8').trim();\n\tif (header.substring(0, HEADERCHECK.length).toLowerCase() !== HEADERCHECK) {\n\t\tself.kill('7:');\n\t\treturn;\n\t}\n\n\theader = header.substring(HEADERCHECK.length).trim();\n\n\tvar beg = header.indexOf('filename=\"');\n\tvar isfile = beg !== -1;\n\n\tself.current.filename = isfile ? header.substring(beg + 10, header.indexOf('\"', beg + 10)).trim() : null;\n\n\tif (isfile && !self.current.filename)\n\t\treturn;\n\n\tbeg = header.indexOf('name=\"');\n\tif (beg === -1) {\n\t\tself.kill('2: Invalid part header');\n\t\treturn;\n\t}\n\n\tself.current.name = header.substring(beg + 6, header.indexOf('\"', beg + 6));\n\tself.current.size = 0;\n\n\tif (isfile) {\n\n\t\tif (REG_EMPTYBUFFER_TEST.test(self.current.filename))\n\t\t\tself.current.filename = self.current.filename.replace(REG_EMPTYBUFFER, '');\n\n\t\tvar type = header.match(/content-type:\\s.*?((\\r\\n)|$)/i);\n\t\tif (type) {\n\t\t\tself.current.type = type[0].substring(14);\n\t\t\tself.current.width = 0;\n\t\t\tself.current.height = 0;\n\t\t\tswitch (self.current.type) {\n\t\t\t\tcase 'image/svg+xml':\n\t\t\t\tcase 'image/svg':\n\t\t\t\t\tself.current.measure = 'measureSVG';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'image/jpeg':\n\t\t\t\tcase 'image/jpg':\n\t\t\t\t\tself.current.measure = 'measureJPG';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'image/png':\n\t\t\t\t\tself.current.measure = 'measurePNG';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'image/gif':\n\t\t\t\t\tself.current.measure = 'measureGIF';\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tself.current.measure = null;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (self.current.stream) {\n\t\t\tself.current.stream.end();\n\t\t\tself.current.stream = null;\n\t\t}\n\n\t\tif (!type) {\n\t\t\tself.kill('2: Invalid part header');\n\t\t\treturn;\n\t\t}\n\n\t\tself.current.path = self.tmp + (UPLOADINDEXER++) + '.bin';\n\t\tself.current.stream = Fs.createWriteStream(self.current.path);\n\t\tvar file = { path: self.current.path, name: self.current.name, filename: self.current.filename, size: 0, type: self.current.type, width: 0, height: 0 };\n\t\tself.current.file = file;\n\t\tself.current.stream.$mpfile = file;\n\t\tself.current.stream.$mpinstance = self;\n\t\tself.current.stream.on('close', multipartfileready);\n\t} else\n\t\tself.current.file = null;\n\n\tself.buffer = self.buffer.slice(index + HEADEREND.length);\n\tself.step = isfile ? 3 : 2;\n\tself.current.size = 0;\n\tself.parse();\n};\n\nMultipartParser.prototype.parse_file = function() {\n\n\tvar self = this;\n\tvar index = self.buffer.indexOf(self.header);\n\tvar tmp;\n\n\tif (self.current.measure) {\n\t\ttmp = framework_image[self.current.measure](self.buffer);\n\t\tif (tmp) {\n\t\t\tself.current.file.width = tmp.width;\n\t\t\tself.current.file.height = tmp.height;\n\t\t}\n\t\tself.current.measure = null;\n\t}\n\n\tif (index !== -1) {\n\n\t\tself.current.size += index - 4;\n\t\tself.current.file.size += index - 4;\n\t\tself.sizes.total += index - 4;\n\t\tself.sizes.files += index - 4;\n\n\t\tif (self.limits.files && self.sizes.files > self.limits.files) {\n\t\t\tself.kill('4: File body is too large');\n\t\t\treturn;\n\t\t}\n\n\t\tif (self.limits.total && self.sizes.total > self.limits.total) {\n\t\t\tself.kill('6: Stream is too large');\n\t\t\treturn;\n\t\t}\n\n\t\tvar data = self.buffer.slice(0, index - 4);\n\t\tself.current.stream.end(data);\n\t\tself.current.stream = null;\n\t\tself.files.push(self.current.file);\n\t\tself.buffer = self.buffer.slice(index);\n\t\tself.current.file = null;\n\t\tself.step = 0;\n\t\tself.parse(2);\n\n\t} else {\n\n\t\tvar length = self.buffer.length;\n\n\t\tself.current.size += length;\n\t\tself.current.file.size += length;\n\t\tself.sizes.total += length;\n\t\tself.sizes.files += length;\n\n\t\tif (self.limits.files && self.sizes.files > self.limits.files) {\n\t\t\tself.kill('4: File body is too large');\n\t\t\treturn;\n\t\t}\n\n\t\tif (self.limits.total && self.sizes.total > self.limits.total) {\n\t\t\tself.kill('6: Stream is too large');\n\t\t\treturn;\n\t\t}\n\n\t\tself.current.stream.write(self.buffer);\n\t\tself.buffer = null;\n\t}\n};\n\nMultipartParser.prototype.parse_data = function() {\n\tvar self = this;\n\tvar index = self.buffer.indexOf(self.header);\n\n\tif (index !== -1) {\n\n\t\tself.sizes.total += index - 2;\n\t\tself.sizes.data += index - 2;\n\n\t\tif (self.limits.data && self.sizes.data > self.limits.data) {\n\t\t\tself.kill('5: Data are too large');\n\t\t\treturn;\n\t\t}\n\n\t\tif (self.limits.total && self.sizes.total > self.limits.total) {\n\t\t\tself.kill('6: Stream is too large');\n\t\t\treturn;\n\t\t}\n\n\t\tvar val = self.buffer.slice(0, index - 4).toString('utf8');\n\n\t\tif (REG_EMPTYBUFFER_TEST.test(val))\n\t\t\tval = val.replace(REG_EMPTYBUFFER, '');\n\n\t\tself.body[self.current.name] = val;\n\t\tself.buffer = self.buffer.slice(index);\n\t\tself.step = 0;\n\t\tself.parse(true);\n\n\t} else {\n\n\t\tself.current.size += self.buffer.length;\n\n\t\tif (self.limits.data && self.current.size > self.limits.data) {\n\t\t\tself.kill('5: Data are too large');\n\t\t\treturn;\n\t\t}\n\n\t\tif (self.limits.total && (self.sizes.total + self.current.size) > self.limits.total) {\n\t\t\tself.kill('6: Stream is too large');\n\t\t\treturn;\n\t\t}\n\n\t}\n};\n\nvar measuring = {};\n\nfunction showtime(name) {\n\n\tvar arr = measuring[name];\n\tvar min = null;\n\tvar max = null;\n\tvar sum = 0;\n\n\tfor (var i = 0; i < arr.length; i++) {\n\n\t\tvar val = arr[i];\n\n\t\tif (min == null || min > val)\n\t\t\tmin = val;\n\n\t\tif (max == null || max < val)\n\t\t\tmax = val;\n\n\t\tsum += val;\n\t}\n\n\tconsole.log(name, 'avg:', (sum / arr.length).floor(2), 'max:', max, 'min:', min);\n}\n\nexports.measure = function(name, timeout) {\n\tvar key = '_' + name;\n\tif (measuring[key]) {\n\t\tvar diff = Date.now() - measuring[key];\n\t\tif (!measuring[name])\n\t\t\tmeasuring[name] = [];\n\t\tmeasuring[name].push(diff);\n\t\tmeasuring[key] = 0;\n\t} else\n\t\tmeasuring[key] = Date.now();\n\tsetTimeout(showtime, timeout || 1000, name);\n};\n\nexports.multipartparser = function(multipart, stream, callback) {\n\treturn new MultipartParser(multipart, stream, callback);\n};\n\nvar QUERIFYMETHODS = { GET: 1, POST: 1, DELETE: 1, PUT: 1, PATCH: 1, API: 1 };\n\nglobal.QUERIFY = function(url, obj) {\n\n\tif (typeof(url) !== 'string') {\n\t\tobj = url;\n\t\turl = '';\n\t}\n\n\tif (!obj)\n\t\treturn url;\n\n\tvar arg = [];\n\tvar keys = Object.keys(obj);\n\n\tfor (var i = 0; i < keys.length; i++) {\n\n\t\tvar key = keys[i];\n\t\tvar val = obj[key];\n\t\tif (val != null) {\n\n\t\t\tif (val instanceof Date)\n\t\t\t\tval = val.toISOString();\n\t\t\telse if (val instanceof Array)\n\t\t\t\tval = val.join(',');\n\n\t\t\tval = val + '';\n\t\t\tval && arg.push(encodeURIComponent(key) + '=' + encodeURIComponent(val));\n\t\t}\n\t}\n\n\tif (url) {\n\t\tvar arr = url.split(' ');\n\t\tvar index = QUERIFYMETHODS[arr[0]] ? 1 : 0;\n\t\tarr[index] += (arr[index].indexOf('?') === -1 ? '?' : '&') + arg.join('&');\n\t\treturn arr.join(' ');\n\t}\n\n\treturn '?' + arg.join('&');\n};\n\nexports.connect = function(opt, callback) {\n\n\t// opt.secure {Boolean}\n\t// opt.host\n\t// opt.port\n\t// opt.timeout\n\n\tvar opt = CLONE(opt);\n\tvar tls = opt.tls;\n\tvar meta = {};\n\tvar timeout;\n\n\tmeta.opt = opt;\n\tmeta.tls = tls;\n\n\tdelete opt.tls;\n\n\tvar close = function() {\n\n\t\tif (meta.socket1) {\n\t\t\tmeta.socket1.removeAllListeners();\n\t\t\tmeta.socket1.end();\n\t\t\tmeta.socket1.destroy();\n\t\t\tmeta.socket1 = null;\n\t\t}\n\n\t\tif (meta.socket2) {\n\t\t\tmeta.socket2.removeAllListeners();\n\t\t\tmeta.socket2.end();\n\t\t\tmeta.socket2.destroy();\n\t\t\tmeta.socket2 = null;\n\t\t}\n\n\t};\n\n\tvar error = function(err) {\n\t\tcallback && callback(err);\n\t\tcallback = null;\n\t\tclose();\n\t};\n\n\tif (opt.timeout)\n\t\ttimeout = setTimeout(() => error(new Error('Timeout')), opt.timeout);\n\n\tmeta.destroy = meta.close = close;\n\tmeta.write = function(data) {\n\t\tmeta.socket.write(data);\n\t};\n\n\tmeta.ondata = function(fn) {\n\t\tmeta.socket.on('data', fn);\n\t};\n\n\tmeta.onend = function(fn) {\n\t\tmeta.socket.on('destroy', fn);\n\t};\n\n\tvar done = function() {\n\n\t\tif (!callback)\n\t\t\treturn;\n\n\t\tif (opt.tls) {\n\t\t\tif (!meta.socket2) {\n\t\t\t\ttls.socket = meta.socket1;\n\t\t\t\tmeta.socket2 = Tls.connect(tls, done);\n\t\t\t\tmeta.socket2.on('error', error);\n\t\t\t\tmeta.socket2.on('clientError', error);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tmeta.socket = meta.socket2 || meta.socket1;\n\t\ttimeout && clearTimeout(timeout);\n\t\ttimeout = null;\n\t\tcallback && callback(null, meta);\n\t\tcallback = null;\n\t};\n\n\tif (opt.secure)\n\t\tmeta.socket1 = Tls.connect(opt, done);\n\telse\n\t\tmeta.socket1 = Net.createConnection(opt.port, opt.host, done);\n\n\tmeta.socket1.on('error', error);\n\tmeta.socket1.on('clientError', error);\n};\n\nString.prototype.toJSONSchema = function(name, url) {\n\n\tvar obj = {};\n\tvar p = (url || CONF.url || 'https://schemas.totaljs.com/');\n\n\tif (p[p.length - 1] !== '/')\n\t\tp += '/';\n\n\tobj.$id = p + (name || (HASH(this) + '')) + '.json';\n\tobj.$schema = 'https://json-schema.org/draft/2020-12/schema';\n\tobj.type = 'object';\n\tobj.properties = {};\n\n\tvar prop = this.split(',');\n\tvar required = [];\n\n\tfor (var i = 0; i < prop.length; i++) {\n\n\t\tvar arr = prop[i].split(':');\n\t\tvar tmp;\n\n\t\tif (arr[0][0] === '!' || arr[0][0] === '*') {\n\t\t\t// required\n\t\t\tarr[0] = arr[0].substring(1);\n\t\t\trequired.push(arr[0]);\n\t\t}\n\n\t\tvar type = arr[1].toLowerCase().trim();\n\t\tvar size = 0;\n\t\tvar isarr = type[0] === '[';\n\t\tif (isarr)\n\t\t\ttype = type.substring(1, type.length - 1);\n\n\t\tvar index = type.indexOf('(');\n\t\tif (index !== -1) {\n\t\t\tsize = +type.substring(index + 1, type.length - 1).trim();\n\t\t\ttype = type.substring(0, index);\n\t\t}\n\n\t\tswitch (type) {\n\t\t\tcase 'string':\n\t\t\tcase 'uid':\n\t\t\t\ttmp = {};\n\t\t\t\tif (isarr) {\n\t\t\t\t\ttmp.type = 'array';\n\t\t\t\t\ttmp.items = { type: 'string' };\n\t\t\t\t\tif (size)\n\t\t\t\t\t\ttmp.items.maxLength = size;\n\t\t\t\t} else {\n\t\t\t\t\ttmp.type = 'string';\n\t\t\t\t\tif (size)\n\t\t\t\t\t\ttmp.maxLength = size;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'number':\n\t\t\tcase 'number2':\n\t\t\tcase 'float':\n\t\t\tcase 'decimal':\n\t\t\t\ttmp = {};\n\t\t\t\tif (isarr) {\n\t\t\t\t\ttmp.type = 'array';\n\t\t\t\t\ttmp.items = { type: 'number' };\n\t\t\t\t} else {\n\t\t\t\t\ttmp.type = 'number';\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'bool':\n\t\t\tcase 'boolean':\n\t\t\t\ttmp = {};\n\t\t\t\tif (isarr) {\n\t\t\t\t\ttmp.type = 'array';\n\t\t\t\t\ttmp.items = { type: 'boolean' };\n\t\t\t\t} else\n\t\t\t\t\ttmp.type = 'boolean';\n\t\t\t\tbreak;\n\t\t\tcase 'date':\n\t\t\t\ttmp = {};\n\t\t\t\tif (isarr) {\n\t\t\t\t\ttmp.type = 'array';\n\t\t\t\t\ttmp.items = { type: 'date' };\n\t\t\t\t} else\n\t\t\t\t\ttmp.type = 'date';\n\t\t\t\tbreak;\n\t\t}\n\t\tif (tmp)\n\t\t\tobj.properties[arr[0].trim()] = tmp;\n\t}\n\n\tif (required.length)\n\t\tobj.required = required;\n\n\treturn obj;\n};\n\n!global.F && require('./index');"], "filenames": ["changelog.txt", "utils.js"], "buggy_code_start_loc": [5, 5206], "buggy_code_end_loc": [5, 5563], "fixing_code_start_loc": [6, 5205], "fixing_code_end_loc": [10, 5418], "type": "CWE-94", "message": "The package total4 before 0.0.43 are vulnerable to Arbitrary Code Execution via the U.set() and U.get() functions.", "other": {"cve": {"id": "CVE-2021-23390", "sourceIdentifier": "report@snyk.io", "published": "2021-07-12T16:15:09.030", "lastModified": "2021-07-14T17:38:45.477", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The package total4 before 0.0.43 are vulnerable to Arbitrary Code Execution via the U.set() and U.get() functions."}, {"lang": "es", "value": "El paquete total4 versiones anteriores a 0.0.43, son vulnerables a una ejecuci\u00f3n de c\u00f3digo arbitrario por medio de las funciones U.set() y U.get()"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "report@snyk.io", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-94"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:totaljs:total4:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "0.0.43", "matchCriteriaId": "47233194-DF6F-400D-A2BB-E5B07141E828"}]}]}], "references": [{"url": "https://github.com/totaljs/framework4/blob/master/utils.js%23L5430-L5455", "source": "report@snyk.io", "tags": ["Broken Link"]}, {"url": "https://github.com/totaljs/framework4/commit/8a72d8c20f38bbcac031a76a51238aa528f68821", "source": "report@snyk.io", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://snyk.io/vuln/SNYK-JS-TOTAL4-1130527", "source": "report@snyk.io", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/totaljs/framework4/commit/8a72d8c20f38bbcac031a76a51238aa528f68821"}}