{"buggy_code": ["/*\n * Copyright \u00a9 2009 Dan Nicholson\n * Copyright \u00a9 2012 Intel Corporation\n * Copyright \u00a9 2012 Ran Benita <ran234@gmail.com>\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice (including the next\n * paragraph) shall be included in all copies or substantial portions of the\n * Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n *\n * Author: Dan Nicholson <dbn.lists@gmail.com>\n *         Daniel Stone <daniel@fooishbar.org>\n *         Ran Benita <ran234@gmail.com>\n */\n\n#include \"xkbcomp-priv.h\"\n\nstatic void\nComputeEffectiveMask(struct xkb_keymap *keymap, struct xkb_mods *mods)\n{\n    mods->mask = mod_mask_get_effective(keymap, mods->mods);\n}\n\nstatic void\nUpdateActionMods(struct xkb_keymap *keymap, union xkb_action *act,\n                 xkb_mod_mask_t modmap)\n{\n    switch (act->type) {\n    case ACTION_TYPE_MOD_SET:\n    case ACTION_TYPE_MOD_LATCH:\n    case ACTION_TYPE_MOD_LOCK:\n        if (act->mods.flags & ACTION_MODS_LOOKUP_MODMAP)\n            act->mods.mods.mods = modmap;\n        ComputeEffectiveMask(keymap, &act->mods.mods);\n        break;\n    default:\n        break;\n    }\n}\n\nstatic const struct xkb_sym_interpret default_interpret = {\n    .sym = XKB_KEY_NoSymbol,\n    .repeat = true,\n    .match = MATCH_ANY_OR_NONE,\n    .mods = 0,\n    .virtual_mod = XKB_MOD_INVALID,\n    .action = { .type = ACTION_TYPE_NONE },\n};\n\n/**\n * Find an interpretation which applies to this particular level, either by\n * finding an exact match for the symbol and modifier combination, or a\n * generic XKB_KEY_NoSymbol match.\n */\nstatic const struct xkb_sym_interpret *\nFindInterpForKey(struct xkb_keymap *keymap, const struct xkb_key *key,\n                 xkb_layout_index_t group, xkb_level_index_t level)\n{\n    const xkb_keysym_t *syms;\n    int num_syms;\n\n    num_syms = xkb_keymap_key_get_syms_by_level(keymap, key->keycode, group,\n                                                level, &syms);\n    if (num_syms == 0)\n        return NULL;\n\n    /*\n     * There may be multiple matchings interprets; we should always return\n     * the most specific. Here we rely on compat.c to set up the\n     * sym_interprets array from the most specific to the least specific,\n     * such that when we find a match we return immediately.\n     */\n    for (unsigned i = 0; i < keymap->num_sym_interprets; i++) {\n        const struct xkb_sym_interpret *interp = &keymap->sym_interprets[i];\n\n        xkb_mod_mask_t mods;\n        bool found = false;\n\n        if ((num_syms > 1 || interp->sym != syms[0]) &&\n            interp->sym != XKB_KEY_NoSymbol)\n            continue;\n\n        if (interp->level_one_only && level != 0)\n            mods = 0;\n        else\n            mods = key->modmap;\n\n        switch (interp->match) {\n        case MATCH_NONE:\n            found = !(interp->mods & mods);\n            break;\n        case MATCH_ANY_OR_NONE:\n            found = (!mods || (interp->mods & mods));\n            break;\n        case MATCH_ANY:\n            found = (interp->mods & mods);\n            break;\n        case MATCH_ALL:\n            found = ((interp->mods & mods) == interp->mods);\n            break;\n        case MATCH_EXACTLY:\n            found = (interp->mods == mods);\n            break;\n        }\n\n        if (found)\n            return interp;\n    }\n\n    return &default_interpret;\n}\n\nstatic bool\nApplyInterpsToKey(struct xkb_keymap *keymap, struct xkb_key *key)\n{\n    xkb_mod_mask_t vmodmap = 0;\n    xkb_layout_index_t group;\n    xkb_level_index_t level;\n\n    /* If we've been told not to bind interps to this key, then don't. */\n    if (key->explicit & EXPLICIT_INTERP)\n        return true;\n\n    for (group = 0; group < key->num_groups; group++) {\n        for (level = 0; level < XkbKeyNumLevels(key, group); level++) {\n            const struct xkb_sym_interpret *interp;\n\n            interp = FindInterpForKey(keymap, key, group, level);\n            if (!interp)\n                continue;\n\n            /* Infer default key behaviours from the base level. */\n            if (group == 0 && level == 0)\n                if (!(key->explicit & EXPLICIT_REPEAT) && interp->repeat)\n                    key->repeats = true;\n\n            if ((group == 0 && level == 0) || !interp->level_one_only)\n                if (interp->virtual_mod != XKB_MOD_INVALID)\n                    vmodmap |= (1u << interp->virtual_mod);\n\n            if (interp->action.type != ACTION_TYPE_NONE)\n                key->groups[group].levels[level].action = interp->action;\n        }\n    }\n\n    if (!(key->explicit & EXPLICIT_VMODMAP))\n        key->vmodmap = vmodmap;\n\n    return true;\n}\n\n/**\n * This collects a bunch of disparate functions which was done in the server\n * at various points that really should've been done within xkbcomp.  Turns out\n * your actions and types are a lot more useful when any of your modifiers\n * other than Shift actually do something ...\n */\nstatic bool\nUpdateDerivedKeymapFields(struct xkb_keymap *keymap)\n{\n    struct xkb_key *key;\n    struct xkb_mod *mod;\n    struct xkb_led *led;\n    unsigned int i, j;\n\n    /* Find all the interprets for the key and bind them to actions,\n     * which will also update the vmodmap. */\n    xkb_keys_foreach(key, keymap)\n        if (!ApplyInterpsToKey(keymap, key))\n            return false;\n\n    /* Update keymap->mods, the virtual -> real mod mapping. */\n    xkb_keys_foreach(key, keymap)\n        xkb_mods_enumerate(i, mod, &keymap->mods)\n            if (key->vmodmap & (1u << i))\n                mod->mapping |= key->modmap;\n\n    /* Now update the level masks for all the types to reflect the vmods. */\n    for (i = 0; i < keymap->num_types; i++) {\n        ComputeEffectiveMask(keymap, &keymap->types[i].mods);\n\n        for (j = 0; j < keymap->types[i].num_entries; j++) {\n            ComputeEffectiveMask(keymap, &keymap->types[i].entries[j].mods);\n            ComputeEffectiveMask(keymap, &keymap->types[i].entries[j].preserve);\n        }\n    }\n\n    /* Update action modifiers. */\n    xkb_keys_foreach(key, keymap)\n        for (i = 0; i < key->num_groups; i++)\n            for (j = 0; j < XkbKeyNumLevels(key, i); j++)\n                UpdateActionMods(keymap, &key->groups[i].levels[j].action,\n                                 key->modmap);\n\n    /* Update vmod -> led maps. */\n    xkb_leds_foreach(led, keymap)\n        ComputeEffectiveMask(keymap, &led->mods);\n\n    /* Find maximum number of groups out of all keys in the keymap. */\n    xkb_keys_foreach(key, keymap)\n        keymap->num_groups = MAX(keymap->num_groups, key->num_groups);\n\n    return true;\n}\n\ntypedef bool (*compile_file_fn)(XkbFile *file,\n                                struct xkb_keymap *keymap,\n                                enum merge_mode merge);\n\nstatic const compile_file_fn compile_file_fns[LAST_KEYMAP_FILE_TYPE + 1] = {\n    [FILE_TYPE_KEYCODES] = CompileKeycodes,\n    [FILE_TYPE_TYPES] = CompileKeyTypes,\n    [FILE_TYPE_COMPAT] = CompileCompatMap,\n    [FILE_TYPE_SYMBOLS] = CompileSymbols,\n};\n\nbool\nCompileKeymap(XkbFile *file, struct xkb_keymap *keymap, enum merge_mode merge)\n{\n    bool ok;\n    XkbFile *files[LAST_KEYMAP_FILE_TYPE + 1] = { NULL };\n    enum xkb_file_type type;\n    struct xkb_context *ctx = keymap->ctx;\n\n    /* Collect section files and check for duplicates. */\n    for (file = (XkbFile *) file->defs; file;\n         file = (XkbFile *) file->common.next) {\n        if (file->file_type < FIRST_KEYMAP_FILE_TYPE ||\n            file->file_type > LAST_KEYMAP_FILE_TYPE) {\n            log_err(ctx, \"Cannot define %s in a keymap file\\n\",\n                    xkb_file_type_to_string(file->file_type));\n            continue;\n        }\n\n        if (files[file->file_type]) {\n            log_err(ctx,\n                    \"More than one %s section in keymap file; \"\n                    \"All sections after the first ignored\\n\",\n                    xkb_file_type_to_string(file->file_type));\n            continue;\n        }\n\n        files[file->file_type] = file;\n    }\n\n    /*\n     * Check that all required section were provided.\n     * Report everything before failing.\n     */\n    ok = true;\n    for (type = FIRST_KEYMAP_FILE_TYPE;\n         type <= LAST_KEYMAP_FILE_TYPE;\n         type++) {\n        if (files[type] == NULL) {\n            log_err(ctx, \"Required section %s missing from keymap\\n\",\n                    xkb_file_type_to_string(type));\n            ok = false;\n        }\n    }\n    if (!ok)\n        return false;\n\n    /* Compile sections. */\n    for (type = FIRST_KEYMAP_FILE_TYPE;\n         type <= LAST_KEYMAP_FILE_TYPE;\n         type++) {\n        log_dbg(ctx, \"Compiling %s \\\"%s\\\"\\n\",\n                xkb_file_type_to_string(type), files[type]->name);\n\n        ok = compile_file_fns[type](files[type], keymap, merge);\n        if (!ok) {\n            log_err(ctx, \"Failed to compile %s\\n\",\n                    xkb_file_type_to_string(type));\n            return false;\n        }\n    }\n\n    return UpdateDerivedKeymapFields(keymap);\n}\n", "/************************************************************\n Copyright (c) 1994 by Silicon Graphics Computer Systems, Inc.\n\n Permission to use, copy, modify, and distribute this\n software and its documentation for any purpose and without\n fee is hereby granted, provided that the above copyright\n notice appear in all copies and that both that copyright\n notice and this permission notice appear in supporting\n documentation, and that the name of Silicon Graphics not be\n used in advertising or publicity pertaining to distribution\n of the software without specific prior written permission.\n Silicon Graphics makes no representation about the suitability\n of this software for any purpose. It is provided \"as is\"\n without any express or implied warranty.\n\n SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS\n SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\n AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL SILICON\n GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL\n DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,\n DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE\n OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION  WITH\n THE USE OR PERFORMANCE OF THIS SOFTWARE.\n\n ********************************************************/\n\n/*\n * The parser should work with reasonably recent versions of either\n * bison or byacc.  So if you make changes, try to make sure it works\n * in both!\n */\n\n%{\n#include \"xkbcomp/xkbcomp-priv.h\"\n#include \"xkbcomp/ast-build.h\"\n#include \"xkbcomp/parser-priv.h\"\n#include \"scanner-utils.h\"\n\nstruct parser_param {\n    struct xkb_context *ctx;\n    struct scanner *scanner;\n    XkbFile *rtrn;\n    bool more_maps;\n};\n\n#define parser_err(param, fmt, ...) \\\n    scanner_err((param)->scanner, fmt, ##__VA_ARGS__)\n\n#define parser_warn(param, fmt, ...) \\\n    scanner_warn((param)->scanner, fmt, ##__VA_ARGS__)\n\nstatic void\n_xkbcommon_error(struct parser_param *param, const char *msg)\n{\n    parser_err(param, \"%s\", msg);\n}\n\nstatic bool\nresolve_keysym(const char *name, xkb_keysym_t *sym_rtrn)\n{\n    xkb_keysym_t sym;\n\n    if (!name || istreq(name, \"any\") || istreq(name, \"nosymbol\")) {\n        *sym_rtrn = XKB_KEY_NoSymbol;\n        return true;\n    }\n\n    if (istreq(name, \"none\") || istreq(name, \"voidsymbol\")) {\n        *sym_rtrn = XKB_KEY_VoidSymbol;\n        return true;\n    }\n\n    sym = xkb_keysym_from_name(name, XKB_KEYSYM_NO_FLAGS);\n    if (sym != XKB_KEY_NoSymbol) {\n        *sym_rtrn = sym;\n        return true;\n    }\n\n    return false;\n}\n\n#define param_scanner param->scanner\n%}\n\n%pure-parser\n%lex-param      { struct scanner *param_scanner }\n%parse-param    { struct parser_param *param }\n\n%token\n        END_OF_FILE     0\n        ERROR_TOK       255\n        XKB_KEYMAP      1\n        XKB_KEYCODES    2\n        XKB_TYPES       3\n        XKB_SYMBOLS     4\n        XKB_COMPATMAP   5\n        XKB_GEOMETRY    6\n        XKB_SEMANTICS   7\n        XKB_LAYOUT      8\n        INCLUDE         10\n        OVERRIDE        11\n        AUGMENT         12\n        REPLACE         13\n        ALTERNATE       14\n        VIRTUAL_MODS    20\n        TYPE            21\n        INTERPRET       22\n        ACTION_TOK      23\n        KEY             24\n        ALIAS           25\n        GROUP           26\n        MODIFIER_MAP    27\n        INDICATOR       28\n        SHAPE           29\n        KEYS            30\n        ROW             31\n        SECTION         32\n        OVERLAY         33\n        TEXT            34\n        OUTLINE         35\n        SOLID           36\n        LOGO            37\n        VIRTUAL         38\n        EQUALS          40\n        PLUS            41\n        MINUS           42\n        DIVIDE          43\n        TIMES           44\n        OBRACE          45\n        CBRACE          46\n        OPAREN          47\n        CPAREN          48\n        OBRACKET        49\n        CBRACKET        50\n        DOT             51\n        COMMA           52\n        SEMI            53\n        EXCLAM          54\n        INVERT          55\n        STRING          60\n        INTEGER         61\n        FLOAT           62\n        IDENT           63\n        KEYNAME         64\n        PARTIAL         70\n        DEFAULT         71\n        HIDDEN          72\n        ALPHANUMERIC_KEYS       73\n        MODIFIER_KEYS           74\n        KEYPAD_KEYS             75\n        FUNCTION_KEYS           76\n        ALTERNATE_GROUP         77\n\n%right  EQUALS\n%left   PLUS MINUS\n%left   TIMES DIVIDE\n%left   EXCLAM INVERT\n%left   OPAREN\n\n%start  XkbFile\n\n%union  {\n        int              ival;\n        int64_t          num;\n        enum xkb_file_type file_type;\n        char            *str;\n        xkb_atom_t      atom;\n        enum merge_mode merge;\n        enum xkb_map_flags mapFlags;\n        xkb_keysym_t    keysym;\n        ParseCommon     *any;\n        ExprDef         *expr;\n        VarDef          *var;\n        VModDef         *vmod;\n        InterpDef       *interp;\n        KeyTypeDef      *keyType;\n        SymbolsDef      *syms;\n        ModMapDef       *modMask;\n        GroupCompatDef  *groupCompat;\n        LedMapDef       *ledMap;\n        LedNameDef      *ledName;\n        KeycodeDef      *keyCode;\n        KeyAliasDef     *keyAlias;\n        void            *geom;\n        XkbFile         *file;\n}\n\n%type <num>     INTEGER FLOAT\n%type <str>     IDENT STRING\n%type <atom>    KEYNAME\n%type <num>     KeyCode\n%type <ival>    Number Integer Float SignedNumber DoodadType\n%type <merge>   MergeMode OptMergeMode\n%type <file_type> XkbCompositeType FileType\n%type <mapFlags> Flag Flags OptFlags\n%type <str>     MapName OptMapName\n%type <atom>    FieldSpec Ident Element String\n%type <keysym>  KeySym\n%type <any>     DeclList Decl\n%type <expr>    OptExprList ExprList Expr Term Lhs Terminal ArrayInit KeySyms\n%type <expr>    OptKeySymList KeySymList Action ActionList Coord CoordList\n%type <var>     VarDecl VarDeclList SymbolsBody SymbolsVarDecl\n%type <vmod>    VModDecl VModDefList VModDef\n%type <interp>  InterpretDecl InterpretMatch\n%type <keyType> KeyTypeDecl\n%type <syms>    SymbolsDecl\n%type <modMask> ModMapDecl\n%type <groupCompat> GroupCompatDecl\n%type <ledMap>  LedMapDecl\n%type <ledName> LedNameDecl\n%type <keyCode> KeyNameDecl\n%type <keyAlias> KeyAliasDecl\n%type <geom>    ShapeDecl SectionDecl SectionBody SectionBodyItem RowBody RowBodyItem\n%type <geom>    Keys Key OverlayDecl OverlayKeyList OverlayKey OutlineList OutlineInList\n%type <geom>    DoodadDecl\n%type <file>    XkbFile XkbMapConfigList XkbMapConfig\n%type <file>    XkbCompositeMap\n\n%destructor { FreeStmt((ParseCommon *) $$); }\n    <any> <expr> <var> <vmod> <interp> <keyType> <syms> <modMask> <groupCompat>\n    <ledMap> <ledName> <keyCode> <keyAlias>\n/* The destructor also runs on the start symbol when the parser *succeeds*.\n * The `if` here catches this case. */\n%destructor { if (!param->rtrn) FreeXkbFile($$); } <file>\n%destructor { free($$); } <str>\n\n%%\n\n/*\n * An actual file may contain more than one map. However, if we do things\n * in the normal yacc way, i.e. aggregate all of the maps into a list and\n * let the caller find the map it wants, we end up scanning and parsing a\n * lot of unneeded maps (in the end we always just need one).\n * Instead of doing that, we make yyparse return one map at a time, and\n * then call it repeatedly until we find the map we need. Once we find it,\n * we don't need to parse everything that follows in the file.\n * This does mean that if we e.g. always use the first map, the file may\n * contain complete garbage after that. But it's worth it.\n */\n\nXkbFile         :       XkbCompositeMap\n                        { $$ = param->rtrn = $1; param->more_maps = true; }\n                |       XkbMapConfig\n                        { $$ = param->rtrn = $1; param->more_maps = true; YYACCEPT; }\n                |       END_OF_FILE\n                        { $$ = param->rtrn = NULL; param->more_maps = false; }\n                ;\n\nXkbCompositeMap :       OptFlags XkbCompositeType OptMapName OBRACE\n                            XkbMapConfigList\n                        CBRACE SEMI\n                        { $$ = XkbFileCreate($2, $3, (ParseCommon *) $5, $1); }\n                ;\n\nXkbCompositeType:       XKB_KEYMAP      { $$ = FILE_TYPE_KEYMAP; }\n                |       XKB_SEMANTICS   { $$ = FILE_TYPE_KEYMAP; }\n                |       XKB_LAYOUT      { $$ = FILE_TYPE_KEYMAP; }\n                ;\n\nXkbMapConfigList :      XkbMapConfigList XkbMapConfig\n                        {\n                            if (!$2)\n                                $$ = $1;\n                            else\n                                $$ = (XkbFile *) AppendStmt((ParseCommon *) $1,\n                                                            (ParseCommon *) $2);\n                        }\n                |       XkbMapConfig\n                        { $$ = $1; }\n                ;\n\nXkbMapConfig    :       OptFlags FileType OptMapName OBRACE\n                            DeclList\n                        CBRACE SEMI\n                        {\n                            if ($2 == FILE_TYPE_GEOMETRY) {\n                                free($3);\n                                FreeStmt($5);\n                                $$ = NULL;\n                            }\n                            else {\n                                $$ = XkbFileCreate($2, $3, $5, $1);\n                            }\n                        }\n                ;\n\nFileType        :       XKB_KEYCODES            { $$ = FILE_TYPE_KEYCODES; }\n                |       XKB_TYPES               { $$ = FILE_TYPE_TYPES; }\n                |       XKB_COMPATMAP           { $$ = FILE_TYPE_COMPAT; }\n                |       XKB_SYMBOLS             { $$ = FILE_TYPE_SYMBOLS; }\n                |       XKB_GEOMETRY            { $$ = FILE_TYPE_GEOMETRY; }\n                ;\n\nOptFlags        :       Flags                   { $$ = $1; }\n                |                               { $$ = 0; }\n                ;\n\nFlags           :       Flags Flag              { $$ = ($1 | $2); }\n                |       Flag                    { $$ = $1; }\n                ;\n\nFlag            :       PARTIAL                 { $$ = MAP_IS_PARTIAL; }\n                |       DEFAULT                 { $$ = MAP_IS_DEFAULT; }\n                |       HIDDEN                  { $$ = MAP_IS_HIDDEN; }\n                |       ALPHANUMERIC_KEYS       { $$ = MAP_HAS_ALPHANUMERIC; }\n                |       MODIFIER_KEYS           { $$ = MAP_HAS_MODIFIER; }\n                |       KEYPAD_KEYS             { $$ = MAP_HAS_KEYPAD; }\n                |       FUNCTION_KEYS           { $$ = MAP_HAS_FN; }\n                |       ALTERNATE_GROUP         { $$ = MAP_IS_ALTGR; }\n                ;\n\nDeclList        :       DeclList Decl\n                        { $$ = AppendStmt($1, $2); }\n                |       { $$ = NULL; }\n                ;\n\nDecl            :       OptMergeMode VarDecl\n                        {\n                            $2->merge = $1;\n                            $$ = (ParseCommon *) $2;\n                        }\n                |       OptMergeMode VModDecl\n                        {\n                            $2->merge = $1;\n                            $$ = (ParseCommon *) $2;\n                        }\n                |       OptMergeMode InterpretDecl\n                        {\n                            $2->merge = $1;\n                            $$ = (ParseCommon *) $2;\n                        }\n                |       OptMergeMode KeyNameDecl\n                        {\n                            $2->merge = $1;\n                            $$ = (ParseCommon *) $2;\n                        }\n                |       OptMergeMode KeyAliasDecl\n                        {\n                            $2->merge = $1;\n                            $$ = (ParseCommon *) $2;\n                        }\n                |       OptMergeMode KeyTypeDecl\n                        {\n                            $2->merge = $1;\n                            $$ = (ParseCommon *) $2;\n                        }\n                |       OptMergeMode SymbolsDecl\n                        {\n                            $2->merge = $1;\n                            $$ = (ParseCommon *) $2;\n                        }\n                |       OptMergeMode ModMapDecl\n                        {\n                            $2->merge = $1;\n                            $$ = (ParseCommon *) $2;\n                        }\n                |       OptMergeMode GroupCompatDecl\n                        {\n                            $2->merge = $1;\n                            $$ = (ParseCommon *) $2;\n                        }\n                |       OptMergeMode LedMapDecl\n                        {\n                            $2->merge = $1;\n                            $$ = (ParseCommon *) $2;\n                        }\n                |       OptMergeMode LedNameDecl\n                        {\n                            $2->merge = $1;\n                            $$ = (ParseCommon *) $2;\n                        }\n                |       OptMergeMode ShapeDecl          { $$ = NULL; }\n                |       OptMergeMode SectionDecl        { $$ = NULL; }\n                |       OptMergeMode DoodadDecl         { $$ = NULL; }\n                |       MergeMode STRING\n                        {\n                            $$ = (ParseCommon *) IncludeCreate(param->ctx, $2, $1);\n                            free($2);\n                        }\n                ;\n\nVarDecl         :       Lhs EQUALS Expr SEMI\n                        { $$ = VarCreate($1, $3); }\n                |       Ident SEMI\n                        { $$ = BoolVarCreate($1, true); }\n                |       EXCLAM Ident SEMI\n                        { $$ = BoolVarCreate($2, false); }\n                ;\n\nKeyNameDecl     :       KEYNAME EQUALS KeyCode SEMI\n                        { $$ = KeycodeCreate($1, $3); }\n                ;\n\nKeyAliasDecl    :       ALIAS KEYNAME EQUALS KEYNAME SEMI\n                        { $$ = KeyAliasCreate($2, $4); }\n                ;\n\nVModDecl        :       VIRTUAL_MODS VModDefList SEMI\n                        { $$ = $2; }\n                ;\n\nVModDefList     :       VModDefList COMMA VModDef\n                        { $$ = (VModDef *) AppendStmt((ParseCommon *) $1,\n                                                      (ParseCommon *) $3); }\n                |       VModDef\n                        { $$ = $1; }\n                ;\n\nVModDef         :       Ident\n                        { $$ = VModCreate($1, NULL); }\n                |       Ident EQUALS Expr\n                        { $$ = VModCreate($1, $3); }\n                ;\n\nInterpretDecl   :       INTERPRET InterpretMatch OBRACE\n                            VarDeclList\n                        CBRACE SEMI\n                        { $2->def = $4; $$ = $2; }\n                ;\n\nInterpretMatch  :       KeySym PLUS Expr\n                        { $$ = InterpCreate($1, $3); }\n                |       KeySym\n                        { $$ = InterpCreate($1, NULL); }\n                ;\n\nVarDeclList     :       VarDeclList VarDecl\n                        { $$ = (VarDef *) AppendStmt((ParseCommon *) $1,\n                                                     (ParseCommon *) $2); }\n                |       VarDecl\n                        { $$ = $1; }\n                ;\n\nKeyTypeDecl     :       TYPE String OBRACE\n                            VarDeclList\n                        CBRACE SEMI\n                        { $$ = KeyTypeCreate($2, $4); }\n                ;\n\nSymbolsDecl     :       KEY KEYNAME OBRACE\n                            SymbolsBody\n                        CBRACE SEMI\n                        { $$ = SymbolsCreate($2, $4); }\n                ;\n\nSymbolsBody     :       SymbolsBody COMMA SymbolsVarDecl\n                        { $$ = (VarDef *) AppendStmt((ParseCommon *) $1,\n                                                     (ParseCommon *) $3); }\n                |       SymbolsVarDecl\n                        { $$ = $1; }\n                |       { $$ = NULL; }\n                ;\n\nSymbolsVarDecl  :       Lhs EQUALS Expr         { $$ = VarCreate($1, $3); }\n                |       Lhs EQUALS ArrayInit    { $$ = VarCreate($1, $3); }\n                |       Ident                   { $$ = BoolVarCreate($1, true); }\n                |       EXCLAM Ident            { $$ = BoolVarCreate($2, false); }\n                |       ArrayInit               { $$ = VarCreate(NULL, $1); }\n                ;\n\nArrayInit       :       OBRACKET OptKeySymList CBRACKET\n                        { $$ = $2; }\n                |       OBRACKET ActionList CBRACKET\n                        { $$ = ExprCreateUnary(EXPR_ACTION_LIST, EXPR_TYPE_ACTION, $2); }\n                ;\n\nGroupCompatDecl :       GROUP Integer EQUALS Expr SEMI\n                        { $$ = GroupCompatCreate($2, $4); }\n                ;\n\nModMapDecl      :       MODIFIER_MAP Ident OBRACE ExprList CBRACE SEMI\n                        { $$ = ModMapCreate($2, $4); }\n                ;\n\nLedMapDecl:             INDICATOR String OBRACE VarDeclList CBRACE SEMI\n                        { $$ = LedMapCreate($2, $4); }\n                ;\n\nLedNameDecl:            INDICATOR Integer EQUALS Expr SEMI\n                        { $$ = LedNameCreate($2, $4, false); }\n                |       VIRTUAL INDICATOR Integer EQUALS Expr SEMI\n                        { $$ = LedNameCreate($3, $5, true); }\n                ;\n\nShapeDecl       :       SHAPE String OBRACE OutlineList CBRACE SEMI\n                        { $$ = NULL; }\n                |       SHAPE String OBRACE CoordList CBRACE SEMI\n                        { (void) $4; $$ = NULL; }\n                ;\n\nSectionDecl     :       SECTION String OBRACE SectionBody CBRACE SEMI\n                        { $$ = NULL; }\n                ;\n\nSectionBody     :       SectionBody SectionBodyItem     { $$ = NULL;}\n                |       SectionBodyItem                 { $$ = NULL; }\n                ;\n\nSectionBodyItem :       ROW OBRACE RowBody CBRACE SEMI\n                        { $$ = NULL; }\n                |       VarDecl\n                        { FreeStmt((ParseCommon *) $1); $$ = NULL; }\n                |       DoodadDecl\n                        { $$ = NULL; }\n                |       LedMapDecl\n                        { FreeStmt((ParseCommon *) $1); $$ = NULL; }\n                |       OverlayDecl\n                        { $$ = NULL; }\n                ;\n\nRowBody         :       RowBody RowBodyItem     { $$ = NULL;}\n                |       RowBodyItem             { $$ = NULL; }\n                ;\n\nRowBodyItem     :       KEYS OBRACE Keys CBRACE SEMI { $$ = NULL; }\n                |       VarDecl\n                        { FreeStmt((ParseCommon *) $1); $$ = NULL; }\n                ;\n\nKeys            :       Keys COMMA Key          { $$ = NULL; }\n                |       Key                     { $$ = NULL; }\n                ;\n\nKey             :       KEYNAME\n                        { $$ = NULL; }\n                |       OBRACE ExprList CBRACE\n                        { FreeStmt((ParseCommon *) $2); $$ = NULL; }\n                ;\n\nOverlayDecl     :       OVERLAY String OBRACE OverlayKeyList CBRACE SEMI\n                        { $$ = NULL; }\n                ;\n\nOverlayKeyList  :       OverlayKeyList COMMA OverlayKey { $$ = NULL; }\n                |       OverlayKey                      { $$ = NULL; }\n                ;\n\nOverlayKey      :       KEYNAME EQUALS KEYNAME          { $$ = NULL; }\n                ;\n\nOutlineList     :       OutlineList COMMA OutlineInList\n                        { $$ = NULL;}\n                |       OutlineInList\n                        { $$ = NULL; }\n                ;\n\nOutlineInList   :       OBRACE CoordList CBRACE\n                        { (void) $2; $$ = NULL; }\n                |       Ident EQUALS OBRACE CoordList CBRACE\n                        { (void) $4; $$ = NULL; }\n                |       Ident EQUALS Expr\n                        { FreeStmt((ParseCommon *) $3); $$ = NULL; }\n                ;\n\nCoordList       :       CoordList COMMA Coord\n                        { (void) $1; (void) $3; $$ = NULL; }\n                |       Coord\n                        { (void) $1; $$ = NULL; }\n                ;\n\nCoord           :       OBRACKET SignedNumber COMMA SignedNumber CBRACKET\n                        { $$ = NULL; }\n                ;\n\nDoodadDecl      :       DoodadType String OBRACE VarDeclList CBRACE SEMI\n                        { FreeStmt((ParseCommon *) $4); $$ = NULL; }\n                ;\n\nDoodadType      :       TEXT    { $$ = 0; }\n                |       OUTLINE { $$ = 0; }\n                |       SOLID   { $$ = 0; }\n                |       LOGO    { $$ = 0; }\n                ;\n\nFieldSpec       :       Ident   { $$ = $1; }\n                |       Element { $$ = $1; }\n                ;\n\nElement         :       ACTION_TOK\n                        { $$ = xkb_atom_intern_literal(param->ctx, \"action\"); }\n                |       INTERPRET\n                        { $$ = xkb_atom_intern_literal(param->ctx, \"interpret\"); }\n                |       TYPE\n                        { $$ = xkb_atom_intern_literal(param->ctx, \"type\"); }\n                |       KEY\n                        { $$ = xkb_atom_intern_literal(param->ctx, \"key\"); }\n                |       GROUP\n                        { $$ = xkb_atom_intern_literal(param->ctx, \"group\"); }\n                |       MODIFIER_MAP\n                        {$$ = xkb_atom_intern_literal(param->ctx, \"modifier_map\");}\n                |       INDICATOR\n                        { $$ = xkb_atom_intern_literal(param->ctx, \"indicator\"); }\n                |       SHAPE\n                        { $$ = xkb_atom_intern_literal(param->ctx, \"shape\"); }\n                |       ROW\n                        { $$ = xkb_atom_intern_literal(param->ctx, \"row\"); }\n                |       SECTION\n                        { $$ = xkb_atom_intern_literal(param->ctx, \"section\"); }\n                |       TEXT\n                        { $$ = xkb_atom_intern_literal(param->ctx, \"text\"); }\n                ;\n\nOptMergeMode    :       MergeMode       { $$ = $1; }\n                |                       { $$ = MERGE_DEFAULT; }\n                ;\n\nMergeMode       :       INCLUDE         { $$ = MERGE_DEFAULT; }\n                |       AUGMENT         { $$ = MERGE_AUGMENT; }\n                |       OVERRIDE        { $$ = MERGE_OVERRIDE; }\n                |       REPLACE         { $$ = MERGE_REPLACE; }\n                |       ALTERNATE\n                {\n                    /*\n                     * This used to be MERGE_ALT_FORM. This functionality was\n                     * unused and has been removed.\n                     */\n                    $$ = MERGE_DEFAULT;\n                }\n                ;\n\nOptExprList     :       ExprList        { $$ = $1; }\n                |                       { $$ = NULL; }\n                ;\n\nExprList        :       ExprList COMMA Expr\n                        { $$ = (ExprDef *) AppendStmt((ParseCommon *) $1,\n                                                      (ParseCommon *) $3); }\n                |       Expr\n                        { $$ = $1; }\n                ;\n\nExpr            :       Expr DIVIDE Expr\n                        { $$ = ExprCreateBinary(EXPR_DIVIDE, $1, $3); }\n                |       Expr PLUS Expr\n                        { $$ = ExprCreateBinary(EXPR_ADD, $1, $3); }\n                |       Expr MINUS Expr\n                        { $$ = ExprCreateBinary(EXPR_SUBTRACT, $1, $3); }\n                |       Expr TIMES Expr\n                        { $$ = ExprCreateBinary(EXPR_MULTIPLY, $1, $3); }\n                |       Lhs EQUALS Expr\n                        { $$ = ExprCreateBinary(EXPR_ASSIGN, $1, $3); }\n                |       Term\n                        { $$ = $1; }\n                ;\n\nTerm            :       MINUS Term\n                        { $$ = ExprCreateUnary(EXPR_NEGATE, $2->expr.value_type, $2); }\n                |       PLUS Term\n                        { $$ = ExprCreateUnary(EXPR_UNARY_PLUS, $2->expr.value_type, $2); }\n                |       EXCLAM Term\n                        { $$ = ExprCreateUnary(EXPR_NOT, EXPR_TYPE_BOOLEAN, $2); }\n                |       INVERT Term\n                        { $$ = ExprCreateUnary(EXPR_INVERT, $2->expr.value_type, $2); }\n                |       Lhs\n                        { $$ = $1;  }\n                |       FieldSpec OPAREN OptExprList CPAREN %prec OPAREN\n                        { $$ = ExprCreateAction($1, $3); }\n                |       Terminal\n                        { $$ = $1;  }\n                |       OPAREN Expr CPAREN\n                        { $$ = $2;  }\n                ;\n\nActionList      :       ActionList COMMA Action\n                        { $$ = (ExprDef *) AppendStmt((ParseCommon *) $1,\n                                                      (ParseCommon *) $3); }\n                |       Action\n                        { $$ = $1; }\n                ;\n\nAction          :       FieldSpec OPAREN OptExprList CPAREN\n                        { $$ = ExprCreateAction($1, $3); }\n                ;\n\nLhs             :       FieldSpec\n                        { $$ = ExprCreateIdent($1); }\n                |       FieldSpec DOT FieldSpec\n                        { $$ = ExprCreateFieldRef($1, $3); }\n                |       FieldSpec OBRACKET Expr CBRACKET\n                        { $$ = ExprCreateArrayRef(XKB_ATOM_NONE, $1, $3); }\n                |       FieldSpec DOT FieldSpec OBRACKET Expr CBRACKET\n                        { $$ = ExprCreateArrayRef($1, $3, $5); }\n                ;\n\nTerminal        :       String\n                        { $$ = ExprCreateString($1); }\n                |       Integer\n                        { $$ = ExprCreateInteger($1); }\n                |       Float\n                        { $$ = ExprCreateFloat(/* Discard $1 */); }\n                |       KEYNAME\n                        { $$ = ExprCreateKeyName($1); }\n                ;\n\nOptKeySymList   :       KeySymList      { $$ = $1; }\n                |                       { $$ = NULL; }\n                ;\n\nKeySymList      :       KeySymList COMMA KeySym\n                        { $$ = ExprAppendKeysymList($1, $3); }\n                |       KeySymList COMMA KeySyms\n                        { $$ = ExprAppendMultiKeysymList($1, $3); }\n                |       KeySym\n                        { $$ = ExprCreateKeysymList($1); }\n                |       KeySyms\n                        { $$ = ExprCreateMultiKeysymList($1); }\n                ;\n\nKeySyms         :       OBRACE KeySymList CBRACE\n                        { $$ = $2; }\n                ;\n\nKeySym          :       IDENT\n                        {\n                            if (!resolve_keysym($1, &$$))\n                                parser_warn(param, \"unrecognized keysym \\\"%s\\\"\", $1);\n                            free($1);\n                        }\n                |       SECTION { $$ = XKB_KEY_section; }\n                |       Integer\n                        {\n                            if ($1 < 0) {\n                                parser_warn(param, \"unrecognized keysym \\\"%d\\\"\", $1);\n                                $$ = XKB_KEY_NoSymbol;\n                            }\n                            else if ($1 < 10) {      /* XKB_KEY_0 .. XKB_KEY_9 */\n                                $$ = XKB_KEY_0 + (xkb_keysym_t) $1;\n                            }\n                            else {\n                                char buf[17];\n                                snprintf(buf, sizeof(buf), \"0x%x\", $1);\n                                if (!resolve_keysym(buf, &$$)) {\n                                    parser_warn(param, \"unrecognized keysym \\\"%s\\\"\", buf);\n                                    $$ = XKB_KEY_NoSymbol;\n                                }\n                            }\n                        }\n                ;\n\nSignedNumber    :       MINUS Number    { $$ = -$2; }\n                |       Number          { $$ = $1; }\n                ;\n\nNumber          :       FLOAT   { $$ = $1; }\n                |       INTEGER { $$ = $1; }\n                ;\n\nFloat           :       FLOAT   { $$ = 0; }\n                ;\n\nInteger         :       INTEGER { $$ = $1; }\n                ;\n\nKeyCode         :       INTEGER { $$ = $1; }\n                ;\n\nIdent           :       IDENT   { $$ = xkb_atom_steal(param->ctx, $1); }\n                |       DEFAULT { $$ = xkb_atom_intern_literal(param->ctx, \"default\"); }\n                ;\n\nString          :       STRING  { $$ = xkb_atom_steal(param->ctx, $1); }\n                ;\n\nOptMapName      :       MapName { $$ = $1; }\n                |               { $$ = NULL; }\n                ;\n\nMapName         :       STRING  { $$ = $1; }\n                ;\n\n%%\n\nXkbFile *\nparse(struct xkb_context *ctx, struct scanner *scanner, const char *map)\n{\n    int ret;\n    XkbFile *first = NULL;\n    struct parser_param param = {\n        .scanner = scanner,\n        .ctx = ctx,\n        .rtrn = NULL,\n    };\n\n    /*\n     * If we got a specific map, we look for it exclusively and return\n     * immediately upon finding it. Otherwise, we need to get the\n     * default map. If we find a map marked as default, we return it\n     * immediately. If there are no maps marked as default, we return\n     * the first map in the file.\n     */\n\n    while ((ret = yyparse(&param)) == 0 && param.more_maps) {\n        if (map) {\n            if (streq_not_null(map, param.rtrn->name))\n                return param.rtrn;\n            else\n                FreeXkbFile(param.rtrn);\n        }\n        else {\n            if (param.rtrn->flags & MAP_IS_DEFAULT) {\n                FreeXkbFile(first);\n                return param.rtrn;\n            }\n            else if (!first) {\n                first = param.rtrn;\n            }\n            else {\n                FreeXkbFile(param.rtrn);\n            }\n        }\n        param.rtrn = NULL;\n    }\n\n    if (ret != 0) {\n        FreeXkbFile(first);\n        return NULL;\n    }\n\n    if (first)\n        log_vrb(ctx, 5,\n                \"No map in include statement, but \\\"%s\\\" contains several; \"\n                \"Using first defined map, \\\"%s\\\"\\n\",\n                scanner->file_name, first->name);\n\n    return first;\n}\n"], "fixing_code": ["/*\n * Copyright \u00a9 2009 Dan Nicholson\n * Copyright \u00a9 2012 Intel Corporation\n * Copyright \u00a9 2012 Ran Benita <ran234@gmail.com>\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice (including the next\n * paragraph) shall be included in all copies or substantial portions of the\n * Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n *\n * Author: Dan Nicholson <dbn.lists@gmail.com>\n *         Daniel Stone <daniel@fooishbar.org>\n *         Ran Benita <ran234@gmail.com>\n */\n\n#include \"xkbcomp-priv.h\"\n\nstatic void\nComputeEffectiveMask(struct xkb_keymap *keymap, struct xkb_mods *mods)\n{\n    mods->mask = mod_mask_get_effective(keymap, mods->mods);\n}\n\nstatic void\nUpdateActionMods(struct xkb_keymap *keymap, union xkb_action *act,\n                 xkb_mod_mask_t modmap)\n{\n    switch (act->type) {\n    case ACTION_TYPE_MOD_SET:\n    case ACTION_TYPE_MOD_LATCH:\n    case ACTION_TYPE_MOD_LOCK:\n        if (act->mods.flags & ACTION_MODS_LOOKUP_MODMAP)\n            act->mods.mods.mods = modmap;\n        ComputeEffectiveMask(keymap, &act->mods.mods);\n        break;\n    default:\n        break;\n    }\n}\n\nstatic const struct xkb_sym_interpret default_interpret = {\n    .sym = XKB_KEY_NoSymbol,\n    .repeat = true,\n    .match = MATCH_ANY_OR_NONE,\n    .mods = 0,\n    .virtual_mod = XKB_MOD_INVALID,\n    .action = { .type = ACTION_TYPE_NONE },\n};\n\n/**\n * Find an interpretation which applies to this particular level, either by\n * finding an exact match for the symbol and modifier combination, or a\n * generic XKB_KEY_NoSymbol match.\n */\nstatic const struct xkb_sym_interpret *\nFindInterpForKey(struct xkb_keymap *keymap, const struct xkb_key *key,\n                 xkb_layout_index_t group, xkb_level_index_t level)\n{\n    const xkb_keysym_t *syms;\n    int num_syms;\n\n    num_syms = xkb_keymap_key_get_syms_by_level(keymap, key->keycode, group,\n                                                level, &syms);\n    if (num_syms == 0)\n        return NULL;\n\n    /*\n     * There may be multiple matchings interprets; we should always return\n     * the most specific. Here we rely on compat.c to set up the\n     * sym_interprets array from the most specific to the least specific,\n     * such that when we find a match we return immediately.\n     */\n    for (unsigned i = 0; i < keymap->num_sym_interprets; i++) {\n        const struct xkb_sym_interpret *interp = &keymap->sym_interprets[i];\n\n        xkb_mod_mask_t mods;\n        bool found = false;\n\n        if ((num_syms > 1 || interp->sym != syms[0]) &&\n            interp->sym != XKB_KEY_NoSymbol)\n            continue;\n\n        if (interp->level_one_only && level != 0)\n            mods = 0;\n        else\n            mods = key->modmap;\n\n        switch (interp->match) {\n        case MATCH_NONE:\n            found = !(interp->mods & mods);\n            break;\n        case MATCH_ANY_OR_NONE:\n            found = (!mods || (interp->mods & mods));\n            break;\n        case MATCH_ANY:\n            found = (interp->mods & mods);\n            break;\n        case MATCH_ALL:\n            found = ((interp->mods & mods) == interp->mods);\n            break;\n        case MATCH_EXACTLY:\n            found = (interp->mods == mods);\n            break;\n        }\n\n        if (found)\n            return interp;\n    }\n\n    return &default_interpret;\n}\n\nstatic bool\nApplyInterpsToKey(struct xkb_keymap *keymap, struct xkb_key *key)\n{\n    xkb_mod_mask_t vmodmap = 0;\n    xkb_layout_index_t group;\n    xkb_level_index_t level;\n\n    /* If we've been told not to bind interps to this key, then don't. */\n    if (key->explicit & EXPLICIT_INTERP)\n        return true;\n\n    for (group = 0; group < key->num_groups; group++) {\n        for (level = 0; level < XkbKeyNumLevels(key, group); level++) {\n            const struct xkb_sym_interpret *interp;\n\n            interp = FindInterpForKey(keymap, key, group, level);\n            if (!interp)\n                continue;\n\n            /* Infer default key behaviours from the base level. */\n            if (group == 0 && level == 0)\n                if (!(key->explicit & EXPLICIT_REPEAT) && interp->repeat)\n                    key->repeats = true;\n\n            if ((group == 0 && level == 0) || !interp->level_one_only)\n                if (interp->virtual_mod != XKB_MOD_INVALID)\n                    vmodmap |= (1u << interp->virtual_mod);\n\n            if (interp->action.type != ACTION_TYPE_NONE)\n                key->groups[group].levels[level].action = interp->action;\n        }\n    }\n\n    if (!(key->explicit & EXPLICIT_VMODMAP))\n        key->vmodmap = vmodmap;\n\n    return true;\n}\n\n/**\n * This collects a bunch of disparate functions which was done in the server\n * at various points that really should've been done within xkbcomp.  Turns out\n * your actions and types are a lot more useful when any of your modifiers\n * other than Shift actually do something ...\n */\nstatic bool\nUpdateDerivedKeymapFields(struct xkb_keymap *keymap)\n{\n    struct xkb_key *key;\n    struct xkb_mod *mod;\n    struct xkb_led *led;\n    unsigned int i, j;\n\n    /* Find all the interprets for the key and bind them to actions,\n     * which will also update the vmodmap. */\n    xkb_keys_foreach(key, keymap)\n        if (!ApplyInterpsToKey(keymap, key))\n            return false;\n\n    /* Update keymap->mods, the virtual -> real mod mapping. */\n    xkb_keys_foreach(key, keymap)\n        xkb_mods_enumerate(i, mod, &keymap->mods)\n            if (key->vmodmap & (1u << i))\n                mod->mapping |= key->modmap;\n\n    /* Now update the level masks for all the types to reflect the vmods. */\n    for (i = 0; i < keymap->num_types; i++) {\n        ComputeEffectiveMask(keymap, &keymap->types[i].mods);\n\n        for (j = 0; j < keymap->types[i].num_entries; j++) {\n            ComputeEffectiveMask(keymap, &keymap->types[i].entries[j].mods);\n            ComputeEffectiveMask(keymap, &keymap->types[i].entries[j].preserve);\n        }\n    }\n\n    /* Update action modifiers. */\n    xkb_keys_foreach(key, keymap)\n        for (i = 0; i < key->num_groups; i++)\n            for (j = 0; j < XkbKeyNumLevels(key, i); j++)\n                UpdateActionMods(keymap, &key->groups[i].levels[j].action,\n                                 key->modmap);\n\n    /* Update vmod -> led maps. */\n    xkb_leds_foreach(led, keymap)\n        ComputeEffectiveMask(keymap, &led->mods);\n\n    /* Find maximum number of groups out of all keys in the keymap. */\n    xkb_keys_foreach(key, keymap)\n        keymap->num_groups = MAX(keymap->num_groups, key->num_groups);\n\n    return true;\n}\n\ntypedef bool (*compile_file_fn)(XkbFile *file,\n                                struct xkb_keymap *keymap,\n                                enum merge_mode merge);\n\nstatic const compile_file_fn compile_file_fns[LAST_KEYMAP_FILE_TYPE + 1] = {\n    [FILE_TYPE_KEYCODES] = CompileKeycodes,\n    [FILE_TYPE_TYPES] = CompileKeyTypes,\n    [FILE_TYPE_COMPAT] = CompileCompatMap,\n    [FILE_TYPE_SYMBOLS] = CompileSymbols,\n};\n\nbool\nCompileKeymap(XkbFile *file, struct xkb_keymap *keymap, enum merge_mode merge)\n{\n    bool ok;\n    XkbFile *files[LAST_KEYMAP_FILE_TYPE + 1] = { NULL };\n    enum xkb_file_type type;\n    struct xkb_context *ctx = keymap->ctx;\n\n    /* Collect section files and check for duplicates. */\n    for (file = (XkbFile *) file->defs; file;\n         file = (XkbFile *) file->common.next) {\n        if (file->file_type < FIRST_KEYMAP_FILE_TYPE ||\n            file->file_type > LAST_KEYMAP_FILE_TYPE) {\n            if (file->file_type == FILE_TYPE_GEOMETRY) {\n                log_vrb(ctx, 1,\n                        \"Geometry sections are not supported; ignoring\\n\");\n            } else {\n                log_err(ctx, \"Cannot define %s in a keymap file\\n\",\n                        xkb_file_type_to_string(file->file_type));\n            }\n            continue;\n        }\n\n        if (files[file->file_type]) {\n            log_err(ctx,\n                    \"More than one %s section in keymap file; \"\n                    \"All sections after the first ignored\\n\",\n                    xkb_file_type_to_string(file->file_type));\n            continue;\n        }\n\n        files[file->file_type] = file;\n    }\n\n    /*\n     * Check that all required section were provided.\n     * Report everything before failing.\n     */\n    ok = true;\n    for (type = FIRST_KEYMAP_FILE_TYPE;\n         type <= LAST_KEYMAP_FILE_TYPE;\n         type++) {\n        if (files[type] == NULL) {\n            log_err(ctx, \"Required section %s missing from keymap\\n\",\n                    xkb_file_type_to_string(type));\n            ok = false;\n        }\n    }\n    if (!ok)\n        return false;\n\n    /* Compile sections. */\n    for (type = FIRST_KEYMAP_FILE_TYPE;\n         type <= LAST_KEYMAP_FILE_TYPE;\n         type++) {\n        log_dbg(ctx, \"Compiling %s \\\"%s\\\"\\n\",\n                xkb_file_type_to_string(type), files[type]->name);\n\n        ok = compile_file_fns[type](files[type], keymap, merge);\n        if (!ok) {\n            log_err(ctx, \"Failed to compile %s\\n\",\n                    xkb_file_type_to_string(type));\n            return false;\n        }\n    }\n\n    return UpdateDerivedKeymapFields(keymap);\n}\n", "/************************************************************\n Copyright (c) 1994 by Silicon Graphics Computer Systems, Inc.\n\n Permission to use, copy, modify, and distribute this\n software and its documentation for any purpose and without\n fee is hereby granted, provided that the above copyright\n notice appear in all copies and that both that copyright\n notice and this permission notice appear in supporting\n documentation, and that the name of Silicon Graphics not be\n used in advertising or publicity pertaining to distribution\n of the software without specific prior written permission.\n Silicon Graphics makes no representation about the suitability\n of this software for any purpose. It is provided \"as is\"\n without any express or implied warranty.\n\n SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS\n SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\n AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL SILICON\n GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL\n DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,\n DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE\n OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION  WITH\n THE USE OR PERFORMANCE OF THIS SOFTWARE.\n\n ********************************************************/\n\n/*\n * The parser should work with reasonably recent versions of either\n * bison or byacc.  So if you make changes, try to make sure it works\n * in both!\n */\n\n%{\n#include \"xkbcomp/xkbcomp-priv.h\"\n#include \"xkbcomp/ast-build.h\"\n#include \"xkbcomp/parser-priv.h\"\n#include \"scanner-utils.h\"\n\nstruct parser_param {\n    struct xkb_context *ctx;\n    struct scanner *scanner;\n    XkbFile *rtrn;\n    bool more_maps;\n};\n\n#define parser_err(param, fmt, ...) \\\n    scanner_err((param)->scanner, fmt, ##__VA_ARGS__)\n\n#define parser_warn(param, fmt, ...) \\\n    scanner_warn((param)->scanner, fmt, ##__VA_ARGS__)\n\nstatic void\n_xkbcommon_error(struct parser_param *param, const char *msg)\n{\n    parser_err(param, \"%s\", msg);\n}\n\nstatic bool\nresolve_keysym(const char *name, xkb_keysym_t *sym_rtrn)\n{\n    xkb_keysym_t sym;\n\n    if (!name || istreq(name, \"any\") || istreq(name, \"nosymbol\")) {\n        *sym_rtrn = XKB_KEY_NoSymbol;\n        return true;\n    }\n\n    if (istreq(name, \"none\") || istreq(name, \"voidsymbol\")) {\n        *sym_rtrn = XKB_KEY_VoidSymbol;\n        return true;\n    }\n\n    sym = xkb_keysym_from_name(name, XKB_KEYSYM_NO_FLAGS);\n    if (sym != XKB_KEY_NoSymbol) {\n        *sym_rtrn = sym;\n        return true;\n    }\n\n    return false;\n}\n\n#define param_scanner param->scanner\n%}\n\n%pure-parser\n%lex-param      { struct scanner *param_scanner }\n%parse-param    { struct parser_param *param }\n\n%token\n        END_OF_FILE     0\n        ERROR_TOK       255\n        XKB_KEYMAP      1\n        XKB_KEYCODES    2\n        XKB_TYPES       3\n        XKB_SYMBOLS     4\n        XKB_COMPATMAP   5\n        XKB_GEOMETRY    6\n        XKB_SEMANTICS   7\n        XKB_LAYOUT      8\n        INCLUDE         10\n        OVERRIDE        11\n        AUGMENT         12\n        REPLACE         13\n        ALTERNATE       14\n        VIRTUAL_MODS    20\n        TYPE            21\n        INTERPRET       22\n        ACTION_TOK      23\n        KEY             24\n        ALIAS           25\n        GROUP           26\n        MODIFIER_MAP    27\n        INDICATOR       28\n        SHAPE           29\n        KEYS            30\n        ROW             31\n        SECTION         32\n        OVERLAY         33\n        TEXT            34\n        OUTLINE         35\n        SOLID           36\n        LOGO            37\n        VIRTUAL         38\n        EQUALS          40\n        PLUS            41\n        MINUS           42\n        DIVIDE          43\n        TIMES           44\n        OBRACE          45\n        CBRACE          46\n        OPAREN          47\n        CPAREN          48\n        OBRACKET        49\n        CBRACKET        50\n        DOT             51\n        COMMA           52\n        SEMI            53\n        EXCLAM          54\n        INVERT          55\n        STRING          60\n        INTEGER         61\n        FLOAT           62\n        IDENT           63\n        KEYNAME         64\n        PARTIAL         70\n        DEFAULT         71\n        HIDDEN          72\n        ALPHANUMERIC_KEYS       73\n        MODIFIER_KEYS           74\n        KEYPAD_KEYS             75\n        FUNCTION_KEYS           76\n        ALTERNATE_GROUP         77\n\n%right  EQUALS\n%left   PLUS MINUS\n%left   TIMES DIVIDE\n%left   EXCLAM INVERT\n%left   OPAREN\n\n%start  XkbFile\n\n%union  {\n        int              ival;\n        int64_t          num;\n        enum xkb_file_type file_type;\n        char            *str;\n        xkb_atom_t      atom;\n        enum merge_mode merge;\n        enum xkb_map_flags mapFlags;\n        xkb_keysym_t    keysym;\n        ParseCommon     *any;\n        ExprDef         *expr;\n        VarDef          *var;\n        VModDef         *vmod;\n        InterpDef       *interp;\n        KeyTypeDef      *keyType;\n        SymbolsDef      *syms;\n        ModMapDef       *modMask;\n        GroupCompatDef  *groupCompat;\n        LedMapDef       *ledMap;\n        LedNameDef      *ledName;\n        KeycodeDef      *keyCode;\n        KeyAliasDef     *keyAlias;\n        void            *geom;\n        XkbFile         *file;\n}\n\n%type <num>     INTEGER FLOAT\n%type <str>     IDENT STRING\n%type <atom>    KEYNAME\n%type <num>     KeyCode\n%type <ival>    Number Integer Float SignedNumber DoodadType\n%type <merge>   MergeMode OptMergeMode\n%type <file_type> XkbCompositeType FileType\n%type <mapFlags> Flag Flags OptFlags\n%type <str>     MapName OptMapName\n%type <atom>    FieldSpec Ident Element String\n%type <keysym>  KeySym\n%type <any>     DeclList Decl\n%type <expr>    OptExprList ExprList Expr Term Lhs Terminal ArrayInit KeySyms\n%type <expr>    OptKeySymList KeySymList Action ActionList Coord CoordList\n%type <var>     VarDecl VarDeclList SymbolsBody SymbolsVarDecl\n%type <vmod>    VModDecl VModDefList VModDef\n%type <interp>  InterpretDecl InterpretMatch\n%type <keyType> KeyTypeDecl\n%type <syms>    SymbolsDecl\n%type <modMask> ModMapDecl\n%type <groupCompat> GroupCompatDecl\n%type <ledMap>  LedMapDecl\n%type <ledName> LedNameDecl\n%type <keyCode> KeyNameDecl\n%type <keyAlias> KeyAliasDecl\n%type <geom>    ShapeDecl SectionDecl SectionBody SectionBodyItem RowBody RowBodyItem\n%type <geom>    Keys Key OverlayDecl OverlayKeyList OverlayKey OutlineList OutlineInList\n%type <geom>    DoodadDecl\n%type <file>    XkbFile XkbMapConfigList XkbMapConfig\n%type <file>    XkbCompositeMap\n\n%destructor { FreeStmt((ParseCommon *) $$); }\n    <any> <expr> <var> <vmod> <interp> <keyType> <syms> <modMask> <groupCompat>\n    <ledMap> <ledName> <keyCode> <keyAlias>\n/* The destructor also runs on the start symbol when the parser *succeeds*.\n * The `if` here catches this case. */\n%destructor { if (!param->rtrn) FreeXkbFile($$); } <file>\n%destructor { free($$); } <str>\n\n%%\n\n/*\n * An actual file may contain more than one map. However, if we do things\n * in the normal yacc way, i.e. aggregate all of the maps into a list and\n * let the caller find the map it wants, we end up scanning and parsing a\n * lot of unneeded maps (in the end we always just need one).\n * Instead of doing that, we make yyparse return one map at a time, and\n * then call it repeatedly until we find the map we need. Once we find it,\n * we don't need to parse everything that follows in the file.\n * This does mean that if we e.g. always use the first map, the file may\n * contain complete garbage after that. But it's worth it.\n */\n\nXkbFile         :       XkbCompositeMap\n                        { $$ = param->rtrn = $1; param->more_maps = true; }\n                |       XkbMapConfig\n                        { $$ = param->rtrn = $1; param->more_maps = true; YYACCEPT; }\n                |       END_OF_FILE\n                        { $$ = param->rtrn = NULL; param->more_maps = false; }\n                ;\n\nXkbCompositeMap :       OptFlags XkbCompositeType OptMapName OBRACE\n                            XkbMapConfigList\n                        CBRACE SEMI\n                        { $$ = XkbFileCreate($2, $3, (ParseCommon *) $5, $1); }\n                ;\n\nXkbCompositeType:       XKB_KEYMAP      { $$ = FILE_TYPE_KEYMAP; }\n                |       XKB_SEMANTICS   { $$ = FILE_TYPE_KEYMAP; }\n                |       XKB_LAYOUT      { $$ = FILE_TYPE_KEYMAP; }\n                ;\n\nXkbMapConfigList :      XkbMapConfigList XkbMapConfig\n                        {\n                            if (!$2)\n                                $$ = $1;\n                            else\n                                $$ = (XkbFile *) AppendStmt((ParseCommon *) $1,\n                                                            (ParseCommon *) $2);\n                        }\n                |       XkbMapConfig\n                        { $$ = $1; }\n                ;\n\nXkbMapConfig    :       OptFlags FileType OptMapName OBRACE\n                            DeclList\n                        CBRACE SEMI\n                        {\n                            $$ = XkbFileCreate($2, $3, $5, $1);\n                        }\n                ;\n\nFileType        :       XKB_KEYCODES            { $$ = FILE_TYPE_KEYCODES; }\n                |       XKB_TYPES               { $$ = FILE_TYPE_TYPES; }\n                |       XKB_COMPATMAP           { $$ = FILE_TYPE_COMPAT; }\n                |       XKB_SYMBOLS             { $$ = FILE_TYPE_SYMBOLS; }\n                |       XKB_GEOMETRY            { $$ = FILE_TYPE_GEOMETRY; }\n                ;\n\nOptFlags        :       Flags                   { $$ = $1; }\n                |                               { $$ = 0; }\n                ;\n\nFlags           :       Flags Flag              { $$ = ($1 | $2); }\n                |       Flag                    { $$ = $1; }\n                ;\n\nFlag            :       PARTIAL                 { $$ = MAP_IS_PARTIAL; }\n                |       DEFAULT                 { $$ = MAP_IS_DEFAULT; }\n                |       HIDDEN                  { $$ = MAP_IS_HIDDEN; }\n                |       ALPHANUMERIC_KEYS       { $$ = MAP_HAS_ALPHANUMERIC; }\n                |       MODIFIER_KEYS           { $$ = MAP_HAS_MODIFIER; }\n                |       KEYPAD_KEYS             { $$ = MAP_HAS_KEYPAD; }\n                |       FUNCTION_KEYS           { $$ = MAP_HAS_FN; }\n                |       ALTERNATE_GROUP         { $$ = MAP_IS_ALTGR; }\n                ;\n\nDeclList        :       DeclList Decl\n                        { $$ = AppendStmt($1, $2); }\n                |       { $$ = NULL; }\n                ;\n\nDecl            :       OptMergeMode VarDecl\n                        {\n                            $2->merge = $1;\n                            $$ = (ParseCommon *) $2;\n                        }\n                |       OptMergeMode VModDecl\n                        {\n                            $2->merge = $1;\n                            $$ = (ParseCommon *) $2;\n                        }\n                |       OptMergeMode InterpretDecl\n                        {\n                            $2->merge = $1;\n                            $$ = (ParseCommon *) $2;\n                        }\n                |       OptMergeMode KeyNameDecl\n                        {\n                            $2->merge = $1;\n                            $$ = (ParseCommon *) $2;\n                        }\n                |       OptMergeMode KeyAliasDecl\n                        {\n                            $2->merge = $1;\n                            $$ = (ParseCommon *) $2;\n                        }\n                |       OptMergeMode KeyTypeDecl\n                        {\n                            $2->merge = $1;\n                            $$ = (ParseCommon *) $2;\n                        }\n                |       OptMergeMode SymbolsDecl\n                        {\n                            $2->merge = $1;\n                            $$ = (ParseCommon *) $2;\n                        }\n                |       OptMergeMode ModMapDecl\n                        {\n                            $2->merge = $1;\n                            $$ = (ParseCommon *) $2;\n                        }\n                |       OptMergeMode GroupCompatDecl\n                        {\n                            $2->merge = $1;\n                            $$ = (ParseCommon *) $2;\n                        }\n                |       OptMergeMode LedMapDecl\n                        {\n                            $2->merge = $1;\n                            $$ = (ParseCommon *) $2;\n                        }\n                |       OptMergeMode LedNameDecl\n                        {\n                            $2->merge = $1;\n                            $$ = (ParseCommon *) $2;\n                        }\n                |       OptMergeMode ShapeDecl          { $$ = NULL; }\n                |       OptMergeMode SectionDecl        { $$ = NULL; }\n                |       OptMergeMode DoodadDecl         { $$ = NULL; }\n                |       MergeMode STRING\n                        {\n                            $$ = (ParseCommon *) IncludeCreate(param->ctx, $2, $1);\n                            free($2);\n                        }\n                ;\n\nVarDecl         :       Lhs EQUALS Expr SEMI\n                        { $$ = VarCreate($1, $3); }\n                |       Ident SEMI\n                        { $$ = BoolVarCreate($1, true); }\n                |       EXCLAM Ident SEMI\n                        { $$ = BoolVarCreate($2, false); }\n                ;\n\nKeyNameDecl     :       KEYNAME EQUALS KeyCode SEMI\n                        { $$ = KeycodeCreate($1, $3); }\n                ;\n\nKeyAliasDecl    :       ALIAS KEYNAME EQUALS KEYNAME SEMI\n                        { $$ = KeyAliasCreate($2, $4); }\n                ;\n\nVModDecl        :       VIRTUAL_MODS VModDefList SEMI\n                        { $$ = $2; }\n                ;\n\nVModDefList     :       VModDefList COMMA VModDef\n                        { $$ = (VModDef *) AppendStmt((ParseCommon *) $1,\n                                                      (ParseCommon *) $3); }\n                |       VModDef\n                        { $$ = $1; }\n                ;\n\nVModDef         :       Ident\n                        { $$ = VModCreate($1, NULL); }\n                |       Ident EQUALS Expr\n                        { $$ = VModCreate($1, $3); }\n                ;\n\nInterpretDecl   :       INTERPRET InterpretMatch OBRACE\n                            VarDeclList\n                        CBRACE SEMI\n                        { $2->def = $4; $$ = $2; }\n                ;\n\nInterpretMatch  :       KeySym PLUS Expr\n                        { $$ = InterpCreate($1, $3); }\n                |       KeySym\n                        { $$ = InterpCreate($1, NULL); }\n                ;\n\nVarDeclList     :       VarDeclList VarDecl\n                        { $$ = (VarDef *) AppendStmt((ParseCommon *) $1,\n                                                     (ParseCommon *) $2); }\n                |       VarDecl\n                        { $$ = $1; }\n                ;\n\nKeyTypeDecl     :       TYPE String OBRACE\n                            VarDeclList\n                        CBRACE SEMI\n                        { $$ = KeyTypeCreate($2, $4); }\n                ;\n\nSymbolsDecl     :       KEY KEYNAME OBRACE\n                            SymbolsBody\n                        CBRACE SEMI\n                        { $$ = SymbolsCreate($2, $4); }\n                ;\n\nSymbolsBody     :       SymbolsBody COMMA SymbolsVarDecl\n                        { $$ = (VarDef *) AppendStmt((ParseCommon *) $1,\n                                                     (ParseCommon *) $3); }\n                |       SymbolsVarDecl\n                        { $$ = $1; }\n                |       { $$ = NULL; }\n                ;\n\nSymbolsVarDecl  :       Lhs EQUALS Expr         { $$ = VarCreate($1, $3); }\n                |       Lhs EQUALS ArrayInit    { $$ = VarCreate($1, $3); }\n                |       Ident                   { $$ = BoolVarCreate($1, true); }\n                |       EXCLAM Ident            { $$ = BoolVarCreate($2, false); }\n                |       ArrayInit               { $$ = VarCreate(NULL, $1); }\n                ;\n\nArrayInit       :       OBRACKET OptKeySymList CBRACKET\n                        { $$ = $2; }\n                |       OBRACKET ActionList CBRACKET\n                        { $$ = ExprCreateUnary(EXPR_ACTION_LIST, EXPR_TYPE_ACTION, $2); }\n                ;\n\nGroupCompatDecl :       GROUP Integer EQUALS Expr SEMI\n                        { $$ = GroupCompatCreate($2, $4); }\n                ;\n\nModMapDecl      :       MODIFIER_MAP Ident OBRACE ExprList CBRACE SEMI\n                        { $$ = ModMapCreate($2, $4); }\n                ;\n\nLedMapDecl:             INDICATOR String OBRACE VarDeclList CBRACE SEMI\n                        { $$ = LedMapCreate($2, $4); }\n                ;\n\nLedNameDecl:            INDICATOR Integer EQUALS Expr SEMI\n                        { $$ = LedNameCreate($2, $4, false); }\n                |       VIRTUAL INDICATOR Integer EQUALS Expr SEMI\n                        { $$ = LedNameCreate($3, $5, true); }\n                ;\n\nShapeDecl       :       SHAPE String OBRACE OutlineList CBRACE SEMI\n                        { $$ = NULL; }\n                |       SHAPE String OBRACE CoordList CBRACE SEMI\n                        { (void) $4; $$ = NULL; }\n                ;\n\nSectionDecl     :       SECTION String OBRACE SectionBody CBRACE SEMI\n                        { $$ = NULL; }\n                ;\n\nSectionBody     :       SectionBody SectionBodyItem     { $$ = NULL;}\n                |       SectionBodyItem                 { $$ = NULL; }\n                ;\n\nSectionBodyItem :       ROW OBRACE RowBody CBRACE SEMI\n                        { $$ = NULL; }\n                |       VarDecl\n                        { FreeStmt((ParseCommon *) $1); $$ = NULL; }\n                |       DoodadDecl\n                        { $$ = NULL; }\n                |       LedMapDecl\n                        { FreeStmt((ParseCommon *) $1); $$ = NULL; }\n                |       OverlayDecl\n                        { $$ = NULL; }\n                ;\n\nRowBody         :       RowBody RowBodyItem     { $$ = NULL;}\n                |       RowBodyItem             { $$ = NULL; }\n                ;\n\nRowBodyItem     :       KEYS OBRACE Keys CBRACE SEMI { $$ = NULL; }\n                |       VarDecl\n                        { FreeStmt((ParseCommon *) $1); $$ = NULL; }\n                ;\n\nKeys            :       Keys COMMA Key          { $$ = NULL; }\n                |       Key                     { $$ = NULL; }\n                ;\n\nKey             :       KEYNAME\n                        { $$ = NULL; }\n                |       OBRACE ExprList CBRACE\n                        { FreeStmt((ParseCommon *) $2); $$ = NULL; }\n                ;\n\nOverlayDecl     :       OVERLAY String OBRACE OverlayKeyList CBRACE SEMI\n                        { $$ = NULL; }\n                ;\n\nOverlayKeyList  :       OverlayKeyList COMMA OverlayKey { $$ = NULL; }\n                |       OverlayKey                      { $$ = NULL; }\n                ;\n\nOverlayKey      :       KEYNAME EQUALS KEYNAME          { $$ = NULL; }\n                ;\n\nOutlineList     :       OutlineList COMMA OutlineInList\n                        { $$ = NULL;}\n                |       OutlineInList\n                        { $$ = NULL; }\n                ;\n\nOutlineInList   :       OBRACE CoordList CBRACE\n                        { (void) $2; $$ = NULL; }\n                |       Ident EQUALS OBRACE CoordList CBRACE\n                        { (void) $4; $$ = NULL; }\n                |       Ident EQUALS Expr\n                        { FreeStmt((ParseCommon *) $3); $$ = NULL; }\n                ;\n\nCoordList       :       CoordList COMMA Coord\n                        { (void) $1; (void) $3; $$ = NULL; }\n                |       Coord\n                        { (void) $1; $$ = NULL; }\n                ;\n\nCoord           :       OBRACKET SignedNumber COMMA SignedNumber CBRACKET\n                        { $$ = NULL; }\n                ;\n\nDoodadDecl      :       DoodadType String OBRACE VarDeclList CBRACE SEMI\n                        { FreeStmt((ParseCommon *) $4); $$ = NULL; }\n                ;\n\nDoodadType      :       TEXT    { $$ = 0; }\n                |       OUTLINE { $$ = 0; }\n                |       SOLID   { $$ = 0; }\n                |       LOGO    { $$ = 0; }\n                ;\n\nFieldSpec       :       Ident   { $$ = $1; }\n                |       Element { $$ = $1; }\n                ;\n\nElement         :       ACTION_TOK\n                        { $$ = xkb_atom_intern_literal(param->ctx, \"action\"); }\n                |       INTERPRET\n                        { $$ = xkb_atom_intern_literal(param->ctx, \"interpret\"); }\n                |       TYPE\n                        { $$ = xkb_atom_intern_literal(param->ctx, \"type\"); }\n                |       KEY\n                        { $$ = xkb_atom_intern_literal(param->ctx, \"key\"); }\n                |       GROUP\n                        { $$ = xkb_atom_intern_literal(param->ctx, \"group\"); }\n                |       MODIFIER_MAP\n                        {$$ = xkb_atom_intern_literal(param->ctx, \"modifier_map\");}\n                |       INDICATOR\n                        { $$ = xkb_atom_intern_literal(param->ctx, \"indicator\"); }\n                |       SHAPE\n                        { $$ = xkb_atom_intern_literal(param->ctx, \"shape\"); }\n                |       ROW\n                        { $$ = xkb_atom_intern_literal(param->ctx, \"row\"); }\n                |       SECTION\n                        { $$ = xkb_atom_intern_literal(param->ctx, \"section\"); }\n                |       TEXT\n                        { $$ = xkb_atom_intern_literal(param->ctx, \"text\"); }\n                ;\n\nOptMergeMode    :       MergeMode       { $$ = $1; }\n                |                       { $$ = MERGE_DEFAULT; }\n                ;\n\nMergeMode       :       INCLUDE         { $$ = MERGE_DEFAULT; }\n                |       AUGMENT         { $$ = MERGE_AUGMENT; }\n                |       OVERRIDE        { $$ = MERGE_OVERRIDE; }\n                |       REPLACE         { $$ = MERGE_REPLACE; }\n                |       ALTERNATE\n                {\n                    /*\n                     * This used to be MERGE_ALT_FORM. This functionality was\n                     * unused and has been removed.\n                     */\n                    $$ = MERGE_DEFAULT;\n                }\n                ;\n\nOptExprList     :       ExprList        { $$ = $1; }\n                |                       { $$ = NULL; }\n                ;\n\nExprList        :       ExprList COMMA Expr\n                        { $$ = (ExprDef *) AppendStmt((ParseCommon *) $1,\n                                                      (ParseCommon *) $3); }\n                |       Expr\n                        { $$ = $1; }\n                ;\n\nExpr            :       Expr DIVIDE Expr\n                        { $$ = ExprCreateBinary(EXPR_DIVIDE, $1, $3); }\n                |       Expr PLUS Expr\n                        { $$ = ExprCreateBinary(EXPR_ADD, $1, $3); }\n                |       Expr MINUS Expr\n                        { $$ = ExprCreateBinary(EXPR_SUBTRACT, $1, $3); }\n                |       Expr TIMES Expr\n                        { $$ = ExprCreateBinary(EXPR_MULTIPLY, $1, $3); }\n                |       Lhs EQUALS Expr\n                        { $$ = ExprCreateBinary(EXPR_ASSIGN, $1, $3); }\n                |       Term\n                        { $$ = $1; }\n                ;\n\nTerm            :       MINUS Term\n                        { $$ = ExprCreateUnary(EXPR_NEGATE, $2->expr.value_type, $2); }\n                |       PLUS Term\n                        { $$ = ExprCreateUnary(EXPR_UNARY_PLUS, $2->expr.value_type, $2); }\n                |       EXCLAM Term\n                        { $$ = ExprCreateUnary(EXPR_NOT, EXPR_TYPE_BOOLEAN, $2); }\n                |       INVERT Term\n                        { $$ = ExprCreateUnary(EXPR_INVERT, $2->expr.value_type, $2); }\n                |       Lhs\n                        { $$ = $1;  }\n                |       FieldSpec OPAREN OptExprList CPAREN %prec OPAREN\n                        { $$ = ExprCreateAction($1, $3); }\n                |       Terminal\n                        { $$ = $1;  }\n                |       OPAREN Expr CPAREN\n                        { $$ = $2;  }\n                ;\n\nActionList      :       ActionList COMMA Action\n                        { $$ = (ExprDef *) AppendStmt((ParseCommon *) $1,\n                                                      (ParseCommon *) $3); }\n                |       Action\n                        { $$ = $1; }\n                ;\n\nAction          :       FieldSpec OPAREN OptExprList CPAREN\n                        { $$ = ExprCreateAction($1, $3); }\n                ;\n\nLhs             :       FieldSpec\n                        { $$ = ExprCreateIdent($1); }\n                |       FieldSpec DOT FieldSpec\n                        { $$ = ExprCreateFieldRef($1, $3); }\n                |       FieldSpec OBRACKET Expr CBRACKET\n                        { $$ = ExprCreateArrayRef(XKB_ATOM_NONE, $1, $3); }\n                |       FieldSpec DOT FieldSpec OBRACKET Expr CBRACKET\n                        { $$ = ExprCreateArrayRef($1, $3, $5); }\n                ;\n\nTerminal        :       String\n                        { $$ = ExprCreateString($1); }\n                |       Integer\n                        { $$ = ExprCreateInteger($1); }\n                |       Float\n                        { $$ = ExprCreateFloat(/* Discard $1 */); }\n                |       KEYNAME\n                        { $$ = ExprCreateKeyName($1); }\n                ;\n\nOptKeySymList   :       KeySymList      { $$ = $1; }\n                |                       { $$ = NULL; }\n                ;\n\nKeySymList      :       KeySymList COMMA KeySym\n                        { $$ = ExprAppendKeysymList($1, $3); }\n                |       KeySymList COMMA KeySyms\n                        { $$ = ExprAppendMultiKeysymList($1, $3); }\n                |       KeySym\n                        { $$ = ExprCreateKeysymList($1); }\n                |       KeySyms\n                        { $$ = ExprCreateMultiKeysymList($1); }\n                ;\n\nKeySyms         :       OBRACE KeySymList CBRACE\n                        { $$ = $2; }\n                ;\n\nKeySym          :       IDENT\n                        {\n                            if (!resolve_keysym($1, &$$))\n                                parser_warn(param, \"unrecognized keysym \\\"%s\\\"\", $1);\n                            free($1);\n                        }\n                |       SECTION { $$ = XKB_KEY_section; }\n                |       Integer\n                        {\n                            if ($1 < 0) {\n                                parser_warn(param, \"unrecognized keysym \\\"%d\\\"\", $1);\n                                $$ = XKB_KEY_NoSymbol;\n                            }\n                            else if ($1 < 10) {      /* XKB_KEY_0 .. XKB_KEY_9 */\n                                $$ = XKB_KEY_0 + (xkb_keysym_t) $1;\n                            }\n                            else {\n                                char buf[17];\n                                snprintf(buf, sizeof(buf), \"0x%x\", $1);\n                                if (!resolve_keysym(buf, &$$)) {\n                                    parser_warn(param, \"unrecognized keysym \\\"%s\\\"\", buf);\n                                    $$ = XKB_KEY_NoSymbol;\n                                }\n                            }\n                        }\n                ;\n\nSignedNumber    :       MINUS Number    { $$ = -$2; }\n                |       Number          { $$ = $1; }\n                ;\n\nNumber          :       FLOAT   { $$ = $1; }\n                |       INTEGER { $$ = $1; }\n                ;\n\nFloat           :       FLOAT   { $$ = 0; }\n                ;\n\nInteger         :       INTEGER { $$ = $1; }\n                ;\n\nKeyCode         :       INTEGER { $$ = $1; }\n                ;\n\nIdent           :       IDENT   { $$ = xkb_atom_steal(param->ctx, $1); }\n                |       DEFAULT { $$ = xkb_atom_intern_literal(param->ctx, \"default\"); }\n                ;\n\nString          :       STRING  { $$ = xkb_atom_steal(param->ctx, $1); }\n                ;\n\nOptMapName      :       MapName { $$ = $1; }\n                |               { $$ = NULL; }\n                ;\n\nMapName         :       STRING  { $$ = $1; }\n                ;\n\n%%\n\nXkbFile *\nparse(struct xkb_context *ctx, struct scanner *scanner, const char *map)\n{\n    int ret;\n    XkbFile *first = NULL;\n    struct parser_param param = {\n        .scanner = scanner,\n        .ctx = ctx,\n        .rtrn = NULL,\n    };\n\n    /*\n     * If we got a specific map, we look for it exclusively and return\n     * immediately upon finding it. Otherwise, we need to get the\n     * default map. If we find a map marked as default, we return it\n     * immediately. If there are no maps marked as default, we return\n     * the first map in the file.\n     */\n\n    while ((ret = yyparse(&param)) == 0 && param.more_maps) {\n        if (map) {\n            if (streq_not_null(map, param.rtrn->name))\n                return param.rtrn;\n            else\n                FreeXkbFile(param.rtrn);\n        }\n        else {\n            if (param.rtrn->flags & MAP_IS_DEFAULT) {\n                FreeXkbFile(first);\n                return param.rtrn;\n            }\n            else if (!first) {\n                first = param.rtrn;\n            }\n            else {\n                FreeXkbFile(param.rtrn);\n            }\n        }\n        param.rtrn = NULL;\n    }\n\n    if (ret != 0) {\n        FreeXkbFile(first);\n        return NULL;\n    }\n\n    if (first)\n        log_vrb(ctx, 5,\n                \"No map in include statement, but \\\"%s\\\" contains several; \"\n                \"Using first defined map, \\\"%s\\\"\\n\",\n                scanner->file_name, first->name);\n\n    return first;\n}\n"], "filenames": ["src/xkbcomp/keymap.c", "src/xkbcomp/parser.y"], "buggy_code_start_loc": [244, 276], "buggy_code_end_loc": [246, 284], "fixing_code_start_loc": [244, 276], "fixing_code_end_loc": [251, 277], "type": "CWE-476", "message": "Unchecked NULL pointer usage in xkbcommon before 0.8.1 could be used by local attackers to crash (NULL pointer dereference) the xkbcommon parser by supplying a crafted keymap file, because the XkbFile for an xkb_geometry section was mishandled.", "other": {"cve": {"id": "CVE-2018-15855", "sourceIdentifier": "cve@mitre.org", "published": "2018-08-25T21:29:01.733", "lastModified": "2019-08-06T17:15:25.087", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Unchecked NULL pointer usage in xkbcommon before 0.8.1 could be used by local attackers to crash (NULL pointer dereference) the xkbcommon parser by supplying a crafted keymap file, because the XkbFile for an xkb_geometry section was mishandled."}, {"lang": "es", "value": "El uso de un puntero NULL no verificado en xkbcommon en versiones anteriores a la 0.8.1 podr\u00eda ser aprovechado por atacantes locales para provocar el cierre inesperado (desreferencia de puntero NULL) del analizador xkbcommon proporcionando un archivo keymap manipulado, debido a que se gestion\u00f3 incorrectamente el XkbFile para una secci\u00f3n xkb_geometry."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 2.1}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:xkbcommon_project:xkbcommon:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.8.1", "matchCriteriaId": "2F9BAF72-405A-41EA-AA6D-509128B3E4AD"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:lts:*:*:*", "matchCriteriaId": "B5A6F2F3-4894-4392-8296-3B8DD2679084"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:lts:*:*:*", "matchCriteriaId": "F7016A2A-8365-4F1A-89A2-7A19F2BCAE5B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}]}]}], "references": [{"url": "https://access.redhat.com/errata/RHSA-2019:2079", "source": "cve@mitre.org"}, {"url": "https://github.com/xkbcommon/libxkbcommon/commit/917636b1d0d70205a13f89062b95e3a0fc31d4ff", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.freedesktop.org/archives/wayland-devel/2018-August/039232.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/201810-05", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3786-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3786-2/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/xkbcommon/libxkbcommon/commit/917636b1d0d70205a13f89062b95e3a0fc31d4ff"}}