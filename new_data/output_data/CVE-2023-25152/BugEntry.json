{"buggy_code": ["package filesystem\n\nimport (\n\t\"bufio\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"path\"\n\t\"path/filepath\"\n\t\"sort\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"time\"\n\n\t\"emperror.dev/errors\"\n\t\"github.com/gabriel-vasile/mimetype\"\n\t\"github.com/karrick/godirwalk\"\n\tignore \"github.com/sabhiram/go-gitignore\"\n\n\t\"github.com/pterodactyl/wings/config\"\n\t\"github.com/pterodactyl/wings/system\"\n)\n\ntype Filesystem struct {\n\tmu                sync.RWMutex\n\tlastLookupTime    *usageLookupTime\n\tlookupInProgress  *system.AtomicBool\n\tdiskUsed          int64\n\tdiskCheckInterval time.Duration\n\tdenylist          *ignore.GitIgnore\n\n\t// The maximum amount of disk space (in bytes) that this Filesystem instance can use.\n\tdiskLimit int64\n\n\t// The root data directory path for this Filesystem instance.\n\troot string\n\n\tisTest bool\n}\n\n// New creates a new Filesystem instance for a given server.\nfunc New(root string, size int64, denylist []string) *Filesystem {\n\treturn &Filesystem{\n\t\troot:              root,\n\t\tdiskLimit:         size,\n\t\tdiskCheckInterval: time.Duration(config.Get().System.DiskCheckInterval),\n\t\tlastLookupTime:    &usageLookupTime{},\n\t\tlookupInProgress:  system.NewAtomicBool(false),\n\t\tdenylist:          ignore.CompileIgnoreLines(denylist...),\n\t}\n}\n\n// Path returns the root path for the Filesystem instance.\nfunc (fs *Filesystem) Path() string {\n\treturn fs.root\n}\n\n// File returns a reader for a file instance as well as the stat information.\nfunc (fs *Filesystem) File(p string) (*os.File, Stat, error) {\n\tcleaned, err := fs.SafePath(p)\n\tif err != nil {\n\t\treturn nil, Stat{}, errors.WithStackIf(err)\n\t}\n\tst, err := fs.Stat(cleaned)\n\tif err != nil {\n\t\tif errors.Is(err, os.ErrNotExist) {\n\t\t\treturn nil, Stat{}, newFilesystemError(ErrNotExist, err)\n\t\t}\n\t\treturn nil, Stat{}, errors.WithStackIf(err)\n\t}\n\tif st.IsDir() {\n\t\treturn nil, Stat{}, newFilesystemError(ErrCodeIsDirectory, nil)\n\t}\n\tf, err := os.Open(cleaned)\n\tif err != nil {\n\t\treturn nil, Stat{}, errors.WithStackIf(err)\n\t}\n\treturn f, st, nil\n}\n\n// Touch acts by creating the given file and path on the disk if it is not present\n// already. If  it is present, the file is opened using the defaults which will truncate\n// the contents. The opened file is then returned to the caller.\nfunc (fs *Filesystem) Touch(p string, flag int) (*os.File, error) {\n\tcleaned, err := fs.SafePath(p)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tf, err := os.OpenFile(cleaned, flag, 0o644)\n\tif err == nil {\n\t\treturn f, nil\n\t}\n\tif f != nil {\n\t\t_ = f.Close()\n\t}\n\t// If the error is not because it doesn't exist then we just need to bail at this point.\n\tif !errors.Is(err, os.ErrNotExist) {\n\t\treturn nil, errors.Wrap(err, \"server/filesystem: touch: failed to open file handle\")\n\t}\n\t// Only create and chown the directory if it doesn't exist.\n\tif _, err := os.Stat(filepath.Dir(cleaned)); errors.Is(err, os.ErrNotExist) {\n\t\t// Create the path leading up to the file we're trying to create, setting the final perms\n\t\t// on it as we go.\n\t\tif err := os.MkdirAll(filepath.Dir(cleaned), 0o755); err != nil {\n\t\t\treturn nil, errors.Wrap(err, \"server/filesystem: touch: failed to create directory tree\")\n\t\t}\n\t\tif err := fs.Chown(filepath.Dir(cleaned)); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\to := &fileOpener{}\n\t// Try to open the file now that we have created the pathing necessary for it, and then\n\t// Chown that file so that the permissions don't mess with things.\n\tf, err = o.open(cleaned, flag, 0o644)\n\tif err != nil {\n\t\treturn nil, errors.Wrap(err, \"server/filesystem: touch: failed to open file with wait\")\n\t}\n\t_ = fs.Chown(cleaned)\n\treturn f, nil\n}\n\n// Writefile writes a file to the system. If the file does not already exist one\n// will be created. This will also properly recalculate the disk space used by\n// the server when writing new files or modifying existing ones.\nfunc (fs *Filesystem) Writefile(p string, r io.Reader) error {\n\tcleaned, err := fs.SafePath(p)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvar currentSize int64\n\t// If the file does not exist on the system already go ahead and create the pathway\n\t// to it and an empty file. We'll then write to it later on after this completes.\n\tstat, err := os.Stat(cleaned)\n\tif err != nil && !os.IsNotExist(err) {\n\t\treturn errors.Wrap(err, \"server/filesystem: writefile: failed to stat file\")\n\t} else if err == nil {\n\t\tif stat.IsDir() {\n\t\t\treturn errors.WithStack(&Error{code: ErrCodeIsDirectory, resolved: cleaned})\n\t\t}\n\t\tcurrentSize = stat.Size()\n\t}\n\n\tbr := bufio.NewReader(r)\n\t// Check that the new size we're writing to the disk can fit. If there is currently\n\t// a file we'll subtract that current file size from the size of the buffer to determine\n\t// the amount of new data we're writing (or amount we're removing if smaller).\n\tif err := fs.HasSpaceFor(int64(br.Size()) - currentSize); err != nil {\n\t\treturn err\n\t}\n\n\t// Touch the file and return the handle to it at this point. This will create the file,\n\t// any necessary directories, and set the proper owner of the file.\n\tfile, err := fs.Touch(cleaned, os.O_RDWR|os.O_CREATE|os.O_TRUNC)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer file.Close()\n\n\tbuf := make([]byte, 1024*4)\n\tsz, err := io.CopyBuffer(file, r, buf)\n\n\t// Adjust the disk usage to account for the old size and the new size of the file.\n\tfs.addDisk(sz - currentSize)\n\n\treturn fs.Chown(cleaned)\n}\n\n// Creates a new directory (name) at a specified path (p) for the server.\nfunc (fs *Filesystem) CreateDirectory(name string, p string) error {\n\tcleaned, err := fs.SafePath(path.Join(p, name))\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn os.MkdirAll(cleaned, 0o755)\n}\n\n// Rename moves (or renames) a file or directory.\nfunc (fs *Filesystem) Rename(from string, to string) error {\n\tcleanedFrom, err := fs.SafePath(from)\n\tif err != nil {\n\t\treturn errors.WithStack(err)\n\t}\n\n\tcleanedTo, err := fs.SafePath(to)\n\tif err != nil {\n\t\treturn errors.WithStack(err)\n\t}\n\n\t// If the target file or directory already exists the rename function will fail, so just\n\t// bail out now.\n\tif _, err := os.Stat(cleanedTo); err == nil {\n\t\treturn os.ErrExist\n\t}\n\n\tif cleanedTo == fs.Path() {\n\t\treturn errors.New(\"attempting to rename into an invalid directory space\")\n\t}\n\n\td := strings.TrimSuffix(cleanedTo, path.Base(cleanedTo))\n\t// Ensure that the directory we're moving into exists correctly on the system. Only do this if\n\t// we're not at the root directory level.\n\tif d != fs.Path() {\n\t\tif mkerr := os.MkdirAll(d, 0o755); mkerr != nil {\n\t\t\treturn errors.WithMessage(mkerr, \"failed to create directory structure for file rename\")\n\t\t}\n\t}\n\n\tif err := os.Rename(cleanedFrom, cleanedTo); err != nil {\n\t\treturn errors.WithStack(err)\n\t}\n\treturn nil\n}\n\n// Recursively iterates over a file or directory and sets the permissions on all of the\n// underlying files. Iterate over all of the files and directories. If it is a file just\n// go ahead and perform the chown operation. Otherwise dig deeper into the directory until\n// we've run out of directories to dig into.\nfunc (fs *Filesystem) Chown(path string) error {\n\tcleaned, err := fs.SafePath(path)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif fs.isTest {\n\t\treturn nil\n\t}\n\n\tuid := config.Get().System.User.Uid\n\tgid := config.Get().System.User.Gid\n\n\t// Start by just chowning the initial path that we received.\n\tif err := os.Chown(cleaned, uid, gid); err != nil {\n\t\treturn errors.Wrap(err, \"server/filesystem: chown: failed to chown path\")\n\t}\n\n\t// If this is not a directory we can now return from the function, there is nothing\n\t// left that we need to do.\n\tif st, err := os.Stat(cleaned); err != nil || !st.IsDir() {\n\t\treturn nil\n\t}\n\n\t// If this was a directory, begin walking over its contents recursively and ensure that all\n\t// of the subfiles and directories get their permissions updated as well.\n\terr = godirwalk.Walk(cleaned, &godirwalk.Options{\n\t\tUnsorted: true,\n\t\tCallback: func(p string, e *godirwalk.Dirent) error {\n\t\t\t// Do not attempt to chown a symlink. Go's os.Chown function will affect the symlink\n\t\t\t// so if it points to a location outside the data directory the user would be able to\n\t\t\t// (un)intentionally modify that files permissions.\n\t\t\tif e.IsSymlink() {\n\t\t\t\tif e.IsDir() {\n\t\t\t\t\treturn godirwalk.SkipThis\n\t\t\t\t}\n\n\t\t\t\treturn nil\n\t\t\t}\n\n\t\t\treturn os.Chown(p, uid, gid)\n\t\t},\n\t})\n\n\treturn errors.Wrap(err, \"server/filesystem: chown: failed to chown during walk function\")\n}\n\nfunc (fs *Filesystem) Chmod(path string, mode os.FileMode) error {\n\tcleaned, err := fs.SafePath(path)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif fs.isTest {\n\t\treturn nil\n\t}\n\n\tif err := os.Chmod(cleaned, mode); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n// Begin looping up to 50 times to try and create a unique copy file name. This will take\n// an input of \"file.txt\" and generate \"file copy.txt\". If that name is already taken, it will\n// then try to write \"file copy 2.txt\" and so on, until reaching 50 loops. At that point we\n// won't waste anymore time, just use the current timestamp and make that copy.\n//\n// Could probably make this more efficient by checking if there are any files matching the copy\n// pattern, and trying to find the highest number and then incrementing it by one rather than\n// looping endlessly.\nfunc (fs *Filesystem) findCopySuffix(dir string, name string, extension string) (string, error) {\n\tvar i int\n\tsuffix := \" copy\"\n\n\tfor i = 0; i < 51; i++ {\n\t\tif i > 0 {\n\t\t\tsuffix = \" copy \" + strconv.Itoa(i)\n\t\t}\n\n\t\tn := name + suffix + extension\n\t\t// If we stat the file and it does not exist that means we're good to create the copy. If it\n\t\t// does exist, we'll just continue to the next loop and try again.\n\t\tif _, err := fs.Stat(path.Join(dir, n)); err != nil {\n\t\t\tif !errors.Is(err, os.ErrNotExist) {\n\t\t\t\treturn \"\", err\n\t\t\t}\n\n\t\t\tbreak\n\t\t}\n\n\t\tif i == 50 {\n\t\t\tsuffix = \"copy.\" + time.Now().Format(time.RFC3339)\n\t\t}\n\t}\n\n\treturn name + suffix + extension, nil\n}\n\n// Copies a given file to the same location and appends a suffix to the file to indicate that\n// it has been copied.\nfunc (fs *Filesystem) Copy(p string) error {\n\tcleaned, err := fs.SafePath(p)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\ts, err := os.Stat(cleaned)\n\tif err != nil {\n\t\treturn err\n\t} else if s.IsDir() || !s.Mode().IsRegular() {\n\t\t// If this is a directory or not a regular file, just throw a not-exist error\n\t\t// since anything calling this function should understand what that means.\n\t\treturn os.ErrNotExist\n\t}\n\n\t// Check that copying this file wouldn't put the server over its limit.\n\tif err := fs.HasSpaceFor(s.Size()); err != nil {\n\t\treturn err\n\t}\n\n\tbase := filepath.Base(cleaned)\n\trelative := strings.TrimSuffix(strings.TrimPrefix(cleaned, fs.Path()), base)\n\textension := filepath.Ext(base)\n\tname := strings.TrimSuffix(base, extension)\n\n\t// Ensure that \".tar\" is also counted as apart of the file extension.\n\t// There might be a better way to handle this for other double file extensions,\n\t// but this is a good workaround for now.\n\tif strings.HasSuffix(name, \".tar\") {\n\t\textension = \".tar\" + extension\n\t\tname = strings.TrimSuffix(name, \".tar\")\n\t}\n\n\tsource, err := os.Open(cleaned)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer source.Close()\n\n\tn, err := fs.findCopySuffix(relative, name, extension)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn fs.Writefile(path.Join(relative, n), source)\n}\n\n// TruncateRootDirectory removes _all_ files and directories from a server's\n// data directory and resets the used disk space to zero.\nfunc (fs *Filesystem) TruncateRootDirectory() error {\n\tif err := os.RemoveAll(fs.Path()); err != nil {\n\t\treturn err\n\t}\n\tif err := os.Mkdir(fs.Path(), 0o755); err != nil {\n\t\treturn err\n\t}\n\tatomic.StoreInt64(&fs.diskUsed, 0)\n\treturn nil\n}\n\n// Delete removes a file or folder from the system. Prevents the user from\n// accidentally (or maliciously) removing their root server data directory.\nfunc (fs *Filesystem) Delete(p string) error {\n\twg := sync.WaitGroup{}\n\t// This is one of the few (only?) places in the codebase where we're explicitly not using\n\t// the SafePath functionality when working with user provided input. If we did, you would\n\t// not be able to delete a file that is a symlink pointing to a location outside of the data\n\t// directory.\n\t//\n\t// We also want to avoid resolving a symlink that points _within_ the data directory and thus\n\t// deleting the actual source file for the symlink rather than the symlink itself. For these\n\t// purposes just resolve the actual file path using filepath.Join() and confirm that the path\n\t// exists within the data directory.\n\tresolved := fs.unsafeFilePath(p)\n\tif !fs.unsafeIsInDataDirectory(resolved) {\n\t\treturn NewBadPathResolution(p, resolved)\n\t}\n\n\t// Block any whoopsies.\n\tif resolved == fs.Path() {\n\t\treturn errors.New(\"cannot delete root server directory\")\n\t}\n\n\tif st, err := os.Lstat(resolved); err != nil {\n\t\tif !os.IsNotExist(err) {\n\t\t\tfs.error(err).Warn(\"error while attempting to stat file before deletion\")\n\t\t}\n\t} else {\n\t\tif !st.IsDir() {\n\t\t\tfs.addDisk(-st.Size())\n\t\t} else {\n\t\t\twg.Add(1)\n\t\t\tgo func(wg *sync.WaitGroup, st os.FileInfo, resolved string) {\n\t\t\t\tdefer wg.Done()\n\t\t\t\tif s, err := fs.DirectorySize(resolved); err == nil {\n\t\t\t\t\tfs.addDisk(-s)\n\t\t\t\t}\n\t\t\t}(&wg, st, resolved)\n\t\t}\n\t}\n\n\twg.Wait()\n\n\treturn os.RemoveAll(resolved)\n}\n\ntype fileOpener struct {\n\tbusy uint\n}\n\n// Attempts to open a given file up to \"attempts\" number of times, using a backoff. If the file\n// cannot be opened because of a \"text file busy\" error, we will attempt until the number of attempts\n// has been exhaused, at which point we will abort with an error.\nfunc (fo *fileOpener) open(path string, flags int, perm os.FileMode) (*os.File, error) {\n\tfor {\n\t\tf, err := os.OpenFile(path, flags, perm)\n\n\t\t// If there is an error because the text file is busy, go ahead and sleep for a few\n\t\t// hundred milliseconds and then try again up to three times before just returning the\n\t\t// error back to the caller.\n\t\t//\n\t\t// Based on code from: https://github.com/golang/go/issues/22220#issuecomment-336458122\n\t\tif err != nil && fo.busy < 3 && strings.Contains(err.Error(), \"text file busy\") {\n\t\t\ttime.Sleep(100 * time.Millisecond << fo.busy)\n\t\t\tfo.busy++\n\t\t\tcontinue\n\t\t}\n\n\t\treturn f, err\n\t}\n}\n\n// ListDirectory lists the contents of a given directory and returns stat\n// information about each file and folder within it.\nfunc (fs *Filesystem) ListDirectory(p string) ([]Stat, error) {\n\tcleaned, err := fs.SafePath(p)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tfiles, err := ioutil.ReadDir(cleaned)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar wg sync.WaitGroup\n\n\t// You must initialize the output of this directory as a non-nil value otherwise\n\t// when it is marshaled into a JSON object you'll just get 'null' back, which will\n\t// break the panel badly.\n\tout := make([]Stat, len(files))\n\n\t// Iterate over all of the files and directories returned and perform an async process\n\t// to get the mime-type for them all.\n\tfor i, file := range files {\n\t\twg.Add(1)\n\n\t\tgo func(idx int, f os.FileInfo) {\n\t\t\tdefer wg.Done()\n\n\t\t\tvar m *mimetype.MIME\n\t\t\td := \"inode/directory\"\n\t\t\tif !f.IsDir() {\n\t\t\t\tcleanedp := filepath.Join(cleaned, f.Name())\n\t\t\t\tif f.Mode()&os.ModeSymlink != 0 {\n\t\t\t\t\tcleanedp, _ = fs.SafePath(filepath.Join(cleaned, f.Name()))\n\t\t\t\t}\n\n\t\t\t\t// Don't try to detect the type on a pipe \u2014 this will just hang the application and\n\t\t\t\t// you'll never get a response back.\n\t\t\t\t//\n\t\t\t\t// @see https://github.com/pterodactyl/panel/issues/4059\n\t\t\t\tif cleanedp != \"\" && f.Mode()&os.ModeNamedPipe == 0 {\n\t\t\t\t\tm, _ = mimetype.DetectFile(filepath.Join(cleaned, f.Name()))\n\t\t\t\t} else {\n\t\t\t\t\t// Just pass this for an unknown type because the file could not safely be resolved within\n\t\t\t\t\t// the server data path.\n\t\t\t\t\td = \"application/octet-stream\"\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tst := Stat{FileInfo: f, Mimetype: d}\n\t\t\tif m != nil {\n\t\t\t\tst.Mimetype = m.String()\n\t\t\t}\n\t\t\tout[idx] = st\n\t\t}(i, file)\n\t}\n\n\twg.Wait()\n\n\t// Sort the output alphabetically to begin with since we've run the output\n\t// through an asynchronous process and the order is gonna be very random.\n\tsort.SliceStable(out, func(i, j int) bool {\n\t\tif out[i].Name() == out[j].Name() || out[i].Name() > out[j].Name() {\n\t\t\treturn true\n\t\t}\n\t\treturn false\n\t})\n\n\t// Then, sort it so that directories are listed first in the output. Everything\n\t// will continue to be alphabetized at this point.\n\tsort.SliceStable(out, func(i, j int) bool {\n\t\treturn out[i].IsDir()\n\t})\n\n\treturn out, nil\n}\n\nfunc (fs *Filesystem) Chtimes(path string, atime, mtime time.Time) error {\n\tcleaned, err := fs.SafePath(path)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif fs.isTest {\n\t\treturn nil\n\t}\n\n\tif err := os.Chtimes(cleaned, atime, mtime); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n", "package filesystem\n\nimport (\n\t\"context\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"sync\"\n\n\t\"emperror.dev/errors\"\n\t\"golang.org/x/sync/errgroup\"\n)\n\n// Checks if the given file or path is in the server's file denylist. If so, an Error\n// is returned, otherwise nil is returned.\nfunc (fs *Filesystem) IsIgnored(paths ...string) error {\n\tfor _, p := range paths {\n\t\tsp, err := fs.SafePath(p)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif fs.denylist.MatchesPath(sp) {\n\t\t\treturn errors.WithStack(&Error{code: ErrCodeDenylistFile, path: p, resolved: sp})\n\t\t}\n\t}\n\treturn nil\n}\n\n// Normalizes a directory being passed in to ensure the user is not able to escape\n// from their data directory. After normalization if the directory is still within their home\n// path it is returned. If they managed to \"escape\" an error will be returned.\n//\n// This logic is actually copied over from the SFTP server code. Ideally that eventually\n// either gets ported into this application, or is able to make use of this package.\nfunc (fs *Filesystem) SafePath(p string) (string, error) {\n\tvar nonExistentPathResolution string\n\n\t// Start with a cleaned up path before checking the more complex bits.\n\tr := fs.unsafeFilePath(p)\n\n\t// At the same time, evaluate the symlink status and determine where this file or folder\n\t// is truly pointing to.\n\tep, err := filepath.EvalSymlinks(r)\n\tif err != nil && !os.IsNotExist(err) {\n\t\treturn \"\", errors.Wrap(err, \"server/filesystem: failed to evaluate symlink\")\n\t} else if os.IsNotExist(err) {\n\t\t// The requested directory doesn't exist, so at this point we need to iterate up the\n\t\t// path chain until we hit a directory that _does_ exist and can be validated.\n\t\tparts := strings.Split(filepath.Dir(r), \"/\")\n\n\t\tvar try string\n\t\t// Range over all of the path parts and form directory pathings from the end\n\t\t// moving up until we have a valid resolution or we run out of paths to try.\n\t\tfor k := range parts {\n\t\t\ttry = strings.Join(parts[:(len(parts)-k)], \"/\")\n\n\t\t\tif !fs.unsafeIsInDataDirectory(try) {\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tt, err := filepath.EvalSymlinks(try)\n\t\t\tif err == nil {\n\t\t\t\tnonExistentPathResolution = t\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\t// If the new path doesn't start with their root directory there is clearly an escape\n\t// attempt going on, and we should NOT resolve this path for them.\n\tif nonExistentPathResolution != \"\" {\n\t\tif !fs.unsafeIsInDataDirectory(nonExistentPathResolution) {\n\t\t\treturn \"\", NewBadPathResolution(p, nonExistentPathResolution)\n\t\t}\n\n\t\t// If the nonExistentPathResolution variable is not empty then the initial path requested\n\t\t// did not exist and we looped through the pathway until we found a match. At this point\n\t\t// we've confirmed the first matched pathway exists in the root server directory, so we\n\t\t// can go ahead and just return the path that was requested initially.\n\t\treturn r, nil\n\t}\n\n\t// If the requested directory from EvalSymlinks begins with the server root directory go\n\t// ahead and return it. If not we'll return an error which will block any further action\n\t// on the file.\n\tif fs.unsafeIsInDataDirectory(ep) {\n\t\treturn ep, nil\n\t}\n\n\treturn \"\", NewBadPathResolution(p, r)\n}\n\n// Generate a path to the file by cleaning it up and appending the root server path to it. This\n// DOES NOT guarantee that the file resolves within the server data directory. You'll want to use\n// the fs.unsafeIsInDataDirectory(p) function to confirm.\nfunc (fs *Filesystem) unsafeFilePath(p string) string {\n\t// Calling filepath.Clean on the joined directory will resolve it to the absolute path,\n\t// removing any ../ type of resolution arguments, and leaving us with a direct path link.\n\t//\n\t// This will also trim the existing root path off the beginning of the path passed to\n\t// the function since that can get a bit messy.\n\treturn filepath.Clean(filepath.Join(fs.Path(), strings.TrimPrefix(p, fs.Path())))\n}\n\n// Check that that path string starts with the server data directory path. This function DOES NOT\n// validate that the rest of the path does not end up resolving out of this directory, or that the\n// targeted file or folder is not a symlink doing the same thing.\nfunc (fs *Filesystem) unsafeIsInDataDirectory(p string) bool {\n\treturn strings.HasPrefix(strings.TrimSuffix(p, \"/\")+\"/\", strings.TrimSuffix(fs.Path(), \"/\")+\"/\")\n}\n\n// Executes the fs.SafePath function in parallel against an array of paths. If any of the calls\n// fails an error will be returned.\nfunc (fs *Filesystem) ParallelSafePath(paths []string) ([]string, error) {\n\tvar cleaned []string\n\n\t// Simple locker function to avoid racy appends to the array of cleaned paths.\n\tm := new(sync.Mutex)\n\tpush := func(c string) {\n\t\tm.Lock()\n\t\tcleaned = append(cleaned, c)\n\t\tm.Unlock()\n\t}\n\n\t// Create an error group that we can use to run processes in parallel while retaining\n\t// the ability to cancel the entire process immediately should any of it fail.\n\tg, ctx := errgroup.WithContext(context.Background())\n\n\t// Iterate over all of the paths and generate a cleaned path, if there is an error for any\n\t// of the files, abort the process.\n\tfor _, p := range paths {\n\t\t// Create copy so we can use it within the goroutine correctly.\n\t\tpi := p\n\n\t\t// Recursively call this function to continue digging through the directory tree within\n\t\t// a separate goroutine. If the context is canceled abort this process.\n\t\tg.Go(func() error {\n\t\t\tselect {\n\t\t\tcase <-ctx.Done():\n\t\t\t\treturn ctx.Err()\n\t\t\tdefault:\n\t\t\t\t// If the callback returns true, go ahead and keep walking deeper. This allows\n\t\t\t\t// us to programmatically continue deeper into directories, or stop digging\n\t\t\t\t// if that pathway knows it needs nothing else.\n\t\t\t\tif c, err := fs.SafePath(pi); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t} else {\n\t\t\t\t\tpush(c)\n\t\t\t\t}\n\n\t\t\t\treturn nil\n\t\t\t}\n\t\t})\n\t}\n\n\t// Block until all of the routines finish and have returned a value.\n\treturn cleaned, g.Wait()\n}\n", "package filesystem\n\nimport (\n\t\"bytes\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"testing\"\n\n\t\"emperror.dev/errors\"\n\t. \"github.com/franela/goblin\"\n)\n\nfunc TestFilesystem_Path(t *testing.T) {\n\tg := Goblin(t)\n\tfs, rfs := NewFs()\n\n\tg.Describe(\"Path\", func() {\n\t\tg.It(\"returns the root path for the instance\", func() {\n\t\t\tg.Assert(fs.Path()).Equal(filepath.Join(rfs.root, \"/server\"))\n\t\t})\n\t})\n}\n\nfunc TestFilesystem_SafePath(t *testing.T) {\n\tg := Goblin(t)\n\tfs, rfs := NewFs()\n\tprefix := filepath.Join(rfs.root, \"/server\")\n\n\tg.Describe(\"SafePath\", func() {\n\t\tg.It(\"returns a cleaned path to a given file\", func() {\n\t\t\tp, err := fs.SafePath(\"test.txt\")\n\t\t\tg.Assert(err).IsNil()\n\t\t\tg.Assert(p).Equal(prefix + \"/test.txt\")\n\n\t\t\tp, err = fs.SafePath(\"/test.txt\")\n\t\t\tg.Assert(err).IsNil()\n\t\t\tg.Assert(p).Equal(prefix + \"/test.txt\")\n\n\t\t\tp, err = fs.SafePath(\"./test.txt\")\n\t\t\tg.Assert(err).IsNil()\n\t\t\tg.Assert(p).Equal(prefix + \"/test.txt\")\n\n\t\t\tp, err = fs.SafePath(\"/foo/../test.txt\")\n\t\t\tg.Assert(err).IsNil()\n\t\t\tg.Assert(p).Equal(prefix + \"/test.txt\")\n\n\t\t\tp, err = fs.SafePath(\"/foo/bar\")\n\t\t\tg.Assert(err).IsNil()\n\t\t\tg.Assert(p).Equal(prefix + \"/foo/bar\")\n\t\t})\n\n\t\tg.It(\"handles root directory access\", func() {\n\t\t\tp, err := fs.SafePath(\"/\")\n\t\t\tg.Assert(err).IsNil()\n\t\t\tg.Assert(p).Equal(prefix)\n\n\t\t\tp, err = fs.SafePath(\"\")\n\t\t\tg.Assert(err).IsNil()\n\t\t\tg.Assert(p).Equal(prefix)\n\t\t})\n\n\t\tg.It(\"removes trailing slashes from paths\", func() {\n\t\t\tp, err := fs.SafePath(\"/foo/bar/\")\n\t\t\tg.Assert(err).IsNil()\n\t\t\tg.Assert(p).Equal(prefix + \"/foo/bar\")\n\t\t})\n\n\t\tg.It(\"handles deeply nested directories that do not exist\", func() {\n\t\t\tp, err := fs.SafePath(\"/foo/bar/baz/quaz/../../ducks/testing.txt\")\n\t\t\tg.Assert(err).IsNil()\n\t\t\tg.Assert(p).Equal(prefix + \"/foo/bar/ducks/testing.txt\")\n\t\t})\n\n\t\tg.It(\"blocks access to files outside the root directory\", func() {\n\t\t\tp, err := fs.SafePath(\"../test.txt\")\n\t\t\tg.Assert(err).IsNotNil()\n\t\t\tg.Assert(IsErrorCode(err, ErrCodePathResolution)).IsTrue()\n\t\t\tg.Assert(p).Equal(\"\")\n\n\t\t\tp, err = fs.SafePath(\"/../test.txt\")\n\t\t\tg.Assert(err).IsNotNil()\n\t\t\tg.Assert(IsErrorCode(err, ErrCodePathResolution)).IsTrue()\n\t\t\tg.Assert(p).Equal(\"\")\n\n\t\t\tp, err = fs.SafePath(\"./foo/../../test.txt\")\n\t\t\tg.Assert(err).IsNotNil()\n\t\t\tg.Assert(IsErrorCode(err, ErrCodePathResolution)).IsTrue()\n\t\t\tg.Assert(p).Equal(\"\")\n\n\t\t\tp, err = fs.SafePath(\"..\")\n\t\t\tg.Assert(err).IsNotNil()\n\t\t\tg.Assert(IsErrorCode(err, ErrCodePathResolution)).IsTrue()\n\t\t\tg.Assert(p).Equal(\"\")\n\t\t})\n\t})\n}\n\n// We test against accessing files outside the root directory in the tests, however it\n// is still possible for someone to mess up and not properly use this safe path call. In\n// order to truly confirm this, we'll try to pass in a symlinked malicious file to all of\n// the calls and ensure they all fail with the same reason.\nfunc TestFilesystem_Blocks_Symlinks(t *testing.T) {\n\tg := Goblin(t)\n\tfs, rfs := NewFs()\n\n\tif err := rfs.CreateServerFileFromString(\"/../malicious.txt\", \"external content\"); err != nil {\n\t\tpanic(err)\n\t}\n\n\tif err := os.Mkdir(filepath.Join(rfs.root, \"/malicious_dir\"), 0o777); err != nil {\n\t\tpanic(err)\n\t}\n\n\tif err := os.Symlink(filepath.Join(rfs.root, \"malicious.txt\"), filepath.Join(rfs.root, \"/server/symlinked.txt\")); err != nil {\n\t\tpanic(err)\n\t}\n\n\tif err := os.Symlink(filepath.Join(rfs.root, \"/malicious_dir\"), filepath.Join(rfs.root, \"/server/external_dir\")); err != nil {\n\t\tpanic(err)\n\t}\n\n\tg.Describe(\"Writefile\", func() {\n\t\tg.It(\"cannot write to a file symlinked outside the root\", func() {\n\t\t\tr := bytes.NewReader([]byte(\"testing\"))\n\n\t\t\terr := fs.Writefile(\"symlinked.txt\", r)\n\t\t\tg.Assert(err).IsNotNil()\n\t\t\tg.Assert(IsErrorCode(err, ErrCodePathResolution)).IsTrue()\n\t\t})\n\n\t\tg.It(\"cannot write a file to a directory symlinked outside the root\", func() {\n\t\t\tr := bytes.NewReader([]byte(\"testing\"))\n\n\t\t\terr := fs.Writefile(\"external_dir/foo.txt\", r)\n\t\t\tg.Assert(err).IsNotNil()\n\t\t\tg.Assert(IsErrorCode(err, ErrCodePathResolution)).IsTrue()\n\t\t})\n\t})\n\n\tg.Describe(\"CreateDirectory\", func() {\n\t\tg.It(\"cannot create a directory outside the root\", func() {\n\t\t\terr := fs.CreateDirectory(\"my_dir\", \"external_dir\")\n\t\t\tg.Assert(err).IsNotNil()\n\t\t\tg.Assert(IsErrorCode(err, ErrCodePathResolution)).IsTrue()\n\t\t})\n\n\t\tg.It(\"cannot create a nested directory outside the root\", func() {\n\t\t\terr := fs.CreateDirectory(\"my/nested/dir\", \"external_dir/foo/bar\")\n\t\t\tg.Assert(err).IsNotNil()\n\t\t\tg.Assert(IsErrorCode(err, ErrCodePathResolution)).IsTrue()\n\t\t})\n\n\t\tg.It(\"cannot create a nested directory outside the root\", func() {\n\t\t\terr := fs.CreateDirectory(\"my/nested/dir\", \"external_dir/server\")\n\t\t\tg.Assert(err).IsNotNil()\n\t\t\tg.Assert(IsErrorCode(err, ErrCodePathResolution)).IsTrue()\n\t\t})\n\t})\n\n\tg.Describe(\"Rename\", func() {\n\t\tg.It(\"cannot rename a file symlinked outside the directory root\", func() {\n\t\t\terr := fs.Rename(\"symlinked.txt\", \"foo.txt\")\n\t\t\tg.Assert(err).IsNotNil()\n\t\t\tg.Assert(IsErrorCode(err, ErrCodePathResolution)).IsTrue()\n\t\t})\n\n\t\tg.It(\"cannot rename a symlinked directory outside the root\", func() {\n\t\t\terr := fs.Rename(\"external_dir\", \"foo\")\n\t\t\tg.Assert(err).IsNotNil()\n\t\t\tg.Assert(IsErrorCode(err, ErrCodePathResolution)).IsTrue()\n\t\t})\n\n\t\tg.It(\"cannot rename a file to a location outside the directory root\", func() {\n\t\t\trfs.CreateServerFileFromString(\"my_file.txt\", \"internal content\")\n\n\t\t\terr := fs.Rename(\"my_file.txt\", \"external_dir/my_file.txt\")\n\t\t\tg.Assert(err).IsNotNil()\n\t\t\tg.Assert(IsErrorCode(err, ErrCodePathResolution)).IsTrue()\n\t\t})\n\t})\n\n\tg.Describe(\"Chown\", func() {\n\t\tg.It(\"cannot chown a file symlinked outside the directory root\", func() {\n\t\t\terr := fs.Chown(\"symlinked.txt\")\n\t\t\tg.Assert(err).IsNotNil()\n\t\t\tg.Assert(IsErrorCode(err, ErrCodePathResolution)).IsTrue()\n\t\t})\n\n\t\tg.It(\"cannot chown a directory symlinked outside the directory root\", func() {\n\t\t\terr := fs.Chown(\"external_dir\")\n\t\t\tg.Assert(err).IsNotNil()\n\t\t\tg.Assert(IsErrorCode(err, ErrCodePathResolution)).IsTrue()\n\t\t})\n\t})\n\n\tg.Describe(\"Copy\", func() {\n\t\tg.It(\"cannot copy a file symlinked outside the directory root\", func() {\n\t\t\terr := fs.Copy(\"symlinked.txt\")\n\t\t\tg.Assert(err).IsNotNil()\n\t\t\tg.Assert(IsErrorCode(err, ErrCodePathResolution)).IsTrue()\n\t\t})\n\t})\n\n\tg.Describe(\"Delete\", func() {\n\t\tg.It(\"deletes the symlinked file but leaves the source\", func() {\n\t\t\terr := fs.Delete(\"symlinked.txt\")\n\t\t\tg.Assert(err).IsNil()\n\n\t\t\t_, err = os.Stat(filepath.Join(rfs.root, \"malicious.txt\"))\n\t\t\tg.Assert(err).IsNil()\n\n\t\t\t_, err = rfs.StatServerFile(\"symlinked.txt\")\n\t\t\tg.Assert(err).IsNotNil()\n\t\t\tg.Assert(errors.Is(err, os.ErrNotExist)).IsTrue()\n\t\t})\n\t})\n\n\trfs.reset()\n}\n"], "fixing_code": ["package filesystem\n\nimport (\n\t\"bufio\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"path\"\n\t\"path/filepath\"\n\t\"sort\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"time\"\n\n\t\"emperror.dev/errors\"\n\t\"github.com/gabriel-vasile/mimetype\"\n\t\"github.com/karrick/godirwalk\"\n\tignore \"github.com/sabhiram/go-gitignore\"\n\n\t\"github.com/pterodactyl/wings/config\"\n\t\"github.com/pterodactyl/wings/system\"\n)\n\ntype Filesystem struct {\n\tmu                sync.RWMutex\n\tlastLookupTime    *usageLookupTime\n\tlookupInProgress  *system.AtomicBool\n\tdiskUsed          int64\n\tdiskCheckInterval time.Duration\n\tdenylist          *ignore.GitIgnore\n\n\t// The maximum amount of disk space (in bytes) that this Filesystem instance can use.\n\tdiskLimit int64\n\n\t// The root data directory path for this Filesystem instance.\n\troot string\n\n\tisTest bool\n}\n\n// New creates a new Filesystem instance for a given server.\nfunc New(root string, size int64, denylist []string) *Filesystem {\n\treturn &Filesystem{\n\t\troot:              root,\n\t\tdiskLimit:         size,\n\t\tdiskCheckInterval: time.Duration(config.Get().System.DiskCheckInterval),\n\t\tlastLookupTime:    &usageLookupTime{},\n\t\tlookupInProgress:  system.NewAtomicBool(false),\n\t\tdenylist:          ignore.CompileIgnoreLines(denylist...),\n\t}\n}\n\n// Path returns the root path for the Filesystem instance.\nfunc (fs *Filesystem) Path() string {\n\treturn fs.root\n}\n\n// File returns a reader for a file instance as well as the stat information.\nfunc (fs *Filesystem) File(p string) (*os.File, Stat, error) {\n\tcleaned, err := fs.SafePath(p)\n\tif err != nil {\n\t\treturn nil, Stat{}, errors.WithStackIf(err)\n\t}\n\tst, err := fs.Stat(cleaned)\n\tif err != nil {\n\t\tif errors.Is(err, os.ErrNotExist) {\n\t\t\treturn nil, Stat{}, newFilesystemError(ErrNotExist, err)\n\t\t}\n\t\treturn nil, Stat{}, errors.WithStackIf(err)\n\t}\n\tif st.IsDir() {\n\t\treturn nil, Stat{}, newFilesystemError(ErrCodeIsDirectory, nil)\n\t}\n\tf, err := os.Open(cleaned)\n\tif err != nil {\n\t\treturn nil, Stat{}, errors.WithStackIf(err)\n\t}\n\treturn f, st, nil\n}\n\n// Touch acts by creating the given file and path on the disk if it is not present\n// already. If  it is present, the file is opened using the defaults which will truncate\n// the contents. The opened file is then returned to the caller.\nfunc (fs *Filesystem) Touch(p string, flag int) (*os.File, error) {\n\tcleaned, err := fs.SafePath(p)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tf, err := os.OpenFile(cleaned, flag, 0o644)\n\tif err == nil {\n\t\treturn f, nil\n\t}\n\tif f != nil {\n\t\t_ = f.Close()\n\t}\n\t// If the error is not because it doesn't exist then we just need to bail at this point.\n\tif !errors.Is(err, os.ErrNotExist) {\n\t\treturn nil, errors.Wrap(err, \"server/filesystem: touch: failed to open file handle\")\n\t}\n\t// Only create and chown the directory if it doesn't exist.\n\tif _, err := os.Stat(filepath.Dir(cleaned)); errors.Is(err, os.ErrNotExist) {\n\t\t// Create the path leading up to the file we're trying to create, setting the final perms\n\t\t// on it as we go.\n\t\tif err := os.MkdirAll(filepath.Dir(cleaned), 0o755); err != nil {\n\t\t\treturn nil, errors.Wrap(err, \"server/filesystem: touch: failed to create directory tree\")\n\t\t}\n\t\tif err := fs.Chown(filepath.Dir(cleaned)); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\to := &fileOpener{}\n\t// Try to open the file now that we have created the pathing necessary for it, and then\n\t// Chown that file so that the permissions don't mess with things.\n\tf, err = o.open(cleaned, flag, 0o644)\n\tif err != nil {\n\t\treturn nil, errors.Wrap(err, \"server/filesystem: touch: failed to open file with wait\")\n\t}\n\t_ = fs.Chown(cleaned)\n\treturn f, nil\n}\n\n// Writefile writes a file to the system. If the file does not already exist one\n// will be created. This will also properly recalculate the disk space used by\n// the server when writing new files or modifying existing ones.\nfunc (fs *Filesystem) Writefile(p string, r io.Reader) error {\n\tcleaned, err := fs.SafePath(p)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvar currentSize int64\n\t// If the file does not exist on the system already go ahead and create the pathway\n\t// to it and an empty file. We'll then write to it later on after this completes.\n\tstat, err := os.Stat(cleaned)\n\tif err != nil && !os.IsNotExist(err) {\n\t\treturn errors.Wrap(err, \"server/filesystem: writefile: failed to stat file\")\n\t} else if err == nil {\n\t\tif stat.IsDir() {\n\t\t\treturn errors.WithStack(&Error{code: ErrCodeIsDirectory, resolved: cleaned})\n\t\t}\n\t\tcurrentSize = stat.Size()\n\t}\n\n\tbr := bufio.NewReader(r)\n\t// Check that the new size we're writing to the disk can fit. If there is currently\n\t// a file we'll subtract that current file size from the size of the buffer to determine\n\t// the amount of new data we're writing (or amount we're removing if smaller).\n\tif err := fs.HasSpaceFor(int64(br.Size()) - currentSize); err != nil {\n\t\treturn err\n\t}\n\n\t// Touch the file and return the handle to it at this point. This will create the file,\n\t// any necessary directories, and set the proper owner of the file.\n\tfile, err := fs.Touch(cleaned, os.O_RDWR|os.O_CREATE|os.O_TRUNC)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer file.Close()\n\n\tbuf := make([]byte, 1024*4)\n\tsz, err := io.CopyBuffer(file, r, buf)\n\n\t// Adjust the disk usage to account for the old size and the new size of the file.\n\tfs.addDisk(sz - currentSize)\n\n\treturn fs.unsafeChown(cleaned)\n}\n\n// Creates a new directory (name) at a specified path (p) for the server.\nfunc (fs *Filesystem) CreateDirectory(name string, p string) error {\n\tcleaned, err := fs.SafePath(path.Join(p, name))\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn os.MkdirAll(cleaned, 0o755)\n}\n\n// Rename moves (or renames) a file or directory.\nfunc (fs *Filesystem) Rename(from string, to string) error {\n\tcleanedFrom, err := fs.SafePath(from)\n\tif err != nil {\n\t\treturn errors.WithStack(err)\n\t}\n\n\tcleanedTo, err := fs.SafePath(to)\n\tif err != nil {\n\t\treturn errors.WithStack(err)\n\t}\n\n\t// If the target file or directory already exists the rename function will fail, so just\n\t// bail out now.\n\tif _, err := os.Stat(cleanedTo); err == nil {\n\t\treturn os.ErrExist\n\t}\n\n\tif cleanedTo == fs.Path() {\n\t\treturn errors.New(\"attempting to rename into an invalid directory space\")\n\t}\n\n\td := strings.TrimSuffix(cleanedTo, path.Base(cleanedTo))\n\t// Ensure that the directory we're moving into exists correctly on the system. Only do this if\n\t// we're not at the root directory level.\n\tif d != fs.Path() {\n\t\tif mkerr := os.MkdirAll(d, 0o755); mkerr != nil {\n\t\t\treturn errors.WithMessage(mkerr, \"failed to create directory structure for file rename\")\n\t\t}\n\t}\n\n\tif err := os.Rename(cleanedFrom, cleanedTo); err != nil {\n\t\treturn errors.WithStack(err)\n\t}\n\treturn nil\n}\n\n// Recursively iterates over a file or directory and sets the permissions on all of the\n// underlying files. Iterate over all of the files and directories. If it is a file just\n// go ahead and perform the chown operation. Otherwise dig deeper into the directory until\n// we've run out of directories to dig into.\nfunc (fs *Filesystem) Chown(path string) error {\n\tcleaned, err := fs.SafePath(path)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn fs.unsafeChown(cleaned)\n}\n\n// unsafeChown chowns the given path, without checking if the path is safe. This should only be used\n// when the path has already been checked.\nfunc (fs *Filesystem) unsafeChown(path string) error {\n\tif fs.isTest {\n\t\treturn nil\n\t}\n\n\tuid := config.Get().System.User.Uid\n\tgid := config.Get().System.User.Gid\n\n\t// Start by just chowning the initial path that we received.\n\tif err := os.Chown(path, uid, gid); err != nil {\n\t\treturn errors.Wrap(err, \"server/filesystem: chown: failed to chown path\")\n\t}\n\n\t// If this is not a directory we can now return from the function, there is nothing\n\t// left that we need to do.\n\tif st, err := os.Stat(path); err != nil || !st.IsDir() {\n\t\treturn nil\n\t}\n\n\t// If this was a directory, begin walking over its contents recursively and ensure that all\n\t// of the subfiles and directories get their permissions updated as well.\n\terr := godirwalk.Walk(path, &godirwalk.Options{\n\t\tUnsorted: true,\n\t\tCallback: func(p string, e *godirwalk.Dirent) error {\n\t\t\t// Do not attempt to chown a symlink. Go's os.Chown function will affect the symlink\n\t\t\t// so if it points to a location outside the data directory the user would be able to\n\t\t\t// (un)intentionally modify that files permissions.\n\t\t\tif e.IsSymlink() {\n\t\t\t\tif e.IsDir() {\n\t\t\t\t\treturn godirwalk.SkipThis\n\t\t\t\t}\n\n\t\t\t\treturn nil\n\t\t\t}\n\n\t\t\treturn os.Chown(p, uid, gid)\n\t\t},\n\t})\n\treturn errors.Wrap(err, \"server/filesystem: chown: failed to chown during walk function\")\n}\n\nfunc (fs *Filesystem) Chmod(path string, mode os.FileMode) error {\n\tcleaned, err := fs.SafePath(path)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif fs.isTest {\n\t\treturn nil\n\t}\n\n\tif err := os.Chmod(cleaned, mode); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n// Begin looping up to 50 times to try and create a unique copy file name. This will take\n// an input of \"file.txt\" and generate \"file copy.txt\". If that name is already taken, it will\n// then try to write \"file copy 2.txt\" and so on, until reaching 50 loops. At that point we\n// won't waste anymore time, just use the current timestamp and make that copy.\n//\n// Could probably make this more efficient by checking if there are any files matching the copy\n// pattern, and trying to find the highest number and then incrementing it by one rather than\n// looping endlessly.\nfunc (fs *Filesystem) findCopySuffix(dir string, name string, extension string) (string, error) {\n\tvar i int\n\tsuffix := \" copy\"\n\n\tfor i = 0; i < 51; i++ {\n\t\tif i > 0 {\n\t\t\tsuffix = \" copy \" + strconv.Itoa(i)\n\t\t}\n\n\t\tn := name + suffix + extension\n\t\t// If we stat the file and it does not exist that means we're good to create the copy. If it\n\t\t// does exist, we'll just continue to the next loop and try again.\n\t\tif _, err := fs.Stat(path.Join(dir, n)); err != nil {\n\t\t\tif !errors.Is(err, os.ErrNotExist) {\n\t\t\t\treturn \"\", err\n\t\t\t}\n\n\t\t\tbreak\n\t\t}\n\n\t\tif i == 50 {\n\t\t\tsuffix = \"copy.\" + time.Now().Format(time.RFC3339)\n\t\t}\n\t}\n\n\treturn name + suffix + extension, nil\n}\n\n// Copies a given file to the same location and appends a suffix to the file to indicate that\n// it has been copied.\nfunc (fs *Filesystem) Copy(p string) error {\n\tcleaned, err := fs.SafePath(p)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\ts, err := os.Stat(cleaned)\n\tif err != nil {\n\t\treturn err\n\t} else if s.IsDir() || !s.Mode().IsRegular() {\n\t\t// If this is a directory or not a regular file, just throw a not-exist error\n\t\t// since anything calling this function should understand what that means.\n\t\treturn os.ErrNotExist\n\t}\n\n\t// Check that copying this file wouldn't put the server over its limit.\n\tif err := fs.HasSpaceFor(s.Size()); err != nil {\n\t\treturn err\n\t}\n\n\tbase := filepath.Base(cleaned)\n\trelative := strings.TrimSuffix(strings.TrimPrefix(cleaned, fs.Path()), base)\n\textension := filepath.Ext(base)\n\tname := strings.TrimSuffix(base, extension)\n\n\t// Ensure that \".tar\" is also counted as apart of the file extension.\n\t// There might be a better way to handle this for other double file extensions,\n\t// but this is a good workaround for now.\n\tif strings.HasSuffix(name, \".tar\") {\n\t\textension = \".tar\" + extension\n\t\tname = strings.TrimSuffix(name, \".tar\")\n\t}\n\n\tsource, err := os.Open(cleaned)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer source.Close()\n\n\tn, err := fs.findCopySuffix(relative, name, extension)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn fs.Writefile(path.Join(relative, n), source)\n}\n\n// TruncateRootDirectory removes _all_ files and directories from a server's\n// data directory and resets the used disk space to zero.\nfunc (fs *Filesystem) TruncateRootDirectory() error {\n\tif err := os.RemoveAll(fs.Path()); err != nil {\n\t\treturn err\n\t}\n\tif err := os.Mkdir(fs.Path(), 0o755); err != nil {\n\t\treturn err\n\t}\n\tatomic.StoreInt64(&fs.diskUsed, 0)\n\treturn nil\n}\n\n// Delete removes a file or folder from the system. Prevents the user from\n// accidentally (or maliciously) removing their root server data directory.\nfunc (fs *Filesystem) Delete(p string) error {\n\twg := sync.WaitGroup{}\n\t// This is one of the few (only?) places in the codebase where we're explicitly not using\n\t// the SafePath functionality when working with user provided input. If we did, you would\n\t// not be able to delete a file that is a symlink pointing to a location outside of the data\n\t// directory.\n\t//\n\t// We also want to avoid resolving a symlink that points _within_ the data directory and thus\n\t// deleting the actual source file for the symlink rather than the symlink itself. For these\n\t// purposes just resolve the actual file path using filepath.Join() and confirm that the path\n\t// exists within the data directory.\n\tresolved := fs.unsafeFilePath(p)\n\tif !fs.unsafeIsInDataDirectory(resolved) {\n\t\treturn NewBadPathResolution(p, resolved)\n\t}\n\n\t// Block any whoopsies.\n\tif resolved == fs.Path() {\n\t\treturn errors.New(\"cannot delete root server directory\")\n\t}\n\n\tif st, err := os.Lstat(resolved); err != nil {\n\t\tif !os.IsNotExist(err) {\n\t\t\tfs.error(err).Warn(\"error while attempting to stat file before deletion\")\n\t\t}\n\t} else {\n\t\tif !st.IsDir() {\n\t\t\tfs.addDisk(-st.Size())\n\t\t} else {\n\t\t\twg.Add(1)\n\t\t\tgo func(wg *sync.WaitGroup, st os.FileInfo, resolved string) {\n\t\t\t\tdefer wg.Done()\n\t\t\t\tif s, err := fs.DirectorySize(resolved); err == nil {\n\t\t\t\t\tfs.addDisk(-s)\n\t\t\t\t}\n\t\t\t}(&wg, st, resolved)\n\t\t}\n\t}\n\n\twg.Wait()\n\n\treturn os.RemoveAll(resolved)\n}\n\ntype fileOpener struct {\n\tbusy uint\n}\n\n// Attempts to open a given file up to \"attempts\" number of times, using a backoff. If the file\n// cannot be opened because of a \"text file busy\" error, we will attempt until the number of attempts\n// has been exhaused, at which point we will abort with an error.\nfunc (fo *fileOpener) open(path string, flags int, perm os.FileMode) (*os.File, error) {\n\tfor {\n\t\tf, err := os.OpenFile(path, flags, perm)\n\n\t\t// If there is an error because the text file is busy, go ahead and sleep for a few\n\t\t// hundred milliseconds and then try again up to three times before just returning the\n\t\t// error back to the caller.\n\t\t//\n\t\t// Based on code from: https://github.com/golang/go/issues/22220#issuecomment-336458122\n\t\tif err != nil && fo.busy < 3 && strings.Contains(err.Error(), \"text file busy\") {\n\t\t\ttime.Sleep(100 * time.Millisecond << fo.busy)\n\t\t\tfo.busy++\n\t\t\tcontinue\n\t\t}\n\n\t\treturn f, err\n\t}\n}\n\n// ListDirectory lists the contents of a given directory and returns stat\n// information about each file and folder within it.\nfunc (fs *Filesystem) ListDirectory(p string) ([]Stat, error) {\n\tcleaned, err := fs.SafePath(p)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tfiles, err := ioutil.ReadDir(cleaned)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar wg sync.WaitGroup\n\n\t// You must initialize the output of this directory as a non-nil value otherwise\n\t// when it is marshaled into a JSON object you'll just get 'null' back, which will\n\t// break the panel badly.\n\tout := make([]Stat, len(files))\n\n\t// Iterate over all of the files and directories returned and perform an async process\n\t// to get the mime-type for them all.\n\tfor i, file := range files {\n\t\twg.Add(1)\n\n\t\tgo func(idx int, f os.FileInfo) {\n\t\t\tdefer wg.Done()\n\n\t\t\tvar m *mimetype.MIME\n\t\t\td := \"inode/directory\"\n\t\t\tif !f.IsDir() {\n\t\t\t\tcleanedp := filepath.Join(cleaned, f.Name())\n\t\t\t\tif f.Mode()&os.ModeSymlink != 0 {\n\t\t\t\t\tcleanedp, _ = fs.SafePath(filepath.Join(cleaned, f.Name()))\n\t\t\t\t}\n\n\t\t\t\t// Don't try to detect the type on a pipe \u2014 this will just hang the application and\n\t\t\t\t// you'll never get a response back.\n\t\t\t\t//\n\t\t\t\t// @see https://github.com/pterodactyl/panel/issues/4059\n\t\t\t\tif cleanedp != \"\" && f.Mode()&os.ModeNamedPipe == 0 {\n\t\t\t\t\tm, _ = mimetype.DetectFile(filepath.Join(cleaned, f.Name()))\n\t\t\t\t} else {\n\t\t\t\t\t// Just pass this for an unknown type because the file could not safely be resolved within\n\t\t\t\t\t// the server data path.\n\t\t\t\t\td = \"application/octet-stream\"\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tst := Stat{FileInfo: f, Mimetype: d}\n\t\t\tif m != nil {\n\t\t\t\tst.Mimetype = m.String()\n\t\t\t}\n\t\t\tout[idx] = st\n\t\t}(i, file)\n\t}\n\n\twg.Wait()\n\n\t// Sort the output alphabetically to begin with since we've run the output\n\t// through an asynchronous process and the order is gonna be very random.\n\tsort.SliceStable(out, func(i, j int) bool {\n\t\tif out[i].Name() == out[j].Name() || out[i].Name() > out[j].Name() {\n\t\t\treturn true\n\t\t}\n\t\treturn false\n\t})\n\n\t// Then, sort it so that directories are listed first in the output. Everything\n\t// will continue to be alphabetized at this point.\n\tsort.SliceStable(out, func(i, j int) bool {\n\t\treturn out[i].IsDir()\n\t})\n\n\treturn out, nil\n}\n\nfunc (fs *Filesystem) Chtimes(path string, atime, mtime time.Time) error {\n\tcleaned, err := fs.SafePath(path)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif fs.isTest {\n\t\treturn nil\n\t}\n\n\tif err := os.Chtimes(cleaned, atime, mtime); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n", "package filesystem\n\nimport (\n\t\"context\"\n\tiofs \"io/fs\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"sync\"\n\n\t\"emperror.dev/errors\"\n\t\"golang.org/x/sync/errgroup\"\n)\n\n// Checks if the given file or path is in the server's file denylist. If so, an Error\n// is returned, otherwise nil is returned.\nfunc (fs *Filesystem) IsIgnored(paths ...string) error {\n\tfor _, p := range paths {\n\t\tsp, err := fs.SafePath(p)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif fs.denylist.MatchesPath(sp) {\n\t\t\treturn errors.WithStack(&Error{code: ErrCodeDenylistFile, path: p, resolved: sp})\n\t\t}\n\t}\n\treturn nil\n}\n\n// Normalizes a directory being passed in to ensure the user is not able to escape\n// from their data directory. After normalization if the directory is still within their home\n// path it is returned. If they managed to \"escape\" an error will be returned.\n//\n// This logic is actually copied over from the SFTP server code. Ideally that eventually\n// either gets ported into this application, or is able to make use of this package.\nfunc (fs *Filesystem) SafePath(p string) (string, error) {\n\t// Start with a cleaned up path before checking the more complex bits.\n\tr := fs.unsafeFilePath(p)\n\n\t// At the same time, evaluate the symlink status and determine where this file or folder\n\t// is truly pointing to.\n\tep, err := filepath.EvalSymlinks(r)\n\tif err != nil && !os.IsNotExist(err) {\n\t\treturn \"\", errors.Wrap(err, \"server/filesystem: failed to evaluate symlink\")\n\t} else if os.IsNotExist(err) {\n\t\t// The target of one of the symlinks (EvalSymlinks is recursive) does not exist.\n\t\t// So we get what target path does not exist and check if it's within the data\n\t\t// directory. If it is, we return the original path, otherwise we return an error.\n\t\tpErr, ok := err.(*iofs.PathError)\n\t\tif !ok {\n\t\t\treturn \"\", errors.Wrap(err, \"server/filesystem: failed to evaluate symlink\")\n\t\t}\n\t\tep = pErr.Path\n\t}\n\n\t// If the requested directory from EvalSymlinks begins with the server root directory go\n\t// ahead and return it. If not we'll return an error which will block any further action\n\t// on the file.\n\tif fs.unsafeIsInDataDirectory(ep) {\n\t\t// Returning the original path here instead of the resolved path ensures that\n\t\t// whatever the user is trying to do will work as expected. If we returned the\n\t\t// resolved path, the user would be unable to know that it is in fact a symlink.\n\t\treturn r, nil\n\t}\n\n\treturn \"\", NewBadPathResolution(p, r)\n}\n\n// Generate a path to the file by cleaning it up and appending the root server path to it. This\n// DOES NOT guarantee that the file resolves within the server data directory. You'll want to use\n// the fs.unsafeIsInDataDirectory(p) function to confirm.\nfunc (fs *Filesystem) unsafeFilePath(p string) string {\n\t// Calling filepath.Clean on the joined directory will resolve it to the absolute path,\n\t// removing any ../ type of resolution arguments, and leaving us with a direct path link.\n\t//\n\t// This will also trim the existing root path off the beginning of the path passed to\n\t// the function since that can get a bit messy.\n\treturn filepath.Clean(filepath.Join(fs.Path(), strings.TrimPrefix(p, fs.Path())))\n}\n\n// Check that that path string starts with the server data directory path. This function DOES NOT\n// validate that the rest of the path does not end up resolving out of this directory, or that the\n// targeted file or folder is not a symlink doing the same thing.\nfunc (fs *Filesystem) unsafeIsInDataDirectory(p string) bool {\n\treturn strings.HasPrefix(strings.TrimSuffix(p, \"/\")+\"/\", strings.TrimSuffix(fs.Path(), \"/\")+\"/\")\n}\n\n// Executes the fs.SafePath function in parallel against an array of paths. If any of the calls\n// fails an error will be returned.\nfunc (fs *Filesystem) ParallelSafePath(paths []string) ([]string, error) {\n\tvar cleaned []string\n\n\t// Simple locker function to avoid racy appends to the array of cleaned paths.\n\tm := new(sync.Mutex)\n\tpush := func(c string) {\n\t\tm.Lock()\n\t\tcleaned = append(cleaned, c)\n\t\tm.Unlock()\n\t}\n\n\t// Create an error group that we can use to run processes in parallel while retaining\n\t// the ability to cancel the entire process immediately should any of it fail.\n\tg, ctx := errgroup.WithContext(context.Background())\n\n\t// Iterate over all of the paths and generate a cleaned path, if there is an error for any\n\t// of the files, abort the process.\n\tfor _, p := range paths {\n\t\t// Create copy so we can use it within the goroutine correctly.\n\t\tpi := p\n\n\t\t// Recursively call this function to continue digging through the directory tree within\n\t\t// a separate goroutine. If the context is canceled abort this process.\n\t\tg.Go(func() error {\n\t\t\tselect {\n\t\t\tcase <-ctx.Done():\n\t\t\t\treturn ctx.Err()\n\t\t\tdefault:\n\t\t\t\t// If the callback returns true, go ahead and keep walking deeper. This allows\n\t\t\t\t// us to programmatically continue deeper into directories, or stop digging\n\t\t\t\t// if that pathway knows it needs nothing else.\n\t\t\t\tif c, err := fs.SafePath(pi); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t} else {\n\t\t\t\t\tpush(c)\n\t\t\t\t}\n\n\t\t\t\treturn nil\n\t\t\t}\n\t\t})\n\t}\n\n\t// Block until all of the routines finish and have returned a value.\n\treturn cleaned, g.Wait()\n}\n", "package filesystem\n\nimport (\n\t\"bytes\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"testing\"\n\n\t\"emperror.dev/errors\"\n\t. \"github.com/franela/goblin\"\n)\n\nfunc TestFilesystem_Path(t *testing.T) {\n\tg := Goblin(t)\n\tfs, rfs := NewFs()\n\n\tg.Describe(\"Path\", func() {\n\t\tg.It(\"returns the root path for the instance\", func() {\n\t\t\tg.Assert(fs.Path()).Equal(filepath.Join(rfs.root, \"/server\"))\n\t\t})\n\t})\n}\n\nfunc TestFilesystem_SafePath(t *testing.T) {\n\tg := Goblin(t)\n\tfs, rfs := NewFs()\n\tprefix := filepath.Join(rfs.root, \"/server\")\n\n\tg.Describe(\"SafePath\", func() {\n\t\tg.It(\"returns a cleaned path to a given file\", func() {\n\t\t\tp, err := fs.SafePath(\"test.txt\")\n\t\t\tg.Assert(err).IsNil()\n\t\t\tg.Assert(p).Equal(prefix + \"/test.txt\")\n\n\t\t\tp, err = fs.SafePath(\"/test.txt\")\n\t\t\tg.Assert(err).IsNil()\n\t\t\tg.Assert(p).Equal(prefix + \"/test.txt\")\n\n\t\t\tp, err = fs.SafePath(\"./test.txt\")\n\t\t\tg.Assert(err).IsNil()\n\t\t\tg.Assert(p).Equal(prefix + \"/test.txt\")\n\n\t\t\tp, err = fs.SafePath(\"/foo/../test.txt\")\n\t\t\tg.Assert(err).IsNil()\n\t\t\tg.Assert(p).Equal(prefix + \"/test.txt\")\n\n\t\t\tp, err = fs.SafePath(\"/foo/bar\")\n\t\t\tg.Assert(err).IsNil()\n\t\t\tg.Assert(p).Equal(prefix + \"/foo/bar\")\n\t\t})\n\n\t\tg.It(\"handles root directory access\", func() {\n\t\t\tp, err := fs.SafePath(\"/\")\n\t\t\tg.Assert(err).IsNil()\n\t\t\tg.Assert(p).Equal(prefix)\n\n\t\t\tp, err = fs.SafePath(\"\")\n\t\t\tg.Assert(err).IsNil()\n\t\t\tg.Assert(p).Equal(prefix)\n\t\t})\n\n\t\tg.It(\"removes trailing slashes from paths\", func() {\n\t\t\tp, err := fs.SafePath(\"/foo/bar/\")\n\t\t\tg.Assert(err).IsNil()\n\t\t\tg.Assert(p).Equal(prefix + \"/foo/bar\")\n\t\t})\n\n\t\tg.It(\"handles deeply nested directories that do not exist\", func() {\n\t\t\tp, err := fs.SafePath(\"/foo/bar/baz/quaz/../../ducks/testing.txt\")\n\t\t\tg.Assert(err).IsNil()\n\t\t\tg.Assert(p).Equal(prefix + \"/foo/bar/ducks/testing.txt\")\n\t\t})\n\n\t\tg.It(\"blocks access to files outside the root directory\", func() {\n\t\t\tp, err := fs.SafePath(\"../test.txt\")\n\t\t\tg.Assert(err).IsNotNil()\n\t\t\tg.Assert(IsErrorCode(err, ErrCodePathResolution)).IsTrue()\n\t\t\tg.Assert(p).Equal(\"\")\n\n\t\t\tp, err = fs.SafePath(\"/../test.txt\")\n\t\t\tg.Assert(err).IsNotNil()\n\t\t\tg.Assert(IsErrorCode(err, ErrCodePathResolution)).IsTrue()\n\t\t\tg.Assert(p).Equal(\"\")\n\n\t\t\tp, err = fs.SafePath(\"./foo/../../test.txt\")\n\t\t\tg.Assert(err).IsNotNil()\n\t\t\tg.Assert(IsErrorCode(err, ErrCodePathResolution)).IsTrue()\n\t\t\tg.Assert(p).Equal(\"\")\n\n\t\t\tp, err = fs.SafePath(\"..\")\n\t\t\tg.Assert(err).IsNotNil()\n\t\t\tg.Assert(IsErrorCode(err, ErrCodePathResolution)).IsTrue()\n\t\t\tg.Assert(p).Equal(\"\")\n\t\t})\n\t})\n}\n\n// We test against accessing files outside the root directory in the tests, however it\n// is still possible for someone to mess up and not properly use this safe path call. In\n// order to truly confirm this, we'll try to pass in a symlinked malicious file to all of\n// the calls and ensure they all fail with the same reason.\nfunc TestFilesystem_Blocks_Symlinks(t *testing.T) {\n\tg := Goblin(t)\n\tfs, rfs := NewFs()\n\n\tif err := rfs.CreateServerFileFromString(\"/../malicious.txt\", \"external content\"); err != nil {\n\t\tpanic(err)\n\t}\n\n\tif err := os.Mkdir(filepath.Join(rfs.root, \"/malicious_dir\"), 0o777); err != nil {\n\t\tpanic(err)\n\t}\n\n\tif err := os.Symlink(filepath.Join(rfs.root, \"malicious.txt\"), filepath.Join(rfs.root, \"/server/symlinked.txt\")); err != nil {\n\t\tpanic(err)\n\t}\n\n\tif err := os.Symlink(filepath.Join(rfs.root, \"malicious_does_not_exist.txt\"), filepath.Join(rfs.root, \"/server/symlinked_does_not_exist.txt\")); err != nil {\n\t\tpanic(err)\n\t}\n\n\tif err := os.Symlink(filepath.Join(rfs.root, \"/server/symlinked_does_not_exist.txt\"), filepath.Join(rfs.root, \"/server/symlinked_does_not_exist2.txt\")); err != nil {\n\t\tpanic(err)\n\t}\n\n\tif err := os.Symlink(filepath.Join(rfs.root, \"/malicious_dir\"), filepath.Join(rfs.root, \"/server/external_dir\")); err != nil {\n\t\tpanic(err)\n\t}\n\n\tg.Describe(\"Writefile\", func() {\n\t\tg.It(\"cannot write to a file symlinked outside the root\", func() {\n\t\t\tr := bytes.NewReader([]byte(\"testing\"))\n\n\t\t\terr := fs.Writefile(\"symlinked.txt\", r)\n\t\t\tg.Assert(err).IsNotNil()\n\t\t\tg.Assert(IsErrorCode(err, ErrCodePathResolution)).IsTrue()\n\t\t})\n\n\t\tg.It(\"cannot write to a non-existent file symlinked outside the root\", func() {\n\t\t\tr := bytes.NewReader([]byte(\"testing what the fuck\"))\n\n\t\t\terr := fs.Writefile(\"symlinked_does_not_exist.txt\", r)\n\t\t\tg.Assert(err).IsNotNil()\n\t\t\tg.Assert(IsErrorCode(err, ErrCodePathResolution)).IsTrue()\n\t\t})\n\n\t\tg.It(\"cannot write to chained symlinks with target that does not exist outside the root\", func() {\n\t\t\tr := bytes.NewReader([]byte(\"testing what the fuck\"))\n\n\t\t\terr := fs.Writefile(\"symlinked_does_not_exist2.txt\", r)\n\t\t\tg.Assert(err).IsNotNil()\n\t\t\tg.Assert(IsErrorCode(err, ErrCodePathResolution)).IsTrue()\n\t\t})\n\n\t\tg.It(\"cannot write a file to a directory symlinked outside the root\", func() {\n\t\t\tr := bytes.NewReader([]byte(\"testing\"))\n\n\t\t\terr := fs.Writefile(\"external_dir/foo.txt\", r)\n\t\t\tg.Assert(err).IsNotNil()\n\t\t\tg.Assert(IsErrorCode(err, ErrCodePathResolution)).IsTrue()\n\t\t})\n\t})\n\n\tg.Describe(\"CreateDirectory\", func() {\n\t\tg.It(\"cannot create a directory outside the root\", func() {\n\t\t\terr := fs.CreateDirectory(\"my_dir\", \"external_dir\")\n\t\t\tg.Assert(err).IsNotNil()\n\t\t\tg.Assert(IsErrorCode(err, ErrCodePathResolution)).IsTrue()\n\t\t})\n\n\t\tg.It(\"cannot create a nested directory outside the root\", func() {\n\t\t\terr := fs.CreateDirectory(\"my/nested/dir\", \"external_dir/foo/bar\")\n\t\t\tg.Assert(err).IsNotNil()\n\t\t\tg.Assert(IsErrorCode(err, ErrCodePathResolution)).IsTrue()\n\t\t})\n\n\t\tg.It(\"cannot create a nested directory outside the root\", func() {\n\t\t\terr := fs.CreateDirectory(\"my/nested/dir\", \"external_dir/server\")\n\t\t\tg.Assert(err).IsNotNil()\n\t\t\tg.Assert(IsErrorCode(err, ErrCodePathResolution)).IsTrue()\n\t\t})\n\t})\n\n\tg.Describe(\"Rename\", func() {\n\t\tg.It(\"cannot rename a file symlinked outside the directory root\", func() {\n\t\t\terr := fs.Rename(\"symlinked.txt\", \"foo.txt\")\n\t\t\tg.Assert(err).IsNotNil()\n\t\t\tg.Assert(IsErrorCode(err, ErrCodePathResolution)).IsTrue()\n\t\t})\n\n\t\tg.It(\"cannot rename a symlinked directory outside the root\", func() {\n\t\t\terr := fs.Rename(\"external_dir\", \"foo\")\n\t\t\tg.Assert(err).IsNotNil()\n\t\t\tg.Assert(IsErrorCode(err, ErrCodePathResolution)).IsTrue()\n\t\t})\n\n\t\tg.It(\"cannot rename a file to a location outside the directory root\", func() {\n\t\t\trfs.CreateServerFileFromString(\"my_file.txt\", \"internal content\")\n\n\t\t\terr := fs.Rename(\"my_file.txt\", \"external_dir/my_file.txt\")\n\t\t\tg.Assert(err).IsNotNil()\n\t\t\tg.Assert(IsErrorCode(err, ErrCodePathResolution)).IsTrue()\n\t\t})\n\t})\n\n\tg.Describe(\"Chown\", func() {\n\t\tg.It(\"cannot chown a file symlinked outside the directory root\", func() {\n\t\t\terr := fs.Chown(\"symlinked.txt\")\n\t\t\tg.Assert(err).IsNotNil()\n\t\t\tg.Assert(IsErrorCode(err, ErrCodePathResolution)).IsTrue()\n\t\t})\n\n\t\tg.It(\"cannot chown a directory symlinked outside the directory root\", func() {\n\t\t\terr := fs.Chown(\"external_dir\")\n\t\t\tg.Assert(err).IsNotNil()\n\t\t\tg.Assert(IsErrorCode(err, ErrCodePathResolution)).IsTrue()\n\t\t})\n\t})\n\n\tg.Describe(\"Copy\", func() {\n\t\tg.It(\"cannot copy a file symlinked outside the directory root\", func() {\n\t\t\terr := fs.Copy(\"symlinked.txt\")\n\t\t\tg.Assert(err).IsNotNil()\n\t\t\tg.Assert(IsErrorCode(err, ErrCodePathResolution)).IsTrue()\n\t\t})\n\t})\n\n\tg.Describe(\"Delete\", func() {\n\t\tg.It(\"deletes the symlinked file but leaves the source\", func() {\n\t\t\terr := fs.Delete(\"symlinked.txt\")\n\t\t\tg.Assert(err).IsNil()\n\n\t\t\t_, err = os.Stat(filepath.Join(rfs.root, \"malicious.txt\"))\n\t\t\tg.Assert(err).IsNil()\n\n\t\t\t_, err = rfs.StatServerFile(\"symlinked.txt\")\n\t\t\tg.Assert(err).IsNotNil()\n\t\t\tg.Assert(errors.Is(err, os.ErrNotExist)).IsTrue()\n\t\t})\n\t})\n\n\trfs.reset()\n}\n"], "filenames": ["server/filesystem/filesystem.go", "server/filesystem/path.go", "server/filesystem/path_test.go"], "buggy_code_start_loc": [168, 4, 117], "buggy_code_end_loc": [265, 88, 130], "fixing_code_start_loc": [168, 5, 118], "fixing_code_end_loc": [268, 64, 155], "type": "CWE-59", "message": "Wings is Pterodactyl's server control plane. Affected versions are subject to a vulnerability which can be used to create new files and directory structures on the host system that previously did not exist, potentially allowing attackers to change their resource allocations, promote their containers to privileged mode, or potentially add ssh authorized keys to allow the attacker access to a remote shell on the target machine. In order to use this exploit, an attacker must have an existing \"server\" allocated and controlled by the Wings Daemon. This vulnerability has been resolved in version `v1.11.3` of the Wings Daemon, and has been back-ported to the 1.7 release series in `v1.7.3`. Anyone running `v1.11.x` should upgrade to `v1.11.3` and anyone running `v1.7.x` should upgrade to `v1.7.3`. There are no known workarounds for this vulnerability. ### Workarounds None at this time.", "other": {"cve": {"id": "CVE-2023-25152", "sourceIdentifier": "security-advisories@github.com", "published": "2023-02-08T19:15:11.953", "lastModified": "2023-02-24T06:20:23.087", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Wings is Pterodactyl's server control plane. Affected versions are subject to a vulnerability which can be used to create new files and directory structures on the host system that previously did not exist, potentially allowing attackers to change their resource allocations, promote their containers to privileged mode, or potentially add ssh authorized keys to allow the attacker access to a remote shell on the target machine. In order to use this exploit, an attacker must have an existing \"server\" allocated and controlled by the Wings Daemon. This vulnerability has been resolved in version `v1.11.3` of the Wings Daemon, and has been back-ported to the 1.7 release series in `v1.7.3`. Anyone running `v1.11.x` should upgrade to `v1.11.3` and anyone running `v1.7.x` should upgrade to `v1.7.3`. There are no known workarounds for this vulnerability. ### Workarounds None at this time."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:C/C:H/I:L/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "LOW", "availabilityImpact": "HIGH", "baseScore": 8.4, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 6.0}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-59"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:pterodactyl:wings:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.7.3", "matchCriteriaId": "956C5C15-B6A3-4A41-BE11-526133781E09"}, {"vulnerable": true, "criteria": "cpe:2.3:a:pterodactyl:wings:1.11.0:-:*:*:*:*:*:*", "matchCriteriaId": "4C6F3CF4-2AFF-4966-8DD4-D7FE674530C2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:pterodactyl:wings:1.11.1:*:*:*:*:*:*:*", "matchCriteriaId": "C72D6216-66D3-49D9-93BA-CCB5B4031569"}, {"vulnerable": true, "criteria": "cpe:2.3:a:pterodactyl:wings:1.11.2:*:*:*:*:*:*:*", "matchCriteriaId": "A7FBA78A-C90F-4800-9AD7-99F3C9CD3125"}]}]}], "references": [{"url": "https://github.com/pterodactyl/wings/commit/dac9685298c3c1c49b3109fa4241aa88272b9f14", "source": "security-advisories@github.com", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://github.com/pterodactyl/wings/security/advisories/GHSA-p8r3-83r8-jwj5", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/pterodactyl/wings/commit/dac9685298c3c1c49b3109fa4241aa88272b9f14"}}