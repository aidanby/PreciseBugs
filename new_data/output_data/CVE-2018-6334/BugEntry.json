{"buggy_code": ["/*\n   +----------------------------------------------------------------------+\n   | HipHop for PHP                                                       |\n   +----------------------------------------------------------------------+\n   | Copyright (c) 2010-present Facebook, Inc. (http://www.facebook.com)  |\n   | Copyright (c) 1997-2010 The PHP Group                                |\n   +----------------------------------------------------------------------+\n   | This source file is subject to version 3.01 of the PHP license,      |\n   | that is bundled with this package in the file LICENSE, and is        |\n   | available through the world-wide-web at the following url:           |\n   | http://www.php.net/license/3_01.txt                                  |\n   | If you did not receive a copy of the PHP license and are unable to   |\n   | obtain it through the world-wide-web, please send a note to          |\n   | license@php.net so we can mail you a copy immediately.               |\n   +----------------------------------------------------------------------+\n*/\n\n#include \"hphp/runtime/server/upload.h\"\n#include \"hphp/runtime/base/program-functions.h\"\n#include \"hphp/runtime/base/runtime-option.h\"\n#include \"hphp/runtime/base/request-local.h\"\n#include \"hphp/runtime/base/zend-printf.h\"\n#include \"hphp/runtime/base/php-globals.h\"\n#include \"hphp/runtime/ext/apc/ext_apc.h\"\n#include \"hphp/util/logger.h\"\n#include \"hphp/runtime/base/string-util.h\"\n#include \"hphp/util/text-util.h\"\n#include \"hphp/runtime/base/request-event-handler.h\"\n#include <folly/FileUtil.h>\n\nusing std::set;\n\nnamespace HPHP {\n///////////////////////////////////////////////////////////////////////////////\n\nstatic void destroy_uploaded_files();\n\nstruct Rfc1867Data final : RequestEventHandler {\n  std::set<std::string> rfc1867ProtectedVariables;\n  std::set<std::string> rfc1867UploadedFiles;\n  apc_rfc1867_data rfc1867ApcData;\n  int (*rfc1867Callback)(apc_rfc1867_data *rfc1867ApcData,\n                         unsigned int event, void *event_data, void **extra);\n  void requestInit() override {\n    if (RuntimeOption::EnableUploadProgress) {\n      rfc1867Callback = apc_rfc1867_progress;\n    } else {\n      rfc1867Callback = nullptr;\n    }\n  }\n  void requestShutdown() override {\n    if (!rfc1867UploadedFiles.empty()) destroy_uploaded_files();\n  }\n};\nIMPLEMENT_STATIC_REQUEST_LOCAL(Rfc1867Data, s_rfc1867_data);\n\n/*\n *  This product includes software developed by the Apache Group\n *  for use in the Apache HTTP server project (http://www.apache.org/).\n *\n */\n\nstatic void safe_php_register_variable(char *var, const Variant& val,\n                                       Array& track_vars_array,\n                                       bool override_protection);\n\n#define FAILURE -1\n\n/* The longest property name we use in an uploaded file array */\n#define MAX_SIZE_OF_INDEX sizeof(\"[tmp_name]\")\n\n/* The longest anonymous name */\n#define MAX_SIZE_ANONNAME 33\n\n/* Errors */\n#define UPLOAD_ERROR_OK   0  /* File upload successful */\n#define UPLOAD_ERROR_A    1  /* Uploaded file exceeded upload_max_filesize */\n#define UPLOAD_ERROR_B    2  /* Uploaded file exceeded MAX_FILE_SIZE */\n#define UPLOAD_ERROR_C    3  /* Partially uploaded */\n#define UPLOAD_ERROR_D    4  /* No file uploaded */\n#define UPLOAD_ERROR_E    6  /* Missing /tmp or similar directory */\n#define UPLOAD_ERROR_F    7  /* Failed to write file to disk */\n#define UPLOAD_ERROR_X    8  /* File upload stopped by extension */\n\nstatic void normalize_protected_variable(char *varname) {\n  char *s=varname, *index=nullptr, *indexend=nullptr, *p;\n\n  /* overjump leading space */\n  while (*s == ' ') {\n    s++;\n  }\n\n  /* and remove it */\n  if (s != varname) {\n    memmove(varname, s, strlen(s)+1);\n  }\n\n  for (p=varname; *p && *p != '['; p++) {\n    switch(*p) {\n      case ' ':\n      case '.':\n        *p='_';\n        break;\n    }\n  }\n\n  /* find index */\n  index = strchr(varname, '[');\n  if (index) {\n    index++;\n    s=index;\n  } else {\n    return;\n  }\n\n  /* done? */\n  while (index) {\n\n    while (*index == ' ' || *index == '\\r' ||\n           *index == '\\n' || *index=='\\t') {\n      index++;\n    }\n    indexend = strchr(index, ']');\n    indexend = indexend ? indexend + 1 : index + strlen(index);\n\n    if (s != index) {\n      memmove(s, index, strlen(index)+1);\n      s += indexend-index;\n    } else {\n      s = indexend;\n    }\n\n    if (*s == '[') {\n      s++;\n      index = s;\n    } else {\n      index = nullptr;\n    }\n  }\n  *s++='\\0';\n}\n\n\nstatic void add_protected_variable(char *varname) {\n  normalize_protected_variable(varname);\n  s_rfc1867_data->rfc1867ProtectedVariables.insert(varname);\n}\n\n\nstatic bool is_protected_variable(char *varname) {\n  normalize_protected_variable(varname);\n  auto iter = s_rfc1867_data->rfc1867ProtectedVariables.find(varname);\n  return iter != s_rfc1867_data->rfc1867ProtectedVariables.end();\n}\n\n\nstatic void safe_php_register_variable(char *var, const Variant& val,\n                                       Array& track_vars_array,\n                                       bool override_protection) {\n  if (override_protection || !is_protected_variable(var)) {\n    register_variable(track_vars_array, var, val);\n  }\n}\n\nbool is_uploaded_file(const std::string filename) {\n  std::set<std::string> &rfc1867UploadedFiles =\n    s_rfc1867_data->rfc1867UploadedFiles;\n  return rfc1867UploadedFiles.find(filename) != rfc1867UploadedFiles.end();\n}\n\nconst std::set<std::string> &get_uploaded_files() {\n  return s_rfc1867_data->rfc1867UploadedFiles;\n}\n\nstatic void destroy_uploaded_files() {\n  std::set<std::string> &rfc1867UploadedFiles =\n    s_rfc1867_data->rfc1867UploadedFiles;\n  for (auto iter = rfc1867UploadedFiles.begin();\n       iter != rfc1867UploadedFiles.end(); iter++) {\n    unlink(iter->c_str());\n  }\n  rfc1867UploadedFiles.clear();\n}\n\n/*\n *  Following code is based on apache_multipart_buffer.c from\n *  libapreq-0.33 package.\n *\n */\n\nconstexpr size_t FILLUNIT = 1024 * 5;\n\nnamespace {\nstruct multipart_buffer {\n  Transport *transport;\n\n  /* read buffer */\n  char *buffer;\n  char *buf_begin;\n  size_t bufsize;\n  int64_t bytes_in_buffer; // signed to catch underflow errors\n\n  /* boundary info */\n  char *boundary;\n  char *boundary_next;\n  int  boundary_next_len;\n\n  /* post data */\n  const char *post_data;\n  uint64_t post_size;\n  uint64_t throw_size; // sum of all previously read chunks\n  char *cursor;\n  uint64_t read_post_bytes;\n};\n}\n\nusing header_list = std::list<std::pair<std::string, std::string>>;\n\nstatic uint32_t read_post(multipart_buffer *self, char *buf,\n                          uint32_t bytes_to_read) {\n  always_assert(bytes_to_read > 0);\n  always_assert(self->post_data);\n  always_assert(self->cursor >= self->post_data);\n  int64_t bytes_remaining = (self->post_size - self->throw_size) -\n                            (self->cursor - self->post_data);\n  always_assert(bytes_remaining >= 0);\n  if (bytes_to_read <= bytes_remaining) {\n    memcpy(buf, self->cursor, bytes_to_read);\n    self->cursor += bytes_to_read;\n    return bytes_to_read;\n  }\n\n  uint32_t bytes_read = bytes_remaining;\n  memcpy(buf, self->cursor, bytes_remaining);\n  bytes_to_read -= bytes_remaining;\n  self->cursor += bytes_remaining;\n  always_assert(self->cursor == (char *)self->post_data +\n                        (self->post_size - self->throw_size));\n  while (bytes_to_read > 0 && self->transport->hasMorePostData()) {\n    size_t extra_byte_read = 0;\n    const void *extra = self->transport->getMorePostData(extra_byte_read);\n    if (extra_byte_read == 0) break;\n    if (RuntimeOption::AlwaysPopulateRawPostData) {\n      // Possible overflow in buffer_append if post_size + extra_byte_read >=\n      // MAX INT\n      self->post_data = (const char *)buffer_append(\n        self->post_data, self->post_size, extra, extra_byte_read);\n      self->cursor = (char*)self->post_data + self->post_size;\n    } else {\n      self->post_data = (const char *)extra;\n      self->throw_size = self->post_size;\n      self->cursor = (char*)self->post_data;\n    }\n    self->post_size += extra_byte_read;\n    if (bytes_to_read <= extra_byte_read) {\n      memcpy(buf + bytes_read, self->cursor, bytes_to_read);\n      self->cursor += bytes_to_read;\n      return bytes_read + bytes_to_read;\n    }\n    memcpy(buf + bytes_read, self->cursor, extra_byte_read);\n    bytes_to_read -= extra_byte_read;\n    bytes_read += extra_byte_read;\n    self->cursor += extra_byte_read;\n  }\n  return bytes_read;\n}\n\n\n/*\n  fill up the buffer with client data.\n  returns number of bytes added to buffer.\n*/\nstatic uint32_t fill_buffer(multipart_buffer *self) {\n  uint32_t bytes_to_read, total_read = 0, actual_read = 0;\n\n  /* shift the existing data if necessary */\n  if (self->bytes_in_buffer > 0 && self->buf_begin != self->buffer) {\n    memmove(self->buffer, self->buf_begin, self->bytes_in_buffer);\n  }\n\n  self->buf_begin = self->buffer;\n\n  /* calculate the free space in the buffer */\n  bytes_to_read = self->bufsize - self->bytes_in_buffer;\n  always_assert(self->bufsize > 0);\n  always_assert(self->bytes_in_buffer >= 0);\n  /* read the required number of bytes */\n  while (bytes_to_read > 0) {\n\n    char *buf = self->buffer + self->bytes_in_buffer;\n\n    actual_read = read_post(self, buf, bytes_to_read);\n\n    /* update the buffer length */\n    if (actual_read > 0) {\n      always_assert(bytes_to_read >= actual_read);\n      self->bytes_in_buffer += actual_read;\n      self->read_post_bytes += actual_read;\n      total_read += actual_read;\n      bytes_to_read -= actual_read;\n    } else {\n      break;\n    }\n  }\n\n  return total_read;\n}\n\n\n/* eof if we are out of bytes, or if we hit the final boundary */\nstatic int multipart_buffer_eof(multipart_buffer *self) {\n  if ( (self->bytes_in_buffer == 0 && fill_buffer(self) < 1) ) {\n    return 1;\n  } else {\n    return 0;\n  }\n}\n\n\n/* create new multipart_buffer structure */\nstatic multipart_buffer *multipart_buffer_new(Transport *transport,\n                                              const char *data, size_t size,\n                                              std::string boundary) {\n  multipart_buffer *self =\n    (multipart_buffer *)calloc(1, sizeof(multipart_buffer));\n\n  self->transport = transport;\n  auto minsize = boundary.length() + 6;\n  if (minsize < FILLUNIT) minsize = FILLUNIT;\n\n  self->buffer = (char *) calloc(1, minsize + 1);\n  self->bufsize = minsize;\n\n  vspprintf(&self->boundary, 0, \"--%s\", boundary.c_str());\n\n  self->boundary_next_len =\n    vspprintf(&self->boundary_next, 0, \"\\n--%s\", boundary.c_str());\n\n  self->buf_begin = self->buffer;\n  self->bytes_in_buffer = 0;\n\n  self->post_data = data;\n  self->cursor = (char*)self->post_data;\n  self->post_size = size;\n  self->throw_size = 0;\n  return self;\n}\n\n\n/*\n  gets the next CRLF terminated line from the input buffer.\n  if it doesn't find a CRLF, and the buffer isn't completely full, returns\n  NULL; otherwise, returns the beginning of the null-terminated line,\n  minus the CRLF.\n\n  note that we really just look for LF terminated lines. this works\n  around a bug in internet explorer for the macintosh which sends mime\n  boundaries that are only LF terminated when you use an image submit\n  button in a multipart/form-data form.\n */\nstatic char *next_line(multipart_buffer *self) {\n  /* look for LF in the data */\n  char* line = self->buf_begin;\n  char* ptr = (char*)memchr(self->buf_begin, '\\n', self->bytes_in_buffer);\n\n  if (ptr) {  /* LF found */\n\n    /* terminate the string, remove CRLF */\n    if ((ptr - line) > 0 && *(ptr-1) == '\\r') {\n      *(ptr-1) = 0;\n    } else {\n      *ptr = 0;\n    }\n\n    /* bump the pointer */\n    self->buf_begin = ptr + 1;\n    self->bytes_in_buffer -= (self->buf_begin - line);\n\n  } else {  /* no LF found */\n\n    /* buffer isn't completely full, fail */\n    if (self->bytes_in_buffer < self->bufsize) {\n      return nullptr;\n    }\n    /* return entire buffer as a partial line */\n    line[self->bufsize] = 0;\n    self->buf_begin = ptr;\n    self->bytes_in_buffer = 0;\n  }\n\n  return line;\n}\n\n\n/* returns the next CRLF terminated line from the client */\nstatic char *get_line(multipart_buffer *self) {\n  char* ptr = next_line(self);\n\n  if (!ptr) {\n    fill_buffer(self);\n    ptr = next_line(self);\n  }\n\n  return ptr;\n}\n\n\n/* finds a boundary */\nstatic int find_boundary(multipart_buffer *self, char *boundary) {\n  char *line;\n\n  /* loop thru lines */\n  while( (line = get_line(self)) )\n  {\n    /* finished if we found the boundary */\n    if (!strcmp(line, boundary)) {\n      return 1;\n    }\n  }\n\n  /* didn't find the boundary */\n  return 0;\n}\n\n\n/* parse headers */\nstatic int multipart_buffer_headers(multipart_buffer *self,\n                                    header_list &header) {\n  char *line;\n  std::string key;\n  std::string buf_value;\n  std::pair<std::string, std::string> entry;\n\n  /* didn't find boundary, abort */\n  if (!find_boundary(self, self->boundary)) {\n    return 0;\n  }\n\n  /* get lines of text, or CRLF_CRLF */\n\n  while( (line = get_line(self)) && strlen(line) > 0 )\n  {\n    /* add header to table */\n    char *value = nullptr;\n\n    /* space in the beginning means same header */\n    if (!isspace(line[0])) {\n      value = strchr(line, ':');\n    }\n\n    if (value) {\n      if (!buf_value.empty() && !key.empty() ) {\n        entry = std::make_pair(key, buf_value);\n        header.push_back(entry);\n        buf_value.erase();\n        key.erase();\n      }\n      *value = '\\0';\n      do { value++; } while(isspace(*value));\n      key.assign(line);\n      buf_value.append(value);\n    } else if (!buf_value.empty() ) {\n      /* If no ':' on the line, add to previous line */\n      buf_value.append(line);\n    } else {\n      continue;\n    }\n  }\n\n  if (!buf_value.empty() && !key.empty()) {\n    entry = std::make_pair(key, buf_value);\n    header.push_back(entry);\n  }\n\n  return 1;\n}\n\n\nstatic char *php_mime_get_hdr_value(header_list &header, char *key) {\n  if (key == nullptr) return nullptr;\n  for (header_list::iterator iter = header.begin();\n       iter != header.end(); iter++) {\n    if (!strcasecmp(iter->first.c_str(), key)) {\n      return (char *)iter->second.c_str();\n    }\n  }\n  return nullptr;\n}\n\n\nstatic char *php_ap_getword(char **line, char stop) {\n  char *pos = *line, quote;\n  char *res;\n\n  while (*pos && *pos != stop) {\n\n    if ((quote = *pos) == '\"' || quote == '\\'') {\n      ++pos;\n      while (*pos && *pos != quote) {\n        if (*pos == '\\\\' && pos[1] && pos[1] == quote) {\n          pos += 2;\n        } else {\n          ++pos;\n        }\n      }\n      if (*pos) {\n        ++pos;\n      }\n    } else ++pos;\n\n  }\n  if (*pos == '\\0') {\n    res = strdup(*line);\n    *line += strlen(*line);\n    return res;\n  }\n\n  res = (char*)malloc(pos - *line + 1);\n  memcpy(res, *line, pos - *line);\n  res[pos - *line] = 0;\n  while (*pos == stop) {\n    ++pos;\n  }\n\n  *line = pos;\n  return res;\n}\n\n\nstatic char *substring_conf(char *start, int len, char quote) {\n  char *result = (char *)malloc(len + 2);\n  char *resp = result;\n  int i;\n\n  for (i = 0; i < len; ++i) {\n    if (start[i] == '\\\\' &&\n        (start[i + 1] == '\\\\' || (quote && start[i + 1] == quote))) {\n      *resp++ = start[++i];\n    } else {\n      *resp++ = start[i];\n    }\n  }\n\n  *resp++ = '\\0';\n  return result;\n}\n\n\nstatic char *php_ap_getword_conf(char **line) {\n  char *str = *line, *strend, *res, quote;\n\n  while (*str && isspace(*str)) {\n    ++str;\n  }\n\n  if (!*str) {\n    *line = str;\n    return strdup(\"\");\n  }\n\n  if ((quote = *str) == '\"' || quote == '\\'') {\n    strend = str + 1;\nlook_for_quote:\n    while (*strend && *strend != quote) {\n      if (*strend == '\\\\' && strend[1] && strend[1] == quote) {\n        strend += 2;\n      } else {\n        ++strend;\n      }\n    }\n    if (*strend && *strend == quote) {\n      char p = *(strend + 1);\n      if (p != '\\r' && p != '\\n' && p != '\\0') {\n        strend++;\n        goto look_for_quote;\n      }\n    }\n\n    res = substring_conf(str + 1, strend - str - 1, quote);\n\n    if (*strend == quote) {\n      ++strend;\n    }\n\n  } else {\n\n    strend = str;\n    while (*strend && !isspace(*strend)) {\n      ++strend;\n    }\n    res = substring_conf(str, strend - str, 0);\n  }\n\n  while (*strend && isspace(*strend)) {\n    ++strend;\n  }\n\n  *line = strend;\n  return res;\n}\n\n\n/*\n  search for a string in a fixed-length byte string.\n  if partial is true, partial matches are allowed at the end of the buffer.\n  returns NULL if not found, or a pointer to the start of the first match.\n*/\nstatic char *php_ap_memstr(char *haystack, int haystacklen, char *needle,\n                           int needlen, int partial) {\n  int len = haystacklen;\n  char *ptr = haystack;\n\n  /* iterate through first character matches */\n  while( (ptr = (char *)memchr(ptr, needle[0], len)) ) {\n\n    /* calculate length after match */\n    len = haystacklen - (ptr - (char *)haystack);\n\n    /* done if matches up to capacity of buffer */\n    if (memcmp(needle, ptr, needlen < len ? needlen : len) == 0 &&\n        (partial || len >= needlen)) {\n      break;\n    }\n\n    /* next character */\n    ptr++; len--;\n  }\n\n  return ptr;\n}\n\n\n/* read until a boundary condition */\nstatic int multipart_buffer_read(multipart_buffer *self, char *buf,\n                                 int bytes, int *end) {\n  int len, max;\n  char *bound;\n\n  /* fill buffer if needed */\n  if (bytes > self->bytes_in_buffer) {\n    fill_buffer(self);\n  }\n\n  /* look for a potential boundary match, only read data up to that point */\n  if ((bound =\n       php_ap_memstr(self->buf_begin, self->bytes_in_buffer,\n                     self->boundary_next, self->boundary_next_len, 1))) {\n    max = bound - self->buf_begin;\n    if (end &&\n        php_ap_memstr(self->buf_begin, self->bytes_in_buffer,\n                      self->boundary_next, self->boundary_next_len, 0)) {\n      *end = 1;\n    }\n  } else {\n    max = self->bytes_in_buffer;\n  }\n\n  /* maximum number of bytes we are reading */\n  len = max < bytes-1 ? max : bytes-1;\n\n  /* if we read any data... */\n  if (len > 0) {\n\n    /* copy the data */\n    memcpy(buf, self->buf_begin, len);\n    buf[len] = 0;\n\n    if (bound && len > 0 && buf[len-1] == '\\r') {\n      buf[--len] = 0;\n    }\n\n    /* update the buffer */\n    self->bytes_in_buffer -= len;\n    self->buf_begin += len;\n  }\n\n  return len;\n}\n\n\n/*\n  XXX: this is horrible memory-usage-wise, but we only expect\n  to do this on small pieces of form data.\n*/\nstatic char *multipart_buffer_read_body(multipart_buffer *self,\n                                        unsigned int *len) {\n  char buf[FILLUNIT], *out=nullptr;\n  int total_bytes=0, read_bytes=0;\n\n  while((read_bytes = multipart_buffer_read(self, buf, sizeof(buf), nullptr))) {\n    out = (char *)realloc(out, total_bytes + read_bytes + 1);\n    memcpy(out + total_bytes, buf, read_bytes);\n    total_bytes += read_bytes;\n  }\n\n  if (out) out[total_bytes] = '\\0';\n  *len = total_bytes;\n\n  return out;\n}\n\n/*\n * The combined READER/HANDLER\n *\n */\n\nvoid rfc1867PostHandler(Transport* transport,\n                        Array& post,\n                        Array& files,\n                        size_t content_length,\n                        const void*& data, size_t& size,\n                        const std::string boundary) {\n  char *s=nullptr, *start_arr=nullptr;\n  std::string array_index, abuf;\n  char *lbuf=nullptr;\n  int total_bytes=0, cancel_upload=0, is_arr_upload=0, array_len=0;\n  int max_file_size=0, skip_upload=0, anonindex=0, is_anonymous;\n  std::set<std::string> &uploaded_files = s_rfc1867_data->rfc1867UploadedFiles;\n  multipart_buffer *mbuff;\n  int fd=-1;\n  void *event_extra_data = nullptr;\n  unsigned int llen = 0;\n  int upload_count = RuntimeOption::MaxFileUploads;\n\n  /* Initialize the buffer */\n  if (!(mbuff = multipart_buffer_new(transport,\n                                     (const char *)data, size, boundary))) {\n    Logger::Warning(\"Unable to initialize the input buffer\");\n    return;\n  }\n\n  /* Initialize $_FILES[] */\n  s_rfc1867_data->rfc1867ProtectedVariables.clear();\n\n  uploaded_files.clear();\n\n  int (*php_rfc1867_callback)(apc_rfc1867_data *rfc1867ApcData,\n                              unsigned int event, void *event_data,\n                              void **extra) = s_rfc1867_data->rfc1867Callback;\n\n  if (php_rfc1867_callback != nullptr) {\n    multipart_event_start event_start;\n\n    event_start.content_length = content_length;\n    if (php_rfc1867_callback(&s_rfc1867_data->rfc1867ApcData,\n                             MULTIPART_EVENT_START, &event_start,\n                             &event_extra_data) == FAILURE) {\n      goto fileupload_done;\n    }\n  }\n\n  while (!multipart_buffer_eof(mbuff)) {\n    std::string temp_filename;\n    char buff[FILLUNIT];\n    char *cd=nullptr,*param=nullptr,*filename=nullptr, *tmp=nullptr;\n    size_t blen=0, wlen=0;\n    off_t offset;\n\n    header_list header;\n    if (!multipart_buffer_headers(mbuff, header)) {\n      goto fileupload_done;\n    }\n\n    if ((cd = php_mime_get_hdr_value(header, \"Content-Disposition\"))) {\n      char *pair=nullptr;\n      int end=0;\n\n      while (isspace(*cd)) {\n        ++cd;\n      }\n\n      while (*cd && (pair = php_ap_getword(&cd, ';')))\n      {\n        char *key=nullptr, *word = pair;\n\n        while (isspace(*cd)) {\n          ++cd;\n        }\n\n        if (strchr(pair, '=')) {\n          key = php_ap_getword(&pair, '=');\n\n          if (!strcasecmp(key, \"name\")) {\n            if (param) {\n              free(param);\n            }\n            param = php_ap_getword_conf(&pair);\n          } else if (!strcasecmp(key, \"filename\")) {\n            if (filename) {\n              free(filename);\n            }\n            filename = php_ap_getword_conf(&pair);\n          }\n        }\n        if (key) free(key);\n        free(word);\n      }\n\n      /* Normal form variable, safe to read all data into memory */\n      if (!filename && param) {\n        unsigned int value_len;\n        char *value = multipart_buffer_read_body(mbuff, &value_len);\n        unsigned int new_val_len; /* Dummy variable */\n\n        if (!value) {\n          value = strdup(\"\");\n        }\n\n        new_val_len = value_len;\n        if (php_rfc1867_callback != nullptr) {\n          multipart_event_formdata event_formdata;\n          size_t newlength = new_val_len;\n\n          event_formdata.post_bytes_processed = mbuff->read_post_bytes;\n          event_formdata.name = param;\n          event_formdata.value = &value;\n          event_formdata.length = new_val_len;\n          event_formdata.newlength = &newlength;\n          if (php_rfc1867_callback(&s_rfc1867_data->rfc1867ApcData,\n                                   MULTIPART_EVENT_FORMDATA, &event_formdata,\n                                   &event_extra_data) == FAILURE) {\n            free(param);\n            free(value);\n            continue;\n          }\n          new_val_len = newlength;\n        }\n\n        String val(value, new_val_len, CopyString);\n        safe_php_register_variable(param, val, post, 0);\n\n        if (!strcasecmp(param, \"MAX_FILE_SIZE\")) {\n          max_file_size = atol(value);\n        }\n\n        free(param);\n        free(value);\n        continue;\n      }\n\n      /* If file_uploads=off, skip the file part */\n      if (!RuntimeOption::EnableFileUploads) {\n        skip_upload = 1;\n      } else if (upload_count <= 0) {\n        Logger::Warning(\n          \"Maximum number of allowable file uploads has been exceeded\"\n        );\n        skip_upload = 1;\n      }\n\n      /* Return with an error if the posted data is garbled */\n      if (!param && !filename) {\n        Logger::Warning(\"File Upload Mime headers garbled\");\n        goto fileupload_done;\n      }\n\n      if (!param) {\n        is_anonymous = 1;\n        param = (char*)malloc(MAX_SIZE_ANONNAME);\n        snprintf(param, MAX_SIZE_ANONNAME, \"%u\", anonindex++);\n      } else {\n        is_anonymous = 0;\n      }\n\n      /* New Rule: never repair potential malicious user input */\n      if (!skip_upload) {\n        tmp = param;\n        long c = 0;\n\n        while (*tmp) {\n          if (*tmp == '[') {\n            c++;\n          } else if (*tmp == ']') {\n            c--;\n            if (tmp[1] && tmp[1] != '[') {\n              skip_upload = 1;\n              break;\n            }\n          }\n          if (c < 0) {\n            skip_upload = 1;\n            break;\n          }\n          tmp++;\n        }\n      }\n\n      total_bytes = cancel_upload = 0;\n\n      if (!skip_upload) {\n        /* Handle file */\n        char path[PATH_MAX];\n\n        // open a temporary file\n        snprintf(path, sizeof(path), \"%s/XXXXXX\",\n                 RuntimeOption::UploadTmpDir.c_str());\n        fd = mkstemp(path);\n        upload_count--;\n        if (fd == -1) {\n          Logger::Warning(\"Unable to open temporary file\");\n          Logger::Warning(\"File upload error - unable to create a \"\n                          \"temporary file\");\n          cancel_upload = UPLOAD_ERROR_E;\n        }\n        temp_filename = path;\n      }\n\n      if (!skip_upload && php_rfc1867_callback != nullptr) {\n        multipart_event_file_start event_file_start;\n\n        event_file_start.post_bytes_processed = mbuff->read_post_bytes;\n        event_file_start.name = param;\n        event_file_start.filename = &filename;\n        if (php_rfc1867_callback(&s_rfc1867_data->rfc1867ApcData,\n                                 MULTIPART_EVENT_FILE_START,\n                                 &event_file_start,\n                                 &event_extra_data) == FAILURE) {\n          if (!temp_filename.empty()) {\n            if (cancel_upload != UPLOAD_ERROR_E) { /* file creation failed */\n              close(fd);\n              unlink(temp_filename.c_str());\n            }\n          }\n          temp_filename=\"\";\n          free(param);\n          free(filename);\n          continue;\n        }\n      }\n\n\n      if (skip_upload) {\n        free(param);\n        free(filename);\n        continue;\n      }\n\n      if (strlen(filename) == 0) {\n        Logger::Verbose(\"No file uploaded\");\n        cancel_upload = UPLOAD_ERROR_D;\n      }\n\n      offset = 0;\n      end = 0;\n      while (!cancel_upload &&\n             (blen = multipart_buffer_read(mbuff, buff, sizeof(buff), &end)))\n      {\n        if (php_rfc1867_callback != nullptr) {\n          multipart_event_file_data event_file_data;\n\n          event_file_data.post_bytes_processed = mbuff->read_post_bytes;\n          event_file_data.offset = offset;\n          event_file_data.data = buff;\n          event_file_data.length = blen;\n          event_file_data.newlength = &blen;\n          if (php_rfc1867_callback(&s_rfc1867_data->rfc1867ApcData,\n                                   MULTIPART_EVENT_FILE_DATA,\n                                   &event_file_data,\n                                   &event_extra_data) == FAILURE) {\n            cancel_upload = UPLOAD_ERROR_X;\n            continue;\n          }\n        }\n\n\n        if (VirtualHost::GetUploadMaxFileSize() > 0 &&\n            total_bytes > VirtualHost::GetUploadMaxFileSize()) {\n          Logger::Verbose(\"upload_max_filesize of %\" PRId64 \" bytes exceeded \"\n                          \"- file [%s=%s] not saved\",\n                          VirtualHost::GetUploadMaxFileSize(),\n                          param, filename);\n          cancel_upload = UPLOAD_ERROR_A;\n        } else if (max_file_size && (total_bytes > max_file_size)) {\n          Logger::Verbose(\"MAX_FILE_SIZE of %d bytes exceeded - \"\n                          \"file [%s=%s] not saved\",\n                          max_file_size, param, filename);\n          cancel_upload = UPLOAD_ERROR_B;\n        } else if (blen > 0) {\n\n          wlen = folly::writeFull(fd, buff, blen);\n          if (wlen < blen) {\n            Logger::Verbose(\"Only %zd bytes were written, expected to \"\n                            \"write %zd\", wlen, blen);\n            cancel_upload = UPLOAD_ERROR_F;\n          } else {\n            total_bytes += wlen;\n          }\n\n          offset += wlen;\n        }\n      }\n      if (fd!=-1) { /* may not be initialized if file could not be created */\n        close(fd);\n      }\n      if (!cancel_upload && !end) {\n        Logger::Verbose(\"Missing mime boundary at the end of the data for \"\n                        \"file %s\", strlen(filename) > 0 ? filename : \"\");\n        cancel_upload = UPLOAD_ERROR_C;\n      }\n      if (strlen(filename) > 0 && total_bytes == 0 && !cancel_upload) {\n        Logger::Verbose(\"Uploaded file size 0 - file [%s=%s] not saved\",\n                        param, filename);\n        cancel_upload = 5;\n      }\n\n      if (php_rfc1867_callback != nullptr) {\n        multipart_event_file_end event_file_end;\n\n        event_file_end.post_bytes_processed = mbuff->read_post_bytes;\n        event_file_end.temp_filename = temp_filename.c_str();\n        event_file_end.cancel_upload = cancel_upload;\n        if (php_rfc1867_callback(&s_rfc1867_data->rfc1867ApcData,\n                                 MULTIPART_EVENT_FILE_END,\n                                 &event_file_end,\n                                 &event_extra_data) == FAILURE) {\n          cancel_upload = UPLOAD_ERROR_X;\n        }\n      }\n\n      if (cancel_upload && cancel_upload != UPLOAD_ERROR_C) {\n        if (!temp_filename.empty()) {\n          if (cancel_upload != UPLOAD_ERROR_E) { /* file creation failed */\n            unlink(temp_filename.c_str());\n          }\n        }\n        temp_filename=\"\";\n      } else {\n        s_rfc1867_data->rfc1867UploadedFiles.insert(temp_filename);\n      }\n\n      /* is_arr_upload is true when name of file upload field\n       * ends in [.*]\n       * start_arr is set to point to 1st [\n       */\n      is_arr_upload = (start_arr = strchr(param,'[')) &&\n                      (param[strlen(param)-1] == ']');\n\n      if (is_arr_upload) {\n        array_len = strlen(start_arr);\n        array_index = std::string(start_arr+1, array_len-2);\n      }\n\n      /* Add $foo_name */\n      if (llen < strlen(param) + MAX_SIZE_OF_INDEX + 1) {\n        llen = strlen(param);\n        lbuf = (char *) realloc(lbuf, llen + MAX_SIZE_OF_INDEX + 1);\n        llen += MAX_SIZE_OF_INDEX + 1;\n      }\n\n      if (is_arr_upload) {\n        abuf = std::string(param, strlen(param)-array_len);\n        snprintf(lbuf, llen, \"%s_name[%s]\",\n                 abuf.c_str(), array_index.c_str());\n      } else {\n        snprintf(lbuf, llen, \"%s_name\", param);\n      }\n\n      /* The \\ check should technically be needed for win32 systems only\n       * where it is a valid path separator. However, IE in all it's wisdom\n       * always sends the full path of the file on the user's filesystem,\n       * which means that unless the user does basename() they get a bogus\n       * file name. Until IE's user base drops to nill or problem is fixed\n       * this code must remain enabled for all systems.\n       */\n      s = strrchr(filename, '\\\\');\n      if ((tmp = strrchr(filename, '/')) > s) {\n        s = tmp;\n      }\n\n      Array globals = php_globals_as_array();\n      if (!is_anonymous) {\n        if (s) {\n          String val(s+1, strlen(s+1), CopyString);\n          safe_php_register_variable(lbuf, val, globals, 0);\n        } else {\n          String val(filename, strlen(filename), CopyString);\n          safe_php_register_variable(lbuf, val, globals, 0);\n        }\n      }\n\n      /* Add $foo[name] */\n      if (is_arr_upload) {\n        snprintf(lbuf, llen, \"%s[name][%s]\",\n                 abuf.c_str(), array_index.c_str());\n      } else {\n        snprintf(lbuf, llen, \"%s[name]\", param);\n      }\n      if (s) {\n        String val(s+1, strlen(s+1), CopyString);\n        safe_php_register_variable(lbuf, val, files, 0);\n      } else {\n        String val(filename, strlen(filename), CopyString);\n        safe_php_register_variable(lbuf, val, files, 0);\n      }\n      free(filename);\n      s = nullptr;\n\n      /* Possible Content-Type: */\n      if ((cancel_upload && cancel_upload != UPLOAD_ERROR_C) ||\n          !(cd = php_mime_get_hdr_value(header, \"Content-Type\"))) {\n        cd = \"\";\n      } else {\n        /* fix for Opera 6.01 */\n        s = strchr(cd, ';');\n        if (s != nullptr) {\n          *s = '\\0';\n        }\n      }\n\n      /* Add $foo_type */\n      if (is_arr_upload) {\n        snprintf(lbuf, llen, \"%s_type[%s]\",\n                 abuf.c_str(), array_index.c_str());\n      } else {\n        snprintf(lbuf, llen, \"%s_type\", param);\n      }\n      if (!is_anonymous) {\n        String val(cd, strlen(cd), CopyString);\n        safe_php_register_variable(lbuf, val, globals, 0);\n      }\n\n      /* Add $foo[type] */\n      if (is_arr_upload) {\n        snprintf(lbuf, llen, \"%s[type][%s]\",\n                 abuf.c_str(), array_index.c_str());\n      } else {\n        snprintf(lbuf, llen, \"%s[type]\", param);\n      }\n      String val(cd, strlen(cd), CopyString);\n      safe_php_register_variable(lbuf, val, files, 0);\n\n      /* Restore Content-Type Header */\n      if (s != nullptr) {\n        *s = ';';\n      }\n      s = \"\";\n\n      /* Initialize variables */\n      add_protected_variable(param);\n\n      Variant tempFileName(temp_filename);\n\n      /* if param is of form xxx[.*] this will cut it to xxx */\n      if (!is_anonymous) {\n        safe_php_register_variable(param, tempFileName, globals, 1);\n      }\n\n      /* Add $foo[tmp_name] */\n      if (is_arr_upload) {\n        snprintf(lbuf, llen, \"%s[tmp_name][%s]\",\n                 abuf.c_str(), array_index.c_str());\n      } else {\n        snprintf(lbuf, llen, \"%s[tmp_name]\", param);\n      }\n      add_protected_variable(lbuf);\n      safe_php_register_variable(lbuf, tempFileName, files, 1);\n\n      Variant file_size, error_type;\n\n      error_type = cancel_upload;\n\n      /* Add $foo[error] */\n      if (cancel_upload) {\n        file_size = 0;\n      } else {\n        file_size = total_bytes;\n      }\n\n      if (is_arr_upload) {\n        snprintf(lbuf, llen, \"%s[error][%s]\",\n                 abuf.c_str(), array_index.c_str());\n      } else {\n        snprintf(lbuf, llen, \"%s[error]\", param);\n      }\n      safe_php_register_variable(lbuf, error_type, files, 0);\n\n      /* Add $foo_size */\n      if (is_arr_upload) {\n        snprintf(lbuf, llen, \"%s_size[%s]\",\n                 abuf.c_str(), array_index.c_str());\n      } else {\n        snprintf(lbuf, llen, \"%s_size\", param);\n      }\n      if (!is_anonymous) {\n        safe_php_register_variable(lbuf, file_size, globals, 0);\n      }\n\n      /* Add $foo[size] */\n      if (is_arr_upload) {\n        snprintf(lbuf, llen, \"%s[size][%s]\",\n                 abuf.c_str(), array_index.c_str());\n      } else {\n        snprintf(lbuf, llen, \"%s[size]\", param);\n      }\n      safe_php_register_variable(lbuf, file_size, files, 0);\n      free(param);\n    }\n  }\nfileupload_done:\n  data = mbuff->post_data;\n  size = mbuff->post_size;\n  if (php_rfc1867_callback != nullptr) {\n    multipart_event_end event_end;\n\n    event_end.post_bytes_processed = mbuff->read_post_bytes;\n    php_rfc1867_callback(&s_rfc1867_data->rfc1867ApcData,\n                         MULTIPART_EVENT_END, &event_end, &event_extra_data);\n  }\n  if (lbuf) free(lbuf);\n  s_rfc1867_data->rfc1867ProtectedVariables.clear();\n  if (mbuff->boundary_next) free(mbuff->boundary_next);\n  if (mbuff->boundary) free(mbuff->boundary);\n  if (mbuff->buffer) free(mbuff->buffer);\n  if (mbuff) free(mbuff);\n}\n\n///////////////////////////////////////////////////////////////////////////////\n}\n"], "fixing_code": ["/*\n   +----------------------------------------------------------------------+\n   | HipHop for PHP                                                       |\n   +----------------------------------------------------------------------+\n   | Copyright (c) 2010-present Facebook, Inc. (http://www.facebook.com)  |\n   | Copyright (c) 1997-2010 The PHP Group                                |\n   +----------------------------------------------------------------------+\n   | This source file is subject to version 3.01 of the PHP license,      |\n   | that is bundled with this package in the file LICENSE, and is        |\n   | available through the world-wide-web at the following url:           |\n   | http://www.php.net/license/3_01.txt                                  |\n   | If you did not receive a copy of the PHP license and are unable to   |\n   | obtain it through the world-wide-web, please send a note to          |\n   | license@php.net so we can mail you a copy immediately.               |\n   +----------------------------------------------------------------------+\n*/\n\n#include \"hphp/runtime/server/upload.h\"\n\n#include \"hphp/runtime/base/program-functions.h\"\n#include \"hphp/runtime/base/request-event-handler.h\"\n#include \"hphp/runtime/base/request-local.h\"\n#include \"hphp/runtime/base/runtime-option.h\"\n#include \"hphp/runtime/base/string-util.h\"\n#include \"hphp/runtime/base/zend-printf.h\"\n#include \"hphp/runtime/ext/apc/ext_apc.h\"\n\n#include \"hphp/util/logger.h\"\n#include \"hphp/util/text-util.h\"\n\n#include <folly/FileUtil.h>\n\nusing std::set;\n\nnamespace HPHP {\n///////////////////////////////////////////////////////////////////////////////\n\nstatic void destroy_uploaded_files();\n\nstruct Rfc1867Data final : RequestEventHandler {\n  std::set<std::string> rfc1867ProtectedVariables;\n  std::set<std::string> rfc1867UploadedFiles;\n  apc_rfc1867_data rfc1867ApcData;\n  int (*rfc1867Callback)(apc_rfc1867_data *rfc1867ApcData,\n                         unsigned int event, void *event_data, void **extra);\n  void requestInit() override {\n    if (RuntimeOption::EnableUploadProgress) {\n      rfc1867Callback = apc_rfc1867_progress;\n    } else {\n      rfc1867Callback = nullptr;\n    }\n  }\n  void requestShutdown() override {\n    if (!rfc1867UploadedFiles.empty()) destroy_uploaded_files();\n  }\n};\nIMPLEMENT_STATIC_REQUEST_LOCAL(Rfc1867Data, s_rfc1867_data);\n\n/*\n *  This product includes software developed by the Apache Group\n *  for use in the Apache HTTP server project (http://www.apache.org/).\n *\n */\n\nstatic void safe_php_register_variable(char *var, const Variant& val,\n                                       Array& track_vars_array,\n                                       bool override_protection);\n\n#define FAILURE -1\n\n/* The longest property name we use in an uploaded file array */\n#define MAX_SIZE_OF_INDEX sizeof(\"[tmp_name]\")\n\n/* The longest anonymous name */\n#define MAX_SIZE_ANONNAME 33\n\n/* Errors */\n#define UPLOAD_ERROR_OK   0  /* File upload successful */\n#define UPLOAD_ERROR_A    1  /* Uploaded file exceeded upload_max_filesize */\n#define UPLOAD_ERROR_B    2  /* Uploaded file exceeded MAX_FILE_SIZE */\n#define UPLOAD_ERROR_C    3  /* Partially uploaded */\n#define UPLOAD_ERROR_D    4  /* No file uploaded */\n#define UPLOAD_ERROR_E    6  /* Missing /tmp or similar directory */\n#define UPLOAD_ERROR_F    7  /* Failed to write file to disk */\n#define UPLOAD_ERROR_X    8  /* File upload stopped by extension */\n\nstatic void normalize_protected_variable(char *varname) {\n  char *s=varname, *index=nullptr, *indexend=nullptr, *p;\n\n  /* overjump leading space */\n  while (*s == ' ') {\n    s++;\n  }\n\n  /* and remove it */\n  if (s != varname) {\n    memmove(varname, s, strlen(s)+1);\n  }\n\n  for (p=varname; *p && *p != '['; p++) {\n    switch(*p) {\n      case ' ':\n      case '.':\n        *p='_';\n        break;\n    }\n  }\n\n  /* find index */\n  index = strchr(varname, '[');\n  if (index) {\n    index++;\n    s=index;\n  } else {\n    return;\n  }\n\n  /* done? */\n  while (index) {\n\n    while (*index == ' ' || *index == '\\r' ||\n           *index == '\\n' || *index=='\\t') {\n      index++;\n    }\n    indexend = strchr(index, ']');\n    indexend = indexend ? indexend + 1 : index + strlen(index);\n\n    if (s != index) {\n      memmove(s, index, strlen(index)+1);\n      s += indexend-index;\n    } else {\n      s = indexend;\n    }\n\n    if (*s == '[') {\n      s++;\n      index = s;\n    } else {\n      index = nullptr;\n    }\n  }\n  *s++='\\0';\n}\n\n\nstatic void add_protected_variable(char *varname) {\n  normalize_protected_variable(varname);\n  s_rfc1867_data->rfc1867ProtectedVariables.insert(varname);\n}\n\n\nstatic bool is_protected_variable(char *varname) {\n  normalize_protected_variable(varname);\n  auto iter = s_rfc1867_data->rfc1867ProtectedVariables.find(varname);\n  return iter != s_rfc1867_data->rfc1867ProtectedVariables.end();\n}\n\n\nstatic void safe_php_register_variable(char *var, const Variant& val,\n                                       Array& track_vars_array,\n                                       bool override_protection) {\n  if (override_protection || !is_protected_variable(var)) {\n    register_variable(track_vars_array, var, val);\n  }\n}\n\nbool is_uploaded_file(const std::string filename) {\n  std::set<std::string> &rfc1867UploadedFiles =\n    s_rfc1867_data->rfc1867UploadedFiles;\n  return rfc1867UploadedFiles.find(filename) != rfc1867UploadedFiles.end();\n}\n\nconst std::set<std::string> &get_uploaded_files() {\n  return s_rfc1867_data->rfc1867UploadedFiles;\n}\n\nstatic void destroy_uploaded_files() {\n  std::set<std::string> &rfc1867UploadedFiles =\n    s_rfc1867_data->rfc1867UploadedFiles;\n  for (auto iter = rfc1867UploadedFiles.begin();\n       iter != rfc1867UploadedFiles.end(); iter++) {\n    unlink(iter->c_str());\n  }\n  rfc1867UploadedFiles.clear();\n}\n\n/*\n *  Following code is based on apache_multipart_buffer.c from\n *  libapreq-0.33 package.\n *\n */\n\nconstexpr size_t FILLUNIT = 1024 * 5;\n\nnamespace {\nstruct multipart_buffer {\n  Transport *transport;\n\n  /* read buffer */\n  char *buffer;\n  char *buf_begin;\n  size_t bufsize;\n  int64_t bytes_in_buffer; // signed to catch underflow errors\n\n  /* boundary info */\n  char *boundary;\n  char *boundary_next;\n  int  boundary_next_len;\n\n  /* post data */\n  const char *post_data;\n  uint64_t post_size;\n  uint64_t throw_size; // sum of all previously read chunks\n  char *cursor;\n  uint64_t read_post_bytes;\n};\n}\n\nusing header_list = std::list<std::pair<std::string, std::string>>;\n\nstatic uint32_t read_post(multipart_buffer *self, char *buf,\n                          uint32_t bytes_to_read) {\n  always_assert(bytes_to_read > 0);\n  always_assert(self->post_data);\n  always_assert(self->cursor >= self->post_data);\n  int64_t bytes_remaining = (self->post_size - self->throw_size) -\n                            (self->cursor - self->post_data);\n  always_assert(bytes_remaining >= 0);\n  if (bytes_to_read <= bytes_remaining) {\n    memcpy(buf, self->cursor, bytes_to_read);\n    self->cursor += bytes_to_read;\n    return bytes_to_read;\n  }\n\n  uint32_t bytes_read = bytes_remaining;\n  memcpy(buf, self->cursor, bytes_remaining);\n  bytes_to_read -= bytes_remaining;\n  self->cursor += bytes_remaining;\n  always_assert(self->cursor == (char *)self->post_data +\n                        (self->post_size - self->throw_size));\n  while (bytes_to_read > 0 && self->transport->hasMorePostData()) {\n    size_t extra_byte_read = 0;\n    const void *extra = self->transport->getMorePostData(extra_byte_read);\n    if (extra_byte_read == 0) break;\n    if (RuntimeOption::AlwaysPopulateRawPostData) {\n      // Possible overflow in buffer_append if post_size + extra_byte_read >=\n      // MAX INT\n      self->post_data = (const char *)buffer_append(\n        self->post_data, self->post_size, extra, extra_byte_read);\n      self->cursor = (char*)self->post_data + self->post_size;\n    } else {\n      self->post_data = (const char *)extra;\n      self->throw_size = self->post_size;\n      self->cursor = (char*)self->post_data;\n    }\n    self->post_size += extra_byte_read;\n    if (bytes_to_read <= extra_byte_read) {\n      memcpy(buf + bytes_read, self->cursor, bytes_to_read);\n      self->cursor += bytes_to_read;\n      return bytes_read + bytes_to_read;\n    }\n    memcpy(buf + bytes_read, self->cursor, extra_byte_read);\n    bytes_to_read -= extra_byte_read;\n    bytes_read += extra_byte_read;\n    self->cursor += extra_byte_read;\n  }\n  return bytes_read;\n}\n\n\n/*\n  fill up the buffer with client data.\n  returns number of bytes added to buffer.\n*/\nstatic uint32_t fill_buffer(multipart_buffer *self) {\n  uint32_t bytes_to_read, total_read = 0, actual_read = 0;\n\n  /* shift the existing data if necessary */\n  if (self->bytes_in_buffer > 0 && self->buf_begin != self->buffer) {\n    memmove(self->buffer, self->buf_begin, self->bytes_in_buffer);\n  }\n\n  self->buf_begin = self->buffer;\n\n  /* calculate the free space in the buffer */\n  bytes_to_read = self->bufsize - self->bytes_in_buffer;\n  always_assert(self->bufsize > 0);\n  always_assert(self->bytes_in_buffer >= 0);\n  /* read the required number of bytes */\n  while (bytes_to_read > 0) {\n\n    char *buf = self->buffer + self->bytes_in_buffer;\n\n    actual_read = read_post(self, buf, bytes_to_read);\n\n    /* update the buffer length */\n    if (actual_read > 0) {\n      always_assert(bytes_to_read >= actual_read);\n      self->bytes_in_buffer += actual_read;\n      self->read_post_bytes += actual_read;\n      total_read += actual_read;\n      bytes_to_read -= actual_read;\n    } else {\n      break;\n    }\n  }\n\n  return total_read;\n}\n\n\n/* eof if we are out of bytes, or if we hit the final boundary */\nstatic int multipart_buffer_eof(multipart_buffer *self) {\n  if ( (self->bytes_in_buffer == 0 && fill_buffer(self) < 1) ) {\n    return 1;\n  } else {\n    return 0;\n  }\n}\n\n\n/* create new multipart_buffer structure */\nstatic multipart_buffer *multipart_buffer_new(Transport *transport,\n                                              const char *data, size_t size,\n                                              std::string boundary) {\n  multipart_buffer *self =\n    (multipart_buffer *)calloc(1, sizeof(multipart_buffer));\n\n  self->transport = transport;\n  auto minsize = boundary.length() + 6;\n  if (minsize < FILLUNIT) minsize = FILLUNIT;\n\n  self->buffer = (char *) calloc(1, minsize + 1);\n  self->bufsize = minsize;\n\n  vspprintf(&self->boundary, 0, \"--%s\", boundary.c_str());\n\n  self->boundary_next_len =\n    vspprintf(&self->boundary_next, 0, \"\\n--%s\", boundary.c_str());\n\n  self->buf_begin = self->buffer;\n  self->bytes_in_buffer = 0;\n\n  self->post_data = data;\n  self->cursor = (char*)self->post_data;\n  self->post_size = size;\n  self->throw_size = 0;\n  return self;\n}\n\n\n/*\n  gets the next CRLF terminated line from the input buffer.\n  if it doesn't find a CRLF, and the buffer isn't completely full, returns\n  NULL; otherwise, returns the beginning of the null-terminated line,\n  minus the CRLF.\n\n  note that we really just look for LF terminated lines. this works\n  around a bug in internet explorer for the macintosh which sends mime\n  boundaries that are only LF terminated when you use an image submit\n  button in a multipart/form-data form.\n */\nstatic char *next_line(multipart_buffer *self) {\n  /* look for LF in the data */\n  char* line = self->buf_begin;\n  char* ptr = (char*)memchr(self->buf_begin, '\\n', self->bytes_in_buffer);\n\n  if (ptr) {  /* LF found */\n\n    /* terminate the string, remove CRLF */\n    if ((ptr - line) > 0 && *(ptr-1) == '\\r') {\n      *(ptr-1) = 0;\n    } else {\n      *ptr = 0;\n    }\n\n    /* bump the pointer */\n    self->buf_begin = ptr + 1;\n    self->bytes_in_buffer -= (self->buf_begin - line);\n\n  } else {  /* no LF found */\n\n    /* buffer isn't completely full, fail */\n    if (self->bytes_in_buffer < self->bufsize) {\n      return nullptr;\n    }\n    /* return entire buffer as a partial line */\n    line[self->bufsize] = 0;\n    self->buf_begin = ptr;\n    self->bytes_in_buffer = 0;\n  }\n\n  return line;\n}\n\n\n/* returns the next CRLF terminated line from the client */\nstatic char *get_line(multipart_buffer *self) {\n  char* ptr = next_line(self);\n\n  if (!ptr) {\n    fill_buffer(self);\n    ptr = next_line(self);\n  }\n\n  return ptr;\n}\n\n\n/* finds a boundary */\nstatic int find_boundary(multipart_buffer *self, char *boundary) {\n  char *line;\n\n  /* loop thru lines */\n  while( (line = get_line(self)) )\n  {\n    /* finished if we found the boundary */\n    if (!strcmp(line, boundary)) {\n      return 1;\n    }\n  }\n\n  /* didn't find the boundary */\n  return 0;\n}\n\n\n/* parse headers */\nstatic int multipart_buffer_headers(multipart_buffer *self,\n                                    header_list &header) {\n  char *line;\n  std::string key;\n  std::string buf_value;\n  std::pair<std::string, std::string> entry;\n\n  /* didn't find boundary, abort */\n  if (!find_boundary(self, self->boundary)) {\n    return 0;\n  }\n\n  /* get lines of text, or CRLF_CRLF */\n\n  while( (line = get_line(self)) && strlen(line) > 0 )\n  {\n    /* add header to table */\n    char *value = nullptr;\n\n    /* space in the beginning means same header */\n    if (!isspace(line[0])) {\n      value = strchr(line, ':');\n    }\n\n    if (value) {\n      if (!buf_value.empty() && !key.empty() ) {\n        entry = std::make_pair(key, buf_value);\n        header.push_back(entry);\n        buf_value.erase();\n        key.erase();\n      }\n      *value = '\\0';\n      do { value++; } while(isspace(*value));\n      key.assign(line);\n      buf_value.append(value);\n    } else if (!buf_value.empty() ) {\n      /* If no ':' on the line, add to previous line */\n      buf_value.append(line);\n    } else {\n      continue;\n    }\n  }\n\n  if (!buf_value.empty() && !key.empty()) {\n    entry = std::make_pair(key, buf_value);\n    header.push_back(entry);\n  }\n\n  return 1;\n}\n\n\nstatic char *php_mime_get_hdr_value(header_list &header, char *key) {\n  if (key == nullptr) return nullptr;\n  for (header_list::iterator iter = header.begin();\n       iter != header.end(); iter++) {\n    if (!strcasecmp(iter->first.c_str(), key)) {\n      return (char *)iter->second.c_str();\n    }\n  }\n  return nullptr;\n}\n\n\nstatic char *php_ap_getword(char **line, char stop) {\n  char *pos = *line, quote;\n  char *res;\n\n  while (*pos && *pos != stop) {\n\n    if ((quote = *pos) == '\"' || quote == '\\'') {\n      ++pos;\n      while (*pos && *pos != quote) {\n        if (*pos == '\\\\' && pos[1] && pos[1] == quote) {\n          pos += 2;\n        } else {\n          ++pos;\n        }\n      }\n      if (*pos) {\n        ++pos;\n      }\n    } else ++pos;\n\n  }\n  if (*pos == '\\0') {\n    res = strdup(*line);\n    *line += strlen(*line);\n    return res;\n  }\n\n  res = (char*)malloc(pos - *line + 1);\n  memcpy(res, *line, pos - *line);\n  res[pos - *line] = 0;\n  while (*pos == stop) {\n    ++pos;\n  }\n\n  *line = pos;\n  return res;\n}\n\n\nstatic char *substring_conf(char *start, int len, char quote) {\n  char *result = (char *)malloc(len + 2);\n  char *resp = result;\n  int i;\n\n  for (i = 0; i < len; ++i) {\n    if (start[i] == '\\\\' &&\n        (start[i + 1] == '\\\\' || (quote && start[i + 1] == quote))) {\n      *resp++ = start[++i];\n    } else {\n      *resp++ = start[i];\n    }\n  }\n\n  *resp++ = '\\0';\n  return result;\n}\n\n\nstatic char *php_ap_getword_conf(char **line) {\n  char *str = *line, *strend, *res, quote;\n\n  while (*str && isspace(*str)) {\n    ++str;\n  }\n\n  if (!*str) {\n    *line = str;\n    return strdup(\"\");\n  }\n\n  if ((quote = *str) == '\"' || quote == '\\'') {\n    strend = str + 1;\nlook_for_quote:\n    while (*strend && *strend != quote) {\n      if (*strend == '\\\\' && strend[1] && strend[1] == quote) {\n        strend += 2;\n      } else {\n        ++strend;\n      }\n    }\n    if (*strend && *strend == quote) {\n      char p = *(strend + 1);\n      if (p != '\\r' && p != '\\n' && p != '\\0') {\n        strend++;\n        goto look_for_quote;\n      }\n    }\n\n    res = substring_conf(str + 1, strend - str - 1, quote);\n\n    if (*strend == quote) {\n      ++strend;\n    }\n\n  } else {\n\n    strend = str;\n    while (*strend && !isspace(*strend)) {\n      ++strend;\n    }\n    res = substring_conf(str, strend - str, 0);\n  }\n\n  while (*strend && isspace(*strend)) {\n    ++strend;\n  }\n\n  *line = strend;\n  return res;\n}\n\n\n/*\n  search for a string in a fixed-length byte string.\n  if partial is true, partial matches are allowed at the end of the buffer.\n  returns NULL if not found, or a pointer to the start of the first match.\n*/\nstatic char *php_ap_memstr(char *haystack, int haystacklen, char *needle,\n                           int needlen, int partial) {\n  int len = haystacklen;\n  char *ptr = haystack;\n\n  /* iterate through first character matches */\n  while( (ptr = (char *)memchr(ptr, needle[0], len)) ) {\n\n    /* calculate length after match */\n    len = haystacklen - (ptr - (char *)haystack);\n\n    /* done if matches up to capacity of buffer */\n    if (memcmp(needle, ptr, needlen < len ? needlen : len) == 0 &&\n        (partial || len >= needlen)) {\n      break;\n    }\n\n    /* next character */\n    ptr++; len--;\n  }\n\n  return ptr;\n}\n\n\n/* read until a boundary condition */\nstatic int multipart_buffer_read(multipart_buffer *self, char *buf,\n                                 int bytes, int *end) {\n  int len, max;\n  char *bound;\n\n  /* fill buffer if needed */\n  if (bytes > self->bytes_in_buffer) {\n    fill_buffer(self);\n  }\n\n  /* look for a potential boundary match, only read data up to that point */\n  if ((bound =\n       php_ap_memstr(self->buf_begin, self->bytes_in_buffer,\n                     self->boundary_next, self->boundary_next_len, 1))) {\n    max = bound - self->buf_begin;\n    if (end &&\n        php_ap_memstr(self->buf_begin, self->bytes_in_buffer,\n                      self->boundary_next, self->boundary_next_len, 0)) {\n      *end = 1;\n    }\n  } else {\n    max = self->bytes_in_buffer;\n  }\n\n  /* maximum number of bytes we are reading */\n  len = max < bytes-1 ? max : bytes-1;\n\n  /* if we read any data... */\n  if (len > 0) {\n\n    /* copy the data */\n    memcpy(buf, self->buf_begin, len);\n    buf[len] = 0;\n\n    if (bound && len > 0 && buf[len-1] == '\\r') {\n      buf[--len] = 0;\n    }\n\n    /* update the buffer */\n    self->bytes_in_buffer -= len;\n    self->buf_begin += len;\n  }\n\n  return len;\n}\n\n\n/*\n  XXX: this is horrible memory-usage-wise, but we only expect\n  to do this on small pieces of form data.\n*/\nstatic char *multipart_buffer_read_body(multipart_buffer *self,\n                                        unsigned int *len) {\n  char buf[FILLUNIT], *out=nullptr;\n  int total_bytes=0, read_bytes=0;\n\n  while((read_bytes = multipart_buffer_read(self, buf, sizeof(buf), nullptr))) {\n    out = (char *)realloc(out, total_bytes + read_bytes + 1);\n    memcpy(out + total_bytes, buf, read_bytes);\n    total_bytes += read_bytes;\n  }\n\n  if (out) out[total_bytes] = '\\0';\n  *len = total_bytes;\n\n  return out;\n}\n\n/*\n * The combined READER/HANDLER\n *\n */\n\nvoid rfc1867PostHandler(Transport* transport,\n                        Array& post,\n                        Array& files,\n                        size_t content_length,\n                        const void*& data, size_t& size,\n                        const std::string boundary) {\n  char *s=nullptr, *start_arr=nullptr;\n  std::string array_index, abuf;\n  char *lbuf=nullptr;\n  int total_bytes=0, cancel_upload=0, is_arr_upload=0, array_len=0;\n  int max_file_size=0, skip_upload=0, anonindex=0;\n  std::set<std::string> &uploaded_files = s_rfc1867_data->rfc1867UploadedFiles;\n  multipart_buffer *mbuff;\n  int fd=-1;\n  void *event_extra_data = nullptr;\n  unsigned int llen = 0;\n  int upload_count = RuntimeOption::MaxFileUploads;\n\n  /* Initialize the buffer */\n  if (!(mbuff = multipart_buffer_new(transport,\n                                     (const char *)data, size, boundary))) {\n    Logger::Warning(\"Unable to initialize the input buffer\");\n    return;\n  }\n\n  /* Initialize $_FILES[] */\n  s_rfc1867_data->rfc1867ProtectedVariables.clear();\n\n  uploaded_files.clear();\n\n  int (*php_rfc1867_callback)(apc_rfc1867_data *rfc1867ApcData,\n                              unsigned int event, void *event_data,\n                              void **extra) = s_rfc1867_data->rfc1867Callback;\n\n  if (php_rfc1867_callback != nullptr) {\n    multipart_event_start event_start;\n\n    event_start.content_length = content_length;\n    if (php_rfc1867_callback(&s_rfc1867_data->rfc1867ApcData,\n                             MULTIPART_EVENT_START, &event_start,\n                             &event_extra_data) == FAILURE) {\n      goto fileupload_done;\n    }\n  }\n\n  while (!multipart_buffer_eof(mbuff)) {\n    std::string temp_filename;\n    char buff[FILLUNIT];\n    char *cd=nullptr,*param=nullptr,*filename=nullptr, *tmp=nullptr;\n    size_t blen=0, wlen=0;\n    off_t offset;\n\n    header_list header;\n    if (!multipart_buffer_headers(mbuff, header)) {\n      goto fileupload_done;\n    }\n\n    if ((cd = php_mime_get_hdr_value(header, \"Content-Disposition\"))) {\n      char *pair=nullptr;\n      int end=0;\n\n      while (isspace(*cd)) {\n        ++cd;\n      }\n\n      while (*cd && (pair = php_ap_getword(&cd, ';')))\n      {\n        char *key=nullptr, *word = pair;\n\n        while (isspace(*cd)) {\n          ++cd;\n        }\n\n        if (strchr(pair, '=')) {\n          key = php_ap_getword(&pair, '=');\n\n          if (!strcasecmp(key, \"name\")) {\n            if (param) {\n              free(param);\n            }\n            param = php_ap_getword_conf(&pair);\n          } else if (!strcasecmp(key, \"filename\")) {\n            if (filename) {\n              free(filename);\n            }\n            filename = php_ap_getword_conf(&pair);\n          }\n        }\n        if (key) free(key);\n        free(word);\n      }\n\n      /* Normal form variable, safe to read all data into memory */\n      if (!filename && param) {\n        unsigned int value_len;\n        char *value = multipart_buffer_read_body(mbuff, &value_len);\n        unsigned int new_val_len; /* Dummy variable */\n\n        if (!value) {\n          value = strdup(\"\");\n        }\n\n        new_val_len = value_len;\n        if (php_rfc1867_callback != nullptr) {\n          multipart_event_formdata event_formdata;\n          size_t newlength = new_val_len;\n\n          event_formdata.post_bytes_processed = mbuff->read_post_bytes;\n          event_formdata.name = param;\n          event_formdata.value = &value;\n          event_formdata.length = new_val_len;\n          event_formdata.newlength = &newlength;\n          if (php_rfc1867_callback(&s_rfc1867_data->rfc1867ApcData,\n                                   MULTIPART_EVENT_FORMDATA, &event_formdata,\n                                   &event_extra_data) == FAILURE) {\n            free(param);\n            free(value);\n            continue;\n          }\n          new_val_len = newlength;\n        }\n\n        String val(value, new_val_len, CopyString);\n        safe_php_register_variable(param, val, post, 0);\n\n        if (!strcasecmp(param, \"MAX_FILE_SIZE\")) {\n          max_file_size = atol(value);\n        }\n\n        free(param);\n        free(value);\n        continue;\n      }\n\n      /* If file_uploads=off, skip the file part */\n      if (!RuntimeOption::EnableFileUploads) {\n        skip_upload = 1;\n      } else if (upload_count <= 0) {\n        Logger::Warning(\n          \"Maximum number of allowable file uploads has been exceeded\"\n        );\n        skip_upload = 1;\n      }\n\n      /* Return with an error if the posted data is garbled */\n      if (!param && !filename) {\n        Logger::Warning(\"File Upload Mime headers garbled\");\n        goto fileupload_done;\n      }\n\n      if (!param) {\n        param = (char*)malloc(MAX_SIZE_ANONNAME);\n        snprintf(param, MAX_SIZE_ANONNAME, \"%u\", anonindex++);\n      }\n\n      /* New Rule: never repair potential malicious user input */\n      if (!skip_upload) {\n        tmp = param;\n        long c = 0;\n\n        while (*tmp) {\n          if (*tmp == '[') {\n            c++;\n          } else if (*tmp == ']') {\n            c--;\n            if (tmp[1] && tmp[1] != '[') {\n              skip_upload = 1;\n              break;\n            }\n          }\n          if (c < 0) {\n            skip_upload = 1;\n            break;\n          }\n          tmp++;\n        }\n      }\n\n      total_bytes = cancel_upload = 0;\n\n      if (!skip_upload) {\n        /* Handle file */\n        char path[PATH_MAX];\n\n        // open a temporary file\n        snprintf(path, sizeof(path), \"%s/XXXXXX\",\n                 RuntimeOption::UploadTmpDir.c_str());\n        fd = mkstemp(path);\n        upload_count--;\n        if (fd == -1) {\n          Logger::Warning(\"Unable to open temporary file\");\n          Logger::Warning(\"File upload error - unable to create a \"\n                          \"temporary file\");\n          cancel_upload = UPLOAD_ERROR_E;\n        }\n        temp_filename = path;\n      }\n\n      if (!skip_upload && php_rfc1867_callback != nullptr) {\n        multipart_event_file_start event_file_start;\n\n        event_file_start.post_bytes_processed = mbuff->read_post_bytes;\n        event_file_start.name = param;\n        event_file_start.filename = &filename;\n        if (php_rfc1867_callback(&s_rfc1867_data->rfc1867ApcData,\n                                 MULTIPART_EVENT_FILE_START,\n                                 &event_file_start,\n                                 &event_extra_data) == FAILURE) {\n          if (!temp_filename.empty()) {\n            if (cancel_upload != UPLOAD_ERROR_E) { /* file creation failed */\n              close(fd);\n              unlink(temp_filename.c_str());\n            }\n          }\n          temp_filename=\"\";\n          free(param);\n          free(filename);\n          continue;\n        }\n      }\n\n\n      if (skip_upload) {\n        free(param);\n        free(filename);\n        continue;\n      }\n\n      if (strlen(filename) == 0) {\n        Logger::Verbose(\"No file uploaded\");\n        cancel_upload = UPLOAD_ERROR_D;\n      }\n\n      offset = 0;\n      end = 0;\n      while (!cancel_upload &&\n             (blen = multipart_buffer_read(mbuff, buff, sizeof(buff), &end)))\n      {\n        if (php_rfc1867_callback != nullptr) {\n          multipart_event_file_data event_file_data;\n\n          event_file_data.post_bytes_processed = mbuff->read_post_bytes;\n          event_file_data.offset = offset;\n          event_file_data.data = buff;\n          event_file_data.length = blen;\n          event_file_data.newlength = &blen;\n          if (php_rfc1867_callback(&s_rfc1867_data->rfc1867ApcData,\n                                   MULTIPART_EVENT_FILE_DATA,\n                                   &event_file_data,\n                                   &event_extra_data) == FAILURE) {\n            cancel_upload = UPLOAD_ERROR_X;\n            continue;\n          }\n        }\n\n\n        if (VirtualHost::GetUploadMaxFileSize() > 0 &&\n            total_bytes > VirtualHost::GetUploadMaxFileSize()) {\n          Logger::Verbose(\"upload_max_filesize of %\" PRId64 \" bytes exceeded \"\n                          \"- file [%s=%s] not saved\",\n                          VirtualHost::GetUploadMaxFileSize(),\n                          param, filename);\n          cancel_upload = UPLOAD_ERROR_A;\n        } else if (max_file_size && (total_bytes > max_file_size)) {\n          Logger::Verbose(\"MAX_FILE_SIZE of %d bytes exceeded - \"\n                          \"file [%s=%s] not saved\",\n                          max_file_size, param, filename);\n          cancel_upload = UPLOAD_ERROR_B;\n        } else if (blen > 0) {\n\n          wlen = folly::writeFull(fd, buff, blen);\n          if (wlen < blen) {\n            Logger::Verbose(\"Only %zd bytes were written, expected to \"\n                            \"write %zd\", wlen, blen);\n            cancel_upload = UPLOAD_ERROR_F;\n          } else {\n            total_bytes += wlen;\n          }\n\n          offset += wlen;\n        }\n      }\n      if (fd!=-1) { /* may not be initialized if file could not be created */\n        close(fd);\n      }\n      if (!cancel_upload && !end) {\n        Logger::Verbose(\"Missing mime boundary at the end of the data for \"\n                        \"file %s\", strlen(filename) > 0 ? filename : \"\");\n        cancel_upload = UPLOAD_ERROR_C;\n      }\n      if (strlen(filename) > 0 && total_bytes == 0 && !cancel_upload) {\n        Logger::Verbose(\"Uploaded file size 0 - file [%s=%s] not saved\",\n                        param, filename);\n        cancel_upload = 5;\n      }\n\n      if (php_rfc1867_callback != nullptr) {\n        multipart_event_file_end event_file_end;\n\n        event_file_end.post_bytes_processed = mbuff->read_post_bytes;\n        event_file_end.temp_filename = temp_filename.c_str();\n        event_file_end.cancel_upload = cancel_upload;\n        if (php_rfc1867_callback(&s_rfc1867_data->rfc1867ApcData,\n                                 MULTIPART_EVENT_FILE_END,\n                                 &event_file_end,\n                                 &event_extra_data) == FAILURE) {\n          cancel_upload = UPLOAD_ERROR_X;\n        }\n      }\n\n      if (cancel_upload && cancel_upload != UPLOAD_ERROR_C) {\n        if (!temp_filename.empty()) {\n          if (cancel_upload != UPLOAD_ERROR_E) { /* file creation failed */\n            unlink(temp_filename.c_str());\n          }\n        }\n        temp_filename=\"\";\n      } else {\n        s_rfc1867_data->rfc1867UploadedFiles.insert(temp_filename);\n      }\n\n      /* is_arr_upload is true when name of file upload field\n       * ends in [.*]\n       * start_arr is set to point to 1st [\n       */\n      is_arr_upload = (start_arr = strchr(param,'[')) &&\n                      (param[strlen(param)-1] == ']');\n\n      if (is_arr_upload) {\n        array_len = strlen(start_arr);\n        array_index = std::string(start_arr+1, array_len-2);\n      }\n\n      /* Add $foo_name */\n      if (llen < strlen(param) + MAX_SIZE_OF_INDEX + 1) {\n        llen = strlen(param);\n        lbuf = (char *) realloc(lbuf, llen + MAX_SIZE_OF_INDEX + 1);\n        llen += MAX_SIZE_OF_INDEX + 1;\n      }\n\n      if (is_arr_upload) {\n        abuf = std::string(param, strlen(param)-array_len);\n        snprintf(lbuf, llen, \"%s_name[%s]\",\n                 abuf.c_str(), array_index.c_str());\n      } else {\n        snprintf(lbuf, llen, \"%s_name\", param);\n      }\n\n      /* The \\ check should technically be needed for win32 systems only\n       * where it is a valid path separator. However, IE in all it's wisdom\n       * always sends the full path of the file on the user's filesystem,\n       * which means that unless the user does basename() they get a bogus\n       * file name. Until IE's user base drops to nill or problem is fixed\n       * this code must remain enabled for all systems.\n       */\n      s = strrchr(filename, '\\\\');\n      if ((tmp = strrchr(filename, '/')) > s) {\n        s = tmp;\n      }\n\n      /* Add $foo[name] */\n      if (is_arr_upload) {\n        snprintf(lbuf, llen, \"%s[name][%s]\",\n                 abuf.c_str(), array_index.c_str());\n      } else {\n        snprintf(lbuf, llen, \"%s[name]\", param);\n      }\n      if (s) {\n        String val(s+1, strlen(s+1), CopyString);\n        safe_php_register_variable(lbuf, val, files, 0);\n      } else {\n        String val(filename, strlen(filename), CopyString);\n        safe_php_register_variable(lbuf, val, files, 0);\n      }\n      free(filename);\n      s = nullptr;\n\n      /* Possible Content-Type: */\n      if ((cancel_upload && cancel_upload != UPLOAD_ERROR_C) ||\n          !(cd = php_mime_get_hdr_value(header, \"Content-Type\"))) {\n        cd = \"\";\n      } else {\n        /* fix for Opera 6.01 */\n        s = strchr(cd, ';');\n        if (s != nullptr) {\n          *s = '\\0';\n        }\n      }\n\n      /* Add $foo[type] */\n      if (is_arr_upload) {\n        snprintf(lbuf, llen, \"%s[type][%s]\",\n                 abuf.c_str(), array_index.c_str());\n      } else {\n        snprintf(lbuf, llen, \"%s[type]\", param);\n      }\n      String val(cd, strlen(cd), CopyString);\n      safe_php_register_variable(lbuf, val, files, 0);\n\n      /* Restore Content-Type Header */\n      if (s != nullptr) {\n        *s = ';';\n      }\n      s = \"\";\n\n      /* Initialize variables */\n      add_protected_variable(param);\n\n      Variant tempFileName(temp_filename);\n\n      /* Add $foo[tmp_name] */\n      if (is_arr_upload) {\n        snprintf(lbuf, llen, \"%s[tmp_name][%s]\",\n                 abuf.c_str(), array_index.c_str());\n      } else {\n        snprintf(lbuf, llen, \"%s[tmp_name]\", param);\n      }\n      add_protected_variable(lbuf);\n      safe_php_register_variable(lbuf, tempFileName, files, 1);\n\n      Variant file_size, error_type;\n\n      error_type = cancel_upload;\n\n      /* Add $foo[error] */\n      if (cancel_upload) {\n        file_size = 0;\n      } else {\n        file_size = total_bytes;\n      }\n\n      if (is_arr_upload) {\n        snprintf(lbuf, llen, \"%s[error][%s]\",\n                 abuf.c_str(), array_index.c_str());\n      } else {\n        snprintf(lbuf, llen, \"%s[error]\", param);\n      }\n      safe_php_register_variable(lbuf, error_type, files, 0);\n\n      /* Add $foo[size] */\n      if (is_arr_upload) {\n        snprintf(lbuf, llen, \"%s[size][%s]\",\n                 abuf.c_str(), array_index.c_str());\n      } else {\n        snprintf(lbuf, llen, \"%s[size]\", param);\n      }\n      safe_php_register_variable(lbuf, file_size, files, 0);\n      free(param);\n    }\n  }\nfileupload_done:\n  data = mbuff->post_data;\n  size = mbuff->post_size;\n  if (php_rfc1867_callback != nullptr) {\n    multipart_event_end event_end;\n\n    event_end.post_bytes_processed = mbuff->read_post_bytes;\n    php_rfc1867_callback(&s_rfc1867_data->rfc1867ApcData,\n                         MULTIPART_EVENT_END, &event_end, &event_extra_data);\n  }\n  if (lbuf) free(lbuf);\n  s_rfc1867_data->rfc1867ProtectedVariables.clear();\n  if (mbuff->boundary_next) free(mbuff->boundary_next);\n  if (mbuff->boundary) free(mbuff->boundary);\n  if (mbuff->buffer) free(mbuff->buffer);\n  if (mbuff) free(mbuff);\n}\n\n///////////////////////////////////////////////////////////////////////////////\n}\n"], "filenames": ["hphp/runtime/server/upload.cpp"], "buggy_code_start_loc": [18], "buggy_code_end_loc": [1188], "fixing_code_start_loc": [19], "fixing_code_end_loc": [1147], "type": "CWE-20", "message": "Multipart-file uploads call variables to be improperly registered in the global scope. In cases where variables are not declared explicitly before being used this can lead to unexpected behavior. This affects all supported versions of HHVM prior to the patch (3.25.1, 3.24.5, and 3.21.9 and below).", "other": {"cve": {"id": "CVE-2018-6334", "sourceIdentifier": "cve-assign@fb.com", "published": "2018-12-31T19:29:00.323", "lastModified": "2019-10-09T23:41:46.313", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Multipart-file uploads call variables to be improperly registered in the global scope. In cases where variables are not declared explicitly before being used this can lead to unexpected behavior. This affects all supported versions of HHVM prior to the patch (3.25.1, 3.24.5, and 3.21.9 and below)."}, {"lang": "es", "value": "Subidas del tipo \"Multipart-file\" llaman a variables para que se registren indebidamente en el \u00e1mbito global. En los casos en los que las variables no se declaran expl\u00edcitamente antes de usarse, esto puede provocar un comportamiento no esperado. Esto afecta a todas las versiones soportadas de HVVM antes del parche (en versiones anteriores a las 3.25.1, 3.24.5 y 3.21.9)."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}]}, {"source": "cve-assign@fb.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-621"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:facebook:hhvm:*:*:*:*:*:*:*:*", "versionEndIncluding": "3.21.9", "matchCriteriaId": "310CA108-E16D-47C8-8769-DB691809E816"}, {"vulnerable": true, "criteria": "cpe:2.3:a:facebook:hhvm:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.21.10", "versionEndIncluding": "3.24.5", "matchCriteriaId": "CFBCFF4E-63FD-4C6E-906A-DEFAC841B089"}, {"vulnerable": true, "criteria": "cpe:2.3:a:facebook:hhvm:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.24.6", "versionEndIncluding": "3.25.1", "matchCriteriaId": "D6074181-C5F1-4A94-9B18-14D817D5FCEF"}]}]}], "references": [{"url": "https://github.com/facebook/hhvm/commit/6937de5544c3eead3466b75020d8382080ed0cff", "source": "cve-assign@fb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://hhvm.com/blog/2018/03/30/hhvm-3.25.2.html", "source": "cve-assign@fb.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/facebook/hhvm/commit/6937de5544c3eead3466b75020d8382080ed0cff"}}