{"buggy_code": ["package webhooks\n\nimport com.dtolabs.rundeck.core.authorization.AuthContext\nimport com.dtolabs.rundeck.core.authorization.AuthContextEvaluator\nimport com.dtolabs.rundeck.core.authorization.AuthContextProvider\nimport com.dtolabs.rundeck.core.authorization.AuthorizationUtil\nimport com.dtolabs.rundeck.core.authorization.UserAndRolesAuthContext\nimport com.dtolabs.rundeck.core.webhook.WebhookEventException\nimport com.dtolabs.rundeck.plugins.webhook.WebhookDataImpl\nimport com.fasterxml.jackson.databind.ObjectMapper\nimport grails.converters.JSON\nimport groovy.transform.PackageScope\nimport org.rundeck.core.auth.AuthConstants\n\nimport javax.servlet.http.HttpServletResponse\n\nclass WebhookController {\n    static allowedMethods = [post:'POST']\n\n    def webhookService\n    def frameworkService\n    AuthContextEvaluator rundeckAuthContextEvaluator\n    AuthContextProvider rundeckAuthContextProvider\n    def apiService\n\n    def admin() {}\n\n    def save() {\n        String project = request.JSON.project\n        if(!project){\n            return apiService.renderErrorFormat(response, [status: HttpServletResponse.SC_BAD_REQUEST,\n                                                           code: 'api.error.parameter.required', args: ['project']])\n\n        }\n        UserAndRolesAuthContext authContext = rundeckAuthContextProvider.getAuthContextForSubjectAndProject(session.subject, project)\n        if (!rundeckAuthContextEvaluator.authorizeProjectResourceAny(\n            authContext,\n            AuthConstants.RESOURCE_TYPE_WEBHOOK,\n            [AuthConstants.ACTION_CREATE, AuthConstants.ACTION_UPDATE, AuthConstants.ACTION_ADMIN, AuthConstants.ACTION_APP_ADMIN],\n            project\n        )) {\n            sendJsonError(\"You are not authorized to perform this action\")\n            return\n        }\n\n        def msg = webhookService.saveHook(authContext,request.JSON)\n        if(msg.err) response.status = 400\n\n        render msg as JSON\n    }\n\n    def remove() {\n        if(!params.project){\n            return apiService.renderErrorFormat(response, [status: HttpServletResponse.SC_BAD_REQUEST,\n                                                           code: 'api.error.parameter.required', args: ['project']])\n\n        }\n        Webhook webhook = webhookService.getWebhook(params.id.toLong())\n        if(!webhook) {\n            sendJsonError(\"Webhook not found\")\n            return\n        }\n\n        UserAndRolesAuthContext authContext = rundeckAuthContextProvider.getAuthContextForSubjectAndProject(session.subject, params.project)\n        if (!authorized(authContext, webhook.project, ACTION_DELETE)) {\n            sendJsonError(\"You are not authorized to perform this action\")\n            return\n        }\n        def output = webhookService.delete(webhook)\n        if(output.err) response.status = 400\n        render output as JSON\n\n    }\n\n    def get() {\n        if(!params.project){\n            return apiService.renderErrorFormat(response, [status: HttpServletResponse.SC_BAD_REQUEST,\n                                                           code: 'api.error.parameter.required', args: ['project']])\n\n        }\n        if(!params.id){\n            return apiService.renderErrorFormat(response, [status: HttpServletResponse.SC_BAD_REQUEST,\n                                                           code: 'api.error.parameter.required', args: ['id']])\n\n        }\n        UserAndRolesAuthContext authContext = rundeckAuthContextProvider.getAuthContextForSubjectAndProject(session.subject,params.project)\n        if (!authorized(authContext, params.project, AuthConstants.ACTION_READ)) {\n            sendJsonError(\"You do not have access to this resource\")\n            return\n        }\n        render webhookService.getWebhookWithAuth(params.id) as JSON\n    }\n\n    def list() {\n        if(!params.project){\n            return apiService.renderErrorFormat(response, [status: HttpServletResponse.SC_BAD_REQUEST,\n                                                           code: 'api.error.parameter.required', args: ['project']])\n\n        }\n        UserAndRolesAuthContext authContext = rundeckAuthContextProvider.getAuthContextForSubjectAndProject(session.subject, params.project)\n        if (!authorized(authContext, params.project, AuthConstants.ACTION_READ)) {\n            sendJsonError(\"You do not have access to this resource\")\n            return\n        }\n        render webhookService.listWebhooksByProject(params.project) as JSON\n    }\n\n    def editorData() {\n        if(!params.project){\n            return apiService.renderErrorFormat(response, [status: HttpServletResponse.SC_BAD_REQUEST,\n                                                           code: 'api.error.parameter.required', args: ['project']])\n\n        }\n        UserAndRolesAuthContext authContext = rundeckAuthContextProvider.getAuthContextForSubjectAndProject(session.subject, params.project)\n        if (!authorized(authContext, params.project, AuthConstants.ACTION_READ)) {\n            sendJsonError(\"You do not have access to this resource\")\n            return\n        }\n\n        def uidata = [:]\n        uidata.hooks = webhookService.listWebhooksByProject(params.project)\n        uidata.username = authContext.username\n        uidata.roles = authContext.roles.join(\",\")\n        render uidata as JSON\n    }\n\n    def post() {\n        Webhook hook = webhookService.getWebhookByToken(Webhook.cleanAuthToken(params.authtoken))\n\n        if(!hook) {\n            sendJsonError(\"Webhook not found\")\n            return\n        }\n        if(!hook.enabled) {\n            sendJsonError(\"Webhook not enabled\",503)\n            return\n        }\n\n        UserAndRolesAuthContext authContext = rundeckAuthContextProvider.getAuthContextForSubjectAndProject(session.subject, hook.project)\n        if (!authorized(authContext, hook.project, AuthConstants.ACTION_POST)) {\n            sendJsonError(\"You are not authorized to perform this action\")\n            return\n        }\n\n        WebhookDataImpl whkdata = new WebhookDataImpl()\n        whkdata.webhookUUID = hook.uuid\n        whkdata.webhook = hook.name\n        whkdata.timestamp = System.currentTimeMillis()\n        whkdata.sender = request.remoteAddr\n        whkdata.project = hook.project\n        whkdata.contentType = request.contentType\n        whkdata.data = request.inputStream\n\n        try {\n            def responder = webhookService.processWebhook(hook.eventPlugin, hook.pluginConfigurationJson, whkdata, authContext, request)\n            responder.respond(response)\n        } catch(WebhookEventException wee) {\n            sendJsonError(wee.message)\n        }\n    }\n\n    private def sendJsonError(String errMessage,int statusCode = 400) {\n        response.setStatus(statusCode)\n        def err = [err:errMessage]\n        render err as JSON\n    }\n\n    @PackageScope\n    boolean authorized(AuthContext authContext, String project, String action) {\n        List authorizedActions = [AuthConstants.ACTION_ADMIN, AuthConstants.ACTION_APP_ADMIN]\n        if(action != AuthConstants.ACTION_ADMIN) authorizedActions.add(action)\n        rundeckAuthContextEvaluator.authorizeProjectResourceAny(authContext,AuthConstants.RESOURCE_TYPE_WEBHOOK,authorizedActions,project)\n    }\n}\n", "package webhooks\n\nimport com.dtolabs.rundeck.core.authentication.tokens.AuthTokenType\nimport com.dtolabs.rundeck.core.authentication.tokens.AuthenticationToken\nimport com.dtolabs.rundeck.core.authorization.UserAndRolesAuthContext\nimport com.dtolabs.rundeck.core.config.Features\nimport com.dtolabs.rundeck.core.event.EventImpl\nimport com.dtolabs.rundeck.core.event.EventQueryImpl\nimport com.dtolabs.rundeck.core.event.EventStoreService\nimport com.dtolabs.rundeck.core.plugins.ValidatedPlugin\nimport com.dtolabs.rundeck.core.plugins.configuration.PluginAdapterUtility\nimport com.dtolabs.rundeck.core.plugins.configuration.PluginCustomConfigValidator\nimport com.dtolabs.rundeck.core.plugins.configuration.PropertyScope\nimport com.dtolabs.rundeck.core.plugins.configuration.Validator\nimport com.dtolabs.rundeck.core.storage.keys.KeyStorageTree\nimport com.dtolabs.rundeck.core.webhook.WebhookEventContextImpl\nimport com.dtolabs.rundeck.plugins.ServiceNameConstants\nimport com.dtolabs.rundeck.plugins.descriptions.PluginCustomConfig\nimport com.dtolabs.rundeck.plugins.webhook.DefaultWebhookResponder\nimport com.dtolabs.rundeck.plugins.webhook.WebhookDataImpl\nimport com.dtolabs.rundeck.plugins.webhook.WebhookEventContext\nimport com.dtolabs.rundeck.plugins.webhook.WebhookEventPlugin\nimport com.fasterxml.jackson.databind.ObjectMapper\nimport grails.gorm.transactions.Transactional\nimport groovy.transform.PackageScope\nimport org.rundeck.app.spi.Services\nimport org.rundeck.app.spi.SimpleServiceProvider\nimport org.slf4j.Logger\nimport org.slf4j.LoggerFactory\n\nimport javax.servlet.http.HttpServletRequest\n\n@Transactional\nclass WebhookService {\n    private static final Logger LOGGER = LoggerFactory.getLogger(\"org.rundeck.webhook.events\")\n    private static final ObjectMapper mapper = new ObjectMapper()\n    private static final String KEY_STORE_PREFIX = \"\\${KS:\"\n    private static final String END_MARKER = \"}\"\n\n    def rundeckPluginRegistry\n    def pluginService\n    def frameworkService\n    def rundeckAuthorizedServicesProvider\n    def apiService\n    def messageSource\n    def userService\n    def rundeckAuthTokenManagerService\n    def storageService\n    def gormEventStoreService\n    def featureService\n\n    def processWebhook(String pluginName, String pluginConfigJson, WebhookDataImpl data, UserAndRolesAuthContext authContext, HttpServletRequest request) {\n        LOGGER.info(\"processing '\" + data.webhook + \"' with plugin '\" + pluginName + \"' triggered by: '\" + authContext.username+ \"'\")\n        Map pluginConfig = pluginConfigJson ? mapper.readValue(pluginConfigJson,HashMap) : [:]\n        replaceSecureOpts(authContext,pluginConfig)\n        WebhookEventPlugin plugin = pluginService.configurePlugin(pluginName, WebhookEventPlugin.class, frameworkService.getFrameworkPropertyResolver(data.project,pluginConfig),\n                                                                  PropertyScope.Instance).instance\n\n        PluginAdapterUtility.setConfig(plugin, pluginConfig)\n\n        plugin.requestHeadersToCopy?.each { hdr -> data.headers[hdr] = request.getHeader(hdr)}\n\n        Services contextServices = rundeckAuthorizedServicesProvider.getServicesWith(authContext)\n\n        if (featureService.featurePresent(Features.EVENT_STORE)) {\n            def scopedStore = gormEventStoreService.scoped(\n                new Evt(projectName: data.project, subsystem: 'webhooks'),\n                new EvtQuery(projectName: data.project, subsystem: 'webhooks')\n            )\n            contextServices = contextServices.combine(\n                    new SimpleServiceProvider([(EventStoreService): scopedStore])\n            )\n        }\n        def keyStorageService = storageService.storageTreeWithContext(authContext)\n        contextServices = contextServices.combine(new SimpleServiceProvider([(KeyStorageTree): keyStorageService]))\n\n        WebhookEventContext context = new WebhookEventContextImpl(contextServices)\n\n        return plugin.onEvent(context,data) ?: new DefaultWebhookResponder()\n    }\n\n    @PackageScope\n    void replaceSecureOpts(UserAndRolesAuthContext authContext, Map configProps) {\n        if(configProps.isEmpty()) return\n        def keystore = storageService.storageTreeWithContext(authContext)\n\n        Stack<Object> items = []\n\n        configProps.each { idx, i -> items.push([i, configProps, idx]) }\n\n        while(true) {\n            if (items.empty())\n                break\n\n            def elem = items.pop()\n\n            def (item, parent, index) = elem\n\n            if (item instanceof Map) {\n                item.each { idx, i -> items.push([i, item, idx]) }\n                continue\n            } else if (item instanceof List) {\n                item.eachWithIndex { i, idx -> items.push([i, item, idx]) }\n                continue\n            }\n\n            if (item instanceof String) {\n                if(item && item.contains(KEY_STORE_PREFIX)) {\n                    String replaced = item\n                    int startIdx = -1\n                    while(replaced.indexOf(KEY_STORE_PREFIX,startIdx+1) != -1) {\n                        startIdx = replaced.indexOf(KEY_STORE_PREFIX)\n                        int endIdx = replaced.indexOf(END_MARKER,startIdx)\n                        if(endIdx == -1) {\n                            log.error(\"Invalid substitution string, terminating marker not found in value: ${replaced}\")\n                            break\n                        }\n                        String valueToReplace = replaced.substring(startIdx,endIdx+1)\n                        String keyPath = valueToReplace.substring(KEY_STORE_PREFIX.length(),valueToReplace.length()-1)\n                        if(keystore.hasPassword(keyPath)) {\n                            String replacementValue = new String(keystore.readPassword(keyPath))\n                            replaced = replaced.replace(valueToReplace,replacementValue)\n                        } else {\n                            log.warn(\"key was not found in key store: ${keyPath}\")\n                        }\n                    }\n                    parent[index] = replaced\n                }\n            }\n        }\n    }\n\n    def listWebhooksByProject(String project) {\n        Webhook.findAllByProject(project).collect {\n            getWebhookWithAuthAsMap(it)\n        }\n    }\n\n    def saveHook(UserAndRolesAuthContext authContext,def hookData) {\n        Webhook hook\n        if(hookData.id) {\n            hook = Webhook.get(hookData.id)\n            if (!hook) return [err: \"Webhook not found\"]\n            if(hookData.roles && !hookData.importData) {\n                try {\n                    rundeckAuthTokenManagerService.updateAuthRoles(authContext, hook.authToken,rundeckAuthTokenManagerService.parseAuthRoles(hookData.roles))\n                } catch (Exception e) {\n                    return [err: \"Failed to update Auth Token roles: \"+e.message]\n                }\n            }\n        } else {\n            int countByNameInProject = Webhook.countByNameAndProject(hookData.name,hookData.project)\n            if(countByNameInProject > 0) return [err: \"A Webhook by that name already exists in this project\"]\n            String checkUser = hookData.user ?: authContext.username\n            if (!hookData.importData && !userService.validateUserExists(checkUser)) return [err: \"Webhook user '${checkUser}' not found\"]\n            hook = new Webhook()\n            hook.uuid = UUID.randomUUID().toString()\n        }\n        hook.uuid = hookData.uuid ?: hook.uuid\n        hook.name = hookData.name ?: hook.name\n        hook.project = hookData.project ?: hook.project\n        if(hookData.enabled != null) hook.enabled = hookData.enabled\n        if(hookData.eventPlugin && !pluginService.listPlugins(WebhookEventPlugin).any { it.key == hookData.eventPlugin}){\n            hook.discard()\n            return [err:\"Plugin does not exist: \" + hookData.eventPlugin]\n        }\n        hook.eventPlugin = hookData.eventPlugin ?: hook.eventPlugin\n\n        Map pluginConfig = [:]\n        if(hookData.config) pluginConfig = hookData.config instanceof String ? mapper.readValue(hookData.config, HashMap) : hookData.config\n\n        def (ValidatedPlugin vPlugin, boolean isCustom) = validatePluginConfig(hook.eventPlugin,pluginConfig)\n        if(!vPlugin.valid) {\n            def errMsg = isCustom ?\n                    \"Validation errors\" :\n                    \"Invalid plugin configuration: \" + vPlugin.report.errors.collect { k, v -> \"$k : $v\" }.join(\"\\n\")\n            hook.discard()\n\n            return [err: errMsg, errors: vPlugin.report.errors]\n        }\n\n        hook.pluginConfigurationJson = mapper.writeValueAsString(pluginConfig)\n        Set<String> roles = hookData.roles ? rundeckAuthTokenManagerService.parseAuthRoles(hookData.roles) : authContext.roles\n        if((!hook.id || !hook.authToken) && !hookData.shouldImportToken){\n            //create token\n            String checkUser = hookData.user ?: authContext.username\n            try {\n                def at=apiService.generateUserToken(authContext, null, checkUser, roles, false, AuthTokenType.WEBHOOK)\n                hook.authToken = at.token\n            } catch (Exception e) {\n                hook.discard()\n                return [err: \"Failed to create associated Auth Token: \"+e.message]\n            }\n        }\n        if(hookData.shouldImportToken) {\n            if(!importIsAllowed(hook,hookData)){\n                throw new Exception(\"Cannot import webhook: auth token already in use\")\n            }\n            try {\n                rundeckAuthTokenManagerService.importWebhookToken(authContext, hookData.authToken, hookData.user, roles)\n            } catch (Exception e) {\n                hook.discard()\n                return [err: \"Failed importing Webhook Token: \"+e.message]\n            }\n            hook.authToken = hookData.authToken\n        }\n\n        if(hook.validate()) {\n            hook.save(failOnError:true, flush:true)\n            return [msg: \"Saved webhook\"]\n        } else {\n            if(!hook.id && hook.authToken){\n                //delete the created token\n                rundeckAuthTokenManagerService.deleteToken(hook.authToken)\n            }\n            return [err: hook.errors.allErrors.collect { messageSource.getMessage(it,null) }.join(\",\")]\n        }\n    }\n\n    boolean importIsAllowed(Webhook hook, Map hookData) {\n        if(hook.authToken == hookData.authToken) return true\n        if(!hook.authToken && Webhook.countByAuthToken(hookData.authToken) == 0 && !rundeckAuthTokenManagerService.getToken(hookData.authToken)) return true\n        return false\n    }\n\n\n    @PackageScope\n    Tuple2<ValidatedPlugin, Boolean> validatePluginConfig(String webhookPlugin, Map pluginConfig) {\n        ValidatedPlugin result = pluginService.validatePluginConfig(ServiceNameConstants.WebhookEvent, webhookPlugin, pluginConfig)\n        def isCustom = false\n        def plugin = pluginService.getPlugin(webhookPlugin,WebhookEventPlugin.class)\n        PluginCustomConfig customConfig = PluginAdapterUtility.getCustomConfigAnnotation(plugin)\n        if(customConfig && customConfig.validator()) {\n            PluginCustomConfigValidator validator = Validator.createCustomPropertyValidator(customConfig)\n            if(validator) {\n                result.report.errors.putAll(validator.validate(pluginConfig).errors)\n                result.valid = result.report.valid\n                isCustom = true\n            }\n        }\n        return new Tuple2(result, isCustom)\n    }\n\n    def deleteWebhooksForProject(String project) {\n        Webhook.findAllByProject(project).each { webhook ->\n            delete(webhook)\n        }\n    }\n\n    def delete(Webhook hook) {\n        String authToken = hook.authToken\n        String name = hook.name\n        try {\n            hook.delete()\n            rundeckAuthTokenManagerService.deleteToken(authToken)\n            return [msg: \"Deleted ${name} webhook\"]\n        } catch(Exception ex) {\n            log.error(\"delete webhook failed\",ex)\n            return [err: ex.message]\n        }\n    }\n\n    def importWebhook(UserAndRolesAuthContext authContext, Map hook, boolean regenAuthTokens) {\n\n        Webhook existing = Webhook.findByUuidAndProject(hook.uuid, hook.project)\n        if(existing) hook.id = existing.id\n        hook.importData = true\n\n        if(!regenAuthTokens && hook.authToken) {\n            hook.shouldImportToken = true\n        } else {\n            hook.authToken = null\n        }\n\n        try {\n            def msg = saveHook(authContext, hook)\n            if(msg.err) {\n                log.error(\"Failed to import webhook. Error: \" + msg.err)\n                return [err:\"Unable to import webhoook ${hook.name}. Error:\"+msg.err]\n            }\n            return [msg:\"Webhook ${hook.name} imported\"]\n        } catch(Exception ex) {\n            log.error(\"Failed to import webhook\", ex)\n            return [err:\"Unable to import webhoook ${hook.name}. Error:\"+ex.message]\n        }\n\n    }\n\n    def getWebhookWithAuth(String id) {\n        Webhook hook = Webhook.get(id.toLong())\n        getWebhookWithAuthAsMap(hook)\n    }\n\n    private Map getWebhookWithAuthAsMap(Webhook hook) {\n        AuthenticationToken authToken = rundeckAuthTokenManagerService.getToken(hook.authToken)\n        return [id:hook.id, uuid:hook.uuid, name:hook.name, project: hook.project, enabled: hook.enabled, user:authToken.ownerName, creator:authToken.creator, roles: authToken.authRolesSet().join(\",\"), authToken:hook.authToken, eventPlugin:hook.eventPlugin, config:mapper.readValue(hook.pluginConfigurationJson, HashMap)]\n    }\n\n    Webhook getWebhook(Long id) {\n        return Webhook.get(id)\n    }\n\n    Webhook getWebhookByUuid(String uuid) {\n        return Webhook.findByUuid(uuid)\n    }\n\n    Webhook getWebhookByToken(String token) {\n        return Webhook.findByAuthToken(token)\n    }\n\n    class Evt extends EventImpl {}\n\n    class EvtQuery extends EventQueryImpl {}\n}\n", "/*\n * Copyright 2019 Rundeck, Inc. (http://rundeck.com)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage webhooks\n\nimport com.dtolabs.rundeck.core.authorization.AuthContextEvaluator\nimport com.dtolabs.rundeck.core.authorization.AuthContextProvider\nimport com.dtolabs.rundeck.core.authorization.SubjectAuthContext\nimport com.dtolabs.rundeck.core.authorization.UserAndRolesAuthContext\nimport com.dtolabs.rundeck.plugins.webhook.DefaultJsonWebhookResponder\nimport com.dtolabs.rundeck.plugins.webhook.DefaultWebhookResponder\nimport com.dtolabs.rundeck.plugins.webhook.WebhookDataImpl\nimport com.dtolabs.rundeck.plugins.webhook.WebhookResponder\nimport grails.testing.web.controllers.ControllerUnitTest\nimport spock.lang.Specification\n\nimport javax.servlet.http.HttpServletRequest\nimport javax.servlet.http.HttpServletResponse\n\n\nclass WebhookControllerSpec extends Specification implements ControllerUnitTest<WebhookController> {\n\n    def \"post\"() {\n        given:\n        controller.rundeckAuthContextProvider = Mock(AuthContextProvider)\n        controller.rundeckAuthContextEvaluator = Mock(AuthContextEvaluator)\n        controller.webhookService = Mock(MockWebhookService)\n\n        when:\n        params.authtoken = \"1234\"\n        request.method = 'POST'\n        controller.post()\n\n        then:\n        1 * controller.webhookService.getWebhookByToken(_) >> { new Webhook(name:\"test\",authToken: \"1234\")}\n        1 * controller.rundeckAuthContextProvider.getAuthContextForSubjectAndProject(_, _) >> { new SubjectAuthContext(null, null) }\n        1 * controller.rundeckAuthContextEvaluator.authorizeProjectResourceAny(_,_,_,_) >> { return true }\n        1 * controller.webhookService.processWebhook(_,_,_,_,_) >> { webhookResponder }\n        response.text == expectedMsg\n\n        where:\n        authtoken   | expectedMsg | webhookResponder\n        \"1234\"      | 'ok' | new DefaultWebhookResponder()\n        \"1234#test\" | '{\"msg\":\"ok\"}' | new DefaultJsonWebhookResponder([msg:\"ok\"])\n    }\n\n    def \"post fail when not authorized\"() {\n        given:\n\n        controller.rundeckAuthContextProvider = Mock(AuthContextProvider){\n            getAuthContextForSubject(_) >> { new SubjectAuthContext(null,null) }\n        }\n        controller.rundeckAuthContextEvaluator = Mock(AuthContextEvaluator){\n            authorizeApplicationResourceAny(_,_,_) >> { return false }\n        }\n        controller.webhookService = Mock(MockWebhookService)\n\n        when:\n        params.authtoken = \"1234\"\n        request.method = 'POST'\n        controller.post()\n\n        then:\n        1 * controller.webhookService.getWebhookByToken(_) >> { new Webhook(name:\"test\",authToken: \"1234\")}\n        0 * controller.webhookService.processWebhook(_,_,_,_)\n        response.text == '{\"err\":\"You are not authorized to perform this action\"}'\n    }\n\n    def \"remove webhook should fail when project params is not present\"() {\n        given:\n        controller.webhookService = Mock(MockWebhookService) {\n            getWebhook(_) >> new Webhook()\n        }\n\n        controller.apiService = Mock(MockApiService)\n\n        when:\n        params.id = \"1234\"\n        controller.remove()\n\n        then:\n        1 * controller.apiService.renderErrorFormat(_,[status: HttpServletResponse.SC_BAD_REQUEST,\n                                                       code: 'api.error.parameter.required', args: ['project']])\n        0 * controller.webhookService.delete(_)\n    }\n\n    def \"503 if webhook is not enabled\"() {\n        given:\n        controller.webhookService = Mock(MockWebhookService)\n\n        when:\n        params.authtoken = \"1234\"\n        request.method = 'POST'\n        controller.post()\n\n        then:\n        1 * controller.webhookService.getWebhookByToken(_) >> { new Webhook(name:\"test\",authToken: \"1234\",enabled:false)}\n        0 * controller.webhookService.processWebhook(_,_,_,_)\n        response.text == '{\"err\":\"Webhook not enabled\"}'\n        response.status == 503\n    }\n\n    def \"POST method is the only valid method\"() {\n        given:\n        controller.rundeckAuthContextProvider = Mock(AuthContextProvider)\n        controller.rundeckAuthContextEvaluator = Mock(AuthContextEvaluator)\n        controller.webhookService = Mock(MockWebhookService)\n\n        when:\n        params.authtoken = \"1234\"\n        request.method = method\n        controller.post()\n\n        then:\n        invocations * controller.webhookService.getWebhookByToken(_) >> { new Webhook(name:\"test\",authToken: \"1234\",enabled:true)}\n        invocations * controller.rundeckAuthContextProvider.getAuthContextForSubjectAndProject(_,_) >> { new SubjectAuthContext(null, null) }\n        invocations * controller.rundeckAuthContextEvaluator.authorizeProjectResourceAny(_,_,_,_) >> { return true }\n        invocations * controller.webhookService.processWebhook(_,_,_,_,_) >> { new DefaultWebhookResponder() }\n        response.status == statusCode\n\n        where:\n        method      | statusCode | invocations\n        'POST'      | 200        | 1\n        'GET'       | 405        | 0\n        'PUT'       | 405        | 0\n        'DELETE'    | 405        | 0\n    }\n\n    interface MockWebhookService {\n        Webhook getWebhookByToken(String token)\n        Webhook getWebhook(Long id)\n        WebhookResponder processWebhook(String pluginName, String pluginConfigJson, WebhookDataImpl data, UserAndRolesAuthContext context, HttpServletRequest request)\n    }\n\n    interface MockApiService {\n        def renderErrorFormat(HttpServletResponse response, Map data)\n    }\n}\n", "/*\n * Copyright 2019 Rundeck, Inc. (http://rundeck.com)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage webhooks\n\nimport com.dtolabs.rundeck.core.authentication.tokens.AuthTokenManager\nimport com.dtolabs.rundeck.core.authentication.tokens.AuthTokenType\nimport com.dtolabs.rundeck.core.authentication.tokens.AuthenticationToken\nimport com.dtolabs.rundeck.core.authorization.UserAndRolesAuthContext\nimport com.dtolabs.rundeck.core.config.FeatureService\nimport com.dtolabs.rundeck.core.config.Features\nimport com.dtolabs.rundeck.core.event.EventStoreService\nimport com.dtolabs.rundeck.core.plugins.ConfiguredPlugin\nimport com.dtolabs.rundeck.core.plugins.PluggableProviderService\nimport com.dtolabs.rundeck.core.plugins.PluginRegistry\nimport com.dtolabs.rundeck.core.plugins.ValidatedPlugin\nimport com.dtolabs.rundeck.core.plugins.configuration.PluginCustomConfigValidator\nimport com.dtolabs.rundeck.core.plugins.configuration.PropertyResolver\nimport com.dtolabs.rundeck.core.plugins.configuration.PropertyScope\nimport com.dtolabs.rundeck.core.plugins.configuration.Validator\nimport com.dtolabs.rundeck.core.storage.keys.KeyStorageTree\nimport com.dtolabs.rundeck.core.webhook.WebhookEventException\nimport com.dtolabs.rundeck.plugins.descriptions.PluginCustomConfig\nimport com.dtolabs.rundeck.plugins.webhook.DefaultWebhookResponder\nimport com.dtolabs.rundeck.plugins.webhook.WebhookData\nimport com.dtolabs.rundeck.plugins.webhook.WebhookDataImpl\nimport com.dtolabs.rundeck.plugins.webhook.WebhookEventContext\nimport com.dtolabs.rundeck.plugins.webhook.WebhookEventPlugin\nimport com.dtolabs.rundeck.plugins.webhook.WebhookResponder\nimport grails.testing.gorm.DataTest\nimport grails.testing.services.ServiceUnitTest\nimport org.rundeck.app.spi.AuthorizedServicesProvider\nimport org.rundeck.app.spi.Services\nimport spock.lang.Specification\nimport spock.lang.Unroll\n\nimport javax.servlet.http.HttpServletRequest\n\n\nclass WebhookServiceSpec extends Specification implements ServiceUnitTest<WebhookService>, DataTest {\n    void setupSpec() {\n        mockDomain Webhook\n    }\n\n    def \"process webhook\"() {\n        given:\n        def mockUserAuth = Mock(UserAndRolesAuthContext) {\n            getUsername() >> { \"webhookUser\" }\n            getRoles() >> { [\"webhook\",\"test\"] }\n        }\n        WebhookDataImpl data = new WebhookDataImpl()\n        data.webhook = \"testhook\"\n        data.sender = \"asender\"\n        data.contentType = \"text/plain\"\n        data.data = new ByteArrayInputStream(\"my event data\".bytes)\n        service.storageService = Mock(MockStorageService)\n\n\n        when:\n        def mockPropertyResolver = Mock(PropertyResolver)\n        def webhookProviderService = Mock(PluggableProviderService)\n\n        service.featureService = Mock(FeatureService) {\n            featurePresent(Features.EVENT_STORE) >> false\n        }\n\n        service.gormEventStoreService = Mock(EventStoreService) {\n            scoped(_,_) >> { Mock(EventStoreService) }\n        }\n\n        service.rundeckAuthorizedServicesProvider = Mock(AuthorizedServicesProvider) {\n            getServicesWith(_) >> { Mock(Services)}\n        }\n        service.frameworkService = Mock(MockFrameworkService) {\n            getFrameworkPropertyResolver(_,_) >> { mockPropertyResolver }\n        }\n        service.rundeckPluginRegistry = Mock(PluginRegistry) {\n            createPluggableService(WebhookEventPlugin) >> {\n                webhookProviderService\n            }\n        }\n\n        TestWebhookEventPlugin testPlugin = new TestWebhookEventPlugin()\n\n        service.pluginService = Mock(MockPluginService) {\n            configurePlugin(\"test-webhook-event\", _, _,_) >> { new ConfiguredPlugin<WebhookEventPlugin>(testPlugin, [:] ) }\n        }\n        def request = Mock(HttpServletRequest) {\n            getHeader(\"X-Rundeck-TestHdr\") >> { \"Hdr1\" }\n        }\n        def responder = service.processWebhook(\"test-webhook-event\",\"{}\",data,mockUserAuth,request)\n\n        then:\n        1 * service.storageService.storageTreeWithContext(_) >> Mock(KeyStorageTree)\n        testPlugin.captured.data.text==\"my event data\"\n        testPlugin.captured.headers[\"X-Rundeck-TestHdr\"] == \"Hdr1\"\n        responder instanceof DefaultWebhookResponder\n\n    }\n\n    class TestWebhookEventPlugin implements WebhookEventPlugin {\n        WebhookData captured\n\n        @Override\n        List<String> getRequestHeadersToCopy() {\n            return [\"X-Rundeck-TestHdr\"]\n        }\n\n        @Override\n        WebhookResponder onEvent(final WebhookEventContext context, final WebhookData data) throws WebhookEventException {\n            captured = data\n            return null\n        }\n    }\n\n    def \"save new webhook\"() {\n        given:\n        def mockUserAuth = Mock(UserAndRolesAuthContext) {\n            getUsername() >> { \"webhookUser\" }\n            getRoles() >> { [\"webhook\",\"test\"] }\n        }\n        service.apiService = Mock(MockApiService)\n        service.rundeckAuthTokenManagerService = Mock(AuthTokenManager) {\n            parseAuthRoles(_) >> { [\"webhook\",\"test\"] }\n        }\n        service.userService = Mock(MockUserService) {\n            validateUserExists(_) >> { true }\n        }\n        service.pluginService = Mock(MockPluginService) {\n            validatePluginConfig(_,_,_) >> { return new ValidatedPlugin(report: new Validator.Report(),valid:true) }\n            getPlugin(_,_) >> { new TestWebhookEventPlugin() }\n            listPlugins(WebhookEventPlugin) >> { [\"log-webhook-event\":new TestWebhookEventPlugin()] }\n        }\n\n        when:\n        def result = service.saveHook(mockUserAuth,[name:\"test\",project:\"Test\",user:\"webhookUser\",roles:\"webhook,test\",eventPlugin:\"log-webhook-event\",\"config\":[\"cfg1\":\"val1\"]])\n        Webhook created = Webhook.findByName(\"test\")\n\n        then:\n        result == [msg:\"Saved webhook\"]\n        created.name == \"test\"\n        created.project == \"Test\"\n        created.enabled == true\n        created.eventPlugin == \"log-webhook-event\"\n        created.pluginConfigurationJson == '{\"cfg1\":\"val1\"}'\n        1 * service.apiService.generateUserToken(_,_,_,_,_,_) >> { [token:\"12345\"] }\n\n    }\n    def \"save new webhook validation fails\"() {\n        given:\n        def mockUserAuth = Mock(UserAndRolesAuthContext) {\n            getUsername() >> { \"webhookUser\" }\n            getRoles() >> { [\"webhook\",\"test\"] }\n        }\n        service.apiService = Mock(MockApiService)\n        service.rundeckAuthTokenManagerService = Mock(AuthTokenManager) {\n            parseAuthRoles(_) >> { [\"webhook\",\"test\"] }\n        }\n        service.userService = Mock(MockUserService) {\n            validateUserExists(_) >> { true }\n        }\n        def report=new Validator.Report()\n        report.errors['test']='wrong'\n        service.pluginService = Mock(MockPluginService) {\n            validatePluginConfig(_,_,_) >> { return new ValidatedPlugin(report: report,valid:false) }\n            getPlugin(_,_) >> { new TestWebhookEventPlugin() }\n            listPlugins(WebhookEventPlugin) >> { [\"log-webhook-event\":new TestWebhookEventPlugin()] }\n        }\n\n        when:\n        def result = service.saveHook(mockUserAuth,[name:\"test\",project:\"Test\",user:\"webhookUser\",roles:\"webhook,test\",eventPlugin:\"log-webhook-event\",\"config\":[\"cfg1\":\"val1\"]])\n        Webhook created = Webhook.findByName(\"test\")\n\n        then:\n        result.err ==~ /^Invalid plugin configuration.*/\n        result.errors==[test:'wrong']\n        !created\n        0 * service.apiService.generateUserToken(_,_,_,_,_,_)\n\n    }\n    def \"save new webhook token creation fails\"() {\n        given:\n        def mockUserAuth = Mock(UserAndRolesAuthContext) {\n            getUsername() >> { \"webhookUser\" }\n            getRoles() >> { [\"webhook\",\"test\"] }\n        }\n        service.apiService = Mock(MockApiService){\n            generateUserToken(_,_,_,_,_,_)>>{\n                throw new Exception(\"token error\")\n            }\n        }\n        service.rundeckAuthTokenManagerService = Mock(AuthTokenManager) {\n            parseAuthRoles(_) >> { [\"webhook\",\"test\"] }\n        }\n        service.userService = Mock(MockUserService) {\n            validateUserExists(_) >> { true }\n        }\n        def report=new Validator.Report()\n        service.pluginService = Mock(MockPluginService) {\n            validatePluginConfig(_,_,_) >> { return new ValidatedPlugin(report: report,valid:true) }\n            getPlugin(_,_) >> { new TestWebhookEventPlugin() }\n            listPlugins(WebhookEventPlugin) >> { [\"log-webhook-event\":new TestWebhookEventPlugin()] }\n        }\n\n        when:\n        def result = service.saveHook(mockUserAuth,[name:\"test\",project:\"Test\",user:\"webhookUser\",roles:\"webhook,test\",eventPlugin:\"log-webhook-event\",\"config\":[\"cfg1\":\"val1\"]])\n        Webhook created = Webhook.findByName(\"test\")\n\n        then:\n        result.err ==~ /^Failed to create associated Auth Token: token error$/\n        !created\n    }\n    def \"save new webhook token creation unauthorized\"() {\n        given:\n            Webhook existing = new Webhook(name:\"test\",project: \"Test\",authToken: \"12345\",eventPlugin: \"log-webhook-event\")\n            existing.save()\n\n            def mockUserAuth = Mock(UserAndRolesAuthContext) {\n                getUsername() >> { \"webhookUser\" }\n                getRoles() >> { [\"webhook\",\"test\"] }\n            }\n            service.apiService = Mock(MockApiService){\n                generateUserToken(_,_,_,_,_,_)>>{\n\n                }\n            }\n            service.rundeckAuthTokenManagerService = Mock(AuthTokenManager) {\n                parseAuthRoles(_) >> { [\"webhook\",\"test\",\"bogus\"] }\n                updateAuthRoles(_,_,_)>>{\n                    throw new Exception(\"Unauthorized to update roles\")\n                }\n            }\n            service.userService = Mock(MockUserService) {\n                validateUserExists(_) >> { true }\n            }\n            def report=new Validator.Report()\n            service.pluginService = Mock(MockPluginService) {\n                validatePluginConfig(_,_,_) >> { return new ValidatedPlugin(report: report,valid:true) }\n                getPlugin(_,_) >> { new TestWebhookEventPlugin() }\n                listPlugins(WebhookEventPlugin) >> { [\"log-webhook-event\":new TestWebhookEventPlugin()] }\n            }\n\n        when:\n            def result = service.saveHook(mockUserAuth,[id:existing.id,name:\"test\",project:\"Test\",user:\"webhookUser\",roles:\"webhook,test,bogus\",eventPlugin:\"log-webhook-event\",\"config\":[\"cfg1\":\"val1\"]])\n\n        then:\n            result.err ==~ /^Failed to update Auth Token roles: Unauthorized to update roles$/\n    }\n\n    def \"save new webhook fails due to gorm validation, token should get deleted\"() {\n        given:\n            def mockUserAuth = Mock(UserAndRolesAuthContext) {\n                getUsername() >> { \"webhookUser\" }\n                getRoles() >> { [\"webhook\",\"test\"] }\n            }\n            service.apiService = Mock(MockApiService)\n            service.rundeckAuthTokenManagerService = Mock(AuthTokenManager) {\n                parseAuthRoles(_) >> { [\"webhook\",\"test\"] }\n            }\n            service.userService = Mock(MockUserService) {\n                validateUserExists(_) >> { true }\n            }\n            service.pluginService = Mock(MockPluginService) {\n                validatePluginConfig(_,_,_) >> { return new ValidatedPlugin(report: new Validator.Report(),valid:true) }\n                getPlugin(_,_) >> { new TestWebhookEventPlugin() }\n                listPlugins(WebhookEventPlugin) >> { [\"log-webhook-event\":new TestWebhookEventPlugin()] }\n            }\n\n        when:\n            def result = service.saveHook(mockUserAuth,[project:\"Test\",user:\"webhookUser\",roles:\"webhook,test\",eventPlugin:\"log-webhook-event\",\"config\":[\"cfg1\":\"val1\"]])\n            Webhook created = Webhook.findByName(\"test\")\n\n\n        then:\n            result.err\n            !created\n            1 * service.apiService.generateUserToken(_,_,_,_,_,_) >> { [token:\"12345\"] }\n            1 * service.rundeckAuthTokenManagerService.deleteToken('12345')\n\n    }\n    def \"webhook name must be unique in project\"() {\n        given:\n        def mockUserAuth = Mock(UserAndRolesAuthContext) {\n            getUsername() >> { \"webhookUser\" }\n            getRoles() >> { [\"webhook\",\"test\"] }\n        }\n        Webhook existing = new Webhook(name:\"test\",project: \"Test\",authToken: \"12345\",eventPlugin: \"log-webhook-event\")\n        existing.save()\n\n        when:\n        def result = service.saveHook(mockUserAuth,[name:\"test\",project:\"Test\",user:\"webhookUser\",roles:\"webhook,test\",eventPlugin:\"log-webhook-event\",\"config\":[\"cfg1\":\"val1\"]])\n\n        then:\n        result == [err:\"A Webhook by that name already exists in this project\"]\n\n    }\n\n    @Unroll\n    def \"validate plugin config - custom validator\"() {\n        given:\n        CustomConfigWebhookEventPlugin customPlugin = new CustomConfigWebhookEventPlugin()\n\n        service.pluginService = Mock(MockPluginService) {\n            validatePluginConfig(_,_,_) >> { return new ValidatedPlugin(report: new Validator.Report(),valid: true) }\n            getPlugin(_,_) >> { customPlugin }\n        }\n\n        when:\n        Tuple2<ValidatedPlugin,Boolean> vPlugin = service.validatePluginConfig(\"custom-cfg-webhook-event\",config)\n\n        then:\n        vPlugin.first.valid == valid\n        vPlugin.first.report.errors == errors\n\n\n        where:\n        valid | config                  | errors\n        false | [:]                     | [\"requiredProp\":\"requiredProp is required\"]\n        true  | [requiredProp:\"value\"]  | [:]\n    }\n\n    static class CustomConfigWebhookEventPlugin implements WebhookEventPlugin {\n        WebhookData captured\n\n        @PluginCustomConfig(validator = TestCustomValidator)\n        Map config\n\n        @Override\n        WebhookResponder onEvent(final WebhookEventContext context, final WebhookData data) throws WebhookEventException {\n            captured = data\n            return new DefaultWebhookResponder()\n        }\n    }\n\n    static class TestCustomValidator implements PluginCustomConfigValidator {\n\n        @Override\n        Validator.Report validate(final Map config) {\n            Validator.Report report = new Validator.Report()\n            if(!config.requiredProp) report.errors[\"requiredProp\"] = \"requiredProp is required\"\n            return report\n        }\n    }\n\n\n    def \"ReplaceSecureOpts\"() {\n        given:\n        def mockUserAuth = Mock(UserAndRolesAuthContext) {\n            getUsername() >> { \"webhookUser\" }\n            getRoles() >> { [\"webhook\",\"test\"] }\n        }\n        when:\n        def config = [:]\n        config.prop1 = \"my value\"\n        config.prop2 = '${KS:keys/proj1/sval}'\n        config.prop3 = [\n                prop1: 'foo',\n                prop2: '${KS:keys/proj1/sval}'\n        ]\n        config.prop4 = [\n                'foo',\n                '${KS:keys/proj1/sval}'\n        ]\n\n        config.prop5 = '${KS:keys/proj1/sval} ${KS:keys/proj1/sval2}'\n\n        def mockStorageTree = Mock(MockStorageTree) {\n            hasPassword(_) >> { true }\n            readPassword(\"keys/proj1/sval\") >> { \"password\".bytes }\n            readPassword(\"keys/proj1/sval2\") >> { \"other\".bytes }\n        }\n        service.storageService = Mock(MockStorageService) {\n            storageTreeWithContext(_) >> { mockStorageTree }\n        }\n        service.replaceSecureOpts(mockUserAuth,config)\n\n        then:\n        config.prop1 == \"my value\"\n        config.prop2 == \"password\"\n        config.prop3['prop2'] == \"password\"\n        config.prop4[1] == \"password\"\n        config.prop5 == \"password other\"\n\n    }\n\n    @Unroll\n    def \"import webhooks regenAuthToken: #regenFlag\"() {\n        given:\n        service.pluginService = Mock(MockPluginService) {\n            listPlugins(_) >> { [\"log-webhook-event\":new Object()]}\n        }\n        service.rundeckAuthTokenManagerService = Mock(AuthTokenManager)\n        def authContext = Mock(UserAndRolesAuthContext) {\n            getUsername() >> { \"admin\" }\n        }\n        service.apiService = Mock(MockApiService)\n        service.metaClass.validatePluginConfig = { String plugin, Map config -> new Tuple2<ValidatedPlugin, Boolean>(new ValidatedPlugin(valid: true),false)}\n\n        when:\n        def result = service.importWebhook(authContext,[name:\"test\",\n                                            uuid: \"0dfb6080-935e-413d-a6a7-cdee9345cf72\",\n                                            project:\"Test\", authToken:'abc123', user:'webhookUser', roles:\"webhook,test\",\n                                            eventPlugin:\"log-webhook-event\",\n                                            config:'{}'],regenFlag)\n        Webhook created = Webhook.findByName(\"test\")\n\n        then:\n        result == [msg:\"Webhook test imported\"]\n        created.name == \"test\"\n        created.project == \"Test\"\n        created.eventPlugin == \"log-webhook-event\"\n        created.pluginConfigurationJson == '{}'\n        1 * service.rundeckAuthTokenManagerService.parseAuthRoles(\"webhook,test\") >> { new HashSet(['webhook','test']) }\n        expectGenTokenCall * service.apiService.generateUserToken(_,_,_,_,_,_) >> { [token:\"12345\"] }\n        expectImportWhkToken * service.rundeckAuthTokenManagerService.importWebhookToken(authContext,'abc123','webhookUser',new HashSet(['webhook','test'])) >> { true }\n\n        where:\n        regenFlag | expectGenTokenCall | expectImportWhkToken\n        true        |                1 |                    0\n        false       |                0 |                    1\n    }\n\n    def \"import is allowed\"() {\n        given:\n        service.rundeckAuthTokenManagerService=Mock(AuthTokenManager)\n        when:\n        boolean res = service.importIsAllowed(hook,hookData)\n\n        then:\n        res == expected\n\n        where:\n        expected | hook | hookData\n        true     | new Webhook(name: \"hk1\", authToken: \"12345\") | [authToken:\"12345\"]\n        true     | new Webhook(name: \"hk1\") | [authToken:\"12345\"]\n    }\n\n    def \"import is not allowed\"() {\n        setup:\n        new Webhook(name:\"preexisting\",authToken: \"12345\",project:\"one\",eventPlugin: \"plugin\").save()\n\n        when:\n\n        Webhook hook = new Webhook(name:\"new\")\n        def hookData = [authToken:\"12345\"]\n        boolean res = service.importIsAllowed(hook,hookData)\n\n        then:\n        !res\n    }\n\n    def \"getWebhookWithAuth\"() {\n        setup:\n        Webhook hook = new Webhook()\n        hook.name = \"hit\"\n        hook.project = \"One\"\n        hook.authToken = \"abc123\"\n        hook.eventPlugin = \"do-some-action\"\n        hook.pluginConfigurationJson = '{\"prop1\":\"true\"}'\n        hook.save()\n\n        service.rundeckAuthTokenManagerService = Mock(AuthTokenManager) {\n            getToken(\"abc123\") >> { new TestAuthenticationToken(token:\"abc123\",\n                                                                creator:\"admin\",\n                                                                authRoles:[\"webhook,role1\"] as Set,\n                                                                ownerName:\"webhook\") }\n\n        }\n\n        when:\n        def output = service.getWebhookWithAuth(hook.id.toString())\n\n        then:\n        output.id == hook.id\n        output.name == \"hit\"\n        output.project == \"One\"\n        output.eventPlugin == \"do-some-action\"\n        output.config == [\"prop1\":\"true\"]\n        output.user == \"webhook\"\n        output.creator == \"admin\"\n        output.roles == \"webhook,role1\"\n        output.authToken == \"abc123\"\n    }\n\n    def \"delete all webhooks in project\"() {\n        setup:\n        String project = \"prj1\"\n        new Webhook(name:\"hook1\",project:project,authToken: \"123\",eventPlugin: \"plugin\").save()\n        new Webhook(name:\"hook2\",project:project,authToken: \"123\",eventPlugin: \"plugin\").save()\n        new Webhook(name:\"hook3\",project:\"prj2\",authToken: \"123\",eventPlugin: \"plugin\").save()\n        new Webhook(name:\"hook4\",project:\"prj3\",authToken: \"123\",eventPlugin: \"plugin\").save()\n\n        when:\n        int beforeCount = Webhook.count()\n        service.deleteWebhooksForProject(project)\n        int afterCount = Webhook.count()\n\n        then:\n        beforeCount == 4\n        afterCount == 2\n        Webhook.countByProject(project) == 0\n    }\n\n    interface MockUserService {\n        boolean validateUserExists(String user)\n    }\n\n    interface MockFrameworkService {\n        PropertyResolver getFrameworkPropertyResolver(String project, Map config)\n    }\n\n    interface MockPluginService {\n        ConfiguredPlugin configurePlugin(String pluginName, Class serviceClass, PropertyResolver resolver, PropertyScope scope)\n        ValidatedPlugin validatePluginConfig(String service, String pluginName, Map config)\n        WebhookEventPlugin getPlugin(String service, Class pluginClass)\n        Map listPlugins(Class pluginClass)\n    }\n\n    interface MockApiService {\n        Map generateUserToken(UserAndRolesAuthContext ctx, Integer expiration, String user, Set<String> roles, boolean forceExpiration, AuthTokenType tokenType) throws Exception\n    }\n\n    interface MockStorageService {\n        Object storageTreeWithContext(Object obj)\n    }\n    interface MockStorageTree {\n        boolean hasPassword(String path)\n        byte[] readPassword(String path)\n    }\n\n    class TestAuthenticationToken implements AuthenticationToken {\n\n        String token\n        Set<String> authRoles\n        String uuid\n        String creator\n        String ownerName\n\n        @Override\n        Set<String> authRolesSet() {\n            return authRoles\n        }\n\n        @Override\n        AuthTokenType getType() {\n            return AuthTokenType.WEBHOOK\n        }\n\n        @Override\n        String getPrintableToken() {\n            return token\n        }\n\n        @Override\n        Date getExpiration() {\n            return null\n        }\n\n        @Override\n        String getName() {\n            return null\n        }\n    }\n}\n"], "fixing_code": ["package webhooks\n\nimport com.dtolabs.rundeck.core.authorization.AuthContext\nimport com.dtolabs.rundeck.core.authorization.AuthContextEvaluator\nimport com.dtolabs.rundeck.core.authorization.AuthContextProvider\nimport com.dtolabs.rundeck.core.authorization.AuthorizationUtil\nimport com.dtolabs.rundeck.core.authorization.UserAndRolesAuthContext\nimport com.dtolabs.rundeck.core.webhook.WebhookEventException\nimport com.dtolabs.rundeck.plugins.webhook.WebhookDataImpl\nimport com.fasterxml.jackson.databind.ObjectMapper\nimport grails.converters.JSON\nimport groovy.transform.PackageScope\nimport org.rundeck.core.auth.AuthConstants\n\nimport javax.servlet.http.HttpServletResponse\n\nclass WebhookController {\n    static allowedMethods = [post:'POST']\n\n    def webhookService\n    def frameworkService\n    AuthContextEvaluator rundeckAuthContextEvaluator\n    AuthContextProvider rundeckAuthContextProvider\n    def apiService\n\n    def admin() {}\n\n    def save() {\n        String project = request.JSON.project\n        if(!project){\n            return apiService.renderErrorFormat(response, [status: HttpServletResponse.SC_BAD_REQUEST,\n                                                           code: 'api.error.parameter.required', args: ['project']])\n\n        }\n        UserAndRolesAuthContext authContext = rundeckAuthContextProvider.getAuthContextForSubjectAndProject(session.subject, project)\n        if (!rundeckAuthContextEvaluator.authorizeProjectResourceAny(\n            authContext,\n            AuthConstants.RESOURCE_TYPE_WEBHOOK,\n            [AuthConstants.ACTION_CREATE, AuthConstants.ACTION_UPDATE, AuthConstants.ACTION_ADMIN, AuthConstants.ACTION_APP_ADMIN],\n            project\n        )) {\n            sendJsonError(\"You are not authorized to perform this action\")\n            return\n        }\n\n        def msg = webhookService.saveHook(authContext,request.JSON)\n        if(msg.err) response.status = 400\n\n        render msg as JSON\n    }\n\n    def remove() {\n        if(!params.project){\n            return apiService.renderErrorFormat(response, [status: HttpServletResponse.SC_BAD_REQUEST,\n                                                           code: 'api.error.parameter.required', args: ['project']])\n\n        }\n        Webhook webhook = webhookService.getWebhook(params.id.toLong())\n        if(!webhook) {\n            sendJsonError(\"Webhook not found\")\n            return\n        }\n\n        UserAndRolesAuthContext authContext = rundeckAuthContextProvider.getAuthContextForSubjectAndProject(session.subject, params.project)\n        if (!authorized(authContext, webhook.project, ACTION_DELETE)) {\n            sendJsonError(\"You are not authorized to perform this action\")\n            return\n        }\n        def output = webhookService.delete(webhook)\n        if(output.err) response.status = 400\n        render output as JSON\n\n    }\n\n    def get() {\n        if(!params.project){\n            return apiService.renderErrorFormat(response, [status: HttpServletResponse.SC_BAD_REQUEST,\n                                                           code: 'api.error.parameter.required', args: ['project']])\n\n        }\n        if(!params.id){\n            return apiService.renderErrorFormat(response, [status: HttpServletResponse.SC_BAD_REQUEST,\n                                                           code: 'api.error.parameter.required', args: ['id']])\n\n        }\n        UserAndRolesAuthContext authContext = rundeckAuthContextProvider.getAuthContextForSubjectAndProject(session.subject,params.project)\n        if (!authorized(authContext, params.project, AuthConstants.ACTION_READ)) {\n            sendJsonError(\"You do not have access to this resource\")\n            return\n        }\n        def webhook = webhookService.getWebhookForProjectWithAuth(params.id, params.project)\n        if(!webhook){\n            return sendJsonError(\"Webhook not found\", HttpServletResponse.SC_NOT_FOUND)\n        }\n        render webhook as JSON\n    }\n\n    def list() {\n        if(!params.project){\n            return apiService.renderErrorFormat(response, [status: HttpServletResponse.SC_BAD_REQUEST,\n                                                           code: 'api.error.parameter.required', args: ['project']])\n\n        }\n        UserAndRolesAuthContext authContext = rundeckAuthContextProvider.getAuthContextForSubjectAndProject(session.subject, params.project)\n        if (!authorized(authContext, params.project, AuthConstants.ACTION_READ)) {\n            sendJsonError(\"You do not have access to this resource\")\n            return\n        }\n        render webhookService.listWebhooksByProject(params.project) as JSON\n    }\n\n    def editorData() {\n        if(!params.project){\n            return apiService.renderErrorFormat(response, [status: HttpServletResponse.SC_BAD_REQUEST,\n                                                           code: 'api.error.parameter.required', args: ['project']])\n\n        }\n        UserAndRolesAuthContext authContext = rundeckAuthContextProvider.getAuthContextForSubjectAndProject(session.subject, params.project)\n        if (!authorized(authContext, params.project, AuthConstants.ACTION_READ)) {\n            sendJsonError(\"You do not have access to this resource\")\n            return\n        }\n\n        def uidata = [:]\n        uidata.hooks = webhookService.listWebhooksByProject(params.project)\n        uidata.username = authContext.username\n        uidata.roles = authContext.roles.join(\",\")\n        render uidata as JSON\n    }\n\n    def post() {\n        Webhook hook = webhookService.getWebhookByToken(Webhook.cleanAuthToken(params.authtoken))\n\n        if(!hook) {\n            sendJsonError(\"Webhook not found\")\n            return\n        }\n        if(!hook.enabled) {\n            sendJsonError(\"Webhook not enabled\",503)\n            return\n        }\n\n        UserAndRolesAuthContext authContext = rundeckAuthContextProvider.getAuthContextForSubjectAndProject(session.subject, hook.project)\n        if (!authorized(authContext, hook.project, AuthConstants.ACTION_POST)) {\n            sendJsonError(\"You are not authorized to perform this action\")\n            return\n        }\n\n        WebhookDataImpl whkdata = new WebhookDataImpl()\n        whkdata.webhookUUID = hook.uuid\n        whkdata.webhook = hook.name\n        whkdata.timestamp = System.currentTimeMillis()\n        whkdata.sender = request.remoteAddr\n        whkdata.project = hook.project\n        whkdata.contentType = request.contentType\n        whkdata.data = request.inputStream\n\n        try {\n            def responder = webhookService.processWebhook(hook.eventPlugin, hook.pluginConfigurationJson, whkdata, authContext, request)\n            responder.respond(response)\n        } catch(WebhookEventException wee) {\n            sendJsonError(wee.message)\n        }\n    }\n\n    private def sendJsonError(String errMessage,int statusCode = 400) {\n        response.setStatus(statusCode)\n        def err = [err:errMessage]\n        render err as JSON\n    }\n\n    @PackageScope\n    boolean authorized(AuthContext authContext, String project, String action) {\n        List authorizedActions = [AuthConstants.ACTION_ADMIN, AuthConstants.ACTION_APP_ADMIN]\n        if(action != AuthConstants.ACTION_ADMIN) authorizedActions.add(action)\n        rundeckAuthContextEvaluator.authorizeProjectResourceAny(authContext,AuthConstants.RESOURCE_TYPE_WEBHOOK,authorizedActions,project)\n    }\n}\n", "package webhooks\n\nimport com.dtolabs.rundeck.core.authentication.tokens.AuthTokenType\nimport com.dtolabs.rundeck.core.authentication.tokens.AuthenticationToken\nimport com.dtolabs.rundeck.core.authorization.UserAndRolesAuthContext\nimport com.dtolabs.rundeck.core.config.Features\nimport com.dtolabs.rundeck.core.event.EventImpl\nimport com.dtolabs.rundeck.core.event.EventQueryImpl\nimport com.dtolabs.rundeck.core.event.EventStoreService\nimport com.dtolabs.rundeck.core.plugins.ValidatedPlugin\nimport com.dtolabs.rundeck.core.plugins.configuration.PluginAdapterUtility\nimport com.dtolabs.rundeck.core.plugins.configuration.PluginCustomConfigValidator\nimport com.dtolabs.rundeck.core.plugins.configuration.PropertyScope\nimport com.dtolabs.rundeck.core.plugins.configuration.Validator\nimport com.dtolabs.rundeck.core.storage.keys.KeyStorageTree\nimport com.dtolabs.rundeck.core.webhook.WebhookEventContextImpl\nimport com.dtolabs.rundeck.plugins.ServiceNameConstants\nimport com.dtolabs.rundeck.plugins.descriptions.PluginCustomConfig\nimport com.dtolabs.rundeck.plugins.webhook.DefaultWebhookResponder\nimport com.dtolabs.rundeck.plugins.webhook.WebhookDataImpl\nimport com.dtolabs.rundeck.plugins.webhook.WebhookEventContext\nimport com.dtolabs.rundeck.plugins.webhook.WebhookEventPlugin\nimport com.fasterxml.jackson.databind.ObjectMapper\nimport grails.gorm.transactions.Transactional\nimport groovy.transform.PackageScope\nimport org.rundeck.app.spi.Services\nimport org.rundeck.app.spi.SimpleServiceProvider\nimport org.slf4j.Logger\nimport org.slf4j.LoggerFactory\n\nimport javax.servlet.http.HttpServletRequest\n\n@Transactional\nclass WebhookService {\n    private static final Logger LOGGER = LoggerFactory.getLogger(\"org.rundeck.webhook.events\")\n    private static final ObjectMapper mapper = new ObjectMapper()\n    private static final String KEY_STORE_PREFIX = \"\\${KS:\"\n    private static final String END_MARKER = \"}\"\n\n    def rundeckPluginRegistry\n    def pluginService\n    def frameworkService\n    def rundeckAuthorizedServicesProvider\n    def apiService\n    def messageSource\n    def userService\n    def rundeckAuthTokenManagerService\n    def storageService\n    def gormEventStoreService\n    def featureService\n\n    def processWebhook(String pluginName, String pluginConfigJson, WebhookDataImpl data, UserAndRolesAuthContext authContext, HttpServletRequest request) {\n        LOGGER.info(\"processing '\" + data.webhook + \"' with plugin '\" + pluginName + \"' triggered by: '\" + authContext.username+ \"'\")\n        Map pluginConfig = pluginConfigJson ? mapper.readValue(pluginConfigJson,HashMap) : [:]\n        replaceSecureOpts(authContext,pluginConfig)\n        WebhookEventPlugin plugin = pluginService.configurePlugin(pluginName, WebhookEventPlugin.class, frameworkService.getFrameworkPropertyResolver(data.project,pluginConfig),\n                                                                  PropertyScope.Instance).instance\n\n        PluginAdapterUtility.setConfig(plugin, pluginConfig)\n\n        plugin.requestHeadersToCopy?.each { hdr -> data.headers[hdr] = request.getHeader(hdr)}\n\n        Services contextServices = rundeckAuthorizedServicesProvider.getServicesWith(authContext)\n\n        if (featureService.featurePresent(Features.EVENT_STORE)) {\n            def scopedStore = gormEventStoreService.scoped(\n                new Evt(projectName: data.project, subsystem: 'webhooks'),\n                new EvtQuery(projectName: data.project, subsystem: 'webhooks')\n            )\n            contextServices = contextServices.combine(\n                    new SimpleServiceProvider([(EventStoreService): scopedStore])\n            )\n        }\n        def keyStorageService = storageService.storageTreeWithContext(authContext)\n        contextServices = contextServices.combine(new SimpleServiceProvider([(KeyStorageTree): keyStorageService]))\n\n        WebhookEventContext context = new WebhookEventContextImpl(contextServices)\n\n        return plugin.onEvent(context,data) ?: new DefaultWebhookResponder()\n    }\n\n    @PackageScope\n    void replaceSecureOpts(UserAndRolesAuthContext authContext, Map configProps) {\n        if(configProps.isEmpty()) return\n        def keystore = storageService.storageTreeWithContext(authContext)\n\n        Stack<Object> items = []\n\n        configProps.each { idx, i -> items.push([i, configProps, idx]) }\n\n        while(true) {\n            if (items.empty())\n                break\n\n            def elem = items.pop()\n\n            def (item, parent, index) = elem\n\n            if (item instanceof Map) {\n                item.each { idx, i -> items.push([i, item, idx]) }\n                continue\n            } else if (item instanceof List) {\n                item.eachWithIndex { i, idx -> items.push([i, item, idx]) }\n                continue\n            }\n\n            if (item instanceof String) {\n                if(item && item.contains(KEY_STORE_PREFIX)) {\n                    String replaced = item\n                    int startIdx = -1\n                    while(replaced.indexOf(KEY_STORE_PREFIX,startIdx+1) != -1) {\n                        startIdx = replaced.indexOf(KEY_STORE_PREFIX)\n                        int endIdx = replaced.indexOf(END_MARKER,startIdx)\n                        if(endIdx == -1) {\n                            log.error(\"Invalid substitution string, terminating marker not found in value: ${replaced}\")\n                            break\n                        }\n                        String valueToReplace = replaced.substring(startIdx,endIdx+1)\n                        String keyPath = valueToReplace.substring(KEY_STORE_PREFIX.length(),valueToReplace.length()-1)\n                        if(keystore.hasPassword(keyPath)) {\n                            String replacementValue = new String(keystore.readPassword(keyPath))\n                            replaced = replaced.replace(valueToReplace,replacementValue)\n                        } else {\n                            log.warn(\"key was not found in key store: ${keyPath}\")\n                        }\n                    }\n                    parent[index] = replaced\n                }\n            }\n        }\n    }\n\n    def listWebhooksByProject(String project) {\n        Webhook.findAllByProject(project).collect {\n            getWebhookWithAuthAsMap(it)\n        }\n    }\n\n    def saveHook(UserAndRolesAuthContext authContext,def hookData) {\n        Webhook hook\n        if(hookData.id) {\n            hook = Webhook.get(hookData.id)\n            if (!hook) return [err: \"Webhook not found\"]\n            if(hookData.roles && !hookData.importData) {\n                try {\n                    rundeckAuthTokenManagerService.updateAuthRoles(authContext, hook.authToken,rundeckAuthTokenManagerService.parseAuthRoles(hookData.roles))\n                } catch (Exception e) {\n                    return [err: \"Failed to update Auth Token roles: \"+e.message]\n                }\n            }\n        } else {\n            int countByNameInProject = Webhook.countByNameAndProject(hookData.name,hookData.project)\n            if(countByNameInProject > 0) return [err: \"A Webhook by that name already exists in this project\"]\n            String checkUser = hookData.user ?: authContext.username\n            if (!hookData.importData && !userService.validateUserExists(checkUser)) return [err: \"Webhook user '${checkUser}' not found\"]\n            hook = new Webhook()\n            hook.uuid = UUID.randomUUID().toString()\n        }\n        hook.uuid = hookData.uuid ?: hook.uuid\n        hook.name = hookData.name ?: hook.name\n        hook.project = hookData.project ?: hook.project\n        if(hookData.enabled != null) hook.enabled = hookData.enabled\n        if(hookData.eventPlugin && !pluginService.listPlugins(WebhookEventPlugin).any { it.key == hookData.eventPlugin}){\n            hook.discard()\n            return [err:\"Plugin does not exist: \" + hookData.eventPlugin]\n        }\n        hook.eventPlugin = hookData.eventPlugin ?: hook.eventPlugin\n\n        Map pluginConfig = [:]\n        if(hookData.config) pluginConfig = hookData.config instanceof String ? mapper.readValue(hookData.config, HashMap) : hookData.config\n\n        def (ValidatedPlugin vPlugin, boolean isCustom) = validatePluginConfig(hook.eventPlugin,pluginConfig)\n        if(!vPlugin.valid) {\n            def errMsg = isCustom ?\n                    \"Validation errors\" :\n                    \"Invalid plugin configuration: \" + vPlugin.report.errors.collect { k, v -> \"$k : $v\" }.join(\"\\n\")\n            hook.discard()\n\n            return [err: errMsg, errors: vPlugin.report.errors]\n        }\n\n        hook.pluginConfigurationJson = mapper.writeValueAsString(pluginConfig)\n        Set<String> roles = hookData.roles ? rundeckAuthTokenManagerService.parseAuthRoles(hookData.roles) : authContext.roles\n        if((!hook.id || !hook.authToken) && !hookData.shouldImportToken){\n            //create token\n            String checkUser = hookData.user ?: authContext.username\n            try {\n                def at=apiService.generateUserToken(authContext, null, checkUser, roles, false, AuthTokenType.WEBHOOK)\n                hook.authToken = at.token\n            } catch (Exception e) {\n                hook.discard()\n                return [err: \"Failed to create associated Auth Token: \"+e.message]\n            }\n        }\n        if(hookData.shouldImportToken) {\n            if(!importIsAllowed(hook,hookData)){\n                throw new Exception(\"Cannot import webhook: auth token already in use\")\n            }\n            try {\n                rundeckAuthTokenManagerService.importWebhookToken(authContext, hookData.authToken, hookData.user, roles)\n            } catch (Exception e) {\n                hook.discard()\n                return [err: \"Failed importing Webhook Token: \"+e.message]\n            }\n            hook.authToken = hookData.authToken\n        }\n\n        if(hook.validate()) {\n            hook.save(failOnError:true, flush:true)\n            return [msg: \"Saved webhook\"]\n        } else {\n            if(!hook.id && hook.authToken){\n                //delete the created token\n                rundeckAuthTokenManagerService.deleteToken(hook.authToken)\n            }\n            return [err: hook.errors.allErrors.collect { messageSource.getMessage(it,null) }.join(\",\")]\n        }\n    }\n\n    boolean importIsAllowed(Webhook hook, Map hookData) {\n        if(hook.authToken == hookData.authToken) return true\n        if(!hook.authToken && Webhook.countByAuthToken(hookData.authToken) == 0 && !rundeckAuthTokenManagerService.getToken(hookData.authToken)) return true\n        return false\n    }\n\n\n    @PackageScope\n    Tuple2<ValidatedPlugin, Boolean> validatePluginConfig(String webhookPlugin, Map pluginConfig) {\n        ValidatedPlugin result = pluginService.validatePluginConfig(ServiceNameConstants.WebhookEvent, webhookPlugin, pluginConfig)\n        def isCustom = false\n        def plugin = pluginService.getPlugin(webhookPlugin,WebhookEventPlugin.class)\n        PluginCustomConfig customConfig = PluginAdapterUtility.getCustomConfigAnnotation(plugin)\n        if(customConfig && customConfig.validator()) {\n            PluginCustomConfigValidator validator = Validator.createCustomPropertyValidator(customConfig)\n            if(validator) {\n                result.report.errors.putAll(validator.validate(pluginConfig).errors)\n                result.valid = result.report.valid\n                isCustom = true\n            }\n        }\n        return new Tuple2(result, isCustom)\n    }\n\n    def deleteWebhooksForProject(String project) {\n        Webhook.findAllByProject(project).each { webhook ->\n            delete(webhook)\n        }\n    }\n\n    def delete(Webhook hook) {\n        String authToken = hook.authToken\n        String name = hook.name\n        try {\n            hook.delete()\n            rundeckAuthTokenManagerService.deleteToken(authToken)\n            return [msg: \"Deleted ${name} webhook\"]\n        } catch(Exception ex) {\n            log.error(\"delete webhook failed\",ex)\n            return [err: ex.message]\n        }\n    }\n\n    def importWebhook(UserAndRolesAuthContext authContext, Map hook, boolean regenAuthTokens) {\n\n        Webhook existing = Webhook.findByUuidAndProject(hook.uuid, hook.project)\n        if(existing) hook.id = existing.id\n        hook.importData = true\n\n        if(!regenAuthTokens && hook.authToken) {\n            hook.shouldImportToken = true\n        } else {\n            hook.authToken = null\n        }\n\n        try {\n            def msg = saveHook(authContext, hook)\n            if(msg.err) {\n                log.error(\"Failed to import webhook. Error: \" + msg.err)\n                return [err:\"Unable to import webhoook ${hook.name}. Error:\"+msg.err]\n            }\n            return [msg:\"Webhook ${hook.name} imported\"]\n        } catch(Exception ex) {\n            log.error(\"Failed to import webhook\", ex)\n            return [err:\"Unable to import webhoook ${hook.name}. Error:\"+ex.message]\n        }\n\n    }\n\n    def getWebhookWithAuth(String id) {\n        Webhook hook = Webhook.get(id.toLong())\n        getWebhookWithAuthAsMap(hook)\n    }\n    def getWebhookForProjectWithAuth(String id, String project) {\n        Webhook hook = getWebhookWithProject(id.toLong(), project)\n        if(!hook){\n            return null\n        }\n        getWebhookWithAuthAsMap(hook)\n    }\n\n    private Map getWebhookWithAuthAsMap(Webhook hook) {\n        AuthenticationToken authToken = rundeckAuthTokenManagerService.getToken(hook.authToken)\n        return [id:hook.id, uuid:hook.uuid, name:hook.name, project: hook.project, enabled: hook.enabled, user:authToken.ownerName, creator:authToken.creator, roles: authToken.authRolesSet().join(\",\"), authToken:hook.authToken, eventPlugin:hook.eventPlugin, config:mapper.readValue(hook.pluginConfigurationJson, HashMap)]\n    }\n\n    Webhook getWebhook(Long id) {\n        return Webhook.get(id)\n    }\n    Webhook getWebhookWithProject(Long id, String project) {\n        return Webhook.findByIdAndProject(id,project)\n    }\n\n    Webhook getWebhookByUuid(String uuid) {\n        return Webhook.findByUuid(uuid)\n    }\n\n    Webhook getWebhookByToken(String token) {\n        return Webhook.findByAuthToken(token)\n    }\n\n    class Evt extends EventImpl {}\n\n    class EvtQuery extends EventQueryImpl {}\n}\n", "/*\n * Copyright 2019 Rundeck, Inc. (http://rundeck.com)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage webhooks\n\nimport com.dtolabs.rundeck.core.authorization.AuthContextEvaluator\nimport com.dtolabs.rundeck.core.authorization.AuthContextProvider\nimport com.dtolabs.rundeck.core.authorization.SubjectAuthContext\nimport com.dtolabs.rundeck.core.authorization.UserAndRolesAuthContext\nimport com.dtolabs.rundeck.plugins.webhook.DefaultJsonWebhookResponder\nimport com.dtolabs.rundeck.plugins.webhook.DefaultWebhookResponder\nimport com.dtolabs.rundeck.plugins.webhook.WebhookDataImpl\nimport com.dtolabs.rundeck.plugins.webhook.WebhookResponder\nimport grails.testing.web.controllers.ControllerUnitTest\nimport org.rundeck.core.auth.AuthConstants\nimport spock.lang.Specification\n\nimport javax.servlet.http.HttpServletRequest\nimport javax.servlet.http.HttpServletResponse\n\n\nclass WebhookControllerSpec extends Specification implements ControllerUnitTest<WebhookController> {\n\n    def \"post\"() {\n        given:\n        controller.rundeckAuthContextProvider = Mock(AuthContextProvider)\n        controller.rundeckAuthContextEvaluator = Mock(AuthContextEvaluator)\n        controller.webhookService = Mock(MockWebhookService)\n\n        when:\n        params.authtoken = \"1234\"\n        request.method = 'POST'\n        controller.post()\n\n        then:\n        1 * controller.webhookService.getWebhookByToken(_) >> { new Webhook(name:\"test\",authToken: \"1234\")}\n        1 * controller.rundeckAuthContextProvider.getAuthContextForSubjectAndProject(_, _) >> { new SubjectAuthContext(null, null) }\n        1 * controller.rundeckAuthContextEvaluator.authorizeProjectResourceAny(_,_,_,_) >> { return true }\n        1 * controller.webhookService.processWebhook(_,_,_,_,_) >> { webhookResponder }\n        response.text == expectedMsg\n\n        where:\n        authtoken   | expectedMsg | webhookResponder\n        \"1234\"      | 'ok' | new DefaultWebhookResponder()\n        \"1234#test\" | '{\"msg\":\"ok\"}' | new DefaultJsonWebhookResponder([msg:\"ok\"])\n    }\n\n    def \"post fail when not authorized\"() {\n        given:\n\n        controller.rundeckAuthContextProvider = Mock(AuthContextProvider){\n            getAuthContextForSubject(_) >> { new SubjectAuthContext(null,null) }\n        }\n        controller.rundeckAuthContextEvaluator = Mock(AuthContextEvaluator){\n            authorizeApplicationResourceAny(_,_,_) >> { return false }\n        }\n        controller.webhookService = Mock(MockWebhookService)\n\n        when:\n        params.authtoken = \"1234\"\n        request.method = 'POST'\n        controller.post()\n\n        then:\n        1 * controller.webhookService.getWebhookByToken(_) >> { new Webhook(name:\"test\",authToken: \"1234\")}\n        0 * controller.webhookService.processWebhook(_,_,_,_)\n        response.text == '{\"err\":\"You are not authorized to perform this action\"}'\n    }\n\n    def \"remove webhook should fail when project params is not present\"() {\n        given:\n        controller.webhookService = Mock(MockWebhookService) {\n            getWebhook(_) >> new Webhook()\n        }\n\n        controller.apiService = Mock(MockApiService)\n\n        when:\n        params.id = \"1234\"\n        controller.remove()\n\n        then:\n        1 * controller.apiService.renderErrorFormat(_,[status: HttpServletResponse.SC_BAD_REQUEST,\n                                                       code: 'api.error.parameter.required', args: ['project']])\n        0 * controller.webhookService.delete(_)\n    }\n\n    def \"get webhook should fail when project param does not match webhook project\"() {\n        given:\n            controller.webhookService = Mock(WebhookService) {\n                1 * getWebhookForProjectWithAuth('1234','otherproject')\n            }\n\n            controller.apiService = Mock(MockApiService)\n            controller.rundeckAuthContextEvaluator = Mock(AuthContextEvaluator)\n            controller.rundeckAuthContextProvider = Mock(AuthContextProvider)\n        when:\n            params.id = \"1234\"\n            params.project = 'otherproject'\n            controller.get()\n\n        then:\n            response.status==404\n            response.text == '{\"err\":\"Webhook not found\"}'\n            1 * controller.rundeckAuthContextProvider.getAuthContextForSubjectAndProject(_,'otherproject')\n            1 * controller.rundeckAuthContextEvaluator.authorizeProjectResourceAny(\n                _,\n                AuthConstants.RESOURCE_TYPE_WEBHOOK,\n                [AuthConstants.ACTION_ADMIN, AuthConstants.ACTION_READ],\n                'otherproject'\n            ) >> true\n    }\n\n    def \"503 if webhook is not enabled\"() {\n        given:\n        controller.webhookService = Mock(MockWebhookService)\n\n        when:\n        params.authtoken = \"1234\"\n        request.method = 'POST'\n        controller.post()\n\n        then:\n        1 * controller.webhookService.getWebhookByToken(_) >> { new Webhook(name:\"test\",authToken: \"1234\",enabled:false)}\n        0 * controller.webhookService.processWebhook(_,_,_,_)\n        response.text == '{\"err\":\"Webhook not enabled\"}'\n        response.status == 503\n    }\n\n    def \"POST method is the only valid method\"() {\n        given:\n        controller.rundeckAuthContextProvider = Mock(AuthContextProvider)\n        controller.rundeckAuthContextEvaluator = Mock(AuthContextEvaluator)\n        controller.webhookService = Mock(MockWebhookService)\n\n        when:\n        params.authtoken = \"1234\"\n        request.method = method\n        controller.post()\n\n        then:\n        invocations * controller.webhookService.getWebhookByToken(_) >> { new Webhook(name:\"test\",authToken: \"1234\",enabled:true)}\n        invocations * controller.rundeckAuthContextProvider.getAuthContextForSubjectAndProject(_,_) >> { new SubjectAuthContext(null, null) }\n        invocations * controller.rundeckAuthContextEvaluator.authorizeProjectResourceAny(_,_,_,_) >> { return true }\n        invocations * controller.webhookService.processWebhook(_,_,_,_,_) >> { new DefaultWebhookResponder() }\n        response.status == statusCode\n\n        where:\n        method      | statusCode | invocations\n        'POST'      | 200        | 1\n        'GET'       | 405        | 0\n        'PUT'       | 405        | 0\n        'DELETE'    | 405        | 0\n    }\n\n    interface MockWebhookService {\n        Webhook getWebhookByToken(String token)\n        Webhook getWebhook(Long id)\n        WebhookResponder processWebhook(String pluginName, String pluginConfigJson, WebhookDataImpl data, UserAndRolesAuthContext context, HttpServletRequest request)\n    }\n\n    interface MockApiService {\n        def renderErrorFormat(HttpServletResponse response, Map data)\n    }\n}\n", "/*\n * Copyright 2019 Rundeck, Inc. (http://rundeck.com)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage webhooks\n\nimport com.dtolabs.rundeck.core.authentication.tokens.AuthTokenManager\nimport com.dtolabs.rundeck.core.authentication.tokens.AuthTokenType\nimport com.dtolabs.rundeck.core.authentication.tokens.AuthenticationToken\nimport com.dtolabs.rundeck.core.authorization.UserAndRolesAuthContext\nimport com.dtolabs.rundeck.core.config.FeatureService\nimport com.dtolabs.rundeck.core.config.Features\nimport com.dtolabs.rundeck.core.event.EventStoreService\nimport com.dtolabs.rundeck.core.plugins.ConfiguredPlugin\nimport com.dtolabs.rundeck.core.plugins.PluggableProviderService\nimport com.dtolabs.rundeck.core.plugins.PluginRegistry\nimport com.dtolabs.rundeck.core.plugins.ValidatedPlugin\nimport com.dtolabs.rundeck.core.plugins.configuration.PluginCustomConfigValidator\nimport com.dtolabs.rundeck.core.plugins.configuration.PropertyResolver\nimport com.dtolabs.rundeck.core.plugins.configuration.PropertyScope\nimport com.dtolabs.rundeck.core.plugins.configuration.Validator\nimport com.dtolabs.rundeck.core.storage.keys.KeyStorageTree\nimport com.dtolabs.rundeck.core.webhook.WebhookEventException\nimport com.dtolabs.rundeck.plugins.descriptions.PluginCustomConfig\nimport com.dtolabs.rundeck.plugins.webhook.DefaultWebhookResponder\nimport com.dtolabs.rundeck.plugins.webhook.WebhookData\nimport com.dtolabs.rundeck.plugins.webhook.WebhookDataImpl\nimport com.dtolabs.rundeck.plugins.webhook.WebhookEventContext\nimport com.dtolabs.rundeck.plugins.webhook.WebhookEventPlugin\nimport com.dtolabs.rundeck.plugins.webhook.WebhookResponder\nimport grails.testing.gorm.DataTest\nimport grails.testing.services.ServiceUnitTest\nimport org.rundeck.app.spi.AuthorizedServicesProvider\nimport org.rundeck.app.spi.Services\nimport spock.lang.Specification\nimport spock.lang.Unroll\n\nimport javax.servlet.http.HttpServletRequest\n\n\nclass WebhookServiceSpec extends Specification implements ServiceUnitTest<WebhookService>, DataTest {\n    void setupSpec() {\n        mockDomain Webhook\n    }\n\n    def \"process webhook\"() {\n        given:\n        def mockUserAuth = Mock(UserAndRolesAuthContext) {\n            getUsername() >> { \"webhookUser\" }\n            getRoles() >> { [\"webhook\",\"test\"] }\n        }\n        WebhookDataImpl data = new WebhookDataImpl()\n        data.webhook = \"testhook\"\n        data.sender = \"asender\"\n        data.contentType = \"text/plain\"\n        data.data = new ByteArrayInputStream(\"my event data\".bytes)\n        service.storageService = Mock(MockStorageService)\n\n\n        when:\n        def mockPropertyResolver = Mock(PropertyResolver)\n        def webhookProviderService = Mock(PluggableProviderService)\n\n        service.featureService = Mock(FeatureService) {\n            featurePresent(Features.EVENT_STORE) >> false\n        }\n\n        service.gormEventStoreService = Mock(EventStoreService) {\n            scoped(_,_) >> { Mock(EventStoreService) }\n        }\n\n        service.rundeckAuthorizedServicesProvider = Mock(AuthorizedServicesProvider) {\n            getServicesWith(_) >> { Mock(Services)}\n        }\n        service.frameworkService = Mock(MockFrameworkService) {\n            getFrameworkPropertyResolver(_,_) >> { mockPropertyResolver }\n        }\n        service.rundeckPluginRegistry = Mock(PluginRegistry) {\n            createPluggableService(WebhookEventPlugin) >> {\n                webhookProviderService\n            }\n        }\n\n        TestWebhookEventPlugin testPlugin = new TestWebhookEventPlugin()\n\n        service.pluginService = Mock(MockPluginService) {\n            configurePlugin(\"test-webhook-event\", _, _,_) >> { new ConfiguredPlugin<WebhookEventPlugin>(testPlugin, [:] ) }\n        }\n        def request = Mock(HttpServletRequest) {\n            getHeader(\"X-Rundeck-TestHdr\") >> { \"Hdr1\" }\n        }\n        def responder = service.processWebhook(\"test-webhook-event\",\"{}\",data,mockUserAuth,request)\n\n        then:\n        1 * service.storageService.storageTreeWithContext(_) >> Mock(KeyStorageTree)\n        testPlugin.captured.data.text==\"my event data\"\n        testPlugin.captured.headers[\"X-Rundeck-TestHdr\"] == \"Hdr1\"\n        responder instanceof DefaultWebhookResponder\n\n    }\n\n    class TestWebhookEventPlugin implements WebhookEventPlugin {\n        WebhookData captured\n\n        @Override\n        List<String> getRequestHeadersToCopy() {\n            return [\"X-Rundeck-TestHdr\"]\n        }\n\n        @Override\n        WebhookResponder onEvent(final WebhookEventContext context, final WebhookData data) throws WebhookEventException {\n            captured = data\n            return null\n        }\n    }\n\n    def \"save new webhook\"() {\n        given:\n        def mockUserAuth = Mock(UserAndRolesAuthContext) {\n            getUsername() >> { \"webhookUser\" }\n            getRoles() >> { [\"webhook\",\"test\"] }\n        }\n        service.apiService = Mock(MockApiService)\n        service.rundeckAuthTokenManagerService = Mock(AuthTokenManager) {\n            parseAuthRoles(_) >> { [\"webhook\",\"test\"] }\n        }\n        service.userService = Mock(MockUserService) {\n            validateUserExists(_) >> { true }\n        }\n        service.pluginService = Mock(MockPluginService) {\n            validatePluginConfig(_,_,_) >> { return new ValidatedPlugin(report: new Validator.Report(),valid:true) }\n            getPlugin(_,_) >> { new TestWebhookEventPlugin() }\n            listPlugins(WebhookEventPlugin) >> { [\"log-webhook-event\":new TestWebhookEventPlugin()] }\n        }\n\n        when:\n        def result = service.saveHook(mockUserAuth,[name:\"test\",project:\"Test\",user:\"webhookUser\",roles:\"webhook,test\",eventPlugin:\"log-webhook-event\",\"config\":[\"cfg1\":\"val1\"]])\n        Webhook created = Webhook.findByName(\"test\")\n\n        then:\n        result == [msg:\"Saved webhook\"]\n        created.name == \"test\"\n        created.project == \"Test\"\n        created.enabled == true\n        created.eventPlugin == \"log-webhook-event\"\n        created.pluginConfigurationJson == '{\"cfg1\":\"val1\"}'\n        1 * service.apiService.generateUserToken(_,_,_,_,_,_) >> { [token:\"12345\"] }\n\n    }\n    def \"save new webhook validation fails\"() {\n        given:\n        def mockUserAuth = Mock(UserAndRolesAuthContext) {\n            getUsername() >> { \"webhookUser\" }\n            getRoles() >> { [\"webhook\",\"test\"] }\n        }\n        service.apiService = Mock(MockApiService)\n        service.rundeckAuthTokenManagerService = Mock(AuthTokenManager) {\n            parseAuthRoles(_) >> { [\"webhook\",\"test\"] }\n        }\n        service.userService = Mock(MockUserService) {\n            validateUserExists(_) >> { true }\n        }\n        def report=new Validator.Report()\n        report.errors['test']='wrong'\n        service.pluginService = Mock(MockPluginService) {\n            validatePluginConfig(_,_,_) >> { return new ValidatedPlugin(report: report,valid:false) }\n            getPlugin(_,_) >> { new TestWebhookEventPlugin() }\n            listPlugins(WebhookEventPlugin) >> { [\"log-webhook-event\":new TestWebhookEventPlugin()] }\n        }\n\n        when:\n        def result = service.saveHook(mockUserAuth,[name:\"test\",project:\"Test\",user:\"webhookUser\",roles:\"webhook,test\",eventPlugin:\"log-webhook-event\",\"config\":[\"cfg1\":\"val1\"]])\n        Webhook created = Webhook.findByName(\"test\")\n\n        then:\n        result.err ==~ /^Invalid plugin configuration.*/\n        result.errors==[test:'wrong']\n        !created\n        0 * service.apiService.generateUserToken(_,_,_,_,_,_)\n\n    }\n    def \"save new webhook token creation fails\"() {\n        given:\n        def mockUserAuth = Mock(UserAndRolesAuthContext) {\n            getUsername() >> { \"webhookUser\" }\n            getRoles() >> { [\"webhook\",\"test\"] }\n        }\n        service.apiService = Mock(MockApiService){\n            generateUserToken(_,_,_,_,_,_)>>{\n                throw new Exception(\"token error\")\n            }\n        }\n        service.rundeckAuthTokenManagerService = Mock(AuthTokenManager) {\n            parseAuthRoles(_) >> { [\"webhook\",\"test\"] }\n        }\n        service.userService = Mock(MockUserService) {\n            validateUserExists(_) >> { true }\n        }\n        def report=new Validator.Report()\n        service.pluginService = Mock(MockPluginService) {\n            validatePluginConfig(_,_,_) >> { return new ValidatedPlugin(report: report,valid:true) }\n            getPlugin(_,_) >> { new TestWebhookEventPlugin() }\n            listPlugins(WebhookEventPlugin) >> { [\"log-webhook-event\":new TestWebhookEventPlugin()] }\n        }\n\n        when:\n        def result = service.saveHook(mockUserAuth,[name:\"test\",project:\"Test\",user:\"webhookUser\",roles:\"webhook,test\",eventPlugin:\"log-webhook-event\",\"config\":[\"cfg1\":\"val1\"]])\n        Webhook created = Webhook.findByName(\"test\")\n\n        then:\n        result.err ==~ /^Failed to create associated Auth Token: token error$/\n        !created\n    }\n    def \"save new webhook token creation unauthorized\"() {\n        given:\n            Webhook existing = new Webhook(name:\"test\",project: \"Test\",authToken: \"12345\",eventPlugin: \"log-webhook-event\")\n            existing.save()\n\n            def mockUserAuth = Mock(UserAndRolesAuthContext) {\n                getUsername() >> { \"webhookUser\" }\n                getRoles() >> { [\"webhook\",\"test\"] }\n            }\n            service.apiService = Mock(MockApiService){\n                generateUserToken(_,_,_,_,_,_)>>{\n\n                }\n            }\n            service.rundeckAuthTokenManagerService = Mock(AuthTokenManager) {\n                parseAuthRoles(_) >> { [\"webhook\",\"test\",\"bogus\"] }\n                updateAuthRoles(_,_,_)>>{\n                    throw new Exception(\"Unauthorized to update roles\")\n                }\n            }\n            service.userService = Mock(MockUserService) {\n                validateUserExists(_) >> { true }\n            }\n            def report=new Validator.Report()\n            service.pluginService = Mock(MockPluginService) {\n                validatePluginConfig(_,_,_) >> { return new ValidatedPlugin(report: report,valid:true) }\n                getPlugin(_,_) >> { new TestWebhookEventPlugin() }\n                listPlugins(WebhookEventPlugin) >> { [\"log-webhook-event\":new TestWebhookEventPlugin()] }\n            }\n\n        when:\n            def result = service.saveHook(mockUserAuth,[id:existing.id,name:\"test\",project:\"Test\",user:\"webhookUser\",roles:\"webhook,test,bogus\",eventPlugin:\"log-webhook-event\",\"config\":[\"cfg1\":\"val1\"]])\n\n        then:\n            result.err ==~ /^Failed to update Auth Token roles: Unauthorized to update roles$/\n    }\n\n    def \"save new webhook fails due to gorm validation, token should get deleted\"() {\n        given:\n            def mockUserAuth = Mock(UserAndRolesAuthContext) {\n                getUsername() >> { \"webhookUser\" }\n                getRoles() >> { [\"webhook\",\"test\"] }\n            }\n            service.apiService = Mock(MockApiService)\n            service.rundeckAuthTokenManagerService = Mock(AuthTokenManager) {\n                parseAuthRoles(_) >> { [\"webhook\",\"test\"] }\n            }\n            service.userService = Mock(MockUserService) {\n                validateUserExists(_) >> { true }\n            }\n            service.pluginService = Mock(MockPluginService) {\n                validatePluginConfig(_,_,_) >> { return new ValidatedPlugin(report: new Validator.Report(),valid:true) }\n                getPlugin(_,_) >> { new TestWebhookEventPlugin() }\n                listPlugins(WebhookEventPlugin) >> { [\"log-webhook-event\":new TestWebhookEventPlugin()] }\n            }\n\n        when:\n            def result = service.saveHook(mockUserAuth,[project:\"Test\",user:\"webhookUser\",roles:\"webhook,test\",eventPlugin:\"log-webhook-event\",\"config\":[\"cfg1\":\"val1\"]])\n            Webhook created = Webhook.findByName(\"test\")\n\n\n        then:\n            result.err\n            !created\n            1 * service.apiService.generateUserToken(_,_,_,_,_,_) >> { [token:\"12345\"] }\n            1 * service.rundeckAuthTokenManagerService.deleteToken('12345')\n\n    }\n    def \"webhook name must be unique in project\"() {\n        given:\n        def mockUserAuth = Mock(UserAndRolesAuthContext) {\n            getUsername() >> { \"webhookUser\" }\n            getRoles() >> { [\"webhook\",\"test\"] }\n        }\n        Webhook existing = new Webhook(name:\"test\",project: \"Test\",authToken: \"12345\",eventPlugin: \"log-webhook-event\")\n        existing.save()\n\n        when:\n        def result = service.saveHook(mockUserAuth,[name:\"test\",project:\"Test\",user:\"webhookUser\",roles:\"webhook,test\",eventPlugin:\"log-webhook-event\",\"config\":[\"cfg1\":\"val1\"]])\n\n        then:\n        result == [err:\"A Webhook by that name already exists in this project\"]\n\n    }\n\n    @Unroll\n    def \"validate plugin config - custom validator\"() {\n        given:\n        CustomConfigWebhookEventPlugin customPlugin = new CustomConfigWebhookEventPlugin()\n\n        service.pluginService = Mock(MockPluginService) {\n            validatePluginConfig(_,_,_) >> { return new ValidatedPlugin(report: new Validator.Report(),valid: true) }\n            getPlugin(_,_) >> { customPlugin }\n        }\n\n        when:\n        Tuple2<ValidatedPlugin,Boolean> vPlugin = service.validatePluginConfig(\"custom-cfg-webhook-event\",config)\n\n        then:\n        vPlugin.first.valid == valid\n        vPlugin.first.report.errors == errors\n\n\n        where:\n        valid | config                  | errors\n        false | [:]                     | [\"requiredProp\":\"requiredProp is required\"]\n        true  | [requiredProp:\"value\"]  | [:]\n    }\n\n    static class CustomConfigWebhookEventPlugin implements WebhookEventPlugin {\n        WebhookData captured\n\n        @PluginCustomConfig(validator = TestCustomValidator)\n        Map config\n\n        @Override\n        WebhookResponder onEvent(final WebhookEventContext context, final WebhookData data) throws WebhookEventException {\n            captured = data\n            return new DefaultWebhookResponder()\n        }\n    }\n\n    static class TestCustomValidator implements PluginCustomConfigValidator {\n\n        @Override\n        Validator.Report validate(final Map config) {\n            Validator.Report report = new Validator.Report()\n            if(!config.requiredProp) report.errors[\"requiredProp\"] = \"requiredProp is required\"\n            return report\n        }\n    }\n\n\n    def \"ReplaceSecureOpts\"() {\n        given:\n        def mockUserAuth = Mock(UserAndRolesAuthContext) {\n            getUsername() >> { \"webhookUser\" }\n            getRoles() >> { [\"webhook\",\"test\"] }\n        }\n        when:\n        def config = [:]\n        config.prop1 = \"my value\"\n        config.prop2 = '${KS:keys/proj1/sval}'\n        config.prop3 = [\n                prop1: 'foo',\n                prop2: '${KS:keys/proj1/sval}'\n        ]\n        config.prop4 = [\n                'foo',\n                '${KS:keys/proj1/sval}'\n        ]\n\n        config.prop5 = '${KS:keys/proj1/sval} ${KS:keys/proj1/sval2}'\n\n        def mockStorageTree = Mock(MockStorageTree) {\n            hasPassword(_) >> { true }\n            readPassword(\"keys/proj1/sval\") >> { \"password\".bytes }\n            readPassword(\"keys/proj1/sval2\") >> { \"other\".bytes }\n        }\n        service.storageService = Mock(MockStorageService) {\n            storageTreeWithContext(_) >> { mockStorageTree }\n        }\n        service.replaceSecureOpts(mockUserAuth,config)\n\n        then:\n        config.prop1 == \"my value\"\n        config.prop2 == \"password\"\n        config.prop3['prop2'] == \"password\"\n        config.prop4[1] == \"password\"\n        config.prop5 == \"password other\"\n\n    }\n\n    @Unroll\n    def \"import webhooks regenAuthToken: #regenFlag\"() {\n        given:\n        service.pluginService = Mock(MockPluginService) {\n            listPlugins(_) >> { [\"log-webhook-event\":new Object()]}\n        }\n        service.rundeckAuthTokenManagerService = Mock(AuthTokenManager)\n        def authContext = Mock(UserAndRolesAuthContext) {\n            getUsername() >> { \"admin\" }\n        }\n        service.apiService = Mock(MockApiService)\n        service.metaClass.validatePluginConfig = { String plugin, Map config -> new Tuple2<ValidatedPlugin, Boolean>(new ValidatedPlugin(valid: true),false)}\n\n        when:\n        def result = service.importWebhook(authContext,[name:\"test\",\n                                            uuid: \"0dfb6080-935e-413d-a6a7-cdee9345cf72\",\n                                            project:\"Test\", authToken:'abc123', user:'webhookUser', roles:\"webhook,test\",\n                                            eventPlugin:\"log-webhook-event\",\n                                            config:'{}'],regenFlag)\n        Webhook created = Webhook.findByName(\"test\")\n\n        then:\n        result == [msg:\"Webhook test imported\"]\n        created.name == \"test\"\n        created.project == \"Test\"\n        created.eventPlugin == \"log-webhook-event\"\n        created.pluginConfigurationJson == '{}'\n        1 * service.rundeckAuthTokenManagerService.parseAuthRoles(\"webhook,test\") >> { new HashSet(['webhook','test']) }\n        expectGenTokenCall * service.apiService.generateUserToken(_,_,_,_,_,_) >> { [token:\"12345\"] }\n        expectImportWhkToken * service.rundeckAuthTokenManagerService.importWebhookToken(authContext,'abc123','webhookUser',new HashSet(['webhook','test'])) >> { true }\n\n        where:\n        regenFlag | expectGenTokenCall | expectImportWhkToken\n        true        |                1 |                    0\n        false       |                0 |                    1\n    }\n\n    def \"import is allowed\"() {\n        given:\n        service.rundeckAuthTokenManagerService=Mock(AuthTokenManager)\n        when:\n        boolean res = service.importIsAllowed(hook,hookData)\n\n        then:\n        res == expected\n\n        where:\n        expected | hook | hookData\n        true     | new Webhook(name: \"hk1\", authToken: \"12345\") | [authToken:\"12345\"]\n        true     | new Webhook(name: \"hk1\") | [authToken:\"12345\"]\n    }\n\n    def \"import is not allowed\"() {\n        setup:\n        new Webhook(name:\"preexisting\",authToken: \"12345\",project:\"one\",eventPlugin: \"plugin\").save()\n\n        when:\n\n        Webhook hook = new Webhook(name:\"new\")\n        def hookData = [authToken:\"12345\"]\n        boolean res = service.importIsAllowed(hook,hookData)\n\n        then:\n        !res\n    }\n\n    def \"getWebhookWithAuth\"() {\n        setup:\n        Webhook hook = new Webhook()\n        hook.name = \"hit\"\n        hook.project = \"One\"\n        hook.authToken = \"abc123\"\n        hook.eventPlugin = \"do-some-action\"\n        hook.pluginConfigurationJson = '{\"prop1\":\"true\"}'\n        hook.save()\n\n        service.rundeckAuthTokenManagerService = Mock(AuthTokenManager) {\n            getToken(\"abc123\") >> { new TestAuthenticationToken(token:\"abc123\",\n                                                                creator:\"admin\",\n                                                                authRoles:[\"webhook,role1\"] as Set,\n                                                                ownerName:\"webhook\") }\n\n        }\n\n        when:\n        def output = service.getWebhookWithAuth(hook.id.toString())\n\n        then:\n        output.id == hook.id\n        output.name == \"hit\"\n        output.project == \"One\"\n        output.eventPlugin == \"do-some-action\"\n        output.config == [\"prop1\":\"true\"]\n        output.user == \"webhook\"\n        output.creator == \"admin\"\n        output.roles == \"webhook,role1\"\n        output.authToken == \"abc123\"\n    }\n\n    def \"getWebhookForProjectWithAuth returns null for wrong project\"() {\n        setup:\n            def project = 'aproject'\n            Webhook hook = new Webhook()\n            hook.name = \"hit\"\n            hook.project = \"otherproject\"\n            hook.authToken = \"abc123\"\n            hook.eventPlugin = \"do-some-action\"\n            hook.pluginConfigurationJson = '{\"prop1\":\"true\"}'\n            hook.save()\n\n            service.rundeckAuthTokenManagerService = Mock(AuthTokenManager)\n\n        when:\n            def output = service.getWebhookForProjectWithAuth(hook.id.toString(), project)\n\n        then:\n            output == null\n            0 * service.rundeckAuthTokenManagerService.getToken(\"abc123\")\n    }\n\n    def \"delete all webhooks in project\"() {\n        setup:\n        String project = \"prj1\"\n        new Webhook(name:\"hook1\",project:project,authToken: \"123\",eventPlugin: \"plugin\").save()\n        new Webhook(name:\"hook2\",project:project,authToken: \"123\",eventPlugin: \"plugin\").save()\n        new Webhook(name:\"hook3\",project:\"prj2\",authToken: \"123\",eventPlugin: \"plugin\").save()\n        new Webhook(name:\"hook4\",project:\"prj3\",authToken: \"123\",eventPlugin: \"plugin\").save()\n\n        when:\n        int beforeCount = Webhook.count()\n        service.deleteWebhooksForProject(project)\n        int afterCount = Webhook.count()\n\n        then:\n        beforeCount == 4\n        afterCount == 2\n        Webhook.countByProject(project) == 0\n    }\n\n    interface MockUserService {\n        boolean validateUserExists(String user)\n    }\n\n    interface MockFrameworkService {\n        PropertyResolver getFrameworkPropertyResolver(String project, Map config)\n    }\n\n    interface MockPluginService {\n        ConfiguredPlugin configurePlugin(String pluginName, Class serviceClass, PropertyResolver resolver, PropertyScope scope)\n        ValidatedPlugin validatePluginConfig(String service, String pluginName, Map config)\n        WebhookEventPlugin getPlugin(String service, Class pluginClass)\n        Map listPlugins(Class pluginClass)\n    }\n\n    interface MockApiService {\n        Map generateUserToken(UserAndRolesAuthContext ctx, Integer expiration, String user, Set<String> roles, boolean forceExpiration, AuthTokenType tokenType) throws Exception\n    }\n\n    interface MockStorageService {\n        Object storageTreeWithContext(Object obj)\n    }\n    interface MockStorageTree {\n        boolean hasPassword(String path)\n        byte[] readPassword(String path)\n    }\n\n    class TestAuthenticationToken implements AuthenticationToken {\n\n        String token\n        Set<String> authRoles\n        String uuid\n        String creator\n        String ownerName\n\n        @Override\n        Set<String> authRolesSet() {\n            return authRoles\n        }\n\n        @Override\n        AuthTokenType getType() {\n            return AuthTokenType.WEBHOOK\n        }\n\n        @Override\n        String getPrintableToken() {\n            return token\n        }\n\n        @Override\n        Date getExpiration() {\n            return null\n        }\n\n        @Override\n        String getName() {\n            return null\n        }\n    }\n}\n"], "filenames": ["grails-webhooks/grails-app/controllers/webhooks/WebhookController.groovy", "grails-webhooks/grails-app/services/webhooks/WebhookService.groovy", "grails-webhooks/src/test/groovy/webhooks/WebhookControllerSpec.groovy", "grails-webhooks/src/test/groovy/webhooks/WebhookServiceSpec.groovy"], "buggy_code_start_loc": [91, 292, 26, 496], "buggy_code_end_loc": [92, 301, 98, 496], "fixing_code_start_loc": [91, 293, 27, 497], "fixing_code_end_loc": [96, 312, 126, 518], "type": "CWE-639", "message": "Rundeck is an open source automation service with a web console, command line tools and a WebAPI. Prior to versions 3.4.5 and 3.3.15, an authenticated user with authorization to read webhooks in one project can craft a request to reveal Webhook definitions and tokens in another project. The user could use the revealed webhook tokens to trigger webhooks. Severity depends on trust level of authenticated users and whether any webhooks exist that trigger sensitive actions. There are patches for this vulnerability in versions 3.4.5 and 3.3.15. There are currently no known workarounds.", "other": {"cve": {"id": "CVE-2021-41111", "sourceIdentifier": "security-advisories@github.com", "published": "2022-02-28T20:15:08.160", "lastModified": "2022-03-10T16:51:07.187", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Rundeck is an open source automation service with a web console, command line tools and a WebAPI. Prior to versions 3.4.5 and 3.3.15, an authenticated user with authorization to read webhooks in one project can craft a request to reveal Webhook definitions and tokens in another project. The user could use the revealed webhook tokens to trigger webhooks. Severity depends on trust level of authenticated users and whether any webhooks exist that trigger sensitive actions. There are patches for this vulnerability in versions 3.4.5 and 3.3.15. There are currently no known workarounds."}, {"lang": "es", "value": "Rundeck es un servicio de automatizaci\u00f3n de c\u00f3digo abierto con una consola web, herramientas de l\u00ednea de comandos y una WebAPI. En versiones anteriores a 3.4.5 y 3.3.15, un usuario autenticado con autorizaci\u00f3n para leer webhooks en un proyecto pod\u00eda dise\u00f1ar una petici\u00f3n para revelar definiciones y tokens de webhooks en otro proyecto. El usuario podr\u00eda usar los tokens de webhooks revelados para desencadenar los webhooks. La gravedad depende del nivel confiable de usuarios autenticados y de que se presenten webhooks que desencadenen acciones confidenciales. Se presentan parches para esta vulnerabilidad en las versiones 3.4.5 y 3.3.15. Actualmente no se presentan medidas de mitigaci\u00f3n conocidas.\n"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.5}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.1, "impactScore": 2.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.5}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-639"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:pagerduty:rundeck:*:*:*:*:-:*:*:*", "versionEndExcluding": "3.3.15", "matchCriteriaId": "FA2AAF8D-05A6-442F-BDBF-F83D4F3D6D67"}, {"vulnerable": true, "criteria": "cpe:2.3:a:pagerduty:rundeck:*:*:*:*:-:*:*:*", "versionStartIncluding": "3.4.0", "versionEndExcluding": "3.4.5", "matchCriteriaId": "E121D06A-74E9-4CFC-9AE9-53CDD266CA43"}]}]}], "references": [{"url": "https://github.com/rundeck/rundeck/commit/a3bdc06a0731da902593732022a5b9d2b4facec5", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/rundeck/rundeck/security/advisories/GHSA-mfqj-f22m-gv8j", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/rundeck/rundeck/commit/a3bdc06a0731da902593732022a5b9d2b4facec5"}}