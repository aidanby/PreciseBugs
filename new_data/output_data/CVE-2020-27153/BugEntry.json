{"buggy_code": ["/*\n *\n *  BlueZ - Bluetooth protocol stack for Linux\n *\n *  Copyright (C) 2014  Google Inc.\n *\n *\n *  This library is free software; you can redistribute it and/or\n *  modify it under the terms of the GNU Lesser General Public\n *  License as published by the Free Software Foundation; either\n *  version 2.1 of the License, or (at your option) any later version.\n *\n *  This library is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n *  Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; if not, write to the Free Software\n *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n *\n */\n\n#ifdef HAVE_CONFIG_H\n#include <config.h>\n#endif\n\n#include <stdlib.h>\n#include <unistd.h>\n#include <errno.h>\n\n#include \"src/shared/io.h\"\n#include \"src/shared/queue.h\"\n#include \"src/shared/util.h\"\n#include \"src/shared/timeout.h\"\n#include \"lib/bluetooth.h\"\n#include \"lib/l2cap.h\"\n#include \"lib/uuid.h\"\n#include \"src/shared/att.h\"\n#include \"src/shared/crypto.h\"\n\n#define ATT_MIN_PDU_LEN\t\t\t1  /* At least 1 byte for the opcode. */\n#define ATT_OP_CMD_MASK\t\t\t0x40\n#define ATT_OP_SIGNED_MASK\t\t0x80\n#define ATT_TIMEOUT_INTERVAL\t\t30000  /* 30000 ms */\n\n/* Length of signature in write signed packet */\n#define BT_ATT_SIGNATURE_LEN\t\t12\n\nstruct att_send_op;\n\nstruct bt_att_chan {\n\tstruct bt_att *att;\n\tint fd;\n\tstruct io *io;\n\tuint8_t type;\n\tint sec_level;\t\t\t/* Only used for non-L2CAP */\n\n\tstruct queue *queue;\t\t/* Channel dedicated queue */\n\n\tstruct att_send_op *pending_req;\n\tstruct att_send_op *pending_ind;\n\tbool writer_active;\n\n\tbool in_req;\t\t\t/* There's a pending incoming request */\n\n\tuint8_t *buf;\n\tuint16_t mtu;\n};\n\nstruct bt_att {\n\tint ref_count;\n\tbool close_on_unref;\n\tstruct queue *chans;\n\tuint8_t enc_size;\n\tuint16_t mtu;\t\t\t/* Biggest possible MTU */\n\n\tstruct queue *notify_list;\t/* List of registered callbacks */\n\tstruct queue *disconn_list;\t/* List of disconnect handlers */\n\n\tunsigned int next_send_id;\t/* IDs for \"send\" ops */\n\tunsigned int next_reg_id;\t/* IDs for registered callbacks */\n\n\tstruct queue *req_queue;\t/* Queued ATT protocol requests */\n\tstruct queue *ind_queue;\t/* Queued ATT protocol indications */\n\tstruct queue *write_queue;\t/* Queue of PDUs ready to send */\n\n\tbt_att_timeout_func_t timeout_callback;\n\tbt_att_destroy_func_t timeout_destroy;\n\tvoid *timeout_data;\n\n\tbt_att_debug_func_t debug_callback;\n\tbt_att_destroy_func_t debug_destroy;\n\tvoid *debug_data;\n\n\tstruct bt_crypto *crypto;\n\n\tstruct sign_info *local_sign;\n\tstruct sign_info *remote_sign;\n};\n\nstruct sign_info {\n\tuint8_t key[16];\n\tbt_att_counter_func_t counter;\n\tvoid *user_data;\n};\n\nenum att_op_type {\n\tATT_OP_TYPE_REQ,\n\tATT_OP_TYPE_RSP,\n\tATT_OP_TYPE_CMD,\n\tATT_OP_TYPE_IND,\n\tATT_OP_TYPE_NFY,\n\tATT_OP_TYPE_CONF,\n\tATT_OP_TYPE_UNKNOWN,\n};\n\nstatic const struct {\n\tuint8_t opcode;\n\tenum att_op_type type;\n} att_opcode_type_table[] = {\n\t{ BT_ATT_OP_ERROR_RSP,\t\t\tATT_OP_TYPE_RSP },\n\t{ BT_ATT_OP_MTU_REQ,\t\t\tATT_OP_TYPE_REQ },\n\t{ BT_ATT_OP_MTU_RSP,\t\t\tATT_OP_TYPE_RSP },\n\t{ BT_ATT_OP_FIND_INFO_REQ,\t\tATT_OP_TYPE_REQ },\n\t{ BT_ATT_OP_FIND_INFO_RSP,\t\tATT_OP_TYPE_RSP },\n\t{ BT_ATT_OP_FIND_BY_TYPE_REQ,\t\tATT_OP_TYPE_REQ },\n\t{ BT_ATT_OP_FIND_BY_TYPE_RSP,\t\tATT_OP_TYPE_RSP },\n\t{ BT_ATT_OP_READ_BY_TYPE_REQ,\t\tATT_OP_TYPE_REQ },\n\t{ BT_ATT_OP_READ_BY_TYPE_RSP,\t\tATT_OP_TYPE_RSP },\n\t{ BT_ATT_OP_READ_REQ,\t\t\tATT_OP_TYPE_REQ },\n\t{ BT_ATT_OP_READ_RSP,\t\t\tATT_OP_TYPE_RSP },\n\t{ BT_ATT_OP_READ_BLOB_REQ,\t\tATT_OP_TYPE_REQ },\n\t{ BT_ATT_OP_READ_BLOB_RSP,\t\tATT_OP_TYPE_RSP },\n\t{ BT_ATT_OP_READ_MULT_REQ,\t\tATT_OP_TYPE_REQ },\n\t{ BT_ATT_OP_READ_MULT_RSP,\t\tATT_OP_TYPE_RSP },\n\t{ BT_ATT_OP_READ_BY_GRP_TYPE_REQ,\tATT_OP_TYPE_REQ },\n\t{ BT_ATT_OP_READ_BY_GRP_TYPE_RSP,\tATT_OP_TYPE_RSP },\n\t{ BT_ATT_OP_WRITE_REQ,\t\t\tATT_OP_TYPE_REQ },\n\t{ BT_ATT_OP_WRITE_RSP,\t\t\tATT_OP_TYPE_RSP },\n\t{ BT_ATT_OP_WRITE_CMD,\t\t\tATT_OP_TYPE_CMD },\n\t{ BT_ATT_OP_SIGNED_WRITE_CMD,\t\tATT_OP_TYPE_CMD },\n\t{ BT_ATT_OP_PREP_WRITE_REQ,\t\tATT_OP_TYPE_REQ },\n\t{ BT_ATT_OP_PREP_WRITE_RSP,\t\tATT_OP_TYPE_RSP },\n\t{ BT_ATT_OP_EXEC_WRITE_REQ,\t\tATT_OP_TYPE_REQ },\n\t{ BT_ATT_OP_EXEC_WRITE_RSP,\t\tATT_OP_TYPE_RSP },\n\t{ BT_ATT_OP_HANDLE_NFY,\t\t\tATT_OP_TYPE_NFY },\n\t{ BT_ATT_OP_HANDLE_NFY_MULT,\t\tATT_OP_TYPE_NFY },\n\t{ BT_ATT_OP_HANDLE_IND,\t\t\tATT_OP_TYPE_IND },\n\t{ BT_ATT_OP_HANDLE_CONF,\t\tATT_OP_TYPE_CONF },\n\t{ }\n};\n\nstatic enum att_op_type get_op_type(uint8_t opcode)\n{\n\tint i;\n\n\tfor (i = 0; att_opcode_type_table[i].opcode; i++) {\n\t\tif (att_opcode_type_table[i].opcode == opcode)\n\t\t\treturn att_opcode_type_table[i].type;\n\t}\n\n\tif (opcode & ATT_OP_CMD_MASK)\n\t\treturn ATT_OP_TYPE_CMD;\n\n\treturn ATT_OP_TYPE_UNKNOWN;\n}\n\nstatic const struct {\n\tuint8_t req_opcode;\n\tuint8_t rsp_opcode;\n} att_req_rsp_mapping_table[] = {\n\t{ BT_ATT_OP_MTU_REQ,\t\t\tBT_ATT_OP_MTU_RSP },\n\t{ BT_ATT_OP_FIND_INFO_REQ,\t\tBT_ATT_OP_FIND_INFO_RSP},\n\t{ BT_ATT_OP_FIND_BY_TYPE_REQ,\t\tBT_ATT_OP_FIND_BY_TYPE_RSP },\n\t{ BT_ATT_OP_READ_BY_TYPE_REQ,\t\tBT_ATT_OP_READ_BY_TYPE_RSP },\n\t{ BT_ATT_OP_READ_REQ,\t\t\tBT_ATT_OP_READ_RSP },\n\t{ BT_ATT_OP_READ_BLOB_REQ,\t\tBT_ATT_OP_READ_BLOB_RSP },\n\t{ BT_ATT_OP_READ_MULT_REQ,\t\tBT_ATT_OP_READ_MULT_RSP },\n\t{ BT_ATT_OP_READ_BY_GRP_TYPE_REQ,\tBT_ATT_OP_READ_BY_GRP_TYPE_RSP },\n\t{ BT_ATT_OP_WRITE_REQ,\t\t\tBT_ATT_OP_WRITE_RSP },\n\t{ BT_ATT_OP_PREP_WRITE_REQ,\t\tBT_ATT_OP_PREP_WRITE_RSP },\n\t{ BT_ATT_OP_EXEC_WRITE_REQ,\t\tBT_ATT_OP_EXEC_WRITE_RSP },\n\t{ }\n};\n\nstatic uint8_t get_req_opcode(uint8_t rsp_opcode)\n{\n\tint i;\n\n\tfor (i = 0; att_req_rsp_mapping_table[i].rsp_opcode; i++) {\n\t\tif (att_req_rsp_mapping_table[i].rsp_opcode == rsp_opcode)\n\t\t\treturn att_req_rsp_mapping_table[i].req_opcode;\n\t}\n\n\treturn 0;\n}\n\nstruct att_send_op {\n\tunsigned int id;\n\tunsigned int timeout_id;\n\tenum att_op_type type;\n\tuint8_t opcode;\n\tvoid *pdu;\n\tuint16_t len;\n\tbt_att_response_func_t callback;\n\tbt_att_destroy_func_t destroy;\n\tvoid *user_data;\n};\n\nstatic void destroy_att_send_op(void *data)\n{\n\tstruct att_send_op *op = data;\n\n\tif (op->timeout_id)\n\t\ttimeout_remove(op->timeout_id);\n\n\tif (op->destroy)\n\t\top->destroy(op->user_data);\n\n\tfree(op->pdu);\n\tfree(op);\n}\n\nstatic void cancel_att_send_op(struct att_send_op *op)\n{\n\tif (op->destroy)\n\t\top->destroy(op->user_data);\n\n\top->user_data = NULL;\n\top->callback = NULL;\n\top->destroy = NULL;\n}\n\nstruct att_notify {\n\tunsigned int id;\n\tuint16_t opcode;\n\tbt_att_notify_func_t callback;\n\tbt_att_destroy_func_t destroy;\n\tvoid *user_data;\n};\n\nstatic void destroy_att_notify(void *data)\n{\n\tstruct att_notify *notify = data;\n\n\tif (notify->destroy)\n\t\tnotify->destroy(notify->user_data);\n\n\tfree(notify);\n}\n\nstatic bool match_notify_id(const void *a, const void *b)\n{\n\tconst struct att_notify *notify = a;\n\tunsigned int id = PTR_TO_UINT(b);\n\n\treturn notify->id == id;\n}\n\nstruct att_disconn {\n\tunsigned int id;\n\tbool removed;\n\tbt_att_disconnect_func_t callback;\n\tbt_att_destroy_func_t destroy;\n\tvoid *user_data;\n};\n\nstatic void destroy_att_disconn(void *data)\n{\n\tstruct att_disconn *disconn = data;\n\n\tif (disconn->destroy)\n\t\tdisconn->destroy(disconn->user_data);\n\n\tfree(disconn);\n}\n\nstatic bool match_disconn_id(const void *a, const void *b)\n{\n\tconst struct att_disconn *disconn = a;\n\tunsigned int id = PTR_TO_UINT(b);\n\n\treturn disconn->id == id;\n}\n\nstatic bool encode_pdu(struct bt_att *att, struct att_send_op *op,\n\t\t\t\t\tconst void *pdu, uint16_t length)\n{\n\tuint16_t pdu_len = 1;\n\tstruct sign_info *sign = att->local_sign;\n\tuint32_t sign_cnt;\n\n\tif (sign && (op->opcode & ATT_OP_SIGNED_MASK))\n\t\tpdu_len += BT_ATT_SIGNATURE_LEN;\n\n\tif (length && pdu)\n\t\tpdu_len += length;\n\n\tif (pdu_len > att->mtu)\n\t\treturn false;\n\n\top->len = pdu_len;\n\top->pdu = malloc(op->len);\n\tif (!op->pdu)\n\t\treturn false;\n\n\t((uint8_t *) op->pdu)[0] = op->opcode;\n\tif (pdu_len > 1)\n\t\tmemcpy(op->pdu + 1, pdu, length);\n\n\tif (!sign || !(op->opcode & ATT_OP_SIGNED_MASK) || !att->crypto)\n\t\treturn true;\n\n\tif (!sign->counter(&sign_cnt, sign->user_data))\n\t\tgoto fail;\n\n\tif ((bt_crypto_sign_att(att->crypto, sign->key, op->pdu, 1 + length,\n\t\t\t\tsign_cnt, &((uint8_t *) op->pdu)[1 + length])))\n\t\treturn true;\n\n\tutil_debug(att->debug_callback, att->debug_data,\n\t\t\t\t\t\"ATT unable to generate signature\");\n\nfail:\n\tfree(op->pdu);\n\treturn false;\n}\n\nstatic struct att_send_op *create_att_send_op(struct bt_att *att,\n\t\t\t\t\t\tuint8_t opcode,\n\t\t\t\t\t\tconst void *pdu,\n\t\t\t\t\t\tuint16_t length,\n\t\t\t\t\t\tbt_att_response_func_t callback,\n\t\t\t\t\t\tvoid *user_data,\n\t\t\t\t\t\tbt_att_destroy_func_t destroy)\n{\n\tstruct att_send_op *op;\n\tenum att_op_type type;\n\n\tif (length && !pdu)\n\t\treturn NULL;\n\n\ttype = get_op_type(opcode);\n\tif (type == ATT_OP_TYPE_UNKNOWN)\n\t\treturn NULL;\n\n\t/* If the opcode corresponds to an operation type that does not elicit a\n\t * response from the remote end, then no callback should have been\n\t * provided, since it will never be called.\n\t */\n\tif (callback && type != ATT_OP_TYPE_REQ && type != ATT_OP_TYPE_IND)\n\t\treturn NULL;\n\n\t/* Similarly, if the operation does elicit a response then a callback\n\t * must be provided.\n\t */\n\tif (!callback && (type == ATT_OP_TYPE_REQ || type == ATT_OP_TYPE_IND))\n\t\treturn NULL;\n\n\top = new0(struct att_send_op, 1);\n\top->type = type;\n\top->opcode = opcode;\n\top->callback = callback;\n\top->destroy = destroy;\n\top->user_data = user_data;\n\n\tif (!encode_pdu(att, op, pdu, length)) {\n\t\tfree(op);\n\t\treturn NULL;\n\t}\n\n\treturn op;\n}\n\nstatic struct att_send_op *pick_next_send_op(struct bt_att_chan *chan)\n{\n\tstruct bt_att *att = chan->att;\n\tstruct att_send_op *op;\n\n\t/* Check if there is anything queued on the channel */\n\top = queue_pop_head(chan->queue);\n\tif (op)\n\t\treturn op;\n\n\t/* See if any operations are already in the write queue */\n\top = queue_peek_head(att->write_queue);\n\tif (op && op->len <= chan->mtu)\n\t\treturn queue_pop_head(att->write_queue);\n\n\t/* If there is no pending request, pick an operation from the\n\t * request queue.\n\t */\n\tif (!chan->pending_req) {\n\t\top = queue_peek_head(att->req_queue);\n\t\tif (op && op->len <= chan->mtu)\n\t\t\treturn queue_pop_head(att->req_queue);\n\t}\n\n\t/* There is either a request pending or no requests queued. If there is\n\t * no pending indication, pick an operation from the indication queue.\n\t */\n\tif (!chan->pending_ind) {\n\t\top = queue_peek_head(att->ind_queue);\n\t\tif (op && op->len <= chan->mtu)\n\t\t\treturn queue_pop_head(att->ind_queue);\n\t}\n\n\treturn NULL;\n}\n\nstatic void disc_att_send_op(void *data)\n{\n\tstruct att_send_op *op = data;\n\n\tif (op->callback)\n\t\top->callback(BT_ATT_OP_ERROR_RSP, NULL, 0, op->user_data);\n\n\tdestroy_att_send_op(op);\n}\n\nstruct timeout_data {\n\tstruct bt_att_chan *chan;\n\tunsigned int id;\n};\n\nstatic bool timeout_cb(void *user_data)\n{\n\tstruct timeout_data *timeout = user_data;\n\tstruct bt_att_chan *chan = timeout->chan;\n\tstruct bt_att *att = chan->att;\n\tstruct att_send_op *op = NULL;\n\n\tif (chan->pending_req && chan->pending_req->id == timeout->id) {\n\t\top = chan->pending_req;\n\t\tchan->pending_req = NULL;\n\t} else if (chan->pending_ind && chan->pending_ind->id == timeout->id) {\n\t\top = chan->pending_ind;\n\t\tchan->pending_ind = NULL;\n\t}\n\n\tif (!op)\n\t\treturn false;\n\n\tutil_debug(att->debug_callback, att->debug_data,\n\t\t\t\t\"(chan %p) Operation timed out: 0x%02x\",\n\t\t\t\tchan, op->opcode);\n\n\tif (att->timeout_callback)\n\t\tatt->timeout_callback(op->id, op->opcode, att->timeout_data);\n\n\top->timeout_id = 0;\n\tdisc_att_send_op(op);\n\n\t/*\n\t * Directly terminate the connection as required by the ATT protocol.\n\t * This should trigger an io disconnect event which will clean up the\n\t * io and notify the upper layer.\n\t */\n\tio_shutdown(chan->io);\n\n\treturn false;\n}\n\nstatic void write_watch_destroy(void *user_data)\n{\n\tstruct bt_att_chan *chan = user_data;\n\n\tchan->writer_active = false;\n}\n\nstatic ssize_t bt_att_chan_write(struct bt_att_chan *chan, uint8_t opcode,\n\t\t\t\t\tconst void *pdu, uint16_t len)\n{\n\tstruct bt_att *att = chan->att;\n\tssize_t ret;\n\tstruct iovec iov;\n\n\tiov.iov_base = (void *) pdu;\n\tiov.iov_len = len;\n\n\tutil_debug(att->debug_callback, att->debug_data,\n\t\t\t\t\t\"(chan %p) ATT op 0x%02x\",\n\t\t\t\t\tchan, opcode);\n\n\tret = io_send(chan->io, &iov, 1);\n\tif (ret < 0) {\n\t\tutil_debug(att->debug_callback, att->debug_data,\n\t\t\t\t\t\"(chan %p) write failed: %s\",\n\t\t\t\t\tchan, strerror(-ret));\n\n\t\treturn ret;\n\t}\n\n\tutil_hexdump('<', pdu, ret, att->debug_callback, att->debug_data);\n\n\treturn ret;\n}\n\nstatic bool can_write_data(struct io *io, void *user_data)\n{\n\tstruct bt_att_chan *chan = user_data;\n\tstruct att_send_op *op;\n\tstruct timeout_data *timeout;\n\n\top = pick_next_send_op(chan);\n\tif (!op)\n\t\treturn false;\n\n\tif (!bt_att_chan_write(chan, op->opcode, op->pdu, op->len)) {\n\t\tif (op->callback)\n\t\t\top->callback(BT_ATT_OP_ERROR_RSP, NULL, 0,\n\t\t\t\t\t\t\top->user_data);\n\t\tdestroy_att_send_op(op);\n\t\treturn true;\n\t}\n\n\t/* Based on the operation type, set either the pending request or the\n\t * pending indication. If it came from the write queue, then there is\n\t * no need to keep it around.\n\t */\n\tswitch (op->type) {\n\tcase ATT_OP_TYPE_REQ:\n\t\tchan->pending_req = op;\n\t\tbreak;\n\tcase ATT_OP_TYPE_IND:\n\t\tchan->pending_ind = op;\n\t\tbreak;\n\tcase ATT_OP_TYPE_RSP:\n\t\t/* Set in_req to false to indicate that no request is pending */\n\t\tchan->in_req = false;\n\t\t/* fall through */\n\tcase ATT_OP_TYPE_CMD:\n\tcase ATT_OP_TYPE_NFY:\n\tcase ATT_OP_TYPE_CONF:\n\tcase ATT_OP_TYPE_UNKNOWN:\n\tdefault:\n\t\tdestroy_att_send_op(op);\n\t\treturn true;\n\t}\n\n\ttimeout = new0(struct timeout_data, 1);\n\ttimeout->chan = chan;\n\ttimeout->id = op->id;\n\top->timeout_id = timeout_add(ATT_TIMEOUT_INTERVAL, timeout_cb,\n\t\t\t\t\t\t\t\ttimeout, free);\n\n\t/* Return true as there may be more operations ready to write. */\n\treturn true;\n}\n\nstatic void wakeup_chan_writer(void *data, void *user_data)\n{\n\tstruct bt_att_chan *chan = data;\n\tstruct bt_att *att = chan->att;\n\n\tif (chan->writer_active)\n\t\treturn;\n\n\t/* Set the write handler only if there is anything that can be sent\n\t * at all.\n\t */\n\tif (queue_isempty(chan->queue) && queue_isempty(att->write_queue)) {\n\t\tif ((chan->pending_req || queue_isempty(att->req_queue)) &&\n\t\t\t(chan->pending_ind || queue_isempty(att->ind_queue)))\n\t\t\treturn;\n\t}\n\n\tif (!io_set_write_handler(chan->io, can_write_data, chan,\n\t\t\t\t\t\t\twrite_watch_destroy))\n\t\treturn;\n\n\tchan->writer_active = true;\n}\n\nstatic void wakeup_writer(struct bt_att *att)\n{\n\tqueue_foreach(att->chans, wakeup_chan_writer, NULL);\n}\n\nstatic void disconn_handler(void *data, void *user_data)\n{\n\tstruct att_disconn *disconn = data;\n\tint err = PTR_TO_INT(user_data);\n\n\tif (disconn->removed)\n\t\treturn;\n\n\tif (disconn->callback)\n\t\tdisconn->callback(err, disconn->user_data);\n}\n\nstatic void bt_att_chan_free(void *data)\n{\n\tstruct bt_att_chan *chan = data;\n\n\tif (chan->pending_req)\n\t\tdestroy_att_send_op(chan->pending_req);\n\n\tif (chan->pending_ind)\n\t\tdestroy_att_send_op(chan->pending_ind);\n\n\tqueue_destroy(chan->queue, destroy_att_send_op);\n\n\tio_destroy(chan->io);\n\n\tfree(chan->buf);\n\tfree(chan);\n}\n\nstatic bool disconnect_cb(struct io *io, void *user_data)\n{\n\tstruct bt_att_chan *chan = user_data;\n\tstruct bt_att *att = chan->att;\n\tint err;\n\tsocklen_t len;\n\n\tlen = sizeof(err);\n\n\tif (getsockopt(chan->fd, SOL_SOCKET, SO_ERROR, &err, &len) < 0) {\n\t\tutil_debug(chan->att->debug_callback, chan->att->debug_data,\n\t\t\t\t\t\"(chan %p) Failed to obtain disconnect\"\n\t\t\t\t\t\" error: %s\", chan, strerror(errno));\n\t\terr = 0;\n\t}\n\n\tutil_debug(chan->att->debug_callback, chan->att->debug_data,\n\t\t\t\t\t\"Channel %p disconnected: %s\",\n\t\t\t\t\tchan, strerror(err));\n\n\t/* Dettach channel */\n\tqueue_remove(att->chans, chan);\n\n\t/* Notify request callbacks */\n\tqueue_remove_all(att->req_queue, NULL, NULL, disc_att_send_op);\n\tqueue_remove_all(att->ind_queue, NULL, NULL, disc_att_send_op);\n\tqueue_remove_all(att->write_queue, NULL, NULL, disc_att_send_op);\n\n\tif (chan->pending_req) {\n\t\tdisc_att_send_op(chan->pending_req);\n\t\tchan->pending_req = NULL;\n\t}\n\n\tif (chan->pending_ind) {\n\t\tdisc_att_send_op(chan->pending_ind);\n\t\tchan->pending_ind = NULL;\n\t}\n\n\tbt_att_chan_free(chan);\n\n\t/* Don't run disconnect callback if there are channels left */\n\tif (!queue_isempty(att->chans))\n\t\treturn false;\n\n\tbt_att_ref(att);\n\n\tqueue_foreach(att->disconn_list, disconn_handler, INT_TO_PTR(err));\n\n\tbt_att_unregister_all(att);\n\tbt_att_unref(att);\n\n\treturn false;\n}\n\nstatic int bt_att_chan_get_security(struct bt_att_chan *chan)\n{\n\tstruct bt_security sec;\n\tsocklen_t len;\n\n\tif (chan->type == BT_ATT_LOCAL)\n\t\treturn chan->sec_level;\n\n\tmemset(&sec, 0, sizeof(sec));\n\tlen = sizeof(sec);\n\tif (getsockopt(chan->fd, SOL_BLUETOOTH, BT_SECURITY, &sec, &len) < 0)\n\t\treturn -EIO;\n\n\treturn sec.level;\n}\n\nstatic bool bt_att_chan_set_security(struct bt_att_chan *chan, int level)\n{\n\tstruct bt_security sec;\n\n\tif (chan->type == BT_ATT_LOCAL) {\n\t\tchan->sec_level = level;\n\t\treturn true;\n\t}\n\n\tmemset(&sec, 0, sizeof(sec));\n\tsec.level = level;\n\n\tif (setsockopt(chan->fd, SOL_BLUETOOTH, BT_SECURITY, &sec,\n\t\t\t\t\t\t\tsizeof(sec)) < 0)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool change_security(struct bt_att_chan *chan, uint8_t ecode)\n{\n\tint security;\n\n\tif (chan->sec_level != BT_ATT_SECURITY_AUTO)\n\t\treturn false;\n\n\tsecurity = bt_att_chan_get_security(chan);\n\n\tif (ecode == BT_ATT_ERROR_INSUFFICIENT_ENCRYPTION &&\n\t\t\t\t\tsecurity < BT_ATT_SECURITY_MEDIUM) {\n\t\tsecurity = BT_ATT_SECURITY_MEDIUM;\n\t} else if (ecode == BT_ATT_ERROR_AUTHENTICATION) {\n\t\tif (security < BT_ATT_SECURITY_MEDIUM)\n\t\t\tsecurity = BT_ATT_SECURITY_MEDIUM;\n\t\telse if (security < BT_ATT_SECURITY_HIGH)\n\t\t\tsecurity = BT_ATT_SECURITY_HIGH;\n\t\telse if (security < BT_ATT_SECURITY_FIPS)\n\t\t\tsecurity = BT_ATT_SECURITY_FIPS;\n\t\telse\n\t\t\treturn false;\n\t} else {\n\t\treturn false;\n\t}\n\n\treturn bt_att_chan_set_security(chan, security);\n}\n\nstatic bool handle_error_rsp(struct bt_att_chan *chan, uint8_t *pdu,\n\t\t\t\t\tssize_t pdu_len, uint8_t *opcode)\n{\n\tstruct bt_att *att = chan->att;\n\tconst struct bt_att_pdu_error_rsp *rsp;\n\tstruct att_send_op *op = chan->pending_req;\n\n\tif (pdu_len != sizeof(*rsp)) {\n\t\t*opcode = 0;\n\t\treturn false;\n\t}\n\n\trsp = (void *) pdu;\n\n\t*opcode = rsp->opcode;\n\n\t/* Attempt to change security */\n\tif (!change_security(chan, rsp->ecode))\n\t\treturn false;\n\n\t/* Remove timeout_id if outstanding */\n\tif (op->timeout_id) {\n\t\ttimeout_remove(op->timeout_id);\n\t\top->timeout_id = 0;\n\t}\n\n\tutil_debug(att->debug_callback, att->debug_data,\n\t\t\t\t\t\t\"(chan %p) Retrying operation \"\n\t\t\t\t\t\t\"%p\", chan, op);\n\n\tchan->pending_req = NULL;\n\n\t/* Push operation back to request queue */\n\treturn queue_push_head(att->req_queue, op);\n}\n\nstatic void handle_rsp(struct bt_att_chan *chan, uint8_t opcode, uint8_t *pdu,\n\t\t\t\t\t\t\t\tssize_t pdu_len)\n{\n\tstruct bt_att *att = chan->att;\n\tstruct att_send_op *op = chan->pending_req;\n\tuint8_t req_opcode;\n\tuint8_t rsp_opcode;\n\tuint8_t *rsp_pdu = NULL;\n\tuint16_t rsp_pdu_len = 0;\n\n\t/*\n\t * If no request is pending, then the response is unexpected. Disconnect\n\t * the bearer.\n\t */\n\tif (!op) {\n\t\tutil_debug(att->debug_callback, att->debug_data,\n\t\t\t\t\t\"(chan %p) Received unexpected ATT \"\n\t\t\t\t\t\"response\", chan);\n\t\tio_shutdown(chan->io);\n\t\treturn;\n\t}\n\n\t/*\n\t * If the received response doesn't match the pending request, or if\n\t * the request is malformed, end the current request with failure.\n\t */\n\tif (opcode == BT_ATT_OP_ERROR_RSP) {\n\t\t/* Return if error response cause a retry */\n\t\tif (handle_error_rsp(chan, pdu, pdu_len, &req_opcode)) {\n\t\t\twakeup_chan_writer(chan, NULL);\n\t\t\treturn;\n\t\t}\n\t} else if (!(req_opcode = get_req_opcode(opcode)))\n\t\tgoto fail;\n\n\tif (req_opcode != op->opcode)\n\t\tgoto fail;\n\n\trsp_opcode = opcode;\n\n\tif (pdu_len > 0) {\n\t\trsp_pdu = pdu;\n\t\trsp_pdu_len = pdu_len;\n\t}\n\n\tgoto done;\n\nfail:\n\tutil_debug(att->debug_callback, att->debug_data,\n\t\t\t\"(chan %p) Failed to handle response PDU; opcode: \"\n\t\t\t\"0x%02x\", chan, opcode);\n\n\trsp_opcode = BT_ATT_OP_ERROR_RSP;\n\ndone:\n\tif (op->callback)\n\t\top->callback(rsp_opcode, rsp_pdu, rsp_pdu_len, op->user_data);\n\n\tdestroy_att_send_op(op);\n\tchan->pending_req = NULL;\n\n\twakeup_chan_writer(chan, NULL);\n}\n\nstatic void handle_conf(struct bt_att_chan *chan, uint8_t *pdu, ssize_t pdu_len)\n{\n\tstruct bt_att *att = chan->att;\n\tstruct att_send_op *op = chan->pending_ind;\n\n\t/*\n\t * Disconnect the bearer if the confirmation is unexpected or the PDU is\n\t * invalid.\n\t */\n\tif (!op || pdu_len) {\n\t\tutil_debug(att->debug_callback, att->debug_data,\n\t\t\t\t\"(chan %p) Received unexpected/invalid ATT \"\n\t\t\t\t\"confirmation\", chan);\n\t\tio_shutdown(chan->io);\n\t\treturn;\n\t}\n\n\tif (op->callback)\n\t\top->callback(BT_ATT_OP_HANDLE_CONF, NULL, 0, op->user_data);\n\n\tdestroy_att_send_op(op);\n\tchan->pending_ind = NULL;\n\n\twakeup_chan_writer(chan, NULL);\n}\n\nstruct notify_data {\n\tuint8_t opcode;\n\tuint8_t *pdu;\n\tssize_t pdu_len;\n\tbool handler_found;\n};\n\nstatic bool opcode_match(uint8_t opcode, uint8_t test_opcode)\n{\n\tenum att_op_type op_type = get_op_type(test_opcode);\n\n\tif (opcode == BT_ATT_ALL_REQUESTS && (op_type == ATT_OP_TYPE_REQ ||\n\t\t\t\t\t\top_type == ATT_OP_TYPE_CMD))\n\t\treturn true;\n\n\treturn opcode == test_opcode;\n}\n\nstatic void respond_not_supported(struct bt_att *att, uint8_t opcode)\n{\n\tstruct bt_att_pdu_error_rsp pdu;\n\n\tpdu.opcode = opcode;\n\tpdu.handle = 0x0000;\n\tpdu.ecode = BT_ATT_ERROR_REQUEST_NOT_SUPPORTED;\n\n\tbt_att_send(att, BT_ATT_OP_ERROR_RSP, &pdu, sizeof(pdu), NULL, NULL,\n\t\t\t\t\t\t\t\t\tNULL);\n}\n\nstatic bool handle_signed(struct bt_att *att, uint8_t *pdu, ssize_t pdu_len)\n{\n\tuint8_t *signature;\n\tuint32_t sign_cnt;\n\tstruct sign_info *sign;\n\tuint8_t opcode = pdu[0];\n\n\t/* Check if there is enough data for a signature */\n\tif (pdu_len < 3 + BT_ATT_SIGNATURE_LEN)\n\t\tgoto fail;\n\n\tsign = att->remote_sign;\n\tif (!sign)\n\t\tgoto fail;\n\n\tsignature = pdu + (pdu_len - BT_ATT_SIGNATURE_LEN);\n\tsign_cnt = get_le32(signature);\n\n\t/* Validate counter */\n\tif (!sign->counter(&sign_cnt, sign->user_data))\n\t\tgoto fail;\n\n\t/* Verify received signature */\n\tif (!bt_crypto_verify_att_sign(att->crypto, sign->key, pdu, pdu_len))\n\t\tgoto fail;\n\n\treturn true;\n\nfail:\n\tutil_debug(att->debug_callback, att->debug_data,\n\t\t\t\"ATT failed to verify signature: 0x%02x\", opcode);\n\n\treturn false;\n}\n\nstatic void handle_notify(struct bt_att_chan *chan, uint8_t *pdu,\n\t\t\t\t\t\t\tssize_t pdu_len)\n{\n\tstruct bt_att *att = chan->att;\n\tconst struct queue_entry *entry;\n\tbool found;\n\tuint8_t opcode = pdu[0];\n\n\tbt_att_ref(att);\n\n\tfound = false;\n\tentry = queue_get_entries(att->notify_list);\n\n\twhile (entry) {\n\t\tstruct att_notify *notify = entry->data;\n\n\t\tentry = entry->next;\n\n\t\tif (!opcode_match(notify->opcode, opcode))\n\t\t\tcontinue;\n\n\t\tif ((opcode & ATT_OP_SIGNED_MASK) && att->crypto) {\n\t\t\tif (!handle_signed(att, pdu, pdu_len))\n\t\t\t\treturn;\n\t\t\tpdu_len -= BT_ATT_SIGNATURE_LEN;\n\t\t}\n\n\t\t/* BLUETOOTH CORE SPECIFICATION Version 5.1 | Vol 3, Part G\n\t\t * page 2370\n\t\t *\n\t\t * 4.3.1 Exchange MTU\n\t\t *\n\t\t * This sub-procedure shall not be used on a BR/EDR physical\n\t\t * link since the MTU size is negotiated using L2CAP channel\n\t\t * configuration procedures.\n\t\t */\n\t\tif (bt_att_get_link_type(att) == BT_ATT_BREDR) {\n\t\t\tswitch (opcode) {\n\t\t\tcase BT_ATT_OP_MTU_REQ:\n\t\t\t\tgoto not_supported;\n\t\t\t}\n\t\t}\n\n\t\tfound = true;\n\n\t\tif (notify->callback)\n\t\t\tnotify->callback(chan, opcode, pdu + 1, pdu_len - 1,\n\t\t\t\t\t\t\tnotify->user_data);\n\n\t\t/* callback could remove all entries from notify list */\n\t\tif (queue_isempty(att->notify_list))\n\t\t\tbreak;\n\t}\n\nnot_supported:\n\t/*\n\t * If this was not a command and no handler was registered for it,\n\t * respond with \"Not Supported\"\n\t */\n\tif (!found && get_op_type(opcode) != ATT_OP_TYPE_CMD)\n\t\trespond_not_supported(att, opcode);\n\n\tbt_att_unref(att);\n}\n\nstatic bool can_read_data(struct io *io, void *user_data)\n{\n\tstruct bt_att_chan *chan = user_data;\n\tstruct bt_att *att = chan->att;\n\tuint8_t opcode;\n\tuint8_t *pdu;\n\tssize_t bytes_read;\n\n\tbytes_read = read(chan->fd, chan->buf, chan->mtu);\n\tif (bytes_read < 0)\n\t\treturn false;\n\n\tutil_debug(att->debug_callback, att->debug_data,\n\t\t\t\t\"(chan %p) ATT received: %zd\",\n\t\t\t\tchan, bytes_read);\n\n\tutil_hexdump('>', chan->buf, bytes_read,\n\t\t\t\tatt->debug_callback, att->debug_data);\n\n\tif (bytes_read < ATT_MIN_PDU_LEN)\n\t\treturn true;\n\n\tpdu = chan->buf;\n\topcode = pdu[0];\n\n\tbt_att_ref(att);\n\n\t/* Act on the received PDU based on the opcode type */\n\tswitch (get_op_type(opcode)) {\n\tcase ATT_OP_TYPE_RSP:\n\t\tutil_debug(att->debug_callback, att->debug_data,\n\t\t\t\t\"(chan %p) ATT response received: 0x%02x\",\n\t\t\t\tchan, opcode);\n\t\thandle_rsp(chan, opcode, pdu + 1, bytes_read - 1);\n\t\tbreak;\n\tcase ATT_OP_TYPE_CONF:\n\t\tutil_debug(att->debug_callback, att->debug_data,\n\t\t\t\t\"(chan %p) ATT confirmation received: 0x%02x\",\n\t\t\t\tchan, opcode);\n\t\thandle_conf(chan, pdu + 1, bytes_read - 1);\n\t\tbreak;\n\tcase ATT_OP_TYPE_REQ:\n\t\t/*\n\t\t * If a request is currently pending, then the sequential\n\t\t * protocol was violated. Disconnect the bearer, which will\n\t\t * promptly notify the upper layer via disconnect handlers.\n\t\t */\n\t\tif (chan->in_req) {\n\t\t\tutil_debug(att->debug_callback, att->debug_data,\n\t\t\t\t\t\"(chan %p) Received request while \"\n\t\t\t\t\t\"another is pending: 0x%02x\",\n\t\t\t\t\tchan, opcode);\n\t\t\tio_shutdown(chan->io);\n\t\t\tbt_att_unref(chan->att);\n\n\t\t\treturn false;\n\t\t}\n\n\t\tchan->in_req = true;\n\t\t/* fall through */\n\tcase ATT_OP_TYPE_CMD:\n\tcase ATT_OP_TYPE_NFY:\n\tcase ATT_OP_TYPE_UNKNOWN:\n\tcase ATT_OP_TYPE_IND:\n\t\t/* fall through */\n\tdefault:\n\t\t/* For all other opcodes notify the upper layer of the PDU and\n\t\t * let them act on it.\n\t\t */\n\t\tutil_debug(att->debug_callback, att->debug_data,\n\t\t\t\t\t\"(chan %p) ATT PDU received: 0x%02x\",\n\t\t\t\t\tchan, opcode);\n\t\thandle_notify(chan, pdu, bytes_read);\n\t\tbreak;\n\t}\n\n\tbt_att_unref(att);\n\n\treturn true;\n}\n\nstatic bool is_io_l2cap_based(int fd)\n{\n\tint domain;\n\tint proto;\n\tint err;\n\tsocklen_t len;\n\n\tdomain = 0;\n\tlen = sizeof(domain);\n\terr = getsockopt(fd, SOL_SOCKET, SO_DOMAIN, &domain, &len);\n\tif (err < 0)\n\t\treturn false;\n\n\tif (domain != AF_BLUETOOTH)\n\t\treturn false;\n\n\tproto = 0;\n\tlen = sizeof(proto);\n\terr = getsockopt(fd, SOL_SOCKET, SO_PROTOCOL, &proto, &len);\n\tif (err < 0)\n\t\treturn false;\n\n\treturn proto == BTPROTO_L2CAP;\n}\n\nstatic void bt_att_free(struct bt_att *att)\n{\n\tbt_crypto_unref(att->crypto);\n\n\tif (att->timeout_destroy)\n\t\tatt->timeout_destroy(att->timeout_data);\n\n\tif (att->debug_destroy)\n\t\tatt->debug_destroy(att->debug_data);\n\n\tfree(att->local_sign);\n\tfree(att->remote_sign);\n\n\tqueue_destroy(att->req_queue, NULL);\n\tqueue_destroy(att->ind_queue, NULL);\n\tqueue_destroy(att->write_queue, NULL);\n\tqueue_destroy(att->notify_list, NULL);\n\tqueue_destroy(att->disconn_list, NULL);\n\tqueue_destroy(att->chans, bt_att_chan_free);\n\n\tfree(att);\n}\n\nstatic uint16_t io_get_mtu(int fd)\n{\n\tsocklen_t len;\n\tstruct l2cap_options l2o;\n\n\tlen = sizeof(l2o);\n\tif (!getsockopt(fd, SOL_L2CAP, L2CAP_OPTIONS, &l2o, &len))\n\t\treturn l2o.omtu;\n\n\tif (!getsockopt(fd, SOL_BLUETOOTH, BT_SNDMTU, &l2o.omtu, &len))\n\t\treturn l2o.omtu;\n\n\treturn 0;\n}\n\nstatic uint8_t io_get_type(int fd)\n{\n\tstruct sockaddr_l2 src;\n\tsocklen_t len;\n\n\tif (!is_io_l2cap_based(fd))\n\t\treturn BT_ATT_LOCAL;\n\n\tlen = sizeof(src);\n\tmemset(&src, 0, len);\n\tif (getsockname(fd, (void *)&src, &len) < 0)\n\t\treturn -errno;\n\n\tif (src.l2_bdaddr_type == BDADDR_BREDR)\n\t\treturn BT_ATT_BREDR;\n\n\treturn BT_ATT_LE;\n}\n\nstatic struct bt_att_chan *bt_att_chan_new(int fd, uint8_t type)\n{\n\tstruct bt_att_chan *chan;\n\n\tif (fd < 0)\n\t\treturn NULL;\n\n\tchan = new0(struct bt_att_chan, 1);\n\tchan->fd = fd;\n\n\tchan->io = io_new(fd);\n\tif (!chan->io)\n\t\tgoto fail;\n\n\tif (!io_set_read_handler(chan->io, can_read_data, chan, NULL))\n\t\tgoto fail;\n\n\tif (!io_set_disconnect_handler(chan->io, disconnect_cb, chan, NULL))\n\t\tgoto fail;\n\n\tchan->type = type;\n\tswitch (chan->type) {\n\tcase BT_ATT_LOCAL:\n\t\tchan->sec_level = BT_ATT_SECURITY_LOW;\n\t\t/* fall through */\n\tcase BT_ATT_LE:\n\t\tchan->mtu = BT_ATT_DEFAULT_LE_MTU;\n\t\tbreak;\n\tdefault:\n\t\tchan->mtu = io_get_mtu(chan->fd);\n\t}\n\n\tif (chan->mtu < BT_ATT_DEFAULT_LE_MTU)\n\t\tgoto fail;\n\n\tchan->buf = malloc(chan->mtu);\n\tif (!chan->buf)\n\t\tgoto fail;\n\n\tchan->queue = queue_new();\n\n\treturn chan;\n\nfail:\n\tbt_att_chan_free(chan);\n\n\treturn NULL;\n}\n\nstatic void bt_att_attach_chan(struct bt_att *att, struct bt_att_chan *chan)\n{\n\t/* Push to head as EATT channels have higher priority */\n\tqueue_push_head(att->chans, chan);\n\tchan->att = att;\n\n\tif (chan->mtu > att->mtu)\n\t\tatt->mtu = chan->mtu;\n\n\tio_set_close_on_destroy(chan->io, att->close_on_unref);\n\n\tutil_debug(att->debug_callback, att->debug_data, \"Channel %p attached\",\n\t\t\t\t\t\t\t\t\tchan);\n\n\twakeup_chan_writer(chan, NULL);\n}\n\nstruct bt_att *bt_att_new(int fd, bool ext_signed)\n{\n\tstruct bt_att *att;\n\tstruct bt_att_chan *chan;\n\n\tchan = bt_att_chan_new(fd, io_get_type(fd));\n\tif (!chan)\n\t\treturn NULL;\n\n\tatt = new0(struct bt_att, 1);\n\tatt->chans = queue_new();\n\tatt->mtu = chan->mtu;\n\n\t/* crypto is optional, if not available leave it NULL */\n\tif (!ext_signed)\n\t\tatt->crypto = bt_crypto_new();\n\n\tatt->req_queue = queue_new();\n\tatt->ind_queue = queue_new();\n\tatt->write_queue = queue_new();\n\tatt->notify_list = queue_new();\n\tatt->disconn_list = queue_new();\n\n\tbt_att_attach_chan(att, chan);\n\n\treturn bt_att_ref(att);\n}\n\nstruct bt_att *bt_att_ref(struct bt_att *att)\n{\n\tif (!att)\n\t\treturn NULL;\n\n\t__sync_fetch_and_add(&att->ref_count, 1);\n\n\treturn att;\n}\n\nvoid bt_att_unref(struct bt_att *att)\n{\n\tif (!att)\n\t\treturn;\n\n\tif (__sync_sub_and_fetch(&att->ref_count, 1))\n\t\treturn;\n\n\tbt_att_unregister_all(att);\n\tbt_att_cancel_all(att);\n\n\tbt_att_free(att);\n}\n\nbool bt_att_set_close_on_unref(struct bt_att *att, bool do_close)\n{\n\tconst struct queue_entry *entry;\n\n\tif (!att)\n\t\treturn false;\n\n\tatt->close_on_unref = do_close;\n\n\tfor (entry = queue_get_entries(att->chans); entry;\n\t\t\t\t\t\tentry = entry->next) {\n\t\tstruct bt_att_chan *chan = entry->data;\n\n\t\tif (!io_set_close_on_destroy(chan->io, do_close))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nint bt_att_attach_fd(struct bt_att *att, int fd)\n{\n\tstruct bt_att_chan *chan;\n\n\tif (!att || fd < 0)\n\t\treturn -EINVAL;\n\n\tchan = bt_att_chan_new(fd, BT_ATT_EATT);\n\tif (!chan)\n\t\treturn -EINVAL;\n\n\tbt_att_attach_chan(att, chan);\n\n\treturn 0;\n}\n\nint bt_att_get_fd(struct bt_att *att)\n{\n\tstruct bt_att_chan *chan;\n\n\tif (!att)\n\t\treturn -1;\n\n\tif (queue_isempty(att->chans))\n\t\treturn -ENOTCONN;\n\n\tchan = queue_peek_tail(att->chans);\n\n\treturn chan->fd;\n}\n\nint bt_att_get_channels(struct bt_att *att)\n{\n\tif (!att)\n\t\treturn 0;\n\n\treturn queue_length(att->chans);\n}\n\nbool bt_att_set_debug(struct bt_att *att, bt_att_debug_func_t callback,\n\t\t\t\tvoid *user_data, bt_att_destroy_func_t destroy)\n{\n\tif (!att)\n\t\treturn false;\n\n\tif (att->debug_destroy)\n\t\tatt->debug_destroy(att->debug_data);\n\n\tatt->debug_callback = callback;\n\tatt->debug_destroy = destroy;\n\tatt->debug_data = user_data;\n\n\treturn true;\n}\n\nuint16_t bt_att_get_mtu(struct bt_att *att)\n{\n\tif (!att)\n\t\treturn 0;\n\n\treturn att->mtu;\n}\n\nbool bt_att_set_mtu(struct bt_att *att, uint16_t mtu)\n{\n\tstruct bt_att_chan *chan;\n\tvoid *buf;\n\n\tif (!att)\n\t\treturn false;\n\n\tif (mtu < BT_ATT_DEFAULT_LE_MTU)\n\t\treturn false;\n\n\t/* Original channel is always the last */\n\tchan = queue_peek_tail(att->chans);\n\tif (!chan)\n\t\treturn -ENOTCONN;\n\n\tbuf = malloc(mtu);\n\tif (!buf)\n\t\treturn false;\n\n\tfree(chan->buf);\n\n\tchan->mtu = mtu;\n\tchan->buf = buf;\n\n\tif (chan->mtu > att->mtu)\n\t\tatt->mtu = chan->mtu;\n\n\treturn true;\n}\n\nuint8_t bt_att_get_link_type(struct bt_att *att)\n{\n\tstruct bt_att_chan *chan;\n\n\tif (!att)\n\t\treturn -EINVAL;\n\n\tchan = queue_peek_tail(att->chans);\n\tif (!chan)\n\t\treturn -ENOTCONN;\n\n\treturn chan->type;\n}\n\nbool bt_att_set_timeout_cb(struct bt_att *att, bt_att_timeout_func_t callback,\n\t\t\t\t\t\tvoid *user_data,\n\t\t\t\t\t\tbt_att_destroy_func_t destroy)\n{\n\tif (!att)\n\t\treturn false;\n\n\tif (att->timeout_destroy)\n\t\tatt->timeout_destroy(att->timeout_data);\n\n\tatt->timeout_callback = callback;\n\tatt->timeout_destroy = destroy;\n\tatt->timeout_data = user_data;\n\n\treturn true;\n}\n\nunsigned int bt_att_register_disconnect(struct bt_att *att,\n\t\t\t\t\tbt_att_disconnect_func_t callback,\n\t\t\t\t\tvoid *user_data,\n\t\t\t\t\tbt_att_destroy_func_t destroy)\n{\n\tstruct att_disconn *disconn;\n\n\tif (!att || queue_isempty(att->chans))\n\t\treturn 0;\n\n\tdisconn = new0(struct att_disconn, 1);\n\tdisconn->callback = callback;\n\tdisconn->destroy = destroy;\n\tdisconn->user_data = user_data;\n\n\tif (att->next_reg_id < 1)\n\t\tatt->next_reg_id = 1;\n\n\tdisconn->id = att->next_reg_id++;\n\n\tif (!queue_push_tail(att->disconn_list, disconn)) {\n\t\tfree(disconn);\n\t\treturn 0;\n\t}\n\n\treturn disconn->id;\n}\n\nbool bt_att_unregister_disconnect(struct bt_att *att, unsigned int id)\n{\n\tstruct att_disconn *disconn;\n\n\tif (!att || !id)\n\t\treturn false;\n\n\t/* Check if disconnect is running */\n\tif (queue_isempty(att->chans)) {\n\t\tdisconn = queue_find(att->disconn_list, match_disconn_id,\n\t\t\t\t\t\t\tUINT_TO_PTR(id));\n\t\tif (!disconn)\n\t\t\treturn false;\n\n\t\tdisconn->removed = true;\n\t\treturn true;\n\t}\n\n\tdisconn = queue_remove_if(att->disconn_list, match_disconn_id,\n\t\t\t\t\t\t\tUINT_TO_PTR(id));\n\tif (!disconn)\n\t\treturn false;\n\n\tdestroy_att_disconn(disconn);\n\treturn true;\n}\n\nunsigned int bt_att_send(struct bt_att *att, uint8_t opcode,\n\t\t\t\tconst void *pdu, uint16_t length,\n\t\t\t\tbt_att_response_func_t callback, void *user_data,\n\t\t\t\tbt_att_destroy_func_t destroy)\n{\n\tstruct att_send_op *op;\n\tbool result;\n\n\tif (!att || queue_isempty(att->chans))\n\t\treturn 0;\n\n\top = create_att_send_op(att, opcode, pdu, length, callback, user_data,\n\t\t\t\t\t\t\t\tdestroy);\n\tif (!op)\n\t\treturn 0;\n\n\tif (att->next_send_id < 1)\n\t\tatt->next_send_id = 1;\n\n\top->id = att->next_send_id++;\n\n\t/* Add the op to the correct queue based on its type */\n\tswitch (op->type) {\n\tcase ATT_OP_TYPE_REQ:\n\t\tresult = queue_push_tail(att->req_queue, op);\n\t\tbreak;\n\tcase ATT_OP_TYPE_IND:\n\t\tresult = queue_push_tail(att->ind_queue, op);\n\t\tbreak;\n\tcase ATT_OP_TYPE_CMD:\n\tcase ATT_OP_TYPE_NFY:\n\tcase ATT_OP_TYPE_UNKNOWN:\n\tcase ATT_OP_TYPE_RSP:\n\tcase ATT_OP_TYPE_CONF:\n\tdefault:\n\t\tresult = queue_push_tail(att->write_queue, op);\n\t\tbreak;\n\t}\n\n\tif (!result) {\n\t\tfree(op->pdu);\n\t\tfree(op);\n\t\treturn 0;\n\t}\n\n\twakeup_writer(att);\n\n\treturn op->id;\n}\n\nunsigned int bt_att_chan_send(struct bt_att_chan *chan, uint8_t opcode,\n\t\t\t\tconst void *pdu, uint16_t len,\n\t\t\t\tbt_att_response_func_t callback,\n\t\t\t\tvoid *user_data,\n\t\t\t\tbt_att_destroy_func_t destroy)\n{\n\tstruct att_send_op *op;\n\n\tif (!chan || !chan->att)\n\t\treturn -EINVAL;\n\n\top = create_att_send_op(chan->att, opcode, pdu, len, callback,\n\t\t\t\t\t\tuser_data, destroy);\n\tif (!op)\n\t\treturn -EINVAL;\n\n\tif (!queue_push_tail(chan->queue, op)) {\n\t\tfree(op->pdu);\n\t\tfree(op);\n\t\treturn 0;\n\t}\n\n\twakeup_chan_writer(chan, NULL);\n\n\treturn op->id;\n}\n\nstatic bool match_op_id(const void *a, const void *b)\n{\n\tconst struct att_send_op *op = a;\n\tunsigned int id = PTR_TO_UINT(b);\n\n\treturn op->id == id;\n}\n\nbool bt_att_chan_cancel(struct bt_att_chan *chan, unsigned int id)\n{\n\tstruct att_send_op *op;\n\n\tif (chan->pending_req && chan->pending_req->id == id) {\n\t\t/* Don't cancel the pending request; remove it's handlers */\n\t\tcancel_att_send_op(chan->pending_req);\n\t\treturn true;\n\t}\n\n\tif (chan->pending_ind && chan->pending_ind->id == id) {\n\t\t/* Don't cancel the pending indication; remove it's handlers. */\n\t\tcancel_att_send_op(chan->pending_ind);\n\t\treturn true;\n\t}\n\n\top = queue_remove_if(chan->queue, match_op_id, UINT_TO_PTR(id));\n\tif (!op)\n\t\treturn false;\n\n\tdestroy_att_send_op(op);\n\n\twakeup_chan_writer(chan, NULL);\n\n\treturn true;\n}\n\nbool bt_att_cancel(struct bt_att *att, unsigned int id)\n{\n\tconst struct queue_entry *entry;\n\tstruct att_send_op *op;\n\n\tif (!att || !id)\n\t\treturn false;\n\n\t/* Lookuo request on each channel first */\n\tfor (entry = queue_get_entries(att->chans); entry;\n\t\t\t\t\t\tentry = entry->next) {\n\t\tstruct bt_att_chan *chan = entry->data;\n\n\t\tif (bt_att_chan_cancel(chan, id))\n\t\t\treturn true;\n\t}\n\n\top = queue_remove_if(att->req_queue, match_op_id, UINT_TO_PTR(id));\n\tif (op)\n\t\tgoto done;\n\n\top = queue_remove_if(att->ind_queue, match_op_id, UINT_TO_PTR(id));\n\tif (op)\n\t\tgoto done;\n\n\top = queue_remove_if(att->write_queue, match_op_id, UINT_TO_PTR(id));\n\tif (op)\n\t\tgoto done;\n\n\tif (!op)\n\t\treturn false;\n\ndone:\n\tdestroy_att_send_op(op);\n\n\twakeup_writer(att);\n\n\treturn true;\n}\n\nbool bt_att_cancel_all(struct bt_att *att)\n{\n\tconst struct queue_entry *entry;\n\n\tif (!att)\n\t\treturn false;\n\n\tqueue_remove_all(att->req_queue, NULL, NULL, destroy_att_send_op);\n\tqueue_remove_all(att->ind_queue, NULL, NULL, destroy_att_send_op);\n\tqueue_remove_all(att->write_queue, NULL, NULL, destroy_att_send_op);\n\n\tfor (entry = queue_get_entries(att->chans); entry;\n\t\t\t\t\t\tentry = entry->next) {\n\t\tstruct bt_att_chan *chan = entry->data;\n\n\t\tif (chan->pending_req)\n\t\t\t/* Don't cancel the pending request; remove it's\n\t\t\t * handlers\n\t\t\t */\n\t\t\tcancel_att_send_op(chan->pending_req);\n\n\t\tif (chan->pending_ind)\n\t\t\t/* Don't cancel the pending request; remove it's\n\t\t\t * handlers\n\t\t\t */\n\t\t\tcancel_att_send_op(chan->pending_ind);\n\t}\n\n\treturn true;\n}\n\nstatic uint8_t att_ecode_from_error(int err)\n{\n\t/*\n\t * If the error fits in a single byte, treat it as an ATT protocol\n\t * error as is. Since \"0\" is not a valid ATT protocol error code, we map\n\t * that to UNLIKELY below.\n\t */\n\tif (err > 0 && err < UINT8_MAX)\n\t\treturn err;\n\n\t/*\n\t * Since we allow UNIX errnos, map them to appropriate ATT protocol\n\t * and \"Common Profile and Service\" error codes.\n\t */\n\tswitch (err) {\n\tcase -ENOENT:\n\t\treturn BT_ATT_ERROR_INVALID_HANDLE;\n\tcase -ENOMEM:\n\t\treturn BT_ATT_ERROR_INSUFFICIENT_RESOURCES;\n\tcase -EALREADY:\n\t\treturn BT_ERROR_ALREADY_IN_PROGRESS;\n\tcase -EOVERFLOW:\n\t\treturn BT_ERROR_OUT_OF_RANGE;\n\t}\n\n\treturn BT_ATT_ERROR_UNLIKELY;\n}\n\nint bt_att_chan_send_error_rsp(struct bt_att_chan *chan, uint8_t opcode,\n\t\t\t\t\t\tuint16_t handle, int error)\n{\n\tstruct bt_att_pdu_error_rsp pdu;\n\tuint8_t ecode;\n\n\tif (!chan || !chan->att || !opcode)\n\t\treturn -EINVAL;\n\n\tecode = att_ecode_from_error(error);\n\n\tmemset(&pdu, 0, sizeof(pdu));\n\n\tpdu.opcode = opcode;\n\tput_le16(handle, &pdu.handle);\n\tpdu.ecode = ecode;\n\n\treturn bt_att_chan_send_rsp(chan, BT_ATT_OP_ERROR_RSP, &pdu,\n\t\t\t\t\t\t\tsizeof(pdu));\n}\n\nunsigned int bt_att_register(struct bt_att *att, uint8_t opcode,\n\t\t\t\t\t\tbt_att_notify_func_t callback,\n\t\t\t\t\t\tvoid *user_data,\n\t\t\t\t\t\tbt_att_destroy_func_t destroy)\n{\n\tstruct att_notify *notify;\n\n\tif (!att || !callback || queue_isempty(att->chans))\n\t\treturn 0;\n\n\tnotify = new0(struct att_notify, 1);\n\tnotify->opcode = opcode;\n\tnotify->callback = callback;\n\tnotify->destroy = destroy;\n\tnotify->user_data = user_data;\n\n\tif (att->next_reg_id < 1)\n\t\tatt->next_reg_id = 1;\n\n\tnotify->id = att->next_reg_id++;\n\n\tif (!queue_push_tail(att->notify_list, notify)) {\n\t\tfree(notify);\n\t\treturn 0;\n\t}\n\n\treturn notify->id;\n}\n\nbool bt_att_unregister(struct bt_att *att, unsigned int id)\n{\n\tstruct att_notify *notify;\n\n\tif (!att || !id)\n\t\treturn false;\n\n\tnotify = queue_remove_if(att->notify_list, match_notify_id,\n\t\t\t\t\t\t\tUINT_TO_PTR(id));\n\tif (!notify)\n\t\treturn false;\n\n\tdestroy_att_notify(notify);\n\treturn true;\n}\n\nbool bt_att_unregister_all(struct bt_att *att)\n{\n\tif (!att)\n\t\treturn false;\n\n\tqueue_remove_all(att->notify_list, NULL, NULL, destroy_att_notify);\n\tqueue_remove_all(att->disconn_list, NULL, NULL, destroy_att_disconn);\n\n\treturn true;\n}\n\nint bt_att_get_security(struct bt_att *att, uint8_t *enc_size)\n{\n\tstruct bt_att_chan *chan;\n\tint ret;\n\n\tif (!att)\n\t\treturn -EINVAL;\n\n\tchan = queue_peek_tail(att->chans);\n\tif (!chan)\n\t\treturn -ENOTCONN;\n\n\tret = bt_att_chan_get_security(chan);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (enc_size)\n\t\t*enc_size = att->enc_size;\n\n\treturn ret;\n}\n\nbool bt_att_set_security(struct bt_att *att, int level)\n{\n\tstruct bt_att_chan *chan;\n\n\tif (!att || level < BT_ATT_SECURITY_AUTO ||\n\t\t\t\t\t\tlevel > BT_ATT_SECURITY_HIGH)\n\t\treturn false;\n\n\tchan = queue_peek_tail(att->chans);\n\tif (!chan)\n\t\treturn -ENOTCONN;\n\n\treturn bt_att_chan_set_security(chan, level);\n}\n\nvoid bt_att_set_enc_key_size(struct bt_att *att, uint8_t enc_size)\n{\n\tif (!att)\n\t\treturn;\n\n\tatt->enc_size = enc_size;\n}\n\nstatic bool sign_set_key(struct sign_info **sign, uint8_t key[16],\n\t\t\t\tbt_att_counter_func_t func, void *user_data)\n{\n\tif (!(*sign))\n\t\t*sign = new0(struct sign_info, 1);\n\n\t(*sign)->counter = func;\n\t(*sign)->user_data = user_data;\n\tmemcpy((*sign)->key, key, 16);\n\n\treturn true;\n}\n\nbool bt_att_set_local_key(struct bt_att *att, uint8_t sign_key[16],\n\t\t\t\tbt_att_counter_func_t func, void *user_data)\n{\n\tif (!att)\n\t\treturn false;\n\n\treturn sign_set_key(&att->local_sign, sign_key, func, user_data);\n}\n\nbool bt_att_set_remote_key(struct bt_att *att, uint8_t sign_key[16],\n\t\t\t\tbt_att_counter_func_t func, void *user_data)\n{\n\tif (!att)\n\t\treturn false;\n\n\treturn sign_set_key(&att->remote_sign, sign_key, func, user_data);\n}\n\nbool bt_att_has_crypto(struct bt_att *att)\n{\n\tif (!att)\n\t\treturn false;\n\n\treturn att->crypto ? true : false;\n}\n"], "fixing_code": ["/*\n *\n *  BlueZ - Bluetooth protocol stack for Linux\n *\n *  Copyright (C) 2014  Google Inc.\n *\n *\n *  This library is free software; you can redistribute it and/or\n *  modify it under the terms of the GNU Lesser General Public\n *  License as published by the Free Software Foundation; either\n *  version 2.1 of the License, or (at your option) any later version.\n *\n *  This library is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n *  Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; if not, write to the Free Software\n *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n *\n */\n\n#ifdef HAVE_CONFIG_H\n#include <config.h>\n#endif\n\n#include <stdlib.h>\n#include <unistd.h>\n#include <errno.h>\n\n#include \"src/shared/io.h\"\n#include \"src/shared/queue.h\"\n#include \"src/shared/util.h\"\n#include \"src/shared/timeout.h\"\n#include \"lib/bluetooth.h\"\n#include \"lib/l2cap.h\"\n#include \"lib/uuid.h\"\n#include \"src/shared/att.h\"\n#include \"src/shared/crypto.h\"\n\n#define ATT_MIN_PDU_LEN\t\t\t1  /* At least 1 byte for the opcode. */\n#define ATT_OP_CMD_MASK\t\t\t0x40\n#define ATT_OP_SIGNED_MASK\t\t0x80\n#define ATT_TIMEOUT_INTERVAL\t\t30000  /* 30000 ms */\n\n/* Length of signature in write signed packet */\n#define BT_ATT_SIGNATURE_LEN\t\t12\n\nstruct att_send_op;\n\nstruct bt_att_chan {\n\tstruct bt_att *att;\n\tint fd;\n\tstruct io *io;\n\tuint8_t type;\n\tint sec_level;\t\t\t/* Only used for non-L2CAP */\n\n\tstruct queue *queue;\t\t/* Channel dedicated queue */\n\n\tstruct att_send_op *pending_req;\n\tstruct att_send_op *pending_ind;\n\tbool writer_active;\n\n\tbool in_req;\t\t\t/* There's a pending incoming request */\n\n\tuint8_t *buf;\n\tuint16_t mtu;\n};\n\nstruct bt_att {\n\tint ref_count;\n\tbool close_on_unref;\n\tstruct queue *chans;\n\tuint8_t enc_size;\n\tuint16_t mtu;\t\t\t/* Biggest possible MTU */\n\n\tstruct queue *notify_list;\t/* List of registered callbacks */\n\tstruct queue *disconn_list;\t/* List of disconnect handlers */\n\n\tunsigned int next_send_id;\t/* IDs for \"send\" ops */\n\tunsigned int next_reg_id;\t/* IDs for registered callbacks */\n\n\tstruct queue *req_queue;\t/* Queued ATT protocol requests */\n\tstruct queue *ind_queue;\t/* Queued ATT protocol indications */\n\tstruct queue *write_queue;\t/* Queue of PDUs ready to send */\n\tbool in_disc;\t\t\t/* Cleanup queues on disconnect_cb */\n\n\tbt_att_timeout_func_t timeout_callback;\n\tbt_att_destroy_func_t timeout_destroy;\n\tvoid *timeout_data;\n\n\tbt_att_debug_func_t debug_callback;\n\tbt_att_destroy_func_t debug_destroy;\n\tvoid *debug_data;\n\n\tstruct bt_crypto *crypto;\n\n\tstruct sign_info *local_sign;\n\tstruct sign_info *remote_sign;\n};\n\nstruct sign_info {\n\tuint8_t key[16];\n\tbt_att_counter_func_t counter;\n\tvoid *user_data;\n};\n\nenum att_op_type {\n\tATT_OP_TYPE_REQ,\n\tATT_OP_TYPE_RSP,\n\tATT_OP_TYPE_CMD,\n\tATT_OP_TYPE_IND,\n\tATT_OP_TYPE_NFY,\n\tATT_OP_TYPE_CONF,\n\tATT_OP_TYPE_UNKNOWN,\n};\n\nstatic const struct {\n\tuint8_t opcode;\n\tenum att_op_type type;\n} att_opcode_type_table[] = {\n\t{ BT_ATT_OP_ERROR_RSP,\t\t\tATT_OP_TYPE_RSP },\n\t{ BT_ATT_OP_MTU_REQ,\t\t\tATT_OP_TYPE_REQ },\n\t{ BT_ATT_OP_MTU_RSP,\t\t\tATT_OP_TYPE_RSP },\n\t{ BT_ATT_OP_FIND_INFO_REQ,\t\tATT_OP_TYPE_REQ },\n\t{ BT_ATT_OP_FIND_INFO_RSP,\t\tATT_OP_TYPE_RSP },\n\t{ BT_ATT_OP_FIND_BY_TYPE_REQ,\t\tATT_OP_TYPE_REQ },\n\t{ BT_ATT_OP_FIND_BY_TYPE_RSP,\t\tATT_OP_TYPE_RSP },\n\t{ BT_ATT_OP_READ_BY_TYPE_REQ,\t\tATT_OP_TYPE_REQ },\n\t{ BT_ATT_OP_READ_BY_TYPE_RSP,\t\tATT_OP_TYPE_RSP },\n\t{ BT_ATT_OP_READ_REQ,\t\t\tATT_OP_TYPE_REQ },\n\t{ BT_ATT_OP_READ_RSP,\t\t\tATT_OP_TYPE_RSP },\n\t{ BT_ATT_OP_READ_BLOB_REQ,\t\tATT_OP_TYPE_REQ },\n\t{ BT_ATT_OP_READ_BLOB_RSP,\t\tATT_OP_TYPE_RSP },\n\t{ BT_ATT_OP_READ_MULT_REQ,\t\tATT_OP_TYPE_REQ },\n\t{ BT_ATT_OP_READ_MULT_RSP,\t\tATT_OP_TYPE_RSP },\n\t{ BT_ATT_OP_READ_BY_GRP_TYPE_REQ,\tATT_OP_TYPE_REQ },\n\t{ BT_ATT_OP_READ_BY_GRP_TYPE_RSP,\tATT_OP_TYPE_RSP },\n\t{ BT_ATT_OP_WRITE_REQ,\t\t\tATT_OP_TYPE_REQ },\n\t{ BT_ATT_OP_WRITE_RSP,\t\t\tATT_OP_TYPE_RSP },\n\t{ BT_ATT_OP_WRITE_CMD,\t\t\tATT_OP_TYPE_CMD },\n\t{ BT_ATT_OP_SIGNED_WRITE_CMD,\t\tATT_OP_TYPE_CMD },\n\t{ BT_ATT_OP_PREP_WRITE_REQ,\t\tATT_OP_TYPE_REQ },\n\t{ BT_ATT_OP_PREP_WRITE_RSP,\t\tATT_OP_TYPE_RSP },\n\t{ BT_ATT_OP_EXEC_WRITE_REQ,\t\tATT_OP_TYPE_REQ },\n\t{ BT_ATT_OP_EXEC_WRITE_RSP,\t\tATT_OP_TYPE_RSP },\n\t{ BT_ATT_OP_HANDLE_NFY,\t\t\tATT_OP_TYPE_NFY },\n\t{ BT_ATT_OP_HANDLE_NFY_MULT,\t\tATT_OP_TYPE_NFY },\n\t{ BT_ATT_OP_HANDLE_IND,\t\t\tATT_OP_TYPE_IND },\n\t{ BT_ATT_OP_HANDLE_CONF,\t\tATT_OP_TYPE_CONF },\n\t{ }\n};\n\nstatic enum att_op_type get_op_type(uint8_t opcode)\n{\n\tint i;\n\n\tfor (i = 0; att_opcode_type_table[i].opcode; i++) {\n\t\tif (att_opcode_type_table[i].opcode == opcode)\n\t\t\treturn att_opcode_type_table[i].type;\n\t}\n\n\tif (opcode & ATT_OP_CMD_MASK)\n\t\treturn ATT_OP_TYPE_CMD;\n\n\treturn ATT_OP_TYPE_UNKNOWN;\n}\n\nstatic const struct {\n\tuint8_t req_opcode;\n\tuint8_t rsp_opcode;\n} att_req_rsp_mapping_table[] = {\n\t{ BT_ATT_OP_MTU_REQ,\t\t\tBT_ATT_OP_MTU_RSP },\n\t{ BT_ATT_OP_FIND_INFO_REQ,\t\tBT_ATT_OP_FIND_INFO_RSP},\n\t{ BT_ATT_OP_FIND_BY_TYPE_REQ,\t\tBT_ATT_OP_FIND_BY_TYPE_RSP },\n\t{ BT_ATT_OP_READ_BY_TYPE_REQ,\t\tBT_ATT_OP_READ_BY_TYPE_RSP },\n\t{ BT_ATT_OP_READ_REQ,\t\t\tBT_ATT_OP_READ_RSP },\n\t{ BT_ATT_OP_READ_BLOB_REQ,\t\tBT_ATT_OP_READ_BLOB_RSP },\n\t{ BT_ATT_OP_READ_MULT_REQ,\t\tBT_ATT_OP_READ_MULT_RSP },\n\t{ BT_ATT_OP_READ_BY_GRP_TYPE_REQ,\tBT_ATT_OP_READ_BY_GRP_TYPE_RSP },\n\t{ BT_ATT_OP_WRITE_REQ,\t\t\tBT_ATT_OP_WRITE_RSP },\n\t{ BT_ATT_OP_PREP_WRITE_REQ,\t\tBT_ATT_OP_PREP_WRITE_RSP },\n\t{ BT_ATT_OP_EXEC_WRITE_REQ,\t\tBT_ATT_OP_EXEC_WRITE_RSP },\n\t{ }\n};\n\nstatic uint8_t get_req_opcode(uint8_t rsp_opcode)\n{\n\tint i;\n\n\tfor (i = 0; att_req_rsp_mapping_table[i].rsp_opcode; i++) {\n\t\tif (att_req_rsp_mapping_table[i].rsp_opcode == rsp_opcode)\n\t\t\treturn att_req_rsp_mapping_table[i].req_opcode;\n\t}\n\n\treturn 0;\n}\n\nstruct att_send_op {\n\tunsigned int id;\n\tunsigned int timeout_id;\n\tenum att_op_type type;\n\tuint8_t opcode;\n\tvoid *pdu;\n\tuint16_t len;\n\tbt_att_response_func_t callback;\n\tbt_att_destroy_func_t destroy;\n\tvoid *user_data;\n};\n\nstatic void destroy_att_send_op(void *data)\n{\n\tstruct att_send_op *op = data;\n\n\tif (op->timeout_id)\n\t\ttimeout_remove(op->timeout_id);\n\n\tif (op->destroy)\n\t\top->destroy(op->user_data);\n\n\tfree(op->pdu);\n\tfree(op);\n}\n\nstatic void cancel_att_send_op(void *data)\n{\n\tstruct att_send_op *op = data;\n\n\tif (op->destroy)\n\t\top->destroy(op->user_data);\n\n\top->user_data = NULL;\n\top->callback = NULL;\n\top->destroy = NULL;\n}\n\nstruct att_notify {\n\tunsigned int id;\n\tuint16_t opcode;\n\tbt_att_notify_func_t callback;\n\tbt_att_destroy_func_t destroy;\n\tvoid *user_data;\n};\n\nstatic void destroy_att_notify(void *data)\n{\n\tstruct att_notify *notify = data;\n\n\tif (notify->destroy)\n\t\tnotify->destroy(notify->user_data);\n\n\tfree(notify);\n}\n\nstatic bool match_notify_id(const void *a, const void *b)\n{\n\tconst struct att_notify *notify = a;\n\tunsigned int id = PTR_TO_UINT(b);\n\n\treturn notify->id == id;\n}\n\nstruct att_disconn {\n\tunsigned int id;\n\tbool removed;\n\tbt_att_disconnect_func_t callback;\n\tbt_att_destroy_func_t destroy;\n\tvoid *user_data;\n};\n\nstatic void destroy_att_disconn(void *data)\n{\n\tstruct att_disconn *disconn = data;\n\n\tif (disconn->destroy)\n\t\tdisconn->destroy(disconn->user_data);\n\n\tfree(disconn);\n}\n\nstatic bool match_disconn_id(const void *a, const void *b)\n{\n\tconst struct att_disconn *disconn = a;\n\tunsigned int id = PTR_TO_UINT(b);\n\n\treturn disconn->id == id;\n}\n\nstatic bool encode_pdu(struct bt_att *att, struct att_send_op *op,\n\t\t\t\t\tconst void *pdu, uint16_t length)\n{\n\tuint16_t pdu_len = 1;\n\tstruct sign_info *sign = att->local_sign;\n\tuint32_t sign_cnt;\n\n\tif (sign && (op->opcode & ATT_OP_SIGNED_MASK))\n\t\tpdu_len += BT_ATT_SIGNATURE_LEN;\n\n\tif (length && pdu)\n\t\tpdu_len += length;\n\n\tif (pdu_len > att->mtu)\n\t\treturn false;\n\n\top->len = pdu_len;\n\top->pdu = malloc(op->len);\n\tif (!op->pdu)\n\t\treturn false;\n\n\t((uint8_t *) op->pdu)[0] = op->opcode;\n\tif (pdu_len > 1)\n\t\tmemcpy(op->pdu + 1, pdu, length);\n\n\tif (!sign || !(op->opcode & ATT_OP_SIGNED_MASK) || !att->crypto)\n\t\treturn true;\n\n\tif (!sign->counter(&sign_cnt, sign->user_data))\n\t\tgoto fail;\n\n\tif ((bt_crypto_sign_att(att->crypto, sign->key, op->pdu, 1 + length,\n\t\t\t\tsign_cnt, &((uint8_t *) op->pdu)[1 + length])))\n\t\treturn true;\n\n\tutil_debug(att->debug_callback, att->debug_data,\n\t\t\t\t\t\"ATT unable to generate signature\");\n\nfail:\n\tfree(op->pdu);\n\treturn false;\n}\n\nstatic struct att_send_op *create_att_send_op(struct bt_att *att,\n\t\t\t\t\t\tuint8_t opcode,\n\t\t\t\t\t\tconst void *pdu,\n\t\t\t\t\t\tuint16_t length,\n\t\t\t\t\t\tbt_att_response_func_t callback,\n\t\t\t\t\t\tvoid *user_data,\n\t\t\t\t\t\tbt_att_destroy_func_t destroy)\n{\n\tstruct att_send_op *op;\n\tenum att_op_type type;\n\n\tif (length && !pdu)\n\t\treturn NULL;\n\n\ttype = get_op_type(opcode);\n\tif (type == ATT_OP_TYPE_UNKNOWN)\n\t\treturn NULL;\n\n\t/* If the opcode corresponds to an operation type that does not elicit a\n\t * response from the remote end, then no callback should have been\n\t * provided, since it will never be called.\n\t */\n\tif (callback && type != ATT_OP_TYPE_REQ && type != ATT_OP_TYPE_IND)\n\t\treturn NULL;\n\n\t/* Similarly, if the operation does elicit a response then a callback\n\t * must be provided.\n\t */\n\tif (!callback && (type == ATT_OP_TYPE_REQ || type == ATT_OP_TYPE_IND))\n\t\treturn NULL;\n\n\top = new0(struct att_send_op, 1);\n\top->type = type;\n\top->opcode = opcode;\n\top->callback = callback;\n\top->destroy = destroy;\n\top->user_data = user_data;\n\n\tif (!encode_pdu(att, op, pdu, length)) {\n\t\tfree(op);\n\t\treturn NULL;\n\t}\n\n\treturn op;\n}\n\nstatic struct att_send_op *pick_next_send_op(struct bt_att_chan *chan)\n{\n\tstruct bt_att *att = chan->att;\n\tstruct att_send_op *op;\n\n\t/* Check if there is anything queued on the channel */\n\top = queue_pop_head(chan->queue);\n\tif (op)\n\t\treturn op;\n\n\t/* See if any operations are already in the write queue */\n\top = queue_peek_head(att->write_queue);\n\tif (op && op->len <= chan->mtu)\n\t\treturn queue_pop_head(att->write_queue);\n\n\t/* If there is no pending request, pick an operation from the\n\t * request queue.\n\t */\n\tif (!chan->pending_req) {\n\t\top = queue_peek_head(att->req_queue);\n\t\tif (op && op->len <= chan->mtu)\n\t\t\treturn queue_pop_head(att->req_queue);\n\t}\n\n\t/* There is either a request pending or no requests queued. If there is\n\t * no pending indication, pick an operation from the indication queue.\n\t */\n\tif (!chan->pending_ind) {\n\t\top = queue_peek_head(att->ind_queue);\n\t\tif (op && op->len <= chan->mtu)\n\t\t\treturn queue_pop_head(att->ind_queue);\n\t}\n\n\treturn NULL;\n}\n\nstatic void disc_att_send_op(void *data)\n{\n\tstruct att_send_op *op = data;\n\n\tif (op->callback)\n\t\top->callback(BT_ATT_OP_ERROR_RSP, NULL, 0, op->user_data);\n\n\tdestroy_att_send_op(op);\n}\n\nstruct timeout_data {\n\tstruct bt_att_chan *chan;\n\tunsigned int id;\n};\n\nstatic bool timeout_cb(void *user_data)\n{\n\tstruct timeout_data *timeout = user_data;\n\tstruct bt_att_chan *chan = timeout->chan;\n\tstruct bt_att *att = chan->att;\n\tstruct att_send_op *op = NULL;\n\n\tif (chan->pending_req && chan->pending_req->id == timeout->id) {\n\t\top = chan->pending_req;\n\t\tchan->pending_req = NULL;\n\t} else if (chan->pending_ind && chan->pending_ind->id == timeout->id) {\n\t\top = chan->pending_ind;\n\t\tchan->pending_ind = NULL;\n\t}\n\n\tif (!op)\n\t\treturn false;\n\n\tutil_debug(att->debug_callback, att->debug_data,\n\t\t\t\t\"(chan %p) Operation timed out: 0x%02x\",\n\t\t\t\tchan, op->opcode);\n\n\tif (att->timeout_callback)\n\t\tatt->timeout_callback(op->id, op->opcode, att->timeout_data);\n\n\top->timeout_id = 0;\n\tdisc_att_send_op(op);\n\n\t/*\n\t * Directly terminate the connection as required by the ATT protocol.\n\t * This should trigger an io disconnect event which will clean up the\n\t * io and notify the upper layer.\n\t */\n\tio_shutdown(chan->io);\n\n\treturn false;\n}\n\nstatic void write_watch_destroy(void *user_data)\n{\n\tstruct bt_att_chan *chan = user_data;\n\n\tchan->writer_active = false;\n}\n\nstatic ssize_t bt_att_chan_write(struct bt_att_chan *chan, uint8_t opcode,\n\t\t\t\t\tconst void *pdu, uint16_t len)\n{\n\tstruct bt_att *att = chan->att;\n\tssize_t ret;\n\tstruct iovec iov;\n\n\tiov.iov_base = (void *) pdu;\n\tiov.iov_len = len;\n\n\tutil_debug(att->debug_callback, att->debug_data,\n\t\t\t\t\t\"(chan %p) ATT op 0x%02x\",\n\t\t\t\t\tchan, opcode);\n\n\tret = io_send(chan->io, &iov, 1);\n\tif (ret < 0) {\n\t\tutil_debug(att->debug_callback, att->debug_data,\n\t\t\t\t\t\"(chan %p) write failed: %s\",\n\t\t\t\t\tchan, strerror(-ret));\n\n\t\treturn ret;\n\t}\n\n\tutil_hexdump('<', pdu, ret, att->debug_callback, att->debug_data);\n\n\treturn ret;\n}\n\nstatic bool can_write_data(struct io *io, void *user_data)\n{\n\tstruct bt_att_chan *chan = user_data;\n\tstruct att_send_op *op;\n\tstruct timeout_data *timeout;\n\n\top = pick_next_send_op(chan);\n\tif (!op)\n\t\treturn false;\n\n\tif (!bt_att_chan_write(chan, op->opcode, op->pdu, op->len)) {\n\t\tif (op->callback)\n\t\t\top->callback(BT_ATT_OP_ERROR_RSP, NULL, 0,\n\t\t\t\t\t\t\top->user_data);\n\t\tdestroy_att_send_op(op);\n\t\treturn true;\n\t}\n\n\t/* Based on the operation type, set either the pending request or the\n\t * pending indication. If it came from the write queue, then there is\n\t * no need to keep it around.\n\t */\n\tswitch (op->type) {\n\tcase ATT_OP_TYPE_REQ:\n\t\tchan->pending_req = op;\n\t\tbreak;\n\tcase ATT_OP_TYPE_IND:\n\t\tchan->pending_ind = op;\n\t\tbreak;\n\tcase ATT_OP_TYPE_RSP:\n\t\t/* Set in_req to false to indicate that no request is pending */\n\t\tchan->in_req = false;\n\t\t/* fall through */\n\tcase ATT_OP_TYPE_CMD:\n\tcase ATT_OP_TYPE_NFY:\n\tcase ATT_OP_TYPE_CONF:\n\tcase ATT_OP_TYPE_UNKNOWN:\n\tdefault:\n\t\tdestroy_att_send_op(op);\n\t\treturn true;\n\t}\n\n\ttimeout = new0(struct timeout_data, 1);\n\ttimeout->chan = chan;\n\ttimeout->id = op->id;\n\top->timeout_id = timeout_add(ATT_TIMEOUT_INTERVAL, timeout_cb,\n\t\t\t\t\t\t\t\ttimeout, free);\n\n\t/* Return true as there may be more operations ready to write. */\n\treturn true;\n}\n\nstatic void wakeup_chan_writer(void *data, void *user_data)\n{\n\tstruct bt_att_chan *chan = data;\n\tstruct bt_att *att = chan->att;\n\n\tif (chan->writer_active)\n\t\treturn;\n\n\t/* Set the write handler only if there is anything that can be sent\n\t * at all.\n\t */\n\tif (queue_isempty(chan->queue) && queue_isempty(att->write_queue)) {\n\t\tif ((chan->pending_req || queue_isempty(att->req_queue)) &&\n\t\t\t(chan->pending_ind || queue_isempty(att->ind_queue)))\n\t\t\treturn;\n\t}\n\n\tif (!io_set_write_handler(chan->io, can_write_data, chan,\n\t\t\t\t\t\t\twrite_watch_destroy))\n\t\treturn;\n\n\tchan->writer_active = true;\n}\n\nstatic void wakeup_writer(struct bt_att *att)\n{\n\tqueue_foreach(att->chans, wakeup_chan_writer, NULL);\n}\n\nstatic void disconn_handler(void *data, void *user_data)\n{\n\tstruct att_disconn *disconn = data;\n\tint err = PTR_TO_INT(user_data);\n\n\tif (disconn->removed)\n\t\treturn;\n\n\tif (disconn->callback)\n\t\tdisconn->callback(err, disconn->user_data);\n}\n\nstatic void bt_att_chan_free(void *data)\n{\n\tstruct bt_att_chan *chan = data;\n\n\tif (chan->pending_req)\n\t\tdestroy_att_send_op(chan->pending_req);\n\n\tif (chan->pending_ind)\n\t\tdestroy_att_send_op(chan->pending_ind);\n\n\tqueue_destroy(chan->queue, destroy_att_send_op);\n\n\tio_destroy(chan->io);\n\n\tfree(chan->buf);\n\tfree(chan);\n}\n\nstatic bool disconnect_cb(struct io *io, void *user_data)\n{\n\tstruct bt_att_chan *chan = user_data;\n\tstruct bt_att *att = chan->att;\n\tint err;\n\tsocklen_t len;\n\n\tlen = sizeof(err);\n\n\tif (getsockopt(chan->fd, SOL_SOCKET, SO_ERROR, &err, &len) < 0) {\n\t\tutil_debug(chan->att->debug_callback, chan->att->debug_data,\n\t\t\t\t\t\"(chan %p) Failed to obtain disconnect\"\n\t\t\t\t\t\" error: %s\", chan, strerror(errno));\n\t\terr = 0;\n\t}\n\n\tutil_debug(chan->att->debug_callback, chan->att->debug_data,\n\t\t\t\t\t\"Channel %p disconnected: %s\",\n\t\t\t\t\tchan, strerror(err));\n\n\t/* Dettach channel */\n\tqueue_remove(att->chans, chan);\n\n\tif (chan->pending_req) {\n\t\tdisc_att_send_op(chan->pending_req);\n\t\tchan->pending_req = NULL;\n\t}\n\n\tif (chan->pending_ind) {\n\t\tdisc_att_send_op(chan->pending_ind);\n\t\tchan->pending_ind = NULL;\n\t}\n\n\tbt_att_chan_free(chan);\n\n\t/* Don't run disconnect callback if there are channels left */\n\tif (!queue_isempty(att->chans))\n\t\treturn false;\n\n\tbt_att_ref(att);\n\n\tatt->in_disc = true;\n\n\t/* Notify request callbacks */\n\tqueue_remove_all(att->req_queue, NULL, NULL, disc_att_send_op);\n\tqueue_remove_all(att->ind_queue, NULL, NULL, disc_att_send_op);\n\tqueue_remove_all(att->write_queue, NULL, NULL, disc_att_send_op);\n\n\tatt->in_disc = false;\n\n\tqueue_foreach(att->disconn_list, disconn_handler, INT_TO_PTR(err));\n\n\tbt_att_unregister_all(att);\n\tbt_att_unref(att);\n\n\treturn false;\n}\n\nstatic int bt_att_chan_get_security(struct bt_att_chan *chan)\n{\n\tstruct bt_security sec;\n\tsocklen_t len;\n\n\tif (chan->type == BT_ATT_LOCAL)\n\t\treturn chan->sec_level;\n\n\tmemset(&sec, 0, sizeof(sec));\n\tlen = sizeof(sec);\n\tif (getsockopt(chan->fd, SOL_BLUETOOTH, BT_SECURITY, &sec, &len) < 0)\n\t\treturn -EIO;\n\n\treturn sec.level;\n}\n\nstatic bool bt_att_chan_set_security(struct bt_att_chan *chan, int level)\n{\n\tstruct bt_security sec;\n\n\tif (chan->type == BT_ATT_LOCAL) {\n\t\tchan->sec_level = level;\n\t\treturn true;\n\t}\n\n\tmemset(&sec, 0, sizeof(sec));\n\tsec.level = level;\n\n\tif (setsockopt(chan->fd, SOL_BLUETOOTH, BT_SECURITY, &sec,\n\t\t\t\t\t\t\tsizeof(sec)) < 0)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool change_security(struct bt_att_chan *chan, uint8_t ecode)\n{\n\tint security;\n\n\tif (chan->sec_level != BT_ATT_SECURITY_AUTO)\n\t\treturn false;\n\n\tsecurity = bt_att_chan_get_security(chan);\n\n\tif (ecode == BT_ATT_ERROR_INSUFFICIENT_ENCRYPTION &&\n\t\t\t\t\tsecurity < BT_ATT_SECURITY_MEDIUM) {\n\t\tsecurity = BT_ATT_SECURITY_MEDIUM;\n\t} else if (ecode == BT_ATT_ERROR_AUTHENTICATION) {\n\t\tif (security < BT_ATT_SECURITY_MEDIUM)\n\t\t\tsecurity = BT_ATT_SECURITY_MEDIUM;\n\t\telse if (security < BT_ATT_SECURITY_HIGH)\n\t\t\tsecurity = BT_ATT_SECURITY_HIGH;\n\t\telse if (security < BT_ATT_SECURITY_FIPS)\n\t\t\tsecurity = BT_ATT_SECURITY_FIPS;\n\t\telse\n\t\t\treturn false;\n\t} else {\n\t\treturn false;\n\t}\n\n\treturn bt_att_chan_set_security(chan, security);\n}\n\nstatic bool handle_error_rsp(struct bt_att_chan *chan, uint8_t *pdu,\n\t\t\t\t\tssize_t pdu_len, uint8_t *opcode)\n{\n\tstruct bt_att *att = chan->att;\n\tconst struct bt_att_pdu_error_rsp *rsp;\n\tstruct att_send_op *op = chan->pending_req;\n\n\tif (pdu_len != sizeof(*rsp)) {\n\t\t*opcode = 0;\n\t\treturn false;\n\t}\n\n\trsp = (void *) pdu;\n\n\t*opcode = rsp->opcode;\n\n\t/* Attempt to change security */\n\tif (!change_security(chan, rsp->ecode))\n\t\treturn false;\n\n\t/* Remove timeout_id if outstanding */\n\tif (op->timeout_id) {\n\t\ttimeout_remove(op->timeout_id);\n\t\top->timeout_id = 0;\n\t}\n\n\tutil_debug(att->debug_callback, att->debug_data,\n\t\t\t\t\t\t\"(chan %p) Retrying operation \"\n\t\t\t\t\t\t\"%p\", chan, op);\n\n\tchan->pending_req = NULL;\n\n\t/* Push operation back to request queue */\n\treturn queue_push_head(att->req_queue, op);\n}\n\nstatic void handle_rsp(struct bt_att_chan *chan, uint8_t opcode, uint8_t *pdu,\n\t\t\t\t\t\t\t\tssize_t pdu_len)\n{\n\tstruct bt_att *att = chan->att;\n\tstruct att_send_op *op = chan->pending_req;\n\tuint8_t req_opcode;\n\tuint8_t rsp_opcode;\n\tuint8_t *rsp_pdu = NULL;\n\tuint16_t rsp_pdu_len = 0;\n\n\t/*\n\t * If no request is pending, then the response is unexpected. Disconnect\n\t * the bearer.\n\t */\n\tif (!op) {\n\t\tutil_debug(att->debug_callback, att->debug_data,\n\t\t\t\t\t\"(chan %p) Received unexpected ATT \"\n\t\t\t\t\t\"response\", chan);\n\t\tio_shutdown(chan->io);\n\t\treturn;\n\t}\n\n\t/*\n\t * If the received response doesn't match the pending request, or if\n\t * the request is malformed, end the current request with failure.\n\t */\n\tif (opcode == BT_ATT_OP_ERROR_RSP) {\n\t\t/* Return if error response cause a retry */\n\t\tif (handle_error_rsp(chan, pdu, pdu_len, &req_opcode)) {\n\t\t\twakeup_chan_writer(chan, NULL);\n\t\t\treturn;\n\t\t}\n\t} else if (!(req_opcode = get_req_opcode(opcode)))\n\t\tgoto fail;\n\n\tif (req_opcode != op->opcode)\n\t\tgoto fail;\n\n\trsp_opcode = opcode;\n\n\tif (pdu_len > 0) {\n\t\trsp_pdu = pdu;\n\t\trsp_pdu_len = pdu_len;\n\t}\n\n\tgoto done;\n\nfail:\n\tutil_debug(att->debug_callback, att->debug_data,\n\t\t\t\"(chan %p) Failed to handle response PDU; opcode: \"\n\t\t\t\"0x%02x\", chan, opcode);\n\n\trsp_opcode = BT_ATT_OP_ERROR_RSP;\n\ndone:\n\tif (op->callback)\n\t\top->callback(rsp_opcode, rsp_pdu, rsp_pdu_len, op->user_data);\n\n\tdestroy_att_send_op(op);\n\tchan->pending_req = NULL;\n\n\twakeup_chan_writer(chan, NULL);\n}\n\nstatic void handle_conf(struct bt_att_chan *chan, uint8_t *pdu, ssize_t pdu_len)\n{\n\tstruct bt_att *att = chan->att;\n\tstruct att_send_op *op = chan->pending_ind;\n\n\t/*\n\t * Disconnect the bearer if the confirmation is unexpected or the PDU is\n\t * invalid.\n\t */\n\tif (!op || pdu_len) {\n\t\tutil_debug(att->debug_callback, att->debug_data,\n\t\t\t\t\"(chan %p) Received unexpected/invalid ATT \"\n\t\t\t\t\"confirmation\", chan);\n\t\tio_shutdown(chan->io);\n\t\treturn;\n\t}\n\n\tif (op->callback)\n\t\top->callback(BT_ATT_OP_HANDLE_CONF, NULL, 0, op->user_data);\n\n\tdestroy_att_send_op(op);\n\tchan->pending_ind = NULL;\n\n\twakeup_chan_writer(chan, NULL);\n}\n\nstruct notify_data {\n\tuint8_t opcode;\n\tuint8_t *pdu;\n\tssize_t pdu_len;\n\tbool handler_found;\n};\n\nstatic bool opcode_match(uint8_t opcode, uint8_t test_opcode)\n{\n\tenum att_op_type op_type = get_op_type(test_opcode);\n\n\tif (opcode == BT_ATT_ALL_REQUESTS && (op_type == ATT_OP_TYPE_REQ ||\n\t\t\t\t\t\top_type == ATT_OP_TYPE_CMD))\n\t\treturn true;\n\n\treturn opcode == test_opcode;\n}\n\nstatic void respond_not_supported(struct bt_att *att, uint8_t opcode)\n{\n\tstruct bt_att_pdu_error_rsp pdu;\n\n\tpdu.opcode = opcode;\n\tpdu.handle = 0x0000;\n\tpdu.ecode = BT_ATT_ERROR_REQUEST_NOT_SUPPORTED;\n\n\tbt_att_send(att, BT_ATT_OP_ERROR_RSP, &pdu, sizeof(pdu), NULL, NULL,\n\t\t\t\t\t\t\t\t\tNULL);\n}\n\nstatic bool handle_signed(struct bt_att *att, uint8_t *pdu, ssize_t pdu_len)\n{\n\tuint8_t *signature;\n\tuint32_t sign_cnt;\n\tstruct sign_info *sign;\n\tuint8_t opcode = pdu[0];\n\n\t/* Check if there is enough data for a signature */\n\tif (pdu_len < 3 + BT_ATT_SIGNATURE_LEN)\n\t\tgoto fail;\n\n\tsign = att->remote_sign;\n\tif (!sign)\n\t\tgoto fail;\n\n\tsignature = pdu + (pdu_len - BT_ATT_SIGNATURE_LEN);\n\tsign_cnt = get_le32(signature);\n\n\t/* Validate counter */\n\tif (!sign->counter(&sign_cnt, sign->user_data))\n\t\tgoto fail;\n\n\t/* Verify received signature */\n\tif (!bt_crypto_verify_att_sign(att->crypto, sign->key, pdu, pdu_len))\n\t\tgoto fail;\n\n\treturn true;\n\nfail:\n\tutil_debug(att->debug_callback, att->debug_data,\n\t\t\t\"ATT failed to verify signature: 0x%02x\", opcode);\n\n\treturn false;\n}\n\nstatic void handle_notify(struct bt_att_chan *chan, uint8_t *pdu,\n\t\t\t\t\t\t\tssize_t pdu_len)\n{\n\tstruct bt_att *att = chan->att;\n\tconst struct queue_entry *entry;\n\tbool found;\n\tuint8_t opcode = pdu[0];\n\n\tbt_att_ref(att);\n\n\tfound = false;\n\tentry = queue_get_entries(att->notify_list);\n\n\twhile (entry) {\n\t\tstruct att_notify *notify = entry->data;\n\n\t\tentry = entry->next;\n\n\t\tif (!opcode_match(notify->opcode, opcode))\n\t\t\tcontinue;\n\n\t\tif ((opcode & ATT_OP_SIGNED_MASK) && att->crypto) {\n\t\t\tif (!handle_signed(att, pdu, pdu_len))\n\t\t\t\treturn;\n\t\t\tpdu_len -= BT_ATT_SIGNATURE_LEN;\n\t\t}\n\n\t\t/* BLUETOOTH CORE SPECIFICATION Version 5.1 | Vol 3, Part G\n\t\t * page 2370\n\t\t *\n\t\t * 4.3.1 Exchange MTU\n\t\t *\n\t\t * This sub-procedure shall not be used on a BR/EDR physical\n\t\t * link since the MTU size is negotiated using L2CAP channel\n\t\t * configuration procedures.\n\t\t */\n\t\tif (bt_att_get_link_type(att) == BT_ATT_BREDR) {\n\t\t\tswitch (opcode) {\n\t\t\tcase BT_ATT_OP_MTU_REQ:\n\t\t\t\tgoto not_supported;\n\t\t\t}\n\t\t}\n\n\t\tfound = true;\n\n\t\tif (notify->callback)\n\t\t\tnotify->callback(chan, opcode, pdu + 1, pdu_len - 1,\n\t\t\t\t\t\t\tnotify->user_data);\n\n\t\t/* callback could remove all entries from notify list */\n\t\tif (queue_isempty(att->notify_list))\n\t\t\tbreak;\n\t}\n\nnot_supported:\n\t/*\n\t * If this was not a command and no handler was registered for it,\n\t * respond with \"Not Supported\"\n\t */\n\tif (!found && get_op_type(opcode) != ATT_OP_TYPE_CMD)\n\t\trespond_not_supported(att, opcode);\n\n\tbt_att_unref(att);\n}\n\nstatic bool can_read_data(struct io *io, void *user_data)\n{\n\tstruct bt_att_chan *chan = user_data;\n\tstruct bt_att *att = chan->att;\n\tuint8_t opcode;\n\tuint8_t *pdu;\n\tssize_t bytes_read;\n\n\tbytes_read = read(chan->fd, chan->buf, chan->mtu);\n\tif (bytes_read < 0)\n\t\treturn false;\n\n\tutil_debug(att->debug_callback, att->debug_data,\n\t\t\t\t\"(chan %p) ATT received: %zd\",\n\t\t\t\tchan, bytes_read);\n\n\tutil_hexdump('>', chan->buf, bytes_read,\n\t\t\t\tatt->debug_callback, att->debug_data);\n\n\tif (bytes_read < ATT_MIN_PDU_LEN)\n\t\treturn true;\n\n\tpdu = chan->buf;\n\topcode = pdu[0];\n\n\tbt_att_ref(att);\n\n\t/* Act on the received PDU based on the opcode type */\n\tswitch (get_op_type(opcode)) {\n\tcase ATT_OP_TYPE_RSP:\n\t\tutil_debug(att->debug_callback, att->debug_data,\n\t\t\t\t\"(chan %p) ATT response received: 0x%02x\",\n\t\t\t\tchan, opcode);\n\t\thandle_rsp(chan, opcode, pdu + 1, bytes_read - 1);\n\t\tbreak;\n\tcase ATT_OP_TYPE_CONF:\n\t\tutil_debug(att->debug_callback, att->debug_data,\n\t\t\t\t\"(chan %p) ATT confirmation received: 0x%02x\",\n\t\t\t\tchan, opcode);\n\t\thandle_conf(chan, pdu + 1, bytes_read - 1);\n\t\tbreak;\n\tcase ATT_OP_TYPE_REQ:\n\t\t/*\n\t\t * If a request is currently pending, then the sequential\n\t\t * protocol was violated. Disconnect the bearer, which will\n\t\t * promptly notify the upper layer via disconnect handlers.\n\t\t */\n\t\tif (chan->in_req) {\n\t\t\tutil_debug(att->debug_callback, att->debug_data,\n\t\t\t\t\t\"(chan %p) Received request while \"\n\t\t\t\t\t\"another is pending: 0x%02x\",\n\t\t\t\t\tchan, opcode);\n\t\t\tio_shutdown(chan->io);\n\t\t\tbt_att_unref(chan->att);\n\n\t\t\treturn false;\n\t\t}\n\n\t\tchan->in_req = true;\n\t\t/* fall through */\n\tcase ATT_OP_TYPE_CMD:\n\tcase ATT_OP_TYPE_NFY:\n\tcase ATT_OP_TYPE_UNKNOWN:\n\tcase ATT_OP_TYPE_IND:\n\t\t/* fall through */\n\tdefault:\n\t\t/* For all other opcodes notify the upper layer of the PDU and\n\t\t * let them act on it.\n\t\t */\n\t\tutil_debug(att->debug_callback, att->debug_data,\n\t\t\t\t\t\"(chan %p) ATT PDU received: 0x%02x\",\n\t\t\t\t\tchan, opcode);\n\t\thandle_notify(chan, pdu, bytes_read);\n\t\tbreak;\n\t}\n\n\tbt_att_unref(att);\n\n\treturn true;\n}\n\nstatic bool is_io_l2cap_based(int fd)\n{\n\tint domain;\n\tint proto;\n\tint err;\n\tsocklen_t len;\n\n\tdomain = 0;\n\tlen = sizeof(domain);\n\terr = getsockopt(fd, SOL_SOCKET, SO_DOMAIN, &domain, &len);\n\tif (err < 0)\n\t\treturn false;\n\n\tif (domain != AF_BLUETOOTH)\n\t\treturn false;\n\n\tproto = 0;\n\tlen = sizeof(proto);\n\terr = getsockopt(fd, SOL_SOCKET, SO_PROTOCOL, &proto, &len);\n\tif (err < 0)\n\t\treturn false;\n\n\treturn proto == BTPROTO_L2CAP;\n}\n\nstatic void bt_att_free(struct bt_att *att)\n{\n\tbt_crypto_unref(att->crypto);\n\n\tif (att->timeout_destroy)\n\t\tatt->timeout_destroy(att->timeout_data);\n\n\tif (att->debug_destroy)\n\t\tatt->debug_destroy(att->debug_data);\n\n\tfree(att->local_sign);\n\tfree(att->remote_sign);\n\n\tqueue_destroy(att->req_queue, NULL);\n\tqueue_destroy(att->ind_queue, NULL);\n\tqueue_destroy(att->write_queue, NULL);\n\tqueue_destroy(att->notify_list, NULL);\n\tqueue_destroy(att->disconn_list, NULL);\n\tqueue_destroy(att->chans, bt_att_chan_free);\n\n\tfree(att);\n}\n\nstatic uint16_t io_get_mtu(int fd)\n{\n\tsocklen_t len;\n\tstruct l2cap_options l2o;\n\n\tlen = sizeof(l2o);\n\tif (!getsockopt(fd, SOL_L2CAP, L2CAP_OPTIONS, &l2o, &len))\n\t\treturn l2o.omtu;\n\n\tif (!getsockopt(fd, SOL_BLUETOOTH, BT_SNDMTU, &l2o.omtu, &len))\n\t\treturn l2o.omtu;\n\n\treturn 0;\n}\n\nstatic uint8_t io_get_type(int fd)\n{\n\tstruct sockaddr_l2 src;\n\tsocklen_t len;\n\n\tif (!is_io_l2cap_based(fd))\n\t\treturn BT_ATT_LOCAL;\n\n\tlen = sizeof(src);\n\tmemset(&src, 0, len);\n\tif (getsockname(fd, (void *)&src, &len) < 0)\n\t\treturn -errno;\n\n\tif (src.l2_bdaddr_type == BDADDR_BREDR)\n\t\treturn BT_ATT_BREDR;\n\n\treturn BT_ATT_LE;\n}\n\nstatic struct bt_att_chan *bt_att_chan_new(int fd, uint8_t type)\n{\n\tstruct bt_att_chan *chan;\n\n\tif (fd < 0)\n\t\treturn NULL;\n\n\tchan = new0(struct bt_att_chan, 1);\n\tchan->fd = fd;\n\n\tchan->io = io_new(fd);\n\tif (!chan->io)\n\t\tgoto fail;\n\n\tif (!io_set_read_handler(chan->io, can_read_data, chan, NULL))\n\t\tgoto fail;\n\n\tif (!io_set_disconnect_handler(chan->io, disconnect_cb, chan, NULL))\n\t\tgoto fail;\n\n\tchan->type = type;\n\tswitch (chan->type) {\n\tcase BT_ATT_LOCAL:\n\t\tchan->sec_level = BT_ATT_SECURITY_LOW;\n\t\t/* fall through */\n\tcase BT_ATT_LE:\n\t\tchan->mtu = BT_ATT_DEFAULT_LE_MTU;\n\t\tbreak;\n\tdefault:\n\t\tchan->mtu = io_get_mtu(chan->fd);\n\t}\n\n\tif (chan->mtu < BT_ATT_DEFAULT_LE_MTU)\n\t\tgoto fail;\n\n\tchan->buf = malloc(chan->mtu);\n\tif (!chan->buf)\n\t\tgoto fail;\n\n\tchan->queue = queue_new();\n\n\treturn chan;\n\nfail:\n\tbt_att_chan_free(chan);\n\n\treturn NULL;\n}\n\nstatic void bt_att_attach_chan(struct bt_att *att, struct bt_att_chan *chan)\n{\n\t/* Push to head as EATT channels have higher priority */\n\tqueue_push_head(att->chans, chan);\n\tchan->att = att;\n\n\tif (chan->mtu > att->mtu)\n\t\tatt->mtu = chan->mtu;\n\n\tio_set_close_on_destroy(chan->io, att->close_on_unref);\n\n\tutil_debug(att->debug_callback, att->debug_data, \"Channel %p attached\",\n\t\t\t\t\t\t\t\t\tchan);\n\n\twakeup_chan_writer(chan, NULL);\n}\n\nstruct bt_att *bt_att_new(int fd, bool ext_signed)\n{\n\tstruct bt_att *att;\n\tstruct bt_att_chan *chan;\n\n\tchan = bt_att_chan_new(fd, io_get_type(fd));\n\tif (!chan)\n\t\treturn NULL;\n\n\tatt = new0(struct bt_att, 1);\n\tatt->chans = queue_new();\n\tatt->mtu = chan->mtu;\n\n\t/* crypto is optional, if not available leave it NULL */\n\tif (!ext_signed)\n\t\tatt->crypto = bt_crypto_new();\n\n\tatt->req_queue = queue_new();\n\tatt->ind_queue = queue_new();\n\tatt->write_queue = queue_new();\n\tatt->notify_list = queue_new();\n\tatt->disconn_list = queue_new();\n\n\tbt_att_attach_chan(att, chan);\n\n\treturn bt_att_ref(att);\n}\n\nstruct bt_att *bt_att_ref(struct bt_att *att)\n{\n\tif (!att)\n\t\treturn NULL;\n\n\t__sync_fetch_and_add(&att->ref_count, 1);\n\n\treturn att;\n}\n\nvoid bt_att_unref(struct bt_att *att)\n{\n\tif (!att)\n\t\treturn;\n\n\tif (__sync_sub_and_fetch(&att->ref_count, 1))\n\t\treturn;\n\n\tbt_att_unregister_all(att);\n\tbt_att_cancel_all(att);\n\n\tbt_att_free(att);\n}\n\nbool bt_att_set_close_on_unref(struct bt_att *att, bool do_close)\n{\n\tconst struct queue_entry *entry;\n\n\tif (!att)\n\t\treturn false;\n\n\tatt->close_on_unref = do_close;\n\n\tfor (entry = queue_get_entries(att->chans); entry;\n\t\t\t\t\t\tentry = entry->next) {\n\t\tstruct bt_att_chan *chan = entry->data;\n\n\t\tif (!io_set_close_on_destroy(chan->io, do_close))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nint bt_att_attach_fd(struct bt_att *att, int fd)\n{\n\tstruct bt_att_chan *chan;\n\n\tif (!att || fd < 0)\n\t\treturn -EINVAL;\n\n\tchan = bt_att_chan_new(fd, BT_ATT_EATT);\n\tif (!chan)\n\t\treturn -EINVAL;\n\n\tbt_att_attach_chan(att, chan);\n\n\treturn 0;\n}\n\nint bt_att_get_fd(struct bt_att *att)\n{\n\tstruct bt_att_chan *chan;\n\n\tif (!att)\n\t\treturn -1;\n\n\tif (queue_isempty(att->chans))\n\t\treturn -ENOTCONN;\n\n\tchan = queue_peek_tail(att->chans);\n\n\treturn chan->fd;\n}\n\nint bt_att_get_channels(struct bt_att *att)\n{\n\tif (!att)\n\t\treturn 0;\n\n\treturn queue_length(att->chans);\n}\n\nbool bt_att_set_debug(struct bt_att *att, bt_att_debug_func_t callback,\n\t\t\t\tvoid *user_data, bt_att_destroy_func_t destroy)\n{\n\tif (!att)\n\t\treturn false;\n\n\tif (att->debug_destroy)\n\t\tatt->debug_destroy(att->debug_data);\n\n\tatt->debug_callback = callback;\n\tatt->debug_destroy = destroy;\n\tatt->debug_data = user_data;\n\n\treturn true;\n}\n\nuint16_t bt_att_get_mtu(struct bt_att *att)\n{\n\tif (!att)\n\t\treturn 0;\n\n\treturn att->mtu;\n}\n\nbool bt_att_set_mtu(struct bt_att *att, uint16_t mtu)\n{\n\tstruct bt_att_chan *chan;\n\tvoid *buf;\n\n\tif (!att)\n\t\treturn false;\n\n\tif (mtu < BT_ATT_DEFAULT_LE_MTU)\n\t\treturn false;\n\n\t/* Original channel is always the last */\n\tchan = queue_peek_tail(att->chans);\n\tif (!chan)\n\t\treturn -ENOTCONN;\n\n\tbuf = malloc(mtu);\n\tif (!buf)\n\t\treturn false;\n\n\tfree(chan->buf);\n\n\tchan->mtu = mtu;\n\tchan->buf = buf;\n\n\tif (chan->mtu > att->mtu)\n\t\tatt->mtu = chan->mtu;\n\n\treturn true;\n}\n\nuint8_t bt_att_get_link_type(struct bt_att *att)\n{\n\tstruct bt_att_chan *chan;\n\n\tif (!att)\n\t\treturn -EINVAL;\n\n\tchan = queue_peek_tail(att->chans);\n\tif (!chan)\n\t\treturn -ENOTCONN;\n\n\treturn chan->type;\n}\n\nbool bt_att_set_timeout_cb(struct bt_att *att, bt_att_timeout_func_t callback,\n\t\t\t\t\t\tvoid *user_data,\n\t\t\t\t\t\tbt_att_destroy_func_t destroy)\n{\n\tif (!att)\n\t\treturn false;\n\n\tif (att->timeout_destroy)\n\t\tatt->timeout_destroy(att->timeout_data);\n\n\tatt->timeout_callback = callback;\n\tatt->timeout_destroy = destroy;\n\tatt->timeout_data = user_data;\n\n\treturn true;\n}\n\nunsigned int bt_att_register_disconnect(struct bt_att *att,\n\t\t\t\t\tbt_att_disconnect_func_t callback,\n\t\t\t\t\tvoid *user_data,\n\t\t\t\t\tbt_att_destroy_func_t destroy)\n{\n\tstruct att_disconn *disconn;\n\n\tif (!att || queue_isempty(att->chans))\n\t\treturn 0;\n\n\tdisconn = new0(struct att_disconn, 1);\n\tdisconn->callback = callback;\n\tdisconn->destroy = destroy;\n\tdisconn->user_data = user_data;\n\n\tif (att->next_reg_id < 1)\n\t\tatt->next_reg_id = 1;\n\n\tdisconn->id = att->next_reg_id++;\n\n\tif (!queue_push_tail(att->disconn_list, disconn)) {\n\t\tfree(disconn);\n\t\treturn 0;\n\t}\n\n\treturn disconn->id;\n}\n\nbool bt_att_unregister_disconnect(struct bt_att *att, unsigned int id)\n{\n\tstruct att_disconn *disconn;\n\n\tif (!att || !id)\n\t\treturn false;\n\n\t/* Check if disconnect is running */\n\tif (queue_isempty(att->chans)) {\n\t\tdisconn = queue_find(att->disconn_list, match_disconn_id,\n\t\t\t\t\t\t\tUINT_TO_PTR(id));\n\t\tif (!disconn)\n\t\t\treturn false;\n\n\t\tdisconn->removed = true;\n\t\treturn true;\n\t}\n\n\tdisconn = queue_remove_if(att->disconn_list, match_disconn_id,\n\t\t\t\t\t\t\tUINT_TO_PTR(id));\n\tif (!disconn)\n\t\treturn false;\n\n\tdestroy_att_disconn(disconn);\n\treturn true;\n}\n\nunsigned int bt_att_send(struct bt_att *att, uint8_t opcode,\n\t\t\t\tconst void *pdu, uint16_t length,\n\t\t\t\tbt_att_response_func_t callback, void *user_data,\n\t\t\t\tbt_att_destroy_func_t destroy)\n{\n\tstruct att_send_op *op;\n\tbool result;\n\n\tif (!att || queue_isempty(att->chans))\n\t\treturn 0;\n\n\top = create_att_send_op(att, opcode, pdu, length, callback, user_data,\n\t\t\t\t\t\t\t\tdestroy);\n\tif (!op)\n\t\treturn 0;\n\n\tif (att->next_send_id < 1)\n\t\tatt->next_send_id = 1;\n\n\top->id = att->next_send_id++;\n\n\t/* Add the op to the correct queue based on its type */\n\tswitch (op->type) {\n\tcase ATT_OP_TYPE_REQ:\n\t\tresult = queue_push_tail(att->req_queue, op);\n\t\tbreak;\n\tcase ATT_OP_TYPE_IND:\n\t\tresult = queue_push_tail(att->ind_queue, op);\n\t\tbreak;\n\tcase ATT_OP_TYPE_CMD:\n\tcase ATT_OP_TYPE_NFY:\n\tcase ATT_OP_TYPE_UNKNOWN:\n\tcase ATT_OP_TYPE_RSP:\n\tcase ATT_OP_TYPE_CONF:\n\tdefault:\n\t\tresult = queue_push_tail(att->write_queue, op);\n\t\tbreak;\n\t}\n\n\tif (!result) {\n\t\tfree(op->pdu);\n\t\tfree(op);\n\t\treturn 0;\n\t}\n\n\twakeup_writer(att);\n\n\treturn op->id;\n}\n\nunsigned int bt_att_chan_send(struct bt_att_chan *chan, uint8_t opcode,\n\t\t\t\tconst void *pdu, uint16_t len,\n\t\t\t\tbt_att_response_func_t callback,\n\t\t\t\tvoid *user_data,\n\t\t\t\tbt_att_destroy_func_t destroy)\n{\n\tstruct att_send_op *op;\n\n\tif (!chan || !chan->att)\n\t\treturn -EINVAL;\n\n\top = create_att_send_op(chan->att, opcode, pdu, len, callback,\n\t\t\t\t\t\tuser_data, destroy);\n\tif (!op)\n\t\treturn -EINVAL;\n\n\tif (!queue_push_tail(chan->queue, op)) {\n\t\tfree(op->pdu);\n\t\tfree(op);\n\t\treturn 0;\n\t}\n\n\twakeup_chan_writer(chan, NULL);\n\n\treturn op->id;\n}\n\nstatic bool match_op_id(const void *a, const void *b)\n{\n\tconst struct att_send_op *op = a;\n\tunsigned int id = PTR_TO_UINT(b);\n\n\treturn op->id == id;\n}\n\nbool bt_att_chan_cancel(struct bt_att_chan *chan, unsigned int id)\n{\n\tstruct att_send_op *op;\n\n\tif (chan->pending_req && chan->pending_req->id == id) {\n\t\t/* Don't cancel the pending request; remove it's handlers */\n\t\tcancel_att_send_op(chan->pending_req);\n\t\treturn true;\n\t}\n\n\tif (chan->pending_ind && chan->pending_ind->id == id) {\n\t\t/* Don't cancel the pending indication; remove it's handlers. */\n\t\tcancel_att_send_op(chan->pending_ind);\n\t\treturn true;\n\t}\n\n\top = queue_remove_if(chan->queue, match_op_id, UINT_TO_PTR(id));\n\tif (!op)\n\t\treturn false;\n\n\tdestroy_att_send_op(op);\n\n\twakeup_chan_writer(chan, NULL);\n\n\treturn true;\n}\n\nstatic bool bt_att_disc_cancel(struct bt_att *att, unsigned int id)\n{\n\tstruct att_send_op *op;\n\n\top = queue_find(att->req_queue, match_op_id, UINT_TO_PTR(id));\n\tif (op)\n\t\tgoto done;\n\n\top = queue_find(att->ind_queue, match_op_id, UINT_TO_PTR(id));\n\tif (op)\n\t\tgoto done;\n\n\top = queue_find(att->write_queue, match_op_id, UINT_TO_PTR(id));\n\ndone:\n\tif (!op)\n\t\treturn false;\n\n\t/* Just cancel since disconnect_cb will be cleaning up */\n\tcancel_att_send_op(op);\n\n\treturn true;\n}\n\nbool bt_att_cancel(struct bt_att *att, unsigned int id)\n{\n\tconst struct queue_entry *entry;\n\tstruct att_send_op *op;\n\n\tif (!att || !id)\n\t\treturn false;\n\n\t/* Lookuo request on each channel first */\n\tfor (entry = queue_get_entries(att->chans); entry;\n\t\t\t\t\t\tentry = entry->next) {\n\t\tstruct bt_att_chan *chan = entry->data;\n\n\t\tif (bt_att_chan_cancel(chan, id))\n\t\t\treturn true;\n\t}\n\n\tif (att->in_disc)\n\t\treturn bt_att_disc_cancel(att, id);\n\n\top = queue_remove_if(att->req_queue, match_op_id, UINT_TO_PTR(id));\n\tif (op)\n\t\tgoto done;\n\n\top = queue_remove_if(att->ind_queue, match_op_id, UINT_TO_PTR(id));\n\tif (op)\n\t\tgoto done;\n\n\top = queue_remove_if(att->write_queue, match_op_id, UINT_TO_PTR(id));\n\tif (op)\n\t\tgoto done;\n\n\tif (!op)\n\t\treturn false;\n\ndone:\n\tdestroy_att_send_op(op);\n\n\twakeup_writer(att);\n\n\treturn true;\n}\n\nbool bt_att_cancel_all(struct bt_att *att)\n{\n\tconst struct queue_entry *entry;\n\n\tif (!att)\n\t\treturn false;\n\n\tqueue_remove_all(att->req_queue, NULL, NULL, destroy_att_send_op);\n\tqueue_remove_all(att->ind_queue, NULL, NULL, destroy_att_send_op);\n\tqueue_remove_all(att->write_queue, NULL, NULL, destroy_att_send_op);\n\n\tfor (entry = queue_get_entries(att->chans); entry;\n\t\t\t\t\t\tentry = entry->next) {\n\t\tstruct bt_att_chan *chan = entry->data;\n\n\t\tif (chan->pending_req)\n\t\t\t/* Don't cancel the pending request; remove it's\n\t\t\t * handlers\n\t\t\t */\n\t\t\tcancel_att_send_op(chan->pending_req);\n\n\t\tif (chan->pending_ind)\n\t\t\t/* Don't cancel the pending request; remove it's\n\t\t\t * handlers\n\t\t\t */\n\t\t\tcancel_att_send_op(chan->pending_ind);\n\t}\n\n\treturn true;\n}\n\nstatic uint8_t att_ecode_from_error(int err)\n{\n\t/*\n\t * If the error fits in a single byte, treat it as an ATT protocol\n\t * error as is. Since \"0\" is not a valid ATT protocol error code, we map\n\t * that to UNLIKELY below.\n\t */\n\tif (err > 0 && err < UINT8_MAX)\n\t\treturn err;\n\n\t/*\n\t * Since we allow UNIX errnos, map them to appropriate ATT protocol\n\t * and \"Common Profile and Service\" error codes.\n\t */\n\tswitch (err) {\n\tcase -ENOENT:\n\t\treturn BT_ATT_ERROR_INVALID_HANDLE;\n\tcase -ENOMEM:\n\t\treturn BT_ATT_ERROR_INSUFFICIENT_RESOURCES;\n\tcase -EALREADY:\n\t\treturn BT_ERROR_ALREADY_IN_PROGRESS;\n\tcase -EOVERFLOW:\n\t\treturn BT_ERROR_OUT_OF_RANGE;\n\t}\n\n\treturn BT_ATT_ERROR_UNLIKELY;\n}\n\nint bt_att_chan_send_error_rsp(struct bt_att_chan *chan, uint8_t opcode,\n\t\t\t\t\t\tuint16_t handle, int error)\n{\n\tstruct bt_att_pdu_error_rsp pdu;\n\tuint8_t ecode;\n\n\tif (!chan || !chan->att || !opcode)\n\t\treturn -EINVAL;\n\n\tecode = att_ecode_from_error(error);\n\n\tmemset(&pdu, 0, sizeof(pdu));\n\n\tpdu.opcode = opcode;\n\tput_le16(handle, &pdu.handle);\n\tpdu.ecode = ecode;\n\n\treturn bt_att_chan_send_rsp(chan, BT_ATT_OP_ERROR_RSP, &pdu,\n\t\t\t\t\t\t\tsizeof(pdu));\n}\n\nunsigned int bt_att_register(struct bt_att *att, uint8_t opcode,\n\t\t\t\t\t\tbt_att_notify_func_t callback,\n\t\t\t\t\t\tvoid *user_data,\n\t\t\t\t\t\tbt_att_destroy_func_t destroy)\n{\n\tstruct att_notify *notify;\n\n\tif (!att || !callback || queue_isempty(att->chans))\n\t\treturn 0;\n\n\tnotify = new0(struct att_notify, 1);\n\tnotify->opcode = opcode;\n\tnotify->callback = callback;\n\tnotify->destroy = destroy;\n\tnotify->user_data = user_data;\n\n\tif (att->next_reg_id < 1)\n\t\tatt->next_reg_id = 1;\n\n\tnotify->id = att->next_reg_id++;\n\n\tif (!queue_push_tail(att->notify_list, notify)) {\n\t\tfree(notify);\n\t\treturn 0;\n\t}\n\n\treturn notify->id;\n}\n\nbool bt_att_unregister(struct bt_att *att, unsigned int id)\n{\n\tstruct att_notify *notify;\n\n\tif (!att || !id)\n\t\treturn false;\n\n\tnotify = queue_remove_if(att->notify_list, match_notify_id,\n\t\t\t\t\t\t\tUINT_TO_PTR(id));\n\tif (!notify)\n\t\treturn false;\n\n\tdestroy_att_notify(notify);\n\treturn true;\n}\n\nbool bt_att_unregister_all(struct bt_att *att)\n{\n\tif (!att)\n\t\treturn false;\n\n\tqueue_remove_all(att->notify_list, NULL, NULL, destroy_att_notify);\n\tqueue_remove_all(att->disconn_list, NULL, NULL, destroy_att_disconn);\n\n\treturn true;\n}\n\nint bt_att_get_security(struct bt_att *att, uint8_t *enc_size)\n{\n\tstruct bt_att_chan *chan;\n\tint ret;\n\n\tif (!att)\n\t\treturn -EINVAL;\n\n\tchan = queue_peek_tail(att->chans);\n\tif (!chan)\n\t\treturn -ENOTCONN;\n\n\tret = bt_att_chan_get_security(chan);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (enc_size)\n\t\t*enc_size = att->enc_size;\n\n\treturn ret;\n}\n\nbool bt_att_set_security(struct bt_att *att, int level)\n{\n\tstruct bt_att_chan *chan;\n\n\tif (!att || level < BT_ATT_SECURITY_AUTO ||\n\t\t\t\t\t\tlevel > BT_ATT_SECURITY_HIGH)\n\t\treturn false;\n\n\tchan = queue_peek_tail(att->chans);\n\tif (!chan)\n\t\treturn -ENOTCONN;\n\n\treturn bt_att_chan_set_security(chan, level);\n}\n\nvoid bt_att_set_enc_key_size(struct bt_att *att, uint8_t enc_size)\n{\n\tif (!att)\n\t\treturn;\n\n\tatt->enc_size = enc_size;\n}\n\nstatic bool sign_set_key(struct sign_info **sign, uint8_t key[16],\n\t\t\t\tbt_att_counter_func_t func, void *user_data)\n{\n\tif (!(*sign))\n\t\t*sign = new0(struct sign_info, 1);\n\n\t(*sign)->counter = func;\n\t(*sign)->user_data = user_data;\n\tmemcpy((*sign)->key, key, 16);\n\n\treturn true;\n}\n\nbool bt_att_set_local_key(struct bt_att *att, uint8_t sign_key[16],\n\t\t\t\tbt_att_counter_func_t func, void *user_data)\n{\n\tif (!att)\n\t\treturn false;\n\n\treturn sign_set_key(&att->local_sign, sign_key, func, user_data);\n}\n\nbool bt_att_set_remote_key(struct bt_att *att, uint8_t sign_key[16],\n\t\t\t\tbt_att_counter_func_t func, void *user_data)\n{\n\tif (!att)\n\t\treturn false;\n\n\treturn sign_set_key(&att->remote_sign, sign_key, func, user_data);\n}\n\nbool bt_att_has_crypto(struct bt_att *att)\n{\n\tif (!att)\n\t\treturn false;\n\n\treturn att->crypto ? true : false;\n}\n"], "filenames": ["src/shared/att.c"], "buggy_code_start_loc": [86], "buggy_code_end_loc": [1592], "fixing_code_start_loc": [87], "fixing_code_end_loc": [1627], "type": "CWE-415", "message": "In BlueZ before 5.55, a double free was found in the gatttool disconnect_cb() routine from shared/att.c. A remote attacker could potentially cause a denial of service or code execution, during service discovery, due to a redundant disconnect MGMT event.", "other": {"cve": {"id": "CVE-2020-27153", "sourceIdentifier": "cve@mitre.org", "published": "2020-10-15T03:15:12.120", "lastModified": "2022-04-05T15:59:37.327", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In BlueZ before 5.55, a double free was found in the gatttool disconnect_cb() routine from shared/att.c. A remote attacker could potentially cause a denial of service or code execution, during service discovery, due to a redundant disconnect MGMT event."}, {"lang": "es", "value": "En BlueZ versiones anteriores a 5.55, se encontr\u00f3 una doble liberaci\u00f3n en la rutina disconnect_cb() de gatttool del archivo shared/att.c.&#xa0;Un atacante remoto podr\u00eda potencialmente causar una denegaci\u00f3n de servicio o una ejecuci\u00f3n de c\u00f3digo, durante la detecci\u00f3n del servicio, debido a un evento MGMT de desconexi\u00f3n redundante"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "HIGH", "baseScore": 8.6, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 4.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-415"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:bluez:bluez:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.55", "matchCriteriaId": "39E80B2D-248F-4CD2-9959-2C1B199C7667"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.1:*:*:*:*:*:*:*", "matchCriteriaId": "B620311B-34A3-48A6-82DF-6F078D7A4493"}, {"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.2:*:*:*:*:*:*:*", "matchCriteriaId": "B009C22E-30A4-4288-BCF6-C3E81DEAF45A"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2020-11/msg00034.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2020-11/msg00036.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1884817", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/bluez/bluez/commit/1cd644db8c23a2f530ddb93cebed7dacc5f5721a", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/bluez/bluez/commit/5a180f2ec9edfacafd95e5fed20d36fe8e077f07", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/10/msg00022.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202011-01", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2021/dsa-4951", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/bluez/bluez/commit/1cd644db8c23a2f530ddb93cebed7dacc5f5721a"}}