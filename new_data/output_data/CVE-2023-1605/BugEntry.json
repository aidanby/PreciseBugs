{"buggy_code": ["/* radare - LGPL - Copyright 2014-2019 - Fedor Sakharov */\n\n#include <r_bin.h>\n#include <sdb/ht_uu.h>\n\n#include \"coff/coff.h\"\n\nstatic Sdb* get_sdb(RBinFile *bf) {\n\tstruct r_bin_coff_obj *bin = (struct r_bin_coff_obj *) R_UNWRAP3 (bf, o, bin_obj);\n\treturn bin? bin->kv: NULL;\n}\n\nstatic bool r_coff_is_stripped(struct r_bin_coff_obj *obj) {\n\treturn !!(obj->hdr.f_flags & (COFF_FLAGS_TI_F_RELFLG | \\\n\t\tCOFF_FLAGS_TI_F_LNNO | COFF_FLAGS_TI_F_LSYMS));\n}\n\nstatic bool load_buffer(RBinFile *bf, void **bin_obj, RBuffer *buf, ut64 loadaddr, Sdb *sdb) {\n\t*bin_obj = r_bin_coff_new_buf (buf, bf->rbin->verbose);\n\treturn *bin_obj;\n}\n\nstatic void destroy(RBinFile *bf) {\n\tr_bin_coff_free ((struct r_bin_coff_obj*)bf->o->bin_obj);\n}\n\nstatic RBinAddr *binsym(RBinFile *bf, int sym) {\n\treturn NULL;\n}\n\n#define DTYPE_IS_FUNCTION(type)\t(COFF_SYM_GET_DTYPE (type) == COFF_SYM_DTYPE_FUNCTION)\n\nstatic bool _fill_bin_symbol(RBin *rbin, struct r_bin_coff_obj *bin, int idx, RBinSymbol **sym) {\n\tRBinSymbol *ptr = *sym;\n\tstruct coff_symbol *s = NULL;\n\tstruct coff_scn_hdr *sc_hdr = NULL;\n\tif (idx < 0 || idx > bin->hdr.f_nsyms) {\n\t\treturn false;\n\t}\n\tif (!bin->symbols) {\n\t\treturn false;\n\t}\n\ts = &bin->symbols[idx];\n\tchar *coffname = r_coff_symbol_name (bin, s);\n\tif (!coffname) {\n\t\treturn false;\n\t}\n\tptr->name = coffname;\n\tptr->forwarder = \"NONE\";\n\tptr->bind = R_BIN_BIND_LOCAL_STR;\n\tptr->is_imported = false;\n\tif (s->n_scnum < bin->hdr.f_nscns + 1 && s->n_scnum > 0) {\n\t\t//first index is 0 that is why -1\n\t\tsc_hdr = &bin->scn_hdrs[s->n_scnum - 1];\n\t\tptr->paddr = sc_hdr->s_scnptr + s->n_value;\n\t\tif (bin->scn_va) {\n\t\t\tptr->vaddr = bin->scn_va[s->n_scnum - 1] + s->n_value;\n\t\t}\n\t}\n\n\tswitch (s->n_sclass) {\n\tcase COFF_SYM_CLASS_FUNCTION:\n\t\tptr->type = R_BIN_TYPE_FUNC_STR;\n\t\tbreak;\n\tcase COFF_SYM_CLASS_FILE:\n\t\tptr->type = R_BIN_TYPE_FILE_STR;\n\t\tbreak;\n\tcase COFF_SYM_CLASS_SECTION:\n\t\tptr->type = R_BIN_TYPE_SECTION_STR;\n\t\tbreak;\n\tcase COFF_SYM_CLASS_EXTERNAL:\n\t\tif (s->n_scnum == COFF_SYM_SCNUM_UNDEF) {\n\t\t\tptr->is_imported = true;\n\t\t\tptr->paddr = ptr->vaddr = UT64_MAX;\n\t\t\tptr->bind = \"NONE\";\n\t\t} else {\n\t\t\tptr->bind = R_BIN_BIND_GLOBAL_STR;\n\t\t}\n\t\tptr->type = (DTYPE_IS_FUNCTION (s->n_type) || !strcmp (coffname, \"main\"))\n\t\t\t? R_BIN_TYPE_FUNC_STR\n\t\t\t: R_BIN_TYPE_UNKNOWN_STR;\n\t\tbreak;\n\tcase COFF_SYM_CLASS_STATIC:\n\t\tif (s->n_scnum == COFF_SYM_SCNUM_ABS) {\n\t\t\tptr->type = \"ABS\";\n\t\t\tptr->paddr = ptr->vaddr = UT64_MAX;\n\t\t\tptr->name = r_str_newf (\"%s-0x%08x\", coffname, s->n_value);\n\t\t\tif (ptr->name) {\n\t\t\t\tR_FREE (coffname);\n\t\t\t} else {\n\t\t\t\tptr->name = coffname;\n\t\t\t}\n\t\t} else if (sc_hdr && !memcmp (sc_hdr->s_name, s->n_name, 8)) {\n\t\t\tptr->type = R_BIN_TYPE_SECTION_STR;\n\t\t} else {\n\t\t\tptr->type = DTYPE_IS_FUNCTION (s->n_type)\n\t\t\t\t? R_BIN_TYPE_FUNC_STR\n\t\t\t\t: R_BIN_TYPE_UNKNOWN_STR;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\t{\n\t\t\tr_strf_var (ivar, 32, \"%i\", s->n_sclass);\n\t\t\tptr->type = r_str_constpool_get (&rbin->constpool, ivar);\n\t\t}\n\t\tbreak;\n\t}\n\tptr->size = 4;\n\tptr->ordinal = 0;\n\treturn true;\n}\n\nstatic bool is_imported_symbol(struct coff_symbol *s) {\n\treturn s->n_scnum == COFF_SYM_SCNUM_UNDEF && s->n_sclass == COFF_SYM_CLASS_EXTERNAL;\n}\n\nstatic RBinImport *_fill_bin_import(struct r_bin_coff_obj *bin, int idx) {\n\tRBinImport *ptr = R_NEW0 (RBinImport);\n\tif (!ptr || idx < 0 || idx > bin->hdr.f_nsyms) {\n\t\tfree (ptr);\n\t\treturn NULL;\n\t}\n\tstruct coff_symbol *s = &bin->symbols[idx];\n\tif (!is_imported_symbol (s)) {\n\t\tfree (ptr);\n\t\treturn NULL;\n\t}\n\tchar *coffname = r_coff_symbol_name (bin, s);\n\tif (!coffname) {\n\t\tfree (ptr);\n\t\treturn NULL;\n\t}\n\tptr->name = coffname;\n\tptr->bind = \"NONE\";\n\tptr->type = DTYPE_IS_FUNCTION (s->n_type)\n\t\t? R_BIN_TYPE_FUNC_STR\n\t\t: R_BIN_TYPE_UNKNOWN_STR;\n\treturn ptr;\n}\n\nstatic RList *entries(RBinFile *bf) {\n\tstruct r_bin_coff_obj *obj = (struct r_bin_coff_obj*)bf->o->bin_obj;\n\tRList *ret;\n\tif (!(ret = r_list_newf (free))) {\n\t\treturn NULL;\n\t}\n\tRBinAddr *ptr = r_coff_get_entry (obj);\n\tif (ptr) {\n\t\tr_list_append (ret, ptr);\n\t}\n\treturn ret;\n}\n\n// XXX the string must be heap allocated because these are bitfields\nstatic const char *section_type_tostring(int i) {\n\tif (i & COFF_STYP_TEXT) {\n\t\treturn \"TEXT\";\n\t}\n\tif (i & COFF_STYP_DATA) {\n\t\treturn \"DATA\";\n\t}\n\tif (i & COFF_STYP_DATA) {\n\t\treturn \"BSS\";\n\t}\n\treturn \"MAP\";\n#if 0\n\tr_cons_printf (\"---> %x\\n\", i);\n\tif (i & COFF_FLAGS_TI_F_EXEC) {\n\t\treturn \"EXEC\";\n\t}\n\tif (i & COFF_FLAGS_TI_F_RELFLG) {\n\t\treturn \"RELFLG\";\n\t}\n\tif (i & COFF_FLAGS_TI_F_LNNO) {\n\t\treturn \"LNNO\";\n\t}\n\tif (i & COFF_FLAGS_TI_F_LSYMS) {\n\t\treturn \"LSYMS\";\n\t}\n\tif (i & COFF_FLAGS_TI_F_BIG) {\n\t\treturn \"BIG\";\n\t}\n\tif (i & COFF_FLAGS_TI_F_LITTLE) {\n\t\treturn \"LITTLE\";\n\t}\n#endif\n\treturn \"MAP\";\n}\n\nstatic RList *sections(RBinFile *bf) {\n\tchar *tmp = NULL;\n\tsize_t i;\n\tRBinSection *ptr = NULL;\n\tstruct r_bin_coff_obj *obj = (struct r_bin_coff_obj*)bf->o->bin_obj;\n\n\tRList *ret = r_list_newf ((RListFree)r_bin_section_free);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tif (obj && obj->scn_hdrs) {\n\t\tfor (i = 0; i < obj->hdr.f_nscns; i++) {\n\t\t\ttmp = r_coff_symbol_name (obj, &obj->scn_hdrs[i]);\n\t\t\tif (!tmp) {\n\t\t\t\tr_list_free (ret);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\t//IO does not like sections with the same name append idx\n\t\t\t//since it will update it\n\t\t\tptr = R_NEW0 (RBinSection);\n\t\t\tif (!ptr) {\n\t\t\t\tfree (tmp);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tptr->name = r_str_newf (\"%s-%u\", tmp, (unsigned int)i);\n\t\t\tfree (tmp);\n\t\t\tif (strstr (ptr->name, \"data\")) {\n\t\t\t\tptr->is_data = true;\n\t\t\t}\n\t\t\tptr->size = obj->scn_hdrs[i].s_size;\n\t\t\tptr->vsize = obj->scn_hdrs[i].s_size;\n\t\t\tptr->paddr = obj->scn_hdrs[i].s_scnptr;\n\t\t\tptr->type = section_type_tostring (obj->scn_hdrs[i].s_flags);\n\t\t\tif (obj->scn_va) {\n\t\t\t\tptr->vaddr = obj->scn_va[i];\n\t\t\t}\n\t\t\tptr->add = true;\n\t\t\tptr->perm = 0;\n\t\t\tif (obj->scn_hdrs[i].s_flags & COFF_SCN_MEM_READ) {\n\t\t\t\tptr->perm |= R_PERM_R;\n\t\t\t}\n\t\t\tif (obj->scn_hdrs[i].s_flags & COFF_SCN_MEM_WRITE) {\n\t\t\t\tptr->perm |= R_PERM_W;\n\t\t\t}\n\t\t\tif (obj->scn_hdrs[i].s_flags & COFF_SCN_MEM_EXECUTE) {\n\t\t\t\tptr->perm |= R_PERM_X;\n\t\t\t}\n\t\t\tr_list_append (ret, ptr);\n\t\t}\n\t}\n\treturn ret;\n}\n\nstatic RList *symbols(RBinFile *bf) {\n\tint i;\n\tRBinSymbol *ptr = NULL;\n\tstruct r_bin_coff_obj *obj = (struct r_bin_coff_obj*)bf->o->bin_obj;\n\tRList *ret = r_list_newf ((RListFree)r_bin_symbol_free);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tret->free = free;\n\tif (obj->symbols) {\n\t\tfor (i = 0; i < obj->hdr.f_nsyms; i++) {\n\t\t\tif (!(ptr = R_NEW0 (RBinSymbol))) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (_fill_bin_symbol (bf->rbin, obj, i, &ptr)) {\n\t\t\t\tr_list_append (ret, ptr);\n\t\t\t\tht_up_insert (obj->sym_ht, (ut64)i, ptr);\n\t\t\t} else {\n\t\t\t\tfree (ptr);\n\t\t\t}\n\t\t\ti += obj->symbols[i].n_numaux;\n\t\t}\n\t}\n\treturn ret;\n}\n\nstatic RList *imports(RBinFile *bf) {\n\tint i;\n\tstruct r_bin_coff_obj *obj = (struct r_bin_coff_obj*)bf->o->bin_obj;\n\tRList *ret = r_list_newf ((RListFree)r_bin_import_free);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tif (obj->symbols) {\n\t\tint ord = 0;\n\t\tfor (i = 0; i < obj->hdr.f_nsyms; i++) {\n\t\t\tRBinImport *ptr = _fill_bin_import (obj, i);\n\t\t\tif (ptr) {\n\t\t\t\tptr->ordinal = ord++;\n\t\t\t\tr_list_append (ret, ptr);\n\t\t\t\tht_up_insert (obj->imp_ht, (ut64)i, ptr);\n\t\t\t}\n\t\t\ti += obj->symbols[i].n_numaux;\n\t\t}\n\t}\n\treturn ret;\n}\n\nstatic RList *libs(RBinFile *bf) {\n\treturn NULL;\n}\n\nstatic ut32 _read_le32(RBin *rbin, ut64 addr) {\n\tut8 data[4] = {0};\n\tif (!rbin->iob.read_at (rbin->iob.io, addr, data, sizeof (data))) {\n\t\treturn UT32_MAX;\n\t}\n\treturn r_read_le32 (data);\n}\n\nstatic ut16 _read_le16(RBin *rbin, ut64 addr) {\n\tut8 data[2] = {0};\n\tif (!rbin->iob.read_at (rbin->iob.io, addr, data, sizeof (data))) {\n\t\treturn UT16_MAX;\n\t}\n\treturn r_read_le16 (data);\n}\n\n#define BYTES_PER_IMP_RELOC\t\t8\n\nstatic RList *_relocs_list(RBin *rbin, struct r_bin_coff_obj *bin, bool patch, ut64 imp_map) {\n\tr_return_val_if_fail (bin, NULL);\n\tif (!bin->scn_hdrs) {\n\t\treturn NULL;\n\t}\n\n\tRBinReloc *reloc;\n\tstruct coff_reloc *rel;\n\tint j, i = 0;\n\tRList *list_rel = r_list_newf (free);\n\tif (!list_rel) {\n\t\treturn NULL;\n\t}\n\tconst bool patch_imports = patch && (imp_map != UT64_MAX);\n\tHtUU *imp_vaddr_ht = patch_imports? ht_uu_new0 (): NULL;\n\tif (patch_imports && !imp_vaddr_ht) {\n\t\tr_list_free (list_rel);\n\t\treturn NULL;\n\t}\n\tfor (i = 0; i < bin->hdr.f_nscns; i++) {\n\t\tif (!bin->scn_hdrs[i].s_nreloc) {\n\t\t\tcontinue;\n\t\t}\n\t\tint len = 0, size = bin->scn_hdrs[i].s_nreloc * sizeof (struct coff_reloc);\n\t\tif (size < 0) {\n\t\t\tbreak;\n\t\t}\n\t\trel = calloc (1, size + sizeof (struct coff_reloc));\n\t\tif (!rel) {\n\t\t\tbreak;\n\t\t}\n\t\tif (bin->scn_hdrs[i].s_relptr > bin->size ||\n\t\t\tbin->scn_hdrs[i].s_relptr + size > bin->size) {\n\t\t\tfree (rel);\n\t\t\tbreak;\n\t\t}\n\t\tlen = r_buf_read_at (bin->b, bin->scn_hdrs[i].s_relptr, (ut8*)rel, size);\n\t\tif (len != size) {\n\t\t\tfree (rel);\n\t\t\tbreak;\n\t\t}\n\t\tfor (j = 0; j < bin->scn_hdrs[i].s_nreloc; j++) {\n\t\t\tRBinSymbol *symbol = (RBinSymbol *)ht_up_find (bin->sym_ht, (ut64)rel[j].r_symndx, NULL);\n\t\t\tif (!symbol) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\treloc = R_NEW0 (RBinReloc);\n\t\t\tif (!reloc) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\treloc->symbol = symbol;\n\t\t\treloc->paddr = bin->scn_hdrs[i].s_scnptr + rel[j].r_vaddr;\n\t\t\tif (bin->scn_va) {\n\t\t\t\treloc->vaddr = bin->scn_va[i] + rel[j].r_vaddr;\n\t\t\t}\n\t\t\treloc->type = rel[j].r_type;\n\n\t\t\tut64 sym_vaddr = symbol->vaddr;\n\t\t\tif (symbol->is_imported) {\n\t\t\t\treloc->import = (RBinImport *)ht_up_find (bin->imp_ht, (ut64)rel[j].r_symndx, NULL);\n\t\t\t\tif (patch_imports) {\n\t\t\t\t\tbool found;\n\t\t\t\t\tsym_vaddr = ht_uu_find (imp_vaddr_ht, (ut64)rel[j].r_symndx, &found);\n\t\t\t\t\tif (!found) {\n\t\t\t\t\t\tsym_vaddr = imp_map;\n\t\t\t\t\t\timp_map += BYTES_PER_IMP_RELOC;\n\t\t\t\t\t\tht_uu_insert (imp_vaddr_ht, (ut64)rel[j].r_symndx, sym_vaddr);\n\t\t\t\t\t\tsymbol->vaddr = sym_vaddr;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (sym_vaddr) {\n\t\t\t\tint plen = 0;\n\t\t\t\tut8 patch_buf[8];\n\t\t\t\tswitch (bin->hdr.f_magic) {\n\t\t\t\tcase COFF_FILE_MACHINE_I386:\n\t\t\t\t\tswitch (rel[j].r_type) {\n\t\t\t\t\tcase COFF_REL_I386_DIR32:\n\t\t\t\t\t\treloc->type = R_BIN_RELOC_32;\n\t\t\t\t\t\tr_write_le32 (patch_buf, (ut32)sym_vaddr);\n\t\t\t\t\t\tplen = 4;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase COFF_REL_I386_REL32:\n\t\t\t\t\t\treloc->type = R_BIN_RELOC_32;\n\t\t\t\t\t\treloc->additive = 1;\n\t\t\t\t\t\tut64 data = _read_le32 (rbin, reloc->vaddr);\n\t\t\t\t\t\tif (data == UT32_MAX) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treloc->addend = data;\n\t\t\t\t\t\tdata += sym_vaddr - reloc->vaddr - 4;\n\t\t\t\t\t\tr_write_le32 (patch_buf, (st32)data);\n\t\t\t\t\t\tplen = 4;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase COFF_FILE_MACHINE_AMD64:\n\t\t\t\t\tswitch (rel[j].r_type) {\n\t\t\t\t\tcase COFF_REL_AMD64_REL32:\n\t\t\t\t\t\treloc->type = R_BIN_RELOC_32;\n\t\t\t\t\t\treloc->additive = 1;\n\t\t\t\t\t\tut64 data = _read_le32 (rbin, reloc->vaddr);\n\t\t\t\t\t\tif (data == UT32_MAX) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treloc->addend = data;\n\t\t\t\t\t\tdata += sym_vaddr - reloc->vaddr - 4;\n\t\t\t\t\t\tr_write_le32 (patch_buf, (st32)data);\n\t\t\t\t\t\tplen = 4;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase COFF_FILE_MACHINE_ARMNT:\n\t\t\t\t\tswitch (rel[j].r_type) {\n\t\t\t\t\tcase COFF_REL_ARM_BRANCH24T:\n\t\t\t\t\tcase COFF_REL_ARM_BLX23T:\n\t\t\t\t\t\treloc->type = R_BIN_RELOC_32;\n\t\t\t\t\t\tut16 hiword = _read_le16 (rbin, reloc->vaddr);\n\t\t\t\t\t\tif (hiword == UT16_MAX) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tut16 loword = _read_le16 (rbin, reloc->vaddr + 2);\n\t\t\t\t\t\tif (loword == UT16_MAX) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tut64 dst = sym_vaddr - reloc->vaddr - 4;\n\t\t\t\t\t\tif (dst & 1) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tloword |= (ut16)(dst >> 1) & 0x7ff;\n\t\t\t\t\t\thiword |= (ut16)(dst >> 12) & 0x7ff;\n\t\t\t\t\t\tr_write_le16 (patch_buf, hiword);\n\t\t\t\t\t\tr_write_le16 (patch_buf + 2, loword);\n\t\t\t\t\t\tplen = 4;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase COFF_FILE_MACHINE_ARM64:\n\t\t\t\t\tswitch (rel[j].r_type) {\n\t\t\t\t\tcase COFF_REL_ARM64_BRANCH26:\n\t\t\t\t\t\treloc->type = R_BIN_RELOC_32;\n\t\t\t\t\t\tut32 data = _read_le32 (rbin, reloc->vaddr);\n\t\t\t\t\t\tif (data == UT32_MAX) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tut64 dst = sym_vaddr - reloc->vaddr;\n\t\t\t\t\t\tdata |= (ut32)((dst >> 2) & 0x3ffffffULL);\n\t\t\t\t\t\tr_write_le32 (patch_buf, data);\n\t\t\t\t\t\tplen = 4;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (patch && plen) {\n\t\t\t\t\trbin->iob.write_at (rbin->iob.io, reloc->vaddr, patch_buf, plen);\n\t\t\t\t\tif (symbol->is_imported) {\n\t\t\t\t\t\treloc->vaddr = sym_vaddr;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tr_list_append (list_rel, reloc);\n\t\t}\n\t\tfree (rel);\n\t}\n\tht_uu_free (imp_vaddr_ht);\n\treturn list_rel;\n}\n\nstatic RList *relocs(RBinFile *bf) {\n\tstruct r_bin_coff_obj *bin = (struct r_bin_coff_obj*)bf->o->bin_obj;\n\treturn _relocs_list (bf->rbin, bin, false, UT64_MAX);\n}\n\nstatic RList *patch_relocs(RBin *b) {\n\tr_return_val_if_fail (b && b->iob.io && b->iob.io->desc, NULL);\n\tRBinObject *bo = r_bin_cur_object (b);\n\tRIO *io = b->iob.io;\n\tif (!bo || !bo->bin_obj) {\n\t\treturn NULL;\n\t}\n\tstruct r_bin_coff_obj *bin = (struct r_bin_coff_obj*)bo->bin_obj;\n\tif (bin->hdr.f_flags & COFF_FLAGS_TI_F_EXEC) {\n\t\treturn NULL;\n\t}\n\tif (!(io->cached & R_PERM_W)) {\n\t\teprintf (\n\t\t\t\"Warning: please run r2 with -e io.cache=true to patch \"\n\t\t\t\"relocations\\n\");\n\t\treturn NULL;\n\t}\n\n\tsize_t nimports = 0;\n\tint i;\n\tfor (i = 0; i < bin->hdr.f_nsyms; i++) {\n\t\tif (is_imported_symbol (&bin->symbols[i])) {\n\t\t\tnimports++;\n\t\t}\n\t\ti += bin->symbols[i].n_numaux;\n\t}\n\tut64 m_vaddr = UT64_MAX;\n\tif (nimports) {\n\t\tut64 offset = 0;\n\t\tRIOBank *bank = b->iob.bank_get (io, io->bank);\n\t\tRListIter *iter;\n\t\tRIOMapRef *mapref;\n\t\tr_list_foreach (bank->maprefs, iter, mapref) {\n\t\t\tRIOMap *map = b->iob.map_get (io, mapref->id);\n\t\t\tif (r_io_map_end (map) > offset) {\n\t\t\t\toffset = r_io_map_end (map);\n\t\t\t}\n\t\t}\n\t\tm_vaddr = R_ROUND (offset, 16);\n\t\tut64 size = nimports * BYTES_PER_IMP_RELOC;\n\t\tchar *muri = r_str_newf (\"malloc://%\" PFMT64u, size);\n\t\tRIODesc *desc = b->iob.open_at (io, muri, R_PERM_R, 0664, m_vaddr);\n\t\tfree (muri);\n\t\tif (!desc) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\tRIOMap *map = b->iob.map_get_at (io, m_vaddr);\n\t\tif (!map) {\n\t\t\treturn NULL;\n\t\t}\n\t\tmap->name = strdup (\".imports.r2\");\n\t}\n\n\treturn _relocs_list (b, bin, true, m_vaddr);\n}\n\nstatic RBinInfo *info(RBinFile *bf) {\n\tRBinInfo *ret = R_NEW0 (RBinInfo);\n\tstruct r_bin_coff_obj *obj = (struct r_bin_coff_obj*)bf->o->bin_obj;\n\n\tret->file = bf->file? strdup (bf->file): NULL;\n\tret->rclass = strdup (\"coff\");\n\tret->bclass = strdup (\"coff\");\n\tret->type = strdup (\"COFF (Executable file)\");\n\tret->os = strdup (\"any\");\n\tret->subsystem = strdup (\"any\");\n\tret->big_endian = obj->endian;\n\tret->has_va = true;\n\tret->dbg_info = 0;\n\tret->has_lit = true;\n\n\tif (r_coff_is_stripped (obj)) {\n\t\tret->dbg_info |= R_BIN_DBG_STRIPPED;\n\t} else {\n\t\tif (!(obj->hdr.f_flags & COFF_FLAGS_TI_F_RELFLG)) {\n\t\t\tret->dbg_info |= R_BIN_DBG_RELOCS;\n\t\t}\n\t\tif (!(obj->hdr.f_flags & COFF_FLAGS_TI_F_LNNO)) {\n\t\t\tret->dbg_info |= R_BIN_DBG_LINENUMS;\n\t\t}\n\t\tif (!(obj->hdr.f_flags & COFF_FLAGS_TI_F_EXEC)) {\n\t\t\tret->dbg_info |= R_BIN_DBG_SYMS;\n\t\t}\n\t}\n\n\tswitch (obj->hdr.f_magic) {\n\tcase COFF_FILE_MACHINE_R4000:\n \tcase COFF_FILE_MACHINE_MIPS16:\n \tcase COFF_FILE_MACHINE_MIPSFPU:\n \tcase COFF_FILE_MACHINE_MIPSFPU16:\n \t\tret->machine = strdup (\"mips\");\n \t\tret->arch = strdup (\"mips\");\n \t\tret->bits = 32;\n \t\tbreak;\n\tcase COFF_FILE_MACHINE_I386:\n\t\tret->machine = strdup (\"i386\");\n\t\tret->arch = strdup (\"x86\");\n\t\tret->bits = 32;\n\t\tbreak;\n\tcase COFF_FILE_MACHINE_ARM64:\n\t\tret->machine = strdup (\"aarch64\");\n\t\tret->arch = strdup (\"arm\");\n\t\tret->bits = 64;\n\t\tbreak;\n\tcase COFF_FILE_MACHINE_THUMB:\n \t\tret->machine = strdup (\"arm\");\n \t\tret->arch = strdup (\"arm\");\n \t\tret->bits = 16;\n \t\tbreak;\n\tcase COFF_FILE_MACHINE_ARM:\n\t\tret->machine = strdup (\"ARM\");\n\t\tret->arch = strdup (\"arm\");\n\t\tret->bits = 32;\n\t\tbreak;\n\tcase COFF_FILE_MACHINE_AMD64:\n\t\tret->machine = strdup (\"AMD64\");\n\t\tret->arch = strdup (\"x86\");\n\t\tret->bits = 64;\n\t\tbreak;\n\tcase COFF_FILE_MACHINE_H8300:\n\t\tret->machine = strdup (\"H8300\");\n\t\tret->arch = strdup (\"h8300\");\n\t\tret->bits = 16;\n\t\tbreak;\n\tcase COFF_FILE_MACHINE_AMD29KBE:\n\tcase COFF_FILE_MACHINE_AMD29KLE:\n\t\tret->cpu = strdup (\"29000\");\n\t\tret->machine = strdup (\"amd29k\");\n\t\tret->arch = strdup (\"amd29k\");\n\t\tret->bits = 32;\n\t\tbreak;\n\tcase COFF_FILE_MACHINE_ARMNT:\n\t\tret->machine = strdup (\"arm\");\n\t\tret->arch = strdup (\"arm\");\n\t\tret->bits = 32;\n\t\tbreak;\n\tcase COFF_FILE_MACHINE_SH3:\n \tcase COFF_FILE_MACHINE_SH3DSP:\n \tcase COFF_FILE_MACHINE_SH4:\n \tcase COFF_FILE_MACHINE_SH5:\n \t\tret->machine = strdup (\"sh\");\n \t\tret->arch = strdup (\"sh\");\n \t\tret->bits = 32;\n \t\tbreak;\n\tcase COFF_FILE_TI_COFF:\n\t\tswitch (obj->target_id) {\n\t\tcase COFF_FILE_MACHINE_TMS320C54:\n\t\t\tret->machine = strdup (\"c54x\");\n\t\t\tret->arch = strdup (\"tms320\");\n\t\t\tret->bits = 32;\n\t\t\tbreak;\n\t\tcase COFF_FILE_MACHINE_TMS320C55:\n\t\t\tret->machine = strdup (\"c55x\");\n\t\t\tret->arch = strdup (\"tms320\");\n\t\t\tret->bits = 32;\n\t\t\tbreak;\n\t\tcase COFF_FILE_MACHINE_TMS320C55PLUS:\n\t\t\tret->machine = strdup (\"c55x+\");\n\t\t\tret->arch = strdup (\"tms320\");\n\t\t\tret->bits = 32;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase COFF_FILE_MACHINE_POWERPC:\n\t\tret->machine = strdup (\"ppc\");\n\t\tret->arch = strdup (\"ppc\");\n\t\tret->big_endian = true;\n\t\tret->bits = 32;\n\t\tbreak;\n\tdefault:\n\t\tret->machine = strdup (\"unknown\");\n\t}\n\n\treturn ret;\n}\n\nstatic bool check_buffer(RBinFile *bf, RBuffer *buf) {\n#if 0\nTODO: do more checks here to avoid false positives\n\nut16 MACHINE\nut16 NSECTIONS\nut32 DATE\nut32 PTRTOSYMTABLE\nut32 NUMOFSYMS\nut16 OPTHDRSIZE\nut16 CHARACTERISTICS\n#endif\n\n\tut8 tmp[20];\n\tint r = r_buf_read_at (buf, 0, tmp, sizeof (tmp));\n\treturn r >= 20 && r_coff_supported_arch (tmp);\n}\n\nRBinPlugin r_bin_plugin_coff = {\n\t.name = \"coff\",\n\t.desc = \"COFF format r_bin plugin\",\n\t.license = \"LGPL3\",\n\t.get_sdb = &get_sdb,\n\t.load_buffer = &load_buffer,\n\t.destroy = &destroy,\n\t.check_buffer = &check_buffer,\n\t.binsym = &binsym,\n\t.entries = &entries,\n\t.sections = &sections,\n\t.symbols = &symbols,\n\t.imports = &imports,\n\t.info = &info,\n\t.libs = &libs,\n\t.relocs = &relocs,\n\t.patch_relocs = &patch_relocs\n};\n\n#ifndef R2_PLUGIN_INCORE\nR_API RLibStruct radare_plugin = {\n\t.type = R_LIB_TYPE_BIN,\n\t.data = &r_bin_plugin_coff,\n\t.version = R2_VERSION\n};\n#endif\n"], "fixing_code": ["/* radare - LGPL - Copyright 2014-2019 - Fedor Sakharov */\n\n#include <r_bin.h>\n#include <sdb/ht_uu.h>\n\n#include \"coff/coff.h\"\n\nstatic Sdb* get_sdb(RBinFile *bf) {\n\tstruct r_bin_coff_obj *bin = (struct r_bin_coff_obj *) R_UNWRAP3 (bf, o, bin_obj);\n\treturn bin? bin->kv: NULL;\n}\n\nstatic bool r_coff_is_stripped(struct r_bin_coff_obj *obj) {\n\treturn !!(obj->hdr.f_flags & (COFF_FLAGS_TI_F_RELFLG | \\\n\t\tCOFF_FLAGS_TI_F_LNNO | COFF_FLAGS_TI_F_LSYMS));\n}\n\nstatic bool load_buffer(RBinFile *bf, void **bin_obj, RBuffer *buf, ut64 loadaddr, Sdb *sdb) {\n\t*bin_obj = r_bin_coff_new_buf (buf, bf->rbin->verbose);\n\treturn *bin_obj;\n}\n\nstatic void destroy(RBinFile *bf) {\n\tr_bin_coff_free ((struct r_bin_coff_obj*)bf->o->bin_obj);\n}\n\nstatic RBinAddr *binsym(RBinFile *bf, int sym) {\n\treturn NULL;\n}\n\n#define DTYPE_IS_FUNCTION(type)\t(COFF_SYM_GET_DTYPE (type) == COFF_SYM_DTYPE_FUNCTION)\n\nstatic bool _fill_bin_symbol(RBin *rbin, struct r_bin_coff_obj *bin, int idx, RBinSymbol **sym) {\n\tRBinSymbol *ptr = *sym;\n\tstruct coff_symbol *s = NULL;\n\tstruct coff_scn_hdr *sc_hdr = NULL;\n\tif (idx < 0 || idx > bin->hdr.f_nsyms) {\n\t\treturn false;\n\t}\n\tif (!bin->symbols) {\n\t\treturn false;\n\t}\n\ts = &bin->symbols[idx];\n\tchar *coffname = r_coff_symbol_name (bin, s);\n\tif (!coffname) {\n\t\treturn false;\n\t}\n\tptr->name = coffname;\n\tptr->forwarder = \"NONE\";\n\tptr->bind = R_BIN_BIND_LOCAL_STR;\n\tptr->is_imported = false;\n\tif (s->n_scnum < bin->hdr.f_nscns + 1 && s->n_scnum > 0) {\n\t\t//first index is 0 that is why -1\n\t\tsc_hdr = &bin->scn_hdrs[s->n_scnum - 1];\n\t\tptr->paddr = sc_hdr->s_scnptr + s->n_value;\n\t\tif (bin->scn_va) {\n\t\t\tptr->vaddr = bin->scn_va[s->n_scnum - 1] + s->n_value;\n\t\t}\n\t}\n\n\tswitch (s->n_sclass) {\n\tcase COFF_SYM_CLASS_FUNCTION:\n\t\tptr->type = R_BIN_TYPE_FUNC_STR;\n\t\tbreak;\n\tcase COFF_SYM_CLASS_FILE:\n\t\tptr->type = R_BIN_TYPE_FILE_STR;\n\t\tbreak;\n\tcase COFF_SYM_CLASS_SECTION:\n\t\tptr->type = R_BIN_TYPE_SECTION_STR;\n\t\tbreak;\n\tcase COFF_SYM_CLASS_EXTERNAL:\n\t\tif (s->n_scnum == COFF_SYM_SCNUM_UNDEF) {\n\t\t\tptr->is_imported = true;\n\t\t\tptr->paddr = ptr->vaddr = UT64_MAX;\n\t\t\tptr->bind = \"NONE\";\n\t\t} else {\n\t\t\tptr->bind = R_BIN_BIND_GLOBAL_STR;\n\t\t}\n\t\tptr->type = (DTYPE_IS_FUNCTION (s->n_type) || !strcmp (coffname, \"main\"))\n\t\t\t? R_BIN_TYPE_FUNC_STR\n\t\t\t: R_BIN_TYPE_UNKNOWN_STR;\n\t\tbreak;\n\tcase COFF_SYM_CLASS_STATIC:\n\t\tif (s->n_scnum == COFF_SYM_SCNUM_ABS) {\n\t\t\tptr->type = \"ABS\";\n\t\t\tptr->paddr = ptr->vaddr = UT64_MAX;\n\t\t\tptr->name = r_str_newf (\"%s-0x%08x\", coffname, s->n_value);\n\t\t\tif (ptr->name) {\n\t\t\t\tR_FREE (coffname);\n\t\t\t} else {\n\t\t\t\tptr->name = coffname;\n\t\t\t}\n\t\t} else if (sc_hdr && !memcmp (sc_hdr->s_name, s->n_name, 8)) {\n\t\t\tptr->type = R_BIN_TYPE_SECTION_STR;\n\t\t} else {\n\t\t\tptr->type = DTYPE_IS_FUNCTION (s->n_type)\n\t\t\t\t? R_BIN_TYPE_FUNC_STR\n\t\t\t\t: R_BIN_TYPE_UNKNOWN_STR;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\t{\n\t\t\tr_strf_var (ivar, 32, \"%i\", s->n_sclass);\n\t\t\tptr->type = r_str_constpool_get (&rbin->constpool, ivar);\n\t\t}\n\t\tbreak;\n\t}\n\tptr->size = 4;\n\tptr->ordinal = 0;\n\treturn true;\n}\n\nstatic bool is_imported_symbol(struct coff_symbol *s) {\n\treturn s->n_scnum == COFF_SYM_SCNUM_UNDEF && s->n_sclass == COFF_SYM_CLASS_EXTERNAL;\n}\n\nstatic RBinImport *_fill_bin_import(struct r_bin_coff_obj *bin, int idx) {\n\tRBinImport *ptr = R_NEW0 (RBinImport);\n\tif (!ptr || idx < 0 || idx > bin->hdr.f_nsyms) {\n\t\tfree (ptr);\n\t\treturn NULL;\n\t}\n\tstruct coff_symbol *s = &bin->symbols[idx];\n\tif (!is_imported_symbol (s)) {\n\t\tfree (ptr);\n\t\treturn NULL;\n\t}\n\tchar *coffname = r_coff_symbol_name (bin, s);\n\tif (!coffname) {\n\t\tfree (ptr);\n\t\treturn NULL;\n\t}\n\tptr->name = coffname;\n\tptr->bind = \"NONE\";\n\tptr->type = DTYPE_IS_FUNCTION (s->n_type)\n\t\t? R_BIN_TYPE_FUNC_STR\n\t\t: R_BIN_TYPE_UNKNOWN_STR;\n\treturn ptr;\n}\n\nstatic RList *entries(RBinFile *bf) {\n\tstruct r_bin_coff_obj *obj = (struct r_bin_coff_obj*)bf->o->bin_obj;\n\tRList *ret;\n\tif (!(ret = r_list_newf (free))) {\n\t\treturn NULL;\n\t}\n\tRBinAddr *ptr = r_coff_get_entry (obj);\n\tif (ptr) {\n\t\tr_list_append (ret, ptr);\n\t}\n\treturn ret;\n}\n\n// XXX the string must be heap allocated because these are bitfields\nstatic const char *section_type_tostring(int i) {\n\tif (i & COFF_STYP_TEXT) {\n\t\treturn \"TEXT\";\n\t}\n\tif (i & COFF_STYP_DATA) {\n\t\treturn \"DATA\";\n\t}\n\tif (i & COFF_STYP_DATA) {\n\t\treturn \"BSS\";\n\t}\n\treturn \"MAP\";\n#if 0\n\tr_cons_printf (\"---> %x\\n\", i);\n\tif (i & COFF_FLAGS_TI_F_EXEC) {\n\t\treturn \"EXEC\";\n\t}\n\tif (i & COFF_FLAGS_TI_F_RELFLG) {\n\t\treturn \"RELFLG\";\n\t}\n\tif (i & COFF_FLAGS_TI_F_LNNO) {\n\t\treturn \"LNNO\";\n\t}\n\tif (i & COFF_FLAGS_TI_F_LSYMS) {\n\t\treturn \"LSYMS\";\n\t}\n\tif (i & COFF_FLAGS_TI_F_BIG) {\n\t\treturn \"BIG\";\n\t}\n\tif (i & COFF_FLAGS_TI_F_LITTLE) {\n\t\treturn \"LITTLE\";\n\t}\n#endif\n\treturn \"MAP\";\n}\n\nstatic RList *sections(RBinFile *bf) {\n\tchar *tmp = NULL;\n\tsize_t i;\n\tRBinSection *ptr = NULL;\n\tstruct r_bin_coff_obj *obj = (struct r_bin_coff_obj*)bf->o->bin_obj;\n\n\tRList *ret = r_list_newf ((RListFree)r_bin_section_free);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tif (obj && obj->scn_hdrs) {\n\t\tfor (i = 0; i < obj->hdr.f_nscns; i++) {\n\t\t\ttmp = r_coff_symbol_name (obj, &obj->scn_hdrs[i]);\n\t\t\tif (!tmp) {\n\t\t\t\tr_list_free (ret);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\t//IO does not like sections with the same name append idx\n\t\t\t//since it will update it\n\t\t\tptr = R_NEW0 (RBinSection);\n\t\t\tif (!ptr) {\n\t\t\t\tfree (tmp);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tptr->name = r_str_newf (\"%s-%u\", tmp, (unsigned int)i);\n\t\t\tfree (tmp);\n\t\t\tif (strstr (ptr->name, \"data\")) {\n\t\t\t\tptr->is_data = true;\n\t\t\t}\n\t\t\tptr->size = obj->scn_hdrs[i].s_size;\n\t\t\tptr->vsize = obj->scn_hdrs[i].s_size;\n\t\t\tptr->paddr = obj->scn_hdrs[i].s_scnptr;\n\t\t\tptr->type = section_type_tostring (obj->scn_hdrs[i].s_flags);\n\t\t\tif (obj->scn_va) {\n\t\t\t\tptr->vaddr = obj->scn_va[i];\n\t\t\t}\n\t\t\tptr->add = true;\n\t\t\tptr->perm = 0;\n\t\t\tif (obj->scn_hdrs[i].s_flags & COFF_SCN_MEM_READ) {\n\t\t\t\tptr->perm |= R_PERM_R;\n\t\t\t}\n\t\t\tif (obj->scn_hdrs[i].s_flags & COFF_SCN_MEM_WRITE) {\n\t\t\t\tptr->perm |= R_PERM_W;\n\t\t\t}\n\t\t\tif (obj->scn_hdrs[i].s_flags & COFF_SCN_MEM_EXECUTE) {\n\t\t\t\tptr->perm |= R_PERM_X;\n\t\t\t}\n\t\t\tr_list_append (ret, ptr);\n\t\t}\n\t}\n\treturn ret;\n}\n\nstatic RList *symbols(RBinFile *bf) {\n\tint i;\n\tRBinSymbol *ptr = NULL;\n\tstruct r_bin_coff_obj *obj = (struct r_bin_coff_obj*)bf->o->bin_obj;\n\tRList *ret = r_list_newf ((RListFree)r_bin_symbol_free);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tret->free = free;\n\tif (obj->symbols) {\n\t\tfor (i = 0; i < obj->hdr.f_nsyms; i++) {\n\t\t\tif (!(ptr = R_NEW0 (RBinSymbol))) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (_fill_bin_symbol (bf->rbin, obj, i, &ptr)) {\n\t\t\t\tr_list_append (ret, ptr);\n\t\t\t\tht_up_insert (obj->sym_ht, (ut64)i, ptr);\n\t\t\t} else {\n\t\t\t\tfree (ptr);\n\t\t\t}\n\t\t\ti += obj->symbols[i].n_numaux;\n\t\t}\n\t}\n\treturn ret;\n}\n\nstatic RList *imports(RBinFile *bf) {\n\tint i;\n\tstruct r_bin_coff_obj *obj = (struct r_bin_coff_obj*)bf->o->bin_obj;\n\tRList *ret = r_list_newf ((RListFree)r_bin_import_free);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tif (obj->symbols) {\n\t\tint ord = 0;\n\t\tfor (i = 0; i < obj->hdr.f_nsyms; i++) {\n\t\t\tRBinImport *ptr = _fill_bin_import (obj, i);\n\t\t\tif (ptr) {\n\t\t\t\tptr->ordinal = ord++;\n\t\t\t\tr_list_append (ret, ptr);\n\t\t\t\tht_up_insert (obj->imp_ht, (ut64)i, ptr);\n\t\t\t}\n\t\t\ti += obj->symbols[i].n_numaux;\n\t\t}\n\t}\n\treturn ret;\n}\n\nstatic RList *libs(RBinFile *bf) {\n\treturn NULL;\n}\n\nstatic ut32 _read_le32(RBin *rbin, ut64 addr) {\n\tut8 data[4] = {0};\n\tif (!rbin->iob.read_at (rbin->iob.io, addr, data, sizeof (data))) {\n\t\treturn UT32_MAX;\n\t}\n\treturn r_read_le32 (data);\n}\n\nstatic ut16 _read_le16(RBin *rbin, ut64 addr) {\n\tut8 data[2] = {0};\n\tif (!rbin->iob.read_at (rbin->iob.io, addr, data, sizeof (data))) {\n\t\treturn UT16_MAX;\n\t}\n\treturn r_read_le16 (data);\n}\n\n#define BYTES_PER_IMP_RELOC\t\t8\n\nstatic RList *_relocs_list(RBin *rbin, struct r_bin_coff_obj *bin, bool patch, ut64 imp_map) {\n\tr_return_val_if_fail (bin, NULL);\n\tif (!bin->scn_hdrs) {\n\t\treturn NULL;\n\t}\n\n\tRBinReloc *reloc;\n\tstruct coff_reloc *rel;\n\tint j, i = 0;\n\tRList *list_rel = r_list_newf (free);\n\tif (!list_rel) {\n\t\treturn NULL;\n\t}\n\tconst bool patch_imports = patch && (imp_map != UT64_MAX);\n\tHtUU *imp_vaddr_ht = patch_imports? ht_uu_new0 (): NULL;\n\tif (patch_imports && !imp_vaddr_ht) {\n\t\tr_list_free (list_rel);\n\t\treturn NULL;\n\t}\n\tfor (i = 0; i < bin->hdr.f_nscns; i++) {\n\t\tif (!bin->scn_hdrs[i].s_nreloc) {\n\t\t\tcontinue;\n\t\t}\n\t\tint len = 0, size = bin->scn_hdrs[i].s_nreloc * sizeof (struct coff_reloc);\n\t\tif (size < 0) {\n\t\t\tbreak;\n\t\t}\n\t\trel = calloc (1, size + sizeof (struct coff_reloc));\n\t\tif (!rel) {\n\t\t\tbreak;\n\t\t}\n\t\tif (bin->scn_hdrs[i].s_relptr > bin->size ||\n\t\t\tbin->scn_hdrs[i].s_relptr + size > bin->size) {\n\t\t\tfree (rel);\n\t\t\tbreak;\n\t\t}\n\t\tlen = r_buf_read_at (bin->b, bin->scn_hdrs[i].s_relptr, (ut8*)rel, size);\n\t\tif (len != size) {\n\t\t\tfree (rel);\n\t\t\tbreak;\n\t\t}\n\t\tfor (j = 0; j < bin->scn_hdrs[i].s_nreloc; j++) {\n\t\t\tRBinSymbol *symbol = (RBinSymbol *)ht_up_find (bin->sym_ht, (ut64)rel[j].r_symndx, NULL);\n\t\t\tif (!symbol) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\treloc = R_NEW0 (RBinReloc);\n\t\t\tif (!reloc) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\treloc->symbol = symbol;\n\t\t\treloc->paddr = bin->scn_hdrs[i].s_scnptr + rel[j].r_vaddr;\n\t\t\tif (bin->scn_va) {\n\t\t\t\treloc->vaddr = bin->scn_va[i] + rel[j].r_vaddr;\n\t\t\t}\n\t\t\treloc->type = rel[j].r_type;\n\n\t\t\tut64 sym_vaddr = symbol->vaddr;\n\t\t\tif (symbol->is_imported) {\n\t\t\t\treloc->import = (RBinImport *)ht_up_find (bin->imp_ht, (ut64)rel[j].r_symndx, NULL);\n\t\t\t\tif (patch_imports) {\n\t\t\t\t\tbool found;\n\t\t\t\t\tsym_vaddr = ht_uu_find (imp_vaddr_ht, (ut64)rel[j].r_symndx, &found);\n\t\t\t\t\tif (!found) {\n\t\t\t\t\t\tsym_vaddr = imp_map;\n\t\t\t\t\t\timp_map += BYTES_PER_IMP_RELOC;\n\t\t\t\t\t\tht_uu_insert (imp_vaddr_ht, (ut64)rel[j].r_symndx, sym_vaddr);\n\t\t\t\t\t\tsymbol->vaddr = sym_vaddr;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (sym_vaddr) {\n\t\t\t\tint plen = 0;\n\t\t\t\tut8 patch_buf[8];\n\t\t\t\tswitch (bin->hdr.f_magic) {\n\t\t\t\tcase COFF_FILE_MACHINE_I386:\n\t\t\t\t\tswitch (rel[j].r_type) {\n\t\t\t\t\tcase COFF_REL_I386_DIR32:\n\t\t\t\t\t\treloc->type = R_BIN_RELOC_32;\n\t\t\t\t\t\tr_write_le32 (patch_buf, (ut32)sym_vaddr);\n\t\t\t\t\t\tplen = 4;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase COFF_REL_I386_REL32:\n\t\t\t\t\t\treloc->type = R_BIN_RELOC_32;\n\t\t\t\t\t\treloc->additive = 1;\n\t\t\t\t\t\tut64 data = _read_le32 (rbin, reloc->vaddr);\n\t\t\t\t\t\tif (data == UT32_MAX) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treloc->addend = data;\n\t\t\t\t\t\tdata += sym_vaddr - reloc->vaddr - 4;\n\t\t\t\t\t\tr_write_le32 (patch_buf, (st32)data);\n\t\t\t\t\t\tplen = 4;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase COFF_FILE_MACHINE_AMD64:\n\t\t\t\t\tswitch (rel[j].r_type) {\n\t\t\t\t\tcase COFF_REL_AMD64_REL32:\n\t\t\t\t\t\treloc->type = R_BIN_RELOC_32;\n\t\t\t\t\t\treloc->additive = 1;\n\t\t\t\t\t\tut64 data = _read_le32 (rbin, reloc->vaddr);\n\t\t\t\t\t\tif (data == UT32_MAX) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treloc->addend = data;\n\t\t\t\t\t\tdata += sym_vaddr - reloc->vaddr - 4;\n\t\t\t\t\t\tr_write_le32 (patch_buf, (st32)data);\n\t\t\t\t\t\tplen = 4;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase COFF_FILE_MACHINE_ARMNT:\n\t\t\t\t\tswitch (rel[j].r_type) {\n\t\t\t\t\tcase COFF_REL_ARM_BRANCH24T:\n\t\t\t\t\tcase COFF_REL_ARM_BLX23T:\n\t\t\t\t\t\treloc->type = R_BIN_RELOC_32;\n\t\t\t\t\t\tut16 hiword = _read_le16 (rbin, reloc->vaddr);\n\t\t\t\t\t\tif (hiword == UT16_MAX) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tut16 loword = _read_le16 (rbin, reloc->vaddr + 2);\n\t\t\t\t\t\tif (loword == UT16_MAX) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tut64 dst = sym_vaddr - reloc->vaddr - 4;\n\t\t\t\t\t\tif (dst & 1) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tloword |= (ut16)(dst >> 1) & 0x7ff;\n\t\t\t\t\t\thiword |= (ut16)(dst >> 12) & 0x7ff;\n\t\t\t\t\t\tr_write_le16 (patch_buf, hiword);\n\t\t\t\t\t\tr_write_le16 (patch_buf + 2, loword);\n\t\t\t\t\t\tplen = 4;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase COFF_FILE_MACHINE_ARM64:\n\t\t\t\t\tswitch (rel[j].r_type) {\n\t\t\t\t\tcase COFF_REL_ARM64_BRANCH26:\n\t\t\t\t\t\treloc->type = R_BIN_RELOC_32;\n\t\t\t\t\t\tut32 data = _read_le32 (rbin, reloc->vaddr);\n\t\t\t\t\t\tif (data == UT32_MAX) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tut64 dst = sym_vaddr - reloc->vaddr;\n\t\t\t\t\t\tdata |= (ut32)((dst >> 2) & 0x3ffffffULL);\n\t\t\t\t\t\tr_write_le32 (patch_buf, data);\n\t\t\t\t\t\tplen = 4;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (patch && plen) {\n\t\t\t\t\trbin->iob.write_at (rbin->iob.io, reloc->vaddr, patch_buf, plen);\n\t\t\t\t\tif (symbol->is_imported) {\n\t\t\t\t\t\treloc->vaddr = sym_vaddr;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tr_list_append (list_rel, reloc);\n\t\t}\n\t\tfree (rel);\n\t}\n\tht_uu_free (imp_vaddr_ht);\n\treturn list_rel;\n}\n\nstatic RList *relocs(RBinFile *bf) {\n\tstruct r_bin_coff_obj *bin = (struct r_bin_coff_obj*)bf->o->bin_obj;\n\treturn _relocs_list (bf->rbin, bin, false, UT64_MAX);\n}\n\nstatic RList *patch_relocs(RBin *b) {\n\tr_return_val_if_fail (b && b->iob.io && b->iob.io->desc, NULL);\n\tRBinObject *bo = r_bin_cur_object (b);\n\tRIO *io = b->iob.io;\n\tif (!bo || !bo->bin_obj) {\n\t\treturn NULL;\n\t}\n\tstruct r_bin_coff_obj *bin = (struct r_bin_coff_obj*)bo->bin_obj;\n\tif (bin->hdr.f_flags & COFF_FLAGS_TI_F_EXEC) {\n\t\treturn NULL;\n\t}\n\tif (!(io->cached & R_PERM_W)) {\n\t\teprintf (\n\t\t\t\"Warning: please run r2 with -e io.cache=true to patch \"\n\t\t\t\"relocations\\n\");\n\t\treturn NULL;\n\t}\n\n\tsize_t nimports = 0;\n\tint i;\n\tif (bin->symbols) {\n\t\tfor (i = 0; i < bin->hdr.f_nsyms; i++) {\n\t\t\tif (is_imported_symbol (&bin->symbols[i])) {\n\t\t\t\tnimports++;\n\t\t\t}\n\t\t\ti += bin->symbols[i].n_numaux;\n\t\t}\n\t}\n\tut64 m_vaddr = UT64_MAX;\n\tif (nimports) {\n\t\tut64 offset = 0;\n\t\tRIOBank *bank = b->iob.bank_get (io, io->bank);\n\t\tRListIter *iter;\n\t\tRIOMapRef *mapref;\n\t\tr_list_foreach (bank->maprefs, iter, mapref) {\n\t\t\tRIOMap *map = b->iob.map_get (io, mapref->id);\n\t\t\tif (r_io_map_end (map) > offset) {\n\t\t\t\toffset = r_io_map_end (map);\n\t\t\t}\n\t\t}\n\t\tm_vaddr = R_ROUND (offset, 16);\n\t\tut64 size = nimports * BYTES_PER_IMP_RELOC;\n\t\tchar *muri = r_str_newf (\"malloc://%\" PFMT64u, size);\n\t\tRIODesc *desc = b->iob.open_at (io, muri, R_PERM_R, 0664, m_vaddr);\n\t\tfree (muri);\n\t\tif (!desc) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\tRIOMap *map = b->iob.map_get_at (io, m_vaddr);\n\t\tif (!map) {\n\t\t\treturn NULL;\n\t\t}\n\t\tmap->name = strdup (\".imports.r2\");\n\t}\n\n\treturn _relocs_list (b, bin, true, m_vaddr);\n}\n\nstatic RBinInfo *info(RBinFile *bf) {\n\tRBinInfo *ret = R_NEW0 (RBinInfo);\n\tstruct r_bin_coff_obj *obj = (struct r_bin_coff_obj*)bf->o->bin_obj;\n\n\tret->file = bf->file? strdup (bf->file): NULL;\n\tret->rclass = strdup (\"coff\");\n\tret->bclass = strdup (\"coff\");\n\tret->type = strdup (\"COFF (Executable file)\");\n\tret->os = strdup (\"any\");\n\tret->subsystem = strdup (\"any\");\n\tret->big_endian = obj->endian;\n\tret->has_va = true;\n\tret->dbg_info = 0;\n\tret->has_lit = true;\n\n\tif (r_coff_is_stripped (obj)) {\n\t\tret->dbg_info |= R_BIN_DBG_STRIPPED;\n\t} else {\n\t\tif (!(obj->hdr.f_flags & COFF_FLAGS_TI_F_RELFLG)) {\n\t\t\tret->dbg_info |= R_BIN_DBG_RELOCS;\n\t\t}\n\t\tif (!(obj->hdr.f_flags & COFF_FLAGS_TI_F_LNNO)) {\n\t\t\tret->dbg_info |= R_BIN_DBG_LINENUMS;\n\t\t}\n\t\tif (!(obj->hdr.f_flags & COFF_FLAGS_TI_F_EXEC)) {\n\t\t\tret->dbg_info |= R_BIN_DBG_SYMS;\n\t\t}\n\t}\n\n\tswitch (obj->hdr.f_magic) {\n\tcase COFF_FILE_MACHINE_R4000:\n \tcase COFF_FILE_MACHINE_MIPS16:\n \tcase COFF_FILE_MACHINE_MIPSFPU:\n \tcase COFF_FILE_MACHINE_MIPSFPU16:\n \t\tret->machine = strdup (\"mips\");\n \t\tret->arch = strdup (\"mips\");\n \t\tret->bits = 32;\n \t\tbreak;\n\tcase COFF_FILE_MACHINE_I386:\n\t\tret->machine = strdup (\"i386\");\n\t\tret->arch = strdup (\"x86\");\n\t\tret->bits = 32;\n\t\tbreak;\n\tcase COFF_FILE_MACHINE_ARM64:\n\t\tret->machine = strdup (\"aarch64\");\n\t\tret->arch = strdup (\"arm\");\n\t\tret->bits = 64;\n\t\tbreak;\n\tcase COFF_FILE_MACHINE_THUMB:\n \t\tret->machine = strdup (\"arm\");\n \t\tret->arch = strdup (\"arm\");\n \t\tret->bits = 16;\n \t\tbreak;\n\tcase COFF_FILE_MACHINE_ARM:\n\t\tret->machine = strdup (\"ARM\");\n\t\tret->arch = strdup (\"arm\");\n\t\tret->bits = 32;\n\t\tbreak;\n\tcase COFF_FILE_MACHINE_AMD64:\n\t\tret->machine = strdup (\"AMD64\");\n\t\tret->arch = strdup (\"x86\");\n\t\tret->bits = 64;\n\t\tbreak;\n\tcase COFF_FILE_MACHINE_H8300:\n\t\tret->machine = strdup (\"H8300\");\n\t\tret->arch = strdup (\"h8300\");\n\t\tret->bits = 16;\n\t\tbreak;\n\tcase COFF_FILE_MACHINE_AMD29KBE:\n\tcase COFF_FILE_MACHINE_AMD29KLE:\n\t\tret->cpu = strdup (\"29000\");\n\t\tret->machine = strdup (\"amd29k\");\n\t\tret->arch = strdup (\"amd29k\");\n\t\tret->bits = 32;\n\t\tbreak;\n\tcase COFF_FILE_MACHINE_ARMNT:\n\t\tret->machine = strdup (\"arm\");\n\t\tret->arch = strdup (\"arm\");\n\t\tret->bits = 32;\n\t\tbreak;\n\tcase COFF_FILE_MACHINE_SH3:\n \tcase COFF_FILE_MACHINE_SH3DSP:\n \tcase COFF_FILE_MACHINE_SH4:\n \tcase COFF_FILE_MACHINE_SH5:\n \t\tret->machine = strdup (\"sh\");\n \t\tret->arch = strdup (\"sh\");\n \t\tret->bits = 32;\n \t\tbreak;\n\tcase COFF_FILE_TI_COFF:\n\t\tswitch (obj->target_id) {\n\t\tcase COFF_FILE_MACHINE_TMS320C54:\n\t\t\tret->machine = strdup (\"c54x\");\n\t\t\tret->arch = strdup (\"tms320\");\n\t\t\tret->bits = 32;\n\t\t\tbreak;\n\t\tcase COFF_FILE_MACHINE_TMS320C55:\n\t\t\tret->machine = strdup (\"c55x\");\n\t\t\tret->arch = strdup (\"tms320\");\n\t\t\tret->bits = 32;\n\t\t\tbreak;\n\t\tcase COFF_FILE_MACHINE_TMS320C55PLUS:\n\t\t\tret->machine = strdup (\"c55x+\");\n\t\t\tret->arch = strdup (\"tms320\");\n\t\t\tret->bits = 32;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase COFF_FILE_MACHINE_POWERPC:\n\t\tret->machine = strdup (\"ppc\");\n\t\tret->arch = strdup (\"ppc\");\n\t\tret->big_endian = true;\n\t\tret->bits = 32;\n\t\tbreak;\n\tdefault:\n\t\tret->machine = strdup (\"unknown\");\n\t}\n\n\treturn ret;\n}\n\nstatic bool check_buffer(RBinFile *bf, RBuffer *buf) {\n#if 0\nTODO: do more checks here to avoid false positives\n\nut16 MACHINE\nut16 NSECTIONS\nut32 DATE\nut32 PTRTOSYMTABLE\nut32 NUMOFSYMS\nut16 OPTHDRSIZE\nut16 CHARACTERISTICS\n#endif\n\n\tut8 tmp[20];\n\tint r = r_buf_read_at (buf, 0, tmp, sizeof (tmp));\n\treturn r >= 20 && r_coff_supported_arch (tmp);\n}\n\nRBinPlugin r_bin_plugin_coff = {\n\t.name = \"coff\",\n\t.desc = \"COFF format r_bin plugin\",\n\t.license = \"LGPL3\",\n\t.get_sdb = &get_sdb,\n\t.load_buffer = &load_buffer,\n\t.destroy = &destroy,\n\t.check_buffer = &check_buffer,\n\t.binsym = &binsym,\n\t.entries = &entries,\n\t.sections = &sections,\n\t.symbols = &symbols,\n\t.imports = &imports,\n\t.info = &info,\n\t.libs = &libs,\n\t.relocs = &relocs,\n\t.patch_relocs = &patch_relocs\n};\n\n#ifndef R2_PLUGIN_INCORE\nR_API RLibStruct radare_plugin = {\n\t.type = R_LIB_TYPE_BIN,\n\t.data = &r_bin_plugin_coff,\n\t.version = R2_VERSION\n};\n#endif\n"], "filenames": ["libr/bin/p/bin_coff.c"], "buggy_code_start_loc": [508], "buggy_code_end_loc": [513], "fixing_code_start_loc": [508], "fixing_code_end_loc": [515], "type": "CWE-400", "message": "Denial of Service in GitHub repository radareorg/radare2 prior to 5.8.6.", "other": {"cve": {"id": "CVE-2023-1605", "sourceIdentifier": "security@huntr.dev", "published": "2023-03-23T19:15:12.863", "lastModified": "2023-03-27T16:50:07.540", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Denial of Service in GitHub repository radareorg/radare2 prior to 5.8.6."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-400"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:radare:radare2:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.8.6", "matchCriteriaId": "045B7EE7-A10D-430E-A936-327F65AFD8A7"}]}]}], "references": [{"url": "https://github.com/radareorg/radare2/commit/508a6307045441defd1bef0999a1f7052097613f", "source": "security@huntr.dev", "tags": ["Patch"]}, {"url": "https://huntr.dev/bounties/9dddcf5b-7dd4-46cc-abf9-172dce20bab2", "source": "security@huntr.dev", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/radareorg/radare2/commit/508a6307045441defd1bef0999a1f7052097613f"}}