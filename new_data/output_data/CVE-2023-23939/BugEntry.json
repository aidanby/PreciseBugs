{"buggy_code": ["import * as run from './run'\nimport { getkubectlDownloadURL, getKubectlArch, getExecutableExtension } from './helpers';\nimport * as os from 'os';\nimport * as toolCache from '@actions/tool-cache';\nimport * as fs from 'fs';\nimport * as path from 'path';\nimport * as core from '@actions/core';\nimport * as util from 'util';\n\ndescribe('Testing all functions in run file.', () => {\n    test('getExecutableExtension() - return .exe when os is Windows', () => {\n        jest.spyOn(os, 'type').mockReturnValue('Windows_NT');\n\n        expect(getExecutableExtension()).toBe('.exe');\n        expect(os.type).toBeCalled();\n    });\n\n    test('getExecutableExtension() - return empty string for non-windows OS', () => {\n        jest.spyOn(os, 'type').mockReturnValue('Darwin');\n\n        expect(getExecutableExtension()).toBe('');\n        expect(os.type).toBeCalled();\n    });\n\n    test.each([\n        ['arm', 'arm'],\n        ['arm64', 'arm64'],\n        ['x64', 'amd64']\n    ])(\"getKubectlArch() - return on %s os arch %s kubectl arch\", (osArch, kubectlArch) => {\n        jest.spyOn(os, 'arch').mockReturnValue(osArch);\n\n        expect(getKubectlArch()).toBe(kubectlArch);\n        expect(os.arch).toBeCalled();\n    });\n\n    test.each([\n        ['arm'],\n        ['arm64'],\n        ['amd64']\n    ])('getkubectlDownloadURL() - return the URL to download %s kubectl for Linux', (arch) => {\n        jest.spyOn(os, 'type').mockReturnValue('Linux');\n        const kubectlLinuxUrl = util.format('https://storage.googleapis.com/kubernetes-release/release/v1.15.0/bin/linux/%s/kubectl', arch);\n\n        expect(getkubectlDownloadURL('v1.15.0', arch)).toBe(kubectlLinuxUrl);\n        expect(os.type).toBeCalled();\n    });\n\n    test.each([\n        ['arm'],\n        ['arm64'],\n        ['amd64']\n    ])('getkubectlDownloadURL() - return the URL to download %s kubectl for Darwin', (arch) => {\n        jest.spyOn(os, 'type').mockReturnValue('Darwin');\n        const kubectlDarwinUrl = util.format('https://storage.googleapis.com/kubernetes-release/release/v1.15.0/bin/darwin/%s/kubectl', arch);\n\n        expect(getkubectlDownloadURL('v1.15.0', arch)).toBe(kubectlDarwinUrl);\n        expect(os.type).toBeCalled();\n    });\n\n    test.each([\n        ['arm'],\n        ['arm64'],\n        ['amd64']\n    ])('getkubectlDownloadURL() - return the URL to download %s kubectl for Windows', (arch) => {\n        jest.spyOn(os, 'type').mockReturnValue('Windows_NT');\n\n        const kubectlWindowsUrl = util.format('https://storage.googleapis.com/kubernetes-release/release/v1.15.0/bin/windows/%s/kubectl.exe', arch);\n        expect(getkubectlDownloadURL('v1.15.0', arch)).toBe(kubectlWindowsUrl);\n        expect(os.type).toBeCalled();\n    });\n\n    test('getStableKubectlVersion() - download stable version file, read version and return it', async () => {\n        jest.spyOn(toolCache, 'downloadTool').mockReturnValue(Promise.resolve('pathToTool'));\n        jest.spyOn(fs, 'readFileSync').mockReturnValue('v1.20.4');\n\n        expect(await run.getStableKubectlVersion()).toBe('v1.20.4');\n        expect(toolCache.downloadTool).toBeCalled();\n        expect(fs.readFileSync).toBeCalledWith('pathToTool', 'utf8');\n    });\n\n    test('getStableKubectlVersion() - return default v1.15.0 if version read is empty', async () => {\n        jest.spyOn(toolCache, 'downloadTool').mockReturnValue(Promise.resolve('pathToTool'));\n        jest.spyOn(fs, 'readFileSync').mockReturnValue('');\n\n        expect(await run.getStableKubectlVersion()).toBe('v1.15.0');\n        expect(toolCache.downloadTool).toBeCalled();\n        expect(fs.readFileSync).toBeCalledWith('pathToTool', 'utf8');\n    });\n\n    test('getStableKubectlVersion() - return default v1.15.0 if unable to download file', async () => {\n        jest.spyOn(toolCache, 'downloadTool').mockRejectedValue('Unable to download.');\n\n        expect(await run.getStableKubectlVersion()).toBe('v1.15.0');\n        expect(toolCache.downloadTool).toBeCalled();\n    });\n\n    test('downloadKubectl() - download kubectl, add it to toolCache and return path to it', async () => {\n        jest.spyOn(toolCache, 'find').mockReturnValue('');\n        jest.spyOn(toolCache, 'downloadTool').mockReturnValue(Promise.resolve('pathToTool'));\n        jest.spyOn(toolCache, 'cacheFile').mockReturnValue(Promise.resolve('pathToCachedTool'));\n        jest.spyOn(os, 'type').mockReturnValue('Windows_NT');\n        jest.spyOn(fs, 'chmodSync').mockImplementation(() => { });\n\n        expect(await run.downloadKubectl('v1.15.0')).toBe(path.join('pathToCachedTool', 'kubectl.exe'));\n        expect(toolCache.find).toBeCalledWith('kubectl', 'v1.15.0');\n        expect(toolCache.downloadTool).toBeCalled();\n        expect(toolCache.cacheFile).toBeCalled();\n        expect(os.type).toBeCalled();\n        expect(fs.chmodSync).toBeCalledWith(path.join('pathToCachedTool', 'kubectl.exe'), '777');\n    });\n\n    test('downloadKubectl() - throw DownloadKubectlFailed error when unable to download kubectl', async () => {\n        jest.spyOn(toolCache, 'find').mockReturnValue('');\n        jest.spyOn(toolCache, 'downloadTool').mockRejectedValue('Unable to download kubectl.');\n\n        await expect(run.downloadKubectl('v1.15.0')).rejects.toThrow('DownloadKubectlFailed');\n        expect(toolCache.find).toBeCalledWith('kubectl', 'v1.15.0');\n        expect(toolCache.downloadTool).toBeCalled();\n    });\n\n    test('downloadKubectl() - throw kubectl not found error when receive 404 response', async () => {\n        const kubectlVersion = 'v1.15.0'\n        const arch = 'arm128';\n\n        jest.spyOn(os, 'arch').mockReturnValue(arch);\n        jest.spyOn(toolCache, 'find').mockReturnValue('');\n        jest.spyOn(toolCache, 'downloadTool').mockImplementation(_ => {\n            throw new toolCache.HTTPError(404);\n        });\n\n        await expect(run.downloadKubectl(kubectlVersion)).rejects\n            .toThrow(util.format(\"Kubectl '%s' for '%s' arch not found.\", kubectlVersion, arch));\n        expect(os.arch).toBeCalled();\n        expect(toolCache.find).toBeCalledWith('kubectl', kubectlVersion);\n        expect(toolCache.downloadTool).toBeCalled();\n    });\n\n    test('downloadKubectl() - return path to existing cache of kubectl', async () => {\n        jest.spyOn(toolCache, 'find').mockReturnValue('pathToCachedTool');\n        jest.spyOn(os, 'type').mockReturnValue('Windows_NT');\n        jest.spyOn(fs, 'chmodSync').mockImplementation(() => { });\n        jest.spyOn(toolCache, 'downloadTool');\n\n        expect(await run.downloadKubectl('v1.15.0')).toBe(path.join('pathToCachedTool', 'kubectl.exe'));\n        expect(toolCache.find).toBeCalledWith('kubectl', 'v1.15.0');\n        expect(os.type).toBeCalled();\n        expect(fs.chmodSync).toBeCalledWith(path.join('pathToCachedTool', 'kubectl.exe'), '777');\n        expect(toolCache.downloadTool).not.toBeCalled();\n    });\n\n    test('run() - download specified version and set output', async () => {\n        jest.spyOn(core, 'getInput').mockReturnValue('v1.15.5');\n        jest.spyOn(toolCache, 'find').mockReturnValue('pathToCachedTool');\n        jest.spyOn(os, 'type').mockReturnValue('Windows_NT');\n        jest.spyOn(fs, 'chmodSync').mockImplementation();\n        jest.spyOn(core, 'addPath').mockImplementation();\n        jest.spyOn(console, 'log').mockImplementation();\n        jest.spyOn(core, 'setOutput').mockImplementation();\n\n        expect(await run.run()).toBeUndefined();\n        expect(core.getInput).toBeCalledWith('version', { 'required': true });\n        expect(core.addPath).toBeCalledWith('pathToCachedTool');\n        expect(core.setOutput).toBeCalledWith('kubectl-path', path.join('pathToCachedTool', 'kubectl.exe'));\n    });\n\n    test('run() - get latest version, download it and set output', async () => {\n        jest.spyOn(core, 'getInput').mockReturnValue('latest');\n        jest.spyOn(toolCache, 'downloadTool').mockReturnValue(Promise.resolve('pathToTool'));\n        jest.spyOn(fs, 'readFileSync').mockReturnValue('v1.20.4');\n        jest.spyOn(toolCache, 'find').mockReturnValue('pathToCachedTool');\n        jest.spyOn(os, 'type').mockReturnValue('Windows_NT');\n        jest.spyOn(fs, 'chmodSync').mockImplementation();\n        jest.spyOn(core, 'addPath').mockImplementation();\n        jest.spyOn(console, 'log').mockImplementation();\n        jest.spyOn(core, 'setOutput').mockImplementation();\n\n        expect(await run.run()).toBeUndefined();\n        expect(toolCache.downloadTool).toBeCalledWith('https://storage.googleapis.com/kubernetes-release/release/stable.txt');\n        expect(core.getInput).toBeCalledWith('version', { 'required': true });\n        expect(core.addPath).toBeCalledWith('pathToCachedTool');\n        expect(core.setOutput).toBeCalledWith('kubectl-path', path.join('pathToCachedTool', 'kubectl.exe'));\n    });\n});", "import * as path from 'path';\r\nimport * as util from 'util';\r\nimport * as fs from 'fs';\r\n\r\nimport * as toolCache from '@actions/tool-cache';\r\nimport * as core from '@actions/core';\r\n\r\nimport { getkubectlDownloadURL, getKubectlArch, getExecutableExtension } from './helpers';\r\n\r\nconst kubectlToolName = 'kubectl';\r\nconst stableKubectlVersion = 'v1.15.0';\r\nconst stableVersionUrl = 'https://storage.googleapis.com/kubernetes-release/release/stable.txt';\r\n\r\nexport async function run() {\r\n    let version = core.getInput('version', { 'required': true });\r\n    if (version.toLocaleLowerCase() === 'latest') {\r\n        version = await getStableKubectlVersion();\r\n    }\r\n    const cachedPath = await downloadKubectl(version);\r\n\r\n    core.addPath(path.dirname(cachedPath));\r\n\r\n    core.debug(`Kubectl tool version: '${version}' has been cached at ${cachedPath}`);\r\n    core.setOutput('kubectl-path', cachedPath);\r\n}\r\n\r\nexport async function getStableKubectlVersion(): Promise<string> {\r\n    return toolCache.downloadTool(stableVersionUrl).then((downloadPath) => {\r\n        let version = fs.readFileSync(downloadPath, 'utf8').toString().trim();\r\n        if (!version) {\r\n            version = stableKubectlVersion;\r\n        }\r\n        return version;\r\n    }, (error) => {\r\n        core.debug(error);\r\n        core.warning('GetStableVersionFailed');\r\n        return stableKubectlVersion;\r\n    });\r\n}\r\n\r\nexport async function downloadKubectl(version: string): Promise<string> {\r\n    let cachedToolpath = toolCache.find(kubectlToolName, version);\r\n    let kubectlDownloadPath = '';\r\n    const arch = getKubectlArch();\r\n    if (!cachedToolpath) {\r\n        try {\r\n            kubectlDownloadPath = await toolCache.downloadTool(getkubectlDownloadURL(version, arch));\r\n        } catch (exception) {\r\n            if (exception instanceof toolCache.HTTPError && exception.httpStatusCode === 404) {\r\n                throw new Error(util.format(\"Kubectl '%s' for '%s' arch not found.\", version, arch));\r\n            } else {\r\n                throw new Error('DownloadKubectlFailed');\r\n            }\r\n        }\r\n\r\n        cachedToolpath = await toolCache.cacheFile(kubectlDownloadPath, kubectlToolName + getExecutableExtension(), kubectlToolName, version);\r\n    }\r\n\r\n    const kubectlPath = path.join(cachedToolpath, kubectlToolName + getExecutableExtension());\r\n    fs.chmodSync(kubectlPath, '777');\r\n    return kubectlPath;\r\n}\r\n\r\nrun().catch(core.setFailed);\r\n"], "fixing_code": ["import * as run from './run'\nimport { getkubectlDownloadURL, getKubectlArch, getExecutableExtension } from './helpers';\nimport * as os from 'os';\nimport * as toolCache from '@actions/tool-cache';\nimport * as fs from 'fs';\nimport * as path from 'path';\nimport * as core from '@actions/core';\nimport * as util from 'util';\n\ndescribe('Testing all functions in run file.', () => {\n    test('getExecutableExtension() - return .exe when os is Windows', () => {\n        jest.spyOn(os, 'type').mockReturnValue('Windows_NT');\n\n        expect(getExecutableExtension()).toBe('.exe');\n        expect(os.type).toBeCalled();\n    });\n\n    test('getExecutableExtension() - return empty string for non-windows OS', () => {\n        jest.spyOn(os, 'type').mockReturnValue('Darwin');\n\n        expect(getExecutableExtension()).toBe('');\n        expect(os.type).toBeCalled();\n    });\n\n    test.each([\n        ['arm', 'arm'],\n        ['arm64', 'arm64'],\n        ['x64', 'amd64']\n    ])(\"getKubectlArch() - return on %s os arch %s kubectl arch\", (osArch, kubectlArch) => {\n        jest.spyOn(os, 'arch').mockReturnValue(osArch);\n\n        expect(getKubectlArch()).toBe(kubectlArch);\n        expect(os.arch).toBeCalled();\n    });\n\n    test.each([\n        ['arm'],\n        ['arm64'],\n        ['amd64']\n    ])('getkubectlDownloadURL() - return the URL to download %s kubectl for Linux', (arch) => {\n        jest.spyOn(os, 'type').mockReturnValue('Linux');\n        const kubectlLinuxUrl = util.format('https://storage.googleapis.com/kubernetes-release/release/v1.15.0/bin/linux/%s/kubectl', arch);\n\n        expect(getkubectlDownloadURL('v1.15.0', arch)).toBe(kubectlLinuxUrl);\n        expect(os.type).toBeCalled();\n    });\n\n    test.each([\n        ['arm'],\n        ['arm64'],\n        ['amd64']\n    ])('getkubectlDownloadURL() - return the URL to download %s kubectl for Darwin', (arch) => {\n        jest.spyOn(os, 'type').mockReturnValue('Darwin');\n        const kubectlDarwinUrl = util.format('https://storage.googleapis.com/kubernetes-release/release/v1.15.0/bin/darwin/%s/kubectl', arch);\n\n        expect(getkubectlDownloadURL('v1.15.0', arch)).toBe(kubectlDarwinUrl);\n        expect(os.type).toBeCalled();\n    });\n\n    test.each([\n        ['arm'],\n        ['arm64'],\n        ['amd64']\n    ])('getkubectlDownloadURL() - return the URL to download %s kubectl for Windows', (arch) => {\n        jest.spyOn(os, 'type').mockReturnValue('Windows_NT');\n\n        const kubectlWindowsUrl = util.format('https://storage.googleapis.com/kubernetes-release/release/v1.15.0/bin/windows/%s/kubectl.exe', arch);\n        expect(getkubectlDownloadURL('v1.15.0', arch)).toBe(kubectlWindowsUrl);\n        expect(os.type).toBeCalled();\n    });\n\n    test('getStableKubectlVersion() - download stable version file, read version and return it', async () => {\n        jest.spyOn(toolCache, 'downloadTool').mockReturnValue(Promise.resolve('pathToTool'));\n        jest.spyOn(fs, 'readFileSync').mockReturnValue('v1.20.4');\n\n        expect(await run.getStableKubectlVersion()).toBe('v1.20.4');\n        expect(toolCache.downloadTool).toBeCalled();\n        expect(fs.readFileSync).toBeCalledWith('pathToTool', 'utf8');\n    });\n\n    test('getStableKubectlVersion() - return default v1.15.0 if version read is empty', async () => {\n        jest.spyOn(toolCache, 'downloadTool').mockReturnValue(Promise.resolve('pathToTool'));\n        jest.spyOn(fs, 'readFileSync').mockReturnValue('');\n\n        expect(await run.getStableKubectlVersion()).toBe('v1.15.0');\n        expect(toolCache.downloadTool).toBeCalled();\n        expect(fs.readFileSync).toBeCalledWith('pathToTool', 'utf8');\n    });\n\n    test('getStableKubectlVersion() - return default v1.15.0 if unable to download file', async () => {\n        jest.spyOn(toolCache, 'downloadTool').mockRejectedValue('Unable to download.');\n\n        expect(await run.getStableKubectlVersion()).toBe('v1.15.0');\n        expect(toolCache.downloadTool).toBeCalled();\n    });\n\n    test('downloadKubectl() - download kubectl, add it to toolCache and return path to it', async () => {\n        jest.spyOn(toolCache, 'find').mockReturnValue('');\n        jest.spyOn(toolCache, 'downloadTool').mockReturnValue(Promise.resolve('pathToTool'));\n        jest.spyOn(toolCache, 'cacheFile').mockReturnValue(Promise.resolve('pathToCachedTool'));\n        jest.spyOn(os, 'type').mockReturnValue('Windows_NT');\n        jest.spyOn(fs, 'chmodSync').mockImplementation(() => { });\n\n        expect(await run.downloadKubectl('v1.15.0')).toBe(path.join('pathToCachedTool', 'kubectl.exe'));\n        expect(toolCache.find).toBeCalledWith('kubectl', 'v1.15.0');\n        expect(toolCache.downloadTool).toBeCalled();\n        expect(toolCache.cacheFile).toBeCalled();\n        expect(os.type).toBeCalled();\n        expect(fs.chmodSync).toBeCalledWith(path.join('pathToCachedTool', 'kubectl.exe'), '775');\n    });\n\n    test('downloadKubectl() - throw DownloadKubectlFailed error when unable to download kubectl', async () => {\n        jest.spyOn(toolCache, 'find').mockReturnValue('');\n        jest.spyOn(toolCache, 'downloadTool').mockRejectedValue('Unable to download kubectl.');\n\n        await expect(run.downloadKubectl('v1.15.0')).rejects.toThrow('DownloadKubectlFailed');\n        expect(toolCache.find).toBeCalledWith('kubectl', 'v1.15.0');\n        expect(toolCache.downloadTool).toBeCalled();\n    });\n\n    test('downloadKubectl() - throw kubectl not found error when receive 404 response', async () => {\n        const kubectlVersion = 'v1.15.0'\n        const arch = 'arm128';\n\n        jest.spyOn(os, 'arch').mockReturnValue(arch);\n        jest.spyOn(toolCache, 'find').mockReturnValue('');\n        jest.spyOn(toolCache, 'downloadTool').mockImplementation(_ => {\n            throw new toolCache.HTTPError(404);\n        });\n\n        await expect(run.downloadKubectl(kubectlVersion)).rejects\n            .toThrow(util.format(\"Kubectl '%s' for '%s' arch not found.\", kubectlVersion, arch));\n        expect(os.arch).toBeCalled();\n        expect(toolCache.find).toBeCalledWith('kubectl', kubectlVersion);\n        expect(toolCache.downloadTool).toBeCalled();\n    });\n\n    test('downloadKubectl() - return path to existing cache of kubectl', async () => {\n        jest.spyOn(toolCache, 'find').mockReturnValue('pathToCachedTool');\n        jest.spyOn(os, 'type').mockReturnValue('Windows_NT');\n        jest.spyOn(fs, 'chmodSync').mockImplementation(() => { });\n        jest.spyOn(toolCache, 'downloadTool');\n\n        expect(await run.downloadKubectl('v1.15.0')).toBe(path.join('pathToCachedTool', 'kubectl.exe'));\n        expect(toolCache.find).toBeCalledWith('kubectl', 'v1.15.0');\n        expect(os.type).toBeCalled();\n        expect(fs.chmodSync).toBeCalledWith(path.join('pathToCachedTool', 'kubectl.exe'), '775');\n        expect(toolCache.downloadTool).not.toBeCalled();\n    });\n\n    test('run() - download specified version and set output', async () => {\n        jest.spyOn(core, 'getInput').mockReturnValue('v1.15.5');\n        jest.spyOn(toolCache, 'find').mockReturnValue('pathToCachedTool');\n        jest.spyOn(os, 'type').mockReturnValue('Windows_NT');\n        jest.spyOn(fs, 'chmodSync').mockImplementation();\n        jest.spyOn(core, 'addPath').mockImplementation();\n        jest.spyOn(console, 'log').mockImplementation();\n        jest.spyOn(core, 'setOutput').mockImplementation();\n\n        expect(await run.run()).toBeUndefined();\n        expect(core.getInput).toBeCalledWith('version', { 'required': true });\n        expect(core.addPath).toBeCalledWith('pathToCachedTool');\n        expect(core.setOutput).toBeCalledWith('kubectl-path', path.join('pathToCachedTool', 'kubectl.exe'));\n    });\n\n    test('run() - get latest version, download it and set output', async () => {\n        jest.spyOn(core, 'getInput').mockReturnValue('latest');\n        jest.spyOn(toolCache, 'downloadTool').mockReturnValue(Promise.resolve('pathToTool'));\n        jest.spyOn(fs, 'readFileSync').mockReturnValue('v1.20.4');\n        jest.spyOn(toolCache, 'find').mockReturnValue('pathToCachedTool');\n        jest.spyOn(os, 'type').mockReturnValue('Windows_NT');\n        jest.spyOn(fs, 'chmodSync').mockImplementation();\n        jest.spyOn(core, 'addPath').mockImplementation();\n        jest.spyOn(console, 'log').mockImplementation();\n        jest.spyOn(core, 'setOutput').mockImplementation();\n\n        expect(await run.run()).toBeUndefined();\n        expect(toolCache.downloadTool).toBeCalledWith('https://storage.googleapis.com/kubernetes-release/release/stable.txt');\n        expect(core.getInput).toBeCalledWith('version', { 'required': true });\n        expect(core.addPath).toBeCalledWith('pathToCachedTool');\n        expect(core.setOutput).toBeCalledWith('kubectl-path', path.join('pathToCachedTool', 'kubectl.exe'));\n    });\n});", "import * as path from 'path';\r\nimport * as util from 'util';\r\nimport * as fs from 'fs';\r\n\r\nimport * as toolCache from '@actions/tool-cache';\r\nimport * as core from '@actions/core';\r\n\r\nimport { getkubectlDownloadURL, getKubectlArch, getExecutableExtension } from './helpers';\r\n\r\nconst kubectlToolName = 'kubectl';\r\nconst stableKubectlVersion = 'v1.15.0';\r\nconst stableVersionUrl = 'https://storage.googleapis.com/kubernetes-release/release/stable.txt';\r\n\r\nexport async function run() {\r\n    let version = core.getInput('version', { 'required': true });\r\n    if (version.toLocaleLowerCase() === 'latest') {\r\n        version = await getStableKubectlVersion();\r\n    }\r\n    const cachedPath = await downloadKubectl(version);\r\n\r\n    core.addPath(path.dirname(cachedPath));\r\n\r\n    core.debug(`Kubectl tool version: '${version}' has been cached at ${cachedPath}`);\r\n    core.setOutput('kubectl-path', cachedPath);\r\n}\r\n\r\nexport async function getStableKubectlVersion(): Promise<string> {\r\n    return toolCache.downloadTool(stableVersionUrl).then((downloadPath) => {\r\n        let version = fs.readFileSync(downloadPath, 'utf8').toString().trim();\r\n        if (!version) {\r\n            version = stableKubectlVersion;\r\n        }\r\n        return version;\r\n    }, (error) => {\r\n        core.debug(error);\r\n        core.warning('GetStableVersionFailed');\r\n        return stableKubectlVersion;\r\n    });\r\n}\r\n\r\nexport async function downloadKubectl(version: string): Promise<string> {\r\n    let cachedToolpath = toolCache.find(kubectlToolName, version);\r\n    let kubectlDownloadPath = '';\r\n    const arch = getKubectlArch();\r\n    if (!cachedToolpath) {\r\n        try {\r\n            kubectlDownloadPath = await toolCache.downloadTool(getkubectlDownloadURL(version, arch));\r\n        } catch (exception) {\r\n            if (exception instanceof toolCache.HTTPError && exception.httpStatusCode === 404) {\r\n                throw new Error(util.format(\"Kubectl '%s' for '%s' arch not found.\", version, arch));\r\n            } else {\r\n                throw new Error('DownloadKubectlFailed');\r\n            }\r\n        }\r\n\r\n        cachedToolpath = await toolCache.cacheFile(kubectlDownloadPath, kubectlToolName + getExecutableExtension(), kubectlToolName, version);\r\n    }\r\n\r\n    const kubectlPath = path.join(cachedToolpath, kubectlToolName + getExecutableExtension());\r\n    fs.chmodSync(kubectlPath, '775');\r\n    return kubectlPath;\r\n}\r\n\r\nrun().catch(core.setFailed);\r\n"], "filenames": ["src/run.test.ts", "src/run.ts"], "buggy_code_start_loc": [109, 60], "buggy_code_end_loc": [148, 61], "fixing_code_start_loc": [109, 60], "fixing_code_end_loc": [148, 61], "type": "CWE-732", "message": "Azure/setup-kubectl is a GitHub Action for installing Kubectl. This vulnerability only impacts versions before version 3. An insecure temporary creation of a file allows other actors on the Actions runner to replace the Kubectl binary created by this action because it is world writable. This Kubectl tool installer runs `fs.chmodSync(kubectlPath, 777)` to set permissions on the Kubectl binary, however, this allows any local user to replace the Kubectl binary. This allows privilege escalation to the user that can also run kubectl, most likely root. This attack is only possible if an attacker somehow breached the GitHub actions runner or if a user is utilizing an Action that maliciously executes this attack. This has been fixed and released in all versions `v3` and later. 775 permissions are used instead. Users are advised to upgrade. There are no known workarounds for this issue.", "other": {"cve": {"id": "CVE-2023-23939", "sourceIdentifier": "security-advisories@github.com", "published": "2023-03-06T19:15:10.297", "lastModified": "2023-03-13T17:49:16.997", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Azure/setup-kubectl is a GitHub Action for installing Kubectl. This vulnerability only impacts versions before version 3. An insecure temporary creation of a file allows other actors on the Actions runner to replace the Kubectl binary created by this action because it is world writable. This Kubectl tool installer runs `fs.chmodSync(kubectlPath, 777)` to set permissions on the Kubectl binary, however, this allows any local user to replace the Kubectl binary. This allows privilege escalation to the user that can also run kubectl, most likely root. This attack is only possible if an attacker somehow breached the GitHub actions runner or if a user is utilizing an Action that maliciously executes this attack. This has been fixed and released in all versions `v3` and later. 775 permissions are used instead. Users are advised to upgrade. There are no known workarounds for this issue."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.0, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.0, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:H/PR:H/UI:N/S:U/C:L/I:L/A:L", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 3.9, "baseSeverity": "LOW"}, "exploitabilityScore": 0.5, "impactScore": 3.4}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-732"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:microsoft:azure_setup_kubectl:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.0", "matchCriteriaId": "A349BC72-1763-4770-9D6F-F49509C0D780"}]}]}], "references": [{"url": "https://github.com/Azure/setup-kubectl/commit/d449d75495d2b9d1463555bb00ca3dca77a42ab6", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/Azure/setup-kubectl/security/advisories/GHSA-p756-rfxh-x63h", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/Azure/setup-kubectl/commit/d449d75495d2b9d1463555bb00ca3dca77a42ab6"}}