{"buggy_code": ["/*\n * RL2 Format Demuxer\n * Copyright (c) 2008 Sascha Sommer (saschasommer@freenet.de)\n *\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n/**\n * RL2 file demuxer\n * @file\n * @author Sascha Sommer (saschasommer@freenet.de)\n * @see http://wiki.multimedia.cx/index.php?title=RL2\n *\n * extradata:\n * 2 byte le initial drawing offset within 320x200 viewport\n * 4 byte le number of used colors\n * 256 * 3 bytes rgb palette\n * optional background_frame\n */\n\n#include <stdint.h>\n\n#include \"libavutil/intreadwrite.h\"\n#include \"libavutil/mathematics.h\"\n#include \"avformat.h\"\n#include \"internal.h\"\n\n#define EXTRADATA1_SIZE (6 + 256 * 3) ///< video base, clr, palette\n\n#define FORM_TAG MKBETAG('F', 'O', 'R', 'M')\n#define RLV2_TAG MKBETAG('R', 'L', 'V', '2')\n#define RLV3_TAG MKBETAG('R', 'L', 'V', '3')\n\ntypedef struct Rl2DemuxContext {\n    unsigned int index_pos[2];   ///< indexes in the sample tables\n} Rl2DemuxContext;\n\n\n/**\n * check if the file is in rl2 format\n * @param p probe buffer\n * @return 0 when the probe buffer does not contain rl2 data, > 0 otherwise\n */\nstatic int rl2_probe(AVProbeData *p)\n{\n\n    if(AV_RB32(&p->buf[0]) != FORM_TAG)\n        return 0;\n\n    if(AV_RB32(&p->buf[8]) != RLV2_TAG &&\n        AV_RB32(&p->buf[8]) != RLV3_TAG)\n        return 0;\n\n    return AVPROBE_SCORE_MAX;\n}\n\n/**\n * read rl2 header data and setup the avstreams\n * @param s demuxer context\n * @return 0 on success, AVERROR otherwise\n */\nstatic av_cold int rl2_read_header(AVFormatContext *s)\n{\n    AVIOContext *pb = s->pb;\n    AVStream *st;\n    unsigned int frame_count;\n    unsigned int audio_frame_counter = 0;\n    unsigned int video_frame_counter = 0;\n    unsigned int back_size;\n    unsigned short sound_rate;\n    unsigned short rate;\n    unsigned short channels;\n    unsigned short def_sound_size;\n    unsigned int signature;\n    unsigned int pts_den = 11025; /* video only case */\n    unsigned int pts_num = 1103;\n    unsigned int* chunk_offset = NULL;\n    int* chunk_size = NULL;\n    int* audio_size = NULL;\n    int i;\n    int ret = 0;\n\n    avio_skip(pb,4);          /* skip FORM tag */\n    back_size = avio_rl32(pb); /**< get size of the background frame */\n    signature = avio_rb32(pb);\n    avio_skip(pb, 4);         /* data size */\n    frame_count = avio_rl32(pb);\n\n    /* disallow back_sizes and frame_counts that may lead to overflows later */\n    if(back_size > INT_MAX/2  || frame_count > INT_MAX / sizeof(uint32_t))\n        return AVERROR_INVALIDDATA;\n\n    avio_skip(pb, 2);         /* encoding method */\n    sound_rate = avio_rl16(pb);\n    rate = avio_rl16(pb);\n    channels = avio_rl16(pb);\n    def_sound_size = avio_rl16(pb);\n\n    /** setup video stream */\n    st = avformat_new_stream(s, NULL);\n    if(!st)\n         return AVERROR(ENOMEM);\n\n    st->codecpar->codec_type = AVMEDIA_TYPE_VIDEO;\n    st->codecpar->codec_id = AV_CODEC_ID_RL2;\n    st->codecpar->codec_tag = 0;  /* no fourcc */\n    st->codecpar->width = 320;\n    st->codecpar->height = 200;\n\n    /** allocate and fill extradata */\n    st->codecpar->extradata_size = EXTRADATA1_SIZE;\n\n    if(signature == RLV3_TAG && back_size > 0)\n        st->codecpar->extradata_size += back_size;\n\n    if(ff_get_extradata(s, st->codecpar, pb, st->codecpar->extradata_size) < 0)\n        return AVERROR(ENOMEM);\n\n    /** setup audio stream if present */\n    if(sound_rate){\n        if (!channels || channels > 42) {\n            av_log(s, AV_LOG_ERROR, \"Invalid number of channels: %d\\n\", channels);\n            return AVERROR_INVALIDDATA;\n        }\n\n        pts_num = def_sound_size;\n        pts_den = rate;\n\n        st = avformat_new_stream(s, NULL);\n        if (!st)\n            return AVERROR(ENOMEM);\n        st->codecpar->codec_type = AVMEDIA_TYPE_AUDIO;\n        st->codecpar->codec_id = AV_CODEC_ID_PCM_U8;\n        st->codecpar->codec_tag = 1;\n        st->codecpar->channels = channels;\n        st->codecpar->bits_per_coded_sample = 8;\n        st->codecpar->sample_rate = rate;\n        st->codecpar->bit_rate = st->codecpar->channels * st->codecpar->sample_rate *\n            st->codecpar->bits_per_coded_sample;\n        st->codecpar->block_align = st->codecpar->channels *\n            st->codecpar->bits_per_coded_sample / 8;\n        avpriv_set_pts_info(st,32,1,rate);\n    }\n\n    avpriv_set_pts_info(s->streams[0], 32, pts_num, pts_den);\n\n    chunk_size =   av_malloc(frame_count * sizeof(uint32_t));\n    audio_size =   av_malloc(frame_count * sizeof(uint32_t));\n    chunk_offset = av_malloc(frame_count * sizeof(uint32_t));\n\n    if(!chunk_size || !audio_size || !chunk_offset){\n        av_free(chunk_size);\n        av_free(audio_size);\n        av_free(chunk_offset);\n        return AVERROR(ENOMEM);\n    }\n\n    /** read offset and size tables */\n    for(i=0; i < frame_count;i++)\n        chunk_size[i] = avio_rl32(pb);\n    for(i=0; i < frame_count;i++)\n        chunk_offset[i] = avio_rl32(pb);\n    for(i=0; i < frame_count;i++)\n        audio_size[i] = avio_rl32(pb) & 0xFFFF;\n\n    /** build the sample index */\n    for(i=0;i<frame_count;i++){\n        if(chunk_size[i] < 0 || audio_size[i] > chunk_size[i]){\n            ret = AVERROR_INVALIDDATA;\n            break;\n        }\n\n        if(sound_rate && audio_size[i]){\n            av_add_index_entry(s->streams[1], chunk_offset[i],\n                audio_frame_counter,audio_size[i], 0, AVINDEX_KEYFRAME);\n            audio_frame_counter += audio_size[i] / channels;\n        }\n        av_add_index_entry(s->streams[0], chunk_offset[i] + audio_size[i],\n            video_frame_counter,chunk_size[i]-audio_size[i],0,AVINDEX_KEYFRAME);\n        ++video_frame_counter;\n    }\n\n\n    av_free(chunk_size);\n    av_free(audio_size);\n    av_free(chunk_offset);\n\n    return ret;\n}\n\n/**\n * read a single audio or video packet\n * @param s demuxer context\n * @param pkt the packet to be filled\n * @return 0 on success, AVERROR otherwise\n */\nstatic int rl2_read_packet(AVFormatContext *s,\n                            AVPacket *pkt)\n{\n    Rl2DemuxContext *rl2 = s->priv_data;\n    AVIOContext *pb = s->pb;\n    AVIndexEntry *sample = NULL;\n    int i;\n    int ret = 0;\n    int stream_id = -1;\n    int64_t pos = INT64_MAX;\n\n    /** check if there is a valid video or audio entry that can be used */\n    for(i=0; i<s->nb_streams; i++){\n        if(rl2->index_pos[i] < s->streams[i]->nb_index_entries\n              && s->streams[i]->index_entries[ rl2->index_pos[i] ].pos < pos){\n            sample = &s->streams[i]->index_entries[ rl2->index_pos[i] ];\n            pos= sample->pos;\n            stream_id= i;\n        }\n    }\n\n    if(stream_id == -1)\n        return AVERROR_EOF;\n\n    ++rl2->index_pos[stream_id];\n\n    /** position the stream (will probably be there anyway) */\n    avio_seek(pb, sample->pos, SEEK_SET);\n\n    /** fill the packet */\n    ret = av_get_packet(pb, pkt, sample->size);\n    if(ret != sample->size){\n        av_packet_unref(pkt);\n        return AVERROR(EIO);\n    }\n\n    pkt->stream_index = stream_id;\n    pkt->pts = sample->timestamp;\n\n    return ret;\n}\n\n/**\n * seek to a new timestamp\n * @param s demuxer context\n * @param stream_index index of the stream that should be seeked\n * @param timestamp wanted timestamp\n * @param flags direction and seeking mode\n * @return 0 on success, -1 otherwise\n */\nstatic int rl2_read_seek(AVFormatContext *s, int stream_index, int64_t timestamp, int flags)\n{\n    AVStream *st = s->streams[stream_index];\n    Rl2DemuxContext *rl2 = s->priv_data;\n    int i;\n    int index = av_index_search_timestamp(st, timestamp, flags);\n    if(index < 0)\n        return -1;\n\n    rl2->index_pos[stream_index] = index;\n    timestamp = st->index_entries[index].timestamp;\n\n    for(i=0; i < s->nb_streams; i++){\n        AVStream *st2 = s->streams[i];\n        index = av_index_search_timestamp(st2,\n                    av_rescale_q(timestamp, st->time_base, st2->time_base),\n                    flags | AVSEEK_FLAG_BACKWARD);\n\n        if(index < 0)\n            index = 0;\n\n        rl2->index_pos[i] = index;\n    }\n\n    return 0;\n}\n\nAVInputFormat ff_rl2_demuxer = {\n    .name           = \"rl2\",\n    .long_name      = NULL_IF_CONFIG_SMALL(\"RL2\"),\n    .priv_data_size = sizeof(Rl2DemuxContext),\n    .read_probe     = rl2_probe,\n    .read_header    = rl2_read_header,\n    .read_packet    = rl2_read_packet,\n    .read_seek      = rl2_read_seek,\n};\n"], "fixing_code": ["/*\n * RL2 Format Demuxer\n * Copyright (c) 2008 Sascha Sommer (saschasommer@freenet.de)\n *\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n/**\n * RL2 file demuxer\n * @file\n * @author Sascha Sommer (saschasommer@freenet.de)\n * @see http://wiki.multimedia.cx/index.php?title=RL2\n *\n * extradata:\n * 2 byte le initial drawing offset within 320x200 viewport\n * 4 byte le number of used colors\n * 256 * 3 bytes rgb palette\n * optional background_frame\n */\n\n#include <stdint.h>\n\n#include \"libavutil/intreadwrite.h\"\n#include \"libavutil/mathematics.h\"\n#include \"avformat.h\"\n#include \"internal.h\"\n\n#define EXTRADATA1_SIZE (6 + 256 * 3) ///< video base, clr, palette\n\n#define FORM_TAG MKBETAG('F', 'O', 'R', 'M')\n#define RLV2_TAG MKBETAG('R', 'L', 'V', '2')\n#define RLV3_TAG MKBETAG('R', 'L', 'V', '3')\n\ntypedef struct Rl2DemuxContext {\n    unsigned int index_pos[2];   ///< indexes in the sample tables\n} Rl2DemuxContext;\n\n\n/**\n * check if the file is in rl2 format\n * @param p probe buffer\n * @return 0 when the probe buffer does not contain rl2 data, > 0 otherwise\n */\nstatic int rl2_probe(AVProbeData *p)\n{\n\n    if(AV_RB32(&p->buf[0]) != FORM_TAG)\n        return 0;\n\n    if(AV_RB32(&p->buf[8]) != RLV2_TAG &&\n        AV_RB32(&p->buf[8]) != RLV3_TAG)\n        return 0;\n\n    return AVPROBE_SCORE_MAX;\n}\n\n/**\n * read rl2 header data and setup the avstreams\n * @param s demuxer context\n * @return 0 on success, AVERROR otherwise\n */\nstatic av_cold int rl2_read_header(AVFormatContext *s)\n{\n    AVIOContext *pb = s->pb;\n    AVStream *st;\n    unsigned int frame_count;\n    unsigned int audio_frame_counter = 0;\n    unsigned int video_frame_counter = 0;\n    unsigned int back_size;\n    unsigned short sound_rate;\n    unsigned short rate;\n    unsigned short channels;\n    unsigned short def_sound_size;\n    unsigned int signature;\n    unsigned int pts_den = 11025; /* video only case */\n    unsigned int pts_num = 1103;\n    unsigned int* chunk_offset = NULL;\n    int* chunk_size = NULL;\n    int* audio_size = NULL;\n    int i;\n    int ret = 0;\n\n    avio_skip(pb,4);          /* skip FORM tag */\n    back_size = avio_rl32(pb); /**< get size of the background frame */\n    signature = avio_rb32(pb);\n    avio_skip(pb, 4);         /* data size */\n    frame_count = avio_rl32(pb);\n\n    /* disallow back_sizes and frame_counts that may lead to overflows later */\n    if(back_size > INT_MAX/2  || frame_count > INT_MAX / sizeof(uint32_t))\n        return AVERROR_INVALIDDATA;\n\n    avio_skip(pb, 2);         /* encoding method */\n    sound_rate = avio_rl16(pb);\n    rate = avio_rl16(pb);\n    channels = avio_rl16(pb);\n    def_sound_size = avio_rl16(pb);\n\n    /** setup video stream */\n    st = avformat_new_stream(s, NULL);\n    if(!st)\n         return AVERROR(ENOMEM);\n\n    st->codecpar->codec_type = AVMEDIA_TYPE_VIDEO;\n    st->codecpar->codec_id = AV_CODEC_ID_RL2;\n    st->codecpar->codec_tag = 0;  /* no fourcc */\n    st->codecpar->width = 320;\n    st->codecpar->height = 200;\n\n    /** allocate and fill extradata */\n    st->codecpar->extradata_size = EXTRADATA1_SIZE;\n\n    if(signature == RLV3_TAG && back_size > 0)\n        st->codecpar->extradata_size += back_size;\n\n    if(ff_get_extradata(s, st->codecpar, pb, st->codecpar->extradata_size) < 0)\n        return AVERROR(ENOMEM);\n\n    /** setup audio stream if present */\n    if(sound_rate){\n        if (!channels || channels > 42) {\n            av_log(s, AV_LOG_ERROR, \"Invalid number of channels: %d\\n\", channels);\n            return AVERROR_INVALIDDATA;\n        }\n\n        pts_num = def_sound_size;\n        pts_den = rate;\n\n        st = avformat_new_stream(s, NULL);\n        if (!st)\n            return AVERROR(ENOMEM);\n        st->codecpar->codec_type = AVMEDIA_TYPE_AUDIO;\n        st->codecpar->codec_id = AV_CODEC_ID_PCM_U8;\n        st->codecpar->codec_tag = 1;\n        st->codecpar->channels = channels;\n        st->codecpar->bits_per_coded_sample = 8;\n        st->codecpar->sample_rate = rate;\n        st->codecpar->bit_rate = st->codecpar->channels * st->codecpar->sample_rate *\n            st->codecpar->bits_per_coded_sample;\n        st->codecpar->block_align = st->codecpar->channels *\n            st->codecpar->bits_per_coded_sample / 8;\n        avpriv_set_pts_info(st,32,1,rate);\n    }\n\n    avpriv_set_pts_info(s->streams[0], 32, pts_num, pts_den);\n\n    chunk_size =   av_malloc(frame_count * sizeof(uint32_t));\n    audio_size =   av_malloc(frame_count * sizeof(uint32_t));\n    chunk_offset = av_malloc(frame_count * sizeof(uint32_t));\n\n    if(!chunk_size || !audio_size || !chunk_offset){\n        av_free(chunk_size);\n        av_free(audio_size);\n        av_free(chunk_offset);\n        return AVERROR(ENOMEM);\n    }\n\n    /** read offset and size tables */\n    for(i=0; i < frame_count;i++) {\n        if (avio_feof(pb))\n            return AVERROR_INVALIDDATA;\n        chunk_size[i] = avio_rl32(pb);\n    }\n    for(i=0; i < frame_count;i++) {\n        if (avio_feof(pb))\n            return AVERROR_INVALIDDATA;\n        chunk_offset[i] = avio_rl32(pb);\n    }\n    for(i=0; i < frame_count;i++) {\n        if (avio_feof(pb))\n            return AVERROR_INVALIDDATA;\n        audio_size[i] = avio_rl32(pb) & 0xFFFF;\n    }\n\n    /** build the sample index */\n    for(i=0;i<frame_count;i++){\n        if(chunk_size[i] < 0 || audio_size[i] > chunk_size[i]){\n            ret = AVERROR_INVALIDDATA;\n            break;\n        }\n\n        if(sound_rate && audio_size[i]){\n            av_add_index_entry(s->streams[1], chunk_offset[i],\n                audio_frame_counter,audio_size[i], 0, AVINDEX_KEYFRAME);\n            audio_frame_counter += audio_size[i] / channels;\n        }\n        av_add_index_entry(s->streams[0], chunk_offset[i] + audio_size[i],\n            video_frame_counter,chunk_size[i]-audio_size[i],0,AVINDEX_KEYFRAME);\n        ++video_frame_counter;\n    }\n\n\n    av_free(chunk_size);\n    av_free(audio_size);\n    av_free(chunk_offset);\n\n    return ret;\n}\n\n/**\n * read a single audio or video packet\n * @param s demuxer context\n * @param pkt the packet to be filled\n * @return 0 on success, AVERROR otherwise\n */\nstatic int rl2_read_packet(AVFormatContext *s,\n                            AVPacket *pkt)\n{\n    Rl2DemuxContext *rl2 = s->priv_data;\n    AVIOContext *pb = s->pb;\n    AVIndexEntry *sample = NULL;\n    int i;\n    int ret = 0;\n    int stream_id = -1;\n    int64_t pos = INT64_MAX;\n\n    /** check if there is a valid video or audio entry that can be used */\n    for(i=0; i<s->nb_streams; i++){\n        if(rl2->index_pos[i] < s->streams[i]->nb_index_entries\n              && s->streams[i]->index_entries[ rl2->index_pos[i] ].pos < pos){\n            sample = &s->streams[i]->index_entries[ rl2->index_pos[i] ];\n            pos= sample->pos;\n            stream_id= i;\n        }\n    }\n\n    if(stream_id == -1)\n        return AVERROR_EOF;\n\n    ++rl2->index_pos[stream_id];\n\n    /** position the stream (will probably be there anyway) */\n    avio_seek(pb, sample->pos, SEEK_SET);\n\n    /** fill the packet */\n    ret = av_get_packet(pb, pkt, sample->size);\n    if(ret != sample->size){\n        av_packet_unref(pkt);\n        return AVERROR(EIO);\n    }\n\n    pkt->stream_index = stream_id;\n    pkt->pts = sample->timestamp;\n\n    return ret;\n}\n\n/**\n * seek to a new timestamp\n * @param s demuxer context\n * @param stream_index index of the stream that should be seeked\n * @param timestamp wanted timestamp\n * @param flags direction and seeking mode\n * @return 0 on success, -1 otherwise\n */\nstatic int rl2_read_seek(AVFormatContext *s, int stream_index, int64_t timestamp, int flags)\n{\n    AVStream *st = s->streams[stream_index];\n    Rl2DemuxContext *rl2 = s->priv_data;\n    int i;\n    int index = av_index_search_timestamp(st, timestamp, flags);\n    if(index < 0)\n        return -1;\n\n    rl2->index_pos[stream_index] = index;\n    timestamp = st->index_entries[index].timestamp;\n\n    for(i=0; i < s->nb_streams; i++){\n        AVStream *st2 = s->streams[i];\n        index = av_index_search_timestamp(st2,\n                    av_rescale_q(timestamp, st->time_base, st2->time_base),\n                    flags | AVSEEK_FLAG_BACKWARD);\n\n        if(index < 0)\n            index = 0;\n\n        rl2->index_pos[i] = index;\n    }\n\n    return 0;\n}\n\nAVInputFormat ff_rl2_demuxer = {\n    .name           = \"rl2\",\n    .long_name      = NULL_IF_CONFIG_SMALL(\"RL2\"),\n    .priv_data_size = sizeof(Rl2DemuxContext),\n    .read_probe     = rl2_probe,\n    .read_header    = rl2_read_header,\n    .read_packet    = rl2_read_packet,\n    .read_seek      = rl2_read_seek,\n};\n"], "filenames": ["libavformat/rl2.c"], "buggy_code_start_loc": [173], "buggy_code_end_loc": [178], "fixing_code_start_loc": [173], "fixing_code_end_loc": [188], "type": "CWE-834", "message": "In libavformat/rl2.c in FFmpeg 3.3.3, a DoS in rl2_read_header() due to lack of an EOF (End of File) check might cause huge CPU and memory consumption. When a crafted RL2 file, which claims a large \"frame_count\" field in the header but does not contain sufficient backing data, is provided, the loops (for offset and size tables) would consume huge CPU and memory resources, since there is no EOF check inside these loops.", "other": {"cve": {"id": "CVE-2017-14056", "sourceIdentifier": "cve@mitre.org", "published": "2017-08-31T15:29:00.373", "lastModified": "2019-10-03T00:03:26.223", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "In libavformat/rl2.c in FFmpeg 3.3.3, a DoS in rl2_read_header() due to lack of an EOF (End of File) check might cause huge CPU and memory consumption. When a crafted RL2 file, which claims a large \"frame_count\" field in the header but does not contain sufficient backing data, is provided, the loops (for offset and size tables) would consume huge CPU and memory resources, since there is no EOF check inside these loops."}, {"lang": "es", "value": "En libavformat/rl2.c in FFmpeg 3.3.3, se podr\u00eda realizar un ataque de denegaci\u00f3n de servicio en rl2_read_header() al no haber un chequeo EOF (End Of File) que podr\u00eda provocar acabar en un gran consumo de CPU y de memoria. Cuando se env\u00eda un archivo RL2 manipulado que reclama un campo \"frame_count\" grande en la cabecera pero que no contiene suficientes datos de respaldo, los bucles (para las tablas offset y size) consumir\u00edan una gran cantidad de recursos de CPU y de memoria, ya que no hay ning\u00fan chequeo EOF en los bucles."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:C", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 7.1}, "baseSeverity": "HIGH", "exploitabilityScore": 8.6, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-834"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:3.3.3:*:*:*:*:*:*:*", "matchCriteriaId": "A97A44A7-DFB8-4DA8-8A4A-DBC1FF255D9A"}]}]}], "references": [{"url": "http://www.debian.org/security/2017/dsa-3996", "source": "cve@mitre.org"}, {"url": "http://www.securityfocus.com/bid/100628", "source": "cve@mitre.org"}, {"url": "https://github.com/FFmpeg/FFmpeg/commit/96f24d1bee7fe7bac08e2b7c74db1a046c9dc0de", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2019/01/msg00006.html", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/FFmpeg/FFmpeg/commit/96f24d1bee7fe7bac08e2b7c74db1a046c9dc0de"}}