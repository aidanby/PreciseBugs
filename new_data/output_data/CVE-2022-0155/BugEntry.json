{"buggy_code": ["var url = require(\"url\");\nvar URL = url.URL;\nvar http = require(\"http\");\nvar https = require(\"https\");\nvar Writable = require(\"stream\").Writable;\nvar assert = require(\"assert\");\nvar debug = require(\"./debug\");\n\n// Create handlers that pass events from native requests\nvar events = [\"abort\", \"aborted\", \"connect\", \"error\", \"socket\", \"timeout\"];\nvar eventHandlers = Object.create(null);\nevents.forEach(function (event) {\n  eventHandlers[event] = function (arg1, arg2, arg3) {\n    this._redirectable.emit(event, arg1, arg2, arg3);\n  };\n});\n\n// Error types with codes\nvar RedirectionError = createErrorType(\n  \"ERR_FR_REDIRECTION_FAILURE\",\n  \"Redirected request failed\"\n);\nvar TooManyRedirectsError = createErrorType(\n  \"ERR_FR_TOO_MANY_REDIRECTS\",\n  \"Maximum number of redirects exceeded\"\n);\nvar MaxBodyLengthExceededError = createErrorType(\n  \"ERR_FR_MAX_BODY_LENGTH_EXCEEDED\",\n  \"Request body larger than maxBodyLength limit\"\n);\nvar WriteAfterEndError = createErrorType(\n  \"ERR_STREAM_WRITE_AFTER_END\",\n  \"write after end\"\n);\n\n// An HTTP(S) request that can be redirected\nfunction RedirectableRequest(options, responseCallback) {\n  // Initialize the request\n  Writable.call(this);\n  this._sanitizeOptions(options);\n  this._options = options;\n  this._ended = false;\n  this._ending = false;\n  this._redirectCount = 0;\n  this._redirects = [];\n  this._requestBodyLength = 0;\n  this._requestBodyBuffers = [];\n\n  // Attach a callback if passed\n  if (responseCallback) {\n    this.on(\"response\", responseCallback);\n  }\n\n  // React to responses of native requests\n  var self = this;\n  this._onNativeResponse = function (response) {\n    self._processResponse(response);\n  };\n\n  // Perform the first request\n  this._performRequest();\n}\nRedirectableRequest.prototype = Object.create(Writable.prototype);\n\nRedirectableRequest.prototype.abort = function () {\n  abortRequest(this._currentRequest);\n  this.emit(\"abort\");\n};\n\n// Writes buffered data to the current native request\nRedirectableRequest.prototype.write = function (data, encoding, callback) {\n  // Writing is not allowed if end has been called\n  if (this._ending) {\n    throw new WriteAfterEndError();\n  }\n\n  // Validate input and shift parameters if necessary\n  if (!(typeof data === \"string\" || typeof data === \"object\" && (\"length\" in data))) {\n    throw new TypeError(\"data should be a string, Buffer or Uint8Array\");\n  }\n  if (typeof encoding === \"function\") {\n    callback = encoding;\n    encoding = null;\n  }\n\n  // Ignore empty buffers, since writing them doesn't invoke the callback\n  // https://github.com/nodejs/node/issues/22066\n  if (data.length === 0) {\n    if (callback) {\n      callback();\n    }\n    return;\n  }\n  // Only write when we don't exceed the maximum body length\n  if (this._requestBodyLength + data.length <= this._options.maxBodyLength) {\n    this._requestBodyLength += data.length;\n    this._requestBodyBuffers.push({ data: data, encoding: encoding });\n    this._currentRequest.write(data, encoding, callback);\n  }\n  // Error when we exceed the maximum body length\n  else {\n    this.emit(\"error\", new MaxBodyLengthExceededError());\n    this.abort();\n  }\n};\n\n// Ends the current native request\nRedirectableRequest.prototype.end = function (data, encoding, callback) {\n  // Shift parameters if necessary\n  if (typeof data === \"function\") {\n    callback = data;\n    data = encoding = null;\n  }\n  else if (typeof encoding === \"function\") {\n    callback = encoding;\n    encoding = null;\n  }\n\n  // Write data if needed and end\n  if (!data) {\n    this._ended = this._ending = true;\n    this._currentRequest.end(null, null, callback);\n  }\n  else {\n    var self = this;\n    var currentRequest = this._currentRequest;\n    this.write(data, encoding, function () {\n      self._ended = true;\n      currentRequest.end(null, null, callback);\n    });\n    this._ending = true;\n  }\n};\n\n// Sets a header value on the current native request\nRedirectableRequest.prototype.setHeader = function (name, value) {\n  this._options.headers[name] = value;\n  this._currentRequest.setHeader(name, value);\n};\n\n// Clears a header value on the current native request\nRedirectableRequest.prototype.removeHeader = function (name) {\n  delete this._options.headers[name];\n  this._currentRequest.removeHeader(name);\n};\n\n// Global timeout for all underlying requests\nRedirectableRequest.prototype.setTimeout = function (msecs, callback) {\n  var self = this;\n\n  // Destroys the socket on timeout\n  function destroyOnTimeout(socket) {\n    socket.setTimeout(msecs);\n    socket.removeListener(\"timeout\", socket.destroy);\n    socket.addListener(\"timeout\", socket.destroy);\n  }\n\n  // Sets up a timer to trigger a timeout event\n  function startTimer(socket) {\n    if (self._timeout) {\n      clearTimeout(self._timeout);\n    }\n    self._timeout = setTimeout(function () {\n      self.emit(\"timeout\");\n      clearTimer();\n    }, msecs);\n    destroyOnTimeout(socket);\n  }\n\n  // Stops a timeout from triggering\n  function clearTimer() {\n    // Clear the timeout\n    if (self._timeout) {\n      clearTimeout(self._timeout);\n      self._timeout = null;\n    }\n\n    // Clean up all attached listeners\n    self.removeListener(\"abort\", clearTimer);\n    self.removeListener(\"error\", clearTimer);\n    self.removeListener(\"response\", clearTimer);\n    if (callback) {\n      self.removeListener(\"timeout\", callback);\n    }\n    if (!self.socket) {\n      self._currentRequest.removeListener(\"socket\", startTimer);\n    }\n  }\n\n  // Attach callback if passed\n  if (callback) {\n    this.on(\"timeout\", callback);\n  }\n\n  // Start the timer if or when the socket is opened\n  if (this.socket) {\n    startTimer(this.socket);\n  }\n  else {\n    this._currentRequest.once(\"socket\", startTimer);\n  }\n\n  // Clean up on events\n  this.on(\"socket\", destroyOnTimeout);\n  this.on(\"abort\", clearTimer);\n  this.on(\"error\", clearTimer);\n  this.on(\"response\", clearTimer);\n\n  return this;\n};\n\n// Proxy all other public ClientRequest methods\n[\n  \"flushHeaders\", \"getHeader\",\n  \"setNoDelay\", \"setSocketKeepAlive\",\n].forEach(function (method) {\n  RedirectableRequest.prototype[method] = function (a, b) {\n    return this._currentRequest[method](a, b);\n  };\n});\n\n// Proxy all public ClientRequest properties\n[\"aborted\", \"connection\", \"socket\"].forEach(function (property) {\n  Object.defineProperty(RedirectableRequest.prototype, property, {\n    get: function () { return this._currentRequest[property]; },\n  });\n});\n\nRedirectableRequest.prototype._sanitizeOptions = function (options) {\n  // Ensure headers are always present\n  if (!options.headers) {\n    options.headers = {};\n  }\n\n  // Since http.request treats host as an alias of hostname,\n  // but the url module interprets host as hostname plus port,\n  // eliminate the host property to avoid confusion.\n  if (options.host) {\n    // Use hostname if set, because it has precedence\n    if (!options.hostname) {\n      options.hostname = options.host;\n    }\n    delete options.host;\n  }\n\n  // Complete the URL object when necessary\n  if (!options.pathname && options.path) {\n    var searchPos = options.path.indexOf(\"?\");\n    if (searchPos < 0) {\n      options.pathname = options.path;\n    }\n    else {\n      options.pathname = options.path.substring(0, searchPos);\n      options.search = options.path.substring(searchPos);\n    }\n  }\n};\n\n\n// Executes the next native request (initial or redirect)\nRedirectableRequest.prototype._performRequest = function () {\n  // Load the native protocol\n  var protocol = this._options.protocol;\n  var nativeProtocol = this._options.nativeProtocols[protocol];\n  if (!nativeProtocol) {\n    this.emit(\"error\", new TypeError(\"Unsupported protocol \" + protocol));\n    return;\n  }\n\n  // If specified, use the agent corresponding to the protocol\n  // (HTTP and HTTPS use different types of agents)\n  if (this._options.agents) {\n    var scheme = protocol.substr(0, protocol.length - 1);\n    this._options.agent = this._options.agents[scheme];\n  }\n\n  // Create the native request\n  var request = this._currentRequest =\n        nativeProtocol.request(this._options, this._onNativeResponse);\n  this._currentUrl = url.format(this._options);\n\n  // Set up event handlers\n  request._redirectable = this;\n  for (var e = 0; e < events.length; e++) {\n    request.on(events[e], eventHandlers[events[e]]);\n  }\n\n  // End a redirected request\n  // (The first request must be ended explicitly with RedirectableRequest#end)\n  if (this._isRedirect) {\n    // Write the request entity and end.\n    var i = 0;\n    var self = this;\n    var buffers = this._requestBodyBuffers;\n    (function writeNext(error) {\n      // Only write if this request has not been redirected yet\n      /* istanbul ignore else */\n      if (request === self._currentRequest) {\n        // Report any write errors\n        /* istanbul ignore if */\n        if (error) {\n          self.emit(\"error\", error);\n        }\n        // Write the next buffer if there are still left\n        else if (i < buffers.length) {\n          var buffer = buffers[i++];\n          /* istanbul ignore else */\n          if (!request.finished) {\n            request.write(buffer.data, buffer.encoding, writeNext);\n          }\n        }\n        // End the request if `end` has been called on us\n        else if (self._ended) {\n          request.end();\n        }\n      }\n    }());\n  }\n};\n\n// Processes a response from the current native request\nRedirectableRequest.prototype._processResponse = function (response) {\n  // Store the redirected response\n  var statusCode = response.statusCode;\n  if (this._options.trackRedirects) {\n    this._redirects.push({\n      url: this._currentUrl,\n      headers: response.headers,\n      statusCode: statusCode,\n    });\n  }\n\n  // RFC7231\u00a76.4: The 3xx (Redirection) class of status code indicates\n  // that further action needs to be taken by the user agent in order to\n  // fulfill the request. If a Location header field is provided,\n  // the user agent MAY automatically redirect its request to the URI\n  // referenced by the Location field value,\n  // even if the specific status code is not understood.\n  var location = response.headers.location;\n  if (location && this._options.followRedirects !== false &&\n      statusCode >= 300 && statusCode < 400) {\n    // Abort the current request\n    abortRequest(this._currentRequest);\n    // Discard the remainder of the response to avoid waiting for data\n    response.destroy();\n\n    // RFC7231\u00a76.4: A client SHOULD detect and intervene\n    // in cyclical redirections (i.e., \"infinite\" redirection loops).\n    if (++this._redirectCount > this._options.maxRedirects) {\n      this.emit(\"error\", new TooManyRedirectsError());\n      return;\n    }\n\n    // RFC7231\u00a76.4: Automatic redirection needs to done with\n    // care for methods not known to be safe, [\u2026]\n    // RFC7231\u00a76.4.2\u20133: For historical reasons, a user agent MAY change\n    // the request method from POST to GET for the subsequent request.\n    if ((statusCode === 301 || statusCode === 302) && this._options.method === \"POST\" ||\n        // RFC7231\u00a76.4.4: The 303 (See Other) status code indicates that\n        // the server is redirecting the user agent to a different resource [\u2026]\n        // A user agent can perform a retrieval request targeting that URI\n        // (a GET or HEAD request if using HTTP) [\u2026]\n        (statusCode === 303) && !/^(?:GET|HEAD)$/.test(this._options.method)) {\n      this._options.method = \"GET\";\n      // Drop a possible entity and headers related to it\n      this._requestBodyBuffers = [];\n      removeMatchingHeaders(/^content-/i, this._options.headers);\n    }\n\n    // Drop the Host header, as the redirect might lead to a different host\n    var currentHostHeader = removeMatchingHeaders(/^host$/i, this._options.headers);\n\n    // If the redirect is relative, carry over the host of the last request\n    var currentUrlParts = url.parse(this._currentUrl);\n    var currentHost = currentHostHeader || currentUrlParts.host;\n    var currentUrl = /^\\w+:/.test(location) ? this._currentUrl :\n      url.format(Object.assign(currentUrlParts, { host: currentHost }));\n\n    // Determine the URL of the redirection\n    var redirectUrl;\n    try {\n      redirectUrl = url.resolve(currentUrl, location);\n    }\n    catch (cause) {\n      this.emit(\"error\", new RedirectionError(cause));\n      return;\n    }\n\n    // Create the redirected request\n    debug(\"redirecting to\", redirectUrl);\n    this._isRedirect = true;\n    var redirectUrlParts = url.parse(redirectUrl);\n    Object.assign(this._options, redirectUrlParts);\n\n    // Drop the Authorization header if redirecting to another domain\n    if (!(redirectUrlParts.host === currentHost || isSubdomainOf(redirectUrlParts.host, currentHost))) {\n      removeMatchingHeaders(/^authorization$/i, this._options.headers);\n    }\n\n    // Evaluate the beforeRedirect callback\n    if (typeof this._options.beforeRedirect === \"function\") {\n      var responseDetails = { headers: response.headers };\n      try {\n        this._options.beforeRedirect.call(null, this._options, responseDetails);\n      }\n      catch (err) {\n        this.emit(\"error\", err);\n        return;\n      }\n      this._sanitizeOptions(this._options);\n    }\n\n    // Perform the redirected request\n    try {\n      this._performRequest();\n    }\n    catch (cause) {\n      this.emit(\"error\", new RedirectionError(cause));\n    }\n  }\n  else {\n    // The response is not a redirect; return it as-is\n    response.responseUrl = this._currentUrl;\n    response.redirects = this._redirects;\n    this.emit(\"response\", response);\n\n    // Clean up\n    this._requestBodyBuffers = [];\n  }\n};\n\n// Wraps the key/value object of protocols with redirect functionality\nfunction wrap(protocols) {\n  // Default settings\n  var exports = {\n    maxRedirects: 21,\n    maxBodyLength: 10 * 1024 * 1024,\n  };\n\n  // Wrap each protocol\n  var nativeProtocols = {};\n  Object.keys(protocols).forEach(function (scheme) {\n    var protocol = scheme + \":\";\n    var nativeProtocol = nativeProtocols[protocol] = protocols[scheme];\n    var wrappedProtocol = exports[scheme] = Object.create(nativeProtocol);\n\n    // Executes a request, following redirects\n    function request(input, options, callback) {\n      // Parse parameters\n      if (typeof input === \"string\") {\n        var urlStr = input;\n        try {\n          input = urlToOptions(new URL(urlStr));\n        }\n        catch (err) {\n          /* istanbul ignore next */\n          input = url.parse(urlStr);\n        }\n      }\n      else if (URL && (input instanceof URL)) {\n        input = urlToOptions(input);\n      }\n      else {\n        callback = options;\n        options = input;\n        input = { protocol: protocol };\n      }\n      if (typeof options === \"function\") {\n        callback = options;\n        options = null;\n      }\n\n      // Set defaults\n      options = Object.assign({\n        maxRedirects: exports.maxRedirects,\n        maxBodyLength: exports.maxBodyLength,\n      }, input, options);\n      options.nativeProtocols = nativeProtocols;\n\n      assert.equal(options.protocol, protocol, \"protocol mismatch\");\n      debug(\"options\", options);\n      return new RedirectableRequest(options, callback);\n    }\n\n    // Executes a GET request, following redirects\n    function get(input, options, callback) {\n      var wrappedRequest = wrappedProtocol.request(input, options, callback);\n      wrappedRequest.end();\n      return wrappedRequest;\n    }\n\n    // Expose the properties on the wrapped protocol\n    Object.defineProperties(wrappedProtocol, {\n      request: { value: request, configurable: true, enumerable: true, writable: true },\n      get: { value: get, configurable: true, enumerable: true, writable: true },\n    });\n  });\n  return exports;\n}\n\n/* istanbul ignore next */\nfunction noop() { /* empty */ }\n\n// from https://github.com/nodejs/node/blob/master/lib/internal/url.js\nfunction urlToOptions(urlObject) {\n  var options = {\n    protocol: urlObject.protocol,\n    hostname: urlObject.hostname.startsWith(\"[\") ?\n      /* istanbul ignore next */\n      urlObject.hostname.slice(1, -1) :\n      urlObject.hostname,\n    hash: urlObject.hash,\n    search: urlObject.search,\n    pathname: urlObject.pathname,\n    path: urlObject.pathname + urlObject.search,\n    href: urlObject.href,\n  };\n  if (urlObject.port !== \"\") {\n    options.port = Number(urlObject.port);\n  }\n  return options;\n}\n\nfunction removeMatchingHeaders(regex, headers) {\n  var lastValue;\n  for (var header in headers) {\n    if (regex.test(header)) {\n      lastValue = headers[header];\n      delete headers[header];\n    }\n  }\n  return (lastValue === null || typeof lastValue === \"undefined\") ?\n    undefined : String(lastValue).trim();\n}\n\nfunction createErrorType(code, defaultMessage) {\n  function CustomError(cause) {\n    Error.captureStackTrace(this, this.constructor);\n    if (!cause) {\n      this.message = defaultMessage;\n    }\n    else {\n      this.message = defaultMessage + \": \" + cause.message;\n      this.cause = cause;\n    }\n  }\n  CustomError.prototype = new Error();\n  CustomError.prototype.constructor = CustomError;\n  CustomError.prototype.name = \"Error [\" + code + \"]\";\n  CustomError.prototype.code = code;\n  return CustomError;\n}\n\nfunction abortRequest(request) {\n  for (var e = 0; e < events.length; e++) {\n    request.removeListener(events[e], eventHandlers[events[e]]);\n  }\n  request.on(\"error\", noop);\n  request.abort();\n}\n\nfunction isSubdomainOf(subdomain, domain) {\n  const dot = subdomain.length - domain.length - 1;\n  return dot > 0 && subdomain[dot] === \".\" && subdomain.endsWith(domain);\n}\n\n// Exports\nmodule.exports = wrap({ http: http, https: https });\nmodule.exports.wrap = wrap;\n", "var express = require(\"express\");\nvar assert = require(\"assert\");\nvar net = require(\"net\");\nvar server = require(\"./server\")({ https: 3601, http: 3600 });\nvar url = require(\"url\");\nvar followRedirects = require(\"..\");\nvar http = followRedirects.http;\nvar https = followRedirects.https;\nvar fs = require(\"fs\");\nvar path = require(\"path\");\nvar lolex = require(\"lolex\");\n\nvar util = require(\"./util\");\nvar concat = require(\"concat-stream\");\nvar concatJson = util.concatJson;\nvar delay = util.delay;\nvar redirectsTo = util.redirectsTo;\nvar sendsJson = util.sendsJson;\nvar asPromise = util.asPromise;\n\nvar testFile = path.resolve(__dirname, \"assets/input.txt\");\nvar testFileBuffer = fs.readFileSync(testFile);\nvar testFileString = testFileBuffer.toString();\n\nvar nodeMajorVersion = Number.parseInt(process.version.match(/\\d+/)[0], 10);\n\ndescribe(\"follow-redirects\", function () {\n  function httpsOptions(app) {\n    return {\n      app: app,\n      protocol: \"https\",\n      cert: fs.readFileSync(path.resolve(__dirname, \"assets/localhost.crt\")),\n      key: fs.readFileSync(path.resolve(__dirname, \"assets/localhost.key\")),\n    };\n  }\n  var ca = fs.readFileSync(path.resolve(__dirname, \"assets/ca.crt\"));\n\n  var app;\n  var app2;\n  var originalMaxRedirects;\n  var originalMaxBodyLength;\n\n  beforeEach(function () {\n    originalMaxRedirects = followRedirects.maxRedirects;\n    originalMaxBodyLength = followRedirects.maxBodyLength;\n    app = express();\n    app2 = express();\n  });\n\n  afterEach(function () {\n    followRedirects.maxRedirects = originalMaxRedirects;\n    followRedirects.maxBodyLength = originalMaxBodyLength;\n    return server.stop();\n  });\n\n  it(\"http.get with string and callback - redirect\", function () {\n    app.get(\"/a\", redirectsTo(\"/b\"));\n    app.get(\"/b\", redirectsTo(\"/c\"));\n    app.get(\"/c\", redirectsTo(\"/d\"));\n    app.get(\"/d\", redirectsTo(\"/e\"));\n    app.get(\"/e\", redirectsTo(\"/f\"));\n    app.get(\"/f\", sendsJson({ a: \"b\" }));\n\n    return server.start(app)\n      .then(asPromise(function (resolve, reject) {\n        http.get(\"http://localhost:3600/a\", concatJson(resolve, reject)).on(\"error\", reject);\n      }))\n      .then(function (res) {\n        assert.deepEqual(res.parsedJson, { a: \"b\" });\n        assert.deepEqual(res.responseUrl, \"http://localhost:3600/f\");\n      });\n  });\n\n  it(\"http.get with URL object and callback - redirect\", function () {\n    if (nodeMajorVersion < 10) {\n      this.skip();\n    }\n\n    app.get(\"/a\", redirectsTo(\"/b\"));\n    app.get(\"/b\", redirectsTo(\"/c\"));\n    app.get(\"/c\", redirectsTo(\"/d\"));\n    app.get(\"/d\", redirectsTo(\"/e\"));\n    app.get(\"/e\", redirectsTo(\"/f\"));\n    app.get(\"/f\", sendsJson({ a: \"b\" }));\n\n    return server.start(app)\n      .then(asPromise(function (resolve, reject) {\n        http.get(\n          new URL(\"http://localhost:3600/a\"),\n          concatJson(resolve, reject)\n        ).on(\"error\", reject);\n      }))\n      .then(function (res) {\n        assert.deepEqual(res.parsedJson, { a: \"b\" });\n        assert.deepEqual(res.responseUrl, \"http://localhost:3600/f\");\n      });\n  });\n\n  it(\"http.get with options object and callback - redirect\", function () {\n    app.get(\"/a\", redirectsTo(\"/b\"));\n    app.get(\"/b\", redirectsTo(\"/c\"));\n    app.get(\"/c\", redirectsTo(\"/d\"));\n    app.get(\"/d\", redirectsTo(\"/e\"));\n    app.get(\"/e\", redirectsTo(\"/f\"));\n    app.get(\"/f\", sendsJson({ a: \"b\" }));\n\n    return server.start(app)\n      .then(asPromise(function (resolve, reject) {\n        var options = {\n          hostname: \"localhost\",\n          port: 3600,\n          path: \"/a\",\n          method: \"GET\",\n        };\n        http.get(options, concatJson(resolve, reject)).on(\"error\", reject);\n      }))\n      .then(function (res) {\n        assert.deepEqual(res.parsedJson, { a: \"b\" });\n        assert.deepEqual(res.responseUrl, \"http://localhost:3600/f\");\n      });\n  });\n\n  it(\"http.get with string and callback - no redirect\", function () {\n    app.get(\"/a\", sendsJson({ a: \"b\" }));\n\n    return server.start(app)\n      .then(asPromise(function (resolve, reject) {\n        http.get(\"http://localhost:3600/a\", concatJson(resolve, reject)).on(\"error\", reject);\n      }))\n      .then(function (res) {\n        assert.deepEqual(res.parsedJson, { a: \"b\" });\n        assert.deepEqual(res.responseUrl, \"http://localhost:3600/a\");\n      });\n  });\n\n  it(\"http.get with options object and callback - no redirect\", function () {\n    app.get(\"/a\", sendsJson({ a: \"b\" }));\n\n    return server.start(app)\n      .then(asPromise(function (resolve, reject) {\n        var options = {\n          hostname: \"localhost\",\n          port: 3600,\n          path: \"/a?xyz\",\n          method: \"GET\",\n        };\n        http.get(options, concatJson(resolve, reject)).on(\"error\", reject);\n      }))\n      .then(function (res) {\n        assert.deepEqual(res.parsedJson, { a: \"b\" });\n        assert.deepEqual(res.responseUrl, \"http://localhost:3600/a?xyz\");\n      });\n  });\n\n  it(\"http.get with host option and callback - redirect\", function () {\n    app.get(\"/a\", redirectsTo(\"/b\"));\n    app.get(\"/b\", redirectsTo(\"/c\"));\n    app.get(\"/c\", redirectsTo(\"/d\"));\n    app.get(\"/d\", redirectsTo(\"/e\"));\n    app.get(\"/e\", redirectsTo(\"/f\"));\n    app.get(\"/f\", sendsJson({ a: \"b\" }));\n\n    return server.start(app)\n      .then(asPromise(function (resolve, reject) {\n        var options = {\n          host: \"localhost\",\n          port: 3600,\n          path: \"/a\",\n          method: \"GET\",\n        };\n        http.get(options, concatJson(resolve, reject)).on(\"error\", reject);\n      }))\n      .then(function (res) {\n        assert.deepEqual(res.parsedJson, { a: \"b\" });\n        assert.deepEqual(res.responseUrl, \"http://localhost:3600/f\");\n      });\n  });\n\n  it(\"http.get with response event\", function () {\n    app.get(\"/a\", redirectsTo(\"/b\"));\n    app.get(\"/b\", redirectsTo(\"/c\"));\n    app.get(\"/c\", redirectsTo(\"/d\"));\n    app.get(\"/d\", redirectsTo(\"/e\"));\n    app.get(\"/e\", redirectsTo(\"/f\"));\n    app.get(\"/f\", sendsJson({ a: \"b\" }));\n\n    return server.start(app)\n      .then(asPromise(function (resolve, reject) {\n        http.get(\"http://localhost:3600/a\")\n          .on(\"response\", concatJson(resolve, reject))\n          .on(\"error\", reject);\n      }))\n      .then(function (res) {\n        assert.deepEqual(res.parsedJson, { a: \"b\" });\n        assert.deepEqual(res.responseUrl, \"http://localhost:3600/f\");\n      });\n  });\n\n  it(\"should return with the original status code if the response does not contain a location header\", function () {\n    app.get(\"/a\", function (req, res) {\n      res.status(307).end();\n    });\n\n    return server.start(app)\n      .then(asPromise(function (resolve, reject) {\n        http.get(\"http://localhost:3600/a\", resolve).on(\"error\", reject);\n      }))\n      .then(function (res) {\n        assert.equal(res.statusCode, 307);\n        assert.deepEqual(res.responseUrl, \"http://localhost:3600/a\");\n        res.on(\"data\", function () {\n          // noop to consume the stream (server won't shut down otherwise).\n        });\n      });\n  });\n\n  it(\"should emit connection errors on the returned stream\", function () {\n    app.get(\"/a\", redirectsTo(\"http://localhost:36002/b\"));\n\n    return server.start(app)\n      .then(asPromise(function (resolve, reject) {\n        http.get(\"http://localhost:3600/a\", reject).on(\"error\", resolve);\n      }))\n      .then(function (error) {\n        assert.equal(error.code, \"ECONNREFUSED\");\n      });\n  });\n\n  it(\"should emit socket events on the returned stream\", function () {\n    app.get(\"/a\", sendsJson({ a: \"b\" }));\n\n    return server.start(app)\n      .then(asPromise(function (resolve, reject) {\n        http.get(\"http://localhost:3600/a\")\n          .on(\"socket\", resolve)\n          .on(\"error\", reject);\n      }))\n      .then(function (socket) {\n        assert(socket instanceof net.Socket, \"socket event should emit with socket\");\n      });\n  });\n\n  it(\"should emit connect events on the returned stream\", function () {\n    app.get(\"/a\", sendsJson({ a: \"b\" }));\n\n    var req;\n    return server.start(app)\n      .then(asPromise(function (resolve, reject) {\n        req = http.get(\"http://localhost:3600/a\");\n        req.on(\"connect\", function (response, socket, head) {\n          resolve({ response: response, socket: socket, head: head });\n        });\n        req.on(\"error\", reject);\n        req._currentRequest.emit(\"connect\", \"r\", \"s\", \"h\");\n      }))\n      .then(function (args) {\n        req.abort();\n        assert.equal(args.response, \"r\");\n        assert.equal(args.socket, \"s\");\n        assert.equal(args.head, \"h\");\n      });\n  });\n\n  it(\"emits an error on redirects with an invalid location\", function () {\n    if (nodeMajorVersion < 10) {\n      this.skip();\n    }\n\n    app.get(\"/a\", function (req, res) {\n      // Explictly send response with invalid Location header\n      res.socket.write(\"HTTP/1.1 301 Moved Permanently\\n\");\n      res.socket.write(\"Location: http://\u0441\u043c\u043e\u043b\u044c\u043d\u044b\u0439-\u0438\u043d\u0441\u0442\u0438\u0442\u0443\u0442.\u0440\u0444\\n\");\n      res.socket.write(\"\\n\");\n      res.socket.end();\n    });\n\n    return server.start(app)\n      .then(asPromise(function (resolve) {\n        http.get(\"http://localhost:3600/a\").on(\"error\", resolve);\n      }))\n      .then(function (error) {\n        assert(error instanceof Error);\n        assert.equal(error.code, \"ERR_FR_REDIRECTION_FAILURE\");\n        assert(error.cause instanceof Error);\n        switch (error.cause.code) {\n        // Node 17+\n        case \"ERR_INVALID_URL\":\n          assert.equal(error.message, \"Redirected request failed: Invalid URL\");\n          break;\n        // Older Node versions\n        case \"ERR_UNESCAPED_CHARACTERS\":\n          assert.equal(error.message, \"Redirected request failed: Request path contains unescaped characters\");\n          break;\n        default:\n          throw new Error(\"Unexpected error code \" + error.code);\n        }\n      });\n  });\n\n  it(\"emits an error whem url.resolve fails\", function () {\n    app.get(\"/a\", redirectsTo(\"/b\"));\n    var urlResolve = url.resolve;\n    url.resolve = function () {\n      throw new Error();\n    };\n\n    return server.start(app)\n      .then(asPromise(function (resolve) {\n        http.get(\"http://localhost:3600/a\").on(\"error\", resolve);\n      }))\n      .then(function (error) {\n        url.resolve = urlResolve;\n        assert.equal(error.code, \"ERR_FR_REDIRECTION_FAILURE\");\n      });\n  });\n\n  it(\"emits an error when the request fails for another reason\", function () {\n    app.get(\"/a\", function (req, res) {\n      res.socket.write(\"HTTP/1.1 301 Moved Permanently\\n\");\n      res.socket.write(\"Location: other\\n\");\n      res.socket.write(\"\\n\");\n      res.socket.end();\n    });\n\n    return server.start(app)\n      .then(asPromise(function (resolve) {\n        var request = http.get(\"http://localhost:3600/a\");\n        request._performRequest = function () {\n          throw new Error(\"custom\");\n        };\n        request.on(\"error\", resolve);\n      }))\n      .then(function (error) {\n        assert(error instanceof Error);\n        assert.equal(error.message, \"Redirected request failed: custom\");\n      });\n  });\n\n  describe(\"setTimeout\", function () {\n    var clock;\n    beforeEach(function () {\n      clock = lolex.install();\n    });\n    afterEach(function () {\n      clock.uninstall();\n    });\n\n    it(\"clears timeouts after a successful response\", function () {\n      app.get(\"/redirect\", redirectsTo(\"/timeout\"));\n      app.get(\"/timeout\", delay(clock, 2000, sendsJson({ didnot: \"timeout\" })));\n\n      var req;\n      return server.start(app)\n        .then(asPromise(function (resolve, reject) {\n          req = http.get(\"http://localhost:3600/redirect\", concatJson(resolve, reject));\n          req.on(\"error\", reject);\n          req.setTimeout(3000, function () {\n            throw new Error(\"should not have timed out\");\n          });\n        }))\n        .then(function (res) {\n          assert.deepEqual(res.parsedJson, { didnot: \"timeout\" });\n          assert.deepEqual(res.responseUrl, \"http://localhost:3600/timeout\");\n          clock.tick(5000);\n        });\n    });\n\n    it(\"clears timeouts after an error response\", function () {\n      app.get(\"/redirect\", redirectsTo(\"http://localhost:3602/b\"));\n\n      var req;\n      return server.start(app)\n        .then(asPromise(function (resolve, reject) {\n          req = http.get(\"http://localhost:3600/redirect\", reject);\n          req.setTimeout(3000, function () {\n            throw new Error(\"should not have timed out\");\n          });\n          req.on(\"error\", resolve);\n        }))\n        .then(function (error) {\n          assert.equal(error.code, \"ECONNREFUSED\");\n          clock.tick(5000);\n        });\n    });\n\n    it(\"handles errors occuring before a socket is established\", function () {\n      app.get(\"/redirect\", redirectsTo(\"http://localhost:3602/b\"));\n\n      var req;\n      return server.start(app)\n        .then(asPromise(function (resolve, reject) {\n          req = http.get(\"http://localhost:3600/redirect\", reject);\n          req.setTimeout(3000, function () {\n            throw new Error(\"should not have timed out\");\n          });\n          req.emit(\"error\", new Error());\n          req.on(\"error\", resolve);\n        }))\n        .then(function (error) {\n          assert.equal(error.code, \"ECONNREFUSED\");\n          clock.tick(5000);\n        });\n    });\n\n    it(\"sets a timeout when the socket already exists\", function () {\n      app.get(\"/timeout\", delay(clock, 5000, sendsJson({ timed: \"out\" })));\n\n      return server.start(app)\n        .then(asPromise(function (resolve, reject) {\n          var req = http.get(\"http://localhost:3600/timeout\", function () {\n            throw new Error(\"should have timed out\");\n          });\n          req.on(\"error\", reject);\n          req.on(\"socket\", function () {\n            assert(req.socket instanceof net.Socket);\n            req.setTimeout(3000, function () {\n              req.abort();\n              resolve();\n            });\n          });\n        }));\n    });\n\n    it(\"destroys the socket after configured inactivity period\", function () {\n      app.get(\"/data\", delay(clock, 3000, sendsJson({ took: \"toolongtosenddata\" })));\n\n      return server.start(app)\n        .then(asPromise(function (resolve, reject) {\n          var req = http.get(\"http://localhost:3600/data\", concatJson(reject, reject));\n          req.on(\"error\", reject);\n          req.setTimeout(100, function () {\n            throw new Error(\"should not have timed out\");\n          });\n          req.on(\"socket\", function () {\n            req.socket.on(\"timeout\", function () {\n              resolve();\n            });\n          });\n        }));\n    });\n\n    it(\"should timeout on the final request\", function () {\n      app.get(\"/redirect1\", redirectsTo(\"/redirect2\"));\n      app.get(\"/redirect2\", redirectsTo(\"/timeout\"));\n      app.get(\"/timeout\", delay(clock, 5000, sendsJson({ timed: \"out\" })));\n\n      return server.start(app)\n        .then(asPromise(function (resolve, reject) {\n          var req = http.get(\"http://localhost:3600/redirect1\", function () {\n            throw new Error(\"should have timed out\");\n          });\n          req.on(\"error\", reject);\n          req.setTimeout(1000, function () {\n            req.abort();\n            resolve();\n          });\n        }));\n    });\n\n    it(\"should include redirect delays in the timeout\", function () {\n      app.get(\"/redirect1\", delay(clock, 1000, redirectsTo(\"/redirect2\")));\n      app.get(\"/redirect2\", delay(clock, 1000, redirectsTo(\"/redirect3\")));\n      app.get(\"/redirect3\", delay(clock, 1000, \"/timeout\"));\n      app.get(\"/timeout\", delay(clock, 1000, sendsJson({ timed: \"out\" })));\n\n      return server.start(app)\n        .then(asPromise(function (resolve, reject) {\n          var req = http.get(\"http://localhost:3600/redirect1\", function () {\n            throw new Error(\"should have timed out\");\n          });\n          req.on(\"error\", reject);\n          req.setTimeout(2000, function () {\n            req.abort();\n            resolve();\n          });\n        }));\n    });\n\n    it(\"overrides existing timeouts\", function () {\n      app.get(\"/redirect\", redirectsTo(\"/timeout\"));\n      app.get(\"/timeout\", delay(clock, 5000, sendsJson({ timed: \"out\" })));\n\n      return server.start(app)\n        .then(asPromise(function (resolve, reject) {\n          var req = http.get(\"http://localhost:3600/redirect\", function () {\n            throw new Error(\"should have timed out\");\n          });\n          req.on(\"error\", reject);\n\n          var callbacks = 0;\n          function timeoutCallback() {\n            if (++callbacks === 3) {\n              req.abort();\n              resolve(callbacks);\n            }\n          }\n          req.setTimeout(10000, timeoutCallback);\n          req.setTimeout(10000, timeoutCallback);\n          req.setTimeout(1000, timeoutCallback);\n        }));\n    });\n  });\n\n  it(\"should follow redirects over https\", function () {\n    app.get(\"/a\", redirectsTo(\"/b\"));\n    app.get(\"/b\", redirectsTo(\"/c\"));\n    app.get(\"/c\", sendsJson({ baz: \"quz\" }));\n\n    return server.start(httpsOptions(app))\n      .then(asPromise(function (resolve, reject) {\n        var opts = url.parse(\"https://localhost:3601/a\");\n        opts.ca = ca;\n        https.get(opts, concatJson(resolve, reject)).on(\"error\", reject);\n      }))\n      .then(function (res) {\n        assert.deepEqual(res.parsedJson, { baz: \"quz\" });\n        assert.deepEqual(res.responseUrl, \"https://localhost:3601/c\");\n      });\n  });\n\n  it(\"should destroy responses\", function () {\n    app.get(\"/a\", hangingRedirectTo(\"/b\"));\n    app.get(\"/b\", hangingRedirectTo(\"/c\"));\n    app.get(\"/c\", hangingRedirectTo(\"/d\"));\n    app.get(\"/d\", hangingRedirectTo(\"/e\"));\n    app.get(\"/e\", hangingRedirectTo(\"/f\"));\n    app.get(\"/f\", sendsJson({ a: \"b\" }));\n\n    function hangingRedirectTo(destination) {\n      return function (req, res) {\n        res.writeHead(301, { location: destination });\n        res.write(new Array(128).join(\" \"));\n      };\n    }\n\n    return server.start(app)\n      .then(asPromise(function (resolve, reject) {\n        http.get(\"http://localhost:3600/a\", concatJson(resolve, reject)).on(\"error\", reject);\n      }))\n      .then(function (res) {\n        assert.deepEqual(res.parsedJson, { a: \"b\" });\n        assert.deepEqual(res.responseUrl, \"http://localhost:3600/f\");\n      });\n  });\n\n  it(\"should honor query params in redirects\", function () {\n    app.get(\"/a\", redirectsTo(\"/b?greeting=hello\"));\n    app.get(\"/b\", function (req, res) {\n      res.json({ greeting: req.query.greeting });\n    });\n\n    return server.start(app)\n      .then(asPromise(function (resolve, reject) {\n        http.get(\"http://localhost:3600/a\", concatJson(resolve, reject)).on(\"error\", reject);\n      }))\n      .then(function (res) {\n        assert.deepEqual(res.parsedJson, { greeting: \"hello\" });\n        assert.deepEqual(res.responseUrl, \"http://localhost:3600/b?greeting=hello\");\n      });\n  });\n\n  it(\"should allow aborting\", function () {\n    var request;\n\n    app.get(\"/a\", redirectsTo(\"/b\"));\n    app.get(\"/b\", redirectsTo(\"/c\"));\n    app.get(\"/c\", function () {\n      request.abort();\n    });\n\n    return server.start(app)\n      .then(asPromise(function (resolve, reject) {\n        var currentTime = Date.now();\n        request = http.get(\"http://localhost:3600/a\", resolve);\n        assert(request.aborted === false || // Node >= v11.0.0\n               typeof request.aborted === \"undefined\"); // Node < v11.0.0\n        request.on(\"response\", reject);\n        request.on(\"error\", reject);\n        request.on(\"abort\", onAbort);\n        function onAbort() {\n          assert(request.aborted === true || // Node >= v11.0.0\n                 typeof request.aborted === \"number\" &&\n                   request.aborted > currentTime); // Node < v11.0.0\n          request.removeListener(\"error\", reject);\n          request.on(\"error\", noop);\n          resolve();\n        }\n      }));\n  });\n\n  it(\"should provide connection\", function () {\n    var request;\n\n    app.get(\"/a\", sendsJson({}));\n\n    return server.start(app)\n      .then(asPromise(function (resolve) {\n        request = http.get(\"http://localhost:3600/a\", resolve);\n      }))\n      .then(function () {\n        assert(request.connection instanceof net.Socket);\n      });\n  });\n\n  it(\"should provide flushHeaders\", function () {\n    app.get(\"/a\", redirectsTo(\"/b\"));\n    app.get(\"/b\", sendsJson({ foo: \"bar\" }));\n\n    return server.start(app)\n      .then(asPromise(function (resolve, reject) {\n        var request = http.get(\"http://localhost:3600/a\", resolve);\n        request.flushHeaders();\n        request.on(\"error\", reject);\n      }));\n  });\n\n  it(\"should provide getHeader\", function () {\n    var req = http.request(\"http://localhost:3600/a\");\n    req.setHeader(\"my-header\", \"my value\");\n    assert.equal(req.getHeader(\"my-header\"), \"my value\");\n    req.abort();\n  });\n\n  it(\"should provide removeHeader\", function () {\n    app.get(\"/a\", redirectsTo(\"/b\"));\n    app.get(\"/b\", function (req, res) {\n      res.end(JSON.stringify(req.headers));\n    });\n\n    return server.start(app)\n      .then(asPromise(function (resolve, reject) {\n        var req = http.request(\"http://localhost:3600/a\", concatJson(resolve, reject));\n        req.setHeader(\"my-header\", \"my value\");\n        assert.equal(req.getHeader(\"my-header\"), \"my value\");\n        req.removeHeader(\"my-header\");\n        assert.equal(req.getHeader(\"my-header\"), undefined);\n        req.end();\n      }))\n      .then(function (res) {\n        var headers = res.parsedJson;\n        assert.equal(headers[\"my-header\"], undefined);\n      });\n  });\n\n  it(\"should provide setHeader\", function () {\n    app.get(\"/a\", redirectsTo(\"/b\"));\n    app.get(\"/b\", function (req, res) {\n      res.end(JSON.stringify(req.headers));\n    });\n\n    return server.start(app)\n      .then(asPromise(function (resolve, reject) {\n        var req = http.request(\"http://localhost:3600/a\", concatJson(resolve, reject));\n        req.setHeader(\"my-header\", \"my value\");\n        assert.equal(req.getHeader(\"my-header\"), \"my value\");\n        req.end();\n      }))\n      .then(function (res) {\n        var headers = res.parsedJson;\n        assert.equal(headers[\"my-header\"], \"my value\");\n      });\n  });\n\n  it(\"should provide setNoDelay\", function () {\n    app.get(\"/a\", redirectsTo(\"/b\"));\n    app.get(\"/b\", sendsJson({ foo: \"bar\" }));\n\n    return server.start(app)\n      .then(asPromise(function (resolve, reject) {\n        var request = http.get(\"http://localhost:3600/a\", resolve);\n        request.setNoDelay(true);\n        request.on(\"error\", reject);\n      }));\n  });\n\n  it(\"should provide setSocketKeepAlive\", function () {\n    app.get(\"/a\", redirectsTo(\"/b\"));\n    app.get(\"/b\", sendsJson({ foo: \"bar\" }));\n\n    return server.start(app)\n      .then(asPromise(function (resolve) {\n        var request = http.get(\"http://localhost:3600/a\", resolve);\n        request.setSocketKeepAlive(true);\n      }));\n  });\n\n  it(\"should provide setTimeout\", function () {\n    app.get(\"/a\", redirectsTo(\"/b\"));\n    app.get(\"/b\", sendsJson({ foo: \"bar\" }));\n\n    return server.start(app)\n      .then(asPromise(function (resolve) {\n        var request = http.get(\"http://localhost:3600/a\", resolve);\n        request.setTimeout(1000);\n      }));\n  });\n\n  it(\"should provide socket\", function () {\n    var request;\n\n    app.get(\"/a\", sendsJson({}));\n\n    return server.start(app)\n      .then(asPromise(function (resolve) {\n        request = http.get(\"http://localhost:3600/a\", resolve);\n      }))\n      .then(function () {\n        assert(request.socket instanceof net.Socket);\n      });\n  });\n\n  describe(\"should obey a `maxRedirects` property\", function () {\n    beforeEach(function () {\n      var i = 22;\n      while (i > 0) {\n        app.get(\"/r\" + i, redirectsTo(\"/r\" + --i));\n      }\n      app.get(\"/r0\", sendsJson({ foo: \"bar\" }));\n    });\n\n    it(\"which defaults to 21\", function () {\n      return server.start(app)\n        // 21 redirects should work fine\n        .then(asPromise(function (resolve, reject) {\n          http.get(\"http://localhost:3600/r21\", concatJson(resolve, reject)).on(\"error\", reject);\n        }))\n        .then(function (res) {\n          assert.deepEqual(res.parsedJson, { foo: \"bar\" });\n          assert.deepEqual(res.responseUrl, \"http://localhost:3600/r0\");\n        })\n        // 22 redirects should fail\n        .then(asPromise(function (resolve, reject) {\n          http.get(\"http://localhost:3600/r22\", reject).on(\"error\", resolve);\n        }))\n        .then(function (error) {\n          assert(error instanceof Error);\n          assert.equal(error.code, \"ERR_FR_TOO_MANY_REDIRECTS\");\n          assert.equal(error.message, \"Maximum number of redirects exceeded\");\n        });\n    });\n\n    it(\"which can be set globally\", function () {\n      followRedirects.maxRedirects = 22;\n      return server.start(app)\n        .then(asPromise(function (resolve, reject) {\n          http.get(\"http://localhost:3600/r22\", concatJson(resolve, reject)).on(\"error\", reject);\n        }))\n        .then(function (res) {\n          assert.deepEqual(res.parsedJson, { foo: \"bar\" });\n          assert.deepEqual(res.responseUrl, \"http://localhost:3600/r0\");\n        });\n    });\n\n    it(\"set as an option on an individual request\", function () {\n      var u = url.parse(\"http://localhost:3600/r2\");\n      u.maxRedirects = 1;\n\n      return server.start(app)\n        .then(asPromise(function (resolve, reject) {\n          http.get(u, reject).on(\"error\", resolve);\n        }))\n        .then(function (error) {\n          assert(error instanceof Error);\n          assert.equal(error.code, \"ERR_FR_TOO_MANY_REDIRECTS\");\n          assert.equal(error.message, \"Maximum number of redirects exceeded\");\n        });\n    });\n  });\n\n  describe(\"the trackRedirects option\", function () {\n    beforeEach(function () {\n      app.get(\"/a\", redirectsTo(\"/b\"));\n      app.get(\"/b\", redirectsTo(\"/c\"));\n      app.get(\"/c\", sendsJson({}));\n    });\n\n    describe(\"when not set\", function () {\n      it(\"should not track redirects\", function () {\n        return server.start(app)\n          .then(asPromise(function (resolve, reject) {\n            var opts = url.parse(\"http://localhost:3600/a\");\n            http.get(opts, concatJson(resolve, reject)).on(\"error\", reject);\n          }))\n          .then(function (res) {\n            var redirects = res.redirects;\n            assert.equal(redirects.length, 0);\n          });\n      });\n    });\n\n    describe(\"when set to true\", function () {\n      it(\"should track redirects\", function () {\n        return server.start(app)\n          .then(asPromise(function (resolve, reject) {\n            var opts = url.parse(\"http://localhost:3600/a\");\n            opts.trackRedirects = true;\n            http.get(opts, concatJson(resolve, reject)).on(\"error\", reject);\n          }))\n          .then(function (res) {\n            var redirects = res.redirects;\n            assert.equal(redirects.length, 3);\n\n            assert.equal(redirects[0].url, \"http://localhost:3600/a\");\n            assert.equal(redirects[0].statusCode, 302);\n            assert.equal(redirects[0].headers[\"content-type\"], \"text/plain; charset=utf-8\");\n\n            assert.equal(redirects[1].url, \"http://localhost:3600/b\");\n            assert.equal(redirects[1].statusCode, 302);\n            assert.equal(redirects[1].headers[\"content-type\"], \"text/plain; charset=utf-8\");\n\n            assert.equal(redirects[2].url, \"http://localhost:3600/c\");\n            assert.equal(redirects[2].statusCode, 200);\n            assert.equal(redirects[2].headers[\"content-type\"], \"application/json; charset=utf-8\");\n          });\n      });\n    });\n  });\n\n  describe(\"should switch to safe methods when appropriate\", function () {\n    function itChangesMethod(statusCode, postToGet, changeAll) {\n      describe(\"when redirecting with status code \" + statusCode, function () {\n        itRedirectsWith(statusCode, \"GET\", \"GET\");\n        itRedirectsWith(statusCode, \"HEAD\", \"HEAD\");\n        itRedirectsWith(statusCode, \"POST\", postToGet ? \"GET\" : \"POST\");\n        itRedirectsWith(statusCode, \"PUT\", changeAll ? \"GET\" : \"PUT\");\n        itRedirectsWith(statusCode, \"DELETE\", changeAll ? \"GET\" : \"DELETE\");\n      });\n    }\n\n    function itRedirectsWith(statusCode, originalMethod, redirectedMethod) {\n      var description = \"should \" +\n          (originalMethod === redirectedMethod ? \"reuse \" + originalMethod :\n            \"switch from \" + originalMethod + \" to \" + redirectedMethod);\n      it(description, function () {\n        app[originalMethod.toLowerCase()](\"/a\", redirectsTo(statusCode, \"/b\"));\n        app[redirectedMethod.toLowerCase()](\"/b\", sendsJson({ a: \"b\" }));\n\n        return server.start(app)\n          .then(asPromise(function (resolve, reject) {\n            var opts = url.parse(\"http://localhost:3600/a\");\n            opts.method = originalMethod;\n            http.request(opts, resolve).on(\"error\", reject).end();\n          }))\n          .then(function (res) {\n            assert.deepEqual(res.responseUrl, \"http://localhost:3600/b\");\n            if (res.statusCode !== 200) {\n              throw new Error(\"Did not use \" + redirectedMethod);\n            }\n          });\n      });\n    }\n\n    itChangesMethod(300, false);\n    itChangesMethod(301, true);\n    itChangesMethod(302, true);\n    itChangesMethod(303, true, true);\n    itChangesMethod(307, false);\n  });\n\n  describe(\"should handle cross protocol redirects \", function () {\n    it(\"(https -> http -> https)\", function () {\n      app.get(\"/a\", redirectsTo(\"http://localhost:3600/b\"));\n      app2.get(\"/b\", redirectsTo(\"https://localhost:3601/c\"));\n      app.get(\"/c\", sendsJson({ yes: \"no\" }));\n\n      return Promise.all([server.start(httpsOptions(app)), server.start(app2)])\n        .then(asPromise(function (resolve, reject) {\n          var opts = url.parse(\"https://localhost:3601/a\");\n          opts.ca = ca;\n          https.get(opts, concatJson(resolve, reject)).on(\"error\", reject);\n        }))\n        .then(function (res) {\n          assert.deepEqual(res.parsedJson, { yes: \"no\" });\n          assert.deepEqual(res.responseUrl, \"https://localhost:3601/c\");\n        });\n    });\n\n    it(\"(http -> https -> http)\", function () {\n      app.get(\"/a\", redirectsTo(\"https://localhost:3601/b\"));\n      app2.get(\"/b\", redirectsTo(\"http://localhost:3600/c\"));\n      app.get(\"/c\", sendsJson({ hello: \"goodbye\" }));\n\n      return Promise.all([server.start(app), server.start(httpsOptions(app2))])\n        .then(asPromise(function (resolve, reject) {\n          var opts = url.parse(\"http://localhost:3600/a\");\n          opts.ca = ca;\n          http.get(opts, concatJson(resolve, reject)).on(\"error\", reject);\n        }))\n        .then(function (res) {\n          assert.deepEqual(res.parsedJson, { hello: \"goodbye\" });\n          assert.deepEqual(res.responseUrl, \"http://localhost:3600/c\");\n        });\n    });\n  });\n\n  describe(\"should error on an unsupported protocol redirect\", function () {\n    it(\"(http -> about)\", function () {\n      app.get(\"/a\", redirectsTo(\"about:blank\"));\n\n      return server.start(app)\n        .then(asPromise(function (resolve, reject) {\n          http.get(\"http://localhost:3600/a\")\n            .on(\"response\", function () { return reject(new Error(\"unexpected response\")); })\n            .on(\"error\", reject);\n        }))\n        .catch(function (error) {\n          assert(error instanceof Error);\n          assert(error instanceof TypeError);\n          assert.equal(error.message, \"Unsupported protocol about:\");\n        });\n    });\n  });\n\n  it(\"should wait for an explicit call to end\", function () {\n    var redirected = false;\n    app.post(\"/a\", redirectsTo(307, \"http://localhost:3600/b\"));\n    app.post(\"/b\", redirectsTo(307, \"http://localhost:3600/c\"));\n    app.post(\"/c\", redirectsTo(307, \"http://localhost:3600/d\"));\n    app.post(\"/d\", function (req, res) {\n      redirected = true;\n      req.pipe(res);\n    });\n\n    var req;\n\n    return server.start(app)\n      .then(asPromise(function (resolve, reject) {\n        req = http.request(\"http://localhost:3600/a\", { method: \"POST\" }, resolve);\n        req.write(testFileString);\n        req.on(\"error\", reject);\n      }))\n      .then(asPromise(function (resolve, reject, res) {\n        assert(redirected);\n        // If we can still write to the request, it wasn't closed yet\n        req.write(testFileString);\n        req.end();\n        res.pipe(concat({ encoding: \"string\" }, resolve)).on(\"error\", reject);\n      }))\n      .then(function (str) {\n        assert.equal(str, testFileString + testFileString);\n      });\n  });\n\n  it(\"errors on write after end\", function () {\n    app.post(\"/a\", function (req, res) {\n      req.pipe(res);\n    });\n\n    return server.start(app)\n      .then(function () {\n        var req = http.request(\"http://localhost:3600/a\", { method: \"POST\" });\n        req.write(testFileString);\n        req.end();\n        try {\n          req.write(testFileString);\n        }\n        catch (error) {\n          assert(error instanceof Error);\n          assert.equal(error.code, \"ERR_STREAM_WRITE_AFTER_END\");\n          assert.equal(error.message, \"write after end\");\n          return;\n        }\n        finally {\n          req.abort();\n        }\n        throw new Error(\"no error\");\n      });\n  });\n\n  it(\"should support writing into request stream without redirects\", function () {\n    app.post(\"/a\", function (req, res) {\n      req.pipe(res);\n    });\n\n    return server.start(app)\n      .then(asPromise(function (resolve, reject) {\n        var req = http.request(\"http://localhost:3600/a\", { method: \"POST\" }, resolve);\n        req.end(testFileBuffer, \"buffer\");\n        req.on(\"error\", reject);\n      }))\n      .then(asPromise(function (resolve, reject, res) {\n        assert.deepEqual(res.responseUrl, \"http://localhost:3600/a\");\n        res.pipe(concat({ encoding: \"string\" }, resolve)).on(\"error\", reject);\n      }))\n      .then(function (str) {\n        assert.equal(str, testFileString);\n      });\n  });\n\n  it(\"should support writing into request stream with redirects\", function () {\n    app.post(\"/a\", redirectsTo(307, \"http://localhost:3600/b\"));\n    app.post(\"/b\", redirectsTo(307, \"http://localhost:3600/c\"));\n    app.post(\"/c\", redirectsTo(307, \"http://localhost:3600/d\"));\n    app.post(\"/d\", function (req, res) {\n      req.pipe(res);\n    });\n\n    return server.start(app)\n      .then(asPromise(function (resolve, reject) {\n        var req = http.request(\"http://localhost:3600/a\", { method: \"POST\" }, resolve);\n        req.end(testFileBuffer, \"buffer\");\n        req.on(\"error\", reject);\n      }))\n      .then(asPromise(function (resolve, reject, res) {\n        res.pipe(concat({ encoding: \"string\" }, resolve)).on(\"error\", reject);\n      }))\n      .then(function (str) {\n        assert.equal(str, testFileString);\n      });\n  });\n\n  it(\"should support piping into request stream without redirects\", function () {\n    app.post(\"/a\", function (req, res) {\n      req.pipe(res);\n    });\n\n    return server.start(app)\n      .then(asPromise(function (resolve, reject) {\n        var req = http.request(\"http://localhost:3600/a\", { method: \"POST\" }, resolve);\n        fs.createReadStream(testFile).pipe(req);\n        req.on(\"error\", reject);\n      }))\n      .then(asPromise(function (resolve, reject, res) {\n        assert.deepEqual(res.responseUrl, \"http://localhost:3600/a\");\n        res.pipe(concat({ encoding: \"string\" }, resolve)).on(\"error\", reject);\n      }))\n      .then(function (str) {\n        assert.equal(str, testFileString);\n      });\n  });\n\n  it(\"should support piping into request stream with redirects\", function () {\n    app.post(\"/a\", redirectsTo(307, \"http://localhost:3600/b\"));\n    app.post(\"/b\", redirectsTo(307, \"http://localhost:3600/c\"));\n    app.post(\"/c\", redirectsTo(307, \"http://localhost:3600/d\"));\n    app.post(\"/d\", function (req, res) {\n      req.pipe(res);\n    });\n\n    return server.start(app)\n      .then(asPromise(function (resolve, reject) {\n        var req = http.request(\"http://localhost:3600/a\", { method: \"POST\" }, resolve);\n        fs.createReadStream(testFile).pipe(req);\n        req.on(\"error\", reject);\n      }))\n      .then(asPromise(function (resolve, reject, res) {\n        res.pipe(concat({ encoding: \"string\" }, resolve)).on(\"error\", reject);\n      }))\n      .then(function (str) {\n        assert.equal(str, testFileString);\n      });\n  });\n\n  it(\"should support piping into request stream with explicit Content-Length without redirects\", function () {\n    app.post(\"/a\", function (req, res) {\n      req.pipe(res);\n    });\n\n    var opts = url.parse(\"http://localhost:3600/a\");\n    opts.method = \"POST\";\n    opts.headers = {\n      \"Content-Length\": testFileBuffer.byteLength,\n    };\n\n    return server.start(app)\n      .then(asPromise(function (resolve, reject) {\n        var req = http.request(opts, resolve);\n        fs.createReadStream(testFile).pipe(req);\n        req.on(\"error\", reject);\n      }))\n      .then(asPromise(function (resolve, reject, res) {\n        assert.deepEqual(res.responseUrl, \"http://localhost:3600/a\");\n        res.pipe(concat({ encoding: \"string\" }, resolve)).on(\"error\", reject);\n      }))\n      .then(function (str) {\n        assert.equal(str, testFileString);\n      });\n  });\n\n  it(\"should support piping into request stream with explicit Content-Length with redirects\", function () {\n    app.post(\"/a\", redirectsTo(307, \"http://localhost:3600/b\"));\n    app.post(\"/b\", redirectsTo(307, \"http://localhost:3600/c\"));\n    app.post(\"/c\", redirectsTo(307, \"http://localhost:3600/d\"));\n    app.post(\"/d\", function (req, res) {\n      req.pipe(res);\n    });\n\n    var opts = url.parse(\"http://localhost:3600/a\");\n    opts.method = \"POST\";\n    opts.headers = {\n      \"Content-Length\": testFileBuffer.byteLength,\n    };\n\n    return server.start(app)\n      .then(asPromise(function (resolve, reject) {\n        var req = http.request(opts, resolve);\n        fs.createReadStream(testFile).pipe(req);\n        req.on(\"error\", reject);\n      }))\n      .then(asPromise(function (resolve, reject, res) {\n        res.pipe(concat({ encoding: \"string\" }, resolve)).on(\"error\", reject);\n      }))\n      .then(function (str) {\n        assert.equal(str, testFileString);\n      });\n  });\n\n  describe(\"should obey a `maxBodyLength` property\", function () {\n    it(\"which defaults to 10MB\", function () {\n      assert.equal(followRedirects.maxBodyLength, 10 * 1024 * 1024);\n    });\n\n    it(\"set globally, on write\", function () {\n      app.post(\"/a\", function (req, res) {\n        req.pipe(res);\n      });\n\n      followRedirects.maxBodyLength = 8;\n      return server.start(app)\n        .then(asPromise(function (resolve, reject) {\n          var req = http.request(\"http://localhost:3600/a\", { method: \"POST\" }, reject);\n          req.write(\"12345678\");\n          req.on(\"error\", resolve);\n          req.write(\"9\");\n        }))\n        .then(function (error) {\n          assert.equal(error.message, \"Request body larger than maxBodyLength limit\");\n        });\n    });\n\n    it(\"set per request, on write\", function () {\n      app.post(\"/a\", function (req, res) {\n        req.pipe(res);\n      });\n      var opts = url.parse(\"http://localhost:3600/a\");\n      opts.method = \"POST\";\n      opts.maxBodyLength = 8;\n\n      return server.start(app)\n        .then(asPromise(function (resolve, reject) {\n          var req = http.request(opts, reject);\n          req.write(\"12345678\");\n          req.on(\"error\", resolve);\n          req.write(\"9\");\n        }))\n        .then(function (error) {\n          assert(error instanceof Error);\n          assert.equal(error.code, \"ERR_FR_MAX_BODY_LENGTH_EXCEEDED\");\n          assert.equal(error.message, \"Request body larger than maxBodyLength limit\");\n        });\n    });\n\n    it(\"set globally, on end\", function () {\n      app.post(\"/a\", function (req, res) {\n        req.pipe(res);\n      });\n\n      followRedirects.maxBodyLength = 8;\n      return server.start(app)\n        .then(asPromise(function (resolve, reject) {\n          var req = http.request(\"http://localhost:3600/a\", { method: \"POST\" }, reject);\n          req.write(\"12345678\");\n          req.on(\"error\", resolve);\n          req.end(\"9\");\n        }))\n        .then(function (error) {\n          assert(error instanceof Error);\n          assert.equal(error.code, \"ERR_FR_MAX_BODY_LENGTH_EXCEEDED\");\n          assert.equal(error.message, \"Request body larger than maxBodyLength limit\");\n        });\n    });\n\n    it(\"set per request, on end\", function () {\n      app.post(\"/a\", function (req, res) {\n        req.pipe(res);\n      });\n      var opts = url.parse(\"http://localhost:3600/a\");\n      opts.method = \"POST\";\n      opts.maxBodyLength = 8;\n\n      return server.start(app)\n        .then(asPromise(function (resolve, reject) {\n          var req = http.request(opts, reject);\n          req.write(\"12345678\");\n          req.on(\"error\", resolve);\n          req.end(\"9\");\n        }))\n        .then(function (error) {\n          assert(error instanceof Error);\n          assert.equal(error.code, \"ERR_FR_MAX_BODY_LENGTH_EXCEEDED\");\n          assert.equal(error.message, \"Request body larger than maxBodyLength limit\");\n        });\n    });\n  });\n\n  describe(\"writing invalid data\", function () {\n    it(\"throws an error\", function () {\n      var req = http.request(\"http://example.org/\");\n      var error = null;\n      try {\n        req.write(12345678);\n      }\n      catch (e) {\n        error = e;\n      }\n      req.abort();\n      assert(error instanceof Error);\n      assert(error instanceof TypeError);\n      assert.equal(error.message, \"data should be a string, Buffer or Uint8Array\");\n    });\n  });\n\n  describe(\"when switching from POST to GET\", function () {\n    it(\"should drop the entity and associated headers\", function () {\n      app.post(\"/a\", redirectsTo(302, \"http://localhost:3600/b\"));\n      app.get(\"/b\", function (req, res) {\n        res.write(JSON.stringify(req.headers));\n        req.pipe(res); // will invalidate JSON if non-empty\n      });\n\n      var opts = url.parse(\"http://localhost:3600/a\");\n      opts.method = \"POST\";\n      opts.headers = {\n        \"other\": \"value\",\n        \"content-type\": \"application/javascript\",\n        \"Content-Length\": testFileBuffer.byteLength,\n      };\n\n      return server.start(app)\n        .then(asPromise(function (resolve, reject) {\n          var req = http.request(opts, resolve);\n          fs.createReadStream(testFile).pipe(req);\n          req.on(\"error\", reject);\n        }))\n        .then(asPromise(function (resolve, reject, res) {\n          res.pipe(concat({ encoding: \"string\" }, resolve)).on(\"error\", reject);\n        }))\n        .then(function (str) {\n          var body = JSON.parse(str);\n          assert.equal(body.host, \"localhost:3600\");\n          assert.equal(body.other, \"value\");\n          assert.equal(body[\"content-type\"], undefined);\n          assert.equal(body[\"content-length\"], undefined);\n        });\n    });\n  });\n\n  describe(\"when redirecting to a different host while the host header is set\", function () {\n    it(\"uses the new host header if redirect host is different\", function () {\n      app.get(\"/a\", redirectsTo(302, \"http://localhost:3600/b\"));\n      app.get(\"/b\", function (req, res) {\n        res.write(JSON.stringify(req.headers));\n        req.pipe(res); // will invalidate JSON if non-empty\n      });\n\n      return server.start(app)\n        .then(asPromise(function (resolve, reject) {\n          var opts = url.parse(\"http://localhost:3600/a\");\n          opts.headers = { hOsT: \"otherhost.com\" };\n          http.get(opts, resolve).on(\"error\", reject);\n        }))\n        .then(asPromise(function (resolve, reject, res) {\n          assert.deepEqual(res.statusCode, 200);\n          assert.deepEqual(res.responseUrl, \"http://localhost:3600/b\");\n          res.pipe(concat({ encoding: \"string\" }, resolve)).on(\"error\", reject);\n        }))\n        .then(function (str) {\n          var body = JSON.parse(str);\n          assert.equal(body.host, \"localhost:3600\");\n        });\n    });\n\n    it(\"uses the location host if redirect host is the same\", function () {\n      app.get(\"/a\", redirectsTo(302, \"http://localhost:3600/b\"));\n      app.get(\"/b\", function (req, res) {\n        res.write(JSON.stringify(req.headers));\n        req.pipe(res); // will invalidate JSON if non-empty\n      });\n\n      return server.start(app)\n        .then(asPromise(function (resolve, reject) {\n          var opts = url.parse(\"http://127.0.0.1:3600/a\");\n          opts.headers = { hOsT: \"localhost:3600\" };\n          http.get(opts, resolve).on(\"error\", reject);\n        }))\n        .then(asPromise(function (resolve, reject, res) {\n          assert.deepEqual(res.statusCode, 200);\n          assert.deepEqual(res.responseUrl, \"http://localhost:3600/b\");\n          res.pipe(concat({ encoding: \"string\" }, resolve)).on(\"error\", reject);\n        }))\n        .then(function (str) {\n          var body = JSON.parse(str);\n          assert.equal(body.host, \"localhost:3600\");\n        });\n    });\n\n    it(\"uses the existing host header if redirect host is relative\", function () {\n      app.get(\"/a\", redirectsTo(302, \"/b\"));\n      app.get(\"/b\", function (req, res) {\n        res.write(JSON.stringify(req.headers));\n        req.pipe(res); // will invalidate JSON if non-empty\n      });\n\n      return server.start(app)\n        .then(asPromise(function (resolve, reject) {\n          var opts = url.parse(\"http://127.0.0.1:3600/a\");\n          opts.headers = { hOsT: \"localhost:3600\" };\n          http.get(opts, resolve).on(\"error\", reject);\n        }))\n        .then(asPromise(function (resolve, reject, res) {\n          assert.deepEqual(res.statusCode, 200);\n          assert.deepEqual(res.responseUrl, \"http://localhost:3600/b\");\n          res.pipe(concat({ encoding: \"string\" }, resolve)).on(\"error\", reject);\n        }))\n        .then(function (str) {\n          var body = JSON.parse(str);\n          assert.equal(body.host, \"localhost:3600\");\n        });\n    });\n  });\n\n  describe(\"when the client passes an Authorization header\", function () {\n    it(\"ignores it when null\", function () {\n      app.get(\"/a\", redirectsTo(302, \"http://localhost:3600/b\"));\n      app.get(\"/b\", function (req, res) {\n        res.end(JSON.stringify(req.headers));\n      });\n\n      var opts = url.parse(\"http://127.0.0.1:3600/a\");\n      opts.headers = {\n        host: \"localhost\",\n        authorization: null,\n      };\n\n      return server.start(app)\n        .then(asPromise(function (resolve, reject) {\n          http.get(opts, resolve).on(\"error\", reject);\n        }))\n        .then(asPromise(function (resolve, reject, res) {\n          res.pipe(concat({ encoding: \"string\" }, resolve)).on(\"error\", reject);\n        }))\n        .then(function (str) {\n          var body = JSON.parse(str);\n          assert.equal(body.host, \"localhost:3600\");\n          assert.equal(body.authorization, undefined);\n        });\n    });\n\n    it(\"keeps the header when redirected to the same host\", function () {\n      app.get(\"/a\", redirectsTo(302, \"/b\"));\n      app.get(\"/b\", function (req, res) {\n        res.end(JSON.stringify(req.headers));\n      });\n\n      var opts = url.parse(\"http://localhost:3600/a\");\n      opts.headers = {\n        authorization: \"bearer my-token-1234\",\n      };\n\n      return server.start(app)\n        .then(asPromise(function (resolve, reject) {\n          http.get(opts, resolve).on(\"error\", reject);\n        }))\n        .then(asPromise(function (resolve, reject, res) {\n          res.pipe(concat({ encoding: \"string\" }, resolve)).on(\"error\", reject);\n        }))\n        .then(function (str) {\n          var body = JSON.parse(str);\n          assert.equal(body.host, \"localhost:3600\");\n          assert.equal(body.authorization, \"bearer my-token-1234\");\n        });\n    });\n\n    it(\"keeps the header when redirected to the same host via header\", function () {\n      app.get(\"/a\", redirectsTo(302, \"http://localhost:3600/b\"));\n      app.get(\"/b\", function (req, res) {\n        res.end(JSON.stringify(req.headers));\n      });\n\n      var opts = url.parse(\"http://127.0.0.1:3600/a\");\n      opts.headers = {\n        host: \"localhost:3600\",\n        authorization: \"bearer my-token-1234\",\n      };\n\n      return server.start(app)\n        .then(asPromise(function (resolve, reject) {\n          http.get(opts, resolve).on(\"error\", reject);\n        }))\n        .then(asPromise(function (resolve, reject, res) {\n          res.pipe(concat({ encoding: \"string\" }, resolve)).on(\"error\", reject);\n        }))\n        .then(function (str) {\n          var body = JSON.parse(str);\n          assert.equal(body.host, \"localhost:3600\");\n          assert.equal(body.authorization, \"bearer my-token-1234\");\n        });\n    });\n\n    it(\"keeps the header when redirected to the same host via header\", function () {\n      app.get(\"/a\", redirectsTo(302, \"http://localhost:3600/b\"));\n      app.get(\"/b\", function (req, res) {\n        res.end(JSON.stringify(req.headers));\n      });\n\n      var opts = url.parse(\"http://127.0.0.1:3600/a\");\n      opts.headers = {\n        host: \"localhost:3600\",\n        authorization: \"bearer my-token-1234\",\n      };\n\n      return server.start(app)\n        .then(asPromise(function (resolve, reject) {\n          http.get(opts, resolve).on(\"error\", reject);\n        }))\n        .then(asPromise(function (resolve, reject, res) {\n          res.pipe(concat({ encoding: \"string\" }, resolve)).on(\"error\", reject);\n        }))\n        .then(function (str) {\n          var body = JSON.parse(str);\n          assert.equal(body.host, \"localhost:3600\");\n          assert.equal(body.authorization, \"bearer my-token-1234\");\n        });\n    });\n\n    it(\"keeps the header when redirected to a subdomain\", function () {\n      app.get(\"/a\", redirectsTo(302, \"http://sub.localhost:3600/b\"));\n      app.get(\"/b\", function (req, res) {\n        res.end(JSON.stringify(req.headers));\n      });\n\n      var opts = url.parse(\"http://localhost:3600/a\");\n      opts.headers = {\n        authorization: \"bearer my-token-1234\",\n      };\n      // Intercept the hostname, as no DNS entry is defined for it\n      opts.beforeRedirect = function (options) {\n        assert.equal(options.hostname, \"sub.localhost\");\n        options.hostname = \"localhost\";\n      };\n\n      return server.start(app)\n        .then(asPromise(function (resolve, reject) {\n          http.get(opts, resolve).on(\"error\", reject);\n        }))\n        .then(asPromise(function (resolve, reject, res) {\n          res.pipe(concat({ encoding: \"string\" }, resolve)).on(\"error\", reject);\n        }))\n        .then(function (str) {\n          var body = JSON.parse(str);\n          assert.equal(body.host, \"localhost:3600\");\n          assert.equal(body.authorization, \"bearer my-token-1234\");\n        });\n    });\n\n    it(\"drops the header when redirected to a different host (same hostname and different port)\", function () {\n      app.get(\"/a\", redirectsTo(302, \"http://localhost:3600/b\"));\n      app.get(\"/b\", function (req, res) {\n        res.end(JSON.stringify(req.headers));\n      });\n\n      var opts = url.parse(\"http://127.0.0.1:3600/a\");\n      opts.headers = {\n        host: \"localhost\",\n        authorization: \"bearer my-token-1234\",\n      };\n\n      return server.start(app)\n        .then(asPromise(function (resolve, reject) {\n          http.get(opts, resolve).on(\"error\", reject);\n        }))\n        .then(asPromise(function (resolve, reject, res) {\n          res.pipe(concat({ encoding: \"string\" }, resolve)).on(\"error\", reject);\n        }))\n        .then(function (str) {\n          var body = JSON.parse(str);\n          assert.equal(body.host, \"localhost:3600\");\n          assert.equal(body.authorization, undefined);\n        });\n    });\n\n    it(\"drops the header when redirected to a different host\", function () {\n      app.get(\"/a\", redirectsTo(302, \"http://127.0.0.1:3600/b\"));\n      app.get(\"/b\", function (req, res) {\n        res.end(JSON.stringify(req.headers));\n      });\n\n      var opts = url.parse(\"http://localhost:3600/a\");\n      opts.headers = {\n        authorization: \"bearer my-token-1234\",\n      };\n\n      return server.start(app)\n        .then(asPromise(function (resolve, reject) {\n          http.get(opts, resolve).on(\"error\", reject);\n        }))\n        .then(asPromise(function (resolve, reject, res) {\n          res.pipe(concat({ encoding: \"string\" }, resolve)).on(\"error\", reject);\n        }))\n        .then(function (str) {\n          var body = JSON.parse(str);\n          assert.equal(body.host, \"127.0.0.1:3600\");\n          assert.equal(body.authorization, undefined);\n        });\n    });\n\n    it(\"drops the header when redirected from a different host via header\", function () {\n      app.get(\"/a\", redirectsTo(302, \"http://127.0.0.1:3600/b\"));\n      app.get(\"/b\", function (req, res) {\n        res.end(JSON.stringify(req.headers));\n      });\n\n      var opts = url.parse(\"http://127.0.0.1:3600/a\");\n      opts.headers = {\n        host: \"localhost\",\n        authorization: \"bearer my-token-1234\",\n      };\n\n      return server.start(app)\n        .then(asPromise(function (resolve, reject) {\n          http.get(opts, resolve).on(\"error\", reject);\n        }))\n        .then(asPromise(function (resolve, reject, res) {\n          res.pipe(concat({ encoding: \"string\" }, resolve)).on(\"error\", reject);\n        }))\n        .then(function (str) {\n          var body = JSON.parse(str);\n          assert.equal(body.host, \"127.0.0.1:3600\");\n          assert.equal(body.authorization, undefined);\n        });\n    });\n  });\n\n  describe(\"when the followRedirects option is set to false\", function () {\n    it(\"does not redirect\", function () {\n      app.get(\"/a\", redirectsTo(302, \"/b\"));\n      app.get(\"/b\", sendsJson({ a: \"b\" }));\n\n      return server.start(app)\n        .then(asPromise(function (resolve, reject) {\n          var opts = url.parse(\"http://localhost:3600/a\");\n          opts.followRedirects = false;\n          http.get(opts, resolve).on(\"error\", reject);\n        }))\n        .then(function (res) {\n          assert.deepEqual(res.statusCode, 302);\n          assert.deepEqual(res.responseUrl, \"http://localhost:3600/a\");\n        });\n    });\n  });\n\n  describe(\"should choose the right agent per protocol\", function () {\n    it(\"(https -> http -> https)\", function () {\n      app.get(\"/a\", redirectsTo(\"http://localhost:3600/b\"));\n      app2.get(\"/b\", redirectsTo(\"https://localhost:3601/c\"));\n      app.get(\"/c\", sendsJson({ yes: \"no\" }));\n\n      var httpAgent = addRequestLogging(new http.Agent());\n      var httpsAgent = addRequestLogging(new https.Agent());\n      function addRequestLogging(agent) {\n        agent._requests = [];\n        agent._addRequest = agent.addRequest;\n        agent.addRequest = function (request, options) {\n          this._requests.push(options.path);\n          this._addRequest(request, options);\n        };\n        return agent;\n      }\n\n      return Promise.all([server.start(httpsOptions(app)), server.start(app2)])\n        .then(asPromise(function (resolve, reject) {\n          var opts = url.parse(\"https://localhost:3601/a\");\n          opts.ca = ca;\n          opts.agents = { http: httpAgent, https: httpsAgent };\n          https.get(opts, concatJson(resolve, reject)).on(\"error\", reject);\n        }))\n        .then(function (res) {\n          assert.deepEqual(httpAgent._requests, [\"/b\"]);\n          assert.deepEqual(httpsAgent._requests, [\"/a\", \"/c\"]);\n          assert.deepEqual(res.parsedJson, { yes: \"no\" });\n          assert.deepEqual(res.responseUrl, \"https://localhost:3601/c\");\n        });\n    });\n  });\n\n  describe(\"should not hang on empty writes\", function () {\n    it(\"when data is the empty string without encoding\", function () {\n      app.post(\"/a\", sendsJson({ foo: \"bar\" }));\n\n      return server.start(app)\n        .then(asPromise(function (resolve, reject) {\n          var req = http.request(\"http://localhost:3600/a\", { method: \"POST\" }, resolve);\n          req.write(\"\");\n          req.write(\"\", function () {\n            req.end(\"\");\n          });\n          req.on(\"error\", reject);\n        }))\n        .then(asPromise(function (resolve, reject, res) {\n          assert.deepEqual(res.responseUrl, \"http://localhost:3600/a\");\n          res.pipe(concat({ encoding: \"string\" }, resolve)).on(\"error\", reject);\n        }));\n    });\n\n    it(\"when data is the empty string with encoding\", function () {\n      app.post(\"/a\", sendsJson({ foo: \"bar\" }));\n\n      return server.start(app)\n        .then(asPromise(function (resolve, reject) {\n          var req = http.request(\"http://localhost:3600/a\", { method: \"POST\" }, resolve);\n          req.write(\"\");\n          req.write(\"\", \"utf8\", function () {\n            req.end(\"\", \"utf8\");\n          });\n          req.on(\"error\", reject);\n        }))\n        .then(asPromise(function (resolve, reject, res) {\n          assert.deepEqual(res.responseUrl, \"http://localhost:3600/a\");\n          res.pipe(concat({ encoding: \"string\" }, resolve)).on(\"error\", reject);\n        }));\n    });\n\n    it(\"when data is Buffer.from('')\", function () {\n      app.post(\"/a\", sendsJson({ foo: \"bar\" }));\n\n      return server.start(app)\n        .then(asPromise(function (resolve, reject) {\n          var req = http.request(\"http://localhost:3600/a\", { method: \"POST\" }, resolve);\n          req.write(Buffer.from(\"\"));\n          req.write(Buffer.from(\"\"), function () {\n            req.end(Buffer.from(\"\"));\n          });\n          req.on(\"error\", reject);\n        }))\n        .then(asPromise(function (resolve, reject, res) {\n          assert.deepEqual(res.responseUrl, \"http://localhost:3600/a\");\n          res.pipe(concat({ encoding: \"string\" }, resolve)).on(\"error\", reject);\n        }));\n    });\n  });\n\n  describe(\"end accepts as arguments\", function () {\n    var called;\n    function setCalled() {\n      called = true;\n    }\n\n    beforeEach(function () {\n      app.post(\"/a\", function (req, res) {\n        req.pipe(res);\n      });\n      called = false;\n    });\n\n\n    it(\"(none)\", function () {\n      return server.start(app)\n        .then(asPromise(function (resolve) {\n          var req = http.request(\"http://localhost:3600/a\", { method: \"POST\" }, resolve);\n          req.end();\n        }))\n        .then(asPromise(function (resolve, reject, res) {\n          res.pipe(concat({ encoding: \"string\" }, resolve));\n        }))\n        .then(function (body) {\n          assert.equal(body, \"\");\n        });\n    });\n\n    it(\"the empty string\", function () {\n      return server.start(app)\n        .then(asPromise(function (resolve) {\n          var req = http.request(\"http://localhost:3600/a\", { method: \"POST\" }, resolve);\n          req.end(\"\");\n        }))\n        .then(asPromise(function (resolve, reject, res) {\n          res.pipe(concat({ encoding: \"string\" }, resolve));\n        }))\n        .then(function (body) {\n          assert.equal(body, \"\");\n        });\n    });\n\n    it(\"a non-empty string\", function () {\n      return server.start(app)\n        .then(asPromise(function (resolve) {\n          var req = http.request(\"http://localhost:3600/a\", { method: \"POST\" }, resolve);\n          req.end(\"abc\");\n        }))\n        .then(asPromise(function (resolve, reject, res) {\n          res.pipe(concat({ encoding: \"string\" }, resolve));\n        }))\n        .then(function (body) {\n          assert.equal(body, \"abc\");\n        });\n    });\n\n    it(\"a non-empty string and an encoding\", function () {\n      return server.start(app)\n        .then(asPromise(function (resolve) {\n          var req = http.request(\"http://localhost:3600/a\", { method: \"POST\" }, resolve);\n          req.end(\"abc\", \"utf8\");\n        }))\n        .then(asPromise(function (resolve, reject, res) {\n          res.pipe(concat({ encoding: \"string\" }, resolve));\n        }))\n        .then(function (body) {\n          assert.equal(body, \"abc\");\n        });\n    });\n\n    it(\"a non-empty string, an encoding, and a callback\", function () {\n      return server.start(app)\n        .then(asPromise(function (resolve) {\n          var req = http.request(\"http://localhost:3600/a\", { method: \"POST\" }, resolve);\n          req.end(\"abc\", \"utf8\", setCalled);\n        }))\n        .then(asPromise(function (resolve, reject, res) {\n          res.pipe(concat({ encoding: \"string\" }, resolve));\n        }))\n        .then(function (body) {\n          assert.equal(body, \"abc\");\n          assert.equal(called, true);\n        });\n    });\n\n    it(\"a non-empty string and a callback\", function () {\n      return server.start(app)\n        .then(asPromise(function (resolve) {\n          var req = http.request(\"http://localhost:3600/a\", { method: \"POST\" }, resolve);\n          req.end(\"abc\", setCalled);\n        }))\n        .then(asPromise(function (resolve, reject, res) {\n          res.pipe(concat({ encoding: \"string\" }, resolve));\n        }))\n        .then(function (body) {\n          assert.equal(body, \"abc\");\n          assert.equal(called, true);\n        });\n    });\n\n    it(\"a callback\", function () {\n      return server.start(app)\n        .then(asPromise(function (resolve) {\n          var req = http.request(\"http://localhost:3600/a\", { method: \"POST\" }, resolve);\n          req.end(setCalled);\n        }))\n        .then(asPromise(function (resolve, reject, res) {\n          res.pipe(concat({ encoding: \"string\" }, resolve));\n        }))\n        .then(function (body) {\n          assert.equal(body, \"\");\n          assert.equal(called, true);\n        });\n    });\n  });\n\n  describe(\"change request options before redirects\", function () {\n    it(\"only call beforeRedirect on redirects, not the inital http call\", function () {\n      app.get(\"/a\", sendsJson({ a: \"b\" }));\n\n      return server.start(app)\n        .then(asPromise(function (resolve, reject) {\n          var options = {\n            host: \"localhost\",\n            port: 3600,\n            path: \"/a\",\n            method: \"GET\",\n            beforeRedirect: function () {\n              assert.fail(\"this should only be called on redirects\");\n            },\n          };\n          http.get(options, concatJson(resolve, reject)).on(\"error\", reject);\n        }))\n        .then(function (res) {\n          assert.deepEqual(res.parsedJson, { a: \"b\" });\n          assert.deepEqual(res.responseUrl, \"http://localhost:3600/a\");\n        });\n    });\n\n    it(\"ignore beforeRedirect if not a function\", function () {\n      app.get(\"/a\", redirectsTo(\"/b\"));\n      app.get(\"/b\", redirectsTo(\"/c\"));\n      app.get(\"/c\", sendsJson({ a: \"b\" }));\n\n      return server.start(app)\n        .then(asPromise(function (resolve, reject) {\n          var options = {\n            host: \"localhost\",\n            port: 3600,\n            path: \"/a\",\n            method: \"GET\",\n            beforeRedirect: 42,\n          };\n          http.get(options, concatJson(resolve, reject)).on(\"error\", reject);\n        }))\n        .then(function (res) {\n          assert.deepEqual(res.parsedJson, { a: \"b\" });\n          assert.deepEqual(res.responseUrl, \"http://localhost:3600/c\");\n        });\n    });\n\n    it(\"append new header with every redirect\", function () {\n      app.get(\"/a\", redirectsTo(\"/b\"));\n      app.get(\"/b\", redirectsTo(\"/c\"));\n      app.get(\"/c\", function (req, res) {\n        res.json(req.headers);\n      });\n      var callsToTransform = 0;\n\n      return server.start(app)\n        .then(asPromise(function (resolve, reject) {\n          var options = {\n            host: \"localhost\",\n            port: 3600,\n            path: \"/a\",\n            method: \"GET\",\n            beforeRedirect: function (optionz) {\n              callsToTransform++;\n              if (optionz.path === \"/b\") {\n                optionz.headers[\"header-a\"] = \"value A\";\n              }\n              else if (optionz.path === \"/c\") {\n                optionz.headers[\"header-b\"] = \"value B\";\n              }\n            },\n          };\n          http.get(options, concatJson(resolve, reject)).on(\"error\", reject);\n        }))\n        .then(function (res) {\n          assert.strictEqual(callsToTransform, 2);\n          assert.strictEqual(res.parsedJson[\"header-a\"], \"value A\");\n          assert.strictEqual(res.parsedJson[\"header-b\"], \"value B\");\n          assert.deepEqual(res.responseUrl, \"http://localhost:3600/c\");\n        });\n    });\n\n    it(\"abort request chain after throwing an error\", function () {\n      var redirected = false;\n      app.get(\"/a\", redirectsTo(\"/b\"));\n      app.get(\"/b\", function () {\n        redirected = true;\n        throw new Error(\"redirected request should have been aborted\");\n      });\n\n      return server.start(app)\n        .then(asPromise(function (resolve, reject) {\n          var options = {\n            host: \"localhost\",\n            port: 3600,\n            path: \"/a\",\n            method: \"GET\",\n            beforeRedirect: function () {\n              throw new Error(\"no redirects!\");\n            },\n          };\n          http.get(options, concatJson(resolve, reject)).on(\"error\", reject);\n        }))\n        .then(function () {\n          assert.fail(\"request chain should have been aborted\");\n        })\n        .catch(function (error) {\n          assert(!redirected);\n          assert(error instanceof Error);\n          assert.equal(error.message, \"no redirects!\");\n        });\n    });\n\n    it(\"access response header in beforeRedirect\", function () {\n      app.get(\"/a\", redirectsTo(\"/b\"));\n      app.get(\"/b\", function (req, res) {\n        res.json(req.headers);\n      });\n\n      return server.start(app)\n        .then(asPromise(function (resolve, reject) {\n          var options = {\n            host: \"localhost\",\n            port: 3600,\n            path: \"/a\",\n            method: \"GET\",\n            beforeRedirect: function (optionz, response) {\n              optionz.headers.testheader = \"itsAtest\" + response.headers.location;\n            },\n          };\n          http.get(options, concatJson(resolve, reject)).on(\"error\", reject);\n        }))\n        .then(function (res) {\n          assert.strictEqual(res.parsedJson.testheader, \"itsAtest/b\");\n          assert.deepEqual(res.responseUrl, \"http://localhost:3600/b\");\n        });\n    });\n  });\n});\n\nfunction noop() { /* noop */ }\n"], "fixing_code": ["var url = require(\"url\");\nvar URL = url.URL;\nvar http = require(\"http\");\nvar https = require(\"https\");\nvar Writable = require(\"stream\").Writable;\nvar assert = require(\"assert\");\nvar debug = require(\"./debug\");\n\n// Create handlers that pass events from native requests\nvar events = [\"abort\", \"aborted\", \"connect\", \"error\", \"socket\", \"timeout\"];\nvar eventHandlers = Object.create(null);\nevents.forEach(function (event) {\n  eventHandlers[event] = function (arg1, arg2, arg3) {\n    this._redirectable.emit(event, arg1, arg2, arg3);\n  };\n});\n\n// Error types with codes\nvar RedirectionError = createErrorType(\n  \"ERR_FR_REDIRECTION_FAILURE\",\n  \"Redirected request failed\"\n);\nvar TooManyRedirectsError = createErrorType(\n  \"ERR_FR_TOO_MANY_REDIRECTS\",\n  \"Maximum number of redirects exceeded\"\n);\nvar MaxBodyLengthExceededError = createErrorType(\n  \"ERR_FR_MAX_BODY_LENGTH_EXCEEDED\",\n  \"Request body larger than maxBodyLength limit\"\n);\nvar WriteAfterEndError = createErrorType(\n  \"ERR_STREAM_WRITE_AFTER_END\",\n  \"write after end\"\n);\n\n// An HTTP(S) request that can be redirected\nfunction RedirectableRequest(options, responseCallback) {\n  // Initialize the request\n  Writable.call(this);\n  this._sanitizeOptions(options);\n  this._options = options;\n  this._ended = false;\n  this._ending = false;\n  this._redirectCount = 0;\n  this._redirects = [];\n  this._requestBodyLength = 0;\n  this._requestBodyBuffers = [];\n\n  // Attach a callback if passed\n  if (responseCallback) {\n    this.on(\"response\", responseCallback);\n  }\n\n  // React to responses of native requests\n  var self = this;\n  this._onNativeResponse = function (response) {\n    self._processResponse(response);\n  };\n\n  // Perform the first request\n  this._performRequest();\n}\nRedirectableRequest.prototype = Object.create(Writable.prototype);\n\nRedirectableRequest.prototype.abort = function () {\n  abortRequest(this._currentRequest);\n  this.emit(\"abort\");\n};\n\n// Writes buffered data to the current native request\nRedirectableRequest.prototype.write = function (data, encoding, callback) {\n  // Writing is not allowed if end has been called\n  if (this._ending) {\n    throw new WriteAfterEndError();\n  }\n\n  // Validate input and shift parameters if necessary\n  if (!(typeof data === \"string\" || typeof data === \"object\" && (\"length\" in data))) {\n    throw new TypeError(\"data should be a string, Buffer or Uint8Array\");\n  }\n  if (typeof encoding === \"function\") {\n    callback = encoding;\n    encoding = null;\n  }\n\n  // Ignore empty buffers, since writing them doesn't invoke the callback\n  // https://github.com/nodejs/node/issues/22066\n  if (data.length === 0) {\n    if (callback) {\n      callback();\n    }\n    return;\n  }\n  // Only write when we don't exceed the maximum body length\n  if (this._requestBodyLength + data.length <= this._options.maxBodyLength) {\n    this._requestBodyLength += data.length;\n    this._requestBodyBuffers.push({ data: data, encoding: encoding });\n    this._currentRequest.write(data, encoding, callback);\n  }\n  // Error when we exceed the maximum body length\n  else {\n    this.emit(\"error\", new MaxBodyLengthExceededError());\n    this.abort();\n  }\n};\n\n// Ends the current native request\nRedirectableRequest.prototype.end = function (data, encoding, callback) {\n  // Shift parameters if necessary\n  if (typeof data === \"function\") {\n    callback = data;\n    data = encoding = null;\n  }\n  else if (typeof encoding === \"function\") {\n    callback = encoding;\n    encoding = null;\n  }\n\n  // Write data if needed and end\n  if (!data) {\n    this._ended = this._ending = true;\n    this._currentRequest.end(null, null, callback);\n  }\n  else {\n    var self = this;\n    var currentRequest = this._currentRequest;\n    this.write(data, encoding, function () {\n      self._ended = true;\n      currentRequest.end(null, null, callback);\n    });\n    this._ending = true;\n  }\n};\n\n// Sets a header value on the current native request\nRedirectableRequest.prototype.setHeader = function (name, value) {\n  this._options.headers[name] = value;\n  this._currentRequest.setHeader(name, value);\n};\n\n// Clears a header value on the current native request\nRedirectableRequest.prototype.removeHeader = function (name) {\n  delete this._options.headers[name];\n  this._currentRequest.removeHeader(name);\n};\n\n// Global timeout for all underlying requests\nRedirectableRequest.prototype.setTimeout = function (msecs, callback) {\n  var self = this;\n\n  // Destroys the socket on timeout\n  function destroyOnTimeout(socket) {\n    socket.setTimeout(msecs);\n    socket.removeListener(\"timeout\", socket.destroy);\n    socket.addListener(\"timeout\", socket.destroy);\n  }\n\n  // Sets up a timer to trigger a timeout event\n  function startTimer(socket) {\n    if (self._timeout) {\n      clearTimeout(self._timeout);\n    }\n    self._timeout = setTimeout(function () {\n      self.emit(\"timeout\");\n      clearTimer();\n    }, msecs);\n    destroyOnTimeout(socket);\n  }\n\n  // Stops a timeout from triggering\n  function clearTimer() {\n    // Clear the timeout\n    if (self._timeout) {\n      clearTimeout(self._timeout);\n      self._timeout = null;\n    }\n\n    // Clean up all attached listeners\n    self.removeListener(\"abort\", clearTimer);\n    self.removeListener(\"error\", clearTimer);\n    self.removeListener(\"response\", clearTimer);\n    if (callback) {\n      self.removeListener(\"timeout\", callback);\n    }\n    if (!self.socket) {\n      self._currentRequest.removeListener(\"socket\", startTimer);\n    }\n  }\n\n  // Attach callback if passed\n  if (callback) {\n    this.on(\"timeout\", callback);\n  }\n\n  // Start the timer if or when the socket is opened\n  if (this.socket) {\n    startTimer(this.socket);\n  }\n  else {\n    this._currentRequest.once(\"socket\", startTimer);\n  }\n\n  // Clean up on events\n  this.on(\"socket\", destroyOnTimeout);\n  this.on(\"abort\", clearTimer);\n  this.on(\"error\", clearTimer);\n  this.on(\"response\", clearTimer);\n\n  return this;\n};\n\n// Proxy all other public ClientRequest methods\n[\n  \"flushHeaders\", \"getHeader\",\n  \"setNoDelay\", \"setSocketKeepAlive\",\n].forEach(function (method) {\n  RedirectableRequest.prototype[method] = function (a, b) {\n    return this._currentRequest[method](a, b);\n  };\n});\n\n// Proxy all public ClientRequest properties\n[\"aborted\", \"connection\", \"socket\"].forEach(function (property) {\n  Object.defineProperty(RedirectableRequest.prototype, property, {\n    get: function () { return this._currentRequest[property]; },\n  });\n});\n\nRedirectableRequest.prototype._sanitizeOptions = function (options) {\n  // Ensure headers are always present\n  if (!options.headers) {\n    options.headers = {};\n  }\n\n  // Since http.request treats host as an alias of hostname,\n  // but the url module interprets host as hostname plus port,\n  // eliminate the host property to avoid confusion.\n  if (options.host) {\n    // Use hostname if set, because it has precedence\n    if (!options.hostname) {\n      options.hostname = options.host;\n    }\n    delete options.host;\n  }\n\n  // Complete the URL object when necessary\n  if (!options.pathname && options.path) {\n    var searchPos = options.path.indexOf(\"?\");\n    if (searchPos < 0) {\n      options.pathname = options.path;\n    }\n    else {\n      options.pathname = options.path.substring(0, searchPos);\n      options.search = options.path.substring(searchPos);\n    }\n  }\n};\n\n\n// Executes the next native request (initial or redirect)\nRedirectableRequest.prototype._performRequest = function () {\n  // Load the native protocol\n  var protocol = this._options.protocol;\n  var nativeProtocol = this._options.nativeProtocols[protocol];\n  if (!nativeProtocol) {\n    this.emit(\"error\", new TypeError(\"Unsupported protocol \" + protocol));\n    return;\n  }\n\n  // If specified, use the agent corresponding to the protocol\n  // (HTTP and HTTPS use different types of agents)\n  if (this._options.agents) {\n    var scheme = protocol.substr(0, protocol.length - 1);\n    this._options.agent = this._options.agents[scheme];\n  }\n\n  // Create the native request\n  var request = this._currentRequest =\n        nativeProtocol.request(this._options, this._onNativeResponse);\n  this._currentUrl = url.format(this._options);\n\n  // Set up event handlers\n  request._redirectable = this;\n  for (var e = 0; e < events.length; e++) {\n    request.on(events[e], eventHandlers[events[e]]);\n  }\n\n  // End a redirected request\n  // (The first request must be ended explicitly with RedirectableRequest#end)\n  if (this._isRedirect) {\n    // Write the request entity and end.\n    var i = 0;\n    var self = this;\n    var buffers = this._requestBodyBuffers;\n    (function writeNext(error) {\n      // Only write if this request has not been redirected yet\n      /* istanbul ignore else */\n      if (request === self._currentRequest) {\n        // Report any write errors\n        /* istanbul ignore if */\n        if (error) {\n          self.emit(\"error\", error);\n        }\n        // Write the next buffer if there are still left\n        else if (i < buffers.length) {\n          var buffer = buffers[i++];\n          /* istanbul ignore else */\n          if (!request.finished) {\n            request.write(buffer.data, buffer.encoding, writeNext);\n          }\n        }\n        // End the request if `end` has been called on us\n        else if (self._ended) {\n          request.end();\n        }\n      }\n    }());\n  }\n};\n\n// Processes a response from the current native request\nRedirectableRequest.prototype._processResponse = function (response) {\n  // Store the redirected response\n  var statusCode = response.statusCode;\n  if (this._options.trackRedirects) {\n    this._redirects.push({\n      url: this._currentUrl,\n      headers: response.headers,\n      statusCode: statusCode,\n    });\n  }\n\n  // RFC7231\u00a76.4: The 3xx (Redirection) class of status code indicates\n  // that further action needs to be taken by the user agent in order to\n  // fulfill the request. If a Location header field is provided,\n  // the user agent MAY automatically redirect its request to the URI\n  // referenced by the Location field value,\n  // even if the specific status code is not understood.\n  var location = response.headers.location;\n  if (location && this._options.followRedirects !== false &&\n      statusCode >= 300 && statusCode < 400) {\n    // Abort the current request\n    abortRequest(this._currentRequest);\n    // Discard the remainder of the response to avoid waiting for data\n    response.destroy();\n\n    // RFC7231\u00a76.4: A client SHOULD detect and intervene\n    // in cyclical redirections (i.e., \"infinite\" redirection loops).\n    if (++this._redirectCount > this._options.maxRedirects) {\n      this.emit(\"error\", new TooManyRedirectsError());\n      return;\n    }\n\n    // RFC7231\u00a76.4: Automatic redirection needs to done with\n    // care for methods not known to be safe, [\u2026]\n    // RFC7231\u00a76.4.2\u20133: For historical reasons, a user agent MAY change\n    // the request method from POST to GET for the subsequent request.\n    if ((statusCode === 301 || statusCode === 302) && this._options.method === \"POST\" ||\n        // RFC7231\u00a76.4.4: The 303 (See Other) status code indicates that\n        // the server is redirecting the user agent to a different resource [\u2026]\n        // A user agent can perform a retrieval request targeting that URI\n        // (a GET or HEAD request if using HTTP) [\u2026]\n        (statusCode === 303) && !/^(?:GET|HEAD)$/.test(this._options.method)) {\n      this._options.method = \"GET\";\n      // Drop a possible entity and headers related to it\n      this._requestBodyBuffers = [];\n      removeMatchingHeaders(/^content-/i, this._options.headers);\n    }\n\n    // Drop the Host header, as the redirect might lead to a different host\n    var currentHostHeader = removeMatchingHeaders(/^host$/i, this._options.headers);\n\n    // If the redirect is relative, carry over the host of the last request\n    var currentUrlParts = url.parse(this._currentUrl);\n    var currentHost = currentHostHeader || currentUrlParts.host;\n    var currentUrl = /^\\w+:/.test(location) ? this._currentUrl :\n      url.format(Object.assign(currentUrlParts, { host: currentHost }));\n\n    // Determine the URL of the redirection\n    var redirectUrl;\n    try {\n      redirectUrl = url.resolve(currentUrl, location);\n    }\n    catch (cause) {\n      this.emit(\"error\", new RedirectionError(cause));\n      return;\n    }\n\n    // Create the redirected request\n    debug(\"redirecting to\", redirectUrl);\n    this._isRedirect = true;\n    var redirectUrlParts = url.parse(redirectUrl);\n    Object.assign(this._options, redirectUrlParts);\n\n    // Drop the confidential headers when redirecting to another domain\n    if (!(redirectUrlParts.host === currentHost || isSubdomainOf(redirectUrlParts.host, currentHost))) {\n      removeMatchingHeaders(/^(?:authorization|cookie)$/i, this._options.headers);\n    }\n\n    // Evaluate the beforeRedirect callback\n    if (typeof this._options.beforeRedirect === \"function\") {\n      var responseDetails = { headers: response.headers };\n      try {\n        this._options.beforeRedirect.call(null, this._options, responseDetails);\n      }\n      catch (err) {\n        this.emit(\"error\", err);\n        return;\n      }\n      this._sanitizeOptions(this._options);\n    }\n\n    // Perform the redirected request\n    try {\n      this._performRequest();\n    }\n    catch (cause) {\n      this.emit(\"error\", new RedirectionError(cause));\n    }\n  }\n  else {\n    // The response is not a redirect; return it as-is\n    response.responseUrl = this._currentUrl;\n    response.redirects = this._redirects;\n    this.emit(\"response\", response);\n\n    // Clean up\n    this._requestBodyBuffers = [];\n  }\n};\n\n// Wraps the key/value object of protocols with redirect functionality\nfunction wrap(protocols) {\n  // Default settings\n  var exports = {\n    maxRedirects: 21,\n    maxBodyLength: 10 * 1024 * 1024,\n  };\n\n  // Wrap each protocol\n  var nativeProtocols = {};\n  Object.keys(protocols).forEach(function (scheme) {\n    var protocol = scheme + \":\";\n    var nativeProtocol = nativeProtocols[protocol] = protocols[scheme];\n    var wrappedProtocol = exports[scheme] = Object.create(nativeProtocol);\n\n    // Executes a request, following redirects\n    function request(input, options, callback) {\n      // Parse parameters\n      if (typeof input === \"string\") {\n        var urlStr = input;\n        try {\n          input = urlToOptions(new URL(urlStr));\n        }\n        catch (err) {\n          /* istanbul ignore next */\n          input = url.parse(urlStr);\n        }\n      }\n      else if (URL && (input instanceof URL)) {\n        input = urlToOptions(input);\n      }\n      else {\n        callback = options;\n        options = input;\n        input = { protocol: protocol };\n      }\n      if (typeof options === \"function\") {\n        callback = options;\n        options = null;\n      }\n\n      // Set defaults\n      options = Object.assign({\n        maxRedirects: exports.maxRedirects,\n        maxBodyLength: exports.maxBodyLength,\n      }, input, options);\n      options.nativeProtocols = nativeProtocols;\n\n      assert.equal(options.protocol, protocol, \"protocol mismatch\");\n      debug(\"options\", options);\n      return new RedirectableRequest(options, callback);\n    }\n\n    // Executes a GET request, following redirects\n    function get(input, options, callback) {\n      var wrappedRequest = wrappedProtocol.request(input, options, callback);\n      wrappedRequest.end();\n      return wrappedRequest;\n    }\n\n    // Expose the properties on the wrapped protocol\n    Object.defineProperties(wrappedProtocol, {\n      request: { value: request, configurable: true, enumerable: true, writable: true },\n      get: { value: get, configurable: true, enumerable: true, writable: true },\n    });\n  });\n  return exports;\n}\n\n/* istanbul ignore next */\nfunction noop() { /* empty */ }\n\n// from https://github.com/nodejs/node/blob/master/lib/internal/url.js\nfunction urlToOptions(urlObject) {\n  var options = {\n    protocol: urlObject.protocol,\n    hostname: urlObject.hostname.startsWith(\"[\") ?\n      /* istanbul ignore next */\n      urlObject.hostname.slice(1, -1) :\n      urlObject.hostname,\n    hash: urlObject.hash,\n    search: urlObject.search,\n    pathname: urlObject.pathname,\n    path: urlObject.pathname + urlObject.search,\n    href: urlObject.href,\n  };\n  if (urlObject.port !== \"\") {\n    options.port = Number(urlObject.port);\n  }\n  return options;\n}\n\nfunction removeMatchingHeaders(regex, headers) {\n  var lastValue;\n  for (var header in headers) {\n    if (regex.test(header)) {\n      lastValue = headers[header];\n      delete headers[header];\n    }\n  }\n  return (lastValue === null || typeof lastValue === \"undefined\") ?\n    undefined : String(lastValue).trim();\n}\n\nfunction createErrorType(code, defaultMessage) {\n  function CustomError(cause) {\n    Error.captureStackTrace(this, this.constructor);\n    if (!cause) {\n      this.message = defaultMessage;\n    }\n    else {\n      this.message = defaultMessage + \": \" + cause.message;\n      this.cause = cause;\n    }\n  }\n  CustomError.prototype = new Error();\n  CustomError.prototype.constructor = CustomError;\n  CustomError.prototype.name = \"Error [\" + code + \"]\";\n  CustomError.prototype.code = code;\n  return CustomError;\n}\n\nfunction abortRequest(request) {\n  for (var e = 0; e < events.length; e++) {\n    request.removeListener(events[e], eventHandlers[events[e]]);\n  }\n  request.on(\"error\", noop);\n  request.abort();\n}\n\nfunction isSubdomainOf(subdomain, domain) {\n  const dot = subdomain.length - domain.length - 1;\n  return dot > 0 && subdomain[dot] === \".\" && subdomain.endsWith(domain);\n}\n\n// Exports\nmodule.exports = wrap({ http: http, https: https });\nmodule.exports.wrap = wrap;\n", "var express = require(\"express\");\nvar assert = require(\"assert\");\nvar net = require(\"net\");\nvar server = require(\"./server\")({ https: 3601, http: 3600 });\nvar url = require(\"url\");\nvar followRedirects = require(\"..\");\nvar http = followRedirects.http;\nvar https = followRedirects.https;\nvar fs = require(\"fs\");\nvar path = require(\"path\");\nvar lolex = require(\"lolex\");\n\nvar util = require(\"./util\");\nvar concat = require(\"concat-stream\");\nvar concatJson = util.concatJson;\nvar delay = util.delay;\nvar redirectsTo = util.redirectsTo;\nvar sendsJson = util.sendsJson;\nvar asPromise = util.asPromise;\n\nvar testFile = path.resolve(__dirname, \"assets/input.txt\");\nvar testFileBuffer = fs.readFileSync(testFile);\nvar testFileString = testFileBuffer.toString();\n\nvar nodeMajorVersion = Number.parseInt(process.version.match(/\\d+/)[0], 10);\n\ndescribe(\"follow-redirects\", function () {\n  function httpsOptions(app) {\n    return {\n      app: app,\n      protocol: \"https\",\n      cert: fs.readFileSync(path.resolve(__dirname, \"assets/localhost.crt\")),\n      key: fs.readFileSync(path.resolve(__dirname, \"assets/localhost.key\")),\n    };\n  }\n  var ca = fs.readFileSync(path.resolve(__dirname, \"assets/ca.crt\"));\n\n  var app;\n  var app2;\n  var originalMaxRedirects;\n  var originalMaxBodyLength;\n\n  beforeEach(function () {\n    originalMaxRedirects = followRedirects.maxRedirects;\n    originalMaxBodyLength = followRedirects.maxBodyLength;\n    app = express();\n    app2 = express();\n  });\n\n  afterEach(function () {\n    followRedirects.maxRedirects = originalMaxRedirects;\n    followRedirects.maxBodyLength = originalMaxBodyLength;\n    return server.stop();\n  });\n\n  it(\"http.get with string and callback - redirect\", function () {\n    app.get(\"/a\", redirectsTo(\"/b\"));\n    app.get(\"/b\", redirectsTo(\"/c\"));\n    app.get(\"/c\", redirectsTo(\"/d\"));\n    app.get(\"/d\", redirectsTo(\"/e\"));\n    app.get(\"/e\", redirectsTo(\"/f\"));\n    app.get(\"/f\", sendsJson({ a: \"b\" }));\n\n    return server.start(app)\n      .then(asPromise(function (resolve, reject) {\n        http.get(\"http://localhost:3600/a\", concatJson(resolve, reject)).on(\"error\", reject);\n      }))\n      .then(function (res) {\n        assert.deepEqual(res.parsedJson, { a: \"b\" });\n        assert.deepEqual(res.responseUrl, \"http://localhost:3600/f\");\n      });\n  });\n\n  it(\"http.get with URL object and callback - redirect\", function () {\n    if (nodeMajorVersion < 10) {\n      this.skip();\n    }\n\n    app.get(\"/a\", redirectsTo(\"/b\"));\n    app.get(\"/b\", redirectsTo(\"/c\"));\n    app.get(\"/c\", redirectsTo(\"/d\"));\n    app.get(\"/d\", redirectsTo(\"/e\"));\n    app.get(\"/e\", redirectsTo(\"/f\"));\n    app.get(\"/f\", sendsJson({ a: \"b\" }));\n\n    return server.start(app)\n      .then(asPromise(function (resolve, reject) {\n        http.get(\n          new URL(\"http://localhost:3600/a\"),\n          concatJson(resolve, reject)\n        ).on(\"error\", reject);\n      }))\n      .then(function (res) {\n        assert.deepEqual(res.parsedJson, { a: \"b\" });\n        assert.deepEqual(res.responseUrl, \"http://localhost:3600/f\");\n      });\n  });\n\n  it(\"http.get with options object and callback - redirect\", function () {\n    app.get(\"/a\", redirectsTo(\"/b\"));\n    app.get(\"/b\", redirectsTo(\"/c\"));\n    app.get(\"/c\", redirectsTo(\"/d\"));\n    app.get(\"/d\", redirectsTo(\"/e\"));\n    app.get(\"/e\", redirectsTo(\"/f\"));\n    app.get(\"/f\", sendsJson({ a: \"b\" }));\n\n    return server.start(app)\n      .then(asPromise(function (resolve, reject) {\n        var options = {\n          hostname: \"localhost\",\n          port: 3600,\n          path: \"/a\",\n          method: \"GET\",\n        };\n        http.get(options, concatJson(resolve, reject)).on(\"error\", reject);\n      }))\n      .then(function (res) {\n        assert.deepEqual(res.parsedJson, { a: \"b\" });\n        assert.deepEqual(res.responseUrl, \"http://localhost:3600/f\");\n      });\n  });\n\n  it(\"http.get with string and callback - no redirect\", function () {\n    app.get(\"/a\", sendsJson({ a: \"b\" }));\n\n    return server.start(app)\n      .then(asPromise(function (resolve, reject) {\n        http.get(\"http://localhost:3600/a\", concatJson(resolve, reject)).on(\"error\", reject);\n      }))\n      .then(function (res) {\n        assert.deepEqual(res.parsedJson, { a: \"b\" });\n        assert.deepEqual(res.responseUrl, \"http://localhost:3600/a\");\n      });\n  });\n\n  it(\"http.get with options object and callback - no redirect\", function () {\n    app.get(\"/a\", sendsJson({ a: \"b\" }));\n\n    return server.start(app)\n      .then(asPromise(function (resolve, reject) {\n        var options = {\n          hostname: \"localhost\",\n          port: 3600,\n          path: \"/a?xyz\",\n          method: \"GET\",\n        };\n        http.get(options, concatJson(resolve, reject)).on(\"error\", reject);\n      }))\n      .then(function (res) {\n        assert.deepEqual(res.parsedJson, { a: \"b\" });\n        assert.deepEqual(res.responseUrl, \"http://localhost:3600/a?xyz\");\n      });\n  });\n\n  it(\"http.get with host option and callback - redirect\", function () {\n    app.get(\"/a\", redirectsTo(\"/b\"));\n    app.get(\"/b\", redirectsTo(\"/c\"));\n    app.get(\"/c\", redirectsTo(\"/d\"));\n    app.get(\"/d\", redirectsTo(\"/e\"));\n    app.get(\"/e\", redirectsTo(\"/f\"));\n    app.get(\"/f\", sendsJson({ a: \"b\" }));\n\n    return server.start(app)\n      .then(asPromise(function (resolve, reject) {\n        var options = {\n          host: \"localhost\",\n          port: 3600,\n          path: \"/a\",\n          method: \"GET\",\n        };\n        http.get(options, concatJson(resolve, reject)).on(\"error\", reject);\n      }))\n      .then(function (res) {\n        assert.deepEqual(res.parsedJson, { a: \"b\" });\n        assert.deepEqual(res.responseUrl, \"http://localhost:3600/f\");\n      });\n  });\n\n  it(\"http.get with response event\", function () {\n    app.get(\"/a\", redirectsTo(\"/b\"));\n    app.get(\"/b\", redirectsTo(\"/c\"));\n    app.get(\"/c\", redirectsTo(\"/d\"));\n    app.get(\"/d\", redirectsTo(\"/e\"));\n    app.get(\"/e\", redirectsTo(\"/f\"));\n    app.get(\"/f\", sendsJson({ a: \"b\" }));\n\n    return server.start(app)\n      .then(asPromise(function (resolve, reject) {\n        http.get(\"http://localhost:3600/a\")\n          .on(\"response\", concatJson(resolve, reject))\n          .on(\"error\", reject);\n      }))\n      .then(function (res) {\n        assert.deepEqual(res.parsedJson, { a: \"b\" });\n        assert.deepEqual(res.responseUrl, \"http://localhost:3600/f\");\n      });\n  });\n\n  it(\"should return with the original status code if the response does not contain a location header\", function () {\n    app.get(\"/a\", function (req, res) {\n      res.status(307).end();\n    });\n\n    return server.start(app)\n      .then(asPromise(function (resolve, reject) {\n        http.get(\"http://localhost:3600/a\", resolve).on(\"error\", reject);\n      }))\n      .then(function (res) {\n        assert.equal(res.statusCode, 307);\n        assert.deepEqual(res.responseUrl, \"http://localhost:3600/a\");\n        res.on(\"data\", function () {\n          // noop to consume the stream (server won't shut down otherwise).\n        });\n      });\n  });\n\n  it(\"should emit connection errors on the returned stream\", function () {\n    app.get(\"/a\", redirectsTo(\"http://localhost:36002/b\"));\n\n    return server.start(app)\n      .then(asPromise(function (resolve, reject) {\n        http.get(\"http://localhost:3600/a\", reject).on(\"error\", resolve);\n      }))\n      .then(function (error) {\n        assert.equal(error.code, \"ECONNREFUSED\");\n      });\n  });\n\n  it(\"should emit socket events on the returned stream\", function () {\n    app.get(\"/a\", sendsJson({ a: \"b\" }));\n\n    return server.start(app)\n      .then(asPromise(function (resolve, reject) {\n        http.get(\"http://localhost:3600/a\")\n          .on(\"socket\", resolve)\n          .on(\"error\", reject);\n      }))\n      .then(function (socket) {\n        assert(socket instanceof net.Socket, \"socket event should emit with socket\");\n      });\n  });\n\n  it(\"should emit connect events on the returned stream\", function () {\n    app.get(\"/a\", sendsJson({ a: \"b\" }));\n\n    var req;\n    return server.start(app)\n      .then(asPromise(function (resolve, reject) {\n        req = http.get(\"http://localhost:3600/a\");\n        req.on(\"connect\", function (response, socket, head) {\n          resolve({ response: response, socket: socket, head: head });\n        });\n        req.on(\"error\", reject);\n        req._currentRequest.emit(\"connect\", \"r\", \"s\", \"h\");\n      }))\n      .then(function (args) {\n        req.abort();\n        assert.equal(args.response, \"r\");\n        assert.equal(args.socket, \"s\");\n        assert.equal(args.head, \"h\");\n      });\n  });\n\n  it(\"emits an error on redirects with an invalid location\", function () {\n    if (nodeMajorVersion < 10) {\n      this.skip();\n    }\n\n    app.get(\"/a\", function (req, res) {\n      // Explictly send response with invalid Location header\n      res.socket.write(\"HTTP/1.1 301 Moved Permanently\\n\");\n      res.socket.write(\"Location: http://\u0441\u043c\u043e\u043b\u044c\u043d\u044b\u0439-\u0438\u043d\u0441\u0442\u0438\u0442\u0443\u0442.\u0440\u0444\\n\");\n      res.socket.write(\"\\n\");\n      res.socket.end();\n    });\n\n    return server.start(app)\n      .then(asPromise(function (resolve) {\n        http.get(\"http://localhost:3600/a\").on(\"error\", resolve);\n      }))\n      .then(function (error) {\n        assert(error instanceof Error);\n        assert.equal(error.code, \"ERR_FR_REDIRECTION_FAILURE\");\n        assert(error.cause instanceof Error);\n        switch (error.cause.code) {\n        // Node 17+\n        case \"ERR_INVALID_URL\":\n          assert.equal(error.message, \"Redirected request failed: Invalid URL\");\n          break;\n        // Older Node versions\n        case \"ERR_UNESCAPED_CHARACTERS\":\n          assert.equal(error.message, \"Redirected request failed: Request path contains unescaped characters\");\n          break;\n        default:\n          throw new Error(\"Unexpected error code \" + error.code);\n        }\n      });\n  });\n\n  it(\"emits an error whem url.resolve fails\", function () {\n    app.get(\"/a\", redirectsTo(\"/b\"));\n    var urlResolve = url.resolve;\n    url.resolve = function () {\n      throw new Error();\n    };\n\n    return server.start(app)\n      .then(asPromise(function (resolve) {\n        http.get(\"http://localhost:3600/a\").on(\"error\", resolve);\n      }))\n      .then(function (error) {\n        url.resolve = urlResolve;\n        assert.equal(error.code, \"ERR_FR_REDIRECTION_FAILURE\");\n      });\n  });\n\n  it(\"emits an error when the request fails for another reason\", function () {\n    app.get(\"/a\", function (req, res) {\n      res.socket.write(\"HTTP/1.1 301 Moved Permanently\\n\");\n      res.socket.write(\"Location: other\\n\");\n      res.socket.write(\"\\n\");\n      res.socket.end();\n    });\n\n    return server.start(app)\n      .then(asPromise(function (resolve) {\n        var request = http.get(\"http://localhost:3600/a\");\n        request._performRequest = function () {\n          throw new Error(\"custom\");\n        };\n        request.on(\"error\", resolve);\n      }))\n      .then(function (error) {\n        assert(error instanceof Error);\n        assert.equal(error.message, \"Redirected request failed: custom\");\n      });\n  });\n\n  describe(\"setTimeout\", function () {\n    var clock;\n    beforeEach(function () {\n      clock = lolex.install();\n    });\n    afterEach(function () {\n      clock.uninstall();\n    });\n\n    it(\"clears timeouts after a successful response\", function () {\n      app.get(\"/redirect\", redirectsTo(\"/timeout\"));\n      app.get(\"/timeout\", delay(clock, 2000, sendsJson({ didnot: \"timeout\" })));\n\n      var req;\n      return server.start(app)\n        .then(asPromise(function (resolve, reject) {\n          req = http.get(\"http://localhost:3600/redirect\", concatJson(resolve, reject));\n          req.on(\"error\", reject);\n          req.setTimeout(3000, function () {\n            throw new Error(\"should not have timed out\");\n          });\n        }))\n        .then(function (res) {\n          assert.deepEqual(res.parsedJson, { didnot: \"timeout\" });\n          assert.deepEqual(res.responseUrl, \"http://localhost:3600/timeout\");\n          clock.tick(5000);\n        });\n    });\n\n    it(\"clears timeouts after an error response\", function () {\n      app.get(\"/redirect\", redirectsTo(\"http://localhost:3602/b\"));\n\n      var req;\n      return server.start(app)\n        .then(asPromise(function (resolve, reject) {\n          req = http.get(\"http://localhost:3600/redirect\", reject);\n          req.setTimeout(3000, function () {\n            throw new Error(\"should not have timed out\");\n          });\n          req.on(\"error\", resolve);\n        }))\n        .then(function (error) {\n          assert.equal(error.code, \"ECONNREFUSED\");\n          clock.tick(5000);\n        });\n    });\n\n    it(\"handles errors occuring before a socket is established\", function () {\n      app.get(\"/redirect\", redirectsTo(\"http://localhost:3602/b\"));\n\n      var req;\n      return server.start(app)\n        .then(asPromise(function (resolve, reject) {\n          req = http.get(\"http://localhost:3600/redirect\", reject);\n          req.setTimeout(3000, function () {\n            throw new Error(\"should not have timed out\");\n          });\n          req.emit(\"error\", new Error());\n          req.on(\"error\", resolve);\n        }))\n        .then(function (error) {\n          assert.equal(error.code, \"ECONNREFUSED\");\n          clock.tick(5000);\n        });\n    });\n\n    it(\"sets a timeout when the socket already exists\", function () {\n      app.get(\"/timeout\", delay(clock, 5000, sendsJson({ timed: \"out\" })));\n\n      return server.start(app)\n        .then(asPromise(function (resolve, reject) {\n          var req = http.get(\"http://localhost:3600/timeout\", function () {\n            throw new Error(\"should have timed out\");\n          });\n          req.on(\"error\", reject);\n          req.on(\"socket\", function () {\n            assert(req.socket instanceof net.Socket);\n            req.setTimeout(3000, function () {\n              req.abort();\n              resolve();\n            });\n          });\n        }));\n    });\n\n    it(\"destroys the socket after configured inactivity period\", function () {\n      app.get(\"/data\", delay(clock, 3000, sendsJson({ took: \"toolongtosenddata\" })));\n\n      return server.start(app)\n        .then(asPromise(function (resolve, reject) {\n          var req = http.get(\"http://localhost:3600/data\", concatJson(reject, reject));\n          req.on(\"error\", reject);\n          req.setTimeout(100, function () {\n            throw new Error(\"should not have timed out\");\n          });\n          req.on(\"socket\", function () {\n            req.socket.on(\"timeout\", function () {\n              resolve();\n            });\n          });\n        }));\n    });\n\n    it(\"should timeout on the final request\", function () {\n      app.get(\"/redirect1\", redirectsTo(\"/redirect2\"));\n      app.get(\"/redirect2\", redirectsTo(\"/timeout\"));\n      app.get(\"/timeout\", delay(clock, 5000, sendsJson({ timed: \"out\" })));\n\n      return server.start(app)\n        .then(asPromise(function (resolve, reject) {\n          var req = http.get(\"http://localhost:3600/redirect1\", function () {\n            throw new Error(\"should have timed out\");\n          });\n          req.on(\"error\", reject);\n          req.setTimeout(1000, function () {\n            req.abort();\n            resolve();\n          });\n        }));\n    });\n\n    it(\"should include redirect delays in the timeout\", function () {\n      app.get(\"/redirect1\", delay(clock, 1000, redirectsTo(\"/redirect2\")));\n      app.get(\"/redirect2\", delay(clock, 1000, redirectsTo(\"/redirect3\")));\n      app.get(\"/redirect3\", delay(clock, 1000, \"/timeout\"));\n      app.get(\"/timeout\", delay(clock, 1000, sendsJson({ timed: \"out\" })));\n\n      return server.start(app)\n        .then(asPromise(function (resolve, reject) {\n          var req = http.get(\"http://localhost:3600/redirect1\", function () {\n            throw new Error(\"should have timed out\");\n          });\n          req.on(\"error\", reject);\n          req.setTimeout(2000, function () {\n            req.abort();\n            resolve();\n          });\n        }));\n    });\n\n    it(\"overrides existing timeouts\", function () {\n      app.get(\"/redirect\", redirectsTo(\"/timeout\"));\n      app.get(\"/timeout\", delay(clock, 5000, sendsJson({ timed: \"out\" })));\n\n      return server.start(app)\n        .then(asPromise(function (resolve, reject) {\n          var req = http.get(\"http://localhost:3600/redirect\", function () {\n            throw new Error(\"should have timed out\");\n          });\n          req.on(\"error\", reject);\n\n          var callbacks = 0;\n          function timeoutCallback() {\n            if (++callbacks === 3) {\n              req.abort();\n              resolve(callbacks);\n            }\n          }\n          req.setTimeout(10000, timeoutCallback);\n          req.setTimeout(10000, timeoutCallback);\n          req.setTimeout(1000, timeoutCallback);\n        }));\n    });\n  });\n\n  it(\"should follow redirects over https\", function () {\n    app.get(\"/a\", redirectsTo(\"/b\"));\n    app.get(\"/b\", redirectsTo(\"/c\"));\n    app.get(\"/c\", sendsJson({ baz: \"quz\" }));\n\n    return server.start(httpsOptions(app))\n      .then(asPromise(function (resolve, reject) {\n        var opts = url.parse(\"https://localhost:3601/a\");\n        opts.ca = ca;\n        https.get(opts, concatJson(resolve, reject)).on(\"error\", reject);\n      }))\n      .then(function (res) {\n        assert.deepEqual(res.parsedJson, { baz: \"quz\" });\n        assert.deepEqual(res.responseUrl, \"https://localhost:3601/c\");\n      });\n  });\n\n  it(\"should destroy responses\", function () {\n    app.get(\"/a\", hangingRedirectTo(\"/b\"));\n    app.get(\"/b\", hangingRedirectTo(\"/c\"));\n    app.get(\"/c\", hangingRedirectTo(\"/d\"));\n    app.get(\"/d\", hangingRedirectTo(\"/e\"));\n    app.get(\"/e\", hangingRedirectTo(\"/f\"));\n    app.get(\"/f\", sendsJson({ a: \"b\" }));\n\n    function hangingRedirectTo(destination) {\n      return function (req, res) {\n        res.writeHead(301, { location: destination });\n        res.write(new Array(128).join(\" \"));\n      };\n    }\n\n    return server.start(app)\n      .then(asPromise(function (resolve, reject) {\n        http.get(\"http://localhost:3600/a\", concatJson(resolve, reject)).on(\"error\", reject);\n      }))\n      .then(function (res) {\n        assert.deepEqual(res.parsedJson, { a: \"b\" });\n        assert.deepEqual(res.responseUrl, \"http://localhost:3600/f\");\n      });\n  });\n\n  it(\"should honor query params in redirects\", function () {\n    app.get(\"/a\", redirectsTo(\"/b?greeting=hello\"));\n    app.get(\"/b\", function (req, res) {\n      res.json({ greeting: req.query.greeting });\n    });\n\n    return server.start(app)\n      .then(asPromise(function (resolve, reject) {\n        http.get(\"http://localhost:3600/a\", concatJson(resolve, reject)).on(\"error\", reject);\n      }))\n      .then(function (res) {\n        assert.deepEqual(res.parsedJson, { greeting: \"hello\" });\n        assert.deepEqual(res.responseUrl, \"http://localhost:3600/b?greeting=hello\");\n      });\n  });\n\n  it(\"should allow aborting\", function () {\n    var request;\n\n    app.get(\"/a\", redirectsTo(\"/b\"));\n    app.get(\"/b\", redirectsTo(\"/c\"));\n    app.get(\"/c\", function () {\n      request.abort();\n    });\n\n    return server.start(app)\n      .then(asPromise(function (resolve, reject) {\n        var currentTime = Date.now();\n        request = http.get(\"http://localhost:3600/a\", resolve);\n        assert(request.aborted === false || // Node >= v11.0.0\n               typeof request.aborted === \"undefined\"); // Node < v11.0.0\n        request.on(\"response\", reject);\n        request.on(\"error\", reject);\n        request.on(\"abort\", onAbort);\n        function onAbort() {\n          assert(request.aborted === true || // Node >= v11.0.0\n                 typeof request.aborted === \"number\" &&\n                   request.aborted > currentTime); // Node < v11.0.0\n          request.removeListener(\"error\", reject);\n          request.on(\"error\", noop);\n          resolve();\n        }\n      }));\n  });\n\n  it(\"should provide connection\", function () {\n    var request;\n\n    app.get(\"/a\", sendsJson({}));\n\n    return server.start(app)\n      .then(asPromise(function (resolve) {\n        request = http.get(\"http://localhost:3600/a\", resolve);\n      }))\n      .then(function () {\n        assert(request.connection instanceof net.Socket);\n      });\n  });\n\n  it(\"should provide flushHeaders\", function () {\n    app.get(\"/a\", redirectsTo(\"/b\"));\n    app.get(\"/b\", sendsJson({ foo: \"bar\" }));\n\n    return server.start(app)\n      .then(asPromise(function (resolve, reject) {\n        var request = http.get(\"http://localhost:3600/a\", resolve);\n        request.flushHeaders();\n        request.on(\"error\", reject);\n      }));\n  });\n\n  it(\"should provide getHeader\", function () {\n    var req = http.request(\"http://localhost:3600/a\");\n    req.setHeader(\"my-header\", \"my value\");\n    assert.equal(req.getHeader(\"my-header\"), \"my value\");\n    req.abort();\n  });\n\n  it(\"should provide removeHeader\", function () {\n    app.get(\"/a\", redirectsTo(\"/b\"));\n    app.get(\"/b\", function (req, res) {\n      res.end(JSON.stringify(req.headers));\n    });\n\n    return server.start(app)\n      .then(asPromise(function (resolve, reject) {\n        var req = http.request(\"http://localhost:3600/a\", concatJson(resolve, reject));\n        req.setHeader(\"my-header\", \"my value\");\n        assert.equal(req.getHeader(\"my-header\"), \"my value\");\n        req.removeHeader(\"my-header\");\n        assert.equal(req.getHeader(\"my-header\"), undefined);\n        req.end();\n      }))\n      .then(function (res) {\n        var headers = res.parsedJson;\n        assert.equal(headers[\"my-header\"], undefined);\n      });\n  });\n\n  it(\"should provide setHeader\", function () {\n    app.get(\"/a\", redirectsTo(\"/b\"));\n    app.get(\"/b\", function (req, res) {\n      res.end(JSON.stringify(req.headers));\n    });\n\n    return server.start(app)\n      .then(asPromise(function (resolve, reject) {\n        var req = http.request(\"http://localhost:3600/a\", concatJson(resolve, reject));\n        req.setHeader(\"my-header\", \"my value\");\n        assert.equal(req.getHeader(\"my-header\"), \"my value\");\n        req.end();\n      }))\n      .then(function (res) {\n        var headers = res.parsedJson;\n        assert.equal(headers[\"my-header\"], \"my value\");\n      });\n  });\n\n  it(\"should provide setNoDelay\", function () {\n    app.get(\"/a\", redirectsTo(\"/b\"));\n    app.get(\"/b\", sendsJson({ foo: \"bar\" }));\n\n    return server.start(app)\n      .then(asPromise(function (resolve, reject) {\n        var request = http.get(\"http://localhost:3600/a\", resolve);\n        request.setNoDelay(true);\n        request.on(\"error\", reject);\n      }));\n  });\n\n  it(\"should provide setSocketKeepAlive\", function () {\n    app.get(\"/a\", redirectsTo(\"/b\"));\n    app.get(\"/b\", sendsJson({ foo: \"bar\" }));\n\n    return server.start(app)\n      .then(asPromise(function (resolve) {\n        var request = http.get(\"http://localhost:3600/a\", resolve);\n        request.setSocketKeepAlive(true);\n      }));\n  });\n\n  it(\"should provide setTimeout\", function () {\n    app.get(\"/a\", redirectsTo(\"/b\"));\n    app.get(\"/b\", sendsJson({ foo: \"bar\" }));\n\n    return server.start(app)\n      .then(asPromise(function (resolve) {\n        var request = http.get(\"http://localhost:3600/a\", resolve);\n        request.setTimeout(1000);\n      }));\n  });\n\n  it(\"should provide socket\", function () {\n    var request;\n\n    app.get(\"/a\", sendsJson({}));\n\n    return server.start(app)\n      .then(asPromise(function (resolve) {\n        request = http.get(\"http://localhost:3600/a\", resolve);\n      }))\n      .then(function () {\n        assert(request.socket instanceof net.Socket);\n      });\n  });\n\n  describe(\"should obey a `maxRedirects` property\", function () {\n    beforeEach(function () {\n      var i = 22;\n      while (i > 0) {\n        app.get(\"/r\" + i, redirectsTo(\"/r\" + --i));\n      }\n      app.get(\"/r0\", sendsJson({ foo: \"bar\" }));\n    });\n\n    it(\"which defaults to 21\", function () {\n      return server.start(app)\n        // 21 redirects should work fine\n        .then(asPromise(function (resolve, reject) {\n          http.get(\"http://localhost:3600/r21\", concatJson(resolve, reject)).on(\"error\", reject);\n        }))\n        .then(function (res) {\n          assert.deepEqual(res.parsedJson, { foo: \"bar\" });\n          assert.deepEqual(res.responseUrl, \"http://localhost:3600/r0\");\n        })\n        // 22 redirects should fail\n        .then(asPromise(function (resolve, reject) {\n          http.get(\"http://localhost:3600/r22\", reject).on(\"error\", resolve);\n        }))\n        .then(function (error) {\n          assert(error instanceof Error);\n          assert.equal(error.code, \"ERR_FR_TOO_MANY_REDIRECTS\");\n          assert.equal(error.message, \"Maximum number of redirects exceeded\");\n        });\n    });\n\n    it(\"which can be set globally\", function () {\n      followRedirects.maxRedirects = 22;\n      return server.start(app)\n        .then(asPromise(function (resolve, reject) {\n          http.get(\"http://localhost:3600/r22\", concatJson(resolve, reject)).on(\"error\", reject);\n        }))\n        .then(function (res) {\n          assert.deepEqual(res.parsedJson, { foo: \"bar\" });\n          assert.deepEqual(res.responseUrl, \"http://localhost:3600/r0\");\n        });\n    });\n\n    it(\"set as an option on an individual request\", function () {\n      var u = url.parse(\"http://localhost:3600/r2\");\n      u.maxRedirects = 1;\n\n      return server.start(app)\n        .then(asPromise(function (resolve, reject) {\n          http.get(u, reject).on(\"error\", resolve);\n        }))\n        .then(function (error) {\n          assert(error instanceof Error);\n          assert.equal(error.code, \"ERR_FR_TOO_MANY_REDIRECTS\");\n          assert.equal(error.message, \"Maximum number of redirects exceeded\");\n        });\n    });\n  });\n\n  describe(\"the trackRedirects option\", function () {\n    beforeEach(function () {\n      app.get(\"/a\", redirectsTo(\"/b\"));\n      app.get(\"/b\", redirectsTo(\"/c\"));\n      app.get(\"/c\", sendsJson({}));\n    });\n\n    describe(\"when not set\", function () {\n      it(\"should not track redirects\", function () {\n        return server.start(app)\n          .then(asPromise(function (resolve, reject) {\n            var opts = url.parse(\"http://localhost:3600/a\");\n            http.get(opts, concatJson(resolve, reject)).on(\"error\", reject);\n          }))\n          .then(function (res) {\n            var redirects = res.redirects;\n            assert.equal(redirects.length, 0);\n          });\n      });\n    });\n\n    describe(\"when set to true\", function () {\n      it(\"should track redirects\", function () {\n        return server.start(app)\n          .then(asPromise(function (resolve, reject) {\n            var opts = url.parse(\"http://localhost:3600/a\");\n            opts.trackRedirects = true;\n            http.get(opts, concatJson(resolve, reject)).on(\"error\", reject);\n          }))\n          .then(function (res) {\n            var redirects = res.redirects;\n            assert.equal(redirects.length, 3);\n\n            assert.equal(redirects[0].url, \"http://localhost:3600/a\");\n            assert.equal(redirects[0].statusCode, 302);\n            assert.equal(redirects[0].headers[\"content-type\"], \"text/plain; charset=utf-8\");\n\n            assert.equal(redirects[1].url, \"http://localhost:3600/b\");\n            assert.equal(redirects[1].statusCode, 302);\n            assert.equal(redirects[1].headers[\"content-type\"], \"text/plain; charset=utf-8\");\n\n            assert.equal(redirects[2].url, \"http://localhost:3600/c\");\n            assert.equal(redirects[2].statusCode, 200);\n            assert.equal(redirects[2].headers[\"content-type\"], \"application/json; charset=utf-8\");\n          });\n      });\n    });\n  });\n\n  describe(\"should switch to safe methods when appropriate\", function () {\n    function itChangesMethod(statusCode, postToGet, changeAll) {\n      describe(\"when redirecting with status code \" + statusCode, function () {\n        itRedirectsWith(statusCode, \"GET\", \"GET\");\n        itRedirectsWith(statusCode, \"HEAD\", \"HEAD\");\n        itRedirectsWith(statusCode, \"POST\", postToGet ? \"GET\" : \"POST\");\n        itRedirectsWith(statusCode, \"PUT\", changeAll ? \"GET\" : \"PUT\");\n        itRedirectsWith(statusCode, \"DELETE\", changeAll ? \"GET\" : \"DELETE\");\n      });\n    }\n\n    function itRedirectsWith(statusCode, originalMethod, redirectedMethod) {\n      var description = \"should \" +\n          (originalMethod === redirectedMethod ? \"reuse \" + originalMethod :\n            \"switch from \" + originalMethod + \" to \" + redirectedMethod);\n      it(description, function () {\n        app[originalMethod.toLowerCase()](\"/a\", redirectsTo(statusCode, \"/b\"));\n        app[redirectedMethod.toLowerCase()](\"/b\", sendsJson({ a: \"b\" }));\n\n        return server.start(app)\n          .then(asPromise(function (resolve, reject) {\n            var opts = url.parse(\"http://localhost:3600/a\");\n            opts.method = originalMethod;\n            http.request(opts, resolve).on(\"error\", reject).end();\n          }))\n          .then(function (res) {\n            assert.deepEqual(res.responseUrl, \"http://localhost:3600/b\");\n            if (res.statusCode !== 200) {\n              throw new Error(\"Did not use \" + redirectedMethod);\n            }\n          });\n      });\n    }\n\n    itChangesMethod(300, false);\n    itChangesMethod(301, true);\n    itChangesMethod(302, true);\n    itChangesMethod(303, true, true);\n    itChangesMethod(307, false);\n  });\n\n  describe(\"should handle cross protocol redirects \", function () {\n    it(\"(https -> http -> https)\", function () {\n      app.get(\"/a\", redirectsTo(\"http://localhost:3600/b\"));\n      app2.get(\"/b\", redirectsTo(\"https://localhost:3601/c\"));\n      app.get(\"/c\", sendsJson({ yes: \"no\" }));\n\n      return Promise.all([server.start(httpsOptions(app)), server.start(app2)])\n        .then(asPromise(function (resolve, reject) {\n          var opts = url.parse(\"https://localhost:3601/a\");\n          opts.ca = ca;\n          https.get(opts, concatJson(resolve, reject)).on(\"error\", reject);\n        }))\n        .then(function (res) {\n          assert.deepEqual(res.parsedJson, { yes: \"no\" });\n          assert.deepEqual(res.responseUrl, \"https://localhost:3601/c\");\n        });\n    });\n\n    it(\"(http -> https -> http)\", function () {\n      app.get(\"/a\", redirectsTo(\"https://localhost:3601/b\"));\n      app2.get(\"/b\", redirectsTo(\"http://localhost:3600/c\"));\n      app.get(\"/c\", sendsJson({ hello: \"goodbye\" }));\n\n      return Promise.all([server.start(app), server.start(httpsOptions(app2))])\n        .then(asPromise(function (resolve, reject) {\n          var opts = url.parse(\"http://localhost:3600/a\");\n          opts.ca = ca;\n          http.get(opts, concatJson(resolve, reject)).on(\"error\", reject);\n        }))\n        .then(function (res) {\n          assert.deepEqual(res.parsedJson, { hello: \"goodbye\" });\n          assert.deepEqual(res.responseUrl, \"http://localhost:3600/c\");\n        });\n    });\n  });\n\n  describe(\"should error on an unsupported protocol redirect\", function () {\n    it(\"(http -> about)\", function () {\n      app.get(\"/a\", redirectsTo(\"about:blank\"));\n\n      return server.start(app)\n        .then(asPromise(function (resolve, reject) {\n          http.get(\"http://localhost:3600/a\")\n            .on(\"response\", function () { return reject(new Error(\"unexpected response\")); })\n            .on(\"error\", reject);\n        }))\n        .catch(function (error) {\n          assert(error instanceof Error);\n          assert(error instanceof TypeError);\n          assert.equal(error.message, \"Unsupported protocol about:\");\n        });\n    });\n  });\n\n  it(\"should wait for an explicit call to end\", function () {\n    var redirected = false;\n    app.post(\"/a\", redirectsTo(307, \"http://localhost:3600/b\"));\n    app.post(\"/b\", redirectsTo(307, \"http://localhost:3600/c\"));\n    app.post(\"/c\", redirectsTo(307, \"http://localhost:3600/d\"));\n    app.post(\"/d\", function (req, res) {\n      redirected = true;\n      req.pipe(res);\n    });\n\n    var req;\n\n    return server.start(app)\n      .then(asPromise(function (resolve, reject) {\n        req = http.request(\"http://localhost:3600/a\", { method: \"POST\" }, resolve);\n        req.write(testFileString);\n        req.on(\"error\", reject);\n      }))\n      .then(asPromise(function (resolve, reject, res) {\n        assert(redirected);\n        // If we can still write to the request, it wasn't closed yet\n        req.write(testFileString);\n        req.end();\n        res.pipe(concat({ encoding: \"string\" }, resolve)).on(\"error\", reject);\n      }))\n      .then(function (str) {\n        assert.equal(str, testFileString + testFileString);\n      });\n  });\n\n  it(\"errors on write after end\", function () {\n    app.post(\"/a\", function (req, res) {\n      req.pipe(res);\n    });\n\n    return server.start(app)\n      .then(function () {\n        var req = http.request(\"http://localhost:3600/a\", { method: \"POST\" });\n        req.write(testFileString);\n        req.end();\n        try {\n          req.write(testFileString);\n        }\n        catch (error) {\n          assert(error instanceof Error);\n          assert.equal(error.code, \"ERR_STREAM_WRITE_AFTER_END\");\n          assert.equal(error.message, \"write after end\");\n          return;\n        }\n        finally {\n          req.abort();\n        }\n        throw new Error(\"no error\");\n      });\n  });\n\n  it(\"should support writing into request stream without redirects\", function () {\n    app.post(\"/a\", function (req, res) {\n      req.pipe(res);\n    });\n\n    return server.start(app)\n      .then(asPromise(function (resolve, reject) {\n        var req = http.request(\"http://localhost:3600/a\", { method: \"POST\" }, resolve);\n        req.end(testFileBuffer, \"buffer\");\n        req.on(\"error\", reject);\n      }))\n      .then(asPromise(function (resolve, reject, res) {\n        assert.deepEqual(res.responseUrl, \"http://localhost:3600/a\");\n        res.pipe(concat({ encoding: \"string\" }, resolve)).on(\"error\", reject);\n      }))\n      .then(function (str) {\n        assert.equal(str, testFileString);\n      });\n  });\n\n  it(\"should support writing into request stream with redirects\", function () {\n    app.post(\"/a\", redirectsTo(307, \"http://localhost:3600/b\"));\n    app.post(\"/b\", redirectsTo(307, \"http://localhost:3600/c\"));\n    app.post(\"/c\", redirectsTo(307, \"http://localhost:3600/d\"));\n    app.post(\"/d\", function (req, res) {\n      req.pipe(res);\n    });\n\n    return server.start(app)\n      .then(asPromise(function (resolve, reject) {\n        var req = http.request(\"http://localhost:3600/a\", { method: \"POST\" }, resolve);\n        req.end(testFileBuffer, \"buffer\");\n        req.on(\"error\", reject);\n      }))\n      .then(asPromise(function (resolve, reject, res) {\n        res.pipe(concat({ encoding: \"string\" }, resolve)).on(\"error\", reject);\n      }))\n      .then(function (str) {\n        assert.equal(str, testFileString);\n      });\n  });\n\n  it(\"should support piping into request stream without redirects\", function () {\n    app.post(\"/a\", function (req, res) {\n      req.pipe(res);\n    });\n\n    return server.start(app)\n      .then(asPromise(function (resolve, reject) {\n        var req = http.request(\"http://localhost:3600/a\", { method: \"POST\" }, resolve);\n        fs.createReadStream(testFile).pipe(req);\n        req.on(\"error\", reject);\n      }))\n      .then(asPromise(function (resolve, reject, res) {\n        assert.deepEqual(res.responseUrl, \"http://localhost:3600/a\");\n        res.pipe(concat({ encoding: \"string\" }, resolve)).on(\"error\", reject);\n      }))\n      .then(function (str) {\n        assert.equal(str, testFileString);\n      });\n  });\n\n  it(\"should support piping into request stream with redirects\", function () {\n    app.post(\"/a\", redirectsTo(307, \"http://localhost:3600/b\"));\n    app.post(\"/b\", redirectsTo(307, \"http://localhost:3600/c\"));\n    app.post(\"/c\", redirectsTo(307, \"http://localhost:3600/d\"));\n    app.post(\"/d\", function (req, res) {\n      req.pipe(res);\n    });\n\n    return server.start(app)\n      .then(asPromise(function (resolve, reject) {\n        var req = http.request(\"http://localhost:3600/a\", { method: \"POST\" }, resolve);\n        fs.createReadStream(testFile).pipe(req);\n        req.on(\"error\", reject);\n      }))\n      .then(asPromise(function (resolve, reject, res) {\n        res.pipe(concat({ encoding: \"string\" }, resolve)).on(\"error\", reject);\n      }))\n      .then(function (str) {\n        assert.equal(str, testFileString);\n      });\n  });\n\n  it(\"should support piping into request stream with explicit Content-Length without redirects\", function () {\n    app.post(\"/a\", function (req, res) {\n      req.pipe(res);\n    });\n\n    var opts = url.parse(\"http://localhost:3600/a\");\n    opts.method = \"POST\";\n    opts.headers = {\n      \"Content-Length\": testFileBuffer.byteLength,\n    };\n\n    return server.start(app)\n      .then(asPromise(function (resolve, reject) {\n        var req = http.request(opts, resolve);\n        fs.createReadStream(testFile).pipe(req);\n        req.on(\"error\", reject);\n      }))\n      .then(asPromise(function (resolve, reject, res) {\n        assert.deepEqual(res.responseUrl, \"http://localhost:3600/a\");\n        res.pipe(concat({ encoding: \"string\" }, resolve)).on(\"error\", reject);\n      }))\n      .then(function (str) {\n        assert.equal(str, testFileString);\n      });\n  });\n\n  it(\"should support piping into request stream with explicit Content-Length with redirects\", function () {\n    app.post(\"/a\", redirectsTo(307, \"http://localhost:3600/b\"));\n    app.post(\"/b\", redirectsTo(307, \"http://localhost:3600/c\"));\n    app.post(\"/c\", redirectsTo(307, \"http://localhost:3600/d\"));\n    app.post(\"/d\", function (req, res) {\n      req.pipe(res);\n    });\n\n    var opts = url.parse(\"http://localhost:3600/a\");\n    opts.method = \"POST\";\n    opts.headers = {\n      \"Content-Length\": testFileBuffer.byteLength,\n    };\n\n    return server.start(app)\n      .then(asPromise(function (resolve, reject) {\n        var req = http.request(opts, resolve);\n        fs.createReadStream(testFile).pipe(req);\n        req.on(\"error\", reject);\n      }))\n      .then(asPromise(function (resolve, reject, res) {\n        res.pipe(concat({ encoding: \"string\" }, resolve)).on(\"error\", reject);\n      }))\n      .then(function (str) {\n        assert.equal(str, testFileString);\n      });\n  });\n\n  describe(\"should obey a `maxBodyLength` property\", function () {\n    it(\"which defaults to 10MB\", function () {\n      assert.equal(followRedirects.maxBodyLength, 10 * 1024 * 1024);\n    });\n\n    it(\"set globally, on write\", function () {\n      app.post(\"/a\", function (req, res) {\n        req.pipe(res);\n      });\n\n      followRedirects.maxBodyLength = 8;\n      return server.start(app)\n        .then(asPromise(function (resolve, reject) {\n          var req = http.request(\"http://localhost:3600/a\", { method: \"POST\" }, reject);\n          req.write(\"12345678\");\n          req.on(\"error\", resolve);\n          req.write(\"9\");\n        }))\n        .then(function (error) {\n          assert.equal(error.message, \"Request body larger than maxBodyLength limit\");\n        });\n    });\n\n    it(\"set per request, on write\", function () {\n      app.post(\"/a\", function (req, res) {\n        req.pipe(res);\n      });\n      var opts = url.parse(\"http://localhost:3600/a\");\n      opts.method = \"POST\";\n      opts.maxBodyLength = 8;\n\n      return server.start(app)\n        .then(asPromise(function (resolve, reject) {\n          var req = http.request(opts, reject);\n          req.write(\"12345678\");\n          req.on(\"error\", resolve);\n          req.write(\"9\");\n        }))\n        .then(function (error) {\n          assert(error instanceof Error);\n          assert.equal(error.code, \"ERR_FR_MAX_BODY_LENGTH_EXCEEDED\");\n          assert.equal(error.message, \"Request body larger than maxBodyLength limit\");\n        });\n    });\n\n    it(\"set globally, on end\", function () {\n      app.post(\"/a\", function (req, res) {\n        req.pipe(res);\n      });\n\n      followRedirects.maxBodyLength = 8;\n      return server.start(app)\n        .then(asPromise(function (resolve, reject) {\n          var req = http.request(\"http://localhost:3600/a\", { method: \"POST\" }, reject);\n          req.write(\"12345678\");\n          req.on(\"error\", resolve);\n          req.end(\"9\");\n        }))\n        .then(function (error) {\n          assert(error instanceof Error);\n          assert.equal(error.code, \"ERR_FR_MAX_BODY_LENGTH_EXCEEDED\");\n          assert.equal(error.message, \"Request body larger than maxBodyLength limit\");\n        });\n    });\n\n    it(\"set per request, on end\", function () {\n      app.post(\"/a\", function (req, res) {\n        req.pipe(res);\n      });\n      var opts = url.parse(\"http://localhost:3600/a\");\n      opts.method = \"POST\";\n      opts.maxBodyLength = 8;\n\n      return server.start(app)\n        .then(asPromise(function (resolve, reject) {\n          var req = http.request(opts, reject);\n          req.write(\"12345678\");\n          req.on(\"error\", resolve);\n          req.end(\"9\");\n        }))\n        .then(function (error) {\n          assert(error instanceof Error);\n          assert.equal(error.code, \"ERR_FR_MAX_BODY_LENGTH_EXCEEDED\");\n          assert.equal(error.message, \"Request body larger than maxBodyLength limit\");\n        });\n    });\n  });\n\n  describe(\"writing invalid data\", function () {\n    it(\"throws an error\", function () {\n      var req = http.request(\"http://example.org/\");\n      var error = null;\n      try {\n        req.write(12345678);\n      }\n      catch (e) {\n        error = e;\n      }\n      req.abort();\n      assert(error instanceof Error);\n      assert(error instanceof TypeError);\n      assert.equal(error.message, \"data should be a string, Buffer or Uint8Array\");\n    });\n  });\n\n  describe(\"when switching from POST to GET\", function () {\n    it(\"should drop the entity and associated headers\", function () {\n      app.post(\"/a\", redirectsTo(302, \"http://localhost:3600/b\"));\n      app.get(\"/b\", function (req, res) {\n        res.write(JSON.stringify(req.headers));\n        req.pipe(res); // will invalidate JSON if non-empty\n      });\n\n      var opts = url.parse(\"http://localhost:3600/a\");\n      opts.method = \"POST\";\n      opts.headers = {\n        \"other\": \"value\",\n        \"content-type\": \"application/javascript\",\n        \"Content-Length\": testFileBuffer.byteLength,\n      };\n\n      return server.start(app)\n        .then(asPromise(function (resolve, reject) {\n          var req = http.request(opts, resolve);\n          fs.createReadStream(testFile).pipe(req);\n          req.on(\"error\", reject);\n        }))\n        .then(asPromise(function (resolve, reject, res) {\n          res.pipe(concat({ encoding: \"string\" }, resolve)).on(\"error\", reject);\n        }))\n        .then(function (str) {\n          var body = JSON.parse(str);\n          assert.equal(body.host, \"localhost:3600\");\n          assert.equal(body.other, \"value\");\n          assert.equal(body[\"content-type\"], undefined);\n          assert.equal(body[\"content-length\"], undefined);\n        });\n    });\n  });\n\n  describe(\"when redirecting to a different host while the host header is set\", function () {\n    it(\"uses the new host header if redirect host is different\", function () {\n      app.get(\"/a\", redirectsTo(302, \"http://localhost:3600/b\"));\n      app.get(\"/b\", function (req, res) {\n        res.write(JSON.stringify(req.headers));\n        req.pipe(res); // will invalidate JSON if non-empty\n      });\n\n      return server.start(app)\n        .then(asPromise(function (resolve, reject) {\n          var opts = url.parse(\"http://localhost:3600/a\");\n          opts.headers = { hOsT: \"otherhost.com\" };\n          http.get(opts, resolve).on(\"error\", reject);\n        }))\n        .then(asPromise(function (resolve, reject, res) {\n          assert.deepEqual(res.statusCode, 200);\n          assert.deepEqual(res.responseUrl, \"http://localhost:3600/b\");\n          res.pipe(concat({ encoding: \"string\" }, resolve)).on(\"error\", reject);\n        }))\n        .then(function (str) {\n          var body = JSON.parse(str);\n          assert.equal(body.host, \"localhost:3600\");\n        });\n    });\n\n    it(\"uses the location host if redirect host is the same\", function () {\n      app.get(\"/a\", redirectsTo(302, \"http://localhost:3600/b\"));\n      app.get(\"/b\", function (req, res) {\n        res.write(JSON.stringify(req.headers));\n        req.pipe(res); // will invalidate JSON if non-empty\n      });\n\n      return server.start(app)\n        .then(asPromise(function (resolve, reject) {\n          var opts = url.parse(\"http://127.0.0.1:3600/a\");\n          opts.headers = { hOsT: \"localhost:3600\" };\n          http.get(opts, resolve).on(\"error\", reject);\n        }))\n        .then(asPromise(function (resolve, reject, res) {\n          assert.deepEqual(res.statusCode, 200);\n          assert.deepEqual(res.responseUrl, \"http://localhost:3600/b\");\n          res.pipe(concat({ encoding: \"string\" }, resolve)).on(\"error\", reject);\n        }))\n        .then(function (str) {\n          var body = JSON.parse(str);\n          assert.equal(body.host, \"localhost:3600\");\n        });\n    });\n\n    it(\"uses the existing host header if redirect host is relative\", function () {\n      app.get(\"/a\", redirectsTo(302, \"/b\"));\n      app.get(\"/b\", function (req, res) {\n        res.write(JSON.stringify(req.headers));\n        req.pipe(res); // will invalidate JSON if non-empty\n      });\n\n      return server.start(app)\n        .then(asPromise(function (resolve, reject) {\n          var opts = url.parse(\"http://127.0.0.1:3600/a\");\n          opts.headers = { hOsT: \"localhost:3600\" };\n          http.get(opts, resolve).on(\"error\", reject);\n        }))\n        .then(asPromise(function (resolve, reject, res) {\n          assert.deepEqual(res.statusCode, 200);\n          assert.deepEqual(res.responseUrl, \"http://localhost:3600/b\");\n          res.pipe(concat({ encoding: \"string\" }, resolve)).on(\"error\", reject);\n        }))\n        .then(function (str) {\n          var body = JSON.parse(str);\n          assert.equal(body.host, \"localhost:3600\");\n        });\n    });\n  });\n\n  [\n    \"Authorization\",\n    \"Cookie\",\n  ].forEach(function (header) {\n    describe(\"when the client passes an header named \" + header, function () {\n      it(\"ignores it when null\", function () {\n        app.get(\"/a\", redirectsTo(302, \"http://localhost:3600/b\"));\n        app.get(\"/b\", function (req, res) {\n          res.end(JSON.stringify(req.headers));\n        });\n\n        var opts = url.parse(\"http://127.0.0.1:3600/a\");\n        opts.headers = { host: \"localhost\" };\n        opts.headers[header] = null;\n\n        return server.start(app)\n          .then(asPromise(function (resolve, reject) {\n            http.get(opts, resolve).on(\"error\", reject);\n          }))\n          .then(asPromise(function (resolve, reject, res) {\n            res.pipe(concat({ encoding: \"string\" }, resolve)).on(\"error\", reject);\n          }))\n          .then(function (str) {\n            var body = JSON.parse(str);\n            assert.equal(body.host, \"localhost:3600\");\n            assert.equal(body[header.toLowerCase()], undefined);\n          });\n      });\n\n      it(\"keeps the header when redirected to the same host\", function () {\n        app.get(\"/a\", redirectsTo(302, \"/b\"));\n        app.get(\"/b\", function (req, res) {\n          res.end(JSON.stringify(req.headers));\n        });\n\n        var opts = url.parse(\"http://localhost:3600/a\");\n        opts.headers = {};\n        opts.headers[header] = \"the header value\";\n\n        return server.start(app)\n          .then(asPromise(function (resolve, reject) {\n            http.get(opts, resolve).on(\"error\", reject);\n          }))\n          .then(asPromise(function (resolve, reject, res) {\n            res.pipe(concat({ encoding: \"string\" }, resolve)).on(\"error\", reject);\n          }))\n          .then(function (str) {\n            var body = JSON.parse(str);\n            assert.equal(body.host, \"localhost:3600\");\n            assert.equal(body[header.toLowerCase()], \"the header value\");\n          });\n      });\n\n      it(\"keeps the header when redirected to the same host via header\", function () {\n        app.get(\"/a\", redirectsTo(302, \"http://localhost:3600/b\"));\n        app.get(\"/b\", function (req, res) {\n          res.end(JSON.stringify(req.headers));\n        });\n\n        var opts = url.parse(\"http://127.0.0.1:3600/a\");\n        opts.headers = { host: \"localhost:3600\" };\n        opts.headers[header] = \"the header value\";\n\n        return server.start(app)\n          .then(asPromise(function (resolve, reject) {\n            http.get(opts, resolve).on(\"error\", reject);\n          }))\n          .then(asPromise(function (resolve, reject, res) {\n            res.pipe(concat({ encoding: \"string\" }, resolve)).on(\"error\", reject);\n          }))\n          .then(function (str) {\n            var body = JSON.parse(str);\n            assert.equal(body.host, \"localhost:3600\");\n            assert.equal(body[header.toLowerCase()], \"the header value\");\n          });\n      });\n\n      it(\"keeps the header when redirected to the same host via header\", function () {\n        app.get(\"/a\", redirectsTo(302, \"http://localhost:3600/b\"));\n        app.get(\"/b\", function (req, res) {\n          res.end(JSON.stringify(req.headers));\n        });\n\n        var opts = url.parse(\"http://127.0.0.1:3600/a\");\n        opts.headers = { host: \"localhost:3600\" };\n        opts.headers[header] = \"the header value\";\n\n        return server.start(app)\n          .then(asPromise(function (resolve, reject) {\n            http.get(opts, resolve).on(\"error\", reject);\n          }))\n          .then(asPromise(function (resolve, reject, res) {\n            res.pipe(concat({ encoding: \"string\" }, resolve)).on(\"error\", reject);\n          }))\n          .then(function (str) {\n            var body = JSON.parse(str);\n            assert.equal(body.host, \"localhost:3600\");\n            assert.equal(body[header.toLowerCase()], \"the header value\");\n          });\n      });\n\n      it(\"keeps the header when redirected to a subdomain\", function () {\n        app.get(\"/a\", redirectsTo(302, \"http://sub.localhost:3600/b\"));\n        app.get(\"/b\", function (req, res) {\n          res.end(JSON.stringify(req.headers));\n        });\n\n        var opts = url.parse(\"http://localhost:3600/a\");\n        opts.headers = {};\n        opts.headers[header] = \"the header value\";\n\n        // Intercept the hostname, as no DNS entry is defined for it\n        opts.beforeRedirect = function (options) {\n          assert.equal(options.hostname, \"sub.localhost\");\n          options.hostname = \"localhost\";\n        };\n\n        return server.start(app)\n          .then(asPromise(function (resolve, reject) {\n            http.get(opts, resolve).on(\"error\", reject);\n          }))\n          .then(asPromise(function (resolve, reject, res) {\n            res.pipe(concat({ encoding: \"string\" }, resolve)).on(\"error\", reject);\n          }))\n          .then(function (str) {\n            var body = JSON.parse(str);\n            assert.equal(body.host, \"localhost:3600\");\n            assert.equal(body[header.toLowerCase()], \"the header value\");\n          });\n      });\n\n      it(\"drops the header when redirected to a different host (same hostname and different port)\", function () {\n        app.get(\"/a\", redirectsTo(302, \"http://localhost:3600/b\"));\n        app.get(\"/b\", function (req, res) {\n          res.end(JSON.stringify(req.headers));\n        });\n\n        var opts = url.parse(\"http://127.0.0.1:3600/a\");\n        opts.headers = { host: \"localhost\" };\n        opts.headers[header] = \"the header value\";\n\n        return server.start(app)\n          .then(asPromise(function (resolve, reject) {\n            http.get(opts, resolve).on(\"error\", reject);\n          }))\n          .then(asPromise(function (resolve, reject, res) {\n            res.pipe(concat({ encoding: \"string\" }, resolve)).on(\"error\", reject);\n          }))\n          .then(function (str) {\n            var body = JSON.parse(str);\n            assert.equal(body.host, \"localhost:3600\");\n            assert.equal(body[header.toLowerCase()], undefined);\n          });\n      });\n\n      it(\"drops the header when redirected to a different host\", function () {\n        app.get(\"/a\", redirectsTo(302, \"http://127.0.0.1:3600/b\"));\n        app.get(\"/b\", function (req, res) {\n          res.end(JSON.stringify(req.headers));\n        });\n\n        var opts = url.parse(\"http://localhost:3600/a\");\n        opts.headers = {};\n        opts.headers[header] = \"the header value\";\n\n        return server.start(app)\n          .then(asPromise(function (resolve, reject) {\n            http.get(opts, resolve).on(\"error\", reject);\n          }))\n          .then(asPromise(function (resolve, reject, res) {\n            res.pipe(concat({ encoding: \"string\" }, resolve)).on(\"error\", reject);\n          }))\n          .then(function (str) {\n            var body = JSON.parse(str);\n            assert.equal(body.host, \"127.0.0.1:3600\");\n            assert.equal(body[header.toLowerCase()], undefined);\n          });\n      });\n\n      it(\"drops the header when redirected from a different host via header\", function () {\n        app.get(\"/a\", redirectsTo(302, \"http://127.0.0.1:3600/b\"));\n        app.get(\"/b\", function (req, res) {\n          res.end(JSON.stringify(req.headers));\n        });\n\n        var opts = url.parse(\"http://127.0.0.1:3600/a\");\n        opts.headers = { host: \"localhost\" };\n        opts.headers[header] = \"the header value\";\n\n        return server.start(app)\n          .then(asPromise(function (resolve, reject) {\n            http.get(opts, resolve).on(\"error\", reject);\n          }))\n          .then(asPromise(function (resolve, reject, res) {\n            res.pipe(concat({ encoding: \"string\" }, resolve)).on(\"error\", reject);\n          }))\n          .then(function (str) {\n            var body = JSON.parse(str);\n            assert.equal(body.host, \"127.0.0.1:3600\");\n            assert.equal(body[header.toLowerCase()], undefined);\n          });\n      });\n    });\n  });\n\n  describe(\"when the followRedirects option is set to false\", function () {\n    it(\"does not redirect\", function () {\n      app.get(\"/a\", redirectsTo(302, \"/b\"));\n      app.get(\"/b\", sendsJson({ a: \"b\" }));\n\n      return server.start(app)\n        .then(asPromise(function (resolve, reject) {\n          var opts = url.parse(\"http://localhost:3600/a\");\n          opts.followRedirects = false;\n          http.get(opts, resolve).on(\"error\", reject);\n        }))\n        .then(function (res) {\n          assert.deepEqual(res.statusCode, 302);\n          assert.deepEqual(res.responseUrl, \"http://localhost:3600/a\");\n        });\n    });\n  });\n\n  describe(\"should choose the right agent per protocol\", function () {\n    it(\"(https -> http -> https)\", function () {\n      app.get(\"/a\", redirectsTo(\"http://localhost:3600/b\"));\n      app2.get(\"/b\", redirectsTo(\"https://localhost:3601/c\"));\n      app.get(\"/c\", sendsJson({ yes: \"no\" }));\n\n      var httpAgent = addRequestLogging(new http.Agent());\n      var httpsAgent = addRequestLogging(new https.Agent());\n      function addRequestLogging(agent) {\n        agent._requests = [];\n        agent._addRequest = agent.addRequest;\n        agent.addRequest = function (request, options) {\n          this._requests.push(options.path);\n          this._addRequest(request, options);\n        };\n        return agent;\n      }\n\n      return Promise.all([server.start(httpsOptions(app)), server.start(app2)])\n        .then(asPromise(function (resolve, reject) {\n          var opts = url.parse(\"https://localhost:3601/a\");\n          opts.ca = ca;\n          opts.agents = { http: httpAgent, https: httpsAgent };\n          https.get(opts, concatJson(resolve, reject)).on(\"error\", reject);\n        }))\n        .then(function (res) {\n          assert.deepEqual(httpAgent._requests, [\"/b\"]);\n          assert.deepEqual(httpsAgent._requests, [\"/a\", \"/c\"]);\n          assert.deepEqual(res.parsedJson, { yes: \"no\" });\n          assert.deepEqual(res.responseUrl, \"https://localhost:3601/c\");\n        });\n    });\n  });\n\n  describe(\"should not hang on empty writes\", function () {\n    it(\"when data is the empty string without encoding\", function () {\n      app.post(\"/a\", sendsJson({ foo: \"bar\" }));\n\n      return server.start(app)\n        .then(asPromise(function (resolve, reject) {\n          var req = http.request(\"http://localhost:3600/a\", { method: \"POST\" }, resolve);\n          req.write(\"\");\n          req.write(\"\", function () {\n            req.end(\"\");\n          });\n          req.on(\"error\", reject);\n        }))\n        .then(asPromise(function (resolve, reject, res) {\n          assert.deepEqual(res.responseUrl, \"http://localhost:3600/a\");\n          res.pipe(concat({ encoding: \"string\" }, resolve)).on(\"error\", reject);\n        }));\n    });\n\n    it(\"when data is the empty string with encoding\", function () {\n      app.post(\"/a\", sendsJson({ foo: \"bar\" }));\n\n      return server.start(app)\n        .then(asPromise(function (resolve, reject) {\n          var req = http.request(\"http://localhost:3600/a\", { method: \"POST\" }, resolve);\n          req.write(\"\");\n          req.write(\"\", \"utf8\", function () {\n            req.end(\"\", \"utf8\");\n          });\n          req.on(\"error\", reject);\n        }))\n        .then(asPromise(function (resolve, reject, res) {\n          assert.deepEqual(res.responseUrl, \"http://localhost:3600/a\");\n          res.pipe(concat({ encoding: \"string\" }, resolve)).on(\"error\", reject);\n        }));\n    });\n\n    it(\"when data is Buffer.from('')\", function () {\n      app.post(\"/a\", sendsJson({ foo: \"bar\" }));\n\n      return server.start(app)\n        .then(asPromise(function (resolve, reject) {\n          var req = http.request(\"http://localhost:3600/a\", { method: \"POST\" }, resolve);\n          req.write(Buffer.from(\"\"));\n          req.write(Buffer.from(\"\"), function () {\n            req.end(Buffer.from(\"\"));\n          });\n          req.on(\"error\", reject);\n        }))\n        .then(asPromise(function (resolve, reject, res) {\n          assert.deepEqual(res.responseUrl, \"http://localhost:3600/a\");\n          res.pipe(concat({ encoding: \"string\" }, resolve)).on(\"error\", reject);\n        }));\n    });\n  });\n\n  describe(\"end accepts as arguments\", function () {\n    var called;\n    function setCalled() {\n      called = true;\n    }\n\n    beforeEach(function () {\n      app.post(\"/a\", function (req, res) {\n        req.pipe(res);\n      });\n      called = false;\n    });\n\n\n    it(\"(none)\", function () {\n      return server.start(app)\n        .then(asPromise(function (resolve) {\n          var req = http.request(\"http://localhost:3600/a\", { method: \"POST\" }, resolve);\n          req.end();\n        }))\n        .then(asPromise(function (resolve, reject, res) {\n          res.pipe(concat({ encoding: \"string\" }, resolve));\n        }))\n        .then(function (body) {\n          assert.equal(body, \"\");\n        });\n    });\n\n    it(\"the empty string\", function () {\n      return server.start(app)\n        .then(asPromise(function (resolve) {\n          var req = http.request(\"http://localhost:3600/a\", { method: \"POST\" }, resolve);\n          req.end(\"\");\n        }))\n        .then(asPromise(function (resolve, reject, res) {\n          res.pipe(concat({ encoding: \"string\" }, resolve));\n        }))\n        .then(function (body) {\n          assert.equal(body, \"\");\n        });\n    });\n\n    it(\"a non-empty string\", function () {\n      return server.start(app)\n        .then(asPromise(function (resolve) {\n          var req = http.request(\"http://localhost:3600/a\", { method: \"POST\" }, resolve);\n          req.end(\"abc\");\n        }))\n        .then(asPromise(function (resolve, reject, res) {\n          res.pipe(concat({ encoding: \"string\" }, resolve));\n        }))\n        .then(function (body) {\n          assert.equal(body, \"abc\");\n        });\n    });\n\n    it(\"a non-empty string and an encoding\", function () {\n      return server.start(app)\n        .then(asPromise(function (resolve) {\n          var req = http.request(\"http://localhost:3600/a\", { method: \"POST\" }, resolve);\n          req.end(\"abc\", \"utf8\");\n        }))\n        .then(asPromise(function (resolve, reject, res) {\n          res.pipe(concat({ encoding: \"string\" }, resolve));\n        }))\n        .then(function (body) {\n          assert.equal(body, \"abc\");\n        });\n    });\n\n    it(\"a non-empty string, an encoding, and a callback\", function () {\n      return server.start(app)\n        .then(asPromise(function (resolve) {\n          var req = http.request(\"http://localhost:3600/a\", { method: \"POST\" }, resolve);\n          req.end(\"abc\", \"utf8\", setCalled);\n        }))\n        .then(asPromise(function (resolve, reject, res) {\n          res.pipe(concat({ encoding: \"string\" }, resolve));\n        }))\n        .then(function (body) {\n          assert.equal(body, \"abc\");\n          assert.equal(called, true);\n        });\n    });\n\n    it(\"a non-empty string and a callback\", function () {\n      return server.start(app)\n        .then(asPromise(function (resolve) {\n          var req = http.request(\"http://localhost:3600/a\", { method: \"POST\" }, resolve);\n          req.end(\"abc\", setCalled);\n        }))\n        .then(asPromise(function (resolve, reject, res) {\n          res.pipe(concat({ encoding: \"string\" }, resolve));\n        }))\n        .then(function (body) {\n          assert.equal(body, \"abc\");\n          assert.equal(called, true);\n        });\n    });\n\n    it(\"a callback\", function () {\n      return server.start(app)\n        .then(asPromise(function (resolve) {\n          var req = http.request(\"http://localhost:3600/a\", { method: \"POST\" }, resolve);\n          req.end(setCalled);\n        }))\n        .then(asPromise(function (resolve, reject, res) {\n          res.pipe(concat({ encoding: \"string\" }, resolve));\n        }))\n        .then(function (body) {\n          assert.equal(body, \"\");\n          assert.equal(called, true);\n        });\n    });\n  });\n\n  describe(\"change request options before redirects\", function () {\n    it(\"only call beforeRedirect on redirects, not the inital http call\", function () {\n      app.get(\"/a\", sendsJson({ a: \"b\" }));\n\n      return server.start(app)\n        .then(asPromise(function (resolve, reject) {\n          var options = {\n            host: \"localhost\",\n            port: 3600,\n            path: \"/a\",\n            method: \"GET\",\n            beforeRedirect: function () {\n              assert.fail(\"this should only be called on redirects\");\n            },\n          };\n          http.get(options, concatJson(resolve, reject)).on(\"error\", reject);\n        }))\n        .then(function (res) {\n          assert.deepEqual(res.parsedJson, { a: \"b\" });\n          assert.deepEqual(res.responseUrl, \"http://localhost:3600/a\");\n        });\n    });\n\n    it(\"ignore beforeRedirect if not a function\", function () {\n      app.get(\"/a\", redirectsTo(\"/b\"));\n      app.get(\"/b\", redirectsTo(\"/c\"));\n      app.get(\"/c\", sendsJson({ a: \"b\" }));\n\n      return server.start(app)\n        .then(asPromise(function (resolve, reject) {\n          var options = {\n            host: \"localhost\",\n            port: 3600,\n            path: \"/a\",\n            method: \"GET\",\n            beforeRedirect: 42,\n          };\n          http.get(options, concatJson(resolve, reject)).on(\"error\", reject);\n        }))\n        .then(function (res) {\n          assert.deepEqual(res.parsedJson, { a: \"b\" });\n          assert.deepEqual(res.responseUrl, \"http://localhost:3600/c\");\n        });\n    });\n\n    it(\"append new header with every redirect\", function () {\n      app.get(\"/a\", redirectsTo(\"/b\"));\n      app.get(\"/b\", redirectsTo(\"/c\"));\n      app.get(\"/c\", function (req, res) {\n        res.json(req.headers);\n      });\n      var callsToTransform = 0;\n\n      return server.start(app)\n        .then(asPromise(function (resolve, reject) {\n          var options = {\n            host: \"localhost\",\n            port: 3600,\n            path: \"/a\",\n            method: \"GET\",\n            beforeRedirect: function (optionz) {\n              callsToTransform++;\n              if (optionz.path === \"/b\") {\n                optionz.headers[\"header-a\"] = \"value A\";\n              }\n              else if (optionz.path === \"/c\") {\n                optionz.headers[\"header-b\"] = \"value B\";\n              }\n            },\n          };\n          http.get(options, concatJson(resolve, reject)).on(\"error\", reject);\n        }))\n        .then(function (res) {\n          assert.strictEqual(callsToTransform, 2);\n          assert.strictEqual(res.parsedJson[\"header-a\"], \"value A\");\n          assert.strictEqual(res.parsedJson[\"header-b\"], \"value B\");\n          assert.deepEqual(res.responseUrl, \"http://localhost:3600/c\");\n        });\n    });\n\n    it(\"abort request chain after throwing an error\", function () {\n      var redirected = false;\n      app.get(\"/a\", redirectsTo(\"/b\"));\n      app.get(\"/b\", function () {\n        redirected = true;\n        throw new Error(\"redirected request should have been aborted\");\n      });\n\n      return server.start(app)\n        .then(asPromise(function (resolve, reject) {\n          var options = {\n            host: \"localhost\",\n            port: 3600,\n            path: \"/a\",\n            method: \"GET\",\n            beforeRedirect: function () {\n              throw new Error(\"no redirects!\");\n            },\n          };\n          http.get(options, concatJson(resolve, reject)).on(\"error\", reject);\n        }))\n        .then(function () {\n          assert.fail(\"request chain should have been aborted\");\n        })\n        .catch(function (error) {\n          assert(!redirected);\n          assert(error instanceof Error);\n          assert.equal(error.message, \"no redirects!\");\n        });\n    });\n\n    it(\"access response header in beforeRedirect\", function () {\n      app.get(\"/a\", redirectsTo(\"/b\"));\n      app.get(\"/b\", function (req, res) {\n        res.json(req.headers);\n      });\n\n      return server.start(app)\n        .then(asPromise(function (resolve, reject) {\n          var options = {\n            host: \"localhost\",\n            port: 3600,\n            path: \"/a\",\n            method: \"GET\",\n            beforeRedirect: function (optionz, response) {\n              optionz.headers.testheader = \"itsAtest\" + response.headers.location;\n            },\n          };\n          http.get(options, concatJson(resolve, reject)).on(\"error\", reject);\n        }))\n        .then(function (res) {\n          assert.strictEqual(res.parsedJson.testheader, \"itsAtest/b\");\n          assert.deepEqual(res.responseUrl, \"http://localhost:3600/b\");\n        });\n    });\n  });\n});\n\nfunction noop() { /* noop */ }\n"], "filenames": ["index.js", "test/test.js"], "buggy_code_start_loc": [395, 1322], "buggy_code_end_loc": [398, 1531], "fixing_code_start_loc": [395, 1322], "fixing_code_end_loc": [398, 1524], "type": "CWE-359", "message": "follow-redirects is vulnerable to Exposure of Private Personal Information to an Unauthorized Actor", "other": {"cve": {"id": "CVE-2022-0155", "sourceIdentifier": "security@huntr.dev", "published": "2022-01-10T20:15:08.177", "lastModified": "2022-10-28T17:54:29.403", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "follow-redirects is vulnerable to Exposure of Private Personal Information to an Unauthorized Actor"}, {"lang": "es", "value": "follow-redirects es vulnerable a una Exposici\u00f3n de Informaci\u00f3n Personal Privada a un Actor no Autorizado"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:L/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.0, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.1, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-359"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:follow-redirects_project:follow-redirects:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "1.14.7", "matchCriteriaId": "C2DABAA5-4FC6-4335-A94B-74CC931680E8"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:siemens:sinec_ins:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.0", "matchCriteriaId": "C89891C1-DFD7-4E1F-80A9-7485D86A15B5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:siemens:sinec_ins:1.0:-:*:*:*:*:*:*", "matchCriteriaId": "4664B195-AF14-4834-82B3-0B2C98020EB6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:siemens:sinec_ins:1.0:sp1:*:*:*:*:*:*", "matchCriteriaId": "75BC588E-CDF0-404E-AD61-02093A1DF343"}]}]}], "references": [{"url": "https://cert-portal.siemens.com/productcert/pdf/ssa-637483.pdf", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/follow-redirects/follow-redirects/commit/8b347cbcef7c7b72a6e9be20f5710c17d6163c22", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/fc524e4b-ebb6-427d-ab67-a64181020406", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/follow-redirects/follow-redirects/commit/8b347cbcef7c7b72a6e9be20f5710c17d6163c22"}}