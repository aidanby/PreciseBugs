{"buggy_code": ["import os\nimport pytest\nimport asyncio\n\nfrom asyncio import TimeoutError\nfrom asyncua import Client\nfrom asyncua import Server\nfrom asyncua import ua\nfrom asyncua.server.user_managers import CertificateUserManager\nfrom asyncua.crypto.security_policies import Verifier, Decryptor\n\ntry:\n    from asyncua.crypto import uacrypto\n    from asyncua.crypto import security_policies\nexcept ImportError:\n    print(\"WARNING: CRYPTO NOT AVAILABLE, CRYPTO TESTS DISABLED!!\")\n    disable_crypto_tests = True\nelse:\n    disable_crypto_tests = False\n\npytestmark = pytest.mark.asyncio\n\nport_num1 = 48515\nport_num2 = 48512\nport_num3 = 48516\nuri_crypto = \"opc.tcp://127.0.0.1:{0:d}\".format(port_num1)\nuri_no_crypto = \"opc.tcp://127.0.0.1:{0:d}\".format(port_num2)\nuri_crypto_cert = \"opc.tcp://127.0.0.1:{0:d}\".format(port_num3)\nBASE_DIR = os.path.dirname(os.path.dirname(__file__))\nEXAMPLE_PATH = os.path.join(BASE_DIR, \"examples\") + os.sep\nsrv_crypto_params = [(f\"{EXAMPLE_PATH}private-key-example.pem\",\n                      f\"{EXAMPLE_PATH}certificate-example.der\"),\n                     (f\"{EXAMPLE_PATH}private-key-3072-example.pem\",\n                      f\"{EXAMPLE_PATH}certificate-3072-example.der\")]\n\npeer_creds = {\n    \"certificate\": f\"{EXAMPLE_PATH}certificates/peer-certificate-example-1.der\",\n    \"private_key\": f\"{EXAMPLE_PATH}certificates/peer-private-key-example-1.pem\"\n}\n\nunauthorized_peer_creds = {\n    \"certificate\": f\"{EXAMPLE_PATH}certificates/peer-certificate-example-2.der\",\n    \"private_key\": f\"{EXAMPLE_PATH}certificates/peer-private-key-example-2.pem\"\n}\n\nencrypted_private_key_peer_creds = {\n    \"private_key\": f\"{EXAMPLE_PATH}certificates/peer-private-key-example-encrypted-private-key.pem\",\n    \"certificate\": f\"{EXAMPLE_PATH}certificates/peer-certificate-example-encrypted-private-key.der\",\n    \"password\": b\"password\"\n}\n\n\n@pytest.fixture(params=srv_crypto_params)\nasync def srv_crypto_encrypted_key_one_cert(request):\n    peer_certificate = encrypted_private_key_peer_creds[\"certificate\"]\n    user_manager = CertificateUserManager()\n    key, cert = request.param\n    await user_manager.add_admin(peer_certificate, 'test1')\n\n    srv = Server(user_manager=user_manager)\n\n    await srv.init()\n    srv.set_endpoint(uri_crypto_cert)\n    srv.set_security_policy([ua.SecurityPolicyType.Basic256Sha256_SignAndEncrypt])\n    await srv.load_certificate(cert)\n    await srv.load_private_key(key)\n    await srv.start()\n    yield srv, cert\n    # stop the server\n    await srv.stop()\n\n\n@pytest.fixture(params=srv_crypto_params)\nasync def srv_crypto_all_certs(request):\n    # start our own server\n    srv = Server()\n    key, cert = request.param\n    await srv.init()\n    srv.set_endpoint(uri_crypto)\n    await srv.load_certificate(cert)\n    await srv.load_private_key(key)\n    await srv.start()\n    yield srv, cert\n    # stop the server\n    await srv.stop()\n\n\n@pytest.fixture(params=srv_crypto_params)\nasync def srv_crypto_one_cert(request):\n    peer_certificate = peer_creds[\"certificate\"]\n    user_manager = CertificateUserManager()\n    key, cert = request.param\n    await user_manager.add_admin(peer_certificate, 'test1')\n\n    srv = Server(user_manager=user_manager)\n\n    await srv.init()\n    srv.set_endpoint(uri_crypto_cert)\n    srv.set_security_policy([ua.SecurityPolicyType.Basic256Sha256_SignAndEncrypt])\n    await srv.load_certificate(cert)\n    await srv.load_private_key(key)\n    await srv.start()\n    yield srv, cert\n    # stop the server\n    await srv.stop()\n\n\n@pytest.fixture()\nasync def srv_no_crypto():\n    # start our own server\n    srv = Server()\n    await srv.init()\n    srv.set_endpoint(uri_no_crypto)\n    await srv.start()\n    yield srv\n    # stop the server\n    await srv.stop()\n\n\nasync def test_nocrypto(srv_no_crypto):\n    clt = Client(uri_no_crypto)\n    async with clt:\n        await clt.nodes.objects.get_children()\n\n\nasync def test_nocrypto_fail(srv_no_crypto):\n    clt = Client(uri_no_crypto)\n    with pytest.raises(ua.UaError):\n        await clt.set_security_string(\n            f\"Basic256Sha256,Sign,{EXAMPLE_PATH}certificate-example.der,{EXAMPLE_PATH}private-key-example.pem\")\n\n\nasync def test_basic256(srv_crypto_all_certs):\n    _, cert = srv_crypto_all_certs\n    clt = Client(uri_crypto)\n    await clt.set_security_string(\n        f\"Basic256Sha256,Sign,{EXAMPLE_PATH}certificate-example.der,{EXAMPLE_PATH}private-key-example.pem,{cert}\"\n    )\n    async with clt:\n        assert await clt.nodes.objects.get_children()\n\n\nasync def test_basic256_encrypt(srv_crypto_all_certs):\n    _, cert = srv_crypto_all_certs\n    clt = Client(uri_crypto)\n    await clt.set_security_string(\n        f\"Basic256Sha256,SignAndEncrypt,{EXAMPLE_PATH}certificate-example.der,{EXAMPLE_PATH}private-key-example.pem,{cert}\")\n    async with clt:\n        assert await clt.nodes.objects.get_children()\n\n\nasync def test_basic256_encrypt_success(srv_crypto_all_certs):\n    clt = Client(uri_crypto)\n    _, cert = srv_crypto_all_certs\n    await clt.set_security(\n        security_policies.SecurityPolicyBasic256Sha256,\n        f\"{EXAMPLE_PATH}certificate-example.der\",\n        f\"{EXAMPLE_PATH}private-key-example.pem\",\n        None,\n        cert,\n        ua.MessageSecurityMode.SignAndEncrypt\n    )\n\n    async with clt:\n        assert await clt.nodes.objects.get_children()\n\n\n@pytest.mark.skip(\"# FIXME: how to make it fail???\")\nasync def test_basic256_encrypt_fail(srv_crypto_all_certs):\n    # FIXME: how to make it fail???\n    _, cert = srv_crypto_all_certs\n    clt = Client(uri_crypto)\n    with pytest.raises(ua.UaError):\n        await clt.set_security(\n            security_policies.SecurityPolicyBasic256Sha256,\n            f\"{EXAMPLE_PATH}certificate-example.der\",\n            f\"{EXAMPLE_PATH}private-key-example.pem\",\n            None,\n            None,\n            mode=ua.MessageSecurityMode.None_\n        )\n\n\nasync def test_certificate_handling_success(srv_crypto_one_cert):\n    _, cert = srv_crypto_one_cert\n    clt = Client(uri_crypto_cert)\n    await clt.set_security(\n        security_policies.SecurityPolicyBasic256Sha256,\n        peer_creds['certificate'],\n        peer_creds['private_key'],\n        None,\n        cert,\n        mode=ua.MessageSecurityMode.SignAndEncrypt\n    )\n    async with clt:\n        assert await clt.get_objects_node().get_children()\n\n\nasync def test_encrypted_private_key_handling_success(srv_crypto_encrypted_key_one_cert):\n    _, cert = srv_crypto_encrypted_key_one_cert\n    clt = Client(uri_crypto_cert)\n    await clt.set_security(\n        security_policies.SecurityPolicyBasic256Sha256,\n        encrypted_private_key_peer_creds['certificate'],\n        encrypted_private_key_peer_creds['private_key'],\n        encrypted_private_key_peer_creds['password'],\n        cert,\n        mode=ua.MessageSecurityMode.SignAndEncrypt\n    )\n    async with clt:\n        assert await clt.get_objects_node().get_children()\n\n\nasync def test_encrypted_private_key_handling_success_with_cert_props(srv_crypto_encrypted_key_one_cert):\n    _, cert = srv_crypto_encrypted_key_one_cert\n    clt = Client(uri_crypto_cert)\n    user_cert = uacrypto.CertProperties(encrypted_private_key_peer_creds['certificate'], \"DER\")\n    user_key = uacrypto.CertProperties(\n        path=encrypted_private_key_peer_creds['private_key'],\n        password=encrypted_private_key_peer_creds['password'],\n        extension=\"PEM\",\n    )\n    server_cert = uacrypto.CertProperties(cert)\n    await clt.set_security(\n        security_policies.SecurityPolicyBasic256Sha256,\n        user_cert,\n        user_key,\n        server_certificate=server_cert,\n        mode=ua.MessageSecurityMode.SignAndEncrypt\n    )\n    async with clt:\n        assert await clt.get_objects_node().get_children()\n\n\nasync def test_certificate_handling_failure(srv_crypto_one_cert):\n    _, cert = srv_crypto_one_cert\n    clt = Client(uri_crypto_cert)\n\n    with pytest.raises(ua.uaerrors.BadUserAccessDenied):\n        await clt.set_security(\n            security_policies.SecurityPolicyBasic256Sha256,\n            unauthorized_peer_creds['certificate'],\n            unauthorized_peer_creds['private_key'],\n            None,\n            mode=ua.MessageSecurityMode.SignAndEncrypt\n        )\n\n        async with clt:\n            assert await clt.get_objects_node().get_children()\n\n\nasync def test_encrypted_private_key_handling_failure(srv_crypto_one_cert):\n    _, cert = srv_crypto_one_cert\n    clt = Client(uri_crypto_cert)\n\n    with pytest.raises(ua.uaerrors.BadUserAccessDenied):\n        await clt.set_security(\n            security_policies.SecurityPolicyBasic256Sha256,\n            unauthorized_peer_creds['certificate'],\n            unauthorized_peer_creds['private_key'],\n            None,  # Pass None for an empty password to test incorrect password.\n            cert,\n            mode=ua.MessageSecurityMode.SignAndEncrypt\n        )\n        async with clt:\n            assert await clt.get_objects_node().get_children()\n\n\nasync def test_certificate_handling_mismatched_creds(srv_crypto_one_cert):\n    _, cert = srv_crypto_one_cert\n    clt = Client(uri_crypto_cert)\n    with pytest.raises((AttributeError, TimeoutError)):\n        # either exception can be raise, depending on used python version\n        # and crypto library version\n        await clt.set_security(\n            security_policies.SecurityPolicyBasic256Sha256,\n            peer_creds['certificate'],\n            unauthorized_peer_creds['private_key'],\n            None,\n            cert,\n            mode=ua.MessageSecurityMode.SignAndEncrypt\n        )\n        async with clt:\n            assert await clt.get_objects_node().get_children()\n\n\n@pytest.mark.skip(\"That test fails and hangs randomly on github so disabling for now\")\nasync def test_secure_channel_key_expiration(srv_crypto_one_cert, mocker):\n    timeout = 1\n    _, cert = srv_crypto_one_cert\n    clt = Client(uri_crypto_cert)\n    clt.secure_channel_timeout = timeout * 1000\n    user_cert = uacrypto.CertProperties(peer_creds['certificate'], \"DER\")\n    user_key = uacrypto.CertProperties(\n        path=peer_creds['private_key'],\n        extension=\"PEM\",\n    )\n    server_cert = uacrypto.CertProperties(cert)\n    await clt.set_security(\n        security_policies.SecurityPolicyBasic256Sha256,\n        user_cert,\n        user_key,\n        server_certificate=server_cert,\n        mode=ua.MessageSecurityMode.SignAndEncrypt\n    )\n    async with clt:\n        assert clt.uaclient.security_policy.symmetric_cryptography.Prev_Verifier is None\n        assert clt.uaclient.security_policy.symmetric_cryptography.Prev_Decryptor is None\n\n        await asyncio.sleep(timeout * 1.2)\n        sym_crypto = clt.uaclient.security_policy.symmetric_cryptography\n        prev_verifier = sym_crypto.Prev_Verifier\n        prev_decryptor = sym_crypto.Prev_Decryptor\n        assert isinstance(prev_verifier, Verifier)\n        assert isinstance(prev_decryptor, Decryptor)\n\n        mock_decry_reset = mocker.patch.object(prev_verifier, \"reset\", wraps=prev_verifier.reset)\n        mock_verif_reset = mocker.patch.object(prev_decryptor, \"reset\", wraps=prev_decryptor.reset)\n        assert mock_decry_reset.call_count == 0\n        assert mock_verif_reset.call_count == 0\n\n        await asyncio.sleep(timeout * 0.3)\n        assert await clt.get_objects_node().get_children()\n\n        assert sym_crypto.key_expiration > 0\n        assert sym_crypto.prev_key_expiration > 0\n        assert sym_crypto.key_expiration > sym_crypto.prev_key_expiration\n\n        assert mock_decry_reset.call_count == 1\n        assert mock_verif_reset.call_count == 1\n        assert clt.uaclient.security_policy.symmetric_cryptography.Prev_Verifier is None\n        assert clt.uaclient.security_policy.symmetric_cryptography.Prev_Decryptor is None\n\n\nasync def test_always_catch_new_cert_on_set_security():\n    \"\"\"\n    Test client reconnection after server cert update.\n    This could be useful when we prefer to keep a unique\n    client instance (i.e HaClient).\n    \"\"\"\n    # Client connecting with encryption to server\n    srv = Server()\n    await srv.init()\n    srv.set_endpoint(uri_crypto_cert)\n    srv.set_security_policy([ua.SecurityPolicyType.Basic256Sha256_SignAndEncrypt])\n    key, cert = srv_crypto_params[0]\n    await srv.load_certificate(cert)\n    await srv.load_private_key(key)\n    await srv.start()\n    clt = Client(uri_crypto_cert)\n    peer_cert = peer_creds[\"certificate\"]\n    peer_key = peer_creds[\"private_key\"]\n    security_string = f\"Basic256Sha256,SignAndEncrypt,{peer_cert},{peer_key}\"\n    await clt.set_security_string(security_string)\n    assert await clt.connect_and_get_server_endpoints()\n    srv_original_cert = clt.security_policy.peer_certificate\n    await srv.stop()\n\n    # Simulation of a server cert renewal\n    srv = Server()\n    await srv.init()\n    srv.set_endpoint(uri_crypto_cert)\n    srv.set_security_policy([ua.SecurityPolicyType.Basic256Sha256_SignAndEncrypt])\n    key, cert = srv_crypto_params[1]\n    await srv.load_certificate(cert)\n    await srv.load_private_key(key)\n    await srv.start()\n    # The same client instance fails to open a SecureChannel because the\n    # security_policy contains the previous SecurityMode and server certificate.\n    with pytest.raises(TimeoutError):\n        await clt.connect_and_get_server_endpoints()\n\n    assert clt.security_policy == clt.uaclient.security_policy\n    assert clt.security_policy.peer_certificate == srv_original_cert\n\n    # If the server cert isn't passed to set_security we clear the security_policy\n    await clt.set_security_string(security_string)\n    assert await clt.connect_and_get_server_endpoints()\n    assert clt.security_policy == clt.uaclient.security_policy\n    assert clt.security_policy.peer_certificate\n    assert clt.security_policy.peer_certificate != srv_original_cert\n    await srv.stop()\n\n\nasync def test_anonymous_rejection():\n    peer_certificate = peer_creds[\"certificate\"]\n    user_manager = CertificateUserManager()\n    key, cert = srv_crypto_params[0]\n    await user_manager.add_admin(peer_certificate, 'test1')\n\n    srv = Server(user_manager=user_manager)\n\n    await srv.init()\n    srv.set_endpoint(uri_crypto_cert)\n    srv.set_security_policy([ua.SecurityPolicyType.Basic256Sha256_SignAndEncrypt])\n    srv.set_security_IDs([\"Username\", \"Basic256Sha256\"])\n    await srv.load_certificate(cert)\n    await srv.load_private_key(key)\n    await srv.start()\n    clt = Client(uri_crypto_cert)\n    await clt.set_security(\n        security_policies.SecurityPolicyBasic256Sha256,\n        peer_creds['certificate'],\n        peer_creds['private_key'],\n        None,\n        cert,\n        mode=ua.MessageSecurityMode.SignAndEncrypt\n    )\n    with pytest.raises(ua.uaerrors.BadIdentityTokenRejected):\n        await clt.connect()\n    await srv.stop()\n"], "fixing_code": ["import os\nimport pytest\nimport asyncio\n\nfrom asyncio import TimeoutError\nfrom asyncua import Client\nfrom asyncua import Server\nfrom asyncua import ua\nfrom asyncua.server.user_managers import CertificateUserManager\nfrom asyncua.crypto.security_policies import Verifier, Decryptor\n\ntry:\n    from asyncua.crypto import uacrypto\n    from asyncua.crypto import security_policies\nexcept ImportError:\n    print(\"WARNING: CRYPTO NOT AVAILABLE, CRYPTO TESTS DISABLED!!\")\n    disable_crypto_tests = True\nelse:\n    disable_crypto_tests = False\n\npytestmark = pytest.mark.asyncio\n\nport_num1 = 48515\nport_num2 = 48512\nport_num3 = 48516\nuri_crypto = \"opc.tcp://127.0.0.1:{0:d}\".format(port_num1)\nuri_no_crypto = \"opc.tcp://127.0.0.1:{0:d}\".format(port_num2)\nuri_crypto_cert = \"opc.tcp://127.0.0.1:{0:d}\".format(port_num3)\nBASE_DIR = os.path.dirname(os.path.dirname(__file__))\nEXAMPLE_PATH = os.path.join(BASE_DIR, \"examples\") + os.sep\nsrv_crypto_params = [(f\"{EXAMPLE_PATH}private-key-example.pem\",\n                      f\"{EXAMPLE_PATH}certificate-example.der\"),\n                     (f\"{EXAMPLE_PATH}private-key-3072-example.pem\",\n                      f\"{EXAMPLE_PATH}certificate-3072-example.der\")]\n\npeer_creds = {\n    \"certificate\": f\"{EXAMPLE_PATH}certificates/peer-certificate-example-1.der\",\n    \"private_key\": f\"{EXAMPLE_PATH}certificates/peer-private-key-example-1.pem\"\n}\n\nunauthorized_peer_creds = {\n    \"certificate\": f\"{EXAMPLE_PATH}certificates/peer-certificate-example-2.der\",\n    \"private_key\": f\"{EXAMPLE_PATH}certificates/peer-private-key-example-2.pem\"\n}\n\nencrypted_private_key_peer_creds = {\n    \"private_key\": f\"{EXAMPLE_PATH}certificates/peer-private-key-example-encrypted-private-key.pem\",\n    \"certificate\": f\"{EXAMPLE_PATH}certificates/peer-certificate-example-encrypted-private-key.der\",\n    \"password\": b\"password\"\n}\n\n\n@pytest.fixture(params=srv_crypto_params)\nasync def srv_crypto_encrypted_key_one_cert(request):\n    peer_certificate = encrypted_private_key_peer_creds[\"certificate\"]\n    user_manager = CertificateUserManager()\n    key, cert = request.param\n    await user_manager.add_admin(peer_certificate, 'test1')\n\n    srv = Server(user_manager=user_manager)\n\n    await srv.init()\n    srv.set_endpoint(uri_crypto_cert)\n    srv.set_security_policy([ua.SecurityPolicyType.Basic256Sha256_SignAndEncrypt])\n    await srv.load_certificate(cert)\n    await srv.load_private_key(key)\n    await srv.start()\n    yield srv, cert\n    # stop the server\n    await srv.stop()\n\n\n@pytest.fixture(params=srv_crypto_params)\nasync def srv_crypto_all_certs(request):\n    # start our own server\n    srv = Server()\n    key, cert = request.param\n    await srv.init()\n    srv.set_endpoint(uri_crypto)\n    await srv.load_certificate(cert)\n    await srv.load_private_key(key)\n    await srv.start()\n    yield srv, cert\n    # stop the server\n    await srv.stop()\n\n\n@pytest.fixture(params=srv_crypto_params)\nasync def srv_crypto_one_cert(request):\n    peer_certificate = peer_creds[\"certificate\"]\n    user_manager = CertificateUserManager()\n    key, cert = request.param\n    await user_manager.add_admin(peer_certificate, 'test1')\n\n    srv = Server(user_manager=user_manager)\n\n    await srv.init()\n    srv.set_endpoint(uri_crypto_cert)\n    srv.set_security_policy([ua.SecurityPolicyType.Basic256Sha256_SignAndEncrypt])\n    await srv.load_certificate(cert)\n    await srv.load_private_key(key)\n    await srv.start()\n    yield srv, cert\n    # stop the server\n    await srv.stop()\n\n\n@pytest.fixture()\nasync def srv_no_crypto():\n    # start our own server\n    srv = Server()\n    await srv.init()\n    srv.set_endpoint(uri_no_crypto)\n    await srv.start()\n    yield srv\n    # stop the server\n    await srv.stop()\n\n\nasync def test_nocrypto(srv_no_crypto):\n    clt = Client(uri_no_crypto)\n    async with clt:\n        await clt.nodes.objects.get_children()\n\n\nasync def test_nocrypto_fail(srv_no_crypto):\n    clt = Client(uri_no_crypto)\n    with pytest.raises(ua.UaError):\n        await clt.set_security_string(\n            f\"Basic256Sha256,Sign,{EXAMPLE_PATH}certificate-example.der,{EXAMPLE_PATH}private-key-example.pem\")\n\n\nasync def test_basic256(srv_crypto_all_certs):\n    _, cert = srv_crypto_all_certs\n    clt = Client(uri_crypto)\n    await clt.set_security_string(\n        f\"Basic256Sha256,Sign,{EXAMPLE_PATH}certificate-example.der,{EXAMPLE_PATH}private-key-example.pem,{cert}\"\n    )\n    async with clt:\n        assert await clt.nodes.objects.get_children()\n\n\nasync def test_basic256_encrypt(srv_crypto_all_certs):\n    _, cert = srv_crypto_all_certs\n    clt = Client(uri_crypto)\n    await clt.set_security_string(\n        f\"Basic256Sha256,SignAndEncrypt,{EXAMPLE_PATH}certificate-example.der,{EXAMPLE_PATH}private-key-example.pem,{cert}\")\n    async with clt:\n        assert await clt.nodes.objects.get_children()\n\n\nasync def test_basic256_encrypt_success(srv_crypto_all_certs):\n    clt = Client(uri_crypto)\n    _, cert = srv_crypto_all_certs\n    await clt.set_security(\n        security_policies.SecurityPolicyBasic256Sha256,\n        f\"{EXAMPLE_PATH}certificate-example.der\",\n        f\"{EXAMPLE_PATH}private-key-example.pem\",\n        None,\n        cert,\n        ua.MessageSecurityMode.SignAndEncrypt\n    )\n\n    async with clt:\n        assert await clt.nodes.objects.get_children()\n\n\n@pytest.mark.skip(\"# FIXME: how to make it fail???\")\nasync def test_basic256_encrypt_fail(srv_crypto_all_certs):\n    # FIXME: how to make it fail???\n    _, cert = srv_crypto_all_certs\n    clt = Client(uri_crypto)\n    with pytest.raises(ua.UaError):\n        await clt.set_security(\n            security_policies.SecurityPolicyBasic256Sha256,\n            f\"{EXAMPLE_PATH}certificate-example.der\",\n            f\"{EXAMPLE_PATH}private-key-example.pem\",\n            None,\n            None,\n            mode=ua.MessageSecurityMode.None_\n        )\n\n\nasync def test_certificate_handling_success(srv_crypto_one_cert):\n    _, cert = srv_crypto_one_cert\n    clt = Client(uri_crypto_cert)\n    await clt.set_security(\n        security_policies.SecurityPolicyBasic256Sha256,\n        peer_creds['certificate'],\n        peer_creds['private_key'],\n        None,\n        cert,\n        mode=ua.MessageSecurityMode.SignAndEncrypt\n    )\n    async with clt:\n        assert await clt.get_objects_node().get_children()\n\n\nasync def test_encrypted_private_key_handling_success(srv_crypto_encrypted_key_one_cert):\n    _, cert = srv_crypto_encrypted_key_one_cert\n    clt = Client(uri_crypto_cert)\n    await clt.set_security(\n        security_policies.SecurityPolicyBasic256Sha256,\n        encrypted_private_key_peer_creds['certificate'],\n        encrypted_private_key_peer_creds['private_key'],\n        encrypted_private_key_peer_creds['password'],\n        cert,\n        mode=ua.MessageSecurityMode.SignAndEncrypt\n    )\n    async with clt:\n        assert await clt.get_objects_node().get_children()\n\n\nasync def test_encrypted_private_key_handling_success_with_cert_props(srv_crypto_encrypted_key_one_cert):\n    _, cert = srv_crypto_encrypted_key_one_cert\n    clt = Client(uri_crypto_cert)\n    user_cert = uacrypto.CertProperties(encrypted_private_key_peer_creds['certificate'], \"DER\")\n    user_key = uacrypto.CertProperties(\n        path=encrypted_private_key_peer_creds['private_key'],\n        password=encrypted_private_key_peer_creds['password'],\n        extension=\"PEM\",\n    )\n    server_cert = uacrypto.CertProperties(cert)\n    await clt.set_security(\n        security_policies.SecurityPolicyBasic256Sha256,\n        user_cert,\n        user_key,\n        server_certificate=server_cert,\n        mode=ua.MessageSecurityMode.SignAndEncrypt\n    )\n    async with clt:\n        assert await clt.get_objects_node().get_children()\n\n\nasync def test_certificate_handling_failure(srv_crypto_one_cert):\n    _, cert = srv_crypto_one_cert\n    clt = Client(uri_crypto_cert)\n\n    with pytest.raises(ua.uaerrors.BadUserAccessDenied):\n        await clt.set_security(\n            security_policies.SecurityPolicyBasic256Sha256,\n            unauthorized_peer_creds['certificate'],\n            unauthorized_peer_creds['private_key'],\n            None,\n            mode=ua.MessageSecurityMode.SignAndEncrypt\n        )\n\n        async with clt:\n            assert await clt.get_objects_node().get_children()\n\n\nasync def test_encrypted_private_key_handling_failure(srv_crypto_one_cert):\n    _, cert = srv_crypto_one_cert\n    clt = Client(uri_crypto_cert)\n\n    with pytest.raises(ua.uaerrors.BadUserAccessDenied):\n        await clt.set_security(\n            security_policies.SecurityPolicyBasic256Sha256,\n            unauthorized_peer_creds['certificate'],\n            unauthorized_peer_creds['private_key'],\n            None,  # Pass None for an empty password to test incorrect password.\n            cert,\n            mode=ua.MessageSecurityMode.SignAndEncrypt\n        )\n        async with clt:\n            assert await clt.get_objects_node().get_children()\n\n\nasync def test_certificate_handling_mismatched_creds(srv_crypto_one_cert):\n    _, cert = srv_crypto_one_cert\n    clt = Client(uri_crypto_cert)\n    with pytest.raises((AttributeError, TimeoutError)):\n        # either exception can be raise, depending on used python version\n        # and crypto library version\n        await clt.set_security(\n            security_policies.SecurityPolicyBasic256Sha256,\n            peer_creds['certificate'],\n            unauthorized_peer_creds['private_key'],\n            None,\n            cert,\n            mode=ua.MessageSecurityMode.SignAndEncrypt\n        )\n        async with clt:\n            assert await clt.get_objects_node().get_children()\n\n\n@pytest.mark.skip(\"That test fails and hangs randomly on github so disabling for now\")\nasync def test_secure_channel_key_expiration(srv_crypto_one_cert, mocker):\n    timeout = 1\n    _, cert = srv_crypto_one_cert\n    clt = Client(uri_crypto_cert)\n    clt.secure_channel_timeout = timeout * 1000\n    user_cert = uacrypto.CertProperties(peer_creds['certificate'], \"DER\")\n    user_key = uacrypto.CertProperties(\n        path=peer_creds['private_key'],\n        extension=\"PEM\",\n    )\n    server_cert = uacrypto.CertProperties(cert)\n    await clt.set_security(\n        security_policies.SecurityPolicyBasic256Sha256,\n        user_cert,\n        user_key,\n        server_certificate=server_cert,\n        mode=ua.MessageSecurityMode.SignAndEncrypt\n    )\n    async with clt:\n        assert clt.uaclient.security_policy.symmetric_cryptography.Prev_Verifier is None\n        assert clt.uaclient.security_policy.symmetric_cryptography.Prev_Decryptor is None\n\n        await asyncio.sleep(timeout)\n        sym_crypto = clt.uaclient.security_policy.symmetric_cryptography\n        prev_verifier = sym_crypto.Prev_Verifier\n        prev_decryptor = sym_crypto.Prev_Decryptor\n        assert isinstance(prev_verifier, Verifier)\n        assert isinstance(prev_decryptor, Decryptor)\n\n        mock_decry_reset = mocker.patch.object(prev_verifier, \"reset\", wraps=prev_verifier.reset)\n        mock_verif_reset = mocker.patch.object(prev_decryptor, \"reset\", wraps=prev_decryptor.reset)\n        assert mock_decry_reset.call_count == 0\n        assert mock_verif_reset.call_count == 0\n\n        await asyncio.sleep(timeout * 0.3)\n        assert await clt.get_objects_node().get_children()\n\n        assert sym_crypto.key_expiration > 0\n        assert sym_crypto.prev_key_expiration > 0\n        assert sym_crypto.key_expiration > sym_crypto.prev_key_expiration\n\n        assert mock_decry_reset.call_count == 1\n        assert mock_verif_reset.call_count == 1\n        assert clt.uaclient.security_policy.symmetric_cryptography.Prev_Verifier is None\n        assert clt.uaclient.security_policy.symmetric_cryptography.Prev_Decryptor is None\n\n\nasync def test_always_catch_new_cert_on_set_security():\n    \"\"\"\n    Test client reconnection after server cert update.\n    This could be useful when we prefer to keep a unique\n    client instance (i.e HaClient).\n    \"\"\"\n    # Client connecting with encryption to server\n    srv = Server()\n    await srv.init()\n    srv.set_endpoint(uri_crypto_cert)\n    srv.set_security_policy([ua.SecurityPolicyType.Basic256Sha256_SignAndEncrypt])\n    key, cert = srv_crypto_params[0]\n    await srv.load_certificate(cert)\n    await srv.load_private_key(key)\n    await srv.start()\n    clt = Client(uri_crypto_cert)\n    peer_cert = peer_creds[\"certificate\"]\n    peer_key = peer_creds[\"private_key\"]\n    security_string = f\"Basic256Sha256,SignAndEncrypt,{peer_cert},{peer_key}\"\n    await clt.set_security_string(security_string)\n    assert await clt.connect_and_get_server_endpoints()\n    srv_original_cert = clt.security_policy.peer_certificate\n    await srv.stop()\n\n    # Simulation of a server cert renewal\n    srv = Server()\n    await srv.init()\n    srv.set_endpoint(uri_crypto_cert)\n    srv.set_security_policy([ua.SecurityPolicyType.Basic256Sha256_SignAndEncrypt])\n    key, cert = srv_crypto_params[1]\n    await srv.load_certificate(cert)\n    await srv.load_private_key(key)\n    await srv.start()\n    # The same client instance fails to open a SecureChannel because the\n    # security_policy contains the previous SecurityMode and server certificate.\n    with pytest.raises(TimeoutError):\n        await clt.connect_and_get_server_endpoints()\n\n    assert clt.security_policy == clt.uaclient.security_policy\n    assert clt.security_policy.peer_certificate == srv_original_cert\n\n    # If the server cert isn't passed to set_security we clear the security_policy\n    await clt.set_security_string(security_string)\n    assert await clt.connect_and_get_server_endpoints()\n    assert clt.security_policy == clt.uaclient.security_policy\n    assert clt.security_policy.peer_certificate\n    assert clt.security_policy.peer_certificate != srv_original_cert\n    await srv.stop()\n\n\nasync def test_anonymous_rejection():\n    peer_certificate = peer_creds[\"certificate\"]\n    user_manager = CertificateUserManager()\n    key, cert = srv_crypto_params[0]\n    await user_manager.add_admin(peer_certificate, 'test1')\n\n    srv = Server(user_manager=user_manager)\n\n    await srv.init()\n    srv.set_endpoint(uri_crypto_cert)\n    srv.set_security_policy([ua.SecurityPolicyType.Basic256Sha256_SignAndEncrypt])\n    srv.set_security_IDs([\"Username\", \"Basic256Sha256\"])\n    await srv.load_certificate(cert)\n    await srv.load_private_key(key)\n    await srv.start()\n    clt = Client(uri_crypto_cert)\n    await clt.set_security(\n        security_policies.SecurityPolicyBasic256Sha256,\n        peer_creds['certificate'],\n        peer_creds['private_key'],\n        None,\n        cert,\n        mode=ua.MessageSecurityMode.SignAndEncrypt\n    )\n    with pytest.raises(ua.uaerrors.BadIdentityTokenRejected):\n        await clt.connect()\n    await srv.stop()\n"], "filenames": ["tests/test_crypto_connect.py"], "buggy_code_start_loc": [310], "buggy_code_end_loc": [311], "fixing_code_start_loc": [310], "fixing_code_end_loc": [311], "type": "CWE-287", "message": "Versions of the package asyncua before 0.9.96 are vulnerable to Improper Authentication such that it is possible to access Address Space without encryption and authentication.\r\r**Note:**\r\rThis issue is a result of missing checks for services that require an active session.", "other": {"cve": {"id": "CVE-2023-26150", "sourceIdentifier": "report@snyk.io", "published": "2023-10-03T05:15:49.963", "lastModified": "2023-11-07T04:09:28.870", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Versions of the package asyncua before 0.9.96 are vulnerable to Improper Authentication such that it is possible to access Address Space without encryption and authentication.\r\r**Note:**\r\rThis issue is a result of missing checks for services that require an active session."}, {"lang": "es", "value": "Las versiones del paquete asyncua anteriores a la 0.9.96 son vulnerables a una autenticaci\u00f3n incorrecta, por lo que es posible acceder al espacio de direcciones sin cifrado ni autenticaci\u00f3n. **Nota:** Este problema se debe a que faltan comprobaciones de servicios que requieren una sesi\u00f3n activa."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "report@snyk.io", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 2.5}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-287"}]}, {"source": "report@snyk.io", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-287"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:freeopcua:opcua-asyncio:*:*:*:*:*:python:*:*", "versionEndExcluding": "0.9.96", "matchCriteriaId": "D64D2A05-90B8-43AA-B8BE-9D79959CFC61"}]}]}], "references": [{"url": "https://gist.github.com/artfire52/84f7279a4119d6f90381ac49d7121121", "source": "report@snyk.io", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://github.com/FreeOpcUa/opcua-asyncio/commit/2be7ce80df05de8d6c6ae1ebce6fa2bb7147844a", "source": "report@snyk.io", "tags": ["Patch"]}, {"url": "https://github.com/FreeOpcUa/opcua-asyncio/commit/b4106dfd5037423c9d1810b48a97296b59cde513", "source": "report@snyk.io", "tags": ["Patch"]}, {"url": "https://github.com/FreeOpcUa/opcua-asyncio/issues/1014", "source": "report@snyk.io", "tags": ["Exploit", "Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/FreeOpcUa/opcua-asyncio/pull/1015", "source": "report@snyk.io", "tags": ["Patch"]}, {"url": "https://github.com/FreeOpcUa/opcua-asyncio/releases/tag/v0.9.96", "source": "report@snyk.io", "tags": ["Product", "Release Notes"]}, {"url": "https://security.snyk.io/vuln/SNYK-PYTHON-ASYNCUA-5673435", "source": "report@snyk.io", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/FreeOpcUa/opcua-asyncio/commit/2be7ce80df05de8d6c6ae1ebce6fa2bb7147844a"}}