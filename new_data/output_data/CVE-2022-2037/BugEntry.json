{"buggy_code": ["import React from 'react';\nimport config from 'config';\nimport { Router, Route, Redirect } from 'react-router-dom';\nimport { history } from '@/_helpers';\nimport { authenticationService, tooljetService } from '@/_services';\nimport { PrivateRoute } from '@/_components';\nimport { HomePage } from '@/HomePage';\nimport { LoginPage } from '@/LoginPage';\nimport { SignupPage } from '@/SignupPage';\nimport { ConfirmationPage, OrganizationInvitationPage } from '@/ConfirmationPage';\nimport { Authorize } from '@/Oauth2';\nimport { Authorize as Oauth } from '@/Oauth';\nimport { Viewer } from '@/Editor';\nimport { ManageGroupPermissions } from '@/ManageGroupPermissions';\nimport { ManageOrgUsers } from '@/ManageOrgUsers';\nimport { ManageGroupPermissionResources } from '@/ManageGroupPermissionResources';\nimport { SettingsPage } from '../SettingsPage/SettingsPage';\nimport { OnboardingModal } from '@/Onboarding/OnboardingModal';\nimport { ForgotPassword } from '@/ForgotPassword';\nimport { ResetPassword } from '@/ResetPassword';\nimport { ManageSSO } from '@/ManageSSO';\nimport { lt } from 'semver';\nimport { Toaster } from 'react-hot-toast';\nimport { RealtimeEditor } from '@/Editor/RealtimeEditor';\nimport { Editor } from '@/Editor/Editor';\nimport { RedirectSso } from '@/RedirectSso/RedirectSso';\n\nimport '@/_styles/theme.scss';\nimport 'emoji-mart/css/emoji-mart.css';\n\nclass App extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      currentUser: null,\n      fetchedMetadata: false,\n      onboarded: true,\n      darkMode: localStorage.getItem('darkMode') === 'true',\n    };\n  }\n\n  fetchMetadata = () => {\n    if (this.state.currentUser) {\n      tooljetService.fetchMetaData().then((data) => {\n        this.setState({ onboarded: data.onboarded });\n\n        if (data.latest_version && lt(data.installed_version, data.latest_version) && data.version_ignored === false) {\n          this.setState({ updateAvailable: true });\n        }\n      });\n    }\n  };\n\n  componentDidMount() {\n    authenticationService.currentUser.subscribe((x) => {\n      this.setState({ currentUser: x }, this.fetchMetadata);\n      setInterval(this.fetchMetadata, 1000 * 60 * 60 * 1);\n    });\n  }\n\n  logout = () => {\n    authenticationService.logout();\n    history.push('/login');\n  };\n\n  switchDarkMode = (newMode) => {\n    this.setState({ darkMode: newMode });\n    localStorage.setItem('darkMode', newMode);\n  };\n\n  render() {\n    const { updateAvailable, onboarded, darkMode } = this.state;\n    let toastOptions = {};\n\n    if (darkMode) {\n      toastOptions = {\n        style: {\n          borderRadius: '10px',\n          background: '#333',\n          color: '#fff',\n        },\n      };\n    }\n\n    return (\n      <>\n        <Router history={history}>\n          <div className={`main-wrapper ${darkMode ? 'theme-dark' : ''}`}>\n            {updateAvailable && (\n              <div className=\"alert alert-info alert-dismissible\" role=\"alert\">\n                <h3 className=\"mb-1\">Update available</h3>\n                <p>A new version of ToolJet has been released.</p>\n                <div className=\"btn-list\">\n                  <a\n                    href=\"https://docs.tooljet.io/docs/setup/updating\"\n                    target=\"_blank\"\n                    className=\"btn btn-info\"\n                    rel=\"noreferrer\"\n                  >\n                    Read release notes & update\n                  </a>\n                  <a\n                    onClick={() => {\n                      tooljetService.skipVersion();\n                      this.setState({ updateAvailable: false });\n                    }}\n                    className=\"btn\"\n                  >\n                    Skip this version\n                  </a>\n                </div>\n              </div>\n            )}\n\n            {!onboarded && <OnboardingModal darkMode={this.state.darkMode} />}\n\n            <PrivateRoute\n              exact\n              path=\"/\"\n              component={HomePage}\n              switchDarkMode={this.switchDarkMode}\n              darkMode={darkMode}\n            />\n            <Route path=\"/login/:organisationId\" exact component={LoginPage} />\n            <Route path=\"/login\" exact component={LoginPage} />\n            <Route path=\"/sso/:origin/:configId\" component={Oauth} />\n            <Route path=\"/signup\" component={SignupPage} />\n            <Route path=\"/forgot-password\" component={ForgotPassword} />\n            <Route path=\"/reset-password\" component={ResetPassword} />\n            <Route path=\"/multiworkspace\" component={RedirectSso} />\n            <Route\n              path=\"/invitations/:token\"\n              render={(props) => (\n                <Redirect\n                  to={{\n                    pathname: '/confirm',\n                    state: {\n                      token: props.match.params.token,\n                    },\n                  }}\n                />\n              )}\n            />\n            <Route path=\"/confirm\" component={ConfirmationPage} />\n            <Route\n              path=\"/organization-invitations/:token\"\n              render={(props) => (\n                <Redirect\n                  to={{\n                    pathname: '/confirm-invite',\n                    state: {\n                      token: props.match.params.token,\n                    },\n                  }}\n                />\n              )}\n            />\n            <Route path=\"/confirm-invite\" component={OrganizationInvitationPage} />\n            <PrivateRoute\n              exact\n              path=\"/apps/:id\"\n              component={config.ENABLE_MULTIPLAYER_EDITING ? RealtimeEditor : Editor}\n              switchDarkMode={this.switchDarkMode}\n              darkMode={darkMode}\n            />\n            <PrivateRoute\n              exact\n              path=\"/applications/:id/versions/:versionId\"\n              component={Viewer}\n              switchDarkMode={this.switchDarkMode}\n              darkMode={darkMode}\n            />\n            <PrivateRoute\n              exact\n              path=\"/applications/:slug\"\n              component={Viewer}\n              switchDarkMode={this.switchDarkMode}\n              darkMode={darkMode}\n            />\n            <PrivateRoute\n              exact\n              path=\"/oauth2/authorize\"\n              component={Authorize}\n              switchDarkMode={this.switchDarkMode}\n              darkMode={darkMode}\n            />\n            <PrivateRoute\n              exact\n              path=\"/users\"\n              component={ManageOrgUsers}\n              switchDarkMode={this.switchDarkMode}\n              darkMode={darkMode}\n            />\n            <PrivateRoute\n              exact\n              path=\"/manage-sso\"\n              component={ManageSSO}\n              switchDarkMode={this.switchDarkMode}\n              darkMode={darkMode}\n            />\n            <PrivateRoute\n              exact\n              path=\"/groups\"\n              component={ManageGroupPermissions}\n              switchDarkMode={this.switchDarkMode}\n              darkMode={darkMode}\n            />\n            <PrivateRoute\n              exact\n              path=\"/groups/:id\"\n              component={ManageGroupPermissionResources}\n              switchDarkMode={this.switchDarkMode}\n              darkMode={darkMode}\n            />\n            <PrivateRoute\n              exact\n              path=\"/settings\"\n              component={SettingsPage}\n              switchDarkMode={this.switchDarkMode}\n              darkMode={darkMode}\n            />\n          </div>\n        </Router>\n        <Toaster toastOptions={toastOptions} />\n      </>\n    );\n  }\n}\n\nexport { App };\n", "import React from 'react';\nimport { userService } from '@/_services';\nimport { toast } from 'react-hot-toast';\n\nclass ConfirmationPage extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      isLoading: false,\n    };\n    this.formRef = React.createRef(null);\n  }\n\n  handleChange = (event) => {\n    this.setState({ [event.target.name]: event.target.value });\n  };\n\n  calculateOffset() {\n    const elementHeight = this.formRef.current.getBoundingClientRect().top;\n    return window.innerHeight - elementHeight;\n  }\n\n  setPassword = (e) => {\n    e.preventDefault();\n    const token = this.props.location.state.token;\n    const { password, organization, role, firstName, lastName, password_confirmation } = this.state;\n    this.setState({ isLoading: true });\n\n    if (!password || !password_confirmation || !password.trim() || !password_confirmation.trim()) {\n      this.setState({ isLoading: false });\n      toast.error(\"Password shouldn't be empty or contain white space(s)\", {\n        position: 'top-center',\n      });\n      return;\n    }\n\n    if (password !== password_confirmation) {\n      this.setState({ isLoading: false });\n      toast.error(\"Passwords don't match\", {\n        position: 'top-center',\n      });\n      return;\n    }\n\n    userService\n      .setPasswordFromToken({\n        token,\n        password,\n        organization,\n        role,\n        firstName,\n        lastName,\n      })\n      .then(() => {\n        this.setState({ isLoading: false });\n        toast.success('Account has been setup successfully.', {\n          position: 'top-center',\n        });\n        this.props.history.push('/login');\n      })\n      .catch(({ error }) => {\n        this.setState({ isLoading: false });\n        toast.error(error, { position: 'top-center' });\n      });\n  };\n\n  render() {\n    const { isLoading } = this.state;\n    const roles = [\n      'CTO/CIO',\n      'Founder/CEO',\n      'IT Manager',\n      'Developer',\n      'Designer',\n      'Sales Professional',\n      'Marketing Professional',\n      'Product Manager',\n      'Other',\n    ];\n\n    const roleOptions = roles.map((role, index) => (\n      <option key={index} value={role}>\n        {role}\n      </option>\n    ));\n\n    return (\n      <div className=\"page page-center\" ref={this.formRef} style={{ overflowY: 'scroll' }}>\n        <div\n          className=\"container-tight py-2 invitation-page\"\n          style={{ maxHeight: this.formRef.current && this.calculateOffset() }}\n        >\n          <div className=\"text-center mb-4\">\n            <a href=\".\">\n              <img src=\"/assets/images/logo-color.svg\" height=\"30\" alt=\"\" />\n            </a>\n          </div>\n          <form className=\"card card-md\" action=\".\" method=\"get\" autoComplete=\"off\">\n            <div className=\"card-body\">\n              <h2 className=\"card-title text-center mb-4\">Set up your account</h2>\n              <div className=\"mb-3\">\n                <label className=\"form-label\">First name</label>\n                <div className=\"input-group input-group-flat\">\n                  <input\n                    onChange={this.handleChange}\n                    name=\"firstName\"\n                    type=\"text\"\n                    className=\"form-control\"\n                    autoComplete=\"off\"\n                  />\n                  <span className=\"input-group-text\"></span>\n                </div>\n              </div>\n              <div className=\"mb-3\">\n                <label className=\"form-label\">Last name</label>\n                <div className=\"input-group input-group-flat\">\n                  <input\n                    onChange={this.handleChange}\n                    name=\"lastName\"\n                    type=\"text\"\n                    className=\"form-control\"\n                    autoComplete=\"off\"\n                  />\n                  <span className=\"input-group-text\"></span>\n                </div>\n              </div>\n              <div className=\"mb-3\">\n                <label className=\"form-label\">Workspace</label>\n                <div className=\"input-group input-group-flat\">\n                  <input\n                    onChange={this.handleChange}\n                    name=\"organization\"\n                    type=\"text\"\n                    className=\"form-control\"\n                    autoComplete=\"off\"\n                  />\n                  <span className=\"input-group-text\"></span>\n                </div>\n              </div>\n              <div className=\"mb-3\">\n                <div className=\"form-label\">Role</div>\n                <select className=\"form-select\" name=\"role\" defaultValue=\"\" onChange={this.handleChange}>\n                  <option value=\"\" disabled>\n                    Please select\n                  </option>\n                  {roleOptions}\n                </select>\n              </div>\n              <div className=\"mb-3\">\n                <label className=\"form-label\">Password</label>\n                <div className=\"input-group input-group-flat\">\n                  <input\n                    onChange={this.handleChange}\n                    name=\"password\"\n                    type=\"password\"\n                    className=\"form-control\"\n                    autoComplete=\"off\"\n                  />\n                  <span className=\"input-group-text\"></span>\n                </div>\n              </div>\n              <div className=\"mb-3\">\n                <label className=\"form-label\">Confirm Password</label>\n                <div className=\"input-group input-group-flat\">\n                  <input\n                    onChange={this.handleChange}\n                    name=\"password_confirmation\"\n                    type=\"password\"\n                    className=\"form-control\"\n                    autoComplete=\"off\"\n                  />\n                  <span className=\"input-group-text\"></span>\n                </div>\n              </div>\n              <div className=\"form-footer\">\n                <p>\n                  By clicking the button below, you agree to our{' '}\n                  <a href=\"https://tooljet.io/terms\">Terms and Conditions</a>.\n                </p>\n                <button\n                  className={`btn mt-2 btn-primary w-100 ${isLoading ? ' btn-loading' : ''}`}\n                  onClick={this.setPassword}\n                  disabled={isLoading}\n                >\n                  Finish account setup\n                </button>\n              </div>\n            </div>\n          </form>\n        </div>\n      </div>\n    );\n  }\n}\n\nexport { ConfirmationPage };\n", "import React from 'react';\nimport { userService } from '@/_services';\nimport { toast } from 'react-hot-toast';\n\nclass OrganizationInvitationPage extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      isLoading: false,\n    };\n    this.formRef = React.createRef(null);\n    this.single_organization = window.public_config?.DISABLE_MULTI_WORKSPACE === 'true';\n  }\n\n  handleChange = (event) => {\n    this.setState({ [event.target.name]: event.target.value });\n  };\n\n  acceptInvite = (e, isSetPassword) => {\n    e.preventDefault();\n\n    const token = this.props.location.state.token;\n    const { password, password_confirmation } = this.state;\n    this.setState({ isLoading: true });\n\n    if (isSetPassword) {\n      if (!password || !password_confirmation || !password.trim() || !password_confirmation.trim()) {\n        this.setState({ isLoading: false });\n        toast.error(\"Password shouldn't be empty or contain white space(s)\", {\n          position: 'top-center',\n        });\n        return;\n      }\n\n      if (password !== password_confirmation) {\n        this.setState({ isLoading: false });\n        toast.error(\"Passwords don't match\", {\n          position: 'top-center',\n        });\n        return;\n      }\n    }\n\n    userService\n      .acceptInvite({\n        token,\n        password,\n      })\n      .then(() => {\n        this.setState({ isLoading: false });\n        toast.success(`Added to the workspace${isSetPassword ? ' and password has been set ' : ' '}successfully.`, {\n          position: 'top-center',\n        });\n        this.props.history.push('/login');\n      })\n      .catch(({ error }) => {\n        this.setState({ isLoading: false });\n        toast.error(error, { position: 'top-center' });\n      });\n  };\n\n  render() {\n    const { isLoading } = this.state;\n\n    return (\n      <div className=\"page page-center\" ref={this.formRef}>\n        <div className=\"container-tight py-2 invitation-page\">\n          <div className=\"text-center mb-4\">\n            <a href=\".\">\n              <img src=\"/assets/images/logo-color.svg\" height=\"30\" alt=\"\" />\n            </a>\n          </div>\n          <form className=\"card card-md\" action=\".\" method=\"get\" autoComplete=\"off\">\n            <div className=\"card-body\">\n              {!this.single_organization && (\n                <>\n                  <h2 className=\"card-title text-center mb-2\">Already have an account?</h2>\n                  <div className=\"mb-3\">\n                    <button\n                      className={`btn mt-2 btn-primary w-100 ${isLoading ? ' btn-loading' : ''}`}\n                      onClick={(e) => this.acceptInvite(e)}\n                      disabled={isLoading}\n                    >\n                      Accept invite\n                    </button>\n                  </div>\n                  <div className=\"org-invite-or\">\n                    <h2>\n                      <span>OR</span>\n                    </h2>\n                  </div>\n                </>\n              )}\n              <h2 className=\"card-title text-center mb-4\">Set up your account</h2>\n              <div className=\"mb-3\">\n                <label className=\"form-label\">Password</label>\n                <div className=\"input-group input-group-flat\">\n                  <input\n                    onChange={this.handleChange}\n                    name=\"password\"\n                    type=\"password\"\n                    className=\"form-control\"\n                    autoComplete=\"off\"\n                  />\n                  <span className=\"input-group-text\"></span>\n                </div>\n              </div>\n              <div className=\"mb-3\">\n                <label className=\"form-label\">Confirm Password</label>\n                <div className=\"input-group input-group-flat\">\n                  <input\n                    onChange={this.handleChange}\n                    name=\"password_confirmation\"\n                    type=\"password\"\n                    className=\"form-control\"\n                    autoComplete=\"off\"\n                  />\n                  <span className=\"input-group-text\"></span>\n                </div>\n              </div>\n              <div className=\"form-footer\">\n                <p>\n                  By clicking the button below, you agree to our{' '}\n                  <a href=\"https://tooljet.io/terms\">Terms and Conditions</a>.\n                </p>\n                <button\n                  className={`btn mt-2 btn-primary w-100 ${isLoading ? ' btn-loading' : ''}`}\n                  onClick={(e) => this.acceptInvite(e, true)}\n                  disabled={isLoading}\n                >\n                  Finish account setup and accept invite\n                </button>\n              </div>\n            </div>\n          </form>\n        </div>\n      </div>\n    );\n  }\n}\n\nexport { OrganizationInvitationPage };\n", "import React from 'react';\nimport { authenticationService, organizationService, organizationUserService } from '@/_services';\nimport { Header } from '@/_components';\nimport { toast } from 'react-hot-toast';\nimport { history } from '@/_helpers';\nimport { CopyToClipboard } from 'react-copy-to-clipboard';\nimport ReactTooltip from 'react-tooltip';\n\nclass ManageOrgUsers extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      currentUser: authenticationService.currentUserValue,\n      isLoading: true,\n      showNewUserForm: false,\n      creatingUser: false,\n      newUser: {},\n      archivingUser: null,\n      unarchivingUser: null,\n      fields: {},\n      errors: {},\n    };\n\n    this.tableRef = React.createRef(null);\n  }\n\n  validateEmail(email) {\n    console.log(email);\n    const re =\n      /^(([^<>()[\\]\\\\.,;:\\s@\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/;\n    return re.test(String(email).toLowerCase());\n  }\n\n  handleValidation() {\n    let fields = this.state.fields;\n    let errors = {};\n    //Name\n    if (!fields['firstName']) {\n      errors['firstName'] = 'This field is required';\n    } else if (typeof fields['firstName'] !== 'undefined') {\n      if (!/^[a-zA-Z]+$/.test(fields['firstName'])) {\n        errors['firstName'] = 'Only letters are allowed';\n      }\n    }\n    if (!fields['lastName']) {\n      errors['lastName'] = 'This field is required';\n    } else if (typeof fields['lastName'] !== 'undefined') {\n      if (!/^[a-zA-Z]+$/.test(fields['lastName'])) {\n        errors['lastName'] = 'Only letters are allowed';\n      }\n    }\n    //Email\n    if (!fields['email']) {\n      errors['email'] = 'This field is required';\n    } else if (!this.validateEmail(fields['email'])) {\n      errors['email'] = 'Email is not valid';\n    }\n\n    this.setState({ errors: errors });\n    return Object.keys(errors).length === 0;\n  }\n\n  componentDidMount() {\n    this.fetchUsers();\n  }\n\n  calculateOffset() {\n    const elementHeight = this.tableRef.current.getBoundingClientRect().top;\n    return window.innerHeight - elementHeight;\n  }\n\n  fetchUsers = () => {\n    this.setState({\n      isLoading: true,\n    });\n\n    organizationService.getUsers(null).then((data) =>\n      this.setState({\n        users: data.users,\n        isLoading: false,\n      })\n    );\n  };\n\n  changeNewUserOption = (name, e) => {\n    let fields = this.state.fields;\n    fields[name] = e.target.value;\n\n    this.setState({\n      fields,\n    });\n  };\n\n  archiveOrgUser = (id) => {\n    this.setState({ archivingUser: id });\n\n    organizationUserService\n      .archive(id)\n      .then(() => {\n        toast.success('The user has been archived', {\n          position: 'top-center',\n        });\n        this.setState({ archivingUser: null });\n        this.fetchUsers();\n      })\n      .catch(({ error }) => {\n        toast.error(error, { position: 'top-center' });\n        this.setState({ archivingUser: null });\n      });\n  };\n\n  unarchiveOrgUser = (id) => {\n    this.setState({ unarchivingUser: id });\n\n    organizationUserService\n      .unarchive(id)\n      .then(() => {\n        toast.success('The user has been unarchived', {\n          position: 'top-center',\n        });\n        this.setState({ unarchivingUser: null });\n        this.fetchUsers();\n      })\n      .catch(({ error }) => {\n        toast.error(error, { position: 'top-center' });\n        this.setState({ unarchivingUser: null });\n      });\n  };\n\n  createUser = (event) => {\n    event.preventDefault();\n\n    if (this.handleValidation()) {\n      let fields = {};\n      Object.keys(this.state.fields).map((key) => {\n        fields[key] = '';\n      });\n\n      this.setState({\n        creatingUser: true,\n      });\n\n      organizationUserService\n        .create(\n          this.state.fields.firstName,\n          this.state.fields.lastName,\n          this.state.fields.email,\n          this.state.fields.role\n        )\n        .then(() => {\n          toast.success('User has been created', {\n            position: 'top-center',\n          });\n          this.fetchUsers();\n          this.setState({\n            creatingUser: false,\n            showNewUserForm: false,\n            fields: fields,\n          });\n        })\n        .catch(({ error }) => {\n          toast.error(error, { position: 'top-center' });\n          this.setState({ creatingUser: false });\n        });\n    } else {\n      this.setState({ creatingUser: false, showNewUserForm: true });\n    }\n  };\n\n  logout = () => {\n    authenticationService.logout();\n    history.push('/login');\n  };\n\n  generateInvitationURL = (user) => window.location.origin + '/organization-invitations/' + user.invitation_token;\n\n  invitationLinkCopyHandler = () => {\n    toast.success('Invitation URL copied', {\n      position: 'bottom-right',\n    });\n  };\n\n  render() {\n    const { isLoading, showNewUserForm, creatingUser, users, archivingUser, unarchivingUser } = this.state;\n    return (\n      <div className=\"wrapper org-users-page\">\n        <Header switchDarkMode={this.props.switchDarkMode} darkMode={this.props.darkMode} />\n        <ReactTooltip type=\"dark\" effect=\"solid\" delayShow={250} />\n\n        <div className=\"page-wrapper\">\n          <div className=\"container-xl\">\n            <div className=\"page-header d-print-none\">\n              <div className=\"row align-items-center\">\n                <div className=\"col\">\n                  <div className=\"page-pretitle\"></div>\n                  <h2 className=\"page-title\">Users & Permissions</h2>\n                </div>\n                <div className=\"col-auto ms-auto d-print-none\">\n                  {!showNewUserForm && (\n                    <div className=\"btn btn-primary\" onClick={() => this.setState({ showNewUserForm: true })}>\n                      Invite new user\n                    </div>\n                  )}\n                </div>\n              </div>\n            </div>\n          </div>\n\n          <div className=\"page-body\">\n            {showNewUserForm && (\n              <div className=\"container-xl\">\n                <div className=\"card\">\n                  <div className=\"card-header\">\n                    <h3 className=\"card-title\">Add new user</h3>\n                  </div>\n                  <div className=\"card-body\">\n                    <form onSubmit={this.createUser} noValidate>\n                      <div className=\"form-group mb-3 \">\n                        <div className=\"row\">\n                          <div className=\"col\">\n                            <input\n                              type=\"text\"\n                              className=\"form-control\"\n                              placeholder=\"Enter First Name\"\n                              name=\"firstName\"\n                              onChange={this.changeNewUserOption.bind(this, 'firstName')}\n                              value={this.state.fields['firstName']}\n                            />\n                            <span className=\"text-danger\">{this.state.errors['firstName']}</span>\n                          </div>\n                          <div className=\"col\">\n                            <input\n                              type=\"text\"\n                              className=\"form-control\"\n                              placeholder=\"Enter Last Name\"\n                              name=\"lastName\"\n                              onChange={this.changeNewUserOption.bind(this, 'lastName')}\n                              value={this.state.fields['lastName']}\n                            />\n                            <span className=\"text-danger\">{this.state.errors['lastName']}</span>\n                          </div>\n                        </div>\n                      </div>\n                      <div className=\"form-group mb-3 \">\n                        <label className=\"form-label\">Email address</label>\n                        <div>\n                          <input\n                            type=\"text\"\n                            className=\"form-control\"\n                            aria-describedby=\"emailHelp\"\n                            placeholder=\"Enter email\"\n                            name=\"email\"\n                            onChange={this.changeNewUserOption.bind(this, 'email')}\n                            value={this.state.fields['email']}\n                          />\n                          <span className=\"text-danger\">{this.state.errors['email']}</span>\n                        </div>\n                      </div>\n                      <div className=\"form-footer\">\n                        <button\n                          type=\"button\"\n                          className=\"btn btn-light mr-2\"\n                          onClick={() =>\n                            this.setState({\n                              showNewUserForm: false,\n                              newUser: {},\n                            })\n                          }\n                        >\n                          Cancel\n                        </button>\n                        <button\n                          type=\"submit\"\n                          className={`btn mx-2 btn-primary ${creatingUser ? 'btn-loading' : ''}`}\n                          disabled={creatingUser}\n                        >\n                          Create User\n                        </button>\n                      </div>\n                    </form>\n                  </div>\n                </div>\n              </div>\n            )}\n\n            {!showNewUserForm && (\n              <div className=\"container-xl\">\n                <div className=\"card\">\n                  <div\n                    className=\"card-table fixedHeader table-responsive table-bordered\"\n                    ref={this.tableRef}\n                    style={{\n                      maxHeight: this.tableRef.current && this.calculateOffset(),\n                    }}\n                  >\n                    <table data-testid=\"usersTable\" className=\"table table-vcenter\" disabled={true}>\n                      <thead>\n                        <tr>\n                          <th>Name</th>\n                          <th>Email</th>\n                          <th>Status</th>\n                          <th className=\"w-1\"></th>\n                        </tr>\n                      </thead>\n                      {isLoading ? (\n                        <tbody className=\"w-100\" style={{ minHeight: '300px' }}>\n                          {Array.from(Array(4)).map((_item, index) => (\n                            <tr key={index}>\n                              <td className=\"col-2 p-3\">\n                                <div className=\"row\">\n                                  <div\n                                    className=\"skeleton-image col-auto\"\n                                    style={{ width: '25px', height: '25px' }}\n                                  ></div>\n                                  <div className=\"skeleton-line w-10 col mx-3\"></div>\n                                </div>\n                              </td>\n                              <td className=\"col-4 p-3\">\n                                <div className=\"skeleton-line w-10\"></div>\n                              </td>\n                              <td className=\"col-2 p-3\">\n                                <div className=\"skeleton-line\"></div>\n                              </td>\n                              <td className=\"text-muted col-auto col-1 pt-3\">\n                                <div className=\"skeleton-line\"></div>\n                              </td>\n                              <td className=\"text-muted col-auto col-1 pt-3\">\n                                <div className=\"skeleton-line\"></div>\n                              </td>\n                            </tr>\n                          ))}\n                        </tbody>\n                      ) : (\n                        <tbody>\n                          {users.map((user) => (\n                            <tr key={user.id}>\n                              <td>\n                                <span className=\"avatar bg-azure-lt avatar-sm\">\n                                  {user.first_name ? user.first_name[0] : ''}\n                                  {user.last_name ? user.last_name[0] : ''}\n                                </span>\n                                <span\n                                  className=\"mx-3\"\n                                  style={{\n                                    display: 'inline-flex',\n                                    marginBottom: '7px',\n                                  }}\n                                >\n                                  {user.name}\n                                </span>\n                              </td>\n                              <td className=\"text-muted\">\n                                <a className=\"text-reset user-email\">{user.email}</a>\n                              </td>\n                              <td className=\"text-muted\">\n                                <span\n                                  className={`badge bg-${\n                                    user.status === 'invited'\n                                      ? 'warning'\n                                      : user.status === 'archived'\n                                      ? 'danger'\n                                      : 'success'\n                                  } me-1 m-1`}\n                                ></span>\n                                <small className=\"user-status\">{user.status}</small>\n                                {user.status === 'invited' && 'invitation_token' in user ? (\n                                  <CopyToClipboard\n                                    text={this.generateInvitationURL(user)}\n                                    onCopy={this.invitationLinkCopyHandler}\n                                  >\n                                    <img\n                                      data-tip=\"Copy invitation link\"\n                                      className=\"svg-icon\"\n                                      src=\"/assets/images/icons/copy.svg\"\n                                      width=\"15\"\n                                      height=\"15\"\n                                      style={{\n                                        cursor: 'pointer',\n                                      }}\n                                    ></img>\n                                  </CopyToClipboard>\n                                ) : (\n                                  ''\n                                )}\n                              </td>\n                              <td>\n                                <button\n                                  type=\"button\"\n                                  style={{ minWidth: '100px' }}\n                                  className={`btn btn-sm btn-outline-${\n                                    user.status === 'archived' ? 'success' : 'danger'\n                                  } ${unarchivingUser === user.id || archivingUser === user.id ? 'btn-loading' : ''}`}\n                                  disabled={unarchivingUser === user.id || archivingUser === user.id}\n                                  onClick={() => {\n                                    user.status === 'archived'\n                                      ? this.unarchiveOrgUser(user.id)\n                                      : this.archiveOrgUser(user.id);\n                                  }}\n                                >\n                                  {user.status === 'archived' ? 'Unarchive' : 'Archive'}\n                                </button>\n                              </td>\n                            </tr>\n                          ))}\n                        </tbody>\n                      )}\n                    </table>\n                  </div>\n                </div>\n              </div>\n            )}\n          </div>\n        </div>\n      </div>\n    );\n  }\n}\n\nexport { ManageOrgUsers };\n", "import config from 'config';\nimport { authHeader, handleResponse } from '@/_helpers';\n\nexport const appService = {\n  getConfig,\n  getAll,\n  createApp,\n  cloneApp,\n  exportApp,\n  importApp,\n  changeIcon,\n  deleteApp,\n  getApp,\n  getAppBySlug,\n  getAppByVersion,\n  saveApp,\n  getAppUsers,\n  createAppUser,\n  setVisibility,\n  setMaintenance,\n  setSlug,\n};\n\nfunction getConfig() {\n  const requestOptions = { method: 'GET', headers: authHeader() };\n  return fetch(`${config.apiUrl}/config`, requestOptions).then(handleResponse);\n}\n\nfunction getAll(page, folder, searchKey) {\n  const requestOptions = { method: 'GET', headers: authHeader() };\n  if (page === 0) return fetch(`${config.apiUrl}/apps`, requestOptions).then(handleResponse);\n  else\n    return fetch(\n      `${config.apiUrl}/apps?page=${page}&folder=${folder || ''}&searchKey=${searchKey}`,\n      requestOptions\n    ).then(handleResponse);\n}\n\nfunction createApp() {\n  const body = {};\n\n  const requestOptions = { method: 'POST', headers: authHeader(), body: JSON.stringify(body) };\n  return fetch(`${config.apiUrl}/apps`, requestOptions).then(handleResponse);\n}\n\nfunction cloneApp(id) {\n  const requestOptions = { method: 'POST', headers: authHeader() };\n  return fetch(`${config.apiUrl}/apps/${id}/clone`, requestOptions).then(handleResponse);\n}\n\nfunction exportApp(id) {\n  const requestOptions = { method: 'GET', headers: authHeader() };\n  return fetch(`${config.apiUrl}/apps/${id}/export`, requestOptions).then(handleResponse);\n}\n\nfunction importApp(body) {\n  const requestOptions = { method: 'POST', headers: authHeader(), body: JSON.stringify(body) };\n  return fetch(`${config.apiUrl}/apps/import`, requestOptions).then(handleResponse);\n}\n\nfunction changeIcon(icon, appId) {\n  const requestOptions = { method: 'PUT', headers: authHeader(), body: JSON.stringify({ icon }) };\n  return fetch(`${config.apiUrl}/apps/${appId}/icons`, requestOptions).then(handleResponse);\n}\n\nfunction getApp(id) {\n  const requestOptions = { method: 'GET', headers: authHeader() };\n  return fetch(`${config.apiUrl}/apps/${id}`, requestOptions).then(handleResponse);\n}\n\nfunction deleteApp(id) {\n  const requestOptions = { method: 'DELETE', headers: authHeader() };\n  return fetch(`${config.apiUrl}/apps/${id}`, requestOptions).then(handleResponse);\n}\n\nfunction getAppBySlug(slug) {\n  const requestOptions = { method: 'GET', headers: authHeader() };\n  return fetch(`${config.apiUrl}/apps/slugs/${slug}`, requestOptions).then(handleResponse);\n}\n\nfunction getAppByVersion(appId, versionId) {\n  const requestOptions = { method: 'GET', headers: authHeader() };\n  return fetch(`${config.apiUrl}/apps/${appId}/versions/${versionId}`, requestOptions).then(handleResponse);\n}\n\nfunction saveApp(id, attributes) {\n  const requestOptions = { method: 'PUT', headers: authHeader(), body: JSON.stringify({ app: attributes }) };\n  return fetch(`${config.apiUrl}/apps/${id}`, requestOptions).then(handleResponse);\n}\n\nfunction getAppUsers(id) {\n  const requestOptions = { method: 'GET', headers: authHeader() };\n  return fetch(`${config.apiUrl}/apps/${id}/users`, requestOptions).then(handleResponse);\n}\n\nfunction createAppUser(app_id, org_user_id, role) {\n  const body = {\n    app_id,\n    org_user_id,\n    role,\n  };\n\n  const requestOptions = { method: 'POST', headers: authHeader(), body: JSON.stringify(body) };\n  return fetch(`${config.apiUrl}/app_users`, requestOptions).then(handleResponse);\n}\n\nfunction setVisibility(appId, visibility) {\n  const requestOptions = {\n    method: 'PUT',\n    headers: authHeader(),\n    body: JSON.stringify({ app: { is_public: visibility } }),\n  };\n  return fetch(`${config.apiUrl}/apps/${appId}`, requestOptions).then(handleResponse);\n}\n\nfunction setMaintenance(appId, value) {\n  const requestOptions = {\n    method: 'PUT',\n    headers: authHeader(),\n    body: JSON.stringify({ app: { is_maintenance_on: value } }),\n  };\n  return fetch(`${config.apiUrl}/apps/${appId}`, requestOptions).then(handleResponse);\n}\n\nfunction setSlug(appId, slug) {\n  const requestOptions = { method: 'PUT', headers: authHeader(), body: JSON.stringify({ app: { slug: slug } }) };\n  return fetch(`${config.apiUrl}/apps/${appId}`, requestOptions).then(handleResponse);\n}\n", "import config from 'config';\nimport { authHeader, handleResponse } from '@/_helpers';\n\nexport const userService = {\n  getAll,\n  createUser,\n  deleteUser,\n  setPasswordFromToken,\n  updateCurrentUser,\n  changePassword,\n  acceptInvite,\n  getAvatar,\n  updateAvatar,\n};\n\nfunction getAll() {\n  const requestOptions = { method: 'GET', headers: authHeader() };\n  return fetch(`${config.apiUrl}/users`, requestOptions).then(handleResponse);\n}\n\nfunction getAvatar(id) {\n  const requestOptions = { method: 'GET', headers: authHeader() };\n  return fetch(`${config.apiUrl}/files/${id}`, requestOptions)\n    .then((response) => response.blob())\n    .then((blob) => blob);\n}\n\nfunction updateAvatar(formData, token) {\n  const requestOptions = {\n    method: 'POST',\n    headers: {\n      Authorization: `Bearer ${token}`,\n    },\n    body: formData,\n  };\n  return fetch(`${config.apiUrl}/users/avatar`, requestOptions).then(handleResponse);\n}\n\nfunction createUser(first_name, last_name, email, role) {\n  const body = {\n    first_name,\n    last_name,\n    email,\n    role,\n  };\n\n  const requestOptions = { method: 'POST', headers: authHeader(), body: JSON.stringify(body) };\n  return fetch(`${config.apiUrl}/users`, requestOptions).then(handleResponse);\n}\n\nfunction deleteUser(id) {\n  const requestOptions = { method: 'DELETE', headers: authHeader(), body: JSON.stringify({}) };\n  return fetch(`${config.apiUrl}/users/${id}`, requestOptions).then(handleResponse);\n}\n\nfunction setPasswordFromToken({ token, password, organization, role, firstName, lastName }) {\n  const body = {\n    token,\n    password,\n    organization,\n    role,\n    first_name: firstName,\n    last_name: lastName,\n  };\n\n  const requestOptions = { method: 'POST', headers: authHeader(), body: JSON.stringify(body) };\n  return fetch(`${config.apiUrl}/users/set_password_from_token`, requestOptions).then(handleResponse);\n}\n\nfunction acceptInvite({ token, password }) {\n  const body = {\n    token,\n    password,\n  };\n\n  const requestOptions = { method: 'POST', headers: authHeader(), body: JSON.stringify(body) };\n  return fetch(`${config.apiUrl}/users/accept-invite`, requestOptions).then(handleResponse);\n}\n\nfunction updateCurrentUser(firstName, lastName) {\n  const body = { first_name: firstName, last_name: lastName };\n  const requestOptions = { method: 'PATCH', headers: authHeader(), body: JSON.stringify(body) };\n  return fetch(`${config.apiUrl}/users/update`, requestOptions).then(handleResponse);\n}\n\nfunction changePassword(currentPassword, newPassword) {\n  const body = { currentPassword, newPassword };\n  const requestOptions = { method: 'PATCH', headers: authHeader(), body: JSON.stringify(body) };\n  return fetch(`${config.apiUrl}/users/change_password`, requestOptions).then(handleResponse);\n}\n", "import { Controller, Get, Request, Post, UseGuards, Body, Param, BadRequestException } from '@nestjs/common';\nimport { User } from 'src/decorators/user.decorator';\nimport { JwtAuthGuard } from '../../src/modules/auth/jwt-auth.guard';\nimport { AppAuthenticationDto, AppForgotPasswordDto, AppPasswordResetDto } from '@dto/app-authentication.dto';\nimport { AuthService } from '../services/auth.service';\n\n@Controller()\nexport class AppController {\n  constructor(private authService: AuthService) {}\n\n  @Post(['authenticate', 'authenticate/:organizationId'])\n  async login(@Body() appAuthDto: AppAuthenticationDto, @Param('organizationId') organizationId) {\n    return this.authService.login(appAuthDto.email, appAuthDto.password, organizationId);\n  }\n\n  @UseGuards(JwtAuthGuard)\n  @Get('switch/:organizationId')\n  async switch(@Param('organizationId') organizationId, @User() user) {\n    if (!organizationId) {\n      throw new BadRequestException();\n    }\n    return await this.authService.switchOrganization(organizationId, user);\n  }\n\n  @Post('signup')\n  async signup(@Body() appAuthDto: AppAuthenticationDto) {\n    return this.authService.signup(appAuthDto.email);\n  }\n\n  @Post('/forgot_password')\n  async forgotPassword(@Body() appAuthDto: AppForgotPasswordDto) {\n    await this.authService.forgotPassword(appAuthDto.email);\n    return {};\n  }\n\n  @Post('/reset_password')\n  async resetPassword(@Body() appAuthDto: AppPasswordResetDto) {\n    const { token, password } = appAuthDto;\n    await this.authService.resetPassword(token, password);\n    return {};\n  }\n\n  @Get('/health')\n  async healthCheck(@Request() req) {\n    return { works: 'yeah' };\n  }\n}\n", "import { Controller, Param, Post, UseGuards, Body } from '@nestjs/common';\nimport { OrganizationUsersService } from 'src/services/organization_users.service';\nimport { decamelizeKeys } from 'humps';\nimport { JwtAuthGuard } from '../../src/modules/auth/jwt-auth.guard';\nimport { AppAbility } from 'src/modules/casl/casl-ability.factory';\nimport { PoliciesGuard } from 'src/modules/casl/policies.guard';\nimport { CheckPolicies } from 'src/modules/casl/check_policies.decorator';\nimport { User as UserEntity } from 'src/entities/user.entity';\nimport { User } from 'src/decorators/user.decorator';\nimport { InviteNewUserDto } from '../dto/invite-new-user.dto';\n\n@Controller('organization_users')\nexport class OrganizationUsersController {\n  constructor(private organizationUsersService: OrganizationUsersService) {}\n\n  // Endpoint for inviting new organization users\n  @UseGuards(JwtAuthGuard, PoliciesGuard)\n  @CheckPolicies((ability: AppAbility) => ability.can('inviteUser', UserEntity))\n  @Post()\n  async create(@User() user, @Body() inviteNewUserDto: InviteNewUserDto) {\n    const result = await this.organizationUsersService.inviteNewUser(user, inviteNewUserDto);\n    return decamelizeKeys({ users: result });\n  }\n\n  @UseGuards(JwtAuthGuard, PoliciesGuard)\n  @CheckPolicies((ability: AppAbility) => ability.can('archiveUser', UserEntity))\n  @Post(':id/archive')\n  async archive(@Param('id') id: string) {\n    const result = await this.organizationUsersService.archive(id);\n    return decamelizeKeys({ result });\n  }\n\n  @UseGuards(JwtAuthGuard, PoliciesGuard)\n  @CheckPolicies((ability: AppAbility) => ability.can('archiveUser', UserEntity))\n  @Post(':id/unarchive')\n  async unarchive(@User() user, @Param('id') id: string) {\n    const result = await this.organizationUsersService.unarchive(user, id);\n    return decamelizeKeys({ result });\n  }\n\n  // Deprecated\n  @UseGuards(JwtAuthGuard, PoliciesGuard)\n  @CheckPolicies((ability: AppAbility) => ability.can('changeRole', UserEntity))\n  @Post(':id/change_role')\n  async changeRole(@Param('id') id, @Body('role') role) {\n    const result = await this.organizationUsersService.changeRole(id, role);\n    return decamelizeKeys({ result });\n  }\n}\n", "import { Body, Controller, Post, Patch, UseGuards, UseInterceptors, Req, UploadedFile } from '@nestjs/common';\nimport { Express } from 'express';\nimport { FileInterceptor } from '@nestjs/platform-express';\nimport { JwtAuthGuard } from 'src/modules/auth/jwt-auth.guard';\nimport { PasswordRevalidateGuard } from 'src/modules/auth/password-revalidate.guard';\nimport { UsersService } from 'src/services/users.service';\nimport { User } from 'src/decorators/user.decorator';\nimport { SignupDisableGuard } from 'src/modules/auth/signup-disable.guard';\nimport { CreateUserDto, UpdateUserDto } from '@dto/user.dto';\nimport { AcceptInviteDto } from '@dto/accept-organization-invite.dto';\nimport { MultiOrganizationGuard } from 'src/modules/auth/multi-organization.guard';\n\n@Controller('users')\nexport class UsersController {\n  constructor(private usersService: UsersService) {}\n\n  @UseGuards(MultiOrganizationGuard, SignupDisableGuard)\n  @Post('set_password_from_token')\n  async create(@Body() userCreateDto: CreateUserDto) {\n    await this.usersService.setupAccountFromInvitationToken(userCreateDto);\n    return {};\n  }\n\n  @Post('accept-invite')\n  async acceptInvite(@Body() acceptInviteDto: AcceptInviteDto) {\n    await this.usersService.acceptOrganizationInvite(acceptInviteDto);\n    return {};\n  }\n\n  @UseGuards(JwtAuthGuard)\n  @Patch('update')\n  async update(@User() user, @Body() updateUserDto: UpdateUserDto) {\n    const { first_name: firstName, last_name: lastName } = updateUserDto;\n    await this.usersService.update(user.id, { firstName, lastName });\n    await user.reload();\n    return {\n      first_name: user.firstName,\n      last_name: user.lastName,\n    };\n  }\n\n  @Post('avatar')\n  @UseGuards(JwtAuthGuard)\n  @UseInterceptors(FileInterceptor('file'))\n  async addAvatar(@Req() req, @UploadedFile() file: Express.Multer.File) {\n    return this.usersService.addAvatar(req.user.id, file.buffer, file.originalname);\n  }\n\n  @UseGuards(JwtAuthGuard, PasswordRevalidateGuard)\n  @Patch('change_password')\n  async changePassword(@User() user, @Body('newPassword') newPassword) {\n    return await this.usersService.update(user.id, {\n      password: newPassword,\n    });\n  }\n}\n", "import { IsString, IsOptional, IsNotEmpty } from 'class-validator';\n\nexport class AcceptInviteDto {\n  @IsString()\n  @IsOptional()\n  @IsNotEmpty()\n  password: string;\n\n  @IsString()\n  @IsNotEmpty()\n  token: string;\n}\n", "import { IsString, IsOptional, IsNotEmpty } from 'class-validator';\nimport { Transform } from 'class-transformer';\nimport { sanitizeInput } from 'src/helpers/utils.helper';\nimport { PartialType } from '@nestjs/mapped-types';\n\nexport class CreateUserDto {\n  @IsString()\n  @IsOptional()\n  @IsNotEmpty()\n  @Transform(({ value }) => sanitizeInput(value))\n  first_name: string;\n\n  @IsString()\n  @IsOptional()\n  @IsNotEmpty()\n  @Transform(({ value }) => sanitizeInput(value))\n  last_name: string;\n\n  @IsString()\n  @IsOptional()\n  @IsNotEmpty()\n  @Transform(({ value }) => sanitizeInput(value))\n  organization: string;\n\n  @IsString()\n  @IsNotEmpty()\n  password: string;\n\n  @IsString()\n  @IsNotEmpty()\n  token: string;\n\n  @IsString()\n  @IsOptional()\n  @Transform(({ value }) => sanitizeInput(value))\n  role: string;\n}\n\nexport class UpdateUserDto extends PartialType(CreateUserDto) {}\n", "import { Injectable, NotAcceptableException, NotFoundException, UnauthorizedException } from '@nestjs/common';\nimport { UsersService } from './users.service';\nimport { OrganizationsService } from './organizations.service';\nimport { JwtService } from '@nestjs/jwt';\nimport { User } from '../entities/user.entity';\nimport { OrganizationUsersService } from './organization_users.service';\nimport { EmailService } from './email.service';\nimport { decamelizeKeys } from 'humps';\nimport { Organization } from 'src/entities/organization.entity';\nimport { ConfigService } from '@nestjs/config';\nimport { SSOConfigs } from 'src/entities/sso_config.entity';\nconst bcrypt = require('bcrypt');\nconst uuid = require('uuid');\n\n@Injectable()\nexport class AuthService {\n  constructor(\n    private usersService: UsersService,\n    private jwtService: JwtService,\n    private organizationsService: OrganizationsService,\n    private organizationUsersService: OrganizationUsersService,\n    private emailService: EmailService,\n    private configService: ConfigService\n  ) {}\n\n  verifyToken(token: string) {\n    try {\n      const signedJwt = this.jwtService.verify(token);\n      return signedJwt;\n    } catch (err) {\n      return null;\n    }\n  }\n\n  private async validateUser(email: string, password: string, organisationId?: string): Promise<User> {\n    const user = await this.usersService.findByEmail(email, organisationId);\n\n    if (!user) return null;\n\n    const isVerified = await bcrypt.compare(password, user.password);\n\n    return isVerified ? user : null;\n  }\n\n  async login(email: string, password: string, organizationId?: string) {\n    let organization: Organization;\n\n    const user = await this.validateUser(email, password, organizationId);\n\n    if (user && (await this.usersService.status(user)) !== 'archived') {\n      if (!organizationId) {\n        // Global login\n        // Determine the organization to be loaded\n        if (this.configService.get<string>('DISABLE_MULTI_WORKSPACE') === 'true') {\n          // Single organization\n          organization = await this.organizationsService.getSingleOrganization();\n          if (!organization?.ssoConfigs?.find((oc) => oc.sso == 'form' && oc.enabled)) {\n            throw new UnauthorizedException();\n          }\n        } else {\n          const organizationList: Organization[] = await this.organizationsService.findOrganizationSupportsFormLogin(\n            user\n          );\n\n          const defaultOrgDetails: Organization = organizationList?.find((og) => og.id === user.defaultOrganizationId);\n          // Multi organization\n          if (defaultOrgDetails) {\n            // default organization form login enabled\n            organization = defaultOrgDetails;\n          } else if (organizationList?.length > 0) {\n            // default organization form login not enabled, picking first one from form enabled list\n            organization = organizationList[0];\n          } else {\n            // no form login enabled organization available for user - creating new one\n            organization = await this.organizationsService.create('Untitled workspace', user);\n          }\n        }\n        user.organizationId = organization.id;\n      } else {\n        // organization specific login\n        user.organizationId = organizationId;\n\n        organization = await this.organizationsService.get(user.organizationId);\n        const formConfigs: SSOConfigs = organization?.ssoConfigs?.find((sso) => sso.sso === 'form');\n\n        if (!formConfigs?.enabled) {\n          // no configurations in organization side or Form login disabled for the organization\n          throw new UnauthorizedException('Password login is disabled for the organization');\n        }\n      }\n\n      if (user.defaultOrganizationId !== user.organizationId) {\n        // Updating default organization Id\n        await this.usersService.updateDefaultOrganization(user, organization.id);\n      }\n\n      const payload = {\n        username: user.id,\n        sub: user.email,\n        organizationId: user.organizationId,\n        isPasswordLogin: true,\n      };\n\n      return decamelizeKeys({\n        id: user.id,\n        auth_token: this.jwtService.sign(payload),\n        email: user.email,\n        first_name: user.firstName,\n        last_name: user.lastName,\n        avatar_id: user.avatarId,\n        organizationId: user.organizationId,\n        organization: organization.name,\n        admin: await this.usersService.hasGroup(user, 'admin'),\n        group_permissions: await this.usersService.groupPermissions(user),\n        app_group_permissions: await this.usersService.appGroupPermissions(user),\n      });\n    } else {\n      throw new UnauthorizedException('Invalid credentials');\n    }\n  }\n\n  async switchOrganization(newOrganizationId: string, user: User, isNewOrganization?: boolean) {\n    if (!(isNewOrganization || user.isPasswordLogin)) {\n      throw new UnauthorizedException();\n    }\n    if (this.configService.get<string>('DISABLE_MULTI_WORKSPACE') === 'true') {\n      throw new UnauthorizedException();\n    }\n    const newUser = await this.usersService.findByEmail(user.email, newOrganizationId);\n\n    if (newUser && (await this.usersService.status(newUser)) !== 'archived') {\n      newUser.organizationId = newOrganizationId;\n\n      const organization: Organization = await this.organizationsService.get(newUser.organizationId);\n\n      const formConfigs: SSOConfigs = organization?.ssoConfigs?.find((sso) => sso.sso === 'form');\n\n      if (!formConfigs?.enabled) {\n        // no configurations in organization side or Form login disabled for the organization\n        throw new UnauthorizedException('Password login disabled for the organization');\n      }\n\n      // Updating default organization Id\n      await this.usersService.updateDefaultOrganization(newUser, newUser.organizationId);\n\n      const payload = {\n        username: user.id,\n        sub: user.email,\n        organizationId: newUser.organizationId,\n        isPasswordLogin: true,\n      };\n\n      return decamelizeKeys({\n        id: newUser.id,\n        auth_token: this.jwtService.sign(payload),\n        email: newUser.email,\n        first_name: newUser.firstName,\n        last_name: newUser.lastName,\n        organizationId: newUser.organizationId,\n        organization: organization.name,\n        admin: await this.usersService.hasGroup(newUser, 'admin'),\n        group_permissions: await this.usersService.groupPermissions(newUser),\n        app_group_permissions: await this.usersService.appGroupPermissions(newUser),\n      });\n    } else {\n      throw new UnauthorizedException('Invalid credentials');\n    }\n  }\n\n  async signup(email: string) {\n    const existingUser = await this.usersService.findByEmail(email);\n    if (existingUser?.invitationToken || existingUser?.organizationUsers?.some((ou) => ou.status === 'active')) {\n      throw new NotAcceptableException('Email already exists');\n    }\n\n    let organization: Organization;\n    // Check if the configs allows user signups\n    if (this.configService.get<string>('DISABLE_MULTI_WORKSPACE') === 'true') {\n      // Single organization checking if organization exist\n      organization = await this.organizationsService.getSingleOrganization();\n\n      if (organization) {\n        throw new NotAcceptableException('Multi organization not supported - organization exist');\n      }\n    } else {\n      // Multi organization\n      if (this.configService.get<string>('DISABLE_SIGNUPS') === 'true') {\n        throw new NotAcceptableException();\n      }\n    }\n    // Create default organization\n    organization = await this.organizationsService.create('Untitled workspace');\n    const user = await this.usersService.create({ email }, organization.id, ['all_users', 'admin'], existingUser, true);\n    await this.organizationUsersService.create(user, organization, true);\n    await this.emailService.sendWelcomeEmail(user.email, user.firstName, user.invitationToken);\n\n    return {};\n  }\n\n  async forgotPassword(email: string) {\n    const user = await this.usersService.findByEmail(email);\n    const forgotPasswordToken = uuid.v4();\n    await this.usersService.update(user.id, { forgotPasswordToken });\n    await this.emailService.sendPasswordResetEmail(email, forgotPasswordToken);\n  }\n\n  async resetPassword(token: string, password: string) {\n    const user = await this.usersService.findByPasswordResetToken(token);\n    if (!user) {\n      throw new NotFoundException('Invalid token');\n    } else {\n      await this.usersService.update(user.id, {\n        password,\n        forgotPasswordToken: null,\n      });\n    }\n  }\n}\n", "import { Injectable } from '@nestjs/common';\nconst nodemailer = require('nodemailer');\nconst previewEmail = require('preview-email');\n\n@Injectable()\nexport class EmailService {\n  private FROM_EMAIL;\n  private TOOLJET_HOST;\n  private NODE_ENV;\n\n  constructor() {\n    this.FROM_EMAIL = process.env.DEFAULT_FROM_EMAIL || 'hello@tooljet.io';\n    this.TOOLJET_HOST = this.stripTrailingSlash(process.env.TOOLJET_HOST);\n    this.NODE_ENV = process.env.NODE_ENV || 'development';\n  }\n\n  async sendEmail(to: string, subject: string, html: string) {\n    if (this.NODE_ENV === 'test') return;\n\n    const port = +process.env.SMTP_PORT || 587;\n    const transporter = nodemailer.createTransport({\n      host: process.env.SMTP_DOMAIN,\n      port: port,\n      secure: port == 465,\n      auth: {\n        user: process.env.SMTP_USERNAME,\n        pass: process.env.SMTP_PASSWORD,\n      },\n    });\n\n    const message = {\n      from: `\"ToolJet\" <${this.FROM_EMAIL}>`,\n      to,\n      subject,\n      html,\n    };\n\n    /* if development environment, log the content of email instead of sending actual emails */\n    if (this.NODE_ENV === 'development') {\n      console.log('Captured email');\n      console.log('to: ', to);\n      console.log('Subject: ', subject);\n      console.log('content: ', html);\n\n      previewEmail(message).then(console.log).catch(console.error);\n    } else {\n      const info = await transporter.sendMail(message);\n      console.log('Message sent: %s', info);\n    }\n  }\n\n  stripTrailingSlash(hostname: string) {\n    return hostname?.endsWith('/') ? hostname.slice(0, -1) : hostname;\n  }\n\n  async sendWelcomeEmail(to: string, name: string, invitationtoken: string) {\n    const subject = 'Welcome to ToolJet';\n    const inviteUrl = `${this.TOOLJET_HOST}/invitations/${invitationtoken}`;\n    const html = `\n      <!DOCTYPE html>\n      <html>\n        <head>\n          <meta content='text/html; charset=UTF-8' http-equiv='Content-Type' />\n        </head>\n        <body>\n          <p>Hi ${name || ''},</p>\n          <span>\n            Please use the link below to set up your account and get started.\n          </span>\n          <br>\n          <a href=\"${inviteUrl}\">${inviteUrl}</a>\n          <br>\n          <p>\n            Welcome aboard,<br>\n            ToolJet Team\n          </p>\n        </body>\n      </html>\n    `;\n\n    await this.sendEmail(to, subject, html);\n  }\n\n  async sendOrganizationUserWelcomeEmail(\n    to: string,\n    name: string,\n    sender: string,\n    invitationtoken: string,\n    organisationName: string\n  ) {\n    const subject = 'Welcome to ToolJet';\n    const inviteUrl = `${this.TOOLJET_HOST}/organization-invitations/${invitationtoken}`;\n    const html = `\n      <!DOCTYPE html>\n      <html>\n        <head>\n          <meta content='text/html; charset=UTF-8' http-equiv='Content-Type' />\n        </head>\n        <body>\n          <p>Hi ${name || ''},</p>\n          <br>\n          <span>\n          ${sender} has invited you to use ToolJet workspace ${organisationName}. Use the link below to set up your account and get started.\n          </span>\n          <br>\n          <a href=\"${inviteUrl}\">${inviteUrl}</a>\n          <br>\n          <br>\n          <p>\n            Welcome aboard,<br>\n            ToolJet Team\n          </p>\n        </body>\n      </html>\n    `;\n\n    await this.sendEmail(to, subject, html);\n  }\n\n  async sendPasswordResetEmail(to: string, token: string) {\n    const subject = 'password reset instructions';\n    const html = `\n      Please use this code to reset your password: ${token}\n    `;\n    await this.sendEmail(to, subject, html);\n  }\n}\n", "import { Injectable } from '@nestjs/common';\nimport { InjectRepository } from '@nestjs/typeorm';\nimport { User } from '../entities/user.entity';\nimport { createQueryBuilder, getManager, Repository } from 'typeorm';\nimport { UsersService } from 'src/services/users.service';\nimport { OrganizationUser } from 'src/entities/organization_user.entity';\nimport { BadRequestException } from '@nestjs/common';\nimport { EmailService } from './email.service';\nimport { Organization } from 'src/entities/organization.entity';\nimport { GroupPermission } from 'src/entities/group_permission.entity';\nimport { InviteNewUserDto } from '@dto/invite-new-user.dto';\nconst uuid = require('uuid');\n\n@Injectable()\nexport class OrganizationUsersService {\n  constructor(\n    @InjectRepository(OrganizationUser)\n    private organizationUsersRepository: Repository<OrganizationUser>,\n    private usersService: UsersService,\n    private emailService: EmailService\n  ) {}\n\n  async findOrganization(id: string): Promise<OrganizationUser> {\n    return await this.organizationUsersRepository.findOne({ where: { id } });\n  }\n\n  async inviteNewUser(currentUser: User, inviteNewUserDto: InviteNewUserDto): Promise<OrganizationUser> {\n    const userParams = <User>{\n      firstName: inviteNewUserDto.first_name,\n      lastName: inviteNewUserDto.last_name,\n      email: inviteNewUserDto.email,\n    };\n\n    let user = await this.usersService.findByEmail(userParams.email);\n\n    if (user?.organizationUsers?.some((ou) => ou.organizationId === currentUser.organizationId)) {\n      throw new BadRequestException('User with such email already exists.');\n    }\n\n    if (user?.invitationToken) {\n      // user sign up not completed, name will be empty - updating name\n      await this.usersService.update(user.id, { firstName: userParams.firstName, lastName: userParams.lastName });\n    }\n\n    user = await this.usersService.create(userParams, currentUser.organizationId, ['all_users'], user);\n\n    const currentOrganization: Organization = (\n      await this.organizationUsersRepository.findOne({\n        where: { userId: currentUser.id, organizationId: currentUser.organizationId },\n        relations: ['organization'],\n      })\n    )?.organization;\n\n    const organizationUser: OrganizationUser = await this.create(user, currentOrganization, true);\n\n    await this.emailService.sendOrganizationUserWelcomeEmail(\n      user.email,\n      user.firstName,\n      currentUser.firstName,\n      organizationUser.invitationToken,\n      currentOrganization.name\n    );\n\n    return organizationUser;\n  }\n\n  async create(user: User, organization: Organization, isInvite?: boolean): Promise<OrganizationUser> {\n    return await this.organizationUsersRepository.save(\n      this.organizationUsersRepository.create({\n        user,\n        organization,\n        invitationToken: isInvite ? uuid.v4() : null,\n        status: isInvite ? 'invited' : 'active',\n        role: 'all-users',\n        createdAt: new Date(),\n        updatedAt: new Date(),\n      })\n    );\n  }\n\n  async changeRole(id: string, role: string) {\n    const organizationUser = await this.organizationUsersRepository.findOne({ where: { id } });\n    if (organizationUser.role == 'admin') {\n      const lastActiveAdmin = await this.lastActiveAdmin(organizationUser.organizationId);\n\n      if (lastActiveAdmin) {\n        throw new BadRequestException('Atleast one active admin is required.');\n      }\n    }\n    return await this.organizationUsersRepository.update(id, { role });\n  }\n\n  async archive(id: string) {\n    await getManager().transaction(async (manager) => {\n      const organizationUser = await manager.findOne(OrganizationUser, {\n        where: { id },\n      });\n      const user = await manager.findOne(User, {\n        where: { id: organizationUser.userId },\n      });\n\n      await this.usersService.throwErrorIfRemovingLastActiveAdmin(user, undefined, organizationUser.organizationId);\n\n      await manager.update(OrganizationUser, id, { status: 'archived', invitationToken: null });\n    });\n\n    return true;\n  }\n\n  async unarchive(user: User, id: string) {\n    const organizationUser = await this.organizationUsersRepository.findOne({\n      where: { id },\n    });\n    if (organizationUser.status !== 'archived') return false;\n\n    const invitationToken = uuid.v4();\n\n    await getManager().transaction(async (manager) => {\n      await manager.update(OrganizationUser, organizationUser.id, {\n        status: 'invited',\n        invitationToken,\n      });\n      await manager.update(User, organizationUser.userId, { password: uuid.v4() });\n    });\n\n    const updatedUser = await this.usersService.findOne(organizationUser.userId);\n\n    const currentOrganization: Organization = (\n      await this.organizationUsersRepository.findOne({\n        where: { userId: user.id, organizationId: user.organizationId },\n        relations: ['organization'],\n      })\n    )?.organization;\n\n    await this.emailService.sendOrganizationUserWelcomeEmail(\n      updatedUser.email,\n      updatedUser.firstName,\n      user.firstName,\n      invitationToken,\n      currentOrganization.name\n    );\n\n    return true;\n  }\n\n  async activate(user: OrganizationUser) {\n    await this.organizationUsersRepository.update(user.id, {\n      status: 'active',\n    });\n  }\n\n  async lastActiveAdmin(organizationId: string): Promise<boolean> {\n    const adminsCount = await this.activeAdminCount(organizationId);\n\n    return adminsCount <= 1;\n  }\n\n  async activeAdminCount(organizationId: string) {\n    return await createQueryBuilder(GroupPermission, 'group_permissions')\n      .innerJoin('group_permissions.userGroupPermission', 'user_group_permission')\n      .where('group_permissions.group = :admin', { admin: 'admin' })\n      .andWhere('group_permissions.organization = :organizationId', { organizationId })\n      .getCount();\n  }\n}\n", "import { BadRequestException, Injectable } from '@nestjs/common';\nimport { InjectRepository } from '@nestjs/typeorm';\nimport { GroupPermission } from 'src/entities/group_permission.entity';\nimport { Organization } from 'src/entities/organization.entity';\nimport { SSOConfigs } from 'src/entities/sso_config.entity';\nimport { User } from 'src/entities/user.entity';\nimport { cleanObject } from 'src/helpers/utils.helper';\nimport { createQueryBuilder, Repository } from 'typeorm';\nimport { OrganizationUser } from '../entities/organization_user.entity';\nimport { EncryptionService } from './encryption.service';\nimport { GroupPermissionsService } from './group_permissions.service';\nimport { OrganizationUsersService } from './organization_users.service';\nimport { UsersService } from './users.service';\n\n@Injectable()\nexport class OrganizationsService {\n  constructor(\n    @InjectRepository(Organization)\n    private organizationsRepository: Repository<Organization>,\n    @InjectRepository(SSOConfigs)\n    private ssoConfigRepository: Repository<SSOConfigs>,\n    @InjectRepository(OrganizationUser)\n    private organizationUsersRepository: Repository<OrganizationUser>,\n    @InjectRepository(GroupPermission)\n    private groupPermissionsRepository: Repository<GroupPermission>,\n    private usersService: UsersService,\n    private organizationUserService: OrganizationUsersService,\n    private groupPermissionService: GroupPermissionsService,\n    private encryptionService: EncryptionService\n  ) {}\n\n  async create(name: string, user?: User): Promise<Organization> {\n    const organization = await this.organizationsRepository.save(\n      this.organizationsRepository.create({\n        ssoConfigs: [\n          {\n            sso: 'form',\n            enabled: true,\n          },\n        ],\n        name,\n        createdAt: new Date(),\n        updatedAt: new Date(),\n      })\n    );\n\n    const createdGroupPermissions = await this.createDefaultGroupPermissionsForOrganization(organization);\n\n    if (user) {\n      await this.organizationUserService.create(user, organization, false);\n\n      for (const groupPermission of createdGroupPermissions) {\n        await this.groupPermissionService.createUserGroupPermission(user.id, groupPermission.id);\n      }\n    }\n\n    return organization;\n  }\n\n  async get(id: string): Promise<Organization> {\n    return await this.organizationsRepository.findOne({ where: { id }, relations: ['ssoConfigs'] });\n  }\n\n  async getSingleOrganization(): Promise<Organization> {\n    return await this.organizationsRepository.findOne({ relations: ['ssoConfigs'] });\n  }\n\n  async createDefaultGroupPermissionsForOrganization(organization: Organization) {\n    const defaultGroups = ['all_users', 'admin'];\n    const createdGroupPermissions = [];\n\n    for (const group of defaultGroups) {\n      const isAdmin = group === 'admin';\n      const groupPermission = this.groupPermissionsRepository.create({\n        organizationId: organization.id,\n        group: group,\n        appCreate: isAdmin,\n        appDelete: isAdmin,\n        folderCreate: isAdmin,\n      });\n      await this.groupPermissionsRepository.save(groupPermission);\n      createdGroupPermissions.push(groupPermission);\n    }\n\n    return createdGroupPermissions;\n  }\n\n  async fetchUsers(user: any): Promise<OrganizationUser[]> {\n    const organizationUsers = await this.organizationUsersRepository.find({\n      where: { organizationId: user.organizationId },\n      relations: ['user'],\n    });\n\n    const isAdmin = await this.usersService.hasGroup(user, 'admin');\n\n    // serialize\n    const serializedUsers = [];\n    for (const orgUser of organizationUsers) {\n      const serializedUser = {\n        email: orgUser.user.email,\n        firstName: orgUser.user.firstName,\n        lastName: orgUser.user.lastName,\n        name: `${orgUser.user.firstName} ${orgUser.user.lastName}`,\n        id: orgUser.id,\n        role: orgUser.role,\n        status: orgUser.status,\n      };\n\n      if (isAdmin && orgUser.invitationToken) {\n        serializedUser['invitationToken'] = orgUser.invitationToken;\n      }\n      serializedUsers.push(serializedUser);\n    }\n\n    return serializedUsers;\n  }\n\n  async fetchOrganisations(user: any): Promise<Organization[]> {\n    return await createQueryBuilder(Organization, 'organization')\n      .innerJoin(\n        'organization.organizationUsers',\n        'organisation_users',\n        'organisation_users.status IN(:...statusList)',\n        {\n          statusList: ['active'],\n        }\n      )\n      .andWhere('organisation_users.userId = :userId', {\n        userId: user.id,\n      })\n      .orderBy('name', 'ASC')\n      .getMany();\n  }\n\n  async findOrganizationSupportsFormLogin(user: any): Promise<Organization[]> {\n    return await createQueryBuilder(Organization, 'organization')\n      .innerJoin('organization.ssoConfigs', 'organisation_sso', 'organisation_sso.sso = :form', {\n        form: 'form',\n      })\n      .innerJoin(\n        'organization.organizationUsers',\n        'organisation_users',\n        'organisation_users.status IN(:...statusList)',\n        {\n          statusList: ['active'],\n        }\n      )\n      .where('organisation_sso.enabled = :enabled', {\n        enabled: true,\n      })\n      .andWhere('organisation_users.userId = :userId', {\n        userId: user.id,\n      })\n      .orderBy('name', 'ASC')\n      .getMany();\n  }\n\n  async getSSOConfigs(organizationId: string, sso: string): Promise<Organization> {\n    return await createQueryBuilder(Organization, 'organization')\n      .leftJoinAndSelect('organization.ssoConfigs', 'organisation_sso', 'organisation_sso.sso = :sso', {\n        sso,\n      })\n      .andWhere('organization.id = :organizationId', {\n        organizationId,\n      })\n      .getOne();\n  }\n\n  async fetchOrganisationDetails(\n    organizationId: string,\n    statusList?: Array<boolean>,\n    isHideSensitiveData?: boolean\n  ): Promise<Organization> {\n    const result = await createQueryBuilder(Organization, 'organization')\n      .innerJoinAndSelect(\n        'organization.ssoConfigs',\n        'organisation_sso',\n        'organisation_sso.enabled IN (:...statusList)',\n        {\n          statusList: statusList || [true, false], // Return enabled and disabled sso if status list not passed\n        }\n      )\n      .andWhere('organization.id = :organizationId', {\n        organizationId,\n      })\n      .getOne();\n\n    if (!(result?.ssoConfigs?.length > 0)) {\n      return;\n    }\n\n    for (const sso of result?.ssoConfigs) {\n      await this.decryptSecret(sso?.configs);\n    }\n\n    if (!isHideSensitiveData) {\n      return result;\n    }\n    return this.hideSSOSensitiveData(result?.ssoConfigs, result?.name);\n  }\n\n  private hideSSOSensitiveData(ssoConfigs: SSOConfigs[], organizationName): any {\n    const configs = { name: organizationName };\n    if (ssoConfigs?.length > 0) {\n      for (const config of ssoConfigs) {\n        const configId = config['id'];\n        delete config['id'];\n        delete config['organizationId'];\n        delete config['createdAt'];\n        delete config['updatedAt'];\n\n        configs[config.sso] = this.buildConfigs(config, configId);\n      }\n    }\n    return configs;\n  }\n\n  private buildConfigs(config: any, configId: string) {\n    if (!config) return config;\n    return {\n      ...config,\n      configs: {\n        ...(config?.configs || {}),\n        ...(config?.configs ? { clientSecret: '' } : {}),\n      },\n      configId,\n    };\n  }\n\n  private async encryptSecret(configs) {\n    if (!configs || typeof configs !== 'object') return configs;\n    await Promise.all(\n      Object.keys(configs).map(async (key) => {\n        if (key.toLowerCase().includes('secret')) {\n          if (configs[key]) {\n            configs[key] = await this.encryptionService.encryptColumnValue('ssoConfigs', key, configs[key]);\n          }\n        }\n      })\n    );\n  }\n\n  private async decryptSecret(configs) {\n    if (!configs || typeof configs !== 'object') return configs;\n    await Promise.all(\n      Object.keys(configs).map(async (key) => {\n        if (key.toLowerCase().includes('secret')) {\n          if (configs[key]) {\n            configs[key] = await this.encryptionService.decryptColumnValue('ssoConfigs', key, configs[key]);\n          }\n        }\n      })\n    );\n  }\n\n  async updateOrganization(organizationId: string, params) {\n    const { name, domain, enableSignUp } = params;\n\n    const updateableParams = {\n      name,\n      domain,\n      enableSignUp,\n    };\n\n    // removing keys with undefined values\n    cleanObject(updateableParams);\n\n    return await this.organizationsRepository.update(organizationId, updateableParams);\n  }\n\n  async updateOrganizationConfigs(organizationId: string, params: any) {\n    const { type, configs, enabled } = params;\n\n    if (!(type && ['git', 'google', 'form'].includes(type))) {\n      throw new BadRequestException();\n    }\n\n    await this.encryptSecret(configs);\n    const organization: Organization = await this.getSSOConfigs(organizationId, type);\n\n    if (organization?.ssoConfigs?.length > 0) {\n      const ssoConfigs: SSOConfigs = organization.ssoConfigs[0];\n\n      const updateableParams = {\n        configs,\n        enabled,\n      };\n\n      // removing keys with undefined values\n      cleanObject(updateableParams);\n      return await this.ssoConfigRepository.update(ssoConfigs.id, updateableParams);\n    } else {\n      const newSSOConfigs = this.ssoConfigRepository.create({\n        organization,\n        sso: type,\n        configs,\n        enabled: !!enabled,\n      });\n      return await this.ssoConfigRepository.save(newSSOConfigs);\n    }\n  }\n\n  async getConfigs(id: string): Promise<SSOConfigs> {\n    const result: SSOConfigs = await this.ssoConfigRepository.findOne({\n      where: { id, enabled: true },\n      relations: ['organization'],\n    });\n    await this.decryptSecret(result?.configs);\n    return result;\n  }\n}\n", "import { Injectable, InternalServerErrorException } from '@nestjs/common';\nimport { InjectRepository } from '@nestjs/typeorm';\nimport { User } from '../entities/user.entity';\nimport { FilesService } from '../services/files.service';\nimport { Organization } from 'src/entities/organization.entity';\nimport { App } from 'src/entities/app.entity';\nimport { Connection, createQueryBuilder, EntityManager, getManager, getRepository, In, Repository } from 'typeorm';\nimport { OrganizationUser } from '../entities/organization_user.entity';\nimport { AppGroupPermission } from 'src/entities/app_group_permission.entity';\nimport { UserGroupPermission } from 'src/entities/user_group_permission.entity';\nimport { GroupPermission } from 'src/entities/group_permission.entity';\nimport { BadRequestException } from '@nestjs/common';\nimport { cleanObject } from 'src/helpers/utils.helper';\nimport { CreateUserDto } from '@dto/user.dto';\nimport { CreateFileDto } from '@dto/create-file.dto';\nconst uuid = require('uuid');\nconst bcrypt = require('bcrypt');\n\n@Injectable()\nexport class UsersService {\n  constructor(\n    private readonly filesService: FilesService,\n    private connection: Connection,\n    @InjectRepository(User)\n    private usersRepository: Repository<User>,\n    @InjectRepository(OrganizationUser)\n    private organizationUsersRepository: Repository<OrganizationUser>,\n    @InjectRepository(Organization)\n    private organizationsRepository: Repository<Organization>,\n    @InjectRepository(App)\n    private appsRepository: Repository<App>\n  ) {}\n\n  async findOne(id: string): Promise<User> {\n    return this.usersRepository.findOne({ where: { id } });\n  }\n\n  async findByEmail(email: string, organisationId?: string): Promise<User> {\n    if (!organisationId) {\n      return this.usersRepository.findOne({\n        where: { email },\n      });\n    } else {\n      return await createQueryBuilder(User, 'users')\n        .innerJoinAndSelect(\n          'users.organizationUsers',\n          'organization_users',\n          'organization_users.organizationId = :organisationId',\n          { organisationId }\n        )\n        .where('organization_users.status = :active', { active: 'active' })\n        .andWhere('users.email = :email', { email })\n        .getOne();\n    }\n  }\n\n  async findByPasswordResetToken(token: string): Promise<User> {\n    return this.usersRepository.findOne({\n      where: { forgotPasswordToken: token },\n    });\n  }\n\n  async create(\n    userParams: any,\n    organizationId: string,\n    groups?: string[],\n    existingUser?: User,\n    isInvite?: boolean\n  ): Promise<User> {\n    const password = uuid.v4();\n\n    const { email, firstName, lastName } = userParams;\n    let user: User;\n\n    await getManager().transaction(async (manager) => {\n      if (!existingUser) {\n        user = manager.create(User, {\n          email,\n          firstName,\n          lastName,\n          password,\n          invitationToken: isInvite ? uuid.v4() : null,\n          defaultOrganizationId: organizationId,\n          createdAt: new Date(),\n          updatedAt: new Date(),\n        });\n        await manager.save(user);\n      } else {\n        if (isInvite) {\n          // user already invited to an organization, but not active - user tries to sign up\n          await manager.save(\n            Object.assign(existingUser, {\n              invitationToken: uuid.v4(),\n              defaultOrganizationId: organizationId,\n            })\n          );\n        }\n        user = existingUser;\n      }\n\n      for (const group of groups) {\n        const orgGroupPermission = await manager.findOne(GroupPermission, {\n          where: {\n            organizationId: organizationId,\n            group: group,\n          },\n        });\n\n        if (orgGroupPermission) {\n          const userGroupPermission = manager.create(UserGroupPermission, {\n            groupPermissionId: orgGroupPermission.id,\n            userId: user.id,\n          });\n          await manager.save(userGroupPermission);\n        } else {\n          throw new BadRequestException(`${group} group does not exist for current organization`);\n        }\n      }\n    });\n\n    return user;\n  }\n\n  async status(user: User) {\n    const orgUser = await this.organizationUsersRepository.findOne({ where: { user } });\n    return orgUser.status;\n  }\n\n  async findOrCreateByEmail(userParams: any, organizationId: string): Promise<{ user: User; newUserCreated: boolean }> {\n    let user: User;\n    let newUserCreated = false;\n\n    user = await this.findByEmail(userParams.email);\n\n    if (user?.organizationUsers?.some((ou) => ou.organizationId === organizationId)) {\n      // User exist in current organization\n      return { user, newUserCreated };\n    }\n\n    const groups = ['all_users'];\n    user = await this.create({ ...userParams }, organizationId, groups, user);\n    newUserCreated = true;\n\n    return { user, newUserCreated };\n  }\n\n  async setupAccountFromInvitationToken(userCreateDto: CreateUserDto) {\n    const { organization, password, token, role, first_name: firstName, last_name: lastName } = userCreateDto;\n\n    if (!token) {\n      throw new BadRequestException('Invalid token');\n    }\n\n    const user: User = await this.usersRepository.findOne({ where: { invitationToken: token } });\n\n    if (!user?.organizationUsers) {\n      throw new BadRequestException('Invalid invitation link');\n    }\n    const organizationUser: OrganizationUser = user.organizationUsers.find(\n      (ou) => ou.organizationId === user.defaultOrganizationId\n    );\n\n    if (!organizationUser) {\n      throw new BadRequestException('Invalid invitation link');\n    }\n\n    await this.usersRepository.save(\n      Object.assign(user, {\n        firstName,\n        lastName,\n        password,\n        role,\n        invitationToken: null,\n      })\n    );\n\n    await this.organizationUsersRepository.save(\n      Object.assign(organizationUser, {\n        invitationToken: null,\n        status: 'active',\n      })\n    );\n\n    if (organization) {\n      await this.organizationsRepository.update(user.defaultOrganizationId, {\n        name: organization,\n      });\n    }\n  }\n\n  async acceptOrganizationInvite(params: any) {\n    const { password, token } = params;\n\n    const organizationUser = await this.organizationUsersRepository.findOne({\n      where: { invitationToken: token },\n      relations: ['user'],\n    });\n\n    if (!organizationUser?.user) {\n      throw new BadRequestException('Invalid invitation link');\n    }\n    const user: User = organizationUser.user;\n\n    if (user.invitationToken) {\n      // User sign up link send - not activated account\n      const defaultOrganizationUser = await this.organizationUsersRepository.findOne({\n        where: { organizationId: user.defaultOrganizationId, status: 'invited' },\n      });\n\n      if (defaultOrganizationUser) {\n        await this.organizationUsersRepository.save(\n          Object.assign(defaultOrganizationUser, {\n            invitationToken: null,\n            status: 'active',\n          })\n        );\n      }\n    }\n\n    // set new password if entered\n    await this.usersRepository.save(\n      Object.assign(user, {\n        ...(password ? { password } : {}),\n        invitationToken: null,\n      })\n    );\n\n    await this.organizationUsersRepository.save(\n      Object.assign(organizationUser, {\n        invitationToken: null,\n        status: 'active',\n      })\n    );\n  }\n\n  async updateDefaultOrganization(user: User, organizationId: string) {\n    await this.usersRepository.update(user.id, { defaultOrganizationId: organizationId });\n  }\n\n  async update(userId: string, params: any, manager?: EntityManager, organizationId?: string) {\n    const { forgotPasswordToken, password, firstName, lastName, addGroups, removeGroups } = params;\n\n    const hashedPassword = password ? bcrypt.hashSync(password, 10) : undefined;\n\n    const updateableParams = {\n      forgotPasswordToken,\n      firstName,\n      lastName,\n      password: hashedPassword,\n    };\n\n    // removing keys with undefined values\n    cleanObject(updateableParams);\n\n    let user: User;\n\n    const performUpdateInTransaction = async (manager) => {\n      await manager.update(User, userId, { ...updateableParams });\n      user = await manager.findOne(User, { where: { id: userId } });\n\n      await this.removeUserGroupPermissionsIfExists(manager, user, removeGroups, organizationId);\n\n      await this.addUserGroupPermissions(manager, user, addGroups, organizationId);\n    };\n\n    if (manager) {\n      await performUpdateInTransaction(manager);\n    } else {\n      await getManager().transaction(async (manager) => {\n        await performUpdateInTransaction(manager);\n      });\n    }\n\n    return user;\n  }\n\n  async addUserGroupPermissions(manager: EntityManager, user: User, addGroups: string[], organizationId?: string) {\n    const orgId = organizationId || user.defaultOrganizationId;\n    if (addGroups) {\n      const orgGroupPermissions = await this.groupPermissionsForOrganization(orgId);\n\n      for (const group of addGroups) {\n        const orgGroupPermission = orgGroupPermissions.find((permission) => permission.group == group);\n\n        if (orgGroupPermission) {\n          const userGroupPermission = manager.create(UserGroupPermission, {\n            groupPermissionId: orgGroupPermission.id,\n            userId: user.id,\n          });\n          await manager.save(userGroupPermission);\n        } else {\n          throw new BadRequestException(`${group} group does not exist for current organization`);\n        }\n      }\n    }\n  }\n\n  async removeUserGroupPermissionsIfExists(\n    manager: EntityManager,\n    user: User,\n    removeGroups: string[],\n    organizationId?: string\n  ) {\n    const orgId = organizationId || user.defaultOrganizationId;\n    if (removeGroups) {\n      await this.throwErrorIfRemovingLastActiveAdmin(user, removeGroups, orgId);\n      if (removeGroups.includes('all_users')) {\n        throw new BadRequestException('Cannot remove user from default group.');\n      }\n\n      const groupPermissions = await manager.find(GroupPermission, {\n        group: In(removeGroups),\n        organizationId: orgId,\n      });\n      const groupIdsToMaybeRemove = groupPermissions.map((permission) => permission.id);\n\n      await manager.delete(UserGroupPermission, {\n        groupPermissionId: In(groupIdsToMaybeRemove),\n        userId: user.id,\n      });\n    }\n  }\n\n  async throwErrorIfRemovingLastActiveAdmin(user: User, removeGroups: string[] = ['admin'], organizationId: string) {\n    const removingAdmin = removeGroups.includes('admin');\n    if (!removingAdmin) return;\n\n    const result = await createQueryBuilder(User, 'users')\n      .innerJoin('users.groupPermissions', 'group_permissions')\n      .innerJoin('users.organizationUsers', 'organization_users')\n      .where('organization_users.user_id != :userId', { userId: user.id })\n      .andWhere('organization_users.status = :status', { status: 'active' })\n      .andWhere('group_permissions.group = :group', { group: 'admin' })\n      .andWhere('group_permissions.organization_id = :organizationId', {\n        organizationId,\n      })\n      .getCount();\n\n    if (result == 0) throw new BadRequestException('Atleast one active admin is required.');\n  }\n\n  async hasGroup(user: User, group: string, organizationId?: string): Promise<boolean> {\n    const orgId = organizationId || user.organizationId;\n\n    const result = await createQueryBuilder(GroupPermission, 'group_permissions')\n      .innerJoin('group_permissions.userGroupPermission', 'user_group_permissions')\n      .where('group_permissions.organization_id = :organizationId', {\n        organizationId: orgId,\n      })\n      .andWhere('group_permissions.group = :group ', { group })\n      .andWhere('user_group_permissions.user_id = :userId', { userId: user.id })\n      .getCount();\n\n    return result > 0;\n  }\n\n  async userCan(user: User, action: string, entityName: string, resourceId?: string): Promise<boolean> {\n    switch (entityName) {\n      case 'App':\n        return await this.canUserPerformActionOnApp(user, action, resourceId);\n\n      case 'User':\n        return await this.hasGroup(user, 'admin');\n\n      case 'Thread':\n      case 'Comment':\n        return await this.canUserPerformActionOnApp(user, 'update', resourceId);\n\n      case 'Folder':\n        return await this.canUserPerformActionOnFolder(user, action);\n\n      default:\n        return false;\n    }\n  }\n\n  async canUserPerformActionOnApp(user: User, action: string, appId?: string): Promise<boolean> {\n    let permissionGrant: boolean;\n\n    switch (action) {\n      case 'create':\n        permissionGrant = this.canAnyGroupPerformAction('appCreate', await this.groupPermissions(user));\n        break;\n      case 'read':\n      case 'update':\n        permissionGrant =\n          this.canAnyGroupPerformAction(action, await this.appGroupPermissions(user, appId)) ||\n          (await this.isUserOwnerOfApp(user, appId));\n        break;\n      case 'delete':\n        permissionGrant =\n          this.canAnyGroupPerformAction('delete', await this.appGroupPermissions(user, appId)) ||\n          this.canAnyGroupPerformAction('appDelete', await this.groupPermissions(user)) ||\n          (await this.isUserOwnerOfApp(user, appId));\n        break;\n      default:\n        permissionGrant = false;\n        break;\n    }\n\n    return permissionGrant;\n  }\n\n  async canUserPerformActionOnFolder(user: User, action: string): Promise<boolean> {\n    let permissionGrant: boolean;\n\n    switch (action) {\n      case 'create':\n        permissionGrant = this.canAnyGroupPerformAction('folderCreate', await this.groupPermissions(user));\n        break;\n      default:\n        permissionGrant = false;\n        break;\n    }\n\n    return permissionGrant;\n  }\n\n  async isUserOwnerOfApp(user: User, appId: string): Promise<boolean> {\n    const app: App = await this.appsRepository.findOne({\n      where: {\n        id: appId,\n        userId: user.id,\n      },\n    });\n    return !!app && app.organizationId === user.organizationId;\n  }\n\n  async addAvatar(userId: number, imageBuffer: Buffer, filename: string) {\n    const queryRunner = this.connection.createQueryRunner();\n\n    await queryRunner.connect();\n    await queryRunner.startTransaction();\n\n    try {\n      const user = await queryRunner.manager.findOne(User, userId);\n      const currentAvatarId = user.avatarId;\n      const createFileDto = new CreateFileDto();\n      createFileDto.filename = filename;\n      createFileDto.data = imageBuffer;\n      const avatar = await this.filesService.create(createFileDto, queryRunner);\n\n      await queryRunner.manager.update(User, userId, {\n        avatarId: avatar.id,\n      });\n\n      if (currentAvatarId) {\n        await this.filesService.remove(currentAvatarId, queryRunner);\n      }\n\n      await queryRunner.commitTransaction();\n\n      return avatar;\n    } catch (error) {\n      await queryRunner.rollbackTransaction();\n      throw new InternalServerErrorException(error);\n    } finally {\n      await queryRunner.release();\n    }\n  }\n\n  canAnyGroupPerformAction(action: string, permissions: AppGroupPermission[] | GroupPermission[]): boolean {\n    return permissions.some((p) => p[action]);\n  }\n\n  async groupPermissions(user: User): Promise<GroupPermission[]> {\n    const orgUserGroupPermissions = await this.userGroupPermissions(user, user.organizationId);\n    const groupIds = orgUserGroupPermissions.map((p) => p.groupPermissionId);\n    const groupPermissionRepository = getRepository(GroupPermission);\n\n    return await groupPermissionRepository.findByIds(groupIds);\n  }\n\n  async groupPermissionsForOrganization(organizationId: string) {\n    const groupPermissionRepository = getRepository(GroupPermission);\n\n    return await groupPermissionRepository.find({ organizationId });\n  }\n\n  async appGroupPermissions(user: User, appId?: string): Promise<AppGroupPermission[]> {\n    const orgUserGroupPermissions = await this.userGroupPermissions(user, user.organizationId);\n    const groupIds = orgUserGroupPermissions.map((p) => p.groupPermissionId);\n\n    if (!groupIds || groupIds.length === 0) {\n      return [];\n    }\n\n    const query = createQueryBuilder(AppGroupPermission, 'app_group_permissions')\n      .innerJoin(\n        'app_group_permissions.groupPermission',\n        'group_permissions',\n        'group_permissions.organization_id = :organizationId',\n        {\n          organizationId: user.organizationId,\n        }\n      )\n      .where('app_group_permissions.groupPermissionId IN (:...groupIds)', { groupIds });\n\n    if (appId) {\n      query.andWhere('app_group_permissions.appId = :appId', { appId });\n    }\n    return await query.getMany();\n  }\n\n  async userGroupPermissions(user: User, organizationId?: string): Promise<UserGroupPermission[]> {\n    const orgId = organizationId || user.organizationId;\n\n    return await createQueryBuilder(UserGroupPermission, 'user_group_permissions')\n      .innerJoin('user_group_permissions.groupPermission', 'group_permissions')\n      .where('group_permissions.organization_id = :organizationId', {\n        organizationId: orgId,\n      })\n      .andWhere('user_group_permissions.user_id = :userId', { userId: user.id })\n      .getMany();\n  }\n}\n", "/* eslint-disable @typescript-eslint/no-unused-vars */\nimport * as request from 'supertest';\nimport { INestApplication } from '@nestjs/common';\nimport { getManager, Repository } from 'typeorm';\nimport { User } from 'src/entities/user.entity';\nimport { clearDB, createUser, authHeaderForUser, createNestAppInstanceWithEnvMock } from '../test.helper';\nimport { OrganizationUser } from 'src/entities/organization_user.entity';\nimport { Organization } from 'src/entities/organization.entity';\nimport { SSOConfigs } from 'src/entities/sso_config.entity';\nimport { EmailService } from '@services/email.service';\n\ndescribe('Authentication', () => {\n  let app: INestApplication;\n  let userRepository: Repository<User>;\n  let orgRepository: Repository<Organization>;\n  let orgUserRepository: Repository<OrganizationUser>;\n  let ssoConfigsRepository: Repository<SSOConfigs>;\n  let mockConfig;\n  let current_organization: Organization;\n  let current_user: User;\n\n  beforeEach(async () => {\n    await clearDB();\n  });\n\n  beforeAll(async () => {\n    ({ app, mockConfig } = await createNestAppInstanceWithEnvMock());\n\n    userRepository = app.get('UserRepository');\n    orgRepository = app.get('OrganizationRepository');\n    orgUserRepository = app.get('OrganizationUserRepository');\n    ssoConfigsRepository = app.get('SSOConfigsRepository');\n  });\n\n  afterEach(() => {\n    jest.resetAllMocks();\n    jest.clearAllMocks();\n  });\n\n  describe('Single organization', () => {\n    beforeEach(async () => {\n      jest.spyOn(mockConfig, 'get').mockImplementation((key: string) => {\n        switch (key) {\n          case 'DISABLE_SIGNUPS':\n            return 'false';\n          case 'DISABLE_MULTI_WORKSPACE':\n            return 'true';\n          default:\n            return process.env[key];\n        }\n      });\n    });\n    it('should create new users and organization', async () => {\n      const response = await request(app.getHttpServer()).post('/api/signup').send({ email: 'test@tooljet.io' });\n      expect(response.statusCode).toBe(201);\n\n      const user = await userRepository.findOneOrFail({\n        where: { email: 'test@tooljet.io' },\n        relations: ['organizationUsers'],\n      });\n\n      const organization = await orgRepository.findOneOrFail({\n        where: { id: user?.organizationUsers?.[0]?.organizationId },\n      });\n\n      expect(user.defaultOrganizationId).toBe(user?.organizationUsers?.[0]?.organizationId);\n      expect(organization.name).toBe('Untitled workspace');\n\n      const groupPermissions = await user.groupPermissions;\n      const groupNames = groupPermissions.map((x) => x.group);\n\n      expect(new Set(['all_users', 'admin'])).toEqual(new Set(groupNames));\n\n      const adminGroup = groupPermissions.find((x) => x.group == 'admin');\n      expect(adminGroup.appCreate).toBeTruthy();\n      expect(adminGroup.appDelete).toBeTruthy();\n      expect(adminGroup.folderCreate).toBeTruthy();\n\n      const allUserGroup = groupPermissions.find((x) => x.group == 'all_users');\n      expect(allUserGroup.appCreate).toBeFalsy();\n      expect(allUserGroup.appDelete).toBeFalsy();\n      expect(allUserGroup.folderCreate).toBeFalsy();\n    });\n    describe('Single organization operations', () => {\n      beforeEach(async () => {\n        current_organization = (await createUser(app, { email: 'admin@tooljet.io' })).organization;\n      });\n      it('should not create new users since organization already exist', async () => {\n        const response = await request(app.getHttpServer()).post('/api/signup').send({ email: 'test@tooljet.io' });\n        expect(response.statusCode).toBe(406);\n      });\n      it('authenticate if valid credentials', async () => {\n        await request(app.getHttpServer())\n          .post('/api/authenticate')\n          .send({ email: 'admin@tooljet.io', password: 'password' })\n          .expect(201);\n      });\n      it('authenticate to organization if valid credentials', async () => {\n        await request(app.getHttpServer())\n          .post('/api/authenticate/' + current_organization.id)\n          .send({ email: 'admin@tooljet.io', password: 'password' })\n          .expect(201);\n      });\n      it('throw unauthorized error if user not exist in given organization if valid credentials', async () => {\n        await request(app.getHttpServer())\n          .post('/api/authenticate/82249621-efc1-4cd2-9986-5c22182fa8a7')\n          .send({ email: 'admin@tooljet.io', password: 'password' })\n          .expect(401);\n      });\n      it('throw 401 if user is archived', async () => {\n        await createUser(app, { email: 'user@tooljet.io', status: 'archived' });\n\n        await request(app.getHttpServer())\n          .post('/api/authenticate')\n          .send({ email: 'user@tooljet.io', password: 'password' })\n          .expect(401);\n\n        const adminUser = await userRepository.findOneOrFail({\n          email: 'admin@tooljet.io',\n        });\n        await orgUserRepository.update({ userId: adminUser.id }, { status: 'archived' });\n\n        await request(app.getHttpServer())\n          .get('/api/organizations/users')\n          .set('Authorization', authHeaderForUser(adminUser))\n          .expect(401);\n      });\n      it('throw 401 if invalid credentials', async () => {\n        await request(app.getHttpServer())\n          .post('/api/authenticate')\n          .send({ email: 'amdin@tooljet.io', password: 'pwd' })\n          .expect(401);\n      });\n      it('should throw 401 if form login is disabled', async () => {\n        await ssoConfigsRepository.update({ organizationId: current_organization.id }, { enabled: false });\n        await request(app.getHttpServer())\n          .post('/api/authenticate')\n          .send({ email: 'admin@tooljet.io', password: 'password' })\n          .expect(401);\n      });\n    });\n  });\n\n  describe('Multi organization', () => {\n    beforeEach(async () => {\n      const { organization, user } = await createUser(app, {\n        email: 'admin@tooljet.io',\n        firstName: 'user',\n        lastName: 'name',\n      });\n      current_organization = organization;\n      current_user = user;\n      jest.spyOn(mockConfig, 'get').mockImplementation((key: string) => {\n        switch (key) {\n          case 'DISABLE_SIGNUPS':\n            return 'false';\n          default:\n            return process.env[key];\n        }\n      });\n    });\n    describe('sign up disabled', () => {\n      beforeEach(async () => {\n        jest.spyOn(mockConfig, 'get').mockImplementation((key: string) => {\n          switch (key) {\n            case 'DISABLE_SIGNUPS':\n              return 'true';\n            default:\n              return process.env[key];\n          }\n        });\n      });\n      it('should not create new users', async () => {\n        const response = await request(app.getHttpServer()).post('/api/signup').send({ email: 'test@tooljet.io' });\n        expect(response.statusCode).toBe(406);\n      });\n    });\n    describe('sign up enabled and authorization', () => {\n      it('should create new users', async () => {\n        const response = await request(app.getHttpServer()).post('/api/signup').send({ email: 'test@tooljet.io' });\n        expect(response.statusCode).toBe(201);\n\n        const user = await userRepository.findOneOrFail({\n          where: { email: 'test@tooljet.io' },\n          relations: ['organizationUsers'],\n        });\n\n        const organization = await orgRepository.findOneOrFail({\n          where: { id: user?.organizationUsers?.[0]?.organizationId },\n        });\n\n        expect(user.defaultOrganizationId).toBe(user?.organizationUsers?.[0]?.organizationId);\n        expect(organization?.name).toBe('Untitled workspace');\n\n        const groupPermissions = await user.groupPermissions;\n        const groupNames = groupPermissions.map((x) => x.group);\n\n        expect(new Set(['all_users', 'admin'])).toEqual(new Set(groupNames));\n\n        const adminGroup = groupPermissions.find((x) => x.group == 'admin');\n        expect(adminGroup.appCreate).toBeTruthy();\n        expect(adminGroup.appDelete).toBeTruthy();\n        expect(adminGroup.folderCreate).toBeTruthy();\n\n        const allUserGroup = groupPermissions.find((x) => x.group == 'all_users');\n        expect(allUserGroup.appCreate).toBeFalsy();\n        expect(allUserGroup.appDelete).toBeFalsy();\n        expect(allUserGroup.folderCreate).toBeFalsy();\n      });\n      it('authenticate if valid credentials', async () => {\n        await request(app.getHttpServer())\n          .post('/api/authenticate')\n          .send({ email: 'admin@tooljet.io', password: 'password' })\n          .expect(201);\n      });\n      it('authenticate to organization if valid credentials', async () => {\n        await request(app.getHttpServer())\n          .post('/api/authenticate/' + current_organization.id)\n          .send({ email: 'admin@tooljet.io', password: 'password' })\n          .expect(201);\n      });\n      it('throw unauthorized error if user not exist in given organization if valid credentials', async () => {\n        await request(app.getHttpServer())\n          .post('/api/authenticate/82249621-efc1-4cd2-9986-5c22182fa8a7')\n          .send({ email: 'admin@tooljet.io', password: 'password' })\n          .expect(401);\n      });\n      it('throw 401 if user is archived', async () => {\n        await createUser(app, { email: 'user@tooljet.io', status: 'archived' });\n\n        await request(app.getHttpServer())\n          .post('/api/authenticate')\n          .send({ email: 'user@tooljet.io', password: 'password' })\n          .expect(401);\n\n        const adminUser = await userRepository.findOneOrFail({\n          email: 'admin@tooljet.io',\n        });\n        await orgUserRepository.update({ userId: adminUser.id }, { status: 'archived' });\n\n        await request(app.getHttpServer())\n          .get('/api/organizations/users')\n          .set('Authorization', authHeaderForUser(adminUser))\n          .expect(401);\n      });\n      it('throw 401 if invalid credentials', async () => {\n        await request(app.getHttpServer())\n          .post('/api/authenticate')\n          .send({ email: 'amdin@tooljet.io', password: 'pwd' })\n          .expect(401);\n      });\n      it('should throw 401 if form login is disabled', async () => {\n        await ssoConfigsRepository.update({ organizationId: current_organization.id }, { enabled: false });\n        await request(app.getHttpServer())\n          .post('/api/authenticate/' + current_organization.id)\n          .send({ email: 'admin@tooljet.io', password: 'password' })\n          .expect(401);\n      });\n      it('should create new organization if login is disabled for default organization', async () => {\n        await ssoConfigsRepository.update({ organizationId: current_organization.id }, { enabled: false });\n        const response = await request(app.getHttpServer())\n          .post('/api/authenticate')\n          .send({ email: 'admin@tooljet.io', password: 'password' });\n        expect(response.statusCode).toBe(201);\n        expect(response.body.organization_id).not.toBe(current_organization.id);\n        expect(response.body.organization).toBe('Untitled workspace');\n      });\n      it('should be able to switch between organizations with admin privilage', async () => {\n        const { organization: invited_organization } = await createUser(\n          app,\n          { organizationName: 'New Organization' },\n          current_user\n        );\n        const response = await request(app.getHttpServer())\n          .get('/api/switch/' + invited_organization.id)\n          .set('Authorization', authHeaderForUser(current_user));\n\n        expect(response.statusCode).toBe(200);\n        expect(Object.keys(response.body).sort()).toEqual(\n          [\n            'id',\n            'email',\n            'first_name',\n            'last_name',\n            'auth_token',\n            'admin',\n            'organization_id',\n            'organization',\n            'group_permissions',\n            'app_group_permissions',\n          ].sort()\n        );\n\n        const {\n          email,\n          first_name,\n          last_name,\n          admin,\n          group_permissions,\n          app_group_permissions,\n          organization_id,\n          organization,\n        } = response.body;\n\n        expect(email).toEqual(current_user.email);\n        expect(first_name).toEqual(current_user.firstName);\n        expect(last_name).toEqual(current_user.lastName);\n        expect(admin).toBeTruthy();\n        expect(organization_id).toBe(invited_organization.id);\n        expect(organization).toBe(invited_organization.name);\n        expect(group_permissions).toHaveLength(2);\n        expect(group_permissions.some((gp) => gp.group === 'all_users')).toBeTruthy();\n        expect(group_permissions.some((gp) => gp.group === 'admin')).toBeTruthy();\n        expect(Object.keys(group_permissions[0]).sort()).toEqual(\n          [\n            'id',\n            'organization_id',\n            'group',\n            'app_create',\n            'app_delete',\n            'updated_at',\n            'created_at',\n            'folder_create',\n          ].sort()\n        );\n        expect(app_group_permissions).toHaveLength(0);\n        await current_user.reload();\n        expect(current_user.defaultOrganizationId).toBe(invited_organization.id);\n      });\n      it('should be able to switch between organizations with user privilage', async () => {\n        const { organization: invited_organization } = await createUser(\n          app,\n          { groups: ['all_users'], organizationName: 'New Organization' },\n          current_user\n        );\n        const response = await request(app.getHttpServer())\n          .get('/api/switch/' + invited_organization.id)\n          .set('Authorization', authHeaderForUser(current_user));\n\n        expect(response.statusCode).toBe(200);\n        expect(Object.keys(response.body).sort()).toEqual(\n          [\n            'id',\n            'email',\n            'first_name',\n            'last_name',\n            'auth_token',\n            'admin',\n            'organization_id',\n            'organization',\n            'group_permissions',\n            'app_group_permissions',\n          ].sort()\n        );\n\n        const {\n          email,\n          first_name,\n          last_name,\n          admin,\n          group_permissions,\n          app_group_permissions,\n          organization_id,\n          organization,\n        } = response.body;\n\n        expect(email).toEqual(current_user.email);\n        expect(first_name).toEqual(current_user.firstName);\n        expect(last_name).toEqual(current_user.lastName);\n        expect(admin).toBeFalsy();\n        expect(organization_id).toBe(invited_organization.id);\n        expect(organization).toBe(invited_organization.name);\n        expect(group_permissions).toHaveLength(1);\n        expect(group_permissions[0].group).toEqual('all_users');\n        expect(Object.keys(group_permissions[0]).sort()).toEqual(\n          [\n            'id',\n            'organization_id',\n            'group',\n            'app_create',\n            'app_delete',\n            'updated_at',\n            'created_at',\n            'folder_create',\n          ].sort()\n        );\n        expect(app_group_permissions).toHaveLength(0);\n        await current_user.reload();\n        expect(current_user.defaultOrganizationId).toBe(invited_organization.id);\n      });\n    });\n  });\n\n  describe('POST /api/forgot_password', () => {\n    beforeEach(async () => {\n      await createUser(app, {\n        email: 'admin@tooljet.io',\n        firstName: 'user',\n        lastName: 'name',\n      });\n    });\n    it('should return error if required params are not present', async () => {\n      const response = await request(app.getHttpServer()).post('/api/forgot_password');\n\n      expect(response.statusCode).toBe(400);\n      expect(response.body.message).toStrictEqual(['email should not be empty', 'email must be an email']);\n    });\n\n    it('should set token and send email', async () => {\n      const emailServiceMock = jest.spyOn(EmailService.prototype, 'sendPasswordResetEmail');\n      emailServiceMock.mockImplementation();\n\n      const response = await request(app.getHttpServer())\n        .post('/api/forgot_password')\n        .send({ email: 'admin@tooljet.io' });\n\n      expect(response.statusCode).toBe(201);\n\n      const user = await getManager().findOne(User, {\n        where: { email: 'admin@tooljet.io' },\n      });\n\n      expect(emailServiceMock).toHaveBeenCalledWith(user.email, user.forgotPasswordToken);\n    });\n  });\n\n  describe('POST /api/reset_password', () => {\n    beforeEach(async () => {\n      await createUser(app, {\n        email: 'admin@tooljet.io',\n        firstName: 'user',\n        lastName: 'name',\n      });\n    });\n    it('should return error if required params are not present', async () => {\n      const response = await request(app.getHttpServer()).post('/api/reset_password');\n\n      expect(response.statusCode).toBe(400);\n      expect(response.body.message).toStrictEqual([\n        'password should not be empty',\n        'password must be a string',\n        'token should not be empty',\n        'token must be a string',\n      ]);\n    });\n\n    it('should reset password', async () => {\n      const user = await getManager().findOne(User, {\n        where: { email: 'admin@tooljet.io' },\n      });\n\n      user.forgotPasswordToken = 'token';\n      await user.save();\n\n      const response = await request(app.getHttpServer()).post('/api/reset_password').send({\n        password: 'new_password',\n        token: 'token',\n      });\n\n      expect(response.statusCode).toBe(201);\n\n      await request(app.getHttpServer())\n        .post('/api/authenticate')\n        .send({ email: 'admin@tooljet.io', password: 'new_password' })\n        .expect(201);\n    });\n  });\n\n  afterAll(async () => {\n    await app.close();\n  });\n});\n", "import * as request from 'supertest';\nimport { INestApplication } from '@nestjs/common';\nimport { authHeaderForUser, clearDB, createUser, createNestAppInstanceWithEnvMock } from '../test.helper';\nimport { getManager } from 'typeorm';\nimport { User } from 'src/entities/user.entity';\nimport { v4 as uuidv4 } from 'uuid';\nimport { OrganizationUser } from 'src/entities/organization_user.entity';\nconst path = require('path');\n\ndescribe('users controller', () => {\n  let app: INestApplication;\n  let mockConfig;\n\n  beforeEach(async () => {\n    await clearDB();\n  });\n\n  beforeAll(async () => {\n    ({ app, mockConfig } = await createNestAppInstanceWithEnvMock());\n  });\n\n  afterEach(() => {\n    jest.resetAllMocks();\n    jest.clearAllMocks();\n  });\n\n  describe('PATCH /api/users/change_password', () => {\n    it('should allow users to update their password', async () => {\n      const userData = await createUser(app, { email: 'admin@tooljet.io' });\n      const { user } = userData;\n\n      const oldPassword = user.password;\n\n      const response = await request(app.getHttpServer())\n        .patch('/api/users/change_password')\n        .set('Authorization', authHeaderForUser(user))\n        .send({ currentPassword: 'password', newPassword: 'new password' });\n\n      expect(response.statusCode).toBe(200);\n      const updatedUser = await getManager().findOneOrFail(User, { where: { email: user.email } });\n      expect(updatedUser.password).not.toEqual(oldPassword);\n    });\n\n    it('should not allow users to update their password if entered current password is wrong', async () => {\n      const userData = await createUser(app, { email: 'admin@tooljet.io' });\n      const { user } = userData;\n\n      const oldPassword = user.password;\n\n      const response = await request(app.getHttpServer())\n        .patch('/api/users/change_password')\n        .set('Authorization', authHeaderForUser(user))\n        .send({\n          currentPassword: 'wrong password',\n          newPassword: 'new password',\n        });\n\n      expect(response.statusCode).toBe(403);\n\n      const updatedUser = await getManager().findOneOrFail(User, { where: { email: user.email } });\n      expect(updatedUser.password).toEqual(oldPassword);\n    });\n  });\n\n  describe('PATCH /api/users/update', () => {\n    it('should allow users to update their firstName, lastName and password', async () => {\n      const userData = await createUser(app, { email: 'admin@tooljet.io' });\n      const { user } = userData;\n\n      const [firstName, lastName] = ['Daenerys', 'Targaryen'];\n\n      const response = await request(app.getHttpServer())\n        .patch('/api/users/update')\n        .set('Authorization', authHeaderForUser(user))\n        .send({ first_name: firstName, last_name: lastName });\n\n      expect(response.statusCode).toBe(200);\n\n      const updatedUser = await getManager().findOneOrFail(User, { where: { email: user.email } });\n      expect(updatedUser.firstName).toEqual(firstName);\n      expect(updatedUser.lastName).toEqual(lastName);\n    });\n  });\n\n  describe('POST /api/users/set_password_from_token', () => {\n    it('should allow users to setup account after sign up using  Multi-Workspace', async () => {\n      const invitationToken = uuidv4();\n      const userData = await createUser(app, {\n        email: 'signup@tooljet.io',\n        invitationToken,\n        status: 'invited',\n      });\n      const { user, organization } = userData;\n\n      const response = await request(app.getHttpServer()).post('/api/users/set_password_from_token').send({\n        first_name: 'signupuser',\n        last_name: 'user',\n        organization: 'org1',\n        password: uuidv4(),\n        token: invitationToken,\n        role: 'developer',\n      });\n\n      expect(response.statusCode).toBe(201);\n\n      const updatedUser = await getManager().findOneOrFail(User, { where: { email: user.email } });\n      expect(updatedUser.firstName).toEqual('signupuser');\n      expect(updatedUser.lastName).toEqual('user');\n      expect(updatedUser.defaultOrganizationId).toEqual(organization.id);\n      const organizationUser = await getManager().findOneOrFail(OrganizationUser, { where: { userId: user.id } });\n      expect(organizationUser.status).toEqual('active');\n    });\n\n    it('should return error if required params are not present - Multi-Workspace', async () => {\n      const invitationToken = uuidv4();\n      await createUser(app, {\n        email: 'signup@tooljet.io',\n        invitationToken,\n        status: 'invited',\n      });\n\n      const response = await request(app.getHttpServer()).post('/api/users/set_password_from_token');\n\n      expect(response.statusCode).toBe(400);\n      expect(response.body.message).toStrictEqual([\n        'password should not be empty',\n        'password must be a string',\n        'token should not be empty',\n        'token must be a string',\n      ]);\n    });\n\n    it('should allow users to setup account for single organization only once', async () => {\n      jest.spyOn(mockConfig, 'get').mockImplementation((key: string) => {\n        switch (key) {\n          case 'DISABLE_MULTI_WORKSPACE':\n            return 'true';\n          default:\n            return process.env[key];\n        }\n      });\n      const invitationToken = uuidv4();\n      await createUser(app, {\n        email: 'signup@tooljet.io',\n        invitationToken,\n        status: 'invited',\n      });\n\n      let response = await request(app.getHttpServer()).post('/api/users/set_password_from_token').send({\n        first_name: 'signupuser',\n        last_name: 'user',\n        organization: 'org1',\n        password: uuidv4(),\n        token: invitationToken,\n        role: 'developer',\n      });\n\n      expect(response.statusCode).toBe(201);\n\n      await createUser(app, {\n        email: 'signup2@tooljet.io',\n        invitationToken,\n        status: 'invited',\n      });\n\n      response = await request(app.getHttpServer()).post('/api/users/set_password_from_token').send({\n        first_name: 'signupuser2',\n        last_name: 'user2',\n        organization: 'org1',\n        password: uuidv4(),\n        token: invitationToken,\n        role: 'developer',\n      });\n\n      expect(response.statusCode).toBe(403);\n    });\n\n    it('should not allow users to setup account for Multi-Workspace and sign up disabled', async () => {\n      jest.spyOn(mockConfig, 'get').mockImplementation((key: string) => {\n        switch (key) {\n          case 'DISABLE_SIGNUPS':\n            return 'true';\n          default:\n            return process.env[key];\n        }\n      });\n      const invitationToken = uuidv4();\n      await createUser(app, {\n        email: 'signup@tooljet.io',\n        invitationToken,\n        status: 'invited',\n      });\n\n      const response = await request(app.getHttpServer()).post('/api/users/set_password_from_token').send({\n        first_name: 'signupuser',\n        last_name: 'user',\n        organization: 'org1',\n        password: uuidv4(),\n        token: invitationToken,\n        role: 'developer',\n      });\n\n      expect(response.statusCode).toBe(403);\n    });\n\n    it('should allow users to setup account if already invited to an organization but not activated', async () => {\n      const org = (\n        await createUser(app, {\n          email: 'admin@tooljet.io',\n        })\n      ).organization;\n      const invitedUser = await createUser(app, {\n        email: 'invited@tooljet.io',\n        status: 'invited',\n        organization: org,\n      });\n\n      const signUpResponse = await request(app.getHttpServer())\n        .post('/api/signup')\n        .send({ email: 'invited@tooljet.io' });\n\n      expect(signUpResponse.statusCode).toBe(201);\n\n      const invitedUserDetails = await getManager().findOneOrFail(User, { where: { email: invitedUser.user.email } });\n\n      expect(invitedUserDetails.defaultOrganizationId).not.toBe(org.id);\n\n      const response = await request(app.getHttpServer()).post('/api/users/set_password_from_token').send({\n        first_name: 'signupuser',\n        last_name: 'user',\n        organization: 'org1',\n        password: uuidv4(),\n        token: invitedUserDetails.invitationToken,\n        role: 'developer',\n      });\n\n      expect(response.statusCode).toBe(201);\n      const updatedUser = await getManager().findOneOrFail(User, { where: { email: invitedUser.user.email } });\n      expect(updatedUser.firstName).toEqual('signupuser');\n      expect(updatedUser.lastName).toEqual('user');\n      expect(updatedUser.defaultOrganizationId).not.toBe(org.id);\n      const organizationUser = await getManager().findOneOrFail(OrganizationUser, {\n        where: { userId: invitedUser.user.id, organizationId: org.id },\n      });\n      const defaultOrganizationUser = await getManager().findOneOrFail(OrganizationUser, {\n        where: { userId: invitedUser.user.id, organizationId: invitedUserDetails.defaultOrganizationId },\n      });\n      expect(organizationUser.status).toEqual('invited');\n      expect(defaultOrganizationUser.status).toEqual('active');\n    });\n\n    it('should not allow users to setup account if already invited to an organization and activated account through invite link after sign up', async () => {\n      const { organization: org } = await createUser(app, {\n        email: 'admin@tooljet.io',\n      });\n      const invitedUser = await createUser(app, {\n        email: 'invited@tooljet.io',\n        status: 'invited',\n        organization: org,\n      });\n\n      const signUpResponse = await request(app.getHttpServer())\n        .post('/api/signup')\n        .send({ email: 'invited@tooljet.io' });\n\n      expect(signUpResponse.statusCode).toBe(201);\n\n      const invitedUserDetails = await getManager().findOneOrFail(User, { where: { email: invitedUser.user.email } });\n\n      expect(invitedUserDetails.defaultOrganizationId).not.toBe(org.id);\n\n      const acceptInviteResponse = await request(app.getHttpServer()).post('/api/users/accept-invite').send({\n        token: invitedUser.orgUser.invitationToken,\n        password: 'new-password',\n      });\n\n      expect(acceptInviteResponse.statusCode).toBe(201);\n\n      const organizationUser = await getManager().findOneOrFail(OrganizationUser, {\n        where: { userId: invitedUser.user.id, organizationId: org.id },\n      });\n      const defaultOrganizationUser = await getManager().findOneOrFail(OrganizationUser, {\n        where: { userId: invitedUser.user.id, organizationId: invitedUserDetails.defaultOrganizationId },\n      });\n      expect(organizationUser.status).toEqual('active');\n      expect(defaultOrganizationUser.status).toEqual('active');\n\n      const updatedUser = await getManager().findOneOrFail(User, { where: { email: invitedUser.user.email } });\n      expect(updatedUser.defaultOrganizationId).toBe(defaultOrganizationUser.organizationId);\n\n      const response = await request(app.getHttpServer()).post('/api/users/set_password_from_token').send({\n        first_name: 'signupuser',\n        last_name: 'user',\n        organization: 'org1',\n        password: uuidv4(),\n        token: invitedUserDetails.invitationToken,\n        role: 'developer',\n      });\n\n      expect(response.statusCode).toBe(400);\n    });\n  });\n\n  describe('POST /api/users/accept-invite', () => {\n    it('should allow users to accept invitation when Multi-Workspace is enabled', async () => {\n      const userData = await createUser(app, {\n        email: 'organizationUser@tooljet.io',\n        status: 'invited',\n      });\n      const { user, orgUser } = userData;\n\n      const response = await request(app.getHttpServer()).post('/api/users/accept-invite').send({\n        token: orgUser.invitationToken,\n        password: uuidv4(),\n      });\n\n      expect(response.statusCode).toBe(201);\n\n      const organizationUser = await getManager().findOneOrFail(OrganizationUser, { where: { userId: user.id } });\n      expect(organizationUser.status).toEqual('active');\n    });\n\n    it('should allow users to accept invitation when Multi-Workspace is disabled', async () => {\n      jest.spyOn(mockConfig, 'get').mockImplementation((key: string) => {\n        switch (key) {\n          case 'DISABLE_MULTI_WORKSPACE':\n            return 'true';\n          default:\n            return process.env[key];\n        }\n      });\n      const userData = await createUser(app, {\n        email: 'organizationUser@tooljet.io',\n        status: 'invited',\n      });\n      const { user, orgUser } = userData;\n\n      const response = await request(app.getHttpServer()).post('/api/users/accept-invite').send({\n        token: orgUser.invitationToken,\n        password: uuidv4(),\n      });\n\n      expect(response.statusCode).toBe(201);\n\n      const organizationUser = await getManager().findOneOrFail(OrganizationUser, { where: { userId: user.id } });\n      expect(organizationUser.status).toEqual('active');\n    });\n  });\n\n  describe('POST /api/users/avatar', () => {\n    it('should allow users to add a avatar', async () => {\n      const userData = await createUser(app, { email: 'admin@tooljet.io' });\n\n      const { user } = userData;\n      const filePath = path.join(__dirname, '../__mocks__/avatar.png');\n\n      const response = await request(app.getHttpServer())\n        .post('/api/users/avatar')\n        .set('Authorization', authHeaderForUser(user))\n        .attach('file', filePath);\n\n      expect(response.statusCode).toBe(201);\n    });\n  });\n\n  afterAll(async () => {\n    await app.close();\n  });\n});\n"], "fixing_code": ["import React from 'react';\nimport config from 'config';\nimport { Router, Route, Redirect } from 'react-router-dom';\nimport { history } from '@/_helpers';\nimport { authenticationService, tooljetService } from '@/_services';\nimport { PrivateRoute } from '@/_components';\nimport { HomePage } from '@/HomePage';\nimport { LoginPage } from '@/LoginPage';\nimport { SignupPage } from '@/SignupPage';\nimport { ConfirmationPage, OrganizationInvitationPage } from '@/ConfirmationPage';\nimport { Authorize } from '@/Oauth2';\nimport { Authorize as Oauth } from '@/Oauth';\nimport { Viewer } from '@/Editor';\nimport { ManageGroupPermissions } from '@/ManageGroupPermissions';\nimport { ManageOrgUsers } from '@/ManageOrgUsers';\nimport { ManageGroupPermissionResources } from '@/ManageGroupPermissionResources';\nimport { SettingsPage } from '../SettingsPage/SettingsPage';\nimport { OnboardingModal } from '@/Onboarding/OnboardingModal';\nimport { ForgotPassword } from '@/ForgotPassword';\nimport { ResetPassword } from '@/ResetPassword';\nimport { ManageSSO } from '@/ManageSSO';\nimport { lt } from 'semver';\nimport { Toaster } from 'react-hot-toast';\nimport { RealtimeEditor } from '@/Editor/RealtimeEditor';\nimport { Editor } from '@/Editor/Editor';\nimport { RedirectSso } from '@/RedirectSso/RedirectSso';\n\nimport '@/_styles/theme.scss';\nimport 'emoji-mart/css/emoji-mart.css';\n\nclass App extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      currentUser: null,\n      fetchedMetadata: false,\n      onboarded: true,\n      darkMode: localStorage.getItem('darkMode') === 'true',\n    };\n  }\n\n  fetchMetadata = () => {\n    if (this.state.currentUser) {\n      tooljetService.fetchMetaData().then((data) => {\n        this.setState({ onboarded: data.onboarded });\n\n        if (data.latest_version && lt(data.installed_version, data.latest_version) && data.version_ignored === false) {\n          this.setState({ updateAvailable: true });\n        }\n      });\n    }\n  };\n\n  componentDidMount() {\n    authenticationService.currentUser.subscribe((x) => {\n      this.setState({ currentUser: x }, this.fetchMetadata);\n      setInterval(this.fetchMetadata, 1000 * 60 * 60 * 1);\n    });\n  }\n\n  logout = () => {\n    authenticationService.logout();\n    history.push('/login');\n  };\n\n  switchDarkMode = (newMode) => {\n    this.setState({ darkMode: newMode });\n    localStorage.setItem('darkMode', newMode);\n  };\n\n  render() {\n    const { updateAvailable, onboarded, darkMode } = this.state;\n    let toastOptions = {};\n\n    if (darkMode) {\n      toastOptions = {\n        style: {\n          borderRadius: '10px',\n          background: '#333',\n          color: '#fff',\n        },\n      };\n    }\n\n    return (\n      <>\n        <Router history={history}>\n          <div className={`main-wrapper ${darkMode ? 'theme-dark' : ''}`}>\n            {updateAvailable && (\n              <div className=\"alert alert-info alert-dismissible\" role=\"alert\">\n                <h3 className=\"mb-1\">Update available</h3>\n                <p>A new version of ToolJet has been released.</p>\n                <div className=\"btn-list\">\n                  <a\n                    href=\"https://docs.tooljet.io/docs/setup/updating\"\n                    target=\"_blank\"\n                    className=\"btn btn-info\"\n                    rel=\"noreferrer\"\n                  >\n                    Read release notes & update\n                  </a>\n                  <a\n                    onClick={() => {\n                      tooljetService.skipVersion();\n                      this.setState({ updateAvailable: false });\n                    }}\n                    className=\"btn\"\n                  >\n                    Skip this version\n                  </a>\n                </div>\n              </div>\n            )}\n\n            {!onboarded && <OnboardingModal darkMode={this.state.darkMode} />}\n\n            <PrivateRoute\n              exact\n              path=\"/\"\n              component={HomePage}\n              switchDarkMode={this.switchDarkMode}\n              darkMode={darkMode}\n            />\n            <Route path=\"/login/:organisationId\" exact component={LoginPage} />\n            <Route path=\"/login\" exact component={LoginPage} />\n            <Route path=\"/sso/:origin/:configId\" component={Oauth} />\n            <Route path=\"/signup\" component={SignupPage} />\n            <Route path=\"/forgot-password\" component={ForgotPassword} />\n            <Route path=\"/reset-password\" component={ResetPassword} />\n            <Route path=\"/multiworkspace\" component={RedirectSso} />\n            <Route\n              path=\"/invitations/:token\"\n              render={(props) => (\n                <Redirect\n                  to={{\n                    pathname: '/confirm',\n                    state: {\n                      token: props.match.params.token,\n                    },\n                  }}\n                />\n              )}\n            />\n            <Route\n              path=\"/invitations/:token/workspaces/:organizationToken\"\n              render={(props) => (\n                <Redirect\n                  to={{\n                    pathname: '/confirm',\n                    state: {\n                      token: props.match.params.token,\n                      organizationToken: props.match.params.organizationToken,\n                    },\n                  }}\n                />\n              )}\n            />\n            <Route path=\"/confirm\" component={ConfirmationPage} />\n            <Route\n              path=\"/organization-invitations/:token\"\n              render={(props) => (\n                <Redirect\n                  to={{\n                    pathname: '/confirm-invite',\n                    state: {\n                      token: props.match.params.token,\n                    },\n                  }}\n                />\n              )}\n            />\n            <Route path=\"/confirm-invite\" component={OrganizationInvitationPage} />\n            <PrivateRoute\n              exact\n              path=\"/apps/:id\"\n              component={config.ENABLE_MULTIPLAYER_EDITING ? RealtimeEditor : Editor}\n              switchDarkMode={this.switchDarkMode}\n              darkMode={darkMode}\n            />\n            <PrivateRoute\n              exact\n              path=\"/applications/:id/versions/:versionId\"\n              component={Viewer}\n              switchDarkMode={this.switchDarkMode}\n              darkMode={darkMode}\n            />\n            <PrivateRoute\n              exact\n              path=\"/applications/:slug\"\n              component={Viewer}\n              switchDarkMode={this.switchDarkMode}\n              darkMode={darkMode}\n            />\n            <PrivateRoute\n              exact\n              path=\"/oauth2/authorize\"\n              component={Authorize}\n              switchDarkMode={this.switchDarkMode}\n              darkMode={darkMode}\n            />\n            <PrivateRoute\n              exact\n              path=\"/users\"\n              component={ManageOrgUsers}\n              switchDarkMode={this.switchDarkMode}\n              darkMode={darkMode}\n            />\n            <PrivateRoute\n              exact\n              path=\"/manage-sso\"\n              component={ManageSSO}\n              switchDarkMode={this.switchDarkMode}\n              darkMode={darkMode}\n            />\n            <PrivateRoute\n              exact\n              path=\"/groups\"\n              component={ManageGroupPermissions}\n              switchDarkMode={this.switchDarkMode}\n              darkMode={darkMode}\n            />\n            <PrivateRoute\n              exact\n              path=\"/groups/:id\"\n              component={ManageGroupPermissionResources}\n              switchDarkMode={this.switchDarkMode}\n              darkMode={darkMode}\n            />\n            <PrivateRoute\n              exact\n              path=\"/settings\"\n              component={SettingsPage}\n              switchDarkMode={this.switchDarkMode}\n              darkMode={darkMode}\n            />\n          </div>\n        </Router>\n        <Toaster toastOptions={toastOptions} />\n      </>\n    );\n  }\n}\n\nexport { App };\n", "import React from 'react';\nimport { appService } from '@/_services';\nimport { toast } from 'react-hot-toast';\n\nclass ConfirmationPage extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      isLoading: false,\n    };\n    this.formRef = React.createRef(null);\n  }\n\n  handleChange = (event) => {\n    this.setState({ [event.target.name]: event.target.value });\n  };\n\n  calculateOffset() {\n    const elementHeight = this.formRef.current.getBoundingClientRect().top;\n    return window.innerHeight - elementHeight;\n  }\n\n  setPassword = (e) => {\n    e.preventDefault();\n    const { token, organizationToken } = this.props.location.state;\n    const { password, organization, role, firstName, lastName, password_confirmation } = this.state;\n    this.setState({ isLoading: true });\n\n    if (!password || !password_confirmation || !password.trim() || !password_confirmation.trim()) {\n      this.setState({ isLoading: false });\n      toast.error(\"Password shouldn't be empty or contain white space(s)\", {\n        position: 'top-center',\n      });\n      return;\n    }\n\n    if (password !== password_confirmation) {\n      this.setState({ isLoading: false });\n      toast.error(\"Passwords don't match\", {\n        position: 'top-center',\n      });\n      return;\n    }\n\n    appService\n      .setPasswordFromToken({\n        token,\n        organizationToken,\n        password,\n        organization,\n        role,\n        firstName,\n        lastName,\n      })\n      .then(() => {\n        this.setState({ isLoading: false });\n        toast.success('Account has been setup successfully.', {\n          position: 'top-center',\n        });\n        this.props.history.push('/login');\n      })\n      .catch(({ error }) => {\n        this.setState({ isLoading: false });\n        toast.error(error, { position: 'top-center' });\n      });\n  };\n\n  render() {\n    const { isLoading } = this.state;\n    const roles = [\n      'CTO/CIO',\n      'Founder/CEO',\n      'IT Manager',\n      'Developer',\n      'Designer',\n      'Sales Professional',\n      'Marketing Professional',\n      'Product Manager',\n      'Other',\n    ];\n\n    const roleOptions = roles.map((role, index) => (\n      <option key={index} value={role}>\n        {role}\n      </option>\n    ));\n\n    return (\n      <div className=\"page page-center\" ref={this.formRef} style={{ overflowY: 'scroll' }}>\n        <div\n          className=\"container-tight py-2 invitation-page\"\n          style={{ maxHeight: this.formRef.current && this.calculateOffset() }}\n        >\n          <div className=\"text-center mb-4\">\n            <a href=\".\">\n              <img src=\"/assets/images/logo-color.svg\" height=\"30\" alt=\"\" />\n            </a>\n          </div>\n          <form className=\"card card-md\" action=\".\" method=\"get\" autoComplete=\"off\">\n            <div className=\"card-body\">\n              <h2 className=\"card-title text-center mb-4\">Set up your account</h2>\n              <div className=\"mb-3\">\n                <label className=\"form-label\">First name</label>\n                <div className=\"input-group input-group-flat\">\n                  <input\n                    onChange={this.handleChange}\n                    name=\"firstName\"\n                    type=\"text\"\n                    className=\"form-control\"\n                    autoComplete=\"off\"\n                  />\n                  <span className=\"input-group-text\"></span>\n                </div>\n              </div>\n              <div className=\"mb-3\">\n                <label className=\"form-label\">Last name</label>\n                <div className=\"input-group input-group-flat\">\n                  <input\n                    onChange={this.handleChange}\n                    name=\"lastName\"\n                    type=\"text\"\n                    className=\"form-control\"\n                    autoComplete=\"off\"\n                  />\n                  <span className=\"input-group-text\"></span>\n                </div>\n              </div>\n              <div className=\"mb-3\">\n                <label className=\"form-label\">Workspace</label>\n                <div className=\"input-group input-group-flat\">\n                  <input\n                    onChange={this.handleChange}\n                    name=\"organization\"\n                    type=\"text\"\n                    className=\"form-control\"\n                    autoComplete=\"off\"\n                  />\n                  <span className=\"input-group-text\"></span>\n                </div>\n              </div>\n              <div className=\"mb-3\">\n                <div className=\"form-label\">Role</div>\n                <select className=\"form-select\" name=\"role\" defaultValue=\"\" onChange={this.handleChange}>\n                  <option value=\"\" disabled>\n                    Please select\n                  </option>\n                  {roleOptions}\n                </select>\n              </div>\n              <div className=\"mb-3\">\n                <label className=\"form-label\">Password</label>\n                <div className=\"input-group input-group-flat\">\n                  <input\n                    onChange={this.handleChange}\n                    name=\"password\"\n                    type=\"password\"\n                    className=\"form-control\"\n                    autoComplete=\"off\"\n                  />\n                  <span className=\"input-group-text\"></span>\n                </div>\n              </div>\n              <div className=\"mb-3\">\n                <label className=\"form-label\">Confirm Password</label>\n                <div className=\"input-group input-group-flat\">\n                  <input\n                    onChange={this.handleChange}\n                    name=\"password_confirmation\"\n                    type=\"password\"\n                    className=\"form-control\"\n                    autoComplete=\"off\"\n                  />\n                  <span className=\"input-group-text\"></span>\n                </div>\n              </div>\n              <div className=\"form-footer\">\n                <p>\n                  By clicking the button below, you agree to our{' '}\n                  <a href=\"https://tooljet.io/terms\">Terms and Conditions</a>.\n                </p>\n                <button\n                  className={`btn mt-2 btn-primary w-100 ${isLoading ? ' btn-loading' : ''}`}\n                  onClick={this.setPassword}\n                  disabled={isLoading}\n                >\n                  Finish account setup\n                </button>\n              </div>\n            </div>\n          </form>\n        </div>\n      </div>\n    );\n  }\n}\n\nexport { ConfirmationPage };\n", "import React from 'react';\nimport { appService } from '@/_services';\nimport { toast } from 'react-hot-toast';\n\nclass OrganizationInvitationPage extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      isLoading: false,\n    };\n    this.formRef = React.createRef(null);\n    this.single_organization = window.public_config?.DISABLE_MULTI_WORKSPACE === 'true';\n  }\n\n  handleChange = (event) => {\n    this.setState({ [event.target.name]: event.target.value });\n  };\n\n  acceptInvite = (e, isSetPassword) => {\n    e.preventDefault();\n\n    const token = this.props.location.state.token;\n    const { password, password_confirmation } = this.state;\n    this.setState({ isLoading: true });\n\n    if (isSetPassword) {\n      if (!password || !password_confirmation || !password.trim() || !password_confirmation.trim()) {\n        this.setState({ isLoading: false });\n        toast.error(\"Password shouldn't be empty or contain white space(s)\", {\n          position: 'top-center',\n        });\n        return;\n      }\n\n      if (password !== password_confirmation) {\n        this.setState({ isLoading: false });\n        toast.error(\"Passwords don't match\", {\n          position: 'top-center',\n        });\n        return;\n      }\n    }\n\n    appService\n      .acceptInvite({\n        token,\n        password,\n      })\n      .then((response) => {\n        this.setState({ isLoading: false });\n        response.json().then((data) => {\n          if (!response.ok) {\n            return toast.error(data?.message || 'Error while setting up your account.', { position: 'top-center' });\n          }\n          toast.success(`Added to the workspace${isSetPassword ? ' and password has been set ' : ' '}successfully.`, {\n            position: 'top-center',\n          });\n          this.props.history.push('/login');\n        });\n      });\n  };\n\n  render() {\n    const { isLoading } = this.state;\n\n    return (\n      <div className=\"page page-center\" ref={this.formRef}>\n        <div className=\"container-tight py-2 invitation-page\">\n          <div className=\"text-center mb-4\">\n            <a href=\".\">\n              <img src=\"/assets/images/logo-color.svg\" height=\"30\" alt=\"\" />\n            </a>\n          </div>\n          <form className=\"card card-md\" action=\".\" method=\"get\" autoComplete=\"off\">\n            <div className=\"card-body\">\n              {!this.single_organization ? (\n                <>\n                  <h2 className=\"card-title text-center mb-2\">Already have an account?</h2>\n                  <div className=\"mb-3\">\n                    <button\n                      className={`btn mt-2 btn-primary w-100 ${isLoading ? ' btn-loading' : ''}`}\n                      onClick={(e) => this.acceptInvite(e)}\n                      disabled={isLoading}\n                    >\n                      Accept invite\n                    </button>\n                  </div>\n                </>\n              ) : (\n                <>\n                  <h2 className=\"card-title text-center mb-4\">Set up your account</h2>\n                  <div className=\"mb-3\">\n                    <label className=\"form-label\">Password</label>\n                    <div className=\"input-group input-group-flat\">\n                      <input\n                        onChange={this.handleChange}\n                        name=\"password\"\n                        type=\"password\"\n                        className=\"form-control\"\n                        autoComplete=\"off\"\n                      />\n                      <span className=\"input-group-text\"></span>\n                    </div>\n                  </div>\n                  <div className=\"mb-3\">\n                    <label className=\"form-label\">Confirm Password</label>\n                    <div className=\"input-group input-group-flat\">\n                      <input\n                        onChange={this.handleChange}\n                        name=\"password_confirmation\"\n                        type=\"password\"\n                        className=\"form-control\"\n                        autoComplete=\"off\"\n                      />\n                      <span className=\"input-group-text\"></span>\n                    </div>\n                  </div>\n                  <div className=\"form-footer\">\n                    <p>\n                      By clicking the button below, you agree to our{' '}\n                      <a href=\"https://tooljet.io/terms\">Terms and Conditions</a>.\n                    </p>\n                    <button\n                      className={`btn mt-2 btn-primary w-100 ${isLoading ? ' btn-loading' : ''}`}\n                      onClick={(e) => this.acceptInvite(e, true)}\n                      disabled={isLoading}\n                    >\n                      Finish account setup and accept invite\n                    </button>\n                  </div>\n                </>\n              )}\n            </div>\n          </form>\n        </div>\n      </div>\n    );\n  }\n}\n\nexport { OrganizationInvitationPage };\n", "import React from 'react';\nimport { authenticationService, organizationService, organizationUserService } from '@/_services';\nimport { Header } from '@/_components';\nimport { toast } from 'react-hot-toast';\nimport { CopyToClipboard } from 'react-copy-to-clipboard';\nimport ReactTooltip from 'react-tooltip';\n\nclass ManageOrgUsers extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      currentUser: authenticationService.currentUserValue,\n      isLoading: true,\n      showNewUserForm: false,\n      creatingUser: false,\n      newUser: {},\n      archivingUser: null,\n      unarchivingUser: null,\n      fields: {},\n      errors: {},\n    };\n\n    this.tableRef = React.createRef(null);\n  }\n\n  validateEmail(email) {\n    const re =\n      /^(([^<>()[\\]\\\\.,;:\\s@\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/;\n    return re.test(String(email).toLowerCase());\n  }\n\n  handleValidation() {\n    let fields = this.state.fields;\n    let errors = {};\n    //Name\n    if (!fields['firstName']) {\n      errors['firstName'] = 'This field is required';\n    } else if (typeof fields['firstName'] !== 'undefined') {\n      if (!/^[a-zA-Z]+$/.test(fields['firstName'])) {\n        errors['firstName'] = 'Only letters are allowed';\n      }\n    }\n    if (!fields['lastName']) {\n      errors['lastName'] = 'This field is required';\n    } else if (typeof fields['lastName'] !== 'undefined') {\n      if (!/^[a-zA-Z]+$/.test(fields['lastName'])) {\n        errors['lastName'] = 'Only letters are allowed';\n      }\n    }\n    //Email\n    if (!fields['email']) {\n      errors['email'] = 'This field is required';\n    } else if (!this.validateEmail(fields['email'])) {\n      errors['email'] = 'Email is not valid';\n    }\n\n    this.setState({ errors: errors });\n    return Object.keys(errors).length === 0;\n  }\n\n  componentDidMount() {\n    this.fetchUsers();\n  }\n\n  calculateOffset() {\n    const elementHeight = this.tableRef.current.getBoundingClientRect().top;\n    return window.innerHeight - elementHeight;\n  }\n\n  fetchUsers = () => {\n    this.setState({\n      isLoading: true,\n    });\n\n    organizationService.getUsers(null).then((data) =>\n      this.setState({\n        users: data.users,\n        isLoading: false,\n      })\n    );\n  };\n\n  changeNewUserOption = (name, e) => {\n    let fields = this.state.fields;\n    fields[name] = e.target.value;\n\n    this.setState({\n      fields,\n    });\n  };\n\n  archiveOrgUser = (id) => {\n    this.setState({ archivingUser: id });\n\n    organizationUserService\n      .archive(id)\n      .then(() => {\n        toast.success('The user has been archived', {\n          position: 'top-center',\n        });\n        this.setState({ archivingUser: null });\n        this.fetchUsers();\n      })\n      .catch(({ error }) => {\n        toast.error(error, { position: 'top-center' });\n        this.setState({ archivingUser: null });\n      });\n  };\n\n  unarchiveOrgUser = (id) => {\n    this.setState({ unarchivingUser: id });\n\n    organizationUserService\n      .unarchive(id)\n      .then(() => {\n        toast.success('The user has been unarchived', {\n          position: 'top-center',\n        });\n        this.setState({ unarchivingUser: null });\n        this.fetchUsers();\n      })\n      .catch(({ error }) => {\n        toast.error(error, { position: 'top-center' });\n        this.setState({ unarchivingUser: null });\n      });\n  };\n\n  createUser = (event) => {\n    event.preventDefault();\n\n    if (this.handleValidation()) {\n      let fields = {};\n      Object.keys(this.state.fields).map((key) => {\n        fields[key] = '';\n      });\n\n      this.setState({\n        creatingUser: true,\n      });\n\n      organizationUserService\n        .create(\n          this.state.fields.firstName,\n          this.state.fields.lastName,\n          this.state.fields.email,\n          this.state.fields.role\n        )\n        .then(() => {\n          toast.success('User has been created', {\n            position: 'top-center',\n          });\n          this.fetchUsers();\n          this.setState({\n            creatingUser: false,\n            showNewUserForm: false,\n            fields: fields,\n          });\n        })\n        .catch(({ error }) => {\n          toast.error(error, { position: 'top-center' });\n          this.setState({ creatingUser: false });\n        });\n    } else {\n      this.setState({ creatingUser: false, showNewUserForm: true });\n    }\n  };\n\n  generateInvitationURL = (user) => window.location.origin + '/organization-invitations/' + user.invitation_token;\n\n  invitationLinkCopyHandler = () => {\n    toast.success('Invitation URL copied', {\n      position: 'bottom-right',\n    });\n  };\n\n  render() {\n    const { isLoading, showNewUserForm, creatingUser, users, archivingUser, unarchivingUser } = this.state;\n    return (\n      <div className=\"wrapper org-users-page\">\n        <Header switchDarkMode={this.props.switchDarkMode} darkMode={this.props.darkMode} />\n        <ReactTooltip type=\"dark\" effect=\"solid\" delayShow={250} />\n\n        <div className=\"page-wrapper\">\n          <div className=\"container-xl\">\n            <div className=\"page-header d-print-none\">\n              <div className=\"row align-items-center\">\n                <div className=\"col\">\n                  <div className=\"page-pretitle\"></div>\n                  <h2 className=\"page-title\">Users & Permissions</h2>\n                </div>\n                <div className=\"col-auto ms-auto d-print-none\">\n                  {!showNewUserForm && (\n                    <div className=\"btn btn-primary\" onClick={() => this.setState({ showNewUserForm: true })}>\n                      Invite new user\n                    </div>\n                  )}\n                </div>\n              </div>\n            </div>\n          </div>\n\n          <div className=\"page-body\">\n            {showNewUserForm && (\n              <div className=\"container-xl\">\n                <div className=\"card\">\n                  <div className=\"card-header\">\n                    <h3 className=\"card-title\">Add new user</h3>\n                  </div>\n                  <div className=\"card-body\">\n                    <form onSubmit={this.createUser} noValidate>\n                      <div className=\"form-group mb-3 \">\n                        <div className=\"row\">\n                          <div className=\"col\">\n                            <input\n                              type=\"text\"\n                              className=\"form-control\"\n                              placeholder=\"Enter First Name\"\n                              name=\"firstName\"\n                              onChange={this.changeNewUserOption.bind(this, 'firstName')}\n                              value={this.state.fields['firstName']}\n                            />\n                            <span className=\"text-danger\">{this.state.errors['firstName']}</span>\n                          </div>\n                          <div className=\"col\">\n                            <input\n                              type=\"text\"\n                              className=\"form-control\"\n                              placeholder=\"Enter Last Name\"\n                              name=\"lastName\"\n                              onChange={this.changeNewUserOption.bind(this, 'lastName')}\n                              value={this.state.fields['lastName']}\n                            />\n                            <span className=\"text-danger\">{this.state.errors['lastName']}</span>\n                          </div>\n                        </div>\n                      </div>\n                      <div className=\"form-group mb-3 \">\n                        <label className=\"form-label\">Email address</label>\n                        <div>\n                          <input\n                            type=\"text\"\n                            className=\"form-control\"\n                            aria-describedby=\"emailHelp\"\n                            placeholder=\"Enter email\"\n                            name=\"email\"\n                            onChange={this.changeNewUserOption.bind(this, 'email')}\n                            value={this.state.fields['email']}\n                          />\n                          <span className=\"text-danger\">{this.state.errors['email']}</span>\n                        </div>\n                      </div>\n                      <div className=\"form-footer\">\n                        <button\n                          type=\"button\"\n                          className=\"btn btn-light mr-2\"\n                          onClick={() =>\n                            this.setState({\n                              showNewUserForm: false,\n                              newUser: {},\n                            })\n                          }\n                        >\n                          Cancel\n                        </button>\n                        <button\n                          type=\"submit\"\n                          className={`btn mx-2 btn-primary ${creatingUser ? 'btn-loading' : ''}`}\n                          disabled={creatingUser}\n                        >\n                          Create User\n                        </button>\n                      </div>\n                    </form>\n                  </div>\n                </div>\n              </div>\n            )}\n\n            {!showNewUserForm && (\n              <div className=\"container-xl\">\n                <div className=\"card\">\n                  <div\n                    className=\"card-table fixedHeader table-responsive table-bordered\"\n                    ref={this.tableRef}\n                    style={{\n                      maxHeight: this.tableRef.current && this.calculateOffset(),\n                    }}\n                  >\n                    <table data-testid=\"usersTable\" className=\"table table-vcenter\" disabled={true}>\n                      <thead>\n                        <tr>\n                          <th>Name</th>\n                          <th>Email</th>\n                          <th>Status</th>\n                          <th className=\"w-1\"></th>\n                        </tr>\n                      </thead>\n                      {isLoading ? (\n                        <tbody className=\"w-100\" style={{ minHeight: '300px' }}>\n                          {Array.from(Array(4)).map((_item, index) => (\n                            <tr key={index}>\n                              <td className=\"col-2 p-3\">\n                                <div className=\"row\">\n                                  <div\n                                    className=\"skeleton-image col-auto\"\n                                    style={{ width: '25px', height: '25px' }}\n                                  ></div>\n                                  <div className=\"skeleton-line w-10 col mx-3\"></div>\n                                </div>\n                              </td>\n                              <td className=\"col-4 p-3\">\n                                <div className=\"skeleton-line w-10\"></div>\n                              </td>\n                              <td className=\"col-2 p-3\">\n                                <div className=\"skeleton-line\"></div>\n                              </td>\n                              <td className=\"text-muted col-auto col-1 pt-3\">\n                                <div className=\"skeleton-line\"></div>\n                              </td>\n                              <td className=\"text-muted col-auto col-1 pt-3\">\n                                <div className=\"skeleton-line\"></div>\n                              </td>\n                            </tr>\n                          ))}\n                        </tbody>\n                      ) : (\n                        <tbody>\n                          {users.map((user) => (\n                            <tr key={user.id}>\n                              <td>\n                                <span className=\"avatar bg-azure-lt avatar-sm\">\n                                  {user.first_name ? user.first_name[0] : ''}\n                                  {user.last_name ? user.last_name[0] : ''}\n                                </span>\n                                <span\n                                  className=\"mx-3\"\n                                  style={{\n                                    display: 'inline-flex',\n                                    marginBottom: '7px',\n                                  }}\n                                >\n                                  {user.name}\n                                </span>\n                              </td>\n                              <td className=\"text-muted\">\n                                <a className=\"text-reset user-email\">{user.email}</a>\n                              </td>\n                              <td className=\"text-muted\">\n                                <span\n                                  className={`badge bg-${\n                                    user.status === 'invited'\n                                      ? 'warning'\n                                      : user.status === 'archived'\n                                      ? 'danger'\n                                      : 'success'\n                                  } me-1 m-1`}\n                                ></span>\n                                <small className=\"user-status\">{user.status}</small>\n                                {user.status === 'invited' && 'invitation_token' in user ? (\n                                  <CopyToClipboard\n                                    text={this.generateInvitationURL(user)}\n                                    onCopy={this.invitationLinkCopyHandler}\n                                  >\n                                    <img\n                                      data-tip=\"Copy invitation link\"\n                                      className=\"svg-icon\"\n                                      src=\"/assets/images/icons/copy.svg\"\n                                      width=\"15\"\n                                      height=\"15\"\n                                      style={{\n                                        cursor: 'pointer',\n                                      }}\n                                    ></img>\n                                  </CopyToClipboard>\n                                ) : (\n                                  ''\n                                )}\n                              </td>\n                              <td>\n                                <button\n                                  type=\"button\"\n                                  style={{ minWidth: '100px' }}\n                                  className={`btn btn-sm btn-outline-${\n                                    user.status === 'archived' ? 'success' : 'danger'\n                                  } ${unarchivingUser === user.id || archivingUser === user.id ? 'btn-loading' : ''}`}\n                                  disabled={unarchivingUser === user.id || archivingUser === user.id}\n                                  onClick={() => {\n                                    user.status === 'archived'\n                                      ? this.unarchiveOrgUser(user.id)\n                                      : this.archiveOrgUser(user.id);\n                                  }}\n                                >\n                                  {user.status === 'archived' ? 'Unarchive' : 'Archive'}\n                                </button>\n                              </td>\n                            </tr>\n                          ))}\n                        </tbody>\n                      )}\n                    </table>\n                  </div>\n                </div>\n              </div>\n            )}\n          </div>\n        </div>\n      </div>\n    );\n  }\n}\n\nexport { ManageOrgUsers };\n", "import config from 'config';\nimport { authHeader, handleResponse } from '@/_helpers';\n\nexport const appService = {\n  getConfig,\n  getAll,\n  createApp,\n  cloneApp,\n  exportApp,\n  importApp,\n  changeIcon,\n  deleteApp,\n  getApp,\n  getAppBySlug,\n  getAppByVersion,\n  saveApp,\n  getAppUsers,\n  createAppUser,\n  setVisibility,\n  setMaintenance,\n  setSlug,\n  setPasswordFromToken,\n  acceptInvite,\n};\n\nfunction getConfig() {\n  const requestOptions = { method: 'GET', headers: authHeader() };\n  return fetch(`${config.apiUrl}/config`, requestOptions).then(handleResponse);\n}\n\nfunction getAll(page, folder, searchKey) {\n  const requestOptions = { method: 'GET', headers: authHeader() };\n  if (page === 0) return fetch(`${config.apiUrl}/apps`, requestOptions).then(handleResponse);\n  else\n    return fetch(\n      `${config.apiUrl}/apps?page=${page}&folder=${folder || ''}&searchKey=${searchKey}`,\n      requestOptions\n    ).then(handleResponse);\n}\n\nfunction createApp() {\n  const body = {};\n\n  const requestOptions = { method: 'POST', headers: authHeader(), body: JSON.stringify(body) };\n  return fetch(`${config.apiUrl}/apps`, requestOptions).then(handleResponse);\n}\n\nfunction cloneApp(id) {\n  const requestOptions = { method: 'POST', headers: authHeader() };\n  return fetch(`${config.apiUrl}/apps/${id}/clone`, requestOptions).then(handleResponse);\n}\n\nfunction exportApp(id) {\n  const requestOptions = { method: 'GET', headers: authHeader() };\n  return fetch(`${config.apiUrl}/apps/${id}/export`, requestOptions).then(handleResponse);\n}\n\nfunction importApp(body) {\n  const requestOptions = { method: 'POST', headers: authHeader(), body: JSON.stringify(body) };\n  return fetch(`${config.apiUrl}/apps/import`, requestOptions).then(handleResponse);\n}\n\nfunction changeIcon(icon, appId) {\n  const requestOptions = { method: 'PUT', headers: authHeader(), body: JSON.stringify({ icon }) };\n  return fetch(`${config.apiUrl}/apps/${appId}/icons`, requestOptions).then(handleResponse);\n}\n\nfunction getApp(id) {\n  const requestOptions = { method: 'GET', headers: authHeader() };\n  return fetch(`${config.apiUrl}/apps/${id}`, requestOptions).then(handleResponse);\n}\n\nfunction deleteApp(id) {\n  const requestOptions = { method: 'DELETE', headers: authHeader() };\n  return fetch(`${config.apiUrl}/apps/${id}`, requestOptions).then(handleResponse);\n}\n\nfunction getAppBySlug(slug) {\n  const requestOptions = { method: 'GET', headers: authHeader() };\n  return fetch(`${config.apiUrl}/apps/slugs/${slug}`, requestOptions).then(handleResponse);\n}\n\nfunction getAppByVersion(appId, versionId) {\n  const requestOptions = { method: 'GET', headers: authHeader() };\n  return fetch(`${config.apiUrl}/apps/${appId}/versions/${versionId}`, requestOptions).then(handleResponse);\n}\n\nfunction saveApp(id, attributes) {\n  const requestOptions = { method: 'PUT', headers: authHeader(), body: JSON.stringify({ app: attributes }) };\n  return fetch(`${config.apiUrl}/apps/${id}`, requestOptions).then(handleResponse);\n}\n\nfunction getAppUsers(id) {\n  const requestOptions = { method: 'GET', headers: authHeader() };\n  return fetch(`${config.apiUrl}/apps/${id}/users`, requestOptions).then(handleResponse);\n}\n\nfunction createAppUser(app_id, org_user_id, role) {\n  const body = {\n    app_id,\n    org_user_id,\n    role,\n  };\n\n  const requestOptions = { method: 'POST', headers: authHeader(), body: JSON.stringify(body) };\n  return fetch(`${config.apiUrl}/app_users`, requestOptions).then(handleResponse);\n}\n\nfunction setVisibility(appId, visibility) {\n  const requestOptions = {\n    method: 'PUT',\n    headers: authHeader(),\n    body: JSON.stringify({ app: { is_public: visibility } }),\n  };\n  return fetch(`${config.apiUrl}/apps/${appId}`, requestOptions).then(handleResponse);\n}\n\nfunction setMaintenance(appId, value) {\n  const requestOptions = {\n    method: 'PUT',\n    headers: authHeader(),\n    body: JSON.stringify({ app: { is_maintenance_on: value } }),\n  };\n  return fetch(`${config.apiUrl}/apps/${appId}`, requestOptions).then(handleResponse);\n}\n\nfunction setSlug(appId, slug) {\n  const requestOptions = { method: 'PUT', headers: authHeader(), body: JSON.stringify({ app: { slug: slug } }) };\n  return fetch(`${config.apiUrl}/apps/${appId}`, requestOptions).then(handleResponse);\n}\n\nfunction setPasswordFromToken({ token, password, organization, role, firstName, lastName, organizationToken }) {\n  const body = {\n    token,\n    organizationToken,\n    password,\n    organization,\n    role,\n    first_name: firstName,\n    last_name: lastName,\n  };\n\n  const requestOptions = { method: 'POST', headers: authHeader(), body: JSON.stringify(body) };\n  return fetch(`${config.apiUrl}/set-password-from-token`, requestOptions).then(handleResponse);\n}\n\nfunction acceptInvite({ token, password }) {\n  const body = {\n    token,\n    password,\n  };\n\n  const requestOptions = { method: 'POST', headers: authHeader(), body: JSON.stringify(body) };\n  return fetch(`${config.apiUrl}/accept-invite`, requestOptions);\n}\n", "import config from 'config';\nimport { authHeader, handleResponse } from '@/_helpers';\n\nexport const userService = {\n  getAll,\n  createUser,\n  deleteUser,\n  updateCurrentUser,\n  changePassword,\n  getAvatar,\n  updateAvatar,\n};\n\nfunction getAll() {\n  const requestOptions = { method: 'GET', headers: authHeader() };\n  return fetch(`${config.apiUrl}/users`, requestOptions).then(handleResponse);\n}\n\nfunction getAvatar(id) {\n  const requestOptions = { method: 'GET', headers: authHeader() };\n  return fetch(`${config.apiUrl}/files/${id}`, requestOptions)\n    .then((response) => response.blob())\n    .then((blob) => blob);\n}\n\nfunction updateAvatar(formData, token) {\n  const requestOptions = {\n    method: 'POST',\n    headers: {\n      Authorization: `Bearer ${token}`,\n    },\n    body: formData,\n  };\n  return fetch(`${config.apiUrl}/users/avatar`, requestOptions).then(handleResponse);\n}\n\nfunction createUser(first_name, last_name, email, role) {\n  const body = {\n    first_name,\n    last_name,\n    email,\n    role,\n  };\n\n  const requestOptions = { method: 'POST', headers: authHeader(), body: JSON.stringify(body) };\n  return fetch(`${config.apiUrl}/users`, requestOptions).then(handleResponse);\n}\n\nfunction deleteUser(id) {\n  const requestOptions = { method: 'DELETE', headers: authHeader(), body: JSON.stringify({}) };\n  return fetch(`${config.apiUrl}/users/${id}`, requestOptions).then(handleResponse);\n}\n\nfunction updateCurrentUser(firstName, lastName) {\n  const body = { first_name: firstName, last_name: lastName };\n  const requestOptions = { method: 'PATCH', headers: authHeader(), body: JSON.stringify(body) };\n  return fetch(`${config.apiUrl}/users/update`, requestOptions).then(handleResponse);\n}\n\nfunction changePassword(currentPassword, newPassword) {\n  const body = { currentPassword, newPassword };\n  const requestOptions = { method: 'PATCH', headers: authHeader(), body: JSON.stringify(body) };\n  return fetch(`${config.apiUrl}/users/change_password`, requestOptions).then(handleResponse);\n}\n", "import { Controller, Get, Request, Post, UseGuards, Body, Param, BadRequestException } from '@nestjs/common';\nimport { User } from 'src/decorators/user.decorator';\nimport { JwtAuthGuard } from '../../src/modules/auth/jwt-auth.guard';\nimport { AppAuthenticationDto, AppForgotPasswordDto, AppPasswordResetDto } from '@dto/app-authentication.dto';\nimport { AuthService } from '../services/auth.service';\nimport { MultiOrganizationGuard } from 'src/modules/auth/multi-organization.guard';\nimport { SignupDisableGuard } from 'src/modules/auth/signup-disable.guard';\nimport { CreateUserDto } from '@dto/user.dto';\nimport { AcceptInviteDto } from '@dto/accept-organization-invite.dto';\n\n@Controller()\nexport class AppController {\n  constructor(private authService: AuthService) {}\n\n  @Post(['authenticate', 'authenticate/:organizationId'])\n  async login(@Body() appAuthDto: AppAuthenticationDto, @Param('organizationId') organizationId) {\n    return this.authService.login(appAuthDto.email, appAuthDto.password, organizationId);\n  }\n\n  @UseGuards(JwtAuthGuard)\n  @Get('switch/:organizationId')\n  async switch(@Param('organizationId') organizationId, @User() user) {\n    if (!organizationId) {\n      throw new BadRequestException();\n    }\n    return await this.authService.switchOrganization(organizationId, user);\n  }\n\n  @UseGuards(MultiOrganizationGuard, SignupDisableGuard)\n  @Post('set-password-from-token')\n  async create(@Body() userCreateDto: CreateUserDto) {\n    await this.authService.setupAccountFromInvitationToken(userCreateDto);\n    return {};\n  }\n\n  @Post('accept-invite')\n  async acceptInvite(@Body() acceptInviteDto: AcceptInviteDto) {\n    await this.authService.acceptOrganizationInvite(acceptInviteDto);\n    return {};\n  }\n\n  @UseGuards(MultiOrganizationGuard, SignupDisableGuard)\n  @Post('signup')\n  async signup(@Body() appAuthDto: AppAuthenticationDto) {\n    return this.authService.signup(appAuthDto.email);\n  }\n\n  @Post('/forgot_password')\n  async forgotPassword(@Body() appAuthDto: AppForgotPasswordDto) {\n    await this.authService.forgotPassword(appAuthDto.email);\n    return {};\n  }\n\n  @Post('/reset_password')\n  async resetPassword(@Body() appAuthDto: AppPasswordResetDto) {\n    const { token, password } = appAuthDto;\n    await this.authService.resetPassword(token, password);\n    return {};\n  }\n\n  @Get('/health')\n  async healthCheck(@Request() req) {\n    return { works: 'yeah' };\n  }\n}\n", "import { Controller, Param, Post, UseGuards, Body } from '@nestjs/common';\nimport { OrganizationUsersService } from 'src/services/organization_users.service';\nimport { decamelizeKeys } from 'humps';\nimport { JwtAuthGuard } from '../../src/modules/auth/jwt-auth.guard';\nimport { AppAbility } from 'src/modules/casl/casl-ability.factory';\nimport { PoliciesGuard } from 'src/modules/casl/policies.guard';\nimport { CheckPolicies } from 'src/modules/casl/check_policies.decorator';\nimport { User as UserEntity } from 'src/entities/user.entity';\nimport { User } from 'src/decorators/user.decorator';\nimport { InviteNewUserDto } from '../dto/invite-new-user.dto';\nimport { OrganizationsService } from '@services/organizations.service';\n\n@Controller('organization_users')\nexport class OrganizationUsersController {\n  constructor(\n    private organizationUsersService: OrganizationUsersService,\n    private organizationsService: OrganizationsService\n  ) {}\n\n  // Endpoint for inviting new organization users\n  @UseGuards(JwtAuthGuard, PoliciesGuard)\n  @CheckPolicies((ability: AppAbility) => ability.can('inviteUser', UserEntity))\n  @Post()\n  async create(@User() user, @Body() inviteNewUserDto: InviteNewUserDto) {\n    const result = await this.organizationsService.inviteNewUser(user, inviteNewUserDto);\n    return decamelizeKeys({ users: result });\n  }\n\n  @UseGuards(JwtAuthGuard, PoliciesGuard)\n  @CheckPolicies((ability: AppAbility) => ability.can('archiveUser', UserEntity))\n  @Post(':id/archive')\n  async archive(@Param('id') id: string) {\n    const result = await this.organizationUsersService.archive(id);\n    return decamelizeKeys({ result });\n  }\n\n  @UseGuards(JwtAuthGuard, PoliciesGuard)\n  @CheckPolicies((ability: AppAbility) => ability.can('archiveUser', UserEntity))\n  @Post(':id/unarchive')\n  async unarchive(@User() user, @Param('id') id: string) {\n    const result = await this.organizationUsersService.unarchive(user, id);\n    return decamelizeKeys({ result });\n  }\n\n  // Deprecated\n  @UseGuards(JwtAuthGuard, PoliciesGuard)\n  @CheckPolicies((ability: AppAbility) => ability.can('changeRole', UserEntity))\n  @Post(':id/change_role')\n  async changeRole(@Param('id') id, @Body('role') role) {\n    const result = await this.organizationUsersService.changeRole(id, role);\n    return decamelizeKeys({ result });\n  }\n}\n", "import { Body, Controller, Post, Patch, UseGuards, UseInterceptors, UploadedFile } from '@nestjs/common';\nimport { Express } from 'express';\nimport { FileInterceptor } from '@nestjs/platform-express';\nimport { JwtAuthGuard } from 'src/modules/auth/jwt-auth.guard';\nimport { PasswordRevalidateGuard } from 'src/modules/auth/password-revalidate.guard';\nimport { UsersService } from 'src/services/users.service';\nimport { User } from 'src/decorators/user.decorator';\nimport { UpdateUserDto } from '@dto/user.dto';\n\n@Controller('users')\nexport class UsersController {\n  constructor(private usersService: UsersService) {}\n\n  @UseGuards(JwtAuthGuard)\n  @Patch('update')\n  async update(@User() user, @Body() updateUserDto: UpdateUserDto) {\n    const { first_name: firstName, last_name: lastName } = updateUserDto;\n    await this.usersService.update(user.id, { firstName, lastName });\n    await user.reload();\n    return {\n      first_name: user.firstName,\n      last_name: user.lastName,\n    };\n  }\n\n  @Post('avatar')\n  @UseGuards(JwtAuthGuard)\n  @UseInterceptors(FileInterceptor('file'))\n  async addAvatar(@User() user, @UploadedFile() file: Express.Multer.File) {\n    return this.usersService.addAvatar(user.id, file.buffer, file.originalname);\n  }\n\n  @UseGuards(JwtAuthGuard, PasswordRevalidateGuard)\n  @Patch('change_password')\n  async changePassword(@User() user, @Body('newPassword') newPassword) {\n    return await this.usersService.update(user.id, {\n      password: newPassword,\n    });\n  }\n}\n", "import { IsString, IsNotEmpty, IsOptional } from 'class-validator';\n\nexport class AcceptInviteDto {\n  @IsString()\n  @IsOptional()\n  @IsNotEmpty()\n  password: string;\n\n  @IsString()\n  @IsNotEmpty()\n  token: string;\n}\n", "import { IsString, IsOptional, IsNotEmpty } from 'class-validator';\nimport { Transform } from 'class-transformer';\nimport { sanitizeInput } from 'src/helpers/utils.helper';\nimport { PartialType } from '@nestjs/mapped-types';\n\nexport class CreateUserDto {\n  @IsString()\n  @IsOptional()\n  @IsNotEmpty()\n  @Transform(({ value }) => sanitizeInput(value))\n  first_name: string;\n\n  @IsString()\n  @IsOptional()\n  @IsNotEmpty()\n  @Transform(({ value }) => sanitizeInput(value))\n  last_name: string;\n\n  @IsString()\n  @IsOptional()\n  @IsNotEmpty()\n  @Transform(({ value }) => sanitizeInput(value))\n  organization: string;\n\n  @IsString()\n  @IsNotEmpty()\n  password: string;\n\n  @IsString()\n  @IsOptional()\n  @IsNotEmpty()\n  organizationToken: string;\n\n  @IsString()\n  @IsNotEmpty()\n  token: string;\n\n  @IsString()\n  @IsOptional()\n  @Transform(({ value }) => sanitizeInput(value))\n  role: string;\n}\n\nexport class UpdateUserDto extends PartialType(CreateUserDto) {}\n", "import {\n  BadRequestException,\n  Injectable,\n  NotAcceptableException,\n  NotFoundException,\n  UnauthorizedException,\n} from '@nestjs/common';\nimport { UsersService } from './users.service';\nimport { OrganizationsService } from './organizations.service';\nimport { JwtService } from '@nestjs/jwt';\nimport { User } from '../entities/user.entity';\nimport { OrganizationUsersService } from './organization_users.service';\nimport { EmailService } from './email.service';\nimport { decamelizeKeys } from 'humps';\nimport { Organization } from 'src/entities/organization.entity';\nimport { ConfigService } from '@nestjs/config';\nimport { SSOConfigs } from 'src/entities/sso_config.entity';\nimport { InjectRepository } from '@nestjs/typeorm';\nimport { Repository } from 'typeorm';\nimport { OrganizationUser } from 'src/entities/organization_user.entity';\nimport { CreateUserDto } from '@dto/user.dto';\nimport { AcceptInviteDto } from '@dto/accept-organization-invite.dto';\nconst bcrypt = require('bcrypt');\nconst uuid = require('uuid');\n\n@Injectable()\nexport class AuthService {\n  constructor(\n    @InjectRepository(User)\n    private usersRepository: Repository<User>,\n    @InjectRepository(OrganizationUser)\n    private organizationUsersRepository: Repository<OrganizationUser>,\n    @InjectRepository(Organization)\n    private organizationsRepository: Repository<Organization>,\n    private usersService: UsersService,\n    private jwtService: JwtService,\n    private organizationsService: OrganizationsService,\n    private organizationUsersService: OrganizationUsersService,\n    private emailService: EmailService,\n    private configService: ConfigService\n  ) {}\n\n  verifyToken(token: string) {\n    try {\n      const signedJwt = this.jwtService.verify(token);\n      return signedJwt;\n    } catch (err) {\n      return null;\n    }\n  }\n\n  private async validateUser(email: string, password: string, organizationId?: string): Promise<User> {\n    const user = await this.usersService.findByEmail(email, organizationId);\n\n    if (!user) return null;\n\n    const isVerified = await bcrypt.compare(password, user.password);\n\n    return isVerified ? user : null;\n  }\n\n  async login(email: string, password: string, organizationId?: string) {\n    let organization: Organization;\n\n    const user = await this.validateUser(email, password, organizationId);\n\n    if (user && (await this.usersService.status(user)) !== 'archived') {\n      if (!organizationId) {\n        // Global login\n        // Determine the organization to be loaded\n        if (this.configService.get<string>('DISABLE_MULTI_WORKSPACE') === 'true') {\n          // Single organization\n          organization = await this.organizationsService.getSingleOrganization();\n          if (!organization?.ssoConfigs?.find((oc) => oc.sso == 'form' && oc.enabled)) {\n            throw new UnauthorizedException();\n          }\n        } else {\n          const organizationList: Organization[] = await this.organizationsService.findOrganizationSupportsFormLogin(\n            user\n          );\n\n          const defaultOrgDetails: Organization = organizationList?.find((og) => og.id === user.defaultOrganizationId);\n          // Multi organization\n          if (defaultOrgDetails) {\n            // default organization form login enabled\n            organization = defaultOrgDetails;\n          } else if (organizationList?.length > 0) {\n            // default organization form login not enabled, picking first one from form enabled list\n            organization = organizationList[0];\n          } else {\n            // no form login enabled organization available for user - creating new one\n            organization = await this.organizationsService.create('Untitled workspace', user);\n          }\n        }\n        user.organizationId = organization.id;\n      } else {\n        // organization specific login\n        user.organizationId = organizationId;\n\n        organization = await this.organizationsService.get(user.organizationId);\n        const formConfigs: SSOConfigs = organization?.ssoConfigs?.find((sso) => sso.sso === 'form');\n\n        if (!formConfigs?.enabled) {\n          // no configurations in organization side or Form login disabled for the organization\n          throw new UnauthorizedException('Password login is disabled for the organization');\n        }\n      }\n\n      if (user.defaultOrganizationId !== user.organizationId) {\n        // Updating default organization Id\n        await this.usersService.updateDefaultOrganization(user, organization.id);\n      }\n\n      const payload = {\n        username: user.id,\n        sub: user.email,\n        organizationId: user.organizationId,\n        isPasswordLogin: true,\n      };\n\n      return decamelizeKeys({\n        id: user.id,\n        auth_token: this.jwtService.sign(payload),\n        email: user.email,\n        first_name: user.firstName,\n        last_name: user.lastName,\n        avatar_id: user.avatarId,\n        organizationId: user.organizationId,\n        organization: organization.name,\n        admin: await this.usersService.hasGroup(user, 'admin'),\n        group_permissions: await this.usersService.groupPermissions(user),\n        app_group_permissions: await this.usersService.appGroupPermissions(user),\n      });\n    } else {\n      throw new UnauthorizedException('Invalid credentials');\n    }\n  }\n\n  async switchOrganization(newOrganizationId: string, user: User, isNewOrganization?: boolean) {\n    if (!(isNewOrganization || user.isPasswordLogin)) {\n      throw new UnauthorizedException();\n    }\n    if (this.configService.get<string>('DISABLE_MULTI_WORKSPACE') === 'true') {\n      throw new UnauthorizedException();\n    }\n    const newUser = await this.usersService.findByEmail(user.email, newOrganizationId);\n\n    if (newUser && (await this.usersService.status(newUser)) !== 'archived') {\n      newUser.organizationId = newOrganizationId;\n\n      const organization: Organization = await this.organizationsService.get(newUser.organizationId);\n\n      const formConfigs: SSOConfigs = organization?.ssoConfigs?.find((sso) => sso.sso === 'form');\n\n      if (!formConfigs?.enabled) {\n        // no configurations in organization side or Form login disabled for the organization\n        throw new UnauthorizedException('Password login disabled for the organization');\n      }\n\n      // Updating default organization Id\n      await this.usersService.updateDefaultOrganization(newUser, newUser.organizationId);\n\n      const payload = {\n        username: user.id,\n        sub: user.email,\n        organizationId: newUser.organizationId,\n        isPasswordLogin: true,\n      };\n\n      return decamelizeKeys({\n        id: newUser.id,\n        auth_token: this.jwtService.sign(payload),\n        email: newUser.email,\n        first_name: newUser.firstName,\n        last_name: newUser.lastName,\n        organizationId: newUser.organizationId,\n        organization: organization.name,\n        admin: await this.usersService.hasGroup(newUser, 'admin'),\n        group_permissions: await this.usersService.groupPermissions(newUser),\n        app_group_permissions: await this.usersService.appGroupPermissions(newUser),\n      });\n    } else {\n      throw new UnauthorizedException('Invalid credentials');\n    }\n  }\n\n  async signup(email: string) {\n    const existingUser = await this.usersService.findByEmail(email);\n    if (existingUser?.organizationUsers?.some((ou) => ou.status === 'active')) {\n      throw new NotAcceptableException('Email already exists');\n    }\n\n    if (existingUser?.invitationToken) {\n      await this.emailService.sendWelcomeEmail(\n        existingUser.email,\n        existingUser.firstName,\n        existingUser.invitationToken\n      );\n      return;\n    }\n\n    let organization: Organization;\n    // Check if the configs allows user signups\n    if (this.configService.get<string>('DISABLE_MULTI_WORKSPACE') === 'true') {\n      // Single organization checking if organization exist\n      organization = await this.organizationsService.getSingleOrganization();\n\n      if (organization) {\n        throw new NotAcceptableException('Multi organization not supported - organization exist');\n      }\n    } else {\n      // Multi organization\n      if (this.configService.get<string>('DISABLE_SIGNUPS') === 'true') {\n        throw new NotAcceptableException();\n      }\n    }\n    // Create default organization\n    organization = await this.organizationsService.create('Untitled workspace');\n    const user = await this.usersService.create({ email }, organization.id, ['all_users', 'admin'], existingUser, true);\n    await this.organizationUsersService.create(user, organization, true);\n    await this.emailService.sendWelcomeEmail(user.email, user.firstName, user.invitationToken);\n\n    return {};\n  }\n\n  async forgotPassword(email: string) {\n    const user = await this.usersService.findByEmail(email);\n    const forgotPasswordToken = uuid.v4();\n    await this.usersService.update(user.id, { forgotPasswordToken });\n    await this.emailService.sendPasswordResetEmail(email, forgotPasswordToken);\n  }\n\n  async resetPassword(token: string, password: string) {\n    const user = await this.usersService.findByPasswordResetToken(token);\n    if (!user) {\n      throw new NotFoundException('Invalid token');\n    } else {\n      await this.usersService.update(user.id, {\n        password,\n        forgotPasswordToken: null,\n      });\n    }\n  }\n\n  async setupAccountFromInvitationToken(userCreateDto: CreateUserDto) {\n    const {\n      organization,\n      password,\n      token,\n      role,\n      first_name: firstName,\n      last_name: lastName,\n      organizationToken,\n    } = userCreateDto;\n\n    if (!token) {\n      throw new BadRequestException('Invalid token');\n    }\n\n    const user: User = await this.usersRepository.findOne({ where: { invitationToken: token } });\n\n    if (!user?.organizationUsers) {\n      throw new BadRequestException('Invalid invitation link');\n    }\n    const organizationUser: OrganizationUser = user.organizationUsers.find(\n      (ou) => ou.organizationId === user.defaultOrganizationId\n    );\n\n    if (!organizationUser) {\n      throw new BadRequestException('Invalid invitation link');\n    }\n\n    await this.usersRepository.save(\n      Object.assign(user, {\n        firstName,\n        lastName,\n        password,\n        role,\n        invitationToken: null,\n      })\n    );\n\n    await this.organizationUsersRepository.save(\n      Object.assign(organizationUser, {\n        invitationToken: null,\n        status: 'active',\n      })\n    );\n\n    if (organization) {\n      await this.organizationsRepository.update(user.defaultOrganizationId, {\n        name: organization,\n      });\n    }\n\n    if (this.configService.get<string>('DISABLE_MULTI_WORKSPACE') !== 'true' && organizationToken) {\n      const organizationUser = await this.organizationUsersRepository.findOne({\n        where: { invitationToken: organizationToken },\n      });\n\n      if (organizationUser) {\n        await this.organizationUsersRepository.save(\n          Object.assign(organizationUser, {\n            invitationToken: null,\n            status: 'active',\n          })\n        );\n      }\n    }\n  }\n\n  async acceptOrganizationInvite(acceptInviteDto: AcceptInviteDto) {\n    const { password, token } = acceptInviteDto;\n\n    if (this.configService.get<string>('DISABLE_MULTI_WORKSPACE') === 'true' && !password) {\n      throw new BadRequestException('Please enter password');\n    }\n    const organizationUser = await this.organizationUsersRepository.findOne({\n      where: { invitationToken: token },\n      relations: ['user'],\n    });\n\n    if (!organizationUser?.user) {\n      throw new BadRequestException('Invalid invitation link');\n    }\n    const user: User = organizationUser.user;\n\n    if (this.configService.get<string>('DISABLE_MULTI_WORKSPACE') !== 'true' && user.invitationToken) {\n      // User sign up link send - not activated account\n      this.emailService\n        .sendWelcomeEmail(\n          user.email,\n          `${user.firstName} ${user.lastName}`,\n          user.invitationToken,\n          organizationUser.invitationToken\n        )\n        .catch((err) => console.error('Error while sending welcome mail', err));\n      throw new UnauthorizedException(\n        'User not exist in the workspace, Please setup your account using link shared via email'\n      );\n    }\n\n    if (this.configService.get<string>('DISABLE_MULTI_WORKSPACE') === 'true') {\n      // set new password\n      await this.usersRepository.save(\n        Object.assign(user, {\n          ...(password ? { password } : {}),\n          invitationToken: null,\n        })\n      );\n    }\n\n    await this.organizationUsersRepository.save(\n      Object.assign(organizationUser, {\n        invitationToken: null,\n        status: 'active',\n      })\n    );\n  }\n}\n", "import { Injectable } from '@nestjs/common';\nconst nodemailer = require('nodemailer');\nconst previewEmail = require('preview-email');\n\n@Injectable()\nexport class EmailService {\n  private FROM_EMAIL;\n  private TOOLJET_HOST;\n  private NODE_ENV;\n\n  constructor() {\n    this.FROM_EMAIL = process.env.DEFAULT_FROM_EMAIL || 'hello@tooljet.io';\n    this.TOOLJET_HOST = this.stripTrailingSlash(process.env.TOOLJET_HOST);\n    this.NODE_ENV = process.env.NODE_ENV || 'development';\n  }\n\n  async sendEmail(to: string, subject: string, html: string) {\n    if (this.NODE_ENV === 'test') return;\n\n    const port = +process.env.SMTP_PORT || 587;\n    const transporter = nodemailer.createTransport({\n      host: process.env.SMTP_DOMAIN,\n      port: port,\n      secure: port == 465,\n      auth: {\n        user: process.env.SMTP_USERNAME,\n        pass: process.env.SMTP_PASSWORD,\n      },\n    });\n\n    const message = {\n      from: `\"ToolJet\" <${this.FROM_EMAIL}>`,\n      to,\n      subject,\n      html,\n    };\n\n    /* if development environment, log the content of email instead of sending actual emails */\n    if (this.NODE_ENV === 'development') {\n      console.log('Captured email');\n      console.log('to: ', to);\n      console.log('Subject: ', subject);\n      console.log('content: ', html);\n\n      previewEmail(message).then(console.log).catch(console.error);\n    } else {\n      const info = await transporter.sendMail(message);\n      console.log('Message sent: %s', info);\n    }\n  }\n\n  stripTrailingSlash(hostname: string) {\n    return hostname?.endsWith('/') ? hostname.slice(0, -1) : hostname;\n  }\n\n  async sendWelcomeEmail(\n    to: string,\n    name: string,\n    invitationtoken: string,\n    organizationInvitationToken?: string,\n    organizationName?: string,\n    sender?: string\n  ) {\n    const subject = 'Welcome to ToolJet';\n    const inviteUrl = `${this.TOOLJET_HOST}/invitations/${invitationtoken}${\n      organizationInvitationToken ? `/workspaces/${organizationInvitationToken}` : ''\n    }`;\n    const html = `\n      <!DOCTYPE html>\n      <html>\n        <head>\n          <meta content='text/html; charset=UTF-8' http-equiv='Content-Type' />\n        </head>\n        <body>\n          <p>Hi ${name || ''},</p>\n          ${\n            organizationInvitationToken && sender && organizationName\n              ? `<span>\n              ${sender} has invited you to use ToolJet workspace: ${organizationName}.\n            </span>`\n              : ''\n          }\n          <span>\n            Please use the link below to set up your account and get started.\n          </span>\n          <br>\n          <a href=\"${inviteUrl}\">${inviteUrl}</a>\n          <br>\n          <p>\n            Welcome aboard,<br>\n            ToolJet Team\n          </p>\n        </body>\n      </html>\n    `;\n\n    await this.sendEmail(to, subject, html);\n  }\n\n  async sendOrganizationUserWelcomeEmail(\n    to: string,\n    name: string,\n    sender: string,\n    invitationtoken: string,\n    organizationName: string\n  ) {\n    const subject = 'Welcome to ToolJet';\n    const inviteUrl = `${this.TOOLJET_HOST}/organization-invitations/${invitationtoken}`;\n    const html = `\n      <!DOCTYPE html>\n      <html>\n        <head>\n          <meta content='text/html; charset=UTF-8' http-equiv='Content-Type' />\n        </head>\n        <body>\n          <p>Hi ${name || ''},</p>\n          <br>\n          <span>\n          ${sender} has invited you to use ToolJet workspace: ${organizationName}. Use the link below to set up your account and get started.\n          </span>\n          <br>\n          <a href=\"${inviteUrl}\">${inviteUrl}</a>\n          <br>\n          <br>\n          <p>\n            Welcome aboard,<br>\n            ToolJet Team\n          </p>\n        </body>\n      </html>\n    `;\n\n    await this.sendEmail(to, subject, html);\n  }\n\n  async sendPasswordResetEmail(to: string, token: string) {\n    const subject = 'password reset instructions';\n    const html = `\n      Please use this code to reset your password: ${token}\n    `;\n    await this.sendEmail(to, subject, html);\n  }\n}\n", "import { Injectable } from '@nestjs/common';\nimport { InjectRepository } from '@nestjs/typeorm';\nimport { User } from '../entities/user.entity';\nimport { createQueryBuilder, getManager, Repository } from 'typeorm';\nimport { UsersService } from 'src/services/users.service';\nimport { OrganizationUser } from 'src/entities/organization_user.entity';\nimport { BadRequestException } from '@nestjs/common';\nimport { EmailService } from './email.service';\nimport { Organization } from 'src/entities/organization.entity';\nimport { GroupPermission } from 'src/entities/group_permission.entity';\nconst uuid = require('uuid');\n\n@Injectable()\nexport class OrganizationUsersService {\n  constructor(\n    @InjectRepository(OrganizationUser)\n    private organizationUsersRepository: Repository<OrganizationUser>,\n    private usersService: UsersService,\n    private emailService: EmailService\n  ) {}\n\n  async findOrganization(id: string): Promise<OrganizationUser> {\n    return await this.organizationUsersRepository.findOne({ where: { id } });\n  }\n\n  async create(user: User, organization: Organization, isInvite?: boolean): Promise<OrganizationUser> {\n    return await this.organizationUsersRepository.save(\n      this.organizationUsersRepository.create({\n        user,\n        organization,\n        invitationToken: isInvite ? uuid.v4() : null,\n        status: isInvite ? 'invited' : 'active',\n        role: 'all-users',\n        createdAt: new Date(),\n        updatedAt: new Date(),\n      })\n    );\n  }\n\n  async changeRole(id: string, role: string) {\n    const organizationUser = await this.organizationUsersRepository.findOne({ where: { id } });\n    if (organizationUser.role == 'admin') {\n      const lastActiveAdmin = await this.lastActiveAdmin(organizationUser.organizationId);\n\n      if (lastActiveAdmin) {\n        throw new BadRequestException('Atleast one active admin is required.');\n      }\n    }\n    return await this.organizationUsersRepository.update(id, { role });\n  }\n\n  async archive(id: string) {\n    await getManager().transaction(async (manager) => {\n      const organizationUser = await manager.findOne(OrganizationUser, {\n        where: { id },\n      });\n      const user = await manager.findOne(User, {\n        where: { id: organizationUser.userId },\n      });\n\n      await this.usersService.throwErrorIfRemovingLastActiveAdmin(user, undefined, organizationUser.organizationId);\n\n      await manager.update(OrganizationUser, id, { status: 'archived', invitationToken: null });\n    });\n\n    return true;\n  }\n\n  async unarchive(user: User, id: string) {\n    const organizationUser = await this.organizationUsersRepository.findOne({\n      where: { id },\n    });\n    if (organizationUser.status !== 'archived') return false;\n\n    const invitationToken = uuid.v4();\n\n    await getManager().transaction(async (manager) => {\n      await manager.update(OrganizationUser, organizationUser.id, {\n        status: 'invited',\n        invitationToken,\n      });\n      await manager.update(User, organizationUser.userId, { password: uuid.v4() });\n    });\n\n    const updatedUser = await this.usersService.findOne(organizationUser.userId);\n\n    const currentOrganization: Organization = (\n      await this.organizationUsersRepository.findOne({\n        where: { userId: user.id, organizationId: user.organizationId },\n        relations: ['organization'],\n      })\n    )?.organization;\n\n    await this.emailService.sendOrganizationUserWelcomeEmail(\n      updatedUser.email,\n      updatedUser.firstName,\n      user.firstName,\n      invitationToken,\n      currentOrganization.name\n    );\n\n    return true;\n  }\n\n  async activate(user: OrganizationUser) {\n    await this.organizationUsersRepository.update(user.id, {\n      status: 'active',\n    });\n  }\n\n  async lastActiveAdmin(organizationId: string): Promise<boolean> {\n    const adminsCount = await this.activeAdminCount(organizationId);\n\n    return adminsCount <= 1;\n  }\n\n  async activeAdminCount(organizationId: string) {\n    return await createQueryBuilder(GroupPermission, 'group_permissions')\n      .innerJoin('group_permissions.userGroupPermission', 'user_group_permission')\n      .where('group_permissions.group = :admin', { admin: 'admin' })\n      .andWhere('group_permissions.organization = :organizationId', { organizationId })\n      .getCount();\n  }\n}\n", "import { BadRequestException, Injectable } from '@nestjs/common';\nimport { InjectRepository } from '@nestjs/typeorm';\nimport { GroupPermission } from 'src/entities/group_permission.entity';\nimport { Organization } from 'src/entities/organization.entity';\nimport { SSOConfigs } from 'src/entities/sso_config.entity';\nimport { User } from 'src/entities/user.entity';\nimport { cleanObject } from 'src/helpers/utils.helper';\nimport { createQueryBuilder, Repository } from 'typeorm';\nimport { OrganizationUser } from '../entities/organization_user.entity';\nimport { EmailService } from './email.service';\nimport { EncryptionService } from './encryption.service';\nimport { GroupPermissionsService } from './group_permissions.service';\nimport { OrganizationUsersService } from './organization_users.service';\nimport { UsersService } from './users.service';\nimport { InviteNewUserDto } from '@dto/invite-new-user.dto';\nimport { ConfigService } from '@nestjs/config';\n\n@Injectable()\nexport class OrganizationsService {\n  constructor(\n    @InjectRepository(Organization)\n    private organizationsRepository: Repository<Organization>,\n    @InjectRepository(SSOConfigs)\n    private ssoConfigRepository: Repository<SSOConfigs>,\n    @InjectRepository(OrganizationUser)\n    private organizationUsersRepository: Repository<OrganizationUser>,\n    @InjectRepository(GroupPermission)\n    private groupPermissionsRepository: Repository<GroupPermission>,\n    private usersService: UsersService,\n    private organizationUserService: OrganizationUsersService,\n    private groupPermissionService: GroupPermissionsService,\n    private encryptionService: EncryptionService,\n    private emailService: EmailService,\n    private configService: ConfigService\n  ) {}\n\n  async create(name: string, user?: User): Promise<Organization> {\n    const organization = await this.organizationsRepository.save(\n      this.organizationsRepository.create({\n        ssoConfigs: [\n          {\n            sso: 'form',\n            enabled: true,\n          },\n        ],\n        name,\n        createdAt: new Date(),\n        updatedAt: new Date(),\n      })\n    );\n\n    const createdGroupPermissions = await this.createDefaultGroupPermissionsForOrganization(organization);\n\n    if (user) {\n      await this.organizationUserService.create(user, organization, false);\n\n      for (const groupPermission of createdGroupPermissions) {\n        await this.groupPermissionService.createUserGroupPermission(user.id, groupPermission.id);\n      }\n    }\n\n    return organization;\n  }\n\n  async get(id: string): Promise<Organization> {\n    return await this.organizationsRepository.findOne({ where: { id }, relations: ['ssoConfigs'] });\n  }\n\n  async getSingleOrganization(): Promise<Organization> {\n    return await this.organizationsRepository.findOne({ relations: ['ssoConfigs'] });\n  }\n\n  async createDefaultGroupPermissionsForOrganization(organization: Organization) {\n    const defaultGroups = ['all_users', 'admin'];\n    const createdGroupPermissions = [];\n\n    for (const group of defaultGroups) {\n      const isAdmin = group === 'admin';\n      const groupPermission = this.groupPermissionsRepository.create({\n        organizationId: organization.id,\n        group: group,\n        appCreate: isAdmin,\n        appDelete: isAdmin,\n        folderCreate: isAdmin,\n      });\n      await this.groupPermissionsRepository.save(groupPermission);\n      createdGroupPermissions.push(groupPermission);\n    }\n\n    return createdGroupPermissions;\n  }\n\n  async fetchUsers(user: any): Promise<OrganizationUser[]> {\n    const organizationUsers = await this.organizationUsersRepository.find({\n      where: { organizationId: user.organizationId },\n      relations: ['user'],\n    });\n\n    const isAdmin = await this.usersService.hasGroup(user, 'admin');\n\n    // serialize\n    const serializedUsers = [];\n    for (const orgUser of organizationUsers) {\n      const serializedUser = {\n        email: orgUser.user.email,\n        firstName: orgUser.user.firstName,\n        lastName: orgUser.user.lastName,\n        name: `${orgUser.user.firstName} ${orgUser.user.lastName}`,\n        id: orgUser.id,\n        role: orgUser.role,\n        status: orgUser.status,\n      };\n\n      if (isAdmin && orgUser.invitationToken) {\n        serializedUser['invitationToken'] = orgUser.invitationToken;\n      }\n      serializedUsers.push(serializedUser);\n    }\n\n    return serializedUsers;\n  }\n\n  async fetchOrganisations(user: any): Promise<Organization[]> {\n    return await createQueryBuilder(Organization, 'organization')\n      .innerJoin(\n        'organization.organizationUsers',\n        'organisation_users',\n        'organisation_users.status IN(:...statusList)',\n        {\n          statusList: ['active'],\n        }\n      )\n      .andWhere('organisation_users.userId = :userId', {\n        userId: user.id,\n      })\n      .orderBy('name', 'ASC')\n      .getMany();\n  }\n\n  async findOrganizationSupportsFormLogin(user: any): Promise<Organization[]> {\n    return await createQueryBuilder(Organization, 'organization')\n      .innerJoin('organization.ssoConfigs', 'organisation_sso', 'organisation_sso.sso = :form', {\n        form: 'form',\n      })\n      .innerJoin(\n        'organization.organizationUsers',\n        'organisation_users',\n        'organisation_users.status IN(:...statusList)',\n        {\n          statusList: ['active'],\n        }\n      )\n      .where('organisation_sso.enabled = :enabled', {\n        enabled: true,\n      })\n      .andWhere('organisation_users.userId = :userId', {\n        userId: user.id,\n      })\n      .orderBy('name', 'ASC')\n      .getMany();\n  }\n\n  async getSSOConfigs(organizationId: string, sso: string): Promise<Organization> {\n    return await createQueryBuilder(Organization, 'organization')\n      .leftJoinAndSelect('organization.ssoConfigs', 'organisation_sso', 'organisation_sso.sso = :sso', {\n        sso,\n      })\n      .andWhere('organization.id = :organizationId', {\n        organizationId,\n      })\n      .getOne();\n  }\n\n  async fetchOrganisationDetails(\n    organizationId: string,\n    statusList?: Array<boolean>,\n    isHideSensitiveData?: boolean\n  ): Promise<Organization> {\n    const result = await createQueryBuilder(Organization, 'organization')\n      .innerJoinAndSelect(\n        'organization.ssoConfigs',\n        'organisation_sso',\n        'organisation_sso.enabled IN (:...statusList)',\n        {\n          statusList: statusList || [true, false], // Return enabled and disabled sso if status list not passed\n        }\n      )\n      .andWhere('organization.id = :organizationId', {\n        organizationId,\n      })\n      .getOne();\n\n    if (!(result?.ssoConfigs?.length > 0)) {\n      return;\n    }\n\n    for (const sso of result?.ssoConfigs) {\n      await this.decryptSecret(sso?.configs);\n    }\n\n    if (!isHideSensitiveData) {\n      return result;\n    }\n    return this.hideSSOSensitiveData(result?.ssoConfigs, result?.name);\n  }\n\n  private hideSSOSensitiveData(ssoConfigs: SSOConfigs[], organizationName): any {\n    const configs = { name: organizationName };\n    if (ssoConfigs?.length > 0) {\n      for (const config of ssoConfigs) {\n        const configId = config['id'];\n        delete config['id'];\n        delete config['organizationId'];\n        delete config['createdAt'];\n        delete config['updatedAt'];\n\n        configs[config.sso] = this.buildConfigs(config, configId);\n      }\n    }\n    return configs;\n  }\n\n  private buildConfigs(config: any, configId: string) {\n    if (!config) return config;\n    return {\n      ...config,\n      configs: {\n        ...(config?.configs || {}),\n        ...(config?.configs ? { clientSecret: '' } : {}),\n      },\n      configId,\n    };\n  }\n\n  private async encryptSecret(configs) {\n    if (!configs || typeof configs !== 'object') return configs;\n    await Promise.all(\n      Object.keys(configs).map(async (key) => {\n        if (key.toLowerCase().includes('secret')) {\n          if (configs[key]) {\n            configs[key] = await this.encryptionService.encryptColumnValue('ssoConfigs', key, configs[key]);\n          }\n        }\n      })\n    );\n  }\n\n  private async decryptSecret(configs) {\n    if (!configs || typeof configs !== 'object') return configs;\n    await Promise.all(\n      Object.keys(configs).map(async (key) => {\n        if (key.toLowerCase().includes('secret')) {\n          if (configs[key]) {\n            configs[key] = await this.encryptionService.decryptColumnValue('ssoConfigs', key, configs[key]);\n          }\n        }\n      })\n    );\n  }\n\n  async updateOrganization(organizationId: string, params) {\n    const { name, domain, enableSignUp } = params;\n\n    const updateableParams = {\n      name,\n      domain,\n      enableSignUp,\n    };\n\n    // removing keys with undefined values\n    cleanObject(updateableParams);\n\n    return await this.organizationsRepository.update(organizationId, updateableParams);\n  }\n\n  async updateOrganizationConfigs(organizationId: string, params: any) {\n    const { type, configs, enabled } = params;\n\n    if (!(type && ['git', 'google', 'form'].includes(type))) {\n      throw new BadRequestException();\n    }\n\n    await this.encryptSecret(configs);\n    const organization: Organization = await this.getSSOConfigs(organizationId, type);\n\n    if (organization?.ssoConfigs?.length > 0) {\n      const ssoConfigs: SSOConfigs = organization.ssoConfigs[0];\n\n      const updateableParams = {\n        configs,\n        enabled,\n      };\n\n      // removing keys with undefined values\n      cleanObject(updateableParams);\n      return await this.ssoConfigRepository.update(ssoConfigs.id, updateableParams);\n    } else {\n      const newSSOConfigs = this.ssoConfigRepository.create({\n        organization,\n        sso: type,\n        configs,\n        enabled: !!enabled,\n      });\n      return await this.ssoConfigRepository.save(newSSOConfigs);\n    }\n  }\n\n  async getConfigs(id: string): Promise<SSOConfigs> {\n    const result: SSOConfigs = await this.ssoConfigRepository.findOne({\n      where: { id, enabled: true },\n      relations: ['organization'],\n    });\n    await this.decryptSecret(result?.configs);\n    return result;\n  }\n\n  async inviteNewUser(currentUser: User, inviteNewUserDto: InviteNewUserDto): Promise<OrganizationUser> {\n    const userParams = <User>{\n      firstName: inviteNewUserDto.first_name,\n      lastName: inviteNewUserDto.last_name,\n      email: inviteNewUserDto.email,\n    };\n\n    let user = await this.usersService.findByEmail(userParams.email);\n    let defaultOrganisation: Organization,\n      shouldSendWelcomeMail = false;\n\n    if (user?.organizationUsers?.some((ou) => ou.organizationId === currentUser.organizationId)) {\n      throw new BadRequestException('User with such email already exists.');\n    }\n\n    if (user?.invitationToken) {\n      // user sign up not completed, name will be empty - updating name\n      await this.usersService.update(user.id, { firstName: userParams.firstName, lastName: userParams.lastName });\n    }\n\n    if (!user && this.configService.get<string>('DISABLE_MULTI_WORKSPACE') !== 'true') {\n      // User not exist\n      shouldSendWelcomeMail = true;\n      // Create default organization\n      defaultOrganisation = await this.create('Untitled workspace');\n    }\n    user = await this.usersService.create(\n      userParams,\n      currentUser.organizationId,\n      ['all_users'],\n      user,\n      true,\n      defaultOrganisation?.id\n    );\n\n    if (defaultOrganisation) {\n      // Setting up default organization\n      await this.organizationUserService.create(user, defaultOrganisation, true);\n      await this.usersService.attachUserGroup(['all_users', 'admin'], defaultOrganisation.id, user.id);\n    }\n\n    const currentOrganization: Organization = (\n      await this.organizationUsersRepository.findOne({\n        where: { userId: currentUser.id, organizationId: currentUser.organizationId },\n        relations: ['organization'],\n      })\n    )?.organization;\n\n    const organizationUser: OrganizationUser = await this.organizationUserService.create(\n      user,\n      currentOrganization,\n      true\n    );\n\n    if (shouldSendWelcomeMail) {\n      this.emailService\n        .sendWelcomeEmail(\n          user.email,\n          user.firstName,\n          user.invitationToken,\n          organizationUser.invitationToken,\n          currentOrganization.name,\n          `${currentUser.firstName} ${currentUser.lastName}`\n        )\n        .catch((err) => console.error('Error while sending welcome mail', err));\n    } else {\n      this.emailService\n        .sendOrganizationUserWelcomeEmail(\n          user.email,\n          user.firstName,\n          `${currentUser.firstName} ${currentUser.lastName}`,\n          organizationUser.invitationToken,\n          currentOrganization.name\n        )\n        .catch((err) => console.error('Error while sending welcome mail', err));\n    }\n    return organizationUser;\n  }\n}\n", "import { Injectable, InternalServerErrorException } from '@nestjs/common';\nimport { InjectRepository } from '@nestjs/typeorm';\nimport { User } from '../entities/user.entity';\nimport { FilesService } from '../services/files.service';\nimport { App } from 'src/entities/app.entity';\nimport { Connection, createQueryBuilder, EntityManager, getManager, getRepository, In, Repository } from 'typeorm';\nimport { OrganizationUser } from '../entities/organization_user.entity';\nimport { AppGroupPermission } from 'src/entities/app_group_permission.entity';\nimport { UserGroupPermission } from 'src/entities/user_group_permission.entity';\nimport { GroupPermission } from 'src/entities/group_permission.entity';\nimport { BadRequestException } from '@nestjs/common';\nimport { cleanObject } from 'src/helpers/utils.helper';\nimport { CreateFileDto } from '@dto/create-file.dto';\nconst uuid = require('uuid');\nconst bcrypt = require('bcrypt');\n\n@Injectable()\nexport class UsersService {\n  constructor(\n    private readonly filesService: FilesService,\n    private connection: Connection,\n    @InjectRepository(User)\n    private usersRepository: Repository<User>,\n    @InjectRepository(OrganizationUser)\n    private organizationUsersRepository: Repository<OrganizationUser>,\n    @InjectRepository(App)\n    private appsRepository: Repository<App>\n  ) {}\n\n  async findOne(id: string): Promise<User> {\n    return this.usersRepository.findOne({ where: { id } });\n  }\n\n  async findByEmail(email: string, organisationId?: string): Promise<User> {\n    if (!organisationId) {\n      return this.usersRepository.findOne({\n        where: { email },\n      });\n    } else {\n      return await createQueryBuilder(User, 'users')\n        .innerJoinAndSelect(\n          'users.organizationUsers',\n          'organization_users',\n          'organization_users.organizationId = :organisationId',\n          { organisationId }\n        )\n        .where('organization_users.status = :active', { active: 'active' })\n        .andWhere('users.email = :email', { email })\n        .getOne();\n    }\n  }\n\n  async findByPasswordResetToken(token: string): Promise<User> {\n    return this.usersRepository.findOne({\n      where: { forgotPasswordToken: token },\n    });\n  }\n\n  async create(\n    userParams: any,\n    organizationId: string,\n    groups?: string[],\n    existingUser?: User,\n    isInvite?: boolean,\n    defaultOrganizationId?: string\n  ): Promise<User> {\n    const password = uuid.v4();\n\n    const { email, firstName, lastName } = userParams;\n    let user: User;\n\n    await getManager().transaction(async (manager) => {\n      if (!existingUser) {\n        user = manager.create(User, {\n          email,\n          firstName,\n          lastName,\n          password,\n          invitationToken: isInvite ? uuid.v4() : null,\n          defaultOrganizationId: defaultOrganizationId || organizationId,\n          createdAt: new Date(),\n          updatedAt: new Date(),\n        });\n        await manager.save(user);\n      } else {\n        user = existingUser;\n      }\n    });\n\n    await this.attachUserGroup(groups, organizationId, user.id);\n\n    return user;\n  }\n\n  async attachUserGroup(groups, organizationId, userId) {\n    await getManager().transaction(async (manager) => {\n      for (const group of groups) {\n        const orgGroupPermission = await manager.findOne(GroupPermission, {\n          where: {\n            organizationId: organizationId,\n            group: group,\n          },\n        });\n\n        if (orgGroupPermission) {\n          const userGroupPermission = manager.create(UserGroupPermission, {\n            groupPermissionId: orgGroupPermission.id,\n            userId: userId,\n          });\n          await manager.save(userGroupPermission);\n        } else {\n          throw new BadRequestException(`${group} group does not exist for current organization`);\n        }\n      }\n    });\n  }\n\n  async status(user: User) {\n    const orgUser = await this.organizationUsersRepository.findOne({ where: { user } });\n    return orgUser.status;\n  }\n\n  async findOrCreateByEmail(userParams: any, organizationId: string): Promise<{ user: User; newUserCreated: boolean }> {\n    let user: User;\n    let newUserCreated = false;\n\n    user = await this.findByEmail(userParams.email);\n\n    if (user?.organizationUsers?.some((ou) => ou.organizationId === organizationId)) {\n      // User exist in current organization\n      return { user, newUserCreated };\n    }\n\n    const groups = ['all_users'];\n    user = await this.create({ ...userParams }, organizationId, groups, user);\n    newUserCreated = true;\n\n    return { user, newUserCreated };\n  }\n\n  async updateDefaultOrganization(user: User, organizationId: string) {\n    await this.usersRepository.update(user.id, { defaultOrganizationId: organizationId });\n  }\n\n  async update(userId: string, params: any, manager?: EntityManager, organizationId?: string) {\n    const { forgotPasswordToken, password, firstName, lastName, addGroups, removeGroups } = params;\n\n    const hashedPassword = password ? bcrypt.hashSync(password, 10) : undefined;\n\n    const updateableParams = {\n      forgotPasswordToken,\n      firstName,\n      lastName,\n      password: hashedPassword,\n    };\n\n    // removing keys with undefined values\n    cleanObject(updateableParams);\n\n    let user: User;\n\n    const performUpdateInTransaction = async (manager) => {\n      await manager.update(User, userId, { ...updateableParams });\n      user = await manager.findOne(User, { where: { id: userId } });\n\n      await this.removeUserGroupPermissionsIfExists(manager, user, removeGroups, organizationId);\n\n      await this.addUserGroupPermissions(manager, user, addGroups, organizationId);\n    };\n\n    if (manager) {\n      await performUpdateInTransaction(manager);\n    } else {\n      await getManager().transaction(async (manager) => {\n        await performUpdateInTransaction(manager);\n      });\n    }\n\n    return user;\n  }\n\n  async addUserGroupPermissions(manager: EntityManager, user: User, addGroups: string[], organizationId?: string) {\n    const orgId = organizationId || user.defaultOrganizationId;\n    if (addGroups) {\n      const orgGroupPermissions = await this.groupPermissionsForOrganization(orgId);\n\n      for (const group of addGroups) {\n        const orgGroupPermission = orgGroupPermissions.find((permission) => permission.group == group);\n\n        if (orgGroupPermission) {\n          const userGroupPermission = manager.create(UserGroupPermission, {\n            groupPermissionId: orgGroupPermission.id,\n            userId: user.id,\n          });\n          await manager.save(userGroupPermission);\n        } else {\n          throw new BadRequestException(`${group} group does not exist for current organization`);\n        }\n      }\n    }\n  }\n\n  async removeUserGroupPermissionsIfExists(\n    manager: EntityManager,\n    user: User,\n    removeGroups: string[],\n    organizationId?: string\n  ) {\n    const orgId = organizationId || user.defaultOrganizationId;\n    if (removeGroups) {\n      await this.throwErrorIfRemovingLastActiveAdmin(user, removeGroups, orgId);\n      if (removeGroups.includes('all_users')) {\n        throw new BadRequestException('Cannot remove user from default group.');\n      }\n\n      const groupPermissions = await manager.find(GroupPermission, {\n        group: In(removeGroups),\n        organizationId: orgId,\n      });\n      const groupIdsToMaybeRemove = groupPermissions.map((permission) => permission.id);\n\n      await manager.delete(UserGroupPermission, {\n        groupPermissionId: In(groupIdsToMaybeRemove),\n        userId: user.id,\n      });\n    }\n  }\n\n  async throwErrorIfRemovingLastActiveAdmin(user: User, removeGroups: string[] = ['admin'], organizationId: string) {\n    const removingAdmin = removeGroups.includes('admin');\n    if (!removingAdmin) return;\n\n    const result = await createQueryBuilder(User, 'users')\n      .innerJoin('users.groupPermissions', 'group_permissions')\n      .innerJoin('users.organizationUsers', 'organization_users')\n      .where('organization_users.user_id != :userId', { userId: user.id })\n      .andWhere('organization_users.status = :status', { status: 'active' })\n      .andWhere('group_permissions.group = :group', { group: 'admin' })\n      .andWhere('group_permissions.organization_id = :organizationId', {\n        organizationId,\n      })\n      .getCount();\n\n    if (result == 0) throw new BadRequestException('Atleast one active admin is required.');\n  }\n\n  async hasGroup(user: User, group: string, organizationId?: string): Promise<boolean> {\n    const orgId = organizationId || user.organizationId;\n\n    const result = await createQueryBuilder(GroupPermission, 'group_permissions')\n      .innerJoin('group_permissions.userGroupPermission', 'user_group_permissions')\n      .where('group_permissions.organization_id = :organizationId', {\n        organizationId: orgId,\n      })\n      .andWhere('group_permissions.group = :group ', { group })\n      .andWhere('user_group_permissions.user_id = :userId', { userId: user.id })\n      .getCount();\n\n    return result > 0;\n  }\n\n  async userCan(user: User, action: string, entityName: string, resourceId?: string): Promise<boolean> {\n    switch (entityName) {\n      case 'App':\n        return await this.canUserPerformActionOnApp(user, action, resourceId);\n\n      case 'User':\n        return await this.hasGroup(user, 'admin');\n\n      case 'Thread':\n      case 'Comment':\n        return await this.canUserPerformActionOnApp(user, 'update', resourceId);\n\n      case 'Folder':\n        return await this.canUserPerformActionOnFolder(user, action);\n\n      default:\n        return false;\n    }\n  }\n\n  async canUserPerformActionOnApp(user: User, action: string, appId?: string): Promise<boolean> {\n    let permissionGrant: boolean;\n\n    switch (action) {\n      case 'create':\n        permissionGrant = this.canAnyGroupPerformAction('appCreate', await this.groupPermissions(user));\n        break;\n      case 'read':\n      case 'update':\n        permissionGrant =\n          this.canAnyGroupPerformAction(action, await this.appGroupPermissions(user, appId)) ||\n          (await this.isUserOwnerOfApp(user, appId));\n        break;\n      case 'delete':\n        permissionGrant =\n          this.canAnyGroupPerformAction('delete', await this.appGroupPermissions(user, appId)) ||\n          this.canAnyGroupPerformAction('appDelete', await this.groupPermissions(user)) ||\n          (await this.isUserOwnerOfApp(user, appId));\n        break;\n      default:\n        permissionGrant = false;\n        break;\n    }\n\n    return permissionGrant;\n  }\n\n  async canUserPerformActionOnFolder(user: User, action: string): Promise<boolean> {\n    let permissionGrant: boolean;\n\n    switch (action) {\n      case 'create':\n        permissionGrant = this.canAnyGroupPerformAction('folderCreate', await this.groupPermissions(user));\n        break;\n      default:\n        permissionGrant = false;\n        break;\n    }\n\n    return permissionGrant;\n  }\n\n  async isUserOwnerOfApp(user: User, appId: string): Promise<boolean> {\n    const app: App = await this.appsRepository.findOne({\n      where: {\n        id: appId,\n        userId: user.id,\n      },\n    });\n    return !!app && app.organizationId === user.organizationId;\n  }\n\n  async addAvatar(userId: number, imageBuffer: Buffer, filename: string) {\n    const queryRunner = this.connection.createQueryRunner();\n\n    await queryRunner.connect();\n    await queryRunner.startTransaction();\n\n    try {\n      const user = await queryRunner.manager.findOne(User, userId);\n      const currentAvatarId = user.avatarId;\n      const createFileDto = new CreateFileDto();\n      createFileDto.filename = filename;\n      createFileDto.data = imageBuffer;\n      const avatar = await this.filesService.create(createFileDto, queryRunner);\n\n      await queryRunner.manager.update(User, userId, {\n        avatarId: avatar.id,\n      });\n\n      if (currentAvatarId) {\n        await this.filesService.remove(currentAvatarId, queryRunner);\n      }\n\n      await queryRunner.commitTransaction();\n\n      return avatar;\n    } catch (error) {\n      await queryRunner.rollbackTransaction();\n      throw new InternalServerErrorException(error);\n    } finally {\n      await queryRunner.release();\n    }\n  }\n\n  canAnyGroupPerformAction(action: string, permissions: AppGroupPermission[] | GroupPermission[]): boolean {\n    return permissions.some((p) => p[action]);\n  }\n\n  async groupPermissions(user: User): Promise<GroupPermission[]> {\n    const orgUserGroupPermissions = await this.userGroupPermissions(user, user.organizationId);\n    const groupIds = orgUserGroupPermissions.map((p) => p.groupPermissionId);\n    const groupPermissionRepository = getRepository(GroupPermission);\n\n    return await groupPermissionRepository.findByIds(groupIds);\n  }\n\n  async groupPermissionsForOrganization(organizationId: string) {\n    const groupPermissionRepository = getRepository(GroupPermission);\n\n    return await groupPermissionRepository.find({ organizationId });\n  }\n\n  async appGroupPermissions(user: User, appId?: string): Promise<AppGroupPermission[]> {\n    const orgUserGroupPermissions = await this.userGroupPermissions(user, user.organizationId);\n    const groupIds = orgUserGroupPermissions.map((p) => p.groupPermissionId);\n\n    if (!groupIds || groupIds.length === 0) {\n      return [];\n    }\n\n    const query = createQueryBuilder(AppGroupPermission, 'app_group_permissions')\n      .innerJoin(\n        'app_group_permissions.groupPermission',\n        'group_permissions',\n        'group_permissions.organization_id = :organizationId',\n        {\n          organizationId: user.organizationId,\n        }\n      )\n      .where('app_group_permissions.groupPermissionId IN (:...groupIds)', { groupIds });\n\n    if (appId) {\n      query.andWhere('app_group_permissions.appId = :appId', { appId });\n    }\n    return await query.getMany();\n  }\n\n  async userGroupPermissions(user: User, organizationId?: string): Promise<UserGroupPermission[]> {\n    const orgId = organizationId || user.organizationId;\n\n    return await createQueryBuilder(UserGroupPermission, 'user_group_permissions')\n      .innerJoin('user_group_permissions.groupPermission', 'group_permissions')\n      .where('group_permissions.organization_id = :organizationId', {\n        organizationId: orgId,\n      })\n      .andWhere('user_group_permissions.user_id = :userId', { userId: user.id })\n      .getMany();\n  }\n}\n", "/* eslint-disable @typescript-eslint/no-unused-vars */\nimport * as request from 'supertest';\nimport { INestApplication } from '@nestjs/common';\nimport { getManager, Repository, Not } from 'typeorm';\nimport { User } from 'src/entities/user.entity';\nimport { clearDB, createUser, authHeaderForUser, createNestAppInstanceWithEnvMock } from '../test.helper';\nimport { OrganizationUser } from 'src/entities/organization_user.entity';\nimport { Organization } from 'src/entities/organization.entity';\nimport { SSOConfigs } from 'src/entities/sso_config.entity';\nimport { EmailService } from '@services/email.service';\nimport { v4 as uuidv4 } from 'uuid';\n\ndescribe('Authentication', () => {\n  let app: INestApplication;\n  let userRepository: Repository<User>;\n  let orgRepository: Repository<Organization>;\n  let orgUserRepository: Repository<OrganizationUser>;\n  let ssoConfigsRepository: Repository<SSOConfigs>;\n  let mockConfig;\n  let current_organization: Organization;\n  let current_user: User;\n\n  beforeEach(async () => {\n    await clearDB();\n  });\n\n  beforeAll(async () => {\n    ({ app, mockConfig } = await createNestAppInstanceWithEnvMock());\n\n    userRepository = app.get('UserRepository');\n    orgRepository = app.get('OrganizationRepository');\n    orgUserRepository = app.get('OrganizationUserRepository');\n    ssoConfigsRepository = app.get('SSOConfigsRepository');\n  });\n\n  afterEach(() => {\n    jest.resetAllMocks();\n    jest.clearAllMocks();\n  });\n\n  describe('Single organization', () => {\n    beforeEach(async () => {\n      jest.spyOn(mockConfig, 'get').mockImplementation((key: string) => {\n        switch (key) {\n          case 'DISABLE_SIGNUPS':\n            return 'false';\n          case 'DISABLE_MULTI_WORKSPACE':\n            return 'true';\n          default:\n            return process.env[key];\n        }\n      });\n    });\n    it('should create new users and organization', async () => {\n      const response = await request(app.getHttpServer()).post('/api/signup').send({ email: 'test@tooljet.io' });\n      expect(response.statusCode).toBe(201);\n\n      const user = await userRepository.findOneOrFail({\n        where: { email: 'test@tooljet.io' },\n        relations: ['organizationUsers'],\n      });\n\n      const organization = await orgRepository.findOneOrFail({\n        where: { id: user?.organizationUsers?.[0]?.organizationId },\n      });\n\n      expect(user.defaultOrganizationId).toBe(user?.organizationUsers?.[0]?.organizationId);\n      expect(organization.name).toBe('Untitled workspace');\n\n      const groupPermissions = await user.groupPermissions;\n      const groupNames = groupPermissions.map((x) => x.group);\n\n      expect(new Set(['all_users', 'admin'])).toEqual(new Set(groupNames));\n\n      const adminGroup = groupPermissions.find((x) => x.group == 'admin');\n      expect(adminGroup.appCreate).toBeTruthy();\n      expect(adminGroup.appDelete).toBeTruthy();\n      expect(adminGroup.folderCreate).toBeTruthy();\n\n      const allUserGroup = groupPermissions.find((x) => x.group == 'all_users');\n      expect(allUserGroup.appCreate).toBeFalsy();\n      expect(allUserGroup.appDelete).toBeFalsy();\n      expect(allUserGroup.folderCreate).toBeFalsy();\n    });\n    describe('Single organization operations', () => {\n      beforeEach(async () => {\n        current_organization = (await createUser(app, { email: 'admin@tooljet.io' })).organization;\n      });\n      it('should not create new users since organization already exist', async () => {\n        const response = await request(app.getHttpServer()).post('/api/signup').send({ email: 'test@tooljet.io' });\n        expect(response.statusCode).toBe(406);\n      });\n      it('authenticate if valid credentials', async () => {\n        await request(app.getHttpServer())\n          .post('/api/authenticate')\n          .send({ email: 'admin@tooljet.io', password: 'password' })\n          .expect(201);\n      });\n      it('authenticate to organization if valid credentials', async () => {\n        await request(app.getHttpServer())\n          .post('/api/authenticate/' + current_organization.id)\n          .send({ email: 'admin@tooljet.io', password: 'password' })\n          .expect(201);\n      });\n      it('throw unauthorized error if user not exist in given organization if valid credentials', async () => {\n        await request(app.getHttpServer())\n          .post('/api/authenticate/82249621-efc1-4cd2-9986-5c22182fa8a7')\n          .send({ email: 'admin@tooljet.io', password: 'password' })\n          .expect(401);\n      });\n      it('throw 401 if user is archived', async () => {\n        await createUser(app, { email: 'user@tooljet.io', status: 'archived' });\n\n        await request(app.getHttpServer())\n          .post('/api/authenticate')\n          .send({ email: 'user@tooljet.io', password: 'password' })\n          .expect(401);\n\n        const adminUser = await userRepository.findOneOrFail({\n          email: 'admin@tooljet.io',\n        });\n        await orgUserRepository.update({ userId: adminUser.id }, { status: 'archived' });\n\n        await request(app.getHttpServer())\n          .get('/api/organizations/users')\n          .set('Authorization', authHeaderForUser(adminUser))\n          .expect(401);\n      });\n      it('throw 401 if invalid credentials', async () => {\n        await request(app.getHttpServer())\n          .post('/api/authenticate')\n          .send({ email: 'amdin@tooljet.io', password: 'pwd' })\n          .expect(401);\n      });\n      it('should throw 401 if form login is disabled', async () => {\n        await ssoConfigsRepository.update({ organizationId: current_organization.id }, { enabled: false });\n        await request(app.getHttpServer())\n          .post('/api/authenticate')\n          .send({ email: 'admin@tooljet.io', password: 'password' })\n          .expect(401);\n      });\n    });\n  });\n\n  describe('Multi organization', () => {\n    beforeEach(async () => {\n      const { organization, user } = await createUser(app, {\n        email: 'admin@tooljet.io',\n        firstName: 'user',\n        lastName: 'name',\n      });\n      current_organization = organization;\n      current_user = user;\n      jest.spyOn(mockConfig, 'get').mockImplementation((key: string) => {\n        switch (key) {\n          case 'DISABLE_SIGNUPS':\n            return 'false';\n          default:\n            return process.env[key];\n        }\n      });\n    });\n    describe('sign up disabled', () => {\n      beforeEach(async () => {\n        jest.spyOn(mockConfig, 'get').mockImplementation((key: string) => {\n          switch (key) {\n            case 'DISABLE_SIGNUPS':\n              return 'true';\n            default:\n              return process.env[key];\n          }\n        });\n      });\n      it('should not create new users', async () => {\n        const response = await request(app.getHttpServer()).post('/api/signup').send({ email: 'test@tooljet.io' });\n        expect(response.statusCode).toBe(403);\n      });\n    });\n    describe('sign up enabled and authorization', () => {\n      it('should create new users', async () => {\n        const response = await request(app.getHttpServer()).post('/api/signup').send({ email: 'test@tooljet.io' });\n        expect(response.statusCode).toBe(201);\n\n        const user = await userRepository.findOneOrFail({\n          where: { email: 'test@tooljet.io' },\n          relations: ['organizationUsers'],\n        });\n\n        const organization = await orgRepository.findOneOrFail({\n          where: { id: user?.organizationUsers?.[0]?.organizationId },\n        });\n\n        expect(user.defaultOrganizationId).toBe(user?.organizationUsers?.[0]?.organizationId);\n        expect(organization?.name).toBe('Untitled workspace');\n\n        const groupPermissions = await user.groupPermissions;\n        const groupNames = groupPermissions.map((x) => x.group);\n\n        expect(new Set(['all_users', 'admin'])).toEqual(new Set(groupNames));\n\n        const adminGroup = groupPermissions.find((x) => x.group == 'admin');\n        expect(adminGroup.appCreate).toBeTruthy();\n        expect(adminGroup.appDelete).toBeTruthy();\n        expect(adminGroup.folderCreate).toBeTruthy();\n\n        const allUserGroup = groupPermissions.find((x) => x.group == 'all_users');\n        expect(allUserGroup.appCreate).toBeFalsy();\n        expect(allUserGroup.appDelete).toBeFalsy();\n        expect(allUserGroup.folderCreate).toBeFalsy();\n      });\n      it('authenticate if valid credentials', async () => {\n        await request(app.getHttpServer())\n          .post('/api/authenticate')\n          .send({ email: 'admin@tooljet.io', password: 'password' })\n          .expect(201);\n      });\n      it('authenticate to organization if valid credentials', async () => {\n        await request(app.getHttpServer())\n          .post('/api/authenticate/' + current_organization.id)\n          .send({ email: 'admin@tooljet.io', password: 'password' })\n          .expect(201);\n      });\n      it('throw unauthorized error if user not exist in given organization if valid credentials', async () => {\n        await request(app.getHttpServer())\n          .post('/api/authenticate/82249621-efc1-4cd2-9986-5c22182fa8a7')\n          .send({ email: 'admin@tooljet.io', password: 'password' })\n          .expect(401);\n      });\n      it('throw 401 if user is archived', async () => {\n        await createUser(app, { email: 'user@tooljet.io', status: 'archived' });\n\n        await request(app.getHttpServer())\n          .post('/api/authenticate')\n          .send({ email: 'user@tooljet.io', password: 'password' })\n          .expect(401);\n\n        const adminUser = await userRepository.findOneOrFail({\n          email: 'admin@tooljet.io',\n        });\n        await orgUserRepository.update({ userId: adminUser.id }, { status: 'archived' });\n\n        await request(app.getHttpServer())\n          .get('/api/organizations/users')\n          .set('Authorization', authHeaderForUser(adminUser))\n          .expect(401);\n      });\n      it('throw 401 if invalid credentials', async () => {\n        await request(app.getHttpServer())\n          .post('/api/authenticate')\n          .send({ email: 'amdin@tooljet.io', password: 'pwd' })\n          .expect(401);\n      });\n      it('should throw 401 if form login is disabled', async () => {\n        await ssoConfigsRepository.update({ organizationId: current_organization.id }, { enabled: false });\n        await request(app.getHttpServer())\n          .post('/api/authenticate/' + current_organization.id)\n          .send({ email: 'admin@tooljet.io', password: 'password' })\n          .expect(401);\n      });\n      it('should create new organization if login is disabled for default organization', async () => {\n        await ssoConfigsRepository.update({ organizationId: current_organization.id }, { enabled: false });\n        const response = await request(app.getHttpServer())\n          .post('/api/authenticate')\n          .send({ email: 'admin@tooljet.io', password: 'password' });\n        expect(response.statusCode).toBe(201);\n        expect(response.body.organization_id).not.toBe(current_organization.id);\n        expect(response.body.organization).toBe('Untitled workspace');\n      });\n      it('should be able to switch between organizations with admin privilage', async () => {\n        const { organization: invited_organization } = await createUser(\n          app,\n          { organizationName: 'New Organization' },\n          current_user\n        );\n        const response = await request(app.getHttpServer())\n          .get('/api/switch/' + invited_organization.id)\n          .set('Authorization', authHeaderForUser(current_user));\n\n        expect(response.statusCode).toBe(200);\n        expect(Object.keys(response.body).sort()).toEqual(\n          [\n            'id',\n            'email',\n            'first_name',\n            'last_name',\n            'auth_token',\n            'admin',\n            'organization_id',\n            'organization',\n            'group_permissions',\n            'app_group_permissions',\n          ].sort()\n        );\n\n        const {\n          email,\n          first_name,\n          last_name,\n          admin,\n          group_permissions,\n          app_group_permissions,\n          organization_id,\n          organization,\n        } = response.body;\n\n        expect(email).toEqual(current_user.email);\n        expect(first_name).toEqual(current_user.firstName);\n        expect(last_name).toEqual(current_user.lastName);\n        expect(admin).toBeTruthy();\n        expect(organization_id).toBe(invited_organization.id);\n        expect(organization).toBe(invited_organization.name);\n        expect(group_permissions).toHaveLength(2);\n        expect(group_permissions.some((gp) => gp.group === 'all_users')).toBeTruthy();\n        expect(group_permissions.some((gp) => gp.group === 'admin')).toBeTruthy();\n        expect(Object.keys(group_permissions[0]).sort()).toEqual(\n          [\n            'id',\n            'organization_id',\n            'group',\n            'app_create',\n            'app_delete',\n            'updated_at',\n            'created_at',\n            'folder_create',\n          ].sort()\n        );\n        expect(app_group_permissions).toHaveLength(0);\n        await current_user.reload();\n        expect(current_user.defaultOrganizationId).toBe(invited_organization.id);\n      });\n      it('should be able to switch between organizations with user privilage', async () => {\n        const { organization: invited_organization } = await createUser(\n          app,\n          { groups: ['all_users'], organizationName: 'New Organization' },\n          current_user\n        );\n        const response = await request(app.getHttpServer())\n          .get('/api/switch/' + invited_organization.id)\n          .set('Authorization', authHeaderForUser(current_user));\n\n        expect(response.statusCode).toBe(200);\n        expect(Object.keys(response.body).sort()).toEqual(\n          [\n            'id',\n            'email',\n            'first_name',\n            'last_name',\n            'auth_token',\n            'admin',\n            'organization_id',\n            'organization',\n            'group_permissions',\n            'app_group_permissions',\n          ].sort()\n        );\n\n        const {\n          email,\n          first_name,\n          last_name,\n          admin,\n          group_permissions,\n          app_group_permissions,\n          organization_id,\n          organization,\n        } = response.body;\n\n        expect(email).toEqual(current_user.email);\n        expect(first_name).toEqual(current_user.firstName);\n        expect(last_name).toEqual(current_user.lastName);\n        expect(admin).toBeFalsy();\n        expect(organization_id).toBe(invited_organization.id);\n        expect(organization).toBe(invited_organization.name);\n        expect(group_permissions).toHaveLength(1);\n        expect(group_permissions[0].group).toEqual('all_users');\n        expect(Object.keys(group_permissions[0]).sort()).toEqual(\n          [\n            'id',\n            'organization_id',\n            'group',\n            'app_create',\n            'app_delete',\n            'updated_at',\n            'created_at',\n            'folder_create',\n          ].sort()\n        );\n        expect(app_group_permissions).toHaveLength(0);\n        await current_user.reload();\n        expect(current_user.defaultOrganizationId).toBe(invited_organization.id);\n      });\n    });\n  });\n\n  describe('POST /api/forgot_password', () => {\n    beforeEach(async () => {\n      await createUser(app, {\n        email: 'admin@tooljet.io',\n        firstName: 'user',\n        lastName: 'name',\n      });\n    });\n    it('should return error if required params are not present', async () => {\n      const response = await request(app.getHttpServer()).post('/api/forgot_password');\n\n      expect(response.statusCode).toBe(400);\n      expect(response.body.message).toStrictEqual(['email should not be empty', 'email must be an email']);\n    });\n\n    it('should set token and send email', async () => {\n      const emailServiceMock = jest.spyOn(EmailService.prototype, 'sendPasswordResetEmail');\n      emailServiceMock.mockImplementation();\n\n      const response = await request(app.getHttpServer())\n        .post('/api/forgot_password')\n        .send({ email: 'admin@tooljet.io' });\n\n      expect(response.statusCode).toBe(201);\n\n      const user = await getManager().findOne(User, {\n        where: { email: 'admin@tooljet.io' },\n      });\n\n      expect(emailServiceMock).toHaveBeenCalledWith(user.email, user.forgotPasswordToken);\n    });\n  });\n\n  describe('POST /api/reset_password', () => {\n    beforeEach(async () => {\n      await createUser(app, {\n        email: 'admin@tooljet.io',\n        firstName: 'user',\n        lastName: 'name',\n      });\n    });\n    it('should return error if required params are not present', async () => {\n      const response = await request(app.getHttpServer()).post('/api/reset_password');\n\n      expect(response.statusCode).toBe(400);\n      expect(response.body.message).toStrictEqual([\n        'password should not be empty',\n        'password must be a string',\n        'token should not be empty',\n        'token must be a string',\n      ]);\n    });\n\n    it('should reset password', async () => {\n      const user = await getManager().findOne(User, {\n        where: { email: 'admin@tooljet.io' },\n      });\n\n      user.forgotPasswordToken = 'token';\n      await user.save();\n\n      const response = await request(app.getHttpServer()).post('/api/reset_password').send({\n        password: 'new_password',\n        token: 'token',\n      });\n\n      expect(response.statusCode).toBe(201);\n\n      await request(app.getHttpServer())\n        .post('/api/authenticate')\n        .send({ email: 'admin@tooljet.io', password: 'new_password' })\n        .expect(201);\n    });\n  });\n\n  describe('POST /api/set-password-from-token', () => {\n    beforeEach(() => {\n      jest.spyOn(mockConfig, 'get').mockImplementation((key: string) => {\n        switch (key) {\n          case 'DISABLE_MULTI_WORKSPACE':\n            return 'false';\n          default:\n            return process.env[key];\n        }\n      });\n    });\n    it('should allow users to setup account after sign up using  Multi-Workspace', async () => {\n      const invitationToken = uuidv4();\n      const userData = await createUser(app, {\n        email: 'signup@tooljet.io',\n        invitationToken,\n        status: 'invited',\n      });\n      const { user, organization } = userData;\n\n      const response = await request(app.getHttpServer()).post('/api/set-password-from-token').send({\n        first_name: 'signupuser',\n        last_name: 'user',\n        organization: 'org1',\n        password: uuidv4(),\n        token: invitationToken,\n        role: 'developer',\n      });\n\n      expect(response.statusCode).toBe(201);\n\n      const updatedUser = await getManager().findOneOrFail(User, { where: { email: user.email } });\n      expect(updatedUser.firstName).toEqual('signupuser');\n      expect(updatedUser.lastName).toEqual('user');\n      expect(updatedUser.defaultOrganizationId).toEqual(organization.id);\n      const organizationUser = await getManager().findOneOrFail(OrganizationUser, { where: { userId: user.id } });\n      expect(organizationUser.status).toEqual('active');\n    });\n\n    it('should return error if required params are not present - Multi-Workspace', async () => {\n      const invitationToken = uuidv4();\n      await createUser(app, {\n        email: 'signup@tooljet.io',\n        invitationToken,\n        status: 'invited',\n      });\n\n      const response = await request(app.getHttpServer()).post('/api/set-password-from-token');\n\n      expect(response.statusCode).toBe(400);\n      expect(response.body.message).toStrictEqual([\n        'password should not be empty',\n        'password must be a string',\n        'token should not be empty',\n        'token must be a string',\n      ]);\n    });\n\n    it('should allow users to setup account for single organization only once', async () => {\n      jest.spyOn(mockConfig, 'get').mockImplementation((key: string) => {\n        switch (key) {\n          case 'DISABLE_MULTI_WORKSPACE':\n            return 'true';\n          default:\n            return process.env[key];\n        }\n      });\n      const invitationToken = uuidv4();\n      await createUser(app, {\n        email: 'signup@tooljet.io',\n        invitationToken,\n        status: 'invited',\n      });\n\n      let response = await request(app.getHttpServer()).post('/api/set-password-from-token').send({\n        first_name: 'signupuser',\n        last_name: 'user',\n        organization: 'org1',\n        password: uuidv4(),\n        token: invitationToken,\n        role: 'developer',\n      });\n\n      expect(response.statusCode).toBe(201);\n\n      await createUser(app, {\n        email: 'signup2@tooljet.io',\n        invitationToken,\n        status: 'invited',\n      });\n\n      response = await request(app.getHttpServer()).post('/api/set-password-from-token').send({\n        first_name: 'signupuser2',\n        last_name: 'user2',\n        organization: 'org1',\n        password: uuidv4(),\n        token: invitationToken,\n        role: 'developer',\n      });\n\n      expect(response.statusCode).toBe(403);\n    });\n\n    it('should not allow users to setup account for Multi-Workspace and sign up disabled', async () => {\n      jest.spyOn(mockConfig, 'get').mockImplementation((key: string) => {\n        switch (key) {\n          case 'DISABLE_SIGNUPS':\n            return 'true';\n          default:\n            return process.env[key];\n        }\n      });\n      const invitationToken = uuidv4();\n      await createUser(app, {\n        email: 'signup@tooljet.io',\n        invitationToken,\n        status: 'invited',\n      });\n\n      const response = await request(app.getHttpServer()).post('/api/set-password-from-token').send({\n        first_name: 'signupuser',\n        last_name: 'user',\n        organization: 'org1',\n        password: uuidv4(),\n        token: invitationToken,\n        role: 'developer',\n      });\n\n      expect(response.statusCode).toBe(403);\n    });\n\n    it('should allow users to sign up and setup account if already invited to an organization but not setup the account', async () => {\n      const { organization: org, user: adminUser } = await createUser(app, {\n        email: 'admin@tooljet.io',\n      });\n\n      await request(app.getHttpServer())\n        .post(`/api/organization_users/`)\n        .set('Authorization', authHeaderForUser(adminUser))\n        .send({ email: 'invited@tooljet.io' })\n        .expect(201);\n\n      const signUpResponse = await request(app.getHttpServer())\n        .post('/api/signup')\n        .send({ email: 'invited@tooljet.io' });\n\n      expect(signUpResponse.statusCode).toBe(201);\n\n      const invitedUserDetails = await getManager().findOneOrFail(User, { where: { email: 'invited@tooljet.io' } });\n\n      expect(invitedUserDetails.defaultOrganizationId).not.toBe(org.id);\n\n      const response = await request(app.getHttpServer()).post('/api/set-password-from-token').send({\n        first_name: 'signupuser',\n        last_name: 'user',\n        organization: 'org1',\n        password: uuidv4(),\n        token: invitedUserDetails.invitationToken,\n        role: 'developer',\n      });\n\n      expect(response.statusCode).toBe(201);\n      const updatedUser = await getManager().findOneOrFail(User, { where: { email: 'invited@tooljet.io' } });\n      expect(updatedUser.firstName).toEqual('signupuser');\n      expect(updatedUser.lastName).toEqual('user');\n      expect(updatedUser.defaultOrganizationId).not.toBe(org.id);\n      const organizationUser = await getManager().findOneOrFail(OrganizationUser, {\n        where: { userId: Not(adminUser.id), organizationId: org.id },\n      });\n      const defaultOrganizationUser = await getManager().findOneOrFail(OrganizationUser, {\n        where: { userId: Not(adminUser.id), organizationId: invitedUserDetails.defaultOrganizationId },\n      });\n      expect(organizationUser.status).toEqual('invited');\n      expect(defaultOrganizationUser.status).toEqual('active');\n\n      const acceptInviteResponse = await request(app.getHttpServer()).post('/api/accept-invite').send({\n        token: organizationUser.invitationToken,\n      });\n\n      expect(acceptInviteResponse.statusCode).toBe(201);\n\n      const organizationUserUpdated = await getManager().findOneOrFail(OrganizationUser, {\n        where: { userId: Not(adminUser.id), organizationId: org.id },\n      });\n      expect(organizationUserUpdated.status).toEqual('active');\n    });\n\n    it('should allow users setup account and accept invite', async () => {\n      const { organization: org, user: adminUser } = await createUser(app, {\n        email: 'admin@tooljet.io',\n      });\n\n      await request(app.getHttpServer())\n        .post(`/api/organization_users/`)\n        .set('Authorization', authHeaderForUser(adminUser))\n        .send({ email: 'invited@tooljet.io' })\n        .expect(201);\n\n      const invitedUserDetails = await getManager().findOneOrFail(User, { where: { email: 'invited@tooljet.io' } });\n\n      expect(invitedUserDetails.defaultOrganizationId).not.toBe(org.id);\n\n      const organizationUserBeforeUpdate = await getManager().findOneOrFail(OrganizationUser, {\n        where: { userId: Not(adminUser.id), organizationId: org.id },\n      });\n\n      const response = await request(app.getHttpServer()).post('/api/set-password-from-token').send({\n        first_name: 'signupuser',\n        last_name: 'user',\n        organization: 'org1',\n        password: uuidv4(),\n        token: invitedUserDetails.invitationToken,\n        organizationToken: organizationUserBeforeUpdate.invitationToken,\n        role: 'developer',\n      });\n\n      expect(response.statusCode).toBe(201);\n      const updatedUser = await getManager().findOneOrFail(User, { where: { email: 'invited@tooljet.io' } });\n      expect(updatedUser.firstName).toEqual('signupuser');\n      expect(updatedUser.lastName).toEqual('user');\n      expect(updatedUser.defaultOrganizationId).not.toBe(org.id);\n      const organizationUser = await getManager().findOneOrFail(OrganizationUser, {\n        where: { userId: Not(adminUser.id), organizationId: org.id },\n      });\n      const defaultOrganizationUser = await getManager().findOneOrFail(OrganizationUser, {\n        where: { userId: Not(adminUser.id), organizationId: invitedUserDetails.defaultOrganizationId },\n      });\n      expect(organizationUser.status).toEqual('active');\n      expect(defaultOrganizationUser.status).toEqual('active');\n\n      const acceptInviteResponse = await request(app.getHttpServer()).post('/api/accept-invite').send({\n        token: organizationUser.invitationToken,\n      });\n\n      expect(acceptInviteResponse.statusCode).toBe(400);\n    });\n\n    it('should not allow users to setup account if already invited to an organization and trying to accept invite before setting up account', async () => {\n      const { organization: org, user: adminUser } = await createUser(app, {\n        email: 'admin@tooljet.io',\n      });\n\n      await request(app.getHttpServer())\n        .post(`/api/organization_users/`)\n        .set('Authorization', authHeaderForUser(adminUser))\n        .send({ email: 'invited@tooljet.io' })\n        .expect(201);\n\n      const signUpResponse = await request(app.getHttpServer())\n        .post('/api/signup')\n        .send({ email: 'invited@tooljet.io' });\n\n      expect(signUpResponse.statusCode).toBe(201);\n\n      const invitedUserDetails = await getManager().findOneOrFail(User, { where: { email: 'invited@tooljet.io' } });\n      const orgUser = await getManager().findOneOrFail(OrganizationUser, {\n        where: { userId: invitedUserDetails.id, organizationId: org.id },\n      });\n\n      expect(invitedUserDetails.defaultOrganizationId).not.toBe(org.id);\n\n      const acceptInviteResponse = await request(app.getHttpServer()).post('/api/accept-invite').send({\n        token: orgUser.invitationToken,\n      });\n\n      expect(acceptInviteResponse.statusCode).toBe(401);\n\n      const organizationUser = await getManager().findOneOrFail(OrganizationUser, {\n        where: { userId: invitedUserDetails.id, organizationId: org.id },\n      });\n      const defaultOrganizationUser = await getManager().findOneOrFail(OrganizationUser, {\n        where: { userId: invitedUserDetails.id, organizationId: invitedUserDetails.defaultOrganizationId },\n      });\n      expect(organizationUser.status).toEqual('invited');\n      expect(defaultOrganizationUser.status).toEqual('invited');\n\n      const response = await request(app.getHttpServer()).post('/api/set-password-from-token').send({\n        first_name: 'signupuser',\n        last_name: 'user',\n        organization: 'org1',\n        password: uuidv4(),\n        token: invitedUserDetails.invitationToken,\n        role: 'developer',\n      });\n\n      expect(response.statusCode).toBe(201);\n    });\n  });\n\n  describe('POST /api/accept-invite', () => {\n    describe('Multi-Worlspace Enabled', () => {\n      beforeEach(() => {\n        jest.spyOn(mockConfig, 'get').mockImplementation((key: string) => {\n          switch (key) {\n            case 'DISABLE_MULTI_WORKSPACE':\n              return 'false';\n            default:\n              return process.env[key];\n          }\n        });\n      });\n\n      it('should allow users to accept invitation when Multi-Workspace is enabled', async () => {\n        const userData = await createUser(app, {\n          email: 'organizationUser@tooljet.io',\n          status: 'invited',\n        });\n\n        const { user, orgUser } = userData;\n\n        const response = await request(app.getHttpServer()).post('/api/accept-invite').send({\n          token: orgUser.invitationToken,\n        });\n\n        expect(response.statusCode).toBe(201);\n\n        const organizationUser = await getManager().findOneOrFail(OrganizationUser, { where: { userId: user.id } });\n        expect(organizationUser.status).toEqual('active');\n      });\n\n      it('should not allow users to accept invitation when user sign up is not completed', async () => {\n        const userData = await createUser(app, {\n          email: 'organizationUser@tooljet.io',\n          invitationToken: uuidv4(),\n          status: 'invited',\n        });\n        const { user, orgUser } = userData;\n\n        const response = await request(app.getHttpServer()).post('/api/accept-invite').send({\n          token: orgUser.invitationToken,\n        });\n\n        expect(response.statusCode).toBe(401);\n        expect(response.body.message).toBe(\n          'User not exist in the workspace, Please setup your account using link shared via email'\n        );\n      });\n    });\n\n    describe('Multi-Worlspace Disabled', () => {\n      beforeEach(() => {\n        jest.spyOn(mockConfig, 'get').mockImplementation((key: string) => {\n          switch (key) {\n            case 'DISABLE_MULTI_WORKSPACE':\n              return 'true';\n            default:\n              return process.env[key];\n          }\n        });\n      });\n\n      it('should allow users to accept invitation when Multi-Workspace is disabled', async () => {\n        const userData = await createUser(app, {\n          email: 'organizationUser@tooljet.io',\n          status: 'invited',\n        });\n        const { user, orgUser } = userData;\n\n        const response = await request(app.getHttpServer()).post('/api/accept-invite').send({\n          token: orgUser.invitationToken,\n          password: uuidv4(),\n        });\n\n        expect(response.statusCode).toBe(201);\n\n        const organizationUser = await getManager().findOneOrFail(OrganizationUser, { where: { userId: user.id } });\n        expect(organizationUser.status).toEqual('active');\n      });\n\n      it('should not allow users to accept invitation when user not entered password for single workspace', async () => {\n        const userData = await createUser(app, {\n          email: 'organizationUser@tooljet.io',\n          invitationToken: uuidv4(),\n          status: 'invited',\n        });\n        const { orgUser } = userData;\n\n        const response = await request(app.getHttpServer()).post('/api/accept-invite').send({\n          token: orgUser.invitationToken,\n        });\n\n        expect(response.statusCode).toBe(400);\n        expect(response.body.message).toBe('Please enter password');\n      });\n    });\n  });\n\n  afterAll(async () => {\n    await app.close();\n  });\n});\n", "import * as request from 'supertest';\nimport { INestApplication } from '@nestjs/common';\nimport { authHeaderForUser, clearDB, createUser, createNestAppInstance } from '../test.helper';\nimport { getManager } from 'typeorm';\nimport { User } from 'src/entities/user.entity';\nconst path = require('path');\n\ndescribe('users controller', () => {\n  let app: INestApplication;\n\n  beforeEach(async () => {\n    await clearDB();\n  });\n\n  beforeAll(async () => {\n    app = await createNestAppInstance();\n  });\n\n  afterEach(() => {\n    jest.resetAllMocks();\n    jest.clearAllMocks();\n  });\n\n  describe('PATCH /api/users/change_password', () => {\n    it('should allow users to update their password', async () => {\n      const userData = await createUser(app, { email: 'admin@tooljet.io' });\n      const { user } = userData;\n\n      const oldPassword = user.password;\n\n      const response = await request(app.getHttpServer())\n        .patch('/api/users/change_password')\n        .set('Authorization', authHeaderForUser(user))\n        .send({ currentPassword: 'password', newPassword: 'new password' });\n\n      expect(response.statusCode).toBe(200);\n      const updatedUser = await getManager().findOneOrFail(User, { where: { email: user.email } });\n      expect(updatedUser.password).not.toEqual(oldPassword);\n    });\n\n    it('should not allow users to update their password if entered current password is wrong', async () => {\n      const userData = await createUser(app, { email: 'admin@tooljet.io' });\n      const { user } = userData;\n\n      const oldPassword = user.password;\n\n      const response = await request(app.getHttpServer())\n        .patch('/api/users/change_password')\n        .set('Authorization', authHeaderForUser(user))\n        .send({\n          currentPassword: 'wrong password',\n          newPassword: 'new password',\n        });\n\n      expect(response.statusCode).toBe(403);\n\n      const updatedUser = await getManager().findOneOrFail(User, { where: { email: user.email } });\n      expect(updatedUser.password).toEqual(oldPassword);\n    });\n  });\n\n  describe('PATCH /api/users/update', () => {\n    it('should allow users to update their firstName, lastName and password', async () => {\n      const userData = await createUser(app, { email: 'admin@tooljet.io' });\n      const { user } = userData;\n\n      const [firstName, lastName] = ['Daenerys', 'Targaryen'];\n\n      const response = await request(app.getHttpServer())\n        .patch('/api/users/update')\n        .set('Authorization', authHeaderForUser(user))\n        .send({ first_name: firstName, last_name: lastName });\n\n      expect(response.statusCode).toBe(200);\n\n      const updatedUser = await getManager().findOneOrFail(User, { where: { email: user.email } });\n      expect(updatedUser.firstName).toEqual(firstName);\n      expect(updatedUser.lastName).toEqual(lastName);\n    });\n  });\n\n  describe('POST /api/users/avatar', () => {\n    it('should allow users to add a avatar', async () => {\n      const userData = await createUser(app, { email: 'admin@tooljet.io' });\n\n      const { user } = userData;\n      const filePath = path.join(__dirname, '../__mocks__/avatar.png');\n\n      const response = await request(app.getHttpServer())\n        .post('/api/users/avatar')\n        .set('Authorization', authHeaderForUser(user))\n        .attach('file', filePath);\n\n      expect(response.statusCode).toBe(201);\n    });\n  });\n\n  afterAll(async () => {\n    await app.close();\n  });\n});\n"], "filenames": ["frontend/src/App/App.jsx", "frontend/src/ConfirmationPage/ConfirmationPage.jsx", "frontend/src/ConfirmationPage/OrganizationInvitationPage.jsx", "frontend/src/ManageOrgUsers/ManageOrgUsers.jsx", "frontend/src/_services/app.service.js", "frontend/src/_services/user.service.js", "server/src/controllers/app.controller.ts", "server/src/controllers/organization_users.controller.ts", "server/src/controllers/users.controller.ts", "server/src/dto/accept-organization-invite.dto.ts", "server/src/dto/user.dto.ts", "server/src/services/auth.service.ts", "server/src/services/email.service.ts", "server/src/services/organization_users.service.ts", "server/src/services/organizations.service.ts", "server/src/services/users.service.ts", "server/test/controllers/app.e2e-spec.ts", "server/test/controllers/users.e2e-spec.ts"], "buggy_code_start_loc": [144, 2, 2, 5, 21, 8, 5, 10, 1, 1, 29, 1, 56, 11, 9, 5, 4, 3], "buggy_code_end_loc": [144, 48, 135, 174, 128, 80, 24, 22, 47, 2, 29, 217, 104, 65, 310, 234, 468, 350], "fixing_code_start_loc": [145, 2, 2, 4, 22, 7, 6, 11, 1, 1, 30, 1, 56, 10, 10, 4, 4, 3], "fixing_code_end_loc": [159, 50, 133, 166, 156, 53, 43, 26, 31, 2, 35, 360, 120, 23, 395, 138, 857, 81], "type": "NVD-CWE-Other", "message": "Excessive Attack Surface in GitHub repository tooljet/tooljet prior to v1.16.0.", "other": {"cve": {"id": "CVE-2022-2037", "sourceIdentifier": "security@huntr.dev", "published": "2022-06-09T17:15:09.760", "lastModified": "2022-06-15T21:10:46.903", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Excessive Attack Surface in GitHub repository tooljet/tooljet prior to v1.16.0."}, {"lang": "es", "value": "Una Superficie de Ataque Excesiva en el repositorio de GitHub tooljet/tooljet versiones anteriores a v1.16.0"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.0, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.1, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:S/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 6.8, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-Other"}]}, {"source": "security@huntr.dev", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-1125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:tooljet:tooljet:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.16.0", "matchCriteriaId": "798670D5-9034-4AF1-85F7-C21675CBF30B"}]}]}], "references": [{"url": "https://github.com/tooljet/tooljet/commit/fadf025365823cbbc739a1313791c0a04621972b", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/4431ef84-93f2-4bc5-bc1a-97d7f229b28e", "source": "security@huntr.dev", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/tooljet/tooljet/commit/fadf025365823cbbc739a1313791c0a04621972b"}}