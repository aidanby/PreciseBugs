{"buggy_code": ["/*\n   BlueZ - Bluetooth protocol stack for Linux\n   Copyright (C) 2000-2001 Qualcomm Incorporated\n   Copyright (C) 2009-2010 Gustavo F. Padovan <gustavo@padovan.org>\n   Copyright (C) 2010 Google Inc.\n   Copyright (C) 2011 ProFUSION Embedded Systems\n\n   Written 2000,2001 by Maxim Krasnyansky <maxk@qualcomm.com>\n\n   This program is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License version 2 as\n   published by the Free Software Foundation;\n\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS.\n   IN NO EVENT SHALL THE COPYRIGHT HOLDER(S) AND AUTHOR(S) BE LIABLE FOR ANY\n   CLAIM, OR ANY SPECIAL INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES\n   WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n   ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n   OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n\n   ALL LIABILITY, INCLUDING LIABILITY FOR INFRINGEMENT OF ANY PATENTS,\n   COPYRIGHTS, TRADEMARKS OR OTHER RIGHTS, RELATING TO USE OF THIS\n   SOFTWARE IS DISCLAIMED.\n*/\n\n/* Bluetooth L2CAP sockets. */\n\n#include <linux/module.h>\n#include <linux/export.h>\n#include <linux/filter.h>\n#include <linux/sched/signal.h>\n\n#include <net/bluetooth/bluetooth.h>\n#include <net/bluetooth/hci_core.h>\n#include <net/bluetooth/l2cap.h>\n\n#include \"smp.h\"\n\nstatic struct bt_sock_list l2cap_sk_list = {\n\t.lock = __RW_LOCK_UNLOCKED(l2cap_sk_list.lock)\n};\n\nstatic const struct proto_ops l2cap_sock_ops;\nstatic void l2cap_sock_init(struct sock *sk, struct sock *parent);\nstatic struct sock *l2cap_sock_alloc(struct net *net, struct socket *sock,\n\t\t\t\t     int proto, gfp_t prio, int kern);\n\nbool l2cap_is_socket(struct socket *sock)\n{\n\treturn sock && sock->ops == &l2cap_sock_ops;\n}\nEXPORT_SYMBOL(l2cap_is_socket);\n\nstatic int l2cap_validate_bredr_psm(u16 psm)\n{\n\t/* PSM must be odd and lsb of upper byte must be 0 */\n\tif ((psm & 0x0101) != 0x0001)\n\t\treturn -EINVAL;\n\n\t/* Restrict usage of well-known PSMs */\n\tif (psm < L2CAP_PSM_DYN_START && !capable(CAP_NET_BIND_SERVICE))\n\t\treturn -EACCES;\n\n\treturn 0;\n}\n\nstatic int l2cap_validate_le_psm(u16 psm)\n{\n\t/* Valid LE_PSM ranges are defined only until 0x00ff */\n\tif (psm > L2CAP_PSM_LE_DYN_END)\n\t\treturn -EINVAL;\n\n\t/* Restrict fixed, SIG assigned PSM values to CAP_NET_BIND_SERVICE */\n\tif (psm < L2CAP_PSM_LE_DYN_START && !capable(CAP_NET_BIND_SERVICE))\n\t\treturn -EACCES;\n\n\treturn 0;\n}\n\nstatic int l2cap_sock_bind(struct socket *sock, struct sockaddr *addr, int alen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct l2cap_chan *chan = l2cap_pi(sk)->chan;\n\tstruct sockaddr_l2 la;\n\tint len, err = 0;\n\n\tBT_DBG(\"sk %p\", sk);\n\n\tif (!addr || alen < offsetofend(struct sockaddr, sa_family) ||\n\t    addr->sa_family != AF_BLUETOOTH)\n\t\treturn -EINVAL;\n\n\tmemset(&la, 0, sizeof(la));\n\tlen = min_t(unsigned int, sizeof(la), alen);\n\tmemcpy(&la, addr, len);\n\n\tif (la.l2_cid && la.l2_psm)\n\t\treturn -EINVAL;\n\n\tif (!bdaddr_type_is_valid(la.l2_bdaddr_type))\n\t\treturn -EINVAL;\n\n\tif (bdaddr_type_is_le(la.l2_bdaddr_type)) {\n\t\t/* We only allow ATT user space socket */\n\t\tif (la.l2_cid &&\n\t\t    la.l2_cid != cpu_to_le16(L2CAP_CID_ATT))\n\t\t\treturn -EINVAL;\n\t}\n\n\tlock_sock(sk);\n\n\tif (sk->sk_state != BT_OPEN) {\n\t\terr = -EBADFD;\n\t\tgoto done;\n\t}\n\n\tif (la.l2_psm) {\n\t\t__u16 psm = __le16_to_cpu(la.l2_psm);\n\n\t\tif (la.l2_bdaddr_type == BDADDR_BREDR)\n\t\t\terr = l2cap_validate_bredr_psm(psm);\n\t\telse\n\t\t\terr = l2cap_validate_le_psm(psm);\n\n\t\tif (err)\n\t\t\tgoto done;\n\t}\n\n\tbacpy(&chan->src, &la.l2_bdaddr);\n\tchan->src_type = la.l2_bdaddr_type;\n\n\tif (la.l2_cid)\n\t\terr = l2cap_add_scid(chan, __le16_to_cpu(la.l2_cid));\n\telse\n\t\terr = l2cap_add_psm(chan, &la.l2_bdaddr, la.l2_psm);\n\n\tif (err < 0)\n\t\tgoto done;\n\n\tswitch (chan->chan_type) {\n\tcase L2CAP_CHAN_CONN_LESS:\n\t\tif (__le16_to_cpu(la.l2_psm) == L2CAP_PSM_3DSP)\n\t\t\tchan->sec_level = BT_SECURITY_SDP;\n\t\tbreak;\n\tcase L2CAP_CHAN_CONN_ORIENTED:\n\t\tif (__le16_to_cpu(la.l2_psm) == L2CAP_PSM_SDP ||\n\t\t    __le16_to_cpu(la.l2_psm) == L2CAP_PSM_RFCOMM)\n\t\t\tchan->sec_level = BT_SECURITY_SDP;\n\t\tbreak;\n\tcase L2CAP_CHAN_RAW:\n\t\tchan->sec_level = BT_SECURITY_SDP;\n\t\tbreak;\n\tcase L2CAP_CHAN_FIXED:\n\t\t/* Fixed channels default to the L2CAP core not holding a\n\t\t * hci_conn reference for them. For fixed channels mapping to\n\t\t * L2CAP sockets we do want to hold a reference so set the\n\t\t * appropriate flag to request it.\n\t\t */\n\t\tset_bit(FLAG_HOLD_HCI_CONN, &chan->flags);\n\t\tbreak;\n\t}\n\n\t/* Use L2CAP_MODE_LE_FLOWCTL (CoC) in case of LE address and\n\t * L2CAP_MODE_EXT_FLOWCTL (ECRED) has not been set.\n\t */\n\tif (chan->psm && bdaddr_type_is_le(chan->src_type) &&\n\t    chan->mode != L2CAP_MODE_EXT_FLOWCTL)\n\t\tchan->mode = L2CAP_MODE_LE_FLOWCTL;\n\n\tchan->state = BT_BOUND;\n\tsk->sk_state = BT_BOUND;\n\ndone:\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic void l2cap_sock_init_pid(struct sock *sk)\n{\n\tstruct l2cap_chan *chan = l2cap_pi(sk)->chan;\n\n\t/* Only L2CAP_MODE_EXT_FLOWCTL ever need to access the PID in order to\n\t * group the channels being requested.\n\t */\n\tif (chan->mode != L2CAP_MODE_EXT_FLOWCTL)\n\t\treturn;\n\n\tspin_lock(&sk->sk_peer_lock);\n\tsk->sk_peer_pid = get_pid(task_tgid(current));\n\tspin_unlock(&sk->sk_peer_lock);\n}\n\nstatic int l2cap_sock_connect(struct socket *sock, struct sockaddr *addr,\n\t\t\t      int alen, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct l2cap_chan *chan = l2cap_pi(sk)->chan;\n\tstruct sockaddr_l2 la;\n\tint len, err = 0;\n\tbool zapped;\n\n\tBT_DBG(\"sk %p\", sk);\n\n\tlock_sock(sk);\n\tzapped = sock_flag(sk, SOCK_ZAPPED);\n\trelease_sock(sk);\n\n\tif (zapped)\n\t\treturn -EINVAL;\n\n\tif (!addr || alen < offsetofend(struct sockaddr, sa_family) ||\n\t    addr->sa_family != AF_BLUETOOTH)\n\t\treturn -EINVAL;\n\n\tmemset(&la, 0, sizeof(la));\n\tlen = min_t(unsigned int, sizeof(la), alen);\n\tmemcpy(&la, addr, len);\n\n\tif (la.l2_cid && la.l2_psm)\n\t\treturn -EINVAL;\n\n\tif (!bdaddr_type_is_valid(la.l2_bdaddr_type))\n\t\treturn -EINVAL;\n\n\t/* Check that the socket wasn't bound to something that\n\t * conflicts with the address given to connect(). If chan->src\n\t * is BDADDR_ANY it means bind() was never used, in which case\n\t * chan->src_type and la.l2_bdaddr_type do not need to match.\n\t */\n\tif (chan->src_type == BDADDR_BREDR && bacmp(&chan->src, BDADDR_ANY) &&\n\t    bdaddr_type_is_le(la.l2_bdaddr_type)) {\n\t\t/* Old user space versions will try to incorrectly bind\n\t\t * the ATT socket using BDADDR_BREDR. We need to accept\n\t\t * this and fix up the source address type only when\n\t\t * both the source CID and destination CID indicate\n\t\t * ATT. Anything else is an invalid combination.\n\t\t */\n\t\tif (chan->scid != L2CAP_CID_ATT ||\n\t\t    la.l2_cid != cpu_to_le16(L2CAP_CID_ATT))\n\t\t\treturn -EINVAL;\n\n\t\t/* We don't have the hdev available here to make a\n\t\t * better decision on random vs public, but since all\n\t\t * user space versions that exhibit this issue anyway do\n\t\t * not support random local addresses assuming public\n\t\t * here is good enough.\n\t\t */\n\t\tchan->src_type = BDADDR_LE_PUBLIC;\n\t}\n\n\tif (chan->src_type != BDADDR_BREDR && la.l2_bdaddr_type == BDADDR_BREDR)\n\t\treturn -EINVAL;\n\n\tif (bdaddr_type_is_le(la.l2_bdaddr_type)) {\n\t\t/* We only allow ATT user space socket */\n\t\tif (la.l2_cid &&\n\t\t    la.l2_cid != cpu_to_le16(L2CAP_CID_ATT))\n\t\t\treturn -EINVAL;\n\t}\n\n\t/* Use L2CAP_MODE_LE_FLOWCTL (CoC) in case of LE address and\n\t * L2CAP_MODE_EXT_FLOWCTL (ECRED) has not been set.\n\t */\n\tif (chan->psm && bdaddr_type_is_le(chan->src_type) &&\n\t    chan->mode != L2CAP_MODE_EXT_FLOWCTL)\n\t\tchan->mode = L2CAP_MODE_LE_FLOWCTL;\n\n\tl2cap_sock_init_pid(sk);\n\n\terr = l2cap_chan_connect(chan, la.l2_psm, __le16_to_cpu(la.l2_cid),\n\t\t\t\t &la.l2_bdaddr, la.l2_bdaddr_type);\n\tif (err)\n\t\treturn err;\n\n\tlock_sock(sk);\n\n\terr = bt_sock_wait_state(sk, BT_CONNECTED,\n\t\t\t\t sock_sndtimeo(sk, flags & O_NONBLOCK));\n\n\trelease_sock(sk);\n\n\treturn err;\n}\n\nstatic int l2cap_sock_listen(struct socket *sock, int backlog)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct l2cap_chan *chan = l2cap_pi(sk)->chan;\n\tint err = 0;\n\n\tBT_DBG(\"sk %p backlog %d\", sk, backlog);\n\n\tlock_sock(sk);\n\n\tif (sk->sk_state != BT_BOUND) {\n\t\terr = -EBADFD;\n\t\tgoto done;\n\t}\n\n\tif (sk->sk_type != SOCK_SEQPACKET && sk->sk_type != SOCK_STREAM) {\n\t\terr = -EINVAL;\n\t\tgoto done;\n\t}\n\n\tswitch (chan->mode) {\n\tcase L2CAP_MODE_BASIC:\n\tcase L2CAP_MODE_LE_FLOWCTL:\n\t\tbreak;\n\tcase L2CAP_MODE_EXT_FLOWCTL:\n\t\tif (!enable_ecred) {\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto done;\n\t\t}\n\t\tbreak;\n\tcase L2CAP_MODE_ERTM:\n\tcase L2CAP_MODE_STREAMING:\n\t\tif (!disable_ertm)\n\t\t\tbreak;\n\t\tfallthrough;\n\tdefault:\n\t\terr = -EOPNOTSUPP;\n\t\tgoto done;\n\t}\n\n\tl2cap_sock_init_pid(sk);\n\n\tsk->sk_max_ack_backlog = backlog;\n\tsk->sk_ack_backlog = 0;\n\n\t/* Listening channels need to use nested locking in order not to\n\t * cause lockdep warnings when the created child channels end up\n\t * being locked in the same thread as the parent channel.\n\t */\n\tatomic_set(&chan->nesting, L2CAP_NESTING_PARENT);\n\n\tchan->state = BT_LISTEN;\n\tsk->sk_state = BT_LISTEN;\n\ndone:\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic int l2cap_sock_accept(struct socket *sock, struct socket *newsock,\n\t\t\t     int flags, bool kern)\n{\n\tDEFINE_WAIT_FUNC(wait, woken_wake_function);\n\tstruct sock *sk = sock->sk, *nsk;\n\tlong timeo;\n\tint err = 0;\n\n\tlock_sock_nested(sk, L2CAP_NESTING_PARENT);\n\n\ttimeo = sock_rcvtimeo(sk, flags & O_NONBLOCK);\n\n\tBT_DBG(\"sk %p timeo %ld\", sk, timeo);\n\n\t/* Wait for an incoming connection. (wake-one). */\n\tadd_wait_queue_exclusive(sk_sleep(sk), &wait);\n\twhile (1) {\n\t\tif (sk->sk_state != BT_LISTEN) {\n\t\t\terr = -EBADFD;\n\t\t\tbreak;\n\t\t}\n\n\t\tnsk = bt_accept_dequeue(sk, newsock);\n\t\tif (nsk)\n\t\t\tbreak;\n\n\t\tif (!timeo) {\n\t\t\terr = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (signal_pending(current)) {\n\t\t\terr = sock_intr_errno(timeo);\n\t\t\tbreak;\n\t\t}\n\n\t\trelease_sock(sk);\n\n\t\ttimeo = wait_woken(&wait, TASK_INTERRUPTIBLE, timeo);\n\n\t\tlock_sock_nested(sk, L2CAP_NESTING_PARENT);\n\t}\n\tremove_wait_queue(sk_sleep(sk), &wait);\n\n\tif (err)\n\t\tgoto done;\n\n\tnewsock->state = SS_CONNECTED;\n\n\tBT_DBG(\"new socket %p\", nsk);\n\ndone:\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic int l2cap_sock_getname(struct socket *sock, struct sockaddr *addr,\n\t\t\t      int peer)\n{\n\tstruct sockaddr_l2 *la = (struct sockaddr_l2 *) addr;\n\tstruct sock *sk = sock->sk;\n\tstruct l2cap_chan *chan = l2cap_pi(sk)->chan;\n\n\tBT_DBG(\"sock %p, sk %p\", sock, sk);\n\n\tif (peer && sk->sk_state != BT_CONNECTED &&\n\t    sk->sk_state != BT_CONNECT && sk->sk_state != BT_CONNECT2 &&\n\t    sk->sk_state != BT_CONFIG)\n\t\treturn -ENOTCONN;\n\n\tmemset(la, 0, sizeof(struct sockaddr_l2));\n\taddr->sa_family = AF_BLUETOOTH;\n\n\tla->l2_psm = chan->psm;\n\n\tif (peer) {\n\t\tbacpy(&la->l2_bdaddr, &chan->dst);\n\t\tla->l2_cid = cpu_to_le16(chan->dcid);\n\t\tla->l2_bdaddr_type = chan->dst_type;\n\t} else {\n\t\tbacpy(&la->l2_bdaddr, &chan->src);\n\t\tla->l2_cid = cpu_to_le16(chan->scid);\n\t\tla->l2_bdaddr_type = chan->src_type;\n\t}\n\n\treturn sizeof(struct sockaddr_l2);\n}\n\nstatic int l2cap_get_mode(struct l2cap_chan *chan)\n{\n\tswitch (chan->mode) {\n\tcase L2CAP_MODE_BASIC:\n\t\treturn BT_MODE_BASIC;\n\tcase L2CAP_MODE_ERTM:\n\t\treturn BT_MODE_ERTM;\n\tcase L2CAP_MODE_STREAMING:\n\t\treturn BT_MODE_STREAMING;\n\tcase L2CAP_MODE_LE_FLOWCTL:\n\t\treturn BT_MODE_LE_FLOWCTL;\n\tcase L2CAP_MODE_EXT_FLOWCTL:\n\t\treturn BT_MODE_EXT_FLOWCTL;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int l2cap_sock_getsockopt_old(struct socket *sock, int optname,\n\t\t\t\t     char __user *optval, int __user *optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct l2cap_chan *chan = l2cap_pi(sk)->chan;\n\tstruct l2cap_options opts;\n\tstruct l2cap_conninfo cinfo;\n\tint len, err = 0;\n\tu32 opt;\n\n\tBT_DBG(\"sk %p\", sk);\n\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\n\tlock_sock(sk);\n\n\tswitch (optname) {\n\tcase L2CAP_OPTIONS:\n\t\t/* LE sockets should use BT_SNDMTU/BT_RCVMTU, but since\n\t\t * legacy ATT code depends on getsockopt for\n\t\t * L2CAP_OPTIONS we need to let this pass.\n\t\t */\n\t\tif (bdaddr_type_is_le(chan->src_type) &&\n\t\t    chan->scid != L2CAP_CID_ATT) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Only BR/EDR modes are supported here */\n\t\tswitch (chan->mode) {\n\t\tcase L2CAP_MODE_BASIC:\n\t\tcase L2CAP_MODE_ERTM:\n\t\tcase L2CAP_MODE_STREAMING:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (err < 0)\n\t\t\tbreak;\n\n\t\tmemset(&opts, 0, sizeof(opts));\n\t\topts.imtu     = chan->imtu;\n\t\topts.omtu     = chan->omtu;\n\t\topts.flush_to = chan->flush_to;\n\t\topts.mode     = chan->mode;\n\t\topts.fcs      = chan->fcs;\n\t\topts.max_tx   = chan->max_tx;\n\t\topts.txwin_size = chan->tx_win;\n\n\t\tBT_DBG(\"mode 0x%2.2x\", chan->mode);\n\n\t\tlen = min_t(unsigned int, len, sizeof(opts));\n\t\tif (copy_to_user(optval, (char *) &opts, len))\n\t\t\terr = -EFAULT;\n\n\t\tbreak;\n\n\tcase L2CAP_LM:\n\t\tswitch (chan->sec_level) {\n\t\tcase BT_SECURITY_LOW:\n\t\t\topt = L2CAP_LM_AUTH;\n\t\t\tbreak;\n\t\tcase BT_SECURITY_MEDIUM:\n\t\t\topt = L2CAP_LM_AUTH | L2CAP_LM_ENCRYPT;\n\t\t\tbreak;\n\t\tcase BT_SECURITY_HIGH:\n\t\t\topt = L2CAP_LM_AUTH | L2CAP_LM_ENCRYPT |\n\t\t\t      L2CAP_LM_SECURE;\n\t\t\tbreak;\n\t\tcase BT_SECURITY_FIPS:\n\t\t\topt = L2CAP_LM_AUTH | L2CAP_LM_ENCRYPT |\n\t\t\t      L2CAP_LM_SECURE | L2CAP_LM_FIPS;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\topt = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (test_bit(FLAG_ROLE_SWITCH, &chan->flags))\n\t\t\topt |= L2CAP_LM_MASTER;\n\n\t\tif (test_bit(FLAG_FORCE_RELIABLE, &chan->flags))\n\t\t\topt |= L2CAP_LM_RELIABLE;\n\n\t\tif (put_user(opt, (u32 __user *) optval))\n\t\t\terr = -EFAULT;\n\n\t\tbreak;\n\n\tcase L2CAP_CONNINFO:\n\t\tif (sk->sk_state != BT_CONNECTED &&\n\t\t    !(sk->sk_state == BT_CONNECT2 &&\n\t\t      test_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags))) {\n\t\t\terr = -ENOTCONN;\n\t\t\tbreak;\n\t\t}\n\n\t\tmemset(&cinfo, 0, sizeof(cinfo));\n\t\tcinfo.hci_handle = chan->conn->hcon->handle;\n\t\tmemcpy(cinfo.dev_class, chan->conn->hcon->dev_class, 3);\n\n\t\tlen = min_t(unsigned int, len, sizeof(cinfo));\n\t\tif (copy_to_user(optval, (char *) &cinfo, len))\n\t\t\terr = -EFAULT;\n\n\t\tbreak;\n\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic int l2cap_sock_getsockopt(struct socket *sock, int level, int optname,\n\t\t\t\t char __user *optval, int __user *optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct l2cap_chan *chan = l2cap_pi(sk)->chan;\n\tstruct bt_security sec;\n\tstruct bt_power pwr;\n\tu32 phys;\n\tint len, mode, err = 0;\n\n\tBT_DBG(\"sk %p\", sk);\n\n\tif (level == SOL_L2CAP)\n\t\treturn l2cap_sock_getsockopt_old(sock, optname, optval, optlen);\n\n\tif (level != SOL_BLUETOOTH)\n\t\treturn -ENOPROTOOPT;\n\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\n\tlock_sock(sk);\n\n\tswitch (optname) {\n\tcase BT_SECURITY:\n\t\tif (chan->chan_type != L2CAP_CHAN_CONN_ORIENTED &&\n\t\t    chan->chan_type != L2CAP_CHAN_FIXED &&\n\t\t    chan->chan_type != L2CAP_CHAN_RAW) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tmemset(&sec, 0, sizeof(sec));\n\t\tif (chan->conn) {\n\t\t\tsec.level = chan->conn->hcon->sec_level;\n\n\t\t\tif (sk->sk_state == BT_CONNECTED)\n\t\t\t\tsec.key_size = chan->conn->hcon->enc_key_size;\n\t\t} else {\n\t\t\tsec.level = chan->sec_level;\n\t\t}\n\n\t\tlen = min_t(unsigned int, len, sizeof(sec));\n\t\tif (copy_to_user(optval, (char *) &sec, len))\n\t\t\terr = -EFAULT;\n\n\t\tbreak;\n\n\tcase BT_DEFER_SETUP:\n\t\tif (sk->sk_state != BT_BOUND && sk->sk_state != BT_LISTEN) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (put_user(test_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags),\n\t\t\t     (u32 __user *) optval))\n\t\t\terr = -EFAULT;\n\n\t\tbreak;\n\n\tcase BT_FLUSHABLE:\n\t\tif (put_user(test_bit(FLAG_FLUSHABLE, &chan->flags),\n\t\t\t     (u32 __user *) optval))\n\t\t\terr = -EFAULT;\n\n\t\tbreak;\n\n\tcase BT_POWER:\n\t\tif (sk->sk_type != SOCK_SEQPACKET && sk->sk_type != SOCK_STREAM\n\t\t    && sk->sk_type != SOCK_RAW) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tpwr.force_active = test_bit(FLAG_FORCE_ACTIVE, &chan->flags);\n\n\t\tlen = min_t(unsigned int, len, sizeof(pwr));\n\t\tif (copy_to_user(optval, (char *) &pwr, len))\n\t\t\terr = -EFAULT;\n\n\t\tbreak;\n\n\tcase BT_CHANNEL_POLICY:\n\t\tif (put_user(chan->chan_policy, (u32 __user *) optval))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\n\tcase BT_SNDMTU:\n\t\tif (!bdaddr_type_is_le(chan->src_type)) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (sk->sk_state != BT_CONNECTED) {\n\t\t\terr = -ENOTCONN;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (put_user(chan->omtu, (u16 __user *) optval))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\n\tcase BT_RCVMTU:\n\t\tif (!bdaddr_type_is_le(chan->src_type)) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (put_user(chan->imtu, (u16 __user *) optval))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\n\tcase BT_PHY:\n\t\tif (sk->sk_state != BT_CONNECTED) {\n\t\t\terr = -ENOTCONN;\n\t\t\tbreak;\n\t\t}\n\n\t\tphys = hci_conn_get_phy(chan->conn->hcon);\n\n\t\tif (put_user(phys, (u32 __user *) optval))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\n\tcase BT_MODE:\n\t\tif (!enable_ecred) {\n\t\t\terr = -ENOPROTOOPT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (chan->chan_type != L2CAP_CHAN_CONN_ORIENTED) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tmode = l2cap_get_mode(chan);\n\t\tif (mode < 0) {\n\t\t\terr = mode;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (put_user(mode, (u8 __user *) optval))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic bool l2cap_valid_mtu(struct l2cap_chan *chan, u16 mtu)\n{\n\tswitch (chan->scid) {\n\tcase L2CAP_CID_ATT:\n\t\tif (mtu < L2CAP_LE_MIN_MTU)\n\t\t\treturn false;\n\t\tbreak;\n\n\tdefault:\n\t\tif (mtu < L2CAP_DEFAULT_MIN_MTU)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic int l2cap_sock_setsockopt_old(struct socket *sock, int optname,\n\t\t\t\t     sockptr_t optval, unsigned int optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct l2cap_chan *chan = l2cap_pi(sk)->chan;\n\tstruct l2cap_options opts;\n\tint len, err = 0;\n\tu32 opt;\n\n\tBT_DBG(\"sk %p\", sk);\n\n\tlock_sock(sk);\n\n\tswitch (optname) {\n\tcase L2CAP_OPTIONS:\n\t\tif (bdaddr_type_is_le(chan->src_type)) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (sk->sk_state == BT_CONNECTED) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\topts.imtu     = chan->imtu;\n\t\topts.omtu     = chan->omtu;\n\t\topts.flush_to = chan->flush_to;\n\t\topts.mode     = chan->mode;\n\t\topts.fcs      = chan->fcs;\n\t\topts.max_tx   = chan->max_tx;\n\t\topts.txwin_size = chan->tx_win;\n\n\t\tlen = min_t(unsigned int, sizeof(opts), optlen);\n\t\tif (copy_from_sockptr(&opts, optval, len)) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (opts.txwin_size > L2CAP_DEFAULT_EXT_WINDOW) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!l2cap_valid_mtu(chan, opts.imtu)) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Only BR/EDR modes are supported here */\n\t\tswitch (opts.mode) {\n\t\tcase L2CAP_MODE_BASIC:\n\t\t\tclear_bit(CONF_STATE2_DEVICE, &chan->conf_state);\n\t\t\tbreak;\n\t\tcase L2CAP_MODE_ERTM:\n\t\tcase L2CAP_MODE_STREAMING:\n\t\t\tif (!disable_ertm)\n\t\t\t\tbreak;\n\t\t\tfallthrough;\n\t\tdefault:\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (err < 0)\n\t\t\tbreak;\n\n\t\tchan->mode = opts.mode;\n\n\t\tBT_DBG(\"mode 0x%2.2x\", chan->mode);\n\n\t\tchan->imtu = opts.imtu;\n\t\tchan->omtu = opts.omtu;\n\t\tchan->fcs  = opts.fcs;\n\t\tchan->max_tx = opts.max_tx;\n\t\tchan->tx_win = opts.txwin_size;\n\t\tchan->flush_to = opts.flush_to;\n\t\tbreak;\n\n\tcase L2CAP_LM:\n\t\tif (copy_from_sockptr(&opt, optval, sizeof(u32))) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (opt & L2CAP_LM_FIPS) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (opt & L2CAP_LM_AUTH)\n\t\t\tchan->sec_level = BT_SECURITY_LOW;\n\t\tif (opt & L2CAP_LM_ENCRYPT)\n\t\t\tchan->sec_level = BT_SECURITY_MEDIUM;\n\t\tif (opt & L2CAP_LM_SECURE)\n\t\t\tchan->sec_level = BT_SECURITY_HIGH;\n\n\t\tif (opt & L2CAP_LM_MASTER)\n\t\t\tset_bit(FLAG_ROLE_SWITCH, &chan->flags);\n\t\telse\n\t\t\tclear_bit(FLAG_ROLE_SWITCH, &chan->flags);\n\n\t\tif (opt & L2CAP_LM_RELIABLE)\n\t\t\tset_bit(FLAG_FORCE_RELIABLE, &chan->flags);\n\t\telse\n\t\t\tclear_bit(FLAG_FORCE_RELIABLE, &chan->flags);\n\t\tbreak;\n\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic int l2cap_set_mode(struct l2cap_chan *chan, u8 mode)\n{\n\tswitch (mode) {\n\tcase BT_MODE_BASIC:\n\t\tif (bdaddr_type_is_le(chan->src_type))\n\t\t\treturn -EINVAL;\n\t\tmode = L2CAP_MODE_BASIC;\n\t\tclear_bit(CONF_STATE2_DEVICE, &chan->conf_state);\n\t\tbreak;\n\tcase BT_MODE_ERTM:\n\t\tif (!disable_ertm || bdaddr_type_is_le(chan->src_type))\n\t\t\treturn -EINVAL;\n\t\tmode = L2CAP_MODE_ERTM;\n\t\tbreak;\n\tcase BT_MODE_STREAMING:\n\t\tif (!disable_ertm || bdaddr_type_is_le(chan->src_type))\n\t\t\treturn -EINVAL;\n\t\tmode = L2CAP_MODE_STREAMING;\n\t\tbreak;\n\tcase BT_MODE_LE_FLOWCTL:\n\t\tif (!bdaddr_type_is_le(chan->src_type))\n\t\t\treturn -EINVAL;\n\t\tmode = L2CAP_MODE_LE_FLOWCTL;\n\t\tbreak;\n\tcase BT_MODE_EXT_FLOWCTL:\n\t\t/* TODO: Add support for ECRED PDUs to BR/EDR */\n\t\tif (!bdaddr_type_is_le(chan->src_type))\n\t\t\treturn -EINVAL;\n\t\tmode = L2CAP_MODE_EXT_FLOWCTL;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tchan->mode = mode;\n\n\treturn 0;\n}\n\nstatic int l2cap_sock_setsockopt(struct socket *sock, int level, int optname,\n\t\t\t\t sockptr_t optval, unsigned int optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct l2cap_chan *chan = l2cap_pi(sk)->chan;\n\tstruct bt_security sec;\n\tstruct bt_power pwr;\n\tstruct l2cap_conn *conn;\n\tint len, err = 0;\n\tu32 opt;\n\tu16 mtu;\n\tu8 mode;\n\n\tBT_DBG(\"sk %p\", sk);\n\n\tif (level == SOL_L2CAP)\n\t\treturn l2cap_sock_setsockopt_old(sock, optname, optval, optlen);\n\n\tif (level != SOL_BLUETOOTH)\n\t\treturn -ENOPROTOOPT;\n\n\tlock_sock(sk);\n\n\tswitch (optname) {\n\tcase BT_SECURITY:\n\t\tif (chan->chan_type != L2CAP_CHAN_CONN_ORIENTED &&\n\t\t    chan->chan_type != L2CAP_CHAN_FIXED &&\n\t\t    chan->chan_type != L2CAP_CHAN_RAW) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tsec.level = BT_SECURITY_LOW;\n\n\t\tlen = min_t(unsigned int, sizeof(sec), optlen);\n\t\tif (copy_from_sockptr(&sec, optval, len)) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (sec.level < BT_SECURITY_LOW ||\n\t\t    sec.level > BT_SECURITY_FIPS) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tchan->sec_level = sec.level;\n\n\t\tif (!chan->conn)\n\t\t\tbreak;\n\n\t\tconn = chan->conn;\n\n\t\t/* change security for LE channels */\n\t\tif (chan->scid == L2CAP_CID_ATT) {\n\t\t\tif (smp_conn_security(conn->hcon, sec.level)) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tset_bit(FLAG_PENDING_SECURITY, &chan->flags);\n\t\t\tsk->sk_state = BT_CONFIG;\n\t\t\tchan->state = BT_CONFIG;\n\n\t\t/* or for ACL link */\n\t\t} else if ((sk->sk_state == BT_CONNECT2 &&\n\t\t\t    test_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags)) ||\n\t\t\t   sk->sk_state == BT_CONNECTED) {\n\t\t\tif (!l2cap_chan_check_security(chan, true))\n\t\t\t\tset_bit(BT_SK_SUSPEND, &bt_sk(sk)->flags);\n\t\t\telse\n\t\t\t\tsk->sk_state_change(sk);\n\t\t} else {\n\t\t\terr = -EINVAL;\n\t\t}\n\t\tbreak;\n\n\tcase BT_DEFER_SETUP:\n\t\tif (sk->sk_state != BT_BOUND && sk->sk_state != BT_LISTEN) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (copy_from_sockptr(&opt, optval, sizeof(u32))) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (opt) {\n\t\t\tset_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags);\n\t\t\tset_bit(FLAG_DEFER_SETUP, &chan->flags);\n\t\t} else {\n\t\t\tclear_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags);\n\t\t\tclear_bit(FLAG_DEFER_SETUP, &chan->flags);\n\t\t}\n\t\tbreak;\n\n\tcase BT_FLUSHABLE:\n\t\tif (copy_from_sockptr(&opt, optval, sizeof(u32))) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (opt > BT_FLUSHABLE_ON) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (opt == BT_FLUSHABLE_OFF) {\n\t\t\tconn = chan->conn;\n\t\t\t/* proceed further only when we have l2cap_conn and\n\t\t\t   No Flush support in the LM */\n\t\t\tif (!conn || !lmp_no_flush_capable(conn->hcon->hdev)) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (opt)\n\t\t\tset_bit(FLAG_FLUSHABLE, &chan->flags);\n\t\telse\n\t\t\tclear_bit(FLAG_FLUSHABLE, &chan->flags);\n\t\tbreak;\n\n\tcase BT_POWER:\n\t\tif (chan->chan_type != L2CAP_CHAN_CONN_ORIENTED &&\n\t\t    chan->chan_type != L2CAP_CHAN_RAW) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tpwr.force_active = BT_POWER_FORCE_ACTIVE_ON;\n\n\t\tlen = min_t(unsigned int, sizeof(pwr), optlen);\n\t\tif (copy_from_sockptr(&pwr, optval, len)) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (pwr.force_active)\n\t\t\tset_bit(FLAG_FORCE_ACTIVE, &chan->flags);\n\t\telse\n\t\t\tclear_bit(FLAG_FORCE_ACTIVE, &chan->flags);\n\t\tbreak;\n\n\tcase BT_CHANNEL_POLICY:\n\t\tif (copy_from_sockptr(&opt, optval, sizeof(u32))) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (opt > BT_CHANNEL_POLICY_AMP_PREFERRED) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (chan->mode != L2CAP_MODE_ERTM &&\n\t\t    chan->mode != L2CAP_MODE_STREAMING) {\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tbreak;\n\t\t}\n\n\t\tchan->chan_policy = (u8) opt;\n\n\t\tif (sk->sk_state == BT_CONNECTED &&\n\t\t    chan->move_role == L2CAP_MOVE_ROLE_NONE)\n\t\t\tl2cap_move_start(chan);\n\n\t\tbreak;\n\n\tcase BT_SNDMTU:\n\t\tif (!bdaddr_type_is_le(chan->src_type)) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Setting is not supported as it's the remote side that\n\t\t * decides this.\n\t\t */\n\t\terr = -EPERM;\n\t\tbreak;\n\n\tcase BT_RCVMTU:\n\t\tif (!bdaddr_type_is_le(chan->src_type)) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (chan->mode == L2CAP_MODE_LE_FLOWCTL &&\n\t\t    sk->sk_state == BT_CONNECTED) {\n\t\t\terr = -EISCONN;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (copy_from_sockptr(&mtu, optval, sizeof(u16))) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (chan->mode == L2CAP_MODE_EXT_FLOWCTL &&\n\t\t    sk->sk_state == BT_CONNECTED)\n\t\t\terr = l2cap_chan_reconfigure(chan, mtu);\n\t\telse\n\t\t\tchan->imtu = mtu;\n\n\t\tbreak;\n\n\tcase BT_MODE:\n\t\tif (!enable_ecred) {\n\t\t\terr = -ENOPROTOOPT;\n\t\t\tbreak;\n\t\t}\n\n\t\tBT_DBG(\"sk->sk_state %u\", sk->sk_state);\n\n\t\tif (sk->sk_state != BT_BOUND) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (chan->chan_type != L2CAP_CHAN_CONN_ORIENTED) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (copy_from_sockptr(&mode, optval, sizeof(u8))) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tBT_DBG(\"mode %u\", mode);\n\n\t\terr = l2cap_set_mode(chan, mode);\n\t\tif (err)\n\t\t\tbreak;\n\n\t\tBT_DBG(\"mode 0x%2.2x\", chan->mode);\n\n\t\tbreak;\n\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic int l2cap_sock_sendmsg(struct socket *sock, struct msghdr *msg,\n\t\t\t      size_t len)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct l2cap_chan *chan = l2cap_pi(sk)->chan;\n\tint err;\n\n\tBT_DBG(\"sock %p, sk %p\", sock, sk);\n\n\terr = sock_error(sk);\n\tif (err)\n\t\treturn err;\n\n\tif (msg->msg_flags & MSG_OOB)\n\t\treturn -EOPNOTSUPP;\n\n\tif (sk->sk_state != BT_CONNECTED)\n\t\treturn -ENOTCONN;\n\n\tlock_sock(sk);\n\terr = bt_sock_wait_ready(sk, msg->msg_flags);\n\trelease_sock(sk);\n\tif (err)\n\t\treturn err;\n\n\tl2cap_chan_lock(chan);\n\terr = l2cap_chan_send(chan, msg, len);\n\tl2cap_chan_unlock(chan);\n\n\treturn err;\n}\n\nstatic int l2cap_sock_recvmsg(struct socket *sock, struct msghdr *msg,\n\t\t\t      size_t len, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct l2cap_pinfo *pi = l2cap_pi(sk);\n\tint err;\n\n\tlock_sock(sk);\n\n\tif (sk->sk_state == BT_CONNECT2 && test_bit(BT_SK_DEFER_SETUP,\n\t\t\t\t\t\t    &bt_sk(sk)->flags)) {\n\t\tif (pi->chan->mode == L2CAP_MODE_EXT_FLOWCTL) {\n\t\t\tsk->sk_state = BT_CONNECTED;\n\t\t\tpi->chan->state = BT_CONNECTED;\n\t\t\t__l2cap_ecred_conn_rsp_defer(pi->chan);\n\t\t} else if (bdaddr_type_is_le(pi->chan->src_type)) {\n\t\t\tsk->sk_state = BT_CONNECTED;\n\t\t\tpi->chan->state = BT_CONNECTED;\n\t\t\t__l2cap_le_connect_rsp_defer(pi->chan);\n\t\t} else {\n\t\t\tsk->sk_state = BT_CONFIG;\n\t\t\tpi->chan->state = BT_CONFIG;\n\t\t\t__l2cap_connect_rsp_defer(pi->chan);\n\t\t}\n\n\t\terr = 0;\n\t\tgoto done;\n\t}\n\n\trelease_sock(sk);\n\n\tif (sock->type == SOCK_STREAM)\n\t\terr = bt_sock_stream_recvmsg(sock, msg, len, flags);\n\telse\n\t\terr = bt_sock_recvmsg(sock, msg, len, flags);\n\n\tif (pi->chan->mode != L2CAP_MODE_ERTM)\n\t\treturn err;\n\n\t/* Attempt to put pending rx data in the socket buffer */\n\n\tlock_sock(sk);\n\n\tif (!test_bit(CONN_LOCAL_BUSY, &pi->chan->conn_state))\n\t\tgoto done;\n\n\tif (pi->rx_busy_skb) {\n\t\tif (!__sock_queue_rcv_skb(sk, pi->rx_busy_skb))\n\t\t\tpi->rx_busy_skb = NULL;\n\t\telse\n\t\t\tgoto done;\n\t}\n\n\t/* Restore data flow when half of the receive buffer is\n\t * available.  This avoids resending large numbers of\n\t * frames.\n\t */\n\tif (atomic_read(&sk->sk_rmem_alloc) <= sk->sk_rcvbuf >> 1)\n\t\tl2cap_chan_busy(pi->chan, 0);\n\ndone:\n\trelease_sock(sk);\n\treturn err;\n}\n\n/* Kill socket (only if zapped and orphan)\n * Must be called on unlocked socket, with l2cap channel lock.\n */\nstatic void l2cap_sock_kill(struct sock *sk)\n{\n\tif (!sock_flag(sk, SOCK_ZAPPED) || sk->sk_socket)\n\t\treturn;\n\n\tBT_DBG(\"sk %p state %s\", sk, state_to_string(sk->sk_state));\n\n\t/* Kill poor orphan */\n\n\tl2cap_chan_put(l2cap_pi(sk)->chan);\n\tsock_set_flag(sk, SOCK_DEAD);\n\tsock_put(sk);\n}\n\nstatic int __l2cap_wait_ack(struct sock *sk, struct l2cap_chan *chan)\n{\n\tDECLARE_WAITQUEUE(wait, current);\n\tint err = 0;\n\tint timeo = L2CAP_WAIT_ACK_POLL_PERIOD;\n\t/* Timeout to prevent infinite loop */\n\tunsigned long timeout = jiffies + L2CAP_WAIT_ACK_TIMEOUT;\n\n\tadd_wait_queue(sk_sleep(sk), &wait);\n\tset_current_state(TASK_INTERRUPTIBLE);\n\tdo {\n\t\tBT_DBG(\"Waiting for %d ACKs, timeout %04d ms\",\n\t\t       chan->unacked_frames, time_after(jiffies, timeout) ? 0 :\n\t\t       jiffies_to_msecs(timeout - jiffies));\n\n\t\tif (!timeo)\n\t\t\ttimeo = L2CAP_WAIT_ACK_POLL_PERIOD;\n\n\t\tif (signal_pending(current)) {\n\t\t\terr = sock_intr_errno(timeo);\n\t\t\tbreak;\n\t\t}\n\n\t\trelease_sock(sk);\n\t\ttimeo = schedule_timeout(timeo);\n\t\tlock_sock(sk);\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\n\t\terr = sock_error(sk);\n\t\tif (err)\n\t\t\tbreak;\n\n\t\tif (time_after(jiffies, timeout)) {\n\t\t\terr = -ENOLINK;\n\t\t\tbreak;\n\t\t}\n\n\t} while (chan->unacked_frames > 0 &&\n\t\t chan->state == BT_CONNECTED);\n\n\tset_current_state(TASK_RUNNING);\n\tremove_wait_queue(sk_sleep(sk), &wait);\n\treturn err;\n}\n\nstatic int l2cap_sock_shutdown(struct socket *sock, int how)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct l2cap_chan *chan;\n\tstruct l2cap_conn *conn;\n\tint err = 0;\n\n\tBT_DBG(\"sock %p, sk %p, how %d\", sock, sk, how);\n\n\t/* 'how' parameter is mapped to sk_shutdown as follows:\n\t * SHUT_RD   (0) --> RCV_SHUTDOWN  (1)\n\t * SHUT_WR   (1) --> SEND_SHUTDOWN (2)\n\t * SHUT_RDWR (2) --> SHUTDOWN_MASK (3)\n\t */\n\thow++;\n\n\tif (!sk)\n\t\treturn 0;\n\n\tlock_sock(sk);\n\n\tif ((sk->sk_shutdown & how) == how)\n\t\tgoto shutdown_already;\n\n\tBT_DBG(\"Handling sock shutdown\");\n\n\t/* prevent sk structure from being freed whilst unlocked */\n\tsock_hold(sk);\n\n\tchan = l2cap_pi(sk)->chan;\n\t/* prevent chan structure from being freed whilst unlocked */\n\tl2cap_chan_hold(chan);\n\n\tBT_DBG(\"chan %p state %s\", chan, state_to_string(chan->state));\n\n\tif (chan->mode == L2CAP_MODE_ERTM &&\n\t    chan->unacked_frames > 0 &&\n\t    chan->state == BT_CONNECTED) {\n\t\terr = __l2cap_wait_ack(sk, chan);\n\n\t\t/* After waiting for ACKs, check whether shutdown\n\t\t * has already been actioned to close the L2CAP\n\t\t * link such as by l2cap_disconnection_req().\n\t\t */\n\t\tif ((sk->sk_shutdown & how) == how)\n\t\t\tgoto shutdown_matched;\n\t}\n\n\t/* Try setting the RCV_SHUTDOWN bit, return early if SEND_SHUTDOWN\n\t * is already set\n\t */\n\tif ((how & RCV_SHUTDOWN) && !(sk->sk_shutdown & RCV_SHUTDOWN)) {\n\t\tsk->sk_shutdown |= RCV_SHUTDOWN;\n\t\tif ((sk->sk_shutdown & how) == how)\n\t\t\tgoto shutdown_matched;\n\t}\n\n\tsk->sk_shutdown |= SEND_SHUTDOWN;\n\trelease_sock(sk);\n\n\tl2cap_chan_lock(chan);\n\tconn = chan->conn;\n\tif (conn)\n\t\t/* prevent conn structure from being freed */\n\t\tl2cap_conn_get(conn);\n\tl2cap_chan_unlock(chan);\n\n\tif (conn)\n\t\t/* mutex lock must be taken before l2cap_chan_lock() */\n\t\tmutex_lock(&conn->chan_lock);\n\n\tl2cap_chan_lock(chan);\n\tl2cap_chan_close(chan, 0);\n\tl2cap_chan_unlock(chan);\n\n\tif (conn) {\n\t\tmutex_unlock(&conn->chan_lock);\n\t\tl2cap_conn_put(conn);\n\t}\n\n\tlock_sock(sk);\n\n\tif (sock_flag(sk, SOCK_LINGER) && sk->sk_lingertime &&\n\t    !(current->flags & PF_EXITING))\n\t\terr = bt_sock_wait_state(sk, BT_CLOSED,\n\t\t\t\t\t sk->sk_lingertime);\n\nshutdown_matched:\n\tl2cap_chan_put(chan);\n\tsock_put(sk);\n\nshutdown_already:\n\tif (!err && sk->sk_err)\n\t\terr = -sk->sk_err;\n\n\trelease_sock(sk);\n\n\tBT_DBG(\"Sock shutdown complete err: %d\", err);\n\n\treturn err;\n}\n\nstatic int l2cap_sock_release(struct socket *sock)\n{\n\tstruct sock *sk = sock->sk;\n\tint err;\n\tstruct l2cap_chan *chan;\n\n\tBT_DBG(\"sock %p, sk %p\", sock, sk);\n\n\tif (!sk)\n\t\treturn 0;\n\n\tbt_sock_unlink(&l2cap_sk_list, sk);\n\n\terr = l2cap_sock_shutdown(sock, SHUT_RDWR);\n\tchan = l2cap_pi(sk)->chan;\n\n\tl2cap_chan_hold(chan);\n\tl2cap_chan_lock(chan);\n\n\tsock_orphan(sk);\n\tl2cap_sock_kill(sk);\n\n\tl2cap_chan_unlock(chan);\n\tl2cap_chan_put(chan);\n\n\treturn err;\n}\n\nstatic void l2cap_sock_cleanup_listen(struct sock *parent)\n{\n\tstruct sock *sk;\n\n\tBT_DBG(\"parent %p state %s\", parent,\n\t       state_to_string(parent->sk_state));\n\n\t/* Close not yet accepted channels */\n\twhile ((sk = bt_accept_dequeue(parent, NULL))) {\n\t\tstruct l2cap_chan *chan = l2cap_pi(sk)->chan;\n\n\t\tBT_DBG(\"child chan %p state %s\", chan,\n\t\t       state_to_string(chan->state));\n\n\t\tl2cap_chan_hold(chan);\n\t\tl2cap_chan_lock(chan);\n\n\t\t__clear_chan_timer(chan);\n\t\tl2cap_chan_close(chan, ECONNRESET);\n\t\tl2cap_sock_kill(sk);\n\n\t\tl2cap_chan_unlock(chan);\n\t\tl2cap_chan_put(chan);\n\t}\n}\n\nstatic struct l2cap_chan *l2cap_sock_new_connection_cb(struct l2cap_chan *chan)\n{\n\tstruct sock *sk, *parent = chan->data;\n\n\tlock_sock(parent);\n\n\t/* Check for backlog size */\n\tif (sk_acceptq_is_full(parent)) {\n\t\tBT_DBG(\"backlog full %d\", parent->sk_ack_backlog);\n\t\trelease_sock(parent);\n\t\treturn NULL;\n\t}\n\n\tsk = l2cap_sock_alloc(sock_net(parent), NULL, BTPROTO_L2CAP,\n\t\t\t      GFP_ATOMIC, 0);\n\tif (!sk) {\n\t\trelease_sock(parent);\n\t\treturn NULL;\n        }\n\n\tbt_sock_reclassify_lock(sk, BTPROTO_L2CAP);\n\n\tl2cap_sock_init(sk, parent);\n\n\tbt_accept_enqueue(parent, sk, false);\n\n\trelease_sock(parent);\n\n\treturn l2cap_pi(sk)->chan;\n}\n\nstatic int l2cap_sock_recv_cb(struct l2cap_chan *chan, struct sk_buff *skb)\n{\n\tstruct sock *sk = chan->data;\n\tint err;\n\n\tlock_sock(sk);\n\n\tif (l2cap_pi(sk)->rx_busy_skb) {\n\t\terr = -ENOMEM;\n\t\tgoto done;\n\t}\n\n\tif (chan->mode != L2CAP_MODE_ERTM &&\n\t    chan->mode != L2CAP_MODE_STREAMING) {\n\t\t/* Even if no filter is attached, we could potentially\n\t\t * get errors from security modules, etc.\n\t\t */\n\t\terr = sk_filter(sk, skb);\n\t\tif (err)\n\t\t\tgoto done;\n\t}\n\n\terr = __sock_queue_rcv_skb(sk, skb);\n\n\t/* For ERTM, handle one skb that doesn't fit into the recv\n\t * buffer.  This is important to do because the data frames\n\t * have already been acked, so the skb cannot be discarded.\n\t *\n\t * Notify the l2cap core that the buffer is full, so the\n\t * LOCAL_BUSY state is entered and no more frames are\n\t * acked and reassembled until there is buffer space\n\t * available.\n\t */\n\tif (err < 0 && chan->mode == L2CAP_MODE_ERTM) {\n\t\tl2cap_pi(sk)->rx_busy_skb = skb;\n\t\tl2cap_chan_busy(chan, 1);\n\t\terr = 0;\n\t}\n\ndone:\n\trelease_sock(sk);\n\n\treturn err;\n}\n\nstatic void l2cap_sock_close_cb(struct l2cap_chan *chan)\n{\n\tstruct sock *sk = chan->data;\n\n\tif (!sk)\n\t\treturn;\n\n\tl2cap_sock_kill(sk);\n}\n\nstatic void l2cap_sock_teardown_cb(struct l2cap_chan *chan, int err)\n{\n\tstruct sock *sk = chan->data;\n\tstruct sock *parent;\n\n\tif (!sk)\n\t\treturn;\n\n\tBT_DBG(\"chan %p state %s\", chan, state_to_string(chan->state));\n\n\t/* This callback can be called both for server (BT_LISTEN)\n\t * sockets as well as \"normal\" ones. To avoid lockdep warnings\n\t * with child socket locking (through l2cap_sock_cleanup_listen)\n\t * we need separation into separate nesting levels. The simplest\n\t * way to accomplish this is to inherit the nesting level used\n\t * for the channel.\n\t */\n\tlock_sock_nested(sk, atomic_read(&chan->nesting));\n\n\tparent = bt_sk(sk)->parent;\n\n\tswitch (chan->state) {\n\tcase BT_OPEN:\n\tcase BT_BOUND:\n\tcase BT_CLOSED:\n\t\tbreak;\n\tcase BT_LISTEN:\n\t\tl2cap_sock_cleanup_listen(sk);\n\t\tsk->sk_state = BT_CLOSED;\n\t\tchan->state = BT_CLOSED;\n\n\t\tbreak;\n\tdefault:\n\t\tsk->sk_state = BT_CLOSED;\n\t\tchan->state = BT_CLOSED;\n\n\t\tsk->sk_err = err;\n\n\t\tif (parent) {\n\t\t\tbt_accept_unlink(sk);\n\t\t\tparent->sk_data_ready(parent);\n\t\t} else {\n\t\t\tsk->sk_state_change(sk);\n\t\t}\n\n\t\tbreak;\n\t}\n\trelease_sock(sk);\n\n\t/* Only zap after cleanup to avoid use after free race */\n\tsock_set_flag(sk, SOCK_ZAPPED);\n\n}\n\nstatic void l2cap_sock_state_change_cb(struct l2cap_chan *chan, int state,\n\t\t\t\t       int err)\n{\n\tstruct sock *sk = chan->data;\n\n\tsk->sk_state = state;\n\n\tif (err)\n\t\tsk->sk_err = err;\n}\n\nstatic struct sk_buff *l2cap_sock_alloc_skb_cb(struct l2cap_chan *chan,\n\t\t\t\t\t       unsigned long hdr_len,\n\t\t\t\t\t       unsigned long len, int nb)\n{\n\tstruct sock *sk = chan->data;\n\tstruct sk_buff *skb;\n\tint err;\n\n\tl2cap_chan_unlock(chan);\n\tskb = bt_skb_send_alloc(sk, hdr_len + len, nb, &err);\n\tl2cap_chan_lock(chan);\n\n\tif (!skb)\n\t\treturn ERR_PTR(err);\n\n\t/* Channel lock is released before requesting new skb and then\n\t * reacquired thus we need to recheck channel state.\n\t */\n\tif (chan->state != BT_CONNECTED) {\n\t\tkfree_skb(skb);\n\t\treturn ERR_PTR(-ENOTCONN);\n\t}\n\n\tskb->priority = sk->sk_priority;\n\n\tbt_cb(skb)->l2cap.chan = chan;\n\n\treturn skb;\n}\n\nstatic void l2cap_sock_ready_cb(struct l2cap_chan *chan)\n{\n\tstruct sock *sk = chan->data;\n\tstruct sock *parent;\n\n\tlock_sock(sk);\n\n\tparent = bt_sk(sk)->parent;\n\n\tBT_DBG(\"sk %p, parent %p\", sk, parent);\n\n\tsk->sk_state = BT_CONNECTED;\n\tsk->sk_state_change(sk);\n\n\tif (parent)\n\t\tparent->sk_data_ready(parent);\n\n\trelease_sock(sk);\n}\n\nstatic void l2cap_sock_defer_cb(struct l2cap_chan *chan)\n{\n\tstruct sock *parent, *sk = chan->data;\n\n\tlock_sock(sk);\n\n\tparent = bt_sk(sk)->parent;\n\tif (parent)\n\t\tparent->sk_data_ready(parent);\n\n\trelease_sock(sk);\n}\n\nstatic void l2cap_sock_resume_cb(struct l2cap_chan *chan)\n{\n\tstruct sock *sk = chan->data;\n\n\tif (test_and_clear_bit(FLAG_PENDING_SECURITY, &chan->flags)) {\n\t\tsk->sk_state = BT_CONNECTED;\n\t\tchan->state = BT_CONNECTED;\n\t}\n\n\tclear_bit(BT_SK_SUSPEND, &bt_sk(sk)->flags);\n\tsk->sk_state_change(sk);\n}\n\nstatic void l2cap_sock_set_shutdown_cb(struct l2cap_chan *chan)\n{\n\tstruct sock *sk = chan->data;\n\n\tlock_sock(sk);\n\tsk->sk_shutdown = SHUTDOWN_MASK;\n\trelease_sock(sk);\n}\n\nstatic long l2cap_sock_get_sndtimeo_cb(struct l2cap_chan *chan)\n{\n\tstruct sock *sk = chan->data;\n\n\treturn sk->sk_sndtimeo;\n}\n\nstatic struct pid *l2cap_sock_get_peer_pid_cb(struct l2cap_chan *chan)\n{\n\tstruct sock *sk = chan->data;\n\n\treturn sk->sk_peer_pid;\n}\n\nstatic void l2cap_sock_suspend_cb(struct l2cap_chan *chan)\n{\n\tstruct sock *sk = chan->data;\n\n\tset_bit(BT_SK_SUSPEND, &bt_sk(sk)->flags);\n\tsk->sk_state_change(sk);\n}\n\nstatic int l2cap_sock_filter(struct l2cap_chan *chan, struct sk_buff *skb)\n{\n\tstruct sock *sk = chan->data;\n\n\tswitch (chan->mode) {\n\tcase L2CAP_MODE_ERTM:\n\tcase L2CAP_MODE_STREAMING:\n\t\treturn sk_filter(sk, skb);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct l2cap_ops l2cap_chan_ops = {\n\t.name\t\t\t= \"L2CAP Socket Interface\",\n\t.new_connection\t\t= l2cap_sock_new_connection_cb,\n\t.recv\t\t\t= l2cap_sock_recv_cb,\n\t.close\t\t\t= l2cap_sock_close_cb,\n\t.teardown\t\t= l2cap_sock_teardown_cb,\n\t.state_change\t\t= l2cap_sock_state_change_cb,\n\t.ready\t\t\t= l2cap_sock_ready_cb,\n\t.defer\t\t\t= l2cap_sock_defer_cb,\n\t.resume\t\t\t= l2cap_sock_resume_cb,\n\t.suspend\t\t= l2cap_sock_suspend_cb,\n\t.set_shutdown\t\t= l2cap_sock_set_shutdown_cb,\n\t.get_sndtimeo\t\t= l2cap_sock_get_sndtimeo_cb,\n\t.get_peer_pid\t\t= l2cap_sock_get_peer_pid_cb,\n\t.alloc_skb\t\t= l2cap_sock_alloc_skb_cb,\n\t.filter\t\t\t= l2cap_sock_filter,\n};\n\nstatic void l2cap_sock_destruct(struct sock *sk)\n{\n\tBT_DBG(\"sk %p\", sk);\n\n\tif (l2cap_pi(sk)->chan) {\n\t\tl2cap_pi(sk)->chan->data = NULL;\n\t\tl2cap_chan_put(l2cap_pi(sk)->chan);\n\t}\n\n\tif (l2cap_pi(sk)->rx_busy_skb) {\n\t\tkfree_skb(l2cap_pi(sk)->rx_busy_skb);\n\t\tl2cap_pi(sk)->rx_busy_skb = NULL;\n\t}\n\n\tskb_queue_purge(&sk->sk_receive_queue);\n\tskb_queue_purge(&sk->sk_write_queue);\n}\n\nstatic void l2cap_skb_msg_name(struct sk_buff *skb, void *msg_name,\n\t\t\t       int *msg_namelen)\n{\n\tDECLARE_SOCKADDR(struct sockaddr_l2 *, la, msg_name);\n\n\tmemset(la, 0, sizeof(struct sockaddr_l2));\n\tla->l2_family = AF_BLUETOOTH;\n\tla->l2_psm = bt_cb(skb)->l2cap.psm;\n\tbacpy(&la->l2_bdaddr, &bt_cb(skb)->l2cap.bdaddr);\n\n\t*msg_namelen = sizeof(struct sockaddr_l2);\n}\n\nstatic void l2cap_sock_init(struct sock *sk, struct sock *parent)\n{\n\tstruct l2cap_chan *chan = l2cap_pi(sk)->chan;\n\n\tBT_DBG(\"sk %p\", sk);\n\n\tif (parent) {\n\t\tstruct l2cap_chan *pchan = l2cap_pi(parent)->chan;\n\n\t\tsk->sk_type = parent->sk_type;\n\t\tbt_sk(sk)->flags = bt_sk(parent)->flags;\n\n\t\tchan->chan_type = pchan->chan_type;\n\t\tchan->imtu = pchan->imtu;\n\t\tchan->omtu = pchan->omtu;\n\t\tchan->conf_state = pchan->conf_state;\n\t\tchan->mode = pchan->mode;\n\t\tchan->fcs  = pchan->fcs;\n\t\tchan->max_tx = pchan->max_tx;\n\t\tchan->tx_win = pchan->tx_win;\n\t\tchan->tx_win_max = pchan->tx_win_max;\n\t\tchan->sec_level = pchan->sec_level;\n\t\tchan->flags = pchan->flags;\n\t\tchan->tx_credits = pchan->tx_credits;\n\t\tchan->rx_credits = pchan->rx_credits;\n\n\t\tif (chan->chan_type == L2CAP_CHAN_FIXED) {\n\t\t\tchan->scid = pchan->scid;\n\t\t\tchan->dcid = pchan->scid;\n\t\t}\n\n\t\tsecurity_sk_clone(parent, sk);\n\t} else {\n\t\tswitch (sk->sk_type) {\n\t\tcase SOCK_RAW:\n\t\t\tchan->chan_type = L2CAP_CHAN_RAW;\n\t\t\tbreak;\n\t\tcase SOCK_DGRAM:\n\t\t\tchan->chan_type = L2CAP_CHAN_CONN_LESS;\n\t\t\tbt_sk(sk)->skb_msg_name = l2cap_skb_msg_name;\n\t\t\tbreak;\n\t\tcase SOCK_SEQPACKET:\n\t\tcase SOCK_STREAM:\n\t\t\tchan->chan_type = L2CAP_CHAN_CONN_ORIENTED;\n\t\t\tbreak;\n\t\t}\n\n\t\tchan->imtu = L2CAP_DEFAULT_MTU;\n\t\tchan->omtu = 0;\n\t\tif (!disable_ertm && sk->sk_type == SOCK_STREAM) {\n\t\t\tchan->mode = L2CAP_MODE_ERTM;\n\t\t\tset_bit(CONF_STATE2_DEVICE, &chan->conf_state);\n\t\t} else {\n\t\t\tchan->mode = L2CAP_MODE_BASIC;\n\t\t}\n\n\t\tl2cap_chan_set_defaults(chan);\n\t}\n\n\t/* Default config options */\n\tchan->flush_to = L2CAP_DEFAULT_FLUSH_TO;\n\n\tchan->data = sk;\n\tchan->ops = &l2cap_chan_ops;\n}\n\nstatic struct proto l2cap_proto = {\n\t.name\t\t= \"L2CAP\",\n\t.owner\t\t= THIS_MODULE,\n\t.obj_size\t= sizeof(struct l2cap_pinfo)\n};\n\nstatic struct sock *l2cap_sock_alloc(struct net *net, struct socket *sock,\n\t\t\t\t     int proto, gfp_t prio, int kern)\n{\n\tstruct sock *sk;\n\tstruct l2cap_chan *chan;\n\n\tsk = sk_alloc(net, PF_BLUETOOTH, prio, &l2cap_proto, kern);\n\tif (!sk)\n\t\treturn NULL;\n\n\tsock_init_data(sock, sk);\n\tINIT_LIST_HEAD(&bt_sk(sk)->accept_q);\n\n\tsk->sk_destruct = l2cap_sock_destruct;\n\tsk->sk_sndtimeo = L2CAP_CONN_TIMEOUT;\n\n\tsock_reset_flag(sk, SOCK_ZAPPED);\n\n\tsk->sk_protocol = proto;\n\tsk->sk_state = BT_OPEN;\n\n\tchan = l2cap_chan_create();\n\tif (!chan) {\n\t\tsk_free(sk);\n\t\treturn NULL;\n\t}\n\n\tl2cap_chan_hold(chan);\n\n\tl2cap_pi(sk)->chan = chan;\n\n\treturn sk;\n}\n\nstatic int l2cap_sock_create(struct net *net, struct socket *sock, int protocol,\n\t\t\t     int kern)\n{\n\tstruct sock *sk;\n\n\tBT_DBG(\"sock %p\", sock);\n\n\tsock->state = SS_UNCONNECTED;\n\n\tif (sock->type != SOCK_SEQPACKET && sock->type != SOCK_STREAM &&\n\t    sock->type != SOCK_DGRAM && sock->type != SOCK_RAW)\n\t\treturn -ESOCKTNOSUPPORT;\n\n\tif (sock->type == SOCK_RAW && !kern && !capable(CAP_NET_RAW))\n\t\treturn -EPERM;\n\n\tsock->ops = &l2cap_sock_ops;\n\n\tsk = l2cap_sock_alloc(net, sock, protocol, GFP_ATOMIC, kern);\n\tif (!sk)\n\t\treturn -ENOMEM;\n\n\tl2cap_sock_init(sk, NULL);\n\tbt_sock_link(&l2cap_sk_list, sk);\n\treturn 0;\n}\n\nstatic const struct proto_ops l2cap_sock_ops = {\n\t.family\t\t= PF_BLUETOOTH,\n\t.owner\t\t= THIS_MODULE,\n\t.release\t= l2cap_sock_release,\n\t.bind\t\t= l2cap_sock_bind,\n\t.connect\t= l2cap_sock_connect,\n\t.listen\t\t= l2cap_sock_listen,\n\t.accept\t\t= l2cap_sock_accept,\n\t.getname\t= l2cap_sock_getname,\n\t.sendmsg\t= l2cap_sock_sendmsg,\n\t.recvmsg\t= l2cap_sock_recvmsg,\n\t.poll\t\t= bt_sock_poll,\n\t.ioctl\t\t= bt_sock_ioctl,\n\t.gettstamp\t= sock_gettstamp,\n\t.mmap\t\t= sock_no_mmap,\n\t.socketpair\t= sock_no_socketpair,\n\t.shutdown\t= l2cap_sock_shutdown,\n\t.setsockopt\t= l2cap_sock_setsockopt,\n\t.getsockopt\t= l2cap_sock_getsockopt\n};\n\nstatic const struct net_proto_family l2cap_sock_family_ops = {\n\t.family\t= PF_BLUETOOTH,\n\t.owner\t= THIS_MODULE,\n\t.create\t= l2cap_sock_create,\n};\n\nint __init l2cap_init_sockets(void)\n{\n\tint err;\n\n\tBUILD_BUG_ON(sizeof(struct sockaddr_l2) > sizeof(struct sockaddr));\n\n\terr = proto_register(&l2cap_proto, 0);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = bt_sock_register(BTPROTO_L2CAP, &l2cap_sock_family_ops);\n\tif (err < 0) {\n\t\tBT_ERR(\"L2CAP socket registration failed\");\n\t\tgoto error;\n\t}\n\n\terr = bt_procfs_init(&init_net, \"l2cap\", &l2cap_sk_list,\n\t\t\t     NULL);\n\tif (err < 0) {\n\t\tBT_ERR(\"Failed to create L2CAP proc file\");\n\t\tbt_sock_unregister(BTPROTO_L2CAP);\n\t\tgoto error;\n\t}\n\n\tBT_INFO(\"L2CAP socket layer initialized\");\n\n\treturn 0;\n\nerror:\n\tproto_unregister(&l2cap_proto);\n\treturn err;\n}\n\nvoid l2cap_cleanup_sockets(void)\n{\n\tbt_procfs_cleanup(&init_net, \"l2cap\");\n\tbt_sock_unregister(BTPROTO_L2CAP);\n\tproto_unregister(&l2cap_proto);\n}\n"], "fixing_code": ["/*\n   BlueZ - Bluetooth protocol stack for Linux\n   Copyright (C) 2000-2001 Qualcomm Incorporated\n   Copyright (C) 2009-2010 Gustavo F. Padovan <gustavo@padovan.org>\n   Copyright (C) 2010 Google Inc.\n   Copyright (C) 2011 ProFUSION Embedded Systems\n\n   Written 2000,2001 by Maxim Krasnyansky <maxk@qualcomm.com>\n\n   This program is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License version 2 as\n   published by the Free Software Foundation;\n\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS.\n   IN NO EVENT SHALL THE COPYRIGHT HOLDER(S) AND AUTHOR(S) BE LIABLE FOR ANY\n   CLAIM, OR ANY SPECIAL INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES\n   WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n   ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n   OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n\n   ALL LIABILITY, INCLUDING LIABILITY FOR INFRINGEMENT OF ANY PATENTS,\n   COPYRIGHTS, TRADEMARKS OR OTHER RIGHTS, RELATING TO USE OF THIS\n   SOFTWARE IS DISCLAIMED.\n*/\n\n/* Bluetooth L2CAP sockets. */\n\n#include <linux/module.h>\n#include <linux/export.h>\n#include <linux/filter.h>\n#include <linux/sched/signal.h>\n\n#include <net/bluetooth/bluetooth.h>\n#include <net/bluetooth/hci_core.h>\n#include <net/bluetooth/l2cap.h>\n\n#include \"smp.h\"\n\nstatic struct bt_sock_list l2cap_sk_list = {\n\t.lock = __RW_LOCK_UNLOCKED(l2cap_sk_list.lock)\n};\n\nstatic const struct proto_ops l2cap_sock_ops;\nstatic void l2cap_sock_init(struct sock *sk, struct sock *parent);\nstatic struct sock *l2cap_sock_alloc(struct net *net, struct socket *sock,\n\t\t\t\t     int proto, gfp_t prio, int kern);\nstatic void l2cap_sock_cleanup_listen(struct sock *parent);\n\nbool l2cap_is_socket(struct socket *sock)\n{\n\treturn sock && sock->ops == &l2cap_sock_ops;\n}\nEXPORT_SYMBOL(l2cap_is_socket);\n\nstatic int l2cap_validate_bredr_psm(u16 psm)\n{\n\t/* PSM must be odd and lsb of upper byte must be 0 */\n\tif ((psm & 0x0101) != 0x0001)\n\t\treturn -EINVAL;\n\n\t/* Restrict usage of well-known PSMs */\n\tif (psm < L2CAP_PSM_DYN_START && !capable(CAP_NET_BIND_SERVICE))\n\t\treturn -EACCES;\n\n\treturn 0;\n}\n\nstatic int l2cap_validate_le_psm(u16 psm)\n{\n\t/* Valid LE_PSM ranges are defined only until 0x00ff */\n\tif (psm > L2CAP_PSM_LE_DYN_END)\n\t\treturn -EINVAL;\n\n\t/* Restrict fixed, SIG assigned PSM values to CAP_NET_BIND_SERVICE */\n\tif (psm < L2CAP_PSM_LE_DYN_START && !capable(CAP_NET_BIND_SERVICE))\n\t\treturn -EACCES;\n\n\treturn 0;\n}\n\nstatic int l2cap_sock_bind(struct socket *sock, struct sockaddr *addr, int alen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct l2cap_chan *chan = l2cap_pi(sk)->chan;\n\tstruct sockaddr_l2 la;\n\tint len, err = 0;\n\n\tBT_DBG(\"sk %p\", sk);\n\n\tif (!addr || alen < offsetofend(struct sockaddr, sa_family) ||\n\t    addr->sa_family != AF_BLUETOOTH)\n\t\treturn -EINVAL;\n\n\tmemset(&la, 0, sizeof(la));\n\tlen = min_t(unsigned int, sizeof(la), alen);\n\tmemcpy(&la, addr, len);\n\n\tif (la.l2_cid && la.l2_psm)\n\t\treturn -EINVAL;\n\n\tif (!bdaddr_type_is_valid(la.l2_bdaddr_type))\n\t\treturn -EINVAL;\n\n\tif (bdaddr_type_is_le(la.l2_bdaddr_type)) {\n\t\t/* We only allow ATT user space socket */\n\t\tif (la.l2_cid &&\n\t\t    la.l2_cid != cpu_to_le16(L2CAP_CID_ATT))\n\t\t\treturn -EINVAL;\n\t}\n\n\tlock_sock(sk);\n\n\tif (sk->sk_state != BT_OPEN) {\n\t\terr = -EBADFD;\n\t\tgoto done;\n\t}\n\n\tif (la.l2_psm) {\n\t\t__u16 psm = __le16_to_cpu(la.l2_psm);\n\n\t\tif (la.l2_bdaddr_type == BDADDR_BREDR)\n\t\t\terr = l2cap_validate_bredr_psm(psm);\n\t\telse\n\t\t\terr = l2cap_validate_le_psm(psm);\n\n\t\tif (err)\n\t\t\tgoto done;\n\t}\n\n\tbacpy(&chan->src, &la.l2_bdaddr);\n\tchan->src_type = la.l2_bdaddr_type;\n\n\tif (la.l2_cid)\n\t\terr = l2cap_add_scid(chan, __le16_to_cpu(la.l2_cid));\n\telse\n\t\terr = l2cap_add_psm(chan, &la.l2_bdaddr, la.l2_psm);\n\n\tif (err < 0)\n\t\tgoto done;\n\n\tswitch (chan->chan_type) {\n\tcase L2CAP_CHAN_CONN_LESS:\n\t\tif (__le16_to_cpu(la.l2_psm) == L2CAP_PSM_3DSP)\n\t\t\tchan->sec_level = BT_SECURITY_SDP;\n\t\tbreak;\n\tcase L2CAP_CHAN_CONN_ORIENTED:\n\t\tif (__le16_to_cpu(la.l2_psm) == L2CAP_PSM_SDP ||\n\t\t    __le16_to_cpu(la.l2_psm) == L2CAP_PSM_RFCOMM)\n\t\t\tchan->sec_level = BT_SECURITY_SDP;\n\t\tbreak;\n\tcase L2CAP_CHAN_RAW:\n\t\tchan->sec_level = BT_SECURITY_SDP;\n\t\tbreak;\n\tcase L2CAP_CHAN_FIXED:\n\t\t/* Fixed channels default to the L2CAP core not holding a\n\t\t * hci_conn reference for them. For fixed channels mapping to\n\t\t * L2CAP sockets we do want to hold a reference so set the\n\t\t * appropriate flag to request it.\n\t\t */\n\t\tset_bit(FLAG_HOLD_HCI_CONN, &chan->flags);\n\t\tbreak;\n\t}\n\n\t/* Use L2CAP_MODE_LE_FLOWCTL (CoC) in case of LE address and\n\t * L2CAP_MODE_EXT_FLOWCTL (ECRED) has not been set.\n\t */\n\tif (chan->psm && bdaddr_type_is_le(chan->src_type) &&\n\t    chan->mode != L2CAP_MODE_EXT_FLOWCTL)\n\t\tchan->mode = L2CAP_MODE_LE_FLOWCTL;\n\n\tchan->state = BT_BOUND;\n\tsk->sk_state = BT_BOUND;\n\ndone:\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic void l2cap_sock_init_pid(struct sock *sk)\n{\n\tstruct l2cap_chan *chan = l2cap_pi(sk)->chan;\n\n\t/* Only L2CAP_MODE_EXT_FLOWCTL ever need to access the PID in order to\n\t * group the channels being requested.\n\t */\n\tif (chan->mode != L2CAP_MODE_EXT_FLOWCTL)\n\t\treturn;\n\n\tspin_lock(&sk->sk_peer_lock);\n\tsk->sk_peer_pid = get_pid(task_tgid(current));\n\tspin_unlock(&sk->sk_peer_lock);\n}\n\nstatic int l2cap_sock_connect(struct socket *sock, struct sockaddr *addr,\n\t\t\t      int alen, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct l2cap_chan *chan = l2cap_pi(sk)->chan;\n\tstruct sockaddr_l2 la;\n\tint len, err = 0;\n\tbool zapped;\n\n\tBT_DBG(\"sk %p\", sk);\n\n\tlock_sock(sk);\n\tzapped = sock_flag(sk, SOCK_ZAPPED);\n\trelease_sock(sk);\n\n\tif (zapped)\n\t\treturn -EINVAL;\n\n\tif (!addr || alen < offsetofend(struct sockaddr, sa_family) ||\n\t    addr->sa_family != AF_BLUETOOTH)\n\t\treturn -EINVAL;\n\n\tmemset(&la, 0, sizeof(la));\n\tlen = min_t(unsigned int, sizeof(la), alen);\n\tmemcpy(&la, addr, len);\n\n\tif (la.l2_cid && la.l2_psm)\n\t\treturn -EINVAL;\n\n\tif (!bdaddr_type_is_valid(la.l2_bdaddr_type))\n\t\treturn -EINVAL;\n\n\t/* Check that the socket wasn't bound to something that\n\t * conflicts with the address given to connect(). If chan->src\n\t * is BDADDR_ANY it means bind() was never used, in which case\n\t * chan->src_type and la.l2_bdaddr_type do not need to match.\n\t */\n\tif (chan->src_type == BDADDR_BREDR && bacmp(&chan->src, BDADDR_ANY) &&\n\t    bdaddr_type_is_le(la.l2_bdaddr_type)) {\n\t\t/* Old user space versions will try to incorrectly bind\n\t\t * the ATT socket using BDADDR_BREDR. We need to accept\n\t\t * this and fix up the source address type only when\n\t\t * both the source CID and destination CID indicate\n\t\t * ATT. Anything else is an invalid combination.\n\t\t */\n\t\tif (chan->scid != L2CAP_CID_ATT ||\n\t\t    la.l2_cid != cpu_to_le16(L2CAP_CID_ATT))\n\t\t\treturn -EINVAL;\n\n\t\t/* We don't have the hdev available here to make a\n\t\t * better decision on random vs public, but since all\n\t\t * user space versions that exhibit this issue anyway do\n\t\t * not support random local addresses assuming public\n\t\t * here is good enough.\n\t\t */\n\t\tchan->src_type = BDADDR_LE_PUBLIC;\n\t}\n\n\tif (chan->src_type != BDADDR_BREDR && la.l2_bdaddr_type == BDADDR_BREDR)\n\t\treturn -EINVAL;\n\n\tif (bdaddr_type_is_le(la.l2_bdaddr_type)) {\n\t\t/* We only allow ATT user space socket */\n\t\tif (la.l2_cid &&\n\t\t    la.l2_cid != cpu_to_le16(L2CAP_CID_ATT))\n\t\t\treturn -EINVAL;\n\t}\n\n\t/* Use L2CAP_MODE_LE_FLOWCTL (CoC) in case of LE address and\n\t * L2CAP_MODE_EXT_FLOWCTL (ECRED) has not been set.\n\t */\n\tif (chan->psm && bdaddr_type_is_le(chan->src_type) &&\n\t    chan->mode != L2CAP_MODE_EXT_FLOWCTL)\n\t\tchan->mode = L2CAP_MODE_LE_FLOWCTL;\n\n\tl2cap_sock_init_pid(sk);\n\n\terr = l2cap_chan_connect(chan, la.l2_psm, __le16_to_cpu(la.l2_cid),\n\t\t\t\t &la.l2_bdaddr, la.l2_bdaddr_type);\n\tif (err)\n\t\treturn err;\n\n\tlock_sock(sk);\n\n\terr = bt_sock_wait_state(sk, BT_CONNECTED,\n\t\t\t\t sock_sndtimeo(sk, flags & O_NONBLOCK));\n\n\trelease_sock(sk);\n\n\treturn err;\n}\n\nstatic int l2cap_sock_listen(struct socket *sock, int backlog)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct l2cap_chan *chan = l2cap_pi(sk)->chan;\n\tint err = 0;\n\n\tBT_DBG(\"sk %p backlog %d\", sk, backlog);\n\n\tlock_sock(sk);\n\n\tif (sk->sk_state != BT_BOUND) {\n\t\terr = -EBADFD;\n\t\tgoto done;\n\t}\n\n\tif (sk->sk_type != SOCK_SEQPACKET && sk->sk_type != SOCK_STREAM) {\n\t\terr = -EINVAL;\n\t\tgoto done;\n\t}\n\n\tswitch (chan->mode) {\n\tcase L2CAP_MODE_BASIC:\n\tcase L2CAP_MODE_LE_FLOWCTL:\n\t\tbreak;\n\tcase L2CAP_MODE_EXT_FLOWCTL:\n\t\tif (!enable_ecred) {\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto done;\n\t\t}\n\t\tbreak;\n\tcase L2CAP_MODE_ERTM:\n\tcase L2CAP_MODE_STREAMING:\n\t\tif (!disable_ertm)\n\t\t\tbreak;\n\t\tfallthrough;\n\tdefault:\n\t\terr = -EOPNOTSUPP;\n\t\tgoto done;\n\t}\n\n\tl2cap_sock_init_pid(sk);\n\n\tsk->sk_max_ack_backlog = backlog;\n\tsk->sk_ack_backlog = 0;\n\n\t/* Listening channels need to use nested locking in order not to\n\t * cause lockdep warnings when the created child channels end up\n\t * being locked in the same thread as the parent channel.\n\t */\n\tatomic_set(&chan->nesting, L2CAP_NESTING_PARENT);\n\n\tchan->state = BT_LISTEN;\n\tsk->sk_state = BT_LISTEN;\n\ndone:\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic int l2cap_sock_accept(struct socket *sock, struct socket *newsock,\n\t\t\t     int flags, bool kern)\n{\n\tDEFINE_WAIT_FUNC(wait, woken_wake_function);\n\tstruct sock *sk = sock->sk, *nsk;\n\tlong timeo;\n\tint err = 0;\n\n\tlock_sock_nested(sk, L2CAP_NESTING_PARENT);\n\n\ttimeo = sock_rcvtimeo(sk, flags & O_NONBLOCK);\n\n\tBT_DBG(\"sk %p timeo %ld\", sk, timeo);\n\n\t/* Wait for an incoming connection. (wake-one). */\n\tadd_wait_queue_exclusive(sk_sleep(sk), &wait);\n\twhile (1) {\n\t\tif (sk->sk_state != BT_LISTEN) {\n\t\t\terr = -EBADFD;\n\t\t\tbreak;\n\t\t}\n\n\t\tnsk = bt_accept_dequeue(sk, newsock);\n\t\tif (nsk)\n\t\t\tbreak;\n\n\t\tif (!timeo) {\n\t\t\terr = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (signal_pending(current)) {\n\t\t\terr = sock_intr_errno(timeo);\n\t\t\tbreak;\n\t\t}\n\n\t\trelease_sock(sk);\n\n\t\ttimeo = wait_woken(&wait, TASK_INTERRUPTIBLE, timeo);\n\n\t\tlock_sock_nested(sk, L2CAP_NESTING_PARENT);\n\t}\n\tremove_wait_queue(sk_sleep(sk), &wait);\n\n\tif (err)\n\t\tgoto done;\n\n\tnewsock->state = SS_CONNECTED;\n\n\tBT_DBG(\"new socket %p\", nsk);\n\ndone:\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic int l2cap_sock_getname(struct socket *sock, struct sockaddr *addr,\n\t\t\t      int peer)\n{\n\tstruct sockaddr_l2 *la = (struct sockaddr_l2 *) addr;\n\tstruct sock *sk = sock->sk;\n\tstruct l2cap_chan *chan = l2cap_pi(sk)->chan;\n\n\tBT_DBG(\"sock %p, sk %p\", sock, sk);\n\n\tif (peer && sk->sk_state != BT_CONNECTED &&\n\t    sk->sk_state != BT_CONNECT && sk->sk_state != BT_CONNECT2 &&\n\t    sk->sk_state != BT_CONFIG)\n\t\treturn -ENOTCONN;\n\n\tmemset(la, 0, sizeof(struct sockaddr_l2));\n\taddr->sa_family = AF_BLUETOOTH;\n\n\tla->l2_psm = chan->psm;\n\n\tif (peer) {\n\t\tbacpy(&la->l2_bdaddr, &chan->dst);\n\t\tla->l2_cid = cpu_to_le16(chan->dcid);\n\t\tla->l2_bdaddr_type = chan->dst_type;\n\t} else {\n\t\tbacpy(&la->l2_bdaddr, &chan->src);\n\t\tla->l2_cid = cpu_to_le16(chan->scid);\n\t\tla->l2_bdaddr_type = chan->src_type;\n\t}\n\n\treturn sizeof(struct sockaddr_l2);\n}\n\nstatic int l2cap_get_mode(struct l2cap_chan *chan)\n{\n\tswitch (chan->mode) {\n\tcase L2CAP_MODE_BASIC:\n\t\treturn BT_MODE_BASIC;\n\tcase L2CAP_MODE_ERTM:\n\t\treturn BT_MODE_ERTM;\n\tcase L2CAP_MODE_STREAMING:\n\t\treturn BT_MODE_STREAMING;\n\tcase L2CAP_MODE_LE_FLOWCTL:\n\t\treturn BT_MODE_LE_FLOWCTL;\n\tcase L2CAP_MODE_EXT_FLOWCTL:\n\t\treturn BT_MODE_EXT_FLOWCTL;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int l2cap_sock_getsockopt_old(struct socket *sock, int optname,\n\t\t\t\t     char __user *optval, int __user *optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct l2cap_chan *chan = l2cap_pi(sk)->chan;\n\tstruct l2cap_options opts;\n\tstruct l2cap_conninfo cinfo;\n\tint len, err = 0;\n\tu32 opt;\n\n\tBT_DBG(\"sk %p\", sk);\n\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\n\tlock_sock(sk);\n\n\tswitch (optname) {\n\tcase L2CAP_OPTIONS:\n\t\t/* LE sockets should use BT_SNDMTU/BT_RCVMTU, but since\n\t\t * legacy ATT code depends on getsockopt for\n\t\t * L2CAP_OPTIONS we need to let this pass.\n\t\t */\n\t\tif (bdaddr_type_is_le(chan->src_type) &&\n\t\t    chan->scid != L2CAP_CID_ATT) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Only BR/EDR modes are supported here */\n\t\tswitch (chan->mode) {\n\t\tcase L2CAP_MODE_BASIC:\n\t\tcase L2CAP_MODE_ERTM:\n\t\tcase L2CAP_MODE_STREAMING:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (err < 0)\n\t\t\tbreak;\n\n\t\tmemset(&opts, 0, sizeof(opts));\n\t\topts.imtu     = chan->imtu;\n\t\topts.omtu     = chan->omtu;\n\t\topts.flush_to = chan->flush_to;\n\t\topts.mode     = chan->mode;\n\t\topts.fcs      = chan->fcs;\n\t\topts.max_tx   = chan->max_tx;\n\t\topts.txwin_size = chan->tx_win;\n\n\t\tBT_DBG(\"mode 0x%2.2x\", chan->mode);\n\n\t\tlen = min_t(unsigned int, len, sizeof(opts));\n\t\tif (copy_to_user(optval, (char *) &opts, len))\n\t\t\terr = -EFAULT;\n\n\t\tbreak;\n\n\tcase L2CAP_LM:\n\t\tswitch (chan->sec_level) {\n\t\tcase BT_SECURITY_LOW:\n\t\t\topt = L2CAP_LM_AUTH;\n\t\t\tbreak;\n\t\tcase BT_SECURITY_MEDIUM:\n\t\t\topt = L2CAP_LM_AUTH | L2CAP_LM_ENCRYPT;\n\t\t\tbreak;\n\t\tcase BT_SECURITY_HIGH:\n\t\t\topt = L2CAP_LM_AUTH | L2CAP_LM_ENCRYPT |\n\t\t\t      L2CAP_LM_SECURE;\n\t\t\tbreak;\n\t\tcase BT_SECURITY_FIPS:\n\t\t\topt = L2CAP_LM_AUTH | L2CAP_LM_ENCRYPT |\n\t\t\t      L2CAP_LM_SECURE | L2CAP_LM_FIPS;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\topt = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (test_bit(FLAG_ROLE_SWITCH, &chan->flags))\n\t\t\topt |= L2CAP_LM_MASTER;\n\n\t\tif (test_bit(FLAG_FORCE_RELIABLE, &chan->flags))\n\t\t\topt |= L2CAP_LM_RELIABLE;\n\n\t\tif (put_user(opt, (u32 __user *) optval))\n\t\t\terr = -EFAULT;\n\n\t\tbreak;\n\n\tcase L2CAP_CONNINFO:\n\t\tif (sk->sk_state != BT_CONNECTED &&\n\t\t    !(sk->sk_state == BT_CONNECT2 &&\n\t\t      test_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags))) {\n\t\t\terr = -ENOTCONN;\n\t\t\tbreak;\n\t\t}\n\n\t\tmemset(&cinfo, 0, sizeof(cinfo));\n\t\tcinfo.hci_handle = chan->conn->hcon->handle;\n\t\tmemcpy(cinfo.dev_class, chan->conn->hcon->dev_class, 3);\n\n\t\tlen = min_t(unsigned int, len, sizeof(cinfo));\n\t\tif (copy_to_user(optval, (char *) &cinfo, len))\n\t\t\terr = -EFAULT;\n\n\t\tbreak;\n\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic int l2cap_sock_getsockopt(struct socket *sock, int level, int optname,\n\t\t\t\t char __user *optval, int __user *optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct l2cap_chan *chan = l2cap_pi(sk)->chan;\n\tstruct bt_security sec;\n\tstruct bt_power pwr;\n\tu32 phys;\n\tint len, mode, err = 0;\n\n\tBT_DBG(\"sk %p\", sk);\n\n\tif (level == SOL_L2CAP)\n\t\treturn l2cap_sock_getsockopt_old(sock, optname, optval, optlen);\n\n\tif (level != SOL_BLUETOOTH)\n\t\treturn -ENOPROTOOPT;\n\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\n\tlock_sock(sk);\n\n\tswitch (optname) {\n\tcase BT_SECURITY:\n\t\tif (chan->chan_type != L2CAP_CHAN_CONN_ORIENTED &&\n\t\t    chan->chan_type != L2CAP_CHAN_FIXED &&\n\t\t    chan->chan_type != L2CAP_CHAN_RAW) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tmemset(&sec, 0, sizeof(sec));\n\t\tif (chan->conn) {\n\t\t\tsec.level = chan->conn->hcon->sec_level;\n\n\t\t\tif (sk->sk_state == BT_CONNECTED)\n\t\t\t\tsec.key_size = chan->conn->hcon->enc_key_size;\n\t\t} else {\n\t\t\tsec.level = chan->sec_level;\n\t\t}\n\n\t\tlen = min_t(unsigned int, len, sizeof(sec));\n\t\tif (copy_to_user(optval, (char *) &sec, len))\n\t\t\terr = -EFAULT;\n\n\t\tbreak;\n\n\tcase BT_DEFER_SETUP:\n\t\tif (sk->sk_state != BT_BOUND && sk->sk_state != BT_LISTEN) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (put_user(test_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags),\n\t\t\t     (u32 __user *) optval))\n\t\t\terr = -EFAULT;\n\n\t\tbreak;\n\n\tcase BT_FLUSHABLE:\n\t\tif (put_user(test_bit(FLAG_FLUSHABLE, &chan->flags),\n\t\t\t     (u32 __user *) optval))\n\t\t\terr = -EFAULT;\n\n\t\tbreak;\n\n\tcase BT_POWER:\n\t\tif (sk->sk_type != SOCK_SEQPACKET && sk->sk_type != SOCK_STREAM\n\t\t    && sk->sk_type != SOCK_RAW) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tpwr.force_active = test_bit(FLAG_FORCE_ACTIVE, &chan->flags);\n\n\t\tlen = min_t(unsigned int, len, sizeof(pwr));\n\t\tif (copy_to_user(optval, (char *) &pwr, len))\n\t\t\terr = -EFAULT;\n\n\t\tbreak;\n\n\tcase BT_CHANNEL_POLICY:\n\t\tif (put_user(chan->chan_policy, (u32 __user *) optval))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\n\tcase BT_SNDMTU:\n\t\tif (!bdaddr_type_is_le(chan->src_type)) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (sk->sk_state != BT_CONNECTED) {\n\t\t\terr = -ENOTCONN;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (put_user(chan->omtu, (u16 __user *) optval))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\n\tcase BT_RCVMTU:\n\t\tif (!bdaddr_type_is_le(chan->src_type)) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (put_user(chan->imtu, (u16 __user *) optval))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\n\tcase BT_PHY:\n\t\tif (sk->sk_state != BT_CONNECTED) {\n\t\t\terr = -ENOTCONN;\n\t\t\tbreak;\n\t\t}\n\n\t\tphys = hci_conn_get_phy(chan->conn->hcon);\n\n\t\tif (put_user(phys, (u32 __user *) optval))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\n\tcase BT_MODE:\n\t\tif (!enable_ecred) {\n\t\t\terr = -ENOPROTOOPT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (chan->chan_type != L2CAP_CHAN_CONN_ORIENTED) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tmode = l2cap_get_mode(chan);\n\t\tif (mode < 0) {\n\t\t\terr = mode;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (put_user(mode, (u8 __user *) optval))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic bool l2cap_valid_mtu(struct l2cap_chan *chan, u16 mtu)\n{\n\tswitch (chan->scid) {\n\tcase L2CAP_CID_ATT:\n\t\tif (mtu < L2CAP_LE_MIN_MTU)\n\t\t\treturn false;\n\t\tbreak;\n\n\tdefault:\n\t\tif (mtu < L2CAP_DEFAULT_MIN_MTU)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic int l2cap_sock_setsockopt_old(struct socket *sock, int optname,\n\t\t\t\t     sockptr_t optval, unsigned int optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct l2cap_chan *chan = l2cap_pi(sk)->chan;\n\tstruct l2cap_options opts;\n\tint len, err = 0;\n\tu32 opt;\n\n\tBT_DBG(\"sk %p\", sk);\n\n\tlock_sock(sk);\n\n\tswitch (optname) {\n\tcase L2CAP_OPTIONS:\n\t\tif (bdaddr_type_is_le(chan->src_type)) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (sk->sk_state == BT_CONNECTED) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\topts.imtu     = chan->imtu;\n\t\topts.omtu     = chan->omtu;\n\t\topts.flush_to = chan->flush_to;\n\t\topts.mode     = chan->mode;\n\t\topts.fcs      = chan->fcs;\n\t\topts.max_tx   = chan->max_tx;\n\t\topts.txwin_size = chan->tx_win;\n\n\t\tlen = min_t(unsigned int, sizeof(opts), optlen);\n\t\tif (copy_from_sockptr(&opts, optval, len)) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (opts.txwin_size > L2CAP_DEFAULT_EXT_WINDOW) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!l2cap_valid_mtu(chan, opts.imtu)) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Only BR/EDR modes are supported here */\n\t\tswitch (opts.mode) {\n\t\tcase L2CAP_MODE_BASIC:\n\t\t\tclear_bit(CONF_STATE2_DEVICE, &chan->conf_state);\n\t\t\tbreak;\n\t\tcase L2CAP_MODE_ERTM:\n\t\tcase L2CAP_MODE_STREAMING:\n\t\t\tif (!disable_ertm)\n\t\t\t\tbreak;\n\t\t\tfallthrough;\n\t\tdefault:\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (err < 0)\n\t\t\tbreak;\n\n\t\tchan->mode = opts.mode;\n\n\t\tBT_DBG(\"mode 0x%2.2x\", chan->mode);\n\n\t\tchan->imtu = opts.imtu;\n\t\tchan->omtu = opts.omtu;\n\t\tchan->fcs  = opts.fcs;\n\t\tchan->max_tx = opts.max_tx;\n\t\tchan->tx_win = opts.txwin_size;\n\t\tchan->flush_to = opts.flush_to;\n\t\tbreak;\n\n\tcase L2CAP_LM:\n\t\tif (copy_from_sockptr(&opt, optval, sizeof(u32))) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (opt & L2CAP_LM_FIPS) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (opt & L2CAP_LM_AUTH)\n\t\t\tchan->sec_level = BT_SECURITY_LOW;\n\t\tif (opt & L2CAP_LM_ENCRYPT)\n\t\t\tchan->sec_level = BT_SECURITY_MEDIUM;\n\t\tif (opt & L2CAP_LM_SECURE)\n\t\t\tchan->sec_level = BT_SECURITY_HIGH;\n\n\t\tif (opt & L2CAP_LM_MASTER)\n\t\t\tset_bit(FLAG_ROLE_SWITCH, &chan->flags);\n\t\telse\n\t\t\tclear_bit(FLAG_ROLE_SWITCH, &chan->flags);\n\n\t\tif (opt & L2CAP_LM_RELIABLE)\n\t\t\tset_bit(FLAG_FORCE_RELIABLE, &chan->flags);\n\t\telse\n\t\t\tclear_bit(FLAG_FORCE_RELIABLE, &chan->flags);\n\t\tbreak;\n\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic int l2cap_set_mode(struct l2cap_chan *chan, u8 mode)\n{\n\tswitch (mode) {\n\tcase BT_MODE_BASIC:\n\t\tif (bdaddr_type_is_le(chan->src_type))\n\t\t\treturn -EINVAL;\n\t\tmode = L2CAP_MODE_BASIC;\n\t\tclear_bit(CONF_STATE2_DEVICE, &chan->conf_state);\n\t\tbreak;\n\tcase BT_MODE_ERTM:\n\t\tif (!disable_ertm || bdaddr_type_is_le(chan->src_type))\n\t\t\treturn -EINVAL;\n\t\tmode = L2CAP_MODE_ERTM;\n\t\tbreak;\n\tcase BT_MODE_STREAMING:\n\t\tif (!disable_ertm || bdaddr_type_is_le(chan->src_type))\n\t\t\treturn -EINVAL;\n\t\tmode = L2CAP_MODE_STREAMING;\n\t\tbreak;\n\tcase BT_MODE_LE_FLOWCTL:\n\t\tif (!bdaddr_type_is_le(chan->src_type))\n\t\t\treturn -EINVAL;\n\t\tmode = L2CAP_MODE_LE_FLOWCTL;\n\t\tbreak;\n\tcase BT_MODE_EXT_FLOWCTL:\n\t\t/* TODO: Add support for ECRED PDUs to BR/EDR */\n\t\tif (!bdaddr_type_is_le(chan->src_type))\n\t\t\treturn -EINVAL;\n\t\tmode = L2CAP_MODE_EXT_FLOWCTL;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tchan->mode = mode;\n\n\treturn 0;\n}\n\nstatic int l2cap_sock_setsockopt(struct socket *sock, int level, int optname,\n\t\t\t\t sockptr_t optval, unsigned int optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct l2cap_chan *chan = l2cap_pi(sk)->chan;\n\tstruct bt_security sec;\n\tstruct bt_power pwr;\n\tstruct l2cap_conn *conn;\n\tint len, err = 0;\n\tu32 opt;\n\tu16 mtu;\n\tu8 mode;\n\n\tBT_DBG(\"sk %p\", sk);\n\n\tif (level == SOL_L2CAP)\n\t\treturn l2cap_sock_setsockopt_old(sock, optname, optval, optlen);\n\n\tif (level != SOL_BLUETOOTH)\n\t\treturn -ENOPROTOOPT;\n\n\tlock_sock(sk);\n\n\tswitch (optname) {\n\tcase BT_SECURITY:\n\t\tif (chan->chan_type != L2CAP_CHAN_CONN_ORIENTED &&\n\t\t    chan->chan_type != L2CAP_CHAN_FIXED &&\n\t\t    chan->chan_type != L2CAP_CHAN_RAW) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tsec.level = BT_SECURITY_LOW;\n\n\t\tlen = min_t(unsigned int, sizeof(sec), optlen);\n\t\tif (copy_from_sockptr(&sec, optval, len)) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (sec.level < BT_SECURITY_LOW ||\n\t\t    sec.level > BT_SECURITY_FIPS) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tchan->sec_level = sec.level;\n\n\t\tif (!chan->conn)\n\t\t\tbreak;\n\n\t\tconn = chan->conn;\n\n\t\t/* change security for LE channels */\n\t\tif (chan->scid == L2CAP_CID_ATT) {\n\t\t\tif (smp_conn_security(conn->hcon, sec.level)) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tset_bit(FLAG_PENDING_SECURITY, &chan->flags);\n\t\t\tsk->sk_state = BT_CONFIG;\n\t\t\tchan->state = BT_CONFIG;\n\n\t\t/* or for ACL link */\n\t\t} else if ((sk->sk_state == BT_CONNECT2 &&\n\t\t\t    test_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags)) ||\n\t\t\t   sk->sk_state == BT_CONNECTED) {\n\t\t\tif (!l2cap_chan_check_security(chan, true))\n\t\t\t\tset_bit(BT_SK_SUSPEND, &bt_sk(sk)->flags);\n\t\t\telse\n\t\t\t\tsk->sk_state_change(sk);\n\t\t} else {\n\t\t\terr = -EINVAL;\n\t\t}\n\t\tbreak;\n\n\tcase BT_DEFER_SETUP:\n\t\tif (sk->sk_state != BT_BOUND && sk->sk_state != BT_LISTEN) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (copy_from_sockptr(&opt, optval, sizeof(u32))) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (opt) {\n\t\t\tset_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags);\n\t\t\tset_bit(FLAG_DEFER_SETUP, &chan->flags);\n\t\t} else {\n\t\t\tclear_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags);\n\t\t\tclear_bit(FLAG_DEFER_SETUP, &chan->flags);\n\t\t}\n\t\tbreak;\n\n\tcase BT_FLUSHABLE:\n\t\tif (copy_from_sockptr(&opt, optval, sizeof(u32))) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (opt > BT_FLUSHABLE_ON) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (opt == BT_FLUSHABLE_OFF) {\n\t\t\tconn = chan->conn;\n\t\t\t/* proceed further only when we have l2cap_conn and\n\t\t\t   No Flush support in the LM */\n\t\t\tif (!conn || !lmp_no_flush_capable(conn->hcon->hdev)) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (opt)\n\t\t\tset_bit(FLAG_FLUSHABLE, &chan->flags);\n\t\telse\n\t\t\tclear_bit(FLAG_FLUSHABLE, &chan->flags);\n\t\tbreak;\n\n\tcase BT_POWER:\n\t\tif (chan->chan_type != L2CAP_CHAN_CONN_ORIENTED &&\n\t\t    chan->chan_type != L2CAP_CHAN_RAW) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tpwr.force_active = BT_POWER_FORCE_ACTIVE_ON;\n\n\t\tlen = min_t(unsigned int, sizeof(pwr), optlen);\n\t\tif (copy_from_sockptr(&pwr, optval, len)) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (pwr.force_active)\n\t\t\tset_bit(FLAG_FORCE_ACTIVE, &chan->flags);\n\t\telse\n\t\t\tclear_bit(FLAG_FORCE_ACTIVE, &chan->flags);\n\t\tbreak;\n\n\tcase BT_CHANNEL_POLICY:\n\t\tif (copy_from_sockptr(&opt, optval, sizeof(u32))) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (opt > BT_CHANNEL_POLICY_AMP_PREFERRED) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (chan->mode != L2CAP_MODE_ERTM &&\n\t\t    chan->mode != L2CAP_MODE_STREAMING) {\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tbreak;\n\t\t}\n\n\t\tchan->chan_policy = (u8) opt;\n\n\t\tif (sk->sk_state == BT_CONNECTED &&\n\t\t    chan->move_role == L2CAP_MOVE_ROLE_NONE)\n\t\t\tl2cap_move_start(chan);\n\n\t\tbreak;\n\n\tcase BT_SNDMTU:\n\t\tif (!bdaddr_type_is_le(chan->src_type)) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Setting is not supported as it's the remote side that\n\t\t * decides this.\n\t\t */\n\t\terr = -EPERM;\n\t\tbreak;\n\n\tcase BT_RCVMTU:\n\t\tif (!bdaddr_type_is_le(chan->src_type)) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (chan->mode == L2CAP_MODE_LE_FLOWCTL &&\n\t\t    sk->sk_state == BT_CONNECTED) {\n\t\t\terr = -EISCONN;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (copy_from_sockptr(&mtu, optval, sizeof(u16))) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (chan->mode == L2CAP_MODE_EXT_FLOWCTL &&\n\t\t    sk->sk_state == BT_CONNECTED)\n\t\t\terr = l2cap_chan_reconfigure(chan, mtu);\n\t\telse\n\t\t\tchan->imtu = mtu;\n\n\t\tbreak;\n\n\tcase BT_MODE:\n\t\tif (!enable_ecred) {\n\t\t\terr = -ENOPROTOOPT;\n\t\t\tbreak;\n\t\t}\n\n\t\tBT_DBG(\"sk->sk_state %u\", sk->sk_state);\n\n\t\tif (sk->sk_state != BT_BOUND) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (chan->chan_type != L2CAP_CHAN_CONN_ORIENTED) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (copy_from_sockptr(&mode, optval, sizeof(u8))) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tBT_DBG(\"mode %u\", mode);\n\n\t\terr = l2cap_set_mode(chan, mode);\n\t\tif (err)\n\t\t\tbreak;\n\n\t\tBT_DBG(\"mode 0x%2.2x\", chan->mode);\n\n\t\tbreak;\n\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic int l2cap_sock_sendmsg(struct socket *sock, struct msghdr *msg,\n\t\t\t      size_t len)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct l2cap_chan *chan = l2cap_pi(sk)->chan;\n\tint err;\n\n\tBT_DBG(\"sock %p, sk %p\", sock, sk);\n\n\terr = sock_error(sk);\n\tif (err)\n\t\treturn err;\n\n\tif (msg->msg_flags & MSG_OOB)\n\t\treturn -EOPNOTSUPP;\n\n\tif (sk->sk_state != BT_CONNECTED)\n\t\treturn -ENOTCONN;\n\n\tlock_sock(sk);\n\terr = bt_sock_wait_ready(sk, msg->msg_flags);\n\trelease_sock(sk);\n\tif (err)\n\t\treturn err;\n\n\tl2cap_chan_lock(chan);\n\terr = l2cap_chan_send(chan, msg, len);\n\tl2cap_chan_unlock(chan);\n\n\treturn err;\n}\n\nstatic int l2cap_sock_recvmsg(struct socket *sock, struct msghdr *msg,\n\t\t\t      size_t len, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct l2cap_pinfo *pi = l2cap_pi(sk);\n\tint err;\n\n\tlock_sock(sk);\n\n\tif (sk->sk_state == BT_CONNECT2 && test_bit(BT_SK_DEFER_SETUP,\n\t\t\t\t\t\t    &bt_sk(sk)->flags)) {\n\t\tif (pi->chan->mode == L2CAP_MODE_EXT_FLOWCTL) {\n\t\t\tsk->sk_state = BT_CONNECTED;\n\t\t\tpi->chan->state = BT_CONNECTED;\n\t\t\t__l2cap_ecred_conn_rsp_defer(pi->chan);\n\t\t} else if (bdaddr_type_is_le(pi->chan->src_type)) {\n\t\t\tsk->sk_state = BT_CONNECTED;\n\t\t\tpi->chan->state = BT_CONNECTED;\n\t\t\t__l2cap_le_connect_rsp_defer(pi->chan);\n\t\t} else {\n\t\t\tsk->sk_state = BT_CONFIG;\n\t\t\tpi->chan->state = BT_CONFIG;\n\t\t\t__l2cap_connect_rsp_defer(pi->chan);\n\t\t}\n\n\t\terr = 0;\n\t\tgoto done;\n\t}\n\n\trelease_sock(sk);\n\n\tif (sock->type == SOCK_STREAM)\n\t\terr = bt_sock_stream_recvmsg(sock, msg, len, flags);\n\telse\n\t\terr = bt_sock_recvmsg(sock, msg, len, flags);\n\n\tif (pi->chan->mode != L2CAP_MODE_ERTM)\n\t\treturn err;\n\n\t/* Attempt to put pending rx data in the socket buffer */\n\n\tlock_sock(sk);\n\n\tif (!test_bit(CONN_LOCAL_BUSY, &pi->chan->conn_state))\n\t\tgoto done;\n\n\tif (pi->rx_busy_skb) {\n\t\tif (!__sock_queue_rcv_skb(sk, pi->rx_busy_skb))\n\t\t\tpi->rx_busy_skb = NULL;\n\t\telse\n\t\t\tgoto done;\n\t}\n\n\t/* Restore data flow when half of the receive buffer is\n\t * available.  This avoids resending large numbers of\n\t * frames.\n\t */\n\tif (atomic_read(&sk->sk_rmem_alloc) <= sk->sk_rcvbuf >> 1)\n\t\tl2cap_chan_busy(pi->chan, 0);\n\ndone:\n\trelease_sock(sk);\n\treturn err;\n}\n\n/* Kill socket (only if zapped and orphan)\n * Must be called on unlocked socket, with l2cap channel lock.\n */\nstatic void l2cap_sock_kill(struct sock *sk)\n{\n\tif (!sock_flag(sk, SOCK_ZAPPED) || sk->sk_socket)\n\t\treturn;\n\n\tBT_DBG(\"sk %p state %s\", sk, state_to_string(sk->sk_state));\n\n\t/* Kill poor orphan */\n\n\tl2cap_chan_put(l2cap_pi(sk)->chan);\n\tsock_set_flag(sk, SOCK_DEAD);\n\tsock_put(sk);\n}\n\nstatic int __l2cap_wait_ack(struct sock *sk, struct l2cap_chan *chan)\n{\n\tDECLARE_WAITQUEUE(wait, current);\n\tint err = 0;\n\tint timeo = L2CAP_WAIT_ACK_POLL_PERIOD;\n\t/* Timeout to prevent infinite loop */\n\tunsigned long timeout = jiffies + L2CAP_WAIT_ACK_TIMEOUT;\n\n\tadd_wait_queue(sk_sleep(sk), &wait);\n\tset_current_state(TASK_INTERRUPTIBLE);\n\tdo {\n\t\tBT_DBG(\"Waiting for %d ACKs, timeout %04d ms\",\n\t\t       chan->unacked_frames, time_after(jiffies, timeout) ? 0 :\n\t\t       jiffies_to_msecs(timeout - jiffies));\n\n\t\tif (!timeo)\n\t\t\ttimeo = L2CAP_WAIT_ACK_POLL_PERIOD;\n\n\t\tif (signal_pending(current)) {\n\t\t\terr = sock_intr_errno(timeo);\n\t\t\tbreak;\n\t\t}\n\n\t\trelease_sock(sk);\n\t\ttimeo = schedule_timeout(timeo);\n\t\tlock_sock(sk);\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\n\t\terr = sock_error(sk);\n\t\tif (err)\n\t\t\tbreak;\n\n\t\tif (time_after(jiffies, timeout)) {\n\t\t\terr = -ENOLINK;\n\t\t\tbreak;\n\t\t}\n\n\t} while (chan->unacked_frames > 0 &&\n\t\t chan->state == BT_CONNECTED);\n\n\tset_current_state(TASK_RUNNING);\n\tremove_wait_queue(sk_sleep(sk), &wait);\n\treturn err;\n}\n\nstatic int l2cap_sock_shutdown(struct socket *sock, int how)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct l2cap_chan *chan;\n\tstruct l2cap_conn *conn;\n\tint err = 0;\n\n\tBT_DBG(\"sock %p, sk %p, how %d\", sock, sk, how);\n\n\t/* 'how' parameter is mapped to sk_shutdown as follows:\n\t * SHUT_RD   (0) --> RCV_SHUTDOWN  (1)\n\t * SHUT_WR   (1) --> SEND_SHUTDOWN (2)\n\t * SHUT_RDWR (2) --> SHUTDOWN_MASK (3)\n\t */\n\thow++;\n\n\tif (!sk)\n\t\treturn 0;\n\n\tlock_sock(sk);\n\n\tif ((sk->sk_shutdown & how) == how)\n\t\tgoto shutdown_already;\n\n\tBT_DBG(\"Handling sock shutdown\");\n\n\t/* prevent sk structure from being freed whilst unlocked */\n\tsock_hold(sk);\n\n\tchan = l2cap_pi(sk)->chan;\n\t/* prevent chan structure from being freed whilst unlocked */\n\tl2cap_chan_hold(chan);\n\n\tBT_DBG(\"chan %p state %s\", chan, state_to_string(chan->state));\n\n\tif (chan->mode == L2CAP_MODE_ERTM &&\n\t    chan->unacked_frames > 0 &&\n\t    chan->state == BT_CONNECTED) {\n\t\terr = __l2cap_wait_ack(sk, chan);\n\n\t\t/* After waiting for ACKs, check whether shutdown\n\t\t * has already been actioned to close the L2CAP\n\t\t * link such as by l2cap_disconnection_req().\n\t\t */\n\t\tif ((sk->sk_shutdown & how) == how)\n\t\t\tgoto shutdown_matched;\n\t}\n\n\t/* Try setting the RCV_SHUTDOWN bit, return early if SEND_SHUTDOWN\n\t * is already set\n\t */\n\tif ((how & RCV_SHUTDOWN) && !(sk->sk_shutdown & RCV_SHUTDOWN)) {\n\t\tsk->sk_shutdown |= RCV_SHUTDOWN;\n\t\tif ((sk->sk_shutdown & how) == how)\n\t\t\tgoto shutdown_matched;\n\t}\n\n\tsk->sk_shutdown |= SEND_SHUTDOWN;\n\trelease_sock(sk);\n\n\tl2cap_chan_lock(chan);\n\tconn = chan->conn;\n\tif (conn)\n\t\t/* prevent conn structure from being freed */\n\t\tl2cap_conn_get(conn);\n\tl2cap_chan_unlock(chan);\n\n\tif (conn)\n\t\t/* mutex lock must be taken before l2cap_chan_lock() */\n\t\tmutex_lock(&conn->chan_lock);\n\n\tl2cap_chan_lock(chan);\n\tl2cap_chan_close(chan, 0);\n\tl2cap_chan_unlock(chan);\n\n\tif (conn) {\n\t\tmutex_unlock(&conn->chan_lock);\n\t\tl2cap_conn_put(conn);\n\t}\n\n\tlock_sock(sk);\n\n\tif (sock_flag(sk, SOCK_LINGER) && sk->sk_lingertime &&\n\t    !(current->flags & PF_EXITING))\n\t\terr = bt_sock_wait_state(sk, BT_CLOSED,\n\t\t\t\t\t sk->sk_lingertime);\n\nshutdown_matched:\n\tl2cap_chan_put(chan);\n\tsock_put(sk);\n\nshutdown_already:\n\tif (!err && sk->sk_err)\n\t\terr = -sk->sk_err;\n\n\trelease_sock(sk);\n\n\tBT_DBG(\"Sock shutdown complete err: %d\", err);\n\n\treturn err;\n}\n\nstatic int l2cap_sock_release(struct socket *sock)\n{\n\tstruct sock *sk = sock->sk;\n\tint err;\n\tstruct l2cap_chan *chan;\n\n\tBT_DBG(\"sock %p, sk %p\", sock, sk);\n\n\tif (!sk)\n\t\treturn 0;\n\n\tl2cap_sock_cleanup_listen(sk);\n\tbt_sock_unlink(&l2cap_sk_list, sk);\n\n\terr = l2cap_sock_shutdown(sock, SHUT_RDWR);\n\tchan = l2cap_pi(sk)->chan;\n\n\tl2cap_chan_hold(chan);\n\tl2cap_chan_lock(chan);\n\n\tsock_orphan(sk);\n\tl2cap_sock_kill(sk);\n\n\tl2cap_chan_unlock(chan);\n\tl2cap_chan_put(chan);\n\n\treturn err;\n}\n\nstatic void l2cap_sock_cleanup_listen(struct sock *parent)\n{\n\tstruct sock *sk;\n\n\tBT_DBG(\"parent %p state %s\", parent,\n\t       state_to_string(parent->sk_state));\n\n\t/* Close not yet accepted channels */\n\twhile ((sk = bt_accept_dequeue(parent, NULL))) {\n\t\tstruct l2cap_chan *chan = l2cap_pi(sk)->chan;\n\n\t\tBT_DBG(\"child chan %p state %s\", chan,\n\t\t       state_to_string(chan->state));\n\n\t\tl2cap_chan_hold(chan);\n\t\tl2cap_chan_lock(chan);\n\n\t\t__clear_chan_timer(chan);\n\t\tl2cap_chan_close(chan, ECONNRESET);\n\t\tl2cap_sock_kill(sk);\n\n\t\tl2cap_chan_unlock(chan);\n\t\tl2cap_chan_put(chan);\n\t}\n}\n\nstatic struct l2cap_chan *l2cap_sock_new_connection_cb(struct l2cap_chan *chan)\n{\n\tstruct sock *sk, *parent = chan->data;\n\n\tlock_sock(parent);\n\n\t/* Check for backlog size */\n\tif (sk_acceptq_is_full(parent)) {\n\t\tBT_DBG(\"backlog full %d\", parent->sk_ack_backlog);\n\t\trelease_sock(parent);\n\t\treturn NULL;\n\t}\n\n\tsk = l2cap_sock_alloc(sock_net(parent), NULL, BTPROTO_L2CAP,\n\t\t\t      GFP_ATOMIC, 0);\n\tif (!sk) {\n\t\trelease_sock(parent);\n\t\treturn NULL;\n        }\n\n\tbt_sock_reclassify_lock(sk, BTPROTO_L2CAP);\n\n\tl2cap_sock_init(sk, parent);\n\n\tbt_accept_enqueue(parent, sk, false);\n\n\trelease_sock(parent);\n\n\treturn l2cap_pi(sk)->chan;\n}\n\nstatic int l2cap_sock_recv_cb(struct l2cap_chan *chan, struct sk_buff *skb)\n{\n\tstruct sock *sk = chan->data;\n\tint err;\n\n\tlock_sock(sk);\n\n\tif (l2cap_pi(sk)->rx_busy_skb) {\n\t\terr = -ENOMEM;\n\t\tgoto done;\n\t}\n\n\tif (chan->mode != L2CAP_MODE_ERTM &&\n\t    chan->mode != L2CAP_MODE_STREAMING) {\n\t\t/* Even if no filter is attached, we could potentially\n\t\t * get errors from security modules, etc.\n\t\t */\n\t\terr = sk_filter(sk, skb);\n\t\tif (err)\n\t\t\tgoto done;\n\t}\n\n\terr = __sock_queue_rcv_skb(sk, skb);\n\n\t/* For ERTM, handle one skb that doesn't fit into the recv\n\t * buffer.  This is important to do because the data frames\n\t * have already been acked, so the skb cannot be discarded.\n\t *\n\t * Notify the l2cap core that the buffer is full, so the\n\t * LOCAL_BUSY state is entered and no more frames are\n\t * acked and reassembled until there is buffer space\n\t * available.\n\t */\n\tif (err < 0 && chan->mode == L2CAP_MODE_ERTM) {\n\t\tl2cap_pi(sk)->rx_busy_skb = skb;\n\t\tl2cap_chan_busy(chan, 1);\n\t\terr = 0;\n\t}\n\ndone:\n\trelease_sock(sk);\n\n\treturn err;\n}\n\nstatic void l2cap_sock_close_cb(struct l2cap_chan *chan)\n{\n\tstruct sock *sk = chan->data;\n\n\tif (!sk)\n\t\treturn;\n\n\tl2cap_sock_kill(sk);\n}\n\nstatic void l2cap_sock_teardown_cb(struct l2cap_chan *chan, int err)\n{\n\tstruct sock *sk = chan->data;\n\tstruct sock *parent;\n\n\tif (!sk)\n\t\treturn;\n\n\tBT_DBG(\"chan %p state %s\", chan, state_to_string(chan->state));\n\n\t/* This callback can be called both for server (BT_LISTEN)\n\t * sockets as well as \"normal\" ones. To avoid lockdep warnings\n\t * with child socket locking (through l2cap_sock_cleanup_listen)\n\t * we need separation into separate nesting levels. The simplest\n\t * way to accomplish this is to inherit the nesting level used\n\t * for the channel.\n\t */\n\tlock_sock_nested(sk, atomic_read(&chan->nesting));\n\n\tparent = bt_sk(sk)->parent;\n\n\tswitch (chan->state) {\n\tcase BT_OPEN:\n\tcase BT_BOUND:\n\tcase BT_CLOSED:\n\t\tbreak;\n\tcase BT_LISTEN:\n\t\tl2cap_sock_cleanup_listen(sk);\n\t\tsk->sk_state = BT_CLOSED;\n\t\tchan->state = BT_CLOSED;\n\n\t\tbreak;\n\tdefault:\n\t\tsk->sk_state = BT_CLOSED;\n\t\tchan->state = BT_CLOSED;\n\n\t\tsk->sk_err = err;\n\n\t\tif (parent) {\n\t\t\tbt_accept_unlink(sk);\n\t\t\tparent->sk_data_ready(parent);\n\t\t} else {\n\t\t\tsk->sk_state_change(sk);\n\t\t}\n\n\t\tbreak;\n\t}\n\trelease_sock(sk);\n\n\t/* Only zap after cleanup to avoid use after free race */\n\tsock_set_flag(sk, SOCK_ZAPPED);\n\n}\n\nstatic void l2cap_sock_state_change_cb(struct l2cap_chan *chan, int state,\n\t\t\t\t       int err)\n{\n\tstruct sock *sk = chan->data;\n\n\tsk->sk_state = state;\n\n\tif (err)\n\t\tsk->sk_err = err;\n}\n\nstatic struct sk_buff *l2cap_sock_alloc_skb_cb(struct l2cap_chan *chan,\n\t\t\t\t\t       unsigned long hdr_len,\n\t\t\t\t\t       unsigned long len, int nb)\n{\n\tstruct sock *sk = chan->data;\n\tstruct sk_buff *skb;\n\tint err;\n\n\tl2cap_chan_unlock(chan);\n\tskb = bt_skb_send_alloc(sk, hdr_len + len, nb, &err);\n\tl2cap_chan_lock(chan);\n\n\tif (!skb)\n\t\treturn ERR_PTR(err);\n\n\t/* Channel lock is released before requesting new skb and then\n\t * reacquired thus we need to recheck channel state.\n\t */\n\tif (chan->state != BT_CONNECTED) {\n\t\tkfree_skb(skb);\n\t\treturn ERR_PTR(-ENOTCONN);\n\t}\n\n\tskb->priority = sk->sk_priority;\n\n\tbt_cb(skb)->l2cap.chan = chan;\n\n\treturn skb;\n}\n\nstatic void l2cap_sock_ready_cb(struct l2cap_chan *chan)\n{\n\tstruct sock *sk = chan->data;\n\tstruct sock *parent;\n\n\tlock_sock(sk);\n\n\tparent = bt_sk(sk)->parent;\n\n\tBT_DBG(\"sk %p, parent %p\", sk, parent);\n\n\tsk->sk_state = BT_CONNECTED;\n\tsk->sk_state_change(sk);\n\n\tif (parent)\n\t\tparent->sk_data_ready(parent);\n\n\trelease_sock(sk);\n}\n\nstatic void l2cap_sock_defer_cb(struct l2cap_chan *chan)\n{\n\tstruct sock *parent, *sk = chan->data;\n\n\tlock_sock(sk);\n\n\tparent = bt_sk(sk)->parent;\n\tif (parent)\n\t\tparent->sk_data_ready(parent);\n\n\trelease_sock(sk);\n}\n\nstatic void l2cap_sock_resume_cb(struct l2cap_chan *chan)\n{\n\tstruct sock *sk = chan->data;\n\n\tif (test_and_clear_bit(FLAG_PENDING_SECURITY, &chan->flags)) {\n\t\tsk->sk_state = BT_CONNECTED;\n\t\tchan->state = BT_CONNECTED;\n\t}\n\n\tclear_bit(BT_SK_SUSPEND, &bt_sk(sk)->flags);\n\tsk->sk_state_change(sk);\n}\n\nstatic void l2cap_sock_set_shutdown_cb(struct l2cap_chan *chan)\n{\n\tstruct sock *sk = chan->data;\n\n\tlock_sock(sk);\n\tsk->sk_shutdown = SHUTDOWN_MASK;\n\trelease_sock(sk);\n}\n\nstatic long l2cap_sock_get_sndtimeo_cb(struct l2cap_chan *chan)\n{\n\tstruct sock *sk = chan->data;\n\n\treturn sk->sk_sndtimeo;\n}\n\nstatic struct pid *l2cap_sock_get_peer_pid_cb(struct l2cap_chan *chan)\n{\n\tstruct sock *sk = chan->data;\n\n\treturn sk->sk_peer_pid;\n}\n\nstatic void l2cap_sock_suspend_cb(struct l2cap_chan *chan)\n{\n\tstruct sock *sk = chan->data;\n\n\tset_bit(BT_SK_SUSPEND, &bt_sk(sk)->flags);\n\tsk->sk_state_change(sk);\n}\n\nstatic int l2cap_sock_filter(struct l2cap_chan *chan, struct sk_buff *skb)\n{\n\tstruct sock *sk = chan->data;\n\n\tswitch (chan->mode) {\n\tcase L2CAP_MODE_ERTM:\n\tcase L2CAP_MODE_STREAMING:\n\t\treturn sk_filter(sk, skb);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct l2cap_ops l2cap_chan_ops = {\n\t.name\t\t\t= \"L2CAP Socket Interface\",\n\t.new_connection\t\t= l2cap_sock_new_connection_cb,\n\t.recv\t\t\t= l2cap_sock_recv_cb,\n\t.close\t\t\t= l2cap_sock_close_cb,\n\t.teardown\t\t= l2cap_sock_teardown_cb,\n\t.state_change\t\t= l2cap_sock_state_change_cb,\n\t.ready\t\t\t= l2cap_sock_ready_cb,\n\t.defer\t\t\t= l2cap_sock_defer_cb,\n\t.resume\t\t\t= l2cap_sock_resume_cb,\n\t.suspend\t\t= l2cap_sock_suspend_cb,\n\t.set_shutdown\t\t= l2cap_sock_set_shutdown_cb,\n\t.get_sndtimeo\t\t= l2cap_sock_get_sndtimeo_cb,\n\t.get_peer_pid\t\t= l2cap_sock_get_peer_pid_cb,\n\t.alloc_skb\t\t= l2cap_sock_alloc_skb_cb,\n\t.filter\t\t\t= l2cap_sock_filter,\n};\n\nstatic void l2cap_sock_destruct(struct sock *sk)\n{\n\tBT_DBG(\"sk %p\", sk);\n\n\tif (l2cap_pi(sk)->chan) {\n\t\tl2cap_pi(sk)->chan->data = NULL;\n\t\tl2cap_chan_put(l2cap_pi(sk)->chan);\n\t}\n\n\tif (l2cap_pi(sk)->rx_busy_skb) {\n\t\tkfree_skb(l2cap_pi(sk)->rx_busy_skb);\n\t\tl2cap_pi(sk)->rx_busy_skb = NULL;\n\t}\n\n\tskb_queue_purge(&sk->sk_receive_queue);\n\tskb_queue_purge(&sk->sk_write_queue);\n}\n\nstatic void l2cap_skb_msg_name(struct sk_buff *skb, void *msg_name,\n\t\t\t       int *msg_namelen)\n{\n\tDECLARE_SOCKADDR(struct sockaddr_l2 *, la, msg_name);\n\n\tmemset(la, 0, sizeof(struct sockaddr_l2));\n\tla->l2_family = AF_BLUETOOTH;\n\tla->l2_psm = bt_cb(skb)->l2cap.psm;\n\tbacpy(&la->l2_bdaddr, &bt_cb(skb)->l2cap.bdaddr);\n\n\t*msg_namelen = sizeof(struct sockaddr_l2);\n}\n\nstatic void l2cap_sock_init(struct sock *sk, struct sock *parent)\n{\n\tstruct l2cap_chan *chan = l2cap_pi(sk)->chan;\n\n\tBT_DBG(\"sk %p\", sk);\n\n\tif (parent) {\n\t\tstruct l2cap_chan *pchan = l2cap_pi(parent)->chan;\n\n\t\tsk->sk_type = parent->sk_type;\n\t\tbt_sk(sk)->flags = bt_sk(parent)->flags;\n\n\t\tchan->chan_type = pchan->chan_type;\n\t\tchan->imtu = pchan->imtu;\n\t\tchan->omtu = pchan->omtu;\n\t\tchan->conf_state = pchan->conf_state;\n\t\tchan->mode = pchan->mode;\n\t\tchan->fcs  = pchan->fcs;\n\t\tchan->max_tx = pchan->max_tx;\n\t\tchan->tx_win = pchan->tx_win;\n\t\tchan->tx_win_max = pchan->tx_win_max;\n\t\tchan->sec_level = pchan->sec_level;\n\t\tchan->flags = pchan->flags;\n\t\tchan->tx_credits = pchan->tx_credits;\n\t\tchan->rx_credits = pchan->rx_credits;\n\n\t\tif (chan->chan_type == L2CAP_CHAN_FIXED) {\n\t\t\tchan->scid = pchan->scid;\n\t\t\tchan->dcid = pchan->scid;\n\t\t}\n\n\t\tsecurity_sk_clone(parent, sk);\n\t} else {\n\t\tswitch (sk->sk_type) {\n\t\tcase SOCK_RAW:\n\t\t\tchan->chan_type = L2CAP_CHAN_RAW;\n\t\t\tbreak;\n\t\tcase SOCK_DGRAM:\n\t\t\tchan->chan_type = L2CAP_CHAN_CONN_LESS;\n\t\t\tbt_sk(sk)->skb_msg_name = l2cap_skb_msg_name;\n\t\t\tbreak;\n\t\tcase SOCK_SEQPACKET:\n\t\tcase SOCK_STREAM:\n\t\t\tchan->chan_type = L2CAP_CHAN_CONN_ORIENTED;\n\t\t\tbreak;\n\t\t}\n\n\t\tchan->imtu = L2CAP_DEFAULT_MTU;\n\t\tchan->omtu = 0;\n\t\tif (!disable_ertm && sk->sk_type == SOCK_STREAM) {\n\t\t\tchan->mode = L2CAP_MODE_ERTM;\n\t\t\tset_bit(CONF_STATE2_DEVICE, &chan->conf_state);\n\t\t} else {\n\t\t\tchan->mode = L2CAP_MODE_BASIC;\n\t\t}\n\n\t\tl2cap_chan_set_defaults(chan);\n\t}\n\n\t/* Default config options */\n\tchan->flush_to = L2CAP_DEFAULT_FLUSH_TO;\n\n\tchan->data = sk;\n\tchan->ops = &l2cap_chan_ops;\n}\n\nstatic struct proto l2cap_proto = {\n\t.name\t\t= \"L2CAP\",\n\t.owner\t\t= THIS_MODULE,\n\t.obj_size\t= sizeof(struct l2cap_pinfo)\n};\n\nstatic struct sock *l2cap_sock_alloc(struct net *net, struct socket *sock,\n\t\t\t\t     int proto, gfp_t prio, int kern)\n{\n\tstruct sock *sk;\n\tstruct l2cap_chan *chan;\n\n\tsk = sk_alloc(net, PF_BLUETOOTH, prio, &l2cap_proto, kern);\n\tif (!sk)\n\t\treturn NULL;\n\n\tsock_init_data(sock, sk);\n\tINIT_LIST_HEAD(&bt_sk(sk)->accept_q);\n\n\tsk->sk_destruct = l2cap_sock_destruct;\n\tsk->sk_sndtimeo = L2CAP_CONN_TIMEOUT;\n\n\tsock_reset_flag(sk, SOCK_ZAPPED);\n\n\tsk->sk_protocol = proto;\n\tsk->sk_state = BT_OPEN;\n\n\tchan = l2cap_chan_create();\n\tif (!chan) {\n\t\tsk_free(sk);\n\t\treturn NULL;\n\t}\n\n\tl2cap_chan_hold(chan);\n\n\tl2cap_pi(sk)->chan = chan;\n\n\treturn sk;\n}\n\nstatic int l2cap_sock_create(struct net *net, struct socket *sock, int protocol,\n\t\t\t     int kern)\n{\n\tstruct sock *sk;\n\n\tBT_DBG(\"sock %p\", sock);\n\n\tsock->state = SS_UNCONNECTED;\n\n\tif (sock->type != SOCK_SEQPACKET && sock->type != SOCK_STREAM &&\n\t    sock->type != SOCK_DGRAM && sock->type != SOCK_RAW)\n\t\treturn -ESOCKTNOSUPPORT;\n\n\tif (sock->type == SOCK_RAW && !kern && !capable(CAP_NET_RAW))\n\t\treturn -EPERM;\n\n\tsock->ops = &l2cap_sock_ops;\n\n\tsk = l2cap_sock_alloc(net, sock, protocol, GFP_ATOMIC, kern);\n\tif (!sk)\n\t\treturn -ENOMEM;\n\n\tl2cap_sock_init(sk, NULL);\n\tbt_sock_link(&l2cap_sk_list, sk);\n\treturn 0;\n}\n\nstatic const struct proto_ops l2cap_sock_ops = {\n\t.family\t\t= PF_BLUETOOTH,\n\t.owner\t\t= THIS_MODULE,\n\t.release\t= l2cap_sock_release,\n\t.bind\t\t= l2cap_sock_bind,\n\t.connect\t= l2cap_sock_connect,\n\t.listen\t\t= l2cap_sock_listen,\n\t.accept\t\t= l2cap_sock_accept,\n\t.getname\t= l2cap_sock_getname,\n\t.sendmsg\t= l2cap_sock_sendmsg,\n\t.recvmsg\t= l2cap_sock_recvmsg,\n\t.poll\t\t= bt_sock_poll,\n\t.ioctl\t\t= bt_sock_ioctl,\n\t.gettstamp\t= sock_gettstamp,\n\t.mmap\t\t= sock_no_mmap,\n\t.socketpair\t= sock_no_socketpair,\n\t.shutdown\t= l2cap_sock_shutdown,\n\t.setsockopt\t= l2cap_sock_setsockopt,\n\t.getsockopt\t= l2cap_sock_getsockopt\n};\n\nstatic const struct net_proto_family l2cap_sock_family_ops = {\n\t.family\t= PF_BLUETOOTH,\n\t.owner\t= THIS_MODULE,\n\t.create\t= l2cap_sock_create,\n};\n\nint __init l2cap_init_sockets(void)\n{\n\tint err;\n\n\tBUILD_BUG_ON(sizeof(struct sockaddr_l2) > sizeof(struct sockaddr));\n\n\terr = proto_register(&l2cap_proto, 0);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = bt_sock_register(BTPROTO_L2CAP, &l2cap_sock_family_ops);\n\tif (err < 0) {\n\t\tBT_ERR(\"L2CAP socket registration failed\");\n\t\tgoto error;\n\t}\n\n\terr = bt_procfs_init(&init_net, \"l2cap\", &l2cap_sk_list,\n\t\t\t     NULL);\n\tif (err < 0) {\n\t\tBT_ERR(\"Failed to create L2CAP proc file\");\n\t\tbt_sock_unregister(BTPROTO_L2CAP);\n\t\tgoto error;\n\t}\n\n\tBT_INFO(\"L2CAP socket layer initialized\");\n\n\treturn 0;\n\nerror:\n\tproto_unregister(&l2cap_proto);\n\treturn err;\n}\n\nvoid l2cap_cleanup_sockets(void)\n{\n\tbt_procfs_cleanup(&init_net, \"l2cap\");\n\tbt_sock_unregister(BTPROTO_L2CAP);\n\tproto_unregister(&l2cap_proto);\n}\n"], "filenames": ["net/bluetooth/l2cap_sock.c"], "buggy_code_start_loc": [48], "buggy_code_end_loc": [1417], "fixing_code_start_loc": [49], "fixing_code_end_loc": [1420], "type": "CWE-416", "message": "An issue was discovered in l2cap_sock_release in net/bluetooth/l2cap_sock.c in the Linux kernel before 6.4.10. There is a use-after-free because the children of an sk are mishandled.", "other": {"cve": {"id": "CVE-2023-40283", "sourceIdentifier": "cve@mitre.org", "published": "2023-08-14T03:15:09.257", "lastModified": "2024-01-11T19:15:10.930", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "An issue was discovered in l2cap_sock_release in net/bluetooth/l2cap_sock.c in the Linux kernel before 6.4.10. There is a use-after-free because the children of an sk are mishandled."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-416"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "6.4.10", "matchCriteriaId": "C26BB101-2CAD-4F3C-9EE4-7865C5B8A1AA"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:11.0:*:*:*:*:*:*:*", "matchCriteriaId": "FA6FEEC2-9F11-4643-8827-749718254FED"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:12.0:*:*:*:*:*:*:*", "matchCriteriaId": "46D69DCC-AE4D-4EA5-861C-D60951444C6C"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:esm:*:*:*", "matchCriteriaId": "815D70A8-47D3-459C-A32C-9FEACA0659D1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:esm:*:*:*", "matchCriteriaId": "7A5301BF-1402-4BE0-A0F8-69FBE79BC6D6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:20.04:*:*:*:lts:*:*:*", "matchCriteriaId": "902B8056-9E37-443B-8905-8AA93E2447FB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:22.04:*:*:*:lts:*:*:*", "matchCriteriaId": "359012F1-2C63-415A-88B8-6726A87830DE"}]}]}], "references": [{"url": "http://packetstormsecurity.com/files/175072/Kernel-Live-Patch-Security-Notice-LSN-0098-1.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "http://packetstormsecurity.com/files/175963/Kernel-Live-Patch-Security-Notice-LSN-0099-1.html", "source": "cve@mitre.org"}, {"url": "https://cdn.kernel.org/pub/linux/kernel/v6.x/ChangeLog-6.4.10", "source": "cve@mitre.org", "tags": ["Release Notes"]}, {"url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=1728137b33c00d5a2b5110ed7aafb42e7c32e4a1", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/torvalds/linux/commit/1728137b33c00d5a2b5110ed7aafb42e7c32e4a1", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://lists.debian.org/debian-lts-announce/2023/10/msg00027.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2024/01/msg00004.html", "source": "cve@mitre.org"}, {"url": "https://security.netapp.com/advisory/ntap-20231020-0007/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2023/dsa-5480", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2023/dsa-5492", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/1728137b33c00d5a2b5110ed7aafb42e7c32e4a1"}}