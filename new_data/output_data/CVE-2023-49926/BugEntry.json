{"buggy_code": ["<?php\n    class EventTimelineTool\n    {\n        private $__lookupTables = array();\n        private $__user = false;\n        private $__json = array();\n        private $__eventModel = false;\n        private $__refModel = false;\n        # Will be use latter on\n        private $__related_events = array();\n        private $__related_attributes = array();\n        # Feature not implemented yet.\n        # This is to let user configure a polling frequency. The idea is that it's not because we don't have data during a specific period that it means it should be considered as positive (or fp).\n        # For example, if we poll every Monday. If it was positive on week 1 and negative on week 2, the timeline will show that it was positive until monday on week 2, which is most probably incorrect as it might be actually negative on Wednesday.\n        private $extrapolateWithPollingFrequency = false;\n\n        public function construct($eventModel, $user, $filterRules, $extended_view=0)\n        {\n            $this->__eventModel = $eventModel;\n            $this->__objectTemplateModel = $eventModel->Object->ObjectTemplate;\n            $this->__user = $user;\n            $this->__filterRules = $filterRules;\n            $this->__json = array();\n            $this->__extended_view = $extended_view;\n            $this->__lookupTables = array(\n                'analysisLevels' => $this->__eventModel->analysisLevels,\n                'distributionLevels' => $this->__eventModel->Attribute->distributionLevels\n            );\n            return true;\n        }\n\n        public function construct_for_ref($refModel, $user)\n        {\n            $this->__refModel = $refModel;\n            $this->__user = $user;\n            $this->__json = array();\n            return true;\n        }\n\n        private function __get_event($id)\n        {\n            $fullevent = $this->__eventModel->fetchEvent($this->__user, array('eventid' => $id, 'flatten' => 0, 'includeTagRelations' => 1, 'extended' => $this->__extended_view));\n            $event = array();\n            if (empty($fullevent)) {\n                return $event;\n            }\n\n            if (!empty($fullevent[0]['Object'])) {\n                $event['Object'] = $fullevent[0]['Object'];\n            } else {\n                $event['Object'] = array();\n            }\n\n            if (!empty($fullevent[0]['Attribute'])) {\n                $event['Attribute'] = $fullevent[0]['Attribute'];\n            } else {\n                $event['Attribute'] = array();\n            }\n\n            if (!empty($fullevent[0]['Sighting'])) {\n                $event['Sighting'] = $fullevent[0]['Sighting'];\n            } else {\n                $event['Sighting'] = array();\n            }\n\n            return $event;\n        }\n\n        public function get_timeline($id)\n        {\n            $event = $this->__get_event($id);\n            $this->__json['items'] = array();\n\n            if (empty($event)) {\n                return $this->__json;\n            }\n\n            if (!empty($event['Object'])) {\n                $object = $event['Object'];\n            } else {\n                $object = array();\n            }\n\n            if (!empty($event['Attribute'])) {\n                $attribute = $event['Attribute'];\n            } else {\n                $attribute = array();\n            }\n\n            $sightingsAttributeMap = [];\n            foreach ($event['Sighting'] as $sighting) {\n                $sightingsAttributeMap[$sighting['attribute_id']][] = $sighting['date_sighting'];\n            }\n\n            // extract links and node type\n            foreach ($attribute as $attr) {\n                $toPush = array(\n                    'id' => $attr['id'],\n                    'uuid' => $attr['uuid'],\n                    'content' => $attr['value'],\n                    'event_id' => $attr['event_id'],\n                    'group' => 'attribute',\n                    'timestamp' => $attr['timestamp'],\n                    'first_seen' => $attr['first_seen'],\n                    'last_seen' => $attr['last_seen'],\n                    'attribute_type' => $attr['type'],\n                    'date_sighting' => $sightingsAttributeMap[$attr['id']] ?? [],\n                    'is_image' => $this->__eventModel->Attribute->isImage($attr),\n                );\n                $this->__json['items'][] = $toPush;\n            }\n\n            foreach ($object as $obj) {\n                $toPush_obj = array(\n                    'id' => $obj['id'],\n                    'uuid' => $obj['uuid'],\n                    'content' => $obj['name'],\n                    'group' => 'object',\n                    'meta-category' => $obj['meta-category'],\n                    'template_uuid' => $obj['template_uuid'],\n                    'event_id' => $obj['event_id'],\n                    'timestamp' => $obj['timestamp'],\n                    'Attribute' => array(),\n                );\n\n                $toPush_obj['first_seen'] = $obj['first_seen'];\n                $toPush_obj['last_seen'] = $obj['last_seen'];\n                $toPush_obj['first_seen_overwrite'] = false;\n                $toPush_obj['last_seen_overwrite'] = false;\n\n                foreach ($obj['Attribute'] as $obj_attr) {\n                    // replaced *_seen based on object attribute\n                    if ($obj_attr['object_relation'] == 'first-seen' && is_null($toPush_obj['first_seen'])) {\n                        $toPush_obj['first_seen'] = $obj_attr['value']; // replace first_seen of the object to seen of the element\n                        $toPush_obj['first_seen_overwrite'] = true;\n                    } elseif ($obj_attr['object_relation'] == 'last-seen' && is_null($toPush_obj['last_seen'])) {\n                        $toPush_obj['last_seen'] = $obj_attr['value']; // replace last_seen of the object to seen of the element\n                        $toPush_obj['last_seen_overwrite'] = true;\n                    }\n                    $toPush_attr = array(\n                        'id' => $obj_attr['id'],\n                        'uuid' => $obj_attr['uuid'],\n                        'content' => $obj_attr['value'],\n                        'contentType' => $obj_attr['object_relation'],\n                        'event_id' => $obj_attr['event_id'],\n                        'group' => 'object_attribute',\n                        'timestamp' => $obj_attr['timestamp'],\n                        'attribute_type' => $obj_attr['type'],\n                        'date_sighting' => $sightingsAttributeMap[$attr['id']] ?? [],\n                        'is_image' => $this->__eventModel->Attribute->isImage($obj_attr),\n                    );\n                    $toPush_obj['Attribute'][] = $toPush_attr;\n                }\n                $this->__json['items'][] = $toPush_obj;\n            }\n\n            return $this->__json;\n        }\n\n        /*\n         * Extrapolation strategy:\n         *  - If only positive sightings: Will be from first to last sighting\n         *  - If both positive and false positive: False positive get priority. It will be marked as false positive until next positive sighting\n        */\n        public function get_sighting_timeline($id)\n        {\n            $event = $this->__eventModel->fetchEvent($this->__user, array(\n                'eventid' => $id,\n                'flatten' => 1,\n                'includeTagRelations' => 1,\n                'extended' => $this->__extended_view\n            ));\n            $this->__json['items'] = array();\n\n            if (empty($event)) {\n                return $this->__json;\n            } else {\n                $event = $event[0];\n            }\n\n            $lookupAttribute = array();\n            foreach ($event['Attribute'] as $k => $attribute) {\n                $lookupAttribute[$attribute['id']] = &$event['Attribute'][$k];\n            }\n\n            // regroup sightings per attribute\n            $regroupedSightings = array();\n            foreach ($event['Sighting'] as $k => $sighting) {\n                $event['Sighting'][$k]['date_sighting'] *= 1000; // adapt to use micro\n                $regroupedSightings[$sighting['attribute_id']][] = &$event['Sighting'][$k];\n            }\n            // generate extrapolation\n            $now = time()*1000;\n            foreach ($regroupedSightings as $attributeId => $sightings) {\n                usort($sightings, function ($a, $b) { // make sure sightings are ordered\n                    return $a['date_sighting'] > $b['date_sighting'];\n                });\n                $i = 0;\n                while ($i < count($sightings)) {\n                    $sighting = $sightings[$i];\n                    $attribute = $lookupAttribute[$attributeId];\n                    $fpSightingIndex = $this->getNextFalsePositiveSightingIndex($sightings, $i+1);\n                    $group = $sighting['type'] == '1' ? 'sighting_negative' : 'sighting_positive';\n                    if ($fpSightingIndex === false) { // No next FP, extrapolate to now\n                        $this->__json['items'][] = array(\n                            'attribute_id' => $attributeId,\n                            'id' => sprintf('%s-%s', $attributeId, $sighting['id']),\n                            'uuid' => $sighting['uuid'],\n                            'content' => $attribute['value'],\n                            'event_id' => $attribute['event_id'],\n                            'group' => $group,\n                            'timestamp' => $attribute['timestamp'],\n                            'first_seen' => $sighting['date_sighting'],\n                            'last_seen' => $now,\n                        );\n                        break;\n                    } else {\n                        // set up until last positive\n                        $pSightingIndex = $fpSightingIndex - 1;\n                        $halfTime = 0;\n                        if ($pSightingIndex == $i) {\n                            // we have only one positive sighting, thus the UP time should be take from a pooling frequence (feature not existing yet)\n                            // for now, consider it UP only for half the time until the next FP\n                            if ($this->extrapolateWithPollingFrequency) {\n                                $halfTime = ($sightings[$i+1]['date_sighting'] - $sighting['date_sighting'])/2;\n                            }\n                        }\n                        $pSighting = $sightings[$pSightingIndex];\n                        if ($this->extrapolateWithPollingFrequency) {\n                            $lastSeenPositive = $pSighting['date_sighting'] + $halfTime;\n                        } else {\n                            $lastSeenPositive = $sightings[$i+1]['date_sighting'];\n                        }\n                        $this->__json['items'][] = array(\n                            'attribute_id' => $attributeId,\n                            'id' => sprintf('%s-%s', $attributeId, $sighting['id']),\n                            'uuid' => $sighting['uuid'],\n                            'content' => $attribute['value'],\n                            'event_id' => $attribute['event_id'],\n                            'group' => 'sighting_positive',\n                            'timestamp' => $attribute['timestamp'],\n                            'first_seen' => $sighting['date_sighting'],\n                            'last_seen' => $lastSeenPositive,\n                        );\n                        // No next FP, extrapolate to now\n                        $fpSighting = $sightings[$fpSightingIndex];\n                        $secondNextPSightingIndex = $this->getNextPositiveSightingIndex($sightings, $fpSightingIndex+1);\n                        if ($secondNextPSightingIndex === false) { // No next P, extrapolate to now\n                            if ($this->extrapolateWithPollingFrequency) {\n                                $firstSeenNegative = $fpSighting['date_sighting'] - $halfTime;\n                            } else {\n                                $firstSeenNegative = $fpSighting['date_sighting'];\n                            }\n                            $this->__json['items'][] = array(\n                                'attribute_id' => $attributeId,\n                                'id' => sprintf('%s-%s', $attributeId, $sighting['id']),\n                                'uuid' => $fpSighting['uuid'],\n                                'content' => $attribute['value'],\n                                'event_id' => $attribute['event_id'],\n                                'group' => 'sighting_negative',\n                                'timestamp' => $attribute['timestamp'],\n                                'first_seen' => $firstSeenNegative,\n                                'last_seen' => $now,\n                            );\n                            break;\n                        } else {\n                            if ($halfTime > 0) { // We need to fake a previous P\n                                $pSightingIndex = $pSightingIndex+1;\n                                $pSighting = $sightings[$pSightingIndex];\n                            }\n                            if ($this->extrapolateWithPollingFrequency) {\n                                $firstSeenNegative = $fpSighting['date_sighting'] - $halfTime;\n                            } else {\n                                $firstSeenNegative = $fpSighting['date_sighting'];\n                            }\n                            // set down until next postive\n                            $secondNextPSighting = $sightings[$secondNextPSightingIndex];\n                            $this->__json['items'][] = array(\n                                'attribute_id' => $attributeId,\n                                'id' => sprintf('%s-%s', $attributeId, $sighting['id']),\n                                'uuid' => $fpSighting['uuid'],\n                                'content' => $attribute['value'],\n                                'event_id' => $attribute['event_id'],\n                                'group' => 'sighting_negative',\n                                'timestamp' => $attribute['timestamp'],\n                                'first_seen' => $firstSeenNegative,\n                                'last_seen' => $secondNextPSighting['date_sighting'],\n                            );\n                            $i = $secondNextPSightingIndex;\n                        }\n                    }\n                }\n            }\n            return $this->__json;\n        }\n\n        private function getNextFalsePositiveSightingIndex($sightings, $startIndex)\n        {\n            for ($i=$startIndex; $i < count($sightings) ; $i++) {\n                $sighting = $sightings[$i];\n                if ($sighting['type'] == 1) { // is false positive\n                    return $i;\n                }\n            }\n            return false;\n        }\n        private function getNextPositiveSightingIndex($sightings, $startIndex)\n        {\n            for ($i=$startIndex; $i < count($sightings) ; $i++) {\n                $sighting = $sightings[$i];\n                if ($sighting['type'] == 0) { // is false positive\n                    return $i;\n                }\n            }\n            return false;\n        }\n    }\n"], "fixing_code": ["<?php\n    class EventTimelineTool\n    {\n        private $__lookupTables = array();\n        private $__user = false;\n        private $__json = array();\n        private $__eventModel = false;\n        private $__refModel = false;\n        # Will be use latter on\n        private $__related_events = array();\n        private $__related_attributes = array();\n        # Feature not implemented yet.\n        # This is to let user configure a polling frequency. The idea is that it's not because we don't have data during a specific period that it means it should be considered as positive (or fp).\n        # For example, if we poll every Monday. If it was positive on week 1 and negative on week 2, the timeline will show that it was positive until monday on week 2, which is most probably incorrect as it might be actually negative on Wednesday.\n        private $extrapolateWithPollingFrequency = false;\n\n        public function construct($eventModel, $user, $filterRules, $extended_view=0)\n        {\n            $this->__eventModel = $eventModel;\n            $this->__objectTemplateModel = $eventModel->Object->ObjectTemplate;\n            $this->__user = $user;\n            $this->__filterRules = $filterRules;\n            $this->__json = array();\n            $this->__extended_view = $extended_view;\n            $this->__lookupTables = array(\n                'analysisLevels' => $this->__eventModel->analysisLevels,\n                'distributionLevels' => $this->__eventModel->Attribute->distributionLevels\n            );\n            return true;\n        }\n\n        public function construct_for_ref($refModel, $user)\n        {\n            $this->__refModel = $refModel;\n            $this->__user = $user;\n            $this->__json = array();\n            return true;\n        }\n\n        private function __get_event($id)\n        {\n            $fullevent = $this->__eventModel->fetchEvent($this->__user, array('eventid' => $id, 'flatten' => 0, 'includeTagRelations' => 1, 'extended' => $this->__extended_view));\n            $event = array();\n            if (empty($fullevent)) {\n                return $event;\n            }\n\n            if (!empty($fullevent[0]['Object'])) {\n                $event['Object'] = $fullevent[0]['Object'];\n            } else {\n                $event['Object'] = array();\n            }\n\n            if (!empty($fullevent[0]['Attribute'])) {\n                $event['Attribute'] = $fullevent[0]['Attribute'];\n            } else {\n                $event['Attribute'] = array();\n            }\n\n            if (!empty($fullevent[0]['Sighting'])) {\n                $event['Sighting'] = $fullevent[0]['Sighting'];\n            } else {\n                $event['Sighting'] = array();\n            }\n\n            return $event;\n        }\n\n        public function get_timeline($id)\n        {\n            $event = $this->__get_event($id);\n            $this->__json['items'] = array();\n\n            if (empty($event)) {\n                return $this->__json;\n            }\n\n            if (!empty($event['Object'])) {\n                $object = $event['Object'];\n            } else {\n                $object = array();\n            }\n\n            if (!empty($event['Attribute'])) {\n                $attribute = $event['Attribute'];\n            } else {\n                $attribute = array();\n            }\n\n            $sightingsAttributeMap = [];\n            foreach ($event['Sighting'] as $sighting) {\n                $sightingsAttributeMap[$sighting['attribute_id']][] = $sighting['date_sighting'];\n            }\n\n            // extract links and node type\n            foreach ($attribute as $attr) {\n                $toPush = array(\n                    'id' => $attr['id'],\n                    'uuid' => $attr['uuid'],\n                    'content' => h($attr['value']),\n                    'event_id' => $attr['event_id'],\n                    'group' => 'attribute',\n                    'timestamp' => $attr['timestamp'],\n                    'first_seen' => $attr['first_seen'],\n                    'last_seen' => $attr['last_seen'],\n                    'attribute_type' => $attr['type'],\n                    'date_sighting' => $sightingsAttributeMap[$attr['id']] ?? [],\n                    'is_image' => $this->__eventModel->Attribute->isImage($attr),\n                );\n                $this->__json['items'][] = $toPush;\n            }\n\n            foreach ($object as $obj) {\n                $toPush_obj = array(\n                    'id' => $obj['id'],\n                    'uuid' => $obj['uuid'],\n                    'content' => h($obj['name']),\n                    'group' => 'object',\n                    'meta-category' => h($obj['meta-category']),\n                    'template_uuid' => $obj['template_uuid'],\n                    'event_id' => $obj['event_id'],\n                    'timestamp' => $obj['timestamp'],\n                    'Attribute' => array(),\n                );\n\n                $toPush_obj['first_seen'] = $obj['first_seen'];\n                $toPush_obj['last_seen'] = $obj['last_seen'];\n                $toPush_obj['first_seen_overwrite'] = false;\n                $toPush_obj['last_seen_overwrite'] = false;\n\n                foreach ($obj['Attribute'] as $obj_attr) {\n                    // replaced *_seen based on object attribute\n                    if ($obj_attr['object_relation'] == 'first-seen' && is_null($toPush_obj['first_seen'])) {\n                        $toPush_obj['first_seen'] = $obj_attr['value']; // replace first_seen of the object to seen of the element\n                        $toPush_obj['first_seen_overwrite'] = true;\n                    } elseif ($obj_attr['object_relation'] == 'last-seen' && is_null($toPush_obj['last_seen'])) {\n                        $toPush_obj['last_seen'] = $obj_attr['value']; // replace last_seen of the object to seen of the element\n                        $toPush_obj['last_seen_overwrite'] = true;\n                    }\n                    $toPush_attr = array(\n                        'id' => $obj_attr['id'],\n                        'uuid' => $obj_attr['uuid'],\n                        'content' => h($obj_attr['value']),\n                        'contentType' => h($obj_attr['object_relation']),\n                        'event_id' => $obj_attr['event_id'],\n                        'group' => 'object_attribute',\n                        'timestamp' => $obj_attr['timestamp'],\n                        'attribute_type' => $obj_attr['type'],\n                        'date_sighting' => $sightingsAttributeMap[$attr['id']] ?? [],\n                        'is_image' => $this->__eventModel->Attribute->isImage($obj_attr),\n                    );\n                    $toPush_obj['Attribute'][] = $toPush_attr;\n                }\n                $this->__json['items'][] = $toPush_obj;\n            }\n\n            return $this->__json;\n        }\n\n        /*\n         * Extrapolation strategy:\n         *  - If only positive sightings: Will be from first to last sighting\n         *  - If both positive and false positive: False positive get priority. It will be marked as false positive until next positive sighting\n        */\n        public function get_sighting_timeline($id)\n        {\n            $event = $this->__eventModel->fetchEvent($this->__user, array(\n                'eventid' => $id,\n                'flatten' => 1,\n                'includeTagRelations' => 1,\n                'extended' => $this->__extended_view\n            ));\n            $this->__json['items'] = array();\n\n            if (empty($event)) {\n                return $this->__json;\n            } else {\n                $event = $event[0];\n            }\n\n            $lookupAttribute = array();\n            foreach ($event['Attribute'] as $k => $attribute) {\n                $lookupAttribute[$attribute['id']] = &$event['Attribute'][$k];\n            }\n\n            // regroup sightings per attribute\n            $regroupedSightings = array();\n            foreach ($event['Sighting'] as $k => $sighting) {\n                $event['Sighting'][$k]['date_sighting'] *= 1000; // adapt to use micro\n                $regroupedSightings[$sighting['attribute_id']][] = &$event['Sighting'][$k];\n            }\n            // generate extrapolation\n            $now = time()*1000;\n            foreach ($regroupedSightings as $attributeId => $sightings) {\n                usort($sightings, function ($a, $b) { // make sure sightings are ordered\n                    return $a['date_sighting'] > $b['date_sighting'];\n                });\n                $i = 0;\n                while ($i < count($sightings)) {\n                    $sighting = $sightings[$i];\n                    $attribute = $lookupAttribute[$attributeId];\n                    $fpSightingIndex = $this->getNextFalsePositiveSightingIndex($sightings, $i+1);\n                    $group = $sighting['type'] == '1' ? 'sighting_negative' : 'sighting_positive';\n                    if ($fpSightingIndex === false) { // No next FP, extrapolate to now\n                        $this->__json['items'][] = array(\n                            'attribute_id' => $attributeId,\n                            'id' => sprintf('%s-%s', $attributeId, $sighting['id']),\n                            'uuid' => $sighting['uuid'],\n                            'content' => h($attribute['value']),\n                            'event_id' => $attribute['event_id'],\n                            'group' => $group,\n                            'timestamp' => $attribute['timestamp'],\n                            'first_seen' => $sighting['date_sighting'],\n                            'last_seen' => $now,\n                        );\n                        break;\n                    } else {\n                        // set up until last positive\n                        $pSightingIndex = $fpSightingIndex - 1;\n                        $halfTime = 0;\n                        if ($pSightingIndex == $i) {\n                            // we have only one positive sighting, thus the UP time should be take from a pooling frequence (feature not existing yet)\n                            // for now, consider it UP only for half the time until the next FP\n                            if ($this->extrapolateWithPollingFrequency) {\n                                $halfTime = ($sightings[$i+1]['date_sighting'] - $sighting['date_sighting'])/2;\n                            }\n                        }\n                        $pSighting = $sightings[$pSightingIndex];\n                        if ($this->extrapolateWithPollingFrequency) {\n                            $lastSeenPositive = $pSighting['date_sighting'] + $halfTime;\n                        } else {\n                            $lastSeenPositive = $sightings[$i+1]['date_sighting'];\n                        }\n                        $this->__json['items'][] = array(\n                            'attribute_id' => $attributeId,\n                            'id' => sprintf('%s-%s', $attributeId, $sighting['id']),\n                            'uuid' => $sighting['uuid'],\n                            'content' => h($attribute['value']),\n                            'event_id' => $attribute['event_id'],\n                            'group' => 'sighting_positive',\n                            'timestamp' => $attribute['timestamp'],\n                            'first_seen' => $sighting['date_sighting'],\n                            'last_seen' => $lastSeenPositive,\n                        );\n                        // No next FP, extrapolate to now\n                        $fpSighting = $sightings[$fpSightingIndex];\n                        $secondNextPSightingIndex = $this->getNextPositiveSightingIndex($sightings, $fpSightingIndex+1);\n                        if ($secondNextPSightingIndex === false) { // No next P, extrapolate to now\n                            if ($this->extrapolateWithPollingFrequency) {\n                                $firstSeenNegative = $fpSighting['date_sighting'] - $halfTime;\n                            } else {\n                                $firstSeenNegative = $fpSighting['date_sighting'];\n                            }\n                            $this->__json['items'][] = array(\n                                'attribute_id' => $attributeId,\n                                'id' => sprintf('%s-%s', $attributeId, $sighting['id']),\n                                'uuid' => $fpSighting['uuid'],\n                                'content' => h($attribute['value']),\n                                'event_id' => $attribute['event_id'],\n                                'group' => 'sighting_negative',\n                                'timestamp' => $attribute['timestamp'],\n                                'first_seen' => $firstSeenNegative,\n                                'last_seen' => $now,\n                            );\n                            break;\n                        } else {\n                            if ($halfTime > 0) { // We need to fake a previous P\n                                $pSightingIndex = $pSightingIndex+1;\n                                $pSighting = $sightings[$pSightingIndex];\n                            }\n                            if ($this->extrapolateWithPollingFrequency) {\n                                $firstSeenNegative = $fpSighting['date_sighting'] - $halfTime;\n                            } else {\n                                $firstSeenNegative = $fpSighting['date_sighting'];\n                            }\n                            // set down until next postive\n                            $secondNextPSighting = $sightings[$secondNextPSightingIndex];\n                            $this->__json['items'][] = array(\n                                'attribute_id' => $attributeId,\n                                'id' => sprintf('%s-%s', $attributeId, $sighting['id']),\n                                'uuid' => $fpSighting['uuid'],\n                                'content' => h($attribute['value']),\n                                'event_id' => $attribute['event_id'],\n                                'group' => 'sighting_negative',\n                                'timestamp' => $attribute['timestamp'],\n                                'first_seen' => $firstSeenNegative,\n                                'last_seen' => $secondNextPSighting['date_sighting'],\n                            );\n                            $i = $secondNextPSightingIndex;\n                        }\n                    }\n                }\n            }\n            return $this->__json;\n        }\n\n        private function getNextFalsePositiveSightingIndex($sightings, $startIndex)\n        {\n            for ($i=$startIndex; $i < count($sightings) ; $i++) {\n                $sighting = $sightings[$i];\n                if ($sighting['type'] == 1) { // is false positive\n                    return $i;\n                }\n            }\n            return false;\n        }\n        private function getNextPositiveSightingIndex($sightings, $startIndex)\n        {\n            for ($i=$startIndex; $i < count($sightings) ; $i++) {\n                $sighting = $sightings[$i];\n                if ($sighting['type'] == 0) { // is false positive\n                    return $i;\n                }\n            }\n            return false;\n        }\n    }\n"], "filenames": ["app/Lib/Tools/EventTimelineTool.php"], "buggy_code_start_loc": [100], "buggy_code_end_loc": [283], "fixing_code_start_loc": [100], "fixing_code_end_loc": [283], "type": "CWE-79", "message": "app/Lib/Tools/EventTimelineTool.php in MISP before 2.4.179 allows XSS in the event timeline widget.", "other": {"cve": {"id": "CVE-2023-49926", "sourceIdentifier": "cve@mitre.org", "published": "2023-12-03T03:15:07.593", "lastModified": "2023-12-06T20:51:09.867", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "app/Lib/Tools/EventTimelineTool.php in MISP before 2.4.179 allows XSS in the event timeline widget."}, {"lang": "es", "value": "app/Lib/Tools/EventTimelineTool.php en MISP anterior a 2.4.179 permite XSS en el widget de l\u00ednea de tiempo de eventos."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:misp:misp:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.4.179", "matchCriteriaId": "181D80EC-D9FA-4EE9-AB6D-64CF451F8BED"}]}]}], "references": [{"url": "https://github.com/MISP/MISP/commit/dc73287ee2000476e3a5800ded402825ca10f7e8", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/MISP/MISP/compare/v2.4.178...v2.4.179", "source": "cve@mitre.org", "tags": ["Patch"]}]}, "github_commit_url": "https://github.com/MISP/MISP/commit/dc73287ee2000476e3a5800ded402825ca10f7e8"}}