{"buggy_code": ["\"\"\"V2.0 present-proof dif presentation-exchange format handler.\"\"\"\n\nimport json\nimport logging\n\nfrom marshmallow import RAISE\nfrom typing import Mapping, Tuple, Sequence\nfrom uuid import uuid4\n\nfrom ......messaging.base_handler import BaseResponder\nfrom ......messaging.decorators.attach_decorator import AttachDecorator\nfrom ......storage.error import StorageNotFoundError\nfrom ......storage.vc_holder.base import VCHolder\nfrom ......storage.vc_holder.vc_record import VCRecord\nfrom ......vc.ld_proofs import (\n    DocumentLoader,\n    Ed25519Signature2018,\n    Ed25519Signature2020,\n    BbsBlsSignature2020,\n    BbsBlsSignatureProof2020,\n    WalletKeyPair,\n)\nfrom ......vc.vc_ld.verify import verify_presentation\nfrom ......wallet.key_type import ED25519, BLS12381G2\n\nfrom .....problem_report.v1_0.message import ProblemReport\n\nfrom ....dif.pres_exch import PresentationDefinition, SchemaInputDescriptor\nfrom ....dif.pres_exch_handler import DIFPresExchHandler, DIFPresExchError\nfrom ....dif.pres_proposal_schema import DIFProofProposalSchema\nfrom ....dif.pres_request_schema import (\n    DIFProofRequestSchema,\n    DIFPresSpecSchema,\n)\nfrom ....dif.pres_schema import DIFProofSchema\nfrom ....v2_0.messages.pres_problem_report import ProblemReportReason\n\nfrom ...message_types import (\n    ATTACHMENT_FORMAT,\n    PRES_20_REQUEST,\n    PRES_20,\n    PRES_20_PROPOSAL,\n)\nfrom ...messages.pres_format import V20PresFormat\nfrom ...messages.pres import V20Pres\nfrom ...models.pres_exchange import V20PresExRecord\n\nfrom ..handler import V20PresFormatHandler, V20PresFormatHandlerError\n\nLOGGER = logging.getLogger(__name__)\n\n\nclass DIFPresFormatHandler(V20PresFormatHandler):\n    \"\"\"DIF presentation format handler.\"\"\"\n\n    format = V20PresFormat.Format.DIF\n\n    ISSUE_SIGNATURE_SUITE_KEY_TYPE_MAPPING = {\n        Ed25519Signature2018: ED25519,\n        Ed25519Signature2020: ED25519,\n    }\n\n    if BbsBlsSignature2020.BBS_SUPPORTED:\n        ISSUE_SIGNATURE_SUITE_KEY_TYPE_MAPPING[BbsBlsSignature2020] = BLS12381G2\n        ISSUE_SIGNATURE_SUITE_KEY_TYPE_MAPPING[BbsBlsSignatureProof2020] = BLS12381G2\n\n    async def _get_all_suites(self):\n        \"\"\"Get all supported suites for verifying presentation.\"\"\"\n        suites = []\n        for suite, key_type in self.ISSUE_SIGNATURE_SUITE_KEY_TYPE_MAPPING.items():\n            suites.append(\n                suite(\n                    key_pair=WalletKeyPair(profile=self._profile, key_type=key_type),\n                )\n            )\n        return suites\n\n    @classmethod\n    def validate_fields(cls, message_type: str, attachment_data: Mapping):\n        \"\"\"Validate attachment data for a specific message type.\n\n        Uses marshmallow schemas to validate if format specific attachment data\n        is valid for the specified message type. Only does structural and type\n        checks, does not validate if .e.g. the issuer value is valid.\n\n\n        Args:\n            message_type (str): The message type to validate the attachment data for.\n                Should be one of the message types as defined in message_types.py\n            attachment_data (Mapping): [description]\n                The attachment data to valide\n\n        Raises:\n            Exception: When the data is not valid.\n\n        \"\"\"\n        mapping = {\n            PRES_20_REQUEST: DIFProofRequestSchema,\n            PRES_20_PROPOSAL: DIFProofProposalSchema,\n            PRES_20: DIFProofSchema,\n        }\n\n        # Get schema class\n        Schema = mapping[message_type]\n\n        # Validate, throw if not valid\n        Schema(unknown=RAISE).load(attachment_data)\n\n    def get_format_identifier(self, message_type: str) -> str:\n        \"\"\"Get attachment format identifier for format and message combination.\n\n        Args:\n            message_type (str): Message type for which to return the format identifier\n\n        Returns:\n            str: Issue credential attachment format identifier\n\n        \"\"\"\n        return ATTACHMENT_FORMAT[message_type][DIFPresFormatHandler.format.api]\n\n    def get_format_data(\n        self, message_type: str, data: dict\n    ) -> Tuple[V20PresFormat, AttachDecorator]:\n        \"\"\"Get presentation format and attach objects for use in pres_ex messages.\"\"\"\n\n        return (\n            V20PresFormat(\n                attach_id=DIFPresFormatHandler.format.api,\n                format_=self.get_format_identifier(message_type),\n            ),\n            AttachDecorator.data_json(data, ident=DIFPresFormatHandler.format.api),\n        )\n\n    async def create_bound_request(\n        self,\n        pres_ex_record: V20PresExRecord,\n        request_data: dict = None,\n    ) -> Tuple[V20PresFormat, AttachDecorator]:\n        \"\"\"Create a presentation request bound to a proposal.\n\n        Args:\n            pres_ex_record: Presentation exchange record for which\n                to create presentation request\n            name: name to use in presentation request (None for default)\n            version: version to use in presentation request (None for default)\n            nonce: nonce to use in presentation request (None to generate)\n            comment: Optional human-readable comment pertaining to request creation\n\n        Returns:\n            A tuple (updated presentation exchange record, presentation request message)\n\n        \"\"\"\n        dif_proof_request = {}\n        pres_proposal_dict = pres_ex_record.pres_proposal.attachment(\n            DIFPresFormatHandler.format\n        )\n        if \"options\" not in pres_proposal_dict:\n            dif_proof_request[\"options\"] = {\"challenge\": str(uuid4())}\n        else:\n            dif_proof_request[\"options\"] = pres_proposal_dict[\"options\"]\n            del pres_proposal_dict[\"options\"]\n            if \"challenge\" not in dif_proof_request.get(\"options\"):\n                dif_proof_request[\"options\"][\"challenge\"] = str(uuid4())\n        dif_proof_request[\"presentation_definition\"] = pres_proposal_dict\n\n        return self.get_format_data(PRES_20_REQUEST, dif_proof_request)\n\n    async def create_pres(\n        self,\n        pres_ex_record: V20PresExRecord,\n        request_data: dict = {},\n    ) -> Tuple[V20PresFormat, AttachDecorator]:\n        \"\"\"Create a presentation.\"\"\"\n        proof_request = pres_ex_record.pres_request.attachment(\n            DIFPresFormatHandler.format\n        )\n        pres_definition = None\n        limit_record_ids = None\n        reveal_doc_frame = None\n        challenge = None\n        domain = None\n        if request_data != {} and DIFPresFormatHandler.format.api in request_data:\n            dif_spec = request_data.get(DIFPresFormatHandler.format.api)\n            pres_spec_payload = DIFPresSpecSchema().load(dif_spec)\n            # Overriding with prover provided pres_spec\n            pres_definition = pres_spec_payload.get(\"presentation_definition\")\n            issuer_id = pres_spec_payload.get(\"issuer_id\")\n            limit_record_ids = pres_spec_payload.get(\"record_ids\")\n            reveal_doc_frame = pres_spec_payload.get(\"reveal_doc\")\n        if not pres_definition:\n            if \"options\" in proof_request:\n                challenge = proof_request[\"options\"].get(\"challenge\")\n                domain = proof_request[\"options\"].get(\"domain\")\n            pres_definition = PresentationDefinition.deserialize(\n                proof_request.get(\"presentation_definition\")\n            )\n            issuer_id = None\n        if not challenge:\n            challenge = str(uuid4())\n\n        input_descriptors = pres_definition.input_descriptors\n        claim_fmt = pres_definition.fmt\n        dif_handler_proof_type = None\n        try:\n            holder = self._profile.inject(VCHolder)\n            record_ids = set()\n            credentials_list = []\n            for input_descriptor in input_descriptors:\n                proof_type = None\n                limit_disclosure = input_descriptor.constraint.limit_disclosure and (\n                    input_descriptor.constraint.limit_disclosure == \"required\"\n                )\n                uri_list = []\n                one_of_uri_groups = []\n                if input_descriptor.schemas:\n                    if input_descriptor.schemas.oneof_filter:\n                        one_of_uri_groups = (\n                            await self.retrieve_uri_list_from_schema_filter(\n                                input_descriptor.schemas.uri_groups\n                            )\n                        )\n                    else:\n                        schema_uris = input_descriptor.schemas.uri_groups[0]\n                        for schema_uri in schema_uris:\n                            if schema_uri.required is None:\n                                required = True\n                            else:\n                                required = schema_uri.required\n                            if required:\n                                uri_list.append(schema_uri.uri)\n                if len(uri_list) == 0:\n                    uri_list = None\n                if len(one_of_uri_groups) == 0:\n                    one_of_uri_groups = None\n                if limit_disclosure:\n                    proof_type = [BbsBlsSignature2020.signature_type]\n                    dif_handler_proof_type = BbsBlsSignature2020.signature_type\n                if claim_fmt:\n                    if claim_fmt.ldp_vp:\n                        if \"proof_type\" in claim_fmt.ldp_vp:\n                            proof_types = claim_fmt.ldp_vp.get(\"proof_type\")\n                            if limit_disclosure and (\n                                BbsBlsSignature2020.signature_type not in proof_types\n                            ):\n                                raise V20PresFormatHandlerError(\n                                    \"Verifier submitted presentation request with \"\n                                    \"limit_disclosure [selective disclosure] \"\n                                    \"option but verifier does not support \"\n                                    \"BbsBlsSignature2020 format\"\n                                )\n                            elif (\n                                len(proof_types) == 1\n                                and (\n                                    BbsBlsSignature2020.signature_type\n                                    not in proof_types\n                                )\n                                and (\n                                    Ed25519Signature2018.signature_type\n                                    not in proof_types\n                                )\n                                and (\n                                    Ed25519Signature2020.signature_type\n                                    not in proof_types\n                                )\n                            ):\n                                raise V20PresFormatHandlerError(\n                                    \"Only BbsBlsSignature2020 and/or \"\n                                    \"Ed25519Signature2018 and/or \"\n                                    \"Ed25519Signature2018 and/or \"\n                                    \"Ed25519Signature2020 signature types \"\n                                    \"are supported\"\n                                )\n                            elif (\n                                len(proof_types) >= 2\n                                and (\n                                    BbsBlsSignature2020.signature_type\n                                    not in proof_types\n                                )\n                                and (\n                                    Ed25519Signature2018.signature_type\n                                    not in proof_types\n                                )\n                                and (\n                                    Ed25519Signature2020.signature_type\n                                    not in proof_types\n                                )\n                            ):\n                                raise V20PresFormatHandlerError(\n                                    \"Only BbsBlsSignature2020, Ed25519Signature2018 and \"\n                                    \"Ed25519Signature2020 signature types \"\n                                    \"are supported\"\n                                )\n                            else:\n                                for proof_format in proof_types:\n                                    if (\n                                        proof_format\n                                        == Ed25519Signature2018.signature_type\n                                    ):\n                                        proof_type = [\n                                            Ed25519Signature2018.signature_type\n                                        ]\n                                        dif_handler_proof_type = (\n                                            Ed25519Signature2018.signature_type\n                                        )\n                                        break\n                                    elif (\n                                        proof_format\n                                        == BbsBlsSignature2020.signature_type\n                                    ):\n                                        proof_type = [\n                                            BbsBlsSignature2020.signature_type\n                                        ]\n                                        dif_handler_proof_type = (\n                                            BbsBlsSignature2020.signature_type\n                                        )\n                                        break\n                    else:\n                        raise V20PresFormatHandlerError(\n                            \"Currently, only ldp_vp with \"\n                            \"BbsBlsSignature2020, Ed25519Signature2018 and \"\n                            \"Ed25519Signature2020 signature types are supported\"\n                        )\n                if one_of_uri_groups:\n                    records = []\n                    cred_group_record_ids = set()\n                    for uri_group in one_of_uri_groups:\n                        search = holder.search_credentials(\n                            proof_types=proof_type, pd_uri_list=uri_group\n                        )\n                        max_results = 1000\n                        cred_group = await search.fetch(max_results)\n                        (\n                            cred_group_vcrecord_list,\n                            cred_group_vcrecord_ids_set,\n                        ) = await self.process_vcrecords_return_list(\n                            cred_group, cred_group_record_ids\n                        )\n                        cred_group_record_ids = cred_group_vcrecord_ids_set\n                        records = records + cred_group_vcrecord_list\n                else:\n                    search = holder.search_credentials(\n                        proof_types=proof_type, pd_uri_list=uri_list\n                    )\n                    # Defaults to page_size but would like to include all\n                    # For now, setting to 1000\n                    max_results = 1000\n                    records = await search.fetch(max_results)\n                # Avoiding addition of duplicate records\n                (\n                    vcrecord_list,\n                    vcrecord_ids_set,\n                ) = await self.process_vcrecords_return_list(records, record_ids)\n                record_ids = vcrecord_ids_set\n                credentials_list = credentials_list + vcrecord_list\n        except StorageNotFoundError as err:\n            raise V20PresFormatHandlerError(err)\n        except TypeError as err:\n            LOGGER.error(str(err))\n            responder = self._profile.inject_or(BaseResponder)\n            if responder:\n                report = ProblemReport(\n                    description={\n                        \"en\": (\n                            \"Presentation request not properly formatted,\"\n                            \" TypeError raised on Holder agent.\"\n                        ),\n                        \"code\": ProblemReportReason.ABANDONED.value,\n                    }\n                )\n                if pres_ex_record.thread_id:\n                    report.assign_thread_id(pres_ex_record.thread_id)\n                await responder.send_reply(\n                    report, connection_id=pres_ex_record.connection_id\n                )\n                return\n\n        dif_handler = DIFPresExchHandler(\n            self._profile,\n            pres_signing_did=issuer_id,\n            proof_type=dif_handler_proof_type,\n            reveal_doc=reveal_doc_frame,\n        )\n        try:\n            pres = await dif_handler.create_vp(\n                challenge=challenge,\n                domain=domain,\n                pd=pres_definition,\n                credentials=credentials_list,\n                records_filter=limit_record_ids,\n            )\n            return self.get_format_data(PRES_20, pres)\n        except DIFPresExchError as err:\n            LOGGER.error(str(err))\n            responder = self._profile.inject_or(BaseResponder)\n            if responder:\n                report = ProblemReport(\n                    description={\n                        \"en\": str(err),\n                        \"code\": ProblemReportReason.ABANDONED.value,\n                    }\n                )\n                if pres_ex_record.thread_id:\n                    report.assign_thread_id(pres_ex_record.thread_id)\n                await responder.send_reply(\n                    report, connection_id=pres_ex_record.connection_id\n                )\n\n    async def process_vcrecords_return_list(\n        self, vc_records: Sequence[VCRecord], record_ids: set\n    ) -> Tuple[Sequence[VCRecord], set]:\n        \"\"\"Return list of non-duplicate VCRecords.\"\"\"\n        to_add = []\n        for vc_record in vc_records:\n            if vc_record.record_id not in record_ids:\n                to_add.append(vc_record)\n                record_ids.add(vc_record.record_id)\n        return (to_add, record_ids)\n\n    async def retrieve_uri_list_from_schema_filter(\n        self, schema_uri_groups: Sequence[Sequence[SchemaInputDescriptor]]\n    ) -> Sequence[str]:\n        \"\"\"Retrieve list of schema uri from uri_group.\"\"\"\n        group_schema_uri_list = []\n        for schema_group in schema_uri_groups:\n            uri_list = []\n            for schema in schema_group:\n                uri_list.append(schema.uri)\n            if len(uri_list) > 0:\n                group_schema_uri_list.append(uri_list)\n        return group_schema_uri_list\n\n    async def receive_pres(self, message: V20Pres, pres_ex_record: V20PresExRecord):\n        \"\"\"Receive a presentation, from message in context on manager creation.\"\"\"\n        dif_handler = DIFPresExchHandler(self._profile)\n        dif_proof = message.attachment(DIFPresFormatHandler.format)\n        proof_request = pres_ex_record.pres_request.attachment(\n            DIFPresFormatHandler.format\n        )\n        pres_definition = PresentationDefinition.deserialize(\n            proof_request.get(\"presentation_definition\")\n        )\n        try:\n            await dif_handler.verify_received_pres(pd=pres_definition, pres=dif_proof)\n            return True\n        except DIFPresExchError as err:\n            LOGGER.error(str(err))\n            responder = self._profile.inject_or(BaseResponder)\n            if responder:\n                report = ProblemReport(\n                    description={\n                        \"en\": str(err),\n                        \"code\": ProblemReportReason.ABANDONED.value,\n                    }\n                )\n                if pres_ex_record.thread_id:\n                    report.assign_thread_id(pres_ex_record.thread_id)\n                await responder.send_reply(\n                    report, connection_id=pres_ex_record.connection_id\n                )\n                return False\n\n    async def verify_pres(self, pres_ex_record: V20PresExRecord) -> V20PresExRecord:\n        \"\"\"Verify a presentation.\n\n        Args:\n            pres_ex_record: presentation exchange record\n                with presentation request and presentation to verify\n\n        Returns:\n            presentation exchange record, updated\n\n        \"\"\"\n        dif_proof = pres_ex_record.pres.attachment(DIFPresFormatHandler.format)\n        pres_request = pres_ex_record.pres_request.attachment(\n            DIFPresFormatHandler.format\n        )\n        challenge = None\n        if \"options\" in pres_request:\n            challenge = pres_request[\"options\"].get(\"challenge\", str(uuid4()))\n        if not challenge:\n            challenge = str(uuid4())\n        if isinstance(dif_proof, Sequence):\n            for proof in dif_proof:\n                pres_ver_result = await verify_presentation(\n                    presentation=proof,\n                    suites=await self._get_all_suites(),\n                    document_loader=self._profile.inject(DocumentLoader),\n                    challenge=challenge,\n                )\n                if not pres_ver_result.verified:\n                    break\n        else:\n            pres_ver_result = await verify_presentation(\n                presentation=dif_proof,\n                suites=await self._get_all_suites(),\n                document_loader=self._profile.inject(DocumentLoader),\n                challenge=challenge,\n            )\n        pres_ex_record.verified = json.dumps(pres_ver_result.verified)\n        return pres_ex_record\n", "\"\"\"Verifiable Credential and Presentation verification methods.\"\"\"\n\nimport asyncio\nfrom typing import List\nfrom pyld.jsonld import JsonLdProcessor\n\nfrom ..ld_proofs import (\n    LinkedDataProof,\n    CredentialIssuancePurpose,\n    DocumentLoaderMethod,\n    ProofPurpose,\n    AuthenticationProofPurpose,\n    verify as ld_proofs_verify,\n    DocumentVerificationResult,\n    LinkedDataProofException,\n)\nfrom .models.credential import VerifiableCredentialSchema\nfrom .validation_result import PresentationVerificationResult\n\n\nasync def _verify_credential(\n    *,\n    credential: dict,\n    suites: List[LinkedDataProof],\n    document_loader: DocumentLoaderMethod,\n    purpose: ProofPurpose = None,\n) -> DocumentVerificationResult:\n    \"\"\"Verify credential structure, proof purpose and signature.\"\"\"\n\n    # Validate credential structure\n    errors = VerifiableCredentialSchema().validate(credential)\n    if len(errors) > 0:\n        raise LinkedDataProofException(\n            f\"Unable to verify credential with invalid structure: {errors}\"\n        )\n\n    if not purpose:\n        purpose = CredentialIssuancePurpose()\n\n    result = await ld_proofs_verify(\n        document=credential,\n        suites=suites,\n        purpose=purpose,\n        document_loader=document_loader,\n    )\n\n    return result\n\n\nasync def verify_credential(\n    *,\n    credential: dict,\n    suites: List[LinkedDataProof],\n    document_loader: DocumentLoaderMethod,\n    purpose: ProofPurpose = None,\n) -> DocumentVerificationResult:\n    \"\"\"Verify credential structure, proof purpose and signature.\n\n    Args:\n        credential (dict): The credential to verify\n        suites (List[LinkedDataProof]): The signature suites to verify with\n        document_loader (DocumentLoader): Document loader used for resolving of documents\n        purpose (ProofPurpose, optional): Proof purpose to use.\n            Defaults to CredentialIssuancePurpose\n\n    Returns:\n        DocumentVerificationResult: The result of the verification. Verified property\n            indicates whether the verification was successful\n\n    \"\"\"\n    try:\n        return await _verify_credential(\n            credential=credential,\n            document_loader=document_loader,\n            suites=suites,\n            purpose=purpose,\n        )\n    except Exception as e:\n        return DocumentVerificationResult(\n            verified=False, document=credential, errors=[e]\n        )\n\n\nasync def _verify_presentation(\n    *,\n    presentation: dict,\n    suites: List[LinkedDataProof],\n    document_loader: DocumentLoaderMethod,\n    challenge: str = None,\n    domain: str = None,\n    purpose: ProofPurpose = None,\n):\n    \"\"\"Verify presentation structure, credentials, proof purpose and signature.\"\"\"\n\n    if not purpose and not challenge:\n        raise LinkedDataProofException(\n            'A \"challenge\" param is required for AuthenticationProofPurpose.'\n        )\n    elif not purpose:\n        purpose = AuthenticationProofPurpose(challenge=challenge, domain=domain)\n\n    # TODO validate presentation structure here\n    if \"proof\" not in presentation:\n        raise LinkedDataProofException('presentation must contain \"proof\"')\n\n    presentation_result = await ld_proofs_verify(\n        document=presentation,\n        suites=suites,\n        purpose=purpose,\n        document_loader=document_loader,\n    )\n\n    credential_results = None\n    verified = True\n\n    credentials = JsonLdProcessor.get_values(presentation, \"verifiableCredential\")\n    credential_results = await asyncio.gather(\n        *[\n            verify_credential(\n                credential=credential,\n                suites=suites,\n                document_loader=document_loader,\n                # FIXME: we don't want to interhit the authentication purpose\n                # from the presentation. However we do want to have subject\n                # authentication I guess\n                # purpose=purpose,\n            )\n            for credential in credentials\n        ]\n    )\n\n    verified = all(result.verified for result in credential_results)\n\n    return PresentationVerificationResult(\n        verified=verified,\n        presentation_result=presentation_result,\n        credential_results=credential_results,\n        errors=presentation_result.errors,\n    )\n\n\nasync def verify_presentation(\n    *,\n    presentation: dict,\n    suites: List[LinkedDataProof],\n    document_loader: DocumentLoaderMethod,\n    purpose: ProofPurpose = None,\n    challenge: str = None,\n    domain: str = None,\n) -> PresentationVerificationResult:\n    \"\"\"Verify presentation structure, credentials, proof purpose and signature.\n\n    Args:\n        presentation (dict): The presentation to verify\n        suites (List[LinkedDataProof]): The signature suites to verify with\n        document_loader (DocumentLoader): Document loader used for resolving of documents\n        purpose (ProofPurpose, optional): Proof purpose to use.\n            Defaults to AuthenticationProofPurpose\n        challenge (str, optional): The challenge to use for authentication.\n            Required if purpose is not passed, not used if purpose is passed\n        domain (str, optional): Domain to use for the authentication proof purpose.\n            Not used if purpose is passed\n\n    Returns:\n        PresentationVerificationResult: The result of the verification. Verified property\n            indicates whether the verification was successful\n\n    \"\"\"\n\n    # TODO: I think we should add some sort of options to authenticate the subject id\n    # to the presentation verification method controller\n\n    try:\n        return await _verify_presentation(\n            presentation=presentation,\n            challenge=challenge,\n            purpose=purpose,\n            suites=suites,\n            domain=domain,\n            document_loader=document_loader,\n        )\n    except Exception as e:\n        return PresentationVerificationResult(verified=False, errors=[e])\n\n\n__all__ = [\"verify_presentation\", \"verify_credential\"]\n"], "fixing_code": ["\"\"\"V2.0 present-proof dif presentation-exchange format handler.\"\"\"\n\nimport json\nimport logging\n\nfrom marshmallow import RAISE\nfrom typing import Mapping, Tuple, Sequence\nfrom uuid import uuid4\n\nfrom ......messaging.base_handler import BaseResponder\nfrom ......messaging.decorators.attach_decorator import AttachDecorator\nfrom ......storage.error import StorageNotFoundError\nfrom ......storage.vc_holder.base import VCHolder\nfrom ......storage.vc_holder.vc_record import VCRecord\nfrom ......vc.ld_proofs import (\n    DocumentLoader,\n    Ed25519Signature2018,\n    Ed25519Signature2020,\n    BbsBlsSignature2020,\n    BbsBlsSignatureProof2020,\n    WalletKeyPair,\n)\nfrom ......vc.vc_ld.verify import verify_presentation\nfrom ......wallet.key_type import ED25519, BLS12381G2\n\nfrom .....problem_report.v1_0.message import ProblemReport\n\nfrom ....dif.pres_exch import PresentationDefinition, SchemaInputDescriptor\nfrom ....dif.pres_exch_handler import DIFPresExchHandler, DIFPresExchError\nfrom ....dif.pres_proposal_schema import DIFProofProposalSchema\nfrom ....dif.pres_request_schema import (\n    DIFProofRequestSchema,\n    DIFPresSpecSchema,\n)\nfrom ....dif.pres_schema import DIFProofSchema\nfrom ....v2_0.messages.pres_problem_report import ProblemReportReason\n\nfrom ...message_types import (\n    ATTACHMENT_FORMAT,\n    PRES_20_REQUEST,\n    PRES_20,\n    PRES_20_PROPOSAL,\n)\nfrom ...messages.pres_format import V20PresFormat\nfrom ...messages.pres import V20Pres\nfrom ...models.pres_exchange import V20PresExRecord\n\nfrom ..handler import V20PresFormatHandler, V20PresFormatHandlerError\n\nLOGGER = logging.getLogger(__name__)\n\n\nclass DIFPresFormatHandler(V20PresFormatHandler):\n    \"\"\"DIF presentation format handler.\"\"\"\n\n    format = V20PresFormat.Format.DIF\n\n    ISSUE_SIGNATURE_SUITE_KEY_TYPE_MAPPING = {\n        Ed25519Signature2018: ED25519,\n        Ed25519Signature2020: ED25519,\n    }\n\n    if BbsBlsSignature2020.BBS_SUPPORTED:\n        ISSUE_SIGNATURE_SUITE_KEY_TYPE_MAPPING[BbsBlsSignature2020] = BLS12381G2\n        ISSUE_SIGNATURE_SUITE_KEY_TYPE_MAPPING[BbsBlsSignatureProof2020] = BLS12381G2\n\n    async def _get_all_suites(self):\n        \"\"\"Get all supported suites for verifying presentation.\"\"\"\n        suites = []\n        for suite, key_type in self.ISSUE_SIGNATURE_SUITE_KEY_TYPE_MAPPING.items():\n            suites.append(\n                suite(\n                    key_pair=WalletKeyPair(profile=self._profile, key_type=key_type),\n                )\n            )\n        return suites\n\n    @classmethod\n    def validate_fields(cls, message_type: str, attachment_data: Mapping):\n        \"\"\"Validate attachment data for a specific message type.\n\n        Uses marshmallow schemas to validate if format specific attachment data\n        is valid for the specified message type. Only does structural and type\n        checks, does not validate if .e.g. the issuer value is valid.\n\n\n        Args:\n            message_type (str): The message type to validate the attachment data for.\n                Should be one of the message types as defined in message_types.py\n            attachment_data (Mapping): [description]\n                The attachment data to valide\n\n        Raises:\n            Exception: When the data is not valid.\n\n        \"\"\"\n        mapping = {\n            PRES_20_REQUEST: DIFProofRequestSchema,\n            PRES_20_PROPOSAL: DIFProofProposalSchema,\n            PRES_20: DIFProofSchema,\n        }\n\n        # Get schema class\n        Schema = mapping[message_type]\n\n        # Validate, throw if not valid\n        Schema(unknown=RAISE).load(attachment_data)\n\n    def get_format_identifier(self, message_type: str) -> str:\n        \"\"\"Get attachment format identifier for format and message combination.\n\n        Args:\n            message_type (str): Message type for which to return the format identifier\n\n        Returns:\n            str: Issue credential attachment format identifier\n\n        \"\"\"\n        return ATTACHMENT_FORMAT[message_type][DIFPresFormatHandler.format.api]\n\n    def get_format_data(\n        self, message_type: str, data: dict\n    ) -> Tuple[V20PresFormat, AttachDecorator]:\n        \"\"\"Get presentation format and attach objects for use in pres_ex messages.\"\"\"\n\n        return (\n            V20PresFormat(\n                attach_id=DIFPresFormatHandler.format.api,\n                format_=self.get_format_identifier(message_type),\n            ),\n            AttachDecorator.data_json(data, ident=DIFPresFormatHandler.format.api),\n        )\n\n    async def create_bound_request(\n        self,\n        pres_ex_record: V20PresExRecord,\n        request_data: dict = None,\n    ) -> Tuple[V20PresFormat, AttachDecorator]:\n        \"\"\"Create a presentation request bound to a proposal.\n\n        Args:\n            pres_ex_record: Presentation exchange record for which\n                to create presentation request\n            name: name to use in presentation request (None for default)\n            version: version to use in presentation request (None for default)\n            nonce: nonce to use in presentation request (None to generate)\n            comment: Optional human-readable comment pertaining to request creation\n\n        Returns:\n            A tuple (updated presentation exchange record, presentation request message)\n\n        \"\"\"\n        dif_proof_request = {}\n        pres_proposal_dict = pres_ex_record.pres_proposal.attachment(\n            DIFPresFormatHandler.format\n        )\n        if \"options\" not in pres_proposal_dict:\n            dif_proof_request[\"options\"] = {\"challenge\": str(uuid4())}\n        else:\n            dif_proof_request[\"options\"] = pres_proposal_dict[\"options\"]\n            del pres_proposal_dict[\"options\"]\n            if \"challenge\" not in dif_proof_request.get(\"options\"):\n                dif_proof_request[\"options\"][\"challenge\"] = str(uuid4())\n        dif_proof_request[\"presentation_definition\"] = pres_proposal_dict\n\n        return self.get_format_data(PRES_20_REQUEST, dif_proof_request)\n\n    async def create_pres(\n        self,\n        pres_ex_record: V20PresExRecord,\n        request_data: dict = {},\n    ) -> Tuple[V20PresFormat, AttachDecorator]:\n        \"\"\"Create a presentation.\"\"\"\n        proof_request = pres_ex_record.pres_request.attachment(\n            DIFPresFormatHandler.format\n        )\n        pres_definition = None\n        limit_record_ids = None\n        reveal_doc_frame = None\n        challenge = None\n        domain = None\n        if request_data != {} and DIFPresFormatHandler.format.api in request_data:\n            dif_spec = request_data.get(DIFPresFormatHandler.format.api)\n            pres_spec_payload = DIFPresSpecSchema().load(dif_spec)\n            # Overriding with prover provided pres_spec\n            pres_definition = pres_spec_payload.get(\"presentation_definition\")\n            issuer_id = pres_spec_payload.get(\"issuer_id\")\n            limit_record_ids = pres_spec_payload.get(\"record_ids\")\n            reveal_doc_frame = pres_spec_payload.get(\"reveal_doc\")\n        if not pres_definition:\n            pres_definition = PresentationDefinition.deserialize(\n                proof_request.get(\"presentation_definition\")\n            )\n            issuer_id = None\n        if \"options\" in proof_request:\n            challenge = proof_request[\"options\"].get(\"challenge\")\n            domain = proof_request[\"options\"].get(\"domain\")\n        if not challenge:\n            challenge = str(uuid4())\n\n        input_descriptors = pres_definition.input_descriptors\n        claim_fmt = pres_definition.fmt\n        dif_handler_proof_type = None\n        try:\n            holder = self._profile.inject(VCHolder)\n            record_ids = set()\n            credentials_list = []\n            for input_descriptor in input_descriptors:\n                proof_type = None\n                limit_disclosure = input_descriptor.constraint.limit_disclosure and (\n                    input_descriptor.constraint.limit_disclosure == \"required\"\n                )\n                uri_list = []\n                one_of_uri_groups = []\n                if input_descriptor.schemas:\n                    if input_descriptor.schemas.oneof_filter:\n                        one_of_uri_groups = (\n                            await self.retrieve_uri_list_from_schema_filter(\n                                input_descriptor.schemas.uri_groups\n                            )\n                        )\n                    else:\n                        schema_uris = input_descriptor.schemas.uri_groups[0]\n                        for schema_uri in schema_uris:\n                            if schema_uri.required is None:\n                                required = True\n                            else:\n                                required = schema_uri.required\n                            if required:\n                                uri_list.append(schema_uri.uri)\n                if len(uri_list) == 0:\n                    uri_list = None\n                if len(one_of_uri_groups) == 0:\n                    one_of_uri_groups = None\n                if limit_disclosure:\n                    proof_type = [BbsBlsSignature2020.signature_type]\n                    dif_handler_proof_type = BbsBlsSignature2020.signature_type\n                if claim_fmt:\n                    if claim_fmt.ldp_vp:\n                        if \"proof_type\" in claim_fmt.ldp_vp:\n                            proof_types = claim_fmt.ldp_vp.get(\"proof_type\")\n                            if limit_disclosure and (\n                                BbsBlsSignature2020.signature_type not in proof_types\n                            ):\n                                raise V20PresFormatHandlerError(\n                                    \"Verifier submitted presentation request with \"\n                                    \"limit_disclosure [selective disclosure] \"\n                                    \"option but verifier does not support \"\n                                    \"BbsBlsSignature2020 format\"\n                                )\n                            elif (\n                                len(proof_types) == 1\n                                and (\n                                    BbsBlsSignature2020.signature_type\n                                    not in proof_types\n                                )\n                                and (\n                                    Ed25519Signature2018.signature_type\n                                    not in proof_types\n                                )\n                                and (\n                                    Ed25519Signature2020.signature_type\n                                    not in proof_types\n                                )\n                            ):\n                                raise V20PresFormatHandlerError(\n                                    \"Only BbsBlsSignature2020 and/or \"\n                                    \"Ed25519Signature2018 and/or \"\n                                    \"Ed25519Signature2018 and/or \"\n                                    \"Ed25519Signature2020 signature types \"\n                                    \"are supported\"\n                                )\n                            elif (\n                                len(proof_types) >= 2\n                                and (\n                                    BbsBlsSignature2020.signature_type\n                                    not in proof_types\n                                )\n                                and (\n                                    Ed25519Signature2018.signature_type\n                                    not in proof_types\n                                )\n                                and (\n                                    Ed25519Signature2020.signature_type\n                                    not in proof_types\n                                )\n                            ):\n                                raise V20PresFormatHandlerError(\n                                    \"Only BbsBlsSignature2020, Ed25519Signature2018 and \"\n                                    \"Ed25519Signature2020 signature types \"\n                                    \"are supported\"\n                                )\n                            else:\n                                for proof_format in proof_types:\n                                    if (\n                                        proof_format\n                                        == Ed25519Signature2018.signature_type\n                                    ):\n                                        proof_type = [\n                                            Ed25519Signature2018.signature_type\n                                        ]\n                                        dif_handler_proof_type = (\n                                            Ed25519Signature2018.signature_type\n                                        )\n                                        break\n                                    elif (\n                                        proof_format\n                                        == BbsBlsSignature2020.signature_type\n                                    ):\n                                        proof_type = [\n                                            BbsBlsSignature2020.signature_type\n                                        ]\n                                        dif_handler_proof_type = (\n                                            BbsBlsSignature2020.signature_type\n                                        )\n                                        break\n                    else:\n                        raise V20PresFormatHandlerError(\n                            \"Currently, only ldp_vp with \"\n                            \"BbsBlsSignature2020, Ed25519Signature2018 and \"\n                            \"Ed25519Signature2020 signature types are supported\"\n                        )\n                if one_of_uri_groups:\n                    records = []\n                    cred_group_record_ids = set()\n                    for uri_group in one_of_uri_groups:\n                        search = holder.search_credentials(\n                            proof_types=proof_type, pd_uri_list=uri_group\n                        )\n                        max_results = 1000\n                        cred_group = await search.fetch(max_results)\n                        (\n                            cred_group_vcrecord_list,\n                            cred_group_vcrecord_ids_set,\n                        ) = await self.process_vcrecords_return_list(\n                            cred_group, cred_group_record_ids\n                        )\n                        cred_group_record_ids = cred_group_vcrecord_ids_set\n                        records = records + cred_group_vcrecord_list\n                else:\n                    search = holder.search_credentials(\n                        proof_types=proof_type, pd_uri_list=uri_list\n                    )\n                    # Defaults to page_size but would like to include all\n                    # For now, setting to 1000\n                    max_results = 1000\n                    records = await search.fetch(max_results)\n                # Avoiding addition of duplicate records\n                (\n                    vcrecord_list,\n                    vcrecord_ids_set,\n                ) = await self.process_vcrecords_return_list(records, record_ids)\n                record_ids = vcrecord_ids_set\n                credentials_list = credentials_list + vcrecord_list\n        except StorageNotFoundError as err:\n            raise V20PresFormatHandlerError(err)\n        except TypeError as err:\n            LOGGER.error(str(err))\n            responder = self._profile.inject_or(BaseResponder)\n            if responder:\n                report = ProblemReport(\n                    description={\n                        \"en\": (\n                            \"Presentation request not properly formatted,\"\n                            \" TypeError raised on Holder agent.\"\n                        ),\n                        \"code\": ProblemReportReason.ABANDONED.value,\n                    }\n                )\n                if pres_ex_record.thread_id:\n                    report.assign_thread_id(pres_ex_record.thread_id)\n                await responder.send_reply(\n                    report, connection_id=pres_ex_record.connection_id\n                )\n                return\n\n        dif_handler = DIFPresExchHandler(\n            self._profile,\n            pres_signing_did=issuer_id,\n            proof_type=dif_handler_proof_type,\n            reveal_doc=reveal_doc_frame,\n        )\n        try:\n            pres = await dif_handler.create_vp(\n                challenge=challenge,\n                domain=domain,\n                pd=pres_definition,\n                credentials=credentials_list,\n                records_filter=limit_record_ids,\n            )\n            return self.get_format_data(PRES_20, pres)\n        except DIFPresExchError as err:\n            LOGGER.error(str(err))\n            responder = self._profile.inject_or(BaseResponder)\n            if responder:\n                report = ProblemReport(\n                    description={\n                        \"en\": str(err),\n                        \"code\": ProblemReportReason.ABANDONED.value,\n                    }\n                )\n                if pres_ex_record.thread_id:\n                    report.assign_thread_id(pres_ex_record.thread_id)\n                await responder.send_reply(\n                    report, connection_id=pres_ex_record.connection_id\n                )\n\n    async def process_vcrecords_return_list(\n        self, vc_records: Sequence[VCRecord], record_ids: set\n    ) -> Tuple[Sequence[VCRecord], set]:\n        \"\"\"Return list of non-duplicate VCRecords.\"\"\"\n        to_add = []\n        for vc_record in vc_records:\n            if vc_record.record_id not in record_ids:\n                to_add.append(vc_record)\n                record_ids.add(vc_record.record_id)\n        return (to_add, record_ids)\n\n    async def retrieve_uri_list_from_schema_filter(\n        self, schema_uri_groups: Sequence[Sequence[SchemaInputDescriptor]]\n    ) -> Sequence[str]:\n        \"\"\"Retrieve list of schema uri from uri_group.\"\"\"\n        group_schema_uri_list = []\n        for schema_group in schema_uri_groups:\n            uri_list = []\n            for schema in schema_group:\n                uri_list.append(schema.uri)\n            if len(uri_list) > 0:\n                group_schema_uri_list.append(uri_list)\n        return group_schema_uri_list\n\n    async def receive_pres(self, message: V20Pres, pres_ex_record: V20PresExRecord):\n        \"\"\"Receive a presentation, from message in context on manager creation.\"\"\"\n        dif_handler = DIFPresExchHandler(self._profile)\n        dif_proof = message.attachment(DIFPresFormatHandler.format)\n        proof_request = pres_ex_record.pres_request.attachment(\n            DIFPresFormatHandler.format\n        )\n        pres_definition = PresentationDefinition.deserialize(\n            proof_request.get(\"presentation_definition\")\n        )\n        try:\n            await dif_handler.verify_received_pres(pd=pres_definition, pres=dif_proof)\n            return True\n        except DIFPresExchError as err:\n            LOGGER.error(str(err))\n            responder = self._profile.inject_or(BaseResponder)\n            if responder:\n                report = ProblemReport(\n                    description={\n                        \"en\": str(err),\n                        \"code\": ProblemReportReason.ABANDONED.value,\n                    }\n                )\n                if pres_ex_record.thread_id:\n                    report.assign_thread_id(pres_ex_record.thread_id)\n                await responder.send_reply(\n                    report, connection_id=pres_ex_record.connection_id\n                )\n                return False\n\n    async def verify_pres(self, pres_ex_record: V20PresExRecord) -> V20PresExRecord:\n        \"\"\"Verify a presentation.\n\n        Args:\n            pres_ex_record: presentation exchange record\n                with presentation request and presentation to verify\n\n        Returns:\n            presentation exchange record, updated\n\n        \"\"\"\n        dif_proof = pres_ex_record.pres.attachment(DIFPresFormatHandler.format)\n        pres_request = pres_ex_record.pres_request.attachment(\n            DIFPresFormatHandler.format\n        )\n        challenge = None\n        if \"options\" in pres_request:\n            challenge = pres_request[\"options\"].get(\"challenge\", str(uuid4()))\n        if not challenge:\n            challenge = str(uuid4())\n        if isinstance(dif_proof, Sequence):\n            for proof in dif_proof:\n                pres_ver_result = await verify_presentation(\n                    presentation=proof,\n                    suites=await self._get_all_suites(),\n                    document_loader=self._profile.inject(DocumentLoader),\n                    challenge=challenge,\n                )\n                if not pres_ver_result.verified:\n                    break\n        else:\n            pres_ver_result = await verify_presentation(\n                presentation=dif_proof,\n                suites=await self._get_all_suites(),\n                document_loader=self._profile.inject(DocumentLoader),\n                challenge=challenge,\n            )\n        pres_ex_record.verified = json.dumps(pres_ver_result.verified)\n        return pres_ex_record\n", "\"\"\"Verifiable Credential and Presentation verification methods.\"\"\"\n\nimport asyncio\nfrom typing import List\nfrom pyld.jsonld import JsonLdProcessor\n\nfrom ..ld_proofs import (\n    LinkedDataProof,\n    CredentialIssuancePurpose,\n    DocumentLoaderMethod,\n    ProofPurpose,\n    AuthenticationProofPurpose,\n    verify as ld_proofs_verify,\n    DocumentVerificationResult,\n    LinkedDataProofException,\n)\nfrom .models.credential import VerifiableCredentialSchema\nfrom .validation_result import PresentationVerificationResult\n\n\nasync def _verify_credential(\n    *,\n    credential: dict,\n    suites: List[LinkedDataProof],\n    document_loader: DocumentLoaderMethod,\n    purpose: ProofPurpose = None,\n) -> DocumentVerificationResult:\n    \"\"\"Verify credential structure, proof purpose and signature.\"\"\"\n\n    # Validate credential structure\n    errors = VerifiableCredentialSchema().validate(credential)\n    if len(errors) > 0:\n        raise LinkedDataProofException(\n            f\"Unable to verify credential with invalid structure: {errors}\"\n        )\n\n    if not purpose:\n        purpose = CredentialIssuancePurpose()\n\n    result = await ld_proofs_verify(\n        document=credential,\n        suites=suites,\n        purpose=purpose,\n        document_loader=document_loader,\n    )\n\n    return result\n\n\nasync def verify_credential(\n    *,\n    credential: dict,\n    suites: List[LinkedDataProof],\n    document_loader: DocumentLoaderMethod,\n    purpose: ProofPurpose = None,\n) -> DocumentVerificationResult:\n    \"\"\"Verify credential structure, proof purpose and signature.\n\n    Args:\n        credential (dict): The credential to verify\n        suites (List[LinkedDataProof]): The signature suites to verify with\n        document_loader (DocumentLoader): Document loader used for resolving of documents\n        purpose (ProofPurpose, optional): Proof purpose to use.\n            Defaults to CredentialIssuancePurpose\n\n    Returns:\n        DocumentVerificationResult: The result of the verification. Verified property\n            indicates whether the verification was successful\n\n    \"\"\"\n    try:\n        return await _verify_credential(\n            credential=credential,\n            document_loader=document_loader,\n            suites=suites,\n            purpose=purpose,\n        )\n    except Exception as e:\n        return DocumentVerificationResult(\n            verified=False, document=credential, errors=[e]\n        )\n\n\nasync def _verify_presentation(\n    *,\n    presentation: dict,\n    suites: List[LinkedDataProof],\n    document_loader: DocumentLoaderMethod,\n    challenge: str = None,\n    domain: str = None,\n    purpose: ProofPurpose = None,\n):\n    \"\"\"Verify presentation structure, credentials, proof purpose and signature.\"\"\"\n\n    if not purpose and not challenge:\n        raise LinkedDataProofException(\n            'A \"challenge\" param is required for AuthenticationProofPurpose.'\n        )\n    elif not purpose:\n        purpose = AuthenticationProofPurpose(challenge=challenge, domain=domain)\n\n    # TODO validate presentation structure here\n    if \"proof\" not in presentation:\n        raise LinkedDataProofException('presentation must contain \"proof\"')\n\n    presentation_result = await ld_proofs_verify(\n        document=presentation,\n        suites=suites,\n        purpose=purpose,\n        document_loader=document_loader,\n    )\n\n    credential_results = None\n\n    credentials = JsonLdProcessor.get_values(presentation, \"verifiableCredential\")\n    credential_results = await asyncio.gather(\n        *[\n            verify_credential(\n                credential=credential,\n                suites=suites,\n                document_loader=document_loader,\n                # FIXME: we don't want to interhit the authentication purpose\n                # from the presentation. However we do want to have subject\n                # authentication I guess\n                # purpose=purpose,\n            )\n            for credential in credentials\n        ]\n    )\n\n    credentials_verified = all(result.verified for result in credential_results)\n    verified = credentials_verified and presentation_result.verified\n\n    return PresentationVerificationResult(\n        verified=verified,\n        presentation_result=presentation_result,\n        credential_results=credential_results,\n        errors=presentation_result.errors,\n    )\n\n\nasync def verify_presentation(\n    *,\n    presentation: dict,\n    suites: List[LinkedDataProof],\n    document_loader: DocumentLoaderMethod,\n    purpose: ProofPurpose = None,\n    challenge: str = None,\n    domain: str = None,\n) -> PresentationVerificationResult:\n    \"\"\"Verify presentation structure, credentials, proof purpose and signature.\n\n    Args:\n        presentation (dict): The presentation to verify\n        suites (List[LinkedDataProof]): The signature suites to verify with\n        document_loader (DocumentLoader): Document loader used for resolving of documents\n        purpose (ProofPurpose, optional): Proof purpose to use.\n            Defaults to AuthenticationProofPurpose\n        challenge (str, optional): The challenge to use for authentication.\n            Required if purpose is not passed, not used if purpose is passed\n        domain (str, optional): Domain to use for the authentication proof purpose.\n            Not used if purpose is passed\n\n    Returns:\n        PresentationVerificationResult: The result of the verification. Verified property\n            indicates whether the verification was successful\n\n    \"\"\"\n\n    # TODO: I think we should add some sort of options to authenticate the subject id\n    # to the presentation verification method controller\n\n    try:\n        return await _verify_presentation(\n            presentation=presentation,\n            challenge=challenge,\n            purpose=purpose,\n            suites=suites,\n            domain=domain,\n            document_loader=document_loader,\n        )\n    except Exception as e:\n        return PresentationVerificationResult(verified=False, errors=[e])\n\n\n__all__ = [\"verify_presentation\", \"verify_credential\"]\n"], "filenames": ["aries_cloudagent/protocols/present_proof/v2_0/formats/dif/handler.py", "aries_cloudagent/vc/vc_ld/verify.py"], "buggy_code_start_loc": [191, 114], "buggy_code_end_loc": [197, 133], "fixing_code_start_loc": [190, 113], "fixing_code_end_loc": [198, 133], "type": "CWE-347", "message": "Hyperledger Aries Cloud Agent Python (ACA-Py) is a foundation for building decentralized identity applications and services running in non-mobile environments. When verifying W3C Format Verifiable Credentials using JSON-LD with Linked Data Proofs (LDP-VCs), the result of verifying the presentation `document.proof` was not factored into the final `verified` value (`true`/`false`) on the presentation record. The flaw enables holders of W3C Format Verifiable Credentials using JSON-LD with Linked Data Proofs (LDPs) to present incorrectly constructed proofs, and allows malicious verifiers to save and replay a presentation from such holders as their own. This vulnerability has been present since version 0.7.0 and fixed in version 0.10.5.", "other": {"cve": {"id": "CVE-2024-21669", "sourceIdentifier": "security-advisories@github.com", "published": "2024-01-11T06:15:44.067", "lastModified": "2024-01-20T18:45:17.257", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Hyperledger Aries Cloud Agent Python (ACA-Py) is a foundation for building decentralized identity applications and services running in non-mobile environments. When verifying W3C Format Verifiable Credentials using JSON-LD with Linked Data Proofs (LDP-VCs), the result of verifying the presentation `document.proof` was not factored into the final `verified` value (`true`/`false`) on the presentation record. The flaw enables holders of W3C Format Verifiable Credentials using JSON-LD with Linked Data Proofs (LDPs) to present incorrectly constructed proofs, and allows malicious verifiers to save and replay a presentation from such holders as their own. This vulnerability has been present since version 0.7.0 and fixed in version 0.10.5."}, {"lang": "es", "value": "Hyperledger Aries Cloud Agent Python (ACA-Py) es una base para crear aplicaciones y servicios de identidad descentralizados que se ejecutan en entornos no m\u00f3viles. Al verificar las credenciales verificables en formato W3C usando JSON-LD con Linked Data Proofs (LDP-VC), el resultado de verificar la presentaci\u00f3n `document.proof` no se tuvo en cuenta en el valor final `verified` (`true`/`false`) en el acta de presentaci\u00f3n. La falla permite a los titulares de credenciales verificables en formato W3C que utilizan JSON-LD con pruebas de datos vinculados (LDP) presentar pruebas construidas incorrectamente y permite a verificadores maliciosos guardar y reproducir una presentaci\u00f3n de dichos titulares como propia. Esta vulnerabilidad ha estado presente desde la versi\u00f3n 0.7.0 y se corrigi\u00f3 en la versi\u00f3n 0.10.5."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:C/C:H/I:H/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "LOW", "baseScore": 9.9, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.1, "impactScore": 6.0}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-347"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:hyperledger:aries_cloud_agent:*:*:*:*:*:python:*:*", "versionStartIncluding": "0.7.0", "versionEndExcluding": "0.10.5", "matchCriteriaId": "8E7EDC2A-7233-4326-82B1-E896F8B52925"}, {"vulnerable": true, "criteria": "cpe:2.3:a:hyperledger:aries_cloud_agent:0.11.0:rc1:*:*:*:python:*:*", "matchCriteriaId": "300CAB56-D1C2-4D96-BBBB-C429E9364E94"}, {"vulnerable": true, "criteria": "cpe:2.3:a:hyperledger:aries_cloud_agent:0.11.0:rc2:*:*:*:python:*:*", "matchCriteriaId": "A99DFE1B-4372-43D1-A8FA-2C4F6B6FB951"}]}]}], "references": [{"url": "https://github.com/hyperledger/aries-cloudagent-python/commit/0b01ffffc0789205ac990292f97238614c9fd293", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/hyperledger/aries-cloudagent-python/commit/4c45244e2085aeff2f038dd771710e92d7682ff2", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/hyperledger/aries-cloudagent-python/releases/tag/0.10.5", "source": "security-advisories@github.com", "tags": ["Release Notes"]}, {"url": "https://github.com/hyperledger/aries-cloudagent-python/releases/tag/0.11.0", "source": "security-advisories@github.com", "tags": ["Release Notes"]}, {"url": "https://github.com/hyperledger/aries-cloudagent-python/security/advisories/GHSA-97x9-59rv-q5pm", "source": "security-advisories@github.com", "tags": ["Exploit", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/hyperledger/aries-cloudagent-python/commit/0b01ffffc0789205ac990292f97238614c9fd293"}}