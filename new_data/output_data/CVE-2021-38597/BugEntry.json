{"buggy_code": ["/* asn.c\n *\n * Copyright (C) 2006-2021 wolfSSL Inc.\n *\n * This file is part of wolfSSL.\n *\n * wolfSSL is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * wolfSSL is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1335, USA\n */\n\n/*\n\nDESCRIPTION\nThis library provides the interface to Abstract Syntax Notation One (ASN.1) objects.\nASN.1 is a standard interface description language for defining data structures\nthat can be serialized and deserialized in a cross-platform way.\n\n*/\n#ifdef HAVE_CONFIG_H\n    #include <config.h>\n#endif\n\n#include <wolfssl/wolfcrypt/settings.h>\n\n/*\nASN Options:\n * NO_ASN_TIME: Disables time parts of the ASN code for systems without an RTC\n    or wishing to save space.\n * IGNORE_NAME_CONSTRAINTS: Skip ASN name checks.\n * ASN_DUMP_OID: Allows dump of OID information for debugging.\n * RSA_DECODE_EXTRA: Decodes extra information in RSA public key.\n * WOLFSSL_CERT_GEN: Cert generation. Saves extra certificate info in GetName.\n * WOLFSSL_NO_ASN_STRICT: Disable strict RFC compliance checks to\n    restore 3.13.0 behavior.\n * WOLFSSL_NO_OCSP_OPTIONAL_CERTS: Skip optional OCSP certs (responder issuer\n    must still be trusted)\n * WOLFSSL_NO_TRUSTED_CERTS_VERIFY: Workaround for situation where entire cert\n    chain is not loaded. This only matches on subject and public key and\n    does not perform a PKI validation, so it is not a secure solution.\n    Only enabled for OCSP.\n * WOLFSSL_NO_OCSP_ISSUER_CHECK: Can be defined for backwards compatibility to\n    disable checking of OCSP subject hash with issuer hash.\n * WOLFSSL_SMALL_CERT_VERIFY: Verify the certificate signature without using\n    DecodedCert. Doubles up on some code but allows smaller dynamic memory\n    usage.\n * WOLFSSL_NO_OCSP_DATE_CHECK: Disable date checks for OCSP responses. This\n    may be required when the system's real-time clock is not very accurate.\n    It is recommended to enforce the nonce check instead if possible.\n * WOLFSSL_FORCE_OCSP_NONCE_CHECK: Require nonces to be available in OCSP\n    responses. The nonces are optional and may not be supported by all\n    responders. If it can be ensured that the used responder sends nonces this\n    option may improve security.\n*/\n\n#ifndef NO_ASN\n\n#include <wolfssl/wolfcrypt/asn.h>\n#include <wolfssl/wolfcrypt/coding.h>\n#include <wolfssl/wolfcrypt/md2.h>\n#include <wolfssl/wolfcrypt/hmac.h>\n#include <wolfssl/wolfcrypt/error-crypt.h>\n#include <wolfssl/wolfcrypt/pwdbased.h>\n#include <wolfssl/wolfcrypt/des3.h>\n#include <wolfssl/wolfcrypt/aes.h>\n#include <wolfssl/wolfcrypt/rc2.h>\n#include <wolfssl/wolfcrypt/wc_encrypt.h>\n#include <wolfssl/wolfcrypt/logging.h>\n\n#include <wolfssl/wolfcrypt/random.h>\n#include <wolfssl/wolfcrypt/hash.h>\n#ifdef NO_INLINE\n    #include <wolfssl/wolfcrypt/misc.h>\n#else\n    #define WOLFSSL_MISC_INCLUDED\n    #include <wolfcrypt/src/misc.c>\n#endif\n\n#ifndef NO_RC4\n    #include <wolfssl/wolfcrypt/arc4.h>\n#endif\n\n#ifdef HAVE_NTRU\n    #include \"libntruencrypt/ntru_crypto.h\"\n#endif\n\n#if defined(WOLFSSL_SHA512) || defined(WOLFSSL_SHA384)\n    #include <wolfssl/wolfcrypt/sha512.h>\n#endif\n\n#ifndef NO_SHA256\n    #include <wolfssl/wolfcrypt/sha256.h>\n#endif\n\n#ifdef HAVE_ECC\n    #include <wolfssl/wolfcrypt/ecc.h>\n#endif\n\n#ifdef HAVE_ED25519\n    #include <wolfssl/wolfcrypt/ed25519.h>\n#endif\n\n#ifdef HAVE_ED448\n    #include <wolfssl/wolfcrypt/ed448.h>\n#endif\n\n#ifdef WOLFSSL_QNX_CAAM\n\t#include <wolfssl/wolfcrypt/port/caam/wolfcaam.h>\n#endif\n\n#ifndef NO_RSA\n    #include <wolfssl/wolfcrypt/rsa.h>\n#if defined(WOLFSSL_XILINX_CRYPT) || defined(WOLFSSL_CRYPTOCELL)\nextern int wc_InitRsaHw(RsaKey* key);\n#endif\n#endif\n\n#ifndef NO_DSA\n    #include <wolfssl/wolfcrypt/dsa.h>\n#else\n    typedef void* DsaKey;\n#endif\n\n#ifdef WOLF_CRYPTO_CB\n    #include <wolfssl/wolfcrypt/cryptocb.h>\n#endif\n\n#if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)\n    #include <wolfssl/openssl/objects.h>\n#endif\n\n#ifdef _MSC_VER\n    /* 4996 warning to use MS extensions e.g., strcpy_s instead of XSTRNCPY */\n    #pragma warning(disable: 4996)\n#endif\n\n#define ERROR_OUT(err, eLabel) { ret = (err); goto eLabel; }\n\n#if !defined(NO_SKID) && (!defined(HAVE_FIPS) || !defined(HAVE_FIPS_VERSION))\n    #if !defined(HAVE_SELFTEST) || (defined(HAVE_SELFTEST) && \\\n                                   (!defined(HAVE_SELFTEST_VERSION) || \\\n                                    HAVE_SELFTEST_VERSION < 2))\n    #ifndef WOLFSSL_AES_KEY_SIZE_ENUM\n    #define WOLFSSL_AES_KEY_SIZE_ENUM\n    enum Asn_Misc {\n        AES_IV_SIZE         = 16,\n        AES_128_KEY_SIZE    = 16,\n        AES_192_KEY_SIZE    = 24,\n        AES_256_KEY_SIZE    = 32\n    };\n    #endif\n    #endif /* HAVE_SELFTEST */\n#endif\n#ifdef WOLFSSL_RENESAS_TSIP_TLS\nvoid tsip_inform_key_position(const word32 key_n_start,\n                const word32 key_n_len, const word32 key_e_start,\n                const word32 key_e_len);\nint tsip_tls_CertVerify(const byte *cert, word32 certSz,\n                        const byte *signature, word32 sigSz,\n                        word32 key_n_start, word32 key_n_len,\n                        word32 key_e_start, word32 key_e_len,\n                        byte *tsip_encRsaKeyIdx);\n#endif\nint GetLength(const byte* input, word32* inOutIdx, int* len,\n                           word32 maxIdx)\n{\n    return GetLength_ex(input, inOutIdx, len, maxIdx, 1);\n}\n\n\n/* give option to check length value found against index. 1 to check 0 to not */\nint GetLength_ex(const byte* input, word32* inOutIdx, int* len,\n                           word32 maxIdx, int check)\n{\n    int     length = 0;\n    word32  idx = *inOutIdx;\n    byte    b;\n\n    *len = 0;    /* default length */\n\n    if ((idx + 1) > maxIdx) {   /* for first read */\n        WOLFSSL_MSG(\"GetLength bad index on input\");\n        return BUFFER_E;\n    }\n\n    b = input[idx++];\n    if (b >= ASN_LONG_LENGTH) {\n        word32 bytes = b & 0x7F;\n\n        if ((idx + bytes) > maxIdx) {   /* for reading bytes */\n            WOLFSSL_MSG(\"GetLength bad long length\");\n            return BUFFER_E;\n        }\n\n        if (bytes > sizeof(length)) {\n            return ASN_PARSE_E;\n        }\n        while (bytes--) {\n            b = input[idx++];\n            length = (length << 8) | b;\n        }\n        if (length < 0) {\n            return ASN_PARSE_E;\n        }\n    }\n    else\n        length = b;\n\n    if (check && (idx + length) > maxIdx) {   /* for user of length */\n        WOLFSSL_MSG(\"GetLength value exceeds buffer length\");\n        return BUFFER_E;\n    }\n\n    *inOutIdx = idx;\n    if (length > 0)\n        *len = length;\n\n    return length;\n}\n\n\n/* input : buffer to read from\n * inOutIdx : index to start reading from, gets advanced by 1 if successful\n * maxIdx : maximum index value\n * tag : ASN tag value found\n *\n * returns 0 on success\n */\nint GetASNTag(const byte* input, word32* inOutIdx, byte* tag, word32 maxIdx)\n{\n    word32 idx;\n\n    if (tag == NULL || inOutIdx == NULL || input == NULL) {\n        return BAD_FUNC_ARG;\n    }\n\n    idx = *inOutIdx;\n    if (idx + ASN_TAG_SZ > maxIdx) {\n        WOLFSSL_MSG(\"Buffer too small for ASN tag\");\n        return BUFFER_E;\n    }\n\n    *tag = input[idx];\n    *inOutIdx = idx + ASN_TAG_SZ;\n    return 0;\n}\n\n\nstatic int GetASNHeader_ex(const byte* input, byte tag, word32* inOutIdx, int* len,\n                        word32 maxIdx, int check)\n{\n    word32 idx = *inOutIdx;\n    byte   tagFound;\n    int    length;\n\n    if (GetASNTag(input, &idx, &tagFound, maxIdx) != 0)\n        return ASN_PARSE_E;\n\n    if (tagFound != tag)\n        return ASN_PARSE_E;\n\n    if (GetLength_ex(input, &idx, &length, maxIdx, check) < 0)\n        return ASN_PARSE_E;\n\n    *len      = length;\n    *inOutIdx = idx;\n    return length;\n}\n\n\n/* Get the DER/BER encoding of an ASN.1 header.\n *\n * input     Buffer holding DER/BER encoded data.\n * tag       ASN.1 tag value expected in header.\n * inOutIdx  Current index into buffer to parse.\n * len       The number of bytes in the ASN.1 data.\n * maxIdx    Length of data in buffer.\n * returns BUFFER_E when there is not enough data to parse.\n *         ASN_PARSE_E when the expected tag is not found or length is invalid.\n *         Otherwise, the number of bytes in the ASN.1 data.\n */\nstatic int GetASNHeader(const byte* input, byte tag, word32* inOutIdx, int* len,\n                        word32 maxIdx)\n{\n    return GetASNHeader_ex(input, tag, inOutIdx, len, maxIdx, 1);\n}\n\nstatic int GetHeader(const byte* input, byte* tag, word32* inOutIdx, int* len,\n                     word32 maxIdx, int check)\n{\n    word32 idx = *inOutIdx;\n    int    length;\n\n    if ((idx + 1) > maxIdx)\n        return BUFFER_E;\n\n    *tag = input[idx++];\n\n    if (GetLength_ex(input, &idx, &length, maxIdx, check) < 0)\n        return ASN_PARSE_E;\n\n    *len      = length;\n    *inOutIdx = idx;\n    return length;\n}\n\nint GetSequence(const byte* input, word32* inOutIdx, int* len,\n                           word32 maxIdx)\n{\n    return GetASNHeader(input, ASN_SEQUENCE | ASN_CONSTRUCTED, inOutIdx, len,\n                        maxIdx);\n}\n\n\nint GetSequence_ex(const byte* input, word32* inOutIdx, int* len,\n                           word32 maxIdx, int check)\n{\n    return GetASNHeader_ex(input, ASN_SEQUENCE | ASN_CONSTRUCTED, inOutIdx, len,\n                        maxIdx, check);\n}\n\n\nint GetSet(const byte* input, word32* inOutIdx, int* len,\n                        word32 maxIdx)\n{\n    return GetASNHeader(input, ASN_SET | ASN_CONSTRUCTED, inOutIdx, len,\n                        maxIdx);\n}\n\n\nint GetSet_ex(const byte* input, word32* inOutIdx, int* len,\n                        word32 maxIdx, int check)\n{\n    return GetASNHeader_ex(input, ASN_SET | ASN_CONSTRUCTED, inOutIdx, len,\n                        maxIdx, check);\n}\n\n/* Get the DER/BER encoded ASN.1 NULL element.\n * Ensure that the all fields are as expected and move index past the element.\n *\n * input     Buffer holding DER/BER encoded data.\n * inOutIdx  Current index into buffer to parse.\n * maxIdx    Length of data in buffer.\n * returns BUFFER_E when there is not enough data to parse.\n *         ASN_TAG_NULL_E when the NULL tag is not found.\n *         ASN_EXPECT_0_E when the length is not zero.\n *         Otherwise, 0 to indicate success.\n */\nstatic int GetASNNull(const byte* input, word32* inOutIdx, word32 maxIdx)\n{\n    word32 idx = *inOutIdx;\n    byte   b;\n\n    if ((idx + 2) > maxIdx)\n        return BUFFER_E;\n\n    b = input[idx++];\n    if (b != ASN_TAG_NULL)\n        return ASN_TAG_NULL_E;\n\n    if (input[idx++] != 0)\n        return ASN_EXPECT_0_E;\n\n    *inOutIdx = idx;\n    return 0;\n}\n\n/* Set the DER/BER encoding of the ASN.1 NULL element.\n *\n * output  Buffer to write into.\n * returns the number of bytes added to the buffer.\n */\nstatic int SetASNNull(byte* output)\n{\n    output[0] = ASN_TAG_NULL;\n    output[1] = 0;\n\n    return 2;\n}\n\n#ifndef NO_CERTS\n/* Get the DER/BER encoding of an ASN.1 BOOLEAN.\n *\n * input     Buffer holding DER/BER encoded data.\n * inOutIdx  Current index into buffer to parse.\n * maxIdx    Length of data in buffer.\n * returns BUFFER_E when there is not enough data to parse.\n *         ASN_PARSE_E when the BOOLEAN tag is not found or length is not 1.\n *         Otherwise, 0 to indicate the value was false and 1 to indicate true.\n */\nstatic int GetBoolean(const byte* input, word32* inOutIdx, word32 maxIdx)\n{\n    word32 idx = *inOutIdx;\n    byte   b;\n\n    if ((idx + 3) > maxIdx)\n        return BUFFER_E;\n\n    b = input[idx++];\n    if (b != ASN_BOOLEAN)\n        return ASN_PARSE_E;\n\n    if (input[idx++] != 1)\n        return ASN_PARSE_E;\n\n    b = input[idx++] != 0;\n\n    *inOutIdx = idx;\n    return b;\n}\n#endif /* !NO_CERTS*/\n#ifdef ASN1_SET_BOOLEAN\n/* Set the DER/BER encoding of the ASN.1 NULL element.\n * Note: Function not required as yet.\n *\n * val     Boolean value to encode.\n * output  Buffer to write into.\n * returns the number of bytes added to the buffer.\n */\nstatic int SetBoolean(int val, byte* output)\n{\n    output[0] = ASN_BOOLEAN;\n    output[1] = 1;\n    output[2] = val ? -1 : 0;\n\n    return 3;\n}\n#endif\n\n/* Get the DER/BER encoding of an ASN.1 OCTET_STRING header.\n *\n * input     Buffer holding DER/BER encoded data.\n * inOutIdx  Current index into buffer to parse.\n * len       The number of bytes in the ASN.1 data.\n * maxIdx    Length of data in buffer.\n * returns BUFFER_E when there is not enough data to parse.\n *         ASN_PARSE_E when the OCTET_STRING tag is not found or length is\n *         invalid.\n *         Otherwise, the number of bytes in the ASN.1 data.\n */\nint GetOctetString(const byte* input, word32* inOutIdx, int* len,\n                          word32 maxIdx)\n{\n    return GetASNHeader(input, ASN_OCTET_STRING, inOutIdx, len, maxIdx);\n}\n\n/* Get the DER/BER encoding of an ASN.1 INTEGER header.\n * Removes the leading zero byte when found.\n *\n * input     Buffer holding DER/BER encoded data.\n * inOutIdx  Current index into buffer to parse.\n * len       The number of bytes in the ASN.1 data (excluding any leading zero).\n * maxIdx    Length of data in buffer.\n * returns BUFFER_E when there is not enough data to parse.\n *         ASN_PARSE_E when the INTEGER tag is not found, length is invalid,\n *         or invalid use of or missing leading zero.\n *         Otherwise, 0 to indicate success.\n */\nstatic int GetASNInt(const byte* input, word32* inOutIdx, int* len,\n                     word32 maxIdx)\n{\n    int    ret;\n\n    ret = GetASNHeader(input, ASN_INTEGER, inOutIdx, len, maxIdx);\n    if (ret < 0)\n        return ret;\n\n    if (*len > 0) {\n\n#ifndef WOLFSSL_ASN_INT_LEAD_0_ANY\n        /* check for invalid padding on negative integer.\n         * c.f. X.690 (ISO/IEC 8825-2:2003 (E)) 10.4.6; RFC 5280 4.1\n         */\n        if (*len > 1) {\n            if ((input[*inOutIdx] == 0xff) && (input[*inOutIdx + 1] & 0x80))\n                return ASN_PARSE_E;\n        }\n#endif\n\n        /* remove leading zero, unless there is only one 0x00 byte */\n        if ((input[*inOutIdx] == 0x00) && (*len > 1)) {\n            (*inOutIdx)++;\n            (*len)--;\n\n#ifndef WOLFSSL_ASN_INT_LEAD_0_ANY\n            if (*len > 0 && (input[*inOutIdx] & 0x80) == 0)\n                return ASN_PARSE_E;\n#endif\n        }\n    }\n\n    return 0;\n}\n\n#ifndef NO_CERTS\n/* Get the DER/BER encoding of an ASN.1 INTEGER that has a value of no more than\n * 7 bits.\n *\n * input     Buffer holding DER/BER encoded data.\n * inOutIdx  Current index into buffer to parse.\n * maxIdx    Length of data in buffer.\n * returns BUFFER_E when there is not enough data to parse.\n *         ASN_PARSE_E when the INTEGER tag is not found or length is invalid.\n *         Otherwise, the 7-bit value.\n */\nstatic int GetInteger7Bit(const byte* input, word32* inOutIdx, word32 maxIdx)\n{\n    word32 idx = *inOutIdx;\n    byte   b;\n\n    if ((idx + 3) > maxIdx)\n        return BUFFER_E;\n\n    if (GetASNTag(input, &idx, &b, maxIdx) != 0)\n        return ASN_PARSE_E;\n    if (b != ASN_INTEGER)\n        return ASN_PARSE_E;\n    if (input[idx++] != 1)\n        return ASN_PARSE_E;\n    b = input[idx++];\n\n    *inOutIdx = idx;\n    return b;\n}\n#endif /* !NO_CERTS */\n\n#if !defined(NO_DSA) && !defined(NO_SHA)\nstatic const char sigSha1wDsaName[] = \"SHAwDSA\";\nstatic const char sigSha256wDsaName[] = \"SHA256wDSA\";\n#endif /* NO_DSA */\n#ifndef NO_RSA\n#ifdef WOLFSSL_MD2\n    static const char  sigMd2wRsaName[] = \"md2WithRSAEncryption\";\n#endif\n#ifndef NO_MD5\n    static const char  sigMd5wRsaName[] = \"md5WithRSAEncryption\";\n#endif\n#ifndef NO_SHA\n    static const char  sigSha1wRsaName[] = \"sha1WithRSAEncryption\";\n#endif\n#ifdef WOLFSSL_SHA224\n    static const char sigSha224wRsaName[] = \"sha224WithRSAEncryption\";\n#endif\n#ifndef NO_SHA256\n    static const char sigSha256wRsaName[] = \"sha256WithRSAEncryption\";\n#endif\n#ifdef WOLFSSL_SHA384\n    static const char sigSha384wRsaName[] = \"sha384WithRSAEncryption\";\n#endif\n#ifdef WOLFSSL_SHA512\n    static const char sigSha512wRsaName[] = \"sha512WithRSAEncryption\";\n#endif\n#ifdef WOLFSSL_SHA3\n#ifndef WOLFSSL_NOSHA3_224\n    static const char sigSha3_224wRsaName[] = \"sha3_224WithRSAEncryption\";\n#endif\n#ifndef WOLFSSL_NOSHA3_256\n    static const char sigSha3_256wRsaName[] = \"sha3_256WithRSAEncryption\";\n#endif\n#ifndef WOLFSSL_NOSHA3_384\n    static const char sigSha3_384wRsaName[] = \"sha3_384WithRSAEncryption\";\n#endif\n#ifndef WOLFSSL_NOSHA3_512\n    static const char sigSha3_512wRsaName[] = \"sha3_512WithRSAEncryption\";\n#endif\n#endif\n#endif /* NO_RSA */\n#ifdef HAVE_ECC\n#ifndef NO_SHA\n    static const char sigSha1wEcdsaName[] = \"SHAwECDSA\";\n#endif\n#ifdef WOLFSSL_SHA224\n    static const char sigSha224wEcdsaName[] = \"SHA224wECDSA\";\n#endif\n#ifndef NO_SHA256\n    static const char sigSha256wEcdsaName[] = \"SHA256wECDSA\";\n#endif\n#ifdef WOLFSSL_SHA384\n    static const char sigSha384wEcdsaName[] = \"SHA384wECDSA\";\n#endif\n#ifdef WOLFSSL_SHA512\n    static const char sigSha512wEcdsaName[] = \"SHA512wECDSA\";\n#endif\n#ifdef WOLFSSL_SHA3\n#ifndef WOLFSSL_NOSHA3_224\n    static const char sigSha3_224wEcdsaName[] = \"SHA3_224wECDSA\";\n#endif\n#ifndef WOLFSSL_NOSHA3_256\n    static const char sigSha3_256wEcdsaName[] = \"SHA3_256wECDSA\";\n#endif\n#ifndef WOLFSSL_NOSHA3_384\n    static const char sigSha3_384wEcdsaName[] = \"SHA3_384wECDSA\";\n#endif\n#ifndef WOLFSSL_NOSHA3_512\n    static const char sigSha3_512wEcdsaName[] = \"SHA3_512wECDSA\";\n#endif\n#endif\n#endif /* HAVE_ECC */\nstatic const char sigUnknownName[] = \"Unknown\";\n\n\n/* Get the human readable string for a signature type\n *\n * oid  Oid value for signature\n */\nconst char* GetSigName(int oid) {\n    switch (oid) {\n    #if !defined(NO_DSA) && !defined(NO_SHA)\n        case CTC_SHAwDSA:\n            return sigSha1wDsaName;\n        case CTC_SHA256wDSA:\n            return sigSha256wDsaName;\n    #endif /* NO_DSA && NO_SHA */\n    #ifndef NO_RSA\n        #ifdef WOLFSSL_MD2\n        case CTC_MD2wRSA:\n            return sigMd2wRsaName;\n        #endif\n        #ifndef NO_MD5\n        case CTC_MD5wRSA:\n            return sigMd5wRsaName;\n        #endif\n        #ifndef NO_SHA\n        case CTC_SHAwRSA:\n            return sigSha1wRsaName;\n        #endif\n        #ifdef WOLFSSL_SHA224\n        case CTC_SHA224wRSA:\n            return sigSha224wRsaName;\n        #endif\n        #ifndef NO_SHA256\n        case CTC_SHA256wRSA:\n            return sigSha256wRsaName;\n        #endif\n        #ifdef WOLFSSL_SHA384\n        case CTC_SHA384wRSA:\n            return sigSha384wRsaName;\n        #endif\n        #ifdef WOLFSSL_SHA512\n        case CTC_SHA512wRSA:\n            return sigSha512wRsaName;\n        #endif\n        #ifdef WOLFSSL_SHA3\n        #ifndef WOLFSSL_NOSHA3_224\n        case CTC_SHA3_224wRSA:\n            return sigSha3_224wRsaName;\n        #endif\n        #ifndef WOLFSSL_NOSHA3_256\n        case CTC_SHA3_256wRSA:\n            return sigSha3_256wRsaName;\n        #endif\n        #ifndef WOLFSSL_NOSHA3_384\n        case CTC_SHA3_384wRSA:\n            return sigSha3_384wRsaName;\n        #endif\n        #ifndef WOLFSSL_NOSHA3_512\n        case CTC_SHA3_512wRSA:\n            return sigSha3_512wRsaName;\n        #endif\n        #endif\n    #endif /* NO_RSA */\n    #ifdef HAVE_ECC\n        #ifndef NO_SHA\n        case CTC_SHAwECDSA:\n            return sigSha1wEcdsaName;\n        #endif\n        #ifdef WOLFSSL_SHA224\n        case CTC_SHA224wECDSA:\n            return sigSha224wEcdsaName;\n        #endif\n        #ifndef NO_SHA256\n        case CTC_SHA256wECDSA:\n            return sigSha256wEcdsaName;\n        #endif\n        #ifdef WOLFSSL_SHA384\n        case CTC_SHA384wECDSA:\n            return sigSha384wEcdsaName;\n        #endif\n        #ifdef WOLFSSL_SHA512\n        case CTC_SHA512wECDSA:\n            return sigSha512wEcdsaName;\n        #endif\n        #ifdef WOLFSSL_SHA3\n        #ifndef WOLFSSL_NOSHA3_224\n        case CTC_SHA3_224wECDSA:\n            return sigSha3_224wEcdsaName;\n        #endif\n        #ifndef WOLFSSL_NOSHA3_256\n        case CTC_SHA3_256wECDSA:\n            return sigSha3_256wEcdsaName;\n        #endif\n        #ifndef WOLFSSL_NOSHA3_384\n        case CTC_SHA3_384wECDSA:\n            return sigSha3_384wEcdsaName;\n        #endif\n        #ifndef WOLFSSL_NOSHA3_512\n        case CTC_SHA3_512wECDSA:\n            return sigSha3_512wEcdsaName;\n        #endif\n        #endif\n    #endif /* HAVE_ECC */\n        default:\n            return sigUnknownName;\n    }\n}\n\n\n#if !defined(NO_DSA) || defined(HAVE_ECC) || !defined(NO_CERTS) || \\\n   (!defined(NO_RSA) && \\\n        (defined(WOLFSSL_CERT_GEN) || \\\n        ((defined(WOLFSSL_KEY_GEN) || defined(OPENSSL_EXTRA)) && !defined(HAVE_USER_RSA))))\n/* Set the DER/BER encoding of the ASN.1 INTEGER header.\n *\n * len        Length of data to encode.\n * firstByte  First byte of data, most significant byte of integer, to encode.\n * output     Buffer to write into.\n * returns the number of bytes added to the buffer.\n */\nint SetASNInt(int len, byte firstByte, byte* output)\n{\n    word32 idx = 0;\n\n    if (output)\n        output[idx] = ASN_INTEGER;\n    idx++;\n    if (firstByte & 0x80)\n        len++;\n    idx += SetLength(len, output ? output + idx : NULL);\n    if (firstByte & 0x80) {\n        if (output)\n            output[idx] = 0x00;\n        idx++;\n    }\n\n    return idx;\n}\n#endif\n\n#if !defined(NO_DSA) || defined(HAVE_ECC) || (defined(WOLFSSL_CERT_GEN) && \\\n    !defined(NO_RSA)) || ((defined(WOLFSSL_KEY_GEN) || \\\n    (!defined(NO_DH) && defined(WOLFSSL_DH_EXTRA)) || \\\n    defined(OPENSSL_EXTRA)) && !defined(NO_RSA) && !defined(HAVE_USER_RSA))\n/* Set the DER/BER encoding of the ASN.1 INTEGER element with an mp_int.\n * The number is assumed to be positive.\n *\n * n       Multi-precision integer to encode.\n * maxSz   Maximum size of the encoded integer.\n *         A negative value indicates no check of length requested.\n * output  Buffer to write into.\n * returns BUFFER_E when the data is too long for the buffer.\n *         MP_TO_E when encoding the integer fails.\n *         Otherwise, the number of bytes added to the buffer.\n */\nstatic int SetASNIntMP(mp_int* n, int maxSz, byte* output)\n{\n    int idx = 0;\n    int leadingBit;\n    int length;\n    int err;\n\n    leadingBit = mp_leading_bit(n);\n    length = mp_unsigned_bin_size(n);\n    if (maxSz >= 0 && (1 + length + (leadingBit ? 1 : 0)) > maxSz)\n        return BUFFER_E;\n    idx = SetASNInt(length, leadingBit ? 0x80 : 0x00, output);\n    if (maxSz >= 0 && (idx + length) > maxSz)\n        return BUFFER_E;\n\n    if (output) {\n        err = mp_to_unsigned_bin(n, output + idx);\n        if (err != MP_OKAY)\n            return MP_TO_E;\n    }\n    idx += length;\n\n    return idx;\n}\n#endif\n\n#if !defined(NO_RSA) && defined(HAVE_USER_RSA) && \\\n    (defined(WOLFSSL_CERT_GEN) || defined(OPENSSL_EXTRA))\n/* Set the DER/BER encoding of the ASN.1 INTEGER element with an mp_int from\n * an RSA key.\n * The number is assumed to be positive.\n *\n * n       Multi-precision integer to encode.\n * output  Buffer to write into.\n * returns BUFFER_E when the data is too long for the buffer.\n *         MP_TO_E when encoding the integer fails.\n *         Otherwise, the number of bytes added to the buffer.\n */\nstatic int SetASNIntRSA(void* n, byte* output)\n{\n    int idx = 0;\n    int leadingBit;\n    int length;\n    int err;\n\n    leadingBit = wc_Rsa_leading_bit(n);\n    length = wc_Rsa_unsigned_bin_size(n);\n    idx = SetASNInt(length, leadingBit ? 0x80 : 0x00, output);\n    if ((idx + length) > MAX_RSA_INT_SZ)\n        return BUFFER_E;\n\n    if (output) {\n        err = wc_Rsa_to_unsigned_bin(n, output + idx, length);\n        if (err != MP_OKAY)\n            return MP_TO_E;\n    }\n    idx += length;\n\n    return idx;\n}\n#endif /* !NO_RSA && HAVE_USER_RSA && WOLFSSL_CERT_GEN */\n\n/* Windows header clash for WinCE using GetVersion */\nint GetMyVersion(const byte* input, word32* inOutIdx,\n                               int* version, word32 maxIdx)\n{\n    word32 idx = *inOutIdx;\n    byte   tag;\n\n    if ((idx + MIN_VERSION_SZ) > maxIdx)\n        return ASN_PARSE_E;\n\n    if (GetASNTag(input, &idx, &tag, maxIdx) != 0)\n        return ASN_PARSE_E;\n\n    if (tag != ASN_INTEGER)\n        return ASN_PARSE_E;\n\n    if (input[idx++] != 0x01)\n        return ASN_VERSION_E;\n\n    *version  = input[idx++];\n    *inOutIdx = idx;\n\n    return *version;\n}\n\n\n#ifndef NO_PWDBASED\n/* Get small count integer, 32 bits or less */\nint GetShortInt(const byte* input, word32* inOutIdx, int* number, word32 maxIdx)\n{\n    word32 idx = *inOutIdx;\n    word32 len;\n    byte   tag;\n\n    *number = 0;\n\n    /* check for type and length bytes */\n    if ((idx + 2) > maxIdx)\n        return BUFFER_E;\n\n    if (GetASNTag(input, &idx, &tag, maxIdx) != 0)\n        return ASN_PARSE_E;\n\n    if (tag != ASN_INTEGER)\n        return ASN_PARSE_E;\n\n    len = input[idx++];\n    if (len > 4)\n        return ASN_PARSE_E;\n\n    if (len + idx > maxIdx)\n        return ASN_PARSE_E;\n\n    while (len--) {\n        *number  = *number << 8 | input[idx++];\n    }\n\n    *inOutIdx = idx;\n\n    return *number;\n}\n\n\n/* Set small integer, 32 bits or less. DER encoding with no leading 0s\n * returns total amount written including ASN tag and length byte on success */\nint SetShortInt(byte* input, word32* inOutIdx, word32 number, word32 maxIdx)\n{\n    word32 idx = *inOutIdx;\n    word32 len = 0;\n    int    i;\n    byte ar[MAX_LENGTH_SZ];\n\n    /* check for room for type and length bytes */\n    if ((idx + 2) > maxIdx)\n        return BUFFER_E;\n\n    input[idx++] = ASN_INTEGER;\n    idx++; /* place holder for length byte */\n    if (MAX_LENGTH_SZ + idx > maxIdx)\n        return ASN_PARSE_E;\n\n    /* find first non zero byte */\n    XMEMSET(ar, 0, MAX_LENGTH_SZ);\n    c32toa(number, ar);\n    for (i = 0; i < MAX_LENGTH_SZ; i++) {\n        if (ar[i] != 0) {\n            break;\n        }\n    }\n\n    /* handle case of 0 */\n    if (i == MAX_LENGTH_SZ) {\n        input[idx++] = 0; len++;\n    }\n\n    for (; i < MAX_LENGTH_SZ && idx < maxIdx; i++) {\n        input[idx++] = ar[i]; len++;\n    }\n\n    /* jump back to beginning of input buffer using unaltered inOutIdx value\n     * and set number of bytes for integer, then update the index value */\n    input[*inOutIdx + 1] = (byte)len;\n    *inOutIdx = idx;\n\n    return len + 2; /* size of integer bytes plus ASN TAG and length byte */\n}\n#endif /* !NO_PWDBASED */\n\n/* May not have one, not an error */\nstatic int GetExplicitVersion(const byte* input, word32* inOutIdx, int* version,\n                              word32 maxIdx)\n{\n    word32 idx = *inOutIdx;\n    byte tag;\n\n    WOLFSSL_ENTER(\"GetExplicitVersion\");\n\n    if (GetASNTag(input, &idx, &tag, maxIdx) != 0)\n        return ASN_PARSE_E;\n\n    if (tag == (ASN_CONTEXT_SPECIFIC | ASN_CONSTRUCTED)) {\n        int ret;\n\n        *inOutIdx = ++idx;  /* skip header */\n        ret = GetMyVersion(input, inOutIdx, version, maxIdx);\n        if (ret >= 0) {\n            /* check if version is expected value rfc 5280 4.1 {0, 1, 2} */\n            if (*version > MAX_X509_VERSION || *version < MIN_X509_VERSION) {\n                WOLFSSL_MSG(\"Unexpected certificate version\");\n                ret = ASN_VERSION_E;\n            }\n        }\n        return ret;\n    }\n\n    /* go back as is */\n    *version = 0;\n\n    return 0;\n}\n\nint GetInt(mp_int* mpi, const byte* input, word32* inOutIdx, word32 maxIdx)\n{\n    word32 idx = *inOutIdx;\n    int    ret;\n    int    length;\n\n    ret = GetASNInt(input, &idx, &length, maxIdx);\n    if (ret != 0)\n        return ret;\n\n    if (mp_init(mpi) != MP_OKAY)\n        return MP_INIT_E;\n\n    if (mp_read_unsigned_bin(mpi, input + idx, length) != 0) {\n        mp_clear(mpi);\n        return ASN_GETINT_E;\n    }\n\n#ifdef HAVE_WOLF_BIGINT\n    if (wc_bigint_from_unsigned_bin(&mpi->raw, input + idx, length) != 0) {\n        mp_clear(mpi);\n        return ASN_GETINT_E;\n    }\n#endif /* HAVE_WOLF_BIGINT */\n\n    *inOutIdx = idx + length;\n\n    return 0;\n}\n\n#if (!defined(WOLFSSL_KEY_GEN) && !defined(OPENSSL_EXTRA) && defined(RSA_LOW_MEM)) \\\n    || defined(WOLFSSL_RSA_PUBLIC_ONLY) || (!defined(NO_DSA))\n#if (!defined(NO_RSA) && !defined(HAVE_USER_RSA)) || !defined(NO_DSA)\nstatic int SkipInt(const byte* input, word32* inOutIdx, word32 maxIdx)\n{\n    word32 idx = *inOutIdx;\n    int    ret;\n    int    length;\n\n    ret = GetASNInt(input, &idx, &length, maxIdx);\n    if (ret != 0)\n        return ret;\n\n    *inOutIdx = idx + length;\n\n    return 0;\n}\n#endif\n#endif\n\nint CheckBitString(const byte* input, word32* inOutIdx, int* len,\n                          word32 maxIdx, int zeroBits, byte* unusedBits)\n{\n    word32 idx = *inOutIdx;\n    int    length;\n    byte   b;\n\n    if (GetASNTag(input, &idx, &b, maxIdx) != 0) {\n        return ASN_BITSTR_E;\n    }\n\n    if (b != ASN_BIT_STRING) {\n        return ASN_BITSTR_E;\n    }\n\n    if (GetLength(input, &idx, &length, maxIdx) < 0)\n        return ASN_PARSE_E;\n\n    /* extra sanity check that length is greater than 0 */\n    if (length <= 0) {\n        WOLFSSL_MSG(\"Error length was 0 in CheckBitString\");\n        return BUFFER_E;\n    }\n\n    if (idx + 1 > maxIdx) {\n        WOLFSSL_MSG(\"Attempted buffer read larger than input buffer\");\n        return BUFFER_E;\n    }\n\n    b = input[idx];\n    if (zeroBits && b != 0x00)\n        return ASN_EXPECT_0_E;\n    if (b >= 0x08)\n        return ASN_PARSE_E;\n    if (b != 0) {\n        if ((byte)(input[idx + length - 1] << (8 - b)) != 0)\n            return ASN_PARSE_E;\n    }\n    idx++;\n    length--; /* length has been checked for greater than 0 */\n\n    *inOutIdx = idx;\n    if (len != NULL)\n        *len = length;\n    if (unusedBits != NULL)\n        *unusedBits = b;\n\n    return 0;\n}\n\n/* RSA (with CertGen or KeyGen) OR ECC OR ED25519 OR ED448 (with CertGen or\n * KeyGen) */\n#if (!defined(NO_RSA) && !defined(HAVE_USER_RSA) && \\\n        (defined(WOLFSSL_CERT_GEN) || defined(WOLFSSL_KEY_GEN) || defined(OPENSSL_EXTRA))) || \\\n    (defined(HAVE_ECC) && defined(HAVE_ECC_KEY_EXPORT)) || \\\n    ((defined(HAVE_ED25519) || defined(HAVE_ED448)) && \\\n        (defined(WOLFSSL_CERT_GEN) || defined(WOLFSSL_KEY_GEN) || defined(OPENSSL_EXTRA))) || \\\n    (!defined(NO_DSA) && !defined(HAVE_SELFTEST) && defined(WOLFSSL_KEY_GEN))\n\n/* Set the DER/BER encoding of the ASN.1 BIT_STRING header.\n *\n * len         Length of data to encode.\n * unusedBits  The number of unused bits in the last byte of data.\n *             That is, the number of least significant zero bits before a one.\n *             The last byte is the most-significant non-zero byte of a number.\n * output      Buffer to write into.\n * returns the number of bytes added to the buffer.\n */\nword32 SetBitString(word32 len, byte unusedBits, byte* output)\n{\n    word32 idx = 0;\n\n    if (output)\n        output[idx] = ASN_BIT_STRING;\n    idx++;\n\n    idx += SetLength(len + 1, output ? output + idx : NULL);\n    if (output)\n        output[idx] = unusedBits;\n    idx++;\n\n    return idx;\n}\n#endif /* !NO_RSA || HAVE_ECC || HAVE_ED25519 || HAVE_ED448 */\n\n#ifdef ASN_BER_TO_DER\n/* Pull informtation from the ASN.1 BER encoded item header */\nstatic int GetBerHeader(const byte* data, word32* idx, word32 maxIdx,\n                        byte* pTag, word32* pLen, int* indef)\n{\n    int len = 0;\n    byte tag;\n    word32 i = *idx;\n\n    *indef = 0;\n\n    /* Check there is enough data for a minimal header */\n    if (i + 2 > maxIdx) {\n        return ASN_PARSE_E;\n    }\n\n    /* Retrieve tag */\n    tag = data[i++];\n\n    /* Indefinite length handled specially */\n    if (data[i] == 0x80) {\n        /* Check valid tag for indefinite */\n        if (((tag & 0xc0) == 0) && ((tag & ASN_CONSTRUCTED) == 0x00)) {\n            return ASN_PARSE_E;\n        }\n        i++;\n        *indef = 1;\n    }\n    else if (GetLength(data, &i, &len, maxIdx) < 0) {\n        return ASN_PARSE_E;\n    }\n\n    /* Return tag, length and index after BER item header */\n    *pTag = tag;\n    *pLen = len;\n    *idx = i;\n    return 0;\n}\n\n#ifndef INDEF_ITEMS_MAX\n#define INDEF_ITEMS_MAX       20\n#endif\n\n/* Indef length item data */\ntypedef struct Indef {\n    word32 start;\n    int depth;\n    int headerLen;\n    word32 len;\n} Indef;\n\n/* Indef length items */\ntypedef struct IndefItems\n{\n    Indef len[INDEF_ITEMS_MAX];\n    int cnt;\n    int idx;\n    int depth;\n} IndefItems;\n\n\n/* Get header length of current item */\nstatic int IndefItems_HeaderLen(IndefItems* items)\n{\n    return items->len[items->idx].headerLen;\n}\n\n/* Get data length of current item */\nstatic word32 IndefItems_Len(IndefItems* items)\n{\n    return items->len[items->idx].len;\n}\n\n/* Add a indefinite length item */\nstatic int IndefItems_AddItem(IndefItems* items, word32 start)\n{\n    int ret = 0;\n    int i;\n\n    if (items->cnt == INDEF_ITEMS_MAX) {\n        ret = MEMORY_E;\n    }\n    else {\n        i = items->cnt++;\n        items->len[i].start = start;\n        items->len[i].depth = items->depth++;\n        items->len[i].headerLen = 1;\n        items->len[i].len = 0;\n        items->idx = i;\n    }\n\n    return ret;\n}\n\n/* Increase data length of current item */\nstatic void IndefItems_AddData(IndefItems* items, word32 length)\n{\n    items->len[items->idx].len += length;\n}\n\n/* Update header length of current item to reflect data length */\nstatic void IndefItems_UpdateHeaderLen(IndefItems* items)\n{\n    items->len[items->idx].headerLen +=\n                                    SetLength(items->len[items->idx].len, NULL);\n}\n\n/* Go to indefinite parent of current item */\nstatic void IndefItems_Up(IndefItems* items)\n{\n    int i;\n    int depth = items->len[items->idx].depth - 1;\n\n    for (i = items->cnt - 1; i >= 0; i--) {\n        if (items->len[i].depth == depth) {\n            break;\n        }\n    }\n    items->idx = i;\n    items->depth = depth + 1;\n}\n\n/* Calculate final length by adding length of indefinite child items */\nstatic void IndefItems_CalcLength(IndefItems* items)\n{\n    int i;\n    int idx = items->idx;\n\n    for (i = idx + 1; i < items->cnt; i++) {\n        if (items->len[i].depth == items->depth) {\n            items->len[idx].len += items->len[i].headerLen;\n            items->len[idx].len += items->len[i].len;\n        }\n    }\n    items->len[idx].headerLen += SetLength(items->len[idx].len, NULL);\n}\n\n/* Add more data to indefinite length item */\nstatic void IndefItems_MoreData(IndefItems* items, word32 length)\n{\n    if (items->cnt > 0 && items->idx >= 0) {\n        items->len[items->idx].len += length;\n    }\n}\n\n/* Convert a BER encoding with indefinite length items to DER.\n *\n * ber    BER encoded data.\n * berSz  Length of BER encoded data.\n * der    Buffer to hold DER encoded version of data.\n *        NULL indicates only the length is required.\n * derSz  The size of the buffer to hold the DER encoded data.\n *        Will be set if der is NULL, otherwise the value is checked as der is\n *        filled.\n * returns ASN_PARSE_E if the BER data is invalid and BAD_FUNC_ARG if ber or\n * derSz are NULL.\n */\nint wc_BerToDer(const byte* ber, word32 berSz, byte* der, word32* derSz)\n{\n    int ret = 0;\n    word32 i, j;\n#ifdef WOLFSSL_SMALL_STACK\n    IndefItems* indefItems = NULL;\n#else\n    IndefItems indefItems[1];\n#endif\n    byte tag, basic;\n    word32 length;\n    int indef;\n\n    if (ber == NULL || derSz == NULL)\n        return BAD_FUNC_ARG;\n\n#ifdef WOLFSSL_SMALL_STACK\n    indefItems = (IndefItems *)XMALLOC(sizeof(IndefItems), NULL, DYNAMIC_TYPE_TMP_BUFFER);\n    if (indefItems == NULL) {\n        ret = MEMORY_E;\n        goto end;\n    }\n#endif\n\n    XMEMSET(indefItems, 0, sizeof(*indefItems));\n\n    /* Calculate indefinite item lengths */\n    for (i = 0; i < berSz; ) {\n        word32 start = i;\n\n        /* Get next BER item */\n        ret = GetBerHeader(ber, &i, berSz, &tag, &length, &indef);\n        if (ret != 0) {\n            goto end;\n        }\n\n        if (indef) {\n            /* Indefinite item - add to list */\n            ret = IndefItems_AddItem(indefItems, i);\n            if (ret != 0) {\n                goto end;\n            }\n\n            if ((tag & 0xC0) == 0 &&\n                tag != (ASN_SEQUENCE | ASN_CONSTRUCTED) &&\n                tag != (ASN_SET      | ASN_CONSTRUCTED)) {\n                /* Constructed basic type - get repeating tag */\n                basic = tag & (~ASN_CONSTRUCTED);\n\n                /* Add up lengths of each item below */\n                for (; i < berSz; ) {\n                    /* Get next BER_item */\n                    ret = GetBerHeader(ber, &i, berSz, &tag, &length, &indef);\n                    if (ret != 0) {\n                        goto end;\n                    }\n\n                    /* End of content closes item */\n                    if (tag == ASN_EOC) {\n                        /* Must be zero length */\n                        if (length != 0) {\n                            ret = ASN_PARSE_E;\n                            goto end;\n                        }\n                        break;\n                    }\n\n                    /* Must not be indefinite and tag must match parent */\n                    if (indef || tag != basic) {\n                        ret = ASN_PARSE_E;\n                        goto end;\n                    }\n\n                    /* Add to length */\n                    IndefItems_AddData(indefItems, length);\n                    /* Skip data */\n                    i += length;\n                }\n\n                /* Ensure we got an EOC and not end of data */\n                if (tag != ASN_EOC) {\n                    ret = ASN_PARSE_E;\n                    goto end;\n                }\n\n                /* Set the header length to include the length field */\n                IndefItems_UpdateHeaderLen(indefItems);\n                /* Go to indefinte parent item */\n                IndefItems_Up(indefItems);\n            }\n        }\n        else if (tag == ASN_EOC) {\n            /* End-of-content must be 0 length */\n            if (length != 0) {\n                ret = ASN_PARSE_E;\n                goto end;\n            }\n            /* Check there is an item to close - missing EOC */\n            if (indefItems->depth == 0) {\n                ret = ASN_PARSE_E;\n                goto end;\n            }\n\n            /* Finish calculation of data length for indefinite item */\n            IndefItems_CalcLength(indefItems);\n            /* Go to indefinte parent item */\n            IndefItems_Up(indefItems);\n        }\n        else {\n            /* Known length item to add in - make sure enough data for it */\n            if (i + length > berSz) {\n                ret = ASN_PARSE_E;\n                goto end;\n            }\n\n            /* Include all data - can't have indefinite inside definite */\n            i += length;\n            /* Add entire item to current indefinite item */\n            IndefItems_MoreData(indefItems, i - start);\n        }\n    }\n    /* Check we had a EOC for each indefinite item */\n    if (indefItems->depth != 0) {\n        ret = ASN_PARSE_E;\n        goto end;\n    }\n\n    /* Write out DER */\n\n    j = 0;\n    /* Reset index */\n    indefItems->idx = 0;\n    for (i = 0; i < berSz; ) {\n        word32 start = i;\n\n        /* Get item - checked above */\n        (void)GetBerHeader(ber, &i, berSz, &tag, &length, &indef);\n        if (indef) {\n            if (der != NULL) {\n                /* Check enough space for header */\n                if (j + IndefItems_HeaderLen(indefItems) > *derSz) {\n                    ret = BUFFER_E;\n                    goto end;\n                }\n\n                if ((tag & 0xC0) == 0 &&\n                    tag != (ASN_SEQUENCE | ASN_CONSTRUCTED) &&\n                    tag != (ASN_SET      | ASN_CONSTRUCTED)) {\n                    /* Remove constructed tag for basic types */\n                    tag &= ~ASN_CONSTRUCTED;\n                }\n                /* Add tag and length */\n                der[j] = tag;\n                (void)SetLength(IndefItems_Len(indefItems), der + j + 1);\n            }\n            /* Add header length of indefinite item */\n            j += IndefItems_HeaderLen(indefItems);\n\n            if ((tag & 0xC0) == 0 &&\n                tag != (ASN_SEQUENCE | ASN_CONSTRUCTED) &&\n                tag != (ASN_SET      | ASN_CONSTRUCTED)) {\n                /* For basic type - get each child item and add data */\n                for (; i < berSz; ) {\n                    (void)GetBerHeader(ber, &i, berSz, &tag, &length, &indef);\n                    if (tag == ASN_EOC) {\n                        break;\n                    }\n                    if (der != NULL) {\n                        if (j + length > *derSz) {\n                            ret = BUFFER_E;\n                            goto end;\n                        }\n                        XMEMCPY(der + j, ber + i, length);\n                    }\n                    j += length;\n                    i += length;\n                }\n            }\n\n            /* Move to next indef item in list */\n            indefItems->idx++;\n        }\n        else if (tag == ASN_EOC) {\n            /* End-Of-Content is not written out in DER */\n        }\n        else {\n            /* Write out definite length item as is. */\n            i += length;\n            if (der != NULL) {\n                /* Ensure space for item */\n                if (j + i - start > *derSz) {\n                    ret = BUFFER_E;\n                    goto end;\n                }\n                /* Copy item as is */\n                XMEMCPY(der + j, ber + start, i - start);\n            }\n            j += i - start;\n        }\n    }\n\n    /* Return the length of the DER encoded ASN.1 */\n    *derSz = j;\n    if (der == NULL) {\n        ret = LENGTH_ONLY_E;\n    }\nend:\n#ifdef WOLFSSL_SMALL_STACK\n    if (indefItems != NULL) {\n        XFREE(indefItems, NULL, DYNAMIC_TYPE_TMP_BUFFER);\n    }\n#endif\n    return ret;\n}\n#endif\n\n#if defined(WOLFSSL_CERT_EXT) && defined(WOLFSSL_CERT_GEN)\n/* Set the DER/BER encoding of the ASN.1 BIT_STRING with a 16-bit value.\n *\n * val         16-bit value to encode.\n * output      Buffer to write into.\n * returns the number of bytes added to the buffer.\n */\nstatic word32 SetBitString16Bit(word16 val, byte* output)\n{\n    word32 idx;\n    int    len;\n    byte   lastByte;\n    byte   unusedBits = 0;\n\n    if ((val >> 8) != 0) {\n        len = 2;\n        lastByte = (byte)(val >> 8);\n    }\n    else {\n        len = 1;\n        lastByte = (byte)val;\n    }\n\n    while (((lastByte >> unusedBits) & 0x01) == 0x00)\n        unusedBits++;\n\n    idx = SetBitString(len, unusedBits, output);\n    output[idx++] = (byte)val;\n    if (len > 1)\n        output[idx++] = (byte)(val >> 8);\n\n    return idx;\n}\n#endif /* WOLFSSL_CERT_EXT || WOLFSSL_CERT_GEN */\n\n/* hashType */\n#ifdef WOLFSSL_MD2\n    static const byte hashMd2hOid[] = {42, 134, 72, 134, 247, 13, 2, 2};\n#endif\n#ifndef NO_MD5\n    static const byte hashMd5hOid[] = {42, 134, 72, 134, 247, 13, 2, 5};\n#endif\n#ifndef NO_SHA\n    static const byte hashSha1hOid[] = {43, 14, 3, 2, 26};\n#endif\n#ifdef WOLFSSL_SHA224\n    static const byte hashSha224hOid[] = {96, 134, 72, 1, 101, 3, 4, 2, 4};\n#endif\n#ifndef NO_SHA256\n    static const byte hashSha256hOid[] = {96, 134, 72, 1, 101, 3, 4, 2, 1};\n#endif\n#ifdef WOLFSSL_SHA384\n    static const byte hashSha384hOid[] = {96, 134, 72, 1, 101, 3, 4, 2, 2};\n#endif\n#ifdef WOLFSSL_SHA512\n    static const byte hashSha512hOid[] = {96, 134, 72, 1, 101, 3, 4, 2, 3};\n#endif\n#ifdef WOLFSSL_SHA3\n#ifndef WOLFSSL_NOSHA3_224\n    static const byte hashSha3_224hOid[] = {96, 134, 72, 1, 101, 3, 4, 2, 7};\n#endif /* WOLFSSL_NOSHA3_224 */\n#ifndef WOLFSSL_NOSHA3_256\n    static const byte hashSha3_256hOid[] = {96, 134, 72, 1, 101, 3, 4, 2, 8};\n#endif /* WOLFSSL_NOSHA3_256 */\n#ifndef WOLFSSL_NOSHA3_384\n    static const byte hashSha3_384hOid[] = {96, 134, 72, 1, 101, 3, 4, 2, 9};\n#endif /* WOLFSSL_NOSHA3_384 */\n#ifndef WOLFSSL_NOSHA3_512\n    static const byte hashSha3_512hOid[] = {96, 134, 72, 1, 101, 3, 4, 2, 10};\n#endif /* WOLFSSL_NOSHA3_512 */\n#endif /* WOLFSSL_SHA3 */\n\n/* hmacType */\n#ifndef NO_HMAC\n    #ifdef WOLFSSL_SHA224\n    static const byte hmacSha224Oid[] = {42, 134, 72, 134, 247, 13, 2, 8};\n    #endif\n    #ifndef NO_SHA256\n    static const byte hmacSha256Oid[] = {42, 134, 72, 134, 247, 13, 2, 9};\n    #endif\n    #ifdef WOLFSSL_SHA384\n    static const byte hmacSha384Oid[] = {42, 134, 72, 134, 247, 13, 2, 10};\n    #endif\n    #ifdef WOLFSSL_SHA512\n    static const byte hmacSha512Oid[] = {42, 134, 72, 134, 247, 13, 2, 11};\n    #endif\n#endif\n\n/* sigType */\n#if !defined(NO_DSA) && !defined(NO_SHA)\n    static const byte sigSha1wDsaOid[] = {42, 134, 72, 206, 56, 4, 3};\n    static const byte sigSha256wDsaOid[] = {96, 134, 72, 1, 101, 3, 4, 3, 2};\n#endif /* NO_DSA */\n#ifndef NO_RSA\n    #ifdef WOLFSSL_MD2\n    static const byte sigMd2wRsaOid[] = {42, 134, 72, 134, 247, 13, 1, 1, 2};\n    #endif\n    #ifndef NO_MD5\n    static const byte sigMd5wRsaOid[] = {42, 134, 72, 134, 247, 13, 1, 1, 4};\n    #endif\n    #ifndef NO_SHA\n    static const byte sigSha1wRsaOid[] = {42, 134, 72, 134, 247, 13, 1, 1, 5};\n    #endif\n    #ifdef WOLFSSL_SHA224\n    static const byte sigSha224wRsaOid[] = {42, 134, 72, 134, 247, 13, 1, 1,14};\n    #endif\n    #ifndef NO_SHA256\n    static const byte sigSha256wRsaOid[] = {42, 134, 72, 134, 247, 13, 1, 1,11};\n    #endif\n    #ifdef WOLFSSL_SHA384\n    static const byte sigSha384wRsaOid[] = {42, 134, 72, 134, 247, 13, 1, 1,12};\n    #endif\n    #ifdef WOLFSSL_SHA512\n    static const byte sigSha512wRsaOid[] = {42, 134, 72, 134, 247, 13, 1, 1,13};\n    #endif\n    #ifdef WOLFSSL_SHA3\n    #ifndef WOLFSSL_NOSHA3_224\n    static const byte sigSha3_224wRsaOid[] = {96, 134, 72, 1, 101, 3, 4, 3, 13};\n    #endif\n    #ifndef WOLFSSL_NOSHA3_256\n    static const byte sigSha3_256wRsaOid[] = {96, 134, 72, 1, 101, 3, 4, 3, 14};\n    #endif\n    #ifndef WOLFSSL_NOSHA3_384\n    static const byte sigSha3_384wRsaOid[] = {96, 134, 72, 1, 101, 3, 4, 3, 15};\n    #endif\n    #ifndef WOLFSSL_NOSHA3_512\n    static const byte sigSha3_512wRsaOid[] = {96, 134, 72, 1, 101, 3, 4, 3, 16};\n    #endif\n    #endif\n#endif /* NO_RSA */\n#ifdef HAVE_ECC\n    #ifndef NO_SHA\n    static const byte sigSha1wEcdsaOid[] = {42, 134, 72, 206, 61, 4, 1};\n    #endif\n    #ifdef WOLFSSL_SHA224\n    static const byte sigSha224wEcdsaOid[] = {42, 134, 72, 206, 61, 4, 3, 1};\n    #endif\n    #ifndef NO_SHA256\n    static const byte sigSha256wEcdsaOid[] = {42, 134, 72, 206, 61, 4, 3, 2};\n    #endif\n    #ifdef WOLFSSL_SHA384\n    static const byte sigSha384wEcdsaOid[] = {42, 134, 72, 206, 61, 4, 3, 3};\n    #endif\n    #ifdef WOLFSSL_SHA512\n    static const byte sigSha512wEcdsaOid[] = {42, 134, 72, 206, 61, 4, 3, 4};\n    #endif\n    #ifdef WOLFSSL_SHA3\n    #ifndef WOLFSSL_NOSHA3_224\n    static const byte sigSha3_224wEcdsaOid[] = {96, 134, 72, 1, 101, 3, 4, 3, 9};\n    #endif\n    #ifndef WOLFSSL_NOSHA3_256\n    static const byte sigSha3_256wEcdsaOid[] = {96, 134, 72, 1, 101, 3, 4, 3, 10};\n    #endif\n    #ifndef WOLFSSL_NOSHA3_384\n    static const byte sigSha3_384wEcdsaOid[] = {96, 134, 72, 1, 101, 3, 4, 3, 11};\n    #endif\n    #ifndef WOLFSSL_NOSHA3_512\n    static const byte sigSha3_512wEcdsaOid[] = {96, 134, 72, 1, 101, 3, 4, 3, 12};\n    #endif\n    #endif\n#endif /* HAVE_ECC */\n#ifdef HAVE_ED25519\n    static const byte sigEd25519Oid[] = {43, 101, 112};\n#endif /* HAVE_ED25519 */\n#ifdef HAVE_ED448\n    static const byte sigEd448Oid[] = {43, 101, 113};\n#endif /* HAVE_ED448 */\n\n/* keyType */\n#ifndef NO_DSA\n    static const byte keyDsaOid[] = {42, 134, 72, 206, 56, 4, 1};\n#endif /* NO_DSA */\n#ifndef NO_RSA\n    static const byte keyRsaOid[] = {42, 134, 72, 134, 247, 13, 1, 1, 1};\n#endif /* NO_RSA */\n#ifdef HAVE_NTRU\n    static const byte keyNtruOid[] = {43, 6, 1, 4, 1, 193, 22, 1, 1, 1, 1};\n#endif /* HAVE_NTRU */\n#ifdef HAVE_ECC\n    static const byte keyEcdsaOid[] = {42, 134, 72, 206, 61, 2, 1};\n#endif /* HAVE_ECC */\n#ifdef HAVE_ED25519\n    static const byte keyEd25519Oid[] = {43, 101, 112};\n#endif /* HAVE_ED25519 */\n#ifdef HAVE_ED448\n    static const byte keyEd448Oid[] = {43, 101, 113};\n#endif /* HAVE_ED448 */\n#ifndef NO_DH\n    static const byte keyDhOid[] = {42, 134, 72, 134, 247, 13, 1, 3, 1};\n#endif /* !NO_DH */\n\n/* curveType */\n#ifdef HAVE_ECC\n    /* See \"ecc_sets\" table in ecc.c */\n#endif /* HAVE_ECC */\n\n#ifdef HAVE_AES_CBC\n/* blkType */\n    #ifdef WOLFSSL_AES_128\n    static const byte blkAes128CbcOid[] = {96, 134, 72, 1, 101, 3, 4, 1, 2};\n    #endif\n    #ifdef WOLFSSL_AES_192\n    static const byte blkAes192CbcOid[] = {96, 134, 72, 1, 101, 3, 4, 1, 22};\n    #endif\n    #ifdef WOLFSSL_AES_256\n    static const byte blkAes256CbcOid[] = {96, 134, 72, 1, 101, 3, 4, 1, 42};\n    #endif\n#endif /* HAVE_AES_CBC */\n#ifdef HAVE_AESGCM\n    #ifdef WOLFSSL_AES_128\n    static const byte blkAes128GcmOid[] = {96, 134, 72, 1, 101, 3, 4, 1, 6};\n    #endif\n    #ifdef WOLFSSL_AES_192\n    static const byte blkAes192GcmOid[] = {96, 134, 72, 1, 101, 3, 4, 1, 26};\n    #endif\n    #ifdef WOLFSSL_AES_256\n    static const byte blkAes256GcmOid[] = {96, 134, 72, 1, 101, 3, 4, 1, 46};\n    #endif\n#endif /* HAVE_AESGCM */\n#ifdef HAVE_AESCCM\n    #ifdef WOLFSSL_AES_128\n    static const byte blkAes128CcmOid[] = {96, 134, 72, 1, 101, 3, 4, 1, 7};\n    #endif\n    #ifdef WOLFSSL_AES_192\n    static const byte blkAes192CcmOid[] = {96, 134, 72, 1, 101, 3, 4, 1, 27};\n    #endif\n    #ifdef WOLFSSL_AES_256\n    static const byte blkAes256CcmOid[] = {96, 134, 72, 1, 101, 3, 4, 1, 47};\n    #endif\n#endif /* HAVE_AESCCM */\n\n#ifndef NO_DES3\n    static const byte blkDesCbcOid[]  = {43, 14, 3, 2, 7};\n    static const byte blkDes3CbcOid[] = {42, 134, 72, 134, 247, 13, 3, 7};\n#endif\n\n/* keyWrapType */\n#ifdef WOLFSSL_AES_128\n    static const byte wrapAes128Oid[] = {96, 134, 72, 1, 101, 3, 4, 1, 5};\n#endif\n#ifdef WOLFSSL_AES_192\n    static const byte wrapAes192Oid[] = {96, 134, 72, 1, 101, 3, 4, 1, 25};\n#endif\n#ifdef WOLFSSL_AES_256\n    static const byte wrapAes256Oid[] = {96, 134, 72, 1, 101, 3, 4, 1, 45};\n#endif\n#ifdef HAVE_PKCS7\n/* From RFC 3211 */\nstatic const byte wrapPwriKekOid[] = {42, 134, 72, 134, 247, 13, 1, 9, 16, 3,9};\n#endif\n\n/* cmsKeyAgreeType */\n#ifndef NO_SHA\n    static const byte dhSinglePass_stdDH_sha1kdf_Oid[]   =\n                                          {43, 129, 5, 16, 134, 72, 63, 0, 2};\n#endif\n#ifdef WOLFSSL_SHA224\n    static const byte dhSinglePass_stdDH_sha224kdf_Oid[] = {43, 129, 4, 1, 11, 0};\n#endif\n#ifndef NO_SHA256\n    static const byte dhSinglePass_stdDH_sha256kdf_Oid[] = {43, 129, 4, 1, 11, 1};\n#endif\n#ifdef WOLFSSL_SHA384\n    static const byte dhSinglePass_stdDH_sha384kdf_Oid[] = {43, 129, 4, 1, 11, 2};\n#endif\n#ifdef WOLFSSL_SHA512\n    static const byte dhSinglePass_stdDH_sha512kdf_Oid[] = {43, 129, 4, 1, 11, 3};\n#endif\n\n/* ocspType */\n#ifdef HAVE_OCSP\n    static const byte ocspBasicOid[]    = {43, 6, 1, 5, 5, 7, 48, 1, 1};\n    static const byte ocspNonceOid[]    = {43, 6, 1, 5, 5, 7, 48, 1, 2};\n    static const byte ocspNoCheckOid[]  = {43, 6, 1, 5, 5, 7, 48, 1, 5};\n#endif /* HAVE_OCSP */\n\n/* certExtType */\nstatic const byte extBasicCaOid[] = {85, 29, 19};\nstatic const byte extAltNamesOid[] = {85, 29, 17};\nstatic const byte extCrlDistOid[] = {85, 29, 31};\nstatic const byte extAuthInfoOid[] = {43, 6, 1, 5, 5, 7, 1, 1};\nstatic const byte extAuthKeyOid[] = {85, 29, 35};\nstatic const byte extSubjKeyOid[] = {85, 29, 14};\nstatic const byte extCertPolicyOid[] = {85, 29, 32};\nstatic const byte extKeyUsageOid[] = {85, 29, 15};\nstatic const byte extInhibitAnyOid[] = {85, 29, 54};\nstatic const byte extExtKeyUsageOid[] = {85, 29, 37};\n#ifndef IGNORE_NAME_CONSTRAINTS\n    static const byte extNameConsOid[] = {85, 29, 30};\n#endif\n\n/* certAuthInfoType */\n#ifdef HAVE_OCSP\n    static const byte extAuthInfoOcspOid[] = {43, 6, 1, 5, 5, 7, 48, 1};\n#endif\nstatic const byte extAuthInfoCaIssuerOid[] = {43, 6, 1, 5, 5, 7, 48, 2};\n\n/* certPolicyType */\nstatic const byte extCertPolicyAnyOid[] = {85, 29, 32, 0};\n\n/* certKeyUseType */\nstatic const byte extAltNamesHwNameOid[] = {43, 6, 1, 5, 5, 7, 8, 4};\n\n/* certKeyUseType */\nstatic const byte extExtKeyUsageAnyOid[] = {85, 29, 37, 0};\nstatic const byte extExtKeyUsageServerAuthOid[]   = {43, 6, 1, 5, 5, 7, 3, 1};\nstatic const byte extExtKeyUsageClientAuthOid[]   = {43, 6, 1, 5, 5, 7, 3, 2};\nstatic const byte extExtKeyUsageCodeSigningOid[]  = {43, 6, 1, 5, 5, 7, 3, 3};\nstatic const byte extExtKeyUsageEmailProtectOid[] = {43, 6, 1, 5, 5, 7, 3, 4};\nstatic const byte extExtKeyUsageTimestampOid[]    = {43, 6, 1, 5, 5, 7, 3, 8};\nstatic const byte extExtKeyUsageOcspSignOid[]     = {43, 6, 1, 5, 5, 7, 3, 9};\n\n#ifdef WOLFSSL_CERT_REQ\n/* csrAttrType */\nstatic const byte attrChallengePasswordOid[] = {42, 134, 72, 134, 247, 13, 1, 9, 7};\nstatic const byte attrSerialNumberOid[] = {85, 4, 5};\n#endif\n\n/* kdfType */\nstatic const byte pbkdf2Oid[] = {42, 134, 72, 134, 247, 13, 1, 5, 12};\n\n/* PKCS5 */\n#if !defined(NO_DES3) && !defined(NO_SHA)\nstatic const byte pbeSha1Des[] = {42, 134, 72, 134, 247, 13, 1, 5, 10};\n#endif\nstatic const byte pbes2[] = {42, 134, 72, 134, 247, 13, 1, 5, 13};\n\n/* PKCS12 */\n#if !defined(NO_RC4) && !defined(NO_SHA)\nstatic const byte pbeSha1RC4128[] = {42, 134, 72, 134, 247, 13, 1, 12, 1, 1};\n#endif\n#if !defined(NO_DES3) && !defined(NO_SHA)\nstatic const byte pbeSha1Des3[] = {42, 134, 72, 134, 247, 13, 1, 12, 1, 3};\n#endif\n\n#ifdef HAVE_LIBZ\n/* zlib compression */\nstatic const byte zlibCompress[] = {42, 134, 72, 134, 247, 13, 1, 9, 16, 3, 8};\n#endif\n#ifdef WOLFSSL_APACHE_HTTPD\n/* tlsExtType */\nstatic const byte tlsFeatureOid[] = {43, 6, 1, 5, 5, 7, 1, 24};\n/* certNameType */\nstatic const byte dnsSRVOid[] = {43, 6, 1, 5, 5, 7, 8, 7};\n#endif\n\n\n/* returns a pointer to the OID string on success and NULL on fail */\nconst byte* OidFromId(word32 id, word32 type, word32* oidSz)\n{\n    const byte* oid = NULL;\n\n    *oidSz = 0;\n\n    switch (type) {\n\n        case oidHashType:\n            switch (id) {\n            #ifdef WOLFSSL_MD2\n                case MD2h:\n                    oid = hashMd2hOid;\n                    *oidSz = sizeof(hashMd2hOid);\n                    break;\n            #endif\n            #ifndef NO_MD5\n                case MD5h:\n                    oid = hashMd5hOid;\n                    *oidSz = sizeof(hashMd5hOid);\n                    break;\n            #endif\n            #ifndef NO_SHA\n                case SHAh:\n                    oid = hashSha1hOid;\n                    *oidSz = sizeof(hashSha1hOid);\n                    break;\n            #endif\n            #ifdef WOLFSSL_SHA224\n                case SHA224h:\n                    oid = hashSha224hOid;\n                    *oidSz = sizeof(hashSha224hOid);\n                    break;\n            #endif\n            #ifndef NO_SHA256\n                case SHA256h:\n                    oid = hashSha256hOid;\n                    *oidSz = sizeof(hashSha256hOid);\n                    break;\n            #endif\n            #ifdef WOLFSSL_SHA384\n                case SHA384h:\n                    oid = hashSha384hOid;\n                    *oidSz = sizeof(hashSha384hOid);\n                    break;\n            #endif\n            #ifdef WOLFSSL_SHA512\n                case SHA512h:\n                    oid = hashSha512hOid;\n                    *oidSz = sizeof(hashSha512hOid);\n                    break;\n            #endif\n            #ifdef WOLFSSL_SHA3\n            #ifndef WOLFSSL_NOSHA3_224\n                case SHA3_224h:\n                    oid = hashSha3_224hOid;\n                    *oidSz = sizeof(hashSha3_224hOid);\n                    break;\n            #endif /* WOLFSSL_NOSHA3_224 */\n            #ifndef WOLFSSL_NOSHA3_256\n                case SHA3_256h:\n                    oid = hashSha3_256hOid;\n                    *oidSz = sizeof(hashSha3_256hOid);\n                    break;\n            #endif /* WOLFSSL_NOSHA3_256 */\n            #ifndef WOLFSSL_NOSHA3_384\n                case SHA3_384h:\n                    oid = hashSha3_384hOid;\n                    *oidSz = sizeof(hashSha3_384hOid);\n                    break;\n            #endif /* WOLFSSL_NOSHA3_384 */\n            #ifndef WOLFSSL_NOSHA3_512\n                case SHA3_512h:\n                    oid = hashSha3_512hOid;\n                    *oidSz = sizeof(hashSha3_512hOid);\n                    break;\n            #endif /* WOLFSSL_NOSHA3_512 */\n            #endif /* WOLFSSL_SHA3 */\n                default:\n                    break;\n            }\n            break;\n\n        case oidSigType:\n            switch (id) {\n                #if !defined(NO_DSA) && !defined(NO_SHA)\n                case CTC_SHAwDSA:\n                    oid = sigSha1wDsaOid;\n                    *oidSz = sizeof(sigSha1wDsaOid);\n                    break;\n                case CTC_SHA256wDSA:\n                    oid = sigSha256wDsaOid;\n                    *oidSz = sizeof(sigSha256wDsaOid);\n                    break;\n                #endif /* NO_DSA */\n                #ifndef NO_RSA\n                #ifdef WOLFSSL_MD2\n                case CTC_MD2wRSA:\n                    oid = sigMd2wRsaOid;\n                    *oidSz = sizeof(sigMd2wRsaOid);\n                    break;\n                #endif\n                #ifndef NO_MD5\n                case CTC_MD5wRSA:\n                    oid = sigMd5wRsaOid;\n                    *oidSz = sizeof(sigMd5wRsaOid);\n                    break;\n                #endif\n                #ifndef NO_SHA\n                case CTC_SHAwRSA:\n                    oid = sigSha1wRsaOid;\n                    *oidSz = sizeof(sigSha1wRsaOid);\n                    break;\n                #endif\n                #ifdef WOLFSSL_SHA224\n                case CTC_SHA224wRSA:\n                    oid = sigSha224wRsaOid;\n                    *oidSz = sizeof(sigSha224wRsaOid);\n                    break;\n                #endif\n                #ifndef NO_SHA256\n                case CTC_SHA256wRSA:\n                    oid = sigSha256wRsaOid;\n                    *oidSz = sizeof(sigSha256wRsaOid);\n                    break;\n                #endif\n                #ifdef WOLFSSL_SHA384\n                case CTC_SHA384wRSA:\n                    oid = sigSha384wRsaOid;\n                    *oidSz = sizeof(sigSha384wRsaOid);\n                    break;\n                #endif\n                #ifdef WOLFSSL_SHA512\n                case CTC_SHA512wRSA:\n                    oid = sigSha512wRsaOid;\n                    *oidSz = sizeof(sigSha512wRsaOid);\n                    break;\n                #endif /* WOLFSSL_SHA512 */\n                #ifdef WOLFSSL_SHA3\n                #ifndef WOLFSSL_NOSHA3_224\n                case CTC_SHA3_224wRSA:\n                    oid = sigSha3_224wRsaOid;\n                    *oidSz = sizeof(sigSha3_224wRsaOid);\n                    break;\n                #endif\n                #ifndef WOLFSSL_NOSHA3_256\n                case CTC_SHA3_256wRSA:\n                    oid = sigSha3_256wRsaOid;\n                    *oidSz = sizeof(sigSha3_256wRsaOid);\n                    break;\n                #endif\n                #ifndef WOLFSSL_NOSHA3_384\n                case CTC_SHA3_384wRSA:\n                    oid = sigSha3_384wRsaOid;\n                    *oidSz = sizeof(sigSha3_384wRsaOid);\n                    break;\n                #endif\n                #ifndef WOLFSSL_NOSHA3_512\n                case CTC_SHA3_512wRSA:\n                    oid = sigSha3_512wRsaOid;\n                    *oidSz = sizeof(sigSha3_512wRsaOid);\n                    break;\n                #endif\n                #endif\n                #endif /* NO_RSA */\n                #ifdef HAVE_ECC\n                #ifndef NO_SHA\n                case CTC_SHAwECDSA:\n                    oid = sigSha1wEcdsaOid;\n                    *oidSz = sizeof(sigSha1wEcdsaOid);\n                    break;\n                #endif\n                #ifdef WOLFSSL_SHA224\n                case CTC_SHA224wECDSA:\n                    oid = sigSha224wEcdsaOid;\n                    *oidSz = sizeof(sigSha224wEcdsaOid);\n                    break;\n                #endif\n                #ifndef NO_SHA256\n                case CTC_SHA256wECDSA:\n                    oid = sigSha256wEcdsaOid;\n                    *oidSz = sizeof(sigSha256wEcdsaOid);\n                    break;\n                #endif\n                #ifdef WOLFSSL_SHA384\n                case CTC_SHA384wECDSA:\n                    oid = sigSha384wEcdsaOid;\n                    *oidSz = sizeof(sigSha384wEcdsaOid);\n                    break;\n                #endif\n                #ifdef WOLFSSL_SHA512\n                case CTC_SHA512wECDSA:\n                    oid = sigSha512wEcdsaOid;\n                    *oidSz = sizeof(sigSha512wEcdsaOid);\n                    break;\n                #endif\n                #ifdef WOLFSSL_SHA3\n                #ifndef WOLFSSL_NOSHA3_224\n                case CTC_SHA3_224wECDSA:\n                    oid = sigSha3_224wEcdsaOid;\n                    *oidSz = sizeof(sigSha3_224wEcdsaOid);\n                    break;\n                #endif\n                #ifndef WOLFSSL_NOSHA3_256\n                case CTC_SHA3_256wECDSA:\n                    oid = sigSha3_256wEcdsaOid;\n                    *oidSz = sizeof(sigSha3_256wEcdsaOid);\n                    break;\n                #endif\n                #ifndef WOLFSSL_NOSHA3_384\n                case CTC_SHA3_384wECDSA:\n                    oid = sigSha3_384wEcdsaOid;\n                    *oidSz = sizeof(sigSha3_384wEcdsaOid);\n                    break;\n                #endif\n                #ifndef WOLFSSL_NOSHA3_512\n                case CTC_SHA3_512wECDSA:\n                    oid = sigSha3_512wEcdsaOid;\n                    *oidSz = sizeof(sigSha3_512wEcdsaOid);\n                    break;\n                #endif\n                #endif\n                #endif /* HAVE_ECC */\n                #ifdef HAVE_ED25519\n                case CTC_ED25519:\n                    oid = sigEd25519Oid;\n                    *oidSz = sizeof(sigEd25519Oid);\n                    break;\n                #endif\n                #ifdef HAVE_ED448\n                case CTC_ED448:\n                    oid = sigEd448Oid;\n                    *oidSz = sizeof(sigEd448Oid);\n                    break;\n                #endif\n                default:\n                    break;\n            }\n            break;\n\n        case oidKeyType:\n            switch (id) {\n                #ifndef NO_DSA\n                case DSAk:\n                    oid = keyDsaOid;\n                    *oidSz = sizeof(keyDsaOid);\n                    break;\n                #endif /* NO_DSA */\n                #ifndef NO_RSA\n                case RSAk:\n                    oid = keyRsaOid;\n                    *oidSz = sizeof(keyRsaOid);\n                    break;\n                #endif /* NO_RSA */\n                #ifdef HAVE_NTRU\n                case NTRUk:\n                    oid = keyNtruOid;\n                    *oidSz = sizeof(keyNtruOid);\n                    break;\n                #endif /* HAVE_NTRU */\n                #ifdef HAVE_ECC\n                case ECDSAk:\n                    oid = keyEcdsaOid;\n                    *oidSz = sizeof(keyEcdsaOid);\n                    break;\n                #endif /* HAVE_ECC */\n                #ifdef HAVE_ED25519\n                case ED25519k:\n                    oid = keyEd25519Oid;\n                    *oidSz = sizeof(keyEd25519Oid);\n                    break;\n                #endif /* HAVE_ED25519 */\n                #ifdef HAVE_ED448\n                case ED448k:\n                    oid = keyEd448Oid;\n                    *oidSz = sizeof(keyEd448Oid);\n                    break;\n                #endif /* HAVE_ED448 */\n                #ifndef NO_DH\n                case DHk:\n                    oid = keyDhOid;\n                    *oidSz = sizeof(keyDhOid);\n                    break;\n                #endif /* !NO_DH */\n                default:\n                    break;\n            }\n            break;\n\n        #ifdef HAVE_ECC\n        case oidCurveType:\n            if (wc_ecc_get_oid(id, &oid, oidSz) < 0) {\n                WOLFSSL_MSG(\"ECC OID not found\");\n            }\n            break;\n        #endif /* HAVE_ECC */\n\n        case oidBlkType:\n            switch (id) {\n    #ifdef HAVE_AES_CBC\n        #ifdef WOLFSSL_AES_128\n                case AES128CBCb:\n                    oid = blkAes128CbcOid;\n                    *oidSz = sizeof(blkAes128CbcOid);\n                    break;\n        #endif\n        #ifdef WOLFSSL_AES_192\n                case AES192CBCb:\n                    oid = blkAes192CbcOid;\n                    *oidSz = sizeof(blkAes192CbcOid);\n                    break;\n        #endif\n        #ifdef WOLFSSL_AES_256\n                case AES256CBCb:\n                    oid = blkAes256CbcOid;\n                    *oidSz = sizeof(blkAes256CbcOid);\n                    break;\n        #endif\n    #endif /* HAVE_AES_CBC */\n    #ifdef HAVE_AESGCM\n        #ifdef WOLFSSL_AES_128\n                case AES128GCMb:\n                    oid = blkAes128GcmOid;\n                    *oidSz = sizeof(blkAes128GcmOid);\n                    break;\n        #endif\n        #ifdef WOLFSSL_AES_192\n                case AES192GCMb:\n                    oid = blkAes192GcmOid;\n                    *oidSz = sizeof(blkAes192GcmOid);\n                    break;\n        #endif\n        #ifdef WOLFSSL_AES_256\n                case AES256GCMb:\n                    oid = blkAes256GcmOid;\n                    *oidSz = sizeof(blkAes256GcmOid);\n                    break;\n        #endif\n    #endif /* HAVE_AESGCM */\n    #ifdef HAVE_AESCCM\n        #ifdef WOLFSSL_AES_128\n                case AES128CCMb:\n                    oid = blkAes128CcmOid;\n                    *oidSz = sizeof(blkAes128CcmOid);\n                    break;\n        #endif\n        #ifdef WOLFSSL_AES_192\n                case AES192CCMb:\n                    oid = blkAes192CcmOid;\n                    *oidSz = sizeof(blkAes192CcmOid);\n                    break;\n        #endif\n        #ifdef WOLFSSL_AES_256\n                case AES256CCMb:\n                    oid = blkAes256CcmOid;\n                    *oidSz = sizeof(blkAes256CcmOid);\n                    break;\n        #endif\n    #endif /* HAVE_AESCCM */\n    #ifndef NO_DES3\n                case DESb:\n                    oid = blkDesCbcOid;\n                    *oidSz = sizeof(blkDesCbcOid);\n                    break;\n                case DES3b:\n                    oid = blkDes3CbcOid;\n                    *oidSz = sizeof(blkDes3CbcOid);\n                    break;\n    #endif /* !NO_DES3 */\n                default:\n                    break;\n            }\n            break;\n\n        #ifdef HAVE_OCSP\n        case oidOcspType:\n            switch (id) {\n                case OCSP_BASIC_OID:\n                    oid = ocspBasicOid;\n                    *oidSz = sizeof(ocspBasicOid);\n                    break;\n                case OCSP_NONCE_OID:\n                    oid = ocspNonceOid;\n                    *oidSz = sizeof(ocspNonceOid);\n                    break;\n                default:\n                    break;\n            }\n            break;\n        #endif /* HAVE_OCSP */\n\n        case oidCertExtType:\n            switch (id) {\n                case BASIC_CA_OID:\n                    oid = extBasicCaOid;\n                    *oidSz = sizeof(extBasicCaOid);\n                    break;\n                case ALT_NAMES_OID:\n                    oid = extAltNamesOid;\n                    *oidSz = sizeof(extAltNamesOid);\n                    break;\n                case CRL_DIST_OID:\n                    oid = extCrlDistOid;\n                    *oidSz = sizeof(extCrlDistOid);\n                    break;\n                case AUTH_INFO_OID:\n                    oid = extAuthInfoOid;\n                    *oidSz = sizeof(extAuthInfoOid);\n                    break;\n                case AUTH_KEY_OID:\n                    oid = extAuthKeyOid;\n                    *oidSz = sizeof(extAuthKeyOid);\n                    break;\n                case SUBJ_KEY_OID:\n                    oid = extSubjKeyOid;\n                    *oidSz = sizeof(extSubjKeyOid);\n                    break;\n                case CERT_POLICY_OID:\n                    oid = extCertPolicyOid;\n                    *oidSz = sizeof(extCertPolicyOid);\n                    break;\n                case KEY_USAGE_OID:\n                    oid = extKeyUsageOid;\n                    *oidSz = sizeof(extKeyUsageOid);\n                    break;\n                case INHIBIT_ANY_OID:\n                    oid = extInhibitAnyOid;\n                    *oidSz = sizeof(extInhibitAnyOid);\n                    break;\n                case EXT_KEY_USAGE_OID:\n                    oid = extExtKeyUsageOid;\n                    *oidSz = sizeof(extExtKeyUsageOid);\n                    break;\n            #ifndef IGNORE_NAME_CONSTRAINTS\n                case NAME_CONS_OID:\n                    oid = extNameConsOid;\n                    *oidSz = sizeof(extNameConsOid);\n                    break;\n            #endif\n            #ifdef HAVE_OCSP\n                case OCSP_NOCHECK_OID:\n                    oid = ocspNoCheckOid;\n                    *oidSz = sizeof(ocspNoCheckOid);\n                    break;\n            #endif\n                default:\n                    break;\n            }\n            break;\n\n        case oidCrlExtType:\n            #ifdef HAVE_CRL\n            switch (id) {\n                case AUTH_KEY_OID:\n                    oid = extAuthKeyOid;\n                    *oidSz = sizeof(extAuthKeyOid);\n                    break;\n                default:\n                    break;\n            }\n            #endif\n            break;\n\n        case oidCertAuthInfoType:\n            switch (id) {\n            #ifdef HAVE_OCSP\n                case AIA_OCSP_OID:\n                    oid = extAuthInfoOcspOid;\n                    *oidSz = sizeof(extAuthInfoOcspOid);\n                    break;\n            #endif\n                case AIA_CA_ISSUER_OID:\n                    oid = extAuthInfoCaIssuerOid;\n                    *oidSz = sizeof(extAuthInfoCaIssuerOid);\n                    break;\n                default:\n                    break;\n            }\n            break;\n\n        case oidCertPolicyType:\n            switch (id) {\n                case CP_ANY_OID:\n                    oid = extCertPolicyAnyOid;\n                    *oidSz = sizeof(extCertPolicyAnyOid);\n                    break;\n                default:\n                    break;\n            }\n            break;\n\n        case oidCertAltNameType:\n            switch (id) {\n                case HW_NAME_OID:\n                    oid = extAltNamesHwNameOid;\n                    *oidSz = sizeof(extAltNamesHwNameOid);\n                    break;\n                default:\n                    break;\n            }\n            break;\n\n        case oidCertKeyUseType:\n            switch (id) {\n                case EKU_ANY_OID:\n                    oid = extExtKeyUsageAnyOid;\n                    *oidSz = sizeof(extExtKeyUsageAnyOid);\n                    break;\n                case EKU_SERVER_AUTH_OID:\n                    oid = extExtKeyUsageServerAuthOid;\n                    *oidSz = sizeof(extExtKeyUsageServerAuthOid);\n                    break;\n                case EKU_CLIENT_AUTH_OID:\n                    oid = extExtKeyUsageClientAuthOid;\n                    *oidSz = sizeof(extExtKeyUsageClientAuthOid);\n                    break;\n                case EKU_CODESIGNING_OID:\n                    oid = extExtKeyUsageCodeSigningOid;\n                    *oidSz = sizeof(extExtKeyUsageCodeSigningOid);\n                    break;\n                case EKU_EMAILPROTECT_OID:\n                    oid = extExtKeyUsageEmailProtectOid;\n                    *oidSz = sizeof(extExtKeyUsageEmailProtectOid);\n                    break;\n                case EKU_TIMESTAMP_OID:\n                    oid = extExtKeyUsageTimestampOid;\n                    *oidSz = sizeof(extExtKeyUsageTimestampOid);\n                    break;\n                case EKU_OCSP_SIGN_OID:\n                    oid = extExtKeyUsageOcspSignOid;\n                    *oidSz = sizeof(extExtKeyUsageOcspSignOid);\n                    break;\n                default:\n                    break;\n            }\n            break;\n\n        case oidKdfType:\n            switch (id) {\n                case PBKDF2_OID:\n                    oid = pbkdf2Oid;\n                    *oidSz = sizeof(pbkdf2Oid);\n                    break;\n                default:\n                    break;\n            }\n            break;\n\n        case oidPBEType:\n            switch (id) {\n        #if !defined(NO_SHA) && !defined(NO_RC4)\n                case PBE_SHA1_RC4_128:\n                    oid = pbeSha1RC4128;\n                    *oidSz = sizeof(pbeSha1RC4128);\n                    break;\n        #endif\n        #if !defined(NO_SHA) && !defined(NO_DES3)\n                case PBE_SHA1_DES:\n                    oid = pbeSha1Des;\n                    *oidSz = sizeof(pbeSha1Des);\n                    break;\n\n        #endif\n        #if !defined(NO_SHA) && !defined(NO_DES3)\n                case PBE_SHA1_DES3:\n                    oid = pbeSha1Des3;\n                    *oidSz = sizeof(pbeSha1Des3);\n                    break;\n        #endif\n                case PBES2:\n                    oid = pbes2;\n                    *oidSz = sizeof(pbes2);\n                    break;\n                default:\n                    break;\n            }\n            break;\n\n        case oidKeyWrapType:\n            switch (id) {\n            #ifdef WOLFSSL_AES_128\n                case AES128_WRAP:\n                    oid = wrapAes128Oid;\n                    *oidSz = sizeof(wrapAes128Oid);\n                    break;\n            #endif\n            #ifdef WOLFSSL_AES_192\n                case AES192_WRAP:\n                    oid = wrapAes192Oid;\n                    *oidSz = sizeof(wrapAes192Oid);\n                    break;\n            #endif\n            #ifdef WOLFSSL_AES_256\n                case AES256_WRAP:\n                    oid = wrapAes256Oid;\n                    *oidSz = sizeof(wrapAes256Oid);\n                    break;\n            #endif\n            #ifdef HAVE_PKCS7\n                case PWRI_KEK_WRAP:\n                    oid = wrapPwriKekOid;\n                    *oidSz = sizeof(wrapPwriKekOid);\n                    break;\n            #endif\n                default:\n                    break;\n            }\n            break;\n\n        case oidCmsKeyAgreeType:\n            switch (id) {\n            #ifndef NO_SHA\n                case dhSinglePass_stdDH_sha1kdf_scheme:\n                    oid = dhSinglePass_stdDH_sha1kdf_Oid;\n                    *oidSz = sizeof(dhSinglePass_stdDH_sha1kdf_Oid);\n                    break;\n            #endif\n            #ifdef WOLFSSL_SHA224\n                case dhSinglePass_stdDH_sha224kdf_scheme:\n                    oid = dhSinglePass_stdDH_sha224kdf_Oid;\n                    *oidSz = sizeof(dhSinglePass_stdDH_sha224kdf_Oid);\n                    break;\n            #endif\n            #ifndef NO_SHA256\n                case dhSinglePass_stdDH_sha256kdf_scheme:\n                    oid = dhSinglePass_stdDH_sha256kdf_Oid;\n                    *oidSz = sizeof(dhSinglePass_stdDH_sha256kdf_Oid);\n                    break;\n            #endif\n            #ifdef WOLFSSL_SHA384\n                case dhSinglePass_stdDH_sha384kdf_scheme:\n                    oid = dhSinglePass_stdDH_sha384kdf_Oid;\n                    *oidSz = sizeof(dhSinglePass_stdDH_sha384kdf_Oid);\n                    break;\n            #endif\n            #ifdef WOLFSSL_SHA512\n                case dhSinglePass_stdDH_sha512kdf_scheme:\n                    oid = dhSinglePass_stdDH_sha512kdf_Oid;\n                    *oidSz = sizeof(dhSinglePass_stdDH_sha512kdf_Oid);\n                    break;\n            #endif\n                default:\n                    break;\n            }\n            break;\n\n#ifndef NO_HMAC\n        case oidHmacType:\n            switch (id) {\n        #ifdef WOLFSSL_SHA224\n                case HMAC_SHA224_OID:\n                    oid = hmacSha224Oid;\n                    *oidSz = sizeof(hmacSha224Oid);\n                    break;\n        #endif\n        #ifndef NO_SHA256\n                case HMAC_SHA256_OID:\n                    oid = hmacSha256Oid;\n                    *oidSz = sizeof(hmacSha256Oid);\n                    break;\n        #endif\n        #ifdef WOLFSSL_SHA384\n                case HMAC_SHA384_OID:\n                    oid = hmacSha384Oid;\n                    *oidSz = sizeof(hmacSha384Oid);\n                    break;\n        #endif\n        #ifdef WOLFSSL_SHA512\n                case HMAC_SHA512_OID:\n                    oid = hmacSha512Oid;\n                    *oidSz = sizeof(hmacSha512Oid);\n                    break;\n        #endif\n                default:\n                    break;\n            }\n            break;\n#endif /* !NO_HMAC */\n\n#ifdef HAVE_LIBZ\n        case oidCompressType:\n            switch (id) {\n                case ZLIBc:\n                    oid = zlibCompress;\n                    *oidSz = sizeof(zlibCompress);\n                    break;\n                default:\n                    break;\n            }\n            break;\n#endif /* HAVE_LIBZ */\n#ifdef WOLFSSL_APACHE_HTTPD\n        case oidCertNameType:\n            switch (id) {\n                 case NID_id_on_dnsSRV:\n                    oid = dnsSRVOid;\n                    *oidSz = sizeof(dnsSRVOid);\n                    break;\n                default:\n                    break;\n            }\n            break;\n        case oidTlsExtType:\n            switch (id) {\n                case TLS_FEATURE_OID:\n                    oid = tlsFeatureOid;\n                    *oidSz = sizeof(tlsFeatureOid);\n                    break;\n                default:\n                    break;\n            }\n            break;\n#endif /* WOLFSSL_APACHE_HTTPD */\n#ifdef WOLFSSL_CERT_REQ\n        case oidCsrAttrType:\n            switch (id) {\n                case CHALLENGE_PASSWORD_OID:\n                    oid = attrChallengePasswordOid;\n                    *oidSz = sizeof(attrChallengePasswordOid);\n                    break;\n                case SERIAL_NUMBER_OID:\n                    oid = attrSerialNumberOid;\n                    *oidSz = sizeof(attrSerialNumberOid);\n                    break;\n                default:\n                    break;\n            }\n            break;\n#endif\n        case oidIgnoreType:\n        default:\n            break;\n    }\n\n    return oid;\n}\n\n#ifdef HAVE_OID_ENCODING\nint EncodeObjectId(const word16* in, word32 inSz, byte* out, word32* outSz)\n{\n    int i, x, len;\n    word32 d, t;\n\n    /* check args */\n    if (in == NULL || outSz == NULL) {\n        return BAD_FUNC_ARG;\n    }\n\n    /* compute length of encoded OID */\n    d = (in[0] * 40) + in[1];\n    len = 0;\n    for (i = 1; i < (int)inSz; i++) {\n        x = 0;\n        t = d;\n        while (t) {\n            x++;\n            t >>= 1;\n        }\n        len += (x / 7) + ((x % 7) ? 1 : 0) + (d == 0 ? 1 : 0);\n\n        if (i < (int)inSz - 1) {\n            d = in[i + 1];\n        }\n    }\n\n    if (out) {\n        /* verify length */\n        if ((int)*outSz < len) {\n            return BUFFER_E; /* buffer provided is not large enough */\n        }\n\n        /* calc first byte */\n        d = (in[0] * 40) + in[1];\n\n        /* encode bytes */\n        x = 0;\n        for (i = 1; i < (int)inSz; i++) {\n            if (d) {\n                int y = x, z;\n                byte mask = 0;\n                while (d) {\n                    out[x++] = (byte)((d & 0x7F) | mask);\n                    d     >>= 7;\n                    mask  |= 0x80;  /* upper bit is set on all but the last byte */\n                }\n                /* now swap bytes y...x-1 */\n                z = x - 1;\n                while (y < z) {\n                    mask = out[y];\n                    out[y] = out[z];\n                    out[z] = mask;\n                    ++y;\n                    --z;\n                }\n            }\n            else {\n              out[x++] = 0x00; /* zero value */\n            }\n\n            /* next word */\n            if (i < (int)inSz - 1) {\n                d = in[i + 1];\n            }\n        }\n    }\n\n    /* return length */\n    *outSz = len;\n\n    return 0;\n}\n#endif /* HAVE_OID_ENCODING */\n\n#ifdef HAVE_OID_DECODING\nint DecodeObjectId(const byte* in, word32 inSz, word16* out, word32* outSz)\n{\n    int x = 0, y = 0;\n    word32 t = 0;\n\n    /* check args */\n    if (in == NULL || outSz == NULL) {\n        return BAD_FUNC_ARG;\n    }\n\n    /* decode bytes */\n    while (inSz--) {\n        t = (t << 7) | (in[x] & 0x7F);\n        if (!(in[x] & 0x80)) {\n            if (y >= (int)*outSz) {\n                return BUFFER_E;\n            }\n            if (y == 0) {\n                out[0] = (t / 40);\n                out[1] = (t % 40);\n                y = 2;\n            }\n            else {\n                out[y++] = t;\n            }\n            t = 0; /* reset tmp */\n        }\n        x++;\n    }\n\n    /* return length */\n    *outSz = y;\n\n    return 0;\n}\n#endif /* HAVE_OID_DECODING */\n\n/* Get the DER/BER encoding of an ASN.1 OBJECT_ID header.\n *\n * input     Buffer holding DER/BER encoded data.\n * inOutIdx  Current index into buffer to parse.\n * len       The number of bytes in the ASN.1 data.\n * maxIdx    Length of data in buffer.\n * returns BUFFER_E when there is not enough data to parse.\n *         ASN_OBJECt_ID_E when the OBJECT_ID tag is not found.\n *         ASN_PARSE_E when length is invalid.\n *         Otherwise, 0 to indicate success.\n */\nint GetASNObjectId(const byte* input, word32* inOutIdx, int* len,\n                          word32 maxIdx)\n{\n    word32 idx = *inOutIdx;\n    int    length;\n    byte   tag;\n\n    if ((idx + 1) > maxIdx)\n        return BUFFER_E;\n\n    if (GetASNTag(input, &idx, &tag, maxIdx) != 0)\n        return ASN_PARSE_E;\n\n    if (tag != ASN_OBJECT_ID)\n        return ASN_OBJECT_ID_E;\n\n    if (GetLength(input, &idx, &length, maxIdx) < 0)\n        return ASN_PARSE_E;\n\n    *len = length;\n    *inOutIdx = idx;\n    return 0;\n}\n\n/* Set the DER/BER encoding of the ASN.1 OBJECT_ID header.\n *\n * len         Length of the OBJECT_ID data.\n * output      Buffer to write into.\n * returns the number of bytes added to the buffer.\n */\nint SetObjectId(int len, byte* output)\n{\n    int idx = 0;\n\n    if (output)\n        output[idx++] = ASN_OBJECT_ID;\n    else\n        idx++;\n    idx += SetLength(len, output ? output + idx : NULL);\n\n    return idx;\n}\n\nint GetObjectId(const byte* input, word32* inOutIdx, word32* oid,\n                                  word32 oidType, word32 maxIdx)\n{\n    int    ret = 0, length;\n    word32 idx = *inOutIdx;\n#ifndef NO_VERIFY_OID\n    word32 actualOidSz = 0;\n    const byte* actualOid;\n#endif /* NO_VERIFY_OID */\n\n    (void)oidType;\n    WOLFSSL_ENTER(\"GetObjectId()\");\n    *oid = 0;\n\n    ret = GetASNObjectId(input, &idx, &length, maxIdx);\n    if (ret != 0)\n        return ret;\n\n#ifndef NO_VERIFY_OID\n    actualOid = &input[idx];\n    if (length > 0)\n        actualOidSz = (word32)length;\n#endif /* NO_VERIFY_OID */\n\n    while (length--) {\n        /* odd HC08 compiler behavior here when input[idx++] */\n        *oid += (word32)input[idx];\n        idx++;\n    }\n    /* just sum it up for now */\n\n    *inOutIdx = idx;\n\n#ifndef NO_VERIFY_OID\n    {\n        const byte* checkOid = NULL;\n        word32 checkOidSz;\n    #ifdef ASN_DUMP_OID\n        word32 i;\n    #endif\n\n        if (oidType != oidIgnoreType) {\n            checkOid = OidFromId(*oid, oidType, &checkOidSz);\n\n        #ifdef ASN_DUMP_OID\n            /* support for dumping OID information */\n            printf(\"OID (Type %d, Sz %d, Sum %d): \", oidType, actualOidSz, *oid);\n            for (i=0; i<actualOidSz; i++) {\n                printf(\"%d, \", actualOid[i]);\n            }\n            printf(\"\\n\");\n            #ifdef HAVE_OID_DECODING\n            {\n                word16 decOid[16];\n                word32 decOidSz = sizeof(decOid);\n                ret = DecodeObjectId(actualOid, actualOidSz, decOid, &decOidSz);\n                if (ret == 0) {\n                    printf(\"  Decoded (Sz %d): \", decOidSz);\n                    for (i=0; i<decOidSz; i++) {\n                        printf(\"%d.\", decOid[i]);\n                    }\n                    printf(\"\\n\");\n                }\n                else {\n                    printf(\"DecodeObjectId failed: %d\\n\", ret);\n                }\n            }\n            #endif /* HAVE_OID_DECODING */\n        #endif /* ASN_DUMP_OID */\n\n            if (checkOid != NULL &&\n                (checkOidSz != actualOidSz ||\n                    XMEMCMP(actualOid, checkOid, checkOidSz) != 0)) {\n                WOLFSSL_MSG(\"OID Check Failed\");\n                return ASN_UNKNOWN_OID_E;\n            }\n        }\n    }\n#endif /* NO_VERIFY_OID */\n\n    return ret;\n}\n\nstatic int SkipObjectId(const byte* input, word32* inOutIdx, word32 maxIdx)\n{\n    word32 idx = *inOutIdx;\n    int    length;\n    int ret;\n\n    ret = GetASNObjectId(input, &idx, &length, maxIdx);\n    if (ret != 0)\n        return ret;\n\n    idx += length;\n    *inOutIdx = idx;\n\n    return 0;\n}\n\nint GetAlgoId(const byte* input, word32* inOutIdx, word32* oid,\n                     word32 oidType, word32 maxIdx)\n{\n    int    length;\n    word32 idx = *inOutIdx;\n    int    ret;\n    *oid = 0;\n\n    WOLFSSL_ENTER(\"GetAlgoId\");\n\n    if (GetSequence(input, &idx, &length, maxIdx) < 0)\n        return ASN_PARSE_E;\n\n    if (GetObjectId(input, &idx, oid, oidType, maxIdx) < 0)\n        return ASN_OBJECT_ID_E;\n\n    /* could have NULL tag and 0 terminator, but may not */\n    if (idx < maxIdx) {\n        word32 localIdx = idx; /*use localIdx to not advance when checking tag*/\n        byte   tag;\n\n        if (GetASNTag(input, &localIdx, &tag, maxIdx) == 0) {\n            if (tag == ASN_TAG_NULL) {\n                ret = GetASNNull(input, &idx, maxIdx);\n                if (ret != 0)\n                    return ret;\n            }\n        }\n    }\n\n    *inOutIdx = idx;\n\n    return 0;\n}\n\n#ifndef NO_RSA\n\n#ifndef HAVE_USER_RSA\nint wc_RsaPrivateKeyDecode(const byte* input, word32* inOutIdx, RsaKey* key,\n                        word32 inSz)\n{\n    int version, length;\n\n    if (inOutIdx == NULL || input == NULL || key == NULL) {\n        return BAD_FUNC_ARG;\n    }\n    if (GetSequence(input, inOutIdx, &length, inSz) < 0)\n        return ASN_PARSE_E;\n\n    if (GetMyVersion(input, inOutIdx, &version, inSz) < 0)\n        return ASN_PARSE_E;\n\n    key->type = RSA_PRIVATE;\n\n    if (GetInt(&key->n,  input, inOutIdx, inSz) < 0 ||\n        GetInt(&key->e,  input, inOutIdx, inSz) < 0 ||\n#ifndef WOLFSSL_RSA_PUBLIC_ONLY\n        GetInt(&key->d,  input, inOutIdx, inSz) < 0 ||\n        GetInt(&key->p,  input, inOutIdx, inSz) < 0 ||\n        GetInt(&key->q,  input, inOutIdx, inSz) < 0)\n#else\n        SkipInt(input, inOutIdx, inSz) < 0 ||\n        SkipInt(input, inOutIdx, inSz) < 0 ||\n        SkipInt(input, inOutIdx, inSz) < 0 )\n\n#endif\n            return ASN_RSA_KEY_E;\n#if (defined(WOLFSSL_KEY_GEN) || defined(OPENSSL_EXTRA) || !defined(RSA_LOW_MEM)) \\\n    && !defined(WOLFSSL_RSA_PUBLIC_ONLY)\n    if (GetInt(&key->dP, input, inOutIdx, inSz) < 0 ||\n        GetInt(&key->dQ, input, inOutIdx, inSz) < 0 ||\n        GetInt(&key->u,  input, inOutIdx, inSz) < 0 )  return ASN_RSA_KEY_E;\n#else\n    if (SkipInt(input, inOutIdx, inSz) < 0 ||\n        SkipInt(input, inOutIdx, inSz) < 0 ||\n        SkipInt(input, inOutIdx, inSz) < 0 )  return ASN_RSA_KEY_E;\n#endif\n\n#if defined(WOLFSSL_XILINX_CRYPT) || defined(WOLFSSL_CRYPTOCELL)\n    if (wc_InitRsaHw(key) != 0) {\n        return BAD_STATE_E;\n    }\n#endif\n\n    return 0;\n}\n#endif /* HAVE_USER_RSA */\n#endif /* NO_RSA */\n\n#if defined(HAVE_PKCS8) || defined(HAVE_PKCS12)\n\n/* Remove PKCS8 header, place inOutIdx at beginning of traditional,\n * return traditional length on success, negative on error */\nint ToTraditionalInline_ex(const byte* input, word32* inOutIdx, word32 sz,\n                           word32* algId)\n{\n    word32 idx;\n    int    version, length;\n    int    ret;\n    byte   tag;\n\n    if (input == NULL || inOutIdx == NULL)\n        return BAD_FUNC_ARG;\n\n    idx = *inOutIdx;\n\n    if (GetSequence(input, &idx, &length, sz) < 0)\n        return ASN_PARSE_E;\n\n    if (GetMyVersion(input, &idx, &version, sz) < 0)\n        return ASN_PARSE_E;\n\n    if (GetAlgoId(input, &idx, algId, oidKeyType, sz) < 0)\n        return ASN_PARSE_E;\n\n    if (GetASNTag(input, &idx, &tag, sz) < 0)\n        return ASN_PARSE_E;\n    idx = idx - 1; /* reset idx after finding tag */\n\n    if (tag == ASN_OBJECT_ID) {\n        if (SkipObjectId(input, &idx, sz) < 0)\n            return ASN_PARSE_E;\n    }\n\n    ret = GetOctetString(input, &idx, &length, sz);\n    if (ret < 0) {\n        if (ret == BUFFER_E)\n            return ASN_PARSE_E;\n        /* Some private keys don't expect an octet string */\n        WOLFSSL_MSG(\"Couldn't find Octet string\");\n    }\n\n    *inOutIdx = idx;\n\n    return length;\n}\n\nint ToTraditionalInline(const byte* input, word32* inOutIdx, word32 sz)\n{\n    word32 oid;\n\n    return ToTraditionalInline_ex(input, inOutIdx, sz, &oid);\n}\n\n/* Remove PKCS8 header, move beginning of traditional to beginning of input */\nint ToTraditional_ex(byte* input, word32 sz, word32* algId)\n{\n    word32 inOutIdx = 0;\n    int    length;\n\n    if (input == NULL)\n        return BAD_FUNC_ARG;\n\n    length = ToTraditionalInline_ex(input, &inOutIdx, sz, algId);\n    if (length < 0)\n        return length;\n\n    if (length + inOutIdx > sz)\n        return BUFFER_E;\n\n    XMEMMOVE(input, input + inOutIdx, length);\n\n    return length;\n}\n\nint ToTraditional(byte* input, word32 sz)\n{\n    word32 oid;\n\n    return ToTraditional_ex(input, sz, &oid);\n}\n\n#endif /* HAVE_PKCS8 || HAVE_PKCS12 */\n\n#if defined(HAVE_PKCS8) && !defined(NO_CERTS)\n\nint wc_GetPkcs8TraditionalOffset(byte* input, word32* inOutIdx, word32 sz)\n{\n    int length;\n    word32 algId;\n\n    if (input == NULL || inOutIdx == NULL || (*inOutIdx > sz))\n        return BAD_FUNC_ARG;\n\n    length = ToTraditionalInline_ex(input, inOutIdx, sz, &algId);\n\n    return length;\n}\n\nint wc_CreatePKCS8Key(byte* out, word32* outSz, byte* key, word32 keySz,\n        int algoID, const byte* curveOID, word32 oidSz)\n{\n        word32 keyIdx = 0;\n        word32 tmpSz  = 0;\n        word32 sz;\n\n\n        /* If out is NULL then return the max size needed\n         * + 2 for ASN_OBJECT_ID and ASN_OCTET_STRING tags */\n        if (out == NULL && outSz != NULL) {\n            *outSz = keySz + MAX_SEQ_SZ + MAX_VERSION_SZ + MAX_ALGO_SZ\n                     + MAX_LENGTH_SZ + MAX_LENGTH_SZ + 2;\n\n            if (curveOID != NULL)\n                *outSz += oidSz + MAX_LENGTH_SZ + 1;\n\n            WOLFSSL_MSG(\"Checking size of PKCS8\");\n\n            return LENGTH_ONLY_E;\n        }\n\n        WOLFSSL_ENTER(\"wc_CreatePKCS8Key()\");\n\n        if (key == NULL || out == NULL || outSz == NULL) {\n            return BAD_FUNC_ARG;\n        }\n\n        /* check the buffer has enough room for largest possible size */\n        if (curveOID != NULL) {\n            if (*outSz < (keySz + MAX_SEQ_SZ + MAX_VERSION_SZ + MAX_ALGO_SZ\n                   + MAX_LENGTH_SZ + MAX_LENGTH_SZ + 3 + oidSz + MAX_LENGTH_SZ))\n                return BUFFER_E;\n        }\n        else {\n            oidSz = 0; /* with no curveOID oid size must be 0 */\n            if (*outSz < (keySz + MAX_SEQ_SZ + MAX_VERSION_SZ + MAX_ALGO_SZ\n                      + MAX_LENGTH_SZ + MAX_LENGTH_SZ + 2))\n                return BUFFER_E;\n        }\n\n        /* PrivateKeyInfo ::= SEQUENCE */\n        keyIdx += MAX_SEQ_SZ; /* save room for sequence */\n\n        /*  version Version\n         *  no header information just INTEGER */\n        sz = SetMyVersion(PKCS8v0, out + keyIdx, 0);\n        tmpSz += sz; keyIdx += sz;\n        /*  privateKeyAlgorithm PrivateKeyAlgorithmIdentifier */\n        sz = 0; /* set sz to 0 and get privateKey oid buffer size needed */\n        if (curveOID != NULL && oidSz > 0) {\n            byte buf[MAX_LENGTH_SZ];\n            sz = SetLength(oidSz, buf);\n            sz += 1; /* plus one for ASN object id */\n        }\n        sz = SetAlgoID(algoID, out + keyIdx, oidKeyType, oidSz + sz);\n        tmpSz += sz; keyIdx += sz;\n\n        /*  privateKey          PrivateKey *\n         * pkcs8 ecc uses slightly different format. Places curve oid in\n         * buffer */\n        if (curveOID != NULL && oidSz > 0) {\n            sz = SetObjectId(oidSz, out + keyIdx);\n            keyIdx += sz; tmpSz += sz;\n            XMEMCPY(out + keyIdx, curveOID, oidSz);\n            keyIdx += oidSz; tmpSz += oidSz;\n        }\n\n        sz = SetOctetString(keySz, out + keyIdx);\n        keyIdx += sz; tmpSz += sz;\n        XMEMCPY(out + keyIdx, key, keySz);\n        tmpSz += keySz;\n\n        /*  attributes          optional\n         * No attributes currently added */\n\n        /* rewind and add sequence */\n        sz = SetSequence(tmpSz, out);\n        XMEMMOVE(out + sz, out + MAX_SEQ_SZ, tmpSz);\n\n        return tmpSz + sz;\n}\n\n#endif /* HAVE_PKCS8 && !NO_CERTS */\n\n#if defined(HAVE_PKCS12) || !defined(NO_CHECK_PRIVATE_KEY)\n/* check that the private key is a pair for the public key\n * return 1 (true) on match\n * return 0 or negative value on failure/error\n *\n * privKey   : buffer holding DER format private key\n * privKeySz : size of private key buffer\n * pubKey    : buffer holding DER format public key\n * pubKeySz  : size of public key buffer\n * ks        : type of key */\nint wc_CheckPrivateKey(const byte* privKey, word32 privKeySz,\n                       const byte* pubKey, word32 pubKeySz, enum Key_Sum ks)\n{\n    int ret;\n    (void)privKeySz;\n    (void)pubKeySz;\n    (void)ks;\n\n    if (privKey == NULL || pubKey == NULL) {\n        return BAD_FUNC_ARG;\n    }\n\n    #if !defined(NO_RSA) && !defined(NO_ASN_CRYPT)\n    /* test if RSA key */\n    if (ks == RSAk) {\n    #ifdef WOLFSSL_SMALL_STACK\n        RsaKey* a;\n        RsaKey* b = NULL;\n    #else\n        RsaKey a[1], b[1];\n    #endif\n        word32 keyIdx = 0;\n\n    #ifdef WOLFSSL_SMALL_STACK\n        a = (RsaKey*)XMALLOC(sizeof(RsaKey), NULL, DYNAMIC_TYPE_RSA);\n        if (a == NULL)\n            return MEMORY_E;\n        b = (RsaKey*)XMALLOC(sizeof(RsaKey), NULL, DYNAMIC_TYPE_RSA);\n        if (b == NULL) {\n            XFREE(a, NULL, DYNAMIC_TYPE_RSA);\n            return MEMORY_E;\n        }\n    #endif\n\n        if ((ret = wc_InitRsaKey(a, NULL)) < 0) {\n    #ifdef WOLFSSL_SMALL_STACK\n            XFREE(b, NULL, DYNAMIC_TYPE_RSA);\n            XFREE(a, NULL, DYNAMIC_TYPE_RSA);\n    #endif\n            return ret;\n        }\n        if ((ret = wc_InitRsaKey(b, NULL)) < 0) {\n            wc_FreeRsaKey(a);\n    #ifdef WOLFSSL_SMALL_STACK\n            XFREE(b, NULL, DYNAMIC_TYPE_RSA);\n            XFREE(a, NULL, DYNAMIC_TYPE_RSA);\n    #endif\n            return ret;\n        }\n        if ((ret = wc_RsaPrivateKeyDecode(privKey, &keyIdx, a, privKeySz)) == 0) {\n            WOLFSSL_MSG(\"Checking RSA key pair\");\n            keyIdx = 0; /* reset to 0 for parsing public key */\n\n            if ((ret = wc_RsaPublicKeyDecode(pubKey, &keyIdx, b,\n                    pubKeySz)) == 0) {\n                /* limit for user RSA crypto because of RsaKey\n                 * dereference. */\n            #if defined(HAVE_USER_RSA)\n                WOLFSSL_MSG(\"Cannot verify RSA pair with user RSA\");\n                ret = 1; /* return first RSA cert as match */\n            #else\n                /* both keys extracted successfully now check n and e\n                 * values are the same. This is dereferencing RsaKey */\n                if (mp_cmp(&(a->n), &(b->n)) != MP_EQ ||\n                    mp_cmp(&(a->e), &(b->e)) != MP_EQ) {\n                    ret = MP_CMP_E;\n                }\n                else\n                    ret = 1;\n            #endif\n            }\n        }\n        wc_FreeRsaKey(b);\n        wc_FreeRsaKey(a);\n    #ifdef WOLFSSL_SMALL_STACK\n        XFREE(b, NULL, DYNAMIC_TYPE_RSA);\n        XFREE(a, NULL, DYNAMIC_TYPE_RSA);\n    #endif\n    }\n    else\n    #endif /* !NO_RSA && !NO_ASN_CRYPT */\n\n    #if defined(HAVE_ECC) && defined(HAVE_ECC_KEY_EXPORT) && !defined(NO_ASN_CRYPT)\n    if (ks == ECDSAk) {\n    #ifdef WOLFSSL_SMALL_STACK\n        ecc_key* key_pair;\n        byte*    privDer;\n    #else\n        ecc_key  key_pair[1];\n        byte     privDer[MAX_ECC_BYTES];\n    #endif\n        word32   privSz = MAX_ECC_BYTES;\n        word32   keyIdx = 0;\n\n    #ifdef WOLFSSL_SMALL_STACK\n        key_pair = (ecc_key*)XMALLOC(sizeof(ecc_key), NULL, DYNAMIC_TYPE_ECC);\n        if (key_pair == NULL)\n            return MEMORY_E;\n        privDer = (byte*)XMALLOC(MAX_ECC_BYTES, NULL, DYNAMIC_TYPE_TMP_BUFFER);\n        if (privDer == NULL) {\n            XFREE(key_pair, NULL, DYNAMIC_TYPE_ECC);\n            return MEMORY_E;\n        }\n    #endif\n\n        if ((ret = wc_ecc_init(key_pair)) < 0) {\n    #ifdef WOLFSSL_SMALL_STACK\n            XFREE(privDer, NULL, DYNAMIC_TYPE_TMP_BUFFER);\n            XFREE(key_pair, NULL, DYNAMIC_TYPE_ECC);\n    #endif\n            return ret;\n        }\n\n        if ((ret = wc_EccPrivateKeyDecode(privKey, &keyIdx, key_pair,\n                privKeySz)) == 0) {\n            WOLFSSL_MSG(\"Checking ECC key pair\");\n\n            if ((ret = wc_ecc_export_private_only(key_pair, privDer, &privSz))\n                                                                         == 0) {\n                wc_ecc_free(key_pair);\n                ret = wc_ecc_init(key_pair);\n                if (ret == 0) {\n                    ret = wc_ecc_import_private_key(privDer,\n                                            privSz, pubKey,\n                                            pubKeySz, key_pair);\n                }\n\n                /* public and private extracted successfully now check if is\n                 * a pair and also do sanity checks on key. wc_ecc_check_key\n                 * checks that private * base generator equals pubkey */\n                if (ret == 0) {\n                    if ((ret = wc_ecc_check_key(key_pair)) == 0) {\n                        ret = 1;\n                    }\n                }\n                ForceZero(privDer, privSz);\n            }\n        }\n        wc_ecc_free(key_pair);\n    #ifdef WOLFSSL_SMALL_STACK\n        XFREE(privDer, NULL, DYNAMIC_TYPE_TMP_BUFFER);\n        XFREE(key_pair, NULL, DYNAMIC_TYPE_ECC);\n    #endif\n    }\n    else\n    #endif /* HAVE_ECC && HAVE_ECC_KEY_EXPORT && !NO_ASN_CRYPT */\n\n    #if defined(HAVE_ED25519) && !defined(NO_ASN_CRYPT)\n    if (ks == ED25519k) {\n    #ifdef WOLFSSL_SMALL_STACK\n        ed25519_key* key_pair;\n    #else\n        ed25519_key  key_pair[1];\n    #endif\n        word32       keyIdx = 0;\n\n    #ifdef WOLFSSL_SMALL_STACK\n        key_pair = (ed25519_key*)XMALLOC(sizeof(ed25519_key), NULL,\n                                                          DYNAMIC_TYPE_ED25519);\n        if (key_pair == NULL)\n            return MEMORY_E;\n    #endif\n\n        if ((ret = wc_ed25519_init(key_pair)) < 0) {\n    #ifdef WOLFSSL_SMALL_STACK\n            XFREE(key_pair, NULL, DYNAMIC_TYPE_ED25519);\n    #endif\n            return ret;\n        }\n        if ((ret = wc_Ed25519PrivateKeyDecode(privKey, &keyIdx, key_pair,\n                privKeySz)) == 0) {\n            WOLFSSL_MSG(\"Checking ED25519 key pair\");\n            keyIdx = 0;\n            if ((ret = wc_ed25519_import_public(pubKey, pubKeySz,\n                    key_pair)) == 0) {\n                /* public and private extracted successfully no check if is\n                 * a pair and also do sanity checks on key. wc_ecc_check_key\n                 * checks that private * base generator equals pubkey */\n                if ((ret = wc_ed25519_check_key(key_pair)) == 0)\n                    ret = 1;\n            }\n        }\n        wc_ed25519_free(key_pair);\n    #ifdef WOLFSSL_SMALL_STACK\n        XFREE(key_pair, NULL, DYNAMIC_TYPE_ED25519);\n    #endif\n    }\n    else\n    #endif /* HAVE_ED25519 && !NO_ASN_CRYPT */\n\n    #if defined(HAVE_ED448) && !defined(NO_ASN_CRYPT)\n    if (ks == ED448k) {\n    #ifdef WOLFSSL_SMALL_STACK\n        ed448_key* key_pair = NULL;\n    #else\n        ed448_key  key_pair[1];\n    #endif\n        word32     keyIdx = 0;\n\n    #ifdef WOLFSSL_SMALL_STACK\n        key_pair = (ed448_key*)XMALLOC(sizeof(ed448_key), NULL,\n                                                            DYNAMIC_TYPE_ED448);\n        if (key_pair == NULL)\n            return MEMORY_E;\n    #endif\n\n        if ((ret = wc_ed448_init(key_pair)) < 0) {\n    #ifdef WOLFSSL_SMALL_STACK\n            XFREE(key_pair, NULL, DYNAMIC_TYPE_ED448);\n    #endif\n            return ret;\n        }\n        if ((ret = wc_Ed448PrivateKeyDecode(privKey, &keyIdx, key_pair,\n                privKeySz)) == 0) {\n            WOLFSSL_MSG(\"Checking ED448 key pair\");\n            keyIdx = 0;\n            if ((ret = wc_ed448_import_public(pubKey, pubKeySz,\n                    key_pair)) == 0) {\n                /* public and private extracted successfully no check if is\n                 * a pair and also do sanity checks on key. wc_ecc_check_key\n                 * checks that private * base generator equals pubkey */\n                if ((ret = wc_ed448_check_key(key_pair)) == 0)\n                    ret = 1;\n            }\n        }\n        wc_ed448_free(key_pair);\n    #ifdef WOLFSSL_SMALL_STACK\n        XFREE(key_pair, NULL, DYNAMIC_TYPE_ED448);\n    #endif\n    }\n    else\n    #endif /* HAVE_ED448 && !NO_ASN_CRYPT */\n    {\n        ret = 0;\n    }\n    (void)ks;\n\n    return ret;\n}\n\n/* check that the private key is a pair for the public key in certificate\n * return 1 (true) on match\n * return 0 or negative value on failure/error\n *\n * key   : buffer holding DER format key\n * keySz : size of key buffer\n * der   : a initialized and parsed DecodedCert holding a certificate */\nint wc_CheckPrivateKeyCert(const byte* key, word32 keySz, DecodedCert* der)\n{\n    if (key == NULL || der == NULL) {\n        return BAD_FUNC_ARG;\n    }\n\n    return wc_CheckPrivateKey(key, keySz, der->publicKey,\n            der->pubKeySize, (enum Key_Sum) der->keyOID);\n}\n\n#endif /* HAVE_PKCS12 || !NO_CHECK_PRIVATE_KEY */\n\n#ifndef NO_PWDBASED\n\n#if defined(HAVE_PKCS8) || defined(HAVE_PKCS12)\n/* Check To see if PKCS version algo is supported, set id if it is return 0\n   < 0 on error */\nstatic int CheckAlgo(int first, int second, int* id, int* version, int* blockSz)\n{\n    *id      = ALGO_ID_E;\n    *version = PKCS5;   /* default */\n    if (blockSz) *blockSz = 8; /* default */\n\n    if (first == 1) {\n        switch (second) {\n#if !defined(NO_SHA)\n    #ifndef NO_RC4\n        case PBE_SHA1_RC4_128:\n            *id = PBE_SHA1_RC4_128;\n            *version = PKCS12v1;\n            return 0;\n    #endif\n    #ifndef NO_DES3\n        case PBE_SHA1_DES3:\n            *id = PBE_SHA1_DES3;\n            *version = PKCS12v1;\n            if (blockSz) *blockSz = DES_BLOCK_SIZE;\n            return 0;\n        case PBE_SHA1_DES:\n            *id = PBE_SHA1_DES;\n            *version = PKCS12v1;\n            if (blockSz) *blockSz = DES_BLOCK_SIZE;\n            return 0;\n    #endif\n    #ifdef WC_RC2\n        case PBE_SHA1_40RC2_CBC:\n            *id = PBE_SHA1_40RC2_CBC;\n            *version = PKCS12v1;\n            if (blockSz) *blockSz = RC2_BLOCK_SIZE;\n            return 0;\n    #endif\n#endif /* !NO_SHA */\n        default:\n            return ALGO_ID_E;\n        }\n    }\n\n    if (first != PKCS5)\n        return ASN_INPUT_E;  /* VERSION ERROR */\n\n    if (second == PBES2) {\n        *version = PKCS5v2;\n        return 0;\n    }\n\n    switch (second) {\n#ifndef NO_DES3\n    #ifndef NO_MD5\n    case 3:                   /* see RFC 2898 for ids */\n        *id = PBE_MD5_DES;\n        if (blockSz) *blockSz = DES_BLOCK_SIZE;\n        return 0;\n    #endif\n    #ifndef NO_SHA\n    case 10:\n        *id = PBE_SHA1_DES;\n        if (blockSz) *blockSz = DES_BLOCK_SIZE;\n        return 0;\n    #endif\n#endif /* !NO_DES3 */\n    default:\n        return ALGO_ID_E;\n\n    }\n}\n\n/* Check To see if PKCS v2 algo is supported, set id if it is return 0\n   < 0 on error */\nstatic int CheckAlgoV2(int oid, int* id, int* blockSz)\n{\n    if (blockSz) *blockSz = 8; /* default */\n    (void)id; /* not used if AES and DES3 disabled */\n    switch (oid) {\n#if !defined(NO_DES3) && !defined(NO_SHA)\n    case DESb:\n        *id = PBE_SHA1_DES;\n        if (blockSz) *blockSz = DES_BLOCK_SIZE;\n        return 0;\n    case DES3b:\n        *id = PBE_SHA1_DES3;\n        if (blockSz) *blockSz = DES_BLOCK_SIZE;\n        return 0;\n#endif\n#ifdef WOLFSSL_AES_256\n    case AES256CBCb:\n        *id = PBE_AES256_CBC;\n        if (blockSz) *blockSz = AES_BLOCK_SIZE;\n        return 0;\n#endif\n#ifdef WOLFSSL_AES_128\n    case AES128CBCb:\n        *id = PBE_AES128_CBC;\n        if (blockSz) *blockSz = AES_BLOCK_SIZE;\n        return 0;\n#endif\n    default:\n        WOLFSSL_MSG(\"No PKCS v2 algo found\");\n        return ALGO_ID_E;\n\n    }\n}\n\n#endif /* HAVE_PKCS8 || HAVE_PKCS12 */\n\n#ifdef HAVE_PKCS8\n\nint wc_GetKeyOID(byte* key, word32 keySz, const byte** curveOID, word32* oidSz,\n        int* algoID, void* heap)\n{\n    word32 tmpIdx = 0;\n\n    if (key == NULL || algoID == NULL)\n        return BAD_FUNC_ARG;\n\n    *algoID = 0;\n\n    #if !defined(NO_RSA) && !defined(NO_ASN_CRYPT)\n    {\n        RsaKey *rsa = (RsaKey *)XMALLOC(sizeof *rsa, heap, DYNAMIC_TYPE_TMP_BUFFER);\n        if (rsa == NULL)\n            return MEMORY_E;\n\n        wc_InitRsaKey(rsa, heap);\n        if (wc_RsaPrivateKeyDecode(key, &tmpIdx, rsa, keySz) == 0) {\n            *algoID = RSAk;\n        }\n        else {\n            WOLFSSL_MSG(\"Not RSA DER key\");\n        }\n        wc_FreeRsaKey(rsa);\n        XFREE(rsa, heap, DYNAMIC_TYPE_TMP_BUFFER);\n    }\n    #endif /* !NO_RSA && !NO_ASN_CRYPT */\n    #if defined(HAVE_ECC) && !defined(NO_ASN_CRYPT)\n    if (*algoID == 0) {\n        ecc_key *ecc = (ecc_key *)XMALLOC(sizeof *ecc, heap, DYNAMIC_TYPE_TMP_BUFFER);\n        if (ecc == NULL)\n            return MEMORY_E;\n\n        tmpIdx = 0;\n        wc_ecc_init_ex(ecc, heap, INVALID_DEVID);\n        if (wc_EccPrivateKeyDecode(key, &tmpIdx, ecc, keySz) == 0) {\n            *algoID = ECDSAk;\n\n            /* now find oid */\n            if (wc_ecc_get_oid(ecc->dp->oidSum, curveOID, oidSz) < 0) {\n                WOLFSSL_MSG(\"Error getting ECC curve OID\");\n                wc_ecc_free(ecc);\n                XFREE(ecc, heap, DYNAMIC_TYPE_TMP_BUFFER);\n                return BAD_FUNC_ARG;\n            }\n        }\n        else {\n            WOLFSSL_MSG(\"Not ECC DER key either\");\n        }\n        wc_ecc_free(ecc);\n        XFREE(ecc, heap, DYNAMIC_TYPE_TMP_BUFFER);\n    }\n#endif /* HAVE_ECC && !NO_ASN_CRYPT */\n#if defined(HAVE_ED25519) && !defined(NO_ASN_CRYPT)\n    if (*algoID != RSAk && *algoID != ECDSAk) {\n        ed25519_key *ed25519 = (ed25519_key *)XMALLOC(sizeof *ed25519, heap, DYNAMIC_TYPE_TMP_BUFFER);\n        if (ed25519 == NULL)\n            return MEMORY_E;\n\n        tmpIdx = 0;\n        if (wc_ed25519_init(ed25519) == 0) {\n            if (wc_Ed25519PrivateKeyDecode(key, &tmpIdx, ed25519, keySz) == 0) {\n                *algoID = ED25519k;\n            }\n            else {\n                WOLFSSL_MSG(\"Not ED25519 DER key\");\n            }\n            wc_ed25519_free(ed25519);\n        }\n        else {\n            WOLFSSL_MSG(\"GetKeyOID wc_ed25519_init failed\");\n        }\n        XFREE(ed25519, heap, DYNAMIC_TYPE_TMP_BUFFER);\n    }\n#endif /* HAVE_ED25519 && !NO_ASN_CRYPT */\n#if defined(HAVE_ED448) && !defined(NO_ASN_CRYPT)\n    if (*algoID != RSAk && *algoID != ECDSAk && *algoID != ED25519k) {\n        ed448_key *ed448 = (ed448_key *)XMALLOC(sizeof *ed448, heap, DYNAMIC_TYPE_TMP_BUFFER);\n        if (ed448 == NULL)\n            return MEMORY_E;\n\n        tmpIdx = 0;\n        if (wc_ed448_init(ed448) == 0) {\n            if (wc_Ed448PrivateKeyDecode(key, &tmpIdx, ed448, keySz) == 0) {\n                *algoID = ED448k;\n            }\n            else {\n                WOLFSSL_MSG(\"Not ED448 DER key\");\n            }\n            wc_ed448_free(ed448);\n        }\n        else {\n            WOLFSSL_MSG(\"GetKeyOID wc_ed448_init failed\");\n        }\n        XFREE(ed448, heap, DYNAMIC_TYPE_TMP_BUFFER);\n    }\n#endif /* HAVE_ED448 && !NO_ASN_CRYPT */\n\n    /* if flag is not set then is neither RSA or ECC key that could be\n     * found */\n    if (*algoID == 0) {\n        WOLFSSL_MSG(\"Bad key DER or compile options\");\n        return BAD_FUNC_ARG;\n    }\n\n    (void)tmpIdx;\n    (void)curveOID;\n    (void)oidSz;\n    (void)keySz;\n    (void)heap;\n\n    return 1;\n}\n\n#endif /* HAVE_PKCS8 */\n\n#if defined(HAVE_PKCS8) || defined(HAVE_PKCS12)\n\n#define PKCS8_MIN_BLOCK_SIZE 8\nstatic int Pkcs8Pad(byte* buf, int sz, int blockSz)\n{\n    int i, padSz;\n\n    /* calculate pad size */\n    padSz = blockSz - (sz & (blockSz - 1));\n\n    /* pad with padSz value */\n    if (buf) {\n        for (i = 0; i < padSz; i++) {\n            buf[sz+i] = (byte)(padSz & 0xFF);\n        }\n    }\n\n    /* return adjusted length */\n    return sz + padSz;\n}\n\n#endif /* HAVE_PKCS8 || HAVE_PKCS12 */\n\n#ifdef HAVE_PKCS8\n\n/*\n * Equivalent to calling TraditionalEnc with the same parameters but with\n * encAlgId set to 0. This function must be kept alive because it's sometimes\n * part of the API (WOLFSSL_ASN_API).\n */\nint UnTraditionalEnc(byte* key, word32 keySz, byte* out, word32* outSz,\n        const char* password, int passwordSz, int vPKCS, int vAlgo,\n        byte* salt, word32 saltSz, int itt, WC_RNG* rng, void* heap)\n{\n    return TraditionalEnc(key, keySz, out, outSz, password, passwordSz,\n                vPKCS, vAlgo, 0, salt, saltSz, itt, rng, heap);\n}\n\nstatic int GetAlgoV2(int encAlgId, const byte** oid, int *len, int* id,\n                     int *blkSz)\n{\n    int ret = 0;\n\n    switch (encAlgId) {\n#if !defined(NO_DES3) && !defined(NO_SHA)\n    case DESb:\n        *len = sizeof(blkDesCbcOid);\n        *oid = blkDesCbcOid;\n        *id = PBE_SHA1_DES;\n        *blkSz = 8;\n        break;\n    case DES3b:\n        *len = sizeof(blkDes3CbcOid);\n        *oid = blkDes3CbcOid;\n        *id = PBE_SHA1_DES3;\n        *blkSz = 8;\n        break;\n#endif\n#if defined(WOLFSSL_AES_256) && defined(HAVE_AES_CBC)\n    case AES256CBCb:\n        *len = sizeof(blkAes256CbcOid);\n        *oid = blkAes256CbcOid;\n        *id = PBE_AES256_CBC;\n        *blkSz = 16;\n        break;\n#endif\n    default:\n        (void)len;\n        (void)oid;\n        (void)id;\n        (void)blkSz;\n        ret = ALGO_ID_E;\n    }\n\n    return ret;\n}\n\nint wc_EncryptPKCS8Key(byte* key, word32 keySz, byte* out, word32* outSz,\n        const char* password, int passwordSz, int vPKCS, int pbeOid,\n        int encAlgId, byte* salt, word32 saltSz, int itt, WC_RNG* rng,\n        void* heap)\n{\n#ifdef WOLFSSL_SMALL_STACK\n    byte* saltTmp = NULL;\n#else\n    byte saltTmp[MAX_SALT_SIZE];\n#endif\n    int genSalt = 0;\n    int ret = 0;\n    int version = 0;\n    int pbeId = 0;\n    int blockSz = 0;\n    const byte* encOid = NULL;\n    int encOidSz = 0;\n    word32 padSz = 0;\n    word32 innerLen = 0;\n    word32 outerLen = 0;\n    const byte* pbeOidBuf = NULL;\n    word32 pbeOidBufSz = 0;\n    word32 pbeLen = 0;\n    word32 kdfLen = 0;\n    word32 encLen = 0;\n    byte cbcIv[MAX_IV_SIZE];\n    word32 idx = 0;\n    word32 encIdx = 0;\n\n    (void)heap;\n\n    WOLFSSL_ENTER(\"wc_EncryptPKCS8Key\");\n\n    if (key == NULL || outSz == NULL || password == NULL) {\n        ret = BAD_FUNC_ARG;\n    }\n\n    if (ret == 0) {\n        ret = CheckAlgo(vPKCS, pbeOid, &pbeId, &version, &blockSz);\n    }\n    if (ret == 0 && (salt == NULL || saltSz == 0)) {\n        genSalt = 1;\n        saltSz = 8;\n    }\n    if (ret == 0 && version == PKCS5v2) {\n        ret = GetAlgoV2(encAlgId, &encOid, &encOidSz, &pbeId, &blockSz);\n    }\n    if (ret == 0) {\n        padSz = (blockSz - (keySz & (blockSz - 1))) & (blockSz - 1);\n        /* inner = OCT salt INT itt */\n        innerLen = 2 + saltSz + 2 + (itt < 256 ? 1 : 2);\n\n        if (version != PKCS5v2) {\n            pbeOidBuf = OidFromId(pbeId, oidPBEType, &pbeOidBufSz);\n            /* pbe = OBJ pbse1 SEQ [ inner ] */\n            pbeLen = 2 + pbeOidBufSz + 2 + innerLen;\n        }\n        else {\n            pbeOidBuf = pbes2;\n            pbeOidBufSz = sizeof(pbes2);\n            /* kdf = OBJ pbkdf2 [ SEQ innerLen ] */\n            kdfLen = 2 + sizeof(pbkdf2Oid) + 2 + innerLen;\n            /* enc = OBJ enc_alg OCT iv */\n            encLen = 2 + encOidSz + 2 + blockSz;\n            /* pbe = OBJ pbse2 SEQ [ SEQ [ kdf ] SEQ [ enc ] ] */\n            pbeLen = 2 + sizeof(pbes2) + 2 + 2 + kdfLen + 2 + encLen;\n\n            ret = wc_RNG_GenerateBlock(rng, cbcIv, blockSz);\n        }\n    }\n    if (ret == 0) {\n        /* outerLen = length of PBE encoding + octet string data */\n        /* Plus 2 for tag and length for pbe */\n        outerLen = 2 + pbeLen;\n        /* Octet string tag, length */\n        outerLen += 1 + SetLength(keySz + padSz, NULL); \n        /* Octet string bytes */\n        outerLen += keySz + padSz;\n        if (out == NULL) {\n            /* Sequence tag, length */\n            *outSz = 1 + SetLength(outerLen, NULL) + outerLen;\n            return LENGTH_ONLY_E;\n        }\n        SetOctetString(keySz + padSz, out);\n\n        idx += SetSequence(outerLen, out + idx);\n\n        encIdx = idx + outerLen - keySz - padSz;\n        /* Put Encrypted content in place. */\n        XMEMCPY(out + encIdx, key, keySz);\n        if (padSz > 0) {\n            XMEMSET(out + encIdx + keySz, padSz, padSz);\n            keySz += padSz;\n        }\n\n        if (genSalt == 1) {\n        #ifdef WOLFSSL_SMALL_STACK\n            saltTmp = (byte*)XMALLOC(saltSz, heap, DYNAMIC_TYPE_TMP_BUFFER);\n            if (saltTmp == NULL) {\n                ret = MEMORY_E;\n            }\n            else\n        #endif\n            {\n                salt = saltTmp;\n                if ((ret = wc_RNG_GenerateBlock(rng, saltTmp, saltSz)) != 0) {\n                    WOLFSSL_MSG(\"Error generating random salt\");\n                }\n            }\n        }\n    }\n    if (ret == 0) {\n        ret = wc_CryptKey(password, passwordSz, salt, saltSz, itt, pbeId,\n                  out + encIdx, keySz, version, cbcIv, 1, 0);\n    }\n    if (ret == 0) {\n        if (version != PKCS5v2) {\n            /* PBE algorithm */\n            idx += SetSequence(pbeLen, out + idx);\n            idx += SetObjectId(pbeOidBufSz, out + idx);\n            XMEMCPY(out + idx, pbeOidBuf, pbeOidBufSz);\n            idx += pbeOidBufSz;\n        }\n        else {\n            /* PBES2 algorithm identifier */\n            idx += SetSequence(pbeLen, out + idx);\n            idx += SetObjectId(pbeOidBufSz, out + idx);\n            XMEMCPY(out + idx, pbeOidBuf, pbeOidBufSz);\n            idx += pbeOidBufSz;\n            /* PBES2 Parameters: SEQ [ kdf ] SEQ [ enc ] */\n            idx += SetSequence(2 + kdfLen + 2 + encLen, out + idx);\n            /* KDF Algorithm Identifier */\n            idx += SetSequence(kdfLen, out + idx);\n            idx += SetObjectId(sizeof(pbkdf2Oid), out + idx);\n            XMEMCPY(out + idx, pbkdf2Oid, sizeof(pbkdf2Oid));\n            idx += sizeof(pbkdf2Oid);\n        }\n        idx += SetSequence(innerLen, out + idx);\n        idx += SetOctetString(saltSz, out + idx);\n        XMEMCPY(out + idx, salt, saltSz); idx += saltSz;\n        ret = SetShortInt(out, &idx, itt, *outSz);\n        if (ret > 0)\n            ret = 0;\n    }\n    if (ret == 0) {\n        if (version == PKCS5v2) {\n            /* Encryption Algorithm Identifier */\n            idx += SetSequence(encLen, out + idx);\n            idx += SetObjectId(encOidSz, out + idx);\n            XMEMCPY(out + idx, encOid, encOidSz);\n            idx += encOidSz;\n            /* Encryption Algorithm Parameter: CBC IV */\n            idx += SetOctetString(blockSz, out + idx);\n            XMEMCPY(out + idx, cbcIv, blockSz);\n            idx += blockSz;\n        }\n        idx += SetOctetString(keySz, out + idx);\n        /* Default PRF - no need to write out OID */\n        idx += keySz;\n\n        ret = idx;\n    }\n\n#ifdef WOLFSSL_SMALL_STACK\n    if (saltTmp != NULL) {\n        XFREE(saltTmp, heap, DYNAMIC_TYPE_TMP_BUFFER);\n    }\n#endif\n\n    WOLFSSL_LEAVE(\"wc_EncryptPKCS8Key\", ret);\n\n    return ret;\n}\n\nint wc_DecryptPKCS8Key(byte* input, word32 sz, const char* password,\n        int passwordSz)\n{\n    int ret;\n    int length;\n    word32 inOutIdx = 0;\n\n    if (input == NULL || password == NULL) {\n        return BAD_FUNC_ARG;\n    }\n\n    if (GetSequence(input, &inOutIdx, &length, sz) < 0) {\n        ret = ASN_PARSE_E;\n    }\n    else {\n        ret = DecryptContent(input + inOutIdx, sz - inOutIdx, password,\n                passwordSz);\n        if (ret > 0) {\n            XMEMMOVE(input, input + inOutIdx, ret);\n        }\n    }\n\n    if (ret > 0) {\n        /* DecryptContent will decrypt the data, but it will leave any padding\n         * bytes intact. This code calculates the length without the padding\n         * and we return that to the user. */\n        inOutIdx = 0;\n        if (GetSequence(input, &inOutIdx, &length, ret) < 0) {\n            ret = ASN_PARSE_E;\n        }\n        else {\n            ret = inOutIdx + length;\n        }\n    }\n\n    return ret;\n}\n\n/* Takes an unencrypted, traditional DER-encoded key and converts it to a PKCS#8\n * encrypted key. If out is not NULL, it will hold the encrypted key. If it's\n * NULL, LENGTH_ONLY_E will be returned and outSz will have the required out\n * buffer size. */\nint TraditionalEnc(byte* key, word32 keySz, byte* out, word32* outSz,\n        const char* password, int passwordSz, int vPKCS, int vAlgo,\n        int encAlgId, byte* salt, word32 saltSz, int itt, WC_RNG* rng,\n        void* heap)\n{\n    int ret = 0;\n    byte *pkcs8Key = NULL;\n    word32 pkcs8KeySz = 0;\n    int algId = 0;\n    const byte* curveOid = NULL;\n    word32 curveOidSz = 0;\n\n    if (ret == 0) {\n        /* check key type and get OID if ECC */\n        ret = wc_GetKeyOID(key, keySz, &curveOid, &curveOidSz, &algId, heap);\n        if (ret == 1)\n            ret = 0;\n    }\n    if (ret == 0) {\n        ret = wc_CreatePKCS8Key(NULL, &pkcs8KeySz, key, keySz, algId, curveOid,\n                                                                    curveOidSz);\n        if (ret == LENGTH_ONLY_E)\n            ret = 0;\n    }\n    if (ret == 0) {\n        pkcs8Key = (byte*)XMALLOC(pkcs8KeySz, heap, DYNAMIC_TYPE_TMP_BUFFER);\n        if (pkcs8Key == NULL)\n            ret = MEMORY_E;\n    }\n    if (ret == 0) {\n        ret = wc_CreatePKCS8Key(pkcs8Key, &pkcs8KeySz, key, keySz, algId,\n            curveOid, curveOidSz);\n        if (ret >= 0) {\n            pkcs8KeySz = ret;\n            ret = 0;\n        }\n    }\n    if (ret == 0) {\n        ret = wc_EncryptPKCS8Key(pkcs8Key, pkcs8KeySz, out, outSz, password,\n            passwordSz, vPKCS, vAlgo, encAlgId, salt, saltSz, itt, rng, heap);\n    }\n\n    if (pkcs8Key != NULL) {\n        ForceZero(pkcs8Key, pkcs8KeySz);\n        XFREE(pkcs8Key, heap, DYNAMIC_TYPE_TMP_BUFFER);\n    }\n\n    (void)rng;\n\n    return ret;\n}\n\n/* Same as TraditionalEnc, but in the public API. */\nint wc_CreateEncryptedPKCS8Key(byte* key, word32 keySz, byte* out,\n        word32* outSz, const char* password, int passwordSz, int vPKCS,\n        int pbeOid, int encAlgId, byte* salt, word32 saltSz, int itt,\n        WC_RNG* rng, void* heap)\n{\n    return TraditionalEnc(key, keySz, out, outSz, password, passwordSz, vPKCS,\n        pbeOid, encAlgId, salt, saltSz, itt, rng, heap);\n}\n\n\n#endif /* HAVE_PKCS8 */\n\n#if defined(HAVE_PKCS8) || defined(HAVE_PKCS12)\n/* decrypt PKCS\n *\n * NOTE: input buffer is overwritten with decrypted data!\n *\n * input[in/out] data to decrypt and results are written to\n * sz            size of input buffer\n * password      password if used. Can be NULL for no password\n * passwordSz    size of password buffer\n *\n * returns the total size of decrypted content on success.\n */\nint DecryptContent(byte* input, word32 sz, const char* password, int passwordSz)\n{\n    word32 inOutIdx = 0, seqEnd, oid, shaOid = 0;\n    int    ret = 0, first, second, length = 0, version, saltSz, id;\n    int    iterations = 0, keySz = 0;\n#ifdef WOLFSSL_SMALL_STACK\n    byte*  salt = NULL;\n    byte*  cbcIv = NULL;\n#else\n    byte   salt[MAX_SALT_SIZE];\n    byte   cbcIv[MAX_IV_SIZE];\n#endif\n    byte   tag;\n\n    if (passwordSz < 0) {\n        WOLFSSL_MSG(\"Bad password size\");\n        return BAD_FUNC_ARG;\n    }\n\n    if (GetAlgoId(input, &inOutIdx, &oid, oidIgnoreType, sz) < 0) {\n        ERROR_OUT(ASN_PARSE_E, exit_dc);\n    }\n\n    first  = input[inOutIdx - 2];   /* PKCS version always 2nd to last byte */\n    second = input[inOutIdx - 1];   /* version.algo, algo id last byte */\n\n    if (CheckAlgo(first, second, &id, &version, NULL) < 0) {\n        ERROR_OUT(ASN_INPUT_E, exit_dc); /* Algo ID error */\n    }\n\n    if (version == PKCS5v2) {\n        if (GetSequence(input, &inOutIdx, &length, sz) < 0) {\n            ERROR_OUT(ASN_PARSE_E, exit_dc);\n        }\n\n        if (GetAlgoId(input, &inOutIdx, &oid, oidKdfType, sz) < 0) {\n            ERROR_OUT(ASN_PARSE_E, exit_dc);\n        }\n\n        if (oid != PBKDF2_OID) {\n            ERROR_OUT(ASN_PARSE_E, exit_dc);\n        }\n    }\n\n    if (GetSequence(input, &inOutIdx, &length, sz) <= 0) {\n        ERROR_OUT(ASN_PARSE_E, exit_dc);\n    }\n    /* Find the end of this SEQUENCE so we can check for the OPTIONAL and\n     * DEFAULT items. */\n    seqEnd = inOutIdx + length;\n\n    ret = GetOctetString(input, &inOutIdx, &saltSz, sz);\n    if (ret < 0)\n        goto exit_dc;\n\n    if (saltSz > MAX_SALT_SIZE) {\n        ERROR_OUT(ASN_PARSE_E, exit_dc);\n    }\n\n#ifdef WOLFSSL_SMALL_STACK\n    salt = (byte*)XMALLOC(MAX_SALT_SIZE, NULL, DYNAMIC_TYPE_TMP_BUFFER);\n    if (salt == NULL) {\n        ERROR_OUT(MEMORY_E, exit_dc);\n    }\n#endif\n\n    XMEMCPY(salt, &input[inOutIdx], saltSz);\n    inOutIdx += saltSz;\n\n    if (GetShortInt(input, &inOutIdx, &iterations, sz) < 0) {\n        ERROR_OUT(ASN_PARSE_E, exit_dc);\n    }\n\n    /* OPTIONAL key length */\n    if (seqEnd > inOutIdx) {\n        word32 localIdx = inOutIdx;\n\n        if (GetASNTag(input, &localIdx, &tag, sz) < 0) {\n            ERROR_OUT(ASN_PARSE_E, exit_dc);\n        }\n\n        if (tag == ASN_INTEGER &&\n                GetShortInt(input, &inOutIdx, &keySz, sz) < 0) {\n            ERROR_OUT(ASN_PARSE_E, exit_dc);\n        }\n    }\n\n    /* DEFAULT HMAC is SHA-1 */\n    if (seqEnd > inOutIdx) {\n        if (GetAlgoId(input, &inOutIdx, &oid, oidHmacType, sz) < 0) {\n            ERROR_OUT(ASN_PARSE_E, exit_dc);\n        }\n\n        shaOid = oid;\n    }\n\n#ifdef WOLFSSL_SMALL_STACK\n    cbcIv = (byte*)XMALLOC(MAX_IV_SIZE, NULL, DYNAMIC_TYPE_TMP_BUFFER);\n    if (cbcIv == NULL) {\n        ERROR_OUT(MEMORY_E, exit_dc);\n    }\n#endif\n\n    if (version == PKCS5v2) {\n        /* get encryption algo */\n        if (GetAlgoId(input, &inOutIdx, &oid, oidBlkType, sz) < 0) {\n            ERROR_OUT(ASN_PARSE_E, exit_dc);\n        }\n\n        if (CheckAlgoV2(oid, &id, NULL) < 0) {\n            ERROR_OUT(ASN_PARSE_E, exit_dc); /* PKCS v2 algo id error */\n        }\n\n        if (shaOid == 0)\n            shaOid = oid;\n\n        ret = GetOctetString(input, &inOutIdx, &length, sz);\n        if (ret < 0)\n            goto exit_dc;\n\n        if (length > MAX_IV_SIZE) {\n            ERROR_OUT(ASN_PARSE_E, exit_dc);\n        }\n\n        XMEMCPY(cbcIv, &input[inOutIdx], length);\n        inOutIdx += length;\n    }\n\n    if (GetASNTag(input, &inOutIdx, &tag, sz) < 0) {\n        ERROR_OUT(ASN_PARSE_E, exit_dc);\n    }\n\n    if (tag != (ASN_CONTEXT_SPECIFIC | 0) && tag != ASN_OCTET_STRING) {\n        ERROR_OUT(ASN_PARSE_E, exit_dc);\n    }\n\n    if (GetLength(input, &inOutIdx, &length, sz) < 0) {\n        ERROR_OUT(ASN_PARSE_E, exit_dc);\n    }\n\n    ret = wc_CryptKey(password, passwordSz, salt, saltSz, iterations, id,\n                   input + inOutIdx, length, version, cbcIv, 0, shaOid);\n\nexit_dc:\n#ifdef WOLFSSL_SMALL_STACK\n    XFREE(salt,  NULL, DYNAMIC_TYPE_TMP_BUFFER);\n    XFREE(cbcIv, NULL, DYNAMIC_TYPE_TMP_BUFFER);\n#endif\n\n    if (ret == 0) {\n        XMEMMOVE(input, input + inOutIdx, length);\n        ret = length;\n    }\n\n    return ret;\n}\n\n/* Remove Encrypted PKCS8 header, move beginning of traditional to beginning\n   of input */\nint ToTraditionalEnc(byte* input, word32 sz, const char* password,\n                     int passwordSz, word32* algId)\n{\n    int ret;\n\n    ret = wc_DecryptPKCS8Key(input, sz, password, passwordSz);\n    if (ret > 0) {\n        ret = ToTraditional_ex(input, ret, algId);\n    }\n\n    return ret;\n}\n\n#endif /* HAVE_PKCS8 || HAVE_PKCS12 */\n\n#ifdef HAVE_PKCS12\n\n/* encrypt PKCS 12 content\n *\n * NOTE: if out is NULL then outSz is set with the total buffer size needed and\n *       the error value LENGTH_ONLY_E is returned.\n *\n * input      data to encrypt\n * inputSz    size of input buffer\n * out        buffer to hold the result\n * outSz      size of out buffer\n * password   password if used. Can be NULL for no password\n * passwordSz size of password buffer\n * vPKCS      version of PKCS i.e. PKCS5v2\n * vAlgo      algorithm version\n * salt       buffer holding salt if used. If NULL then a random salt is created\n * saltSz     size of salt buffer if it is not NULL\n * itt        number of iterations used\n * rng        random number generator to use\n * heap       possible heap hint for mallocs/frees\n *\n * returns the total size of encrypted content on success.\n *\n * data returned is :\n * [ seq - obj [ seq -salt,itt]] , construct with encrypted data\n */\nint EncryptContent(byte* input, word32 inputSz, byte* out, word32* outSz,\n        const char* password, int passwordSz, int vPKCS, int vAlgo,\n        byte* salt, word32 saltSz, int itt, WC_RNG* rng, void* heap)\n{\n    word32 sz;\n    word32 inOutIdx = 0;\n    word32 tmpIdx   = 0;\n    word32 totalSz  = 0;\n    word32 seqSz;\n    word32 innerSz;\n    int    ret;\n    int    version, id, blockSz = 0;\n#ifdef WOLFSSL_SMALL_STACK\n    byte*  saltTmp = NULL;\n    byte*  cbcIv   = NULL;\n#else\n    byte   saltTmp[MAX_SALT_SIZE];\n    byte   cbcIv[MAX_IV_SIZE];\n#endif\n    byte   seq[MAX_SEQ_SZ];\n    byte   shr[MAX_SHORT_SZ];\n    word32 maxShr = MAX_SHORT_SZ;\n    word32 algoSz;\n    const  byte* algoName;\n\n    (void)heap;\n\n    WOLFSSL_ENTER(\"EncryptContent()\");\n\n    if (CheckAlgo(vPKCS, vAlgo, &id, &version, &blockSz) < 0)\n        return ASN_INPUT_E;  /* Algo ID error */\n\n    if (version == PKCS5v2) {\n        WOLFSSL_MSG(\"PKCS#5 version 2 not supported yet\");\n        return BAD_FUNC_ARG;\n    }\n\n    if (saltSz > MAX_SALT_SIZE)\n        return ASN_PARSE_E;\n\n    if (outSz == NULL) {\n        return BAD_FUNC_ARG;\n    }\n\n    /* calculate size */\n    /* size of constructed string at end */\n    sz = Pkcs8Pad(NULL, inputSz, blockSz);\n    totalSz  = ASN_TAG_SZ;\n    totalSz += SetLength(sz, seq);\n    totalSz += sz;\n\n    /* size of sequence holding object id and sub sequence of salt and itt */\n    algoName = OidFromId(id, oidPBEType, &algoSz);\n    if (algoName == NULL) {\n        WOLFSSL_MSG(\"Unknown Algorithm\");\n        return 0;\n    }\n    innerSz = SetObjectId(algoSz, seq);\n    innerSz += algoSz;\n\n    /* get subsequence of salt and itt */\n    if (salt == NULL || saltSz == 0) {\n        sz = 8;\n    }\n    else {\n        sz = saltSz;\n    }\n    seqSz  = SetOctetString(sz, seq);\n    seqSz += sz;\n\n    tmpIdx = 0;\n    ret = SetShortInt(shr, &tmpIdx, itt, maxShr);\n    if (ret >= 0) {\n        seqSz += ret;\n    }\n    else {\n        return ret;\n    }\n    innerSz += seqSz + SetSequence(seqSz, seq);\n    totalSz += innerSz + SetSequence(innerSz, seq);\n\n    if (out == NULL) {\n        *outSz = totalSz;\n        return LENGTH_ONLY_E;\n    }\n\n    inOutIdx = 0;\n    if (totalSz > *outSz)\n        return BUFFER_E;\n\n    inOutIdx += SetSequence(innerSz, out + inOutIdx);\n    inOutIdx += SetObjectId(algoSz, out + inOutIdx);\n    XMEMCPY(out + inOutIdx, algoName, algoSz);\n    inOutIdx += algoSz;\n    inOutIdx += SetSequence(seqSz, out + inOutIdx);\n\n    /* create random salt if one not provided */\n    if (salt == NULL || saltSz == 0) {\n        saltSz = 8;\n    #ifdef WOLFSSL_SMALL_STACK\n        saltTmp = (byte*)XMALLOC(saltSz, heap, DYNAMIC_TYPE_TMP_BUFFER);\n        if (saltTmp == NULL)\n            return MEMORY_E;\n    #endif\n        salt = saltTmp;\n\n        if ((ret = wc_RNG_GenerateBlock(rng, saltTmp, saltSz)) != 0) {\n            WOLFSSL_MSG(\"Error generating random salt\");\n        #ifdef WOLFSSL_SMALL_STACK\n            XFREE(saltTmp, heap, DYNAMIC_TYPE_TMP_BUFFER);\n        #endif\n            return ret;\n        }\n    }\n    inOutIdx += SetOctetString(saltSz, out + inOutIdx);\n    if (saltSz + inOutIdx > *outSz) {\n    #ifdef WOLFSSL_SMALL_STACK\n        XFREE(saltTmp, heap, DYNAMIC_TYPE_TMP_BUFFER);\n    #endif\n        return BUFFER_E;\n    }\n    XMEMCPY(out + inOutIdx, salt, saltSz);\n    inOutIdx += saltSz;\n\n    /* place iteration setting in buffer */\n    ret = SetShortInt(out, &inOutIdx, itt, *outSz);\n    if (ret < 0) {\n    #ifdef WOLFSSL_SMALL_STACK\n        XFREE(saltTmp, heap, DYNAMIC_TYPE_TMP_BUFFER);\n    #endif\n        return ret;\n    }\n\n    if (inOutIdx + 1 > *outSz) {\n    #ifdef WOLFSSL_SMALL_STACK\n        XFREE(saltTmp, heap, DYNAMIC_TYPE_TMP_BUFFER);\n    #endif\n        return BUFFER_E;\n    }\n    out[inOutIdx++] = ASN_CONTEXT_SPECIFIC | 0;\n\n    /* get pad size and verify buffer room */\n    sz = Pkcs8Pad(NULL, inputSz, blockSz);\n    if (sz + inOutIdx > *outSz) {\n    #ifdef WOLFSSL_SMALL_STACK\n        XFREE(saltTmp, heap, DYNAMIC_TYPE_TMP_BUFFER);\n    #endif\n        return BUFFER_E;\n    }\n    inOutIdx += SetLength(sz, out + inOutIdx);\n\n    /* copy input to output buffer and pad end */\n    XMEMCPY(out + inOutIdx, input, inputSz);\n    sz = Pkcs8Pad(out + inOutIdx, inputSz, blockSz);\n#ifdef WOLFSSL_SMALL_STACK\n    cbcIv = (byte*)XMALLOC(MAX_IV_SIZE, heap, DYNAMIC_TYPE_TMP_BUFFER);\n    if (cbcIv == NULL) {\n        XFREE(saltTmp, heap, DYNAMIC_TYPE_TMP_BUFFER);\n        return MEMORY_E;\n    }\n#endif\n\n    /* encrypt */\n    if ((ret = wc_CryptKey(password, passwordSz, salt, saltSz, itt, id,\n                   out + inOutIdx, sz, version, cbcIv, 1, 0)) < 0) {\n\n    #ifdef WOLFSSL_SMALL_STACK\n        XFREE(cbcIv,   heap, DYNAMIC_TYPE_TMP_BUFFER);\n        XFREE(saltTmp, heap, DYNAMIC_TYPE_TMP_BUFFER);\n    #endif\n        return ret;  /* encrypt failure */\n    }\n\n#ifdef WOLFSSL_SMALL_STACK\n    XFREE(cbcIv,   heap, DYNAMIC_TYPE_TMP_BUFFER);\n    XFREE(saltTmp, heap, DYNAMIC_TYPE_TMP_BUFFER);\n#endif\n\n    (void)rng;\n\n    return inOutIdx + sz;\n}\n\n\n#endif /* HAVE_PKCS12 */\n#endif /* NO_PWDBASED */\n\n#ifndef NO_RSA\n\n#ifndef HAVE_USER_RSA\n#ifdef WOLFSSL_RENESAS_TSIP\n/* This function is to retrieve key position information in a cert.*\n * The information will be used to call TSIP TLS-linked API for    *\n * certificate verification.                                       */\nstatic int RsaPublicKeyDecodeRawIndex(const byte* input, word32* inOutIdx,\n                                      word32 inSz, word32* key_n,\n                                      word32* key_n_len, word32* key_e,\n                                      word32* key_e_len)\n{\n\n    int ret = 0;\n    int length = 0;\n#if defined(OPENSSL_EXTRA) || defined(RSA_DECODE_EXTRA)\n    byte b;\n#endif\n\n    if (input == NULL || inOutIdx == NULL)\n        return BAD_FUNC_ARG;\n\n    if (GetSequence(input, inOutIdx, &length, inSz) < 0)\n        return ASN_PARSE_E;\n\n#if defined(OPENSSL_EXTRA) || defined(RSA_DECODE_EXTRA)\n    if ((*inOutIdx + 1) > inSz)\n        return BUFFER_E;\n\n    b = input[*inOutIdx];\n    if (b != ASN_INTEGER) {\n        /* not from decoded cert, will have algo id, skip past */\n        if (GetSequence(input, inOutIdx, &length, inSz) < 0)\n            return ASN_PARSE_E;\n\n        if (SkipObjectId(input, inOutIdx, inSz) < 0)\n            return ASN_PARSE_E;\n\n        /* Option NULL ASN.1 tag */\n        if (*inOutIdx  >= inSz) {\n            return BUFFER_E;\n        }\n        if (input[*inOutIdx] == ASN_TAG_NULL) {\n            ret = GetASNNull(input, inOutIdx, inSz);\n            if (ret != 0)\n                return ret;\n        }\n\n        /* should have bit tag length and seq next */\n        ret = CheckBitString(input, inOutIdx, NULL, inSz, 1, NULL);\n        if (ret != 0)\n            return ret;\n\n        if (GetSequence(input, inOutIdx, &length, inSz) < 0)\n            return ASN_PARSE_E;\n    }\n#endif /* OPENSSL_EXTRA */\n\n    /* Get modulus */\n    ret = GetASNInt(input, inOutIdx, &length, inSz);\n    *key_n += *inOutIdx;\n    if (ret < 0) {\n        return ASN_RSA_KEY_E;\n    }\n    if (key_n_len)\n        *key_n_len = length;\n    *inOutIdx += length;\n\n    /* Get exponent */\n    ret = GetASNInt(input, inOutIdx, &length, inSz);\n    *key_e += *inOutIdx;\n    if (ret < 0) {\n        return ASN_RSA_KEY_E;\n    }\n    if (key_e_len)\n        *key_e_len = length;\n\n    return ret;\n}\n#endif /* WOLFSSL_RENESAS_TSIP */\n\nint wc_RsaPublicKeyDecode_ex(const byte* input, word32* inOutIdx, word32 inSz,\n    const byte** n, word32* nSz, const byte** e, word32* eSz)\n{\n    int ret = 0;\n    int length = 0;\n#if defined(OPENSSL_EXTRA) || defined(RSA_DECODE_EXTRA)\n    word32 localIdx;\n    byte   tag;\n#endif\n\n    if (input == NULL || inOutIdx == NULL)\n        return BAD_FUNC_ARG;\n\n    if (GetSequence(input, inOutIdx, &length, inSz) < 0)\n        return ASN_PARSE_E;\n\n#if defined(OPENSSL_EXTRA) || defined(RSA_DECODE_EXTRA)\n    localIdx = *inOutIdx;\n    if (GetASNTag(input, &localIdx, &tag, inSz) < 0)\n        return BUFFER_E;\n\n    if (tag != ASN_INTEGER) {\n        /* not from decoded cert, will have algo id, skip past */\n        if (GetSequence(input, inOutIdx, &length, inSz) < 0)\n            return ASN_PARSE_E;\n\n        if (SkipObjectId(input, inOutIdx, inSz) < 0)\n            return ASN_PARSE_E;\n\n        /* Option NULL ASN.1 tag */\n        if (*inOutIdx  >= inSz) {\n            return BUFFER_E;\n        }\n\n        localIdx = *inOutIdx;\n        if (GetASNTag(input, &localIdx, &tag, inSz) < 0)\n            return ASN_PARSE_E;\n\n        if (tag == ASN_TAG_NULL) {\n            ret = GetASNNull(input, inOutIdx, inSz);\n            if (ret != 0)\n                return ret;\n        }\n\n        /* should have bit tag length and seq next */\n        ret = CheckBitString(input, inOutIdx, NULL, inSz, 1, NULL);\n        if (ret != 0)\n            return ret;\n\n        if (GetSequence(input, inOutIdx, &length, inSz) < 0)\n            return ASN_PARSE_E;\n    }\n#endif /* OPENSSL_EXTRA */\n\n    /* Get modulus */\n    ret = GetASNInt(input, inOutIdx, &length, inSz);\n    if (ret < 0) {\n        return ASN_RSA_KEY_E;\n    }\n    if (nSz)\n        *nSz = length;\n    if (n)\n        *n = &input[*inOutIdx];\n    *inOutIdx += length;\n\n    /* Get exponent */\n    ret = GetASNInt(input, inOutIdx, &length, inSz);\n    if (ret < 0) {\n        return ASN_RSA_KEY_E;\n    }\n    if (eSz)\n        *eSz = length;\n    if (e)\n        *e = &input[*inOutIdx];\n    *inOutIdx += length;\n\n    return ret;\n}\n\nint wc_RsaPublicKeyDecode(const byte* input, word32* inOutIdx, RsaKey* key,\n                       word32 inSz)\n{\n    int ret;\n    const byte *n = NULL, *e = NULL;\n    word32 nSz = 0, eSz = 0;\n\n    if (key == NULL)\n        return BAD_FUNC_ARG;\n\n    ret = wc_RsaPublicKeyDecode_ex(input, inOutIdx, inSz, &n, &nSz, &e, &eSz);\n    if (ret == 0) {\n        ret = wc_RsaPublicKeyDecodeRaw(n, nSz, e, eSz, key);\n    }\n\n    return ret;\n}\n\n/* import RSA public key elements (n, e) into RsaKey structure (key) */\nint wc_RsaPublicKeyDecodeRaw(const byte* n, word32 nSz, const byte* e,\n                             word32 eSz, RsaKey* key)\n{\n    if (n == NULL || e == NULL || key == NULL)\n        return BAD_FUNC_ARG;\n\n    key->type = RSA_PUBLIC;\n\n    if (mp_init(&key->n) != MP_OKAY)\n        return MP_INIT_E;\n\n    if (mp_read_unsigned_bin(&key->n, n, nSz) != 0) {\n        mp_clear(&key->n);\n        return ASN_GETINT_E;\n    }\n#ifdef HAVE_WOLF_BIGINT\n    if ((int)nSz > 0 && wc_bigint_from_unsigned_bin(&key->n.raw, n, nSz) != 0) {\n        mp_clear(&key->n);\n        return ASN_GETINT_E;\n    }\n#endif /* HAVE_WOLF_BIGINT */\n\n    if (mp_init(&key->e) != MP_OKAY) {\n        mp_clear(&key->n);\n        return MP_INIT_E;\n    }\n\n    if (mp_read_unsigned_bin(&key->e, e, eSz) != 0) {\n        mp_clear(&key->n);\n        mp_clear(&key->e);\n        return ASN_GETINT_E;\n    }\n#ifdef HAVE_WOLF_BIGINT\n    if ((int)eSz > 0 && wc_bigint_from_unsigned_bin(&key->e.raw, e, eSz) != 0) {\n        mp_clear(&key->n);\n        mp_clear(&key->e);\n        return ASN_GETINT_E;\n    }\n#endif /* HAVE_WOLF_BIGINT */\n\n#ifdef WOLFSSL_XILINX_CRYPT\n    if (wc_InitRsaHw(key) != 0) {\n        return BAD_STATE_E;\n    }\n#endif\n\n    return 0;\n}\n#endif /* HAVE_USER_RSA */\n#endif /* !NO_RSA */\n\n#ifndef NO_DH\n#if defined(WOLFSSL_DH_EXTRA)\n/*\n * Decodes DH public key to fill specified DhKey.\n *\n * return 0 on success, negative on failure\n */\nint wc_DhPublicKeyDecode(const byte* input, word32* inOutIdx,\n                DhKey* key, word32 inSz)\n{\n    int ret = 0;\n    int length;\n    word32 oid = 0;\n\n    if (input == NULL || inOutIdx == NULL || key == NULL || inSz == 0)\n        return BAD_FUNC_ARG;\n\n    if (GetSequence(input, inOutIdx, &length, inSz) < 0)\n        return ASN_PARSE_E;\n\n    if (GetSequence(input, inOutIdx, &length, inSz) < 0)\n        return ASN_PARSE_E;\n\n    ret = GetObjectId(input, inOutIdx, &oid, oidKeyType, inSz);\n    if (oid != DHk || ret < 0)\n        return ASN_DH_KEY_E;\n\n    if (GetSequence(input, inOutIdx, &length, inSz) < 0)\n        return ASN_PARSE_E;\n\n    if (GetInt(&key->p, input, inOutIdx, inSz) < 0)\n        return ASN_DH_KEY_E;\n\n    if (GetInt(&key->g, input, inOutIdx, inSz) < 0) {\n        mp_clear(&key->p);\n        return ASN_DH_KEY_E;\n    }\n    ret = (CheckBitString(input, inOutIdx, &length, inSz, 0, NULL) == 0);\n    if (ret > 0) {\n        /* Found Bit String WOLFSSL_DH_EXTRA is required to access DhKey.pub */\n        if (GetInt(&key->pub, input, inOutIdx, inSz) < 0) {\n            mp_clear(&key->p);\n            mp_clear(&key->g);\n            return ASN_DH_KEY_E;\n        }\n    }\n    else {\n        mp_clear(&key->p);\n        mp_clear(&key->g);\n        return ASN_DH_KEY_E;\n    }\n    return 0;\n}\n#endif /* WOLFSSL_DH_EXTRA */\n\n/* Supports either:\n * - DH params G/P (PKCS#3 DH) file or\n * - DH key file (if WOLFSSL_DH_EXTRA enabled) */\n/* The wc_DhParamsLoad function also loads DH params, but directly into buffers, not DhKey */\nint wc_DhKeyDecode(const byte* input, word32* inOutIdx, DhKey* key, word32 inSz)\n{\n    int ret = 0;\n    int length;\n#ifdef WOLFSSL_DH_EXTRA\n    #if !defined(HAVE_FIPS) || \\\n        (defined(HAVE_FIPS_VERSION) && (HAVE_FIPS_VERSION > 2))\n    word32 oid = 0, temp = 0;\n    #endif\n#endif\n\n    WOLFSSL_ENTER(\"wc_DhKeyDecode\");\n\n    if (inOutIdx == NULL)\n        return BAD_FUNC_ARG;\n\n    if (GetSequence(input, inOutIdx, &length, inSz) < 0)\n        return ASN_PARSE_E;\n\n#ifdef WOLFSSL_DH_EXTRA\n    #if !defined(HAVE_FIPS) || \\\n        (defined(HAVE_FIPS_VERSION) && (HAVE_FIPS_VERSION > 2))\n    temp = *inOutIdx;\n    #endif\n#endif\n    /* Assume input started after 1.2.840.113549.1.3.1 dhKeyAgreement */\n    if (GetInt(&key->p, input, inOutIdx, inSz) < 0) {\n        ret = ASN_DH_KEY_E;\n    }\n    if (ret == 0 && GetInt(&key->g, input, inOutIdx, inSz) < 0) {\n        mp_clear(&key->p);\n        ret = ASN_DH_KEY_E;\n    }\n\n#ifdef WOLFSSL_DH_EXTRA\n    #if !defined(HAVE_FIPS) || \\\n        (defined(HAVE_FIPS_VERSION) && (HAVE_FIPS_VERSION > 2))\n    /* If ASN_DH_KEY_E: Check if input started at beginning of key */\n    if (ret == ASN_DH_KEY_E) {\n        *inOutIdx = temp;\n\n        /* the version (0) - private only (for public skip) */\n        if (GetASNInt(input, inOutIdx, &length, inSz) == 0) {\n            *inOutIdx += length;\n        }\n\n        /* Size of dhKeyAgreement section */\n        if (GetSequence(input, inOutIdx, &length, inSz) < 0)\n            return ASN_PARSE_E;\n\n        /* Check for dhKeyAgreement */\n        ret = GetObjectId(input, inOutIdx, &oid, oidKeyType, inSz);\n        if (oid != DHk || ret < 0)\n            return ASN_DH_KEY_E;\n\n        if (GetSequence(input, inOutIdx, &length, inSz) < 0)\n            return ASN_PARSE_E;\n\n        if (GetInt(&key->p, input, inOutIdx, inSz) < 0) {\n            return ASN_DH_KEY_E;\n        }\n        if (ret == 0 && GetInt(&key->g, input, inOutIdx, inSz) < 0) {\n            mp_clear(&key->p);\n            return ASN_DH_KEY_E;\n        }\n    }\n\n    temp = *inOutIdx;\n    ret = (CheckBitString(input, inOutIdx, &length, inSz, 0, NULL) == 0);\n    if (ret > 0) {\n        /* Found Bit String */\n        if (GetInt(&key->pub, input, inOutIdx, inSz) == 0) {\n            WOLFSSL_MSG(\"Found Public Key\");\n            ret = 0;\n        }\n    } else {\n        *inOutIdx = temp;\n        ret = (GetOctetString(input, inOutIdx, &length, inSz) >= 0);\n        if (ret > 0) {\n            /* Found Octet String */\n            if (GetInt(&key->priv, input, inOutIdx, inSz) == 0) {\n                WOLFSSL_MSG(\"Found Private Key\");\n\n                /* Compute public */\n                ret = mp_exptmod(&key->g, &key->priv, &key->p, &key->pub);\n            }\n        } else {\n            /* Don't use length from failed CheckBitString/GetOctetString */\n            *inOutIdx = temp;\n            ret = 0;\n        }\n    }\n    #endif /* !HAVE_FIPS || HAVE_FIPS_VERSION > 2 */\n#endif /* WOLFSSL_DH_EXTRA */\n\n    WOLFSSL_LEAVE(\"wc_DhKeyDecode\", ret);\n\n    return ret;\n}\n\n#ifdef WOLFSSL_DH_EXTRA\n\n/* Export DH Key (private or public) */\nint wc_DhKeyToDer(DhKey* key, byte* output, word32* outSz, int exportPriv)\n{\n    int ret, privSz = 0, pubSz = 0, keySz;\n    word32 idx, total;\n\n    if (key == NULL || outSz == NULL) {\n        return BAD_FUNC_ARG;\n    }\n\n    /* determine size */\n    if (exportPriv) {\n        /* octect string: priv */\n        privSz = SetASNIntMP(&key->priv, -1, NULL);\n        idx = 1 + SetLength(privSz, NULL) + privSz; /* +1 for ASN_OCTET_STRING */\n    }\n    else {\n        /* bit string: public */\n        pubSz = SetASNIntMP(&key->pub, -1, NULL);\n        idx = SetBitString(pubSz, 0, NULL) + pubSz;\n    }\n    keySz = idx;\n\n    /* DH Parameters sequence with P and G */\n    total = 0;\n    ret = wc_DhParamsToDer(key, NULL, &total);\n    if (ret != LENGTH_ONLY_E)\n        return ret;\n    idx += total;\n\n    /* object dhKeyAgreement 1.2.840.113549.1.3.1 */\n    idx += SetObjectId(sizeof(keyDhOid), NULL);\n    idx += sizeof(keyDhOid);\n    /* sequence */\n    idx += SetSequence(idx, NULL);\n    if (exportPriv) {\n        /* version: 0 (ASN_INTEGER, 0x01, 0x00) */\n        idx += 3;\n    }\n    /* sequence */\n    total = idx + SetSequence(idx, NULL);\n\n    /* if no output, then just getting size */\n    if (output == NULL) {\n        *outSz = total;\n        return LENGTH_ONLY_E;\n    }\n\n    /* make sure output fits in buffer */\n    if (total > *outSz) {\n        return BUFFER_E;\n    }\n    total = idx;\n\n    /* sequence */\n    idx = SetSequence(total, output);\n    if (exportPriv) {\n        /* version: 0 */\n        idx += SetMyVersion(0, output + idx, 0);\n    }\n    /* sequence - all but pub/priv */\n    idx += SetSequence(total - keySz - idx, output + idx);\n    /* object dhKeyAgreement 1.2.840.113549.1.3.1 */\n    idx += SetObjectId(sizeof(keyDhOid), output + idx);\n    XMEMCPY(output + idx, keyDhOid, sizeof(keyDhOid));\n    idx += sizeof(keyDhOid);\n\n    /* DH Parameters sequence with P and G */\n    total = *outSz - idx;\n    ret = wc_DhParamsToDer(key, output + idx, &total);\n    if (ret < 0)\n        return ret;\n    idx += total;\n\n    /* octect string: priv */\n    if (exportPriv) {\n        idx += SetOctetString(privSz, output + idx);\n        idx += SetASNIntMP(&key->priv, -1, output + idx);        \n    }\n    else {\n        /* bit string: public */\n        idx += SetBitString(pubSz, 0, output + idx);\n        idx += SetASNIntMP(&key->pub, -1, output + idx);\n    }\n    *outSz = idx;\n\n    return idx;    \n}\n\nint wc_DhPubKeyToDer(DhKey* key, byte* out, word32* outSz)\n{\n    return wc_DhKeyToDer(key, out, outSz, 0);\n}\nint wc_DhPrivKeyToDer(DhKey* key, byte* out, word32* outSz)\n{\n    return wc_DhKeyToDer(key, out, outSz, 1);\n}\n\n\n/* Convert DH key parameters to DER format, write to output (outSz)\n * If output is NULL then max expected size is set to outSz and LENGTH_ONLY_E is\n * returned.\n *\n * Note : static function due to redefinition complications with DhKey and FIPS\n * version 2 build.\n *\n * return bytes written on success */\nint wc_DhParamsToDer(DhKey* key, byte* output, word32* outSz)\n{\n    word32 idx, total;\n\n    if (key == NULL || outSz == NULL) {\n        return BAD_FUNC_ARG;\n    }\n\n    /* determine size */\n    /* integer - g */\n    idx = SetASNIntMP(&key->g, -1, NULL);\n    /* integer - p */\n    idx += SetASNIntMP(&key->p, -1, NULL);\n    total = idx;\n     /* sequence */\n    idx += SetSequence(idx, NULL);\n\n    if (output == NULL) {\n        *outSz = idx;\n        return LENGTH_ONLY_E;\n    }\n    /* make sure output fits in buffer */\n    if (idx > *outSz) {\n        return BUFFER_E;\n    }\n\n\n    /* write DH parameters */\n    /* sequence - for P and G only */\n    idx = SetSequence(total, output);\n    /* integer - p */\n    idx += SetASNIntMP(&key->p, -1, output + idx);\n    /* integer - g */\n    idx += SetASNIntMP(&key->g, -1, output + idx);\n    *outSz = idx;\n\n    return idx;\n}\n\n#endif /* WOLFSSL_DH_EXTRA */\n\nint wc_DhParamsLoad(const byte* input, word32 inSz, byte* p, word32* pInOutSz,\n                 byte* g, word32* gInOutSz)\n{\n    word32 idx = 0;\n    int    ret;\n    int    length;\n\n    if (GetSequence(input, &idx, &length, inSz) <= 0)\n        return ASN_PARSE_E;\n\n    ret = GetASNInt(input, &idx, &length, inSz);\n    if (ret != 0)\n        return ret;\n\n    if (length <= (int)*pInOutSz) {\n        XMEMCPY(p, &input[idx], length);\n        *pInOutSz = length;\n    }\n    else {\n        return BUFFER_E;\n    }\n    idx += length;\n\n    ret = GetASNInt(input, &idx, &length, inSz);\n    if (ret != 0)\n        return ret;\n\n    if (length <= (int)*gInOutSz) {\n        XMEMCPY(g, &input[idx], length);\n        *gInOutSz = length;\n    }\n    else {\n        return BUFFER_E;\n    }\n\n    return 0;\n}\n#endif /* !NO_DH */\n\n\n#ifndef NO_DSA\n\nint DsaPublicKeyDecode(const byte* input, word32* inOutIdx, DsaKey* key,\n                        word32 inSz)\n{\n    int    length;\n    int    ret = 0;\n    word32 oid;\n    word32 maxIdx;\n\n    if (input == NULL || inOutIdx == NULL || key == NULL)\n        return BAD_FUNC_ARG;\n\n    if (GetSequence(input, inOutIdx, &length, inSz) < 0)\n        return ASN_PARSE_E;\n\n    maxIdx = (word32)(*inOutIdx + length);\n    if (GetInt(&key->p,  input, inOutIdx, maxIdx) < 0 ||\n        GetInt(&key->q,  input, inOutIdx, maxIdx) < 0 ||\n        GetInt(&key->g,  input, inOutIdx, maxIdx) < 0 ||\n        GetInt(&key->y,  input, inOutIdx, maxIdx) < 0 )\n        ret = ASN_DH_KEY_E;\n\n    if (ret != 0) {\n        if (GetSequence(input, inOutIdx, &length, inSz) < 0)\n            return ASN_PARSE_E;\n\n        ret = GetObjectId(input, inOutIdx, &oid, oidIgnoreType, inSz);\n        if (ret != 0)\n            return ret;\n\n        if (GetSequence(input, inOutIdx, &length, inSz) < 0)\n            return ASN_PARSE_E;\n\n        if (GetInt(&key->p,  input, inOutIdx, inSz) < 0 ||\n            GetInt(&key->q,  input, inOutIdx, inSz) < 0 ||\n            GetInt(&key->g,  input, inOutIdx, inSz) < 0)\n            return ASN_DH_KEY_E;\n\n        if (CheckBitString(input, inOutIdx, &length, inSz, 0, NULL) < 0)\n            return ASN_PARSE_E;\n\n        if (GetInt(&key->y,  input, inOutIdx, inSz) < 0 )\n            return ASN_DH_KEY_E;\n\n        ret = 0;\n    }\n\n    key->type = DSA_PUBLIC;\n    return ret;\n}\n\nint wc_DsaParamsDecode(const byte* input, word32* inOutIdx, DsaKey* key,\n                        word32 inSz)\n{\n    int    length;\n    word32 maxIdx;\n\n    if (input == NULL || inOutIdx == NULL || key == NULL)\n        return BAD_FUNC_ARG;\n\n    if (GetSequence(input, inOutIdx, &length, inSz) < 0)\n        return ASN_PARSE_E;\n\n    maxIdx = (word32)(*inOutIdx + length);\n    if (GetInt(&key->p, input, inOutIdx, maxIdx) < 0 ||\n        GetInt(&key->q, input, inOutIdx, maxIdx) < 0 ||\n        GetInt(&key->g, input, inOutIdx, maxIdx) < 0)\n        return ASN_DH_KEY_E;\n\n    return 0;\n}\n\n\nint DsaPrivateKeyDecode(const byte* input, word32* inOutIdx, DsaKey* key,\n                        word32 inSz)\n{\n    int    length, version, ret = 0, temp = 0;\n\n    /* Sanity checks on input */\n    if (input == NULL || inOutIdx == NULL || key == NULL) {\n        return BAD_FUNC_ARG;\n    }\n\n    if (GetSequence(input, inOutIdx, &length, inSz) < 0)\n        return ASN_PARSE_E;\n\n    temp = (int)*inOutIdx;\n\n    /* Default case expects a certificate with OctetString but no version ID */\n    ret = GetInt(&key->p, input, inOutIdx, inSz);\n    if (ret < 0) {\n        mp_clear(&key->p);\n        ret = ASN_PARSE_E;\n    }\n    else {\n        ret = GetInt(&key->q, input, inOutIdx, inSz);\n        if (ret < 0) {\n            mp_clear(&key->p);\n            mp_clear(&key->q);\n            ret = ASN_PARSE_E;\n        }\n        else {\n            ret = GetInt(&key->g, input, inOutIdx, inSz);\n            if (ret < 0) {\n                mp_clear(&key->p);\n                mp_clear(&key->q);\n                mp_clear(&key->g);\n                ret = ASN_PARSE_E;\n            }\n            else {\n                ret = GetOctetString(input, inOutIdx, &length, inSz);\n                if (ret < 0) {\n                    mp_clear(&key->p);\n                    mp_clear(&key->q);\n                    mp_clear(&key->g);\n                    ret = ASN_PARSE_E;\n                }\n                else {\n                    ret = GetInt(&key->y, input, inOutIdx, inSz);\n                    if (ret < 0) {\n                        mp_clear(&key->p);\n                        mp_clear(&key->q);\n                        mp_clear(&key->g);\n                        mp_clear(&key->y);\n                        ret = ASN_PARSE_E;\n                    }\n                }\n            }\n        }\n    }\n    /* An alternate pass if default certificate fails parsing */\n    if (ret == ASN_PARSE_E) {\n        *inOutIdx = temp;\n        if (GetMyVersion(input, inOutIdx, &version, inSz) < 0)\n            return ASN_PARSE_E;\n\n        if (GetInt(&key->p,  input, inOutIdx, inSz) < 0 ||\n            GetInt(&key->q,  input, inOutIdx, inSz) < 0 ||\n            GetInt(&key->g,  input, inOutIdx, inSz) < 0 ||\n            GetInt(&key->y,  input, inOutIdx, inSz) < 0 ||\n            GetInt(&key->x,  input, inOutIdx, inSz) < 0 )\n            return ASN_DH_KEY_E;\n    }\n\n    key->type = DSA_PRIVATE;\n    return 0;\n}\n\nstatic mp_int* GetDsaInt(DsaKey* key, int idx)\n{\n    /* Other functions depend on this order. Please don't change it. */\n    if (idx == 0)\n        return &key->p;\n    if (idx == 1)\n        return &key->q;\n    if (idx == 2)\n        return &key->g;\n    if (idx == 3)\n        return &key->y;\n    if (idx == 4)\n        return &key->x;\n\n    return NULL;\n}\n\n/* Release Tmp DSA resources */\nstatic WC_INLINE void FreeTmpDsas(byte** tmps, void* heap, int ints)\n{\n    int i;\n\n    for (i = 0; i < ints; i++)\n        XFREE(tmps[i], heap, DYNAMIC_TYPE_DSA);\n\n    (void)heap;\n}\n\n#if !defined(HAVE_SELFTEST) && (defined(WOLFSSL_KEY_GEN) || \\\n        defined(WOLFSSL_CERT_GEN))\n/* Write a public DSA key to output */\nint wc_SetDsaPublicKey(byte* output, DsaKey* key,\n                           int outLen, int with_header)\n{\n    /* p, g, q = DSA params, y = public exponent */\n#ifdef WOLFSSL_SMALL_STACK\n    byte* p = NULL;\n    byte* g = NULL;\n    byte* q = NULL;\n    byte* y = NULL;\n#else\n    byte p[MAX_DSA_INT_SZ];\n    byte g[MAX_DSA_INT_SZ];\n    byte q[MAX_DSA_INT_SZ];\n    byte y[MAX_DSA_INT_SZ];\n#endif\n    byte innerSeq[MAX_SEQ_SZ];\n    byte outerSeq[MAX_SEQ_SZ];\n    byte bitString[1 + MAX_LENGTH_SZ + 1];\n    int  idx, pSz, gSz, qSz, ySz, innerSeqSz, outerSeqSz, bitStringSz = 0;\n\n    WOLFSSL_ENTER(\"wc_SetDsaPublicKey\");\n\n    if (output == NULL || key == NULL || outLen < MAX_SEQ_SZ) {\n        return BAD_FUNC_ARG;\n    }\n\n    /* p */\n#ifdef WOLFSSL_SMALL_STACK\n    p = (byte*)XMALLOC(MAX_DSA_INT_SZ, key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n    if (p == NULL)\n        return MEMORY_E;\n#endif\n    if ((pSz = SetASNIntMP(&key->p, MAX_DSA_INT_SZ, p)) < 0) {\n        WOLFSSL_MSG(\"SetASNIntMP Error with p\");\n#ifdef WOLFSSL_SMALL_STACK\n        XFREE(p, key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n#endif\n        return pSz;\n    }\n\n    /* q */\n#ifdef WOLFSSL_SMALL_STACK\n    q = (byte*)XMALLOC(MAX_DSA_INT_SZ, key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n    if (q == NULL)\n        return MEMORY_E;\n#endif\n    if ((qSz = SetASNIntMP(&key->q, MAX_DSA_INT_SZ, q)) < 0) {\n        WOLFSSL_MSG(\"SetASNIntMP Error with q\");\n#ifdef WOLFSSL_SMALL_STACK\n        XFREE(p, key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n        XFREE(q, key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n#endif\n        return qSz;\n    }\n\n    /* g */\n#ifdef WOLFSSL_SMALL_STACK\n    g = (byte*)XMALLOC(MAX_DSA_INT_SZ, key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n    if (g == NULL)\n        return MEMORY_E;\n#endif\n    if ((gSz = SetASNIntMP(&key->g, MAX_DSA_INT_SZ, g)) < 0) {\n        WOLFSSL_MSG(\"SetASNIntMP Error with g\");\n#ifdef WOLFSSL_SMALL_STACK\n        XFREE(p, key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n        XFREE(q, key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n        XFREE(g, key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n#endif\n        return gSz;\n    }\n\n    /* y */\n#ifdef WOLFSSL_SMALL_STACK\n    y = (byte*)XMALLOC(MAX_DSA_INT_SZ, key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n    if (y == NULL)\n        return MEMORY_E;\n#endif\n    if ((ySz = SetASNIntMP(&key->y, MAX_DSA_INT_SZ, y)) < 0) {\n        WOLFSSL_MSG(\"SetASNIntMP Error with y\");\n#ifdef WOLFSSL_SMALL_STACK\n        XFREE(p, key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n        XFREE(q, key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n        XFREE(g, key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n        XFREE(y, key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n#endif\n        return ySz;\n    }\n\n    innerSeqSz  = SetSequence(pSz + qSz + gSz, innerSeq);\n\n    /* check output size */\n    if ((innerSeqSz + pSz + qSz + gSz) > outLen) {\n#ifdef WOLFSSL_SMALL_STACK\n        XFREE(p,    key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n        XFREE(q,    key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n        XFREE(g,    key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n        XFREE(y,    key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n#endif\n        WOLFSSL_MSG(\"Error, output size smaller than outlen\");\n        return BUFFER_E;\n    }\n\n    if (with_header) {\n        int algoSz;\n#ifdef WOLFSSL_SMALL_STACK\n        byte* algo = NULL;\n\n        algo = (byte*)XMALLOC(MAX_ALGO_SZ, key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n        if (algo == NULL) {\n            XFREE(p,    key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n            XFREE(q,    key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n            XFREE(g,    key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n            XFREE(y,    key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n            return MEMORY_E;\n        }\n#else\n        byte algo[MAX_ALGO_SZ];\n#endif\n        algoSz = SetAlgoID(DSAk, algo, oidKeyType, 0);\n        bitStringSz  = SetBitString(ySz, 0, bitString);\n        outerSeqSz = SetSequence(algoSz + innerSeqSz + pSz + qSz + gSz,\n                                                                      outerSeq);\n\n        idx = SetSequence(algoSz + innerSeqSz + pSz + qSz + gSz + bitStringSz +\n                                                      ySz + outerSeqSz, output);\n\n        /* check output size */\n        if ((idx + algoSz + bitStringSz + innerSeqSz + pSz + qSz + gSz + ySz) >\n                                                                       outLen) {\n            #ifdef WOLFSSL_SMALL_STACK\n                XFREE(p,    key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n                XFREE(q,    key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n                XFREE(g,    key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n                XFREE(y,    key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n                XFREE(algo, key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n            #endif\n            WOLFSSL_MSG(\"Error, output size smaller than outlen\");\n            return BUFFER_E;\n        }\n\n        /* outerSeq */\n        XMEMCPY(output + idx, outerSeq, outerSeqSz);\n        idx += outerSeqSz;\n        /* algo */\n        XMEMCPY(output + idx, algo, algoSz);\n        idx += algoSz;\n#ifdef WOLFSSL_SMALL_STACK\n        XFREE(algo, key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n#endif\n    } else {\n        idx = 0;\n    }\n\n    /* innerSeq */\n    XMEMCPY(output + idx, innerSeq, innerSeqSz);\n    idx += innerSeqSz;\n    /* p */\n    XMEMCPY(output + idx, p, pSz);\n    idx += pSz;\n    /* q */\n    XMEMCPY(output + idx, q, qSz);\n    idx += qSz;\n    /* g */\n    XMEMCPY(output + idx, g, gSz);\n    idx += gSz;\n    /* bit string */\n    if (bitStringSz > 0) {\n        XMEMCPY(output + idx, bitString, bitStringSz);\n        idx += bitStringSz;\n    }\n    /* y */\n    XMEMCPY(output + idx, y, ySz);\n    idx += ySz;\n\n#ifdef WOLFSSL_SMALL_STACK\n    XFREE(p,    key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n    XFREE(q,    key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n    XFREE(g,    key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n    XFREE(y,    key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n#endif\n    return idx;\n}\n\n/* Convert DSA Public key to DER format, write to output (inLen), return bytes\n   written */\nint wc_DsaKeyToPublicDer(DsaKey* key, byte* output, word32 inLen)\n{\n    return wc_SetDsaPublicKey(output, key, inLen, 1);\n}\n#endif /* !HAVE_SELFTEST && (WOLFSSL_KEY_GEN || WOLFSSL_CERT_GEN) */\n\nstatic int DsaKeyIntsToDer(DsaKey* key, byte* output, word32 inLen,\n                           int ints, int includeVersion)\n{\n    word32 seqSz = 0, verSz = 0, rawLen, intTotalLen = 0;\n    word32 sizes[DSA_INTS];\n    int    i, j, outLen, ret = 0, mpSz;\n\n    byte  seq[MAX_SEQ_SZ];\n    byte  ver[MAX_VERSION_SZ];\n    byte* tmps[DSA_INTS];\n\n    if (ints > DSA_INTS)\n        return BAD_FUNC_ARG;\n\n    XMEMSET(sizes, 0, sizeof(sizes));\n    for (i = 0; i < ints; i++)\n        tmps[i] = NULL;\n\n    /* write all big ints from key to DER tmps */\n    for (i = 0; i < ints; i++) {\n        mp_int* keyInt = GetDsaInt(key, i);\n\n        rawLen = mp_unsigned_bin_size(keyInt) + 1;\n        tmps[i] = (byte*)XMALLOC(rawLen + MAX_SEQ_SZ, key->heap,\n                                                              DYNAMIC_TYPE_DSA);\n        if (tmps[i] == NULL) {\n            ret = MEMORY_E;\n            break;\n        }\n\n        mpSz = SetASNIntMP(keyInt, -1, tmps[i]);\n        if (mpSz < 0) {\n            ret = mpSz;\n            break;\n        }\n        intTotalLen += (sizes[i] = mpSz);\n    }\n\n    if (ret != 0) {\n        FreeTmpDsas(tmps, key->heap, ints);\n        return ret;\n    }\n\n    /* make headers */\n    if (includeVersion)\n        verSz = SetMyVersion(0, ver, FALSE);\n    seqSz = SetSequence(verSz + intTotalLen, seq);\n\n    outLen = seqSz + verSz + intTotalLen;\n    if (outLen > (int)inLen) {\n        FreeTmpDsas(tmps, key->heap, ints);\n        return BAD_FUNC_ARG;\n    }\n\n    /* write to output */\n    XMEMCPY(output, seq, seqSz);\n    j = seqSz;\n    if (includeVersion) {\n        XMEMCPY(output + j, ver, verSz);\n        j += verSz;\n    }\n\n    for (i = 0; i < ints; i++) {\n        XMEMCPY(output + j, tmps[i], sizes[i]);\n        j += sizes[i];\n    }\n    FreeTmpDsas(tmps, key->heap, ints);\n\n    return outLen;\n}\n\n/* Convert private DsaKey key to DER format, write to output (inLen),\n   return bytes written */\nint wc_DsaKeyToDer(DsaKey* key, byte* output, word32 inLen)\n{\n    if (!key || !output)\n        return BAD_FUNC_ARG;\n\n    if (key->type != DSA_PRIVATE)\n        return BAD_FUNC_ARG;\n\n    return DsaKeyIntsToDer(key, output, inLen, DSA_INTS, 1);\n}\n\n/* Convert DsaKey parameters to DER format, write to output (inLen),\n   return bytes written. Version is excluded to be compatible with\n   OpenSSL d2i_DSAparams */\nint wc_DsaKeyToParamsDer(DsaKey* key, byte* output, word32 inLen)\n{\n    if (!key || !output)\n        return BAD_FUNC_ARG;\n\n    return DsaKeyIntsToDer(key, output, inLen, DSA_PARAM_INTS, 0);\n}\n\n#endif /* NO_DSA */\n\nvoid InitDecodedCert(DecodedCert* cert,\n                     const byte* source, word32 inSz, void* heap)\n{\n    if (cert != NULL) {\n        XMEMSET(cert, 0, sizeof(DecodedCert));\n\n        cert->subjectCNEnc    = CTC_UTF8;\n        cert->issuer[0]       = '\\0';\n        cert->subject[0]      = '\\0';\n        cert->source          = source;  /* don't own */\n        cert->maxIdx          = inSz;    /* can't go over this index */\n        cert->heap            = heap;\n        cert->maxPathLen      = WOLFSSL_MAX_PATH_LEN;\n    #ifdef WOLFSSL_CERT_GEN\n        cert->subjectSNEnc    = CTC_UTF8;\n        cert->subjectCEnc     = CTC_PRINTABLE;\n        cert->subjectLEnc     = CTC_UTF8;\n        cert->subjectSTEnc    = CTC_UTF8;\n        cert->subjectOEnc     = CTC_UTF8;\n        cert->subjectOUEnc    = CTC_UTF8;\n    #endif /* WOLFSSL_CERT_GEN */\n\n    #ifndef NO_CERTS\n        InitSignatureCtx(&cert->sigCtx, heap, INVALID_DEVID);\n    #endif\n    }\n}\n\n\nvoid FreeAltNames(DNS_entry* altNames, void* heap)\n{\n    (void)heap;\n\n    while (altNames) {\n        DNS_entry* tmp = altNames->next;\n\n        XFREE(altNames->name, heap, DYNAMIC_TYPE_ALTNAME);\n        XFREE(altNames,       heap, DYNAMIC_TYPE_ALTNAME);\n        altNames = tmp;\n    }\n}\n\n#ifndef IGNORE_NAME_CONSTRAINTS\n\nvoid FreeNameSubtrees(Base_entry* names, void* heap)\n{\n    (void)heap;\n\n    while (names) {\n        Base_entry* tmp = names->next;\n\n        XFREE(names->name, heap, DYNAMIC_TYPE_ALTNAME);\n        XFREE(names,       heap, DYNAMIC_TYPE_ALTNAME);\n        names = tmp;\n    }\n}\n\n#endif /* IGNORE_NAME_CONSTRAINTS */\n\nvoid FreeDecodedCert(DecodedCert* cert)\n{\n    if (cert == NULL)\n        return;\n    if (cert->subjectCNStored == 1)\n        XFREE(cert->subjectCN, cert->heap, DYNAMIC_TYPE_SUBJECT_CN);\n    if (cert->pubKeyStored == 1)\n        XFREE((void*)cert->publicKey, cert->heap, DYNAMIC_TYPE_PUBLIC_KEY);\n    if (cert->weOwnAltNames && cert->altNames)\n        FreeAltNames(cert->altNames, cert->heap);\n#ifndef IGNORE_NAME_CONSTRAINTS\n    if (cert->altEmailNames)\n        FreeAltNames(cert->altEmailNames, cert->heap);\n    if (cert->altDirNames)\n        FreeAltNames(cert->altDirNames, cert->heap);\n    if (cert->permittedNames)\n        FreeNameSubtrees(cert->permittedNames, cert->heap);\n    if (cert->excludedNames)\n        FreeNameSubtrees(cert->excludedNames, cert->heap);\n#endif /* IGNORE_NAME_CONSTRAINTS */\n#ifdef WOLFSSL_SEP\n    XFREE(cert->deviceType, cert->heap, DYNAMIC_TYPE_X509_EXT);\n    XFREE(cert->hwType, cert->heap, DYNAMIC_TYPE_X509_EXT);\n    XFREE(cert->hwSerialNum, cert->heap, DYNAMIC_TYPE_X509_EXT);\n#endif /* WOLFSSL_SEP */\n#if (defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)) && \\\n    !defined(WOLFCRYPT_ONLY)\n    if (cert->issuerName != NULL)\n        wolfSSL_X509_NAME_free((WOLFSSL_X509_NAME*)cert->issuerName);\n    if (cert->subjectName != NULL)\n        wolfSSL_X509_NAME_free((WOLFSSL_X509_NAME*)cert->subjectName);\n#endif /* OPENSSL_EXTRA */\n#ifdef WOLFSSL_RENESAS_TSIP_TLS\n    if (cert->tsip_encRsaKeyIdx != NULL)\n        XFREE(cert->tsip_encRsaKeyIdx, cert->heap, DYNAMIC_TYPE_RSA);\n#endif\n#ifndef NO_CERTS\n    FreeSignatureCtx(&cert->sigCtx);\n#endif\n}\n\nstatic int GetCertHeader(DecodedCert* cert)\n{\n    int ret = 0, len;\n\n    if (GetSequence(cert->source, &cert->srcIdx, &len, cert->maxIdx) < 0)\n        return ASN_PARSE_E;\n\n    /* Reset the max index for the size indicated in the outer wrapper. */\n    cert->maxIdx = len + cert->srcIdx;\n    cert->certBegin = cert->srcIdx;\n\n    if (GetSequence(cert->source, &cert->srcIdx, &len, cert->maxIdx) < 0)\n        return ASN_PARSE_E;\n\n    cert->sigIndex = len + cert->srcIdx;\n    if (cert->sigIndex > cert->maxIdx)\n        return ASN_PARSE_E;\n\n    if (GetExplicitVersion(cert->source, &cert->srcIdx, &cert->version,\n                                                            cert->sigIndex) < 0)\n        return ASN_PARSE_E;\n\n    if (GetSerialNumber(cert->source, &cert->srcIdx, cert->serial,\n                                           &cert->serialSz, cert->sigIndex) < 0)\n        return ASN_PARSE_E;\n\n    return ret;\n}\n\n#if !defined(NO_RSA)\n/* Store Rsa Key, may save later, Dsa could use in future */\nstatic int StoreRsaKey(DecodedCert* cert, word32 bitStringEnd)\n{\n    int    length;\n    word32 recvd = cert->srcIdx;\n\n    if (GetSequence(cert->source, &cert->srcIdx, &length, bitStringEnd) < 0)\n        return ASN_PARSE_E;\n\n    recvd = cert->srcIdx - recvd;\n    length += recvd;\n\n    while (recvd--)\n       cert->srcIdx--;\n#if defined(WOLFSSL_RENESAS_TSIP)\n    cert->sigCtx.pubkey_n_start = cert->sigCtx.pubkey_e_start = cert->srcIdx;\n#endif\n    cert->pubKeySize = length;\n    cert->publicKey = cert->source + cert->srcIdx;\n    cert->srcIdx += length;\n\n    return 0;\n}\n#endif /* !NO_RSA */\n\n#ifdef HAVE_ECC\n\n    /* return 0 on success if the ECC curve oid sum is supported */\n    static int CheckCurve(word32 oid)\n    {\n        int ret = 0;\n        word32 oidSz = 0;\n\n        ret = wc_ecc_get_oid(oid, NULL, &oidSz);\n        if (ret < 0 || oidSz == 0) {\n            WOLFSSL_MSG(\"CheckCurve not found\");\n            ret = ALGO_ID_E;\n        }\n\n        return ret;\n    }\n\n#endif /* HAVE_ECC */\n\nstatic int GetKey(DecodedCert* cert)\n{\n    int length;\n#ifndef NO_DSA\n    int tmpLen;\n#endif\n#if defined(HAVE_ECC) || defined(HAVE_NTRU) || !defined(NO_DSA)\n    int tmpIdx = cert->srcIdx;\n#endif\n\n    if (GetSequence(cert->source, &cert->srcIdx, &length, cert->maxIdx) < 0)\n        return ASN_PARSE_E;\n\n#ifndef NO_DSA\n    tmpLen = length + 4;\n#endif\n\n    if (GetAlgoId(cert->source, &cert->srcIdx,\n                  &cert->keyOID, oidKeyType, cert->maxIdx) < 0)\n        return ASN_PARSE_E;\n\n    switch (cert->keyOID) {\n   #ifndef NO_RSA\n        case RSAk:\n        {\n            int ret;\n\n            ret = CheckBitString(cert->source, &cert->srcIdx, &length,\n                                 cert->maxIdx, 1, NULL);\n            if (ret != 0)\n                return ret;\n\n            #ifdef HAVE_OCSP\n                ret = CalcHashId(cert->source + cert->srcIdx, length,\n                        cert->subjectKeyHash);\n                if (ret != 0)\n                    return ret;\n            #endif\n\n            return StoreRsaKey(cert, cert->srcIdx + length);\n        }\n\n    #endif /* NO_RSA */\n    #ifdef HAVE_NTRU\n        case NTRUk:\n        {\n            const byte* key = &cert->source[tmpIdx];\n            byte*       next = (byte*)key;\n            word16      keyLen;\n            word32      rc;\n            word32      remaining = cert->maxIdx - cert->srcIdx;\n            byte*       publicKey;\n#ifdef WOLFSSL_SMALL_STACK\n            byte*       keyBlob = NULL;\n#else\n            byte        keyBlob[MAX_NTRU_KEY_SZ];\n#endif\n            rc = ntru_crypto_ntru_encrypt_subjectPublicKeyInfo2PublicKey(key,\n                                &keyLen, NULL, &next, &remaining);\n            if (rc != NTRU_OK)\n                return ASN_NTRU_KEY_E;\n            if (keyLen > MAX_NTRU_KEY_SZ)\n                return ASN_NTRU_KEY_E;\n\n#ifdef WOLFSSL_SMALL_STACK\n            keyBlob = (byte*)XMALLOC(MAX_NTRU_KEY_SZ, cert->heap,\n                                     DYNAMIC_TYPE_TMP_BUFFER);\n            if (keyBlob == NULL)\n                return MEMORY_E;\n#endif\n\n            rc = ntru_crypto_ntru_encrypt_subjectPublicKeyInfo2PublicKey(key,\n                                &keyLen, keyBlob, &next, &remaining);\n            if (rc != NTRU_OK) {\n#ifdef WOLFSSL_SMALL_STACK\n                XFREE(keyBlob, cert->heap, DYNAMIC_TYPE_TMP_BUFFER);\n#endif\n                return ASN_NTRU_KEY_E;\n            }\n\n            if ( (next - key) < 0) {\n#ifdef WOLFSSL_SMALL_STACK\n                XFREE(keyBlob, cert->heap, DYNAMIC_TYPE_TMP_BUFFER);\n#endif\n                return ASN_NTRU_KEY_E;\n            }\n\n            cert->srcIdx = tmpIdx + (int)(next - key);\n\n            publicKey = (byte*)XMALLOC(keyLen, cert->heap,\n                                       DYNAMIC_TYPE_PUBLIC_KEY);\n            if (publicKey == NULL) {\n#ifdef WOLFSSL_SMALL_STACK\n                XFREE(keyBlob, cert->heap, DYNAMIC_TYPE_TMP_BUFFER);\n#endif\n                return MEMORY_E;\n            }\n            XMEMCPY(publicKey, keyBlob, keyLen);\n            cert->publicKey = publicKey;\n            cert->pubKeyStored = 1;\n            cert->pubKeySize   = keyLen;\n\n#ifdef WOLFSSL_SMALL_STACK\n            XFREE(keyBlob, cert->heap, DYNAMIC_TYPE_TMP_BUFFER);\n#endif\n\n            return 0;\n        }\n    #endif /* HAVE_NTRU */\n    #ifdef HAVE_ECC\n        case ECDSAk:\n        {\n            int ret;\n            byte seq[5];\n            int pubLen = length + 1 + SetLength(length, seq);\n            word32 localIdx;\n            byte* publicKey;\n            byte  tag;\n\n            localIdx = cert->srcIdx;\n            if (GetASNTag(cert->source, &localIdx, &tag, cert->maxIdx) < 0)\n                return ASN_PARSE_E;\n\n            if (tag != (ASN_SEQUENCE | ASN_CONSTRUCTED)) {\n                if (GetObjectId(cert->source, &cert->srcIdx,\n                            &cert->pkCurveOID, oidCurveType, cert->maxIdx) < 0)\n                    return ASN_PARSE_E;\n\n                if (CheckCurve(cert->pkCurveOID) < 0)\n                    return ECC_CURVE_OID_E;\n\n                /* key header */\n                ret = CheckBitString(cert->source, &cert->srcIdx, &length,\n                                                         cert->maxIdx, 1, NULL);\n                if (ret != 0)\n                    return ret;\n            #ifdef HAVE_OCSP\n                ret = CalcHashId(cert->source + cert->srcIdx, length,\n                        cert->subjectKeyHash);\n                if (ret != 0)\n                    return ret;\n            #endif\n            }\n\n            publicKey = (byte*)XMALLOC(pubLen, cert->heap,\n                                       DYNAMIC_TYPE_PUBLIC_KEY);\n            if (publicKey == NULL)\n                return MEMORY_E;\n            XMEMCPY(publicKey, &cert->source[tmpIdx], pubLen);\n            cert->publicKey = publicKey;\n            cert->pubKeyStored = 1;\n            cert->pubKeySize   = pubLen;\n\n            cert->srcIdx = tmpIdx + pubLen;\n\n            return 0;\n        }\n    #endif /* HAVE_ECC */\n    #ifdef HAVE_ED25519\n        case ED25519k:\n        {\n            byte* publicKey;\n            int ret;\n\n            cert->pkCurveOID = ED25519k;\n\n            ret = CheckBitString(cert->source, &cert->srcIdx, &length,\n                                 cert->maxIdx, 1, NULL);\n            if (ret != 0)\n                return ret;\n\n            #ifdef HAVE_OCSP\n                ret = CalcHashId(cert->source + cert->srcIdx, length,\n                        cert->subjectKeyHash);\n                if (ret != 0)\n                    return ret;\n            #endif\n\n            publicKey = (byte*) XMALLOC(length, cert->heap,\n                                        DYNAMIC_TYPE_PUBLIC_KEY);\n            if (publicKey == NULL)\n                return MEMORY_E;\n            XMEMCPY(publicKey, &cert->source[cert->srcIdx], length);\n            cert->publicKey = publicKey;\n            cert->pubKeyStored = 1;\n            cert->pubKeySize   = length;\n\n            cert->srcIdx += length;\n\n            return 0;\n        }\n    #endif /* HAVE_ED25519 */\n    #ifdef HAVE_ED448\n        case ED448k:\n        {\n            byte* publicKey;\n            int ret;\n\n            cert->pkCurveOID = ED448k;\n\n            ret = CheckBitString(cert->source, &cert->srcIdx, &length,\n                                 cert->maxIdx, 1, NULL);\n            if (ret != 0)\n                return ret;\n\n            #ifdef HAVE_OCSP\n                ret = CalcHashId(cert->source + cert->srcIdx, length,\n                                 cert->subjectKeyHash);\n                if (ret != 0)\n                    return ret;\n            #endif\n\n            publicKey = (byte*) XMALLOC(length, cert->heap,\n                                        DYNAMIC_TYPE_PUBLIC_KEY);\n            if (publicKey == NULL)\n                return MEMORY_E;\n            XMEMCPY(publicKey, &cert->source[cert->srcIdx], length);\n            cert->publicKey = publicKey;\n            cert->pubKeyStored = 1;\n            cert->pubKeySize   = length;\n\n            cert->srcIdx += length;\n\n            return 0;\n        }\n    #endif /* HAVE_ED448 */\n    #ifndef NO_DSA\n        case DSAk:\n        {\n            int ret;\n            ret = GetSequence(cert->source, &cert->srcIdx, &length,\n                           cert->maxIdx);\n            if (ret < 0)\n                return ret;\n\n            ret = SkipInt(cert->source, &cert->srcIdx, cert->maxIdx);\n            if (ret != 0)\n                return ret;\n            ret = SkipInt(cert->source, &cert->srcIdx, cert->maxIdx);\n            if (ret != 0)\n                return ret;\n            ret = SkipInt(cert->source, &cert->srcIdx, cert->maxIdx);\n            if (ret != 0)\n                return ret;\n\n            ret = CheckBitString(cert->source, &cert->srcIdx, &length,\n                                                         cert->maxIdx, 1, NULL);\n            if (ret != 0)\n                return ret;\n\n            ret = GetASNInt(cert->source, &cert->srcIdx, &length, cert->maxIdx);\n            if (ret !=0)\n                return ASN_PARSE_E;\n\n            cert->publicKey = cert->source + tmpIdx;\n            cert->pubKeySize = tmpLen;\n            cert->srcIdx += length;\n            return 0;\n        }\n    #endif /* NO_DSA */\n        default:\n            WOLFSSL_MSG(\"Unknown or not compiled in key OID\");\n            return ASN_UNKNOWN_OID_E;\n    }\n}\n\n#if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)\n#if defined(HAVE_ECC)\n/* Converts ECC curve enum values in ecc_curve_id to the associated OpenSSL NID\n    value */\nWOLFSSL_API int EccEnumToNID(int n)\n{\n    WOLFSSL_ENTER(\"EccEnumToNID()\");\n\n    switch(n) {\n        case ECC_SECP192R1:\n            return NID_X9_62_prime192v1;\n        case ECC_PRIME192V2:\n            return NID_X9_62_prime192v2;\n        case ECC_PRIME192V3:\n            return NID_X9_62_prime192v3;\n        case ECC_PRIME239V1:\n            return NID_X9_62_prime239v1;\n        case ECC_PRIME239V2:\n            return NID_X9_62_prime239v2;\n        case ECC_PRIME239V3:\n            return NID_X9_62_prime239v3;\n        case ECC_SECP256R1:\n            return NID_X9_62_prime256v1;\n        case ECC_SECP112R1:\n            return NID_secp112r1;\n        case ECC_SECP112R2:\n            return NID_secp112r2;\n        case ECC_SECP128R1:\n            return NID_secp128r1;\n        case ECC_SECP128R2:\n            return NID_secp128r2;\n        case ECC_SECP160R1:\n            return NID_secp160r1;\n        case ECC_SECP160R2:\n            return NID_secp160r2;\n        case ECC_SECP224R1:\n            return NID_secp224r1;\n        case ECC_SECP384R1:\n            return NID_secp384r1;\n        case ECC_SECP521R1:\n            return NID_secp521r1;\n        case ECC_SECP160K1:\n            return NID_secp160k1;\n        case ECC_SECP192K1:\n            return NID_secp192k1;\n        case ECC_SECP224K1:\n            return NID_secp224k1;\n        case ECC_SECP256K1:\n            return NID_secp256k1;\n        case ECC_BRAINPOOLP160R1:\n            return NID_brainpoolP160r1;\n        case ECC_BRAINPOOLP192R1:\n            return NID_brainpoolP192r1;\n        case ECC_BRAINPOOLP224R1:\n            return NID_brainpoolP224r1;\n        case ECC_BRAINPOOLP256R1:\n            return NID_brainpoolP256r1;\n        case ECC_BRAINPOOLP320R1:\n            return NID_brainpoolP320r1;\n        case ECC_BRAINPOOLP384R1:\n            return NID_brainpoolP384r1;\n        case ECC_BRAINPOOLP512R1:\n            return NID_brainpoolP512r1;\n        default:\n            WOLFSSL_MSG(\"NID not found\");\n            return -1;\n    }\n}\n#endif /* HAVE_ECC */\n#endif /* OPENSSL_EXTRA || OPENSSL_EXTRA_X509_SMALL */\n\n#if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)\nint wc_OBJ_sn2nid(const char *sn)\n{\n    const struct {\n        const char *sn;\n        int  nid;\n    } sn2nid[] = {\n        {WOLFSSL_COMMON_NAME, NID_commonName},\n        {WOLFSSL_COUNTRY_NAME, NID_countryName},\n        {WOLFSSL_LOCALITY_NAME, NID_localityName},\n        {WOLFSSL_STATE_NAME, NID_stateOrProvinceName},\n        {WOLFSSL_ORG_NAME, NID_organizationName},\n        {WOLFSSL_ORGUNIT_NAME, NID_organizationalUnitName},\n        {WOLFSSL_EMAIL_ADDR, NID_emailAddress},\n        {NULL, -1}};\n    int i;\n    #ifdef HAVE_ECC\n    char curveName[16]; /* Same as MAX_CURVE_NAME_SZ but can't include that\n                         * symbol in this file */\n    int eccEnum;\n    #endif\n    WOLFSSL_ENTER(\"OBJ_sn2nid\");\n    for(i=0; sn2nid[i].sn != NULL; i++) {\n        if(XSTRNCMP(sn, sn2nid[i].sn, XSTRLEN(sn2nid[i].sn)) == 0) {\n            return sn2nid[i].nid;\n        }\n    }\n    #ifdef HAVE_ECC\n    /* Nginx uses this OpenSSL string. */\n    if (XSTRNCMP(sn, \"prime256v1\", 10) == 0)\n        sn = \"SECP256R1\";\n    /* OpenSSL allows lowercase curve names */\n    for (i = 0; i < (int)(sizeof(curveName) - 1) && *sn; i++) {\n        curveName[i] = (char)XTOUPPER(*sn++);\n    }\n    curveName[i] = '\\0';\n    /* find based on name and return NID */\n    for (i = 0;\n#ifndef WOLFSSL_ECC_CURVE_STATIC\n         ecc_sets[i].size != 0 && ecc_sets[i].name != NULL;\n#else\n         ecc_sets[i].size != 0;\n#endif\n         i++) {\n        if (XSTRNCMP(curveName, ecc_sets[i].name, ECC_MAXNAME) == 0) {\n            eccEnum = ecc_sets[i].id;\n            /* Convert enum value in ecc_curve_id to OpenSSL NID */\n            return EccEnumToNID(eccEnum);\n        }\n    }\n    #endif\n\n    return NID_undef;\n}\n#endif\n\n/* Routine for calculating hashId */\nint CalcHashId(const byte* data, word32 len, byte* hash)\n{\n    int ret;\n\n#if defined(NO_SHA) && !defined(NO_SHA256)\n    ret = wc_Sha256Hash(data, len, hash);\n#elif !defined(NO_SHA)\n    ret = wc_ShaHash(data, len, hash);\n#else\n    ret = NOT_COMPILED_IN;\n    (void)data;\n    (void)len;\n    (void)hash;\n#endif\n\n    return ret;\n}\n\n/* process NAME, either issuer or subject\n * returns 0 on success and negative values on fail */\nint GetName(DecodedCert* cert, int nameType, int maxIdx)\n{\n    int    length;  /* length of all distinguished names */\n    int    dummy;\n    int    ret;\n    char*  full;\n    byte*  hash;\n    word32 idx, localIdx = 0;\n    byte   tag;\n#if (defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)) && \\\n            !defined(WOLFCRYPT_ONLY)\n    WOLFSSL_X509_NAME* dName;\n#endif /* OPENSSL_EXTRA */\n\n    WOLFSSL_MSG(\"Getting Cert Name\");\n\n    if (nameType == ISSUER) {\n        full = cert->issuer;\n        hash = cert->issuerHash;\n    }\n    else {\n        full = cert->subject;\n        hash = cert->subjectHash;\n    }\n\n    if (cert->srcIdx >= (word32)maxIdx) {\n        return BUFFER_E;\n    }\n\n    localIdx = cert->srcIdx;\n    if (GetASNTag(cert->source, &localIdx, &tag, maxIdx) < 0) {\n        return ASN_PARSE_E;\n    }\n\n    if (tag == ASN_OBJECT_ID) {\n        WOLFSSL_MSG(\"Trying optional prefix...\");\n\n        if (SkipObjectId(cert->source, &cert->srcIdx, maxIdx) < 0)\n            return ASN_PARSE_E;\n        WOLFSSL_MSG(\"Got optional prefix\");\n    }\n\n    /* For OCSP, RFC2560 section 4.1.1 states the issuer hash should be\n     * calculated over the entire DER encoding of the Name field, including\n     * the tag and length. */\n    idx = cert->srcIdx;\n    if (GetSequence(cert->source, &cert->srcIdx, &length, maxIdx) < 0)\n        return ASN_PARSE_E;\n\n    ret = CalcHashId(&cert->source[idx], length + cert->srcIdx - idx, hash);\n    if (ret != 0)\n        return ret;\n\n    length += cert->srcIdx;\n    idx = 0;\n\n#if defined(HAVE_PKCS7) || defined(WOLFSSL_CERT_EXT)\n    /* store pointer to raw issuer */\n    if (nameType == ISSUER) {\n        cert->issuerRaw = &cert->source[cert->srcIdx];\n        cert->issuerRawLen = length - cert->srcIdx;\n    }\n#endif\n#ifndef IGNORE_NAME_CONSTRAINTS\n    if (nameType == SUBJECT) {\n        cert->subjectRaw = &cert->source[cert->srcIdx];\n        cert->subjectRawLen = length - cert->srcIdx;\n    }\n#endif\n#if (defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)) && \\\n    !defined(WOLFCRYPT_ONLY)\n    dName = wolfSSL_X509_NAME_new();\n    if (dName == NULL) {\n        return MEMORY_E;\n    }\n#endif /* OPENSSL_EXTRA */\n\n    while (cert->srcIdx < (word32)length) {\n        byte        b       = 0;\n        byte        joint[3];\n        byte        tooBig  = FALSE;\n        int         oidSz;\n        const char* copy    = NULL;\n        int         copyLen = 0;\n        int         strLen  = 0;\n        byte        id      = 0;\n    #if (defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)) \\\n                && !defined(WOLFCRYPT_ONLY)\n         int        nid = NID_undef;\n         int        enc;\n    #endif /* OPENSSL_EXTRA */\n\n        if (GetSet(cert->source, &cert->srcIdx, &dummy, maxIdx) < 0) {\n            WOLFSSL_MSG(\"Cert name lacks set header, trying sequence\");\n        }\n\n        if (GetSequence(cert->source, &cert->srcIdx, &dummy, maxIdx) <= 0) {\n        #if (defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)) && \\\n            !defined(WOLFCRYPT_ONLY)\n            wolfSSL_X509_NAME_free(dName);\n        #endif /* OPENSSL_EXTRA */\n            return ASN_PARSE_E;\n        }\n\n        ret = GetASNObjectId(cert->source, &cert->srcIdx, &oidSz, maxIdx);\n        if (ret != 0) {\n        #if (defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)) && \\\n            !defined(WOLFCRYPT_ONLY)\n            wolfSSL_X509_NAME_free(dName);\n        #endif /* OPENSSL_EXTRA */\n            return ret;\n        }\n\n        /* make sure there is room for joint */\n        if ((cert->srcIdx + sizeof(joint)) > (word32)maxIdx) {\n        #if (defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)) && \\\n            !defined(WOLFCRYPT_ONLY)\n            wolfSSL_X509_NAME_free(dName);\n        #endif /* OPENSSL_EXTRA */\n            return ASN_PARSE_E;\n        }\n\n        XMEMCPY(joint, &cert->source[cert->srcIdx], sizeof(joint));\n\n        /* v1 name types */\n        if (joint[0] == 0x55 && joint[1] == 0x04) {\n            cert->srcIdx += 3;\n            id = joint[2];\n            if (GetHeader(cert->source, &b, &cert->srcIdx, &strLen,\n                          maxIdx, 1) < 0) {\n            #if (defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)) && \\\n            !defined(WOLFCRYPT_ONLY)\n                wolfSSL_X509_NAME_free(dName);\n            #endif /* OPENSSL_EXTRA */\n                return ASN_PARSE_E;\n            }\n\n            if (id == ASN_COMMON_NAME) {\n                if (nameType == SUBJECT) {\n                    cert->subjectCN = (char *)&cert->source[cert->srcIdx];\n                    cert->subjectCNLen = strLen;\n                    cert->subjectCNEnc = b;\n                }\n\n                copy = WOLFSSL_COMMON_NAME;\n                copyLen = sizeof(WOLFSSL_COMMON_NAME) - 1;\n            #if (defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)) \\\n                && !defined(WOLFCRYPT_ONLY)\n                nid = NID_commonName;\n            #endif /* OPENSSL_EXTRA */\n            }\n            else if (id == ASN_SUR_NAME) {\n                copy = WOLFSSL_SUR_NAME;\n                copyLen = sizeof(WOLFSSL_SUR_NAME) - 1;\n                #ifdef WOLFSSL_CERT_GEN\n                    if (nameType == SUBJECT) {\n                        cert->subjectSN = (char*)&cert->source[cert->srcIdx];\n                        cert->subjectSNLen = strLen;\n                        cert->subjectSNEnc = b;\n                    }\n                #endif /* WOLFSSL_CERT_GEN */\n                #if (defined(OPENSSL_EXTRA) || \\\n                        defined(OPENSSL_EXTRA_X509_SMALL)) \\\n                        && !defined(WOLFCRYPT_ONLY)\n                    nid = NID_surname;\n                #endif /* OPENSSL_EXTRA */\n            }\n            else if (id == ASN_COUNTRY_NAME) {\n                copy = WOLFSSL_COUNTRY_NAME;\n                copyLen = sizeof(WOLFSSL_COUNTRY_NAME) - 1;\n                #ifdef WOLFSSL_CERT_GEN\n                    if (nameType == SUBJECT) {\n                        cert->subjectC = (char*)&cert->source[cert->srcIdx];\n                        cert->subjectCLen = strLen;\n                        cert->subjectCEnc = b;\n                    }\n                #endif /* WOLFSSL_CERT_GEN */\n                #if (defined(OPENSSL_EXTRA) || \\\n                        defined(OPENSSL_EXTRA_X509_SMALL)) \\\n                        && !defined(WOLFCRYPT_ONLY)\n                    nid = NID_countryName;\n                #endif /* OPENSSL_EXTRA */\n            }\n            else if (id == ASN_LOCALITY_NAME) {\n                copy = WOLFSSL_LOCALITY_NAME;\n                copyLen = sizeof(WOLFSSL_LOCALITY_NAME) - 1;\n                #ifdef WOLFSSL_CERT_GEN\n                    if (nameType == SUBJECT) {\n                        cert->subjectL = (char*)&cert->source[cert->srcIdx];\n                        cert->subjectLLen = strLen;\n                        cert->subjectLEnc = b;\n                    }\n                #endif /* WOLFSSL_CERT_GEN */\n                #if (defined(OPENSSL_EXTRA) || \\\n                        defined(OPENSSL_EXTRA_X509_SMALL)) \\\n                        && !defined(WOLFCRYPT_ONLY)\n                    nid = NID_localityName;\n                #endif /* OPENSSL_EXTRA */\n            }\n            else if (id == ASN_STATE_NAME) {\n                copy = WOLFSSL_STATE_NAME;\n                copyLen = sizeof(WOLFSSL_STATE_NAME) - 1;\n                #ifdef WOLFSSL_CERT_GEN\n                    if (nameType == SUBJECT) {\n                        cert->subjectST = (char*)&cert->source[cert->srcIdx];\n                        cert->subjectSTLen = strLen;\n                        cert->subjectSTEnc = b;\n                    }\n                #endif /* WOLFSSL_CERT_GEN */\n                #if (defined(OPENSSL_EXTRA) || \\\n                        defined(OPENSSL_EXTRA_X509_SMALL)) \\\n                        && !defined(WOLFCRYPT_ONLY)\n                    nid = NID_stateOrProvinceName;\n                #endif /* OPENSSL_EXTRA */\n            }\n            else if (id == ASN_ORG_NAME) {\n                copy = WOLFSSL_ORG_NAME;\n                copyLen = sizeof(WOLFSSL_ORG_NAME) - 1;\n                #ifdef WOLFSSL_CERT_GEN\n                    if (nameType == SUBJECT) {\n                        cert->subjectO = (char*)&cert->source[cert->srcIdx];\n                        cert->subjectOLen = strLen;\n                        cert->subjectOEnc = b;\n                    }\n                #endif /* WOLFSSL_CERT_GEN */\n                #if (defined(OPENSSL_EXTRA) || \\\n                        defined(OPENSSL_EXTRA_X509_SMALL)) \\\n                        && !defined(WOLFCRYPT_ONLY)\n                    nid = NID_organizationName;\n                #endif /* OPENSSL_EXTRA */\n            }\n            else if (id == ASN_ORGUNIT_NAME) {\n                copy = WOLFSSL_ORGUNIT_NAME;\n                copyLen = sizeof(WOLFSSL_ORGUNIT_NAME) - 1;\n                #ifdef WOLFSSL_CERT_GEN\n                    if (nameType == SUBJECT) {\n                        cert->subjectOU = (char*)&cert->source[cert->srcIdx];\n                        cert->subjectOULen = strLen;\n                        cert->subjectOUEnc = b;\n                    }\n                #endif /* WOLFSSL_CERT_GEN */\n                #if (defined(OPENSSL_EXTRA) || \\\n                        defined(OPENSSL_EXTRA_X509_SMALL)) \\\n                        && !defined(WOLFCRYPT_ONLY)\n                    nid = NID_organizationalUnitName;\n                #endif /* OPENSSL_EXTRA */\n            }\n            else if (id == ASN_SERIAL_NUMBER) {\n                copy = WOLFSSL_SERIAL_NUMBER;\n                copyLen = sizeof(WOLFSSL_SERIAL_NUMBER) - 1;\n                #ifdef WOLFSSL_CERT_GEN\n                    if (nameType == SUBJECT) {\n                        cert->subjectSND = (char*)&cert->source[cert->srcIdx];\n                        cert->subjectSNDLen = strLen;\n                        cert->subjectSNDEnc = b;\n                    }\n                #endif /* WOLFSSL_CERT_GEN */\n                #if (defined(OPENSSL_EXTRA) || \\\n                        defined(OPENSSL_EXTRA_X509_SMALL)) \\\n                        && !defined(WOLFCRYPT_ONLY)\n                    nid = NID_serialNumber;\n                #endif /* OPENSSL_EXTRA */\n            }\n        #ifdef WOLFSSL_CERT_EXT\n            else if (id == ASN_BUS_CAT) {\n                copy = WOLFSSL_BUS_CAT;\n                copyLen = sizeof(WOLFSSL_BUS_CAT) - 1;\n            #ifdef WOLFSSL_CERT_GEN\n                if (nameType == SUBJECT) {\n                    cert->subjectBC = (char*)&cert->source[cert->srcIdx];\n                    cert->subjectBCLen = strLen;\n                    cert->subjectBCEnc = b;\n                }\n            #endif /* WOLFSSL_CERT_GEN */\n            #if (defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)) \\\n                        && !defined(WOLFCRYPT_ONLY)\n                nid = NID_businessCategory;\n            #endif /* OPENSSL_EXTRA */\n            }\n        #endif /* WOLFSSL_CERT_EXT */\n        }\n    #ifdef WOLFSSL_CERT_EXT\n        else if ((cert->srcIdx + ASN_JOI_PREFIX_SZ + 2 <= (word32)maxIdx) &&\n                 (0 == XMEMCMP(&cert->source[cert->srcIdx], ASN_JOI_PREFIX,\n                               ASN_JOI_PREFIX_SZ)) &&\n                 ((cert->source[cert->srcIdx+ASN_JOI_PREFIX_SZ] == ASN_JOI_C) ||\n                  (cert->source[cert->srcIdx+ASN_JOI_PREFIX_SZ] == ASN_JOI_ST)))\n        {\n            cert->srcIdx += ASN_JOI_PREFIX_SZ;\n            id = cert->source[cert->srcIdx++];\n            b = cert->source[cert->srcIdx++]; /* encoding */\n\n            if (GetLength(cert->source, &cert->srcIdx, &strLen,\n                          maxIdx) < 0) {\n            #if (defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)) && \\\n            !defined(WOLFCRYPT_ONLY)\n                wolfSSL_X509_NAME_free(dName);\n            #endif /* OPENSSL_EXTRA */\n                return ASN_PARSE_E;\n            }\n\n            /* Check for jurisdiction of incorporation country name */\n            if (id == ASN_JOI_C) {\n                copy = WOLFSSL_JOI_C;\n                copyLen = sizeof(WOLFSSL_JOI_C) - 1;\n                #ifdef WOLFSSL_CERT_GEN\n                    if (nameType == SUBJECT) {\n                        cert->subjectJC = (char*)&cert->source[cert->srcIdx];\n                        cert->subjectJCLen = strLen;\n                        cert->subjectJCEnc = b;\n                    }\n                #endif /* WOLFSSL_CERT_GEN */\n                #if (defined(OPENSSL_EXTRA) || \\\n                        defined(OPENSSL_EXTRA_X509_SMALL)) \\\n                        && !defined(WOLFCRYPT_ONLY)\n                    nid = NID_jurisdictionCountryName;\n                #endif /* OPENSSL_EXTRA */\n            }\n\n            /* Check for jurisdiction of incorporation state name */\n            else if (id == ASN_JOI_ST) {\n                copy = WOLFSSL_JOI_ST;\n                copyLen = sizeof(WOLFSSL_JOI_ST) - 1;\n                #ifdef WOLFSSL_CERT_GEN\n                    if (nameType == SUBJECT) {\n                        cert->subjectJS = (char*)&cert->source[cert->srcIdx];\n                        cert->subjectJSLen = strLen;\n                        cert->subjectJSEnc = b;\n                    }\n                #endif /* WOLFSSL_CERT_GEN */\n                #if (defined(OPENSSL_EXTRA) || \\\n                        defined(OPENSSL_EXTRA_X509_SMALL)) \\\n                        && !defined(WOLFCRYPT_ONLY)\n                    nid = NID_jurisdictionStateOrProvinceName;\n                #endif /* OPENSSL_EXTRA */\n            }\n\n            if ((strLen + copyLen) > (int)(ASN_NAME_MAX - idx)) {\n                WOLFSSL_MSG(\"ASN Name too big, skipping\");\n                tooBig = TRUE;\n            }\n        }\n    #endif /* WOLFSSL_CERT_EXT */\n        else {\n            /* skip */\n            byte email = FALSE;\n            byte pilot = FALSE;\n\n            if (joint[0] == 0x2a && joint[1] == 0x86) {  /* email id hdr */\n                id = ASN_EMAIL_NAME;\n                email = TRUE;\n            }\n\n            if (joint[0] == 0x9  && joint[1] == 0x92) { /* uid id hdr */\n                /* last value of OID is the type of pilot attribute */\n                id    = cert->source[cert->srcIdx + oidSz - 1];\n                pilot = TRUE;\n            }\n\n            cert->srcIdx += oidSz + 1;\n\n            if (GetLength(cert->source, &cert->srcIdx, &strLen, maxIdx) < 0) {\n            #if (defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)) && \\\n            !defined(WOLFCRYPT_ONLY)\n                wolfSSL_X509_NAME_free(dName);\n            #endif /* OPENSSL_EXTRA */\n                return ASN_PARSE_E;\n            }\n\n            if (strLen > (int)(ASN_NAME_MAX - idx)) {\n                WOLFSSL_MSG(\"ASN name too big, skipping\");\n                tooBig = TRUE;\n            }\n\n            if (email) {\n                copyLen = sizeof(WOLFSSL_EMAIL_ADDR) - 1;\n                if ((copyLen + strLen) > (int)(ASN_NAME_MAX - idx)) {\n                    WOLFSSL_MSG(\"ASN name too big, skipping\");\n                    tooBig = TRUE;\n                }\n                else {\n                    copy = WOLFSSL_EMAIL_ADDR;\n                }\n\n                #ifdef WOLFSSL_CERT_GEN\n                    if (nameType == SUBJECT) {\n                        cert->subjectEmail = (char*)&cert->source[cert->srcIdx];\n                        cert->subjectEmailLen = strLen;\n                    }\n                #endif /* WOLFSSL_CERT_GEN */\n                #if (defined(OPENSSL_EXTRA) || \\\n                        defined(OPENSSL_EXTRA_X509_SMALL)) \\\n                        && !defined(WOLFCRYPT_ONLY)\n                    nid = NID_emailAddress;\n                #endif /* OPENSSL_EXTRA */\n                #ifndef IGNORE_NAME_CONSTRAINTS\n                    {\n                        DNS_entry* emailName;\n\n                        emailName = (DNS_entry*)XMALLOC(sizeof(DNS_entry),\n                                              cert->heap, DYNAMIC_TYPE_ALTNAME);\n                        if (emailName == NULL) {\n                            WOLFSSL_MSG(\"\\tOut of Memory\");\n                        #if (defined(OPENSSL_EXTRA) || \\\n                                defined(OPENSSL_EXTRA_X509_SMALL)) && \\\n                                !defined(WOLFCRYPT_ONLY)\n                            wolfSSL_X509_NAME_free(dName);\n                        #endif /* OPENSSL_EXTRA */\n                            return MEMORY_E;\n                        }\n                        emailName->type = 0;\n                        emailName->name = (char*)XMALLOC(strLen + 1,\n                                              cert->heap, DYNAMIC_TYPE_ALTNAME);\n                        if (emailName->name == NULL) {\n                            WOLFSSL_MSG(\"\\tOut of Memory\");\n                            XFREE(emailName, cert->heap, DYNAMIC_TYPE_ALTNAME);\n                        #if (defined(OPENSSL_EXTRA) || \\\n                                defined(OPENSSL_EXTRA_X509_SMALL)) && \\\n                                !defined(WOLFCRYPT_ONLY)\n                            wolfSSL_X509_NAME_free(dName);\n                        #endif /* OPENSSL_EXTRA */\n                            return MEMORY_E;\n                        }\n                        emailName->len = strLen;\n                        XMEMCPY(emailName->name, &cert->source[cert->srcIdx],\n                                                                        strLen);\n                        emailName->name[strLen] = '\\0';\n\n                        emailName->next = cert->altEmailNames;\n                        cert->altEmailNames = emailName;\n                    }\n                #endif /* IGNORE_NAME_CONSTRAINTS */\n            }\n\n            if (pilot) {\n                switch (id) {\n                    case ASN_USER_ID:\n                        copy = WOLFSSL_USER_ID;\n                        copyLen = sizeof(WOLFSSL_USER_ID) - 1;\n                    #if (defined(OPENSSL_EXTRA) || \\\n                        defined(OPENSSL_EXTRA_X509_SMALL)) \\\n                        && !defined(WOLFCRYPT_ONLY)\n                        nid = NID_userId;\n                    #endif /* OPENSSL_EXTRA */\n                        break;\n\n                    case ASN_DOMAIN_COMPONENT:\n                        copy = WOLFSSL_DOMAIN_COMPONENT;\n                        copyLen = sizeof(WOLFSSL_DOMAIN_COMPONENT) - 1;\n                    #if (defined(OPENSSL_EXTRA) || \\\n                        defined(OPENSSL_EXTRA_X509_SMALL)) \\\n                        && !defined(WOLFCRYPT_ONLY)\n                        nid = NID_domainComponent;\n                    #endif /* OPENSSL_EXTRA */\n                        break;\n                    case ASN_FAVOURITE_DRINK:\n                        copy = WOLFSSL_FAVOURITE_DRINK;\n                        copyLen = sizeof(WOLFSSL_FAVOURITE_DRINK) - 1;\n                    #if (defined(OPENSSL_EXTRA) || \\\n                        defined(OPENSSL_EXTRA_X509_SMALL)) \\\n                        && !defined(WOLFCRYPT_ONLY)\n                        nid = NID_favouriteDrink;\n                    #endif /* OPENSSL_EXTRA */\n                        break;\n\n                    default:\n                        WOLFSSL_MSG(\"Unknown pilot attribute type\");\n                    #if (defined(OPENSSL_EXTRA) || \\\n                                defined(OPENSSL_EXTRA_X509_SMALL)) && \\\n                                !defined(WOLFCRYPT_ONLY)\n                        wolfSSL_X509_NAME_free(dName);\n                    #endif /* OPENSSL_EXTRA */\n                        return ASN_PARSE_E;\n                }\n            }\n        }\n        if ((copyLen + strLen) > (int)(ASN_NAME_MAX - idx))\n        {\n            WOLFSSL_MSG(\"ASN Name too big, skipping\");\n            tooBig = TRUE;\n        }\n        if ((copy != NULL) && !tooBig) {\n            XMEMCPY(&full[idx], copy, copyLen);\n            idx += copyLen;\n            XMEMCPY(&full[idx], &cert->source[cert->srcIdx], strLen);\n            idx += strLen;\n        }\n        #if (defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)) && \\\n            !defined(WOLFCRYPT_ONLY)\n        switch (b) {\n            case CTC_UTF8:\n                enc = MBSTRING_UTF8;\n                break;\n            case CTC_PRINTABLE:\n                enc = V_ASN1_PRINTABLESTRING;\n                break;\n            default:\n                WOLFSSL_MSG(\"Unknown encoding type, using UTF8 by default\");\n                enc = MBSTRING_UTF8;\n        }\n\n        if (nid != NID_undef) {\n            if (wolfSSL_X509_NAME_add_entry_by_NID(dName, nid, enc,\n                            &cert->source[cert->srcIdx], strLen, -1, -1) !=\n                            WOLFSSL_SUCCESS) {\n                wolfSSL_X509_NAME_free(dName);\n                return ASN_PARSE_E;\n            }\n        }\n        #endif /* OPENSSL_EXTRA */\n        cert->srcIdx += strLen;\n    }\n    full[idx++] = 0;\n\n\n#if (defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)) && \\\n            !defined(WOLFCRYPT_ONLY)\n    if (nameType == ISSUER) {\n        cert->issuerName = dName;\n    }\n    else {\n        cert->subjectName = dName;\n    }\n#endif\n    return 0;\n}\n\n\n#ifndef NO_ASN_TIME\n\n/* two byte date/time, add to value */\nstatic WC_INLINE int GetTime(int* value, const byte* date, int* idx)\n{\n    int i = *idx;\n\n    if (date[i] < 0x30 || date[i] > 0x39 || date[i+1] < 0x30 ||\n                                                             date[i+1] > 0x39) {\n        return ASN_PARSE_E;\n    }\n\n    *value += btoi(date[i++]) * 10;\n    *value += btoi(date[i++]);\n\n    *idx = i;\n\n    return 0;\n}\n\n#ifdef WOLFSSL_LINUXKM\nstatic WC_INLINE int GetTime_Long(long* value, const byte* date, int* idx)\n{\n    int i = *idx;\n\n    if (date[i] < 0x30 || date[i] > 0x39 || date[i+1] < 0x30 ||\n                                                             date[i+1] > 0x39) {\n        return ASN_PARSE_E;\n    }\n\n    *value += (long)btoi(date[i++]) * 10;\n    *value += (long)btoi(date[i++]);\n\n    *idx = i;\n\n    return 0;\n}\n#endif\n\nint ExtractDate(const unsigned char* date, unsigned char format,\n                                                  struct tm* certTime, int* idx)\n{\n    XMEMSET(certTime, 0, sizeof(struct tm));\n\n    if (format == ASN_UTC_TIME) {\n        if (btoi(date[*idx]) >= 5)\n            certTime->tm_year = 1900;\n        else\n            certTime->tm_year = 2000;\n    }\n    else  { /* format == GENERALIZED_TIME */\n#ifdef WOLFSSL_LINUXKM\n        if (GetTime_Long(&certTime->tm_year, date, idx) != 0) return 0;\n#else\n        if (GetTime(&certTime->tm_year, date, idx) != 0) return 0;\n#endif\n        certTime->tm_year *= 100;\n    }\n\n#ifdef AVR\n    /* Extract the time from the struct tm and adjust tm_year, tm_mon */\n    /* AVR libc stores these as uint8_t instead of int */\n    /* AVR time_t also offsets from midnight 1 Jan 2000 */\n    int tm_year = certTime->tm_year - 2000;\n    int tm_mon  = certTime->tm_mon - 1;\n    int tm_mday = certTime->tm_mday;\n    int tm_hour = certTime->tm_hour;\n    int tm_min  = certTime->tm_min;\n    int tm_sec  = certTime->tm_sec;\n\n#ifdef WOLFSSL_LINUXKM\n    if (GetTime_Long(&tm_year, date, idx) != 0) return 0;\n#else\n    if (GetTime(&tm_year, date, idx) != 0) return 0;\n#endif\n    if (GetTime(&tm_mon , date, idx) != 0) return 0;\n    if (GetTime(&tm_mday, date, idx) != 0) return 0;\n    if (GetTime(&tm_hour, date, idx) != 0) return 0;\n    if (GetTime(&tm_min , date, idx) != 0) return 0;\n    if (GetTime(&tm_sec , date, idx) != 0) return 0;\n\n    /* Re-populate certTime with computed values */\n    certTime->tm_year = tm_year;\n    certTime->tm_mon  = tm_mon;\n    certTime->tm_mday = tm_mday;\n    certTime->tm_hour = tm_hour;\n    certTime->tm_min  = tm_min;\n    certTime->tm_sec  = tm_sec;\n#else\n    /* adjust tm_year, tm_mon */\n#ifdef WOLFSSL_LINUXKM\n    if (GetTime_Long(&certTime->tm_year, date, idx) != 0) return 0;\n#else\n    if (GetTime(&certTime->tm_year, date, idx) != 0) return 0;\n#endif\n    certTime->tm_year -= 1900;\n    if (GetTime(&certTime->tm_mon , date, idx) != 0) return 0;\n    certTime->tm_mon  -= 1;\n    if (GetTime(&certTime->tm_mday, date, idx) != 0) return 0;\n    if (GetTime(&certTime->tm_hour, date, idx) != 0) return 0;\n    if (GetTime(&certTime->tm_min , date, idx) != 0) return 0;\n    if (GetTime(&certTime->tm_sec , date, idx) != 0) return 0;\n#endif\n\n    return 1;\n}\n\n\n#if defined(OPENSSL_ALL) || defined(WOLFSSL_MYSQL_COMPATIBLE) || \\\n    defined(OPENSSL_EXTRA) || defined(WOLFSSL_NGINX) || defined(WOLFSSL_HAPROXY)\nint GetTimeString(byte* date, int format, char* buf, int len)\n{\n    struct tm t;\n    int idx = 0;\n\n    if (!ExtractDate(date, (unsigned char)format, &t, &idx)) {\n        return 0;\n    }\n\n    if (date[idx] != 'Z') {\n        WOLFSSL_MSG(\"UTCtime, not Zulu\") ;\n        return 0;\n    }\n\n    /* place month in buffer */\n    buf[0] = '\\0';\n    switch(t.tm_mon) {\n        case 0:  XSTRNCAT(buf, \"Jan \", 5); break;\n        case 1:  XSTRNCAT(buf, \"Feb \", 5); break;\n        case 2:  XSTRNCAT(buf, \"Mar \", 5); break;\n        case 3:  XSTRNCAT(buf, \"Apr \", 5); break;\n        case 4:  XSTRNCAT(buf, \"May \", 5); break;\n        case 5:  XSTRNCAT(buf, \"Jun \", 5); break;\n        case 6:  XSTRNCAT(buf, \"Jul \", 5); break;\n        case 7:  XSTRNCAT(buf, \"Aug \", 5); break;\n        case 8:  XSTRNCAT(buf, \"Sep \", 5); break;\n        case 9:  XSTRNCAT(buf, \"Oct \", 5); break;\n        case 10: XSTRNCAT(buf, \"Nov \", 5); break;\n        case 11: XSTRNCAT(buf, \"Dec \", 5); break;\n        default:\n            return 0;\n\n    }\n    idx = 4; /* use idx now for char buffer */\n\n    XSNPRINTF(buf + idx, len - idx, \"%2d %02d:%02d:%02d %d GMT\",\n              t.tm_mday, t.tm_hour, t.tm_min, t.tm_sec, (int)t.tm_year + 1900);\n\n    return 1;\n}\n#endif /* OPENSSL_ALL || WOLFSSL_MYSQL_COMPATIBLE || WOLFSSL_NGINX || WOLFSSL_HAPROXY */\n\n\n#if !defined(NO_ASN_TIME) && defined(HAVE_PKCS7)\n\n/* Set current time string, either UTC or GeneralizedTime.\n * (void*) tm should be a pointer to time_t, output is placed in buf.\n *\n * Return time string length placed in buf on success, negative on error */\nint GetAsnTimeString(void* currTime, byte* buf, word32 len)\n{\n    struct tm* ts      = NULL;\n    struct tm* tmpTime = NULL;\n    byte* data_ptr  = buf;\n    word32 data_len = 0;\n    int year, mon, day, hour, mini, sec;\n#if defined(NEED_TMP_TIME)\n    struct tm tmpTimeStorage;\n    tmpTime = &tmpTimeStorage;\n#else\n    (void)tmpTime;\n#endif\n\n    WOLFSSL_ENTER(\"SetAsnTimeString\");\n\n    if (buf == NULL || len == 0)\n        return BAD_FUNC_ARG;\n\n    ts = (struct tm *)XGMTIME((time_t*)currTime, tmpTime);\n    if (ts == NULL){\n        WOLFSSL_MSG(\"failed to get time data.\");\n        return ASN_TIME_E;\n    }\n\n    /* Note ASN_UTC_TIME_SIZE and ASN_GENERALIZED_TIME_SIZE include space for\n     * the null terminator. ASN encoded values leave off the terminator. */\n\n    if (ts->tm_year >= 50 && ts->tm_year < 150) {\n        /* UTC Time */\n        char utc_str[ASN_UTC_TIME_SIZE];\n        data_len = ASN_UTC_TIME_SIZE - 1 + 2;\n\n        if (len < data_len)\n            return BUFFER_E;\n\n        if (ts->tm_year >= 50 && ts->tm_year < 100) {\n            year = ts->tm_year;\n        } else if (ts->tm_year >= 100 && ts->tm_year < 150) {\n            year = ts->tm_year - 100;\n        }\n        else {\n            WOLFSSL_MSG(\"unsupported year range\");\n            return BAD_FUNC_ARG;\n        }\n        mon  = ts->tm_mon + 1;\n        day  = ts->tm_mday;\n        hour = ts->tm_hour;\n        mini = ts->tm_min;\n        sec  = ts->tm_sec;\n        XSNPRINTF((char *)utc_str, ASN_UTC_TIME_SIZE,\n                  \"%02d%02d%02d%02d%02d%02dZ\", year, mon, day, hour, mini, sec);\n        *data_ptr = (byte) ASN_UTC_TIME; data_ptr++;\n        /* -1 below excludes null terminator */\n        *data_ptr = (byte) ASN_UTC_TIME_SIZE - 1; data_ptr++;\n        XMEMCPY(data_ptr,(byte *)utc_str, ASN_UTC_TIME_SIZE - 1);\n\n    } else {\n        /* GeneralizedTime */\n        char gt_str[ASN_GENERALIZED_TIME_SIZE];\n        data_len = ASN_GENERALIZED_TIME_SIZE - 1 + 2;\n\n        if (len < data_len)\n            return BUFFER_E;\n\n        year = ts->tm_year + 1900;\n        mon  = ts->tm_mon + 1;\n        day  = ts->tm_mday;\n        hour = ts->tm_hour;\n        mini = ts->tm_min;\n        sec  = ts->tm_sec;\n        XSNPRINTF((char *)gt_str, ASN_GENERALIZED_TIME_SIZE,\n                  \"%4d%02d%02d%02d%02d%02dZ\", year, mon, day, hour, mini, sec);\n        *data_ptr = (byte) ASN_GENERALIZED_TIME; data_ptr++;\n        /* -1 below excludes null terminator */\n        *data_ptr = (byte) ASN_GENERALIZED_TIME_SIZE - 1; data_ptr++;\n        XMEMCPY(data_ptr,(byte *)gt_str, ASN_GENERALIZED_TIME_SIZE - 1);\n    }\n\n    return data_len;\n}\n\n#endif /* !NO_ASN_TIME && HAVE_PKCS7 */\n\n\n#if defined(USE_WOLF_VALIDDATE)\n\n/* to the second */\nint DateGreaterThan(const struct tm* a, const struct tm* b)\n{\n    if (a->tm_year > b->tm_year)\n        return 1;\n\n    if (a->tm_year == b->tm_year && a->tm_mon > b->tm_mon)\n        return 1;\n\n    if (a->tm_year == b->tm_year && a->tm_mon == b->tm_mon &&\n           a->tm_mday > b->tm_mday)\n        return 1;\n\n    if (a->tm_year == b->tm_year && a->tm_mon == b->tm_mon &&\n        a->tm_mday == b->tm_mday && a->tm_hour > b->tm_hour)\n        return 1;\n\n    if (a->tm_year == b->tm_year && a->tm_mon == b->tm_mon &&\n        a->tm_mday == b->tm_mday && a->tm_hour == b->tm_hour &&\n        a->tm_min > b->tm_min)\n        return 1;\n\n    if (a->tm_year == b->tm_year && a->tm_mon == b->tm_mon &&\n        a->tm_mday == b->tm_mday && a->tm_hour == b->tm_hour &&\n        a->tm_min  == b->tm_min  && a->tm_sec > b->tm_sec)\n        return 1;\n\n    return 0; /* false */\n}\n\n\nstatic WC_INLINE int DateLessThan(const struct tm* a, const struct tm* b)\n{\n    return DateGreaterThan(b,a);\n}\n\n/* like atoi but only use first byte */\n/* Make sure before and after dates are valid */\nint wc_ValidateDate(const byte* date, byte format, int dateType)\n{\n    time_t ltime;\n    struct tm  certTime;\n    struct tm* localTime;\n    struct tm* tmpTime;\n    int    i = 0;\n    int    timeDiff = 0 ;\n    int    diffHH = 0 ; int diffMM = 0 ;\n    int    diffSign = 0 ;\n\n#if defined(NEED_TMP_TIME)\n    struct tm tmpTimeStorage;\n    tmpTime = &tmpTimeStorage;\n#else\n    tmpTime = NULL;\n#endif\n    (void)tmpTime;\n\n    ltime = XTIME(0);\n\n#ifdef WOLFSSL_BEFORE_DATE_CLOCK_SKEW\n    if (dateType == BEFORE) {\n        WOLFSSL_MSG(\"Skewing local time for before date check\");\n        ltime += WOLFSSL_BEFORE_DATE_CLOCK_SKEW;\n    }\n#endif\n\n#ifdef WOLFSSL_AFTER_DATE_CLOCK_SKEW\n    if (dateType == AFTER) {\n        WOLFSSL_MSG(\"Skewing local time for after date check\");\n        ltime -= WOLFSSL_AFTER_DATE_CLOCK_SKEW;\n    }\n#endif\n\n    if (!ExtractDate(date, format, &certTime, &i)) {\n        WOLFSSL_MSG(\"Error extracting the date\");\n        return 0;\n    }\n\n    if ((date[i] == '+') || (date[i] == '-')) {\n        WOLFSSL_MSG(\"Using time differential, not Zulu\") ;\n        diffSign = date[i++] == '+' ? 1 : -1 ;\n        if (GetTime(&diffHH, date, &i) != 0)\n            return 0;\n        if (GetTime(&diffMM, date, &i) != 0)\n            return 0;\n        timeDiff = diffSign * (diffHH*60 + diffMM) * 60 ;\n    } else if (date[i] != 'Z') {\n        WOLFSSL_MSG(\"UTCtime, neither Zulu or time differential\") ;\n        return 0;\n    }\n\n    ltime -= (time_t)timeDiff ;\n    localTime = XGMTIME(&ltime, tmpTime);\n\n    if (localTime == NULL) {\n        WOLFSSL_MSG(\"XGMTIME failed\");\n        return 0;\n    }\n\n    if (dateType == BEFORE) {\n        if (DateLessThan(localTime, &certTime)) {\n            WOLFSSL_MSG(\"Date BEFORE check failed\");\n            return 0;\n        }\n    }\n    else {  /* dateType == AFTER */\n        if (DateGreaterThan(localTime, &certTime)) {\n            WOLFSSL_MSG(\"Date AFTER check failed\");\n            return 0;\n        }\n    }\n\n    return 1;\n}\n#endif /* USE_WOLF_VALIDDATE */\n\nint wc_GetTime(void* timePtr, word32 timeSize)\n{\n    time_t* ltime = (time_t*)timePtr;\n\n    if (timePtr == NULL) {\n        return BAD_FUNC_ARG;\n    }\n\n    if ((word32)sizeof(time_t) > timeSize) {\n        return BUFFER_E;\n    }\n\n    *ltime = XTIME(0);\n\n    return 0;\n}\n\n#endif /* !NO_ASN_TIME */\n\n\n/* Get date buffer, format and length. Returns 0=success or error */\nstatic int GetDateInfo(const byte* source, word32* idx, const byte** pDate,\n                        byte* pFormat, int* pLength, word32 maxIdx)\n{\n    int length;\n    byte format;\n\n    if (source == NULL || idx == NULL)\n        return BAD_FUNC_ARG;\n\n    /* get ASN format header */\n    if (*idx+1 > maxIdx)\n        return BUFFER_E;\n    format = source[*idx];\n    *idx += 1;\n    if (format != ASN_UTC_TIME && format != ASN_GENERALIZED_TIME)\n        return ASN_TIME_E;\n\n    /* get length */\n    if (GetLength(source, idx, &length, maxIdx) < 0)\n        return ASN_PARSE_E;\n    if (length > MAX_DATE_SIZE || length < MIN_DATE_SIZE)\n        return ASN_DATE_SZ_E;\n\n    /* return format, date and length */\n    if (pFormat)\n        *pFormat = format;\n    if (pDate)\n        *pDate = &source[*idx];\n    if (pLength)\n        *pLength = length;\n\n    *idx += length;\n\n    return 0;\n}\n\nstatic int GetDate(DecodedCert* cert, int dateType, int verify, int maxIdx)\n{\n    int    ret, length;\n    const byte *datePtr = NULL;\n    byte   date[MAX_DATE_SIZE];\n    byte   format;\n    word32 startIdx = 0;\n\n    if (dateType == BEFORE)\n        cert->beforeDate = &cert->source[cert->srcIdx];\n    else\n        cert->afterDate = &cert->source[cert->srcIdx];\n    startIdx = cert->srcIdx;\n\n    ret = GetDateInfo(cert->source, &cert->srcIdx, &datePtr, &format,\n                      &length, maxIdx);\n    if (ret < 0)\n        return ret;\n\n    XMEMSET(date, 0, MAX_DATE_SIZE);\n    XMEMCPY(date, datePtr, length);\n\n    if (dateType == BEFORE)\n        cert->beforeDateLen = cert->srcIdx - startIdx;\n    else\n        cert->afterDateLen  = cert->srcIdx - startIdx;\n\n#ifndef NO_ASN_TIME\n    if (verify != NO_VERIFY && verify != VERIFY_SKIP_DATE &&\n            !XVALIDATE_DATE(date, format, dateType)) {\n        if (dateType == BEFORE)\n            return ASN_BEFORE_DATE_E;\n        else\n            return ASN_AFTER_DATE_E;\n    }\n#else\n    (void)verify;\n#endif\n\n    return 0;\n}\n\nstatic int GetValidity(DecodedCert* cert, int verify, int maxIdx)\n{\n    int length;\n    int badDate = 0;\n\n    if (GetSequence(cert->source, &cert->srcIdx, &length, maxIdx) < 0)\n        return ASN_PARSE_E;\n\n    maxIdx = cert->srcIdx + length;\n\n    if (GetDate(cert, BEFORE, verify, maxIdx) < 0)\n        badDate = ASN_BEFORE_DATE_E; /* continue parsing */\n\n    if (GetDate(cert, AFTER, verify, maxIdx) < 0)\n        return ASN_AFTER_DATE_E;\n\n    if (badDate != 0)\n        return badDate;\n\n    return 0;\n}\n\n\nint wc_GetDateInfo(const byte* certDate, int certDateSz, const byte** date,\n    byte* format, int* length)\n{\n    int ret;\n    word32 idx = 0;\n\n    ret = GetDateInfo(certDate, &idx, date, format, length, certDateSz);\n    if (ret < 0)\n        return ret;\n\n    return 0;\n}\n\n#ifndef NO_ASN_TIME\nint wc_GetDateAsCalendarTime(const byte* date, int length, byte format,\n    struct tm* timearg)\n{\n    int idx = 0;\n    (void)length;\n    if (!ExtractDate(date, format, timearg, &idx))\n        return ASN_TIME_E;\n    return 0;\n}\n\n#if defined(WOLFSSL_CERT_GEN) && defined(WOLFSSL_ALT_NAMES)\nint wc_GetCertDates(Cert* cert, struct tm* before, struct tm* after)\n{\n    int ret = 0;\n    const byte* date;\n    byte format;\n    int length;\n\n    if (cert == NULL)\n        return BAD_FUNC_ARG;\n\n    if (before && cert->beforeDateSz > 0) {\n        ret = wc_GetDateInfo(cert->beforeDate, cert->beforeDateSz, &date,\n                             &format, &length);\n        if (ret == 0)\n            ret = wc_GetDateAsCalendarTime(date, length, format, before);\n    }\n    if (after && cert->afterDateSz > 0) {\n        ret = wc_GetDateInfo(cert->afterDate, cert->afterDateSz, &date,\n                             &format, &length);\n        if (ret == 0)\n            ret = wc_GetDateAsCalendarTime(date, length, format, after);\n    }\n\n    return ret;\n}\n#endif /* WOLFSSL_CERT_GEN && WOLFSSL_ALT_NAMES */\n#endif /* !NO_ASN_TIME */\n\n/* parses certificate up to point of X.509 public key\n *\n * if cert date is invalid then badDate gets set to error value, otherwise is 0\n *\n * returns a negative value on fail case\n */\nint wc_GetPubX509(DecodedCert* cert, int verify, int* badDate)\n{\n    int ret;\n\n    if (cert == NULL || badDate == NULL)\n        return BAD_FUNC_ARG;\n\n    *badDate = 0;\n    if ( (ret = GetCertHeader(cert)) < 0)\n        return ret;\n\n    WOLFSSL_MSG(\"Got Cert Header\");\n\n#ifdef WOLFSSL_CERT_REQ\n    if (!cert->isCSR) {\n#endif\n        /* Using the sigIndex as the upper bound because that's where the\n         * actual certificate data ends. */\n        if ( (ret = GetAlgoId(cert->source, &cert->srcIdx, &cert->signatureOID,\n                              oidSigType, cert->sigIndex)) < 0)\n            return ret;\n\n        WOLFSSL_MSG(\"Got Algo ID\");\n\n        if ( (ret = GetName(cert, ISSUER, cert->sigIndex)) < 0)\n            return ret;\n\n        if ( (ret = GetValidity(cert, verify, cert->sigIndex)) < 0)\n            *badDate = ret;\n#ifdef WOLFSSL_CERT_REQ\n    }\n#endif\n\n    if ( (ret = GetName(cert, SUBJECT, cert->sigIndex)) < 0)\n        return ret;\n\n    WOLFSSL_MSG(\"Got Subject Name\");\n    return ret;\n}\n\nint DecodeToKey(DecodedCert* cert, int verify)\n{\n    int badDate = 0;\n    int ret;\n\n    if ( (ret = wc_GetPubX509(cert, verify, &badDate)) < 0)\n        return ret;\n\n    /* Determine if self signed */\n    cert->selfSigned = XMEMCMP(cert->issuerHash,\n                               cert->subjectHash,\n                               KEYID_SIZE) == 0 ? 1 : 0;\n\n    if ( (ret = GetKey(cert)) < 0)\n        return ret;\n\n    WOLFSSL_MSG(\"Got Key\");\n\n    if (badDate != 0)\n        return badDate;\n\n    return ret;\n}\n\n#ifndef NO_CERTS\nstatic int GetSignature(DecodedCert* cert)\n{\n    int length;\n    int ret;\n\n    ret = CheckBitString(cert->source, &cert->srcIdx, &length, cert->maxIdx, 1,\n                         NULL);\n    if (ret != 0)\n        return ret;\n\n    cert->sigLength = length;\n    cert->signature = &cert->source[cert->srcIdx];\n    cert->srcIdx += cert->sigLength;\n\n    if (cert->srcIdx != cert->maxIdx)\n        return ASN_PARSE_E;\n\n    return 0;\n}\n#endif\n\nstatic word32 SetOctetString8Bit(word32 len, byte* output)\n{\n    output[0] = ASN_OCTET_STRING;\n    output[1] = (byte)len;\n    return 2;\n}\n\nstatic word32 SetDigest(const byte* digest, word32 digSz, byte* output)\n{\n    word32 idx = SetOctetString8Bit(digSz, output);\n    XMEMCPY(&output[idx], digest, digSz);\n\n    return idx + digSz;\n}\n\n\nstatic word32 BytePrecision(word32 value)\n{\n    word32 i;\n    for (i = (word32)sizeof(value); i; --i)\n        if (value >> ((i - 1) * WOLFSSL_BIT_SIZE))\n            break;\n\n    return i;\n}\n\n\nword32 SetLength(word32 length, byte* output)\n{\n    word32 i = 0, j;\n\n    if (length < ASN_LONG_LENGTH) {\n        if (output)\n            output[i] = (byte)length;\n        i++;\n    }\n    else {\n        if (output)\n            output[i] = (byte)(BytePrecision(length) | ASN_LONG_LENGTH);\n        i++;\n\n        for (j = BytePrecision(length); j; --j) {\n            if (output)\n                output[i] = (byte)(length >> ((j - 1) * WOLFSSL_BIT_SIZE));\n            i++;\n        }\n    }\n\n    return i;\n}\n\nword32 SetSequence(word32 len, byte* output)\n{\n    if (output)\n        output[0] = ASN_SEQUENCE | ASN_CONSTRUCTED;\n    return SetLength(len, output ? output + 1 : NULL) + 1;\n}\n\nword32 SetOctetString(word32 len, byte* output)\n{\n    output[0] = ASN_OCTET_STRING;\n    return SetLength(len, output + 1) + 1;\n}\n\n/* Write a set header to output */\nword32 SetSet(word32 len, byte* output)\n{\n    output[0] = ASN_SET | ASN_CONSTRUCTED;\n    return SetLength(len, output + 1) + 1;\n}\n\nword32 SetImplicit(byte tag, byte number, word32 len, byte* output)\n{\n\n    output[0] = ((tag == ASN_SEQUENCE || tag == ASN_SET) ? ASN_CONSTRUCTED : 0)\n                    | ASN_CONTEXT_SPECIFIC | number;\n    return SetLength(len, output + 1) + 1;\n}\n\nword32 SetExplicit(byte number, word32 len, byte* output)\n{\n    output[0] = ASN_CONSTRUCTED | ASN_CONTEXT_SPECIFIC | number;\n    return SetLength(len, output + 1) + 1;\n}\n\n\n#if defined(HAVE_ECC) && defined(HAVE_ECC_KEY_EXPORT)\n\nstatic int SetCurve(ecc_key* key, byte* output)\n{\n#ifdef HAVE_OID_ENCODING\n    int ret;\n#endif\n    int idx = 0;\n    word32 oidSz = 0;\n\n    /* validate key */\n    if (key == NULL || key->dp == NULL) {\n        return BAD_FUNC_ARG;\n    }\n\n#ifdef HAVE_OID_ENCODING\n    ret = EncodeObjectId(key->dp->oid, key->dp->oidSz, NULL, &oidSz);\n    if (ret != 0) {\n        return ret;\n    }\n#else\n    oidSz = key->dp->oidSz;\n#endif\n\n    idx += SetObjectId(oidSz, output);\n\n#ifdef HAVE_OID_ENCODING\n    ret = EncodeObjectId(key->dp->oid, key->dp->oidSz, output+idx, &oidSz);\n    if (ret != 0) {\n        return ret;\n    }\n#else\n    XMEMCPY(output+idx, key->dp->oid, oidSz);\n#endif\n    idx += oidSz;\n\n    return idx;\n}\n\n#endif /* HAVE_ECC && HAVE_ECC_KEY_EXPORT */\n\n\n#ifdef HAVE_ECC\nstatic WC_INLINE int IsSigAlgoECDSA(int algoOID)\n{\n    /* ECDSA sigAlgo must not have ASN1 NULL parameters */\n    if (algoOID == CTC_SHAwECDSA || algoOID == CTC_SHA256wECDSA ||\n        algoOID == CTC_SHA384wECDSA || algoOID == CTC_SHA512wECDSA) {\n        return 1;\n    }\n\n    return 0;\n}\n#endif\n\nword32 SetAlgoID(int algoOID, byte* output, int type, int curveSz)\n{\n    word32 tagSz, idSz, seqSz, algoSz = 0;\n    const  byte* algoName = 0;\n    byte   ID_Length[1 + MAX_LENGTH_SZ];\n    byte   seqArray[MAX_SEQ_SZ + 1];  /* add object_id to end */\n    int    length = 0;\n\n    tagSz = (type == oidHashType ||\n             (type == oidSigType\n        #ifdef HAVE_ECC\n              && !IsSigAlgoECDSA(algoOID)\n        #endif\n        #ifdef HAVE_ED25519\n              && algoOID != ED25519k\n        #endif\n        #ifdef HAVE_ED448\n              && algoOID != ED448k\n        #endif\n              ) ||\n             (type == oidKeyType && algoOID == RSAk)) ? 2 : 0;\n\n    algoName = OidFromId(algoOID, type, &algoSz);\n\n    if (algoName == NULL) {\n        WOLFSSL_MSG(\"Unknown Algorithm\");\n        return 0;\n    }\n\n    idSz  = SetObjectId(algoSz, ID_Length);\n    seqSz = SetSequence(idSz + algoSz + tagSz + curveSz, seqArray);\n\n    /* Copy only algo to output for DSA keys */\n    if (algoOID == DSAk && output) {\n        XMEMCPY(output, ID_Length, idSz);\n        XMEMCPY(output + idSz, algoName, algoSz);\n        if (tagSz == 2)\n            SetASNNull(&output[seqSz + idSz + algoSz]);\n    }\n    else if (output) {\n        XMEMCPY(output, seqArray, seqSz);\n        XMEMCPY(output + seqSz, ID_Length, idSz);\n        XMEMCPY(output + seqSz + idSz, algoName, algoSz);\n        if (tagSz == 2)\n            SetASNNull(&output[seqSz + idSz + algoSz]);\n    }\n\n    if (algoOID == DSAk)\n        length = idSz + algoSz + tagSz;\n    else\n        length = seqSz + idSz + algoSz + tagSz;\n\n    return length;\n}\n\n\nword32 wc_EncodeSignature(byte* out, const byte* digest, word32 digSz,\n                          int hashOID)\n{\n    byte digArray[MAX_ENCODED_DIG_SZ];\n    byte algoArray[MAX_ALGO_SZ];\n    byte seqArray[MAX_SEQ_SZ];\n    word32 encDigSz, algoSz, seqSz;\n\n    encDigSz = SetDigest(digest, digSz, digArray);\n    algoSz   = SetAlgoID(hashOID, algoArray, oidHashType, 0);\n    seqSz    = SetSequence(encDigSz + algoSz, seqArray);\n\n    XMEMCPY(out, seqArray, seqSz);\n    XMEMCPY(out + seqSz, algoArray, algoSz);\n    XMEMCPY(out + seqSz + algoSz, digArray, encDigSz);\n\n    return encDigSz + algoSz + seqSz;\n}\n\n\n#ifndef NO_CERTS\n\nint wc_GetCTC_HashOID(int type)\n{\n    int ret;\n    enum wc_HashType hType;\n\n    hType = wc_HashTypeConvert(type);\n    ret = wc_HashGetOID(hType);\n    if (ret < 0)\n        ret = 0; /* backwards compatibility */\n\n    return ret;\n}\n\nvoid InitSignatureCtx(SignatureCtx* sigCtx, void* heap, int devId)\n{\n    if (sigCtx) {\n        XMEMSET(sigCtx, 0, sizeof(SignatureCtx));\n        sigCtx->devId = devId;\n        sigCtx->heap = heap;\n    }\n}\n\nvoid FreeSignatureCtx(SignatureCtx* sigCtx)\n{\n    if (sigCtx == NULL)\n        return;\n\n    if (sigCtx->digest) {\n        XFREE(sigCtx->digest, sigCtx->heap, DYNAMIC_TYPE_DIGEST);\n        sigCtx->digest = NULL;\n    }\n#if !(defined(NO_RSA) && defined(NO_DSA))\n    if (sigCtx->sigCpy) {\n        XFREE(sigCtx->sigCpy, sigCtx->heap, DYNAMIC_TYPE_SIGNATURE);\n        sigCtx->sigCpy = NULL;\n    }\n#endif\n#ifndef NO_ASN_CRYPT\n    if (sigCtx->key.ptr) {\n        switch (sigCtx->keyOID) {\n        #ifndef NO_RSA\n            case RSAk:\n                wc_FreeRsaKey(sigCtx->key.rsa);\n                XFREE(sigCtx->key.ptr, sigCtx->heap, DYNAMIC_TYPE_RSA);\n                break;\n        #endif /* !NO_RSA */\n        #ifndef NO_DSA\n            case DSAk:\n                wc_FreeDsaKey(sigCtx->key.dsa);\n                XFREE(sigCtx->key.dsa, sigCtx->heap, DYNAMIC_TYPE_DSA);\n                break;\n        #endif\n        #ifdef HAVE_ECC\n            case ECDSAk:\n                wc_ecc_free(sigCtx->key.ecc);\n                XFREE(sigCtx->key.ecc, sigCtx->heap, DYNAMIC_TYPE_ECC);\n                break;\n        #endif /* HAVE_ECC */\n        #ifdef HAVE_ED25519\n            case ED25519k:\n                wc_ed25519_free(sigCtx->key.ed25519);\n                XFREE(sigCtx->key.ed25519, sigCtx->heap, DYNAMIC_TYPE_ED25519);\n                break;\n        #endif /* HAVE_ED25519 */\n        #ifdef HAVE_ED448\n            case ED448k:\n                wc_ed448_free(sigCtx->key.ed448);\n                XFREE(sigCtx->key.ed448, sigCtx->heap, DYNAMIC_TYPE_ED448);\n                break;\n        #endif /* HAVE_ED448 */\n            default:\n                break;\n        } /* switch (keyOID) */\n        sigCtx->key.ptr = NULL;\n    }\n#endif\n\n    /* reset state, we are done */\n    sigCtx->state = SIG_STATE_BEGIN;\n}\n\n#ifndef NO_ASN_CRYPT\nstatic int HashForSignature(const byte* buf, word32 bufSz, word32 sigOID,\n                            byte* digest, int* typeH, int* digestSz, int verify)\n{\n    int ret = 0;\n\n    switch (sigOID) {\n    #if defined(WOLFSSL_MD2)\n        case CTC_MD2wRSA:\n            if (!verify) {\n                ret = HASH_TYPE_E;\n                WOLFSSL_MSG(\"MD2 not supported for signing\");\n            }\n            else if ((ret = wc_Md2Hash(buf, bufSz, digest)) == 0) {\n                *typeH    = MD2h;\n                *digestSz = MD2_DIGEST_SIZE;\n            }\n        break;\n    #endif\n    #ifndef NO_MD5\n        case CTC_MD5wRSA:\n            if ((ret = wc_Md5Hash(buf, bufSz, digest)) == 0) {\n                *typeH    = MD5h;\n                *digestSz = WC_MD5_DIGEST_SIZE;\n            }\n            break;\n    #endif\n    #ifndef NO_SHA\n        case CTC_SHAwRSA:\n        case CTC_SHAwDSA:\n        case CTC_SHAwECDSA:\n            if ((ret = wc_ShaHash(buf, bufSz, digest)) == 0) {\n                *typeH    = SHAh;\n                *digestSz = WC_SHA_DIGEST_SIZE;\n            }\n            break;\n    #endif\n    #ifdef WOLFSSL_SHA224\n        case CTC_SHA224wRSA:\n        case CTC_SHA224wECDSA:\n            if ((ret = wc_Sha224Hash(buf, bufSz, digest)) == 0) {\n                *typeH    = SHA224h;\n                *digestSz = WC_SHA224_DIGEST_SIZE;\n            }\n            break;\n    #endif\n    #ifndef NO_SHA256\n        case CTC_SHA256wRSA:\n        case CTC_SHA256wECDSA:\n        case CTC_SHA256wDSA:\n            if ((ret = wc_Sha256Hash(buf, bufSz, digest)) == 0) {\n                *typeH    = SHA256h;\n                *digestSz = WC_SHA256_DIGEST_SIZE;\n            }\n            break;\n    #endif\n    #ifdef WOLFSSL_SHA384\n        case CTC_SHA384wRSA:\n        case CTC_SHA384wECDSA:\n            if ((ret = wc_Sha384Hash(buf, bufSz, digest)) == 0) {\n                *typeH    = SHA384h;\n                *digestSz = WC_SHA384_DIGEST_SIZE;\n            }\n            break;\n    #endif\n    #ifdef WOLFSSL_SHA512\n        case CTC_SHA512wRSA:\n        case CTC_SHA512wECDSA:\n            if ((ret = wc_Sha512Hash(buf, bufSz, digest)) == 0) {\n                *typeH    = SHA512h;\n                *digestSz = WC_SHA512_DIGEST_SIZE;\n            }\n            break;\n    #endif\n    #ifdef WOLFSSL_SHA3\n    #ifndef WOLFSSL_NOSHA3_224\n        case CTC_SHA3_224wRSA:\n        case CTC_SHA3_224wECDSA:\n            if ((ret = wc_Sha3_224Hash(buf, bufSz, digest)) == 0) {\n                *typeH    = SHA3_224h;\n                *digestSz = WC_SHA3_224_DIGEST_SIZE;\n            }\n            break;\n    #endif\n    #ifndef WOLFSSL_NOSHA3_256\n        case CTC_SHA3_256wRSA:\n        case CTC_SHA3_256wECDSA:\n            if ((ret = wc_Sha3_256Hash(buf, bufSz, digest)) == 0) {\n                *typeH    = SHA3_256h;\n                *digestSz = WC_SHA3_256_DIGEST_SIZE;\n            }\n            break;\n    #endif\n    #ifndef WOLFSSL_NOSHA3_384\n        case CTC_SHA3_384wRSA:\n        case CTC_SHA3_384wECDSA:\n            if ((ret = wc_Sha3_384Hash(buf, bufSz, digest)) == 0) {\n                *typeH    = SHA3_384h;\n                *digestSz = WC_SHA3_384_DIGEST_SIZE;\n            }\n            break;\n    #endif\n    #ifndef WOLFSSL_NOSHA3_512\n        case CTC_SHA3_512wRSA:\n        case CTC_SHA3_512wECDSA:\n            if ((ret = wc_Sha3_512Hash(buf, bufSz, digest)) == 0) {\n                *typeH    = SHA3_512h;\n                *digestSz = WC_SHA3_512_DIGEST_SIZE;\n            }\n            break;\n    #endif\n    #endif\n    #ifdef HAVE_ED25519\n        case CTC_ED25519:\n            /* Hashes done in signing operation.\n             * Two dependent hashes with prefixes performed.\n             */\n            break;\n    #endif\n    #ifdef HAVE_ED448\n        case CTC_ED448:\n            /* Hashes done in signing operation.\n             * Two dependent hashes with prefixes performed.\n             */\n            break;\n    #endif\n        default:\n            ret = HASH_TYPE_E;\n            WOLFSSL_MSG(\"Hash for Signature has unsupported type\");\n    }\n\n    (void)buf;\n    (void)bufSz;\n    (void)sigOID;\n    (void)digest;\n    (void)digestSz;\n    (void)typeH;\n    (void)verify;\n\n    return ret;\n}\n#endif /* !NO_ASN_CRYPT */\n\n/* Return codes: 0=Success, Negative (see error-crypt.h), ASN_SIG_CONFIRM_E */\nstatic int ConfirmSignature(SignatureCtx* sigCtx,\n    const byte* buf, word32 bufSz,\n    const byte* key, word32 keySz, word32 keyOID,\n    const byte* sig, word32 sigSz, word32 sigOID, byte* rsaKeyIdx)\n{\n    int ret = 0;\n#ifndef WOLFSSL_RENESAS_TSIP_TLS\n    (void)rsaKeyIdx;\n#endif\n    if (sigCtx == NULL || buf == NULL || bufSz == 0 || key == NULL ||\n        keySz == 0 || sig == NULL || sigSz == 0) {\n        return BAD_FUNC_ARG;\n    }\n\n    (void)key;\n    (void)keySz;\n    (void)sig;\n    (void)sigSz;\n\n    WOLFSSL_ENTER(\"ConfirmSignature\");\n\n#ifndef NO_ASN_CRYPT\n    switch (sigCtx->state) {\n        case SIG_STATE_BEGIN:\n        {\n            sigCtx->keyOID = keyOID; /* must set early for cleanup */\n\n            sigCtx->digest = (byte*)XMALLOC(WC_MAX_DIGEST_SIZE, sigCtx->heap,\n                                                    DYNAMIC_TYPE_DIGEST);\n            if (sigCtx->digest == NULL) {\n                ERROR_OUT(MEMORY_E, exit_cs);\n            }\n\n            sigCtx->state = SIG_STATE_HASH;\n        } /* SIG_STATE_BEGIN */\n        FALL_THROUGH;\n\n        case SIG_STATE_HASH:\n        {\n            ret = HashForSignature(buf, bufSz, sigOID, sigCtx->digest,\n                                   &sigCtx->typeH, &sigCtx->digestSz, 1);\n            if (ret != 0) {\n                goto exit_cs;\n            }\n\n            sigCtx->state = SIG_STATE_KEY;\n        } /* SIG_STATE_HASH */\n        FALL_THROUGH;\n\n        case SIG_STATE_KEY:\n        {\n            switch (keyOID) {\n            #ifndef NO_RSA\n                case RSAk:\n                {\n                    word32 idx = 0;\n\n                    sigCtx->key.rsa = (RsaKey*)XMALLOC(sizeof(RsaKey),\n                                                sigCtx->heap, DYNAMIC_TYPE_RSA);\n                    sigCtx->sigCpy = (byte*)XMALLOC(MAX_ENCODED_SIG_SZ,\n                                         sigCtx->heap, DYNAMIC_TYPE_SIGNATURE);\n                    if (sigCtx->key.rsa == NULL || sigCtx->sigCpy == NULL) {\n                        ERROR_OUT(MEMORY_E, exit_cs);\n                    }\n                    if ((ret = wc_InitRsaKey_ex(sigCtx->key.rsa, sigCtx->heap,\n                                                        sigCtx->devId)) != 0) {\n                        goto exit_cs;\n                    }\n                    if (sigSz > MAX_ENCODED_SIG_SZ) {\n                        WOLFSSL_MSG(\"Verify Signature is too big\");\n                        ERROR_OUT(BUFFER_E, exit_cs);\n                    }\n                    if ((ret = wc_RsaPublicKeyDecode(key, &idx, sigCtx->key.rsa,\n                                                                 keySz)) != 0) {\n                        WOLFSSL_MSG(\"ASN Key decode error RSA\");\n                        goto exit_cs;\n                    }\n                    XMEMCPY(sigCtx->sigCpy, sig, sigSz);\n                    sigCtx->out = NULL;\n\n                #ifdef WOLFSSL_ASYNC_CRYPT\n                    sigCtx->asyncDev = &sigCtx->key.rsa->asyncDev;\n                #endif\n                    break;\n                }\n            #endif /* !NO_RSA */\n            #if !defined(NO_DSA) && !defined(HAVE_SELFTEST)\n                case DSAk:\n                {\n                    word32 idx = 0;\n\n                    if (sigSz < DSA_SIG_SIZE) {\n                        WOLFSSL_MSG(\"Verify Signature is too small\");\n                        ERROR_OUT(BUFFER_E, exit_cs);\n                    }\n                    sigCtx->key.dsa = (DsaKey*)XMALLOC(sizeof(DsaKey),\n                                                sigCtx->heap, DYNAMIC_TYPE_DSA);\n                    sigCtx->sigCpy = (byte*)XMALLOC(sigSz,\n                                         sigCtx->heap, DYNAMIC_TYPE_SIGNATURE);\n                    if (sigCtx->key.dsa == NULL || sigCtx->sigCpy == NULL) {\n                        ERROR_OUT(MEMORY_E, exit_cs);\n                    }\n                    if ((ret = wc_InitDsaKey_h(sigCtx->key.dsa, sigCtx->heap)) != 0) {\n                        WOLFSSL_MSG(\"wc_InitDsaKey_h error\");\n                        goto exit_cs;\n                    }\n                    if ((ret = wc_DsaPublicKeyDecode(key, &idx, sigCtx->key.dsa,\n                                                                 keySz)) != 0) {\n                        WOLFSSL_MSG(\"ASN Key decode error DSA\");\n                        goto exit_cs;\n                    }\n                    if (sigSz != DSA_SIG_SIZE) {\n                #ifdef HAVE_ECC\n                        /* Try to parse it as the contents of a bitstring */\n                        mp_int r, s;\n                        idx = 0;\n                        if (DecodeECC_DSA_Sig(sig + idx, sigSz - idx,\n                                              &r, &s) != 0) {\n                            WOLFSSL_MSG(\"DSA Sig is in unrecognized or \"\n                                        \"incorrect format\");\n                            ERROR_OUT(ASN_SIG_CONFIRM_E, exit_cs);\n                        }\n                        if (mp_to_unsigned_bin_len(&r, sigCtx->sigCpy,\n                                DSA_HALF_SIZE) != MP_OKAY ||\n                            mp_to_unsigned_bin_len(&s,\n                                    sigCtx->sigCpy + DSA_HALF_SIZE,\n                                    DSA_HALF_SIZE) != MP_OKAY) {\n                            WOLFSSL_MSG(\"DSA Sig is in unrecognized or \"\n                                        \"incorrect format\");\n                            ERROR_OUT(ASN_SIG_CONFIRM_E, exit_cs);\n                        }\n                        mp_free(&r);\n                        mp_free(&s);\n                #else\n                        WOLFSSL_MSG(\"DSA Sig is in unrecognized or \"\n                                    \"incorrect format\");\n                        ERROR_OUT(ASN_SIG_CONFIRM_E, exit_cs);\n                #endif\n                    }\n                    else {\n                        XMEMCPY(sigCtx->sigCpy, sig, DSA_SIG_SIZE);\n                    }\n                    break;\n                }\n            #endif /* !NO_DSA && !HAVE_SELFTEST */\n            #ifdef HAVE_ECC\n                case ECDSAk:\n                {\n                    word32 idx = 0;\n\n                    sigCtx->verify = 0;\n                    sigCtx->key.ecc = (ecc_key*)XMALLOC(sizeof(ecc_key),\n                                                sigCtx->heap, DYNAMIC_TYPE_ECC);\n                    if (sigCtx->key.ecc == NULL) {\n                        ERROR_OUT(MEMORY_E, exit_cs);\n                    }\n                    if ((ret = wc_ecc_init_ex(sigCtx->key.ecc, sigCtx->heap,\n                                                          sigCtx->devId)) < 0) {\n                        goto exit_cs;\n                    }\n                    ret = wc_EccPublicKeyDecode(key, &idx, sigCtx->key.ecc,\n                                                                         keySz);\n                    if (ret < 0) {\n                        WOLFSSL_MSG(\"ASN Key import error ECC\");\n                        goto exit_cs;\n                    }\n                #ifdef WOLFSSL_ASYNC_CRYPT\n                    sigCtx->asyncDev = &sigCtx->key.ecc->asyncDev;\n                #endif\n                    break;\n                }\n            #endif /* HAVE_ECC */\n            #ifdef HAVE_ED25519\n                case ED25519k:\n                {\n                    sigCtx->verify = 0;\n                    sigCtx->key.ed25519 = (ed25519_key*)XMALLOC(\n                                              sizeof(ed25519_key), sigCtx->heap,\n                                              DYNAMIC_TYPE_ED25519);\n                    if (sigCtx->key.ed25519 == NULL) {\n                        ERROR_OUT(MEMORY_E, exit_cs);\n                    }\n                    if ((ret = wc_ed25519_init(sigCtx->key.ed25519)) < 0) {\n                        goto exit_cs;\n                    }\n                    if ((ret = wc_ed25519_import_public(key, keySz,\n                                                    sigCtx->key.ed25519)) < 0) {\n                        WOLFSSL_MSG(\"ASN Key import error ED25519\");\n                        goto exit_cs;\n                    }\n                #ifdef WOLFSSL_ASYNC_CRYPT\n                    sigCtx->asyncDev = &sigCtx->key.ed25519->asyncDev;\n                #endif\n                    break;\n                }\n            #endif\n            #ifdef HAVE_ED448\n                case ED448k:\n                {\n                    sigCtx->verify = 0;\n                    sigCtx->key.ed448 = (ed448_key*)XMALLOC(\n                                                sizeof(ed448_key), sigCtx->heap,\n                                                DYNAMIC_TYPE_ED448);\n                    if (sigCtx->key.ed448 == NULL) {\n                        ERROR_OUT(MEMORY_E, exit_cs);\n                    }\n                    if ((ret = wc_ed448_init(sigCtx->key.ed448)) < 0) {\n                        goto exit_cs;\n                    }\n                    if ((ret = wc_ed448_import_public(key, keySz,\n                                                      sigCtx->key.ed448)) < 0) {\n                        WOLFSSL_MSG(\"ASN Key import error ED448\");\n                        goto exit_cs;\n                    }\n                #ifdef WOLFSSL_ASYNC_CRYPT\n                    sigCtx->asyncDev = &sigCtx->key.ed448->asyncDev;\n                #endif\n                    break;\n                }\n            #endif\n                default:\n                    WOLFSSL_MSG(\"Verify Key type unknown\");\n                    ret = ASN_UNKNOWN_OID_E;\n                    break;\n            } /* switch (keyOID) */\n\n            if (ret != 0) {\n                goto exit_cs;\n            }\n\n            sigCtx->state = SIG_STATE_DO;\n\n        #ifdef WOLFSSL_ASYNC_CRYPT\n            if (sigCtx->devId != INVALID_DEVID && sigCtx->asyncDev && sigCtx->asyncCtx) {\n                /* make sure event is initialized */\n                WOLF_EVENT* event = &sigCtx->asyncDev->event;\n                ret = wolfAsync_EventInit(event, WOLF_EVENT_TYPE_ASYNC_WOLFSSL,\n                    sigCtx->asyncCtx, WC_ASYNC_FLAG_CALL_AGAIN);\n            }\n        #endif\n        } /* SIG_STATE_KEY */\n        FALL_THROUGH;\n\n        case SIG_STATE_DO:\n        {\n            switch (keyOID) {\n            #ifndef NO_RSA\n                case RSAk:\n                {\n                #ifdef HAVE_PK_CALLBACKS\n                    if (sigCtx->pkCbRsa) {\n                        ret = sigCtx->pkCbRsa(\n                                sigCtx->sigCpy, sigSz, &sigCtx->out,\n                                key, keySz,\n                                sigCtx->pkCtxRsa);\n                    }\n                    else\n                #endif /* HAVE_PK_CALLBACKS */\n                    {\n                     #ifdef WOLFSSL_RENESAS_TSIP_TLS\n                        if (rsaKeyIdx != NULL)\n                        {\n                            ret = tsip_tls_CertVerify(buf, bufSz, sigCtx->sigCpy,\n                                sigSz,\n                                sigCtx->pubkey_n_start - sigCtx->certBegin,\n                                sigCtx->pubkey_n_len - 1,\n                                sigCtx->pubkey_e_start - sigCtx->certBegin,\n                                sigCtx->pubkey_e_len - 1,\n                                rsaKeyIdx);\n\n                            if (ret == 0){\n                                sigCtx->verifyByTSIP = 1;\n                                ret = 0;\n                            } else {\n                                WOLFSSL_MSG(\"RSA Verify by tsip didn't match\");\n                                ret = ASN_SIG_CONFIRM_E;\n                            }\n                        } else\n                    #endif\n                        ret = wc_RsaSSL_VerifyInline(sigCtx->sigCpy, sigSz,\n                                                 &sigCtx->out, sigCtx->key.rsa);\n                    }\n                    break;\n                }\n            #endif /* !NO_RSA */\n            #if !defined(NO_DSA) && !defined(HAVE_SELFTEST)\n                case DSAk:\n                {\n                    ret = wc_DsaVerify(sigCtx->digest, sigCtx->sigCpy,\n                            sigCtx->key.dsa, &sigCtx->verify);\n                    break;\n                }\n            #endif /* !NO_DSA && !HAVE_SELFTEST */\n            #if defined(HAVE_ECC)\n                case ECDSAk:\n                {\n                #ifdef HAVE_PK_CALLBACKS\n                    if (sigCtx->pkCbEcc) {\n                        ret = sigCtx->pkCbEcc(\n                                sig, sigSz,\n                                sigCtx->digest, sigCtx->digestSz,\n                                key, keySz, &sigCtx->verify,\n                                sigCtx->pkCtxEcc);\n                    }\n                    else\n                #endif /* HAVE_PK_CALLBACKS */\n                    {\n                        ret = wc_ecc_verify_hash(sig, sigSz, sigCtx->digest,\n                                            sigCtx->digestSz, &sigCtx->verify,\n                                            sigCtx->key.ecc);\n                    }\n                    break;\n                }\n            #endif /* HAVE_ECC */\n            #ifdef HAVE_ED25519\n                case ED25519k:\n                {\n                    ret = wc_ed25519_verify_msg(sig, sigSz, buf, bufSz,\n                                          &sigCtx->verify, sigCtx->key.ed25519);\n                    break;\n                }\n            #endif\n            #ifdef HAVE_ED448\n                case ED448k:\n                {\n                    ret = wc_ed448_verify_msg(sig, sigSz, buf, bufSz,\n                                             &sigCtx->verify, sigCtx->key.ed448,\n                                             NULL, 0);\n                    break;\n                }\n            #endif\n                default:\n                    break;\n            }  /* switch (keyOID) */\n\n        #ifdef WOLFSSL_ASYNC_CRYPT\n            if (ret == WC_PENDING_E) {\n                goto exit_cs;\n            }\n        #endif\n\n            if (ret < 0) {\n                /* treat all RSA errors as ASN_SIG_CONFIRM_E */\n                ret = ASN_SIG_CONFIRM_E;\n                goto exit_cs;\n            }\n\n            sigCtx->state = SIG_STATE_CHECK;\n        } /* SIG_STATE_DO */\n        FALL_THROUGH;\n\n        case SIG_STATE_CHECK:\n        {\n            switch (keyOID) {\n            #ifndef NO_RSA\n                case RSAk:\n                {\n                    int encodedSigSz, verifySz;\n                #ifdef WOLFSSL_RENESAS_TSIP\n                    if (sigCtx->verifyByTSIP == 1) break;\n                #endif\n                #ifdef WOLFSSL_SMALL_STACK\n                    byte* encodedSig = (byte*)XMALLOC(MAX_ENCODED_SIG_SZ,\n                                        sigCtx->heap, DYNAMIC_TYPE_TMP_BUFFER);\n                    if (encodedSig == NULL) {\n                        ERROR_OUT(MEMORY_E, exit_cs);\n                    }\n                #else\n                    byte encodedSig[MAX_ENCODED_SIG_SZ];\n                #endif\n\n                    verifySz = ret;\n\n                    /* make sure we're right justified */\n                    encodedSigSz = wc_EncodeSignature(encodedSig,\n                            sigCtx->digest, sigCtx->digestSz, sigCtx->typeH);\n                    if (encodedSigSz == verifySz && sigCtx->out != NULL &&\n                        XMEMCMP(sigCtx->out, encodedSig, encodedSigSz) == 0) {\n                        ret = 0;\n                    }\n                    else {\n                        WOLFSSL_MSG(\"RSA SSL verify match encode error\");\n                        ret = ASN_SIG_CONFIRM_E;\n                    }\n\n                #ifdef WOLFSSL_SMALL_STACK\n                    XFREE(encodedSig, sigCtx->heap, DYNAMIC_TYPE_TMP_BUFFER);\n                #endif\n                    break;\n                }\n            #endif /* NO_RSA */\n            #if !defined(NO_DSA) && !defined(HAVE_SELFTEST)\n                case DSAk:\n                {\n                    if (sigCtx->verify == 1) {\n                        ret = 0;\n                    }\n                    else {\n                        WOLFSSL_MSG(\"DSA Verify didn't match\");\n                        ret = ASN_SIG_CONFIRM_E;\n                    }\n                    break;\n                }\n            #endif /* !NO_DSA && !HAVE_SELFTEST */\n            #ifdef HAVE_ECC\n                case ECDSAk:\n                {\n                    if (sigCtx->verify == 1) {\n                        ret = 0;\n                    }\n                    else {\n                        WOLFSSL_MSG(\"ECC Verify didn't match\");\n                        ret = ASN_SIG_CONFIRM_E;\n                    }\n                    break;\n                }\n            #endif /* HAVE_ECC */\n            #ifdef HAVE_ED25519\n                case ED25519k:\n                {\n                    if (sigCtx->verify == 1) {\n                        ret = 0;\n                    }\n                    else {\n                        WOLFSSL_MSG(\"ED25519 Verify didn't match\");\n                        ret = ASN_SIG_CONFIRM_E;\n                    }\n                    break;\n                }\n            #endif /* HAVE_ED25519 */\n            #ifdef HAVE_ED448\n                case ED448k:\n                {\n                    if (sigCtx->verify == 1) {\n                        ret = 0;\n                    }\n                    else {\n                        WOLFSSL_MSG(\"ED448 Verify didn't match\");\n                        ret = ASN_SIG_CONFIRM_E;\n                    }\n                    break;\n                }\n            #endif /* HAVE_ED448 */\n                default:\n                    break;\n            }  /* switch (keyOID) */\n\n            break;\n        } /* SIG_STATE_CHECK */\n\n        default:\n            break;\n    } /* switch (sigCtx->state) */\n\nexit_cs:\n\n#endif /* !NO_ASN_CRYPT */\n\n    (void)keyOID;\n    (void)sigOID;\n\n    WOLFSSL_LEAVE(\"ConfirmSignature\", ret);\n\n#ifdef WOLFSSL_ASYNC_CRYPT\n    if (ret == WC_PENDING_E)\n        return ret;\n#endif\n\n    FreeSignatureCtx(sigCtx);\n\n    return ret;\n}\n\n\n#ifndef IGNORE_NAME_CONSTRAINTS\n\nstatic int MatchBaseName(int type, const char* name, int nameSz,\n                         const char* base, int baseSz)\n{\n    if (base == NULL || baseSz <= 0 || name == NULL || nameSz <= 0 ||\n            name[0] == '.' || nameSz < baseSz ||\n            (type != ASN_RFC822_TYPE && type != ASN_DNS_TYPE))\n        return 0;\n\n    /* If an email type, handle special cases where the base is only\n     * a domain, or is an email address itself. */\n    if (type == ASN_RFC822_TYPE) {\n        const char* p = NULL;\n        int count = 0;\n\n        if (base[0] != '.') {\n            p = base;\n            count = 0;\n\n            /* find the '@' in the base */\n            while (*p != '@' && count < baseSz) {\n                count++;\n                p++;\n            }\n\n            /* No '@' in base, reset p to NULL */\n            if (count >= baseSz)\n                p = NULL;\n        }\n\n        if (p == NULL) {\n            /* Base isn't an email address, it is a domain name,\n             * wind the name forward one character past its '@'. */\n            p = name;\n            count = 0;\n            while (*p != '@' && count < baseSz) {\n                count++;\n                p++;\n            }\n\n            if (count < baseSz && *p == '@') {\n                name = p + 1;\n                nameSz -= count + 1;\n            }\n        }\n    }\n\n    if ((type == ASN_DNS_TYPE || type == ASN_RFC822_TYPE) && base[0] == '.') {\n        int szAdjust = nameSz - baseSz;\n        name += szAdjust;\n        nameSz -= szAdjust;\n    }\n\n    while (nameSz > 0) {\n        if (XTOLOWER((unsigned char)*name++) !=\n                                               XTOLOWER((unsigned char)*base++))\n            return 0;\n        nameSz--;\n    }\n\n    return 1;\n}\n\n\nstatic int ConfirmNameConstraints(Signer* signer, DecodedCert* cert)\n{\n    if (signer == NULL || cert == NULL)\n        return 0;\n\n    /* Check against the excluded list */\n    if (signer->excludedNames) {\n        Base_entry* base = signer->excludedNames;\n\n        while (base != NULL) {\n            switch (base->type) {\n                case ASN_DNS_TYPE:\n                {\n                    DNS_entry* name = cert->altNames;\n                    while (name != NULL) {\n                        if (MatchBaseName(ASN_DNS_TYPE,\n                                          name->name, name->len,\n                                          base->name, base->nameSz)) {\n                            return 0;\n                        }\n                        name = name->next;\n                    }\n                    break;\n                }\n                case ASN_RFC822_TYPE:\n                {\n                    DNS_entry* name = cert->altEmailNames;\n                    while (name != NULL) {\n                        if (MatchBaseName(ASN_RFC822_TYPE,\n                                          name->name, name->len,\n                                          base->name, base->nameSz)) {\n                            return 0;\n                        }\n                        name = name->next;\n                    }\n                    break;\n                }\n                case ASN_DIR_TYPE:\n                {\n                    /* allow permitted dirName smaller than actual subject */\n                    if (cert->subjectRawLen >= base->nameSz &&\n                        XMEMCMP(cert->subjectRaw, base->name,\n                                                        base->nameSz) == 0) {\n                        return 0;\n                    }\n                    #ifndef WOLFSSL_NO_ASN_STRICT\n                    /* RFC 5280 section 4.2.1.10\n                       \"Restrictions of the form directoryName MUST be\n                        applied to the subject field .... and to any names\n                        of type directoryName in the subjectAltName\n                        extension\"\n                    */\n                    if (cert->altDirNames != NULL) {\n                        DNS_entry* cur = cert->altDirNames;\n                        while (cur != NULL) {\n                            if (XMEMCMP(cur->name, base->name, base->nameSz)\n                                    == 0) {\n                                WOLFSSL_MSG(\"DIR alt name constraint err\");\n                                return 0;\n                            }\n                            cur = cur->next;\n                        }\n                    }\n                    #endif /* !WOLFSSL_NO_ASN_STRICT */\n                    break;\n                }\n                default:\n                    break;\n            }; /* switch */\n            base = base->next;\n        }\n    }\n\n    /* Check against the permitted list */\n    if (signer->permittedNames != NULL) {\n        int needDns = 0;\n        int matchDns = 0;\n        int needEmail = 0;\n        int matchEmail = 0;\n        int needDir = 0;\n        int matchDir = 0;\n        Base_entry* base = signer->permittedNames;\n\n        while (base != NULL) {\n            switch (base->type) {\n                case ASN_DNS_TYPE:\n                {\n                    DNS_entry* name = cert->altNames;\n\n                    if (name != NULL)\n                        needDns = 1;\n\n                    while (name != NULL) {\n                        matchDns = MatchBaseName(ASN_DNS_TYPE,\n                                          name->name, name->len,\n                                          base->name, base->nameSz);\n                        name = name->next;\n                    }\n                    break;\n                }\n                case ASN_RFC822_TYPE:\n                {\n                    DNS_entry* name = cert->altEmailNames;\n\n                    if (name != NULL)\n                        needEmail = 1;\n\n                    while (name != NULL) {\n                        matchEmail = MatchBaseName(ASN_DNS_TYPE,\n                                          name->name, name->len,\n                                          base->name, base->nameSz);\n                        name = name->next;\n                    }\n                    break;\n                }\n                case ASN_DIR_TYPE:\n                {\n                    /* allow permitted dirName smaller than actual subject */\n                    needDir = 1;\n                    if (cert->subjectRaw != NULL &&\n                        cert->subjectRawLen >= base->nameSz &&\n                        XMEMCMP(cert->subjectRaw, base->name,\n                                                        base->nameSz) == 0) {\n                        matchDir = 1;\n\n                        #ifndef WOLFSSL_NO_ASN_STRICT\n                        /* RFC 5280 section 4.2.1.10\n                           \"Restrictions of the form directoryName MUST be\n                            applied to the subject field .... and to any names\n                            of type directoryName in the subjectAltName\n                            extension\"\n                        */\n                        if (cert->altDirNames != NULL) {\n                            DNS_entry* cur = cert->altDirNames;\n                            while (cur != NULL) {\n                                if (XMEMCMP(cur->name, base->name, base->nameSz)\n                                        != 0) {\n                                    WOLFSSL_MSG(\"DIR alt name constraint err\");\n                                    matchDir = 0; /* did not match */\n                                }\n                                cur = cur->next;\n                            }\n                        }\n                        #endif /* !WOLFSSL_NO_ASN_STRICT */\n                    }\n                    break;\n                }\n                default:\n                    break;\n            } /* switch */\n            base = base->next;\n        }\n\n        if ((needDns   && !matchDns) ||\n            (needEmail && !matchEmail) ||\n            (needDir   && !matchDir)) {\n            return 0;\n        }\n    }\n\n    return 1;\n}\n\n#endif /* IGNORE_NAME_CONSTRAINTS */\n\nstatic int DecodeAltNames(const byte* input, int sz, DecodedCert* cert)\n{\n    word32 idx = 0;\n    int length = 0;\n\n    WOLFSSL_ENTER(\"DecodeAltNames\");\n\n    if (GetSequence(input, &idx, &length, sz) < 0) {\n        WOLFSSL_MSG(\"\\tBad Sequence\");\n        return ASN_PARSE_E;\n    }\n\n    if (length == 0) {\n        /* RFC 5280 4.2.1.6.  Subject Alternative Name\n           If the subjectAltName extension is present, the sequence MUST\n           contain at least one entry. */\n        return ASN_PARSE_E;\n    }\n\n    cert->weOwnAltNames = 1;\n\n    while (length > 0) {\n        byte b = input[idx++];\n\n        length--;\n\n        /* Save DNS Type names in the altNames list. */\n        /* Save Other Type names in the cert's OidMap */\n        if (b == (ASN_CONTEXT_SPECIFIC | ASN_DNS_TYPE)) {\n            DNS_entry* dnsEntry;\n            int strLen;\n            word32 lenStartIdx = idx;\n\n            if (GetLength(input, &idx, &strLen, sz) < 0) {\n                WOLFSSL_MSG(\"\\tfail: str length\");\n                return ASN_PARSE_E;\n            }\n            length -= (idx - lenStartIdx);\n\n            dnsEntry = (DNS_entry*)XMALLOC(sizeof(DNS_entry), cert->heap,\n                                        DYNAMIC_TYPE_ALTNAME);\n            if (dnsEntry == NULL) {\n                WOLFSSL_MSG(\"\\tOut of Memory\");\n                return MEMORY_E;\n            }\n\n            dnsEntry->type = ASN_DNS_TYPE;\n            dnsEntry->name = (char*)XMALLOC(strLen + 1, cert->heap,\n                                         DYNAMIC_TYPE_ALTNAME);\n            if (dnsEntry->name == NULL) {\n                WOLFSSL_MSG(\"\\tOut of Memory\");\n                XFREE(dnsEntry, cert->heap, DYNAMIC_TYPE_ALTNAME);\n                return MEMORY_E;\n            }\n            dnsEntry->len = strLen;\n            XMEMCPY(dnsEntry->name, &input[idx], strLen);\n            dnsEntry->name[strLen] = '\\0';\n\n            dnsEntry->next = cert->altNames;\n            cert->altNames = dnsEntry;\n\n            length -= strLen;\n            idx    += strLen;\n        }\n    #ifndef IGNORE_NAME_CONSTRAINTS\n        else if (b == (ASN_CONTEXT_SPECIFIC | ASN_CONSTRUCTED | ASN_DIR_TYPE)) {\n            DNS_entry* dirEntry;\n            int strLen;\n            word32 lenStartIdx = idx;\n\n            if (GetLength(input, &idx, &strLen, sz) < 0) {\n                WOLFSSL_MSG(\"\\tfail: str length\");\n                return ASN_PARSE_E;\n            }\n\n            if (GetSequence(input, &idx, &strLen, sz) < 0) {\n                WOLFSSL_MSG(\"\\tfail: seq length\");\n                return ASN_PARSE_E;\n            }\n            length -= (idx - lenStartIdx);\n\n            dirEntry = (DNS_entry*)XMALLOC(sizeof(DNS_entry), cert->heap,\n                                        DYNAMIC_TYPE_ALTNAME);\n            if (dirEntry == NULL) {\n                WOLFSSL_MSG(\"\\tOut of Memory\");\n                return MEMORY_E;\n            }\n\n            dirEntry->type = ASN_DIR_TYPE;\n            dirEntry->name = (char*)XMALLOC(strLen + 1, cert->heap,\n                                         DYNAMIC_TYPE_ALTNAME);\n            if (dirEntry->name == NULL) {\n                WOLFSSL_MSG(\"\\tOut of Memory\");\n                XFREE(dirEntry, cert->heap, DYNAMIC_TYPE_ALTNAME);\n                return MEMORY_E;\n            }\n            dirEntry->len = strLen;\n            XMEMCPY(dirEntry->name, &input[idx], strLen);\n            dirEntry->name[strLen] = '\\0';\n\n            dirEntry->next = cert->altDirNames;\n            cert->altDirNames = dirEntry;\n\n            length -= strLen;\n            idx    += strLen;\n        }\n        else if (b == (ASN_CONTEXT_SPECIFIC | ASN_RFC822_TYPE)) {\n            DNS_entry* emailEntry;\n            int strLen;\n            word32 lenStartIdx = idx;\n\n            if (GetLength(input, &idx, &strLen, sz) < 0) {\n                WOLFSSL_MSG(\"\\tfail: str length\");\n                return ASN_PARSE_E;\n            }\n            length -= (idx - lenStartIdx);\n\n            emailEntry = (DNS_entry*)XMALLOC(sizeof(DNS_entry), cert->heap,\n                                        DYNAMIC_TYPE_ALTNAME);\n            if (emailEntry == NULL) {\n                WOLFSSL_MSG(\"\\tOut of Memory\");\n                return MEMORY_E;\n            }\n\n            emailEntry->type = ASN_RFC822_TYPE;\n            emailEntry->name = (char*)XMALLOC(strLen + 1, cert->heap,\n                                         DYNAMIC_TYPE_ALTNAME);\n            if (emailEntry->name == NULL) {\n                WOLFSSL_MSG(\"\\tOut of Memory\");\n                XFREE(emailEntry, cert->heap, DYNAMIC_TYPE_ALTNAME);\n                return MEMORY_E;\n            }\n            emailEntry->len = strLen;\n            XMEMCPY(emailEntry->name, &input[idx], strLen);\n            emailEntry->name[strLen] = '\\0';\n\n            emailEntry->next = cert->altEmailNames;\n            cert->altEmailNames = emailEntry;\n\n            length -= strLen;\n            idx    += strLen;\n        }\n        else if (b == (ASN_CONTEXT_SPECIFIC | ASN_URI_TYPE)) {\n            DNS_entry* uriEntry;\n            int strLen;\n            word32 lenStartIdx = idx;\n\n            WOLFSSL_MSG(\"\\tPutting URI into list but not using\");\n            if (GetLength(input, &idx, &strLen, sz) < 0) {\n                WOLFSSL_MSG(\"\\tfail: str length\");\n                return ASN_PARSE_E;\n            }\n            length -= (idx - lenStartIdx);\n\n            /* check that strLen at index is not past input buffer */\n            if (strLen + (int)idx > sz) {\n                return BUFFER_E;\n            }\n\n        #ifndef WOLFSSL_NO_ASN_STRICT\n            /* Verify RFC 5280 Sec 4.2.1.6 rule:\n                \"The name MUST NOT be a relative URI\" */\n\n            {\n                int i;\n\n                /* skip past scheme (i.e http,ftp,...) finding first ':' char */\n                for (i = 0; i < strLen; i++) {\n                    if (input[idx + i] == ':') {\n                        break;\n                    }\n                    if (input[idx + i] == '/') {\n                        WOLFSSL_MSG(\"\\tAlt Name must be absolute URI\");\n                        return ASN_ALT_NAME_E;\n                    }\n                }\n\n                /* test if no ':' char was found and test that the next two\n                 * chars are // to match the pattern \"://\" */\n                if (i >= strLen - 2 || (input[idx + i + 1] != '/' ||\n                                        input[idx + i + 2] != '/')) {\n                    WOLFSSL_MSG(\"\\tAlt Name must be absolute URI\");\n                    return ASN_ALT_NAME_E;\n                }\n            }\n        #endif\n\n            uriEntry = (DNS_entry*)XMALLOC(sizeof(DNS_entry), cert->heap,\n                                        DYNAMIC_TYPE_ALTNAME);\n            if (uriEntry == NULL) {\n                WOLFSSL_MSG(\"\\tOut of Memory\");\n                return MEMORY_E;\n            }\n\n            uriEntry->type = ASN_URI_TYPE;\n            uriEntry->name = (char*)XMALLOC(strLen + 1, cert->heap,\n                                         DYNAMIC_TYPE_ALTNAME);\n            if (uriEntry->name == NULL) {\n                WOLFSSL_MSG(\"\\tOut of Memory\");\n                XFREE(uriEntry, cert->heap, DYNAMIC_TYPE_ALTNAME);\n                return MEMORY_E;\n            }\n            uriEntry->len = strLen;\n            XMEMCPY(uriEntry->name, &input[idx], strLen);\n            uriEntry->name[strLen] = '\\0';\n\n            uriEntry->next = cert->altNames;\n            cert->altNames = uriEntry;\n\n            length -= strLen;\n            idx    += strLen;\n        }\n#if defined(WOLFSSL_QT) || defined(OPENSSL_ALL) || defined(WOLFSSL_IP_ALT_NAME)\n        else if (b == (ASN_CONTEXT_SPECIFIC | ASN_IP_TYPE)) {\n            DNS_entry* ipAddr;\n            int strLen;\n            word32 lenStartIdx = idx;\n            WOLFSSL_MSG(\"Decoding Subject Alt. Name: IP Address\");\n\n            if (GetLength(input, &idx, &strLen, sz) < 0) {\n                WOLFSSL_MSG(\"\\tfail: str length\");\n                return ASN_PARSE_E;\n            }\n            length -= (idx - lenStartIdx);\n            /* check that strLen at index is not past input buffer */\n            if (strLen + (int)idx > sz) {\n                return BUFFER_E;\n            }\n\n            ipAddr = (DNS_entry*)XMALLOC(sizeof(DNS_entry), cert->heap,\n                                        DYNAMIC_TYPE_ALTNAME);\n            if (ipAddr == NULL) {\n                WOLFSSL_MSG(\"\\tOut of Memory\");\n                return MEMORY_E;\n            }\n\n            ipAddr->type = ASN_IP_TYPE;\n            ipAddr->name = (char*)XMALLOC(strLen + 1, cert->heap,\n                                         DYNAMIC_TYPE_ALTNAME);\n            if (ipAddr->name == NULL) {\n                WOLFSSL_MSG(\"\\tOut of Memory\");\n                XFREE(ipAddr, cert->heap, DYNAMIC_TYPE_ALTNAME);\n                return MEMORY_E;\n            }\n            ipAddr->len = strLen;\n            XMEMCPY(ipAddr->name, &input[idx], strLen);\n            ipAddr->name[strLen] = '\\0';\n\n            ipAddr->next   = cert->altNames;\n            cert->altNames = ipAddr;\n\n            length -= strLen;\n            idx    += strLen;\n        }\n#endif /* WOLFSSL_QT || OPENSSL_ALL */\n#endif /* IGNORE_NAME_CONSTRAINTS */\n#ifdef WOLFSSL_SEP\n        else if (b == (ASN_CONTEXT_SPECIFIC | ASN_CONSTRUCTED | ASN_OTHER_TYPE))\n        {\n            int strLen;\n            word32 lenStartIdx = idx;\n            word32 oid = 0;\n            int    ret;\n            byte   tag;\n\n            if (GetLength(input, &idx, &strLen, sz) < 0) {\n                WOLFSSL_MSG(\"\\tfail: other name length\");\n                return ASN_PARSE_E;\n            }\n            /* Consume the rest of this sequence. */\n            length -= (strLen + idx - lenStartIdx);\n\n            if (GetObjectId(input, &idx, &oid, oidCertAltNameType, sz) < 0) {\n                WOLFSSL_MSG(\"\\tbad OID\");\n                return ASN_PARSE_E;\n            }\n\n            if (oid != HW_NAME_OID) {\n                WOLFSSL_MSG(\"\\tincorrect OID\");\n                return ASN_PARSE_E;\n            }\n\n            /* Certiciates issued with this OID in the subject alt name are for\n             * verifying signatures created on a module.\n             * RFC 4108 Section 5. */\n            if (cert->hwType != NULL) {\n                WOLFSSL_MSG(\"\\tAlready seen Hardware Module Name\");\n                return ASN_PARSE_E;\n            }\n\n            if (GetASNTag(input, &idx, &tag, sz) < 0) {\n                return ASN_PARSE_E;\n            }\n\n            if (tag != (ASN_CONTEXT_SPECIFIC | ASN_CONSTRUCTED)) {\n                WOLFSSL_MSG(\"\\twrong type\");\n                return ASN_PARSE_E;\n            }\n\n            if (GetLength(input, &idx, &strLen, sz) < 0) {\n                WOLFSSL_MSG(\"\\tfail: str len\");\n                return ASN_PARSE_E;\n            }\n\n            if (GetSequence(input, &idx, &strLen, sz) < 0) {\n                WOLFSSL_MSG(\"\\tBad Sequence\");\n                return ASN_PARSE_E;\n            }\n\n            ret = GetASNObjectId(input, &idx, &strLen, sz);\n            if (ret != 0) {\n                WOLFSSL_MSG(\"\\tbad OID\");\n                return ret;\n            }\n\n            cert->hwType = (byte*)XMALLOC(strLen, cert->heap,\n                                          DYNAMIC_TYPE_X509_EXT);\n            if (cert->hwType == NULL) {\n                WOLFSSL_MSG(\"\\tOut of Memory\");\n                return MEMORY_E;\n            }\n\n            XMEMCPY(cert->hwType, &input[idx], strLen);\n            cert->hwTypeSz = strLen;\n            idx += strLen;\n\n            ret = GetOctetString(input, &idx, &strLen, sz);\n            if (ret < 0)\n                return ret;\n\n            cert->hwSerialNum = (byte*)XMALLOC(strLen + 1, cert->heap,\n                                               DYNAMIC_TYPE_X509_EXT);\n            if (cert->hwSerialNum == NULL) {\n                WOLFSSL_MSG(\"\\tOut of Memory\");\n                return MEMORY_E;\n            }\n\n            XMEMCPY(cert->hwSerialNum, &input[idx], strLen);\n            cert->hwSerialNum[strLen] = '\\0';\n            cert->hwSerialNumSz = strLen;\n            idx += strLen;\n        }\n    #endif /* WOLFSSL_SEP */\n        else {\n            int strLen;\n            word32 lenStartIdx = idx;\n\n            WOLFSSL_MSG(\"\\tUnsupported name type, skipping\");\n\n            if (GetLength(input, &idx, &strLen, sz) < 0) {\n                WOLFSSL_MSG(\"\\tfail: unsupported name length\");\n                return ASN_PARSE_E;\n            }\n            length -= (strLen + idx - lenStartIdx);\n            idx += strLen;\n        }\n    }\n    return 0;\n}\n\nstatic int DecodeBasicCaConstraint(const byte* input, int sz, DecodedCert* cert)\n{\n    word32 idx = 0;\n    int length = 0;\n    int ret;\n\n    WOLFSSL_ENTER(\"DecodeBasicCaConstraint\");\n\n    if (GetSequence(input, &idx, &length, sz) < 0) {\n        WOLFSSL_MSG(\"\\tfail: bad SEQUENCE\");\n        return ASN_PARSE_E;\n    }\n\n    if (length == 0)\n        return 0;\n\n    /* If the basic ca constraint is false, this extension may be named, but\n     * left empty. So, if the length is 0, just return. */\n\n    ret = GetBoolean(input, &idx, sz);\n\n#ifndef WOLFSSL_X509_BASICCONS_INT\n    if (ret < 0) {\n        WOLFSSL_MSG(\"\\tfail: constraint not valid BOOLEAN\");\n        return ret;\n    }\n\n    cert->isCA = (byte)ret;\n#else\n    if (ret < 0) {\n        if(input[idx] == ASN_INTEGER) {\n            /* For OpenSSL compatibility, if ASN_INTEGER it is valid format */\n            cert->isCA = FALSE;\n        } else return ret;\n    } else\n        cert->isCA = (byte)ret;\n#endif\n\n    /* If there isn't any more data, return. */\n    if (idx >= (word32)sz) {\n        return 0;\n    }\n\n    ret = GetInteger7Bit(input, &idx, sz);\n    if (ret < 0)\n        return ret;\n    cert->pathLength = (byte)ret;\n    cert->pathLengthSet = 1;\n\n    return 0;\n}\n\n\nstatic int DecodePolicyConstraints(const byte* input, int sz, DecodedCert* cert)\n{\n    word32 idx = 0;\n    int length = 0;\n    int skipLength = 0;\n    int ret;\n    byte tag;\n\n    WOLFSSL_ENTER(\"DecodePolicyConstraints\");\n\n    if (GetSequence(input, &idx, &length, sz) < 0) {\n        WOLFSSL_MSG(\"\\tfail: bad SEQUENCE\");\n        return ASN_PARSE_E;\n    }\n\n    if (length == 0)\n        return ASN_PARSE_E;\n\n    if (GetASNTag(input, &idx, &tag, sz) < 0) {\n        WOLFSSL_MSG(\"\\tfail: bad TAG\");\n        return ASN_PARSE_E;\n    }\n\n    if (tag == (ASN_CONTEXT_SPECIFIC | 0)) {\n        /* requireExplicitPolicy */\n        cert->extPolicyConstRxpSet = 1;\n    }\n    else if (tag == (ASN_CONTEXT_SPECIFIC | 1)) {\n        /* inhibitPolicyMapping */\n        cert->extPolicyConstIpmSet = 1;\n    }\n    else {\n        WOLFSSL_MSG(\"\\tfail: invalid TAG\");\n        return ASN_PARSE_E;\n    }\n\n    ret = GetLength(input, &idx, &skipLength, sz);\n    if (ret < 0) {\n        WOLFSSL_MSG(\"\\tfail: invalid length\");\n        return ret;\n    }\n    if (skipLength > 1) {\n        WOLFSSL_MSG(\"\\tfail: skip value too big\");\n        return BUFFER_E;\n    }\n    cert->policyConstSkip = input[idx];\n\n    return 0;\n}\n\n\n#define CRLDP_FULL_NAME 0\n    /* From RFC3280 SS4.2.1.14, Distribution Point Name*/\n#define GENERALNAME_URI 6\n    /* From RFC3280 SS4.2.1.7, GeneralName */\n\nstatic int DecodeCrlDist(const byte* input, int sz, DecodedCert* cert)\n{\n    word32 idx = 0, localIdx;\n    int length = 0;\n    byte tag   = 0;\n\n    WOLFSSL_ENTER(\"DecodeCrlDist\");\n\n    /* Unwrap the list of Distribution Points*/\n    if (GetSequence(input, &idx, &length, sz) < 0)\n        return ASN_PARSE_E;\n\n    /* Unwrap a single Distribution Point */\n    if (GetSequence(input, &idx, &length, sz) < 0)\n        return ASN_PARSE_E;\n\n    /* The Distribution Point has three explicit optional members\n     *  First check for a DistributionPointName\n     */\n    localIdx = idx;\n    if (GetASNTag(input, &localIdx, &tag, sz) == 0 &&\n            tag == (ASN_CONSTRUCTED | ASN_CONTEXT_SPECIFIC | 0))\n    {\n        idx++;\n        if (GetLength(input, &idx, &length, sz) < 0)\n            return ASN_PARSE_E;\n\n        localIdx = idx;\n        if (GetASNTag(input, &localIdx, &tag, sz) == 0 &&\n                tag == (ASN_CONTEXT_SPECIFIC | ASN_CONSTRUCTED |\n                    CRLDP_FULL_NAME))\n        {\n            idx++;\n            if (GetLength(input, &idx, &length, sz) < 0)\n                return ASN_PARSE_E;\n\n            localIdx = idx;\n            if (GetASNTag(input, &localIdx, &tag, sz) == 0 &&\n                    tag == (ASN_CONTEXT_SPECIFIC | GENERALNAME_URI))\n            {\n                idx++;\n                if (GetLength(input, &idx, &length, sz) < 0)\n                    return ASN_PARSE_E;\n\n                cert->extCrlInfoSz = length;\n                cert->extCrlInfo = input + idx;\n                idx += length;\n            }\n            else\n                /* This isn't a URI, skip it. */\n                idx += length;\n        }\n        else {\n            /* This isn't a FULLNAME, skip it. */\n            idx += length;\n        }\n    }\n\n    /* Check for reasonFlags */\n    localIdx = idx;\n    if (idx < (word32)sz &&\n        GetASNTag(input, &localIdx, &tag, sz) == 0 &&\n        tag == (ASN_CONSTRUCTED | ASN_CONTEXT_SPECIFIC | 1))\n    {\n        idx++;\n        if (GetLength(input, &idx, &length, sz) < 0)\n            return ASN_PARSE_E;\n        idx += length;\n    }\n\n    /* Check for cRLIssuer */\n    localIdx = idx;\n    if (idx < (word32)sz &&\n        GetASNTag(input, &localIdx, &tag, sz) == 0 &&\n        tag == (ASN_CONSTRUCTED | ASN_CONTEXT_SPECIFIC | 2))\n    {\n        idx++;\n        if (GetLength(input, &idx, &length, sz) < 0)\n            return ASN_PARSE_E;\n        idx += length;\n    }\n\n    if (idx < (word32)sz)\n    {\n        WOLFSSL_MSG(\"\\tThere are more CRL Distribution Point records, \"\n                   \"but we only use the first one.\");\n    }\n\n    return 0;\n}\n\n\nstatic int DecodeAuthInfo(const byte* input, int sz, DecodedCert* cert)\n/*\n *  Read Authority Information Access records. If there are\n *  any issues, return without saving the record.\n */\n{\n    word32 idx = 0;\n    int length = 0;\n    int count  = 0;\n    byte b = 0;\n    word32 oid;\n\n    WOLFSSL_ENTER(\"DecodeAuthInfo\");\n\n    /* Unwrap the list of AIAs */\n    if (GetSequence(input, &idx, &length, sz) < 0)\n        return ASN_PARSE_E;\n\n    while ((idx < (word32)sz) && (count < MAX_AIA_SZ)) {\n        /* Unwrap a single AIA */\n        if (GetSequence(input, &idx, &length, sz) < 0)\n            return ASN_PARSE_E;\n\n        oid = 0;\n        if (GetObjectId(input, &idx, &oid, oidCertAuthInfoType, sz) < 0)\n            return ASN_PARSE_E;\n\n        /* Only supporting URIs right now. */\n        if (GetASNTag(input, &idx, &b, sz) < 0)\n            return ASN_PARSE_E;\n\n        if (GetLength(input, &idx, &length, sz) < 0)\n            return ASN_PARSE_E;\n\n        /* Set ocsp entry */\n        if (b == (ASN_CONTEXT_SPECIFIC | GENERALNAME_URI) &&\n            oid == AIA_OCSP_OID)\n        {\n            cert->extAuthInfoSz = length;\n            cert->extAuthInfo = input + idx;\n            count++;\n        #if !defined(OPENSSL_ALL) || !defined(WOLFSSL_QT)\n            break;\n        #endif\n        }\n        #if defined(OPENSSL_ALL) || defined(WOLFSSL_QT)\n        /* Set CaIssuers entry */\n        else if ((b == (ASN_CONTEXT_SPECIFIC | GENERALNAME_URI)) &&\n            oid == AIA_CA_ISSUER_OID)\n        {\n            cert->extAuthInfoCaIssuerSz = length;\n            cert->extAuthInfoCaIssuer = input + idx;\n            count++;\n        }\n        #endif\n        idx += length;\n    }\n\n    return 0;\n}\n\n\nstatic int DecodeAuthKeyId(const byte* input, int sz, DecodedCert* cert)\n{\n    word32 idx = 0;\n    int length = 0, ret = 0;\n    byte tag;\n\n    WOLFSSL_ENTER(\"DecodeAuthKeyId\");\n\n    if (GetSequence(input, &idx, &length, sz) < 0) {\n        WOLFSSL_MSG(\"\\tfail: should be a SEQUENCE\\n\");\n        return ASN_PARSE_E;\n    }\n\n    if (GetASNTag(input, &idx, &tag, sz) < 0) {\n        return ASN_PARSE_E;\n    }\n\n    if (tag != (ASN_CONTEXT_SPECIFIC | 0)) {\n        WOLFSSL_MSG(\"\\tinfo: OPTIONAL item 0, not available\\n\");\n        cert->extAuthKeyIdSet = 0;\n        return 0;\n    }\n\n    if (GetLength(input, &idx, &length, sz) <= 0) {\n        WOLFSSL_MSG(\"\\tfail: extension data length\");\n        return ASN_PARSE_E;\n    }\n\n#if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)\n    cert->extAuthKeyIdSrc = &input[idx];\n    cert->extAuthKeyIdSz = length;\n#endif /* OPENSSL_EXTRA */\n\n    if (length == KEYID_SIZE) {\n        XMEMCPY(cert->extAuthKeyId, input + idx, length);\n    }\n    else\n        ret = CalcHashId(input + idx, length, cert->extAuthKeyId);\n\n    return ret;\n}\n\n\nstatic int DecodeSubjKeyId(const byte* input, int sz, DecodedCert* cert)\n{\n    word32 idx = 0;\n    int length = 0, ret = 0;\n\n    WOLFSSL_ENTER(\"DecodeSubjKeyId\");\n\n    if (sz <= 0)\n        return ASN_PARSE_E;\n\n    ret = GetOctetString(input, &idx, &length, sz);\n    if (ret < 0)\n        return ret;\n\n    #if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)\n        cert->extSubjKeyIdSrc = &input[idx];\n        cert->extSubjKeyIdSz = length;\n    #endif /* OPENSSL_EXTRA */\n\n    if (length == KEYID_SIZE) {\n        XMEMCPY(cert->extSubjKeyId, input + idx, length);\n    }\n    else\n        ret = CalcHashId(input + idx, length, cert->extSubjKeyId);\n\n    return ret;\n}\n\n\nstatic int DecodeKeyUsage(const byte* input, int sz, DecodedCert* cert)\n{\n    word32 idx = 0;\n    int length;\n    int ret;\n    WOLFSSL_ENTER(\"DecodeKeyUsage\");\n\n    ret = CheckBitString(input, &idx, &length, sz, 0, NULL);\n    if (ret != 0)\n        return ret;\n\n    cert->extKeyUsage = (word16)(input[idx]);\n    if (length == 2)\n        cert->extKeyUsage |= (word16)(input[idx+1] << 8);\n\n    return 0;\n}\n\n\nstatic int DecodeExtKeyUsage(const byte* input, int sz, DecodedCert* cert)\n{\n    word32 idx = 0, oid;\n    int length, ret;\n\n    WOLFSSL_MSG(\"DecodeExtKeyUsage\");\n\n    if (GetSequence(input, &idx, &length, sz) < 0) {\n        WOLFSSL_MSG(\"\\tfail: should be a SEQUENCE\");\n        return ASN_PARSE_E;\n    }\n\n#if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)\n    cert->extExtKeyUsageSrc = input + idx;\n    cert->extExtKeyUsageSz = length;\n#endif\n\n    while (idx < (word32)sz) {\n        ret = GetObjectId(input, &idx, &oid, oidCertKeyUseType, sz);\n        if (ret == ASN_UNKNOWN_OID_E)\n            continue;\n        else if (ret < 0)\n            return ret;\n\n        switch (oid) {\n            case EKU_ANY_OID:\n                cert->extExtKeyUsage |= EXTKEYUSE_ANY;\n                break;\n            case EKU_SERVER_AUTH_OID:\n                cert->extExtKeyUsage |= EXTKEYUSE_SERVER_AUTH;\n                break;\n            case EKU_CLIENT_AUTH_OID:\n                cert->extExtKeyUsage |= EXTKEYUSE_CLIENT_AUTH;\n                break;\n            case EKU_CODESIGNING_OID:\n                cert->extExtKeyUsage |= EXTKEYUSE_CODESIGN;\n                break;\n            case EKU_EMAILPROTECT_OID:\n                cert->extExtKeyUsage |= EXTKEYUSE_EMAILPROT;\n                break;\n            case EKU_TIMESTAMP_OID:\n                cert->extExtKeyUsage |= EXTKEYUSE_TIMESTAMP;\n                break;\n            case EKU_OCSP_SIGN_OID:\n                cert->extExtKeyUsage |= EXTKEYUSE_OCSP_SIGN;\n                break;\n            default:\n                break;\n        }\n\n    #if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)\n        cert->extExtKeyUsageCount++;\n    #endif\n    }\n\n    return 0;\n}\n\n\n#ifndef IGNORE_NAME_CONSTRAINTS\n#define ASN_TYPE_MASK 0xF\nstatic int DecodeSubtree(const byte* input, int sz,\n                         Base_entry** head, void* heap)\n{\n    word32 idx = 0;\n\n    (void)heap;\n\n    while (idx < (word32)sz) {\n        int seqLength, strLength;\n        word32 nameIdx;\n        byte b, bType;\n\n        if (GetSequence(input, &idx, &seqLength, sz) < 0) {\n            WOLFSSL_MSG(\"\\tfail: should be a SEQUENCE\");\n            return ASN_PARSE_E;\n        }\n        nameIdx = idx;\n        b = input[nameIdx++];\n\n        if (GetLength(input, &nameIdx, &strLength, sz) <= 0) {\n            WOLFSSL_MSG(\"\\tinvalid length\");\n            return ASN_PARSE_E;\n        }\n\n        /* Get type, LSB 4-bits */\n        bType = (b & ASN_TYPE_MASK);\n\n        if (bType == ASN_DNS_TYPE || bType == ASN_RFC822_TYPE ||\n                                                        bType == ASN_DIR_TYPE) {\n            Base_entry* entry;\n\n            /* if constructed has leading sequence */\n            if (b & ASN_CONSTRUCTED) {\n                if (GetSequence(input, &nameIdx, &strLength, sz) < 0) {\n                    WOLFSSL_MSG(\"\\tfail: constructed be a SEQUENCE\");\n                    return ASN_PARSE_E;\n                }\n            }\n\n            entry = (Base_entry*)XMALLOC(sizeof(Base_entry), heap,\n                                                          DYNAMIC_TYPE_ALTNAME);\n            if (entry == NULL) {\n                WOLFSSL_MSG(\"allocate error\");\n                return MEMORY_E;\n            }\n\n            entry->name = (char*)XMALLOC(strLength, heap, DYNAMIC_TYPE_ALTNAME);\n            if (entry->name == NULL) {\n                WOLFSSL_MSG(\"allocate error\");\n                XFREE(entry, heap, DYNAMIC_TYPE_ALTNAME);\n                return MEMORY_E;\n            }\n\n            XMEMCPY(entry->name, &input[nameIdx], strLength);\n            entry->nameSz = strLength;\n            entry->type = bType;\n\n            entry->next = *head;\n            *head = entry;\n        }\n\n        idx += seqLength;\n    }\n\n    return 0;\n}\n\n\nstatic int DecodeNameConstraints(const byte* input, int sz, DecodedCert* cert)\n{\n    word32 idx = 0;\n    int length = 0;\n\n    WOLFSSL_ENTER(\"DecodeNameConstraints\");\n\n    if (GetSequence(input, &idx, &length, sz) < 0) {\n        WOLFSSL_MSG(\"\\tfail: should be a SEQUENCE\");\n        return ASN_PARSE_E;\n    }\n\n    while (idx < (word32)sz) {\n        byte b = input[idx++];\n        Base_entry** subtree = NULL;\n\n        if (GetLength(input, &idx, &length, sz) <= 0) {\n            WOLFSSL_MSG(\"\\tinvalid length\");\n            return ASN_PARSE_E;\n        }\n\n        if (b == (ASN_CONTEXT_SPECIFIC | ASN_CONSTRUCTED | 0))\n            subtree = &cert->permittedNames;\n        else if (b == (ASN_CONTEXT_SPECIFIC | ASN_CONSTRUCTED | 1))\n            subtree = &cert->excludedNames;\n        else {\n            WOLFSSL_MSG(\"\\tinvalid subtree\");\n            return ASN_PARSE_E;\n        }\n\n        if (DecodeSubtree(input + idx, length, subtree, cert->heap) < 0) {\n            WOLFSSL_MSG(\"\\terror parsing subtree\");\n            return ASN_PARSE_E;\n        }\n\n        idx += length;\n    }\n\n    return 0;\n}\n#endif /* IGNORE_NAME_CONSTRAINTS */\n\n#if (defined(WOLFSSL_CERT_EXT) && !defined(WOLFSSL_SEP)) || \\\n    defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)\n\n/* Decode ITU-T X.690 OID format to a string representation\n * return string length */\nint DecodePolicyOID(char *out, word32 outSz, const byte *in, word32 inSz)\n{\n    word32 val, inIdx = 0, outIdx = 0;\n    int w = 0;\n\n    if (out == NULL || in == NULL || outSz < 4 || inSz < 2)\n        return BAD_FUNC_ARG;\n\n    /* The first byte expands into b/40 dot b%40. */\n    val = in[inIdx++];\n\n    w = XSNPRINTF(out, outSz, \"%u.%u\", val / 40, val % 40);\n    if (w < 0) {\n        w = BUFFER_E;\n        goto exit;\n    }\n    outIdx += w;\n    val = 0;\n\n    while (inIdx < inSz && outIdx < outSz) {\n        /* extract the next OID digit from in to val */\n        /* first bit is used to set if value is coded on 1 or multiple bytes */\n        if (in[inIdx] & 0x80) {\n            val += in[inIdx] & 0x7F;\n            val *= 128;\n        }\n        else {\n            /* write val as text into out */\n            val += in[inIdx];\n            w = XSNPRINTF(out + outIdx, outSz - outIdx, \".%u\", val);\n            if (w < 0 || (word32)w > outSz - outIdx) {\n                w = BUFFER_E;\n                goto exit;\n            }\n            outIdx += w;\n            val = 0;\n        }\n        inIdx++;\n    }\n    if (outIdx == outSz)\n        outIdx--;\n    out[outIdx] = 0;\n\n    w = (int)outIdx;\n\nexit:\n    return w;\n}\n#endif /* WOLFSSL_CERT_EXT && !WOLFSSL_SEP */\n\n#if defined(WOLFSSL_SEP) || defined(WOLFSSL_CERT_EXT) || defined(WOLFSSL_QT)\n    /* Reference: https://tools.ietf.org/html/rfc5280#section-4.2.1.4 */\n    static int DecodeCertPolicy(const byte* input, int sz, DecodedCert* cert)\n    {\n        word32 idx = 0;\n        word32 oldIdx;\n        int ret;\n        int total_length = 0, policy_length = 0, length = 0;\n    #if !defined(WOLFSSL_SEP) && defined(WOLFSSL_CERT_EXT) && \\\n        !defined(WOLFSSL_DUP_CERTPOL)\n        int i;\n    #endif\n\n        WOLFSSL_ENTER(\"DecodeCertPolicy\");\n        #if defined(WOLFSSL_SEP) || defined(WOLFSSL_CERT_EXT)\n        /* Check if cert is null before dereferencing below */\n        if (cert == NULL)\n            return BAD_FUNC_ARG;\n        #endif\n\n    #if defined(WOLFSSL_CERT_EXT)\n         cert->extCertPoliciesNb = 0;\n    #endif\n\n        if (GetSequence(input, &idx, &total_length, sz) < 0) {\n            WOLFSSL_MSG(\"\\tGet CertPolicy total seq failed\");\n            return ASN_PARSE_E;\n        }\n\n        /* Validate total length */\n        if (total_length > (sz - (int)idx)) {\n            WOLFSSL_MSG(\"\\tCertPolicy length mismatch\");\n            return ASN_PARSE_E;\n        }\n\n        /* Unwrap certificatePolicies */\n        do {\n            if (GetSequence(input, &idx, &policy_length, sz) < 0) {\n                WOLFSSL_MSG(\"\\tGet CertPolicy seq failed\");\n                return ASN_PARSE_E;\n            }\n\n            oldIdx = idx;\n            ret = GetASNObjectId(input, &idx, &length, sz);\n            if (ret != 0)\n                return ret;\n            policy_length -= idx - oldIdx;\n\n            if (length > 0) {\n                /* Verify length won't overrun buffer */\n                if (length > (sz - (int)idx)) {\n                    WOLFSSL_MSG(\"\\tCertPolicy length exceeds input buffer\");\n                    return ASN_PARSE_E;\n                }\n\n        #if defined(WOLFSSL_SEP)\n                cert->deviceType = (byte*)XMALLOC(length, cert->heap,\n                                                         DYNAMIC_TYPE_X509_EXT);\n                if (cert->deviceType == NULL) {\n                    WOLFSSL_MSG(\"\\tCouldn't alloc memory for deviceType\");\n                    return MEMORY_E;\n                }\n                cert->deviceTypeSz = length;\n                XMEMCPY(cert->deviceType, input + idx, length);\n                break;\n        #elif defined(WOLFSSL_CERT_EXT)\n                /* decode cert policy */\n                if (DecodePolicyOID(cert->extCertPolicies[\n                                       cert->extCertPoliciesNb], MAX_CERTPOL_SZ,\n                                       input + idx, length) <= 0) {\n                    WOLFSSL_MSG(\"\\tCouldn't decode CertPolicy\");\n                    return ASN_PARSE_E;\n                }\n            #ifndef WOLFSSL_DUP_CERTPOL\n                /* From RFC 5280 section 4.2.1.3 \"A certificate policy OID MUST\n                 * NOT appear more than once in a certificate policies\n                 * extension\". This is a sanity check for duplicates.\n                 * extCertPolicies should only have OID values, additional\n                 * qualifiers need to be stored in a separate array. */\n                for (i = 0; i < cert->extCertPoliciesNb; i++) {\n                    if (XMEMCMP(cert->extCertPolicies[i],\n                            cert->extCertPolicies[cert->extCertPoliciesNb],\n                            MAX_CERTPOL_SZ) == 0) {\n                            WOLFSSL_MSG(\"Duplicate policy OIDs not allowed\");\n                            WOLFSSL_MSG(\"Use WOLFSSL_DUP_CERTPOL if wanted\");\n                            return CERTPOLICIES_E;\n                    }\n                }\n            #endif /* !WOLFSSL_DUP_CERTPOL */\n                cert->extCertPoliciesNb++;\n        #else\n                WOLFSSL_LEAVE(\"DecodeCertPolicy : unsupported mode\", 0);\n                return 0;\n        #endif\n            }\n            idx += policy_length;\n        } while((int)idx < total_length\n    #if defined(WOLFSSL_CERT_EXT)\n            && cert->extCertPoliciesNb < MAX_CERTPOL_NB\n    #endif\n        );\n\n        WOLFSSL_LEAVE(\"DecodeCertPolicy\", 0);\n        return 0;\n    }\n#endif /* WOLFSSL_SEP */\n\n/* Macro to check if bit is set, if not sets and return success.\n    Otherwise returns failure */\n/* Macro required here because bit-field operation */\n#ifndef WOLFSSL_NO_ASN_STRICT\n    #define VERIFY_AND_SET_OID(bit) \\\n        if (bit == 0) \\\n            bit = 1; \\\n        else \\\n            return ASN_OBJECT_ID_E;\n#else\n    /* With no strict defined, the verify is skipped */\n#define VERIFY_AND_SET_OID(bit) bit = 1;\n#endif\n\nstatic int DecodeCertExtensions(DecodedCert* cert)\n/*\n *  Processing the Certificate Extensions. This does not modify the current\n *  index. It is works starting with the recorded extensions pointer.\n */\n{\n    int ret = 0;\n    word32 idx = 0;\n    int sz = cert->extensionsSz;\n    const byte* input = cert->extensions;\n    int length;\n    word32 oid;\n    byte critical = 0;\n    byte criticalFail = 0;\n    byte tag = 0;\n\n    WOLFSSL_ENTER(\"DecodeCertExtensions\");\n\n    if (input == NULL || sz == 0)\n        return BAD_FUNC_ARG;\n\n#ifdef WOLFSSL_CERT_REQ\n    if (!cert->isCSR)\n#endif\n    { /* Not included in CSR */\n        if (GetASNTag(input, &idx, &tag, sz) < 0) {\n            return ASN_PARSE_E;\n        }\n\n        if (tag != ASN_EXTENSIONS) {\n            WOLFSSL_MSG(\"\\tfail: should be an EXTENSIONS\");\n            return ASN_PARSE_E;\n        }\n\n        if (GetLength(input, &idx, &length, sz) < 0) {\n            WOLFSSL_MSG(\"\\tfail: invalid length\");\n            return ASN_PARSE_E;\n        }\n    }\n\n    if (GetSequence(input, &idx, &length, sz) < 0) {\n        WOLFSSL_MSG(\"\\tfail: should be a SEQUENCE (1)\");\n        return ASN_PARSE_E;\n    }\n\n    while (idx < (word32)sz) {\n        word32 localIdx;\n\n        if (GetSequence(input, &idx, &length, sz) < 0) {\n            WOLFSSL_MSG(\"\\tfail: should be a SEQUENCE\");\n            return ASN_PARSE_E;\n        }\n\n        oid = 0;\n        if ((ret = GetObjectId(input, &idx, &oid, oidCertExtType, sz)) < 0) {\n            WOLFSSL_MSG(\"\\tfail: OBJECT ID\");\n            return ret;\n        }\n\n        /* check for critical flag */\n        critical = 0;\n        if ((idx + 1) > (word32)sz) {\n            WOLFSSL_MSG(\"\\tfail: malformed buffer\");\n            return BUFFER_E;\n        }\n\n        localIdx = idx;\n        if (GetASNTag(input, &localIdx, &tag, sz) == 0) {\n            if (tag == ASN_BOOLEAN) {\n                ret = GetBoolean(input, &idx, sz);\n                if (ret < 0) {\n                    WOLFSSL_MSG(\"\\tfail: critical boolean\");\n                    return ret;\n                }\n\n                critical = (byte)ret;\n            }\n        }\n\n        /* process the extension based on the OID */\n        ret = GetOctetString(input, &idx, &length, sz);\n        if (ret < 0) {\n            WOLFSSL_MSG(\"\\tfail: bad OCTET STRING\");\n            return ret;\n        }\n\n        switch (oid) {\n            case BASIC_CA_OID:\n                VERIFY_AND_SET_OID(cert->extBasicConstSet);\n                #if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)\n                    cert->extBasicConstCrit = critical;\n                #endif\n                if (DecodeBasicCaConstraint(&input[idx], length, cert) < 0)\n                    return ASN_PARSE_E;\n                break;\n\n            case CRL_DIST_OID:\n                VERIFY_AND_SET_OID(cert->extCRLdistSet);\n                #if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)\n                    cert->extCRLdistCrit = critical;\n                #endif\n                if (DecodeCrlDist(&input[idx], length, cert) < 0)\n                    return ASN_PARSE_E;\n                break;\n\n            case AUTH_INFO_OID:\n                VERIFY_AND_SET_OID(cert->extAuthInfoSet);\n                #if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)\n                    cert->extAuthInfoCrit = critical;\n                #endif\n                if (DecodeAuthInfo(&input[idx], length, cert) < 0)\n                    return ASN_PARSE_E;\n                break;\n\n            case ALT_NAMES_OID:\n                VERIFY_AND_SET_OID(cert->extSubjAltNameSet);\n                #if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)\n                    cert->extSubjAltNameCrit = critical;\n                #endif\n                ret = DecodeAltNames(&input[idx], length, cert);\n                if (ret < 0)\n                    return ret;\n                break;\n\n            case AUTH_KEY_OID:\n                VERIFY_AND_SET_OID(cert->extAuthKeyIdSet);\n                #if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)\n                    cert->extAuthKeyIdCrit = critical;\n                #endif\n                #ifndef WOLFSSL_ALLOW_CRIT_SKID\n                    /* This check is added due to RFC 5280 section 4.2.1.1\n                     * stating that conforming CA's must mark this extension\n                     * as non-critical. When parsing extensions check that\n                     * certificate was made in compliance with this. */\n                    if (critical) {\n                        WOLFSSL_MSG(\"Critical Auth Key ID is not allowed\");\n                        WOLFSSL_MSG(\"Use macro WOLFSSL_ALLOW_CRIT_SKID if wanted\");\n                        return ASN_CRIT_EXT_E;\n                    }\n                #endif\n                if (DecodeAuthKeyId(&input[idx], length, cert) < 0)\n                    return ASN_PARSE_E;\n                break;\n\n            case SUBJ_KEY_OID:\n                VERIFY_AND_SET_OID(cert->extSubjKeyIdSet);\n                #if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)\n                    cert->extSubjKeyIdCrit = critical;\n                #endif\n                #ifndef WOLFSSL_ALLOW_CRIT_SKID\n                    /* This check is added due to RFC 5280 section 4.2.1.2\n                     * stating that conforming CA's must mark this extension\n                     * as non-critical. When parsing extensions check that\n                     * certificate was made in compliance with this. */\n                    if (critical) {\n                        WOLFSSL_MSG(\"Critical Subject Key ID is not allowed\");\n                        WOLFSSL_MSG(\"Use macro WOLFSSL_ALLOW_CRIT_SKID if wanted\");\n                        return ASN_CRIT_EXT_E;\n                    }\n                #endif\n\n                if (DecodeSubjKeyId(&input[idx], length, cert) < 0)\n                    return ASN_PARSE_E;\n                break;\n\n            case CERT_POLICY_OID:\n                #if defined(WOLFSSL_SEP) || defined(WOLFSSL_QT)\n                    VERIFY_AND_SET_OID(cert->extCertPolicySet);\n                    #if defined(OPENSSL_EXTRA) || \\\n                        defined(OPENSSL_EXTRA_X509_SMALL)\n                        cert->extCertPolicyCrit = critical;\n                    #endif\n                #endif\n                #if defined(WOLFSSL_SEP) || defined(WOLFSSL_CERT_EXT) || \\\n                    defined(WOLFSSL_QT)\n                    if (DecodeCertPolicy(&input[idx], length, cert) < 0) {\n                        return ASN_PARSE_E;\n                    }\n                #else\n                    WOLFSSL_MSG(\"Certificate Policy extension not supported yet.\");\n                #endif\n                break;\n\n            case KEY_USAGE_OID:\n                VERIFY_AND_SET_OID(cert->extKeyUsageSet);\n                #if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)\n                    cert->extKeyUsageCrit = critical;\n                #endif\n                if (DecodeKeyUsage(&input[idx], length, cert) < 0)\n                    return ASN_PARSE_E;\n                break;\n\n            case EXT_KEY_USAGE_OID:\n                VERIFY_AND_SET_OID(cert->extExtKeyUsageSet);\n                #if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)\n                    cert->extExtKeyUsageCrit = critical;\n                #endif\n                if (DecodeExtKeyUsage(&input[idx], length, cert) < 0)\n                    return ASN_PARSE_E;\n                break;\n\n            #ifndef IGNORE_NAME_CONSTRAINTS\n            case NAME_CONS_OID:\n            #ifndef WOLFSSL_NO_ASN_STRICT\n                /* Verify RFC 5280 Sec 4.2.1.10 rule:\n                    \"The name constraints extension,\n                    which MUST be used only in a CA certificate\" */\n                if (!cert->isCA) {\n                    WOLFSSL_MSG(\"Name constraints allowed only for CA certs\");\n                    return ASN_NAME_INVALID_E;\n                }\n            #endif\n                VERIFY_AND_SET_OID(cert->extNameConstraintSet);\n                #if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)\n                    cert->extNameConstraintCrit = critical;\n                #endif\n                if (DecodeNameConstraints(&input[idx], length, cert) < 0)\n                    return ASN_PARSE_E;\n                break;\n            #endif /* IGNORE_NAME_CONSTRAINTS */\n\n            case INHIBIT_ANY_OID:\n                VERIFY_AND_SET_OID(cert->inhibitAnyOidSet);\n                WOLFSSL_MSG(\"Inhibit anyPolicy extension not supported yet.\");\n                break;\n\n       #ifndef IGNORE_NETSCAPE_CERT_TYPE\n            case NETSCAPE_CT_OID:\n                WOLFSSL_MSG(\"Netscape certificate type extension not supported \"\n                            \"yet.\");\n                if (CheckBitString(input, &idx, &length, idx + length, 0,\n                                                                    NULL) < 0) {\n                    return ASN_PARSE_E;\n                }\n                break;\n        #endif\n        #ifdef HAVE_OCSP\n            case OCSP_NOCHECK_OID:\n                VERIFY_AND_SET_OID(cert->ocspNoCheckSet);\n                ret = GetASNNull(input, &idx, sz);\n                length = 0; /* idx is already incremented, reset length to 0 */\n                if (ret != 0)\n                    return ASN_PARSE_E;\n                break;\n        #endif\n            case POLICY_CONST_OID:\n                VERIFY_AND_SET_OID(cert->extPolicyConstSet);\n                #if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)\n                    cert->extPolicyConstCrit = critical;\n                #endif\n                if (DecodePolicyConstraints(&input[idx], length, cert) < 0)\n                    return ASN_PARSE_E;\n                break;\n            default:\n            #ifndef WOLFSSL_NO_ASN_STRICT\n                /* While it is a failure to not support critical extensions,\n                 * still parse the certificate ignoring the unsupported\n                 * extension to allow caller to accept it with the verify\n                 * callback. */\n                if (critical)\n                    criticalFail = 1;\n            #endif\n            break;\n        }\n        idx += length;\n    }\n\n    return criticalFail ? ASN_CRIT_EXT_E : 0;\n}\n\nint ParseCert(DecodedCert* cert, int type, int verify, void* cm)\n{\n    int   ret;\n    char* ptr;\n\n    ret = ParseCertRelative(cert, type, verify, cm);\n    if (ret < 0)\n        return ret;\n\n    if (cert->subjectCNLen > 0) {\n        ptr = (char*) XMALLOC(cert->subjectCNLen + 1, cert->heap,\n                              DYNAMIC_TYPE_SUBJECT_CN);\n        if (ptr == NULL)\n            return MEMORY_E;\n        XMEMCPY(ptr, cert->subjectCN, cert->subjectCNLen);\n        ptr[cert->subjectCNLen] = '\\0';\n        cert->subjectCN = ptr;\n        cert->subjectCNStored = 1;\n    }\n\n    if (cert->keyOID == RSAk &&\n                          cert->publicKey != NULL  && cert->pubKeySize > 0) {\n        ptr = (char*) XMALLOC(cert->pubKeySize, cert->heap,\n                              DYNAMIC_TYPE_PUBLIC_KEY);\n        if (ptr == NULL)\n            return MEMORY_E;\n        XMEMCPY(ptr, cert->publicKey, cert->pubKeySize);\n        cert->publicKey = (byte *)ptr;\n        cert->pubKeyStored = 1;\n    }\n\n    return ret;\n}\n\n/* from SSL proper, for locking can't do find here anymore */\n#ifdef __cplusplus\n    extern \"C\" {\n#endif\n    Signer* GetCA(void* signers, byte* hash);\n    #ifndef NO_SKID\n        Signer* GetCAByName(void* signers, byte* hash);\n    #endif\n#ifdef __cplusplus\n    }\n#endif\n\n#if defined(WOLFCRYPT_ONLY) || defined(NO_CERTS)\n\n/* dummy functions, not using wolfSSL so don't need actual ones */\nSigner* GetCA(void* signers, byte* hash)\n{\n    (void)hash;\n\n    return (Signer*)signers;\n}\n\n#ifndef NO_SKID\nSigner* GetCAByName(void* signers, byte* hash)\n{\n    (void)hash;\n\n    return (Signer*)signers;\n}\n#endif /* NO_SKID */\n\n#endif /* WOLFCRYPT_ONLY || NO_CERTS */\n\n#if defined(WOLFSSL_NO_TRUSTED_CERTS_VERIFY) && !defined(NO_SKID)\nstatic Signer* GetCABySubjectAndPubKey(DecodedCert* cert, void* cm)\n{\n    Signer* ca = NULL;\n    if (cert->extSubjKeyIdSet)\n        ca = GetCA(cm, cert->extSubjKeyId);\n    if (ca == NULL)\n        ca = GetCAByName(cm, cert->subjectHash);\n    if (ca) {\n        if ((ca->pubKeySize == cert->pubKeySize) &&\n               (XMEMCMP(ca->publicKey, cert->publicKey, ca->pubKeySize) == 0)) {\n            return ca;\n        }\n    }\n    return NULL;\n}\n#endif\n\n#if defined(WOLFSSL_SMALL_CERT_VERIFY) || defined(OPENSSL_EXTRA)\n/* Only quick step through the certificate to find fields that are then used\n * in certificate signature verification.\n * Must use the signature OID from the signed part of the certificate.\n * Works also on certificate signing requests.\n *\n * This is only for minimizing dynamic memory usage during TLS certificate\n * chain processing.\n * Doesn't support:\n *   OCSP Only: alt lookup using subject and pub key w/o sig check\n */\nstatic int CheckCertSignature_ex(const byte* cert, word32 certSz, void* heap,\n        void* cm, const byte* pubKey, word32 pubKeySz, int pubKeyOID, int req)\n{\n#ifndef WOLFSSL_SMALL_STACK\n    SignatureCtx  sigCtx[1];\n#else\n    SignatureCtx* sigCtx;\n#endif\n    byte          hash[KEYID_SIZE];\n    Signer*       ca = NULL;\n    word32        idx = 0;\n    int           len;\n    word32        tbsCertIdx = 0;\n    word32        sigIndex   = 0;\n    word32        signatureOID = 0;\n    word32        oid = 0;\n    word32        issuerIdx = 0;\n    word32        issuerSz  = 0;\n#ifndef NO_SKID\n    int           extLen = 0;\n    word32        extIdx = 0;\n    word32        extEndIdx = 0;\n    int           extAuthKeyIdSet = 0;\n#endif\n    int           ret = 0;\n    word32        localIdx;\n    byte          tag;\n\n\n    if (cert == NULL) {\n        return BAD_FUNC_ARG;\n    }\n\n#ifdef WOLFSSL_SMALL_STACK\n    sigCtx = (SignatureCtx*)XMALLOC(sizeof(*sigCtx), heap, DYNAMIC_TYPE_SIGNATURE);\n    if (sigCtx == NULL)\n        return MEMORY_E;\n#endif\n    InitSignatureCtx(sigCtx, heap, INVALID_DEVID);\n\n    /* Certificate SEQUENCE */\n    if (GetSequence(cert, &idx, &len, certSz) < 0)\n        ret = ASN_PARSE_E;\n    if (ret == 0) {\n        tbsCertIdx = idx;\n\n        /* TBSCertificate SEQUENCE */\n        if (GetSequence(cert, &idx, &len, certSz) < 0)\n            ret = ASN_PARSE_E;\n    }\n    if (ret == 0) {\n        sigIndex = len + idx;\n\n        if ((idx + 1) > certSz)\n            ret = BUFFER_E;\n    }\n    if (ret == 0) {\n        /* version - optional */\n        localIdx = idx;\n        if (GetASNTag(cert, &localIdx, &tag, certSz) == 0) {\n            if (tag == (ASN_CONTEXT_SPECIFIC | ASN_CONSTRUCTED)) {\n                idx++;\n                if (GetLength(cert, &idx, &len, certSz) < 0)\n                    ret = ASN_PARSE_E;\n                idx += len;\n            }\n        }\n    }\n\n    if (ret == 0) {\n        /* serialNumber */\n        if (GetASNHeader(cert, ASN_INTEGER, &idx, &len, certSz) < 0)\n            ret = ASN_PARSE_E;\n    }\n    if (ret == 0) {\n        idx += len;\n\n        /* signature */\n        if (!req &&\n                GetAlgoId(cert, &idx, &signatureOID, oidSigType, certSz) < 0)\n            ret = ASN_PARSE_E;\n    }\n\n    if (ret == 0) {\n        issuerIdx = idx;\n        /* issuer for cert or subject for csr */\n        if (GetSequence(cert, &idx, &len, certSz) < 0)\n            ret = ASN_PARSE_E;\n    }\n    if (ret == 0) {\n        issuerSz = len + idx - issuerIdx;\n    }\n#ifndef NO_SKID\n    if (!req && ret == 0) {\n        idx += len;\n\n        /* validity */\n        if (GetSequence(cert, &idx, &len, certSz) < 0)\n            ret = ASN_PARSE_E;\n    }\n    if (!req && ret == 0) {\n        idx += len;\n\n        /* subject */\n        if (GetSequence(cert, &idx, &len, certSz) < 0)\n            ret = ASN_PARSE_E;\n    }\n    if (ret == 0) {\n        idx += len;\n\n        /* subjectPublicKeyInfo */\n        if (GetSequence(cert, &idx, &len, certSz) < 0)\n            ret = ASN_PARSE_E;\n    }\n    if (req && ret == 0) {\n        idx += len;\n\n        /* attributes */\n        if (GetASNHeader_ex(cert,\n                ASN_CONTEXT_SPECIFIC | ASN_CONSTRUCTED, &idx,\n                &len, certSz, 1) < 0)\n            ret = ASN_PARSE_E;\n    }\n    if (!req) {\n        if (ret == 0) {\n            idx += len;\n\n            if ((idx + 1) > certSz)\n                ret = BUFFER_E;\n        }\n        if (ret == 0) {\n            /* issuerUniqueID - optional */\n            localIdx = idx;\n            if (GetASNTag(cert, &localIdx, &tag, certSz) == 0) {\n                if (tag == (ASN_CONTEXT_SPECIFIC | ASN_CONSTRUCTED | 1)) {\n                    idx++;\n                    if (GetLength(cert, &idx, &len, certSz) < 0)\n                        ret = ASN_PARSE_E;\n                    idx += len;\n                }\n            }\n        }\n        if (ret == 0) {\n            if ((idx + 1) > certSz)\n                ret = BUFFER_E;\n        }\n        if (ret == 0) {\n            /* subjectUniqueID - optional */\n            localIdx = idx;\n            if (GetASNTag(cert, &localIdx, &tag, certSz) == 0) {\n                if (tag == (ASN_CONTEXT_SPECIFIC | ASN_CONSTRUCTED | 2)) {\n                    idx++;\n                    if (GetLength(cert, &idx, &len, certSz) < 0)\n                        ret = ASN_PARSE_E;\n                    idx += len;\n                }\n            }\n        }\n\n        if (ret == 0) {\n            if ((idx + 1) > certSz)\n                ret = BUFFER_E;\n        }\n        /* extensions - optional */\n        localIdx = idx;\n        if (ret == 0 && GetASNTag(cert, &localIdx, &tag, certSz) == 0 &&\n                tag == (ASN_CONTEXT_SPECIFIC | ASN_CONSTRUCTED | 3)) {\n            idx++;\n            if (GetLength(cert, &idx, &extLen, certSz) < 0)\n                ret = ASN_PARSE_E;\n            if (ret == 0) {\n                if (GetSequence(cert, &idx, &extLen, certSz) < 0)\n                    ret = ASN_PARSE_E;\n            }\n            if (ret == 0) {\n                extEndIdx = idx + extLen;\n\n                /* Check each extension for the ones we want. */\n                while (ret == 0 && idx < extEndIdx) {\n                    if (GetSequence(cert, &idx, &len, certSz) < 0)\n                        ret = ASN_PARSE_E;\n                    if (ret == 0) {\n                        extIdx = idx;\n                        if (GetObjectId(cert, &extIdx, &oid, oidCertExtType,\n                                                                      certSz) < 0) {\n                            ret = ASN_PARSE_E;\n                        }\n\n                        if (ret == 0) {\n                            if ((extIdx + 1) > certSz)\n                                ret = BUFFER_E;\n                        }\n                    }\n\n                    if (ret == 0) {\n                        localIdx = extIdx;\n                        if (GetASNTag(cert, &localIdx, &tag, certSz) == 0 &&\n                                tag == ASN_BOOLEAN) {\n                            if (GetBoolean(cert, &extIdx, certSz) < 0)\n                                ret = ASN_PARSE_E;\n                        }\n                    }\n                    if (ret == 0) {\n                        if (GetOctetString(cert, &extIdx, &extLen, certSz) < 0)\n                            ret = ASN_PARSE_E;\n                    }\n\n                    if (ret == 0) {\n                        switch (oid) {\n                        case AUTH_KEY_OID:\n                            if (GetSequence(cert, &extIdx, &extLen, certSz) < 0)\n                                ret = ASN_PARSE_E;\n\n                            if (ret == 0 && (extIdx + 1) >= certSz)\n                                ret = BUFFER_E;\n\n                            if (ret == 0 &&\n                                    GetASNTag(cert, &extIdx, &tag, certSz) == 0 &&\n                                    tag == (ASN_CONTEXT_SPECIFIC | 0)) {\n                                if (GetLength(cert, &extIdx, &extLen, certSz) <= 0)\n                                    ret = ASN_PARSE_E;\n                                if (ret == 0) {\n                                    extAuthKeyIdSet = 1;\n                                    if (extLen == KEYID_SIZE)\n                                        XMEMCPY(hash, cert + extIdx, extLen);\n                                    else {\n                                        ret = CalcHashId(cert + extIdx, extLen,\n                                                                              hash);\n                                    }\n                                }\n                            }\n                            break;\n\n                        default:\n                            break;\n                        }\n                    }\n                    idx += len;\n                }\n            }\n        }\n    }\n    else if (ret == 0) {\n        idx += len;\n    }\n\n    if (ret == 0 && pubKey == NULL) {\n        if (extAuthKeyIdSet)\n            ca = GetCA(cm, hash);\n        if (ca == NULL) {\n            ret = CalcHashId(cert + issuerIdx, issuerSz, hash);\n            if (ret == 0)\n                ca = GetCAByName(cm, hash);\n        }\n    }\n#else\n    if (ret == 0 && pubKey == NULL) {\n        ret = CalcHashId(cert + issuerIdx, issuerSz, hash);\n        if (ret == 0)\n            ca = GetCA(cm, hash);\n    }\n#endif /* !NO_SKID */\n    if (ca == NULL && pubKey == NULL)\n        ret = ASN_NO_SIGNER_E;\n\n    if (ret == 0) {\n        idx = sigIndex;\n        /* signatureAlgorithm */\n        if (GetAlgoId(cert, &idx, &oid, oidSigType, certSz) < 0)\n            ret = ASN_PARSE_E;\n        /* In CSR signature data is not present in body */\n        if (req)\n            signatureOID = oid;\n    }\n    if (ret == 0) {\n        if (oid != signatureOID)\n            ret = ASN_SIG_OID_E;\n    }\n    if (ret == 0) {\n        /* signatureValue */\n        if (CheckBitString(cert, &idx, &len, certSz, 1, NULL) < 0)\n            ret = ASN_PARSE_E;\n    }\n\n    if (ret == 0) {\n        if (pubKey != NULL) {\n            ret = ConfirmSignature(sigCtx, cert + tbsCertIdx,\n                               sigIndex - tbsCertIdx,\n                               pubKey, pubKeySz, pubKeyOID,\n                               cert + idx, len, signatureOID, NULL);\n        }\n        else {\n            ret = ConfirmSignature(sigCtx, cert + tbsCertIdx,\n                               sigIndex - tbsCertIdx,\n                               ca->publicKey, ca->pubKeySize, ca->keyOID,\n                               cert + idx, len, signatureOID, NULL);\n        }\n        if (ret != 0) {\n            WOLFSSL_MSG(\"Confirm signature failed\");\n        }\n    }\n\n    FreeSignatureCtx(sigCtx);\n#ifdef WOLFSSL_SMALL_STACK\n    if (sigCtx != NULL)\n        XFREE(sigCtx, heap, DYNAMIC_TYPE_SIGNATURE);\n#endif\n    return ret;\n}\n\n#ifdef OPENSSL_EXTRA\n/* Call CheckCertSignature_ex using a public key buffer for verification\n */\nint CheckCertSignaturePubKey(const byte* cert, word32 certSz, void* heap,\n        const byte* pubKey, word32 pubKeySz, int pubKeyOID)\n{\n    return CheckCertSignature_ex(cert, certSz, heap, NULL,\n            pubKey, pubKeySz, pubKeyOID, 0);\n}\n#ifdef WOLFSSL_CERT_REQ\nint CheckCSRSignaturePubKey(const byte* cert, word32 certSz, void* heap,\n        const byte* pubKey, word32 pubKeySz, int pubKeyOID)\n{\n    return CheckCertSignature_ex(cert, certSz, heap, NULL,\n            pubKey, pubKeySz, pubKeyOID, 1);\n}\n#endif /* WOLFSSL_CERT_REQ */\n#endif /* OPENSSL_EXTRA */\n#ifdef WOLFSSL_SMALL_CERT_VERIFY\n/* Call CheckCertSignature_ex using a certificate manager (cm)\n */\nint CheckCertSignature(const byte* cert, word32 certSz, void* heap, void* cm)\n{\n    return CheckCertSignature_ex(cert, certSz, heap, cm, NULL, 0, 0, 0);\n}\n#endif /* WOLFSSL_SMALL_CERT_VERIFY */\n#endif /* WOLFSSL_SMALL_CERT_VERIFY || OPENSSL_EXTRA */\n\nint ParseCertRelative(DecodedCert* cert, int type, int verify, void* cm)\n{\n    int    ret = 0;\n    int    checkPathLen = 0;\n    int    decrementMaxPathLen = 0;\n    word32 confirmOID = 0;\n#if defined(WOLFSSL_RENESAS_TSIP)\n    int    idx = 0;\n#endif\n    byte*  tsip_encRsaKeyIdx;\n#ifdef WOLFSSL_CERT_REQ\n    int    len = 0;\n#endif\n\n    if (cert == NULL) {\n        return BAD_FUNC_ARG;\n    }\n\n#ifdef WOLFSSL_CERT_REQ\n    if (type == CERTREQ_TYPE)\n        cert->isCSR = 1;\n#endif\n\n    if (cert->sigCtx.state == SIG_STATE_BEGIN) {\n        cert->badDate = 0;\n        cert->criticalExt = 0;\n        if ((ret = DecodeToKey(cert, verify)) < 0) {\n            if (ret == ASN_BEFORE_DATE_E || ret == ASN_AFTER_DATE_E)\n                cert->badDate = ret;\n            else\n                return ret;\n        }\n\n        WOLFSSL_MSG(\"Parsed Past Key\");\n\n\n#ifdef WOLFSSL_CERT_REQ\n        /* Read attributes */\n        if (cert->isCSR) {\n            if (GetASNHeader_ex(cert->source,\n                    ASN_CONTEXT_SPECIFIC | ASN_CONSTRUCTED, &cert->srcIdx,\n                    &len, cert->maxIdx, 1) < 0) {\n                WOLFSSL_MSG(\"GetASNHeader_ex error\");\n                return ASN_PARSE_E;\n            }\n\n            if (len) {\n                word32 attrMaxIdx = cert->srcIdx + len;\n                word32 oid;\n                byte   tag;\n\n                if (attrMaxIdx > cert->maxIdx) {\n                    WOLFSSL_MSG(\"Attribute length greater than CSR length\");\n                    return ASN_PARSE_E;\n                }\n\n                while (cert->srcIdx < attrMaxIdx) {\n                    /* Attributes have the structure:\n                     * SEQ -> OID -> SET -> ATTRIBUTE */\n                    if (GetSequence(cert->source, &cert->srcIdx, &len,\n                            attrMaxIdx) < 0) {\n                        WOLFSSL_MSG(\"attr GetSequence error\");\n                        return ASN_PARSE_E;\n                    }\n                    if (GetObjectId(cert->source, &cert->srcIdx, &oid,\n                            oidCsrAttrType, attrMaxIdx) < 0) {\n                        WOLFSSL_MSG(\"attr GetObjectId error\");\n                        return ASN_PARSE_E;\n                    }\n                    if (GetSet(cert->source, &cert->srcIdx, &len,\n                            attrMaxIdx) < 0) {\n                        WOLFSSL_MSG(\"attr GetSet error\");\n                        return ASN_PARSE_E;\n                    }\n                    switch (oid) {\n                    case CHALLENGE_PASSWORD_OID:\n                        if (GetHeader(cert->source, &tag,\n                                &cert->srcIdx, &len, attrMaxIdx, 1) < 0) {\n                            WOLFSSL_MSG(\"attr GetHeader error\");\n                            return ASN_PARSE_E;\n                        }\n                        if (tag != ASN_PRINTABLE_STRING && tag != ASN_UTF8STRING &&\n                                tag != ASN_IA5_STRING) {\n                            WOLFSSL_MSG(\"Unsupported attribute value format\");\n                            return ASN_PARSE_E;\n                        }\n                        cert->cPwd = (char*)cert->source + cert->srcIdx;\n                        cert->cPwdLen = len;\n                        cert->srcIdx += len;\n                        break;\n                    case SERIAL_NUMBER_OID:\n                        if (GetHeader(cert->source, &tag,\n                                &cert->srcIdx, &len, attrMaxIdx, 1) < 0) {\n                            WOLFSSL_MSG(\"attr GetHeader error\");\n                            return ASN_PARSE_E;\n                        }\n                        if (tag != ASN_PRINTABLE_STRING && tag != ASN_UTF8STRING &&\n                                tag != ASN_IA5_STRING) {\n                            WOLFSSL_MSG(\"Unsupported attribute value format\");\n                            return ASN_PARSE_E;\n                        }\n                        cert->sNum = (char*)cert->source + cert->srcIdx;\n                        cert->sNumLen = len;\n                        cert->srcIdx += len;\n                        if (cert->sNumLen <= EXTERNAL_SERIAL_SIZE) {\n                            XMEMCPY(cert->serial, cert->sNum, cert->sNumLen);\n                            cert->serialSz = cert->sNumLen;\n                        }\n                        break;\n                    case EXTENSION_REQUEST_OID:\n                        /* save extensions */\n                        cert->extensions    = &cert->source[cert->srcIdx];\n                        cert->extensionsSz  = len;\n                        cert->extensionsIdx = cert->srcIdx;   /* for potential later use */\n\n                        if ((ret = DecodeCertExtensions(cert)) < 0) {\n                            if (ret == ASN_CRIT_EXT_E)\n                                cert->criticalExt = ret;\n                            else\n                                return ret;\n                        }\n                        cert->srcIdx += len;\n                        break;\n                    default:\n                        WOLFSSL_MSG(\"Unsupported attribute type\");\n                        return ASN_PARSE_E;\n                    }\n                }\n            }\n        }\n#endif\n\n        if (cert->srcIdx < cert->sigIndex) {\n        #ifndef ALLOW_V1_EXTENSIONS\n            if (cert->version < 2) {\n                WOLFSSL_MSG(\"\\tv1 and v2 certs not allowed extensions\");\n                return ASN_VERSION_E;\n            }\n        #endif\n\n            /* save extensions */\n            cert->extensions    = &cert->source[cert->srcIdx];\n            cert->extensionsSz  = cert->sigIndex - cert->srcIdx;\n            cert->extensionsIdx = cert->srcIdx;   /* for potential later use */\n\n            if ((ret = DecodeCertExtensions(cert)) < 0) {\n                if (ret == ASN_CRIT_EXT_E)\n                    cert->criticalExt = ret;\n                else\n                    return ret;\n            }\n\n        #ifdef HAVE_OCSP\n            /* trust for the lifetime of the responder's cert*/\n            if (cert->ocspNoCheckSet && verify == VERIFY_OCSP)\n                verify = NO_VERIFY;\n        #endif\n            /* advance past extensions */\n            cert->srcIdx = cert->sigIndex;\n        }\n\n        if ((ret = GetAlgoId(cert->source, &cert->srcIdx,\n#ifdef WOLFSSL_CERT_REQ\n                !cert->isCSR ? &confirmOID : &cert->signatureOID,\n#else\n                &confirmOID,\n#endif\n                oidSigType, cert->maxIdx)) < 0)\n            return ret;\n\n        if ((ret = GetSignature(cert)) < 0)\n            return ret;\n\n        if (confirmOID != cert->signatureOID\n#ifdef WOLFSSL_CERT_REQ\n                && !cert->isCSR\n#endif\n                )\n            return ASN_SIG_OID_E;\n\n    #ifndef NO_SKID\n        if (cert->extSubjKeyIdSet == 0 && cert->publicKey != NULL &&\n                                                         cert->pubKeySize > 0) {\n            ret = CalcHashId(cert->publicKey, cert->pubKeySize,\n                                                            cert->extSubjKeyId);\n            if (ret != 0)\n                return ret;\n        }\n    #endif /* !NO_SKID */\n\n        if (!cert->selfSigned || (verify != NO_VERIFY && type != CA_TYPE &&\n                                                   type != TRUSTED_PEER_TYPE)) {\n            cert->ca = NULL;\n    #ifndef NO_SKID\n            if (cert->extAuthKeyIdSet) {\n                cert->ca = GetCA(cm, cert->extAuthKeyId);\n            }\n            if (cert->ca == NULL && cert->extSubjKeyIdSet\n                                 && verify != VERIFY_OCSP) {\n                cert->ca = GetCA(cm, cert->extSubjKeyId);\n            }\n            if (cert->ca != NULL && XMEMCMP(cert->issuerHash,\n                                  cert->ca->subjectNameHash, KEYID_SIZE) != 0) {\n                cert->ca = NULL;\n            }\n            if (cert->ca == NULL) {\n                cert->ca = GetCAByName(cm, cert->issuerHash);\n                /* If AKID is available then this CA doesn't have the public\n                 * key required */\n                if (cert->ca && cert->extAuthKeyIdSet) {\n                    WOLFSSL_MSG(\"CA SKID doesn't match AKID\");\n                    cert->ca = NULL;\n                }\n            }\n\n            /* OCSP Only: alt lookup using subject and pub key w/o sig check */\n        #ifdef WOLFSSL_NO_TRUSTED_CERTS_VERIFY\n            if (cert->ca == NULL && verify == VERIFY_OCSP) {\n                cert->ca = GetCABySubjectAndPubKey(cert, cm);\n                if (cert->ca) {\n                    ret = 0; /* success */\n                    goto exit_pcr;\n                }\n            }\n        #endif /* WOLFSSL_NO_TRUSTED_CERTS_VERIFY */\n    #else\n            cert->ca = GetCA(cm, cert->issuerHash);\n    #endif /* !NO_SKID */\n\n            if (cert->ca) {\n                WOLFSSL_MSG(\"CA found\");\n            }\n        }\n\n        if (cert->selfSigned) {\n            cert->maxPathLen = WOLFSSL_MAX_PATH_LEN;\n        } else {\n            /* RFC 5280 Section 4.2.1.9:\n             *\n             * load/receive check\n             *\n             * 1) Is CA boolean set?\n             *      No  - SKIP CHECK\n             *      Yes - Check key usage\n             * 2) Is Key usage extension present?\n             *      No  - goto 3\n             *      Yes - check keyCertSign assertion\n             *     2.a) Is keyCertSign asserted?\n             *          No  - goto 4\n             *          Yes - goto 3\n             * 3) Is pathLen set?\n             *      No  - goto 4\n             *      Yes - check pathLen against maxPathLen.\n             *      3.a) Is pathLen less than maxPathLen?\n             *           No - goto 4\n             *           Yes - set maxPathLen to pathLen and EXIT\n             * 4) Is maxPathLen > 0?\n             *      Yes - Reduce by 1\n             *      No  - ERROR\n             */\n\n            if (cert->ca && cert->pathLengthSet) {\n                cert->maxPathLen = cert->pathLength;\n                if (cert->isCA) {\n                    WOLFSSL_MSG(\"\\tCA boolean set\");\n                    if (cert->extKeyUsageSet) {\n                         WOLFSSL_MSG(\"\\tExtension Key Usage Set\");\n                         if ((cert->extKeyUsage & KEYUSE_KEY_CERT_SIGN) != 0) {\n                            checkPathLen = 1;\n                         } else {\n                            decrementMaxPathLen = 1;\n                         }\n                    } else {\n                        checkPathLen = 1;\n                    } /* !cert->ca check */\n                } /* cert is not a CA (assuming entity cert) */\n\n                if (checkPathLen && cert->pathLengthSet) {\n                    if (cert->pathLength < cert->ca->maxPathLen) {\n                        WOLFSSL_MSG(\"\\tmaxPathLen status: set to pathLength\");\n                        cert->maxPathLen = cert->pathLength;\n                    } else {\n                        decrementMaxPathLen = 1;\n                    }\n                }\n\n                if (decrementMaxPathLen && cert->ca->maxPathLen > 0) {\n                    WOLFSSL_MSG(\"\\tmaxPathLen status: reduce by 1\");\n                    cert->maxPathLen = cert->ca->maxPathLen - 1;\n                    if (verify != NO_VERIFY && type != CA_TYPE &&\n                                                    type != TRUSTED_PEER_TYPE) {\n                        WOLFSSL_MSG(\"\\tmaxPathLen status: OK\");\n                    }\n                } else if (decrementMaxPathLen && cert->ca->maxPathLen == 0) {\n                    cert->maxPathLen = 0;\n                    if (verify != NO_VERIFY && type != CA_TYPE &&\n                                                    type != TRUSTED_PEER_TYPE) {\n                        WOLFSSL_MSG(\"\\tNon-entity cert, maxPathLen is 0\");\n                        WOLFSSL_MSG(\"\\tmaxPathLen status: ERROR\");\n                        return ASN_PATHLEN_INV_E;\n                    }\n                }\n            } else if (cert->ca && cert->isCA) {\n                /* case where cert->pathLength extension is not set */\n                if (cert->ca->maxPathLen > 0) {\n                    cert->maxPathLen = cert->ca->maxPathLen - 1;\n                } else {\n                    cert->maxPathLen = 0;\n                    if (verify != NO_VERIFY && type != CA_TYPE &&\n                                                    type != TRUSTED_PEER_TYPE) {\n                        WOLFSSL_MSG(\"\\tNon-entity cert, maxPathLen is 0\");\n                        WOLFSSL_MSG(\"\\tmaxPathLen status: ERROR\");\n                        return ASN_PATHLEN_INV_E;\n                    }\n                }\n            }\n        }\n\n        #ifdef HAVE_OCSP\n        if (verify != NO_VERIFY && type != CA_TYPE &&\n                                                type != TRUSTED_PEER_TYPE) {\n            if (cert->ca) {\n                /* Need the CA's public key hash for OCSP */\n                XMEMCPY(cert->issuerKeyHash, cert->ca->subjectKeyHash,\n                                                                KEYID_SIZE);\n            }\n        }\n        #endif /* HAVE_OCSP */\n    }\n#if defined(WOLFSSL_RENESAS_TSIP)\n    /* prepare for TSIP TLS cert verification API use */\n    if (cert->keyOID == RSAk) {\n        /* to call TSIP API, it needs keys position info in bytes */\n        if ((ret = RsaPublicKeyDecodeRawIndex(cert->publicKey, (word32*)&idx,\n                                   cert->pubKeySize,\n                                   &cert->sigCtx.pubkey_n_start,\n                                   &cert->sigCtx.pubkey_n_len,\n                                   &cert->sigCtx.pubkey_e_start,\n                                   &cert->sigCtx.pubkey_e_len)) != 0) {\n            WOLFSSL_MSG(\"Decoding index from cert failed.\");\n            return ret;\n        }\n        cert->sigCtx.certBegin = cert->certBegin;\n    }\n    /* check if we can use TSIP for cert verification */\n    /* if the ca is verified as tsip root ca.         */\n    /* TSIP can only handle 2048 bits(256 byte) key.  */\n    if (cert->ca && tsip_checkCA(cert->ca->cm_idx) != 0 &&\n        cert->sigCtx.pubkey_n_len == 256) {\n\n        /* assign memory to encrypted tsip Rsa key index */\n        if (!cert->tsip_encRsaKeyIdx)\n            cert->tsip_encRsaKeyIdx =\n                            (byte*)XMALLOC(TSIP_TLS_ENCPUBKEY_SZ_BY_CERTVRFY,\n                             cert->heap, DYNAMIC_TYPE_RSA);\n        if (cert->tsip_encRsaKeyIdx == NULL)\n                return MEMORY_E;\n    } else {\n        if (cert->ca) {\n            /* TSIP isn't usable */\n            if (tsip_checkCA(cert->ca->cm_idx) == 0)\n                WOLFSSL_MSG(\"TSIP isn't usable because the ca isn't verified \"\n                            \"by TSIP.\");\n            else if (cert->sigCtx.pubkey_n_len != 256)\n                WOLFSSL_MSG(\"TSIP isn't usable because the ca isn't signed by \"\n                            \"RSA 2048.\");\n            else\n                WOLFSSL_MSG(\"TSIP isn't usable\");\n        }\n        cert->tsip_encRsaKeyIdx = NULL;\n    }\n\n    tsip_encRsaKeyIdx = cert->tsip_encRsaKeyIdx;\n#else\n    tsip_encRsaKeyIdx = NULL;\n#endif\n\n    if (verify != NO_VERIFY && type != CA_TYPE && type != TRUSTED_PEER_TYPE) {\n        if (cert->ca) {\n            if (verify == VERIFY || verify == VERIFY_OCSP ||\n                                                 verify == VERIFY_SKIP_DATE) {\n                /* try to confirm/verify signature */\n                if ((ret = ConfirmSignature(&cert->sigCtx,\n                        cert->source + cert->certBegin,\n                        cert->sigIndex - cert->certBegin,\n                        cert->ca->publicKey, cert->ca->pubKeySize,\n                        cert->ca->keyOID, cert->signature,\n                        cert->sigLength, cert->signatureOID,\n                        tsip_encRsaKeyIdx)) != 0) {\n                    if (ret != WC_PENDING_E) {\n                        WOLFSSL_MSG(\"Confirm signature failed\");\n                    }\n                    return ret;\n                }\n            }\n        #ifndef IGNORE_NAME_CONSTRAINTS\n            if (verify == VERIFY || verify == VERIFY_OCSP ||\n                        verify == VERIFY_NAME || verify == VERIFY_SKIP_DATE) {\n                /* check that this cert's name is permitted by the signer's\n                 * name constraints */\n                if (!ConfirmNameConstraints(cert->ca, cert)) {\n                    WOLFSSL_MSG(\"Confirm name constraint failed\");\n                    return ASN_NAME_INVALID_E;\n                }\n            }\n        #endif /* IGNORE_NAME_CONSTRAINTS */\n        }\n        else {\n            /* no signer */\n            WOLFSSL_MSG(\"No CA signer to verify with\");\n            return ASN_NO_SIGNER_E;\n        }\n    }\n\n#if defined(WOLFSSL_NO_TRUSTED_CERTS_VERIFY) && !defined(NO_SKID)\nexit_pcr:\n#endif\n\n    if (cert->badDate != 0) {\n        if (verify != VERIFY_SKIP_DATE) {\n            return cert->badDate;\n        }\n        WOLFSSL_MSG(\"Date error: Verify option is skipping\");\n    }\n\n    if (cert->criticalExt != 0)\n        return cert->criticalExt;\n\n    return ret;\n}\n\n/* Create and init an new signer */\nSigner* MakeSigner(void* heap)\n{\n    Signer* signer = (Signer*) XMALLOC(sizeof(Signer), heap,\n                                       DYNAMIC_TYPE_SIGNER);\n    if (signer) {\n        XMEMSET(signer, 0, sizeof(Signer));\n    }\n    (void)heap;\n\n    return signer;\n}\n\n\n/* Free an individual signer */\nvoid FreeSigner(Signer* signer, void* heap)\n{\n    XFREE(signer->name, heap, DYNAMIC_TYPE_SUBJECT_CN);\n    XFREE((void*)signer->publicKey, heap, DYNAMIC_TYPE_PUBLIC_KEY);\n#ifndef IGNORE_NAME_CONSTRAINTS\n    if (signer->permittedNames)\n        FreeNameSubtrees(signer->permittedNames, heap);\n    if (signer->excludedNames)\n        FreeNameSubtrees(signer->excludedNames, heap);\n#endif\n#ifdef WOLFSSL_SIGNER_DER_CERT\n    FreeDer(&signer->derCert);\n#endif\n    XFREE(signer, heap, DYNAMIC_TYPE_SIGNER);\n\n    (void)heap;\n}\n\n\n/* Free the whole singer table with number of rows */\nvoid FreeSignerTable(Signer** table, int rows, void* heap)\n{\n    int i;\n\n    for (i = 0; i < rows; i++) {\n        Signer* signer = table[i];\n        while (signer) {\n            Signer* next = signer->next;\n            FreeSigner(signer, heap);\n            signer = next;\n        }\n        table[i] = NULL;\n    }\n}\n\n#ifdef WOLFSSL_TRUST_PEER_CERT\n/* Free an individual trusted peer cert */\nvoid FreeTrustedPeer(TrustedPeerCert* tp, void* heap)\n{\n    if (tp == NULL) {\n        return;\n    }\n\n    if (tp->name) {\n        XFREE(tp->name, heap, DYNAMIC_TYPE_SUBJECT_CN);\n    }\n\n    if (tp->sig) {\n        XFREE(tp->sig, heap, DYNAMIC_TYPE_SIGNATURE);\n    }\n#ifndef IGNORE_NAME_CONSTRAINTS\n    if (tp->permittedNames)\n        FreeNameSubtrees(tp->permittedNames, heap);\n    if (tp->excludedNames)\n        FreeNameSubtrees(tp->excludedNames, heap);\n#endif\n    XFREE(tp, heap, DYNAMIC_TYPE_CERT);\n\n    (void)heap;\n}\n\n/* Free the whole Trusted Peer linked list */\nvoid FreeTrustedPeerTable(TrustedPeerCert** table, int rows, void* heap)\n{\n    int i;\n\n    for (i = 0; i < rows; i++) {\n        TrustedPeerCert* tp = table[i];\n        while (tp) {\n            TrustedPeerCert* next = tp->next;\n            FreeTrustedPeer(tp, heap);\n            tp = next;\n        }\n        table[i] = NULL;\n    }\n}\n#endif /* WOLFSSL_TRUST_PEER_CERT */\n\nint SetMyVersion(word32 version, byte* output, int header)\n{\n    int i = 0;\n\n    if (output == NULL)\n        return BAD_FUNC_ARG;\n\n    if (header) {\n        output[i++] = ASN_CONTEXT_SPECIFIC | ASN_CONSTRUCTED;\n        output[i++] = 3;\n    }\n    output[i++] = ASN_INTEGER;\n    output[i++] = 0x01;\n    output[i++] = (byte)version;\n\n    return i;\n}\n\nint SetSerialNumber(const byte* sn, word32 snSz, byte* output,\n    word32 outputSz, int maxSnSz)\n{\n    int i;\n    int snSzInt = (int)snSz;\n\n    if (sn == NULL || output == NULL || snSzInt < 0)\n        return BAD_FUNC_ARG;\n\n    /* remove leading zeros */\n    while (snSzInt > 0 && sn[0] == 0) {\n        snSzInt--;\n        sn++;\n    }\n    /* RFC 5280 - 4.1.2.2:\n     *   Serial numbers must be a positive value (and not zero) */\n    if (snSzInt == 0)\n        return BAD_FUNC_ARG;\n\n    if (sn[0] & 0x80)\n        maxSnSz--;\n    /* truncate if input is too long */\n    if (snSzInt > maxSnSz)\n        snSzInt = maxSnSz;\n\n    i = SetASNInt(snSzInt, sn[0], NULL);\n    /* truncate if input is too long */\n    if (snSzInt > (int)outputSz - i)\n        snSzInt = (int)outputSz - i;\n    /* sanity check number of bytes to copy */\n    if (snSzInt <= 0) {\n        return BUFFER_E;\n    }\n\n    /* write out ASN.1 Integer */\n    (void)SetASNInt(snSzInt, sn[0], output);\n    XMEMCPY(output + i, sn, snSzInt);\n\n    /* compute final length */\n    i += snSzInt;\n\n    return i;\n}\n\n#endif /* !NO_CERTS */\n\nint GetSerialNumber(const byte* input, word32* inOutIdx,\n    byte* serial, int* serialSz, word32 maxIdx)\n{\n    int result = 0;\n    int ret;\n\n    WOLFSSL_ENTER(\"GetSerialNumber\");\n\n    if (serial == NULL || input == NULL || serialSz == NULL) {\n        return BAD_FUNC_ARG;\n    }\n\n    /* First byte is ASN type */\n    if ((*inOutIdx+1) > maxIdx) {\n        WOLFSSL_MSG(\"Bad idx first\");\n        return BUFFER_E;\n    }\n\n    ret = GetASNInt(input, inOutIdx, serialSz, maxIdx);\n    if (ret != 0)\n        return ret;\n\n    if (*serialSz > EXTERNAL_SERIAL_SIZE) {\n        WOLFSSL_MSG(\"Serial size bad\");\n        return ASN_PARSE_E;\n    }\n\n    /* return serial */\n    XMEMCPY(serial, &input[*inOutIdx], *serialSz);\n    *inOutIdx += *serialSz;\n\n    return result;\n}\n\n#ifndef NO_CERTS\n\nint AllocDer(DerBuffer** pDer, word32 length, int type, void* heap)\n{\n    int ret = BAD_FUNC_ARG;\n    if (pDer) {\n        int dynType = 0;\n        DerBuffer* der;\n\n        /* Determine dynamic type */\n        switch (type) {\n            case CA_TYPE:   dynType = DYNAMIC_TYPE_CA;   break;\n            case CERT_TYPE: dynType = DYNAMIC_TYPE_CERT; break;\n            case CRL_TYPE:  dynType = DYNAMIC_TYPE_CRL;  break;\n            case DSA_TYPE:  dynType = DYNAMIC_TYPE_DSA;  break;\n            case ECC_TYPE:  dynType = DYNAMIC_TYPE_ECC;  break;\n            case RSA_TYPE:  dynType = DYNAMIC_TYPE_RSA;  break;\n            default:        dynType = DYNAMIC_TYPE_KEY;  break;\n        }\n\n        /* Setup new buffer */\n        *pDer = (DerBuffer*)XMALLOC(sizeof(DerBuffer) + length, heap, dynType);\n        if (*pDer == NULL) {\n            return MEMORY_E;\n        }\n        XMEMSET(*pDer, 0, sizeof(DerBuffer) + length);\n\n        der = *pDer;\n        der->type = type;\n        der->dynType = dynType; /* Cache this for FreeDer */\n        der->heap = heap;\n        der->buffer = (byte*)der + sizeof(DerBuffer);\n        der->length = length;\n        ret = 0; /* Success */\n    }\n    return ret;\n}\n\nvoid FreeDer(DerBuffer** pDer)\n{\n    if (pDer && *pDer)\n    {\n        DerBuffer* der = (DerBuffer*)*pDer;\n\n        /* ForceZero private keys */\n        if (der->type == PRIVATEKEY_TYPE && der->buffer != NULL) {\n            ForceZero(der->buffer, der->length);\n        }\n        der->buffer = NULL;\n        der->length = 0;\n        XFREE(der, der->heap, der->dynType);\n\n        *pDer = NULL;\n    }\n}\n\nint wc_AllocDer(DerBuffer** pDer, word32 length, int type, void* heap)\n{\n    return AllocDer(pDer, length, type, heap);\n}\nvoid wc_FreeDer(DerBuffer** pDer)\n{\n    FreeDer(pDer);\n}\n\n\n#if defined(WOLFSSL_PEM_TO_DER) || defined(WOLFSSL_DER_TO_PEM)\n\n/* Note: If items added make sure MAX_X509_HEADER_SZ is \n    updated to reflect maximum length and pem_struct_min_sz\n    to reflect minimum size */\nwcchar BEGIN_CERT           = \"-----BEGIN CERTIFICATE-----\";\nwcchar END_CERT             = \"-----END CERTIFICATE-----\";\n#ifdef WOLFSSL_CERT_REQ\n    wcchar BEGIN_CERT_REQ   = \"-----BEGIN CERTIFICATE REQUEST-----\";\n    wcchar END_CERT_REQ     = \"-----END CERTIFICATE REQUEST-----\";\n#endif\n#ifndef NO_DH\n    wcchar BEGIN_DH_PARAM   = \"-----BEGIN DH PARAMETERS-----\";\n    wcchar END_DH_PARAM     = \"-----END DH PARAMETERS-----\";\n#endif\n#ifndef NO_DSA\n    wcchar BEGIN_DSA_PARAM  = \"-----BEGIN DSA PARAMETERS-----\";\n    wcchar END_DSA_PARAM    = \"-----END DSA PARAMETERS-----\";\n#endif\nwcchar BEGIN_X509_CRL       = \"-----BEGIN X509 CRL-----\";\nwcchar END_X509_CRL         = \"-----END X509 CRL-----\";\nwcchar BEGIN_RSA_PRIV       = \"-----BEGIN RSA PRIVATE KEY-----\";\nwcchar END_RSA_PRIV         = \"-----END RSA PRIVATE KEY-----\";\nwcchar BEGIN_PRIV_KEY       = \"-----BEGIN PRIVATE KEY-----\";\nwcchar END_PRIV_KEY         = \"-----END PRIVATE KEY-----\";\nwcchar BEGIN_ENC_PRIV_KEY   = \"-----BEGIN ENCRYPTED PRIVATE KEY-----\";\nwcchar END_ENC_PRIV_KEY     = \"-----END ENCRYPTED PRIVATE KEY-----\";\n#ifdef HAVE_ECC\n    wcchar BEGIN_EC_PRIV    = \"-----BEGIN EC PRIVATE KEY-----\";\n    wcchar END_EC_PRIV      = \"-----END EC PRIVATE KEY-----\";\n#endif\n#if defined(HAVE_ECC) || defined(HAVE_ED25519) || defined(HAVE_ED448) || \\\n                                                                !defined(NO_DSA)\n    wcchar BEGIN_DSA_PRIV   = \"-----BEGIN DSA PRIVATE KEY-----\";\n    wcchar END_DSA_PRIV     = \"-----END DSA PRIVATE KEY-----\";\n#endif\n#ifdef OPENSSL_EXTRA\n    const char BEGIN_PRIV_KEY_PREFIX[] = \"-----BEGIN\";\n    const char PRIV_KEY_SUFFIX[] = \"PRIVATE KEY-----\";\n    const char END_PRIV_KEY_PREFIX[]   = \"-----END\";\n#endif\nwcchar BEGIN_PUB_KEY        = \"-----BEGIN PUBLIC KEY-----\";\nwcchar END_PUB_KEY          = \"-----END PUBLIC KEY-----\";\n#if defined(HAVE_ED25519) || defined(HAVE_ED448)\n    wcchar BEGIN_EDDSA_PRIV = \"-----BEGIN EDDSA PRIVATE KEY-----\";\n    wcchar END_EDDSA_PRIV   = \"-----END EDDSA PRIVATE KEY-----\";\n#endif\n\nconst int pem_struct_min_sz = XSTR_SIZEOF(\"-----BEGIN X509 CRL-----\"\n                                             \"-----END X509 CRL-----\");\n\nstatic WC_INLINE const char* SkipEndOfLineChars(const char* line,\n                                                const char* endOfLine)\n{\n    /* eat end of line characters */\n    while (line < endOfLine &&\n              (line[0] == '\\r' || line[0] == '\\n')) {\n        line++;\n    }\n    return line;\n}\n\nint wc_PemGetHeaderFooter(int type, const char** header, const char** footer)\n{\n    int ret = BAD_FUNC_ARG;\n\n    switch (type) {\n        case CA_TYPE:       /* same as below */\n        case TRUSTED_PEER_TYPE:\n        case CERT_TYPE:\n            if (header) *header = BEGIN_CERT;\n            if (footer) *footer = END_CERT;\n            ret = 0;\n            break;\n\n        case CRL_TYPE:\n            if (header) *header = BEGIN_X509_CRL;\n            if (footer) *footer = END_X509_CRL;\n            ret = 0;\n            break;\n    #ifndef NO_DH\n        case DH_PARAM_TYPE:\n            if (header) *header = BEGIN_DH_PARAM;\n            if (footer) *footer = END_DH_PARAM;\n            ret = 0;\n            break;\n    #endif\n    #ifndef NO_DSA\n        case DSA_PARAM_TYPE:\n            if (header) *header = BEGIN_DSA_PARAM;\n            if (footer) *footer = END_DSA_PARAM;\n            ret = 0;\n            break;\n    #endif\n    #ifdef WOLFSSL_CERT_REQ\n        case CERTREQ_TYPE:\n            if (header) *header = BEGIN_CERT_REQ;\n            if (footer) *footer = END_CERT_REQ;\n            ret = 0;\n            break;\n    #endif\n    #ifndef NO_DSA\n        case DSA_TYPE:\n        case DSA_PRIVATEKEY_TYPE:\n            if (header) *header = BEGIN_DSA_PRIV;\n            if (footer) *footer = END_DSA_PRIV;\n            ret = 0;\n            break;\n    #endif\n    #ifdef HAVE_ECC\n        case ECC_TYPE:\n        case ECC_PRIVATEKEY_TYPE:\n            if (header) *header = BEGIN_EC_PRIV;\n            if (footer) *footer = END_EC_PRIV;\n            ret = 0;\n            break;\n    #endif\n        case RSA_TYPE:\n        case PRIVATEKEY_TYPE:\n            if (header) *header = BEGIN_RSA_PRIV;\n            if (footer) *footer = END_RSA_PRIV;\n            ret = 0;\n            break;\n    #ifdef HAVE_ED25519\n        case ED25519_TYPE:\n    #endif\n    #ifdef HAVE_ED448\n        case ED448_TYPE:\n    #endif\n    #if defined(HAVE_ED25519) || defined(HAVE_ED448)\n        case EDDSA_PRIVATEKEY_TYPE:\n            if (header) *header = BEGIN_EDDSA_PRIV;\n            if (footer) *footer = END_EDDSA_PRIV;\n            ret = 0;\n            break;\n    #endif\n        case PUBLICKEY_TYPE:\n        case ECC_PUBLICKEY_TYPE:\n            if (header) *header = BEGIN_PUB_KEY;\n            if (footer) *footer = END_PUB_KEY;\n            ret = 0;\n            break;\n    #ifndef NO_DH\n        case DH_PRIVATEKEY_TYPE:\n    #endif\n        case PKCS8_PRIVATEKEY_TYPE:\n            if (header) *header = BEGIN_PRIV_KEY;\n            if (footer) *footer = END_PRIV_KEY;\n            ret = 0;\n            break;\n        case PKCS8_ENC_PRIVATEKEY_TYPE:\n            if (header) *header = BEGIN_ENC_PRIV_KEY;\n            if (footer) *footer = END_ENC_PRIV_KEY;\n            ret = 0;\n            break;\n        default:\n            break;\n    }\n    return ret;\n}\n\n#ifdef WOLFSSL_ENCRYPTED_KEYS\n\nstatic wcchar kProcTypeHeader = \"Proc-Type\";\nstatic wcchar kDecInfoHeader = \"DEK-Info\";\n\n#ifdef WOLFSSL_PEM_TO_DER\n#ifndef NO_DES3\n    static wcchar kEncTypeDes = \"DES-CBC\";\n    static wcchar kEncTypeDes3 = \"DES-EDE3-CBC\";\n#endif\n#if !defined(NO_AES) && defined(HAVE_AES_CBC) && defined(WOLFSSL_AES_128)\n    static wcchar kEncTypeAesCbc128 = \"AES-128-CBC\";\n#endif\n#if !defined(NO_AES) && defined(HAVE_AES_CBC) && defined(WOLFSSL_AES_192)\n    static wcchar kEncTypeAesCbc192 = \"AES-192-CBC\";\n#endif\n#if !defined(NO_AES) && defined(HAVE_AES_CBC) && defined(WOLFSSL_AES_256)\n    static wcchar kEncTypeAesCbc256 = \"AES-256-CBC\";\n#endif\n\nint wc_EncryptedInfoGet(EncryptedInfo* info, const char* cipherInfo)\n{\n    int ret = 0;\n\n    if (info == NULL || cipherInfo == NULL)\n        return BAD_FUNC_ARG;\n\n    /* determine cipher information */\n#ifndef NO_DES3\n    if (XSTRNCMP(cipherInfo, kEncTypeDes, XSTRLEN(kEncTypeDes)) == 0) {\n        info->cipherType = WC_CIPHER_DES;\n        info->keySz = DES_KEY_SIZE;\n        if (info->ivSz == 0) info->ivSz  = DES_IV_SIZE;\n    }\n    else if (XSTRNCMP(cipherInfo, kEncTypeDes3, XSTRLEN(kEncTypeDes3)) == 0) {\n        info->cipherType = WC_CIPHER_DES3;\n        info->keySz = DES3_KEY_SIZE;\n        if (info->ivSz == 0) info->ivSz  = DES_IV_SIZE;\n    }\n    else\n#endif /* !NO_DES3 */\n#if !defined(NO_AES) && defined(HAVE_AES_CBC) && defined(WOLFSSL_AES_128)\n    if (XSTRNCMP(cipherInfo, kEncTypeAesCbc128, XSTRLEN(kEncTypeAesCbc128)) == 0) {\n        info->cipherType = WC_CIPHER_AES_CBC;\n        info->keySz = AES_128_KEY_SIZE;\n        if (info->ivSz == 0) info->ivSz  = AES_IV_SIZE;\n    }\n    else\n#endif\n#if !defined(NO_AES) && defined(HAVE_AES_CBC) && defined(WOLFSSL_AES_192)\n    if (XSTRNCMP(cipherInfo, kEncTypeAesCbc192, XSTRLEN(kEncTypeAesCbc192)) == 0) {\n        info->cipherType = WC_CIPHER_AES_CBC;\n        info->keySz = AES_192_KEY_SIZE;\n        if (info->ivSz == 0) info->ivSz  = AES_IV_SIZE;\n    }\n    else\n#endif\n#if !defined(NO_AES) && defined(HAVE_AES_CBC) && defined(WOLFSSL_AES_256)\n    if (XSTRNCMP(cipherInfo, kEncTypeAesCbc256, XSTRLEN(kEncTypeAesCbc256)) == 0) {\n        info->cipherType = WC_CIPHER_AES_CBC;\n        info->keySz = AES_256_KEY_SIZE;\n        if (info->ivSz == 0) info->ivSz  = AES_IV_SIZE;\n    }\n    else\n#endif\n    {\n        ret = NOT_COMPILED_IN;\n    }\n    return ret;\n}\n\nint wc_EncryptedInfoParse(EncryptedInfo* info, const char** pBuffer,\n                          size_t bufSz)\n{\n    int         err = 0;\n    const char* bufferStart;\n    const char* bufferEnd;\n    char*       line;\n    word32      lineSz;\n    char*       finish;\n    word32      finishSz;\n    char*       start = NULL;\n    word32      startSz;\n    const char* newline = NULL;\n\n    if (info == NULL || pBuffer == NULL || bufSz == 0)\n        return BAD_FUNC_ARG;\n\n    bufferStart = *pBuffer;\n    bufferEnd = bufferStart + bufSz;\n\n    /* find encrypted info marker */\n    line = XSTRNSTR(bufferStart, kProcTypeHeader,\n                    min((word32)bufSz, PEM_LINE_LEN));\n    if (line != NULL) {\n        if (line >= bufferEnd) {\n            return BUFFER_E;\n        }\n\n        lineSz = (word32)(bufferEnd - line);\n\n        /* find DEC-Info marker */\n        start = XSTRNSTR(line, kDecInfoHeader, min(lineSz, PEM_LINE_LEN));\n\n        if (start == NULL)\n            return BUFFER_E;\n\n        /* skip dec-info and \": \" */\n        start += XSTRLEN(kDecInfoHeader);\n        if (start >= bufferEnd)\n            return BUFFER_E;\n\n        if (start[0] == ':') {\n            start++;\n            if (start >= bufferEnd)\n                return BUFFER_E;\n        }\n        if (start[0] == ' ')\n            start++;\n\n        startSz = (word32)(bufferEnd - start);\n        finish = XSTRNSTR(start, \",\", min(startSz, PEM_LINE_LEN));\n\n        if ((start != NULL) && (finish != NULL) && (start < finish)) {\n            if (finish >= bufferEnd) {\n                return BUFFER_E;\n            }\n\n            finishSz = (word32)(bufferEnd - finish);\n            newline = XSTRNSTR(finish, \"\\r\", min(finishSz, PEM_LINE_LEN));\n\n            /* get cipher name */\n            if (NAME_SZ < (finish - start)) /* buffer size of info->name */\n                return BUFFER_E;\n            if (XMEMCPY(info->name, start, finish - start) == NULL)\n                return BUFFER_E;\n            info->name[finish - start] = '\\0'; /* null term */\n\n            /* populate info */\n            err = wc_EncryptedInfoGet(info, info->name);\n            if (err != 0)\n                return err;\n\n            /* get IV */\n            if (finishSz < info->ivSz + 1)\n                return BUFFER_E;\n\n            if (newline == NULL) {\n                newline = XSTRNSTR(finish, \"\\n\", min(finishSz,\n                                                     PEM_LINE_LEN));\n            }\n            if ((newline != NULL) && (newline > finish)) {\n                finish++;\n                info->ivSz = (word32)(newline - finish);\n                if (info->ivSz > IV_SZ)\n                    return BUFFER_E;\n                if (XMEMCPY(info->iv, finish, info->ivSz) == NULL)\n                    return BUFFER_E;\n                info->set = 1;\n            }\n            else\n                return BUFFER_E;\n        }\n        else\n            return BUFFER_E;\n\n        /* eat end of line characters */\n        newline = SkipEndOfLineChars(newline, bufferEnd);\n\n        /* return new headerEnd */\n\n        *pBuffer = newline;\n    }\n\n    return err;\n}\n#endif /* WOLFSSL_PEM_TO_DER */\n\n#ifdef WOLFSSL_DER_TO_PEM\nstatic int wc_EncryptedInfoAppend(char* dest, int destSz, char* cipherInfo)\n{\n    if (cipherInfo != NULL) {\n        int cipherInfoStrLen = (int)XSTRLEN((char*)cipherInfo);\n\n        if (cipherInfoStrLen > HEADER_ENCRYPTED_KEY_SIZE - (9+14+10+3))\n            cipherInfoStrLen = HEADER_ENCRYPTED_KEY_SIZE - (9+14+10+3);\n\n        if (destSz - (int)XSTRLEN(dest) >= cipherInfoStrLen + (9+14+8+2+2+1)) {\n            /* strncat's src length needs to include the NULL */\n            XSTRNCAT(dest, kProcTypeHeader, 10);\n            XSTRNCAT(dest, \": 4,ENCRYPTED\\n\", 15);\n            XSTRNCAT(dest, kDecInfoHeader, 9);\n            XSTRNCAT(dest, \": \", 3);\n            XSTRNCAT(dest, cipherInfo, destSz - (int)XSTRLEN(dest) - 1);\n            XSTRNCAT(dest, \"\\n\\n\", 4);\n        }\n    }\n    return 0;\n}\n#endif /* WOLFSSL_DER_TO_PEM */\n#endif /* WOLFSSL_ENCRYPTED_KEYS */\n\n#ifdef WOLFSSL_DER_TO_PEM\n\n/* Used for compatibility API */\nint wc_DerToPem(const byte* der, word32 derSz,\n                byte* output, word32 outSz, int type)\n{\n    return wc_DerToPemEx(der, derSz, output, outSz, NULL, type);\n}\n\n/* convert der buffer to pem into output, can't do inplace, der and output\n   need to be different */\nint wc_DerToPemEx(const byte* der, word32 derSz, byte* output, word32 outSz,\n             byte *cipher_info, int type)\n{\n    const char* headerStr = NULL;\n    const char* footerStr = NULL;\n#ifdef WOLFSSL_SMALL_STACK\n    char* header = NULL;\n    char* footer = NULL;\n#else\n    char header[MAX_X509_HEADER_SZ + HEADER_ENCRYPTED_KEY_SIZE];\n    char footer[MAX_X509_HEADER_SZ];\n#endif\n    int headerLen = MAX_X509_HEADER_SZ + HEADER_ENCRYPTED_KEY_SIZE;\n    int footerLen = MAX_X509_HEADER_SZ;\n    int i;\n    int err;\n    int outLen;   /* return length or error */\n\n    (void)cipher_info;\n\n    if (der == output)      /* no in place conversion */\n        return BAD_FUNC_ARG;\n\n    err = wc_PemGetHeaderFooter(type, &headerStr, &footerStr);\n    if (err != 0)\n        return err;\n\n#ifdef WOLFSSL_SMALL_STACK\n    header = (char*)XMALLOC(headerLen, NULL, DYNAMIC_TYPE_TMP_BUFFER);\n    if (header == NULL)\n        return MEMORY_E;\n\n    footer = (char*)XMALLOC(footerLen, NULL, DYNAMIC_TYPE_TMP_BUFFER);\n    if (footer == NULL) {\n        XFREE(header, NULL, DYNAMIC_TYPE_TMP_BUFFER);\n        return MEMORY_E;\n    }\n#endif\n\n    /* build header and footer based on type */\n    XSTRNCPY(header, headerStr, headerLen - 1);\n    header[headerLen - 2] = 0;\n    XSTRNCPY(footer, footerStr, footerLen - 1);\n    footer[footerLen - 2] = 0;\n\n    /* add new line to end */\n    XSTRNCAT(header, \"\\n\", 2);\n    XSTRNCAT(footer, \"\\n\", 2);\n\n#ifdef WOLFSSL_ENCRYPTED_KEYS\n    err = wc_EncryptedInfoAppend(header, headerLen, (char*)cipher_info);\n    if (err != 0) {\n    #ifdef WOLFSSL_SMALL_STACK\n        XFREE(header, NULL, DYNAMIC_TYPE_TMP_BUFFER);\n        XFREE(footer, NULL, DYNAMIC_TYPE_TMP_BUFFER);\n    #endif\n        return err;\n    }\n#endif\n\n    headerLen = (int)XSTRLEN(header);\n    footerLen = (int)XSTRLEN(footer);\n\n    /* if null output and 0 size passed in then return size needed */\n    if (!output && outSz == 0) {\n#ifdef WOLFSSL_SMALL_STACK\n        XFREE(header, NULL, DYNAMIC_TYPE_TMP_BUFFER);\n        XFREE(footer, NULL, DYNAMIC_TYPE_TMP_BUFFER);\n#endif\n        outLen = 0;\n        if ((err = Base64_Encode(der, derSz, NULL, (word32*)&outLen))\n                != LENGTH_ONLY_E) {\n            return err;\n        }\n        return headerLen + footerLen + outLen;\n    }\n\n    if (!der || !output) {\n#ifdef WOLFSSL_SMALL_STACK\n        XFREE(header, NULL, DYNAMIC_TYPE_TMP_BUFFER);\n        XFREE(footer, NULL, DYNAMIC_TYPE_TMP_BUFFER);\n#endif\n        return BAD_FUNC_ARG;\n    }\n\n    /* don't even try if outSz too short */\n    if (outSz < headerLen + footerLen + derSz) {\n#ifdef WOLFSSL_SMALL_STACK\n        XFREE(header, NULL, DYNAMIC_TYPE_TMP_BUFFER);\n        XFREE(footer, NULL, DYNAMIC_TYPE_TMP_BUFFER);\n#endif\n        return BAD_FUNC_ARG;\n    }\n\n    /* header */\n    XMEMCPY(output, header, headerLen);\n    i = headerLen;\n\n#ifdef WOLFSSL_SMALL_STACK\n    XFREE(header, NULL, DYNAMIC_TYPE_TMP_BUFFER);\n#endif\n\n    /* body */\n    outLen = outSz - (headerLen + footerLen);  /* input to Base64_Encode */\n    if ( (err = Base64_Encode(der, derSz, output + i, (word32*)&outLen)) < 0) {\n#ifdef WOLFSSL_SMALL_STACK\n        XFREE(footer, NULL, DYNAMIC_TYPE_TMP_BUFFER);\n#endif\n        return err;\n    }\n    i += outLen;\n\n    /* footer */\n    if ( (i + footerLen) > (int)outSz) {\n#ifdef WOLFSSL_SMALL_STACK\n        XFREE(footer, NULL, DYNAMIC_TYPE_TMP_BUFFER);\n#endif\n        return BAD_FUNC_ARG;\n    }\n    XMEMCPY(output + i, footer, footerLen);\n\n#ifdef WOLFSSL_SMALL_STACK\n    XFREE(footer, NULL, DYNAMIC_TYPE_TMP_BUFFER);\n#endif\n\n    return outLen + headerLen + footerLen;\n}\n\n#endif /* WOLFSSL_DER_TO_PEM */\n\n#ifdef WOLFSSL_PEM_TO_DER\n\n/* Remove PEM header/footer, convert to ASN1, store any encrypted data\n   info->consumed tracks of PEM bytes consumed in case multiple parts */\nint PemToDer(const unsigned char* buff, long longSz, int type,\n              DerBuffer** pDer, void* heap, EncryptedInfo* info, int* keyFormat)\n{\n    const char* header      = NULL;\n    const char* footer      = NULL;\n    const char* headerEnd;\n    const char* footerEnd;\n    const char* consumedEnd;\n    const char* bufferEnd   = (const char*)(buff + longSz);\n    long        neededSz;\n    int         ret         = 0;\n    int         sz          = (int)longSz;\n    int         encrypted_key = 0;\n    DerBuffer*  der;\n#if defined(HAVE_PKCS8) || defined(WOLFSSL_ENCRYPTED_KEYS)\n    word32      algId = 0;\n    #if defined(WOLFSSL_ENCRYPTED_KEYS) && !defined(NO_DES3) && !defined(NO_WOLFSSL_SKIP_TRAILING_PAD)\n        int     padVal = 0;\n    #endif\n#endif\n#ifdef OPENSSL_EXTRA\n    char        beginBuf[PEM_LINE_LEN + 1]; /* add 1 for null terminator */\n    char        endBuf[PEM_LINE_LEN + 1];   /* add 1 for null terminator */\n#endif\n\n    WOLFSSL_ENTER(\"PemToDer\");\n\n    /* get PEM header and footer based on type */\n    ret = wc_PemGetHeaderFooter(type, &header, &footer);\n    if (ret != 0)\n        return ret;\n\n    /* map header if not found for type */\n    for (;;) {\n        headerEnd = XSTRNSTR((char*)buff, header, sz);\n\n        if (headerEnd) {\n            break;\n        } else\n        if (type == PRIVATEKEY_TYPE) {\n            if (header == BEGIN_RSA_PRIV) {\n                header =  BEGIN_PRIV_KEY;       footer = END_PRIV_KEY;\n            } else\n            if (header == BEGIN_PRIV_KEY) {\n                header =  BEGIN_ENC_PRIV_KEY;   footer = END_ENC_PRIV_KEY;\n            } else\n    #ifdef HAVE_ECC\n            if (header == BEGIN_ENC_PRIV_KEY) {\n                header =  BEGIN_EC_PRIV;        footer = END_EC_PRIV;\n            } else\n            if (header == BEGIN_EC_PRIV) {\n                header =  BEGIN_DSA_PRIV;       footer = END_DSA_PRIV;\n            } else\n    #endif\n    #if defined(HAVE_ED25519) || defined(HAVE_ED448)\n        #ifdef HAVE_ECC\n            if (header == BEGIN_DSA_PRIV)\n        #else\n            if (header == BEGIN_ENC_PRIV_KEY)\n        #endif\n            {\n                header =  BEGIN_EDDSA_PRIV;     footer = END_EDDSA_PRIV;\n            } else\n    #endif\n            {\n                break;\n            }\n        } else\n#ifdef HAVE_CRL\n        if ((type == CRL_TYPE) && (header != BEGIN_X509_CRL)) {\n            header =  BEGIN_X509_CRL;           footer = END_X509_CRL;\n        } else\n#endif\n        {\n            break;\n        }\n    }\n\n    if (!headerEnd) {\n#ifdef OPENSSL_EXTRA\n        if (type == PRIVATEKEY_TYPE) {\n            const char* beginEnd;\n            int endLen;\n            /* see if there is a -----BEGIN * PRIVATE KEY----- header */\n            headerEnd = XSTRNSTR((char*)buff, PRIV_KEY_SUFFIX, sz);\n            if (headerEnd) {\n                beginEnd = headerEnd + XSTR_SIZEOF(PRIV_KEY_SUFFIX);\n                if (beginEnd >= (char*)buff + sz) {\n                    return BUFFER_E;\n                }\n\n                /* back up to BEGIN_PRIV_KEY_PREFIX */\n                while (headerEnd > (char*)buff &&\n                        XSTRNCMP(headerEnd, BEGIN_PRIV_KEY_PREFIX,\n                                XSTR_SIZEOF(BEGIN_PRIV_KEY_PREFIX)) != 0 &&\n                        *headerEnd != '\\n') {\n                    headerEnd--;\n                }\n                if (headerEnd <= (char*)buff ||\n                        XSTRNCMP(headerEnd, BEGIN_PRIV_KEY_PREFIX,\n                        XSTR_SIZEOF(BEGIN_PRIV_KEY_PREFIX)) != 0 ||\n                        beginEnd - headerEnd > PEM_LINE_LEN) {\n                    WOLFSSL_MSG(\"Couldn't find PEM header\");\n                    WOLFSSL_ERROR(ASN_NO_PEM_HEADER);\n                    return ASN_NO_PEM_HEADER;\n                }\n\n                /* headerEnd now points to beginning of header */\n                XMEMCPY(beginBuf, headerEnd, beginEnd - headerEnd);\n                beginBuf[beginEnd - headerEnd] = '\\0';\n                /* look for matching footer */\n                footer = XSTRNSTR(beginEnd,\n                                beginBuf + XSTR_SIZEOF(BEGIN_PRIV_KEY_PREFIX),\n                                (unsigned int)((char*)buff + sz - beginEnd));\n                if (!footer) {\n                    WOLFSSL_MSG(\"Couldn't find PEM footer\");\n                    WOLFSSL_ERROR(ASN_NO_PEM_HEADER);\n                    return ASN_NO_PEM_HEADER;\n                }\n\n                footer -= XSTR_SIZEOF(END_PRIV_KEY_PREFIX);\n                if (footer > (char*)buff + sz - XSTR_SIZEOF(END_PRIV_KEY_PREFIX)\n                        || XSTRNCMP(footer, END_PRIV_KEY_PREFIX,\n                            XSTR_SIZEOF(END_PRIV_KEY_PREFIX)) != 0) {\n                    WOLFSSL_MSG(\"Unexpected footer for PEM\");\n                    return BUFFER_E;\n                }\n\n                endLen = (unsigned int)(beginEnd - headerEnd -\n                            (XSTR_SIZEOF(BEGIN_PRIV_KEY_PREFIX) -\n                                    XSTR_SIZEOF(END_PRIV_KEY_PREFIX)));\n                XMEMCPY(endBuf, footer, endLen);\n                endBuf[endLen] = '\\0';\n\n                header = beginBuf;\n                footer = endBuf;\n                headerEnd = beginEnd;\n            }\n        }\n\n        if (!headerEnd) {\n            WOLFSSL_MSG(\"Couldn't find PEM header\");\n            WOLFSSL_ERROR(ASN_NO_PEM_HEADER);\n            return ASN_NO_PEM_HEADER;\n        }\n#else\n        WOLFSSL_MSG(\"Couldn't find PEM header\");\n        return ASN_NO_PEM_HEADER;\n#endif\n    } else {\n        headerEnd += XSTRLEN(header);\n    }\n\n    /* eat end of line characters */\n    headerEnd = SkipEndOfLineChars(headerEnd, bufferEnd);\n\n    if (type == PRIVATEKEY_TYPE) {\n        /* keyFormat is Key_Sum enum */\n        if (keyFormat) {\n        #ifdef HAVE_ECC\n            if (header == BEGIN_EC_PRIV)\n                *keyFormat = ECDSAk;\n        #endif\n        #if !defined(NO_DSA)\n            if (header == BEGIN_DSA_PRIV)\n                *keyFormat = DSAk;\n        #endif\n        }\n    }\n\n#ifdef WOLFSSL_ENCRYPTED_KEYS\n    if (info) {\n        ret = wc_EncryptedInfoParse(info, &headerEnd, bufferEnd - headerEnd);\n        if (ret < 0)\n            return ret;\n        if (info->set)\n            encrypted_key = 1;\n    }\n#endif /* WOLFSSL_ENCRYPTED_KEYS */\n\n    /* find footer */\n    footerEnd = XSTRNSTR(headerEnd, footer, (unsigned int)((char*)buff + sz - headerEnd));\n    if (!footerEnd) {\n        if (info)\n            info->consumed = longSz; /* No more certs if no footer */\n        return BUFFER_E;\n    }\n\n    consumedEnd = footerEnd + XSTRLEN(footer);\n\n    if (consumedEnd < bufferEnd) { /* handle no end of line on last line */\n        /* eat end of line characters */\n        consumedEnd = SkipEndOfLineChars(consumedEnd, bufferEnd);\n        /* skip possible null term */\n        if (consumedEnd < bufferEnd && consumedEnd[0] == '\\0')\n            consumedEnd++;\n    }\n\n    if (info)\n        info->consumed = (long)(consumedEnd - (const char*)buff);\n\n    /* set up der buffer */\n    neededSz = (long)(footerEnd - headerEnd);\n    if (neededSz > sz || neededSz <= 0)\n        return BUFFER_E;\n\n    ret = AllocDer(pDer, (word32)neededSz, type, heap);\n    if (ret < 0) {\n        return ret;\n    }\n    der = *pDer;\n\n    if (Base64_Decode((byte*)headerEnd, (word32)neededSz,\n                      der->buffer, &der->length) < 0)\n        return BUFFER_E;\n\n    if ((header == BEGIN_PRIV_KEY\n#ifdef OPENSSL_EXTRA\n         || header == beginBuf\n#endif\n#ifdef HAVE_ECC\n         || header == BEGIN_EC_PRIV\n#endif\n        ) && !encrypted_key)\n    {\n    #ifdef HAVE_PKCS8\n        /* pkcs8 key, convert and adjust length */\n        if ((ret = ToTraditional_ex(der->buffer, der->length, &algId)) > 0) {\n            der->length = ret;\n            if (keyFormat) {\n                *keyFormat = algId;\n            }\n        }\n        else {\n            /* ignore failure here and assume key is not pkcs8 wrapped */\n        }\n    #endif\n\n        return 0;\n    }\n\n#ifdef WOLFSSL_ENCRYPTED_KEYS\n    if (encrypted_key || header == BEGIN_ENC_PRIV_KEY) {\n        int   passwordSz = NAME_SZ;\n    #ifdef WOLFSSL_SMALL_STACK\n        char* password = NULL;\n    #else\n        char  password[NAME_SZ];\n    #endif\n\n        if (!info || !info->passwd_cb) {\n            WOLFSSL_MSG(\"No password callback set\");\n            return NO_PASSWORD;\n        }\n\n    #ifdef WOLFSSL_SMALL_STACK\n        password = (char*)XMALLOC(passwordSz, heap, DYNAMIC_TYPE_STRING);\n        if (password == NULL)\n            return MEMORY_E;\n    #endif\n\n        /* get password */\n        ret = info->passwd_cb(password, passwordSz, PEM_PASS_READ,\n            info->passwd_userdata);\n        if (ret >= 0) {\n            passwordSz = ret;\n\n            /* convert and adjust length */\n            if (header == BEGIN_ENC_PRIV_KEY) {\n            #ifndef NO_PWDBASED\n                ret = ToTraditionalEnc(der->buffer, der->length,\n                                       password, passwordSz, &algId);\n\n                if (ret >= 0) {\n                    der->length = ret;\n                    if (keyFormat) {\n                        *keyFormat = algId;\n                    }\n                    ret = 0;\n                }\n            #else\n                ret = NOT_COMPILED_IN;\n            #endif\n            }\n            /* decrypt the key */\n            else {\n                if (passwordSz == 0) {\n                    /* The key is encrypted but does not have a password */\n                    WOLFSSL_MSG(\"No password for encrypted key\");\n                    ret = NO_PASSWORD;\n                }\n                else {\n                    ret = wc_BufferKeyDecrypt(info, der->buffer, der->length,\n                        (byte*)password, passwordSz, WC_MD5);\n\n#ifndef NO_WOLFSSL_SKIP_TRAILING_PAD\n                #ifndef NO_DES3\n                    if (info->cipherType == WC_CIPHER_DES3) {\n                        /* Assuming there is padding:\n                         *      (der->length > 0 && der->length > DES_BLOCK_SIZE &&\n                         *       (der->length % DES_BLOCK_SIZE) != 0)\n                         * and assuming the last value signifies the number of\n                         * padded bytes IE if last value is 0x08 then there are\n                         * 8 bytes of padding:\n                         *      padVal = der->buffer[der->length-1];\n                         * then strip this padding before proceeding:\n                         * der->length -= padVal;\n                         */\n                        if (der->length > DES_BLOCK_SIZE &&\n                            (der->length % DES_BLOCK_SIZE) != 0) {\n                            padVal = der->buffer[der->length-1];\n                            if (padVal < DES_BLOCK_SIZE) {\n                                der->length -= padVal;\n                            }\n                        }\n                    }\n                #endif /* !NO_DES3 */\n#endif /* !NO_WOLFSSL_SKIP_TRAILING_PAD */\n                }\n            }\n#ifdef OPENSSL_EXTRA\n            if (ret) {\n                PEMerr(0, PEM_R_BAD_DECRYPT);\n            }\n#endif\n            ForceZero(password, passwordSz);\n        }\n#ifdef OPENSSL_EXTRA\n        else {\n            PEMerr(0, PEM_R_BAD_PASSWORD_READ);\n        }\n#endif\n\n    #ifdef WOLFSSL_SMALL_STACK\n        XFREE(password, heap, DYNAMIC_TYPE_STRING);\n    #endif\n    }\n#endif /* WOLFSSL_ENCRYPTED_KEYS */\n\n    return ret;\n}\n\nint wc_PemToDer(const unsigned char* buff, long longSz, int type,\n              DerBuffer** pDer, void* heap, EncryptedInfo* info, int* eccKey)\n{\n    return PemToDer(buff, longSz, type, pDer, heap, info, eccKey);\n}\n\n\n/* our KeyPemToDer password callback, password in userData */\nstatic WC_INLINE int OurPasswordCb(char* passwd, int sz, int rw, void* userdata)\n{\n    (void)rw;\n\n    if (userdata == NULL)\n        return 0;\n\n    XSTRNCPY(passwd, (char*)userdata, sz);\n    return min((word32)sz, (word32)XSTRLEN((char*)userdata));\n}\n\n/* Return bytes written to buff or < 0 for error */\nint wc_KeyPemToDer(const unsigned char* pem, int pemSz,\n                        unsigned char* buff, int buffSz, const char* pass)\n{\n    int            eccKey = 0;\n    int            ret;\n    DerBuffer*     der = NULL;\n#ifdef WOLFSSL_SMALL_STACK\n    EncryptedInfo* info = NULL;\n#else\n    EncryptedInfo  info[1];\n#endif\n\n    WOLFSSL_ENTER(\"wc_KeyPemToDer\");\n\n    if (pem == NULL || buff == NULL || buffSz <= 0) {\n        WOLFSSL_MSG(\"Bad pem der args\");\n        return BAD_FUNC_ARG;\n    }\n\n#ifdef WOLFSSL_SMALL_STACK\n    info = (EncryptedInfo*)XMALLOC(sizeof(EncryptedInfo), NULL,\n                                   DYNAMIC_TYPE_ENCRYPTEDINFO);\n    if (info == NULL)\n        return MEMORY_E;\n#endif\n\n    XMEMSET(info, 0, sizeof(EncryptedInfo));\n    info->passwd_cb = OurPasswordCb;\n    info->passwd_userdata = (void*)pass;\n\n    ret = PemToDer(pem, pemSz, PRIVATEKEY_TYPE, &der, NULL, info, &eccKey);\n\n#ifdef WOLFSSL_SMALL_STACK\n    XFREE(info, NULL, DYNAMIC_TYPE_ENCRYPTEDINFO);\n#endif\n\n    if (ret < 0 || der == NULL) {\n        WOLFSSL_MSG(\"Bad Pem To Der\");\n    }\n    else {\n        if (der->length <= (word32)buffSz) {\n            XMEMCPY(buff, der->buffer, der->length);\n            ret = der->length;\n        }\n        else {\n            WOLFSSL_MSG(\"Bad der length\");\n            ret = BAD_FUNC_ARG;\n        }\n    }\n\n    FreeDer(&der);\n    return ret;\n}\n\n\n/* Return bytes written to buff or < 0 for error */\nint wc_CertPemToDer(const unsigned char* pem, int pemSz,\n                        unsigned char* buff, int buffSz, int type)\n{\n    int            eccKey = 0;\n    int            ret;\n    DerBuffer*     der = NULL;\n\n    WOLFSSL_ENTER(\"wc_CertPemToDer\");\n\n    if (pem == NULL || buff == NULL || buffSz <= 0) {\n        WOLFSSL_MSG(\"Bad pem der args\");\n        return BAD_FUNC_ARG;\n    }\n\n    if (type != CERT_TYPE && type != CA_TYPE && type != CERTREQ_TYPE) {\n        WOLFSSL_MSG(\"Bad cert type\");\n        return BAD_FUNC_ARG;\n    }\n\n\n    ret = PemToDer(pem, pemSz, type, &der, NULL, NULL, &eccKey);\n    if (ret < 0 || der == NULL) {\n        WOLFSSL_MSG(\"Bad Pem To Der\");\n    }\n    else {\n        if (der->length <= (word32)buffSz) {\n            XMEMCPY(buff, der->buffer, der->length);\n            ret = der->length;\n        }\n        else {\n            WOLFSSL_MSG(\"Bad der length\");\n            ret = BAD_FUNC_ARG;\n        }\n    }\n\n    FreeDer(&der);\n    return ret;\n}\n\n#endif /* WOLFSSL_PEM_TO_DER */\n#endif /* WOLFSSL_PEM_TO_DER || WOLFSSL_DER_TO_PEM */\n\n\n#ifdef WOLFSSL_PEM_TO_DER\n#if defined(WOLFSSL_CERT_EXT) || defined(WOLFSSL_PUB_PEM_TO_DER)\n/* Return bytes written to buff or < 0 for error */\nint wc_PubKeyPemToDer(const unsigned char* pem, int pemSz,\n                           unsigned char* buff, int buffSz)\n{\n    int ret;\n    DerBuffer* der = NULL;\n\n    WOLFSSL_ENTER(\"wc_PubKeyPemToDer\");\n\n    if (pem == NULL || buff == NULL || buffSz <= 0) {\n        WOLFSSL_MSG(\"Bad pem der args\");\n        return BAD_FUNC_ARG;\n    }\n\n    ret = PemToDer(pem, pemSz, PUBLICKEY_TYPE, &der, NULL, NULL, NULL);\n    if (ret < 0 || der == NULL) {\n        WOLFSSL_MSG(\"Bad Pem To Der\");\n    }\n    else {\n        if (der->length <= (word32)buffSz) {\n            XMEMCPY(buff, der->buffer, der->length);\n            ret = der->length;\n        }\n        else {\n            WOLFSSL_MSG(\"Bad der length\");\n            ret = BAD_FUNC_ARG;\n        }\n    }\n\n    FreeDer(&der);\n    return ret;\n}\n#endif /* WOLFSSL_CERT_EXT || WOLFSSL_PUB_PEM_TO_DER */\n#endif /* WOLFSSL_PEM_TO_DER */\n\n#ifndef NO_FILESYSTEM\n\n#ifdef WOLFSSL_CERT_GEN\n/* load pem cert from file into der buffer, return der size or error */\nint wc_PemCertToDer(const char* fileName, unsigned char* derBuf, int derSz)\n{\n#ifdef WOLFSSL_SMALL_STACK\n    byte   staticBuffer[1]; /* force XMALLOC */\n#else\n    byte   staticBuffer[FILE_BUFFER_SIZE];\n#endif\n    byte*  fileBuf = staticBuffer;\n    int    dynamic = 0;\n    int    ret     = 0;\n    long   sz      = 0;\n    XFILE  file;\n    DerBuffer* converted = NULL;\n\n    WOLFSSL_ENTER(\"wc_PemCertToDer\");\n\n    if (fileName == NULL) {\n        ret = BAD_FUNC_ARG;\n    }\n    else {\n        file = XFOPEN(fileName, \"rb\");\n        if (file == XBADFILE) {\n            ret = BUFFER_E;\n        }\n    }\n\n    if (ret == 0) {\n        if(XFSEEK(file, 0, XSEEK_END) != 0)\n            ret = BUFFER_E;\n        sz = XFTELL(file);\n        XREWIND(file);\n\n        if (sz <= 0) {\n            ret = BUFFER_E;\n        }\n        else if (sz > (long)sizeof(staticBuffer)) {\n        #ifdef WOLFSSL_STATIC_MEMORY\n            WOLFSSL_MSG(\"File was larger then static buffer\");\n            return MEMORY_E;\n        #endif\n            fileBuf = (byte*)XMALLOC(sz, NULL, DYNAMIC_TYPE_FILE);\n            if (fileBuf == NULL)\n                ret = MEMORY_E;\n            else\n                dynamic = 1;\n        }\n\n        if (ret == 0) {\n            if ((size_t)XFREAD(fileBuf, 1, sz, file) != (size_t)sz) {\n                ret = BUFFER_E;\n            }\n        #ifdef WOLFSSL_PEM_TO_DER\n            else {\n                ret = PemToDer(fileBuf, sz, CA_TYPE, &converted,  0, NULL,NULL);\n            }\n        #endif\n\n            if (ret == 0) {\n                if (converted->length < (word32)derSz) {\n                    XMEMCPY(derBuf, converted->buffer, converted->length);\n                    ret = converted->length;\n                }\n                else\n                    ret = BUFFER_E;\n            }\n\n            FreeDer(&converted);\n        }\n\n        XFCLOSE(file);\n        if (dynamic)\n            XFREE(fileBuf, NULL, DYNAMIC_TYPE_FILE);\n    }\n\n    return ret;\n}\n#endif /* WOLFSSL_CERT_GEN */\n\n#if defined(WOLFSSL_CERT_EXT) || defined(WOLFSSL_PUB_PEM_TO_DER)\n/* load pem public key from file into der buffer, return der size or error */\nint wc_PemPubKeyToDer(const char* fileName,\n                           unsigned char* derBuf, int derSz)\n{\n#ifdef WOLFSSL_SMALL_STACK\n    byte   staticBuffer[1]; /* force XMALLOC */\n#else\n    byte   staticBuffer[FILE_BUFFER_SIZE];\n#endif\n    byte*  fileBuf = staticBuffer;\n    int    dynamic = 0;\n    int    ret     = 0;\n    long   sz      = 0;\n    XFILE  file;\n    DerBuffer* converted = NULL;\n\n    WOLFSSL_ENTER(\"wc_PemPubKeyToDer\");\n\n    if (fileName == NULL) {\n        ret = BAD_FUNC_ARG;\n    }\n    else {\n        file = XFOPEN(fileName, \"rb\");\n        if (file == XBADFILE) {\n            ret = BUFFER_E;\n        }\n    }\n\n    if (ret == 0) {\n        if(XFSEEK(file, 0, XSEEK_END) != 0)\n            ret = BUFFER_E;\n        sz = XFTELL(file);\n        XREWIND(file);\n\n        if (sz <= 0) {\n            ret = BUFFER_E;\n        }\n        else if (sz > (long)sizeof(staticBuffer)) {\n        #ifdef WOLFSSL_STATIC_MEMORY\n            WOLFSSL_MSG(\"File was larger then static buffer\");\n            return MEMORY_E;\n        #endif\n            fileBuf = (byte*)XMALLOC(sz, NULL, DYNAMIC_TYPE_FILE);\n            if (fileBuf == NULL)\n                ret = MEMORY_E;\n            else\n                dynamic = 1;\n        }\n        if (ret == 0) {\n            if ((size_t)XFREAD(fileBuf, 1, sz, file) != (size_t)sz) {\n                ret = BUFFER_E;\n            }\n        #ifdef WOLFSSL_PEM_TO_DER\n            else {\n                ret = PemToDer(fileBuf, sz, PUBLICKEY_TYPE, &converted,\n                               0, NULL, NULL);\n            }\n        #endif\n\n            if (ret == 0) {\n                if (converted->length < (word32)derSz) {\n                    XMEMCPY(derBuf, converted->buffer, converted->length);\n                    ret = converted->length;\n                }\n                else\n                    ret = BUFFER_E;\n            }\n\n            FreeDer(&converted);\n        }\n\n        XFCLOSE(file);\n        if (dynamic)\n            XFREE(fileBuf, NULL, DYNAMIC_TYPE_FILE);\n    }\n\n    return ret;\n}\n#endif /* WOLFSSL_CERT_EXT || WOLFSSL_PUB_PEM_TO_DER */\n\n#endif /* !NO_FILESYSTEM */\n\n\n#if !defined(NO_RSA) && (defined(WOLFSSL_CERT_GEN) || \\\n    ((defined(WOLFSSL_KEY_GEN) || defined(OPENSSL_EXTRA)) && !defined(HAVE_USER_RSA)))\n/* USER RSA ifdef portions used instead of refactor in consideration for\n   possible fips build */\n/* Write a public RSA key to output */\nstatic int SetRsaPublicKey(byte* output, RsaKey* key,\n                           int outLen, int with_header)\n{\n#ifdef WOLFSSL_SMALL_STACK\n    byte* n = NULL;\n    byte* e = NULL;\n#else\n    byte n[MAX_RSA_INT_SZ];\n    byte e[MAX_RSA_E_SZ];\n#endif\n    byte seq[MAX_SEQ_SZ];\n    byte bitString[1 + MAX_LENGTH_SZ + 1];\n    int  nSz;\n    int  eSz;\n    int  seqSz;\n    int  bitStringSz;\n    int  idx;\n\n    if (output == NULL || key == NULL || outLen < MAX_SEQ_SZ)\n        return BAD_FUNC_ARG;\n\n    /* n */\n#ifdef WOLFSSL_SMALL_STACK\n    n = (byte*)XMALLOC(MAX_RSA_INT_SZ, key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n    if (n == NULL)\n        return MEMORY_E;\n#endif\n\n#ifdef HAVE_USER_RSA\n    nSz = SetASNIntRSA(key->n, n);\n#else\n    nSz = SetASNIntMP(&key->n, MAX_RSA_INT_SZ, n);\n#endif\n    if (nSz < 0) {\n#ifdef WOLFSSL_SMALL_STACK\n        XFREE(n, key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n#endif\n        return nSz;\n    }\n\n    /* e */\n#ifdef WOLFSSL_SMALL_STACK\n    e = (byte*)XMALLOC(MAX_RSA_E_SZ, key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n    if (e == NULL) {\n#ifdef WOLFSSL_SMALL_STACK\n        XFREE(n, key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n#endif\n        return MEMORY_E;\n    }\n#endif\n\n#ifdef HAVE_USER_RSA\n    eSz = SetASNIntRSA(key->e, e);\n#else\n    eSz = SetASNIntMP(&key->e, MAX_RSA_INT_SZ, e);\n#endif\n    if (eSz < 0) {\n#ifdef WOLFSSL_SMALL_STACK\n        XFREE(n, key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n        XFREE(e, key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n#endif\n        return eSz;\n    }\n\n    seqSz  = SetSequence(nSz + eSz, seq);\n\n    /* check output size */\n    if ( (seqSz + nSz + eSz) > outLen) {\n#ifdef WOLFSSL_SMALL_STACK\n        XFREE(n,    key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n        XFREE(e,    key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n#endif\n        return BUFFER_E;\n    }\n\n    /* headers */\n    if (with_header) {\n        int  algoSz;\n#ifdef WOLFSSL_SMALL_STACK\n        byte* algo;\n\n        algo = (byte*)XMALLOC(MAX_ALGO_SZ, key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n        if (algo == NULL) {\n            XFREE(n, key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n            XFREE(e, key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n            return MEMORY_E;\n        }\n#else\n        byte algo[MAX_ALGO_SZ];\n#endif\n        algoSz = SetAlgoID(RSAk, algo, oidKeyType, 0);\n        bitStringSz  = SetBitString(seqSz + nSz + eSz, 0, bitString);\n\n        idx = SetSequence(nSz + eSz + seqSz + bitStringSz + algoSz, output);\n\n        /* check output size */\n        if ( (idx + algoSz + bitStringSz + seqSz + nSz + eSz) > outLen) {\n            #ifdef WOLFSSL_SMALL_STACK\n                XFREE(n,    key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n                XFREE(e,    key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n                XFREE(algo, key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n            #endif\n\n            return BUFFER_E;\n        }\n\n        /* algo */\n        XMEMCPY(output + idx, algo, algoSz);\n        idx += algoSz;\n        /* bit string */\n        XMEMCPY(output + idx, bitString, bitStringSz);\n        idx += bitStringSz;\n#ifdef WOLFSSL_SMALL_STACK\n        XFREE(algo, key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n#endif\n    }\n    else\n        idx = 0;\n\n    /* seq */\n    XMEMCPY(output + idx, seq, seqSz);\n    idx += seqSz;\n    /* n */\n    XMEMCPY(output + idx, n, nSz);\n    idx += nSz;\n    /* e */\n    XMEMCPY(output + idx, e, eSz);\n    idx += eSz;\n\n#ifdef WOLFSSL_SMALL_STACK\n    XFREE(n,    key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n    XFREE(e,    key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n#endif\n\n    return idx;\n}\n\n#endif /* !NO_RSA && (WOLFSSL_CERT_GEN || (WOLFSSL_KEY_GEN &&\n                                           !HAVE_USER_RSA))) */\n\n#if !defined(NO_RSA) && (defined(WOLFSSL_CERT_GEN) || defined(OPENSSL_EXTRA))\nint wc_RsaPublicKeyDerSize(RsaKey* key, int with_header)\n{\n    int  idx = 0;\n    int  nSz, eSz, seqSz, bitStringSz, algoSz;\n\n    if (key == NULL)\n        return BAD_FUNC_ARG;\n\n    /* n */\n#ifdef HAVE_USER_RSA\n    nSz = SetASNIntRSA(key->n, NULL);\n#else\n    nSz = SetASNIntMP(&key->n, MAX_RSA_INT_SZ, NULL);\n#endif\n    if (nSz < 0) {\n        return nSz;\n    }\n\n    /* e */\n#ifdef HAVE_USER_RSA\n    eSz = SetASNIntRSA(key->e, NULL);\n#else\n    eSz = SetASNIntMP(&key->e, MAX_RSA_INT_SZ, NULL);\n#endif\n    if (eSz < 0) {\n        return eSz;\n    }\n\n    seqSz  = SetSequence(nSz + eSz, NULL);\n\n    /* headers */\n    if (with_header) {\n        algoSz = SetAlgoID(RSAk, NULL, oidKeyType, 0);\n        bitStringSz = SetBitString(seqSz + nSz + eSz, 0, NULL);\n\n        idx += SetSequence(nSz + eSz + seqSz + bitStringSz + algoSz, NULL);\n\n        /* algo */\n        idx += algoSz;\n        /* bit string */\n        idx += bitStringSz;\n    }\n\n    /* seq */\n    idx += seqSz;\n    /* n */\n    idx += nSz;\n    /* e */\n    idx += eSz;\n\n    return idx;\n}\n\n#endif /* !NO_RSA && WOLFSSL_CERT_GEN */\n\n\n#if defined(WOLFSSL_KEY_GEN) && !defined(NO_RSA) && !defined(HAVE_USER_RSA)\n\nstatic mp_int* GetRsaInt(RsaKey* key, int idx)\n{\n    if (idx == 0)\n        return &key->n;\n    if (idx == 1)\n        return &key->e;\n    if (idx == 2)\n        return &key->d;\n    if (idx == 3)\n        return &key->p;\n    if (idx == 4)\n        return &key->q;\n    if (idx == 5)\n        return &key->dP;\n    if (idx == 6)\n        return &key->dQ;\n    if (idx == 7)\n        return &key->u;\n\n    return NULL;\n}\n\n\n/* Release Tmp RSA resources */\nstatic WC_INLINE void FreeTmpRsas(byte** tmps, void* heap)\n{\n    int i;\n\n    (void)heap;\n\n    for (i = 0; i < RSA_INTS; i++)\n        XFREE(tmps[i], heap, DYNAMIC_TYPE_RSA);\n}\n\n\n/* Convert RsaKey key to DER format, write to output (inLen), return bytes\n   written */\nint wc_RsaKeyToDer(RsaKey* key, byte* output, word32 inLen)\n{\n    word32 seqSz, verSz, rawLen, intTotalLen = 0;\n    word32 sizes[RSA_INTS];\n    int    i, j, outLen, ret = 0, mpSz;\n\n    byte  seq[MAX_SEQ_SZ];\n    byte  ver[MAX_VERSION_SZ];\n    byte* tmps[RSA_INTS];\n\n    if (!key)\n        return BAD_FUNC_ARG;\n\n    if (key->type != RSA_PRIVATE)\n        return BAD_FUNC_ARG;\n\n    for (i = 0; i < RSA_INTS; i++)\n        tmps[i] = NULL;\n\n    /* write all big ints from key to DER tmps */\n    for (i = 0; i < RSA_INTS; i++) {\n        mp_int* keyInt = GetRsaInt(key, i);\n\n        rawLen = mp_unsigned_bin_size(keyInt) + 1;\n        tmps[i] = (byte*)XMALLOC(rawLen + MAX_SEQ_SZ, key->heap,\n                                 DYNAMIC_TYPE_RSA);\n        if (tmps[i] == NULL) {\n            ret = MEMORY_E;\n            break;\n        }\n\n        mpSz = SetASNIntMP(keyInt, MAX_RSA_INT_SZ, tmps[i]);\n        if (mpSz < 0) {\n            ret = mpSz;\n            break;\n        }\n        intTotalLen += (sizes[i] = mpSz);\n    }\n\n    if (ret != 0) {\n        FreeTmpRsas(tmps, key->heap);\n        return ret;\n    }\n\n    /* make headers */\n    verSz = SetMyVersion(0, ver, FALSE);\n    seqSz = SetSequence(verSz + intTotalLen, seq);\n\n    outLen = seqSz + verSz + intTotalLen;\n    if (output) {\n        if (outLen > (int)inLen) {\n            FreeTmpRsas(tmps, key->heap);\n            return BAD_FUNC_ARG;\n        }\n\n        /* write to output */\n        XMEMCPY(output, seq, seqSz);\n        j = seqSz;\n        XMEMCPY(output + j, ver, verSz);\n        j += verSz;\n\n        for (i = 0; i < RSA_INTS; i++) {\n            XMEMCPY(output + j, tmps[i], sizes[i]);\n            j += sizes[i];\n        }\n    }\n    FreeTmpRsas(tmps, key->heap);\n\n    return outLen;\n}\n#endif\n\n#if (defined(WOLFSSL_KEY_GEN) || defined(OPENSSL_EXTRA)) && !defined(NO_RSA) && !defined(HAVE_USER_RSA)\n/* Convert Rsa Public key to DER format, write to output (inLen), return bytes\n   written */\nint wc_RsaKeyToPublicDer(RsaKey* key, byte* output, word32 inLen)\n{\n    return SetRsaPublicKey(output, key, inLen, 1);\n}\n\n#endif /* (WOLFSSL_KEY_GEN || OPENSSL_EXTRA) && !NO_RSA && !HAVE_USER_RSA */\n\n\n#ifdef WOLFSSL_CERT_GEN\n\n/* Initialize and Set Certificate defaults:\n   version    = 3 (0x2)\n   serial     = 0\n   sigType    = SHA_WITH_RSA\n   issuer     = blank\n   daysValid  = 500\n   selfSigned = 1 (true) use subject as issuer\n   subject    = blank\n*/\nint wc_InitCert(Cert* cert)\n{\n#ifdef WOLFSSL_MULTI_ATTRIB\n    int i = 0;\n#endif\n    if (cert == NULL) {\n        return BAD_FUNC_ARG;\n    }\n\n    XMEMSET(cert, 0, sizeof(Cert));\n\n    cert->version    = 2;   /* version 3 is hex 2 */\n#ifndef NO_SHA\n    cert->sigType    = CTC_SHAwRSA;\n#elif !defined(NO_SHA256)\n    cert->sigType    = CTC_SHA256wRSA;\n#else\n    cert->sigType    = 0;\n#endif\n    cert->daysValid  = 500;\n    cert->selfSigned = 1;\n    cert->keyType    = RSA_KEY;\n\n    cert->issuer.countryEnc = CTC_PRINTABLE;\n    cert->issuer.stateEnc = CTC_UTF8;\n    cert->issuer.localityEnc = CTC_UTF8;\n    cert->issuer.surEnc = CTC_UTF8;\n    cert->issuer.orgEnc = CTC_UTF8;\n    cert->issuer.unitEnc = CTC_UTF8;\n    cert->issuer.commonNameEnc = CTC_UTF8;\n\n    cert->subject.countryEnc = CTC_PRINTABLE;\n    cert->subject.stateEnc = CTC_UTF8;\n    cert->subject.localityEnc = CTC_UTF8;\n    cert->subject.surEnc = CTC_UTF8;\n    cert->subject.orgEnc = CTC_UTF8;\n    cert->subject.unitEnc = CTC_UTF8;\n    cert->subject.commonNameEnc = CTC_UTF8;\n\n#ifdef WOLFSSL_MULTI_ATTRIB\n    for (i = 0; i < CTC_MAX_ATTRIB; i++) {\n        cert->issuer.name[i].type   = CTC_UTF8;\n        cert->subject.name[i].type  = CTC_UTF8;\n    }\n#endif /* WOLFSSL_MULTI_ATTRIB */\n\n#ifdef WOLFSSL_HEAP_TEST\n    cert->heap = (void*)WOLFSSL_HEAP_TEST;\n#endif\n\n    return 0;\n}\n\n\n/* DER encoded x509 Certificate */\ntypedef struct DerCert {\n    byte size[MAX_LENGTH_SZ];          /* length encoded */\n    byte version[MAX_VERSION_SZ];      /* version encoded */\n    byte serial[(int)CTC_SERIAL_SIZE + (int)MAX_LENGTH_SZ]; /* serial number encoded */\n    byte sigAlgo[MAX_ALGO_SZ];         /* signature algo encoded */\n    byte issuer[ASN_NAME_MAX];         /* issuer  encoded */\n    byte subject[ASN_NAME_MAX];        /* subject encoded */\n    byte validity[MAX_DATE_SIZE*2 + MAX_SEQ_SZ*2];  /* before and after dates */\n    byte publicKey[MAX_PUBLIC_KEY_SZ]; /* rsa / ntru public key encoded */\n    byte ca[MAX_CA_SZ];                /* basic constraint CA true size */\n    byte extensions[MAX_EXTENSIONS_SZ]; /* all extensions */\n#ifdef WOLFSSL_CERT_EXT\n    byte skid[MAX_KID_SZ];             /* Subject Key Identifier extension */\n    byte akid[MAX_KID_SZ];             /* Authority Key Identifier extension */\n    byte keyUsage[MAX_KEYUSAGE_SZ];    /* Key Usage extension */\n    byte extKeyUsage[MAX_EXTKEYUSAGE_SZ]; /* Extended Key Usage extension */\n    byte certPolicies[MAX_CERTPOL_NB*MAX_CERTPOL_SZ]; /* Certificate Policies */\n#endif\n#ifdef WOLFSSL_CERT_REQ\n    byte attrib[MAX_ATTRIB_SZ];        /* Cert req attributes encoded */\n#endif\n#ifdef WOLFSSL_ALT_NAMES\n    byte altNames[CTC_MAX_ALT_SIZE];   /* Alternative Names encoded */\n#endif\n    int  sizeSz;                       /* encoded size length */\n    int  versionSz;                    /* encoded version length */\n    int  serialSz;                     /* encoded serial length */\n    int  sigAlgoSz;                    /* encoded sig algo length */\n    int  issuerSz;                     /* encoded issuer length */\n    int  subjectSz;                    /* encoded subject length */\n    int  validitySz;                   /* encoded validity length */\n    int  publicKeySz;                  /* encoded public key length */\n    int  caSz;                         /* encoded CA extension length */\n#ifdef WOLFSSL_CERT_EXT\n    int  skidSz;                       /* encoded SKID extension length */\n    int  akidSz;                       /* encoded SKID extension length */\n    int  keyUsageSz;                   /* encoded KeyUsage extension length */\n    int  extKeyUsageSz;                /* encoded ExtendedKeyUsage extension length */\n    int  certPoliciesSz;               /* encoded CertPolicies extension length*/\n#endif\n#ifdef WOLFSSL_ALT_NAMES\n    int  altNamesSz;                   /* encoded AltNames extension length */\n#endif\n    int  extensionsSz;                 /* encoded extensions total length */\n    int  total;                        /* total encoded lengths */\n#ifdef WOLFSSL_CERT_REQ\n    int  attribSz;\n#endif\n} DerCert;\n\n\n#ifdef WOLFSSL_CERT_REQ\n\n/* Write a set header to output */\nstatic word32 SetPrintableString(word32 len, byte* output)\n{\n    output[0] = ASN_PRINTABLE_STRING;\n    return SetLength(len, output + 1) + 1;\n}\n\nstatic word32 SetUTF8String(word32 len, byte* output)\n{\n    output[0] = ASN_UTF8STRING;\n    return SetLength(len, output + 1) + 1;\n}\n\n#endif /* WOLFSSL_CERT_REQ */\n\n\n#ifndef WOLFSSL_CERT_GEN_CACHE\n/* wc_SetCert_Free is only public when WOLFSSL_CERT_GEN_CACHE is not defined */\nstatic\n#endif\nvoid wc_SetCert_Free(Cert* cert)\n{\n    if (cert != NULL) {\n        cert->der = NULL;\n        if (cert->decodedCert) {\n            FreeDecodedCert((DecodedCert*)cert->decodedCert);\n\n            XFREE(cert->decodedCert, cert->heap, DYNAMIC_TYPE_DCERT);\n            cert->decodedCert = NULL;\n        }\n    }\n}\n\nstatic int wc_SetCert_LoadDer(Cert* cert, const byte* der, word32 derSz)\n{\n    int ret;\n\n    if (cert == NULL) {\n        ret = BAD_FUNC_ARG;\n    }\n    else {\n        /* Allocate DecodedCert struct and Zero */\n        cert->decodedCert = (void*)XMALLOC(sizeof(DecodedCert), cert->heap,\n            DYNAMIC_TYPE_DCERT);\n\n        if (cert->decodedCert == NULL) {\n            ret = MEMORY_E;\n        }\n        else {\n            XMEMSET(cert->decodedCert, 0, sizeof(DecodedCert));\n\n            InitDecodedCert((DecodedCert*)cert->decodedCert, der, derSz,\n                    cert->heap);\n            ret = ParseCertRelative((DecodedCert*)cert->decodedCert,\n                    CERT_TYPE, 0, NULL);\n            if (ret >= 0) {\n                cert->der = (byte*)der;\n            }\n            else {\n                wc_SetCert_Free(cert);\n            }\n        }\n    }\n\n    return ret;\n}\n\n#endif /* WOLFSSL_CERT_GEN */\n\n\n#if defined(HAVE_ECC) && defined(HAVE_ECC_KEY_EXPORT)\n\n/* Write a public ECC key to output */\nstatic int SetEccPublicKey(byte* output, ecc_key* key, int with_header)\n{\n    byte bitString[1 + MAX_LENGTH_SZ + 1];\n    int  algoSz;\n    int  curveSz;\n    int  bitStringSz;\n    int  idx;\n    word32 pubSz = ECC_BUFSIZE;\n#ifdef WOLFSSL_SMALL_STACK\n    byte* algo = NULL;\n    byte* curve = NULL;\n    byte* pub;\n#else\n    byte algo[MAX_ALGO_SZ];\n    byte curve[MAX_ALGO_SZ];\n    byte pub[ECC_BUFSIZE];\n#endif\n    int ret;\n\n#ifdef WOLFSSL_SMALL_STACK\n    pub = (byte*)XMALLOC(ECC_BUFSIZE, key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n    if (pub == NULL)\n        return MEMORY_E;\n#endif\n\n#if defined(HAVE_SELFTEST) || defined(HAVE_FIPS)\n    /* older version of ecc.c can not handle dp being NULL */\n    if (key != NULL && key->dp == NULL) {\n        ret = BAD_FUNC_ARG;\n    }\n    else {\n        ret = wc_ecc_export_x963(key, pub, &pubSz);\n    }\n#else\n    ret = wc_ecc_export_x963(key, pub, &pubSz);\n#endif\n    if (ret != 0) {\n#ifdef WOLFSSL_SMALL_STACK\n        XFREE(pub, key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n#endif\n        return ret;\n    }\n\n    /* headers */\n    if (with_header) {\n#ifdef WOLFSSL_SMALL_STACK\n        curve = (byte*)XMALLOC(MAX_ALGO_SZ, key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n        if (curve == NULL) {\n            XFREE(pub, key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n            return MEMORY_E;\n        }\n#endif\n        curveSz = SetCurve(key, curve);\n        if (curveSz <= 0) {\n#ifdef WOLFSSL_SMALL_STACK\n            XFREE(curve, key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n            XFREE(pub,   key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n#endif\n            return curveSz;\n        }\n\n#ifdef WOLFSSL_SMALL_STACK\n        algo = (byte*)XMALLOC(MAX_ALGO_SZ, key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n        if (algo == NULL) {\n            XFREE(curve, key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n            XFREE(pub,   key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n            return MEMORY_E;\n        }\n#endif\n        algoSz  = SetAlgoID(ECDSAk, algo, oidKeyType, curveSz);\n\n        bitStringSz = SetBitString(pubSz, 0, bitString);\n\n        idx = SetSequence(pubSz + curveSz + bitStringSz + algoSz, output);\n        /* algo */\n        if (output)\n            XMEMCPY(output + idx, algo, algoSz);\n        idx += algoSz;\n        /* curve */\n        if (output)\n            XMEMCPY(output + idx, curve, curveSz);\n        idx += curveSz;\n        /* bit string */\n        if (output)\n            XMEMCPY(output + idx, bitString, bitStringSz);\n        idx += bitStringSz;\n    }\n    else\n        idx = 0;\n\n    /* pub */\n    if (output)\n        XMEMCPY(output + idx, pub, pubSz);\n    idx += pubSz;\n\n#ifdef WOLFSSL_SMALL_STACK\n    if (with_header) {\n        XFREE(algo,  key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n        XFREE(curve, key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n    }\n    XFREE(pub,   key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n#endif\n\n    return idx;\n}\n\n\n/* returns the size of buffer used, the public ECC key in DER format is stored\n   in output buffer\n   with_AlgCurve is a flag for when to include a header that has the Algorithm\n   and Curve information */\nint wc_EccPublicKeyToDer(ecc_key* key, byte* output, word32 inLen,\n                                                              int with_AlgCurve)\n{\n    word32 infoSz = 0;\n    word32 keySz  = 0;\n    int ret;\n\n    if (key == NULL) {\n        return BAD_FUNC_ARG;\n    }\n\n    if (with_AlgCurve) {\n        /* buffer space for algorithm/curve */\n        infoSz += MAX_SEQ_SZ;\n        infoSz += 2 * MAX_ALGO_SZ;\n\n        /* buffer space for public key sequence */\n        infoSz += MAX_SEQ_SZ;\n        infoSz += TRAILING_ZERO;\n    }\n\n#if defined(HAVE_SELFTEST) || defined(HAVE_FIPS)\n    /* older version of ecc.c can not handle dp being NULL */\n    if (key->dp == NULL) {\n        keySz = 1 + 2 * MAX_ECC_BYTES;\n        ret = LENGTH_ONLY_E;\n    }\n    else {\n        ret = wc_ecc_export_x963(key, NULL, &keySz);\n    }\n#else\n    ret = wc_ecc_export_x963(key, NULL, &keySz);\n#endif\n    if (ret != LENGTH_ONLY_E) {\n        WOLFSSL_MSG(\"Error in getting ECC public key size\");\n        return ret;\n    }\n\n    /* if output null then just return size */\n    if (output == NULL) {\n        return keySz + infoSz;\n    }\n\n    if (inLen < keySz + infoSz) {\n        return BUFFER_E;\n    }\n\n    return SetEccPublicKey(output, key, with_AlgCurve);\n}\n\nint wc_EccPublicKeyDerSize(ecc_key* key, int with_AlgCurve)\n{\n    return wc_EccPublicKeyToDer(key, NULL, 0, with_AlgCurve);\n}\n\n#endif /* HAVE_ECC && HAVE_ECC_KEY_EXPORT */\n\n#if defined(HAVE_ED25519) && (defined(WOLFSSL_CERT_GEN) || \\\n                              defined(WOLFSSL_KEY_GEN))\n\n/* Write a public ECC key to output */\nstatic int SetEd25519PublicKey(byte* output, ed25519_key* key, int with_header)\n{\n    byte bitString[1 + MAX_LENGTH_SZ + 1];\n    int  algoSz;\n    int  bitStringSz;\n    int  idx;\n    word32 pubSz = ED25519_PUB_KEY_SIZE;\n#ifdef WOLFSSL_SMALL_STACK\n    byte* algo = NULL;\n    byte* pub;\n#else\n    byte algo[MAX_ALGO_SZ];\n    byte pub[ED25519_PUB_KEY_SIZE];\n#endif\n\n#ifdef WOLFSSL_SMALL_STACK\n    pub = (byte*)XMALLOC(ECC_BUFSIZE, NULL, DYNAMIC_TYPE_TMP_BUFFER);\n    if (pub == NULL)\n        return MEMORY_E;\n#endif\n\n    idx = wc_ed25519_export_public(key, pub, &pubSz);\n    if (idx != 0) {\n#ifdef WOLFSSL_SMALL_STACK\n        XFREE(pub, NULL, DYNAMIC_TYPE_TMP_BUFFER);\n#endif\n        return idx;\n    }\n\n    /* headers */\n    if (with_header) {\n#ifdef WOLFSSL_SMALL_STACK\n        algo = (byte*)XMALLOC(MAX_ALGO_SZ, NULL, DYNAMIC_TYPE_TMP_BUFFER);\n        if (algo == NULL) {\n            XFREE(pub, NULL, DYNAMIC_TYPE_TMP_BUFFER);\n            return MEMORY_E;\n        }\n#endif\n        algoSz  = SetAlgoID(ED25519k, algo, oidKeyType, 0);\n\n        bitStringSz = SetBitString(pubSz, 0, bitString);\n\n        idx = SetSequence(pubSz + bitStringSz + algoSz, output);\n        /* algo */\n        XMEMCPY(output + idx, algo, algoSz);\n        idx += algoSz;\n        /* bit string */\n        XMEMCPY(output + idx, bitString, bitStringSz);\n        idx += bitStringSz;\n    }\n    else\n        idx = 0;\n\n    /* pub */\n    XMEMCPY(output + idx, pub, pubSz);\n    idx += pubSz;\n\n#ifdef WOLFSSL_SMALL_STACK\n    if (with_header) {\n        XFREE(algo, NULL, DYNAMIC_TYPE_TMP_BUFFER);\n    }\n    XFREE(pub, NULL, DYNAMIC_TYPE_TMP_BUFFER);\n#endif\n\n    return idx;\n}\n\nint wc_Ed25519PublicKeyToDer(ed25519_key* key, byte* output, word32 inLen,\n                                                                    int withAlg)\n{\n    word32 infoSz = 0;\n    word32 keySz  = 0;\n    int ret;\n\n    if (output == NULL || key == NULL) {\n        return BAD_FUNC_ARG;\n    }\n\n    if (withAlg) {\n        /* buffer space for algorithm */\n        infoSz += MAX_SEQ_SZ;\n        infoSz += MAX_ALGO_SZ;\n\n        /* buffer space for public key sequence */\n        infoSz += MAX_SEQ_SZ;\n        infoSz += TRAILING_ZERO;\n    }\n\n    if ((ret = wc_ed25519_export_public(key, output, &keySz)) != BUFFER_E) {\n        WOLFSSL_MSG(\"Error in getting ECC public key size\");\n        return ret;\n    }\n\n    if (inLen < keySz + infoSz) {\n        return BUFFER_E;\n    }\n\n    return SetEd25519PublicKey(output, key, withAlg);\n}\n#endif /* HAVE_ED25519 && (WOLFSSL_CERT_GEN || WOLFSSL_KEY_GEN) */\n#if defined(HAVE_ED448) && (defined(WOLFSSL_CERT_GEN) || \\\n                                                       defined(WOLFSSL_KEY_GEN))\n\n/* Write a public ECC key to output */\nstatic int SetEd448PublicKey(byte* output, ed448_key* key, int with_header)\n{\n    byte bitString[1 + MAX_LENGTH_SZ + 1];\n    int  algoSz;\n    int  bitStringSz;\n    int  idx;\n    word32 pubSz = ED448_PUB_KEY_SIZE;\n#ifdef WOLFSSL_SMALL_STACK\n    byte* algo = NULL;\n    byte* pub = NULL;\n#else\n    byte algo[MAX_ALGO_SZ];\n    byte pub[ED448_PUB_KEY_SIZE];\n#endif\n\n#ifdef WOLFSSL_SMALL_STACK\n    pub = (byte*)XMALLOC(ECC_BUFSIZE, NULL, DYNAMIC_TYPE_TMP_BUFFER);\n    if (pub == NULL)\n        return MEMORY_E;\n#endif\n\n    idx = wc_ed448_export_public(key, pub, &pubSz);\n    if (idx != 0) {\n#ifdef WOLFSSL_SMALL_STACK\n        XFREE(pub, NULL, DYNAMIC_TYPE_TMP_BUFFER);\n#endif\n        return idx;\n    }\n\n    /* headers */\n    if (with_header) {\n#ifdef WOLFSSL_SMALL_STACK\n        algo = (byte*)XMALLOC(MAX_ALGO_SZ, NULL, DYNAMIC_TYPE_TMP_BUFFER);\n        if (algo == NULL) {\n            XFREE(pub, NULL, DYNAMIC_TYPE_TMP_BUFFER);\n            return MEMORY_E;\n        }\n#endif\n        algoSz  = SetAlgoID(ED448k, algo, oidKeyType, 0);\n\n        bitStringSz = SetBitString(pubSz, 0, bitString);\n\n        idx = SetSequence(pubSz + bitStringSz + algoSz, output);\n        /* algo */\n        XMEMCPY(output + idx, algo, algoSz);\n        idx += algoSz;\n        /* bit string */\n        XMEMCPY(output + idx, bitString, bitStringSz);\n        idx += bitStringSz;\n    }\n    else\n        idx = 0;\n\n    /* pub */\n    XMEMCPY(output + idx, pub, pubSz);\n    idx += pubSz;\n\n#ifdef WOLFSSL_SMALL_STACK\n    if (with_header) {\n        XFREE(algo, NULL, DYNAMIC_TYPE_TMP_BUFFER);\n    }\n    XFREE(pub, NULL, DYNAMIC_TYPE_TMP_BUFFER);\n#endif\n\n    return idx;\n}\n\nint wc_Ed448PublicKeyToDer(ed448_key* key, byte* output, word32 inLen,\n                                                                    int withAlg)\n{\n    word32 infoSz = 0;\n    word32 keySz  = 0;\n    int ret;\n\n    if (output == NULL || key == NULL) {\n        return BAD_FUNC_ARG;\n    }\n\n    if (withAlg) {\n        /* buffer space for algorithm */\n        infoSz += MAX_SEQ_SZ;\n        infoSz += MAX_ALGO_SZ;\n\n        /* buffer space for public key sequence */\n        infoSz += MAX_SEQ_SZ;\n        infoSz += TRAILING_ZERO;\n    }\n\n    if ((ret = wc_ed448_export_public(key, output, &keySz)) != BUFFER_E) {\n        WOLFSSL_MSG(\"Error in getting ECC public key size\");\n        return ret;\n    }\n\n    if (inLen < keySz + infoSz) {\n        return BUFFER_E;\n    }\n\n    return SetEd448PublicKey(output, key, withAlg);\n}\n#endif /* HAVE_ED448 && (WOLFSSL_CERT_GEN || WOLFSSL_KEY_GEN) */\n\n\n#ifdef WOLFSSL_CERT_GEN\n\n#ifndef NO_ASN_TIME\nstatic WC_INLINE byte itob(int number)\n{\n    return (byte)number + 0x30;\n}\n\n\n/* write time to output, format */\nstatic void SetTime(struct tm* date, byte* output)\n{\n    int i = 0;\n\n    output[i++] = itob((date->tm_year % 10000) / 1000);\n    output[i++] = itob((date->tm_year % 1000)  /  100);\n    output[i++] = itob((date->tm_year % 100)   /   10);\n    output[i++] = itob( date->tm_year % 10);\n\n    output[i++] = itob(date->tm_mon / 10);\n    output[i++] = itob(date->tm_mon % 10);\n\n    output[i++] = itob(date->tm_mday / 10);\n    output[i++] = itob(date->tm_mday % 10);\n\n    output[i++] = itob(date->tm_hour / 10);\n    output[i++] = itob(date->tm_hour % 10);\n\n    output[i++] = itob(date->tm_min / 10);\n    output[i++] = itob(date->tm_min % 10);\n\n    output[i++] = itob(date->tm_sec / 10);\n    output[i++] = itob(date->tm_sec % 10);\n\n    output[i] = 'Z';  /* Zulu profile */\n}\n#endif\n\n#ifdef WOLFSSL_ALT_NAMES\n\n/* Copy Dates from cert, return bytes written */\nstatic int CopyValidity(byte* output, Cert* cert)\n{\n    int seqSz;\n\n    WOLFSSL_ENTER(\"CopyValidity\");\n\n    /* headers and output */\n    seqSz = SetSequence(cert->beforeDateSz + cert->afterDateSz, output);\n    if (output) {\n        XMEMCPY(output + seqSz, cert->beforeDate, cert->beforeDateSz);\n        XMEMCPY(output + seqSz + cert->beforeDateSz, cert->afterDate,\n                                                     cert->afterDateSz);\n    }\n    return seqSz + cert->beforeDateSz + cert->afterDateSz;\n}\n\n#endif\n\n/* Get Which Name from index */\nconst char* GetOneCertName(CertName* name, int idx)\n{\n    switch (idx) {\n    case 0:\n       return name->country;\n\n    case 1:\n       return name->state;\n\n    case 2:\n       return name->locality;\n\n    case 3:\n       return name->sur;\n\n    case 4:\n       return name->org;\n\n    case 5:\n       return name->unit;\n\n    case 6:\n       return name->commonName;\n\n    case 7:\n       return name->serialDev;\n\n#ifdef WOLFSSL_CERT_EXT\n    case 8:\n       return name->busCat;\n\n    case 9:\n#else\n    case 8:\n#endif\n       return name->email;\n\n    default:\n       return 0;\n    }\n}\n\n\n/* Get Which Name Encoding from index */\nstatic char GetNameType(CertName* name, int idx)\n{\n    switch (idx) {\n    case 0:\n       return name->countryEnc;\n\n    case 1:\n       return name->stateEnc;\n\n    case 2:\n       return name->localityEnc;\n\n    case 3:\n       return name->surEnc;\n\n    case 4:\n       return name->orgEnc;\n\n    case 5:\n       return name->unitEnc;\n\n    case 6:\n       return name->commonNameEnc;\n\n    case 7:\n       return name->serialDevEnc;\n\n#ifdef WOLFSSL_CERT_EXT\n    case 8:\n       return name->busCatEnc;\n\n    case 9:\n#else\n    case 8:\n#endif\n        /* FALL THROUGH */\n        /* The last index, email name, does not have encoding type.\n           The empty case here is to keep track of it for future reference. */\n    default:\n       return 0;\n    }\n}\n\n\n/* Get ASN Name from index */\nbyte GetCertNameId(int idx)\n{\n    switch (idx) {\n    case 0:\n       return ASN_COUNTRY_NAME;\n\n    case 1:\n       return ASN_STATE_NAME;\n\n    case 2:\n       return ASN_LOCALITY_NAME;\n\n    case 3:\n       return ASN_SUR_NAME;\n\n    case 4:\n       return ASN_ORG_NAME;\n\n    case 5:\n       return ASN_ORGUNIT_NAME;\n\n    case 6:\n       return ASN_COMMON_NAME;\n\n    case 7:\n       return ASN_SERIAL_NUMBER;\n\n#ifdef WOLFSSL_CERT_EXT\n    case 8:\n        return ASN_BUS_CAT;\n\n    case 9:\n#else\n    case 8:\n#endif\n        return ASN_EMAIL_NAME;\n\n    default:\n       return 0;\n    }\n}\n\n\n/*\n Extensions ::= SEQUENCE OF Extension\n\n Extension ::= SEQUENCE {\n extnId     OBJECT IDENTIFIER,\n critical   BOOLEAN DEFAULT FALSE,\n extnValue  OCTET STRING }\n */\n\n/* encode all extensions, return total bytes written */\nstatic int SetExtensions(byte* out, word32 outSz, int *IdxInOut,\n                         const byte* ext, int extSz)\n{\n    if (out == NULL || IdxInOut == NULL || ext == NULL)\n        return BAD_FUNC_ARG;\n\n    if (outSz < (word32)(*IdxInOut+extSz))\n        return BUFFER_E;\n\n    XMEMCPY(&out[*IdxInOut], ext, extSz);  /* extensions */\n    *IdxInOut += extSz;\n\n    return *IdxInOut;\n}\n\n/* encode extensions header, return total bytes written */\nstatic int SetExtensionsHeader(byte* out, word32 outSz, int extSz)\n{\n    byte sequence[MAX_SEQ_SZ];\n    byte len[MAX_LENGTH_SZ];\n    int seqSz, lenSz, idx = 0;\n\n    if (out == NULL)\n        return BAD_FUNC_ARG;\n\n    if (outSz < 3)\n        return BUFFER_E;\n\n    seqSz = SetSequence(extSz, sequence);\n\n    /* encode extensions length provided */\n    lenSz = SetLength(extSz+seqSz, len);\n\n    if (outSz < (word32)(lenSz+seqSz+1))\n        return BUFFER_E;\n\n    out[idx++] = ASN_EXTENSIONS; /* extensions id */\n    XMEMCPY(&out[idx], len, lenSz);  /* length */\n    idx += lenSz;\n\n    XMEMCPY(&out[idx], sequence, seqSz);  /* sequence */\n    idx += seqSz;\n\n    return idx;\n}\n\n\n/* encode CA basic constraint true, return total bytes written */\nstatic int SetCa(byte* out, word32 outSz)\n{\n    const byte ca[] = { 0x30, 0x0c, 0x06, 0x03, 0x55, 0x1d, 0x13, 0x04,\n                               0x05, 0x30, 0x03, 0x01, 0x01, 0xff };\n\n    if (out == NULL)\n        return BAD_FUNC_ARG;\n\n    if (outSz < sizeof(ca))\n        return BUFFER_E;\n\n    XMEMCPY(out, ca, sizeof(ca));\n\n    return (int)sizeof(ca);\n}\n\n\n#ifdef WOLFSSL_CERT_EXT\n/* encode OID and associated value, return total bytes written */\nstatic int SetOidValue(byte* out, word32 outSz, const byte *oid, word32 oidSz,\n                       byte *in, word32 inSz)\n{\n    int idx = 0;\n\n    if (out == NULL || oid == NULL || in == NULL)\n        return BAD_FUNC_ARG;\n\n    if (outSz < 3)\n        return BUFFER_E;\n\n    /* sequence,  + 1 => byte to put value size */\n    idx = SetSequence(inSz + oidSz + 1, out);\n\n    if ((idx + inSz + oidSz + 1) > outSz)\n        return BUFFER_E;\n\n    XMEMCPY(out+idx, oid, oidSz);\n    idx += oidSz;\n    out[idx++] = (byte)inSz;\n    XMEMCPY(out+idx, in, inSz);\n\n    return (idx+inSz);\n}\n\n/* encode Subject Key Identifier, return total bytes written\n * RFC5280 : non-critical */\nstatic int SetSKID(byte* output, word32 outSz, const byte *input, word32 length)\n{\n    byte skid_len[1 + MAX_LENGTH_SZ];\n    byte skid_enc_len[MAX_LENGTH_SZ];\n    int idx = 0, skid_lenSz, skid_enc_lenSz;\n    const byte skid_oid[] = { 0x06, 0x03, 0x55, 0x1d, 0x0e, 0x04 };\n\n    if (output == NULL || input == NULL)\n        return BAD_FUNC_ARG;\n\n    /* Octet String header */\n    skid_lenSz = SetOctetString(length, skid_len);\n\n    /* length of encoded value */\n    skid_enc_lenSz = SetLength(length + skid_lenSz, skid_enc_len);\n\n    if (outSz < 3)\n        return BUFFER_E;\n\n    idx = SetSequence(length + sizeof(skid_oid) + skid_lenSz + skid_enc_lenSz,\n                      output);\n\n    if ((length + sizeof(skid_oid) + skid_lenSz + skid_enc_lenSz) > outSz)\n        return BUFFER_E;\n\n    /* put oid */\n    XMEMCPY(output+idx, skid_oid, sizeof(skid_oid));\n    idx += sizeof(skid_oid);\n\n    /* put encoded len */\n    XMEMCPY(output+idx, skid_enc_len, skid_enc_lenSz);\n    idx += skid_enc_lenSz;\n\n    /* put octet header */\n    XMEMCPY(output+idx, skid_len, skid_lenSz);\n    idx += skid_lenSz;\n\n    /* put value */\n    XMEMCPY(output+idx, input, length);\n    idx += length;\n\n    return idx;\n}\n\n/* encode Authority Key Identifier, return total bytes written\n * RFC5280 : non-critical */\nstatic int SetAKID(byte* output, word32 outSz,\n                                         byte *input, word32 length, void* heap)\n{\n    byte    *enc_val;\n    int     ret, enc_valSz;\n    const byte akid_oid[] = { 0x06, 0x03, 0x55, 0x1d, 0x23, 0x04 };\n    const byte akid_cs[] = { 0x80 };\n\n    (void)heap;\n\n    if (output == NULL || input == NULL)\n        return BAD_FUNC_ARG;\n\n    enc_valSz = length + 3 + sizeof(akid_cs);\n    enc_val = (byte *)XMALLOC(enc_valSz, heap, DYNAMIC_TYPE_TMP_BUFFER);\n    if (enc_val == NULL)\n        return MEMORY_E;\n\n    /* sequence for ContentSpec & value */\n    ret = SetOidValue(enc_val, enc_valSz, akid_cs, sizeof(akid_cs),\n                      input, length);\n    if (ret > 0) {\n        enc_valSz = ret;\n\n        ret = SetOidValue(output, outSz, akid_oid, sizeof(akid_oid),\n                          enc_val, enc_valSz);\n    }\n\n    XFREE(enc_val, heap, DYNAMIC_TYPE_TMP_BUFFER);\n    return ret;\n}\n\n/* encode Key Usage, return total bytes written\n * RFC5280 : critical */\nstatic int SetKeyUsage(byte* output, word32 outSz, word16 input)\n{\n    byte ku[5];\n    int  idx;\n    const byte keyusage_oid[] = { 0x06, 0x03, 0x55, 0x1d, 0x0f,\n                                         0x01, 0x01, 0xff, 0x04};\n    if (output == NULL)\n        return BAD_FUNC_ARG;\n\n    idx = SetBitString16Bit(input, ku);\n    return SetOidValue(output, outSz, keyusage_oid, sizeof(keyusage_oid),\n                       ku, idx);\n}\n\nstatic int SetOjectIdValue(byte* output, word32 outSz, int* idx,\n    const byte* oid, word32 oidSz)\n{\n    /* verify room */\n    if (*idx + 2 + oidSz >= outSz)\n        return ASN_PARSE_E;\n\n    *idx += SetObjectId(oidSz, &output[*idx]);\n    XMEMCPY(&output[*idx], oid, oidSz);\n    *idx += oidSz;\n\n    return 0;\n}\n\n/* encode Extended Key Usage (RFC 5280 4.2.1.12), return total bytes written */\nstatic int SetExtKeyUsage(Cert* cert, byte* output, word32 outSz, byte input)\n{\n    int idx = 0, oidListSz = 0, totalSz, ret = 0;\n    const byte extkeyusage_oid[] = { 0x06, 0x03, 0x55, 0x1d, 0x25 };\n\n    if (output == NULL)\n        return BAD_FUNC_ARG;\n\n    /* Skip to OID List */\n    totalSz = 2 + sizeof(extkeyusage_oid) + 4;\n    idx = totalSz;\n\n    /* Build OID List */\n    /* If any set, then just use it */\n    if (input & EXTKEYUSE_ANY) {\n        ret |= SetOjectIdValue(output, outSz, &idx,\n            extExtKeyUsageAnyOid, sizeof(extExtKeyUsageAnyOid));\n    }\n    else {\n        if (input & EXTKEYUSE_SERVER_AUTH)\n            ret |= SetOjectIdValue(output, outSz, &idx,\n                extExtKeyUsageServerAuthOid, sizeof(extExtKeyUsageServerAuthOid));\n        if (input & EXTKEYUSE_CLIENT_AUTH)\n            ret |= SetOjectIdValue(output, outSz, &idx,\n                extExtKeyUsageClientAuthOid, sizeof(extExtKeyUsageClientAuthOid));\n        if (input & EXTKEYUSE_CODESIGN)\n            ret |= SetOjectIdValue(output, outSz, &idx,\n                extExtKeyUsageCodeSigningOid, sizeof(extExtKeyUsageCodeSigningOid));\n        if (input & EXTKEYUSE_EMAILPROT)\n            ret |= SetOjectIdValue(output, outSz, &idx,\n                extExtKeyUsageEmailProtectOid, sizeof(extExtKeyUsageEmailProtectOid));\n        if (input & EXTKEYUSE_TIMESTAMP)\n            ret |= SetOjectIdValue(output, outSz, &idx,\n                extExtKeyUsageTimestampOid, sizeof(extExtKeyUsageTimestampOid));\n        if (input & EXTKEYUSE_OCSP_SIGN)\n            ret |= SetOjectIdValue(output, outSz, &idx,\n                extExtKeyUsageOcspSignOid, sizeof(extExtKeyUsageOcspSignOid));\n    #ifdef WOLFSSL_EKU_OID\n        /* iterate through OID values */\n        if (input & EXTKEYUSE_USER) {\n            int i, sz;\n            for (i = 0; i < CTC_MAX_EKU_NB; i++) {\n                sz = cert->extKeyUsageOIDSz[i];\n                if (sz > 0) {\n                    ret |= SetOjectIdValue(output, outSz, &idx,\n                        cert->extKeyUsageOID[i], sz);\n                }\n            }\n        }\n    #endif /* WOLFSSL_EKU_OID */\n    }\n    if (ret != 0)\n        return ASN_PARSE_E;\n\n    /* Calculate Sizes */\n    oidListSz = idx - totalSz;\n    totalSz = idx - 2; /* exclude first seq/len (2) */\n\n    /* 1. Seq + Total Len (2) */\n    idx = SetSequence(totalSz, output);\n\n    /* 2. Object ID (2) */\n    XMEMCPY(&output[idx], extkeyusage_oid, sizeof(extkeyusage_oid));\n    idx += sizeof(extkeyusage_oid);\n\n    /* 3. Octet String (2) */\n    idx += SetOctetString(totalSz - idx, &output[idx]);\n\n    /* 4. Seq + OidListLen (2) */\n    idx += SetSequence(oidListSz, &output[idx]);\n\n    /* 5. Oid List (already set in-place above) */\n    idx += oidListSz;\n\n    (void)cert;\n    return idx;\n}\n\n/* encode Certificate Policies, return total bytes written\n * each input value must be ITU-T X.690 formatted : a.b.c...\n * input must be an array of values with a NULL terminated for the latest\n * RFC5280 : non-critical */\nstatic int SetCertificatePolicies(byte *output,\n                                  word32 outputSz,\n                                  char input[MAX_CERTPOL_NB][MAX_CERTPOL_SZ],\n                                  word16 nb_certpol,\n                                  void* heap)\n{\n    byte    oid[MAX_OID_SZ],\n            der_oid[MAX_CERTPOL_NB][MAX_OID_SZ],\n            out[MAX_CERTPOL_SZ];\n    word32  oidSz;\n    word32  outSz, i = 0, der_oidSz[MAX_CERTPOL_NB];\n    int     ret;\n\n    const byte certpol_oid[] = { 0x06, 0x03, 0x55, 0x1d, 0x20, 0x04 };\n    const byte oid_oid[] = { 0x06 };\n\n    if (output == NULL || input == NULL || nb_certpol > MAX_CERTPOL_NB)\n        return BAD_FUNC_ARG;\n\n    for (i = 0; i < nb_certpol; i++) {\n        oidSz = sizeof(oid);\n        XMEMSET(oid, 0, oidSz);\n\n        ret = EncodePolicyOID(oid, &oidSz, input[i], heap);\n        if (ret != 0)\n            return ret;\n\n        /* compute sequence value for the oid */\n        ret = SetOidValue(der_oid[i], MAX_OID_SZ, oid_oid,\n                          sizeof(oid_oid), oid, oidSz);\n        if (ret <= 0)\n            return ret;\n        else\n            der_oidSz[i] = (word32)ret;\n    }\n\n    /* concatenate oid, keep two byte for sequence/size of the created value */\n    for (i = 0, outSz = 2; i < nb_certpol; i++) {\n        XMEMCPY(out+outSz, der_oid[i], der_oidSz[i]);\n        outSz += der_oidSz[i];\n    }\n\n    /* add sequence */\n    ret = SetSequence(outSz-2, out);\n    if (ret <= 0)\n        return ret;\n\n    /* add Policy OID to compute final value */\n    return SetOidValue(output, outputSz, certpol_oid, sizeof(certpol_oid),\n                      out, outSz);\n}\n#endif /* WOLFSSL_CERT_EXT */\n\n\n#ifdef WOLFSSL_ALT_NAMES\n\n/* encode Alternative Names, return total bytes written */\nstatic int SetAltNames(byte *output, word32 outSz,\n        const byte *input, word32 length)\n{\n    byte san_len[1 + MAX_LENGTH_SZ];\n    int idx = 0, san_lenSz;\n    const byte san_oid[] = { 0x06, 0x03, 0x55, 0x1d, 0x11 };\n\n    if (output == NULL || input == NULL)\n        return BAD_FUNC_ARG;\n\n    if (outSz < length)\n        return BUFFER_E;\n\n    /* Octet String header */\n    san_lenSz = SetOctetString(length, san_len);\n\n    if (outSz < MAX_SEQ_SZ)\n        return BUFFER_E;\n\n    idx = SetSequence(length + sizeof(san_oid) + san_lenSz, output);\n\n    if ((length + sizeof(san_oid) + san_lenSz) > outSz)\n        return BUFFER_E;\n\n    /* put oid */\n    XMEMCPY(output+idx, san_oid, sizeof(san_oid));\n    idx += sizeof(san_oid);\n\n    /* put octet header */\n    XMEMCPY(output+idx, san_len, san_lenSz);\n    idx += san_lenSz;\n\n    /* put value */\n    XMEMCPY(output+idx, input, length);\n    idx += length;\n\n    return idx;\n}\n\n\n#ifdef WOLFSSL_CERT_GEN\n\nint FlattenAltNames(byte* output, word32 outputSz, const DNS_entry* names)\n{\n    word32 idx;\n    const DNS_entry* curName;\n    word32 namesSz = 0;\n\n    if (output == NULL)\n        return BAD_FUNC_ARG;\n\n    if (names == NULL)\n        return 0;\n\n    curName = names;\n    do {\n        namesSz += curName->len + 2 +\n            ((curName->len < ASN_LONG_LENGTH) ? 0\n             : BytePrecision(curName->len));\n        curName = curName->next;\n    } while (curName != NULL);\n\n    if (outputSz < MAX_SEQ_SZ + namesSz)\n        return BUFFER_E;\n\n    idx = SetSequence(namesSz, output);\n\n    curName = names;\n    do {\n        output[idx] = ASN_CONTEXT_SPECIFIC | curName->type;\n        if (curName->type == ASN_DIR_TYPE) {\n            output[idx] |= ASN_CONSTRUCTED;\n        }\n        idx++;\n        idx += SetLength(curName->len, output + idx);\n        XMEMCPY(output + idx, curName->name, curName->len);\n        idx += curName->len;\n        curName = curName->next;\n    } while (curName != NULL);\n\n    return idx;\n}\n\n#endif /* WOLFSSL_CERT_GEN */\n\n#endif /* WOLFSSL_ALT_NAMES */\n\n/* Encodes one attribute of the name (issuer/subject)\n *\n * name     structure to hold result of encoding\n * nameStr  value to be encoded\n * nameType type of encoding i.e CTC_UTF8\n * type     id of attribute i.e ASN_COMMON_NAME\n * emailType type of email i.e CTC_UTF8\n * returns length on success\n */\nstatic int wc_EncodeName_ex(EncodedName* name, const char* nameStr, char nameType,\n                  byte type, byte emailType)\n{\n    word32 idx = 0;\n    /* bottom up */\n    byte firstLen[1 + MAX_LENGTH_SZ];\n    byte secondLen[MAX_LENGTH_SZ];\n    byte sequence[MAX_SEQ_SZ];\n    byte set[MAX_SET_SZ];\n\n    int strLen;\n    int thisLen;\n    int firstSz, secondSz, seqSz, setSz;\n\n    if (nameStr == NULL) {\n        name->used = 0;\n        return 0;\n    }\n    thisLen = strLen = (int)XSTRLEN(nameStr);\n    if (strLen == 0) { /* no user data for this item */\n        name->used = 0;\n        return 0;\n    }\n\n    /* Restrict country code size */\n    if (ASN_COUNTRY_NAME == type && strLen != CTC_COUNTRY_SIZE) {\n        WOLFSSL_MSG(\"Country code size error\");\n        return ASN_COUNTRY_SIZE_E;\n    }\n\n    secondSz = SetLength(strLen, secondLen);\n    thisLen += secondSz;\n    switch (type) {\n        case ASN_EMAIL_NAME: /* email */\n            thisLen += EMAIL_JOINT_LEN;\n            firstSz  = EMAIL_JOINT_LEN;\n            break;\n\n        case ASN_DOMAIN_COMPONENT:\n            thisLen += PILOT_JOINT_LEN;\n            firstSz  = PILOT_JOINT_LEN;\n            break;\n\n        default:\n            thisLen++;                                 /* str type */\n            thisLen += JOINT_LEN;\n            firstSz  = JOINT_LEN + 1;\n    }\n    thisLen++; /* id  type */\n    firstSz  = SetObjectId(firstSz, firstLen);\n    thisLen += firstSz;\n\n    seqSz = SetSequence(thisLen, sequence);\n    thisLen += seqSz;\n    setSz = SetSet(thisLen, set);\n    thisLen += setSz;\n\n    if (thisLen > (int)sizeof(name->encoded)) {\n        return BUFFER_E;\n    }\n\n    /* store it */\n    idx = 0;\n    /* set */\n    XMEMCPY(name->encoded, set, setSz);\n    idx += setSz;\n    /* seq */\n    XMEMCPY(name->encoded + idx, sequence, seqSz);\n    idx += seqSz;\n    /* asn object id */\n    XMEMCPY(name->encoded + idx, firstLen, firstSz);\n    idx += firstSz;\n    switch (type) {\n        case ASN_EMAIL_NAME:\n        {\n            const byte EMAIL_OID[] = {\n                0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x09, 0x01\n            };\n            /* email joint id */\n            XMEMCPY(name->encoded + idx, EMAIL_OID, sizeof(EMAIL_OID));\n            idx += (int)sizeof(EMAIL_OID);\n            name->encoded[idx++] = emailType;\n            break;\n        }\n\n        case ASN_DOMAIN_COMPONENT:\n        {\n            const byte PILOT_OID[] = {\n                0x09, 0x92, 0x26, 0x89, 0x93, 0xF2, 0x2C, 0x64, 0x01\n            };\n\n            XMEMCPY(name->encoded + idx, PILOT_OID, sizeof(PILOT_OID));\n            idx += (int)sizeof(PILOT_OID);\n            /* id type */\n            name->encoded[idx++] = type;\n            /* str type */\n            name->encoded[idx++] = nameType;\n            break;\n        }\n\n        default:\n            name->encoded[idx++] = 0x55;\n            name->encoded[idx++] = 0x04;\n            /* id type */\n            name->encoded[idx++] = type;\n            /* str type */\n            name->encoded[idx++] = nameType;\n    }\n    /* second length */\n    XMEMCPY(name->encoded + idx, secondLen, secondSz);\n    idx += secondSz;\n    /* str value */\n    XMEMCPY(name->encoded + idx, nameStr, strLen);\n    idx += strLen;\n\n    name->type = type;\n    name->totalLen = idx;\n    name->used = 1;\n\n    return idx;\n}\n\n/* canonical encoding one attribute of the name (issuer/subject)\n * call wc_EncodeName_ex with CTC_UTF8 for email type\n *\n * name     structure to hold result of encoding\n * nameStr  value to be encoded\n * nameType type of encoding i.e CTC_UTF8\n * type     id of attribute i.e ASN_COMMON_NAME\n *\n * returns length on success\n */\nint wc_EncodeNameCanonical(EncodedName* name, const char* nameStr, char nameType,\n        byte type)\n{\n    return wc_EncodeName_ex(name, nameStr, nameType, type, 0x0c/* CTC_UTF8 */);\n}\n\n/* Encodes one attribute of the name (issuer/subject)\n * call we_EncodeName_ex with 0x16, IA5String for email type\n * name     structure to hold result of encoding\n * nameStr  value to be encoded\n * nameType type of encoding i.e CTC_UTF8\n * type     id of attribute i.e ASN_COMMON_NAME\n *\n * returns length on success\n */\nint wc_EncodeName(EncodedName* name, const char* nameStr, char nameType,\n                  byte type)\n{\n    return wc_EncodeName_ex(name, nameStr, nameType, type, ASN_IA5_STRING);\n}\n/* encode CertName into output, return total bytes written */\nint SetName(byte* output, word32 outputSz, CertName* name)\n{\n    int          totalBytes = 0, i, idx;\n#ifdef WOLFSSL_SMALL_STACK\n    EncodedName* names = NULL;\n#else\n    EncodedName  names[NAME_ENTRIES];\n#endif\n#ifdef WOLFSSL_MULTI_ATTRIB\n    EncodedName addNames[CTC_MAX_ATTRIB];\n    int j, type;\n#endif\n\n    if (output == NULL || name == NULL)\n        return BAD_FUNC_ARG;\n\n    if (outputSz < 3)\n        return BUFFER_E;\n\n#ifdef WOLFSSL_SMALL_STACK\n    names = (EncodedName*)XMALLOC(sizeof(EncodedName) * NAME_ENTRIES, NULL,\n                                                       DYNAMIC_TYPE_TMP_BUFFER);\n    if (names == NULL)\n        return MEMORY_E;\n#endif\n\n    for (i = 0; i < NAME_ENTRIES; i++) {\n        int ret;\n        const char* nameStr = GetOneCertName(name, i);\n\n        ret = wc_EncodeName(&names[i], nameStr, GetNameType(name, i),\n                          GetCertNameId(i));\n        if (ret < 0) {\n        #ifdef WOLFSSL_SMALL_STACK\n            XFREE(names, NULL, DYNAMIC_TYPE_TMP_BUFFER);\n        #endif\n            WOLFSSL_MSG(\"EncodeName failed\");\n            return BUFFER_E;\n        }\n        totalBytes += ret;\n    }\n#ifdef WOLFSSL_MULTI_ATTRIB\n    for (i = 0; i < CTC_MAX_ATTRIB; i++) {\n        if (name->name[i].sz > 0) {\n            int ret;\n            ret = wc_EncodeName(&addNames[i], name->name[i].value,\n                        name->name[i].type, name->name[i].id);\n            if (ret < 0) {\n            #ifdef WOLFSSL_SMALL_STACK\n                XFREE(names, NULL, DYNAMIC_TYPE_TMP_BUFFER);\n            #endif\n                WOLFSSL_MSG(\"EncodeName on multiple attributes failed\\n\");\n                return BUFFER_E;\n            }\n            totalBytes += ret;\n        }\n        else {\n            addNames[i].used = 0;\n        }\n    }\n#endif /* WOLFSSL_MULTI_ATTRIB */\n\n    /* header */\n    idx = SetSequence(totalBytes, output);\n    totalBytes += idx;\n    if (totalBytes > ASN_NAME_MAX) {\n#ifdef WOLFSSL_SMALL_STACK\n        XFREE(names, NULL, DYNAMIC_TYPE_TMP_BUFFER);\n#endif\n        WOLFSSL_MSG(\"Total Bytes is greater than ASN_NAME_MAX\");\n        return BUFFER_E;\n    }\n\n    for (i = 0; i < NAME_ENTRIES; i++) {\n    #ifdef WOLFSSL_MULTI_ATTRIB\n        type = GetCertNameId(i);\n\n        /* list all DC values before OUs */\n        if (type == ASN_ORGUNIT_NAME) {\n            type = ASN_DOMAIN_COMPONENT;\n            for (j = 0; j < CTC_MAX_ATTRIB; j++) {\n                if (name->name[j].sz > 0 && type == name->name[j].id) {\n                    if (outputSz < (word32)(idx+addNames[j].totalLen)) {\n                    #ifdef WOLFSSL_SMALL_STACK\n                        XFREE(names, NULL, DYNAMIC_TYPE_TMP_BUFFER);\n                    #endif\n                        WOLFSSL_MSG(\"Not enough space left for DC value\");\n                        return BUFFER_E;\n                    }\n\n                    XMEMCPY(output + idx, addNames[j].encoded,\n                            addNames[j].totalLen);\n                    idx += addNames[j].totalLen;\n                }\n            }\n            type = ASN_ORGUNIT_NAME;\n        }\n\n        /* write all similar types to the buffer */\n        for (j = 0; j < CTC_MAX_ATTRIB; j++) {\n            if (name->name[j].sz > 0 && type == name->name[j].id) {\n                if (outputSz < (word32)(idx+addNames[j].totalLen)) {\n                #ifdef WOLFSSL_SMALL_STACK\n                    XFREE(names, NULL, DYNAMIC_TYPE_TMP_BUFFER);\n                #endif\n                    return BUFFER_E;\n                }\n\n                XMEMCPY(output + idx, addNames[j].encoded,\n                        addNames[j].totalLen);\n                idx += addNames[j].totalLen;\n            }\n        }\n    #endif /* WOLFSSL_MULTI_ATTRIB */\n\n        if (names[i].used) {\n            if (outputSz < (word32)(idx+names[i].totalLen)) {\n#ifdef WOLFSSL_SMALL_STACK\n                XFREE(names, NULL, DYNAMIC_TYPE_TMP_BUFFER);\n#endif\n                return BUFFER_E;\n            }\n\n            XMEMCPY(output + idx, names[i].encoded, names[i].totalLen);\n            idx += names[i].totalLen;\n        }\n    }\n\n#ifdef WOLFSSL_SMALL_STACK\n    XFREE(names, NULL, DYNAMIC_TYPE_TMP_BUFFER);\n#endif\n\n    return totalBytes;\n}\n\n/* Set Date validity from now until now + daysValid\n * return size in bytes written to output, 0 on error */\nstatic int SetValidity(byte* output, int daysValid)\n{\n#ifndef NO_ASN_TIME\n    byte before[MAX_DATE_SIZE];\n    byte  after[MAX_DATE_SIZE];\n\n    int beforeSz;\n    int afterSz;\n    int seqSz;\n\n    time_t now;\n    time_t then;\n    struct tm* tmpTime;\n    struct tm* expandedTime;\n    struct tm localTime;\n\n#if defined(NEED_TMP_TIME)\n    /* for use with gmtime_r */\n    struct tm tmpTimeStorage;\n    tmpTime = &tmpTimeStorage;\n#else\n    tmpTime = NULL;\n#endif\n    (void)tmpTime;\n\n    now = XTIME(0);\n\n    /* before now */\n    before[0] = ASN_GENERALIZED_TIME;\n    beforeSz = SetLength(ASN_GEN_TIME_SZ, before + 1) + 1;  /* gen tag */\n\n    /* subtract 1 day of seconds for more compliance */\n    then = now - 86400;\n    expandedTime = XGMTIME(&then, tmpTime);\n    if (expandedTime == NULL) {\n        WOLFSSL_MSG(\"XGMTIME failed\");\n        return 0;   /* error */\n    }\n    localTime = *expandedTime;\n\n    /* adjust */\n    localTime.tm_year += 1900;\n    localTime.tm_mon +=    1;\n\n    SetTime(&localTime, before + beforeSz);\n    beforeSz += ASN_GEN_TIME_SZ;\n\n    after[0] = ASN_GENERALIZED_TIME;\n    afterSz  = SetLength(ASN_GEN_TIME_SZ, after + 1) + 1;  /* gen tag */\n\n    /* add daysValid of seconds */\n    then = now + (daysValid * (time_t)86400);\n    expandedTime = XGMTIME(&then, tmpTime);\n    if (expandedTime == NULL) {\n        WOLFSSL_MSG(\"XGMTIME failed\");\n        return 0;   /* error */\n    }\n    localTime = *expandedTime;\n\n    /* adjust */\n    localTime.tm_year += 1900;\n    localTime.tm_mon  +=    1;\n\n    SetTime(&localTime, after + afterSz);\n    afterSz += ASN_GEN_TIME_SZ;\n\n    /* headers and output */\n    seqSz = SetSequence(beforeSz + afterSz, output);\n    XMEMCPY(output + seqSz, before, beforeSz);\n    XMEMCPY(output + seqSz + beforeSz, after, afterSz);\n\n    return seqSz + beforeSz + afterSz;\n#else\n    (void)output;\n    (void)daysValid;\n    return NOT_COMPILED_IN;\n#endif\n}\n\n/* encode info from cert into DER encoded format */\nstatic int EncodeCert(Cert* cert, DerCert* der, RsaKey* rsaKey, ecc_key* eccKey,\n                      WC_RNG* rng, const byte* ntruKey, word16 ntruSz, DsaKey* dsaKey,\n                      ed25519_key* ed25519Key, ed448_key* ed448Key)\n{\n    int ret;\n\n    if (cert == NULL || der == NULL || rng == NULL)\n        return BAD_FUNC_ARG;\n\n    /* make sure at least one key type is provided */\n    if (rsaKey == NULL && eccKey == NULL && ed25519Key == NULL &&\n            dsaKey == NULL && ed448Key == NULL && ntruKey == NULL) {\n        return PUBLIC_KEY_E;\n    }\n\n    /* init */\n    XMEMSET(der, 0, sizeof(DerCert));\n\n    /* version */\n    der->versionSz = SetMyVersion(cert->version, der->version, TRUE);\n\n    /* serial number (must be positive) */\n    if (cert->serialSz == 0) {\n        /* generate random serial */\n        cert->serialSz = CTC_GEN_SERIAL_SZ;\n        ret = wc_RNG_GenerateBlock(rng, cert->serial, cert->serialSz);\n        if (ret != 0)\n            return ret;\n        /* Clear the top bit to avoid a negative value */\n        cert->serial[0] &= 0x7f;\n    }\n    der->serialSz = SetSerialNumber(cert->serial, cert->serialSz, der->serial,\n        sizeof(der->serial), CTC_SERIAL_SIZE);\n    if (der->serialSz < 0)\n        return der->serialSz;\n\n    /* signature algo */\n    der->sigAlgoSz = SetAlgoID(cert->sigType, der->sigAlgo, oidSigType, 0);\n    if (der->sigAlgoSz <= 0)\n        return ALGO_ID_E;\n\n    /* public key */\n#ifndef NO_RSA\n    if (cert->keyType == RSA_KEY) {\n        if (rsaKey == NULL)\n            return PUBLIC_KEY_E;\n        der->publicKeySz = SetRsaPublicKey(der->publicKey, rsaKey,\n                                           sizeof(der->publicKey), 1);\n    }\n#endif\n\n#ifdef HAVE_ECC\n    if (cert->keyType == ECC_KEY) {\n        if (eccKey == NULL)\n            return PUBLIC_KEY_E;\n        der->publicKeySz = SetEccPublicKey(der->publicKey, eccKey, 1);\n    }\n#endif\n\n#if !defined(NO_DSA) && !defined(HAVE_SELFTEST)\n    if (cert->keyType == DSA_KEY) {\n        if (dsaKey == NULL)\n            return PUBLIC_KEY_E;\n        der->publicKeySz = wc_SetDsaPublicKey(der->publicKey, dsaKey,\n                                           sizeof(der->publicKey), 1);\n    }\n#endif\n\n#ifdef HAVE_ED25519\n    if (cert->keyType == ED25519_KEY) {\n        if (ed25519Key == NULL)\n            return PUBLIC_KEY_E;\n        der->publicKeySz = SetEd25519PublicKey(der->publicKey, ed25519Key, 1);\n    }\n#endif\n\n#ifdef HAVE_ED448\n    if (cert->keyType == ED448_KEY) {\n        if (ed448Key == NULL)\n            return PUBLIC_KEY_E;\n        der->publicKeySz = SetEd448PublicKey(der->publicKey, ed448Key, 1);\n    }\n#endif\n\n#ifdef HAVE_NTRU\n    if (cert->keyType == NTRU_KEY) {\n        word32 rc;\n        word16 encodedSz;\n\n        if (ntruKey == NULL)\n            return PUBLIC_KEY_E;\n\n        rc  = ntru_crypto_ntru_encrypt_publicKey2SubjectPublicKeyInfo(ntruSz,\n                                                   ntruKey, &encodedSz, NULL);\n        if (rc != NTRU_OK)\n            return PUBLIC_KEY_E;\n        if (encodedSz > MAX_PUBLIC_KEY_SZ)\n            return PUBLIC_KEY_E;\n\n        rc  = ntru_crypto_ntru_encrypt_publicKey2SubjectPublicKeyInfo(ntruSz,\n                                         ntruKey, &encodedSz, der->publicKey);\n        if (rc != NTRU_OK)\n            return PUBLIC_KEY_E;\n\n        der->publicKeySz = encodedSz;\n    }\n#else\n    (void)ntruSz;\n#endif /* HAVE_NTRU */\n\n    if (der->publicKeySz <= 0)\n        return PUBLIC_KEY_E;\n\n    der->validitySz = 0;\n#ifdef WOLFSSL_ALT_NAMES\n    /* date validity copy ? */\n    if (cert->beforeDateSz && cert->afterDateSz) {\n        der->validitySz = CopyValidity(der->validity, cert);\n        if (der->validitySz <= 0)\n            return DATE_E;\n    }\n#endif\n\n    /* date validity */\n    if (der->validitySz == 0) {\n        der->validitySz = SetValidity(der->validity, cert->daysValid);\n        if (der->validitySz <= 0)\n            return DATE_E;\n    }\n\n    /* subject name */\n#if defined(WOLFSSL_CERT_EXT) || defined(OPENSSL_EXTRA)\n    if (XSTRLEN((const char*)cert->sbjRaw) > 0) {\n        /* Use the raw subject */\n        int idx;\n\n        der->subjectSz = min(sizeof(der->subject),\n                (word32)XSTRLEN((const char*)cert->sbjRaw));\n        /* header */\n        idx = SetSequence(der->subjectSz, der->subject);\n        if (der->subjectSz + idx > (int)sizeof(der->subject)) {\n            return SUBJECT_E;\n        }\n\n        XMEMCPY((char*)der->subject + idx, (const char*)cert->sbjRaw,\n                der->subjectSz);\n        der->subjectSz += idx;\n    }\n    else\n#endif\n    {\n        /* Use the name structure */\n        der->subjectSz = SetName(der->subject, sizeof(der->subject),\n                &cert->subject);\n    }\n    if (der->subjectSz <= 0)\n        return SUBJECT_E;\n\n    /* issuer name */\n#if defined(WOLFSSL_CERT_EXT) || defined(OPENSSL_EXTRA)\n    if (XSTRLEN((const char*)cert->issRaw) > 0) {\n        /* Use the raw issuer */\n        int idx;\n\n        der->issuerSz = min(sizeof(der->issuer),\n                (word32)XSTRLEN((const char*)cert->issRaw));\n\n        /* header */\n        idx = SetSequence(der->issuerSz, der->issuer);\n        if (der->issuerSz + idx > (int)sizeof(der->issuer)) {\n            return ISSUER_E;\n        }\n\n        XMEMCPY((char*)der->issuer + idx, (const char*)cert->issRaw,\n                der->issuerSz);\n        der->issuerSz += idx;\n    }\n    else\n#endif\n    {\n        /* Use the name structure */\n        der->issuerSz = SetName(der->issuer, sizeof(der->issuer),\n                cert->selfSigned ? &cert->subject : &cert->issuer);\n    }\n    if (der->issuerSz <= 0)\n        return ISSUER_E;\n\n    /* set the extensions */\n    der->extensionsSz = 0;\n\n    /* CA */\n    if (cert->isCA) {\n        der->caSz = SetCa(der->ca, sizeof(der->ca));\n        if (der->caSz <= 0)\n            return CA_TRUE_E;\n\n        der->extensionsSz += der->caSz;\n    }\n    else\n        der->caSz = 0;\n\n#ifdef WOLFSSL_ALT_NAMES\n    /* Alternative Name */\n    if (cert->altNamesSz) {\n        der->altNamesSz = SetAltNames(der->altNames, sizeof(der->altNames),\n                                      cert->altNames, cert->altNamesSz);\n        if (der->altNamesSz <= 0)\n            return ALT_NAME_E;\n\n        der->extensionsSz += der->altNamesSz;\n    }\n    else\n        der->altNamesSz = 0;\n#endif\n\n#ifdef WOLFSSL_CERT_EXT\n    /* SKID */\n    if (cert->skidSz) {\n        /* check the provided SKID size */\n        if (cert->skidSz > (int)min(CTC_MAX_SKID_SIZE, sizeof(der->skid)))\n            return SKID_E;\n\n        /* Note: different skid buffers sizes for der (MAX_KID_SZ) and\n            cert (CTC_MAX_SKID_SIZE). */\n        der->skidSz = SetSKID(der->skid, sizeof(der->skid),\n                              cert->skid, cert->skidSz);\n        if (der->skidSz <= 0)\n            return SKID_E;\n\n        der->extensionsSz += der->skidSz;\n    }\n    else\n        der->skidSz = 0;\n\n    /* AKID */\n    if (cert->akidSz) {\n        /* check the provided AKID size */\n        if (cert->akidSz > (int)min(CTC_MAX_AKID_SIZE, sizeof(der->akid)))\n            return AKID_E;\n\n        der->akidSz = SetAKID(der->akid, sizeof(der->akid),\n                              cert->akid, cert->akidSz, cert->heap);\n        if (der->akidSz <= 0)\n            return AKID_E;\n\n        der->extensionsSz += der->akidSz;\n    }\n    else\n        der->akidSz = 0;\n\n    /* Key Usage */\n    if (cert->keyUsage != 0){\n        der->keyUsageSz = SetKeyUsage(der->keyUsage, sizeof(der->keyUsage),\n                                      cert->keyUsage);\n        if (der->keyUsageSz <= 0)\n            return KEYUSAGE_E;\n\n        der->extensionsSz += der->keyUsageSz;\n    }\n    else\n        der->keyUsageSz = 0;\n\n    /* Extended Key Usage */\n    if (cert->extKeyUsage != 0){\n        der->extKeyUsageSz = SetExtKeyUsage(cert, der->extKeyUsage,\n                                sizeof(der->extKeyUsage), cert->extKeyUsage);\n        if (der->extKeyUsageSz <= 0)\n            return EXTKEYUSAGE_E;\n\n        der->extensionsSz += der->extKeyUsageSz;\n    }\n    else\n        der->extKeyUsageSz = 0;\n\n    /* Certificate Policies */\n    if (cert->certPoliciesNb != 0) {\n        der->certPoliciesSz = SetCertificatePolicies(der->certPolicies,\n                                                     sizeof(der->certPolicies),\n                                                     cert->certPolicies,\n                                                     cert->certPoliciesNb,\n                                                     cert->heap);\n        if (der->certPoliciesSz <= 0)\n            return CERTPOLICIES_E;\n\n        der->extensionsSz += der->certPoliciesSz;\n    }\n    else\n        der->certPoliciesSz = 0;\n#endif /* WOLFSSL_CERT_EXT */\n\n    /* put extensions */\n    if (der->extensionsSz > 0) {\n\n        /* put the start of extensions sequence (ID, Size) */\n        der->extensionsSz = SetExtensionsHeader(der->extensions,\n                                                sizeof(der->extensions),\n                                                der->extensionsSz);\n        if (der->extensionsSz <= 0)\n            return EXTENSIONS_E;\n\n        /* put CA */\n        if (der->caSz) {\n            ret = SetExtensions(der->extensions, sizeof(der->extensions),\n                                &der->extensionsSz,\n                                der->ca, der->caSz);\n            if (ret == 0)\n                return EXTENSIONS_E;\n        }\n\n#ifdef WOLFSSL_ALT_NAMES\n        /* put Alternative Names */\n        if (der->altNamesSz) {\n            ret = SetExtensions(der->extensions, sizeof(der->extensions),\n                                &der->extensionsSz,\n                                der->altNames, der->altNamesSz);\n            if (ret <= 0)\n                return EXTENSIONS_E;\n        }\n#endif\n\n#ifdef WOLFSSL_CERT_EXT\n        /* put SKID */\n        if (der->skidSz) {\n            ret = SetExtensions(der->extensions, sizeof(der->extensions),\n                                &der->extensionsSz,\n                                der->skid, der->skidSz);\n            if (ret <= 0)\n                return EXTENSIONS_E;\n        }\n\n        /* put AKID */\n        if (der->akidSz) {\n            ret = SetExtensions(der->extensions, sizeof(der->extensions),\n                                &der->extensionsSz,\n                                der->akid, der->akidSz);\n            if (ret <= 0)\n                return EXTENSIONS_E;\n        }\n\n        /* put KeyUsage */\n        if (der->keyUsageSz) {\n            ret = SetExtensions(der->extensions, sizeof(der->extensions),\n                                &der->extensionsSz,\n                                der->keyUsage, der->keyUsageSz);\n            if (ret <= 0)\n                return EXTENSIONS_E;\n        }\n\n        /* put ExtendedKeyUsage */\n        if (der->extKeyUsageSz) {\n            ret = SetExtensions(der->extensions, sizeof(der->extensions),\n                                &der->extensionsSz,\n                                der->extKeyUsage, der->extKeyUsageSz);\n            if (ret <= 0)\n                return EXTENSIONS_E;\n        }\n\n        /* put Certificate Policies */\n        if (der->certPoliciesSz) {\n            ret = SetExtensions(der->extensions, sizeof(der->extensions),\n                                &der->extensionsSz,\n                                der->certPolicies, der->certPoliciesSz);\n            if (ret <= 0)\n                return EXTENSIONS_E;\n        }\n#endif /* WOLFSSL_CERT_EXT */\n    }\n\n    der->total = der->versionSz + der->serialSz + der->sigAlgoSz +\n        der->publicKeySz + der->validitySz + der->subjectSz + der->issuerSz +\n        der->extensionsSz;\n\n    return 0;\n}\n\n\n/* write DER encoded cert to buffer, size already checked */\nstatic int WriteCertBody(DerCert* der, byte* buf)\n{\n    int idx;\n\n    /* signed part header */\n    idx = SetSequence(der->total, buf);\n    /* version */\n    XMEMCPY(buf + idx, der->version, der->versionSz);\n    idx += der->versionSz;\n    /* serial */\n    XMEMCPY(buf + idx, der->serial, der->serialSz);\n    idx += der->serialSz;\n    /* sig algo */\n    XMEMCPY(buf + idx, der->sigAlgo, der->sigAlgoSz);\n    idx += der->sigAlgoSz;\n    /* issuer */\n    XMEMCPY(buf + idx, der->issuer, der->issuerSz);\n    idx += der->issuerSz;\n    /* validity */\n    XMEMCPY(buf + idx, der->validity, der->validitySz);\n    idx += der->validitySz;\n    /* subject */\n    XMEMCPY(buf + idx, der->subject, der->subjectSz);\n    idx += der->subjectSz;\n    /* public key */\n    XMEMCPY(buf + idx, der->publicKey, der->publicKeySz);\n    idx += der->publicKeySz;\n    if (der->extensionsSz) {\n        /* extensions */\n        XMEMCPY(buf + idx, der->extensions, min(der->extensionsSz,\n                                                   (int)sizeof(der->extensions)));\n        idx += der->extensionsSz;\n    }\n\n    return idx;\n}\n\n\n/* Make RSA signature from buffer (sz), write to sig (sigSz) */\nstatic int MakeSignature(CertSignCtx* certSignCtx, const byte* buf, int sz,\n    byte* sig, int sigSz, RsaKey* rsaKey, ecc_key* eccKey,\n    ed25519_key* ed25519Key, ed448_key* ed448Key, WC_RNG* rng, int sigAlgoType,\n    void* heap)\n{\n    int digestSz = 0, typeH = 0, ret = 0;\n\n    (void)digestSz;\n    (void)typeH;\n    (void)buf;\n    (void)sz;\n    (void)sig;\n    (void)sigSz;\n    (void)rsaKey;\n    (void)eccKey;\n    (void)ed25519Key;\n    (void)ed448Key;\n    (void)rng;\n    (void)heap;\n\n    switch (certSignCtx->state) {\n    case CERTSIGN_STATE_BEGIN:\n    case CERTSIGN_STATE_DIGEST:\n\n        certSignCtx->state = CERTSIGN_STATE_DIGEST;\n        certSignCtx->digest = (byte*)XMALLOC(WC_MAX_DIGEST_SIZE, heap,\n            DYNAMIC_TYPE_TMP_BUFFER);\n        if (certSignCtx->digest == NULL) {\n            ret = MEMORY_E; goto exit_ms;\n        }\n\n        ret = HashForSignature(buf, sz, sigAlgoType, certSignCtx->digest,\n                               &typeH, &digestSz, 0);\n        /* set next state, since WC_PENDING_E rentry for these are not \"call again\" */\n        certSignCtx->state = CERTSIGN_STATE_ENCODE;\n        if (ret != 0) {\n            goto exit_ms;\n        }\n        FALL_THROUGH;\n\n    case CERTSIGN_STATE_ENCODE:\n    #ifndef NO_RSA\n        if (rsaKey) {\n            certSignCtx->encSig = (byte*)XMALLOC(MAX_DER_DIGEST_SZ, heap,\n                DYNAMIC_TYPE_TMP_BUFFER);\n            if (certSignCtx->encSig == NULL) {\n                ret = MEMORY_E; goto exit_ms;\n            }\n\n            /* signature */\n            certSignCtx->encSigSz = wc_EncodeSignature(certSignCtx->encSig,\n                                          certSignCtx->digest, digestSz, typeH);\n        }\n    #endif /* !NO_RSA */\n        FALL_THROUGH;\n\n    case CERTSIGN_STATE_DO:\n        certSignCtx->state = CERTSIGN_STATE_DO;\n        ret = ALGO_ID_E; /* default to error */\n\n    #ifndef NO_RSA\n        if (rsaKey) {\n            /* signature */\n            ret = wc_RsaSSL_Sign(certSignCtx->encSig, certSignCtx->encSigSz,\n                                 sig, sigSz, rsaKey, rng);\n        }\n    #endif /* !NO_RSA */\n\n    #ifdef HAVE_ECC\n        if (!rsaKey && eccKey) {\n            word32 outSz = sigSz;\n\n            ret = wc_ecc_sign_hash(certSignCtx->digest, digestSz,\n                                   sig, &outSz, rng, eccKey);\n            if (ret == 0)\n                ret = outSz;\n        }\n    #endif /* HAVE_ECC */\n\n    #ifdef HAVE_ED25519\n        if (!rsaKey && !eccKey && ed25519Key) {\n            word32 outSz = sigSz;\n\n            ret = wc_ed25519_sign_msg(buf, sz, sig, &outSz, ed25519Key);\n            if (ret == 0)\n                ret = outSz;\n        }\n    #endif /* HAVE_ECC */\n\n    #ifdef HAVE_ED448\n        if (!rsaKey && !eccKey && !ed25519Key && ed448Key) {\n            word32 outSz = sigSz;\n\n            ret = wc_ed448_sign_msg(buf, sz, sig, &outSz, ed448Key, NULL, 0);\n            if (ret == 0)\n                ret = outSz;\n        }\n    #endif /* HAVE_ECC */\n        break;\n    }\n\nexit_ms:\n\n#ifdef WOLFSSL_ASYNC_CRYPT\n    if (ret == WC_PENDING_E) {\n        return ret;\n    }\n#endif\n\n#ifndef NO_RSA\n    if (rsaKey) {\n        XFREE(certSignCtx->encSig, heap, DYNAMIC_TYPE_TMP_BUFFER);\n    }\n#endif /* !NO_RSA */\n\n    XFREE(certSignCtx->digest, heap, DYNAMIC_TYPE_TMP_BUFFER);\n    certSignCtx->digest = NULL;\n\n    /* reset state */\n    certSignCtx->state = CERTSIGN_STATE_BEGIN;\n\n    return ret;\n}\n\n\n/* add signature to end of buffer, size of buffer assumed checked, return\n   new length */\nint AddSignature(byte* buf, int bodySz, const byte* sig, int sigSz,\n                        int sigAlgoType)\n{\n    byte seq[MAX_SEQ_SZ];\n    int  idx = bodySz, seqSz;\n\n    /* algo */\n    idx += SetAlgoID(sigAlgoType, buf ? buf + idx : NULL, oidSigType, 0);\n    /* bit string */\n    idx += SetBitString(sigSz, 0, buf ? buf + idx : NULL);\n    /* signature */\n    if (buf)\n        XMEMCPY(buf + idx, sig, sigSz);\n    idx += sigSz;\n\n    /* make room for overall header */\n    seqSz = SetSequence(idx, seq);\n    if (buf) {\n        XMEMMOVE(buf + seqSz, buf, idx);\n        XMEMCPY(buf, seq, seqSz);\n    }\n\n    return idx + seqSz;\n}\n\n\n/* Make an x509 Certificate v3 any key type from cert input, write to buffer */\nstatic int MakeAnyCert(Cert* cert, byte* derBuffer, word32 derSz,\n                       RsaKey* rsaKey, ecc_key* eccKey, WC_RNG* rng,\n                       DsaKey* dsaKey, const byte* ntruKey, word16 ntruSz,\n                       ed25519_key* ed25519Key, ed448_key* ed448Key)\n{\n    int ret;\n#ifdef WOLFSSL_SMALL_STACK\n    DerCert* der;\n#else\n    DerCert der[1];\n#endif\n\n    if (derBuffer == NULL)\n        return BAD_FUNC_ARG;\n\n    if (eccKey)\n        cert->keyType = ECC_KEY;\n    else if (rsaKey)\n        cert->keyType = RSA_KEY;\n    else if (dsaKey)\n        cert->keyType = DSA_KEY;\n    else if (ed25519Key)\n        cert->keyType = ED25519_KEY;\n    else if (ed448Key)\n        cert->keyType = ED448_KEY;\n    else if (ntruKey)\n        cert->keyType = NTRU_KEY;\n    else\n        return BAD_FUNC_ARG;\n\n#ifdef WOLFSSL_SMALL_STACK\n    der = (DerCert*)XMALLOC(sizeof(DerCert), cert->heap, DYNAMIC_TYPE_TMP_BUFFER);\n    if (der == NULL)\n        return MEMORY_E;\n#endif\n\n    ret = EncodeCert(cert, der, rsaKey, eccKey, rng, ntruKey, ntruSz, dsaKey,\n                     ed25519Key, ed448Key);\n    if (ret == 0) {\n        if (der->total + MAX_SEQ_SZ * 2 > (int)derSz)\n            ret = BUFFER_E;\n        else\n            ret = cert->bodySz = WriteCertBody(der, derBuffer);\n    }\n\n#ifdef WOLFSSL_SMALL_STACK\n    XFREE(der, cert->heap, DYNAMIC_TYPE_TMP_BUFFER);\n#endif\n\n    return ret;\n}\n\n\n/* Make an x509 Certificate v3 RSA or ECC from cert input, write to buffer */\nint wc_MakeCert_ex(Cert* cert, byte* derBuffer, word32 derSz, int keyType,\n                   void* key, WC_RNG* rng)\n{\n    RsaKey*      rsaKey = NULL;\n    DsaKey*      dsaKey = NULL;\n    ecc_key*     eccKey = NULL;\n    ed25519_key* ed25519Key = NULL;\n    ed448_key*   ed448Key = NULL;\n\n    if (keyType == RSA_TYPE)\n        rsaKey = (RsaKey*)key;\n    else if (keyType == DSA_TYPE)\n        dsaKey = (DsaKey*)key;\n    else if (keyType == ECC_TYPE)\n        eccKey = (ecc_key*)key;\n    else if (keyType == ED25519_TYPE)\n        ed25519Key = (ed25519_key*)key;\n    else if (keyType == ED448_TYPE)\n        ed448Key = (ed448_key*)key;\n\n    return MakeAnyCert(cert, derBuffer, derSz, rsaKey, eccKey, rng, dsaKey,\n                       NULL, 0, ed25519Key, ed448Key);\n}\n/* Make an x509 Certificate v3 RSA or ECC from cert input, write to buffer */\nint wc_MakeCert(Cert* cert, byte* derBuffer, word32 derSz, RsaKey* rsaKey,\n             ecc_key* eccKey, WC_RNG* rng)\n{\n    return MakeAnyCert(cert, derBuffer, derSz, rsaKey, eccKey, rng, NULL, NULL, 0,\n                       NULL, NULL);\n}\n\n\n#ifdef HAVE_NTRU\n\nint wc_MakeNtruCert(Cert* cert, byte* derBuffer, word32 derSz,\n                  const byte* ntruKey, word16 keySz, WC_RNG* rng)\n{\n    return MakeAnyCert(cert, derBuffer, derSz, NULL, NULL, rng, NULL,\n            ntruKey, keySz, NULL, NULL);\n}\n\n#endif /* HAVE_NTRU */\n\n\n#ifdef WOLFSSL_CERT_REQ\n\nstatic int SetReqAttrib(byte* output, char* pw, int pwPrintableString,\n                        int extSz)\n{\n    const byte erOid[] =\n        { ASN_OBJECT_ID, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01,\n                         0x09, 0x0e };\n\n    int sz      = 0; /* overall size */\n    int cpSz    = 0; /* Challenge Password section size */\n    int cpSeqSz = 0;\n    int cpSetSz = 0;\n    int cpStrSz = 0;\n    int pwSz    = 0;\n    int erSz    = 0; /* Extension Request section size */\n    int erSeqSz = 0;\n    int erSetSz = 0;\n    byte cpSeq[MAX_SEQ_SZ];\n    byte cpSet[MAX_SET_SZ];\n    byte cpStr[MAX_PRSTR_SZ];\n    byte erSeq[MAX_SEQ_SZ];\n    byte erSet[MAX_SET_SZ];\n\n    output[0] = ASN_CONTEXT_SPECIFIC | ASN_CONSTRUCTED;\n    sz++;\n\n    if (pw && pw[0]) {\n        pwSz = (int)XSTRLEN(pw);\n        if (pwPrintableString) {\n            cpStrSz = SetPrintableString(pwSz, cpStr);\n        } else {\n            cpStrSz = SetUTF8String(pwSz, cpStr);\n        }\n        cpSetSz = SetSet(cpStrSz + pwSz, cpSet);\n        /* +2 for tag and length parts of the TLV triplet */\n        cpSeqSz = SetSequence(2 + sizeof(attrChallengePasswordOid) + cpSetSz +\n                cpStrSz + pwSz, cpSeq);\n        cpSz = cpSeqSz + 2 + sizeof(attrChallengePasswordOid) + cpSetSz +\n                cpStrSz + pwSz;\n    }\n\n    if (extSz) {\n        erSetSz = SetSet(extSz, erSet);\n        erSeqSz = SetSequence(erSetSz + sizeof(erOid) + extSz, erSeq);\n        erSz = extSz + erSetSz + erSeqSz + sizeof(erOid);\n    }\n\n    /* Put the pieces together. */\n    sz += SetLength(cpSz + erSz, &output[sz]);\n\n    if (cpSz) {\n        XMEMCPY(&output[sz], cpSeq, cpSeqSz);\n        sz += cpSeqSz;\n        sz += SetObjectId(sizeof(attrChallengePasswordOid), output + sz);\n        XMEMCPY(&output[sz], attrChallengePasswordOid,\n                sizeof(attrChallengePasswordOid));\n        sz += sizeof(attrChallengePasswordOid);\n        XMEMCPY(&output[sz], cpSet, cpSetSz);\n        sz += cpSetSz;\n        XMEMCPY(&output[sz], cpStr, cpStrSz);\n        sz += cpStrSz;\n        XMEMCPY(&output[sz], pw, pwSz);\n        sz += pwSz;\n    }\n\n    if (erSz) {\n        XMEMCPY(&output[sz], erSeq, erSeqSz);\n        sz += erSeqSz;\n        XMEMCPY(&output[sz], erOid, sizeof(erOid));\n        sz += sizeof(erOid);\n        XMEMCPY(&output[sz], erSet, erSetSz);\n        sz += erSetSz;\n        /* The actual extension data will be tacked onto the output later. */\n    }\n\n    return sz;\n}\n\n\n/* encode info from cert into DER encoded format */\nstatic int EncodeCertReq(Cert* cert, DerCert* der, RsaKey* rsaKey,\n                         DsaKey* dsaKey, ecc_key* eccKey,\n                         ed25519_key* ed25519Key, ed448_key* ed448Key)\n{\n    (void)eccKey;\n    (void)ed25519Key;\n    (void)ed448Key;\n\n    if (cert == NULL || der == NULL)\n        return BAD_FUNC_ARG;\n\n    if (rsaKey == NULL && eccKey == NULL && ed25519Key == NULL &&\n            dsaKey == NULL && ed448Key == NULL) {\n            return PUBLIC_KEY_E;\n    }\n\n    /* init */\n    XMEMSET(der, 0, sizeof(DerCert));\n\n    /* version */\n    der->versionSz = SetMyVersion(cert->version, der->version, FALSE);\n\n    /* subject name */\n#if defined(WOLFSSL_CERT_EXT) || defined(OPENSSL_EXTRA)\n    if (XSTRLEN((const char*)cert->sbjRaw) > 0) {\n        /* Use the raw subject */\n        int idx;\n\n        der->subjectSz = min(sizeof(der->subject),\n                (word32)XSTRLEN((const char*)cert->sbjRaw));\n        /* header */\n        idx = SetSequence(der->subjectSz, der->subject);\n        if (der->subjectSz + idx > (int)sizeof(der->subject)) {\n            return SUBJECT_E;\n        }\n\n        XMEMCPY((char*)der->subject + idx, (const char*)cert->sbjRaw,\n                der->subjectSz);\n        der->subjectSz += idx;\n    }\n    else\n#endif\n    {\n        der->subjectSz = SetName(der->subject, sizeof(der->subject),\n                &cert->subject);\n    }\n    if (der->subjectSz <= 0)\n        return SUBJECT_E;\n\n    /* public key */\n#ifndef NO_RSA\n    if (cert->keyType == RSA_KEY) {\n        if (rsaKey == NULL)\n            return PUBLIC_KEY_E;\n        der->publicKeySz = SetRsaPublicKey(der->publicKey, rsaKey,\n                                           sizeof(der->publicKey), 1);\n    }\n#endif\n\n#if !defined(NO_DSA) && !defined(HAVE_SELFTEST)\n    if (cert->keyType == DSA_KEY) {\n        if (dsaKey == NULL)\n            return PUBLIC_KEY_E;\n        der->publicKeySz = wc_SetDsaPublicKey(der->publicKey, dsaKey,\n                                           sizeof(der->publicKey), 1);\n    }\n#endif\n\n#ifdef HAVE_ECC\n    if (cert->keyType == ECC_KEY) {\n        if (eccKey == NULL)\n            return PUBLIC_KEY_E;\n        der->publicKeySz = SetEccPublicKey(der->publicKey, eccKey, 1);\n    }\n#endif\n\n#ifdef HAVE_ED25519\n    if (cert->keyType == ED25519_KEY) {\n        if (ed25519Key == NULL)\n            return PUBLIC_KEY_E;\n        der->publicKeySz = SetEd25519PublicKey(der->publicKey, ed25519Key, 1);\n    }\n#endif\n\n#ifdef HAVE_ED448\n    if (cert->keyType == ED448_KEY) {\n        if (ed448Key == NULL)\n            return PUBLIC_KEY_E;\n        der->publicKeySz = SetEd448PublicKey(der->publicKey, ed448Key, 1);\n    }\n#endif\n    if (der->publicKeySz <= 0)\n        return PUBLIC_KEY_E;\n\n    /* set the extensions */\n    der->extensionsSz = 0;\n\n    /* CA */\n    if (cert->isCA) {\n        der->caSz = SetCa(der->ca, sizeof(der->ca));\n        if (der->caSz <= 0)\n            return CA_TRUE_E;\n\n        der->extensionsSz += der->caSz;\n    }\n    else\n        der->caSz = 0;\n\n#ifdef WOLFSSL_ALT_NAMES\n    /* Alternative Name */\n    if (cert->altNamesSz) {\n        der->altNamesSz = SetAltNames(der->altNames, sizeof(der->altNames),\n                                      cert->altNames, cert->altNamesSz);\n        if (der->altNamesSz <= 0)\n            return ALT_NAME_E;\n\n        der->extensionsSz += der->altNamesSz;\n    }\n    else\n        der->altNamesSz = 0;\n#endif\n\n#ifdef WOLFSSL_CERT_EXT\n    /* SKID */\n    if (cert->skidSz) {\n        /* check the provided SKID size */\n        if (cert->skidSz > (int)min(CTC_MAX_SKID_SIZE, sizeof(der->skid)))\n            return SKID_E;\n\n        der->skidSz = SetSKID(der->skid, sizeof(der->skid),\n                              cert->skid, cert->skidSz);\n        if (der->skidSz <= 0)\n            return SKID_E;\n\n        der->extensionsSz += der->skidSz;\n    }\n    else\n        der->skidSz = 0;\n\n    /* Key Usage */\n    if (cert->keyUsage != 0){\n        der->keyUsageSz = SetKeyUsage(der->keyUsage, sizeof(der->keyUsage),\n                                      cert->keyUsage);\n        if (der->keyUsageSz <= 0)\n            return KEYUSAGE_E;\n\n        der->extensionsSz += der->keyUsageSz;\n    }\n    else\n        der->keyUsageSz = 0;\n\n    /* Extended Key Usage */\n    if (cert->extKeyUsage != 0){\n        der->extKeyUsageSz = SetExtKeyUsage(cert, der->extKeyUsage,\n                                sizeof(der->extKeyUsage), cert->extKeyUsage);\n        if (der->extKeyUsageSz <= 0)\n            return EXTKEYUSAGE_E;\n\n        der->extensionsSz += der->extKeyUsageSz;\n    }\n    else\n        der->extKeyUsageSz = 0;\n\n#endif /* WOLFSSL_CERT_EXT */\n\n    /* put extensions */\n    if (der->extensionsSz > 0) {\n        int ret;\n\n        /* put the start of sequence (ID, Size) */\n        der->extensionsSz = SetSequence(der->extensionsSz, der->extensions);\n        if (der->extensionsSz <= 0)\n            return EXTENSIONS_E;\n\n        /* put CA */\n        if (der->caSz) {\n            ret = SetExtensions(der->extensions, sizeof(der->extensions),\n                                &der->extensionsSz,\n                                der->ca, der->caSz);\n            if (ret <= 0)\n                return EXTENSIONS_E;\n        }\n\n#ifdef WOLFSSL_ALT_NAMES\n        /* put Alternative Names */\n        if (der->altNamesSz) {\n            ret = SetExtensions(der->extensions, sizeof(der->extensions),\n                                &der->extensionsSz,\n                                der->altNames, der->altNamesSz);\n            if (ret <= 0)\n                return EXTENSIONS_E;\n        }\n#endif\n\n#ifdef WOLFSSL_CERT_EXT\n        /* put SKID */\n        if (der->skidSz) {\n            ret = SetExtensions(der->extensions, sizeof(der->extensions),\n                                &der->extensionsSz,\n                                der->skid, der->skidSz);\n            if (ret <= 0)\n                return EXTENSIONS_E;\n        }\n\n        /* put AKID */\n        if (der->akidSz) {\n            ret = SetExtensions(der->extensions, sizeof(der->extensions),\n                                &der->extensionsSz,\n                                der->akid, der->akidSz);\n            if (ret <= 0)\n                return EXTENSIONS_E;\n        }\n\n        /* put KeyUsage */\n        if (der->keyUsageSz) {\n            ret = SetExtensions(der->extensions, sizeof(der->extensions),\n                                &der->extensionsSz,\n                                der->keyUsage, der->keyUsageSz);\n            if (ret <= 0)\n                return EXTENSIONS_E;\n        }\n\n        /* put ExtendedKeyUsage */\n        if (der->extKeyUsageSz) {\n            ret = SetExtensions(der->extensions, sizeof(der->extensions),\n                                &der->extensionsSz,\n                                der->extKeyUsage, der->extKeyUsageSz);\n            if (ret <= 0)\n                return EXTENSIONS_E;\n        }\n\n#endif /* WOLFSSL_CERT_EXT */\n    }\n\n    der->attribSz = SetReqAttrib(der->attrib, cert->challengePw,\n                                 cert->challengePwPrintableString,\n                                 der->extensionsSz);\n    if (der->attribSz <= 0)\n        return REQ_ATTRIBUTE_E;\n\n    der->total = der->versionSz + der->subjectSz + der->publicKeySz +\n        der->extensionsSz + der->attribSz;\n\n    return 0;\n}\n\n\n/* write DER encoded cert req to buffer, size already checked */\nstatic int WriteCertReqBody(DerCert* der, byte* buf)\n{\n    int idx;\n\n    /* signed part header */\n    idx = SetSequence(der->total, buf);\n    /* version */\n    if (buf)\n        XMEMCPY(buf + idx, der->version, der->versionSz);\n    idx += der->versionSz;\n    /* subject */\n    if (buf)\n        XMEMCPY(buf + idx, der->subject, der->subjectSz);\n    idx += der->subjectSz;\n    /* public key */\n    if (buf)\n        XMEMCPY(buf + idx, der->publicKey, der->publicKeySz);\n    idx += der->publicKeySz;\n    /* attributes */\n    if (buf)\n        XMEMCPY(buf + idx, der->attrib, der->attribSz);\n    idx += der->attribSz;\n    /* extensions */\n    if (der->extensionsSz) {\n        if (buf)\n            XMEMCPY(buf + idx, der->extensions, min(der->extensionsSz,\n                                               (int)sizeof(der->extensions)));\n        idx += der->extensionsSz;\n    }\n\n    return idx;\n}\n\n\nstatic int MakeCertReq(Cert* cert, byte* derBuffer, word32 derSz,\n                   RsaKey* rsaKey, DsaKey* dsaKey, ecc_key* eccKey,\n                   ed25519_key* ed25519Key, ed448_key* ed448Key)\n{\n    int ret;\n#ifdef WOLFSSL_SMALL_STACK\n    DerCert* der;\n#else\n    DerCert der[1];\n#endif\n\n    if (eccKey)\n        cert->keyType = ECC_KEY;\n    else if (rsaKey)\n        cert->keyType = RSA_KEY;\n    else if (dsaKey)\n        cert->keyType = DSA_KEY;\n    else if (ed25519Key)\n        cert->keyType = ED25519_KEY;\n    else if (ed448Key)\n        cert->keyType = ED448_KEY;\n    else\n        return BAD_FUNC_ARG;\n\n#ifdef WOLFSSL_SMALL_STACK\n    der = (DerCert*)XMALLOC(sizeof(DerCert), cert->heap,\n                                                    DYNAMIC_TYPE_TMP_BUFFER);\n    if (der == NULL)\n        return MEMORY_E;\n#endif\n\n    ret = EncodeCertReq(cert, der, rsaKey, dsaKey, eccKey, ed25519Key, ed448Key);\n\n    if (ret == 0) {\n        if (der->total + MAX_SEQ_SZ * 2 > (int)derSz)\n            ret = BUFFER_E;\n        else\n            ret = cert->bodySz = WriteCertReqBody(der, derBuffer);\n    }\n\n#ifdef WOLFSSL_SMALL_STACK\n    XFREE(der, cert->heap, DYNAMIC_TYPE_TMP_BUFFER);\n#endif\n\n    return ret;\n}\n\nint wc_MakeCertReq_ex(Cert* cert, byte* derBuffer, word32 derSz, int keyType,\n                      void* key)\n{\n    RsaKey*      rsaKey = NULL;\n    DsaKey*      dsaKey = NULL;\n    ecc_key*     eccKey = NULL;\n    ed25519_key* ed25519Key = NULL;\n    ed448_key*   ed448Key = NULL;\n\n    if (keyType == RSA_TYPE)\n        rsaKey = (RsaKey*)key;\n    else if (keyType == DSA_TYPE)\n        dsaKey = (DsaKey*)key;\n    else if (keyType == ECC_TYPE)\n        eccKey = (ecc_key*)key;\n    else if (keyType == ED25519_TYPE)\n        ed25519Key = (ed25519_key*)key;\n    else if (keyType == ED448_TYPE)\n        ed448Key = (ed448_key*)key;\n\n    return MakeCertReq(cert, derBuffer, derSz, rsaKey, dsaKey, eccKey, ed25519Key,\n                       ed448Key);\n}\n\nint wc_MakeCertReq(Cert* cert, byte* derBuffer, word32 derSz,\n                   RsaKey* rsaKey, ecc_key* eccKey)\n{\n    return MakeCertReq(cert, derBuffer, derSz, rsaKey, NULL, eccKey, NULL, NULL);\n}\n#endif /* WOLFSSL_CERT_REQ */\n\n\nstatic int SignCert(int requestSz, int sType, byte* buf, word32 buffSz,\n                    RsaKey* rsaKey, ecc_key* eccKey, ed25519_key* ed25519Key,\n                    ed448_key* ed448Key, WC_RNG* rng)\n{\n    int sigSz = 0;\n    void* heap = NULL;\n    CertSignCtx* certSignCtx;\n#ifndef WOLFSSL_ASYNC_CRYPT\n    CertSignCtx  certSignCtx_lcl;\n\n    certSignCtx = &certSignCtx_lcl;\n    XMEMSET(certSignCtx, 0, sizeof(CertSignCtx));\n#else\n    certSignCtx = NULL;\n#endif\n\n    if (requestSz < 0)\n        return requestSz;\n\n    /* locate ctx */\n    if (rsaKey) {\n    #ifndef NO_RSA\n    #ifdef WOLFSSL_ASYNC_CRYPT\n        certSignCtx = &rsaKey->certSignCtx;\n    #endif\n        heap = rsaKey->heap;\n    #else\n        return NOT_COMPILED_IN;\n    #endif /* NO_RSA */\n    }\n    else if (eccKey) {\n    #ifdef HAVE_ECC\n    #ifdef WOLFSSL_ASYNC_CRYPT\n        certSignCtx = &eccKey->certSignCtx;\n    #endif\n        heap = eccKey->heap;\n    #else\n        return NOT_COMPILED_IN;\n    #endif /* HAVE_ECC */\n    }\n\n#ifdef WOLFSSL_ASYNC_CRYPT\n    if (certSignCtx == NULL) {\n        return BAD_FUNC_ARG;\n    }\n#endif\n\n    if (certSignCtx->sig == NULL) {\n        certSignCtx->sig = (byte*)XMALLOC(MAX_ENCODED_SIG_SZ, heap,\n            DYNAMIC_TYPE_TMP_BUFFER);\n        if (certSignCtx->sig == NULL)\n            return MEMORY_E;\n    }\n\n    sigSz = MakeSignature(certSignCtx, buf, requestSz, certSignCtx->sig,\n        MAX_ENCODED_SIG_SZ, rsaKey, eccKey, ed25519Key, ed448Key, rng, sType,\n        heap);\n#ifdef WOLFSSL_ASYNC_CRYPT\n    if (sigSz == WC_PENDING_E) {\n        /* Not free'ing certSignCtx->sig here because it could still be in use\n         * with async operations. */\n        return sigSz;\n    }\n#endif\n\n    if (sigSz >= 0) {\n        if (requestSz + MAX_SEQ_SZ * 2 + sigSz > (int)buffSz)\n            sigSz = BUFFER_E;\n        else\n            sigSz = AddSignature(buf, requestSz, certSignCtx->sig, sigSz,\n                                 sType);\n    }\n\n    XFREE(certSignCtx->sig, heap, DYNAMIC_TYPE_TMP_BUFFER);\n    certSignCtx->sig = NULL;\n\n    return sigSz;\n}\n\nint wc_SignCert_ex(int requestSz, int sType, byte* buf, word32 buffSz,\n                   int keyType, void* key, WC_RNG* rng)\n{\n    RsaKey*      rsaKey = NULL;\n    ecc_key*     eccKey = NULL;\n    ed25519_key* ed25519Key = NULL;\n    ed448_key*   ed448Key = NULL;\n\n    if (keyType == RSA_TYPE)\n        rsaKey = (RsaKey*)key;\n    else if (keyType == ECC_TYPE)\n        eccKey = (ecc_key*)key;\n    else if (keyType == ED25519_TYPE)\n        ed25519Key = (ed25519_key*)key;\n    else if (keyType == ED448_TYPE)\n        ed448Key = (ed448_key*)key;\n\n    return SignCert(requestSz, sType, buf, buffSz, rsaKey, eccKey, ed25519Key,\n                    ed448Key, rng);\n}\n\nint wc_SignCert(int requestSz, int sType, byte* buf, word32 buffSz,\n                RsaKey* rsaKey, ecc_key* eccKey, WC_RNG* rng)\n{\n    return SignCert(requestSz, sType, buf, buffSz, rsaKey, eccKey, NULL, NULL,\n                    rng);\n}\n\nint wc_MakeSelfCert(Cert* cert, byte* buf, word32 buffSz,\n                    RsaKey* key, WC_RNG* rng)\n{\n    int ret;\n\n    ret = wc_MakeCert(cert, buf, buffSz, key, NULL, rng);\n    if (ret < 0)\n        return ret;\n\n    return wc_SignCert(cert->bodySz, cert->sigType,\n                       buf, buffSz, key, NULL, rng);\n}\n\n\n#ifdef WOLFSSL_CERT_EXT\n\n/* Get raw subject from cert, which may contain OIDs not parsed by Decode.\n   The raw subject pointer will only be valid while \"cert\" is valid. */\nint wc_GetSubjectRaw(byte **subjectRaw, Cert *cert)\n{\n    int rc = BAD_FUNC_ARG;\n    if ((subjectRaw != NULL) && (cert != NULL)) {\n        *subjectRaw = cert->sbjRaw;\n        rc = 0;\n    }\n    return rc;\n}\n\n/* Set KID from public key */\nstatic int SetKeyIdFromPublicKey(Cert *cert, RsaKey *rsakey, ecc_key *eckey,\n                                 byte *ntruKey, word16 ntruKeySz,\n                                 ed25519_key* ed25519Key, ed448_key* ed448Key,\n                                 int kid_type)\n{\n    byte *buf;\n    int   bufferSz, ret;\n\n    if (cert == NULL ||\n        (rsakey == NULL && eckey == NULL && ntruKey == NULL &&\n                                      ed25519Key == NULL && ed448Key == NULL) ||\n        (kid_type != SKID_TYPE && kid_type != AKID_TYPE))\n        return BAD_FUNC_ARG;\n\n    buf = (byte *)XMALLOC(MAX_PUBLIC_KEY_SZ, cert->heap,\n                                                       DYNAMIC_TYPE_TMP_BUFFER);\n    if (buf == NULL)\n        return MEMORY_E;\n\n    /* Public Key */\n    bufferSz = -1;\n#ifndef NO_RSA\n    /* RSA public key */\n    if (rsakey != NULL)\n        bufferSz = SetRsaPublicKey(buf, rsakey, MAX_PUBLIC_KEY_SZ, 0);\n#endif\n#ifdef HAVE_ECC\n    /* ECC public key */\n    if (eckey != NULL)\n        bufferSz = SetEccPublicKey(buf, eckey, 0);\n#endif\n#ifdef HAVE_NTRU\n    /* NTRU public key */\n    if (ntruKey != NULL) {\n        bufferSz = MAX_PUBLIC_KEY_SZ;\n        ret = ntru_crypto_ntru_encrypt_publicKey2SubjectPublicKeyInfo(\n                        ntruKeySz, ntruKey, (word16 *)(&bufferSz), buf);\n        if (ret != NTRU_OK)\n            bufferSz = -1;\n    }\n#else\n    (void)ntruKeySz;\n#endif\n#ifdef HAVE_ED25519\n    /* ED25519 public key */\n    if (ed25519Key != NULL)\n        bufferSz = SetEd25519PublicKey(buf, ed25519Key, 0);\n#endif\n#ifdef HAVE_ED448\n    /* ED448 public key */\n    if (ed448Key != NULL)\n        bufferSz = SetEd448PublicKey(buf, ed448Key, 0);\n#endif\n\n    if (bufferSz <= 0) {\n        XFREE(buf, cert->heap, DYNAMIC_TYPE_TMP_BUFFER);\n        return PUBLIC_KEY_E;\n    }\n\n    /* Compute SKID by hashing public key */\n    if (kid_type == SKID_TYPE) {\n        ret = CalcHashId(buf, bufferSz, cert->skid);\n        cert->skidSz = KEYID_SIZE;\n    }\n    else if (kid_type == AKID_TYPE) {\n        ret = CalcHashId(buf, bufferSz, cert->akid);\n        cert->akidSz = KEYID_SIZE;\n    }\n    else\n        ret = BAD_FUNC_ARG;\n\n    XFREE(buf, cert->heap, DYNAMIC_TYPE_TMP_BUFFER);\n    return ret;\n}\n\nint wc_SetSubjectKeyIdFromPublicKey_ex(Cert *cert, int keyType, void* key)\n{\n    RsaKey*      rsaKey = NULL;\n    ecc_key*     eccKey = NULL;\n    ed25519_key* ed25519Key = NULL;\n    ed448_key*   ed448Key = NULL;\n\n    if (keyType == RSA_TYPE)\n        rsaKey = (RsaKey*)key;\n    else if (keyType == ECC_TYPE)\n        eccKey = (ecc_key*)key;\n    else if (keyType == ED25519_TYPE)\n        ed25519Key = (ed25519_key*)key;\n    else if (keyType == ED448_TYPE)\n        ed448Key = (ed448_key*)key;\n\n    return SetKeyIdFromPublicKey(cert, rsaKey, eccKey, NULL, 0, ed25519Key,\n                                 ed448Key, SKID_TYPE);\n}\n\n/* Set SKID from RSA or ECC public key */\nint wc_SetSubjectKeyIdFromPublicKey(Cert *cert, RsaKey *rsakey, ecc_key *eckey)\n{\n    return SetKeyIdFromPublicKey(cert, rsakey, eckey, NULL, 0, NULL, NULL,\n                                 SKID_TYPE);\n}\n\n#ifdef HAVE_NTRU\n/* Set SKID from NTRU public key */\nint wc_SetSubjectKeyIdFromNtruPublicKey(Cert *cert,\n                                        byte *ntruKey, word16 ntruKeySz)\n{\n    return SetKeyIdFromPublicKey(cert, NULL,NULL,ntruKey, ntruKeySz, NULL, NULL,\n                                 SKID_TYPE);\n}\n#endif\n\nint wc_SetAuthKeyIdFromPublicKey_ex(Cert *cert, int keyType, void* key)\n{\n    RsaKey*      rsaKey = NULL;\n    ecc_key*     eccKey = NULL;\n    ed25519_key* ed25519Key = NULL;\n    ed448_key*   ed448Key = NULL;\n\n    if (keyType == RSA_TYPE)\n        rsaKey = (RsaKey*)key;\n    else if (keyType == ECC_TYPE)\n        eccKey = (ecc_key*)key;\n    else if (keyType == ED25519_TYPE)\n        ed25519Key = (ed25519_key*)key;\n    else if (keyType == ED448_TYPE)\n        ed448Key = (ed448_key*)key;\n\n    return SetKeyIdFromPublicKey(cert, rsaKey, eccKey, NULL, 0, ed25519Key,\n                                 ed448Key, AKID_TYPE);\n}\n\n/* Set SKID from RSA or ECC public key */\nint wc_SetAuthKeyIdFromPublicKey(Cert *cert, RsaKey *rsakey, ecc_key *eckey)\n{\n    return SetKeyIdFromPublicKey(cert, rsakey, eckey, NULL, 0, NULL, NULL,\n                                 AKID_TYPE);\n}\n\n\n#if !defined(NO_FILESYSTEM) && !defined(NO_ASN_CRYPT)\n\n/* Set SKID from public key file in PEM */\nint wc_SetSubjectKeyId(Cert *cert, const char* file)\n{\n    int     ret, derSz;\n    byte*   der;\n    word32  idx;\n    RsaKey  *rsakey = NULL;\n    ecc_key *eckey = NULL;\n\n    if (cert == NULL || file == NULL)\n        return BAD_FUNC_ARG;\n\n    der = (byte*)XMALLOC(MAX_PUBLIC_KEY_SZ, cert->heap, DYNAMIC_TYPE_CERT);\n    if (der == NULL) {\n        WOLFSSL_MSG(\"wc_SetSubjectKeyId memory Problem\");\n        return MEMORY_E;\n    }\n    derSz = MAX_PUBLIC_KEY_SZ;\n\n    XMEMSET(der, 0, derSz);\n    derSz = wc_PemPubKeyToDer(file, der, derSz);\n    if (derSz <= 0) {\n        XFREE(der, cert->heap, DYNAMIC_TYPE_CERT);\n        return derSz;\n    }\n\n    /* Load PubKey in internal structure */\n#ifndef NO_RSA\n    rsakey = (RsaKey*) XMALLOC(sizeof(RsaKey), cert->heap, DYNAMIC_TYPE_RSA);\n    if (rsakey == NULL) {\n        XFREE(der, cert->heap, DYNAMIC_TYPE_CERT);\n        return MEMORY_E;\n    }\n\n    if (wc_InitRsaKey(rsakey, cert->heap) != 0) {\n        WOLFSSL_MSG(\"wc_InitRsaKey failure\");\n        XFREE(rsakey, cert->heap, DYNAMIC_TYPE_RSA);\n        XFREE(der, cert->heap, DYNAMIC_TYPE_CERT);\n        return MEMORY_E;\n    }\n\n    idx = 0;\n    ret = wc_RsaPublicKeyDecode(der, &idx, rsakey, derSz);\n    if (ret != 0)\n#endif\n    {\n#ifndef NO_RSA\n        WOLFSSL_MSG(\"wc_RsaPublicKeyDecode failed\");\n        wc_FreeRsaKey(rsakey);\n        XFREE(rsakey, cert->heap, DYNAMIC_TYPE_RSA);\n        rsakey = NULL;\n#endif\n#ifdef HAVE_ECC\n        /* Check to load ecc public key */\n        eckey = (ecc_key*) XMALLOC(sizeof(ecc_key), cert->heap,\n                                                              DYNAMIC_TYPE_ECC);\n        if (eckey == NULL) {\n            XFREE(der, cert->heap, DYNAMIC_TYPE_CERT);\n            return MEMORY_E;\n        }\n\n        if (wc_ecc_init(eckey) != 0) {\n            WOLFSSL_MSG(\"wc_ecc_init failure\");\n            wc_ecc_free(eckey);\n            XFREE(eckey, cert->heap, DYNAMIC_TYPE_ECC);\n            XFREE(der, cert->heap, DYNAMIC_TYPE_CERT);\n            return MEMORY_E;\n        }\n\n        idx = 0;\n        ret = wc_EccPublicKeyDecode(der, &idx, eckey, derSz);\n        if (ret != 0) {\n            WOLFSSL_MSG(\"wc_EccPublicKeyDecode failed\");\n            XFREE(der, cert->heap, DYNAMIC_TYPE_CERT);\n            wc_ecc_free(eckey);\n            XFREE(eckey, cert->heap, DYNAMIC_TYPE_ECC);\n            return PUBLIC_KEY_E;\n        }\n#else\n        XFREE(der, cert->heap, DYNAMIC_TYPE_CERT);\n        return PUBLIC_KEY_E;\n#endif /* HAVE_ECC */\n    }\n\n    XFREE(der, cert->heap, DYNAMIC_TYPE_CERT);\n\n    ret = wc_SetSubjectKeyIdFromPublicKey(cert, rsakey, eckey);\n\n#ifndef NO_RSA\n    wc_FreeRsaKey(rsakey);\n    XFREE(rsakey, cert->heap, DYNAMIC_TYPE_RSA);\n#endif\n#ifdef HAVE_ECC\n    wc_ecc_free(eckey);\n    XFREE(eckey, cert->heap, DYNAMIC_TYPE_ECC);\n#endif\n    return ret;\n}\n\n#endif /* !NO_FILESYSTEM && !NO_ASN_CRYPT */\n\nstatic int SetAuthKeyIdFromDcert(Cert* cert, DecodedCert* decoded)\n{\n    int ret = 0;\n\n    /* Subject Key Id not found !! */\n    if (decoded->extSubjKeyIdSet == 0) {\n        ret = ASN_NO_SKID;\n    }\n\n    /* SKID invalid size */\n    else if (sizeof(cert->akid) < sizeof(decoded->extSubjKeyId)) {\n        ret = MEMORY_E;\n    }\n\n    else {\n        /* Put the SKID of CA to AKID of certificate */\n        XMEMCPY(cert->akid, decoded->extSubjKeyId, KEYID_SIZE);\n        cert->akidSz = KEYID_SIZE;\n    }\n\n    return ret;\n}\n\n/* Set AKID from certificate contains in buffer (DER encoded) */\nint wc_SetAuthKeyIdFromCert(Cert *cert, const byte *der, int derSz)\n{\n    int ret = 0;\n\n    if (cert == NULL) {\n        ret = BAD_FUNC_ARG;\n    }\n    else {\n        /* Check if decodedCert is cached */\n        if (cert->der != der) {\n            /* Allocate cache for the decoded cert */\n            ret = wc_SetCert_LoadDer(cert, der, derSz);\n        }\n\n        if (ret >= 0) {\n            ret = SetAuthKeyIdFromDcert(cert, (DecodedCert*)cert->decodedCert);\n#ifndef WOLFSSL_CERT_GEN_CACHE\n            wc_SetCert_Free(cert);\n#endif\n        }\n    }\n\n    return ret;\n}\n\n\n#ifndef NO_FILESYSTEM\n\n/* Set AKID from certificate file in PEM */\nint wc_SetAuthKeyId(Cert *cert, const char* file)\n{\n    int         ret;\n    int         derSz;\n    byte*       der;\n\n    if (cert == NULL || file == NULL)\n        return BAD_FUNC_ARG;\n\n    der = (byte*)XMALLOC(EIGHTK_BUF, cert->heap, DYNAMIC_TYPE_CERT);\n    if (der == NULL) {\n        WOLFSSL_MSG(\"wc_SetAuthKeyId OOF Problem\");\n        return MEMORY_E;\n    }\n\n    derSz = wc_PemCertToDer(file, der, EIGHTK_BUF);\n    if (derSz <= 0)\n    {\n        XFREE(der, cert->heap, DYNAMIC_TYPE_CERT);\n        return derSz;\n    }\n\n    ret = wc_SetAuthKeyIdFromCert(cert, der, derSz);\n    XFREE(der, cert->heap, DYNAMIC_TYPE_CERT);\n\n    return ret;\n}\n\n#endif /* !NO_FILESYSTEM */\n\n/* Set KeyUsage from human readable string */\nint wc_SetKeyUsage(Cert *cert, const char *value)\n{\n    int ret = 0;\n    char *token, *str, *ptr;\n    word32 len;\n\n    if (cert == NULL || value == NULL)\n        return BAD_FUNC_ARG;\n\n    cert->keyUsage = 0;\n\n    /* duplicate string (including terminator) */\n    len = (word32)XSTRLEN(value);\n    str = (char*)XMALLOC(len+1, cert->heap, DYNAMIC_TYPE_TMP_BUFFER);\n    if (str == NULL)\n        return MEMORY_E;\n    XMEMCPY(str, value, len+1);\n\n    /* parse value, and set corresponding Key Usage value */\n    if ((token = XSTRTOK(str, \",\", &ptr)) == NULL) {\n        XFREE(str, cert->heap, DYNAMIC_TYPE_TMP_BUFFER);\n        return KEYUSAGE_E;\n    }\n    while (token != NULL)\n    {\n        len = (word32)XSTRLEN(token);\n\n        if (!XSTRNCASECMP(token, \"digitalSignature\", len))\n            cert->keyUsage |= KEYUSE_DIGITAL_SIG;\n        else if (!XSTRNCASECMP(token, \"nonRepudiation\", len) ||\n                 !XSTRNCASECMP(token, \"contentCommitment\", len))\n            cert->keyUsage |= KEYUSE_CONTENT_COMMIT;\n        else if (!XSTRNCASECMP(token, \"keyEncipherment\", len))\n            cert->keyUsage |= KEYUSE_KEY_ENCIPHER;\n        else if (!XSTRNCASECMP(token, \"dataEncipherment\", len))\n            cert->keyUsage |= KEYUSE_DATA_ENCIPHER;\n        else if (!XSTRNCASECMP(token, \"keyAgreement\", len))\n            cert->keyUsage |= KEYUSE_KEY_AGREE;\n        else if (!XSTRNCASECMP(token, \"keyCertSign\", len))\n            cert->keyUsage |= KEYUSE_KEY_CERT_SIGN;\n        else if (!XSTRNCASECMP(token, \"cRLSign\", len))\n            cert->keyUsage |= KEYUSE_CRL_SIGN;\n        else if (!XSTRNCASECMP(token, \"encipherOnly\", len))\n            cert->keyUsage |= KEYUSE_ENCIPHER_ONLY;\n        else if (!XSTRNCASECMP(token, \"decipherOnly\", len))\n            cert->keyUsage |= KEYUSE_DECIPHER_ONLY;\n        else {\n            ret = KEYUSAGE_E;\n            break;\n        }\n\n        token = XSTRTOK(NULL, \",\", &ptr);\n    }\n\n    XFREE(str, cert->heap, DYNAMIC_TYPE_TMP_BUFFER);\n    return ret;\n}\n\n/* Set ExtendedKeyUsage from human readable string */\nint wc_SetExtKeyUsage(Cert *cert, const char *value)\n{\n    int ret = 0;\n    char *token, *str, *ptr;\n    word32 len;\n\n    if (cert == NULL || value == NULL)\n        return BAD_FUNC_ARG;\n\n    cert->extKeyUsage = 0;\n\n    /* duplicate string (including terminator) */\n    len = (word32)XSTRLEN(value);\n    str = (char*)XMALLOC(len+1, cert->heap, DYNAMIC_TYPE_TMP_BUFFER);\n    if (str == NULL)\n        return MEMORY_E;\n    XMEMCPY(str, value, len+1);\n\n    /* parse value, and set corresponding Key Usage value */\n    if ((token = XSTRTOK(str, \",\", &ptr)) == NULL) {\n        XFREE(str, cert->heap, DYNAMIC_TYPE_TMP_BUFFER);\n        return EXTKEYUSAGE_E;\n    }\n\n    while (token != NULL)\n    {\n        len = (word32)XSTRLEN(token);\n\n        if (!XSTRNCASECMP(token, \"any\", len))\n            cert->extKeyUsage |= EXTKEYUSE_ANY;\n        else if (!XSTRNCASECMP(token, \"serverAuth\", len))\n            cert->extKeyUsage |= EXTKEYUSE_SERVER_AUTH;\n        else if (!XSTRNCASECMP(token, \"clientAuth\", len))\n            cert->extKeyUsage |= EXTKEYUSE_CLIENT_AUTH;\n        else if (!XSTRNCASECMP(token, \"codeSigning\", len))\n            cert->extKeyUsage |= EXTKEYUSE_CODESIGN;\n        else if (!XSTRNCASECMP(token, \"emailProtection\", len))\n            cert->extKeyUsage |= EXTKEYUSE_EMAILPROT;\n        else if (!XSTRNCASECMP(token, \"timeStamping\", len))\n            cert->extKeyUsage |= EXTKEYUSE_TIMESTAMP;\n        else if (!XSTRNCASECMP(token, \"OCSPSigning\", len))\n            cert->extKeyUsage |= EXTKEYUSE_OCSP_SIGN;\n        else {\n            ret = EXTKEYUSAGE_E;\n            break;\n        }\n\n        token = XSTRTOK(NULL, \",\", &ptr);\n    }\n\n    XFREE(str, cert->heap, DYNAMIC_TYPE_TMP_BUFFER);\n    return ret;\n}\n\n#ifdef WOLFSSL_EKU_OID\n/*\n * cert structure to set EKU oid in\n * oid  the oid in byte representation\n * sz   size of oid buffer\n * idx  index of array to place oid\n *\n * returns 0 on success\n */\nint wc_SetExtKeyUsageOID(Cert *cert, const char *in, word32 sz, byte idx,\n        void* heap)\n{\n    byte oid[MAX_OID_SZ];\n    word32 oidSz = MAX_OID_SZ;\n\n    if (idx >= CTC_MAX_EKU_NB || sz >= CTC_MAX_EKU_OID_SZ) {\n        WOLFSSL_MSG(\"Either idx or sz was too large\");\n        return BAD_FUNC_ARG;\n    }\n\n    if (EncodePolicyOID(oid, &oidSz, in, heap) != 0) {\n        return BUFFER_E;\n    }\n\n    XMEMCPY(cert->extKeyUsageOID[idx], oid, oidSz);\n    cert->extKeyUsageOIDSz[idx] = oidSz;\n    cert->extKeyUsage |= EXTKEYUSE_USER;\n\n    return 0;\n}\n#endif /* WOLFSSL_EKU_OID */\n#endif /* WOLFSSL_CERT_EXT */\n\n\n#ifdef WOLFSSL_ALT_NAMES\n\nstatic int SetAltNamesFromDcert(Cert* cert, DecodedCert* decoded)\n{\n    int ret = 0;\n\n    cert->altNamesSz = 0;\n    if (decoded->altNames) {\n        ret = FlattenAltNames(cert->altNames,\n            sizeof(cert->altNames), decoded->altNames);\n        if (ret >= 0) {\n            cert->altNamesSz = ret;\n            ret = 0;\n        }\n    }\n\n    return ret;\n}\n\n#ifndef NO_FILESYSTEM\n\n/* Set Alt Names from der cert, return 0 on success */\nstatic int SetAltNamesFromCert(Cert* cert, const byte* der, int derSz)\n{\n    int ret;\n#ifdef WOLFSSL_SMALL_STACK\n    DecodedCert* decoded;\n#else\n    DecodedCert decoded[1];\n#endif\n\n    if (derSz < 0)\n        return derSz;\n\n#ifdef WOLFSSL_SMALL_STACK\n    decoded = (DecodedCert*)XMALLOC(sizeof(DecodedCert), cert->heap,\n                                                       DYNAMIC_TYPE_TMP_BUFFER);\n    if (decoded == NULL)\n        return MEMORY_E;\n#endif\n\n    InitDecodedCert(decoded, der, derSz, NULL);\n    ret = ParseCertRelative(decoded, CA_TYPE, NO_VERIFY, 0);\n\n    if (ret < 0) {\n        WOLFSSL_MSG(\"ParseCertRelative error\");\n    }\n    else {\n        ret = SetAltNamesFromDcert(cert, decoded);\n    }\n\n    FreeDecodedCert(decoded);\n#ifdef WOLFSSL_SMALL_STACK\n    XFREE(decoded, cert->heap, DYNAMIC_TYPE_TMP_BUFFER);\n#endif\n\n    return ret < 0 ? ret : 0;\n}\n\n#endif\n\nstatic int SetDatesFromDcert(Cert* cert, DecodedCert* decoded)\n{\n    int ret = 0;\n\n    if (decoded->beforeDate == NULL || decoded->afterDate == NULL) {\n        WOLFSSL_MSG(\"Couldn't extract dates\");\n        ret = -1;\n    }\n    else if (decoded->beforeDateLen > MAX_DATE_SIZE ||\n                                        decoded->afterDateLen > MAX_DATE_SIZE) {\n        WOLFSSL_MSG(\"Bad date size\");\n        ret = -1;\n    }\n    else {\n        XMEMCPY(cert->beforeDate, decoded->beforeDate, decoded->beforeDateLen);\n        XMEMCPY(cert->afterDate,  decoded->afterDate,  decoded->afterDateLen);\n\n        cert->beforeDateSz = decoded->beforeDateLen;\n        cert->afterDateSz  = decoded->afterDateLen;\n    }\n\n    return ret;\n}\n\n#endif /* WOLFSSL_ALT_NAMES */\n\nstatic void SetNameFromDcert(CertName* cn, DecodedCert* decoded)\n{\n    int sz;\n\n    if (decoded->subjectCN) {\n        sz = (decoded->subjectCNLen < CTC_NAME_SIZE) ? decoded->subjectCNLen\n                                                     : CTC_NAME_SIZE - 1;\n        XSTRNCPY(cn->commonName, decoded->subjectCN, sz);\n        cn->commonName[sz] = '\\0';\n        cn->commonNameEnc = decoded->subjectCNEnc;\n    }\n    if (decoded->subjectC) {\n        sz = (decoded->subjectCLen < CTC_NAME_SIZE) ? decoded->subjectCLen\n                                                    : CTC_NAME_SIZE - 1;\n        XSTRNCPY(cn->country, decoded->subjectC, sz);\n        cn->country[sz] = '\\0';\n        cn->countryEnc = decoded->subjectCEnc;\n    }\n    if (decoded->subjectST) {\n        sz = (decoded->subjectSTLen < CTC_NAME_SIZE) ? decoded->subjectSTLen\n                                                     : CTC_NAME_SIZE - 1;\n        XSTRNCPY(cn->state, decoded->subjectST, sz);\n        cn->state[sz] = '\\0';\n        cn->stateEnc = decoded->subjectSTEnc;\n    }\n    if (decoded->subjectL) {\n        sz = (decoded->subjectLLen < CTC_NAME_SIZE) ? decoded->subjectLLen\n                                                    : CTC_NAME_SIZE - 1;\n        XSTRNCPY(cn->locality, decoded->subjectL, sz);\n        cn->locality[sz] = '\\0';\n        cn->localityEnc = decoded->subjectLEnc;\n    }\n    if (decoded->subjectO) {\n        sz = (decoded->subjectOLen < CTC_NAME_SIZE) ? decoded->subjectOLen\n                                                    : CTC_NAME_SIZE - 1;\n        XSTRNCPY(cn->org, decoded->subjectO, sz);\n        cn->org[sz] = '\\0';\n        cn->orgEnc = decoded->subjectOEnc;\n    }\n    if (decoded->subjectOU) {\n        sz = (decoded->subjectOULen < CTC_NAME_SIZE) ? decoded->subjectOULen\n                                                     : CTC_NAME_SIZE - 1;\n        XSTRNCPY(cn->unit, decoded->subjectOU, sz);\n        cn->unit[sz] = '\\0';\n        cn->unitEnc = decoded->subjectOUEnc;\n    }\n    if (decoded->subjectSN) {\n        sz = (decoded->subjectSNLen < CTC_NAME_SIZE) ? decoded->subjectSNLen\n                                                     : CTC_NAME_SIZE - 1;\n        XSTRNCPY(cn->sur, decoded->subjectSN, sz);\n        cn->sur[sz] = '\\0';\n        cn->surEnc = decoded->subjectSNEnc;\n    }\n    if (decoded->subjectSND) {\n        sz = (decoded->subjectSNDLen < CTC_NAME_SIZE) ? decoded->subjectSNDLen\n                                                     : CTC_NAME_SIZE - 1;\n        XSTRNCPY(cn->serialDev, decoded->subjectSND, sz);\n        cn->serialDev[sz] = '\\0';\n        cn->serialDevEnc = decoded->subjectSNDEnc;\n    }\n#ifdef WOLFSSL_CERT_EXT\n    if (decoded->subjectBC) {\n        sz = (decoded->subjectBCLen < CTC_NAME_SIZE) ? decoded->subjectBCLen\n                                                     : CTC_NAME_SIZE - 1;\n        XSTRNCPY(cn->busCat, decoded->subjectBC, sz);\n        cn->busCat[sz] = '\\0';\n        cn->busCatEnc = decoded->subjectBCEnc;\n    }\n    if (decoded->subjectJC) {\n        sz = (decoded->subjectJCLen < CTC_NAME_SIZE) ? decoded->subjectJCLen\n                                                     : CTC_NAME_SIZE - 1;\n        XSTRNCPY(cn->joiC, decoded->subjectJC, sz);\n        cn->joiC[sz] = '\\0';\n        cn->joiCEnc = decoded->subjectJCEnc;\n    }\n    if (decoded->subjectJS) {\n        sz = (decoded->subjectJSLen < CTC_NAME_SIZE) ? decoded->subjectJSLen\n                                                     : CTC_NAME_SIZE - 1;\n        XSTRNCPY(cn->joiSt, decoded->subjectJS, sz);\n        cn->joiSt[sz] = '\\0';\n        cn->joiStEnc = decoded->subjectJSEnc;\n    }\n#endif\n    if (decoded->subjectEmail) {\n        sz = (decoded->subjectEmailLen < CTC_NAME_SIZE)\n           ?  decoded->subjectEmailLen : CTC_NAME_SIZE - 1;\n        XSTRNCPY(cn->email, decoded->subjectEmail, sz);\n        cn->email[sz] = '\\0';\n    }\n}\n\n#ifndef NO_FILESYSTEM\n\n/* Set cn name from der buffer, return 0 on success */\nstatic int SetNameFromCert(CertName* cn, const byte* der, int derSz)\n{\n    int ret;\n#ifdef WOLFSSL_SMALL_STACK\n    DecodedCert* decoded;\n#else\n    DecodedCert decoded[1];\n#endif\n\n    if (derSz < 0)\n        return derSz;\n\n#ifdef WOLFSSL_SMALL_STACK\n    decoded = (DecodedCert*)XMALLOC(sizeof(DecodedCert), NULL,\n                                                       DYNAMIC_TYPE_TMP_BUFFER);\n    if (decoded == NULL)\n        return MEMORY_E;\n#endif\n\n    InitDecodedCert(decoded, der, derSz, NULL);\n    ret = ParseCertRelative(decoded, CA_TYPE, NO_VERIFY, 0);\n\n    if (ret < 0) {\n        WOLFSSL_MSG(\"ParseCertRelative error\");\n    }\n    else {\n        SetNameFromDcert(cn, decoded);\n    }\n\n    FreeDecodedCert(decoded);\n\n#ifdef WOLFSSL_SMALL_STACK\n    XFREE(decoded, NULL, DYNAMIC_TYPE_TMP_BUFFER);\n#endif\n\n    return ret < 0 ? ret : 0;\n}\n\n/* Set cert issuer from issuerFile in PEM */\nint wc_SetIssuer(Cert* cert, const char* issuerFile)\n{\n    int         ret;\n    int         derSz;\n    byte*       der;\n\n    if (cert == NULL) {\n        return BAD_FUNC_ARG;\n    }\n\n    der = (byte*)XMALLOC(EIGHTK_BUF, cert->heap, DYNAMIC_TYPE_CERT);\n    if (der == NULL) {\n        WOLFSSL_MSG(\"wc_SetIssuer OOF Problem\");\n        return MEMORY_E;\n    }\n    derSz = wc_PemCertToDer(issuerFile, der, EIGHTK_BUF);\n    cert->selfSigned = 0;\n    ret = SetNameFromCert(&cert->issuer, der, derSz);\n    XFREE(der, cert->heap, DYNAMIC_TYPE_CERT);\n\n    return ret;\n}\n\n\n/* Set cert subject from subjectFile in PEM */\nint wc_SetSubject(Cert* cert, const char* subjectFile)\n{\n    int         ret;\n    int         derSz;\n    byte*       der;\n\n    if (cert == NULL) {\n        return BAD_FUNC_ARG;\n    }\n\n    der = (byte*)XMALLOC(EIGHTK_BUF, cert->heap, DYNAMIC_TYPE_CERT);\n    if (der == NULL) {\n        WOLFSSL_MSG(\"wc_SetSubject OOF Problem\");\n        return MEMORY_E;\n    }\n\n    derSz = wc_PemCertToDer(subjectFile, der, EIGHTK_BUF);\n    ret = SetNameFromCert(&cert->subject, der, derSz);\n    XFREE(der, cert->heap, DYNAMIC_TYPE_CERT);\n\n    return ret;\n}\n\n#ifdef WOLFSSL_ALT_NAMES\n\n/* Set alt names from file in PEM */\nint wc_SetAltNames(Cert* cert, const char* file)\n{\n    int         ret;\n    int         derSz;\n    byte*       der;\n\n    if (cert == NULL) {\n        return BAD_FUNC_ARG;\n    }\n\n    der = (byte*)XMALLOC(EIGHTK_BUF, cert->heap, DYNAMIC_TYPE_CERT);\n    if (der == NULL) {\n        WOLFSSL_MSG(\"wc_SetAltNames OOF Problem\");\n        return MEMORY_E;\n    }\n    derSz = wc_PemCertToDer(file, der, EIGHTK_BUF);\n    ret = SetAltNamesFromCert(cert, der, derSz);\n    XFREE(der, cert->heap, DYNAMIC_TYPE_CERT);\n\n    return ret;\n}\n\n#endif /* WOLFSSL_ALT_NAMES */\n\n#endif /* !NO_FILESYSTEM */\n\n/* Set cert issuer from DER buffer */\nint wc_SetIssuerBuffer(Cert* cert, const byte* der, int derSz)\n{\n    int ret = 0;\n\n    if (cert == NULL) {\n        ret = BAD_FUNC_ARG;\n    }\n    else {\n        cert->selfSigned = 0;\n\n        /* Check if decodedCert is cached */\n        if (cert->der != der) {\n            /* Allocate cache for the decoded cert */\n            ret = wc_SetCert_LoadDer(cert, der, derSz);\n        }\n\n        if (ret >= 0) {\n            SetNameFromDcert(&cert->issuer, (DecodedCert*)cert->decodedCert);\n#ifndef WOLFSSL_CERT_GEN_CACHE\n            wc_SetCert_Free(cert);\n#endif\n        }\n    }\n\n    return ret;\n}\n\n/* Set cert subject from DER buffer */\nint wc_SetSubjectBuffer(Cert* cert, const byte* der, int derSz)\n{\n    int ret = 0;\n\n    if (cert == NULL) {\n        ret = BAD_FUNC_ARG;\n    }\n    else {\n        /* Check if decodedCert is cached */\n        if (cert->der != der) {\n            /* Allocate cache for the decoded cert */\n            ret = wc_SetCert_LoadDer(cert, der, derSz);\n        }\n\n        if (ret >= 0) {\n            SetNameFromDcert(&cert->subject, (DecodedCert*)cert->decodedCert);\n#ifndef WOLFSSL_CERT_GEN_CACHE\n            wc_SetCert_Free(cert);\n#endif\n        }\n    }\n\n    return ret;\n}\n#ifdef WOLFSSL_CERT_EXT\n/* Set cert raw subject from DER buffer */\nint wc_SetSubjectRaw(Cert* cert, const byte* der, int derSz)\n{\n    int ret = 0;\n\n    if (cert == NULL) {\n        ret = BAD_FUNC_ARG;\n    }\n    else {\n        /* Check if decodedCert is cached */\n        if (cert->der != der) {\n            /* Allocate cache for the decoded cert */\n            ret = wc_SetCert_LoadDer(cert, der, derSz);\n        }\n\n        if (ret >= 0) {\n            if ((((DecodedCert*)cert->decodedCert)->subjectRaw) &&\n                (((DecodedCert*)cert->decodedCert)->subjectRawLen <=\n                        (int)sizeof(CertName))) {\n                XMEMCPY(cert->sbjRaw,\n                        ((DecodedCert*)cert->decodedCert)->subjectRaw,\n                        ((DecodedCert*)cert->decodedCert)->subjectRawLen);\n            }\n#ifndef WOLFSSL_CERT_GEN_CACHE\n            wc_SetCert_Free(cert);\n#endif\n        }\n    }\n\n    return ret;\n}\n\n/* Set cert raw issuer from DER buffer */\nint wc_SetIssuerRaw(Cert* cert, const byte* der, int derSz)\n{\n    int ret = 0;\n\n    if (cert == NULL) {\n        ret = BAD_FUNC_ARG;\n    }\n    else {\n        /* Check if decodedCert is cached */\n        if (cert->der != der) {\n            /* Allocate cache for the decoded cert */\n            ret = wc_SetCert_LoadDer(cert, der, derSz);\n        }\n\n        if (ret >= 0) {\n            if ((((DecodedCert*)cert->decodedCert)->subjectRaw) &&\n                (((DecodedCert*)cert->decodedCert)->subjectRawLen <=\n                        (int)sizeof(CertName))) {\n                /* Copy the subject to the issuer field */\n                XMEMCPY(cert->issRaw,\n                        ((DecodedCert*)cert->decodedCert)->subjectRaw,\n                        ((DecodedCert*)cert->decodedCert)->subjectRawLen);\n            }\n#ifndef WOLFSSL_CERT_GEN_CACHE\n            wc_SetCert_Free(cert);\n#endif\n        }\n    }\n    return ret;\n}\n#endif\n\n#ifdef WOLFSSL_ALT_NAMES\n\n/* Set cert alt names from DER buffer */\nint wc_SetAltNamesBuffer(Cert* cert, const byte* der, int derSz)\n{\n    int ret = 0;\n\n    if (cert == NULL) {\n       ret = BAD_FUNC_ARG;\n    }\n    else {\n        /* Check if decodedCert is cached */\n        if (cert->der != der) {\n            /* Allocate cache for the decoded cert */\n            ret = wc_SetCert_LoadDer(cert, der, derSz);\n        }\n\n        if (ret >= 0) {\n            ret = SetAltNamesFromDcert(cert, (DecodedCert*)cert->decodedCert);\n#ifndef WOLFSSL_CERT_GEN_CACHE\n            wc_SetCert_Free(cert);\n#endif\n       }\n    }\n\n    return(ret);\n}\n\n/* Set cert dates from DER buffer */\nint wc_SetDatesBuffer(Cert* cert, const byte* der, int derSz)\n{\n    int ret = 0;\n\n    if (cert == NULL) {\n     ret = BAD_FUNC_ARG;\n    }\n    else {\n        /* Check if decodedCert is cached */\n        if (cert->der != der) {\n            /* Allocate cache for the decoded cert */\n            ret = wc_SetCert_LoadDer(cert, der, derSz);\n        }\n\n        if (ret >= 0) {\n            ret = SetDatesFromDcert(cert, (DecodedCert*)cert->decodedCert);\n#ifndef WOLFSSL_CERT_GEN_CACHE\n            wc_SetCert_Free(cert);\n#endif\n        }\n    }\n\n    return(ret);\n}\n\n#endif /* WOLFSSL_ALT_NAMES */\n\n#endif /* WOLFSSL_CERT_GEN */\n\n#if (defined(WOLFSSL_CERT_GEN) && defined(WOLFSSL_CERT_EXT)) \\\n        || defined(OPENSSL_EXTRA)\n/* Encode OID string representation to ITU-T X.690 format */\nint EncodePolicyOID(byte *out, word32 *outSz, const char *in, void* heap)\n{\n    word32 val, idx = 0, nb_val;\n    char *token, *str, *ptr;\n    word32 len;\n\n    (void)heap;\n\n    if (out == NULL || outSz == NULL || *outSz < 2 || in == NULL)\n        return BAD_FUNC_ARG;\n\n    /* duplicate string (including terminator) */\n    len = (word32)XSTRLEN(in);\n    str = (char *)XMALLOC(len+1, heap, DYNAMIC_TYPE_TMP_BUFFER);\n    if (str == NULL)\n        return MEMORY_E;\n    XMEMCPY(str, in, len+1);\n\n    nb_val = 0;\n\n    /* parse value, and set corresponding Policy OID value */\n    token = XSTRTOK(str, \".\", &ptr);\n    while (token != NULL)\n    {\n        val = (word32)XATOI(token);\n\n        if (nb_val == 0) {\n            if (val > 2) {\n                XFREE(str, heap, DYNAMIC_TYPE_TMP_BUFFER);\n                return ASN_OBJECT_ID_E;\n            }\n\n            out[idx] = (byte)(40 * val);\n        }\n        else if (nb_val == 1) {\n            if (val > 127) {\n                XFREE(str, heap, DYNAMIC_TYPE_TMP_BUFFER);\n                return ASN_OBJECT_ID_E;\n            }\n\n            if (idx > *outSz) {\n                XFREE(str, heap, DYNAMIC_TYPE_TMP_BUFFER);\n                return BUFFER_E;\n            }\n\n            out[idx++] += (byte)val;\n        }\n        else {\n            word32  tb = 0, x;\n            int     i = 0;\n            byte    oid[MAX_OID_SZ];\n\n            while (val >= 128) {\n                x = val % 128;\n                val /= 128;\n                oid[i++] = (byte) (((tb++) ? 0x80 : 0) | x);\n            }\n\n            if ((idx+(word32)i) >= *outSz) {\n                XFREE(str, heap, DYNAMIC_TYPE_TMP_BUFFER);\n                return BUFFER_E;\n            }\n\n            oid[i] = (byte) (((tb++) ? 0x80 : 0) | val);\n\n            /* push value in the right order */\n            while (i >= 0)\n                out[idx++] = oid[i--];\n        }\n\n        token = XSTRTOK(NULL, \".\", &ptr);\n        nb_val++;\n    }\n\n    *outSz = idx;\n\n    XFREE(str, heap, DYNAMIC_TYPE_TMP_BUFFER);\n    return 0;\n}\n#endif /* WOLFSSL_CERT_EXT || OPENSSL_EXTRA */\n\n#endif /* !NO_CERTS */\n\n#if !defined(NO_DH) && (defined(WOLFSSL_QT) || defined(OPENSSL_ALL))\n/* Helper function for wolfSSL_i2d_DHparams */\nint StoreDHparams(byte* out, word32* outLen, mp_int* p, mp_int* g)\n{\n    word32 idx = 0;\n    int pSz;\n    int gSz;\n    unsigned int tmp;\n    word32 headerSz = 4; /* 2*ASN_TAG + 2*LEN(ENUM) */\n\n    /* If the leading bit on the INTEGER is a 1, add a leading zero */\n    int pLeadingZero = mp_leading_bit(p);\n    int gLeadingZero = mp_leading_bit(g);\n    int pLen = mp_unsigned_bin_size(p);\n    int gLen = mp_unsigned_bin_size(g);\n\n    WOLFSSL_ENTER(\"StoreDHparams\");\n    if (out == NULL) {\n        WOLFSSL_MSG(\"Null buffer error\");\n        return BUFFER_E;\n    }\n\n    tmp = pLeadingZero + gLeadingZero + pLen + gLen;\n    if (*outLen < (tmp + headerSz)) {\n        return BUFFER_E;\n    }\n\n    /* Set sequence */\n    idx = SetSequence(tmp + headerSz + 2, out);\n\n    /* Encode p */\n    pSz = SetASNIntMP(p, -1, &out[idx]);\n    if (pSz < 0) {\n        WOLFSSL_MSG(\"SetASNIntMP failed\");\n        return pSz;\n    }\n    idx += pSz;\n\n    /* Encode g */\n    gSz = SetASNIntMP(g, -1, &out[idx]);\n    if (gSz < 0) {\n        WOLFSSL_MSG(\"SetASNIntMP failed\");\n        return gSz;\n    }\n    idx += gSz;\n\n    *outLen = idx;\n\n    return 0;\n}\n#endif /* !NO_DH && (WOLFSSL_QT || OPENSSL_ALL) */\n\n#ifdef HAVE_ECC\n\n/* Der Encode r & s ints into out, outLen is (in/out) size */\nint StoreECC_DSA_Sig(byte* out, word32* outLen, mp_int* r, mp_int* s)\n{\n    word32 idx = 0;\n    int    rSz;                           /* encoding size */\n    int    sSz;\n    word32 headerSz = 4;   /* 2*ASN_TAG + 2*LEN(ENUM) */\n\n    /* If the leading bit on the INTEGER is a 1, add a leading zero */\n    int rLeadingZero = mp_leading_bit(r);\n    int sLeadingZero = mp_leading_bit(s);\n    int rLen = mp_unsigned_bin_size(r);   /* big int size */\n    int sLen = mp_unsigned_bin_size(s);\n\n    if (*outLen < (rLen + rLeadingZero + sLen + sLeadingZero +\n                   headerSz + 2))  /* SEQ_TAG + LEN(ENUM) */\n        return BUFFER_E;\n\n    idx = SetSequence(rLen + rLeadingZero + sLen+sLeadingZero + headerSz, out);\n\n    /* store r */\n    rSz = SetASNIntMP(r, *outLen - idx, &out[idx]);\n    if (rSz < 0)\n        return rSz;\n    idx += rSz;\n\n    /* store s */\n    sSz = SetASNIntMP(s, *outLen - idx, &out[idx]);\n    if (sSz < 0)\n        return sSz;\n    idx += sSz;\n\n    *outLen = idx;\n\n    return 0;\n}\n\n/* determine if leading bit is set */\nstatic int is_leading_bit_set(const byte* input, word32 sz)\n{\n    byte c = 0;\n    if (sz > 0)\n        c = input[0];\n    return (c & 0x80) != 0;\n}\nstatic int trim_leading_zeros(const byte** input, word32 sz)\n{\n    int i, leadingZeroCount = 0;\n    const byte* tmp = *input;\n    for (i=0; i<(int)sz; i++) {\n        if (tmp[i] != 0)\n            break;\n        leadingZeroCount++;\n    }\n    /* catch all zero case */\n    if (sz > 0 && leadingZeroCount == (int)sz) {\n        leadingZeroCount--;\n    }\n    *input += leadingZeroCount;\n    sz -= leadingZeroCount;\n    return sz;\n}\n\n/* Der Encode r & s ints into out, outLen is (in/out) size */\n/* All input/outputs are assumed to be big-endian */\nint StoreECC_DSA_Sig_Bin(byte* out, word32* outLen, const byte* r, word32 rLen, \n    const byte* s, word32 sLen)\n{\n    int ret;\n    word32 idx;\n    word32 headerSz = 4;   /* 2*ASN_TAG + 2*LEN(ENUM) */\n    int rAddLeadZero, sAddLeadZero;\n\n    if ((out == NULL) || (outLen == NULL) || (r == NULL) || (s == NULL))\n        return BAD_FUNC_ARG;\n\n    /* Trim leading zeros */\n    rLen = trim_leading_zeros(&r, rLen);\n    sLen = trim_leading_zeros(&s, sLen);\n    /* If the leading bit on the INTEGER is a 1, add a leading zero */\n    /* Add leading zero if MSB is set */\n    rAddLeadZero = is_leading_bit_set(r, rLen);\n    sAddLeadZero = is_leading_bit_set(s, sLen);\n\n    if (*outLen < (rLen + rAddLeadZero + sLen + sAddLeadZero +\n                   headerSz + 2))  /* SEQ_TAG + LEN(ENUM) */\n        return BUFFER_E;\n\n    idx = SetSequence(rLen+rAddLeadZero + sLen+sAddLeadZero + headerSz, out);\n\n    /* store r */\n    ret = SetASNInt(rLen, rAddLeadZero ? 0x80 : 0x00, &out[idx]);\n    if (ret < 0)\n        return ret;\n    idx += ret;\n    XMEMCPY(&out[idx], r, rLen);\n    idx += rLen;\n\n    /* store s */\n    ret = SetASNInt(sLen, sAddLeadZero ? 0x80 : 0x00, &out[idx]);\n    if (ret < 0)\n        return ret;\n    idx += ret;\n    XMEMCPY(&out[idx], s, sLen);\n    idx += sLen;\n\n    *outLen = idx;\n\n    return 0;\n}\n\n/* Der Decode ECC-DSA Signature with R/S as unsigned bin */\n/* All input/outputs are assumed to be big-endian */\nint DecodeECC_DSA_Sig_Bin(const byte* sig, word32 sigLen, byte* r, word32* rLen,\n    byte* s, word32* sLen)\n{\n    int    ret;\n    word32 idx = 0;\n    int    len = 0;\n\n    if (GetSequence(sig, &idx, &len, sigLen) < 0) {\n        return ASN_ECC_KEY_E;\n    }\n\n#ifndef NO_STRICT_ECDSA_LEN\n    /* enable strict length checking for signature */\n    if (sigLen != idx + (word32)len) {\n        return ASN_ECC_KEY_E;\n    }\n#else\n    /* allow extra signature bytes at end */\n    if ((word32)len > (sigLen - idx)) {\n        return ASN_ECC_KEY_E;\n    }\n#endif\n\n    ret = GetASNInt(sig, &idx, &len, sigLen);\n    if (ret != 0)\n        return ret;\n    if (rLen)\n        *rLen = len;\n    if (r)\n        XMEMCPY(r, (byte*)sig + idx, len);\n    idx += len;\n\n    ret = GetASNInt(sig, &idx, &len, sigLen);\n    if (ret != 0)\n        return ret;\n    if (sLen)\n        *sLen = len;\n    if (s)\n        XMEMCPY(s, (byte*)sig + idx, len);\n\n#ifndef NO_STRICT_ECDSA_LEN\n    /* sanity check that the index has been advanced all the way to the end of\n     * the buffer */\n    if (idx + len != sigLen) {\n        ret = ASN_ECC_KEY_E;\n    }\n#endif\n\n    return ret;\n}\n#endif\n\n#if defined(HAVE_ECC) || !defined(NO_DSA)\nint DecodeECC_DSA_Sig(const byte* sig, word32 sigLen, mp_int* r, mp_int* s)\n{\n    word32 idx = 0;\n    int    len = 0;\n\n    if (GetSequence(sig, &idx, &len, sigLen) < 0) {\n        return ASN_ECC_KEY_E;\n    }\n\n#ifndef NO_STRICT_ECDSA_LEN\n    /* enable strict length checking for signature */\n    if (sigLen != idx + (word32)len) {\n        return ASN_ECC_KEY_E;\n    }\n#else\n    /* allow extra signature bytes at end */\n    if ((word32)len > (sigLen - idx)) {\n        return ASN_ECC_KEY_E;\n    }\n#endif\n\n    if (GetInt(r, sig, &idx, sigLen) < 0) {\n        return ASN_ECC_KEY_E;\n    }\n\n    if (GetInt(s, sig, &idx, sigLen) < 0) {\n        mp_clear(r);\n        return ASN_ECC_KEY_E;\n    }\n\n#ifndef NO_STRICT_ECDSA_LEN\n    /* sanity check that the index has been advanced all the way to the end of\n     * the buffer */\n    if (idx != sigLen) {\n        mp_clear(r);\n        mp_clear(s);\n        return ASN_ECC_KEY_E;\n    }\n#endif\n\n    return 0;\n}\n#endif\n\n#ifdef HAVE_ECC\nint wc_EccPrivateKeyDecode(const byte* input, word32* inOutIdx, ecc_key* key,\n                        word32 inSz)\n{\n    word32 oidSum;\n    int    version, length;\n    int    privSz, pubSz = 0;\n    byte   b;\n    int    ret = 0;\n    int    curve_id = ECC_CURVE_DEF;\n#ifdef WOLFSSL_SMALL_STACK\n    byte* priv;\n    byte* pub = NULL;\n#else\n    byte priv[ECC_MAXSIZE+1];\n    byte pub[2*(ECC_MAXSIZE+1)]; /* public key has two parts plus header */\n#endif\n    byte* pubData = NULL;\n\n    if (input == NULL || inOutIdx == NULL || key == NULL || inSz == 0)\n        return BAD_FUNC_ARG;\n\n    if (GetSequence(input, inOutIdx, &length, inSz) < 0)\n        return ASN_PARSE_E;\n\n    if (GetMyVersion(input, inOutIdx, &version, inSz) < 0)\n        return ASN_PARSE_E;\n\n    if (*inOutIdx >= inSz)\n        return ASN_PARSE_E;\n\n    b = input[*inOutIdx];\n    *inOutIdx += 1;\n\n    /* priv type */\n    if (b != 4 && b != 6 && b != 7)\n        return ASN_PARSE_E;\n\n    if (GetLength(input, inOutIdx, &length, inSz) < 0)\n        return ASN_PARSE_E;\n    privSz = length;\n\n    if (privSz > ECC_MAXSIZE)\n        return BUFFER_E;\n\n#ifdef WOLFSSL_SMALL_STACK\n    priv = (byte*)XMALLOC(privSz, key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n    if (priv == NULL)\n        return MEMORY_E;\n#endif\n\n    /* priv key */\n    XMEMCPY(priv, &input[*inOutIdx], privSz);\n    *inOutIdx += length;\n\n    if ((*inOutIdx + 1) < inSz) {\n        /* prefix 0, may have */\n        b = input[*inOutIdx];\n        if (b == ECC_PREFIX_0) {\n            *inOutIdx += 1;\n\n            if (GetLength(input, inOutIdx, &length, inSz) <= 0)\n                ret = ASN_PARSE_E;\n            else {\n                ret = GetObjectId(input, inOutIdx, &oidSum, oidIgnoreType,\n                                  inSz);\n                if (ret == 0) {\n                    if ((ret = CheckCurve(oidSum)) < 0)\n                        ret = ECC_CURVE_OID_E;\n                    else {\n                        curve_id = ret;\n                        ret = 0;\n                    }\n                }\n            }\n        }\n    }\n\n    if (ret == 0 && (*inOutIdx + 1) < inSz) {\n        /* prefix 1 */\n        b = input[*inOutIdx];\n        *inOutIdx += 1;\n\n        if (b != ECC_PREFIX_1) {\n            ret = ASN_ECC_KEY_E;\n        }\n        else if (GetLength(input, inOutIdx, &length, inSz) <= 0) {\n            ret = ASN_PARSE_E;\n        }\n        else {\n            /* key header */\n            ret = CheckBitString(input, inOutIdx, &length, inSz, 0, NULL);\n            if (ret == 0) {\n                /* pub key */\n                pubSz = length;\n                if (pubSz > 2*(ECC_MAXSIZE+1))\n                    ret = BUFFER_E;\n                else {\n            #ifdef WOLFSSL_SMALL_STACK\n                    pub = (byte*)XMALLOC(pubSz, key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n                    if (pub == NULL)\n                        ret = MEMORY_E;\n                    else\n            #endif\n                    {\n                        XMEMCPY(pub, &input[*inOutIdx], pubSz);\n                        *inOutIdx += length;\n                        pubData = pub;\n                    }\n                }\n            }\n        }\n    }\n\n    if (ret == 0) {\n        ret = wc_ecc_import_private_key_ex(priv, privSz, pubData, pubSz, key,\n                                                                      curve_id);\n    }\n\n#ifdef WOLFSSL_SMALL_STACK\n    XFREE(priv, key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n    XFREE(pub,  key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n#endif\n\n    return ret;\n}\n\n\n#ifdef WOLFSSL_CUSTOM_CURVES\nstatic void ByteToHex(byte n, char* str)\n{\n    const char hexChar[] = { '0', '1', '2', '3', '4', '5', '6', '7',\n                                    '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };\n\n    str[0] = hexChar[n >> 4];\n    str[1] = hexChar[n & 0xf];\n}\n\n/* returns 0 on success */\nstatic int ASNToHexString(const byte* input, word32* inOutIdx, char** out,\n                          word32 inSz, void* heap, int heapType)\n{\n    int len;\n    int i;\n    char* str;\n    word32 localIdx;\n    byte   tag;\n\n    if (*inOutIdx >= inSz) {\n        return BUFFER_E;\n    }\n\n    localIdx = *inOutIdx;\n    if (GetASNTag(input, &localIdx, &tag, inSz) == 0 && tag == ASN_INTEGER) {\n        if (GetASNInt(input, inOutIdx, &len, inSz) < 0)\n            return ASN_PARSE_E;\n    }\n    else {\n        if (GetOctetString(input, inOutIdx, &len, inSz) < 0)\n            return ASN_PARSE_E;\n    }\n\n    str = (char*)XMALLOC(len * 2 + 1, heap, heapType);\n    if (str == NULL) {\n        return MEMORY_E;\n    }\n\n    for (i=0; i<len; i++)\n        ByteToHex(input[*inOutIdx + i], str + i*2);\n    str[len*2] = '\\0';\n\n    *inOutIdx += len;\n    *out = str;\n\n    (void)heap;\n    (void)heapType;\n\n    return 0;\n}\n#endif /* WOLFSSL_CUSTOM_CURVES */\n\n#ifdef WOLFSSL_CUSTOM_CURVES\nstatic int EccKeyParamCopy(char** dst, char* src)\n{\n    int ret = 0;\n#ifdef WOLFSSL_ECC_CURVE_STATIC\n    word32 length;\n#endif\n\n    if (dst == NULL || src == NULL)\n        return BAD_FUNC_ARG;\n\n#ifndef WOLFSSL_ECC_CURVE_STATIC\n    *dst = src;\n#else\n    length = (int)XSTRLEN(src) + 1;\n    if (length > MAX_ECC_STRING) {\n        WOLFSSL_MSG(\"ECC Param too large for buffer\");\n        ret = BUFFER_E;\n    }\n    else {\n        XSTRNCPY(*dst, src, MAX_ECC_STRING);\n    }\n    XFREE(src, key->heap, DYNAMIC_TYPE_ECC_BUFFER);\n#endif\n\n    return ret;\n}\n#endif /* WOLFSSL_CUSTOM_CURVES */\n\nint wc_EccPublicKeyDecode(const byte* input, word32* inOutIdx,\n                          ecc_key* key, word32 inSz)\n{\n    int    ret;\n    int    version, length;\n    int    curve_id = ECC_CURVE_DEF;\n    word32 oidSum, localIdx;\n    byte   tag, isPrivFormat = 0;\n\n    if (input == NULL || inOutIdx == NULL || key == NULL || inSz == 0)\n        return BAD_FUNC_ARG;\n\n    if (GetSequence(input, inOutIdx, &length, inSz) < 0)\n        return ASN_PARSE_E;\n\n    /* Check if ECC private key is being used and skip private portion */\n    if (GetMyVersion(input, inOutIdx, &version, inSz) >= 0) {\n        isPrivFormat = 1;\n\n        /* Type private key */\n        if (*inOutIdx >= inSz)\n            return ASN_PARSE_E;\n        tag = input[*inOutIdx];\n        *inOutIdx += 1;\n        if (tag != 4 && tag != 6 && tag != 7)\n            return ASN_PARSE_E;\n\n        /* Skip Private Key */\n        if (GetLength(input, inOutIdx, &length, inSz) < 0)\n            return ASN_PARSE_E;\n        if (length > ECC_MAXSIZE)\n            return BUFFER_E;\n        *inOutIdx += length;\n\n        /* Private Curve Header */\n        if (*inOutIdx >= inSz)\n            return ASN_PARSE_E;\n        tag = input[*inOutIdx];\n        *inOutIdx += 1;\n        if (tag != ECC_PREFIX_0)\n            return ASN_ECC_KEY_E;\n        if (GetLength(input, inOutIdx, &length, inSz) <= 0)\n            return ASN_PARSE_E;\n    }\n    /* Standard ECC public key */\n    else {\n        if (GetSequence(input, inOutIdx, &length, inSz) < 0)\n            return ASN_PARSE_E;\n\n        ret = SkipObjectId(input, inOutIdx, inSz);\n        if (ret != 0)\n            return ret;\n    }\n\n    if (*inOutIdx >= inSz) {\n        return BUFFER_E;\n    }\n\n    localIdx = *inOutIdx;\n    if (GetASNTag(input, &localIdx, &tag, inSz) == 0 &&\n            tag == (ASN_SEQUENCE | ASN_CONSTRUCTED)) {\n#ifdef WOLFSSL_CUSTOM_CURVES\n        ecc_set_type* curve;\n        int len;\n        char* point = NULL;\n\n        ret = 0;\n\n        curve = (ecc_set_type*)XMALLOC(sizeof(*curve), key->heap,\n                                                       DYNAMIC_TYPE_ECC_BUFFER);\n        if (curve == NULL)\n            ret = MEMORY_E;\n\n        if (ret == 0) {\n            static const char customName[] = \"Custom\";\n            XMEMSET(curve, 0, sizeof(*curve));\n        #ifndef WOLFSSL_ECC_CURVE_STATIC\n            curve->name = customName;\n        #else\n            XMEMCPY((void*)curve->name, customName, sizeof(customName));\n        #endif\n            curve->id = ECC_CURVE_CUSTOM;\n\n            if (GetSequence(input, inOutIdx, &length, inSz) < 0)\n                ret = ASN_PARSE_E;\n        }\n\n        if (ret == 0) {\n            GetInteger7Bit(input, inOutIdx, inSz);\n            if (GetSequence(input, inOutIdx, &length, inSz) < 0)\n                ret = ASN_PARSE_E;\n        }\n        if (ret == 0) {\n            char* p = NULL;\n            SkipObjectId(input, inOutIdx, inSz);\n            ret = ASNToHexString(input, inOutIdx, &p, inSz,\n                                            key->heap, DYNAMIC_TYPE_ECC_BUFFER);\n            if (ret == 0)\n                ret = EccKeyParamCopy((char**)&curve->prime, p);\n        }\n        if (ret == 0) {\n            curve->size = (int)XSTRLEN(curve->prime) / 2;\n\n            if (GetSequence(input, inOutIdx, &length, inSz) < 0)\n                ret = ASN_PARSE_E;\n        }\n        if (ret == 0) {\n            char* af = NULL;\n            ret = ASNToHexString(input, inOutIdx, &af, inSz,\n                                            key->heap, DYNAMIC_TYPE_ECC_BUFFER);\n            if (ret == 0)\n                ret = EccKeyParamCopy((char**)&curve->Af, af);\n        }\n        if (ret == 0) {\n            char* bf = NULL;\n            ret = ASNToHexString(input, inOutIdx, &bf, inSz,\n                                            key->heap, DYNAMIC_TYPE_ECC_BUFFER);\n            if (ret == 0)\n                ret = EccKeyParamCopy((char**)&curve->Bf, bf);\n        }\n        if (ret == 0) {\n            localIdx = *inOutIdx;\n            if (*inOutIdx < inSz && GetASNTag(input, &localIdx, &tag, inSz)\n                    == 0 && tag == ASN_BIT_STRING) {\n                len = 0;\n                ret = GetASNHeader(input, ASN_BIT_STRING, inOutIdx, &len, inSz);\n                *inOutIdx += len;\n            }\n        }\n        if (ret == 0) {\n            ret = ASNToHexString(input, inOutIdx, (char**)&point, inSz,\n                                            key->heap, DYNAMIC_TYPE_ECC_BUFFER);\n\n            /* sanity check that point buffer is not smaller than the expected\n             * size to hold ( 0 4 || Gx || Gy )\n             * where Gx and Gy are each the size of curve->size * 2 */\n            if (ret == 0 && (int)XSTRLEN(point) < (curve->size * 4) + 2) {\n                XFREE(point, key->heap, DYNAMIC_TYPE_ECC_BUFFER);\n                ret = BUFFER_E;\n            }\n        }\n        if (ret == 0) {\n        #ifndef WOLFSSL_ECC_CURVE_STATIC\n            curve->Gx = (const char*)XMALLOC(curve->size * 2 + 2, key->heap,\n                                                       DYNAMIC_TYPE_ECC_BUFFER);\n            curve->Gy = (const char*)XMALLOC(curve->size * 2 + 2, key->heap,\n                                                       DYNAMIC_TYPE_ECC_BUFFER);\n            if (curve->Gx == NULL || curve->Gy == NULL) {\n                XFREE(point, key->heap, DYNAMIC_TYPE_ECC_BUFFER);\n                ret = MEMORY_E;\n            }\n        #else\n            if (curve->size * 2 + 2 > MAX_ECC_STRING) {\n                WOLFSSL_MSG(\"curve size is too large to fit in buffer\");\n                ret = BUFFER_E;\n            }\n        #endif\n        }\n        if (ret == 0) {\n            char* o = NULL;\n\n            XMEMCPY((char*)curve->Gx, point + 2, curve->size * 2);\n            XMEMCPY((char*)curve->Gy, point + curve->size * 2 + 2,\n                                                               curve->size * 2);\n            ((char*)curve->Gx)[curve->size * 2] = '\\0';\n            ((char*)curve->Gy)[curve->size * 2] = '\\0';\n            XFREE(point, key->heap, DYNAMIC_TYPE_ECC_BUFFER);\n            ret = ASNToHexString(input, inOutIdx, &o, inSz,\n                                            key->heap, DYNAMIC_TYPE_ECC_BUFFER);\n            if (ret == 0)\n                ret = EccKeyParamCopy((char**)&curve->order, o);\n        }\n        if (ret == 0) {\n            curve->cofactor = GetInteger7Bit(input, inOutIdx, inSz);\n\n        #ifndef WOLFSSL_ECC_CURVE_STATIC\n            curve->oid = NULL;\n        #else\n            XMEMSET((void*)curve->oid, 0, sizeof(curve->oid));\n        #endif\n            curve->oidSz = 0;\n            curve->oidSum = 0;\n\n            if (wc_ecc_set_custom_curve(key, curve) < 0) {\n                ret = ASN_PARSE_E;\n            }\n        #ifdef WOLFSSL_CUSTOM_CURVES\n            key->deallocSet = 1;\n        #endif\n            curve = NULL;\n        }\n        if (curve != NULL)\n            wc_ecc_free_curve(curve, key->heap);\n\n        if (ret < 0)\n            return ret;\n#else\n        return ASN_PARSE_E;\n#endif /* WOLFSSL_CUSTOM_CURVES */\n    }\n    else {\n        /* ecc params information */\n        ret = GetObjectId(input, inOutIdx, &oidSum, oidIgnoreType, inSz);\n        if (ret != 0)\n            return ret;\n\n        /* get curve id */\n        if ((ret = CheckCurve(oidSum)) < 0)\n            return ECC_CURVE_OID_E;\n        else {\n            curve_id = ret;\n        }\n    }\n\n    if (isPrivFormat) {\n        /* Public Curve Header - skip */\n        if (*inOutIdx >= inSz)\n            return ASN_PARSE_E;\n        tag = input[*inOutIdx];\n        *inOutIdx += 1;\n        if (tag != ECC_PREFIX_1)\n            return ASN_ECC_KEY_E;\n        if (GetLength(input, inOutIdx, &length, inSz) <= 0)\n            return ASN_PARSE_E;\n    }\n\n    /* key header */\n    ret = CheckBitString(input, inOutIdx, &length, inSz, 1, NULL);\n    if (ret != 0)\n        return ret;\n\n    /* This is the raw point data compressed or uncompressed. */\n    if (wc_ecc_import_x963_ex(input + *inOutIdx, length, key,\n                                                            curve_id) != 0) {\n        return ASN_ECC_KEY_E;\n    }\n\n    *inOutIdx += length;\n\n    return 0;\n}\n\n#if defined(HAVE_ECC_KEY_EXPORT) && !defined(NO_ASN_CRYPT)\n/* build DER formatted ECC key, include optional public key if requested,\n * return length on success, negative on error */\nstatic int wc_BuildEccKeyDer(ecc_key* key, byte* output, word32 *inLen,\n                             int pubIn)\n{\n    byte   curve[MAX_ALGO_SZ+2];\n    byte   ver[MAX_VERSION_SZ];\n    byte   seq[MAX_SEQ_SZ];\n    int    ret, totalSz, curveSz, verSz;\n    int    privHdrSz  = ASN_ECC_HEADER_SZ;\n    int    pubHdrSz   = ASN_ECC_CONTEXT_SZ + ASN_ECC_HEADER_SZ;\n#ifdef WOLFSSL_NO_MALLOC\n    byte   prv[MAX_ECC_BYTES + ASN_ECC_HEADER_SZ + MAX_SEQ_SZ];\n    byte   pub[(MAX_ECC_BYTES * 2) + 1 + ASN_ECC_CONTEXT_SZ + \n                              ASN_ECC_HEADER_SZ + MAX_SEQ_SZ];\n#else\n    byte   *prv = NULL, *pub = NULL;\n#endif\n\n    word32 idx = 0, prvidx = 0, pubidx = 0, curveidx = 0;\n    word32 seqSz, privSz, pubSz = ECC_BUFSIZE;\n\n    if (key == NULL || (output == NULL && inLen == NULL))\n        return BAD_FUNC_ARG;\n\n    /* curve */\n    curve[curveidx++] = ECC_PREFIX_0;\n    curveidx++ /* to put the size after computation */;\n    curveSz = SetCurve(key, curve+curveidx);\n    if (curveSz < 0)\n        return curveSz;\n    /* set computed size */\n    curve[1] = (byte)curveSz;\n    curveidx += curveSz;\n\n    /* private */\n    privSz = key->dp->size;\n\n#ifdef WOLFSSL_QNX_CAAM\n    /* check if is a black key, and add MAC size if so */\n    if (key->blackKey > 0) {\n        privSz = privSz + WC_CAAM_MAC_SZ;\n    }\n#endif\n\n#ifndef WOLFSSL_NO_MALLOC\n    prv = (byte*)XMALLOC(privSz + privHdrSz + MAX_SEQ_SZ,\n                         key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n    if (prv == NULL) {\n        return MEMORY_E;\n    }\n#else\n    if (sizeof(prv) < privSz + privHdrSz + MAX_SEQ_SZ) {\n        return BUFFER_E;\n    }\n#endif\n    if (privSz < ASN_LONG_LENGTH) {\n        prvidx += SetOctetString8Bit(privSz, &prv[prvidx]);\n    }\n    else {\n        prvidx += SetOctetString(privSz, &prv[prvidx]);\n    }\n    ret = wc_ecc_export_private_only(key, prv + prvidx, &privSz);\n    if (ret < 0) {\n    #ifndef WOLFSSL_NO_MALLOC\n        XFREE(prv, key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n    #endif\n        return ret;\n    }\n    prvidx += privSz;\n\n    /* pubIn */\n    if (pubIn) {\n        ret = wc_ecc_export_x963(key, NULL, &pubSz);\n        if (ret != LENGTH_ONLY_E) {\n        #ifndef WOLFSSL_NO_MALLOC\n            XFREE(prv, key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n        #endif\n            return ret;\n        }\n\n    #ifndef WOLFSSL_NO_MALLOC\n        pub = (byte*)XMALLOC(pubSz + pubHdrSz + MAX_SEQ_SZ,\n                             key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n        if (pub == NULL) {\n            XFREE(prv, key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n            return MEMORY_E;\n        }\n    #else\n        if (sizeof(pub) < pubSz + pubHdrSz + MAX_SEQ_SZ) {\n            return BUFFER_E;\n        }\n    #endif\n\n        pub[pubidx++] = ECC_PREFIX_1;\n        if (pubSz > 128) /* leading zero + extra size byte */\n            pubidx += SetLength(pubSz + ASN_ECC_CONTEXT_SZ + 2, pub+pubidx);\n        else /* leading zero */\n            pubidx += SetLength(pubSz + ASN_ECC_CONTEXT_SZ + 1, pub+pubidx);\n\n        /* SetBitString adds leading zero */\n        pubidx += SetBitString(pubSz, 0, pub + pubidx);\n        ret = wc_ecc_export_x963(key, pub + pubidx, &pubSz);\n        if (ret != 0) {\n        #ifndef WOLFSSL_NO_MALLOC\n            XFREE(prv, key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n            XFREE(pub, key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n        #endif\n            return ret;\n        }\n        pubidx += pubSz;\n    }\n\n    /* make headers */\n    verSz = SetMyVersion(1, ver, FALSE);\n    seqSz = SetSequence(verSz + prvidx + pubidx + curveidx, seq);\n\n    totalSz = prvidx + pubidx + curveidx + verSz + seqSz;\n    if (output == NULL) {\n        *inLen = totalSz;\n    #ifndef WOLFSSL_NO_MALLOC\n        XFREE(prv, key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n        if (pub) {\n            XFREE(pub, key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n        }\n    #endif\n        return LENGTH_ONLY_E;\n    }\n    if (inLen != NULL && totalSz > (int)*inLen) {\n        #ifndef WOLFSSL_NO_MALLOC\n        XFREE(prv, key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n        if (pubIn) {\n            XFREE(pub, key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n        }\n        #endif\n        return BAD_FUNC_ARG;\n    }\n\n    /* write out */\n    /* seq */\n    XMEMCPY(output + idx, seq, seqSz);\n    idx = seqSz;\n\n    /* ver */\n    XMEMCPY(output + idx, ver, verSz);\n    idx += verSz;\n\n    /* private */\n    XMEMCPY(output + idx, prv, prvidx);\n    idx += prvidx;\n#ifndef WOLFSSL_NO_MALLOC\n    XFREE(prv, key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n#endif\n\n    /* curve */\n    XMEMCPY(output + idx, curve, curveidx);\n    idx += curveidx;\n\n    /* pubIn */\n    if (pubIn) {\n        XMEMCPY(output + idx, pub, pubidx);\n        /* idx += pubidx;  not used after write, if more data remove comment */\n    #ifndef WOLFSSL_NO_MALLOC\n        XFREE(pub, key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n    #endif\n    }\n\n    return totalSz;\n}\n\n/* Write a Private ecc key, including public to DER format,\n * length on success else < 0 */\nint wc_EccKeyToDer(ecc_key* key, byte* output, word32 inLen)\n{\n    return wc_BuildEccKeyDer(key, output, &inLen, 1);\n}\n\n/* Write only private ecc key to DER format,\n * length on success else < 0 */\nint wc_EccKeyDerSize(ecc_key* key, int pub)\n{\n    word32 sz = 0;\n    int ret;\n\n    ret = wc_BuildEccKeyDer(key, NULL, &sz, pub);\n\n    if (ret != LENGTH_ONLY_E) {\n        return ret;\n    }\n    return sz;\n }\n\n/* Write only private ecc key to DER format,\n * length on success else < 0 */\nint wc_EccPrivateKeyToDer(ecc_key* key, byte* output, word32 inLen)\n{\n    return wc_BuildEccKeyDer(key, output, &inLen, 0);\n}\n\n\n\n#ifdef HAVE_PKCS8\n/* Write only private ecc key or both private and public parts to unencrypted\n * PKCS#8 format.\n *\n * If output is NULL, places required PKCS#8 buffer size in outLen and\n * returns LENGTH_ONLY_E.\n *\n * return length on success else < 0 */\nstatic int eccToPKCS8(ecc_key* key, byte* output, word32* outLen,\n        int includePublic)\n{\n    int ret, tmpDerSz;\n    int algoID = 0;\n    word32 oidSz = 0;\n    word32 pkcs8Sz = 0;\n    const byte* curveOID = NULL;\n#ifdef WOLFSSL_NO_MALLOC\n    byte  tmpDer[ECC_BUFSIZE];\n#else\n    byte* tmpDer = NULL;\n#endif\n    word32 sz = ECC_BUFSIZE;\n\n    if (key == NULL || key->dp == NULL || outLen == NULL)\n        return BAD_FUNC_ARG;\n\n    /* set algoID, get curve OID */\n    algoID = ECDSAk;\n    ret = wc_ecc_get_oid(key->dp->oidSum, &curveOID, &oidSz);\n    if (ret < 0)\n        return ret;\n\n#ifndef WOLFSSL_NO_MALLOC\n    /* temp buffer for plain DER key */\n    tmpDer = (byte*)XMALLOC(ECC_BUFSIZE, key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n    if (tmpDer == NULL)\n        return MEMORY_E;\n#endif\n    XMEMSET(tmpDer, 0, ECC_BUFSIZE);\n\n    tmpDerSz = wc_BuildEccKeyDer(key, tmpDer, &sz, includePublic);\n    if (tmpDerSz < 0) {\n    #ifndef WOLFSSL_NO_MALLOC\n        XFREE(tmpDer, key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n    #endif\n        return tmpDerSz;\n    }\n\n    /* get pkcs8 expected output size */\n    ret = wc_CreatePKCS8Key(NULL, &pkcs8Sz, tmpDer, tmpDerSz, algoID,\n                            curveOID, oidSz);\n    if (ret != LENGTH_ONLY_E) {\n    #ifndef WOLFSSL_NO_MALLOC\n        XFREE(tmpDer, key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n    #endif\n        return ret;\n    }\n\n    if (output == NULL) {\n    #ifndef WOLFSSL_NO_MALLOC\n        XFREE(tmpDer, key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n    #endif\n        *outLen = pkcs8Sz;\n        return LENGTH_ONLY_E;\n\n    }\n    else if (*outLen < pkcs8Sz) {\n    #ifndef WOLFSSL_NO_MALLOC\n        XFREE(tmpDer, key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n    #endif\n        WOLFSSL_MSG(\"Input buffer too small for ECC PKCS#8 key\");\n        return BUFFER_E;\n    }\n\n    ret = wc_CreatePKCS8Key(output, &pkcs8Sz, tmpDer, tmpDerSz,\n                            algoID, curveOID, oidSz);\n    if (ret < 0) {\n    #ifndef WOLFSSL_NO_MALLOC\n        XFREE(tmpDer, key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n    #endif\n        return ret;\n    }\n\n#ifndef WOLFSSL_NO_MALLOC\n    XFREE(tmpDer, key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n#endif\n\n    *outLen = ret;\n    return ret;\n}\n\n/* Write only private ecc key to unencrypted PKCS#8 format.\n *\n * return length on success else < 0 */\nint wc_EccPrivateKeyToPKCS8(ecc_key* key, byte* output, word32* outLen)\n{\n    return eccToPKCS8(key, output, outLen, 0);\n}\n\n/* Write both private and public ecc keys to unencrypted PKCS#8 format.\n *\n * return length on success else < 0 */\nint wc_EccKeyToPKCS8(ecc_key* key, byte* output,\n                     word32* outLen)\n{\n    return eccToPKCS8(key, output, outLen, 1);\n}\n#endif /* HAVE_PKCS8 */\n#endif /* HAVE_ECC_KEY_EXPORT && !NO_ASN_CRYPT */\n#endif /* HAVE_ECC */\n\n\n#ifdef HAVE_ED25519\n\nint wc_Ed25519PrivateKeyDecode(const byte* input, word32* inOutIdx,\n                               ed25519_key* key, word32 inSz)\n{\n    word32      oid;\n    int         ret, version, length, endKeyIdx, privSz, pubSz;\n    const byte* priv;\n    const byte* pub;\n\n    if (input == NULL || inOutIdx == NULL || key == NULL || inSz == 0)\n        return BAD_FUNC_ARG;\n\n    if (GetSequence(input, inOutIdx, &length, inSz) >= 0) {\n        endKeyIdx = *inOutIdx + length;\n\n        if (GetMyVersion(input, inOutIdx, &version, inSz) < 0)\n            return ASN_PARSE_E;\n        if (version != 0) {\n            WOLFSSL_MSG(\"Unrecognized version of ED25519 private key\");\n            return ASN_PARSE_E;\n        }\n\n        if (GetAlgoId(input, inOutIdx, &oid, oidKeyType, inSz) < 0)\n            return ASN_PARSE_E;\n        if (oid != ED25519k)\n            return ASN_PARSE_E;\n\n        if (GetOctetString(input, inOutIdx, &length, inSz) < 0)\n            return ASN_PARSE_E;\n\n        if (GetOctetString(input, inOutIdx, &privSz, inSz) < 0)\n            return ASN_PARSE_E;\n\n        priv = input + *inOutIdx;\n        *inOutIdx += privSz;\n    }\n    else {\n        if (GetOctetString(input, inOutIdx, &privSz, inSz) < 0)\n            return ASN_PARSE_E;\n\n        if (privSz != 32)\n            return ASN_PARSE_E;\n\n        priv = input + *inOutIdx;\n        *inOutIdx += privSz;\n        endKeyIdx = *inOutIdx;\n    }\n\n    if (endKeyIdx == (int)*inOutIdx) {\n        ret = wc_ed25519_import_private_only(priv, privSz, key);\n    }\n    else {\n        if (GetASNHeader(input, ASN_CONTEXT_SPECIFIC | ASN_CONSTRUCTED | 1,\n                         inOutIdx, &length, inSz) < 0) {\n            return ASN_PARSE_E;\n        }\n        if (GetOctetString(input, inOutIdx, &pubSz, inSz) < 0)\n            return ASN_PARSE_E;\n        pub = input + *inOutIdx;\n        *inOutIdx += pubSz;\n\n        ret = wc_ed25519_import_private_key(priv, privSz, pub, pubSz, key);\n    }\n    if (ret == 0 && endKeyIdx != (int)*inOutIdx)\n        return ASN_PARSE_E;\n\n    return ret;\n}\n\n\nint wc_Ed25519PublicKeyDecode(const byte* input, word32* inOutIdx,\n                              ed25519_key* key, word32 inSz)\n{\n    int    length;\n    int    ret;\n\n    if (input == NULL || inOutIdx == NULL || key == NULL || inSz == 0)\n        return BAD_FUNC_ARG;\n\n    if (GetSequence(input, inOutIdx, &length, inSz) < 0)\n        return ASN_PARSE_E;\n\n    if (GetSequence(input, inOutIdx, &length, inSz) < 0)\n        return ASN_PARSE_E;\n\n    ret = SkipObjectId(input, inOutIdx, inSz);\n    if (ret != 0)\n        return ret;\n\n    /* key header */\n    ret = CheckBitString(input, inOutIdx, NULL, inSz, 1, NULL);\n    if (ret != 0)\n        return ret;\n\n    /* This is the raw point data compressed or uncompressed. */\n    if (wc_ed25519_import_public(input + *inOutIdx, inSz - *inOutIdx, key) != 0)\n        return ASN_ECC_KEY_E;\n\n    return 0;\n}\n\n\n#ifdef WOLFSSL_KEY_GEN\n\n/* build DER formatted ED25519 key,\n * return length on success, negative on error */\nstatic int wc_BuildEd25519KeyDer(ed25519_key* key, byte* output, word32 inLen,\n                                 int pubOut)\n{\n    byte   algoArray[MAX_ALGO_SZ];\n    byte   ver[MAX_VERSION_SZ];\n    byte   seq[MAX_SEQ_SZ];\n    int    ret;\n    word32 idx = 0, seqSz, verSz, algoSz, privSz, pubSz = 0;\n\n    if (key == NULL || output == NULL || inLen == 0)\n        return BAD_FUNC_ARG;\n\n    if (pubOut)\n        pubSz = 2 + 2 + ED25519_PUB_KEY_SIZE;\n    privSz = 2 + 2 + ED25519_KEY_SIZE;\n    algoSz = SetAlgoID(ED25519k, algoArray, oidKeyType, 0);\n    verSz  = SetMyVersion(0, ver, FALSE);\n    seqSz  = SetSequence(verSz + algoSz + privSz + pubSz, seq);\n\n    if (seqSz + verSz + algoSz + privSz + pubSz > inLen)\n        return BAD_FUNC_ARG;\n\n    /* write out */\n    /* seq */\n    XMEMCPY(output + idx, seq, seqSz);\n    idx = seqSz;\n    /* ver */\n    XMEMCPY(output + idx, ver, verSz);\n    idx += verSz;\n    /* algo */\n    XMEMCPY(output + idx, algoArray, algoSz);\n    idx += algoSz;\n    /* privKey */\n    idx += SetOctetString(2 + ED25519_KEY_SIZE, output + idx);\n    idx += SetOctetString(ED25519_KEY_SIZE, output + idx);\n    ret = wc_ed25519_export_private_only(key, output + idx, &privSz);\n    if (ret != 0)\n        return ret;\n    idx += privSz;\n    /* pubKey */\n    if (pubOut) {\n        idx += SetExplicit(1, 2 + ED25519_PUB_KEY_SIZE, output + idx);\n        idx += SetOctetString(ED25519_KEY_SIZE, output + idx);\n        ret = wc_ed25519_export_public(key, output + idx, &pubSz);\n        if (ret != 0)\n            return ret;\n        idx += pubSz;\n    }\n\n    return idx;\n}\n\n/* Write a Private ecc key, including public to DER format,\n * length on success else < 0 */\nint wc_Ed25519KeyToDer(ed25519_key* key, byte* output, word32 inLen)\n{\n    return wc_BuildEd25519KeyDer(key, output, inLen, 1);\n}\n\n\n\n/* Write only private ecc key to DER format,\n * length on success else < 0 */\nint wc_Ed25519PrivateKeyToDer(ed25519_key* key, byte* output, word32 inLen)\n{\n    return wc_BuildEd25519KeyDer(key, output, inLen, 0);\n}\n\n#endif /* WOLFSSL_KEY_GEN */\n\n#endif /* HAVE_ED25519 */\n\n#ifdef HAVE_ED448\n\nint wc_Ed448PrivateKeyDecode(const byte* input, word32* inOutIdx,\n                             ed448_key* key, word32 inSz)\n{\n    word32      oid;\n    int         ret, version, length, endKeyIdx, privSz, pubSz;\n    const byte* priv;\n    const byte* pub;\n\n    if (input == NULL || inOutIdx == NULL || key == NULL || inSz == 0)\n        return BAD_FUNC_ARG;\n\n    if (GetSequence(input, inOutIdx, &length, inSz) >= 0) {\n        endKeyIdx = *inOutIdx + length;\n\n        if (GetMyVersion(input, inOutIdx, &version, inSz) < 0)\n            return ASN_PARSE_E;\n        if (version != 0) {\n            WOLFSSL_MSG(\"Unrecognized version of ED448 private key\");\n            return ASN_PARSE_E;\n        }\n\n        if (GetAlgoId(input, inOutIdx, &oid, oidKeyType, inSz) < 0)\n            return ASN_PARSE_E;\n        if (oid != ED448k)\n            return ASN_PARSE_E;\n\n        if (GetOctetString(input, inOutIdx, &length, inSz) < 0)\n            return ASN_PARSE_E;\n\n        if (GetOctetString(input, inOutIdx, &privSz, inSz) < 0)\n            return ASN_PARSE_E;\n\n        priv = input + *inOutIdx;\n        *inOutIdx += privSz;\n    }\n    else {\n        if (GetOctetString(input, inOutIdx, &privSz, inSz) < 0)\n            return ASN_PARSE_E;\n\n        if (privSz != 57)\n            return ASN_PARSE_E;\n\n        priv = input + *inOutIdx;\n        *inOutIdx += privSz;\n        endKeyIdx = *inOutIdx;\n    }\n\n    if (endKeyIdx == (int)*inOutIdx) {\n        ret = wc_ed448_import_private_only(priv, privSz, key);\n    }\n    else {\n        if (GetASNHeader(input, ASN_CONTEXT_SPECIFIC | ASN_CONSTRUCTED | 1,\n                         inOutIdx, &length, inSz) < 0) {\n            return ASN_PARSE_E;\n        }\n        if (GetOctetString(input, inOutIdx, &pubSz, inSz) < 0)\n            return ASN_PARSE_E;\n        pub = input + *inOutIdx;\n        *inOutIdx += pubSz;\n\n        ret = wc_ed448_import_private_key(priv, privSz, pub, pubSz, key);\n    }\n    if (ret == 0 && endKeyIdx != (int)*inOutIdx)\n        return ASN_PARSE_E;\n\n    return ret;\n}\n\n\nint wc_Ed448PublicKeyDecode(const byte* input, word32* inOutIdx,\n                            ed448_key* key, word32 inSz)\n{\n    int    length;\n    int    ret;\n\n    if (input == NULL || inOutIdx == NULL || key == NULL || inSz == 0)\n        return BAD_FUNC_ARG;\n\n    if (GetSequence(input, inOutIdx, &length, inSz) < 0)\n        return ASN_PARSE_E;\n\n    if (GetSequence(input, inOutIdx, &length, inSz) < 0)\n        return ASN_PARSE_E;\n\n    ret = SkipObjectId(input, inOutIdx, inSz);\n    if (ret != 0)\n        return ret;\n\n    /* key header */\n    ret = CheckBitString(input, inOutIdx, NULL, inSz, 1, NULL);\n    if (ret != 0)\n        return ret;\n\n    /* This is the raw point data compressed or uncompressed. */\n    if (wc_ed448_import_public(input + *inOutIdx, inSz - *inOutIdx, key) != 0)\n        return ASN_ECC_KEY_E;\n\n    return 0;\n}\n\n\n#ifdef WOLFSSL_KEY_GEN\n\n/* build DER formatted ED448 key,\n * return length on success, negative on error */\nstatic int wc_BuildEd448KeyDer(ed448_key* key, byte* output, word32 inLen,\n                               int pubOut)\n{\n    byte   algoArray[MAX_ALGO_SZ];\n    byte   ver[MAX_VERSION_SZ];\n    byte   seq[MAX_SEQ_SZ];\n    int    ret;\n    word32 idx = 0, seqSz, verSz, algoSz, privSz, pubSz = 0;\n\n    if (key == NULL || output == NULL || inLen == 0)\n        return BAD_FUNC_ARG;\n\n    if (pubOut) {\n        pubSz = 2 + 2 + ED448_PUB_KEY_SIZE;\n    }\n    privSz = 2 + 2 + ED448_KEY_SIZE;\n    algoSz = SetAlgoID(ED448k, algoArray, oidKeyType, 0);\n    verSz  = SetMyVersion(0, ver, FALSE);\n    seqSz  = SetSequence(verSz + algoSz + privSz + pubSz, seq);\n\n    if (seqSz + verSz + algoSz + privSz + pubSz > inLen)\n        return BAD_FUNC_ARG;\n\n    /* write out */\n    /* seq */\n    XMEMCPY(output + idx, seq, seqSz);\n    idx = seqSz;\n    /* ver */\n    XMEMCPY(output + idx, ver, verSz);\n    idx += verSz;\n    /* algo */\n    XMEMCPY(output + idx, algoArray, algoSz);\n    idx += algoSz;\n    /* privKey */\n    idx += SetOctetString(2 + ED448_KEY_SIZE, output + idx);\n    idx += SetOctetString(ED448_KEY_SIZE, output + idx);\n    ret = wc_ed448_export_private_only(key, output + idx, &privSz);\n    if (ret != 0)\n        return ret;\n    idx += privSz;\n    /* pubKey */\n    if (pubOut) {\n        idx += SetExplicit(1, 2 + ED448_PUB_KEY_SIZE, output + idx);\n        idx += SetOctetString(ED448_KEY_SIZE, output + idx);\n        ret = wc_ed448_export_public(key, output + idx, &pubSz);\n        if (ret != 0)\n            return ret;\n        idx += pubSz;\n    }\n\n    return idx;\n}\n\n/* Write a Private ecc key, including public to DER format,\n * length on success else < 0 */\nint wc_Ed448KeyToDer(ed448_key* key, byte* output, word32 inLen)\n{\n    return wc_BuildEd448KeyDer(key, output, inLen, 1);\n}\n\n\n\n/* Write only private ecc key to DER format,\n * length on success else < 0 */\nint wc_Ed448PrivateKeyToDer(ed448_key* key, byte* output, word32 inLen)\n{\n    return wc_BuildEd448KeyDer(key, output, inLen, 0);\n}\n\n#endif /* WOLFSSL_KEY_GEN */\n\n#endif /* HAVE_ED448 */\n\n#if defined(HAVE_OCSP) || defined(HAVE_CRL)\n\n/* Get raw Date only, no processing, 0 on success */\nstatic int GetBasicDate(const byte* source, word32* idx, byte* date,\n                        byte* format, int maxIdx)\n{\n    int    ret, length;\n    const byte *datePtr = NULL;\n\n    WOLFSSL_ENTER(\"GetBasicDate\");\n\n    ret = GetDateInfo(source, idx, &datePtr, format, &length, maxIdx);\n    if (ret < 0)\n        return ret;\n\n    XMEMCPY(date, datePtr, length);\n\n    return 0;\n}\n\n#endif /* HAVE_OCSP || HAVE_CRL */\n\n\n#ifdef HAVE_OCSP\n\nstatic int GetEnumerated(const byte* input, word32* inOutIdx, int *value,\n        int sz)\n{\n    word32 idx = *inOutIdx;\n    word32 len;\n    byte   tag;\n\n    WOLFSSL_ENTER(\"GetEnumerated\");\n\n    *value = 0;\n\n    if (GetASNTag(input, &idx, &tag, sz) < 0)\n        return ASN_PARSE_E;\n\n    if (tag != ASN_ENUMERATED)\n        return ASN_PARSE_E;\n\n    if ((int)idx >= sz)\n        return BUFFER_E;\n\n    len = input[idx++];\n    if (len > 4 || (int)(len + idx) > sz)\n        return ASN_PARSE_E;\n\n    while (len--) {\n        *value  = *value << 8 | input[idx++];\n    }\n\n    *inOutIdx = idx;\n\n    return *value;\n}\n\n\nstatic int DecodeSingleResponse(byte* source, word32* ioIndex, word32 size,\n                                int wrapperSz, OcspEntry* single)\n{\n    word32 idx = *ioIndex, prevIndex, oid, localIdx, certIdIdx;\n    int length;\n    int ret;\n    byte tag;\n\n    WOLFSSL_ENTER(\"DecodeSingleResponse\");\n\n    prevIndex = idx;\n\n    /* Wrapper around the Single Response */\n    if (GetSequence(source, &idx, &length, size) < 0)\n        return ASN_PARSE_E;\n\n    /* Wrapper around the CertID */\n    certIdIdx = idx;\n    if (GetSequence(source, &idx, &length, size) < 0)\n        return ASN_PARSE_E;\n    single->rawCertId = source + certIdIdx;\n    /* Hash algorithm */\n    ret = GetAlgoId(source, &idx, &oid, oidIgnoreType, size);\n    if (ret < 0)\n        return ret;\n    single->hashAlgoOID = oid;\n    /* Save reference to the hash of CN */\n    ret = GetOctetString(source, &idx, &length, size);\n    if (ret < 0)\n        return ret;\n    if (length > (int)sizeof(single->issuerHash))\n        return BUFFER_E;\n    XMEMCPY(single->issuerHash, source + idx, length);\n    idx += length;\n    /* Save reference to the hash of the issuer public key */\n    ret = GetOctetString(source, &idx, &length, size);\n    if (ret < 0)\n        return ret;\n    if (length > (int)sizeof(single->issuerKeyHash))\n        return BUFFER_E;\n    XMEMCPY(single->issuerKeyHash, source + idx, length);\n    idx += length;\n\n    /* Get serial number */\n    if (GetSerialNumber(source, &idx, single->status->serial, &single->status->serialSz, size) < 0)\n        return ASN_PARSE_E;\n    single->rawCertIdSize = idx - certIdIdx;\n\n    if (idx >= size)\n        return BUFFER_E;\n\n    /* CertStatus */\n    switch (source[idx++])\n    {\n        case (ASN_CONTEXT_SPECIFIC | CERT_GOOD):\n            single->status->status = CERT_GOOD;\n            idx++;\n            break;\n        case (ASN_CONTEXT_SPECIFIC | ASN_CONSTRUCTED | CERT_REVOKED):\n            single->status->status = CERT_REVOKED;\n            if (GetLength(source, &idx, &length, size) < 0)\n                return ASN_PARSE_E;\n            idx += length;\n            break;\n        case (ASN_CONTEXT_SPECIFIC | CERT_UNKNOWN):\n            single->status->status = CERT_UNKNOWN;\n            idx++;\n            break;\n        default:\n            return ASN_PARSE_E;\n    }\n\n#if defined(OPENSSL_ALL) || defined(WOLFSSL_NGINX) || defined(WOLFSSL_HAPROXY)\n    single->status->thisDateAsn = source + idx;\n    localIdx = 0;\n    if (GetDateInfo(single->status->thisDateAsn, &localIdx, NULL,\n                    (byte*)&single->status->thisDateParsed.type,\n                    &single->status->thisDateParsed.length, size) < 0)\n        return ASN_PARSE_E;\n    XMEMCPY(single->status->thisDateParsed.data,\n            single->status->thisDateAsn + localIdx - single->status->thisDateParsed.length,\n            single->status->thisDateParsed.length);\n#endif\n    if (GetBasicDate(source, &idx, single->status->thisDate,\n                                                &single->status->thisDateFormat, size) < 0)\n        return ASN_PARSE_E;\n\n#ifndef NO_ASN_TIME\n#ifndef WOLFSSL_NO_OCSP_DATE_CHECK\n    if (!XVALIDATE_DATE(single->status->thisDate, single->status->thisDateFormat, BEFORE))\n        return ASN_BEFORE_DATE_E;\n#endif\n#endif\n\n    /* The following items are optional. Only check for them if there is more\n     * unprocessed data in the singleResponse wrapper. */\n    localIdx = idx;\n    if (((int)(idx - prevIndex) < wrapperSz) &&\n        GetASNTag(source, &localIdx, &tag, size) == 0 &&\n        tag == (ASN_CONSTRUCTED | ASN_CONTEXT_SPECIFIC | 0))\n    {\n        idx++;\n        if (GetLength(source, &idx, &length, size) < 0)\n            return ASN_PARSE_E;\n#if defined(OPENSSL_ALL) || defined(WOLFSSL_NGINX) || defined(WOLFSSL_HAPROXY)\n        single->status->nextDateAsn = source + idx;\n        localIdx = 0;\n        if (GetDateInfo(single->status->nextDateAsn, &localIdx, NULL,\n                        (byte*)&single->status->nextDateParsed.type,\n                        &single->status->nextDateParsed.length, size) < 0)\n            return ASN_PARSE_E;\n        XMEMCPY(single->status->nextDateParsed.data,\n                single->status->nextDateAsn + localIdx - single->status->nextDateParsed.length,\n                single->status->nextDateParsed.length);\n#endif\n        if (GetBasicDate(source, &idx, single->status->nextDate,\n                                                &single->status->nextDateFormat, size) < 0)\n            return ASN_PARSE_E;\n\n#ifndef NO_ASN_TIME\n#ifndef WOLFSSL_NO_OCSP_DATE_CHECK\n        if (!XVALIDATE_DATE(single->status->nextDate, single->status->nextDateFormat, AFTER))\n            return ASN_AFTER_DATE_E;\n#endif\n#endif\n    }\n\n    /* Skip the optional extensions in singleResponse. */\n    localIdx = idx;\n    if (((int)(idx - prevIndex) < wrapperSz) &&\n        GetASNTag(source, &localIdx, &tag, size) == 0 &&\n        tag == (ASN_CONSTRUCTED | ASN_CONTEXT_SPECIFIC | 1))\n    {\n        idx++;\n        if (GetLength(source, &idx, &length, size) < 0)\n            return ASN_PARSE_E;\n        idx += length;\n    }\n\n    *ioIndex = idx;\n\n    return 0;\n}\n\nstatic int DecodeOcspRespExtensions(byte* source,\n                            word32* ioIndex, OcspResponse* resp, word32 sz)\n{\n    word32 idx = *ioIndex;\n    int length;\n    int ext_bound; /* boundary index for the sequence of extensions */\n    word32 oid;\n    int ret;\n    byte tag;\n\n    WOLFSSL_ENTER(\"DecodeOcspRespExtensions\");\n\n    if ((idx + 1) > sz)\n        return BUFFER_E;\n\n    if (GetASNTag(source, &idx, &tag, sz) < 0)\n        return ASN_PARSE_E;\n\n    if (tag != (ASN_CONSTRUCTED | ASN_CONTEXT_SPECIFIC | 1))\n        return ASN_PARSE_E;\n\n    if (GetLength(source, &idx, &length, sz) < 0)\n        return ASN_PARSE_E;\n\n    if (GetSequence(source, &idx, &length, sz) < 0)\n        return ASN_PARSE_E;\n\n    ext_bound = idx + length;\n\n    while (idx < (word32)ext_bound) {\n        word32 localIdx;\n\n        if (GetSequence(source, &idx, &length, sz) < 0) {\n            WOLFSSL_MSG(\"\\tfail: should be a SEQUENCE\");\n            return ASN_PARSE_E;\n        }\n\n        oid = 0;\n        if (GetObjectId(source, &idx, &oid, oidOcspType, sz) < 0) {\n            WOLFSSL_MSG(\"\\tfail: OBJECT ID\");\n            return ASN_PARSE_E;\n        }\n\n        /* check for critical flag */\n        if ((idx + 1) > (word32)sz) {\n            WOLFSSL_MSG(\"\\tfail: malformed buffer\");\n            return BUFFER_E;\n        }\n\n        localIdx = idx;\n        if (GetASNTag(source, &localIdx, &tag, sz) == 0 && tag == ASN_BOOLEAN) {\n            WOLFSSL_MSG(\"\\tfound optional critical flag, moving past\");\n            ret = GetBoolean(source, &idx, sz);\n            if (ret < 0)\n                return ret;\n        }\n\n        ret = GetOctetString(source, &idx, &length, sz);\n        if (ret < 0)\n            return ret;\n\n        if (oid == OCSP_NONCE_OID) {\n            /* get data inside extra OCTET_STRING */\n            ret = GetOctetString(source, &idx, &length, sz);\n            if (ret < 0)\n                return ret;\n\n            resp->nonce = source + idx;\n            resp->nonceSz = length;\n        }\n\n        idx += length;\n    }\n\n    *ioIndex = idx;\n    return 0;\n}\n\n\nstatic int DecodeResponseData(byte* source,\n                            word32* ioIndex, OcspResponse* resp, word32 size)\n{\n    word32 idx = *ioIndex, prev_idx, localIdx;\n    int length;\n    int version;\n    int ret;\n    byte tag;\n    int wrapperSz;\n    OcspEntry* single;\n\n    WOLFSSL_ENTER(\"DecodeResponseData\");\n\n    resp->response = source + idx;\n    prev_idx = idx;\n    if (GetSequence(source, &idx, &length, size) < 0)\n        return ASN_PARSE_E;\n    resp->responseSz = length + idx - prev_idx;\n\n    /* Get version. It is an EXPLICIT[0] DEFAULT(0) value. If this\n     * item isn't an EXPLICIT[0], then set version to zero and move\n     * onto the next item.\n     */\n    localIdx = idx;\n    if (GetASNTag(source, &localIdx, &tag, size) == 0 &&\n            tag == (ASN_CONTEXT_SPECIFIC | ASN_CONSTRUCTED))\n    {\n        idx += 2; /* Eat the value and length */\n        if (GetMyVersion(source, &idx, &version, size) < 0)\n            return ASN_PARSE_E;\n    } else\n        version = 0;\n\n    localIdx = idx;\n    if (GetASNTag(source, &localIdx, &tag, size) == 0 &&\n        ( tag == (ASN_CONTEXT_SPECIFIC | ASN_CONSTRUCTED | 1) ||\n          tag == (ASN_CONTEXT_SPECIFIC | ASN_CONSTRUCTED | 2) ))\n    {\n        idx++; /* advance past ASN tag */\n        if (GetLength(source, &idx, &length, size) < 0)\n            return ASN_PARSE_E;\n        idx += length;\n    }\n    else\n        return ASN_PARSE_E;\n\n    /* save pointer to the producedAt time */\n    if (GetBasicDate(source, &idx, resp->producedDate,\n                                        &resp->producedDateFormat, size) < 0)\n        return ASN_PARSE_E;\n\n    /* Outer wrapper of the SEQUENCE OF Single Responses. */\n    if (GetSequence(source, &idx, &wrapperSz, size) < 0)\n        return ASN_PARSE_E;\n\n    localIdx = idx;\n    single = resp->single;\n\n    while (idx - localIdx < (word32)wrapperSz) {\n        ret = DecodeSingleResponse(source, &idx, size, wrapperSz, single);\n        if (ret < 0)\n            return ret; /* ASN_PARSE_E, ASN_BEFORE_DATE_E, ASN_AFTER_DATE_E */\n        if (idx - localIdx < (word32)wrapperSz) {\n            single->next = (OcspEntry*)XMALLOC(sizeof(OcspEntry), resp->heap, \n                DYNAMIC_TYPE_OCSP_ENTRY);\n            if (single->next == NULL) {\n                return MEMORY_E;\n            }\n            XMEMSET(single->next, 0, sizeof(OcspEntry));\n\n            single->next->status = (CertStatus*)XMALLOC(sizeof(CertStatus),\n                resp->heap, DYNAMIC_TYPE_OCSP_STATUS);\n            if (single->next->status == NULL) {\n                XFREE(single->next, resp->heap, DYNAMIC_TYPE_OCSP_ENTRY);\n                single->next = NULL;\n                return MEMORY_E;\n            }\n            XMEMSET(single->next->status, 0, sizeof(CertStatus));\n\n            single->next->isDynamic = 1;\n\n            single = single->next;\n        }\n    }\n\n    /*\n     * Check the length of the ResponseData against the current index to\n     * see if there are extensions, they are optional.\n     */\n    if (idx - prev_idx < resp->responseSz)\n        if (DecodeOcspRespExtensions(source, &idx, resp, size) < 0)\n            return ASN_PARSE_E;\n\n    *ioIndex = idx;\n    return 0;\n}\n\n\n#ifndef WOLFSSL_NO_OCSP_OPTIONAL_CERTS\n\nstatic int DecodeCerts(byte* source,\n                            word32* ioIndex, OcspResponse* resp, word32 size)\n{\n    word32 idx = *ioIndex;\n    byte tag;\n\n    WOLFSSL_ENTER(\"DecodeCerts\");\n\n    if (GetASNTag(source, &idx, &tag, size) < 0)\n        return ASN_PARSE_E;\n\n    if (tag == (ASN_CONSTRUCTED | ASN_CONTEXT_SPECIFIC))\n    {\n        int length;\n\n        if (GetLength(source, &idx, &length, size) < 0)\n            return ASN_PARSE_E;\n\n        if (GetSequence(source, &idx, &length, size) < 0)\n            return ASN_PARSE_E;\n\n        resp->cert = source + idx;\n        resp->certSz = length;\n\n        idx += length;\n    }\n    *ioIndex = idx;\n    return 0;\n}\n\n#endif /* WOLFSSL_NO_OCSP_OPTIONAL_CERTS */\n\n\nstatic int DecodeBasicOcspResponse(byte* source, word32* ioIndex,\n            OcspResponse* resp, word32 size, void* cm, void* heap, int noVerify)\n{\n    int    length;\n    word32 idx = *ioIndex;\n    word32 end_index;\n    int    ret;\n    int    sigLength;\n\n    WOLFSSL_ENTER(\"DecodeBasicOcspResponse\");\n    (void)heap;\n\n    if (GetSequence(source, &idx, &length, size) < 0)\n        return ASN_PARSE_E;\n\n    if (idx + length > size)\n        return ASN_INPUT_E;\n    end_index = idx + length;\n\n    if ((ret = DecodeResponseData(source, &idx, resp, size)) < 0)\n        return ret; /* ASN_PARSE_E, ASN_BEFORE_DATE_E, ASN_AFTER_DATE_E */\n\n    /* Get the signature algorithm */\n    if (GetAlgoId(source, &idx, &resp->sigOID, oidSigType, size) < 0)\n        return ASN_PARSE_E;\n\n    ret = CheckBitString(source, &idx, &sigLength, size, 1, NULL);\n    if (ret != 0)\n        return ret;\n\n    resp->sigSz = sigLength;\n    resp->sig = source + idx;\n    idx += sigLength;\n\n    /*\n     * Check the length of the BasicOcspResponse against the current index to\n     * see if there are certificates, they are optional.\n     */\n#ifndef WOLFSSL_NO_OCSP_OPTIONAL_CERTS\n    if (idx < end_index)\n    {\n        DecodedCert cert;\n\n        if (DecodeCerts(source, &idx, resp, size) < 0)\n            return ASN_PARSE_E;\n\n        InitDecodedCert(&cert, resp->cert, resp->certSz, heap);\n\n        /* Don't verify if we don't have access to Cert Manager. */\n        ret = ParseCertRelative(&cert, CERT_TYPE,\n                                noVerify ? NO_VERIFY : VERIFY_OCSP, cm);\n        if (ret < 0) {\n            WOLFSSL_MSG(\"\\tOCSP Responder certificate parsing failed\");\n            FreeDecodedCert(&cert);\n            return ret;\n        }\n\n#ifndef WOLFSSL_NO_OCSP_ISSUER_CHECK\n        if ((cert.extExtKeyUsage & EXTKEYUSE_OCSP_SIGN) == 0) {\n            if (XMEMCMP(cert.subjectHash,\n                        resp->single->issuerHash, OCSP_DIGEST_SIZE) == 0) {\n                WOLFSSL_MSG(\"\\tOCSP Response signed by issuer\");\n            }\n            else {\n                WOLFSSL_MSG(\"\\tOCSP Responder key usage check failed\");\n    #ifdef OPENSSL_EXTRA\n                resp->verifyError = OCSP_BAD_ISSUER;\n    #else\n                FreeDecodedCert(&cert);\n                return BAD_OCSP_RESPONDER;\n    #endif\n            }\n        }\n#endif\n\n        /* ConfirmSignature is blocking here */\n        ret = ConfirmSignature(&cert.sigCtx,\n            resp->response, resp->responseSz,\n            cert.publicKey, cert.pubKeySize, cert.keyOID,\n            resp->sig, resp->sigSz, resp->sigOID, NULL);\n\n        FreeDecodedCert(&cert);\n\n        if (ret != 0) {\n            WOLFSSL_MSG(\"\\tOCSP Confirm signature failed\");\n            return ASN_OCSP_CONFIRM_E;\n        }\n    }\n    else\n#endif /* WOLFSSL_NO_OCSP_OPTIONAL_CERTS */\n    {\n        Signer* ca;\n        int sigValid = -1;\n\n        #ifndef NO_SKID\n            ca = GetCA(cm, resp->single->issuerKeyHash);\n        #else\n            ca = GetCA(cm, resp->single->issuerHash);\n        #endif\n\n        if (ca) {\n            SignatureCtx sigCtx;\n            InitSignatureCtx(&sigCtx, heap, INVALID_DEVID);\n\n            /* ConfirmSignature is blocking here */\n            sigValid = ConfirmSignature(&sigCtx, resp->response,\n                resp->responseSz, ca->publicKey, ca->pubKeySize, ca->keyOID,\n                                resp->sig, resp->sigSz, resp->sigOID, NULL);\n        }\n        if (ca == NULL || sigValid != 0) {\n            WOLFSSL_MSG(\"\\tOCSP Confirm signature failed\");\n            return ASN_OCSP_CONFIRM_E;\n        }\n\n        (void)noVerify;\n    }\n\n    *ioIndex = idx;\n    return 0;\n}\n\n\nvoid InitOcspResponse(OcspResponse* resp, OcspEntry* single, CertStatus* status,\n                      byte* source, word32 inSz, void* heap)\n{\n    WOLFSSL_ENTER(\"InitOcspResponse\");\n\n    XMEMSET(status, 0, sizeof(CertStatus));\n    XMEMSET(single,  0, sizeof(OcspEntry));\n    XMEMSET(resp,   0, sizeof(OcspResponse));\n\n    single->status       = status;\n    resp->responseStatus = -1;\n    resp->single         = single;\n    resp->source         = source;\n    resp->maxIdx         = inSz;\n    resp->heap           = heap;\n}\n\nvoid FreeOcspResponse(OcspResponse* resp)\n{\n    OcspEntry *single, *next;\n    for (single = resp->single; single; single = next) {\n        next = single->next;\n        if (single->isDynamic) {\n            XFREE(single->status, resp->heap, DYNAMIC_TYPE_OCSP_STATUS);\n            XFREE(single, resp->heap, DYNAMIC_TYPE_OCSP_ENTRY);\n        }\n    }\n}\n\n\nint OcspResponseDecode(OcspResponse* resp, void* cm, void* heap, int noVerify)\n{\n    int ret;\n    int length = 0;\n    word32 idx = 0;\n    byte* source = resp->source;\n    word32 size = resp->maxIdx;\n    word32 oid;\n    byte   tag;\n\n    WOLFSSL_ENTER(\"OcspResponseDecode\");\n\n    /* peel the outer SEQUENCE wrapper */\n    if (GetSequence(source, &idx, &length, size) < 0)\n        return ASN_PARSE_E;\n\n    /* First get the responseStatus, an ENUMERATED */\n    if (GetEnumerated(source, &idx, &resp->responseStatus, size) < 0)\n        return ASN_PARSE_E;\n\n    if (resp->responseStatus != OCSP_SUCCESSFUL)\n        return 0;\n\n    /* Next is an EXPLICIT record called ResponseBytes, OPTIONAL */\n    if (idx >= size)\n        return ASN_INPUT_E;\n    if (GetASNTag(source, &idx, &tag, size) < 0)\n        return ASN_PARSE_E;\n    if (tag != (ASN_CONSTRUCTED | ASN_CONTEXT_SPECIFIC))\n        return ASN_PARSE_E;\n    if (GetLength(source, &idx, &length, size) < 0)\n        return ASN_PARSE_E;\n\n    /* Get the responseBytes SEQUENCE */\n    if (GetSequence(source, &idx, &length, size) < 0)\n        return ASN_PARSE_E;\n\n    /* Check ObjectID for the resposeBytes */\n    if (GetObjectId(source, &idx, &oid, oidOcspType, size) < 0)\n        return ASN_PARSE_E;\n    if (oid != OCSP_BASIC_OID)\n        return ASN_PARSE_E;\n    ret = GetOctetString(source, &idx, &length, size);\n    if (ret < 0)\n        return ret;\n\n    ret = DecodeBasicOcspResponse(source, &idx, resp, size, cm, heap, noVerify);\n    if (ret < 0)\n        return ret;\n\n    return 0;\n}\n\n\nword32 EncodeOcspRequestExtensions(OcspRequest* req, byte* output, word32 size)\n{\n    const byte NonceObjId[] = { 0x2b, 0x06, 0x01, 0x05, 0x05, 0x07,\n                                       0x30, 0x01, 0x02 };\n    byte seqArray[5][MAX_SEQ_SZ];\n    word32 seqSz[5], totalSz = (word32)sizeof(NonceObjId);\n\n    WOLFSSL_ENTER(\"SetOcspReqExtensions\");\n\n    if (!req || !output || !req->nonceSz)\n        return 0;\n\n    totalSz += req->nonceSz;\n    totalSz += seqSz[0] = SetOctetString(req->nonceSz, seqArray[0]);\n    totalSz += seqSz[1] = SetOctetString(req->nonceSz + seqSz[0], seqArray[1]);\n    totalSz += seqSz[2] = SetObjectId(sizeof(NonceObjId), seqArray[2]);\n    totalSz += seqSz[3] = SetSequence(totalSz, seqArray[3]);\n    totalSz += seqSz[4] = SetSequence(totalSz, seqArray[4]);\n\n    if (totalSz > size)\n        return 0;\n\n    totalSz = 0;\n\n    XMEMCPY(output + totalSz, seqArray[4], seqSz[4]);\n    totalSz += seqSz[4];\n\n    XMEMCPY(output + totalSz, seqArray[3], seqSz[3]);\n    totalSz += seqSz[3];\n\n    XMEMCPY(output + totalSz, seqArray[2], seqSz[2]);\n    totalSz += seqSz[2];\n\n    XMEMCPY(output + totalSz, NonceObjId, sizeof(NonceObjId));\n    totalSz += (word32)sizeof(NonceObjId);\n\n    XMEMCPY(output + totalSz, seqArray[1], seqSz[1]);\n    totalSz += seqSz[1];\n\n    XMEMCPY(output + totalSz, seqArray[0], seqSz[0]);\n    totalSz += seqSz[0];\n\n    XMEMCPY(output + totalSz, req->nonce, req->nonceSz);\n    totalSz += req->nonceSz;\n\n    return totalSz;\n}\n\n\nint EncodeOcspRequest(OcspRequest* req, byte* output, word32 size)\n{\n    byte seqArray[5][MAX_SEQ_SZ];\n    /* The ASN.1 of the OCSP Request is an onion of sequences */\n    byte algoArray[MAX_ALGO_SZ];\n    byte issuerArray[MAX_ENCODED_DIG_SZ];\n    byte issuerKeyArray[MAX_ENCODED_DIG_SZ];\n    byte snArray[MAX_SN_SZ];\n    byte extArray[MAX_OCSP_EXT_SZ];\n    word32 seqSz[5], algoSz, issuerSz, issuerKeySz, extSz, totalSz;\n    int i, snSz;\n\n    WOLFSSL_ENTER(\"EncodeOcspRequest\");\n\n#ifdef NO_SHA\n    algoSz = SetAlgoID(SHA256h, algoArray, oidHashType, 0);\n#else\n    algoSz = SetAlgoID(SHAh, algoArray, oidHashType, 0);\n#endif\n\n    issuerSz    = SetDigest(req->issuerHash,    KEYID_SIZE,    issuerArray);\n    issuerKeySz = SetDigest(req->issuerKeyHash, KEYID_SIZE,    issuerKeyArray);\n    snSz        = SetSerialNumber(req->serial,  req->serialSz, snArray,\n                                                          MAX_SN_SZ, MAX_SN_SZ);\n    extSz       = 0;\n\n    if (snSz < 0)\n        return snSz;\n\n    if (req->nonceSz) {\n        /* TLS Extensions use this function too - put extensions after\n         * ASN.1: Context Specific [2].\n         */\n        extSz = EncodeOcspRequestExtensions(req, extArray + 2,\n                                            OCSP_NONCE_EXT_SZ);\n        extSz += SetExplicit(2, extSz, extArray);\n    }\n\n    totalSz = algoSz + issuerSz + issuerKeySz + snSz;\n    for (i = 4; i >= 0; i--) {\n        seqSz[i] = SetSequence(totalSz, seqArray[i]);\n        totalSz += seqSz[i];\n        if (i == 2) totalSz += extSz;\n    }\n\n    if (output == NULL)\n        return totalSz;\n    if (totalSz > size)\n        return BUFFER_E;\n\n    totalSz = 0;\n    for (i = 0; i < 5; i++) {\n        XMEMCPY(output + totalSz, seqArray[i], seqSz[i]);\n        totalSz += seqSz[i];\n    }\n\n    XMEMCPY(output + totalSz, algoArray, algoSz);\n    totalSz += algoSz;\n\n    XMEMCPY(output + totalSz, issuerArray, issuerSz);\n    totalSz += issuerSz;\n\n    XMEMCPY(output + totalSz, issuerKeyArray, issuerKeySz);\n    totalSz += issuerKeySz;\n\n    XMEMCPY(output + totalSz, snArray, snSz);\n    totalSz += snSz;\n\n    if (extSz != 0) {\n        XMEMCPY(output + totalSz, extArray, extSz);\n        totalSz += extSz;\n    }\n\n    return totalSz;\n}\n\n\nint InitOcspRequest(OcspRequest* req, DecodedCert* cert, byte useNonce,\n                                                                     void* heap)\n{\n    int ret;\n\n    WOLFSSL_ENTER(\"InitOcspRequest\");\n\n    if (req == NULL)\n        return BAD_FUNC_ARG;\n\n    ForceZero(req, sizeof(OcspRequest));\n    req->heap = heap;\n\n    if (cert) {\n        XMEMCPY(req->issuerHash,    cert->issuerHash,    KEYID_SIZE);\n        XMEMCPY(req->issuerKeyHash, cert->issuerKeyHash, KEYID_SIZE);\n\n        req->serial = (byte*)XMALLOC(cert->serialSz, req->heap,\n                                                     DYNAMIC_TYPE_OCSP_REQUEST);\n        if (req->serial == NULL)\n            return MEMORY_E;\n\n        XMEMCPY(req->serial, cert->serial, cert->serialSz);\n        req->serialSz = cert->serialSz;\n\n        if (cert->extAuthInfoSz != 0 && cert->extAuthInfo != NULL) {\n            req->url = (byte*)XMALLOC(cert->extAuthInfoSz + 1, req->heap,\n                                                     DYNAMIC_TYPE_OCSP_REQUEST);\n            if (req->url == NULL) {\n                XFREE(req->serial, req->heap, DYNAMIC_TYPE_OCSP);\n                return MEMORY_E;\n            }\n\n            XMEMCPY(req->url, cert->extAuthInfo, cert->extAuthInfoSz);\n            req->urlSz = cert->extAuthInfoSz;\n            req->url[req->urlSz] = 0;\n        }\n    }\n\n    if (useNonce) {\n        WC_RNG rng;\n\n    #ifndef HAVE_FIPS\n        ret = wc_InitRng_ex(&rng, req->heap, INVALID_DEVID);\n    #else\n        ret = wc_InitRng(&rng);\n    #endif\n        if (ret != 0) {\n            WOLFSSL_MSG(\"\\tCannot initialize RNG. Skipping the OSCP Nonce.\");\n        } else {\n            if (wc_RNG_GenerateBlock(&rng, req->nonce, MAX_OCSP_NONCE_SZ) != 0)\n                WOLFSSL_MSG(\"\\tCannot run RNG. Skipping the OSCP Nonce.\");\n            else\n                req->nonceSz = MAX_OCSP_NONCE_SZ;\n\n            wc_FreeRng(&rng);\n        }\n    }\n\n    return 0;\n}\n\nvoid FreeOcspRequest(OcspRequest* req)\n{\n    WOLFSSL_ENTER(\"FreeOcspRequest\");\n\n    if (req) {\n        if (req->serial)\n            XFREE(req->serial, req->heap, DYNAMIC_TYPE_OCSP_REQUEST);\n        req->serial = NULL;\n\n#ifdef OPENSSL_EXTRA\n        if (req->serialInt) {\n            if (req->serialInt->isDynamic) {\n                XFREE(req->serialInt->data, NULL, DYNAMIC_TYPE_OPENSSL);\n            }\n            XFREE(req->serialInt, NULL, DYNAMIC_TYPE_OPENSSL);\n        }\n        req->serialInt = NULL;\n#endif\n\n        if (req->url)\n            XFREE(req->url, req->heap, DYNAMIC_TYPE_OCSP_REQUEST);\n        req->url = NULL;\n    }\n}\n\n\nint CompareOcspReqResp(OcspRequest* req, OcspResponse* resp)\n{\n    int cmp = -1; /* default as not matching, cmp gets set on each check */\n    OcspEntry *single, *next, *prev = NULL, *top;\n\n    WOLFSSL_ENTER(\"CompareOcspReqResp\");\n\n    if (req == NULL) {\n        WOLFSSL_MSG(\"\\tReq missing\");\n        return -1;\n    }\n    if (resp == NULL || resp->single == NULL) {\n        WOLFSSL_MSG(\"\\tResp missing\");\n        return 1;\n    }\n\n    /* Nonces are not critical. The responder may not necessarily add\n     * the nonce to the response. */\n    if (req->nonceSz && resp->nonce != NULL\n#ifndef WOLFSSL_FORCE_OCSP_NONCE_CHECK\n            && resp->nonceSz != 0\n#endif\n    ) {\n        cmp = req->nonceSz - resp->nonceSz;\n        if (cmp != 0) {\n            WOLFSSL_MSG(\"\\tnonceSz mismatch\");\n            return cmp;\n        }\n\n        cmp = XMEMCMP(req->nonce, resp->nonce, req->nonceSz);\n        if (cmp != 0) {\n            WOLFSSL_MSG(\"\\tnonce mismatch\");\n            return cmp;\n        }\n    }\n\n    /* match based on found status and return */\n    for (single = resp->single; single; single = next) {\n        cmp = req->serialSz - single->status->serialSz;\n        if (cmp == 0) {\n            cmp = XMEMCMP(req->serial, single->status->serial, req->serialSz)\n               || XMEMCMP(req->issuerHash, single->issuerHash, OCSP_DIGEST_SIZE)\n               || XMEMCMP(req->issuerKeyHash, single->issuerKeyHash, OCSP_DIGEST_SIZE);\n            if (cmp == 0) {\n                /* match found */\n                if (resp->single != single && prev) {\n                    /* move to top of list */\n                    top = resp->single;\n                    resp->single = single;\n                    prev->next = single->next;\n                    single->next = top;\n                }\n                break;\n            }\n        }\n        next = single->next;\n        prev = single;\n    }\n\n    if (cmp != 0) {\n        WOLFSSL_MSG(\"\\trequest and response mismatch\");\n        return cmp;\n    }\n\n    return 0;\n}\n\n#endif /* HAVE_OCSP */\n\n\n/* store WC_SHA hash of NAME */\nint GetNameHash(const byte* source, word32* idx, byte* hash,\n                             int maxIdx)\n{\n    int    length;  /* length of all distinguished names */\n    int    ret;\n    word32 dummy;\n    byte   tag;\n\n    WOLFSSL_ENTER(\"GetNameHash\");\n\n    dummy = *idx;\n    if (GetASNTag(source, &dummy, &tag, maxIdx) == 0 && tag == ASN_OBJECT_ID) {\n        WOLFSSL_MSG(\"Trying optional prefix...\");\n\n        if (GetLength(source, idx, &length, maxIdx) < 0)\n            return ASN_PARSE_E;\n\n        *idx += length;\n        WOLFSSL_MSG(\"Got optional prefix\");\n    }\n\n    /* For OCSP, RFC2560 section 4.1.1 states the issuer hash should be\n     * calculated over the entire DER encoding of the Name field, including\n     * the tag and length. */\n    dummy = *idx;\n    if (GetSequence(source, idx, &length, maxIdx) < 0)\n        return ASN_PARSE_E;\n\n    ret = CalcHashId(source + dummy, length + *idx - dummy, hash);\n\n    *idx += length;\n\n    return ret;\n}\n\n\n#ifdef HAVE_CRL\n\n/* initialize decoded CRL */\nvoid InitDecodedCRL(DecodedCRL* dcrl, void* heap)\n{\n    WOLFSSL_MSG(\"InitDecodedCRL\");\n\n    XMEMSET(dcrl, 0, sizeof(DecodedCRL));\n    dcrl->heap = heap;\n    #ifdef WOLFSSL_HEAP_TEST\n        dcrl->heap = (void*)WOLFSSL_HEAP_TEST;\n    #endif\n}\n\n\n/* free decoded CRL resources */\nvoid FreeDecodedCRL(DecodedCRL* dcrl)\n{\n    RevokedCert* tmp = dcrl->certs;\n\n    WOLFSSL_MSG(\"FreeDecodedCRL\");\n\n    while(tmp) {\n        RevokedCert* next = tmp->next;\n        XFREE(tmp, dcrl->heap, DYNAMIC_TYPE_REVOKED);\n        tmp = next;\n    }\n}\n\n\n/* Get Revoked Cert list, 0 on success */\nstatic int GetRevoked(const byte* buff, word32* idx, DecodedCRL* dcrl,\n                      int maxIdx)\n{\n    int    ret, len;\n    word32 end;\n    byte   b;\n    RevokedCert* rc;\n\n    WOLFSSL_ENTER(\"GetRevoked\");\n\n    if (GetSequence(buff, idx, &len, maxIdx) < 0)\n        return ASN_PARSE_E;\n\n    end = *idx + len;\n\n    rc = (RevokedCert*)XMALLOC(sizeof(RevokedCert), dcrl->heap,\n                                                          DYNAMIC_TYPE_REVOKED);\n    if (rc == NULL) {\n        WOLFSSL_MSG(\"Alloc Revoked Cert failed\");\n        return MEMORY_E;\n    }\n\n    if (GetSerialNumber(buff, idx, rc->serialNumber, &rc->serialSz,\n                                                                maxIdx) < 0) {\n        XFREE(rc, dcrl->heap, DYNAMIC_TYPE_REVOKED);\n        return ASN_PARSE_E;\n    }\n\n    /* add to list */\n    rc->next = dcrl->certs;\n    dcrl->certs = rc;\n    dcrl->totalCerts++;\n\n    /* get date */\n    ret = GetDateInfo(buff, idx, NULL, &b, NULL, maxIdx);\n    if (ret < 0) {\n        WOLFSSL_MSG(\"Expecting Date\");\n        return ret;\n    }\n\n    /* skip extensions */\n    *idx = end;\n\n    return 0;\n}\n\n\n/* Get CRL Signature, 0 on success */\nstatic int GetCRL_Signature(const byte* source, word32* idx, DecodedCRL* dcrl,\n                            int maxIdx)\n{\n    int    length;\n    int    ret;\n\n    WOLFSSL_ENTER(\"GetCRL_Signature\");\n\n    ret = CheckBitString(source, idx, &length, maxIdx, 1, NULL);\n    if (ret != 0)\n        return ret;\n    dcrl->sigLength = length;\n\n    dcrl->signature = (byte*)&source[*idx];\n    *idx += dcrl->sigLength;\n\n    return 0;\n}\n\nint VerifyCRL_Signature(SignatureCtx* sigCtx, const byte* toBeSigned,\n                        word32 tbsSz, const byte* signature, word32 sigSz,\n                        word32 signatureOID, Signer *ca, void* heap)\n{\n    /* try to confirm/verify signature */\n#ifndef IGNORE_KEY_EXTENSIONS\n    if ((ca->keyUsage & KEYUSE_CRL_SIGN) == 0) {\n        WOLFSSL_MSG(\"CA cannot sign CRLs\");\n        return ASN_CRL_NO_SIGNER_E;\n    }\n#endif /* IGNORE_KEY_EXTENSIONS */\n\n    InitSignatureCtx(sigCtx, heap, INVALID_DEVID);\n    if (ConfirmSignature(sigCtx, toBeSigned, tbsSz, ca->publicKey,\n                         ca->pubKeySize, ca->keyOID, signature, sigSz,\n                         signatureOID, NULL) != 0) {\n        WOLFSSL_MSG(\"CRL Confirm signature failed\");\n        return ASN_CRL_CONFIRM_E;\n    }\n\n    return 0;\n}\n\n\nstatic int ParseCRL_CertList(DecodedCRL* dcrl, const byte* buf,\n        word32* inOutIdx, int sz)\n{\n    word32 oid, dateIdx, idx, checkIdx;\n    int version;\n#ifdef WOLFSSL_NO_CRL_NEXT_DATE\n    int doNextDate = 1;\n#endif\n    byte tag;\n\n    if (dcrl == NULL || inOutIdx == NULL || buf == NULL) {\n        return BAD_FUNC_ARG;\n    }\n\n    /* may have version */\n    idx = *inOutIdx;\n\n    checkIdx = idx;\n    if (GetASNTag(buf, &checkIdx, &tag, sz) == 0 && tag == ASN_INTEGER) {\n        if (GetMyVersion(buf, &idx, &version, sz) < 0)\n            return ASN_PARSE_E;\n    }\n\n    if (GetAlgoId(buf, &idx, &oid, oidIgnoreType, sz) < 0)\n        return ASN_PARSE_E;\n\n    if (GetNameHash(buf, &idx, dcrl->issuerHash, sz) < 0)\n        return ASN_PARSE_E;\n\n    if (GetBasicDate(buf, &idx, dcrl->lastDate, &dcrl->lastDateFormat, sz) < 0)\n        return ASN_PARSE_E;\n\n    dateIdx = idx;\n\n    if (GetBasicDate(buf, &idx, dcrl->nextDate, &dcrl->nextDateFormat, sz) < 0)\n    {\n#ifndef WOLFSSL_NO_CRL_NEXT_DATE\n        (void)dateIdx;\n        return ASN_PARSE_E;\n#else\n        dcrl->nextDateFormat = ASN_OTHER_TYPE;  /* skip flag */\n        doNextDate = 0;\n        idx = dateIdx;\n#endif\n    }\n\n#ifdef WOLFSSL_NO_CRL_NEXT_DATE\n    if (doNextDate)x\n#endif\n    {\n#ifndef NO_ASN_TIME\n        if (!XVALIDATE_DATE(dcrl->nextDate, dcrl->nextDateFormat, AFTER)) {\n            WOLFSSL_MSG(\"CRL after date is no longer valid\");\n            return ASN_AFTER_DATE_E;\n        }\n#endif\n    }\n\n    checkIdx = idx;\n    if (idx != dcrl->sigIndex &&\n           GetASNTag(buf, &checkIdx, &tag, sz) == 0 && tag != CRL_EXTENSIONS) {\n\n        int len;\n\n        if (GetSequence(buf, &idx, &len, sz) < 0)\n            return ASN_PARSE_E;\n        len += idx;\n\n        while (idx < (word32)len) {\n            if (GetRevoked(buf, &idx, dcrl, len) < 0)\n                return ASN_PARSE_E;\n        }\n    }\n\n    *inOutIdx = idx;\n\n    return 0;\n}\n\n\n#ifndef NO_SKID\nstatic int ParseCRL_AuthKeyIdExt(const byte* input, int sz, DecodedCRL* dcrl)\n{\n    word32 idx = 0;\n    int length = 0, ret = 0;\n    byte tag;\n\n    WOLFSSL_ENTER(\"ParseCRL_AuthKeyIdExt\");\n\n    if (GetSequence(input, &idx, &length, sz) < 0) {\n        WOLFSSL_MSG(\"\\tfail: should be a SEQUENCE\\n\");\n        return ASN_PARSE_E;\n    }\n\n    if (GetASNTag(input, &idx, &tag, sz) < 0) {\n        return ASN_PARSE_E;\n    }\n\n    if (tag != (ASN_CONTEXT_SPECIFIC | 0)) {\n        WOLFSSL_MSG(\"\\tinfo: OPTIONAL item 0, not available\\n\");\n        return 0;\n    }\n\n    if (GetLength(input, &idx, &length, sz) <= 0) {\n        WOLFSSL_MSG(\"\\tfail: extension data length\");\n        return ASN_PARSE_E;\n    }\n\n    dcrl->extAuthKeyIdSet = 1;\n    if (length == KEYID_SIZE) {\n        XMEMCPY(dcrl->extAuthKeyId, input + idx, length);\n    }\n    else {\n        ret = CalcHashId(input + idx, length, dcrl->extAuthKeyId);\n    }\n\n    return ret;\n}\n#endif\n\n\nstatic int ParseCRL_Extensions(DecodedCRL* dcrl, const byte* buf,\n        word32* inOutIdx, word32 sz)\n{\n    int length;\n    word32 idx;\n    word32 ext_bound; /* boundary index for the sequence of extensions */\n    word32 oid;\n    byte tag;\n\n    WOLFSSL_ENTER(\"ParseCRL_Extensions\");\n    (void)dcrl;\n\n    if (inOutIdx == NULL)\n        return BAD_FUNC_ARG;\n\n    idx = *inOutIdx;\n\n    /* CRL Extensions are optional */\n    if ((idx + 1) > sz)\n        return 0;\n\n    /* CRL Extensions are optional */\n    if (GetASNTag(buf, &idx, &tag, sz) < 0)\n        return 0;\n\n    /* CRL Extensions are optional */\n    if (tag != (ASN_CONSTRUCTED | ASN_CONTEXT_SPECIFIC | 0))\n        return 0;\n\n    if (GetLength(buf, &idx, &length, sz) < 0)\n        return ASN_PARSE_E;\n\n    if (GetSequence(buf, &idx, &length, sz) < 0)\n        return ASN_PARSE_E;\n\n    ext_bound = idx + length;\n\n    while (idx < (word32)ext_bound) {\n        word32 localIdx;\n        int ret;\n\n        if (GetSequence(buf, &idx, &length, sz) < 0) {\n            WOLFSSL_MSG(\"\\tfail: should be a SEQUENCE\");\n            return ASN_PARSE_E;\n        }\n\n        oid = 0;\n        if (GetObjectId(buf, &idx, &oid, oidCrlExtType, sz) < 0) {\n            WOLFSSL_MSG(\"\\tfail: OBJECT ID\");\n            return ASN_PARSE_E;\n        }\n\n        /* check for critical flag */\n        if ((idx + 1) > (word32)sz) {\n            WOLFSSL_MSG(\"\\tfail: malformed buffer\");\n            return BUFFER_E;\n        }\n\n        localIdx = idx;\n        if (GetASNTag(buf, &localIdx, &tag, sz) == 0 && tag == ASN_BOOLEAN) {\n            WOLFSSL_MSG(\"\\tfound optional critical flag, moving past\");\n            ret = GetBoolean(buf, &idx, sz);\n            if (ret < 0)\n                return ret;\n        }\n\n        ret = GetOctetString(buf, &idx, &length, sz);\n        if (ret < 0)\n            return ret;\n\n        if (oid == AUTH_KEY_OID) {\n        #ifndef NO_SKID\n            ret = ParseCRL_AuthKeyIdExt(buf + idx, length, dcrl);\n            if (ret < 0) {\n                WOLFSSL_MSG(\"\\tcouldn't parse AuthKeyId extension\");\n                return ret;\n            }\n        #endif\n        }\n\n        idx += length;\n    }\n\n    *inOutIdx = idx;\n\n    return 0;\n}\n\n\n/* parse crl buffer into decoded state, 0 on success */\nint ParseCRL(DecodedCRL* dcrl, const byte* buff, word32 sz, void* cm)\n{\n    int          len;\n    word32       idx = 0;\n    Signer*      ca = NULL;\n    SignatureCtx sigCtx;\n\n    WOLFSSL_MSG(\"ParseCRL\");\n\n    /* raw crl hash */\n    /* hash here if needed for optimized comparisons\n     * wc_Sha sha;\n     * wc_InitSha(&sha);\n     * wc_ShaUpdate(&sha, buff, sz);\n     * wc_ShaFinal(&sha, dcrl->crlHash); */\n\n    if (GetSequence(buff, &idx, &len, sz) < 0)\n        return ASN_PARSE_E;\n\n    dcrl->certBegin = idx;\n    /* Normalize sz for the length inside the outer sequence. */\n    sz = len + idx;\n\n    if (GetSequence(buff, &idx, &len, sz) < 0)\n        return ASN_PARSE_E;\n    dcrl->sigIndex = len + idx;\n\n    if (ParseCRL_CertList(dcrl, buff, &idx, dcrl->sigIndex) < 0)\n        return ASN_PARSE_E;\n\n    if (ParseCRL_Extensions(dcrl, buff, &idx, dcrl->sigIndex) < 0)\n        return ASN_PARSE_E;\n\n    idx = dcrl->sigIndex;\n\n    if (GetAlgoId(buff, &idx, &dcrl->signatureOID, oidSigType, sz) < 0)\n        return ASN_PARSE_E;\n\n    if (GetCRL_Signature(buff, &idx, dcrl, sz) < 0)\n        return ASN_PARSE_E;\n\n    /* openssl doesn't add skid by default for CRLs cause firefox chokes\n       if experiencing issues uncomment NO_SKID define in CRL section of\n       wolfssl/wolfcrypt/settings.h */\n#ifndef NO_SKID\n    if (dcrl->extAuthKeyIdSet) {\n        ca = GetCA(cm, dcrl->extAuthKeyId); /* more unique than issuerHash */\n    }\n    if (ca != NULL && XMEMCMP(dcrl->issuerHash, ca->subjectNameHash,\n                KEYID_SIZE) != 0) {\n        ca = NULL;\n    }\n    if (ca == NULL) {\n        ca = GetCAByName(cm, dcrl->issuerHash); /* last resort */\n        /* If AKID is available then this CA doesn't have the public\n         * key required */\n        if (ca && dcrl->extAuthKeyIdSet) {\n            WOLFSSL_MSG(\"CA SKID doesn't match AKID\");\n            ca = NULL;\n        }\n    }\n#else\n    ca = GetCA(cm, dcrl->issuerHash);\n#endif /* !NO_SKID */\n    WOLFSSL_MSG(\"About to verify CRL signature\");\n\n    if (ca == NULL) {\n        WOLFSSL_MSG(\"Did NOT find CRL issuer CA\");\n        return ASN_CRL_NO_SIGNER_E;\n    }\n\n    WOLFSSL_MSG(\"Found CRL issuer CA\");\n    return VerifyCRL_Signature(&sigCtx, buff + dcrl->certBegin,\n           dcrl->sigIndex - dcrl->certBegin, dcrl->signature, dcrl->sigLength,\n           dcrl->signatureOID, ca, dcrl->heap);\n}\n\n#endif /* HAVE_CRL */\n\n\n\n#ifdef WOLFSSL_CERT_PIV\n\nint wc_ParseCertPIV(wc_CertPIV* piv, const byte* buf, word32 totalSz)\n{\n    int length = 0;\n    word32 idx = 0;\n\n    WOLFSSL_ENTER(\"wc_ParseCertPIV\");\n\n    if (piv == NULL || buf == NULL || totalSz == 0)\n        return BAD_FUNC_ARG;\n\n    XMEMSET(piv, 0, sizeof(wc_CertPIV));\n\n    /* Detect Identiv PIV (with 0x0A, 0x0B and 0x0C sections) */\n    /* Certificate (0A 82 05FA) */\n    if (GetASNHeader(buf, ASN_PIV_CERT, &idx, &length, totalSz) >= 0) {\n        /* Identiv Type PIV card */\n        piv->isIdentiv = 1;\n\n        piv->cert =   &buf[idx];\n        piv->certSz = length;\n        idx += length;\n\n        /* Nonce (0B 14) */\n        if (GetASNHeader(buf, ASN_PIV_NONCE, &idx, &length, totalSz) >= 0) {\n            piv->nonce =   &buf[idx];\n            piv->nonceSz = length;\n            idx += length;\n        }\n\n        /* Signed Nonce (0C 82 0100) */\n        if (GetASNHeader(buf, ASN_PIV_SIGNED_NONCE, &idx, &length, totalSz) >= 0) {\n            piv->signedNonce =   &buf[idx];\n            piv->signedNonceSz = length;\n        }\n\n        idx = 0;\n        buf = piv->cert;\n        totalSz = piv->certSz;\n    }\n\n    /* Certificate Buffer Total Size (53 82 05F6) */\n    if (GetASNHeader(buf, ASN_APPLICATION | ASN_PRINTABLE_STRING, &idx,\n                                                   &length, totalSz) < 0) {\n        return ASN_PARSE_E;\n    }\n    /* PIV Certificate (70 82 05ED) */\n    if (GetASNHeader(buf, ASN_PIV_TAG_CERT, &idx, &length,\n                                                         totalSz) < 0) {\n        return ASN_PARSE_E;\n    }\n\n    /* Capture certificate buffer pointer and length */\n    piv->cert =   &buf[idx];\n    piv->certSz = length;\n    idx += length;\n\n    /* PIV Certificate Info (71 01 00) */\n    if (GetASNHeader(buf, ASN_PIV_TAG_CERT_INFO, &idx, &length,\n                                                        totalSz) >= 0) {\n        if (length >= 1) {\n            piv->compression = (buf[idx] & ASN_PIV_CERT_INFO_COMPRESSED);\n            piv->isX509 =      (buf[idx] & ASN_PIV_CERT_INFO_ISX509);\n        }\n        idx += length;\n    }\n\n    /* PIV Error Detection (FE 00) */\n    if (GetASNHeader(buf, ASN_PIV_TAG_ERR_DET, &idx, &length,\n                                                        totalSz) >= 0) {\n        piv->certErrDet =   &buf[idx];\n        piv->certErrDetSz = length;\n        idx += length;\n    }\n\n    return 0;\n}\n\n#endif /* WOLFSSL_CERT_PIV */\n\n\n\n#ifdef HAVE_SMIME\n\n/*****************************************************************************\n* wc_MIME_parse_headers - Reads the char array in and parses out MIME headers\n* and parameters into headers.  Will continue until in has no more content.\n*\n* RETURNS:\n* returns zero on success, non-zero on error.\n*/\nint wc_MIME_parse_headers(char* in, int inLen, MimeHdr** headers)\n{\n    MimeHdr* nextHdr = NULL;\n    MimeHdr* curHdr = NULL;\n    MimeParam* nextParam = NULL;\n    size_t start = 0;\n    size_t end = 0;\n    char* nameAttr = NULL;\n    char* bodyVal = NULL;\n    MimeTypes mimeType = MIME_HDR;\n    MimeStatus mimeStatus = MIME_NAMEATTR;\n    int ret = -1;\n    size_t pos = 0;\n    size_t lineLen = 0;\n    char* curLine = NULL;\n    char* ptr = NULL;\n\n    if (in == NULL || inLen <= 0 || in[inLen] != '\\0' || headers == NULL) {\n        ret = BAD_FUNC_ARG;\n        goto error;\n    }\n    nextHdr = (MimeHdr*)XMALLOC(sizeof(MimeHdr), NULL, DYNAMIC_TYPE_PKCS7);\n    nextParam = (MimeParam*)XMALLOC(sizeof(MimeParam), NULL,\n                                    DYNAMIC_TYPE_PKCS7);\n    if (nextHdr == NULL || nextParam == NULL) {\n        ret = MEMORY_E;\n        goto error;\n    }\n    XMEMSET(nextHdr, 0, (word32)sizeof(MimeHdr));\n    XMEMSET(nextParam, 0, (word32)sizeof(MimeParam));\n\n    curLine = XSTRTOK(in, \"\\r\\n\", &ptr);\n    if (curLine == NULL) {\n        ret = ASN_PARSE_E;\n        goto error;\n    }\n\n    while (curLine != NULL) {\n        /* Leftover from previous line, add params to previous header. */\n        if (curLine[0] == ' ' && curHdr) {\n            mimeType = MIME_PARAM;\n        }\n        else {\n            mimeType = MIME_HDR;\n        }\n        start = 0;\n        lineLen = XSTRLEN(curLine);\n        if (lineLen == 0) {\n            ret = BAD_FUNC_ARG;\n            goto error;\n        }\n\n        for (pos = 0; pos < lineLen; pos++) {\n            char cur = curLine[pos];\n\n            if (mimeStatus == MIME_NAMEATTR && ((cur == ':' &&\n                mimeType == MIME_HDR) || (cur == '=' &&\n                mimeType == MIME_PARAM)) && pos >= 1) {\n                mimeStatus = MIME_BODYVAL;\n                end = pos-1;\n                ret = wc_MIME_header_strip(curLine, &nameAttr, start, end);\n                if (ret) {\n                    goto error;\n                }\n                start = pos+1;\n            }\n            else if (mimeStatus == MIME_BODYVAL && cur == ';' && pos >= 1) {\n                end = pos-1;\n                ret = wc_MIME_header_strip(curLine, &bodyVal, start, end);\n                if (ret) {\n                    goto error;\n                }\n                if (mimeType == MIME_HDR) {\n                    nextHdr->name = nameAttr;\n                    nameAttr = NULL;\n                    nextHdr->body = bodyVal;\n                    bodyVal = NULL;\n                    nextHdr->next = curHdr;\n                    curHdr = nextHdr;\n                    nextHdr = (MimeHdr*)XMALLOC(sizeof(MimeHdr), NULL,\n                                                DYNAMIC_TYPE_PKCS7);\n                    if (nextHdr == NULL) {\n                        ret = MEMORY_E;\n                        goto error;\n                    }\n                    XMEMSET(nextHdr, 0, (word32)sizeof(MimeHdr));\n                }\n                else {\n                    nextParam->attribute = nameAttr;\n                    nameAttr = NULL;\n                    nextParam->value = bodyVal;\n                    bodyVal = NULL;\n                    nextParam->next = curHdr->params;\n                    curHdr->params = nextParam;\n                    nextParam = (MimeParam*)XMALLOC(sizeof(MimeParam), NULL,\n                                                    DYNAMIC_TYPE_PKCS7);\n                    if (nextParam == NULL) {\n                        ret = MEMORY_E;\n                        goto error;\n                    }\n                    XMEMSET(nextParam, 0, (word32)sizeof(MimeParam));\n                }\n                mimeType = MIME_PARAM;\n                mimeStatus = MIME_NAMEATTR;\n                start = pos+1;\n            }\n        }\n\n        end = lineLen-1;\n        /* Omit newline characters. */\n        while ((curLine[end] == '\\r' || curLine[end] == '\\n') && end > 0) {\n            end--;\n        }\n        if (end >= start && mimeStatus == MIME_BODYVAL) {\n            ret = wc_MIME_header_strip(curLine, &bodyVal, start, end);\n            if (ret) {\n                goto error;\n            }\n            if (mimeType == MIME_HDR) {\n                nextHdr->name = nameAttr;\n                nameAttr = NULL;\n                nextHdr->body = bodyVal;\n                bodyVal = NULL;\n                nextHdr->next = curHdr;\n                curHdr = nextHdr;\n                nextHdr = (MimeHdr*)XMALLOC(sizeof(MimeHdr), NULL,\n                                            DYNAMIC_TYPE_PKCS7);\n                if (nextHdr == NULL) {\n                    ret = MEMORY_E;\n                    goto error;\n                }\n                XMEMSET(nextHdr, 0, (word32)sizeof(MimeHdr));\n            } else {\n                nextParam->attribute = nameAttr;\n                nameAttr = NULL;\n                nextParam->value = bodyVal;\n                bodyVal = NULL;\n                nextParam->next = curHdr->params;\n                curHdr->params = nextParam;\n                nextParam = (MimeParam*)XMALLOC(sizeof(MimeParam), NULL,\n                                                DYNAMIC_TYPE_PKCS7);\n                if (nextParam == NULL) {\n                    ret = MEMORY_E;\n                    goto error;\n                }\n                XMEMSET(nextParam, 0, (word32)sizeof(MimeParam));\n            }\n        }\n\n        curLine = XSTRTOK(NULL, \"\\r\\n\", &ptr);\n        mimeStatus = MIME_NAMEATTR;\n    }\n\n    *headers = curHdr;\n    ret = 0; /* success if at this point */\n\nerror:\n    if (ret != 0)\n        wc_MIME_free_hdrs(curHdr);\n    wc_MIME_free_hdrs(nextHdr);\n    if (nameAttr != NULL)\n        XFREE(nameAttr, NULL, DYNAMIC_TYPE_PKCS7);\n    if (bodyVal != NULL)\n        XFREE(bodyVal, NULL, DYNAMIC_TYPE_PKCS7);\n    XFREE(nextParam, NULL, DYNAMIC_TYPE_PKCS7);\n\n    return ret;\n}\n\n/*****************************************************************************\n* wc_MIME_header_strip - Reads the string in from indices start to end, strips\n* out disallowed/separator characters and places the rest into *out.\n*\n* RETURNS:\n* returns zero on success, non-zero on error.\n*/\nint wc_MIME_header_strip(char* in, char** out, size_t start, size_t end)\n{\n    size_t inPos = start;\n    size_t outPos = 0;\n    size_t inLen = 0;\n\n    if (end < start || in == NULL || out == NULL) {\n        return BAD_FUNC_ARG;\n    }\n\n    inLen = XSTRLEN(in);\n    if (start > inLen || end > inLen) {\n        return BAD_FUNC_ARG;\n    }\n\n    *out = (char*)XMALLOC(((end-start)+2)*sizeof(char), NULL,\n                          DYNAMIC_TYPE_PKCS7);\n    if (*out == NULL) {\n        return MEMORY_E;\n    }\n\n    while (inPos <= end) {\n        if (in[inPos] >= MIME_HEADER_ASCII_MIN && in[inPos] <=\n            MIME_HEADER_ASCII_MAX && in[inPos] != ';' && in[inPos] != '\\\"') {\n            (*out)[outPos] = in[inPos];\n            outPos++;\n        }\n        inPos++;\n    }\n    (*out)[outPos] = '\\0';\n\n    return 0;\n}\n\n/*****************************************************************************\n* wc_MIME_find_header_name - Searches through all given headers until a header with\n* a name matching the provided name is found.\n*\n* RETURNS:\n* returns a pointer to the found header, if no match was found, returns NULL.\n*/\nMimeHdr* wc_MIME_find_header_name(const char* name, MimeHdr* header)\n{\n    size_t len = XSTRLEN(name);\n\n    while (header) {\n        if (!XSTRNCMP(name, header->name, len)) {\n            return header;\n        }\n        header = header->next;\n    }\n\n    return header;\n}\n\n/*****************************************************************************\n* wc_MIME_find_param_attr - Searches through all parameters until a parameter\n* with a attribute matching the provided attribute is found.\n*\n* RETURNS:\n* returns a pointer to the found parameter, if no match was found,\n* returns NULL.\n*/\nMimeParam* wc_MIME_find_param_attr(const char* attribute,\n                                    MimeParam* param)\n{\n    size_t len = XSTRLEN(attribute);\n\n    while (param) {\n        if (!XSTRNCMP(attribute, param->attribute, len)) {\n            return param;\n        }\n        param = param->next;\n    }\n\n    return param;\n}\n\n/*****************************************************************************\n* wc_MIME_canonicalize - Canonicalize a line by converting all line endings\n* to CRLF.\n*\n* RETURNS:\n* returns a pointer to a canonicalized line on success, NULL on error.\n*/\nchar* wc_MIME_canonicalize(const char* line)\n{\n    size_t end = 0;\n    char* canonLine = NULL;\n\n    if (line == NULL || XSTRLEN(line) == 0) {\n        return NULL;\n    }\n\n    end = XSTRLEN(line);\n    while (end >= 1 && ((line[end-1] == '\\r') || (line[end-1] == '\\n'))) {\n        end--;\n    }\n\n    /* Need 2 chars for \\r\\n and 1 for EOL */\n    canonLine = (char*)XMALLOC((end+3)*sizeof(char), NULL, DYNAMIC_TYPE_PKCS7);\n    if (canonLine == NULL) {\n        return NULL;\n    }\n\n    XSTRNCPY(canonLine, line, end);\n    canonLine[end] = '\\r';\n    canonLine[end+1] = '\\n';\n    canonLine[end+2] = '\\0';\n\n    return canonLine;\n}\n\n/*****************************************************************************\n* wc_MIME_free_hdrs - Frees all MIME headers, parameters and strings starting from\n* the provided header pointer.\n*\n* RETURNS:\n* returns zero on success, non-zero on error.\n*/\nint wc_MIME_free_hdrs(MimeHdr* head)\n{\n    MimeHdr* curHdr = NULL;\n    MimeParam* curParam = NULL;\n\n    while (head) {\n        while (head->params) {\n            curParam = head->params;\n            head->params = head->params->next;\n            XFREE(curParam->attribute, NULL, DYNAMIC_TYPE_PKCS7);\n            XFREE(curParam->value, NULL, DYNAMIC_TYPE_PKCS7);\n            XFREE(curParam, NULL, DYNAMIC_TYPE_PKCS7);\n        }\n        curHdr = head;\n        head = head->next;\n        XFREE(curHdr->name, NULL, DYNAMIC_TYPE_PKCS7);\n        XFREE(curHdr->body, NULL, DYNAMIC_TYPE_PKCS7);\n        XFREE(curHdr, NULL, DYNAMIC_TYPE_PKCS7);\n    }\n\n    return 0;\n}\n\n#endif /* HAVE_SMIME */\n\n\n#undef ERROR_OUT\n\n#endif /* !NO_ASN */\n\n#ifdef WOLFSSL_SEP\n\n\n#endif /* WOLFSSL_SEP */\n", "/* asn.h\n *\n * Copyright (C) 2006-2021 wolfSSL Inc.\n *\n * This file is part of wolfSSL.\n *\n * wolfSSL is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * wolfSSL is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1335, USA\n */\n\n/*!\n    \\file wolfssl/wolfcrypt/asn.h\n*/\n\n/*\n\nDESCRIPTION\nThis library provides the interface to Abstract Syntax Notation One (ASN.1) objects.\nASN.1 is a standard interface description language for defining data structures\nthat can be serialized and deserialized in a cross-platform way.\n\n*/\n#ifndef WOLF_CRYPT_ASN_H\n#define WOLF_CRYPT_ASN_H\n\n#include <wolfssl/wolfcrypt/types.h>\n\n#ifndef NO_ASN\n\n\n#if !defined(NO_ASN_TIME) && defined(NO_TIME_H)\n    #define NO_ASN_TIME /* backwards compatibility with NO_TIME_H */\n#endif\n\n#include <wolfssl/wolfcrypt/integer.h>\n\n/* fips declare of RsaPrivateKeyDecode @wc_fips */\n#if defined(HAVE_FIPS) && !defined(NO_RSA) && \\\n\t(!defined(HAVE_FIPS_VERSION) || (HAVE_FIPS_VERSION < 2))\n    #include <cyassl/ctaocrypt/rsa.h>\n#endif\n\n#ifndef NO_DH\n    #include <wolfssl/wolfcrypt/dh.h>\n#endif\n#ifndef NO_DSA\n    #include <wolfssl/wolfcrypt/dsa.h>\n#endif\n#ifndef NO_SHA\n    #include <wolfssl/wolfcrypt/sha.h>\n#endif\n#ifndef NO_MD5\n    #include <wolfssl/wolfcrypt/md5.h>\n#endif\n#include <wolfssl/wolfcrypt/sha256.h>\n#include <wolfssl/wolfcrypt/asn_public.h>   /* public interface */\n\n#if defined(NO_SHA) && defined(NO_SHA256)\n    #define WC_SHA256_DIGEST_SIZE 32\n#endif\n\n#ifdef __cplusplus\n    extern \"C\" {\n#endif\n\n#ifndef EXTERNAL_SERIAL_SIZE\n    #define EXTERNAL_SERIAL_SIZE 32\n#endif\n\nenum {\n    ISSUER  = 0,\n    SUBJECT = 1,\n\n    BEFORE  = 0,\n    AFTER   = 1\n};\n\n/* ASN Tags   */\nenum ASN_Tags {\n    ASN_EOC               = 0x00,\n    ASN_BOOLEAN           = 0x01,\n    ASN_INTEGER           = 0x02,\n    ASN_BIT_STRING        = 0x03,\n    ASN_OCTET_STRING      = 0x04,\n    ASN_TAG_NULL          = 0x05,\n    ASN_OBJECT_ID         = 0x06,\n    ASN_ENUMERATED        = 0x0a,\n    ASN_UTF8STRING        = 0x0c,\n    ASN_SEQUENCE          = 0x10,\n    ASN_SET               = 0x11,\n    ASN_PRINTABLE_STRING  = 0x13,\n    ASN_IA5_STRING        = 0x16,\n    ASN_UTC_TIME          = 0x17,\n    ASN_OTHER_TYPE        = 0x00,\n    ASN_RFC822_TYPE       = 0x01,\n    ASN_DNS_TYPE          = 0x02,\n    ASN_DIR_TYPE          = 0x04,\n    ASN_URI_TYPE          = 0x06, /* the value 6 is from GeneralName OID */\n    ASN_IP_TYPE           = 0x07, /* the value 7 is from GeneralName OID */\n    ASN_GENERALIZED_TIME  = 0x18,\n    CRL_EXTENSIONS        = 0xa0,\n    ASN_EXTENSIONS        = 0xa3,\n    ASN_LONG_LENGTH       = 0x80,\n    ASN_INDEF_LENGTH      = 0x80,\n\n    /* ASN_Flags - Bitmask */\n    ASN_CONSTRUCTED       = 0x20,\n    ASN_APPLICATION       = 0x40,\n    ASN_CONTEXT_SPECIFIC  = 0x80,\n};\n\n#define ASN_UTC_TIME_SIZE 14\n#define ASN_GENERALIZED_TIME_SIZE 16\n#define ASN_GENERALIZED_TIME_MAX 68\n\nenum DN_Tags {\n    ASN_DN_NULL       = 0x00,\n    ASN_COMMON_NAME   = 0x03,   /* CN */\n    ASN_SUR_NAME      = 0x04,   /* SN */\n    ASN_SERIAL_NUMBER = 0x05,   /* serialNumber */\n    ASN_COUNTRY_NAME  = 0x06,   /* C  */\n    ASN_LOCALITY_NAME = 0x07,   /* L  */\n    ASN_STATE_NAME    = 0x08,   /* ST */\n    ASN_ORG_NAME      = 0x0a,   /* O  */\n    ASN_ORGUNIT_NAME  = 0x0b,   /* OU */\n    ASN_BUS_CAT       = 0x0f,   /* businessCategory */\n    ASN_EMAIL_NAME    = 0x98,   /* not oid number there is 97 in 2.5.4.0-97 */\n\n    /* pilot attribute types\n     * OID values of 0.9.2342.19200300.100.1.* */\n    ASN_USER_ID          = 0x01, /* UID */\n    ASN_FAVOURITE_DRINK  = 0x05, /* favouriteDrink */\n    ASN_DOMAIN_COMPONENT = 0x19  /* DC */\n};\n\n/* This is the size of the smallest possible PEM header and footer */\nextern const int pem_struct_min_sz;\n\n#if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)\ntypedef struct WOLFSSL_ObjectInfo {\n    int nid;\n    int id;\n    word32 type;\n    const char* sName;\n    const char* lName;\n} WOLFSSL_ObjectInfo;\nextern const size_t wolfssl_object_info_sz;\nextern const WOLFSSL_ObjectInfo wolfssl_object_info[];\n#endif /* defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL) */\n\n/* DN Tag Strings */\n#define WOLFSSL_COMMON_NAME      \"/CN=\"\n#define WOLFSSL_LN_COMMON_NAME   \"/commonName=\"\n#define WOLFSSL_SUR_NAME         \"/SN=\"\n#define WOLFSSL_SERIAL_NUMBER    \"/serialNumber=\"\n#define WOLFSSL_COUNTRY_NAME     \"/C=\"\n#define WOLFSSL_LN_COUNTRY_NAME  \"/countryName=\"\n#define WOLFSSL_LOCALITY_NAME    \"/L=\"\n#define WOLFSSL_LN_LOCALITY_NAME \"/localityName=\"\n#define WOLFSSL_STATE_NAME       \"/ST=\"\n#define WOLFSSL_LN_STATE_NAME    \"/stateOrProvinceName=\"\n#define WOLFSSL_ORG_NAME         \"/O=\"\n#define WOLFSSL_LN_ORG_NAME      \"/organizationName=\"\n#define WOLFSSL_ORGUNIT_NAME     \"/OU=\"\n#define WOLFSSL_LN_ORGUNIT_NAME  \"/organizationalUnitName=\"\n#define WOLFSSL_DOMAIN_COMPONENT \"/DC=\"\n#define WOLFSSL_LN_DOMAIN_COMPONENT \"/domainComponent=\"\n#define WOLFSSL_BUS_CAT          \"/businessCategory=\"\n#define WOLFSSL_JOI_C            \"/jurisdictionC=\"\n#define WOLFSSL_JOI_ST           \"/jurisdictionST=\"\n#define WOLFSSL_EMAIL_ADDR       \"/emailAddress=\"\n\n#define WOLFSSL_USER_ID          \"/UID=\"\n#define WOLFSSL_DOMAIN_COMPONENT \"/DC=\"\n#define WOLFSSL_FAVOURITE_DRINK  \"/favouriteDrink=\"\n\n#if defined(WOLFSSL_APACHE_HTTPD)\n    /* otherName strings */\n    #define WOLFSSL_SN_MS_UPN       \"msUPN\"\n    #define WOLFSSL_LN_MS_UPN       \"Microsoft User Principal Name\"\n    #define WOLFSSL_MS_UPN_SUM 265\n    #define WOLFSSL_SN_DNS_SRV      \"id-on-dnsSRV\"\n    #define WOLFSSL_LN_DNS_SRV      \"SRVName\"\n    /* TLS features extension strings */\n    #define WOLFSSL_SN_TLS_FEATURE  \"tlsfeature\"\n    #define WOLFSSL_LN_TLS_FEATURE  \"TLS Feature\"\n    #define WOLFSSL_TLS_FEATURE_SUM 92\n#endif\n\n#if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)\n/* NIDs */\nenum\n{\n    NID_undef = 0,\n    NID_netscape_cert_type = NID_undef,\n    NID_des = 66,\n    NID_des3 = 67,\n    NID_sha256 = 672,\n    NID_sha384 = 673,\n    NID_sha512 = 674,\n    NID_pkcs9_challengePassword = 54,\n    NID_hw_name_oid = 73,\n    NID_id_pkix_OCSP_basic = 74,\n    NID_any_policy = 75,\n    NID_anyExtendedKeyUsage = 76,\n    NID_givenName = 99,\n    NID_initials = 101,\n    NID_title = 106,\n    NID_description = 107,\n    NID_basic_constraints = 133,\n    NID_key_usage = 129,     /* 2.5.29.15 */\n    NID_ext_key_usage = 151, /* 2.5.29.37 */\n    NID_subject_key_identifier = 128,\n    NID_authority_key_identifier = 149,\n    NID_private_key_usage_period = 130, /* 2.5.29.16 */\n    NID_subject_alt_name = 131,\n    NID_issuer_alt_name = 132,\n    NID_info_access = 69,\n    NID_sinfo_access = 79,      /* id-pe 11 */\n    NID_name_constraints = 144, /* 2.5.29.30 */\n    NID_crl_distribution_points = 145, /* 2.5.29.31 */\n    NID_certificate_policies = 146,\n    NID_policy_mappings = 147,\n    NID_policy_constraints = 150,\n    NID_inhibit_any_policy = 168,      /* 2.5.29.54 */\n    NID_tlsfeature = 1020,             /* id-pe 24 */\n    NID_commonName = 0x03,             /* matches ASN_COMMON_NAME in asn.h */\n    NID_buildingName = 1494,\n\n\n    NID_surname = 0x04,                /* SN */\n    NID_serialNumber = 0x05,           /* serialNumber */\n    NID_countryName = 0x06,            /* C  */\n    NID_localityName = 0x07,           /* L  */\n    NID_stateOrProvinceName = 0x08,    /* ST */\n    NID_organizationName = 0x0a,       /* O  */\n    NID_organizationalUnitName = 0x0b, /* OU */\n    NID_jurisdictionCountryName = 0xc,\n    NID_jurisdictionStateOrProvinceName = 0xd,\n    NID_businessCategory = ASN_BUS_CAT,\n    NID_domainComponent = ASN_DOMAIN_COMPONENT,\n    NID_favouriteDrink = 462,\n    NID_userId = 458,\n    NID_emailAddress = 0x30,           /* emailAddress */\n    NID_id_on_dnsSRV = 82,             /* 1.3.6.1.5.5.7.8.7 */\n    NID_ms_upn = 265,                  /* 1.3.6.1.4.1.311.20.2.3 */\n\n    NID_X9_62_prime_field = 406        /* 1.2.840.10045.1.1 */\n};\n#endif /* OPENSSL_EXTRA */\n\nenum ECC_TYPES\n{\n    ECC_PREFIX_0 = 160,\n    ECC_PREFIX_1 = 161\n};\n\n#ifdef WOLFSSL_CERT_PIV\n    enum PIV_Tags {\n        ASN_PIV_CERT          = 0x0A,\n        ASN_PIV_NONCE         = 0x0B,\n        ASN_PIV_SIGNED_NONCE  = 0x0C,\n\n        ASN_PIV_TAG_CERT      = 0x70,\n        ASN_PIV_TAG_CERT_INFO = 0x71,\n        ASN_PIV_TAG_MSCUID    = 0x72,\n        ASN_PIV_TAG_ERR_DET   = 0xFE,\n\n        /* certificate info masks */\n        ASN_PIV_CERT_INFO_COMPRESSED = 0x03,\n        ASN_PIV_CERT_INFO_ISX509     = 0x04,\n    };\n#endif /* WOLFSSL_CERT_PIV */\n\n\n#define ASN_JOI_PREFIX_SZ       10\n#define ASN_JOI_PREFIX          \"\\x2b\\x06\\x01\\x04\\x01\\x82\\x37\\x3c\\x02\\x01\"\n#define ASN_JOI_C               0x3\n#define ASN_JOI_ST              0x2\n\n#ifndef WC_ASN_NAME_MAX\n    #ifdef OPENSSL_EXTRA\n        #define WC_ASN_NAME_MAX 300\n    #else\n        #define WC_ASN_NAME_MAX 256\n    #endif\n#endif\n#define ASN_NAME_MAX WC_ASN_NAME_MAX\n\nenum Misc_ASN {\n    MAX_SALT_SIZE       =  64,     /* MAX PKCS Salt length */\n    MAX_IV_SIZE         =  64,     /* MAX PKCS Iv length */\n    ASN_BOOL_SIZE       =   2,     /* including type */\n    ASN_ECC_HEADER_SZ   =   2,     /* String type + 1 byte len */\n    ASN_ECC_CONTEXT_SZ  =   2,     /* Content specific type + 1 byte len */\n#ifdef NO_SHA\n    KEYID_SIZE          = WC_SHA256_DIGEST_SIZE,\n#else\n    KEYID_SIZE          = WC_SHA_DIGEST_SIZE,\n#endif\n    RSA_INTS            =   8,     /* RSA ints in private key */\n    DSA_PARAM_INTS      =   3,     /* DSA paramater ints */\n    DSA_INTS            =   5,     /* DSA ints in private key */\n    MIN_DATE_SIZE       =  12,\n    MAX_DATE_SIZE       =  32,\n    ASN_GEN_TIME_SZ     =  15,     /* 7 numbers * 2 + Zulu tag */\n#ifndef NO_RSA\n#ifdef WOLFSSL_HAPROXY\n    MAX_ENCODED_SIG_SZ  = 1024,    /* Supports 8192 bit keys */\n#else\n    MAX_ENCODED_SIG_SZ  = 512,     /* Supports 4096 bit keys */\n#endif\n#elif defined(HAVE_ECC)\n    MAX_ENCODED_SIG_SZ  = 140,\n#elif defined(HAVE_CURVE448)\n    MAX_ENCODED_SIG_SZ  = 114,\n#else\n    MAX_ENCODED_SIG_SZ  =  64,\n#endif\n    MAX_SIG_SZ          = 256,\n    MAX_ALGO_SZ         =  20,\n    MAX_SHORT_SZ        =   6,     /* asn int + byte len + 4 byte length */\n    MAX_SEQ_SZ          =   5,     /* enum(seq | con) + length(4) */\n    MAX_SET_SZ          =   5,     /* enum(set | con) + length(4) */\n    MAX_OCTET_STR_SZ    =   5,     /* enum(set | con) + length(4) */\n    MAX_EXP_SZ          =   5,     /* enum(contextspec|con|exp) + length(4) */\n    MAX_PRSTR_SZ        =   5,     /* enum(prstr) + length(4) */\n    MAX_VERSION_SZ      =   5,     /* enum + id + version(byte) + (header(2))*/\n    MAX_ENCODED_DIG_ASN_SZ= 9,     /* enum(bit or octet) + length(4) */\n    MAX_ENCODED_DIG_SZ  =  64 + MAX_ENCODED_DIG_ASN_SZ, /* asn header + sha512 */\n    MAX_RSA_INT_SZ      = 517,     /* RSA raw sz 4096 for bits + tag + len(4) */\n    MAX_DSA_INT_SZ      = 389,     /* DSA raw sz 3072 for bits + tag + len(4) */\n    MAX_NTRU_KEY_SZ     = 610,     /* NTRU 112 bit public key */\n    MAX_NTRU_ENC_SZ     = 628,     /* NTRU 112 bit DER public encoding */\n    MAX_LENGTH_SZ       =   4,     /* Max length size for DER encoding */\n    MAX_RSA_E_SZ        =  16,     /* Max RSA public e size */\n    MAX_CA_SZ           =  32,     /* Max encoded CA basic constraint length */\n    MAX_SN_SZ           =  35,     /* Max encoded serial number (INT) length */\n    MAX_DER_DIGEST_SZ     = MAX_ENCODED_DIG_SZ + MAX_ALGO_SZ + MAX_SEQ_SZ,\n                            /* Maximum DER digest size */\n    MAX_DER_DIGEST_ASN_SZ = MAX_ENCODED_DIG_ASN_SZ + MAX_ALGO_SZ + MAX_SEQ_SZ,\n                            /* Maximum DER digest ASN header size */\n                            /* Max X509 header length indicates the max length + 2 ('\\n', '\\0') */\n    MAX_X509_HEADER_SZ  = (37 + 2), /* Maximum PEM Header/Footer Size */\n#ifdef WOLFSSL_CERT_GEN\n    #ifdef WOLFSSL_CERT_REQ\n                          /* Max encoded cert req attributes length */\n        MAX_ATTRIB_SZ   = MAX_SEQ_SZ * 3 + (11 + MAX_SEQ_SZ) * 2 +\n                          MAX_PRSTR_SZ + CTC_NAME_SIZE, /* 11 is the OID size */\n    #endif\n    #if defined(WOLFSSL_ALT_NAMES) || defined(WOLFSSL_CERT_EXT)\n        MAX_EXTENSIONS_SZ   = 1 + MAX_LENGTH_SZ + CTC_MAX_ALT_SIZE,\n    #else\n        MAX_EXTENSIONS_SZ   = 1 + MAX_LENGTH_SZ + MAX_CA_SZ,\n    #endif\n                                   /* Max total extensions, id + len + others */\n#endif\n#if defined(WOLFSSL_CERT_EXT) || defined(OPENSSL_EXTRA) || \\\n        defined(HAVE_PKCS7) || defined(OPENSSL_EXTRA_X509_SMALL)\n    MAX_OID_SZ          = 32,      /* Max DER length of OID*/\n    MAX_OID_STRING_SZ   = 64,      /* Max string length representation of OID*/\n#endif\n#ifdef WOLFSSL_CERT_EXT\n    MAX_KID_SZ          = 45,      /* Max encoded KID length (SHA-256 case) */\n    MAX_KEYUSAGE_SZ     = 18,      /* Max encoded Key Usage length */\n    MAX_EXTKEYUSAGE_SZ  = 12 + (6 * (8 + 2)) +\n                          CTC_MAX_EKU_OID_SZ, /* Max encoded ExtKeyUsage\n                          (SEQ/LEN + OBJID + OCTSTR/LEN + SEQ +\n                          (6 * (SEQ + OID))) */\n    MAX_CERTPOL_NB      = CTC_MAX_CERTPOL_NB,/* Max number of Cert Policy */\n    MAX_CERTPOL_SZ      = CTC_MAX_CERTPOL_SZ,\n#endif\n    MAX_AIA_SZ          = 2,       /* Max Authority Info Access extension size*/\n    OCSP_NONCE_EXT_SZ   = 35,      /* OCSP Nonce Extension size */\n    MAX_OCSP_EXT_SZ     = 58,      /* Max OCSP Extension length */\n    MAX_OCSP_NONCE_SZ   = 16,      /* OCSP Nonce size           */\n    EIGHTK_BUF          = 8192,    /* Tmp buffer size           */\n    MAX_PUBLIC_KEY_SZ   = MAX_NTRU_ENC_SZ + MAX_ALGO_SZ + MAX_SEQ_SZ * 2,\n                                   /* use bigger NTRU size */\n#ifdef WOLFSSL_ENCRYPTED_KEYS\n    HEADER_ENCRYPTED_KEY_SIZE = 88,/* Extra header size for encrypted key */\n#else\n    HEADER_ENCRYPTED_KEY_SIZE = 0,\n#endif\n    TRAILING_ZERO       = 1,       /* Used for size of zero pad */\n    ASN_TAG_SZ          = 1,       /* single byte ASN.1 tag */\n    MIN_VERSION_SZ      = 3,       /* Min bytes needed for GetMyVersion */\n    MAX_X509_VERSION    = 3,       /* Max X509 version allowed */\n    MIN_X509_VERSION    = 0,       /* Min X509 version allowed */\n    WOLFSSL_X509_V1     = 0,\n    WOLFSSL_X509_V2     = 1,\n    WOLFSSL_X509_V3     = 2,\n#if defined(OPENSSL_ALL)  || defined(WOLFSSL_MYSQL_COMPATIBLE) || \\\n    defined(WOLFSSL_NGINX) || defined(WOLFSSL_HAPROXY) || \\\n    defined(OPENSSL_EXTRA) || defined(HAVE_PKCS7)\n    MAX_TIME_STRING_SZ  = 25,      /* Max length of formatted time string */\n#endif\n\n    PKCS5_SALT_SZ       = 8,\n\n    PEM_LINE_SZ        = 64,               /* Length of Base64 encoded line, not including new line */\n    PEM_LINE_LEN       = PEM_LINE_SZ + 12, /* PEM line max + fudge */\n};\n\n#ifndef WC_MAX_NAME_ENTRIES\n    /* entries added to x509 name struct */\n    #define WC_MAX_NAME_ENTRIES 13\n#endif\n#define MAX_NAME_ENTRIES WC_MAX_NAME_ENTRIES\n\n\nenum Oid_Types {\n    oidHashType         = 0,\n    oidSigType          = 1,\n    oidKeyType          = 2,\n    oidCurveType        = 3,\n    oidBlkType          = 4,\n    oidOcspType         = 5,\n    oidCertExtType      = 6,\n    oidCertAuthInfoType = 7,\n    oidCertPolicyType   = 8,\n    oidCertAltNameType  = 9,\n    oidCertKeyUseType   = 10,\n    oidKdfType          = 11,\n    oidKeyWrapType      = 12,\n    oidCmsKeyAgreeType  = 13,\n    oidPBEType          = 14,\n    oidHmacType         = 15,\n    oidCompressType     = 16,\n    oidCertNameType     = 17,\n    oidTlsExtType       = 18,\n    oidCrlExtType       = 19,\n    oidCsrAttrType      = 20,\n    oidIgnoreType\n};\n\n\nenum Hash_Sum  {\n    MD2h      = 646,\n    MD5h      = 649,\n    SHAh      =  88,\n    SHA224h   = 417,\n    SHA256h   = 414,\n    SHA384h   = 415,\n    SHA512h   = 416,\n    SHA3_224h = 420,\n    SHA3_256h = 421,\n    SHA3_384h = 422,\n    SHA3_512h = 423\n};\n\n\n#if !defined(NO_DES3) || !defined(NO_AES)\nenum Block_Sum {\n#ifdef WOLFSSL_AES_128\n    AES128CBCb = 414,\n    AES128GCMb = 418,\n    AES128CCMb = 419,\n#endif\n#ifdef WOLFSSL_AES_192\n    AES192CBCb = 434,\n    AES192GCMb = 438,\n    AES192CCMb = 439,\n#endif\n#ifdef WOLFSSL_AES_256\n    AES256CBCb = 454,\n    AES256GCMb = 458,\n    AES256CCMb = 459,\n#endif\n#ifndef NO_DES3\n    DESb       = 69,\n    DES3b      = 652\n#endif\n};\n#endif /* !NO_DES3 || !NO_AES */\n\n\nenum Key_Sum {\n    DSAk     = 515,\n    RSAk     = 645,\n    NTRUk    = 274,\n    ECDSAk   = 518,\n    ED25519k = 256,\n    ED448k   = 257,\n    DHk      = 647, /* dhKeyAgreement OID: 1.2.840.113549.1.3.1 */\n};\n\n#if !defined(NO_AES) || defined(HAVE_PKCS7)\nenum KeyWrap_Sum {\n#ifdef WOLFSSL_AES_128\n    AES128_WRAP  = 417,\n#endif\n#ifdef WOLFSSL_AES_192\n    AES192_WRAP  = 437,\n#endif\n#ifdef WOLFSSL_AES_256\n    AES256_WRAP  = 457,\n#endif\n#ifdef HAVE_PKCS7\n    PWRI_KEK_WRAP = 680  /*id-alg-PWRI-KEK, 1.2.840.113549.1.9.16.3.9 */\n#endif\n};\n#endif /* !NO_AES || PKCS7 */\n\nenum Key_Agree {\n    dhSinglePass_stdDH_sha1kdf_scheme   = 464,\n    dhSinglePass_stdDH_sha224kdf_scheme = 188,\n    dhSinglePass_stdDH_sha256kdf_scheme = 189,\n    dhSinglePass_stdDH_sha384kdf_scheme = 190,\n    dhSinglePass_stdDH_sha512kdf_scheme = 191,\n};\n\n\n\nenum KDF_Sum {\n    PBKDF2_OID = 660\n};\n\n\nenum HMAC_Sum {\n    HMAC_SHA224_OID   = 652,\n    HMAC_SHA256_OID   = 653,\n    HMAC_SHA384_OID   = 654,\n    HMAC_SHA512_OID   = 655,\n    HMAC_SHA3_224_OID = 426,\n    HMAC_SHA3_256_OID = 427,\n    HMAC_SHA3_384_OID = 428,\n    HMAC_SHA3_512_OID = 429\n};\n\n\nenum Extensions_Sum {\n    BASIC_CA_OID    = 133,           /* 2.5.29.19 */\n    ALT_NAMES_OID   = 131,           /* 2.5.29.17 */\n    CRL_DIST_OID    = 145,           /* 2.5.29.31 */\n    AUTH_INFO_OID   = 69,            /* 1.3.6.1.5.5.7.1.1 */\n    AUTH_KEY_OID    = 149,           /* 2.5.29.35 */\n    SUBJ_KEY_OID    = 128,           /* 2.5.29.14 */\n    CERT_POLICY_OID = 146,           /* 2.5.29.32 */\n    KEY_USAGE_OID   = 129,           /* 2.5.29.15 */\n    INHIBIT_ANY_OID = 168,           /* 2.5.29.54 */\n    EXT_KEY_USAGE_OID         = 151, /* 2.5.29.37 */\n    NAME_CONS_OID             = 144, /* 2.5.29.30 */\n    PRIV_KEY_USAGE_PERIOD_OID = 130, /* 2.5.29.16 */\n    SUBJECT_INFO_ACCESS       = 79,  /* 1.3.6.1.5.5.7.1.11 */\n    POLICY_MAP_OID            = 147, /* 2.5.29.33 */\n    POLICY_CONST_OID          = 150, /* 2.5.29.36 */\n    ISSUE_ALT_NAMES_OID       = 132, /* 2.5.29.18 */\n    TLS_FEATURE_OID           = 92,  /* 1.3.6.1.5.5.7.1.24 */\n    NETSCAPE_CT_OID           = 753, /* 2.16.840.1.113730.1.1 */\n    OCSP_NOCHECK_OID          = 121  /* 1.3.6.1.5.5.7.48.1.5\n                                         id-pkix-ocsp-nocheck */\n};\n\nenum CertificatePolicy_Sum {\n    CP_ANY_OID      = 146  /* id-ce 32 0 */\n};\n\nenum SepHardwareName_Sum {\n    HW_NAME_OID     = 79   /* 1.3.6.1.5.5.7.8.4 from RFC 4108*/\n};\n\nenum AuthInfo_Sum {\n    AIA_OCSP_OID      = 116, /* 1.3.6.1.5.5.7.48.1 */\n    AIA_CA_ISSUER_OID = 117  /* 1.3.6.1.5.5.7.48.2 */\n};\n\nenum ExtKeyUsage_Sum { /* From RFC 5280 */\n    EKU_ANY_OID         = 151, /* 2.5.29.37.0, anyExtendedKeyUsage         */\n    EKU_SERVER_AUTH_OID = 71,  /* 1.3.6.1.5.5.7.3.1, id-kp-serverAuth      */\n    EKU_CLIENT_AUTH_OID = 72,  /* 1.3.6.1.5.5.7.3.2, id-kp-clientAuth      */\n    EKU_CODESIGNING_OID = 73,  /* 1.3.6.1.5.5.7.3.3, id-kp-codeSigning     */\n    EKU_EMAILPROTECT_OID = 74, /* 1.3.6.1.5.5.7.3.4, id-kp-emailProtection */\n    EKU_TIMESTAMP_OID   = 78,  /* 1.3.6.1.5.5.7.3.8, id-kp-timeStamping    */\n    EKU_OCSP_SIGN_OID   = 79   /* 1.3.6.1.5.5.7.3.9, id-kp-OCSPSigning     */\n};\n\n#ifdef HAVE_LIBZ\nenum CompressAlg_Sum {\n    ZLIBc = 679  /* 1.2.840.113549.1.9.16.3.8, id-alg-zlibCompress */\n};\n#endif\n\nenum VerifyType {\n    NO_VERIFY   = 0,\n    VERIFY      = 1,\n    VERIFY_CRL  = 2,\n    VERIFY_OCSP = 3,\n    VERIFY_NAME = 4,\n    VERIFY_SKIP_DATE = 5,\n};\n\n#ifdef WOLFSSL_CERT_EXT\nenum KeyIdType {\n    SKID_TYPE = 0,\n    AKID_TYPE = 1\n};\n#endif\n\n#ifdef WOLFSSL_CERT_REQ\nenum CsrAttrType {\n    CHALLENGE_PASSWORD_OID = 659,\n    SERIAL_NUMBER_OID = 94,\n    EXTENSION_REQUEST_OID = 666,\n};\n#endif\n\n/* Key usage extension bits (based on RFC 5280) */\n#define KEYUSE_DIGITAL_SIG    0x0080\n#define KEYUSE_CONTENT_COMMIT 0x0040\n#define KEYUSE_KEY_ENCIPHER   0x0020\n#define KEYUSE_DATA_ENCIPHER  0x0010\n#define KEYUSE_KEY_AGREE      0x0008\n#define KEYUSE_KEY_CERT_SIGN  0x0004\n#define KEYUSE_CRL_SIGN       0x0002\n#define KEYUSE_ENCIPHER_ONLY  0x0001\n#define KEYUSE_DECIPHER_ONLY  0x8000\n\n/* Extended Key Usage bits (internal mapping only) */\n#define EXTKEYUSE_USER        0x80\n#define EXTKEYUSE_OCSP_SIGN   0x40\n#define EXTKEYUSE_TIMESTAMP   0x20\n#define EXTKEYUSE_EMAILPROT   0x10\n#define EXTKEYUSE_CODESIGN    0x08\n#define EXTKEYUSE_CLIENT_AUTH 0x04\n#define EXTKEYUSE_SERVER_AUTH 0x02\n#define EXTKEYUSE_ANY         0x01\n\ntypedef struct DNS_entry   DNS_entry;\n\nstruct DNS_entry {\n    DNS_entry* next;   /* next on DNS list */\n    int        type;   /* i.e. ASN_DNS_TYPE */\n    int        len;    /* actual DNS len */\n    char*      name;   /* actual DNS name */\n};\n\n\ntypedef struct Base_entry  Base_entry;\n\nstruct Base_entry {\n    Base_entry* next;   /* next on name base list */\n    char*       name;   /* actual name base */\n    int         nameSz; /* name length */\n    byte        type;   /* Name base type (DNS or RFC822) */\n};\n\n\nenum SignatureState {\n    SIG_STATE_BEGIN,\n    SIG_STATE_HASH,\n    SIG_STATE_KEY,\n    SIG_STATE_DO,\n    SIG_STATE_CHECK,\n};\n\n\n#ifdef HAVE_PK_CALLBACKS\n#ifdef HAVE_ECC\n    typedef int (*wc_CallbackEccVerify)(\n           const unsigned char* sig, unsigned int sigSz,\n           const unsigned char* hash, unsigned int hashSz,\n           const unsigned char* keyDer, unsigned int keySz,\n           int* result, void* ctx);\n#endif\n#ifndef NO_RSA\n    typedef int (*wc_CallbackRsaVerify)(\n           unsigned char* sig, unsigned int sigSz,\n           unsigned char** out,\n           const unsigned char* keyDer, unsigned int keySz,\n           void* ctx);\n#endif\n#endif /* HAVE_PK_CALLBACKS */\n\nstruct SignatureCtx {\n    void* heap;\n    byte* digest;\n#ifndef NO_RSA\n    byte* out;\n#endif\n#if !(defined(NO_RSA) && defined(NO_DSA))\n    byte* sigCpy;\n#endif\n#if defined(HAVE_ECC) || defined(HAVE_ED25519) || defined(HAVE_ED448) || \\\n    !defined(NO_DSA)\n    int verify;\n#endif\n    union {\n    #ifndef NO_RSA\n        struct RsaKey*      rsa;\n    #endif\n    #ifndef NO_DSA\n        struct DsaKey*      dsa;\n    #endif\n    #ifdef HAVE_ECC\n        struct ecc_key*     ecc;\n    #endif\n    #ifdef HAVE_ED25519\n        struct ed25519_key* ed25519;\n    #endif\n    #ifdef HAVE_ED448\n        struct ed448_key* ed448;\n    #endif\n        void* ptr;\n    } key;\n    int devId;\n    int state;\n    int typeH;\n    int digestSz;\n    word32 keyOID;\n#ifdef WOLFSSL_ASYNC_CRYPT\n    WC_ASYNC_DEV* asyncDev;\n    void* asyncCtx;\n#endif\n\n#ifdef HAVE_PK_CALLBACKS\n#ifdef HAVE_ECC\n    wc_CallbackEccVerify pkCbEcc;\n    void* pkCtxEcc;\n#endif\n#ifndef NO_RSA\n    wc_CallbackRsaVerify pkCbRsa;\n    void* pkCtxRsa;\n#endif\n#endif /* HAVE_PK_CALLBACKS */\n#ifndef NO_RSA\n#ifdef WOLFSSL_RENESAS_TSIP_TLS\n    byte verifyByTSIP;\n    word32 certBegin;\n    word32 pubkey_n_start;\n    word32 pubkey_n_len;\n    word32 pubkey_e_start;\n    word32 pubkey_e_len;\n#endif\n#endif\n};\n\nenum CertSignState {\n    CERTSIGN_STATE_BEGIN,\n    CERTSIGN_STATE_DIGEST,\n    CERTSIGN_STATE_ENCODE,\n    CERTSIGN_STATE_DO,\n};\n\nstruct CertSignCtx {\n    byte* sig;\n    byte* digest;\n    #ifndef NO_RSA\n        byte* encSig;\n        int encSigSz;\n    #endif\n    int state; /* enum CertSignState */\n};\n\n#ifndef WOLFSSL_MAX_PATH_LEN\n    /* RFC 5280 Section 6.1.2. \"Initialization\" - item (k) defines\n     *     (k)  max_path_length:  this integer is initialized to \"n\", is\n     *     decremented for each non-self-issued certificate in the path,\n     *     and may be reduced to the value in the path length constraint\n     *     field within the basic constraints extension of a CA\n     *     certificate.\n     *\n     * wolfSSL has arbitrarily selected the value 127 for \"n\" in the above\n     * description. Users can modify the maximum path length by setting\n     * WOLFSSL_MAX_PATH_LEN to a preferred value at build time\n     */\n    #define WOLFSSL_MAX_PATH_LEN 127\n#endif\n\ntypedef struct DecodedCert DecodedCert;\ntypedef struct Signer      Signer;\n#ifdef WOLFSSL_TRUST_PEER_CERT\ntypedef struct TrustedPeerCert TrustedPeerCert;\n#endif /* WOLFSSL_TRUST_PEER_CERT */\ntypedef struct SignatureCtx SignatureCtx;\ntypedef struct CertSignCtx  CertSignCtx;\n\n\nstruct DecodedCert {\n    const byte* publicKey;\n    word32  pubKeySize;\n    int     pubKeyStored;\n    word32  certBegin;               /* offset to start of cert          */\n    word32  sigIndex;                /* offset to start of signature     */\n    word32  sigLength;               /* length of signature              */\n    word32  signatureOID;            /* sum of algorithm object id       */\n    word32  keyOID;                  /* sum of key algo  object id       */\n    int     version;                 /* cert version, 1 or 3             */\n    DNS_entry* altNames;             /* alt names list of dns entries    */\n#ifndef IGNORE_NAME_CONSTRAINTS\n    DNS_entry* altEmailNames;        /* alt names list of RFC822 entries */\n    DNS_entry* altDirNames;          /* alt names list of DIR entries    */\n    Base_entry* permittedNames;      /* Permitted name bases             */\n    Base_entry* excludedNames;       /* Excluded name bases              */\n#endif /* IGNORE_NAME_CONSTRAINTS */\n    byte    subjectHash[KEYID_SIZE]; /* hash of all Names                */\n    byte    issuerHash[KEYID_SIZE];  /* hash of all Names                */\n#ifdef HAVE_OCSP\n    byte    subjectKeyHash[KEYID_SIZE]; /* hash of the public Key         */\n    byte    issuerKeyHash[KEYID_SIZE]; /* hash of the public Key         */\n#endif /* HAVE_OCSP */\n    const byte* signature;           /* not owned, points into raw cert  */\n    char*   subjectCN;               /* CommonName                       */\n    int     subjectCNLen;            /* CommonName Length                */\n    char    subjectCNEnc;            /* CommonName Encoding              */\n    char    issuer[ASN_NAME_MAX];    /* full name including common name  */\n    char    subject[ASN_NAME_MAX];   /* full name including common name  */\n    int     verify;                  /* Default to yes, but could be off */\n    const byte* source;              /* byte buffer holder cert, NOT owner */\n    word32  srcIdx;                  /* current offset into buffer       */\n    word32  maxIdx;                  /* max offset based on init size    */\n    void*   heap;                    /* for user memory overrides        */\n    byte    serial[EXTERNAL_SERIAL_SIZE];  /* raw serial number          */\n    int     serialSz;                /* raw serial bytes stored */\n    const byte* extensions;          /* not owned, points into raw cert  */\n    int     extensionsSz;            /* length of cert extensions */\n    word32  extensionsIdx;           /* if want to go back and parse later */\n    const byte* extAuthInfo;         /* Authority Information Access URI */\n    int     extAuthInfoSz;           /* length of the URI                */\n#if defined(OPENSSL_ALL) || defined(WOLFSSL_QT)\n    const byte* extAuthInfoCaIssuer; /* Authority Info Access caIssuer URI */\n    int     extAuthInfoCaIssuerSz;   /* length of the caIssuer URI         */\n#endif\n    const byte* extCrlInfo;          /* CRL Distribution Points          */\n    int     extCrlInfoSz;            /* length of the URI                */\n    byte    extSubjKeyId[KEYID_SIZE]; /* Subject Key ID                  */\n    byte    extAuthKeyId[KEYID_SIZE]; /* Authority Key ID                */\n    byte    pathLength;              /* CA basic constraint path length  */\n    byte    maxPathLen;              /* max_path_len see RFC 5280 section\n                                      * 6.1.2 \"Initialization\" - (k) for\n                                      * description of max_path_len */\n    byte    policyConstSkip;         /* Policy Constraints skip certs value */\n    word16  extKeyUsage;             /* Key usage bitfield               */\n    byte    extExtKeyUsage;          /* Extended Key usage bitfield      */\n\n#if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)\n    const byte* extExtKeyUsageSrc;\n    word32  extExtKeyUsageSz;\n    word32  extExtKeyUsageCount;\n    const byte* extAuthKeyIdSrc;\n    word32  extAuthKeyIdSz;\n    const byte* extSubjKeyIdSrc;\n    word32  extSubjKeyIdSz;\n#endif\n\n#if defined(HAVE_ECC) || defined(HAVE_ED25519) || defined(HAVE_ED448)\n    word32  pkCurveOID;           /* Public Key's curve OID */\n#endif /* HAVE_ECC */\n    const byte* beforeDate;\n    int     beforeDateLen;\n    const byte* afterDate;\n    int     afterDateLen;\n#if defined(HAVE_PKCS7) || defined(WOLFSSL_CERT_EXT)\n    const byte* issuerRaw;           /* pointer to issuer inside source */\n    int     issuerRawLen;\n#endif\n#if !defined(IGNORE_NAME_CONSTRAINTS) || defined(WOLFSSL_CERT_EXT)\n    const byte* subjectRaw;          /* pointer to subject inside source */\n    int     subjectRawLen;\n#endif\n#if defined(WOLFSSL_CERT_GEN) || defined(WOLFSSL_CERT_EXT)\n    /* easy access to subject info for other sign */\n    char*   subjectSN;\n    int     subjectSNLen;\n    char    subjectSNEnc;\n    char*   subjectC;\n    int     subjectCLen;\n    char    subjectCEnc;\n    char*   subjectL;\n    int     subjectLLen;\n    char    subjectLEnc;\n    char*   subjectST;\n    int     subjectSTLen;\n    char    subjectSTEnc;\n    char*   subjectO;\n    int     subjectOLen;\n    char    subjectOEnc;\n    char*   subjectOU;\n    int     subjectOULen;\n    char    subjectOUEnc;\n    char*   subjectSND;\n    int     subjectSNDLen;\n    char    subjectSNDEnc;\n#ifdef WOLFSSL_CERT_EXT\n    char*   subjectBC;\n    int     subjectBCLen;\n    char    subjectBCEnc;\n    char*   subjectJC;\n    int     subjectJCLen;\n    char    subjectJCEnc;\n    char*   subjectJS;\n    int     subjectJSLen;\n    char    subjectJSEnc;\n#endif\n    char*   subjectEmail;\n    int     subjectEmailLen;\n#endif /* WOLFSSL_CERT_GEN */\n#if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)\n    /* WOLFSSL_X509_NAME structures (used void* to avoid including ssl.h) */\n    void* issuerName;\n    void* subjectName;\n#endif /* OPENSSL_EXTRA */\n#ifdef WOLFSSL_SEP\n    int     deviceTypeSz;\n    byte*   deviceType;\n    int     hwTypeSz;\n    byte*   hwType;\n    int     hwSerialNumSz;\n    byte*   hwSerialNum;\n#endif /* WOLFSSL_SEP */\n#ifdef WOLFSSL_CERT_EXT\n    char    extCertPolicies[MAX_CERTPOL_NB][MAX_CERTPOL_SZ];\n    int     extCertPoliciesNb;\n#endif /* defined(WOLFSSL_CERT_GEN) || defined(WOLFSSL_CERT_EXT) */\n\n#ifdef WOLFSSL_CERT_REQ\n    /* CSR attributes */\n    char*   cPwd; /* challengePassword */\n    int     cPwdLen;\n    char*   sNum; /* Serial Number */\n    int     sNumLen;\n#endif /* WOLFSSL_CERT_REQ */\n\n    Signer* ca;\n#ifndef NO_CERTS\n    SignatureCtx sigCtx;\n#endif\n#ifdef WOLFSSL_RENESAS_TSIP\n    byte*  tsip_encRsaKeyIdx;\n#endif\n\n    int badDate;\n    int criticalExt;\n\n    /* Option Bits */\n    byte subjectCNStored : 1;      /* have we saved a copy we own */\n    byte extSubjKeyIdSet : 1;      /* Set when the SKID was read from cert */\n    byte extAuthKeyIdSet : 1;      /* Set when the AKID was read from cert */\n#ifndef IGNORE_NAME_CONSTRAINTS\n    byte extNameConstraintSet : 1;\n#endif\n    byte isCA : 1;                 /* CA basic constraint true */\n    byte pathLengthSet : 1;        /* CA basic const path length set */\n    byte weOwnAltNames : 1;        /* altNames haven't been given to copy */\n    byte extKeyUsageSet : 1;\n    byte extExtKeyUsageSet : 1;    /* Extended Key Usage set */\n#ifdef HAVE_OCSP\n    byte ocspNoCheckSet : 1;       /* id-pkix-ocsp-nocheck set */\n#endif\n    byte extCRLdistSet : 1;\n    byte extAuthInfoSet : 1;\n    byte extBasicConstSet : 1;\n    byte extPolicyConstSet : 1;\n    byte extPolicyConstRxpSet : 1; /* requireExplicitPolicy set */\n    byte extPolicyConstIpmSet : 1; /* inhibitPolicyMapping set */\n    byte extSubjAltNameSet : 1;\n    byte inhibitAnyOidSet : 1;\n    byte selfSigned : 1;           /* Indicates subject and issuer are same */\n#if defined(WOLFSSL_SEP) || defined(WOLFSSL_QT)\n    byte extCertPolicySet : 1;\n#endif\n#if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)\n    byte extCRLdistCrit : 1;\n    byte extAuthInfoCrit : 1;\n    byte extBasicConstCrit : 1;\n    byte extPolicyConstCrit : 1;\n    byte extSubjAltNameCrit : 1;\n    byte extAuthKeyIdCrit : 1;\n    #ifndef IGNORE_NAME_CONSTRAINTS\n        byte extNameConstraintCrit : 1;\n    #endif\n    byte extSubjKeyIdCrit : 1;\n    byte extKeyUsageCrit : 1;\n    byte extExtKeyUsageCrit : 1;\n#endif /* OPENSSL_EXTRA */\n#if defined(WOLFSSL_SEP) || defined(WOLFSSL_QT)\n    byte extCertPolicyCrit : 1;\n#endif\n#ifdef WOLFSSL_CERT_REQ\n    byte isCSR : 1;                /* Do we intend on parsing a CSR? */\n#endif\n};\n\n/* ASN Encoded Name field */\ntypedef struct EncodedName {\n    int  nameLen;                /* actual string value length */\n    int  totalLen;               /* total encoded length */\n    int  type;                   /* type of name */\n    int  used;                   /* are we actually using this one */\n    byte encoded[CTC_NAME_SIZE * 2]; /* encoding */\n} EncodedName;\n\n#ifdef NO_SHA\n    #define SIGNER_DIGEST_SIZE WC_SHA256_DIGEST_SIZE\n#else\n    #define SIGNER_DIGEST_SIZE WC_SHA_DIGEST_SIZE\n#endif\n\n/* CA Signers */\n/* if change layout change PERSIST_CERT_CACHE functions too */\nstruct Signer {\n    word32  pubKeySize;\n    word32  keyOID;                  /* key type */\n    word16  keyUsage;\n    byte    maxPathLen;\n    byte    pathLength;\n    byte    pathLengthSet : 1;\n    byte    selfSigned : 1;\n    const byte* publicKey;\n    int     nameLen;\n    char*   name;                    /* common name */\n#ifndef IGNORE_NAME_CONSTRAINTS\n        Base_entry* permittedNames;\n        Base_entry* excludedNames;\n#endif /* IGNORE_NAME_CONSTRAINTS */\n    byte    subjectNameHash[SIGNER_DIGEST_SIZE];\n                                     /* sha hash of names in certificate */\n    #ifndef NO_SKID\n        byte    subjectKeyIdHash[SIGNER_DIGEST_SIZE];\n                                     /* sha hash of names in certificate */\n    #endif\n    #ifdef HAVE_OCSP\n        byte subjectKeyHash[KEYID_SIZE];\n    #endif\n#ifdef WOLFSSL_SIGNER_DER_CERT\n    DerBuffer* derCert;\n#endif\n#ifdef WOLFSSL_RENESAS_TSIP_TLS\n    word32 cm_idx;\n#endif\n    Signer* next;\n};\n\n\n#ifdef WOLFSSL_TRUST_PEER_CERT\n/* used for having trusted peer certs rather then CA */\nstruct TrustedPeerCert {\n    int     nameLen;\n    char*   name;                    /* common name */\n    #ifndef IGNORE_NAME_CONSTRAINTS\n        Base_entry* permittedNames;\n        Base_entry* excludedNames;\n    #endif /* IGNORE_NAME_CONSTRAINTS */\n    byte    subjectNameHash[SIGNER_DIGEST_SIZE];\n                                     /* sha hash of names in certificate */\n    #ifndef NO_SKID\n        byte    subjectKeyIdHash[SIGNER_DIGEST_SIZE];\n                                     /* sha hash of names in certificate */\n    #endif\n    word32 sigLen;\n    byte*  sig;\n    struct TrustedPeerCert* next;\n};\n#endif /* WOLFSSL_TRUST_PEER_CERT */\n\n\n/* for testing or custom openssl wrappers */\n#if defined(WOLFSSL_TEST_CERT) || defined(OPENSSL_EXTRA) || \\\n    defined(OPENSSL_EXTRA_X509_SMALL)\n    #define WOLFSSL_ASN_API WOLFSSL_API\n#else\n    #define WOLFSSL_ASN_API WOLFSSL_LOCAL\n#endif\n\n#ifdef HAVE_SMIME\n#define MIME_HEADER_ASCII_MIN   33\n#define MIME_HEADER_ASCII_MAX   126\n\ntypedef struct MimeParam MimeParam;\ntypedef struct MimeHdr MimeHdr;\n\nstruct MimeParam\n{\n    MimeParam*  next;\n    char*       attribute;\n    char*       value;\n};\n\nstruct MimeHdr\n{\n    MimeHdr*    next;\n    MimeParam*  params;\n    char*       name;\n    char*       body;\n};\n\ntypedef enum MimeTypes\n{\n    MIME_HDR,\n    MIME_PARAM\n} MimeTypes;\n\ntypedef enum MimeStatus\n{\n    MIME_NAMEATTR,\n    MIME_BODYVAL\n} MimeStatus;\n#endif /* HAVE_SMIME */\n\n\nWOLFSSL_LOCAL int CalcHashId(const byte* data, word32 len, byte* hash);\nWOLFSSL_LOCAL int GetName(DecodedCert* cert, int nameType, int maxIdx);\n\nWOLFSSL_ASN_API int wc_BerToDer(const byte* ber, word32 berSz, byte* der,\n                                word32* derSz);\n\nWOLFSSL_ASN_API void FreeAltNames(DNS_entry*, void*);\n#ifndef IGNORE_NAME_CONSTRAINTS\n    WOLFSSL_ASN_API void FreeNameSubtrees(Base_entry*, void*);\n#endif /* IGNORE_NAME_CONSTRAINTS */\nWOLFSSL_ASN_API void InitDecodedCert(DecodedCert*, const byte*, word32, void*);\nWOLFSSL_ASN_API void FreeDecodedCert(DecodedCert*);\nWOLFSSL_ASN_API int  ParseCert(DecodedCert*, int type, int verify, void* cm);\n\nWOLFSSL_LOCAL int DecodePolicyOID(char *o, word32 oSz,\n                                  const byte *in, word32 inSz);\nWOLFSSL_LOCAL int EncodePolicyOID(byte *out, word32 *outSz,\n                                  const char *in, void* heap);\nWOLFSSL_API int CheckCertSignature(const byte*,word32,void*,void* cm);\nWOLFSSL_LOCAL int CheckCertSignaturePubKey(const byte* cert, word32 certSz,\n        void* heap, const byte* pubKey, word32 pubKeySz, int pubKeyOID);\n#ifdef WOLFSSL_CERT_REQ\nWOLFSSL_LOCAL int CheckCSRSignaturePubKey(const byte* cert, word32 certSz, void* heap,\n        const byte* pubKey, word32 pubKeySz, int pubKeyOID);\n#endif /* WOLFSSL_CERT_REQ */\nWOLFSSL_LOCAL int AddSignature(byte* buf, int bodySz, const byte* sig, int sigSz,\n                        int sigAlgoType);\nWOLFSSL_LOCAL int ParseCertRelative(DecodedCert*,int type,int verify,void* cm);\nWOLFSSL_LOCAL int DecodeToKey(DecodedCert*, int verify);\nWOLFSSL_LOCAL int wc_GetPubX509(DecodedCert* cert, int verify, int* badDate);\n\nWOLFSSL_LOCAL const byte* OidFromId(word32 id, word32 type, word32* oidSz);\nWOLFSSL_LOCAL Signer* MakeSigner(void*);\nWOLFSSL_LOCAL void    FreeSigner(Signer*, void*);\nWOLFSSL_LOCAL void    FreeSignerTable(Signer**, int, void*);\n#ifdef WOLFSSL_TRUST_PEER_CERT\nWOLFSSL_LOCAL void    FreeTrustedPeer(TrustedPeerCert*, void*);\nWOLFSSL_LOCAL void    FreeTrustedPeerTable(TrustedPeerCert**, int, void*);\n#endif /* WOLFSSL_TRUST_PEER_CERT */\n\nWOLFSSL_ASN_API int ToTraditional(byte* buffer, word32 length);\nWOLFSSL_ASN_API int ToTraditional_ex(byte* buffer, word32 length,\n                                     word32* algId);\nWOLFSSL_LOCAL int ToTraditionalInline(const byte* input, word32* inOutIdx,\n                                      word32 length);\nWOLFSSL_LOCAL int ToTraditionalInline_ex(const byte* input, word32* inOutIdx,\n                                         word32 length, word32* algId);\nWOLFSSL_LOCAL int ToTraditionalEnc(byte* buffer, word32 length,const char*,int,\n                                   word32* algId);\nWOLFSSL_ASN_API int UnTraditionalEnc(byte* key, word32 keySz, byte* out,\n        word32* outSz, const char* password, int passwordSz, int vPKCS,\n        int vAlgo, byte* salt, word32 saltSz, int itt, WC_RNG* rng, void* heap);\nWOLFSSL_ASN_API int TraditionalEnc(byte* key, word32 keySz, byte* out,\n        word32* outSz, const char* password, int passwordSz, int vPKCS,\n        int vAlgo, int encAlgId, byte* salt, word32 saltSz, int itt,\n        WC_RNG* rng, void* heap);\nWOLFSSL_LOCAL int DecryptContent(byte* input, word32 sz,const char* psw,int pswSz);\nWOLFSSL_LOCAL int EncryptContent(byte* input, word32 sz, byte* out, word32* outSz,\n        const char* password,int passwordSz, int vPKCS, int vAlgo,\n        byte* salt, word32 saltSz, int itt, WC_RNG* rng, void* heap);\nWOLFSSL_LOCAL int wc_GetKeyOID(byte* key, word32 keySz, const byte** curveOID,\n        word32* oidSz, int* algoID, void* heap);\n\ntypedef struct tm wolfssl_tm;\n#if defined(OPENSSL_ALL) || defined(WOLFSSL_MYSQL_COMPATIBLE) || defined(OPENSSL_EXTRA) || \\\n    defined(WOLFSSL_NGINX) || defined(WOLFSSL_HAPROXY)\nWOLFSSL_LOCAL int GetTimeString(byte* date, int format, char* buf, int len);\n#endif\n#if !defined(NO_ASN_TIME) && defined(HAVE_PKCS7)\nWOLFSSL_LOCAL int GetAsnTimeString(void* currTime, byte* buf, word32 len);\n#endif\nWOLFSSL_LOCAL int ExtractDate(const unsigned char* date, unsigned char format,\n                                                 wolfssl_tm* certTime, int* idx);\nWOLFSSL_LOCAL int DateGreaterThan(const struct tm* a, const struct tm* b);\nWOLFSSL_LOCAL int wc_ValidateDate(const byte* date, byte format, int dateType);\nWOLFSSL_LOCAL int wc_OBJ_sn2nid(const char *sn);\n\nWOLFSSL_LOCAL int wc_EncodeName(EncodedName* name, const char* nameStr,\n                                char nameType, byte type);\nWOLFSSL_LOCAL int wc_EncodeNameCanonical(EncodedName* name, const char* nameStr,\n                                char nameType, byte type);\n/* ASN.1 helper functions */\n#ifdef WOLFSSL_CERT_GEN\nWOLFSSL_ASN_API int SetName(byte* output, word32 outputSz, CertName* name);\nWOLFSSL_LOCAL const char* GetOneCertName(CertName* name, int idx);\nWOLFSSL_LOCAL byte GetCertNameId(int idx);\n#endif\nWOLFSSL_LOCAL int GetShortInt(const byte* input, word32* inOutIdx, int* number,\n                              word32 maxIdx);\nWOLFSSL_LOCAL int SetShortInt(byte* input, word32* inOutIdx, word32 number,\n                              word32 maxIdx);\n\nWOLFSSL_LOCAL const char* GetSigName(int oid);\nWOLFSSL_LOCAL int GetLength(const byte* input, word32* inOutIdx, int* len,\n                           word32 maxIdx);\nWOLFSSL_LOCAL int GetLength_ex(const byte* input, word32* inOutIdx, int* len,\n                           word32 maxIdx, int check);\nWOLFSSL_LOCAL int GetSequence(const byte* input, word32* inOutIdx, int* len,\n                             word32 maxIdx);\nWOLFSSL_LOCAL int GetSequence_ex(const byte* input, word32* inOutIdx, int* len,\n                           word32 maxIdx, int check);\nWOLFSSL_LOCAL int GetOctetString(const byte* input, word32* inOutIdx, int* len,\n                         word32 maxIdx);\nWOLFSSL_LOCAL int CheckBitString(const byte* input, word32* inOutIdx, int* len,\n                          word32 maxIdx, int zeroBits, byte* unusedBits);\nWOLFSSL_LOCAL int GetSet(const byte* input, word32* inOutIdx, int* len,\n                        word32 maxIdx);\nWOLFSSL_LOCAL int GetSet_ex(const byte* input, word32* inOutIdx, int* len,\n                        word32 maxIdx, int check);\nWOLFSSL_LOCAL int GetMyVersion(const byte* input, word32* inOutIdx,\n                              int* version, word32 maxIdx);\nWOLFSSL_LOCAL int GetInt(mp_int* mpi, const byte* input, word32* inOutIdx,\n                        word32 maxIdx);\n#ifdef HAVE_OID_ENCODING\n    WOLFSSL_LOCAL int EncodeObjectId(const word16* in, word32 inSz,\n        byte* out, word32* outSz);\n#endif\n#ifdef HAVE_OID_DECODING\n    WOLFSSL_LOCAL int DecodeObjectId(const byte* in, word32 inSz,\n        word16* out, word32* outSz);\n#endif\nWOLFSSL_LOCAL int GetASNObjectId(const byte* input, word32* inOutIdx, int* len,\n                                 word32 maxIdx);\nWOLFSSL_LOCAL int SetObjectId(int len, byte* output);\nWOLFSSL_LOCAL int GetObjectId(const byte* input, word32* inOutIdx, word32* oid,\n                              word32 oidType, word32 maxIdx);\nWOLFSSL_LOCAL int GetAlgoId(const byte* input, word32* inOutIdx, word32* oid,\n                           word32 oidType, word32 maxIdx);\nWOLFSSL_LOCAL int GetASNTag(const byte* input, word32* idx, byte* tag,\n                            word32 inputSz);\nWOLFSSL_LOCAL word32 SetLength(word32 length, byte* output);\nWOLFSSL_LOCAL word32 SetSequence(word32 len, byte* output);\nWOLFSSL_LOCAL word32 SetOctetString(word32 len, byte* output);\nWOLFSSL_LOCAL int SetASNInt(int len, byte firstByte, byte* output);\nWOLFSSL_LOCAL word32 SetBitString(word32 len, byte unusedBits, byte* output);\nWOLFSSL_LOCAL word32 SetImplicit(byte tag,byte number,word32 len,byte* output);\nWOLFSSL_LOCAL word32 SetExplicit(byte number, word32 len, byte* output);\nWOLFSSL_LOCAL word32 SetSet(word32 len, byte* output);\nWOLFSSL_LOCAL word32 SetAlgoID(int algoOID,byte* output,int type,int curveSz);\nWOLFSSL_LOCAL int SetMyVersion(word32 version, byte* output, int header);\nWOLFSSL_LOCAL int SetSerialNumber(const byte* sn, word32 snSz, byte* output,\n    word32 outputSz, int maxSnSz);\nWOLFSSL_LOCAL int GetSerialNumber(const byte* input, word32* inOutIdx,\n    byte* serial, int* serialSz, word32 maxIdx);\nWOLFSSL_LOCAL int GetNameHash(const byte* source, word32* idx, byte* hash,\n                             int maxIdx);\nWOLFSSL_LOCAL int wc_CheckPrivateKeyCert(const byte* key, word32 keySz, DecodedCert* der);\nWOLFSSL_LOCAL int wc_CheckPrivateKey(const byte* privKey, word32 privKeySz,\n                                     const byte* pubKey, word32 pubKeySz, enum Key_Sum ks);\nWOLFSSL_LOCAL int StoreDHparams(byte* out, word32* outLen, mp_int* p, mp_int* g);\nWOLFSSL_LOCAL int FlattenAltNames( byte*, word32, const DNS_entry*);\n\n#ifdef HAVE_ECC\n    /* ASN sig helpers */\n    WOLFSSL_LOCAL int StoreECC_DSA_Sig(byte* out, word32* outLen, mp_int* r,\n                                      mp_int* s);\n    WOLFSSL_LOCAL int StoreECC_DSA_Sig_Bin(byte* out, word32* outLen, \n        const byte* r, word32 rLen, const byte* s, word32 sLen);\n    WOLFSSL_LOCAL int DecodeECC_DSA_Sig_Bin(const byte* sig, word32 sigLen, \n        byte* r, word32* rLen, byte* s, word32* sLen);\n#endif\n#if defined(HAVE_ECC) || !defined(NO_DSA)\n    WOLFSSL_LOCAL int DecodeECC_DSA_Sig(const byte* sig, word32 sigLen,\n                                       mp_int* r, mp_int* s);\n#endif\n#if defined HAVE_ECC && (defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL))\nWOLFSSL_API int EccEnumToNID(int n);\n#endif\n\nWOLFSSL_LOCAL void InitSignatureCtx(SignatureCtx* sigCtx, void* heap, int devId);\nWOLFSSL_LOCAL void FreeSignatureCtx(SignatureCtx* sigCtx);\n\n#ifndef NO_CERTS\n\nWOLFSSL_LOCAL int wc_EncryptedInfoParse(EncryptedInfo* info,\n                                        const char** pBuffer, size_t bufSz);\n\nWOLFSSL_LOCAL int PemToDer(const unsigned char* buff, long sz, int type,\n                          DerBuffer** pDer, void* heap, EncryptedInfo* info,\n                          int* eccKey);\nWOLFSSL_LOCAL int AllocDer(DerBuffer** der, word32 length, int type, void* heap);\nWOLFSSL_LOCAL void FreeDer(DerBuffer** der);\n\n#endif /* !NO_CERTS */\n\n#ifdef HAVE_SMIME\nWOLFSSL_LOCAL int wc_MIME_parse_headers(char* in, int inLen, MimeHdr** hdrs);\nWOLFSSL_LOCAL int wc_MIME_header_strip(char* in, char** out, size_t start, size_t end);\nWOLFSSL_LOCAL int wc_MIME_create_header(char* name, char* body, MimeHdr** hdr);\nWOLFSSL_LOCAL int wc_MIME_create_parameter(char* attribute, char* value, MimeParam** param);\nWOLFSSL_LOCAL MimeHdr* wc_MIME_find_header_name(const char* name, MimeHdr* hdr);\nWOLFSSL_LOCAL MimeParam* wc_MIME_find_param_attr(const char* attribute, MimeParam* param);\nWOLFSSL_LOCAL char* wc_MIME_canonicalize(const char* line);\nWOLFSSL_LOCAL int wc_MIME_free_hdrs(MimeHdr* head);\n#endif /* HAVE_SMIME */\n\n#ifdef WOLFSSL_CERT_GEN\n\nenum cert_enums {\n#ifdef WOLFSSL_CERT_EXT\n    NAME_ENTRIES    =  10,\n#else\n    NAME_ENTRIES    =  9,\n#endif\n    JOINT_LEN       =  2,\n    EMAIL_JOINT_LEN =  9,\n    PILOT_JOINT_LEN =  10,\n    RSA_KEY         = 10,\n    NTRU_KEY        = 11,\n    ECC_KEY         = 12,\n    ED25519_KEY     = 13,\n    ED448_KEY       = 14,\n    DSA_KEY         = 15\n};\n\n#endif /* WOLFSSL_CERT_GEN */\n\n\n\n/* for pointer use */\ntypedef struct CertStatus CertStatus;\n\n#ifdef HAVE_OCSP\n\nenum Ocsp_Response_Status {\n    OCSP_SUCCESSFUL        = 0, /* Response has valid confirmations */\n    OCSP_MALFORMED_REQUEST = 1, /* Illegal confirmation request */\n    OCSP_INTERNAL_ERROR    = 2, /* Internal error in issuer */\n    OCSP_TRY_LATER         = 3, /* Try again later */\n    OCSP_SIG_REQUIRED      = 5, /* Must sign the request (4 is skipped) */\n    OCSP_UNAUTHROIZED      = 6  /* Request unauthorized */\n};\n\n\nenum Ocsp_Cert_Status {\n    CERT_GOOD    = 0,\n    CERT_REVOKED = 1,\n    CERT_UNKNOWN = 2\n};\n\n\nenum Ocsp_Sums {\n    OCSP_BASIC_OID = 117,\n    OCSP_NONCE_OID = 118\n};\n\n#ifdef OPENSSL_EXTRA\nenum Ocsp_Verify_Error {\n    OCSP_VERIFY_ERROR_NONE = 0,\n    OCSP_BAD_ISSUER = 1\n};\n#endif\n\n\ntypedef struct OcspRequest  OcspRequest;\ntypedef struct OcspResponse OcspResponse;\n\n\nstruct CertStatus {\n    CertStatus* next;\n\n    byte serial[EXTERNAL_SERIAL_SIZE];\n    int serialSz;\n#ifdef OPENSSL_EXTRA\n    WOLFSSL_ASN1_INTEGER* serialInt;\n#endif\n\n    int status;\n\n    byte thisDate[MAX_DATE_SIZE];\n    byte nextDate[MAX_DATE_SIZE];\n    byte thisDateFormat;\n    byte nextDateFormat;\n#if defined(OPENSSL_ALL) || defined(WOLFSSL_NGINX) || defined(WOLFSSL_HAPROXY) || defined(HAVE_LIGHTY)\n    WOLFSSL_ASN1_TIME thisDateParsed;\n    WOLFSSL_ASN1_TIME nextDateParsed;\n    byte* thisDateAsn;\n    byte* nextDateAsn;\n#endif\n\n    byte*  rawOcspResponse;\n    word32 rawOcspResponseSz;\n};\n\ntypedef struct OcspEntry OcspEntry;\n\n#ifdef NO_SHA\n#define OCSP_DIGEST_SIZE WC_SHA256_DIGEST_SIZE\n#else\n#define OCSP_DIGEST_SIZE WC_SHA_DIGEST_SIZE\n#endif\n\nstruct OcspEntry\n{\n    OcspEntry *next;                      /* next entry                */\n    word32 hashAlgoOID;                   /* hash algo ID              */\n    byte issuerHash[OCSP_DIGEST_SIZE];    /* issuer hash               */\n    byte issuerKeyHash[OCSP_DIGEST_SIZE]; /* issuer public key hash    */\n    CertStatus *status;                   /* OCSP response list        */\n    int totalStatus;                      /* number on list            */\n    byte* rawCertId;                      /* raw bytes of the CertID   */\n    int rawCertIdSize;                    /* num bytes in raw CertID   */\n    /* option bits - using 32-bit for alignment */\n    word32 ownStatus:1;                   /* do we need to free the status\n                                           * response list */\n    word32 isDynamic:1;                   /* was dynamically allocated */\n\n};\n\n/* TODO: Long-term, it would be helpful if we made this struct and other OCSP\n         structs conform to the ASN spec as described in RFC 6960. It will help\n         with readability and with implementing OpenSSL compatibility API\n         functions, because OpenSSL's OCSP data structures conform to the\n         RFC. */\nstruct OcspResponse {\n    int     responseStatus;  /* return code from Responder */\n\n    byte*   response;        /* Pointer to beginning of OCSP Response */\n    word32  responseSz;      /* length of the OCSP Response */\n\n    byte    producedDate[MAX_DATE_SIZE];\n                             /* Date at which this response was signed */\n    byte    producedDateFormat; /* format of the producedDate */\n\n    byte*   cert;\n    word32  certSz;\n\n    byte*   sig;             /* Pointer to sig in source */\n    word32  sigSz;           /* Length in octets for the sig */\n    word32  sigOID;          /* OID for hash used for sig */\n\n    OcspEntry* single;       /* chain of OCSP single responses */\n\n    byte*   nonce;           /* pointer to nonce inside ASN.1 response */\n    int     nonceSz;         /* length of the nonce string */\n\n    byte*   source;          /* pointer to source buffer, not owned */\n    word32  maxIdx;          /* max offset based on init size */\n\n#ifdef OPENSSL_EXTRA\n    int     verifyError;\n#endif\n    void*  heap;\n};\n\n\nstruct OcspRequest {\n    byte   issuerHash[KEYID_SIZE];\n    byte   issuerKeyHash[KEYID_SIZE];\n    byte*  serial;   /* copy of the serial number in source cert */\n    int    serialSz;\n#ifdef OPENSSL_EXTRA\n    WOLFSSL_ASN1_INTEGER* serialInt;\n#endif\n    byte*  url;      /* copy of the extAuthInfo in source cert */\n    int    urlSz;\n\n    byte   nonce[MAX_OCSP_NONCE_SZ];\n    int    nonceSz;\n    void*  heap;\n    void*  ssl;\n};\n\nWOLFSSL_LOCAL void InitOcspResponse(OcspResponse*, OcspEntry*, CertStatus*, byte*, word32, void*);\nWOLFSSL_LOCAL void FreeOcspResponse(OcspResponse*);\nWOLFSSL_LOCAL int OcspResponseDecode(OcspResponse*, void*, void* heap, int);\n\nWOLFSSL_LOCAL int    InitOcspRequest(OcspRequest*, DecodedCert*, byte, void*);\nWOLFSSL_LOCAL void   FreeOcspRequest(OcspRequest*);\nWOLFSSL_LOCAL int    EncodeOcspRequest(OcspRequest*, byte*, word32);\nWOLFSSL_LOCAL word32 EncodeOcspRequestExtensions(OcspRequest*, byte*, word32);\n\n\nWOLFSSL_LOCAL int  CompareOcspReqResp(OcspRequest*, OcspResponse*);\n\n\n#endif /* HAVE_OCSP */\n\n\n/* for pointer use */\ntypedef struct RevokedCert RevokedCert;\n\n#ifdef HAVE_CRL\n\nstruct RevokedCert {\n    byte         serialNumber[EXTERNAL_SERIAL_SIZE];\n    int          serialSz;\n    RevokedCert* next;\n};\n\ntypedef struct DecodedCRL DecodedCRL;\n\nstruct DecodedCRL {\n    word32  certBegin;               /* offset to start of cert          */\n    word32  sigIndex;                /* offset to start of signature     */\n    word32  sigLength;               /* length of signature              */\n    word32  signatureOID;            /* sum of algorithm object id       */\n    byte*   signature;               /* pointer into raw source, not owned */\n    byte    issuerHash[SIGNER_DIGEST_SIZE]; /* issuer name hash          */\n    byte    crlHash[SIGNER_DIGEST_SIZE]; /* raw crl data hash            */\n    byte    lastDate[MAX_DATE_SIZE]; /* last date updated  */\n    byte    nextDate[MAX_DATE_SIZE]; /* next update date   */\n    byte    lastDateFormat;          /* format of last date */\n    byte    nextDateFormat;          /* format of next date */\n    RevokedCert* certs;              /* revoked cert list  */\n    int          totalCerts;         /* number on list     */\n    void*   heap;\n#ifndef NO_SKID\n    byte    extAuthKeyIdSet;\n    byte    extAuthKeyId[SIGNER_DIGEST_SIZE]; /* Authority Key ID        */\n#endif\n};\n\nWOLFSSL_LOCAL void InitDecodedCRL(DecodedCRL*, void* heap);\nWOLFSSL_LOCAL int VerifyCRL_Signature(SignatureCtx* sigCtx,\n                                      const byte* toBeSigned, word32 tbsSz,\n                                      const byte* signature, word32 sigSz,\n                                      word32 signatureOID, Signer *ca,\n                                      void* heap);\nWOLFSSL_LOCAL int  ParseCRL(DecodedCRL*, const byte* buff, word32 sz, void* cm);\nWOLFSSL_LOCAL void FreeDecodedCRL(DecodedCRL*);\n\n\n#endif /* HAVE_CRL */\n\n\n#ifdef __cplusplus\n    } /* extern \"C\" */\n#endif\n\n#endif /* !NO_ASN */\n\n\n#if !defined(NO_ASN) || !defined(NO_PWDBASED)\n\n#ifndef MAX_KEY_SIZE\n    #define MAX_KEY_SIZE    64  /* MAX PKCS Key length */\n#endif\n#ifndef MAX_UNICODE_SZ\n    #define MAX_UNICODE_SZ  256\n#endif\n\nenum PBESTypes {\n    PBE_MD5_DES        = 0,\n    PBE_SHA1_RC4_128   = 1,\n    PBE_SHA1_DES       = 2,\n    PBE_SHA1_DES3      = 3,\n    PBE_AES256_CBC     = 4,\n    PBE_AES128_CBC     = 5,\n    PBE_SHA1_40RC2_CBC = 6,\n\n    PBE_SHA1_RC4_128_SUM = 657,\n    PBE_SHA1_DES3_SUM    = 659,\n    PBES2            = 13       /* algo ID */\n};\n\nenum PKCSTypes {\n    PKCS5v2             =   6,     /* PKCS #5 v2.0 */\n    PKCS12v1            =  12,     /* PKCS #12 */\n    PKCS5               =   5,     /* PKCS oid tag */\n    PKCS8v0             =   0,     /* default PKCS#8 version */\n};\n\n#endif /* !NO_ASN || !NO_PWDBASED */\n\n#endif /* WOLF_CRYPT_ASN_H */\n"], "fixing_code": ["/* asn.c\n *\n * Copyright (C) 2006-2021 wolfSSL Inc.\n *\n * This file is part of wolfSSL.\n *\n * wolfSSL is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * wolfSSL is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1335, USA\n */\n\n/*\n\nDESCRIPTION\nThis library provides the interface to Abstract Syntax Notation One (ASN.1) objects.\nASN.1 is a standard interface description language for defining data structures\nthat can be serialized and deserialized in a cross-platform way.\n\n*/\n#ifdef HAVE_CONFIG_H\n    #include <config.h>\n#endif\n\n#include <wolfssl/wolfcrypt/settings.h>\n\n/*\nASN Options:\n * NO_ASN_TIME: Disables time parts of the ASN code for systems without an RTC\n    or wishing to save space.\n * IGNORE_NAME_CONSTRAINTS: Skip ASN name checks.\n * ASN_DUMP_OID: Allows dump of OID information for debugging.\n * RSA_DECODE_EXTRA: Decodes extra information in RSA public key.\n * WOLFSSL_CERT_GEN: Cert generation. Saves extra certificate info in GetName.\n * WOLFSSL_NO_ASN_STRICT: Disable strict RFC compliance checks to\n    restore 3.13.0 behavior.\n * WOLFSSL_NO_OCSP_OPTIONAL_CERTS: Skip optional OCSP certs (responder issuer\n    must still be trusted)\n * WOLFSSL_NO_TRUSTED_CERTS_VERIFY: Workaround for situation where entire cert\n    chain is not loaded. This only matches on subject and public key and\n    does not perform a PKI validation, so it is not a secure solution.\n    Only enabled for OCSP.\n * WOLFSSL_NO_OCSP_ISSUER_CHECK: Can be defined for backwards compatibility to\n    disable checking of OCSP subject hash with issuer hash.\n * WOLFSSL_SMALL_CERT_VERIFY: Verify the certificate signature without using\n    DecodedCert. Doubles up on some code but allows smaller dynamic memory\n    usage.\n * WOLFSSL_NO_OCSP_DATE_CHECK: Disable date checks for OCSP responses. This\n    may be required when the system's real-time clock is not very accurate.\n    It is recommended to enforce the nonce check instead if possible.\n * WOLFSSL_FORCE_OCSP_NONCE_CHECK: Require nonces to be available in OCSP\n    responses. The nonces are optional and may not be supported by all\n    responders. If it can be ensured that the used responder sends nonces this\n    option may improve security.\n*/\n\n#ifndef NO_ASN\n\n#include <wolfssl/wolfcrypt/asn.h>\n#include <wolfssl/wolfcrypt/coding.h>\n#include <wolfssl/wolfcrypt/md2.h>\n#include <wolfssl/wolfcrypt/hmac.h>\n#include <wolfssl/wolfcrypt/error-crypt.h>\n#include <wolfssl/wolfcrypt/pwdbased.h>\n#include <wolfssl/wolfcrypt/des3.h>\n#include <wolfssl/wolfcrypt/aes.h>\n#include <wolfssl/wolfcrypt/rc2.h>\n#include <wolfssl/wolfcrypt/wc_encrypt.h>\n#include <wolfssl/wolfcrypt/logging.h>\n\n#include <wolfssl/wolfcrypt/random.h>\n#include <wolfssl/wolfcrypt/hash.h>\n#ifdef NO_INLINE\n    #include <wolfssl/wolfcrypt/misc.h>\n#else\n    #define WOLFSSL_MISC_INCLUDED\n    #include <wolfcrypt/src/misc.c>\n#endif\n\n#ifndef NO_RC4\n    #include <wolfssl/wolfcrypt/arc4.h>\n#endif\n\n#ifdef HAVE_NTRU\n    #include \"libntruencrypt/ntru_crypto.h\"\n#endif\n\n#if defined(WOLFSSL_SHA512) || defined(WOLFSSL_SHA384)\n    #include <wolfssl/wolfcrypt/sha512.h>\n#endif\n\n#ifndef NO_SHA256\n    #include <wolfssl/wolfcrypt/sha256.h>\n#endif\n\n#ifdef HAVE_ECC\n    #include <wolfssl/wolfcrypt/ecc.h>\n#endif\n\n#ifdef HAVE_ED25519\n    #include <wolfssl/wolfcrypt/ed25519.h>\n#endif\n\n#ifdef HAVE_ED448\n    #include <wolfssl/wolfcrypt/ed448.h>\n#endif\n\n#ifdef WOLFSSL_QNX_CAAM\n\t#include <wolfssl/wolfcrypt/port/caam/wolfcaam.h>\n#endif\n\n#ifndef NO_RSA\n    #include <wolfssl/wolfcrypt/rsa.h>\n#if defined(WOLFSSL_XILINX_CRYPT) || defined(WOLFSSL_CRYPTOCELL)\nextern int wc_InitRsaHw(RsaKey* key);\n#endif\n#endif\n\n#ifndef NO_DSA\n    #include <wolfssl/wolfcrypt/dsa.h>\n#else\n    typedef void* DsaKey;\n#endif\n\n#ifdef WOLF_CRYPTO_CB\n    #include <wolfssl/wolfcrypt/cryptocb.h>\n#endif\n\n#if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)\n    #include <wolfssl/openssl/objects.h>\n#endif\n\n#ifdef _MSC_VER\n    /* 4996 warning to use MS extensions e.g., strcpy_s instead of XSTRNCPY */\n    #pragma warning(disable: 4996)\n#endif\n\n#define ERROR_OUT(err, eLabel) { ret = (err); goto eLabel; }\n\n#if !defined(NO_SKID) && (!defined(HAVE_FIPS) || !defined(HAVE_FIPS_VERSION))\n    #if !defined(HAVE_SELFTEST) || (defined(HAVE_SELFTEST) && \\\n                                   (!defined(HAVE_SELFTEST_VERSION) || \\\n                                    HAVE_SELFTEST_VERSION < 2))\n    #ifndef WOLFSSL_AES_KEY_SIZE_ENUM\n    #define WOLFSSL_AES_KEY_SIZE_ENUM\n    enum Asn_Misc {\n        AES_IV_SIZE         = 16,\n        AES_128_KEY_SIZE    = 16,\n        AES_192_KEY_SIZE    = 24,\n        AES_256_KEY_SIZE    = 32\n    };\n    #endif\n    #endif /* HAVE_SELFTEST */\n#endif\n#ifdef WOLFSSL_RENESAS_TSIP_TLS\nvoid tsip_inform_key_position(const word32 key_n_start,\n                const word32 key_n_len, const word32 key_e_start,\n                const word32 key_e_len);\nint tsip_tls_CertVerify(const byte *cert, word32 certSz,\n                        const byte *signature, word32 sigSz,\n                        word32 key_n_start, word32 key_n_len,\n                        word32 key_e_start, word32 key_e_len,\n                        byte *tsip_encRsaKeyIdx);\n#endif\nint GetLength(const byte* input, word32* inOutIdx, int* len,\n                           word32 maxIdx)\n{\n    return GetLength_ex(input, inOutIdx, len, maxIdx, 1);\n}\n\n\n/* give option to check length value found against index. 1 to check 0 to not */\nint GetLength_ex(const byte* input, word32* inOutIdx, int* len,\n                           word32 maxIdx, int check)\n{\n    int     length = 0;\n    word32  idx = *inOutIdx;\n    byte    b;\n\n    *len = 0;    /* default length */\n\n    if ((idx + 1) > maxIdx) {   /* for first read */\n        WOLFSSL_MSG(\"GetLength bad index on input\");\n        return BUFFER_E;\n    }\n\n    b = input[idx++];\n    if (b >= ASN_LONG_LENGTH) {\n        word32 bytes = b & 0x7F;\n\n        if ((idx + bytes) > maxIdx) {   /* for reading bytes */\n            WOLFSSL_MSG(\"GetLength bad long length\");\n            return BUFFER_E;\n        }\n\n        if (bytes > sizeof(length)) {\n            return ASN_PARSE_E;\n        }\n        while (bytes--) {\n            b = input[idx++];\n            length = (length << 8) | b;\n        }\n        if (length < 0) {\n            return ASN_PARSE_E;\n        }\n    }\n    else\n        length = b;\n\n    if (check && (idx + length) > maxIdx) {   /* for user of length */\n        WOLFSSL_MSG(\"GetLength value exceeds buffer length\");\n        return BUFFER_E;\n    }\n\n    *inOutIdx = idx;\n    if (length > 0)\n        *len = length;\n\n    return length;\n}\n\n\n/* input : buffer to read from\n * inOutIdx : index to start reading from, gets advanced by 1 if successful\n * maxIdx : maximum index value\n * tag : ASN tag value found\n *\n * returns 0 on success\n */\nint GetASNTag(const byte* input, word32* inOutIdx, byte* tag, word32 maxIdx)\n{\n    word32 idx;\n\n    if (tag == NULL || inOutIdx == NULL || input == NULL) {\n        return BAD_FUNC_ARG;\n    }\n\n    idx = *inOutIdx;\n    if (idx + ASN_TAG_SZ > maxIdx) {\n        WOLFSSL_MSG(\"Buffer too small for ASN tag\");\n        return BUFFER_E;\n    }\n\n    *tag = input[idx];\n    *inOutIdx = idx + ASN_TAG_SZ;\n    return 0;\n}\n\n\nstatic int GetASNHeader_ex(const byte* input, byte tag, word32* inOutIdx, int* len,\n                        word32 maxIdx, int check)\n{\n    word32 idx = *inOutIdx;\n    byte   tagFound;\n    int    length;\n\n    if (GetASNTag(input, &idx, &tagFound, maxIdx) != 0)\n        return ASN_PARSE_E;\n\n    if (tagFound != tag)\n        return ASN_PARSE_E;\n\n    if (GetLength_ex(input, &idx, &length, maxIdx, check) < 0)\n        return ASN_PARSE_E;\n\n    *len      = length;\n    *inOutIdx = idx;\n    return length;\n}\n\n\n/* Get the DER/BER encoding of an ASN.1 header.\n *\n * input     Buffer holding DER/BER encoded data.\n * tag       ASN.1 tag value expected in header.\n * inOutIdx  Current index into buffer to parse.\n * len       The number of bytes in the ASN.1 data.\n * maxIdx    Length of data in buffer.\n * returns BUFFER_E when there is not enough data to parse.\n *         ASN_PARSE_E when the expected tag is not found or length is invalid.\n *         Otherwise, the number of bytes in the ASN.1 data.\n */\nstatic int GetASNHeader(const byte* input, byte tag, word32* inOutIdx, int* len,\n                        word32 maxIdx)\n{\n    return GetASNHeader_ex(input, tag, inOutIdx, len, maxIdx, 1);\n}\n\nstatic int GetHeader(const byte* input, byte* tag, word32* inOutIdx, int* len,\n                     word32 maxIdx, int check)\n{\n    word32 idx = *inOutIdx;\n    int    length;\n\n    if ((idx + 1) > maxIdx)\n        return BUFFER_E;\n\n    *tag = input[idx++];\n\n    if (GetLength_ex(input, &idx, &length, maxIdx, check) < 0)\n        return ASN_PARSE_E;\n\n    *len      = length;\n    *inOutIdx = idx;\n    return length;\n}\n\nint GetSequence(const byte* input, word32* inOutIdx, int* len,\n                           word32 maxIdx)\n{\n    return GetASNHeader(input, ASN_SEQUENCE | ASN_CONSTRUCTED, inOutIdx, len,\n                        maxIdx);\n}\n\n\nint GetSequence_ex(const byte* input, word32* inOutIdx, int* len,\n                           word32 maxIdx, int check)\n{\n    return GetASNHeader_ex(input, ASN_SEQUENCE | ASN_CONSTRUCTED, inOutIdx, len,\n                        maxIdx, check);\n}\n\n\nint GetSet(const byte* input, word32* inOutIdx, int* len,\n                        word32 maxIdx)\n{\n    return GetASNHeader(input, ASN_SET | ASN_CONSTRUCTED, inOutIdx, len,\n                        maxIdx);\n}\n\n\nint GetSet_ex(const byte* input, word32* inOutIdx, int* len,\n                        word32 maxIdx, int check)\n{\n    return GetASNHeader_ex(input, ASN_SET | ASN_CONSTRUCTED, inOutIdx, len,\n                        maxIdx, check);\n}\n\n/* Get the DER/BER encoded ASN.1 NULL element.\n * Ensure that the all fields are as expected and move index past the element.\n *\n * input     Buffer holding DER/BER encoded data.\n * inOutIdx  Current index into buffer to parse.\n * maxIdx    Length of data in buffer.\n * returns BUFFER_E when there is not enough data to parse.\n *         ASN_TAG_NULL_E when the NULL tag is not found.\n *         ASN_EXPECT_0_E when the length is not zero.\n *         Otherwise, 0 to indicate success.\n */\nstatic int GetASNNull(const byte* input, word32* inOutIdx, word32 maxIdx)\n{\n    word32 idx = *inOutIdx;\n    byte   b;\n\n    if ((idx + 2) > maxIdx)\n        return BUFFER_E;\n\n    b = input[idx++];\n    if (b != ASN_TAG_NULL)\n        return ASN_TAG_NULL_E;\n\n    if (input[idx++] != 0)\n        return ASN_EXPECT_0_E;\n\n    *inOutIdx = idx;\n    return 0;\n}\n\n/* Set the DER/BER encoding of the ASN.1 NULL element.\n *\n * output  Buffer to write into.\n * returns the number of bytes added to the buffer.\n */\nstatic int SetASNNull(byte* output)\n{\n    output[0] = ASN_TAG_NULL;\n    output[1] = 0;\n\n    return 2;\n}\n\n#ifndef NO_CERTS\n/* Get the DER/BER encoding of an ASN.1 BOOLEAN.\n *\n * input     Buffer holding DER/BER encoded data.\n * inOutIdx  Current index into buffer to parse.\n * maxIdx    Length of data in buffer.\n * returns BUFFER_E when there is not enough data to parse.\n *         ASN_PARSE_E when the BOOLEAN tag is not found or length is not 1.\n *         Otherwise, 0 to indicate the value was false and 1 to indicate true.\n */\nstatic int GetBoolean(const byte* input, word32* inOutIdx, word32 maxIdx)\n{\n    word32 idx = *inOutIdx;\n    byte   b;\n\n    if ((idx + 3) > maxIdx)\n        return BUFFER_E;\n\n    b = input[idx++];\n    if (b != ASN_BOOLEAN)\n        return ASN_PARSE_E;\n\n    if (input[idx++] != 1)\n        return ASN_PARSE_E;\n\n    b = input[idx++] != 0;\n\n    *inOutIdx = idx;\n    return b;\n}\n#endif /* !NO_CERTS*/\n#ifdef ASN1_SET_BOOLEAN\n/* Set the DER/BER encoding of the ASN.1 NULL element.\n * Note: Function not required as yet.\n *\n * val     Boolean value to encode.\n * output  Buffer to write into.\n * returns the number of bytes added to the buffer.\n */\nstatic int SetBoolean(int val, byte* output)\n{\n    output[0] = ASN_BOOLEAN;\n    output[1] = 1;\n    output[2] = val ? -1 : 0;\n\n    return 3;\n}\n#endif\n\n/* Get the DER/BER encoding of an ASN.1 OCTET_STRING header.\n *\n * input     Buffer holding DER/BER encoded data.\n * inOutIdx  Current index into buffer to parse.\n * len       The number of bytes in the ASN.1 data.\n * maxIdx    Length of data in buffer.\n * returns BUFFER_E when there is not enough data to parse.\n *         ASN_PARSE_E when the OCTET_STRING tag is not found or length is\n *         invalid.\n *         Otherwise, the number of bytes in the ASN.1 data.\n */\nint GetOctetString(const byte* input, word32* inOutIdx, int* len,\n                          word32 maxIdx)\n{\n    return GetASNHeader(input, ASN_OCTET_STRING, inOutIdx, len, maxIdx);\n}\n\n/* Get the DER/BER encoding of an ASN.1 INTEGER header.\n * Removes the leading zero byte when found.\n *\n * input     Buffer holding DER/BER encoded data.\n * inOutIdx  Current index into buffer to parse.\n * len       The number of bytes in the ASN.1 data (excluding any leading zero).\n * maxIdx    Length of data in buffer.\n * returns BUFFER_E when there is not enough data to parse.\n *         ASN_PARSE_E when the INTEGER tag is not found, length is invalid,\n *         or invalid use of or missing leading zero.\n *         Otherwise, 0 to indicate success.\n */\nstatic int GetASNInt(const byte* input, word32* inOutIdx, int* len,\n                     word32 maxIdx)\n{\n    int    ret;\n\n    ret = GetASNHeader(input, ASN_INTEGER, inOutIdx, len, maxIdx);\n    if (ret < 0)\n        return ret;\n\n    if (*len > 0) {\n\n#ifndef WOLFSSL_ASN_INT_LEAD_0_ANY\n        /* check for invalid padding on negative integer.\n         * c.f. X.690 (ISO/IEC 8825-2:2003 (E)) 10.4.6; RFC 5280 4.1\n         */\n        if (*len > 1) {\n            if ((input[*inOutIdx] == 0xff) && (input[*inOutIdx + 1] & 0x80))\n                return ASN_PARSE_E;\n        }\n#endif\n\n        /* remove leading zero, unless there is only one 0x00 byte */\n        if ((input[*inOutIdx] == 0x00) && (*len > 1)) {\n            (*inOutIdx)++;\n            (*len)--;\n\n#ifndef WOLFSSL_ASN_INT_LEAD_0_ANY\n            if (*len > 0 && (input[*inOutIdx] & 0x80) == 0)\n                return ASN_PARSE_E;\n#endif\n        }\n    }\n\n    return 0;\n}\n\n#ifndef NO_CERTS\n/* Get the DER/BER encoding of an ASN.1 INTEGER that has a value of no more than\n * 7 bits.\n *\n * input     Buffer holding DER/BER encoded data.\n * inOutIdx  Current index into buffer to parse.\n * maxIdx    Length of data in buffer.\n * returns BUFFER_E when there is not enough data to parse.\n *         ASN_PARSE_E when the INTEGER tag is not found or length is invalid.\n *         Otherwise, the 7-bit value.\n */\nstatic int GetInteger7Bit(const byte* input, word32* inOutIdx, word32 maxIdx)\n{\n    word32 idx = *inOutIdx;\n    byte   b;\n\n    if ((idx + 3) > maxIdx)\n        return BUFFER_E;\n\n    if (GetASNTag(input, &idx, &b, maxIdx) != 0)\n        return ASN_PARSE_E;\n    if (b != ASN_INTEGER)\n        return ASN_PARSE_E;\n    if (input[idx++] != 1)\n        return ASN_PARSE_E;\n    b = input[idx++];\n\n    *inOutIdx = idx;\n    return b;\n}\n#endif /* !NO_CERTS */\n\n#if !defined(NO_DSA) && !defined(NO_SHA)\nstatic const char sigSha1wDsaName[] = \"SHAwDSA\";\nstatic const char sigSha256wDsaName[] = \"SHA256wDSA\";\n#endif /* NO_DSA */\n#ifndef NO_RSA\n#ifdef WOLFSSL_MD2\n    static const char  sigMd2wRsaName[] = \"md2WithRSAEncryption\";\n#endif\n#ifndef NO_MD5\n    static const char  sigMd5wRsaName[] = \"md5WithRSAEncryption\";\n#endif\n#ifndef NO_SHA\n    static const char  sigSha1wRsaName[] = \"sha1WithRSAEncryption\";\n#endif\n#ifdef WOLFSSL_SHA224\n    static const char sigSha224wRsaName[] = \"sha224WithRSAEncryption\";\n#endif\n#ifndef NO_SHA256\n    static const char sigSha256wRsaName[] = \"sha256WithRSAEncryption\";\n#endif\n#ifdef WOLFSSL_SHA384\n    static const char sigSha384wRsaName[] = \"sha384WithRSAEncryption\";\n#endif\n#ifdef WOLFSSL_SHA512\n    static const char sigSha512wRsaName[] = \"sha512WithRSAEncryption\";\n#endif\n#ifdef WOLFSSL_SHA3\n#ifndef WOLFSSL_NOSHA3_224\n    static const char sigSha3_224wRsaName[] = \"sha3_224WithRSAEncryption\";\n#endif\n#ifndef WOLFSSL_NOSHA3_256\n    static const char sigSha3_256wRsaName[] = \"sha3_256WithRSAEncryption\";\n#endif\n#ifndef WOLFSSL_NOSHA3_384\n    static const char sigSha3_384wRsaName[] = \"sha3_384WithRSAEncryption\";\n#endif\n#ifndef WOLFSSL_NOSHA3_512\n    static const char sigSha3_512wRsaName[] = \"sha3_512WithRSAEncryption\";\n#endif\n#endif\n#endif /* NO_RSA */\n#ifdef HAVE_ECC\n#ifndef NO_SHA\n    static const char sigSha1wEcdsaName[] = \"SHAwECDSA\";\n#endif\n#ifdef WOLFSSL_SHA224\n    static const char sigSha224wEcdsaName[] = \"SHA224wECDSA\";\n#endif\n#ifndef NO_SHA256\n    static const char sigSha256wEcdsaName[] = \"SHA256wECDSA\";\n#endif\n#ifdef WOLFSSL_SHA384\n    static const char sigSha384wEcdsaName[] = \"SHA384wECDSA\";\n#endif\n#ifdef WOLFSSL_SHA512\n    static const char sigSha512wEcdsaName[] = \"SHA512wECDSA\";\n#endif\n#ifdef WOLFSSL_SHA3\n#ifndef WOLFSSL_NOSHA3_224\n    static const char sigSha3_224wEcdsaName[] = \"SHA3_224wECDSA\";\n#endif\n#ifndef WOLFSSL_NOSHA3_256\n    static const char sigSha3_256wEcdsaName[] = \"SHA3_256wECDSA\";\n#endif\n#ifndef WOLFSSL_NOSHA3_384\n    static const char sigSha3_384wEcdsaName[] = \"SHA3_384wECDSA\";\n#endif\n#ifndef WOLFSSL_NOSHA3_512\n    static const char sigSha3_512wEcdsaName[] = \"SHA3_512wECDSA\";\n#endif\n#endif\n#endif /* HAVE_ECC */\nstatic const char sigUnknownName[] = \"Unknown\";\n\n\n/* Get the human readable string for a signature type\n *\n * oid  Oid value for signature\n */\nconst char* GetSigName(int oid) {\n    switch (oid) {\n    #if !defined(NO_DSA) && !defined(NO_SHA)\n        case CTC_SHAwDSA:\n            return sigSha1wDsaName;\n        case CTC_SHA256wDSA:\n            return sigSha256wDsaName;\n    #endif /* NO_DSA && NO_SHA */\n    #ifndef NO_RSA\n        #ifdef WOLFSSL_MD2\n        case CTC_MD2wRSA:\n            return sigMd2wRsaName;\n        #endif\n        #ifndef NO_MD5\n        case CTC_MD5wRSA:\n            return sigMd5wRsaName;\n        #endif\n        #ifndef NO_SHA\n        case CTC_SHAwRSA:\n            return sigSha1wRsaName;\n        #endif\n        #ifdef WOLFSSL_SHA224\n        case CTC_SHA224wRSA:\n            return sigSha224wRsaName;\n        #endif\n        #ifndef NO_SHA256\n        case CTC_SHA256wRSA:\n            return sigSha256wRsaName;\n        #endif\n        #ifdef WOLFSSL_SHA384\n        case CTC_SHA384wRSA:\n            return sigSha384wRsaName;\n        #endif\n        #ifdef WOLFSSL_SHA512\n        case CTC_SHA512wRSA:\n            return sigSha512wRsaName;\n        #endif\n        #ifdef WOLFSSL_SHA3\n        #ifndef WOLFSSL_NOSHA3_224\n        case CTC_SHA3_224wRSA:\n            return sigSha3_224wRsaName;\n        #endif\n        #ifndef WOLFSSL_NOSHA3_256\n        case CTC_SHA3_256wRSA:\n            return sigSha3_256wRsaName;\n        #endif\n        #ifndef WOLFSSL_NOSHA3_384\n        case CTC_SHA3_384wRSA:\n            return sigSha3_384wRsaName;\n        #endif\n        #ifndef WOLFSSL_NOSHA3_512\n        case CTC_SHA3_512wRSA:\n            return sigSha3_512wRsaName;\n        #endif\n        #endif\n    #endif /* NO_RSA */\n    #ifdef HAVE_ECC\n        #ifndef NO_SHA\n        case CTC_SHAwECDSA:\n            return sigSha1wEcdsaName;\n        #endif\n        #ifdef WOLFSSL_SHA224\n        case CTC_SHA224wECDSA:\n            return sigSha224wEcdsaName;\n        #endif\n        #ifndef NO_SHA256\n        case CTC_SHA256wECDSA:\n            return sigSha256wEcdsaName;\n        #endif\n        #ifdef WOLFSSL_SHA384\n        case CTC_SHA384wECDSA:\n            return sigSha384wEcdsaName;\n        #endif\n        #ifdef WOLFSSL_SHA512\n        case CTC_SHA512wECDSA:\n            return sigSha512wEcdsaName;\n        #endif\n        #ifdef WOLFSSL_SHA3\n        #ifndef WOLFSSL_NOSHA3_224\n        case CTC_SHA3_224wECDSA:\n            return sigSha3_224wEcdsaName;\n        #endif\n        #ifndef WOLFSSL_NOSHA3_256\n        case CTC_SHA3_256wECDSA:\n            return sigSha3_256wEcdsaName;\n        #endif\n        #ifndef WOLFSSL_NOSHA3_384\n        case CTC_SHA3_384wECDSA:\n            return sigSha3_384wEcdsaName;\n        #endif\n        #ifndef WOLFSSL_NOSHA3_512\n        case CTC_SHA3_512wECDSA:\n            return sigSha3_512wEcdsaName;\n        #endif\n        #endif\n    #endif /* HAVE_ECC */\n        default:\n            return sigUnknownName;\n    }\n}\n\n\n#if !defined(NO_DSA) || defined(HAVE_ECC) || !defined(NO_CERTS) || \\\n   (!defined(NO_RSA) && \\\n        (defined(WOLFSSL_CERT_GEN) || \\\n        ((defined(WOLFSSL_KEY_GEN) || defined(OPENSSL_EXTRA)) && !defined(HAVE_USER_RSA))))\n/* Set the DER/BER encoding of the ASN.1 INTEGER header.\n *\n * len        Length of data to encode.\n * firstByte  First byte of data, most significant byte of integer, to encode.\n * output     Buffer to write into.\n * returns the number of bytes added to the buffer.\n */\nint SetASNInt(int len, byte firstByte, byte* output)\n{\n    word32 idx = 0;\n\n    if (output)\n        output[idx] = ASN_INTEGER;\n    idx++;\n    if (firstByte & 0x80)\n        len++;\n    idx += SetLength(len, output ? output + idx : NULL);\n    if (firstByte & 0x80) {\n        if (output)\n            output[idx] = 0x00;\n        idx++;\n    }\n\n    return idx;\n}\n#endif\n\n#if !defined(NO_DSA) || defined(HAVE_ECC) || (defined(WOLFSSL_CERT_GEN) && \\\n    !defined(NO_RSA)) || ((defined(WOLFSSL_KEY_GEN) || \\\n    (!defined(NO_DH) && defined(WOLFSSL_DH_EXTRA)) || \\\n    defined(OPENSSL_EXTRA)) && !defined(NO_RSA) && !defined(HAVE_USER_RSA))\n/* Set the DER/BER encoding of the ASN.1 INTEGER element with an mp_int.\n * The number is assumed to be positive.\n *\n * n       Multi-precision integer to encode.\n * maxSz   Maximum size of the encoded integer.\n *         A negative value indicates no check of length requested.\n * output  Buffer to write into.\n * returns BUFFER_E when the data is too long for the buffer.\n *         MP_TO_E when encoding the integer fails.\n *         Otherwise, the number of bytes added to the buffer.\n */\nstatic int SetASNIntMP(mp_int* n, int maxSz, byte* output)\n{\n    int idx = 0;\n    int leadingBit;\n    int length;\n    int err;\n\n    leadingBit = mp_leading_bit(n);\n    length = mp_unsigned_bin_size(n);\n    if (maxSz >= 0 && (1 + length + (leadingBit ? 1 : 0)) > maxSz)\n        return BUFFER_E;\n    idx = SetASNInt(length, leadingBit ? 0x80 : 0x00, output);\n    if (maxSz >= 0 && (idx + length) > maxSz)\n        return BUFFER_E;\n\n    if (output) {\n        err = mp_to_unsigned_bin(n, output + idx);\n        if (err != MP_OKAY)\n            return MP_TO_E;\n    }\n    idx += length;\n\n    return idx;\n}\n#endif\n\n#if !defined(NO_RSA) && defined(HAVE_USER_RSA) && \\\n    (defined(WOLFSSL_CERT_GEN) || defined(OPENSSL_EXTRA))\n/* Set the DER/BER encoding of the ASN.1 INTEGER element with an mp_int from\n * an RSA key.\n * The number is assumed to be positive.\n *\n * n       Multi-precision integer to encode.\n * output  Buffer to write into.\n * returns BUFFER_E when the data is too long for the buffer.\n *         MP_TO_E when encoding the integer fails.\n *         Otherwise, the number of bytes added to the buffer.\n */\nstatic int SetASNIntRSA(void* n, byte* output)\n{\n    int idx = 0;\n    int leadingBit;\n    int length;\n    int err;\n\n    leadingBit = wc_Rsa_leading_bit(n);\n    length = wc_Rsa_unsigned_bin_size(n);\n    idx = SetASNInt(length, leadingBit ? 0x80 : 0x00, output);\n    if ((idx + length) > MAX_RSA_INT_SZ)\n        return BUFFER_E;\n\n    if (output) {\n        err = wc_Rsa_to_unsigned_bin(n, output + idx, length);\n        if (err != MP_OKAY)\n            return MP_TO_E;\n    }\n    idx += length;\n\n    return idx;\n}\n#endif /* !NO_RSA && HAVE_USER_RSA && WOLFSSL_CERT_GEN */\n\n/* Windows header clash for WinCE using GetVersion */\nint GetMyVersion(const byte* input, word32* inOutIdx,\n                               int* version, word32 maxIdx)\n{\n    word32 idx = *inOutIdx;\n    byte   tag;\n\n    if ((idx + MIN_VERSION_SZ) > maxIdx)\n        return ASN_PARSE_E;\n\n    if (GetASNTag(input, &idx, &tag, maxIdx) != 0)\n        return ASN_PARSE_E;\n\n    if (tag != ASN_INTEGER)\n        return ASN_PARSE_E;\n\n    if (input[idx++] != 0x01)\n        return ASN_VERSION_E;\n\n    *version  = input[idx++];\n    *inOutIdx = idx;\n\n    return *version;\n}\n\n\n#ifndef NO_PWDBASED\n/* Get small count integer, 32 bits or less */\nint GetShortInt(const byte* input, word32* inOutIdx, int* number, word32 maxIdx)\n{\n    word32 idx = *inOutIdx;\n    word32 len;\n    byte   tag;\n\n    *number = 0;\n\n    /* check for type and length bytes */\n    if ((idx + 2) > maxIdx)\n        return BUFFER_E;\n\n    if (GetASNTag(input, &idx, &tag, maxIdx) != 0)\n        return ASN_PARSE_E;\n\n    if (tag != ASN_INTEGER)\n        return ASN_PARSE_E;\n\n    len = input[idx++];\n    if (len > 4)\n        return ASN_PARSE_E;\n\n    if (len + idx > maxIdx)\n        return ASN_PARSE_E;\n\n    while (len--) {\n        *number  = *number << 8 | input[idx++];\n    }\n\n    *inOutIdx = idx;\n\n    return *number;\n}\n\n\n/* Set small integer, 32 bits or less. DER encoding with no leading 0s\n * returns total amount written including ASN tag and length byte on success */\nint SetShortInt(byte* input, word32* inOutIdx, word32 number, word32 maxIdx)\n{\n    word32 idx = *inOutIdx;\n    word32 len = 0;\n    int    i;\n    byte ar[MAX_LENGTH_SZ];\n\n    /* check for room for type and length bytes */\n    if ((idx + 2) > maxIdx)\n        return BUFFER_E;\n\n    input[idx++] = ASN_INTEGER;\n    idx++; /* place holder for length byte */\n    if (MAX_LENGTH_SZ + idx > maxIdx)\n        return ASN_PARSE_E;\n\n    /* find first non zero byte */\n    XMEMSET(ar, 0, MAX_LENGTH_SZ);\n    c32toa(number, ar);\n    for (i = 0; i < MAX_LENGTH_SZ; i++) {\n        if (ar[i] != 0) {\n            break;\n        }\n    }\n\n    /* handle case of 0 */\n    if (i == MAX_LENGTH_SZ) {\n        input[idx++] = 0; len++;\n    }\n\n    for (; i < MAX_LENGTH_SZ && idx < maxIdx; i++) {\n        input[idx++] = ar[i]; len++;\n    }\n\n    /* jump back to beginning of input buffer using unaltered inOutIdx value\n     * and set number of bytes for integer, then update the index value */\n    input[*inOutIdx + 1] = (byte)len;\n    *inOutIdx = idx;\n\n    return len + 2; /* size of integer bytes plus ASN TAG and length byte */\n}\n#endif /* !NO_PWDBASED */\n\n/* May not have one, not an error */\nstatic int GetExplicitVersion(const byte* input, word32* inOutIdx, int* version,\n                              word32 maxIdx)\n{\n    word32 idx = *inOutIdx;\n    byte tag;\n\n    WOLFSSL_ENTER(\"GetExplicitVersion\");\n\n    if (GetASNTag(input, &idx, &tag, maxIdx) != 0)\n        return ASN_PARSE_E;\n\n    if (tag == (ASN_CONTEXT_SPECIFIC | ASN_CONSTRUCTED)) {\n        int ret;\n\n        *inOutIdx = ++idx;  /* skip header */\n        ret = GetMyVersion(input, inOutIdx, version, maxIdx);\n        if (ret >= 0) {\n            /* check if version is expected value rfc 5280 4.1 {0, 1, 2} */\n            if (*version > MAX_X509_VERSION || *version < MIN_X509_VERSION) {\n                WOLFSSL_MSG(\"Unexpected certificate version\");\n                ret = ASN_VERSION_E;\n            }\n        }\n        return ret;\n    }\n\n    /* go back as is */\n    *version = 0;\n\n    return 0;\n}\n\nint GetInt(mp_int* mpi, const byte* input, word32* inOutIdx, word32 maxIdx)\n{\n    word32 idx = *inOutIdx;\n    int    ret;\n    int    length;\n\n    ret = GetASNInt(input, &idx, &length, maxIdx);\n    if (ret != 0)\n        return ret;\n\n    if (mp_init(mpi) != MP_OKAY)\n        return MP_INIT_E;\n\n    if (mp_read_unsigned_bin(mpi, input + idx, length) != 0) {\n        mp_clear(mpi);\n        return ASN_GETINT_E;\n    }\n\n#ifdef HAVE_WOLF_BIGINT\n    if (wc_bigint_from_unsigned_bin(&mpi->raw, input + idx, length) != 0) {\n        mp_clear(mpi);\n        return ASN_GETINT_E;\n    }\n#endif /* HAVE_WOLF_BIGINT */\n\n    *inOutIdx = idx + length;\n\n    return 0;\n}\n\n#if (!defined(WOLFSSL_KEY_GEN) && !defined(OPENSSL_EXTRA) && defined(RSA_LOW_MEM)) \\\n    || defined(WOLFSSL_RSA_PUBLIC_ONLY) || (!defined(NO_DSA))\n#if (!defined(NO_RSA) && !defined(HAVE_USER_RSA)) || !defined(NO_DSA)\nstatic int SkipInt(const byte* input, word32* inOutIdx, word32 maxIdx)\n{\n    word32 idx = *inOutIdx;\n    int    ret;\n    int    length;\n\n    ret = GetASNInt(input, &idx, &length, maxIdx);\n    if (ret != 0)\n        return ret;\n\n    *inOutIdx = idx + length;\n\n    return 0;\n}\n#endif\n#endif\n\nint CheckBitString(const byte* input, word32* inOutIdx, int* len,\n                          word32 maxIdx, int zeroBits, byte* unusedBits)\n{\n    word32 idx = *inOutIdx;\n    int    length;\n    byte   b;\n\n    if (GetASNTag(input, &idx, &b, maxIdx) != 0) {\n        return ASN_BITSTR_E;\n    }\n\n    if (b != ASN_BIT_STRING) {\n        return ASN_BITSTR_E;\n    }\n\n    if (GetLength(input, &idx, &length, maxIdx) < 0)\n        return ASN_PARSE_E;\n\n    /* extra sanity check that length is greater than 0 */\n    if (length <= 0) {\n        WOLFSSL_MSG(\"Error length was 0 in CheckBitString\");\n        return BUFFER_E;\n    }\n\n    if (idx + 1 > maxIdx) {\n        WOLFSSL_MSG(\"Attempted buffer read larger than input buffer\");\n        return BUFFER_E;\n    }\n\n    b = input[idx];\n    if (zeroBits && b != 0x00)\n        return ASN_EXPECT_0_E;\n    if (b >= 0x08)\n        return ASN_PARSE_E;\n    if (b != 0) {\n        if ((byte)(input[idx + length - 1] << (8 - b)) != 0)\n            return ASN_PARSE_E;\n    }\n    idx++;\n    length--; /* length has been checked for greater than 0 */\n\n    *inOutIdx = idx;\n    if (len != NULL)\n        *len = length;\n    if (unusedBits != NULL)\n        *unusedBits = b;\n\n    return 0;\n}\n\n/* RSA (with CertGen or KeyGen) OR ECC OR ED25519 OR ED448 (with CertGen or\n * KeyGen) */\n#if (!defined(NO_RSA) && !defined(HAVE_USER_RSA) && \\\n        (defined(WOLFSSL_CERT_GEN) || defined(WOLFSSL_KEY_GEN) || defined(OPENSSL_EXTRA))) || \\\n    (defined(HAVE_ECC) && defined(HAVE_ECC_KEY_EXPORT)) || \\\n    ((defined(HAVE_ED25519) || defined(HAVE_ED448)) && \\\n        (defined(WOLFSSL_CERT_GEN) || defined(WOLFSSL_KEY_GEN) || defined(OPENSSL_EXTRA))) || \\\n    (!defined(NO_DSA) && !defined(HAVE_SELFTEST) && defined(WOLFSSL_KEY_GEN))\n\n/* Set the DER/BER encoding of the ASN.1 BIT_STRING header.\n *\n * len         Length of data to encode.\n * unusedBits  The number of unused bits in the last byte of data.\n *             That is, the number of least significant zero bits before a one.\n *             The last byte is the most-significant non-zero byte of a number.\n * output      Buffer to write into.\n * returns the number of bytes added to the buffer.\n */\nword32 SetBitString(word32 len, byte unusedBits, byte* output)\n{\n    word32 idx = 0;\n\n    if (output)\n        output[idx] = ASN_BIT_STRING;\n    idx++;\n\n    idx += SetLength(len + 1, output ? output + idx : NULL);\n    if (output)\n        output[idx] = unusedBits;\n    idx++;\n\n    return idx;\n}\n#endif /* !NO_RSA || HAVE_ECC || HAVE_ED25519 || HAVE_ED448 */\n\n#ifdef ASN_BER_TO_DER\n/* Pull informtation from the ASN.1 BER encoded item header */\nstatic int GetBerHeader(const byte* data, word32* idx, word32 maxIdx,\n                        byte* pTag, word32* pLen, int* indef)\n{\n    int len = 0;\n    byte tag;\n    word32 i = *idx;\n\n    *indef = 0;\n\n    /* Check there is enough data for a minimal header */\n    if (i + 2 > maxIdx) {\n        return ASN_PARSE_E;\n    }\n\n    /* Retrieve tag */\n    tag = data[i++];\n\n    /* Indefinite length handled specially */\n    if (data[i] == 0x80) {\n        /* Check valid tag for indefinite */\n        if (((tag & 0xc0) == 0) && ((tag & ASN_CONSTRUCTED) == 0x00)) {\n            return ASN_PARSE_E;\n        }\n        i++;\n        *indef = 1;\n    }\n    else if (GetLength(data, &i, &len, maxIdx) < 0) {\n        return ASN_PARSE_E;\n    }\n\n    /* Return tag, length and index after BER item header */\n    *pTag = tag;\n    *pLen = len;\n    *idx = i;\n    return 0;\n}\n\n#ifndef INDEF_ITEMS_MAX\n#define INDEF_ITEMS_MAX       20\n#endif\n\n/* Indef length item data */\ntypedef struct Indef {\n    word32 start;\n    int depth;\n    int headerLen;\n    word32 len;\n} Indef;\n\n/* Indef length items */\ntypedef struct IndefItems\n{\n    Indef len[INDEF_ITEMS_MAX];\n    int cnt;\n    int idx;\n    int depth;\n} IndefItems;\n\n\n/* Get header length of current item */\nstatic int IndefItems_HeaderLen(IndefItems* items)\n{\n    return items->len[items->idx].headerLen;\n}\n\n/* Get data length of current item */\nstatic word32 IndefItems_Len(IndefItems* items)\n{\n    return items->len[items->idx].len;\n}\n\n/* Add a indefinite length item */\nstatic int IndefItems_AddItem(IndefItems* items, word32 start)\n{\n    int ret = 0;\n    int i;\n\n    if (items->cnt == INDEF_ITEMS_MAX) {\n        ret = MEMORY_E;\n    }\n    else {\n        i = items->cnt++;\n        items->len[i].start = start;\n        items->len[i].depth = items->depth++;\n        items->len[i].headerLen = 1;\n        items->len[i].len = 0;\n        items->idx = i;\n    }\n\n    return ret;\n}\n\n/* Increase data length of current item */\nstatic void IndefItems_AddData(IndefItems* items, word32 length)\n{\n    items->len[items->idx].len += length;\n}\n\n/* Update header length of current item to reflect data length */\nstatic void IndefItems_UpdateHeaderLen(IndefItems* items)\n{\n    items->len[items->idx].headerLen +=\n                                    SetLength(items->len[items->idx].len, NULL);\n}\n\n/* Go to indefinite parent of current item */\nstatic void IndefItems_Up(IndefItems* items)\n{\n    int i;\n    int depth = items->len[items->idx].depth - 1;\n\n    for (i = items->cnt - 1; i >= 0; i--) {\n        if (items->len[i].depth == depth) {\n            break;\n        }\n    }\n    items->idx = i;\n    items->depth = depth + 1;\n}\n\n/* Calculate final length by adding length of indefinite child items */\nstatic void IndefItems_CalcLength(IndefItems* items)\n{\n    int i;\n    int idx = items->idx;\n\n    for (i = idx + 1; i < items->cnt; i++) {\n        if (items->len[i].depth == items->depth) {\n            items->len[idx].len += items->len[i].headerLen;\n            items->len[idx].len += items->len[i].len;\n        }\n    }\n    items->len[idx].headerLen += SetLength(items->len[idx].len, NULL);\n}\n\n/* Add more data to indefinite length item */\nstatic void IndefItems_MoreData(IndefItems* items, word32 length)\n{\n    if (items->cnt > 0 && items->idx >= 0) {\n        items->len[items->idx].len += length;\n    }\n}\n\n/* Convert a BER encoding with indefinite length items to DER.\n *\n * ber    BER encoded data.\n * berSz  Length of BER encoded data.\n * der    Buffer to hold DER encoded version of data.\n *        NULL indicates only the length is required.\n * derSz  The size of the buffer to hold the DER encoded data.\n *        Will be set if der is NULL, otherwise the value is checked as der is\n *        filled.\n * returns ASN_PARSE_E if the BER data is invalid and BAD_FUNC_ARG if ber or\n * derSz are NULL.\n */\nint wc_BerToDer(const byte* ber, word32 berSz, byte* der, word32* derSz)\n{\n    int ret = 0;\n    word32 i, j;\n#ifdef WOLFSSL_SMALL_STACK\n    IndefItems* indefItems = NULL;\n#else\n    IndefItems indefItems[1];\n#endif\n    byte tag, basic;\n    word32 length;\n    int indef;\n\n    if (ber == NULL || derSz == NULL)\n        return BAD_FUNC_ARG;\n\n#ifdef WOLFSSL_SMALL_STACK\n    indefItems = (IndefItems *)XMALLOC(sizeof(IndefItems), NULL, DYNAMIC_TYPE_TMP_BUFFER);\n    if (indefItems == NULL) {\n        ret = MEMORY_E;\n        goto end;\n    }\n#endif\n\n    XMEMSET(indefItems, 0, sizeof(*indefItems));\n\n    /* Calculate indefinite item lengths */\n    for (i = 0; i < berSz; ) {\n        word32 start = i;\n\n        /* Get next BER item */\n        ret = GetBerHeader(ber, &i, berSz, &tag, &length, &indef);\n        if (ret != 0) {\n            goto end;\n        }\n\n        if (indef) {\n            /* Indefinite item - add to list */\n            ret = IndefItems_AddItem(indefItems, i);\n            if (ret != 0) {\n                goto end;\n            }\n\n            if ((tag & 0xC0) == 0 &&\n                tag != (ASN_SEQUENCE | ASN_CONSTRUCTED) &&\n                tag != (ASN_SET      | ASN_CONSTRUCTED)) {\n                /* Constructed basic type - get repeating tag */\n                basic = tag & (~ASN_CONSTRUCTED);\n\n                /* Add up lengths of each item below */\n                for (; i < berSz; ) {\n                    /* Get next BER_item */\n                    ret = GetBerHeader(ber, &i, berSz, &tag, &length, &indef);\n                    if (ret != 0) {\n                        goto end;\n                    }\n\n                    /* End of content closes item */\n                    if (tag == ASN_EOC) {\n                        /* Must be zero length */\n                        if (length != 0) {\n                            ret = ASN_PARSE_E;\n                            goto end;\n                        }\n                        break;\n                    }\n\n                    /* Must not be indefinite and tag must match parent */\n                    if (indef || tag != basic) {\n                        ret = ASN_PARSE_E;\n                        goto end;\n                    }\n\n                    /* Add to length */\n                    IndefItems_AddData(indefItems, length);\n                    /* Skip data */\n                    i += length;\n                }\n\n                /* Ensure we got an EOC and not end of data */\n                if (tag != ASN_EOC) {\n                    ret = ASN_PARSE_E;\n                    goto end;\n                }\n\n                /* Set the header length to include the length field */\n                IndefItems_UpdateHeaderLen(indefItems);\n                /* Go to indefinte parent item */\n                IndefItems_Up(indefItems);\n            }\n        }\n        else if (tag == ASN_EOC) {\n            /* End-of-content must be 0 length */\n            if (length != 0) {\n                ret = ASN_PARSE_E;\n                goto end;\n            }\n            /* Check there is an item to close - missing EOC */\n            if (indefItems->depth == 0) {\n                ret = ASN_PARSE_E;\n                goto end;\n            }\n\n            /* Finish calculation of data length for indefinite item */\n            IndefItems_CalcLength(indefItems);\n            /* Go to indefinte parent item */\n            IndefItems_Up(indefItems);\n        }\n        else {\n            /* Known length item to add in - make sure enough data for it */\n            if (i + length > berSz) {\n                ret = ASN_PARSE_E;\n                goto end;\n            }\n\n            /* Include all data - can't have indefinite inside definite */\n            i += length;\n            /* Add entire item to current indefinite item */\n            IndefItems_MoreData(indefItems, i - start);\n        }\n    }\n    /* Check we had a EOC for each indefinite item */\n    if (indefItems->depth != 0) {\n        ret = ASN_PARSE_E;\n        goto end;\n    }\n\n    /* Write out DER */\n\n    j = 0;\n    /* Reset index */\n    indefItems->idx = 0;\n    for (i = 0; i < berSz; ) {\n        word32 start = i;\n\n        /* Get item - checked above */\n        (void)GetBerHeader(ber, &i, berSz, &tag, &length, &indef);\n        if (indef) {\n            if (der != NULL) {\n                /* Check enough space for header */\n                if (j + IndefItems_HeaderLen(indefItems) > *derSz) {\n                    ret = BUFFER_E;\n                    goto end;\n                }\n\n                if ((tag & 0xC0) == 0 &&\n                    tag != (ASN_SEQUENCE | ASN_CONSTRUCTED) &&\n                    tag != (ASN_SET      | ASN_CONSTRUCTED)) {\n                    /* Remove constructed tag for basic types */\n                    tag &= ~ASN_CONSTRUCTED;\n                }\n                /* Add tag and length */\n                der[j] = tag;\n                (void)SetLength(IndefItems_Len(indefItems), der + j + 1);\n            }\n            /* Add header length of indefinite item */\n            j += IndefItems_HeaderLen(indefItems);\n\n            if ((tag & 0xC0) == 0 &&\n                tag != (ASN_SEQUENCE | ASN_CONSTRUCTED) &&\n                tag != (ASN_SET      | ASN_CONSTRUCTED)) {\n                /* For basic type - get each child item and add data */\n                for (; i < berSz; ) {\n                    (void)GetBerHeader(ber, &i, berSz, &tag, &length, &indef);\n                    if (tag == ASN_EOC) {\n                        break;\n                    }\n                    if (der != NULL) {\n                        if (j + length > *derSz) {\n                            ret = BUFFER_E;\n                            goto end;\n                        }\n                        XMEMCPY(der + j, ber + i, length);\n                    }\n                    j += length;\n                    i += length;\n                }\n            }\n\n            /* Move to next indef item in list */\n            indefItems->idx++;\n        }\n        else if (tag == ASN_EOC) {\n            /* End-Of-Content is not written out in DER */\n        }\n        else {\n            /* Write out definite length item as is. */\n            i += length;\n            if (der != NULL) {\n                /* Ensure space for item */\n                if (j + i - start > *derSz) {\n                    ret = BUFFER_E;\n                    goto end;\n                }\n                /* Copy item as is */\n                XMEMCPY(der + j, ber + start, i - start);\n            }\n            j += i - start;\n        }\n    }\n\n    /* Return the length of the DER encoded ASN.1 */\n    *derSz = j;\n    if (der == NULL) {\n        ret = LENGTH_ONLY_E;\n    }\nend:\n#ifdef WOLFSSL_SMALL_STACK\n    if (indefItems != NULL) {\n        XFREE(indefItems, NULL, DYNAMIC_TYPE_TMP_BUFFER);\n    }\n#endif\n    return ret;\n}\n#endif\n\n#if defined(WOLFSSL_CERT_EXT) && defined(WOLFSSL_CERT_GEN)\n/* Set the DER/BER encoding of the ASN.1 BIT_STRING with a 16-bit value.\n *\n * val         16-bit value to encode.\n * output      Buffer to write into.\n * returns the number of bytes added to the buffer.\n */\nstatic word32 SetBitString16Bit(word16 val, byte* output)\n{\n    word32 idx;\n    int    len;\n    byte   lastByte;\n    byte   unusedBits = 0;\n\n    if ((val >> 8) != 0) {\n        len = 2;\n        lastByte = (byte)(val >> 8);\n    }\n    else {\n        len = 1;\n        lastByte = (byte)val;\n    }\n\n    while (((lastByte >> unusedBits) & 0x01) == 0x00)\n        unusedBits++;\n\n    idx = SetBitString(len, unusedBits, output);\n    output[idx++] = (byte)val;\n    if (len > 1)\n        output[idx++] = (byte)(val >> 8);\n\n    return idx;\n}\n#endif /* WOLFSSL_CERT_EXT || WOLFSSL_CERT_GEN */\n\n/* hashType */\n#ifdef WOLFSSL_MD2\n    static const byte hashMd2hOid[] = {42, 134, 72, 134, 247, 13, 2, 2};\n#endif\n#ifndef NO_MD5\n    static const byte hashMd5hOid[] = {42, 134, 72, 134, 247, 13, 2, 5};\n#endif\n#ifndef NO_SHA\n    static const byte hashSha1hOid[] = {43, 14, 3, 2, 26};\n#endif\n#ifdef WOLFSSL_SHA224\n    static const byte hashSha224hOid[] = {96, 134, 72, 1, 101, 3, 4, 2, 4};\n#endif\n#ifndef NO_SHA256\n    static const byte hashSha256hOid[] = {96, 134, 72, 1, 101, 3, 4, 2, 1};\n#endif\n#ifdef WOLFSSL_SHA384\n    static const byte hashSha384hOid[] = {96, 134, 72, 1, 101, 3, 4, 2, 2};\n#endif\n#ifdef WOLFSSL_SHA512\n    static const byte hashSha512hOid[] = {96, 134, 72, 1, 101, 3, 4, 2, 3};\n#endif\n#ifdef WOLFSSL_SHA3\n#ifndef WOLFSSL_NOSHA3_224\n    static const byte hashSha3_224hOid[] = {96, 134, 72, 1, 101, 3, 4, 2, 7};\n#endif /* WOLFSSL_NOSHA3_224 */\n#ifndef WOLFSSL_NOSHA3_256\n    static const byte hashSha3_256hOid[] = {96, 134, 72, 1, 101, 3, 4, 2, 8};\n#endif /* WOLFSSL_NOSHA3_256 */\n#ifndef WOLFSSL_NOSHA3_384\n    static const byte hashSha3_384hOid[] = {96, 134, 72, 1, 101, 3, 4, 2, 9};\n#endif /* WOLFSSL_NOSHA3_384 */\n#ifndef WOLFSSL_NOSHA3_512\n    static const byte hashSha3_512hOid[] = {96, 134, 72, 1, 101, 3, 4, 2, 10};\n#endif /* WOLFSSL_NOSHA3_512 */\n#endif /* WOLFSSL_SHA3 */\n\n/* hmacType */\n#ifndef NO_HMAC\n    #ifdef WOLFSSL_SHA224\n    static const byte hmacSha224Oid[] = {42, 134, 72, 134, 247, 13, 2, 8};\n    #endif\n    #ifndef NO_SHA256\n    static const byte hmacSha256Oid[] = {42, 134, 72, 134, 247, 13, 2, 9};\n    #endif\n    #ifdef WOLFSSL_SHA384\n    static const byte hmacSha384Oid[] = {42, 134, 72, 134, 247, 13, 2, 10};\n    #endif\n    #ifdef WOLFSSL_SHA512\n    static const byte hmacSha512Oid[] = {42, 134, 72, 134, 247, 13, 2, 11};\n    #endif\n#endif\n\n/* sigType */\n#if !defined(NO_DSA) && !defined(NO_SHA)\n    static const byte sigSha1wDsaOid[] = {42, 134, 72, 206, 56, 4, 3};\n    static const byte sigSha256wDsaOid[] = {96, 134, 72, 1, 101, 3, 4, 3, 2};\n#endif /* NO_DSA */\n#ifndef NO_RSA\n    #ifdef WOLFSSL_MD2\n    static const byte sigMd2wRsaOid[] = {42, 134, 72, 134, 247, 13, 1, 1, 2};\n    #endif\n    #ifndef NO_MD5\n    static const byte sigMd5wRsaOid[] = {42, 134, 72, 134, 247, 13, 1, 1, 4};\n    #endif\n    #ifndef NO_SHA\n    static const byte sigSha1wRsaOid[] = {42, 134, 72, 134, 247, 13, 1, 1, 5};\n    #endif\n    #ifdef WOLFSSL_SHA224\n    static const byte sigSha224wRsaOid[] = {42, 134, 72, 134, 247, 13, 1, 1,14};\n    #endif\n    #ifndef NO_SHA256\n    static const byte sigSha256wRsaOid[] = {42, 134, 72, 134, 247, 13, 1, 1,11};\n    #endif\n    #ifdef WOLFSSL_SHA384\n    static const byte sigSha384wRsaOid[] = {42, 134, 72, 134, 247, 13, 1, 1,12};\n    #endif\n    #ifdef WOLFSSL_SHA512\n    static const byte sigSha512wRsaOid[] = {42, 134, 72, 134, 247, 13, 1, 1,13};\n    #endif\n    #ifdef WOLFSSL_SHA3\n    #ifndef WOLFSSL_NOSHA3_224\n    static const byte sigSha3_224wRsaOid[] = {96, 134, 72, 1, 101, 3, 4, 3, 13};\n    #endif\n    #ifndef WOLFSSL_NOSHA3_256\n    static const byte sigSha3_256wRsaOid[] = {96, 134, 72, 1, 101, 3, 4, 3, 14};\n    #endif\n    #ifndef WOLFSSL_NOSHA3_384\n    static const byte sigSha3_384wRsaOid[] = {96, 134, 72, 1, 101, 3, 4, 3, 15};\n    #endif\n    #ifndef WOLFSSL_NOSHA3_512\n    static const byte sigSha3_512wRsaOid[] = {96, 134, 72, 1, 101, 3, 4, 3, 16};\n    #endif\n    #endif\n#endif /* NO_RSA */\n#ifdef HAVE_ECC\n    #ifndef NO_SHA\n    static const byte sigSha1wEcdsaOid[] = {42, 134, 72, 206, 61, 4, 1};\n    #endif\n    #ifdef WOLFSSL_SHA224\n    static const byte sigSha224wEcdsaOid[] = {42, 134, 72, 206, 61, 4, 3, 1};\n    #endif\n    #ifndef NO_SHA256\n    static const byte sigSha256wEcdsaOid[] = {42, 134, 72, 206, 61, 4, 3, 2};\n    #endif\n    #ifdef WOLFSSL_SHA384\n    static const byte sigSha384wEcdsaOid[] = {42, 134, 72, 206, 61, 4, 3, 3};\n    #endif\n    #ifdef WOLFSSL_SHA512\n    static const byte sigSha512wEcdsaOid[] = {42, 134, 72, 206, 61, 4, 3, 4};\n    #endif\n    #ifdef WOLFSSL_SHA3\n    #ifndef WOLFSSL_NOSHA3_224\n    static const byte sigSha3_224wEcdsaOid[] = {96, 134, 72, 1, 101, 3, 4, 3, 9};\n    #endif\n    #ifndef WOLFSSL_NOSHA3_256\n    static const byte sigSha3_256wEcdsaOid[] = {96, 134, 72, 1, 101, 3, 4, 3, 10};\n    #endif\n    #ifndef WOLFSSL_NOSHA3_384\n    static const byte sigSha3_384wEcdsaOid[] = {96, 134, 72, 1, 101, 3, 4, 3, 11};\n    #endif\n    #ifndef WOLFSSL_NOSHA3_512\n    static const byte sigSha3_512wEcdsaOid[] = {96, 134, 72, 1, 101, 3, 4, 3, 12};\n    #endif\n    #endif\n#endif /* HAVE_ECC */\n#ifdef HAVE_ED25519\n    static const byte sigEd25519Oid[] = {43, 101, 112};\n#endif /* HAVE_ED25519 */\n#ifdef HAVE_ED448\n    static const byte sigEd448Oid[] = {43, 101, 113};\n#endif /* HAVE_ED448 */\n\n/* keyType */\n#ifndef NO_DSA\n    static const byte keyDsaOid[] = {42, 134, 72, 206, 56, 4, 1};\n#endif /* NO_DSA */\n#ifndef NO_RSA\n    static const byte keyRsaOid[] = {42, 134, 72, 134, 247, 13, 1, 1, 1};\n#endif /* NO_RSA */\n#ifdef HAVE_NTRU\n    static const byte keyNtruOid[] = {43, 6, 1, 4, 1, 193, 22, 1, 1, 1, 1};\n#endif /* HAVE_NTRU */\n#ifdef HAVE_ECC\n    static const byte keyEcdsaOid[] = {42, 134, 72, 206, 61, 2, 1};\n#endif /* HAVE_ECC */\n#ifdef HAVE_ED25519\n    static const byte keyEd25519Oid[] = {43, 101, 112};\n#endif /* HAVE_ED25519 */\n#ifdef HAVE_ED448\n    static const byte keyEd448Oid[] = {43, 101, 113};\n#endif /* HAVE_ED448 */\n#ifndef NO_DH\n    static const byte keyDhOid[] = {42, 134, 72, 134, 247, 13, 1, 3, 1};\n#endif /* !NO_DH */\n\n/* curveType */\n#ifdef HAVE_ECC\n    /* See \"ecc_sets\" table in ecc.c */\n#endif /* HAVE_ECC */\n\n#ifdef HAVE_AES_CBC\n/* blkType */\n    #ifdef WOLFSSL_AES_128\n    static const byte blkAes128CbcOid[] = {96, 134, 72, 1, 101, 3, 4, 1, 2};\n    #endif\n    #ifdef WOLFSSL_AES_192\n    static const byte blkAes192CbcOid[] = {96, 134, 72, 1, 101, 3, 4, 1, 22};\n    #endif\n    #ifdef WOLFSSL_AES_256\n    static const byte blkAes256CbcOid[] = {96, 134, 72, 1, 101, 3, 4, 1, 42};\n    #endif\n#endif /* HAVE_AES_CBC */\n#ifdef HAVE_AESGCM\n    #ifdef WOLFSSL_AES_128\n    static const byte blkAes128GcmOid[] = {96, 134, 72, 1, 101, 3, 4, 1, 6};\n    #endif\n    #ifdef WOLFSSL_AES_192\n    static const byte blkAes192GcmOid[] = {96, 134, 72, 1, 101, 3, 4, 1, 26};\n    #endif\n    #ifdef WOLFSSL_AES_256\n    static const byte blkAes256GcmOid[] = {96, 134, 72, 1, 101, 3, 4, 1, 46};\n    #endif\n#endif /* HAVE_AESGCM */\n#ifdef HAVE_AESCCM\n    #ifdef WOLFSSL_AES_128\n    static const byte blkAes128CcmOid[] = {96, 134, 72, 1, 101, 3, 4, 1, 7};\n    #endif\n    #ifdef WOLFSSL_AES_192\n    static const byte blkAes192CcmOid[] = {96, 134, 72, 1, 101, 3, 4, 1, 27};\n    #endif\n    #ifdef WOLFSSL_AES_256\n    static const byte blkAes256CcmOid[] = {96, 134, 72, 1, 101, 3, 4, 1, 47};\n    #endif\n#endif /* HAVE_AESCCM */\n\n#ifndef NO_DES3\n    static const byte blkDesCbcOid[]  = {43, 14, 3, 2, 7};\n    static const byte blkDes3CbcOid[] = {42, 134, 72, 134, 247, 13, 3, 7};\n#endif\n\n/* keyWrapType */\n#ifdef WOLFSSL_AES_128\n    static const byte wrapAes128Oid[] = {96, 134, 72, 1, 101, 3, 4, 1, 5};\n#endif\n#ifdef WOLFSSL_AES_192\n    static const byte wrapAes192Oid[] = {96, 134, 72, 1, 101, 3, 4, 1, 25};\n#endif\n#ifdef WOLFSSL_AES_256\n    static const byte wrapAes256Oid[] = {96, 134, 72, 1, 101, 3, 4, 1, 45};\n#endif\n#ifdef HAVE_PKCS7\n/* From RFC 3211 */\nstatic const byte wrapPwriKekOid[] = {42, 134, 72, 134, 247, 13, 1, 9, 16, 3,9};\n#endif\n\n/* cmsKeyAgreeType */\n#ifndef NO_SHA\n    static const byte dhSinglePass_stdDH_sha1kdf_Oid[]   =\n                                          {43, 129, 5, 16, 134, 72, 63, 0, 2};\n#endif\n#ifdef WOLFSSL_SHA224\n    static const byte dhSinglePass_stdDH_sha224kdf_Oid[] = {43, 129, 4, 1, 11, 0};\n#endif\n#ifndef NO_SHA256\n    static const byte dhSinglePass_stdDH_sha256kdf_Oid[] = {43, 129, 4, 1, 11, 1};\n#endif\n#ifdef WOLFSSL_SHA384\n    static const byte dhSinglePass_stdDH_sha384kdf_Oid[] = {43, 129, 4, 1, 11, 2};\n#endif\n#ifdef WOLFSSL_SHA512\n    static const byte dhSinglePass_stdDH_sha512kdf_Oid[] = {43, 129, 4, 1, 11, 3};\n#endif\n\n/* ocspType */\n#ifdef HAVE_OCSP\n    static const byte ocspBasicOid[]    = {43, 6, 1, 5, 5, 7, 48, 1, 1};\n    static const byte ocspNonceOid[]    = {43, 6, 1, 5, 5, 7, 48, 1, 2};\n    static const byte ocspNoCheckOid[]  = {43, 6, 1, 5, 5, 7, 48, 1, 5};\n#endif /* HAVE_OCSP */\n\n/* certExtType */\nstatic const byte extBasicCaOid[] = {85, 29, 19};\nstatic const byte extAltNamesOid[] = {85, 29, 17};\nstatic const byte extCrlDistOid[] = {85, 29, 31};\nstatic const byte extAuthInfoOid[] = {43, 6, 1, 5, 5, 7, 1, 1};\nstatic const byte extAuthKeyOid[] = {85, 29, 35};\nstatic const byte extSubjKeyOid[] = {85, 29, 14};\nstatic const byte extCertPolicyOid[] = {85, 29, 32};\nstatic const byte extKeyUsageOid[] = {85, 29, 15};\nstatic const byte extInhibitAnyOid[] = {85, 29, 54};\nstatic const byte extExtKeyUsageOid[] = {85, 29, 37};\n#ifndef IGNORE_NAME_CONSTRAINTS\n    static const byte extNameConsOid[] = {85, 29, 30};\n#endif\n\n/* certAuthInfoType */\n#ifdef HAVE_OCSP\n    static const byte extAuthInfoOcspOid[] = {43, 6, 1, 5, 5, 7, 48, 1};\n#endif\nstatic const byte extAuthInfoCaIssuerOid[] = {43, 6, 1, 5, 5, 7, 48, 2};\n\n/* certPolicyType */\nstatic const byte extCertPolicyAnyOid[] = {85, 29, 32, 0};\n\n/* certKeyUseType */\nstatic const byte extAltNamesHwNameOid[] = {43, 6, 1, 5, 5, 7, 8, 4};\n\n/* certKeyUseType */\nstatic const byte extExtKeyUsageAnyOid[] = {85, 29, 37, 0};\nstatic const byte extExtKeyUsageServerAuthOid[]   = {43, 6, 1, 5, 5, 7, 3, 1};\nstatic const byte extExtKeyUsageClientAuthOid[]   = {43, 6, 1, 5, 5, 7, 3, 2};\nstatic const byte extExtKeyUsageCodeSigningOid[]  = {43, 6, 1, 5, 5, 7, 3, 3};\nstatic const byte extExtKeyUsageEmailProtectOid[] = {43, 6, 1, 5, 5, 7, 3, 4};\nstatic const byte extExtKeyUsageTimestampOid[]    = {43, 6, 1, 5, 5, 7, 3, 8};\nstatic const byte extExtKeyUsageOcspSignOid[]     = {43, 6, 1, 5, 5, 7, 3, 9};\n\n#ifdef WOLFSSL_CERT_REQ\n/* csrAttrType */\nstatic const byte attrChallengePasswordOid[] = {42, 134, 72, 134, 247, 13, 1, 9, 7};\nstatic const byte attrSerialNumberOid[] = {85, 4, 5};\n#endif\n\n/* kdfType */\nstatic const byte pbkdf2Oid[] = {42, 134, 72, 134, 247, 13, 1, 5, 12};\n\n/* PKCS5 */\n#if !defined(NO_DES3) && !defined(NO_SHA)\nstatic const byte pbeSha1Des[] = {42, 134, 72, 134, 247, 13, 1, 5, 10};\n#endif\nstatic const byte pbes2[] = {42, 134, 72, 134, 247, 13, 1, 5, 13};\n\n/* PKCS12 */\n#if !defined(NO_RC4) && !defined(NO_SHA)\nstatic const byte pbeSha1RC4128[] = {42, 134, 72, 134, 247, 13, 1, 12, 1, 1};\n#endif\n#if !defined(NO_DES3) && !defined(NO_SHA)\nstatic const byte pbeSha1Des3[] = {42, 134, 72, 134, 247, 13, 1, 12, 1, 3};\n#endif\n\n#ifdef HAVE_LIBZ\n/* zlib compression */\nstatic const byte zlibCompress[] = {42, 134, 72, 134, 247, 13, 1, 9, 16, 3, 8};\n#endif\n#ifdef WOLFSSL_APACHE_HTTPD\n/* tlsExtType */\nstatic const byte tlsFeatureOid[] = {43, 6, 1, 5, 5, 7, 1, 24};\n/* certNameType */\nstatic const byte dnsSRVOid[] = {43, 6, 1, 5, 5, 7, 8, 7};\n#endif\n\n\n/* returns a pointer to the OID string on success and NULL on fail */\nconst byte* OidFromId(word32 id, word32 type, word32* oidSz)\n{\n    const byte* oid = NULL;\n\n    *oidSz = 0;\n\n    switch (type) {\n\n        case oidHashType:\n            switch (id) {\n            #ifdef WOLFSSL_MD2\n                case MD2h:\n                    oid = hashMd2hOid;\n                    *oidSz = sizeof(hashMd2hOid);\n                    break;\n            #endif\n            #ifndef NO_MD5\n                case MD5h:\n                    oid = hashMd5hOid;\n                    *oidSz = sizeof(hashMd5hOid);\n                    break;\n            #endif\n            #ifndef NO_SHA\n                case SHAh:\n                    oid = hashSha1hOid;\n                    *oidSz = sizeof(hashSha1hOid);\n                    break;\n            #endif\n            #ifdef WOLFSSL_SHA224\n                case SHA224h:\n                    oid = hashSha224hOid;\n                    *oidSz = sizeof(hashSha224hOid);\n                    break;\n            #endif\n            #ifndef NO_SHA256\n                case SHA256h:\n                    oid = hashSha256hOid;\n                    *oidSz = sizeof(hashSha256hOid);\n                    break;\n            #endif\n            #ifdef WOLFSSL_SHA384\n                case SHA384h:\n                    oid = hashSha384hOid;\n                    *oidSz = sizeof(hashSha384hOid);\n                    break;\n            #endif\n            #ifdef WOLFSSL_SHA512\n                case SHA512h:\n                    oid = hashSha512hOid;\n                    *oidSz = sizeof(hashSha512hOid);\n                    break;\n            #endif\n            #ifdef WOLFSSL_SHA3\n            #ifndef WOLFSSL_NOSHA3_224\n                case SHA3_224h:\n                    oid = hashSha3_224hOid;\n                    *oidSz = sizeof(hashSha3_224hOid);\n                    break;\n            #endif /* WOLFSSL_NOSHA3_224 */\n            #ifndef WOLFSSL_NOSHA3_256\n                case SHA3_256h:\n                    oid = hashSha3_256hOid;\n                    *oidSz = sizeof(hashSha3_256hOid);\n                    break;\n            #endif /* WOLFSSL_NOSHA3_256 */\n            #ifndef WOLFSSL_NOSHA3_384\n                case SHA3_384h:\n                    oid = hashSha3_384hOid;\n                    *oidSz = sizeof(hashSha3_384hOid);\n                    break;\n            #endif /* WOLFSSL_NOSHA3_384 */\n            #ifndef WOLFSSL_NOSHA3_512\n                case SHA3_512h:\n                    oid = hashSha3_512hOid;\n                    *oidSz = sizeof(hashSha3_512hOid);\n                    break;\n            #endif /* WOLFSSL_NOSHA3_512 */\n            #endif /* WOLFSSL_SHA3 */\n                default:\n                    break;\n            }\n            break;\n\n        case oidSigType:\n            switch (id) {\n                #if !defined(NO_DSA) && !defined(NO_SHA)\n                case CTC_SHAwDSA:\n                    oid = sigSha1wDsaOid;\n                    *oidSz = sizeof(sigSha1wDsaOid);\n                    break;\n                case CTC_SHA256wDSA:\n                    oid = sigSha256wDsaOid;\n                    *oidSz = sizeof(sigSha256wDsaOid);\n                    break;\n                #endif /* NO_DSA */\n                #ifndef NO_RSA\n                #ifdef WOLFSSL_MD2\n                case CTC_MD2wRSA:\n                    oid = sigMd2wRsaOid;\n                    *oidSz = sizeof(sigMd2wRsaOid);\n                    break;\n                #endif\n                #ifndef NO_MD5\n                case CTC_MD5wRSA:\n                    oid = sigMd5wRsaOid;\n                    *oidSz = sizeof(sigMd5wRsaOid);\n                    break;\n                #endif\n                #ifndef NO_SHA\n                case CTC_SHAwRSA:\n                    oid = sigSha1wRsaOid;\n                    *oidSz = sizeof(sigSha1wRsaOid);\n                    break;\n                #endif\n                #ifdef WOLFSSL_SHA224\n                case CTC_SHA224wRSA:\n                    oid = sigSha224wRsaOid;\n                    *oidSz = sizeof(sigSha224wRsaOid);\n                    break;\n                #endif\n                #ifndef NO_SHA256\n                case CTC_SHA256wRSA:\n                    oid = sigSha256wRsaOid;\n                    *oidSz = sizeof(sigSha256wRsaOid);\n                    break;\n                #endif\n                #ifdef WOLFSSL_SHA384\n                case CTC_SHA384wRSA:\n                    oid = sigSha384wRsaOid;\n                    *oidSz = sizeof(sigSha384wRsaOid);\n                    break;\n                #endif\n                #ifdef WOLFSSL_SHA512\n                case CTC_SHA512wRSA:\n                    oid = sigSha512wRsaOid;\n                    *oidSz = sizeof(sigSha512wRsaOid);\n                    break;\n                #endif /* WOLFSSL_SHA512 */\n                #ifdef WOLFSSL_SHA3\n                #ifndef WOLFSSL_NOSHA3_224\n                case CTC_SHA3_224wRSA:\n                    oid = sigSha3_224wRsaOid;\n                    *oidSz = sizeof(sigSha3_224wRsaOid);\n                    break;\n                #endif\n                #ifndef WOLFSSL_NOSHA3_256\n                case CTC_SHA3_256wRSA:\n                    oid = sigSha3_256wRsaOid;\n                    *oidSz = sizeof(sigSha3_256wRsaOid);\n                    break;\n                #endif\n                #ifndef WOLFSSL_NOSHA3_384\n                case CTC_SHA3_384wRSA:\n                    oid = sigSha3_384wRsaOid;\n                    *oidSz = sizeof(sigSha3_384wRsaOid);\n                    break;\n                #endif\n                #ifndef WOLFSSL_NOSHA3_512\n                case CTC_SHA3_512wRSA:\n                    oid = sigSha3_512wRsaOid;\n                    *oidSz = sizeof(sigSha3_512wRsaOid);\n                    break;\n                #endif\n                #endif\n                #endif /* NO_RSA */\n                #ifdef HAVE_ECC\n                #ifndef NO_SHA\n                case CTC_SHAwECDSA:\n                    oid = sigSha1wEcdsaOid;\n                    *oidSz = sizeof(sigSha1wEcdsaOid);\n                    break;\n                #endif\n                #ifdef WOLFSSL_SHA224\n                case CTC_SHA224wECDSA:\n                    oid = sigSha224wEcdsaOid;\n                    *oidSz = sizeof(sigSha224wEcdsaOid);\n                    break;\n                #endif\n                #ifndef NO_SHA256\n                case CTC_SHA256wECDSA:\n                    oid = sigSha256wEcdsaOid;\n                    *oidSz = sizeof(sigSha256wEcdsaOid);\n                    break;\n                #endif\n                #ifdef WOLFSSL_SHA384\n                case CTC_SHA384wECDSA:\n                    oid = sigSha384wEcdsaOid;\n                    *oidSz = sizeof(sigSha384wEcdsaOid);\n                    break;\n                #endif\n                #ifdef WOLFSSL_SHA512\n                case CTC_SHA512wECDSA:\n                    oid = sigSha512wEcdsaOid;\n                    *oidSz = sizeof(sigSha512wEcdsaOid);\n                    break;\n                #endif\n                #ifdef WOLFSSL_SHA3\n                #ifndef WOLFSSL_NOSHA3_224\n                case CTC_SHA3_224wECDSA:\n                    oid = sigSha3_224wEcdsaOid;\n                    *oidSz = sizeof(sigSha3_224wEcdsaOid);\n                    break;\n                #endif\n                #ifndef WOLFSSL_NOSHA3_256\n                case CTC_SHA3_256wECDSA:\n                    oid = sigSha3_256wEcdsaOid;\n                    *oidSz = sizeof(sigSha3_256wEcdsaOid);\n                    break;\n                #endif\n                #ifndef WOLFSSL_NOSHA3_384\n                case CTC_SHA3_384wECDSA:\n                    oid = sigSha3_384wEcdsaOid;\n                    *oidSz = sizeof(sigSha3_384wEcdsaOid);\n                    break;\n                #endif\n                #ifndef WOLFSSL_NOSHA3_512\n                case CTC_SHA3_512wECDSA:\n                    oid = sigSha3_512wEcdsaOid;\n                    *oidSz = sizeof(sigSha3_512wEcdsaOid);\n                    break;\n                #endif\n                #endif\n                #endif /* HAVE_ECC */\n                #ifdef HAVE_ED25519\n                case CTC_ED25519:\n                    oid = sigEd25519Oid;\n                    *oidSz = sizeof(sigEd25519Oid);\n                    break;\n                #endif\n                #ifdef HAVE_ED448\n                case CTC_ED448:\n                    oid = sigEd448Oid;\n                    *oidSz = sizeof(sigEd448Oid);\n                    break;\n                #endif\n                default:\n                    break;\n            }\n            break;\n\n        case oidKeyType:\n            switch (id) {\n                #ifndef NO_DSA\n                case DSAk:\n                    oid = keyDsaOid;\n                    *oidSz = sizeof(keyDsaOid);\n                    break;\n                #endif /* NO_DSA */\n                #ifndef NO_RSA\n                case RSAk:\n                    oid = keyRsaOid;\n                    *oidSz = sizeof(keyRsaOid);\n                    break;\n                #endif /* NO_RSA */\n                #ifdef HAVE_NTRU\n                case NTRUk:\n                    oid = keyNtruOid;\n                    *oidSz = sizeof(keyNtruOid);\n                    break;\n                #endif /* HAVE_NTRU */\n                #ifdef HAVE_ECC\n                case ECDSAk:\n                    oid = keyEcdsaOid;\n                    *oidSz = sizeof(keyEcdsaOid);\n                    break;\n                #endif /* HAVE_ECC */\n                #ifdef HAVE_ED25519\n                case ED25519k:\n                    oid = keyEd25519Oid;\n                    *oidSz = sizeof(keyEd25519Oid);\n                    break;\n                #endif /* HAVE_ED25519 */\n                #ifdef HAVE_ED448\n                case ED448k:\n                    oid = keyEd448Oid;\n                    *oidSz = sizeof(keyEd448Oid);\n                    break;\n                #endif /* HAVE_ED448 */\n                #ifndef NO_DH\n                case DHk:\n                    oid = keyDhOid;\n                    *oidSz = sizeof(keyDhOid);\n                    break;\n                #endif /* !NO_DH */\n                default:\n                    break;\n            }\n            break;\n\n        #ifdef HAVE_ECC\n        case oidCurveType:\n            if (wc_ecc_get_oid(id, &oid, oidSz) < 0) {\n                WOLFSSL_MSG(\"ECC OID not found\");\n            }\n            break;\n        #endif /* HAVE_ECC */\n\n        case oidBlkType:\n            switch (id) {\n    #ifdef HAVE_AES_CBC\n        #ifdef WOLFSSL_AES_128\n                case AES128CBCb:\n                    oid = blkAes128CbcOid;\n                    *oidSz = sizeof(blkAes128CbcOid);\n                    break;\n        #endif\n        #ifdef WOLFSSL_AES_192\n                case AES192CBCb:\n                    oid = blkAes192CbcOid;\n                    *oidSz = sizeof(blkAes192CbcOid);\n                    break;\n        #endif\n        #ifdef WOLFSSL_AES_256\n                case AES256CBCb:\n                    oid = blkAes256CbcOid;\n                    *oidSz = sizeof(blkAes256CbcOid);\n                    break;\n        #endif\n    #endif /* HAVE_AES_CBC */\n    #ifdef HAVE_AESGCM\n        #ifdef WOLFSSL_AES_128\n                case AES128GCMb:\n                    oid = blkAes128GcmOid;\n                    *oidSz = sizeof(blkAes128GcmOid);\n                    break;\n        #endif\n        #ifdef WOLFSSL_AES_192\n                case AES192GCMb:\n                    oid = blkAes192GcmOid;\n                    *oidSz = sizeof(blkAes192GcmOid);\n                    break;\n        #endif\n        #ifdef WOLFSSL_AES_256\n                case AES256GCMb:\n                    oid = blkAes256GcmOid;\n                    *oidSz = sizeof(blkAes256GcmOid);\n                    break;\n        #endif\n    #endif /* HAVE_AESGCM */\n    #ifdef HAVE_AESCCM\n        #ifdef WOLFSSL_AES_128\n                case AES128CCMb:\n                    oid = blkAes128CcmOid;\n                    *oidSz = sizeof(blkAes128CcmOid);\n                    break;\n        #endif\n        #ifdef WOLFSSL_AES_192\n                case AES192CCMb:\n                    oid = blkAes192CcmOid;\n                    *oidSz = sizeof(blkAes192CcmOid);\n                    break;\n        #endif\n        #ifdef WOLFSSL_AES_256\n                case AES256CCMb:\n                    oid = blkAes256CcmOid;\n                    *oidSz = sizeof(blkAes256CcmOid);\n                    break;\n        #endif\n    #endif /* HAVE_AESCCM */\n    #ifndef NO_DES3\n                case DESb:\n                    oid = blkDesCbcOid;\n                    *oidSz = sizeof(blkDesCbcOid);\n                    break;\n                case DES3b:\n                    oid = blkDes3CbcOid;\n                    *oidSz = sizeof(blkDes3CbcOid);\n                    break;\n    #endif /* !NO_DES3 */\n                default:\n                    break;\n            }\n            break;\n\n        #ifdef HAVE_OCSP\n        case oidOcspType:\n            switch (id) {\n                case OCSP_BASIC_OID:\n                    oid = ocspBasicOid;\n                    *oidSz = sizeof(ocspBasicOid);\n                    break;\n                case OCSP_NONCE_OID:\n                    oid = ocspNonceOid;\n                    *oidSz = sizeof(ocspNonceOid);\n                    break;\n                default:\n                    break;\n            }\n            break;\n        #endif /* HAVE_OCSP */\n\n        case oidCertExtType:\n            switch (id) {\n                case BASIC_CA_OID:\n                    oid = extBasicCaOid;\n                    *oidSz = sizeof(extBasicCaOid);\n                    break;\n                case ALT_NAMES_OID:\n                    oid = extAltNamesOid;\n                    *oidSz = sizeof(extAltNamesOid);\n                    break;\n                case CRL_DIST_OID:\n                    oid = extCrlDistOid;\n                    *oidSz = sizeof(extCrlDistOid);\n                    break;\n                case AUTH_INFO_OID:\n                    oid = extAuthInfoOid;\n                    *oidSz = sizeof(extAuthInfoOid);\n                    break;\n                case AUTH_KEY_OID:\n                    oid = extAuthKeyOid;\n                    *oidSz = sizeof(extAuthKeyOid);\n                    break;\n                case SUBJ_KEY_OID:\n                    oid = extSubjKeyOid;\n                    *oidSz = sizeof(extSubjKeyOid);\n                    break;\n                case CERT_POLICY_OID:\n                    oid = extCertPolicyOid;\n                    *oidSz = sizeof(extCertPolicyOid);\n                    break;\n                case KEY_USAGE_OID:\n                    oid = extKeyUsageOid;\n                    *oidSz = sizeof(extKeyUsageOid);\n                    break;\n                case INHIBIT_ANY_OID:\n                    oid = extInhibitAnyOid;\n                    *oidSz = sizeof(extInhibitAnyOid);\n                    break;\n                case EXT_KEY_USAGE_OID:\n                    oid = extExtKeyUsageOid;\n                    *oidSz = sizeof(extExtKeyUsageOid);\n                    break;\n            #ifndef IGNORE_NAME_CONSTRAINTS\n                case NAME_CONS_OID:\n                    oid = extNameConsOid;\n                    *oidSz = sizeof(extNameConsOid);\n                    break;\n            #endif\n            #ifdef HAVE_OCSP\n                case OCSP_NOCHECK_OID:\n                    oid = ocspNoCheckOid;\n                    *oidSz = sizeof(ocspNoCheckOid);\n                    break;\n            #endif\n                default:\n                    break;\n            }\n            break;\n\n        case oidCrlExtType:\n            #ifdef HAVE_CRL\n            switch (id) {\n                case AUTH_KEY_OID:\n                    oid = extAuthKeyOid;\n                    *oidSz = sizeof(extAuthKeyOid);\n                    break;\n                default:\n                    break;\n            }\n            #endif\n            break;\n\n        case oidCertAuthInfoType:\n            switch (id) {\n            #ifdef HAVE_OCSP\n                case AIA_OCSP_OID:\n                    oid = extAuthInfoOcspOid;\n                    *oidSz = sizeof(extAuthInfoOcspOid);\n                    break;\n            #endif\n                case AIA_CA_ISSUER_OID:\n                    oid = extAuthInfoCaIssuerOid;\n                    *oidSz = sizeof(extAuthInfoCaIssuerOid);\n                    break;\n                default:\n                    break;\n            }\n            break;\n\n        case oidCertPolicyType:\n            switch (id) {\n                case CP_ANY_OID:\n                    oid = extCertPolicyAnyOid;\n                    *oidSz = sizeof(extCertPolicyAnyOid);\n                    break;\n                default:\n                    break;\n            }\n            break;\n\n        case oidCertAltNameType:\n            switch (id) {\n                case HW_NAME_OID:\n                    oid = extAltNamesHwNameOid;\n                    *oidSz = sizeof(extAltNamesHwNameOid);\n                    break;\n                default:\n                    break;\n            }\n            break;\n\n        case oidCertKeyUseType:\n            switch (id) {\n                case EKU_ANY_OID:\n                    oid = extExtKeyUsageAnyOid;\n                    *oidSz = sizeof(extExtKeyUsageAnyOid);\n                    break;\n                case EKU_SERVER_AUTH_OID:\n                    oid = extExtKeyUsageServerAuthOid;\n                    *oidSz = sizeof(extExtKeyUsageServerAuthOid);\n                    break;\n                case EKU_CLIENT_AUTH_OID:\n                    oid = extExtKeyUsageClientAuthOid;\n                    *oidSz = sizeof(extExtKeyUsageClientAuthOid);\n                    break;\n                case EKU_CODESIGNING_OID:\n                    oid = extExtKeyUsageCodeSigningOid;\n                    *oidSz = sizeof(extExtKeyUsageCodeSigningOid);\n                    break;\n                case EKU_EMAILPROTECT_OID:\n                    oid = extExtKeyUsageEmailProtectOid;\n                    *oidSz = sizeof(extExtKeyUsageEmailProtectOid);\n                    break;\n                case EKU_TIMESTAMP_OID:\n                    oid = extExtKeyUsageTimestampOid;\n                    *oidSz = sizeof(extExtKeyUsageTimestampOid);\n                    break;\n                case EKU_OCSP_SIGN_OID:\n                    oid = extExtKeyUsageOcspSignOid;\n                    *oidSz = sizeof(extExtKeyUsageOcspSignOid);\n                    break;\n                default:\n                    break;\n            }\n            break;\n\n        case oidKdfType:\n            switch (id) {\n                case PBKDF2_OID:\n                    oid = pbkdf2Oid;\n                    *oidSz = sizeof(pbkdf2Oid);\n                    break;\n                default:\n                    break;\n            }\n            break;\n\n        case oidPBEType:\n            switch (id) {\n        #if !defined(NO_SHA) && !defined(NO_RC4)\n                case PBE_SHA1_RC4_128:\n                    oid = pbeSha1RC4128;\n                    *oidSz = sizeof(pbeSha1RC4128);\n                    break;\n        #endif\n        #if !defined(NO_SHA) && !defined(NO_DES3)\n                case PBE_SHA1_DES:\n                    oid = pbeSha1Des;\n                    *oidSz = sizeof(pbeSha1Des);\n                    break;\n\n        #endif\n        #if !defined(NO_SHA) && !defined(NO_DES3)\n                case PBE_SHA1_DES3:\n                    oid = pbeSha1Des3;\n                    *oidSz = sizeof(pbeSha1Des3);\n                    break;\n        #endif\n                case PBES2:\n                    oid = pbes2;\n                    *oidSz = sizeof(pbes2);\n                    break;\n                default:\n                    break;\n            }\n            break;\n\n        case oidKeyWrapType:\n            switch (id) {\n            #ifdef WOLFSSL_AES_128\n                case AES128_WRAP:\n                    oid = wrapAes128Oid;\n                    *oidSz = sizeof(wrapAes128Oid);\n                    break;\n            #endif\n            #ifdef WOLFSSL_AES_192\n                case AES192_WRAP:\n                    oid = wrapAes192Oid;\n                    *oidSz = sizeof(wrapAes192Oid);\n                    break;\n            #endif\n            #ifdef WOLFSSL_AES_256\n                case AES256_WRAP:\n                    oid = wrapAes256Oid;\n                    *oidSz = sizeof(wrapAes256Oid);\n                    break;\n            #endif\n            #ifdef HAVE_PKCS7\n                case PWRI_KEK_WRAP:\n                    oid = wrapPwriKekOid;\n                    *oidSz = sizeof(wrapPwriKekOid);\n                    break;\n            #endif\n                default:\n                    break;\n            }\n            break;\n\n        case oidCmsKeyAgreeType:\n            switch (id) {\n            #ifndef NO_SHA\n                case dhSinglePass_stdDH_sha1kdf_scheme:\n                    oid = dhSinglePass_stdDH_sha1kdf_Oid;\n                    *oidSz = sizeof(dhSinglePass_stdDH_sha1kdf_Oid);\n                    break;\n            #endif\n            #ifdef WOLFSSL_SHA224\n                case dhSinglePass_stdDH_sha224kdf_scheme:\n                    oid = dhSinglePass_stdDH_sha224kdf_Oid;\n                    *oidSz = sizeof(dhSinglePass_stdDH_sha224kdf_Oid);\n                    break;\n            #endif\n            #ifndef NO_SHA256\n                case dhSinglePass_stdDH_sha256kdf_scheme:\n                    oid = dhSinglePass_stdDH_sha256kdf_Oid;\n                    *oidSz = sizeof(dhSinglePass_stdDH_sha256kdf_Oid);\n                    break;\n            #endif\n            #ifdef WOLFSSL_SHA384\n                case dhSinglePass_stdDH_sha384kdf_scheme:\n                    oid = dhSinglePass_stdDH_sha384kdf_Oid;\n                    *oidSz = sizeof(dhSinglePass_stdDH_sha384kdf_Oid);\n                    break;\n            #endif\n            #ifdef WOLFSSL_SHA512\n                case dhSinglePass_stdDH_sha512kdf_scheme:\n                    oid = dhSinglePass_stdDH_sha512kdf_Oid;\n                    *oidSz = sizeof(dhSinglePass_stdDH_sha512kdf_Oid);\n                    break;\n            #endif\n                default:\n                    break;\n            }\n            break;\n\n#ifndef NO_HMAC\n        case oidHmacType:\n            switch (id) {\n        #ifdef WOLFSSL_SHA224\n                case HMAC_SHA224_OID:\n                    oid = hmacSha224Oid;\n                    *oidSz = sizeof(hmacSha224Oid);\n                    break;\n        #endif\n        #ifndef NO_SHA256\n                case HMAC_SHA256_OID:\n                    oid = hmacSha256Oid;\n                    *oidSz = sizeof(hmacSha256Oid);\n                    break;\n        #endif\n        #ifdef WOLFSSL_SHA384\n                case HMAC_SHA384_OID:\n                    oid = hmacSha384Oid;\n                    *oidSz = sizeof(hmacSha384Oid);\n                    break;\n        #endif\n        #ifdef WOLFSSL_SHA512\n                case HMAC_SHA512_OID:\n                    oid = hmacSha512Oid;\n                    *oidSz = sizeof(hmacSha512Oid);\n                    break;\n        #endif\n                default:\n                    break;\n            }\n            break;\n#endif /* !NO_HMAC */\n\n#ifdef HAVE_LIBZ\n        case oidCompressType:\n            switch (id) {\n                case ZLIBc:\n                    oid = zlibCompress;\n                    *oidSz = sizeof(zlibCompress);\n                    break;\n                default:\n                    break;\n            }\n            break;\n#endif /* HAVE_LIBZ */\n#ifdef WOLFSSL_APACHE_HTTPD\n        case oidCertNameType:\n            switch (id) {\n                 case NID_id_on_dnsSRV:\n                    oid = dnsSRVOid;\n                    *oidSz = sizeof(dnsSRVOid);\n                    break;\n                default:\n                    break;\n            }\n            break;\n        case oidTlsExtType:\n            switch (id) {\n                case TLS_FEATURE_OID:\n                    oid = tlsFeatureOid;\n                    *oidSz = sizeof(tlsFeatureOid);\n                    break;\n                default:\n                    break;\n            }\n            break;\n#endif /* WOLFSSL_APACHE_HTTPD */\n#ifdef WOLFSSL_CERT_REQ\n        case oidCsrAttrType:\n            switch (id) {\n                case CHALLENGE_PASSWORD_OID:\n                    oid = attrChallengePasswordOid;\n                    *oidSz = sizeof(attrChallengePasswordOid);\n                    break;\n                case SERIAL_NUMBER_OID:\n                    oid = attrSerialNumberOid;\n                    *oidSz = sizeof(attrSerialNumberOid);\n                    break;\n                default:\n                    break;\n            }\n            break;\n#endif\n        case oidIgnoreType:\n        default:\n            break;\n    }\n\n    return oid;\n}\n\n#ifdef HAVE_OID_ENCODING\nint EncodeObjectId(const word16* in, word32 inSz, byte* out, word32* outSz)\n{\n    int i, x, len;\n    word32 d, t;\n\n    /* check args */\n    if (in == NULL || outSz == NULL) {\n        return BAD_FUNC_ARG;\n    }\n\n    /* compute length of encoded OID */\n    d = (in[0] * 40) + in[1];\n    len = 0;\n    for (i = 1; i < (int)inSz; i++) {\n        x = 0;\n        t = d;\n        while (t) {\n            x++;\n            t >>= 1;\n        }\n        len += (x / 7) + ((x % 7) ? 1 : 0) + (d == 0 ? 1 : 0);\n\n        if (i < (int)inSz - 1) {\n            d = in[i + 1];\n        }\n    }\n\n    if (out) {\n        /* verify length */\n        if ((int)*outSz < len) {\n            return BUFFER_E; /* buffer provided is not large enough */\n        }\n\n        /* calc first byte */\n        d = (in[0] * 40) + in[1];\n\n        /* encode bytes */\n        x = 0;\n        for (i = 1; i < (int)inSz; i++) {\n            if (d) {\n                int y = x, z;\n                byte mask = 0;\n                while (d) {\n                    out[x++] = (byte)((d & 0x7F) | mask);\n                    d     >>= 7;\n                    mask  |= 0x80;  /* upper bit is set on all but the last byte */\n                }\n                /* now swap bytes y...x-1 */\n                z = x - 1;\n                while (y < z) {\n                    mask = out[y];\n                    out[y] = out[z];\n                    out[z] = mask;\n                    ++y;\n                    --z;\n                }\n            }\n            else {\n              out[x++] = 0x00; /* zero value */\n            }\n\n            /* next word */\n            if (i < (int)inSz - 1) {\n                d = in[i + 1];\n            }\n        }\n    }\n\n    /* return length */\n    *outSz = len;\n\n    return 0;\n}\n#endif /* HAVE_OID_ENCODING */\n\n#ifdef HAVE_OID_DECODING\nint DecodeObjectId(const byte* in, word32 inSz, word16* out, word32* outSz)\n{\n    int x = 0, y = 0;\n    word32 t = 0;\n\n    /* check args */\n    if (in == NULL || outSz == NULL) {\n        return BAD_FUNC_ARG;\n    }\n\n    /* decode bytes */\n    while (inSz--) {\n        t = (t << 7) | (in[x] & 0x7F);\n        if (!(in[x] & 0x80)) {\n            if (y >= (int)*outSz) {\n                return BUFFER_E;\n            }\n            if (y == 0) {\n                out[0] = (t / 40);\n                out[1] = (t % 40);\n                y = 2;\n            }\n            else {\n                out[y++] = t;\n            }\n            t = 0; /* reset tmp */\n        }\n        x++;\n    }\n\n    /* return length */\n    *outSz = y;\n\n    return 0;\n}\n#endif /* HAVE_OID_DECODING */\n\n/* Get the DER/BER encoding of an ASN.1 OBJECT_ID header.\n *\n * input     Buffer holding DER/BER encoded data.\n * inOutIdx  Current index into buffer to parse.\n * len       The number of bytes in the ASN.1 data.\n * maxIdx    Length of data in buffer.\n * returns BUFFER_E when there is not enough data to parse.\n *         ASN_OBJECt_ID_E when the OBJECT_ID tag is not found.\n *         ASN_PARSE_E when length is invalid.\n *         Otherwise, 0 to indicate success.\n */\nint GetASNObjectId(const byte* input, word32* inOutIdx, int* len,\n                          word32 maxIdx)\n{\n    word32 idx = *inOutIdx;\n    int    length;\n    byte   tag;\n\n    if ((idx + 1) > maxIdx)\n        return BUFFER_E;\n\n    if (GetASNTag(input, &idx, &tag, maxIdx) != 0)\n        return ASN_PARSE_E;\n\n    if (tag != ASN_OBJECT_ID)\n        return ASN_OBJECT_ID_E;\n\n    if (GetLength(input, &idx, &length, maxIdx) < 0)\n        return ASN_PARSE_E;\n\n    *len = length;\n    *inOutIdx = idx;\n    return 0;\n}\n\n/* Set the DER/BER encoding of the ASN.1 OBJECT_ID header.\n *\n * len         Length of the OBJECT_ID data.\n * output      Buffer to write into.\n * returns the number of bytes added to the buffer.\n */\nint SetObjectId(int len, byte* output)\n{\n    int idx = 0;\n\n    if (output)\n        output[idx++] = ASN_OBJECT_ID;\n    else\n        idx++;\n    idx += SetLength(len, output ? output + idx : NULL);\n\n    return idx;\n}\n\nint GetObjectId(const byte* input, word32* inOutIdx, word32* oid,\n                                  word32 oidType, word32 maxIdx)\n{\n    int    ret = 0, length;\n    word32 idx = *inOutIdx;\n#ifndef NO_VERIFY_OID\n    word32 actualOidSz = 0;\n    const byte* actualOid;\n#endif /* NO_VERIFY_OID */\n\n    (void)oidType;\n    WOLFSSL_ENTER(\"GetObjectId()\");\n    *oid = 0;\n\n    ret = GetASNObjectId(input, &idx, &length, maxIdx);\n    if (ret != 0)\n        return ret;\n\n#ifndef NO_VERIFY_OID\n    actualOid = &input[idx];\n    if (length > 0)\n        actualOidSz = (word32)length;\n#endif /* NO_VERIFY_OID */\n\n    while (length--) {\n        /* odd HC08 compiler behavior here when input[idx++] */\n        *oid += (word32)input[idx];\n        idx++;\n    }\n    /* just sum it up for now */\n\n    *inOutIdx = idx;\n\n#ifndef NO_VERIFY_OID\n    {\n        const byte* checkOid = NULL;\n        word32 checkOidSz;\n    #ifdef ASN_DUMP_OID\n        word32 i;\n    #endif\n\n        if (oidType != oidIgnoreType) {\n            checkOid = OidFromId(*oid, oidType, &checkOidSz);\n\n        #ifdef ASN_DUMP_OID\n            /* support for dumping OID information */\n            printf(\"OID (Type %d, Sz %d, Sum %d): \", oidType, actualOidSz, *oid);\n            for (i=0; i<actualOidSz; i++) {\n                printf(\"%d, \", actualOid[i]);\n            }\n            printf(\"\\n\");\n            #ifdef HAVE_OID_DECODING\n            {\n                word16 decOid[16];\n                word32 decOidSz = sizeof(decOid);\n                ret = DecodeObjectId(actualOid, actualOidSz, decOid, &decOidSz);\n                if (ret == 0) {\n                    printf(\"  Decoded (Sz %d): \", decOidSz);\n                    for (i=0; i<decOidSz; i++) {\n                        printf(\"%d.\", decOid[i]);\n                    }\n                    printf(\"\\n\");\n                }\n                else {\n                    printf(\"DecodeObjectId failed: %d\\n\", ret);\n                }\n            }\n            #endif /* HAVE_OID_DECODING */\n        #endif /* ASN_DUMP_OID */\n\n            if (checkOid != NULL &&\n                (checkOidSz != actualOidSz ||\n                    XMEMCMP(actualOid, checkOid, checkOidSz) != 0)) {\n                WOLFSSL_MSG(\"OID Check Failed\");\n                return ASN_UNKNOWN_OID_E;\n            }\n        }\n    }\n#endif /* NO_VERIFY_OID */\n\n    return ret;\n}\n\nstatic int SkipObjectId(const byte* input, word32* inOutIdx, word32 maxIdx)\n{\n    word32 idx = *inOutIdx;\n    int    length;\n    int ret;\n\n    ret = GetASNObjectId(input, &idx, &length, maxIdx);\n    if (ret != 0)\n        return ret;\n\n    idx += length;\n    *inOutIdx = idx;\n\n    return 0;\n}\n\nint GetAlgoId(const byte* input, word32* inOutIdx, word32* oid,\n                     word32 oidType, word32 maxIdx)\n{\n    int    length;\n    word32 idx = *inOutIdx;\n    int    ret;\n    *oid = 0;\n\n    WOLFSSL_ENTER(\"GetAlgoId\");\n\n    if (GetSequence(input, &idx, &length, maxIdx) < 0)\n        return ASN_PARSE_E;\n\n    if (GetObjectId(input, &idx, oid, oidType, maxIdx) < 0)\n        return ASN_OBJECT_ID_E;\n\n    /* could have NULL tag and 0 terminator, but may not */\n    if (idx < maxIdx) {\n        word32 localIdx = idx; /*use localIdx to not advance when checking tag*/\n        byte   tag;\n\n        if (GetASNTag(input, &localIdx, &tag, maxIdx) == 0) {\n            if (tag == ASN_TAG_NULL) {\n                ret = GetASNNull(input, &idx, maxIdx);\n                if (ret != 0)\n                    return ret;\n            }\n        }\n    }\n\n    *inOutIdx = idx;\n\n    return 0;\n}\n\n#ifndef NO_RSA\n\n#ifndef HAVE_USER_RSA\nint wc_RsaPrivateKeyDecode(const byte* input, word32* inOutIdx, RsaKey* key,\n                        word32 inSz)\n{\n    int version, length;\n\n    if (inOutIdx == NULL || input == NULL || key == NULL) {\n        return BAD_FUNC_ARG;\n    }\n    if (GetSequence(input, inOutIdx, &length, inSz) < 0)\n        return ASN_PARSE_E;\n\n    if (GetMyVersion(input, inOutIdx, &version, inSz) < 0)\n        return ASN_PARSE_E;\n\n    key->type = RSA_PRIVATE;\n\n    if (GetInt(&key->n,  input, inOutIdx, inSz) < 0 ||\n        GetInt(&key->e,  input, inOutIdx, inSz) < 0 ||\n#ifndef WOLFSSL_RSA_PUBLIC_ONLY\n        GetInt(&key->d,  input, inOutIdx, inSz) < 0 ||\n        GetInt(&key->p,  input, inOutIdx, inSz) < 0 ||\n        GetInt(&key->q,  input, inOutIdx, inSz) < 0)\n#else\n        SkipInt(input, inOutIdx, inSz) < 0 ||\n        SkipInt(input, inOutIdx, inSz) < 0 ||\n        SkipInt(input, inOutIdx, inSz) < 0 )\n\n#endif\n            return ASN_RSA_KEY_E;\n#if (defined(WOLFSSL_KEY_GEN) || defined(OPENSSL_EXTRA) || !defined(RSA_LOW_MEM)) \\\n    && !defined(WOLFSSL_RSA_PUBLIC_ONLY)\n    if (GetInt(&key->dP, input, inOutIdx, inSz) < 0 ||\n        GetInt(&key->dQ, input, inOutIdx, inSz) < 0 ||\n        GetInt(&key->u,  input, inOutIdx, inSz) < 0 )  return ASN_RSA_KEY_E;\n#else\n    if (SkipInt(input, inOutIdx, inSz) < 0 ||\n        SkipInt(input, inOutIdx, inSz) < 0 ||\n        SkipInt(input, inOutIdx, inSz) < 0 )  return ASN_RSA_KEY_E;\n#endif\n\n#if defined(WOLFSSL_XILINX_CRYPT) || defined(WOLFSSL_CRYPTOCELL)\n    if (wc_InitRsaHw(key) != 0) {\n        return BAD_STATE_E;\n    }\n#endif\n\n    return 0;\n}\n#endif /* HAVE_USER_RSA */\n#endif /* NO_RSA */\n\n#if defined(HAVE_PKCS8) || defined(HAVE_PKCS12)\n\n/* Remove PKCS8 header, place inOutIdx at beginning of traditional,\n * return traditional length on success, negative on error */\nint ToTraditionalInline_ex(const byte* input, word32* inOutIdx, word32 sz,\n                           word32* algId)\n{\n    word32 idx;\n    int    version, length;\n    int    ret;\n    byte   tag;\n\n    if (input == NULL || inOutIdx == NULL)\n        return BAD_FUNC_ARG;\n\n    idx = *inOutIdx;\n\n    if (GetSequence(input, &idx, &length, sz) < 0)\n        return ASN_PARSE_E;\n\n    if (GetMyVersion(input, &idx, &version, sz) < 0)\n        return ASN_PARSE_E;\n\n    if (GetAlgoId(input, &idx, algId, oidKeyType, sz) < 0)\n        return ASN_PARSE_E;\n\n    if (GetASNTag(input, &idx, &tag, sz) < 0)\n        return ASN_PARSE_E;\n    idx = idx - 1; /* reset idx after finding tag */\n\n    if (tag == ASN_OBJECT_ID) {\n        if (SkipObjectId(input, &idx, sz) < 0)\n            return ASN_PARSE_E;\n    }\n\n    ret = GetOctetString(input, &idx, &length, sz);\n    if (ret < 0) {\n        if (ret == BUFFER_E)\n            return ASN_PARSE_E;\n        /* Some private keys don't expect an octet string */\n        WOLFSSL_MSG(\"Couldn't find Octet string\");\n    }\n\n    *inOutIdx = idx;\n\n    return length;\n}\n\nint ToTraditionalInline(const byte* input, word32* inOutIdx, word32 sz)\n{\n    word32 oid;\n\n    return ToTraditionalInline_ex(input, inOutIdx, sz, &oid);\n}\n\n/* Remove PKCS8 header, move beginning of traditional to beginning of input */\nint ToTraditional_ex(byte* input, word32 sz, word32* algId)\n{\n    word32 inOutIdx = 0;\n    int    length;\n\n    if (input == NULL)\n        return BAD_FUNC_ARG;\n\n    length = ToTraditionalInline_ex(input, &inOutIdx, sz, algId);\n    if (length < 0)\n        return length;\n\n    if (length + inOutIdx > sz)\n        return BUFFER_E;\n\n    XMEMMOVE(input, input + inOutIdx, length);\n\n    return length;\n}\n\nint ToTraditional(byte* input, word32 sz)\n{\n    word32 oid;\n\n    return ToTraditional_ex(input, sz, &oid);\n}\n\n#endif /* HAVE_PKCS8 || HAVE_PKCS12 */\n\n#if defined(HAVE_PKCS8) && !defined(NO_CERTS)\n\nint wc_GetPkcs8TraditionalOffset(byte* input, word32* inOutIdx, word32 sz)\n{\n    int length;\n    word32 algId;\n\n    if (input == NULL || inOutIdx == NULL || (*inOutIdx > sz))\n        return BAD_FUNC_ARG;\n\n    length = ToTraditionalInline_ex(input, inOutIdx, sz, &algId);\n\n    return length;\n}\n\nint wc_CreatePKCS8Key(byte* out, word32* outSz, byte* key, word32 keySz,\n        int algoID, const byte* curveOID, word32 oidSz)\n{\n        word32 keyIdx = 0;\n        word32 tmpSz  = 0;\n        word32 sz;\n\n\n        /* If out is NULL then return the max size needed\n         * + 2 for ASN_OBJECT_ID and ASN_OCTET_STRING tags */\n        if (out == NULL && outSz != NULL) {\n            *outSz = keySz + MAX_SEQ_SZ + MAX_VERSION_SZ + MAX_ALGO_SZ\n                     + MAX_LENGTH_SZ + MAX_LENGTH_SZ + 2;\n\n            if (curveOID != NULL)\n                *outSz += oidSz + MAX_LENGTH_SZ + 1;\n\n            WOLFSSL_MSG(\"Checking size of PKCS8\");\n\n            return LENGTH_ONLY_E;\n        }\n\n        WOLFSSL_ENTER(\"wc_CreatePKCS8Key()\");\n\n        if (key == NULL || out == NULL || outSz == NULL) {\n            return BAD_FUNC_ARG;\n        }\n\n        /* check the buffer has enough room for largest possible size */\n        if (curveOID != NULL) {\n            if (*outSz < (keySz + MAX_SEQ_SZ + MAX_VERSION_SZ + MAX_ALGO_SZ\n                   + MAX_LENGTH_SZ + MAX_LENGTH_SZ + 3 + oidSz + MAX_LENGTH_SZ))\n                return BUFFER_E;\n        }\n        else {\n            oidSz = 0; /* with no curveOID oid size must be 0 */\n            if (*outSz < (keySz + MAX_SEQ_SZ + MAX_VERSION_SZ + MAX_ALGO_SZ\n                      + MAX_LENGTH_SZ + MAX_LENGTH_SZ + 2))\n                return BUFFER_E;\n        }\n\n        /* PrivateKeyInfo ::= SEQUENCE */\n        keyIdx += MAX_SEQ_SZ; /* save room for sequence */\n\n        /*  version Version\n         *  no header information just INTEGER */\n        sz = SetMyVersion(PKCS8v0, out + keyIdx, 0);\n        tmpSz += sz; keyIdx += sz;\n        /*  privateKeyAlgorithm PrivateKeyAlgorithmIdentifier */\n        sz = 0; /* set sz to 0 and get privateKey oid buffer size needed */\n        if (curveOID != NULL && oidSz > 0) {\n            byte buf[MAX_LENGTH_SZ];\n            sz = SetLength(oidSz, buf);\n            sz += 1; /* plus one for ASN object id */\n        }\n        sz = SetAlgoID(algoID, out + keyIdx, oidKeyType, oidSz + sz);\n        tmpSz += sz; keyIdx += sz;\n\n        /*  privateKey          PrivateKey *\n         * pkcs8 ecc uses slightly different format. Places curve oid in\n         * buffer */\n        if (curveOID != NULL && oidSz > 0) {\n            sz = SetObjectId(oidSz, out + keyIdx);\n            keyIdx += sz; tmpSz += sz;\n            XMEMCPY(out + keyIdx, curveOID, oidSz);\n            keyIdx += oidSz; tmpSz += oidSz;\n        }\n\n        sz = SetOctetString(keySz, out + keyIdx);\n        keyIdx += sz; tmpSz += sz;\n        XMEMCPY(out + keyIdx, key, keySz);\n        tmpSz += keySz;\n\n        /*  attributes          optional\n         * No attributes currently added */\n\n        /* rewind and add sequence */\n        sz = SetSequence(tmpSz, out);\n        XMEMMOVE(out + sz, out + MAX_SEQ_SZ, tmpSz);\n\n        return tmpSz + sz;\n}\n\n#endif /* HAVE_PKCS8 && !NO_CERTS */\n\n#if defined(HAVE_PKCS12) || !defined(NO_CHECK_PRIVATE_KEY)\n/* check that the private key is a pair for the public key\n * return 1 (true) on match\n * return 0 or negative value on failure/error\n *\n * privKey   : buffer holding DER format private key\n * privKeySz : size of private key buffer\n * pubKey    : buffer holding DER format public key\n * pubKeySz  : size of public key buffer\n * ks        : type of key */\nint wc_CheckPrivateKey(const byte* privKey, word32 privKeySz,\n                       const byte* pubKey, word32 pubKeySz, enum Key_Sum ks)\n{\n    int ret;\n    (void)privKeySz;\n    (void)pubKeySz;\n    (void)ks;\n\n    if (privKey == NULL || pubKey == NULL) {\n        return BAD_FUNC_ARG;\n    }\n\n    #if !defined(NO_RSA) && !defined(NO_ASN_CRYPT)\n    /* test if RSA key */\n    if (ks == RSAk) {\n    #ifdef WOLFSSL_SMALL_STACK\n        RsaKey* a;\n        RsaKey* b = NULL;\n    #else\n        RsaKey a[1], b[1];\n    #endif\n        word32 keyIdx = 0;\n\n    #ifdef WOLFSSL_SMALL_STACK\n        a = (RsaKey*)XMALLOC(sizeof(RsaKey), NULL, DYNAMIC_TYPE_RSA);\n        if (a == NULL)\n            return MEMORY_E;\n        b = (RsaKey*)XMALLOC(sizeof(RsaKey), NULL, DYNAMIC_TYPE_RSA);\n        if (b == NULL) {\n            XFREE(a, NULL, DYNAMIC_TYPE_RSA);\n            return MEMORY_E;\n        }\n    #endif\n\n        if ((ret = wc_InitRsaKey(a, NULL)) < 0) {\n    #ifdef WOLFSSL_SMALL_STACK\n            XFREE(b, NULL, DYNAMIC_TYPE_RSA);\n            XFREE(a, NULL, DYNAMIC_TYPE_RSA);\n    #endif\n            return ret;\n        }\n        if ((ret = wc_InitRsaKey(b, NULL)) < 0) {\n            wc_FreeRsaKey(a);\n    #ifdef WOLFSSL_SMALL_STACK\n            XFREE(b, NULL, DYNAMIC_TYPE_RSA);\n            XFREE(a, NULL, DYNAMIC_TYPE_RSA);\n    #endif\n            return ret;\n        }\n        if ((ret = wc_RsaPrivateKeyDecode(privKey, &keyIdx, a, privKeySz)) == 0) {\n            WOLFSSL_MSG(\"Checking RSA key pair\");\n            keyIdx = 0; /* reset to 0 for parsing public key */\n\n            if ((ret = wc_RsaPublicKeyDecode(pubKey, &keyIdx, b,\n                    pubKeySz)) == 0) {\n                /* limit for user RSA crypto because of RsaKey\n                 * dereference. */\n            #if defined(HAVE_USER_RSA)\n                WOLFSSL_MSG(\"Cannot verify RSA pair with user RSA\");\n                ret = 1; /* return first RSA cert as match */\n            #else\n                /* both keys extracted successfully now check n and e\n                 * values are the same. This is dereferencing RsaKey */\n                if (mp_cmp(&(a->n), &(b->n)) != MP_EQ ||\n                    mp_cmp(&(a->e), &(b->e)) != MP_EQ) {\n                    ret = MP_CMP_E;\n                }\n                else\n                    ret = 1;\n            #endif\n            }\n        }\n        wc_FreeRsaKey(b);\n        wc_FreeRsaKey(a);\n    #ifdef WOLFSSL_SMALL_STACK\n        XFREE(b, NULL, DYNAMIC_TYPE_RSA);\n        XFREE(a, NULL, DYNAMIC_TYPE_RSA);\n    #endif\n    }\n    else\n    #endif /* !NO_RSA && !NO_ASN_CRYPT */\n\n    #if defined(HAVE_ECC) && defined(HAVE_ECC_KEY_EXPORT) && !defined(NO_ASN_CRYPT)\n    if (ks == ECDSAk) {\n    #ifdef WOLFSSL_SMALL_STACK\n        ecc_key* key_pair;\n        byte*    privDer;\n    #else\n        ecc_key  key_pair[1];\n        byte     privDer[MAX_ECC_BYTES];\n    #endif\n        word32   privSz = MAX_ECC_BYTES;\n        word32   keyIdx = 0;\n\n    #ifdef WOLFSSL_SMALL_STACK\n        key_pair = (ecc_key*)XMALLOC(sizeof(ecc_key), NULL, DYNAMIC_TYPE_ECC);\n        if (key_pair == NULL)\n            return MEMORY_E;\n        privDer = (byte*)XMALLOC(MAX_ECC_BYTES, NULL, DYNAMIC_TYPE_TMP_BUFFER);\n        if (privDer == NULL) {\n            XFREE(key_pair, NULL, DYNAMIC_TYPE_ECC);\n            return MEMORY_E;\n        }\n    #endif\n\n        if ((ret = wc_ecc_init(key_pair)) < 0) {\n    #ifdef WOLFSSL_SMALL_STACK\n            XFREE(privDer, NULL, DYNAMIC_TYPE_TMP_BUFFER);\n            XFREE(key_pair, NULL, DYNAMIC_TYPE_ECC);\n    #endif\n            return ret;\n        }\n\n        if ((ret = wc_EccPrivateKeyDecode(privKey, &keyIdx, key_pair,\n                privKeySz)) == 0) {\n            WOLFSSL_MSG(\"Checking ECC key pair\");\n\n            if ((ret = wc_ecc_export_private_only(key_pair, privDer, &privSz))\n                                                                         == 0) {\n                wc_ecc_free(key_pair);\n                ret = wc_ecc_init(key_pair);\n                if (ret == 0) {\n                    ret = wc_ecc_import_private_key(privDer,\n                                            privSz, pubKey,\n                                            pubKeySz, key_pair);\n                }\n\n                /* public and private extracted successfully now check if is\n                 * a pair and also do sanity checks on key. wc_ecc_check_key\n                 * checks that private * base generator equals pubkey */\n                if (ret == 0) {\n                    if ((ret = wc_ecc_check_key(key_pair)) == 0) {\n                        ret = 1;\n                    }\n                }\n                ForceZero(privDer, privSz);\n            }\n        }\n        wc_ecc_free(key_pair);\n    #ifdef WOLFSSL_SMALL_STACK\n        XFREE(privDer, NULL, DYNAMIC_TYPE_TMP_BUFFER);\n        XFREE(key_pair, NULL, DYNAMIC_TYPE_ECC);\n    #endif\n    }\n    else\n    #endif /* HAVE_ECC && HAVE_ECC_KEY_EXPORT && !NO_ASN_CRYPT */\n\n    #if defined(HAVE_ED25519) && !defined(NO_ASN_CRYPT)\n    if (ks == ED25519k) {\n    #ifdef WOLFSSL_SMALL_STACK\n        ed25519_key* key_pair;\n    #else\n        ed25519_key  key_pair[1];\n    #endif\n        word32       keyIdx = 0;\n\n    #ifdef WOLFSSL_SMALL_STACK\n        key_pair = (ed25519_key*)XMALLOC(sizeof(ed25519_key), NULL,\n                                                          DYNAMIC_TYPE_ED25519);\n        if (key_pair == NULL)\n            return MEMORY_E;\n    #endif\n\n        if ((ret = wc_ed25519_init(key_pair)) < 0) {\n    #ifdef WOLFSSL_SMALL_STACK\n            XFREE(key_pair, NULL, DYNAMIC_TYPE_ED25519);\n    #endif\n            return ret;\n        }\n        if ((ret = wc_Ed25519PrivateKeyDecode(privKey, &keyIdx, key_pair,\n                privKeySz)) == 0) {\n            WOLFSSL_MSG(\"Checking ED25519 key pair\");\n            keyIdx = 0;\n            if ((ret = wc_ed25519_import_public(pubKey, pubKeySz,\n                    key_pair)) == 0) {\n                /* public and private extracted successfully no check if is\n                 * a pair and also do sanity checks on key. wc_ecc_check_key\n                 * checks that private * base generator equals pubkey */\n                if ((ret = wc_ed25519_check_key(key_pair)) == 0)\n                    ret = 1;\n            }\n        }\n        wc_ed25519_free(key_pair);\n    #ifdef WOLFSSL_SMALL_STACK\n        XFREE(key_pair, NULL, DYNAMIC_TYPE_ED25519);\n    #endif\n    }\n    else\n    #endif /* HAVE_ED25519 && !NO_ASN_CRYPT */\n\n    #if defined(HAVE_ED448) && !defined(NO_ASN_CRYPT)\n    if (ks == ED448k) {\n    #ifdef WOLFSSL_SMALL_STACK\n        ed448_key* key_pair = NULL;\n    #else\n        ed448_key  key_pair[1];\n    #endif\n        word32     keyIdx = 0;\n\n    #ifdef WOLFSSL_SMALL_STACK\n        key_pair = (ed448_key*)XMALLOC(sizeof(ed448_key), NULL,\n                                                            DYNAMIC_TYPE_ED448);\n        if (key_pair == NULL)\n            return MEMORY_E;\n    #endif\n\n        if ((ret = wc_ed448_init(key_pair)) < 0) {\n    #ifdef WOLFSSL_SMALL_STACK\n            XFREE(key_pair, NULL, DYNAMIC_TYPE_ED448);\n    #endif\n            return ret;\n        }\n        if ((ret = wc_Ed448PrivateKeyDecode(privKey, &keyIdx, key_pair,\n                privKeySz)) == 0) {\n            WOLFSSL_MSG(\"Checking ED448 key pair\");\n            keyIdx = 0;\n            if ((ret = wc_ed448_import_public(pubKey, pubKeySz,\n                    key_pair)) == 0) {\n                /* public and private extracted successfully no check if is\n                 * a pair and also do sanity checks on key. wc_ecc_check_key\n                 * checks that private * base generator equals pubkey */\n                if ((ret = wc_ed448_check_key(key_pair)) == 0)\n                    ret = 1;\n            }\n        }\n        wc_ed448_free(key_pair);\n    #ifdef WOLFSSL_SMALL_STACK\n        XFREE(key_pair, NULL, DYNAMIC_TYPE_ED448);\n    #endif\n    }\n    else\n    #endif /* HAVE_ED448 && !NO_ASN_CRYPT */\n    {\n        ret = 0;\n    }\n    (void)ks;\n\n    return ret;\n}\n\n/* check that the private key is a pair for the public key in certificate\n * return 1 (true) on match\n * return 0 or negative value on failure/error\n *\n * key   : buffer holding DER format key\n * keySz : size of key buffer\n * der   : a initialized and parsed DecodedCert holding a certificate */\nint wc_CheckPrivateKeyCert(const byte* key, word32 keySz, DecodedCert* der)\n{\n    if (key == NULL || der == NULL) {\n        return BAD_FUNC_ARG;\n    }\n\n    return wc_CheckPrivateKey(key, keySz, der->publicKey,\n            der->pubKeySize, (enum Key_Sum) der->keyOID);\n}\n\n#endif /* HAVE_PKCS12 || !NO_CHECK_PRIVATE_KEY */\n\n#ifndef NO_PWDBASED\n\n#if defined(HAVE_PKCS8) || defined(HAVE_PKCS12)\n/* Check To see if PKCS version algo is supported, set id if it is return 0\n   < 0 on error */\nstatic int CheckAlgo(int first, int second, int* id, int* version, int* blockSz)\n{\n    *id      = ALGO_ID_E;\n    *version = PKCS5;   /* default */\n    if (blockSz) *blockSz = 8; /* default */\n\n    if (first == 1) {\n        switch (second) {\n#if !defined(NO_SHA)\n    #ifndef NO_RC4\n        case PBE_SHA1_RC4_128:\n            *id = PBE_SHA1_RC4_128;\n            *version = PKCS12v1;\n            return 0;\n    #endif\n    #ifndef NO_DES3\n        case PBE_SHA1_DES3:\n            *id = PBE_SHA1_DES3;\n            *version = PKCS12v1;\n            if (blockSz) *blockSz = DES_BLOCK_SIZE;\n            return 0;\n        case PBE_SHA1_DES:\n            *id = PBE_SHA1_DES;\n            *version = PKCS12v1;\n            if (blockSz) *blockSz = DES_BLOCK_SIZE;\n            return 0;\n    #endif\n    #ifdef WC_RC2\n        case PBE_SHA1_40RC2_CBC:\n            *id = PBE_SHA1_40RC2_CBC;\n            *version = PKCS12v1;\n            if (blockSz) *blockSz = RC2_BLOCK_SIZE;\n            return 0;\n    #endif\n#endif /* !NO_SHA */\n        default:\n            return ALGO_ID_E;\n        }\n    }\n\n    if (first != PKCS5)\n        return ASN_INPUT_E;  /* VERSION ERROR */\n\n    if (second == PBES2) {\n        *version = PKCS5v2;\n        return 0;\n    }\n\n    switch (second) {\n#ifndef NO_DES3\n    #ifndef NO_MD5\n    case 3:                   /* see RFC 2898 for ids */\n        *id = PBE_MD5_DES;\n        if (blockSz) *blockSz = DES_BLOCK_SIZE;\n        return 0;\n    #endif\n    #ifndef NO_SHA\n    case 10:\n        *id = PBE_SHA1_DES;\n        if (blockSz) *blockSz = DES_BLOCK_SIZE;\n        return 0;\n    #endif\n#endif /* !NO_DES3 */\n    default:\n        return ALGO_ID_E;\n\n    }\n}\n\n/* Check To see if PKCS v2 algo is supported, set id if it is return 0\n   < 0 on error */\nstatic int CheckAlgoV2(int oid, int* id, int* blockSz)\n{\n    if (blockSz) *blockSz = 8; /* default */\n    (void)id; /* not used if AES and DES3 disabled */\n    switch (oid) {\n#if !defined(NO_DES3) && !defined(NO_SHA)\n    case DESb:\n        *id = PBE_SHA1_DES;\n        if (blockSz) *blockSz = DES_BLOCK_SIZE;\n        return 0;\n    case DES3b:\n        *id = PBE_SHA1_DES3;\n        if (blockSz) *blockSz = DES_BLOCK_SIZE;\n        return 0;\n#endif\n#ifdef WOLFSSL_AES_256\n    case AES256CBCb:\n        *id = PBE_AES256_CBC;\n        if (blockSz) *blockSz = AES_BLOCK_SIZE;\n        return 0;\n#endif\n#ifdef WOLFSSL_AES_128\n    case AES128CBCb:\n        *id = PBE_AES128_CBC;\n        if (blockSz) *blockSz = AES_BLOCK_SIZE;\n        return 0;\n#endif\n    default:\n        WOLFSSL_MSG(\"No PKCS v2 algo found\");\n        return ALGO_ID_E;\n\n    }\n}\n\n#endif /* HAVE_PKCS8 || HAVE_PKCS12 */\n\n#ifdef HAVE_PKCS8\n\nint wc_GetKeyOID(byte* key, word32 keySz, const byte** curveOID, word32* oidSz,\n        int* algoID, void* heap)\n{\n    word32 tmpIdx = 0;\n\n    if (key == NULL || algoID == NULL)\n        return BAD_FUNC_ARG;\n\n    *algoID = 0;\n\n    #if !defined(NO_RSA) && !defined(NO_ASN_CRYPT)\n    {\n        RsaKey *rsa = (RsaKey *)XMALLOC(sizeof *rsa, heap, DYNAMIC_TYPE_TMP_BUFFER);\n        if (rsa == NULL)\n            return MEMORY_E;\n\n        wc_InitRsaKey(rsa, heap);\n        if (wc_RsaPrivateKeyDecode(key, &tmpIdx, rsa, keySz) == 0) {\n            *algoID = RSAk;\n        }\n        else {\n            WOLFSSL_MSG(\"Not RSA DER key\");\n        }\n        wc_FreeRsaKey(rsa);\n        XFREE(rsa, heap, DYNAMIC_TYPE_TMP_BUFFER);\n    }\n    #endif /* !NO_RSA && !NO_ASN_CRYPT */\n    #if defined(HAVE_ECC) && !defined(NO_ASN_CRYPT)\n    if (*algoID == 0) {\n        ecc_key *ecc = (ecc_key *)XMALLOC(sizeof *ecc, heap, DYNAMIC_TYPE_TMP_BUFFER);\n        if (ecc == NULL)\n            return MEMORY_E;\n\n        tmpIdx = 0;\n        wc_ecc_init_ex(ecc, heap, INVALID_DEVID);\n        if (wc_EccPrivateKeyDecode(key, &tmpIdx, ecc, keySz) == 0) {\n            *algoID = ECDSAk;\n\n            /* now find oid */\n            if (wc_ecc_get_oid(ecc->dp->oidSum, curveOID, oidSz) < 0) {\n                WOLFSSL_MSG(\"Error getting ECC curve OID\");\n                wc_ecc_free(ecc);\n                XFREE(ecc, heap, DYNAMIC_TYPE_TMP_BUFFER);\n                return BAD_FUNC_ARG;\n            }\n        }\n        else {\n            WOLFSSL_MSG(\"Not ECC DER key either\");\n        }\n        wc_ecc_free(ecc);\n        XFREE(ecc, heap, DYNAMIC_TYPE_TMP_BUFFER);\n    }\n#endif /* HAVE_ECC && !NO_ASN_CRYPT */\n#if defined(HAVE_ED25519) && !defined(NO_ASN_CRYPT)\n    if (*algoID != RSAk && *algoID != ECDSAk) {\n        ed25519_key *ed25519 = (ed25519_key *)XMALLOC(sizeof *ed25519, heap, DYNAMIC_TYPE_TMP_BUFFER);\n        if (ed25519 == NULL)\n            return MEMORY_E;\n\n        tmpIdx = 0;\n        if (wc_ed25519_init(ed25519) == 0) {\n            if (wc_Ed25519PrivateKeyDecode(key, &tmpIdx, ed25519, keySz) == 0) {\n                *algoID = ED25519k;\n            }\n            else {\n                WOLFSSL_MSG(\"Not ED25519 DER key\");\n            }\n            wc_ed25519_free(ed25519);\n        }\n        else {\n            WOLFSSL_MSG(\"GetKeyOID wc_ed25519_init failed\");\n        }\n        XFREE(ed25519, heap, DYNAMIC_TYPE_TMP_BUFFER);\n    }\n#endif /* HAVE_ED25519 && !NO_ASN_CRYPT */\n#if defined(HAVE_ED448) && !defined(NO_ASN_CRYPT)\n    if (*algoID != RSAk && *algoID != ECDSAk && *algoID != ED25519k) {\n        ed448_key *ed448 = (ed448_key *)XMALLOC(sizeof *ed448, heap, DYNAMIC_TYPE_TMP_BUFFER);\n        if (ed448 == NULL)\n            return MEMORY_E;\n\n        tmpIdx = 0;\n        if (wc_ed448_init(ed448) == 0) {\n            if (wc_Ed448PrivateKeyDecode(key, &tmpIdx, ed448, keySz) == 0) {\n                *algoID = ED448k;\n            }\n            else {\n                WOLFSSL_MSG(\"Not ED448 DER key\");\n            }\n            wc_ed448_free(ed448);\n        }\n        else {\n            WOLFSSL_MSG(\"GetKeyOID wc_ed448_init failed\");\n        }\n        XFREE(ed448, heap, DYNAMIC_TYPE_TMP_BUFFER);\n    }\n#endif /* HAVE_ED448 && !NO_ASN_CRYPT */\n\n    /* if flag is not set then is neither RSA or ECC key that could be\n     * found */\n    if (*algoID == 0) {\n        WOLFSSL_MSG(\"Bad key DER or compile options\");\n        return BAD_FUNC_ARG;\n    }\n\n    (void)tmpIdx;\n    (void)curveOID;\n    (void)oidSz;\n    (void)keySz;\n    (void)heap;\n\n    return 1;\n}\n\n#endif /* HAVE_PKCS8 */\n\n#if defined(HAVE_PKCS8) || defined(HAVE_PKCS12)\n\n#define PKCS8_MIN_BLOCK_SIZE 8\nstatic int Pkcs8Pad(byte* buf, int sz, int blockSz)\n{\n    int i, padSz;\n\n    /* calculate pad size */\n    padSz = blockSz - (sz & (blockSz - 1));\n\n    /* pad with padSz value */\n    if (buf) {\n        for (i = 0; i < padSz; i++) {\n            buf[sz+i] = (byte)(padSz & 0xFF);\n        }\n    }\n\n    /* return adjusted length */\n    return sz + padSz;\n}\n\n#endif /* HAVE_PKCS8 || HAVE_PKCS12 */\n\n#ifdef HAVE_PKCS8\n\n/*\n * Equivalent to calling TraditionalEnc with the same parameters but with\n * encAlgId set to 0. This function must be kept alive because it's sometimes\n * part of the API (WOLFSSL_ASN_API).\n */\nint UnTraditionalEnc(byte* key, word32 keySz, byte* out, word32* outSz,\n        const char* password, int passwordSz, int vPKCS, int vAlgo,\n        byte* salt, word32 saltSz, int itt, WC_RNG* rng, void* heap)\n{\n    return TraditionalEnc(key, keySz, out, outSz, password, passwordSz,\n                vPKCS, vAlgo, 0, salt, saltSz, itt, rng, heap);\n}\n\nstatic int GetAlgoV2(int encAlgId, const byte** oid, int *len, int* id,\n                     int *blkSz)\n{\n    int ret = 0;\n\n    switch (encAlgId) {\n#if !defined(NO_DES3) && !defined(NO_SHA)\n    case DESb:\n        *len = sizeof(blkDesCbcOid);\n        *oid = blkDesCbcOid;\n        *id = PBE_SHA1_DES;\n        *blkSz = 8;\n        break;\n    case DES3b:\n        *len = sizeof(blkDes3CbcOid);\n        *oid = blkDes3CbcOid;\n        *id = PBE_SHA1_DES3;\n        *blkSz = 8;\n        break;\n#endif\n#if defined(WOLFSSL_AES_256) && defined(HAVE_AES_CBC)\n    case AES256CBCb:\n        *len = sizeof(blkAes256CbcOid);\n        *oid = blkAes256CbcOid;\n        *id = PBE_AES256_CBC;\n        *blkSz = 16;\n        break;\n#endif\n    default:\n        (void)len;\n        (void)oid;\n        (void)id;\n        (void)blkSz;\n        ret = ALGO_ID_E;\n    }\n\n    return ret;\n}\n\nint wc_EncryptPKCS8Key(byte* key, word32 keySz, byte* out, word32* outSz,\n        const char* password, int passwordSz, int vPKCS, int pbeOid,\n        int encAlgId, byte* salt, word32 saltSz, int itt, WC_RNG* rng,\n        void* heap)\n{\n#ifdef WOLFSSL_SMALL_STACK\n    byte* saltTmp = NULL;\n#else\n    byte saltTmp[MAX_SALT_SIZE];\n#endif\n    int genSalt = 0;\n    int ret = 0;\n    int version = 0;\n    int pbeId = 0;\n    int blockSz = 0;\n    const byte* encOid = NULL;\n    int encOidSz = 0;\n    word32 padSz = 0;\n    word32 innerLen = 0;\n    word32 outerLen = 0;\n    const byte* pbeOidBuf = NULL;\n    word32 pbeOidBufSz = 0;\n    word32 pbeLen = 0;\n    word32 kdfLen = 0;\n    word32 encLen = 0;\n    byte cbcIv[MAX_IV_SIZE];\n    word32 idx = 0;\n    word32 encIdx = 0;\n\n    (void)heap;\n\n    WOLFSSL_ENTER(\"wc_EncryptPKCS8Key\");\n\n    if (key == NULL || outSz == NULL || password == NULL) {\n        ret = BAD_FUNC_ARG;\n    }\n\n    if (ret == 0) {\n        ret = CheckAlgo(vPKCS, pbeOid, &pbeId, &version, &blockSz);\n    }\n    if (ret == 0 && (salt == NULL || saltSz == 0)) {\n        genSalt = 1;\n        saltSz = 8;\n    }\n    if (ret == 0 && version == PKCS5v2) {\n        ret = GetAlgoV2(encAlgId, &encOid, &encOidSz, &pbeId, &blockSz);\n    }\n    if (ret == 0) {\n        padSz = (blockSz - (keySz & (blockSz - 1))) & (blockSz - 1);\n        /* inner = OCT salt INT itt */\n        innerLen = 2 + saltSz + 2 + (itt < 256 ? 1 : 2);\n\n        if (version != PKCS5v2) {\n            pbeOidBuf = OidFromId(pbeId, oidPBEType, &pbeOidBufSz);\n            /* pbe = OBJ pbse1 SEQ [ inner ] */\n            pbeLen = 2 + pbeOidBufSz + 2 + innerLen;\n        }\n        else {\n            pbeOidBuf = pbes2;\n            pbeOidBufSz = sizeof(pbes2);\n            /* kdf = OBJ pbkdf2 [ SEQ innerLen ] */\n            kdfLen = 2 + sizeof(pbkdf2Oid) + 2 + innerLen;\n            /* enc = OBJ enc_alg OCT iv */\n            encLen = 2 + encOidSz + 2 + blockSz;\n            /* pbe = OBJ pbse2 SEQ [ SEQ [ kdf ] SEQ [ enc ] ] */\n            pbeLen = 2 + sizeof(pbes2) + 2 + 2 + kdfLen + 2 + encLen;\n\n            ret = wc_RNG_GenerateBlock(rng, cbcIv, blockSz);\n        }\n    }\n    if (ret == 0) {\n        /* outerLen = length of PBE encoding + octet string data */\n        /* Plus 2 for tag and length for pbe */\n        outerLen = 2 + pbeLen;\n        /* Octet string tag, length */\n        outerLen += 1 + SetLength(keySz + padSz, NULL); \n        /* Octet string bytes */\n        outerLen += keySz + padSz;\n        if (out == NULL) {\n            /* Sequence tag, length */\n            *outSz = 1 + SetLength(outerLen, NULL) + outerLen;\n            return LENGTH_ONLY_E;\n        }\n        SetOctetString(keySz + padSz, out);\n\n        idx += SetSequence(outerLen, out + idx);\n\n        encIdx = idx + outerLen - keySz - padSz;\n        /* Put Encrypted content in place. */\n        XMEMCPY(out + encIdx, key, keySz);\n        if (padSz > 0) {\n            XMEMSET(out + encIdx + keySz, padSz, padSz);\n            keySz += padSz;\n        }\n\n        if (genSalt == 1) {\n        #ifdef WOLFSSL_SMALL_STACK\n            saltTmp = (byte*)XMALLOC(saltSz, heap, DYNAMIC_TYPE_TMP_BUFFER);\n            if (saltTmp == NULL) {\n                ret = MEMORY_E;\n            }\n            else\n        #endif\n            {\n                salt = saltTmp;\n                if ((ret = wc_RNG_GenerateBlock(rng, saltTmp, saltSz)) != 0) {\n                    WOLFSSL_MSG(\"Error generating random salt\");\n                }\n            }\n        }\n    }\n    if (ret == 0) {\n        ret = wc_CryptKey(password, passwordSz, salt, saltSz, itt, pbeId,\n                  out + encIdx, keySz, version, cbcIv, 1, 0);\n    }\n    if (ret == 0) {\n        if (version != PKCS5v2) {\n            /* PBE algorithm */\n            idx += SetSequence(pbeLen, out + idx);\n            idx += SetObjectId(pbeOidBufSz, out + idx);\n            XMEMCPY(out + idx, pbeOidBuf, pbeOidBufSz);\n            idx += pbeOidBufSz;\n        }\n        else {\n            /* PBES2 algorithm identifier */\n            idx += SetSequence(pbeLen, out + idx);\n            idx += SetObjectId(pbeOidBufSz, out + idx);\n            XMEMCPY(out + idx, pbeOidBuf, pbeOidBufSz);\n            idx += pbeOidBufSz;\n            /* PBES2 Parameters: SEQ [ kdf ] SEQ [ enc ] */\n            idx += SetSequence(2 + kdfLen + 2 + encLen, out + idx);\n            /* KDF Algorithm Identifier */\n            idx += SetSequence(kdfLen, out + idx);\n            idx += SetObjectId(sizeof(pbkdf2Oid), out + idx);\n            XMEMCPY(out + idx, pbkdf2Oid, sizeof(pbkdf2Oid));\n            idx += sizeof(pbkdf2Oid);\n        }\n        idx += SetSequence(innerLen, out + idx);\n        idx += SetOctetString(saltSz, out + idx);\n        XMEMCPY(out + idx, salt, saltSz); idx += saltSz;\n        ret = SetShortInt(out, &idx, itt, *outSz);\n        if (ret > 0)\n            ret = 0;\n    }\n    if (ret == 0) {\n        if (version == PKCS5v2) {\n            /* Encryption Algorithm Identifier */\n            idx += SetSequence(encLen, out + idx);\n            idx += SetObjectId(encOidSz, out + idx);\n            XMEMCPY(out + idx, encOid, encOidSz);\n            idx += encOidSz;\n            /* Encryption Algorithm Parameter: CBC IV */\n            idx += SetOctetString(blockSz, out + idx);\n            XMEMCPY(out + idx, cbcIv, blockSz);\n            idx += blockSz;\n        }\n        idx += SetOctetString(keySz, out + idx);\n        /* Default PRF - no need to write out OID */\n        idx += keySz;\n\n        ret = idx;\n    }\n\n#ifdef WOLFSSL_SMALL_STACK\n    if (saltTmp != NULL) {\n        XFREE(saltTmp, heap, DYNAMIC_TYPE_TMP_BUFFER);\n    }\n#endif\n\n    WOLFSSL_LEAVE(\"wc_EncryptPKCS8Key\", ret);\n\n    return ret;\n}\n\nint wc_DecryptPKCS8Key(byte* input, word32 sz, const char* password,\n        int passwordSz)\n{\n    int ret;\n    int length;\n    word32 inOutIdx = 0;\n\n    if (input == NULL || password == NULL) {\n        return BAD_FUNC_ARG;\n    }\n\n    if (GetSequence(input, &inOutIdx, &length, sz) < 0) {\n        ret = ASN_PARSE_E;\n    }\n    else {\n        ret = DecryptContent(input + inOutIdx, sz - inOutIdx, password,\n                passwordSz);\n        if (ret > 0) {\n            XMEMMOVE(input, input + inOutIdx, ret);\n        }\n    }\n\n    if (ret > 0) {\n        /* DecryptContent will decrypt the data, but it will leave any padding\n         * bytes intact. This code calculates the length without the padding\n         * and we return that to the user. */\n        inOutIdx = 0;\n        if (GetSequence(input, &inOutIdx, &length, ret) < 0) {\n            ret = ASN_PARSE_E;\n        }\n        else {\n            ret = inOutIdx + length;\n        }\n    }\n\n    return ret;\n}\n\n/* Takes an unencrypted, traditional DER-encoded key and converts it to a PKCS#8\n * encrypted key. If out is not NULL, it will hold the encrypted key. If it's\n * NULL, LENGTH_ONLY_E will be returned and outSz will have the required out\n * buffer size. */\nint TraditionalEnc(byte* key, word32 keySz, byte* out, word32* outSz,\n        const char* password, int passwordSz, int vPKCS, int vAlgo,\n        int encAlgId, byte* salt, word32 saltSz, int itt, WC_RNG* rng,\n        void* heap)\n{\n    int ret = 0;\n    byte *pkcs8Key = NULL;\n    word32 pkcs8KeySz = 0;\n    int algId = 0;\n    const byte* curveOid = NULL;\n    word32 curveOidSz = 0;\n\n    if (ret == 0) {\n        /* check key type and get OID if ECC */\n        ret = wc_GetKeyOID(key, keySz, &curveOid, &curveOidSz, &algId, heap);\n        if (ret == 1)\n            ret = 0;\n    }\n    if (ret == 0) {\n        ret = wc_CreatePKCS8Key(NULL, &pkcs8KeySz, key, keySz, algId, curveOid,\n                                                                    curveOidSz);\n        if (ret == LENGTH_ONLY_E)\n            ret = 0;\n    }\n    if (ret == 0) {\n        pkcs8Key = (byte*)XMALLOC(pkcs8KeySz, heap, DYNAMIC_TYPE_TMP_BUFFER);\n        if (pkcs8Key == NULL)\n            ret = MEMORY_E;\n    }\n    if (ret == 0) {\n        ret = wc_CreatePKCS8Key(pkcs8Key, &pkcs8KeySz, key, keySz, algId,\n            curveOid, curveOidSz);\n        if (ret >= 0) {\n            pkcs8KeySz = ret;\n            ret = 0;\n        }\n    }\n    if (ret == 0) {\n        ret = wc_EncryptPKCS8Key(pkcs8Key, pkcs8KeySz, out, outSz, password,\n            passwordSz, vPKCS, vAlgo, encAlgId, salt, saltSz, itt, rng, heap);\n    }\n\n    if (pkcs8Key != NULL) {\n        ForceZero(pkcs8Key, pkcs8KeySz);\n        XFREE(pkcs8Key, heap, DYNAMIC_TYPE_TMP_BUFFER);\n    }\n\n    (void)rng;\n\n    return ret;\n}\n\n/* Same as TraditionalEnc, but in the public API. */\nint wc_CreateEncryptedPKCS8Key(byte* key, word32 keySz, byte* out,\n        word32* outSz, const char* password, int passwordSz, int vPKCS,\n        int pbeOid, int encAlgId, byte* salt, word32 saltSz, int itt,\n        WC_RNG* rng, void* heap)\n{\n    return TraditionalEnc(key, keySz, out, outSz, password, passwordSz, vPKCS,\n        pbeOid, encAlgId, salt, saltSz, itt, rng, heap);\n}\n\n\n#endif /* HAVE_PKCS8 */\n\n#if defined(HAVE_PKCS8) || defined(HAVE_PKCS12)\n/* decrypt PKCS\n *\n * NOTE: input buffer is overwritten with decrypted data!\n *\n * input[in/out] data to decrypt and results are written to\n * sz            size of input buffer\n * password      password if used. Can be NULL for no password\n * passwordSz    size of password buffer\n *\n * returns the total size of decrypted content on success.\n */\nint DecryptContent(byte* input, word32 sz, const char* password, int passwordSz)\n{\n    word32 inOutIdx = 0, seqEnd, oid, shaOid = 0;\n    int    ret = 0, first, second, length = 0, version, saltSz, id;\n    int    iterations = 0, keySz = 0;\n#ifdef WOLFSSL_SMALL_STACK\n    byte*  salt = NULL;\n    byte*  cbcIv = NULL;\n#else\n    byte   salt[MAX_SALT_SIZE];\n    byte   cbcIv[MAX_IV_SIZE];\n#endif\n    byte   tag;\n\n    if (passwordSz < 0) {\n        WOLFSSL_MSG(\"Bad password size\");\n        return BAD_FUNC_ARG;\n    }\n\n    if (GetAlgoId(input, &inOutIdx, &oid, oidIgnoreType, sz) < 0) {\n        ERROR_OUT(ASN_PARSE_E, exit_dc);\n    }\n\n    first  = input[inOutIdx - 2];   /* PKCS version always 2nd to last byte */\n    second = input[inOutIdx - 1];   /* version.algo, algo id last byte */\n\n    if (CheckAlgo(first, second, &id, &version, NULL) < 0) {\n        ERROR_OUT(ASN_INPUT_E, exit_dc); /* Algo ID error */\n    }\n\n    if (version == PKCS5v2) {\n        if (GetSequence(input, &inOutIdx, &length, sz) < 0) {\n            ERROR_OUT(ASN_PARSE_E, exit_dc);\n        }\n\n        if (GetAlgoId(input, &inOutIdx, &oid, oidKdfType, sz) < 0) {\n            ERROR_OUT(ASN_PARSE_E, exit_dc);\n        }\n\n        if (oid != PBKDF2_OID) {\n            ERROR_OUT(ASN_PARSE_E, exit_dc);\n        }\n    }\n\n    if (GetSequence(input, &inOutIdx, &length, sz) <= 0) {\n        ERROR_OUT(ASN_PARSE_E, exit_dc);\n    }\n    /* Find the end of this SEQUENCE so we can check for the OPTIONAL and\n     * DEFAULT items. */\n    seqEnd = inOutIdx + length;\n\n    ret = GetOctetString(input, &inOutIdx, &saltSz, sz);\n    if (ret < 0)\n        goto exit_dc;\n\n    if (saltSz > MAX_SALT_SIZE) {\n        ERROR_OUT(ASN_PARSE_E, exit_dc);\n    }\n\n#ifdef WOLFSSL_SMALL_STACK\n    salt = (byte*)XMALLOC(MAX_SALT_SIZE, NULL, DYNAMIC_TYPE_TMP_BUFFER);\n    if (salt == NULL) {\n        ERROR_OUT(MEMORY_E, exit_dc);\n    }\n#endif\n\n    XMEMCPY(salt, &input[inOutIdx], saltSz);\n    inOutIdx += saltSz;\n\n    if (GetShortInt(input, &inOutIdx, &iterations, sz) < 0) {\n        ERROR_OUT(ASN_PARSE_E, exit_dc);\n    }\n\n    /* OPTIONAL key length */\n    if (seqEnd > inOutIdx) {\n        word32 localIdx = inOutIdx;\n\n        if (GetASNTag(input, &localIdx, &tag, sz) < 0) {\n            ERROR_OUT(ASN_PARSE_E, exit_dc);\n        }\n\n        if (tag == ASN_INTEGER &&\n                GetShortInt(input, &inOutIdx, &keySz, sz) < 0) {\n            ERROR_OUT(ASN_PARSE_E, exit_dc);\n        }\n    }\n\n    /* DEFAULT HMAC is SHA-1 */\n    if (seqEnd > inOutIdx) {\n        if (GetAlgoId(input, &inOutIdx, &oid, oidHmacType, sz) < 0) {\n            ERROR_OUT(ASN_PARSE_E, exit_dc);\n        }\n\n        shaOid = oid;\n    }\n\n#ifdef WOLFSSL_SMALL_STACK\n    cbcIv = (byte*)XMALLOC(MAX_IV_SIZE, NULL, DYNAMIC_TYPE_TMP_BUFFER);\n    if (cbcIv == NULL) {\n        ERROR_OUT(MEMORY_E, exit_dc);\n    }\n#endif\n\n    if (version == PKCS5v2) {\n        /* get encryption algo */\n        if (GetAlgoId(input, &inOutIdx, &oid, oidBlkType, sz) < 0) {\n            ERROR_OUT(ASN_PARSE_E, exit_dc);\n        }\n\n        if (CheckAlgoV2(oid, &id, NULL) < 0) {\n            ERROR_OUT(ASN_PARSE_E, exit_dc); /* PKCS v2 algo id error */\n        }\n\n        if (shaOid == 0)\n            shaOid = oid;\n\n        ret = GetOctetString(input, &inOutIdx, &length, sz);\n        if (ret < 0)\n            goto exit_dc;\n\n        if (length > MAX_IV_SIZE) {\n            ERROR_OUT(ASN_PARSE_E, exit_dc);\n        }\n\n        XMEMCPY(cbcIv, &input[inOutIdx], length);\n        inOutIdx += length;\n    }\n\n    if (GetASNTag(input, &inOutIdx, &tag, sz) < 0) {\n        ERROR_OUT(ASN_PARSE_E, exit_dc);\n    }\n\n    if (tag != (ASN_CONTEXT_SPECIFIC | 0) && tag != ASN_OCTET_STRING) {\n        ERROR_OUT(ASN_PARSE_E, exit_dc);\n    }\n\n    if (GetLength(input, &inOutIdx, &length, sz) < 0) {\n        ERROR_OUT(ASN_PARSE_E, exit_dc);\n    }\n\n    ret = wc_CryptKey(password, passwordSz, salt, saltSz, iterations, id,\n                   input + inOutIdx, length, version, cbcIv, 0, shaOid);\n\nexit_dc:\n#ifdef WOLFSSL_SMALL_STACK\n    XFREE(salt,  NULL, DYNAMIC_TYPE_TMP_BUFFER);\n    XFREE(cbcIv, NULL, DYNAMIC_TYPE_TMP_BUFFER);\n#endif\n\n    if (ret == 0) {\n        XMEMMOVE(input, input + inOutIdx, length);\n        ret = length;\n    }\n\n    return ret;\n}\n\n/* Remove Encrypted PKCS8 header, move beginning of traditional to beginning\n   of input */\nint ToTraditionalEnc(byte* input, word32 sz, const char* password,\n                     int passwordSz, word32* algId)\n{\n    int ret;\n\n    ret = wc_DecryptPKCS8Key(input, sz, password, passwordSz);\n    if (ret > 0) {\n        ret = ToTraditional_ex(input, ret, algId);\n    }\n\n    return ret;\n}\n\n#endif /* HAVE_PKCS8 || HAVE_PKCS12 */\n\n#ifdef HAVE_PKCS12\n\n/* encrypt PKCS 12 content\n *\n * NOTE: if out is NULL then outSz is set with the total buffer size needed and\n *       the error value LENGTH_ONLY_E is returned.\n *\n * input      data to encrypt\n * inputSz    size of input buffer\n * out        buffer to hold the result\n * outSz      size of out buffer\n * password   password if used. Can be NULL for no password\n * passwordSz size of password buffer\n * vPKCS      version of PKCS i.e. PKCS5v2\n * vAlgo      algorithm version\n * salt       buffer holding salt if used. If NULL then a random salt is created\n * saltSz     size of salt buffer if it is not NULL\n * itt        number of iterations used\n * rng        random number generator to use\n * heap       possible heap hint for mallocs/frees\n *\n * returns the total size of encrypted content on success.\n *\n * data returned is :\n * [ seq - obj [ seq -salt,itt]] , construct with encrypted data\n */\nint EncryptContent(byte* input, word32 inputSz, byte* out, word32* outSz,\n        const char* password, int passwordSz, int vPKCS, int vAlgo,\n        byte* salt, word32 saltSz, int itt, WC_RNG* rng, void* heap)\n{\n    word32 sz;\n    word32 inOutIdx = 0;\n    word32 tmpIdx   = 0;\n    word32 totalSz  = 0;\n    word32 seqSz;\n    word32 innerSz;\n    int    ret;\n    int    version, id, blockSz = 0;\n#ifdef WOLFSSL_SMALL_STACK\n    byte*  saltTmp = NULL;\n    byte*  cbcIv   = NULL;\n#else\n    byte   saltTmp[MAX_SALT_SIZE];\n    byte   cbcIv[MAX_IV_SIZE];\n#endif\n    byte   seq[MAX_SEQ_SZ];\n    byte   shr[MAX_SHORT_SZ];\n    word32 maxShr = MAX_SHORT_SZ;\n    word32 algoSz;\n    const  byte* algoName;\n\n    (void)heap;\n\n    WOLFSSL_ENTER(\"EncryptContent()\");\n\n    if (CheckAlgo(vPKCS, vAlgo, &id, &version, &blockSz) < 0)\n        return ASN_INPUT_E;  /* Algo ID error */\n\n    if (version == PKCS5v2) {\n        WOLFSSL_MSG(\"PKCS#5 version 2 not supported yet\");\n        return BAD_FUNC_ARG;\n    }\n\n    if (saltSz > MAX_SALT_SIZE)\n        return ASN_PARSE_E;\n\n    if (outSz == NULL) {\n        return BAD_FUNC_ARG;\n    }\n\n    /* calculate size */\n    /* size of constructed string at end */\n    sz = Pkcs8Pad(NULL, inputSz, blockSz);\n    totalSz  = ASN_TAG_SZ;\n    totalSz += SetLength(sz, seq);\n    totalSz += sz;\n\n    /* size of sequence holding object id and sub sequence of salt and itt */\n    algoName = OidFromId(id, oidPBEType, &algoSz);\n    if (algoName == NULL) {\n        WOLFSSL_MSG(\"Unknown Algorithm\");\n        return 0;\n    }\n    innerSz = SetObjectId(algoSz, seq);\n    innerSz += algoSz;\n\n    /* get subsequence of salt and itt */\n    if (salt == NULL || saltSz == 0) {\n        sz = 8;\n    }\n    else {\n        sz = saltSz;\n    }\n    seqSz  = SetOctetString(sz, seq);\n    seqSz += sz;\n\n    tmpIdx = 0;\n    ret = SetShortInt(shr, &tmpIdx, itt, maxShr);\n    if (ret >= 0) {\n        seqSz += ret;\n    }\n    else {\n        return ret;\n    }\n    innerSz += seqSz + SetSequence(seqSz, seq);\n    totalSz += innerSz + SetSequence(innerSz, seq);\n\n    if (out == NULL) {\n        *outSz = totalSz;\n        return LENGTH_ONLY_E;\n    }\n\n    inOutIdx = 0;\n    if (totalSz > *outSz)\n        return BUFFER_E;\n\n    inOutIdx += SetSequence(innerSz, out + inOutIdx);\n    inOutIdx += SetObjectId(algoSz, out + inOutIdx);\n    XMEMCPY(out + inOutIdx, algoName, algoSz);\n    inOutIdx += algoSz;\n    inOutIdx += SetSequence(seqSz, out + inOutIdx);\n\n    /* create random salt if one not provided */\n    if (salt == NULL || saltSz == 0) {\n        saltSz = 8;\n    #ifdef WOLFSSL_SMALL_STACK\n        saltTmp = (byte*)XMALLOC(saltSz, heap, DYNAMIC_TYPE_TMP_BUFFER);\n        if (saltTmp == NULL)\n            return MEMORY_E;\n    #endif\n        salt = saltTmp;\n\n        if ((ret = wc_RNG_GenerateBlock(rng, saltTmp, saltSz)) != 0) {\n            WOLFSSL_MSG(\"Error generating random salt\");\n        #ifdef WOLFSSL_SMALL_STACK\n            XFREE(saltTmp, heap, DYNAMIC_TYPE_TMP_BUFFER);\n        #endif\n            return ret;\n        }\n    }\n    inOutIdx += SetOctetString(saltSz, out + inOutIdx);\n    if (saltSz + inOutIdx > *outSz) {\n    #ifdef WOLFSSL_SMALL_STACK\n        XFREE(saltTmp, heap, DYNAMIC_TYPE_TMP_BUFFER);\n    #endif\n        return BUFFER_E;\n    }\n    XMEMCPY(out + inOutIdx, salt, saltSz);\n    inOutIdx += saltSz;\n\n    /* place iteration setting in buffer */\n    ret = SetShortInt(out, &inOutIdx, itt, *outSz);\n    if (ret < 0) {\n    #ifdef WOLFSSL_SMALL_STACK\n        XFREE(saltTmp, heap, DYNAMIC_TYPE_TMP_BUFFER);\n    #endif\n        return ret;\n    }\n\n    if (inOutIdx + 1 > *outSz) {\n    #ifdef WOLFSSL_SMALL_STACK\n        XFREE(saltTmp, heap, DYNAMIC_TYPE_TMP_BUFFER);\n    #endif\n        return BUFFER_E;\n    }\n    out[inOutIdx++] = ASN_CONTEXT_SPECIFIC | 0;\n\n    /* get pad size and verify buffer room */\n    sz = Pkcs8Pad(NULL, inputSz, blockSz);\n    if (sz + inOutIdx > *outSz) {\n    #ifdef WOLFSSL_SMALL_STACK\n        XFREE(saltTmp, heap, DYNAMIC_TYPE_TMP_BUFFER);\n    #endif\n        return BUFFER_E;\n    }\n    inOutIdx += SetLength(sz, out + inOutIdx);\n\n    /* copy input to output buffer and pad end */\n    XMEMCPY(out + inOutIdx, input, inputSz);\n    sz = Pkcs8Pad(out + inOutIdx, inputSz, blockSz);\n#ifdef WOLFSSL_SMALL_STACK\n    cbcIv = (byte*)XMALLOC(MAX_IV_SIZE, heap, DYNAMIC_TYPE_TMP_BUFFER);\n    if (cbcIv == NULL) {\n        XFREE(saltTmp, heap, DYNAMIC_TYPE_TMP_BUFFER);\n        return MEMORY_E;\n    }\n#endif\n\n    /* encrypt */\n    if ((ret = wc_CryptKey(password, passwordSz, salt, saltSz, itt, id,\n                   out + inOutIdx, sz, version, cbcIv, 1, 0)) < 0) {\n\n    #ifdef WOLFSSL_SMALL_STACK\n        XFREE(cbcIv,   heap, DYNAMIC_TYPE_TMP_BUFFER);\n        XFREE(saltTmp, heap, DYNAMIC_TYPE_TMP_BUFFER);\n    #endif\n        return ret;  /* encrypt failure */\n    }\n\n#ifdef WOLFSSL_SMALL_STACK\n    XFREE(cbcIv,   heap, DYNAMIC_TYPE_TMP_BUFFER);\n    XFREE(saltTmp, heap, DYNAMIC_TYPE_TMP_BUFFER);\n#endif\n\n    (void)rng;\n\n    return inOutIdx + sz;\n}\n\n\n#endif /* HAVE_PKCS12 */\n#endif /* NO_PWDBASED */\n\n#ifndef NO_RSA\n\n#ifndef HAVE_USER_RSA\n#ifdef WOLFSSL_RENESAS_TSIP\n/* This function is to retrieve key position information in a cert.*\n * The information will be used to call TSIP TLS-linked API for    *\n * certificate verification.                                       */\nstatic int RsaPublicKeyDecodeRawIndex(const byte* input, word32* inOutIdx,\n                                      word32 inSz, word32* key_n,\n                                      word32* key_n_len, word32* key_e,\n                                      word32* key_e_len)\n{\n\n    int ret = 0;\n    int length = 0;\n#if defined(OPENSSL_EXTRA) || defined(RSA_DECODE_EXTRA)\n    byte b;\n#endif\n\n    if (input == NULL || inOutIdx == NULL)\n        return BAD_FUNC_ARG;\n\n    if (GetSequence(input, inOutIdx, &length, inSz) < 0)\n        return ASN_PARSE_E;\n\n#if defined(OPENSSL_EXTRA) || defined(RSA_DECODE_EXTRA)\n    if ((*inOutIdx + 1) > inSz)\n        return BUFFER_E;\n\n    b = input[*inOutIdx];\n    if (b != ASN_INTEGER) {\n        /* not from decoded cert, will have algo id, skip past */\n        if (GetSequence(input, inOutIdx, &length, inSz) < 0)\n            return ASN_PARSE_E;\n\n        if (SkipObjectId(input, inOutIdx, inSz) < 0)\n            return ASN_PARSE_E;\n\n        /* Option NULL ASN.1 tag */\n        if (*inOutIdx  >= inSz) {\n            return BUFFER_E;\n        }\n        if (input[*inOutIdx] == ASN_TAG_NULL) {\n            ret = GetASNNull(input, inOutIdx, inSz);\n            if (ret != 0)\n                return ret;\n        }\n\n        /* should have bit tag length and seq next */\n        ret = CheckBitString(input, inOutIdx, NULL, inSz, 1, NULL);\n        if (ret != 0)\n            return ret;\n\n        if (GetSequence(input, inOutIdx, &length, inSz) < 0)\n            return ASN_PARSE_E;\n    }\n#endif /* OPENSSL_EXTRA */\n\n    /* Get modulus */\n    ret = GetASNInt(input, inOutIdx, &length, inSz);\n    *key_n += *inOutIdx;\n    if (ret < 0) {\n        return ASN_RSA_KEY_E;\n    }\n    if (key_n_len)\n        *key_n_len = length;\n    *inOutIdx += length;\n\n    /* Get exponent */\n    ret = GetASNInt(input, inOutIdx, &length, inSz);\n    *key_e += *inOutIdx;\n    if (ret < 0) {\n        return ASN_RSA_KEY_E;\n    }\n    if (key_e_len)\n        *key_e_len = length;\n\n    return ret;\n}\n#endif /* WOLFSSL_RENESAS_TSIP */\n\nint wc_RsaPublicKeyDecode_ex(const byte* input, word32* inOutIdx, word32 inSz,\n    const byte** n, word32* nSz, const byte** e, word32* eSz)\n{\n    int ret = 0;\n    int length = 0;\n#if defined(OPENSSL_EXTRA) || defined(RSA_DECODE_EXTRA)\n    word32 localIdx;\n    byte   tag;\n#endif\n\n    if (input == NULL || inOutIdx == NULL)\n        return BAD_FUNC_ARG;\n\n    if (GetSequence(input, inOutIdx, &length, inSz) < 0)\n        return ASN_PARSE_E;\n\n#if defined(OPENSSL_EXTRA) || defined(RSA_DECODE_EXTRA)\n    localIdx = *inOutIdx;\n    if (GetASNTag(input, &localIdx, &tag, inSz) < 0)\n        return BUFFER_E;\n\n    if (tag != ASN_INTEGER) {\n        /* not from decoded cert, will have algo id, skip past */\n        if (GetSequence(input, inOutIdx, &length, inSz) < 0)\n            return ASN_PARSE_E;\n\n        if (SkipObjectId(input, inOutIdx, inSz) < 0)\n            return ASN_PARSE_E;\n\n        /* Option NULL ASN.1 tag */\n        if (*inOutIdx  >= inSz) {\n            return BUFFER_E;\n        }\n\n        localIdx = *inOutIdx;\n        if (GetASNTag(input, &localIdx, &tag, inSz) < 0)\n            return ASN_PARSE_E;\n\n        if (tag == ASN_TAG_NULL) {\n            ret = GetASNNull(input, inOutIdx, inSz);\n            if (ret != 0)\n                return ret;\n        }\n\n        /* should have bit tag length and seq next */\n        ret = CheckBitString(input, inOutIdx, NULL, inSz, 1, NULL);\n        if (ret != 0)\n            return ret;\n\n        if (GetSequence(input, inOutIdx, &length, inSz) < 0)\n            return ASN_PARSE_E;\n    }\n#endif /* OPENSSL_EXTRA */\n\n    /* Get modulus */\n    ret = GetASNInt(input, inOutIdx, &length, inSz);\n    if (ret < 0) {\n        return ASN_RSA_KEY_E;\n    }\n    if (nSz)\n        *nSz = length;\n    if (n)\n        *n = &input[*inOutIdx];\n    *inOutIdx += length;\n\n    /* Get exponent */\n    ret = GetASNInt(input, inOutIdx, &length, inSz);\n    if (ret < 0) {\n        return ASN_RSA_KEY_E;\n    }\n    if (eSz)\n        *eSz = length;\n    if (e)\n        *e = &input[*inOutIdx];\n    *inOutIdx += length;\n\n    return ret;\n}\n\nint wc_RsaPublicKeyDecode(const byte* input, word32* inOutIdx, RsaKey* key,\n                       word32 inSz)\n{\n    int ret;\n    const byte *n = NULL, *e = NULL;\n    word32 nSz = 0, eSz = 0;\n\n    if (key == NULL)\n        return BAD_FUNC_ARG;\n\n    ret = wc_RsaPublicKeyDecode_ex(input, inOutIdx, inSz, &n, &nSz, &e, &eSz);\n    if (ret == 0) {\n        ret = wc_RsaPublicKeyDecodeRaw(n, nSz, e, eSz, key);\n    }\n\n    return ret;\n}\n\n/* import RSA public key elements (n, e) into RsaKey structure (key) */\nint wc_RsaPublicKeyDecodeRaw(const byte* n, word32 nSz, const byte* e,\n                             word32 eSz, RsaKey* key)\n{\n    if (n == NULL || e == NULL || key == NULL)\n        return BAD_FUNC_ARG;\n\n    key->type = RSA_PUBLIC;\n\n    if (mp_init(&key->n) != MP_OKAY)\n        return MP_INIT_E;\n\n    if (mp_read_unsigned_bin(&key->n, n, nSz) != 0) {\n        mp_clear(&key->n);\n        return ASN_GETINT_E;\n    }\n#ifdef HAVE_WOLF_BIGINT\n    if ((int)nSz > 0 && wc_bigint_from_unsigned_bin(&key->n.raw, n, nSz) != 0) {\n        mp_clear(&key->n);\n        return ASN_GETINT_E;\n    }\n#endif /* HAVE_WOLF_BIGINT */\n\n    if (mp_init(&key->e) != MP_OKAY) {\n        mp_clear(&key->n);\n        return MP_INIT_E;\n    }\n\n    if (mp_read_unsigned_bin(&key->e, e, eSz) != 0) {\n        mp_clear(&key->n);\n        mp_clear(&key->e);\n        return ASN_GETINT_E;\n    }\n#ifdef HAVE_WOLF_BIGINT\n    if ((int)eSz > 0 && wc_bigint_from_unsigned_bin(&key->e.raw, e, eSz) != 0) {\n        mp_clear(&key->n);\n        mp_clear(&key->e);\n        return ASN_GETINT_E;\n    }\n#endif /* HAVE_WOLF_BIGINT */\n\n#ifdef WOLFSSL_XILINX_CRYPT\n    if (wc_InitRsaHw(key) != 0) {\n        return BAD_STATE_E;\n    }\n#endif\n\n    return 0;\n}\n#endif /* HAVE_USER_RSA */\n#endif /* !NO_RSA */\n\n#ifndef NO_DH\n#if defined(WOLFSSL_DH_EXTRA)\n/*\n * Decodes DH public key to fill specified DhKey.\n *\n * return 0 on success, negative on failure\n */\nint wc_DhPublicKeyDecode(const byte* input, word32* inOutIdx,\n                DhKey* key, word32 inSz)\n{\n    int ret = 0;\n    int length;\n    word32 oid = 0;\n\n    if (input == NULL || inOutIdx == NULL || key == NULL || inSz == 0)\n        return BAD_FUNC_ARG;\n\n    if (GetSequence(input, inOutIdx, &length, inSz) < 0)\n        return ASN_PARSE_E;\n\n    if (GetSequence(input, inOutIdx, &length, inSz) < 0)\n        return ASN_PARSE_E;\n\n    ret = GetObjectId(input, inOutIdx, &oid, oidKeyType, inSz);\n    if (oid != DHk || ret < 0)\n        return ASN_DH_KEY_E;\n\n    if (GetSequence(input, inOutIdx, &length, inSz) < 0)\n        return ASN_PARSE_E;\n\n    if (GetInt(&key->p, input, inOutIdx, inSz) < 0)\n        return ASN_DH_KEY_E;\n\n    if (GetInt(&key->g, input, inOutIdx, inSz) < 0) {\n        mp_clear(&key->p);\n        return ASN_DH_KEY_E;\n    }\n    ret = (CheckBitString(input, inOutIdx, &length, inSz, 0, NULL) == 0);\n    if (ret > 0) {\n        /* Found Bit String WOLFSSL_DH_EXTRA is required to access DhKey.pub */\n        if (GetInt(&key->pub, input, inOutIdx, inSz) < 0) {\n            mp_clear(&key->p);\n            mp_clear(&key->g);\n            return ASN_DH_KEY_E;\n        }\n    }\n    else {\n        mp_clear(&key->p);\n        mp_clear(&key->g);\n        return ASN_DH_KEY_E;\n    }\n    return 0;\n}\n#endif /* WOLFSSL_DH_EXTRA */\n\n/* Supports either:\n * - DH params G/P (PKCS#3 DH) file or\n * - DH key file (if WOLFSSL_DH_EXTRA enabled) */\n/* The wc_DhParamsLoad function also loads DH params, but directly into buffers, not DhKey */\nint wc_DhKeyDecode(const byte* input, word32* inOutIdx, DhKey* key, word32 inSz)\n{\n    int ret = 0;\n    int length;\n#ifdef WOLFSSL_DH_EXTRA\n    #if !defined(HAVE_FIPS) || \\\n        (defined(HAVE_FIPS_VERSION) && (HAVE_FIPS_VERSION > 2))\n    word32 oid = 0, temp = 0;\n    #endif\n#endif\n\n    WOLFSSL_ENTER(\"wc_DhKeyDecode\");\n\n    if (inOutIdx == NULL)\n        return BAD_FUNC_ARG;\n\n    if (GetSequence(input, inOutIdx, &length, inSz) < 0)\n        return ASN_PARSE_E;\n\n#ifdef WOLFSSL_DH_EXTRA\n    #if !defined(HAVE_FIPS) || \\\n        (defined(HAVE_FIPS_VERSION) && (HAVE_FIPS_VERSION > 2))\n    temp = *inOutIdx;\n    #endif\n#endif\n    /* Assume input started after 1.2.840.113549.1.3.1 dhKeyAgreement */\n    if (GetInt(&key->p, input, inOutIdx, inSz) < 0) {\n        ret = ASN_DH_KEY_E;\n    }\n    if (ret == 0 && GetInt(&key->g, input, inOutIdx, inSz) < 0) {\n        mp_clear(&key->p);\n        ret = ASN_DH_KEY_E;\n    }\n\n#ifdef WOLFSSL_DH_EXTRA\n    #if !defined(HAVE_FIPS) || \\\n        (defined(HAVE_FIPS_VERSION) && (HAVE_FIPS_VERSION > 2))\n    /* If ASN_DH_KEY_E: Check if input started at beginning of key */\n    if (ret == ASN_DH_KEY_E) {\n        *inOutIdx = temp;\n\n        /* the version (0) - private only (for public skip) */\n        if (GetASNInt(input, inOutIdx, &length, inSz) == 0) {\n            *inOutIdx += length;\n        }\n\n        /* Size of dhKeyAgreement section */\n        if (GetSequence(input, inOutIdx, &length, inSz) < 0)\n            return ASN_PARSE_E;\n\n        /* Check for dhKeyAgreement */\n        ret = GetObjectId(input, inOutIdx, &oid, oidKeyType, inSz);\n        if (oid != DHk || ret < 0)\n            return ASN_DH_KEY_E;\n\n        if (GetSequence(input, inOutIdx, &length, inSz) < 0)\n            return ASN_PARSE_E;\n\n        if (GetInt(&key->p, input, inOutIdx, inSz) < 0) {\n            return ASN_DH_KEY_E;\n        }\n        if (ret == 0 && GetInt(&key->g, input, inOutIdx, inSz) < 0) {\n            mp_clear(&key->p);\n            return ASN_DH_KEY_E;\n        }\n    }\n\n    temp = *inOutIdx;\n    ret = (CheckBitString(input, inOutIdx, &length, inSz, 0, NULL) == 0);\n    if (ret > 0) {\n        /* Found Bit String */\n        if (GetInt(&key->pub, input, inOutIdx, inSz) == 0) {\n            WOLFSSL_MSG(\"Found Public Key\");\n            ret = 0;\n        }\n    } else {\n        *inOutIdx = temp;\n        ret = (GetOctetString(input, inOutIdx, &length, inSz) >= 0);\n        if (ret > 0) {\n            /* Found Octet String */\n            if (GetInt(&key->priv, input, inOutIdx, inSz) == 0) {\n                WOLFSSL_MSG(\"Found Private Key\");\n\n                /* Compute public */\n                ret = mp_exptmod(&key->g, &key->priv, &key->p, &key->pub);\n            }\n        } else {\n            /* Don't use length from failed CheckBitString/GetOctetString */\n            *inOutIdx = temp;\n            ret = 0;\n        }\n    }\n    #endif /* !HAVE_FIPS || HAVE_FIPS_VERSION > 2 */\n#endif /* WOLFSSL_DH_EXTRA */\n\n    WOLFSSL_LEAVE(\"wc_DhKeyDecode\", ret);\n\n    return ret;\n}\n\n#ifdef WOLFSSL_DH_EXTRA\n\n/* Export DH Key (private or public) */\nint wc_DhKeyToDer(DhKey* key, byte* output, word32* outSz, int exportPriv)\n{\n    int ret, privSz = 0, pubSz = 0, keySz;\n    word32 idx, total;\n\n    if (key == NULL || outSz == NULL) {\n        return BAD_FUNC_ARG;\n    }\n\n    /* determine size */\n    if (exportPriv) {\n        /* octect string: priv */\n        privSz = SetASNIntMP(&key->priv, -1, NULL);\n        idx = 1 + SetLength(privSz, NULL) + privSz; /* +1 for ASN_OCTET_STRING */\n    }\n    else {\n        /* bit string: public */\n        pubSz = SetASNIntMP(&key->pub, -1, NULL);\n        idx = SetBitString(pubSz, 0, NULL) + pubSz;\n    }\n    keySz = idx;\n\n    /* DH Parameters sequence with P and G */\n    total = 0;\n    ret = wc_DhParamsToDer(key, NULL, &total);\n    if (ret != LENGTH_ONLY_E)\n        return ret;\n    idx += total;\n\n    /* object dhKeyAgreement 1.2.840.113549.1.3.1 */\n    idx += SetObjectId(sizeof(keyDhOid), NULL);\n    idx += sizeof(keyDhOid);\n    /* sequence */\n    idx += SetSequence(idx, NULL);\n    if (exportPriv) {\n        /* version: 0 (ASN_INTEGER, 0x01, 0x00) */\n        idx += 3;\n    }\n    /* sequence */\n    total = idx + SetSequence(idx, NULL);\n\n    /* if no output, then just getting size */\n    if (output == NULL) {\n        *outSz = total;\n        return LENGTH_ONLY_E;\n    }\n\n    /* make sure output fits in buffer */\n    if (total > *outSz) {\n        return BUFFER_E;\n    }\n    total = idx;\n\n    /* sequence */\n    idx = SetSequence(total, output);\n    if (exportPriv) {\n        /* version: 0 */\n        idx += SetMyVersion(0, output + idx, 0);\n    }\n    /* sequence - all but pub/priv */\n    idx += SetSequence(total - keySz - idx, output + idx);\n    /* object dhKeyAgreement 1.2.840.113549.1.3.1 */\n    idx += SetObjectId(sizeof(keyDhOid), output + idx);\n    XMEMCPY(output + idx, keyDhOid, sizeof(keyDhOid));\n    idx += sizeof(keyDhOid);\n\n    /* DH Parameters sequence with P and G */\n    total = *outSz - idx;\n    ret = wc_DhParamsToDer(key, output + idx, &total);\n    if (ret < 0)\n        return ret;\n    idx += total;\n\n    /* octect string: priv */\n    if (exportPriv) {\n        idx += SetOctetString(privSz, output + idx);\n        idx += SetASNIntMP(&key->priv, -1, output + idx);        \n    }\n    else {\n        /* bit string: public */\n        idx += SetBitString(pubSz, 0, output + idx);\n        idx += SetASNIntMP(&key->pub, -1, output + idx);\n    }\n    *outSz = idx;\n\n    return idx;    \n}\n\nint wc_DhPubKeyToDer(DhKey* key, byte* out, word32* outSz)\n{\n    return wc_DhKeyToDer(key, out, outSz, 0);\n}\nint wc_DhPrivKeyToDer(DhKey* key, byte* out, word32* outSz)\n{\n    return wc_DhKeyToDer(key, out, outSz, 1);\n}\n\n\n/* Convert DH key parameters to DER format, write to output (outSz)\n * If output is NULL then max expected size is set to outSz and LENGTH_ONLY_E is\n * returned.\n *\n * Note : static function due to redefinition complications with DhKey and FIPS\n * version 2 build.\n *\n * return bytes written on success */\nint wc_DhParamsToDer(DhKey* key, byte* output, word32* outSz)\n{\n    word32 idx, total;\n\n    if (key == NULL || outSz == NULL) {\n        return BAD_FUNC_ARG;\n    }\n\n    /* determine size */\n    /* integer - g */\n    idx = SetASNIntMP(&key->g, -1, NULL);\n    /* integer - p */\n    idx += SetASNIntMP(&key->p, -1, NULL);\n    total = idx;\n     /* sequence */\n    idx += SetSequence(idx, NULL);\n\n    if (output == NULL) {\n        *outSz = idx;\n        return LENGTH_ONLY_E;\n    }\n    /* make sure output fits in buffer */\n    if (idx > *outSz) {\n        return BUFFER_E;\n    }\n\n\n    /* write DH parameters */\n    /* sequence - for P and G only */\n    idx = SetSequence(total, output);\n    /* integer - p */\n    idx += SetASNIntMP(&key->p, -1, output + idx);\n    /* integer - g */\n    idx += SetASNIntMP(&key->g, -1, output + idx);\n    *outSz = idx;\n\n    return idx;\n}\n\n#endif /* WOLFSSL_DH_EXTRA */\n\nint wc_DhParamsLoad(const byte* input, word32 inSz, byte* p, word32* pInOutSz,\n                 byte* g, word32* gInOutSz)\n{\n    word32 idx = 0;\n    int    ret;\n    int    length;\n\n    if (GetSequence(input, &idx, &length, inSz) <= 0)\n        return ASN_PARSE_E;\n\n    ret = GetASNInt(input, &idx, &length, inSz);\n    if (ret != 0)\n        return ret;\n\n    if (length <= (int)*pInOutSz) {\n        XMEMCPY(p, &input[idx], length);\n        *pInOutSz = length;\n    }\n    else {\n        return BUFFER_E;\n    }\n    idx += length;\n\n    ret = GetASNInt(input, &idx, &length, inSz);\n    if (ret != 0)\n        return ret;\n\n    if (length <= (int)*gInOutSz) {\n        XMEMCPY(g, &input[idx], length);\n        *gInOutSz = length;\n    }\n    else {\n        return BUFFER_E;\n    }\n\n    return 0;\n}\n#endif /* !NO_DH */\n\n\n#ifndef NO_DSA\n\nint DsaPublicKeyDecode(const byte* input, word32* inOutIdx, DsaKey* key,\n                        word32 inSz)\n{\n    int    length;\n    int    ret = 0;\n    word32 oid;\n    word32 maxIdx;\n\n    if (input == NULL || inOutIdx == NULL || key == NULL)\n        return BAD_FUNC_ARG;\n\n    if (GetSequence(input, inOutIdx, &length, inSz) < 0)\n        return ASN_PARSE_E;\n\n    maxIdx = (word32)(*inOutIdx + length);\n    if (GetInt(&key->p,  input, inOutIdx, maxIdx) < 0 ||\n        GetInt(&key->q,  input, inOutIdx, maxIdx) < 0 ||\n        GetInt(&key->g,  input, inOutIdx, maxIdx) < 0 ||\n        GetInt(&key->y,  input, inOutIdx, maxIdx) < 0 )\n        ret = ASN_DH_KEY_E;\n\n    if (ret != 0) {\n        if (GetSequence(input, inOutIdx, &length, inSz) < 0)\n            return ASN_PARSE_E;\n\n        ret = GetObjectId(input, inOutIdx, &oid, oidIgnoreType, inSz);\n        if (ret != 0)\n            return ret;\n\n        if (GetSequence(input, inOutIdx, &length, inSz) < 0)\n            return ASN_PARSE_E;\n\n        if (GetInt(&key->p,  input, inOutIdx, inSz) < 0 ||\n            GetInt(&key->q,  input, inOutIdx, inSz) < 0 ||\n            GetInt(&key->g,  input, inOutIdx, inSz) < 0)\n            return ASN_DH_KEY_E;\n\n        if (CheckBitString(input, inOutIdx, &length, inSz, 0, NULL) < 0)\n            return ASN_PARSE_E;\n\n        if (GetInt(&key->y,  input, inOutIdx, inSz) < 0 )\n            return ASN_DH_KEY_E;\n\n        ret = 0;\n    }\n\n    key->type = DSA_PUBLIC;\n    return ret;\n}\n\nint wc_DsaParamsDecode(const byte* input, word32* inOutIdx, DsaKey* key,\n                        word32 inSz)\n{\n    int    length;\n    word32 maxIdx;\n\n    if (input == NULL || inOutIdx == NULL || key == NULL)\n        return BAD_FUNC_ARG;\n\n    if (GetSequence(input, inOutIdx, &length, inSz) < 0)\n        return ASN_PARSE_E;\n\n    maxIdx = (word32)(*inOutIdx + length);\n    if (GetInt(&key->p, input, inOutIdx, maxIdx) < 0 ||\n        GetInt(&key->q, input, inOutIdx, maxIdx) < 0 ||\n        GetInt(&key->g, input, inOutIdx, maxIdx) < 0)\n        return ASN_DH_KEY_E;\n\n    return 0;\n}\n\n\nint DsaPrivateKeyDecode(const byte* input, word32* inOutIdx, DsaKey* key,\n                        word32 inSz)\n{\n    int    length, version, ret = 0, temp = 0;\n\n    /* Sanity checks on input */\n    if (input == NULL || inOutIdx == NULL || key == NULL) {\n        return BAD_FUNC_ARG;\n    }\n\n    if (GetSequence(input, inOutIdx, &length, inSz) < 0)\n        return ASN_PARSE_E;\n\n    temp = (int)*inOutIdx;\n\n    /* Default case expects a certificate with OctetString but no version ID */\n    ret = GetInt(&key->p, input, inOutIdx, inSz);\n    if (ret < 0) {\n        mp_clear(&key->p);\n        ret = ASN_PARSE_E;\n    }\n    else {\n        ret = GetInt(&key->q, input, inOutIdx, inSz);\n        if (ret < 0) {\n            mp_clear(&key->p);\n            mp_clear(&key->q);\n            ret = ASN_PARSE_E;\n        }\n        else {\n            ret = GetInt(&key->g, input, inOutIdx, inSz);\n            if (ret < 0) {\n                mp_clear(&key->p);\n                mp_clear(&key->q);\n                mp_clear(&key->g);\n                ret = ASN_PARSE_E;\n            }\n            else {\n                ret = GetOctetString(input, inOutIdx, &length, inSz);\n                if (ret < 0) {\n                    mp_clear(&key->p);\n                    mp_clear(&key->q);\n                    mp_clear(&key->g);\n                    ret = ASN_PARSE_E;\n                }\n                else {\n                    ret = GetInt(&key->y, input, inOutIdx, inSz);\n                    if (ret < 0) {\n                        mp_clear(&key->p);\n                        mp_clear(&key->q);\n                        mp_clear(&key->g);\n                        mp_clear(&key->y);\n                        ret = ASN_PARSE_E;\n                    }\n                }\n            }\n        }\n    }\n    /* An alternate pass if default certificate fails parsing */\n    if (ret == ASN_PARSE_E) {\n        *inOutIdx = temp;\n        if (GetMyVersion(input, inOutIdx, &version, inSz) < 0)\n            return ASN_PARSE_E;\n\n        if (GetInt(&key->p,  input, inOutIdx, inSz) < 0 ||\n            GetInt(&key->q,  input, inOutIdx, inSz) < 0 ||\n            GetInt(&key->g,  input, inOutIdx, inSz) < 0 ||\n            GetInt(&key->y,  input, inOutIdx, inSz) < 0 ||\n            GetInt(&key->x,  input, inOutIdx, inSz) < 0 )\n            return ASN_DH_KEY_E;\n    }\n\n    key->type = DSA_PRIVATE;\n    return 0;\n}\n\nstatic mp_int* GetDsaInt(DsaKey* key, int idx)\n{\n    /* Other functions depend on this order. Please don't change it. */\n    if (idx == 0)\n        return &key->p;\n    if (idx == 1)\n        return &key->q;\n    if (idx == 2)\n        return &key->g;\n    if (idx == 3)\n        return &key->y;\n    if (idx == 4)\n        return &key->x;\n\n    return NULL;\n}\n\n/* Release Tmp DSA resources */\nstatic WC_INLINE void FreeTmpDsas(byte** tmps, void* heap, int ints)\n{\n    int i;\n\n    for (i = 0; i < ints; i++)\n        XFREE(tmps[i], heap, DYNAMIC_TYPE_DSA);\n\n    (void)heap;\n}\n\n#if !defined(HAVE_SELFTEST) && (defined(WOLFSSL_KEY_GEN) || \\\n        defined(WOLFSSL_CERT_GEN))\n/* Write a public DSA key to output */\nint wc_SetDsaPublicKey(byte* output, DsaKey* key,\n                           int outLen, int with_header)\n{\n    /* p, g, q = DSA params, y = public exponent */\n#ifdef WOLFSSL_SMALL_STACK\n    byte* p = NULL;\n    byte* g = NULL;\n    byte* q = NULL;\n    byte* y = NULL;\n#else\n    byte p[MAX_DSA_INT_SZ];\n    byte g[MAX_DSA_INT_SZ];\n    byte q[MAX_DSA_INT_SZ];\n    byte y[MAX_DSA_INT_SZ];\n#endif\n    byte innerSeq[MAX_SEQ_SZ];\n    byte outerSeq[MAX_SEQ_SZ];\n    byte bitString[1 + MAX_LENGTH_SZ + 1];\n    int  idx, pSz, gSz, qSz, ySz, innerSeqSz, outerSeqSz, bitStringSz = 0;\n\n    WOLFSSL_ENTER(\"wc_SetDsaPublicKey\");\n\n    if (output == NULL || key == NULL || outLen < MAX_SEQ_SZ) {\n        return BAD_FUNC_ARG;\n    }\n\n    /* p */\n#ifdef WOLFSSL_SMALL_STACK\n    p = (byte*)XMALLOC(MAX_DSA_INT_SZ, key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n    if (p == NULL)\n        return MEMORY_E;\n#endif\n    if ((pSz = SetASNIntMP(&key->p, MAX_DSA_INT_SZ, p)) < 0) {\n        WOLFSSL_MSG(\"SetASNIntMP Error with p\");\n#ifdef WOLFSSL_SMALL_STACK\n        XFREE(p, key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n#endif\n        return pSz;\n    }\n\n    /* q */\n#ifdef WOLFSSL_SMALL_STACK\n    q = (byte*)XMALLOC(MAX_DSA_INT_SZ, key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n    if (q == NULL)\n        return MEMORY_E;\n#endif\n    if ((qSz = SetASNIntMP(&key->q, MAX_DSA_INT_SZ, q)) < 0) {\n        WOLFSSL_MSG(\"SetASNIntMP Error with q\");\n#ifdef WOLFSSL_SMALL_STACK\n        XFREE(p, key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n        XFREE(q, key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n#endif\n        return qSz;\n    }\n\n    /* g */\n#ifdef WOLFSSL_SMALL_STACK\n    g = (byte*)XMALLOC(MAX_DSA_INT_SZ, key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n    if (g == NULL)\n        return MEMORY_E;\n#endif\n    if ((gSz = SetASNIntMP(&key->g, MAX_DSA_INT_SZ, g)) < 0) {\n        WOLFSSL_MSG(\"SetASNIntMP Error with g\");\n#ifdef WOLFSSL_SMALL_STACK\n        XFREE(p, key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n        XFREE(q, key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n        XFREE(g, key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n#endif\n        return gSz;\n    }\n\n    /* y */\n#ifdef WOLFSSL_SMALL_STACK\n    y = (byte*)XMALLOC(MAX_DSA_INT_SZ, key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n    if (y == NULL)\n        return MEMORY_E;\n#endif\n    if ((ySz = SetASNIntMP(&key->y, MAX_DSA_INT_SZ, y)) < 0) {\n        WOLFSSL_MSG(\"SetASNIntMP Error with y\");\n#ifdef WOLFSSL_SMALL_STACK\n        XFREE(p, key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n        XFREE(q, key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n        XFREE(g, key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n        XFREE(y, key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n#endif\n        return ySz;\n    }\n\n    innerSeqSz  = SetSequence(pSz + qSz + gSz, innerSeq);\n\n    /* check output size */\n    if ((innerSeqSz + pSz + qSz + gSz) > outLen) {\n#ifdef WOLFSSL_SMALL_STACK\n        XFREE(p,    key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n        XFREE(q,    key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n        XFREE(g,    key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n        XFREE(y,    key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n#endif\n        WOLFSSL_MSG(\"Error, output size smaller than outlen\");\n        return BUFFER_E;\n    }\n\n    if (with_header) {\n        int algoSz;\n#ifdef WOLFSSL_SMALL_STACK\n        byte* algo = NULL;\n\n        algo = (byte*)XMALLOC(MAX_ALGO_SZ, key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n        if (algo == NULL) {\n            XFREE(p,    key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n            XFREE(q,    key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n            XFREE(g,    key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n            XFREE(y,    key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n            return MEMORY_E;\n        }\n#else\n        byte algo[MAX_ALGO_SZ];\n#endif\n        algoSz = SetAlgoID(DSAk, algo, oidKeyType, 0);\n        bitStringSz  = SetBitString(ySz, 0, bitString);\n        outerSeqSz = SetSequence(algoSz + innerSeqSz + pSz + qSz + gSz,\n                                                                      outerSeq);\n\n        idx = SetSequence(algoSz + innerSeqSz + pSz + qSz + gSz + bitStringSz +\n                                                      ySz + outerSeqSz, output);\n\n        /* check output size */\n        if ((idx + algoSz + bitStringSz + innerSeqSz + pSz + qSz + gSz + ySz) >\n                                                                       outLen) {\n            #ifdef WOLFSSL_SMALL_STACK\n                XFREE(p,    key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n                XFREE(q,    key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n                XFREE(g,    key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n                XFREE(y,    key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n                XFREE(algo, key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n            #endif\n            WOLFSSL_MSG(\"Error, output size smaller than outlen\");\n            return BUFFER_E;\n        }\n\n        /* outerSeq */\n        XMEMCPY(output + idx, outerSeq, outerSeqSz);\n        idx += outerSeqSz;\n        /* algo */\n        XMEMCPY(output + idx, algo, algoSz);\n        idx += algoSz;\n#ifdef WOLFSSL_SMALL_STACK\n        XFREE(algo, key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n#endif\n    } else {\n        idx = 0;\n    }\n\n    /* innerSeq */\n    XMEMCPY(output + idx, innerSeq, innerSeqSz);\n    idx += innerSeqSz;\n    /* p */\n    XMEMCPY(output + idx, p, pSz);\n    idx += pSz;\n    /* q */\n    XMEMCPY(output + idx, q, qSz);\n    idx += qSz;\n    /* g */\n    XMEMCPY(output + idx, g, gSz);\n    idx += gSz;\n    /* bit string */\n    if (bitStringSz > 0) {\n        XMEMCPY(output + idx, bitString, bitStringSz);\n        idx += bitStringSz;\n    }\n    /* y */\n    XMEMCPY(output + idx, y, ySz);\n    idx += ySz;\n\n#ifdef WOLFSSL_SMALL_STACK\n    XFREE(p,    key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n    XFREE(q,    key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n    XFREE(g,    key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n    XFREE(y,    key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n#endif\n    return idx;\n}\n\n/* Convert DSA Public key to DER format, write to output (inLen), return bytes\n   written */\nint wc_DsaKeyToPublicDer(DsaKey* key, byte* output, word32 inLen)\n{\n    return wc_SetDsaPublicKey(output, key, inLen, 1);\n}\n#endif /* !HAVE_SELFTEST && (WOLFSSL_KEY_GEN || WOLFSSL_CERT_GEN) */\n\nstatic int DsaKeyIntsToDer(DsaKey* key, byte* output, word32 inLen,\n                           int ints, int includeVersion)\n{\n    word32 seqSz = 0, verSz = 0, rawLen, intTotalLen = 0;\n    word32 sizes[DSA_INTS];\n    int    i, j, outLen, ret = 0, mpSz;\n\n    byte  seq[MAX_SEQ_SZ];\n    byte  ver[MAX_VERSION_SZ];\n    byte* tmps[DSA_INTS];\n\n    if (ints > DSA_INTS)\n        return BAD_FUNC_ARG;\n\n    XMEMSET(sizes, 0, sizeof(sizes));\n    for (i = 0; i < ints; i++)\n        tmps[i] = NULL;\n\n    /* write all big ints from key to DER tmps */\n    for (i = 0; i < ints; i++) {\n        mp_int* keyInt = GetDsaInt(key, i);\n\n        rawLen = mp_unsigned_bin_size(keyInt) + 1;\n        tmps[i] = (byte*)XMALLOC(rawLen + MAX_SEQ_SZ, key->heap,\n                                                              DYNAMIC_TYPE_DSA);\n        if (tmps[i] == NULL) {\n            ret = MEMORY_E;\n            break;\n        }\n\n        mpSz = SetASNIntMP(keyInt, -1, tmps[i]);\n        if (mpSz < 0) {\n            ret = mpSz;\n            break;\n        }\n        intTotalLen += (sizes[i] = mpSz);\n    }\n\n    if (ret != 0) {\n        FreeTmpDsas(tmps, key->heap, ints);\n        return ret;\n    }\n\n    /* make headers */\n    if (includeVersion)\n        verSz = SetMyVersion(0, ver, FALSE);\n    seqSz = SetSequence(verSz + intTotalLen, seq);\n\n    outLen = seqSz + verSz + intTotalLen;\n    if (outLen > (int)inLen) {\n        FreeTmpDsas(tmps, key->heap, ints);\n        return BAD_FUNC_ARG;\n    }\n\n    /* write to output */\n    XMEMCPY(output, seq, seqSz);\n    j = seqSz;\n    if (includeVersion) {\n        XMEMCPY(output + j, ver, verSz);\n        j += verSz;\n    }\n\n    for (i = 0; i < ints; i++) {\n        XMEMCPY(output + j, tmps[i], sizes[i]);\n        j += sizes[i];\n    }\n    FreeTmpDsas(tmps, key->heap, ints);\n\n    return outLen;\n}\n\n/* Convert private DsaKey key to DER format, write to output (inLen),\n   return bytes written */\nint wc_DsaKeyToDer(DsaKey* key, byte* output, word32 inLen)\n{\n    if (!key || !output)\n        return BAD_FUNC_ARG;\n\n    if (key->type != DSA_PRIVATE)\n        return BAD_FUNC_ARG;\n\n    return DsaKeyIntsToDer(key, output, inLen, DSA_INTS, 1);\n}\n\n/* Convert DsaKey parameters to DER format, write to output (inLen),\n   return bytes written. Version is excluded to be compatible with\n   OpenSSL d2i_DSAparams */\nint wc_DsaKeyToParamsDer(DsaKey* key, byte* output, word32 inLen)\n{\n    if (!key || !output)\n        return BAD_FUNC_ARG;\n\n    return DsaKeyIntsToDer(key, output, inLen, DSA_PARAM_INTS, 0);\n}\n\n#endif /* NO_DSA */\n\nvoid InitDecodedCert(DecodedCert* cert,\n                     const byte* source, word32 inSz, void* heap)\n{\n    if (cert != NULL) {\n        XMEMSET(cert, 0, sizeof(DecodedCert));\n\n        cert->subjectCNEnc    = CTC_UTF8;\n        cert->issuer[0]       = '\\0';\n        cert->subject[0]      = '\\0';\n        cert->source          = source;  /* don't own */\n        cert->maxIdx          = inSz;    /* can't go over this index */\n        cert->heap            = heap;\n        cert->maxPathLen      = WOLFSSL_MAX_PATH_LEN;\n    #ifdef WOLFSSL_CERT_GEN\n        cert->subjectSNEnc    = CTC_UTF8;\n        cert->subjectCEnc     = CTC_PRINTABLE;\n        cert->subjectLEnc     = CTC_UTF8;\n        cert->subjectSTEnc    = CTC_UTF8;\n        cert->subjectOEnc     = CTC_UTF8;\n        cert->subjectOUEnc    = CTC_UTF8;\n    #endif /* WOLFSSL_CERT_GEN */\n\n    #ifndef NO_CERTS\n        InitSignatureCtx(&cert->sigCtx, heap, INVALID_DEVID);\n    #endif\n    }\n}\n\n\nvoid FreeAltNames(DNS_entry* altNames, void* heap)\n{\n    (void)heap;\n\n    while (altNames) {\n        DNS_entry* tmp = altNames->next;\n\n        XFREE(altNames->name, heap, DYNAMIC_TYPE_ALTNAME);\n        XFREE(altNames,       heap, DYNAMIC_TYPE_ALTNAME);\n        altNames = tmp;\n    }\n}\n\n#ifndef IGNORE_NAME_CONSTRAINTS\n\nvoid FreeNameSubtrees(Base_entry* names, void* heap)\n{\n    (void)heap;\n\n    while (names) {\n        Base_entry* tmp = names->next;\n\n        XFREE(names->name, heap, DYNAMIC_TYPE_ALTNAME);\n        XFREE(names,       heap, DYNAMIC_TYPE_ALTNAME);\n        names = tmp;\n    }\n}\n\n#endif /* IGNORE_NAME_CONSTRAINTS */\n\nvoid FreeDecodedCert(DecodedCert* cert)\n{\n    if (cert == NULL)\n        return;\n    if (cert->subjectCNStored == 1)\n        XFREE(cert->subjectCN, cert->heap, DYNAMIC_TYPE_SUBJECT_CN);\n    if (cert->pubKeyStored == 1)\n        XFREE((void*)cert->publicKey, cert->heap, DYNAMIC_TYPE_PUBLIC_KEY);\n    if (cert->weOwnAltNames && cert->altNames)\n        FreeAltNames(cert->altNames, cert->heap);\n#ifndef IGNORE_NAME_CONSTRAINTS\n    if (cert->altEmailNames)\n        FreeAltNames(cert->altEmailNames, cert->heap);\n    if (cert->altDirNames)\n        FreeAltNames(cert->altDirNames, cert->heap);\n    if (cert->permittedNames)\n        FreeNameSubtrees(cert->permittedNames, cert->heap);\n    if (cert->excludedNames)\n        FreeNameSubtrees(cert->excludedNames, cert->heap);\n#endif /* IGNORE_NAME_CONSTRAINTS */\n#ifdef WOLFSSL_SEP\n    XFREE(cert->deviceType, cert->heap, DYNAMIC_TYPE_X509_EXT);\n    XFREE(cert->hwType, cert->heap, DYNAMIC_TYPE_X509_EXT);\n    XFREE(cert->hwSerialNum, cert->heap, DYNAMIC_TYPE_X509_EXT);\n#endif /* WOLFSSL_SEP */\n#if (defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)) && \\\n    !defined(WOLFCRYPT_ONLY)\n    if (cert->issuerName != NULL)\n        wolfSSL_X509_NAME_free((WOLFSSL_X509_NAME*)cert->issuerName);\n    if (cert->subjectName != NULL)\n        wolfSSL_X509_NAME_free((WOLFSSL_X509_NAME*)cert->subjectName);\n#endif /* OPENSSL_EXTRA */\n#ifdef WOLFSSL_RENESAS_TSIP_TLS\n    if (cert->tsip_encRsaKeyIdx != NULL)\n        XFREE(cert->tsip_encRsaKeyIdx, cert->heap, DYNAMIC_TYPE_RSA);\n#endif\n#ifndef NO_CERTS\n    FreeSignatureCtx(&cert->sigCtx);\n#endif\n}\n\nstatic int GetCertHeader(DecodedCert* cert)\n{\n    int ret = 0, len;\n\n    if (GetSequence(cert->source, &cert->srcIdx, &len, cert->maxIdx) < 0)\n        return ASN_PARSE_E;\n\n    /* Reset the max index for the size indicated in the outer wrapper. */\n    cert->maxIdx = len + cert->srcIdx;\n    cert->certBegin = cert->srcIdx;\n\n    if (GetSequence(cert->source, &cert->srcIdx, &len, cert->maxIdx) < 0)\n        return ASN_PARSE_E;\n\n    cert->sigIndex = len + cert->srcIdx;\n    if (cert->sigIndex > cert->maxIdx)\n        return ASN_PARSE_E;\n\n    if (GetExplicitVersion(cert->source, &cert->srcIdx, &cert->version,\n                                                            cert->sigIndex) < 0)\n        return ASN_PARSE_E;\n\n    if (GetSerialNumber(cert->source, &cert->srcIdx, cert->serial,\n                                           &cert->serialSz, cert->sigIndex) < 0)\n        return ASN_PARSE_E;\n\n    return ret;\n}\n\n#if !defined(NO_RSA)\n/* Store Rsa Key, may save later, Dsa could use in future */\nstatic int StoreRsaKey(DecodedCert* cert, word32 bitStringEnd)\n{\n    int    length;\n    word32 recvd = cert->srcIdx;\n\n    if (GetSequence(cert->source, &cert->srcIdx, &length, bitStringEnd) < 0)\n        return ASN_PARSE_E;\n\n    recvd = cert->srcIdx - recvd;\n    length += recvd;\n\n    while (recvd--)\n       cert->srcIdx--;\n#if defined(WOLFSSL_RENESAS_TSIP)\n    cert->sigCtx.pubkey_n_start = cert->sigCtx.pubkey_e_start = cert->srcIdx;\n#endif\n    cert->pubKeySize = length;\n    cert->publicKey = cert->source + cert->srcIdx;\n    cert->srcIdx += length;\n\n    return 0;\n}\n#endif /* !NO_RSA */\n\n#ifdef HAVE_ECC\n\n    /* return 0 on success if the ECC curve oid sum is supported */\n    static int CheckCurve(word32 oid)\n    {\n        int ret = 0;\n        word32 oidSz = 0;\n\n        ret = wc_ecc_get_oid(oid, NULL, &oidSz);\n        if (ret < 0 || oidSz == 0) {\n            WOLFSSL_MSG(\"CheckCurve not found\");\n            ret = ALGO_ID_E;\n        }\n\n        return ret;\n    }\n\n#endif /* HAVE_ECC */\n\nstatic int GetKey(DecodedCert* cert)\n{\n    int length;\n#ifndef NO_DSA\n    int tmpLen;\n#endif\n#if defined(HAVE_ECC) || defined(HAVE_NTRU) || !defined(NO_DSA)\n    int tmpIdx = cert->srcIdx;\n#endif\n\n    if (GetSequence(cert->source, &cert->srcIdx, &length, cert->maxIdx) < 0)\n        return ASN_PARSE_E;\n\n#ifndef NO_DSA\n    tmpLen = length + 4;\n#endif\n\n    if (GetAlgoId(cert->source, &cert->srcIdx,\n                  &cert->keyOID, oidKeyType, cert->maxIdx) < 0)\n        return ASN_PARSE_E;\n\n    switch (cert->keyOID) {\n   #ifndef NO_RSA\n        case RSAk:\n        {\n            int ret;\n\n            ret = CheckBitString(cert->source, &cert->srcIdx, &length,\n                                 cert->maxIdx, 1, NULL);\n            if (ret != 0)\n                return ret;\n\n            #ifdef HAVE_OCSP\n                ret = CalcHashId(cert->source + cert->srcIdx, length,\n                        cert->subjectKeyHash);\n                if (ret != 0)\n                    return ret;\n            #endif\n\n            return StoreRsaKey(cert, cert->srcIdx + length);\n        }\n\n    #endif /* NO_RSA */\n    #ifdef HAVE_NTRU\n        case NTRUk:\n        {\n            const byte* key = &cert->source[tmpIdx];\n            byte*       next = (byte*)key;\n            word16      keyLen;\n            word32      rc;\n            word32      remaining = cert->maxIdx - cert->srcIdx;\n            byte*       publicKey;\n#ifdef WOLFSSL_SMALL_STACK\n            byte*       keyBlob = NULL;\n#else\n            byte        keyBlob[MAX_NTRU_KEY_SZ];\n#endif\n            rc = ntru_crypto_ntru_encrypt_subjectPublicKeyInfo2PublicKey(key,\n                                &keyLen, NULL, &next, &remaining);\n            if (rc != NTRU_OK)\n                return ASN_NTRU_KEY_E;\n            if (keyLen > MAX_NTRU_KEY_SZ)\n                return ASN_NTRU_KEY_E;\n\n#ifdef WOLFSSL_SMALL_STACK\n            keyBlob = (byte*)XMALLOC(MAX_NTRU_KEY_SZ, cert->heap,\n                                     DYNAMIC_TYPE_TMP_BUFFER);\n            if (keyBlob == NULL)\n                return MEMORY_E;\n#endif\n\n            rc = ntru_crypto_ntru_encrypt_subjectPublicKeyInfo2PublicKey(key,\n                                &keyLen, keyBlob, &next, &remaining);\n            if (rc != NTRU_OK) {\n#ifdef WOLFSSL_SMALL_STACK\n                XFREE(keyBlob, cert->heap, DYNAMIC_TYPE_TMP_BUFFER);\n#endif\n                return ASN_NTRU_KEY_E;\n            }\n\n            if ( (next - key) < 0) {\n#ifdef WOLFSSL_SMALL_STACK\n                XFREE(keyBlob, cert->heap, DYNAMIC_TYPE_TMP_BUFFER);\n#endif\n                return ASN_NTRU_KEY_E;\n            }\n\n            cert->srcIdx = tmpIdx + (int)(next - key);\n\n            publicKey = (byte*)XMALLOC(keyLen, cert->heap,\n                                       DYNAMIC_TYPE_PUBLIC_KEY);\n            if (publicKey == NULL) {\n#ifdef WOLFSSL_SMALL_STACK\n                XFREE(keyBlob, cert->heap, DYNAMIC_TYPE_TMP_BUFFER);\n#endif\n                return MEMORY_E;\n            }\n            XMEMCPY(publicKey, keyBlob, keyLen);\n            cert->publicKey = publicKey;\n            cert->pubKeyStored = 1;\n            cert->pubKeySize   = keyLen;\n\n#ifdef WOLFSSL_SMALL_STACK\n            XFREE(keyBlob, cert->heap, DYNAMIC_TYPE_TMP_BUFFER);\n#endif\n\n            return 0;\n        }\n    #endif /* HAVE_NTRU */\n    #ifdef HAVE_ECC\n        case ECDSAk:\n        {\n            int ret;\n            byte seq[5];\n            int pubLen = length + 1 + SetLength(length, seq);\n            word32 localIdx;\n            byte* publicKey;\n            byte  tag;\n\n            localIdx = cert->srcIdx;\n            if (GetASNTag(cert->source, &localIdx, &tag, cert->maxIdx) < 0)\n                return ASN_PARSE_E;\n\n            if (tag != (ASN_SEQUENCE | ASN_CONSTRUCTED)) {\n                if (GetObjectId(cert->source, &cert->srcIdx,\n                            &cert->pkCurveOID, oidCurveType, cert->maxIdx) < 0)\n                    return ASN_PARSE_E;\n\n                if (CheckCurve(cert->pkCurveOID) < 0)\n                    return ECC_CURVE_OID_E;\n\n                /* key header */\n                ret = CheckBitString(cert->source, &cert->srcIdx, &length,\n                                                         cert->maxIdx, 1, NULL);\n                if (ret != 0)\n                    return ret;\n            #ifdef HAVE_OCSP\n                ret = CalcHashId(cert->source + cert->srcIdx, length,\n                        cert->subjectKeyHash);\n                if (ret != 0)\n                    return ret;\n            #endif\n            }\n\n            publicKey = (byte*)XMALLOC(pubLen, cert->heap,\n                                       DYNAMIC_TYPE_PUBLIC_KEY);\n            if (publicKey == NULL)\n                return MEMORY_E;\n            XMEMCPY(publicKey, &cert->source[tmpIdx], pubLen);\n            cert->publicKey = publicKey;\n            cert->pubKeyStored = 1;\n            cert->pubKeySize   = pubLen;\n\n            cert->srcIdx = tmpIdx + pubLen;\n\n            return 0;\n        }\n    #endif /* HAVE_ECC */\n    #ifdef HAVE_ED25519\n        case ED25519k:\n        {\n            byte* publicKey;\n            int ret;\n\n            cert->pkCurveOID = ED25519k;\n\n            ret = CheckBitString(cert->source, &cert->srcIdx, &length,\n                                 cert->maxIdx, 1, NULL);\n            if (ret != 0)\n                return ret;\n\n            #ifdef HAVE_OCSP\n                ret = CalcHashId(cert->source + cert->srcIdx, length,\n                        cert->subjectKeyHash);\n                if (ret != 0)\n                    return ret;\n            #endif\n\n            publicKey = (byte*) XMALLOC(length, cert->heap,\n                                        DYNAMIC_TYPE_PUBLIC_KEY);\n            if (publicKey == NULL)\n                return MEMORY_E;\n            XMEMCPY(publicKey, &cert->source[cert->srcIdx], length);\n            cert->publicKey = publicKey;\n            cert->pubKeyStored = 1;\n            cert->pubKeySize   = length;\n\n            cert->srcIdx += length;\n\n            return 0;\n        }\n    #endif /* HAVE_ED25519 */\n    #ifdef HAVE_ED448\n        case ED448k:\n        {\n            byte* publicKey;\n            int ret;\n\n            cert->pkCurveOID = ED448k;\n\n            ret = CheckBitString(cert->source, &cert->srcIdx, &length,\n                                 cert->maxIdx, 1, NULL);\n            if (ret != 0)\n                return ret;\n\n            #ifdef HAVE_OCSP\n                ret = CalcHashId(cert->source + cert->srcIdx, length,\n                                 cert->subjectKeyHash);\n                if (ret != 0)\n                    return ret;\n            #endif\n\n            publicKey = (byte*) XMALLOC(length, cert->heap,\n                                        DYNAMIC_TYPE_PUBLIC_KEY);\n            if (publicKey == NULL)\n                return MEMORY_E;\n            XMEMCPY(publicKey, &cert->source[cert->srcIdx], length);\n            cert->publicKey = publicKey;\n            cert->pubKeyStored = 1;\n            cert->pubKeySize   = length;\n\n            cert->srcIdx += length;\n\n            return 0;\n        }\n    #endif /* HAVE_ED448 */\n    #ifndef NO_DSA\n        case DSAk:\n        {\n            int ret;\n            ret = GetSequence(cert->source, &cert->srcIdx, &length,\n                           cert->maxIdx);\n            if (ret < 0)\n                return ret;\n\n            ret = SkipInt(cert->source, &cert->srcIdx, cert->maxIdx);\n            if (ret != 0)\n                return ret;\n            ret = SkipInt(cert->source, &cert->srcIdx, cert->maxIdx);\n            if (ret != 0)\n                return ret;\n            ret = SkipInt(cert->source, &cert->srcIdx, cert->maxIdx);\n            if (ret != 0)\n                return ret;\n\n            ret = CheckBitString(cert->source, &cert->srcIdx, &length,\n                                                         cert->maxIdx, 1, NULL);\n            if (ret != 0)\n                return ret;\n\n            ret = GetASNInt(cert->source, &cert->srcIdx, &length, cert->maxIdx);\n            if (ret !=0)\n                return ASN_PARSE_E;\n\n            cert->publicKey = cert->source + tmpIdx;\n            cert->pubKeySize = tmpLen;\n            cert->srcIdx += length;\n            return 0;\n        }\n    #endif /* NO_DSA */\n        default:\n            WOLFSSL_MSG(\"Unknown or not compiled in key OID\");\n            return ASN_UNKNOWN_OID_E;\n    }\n}\n\n#if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)\n#if defined(HAVE_ECC)\n/* Converts ECC curve enum values in ecc_curve_id to the associated OpenSSL NID\n    value */\nWOLFSSL_API int EccEnumToNID(int n)\n{\n    WOLFSSL_ENTER(\"EccEnumToNID()\");\n\n    switch(n) {\n        case ECC_SECP192R1:\n            return NID_X9_62_prime192v1;\n        case ECC_PRIME192V2:\n            return NID_X9_62_prime192v2;\n        case ECC_PRIME192V3:\n            return NID_X9_62_prime192v3;\n        case ECC_PRIME239V1:\n            return NID_X9_62_prime239v1;\n        case ECC_PRIME239V2:\n            return NID_X9_62_prime239v2;\n        case ECC_PRIME239V3:\n            return NID_X9_62_prime239v3;\n        case ECC_SECP256R1:\n            return NID_X9_62_prime256v1;\n        case ECC_SECP112R1:\n            return NID_secp112r1;\n        case ECC_SECP112R2:\n            return NID_secp112r2;\n        case ECC_SECP128R1:\n            return NID_secp128r1;\n        case ECC_SECP128R2:\n            return NID_secp128r2;\n        case ECC_SECP160R1:\n            return NID_secp160r1;\n        case ECC_SECP160R2:\n            return NID_secp160r2;\n        case ECC_SECP224R1:\n            return NID_secp224r1;\n        case ECC_SECP384R1:\n            return NID_secp384r1;\n        case ECC_SECP521R1:\n            return NID_secp521r1;\n        case ECC_SECP160K1:\n            return NID_secp160k1;\n        case ECC_SECP192K1:\n            return NID_secp192k1;\n        case ECC_SECP224K1:\n            return NID_secp224k1;\n        case ECC_SECP256K1:\n            return NID_secp256k1;\n        case ECC_BRAINPOOLP160R1:\n            return NID_brainpoolP160r1;\n        case ECC_BRAINPOOLP192R1:\n            return NID_brainpoolP192r1;\n        case ECC_BRAINPOOLP224R1:\n            return NID_brainpoolP224r1;\n        case ECC_BRAINPOOLP256R1:\n            return NID_brainpoolP256r1;\n        case ECC_BRAINPOOLP320R1:\n            return NID_brainpoolP320r1;\n        case ECC_BRAINPOOLP384R1:\n            return NID_brainpoolP384r1;\n        case ECC_BRAINPOOLP512R1:\n            return NID_brainpoolP512r1;\n        default:\n            WOLFSSL_MSG(\"NID not found\");\n            return -1;\n    }\n}\n#endif /* HAVE_ECC */\n#endif /* OPENSSL_EXTRA || OPENSSL_EXTRA_X509_SMALL */\n\n#if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)\nint wc_OBJ_sn2nid(const char *sn)\n{\n    const struct {\n        const char *sn;\n        int  nid;\n    } sn2nid[] = {\n        {WOLFSSL_COMMON_NAME, NID_commonName},\n        {WOLFSSL_COUNTRY_NAME, NID_countryName},\n        {WOLFSSL_LOCALITY_NAME, NID_localityName},\n        {WOLFSSL_STATE_NAME, NID_stateOrProvinceName},\n        {WOLFSSL_ORG_NAME, NID_organizationName},\n        {WOLFSSL_ORGUNIT_NAME, NID_organizationalUnitName},\n        {WOLFSSL_EMAIL_ADDR, NID_emailAddress},\n        {NULL, -1}};\n    int i;\n    #ifdef HAVE_ECC\n    char curveName[16]; /* Same as MAX_CURVE_NAME_SZ but can't include that\n                         * symbol in this file */\n    int eccEnum;\n    #endif\n    WOLFSSL_ENTER(\"OBJ_sn2nid\");\n    for(i=0; sn2nid[i].sn != NULL; i++) {\n        if(XSTRNCMP(sn, sn2nid[i].sn, XSTRLEN(sn2nid[i].sn)) == 0) {\n            return sn2nid[i].nid;\n        }\n    }\n    #ifdef HAVE_ECC\n    /* Nginx uses this OpenSSL string. */\n    if (XSTRNCMP(sn, \"prime256v1\", 10) == 0)\n        sn = \"SECP256R1\";\n    /* OpenSSL allows lowercase curve names */\n    for (i = 0; i < (int)(sizeof(curveName) - 1) && *sn; i++) {\n        curveName[i] = (char)XTOUPPER(*sn++);\n    }\n    curveName[i] = '\\0';\n    /* find based on name and return NID */\n    for (i = 0;\n#ifndef WOLFSSL_ECC_CURVE_STATIC\n         ecc_sets[i].size != 0 && ecc_sets[i].name != NULL;\n#else\n         ecc_sets[i].size != 0;\n#endif\n         i++) {\n        if (XSTRNCMP(curveName, ecc_sets[i].name, ECC_MAXNAME) == 0) {\n            eccEnum = ecc_sets[i].id;\n            /* Convert enum value in ecc_curve_id to OpenSSL NID */\n            return EccEnumToNID(eccEnum);\n        }\n    }\n    #endif\n\n    return NID_undef;\n}\n#endif\n\n/* Routine for calculating hashId */\nint CalcHashId(const byte* data, word32 len, byte* hash)\n{\n    int ret;\n\n#if defined(NO_SHA) && !defined(NO_SHA256)\n    ret = wc_Sha256Hash(data, len, hash);\n#elif !defined(NO_SHA)\n    ret = wc_ShaHash(data, len, hash);\n#else\n    ret = NOT_COMPILED_IN;\n    (void)data;\n    (void)len;\n    (void)hash;\n#endif\n\n    return ret;\n}\n\n/* process NAME, either issuer or subject\n * returns 0 on success and negative values on fail */\nint GetName(DecodedCert* cert, int nameType, int maxIdx)\n{\n    int    length;  /* length of all distinguished names */\n    int    dummy;\n    int    ret;\n    char*  full;\n    byte*  hash;\n    word32 idx, localIdx = 0;\n    byte   tag;\n#if (defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)) && \\\n            !defined(WOLFCRYPT_ONLY)\n    WOLFSSL_X509_NAME* dName;\n#endif /* OPENSSL_EXTRA */\n\n    WOLFSSL_MSG(\"Getting Cert Name\");\n\n    if (nameType == ISSUER) {\n        full = cert->issuer;\n        hash = cert->issuerHash;\n    }\n    else {\n        full = cert->subject;\n        hash = cert->subjectHash;\n    }\n\n    if (cert->srcIdx >= (word32)maxIdx) {\n        return BUFFER_E;\n    }\n\n    localIdx = cert->srcIdx;\n    if (GetASNTag(cert->source, &localIdx, &tag, maxIdx) < 0) {\n        return ASN_PARSE_E;\n    }\n\n    if (tag == ASN_OBJECT_ID) {\n        WOLFSSL_MSG(\"Trying optional prefix...\");\n\n        if (SkipObjectId(cert->source, &cert->srcIdx, maxIdx) < 0)\n            return ASN_PARSE_E;\n        WOLFSSL_MSG(\"Got optional prefix\");\n    }\n\n    /* For OCSP, RFC2560 section 4.1.1 states the issuer hash should be\n     * calculated over the entire DER encoding of the Name field, including\n     * the tag and length. */\n    idx = cert->srcIdx;\n    if (GetSequence(cert->source, &cert->srcIdx, &length, maxIdx) < 0)\n        return ASN_PARSE_E;\n\n    ret = CalcHashId(&cert->source[idx], length + cert->srcIdx - idx, hash);\n    if (ret != 0)\n        return ret;\n\n    length += cert->srcIdx;\n    idx = 0;\n\n#if defined(HAVE_PKCS7) || defined(WOLFSSL_CERT_EXT)\n    /* store pointer to raw issuer */\n    if (nameType == ISSUER) {\n        cert->issuerRaw = &cert->source[cert->srcIdx];\n        cert->issuerRawLen = length - cert->srcIdx;\n    }\n#endif\n#ifndef IGNORE_NAME_CONSTRAINTS\n    if (nameType == SUBJECT) {\n        cert->subjectRaw = &cert->source[cert->srcIdx];\n        cert->subjectRawLen = length - cert->srcIdx;\n    }\n#endif\n#if (defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)) && \\\n    !defined(WOLFCRYPT_ONLY)\n    dName = wolfSSL_X509_NAME_new();\n    if (dName == NULL) {\n        return MEMORY_E;\n    }\n#endif /* OPENSSL_EXTRA */\n\n    while (cert->srcIdx < (word32)length) {\n        byte        b       = 0;\n        byte        joint[3];\n        byte        tooBig  = FALSE;\n        int         oidSz;\n        const char* copy    = NULL;\n        int         copyLen = 0;\n        int         strLen  = 0;\n        byte        id      = 0;\n    #if (defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)) \\\n                && !defined(WOLFCRYPT_ONLY)\n         int        nid = NID_undef;\n         int        enc;\n    #endif /* OPENSSL_EXTRA */\n\n        if (GetSet(cert->source, &cert->srcIdx, &dummy, maxIdx) < 0) {\n            WOLFSSL_MSG(\"Cert name lacks set header, trying sequence\");\n        }\n\n        if (GetSequence(cert->source, &cert->srcIdx, &dummy, maxIdx) <= 0) {\n        #if (defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)) && \\\n            !defined(WOLFCRYPT_ONLY)\n            wolfSSL_X509_NAME_free(dName);\n        #endif /* OPENSSL_EXTRA */\n            return ASN_PARSE_E;\n        }\n\n        ret = GetASNObjectId(cert->source, &cert->srcIdx, &oidSz, maxIdx);\n        if (ret != 0) {\n        #if (defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)) && \\\n            !defined(WOLFCRYPT_ONLY)\n            wolfSSL_X509_NAME_free(dName);\n        #endif /* OPENSSL_EXTRA */\n            return ret;\n        }\n\n        /* make sure there is room for joint */\n        if ((cert->srcIdx + sizeof(joint)) > (word32)maxIdx) {\n        #if (defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)) && \\\n            !defined(WOLFCRYPT_ONLY)\n            wolfSSL_X509_NAME_free(dName);\n        #endif /* OPENSSL_EXTRA */\n            return ASN_PARSE_E;\n        }\n\n        XMEMCPY(joint, &cert->source[cert->srcIdx], sizeof(joint));\n\n        /* v1 name types */\n        if (joint[0] == 0x55 && joint[1] == 0x04) {\n            cert->srcIdx += 3;\n            id = joint[2];\n            if (GetHeader(cert->source, &b, &cert->srcIdx, &strLen,\n                          maxIdx, 1) < 0) {\n            #if (defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)) && \\\n            !defined(WOLFCRYPT_ONLY)\n                wolfSSL_X509_NAME_free(dName);\n            #endif /* OPENSSL_EXTRA */\n                return ASN_PARSE_E;\n            }\n\n            if (id == ASN_COMMON_NAME) {\n                if (nameType == SUBJECT) {\n                    cert->subjectCN = (char *)&cert->source[cert->srcIdx];\n                    cert->subjectCNLen = strLen;\n                    cert->subjectCNEnc = b;\n                }\n\n                copy = WOLFSSL_COMMON_NAME;\n                copyLen = sizeof(WOLFSSL_COMMON_NAME) - 1;\n            #if (defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)) \\\n                && !defined(WOLFCRYPT_ONLY)\n                nid = NID_commonName;\n            #endif /* OPENSSL_EXTRA */\n            }\n            else if (id == ASN_SUR_NAME) {\n                copy = WOLFSSL_SUR_NAME;\n                copyLen = sizeof(WOLFSSL_SUR_NAME) - 1;\n                #ifdef WOLFSSL_CERT_GEN\n                    if (nameType == SUBJECT) {\n                        cert->subjectSN = (char*)&cert->source[cert->srcIdx];\n                        cert->subjectSNLen = strLen;\n                        cert->subjectSNEnc = b;\n                    }\n                #endif /* WOLFSSL_CERT_GEN */\n                #if (defined(OPENSSL_EXTRA) || \\\n                        defined(OPENSSL_EXTRA_X509_SMALL)) \\\n                        && !defined(WOLFCRYPT_ONLY)\n                    nid = NID_surname;\n                #endif /* OPENSSL_EXTRA */\n            }\n            else if (id == ASN_COUNTRY_NAME) {\n                copy = WOLFSSL_COUNTRY_NAME;\n                copyLen = sizeof(WOLFSSL_COUNTRY_NAME) - 1;\n                #ifdef WOLFSSL_CERT_GEN\n                    if (nameType == SUBJECT) {\n                        cert->subjectC = (char*)&cert->source[cert->srcIdx];\n                        cert->subjectCLen = strLen;\n                        cert->subjectCEnc = b;\n                    }\n                #endif /* WOLFSSL_CERT_GEN */\n                #if (defined(OPENSSL_EXTRA) || \\\n                        defined(OPENSSL_EXTRA_X509_SMALL)) \\\n                        && !defined(WOLFCRYPT_ONLY)\n                    nid = NID_countryName;\n                #endif /* OPENSSL_EXTRA */\n            }\n            else if (id == ASN_LOCALITY_NAME) {\n                copy = WOLFSSL_LOCALITY_NAME;\n                copyLen = sizeof(WOLFSSL_LOCALITY_NAME) - 1;\n                #ifdef WOLFSSL_CERT_GEN\n                    if (nameType == SUBJECT) {\n                        cert->subjectL = (char*)&cert->source[cert->srcIdx];\n                        cert->subjectLLen = strLen;\n                        cert->subjectLEnc = b;\n                    }\n                #endif /* WOLFSSL_CERT_GEN */\n                #if (defined(OPENSSL_EXTRA) || \\\n                        defined(OPENSSL_EXTRA_X509_SMALL)) \\\n                        && !defined(WOLFCRYPT_ONLY)\n                    nid = NID_localityName;\n                #endif /* OPENSSL_EXTRA */\n            }\n            else if (id == ASN_STATE_NAME) {\n                copy = WOLFSSL_STATE_NAME;\n                copyLen = sizeof(WOLFSSL_STATE_NAME) - 1;\n                #ifdef WOLFSSL_CERT_GEN\n                    if (nameType == SUBJECT) {\n                        cert->subjectST = (char*)&cert->source[cert->srcIdx];\n                        cert->subjectSTLen = strLen;\n                        cert->subjectSTEnc = b;\n                    }\n                #endif /* WOLFSSL_CERT_GEN */\n                #if (defined(OPENSSL_EXTRA) || \\\n                        defined(OPENSSL_EXTRA_X509_SMALL)) \\\n                        && !defined(WOLFCRYPT_ONLY)\n                    nid = NID_stateOrProvinceName;\n                #endif /* OPENSSL_EXTRA */\n            }\n            else if (id == ASN_ORG_NAME) {\n                copy = WOLFSSL_ORG_NAME;\n                copyLen = sizeof(WOLFSSL_ORG_NAME) - 1;\n                #ifdef WOLFSSL_CERT_GEN\n                    if (nameType == SUBJECT) {\n                        cert->subjectO = (char*)&cert->source[cert->srcIdx];\n                        cert->subjectOLen = strLen;\n                        cert->subjectOEnc = b;\n                    }\n                #endif /* WOLFSSL_CERT_GEN */\n                #if (defined(OPENSSL_EXTRA) || \\\n                        defined(OPENSSL_EXTRA_X509_SMALL)) \\\n                        && !defined(WOLFCRYPT_ONLY)\n                    nid = NID_organizationName;\n                #endif /* OPENSSL_EXTRA */\n            }\n            else if (id == ASN_ORGUNIT_NAME) {\n                copy = WOLFSSL_ORGUNIT_NAME;\n                copyLen = sizeof(WOLFSSL_ORGUNIT_NAME) - 1;\n                #ifdef WOLFSSL_CERT_GEN\n                    if (nameType == SUBJECT) {\n                        cert->subjectOU = (char*)&cert->source[cert->srcIdx];\n                        cert->subjectOULen = strLen;\n                        cert->subjectOUEnc = b;\n                    }\n                #endif /* WOLFSSL_CERT_GEN */\n                #if (defined(OPENSSL_EXTRA) || \\\n                        defined(OPENSSL_EXTRA_X509_SMALL)) \\\n                        && !defined(WOLFCRYPT_ONLY)\n                    nid = NID_organizationalUnitName;\n                #endif /* OPENSSL_EXTRA */\n            }\n            else if (id == ASN_SERIAL_NUMBER) {\n                copy = WOLFSSL_SERIAL_NUMBER;\n                copyLen = sizeof(WOLFSSL_SERIAL_NUMBER) - 1;\n                #ifdef WOLFSSL_CERT_GEN\n                    if (nameType == SUBJECT) {\n                        cert->subjectSND = (char*)&cert->source[cert->srcIdx];\n                        cert->subjectSNDLen = strLen;\n                        cert->subjectSNDEnc = b;\n                    }\n                #endif /* WOLFSSL_CERT_GEN */\n                #if (defined(OPENSSL_EXTRA) || \\\n                        defined(OPENSSL_EXTRA_X509_SMALL)) \\\n                        && !defined(WOLFCRYPT_ONLY)\n                    nid = NID_serialNumber;\n                #endif /* OPENSSL_EXTRA */\n            }\n        #ifdef WOLFSSL_CERT_EXT\n            else if (id == ASN_BUS_CAT) {\n                copy = WOLFSSL_BUS_CAT;\n                copyLen = sizeof(WOLFSSL_BUS_CAT) - 1;\n            #ifdef WOLFSSL_CERT_GEN\n                if (nameType == SUBJECT) {\n                    cert->subjectBC = (char*)&cert->source[cert->srcIdx];\n                    cert->subjectBCLen = strLen;\n                    cert->subjectBCEnc = b;\n                }\n            #endif /* WOLFSSL_CERT_GEN */\n            #if (defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)) \\\n                        && !defined(WOLFCRYPT_ONLY)\n                nid = NID_businessCategory;\n            #endif /* OPENSSL_EXTRA */\n            }\n        #endif /* WOLFSSL_CERT_EXT */\n        }\n    #ifdef WOLFSSL_CERT_EXT\n        else if ((cert->srcIdx + ASN_JOI_PREFIX_SZ + 2 <= (word32)maxIdx) &&\n                 (0 == XMEMCMP(&cert->source[cert->srcIdx], ASN_JOI_PREFIX,\n                               ASN_JOI_PREFIX_SZ)) &&\n                 ((cert->source[cert->srcIdx+ASN_JOI_PREFIX_SZ] == ASN_JOI_C) ||\n                  (cert->source[cert->srcIdx+ASN_JOI_PREFIX_SZ] == ASN_JOI_ST)))\n        {\n            cert->srcIdx += ASN_JOI_PREFIX_SZ;\n            id = cert->source[cert->srcIdx++];\n            b = cert->source[cert->srcIdx++]; /* encoding */\n\n            if (GetLength(cert->source, &cert->srcIdx, &strLen,\n                          maxIdx) < 0) {\n            #if (defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)) && \\\n            !defined(WOLFCRYPT_ONLY)\n                wolfSSL_X509_NAME_free(dName);\n            #endif /* OPENSSL_EXTRA */\n                return ASN_PARSE_E;\n            }\n\n            /* Check for jurisdiction of incorporation country name */\n            if (id == ASN_JOI_C) {\n                copy = WOLFSSL_JOI_C;\n                copyLen = sizeof(WOLFSSL_JOI_C) - 1;\n                #ifdef WOLFSSL_CERT_GEN\n                    if (nameType == SUBJECT) {\n                        cert->subjectJC = (char*)&cert->source[cert->srcIdx];\n                        cert->subjectJCLen = strLen;\n                        cert->subjectJCEnc = b;\n                    }\n                #endif /* WOLFSSL_CERT_GEN */\n                #if (defined(OPENSSL_EXTRA) || \\\n                        defined(OPENSSL_EXTRA_X509_SMALL)) \\\n                        && !defined(WOLFCRYPT_ONLY)\n                    nid = NID_jurisdictionCountryName;\n                #endif /* OPENSSL_EXTRA */\n            }\n\n            /* Check for jurisdiction of incorporation state name */\n            else if (id == ASN_JOI_ST) {\n                copy = WOLFSSL_JOI_ST;\n                copyLen = sizeof(WOLFSSL_JOI_ST) - 1;\n                #ifdef WOLFSSL_CERT_GEN\n                    if (nameType == SUBJECT) {\n                        cert->subjectJS = (char*)&cert->source[cert->srcIdx];\n                        cert->subjectJSLen = strLen;\n                        cert->subjectJSEnc = b;\n                    }\n                #endif /* WOLFSSL_CERT_GEN */\n                #if (defined(OPENSSL_EXTRA) || \\\n                        defined(OPENSSL_EXTRA_X509_SMALL)) \\\n                        && !defined(WOLFCRYPT_ONLY)\n                    nid = NID_jurisdictionStateOrProvinceName;\n                #endif /* OPENSSL_EXTRA */\n            }\n\n            if ((strLen + copyLen) > (int)(ASN_NAME_MAX - idx)) {\n                WOLFSSL_MSG(\"ASN Name too big, skipping\");\n                tooBig = TRUE;\n            }\n        }\n    #endif /* WOLFSSL_CERT_EXT */\n        else {\n            /* skip */\n            byte email = FALSE;\n            byte pilot = FALSE;\n\n            if (joint[0] == 0x2a && joint[1] == 0x86) {  /* email id hdr */\n                id = ASN_EMAIL_NAME;\n                email = TRUE;\n            }\n\n            if (joint[0] == 0x9  && joint[1] == 0x92) { /* uid id hdr */\n                /* last value of OID is the type of pilot attribute */\n                id    = cert->source[cert->srcIdx + oidSz - 1];\n                pilot = TRUE;\n            }\n\n            cert->srcIdx += oidSz + 1;\n\n            if (GetLength(cert->source, &cert->srcIdx, &strLen, maxIdx) < 0) {\n            #if (defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)) && \\\n            !defined(WOLFCRYPT_ONLY)\n                wolfSSL_X509_NAME_free(dName);\n            #endif /* OPENSSL_EXTRA */\n                return ASN_PARSE_E;\n            }\n\n            if (strLen > (int)(ASN_NAME_MAX - idx)) {\n                WOLFSSL_MSG(\"ASN name too big, skipping\");\n                tooBig = TRUE;\n            }\n\n            if (email) {\n                copyLen = sizeof(WOLFSSL_EMAIL_ADDR) - 1;\n                if ((copyLen + strLen) > (int)(ASN_NAME_MAX - idx)) {\n                    WOLFSSL_MSG(\"ASN name too big, skipping\");\n                    tooBig = TRUE;\n                }\n                else {\n                    copy = WOLFSSL_EMAIL_ADDR;\n                }\n\n                #ifdef WOLFSSL_CERT_GEN\n                    if (nameType == SUBJECT) {\n                        cert->subjectEmail = (char*)&cert->source[cert->srcIdx];\n                        cert->subjectEmailLen = strLen;\n                    }\n                #endif /* WOLFSSL_CERT_GEN */\n                #if (defined(OPENSSL_EXTRA) || \\\n                        defined(OPENSSL_EXTRA_X509_SMALL)) \\\n                        && !defined(WOLFCRYPT_ONLY)\n                    nid = NID_emailAddress;\n                #endif /* OPENSSL_EXTRA */\n                #ifndef IGNORE_NAME_CONSTRAINTS\n                    {\n                        DNS_entry* emailName;\n\n                        emailName = (DNS_entry*)XMALLOC(sizeof(DNS_entry),\n                                              cert->heap, DYNAMIC_TYPE_ALTNAME);\n                        if (emailName == NULL) {\n                            WOLFSSL_MSG(\"\\tOut of Memory\");\n                        #if (defined(OPENSSL_EXTRA) || \\\n                                defined(OPENSSL_EXTRA_X509_SMALL)) && \\\n                                !defined(WOLFCRYPT_ONLY)\n                            wolfSSL_X509_NAME_free(dName);\n                        #endif /* OPENSSL_EXTRA */\n                            return MEMORY_E;\n                        }\n                        emailName->type = 0;\n                        emailName->name = (char*)XMALLOC(strLen + 1,\n                                              cert->heap, DYNAMIC_TYPE_ALTNAME);\n                        if (emailName->name == NULL) {\n                            WOLFSSL_MSG(\"\\tOut of Memory\");\n                            XFREE(emailName, cert->heap, DYNAMIC_TYPE_ALTNAME);\n                        #if (defined(OPENSSL_EXTRA) || \\\n                                defined(OPENSSL_EXTRA_X509_SMALL)) && \\\n                                !defined(WOLFCRYPT_ONLY)\n                            wolfSSL_X509_NAME_free(dName);\n                        #endif /* OPENSSL_EXTRA */\n                            return MEMORY_E;\n                        }\n                        emailName->len = strLen;\n                        XMEMCPY(emailName->name, &cert->source[cert->srcIdx],\n                                                                        strLen);\n                        emailName->name[strLen] = '\\0';\n\n                        emailName->next = cert->altEmailNames;\n                        cert->altEmailNames = emailName;\n                    }\n                #endif /* IGNORE_NAME_CONSTRAINTS */\n            }\n\n            if (pilot) {\n                switch (id) {\n                    case ASN_USER_ID:\n                        copy = WOLFSSL_USER_ID;\n                        copyLen = sizeof(WOLFSSL_USER_ID) - 1;\n                    #if (defined(OPENSSL_EXTRA) || \\\n                        defined(OPENSSL_EXTRA_X509_SMALL)) \\\n                        && !defined(WOLFCRYPT_ONLY)\n                        nid = NID_userId;\n                    #endif /* OPENSSL_EXTRA */\n                        break;\n\n                    case ASN_DOMAIN_COMPONENT:\n                        copy = WOLFSSL_DOMAIN_COMPONENT;\n                        copyLen = sizeof(WOLFSSL_DOMAIN_COMPONENT) - 1;\n                    #if (defined(OPENSSL_EXTRA) || \\\n                        defined(OPENSSL_EXTRA_X509_SMALL)) \\\n                        && !defined(WOLFCRYPT_ONLY)\n                        nid = NID_domainComponent;\n                    #endif /* OPENSSL_EXTRA */\n                        break;\n                    case ASN_FAVOURITE_DRINK:\n                        copy = WOLFSSL_FAVOURITE_DRINK;\n                        copyLen = sizeof(WOLFSSL_FAVOURITE_DRINK) - 1;\n                    #if (defined(OPENSSL_EXTRA) || \\\n                        defined(OPENSSL_EXTRA_X509_SMALL)) \\\n                        && !defined(WOLFCRYPT_ONLY)\n                        nid = NID_favouriteDrink;\n                    #endif /* OPENSSL_EXTRA */\n                        break;\n\n                    default:\n                        WOLFSSL_MSG(\"Unknown pilot attribute type\");\n                    #if (defined(OPENSSL_EXTRA) || \\\n                                defined(OPENSSL_EXTRA_X509_SMALL)) && \\\n                                !defined(WOLFCRYPT_ONLY)\n                        wolfSSL_X509_NAME_free(dName);\n                    #endif /* OPENSSL_EXTRA */\n                        return ASN_PARSE_E;\n                }\n            }\n        }\n        if ((copyLen + strLen) > (int)(ASN_NAME_MAX - idx))\n        {\n            WOLFSSL_MSG(\"ASN Name too big, skipping\");\n            tooBig = TRUE;\n        }\n        if ((copy != NULL) && !tooBig) {\n            XMEMCPY(&full[idx], copy, copyLen);\n            idx += copyLen;\n            XMEMCPY(&full[idx], &cert->source[cert->srcIdx], strLen);\n            idx += strLen;\n        }\n        #if (defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)) && \\\n            !defined(WOLFCRYPT_ONLY)\n        switch (b) {\n            case CTC_UTF8:\n                enc = MBSTRING_UTF8;\n                break;\n            case CTC_PRINTABLE:\n                enc = V_ASN1_PRINTABLESTRING;\n                break;\n            default:\n                WOLFSSL_MSG(\"Unknown encoding type, using UTF8 by default\");\n                enc = MBSTRING_UTF8;\n        }\n\n        if (nid != NID_undef) {\n            if (wolfSSL_X509_NAME_add_entry_by_NID(dName, nid, enc,\n                            &cert->source[cert->srcIdx], strLen, -1, -1) !=\n                            WOLFSSL_SUCCESS) {\n                wolfSSL_X509_NAME_free(dName);\n                return ASN_PARSE_E;\n            }\n        }\n        #endif /* OPENSSL_EXTRA */\n        cert->srcIdx += strLen;\n    }\n    full[idx++] = 0;\n\n\n#if (defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)) && \\\n            !defined(WOLFCRYPT_ONLY)\n    if (nameType == ISSUER) {\n        cert->issuerName = dName;\n    }\n    else {\n        cert->subjectName = dName;\n    }\n#endif\n    return 0;\n}\n\n\n#ifndef NO_ASN_TIME\n\n/* two byte date/time, add to value */\nstatic WC_INLINE int GetTime(int* value, const byte* date, int* idx)\n{\n    int i = *idx;\n\n    if (date[i] < 0x30 || date[i] > 0x39 || date[i+1] < 0x30 ||\n                                                             date[i+1] > 0x39) {\n        return ASN_PARSE_E;\n    }\n\n    *value += btoi(date[i++]) * 10;\n    *value += btoi(date[i++]);\n\n    *idx = i;\n\n    return 0;\n}\n\n#ifdef WOLFSSL_LINUXKM\nstatic WC_INLINE int GetTime_Long(long* value, const byte* date, int* idx)\n{\n    int i = *idx;\n\n    if (date[i] < 0x30 || date[i] > 0x39 || date[i+1] < 0x30 ||\n                                                             date[i+1] > 0x39) {\n        return ASN_PARSE_E;\n    }\n\n    *value += (long)btoi(date[i++]) * 10;\n    *value += (long)btoi(date[i++]);\n\n    *idx = i;\n\n    return 0;\n}\n#endif\n\nint ExtractDate(const unsigned char* date, unsigned char format,\n                                                  struct tm* certTime, int* idx)\n{\n    XMEMSET(certTime, 0, sizeof(struct tm));\n\n    if (format == ASN_UTC_TIME) {\n        if (btoi(date[*idx]) >= 5)\n            certTime->tm_year = 1900;\n        else\n            certTime->tm_year = 2000;\n    }\n    else  { /* format == GENERALIZED_TIME */\n#ifdef WOLFSSL_LINUXKM\n        if (GetTime_Long(&certTime->tm_year, date, idx) != 0) return 0;\n#else\n        if (GetTime(&certTime->tm_year, date, idx) != 0) return 0;\n#endif\n        certTime->tm_year *= 100;\n    }\n\n#ifdef AVR\n    /* Extract the time from the struct tm and adjust tm_year, tm_mon */\n    /* AVR libc stores these as uint8_t instead of int */\n    /* AVR time_t also offsets from midnight 1 Jan 2000 */\n    int tm_year = certTime->tm_year - 2000;\n    int tm_mon  = certTime->tm_mon - 1;\n    int tm_mday = certTime->tm_mday;\n    int tm_hour = certTime->tm_hour;\n    int tm_min  = certTime->tm_min;\n    int tm_sec  = certTime->tm_sec;\n\n#ifdef WOLFSSL_LINUXKM\n    if (GetTime_Long(&tm_year, date, idx) != 0) return 0;\n#else\n    if (GetTime(&tm_year, date, idx) != 0) return 0;\n#endif\n    if (GetTime(&tm_mon , date, idx) != 0) return 0;\n    if (GetTime(&tm_mday, date, idx) != 0) return 0;\n    if (GetTime(&tm_hour, date, idx) != 0) return 0;\n    if (GetTime(&tm_min , date, idx) != 0) return 0;\n    if (GetTime(&tm_sec , date, idx) != 0) return 0;\n\n    /* Re-populate certTime with computed values */\n    certTime->tm_year = tm_year;\n    certTime->tm_mon  = tm_mon;\n    certTime->tm_mday = tm_mday;\n    certTime->tm_hour = tm_hour;\n    certTime->tm_min  = tm_min;\n    certTime->tm_sec  = tm_sec;\n#else\n    /* adjust tm_year, tm_mon */\n#ifdef WOLFSSL_LINUXKM\n    if (GetTime_Long(&certTime->tm_year, date, idx) != 0) return 0;\n#else\n    if (GetTime(&certTime->tm_year, date, idx) != 0) return 0;\n#endif\n    certTime->tm_year -= 1900;\n    if (GetTime(&certTime->tm_mon , date, idx) != 0) return 0;\n    certTime->tm_mon  -= 1;\n    if (GetTime(&certTime->tm_mday, date, idx) != 0) return 0;\n    if (GetTime(&certTime->tm_hour, date, idx) != 0) return 0;\n    if (GetTime(&certTime->tm_min , date, idx) != 0) return 0;\n    if (GetTime(&certTime->tm_sec , date, idx) != 0) return 0;\n#endif\n\n    return 1;\n}\n\n\n#if defined(OPENSSL_ALL) || defined(WOLFSSL_MYSQL_COMPATIBLE) || \\\n    defined(OPENSSL_EXTRA) || defined(WOLFSSL_NGINX) || defined(WOLFSSL_HAPROXY)\nint GetTimeString(byte* date, int format, char* buf, int len)\n{\n    struct tm t;\n    int idx = 0;\n\n    if (!ExtractDate(date, (unsigned char)format, &t, &idx)) {\n        return 0;\n    }\n\n    if (date[idx] != 'Z') {\n        WOLFSSL_MSG(\"UTCtime, not Zulu\") ;\n        return 0;\n    }\n\n    /* place month in buffer */\n    buf[0] = '\\0';\n    switch(t.tm_mon) {\n        case 0:  XSTRNCAT(buf, \"Jan \", 5); break;\n        case 1:  XSTRNCAT(buf, \"Feb \", 5); break;\n        case 2:  XSTRNCAT(buf, \"Mar \", 5); break;\n        case 3:  XSTRNCAT(buf, \"Apr \", 5); break;\n        case 4:  XSTRNCAT(buf, \"May \", 5); break;\n        case 5:  XSTRNCAT(buf, \"Jun \", 5); break;\n        case 6:  XSTRNCAT(buf, \"Jul \", 5); break;\n        case 7:  XSTRNCAT(buf, \"Aug \", 5); break;\n        case 8:  XSTRNCAT(buf, \"Sep \", 5); break;\n        case 9:  XSTRNCAT(buf, \"Oct \", 5); break;\n        case 10: XSTRNCAT(buf, \"Nov \", 5); break;\n        case 11: XSTRNCAT(buf, \"Dec \", 5); break;\n        default:\n            return 0;\n\n    }\n    idx = 4; /* use idx now for char buffer */\n\n    XSNPRINTF(buf + idx, len - idx, \"%2d %02d:%02d:%02d %d GMT\",\n              t.tm_mday, t.tm_hour, t.tm_min, t.tm_sec, (int)t.tm_year + 1900);\n\n    return 1;\n}\n#endif /* OPENSSL_ALL || WOLFSSL_MYSQL_COMPATIBLE || WOLFSSL_NGINX || WOLFSSL_HAPROXY */\n\n\n#if !defined(NO_ASN_TIME) && defined(HAVE_PKCS7)\n\n/* Set current time string, either UTC or GeneralizedTime.\n * (void*) tm should be a pointer to time_t, output is placed in buf.\n *\n * Return time string length placed in buf on success, negative on error */\nint GetAsnTimeString(void* currTime, byte* buf, word32 len)\n{\n    struct tm* ts      = NULL;\n    struct tm* tmpTime = NULL;\n    byte* data_ptr  = buf;\n    word32 data_len = 0;\n    int year, mon, day, hour, mini, sec;\n#if defined(NEED_TMP_TIME)\n    struct tm tmpTimeStorage;\n    tmpTime = &tmpTimeStorage;\n#else\n    (void)tmpTime;\n#endif\n\n    WOLFSSL_ENTER(\"SetAsnTimeString\");\n\n    if (buf == NULL || len == 0)\n        return BAD_FUNC_ARG;\n\n    ts = (struct tm *)XGMTIME((time_t*)currTime, tmpTime);\n    if (ts == NULL){\n        WOLFSSL_MSG(\"failed to get time data.\");\n        return ASN_TIME_E;\n    }\n\n    /* Note ASN_UTC_TIME_SIZE and ASN_GENERALIZED_TIME_SIZE include space for\n     * the null terminator. ASN encoded values leave off the terminator. */\n\n    if (ts->tm_year >= 50 && ts->tm_year < 150) {\n        /* UTC Time */\n        char utc_str[ASN_UTC_TIME_SIZE];\n        data_len = ASN_UTC_TIME_SIZE - 1 + 2;\n\n        if (len < data_len)\n            return BUFFER_E;\n\n        if (ts->tm_year >= 50 && ts->tm_year < 100) {\n            year = ts->tm_year;\n        } else if (ts->tm_year >= 100 && ts->tm_year < 150) {\n            year = ts->tm_year - 100;\n        }\n        else {\n            WOLFSSL_MSG(\"unsupported year range\");\n            return BAD_FUNC_ARG;\n        }\n        mon  = ts->tm_mon + 1;\n        day  = ts->tm_mday;\n        hour = ts->tm_hour;\n        mini = ts->tm_min;\n        sec  = ts->tm_sec;\n        XSNPRINTF((char *)utc_str, ASN_UTC_TIME_SIZE,\n                  \"%02d%02d%02d%02d%02d%02dZ\", year, mon, day, hour, mini, sec);\n        *data_ptr = (byte) ASN_UTC_TIME; data_ptr++;\n        /* -1 below excludes null terminator */\n        *data_ptr = (byte) ASN_UTC_TIME_SIZE - 1; data_ptr++;\n        XMEMCPY(data_ptr,(byte *)utc_str, ASN_UTC_TIME_SIZE - 1);\n\n    } else {\n        /* GeneralizedTime */\n        char gt_str[ASN_GENERALIZED_TIME_SIZE];\n        data_len = ASN_GENERALIZED_TIME_SIZE - 1 + 2;\n\n        if (len < data_len)\n            return BUFFER_E;\n\n        year = ts->tm_year + 1900;\n        mon  = ts->tm_mon + 1;\n        day  = ts->tm_mday;\n        hour = ts->tm_hour;\n        mini = ts->tm_min;\n        sec  = ts->tm_sec;\n        XSNPRINTF((char *)gt_str, ASN_GENERALIZED_TIME_SIZE,\n                  \"%4d%02d%02d%02d%02d%02dZ\", year, mon, day, hour, mini, sec);\n        *data_ptr = (byte) ASN_GENERALIZED_TIME; data_ptr++;\n        /* -1 below excludes null terminator */\n        *data_ptr = (byte) ASN_GENERALIZED_TIME_SIZE - 1; data_ptr++;\n        XMEMCPY(data_ptr,(byte *)gt_str, ASN_GENERALIZED_TIME_SIZE - 1);\n    }\n\n    return data_len;\n}\n\n#endif /* !NO_ASN_TIME && HAVE_PKCS7 */\n\n\n#if defined(USE_WOLF_VALIDDATE)\n\n/* to the second */\nint DateGreaterThan(const struct tm* a, const struct tm* b)\n{\n    if (a->tm_year > b->tm_year)\n        return 1;\n\n    if (a->tm_year == b->tm_year && a->tm_mon > b->tm_mon)\n        return 1;\n\n    if (a->tm_year == b->tm_year && a->tm_mon == b->tm_mon &&\n           a->tm_mday > b->tm_mday)\n        return 1;\n\n    if (a->tm_year == b->tm_year && a->tm_mon == b->tm_mon &&\n        a->tm_mday == b->tm_mday && a->tm_hour > b->tm_hour)\n        return 1;\n\n    if (a->tm_year == b->tm_year && a->tm_mon == b->tm_mon &&\n        a->tm_mday == b->tm_mday && a->tm_hour == b->tm_hour &&\n        a->tm_min > b->tm_min)\n        return 1;\n\n    if (a->tm_year == b->tm_year && a->tm_mon == b->tm_mon &&\n        a->tm_mday == b->tm_mday && a->tm_hour == b->tm_hour &&\n        a->tm_min  == b->tm_min  && a->tm_sec > b->tm_sec)\n        return 1;\n\n    return 0; /* false */\n}\n\n\nstatic WC_INLINE int DateLessThan(const struct tm* a, const struct tm* b)\n{\n    return DateGreaterThan(b,a);\n}\n\n/* like atoi but only use first byte */\n/* Make sure before and after dates are valid */\nint wc_ValidateDate(const byte* date, byte format, int dateType)\n{\n    time_t ltime;\n    struct tm  certTime;\n    struct tm* localTime;\n    struct tm* tmpTime;\n    int    i = 0;\n    int    timeDiff = 0 ;\n    int    diffHH = 0 ; int diffMM = 0 ;\n    int    diffSign = 0 ;\n\n#if defined(NEED_TMP_TIME)\n    struct tm tmpTimeStorage;\n    tmpTime = &tmpTimeStorage;\n#else\n    tmpTime = NULL;\n#endif\n    (void)tmpTime;\n\n    ltime = XTIME(0);\n\n#ifdef WOLFSSL_BEFORE_DATE_CLOCK_SKEW\n    if (dateType == BEFORE) {\n        WOLFSSL_MSG(\"Skewing local time for before date check\");\n        ltime += WOLFSSL_BEFORE_DATE_CLOCK_SKEW;\n    }\n#endif\n\n#ifdef WOLFSSL_AFTER_DATE_CLOCK_SKEW\n    if (dateType == AFTER) {\n        WOLFSSL_MSG(\"Skewing local time for after date check\");\n        ltime -= WOLFSSL_AFTER_DATE_CLOCK_SKEW;\n    }\n#endif\n\n    if (!ExtractDate(date, format, &certTime, &i)) {\n        WOLFSSL_MSG(\"Error extracting the date\");\n        return 0;\n    }\n\n    if ((date[i] == '+') || (date[i] == '-')) {\n        WOLFSSL_MSG(\"Using time differential, not Zulu\") ;\n        diffSign = date[i++] == '+' ? 1 : -1 ;\n        if (GetTime(&diffHH, date, &i) != 0)\n            return 0;\n        if (GetTime(&diffMM, date, &i) != 0)\n            return 0;\n        timeDiff = diffSign * (diffHH*60 + diffMM) * 60 ;\n    } else if (date[i] != 'Z') {\n        WOLFSSL_MSG(\"UTCtime, neither Zulu or time differential\") ;\n        return 0;\n    }\n\n    ltime -= (time_t)timeDiff ;\n    localTime = XGMTIME(&ltime, tmpTime);\n\n    if (localTime == NULL) {\n        WOLFSSL_MSG(\"XGMTIME failed\");\n        return 0;\n    }\n\n    if (dateType == BEFORE) {\n        if (DateLessThan(localTime, &certTime)) {\n            WOLFSSL_MSG(\"Date BEFORE check failed\");\n            return 0;\n        }\n    }\n    else {  /* dateType == AFTER */\n        if (DateGreaterThan(localTime, &certTime)) {\n            WOLFSSL_MSG(\"Date AFTER check failed\");\n            return 0;\n        }\n    }\n\n    return 1;\n}\n#endif /* USE_WOLF_VALIDDATE */\n\nint wc_GetTime(void* timePtr, word32 timeSize)\n{\n    time_t* ltime = (time_t*)timePtr;\n\n    if (timePtr == NULL) {\n        return BAD_FUNC_ARG;\n    }\n\n    if ((word32)sizeof(time_t) > timeSize) {\n        return BUFFER_E;\n    }\n\n    *ltime = XTIME(0);\n\n    return 0;\n}\n\n#endif /* !NO_ASN_TIME */\n\n\n/* Get date buffer, format and length. Returns 0=success or error */\nstatic int GetDateInfo(const byte* source, word32* idx, const byte** pDate,\n                        byte* pFormat, int* pLength, word32 maxIdx)\n{\n    int length;\n    byte format;\n\n    if (source == NULL || idx == NULL)\n        return BAD_FUNC_ARG;\n\n    /* get ASN format header */\n    if (*idx+1 > maxIdx)\n        return BUFFER_E;\n    format = source[*idx];\n    *idx += 1;\n    if (format != ASN_UTC_TIME && format != ASN_GENERALIZED_TIME)\n        return ASN_TIME_E;\n\n    /* get length */\n    if (GetLength(source, idx, &length, maxIdx) < 0)\n        return ASN_PARSE_E;\n    if (length > MAX_DATE_SIZE || length < MIN_DATE_SIZE)\n        return ASN_DATE_SZ_E;\n\n    /* return format, date and length */\n    if (pFormat)\n        *pFormat = format;\n    if (pDate)\n        *pDate = &source[*idx];\n    if (pLength)\n        *pLength = length;\n\n    *idx += length;\n\n    return 0;\n}\n\nstatic int GetDate(DecodedCert* cert, int dateType, int verify, int maxIdx)\n{\n    int    ret, length;\n    const byte *datePtr = NULL;\n    byte   date[MAX_DATE_SIZE];\n    byte   format;\n    word32 startIdx = 0;\n\n    if (dateType == BEFORE)\n        cert->beforeDate = &cert->source[cert->srcIdx];\n    else\n        cert->afterDate = &cert->source[cert->srcIdx];\n    startIdx = cert->srcIdx;\n\n    ret = GetDateInfo(cert->source, &cert->srcIdx, &datePtr, &format,\n                      &length, maxIdx);\n    if (ret < 0)\n        return ret;\n\n    XMEMSET(date, 0, MAX_DATE_SIZE);\n    XMEMCPY(date, datePtr, length);\n\n    if (dateType == BEFORE)\n        cert->beforeDateLen = cert->srcIdx - startIdx;\n    else\n        cert->afterDateLen  = cert->srcIdx - startIdx;\n\n#ifndef NO_ASN_TIME\n    if (verify != NO_VERIFY && verify != VERIFY_SKIP_DATE &&\n            !XVALIDATE_DATE(date, format, dateType)) {\n        if (dateType == BEFORE)\n            return ASN_BEFORE_DATE_E;\n        else\n            return ASN_AFTER_DATE_E;\n    }\n#else\n    (void)verify;\n#endif\n\n    return 0;\n}\n\nstatic int GetValidity(DecodedCert* cert, int verify, int maxIdx)\n{\n    int length;\n    int badDate = 0;\n\n    if (GetSequence(cert->source, &cert->srcIdx, &length, maxIdx) < 0)\n        return ASN_PARSE_E;\n\n    maxIdx = cert->srcIdx + length;\n\n    if (GetDate(cert, BEFORE, verify, maxIdx) < 0)\n        badDate = ASN_BEFORE_DATE_E; /* continue parsing */\n\n    if (GetDate(cert, AFTER, verify, maxIdx) < 0)\n        return ASN_AFTER_DATE_E;\n\n    if (badDate != 0)\n        return badDate;\n\n    return 0;\n}\n\n\nint wc_GetDateInfo(const byte* certDate, int certDateSz, const byte** date,\n    byte* format, int* length)\n{\n    int ret;\n    word32 idx = 0;\n\n    ret = GetDateInfo(certDate, &idx, date, format, length, certDateSz);\n    if (ret < 0)\n        return ret;\n\n    return 0;\n}\n\n#ifndef NO_ASN_TIME\nint wc_GetDateAsCalendarTime(const byte* date, int length, byte format,\n    struct tm* timearg)\n{\n    int idx = 0;\n    (void)length;\n    if (!ExtractDate(date, format, timearg, &idx))\n        return ASN_TIME_E;\n    return 0;\n}\n\n#if defined(WOLFSSL_CERT_GEN) && defined(WOLFSSL_ALT_NAMES)\nint wc_GetCertDates(Cert* cert, struct tm* before, struct tm* after)\n{\n    int ret = 0;\n    const byte* date;\n    byte format;\n    int length;\n\n    if (cert == NULL)\n        return BAD_FUNC_ARG;\n\n    if (before && cert->beforeDateSz > 0) {\n        ret = wc_GetDateInfo(cert->beforeDate, cert->beforeDateSz, &date,\n                             &format, &length);\n        if (ret == 0)\n            ret = wc_GetDateAsCalendarTime(date, length, format, before);\n    }\n    if (after && cert->afterDateSz > 0) {\n        ret = wc_GetDateInfo(cert->afterDate, cert->afterDateSz, &date,\n                             &format, &length);\n        if (ret == 0)\n            ret = wc_GetDateAsCalendarTime(date, length, format, after);\n    }\n\n    return ret;\n}\n#endif /* WOLFSSL_CERT_GEN && WOLFSSL_ALT_NAMES */\n#endif /* !NO_ASN_TIME */\n\n/* parses certificate up to point of X.509 public key\n *\n * if cert date is invalid then badDate gets set to error value, otherwise is 0\n *\n * returns a negative value on fail case\n */\nint wc_GetPubX509(DecodedCert* cert, int verify, int* badDate)\n{\n    int ret;\n\n    if (cert == NULL || badDate == NULL)\n        return BAD_FUNC_ARG;\n\n    *badDate = 0;\n    if ( (ret = GetCertHeader(cert)) < 0)\n        return ret;\n\n    WOLFSSL_MSG(\"Got Cert Header\");\n\n#ifdef WOLFSSL_CERT_REQ\n    if (!cert->isCSR) {\n#endif\n        /* Using the sigIndex as the upper bound because that's where the\n         * actual certificate data ends. */\n        if ( (ret = GetAlgoId(cert->source, &cert->srcIdx, &cert->signatureOID,\n                              oidSigType, cert->sigIndex)) < 0)\n            return ret;\n\n        WOLFSSL_MSG(\"Got Algo ID\");\n\n        if ( (ret = GetName(cert, ISSUER, cert->sigIndex)) < 0)\n            return ret;\n\n        if ( (ret = GetValidity(cert, verify, cert->sigIndex)) < 0)\n            *badDate = ret;\n#ifdef WOLFSSL_CERT_REQ\n    }\n#endif\n\n    if ( (ret = GetName(cert, SUBJECT, cert->sigIndex)) < 0)\n        return ret;\n\n    WOLFSSL_MSG(\"Got Subject Name\");\n    return ret;\n}\n\nint DecodeToKey(DecodedCert* cert, int verify)\n{\n    int badDate = 0;\n    int ret;\n\n    if ( (ret = wc_GetPubX509(cert, verify, &badDate)) < 0)\n        return ret;\n\n    /* Determine if self signed */\n    cert->selfSigned = XMEMCMP(cert->issuerHash,\n                               cert->subjectHash,\n                               KEYID_SIZE) == 0 ? 1 : 0;\n\n    if ( (ret = GetKey(cert)) < 0)\n        return ret;\n\n    WOLFSSL_MSG(\"Got Key\");\n\n    if (badDate != 0)\n        return badDate;\n\n    return ret;\n}\n\n#ifndef NO_CERTS\nstatic int GetSignature(DecodedCert* cert)\n{\n    int length;\n    int ret;\n\n    ret = CheckBitString(cert->source, &cert->srcIdx, &length, cert->maxIdx, 1,\n                         NULL);\n    if (ret != 0)\n        return ret;\n\n    cert->sigLength = length;\n    cert->signature = &cert->source[cert->srcIdx];\n    cert->srcIdx += cert->sigLength;\n\n    if (cert->srcIdx != cert->maxIdx)\n        return ASN_PARSE_E;\n\n    return 0;\n}\n#endif\n\nstatic word32 SetOctetString8Bit(word32 len, byte* output)\n{\n    output[0] = ASN_OCTET_STRING;\n    output[1] = (byte)len;\n    return 2;\n}\n\nstatic word32 SetDigest(const byte* digest, word32 digSz, byte* output)\n{\n    word32 idx = SetOctetString8Bit(digSz, output);\n    XMEMCPY(&output[idx], digest, digSz);\n\n    return idx + digSz;\n}\n\n\nstatic word32 BytePrecision(word32 value)\n{\n    word32 i;\n    for (i = (word32)sizeof(value); i; --i)\n        if (value >> ((i - 1) * WOLFSSL_BIT_SIZE))\n            break;\n\n    return i;\n}\n\n\nword32 SetLength(word32 length, byte* output)\n{\n    word32 i = 0, j;\n\n    if (length < ASN_LONG_LENGTH) {\n        if (output)\n            output[i] = (byte)length;\n        i++;\n    }\n    else {\n        if (output)\n            output[i] = (byte)(BytePrecision(length) | ASN_LONG_LENGTH);\n        i++;\n\n        for (j = BytePrecision(length); j; --j) {\n            if (output)\n                output[i] = (byte)(length >> ((j - 1) * WOLFSSL_BIT_SIZE));\n            i++;\n        }\n    }\n\n    return i;\n}\n\nword32 SetSequence(word32 len, byte* output)\n{\n    if (output)\n        output[0] = ASN_SEQUENCE | ASN_CONSTRUCTED;\n    return SetLength(len, output ? output + 1 : NULL) + 1;\n}\n\nword32 SetOctetString(word32 len, byte* output)\n{\n    output[0] = ASN_OCTET_STRING;\n    return SetLength(len, output + 1) + 1;\n}\n\n/* Write a set header to output */\nword32 SetSet(word32 len, byte* output)\n{\n    output[0] = ASN_SET | ASN_CONSTRUCTED;\n    return SetLength(len, output + 1) + 1;\n}\n\nword32 SetImplicit(byte tag, byte number, word32 len, byte* output)\n{\n\n    output[0] = ((tag == ASN_SEQUENCE || tag == ASN_SET) ? ASN_CONSTRUCTED : 0)\n                    | ASN_CONTEXT_SPECIFIC | number;\n    return SetLength(len, output + 1) + 1;\n}\n\nword32 SetExplicit(byte number, word32 len, byte* output)\n{\n    output[0] = ASN_CONSTRUCTED | ASN_CONTEXT_SPECIFIC | number;\n    return SetLength(len, output + 1) + 1;\n}\n\n\n#if defined(HAVE_ECC) && defined(HAVE_ECC_KEY_EXPORT)\n\nstatic int SetCurve(ecc_key* key, byte* output)\n{\n#ifdef HAVE_OID_ENCODING\n    int ret;\n#endif\n    int idx = 0;\n    word32 oidSz = 0;\n\n    /* validate key */\n    if (key == NULL || key->dp == NULL) {\n        return BAD_FUNC_ARG;\n    }\n\n#ifdef HAVE_OID_ENCODING\n    ret = EncodeObjectId(key->dp->oid, key->dp->oidSz, NULL, &oidSz);\n    if (ret != 0) {\n        return ret;\n    }\n#else\n    oidSz = key->dp->oidSz;\n#endif\n\n    idx += SetObjectId(oidSz, output);\n\n#ifdef HAVE_OID_ENCODING\n    ret = EncodeObjectId(key->dp->oid, key->dp->oidSz, output+idx, &oidSz);\n    if (ret != 0) {\n        return ret;\n    }\n#else\n    XMEMCPY(output+idx, key->dp->oid, oidSz);\n#endif\n    idx += oidSz;\n\n    return idx;\n}\n\n#endif /* HAVE_ECC && HAVE_ECC_KEY_EXPORT */\n\n\n#ifdef HAVE_ECC\nstatic WC_INLINE int IsSigAlgoECDSA(int algoOID)\n{\n    /* ECDSA sigAlgo must not have ASN1 NULL parameters */\n    if (algoOID == CTC_SHAwECDSA || algoOID == CTC_SHA256wECDSA ||\n        algoOID == CTC_SHA384wECDSA || algoOID == CTC_SHA512wECDSA) {\n        return 1;\n    }\n\n    return 0;\n}\n#endif\n\nword32 SetAlgoID(int algoOID, byte* output, int type, int curveSz)\n{\n    word32 tagSz, idSz, seqSz, algoSz = 0;\n    const  byte* algoName = 0;\n    byte   ID_Length[1 + MAX_LENGTH_SZ];\n    byte   seqArray[MAX_SEQ_SZ + 1];  /* add object_id to end */\n    int    length = 0;\n\n    tagSz = (type == oidHashType ||\n             (type == oidSigType\n        #ifdef HAVE_ECC\n              && !IsSigAlgoECDSA(algoOID)\n        #endif\n        #ifdef HAVE_ED25519\n              && algoOID != ED25519k\n        #endif\n        #ifdef HAVE_ED448\n              && algoOID != ED448k\n        #endif\n              ) ||\n             (type == oidKeyType && algoOID == RSAk)) ? 2 : 0;\n\n    algoName = OidFromId(algoOID, type, &algoSz);\n\n    if (algoName == NULL) {\n        WOLFSSL_MSG(\"Unknown Algorithm\");\n        return 0;\n    }\n\n    idSz  = SetObjectId(algoSz, ID_Length);\n    seqSz = SetSequence(idSz + algoSz + tagSz + curveSz, seqArray);\n\n    /* Copy only algo to output for DSA keys */\n    if (algoOID == DSAk && output) {\n        XMEMCPY(output, ID_Length, idSz);\n        XMEMCPY(output + idSz, algoName, algoSz);\n        if (tagSz == 2)\n            SetASNNull(&output[seqSz + idSz + algoSz]);\n    }\n    else if (output) {\n        XMEMCPY(output, seqArray, seqSz);\n        XMEMCPY(output + seqSz, ID_Length, idSz);\n        XMEMCPY(output + seqSz + idSz, algoName, algoSz);\n        if (tagSz == 2)\n            SetASNNull(&output[seqSz + idSz + algoSz]);\n    }\n\n    if (algoOID == DSAk)\n        length = idSz + algoSz + tagSz;\n    else\n        length = seqSz + idSz + algoSz + tagSz;\n\n    return length;\n}\n\n\nword32 wc_EncodeSignature(byte* out, const byte* digest, word32 digSz,\n                          int hashOID)\n{\n    byte digArray[MAX_ENCODED_DIG_SZ];\n    byte algoArray[MAX_ALGO_SZ];\n    byte seqArray[MAX_SEQ_SZ];\n    word32 encDigSz, algoSz, seqSz;\n\n    encDigSz = SetDigest(digest, digSz, digArray);\n    algoSz   = SetAlgoID(hashOID, algoArray, oidHashType, 0);\n    seqSz    = SetSequence(encDigSz + algoSz, seqArray);\n\n    XMEMCPY(out, seqArray, seqSz);\n    XMEMCPY(out + seqSz, algoArray, algoSz);\n    XMEMCPY(out + seqSz + algoSz, digArray, encDigSz);\n\n    return encDigSz + algoSz + seqSz;\n}\n\n\n#ifndef NO_CERTS\n\nint wc_GetCTC_HashOID(int type)\n{\n    int ret;\n    enum wc_HashType hType;\n\n    hType = wc_HashTypeConvert(type);\n    ret = wc_HashGetOID(hType);\n    if (ret < 0)\n        ret = 0; /* backwards compatibility */\n\n    return ret;\n}\n\nvoid InitSignatureCtx(SignatureCtx* sigCtx, void* heap, int devId)\n{\n    if (sigCtx) {\n        XMEMSET(sigCtx, 0, sizeof(SignatureCtx));\n        sigCtx->devId = devId;\n        sigCtx->heap = heap;\n    }\n}\n\nvoid FreeSignatureCtx(SignatureCtx* sigCtx)\n{\n    if (sigCtx == NULL)\n        return;\n\n    if (sigCtx->digest) {\n        XFREE(sigCtx->digest, sigCtx->heap, DYNAMIC_TYPE_DIGEST);\n        sigCtx->digest = NULL;\n    }\n#if !(defined(NO_RSA) && defined(NO_DSA))\n    if (sigCtx->sigCpy) {\n        XFREE(sigCtx->sigCpy, sigCtx->heap, DYNAMIC_TYPE_SIGNATURE);\n        sigCtx->sigCpy = NULL;\n    }\n#endif\n#ifndef NO_ASN_CRYPT\n    if (sigCtx->key.ptr) {\n        switch (sigCtx->keyOID) {\n        #ifndef NO_RSA\n            case RSAk:\n                wc_FreeRsaKey(sigCtx->key.rsa);\n                XFREE(sigCtx->key.ptr, sigCtx->heap, DYNAMIC_TYPE_RSA);\n                break;\n        #endif /* !NO_RSA */\n        #ifndef NO_DSA\n            case DSAk:\n                wc_FreeDsaKey(sigCtx->key.dsa);\n                XFREE(sigCtx->key.dsa, sigCtx->heap, DYNAMIC_TYPE_DSA);\n                break;\n        #endif\n        #ifdef HAVE_ECC\n            case ECDSAk:\n                wc_ecc_free(sigCtx->key.ecc);\n                XFREE(sigCtx->key.ecc, sigCtx->heap, DYNAMIC_TYPE_ECC);\n                break;\n        #endif /* HAVE_ECC */\n        #ifdef HAVE_ED25519\n            case ED25519k:\n                wc_ed25519_free(sigCtx->key.ed25519);\n                XFREE(sigCtx->key.ed25519, sigCtx->heap, DYNAMIC_TYPE_ED25519);\n                break;\n        #endif /* HAVE_ED25519 */\n        #ifdef HAVE_ED448\n            case ED448k:\n                wc_ed448_free(sigCtx->key.ed448);\n                XFREE(sigCtx->key.ed448, sigCtx->heap, DYNAMIC_TYPE_ED448);\n                break;\n        #endif /* HAVE_ED448 */\n            default:\n                break;\n        } /* switch (keyOID) */\n        sigCtx->key.ptr = NULL;\n    }\n#endif\n\n    /* reset state, we are done */\n    sigCtx->state = SIG_STATE_BEGIN;\n}\n\n#ifndef NO_ASN_CRYPT\nstatic int HashForSignature(const byte* buf, word32 bufSz, word32 sigOID,\n                            byte* digest, int* typeH, int* digestSz, int verify)\n{\n    int ret = 0;\n\n    switch (sigOID) {\n    #if defined(WOLFSSL_MD2)\n        case CTC_MD2wRSA:\n            if (!verify) {\n                ret = HASH_TYPE_E;\n                WOLFSSL_MSG(\"MD2 not supported for signing\");\n            }\n            else if ((ret = wc_Md2Hash(buf, bufSz, digest)) == 0) {\n                *typeH    = MD2h;\n                *digestSz = MD2_DIGEST_SIZE;\n            }\n        break;\n    #endif\n    #ifndef NO_MD5\n        case CTC_MD5wRSA:\n            if ((ret = wc_Md5Hash(buf, bufSz, digest)) == 0) {\n                *typeH    = MD5h;\n                *digestSz = WC_MD5_DIGEST_SIZE;\n            }\n            break;\n    #endif\n    #ifndef NO_SHA\n        case CTC_SHAwRSA:\n        case CTC_SHAwDSA:\n        case CTC_SHAwECDSA:\n            if ((ret = wc_ShaHash(buf, bufSz, digest)) == 0) {\n                *typeH    = SHAh;\n                *digestSz = WC_SHA_DIGEST_SIZE;\n            }\n            break;\n    #endif\n    #ifdef WOLFSSL_SHA224\n        case CTC_SHA224wRSA:\n        case CTC_SHA224wECDSA:\n            if ((ret = wc_Sha224Hash(buf, bufSz, digest)) == 0) {\n                *typeH    = SHA224h;\n                *digestSz = WC_SHA224_DIGEST_SIZE;\n            }\n            break;\n    #endif\n    #ifndef NO_SHA256\n        case CTC_SHA256wRSA:\n        case CTC_SHA256wECDSA:\n        case CTC_SHA256wDSA:\n            if ((ret = wc_Sha256Hash(buf, bufSz, digest)) == 0) {\n                *typeH    = SHA256h;\n                *digestSz = WC_SHA256_DIGEST_SIZE;\n            }\n            break;\n    #endif\n    #ifdef WOLFSSL_SHA384\n        case CTC_SHA384wRSA:\n        case CTC_SHA384wECDSA:\n            if ((ret = wc_Sha384Hash(buf, bufSz, digest)) == 0) {\n                *typeH    = SHA384h;\n                *digestSz = WC_SHA384_DIGEST_SIZE;\n            }\n            break;\n    #endif\n    #ifdef WOLFSSL_SHA512\n        case CTC_SHA512wRSA:\n        case CTC_SHA512wECDSA:\n            if ((ret = wc_Sha512Hash(buf, bufSz, digest)) == 0) {\n                *typeH    = SHA512h;\n                *digestSz = WC_SHA512_DIGEST_SIZE;\n            }\n            break;\n    #endif\n    #ifdef WOLFSSL_SHA3\n    #ifndef WOLFSSL_NOSHA3_224\n        case CTC_SHA3_224wRSA:\n        case CTC_SHA3_224wECDSA:\n            if ((ret = wc_Sha3_224Hash(buf, bufSz, digest)) == 0) {\n                *typeH    = SHA3_224h;\n                *digestSz = WC_SHA3_224_DIGEST_SIZE;\n            }\n            break;\n    #endif\n    #ifndef WOLFSSL_NOSHA3_256\n        case CTC_SHA3_256wRSA:\n        case CTC_SHA3_256wECDSA:\n            if ((ret = wc_Sha3_256Hash(buf, bufSz, digest)) == 0) {\n                *typeH    = SHA3_256h;\n                *digestSz = WC_SHA3_256_DIGEST_SIZE;\n            }\n            break;\n    #endif\n    #ifndef WOLFSSL_NOSHA3_384\n        case CTC_SHA3_384wRSA:\n        case CTC_SHA3_384wECDSA:\n            if ((ret = wc_Sha3_384Hash(buf, bufSz, digest)) == 0) {\n                *typeH    = SHA3_384h;\n                *digestSz = WC_SHA3_384_DIGEST_SIZE;\n            }\n            break;\n    #endif\n    #ifndef WOLFSSL_NOSHA3_512\n        case CTC_SHA3_512wRSA:\n        case CTC_SHA3_512wECDSA:\n            if ((ret = wc_Sha3_512Hash(buf, bufSz, digest)) == 0) {\n                *typeH    = SHA3_512h;\n                *digestSz = WC_SHA3_512_DIGEST_SIZE;\n            }\n            break;\n    #endif\n    #endif\n    #ifdef HAVE_ED25519\n        case CTC_ED25519:\n            /* Hashes done in signing operation.\n             * Two dependent hashes with prefixes performed.\n             */\n            break;\n    #endif\n    #ifdef HAVE_ED448\n        case CTC_ED448:\n            /* Hashes done in signing operation.\n             * Two dependent hashes with prefixes performed.\n             */\n            break;\n    #endif\n        default:\n            ret = HASH_TYPE_E;\n            WOLFSSL_MSG(\"Hash for Signature has unsupported type\");\n    }\n\n    (void)buf;\n    (void)bufSz;\n    (void)sigOID;\n    (void)digest;\n    (void)digestSz;\n    (void)typeH;\n    (void)verify;\n\n    return ret;\n}\n#endif /* !NO_ASN_CRYPT */\n\n/* Return codes: 0=Success, Negative (see error-crypt.h), ASN_SIG_CONFIRM_E */\nstatic int ConfirmSignature(SignatureCtx* sigCtx,\n    const byte* buf, word32 bufSz,\n    const byte* key, word32 keySz, word32 keyOID,\n    const byte* sig, word32 sigSz, word32 sigOID, byte* rsaKeyIdx)\n{\n    int ret = 0;\n#ifndef WOLFSSL_RENESAS_TSIP_TLS\n    (void)rsaKeyIdx;\n#endif\n    if (sigCtx == NULL || buf == NULL || bufSz == 0 || key == NULL ||\n        keySz == 0 || sig == NULL || sigSz == 0) {\n        return BAD_FUNC_ARG;\n    }\n\n    (void)key;\n    (void)keySz;\n    (void)sig;\n    (void)sigSz;\n\n    WOLFSSL_ENTER(\"ConfirmSignature\");\n\n#ifndef NO_ASN_CRYPT\n    switch (sigCtx->state) {\n        case SIG_STATE_BEGIN:\n        {\n            sigCtx->keyOID = keyOID; /* must set early for cleanup */\n\n            sigCtx->digest = (byte*)XMALLOC(WC_MAX_DIGEST_SIZE, sigCtx->heap,\n                                                    DYNAMIC_TYPE_DIGEST);\n            if (sigCtx->digest == NULL) {\n                ERROR_OUT(MEMORY_E, exit_cs);\n            }\n\n            sigCtx->state = SIG_STATE_HASH;\n        } /* SIG_STATE_BEGIN */\n        FALL_THROUGH;\n\n        case SIG_STATE_HASH:\n        {\n            ret = HashForSignature(buf, bufSz, sigOID, sigCtx->digest,\n                                   &sigCtx->typeH, &sigCtx->digestSz, 1);\n            if (ret != 0) {\n                goto exit_cs;\n            }\n\n            sigCtx->state = SIG_STATE_KEY;\n        } /* SIG_STATE_HASH */\n        FALL_THROUGH;\n\n        case SIG_STATE_KEY:\n        {\n            switch (keyOID) {\n            #ifndef NO_RSA\n                case RSAk:\n                {\n                    word32 idx = 0;\n\n                    sigCtx->key.rsa = (RsaKey*)XMALLOC(sizeof(RsaKey),\n                                                sigCtx->heap, DYNAMIC_TYPE_RSA);\n                    sigCtx->sigCpy = (byte*)XMALLOC(MAX_ENCODED_SIG_SZ,\n                                         sigCtx->heap, DYNAMIC_TYPE_SIGNATURE);\n                    if (sigCtx->key.rsa == NULL || sigCtx->sigCpy == NULL) {\n                        ERROR_OUT(MEMORY_E, exit_cs);\n                    }\n                    if ((ret = wc_InitRsaKey_ex(sigCtx->key.rsa, sigCtx->heap,\n                                                        sigCtx->devId)) != 0) {\n                        goto exit_cs;\n                    }\n                    if (sigSz > MAX_ENCODED_SIG_SZ) {\n                        WOLFSSL_MSG(\"Verify Signature is too big\");\n                        ERROR_OUT(BUFFER_E, exit_cs);\n                    }\n                    if ((ret = wc_RsaPublicKeyDecode(key, &idx, sigCtx->key.rsa,\n                                                                 keySz)) != 0) {\n                        WOLFSSL_MSG(\"ASN Key decode error RSA\");\n                        goto exit_cs;\n                    }\n                    XMEMCPY(sigCtx->sigCpy, sig, sigSz);\n                    sigCtx->out = NULL;\n\n                #ifdef WOLFSSL_ASYNC_CRYPT\n                    sigCtx->asyncDev = &sigCtx->key.rsa->asyncDev;\n                #endif\n                    break;\n                }\n            #endif /* !NO_RSA */\n            #if !defined(NO_DSA) && !defined(HAVE_SELFTEST)\n                case DSAk:\n                {\n                    word32 idx = 0;\n\n                    if (sigSz < DSA_SIG_SIZE) {\n                        WOLFSSL_MSG(\"Verify Signature is too small\");\n                        ERROR_OUT(BUFFER_E, exit_cs);\n                    }\n                    sigCtx->key.dsa = (DsaKey*)XMALLOC(sizeof(DsaKey),\n                                                sigCtx->heap, DYNAMIC_TYPE_DSA);\n                    sigCtx->sigCpy = (byte*)XMALLOC(sigSz,\n                                         sigCtx->heap, DYNAMIC_TYPE_SIGNATURE);\n                    if (sigCtx->key.dsa == NULL || sigCtx->sigCpy == NULL) {\n                        ERROR_OUT(MEMORY_E, exit_cs);\n                    }\n                    if ((ret = wc_InitDsaKey_h(sigCtx->key.dsa, sigCtx->heap)) != 0) {\n                        WOLFSSL_MSG(\"wc_InitDsaKey_h error\");\n                        goto exit_cs;\n                    }\n                    if ((ret = wc_DsaPublicKeyDecode(key, &idx, sigCtx->key.dsa,\n                                                                 keySz)) != 0) {\n                        WOLFSSL_MSG(\"ASN Key decode error DSA\");\n                        goto exit_cs;\n                    }\n                    if (sigSz != DSA_SIG_SIZE) {\n                #ifdef HAVE_ECC\n                        /* Try to parse it as the contents of a bitstring */\n                        mp_int r, s;\n                        idx = 0;\n                        if (DecodeECC_DSA_Sig(sig + idx, sigSz - idx,\n                                              &r, &s) != 0) {\n                            WOLFSSL_MSG(\"DSA Sig is in unrecognized or \"\n                                        \"incorrect format\");\n                            ERROR_OUT(ASN_SIG_CONFIRM_E, exit_cs);\n                        }\n                        if (mp_to_unsigned_bin_len(&r, sigCtx->sigCpy,\n                                DSA_HALF_SIZE) != MP_OKAY ||\n                            mp_to_unsigned_bin_len(&s,\n                                    sigCtx->sigCpy + DSA_HALF_SIZE,\n                                    DSA_HALF_SIZE) != MP_OKAY) {\n                            WOLFSSL_MSG(\"DSA Sig is in unrecognized or \"\n                                        \"incorrect format\");\n                            ERROR_OUT(ASN_SIG_CONFIRM_E, exit_cs);\n                        }\n                        mp_free(&r);\n                        mp_free(&s);\n                #else\n                        WOLFSSL_MSG(\"DSA Sig is in unrecognized or \"\n                                    \"incorrect format\");\n                        ERROR_OUT(ASN_SIG_CONFIRM_E, exit_cs);\n                #endif\n                    }\n                    else {\n                        XMEMCPY(sigCtx->sigCpy, sig, DSA_SIG_SIZE);\n                    }\n                    break;\n                }\n            #endif /* !NO_DSA && !HAVE_SELFTEST */\n            #ifdef HAVE_ECC\n                case ECDSAk:\n                {\n                    word32 idx = 0;\n\n                    sigCtx->verify = 0;\n                    sigCtx->key.ecc = (ecc_key*)XMALLOC(sizeof(ecc_key),\n                                                sigCtx->heap, DYNAMIC_TYPE_ECC);\n                    if (sigCtx->key.ecc == NULL) {\n                        ERROR_OUT(MEMORY_E, exit_cs);\n                    }\n                    if ((ret = wc_ecc_init_ex(sigCtx->key.ecc, sigCtx->heap,\n                                                          sigCtx->devId)) < 0) {\n                        goto exit_cs;\n                    }\n                    ret = wc_EccPublicKeyDecode(key, &idx, sigCtx->key.ecc,\n                                                                         keySz);\n                    if (ret < 0) {\n                        WOLFSSL_MSG(\"ASN Key import error ECC\");\n                        goto exit_cs;\n                    }\n                #ifdef WOLFSSL_ASYNC_CRYPT\n                    sigCtx->asyncDev = &sigCtx->key.ecc->asyncDev;\n                #endif\n                    break;\n                }\n            #endif /* HAVE_ECC */\n            #ifdef HAVE_ED25519\n                case ED25519k:\n                {\n                    sigCtx->verify = 0;\n                    sigCtx->key.ed25519 = (ed25519_key*)XMALLOC(\n                                              sizeof(ed25519_key), sigCtx->heap,\n                                              DYNAMIC_TYPE_ED25519);\n                    if (sigCtx->key.ed25519 == NULL) {\n                        ERROR_OUT(MEMORY_E, exit_cs);\n                    }\n                    if ((ret = wc_ed25519_init(sigCtx->key.ed25519)) < 0) {\n                        goto exit_cs;\n                    }\n                    if ((ret = wc_ed25519_import_public(key, keySz,\n                                                    sigCtx->key.ed25519)) < 0) {\n                        WOLFSSL_MSG(\"ASN Key import error ED25519\");\n                        goto exit_cs;\n                    }\n                #ifdef WOLFSSL_ASYNC_CRYPT\n                    sigCtx->asyncDev = &sigCtx->key.ed25519->asyncDev;\n                #endif\n                    break;\n                }\n            #endif\n            #ifdef HAVE_ED448\n                case ED448k:\n                {\n                    sigCtx->verify = 0;\n                    sigCtx->key.ed448 = (ed448_key*)XMALLOC(\n                                                sizeof(ed448_key), sigCtx->heap,\n                                                DYNAMIC_TYPE_ED448);\n                    if (sigCtx->key.ed448 == NULL) {\n                        ERROR_OUT(MEMORY_E, exit_cs);\n                    }\n                    if ((ret = wc_ed448_init(sigCtx->key.ed448)) < 0) {\n                        goto exit_cs;\n                    }\n                    if ((ret = wc_ed448_import_public(key, keySz,\n                                                      sigCtx->key.ed448)) < 0) {\n                        WOLFSSL_MSG(\"ASN Key import error ED448\");\n                        goto exit_cs;\n                    }\n                #ifdef WOLFSSL_ASYNC_CRYPT\n                    sigCtx->asyncDev = &sigCtx->key.ed448->asyncDev;\n                #endif\n                    break;\n                }\n            #endif\n                default:\n                    WOLFSSL_MSG(\"Verify Key type unknown\");\n                    ret = ASN_UNKNOWN_OID_E;\n                    break;\n            } /* switch (keyOID) */\n\n            if (ret != 0) {\n                goto exit_cs;\n            }\n\n            sigCtx->state = SIG_STATE_DO;\n\n        #ifdef WOLFSSL_ASYNC_CRYPT\n            if (sigCtx->devId != INVALID_DEVID && sigCtx->asyncDev && sigCtx->asyncCtx) {\n                /* make sure event is initialized */\n                WOLF_EVENT* event = &sigCtx->asyncDev->event;\n                ret = wolfAsync_EventInit(event, WOLF_EVENT_TYPE_ASYNC_WOLFSSL,\n                    sigCtx->asyncCtx, WC_ASYNC_FLAG_CALL_AGAIN);\n            }\n        #endif\n        } /* SIG_STATE_KEY */\n        FALL_THROUGH;\n\n        case SIG_STATE_DO:\n        {\n            switch (keyOID) {\n            #ifndef NO_RSA\n                case RSAk:\n                {\n                #ifdef HAVE_PK_CALLBACKS\n                    if (sigCtx->pkCbRsa) {\n                        ret = sigCtx->pkCbRsa(\n                                sigCtx->sigCpy, sigSz, &sigCtx->out,\n                                key, keySz,\n                                sigCtx->pkCtxRsa);\n                    }\n                    else\n                #endif /* HAVE_PK_CALLBACKS */\n                    {\n                     #ifdef WOLFSSL_RENESAS_TSIP_TLS\n                        if (rsaKeyIdx != NULL)\n                        {\n                            ret = tsip_tls_CertVerify(buf, bufSz, sigCtx->sigCpy,\n                                sigSz,\n                                sigCtx->pubkey_n_start - sigCtx->certBegin,\n                                sigCtx->pubkey_n_len - 1,\n                                sigCtx->pubkey_e_start - sigCtx->certBegin,\n                                sigCtx->pubkey_e_len - 1,\n                                rsaKeyIdx);\n\n                            if (ret == 0){\n                                sigCtx->verifyByTSIP = 1;\n                                ret = 0;\n                            } else {\n                                WOLFSSL_MSG(\"RSA Verify by tsip didn't match\");\n                                ret = ASN_SIG_CONFIRM_E;\n                            }\n                        } else\n                    #endif\n                        ret = wc_RsaSSL_VerifyInline(sigCtx->sigCpy, sigSz,\n                                                 &sigCtx->out, sigCtx->key.rsa);\n                    }\n                    break;\n                }\n            #endif /* !NO_RSA */\n            #if !defined(NO_DSA) && !defined(HAVE_SELFTEST)\n                case DSAk:\n                {\n                    ret = wc_DsaVerify(sigCtx->digest, sigCtx->sigCpy,\n                            sigCtx->key.dsa, &sigCtx->verify);\n                    break;\n                }\n            #endif /* !NO_DSA && !HAVE_SELFTEST */\n            #if defined(HAVE_ECC)\n                case ECDSAk:\n                {\n                #ifdef HAVE_PK_CALLBACKS\n                    if (sigCtx->pkCbEcc) {\n                        ret = sigCtx->pkCbEcc(\n                                sig, sigSz,\n                                sigCtx->digest, sigCtx->digestSz,\n                                key, keySz, &sigCtx->verify,\n                                sigCtx->pkCtxEcc);\n                    }\n                    else\n                #endif /* HAVE_PK_CALLBACKS */\n                    {\n                        ret = wc_ecc_verify_hash(sig, sigSz, sigCtx->digest,\n                                            sigCtx->digestSz, &sigCtx->verify,\n                                            sigCtx->key.ecc);\n                    }\n                    break;\n                }\n            #endif /* HAVE_ECC */\n            #ifdef HAVE_ED25519\n                case ED25519k:\n                {\n                    ret = wc_ed25519_verify_msg(sig, sigSz, buf, bufSz,\n                                          &sigCtx->verify, sigCtx->key.ed25519);\n                    break;\n                }\n            #endif\n            #ifdef HAVE_ED448\n                case ED448k:\n                {\n                    ret = wc_ed448_verify_msg(sig, sigSz, buf, bufSz,\n                                             &sigCtx->verify, sigCtx->key.ed448,\n                                             NULL, 0);\n                    break;\n                }\n            #endif\n                default:\n                    break;\n            }  /* switch (keyOID) */\n\n        #ifdef WOLFSSL_ASYNC_CRYPT\n            if (ret == WC_PENDING_E) {\n                goto exit_cs;\n            }\n        #endif\n\n            if (ret < 0) {\n                /* treat all RSA errors as ASN_SIG_CONFIRM_E */\n                ret = ASN_SIG_CONFIRM_E;\n                goto exit_cs;\n            }\n\n            sigCtx->state = SIG_STATE_CHECK;\n        } /* SIG_STATE_DO */\n        FALL_THROUGH;\n\n        case SIG_STATE_CHECK:\n        {\n            switch (keyOID) {\n            #ifndef NO_RSA\n                case RSAk:\n                {\n                    int encodedSigSz, verifySz;\n                #ifdef WOLFSSL_RENESAS_TSIP\n                    if (sigCtx->verifyByTSIP == 1) break;\n                #endif\n                #ifdef WOLFSSL_SMALL_STACK\n                    byte* encodedSig = (byte*)XMALLOC(MAX_ENCODED_SIG_SZ,\n                                        sigCtx->heap, DYNAMIC_TYPE_TMP_BUFFER);\n                    if (encodedSig == NULL) {\n                        ERROR_OUT(MEMORY_E, exit_cs);\n                    }\n                #else\n                    byte encodedSig[MAX_ENCODED_SIG_SZ];\n                #endif\n\n                    verifySz = ret;\n\n                    /* make sure we're right justified */\n                    encodedSigSz = wc_EncodeSignature(encodedSig,\n                            sigCtx->digest, sigCtx->digestSz, sigCtx->typeH);\n                    if (encodedSigSz == verifySz && sigCtx->out != NULL &&\n                        XMEMCMP(sigCtx->out, encodedSig, encodedSigSz) == 0) {\n                        ret = 0;\n                    }\n                    else {\n                        WOLFSSL_MSG(\"RSA SSL verify match encode error\");\n                        ret = ASN_SIG_CONFIRM_E;\n                    }\n\n                #ifdef WOLFSSL_SMALL_STACK\n                    XFREE(encodedSig, sigCtx->heap, DYNAMIC_TYPE_TMP_BUFFER);\n                #endif\n                    break;\n                }\n            #endif /* NO_RSA */\n            #if !defined(NO_DSA) && !defined(HAVE_SELFTEST)\n                case DSAk:\n                {\n                    if (sigCtx->verify == 1) {\n                        ret = 0;\n                    }\n                    else {\n                        WOLFSSL_MSG(\"DSA Verify didn't match\");\n                        ret = ASN_SIG_CONFIRM_E;\n                    }\n                    break;\n                }\n            #endif /* !NO_DSA && !HAVE_SELFTEST */\n            #ifdef HAVE_ECC\n                case ECDSAk:\n                {\n                    if (sigCtx->verify == 1) {\n                        ret = 0;\n                    }\n                    else {\n                        WOLFSSL_MSG(\"ECC Verify didn't match\");\n                        ret = ASN_SIG_CONFIRM_E;\n                    }\n                    break;\n                }\n            #endif /* HAVE_ECC */\n            #ifdef HAVE_ED25519\n                case ED25519k:\n                {\n                    if (sigCtx->verify == 1) {\n                        ret = 0;\n                    }\n                    else {\n                        WOLFSSL_MSG(\"ED25519 Verify didn't match\");\n                        ret = ASN_SIG_CONFIRM_E;\n                    }\n                    break;\n                }\n            #endif /* HAVE_ED25519 */\n            #ifdef HAVE_ED448\n                case ED448k:\n                {\n                    if (sigCtx->verify == 1) {\n                        ret = 0;\n                    }\n                    else {\n                        WOLFSSL_MSG(\"ED448 Verify didn't match\");\n                        ret = ASN_SIG_CONFIRM_E;\n                    }\n                    break;\n                }\n            #endif /* HAVE_ED448 */\n                default:\n                    break;\n            }  /* switch (keyOID) */\n\n            break;\n        } /* SIG_STATE_CHECK */\n\n        default:\n            break;\n    } /* switch (sigCtx->state) */\n\nexit_cs:\n\n#endif /* !NO_ASN_CRYPT */\n\n    (void)keyOID;\n    (void)sigOID;\n\n    WOLFSSL_LEAVE(\"ConfirmSignature\", ret);\n\n#ifdef WOLFSSL_ASYNC_CRYPT\n    if (ret == WC_PENDING_E)\n        return ret;\n#endif\n\n    FreeSignatureCtx(sigCtx);\n\n    return ret;\n}\n\n\n#ifndef IGNORE_NAME_CONSTRAINTS\n\nstatic int MatchBaseName(int type, const char* name, int nameSz,\n                         const char* base, int baseSz)\n{\n    if (base == NULL || baseSz <= 0 || name == NULL || nameSz <= 0 ||\n            name[0] == '.' || nameSz < baseSz ||\n            (type != ASN_RFC822_TYPE && type != ASN_DNS_TYPE))\n        return 0;\n\n    /* If an email type, handle special cases where the base is only\n     * a domain, or is an email address itself. */\n    if (type == ASN_RFC822_TYPE) {\n        const char* p = NULL;\n        int count = 0;\n\n        if (base[0] != '.') {\n            p = base;\n            count = 0;\n\n            /* find the '@' in the base */\n            while (*p != '@' && count < baseSz) {\n                count++;\n                p++;\n            }\n\n            /* No '@' in base, reset p to NULL */\n            if (count >= baseSz)\n                p = NULL;\n        }\n\n        if (p == NULL) {\n            /* Base isn't an email address, it is a domain name,\n             * wind the name forward one character past its '@'. */\n            p = name;\n            count = 0;\n            while (*p != '@' && count < baseSz) {\n                count++;\n                p++;\n            }\n\n            if (count < baseSz && *p == '@') {\n                name = p + 1;\n                nameSz -= count + 1;\n            }\n        }\n    }\n\n    if ((type == ASN_DNS_TYPE || type == ASN_RFC822_TYPE) && base[0] == '.') {\n        int szAdjust = nameSz - baseSz;\n        name += szAdjust;\n        nameSz -= szAdjust;\n    }\n\n    while (nameSz > 0) {\n        if (XTOLOWER((unsigned char)*name++) !=\n                                               XTOLOWER((unsigned char)*base++))\n            return 0;\n        nameSz--;\n    }\n\n    return 1;\n}\n\n\nstatic int ConfirmNameConstraints(Signer* signer, DecodedCert* cert)\n{\n    if (signer == NULL || cert == NULL)\n        return 0;\n\n    /* Check against the excluded list */\n    if (signer->excludedNames) {\n        Base_entry* base = signer->excludedNames;\n\n        while (base != NULL) {\n            switch (base->type) {\n                case ASN_DNS_TYPE:\n                {\n                    DNS_entry* name = cert->altNames;\n                    while (name != NULL) {\n                        if (MatchBaseName(ASN_DNS_TYPE,\n                                          name->name, name->len,\n                                          base->name, base->nameSz)) {\n                            return 0;\n                        }\n                        name = name->next;\n                    }\n                    break;\n                }\n                case ASN_RFC822_TYPE:\n                {\n                    DNS_entry* name = cert->altEmailNames;\n                    while (name != NULL) {\n                        if (MatchBaseName(ASN_RFC822_TYPE,\n                                          name->name, name->len,\n                                          base->name, base->nameSz)) {\n                            return 0;\n                        }\n                        name = name->next;\n                    }\n                    break;\n                }\n                case ASN_DIR_TYPE:\n                {\n                    /* allow permitted dirName smaller than actual subject */\n                    if (cert->subjectRawLen >= base->nameSz &&\n                        XMEMCMP(cert->subjectRaw, base->name,\n                                                        base->nameSz) == 0) {\n                        return 0;\n                    }\n                    #ifndef WOLFSSL_NO_ASN_STRICT\n                    /* RFC 5280 section 4.2.1.10\n                       \"Restrictions of the form directoryName MUST be\n                        applied to the subject field .... and to any names\n                        of type directoryName in the subjectAltName\n                        extension\"\n                    */\n                    if (cert->altDirNames != NULL) {\n                        DNS_entry* cur = cert->altDirNames;\n                        while (cur != NULL) {\n                            if (XMEMCMP(cur->name, base->name, base->nameSz)\n                                    == 0) {\n                                WOLFSSL_MSG(\"DIR alt name constraint err\");\n                                return 0;\n                            }\n                            cur = cur->next;\n                        }\n                    }\n                    #endif /* !WOLFSSL_NO_ASN_STRICT */\n                    break;\n                }\n                default:\n                    break;\n            }; /* switch */\n            base = base->next;\n        }\n    }\n\n    /* Check against the permitted list */\n    if (signer->permittedNames != NULL) {\n        int needDns = 0;\n        int matchDns = 0;\n        int needEmail = 0;\n        int matchEmail = 0;\n        int needDir = 0;\n        int matchDir = 0;\n        Base_entry* base = signer->permittedNames;\n\n        while (base != NULL) {\n            switch (base->type) {\n                case ASN_DNS_TYPE:\n                {\n                    DNS_entry* name = cert->altNames;\n\n                    if (name != NULL)\n                        needDns = 1;\n\n                    while (name != NULL) {\n                        matchDns = MatchBaseName(ASN_DNS_TYPE,\n                                          name->name, name->len,\n                                          base->name, base->nameSz);\n                        name = name->next;\n                    }\n                    break;\n                }\n                case ASN_RFC822_TYPE:\n                {\n                    DNS_entry* name = cert->altEmailNames;\n\n                    if (name != NULL)\n                        needEmail = 1;\n\n                    while (name != NULL) {\n                        matchEmail = MatchBaseName(ASN_DNS_TYPE,\n                                          name->name, name->len,\n                                          base->name, base->nameSz);\n                        name = name->next;\n                    }\n                    break;\n                }\n                case ASN_DIR_TYPE:\n                {\n                    /* allow permitted dirName smaller than actual subject */\n                    needDir = 1;\n                    if (cert->subjectRaw != NULL &&\n                        cert->subjectRawLen >= base->nameSz &&\n                        XMEMCMP(cert->subjectRaw, base->name,\n                                                        base->nameSz) == 0) {\n                        matchDir = 1;\n\n                        #ifndef WOLFSSL_NO_ASN_STRICT\n                        /* RFC 5280 section 4.2.1.10\n                           \"Restrictions of the form directoryName MUST be\n                            applied to the subject field .... and to any names\n                            of type directoryName in the subjectAltName\n                            extension\"\n                        */\n                        if (cert->altDirNames != NULL) {\n                            DNS_entry* cur = cert->altDirNames;\n                            while (cur != NULL) {\n                                if (XMEMCMP(cur->name, base->name, base->nameSz)\n                                        != 0) {\n                                    WOLFSSL_MSG(\"DIR alt name constraint err\");\n                                    matchDir = 0; /* did not match */\n                                }\n                                cur = cur->next;\n                            }\n                        }\n                        #endif /* !WOLFSSL_NO_ASN_STRICT */\n                    }\n                    break;\n                }\n                default:\n                    break;\n            } /* switch */\n            base = base->next;\n        }\n\n        if ((needDns   && !matchDns) ||\n            (needEmail && !matchEmail) ||\n            (needDir   && !matchDir)) {\n            return 0;\n        }\n    }\n\n    return 1;\n}\n\n#endif /* IGNORE_NAME_CONSTRAINTS */\n\nstatic int DecodeAltNames(const byte* input, int sz, DecodedCert* cert)\n{\n    word32 idx = 0;\n    int length = 0;\n\n    WOLFSSL_ENTER(\"DecodeAltNames\");\n\n    if (GetSequence(input, &idx, &length, sz) < 0) {\n        WOLFSSL_MSG(\"\\tBad Sequence\");\n        return ASN_PARSE_E;\n    }\n\n    if (length == 0) {\n        /* RFC 5280 4.2.1.6.  Subject Alternative Name\n           If the subjectAltName extension is present, the sequence MUST\n           contain at least one entry. */\n        return ASN_PARSE_E;\n    }\n\n    cert->weOwnAltNames = 1;\n\n    while (length > 0) {\n        byte b = input[idx++];\n\n        length--;\n\n        /* Save DNS Type names in the altNames list. */\n        /* Save Other Type names in the cert's OidMap */\n        if (b == (ASN_CONTEXT_SPECIFIC | ASN_DNS_TYPE)) {\n            DNS_entry* dnsEntry;\n            int strLen;\n            word32 lenStartIdx = idx;\n\n            if (GetLength(input, &idx, &strLen, sz) < 0) {\n                WOLFSSL_MSG(\"\\tfail: str length\");\n                return ASN_PARSE_E;\n            }\n            length -= (idx - lenStartIdx);\n\n            dnsEntry = (DNS_entry*)XMALLOC(sizeof(DNS_entry), cert->heap,\n                                        DYNAMIC_TYPE_ALTNAME);\n            if (dnsEntry == NULL) {\n                WOLFSSL_MSG(\"\\tOut of Memory\");\n                return MEMORY_E;\n            }\n\n            dnsEntry->type = ASN_DNS_TYPE;\n            dnsEntry->name = (char*)XMALLOC(strLen + 1, cert->heap,\n                                         DYNAMIC_TYPE_ALTNAME);\n            if (dnsEntry->name == NULL) {\n                WOLFSSL_MSG(\"\\tOut of Memory\");\n                XFREE(dnsEntry, cert->heap, DYNAMIC_TYPE_ALTNAME);\n                return MEMORY_E;\n            }\n            dnsEntry->len = strLen;\n            XMEMCPY(dnsEntry->name, &input[idx], strLen);\n            dnsEntry->name[strLen] = '\\0';\n\n            dnsEntry->next = cert->altNames;\n            cert->altNames = dnsEntry;\n\n            length -= strLen;\n            idx    += strLen;\n        }\n    #ifndef IGNORE_NAME_CONSTRAINTS\n        else if (b == (ASN_CONTEXT_SPECIFIC | ASN_CONSTRUCTED | ASN_DIR_TYPE)) {\n            DNS_entry* dirEntry;\n            int strLen;\n            word32 lenStartIdx = idx;\n\n            if (GetLength(input, &idx, &strLen, sz) < 0) {\n                WOLFSSL_MSG(\"\\tfail: str length\");\n                return ASN_PARSE_E;\n            }\n\n            if (GetSequence(input, &idx, &strLen, sz) < 0) {\n                WOLFSSL_MSG(\"\\tfail: seq length\");\n                return ASN_PARSE_E;\n            }\n            length -= (idx - lenStartIdx);\n\n            dirEntry = (DNS_entry*)XMALLOC(sizeof(DNS_entry), cert->heap,\n                                        DYNAMIC_TYPE_ALTNAME);\n            if (dirEntry == NULL) {\n                WOLFSSL_MSG(\"\\tOut of Memory\");\n                return MEMORY_E;\n            }\n\n            dirEntry->type = ASN_DIR_TYPE;\n            dirEntry->name = (char*)XMALLOC(strLen + 1, cert->heap,\n                                         DYNAMIC_TYPE_ALTNAME);\n            if (dirEntry->name == NULL) {\n                WOLFSSL_MSG(\"\\tOut of Memory\");\n                XFREE(dirEntry, cert->heap, DYNAMIC_TYPE_ALTNAME);\n                return MEMORY_E;\n            }\n            dirEntry->len = strLen;\n            XMEMCPY(dirEntry->name, &input[idx], strLen);\n            dirEntry->name[strLen] = '\\0';\n\n            dirEntry->next = cert->altDirNames;\n            cert->altDirNames = dirEntry;\n\n            length -= strLen;\n            idx    += strLen;\n        }\n        else if (b == (ASN_CONTEXT_SPECIFIC | ASN_RFC822_TYPE)) {\n            DNS_entry* emailEntry;\n            int strLen;\n            word32 lenStartIdx = idx;\n\n            if (GetLength(input, &idx, &strLen, sz) < 0) {\n                WOLFSSL_MSG(\"\\tfail: str length\");\n                return ASN_PARSE_E;\n            }\n            length -= (idx - lenStartIdx);\n\n            emailEntry = (DNS_entry*)XMALLOC(sizeof(DNS_entry), cert->heap,\n                                        DYNAMIC_TYPE_ALTNAME);\n            if (emailEntry == NULL) {\n                WOLFSSL_MSG(\"\\tOut of Memory\");\n                return MEMORY_E;\n            }\n\n            emailEntry->type = ASN_RFC822_TYPE;\n            emailEntry->name = (char*)XMALLOC(strLen + 1, cert->heap,\n                                         DYNAMIC_TYPE_ALTNAME);\n            if (emailEntry->name == NULL) {\n                WOLFSSL_MSG(\"\\tOut of Memory\");\n                XFREE(emailEntry, cert->heap, DYNAMIC_TYPE_ALTNAME);\n                return MEMORY_E;\n            }\n            emailEntry->len = strLen;\n            XMEMCPY(emailEntry->name, &input[idx], strLen);\n            emailEntry->name[strLen] = '\\0';\n\n            emailEntry->next = cert->altEmailNames;\n            cert->altEmailNames = emailEntry;\n\n            length -= strLen;\n            idx    += strLen;\n        }\n        else if (b == (ASN_CONTEXT_SPECIFIC | ASN_URI_TYPE)) {\n            DNS_entry* uriEntry;\n            int strLen;\n            word32 lenStartIdx = idx;\n\n            WOLFSSL_MSG(\"\\tPutting URI into list but not using\");\n            if (GetLength(input, &idx, &strLen, sz) < 0) {\n                WOLFSSL_MSG(\"\\tfail: str length\");\n                return ASN_PARSE_E;\n            }\n            length -= (idx - lenStartIdx);\n\n            /* check that strLen at index is not past input buffer */\n            if (strLen + (int)idx > sz) {\n                return BUFFER_E;\n            }\n\n        #ifndef WOLFSSL_NO_ASN_STRICT\n            /* Verify RFC 5280 Sec 4.2.1.6 rule:\n                \"The name MUST NOT be a relative URI\" */\n\n            {\n                int i;\n\n                /* skip past scheme (i.e http,ftp,...) finding first ':' char */\n                for (i = 0; i < strLen; i++) {\n                    if (input[idx + i] == ':') {\n                        break;\n                    }\n                    if (input[idx + i] == '/') {\n                        WOLFSSL_MSG(\"\\tAlt Name must be absolute URI\");\n                        return ASN_ALT_NAME_E;\n                    }\n                }\n\n                /* test if no ':' char was found and test that the next two\n                 * chars are // to match the pattern \"://\" */\n                if (i >= strLen - 2 || (input[idx + i + 1] != '/' ||\n                                        input[idx + i + 2] != '/')) {\n                    WOLFSSL_MSG(\"\\tAlt Name must be absolute URI\");\n                    return ASN_ALT_NAME_E;\n                }\n            }\n        #endif\n\n            uriEntry = (DNS_entry*)XMALLOC(sizeof(DNS_entry), cert->heap,\n                                        DYNAMIC_TYPE_ALTNAME);\n            if (uriEntry == NULL) {\n                WOLFSSL_MSG(\"\\tOut of Memory\");\n                return MEMORY_E;\n            }\n\n            uriEntry->type = ASN_URI_TYPE;\n            uriEntry->name = (char*)XMALLOC(strLen + 1, cert->heap,\n                                         DYNAMIC_TYPE_ALTNAME);\n            if (uriEntry->name == NULL) {\n                WOLFSSL_MSG(\"\\tOut of Memory\");\n                XFREE(uriEntry, cert->heap, DYNAMIC_TYPE_ALTNAME);\n                return MEMORY_E;\n            }\n            uriEntry->len = strLen;\n            XMEMCPY(uriEntry->name, &input[idx], strLen);\n            uriEntry->name[strLen] = '\\0';\n\n            uriEntry->next = cert->altNames;\n            cert->altNames = uriEntry;\n\n            length -= strLen;\n            idx    += strLen;\n        }\n#if defined(WOLFSSL_QT) || defined(OPENSSL_ALL) || defined(WOLFSSL_IP_ALT_NAME)\n        else if (b == (ASN_CONTEXT_SPECIFIC | ASN_IP_TYPE)) {\n            DNS_entry* ipAddr;\n            int strLen;\n            word32 lenStartIdx = idx;\n            WOLFSSL_MSG(\"Decoding Subject Alt. Name: IP Address\");\n\n            if (GetLength(input, &idx, &strLen, sz) < 0) {\n                WOLFSSL_MSG(\"\\tfail: str length\");\n                return ASN_PARSE_E;\n            }\n            length -= (idx - lenStartIdx);\n            /* check that strLen at index is not past input buffer */\n            if (strLen + (int)idx > sz) {\n                return BUFFER_E;\n            }\n\n            ipAddr = (DNS_entry*)XMALLOC(sizeof(DNS_entry), cert->heap,\n                                        DYNAMIC_TYPE_ALTNAME);\n            if (ipAddr == NULL) {\n                WOLFSSL_MSG(\"\\tOut of Memory\");\n                return MEMORY_E;\n            }\n\n            ipAddr->type = ASN_IP_TYPE;\n            ipAddr->name = (char*)XMALLOC(strLen + 1, cert->heap,\n                                         DYNAMIC_TYPE_ALTNAME);\n            if (ipAddr->name == NULL) {\n                WOLFSSL_MSG(\"\\tOut of Memory\");\n                XFREE(ipAddr, cert->heap, DYNAMIC_TYPE_ALTNAME);\n                return MEMORY_E;\n            }\n            ipAddr->len = strLen;\n            XMEMCPY(ipAddr->name, &input[idx], strLen);\n            ipAddr->name[strLen] = '\\0';\n\n            ipAddr->next   = cert->altNames;\n            cert->altNames = ipAddr;\n\n            length -= strLen;\n            idx    += strLen;\n        }\n#endif /* WOLFSSL_QT || OPENSSL_ALL */\n#endif /* IGNORE_NAME_CONSTRAINTS */\n#ifdef WOLFSSL_SEP\n        else if (b == (ASN_CONTEXT_SPECIFIC | ASN_CONSTRUCTED | ASN_OTHER_TYPE))\n        {\n            int strLen;\n            word32 lenStartIdx = idx;\n            word32 oid = 0;\n            int    ret;\n            byte   tag;\n\n            if (GetLength(input, &idx, &strLen, sz) < 0) {\n                WOLFSSL_MSG(\"\\tfail: other name length\");\n                return ASN_PARSE_E;\n            }\n            /* Consume the rest of this sequence. */\n            length -= (strLen + idx - lenStartIdx);\n\n            if (GetObjectId(input, &idx, &oid, oidCertAltNameType, sz) < 0) {\n                WOLFSSL_MSG(\"\\tbad OID\");\n                return ASN_PARSE_E;\n            }\n\n            if (oid != HW_NAME_OID) {\n                WOLFSSL_MSG(\"\\tincorrect OID\");\n                return ASN_PARSE_E;\n            }\n\n            /* Certiciates issued with this OID in the subject alt name are for\n             * verifying signatures created on a module.\n             * RFC 4108 Section 5. */\n            if (cert->hwType != NULL) {\n                WOLFSSL_MSG(\"\\tAlready seen Hardware Module Name\");\n                return ASN_PARSE_E;\n            }\n\n            if (GetASNTag(input, &idx, &tag, sz) < 0) {\n                return ASN_PARSE_E;\n            }\n\n            if (tag != (ASN_CONTEXT_SPECIFIC | ASN_CONSTRUCTED)) {\n                WOLFSSL_MSG(\"\\twrong type\");\n                return ASN_PARSE_E;\n            }\n\n            if (GetLength(input, &idx, &strLen, sz) < 0) {\n                WOLFSSL_MSG(\"\\tfail: str len\");\n                return ASN_PARSE_E;\n            }\n\n            if (GetSequence(input, &idx, &strLen, sz) < 0) {\n                WOLFSSL_MSG(\"\\tBad Sequence\");\n                return ASN_PARSE_E;\n            }\n\n            ret = GetASNObjectId(input, &idx, &strLen, sz);\n            if (ret != 0) {\n                WOLFSSL_MSG(\"\\tbad OID\");\n                return ret;\n            }\n\n            cert->hwType = (byte*)XMALLOC(strLen, cert->heap,\n                                          DYNAMIC_TYPE_X509_EXT);\n            if (cert->hwType == NULL) {\n                WOLFSSL_MSG(\"\\tOut of Memory\");\n                return MEMORY_E;\n            }\n\n            XMEMCPY(cert->hwType, &input[idx], strLen);\n            cert->hwTypeSz = strLen;\n            idx += strLen;\n\n            ret = GetOctetString(input, &idx, &strLen, sz);\n            if (ret < 0)\n                return ret;\n\n            cert->hwSerialNum = (byte*)XMALLOC(strLen + 1, cert->heap,\n                                               DYNAMIC_TYPE_X509_EXT);\n            if (cert->hwSerialNum == NULL) {\n                WOLFSSL_MSG(\"\\tOut of Memory\");\n                return MEMORY_E;\n            }\n\n            XMEMCPY(cert->hwSerialNum, &input[idx], strLen);\n            cert->hwSerialNum[strLen] = '\\0';\n            cert->hwSerialNumSz = strLen;\n            idx += strLen;\n        }\n    #endif /* WOLFSSL_SEP */\n        else {\n            int strLen;\n            word32 lenStartIdx = idx;\n\n            WOLFSSL_MSG(\"\\tUnsupported name type, skipping\");\n\n            if (GetLength(input, &idx, &strLen, sz) < 0) {\n                WOLFSSL_MSG(\"\\tfail: unsupported name length\");\n                return ASN_PARSE_E;\n            }\n            length -= (strLen + idx - lenStartIdx);\n            idx += strLen;\n        }\n    }\n    return 0;\n}\n\nstatic int DecodeBasicCaConstraint(const byte* input, int sz, DecodedCert* cert)\n{\n    word32 idx = 0;\n    int length = 0;\n    int ret;\n\n    WOLFSSL_ENTER(\"DecodeBasicCaConstraint\");\n\n    if (GetSequence(input, &idx, &length, sz) < 0) {\n        WOLFSSL_MSG(\"\\tfail: bad SEQUENCE\");\n        return ASN_PARSE_E;\n    }\n\n    if (length == 0)\n        return 0;\n\n    /* If the basic ca constraint is false, this extension may be named, but\n     * left empty. So, if the length is 0, just return. */\n\n    ret = GetBoolean(input, &idx, sz);\n\n#ifndef WOLFSSL_X509_BASICCONS_INT\n    if (ret < 0) {\n        WOLFSSL_MSG(\"\\tfail: constraint not valid BOOLEAN\");\n        return ret;\n    }\n\n    cert->isCA = (byte)ret;\n#else\n    if (ret < 0) {\n        if(input[idx] == ASN_INTEGER) {\n            /* For OpenSSL compatibility, if ASN_INTEGER it is valid format */\n            cert->isCA = FALSE;\n        } else return ret;\n    } else\n        cert->isCA = (byte)ret;\n#endif\n\n    /* If there isn't any more data, return. */\n    if (idx >= (word32)sz) {\n        return 0;\n    }\n\n    ret = GetInteger7Bit(input, &idx, sz);\n    if (ret < 0)\n        return ret;\n    cert->pathLength = (byte)ret;\n    cert->pathLengthSet = 1;\n\n    return 0;\n}\n\n\nstatic int DecodePolicyConstraints(const byte* input, int sz, DecodedCert* cert)\n{\n    word32 idx = 0;\n    int length = 0;\n    int skipLength = 0;\n    int ret;\n    byte tag;\n\n    WOLFSSL_ENTER(\"DecodePolicyConstraints\");\n\n    if (GetSequence(input, &idx, &length, sz) < 0) {\n        WOLFSSL_MSG(\"\\tfail: bad SEQUENCE\");\n        return ASN_PARSE_E;\n    }\n\n    if (length == 0)\n        return ASN_PARSE_E;\n\n    if (GetASNTag(input, &idx, &tag, sz) < 0) {\n        WOLFSSL_MSG(\"\\tfail: bad TAG\");\n        return ASN_PARSE_E;\n    }\n\n    if (tag == (ASN_CONTEXT_SPECIFIC | 0)) {\n        /* requireExplicitPolicy */\n        cert->extPolicyConstRxpSet = 1;\n    }\n    else if (tag == (ASN_CONTEXT_SPECIFIC | 1)) {\n        /* inhibitPolicyMapping */\n        cert->extPolicyConstIpmSet = 1;\n    }\n    else {\n        WOLFSSL_MSG(\"\\tfail: invalid TAG\");\n        return ASN_PARSE_E;\n    }\n\n    ret = GetLength(input, &idx, &skipLength, sz);\n    if (ret < 0) {\n        WOLFSSL_MSG(\"\\tfail: invalid length\");\n        return ret;\n    }\n    if (skipLength > 1) {\n        WOLFSSL_MSG(\"\\tfail: skip value too big\");\n        return BUFFER_E;\n    }\n    cert->policyConstSkip = input[idx];\n\n    return 0;\n}\n\n\n#define CRLDP_FULL_NAME 0\n    /* From RFC3280 SS4.2.1.14, Distribution Point Name*/\n#define GENERALNAME_URI 6\n    /* From RFC3280 SS4.2.1.7, GeneralName */\n\nstatic int DecodeCrlDist(const byte* input, int sz, DecodedCert* cert)\n{\n    word32 idx = 0, localIdx;\n    int length = 0;\n    byte tag   = 0;\n\n    WOLFSSL_ENTER(\"DecodeCrlDist\");\n\n    /* Unwrap the list of Distribution Points*/\n    if (GetSequence(input, &idx, &length, sz) < 0)\n        return ASN_PARSE_E;\n\n    /* Unwrap a single Distribution Point */\n    if (GetSequence(input, &idx, &length, sz) < 0)\n        return ASN_PARSE_E;\n\n    /* The Distribution Point has three explicit optional members\n     *  First check for a DistributionPointName\n     */\n    localIdx = idx;\n    if (GetASNTag(input, &localIdx, &tag, sz) == 0 &&\n            tag == (ASN_CONSTRUCTED | ASN_CONTEXT_SPECIFIC | 0))\n    {\n        idx++;\n        if (GetLength(input, &idx, &length, sz) < 0)\n            return ASN_PARSE_E;\n\n        localIdx = idx;\n        if (GetASNTag(input, &localIdx, &tag, sz) == 0 &&\n                tag == (ASN_CONTEXT_SPECIFIC | ASN_CONSTRUCTED |\n                    CRLDP_FULL_NAME))\n        {\n            idx++;\n            if (GetLength(input, &idx, &length, sz) < 0)\n                return ASN_PARSE_E;\n\n            localIdx = idx;\n            if (GetASNTag(input, &localIdx, &tag, sz) == 0 &&\n                    tag == (ASN_CONTEXT_SPECIFIC | GENERALNAME_URI))\n            {\n                idx++;\n                if (GetLength(input, &idx, &length, sz) < 0)\n                    return ASN_PARSE_E;\n\n                cert->extCrlInfoSz = length;\n                cert->extCrlInfo = input + idx;\n                idx += length;\n            }\n            else\n                /* This isn't a URI, skip it. */\n                idx += length;\n        }\n        else {\n            /* This isn't a FULLNAME, skip it. */\n            idx += length;\n        }\n    }\n\n    /* Check for reasonFlags */\n    localIdx = idx;\n    if (idx < (word32)sz &&\n        GetASNTag(input, &localIdx, &tag, sz) == 0 &&\n        tag == (ASN_CONSTRUCTED | ASN_CONTEXT_SPECIFIC | 1))\n    {\n        idx++;\n        if (GetLength(input, &idx, &length, sz) < 0)\n            return ASN_PARSE_E;\n        idx += length;\n    }\n\n    /* Check for cRLIssuer */\n    localIdx = idx;\n    if (idx < (word32)sz &&\n        GetASNTag(input, &localIdx, &tag, sz) == 0 &&\n        tag == (ASN_CONSTRUCTED | ASN_CONTEXT_SPECIFIC | 2))\n    {\n        idx++;\n        if (GetLength(input, &idx, &length, sz) < 0)\n            return ASN_PARSE_E;\n        idx += length;\n    }\n\n    if (idx < (word32)sz)\n    {\n        WOLFSSL_MSG(\"\\tThere are more CRL Distribution Point records, \"\n                   \"but we only use the first one.\");\n    }\n\n    return 0;\n}\n\n\nstatic int DecodeAuthInfo(const byte* input, int sz, DecodedCert* cert)\n/*\n *  Read Authority Information Access records. If there are\n *  any issues, return without saving the record.\n */\n{\n    word32 idx = 0;\n    int length = 0;\n    int count  = 0;\n    byte b = 0;\n    word32 oid;\n\n    WOLFSSL_ENTER(\"DecodeAuthInfo\");\n\n    /* Unwrap the list of AIAs */\n    if (GetSequence(input, &idx, &length, sz) < 0)\n        return ASN_PARSE_E;\n\n    while ((idx < (word32)sz) && (count < MAX_AIA_SZ)) {\n        /* Unwrap a single AIA */\n        if (GetSequence(input, &idx, &length, sz) < 0)\n            return ASN_PARSE_E;\n\n        oid = 0;\n        if (GetObjectId(input, &idx, &oid, oidCertAuthInfoType, sz) < 0)\n            return ASN_PARSE_E;\n\n        /* Only supporting URIs right now. */\n        if (GetASNTag(input, &idx, &b, sz) < 0)\n            return ASN_PARSE_E;\n\n        if (GetLength(input, &idx, &length, sz) < 0)\n            return ASN_PARSE_E;\n\n        /* Set ocsp entry */\n        if (b == (ASN_CONTEXT_SPECIFIC | GENERALNAME_URI) &&\n            oid == AIA_OCSP_OID)\n        {\n            cert->extAuthInfoSz = length;\n            cert->extAuthInfo = input + idx;\n            count++;\n        #if !defined(OPENSSL_ALL) || !defined(WOLFSSL_QT)\n            break;\n        #endif\n        }\n        #if defined(OPENSSL_ALL) || defined(WOLFSSL_QT)\n        /* Set CaIssuers entry */\n        else if ((b == (ASN_CONTEXT_SPECIFIC | GENERALNAME_URI)) &&\n            oid == AIA_CA_ISSUER_OID)\n        {\n            cert->extAuthInfoCaIssuerSz = length;\n            cert->extAuthInfoCaIssuer = input + idx;\n            count++;\n        }\n        #endif\n        idx += length;\n    }\n\n    return 0;\n}\n\n\nstatic int DecodeAuthKeyId(const byte* input, int sz, DecodedCert* cert)\n{\n    word32 idx = 0;\n    int length = 0, ret = 0;\n    byte tag;\n\n    WOLFSSL_ENTER(\"DecodeAuthKeyId\");\n\n    if (GetSequence(input, &idx, &length, sz) < 0) {\n        WOLFSSL_MSG(\"\\tfail: should be a SEQUENCE\\n\");\n        return ASN_PARSE_E;\n    }\n\n    if (GetASNTag(input, &idx, &tag, sz) < 0) {\n        return ASN_PARSE_E;\n    }\n\n    if (tag != (ASN_CONTEXT_SPECIFIC | 0)) {\n        WOLFSSL_MSG(\"\\tinfo: OPTIONAL item 0, not available\\n\");\n        cert->extAuthKeyIdSet = 0;\n        return 0;\n    }\n\n    if (GetLength(input, &idx, &length, sz) <= 0) {\n        WOLFSSL_MSG(\"\\tfail: extension data length\");\n        return ASN_PARSE_E;\n    }\n\n#if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)\n    cert->extAuthKeyIdSrc = &input[idx];\n    cert->extAuthKeyIdSz = length;\n#endif /* OPENSSL_EXTRA */\n\n    if (length == KEYID_SIZE) {\n        XMEMCPY(cert->extAuthKeyId, input + idx, length);\n    }\n    else\n        ret = CalcHashId(input + idx, length, cert->extAuthKeyId);\n\n    return ret;\n}\n\n\nstatic int DecodeSubjKeyId(const byte* input, int sz, DecodedCert* cert)\n{\n    word32 idx = 0;\n    int length = 0, ret = 0;\n\n    WOLFSSL_ENTER(\"DecodeSubjKeyId\");\n\n    if (sz <= 0)\n        return ASN_PARSE_E;\n\n    ret = GetOctetString(input, &idx, &length, sz);\n    if (ret < 0)\n        return ret;\n\n    #if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)\n        cert->extSubjKeyIdSrc = &input[idx];\n        cert->extSubjKeyIdSz = length;\n    #endif /* OPENSSL_EXTRA */\n\n    if (length == KEYID_SIZE) {\n        XMEMCPY(cert->extSubjKeyId, input + idx, length);\n    }\n    else\n        ret = CalcHashId(input + idx, length, cert->extSubjKeyId);\n\n    return ret;\n}\n\n\nstatic int DecodeKeyUsage(const byte* input, int sz, DecodedCert* cert)\n{\n    word32 idx = 0;\n    int length;\n    int ret;\n    WOLFSSL_ENTER(\"DecodeKeyUsage\");\n\n    ret = CheckBitString(input, &idx, &length, sz, 0, NULL);\n    if (ret != 0)\n        return ret;\n\n    cert->extKeyUsage = (word16)(input[idx]);\n    if (length == 2)\n        cert->extKeyUsage |= (word16)(input[idx+1] << 8);\n\n    return 0;\n}\n\n\nstatic int DecodeExtKeyUsage(const byte* input, int sz, DecodedCert* cert)\n{\n    word32 idx = 0, oid;\n    int length, ret;\n\n    WOLFSSL_MSG(\"DecodeExtKeyUsage\");\n\n    if (GetSequence(input, &idx, &length, sz) < 0) {\n        WOLFSSL_MSG(\"\\tfail: should be a SEQUENCE\");\n        return ASN_PARSE_E;\n    }\n\n#if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)\n    cert->extExtKeyUsageSrc = input + idx;\n    cert->extExtKeyUsageSz = length;\n#endif\n\n    while (idx < (word32)sz) {\n        ret = GetObjectId(input, &idx, &oid, oidCertKeyUseType, sz);\n        if (ret == ASN_UNKNOWN_OID_E)\n            continue;\n        else if (ret < 0)\n            return ret;\n\n        switch (oid) {\n            case EKU_ANY_OID:\n                cert->extExtKeyUsage |= EXTKEYUSE_ANY;\n                break;\n            case EKU_SERVER_AUTH_OID:\n                cert->extExtKeyUsage |= EXTKEYUSE_SERVER_AUTH;\n                break;\n            case EKU_CLIENT_AUTH_OID:\n                cert->extExtKeyUsage |= EXTKEYUSE_CLIENT_AUTH;\n                break;\n            case EKU_CODESIGNING_OID:\n                cert->extExtKeyUsage |= EXTKEYUSE_CODESIGN;\n                break;\n            case EKU_EMAILPROTECT_OID:\n                cert->extExtKeyUsage |= EXTKEYUSE_EMAILPROT;\n                break;\n            case EKU_TIMESTAMP_OID:\n                cert->extExtKeyUsage |= EXTKEYUSE_TIMESTAMP;\n                break;\n            case EKU_OCSP_SIGN_OID:\n                cert->extExtKeyUsage |= EXTKEYUSE_OCSP_SIGN;\n                break;\n            default:\n                break;\n        }\n\n    #if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)\n        cert->extExtKeyUsageCount++;\n    #endif\n    }\n\n    return 0;\n}\n\n\n#ifndef IGNORE_NAME_CONSTRAINTS\n#define ASN_TYPE_MASK 0xF\nstatic int DecodeSubtree(const byte* input, int sz,\n                         Base_entry** head, void* heap)\n{\n    word32 idx = 0;\n\n    (void)heap;\n\n    while (idx < (word32)sz) {\n        int seqLength, strLength;\n        word32 nameIdx;\n        byte b, bType;\n\n        if (GetSequence(input, &idx, &seqLength, sz) < 0) {\n            WOLFSSL_MSG(\"\\tfail: should be a SEQUENCE\");\n            return ASN_PARSE_E;\n        }\n        nameIdx = idx;\n        b = input[nameIdx++];\n\n        if (GetLength(input, &nameIdx, &strLength, sz) <= 0) {\n            WOLFSSL_MSG(\"\\tinvalid length\");\n            return ASN_PARSE_E;\n        }\n\n        /* Get type, LSB 4-bits */\n        bType = (b & ASN_TYPE_MASK);\n\n        if (bType == ASN_DNS_TYPE || bType == ASN_RFC822_TYPE ||\n                                                        bType == ASN_DIR_TYPE) {\n            Base_entry* entry;\n\n            /* if constructed has leading sequence */\n            if (b & ASN_CONSTRUCTED) {\n                if (GetSequence(input, &nameIdx, &strLength, sz) < 0) {\n                    WOLFSSL_MSG(\"\\tfail: constructed be a SEQUENCE\");\n                    return ASN_PARSE_E;\n                }\n            }\n\n            entry = (Base_entry*)XMALLOC(sizeof(Base_entry), heap,\n                                                          DYNAMIC_TYPE_ALTNAME);\n            if (entry == NULL) {\n                WOLFSSL_MSG(\"allocate error\");\n                return MEMORY_E;\n            }\n\n            entry->name = (char*)XMALLOC(strLength, heap, DYNAMIC_TYPE_ALTNAME);\n            if (entry->name == NULL) {\n                WOLFSSL_MSG(\"allocate error\");\n                XFREE(entry, heap, DYNAMIC_TYPE_ALTNAME);\n                return MEMORY_E;\n            }\n\n            XMEMCPY(entry->name, &input[nameIdx], strLength);\n            entry->nameSz = strLength;\n            entry->type = bType;\n\n            entry->next = *head;\n            *head = entry;\n        }\n\n        idx += seqLength;\n    }\n\n    return 0;\n}\n\n\nstatic int DecodeNameConstraints(const byte* input, int sz, DecodedCert* cert)\n{\n    word32 idx = 0;\n    int length = 0;\n\n    WOLFSSL_ENTER(\"DecodeNameConstraints\");\n\n    if (GetSequence(input, &idx, &length, sz) < 0) {\n        WOLFSSL_MSG(\"\\tfail: should be a SEQUENCE\");\n        return ASN_PARSE_E;\n    }\n\n    while (idx < (word32)sz) {\n        byte b = input[idx++];\n        Base_entry** subtree = NULL;\n\n        if (GetLength(input, &idx, &length, sz) <= 0) {\n            WOLFSSL_MSG(\"\\tinvalid length\");\n            return ASN_PARSE_E;\n        }\n\n        if (b == (ASN_CONTEXT_SPECIFIC | ASN_CONSTRUCTED | 0))\n            subtree = &cert->permittedNames;\n        else if (b == (ASN_CONTEXT_SPECIFIC | ASN_CONSTRUCTED | 1))\n            subtree = &cert->excludedNames;\n        else {\n            WOLFSSL_MSG(\"\\tinvalid subtree\");\n            return ASN_PARSE_E;\n        }\n\n        if (DecodeSubtree(input + idx, length, subtree, cert->heap) < 0) {\n            WOLFSSL_MSG(\"\\terror parsing subtree\");\n            return ASN_PARSE_E;\n        }\n\n        idx += length;\n    }\n\n    return 0;\n}\n#endif /* IGNORE_NAME_CONSTRAINTS */\n\n#if (defined(WOLFSSL_CERT_EXT) && !defined(WOLFSSL_SEP)) || \\\n    defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)\n\n/* Decode ITU-T X.690 OID format to a string representation\n * return string length */\nint DecodePolicyOID(char *out, word32 outSz, const byte *in, word32 inSz)\n{\n    word32 val, inIdx = 0, outIdx = 0;\n    int w = 0;\n\n    if (out == NULL || in == NULL || outSz < 4 || inSz < 2)\n        return BAD_FUNC_ARG;\n\n    /* The first byte expands into b/40 dot b%40. */\n    val = in[inIdx++];\n\n    w = XSNPRINTF(out, outSz, \"%u.%u\", val / 40, val % 40);\n    if (w < 0) {\n        w = BUFFER_E;\n        goto exit;\n    }\n    outIdx += w;\n    val = 0;\n\n    while (inIdx < inSz && outIdx < outSz) {\n        /* extract the next OID digit from in to val */\n        /* first bit is used to set if value is coded on 1 or multiple bytes */\n        if (in[inIdx] & 0x80) {\n            val += in[inIdx] & 0x7F;\n            val *= 128;\n        }\n        else {\n            /* write val as text into out */\n            val += in[inIdx];\n            w = XSNPRINTF(out + outIdx, outSz - outIdx, \".%u\", val);\n            if (w < 0 || (word32)w > outSz - outIdx) {\n                w = BUFFER_E;\n                goto exit;\n            }\n            outIdx += w;\n            val = 0;\n        }\n        inIdx++;\n    }\n    if (outIdx == outSz)\n        outIdx--;\n    out[outIdx] = 0;\n\n    w = (int)outIdx;\n\nexit:\n    return w;\n}\n#endif /* WOLFSSL_CERT_EXT && !WOLFSSL_SEP */\n\n#if defined(WOLFSSL_SEP) || defined(WOLFSSL_CERT_EXT) || defined(WOLFSSL_QT)\n    /* Reference: https://tools.ietf.org/html/rfc5280#section-4.2.1.4 */\n    static int DecodeCertPolicy(const byte* input, int sz, DecodedCert* cert)\n    {\n        word32 idx = 0;\n        word32 oldIdx;\n        int ret;\n        int total_length = 0, policy_length = 0, length = 0;\n    #if !defined(WOLFSSL_SEP) && defined(WOLFSSL_CERT_EXT) && \\\n        !defined(WOLFSSL_DUP_CERTPOL)\n        int i;\n    #endif\n\n        WOLFSSL_ENTER(\"DecodeCertPolicy\");\n        #if defined(WOLFSSL_SEP) || defined(WOLFSSL_CERT_EXT)\n        /* Check if cert is null before dereferencing below */\n        if (cert == NULL)\n            return BAD_FUNC_ARG;\n        #endif\n\n    #if defined(WOLFSSL_CERT_EXT)\n         cert->extCertPoliciesNb = 0;\n    #endif\n\n        if (GetSequence(input, &idx, &total_length, sz) < 0) {\n            WOLFSSL_MSG(\"\\tGet CertPolicy total seq failed\");\n            return ASN_PARSE_E;\n        }\n\n        /* Validate total length */\n        if (total_length > (sz - (int)idx)) {\n            WOLFSSL_MSG(\"\\tCertPolicy length mismatch\");\n            return ASN_PARSE_E;\n        }\n\n        /* Unwrap certificatePolicies */\n        do {\n            if (GetSequence(input, &idx, &policy_length, sz) < 0) {\n                WOLFSSL_MSG(\"\\tGet CertPolicy seq failed\");\n                return ASN_PARSE_E;\n            }\n\n            oldIdx = idx;\n            ret = GetASNObjectId(input, &idx, &length, sz);\n            if (ret != 0)\n                return ret;\n            policy_length -= idx - oldIdx;\n\n            if (length > 0) {\n                /* Verify length won't overrun buffer */\n                if (length > (sz - (int)idx)) {\n                    WOLFSSL_MSG(\"\\tCertPolicy length exceeds input buffer\");\n                    return ASN_PARSE_E;\n                }\n\n        #if defined(WOLFSSL_SEP)\n                cert->deviceType = (byte*)XMALLOC(length, cert->heap,\n                                                         DYNAMIC_TYPE_X509_EXT);\n                if (cert->deviceType == NULL) {\n                    WOLFSSL_MSG(\"\\tCouldn't alloc memory for deviceType\");\n                    return MEMORY_E;\n                }\n                cert->deviceTypeSz = length;\n                XMEMCPY(cert->deviceType, input + idx, length);\n                break;\n        #elif defined(WOLFSSL_CERT_EXT)\n                /* decode cert policy */\n                if (DecodePolicyOID(cert->extCertPolicies[\n                                       cert->extCertPoliciesNb], MAX_CERTPOL_SZ,\n                                       input + idx, length) <= 0) {\n                    WOLFSSL_MSG(\"\\tCouldn't decode CertPolicy\");\n                    return ASN_PARSE_E;\n                }\n            #ifndef WOLFSSL_DUP_CERTPOL\n                /* From RFC 5280 section 4.2.1.3 \"A certificate policy OID MUST\n                 * NOT appear more than once in a certificate policies\n                 * extension\". This is a sanity check for duplicates.\n                 * extCertPolicies should only have OID values, additional\n                 * qualifiers need to be stored in a separate array. */\n                for (i = 0; i < cert->extCertPoliciesNb; i++) {\n                    if (XMEMCMP(cert->extCertPolicies[i],\n                            cert->extCertPolicies[cert->extCertPoliciesNb],\n                            MAX_CERTPOL_SZ) == 0) {\n                            WOLFSSL_MSG(\"Duplicate policy OIDs not allowed\");\n                            WOLFSSL_MSG(\"Use WOLFSSL_DUP_CERTPOL if wanted\");\n                            return CERTPOLICIES_E;\n                    }\n                }\n            #endif /* !WOLFSSL_DUP_CERTPOL */\n                cert->extCertPoliciesNb++;\n        #else\n                WOLFSSL_LEAVE(\"DecodeCertPolicy : unsupported mode\", 0);\n                return 0;\n        #endif\n            }\n            idx += policy_length;\n        } while((int)idx < total_length\n    #if defined(WOLFSSL_CERT_EXT)\n            && cert->extCertPoliciesNb < MAX_CERTPOL_NB\n    #endif\n        );\n\n        WOLFSSL_LEAVE(\"DecodeCertPolicy\", 0);\n        return 0;\n    }\n#endif /* WOLFSSL_SEP */\n\n/* Macro to check if bit is set, if not sets and return success.\n    Otherwise returns failure */\n/* Macro required here because bit-field operation */\n#ifndef WOLFSSL_NO_ASN_STRICT\n    #define VERIFY_AND_SET_OID(bit) \\\n        if (bit == 0) \\\n            bit = 1; \\\n        else \\\n            return ASN_OBJECT_ID_E;\n#else\n    /* With no strict defined, the verify is skipped */\n#define VERIFY_AND_SET_OID(bit) bit = 1;\n#endif\n\nstatic int DecodeCertExtensions(DecodedCert* cert)\n/*\n *  Processing the Certificate Extensions. This does not modify the current\n *  index. It is works starting with the recorded extensions pointer.\n */\n{\n    int ret = 0;\n    word32 idx = 0;\n    int sz = cert->extensionsSz;\n    const byte* input = cert->extensions;\n    int length;\n    word32 oid;\n    byte critical = 0;\n    byte criticalFail = 0;\n    byte tag = 0;\n\n    WOLFSSL_ENTER(\"DecodeCertExtensions\");\n\n    if (input == NULL || sz == 0)\n        return BAD_FUNC_ARG;\n\n#ifdef WOLFSSL_CERT_REQ\n    if (!cert->isCSR)\n#endif\n    { /* Not included in CSR */\n        if (GetASNTag(input, &idx, &tag, sz) < 0) {\n            return ASN_PARSE_E;\n        }\n\n        if (tag != ASN_EXTENSIONS) {\n            WOLFSSL_MSG(\"\\tfail: should be an EXTENSIONS\");\n            return ASN_PARSE_E;\n        }\n\n        if (GetLength(input, &idx, &length, sz) < 0) {\n            WOLFSSL_MSG(\"\\tfail: invalid length\");\n            return ASN_PARSE_E;\n        }\n    }\n\n    if (GetSequence(input, &idx, &length, sz) < 0) {\n        WOLFSSL_MSG(\"\\tfail: should be a SEQUENCE (1)\");\n        return ASN_PARSE_E;\n    }\n\n    while (idx < (word32)sz) {\n        word32 localIdx;\n\n        if (GetSequence(input, &idx, &length, sz) < 0) {\n            WOLFSSL_MSG(\"\\tfail: should be a SEQUENCE\");\n            return ASN_PARSE_E;\n        }\n\n        oid = 0;\n        if ((ret = GetObjectId(input, &idx, &oid, oidCertExtType, sz)) < 0) {\n            WOLFSSL_MSG(\"\\tfail: OBJECT ID\");\n            return ret;\n        }\n\n        /* check for critical flag */\n        critical = 0;\n        if ((idx + 1) > (word32)sz) {\n            WOLFSSL_MSG(\"\\tfail: malformed buffer\");\n            return BUFFER_E;\n        }\n\n        localIdx = idx;\n        if (GetASNTag(input, &localIdx, &tag, sz) == 0) {\n            if (tag == ASN_BOOLEAN) {\n                ret = GetBoolean(input, &idx, sz);\n                if (ret < 0) {\n                    WOLFSSL_MSG(\"\\tfail: critical boolean\");\n                    return ret;\n                }\n\n                critical = (byte)ret;\n            }\n        }\n\n        /* process the extension based on the OID */\n        ret = GetOctetString(input, &idx, &length, sz);\n        if (ret < 0) {\n            WOLFSSL_MSG(\"\\tfail: bad OCTET STRING\");\n            return ret;\n        }\n\n        switch (oid) {\n            case BASIC_CA_OID:\n                VERIFY_AND_SET_OID(cert->extBasicConstSet);\n                #if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)\n                    cert->extBasicConstCrit = critical;\n                #endif\n                if (DecodeBasicCaConstraint(&input[idx], length, cert) < 0)\n                    return ASN_PARSE_E;\n                break;\n\n            case CRL_DIST_OID:\n                VERIFY_AND_SET_OID(cert->extCRLdistSet);\n                #if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)\n                    cert->extCRLdistCrit = critical;\n                #endif\n                if (DecodeCrlDist(&input[idx], length, cert) < 0)\n                    return ASN_PARSE_E;\n                break;\n\n            case AUTH_INFO_OID:\n                VERIFY_AND_SET_OID(cert->extAuthInfoSet);\n                #if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)\n                    cert->extAuthInfoCrit = critical;\n                #endif\n                if (DecodeAuthInfo(&input[idx], length, cert) < 0)\n                    return ASN_PARSE_E;\n                break;\n\n            case ALT_NAMES_OID:\n                VERIFY_AND_SET_OID(cert->extSubjAltNameSet);\n                #if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)\n                    cert->extSubjAltNameCrit = critical;\n                #endif\n                ret = DecodeAltNames(&input[idx], length, cert);\n                if (ret < 0)\n                    return ret;\n                break;\n\n            case AUTH_KEY_OID:\n                VERIFY_AND_SET_OID(cert->extAuthKeyIdSet);\n                #if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)\n                    cert->extAuthKeyIdCrit = critical;\n                #endif\n                #ifndef WOLFSSL_ALLOW_CRIT_SKID\n                    /* This check is added due to RFC 5280 section 4.2.1.1\n                     * stating that conforming CA's must mark this extension\n                     * as non-critical. When parsing extensions check that\n                     * certificate was made in compliance with this. */\n                    if (critical) {\n                        WOLFSSL_MSG(\"Critical Auth Key ID is not allowed\");\n                        WOLFSSL_MSG(\"Use macro WOLFSSL_ALLOW_CRIT_SKID if wanted\");\n                        return ASN_CRIT_EXT_E;\n                    }\n                #endif\n                if (DecodeAuthKeyId(&input[idx], length, cert) < 0)\n                    return ASN_PARSE_E;\n                break;\n\n            case SUBJ_KEY_OID:\n                VERIFY_AND_SET_OID(cert->extSubjKeyIdSet);\n                #if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)\n                    cert->extSubjKeyIdCrit = critical;\n                #endif\n                #ifndef WOLFSSL_ALLOW_CRIT_SKID\n                    /* This check is added due to RFC 5280 section 4.2.1.2\n                     * stating that conforming CA's must mark this extension\n                     * as non-critical. When parsing extensions check that\n                     * certificate was made in compliance with this. */\n                    if (critical) {\n                        WOLFSSL_MSG(\"Critical Subject Key ID is not allowed\");\n                        WOLFSSL_MSG(\"Use macro WOLFSSL_ALLOW_CRIT_SKID if wanted\");\n                        return ASN_CRIT_EXT_E;\n                    }\n                #endif\n\n                if (DecodeSubjKeyId(&input[idx], length, cert) < 0)\n                    return ASN_PARSE_E;\n                break;\n\n            case CERT_POLICY_OID:\n                #if defined(WOLFSSL_SEP) || defined(WOLFSSL_QT)\n                    VERIFY_AND_SET_OID(cert->extCertPolicySet);\n                    #if defined(OPENSSL_EXTRA) || \\\n                        defined(OPENSSL_EXTRA_X509_SMALL)\n                        cert->extCertPolicyCrit = critical;\n                    #endif\n                #endif\n                #if defined(WOLFSSL_SEP) || defined(WOLFSSL_CERT_EXT) || \\\n                    defined(WOLFSSL_QT)\n                    if (DecodeCertPolicy(&input[idx], length, cert) < 0) {\n                        return ASN_PARSE_E;\n                    }\n                #else\n                    WOLFSSL_MSG(\"Certificate Policy extension not supported yet.\");\n                #endif\n                break;\n\n            case KEY_USAGE_OID:\n                VERIFY_AND_SET_OID(cert->extKeyUsageSet);\n                #if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)\n                    cert->extKeyUsageCrit = critical;\n                #endif\n                if (DecodeKeyUsage(&input[idx], length, cert) < 0)\n                    return ASN_PARSE_E;\n                break;\n\n            case EXT_KEY_USAGE_OID:\n                VERIFY_AND_SET_OID(cert->extExtKeyUsageSet);\n                #if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)\n                    cert->extExtKeyUsageCrit = critical;\n                #endif\n                if (DecodeExtKeyUsage(&input[idx], length, cert) < 0)\n                    return ASN_PARSE_E;\n                break;\n\n            #ifndef IGNORE_NAME_CONSTRAINTS\n            case NAME_CONS_OID:\n            #ifndef WOLFSSL_NO_ASN_STRICT\n                /* Verify RFC 5280 Sec 4.2.1.10 rule:\n                    \"The name constraints extension,\n                    which MUST be used only in a CA certificate\" */\n                if (!cert->isCA) {\n                    WOLFSSL_MSG(\"Name constraints allowed only for CA certs\");\n                    return ASN_NAME_INVALID_E;\n                }\n            #endif\n                VERIFY_AND_SET_OID(cert->extNameConstraintSet);\n                #if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)\n                    cert->extNameConstraintCrit = critical;\n                #endif\n                if (DecodeNameConstraints(&input[idx], length, cert) < 0)\n                    return ASN_PARSE_E;\n                break;\n            #endif /* IGNORE_NAME_CONSTRAINTS */\n\n            case INHIBIT_ANY_OID:\n                VERIFY_AND_SET_OID(cert->inhibitAnyOidSet);\n                WOLFSSL_MSG(\"Inhibit anyPolicy extension not supported yet.\");\n                break;\n\n       #ifndef IGNORE_NETSCAPE_CERT_TYPE\n            case NETSCAPE_CT_OID:\n                WOLFSSL_MSG(\"Netscape certificate type extension not supported \"\n                            \"yet.\");\n                if (CheckBitString(input, &idx, &length, idx + length, 0,\n                                                                    NULL) < 0) {\n                    return ASN_PARSE_E;\n                }\n                break;\n        #endif\n        #ifdef HAVE_OCSP\n            case OCSP_NOCHECK_OID:\n                VERIFY_AND_SET_OID(cert->ocspNoCheckSet);\n                ret = GetASNNull(input, &idx, sz);\n                length = 0; /* idx is already incremented, reset length to 0 */\n                if (ret != 0)\n                    return ASN_PARSE_E;\n                break;\n        #endif\n            case POLICY_CONST_OID:\n                VERIFY_AND_SET_OID(cert->extPolicyConstSet);\n                #if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)\n                    cert->extPolicyConstCrit = critical;\n                #endif\n                if (DecodePolicyConstraints(&input[idx], length, cert) < 0)\n                    return ASN_PARSE_E;\n                break;\n            default:\n            #ifndef WOLFSSL_NO_ASN_STRICT\n                /* While it is a failure to not support critical extensions,\n                 * still parse the certificate ignoring the unsupported\n                 * extension to allow caller to accept it with the verify\n                 * callback. */\n                if (critical)\n                    criticalFail = 1;\n            #endif\n            break;\n        }\n        idx += length;\n    }\n\n    return criticalFail ? ASN_CRIT_EXT_E : 0;\n}\n\nint ParseCert(DecodedCert* cert, int type, int verify, void* cm)\n{\n    int   ret;\n    char* ptr;\n\n    ret = ParseCertRelative(cert, type, verify, cm);\n    if (ret < 0)\n        return ret;\n\n    if (cert->subjectCNLen > 0) {\n        ptr = (char*) XMALLOC(cert->subjectCNLen + 1, cert->heap,\n                              DYNAMIC_TYPE_SUBJECT_CN);\n        if (ptr == NULL)\n            return MEMORY_E;\n        XMEMCPY(ptr, cert->subjectCN, cert->subjectCNLen);\n        ptr[cert->subjectCNLen] = '\\0';\n        cert->subjectCN = ptr;\n        cert->subjectCNStored = 1;\n    }\n\n    if (cert->keyOID == RSAk &&\n                          cert->publicKey != NULL  && cert->pubKeySize > 0) {\n        ptr = (char*) XMALLOC(cert->pubKeySize, cert->heap,\n                              DYNAMIC_TYPE_PUBLIC_KEY);\n        if (ptr == NULL)\n            return MEMORY_E;\n        XMEMCPY(ptr, cert->publicKey, cert->pubKeySize);\n        cert->publicKey = (byte *)ptr;\n        cert->pubKeyStored = 1;\n    }\n\n    return ret;\n}\n\n/* from SSL proper, for locking can't do find here anymore */\n#ifdef __cplusplus\n    extern \"C\" {\n#endif\n    Signer* GetCA(void* signers, byte* hash);\n    #ifndef NO_SKID\n        Signer* GetCAByName(void* signers, byte* hash);\n    #endif\n#ifdef __cplusplus\n    }\n#endif\n\n#if defined(WOLFCRYPT_ONLY) || defined(NO_CERTS)\n\n/* dummy functions, not using wolfSSL so don't need actual ones */\nSigner* GetCA(void* signers, byte* hash)\n{\n    (void)hash;\n\n    return (Signer*)signers;\n}\n\n#ifndef NO_SKID\nSigner* GetCAByName(void* signers, byte* hash)\n{\n    (void)hash;\n\n    return (Signer*)signers;\n}\n#endif /* NO_SKID */\n\n#endif /* WOLFCRYPT_ONLY || NO_CERTS */\n\n#if defined(WOLFSSL_NO_TRUSTED_CERTS_VERIFY) && !defined(NO_SKID)\nstatic Signer* GetCABySubjectAndPubKey(DecodedCert* cert, void* cm)\n{\n    Signer* ca = NULL;\n    if (cert->extSubjKeyIdSet)\n        ca = GetCA(cm, cert->extSubjKeyId);\n    if (ca == NULL)\n        ca = GetCAByName(cm, cert->subjectHash);\n    if (ca) {\n        if ((ca->pubKeySize == cert->pubKeySize) &&\n               (XMEMCMP(ca->publicKey, cert->publicKey, ca->pubKeySize) == 0)) {\n            return ca;\n        }\n    }\n    return NULL;\n}\n#endif\n\n#if defined(WOLFSSL_SMALL_CERT_VERIFY) || defined(OPENSSL_EXTRA)\n/* Only quick step through the certificate to find fields that are then used\n * in certificate signature verification.\n * Must use the signature OID from the signed part of the certificate.\n * Works also on certificate signing requests.\n *\n * This is only for minimizing dynamic memory usage during TLS certificate\n * chain processing.\n * Doesn't support:\n *   OCSP Only: alt lookup using subject and pub key w/o sig check\n */\nstatic int CheckCertSignature_ex(const byte* cert, word32 certSz, void* heap,\n        void* cm, const byte* pubKey, word32 pubKeySz, int pubKeyOID, int req)\n{\n#ifndef WOLFSSL_SMALL_STACK\n    SignatureCtx  sigCtx[1];\n#else\n    SignatureCtx* sigCtx;\n#endif\n    byte          hash[KEYID_SIZE];\n    Signer*       ca = NULL;\n    word32        idx = 0;\n    int           len;\n    word32        tbsCertIdx = 0;\n    word32        sigIndex   = 0;\n    word32        signatureOID = 0;\n    word32        oid = 0;\n    word32        issuerIdx = 0;\n    word32        issuerSz  = 0;\n#ifndef NO_SKID\n    int           extLen = 0;\n    word32        extIdx = 0;\n    word32        extEndIdx = 0;\n    int           extAuthKeyIdSet = 0;\n#endif\n    int           ret = 0;\n    word32        localIdx;\n    byte          tag;\n\n\n    if (cert == NULL) {\n        return BAD_FUNC_ARG;\n    }\n\n#ifdef WOLFSSL_SMALL_STACK\n    sigCtx = (SignatureCtx*)XMALLOC(sizeof(*sigCtx), heap, DYNAMIC_TYPE_SIGNATURE);\n    if (sigCtx == NULL)\n        return MEMORY_E;\n#endif\n    InitSignatureCtx(sigCtx, heap, INVALID_DEVID);\n\n    /* Certificate SEQUENCE */\n    if (GetSequence(cert, &idx, &len, certSz) < 0)\n        ret = ASN_PARSE_E;\n    if (ret == 0) {\n        tbsCertIdx = idx;\n\n        /* TBSCertificate SEQUENCE */\n        if (GetSequence(cert, &idx, &len, certSz) < 0)\n            ret = ASN_PARSE_E;\n    }\n    if (ret == 0) {\n        sigIndex = len + idx;\n\n        if ((idx + 1) > certSz)\n            ret = BUFFER_E;\n    }\n    if (ret == 0) {\n        /* version - optional */\n        localIdx = idx;\n        if (GetASNTag(cert, &localIdx, &tag, certSz) == 0) {\n            if (tag == (ASN_CONTEXT_SPECIFIC | ASN_CONSTRUCTED)) {\n                idx++;\n                if (GetLength(cert, &idx, &len, certSz) < 0)\n                    ret = ASN_PARSE_E;\n                idx += len;\n            }\n        }\n    }\n\n    if (ret == 0) {\n        /* serialNumber */\n        if (GetASNHeader(cert, ASN_INTEGER, &idx, &len, certSz) < 0)\n            ret = ASN_PARSE_E;\n    }\n    if (ret == 0) {\n        idx += len;\n\n        /* signature */\n        if (!req &&\n                GetAlgoId(cert, &idx, &signatureOID, oidSigType, certSz) < 0)\n            ret = ASN_PARSE_E;\n    }\n\n    if (ret == 0) {\n        issuerIdx = idx;\n        /* issuer for cert or subject for csr */\n        if (GetSequence(cert, &idx, &len, certSz) < 0)\n            ret = ASN_PARSE_E;\n    }\n    if (ret == 0) {\n        issuerSz = len + idx - issuerIdx;\n    }\n#ifndef NO_SKID\n    if (!req && ret == 0) {\n        idx += len;\n\n        /* validity */\n        if (GetSequence(cert, &idx, &len, certSz) < 0)\n            ret = ASN_PARSE_E;\n    }\n    if (!req && ret == 0) {\n        idx += len;\n\n        /* subject */\n        if (GetSequence(cert, &idx, &len, certSz) < 0)\n            ret = ASN_PARSE_E;\n    }\n    if (ret == 0) {\n        idx += len;\n\n        /* subjectPublicKeyInfo */\n        if (GetSequence(cert, &idx, &len, certSz) < 0)\n            ret = ASN_PARSE_E;\n    }\n    if (req && ret == 0) {\n        idx += len;\n\n        /* attributes */\n        if (GetASNHeader_ex(cert,\n                ASN_CONTEXT_SPECIFIC | ASN_CONSTRUCTED, &idx,\n                &len, certSz, 1) < 0)\n            ret = ASN_PARSE_E;\n    }\n    if (!req) {\n        if (ret == 0) {\n            idx += len;\n\n            if ((idx + 1) > certSz)\n                ret = BUFFER_E;\n        }\n        if (ret == 0) {\n            /* issuerUniqueID - optional */\n            localIdx = idx;\n            if (GetASNTag(cert, &localIdx, &tag, certSz) == 0) {\n                if (tag == (ASN_CONTEXT_SPECIFIC | ASN_CONSTRUCTED | 1)) {\n                    idx++;\n                    if (GetLength(cert, &idx, &len, certSz) < 0)\n                        ret = ASN_PARSE_E;\n                    idx += len;\n                }\n            }\n        }\n        if (ret == 0) {\n            if ((idx + 1) > certSz)\n                ret = BUFFER_E;\n        }\n        if (ret == 0) {\n            /* subjectUniqueID - optional */\n            localIdx = idx;\n            if (GetASNTag(cert, &localIdx, &tag, certSz) == 0) {\n                if (tag == (ASN_CONTEXT_SPECIFIC | ASN_CONSTRUCTED | 2)) {\n                    idx++;\n                    if (GetLength(cert, &idx, &len, certSz) < 0)\n                        ret = ASN_PARSE_E;\n                    idx += len;\n                }\n            }\n        }\n\n        if (ret == 0) {\n            if ((idx + 1) > certSz)\n                ret = BUFFER_E;\n        }\n        /* extensions - optional */\n        localIdx = idx;\n        if (ret == 0 && GetASNTag(cert, &localIdx, &tag, certSz) == 0 &&\n                tag == (ASN_CONTEXT_SPECIFIC | ASN_CONSTRUCTED | 3)) {\n            idx++;\n            if (GetLength(cert, &idx, &extLen, certSz) < 0)\n                ret = ASN_PARSE_E;\n            if (ret == 0) {\n                if (GetSequence(cert, &idx, &extLen, certSz) < 0)\n                    ret = ASN_PARSE_E;\n            }\n            if (ret == 0) {\n                extEndIdx = idx + extLen;\n\n                /* Check each extension for the ones we want. */\n                while (ret == 0 && idx < extEndIdx) {\n                    if (GetSequence(cert, &idx, &len, certSz) < 0)\n                        ret = ASN_PARSE_E;\n                    if (ret == 0) {\n                        extIdx = idx;\n                        if (GetObjectId(cert, &extIdx, &oid, oidCertExtType,\n                                                                      certSz) < 0) {\n                            ret = ASN_PARSE_E;\n                        }\n\n                        if (ret == 0) {\n                            if ((extIdx + 1) > certSz)\n                                ret = BUFFER_E;\n                        }\n                    }\n\n                    if (ret == 0) {\n                        localIdx = extIdx;\n                        if (GetASNTag(cert, &localIdx, &tag, certSz) == 0 &&\n                                tag == ASN_BOOLEAN) {\n                            if (GetBoolean(cert, &extIdx, certSz) < 0)\n                                ret = ASN_PARSE_E;\n                        }\n                    }\n                    if (ret == 0) {\n                        if (GetOctetString(cert, &extIdx, &extLen, certSz) < 0)\n                            ret = ASN_PARSE_E;\n                    }\n\n                    if (ret == 0) {\n                        switch (oid) {\n                        case AUTH_KEY_OID:\n                            if (GetSequence(cert, &extIdx, &extLen, certSz) < 0)\n                                ret = ASN_PARSE_E;\n\n                            if (ret == 0 && (extIdx + 1) >= certSz)\n                                ret = BUFFER_E;\n\n                            if (ret == 0 &&\n                                    GetASNTag(cert, &extIdx, &tag, certSz) == 0 &&\n                                    tag == (ASN_CONTEXT_SPECIFIC | 0)) {\n                                if (GetLength(cert, &extIdx, &extLen, certSz) <= 0)\n                                    ret = ASN_PARSE_E;\n                                if (ret == 0) {\n                                    extAuthKeyIdSet = 1;\n                                    if (extLen == KEYID_SIZE)\n                                        XMEMCPY(hash, cert + extIdx, extLen);\n                                    else {\n                                        ret = CalcHashId(cert + extIdx, extLen,\n                                                                              hash);\n                                    }\n                                }\n                            }\n                            break;\n\n                        default:\n                            break;\n                        }\n                    }\n                    idx += len;\n                }\n            }\n        }\n    }\n    else if (ret == 0) {\n        idx += len;\n    }\n\n    if (ret == 0 && pubKey == NULL) {\n        if (extAuthKeyIdSet)\n            ca = GetCA(cm, hash);\n        if (ca == NULL) {\n            ret = CalcHashId(cert + issuerIdx, issuerSz, hash);\n            if (ret == 0)\n                ca = GetCAByName(cm, hash);\n        }\n    }\n#else\n    if (ret == 0 && pubKey == NULL) {\n        ret = CalcHashId(cert + issuerIdx, issuerSz, hash);\n        if (ret == 0)\n            ca = GetCA(cm, hash);\n    }\n#endif /* !NO_SKID */\n    if (ca == NULL && pubKey == NULL)\n        ret = ASN_NO_SIGNER_E;\n\n    if (ret == 0) {\n        idx = sigIndex;\n        /* signatureAlgorithm */\n        if (GetAlgoId(cert, &idx, &oid, oidSigType, certSz) < 0)\n            ret = ASN_PARSE_E;\n        /* In CSR signature data is not present in body */\n        if (req)\n            signatureOID = oid;\n    }\n    if (ret == 0) {\n        if (oid != signatureOID)\n            ret = ASN_SIG_OID_E;\n    }\n    if (ret == 0) {\n        /* signatureValue */\n        if (CheckBitString(cert, &idx, &len, certSz, 1, NULL) < 0)\n            ret = ASN_PARSE_E;\n    }\n\n    if (ret == 0) {\n        if (pubKey != NULL) {\n            ret = ConfirmSignature(sigCtx, cert + tbsCertIdx,\n                               sigIndex - tbsCertIdx,\n                               pubKey, pubKeySz, pubKeyOID,\n                               cert + idx, len, signatureOID, NULL);\n        }\n        else {\n            ret = ConfirmSignature(sigCtx, cert + tbsCertIdx,\n                               sigIndex - tbsCertIdx,\n                               ca->publicKey, ca->pubKeySize, ca->keyOID,\n                               cert + idx, len, signatureOID, NULL);\n        }\n        if (ret != 0) {\n            WOLFSSL_MSG(\"Confirm signature failed\");\n        }\n    }\n\n    FreeSignatureCtx(sigCtx);\n#ifdef WOLFSSL_SMALL_STACK\n    if (sigCtx != NULL)\n        XFREE(sigCtx, heap, DYNAMIC_TYPE_SIGNATURE);\n#endif\n    return ret;\n}\n\n#ifdef OPENSSL_EXTRA\n/* Call CheckCertSignature_ex using a public key buffer for verification\n */\nint CheckCertSignaturePubKey(const byte* cert, word32 certSz, void* heap,\n        const byte* pubKey, word32 pubKeySz, int pubKeyOID)\n{\n    return CheckCertSignature_ex(cert, certSz, heap, NULL,\n            pubKey, pubKeySz, pubKeyOID, 0);\n}\n#ifdef WOLFSSL_CERT_REQ\nint CheckCSRSignaturePubKey(const byte* cert, word32 certSz, void* heap,\n        const byte* pubKey, word32 pubKeySz, int pubKeyOID)\n{\n    return CheckCertSignature_ex(cert, certSz, heap, NULL,\n            pubKey, pubKeySz, pubKeyOID, 1);\n}\n#endif /* WOLFSSL_CERT_REQ */\n#endif /* OPENSSL_EXTRA */\n#ifdef WOLFSSL_SMALL_CERT_VERIFY\n/* Call CheckCertSignature_ex using a certificate manager (cm)\n */\nint CheckCertSignature(const byte* cert, word32 certSz, void* heap, void* cm)\n{\n    return CheckCertSignature_ex(cert, certSz, heap, cm, NULL, 0, 0, 0);\n}\n#endif /* WOLFSSL_SMALL_CERT_VERIFY */\n#endif /* WOLFSSL_SMALL_CERT_VERIFY || OPENSSL_EXTRA */\n\nint ParseCertRelative(DecodedCert* cert, int type, int verify, void* cm)\n{\n    int    ret = 0;\n    int    checkPathLen = 0;\n    int    decrementMaxPathLen = 0;\n    word32 confirmOID = 0;\n#if defined(WOLFSSL_RENESAS_TSIP)\n    int    idx = 0;\n#endif\n    byte*  tsip_encRsaKeyIdx;\n#ifdef WOLFSSL_CERT_REQ\n    int    len = 0;\n#endif\n\n    if (cert == NULL) {\n        return BAD_FUNC_ARG;\n    }\n\n#ifdef WOLFSSL_CERT_REQ\n    if (type == CERTREQ_TYPE)\n        cert->isCSR = 1;\n#endif\n\n    if (cert->sigCtx.state == SIG_STATE_BEGIN) {\n        cert->badDate = 0;\n        cert->criticalExt = 0;\n        if ((ret = DecodeToKey(cert, verify)) < 0) {\n            if (ret == ASN_BEFORE_DATE_E || ret == ASN_AFTER_DATE_E)\n                cert->badDate = ret;\n            else\n                return ret;\n        }\n\n        WOLFSSL_MSG(\"Parsed Past Key\");\n\n\n#ifdef WOLFSSL_CERT_REQ\n        /* Read attributes */\n        if (cert->isCSR) {\n            if (GetASNHeader_ex(cert->source,\n                    ASN_CONTEXT_SPECIFIC | ASN_CONSTRUCTED, &cert->srcIdx,\n                    &len, cert->maxIdx, 1) < 0) {\n                WOLFSSL_MSG(\"GetASNHeader_ex error\");\n                return ASN_PARSE_E;\n            }\n\n            if (len) {\n                word32 attrMaxIdx = cert->srcIdx + len;\n                word32 oid;\n                byte   tag;\n\n                if (attrMaxIdx > cert->maxIdx) {\n                    WOLFSSL_MSG(\"Attribute length greater than CSR length\");\n                    return ASN_PARSE_E;\n                }\n\n                while (cert->srcIdx < attrMaxIdx) {\n                    /* Attributes have the structure:\n                     * SEQ -> OID -> SET -> ATTRIBUTE */\n                    if (GetSequence(cert->source, &cert->srcIdx, &len,\n                            attrMaxIdx) < 0) {\n                        WOLFSSL_MSG(\"attr GetSequence error\");\n                        return ASN_PARSE_E;\n                    }\n                    if (GetObjectId(cert->source, &cert->srcIdx, &oid,\n                            oidCsrAttrType, attrMaxIdx) < 0) {\n                        WOLFSSL_MSG(\"attr GetObjectId error\");\n                        return ASN_PARSE_E;\n                    }\n                    if (GetSet(cert->source, &cert->srcIdx, &len,\n                            attrMaxIdx) < 0) {\n                        WOLFSSL_MSG(\"attr GetSet error\");\n                        return ASN_PARSE_E;\n                    }\n                    switch (oid) {\n                    case CHALLENGE_PASSWORD_OID:\n                        if (GetHeader(cert->source, &tag,\n                                &cert->srcIdx, &len, attrMaxIdx, 1) < 0) {\n                            WOLFSSL_MSG(\"attr GetHeader error\");\n                            return ASN_PARSE_E;\n                        }\n                        if (tag != ASN_PRINTABLE_STRING && tag != ASN_UTF8STRING &&\n                                tag != ASN_IA5_STRING) {\n                            WOLFSSL_MSG(\"Unsupported attribute value format\");\n                            return ASN_PARSE_E;\n                        }\n                        cert->cPwd = (char*)cert->source + cert->srcIdx;\n                        cert->cPwdLen = len;\n                        cert->srcIdx += len;\n                        break;\n                    case SERIAL_NUMBER_OID:\n                        if (GetHeader(cert->source, &tag,\n                                &cert->srcIdx, &len, attrMaxIdx, 1) < 0) {\n                            WOLFSSL_MSG(\"attr GetHeader error\");\n                            return ASN_PARSE_E;\n                        }\n                        if (tag != ASN_PRINTABLE_STRING && tag != ASN_UTF8STRING &&\n                                tag != ASN_IA5_STRING) {\n                            WOLFSSL_MSG(\"Unsupported attribute value format\");\n                            return ASN_PARSE_E;\n                        }\n                        cert->sNum = (char*)cert->source + cert->srcIdx;\n                        cert->sNumLen = len;\n                        cert->srcIdx += len;\n                        if (cert->sNumLen <= EXTERNAL_SERIAL_SIZE) {\n                            XMEMCPY(cert->serial, cert->sNum, cert->sNumLen);\n                            cert->serialSz = cert->sNumLen;\n                        }\n                        break;\n                    case EXTENSION_REQUEST_OID:\n                        /* save extensions */\n                        cert->extensions    = &cert->source[cert->srcIdx];\n                        cert->extensionsSz  = len;\n                        cert->extensionsIdx = cert->srcIdx;   /* for potential later use */\n\n                        if ((ret = DecodeCertExtensions(cert)) < 0) {\n                            if (ret == ASN_CRIT_EXT_E)\n                                cert->criticalExt = ret;\n                            else\n                                return ret;\n                        }\n                        cert->srcIdx += len;\n                        break;\n                    default:\n                        WOLFSSL_MSG(\"Unsupported attribute type\");\n                        return ASN_PARSE_E;\n                    }\n                }\n            }\n        }\n#endif\n\n        if (cert->srcIdx < cert->sigIndex) {\n        #ifndef ALLOW_V1_EXTENSIONS\n            if (cert->version < 2) {\n                WOLFSSL_MSG(\"\\tv1 and v2 certs not allowed extensions\");\n                return ASN_VERSION_E;\n            }\n        #endif\n\n            /* save extensions */\n            cert->extensions    = &cert->source[cert->srcIdx];\n            cert->extensionsSz  = cert->sigIndex - cert->srcIdx;\n            cert->extensionsIdx = cert->srcIdx;   /* for potential later use */\n\n            if ((ret = DecodeCertExtensions(cert)) < 0) {\n                if (ret == ASN_CRIT_EXT_E)\n                    cert->criticalExt = ret;\n                else\n                    return ret;\n            }\n\n        #ifdef HAVE_OCSP\n            if (verify == VERIFY_OCSP_CERT) {\n                /* trust for the lifetime of the responder's cert*/\n                if (cert->ocspNoCheckSet)\n                    verify = VERIFY;\n                else\n                    verify = VERIFY_OCSP;\n            }\n        #endif\n            /* advance past extensions */\n            cert->srcIdx = cert->sigIndex;\n        }\n\n        if ((ret = GetAlgoId(cert->source, &cert->srcIdx,\n#ifdef WOLFSSL_CERT_REQ\n                !cert->isCSR ? &confirmOID : &cert->signatureOID,\n#else\n                &confirmOID,\n#endif\n                oidSigType, cert->maxIdx)) < 0)\n            return ret;\n\n        if ((ret = GetSignature(cert)) < 0)\n            return ret;\n\n        if (confirmOID != cert->signatureOID\n#ifdef WOLFSSL_CERT_REQ\n                && !cert->isCSR\n#endif\n                )\n            return ASN_SIG_OID_E;\n\n    #ifndef NO_SKID\n        if (cert->extSubjKeyIdSet == 0 && cert->publicKey != NULL &&\n                                                         cert->pubKeySize > 0) {\n            ret = CalcHashId(cert->publicKey, cert->pubKeySize,\n                                                            cert->extSubjKeyId);\n            if (ret != 0)\n                return ret;\n        }\n    #endif /* !NO_SKID */\n\n        if (!cert->selfSigned || (verify != NO_VERIFY && type != CA_TYPE &&\n                                                   type != TRUSTED_PEER_TYPE)) {\n            cert->ca = NULL;\n    #ifndef NO_SKID\n            if (cert->extAuthKeyIdSet) {\n                cert->ca = GetCA(cm, cert->extAuthKeyId);\n            }\n            if (cert->ca == NULL && cert->extSubjKeyIdSet\n                                 && verify != VERIFY_OCSP) {\n                cert->ca = GetCA(cm, cert->extSubjKeyId);\n            }\n            if (cert->ca != NULL && XMEMCMP(cert->issuerHash,\n                                  cert->ca->subjectNameHash, KEYID_SIZE) != 0) {\n                cert->ca = NULL;\n            }\n            if (cert->ca == NULL) {\n                cert->ca = GetCAByName(cm, cert->issuerHash);\n                /* If AKID is available then this CA doesn't have the public\n                 * key required */\n                if (cert->ca && cert->extAuthKeyIdSet) {\n                    WOLFSSL_MSG(\"CA SKID doesn't match AKID\");\n                    cert->ca = NULL;\n                }\n            }\n\n            /* OCSP Only: alt lookup using subject and pub key w/o sig check */\n        #ifdef WOLFSSL_NO_TRUSTED_CERTS_VERIFY\n            if (cert->ca == NULL && verify == VERIFY_OCSP) {\n                cert->ca = GetCABySubjectAndPubKey(cert, cm);\n                if (cert->ca) {\n                    ret = 0; /* success */\n                    goto exit_pcr;\n                }\n            }\n        #endif /* WOLFSSL_NO_TRUSTED_CERTS_VERIFY */\n    #else\n            cert->ca = GetCA(cm, cert->issuerHash);\n    #endif /* !NO_SKID */\n\n            if (cert->ca) {\n                WOLFSSL_MSG(\"CA found\");\n            }\n        }\n\n        if (cert->selfSigned) {\n            cert->maxPathLen = WOLFSSL_MAX_PATH_LEN;\n        } else {\n            /* RFC 5280 Section 4.2.1.9:\n             *\n             * load/receive check\n             *\n             * 1) Is CA boolean set?\n             *      No  - SKIP CHECK\n             *      Yes - Check key usage\n             * 2) Is Key usage extension present?\n             *      No  - goto 3\n             *      Yes - check keyCertSign assertion\n             *     2.a) Is keyCertSign asserted?\n             *          No  - goto 4\n             *          Yes - goto 3\n             * 3) Is pathLen set?\n             *      No  - goto 4\n             *      Yes - check pathLen against maxPathLen.\n             *      3.a) Is pathLen less than maxPathLen?\n             *           No - goto 4\n             *           Yes - set maxPathLen to pathLen and EXIT\n             * 4) Is maxPathLen > 0?\n             *      Yes - Reduce by 1\n             *      No  - ERROR\n             */\n\n            if (cert->ca && cert->pathLengthSet) {\n                cert->maxPathLen = cert->pathLength;\n                if (cert->isCA) {\n                    WOLFSSL_MSG(\"\\tCA boolean set\");\n                    if (cert->extKeyUsageSet) {\n                         WOLFSSL_MSG(\"\\tExtension Key Usage Set\");\n                         if ((cert->extKeyUsage & KEYUSE_KEY_CERT_SIGN) != 0) {\n                            checkPathLen = 1;\n                         } else {\n                            decrementMaxPathLen = 1;\n                         }\n                    } else {\n                        checkPathLen = 1;\n                    } /* !cert->ca check */\n                } /* cert is not a CA (assuming entity cert) */\n\n                if (checkPathLen && cert->pathLengthSet) {\n                    if (cert->pathLength < cert->ca->maxPathLen) {\n                        WOLFSSL_MSG(\"\\tmaxPathLen status: set to pathLength\");\n                        cert->maxPathLen = cert->pathLength;\n                    } else {\n                        decrementMaxPathLen = 1;\n                    }\n                }\n\n                if (decrementMaxPathLen && cert->ca->maxPathLen > 0) {\n                    WOLFSSL_MSG(\"\\tmaxPathLen status: reduce by 1\");\n                    cert->maxPathLen = cert->ca->maxPathLen - 1;\n                    if (verify != NO_VERIFY && type != CA_TYPE &&\n                                                    type != TRUSTED_PEER_TYPE) {\n                        WOLFSSL_MSG(\"\\tmaxPathLen status: OK\");\n                    }\n                } else if (decrementMaxPathLen && cert->ca->maxPathLen == 0) {\n                    cert->maxPathLen = 0;\n                    if (verify != NO_VERIFY && type != CA_TYPE &&\n                                                    type != TRUSTED_PEER_TYPE) {\n                        WOLFSSL_MSG(\"\\tNon-entity cert, maxPathLen is 0\");\n                        WOLFSSL_MSG(\"\\tmaxPathLen status: ERROR\");\n                        return ASN_PATHLEN_INV_E;\n                    }\n                }\n            } else if (cert->ca && cert->isCA) {\n                /* case where cert->pathLength extension is not set */\n                if (cert->ca->maxPathLen > 0) {\n                    cert->maxPathLen = cert->ca->maxPathLen - 1;\n                } else {\n                    cert->maxPathLen = 0;\n                    if (verify != NO_VERIFY && type != CA_TYPE &&\n                                                    type != TRUSTED_PEER_TYPE) {\n                        WOLFSSL_MSG(\"\\tNon-entity cert, maxPathLen is 0\");\n                        WOLFSSL_MSG(\"\\tmaxPathLen status: ERROR\");\n                        return ASN_PATHLEN_INV_E;\n                    }\n                }\n            }\n        }\n\n        #ifdef HAVE_OCSP\n        if (verify != NO_VERIFY && type != CA_TYPE &&\n                                                type != TRUSTED_PEER_TYPE) {\n            if (cert->ca) {\n                /* Need the CA's public key hash for OCSP */\n                XMEMCPY(cert->issuerKeyHash, cert->ca->subjectKeyHash,\n                                                                KEYID_SIZE);\n            }\n        }\n        #endif /* HAVE_OCSP */\n    }\n#if defined(WOLFSSL_RENESAS_TSIP)\n    /* prepare for TSIP TLS cert verification API use */\n    if (cert->keyOID == RSAk) {\n        /* to call TSIP API, it needs keys position info in bytes */\n        if ((ret = RsaPublicKeyDecodeRawIndex(cert->publicKey, (word32*)&idx,\n                                   cert->pubKeySize,\n                                   &cert->sigCtx.pubkey_n_start,\n                                   &cert->sigCtx.pubkey_n_len,\n                                   &cert->sigCtx.pubkey_e_start,\n                                   &cert->sigCtx.pubkey_e_len)) != 0) {\n            WOLFSSL_MSG(\"Decoding index from cert failed.\");\n            return ret;\n        }\n        cert->sigCtx.certBegin = cert->certBegin;\n    }\n    /* check if we can use TSIP for cert verification */\n    /* if the ca is verified as tsip root ca.         */\n    /* TSIP can only handle 2048 bits(256 byte) key.  */\n    if (cert->ca && tsip_checkCA(cert->ca->cm_idx) != 0 &&\n        cert->sigCtx.pubkey_n_len == 256) {\n\n        /* assign memory to encrypted tsip Rsa key index */\n        if (!cert->tsip_encRsaKeyIdx)\n            cert->tsip_encRsaKeyIdx =\n                            (byte*)XMALLOC(TSIP_TLS_ENCPUBKEY_SZ_BY_CERTVRFY,\n                             cert->heap, DYNAMIC_TYPE_RSA);\n        if (cert->tsip_encRsaKeyIdx == NULL)\n                return MEMORY_E;\n    } else {\n        if (cert->ca) {\n            /* TSIP isn't usable */\n            if (tsip_checkCA(cert->ca->cm_idx) == 0)\n                WOLFSSL_MSG(\"TSIP isn't usable because the ca isn't verified \"\n                            \"by TSIP.\");\n            else if (cert->sigCtx.pubkey_n_len != 256)\n                WOLFSSL_MSG(\"TSIP isn't usable because the ca isn't signed by \"\n                            \"RSA 2048.\");\n            else\n                WOLFSSL_MSG(\"TSIP isn't usable\");\n        }\n        cert->tsip_encRsaKeyIdx = NULL;\n    }\n\n    tsip_encRsaKeyIdx = cert->tsip_encRsaKeyIdx;\n#else\n    tsip_encRsaKeyIdx = NULL;\n#endif\n\n    if (verify != NO_VERIFY && type != CA_TYPE && type != TRUSTED_PEER_TYPE) {\n        if (cert->ca) {\n            if (verify == VERIFY || verify == VERIFY_OCSP ||\n                                                 verify == VERIFY_SKIP_DATE) {\n                /* try to confirm/verify signature */\n                if ((ret = ConfirmSignature(&cert->sigCtx,\n                        cert->source + cert->certBegin,\n                        cert->sigIndex - cert->certBegin,\n                        cert->ca->publicKey, cert->ca->pubKeySize,\n                        cert->ca->keyOID, cert->signature,\n                        cert->sigLength, cert->signatureOID,\n                        tsip_encRsaKeyIdx)) != 0) {\n                    if (ret != WC_PENDING_E) {\n                        WOLFSSL_MSG(\"Confirm signature failed\");\n                    }\n                    return ret;\n                }\n            }\n        #ifndef IGNORE_NAME_CONSTRAINTS\n            if (verify == VERIFY || verify == VERIFY_OCSP ||\n                        verify == VERIFY_NAME || verify == VERIFY_SKIP_DATE) {\n                /* check that this cert's name is permitted by the signer's\n                 * name constraints */\n                if (!ConfirmNameConstraints(cert->ca, cert)) {\n                    WOLFSSL_MSG(\"Confirm name constraint failed\");\n                    return ASN_NAME_INVALID_E;\n                }\n            }\n        #endif /* IGNORE_NAME_CONSTRAINTS */\n        }\n        else {\n            /* no signer */\n            WOLFSSL_MSG(\"No CA signer to verify with\");\n            return ASN_NO_SIGNER_E;\n        }\n    }\n\n#if defined(WOLFSSL_NO_TRUSTED_CERTS_VERIFY) && !defined(NO_SKID)\nexit_pcr:\n#endif\n\n    if (cert->badDate != 0) {\n        if (verify != VERIFY_SKIP_DATE) {\n            return cert->badDate;\n        }\n        WOLFSSL_MSG(\"Date error: Verify option is skipping\");\n    }\n\n    if (cert->criticalExt != 0)\n        return cert->criticalExt;\n\n    return ret;\n}\n\n/* Create and init an new signer */\nSigner* MakeSigner(void* heap)\n{\n    Signer* signer = (Signer*) XMALLOC(sizeof(Signer), heap,\n                                       DYNAMIC_TYPE_SIGNER);\n    if (signer) {\n        XMEMSET(signer, 0, sizeof(Signer));\n    }\n    (void)heap;\n\n    return signer;\n}\n\n\n/* Free an individual signer */\nvoid FreeSigner(Signer* signer, void* heap)\n{\n    XFREE(signer->name, heap, DYNAMIC_TYPE_SUBJECT_CN);\n    XFREE((void*)signer->publicKey, heap, DYNAMIC_TYPE_PUBLIC_KEY);\n#ifndef IGNORE_NAME_CONSTRAINTS\n    if (signer->permittedNames)\n        FreeNameSubtrees(signer->permittedNames, heap);\n    if (signer->excludedNames)\n        FreeNameSubtrees(signer->excludedNames, heap);\n#endif\n#ifdef WOLFSSL_SIGNER_DER_CERT\n    FreeDer(&signer->derCert);\n#endif\n    XFREE(signer, heap, DYNAMIC_TYPE_SIGNER);\n\n    (void)heap;\n}\n\n\n/* Free the whole singer table with number of rows */\nvoid FreeSignerTable(Signer** table, int rows, void* heap)\n{\n    int i;\n\n    for (i = 0; i < rows; i++) {\n        Signer* signer = table[i];\n        while (signer) {\n            Signer* next = signer->next;\n            FreeSigner(signer, heap);\n            signer = next;\n        }\n        table[i] = NULL;\n    }\n}\n\n#ifdef WOLFSSL_TRUST_PEER_CERT\n/* Free an individual trusted peer cert */\nvoid FreeTrustedPeer(TrustedPeerCert* tp, void* heap)\n{\n    if (tp == NULL) {\n        return;\n    }\n\n    if (tp->name) {\n        XFREE(tp->name, heap, DYNAMIC_TYPE_SUBJECT_CN);\n    }\n\n    if (tp->sig) {\n        XFREE(tp->sig, heap, DYNAMIC_TYPE_SIGNATURE);\n    }\n#ifndef IGNORE_NAME_CONSTRAINTS\n    if (tp->permittedNames)\n        FreeNameSubtrees(tp->permittedNames, heap);\n    if (tp->excludedNames)\n        FreeNameSubtrees(tp->excludedNames, heap);\n#endif\n    XFREE(tp, heap, DYNAMIC_TYPE_CERT);\n\n    (void)heap;\n}\n\n/* Free the whole Trusted Peer linked list */\nvoid FreeTrustedPeerTable(TrustedPeerCert** table, int rows, void* heap)\n{\n    int i;\n\n    for (i = 0; i < rows; i++) {\n        TrustedPeerCert* tp = table[i];\n        while (tp) {\n            TrustedPeerCert* next = tp->next;\n            FreeTrustedPeer(tp, heap);\n            tp = next;\n        }\n        table[i] = NULL;\n    }\n}\n#endif /* WOLFSSL_TRUST_PEER_CERT */\n\nint SetMyVersion(word32 version, byte* output, int header)\n{\n    int i = 0;\n\n    if (output == NULL)\n        return BAD_FUNC_ARG;\n\n    if (header) {\n        output[i++] = ASN_CONTEXT_SPECIFIC | ASN_CONSTRUCTED;\n        output[i++] = 3;\n    }\n    output[i++] = ASN_INTEGER;\n    output[i++] = 0x01;\n    output[i++] = (byte)version;\n\n    return i;\n}\n\nint SetSerialNumber(const byte* sn, word32 snSz, byte* output,\n    word32 outputSz, int maxSnSz)\n{\n    int i;\n    int snSzInt = (int)snSz;\n\n    if (sn == NULL || output == NULL || snSzInt < 0)\n        return BAD_FUNC_ARG;\n\n    /* remove leading zeros */\n    while (snSzInt > 0 && sn[0] == 0) {\n        snSzInt--;\n        sn++;\n    }\n    /* RFC 5280 - 4.1.2.2:\n     *   Serial numbers must be a positive value (and not zero) */\n    if (snSzInt == 0)\n        return BAD_FUNC_ARG;\n\n    if (sn[0] & 0x80)\n        maxSnSz--;\n    /* truncate if input is too long */\n    if (snSzInt > maxSnSz)\n        snSzInt = maxSnSz;\n\n    i = SetASNInt(snSzInt, sn[0], NULL);\n    /* truncate if input is too long */\n    if (snSzInt > (int)outputSz - i)\n        snSzInt = (int)outputSz - i;\n    /* sanity check number of bytes to copy */\n    if (snSzInt <= 0) {\n        return BUFFER_E;\n    }\n\n    /* write out ASN.1 Integer */\n    (void)SetASNInt(snSzInt, sn[0], output);\n    XMEMCPY(output + i, sn, snSzInt);\n\n    /* compute final length */\n    i += snSzInt;\n\n    return i;\n}\n\n#endif /* !NO_CERTS */\n\nint GetSerialNumber(const byte* input, word32* inOutIdx,\n    byte* serial, int* serialSz, word32 maxIdx)\n{\n    int result = 0;\n    int ret;\n\n    WOLFSSL_ENTER(\"GetSerialNumber\");\n\n    if (serial == NULL || input == NULL || serialSz == NULL) {\n        return BAD_FUNC_ARG;\n    }\n\n    /* First byte is ASN type */\n    if ((*inOutIdx+1) > maxIdx) {\n        WOLFSSL_MSG(\"Bad idx first\");\n        return BUFFER_E;\n    }\n\n    ret = GetASNInt(input, inOutIdx, serialSz, maxIdx);\n    if (ret != 0)\n        return ret;\n\n    if (*serialSz > EXTERNAL_SERIAL_SIZE) {\n        WOLFSSL_MSG(\"Serial size bad\");\n        return ASN_PARSE_E;\n    }\n\n    /* return serial */\n    XMEMCPY(serial, &input[*inOutIdx], *serialSz);\n    *inOutIdx += *serialSz;\n\n    return result;\n}\n\n#ifndef NO_CERTS\n\nint AllocDer(DerBuffer** pDer, word32 length, int type, void* heap)\n{\n    int ret = BAD_FUNC_ARG;\n    if (pDer) {\n        int dynType = 0;\n        DerBuffer* der;\n\n        /* Determine dynamic type */\n        switch (type) {\n            case CA_TYPE:   dynType = DYNAMIC_TYPE_CA;   break;\n            case CERT_TYPE: dynType = DYNAMIC_TYPE_CERT; break;\n            case CRL_TYPE:  dynType = DYNAMIC_TYPE_CRL;  break;\n            case DSA_TYPE:  dynType = DYNAMIC_TYPE_DSA;  break;\n            case ECC_TYPE:  dynType = DYNAMIC_TYPE_ECC;  break;\n            case RSA_TYPE:  dynType = DYNAMIC_TYPE_RSA;  break;\n            default:        dynType = DYNAMIC_TYPE_KEY;  break;\n        }\n\n        /* Setup new buffer */\n        *pDer = (DerBuffer*)XMALLOC(sizeof(DerBuffer) + length, heap, dynType);\n        if (*pDer == NULL) {\n            return MEMORY_E;\n        }\n        XMEMSET(*pDer, 0, sizeof(DerBuffer) + length);\n\n        der = *pDer;\n        der->type = type;\n        der->dynType = dynType; /* Cache this for FreeDer */\n        der->heap = heap;\n        der->buffer = (byte*)der + sizeof(DerBuffer);\n        der->length = length;\n        ret = 0; /* Success */\n    }\n    return ret;\n}\n\nvoid FreeDer(DerBuffer** pDer)\n{\n    if (pDer && *pDer)\n    {\n        DerBuffer* der = (DerBuffer*)*pDer;\n\n        /* ForceZero private keys */\n        if (der->type == PRIVATEKEY_TYPE && der->buffer != NULL) {\n            ForceZero(der->buffer, der->length);\n        }\n        der->buffer = NULL;\n        der->length = 0;\n        XFREE(der, der->heap, der->dynType);\n\n        *pDer = NULL;\n    }\n}\n\nint wc_AllocDer(DerBuffer** pDer, word32 length, int type, void* heap)\n{\n    return AllocDer(pDer, length, type, heap);\n}\nvoid wc_FreeDer(DerBuffer** pDer)\n{\n    FreeDer(pDer);\n}\n\n\n#if defined(WOLFSSL_PEM_TO_DER) || defined(WOLFSSL_DER_TO_PEM)\n\n/* Note: If items added make sure MAX_X509_HEADER_SZ is \n    updated to reflect maximum length and pem_struct_min_sz\n    to reflect minimum size */\nwcchar BEGIN_CERT           = \"-----BEGIN CERTIFICATE-----\";\nwcchar END_CERT             = \"-----END CERTIFICATE-----\";\n#ifdef WOLFSSL_CERT_REQ\n    wcchar BEGIN_CERT_REQ   = \"-----BEGIN CERTIFICATE REQUEST-----\";\n    wcchar END_CERT_REQ     = \"-----END CERTIFICATE REQUEST-----\";\n#endif\n#ifndef NO_DH\n    wcchar BEGIN_DH_PARAM   = \"-----BEGIN DH PARAMETERS-----\";\n    wcchar END_DH_PARAM     = \"-----END DH PARAMETERS-----\";\n#endif\n#ifndef NO_DSA\n    wcchar BEGIN_DSA_PARAM  = \"-----BEGIN DSA PARAMETERS-----\";\n    wcchar END_DSA_PARAM    = \"-----END DSA PARAMETERS-----\";\n#endif\nwcchar BEGIN_X509_CRL       = \"-----BEGIN X509 CRL-----\";\nwcchar END_X509_CRL         = \"-----END X509 CRL-----\";\nwcchar BEGIN_RSA_PRIV       = \"-----BEGIN RSA PRIVATE KEY-----\";\nwcchar END_RSA_PRIV         = \"-----END RSA PRIVATE KEY-----\";\nwcchar BEGIN_PRIV_KEY       = \"-----BEGIN PRIVATE KEY-----\";\nwcchar END_PRIV_KEY         = \"-----END PRIVATE KEY-----\";\nwcchar BEGIN_ENC_PRIV_KEY   = \"-----BEGIN ENCRYPTED PRIVATE KEY-----\";\nwcchar END_ENC_PRIV_KEY     = \"-----END ENCRYPTED PRIVATE KEY-----\";\n#ifdef HAVE_ECC\n    wcchar BEGIN_EC_PRIV    = \"-----BEGIN EC PRIVATE KEY-----\";\n    wcchar END_EC_PRIV      = \"-----END EC PRIVATE KEY-----\";\n#endif\n#if defined(HAVE_ECC) || defined(HAVE_ED25519) || defined(HAVE_ED448) || \\\n                                                                !defined(NO_DSA)\n    wcchar BEGIN_DSA_PRIV   = \"-----BEGIN DSA PRIVATE KEY-----\";\n    wcchar END_DSA_PRIV     = \"-----END DSA PRIVATE KEY-----\";\n#endif\n#ifdef OPENSSL_EXTRA\n    const char BEGIN_PRIV_KEY_PREFIX[] = \"-----BEGIN\";\n    const char PRIV_KEY_SUFFIX[] = \"PRIVATE KEY-----\";\n    const char END_PRIV_KEY_PREFIX[]   = \"-----END\";\n#endif\nwcchar BEGIN_PUB_KEY        = \"-----BEGIN PUBLIC KEY-----\";\nwcchar END_PUB_KEY          = \"-----END PUBLIC KEY-----\";\n#if defined(HAVE_ED25519) || defined(HAVE_ED448)\n    wcchar BEGIN_EDDSA_PRIV = \"-----BEGIN EDDSA PRIVATE KEY-----\";\n    wcchar END_EDDSA_PRIV   = \"-----END EDDSA PRIVATE KEY-----\";\n#endif\n\nconst int pem_struct_min_sz = XSTR_SIZEOF(\"-----BEGIN X509 CRL-----\"\n                                             \"-----END X509 CRL-----\");\n\nstatic WC_INLINE const char* SkipEndOfLineChars(const char* line,\n                                                const char* endOfLine)\n{\n    /* eat end of line characters */\n    while (line < endOfLine &&\n              (line[0] == '\\r' || line[0] == '\\n')) {\n        line++;\n    }\n    return line;\n}\n\nint wc_PemGetHeaderFooter(int type, const char** header, const char** footer)\n{\n    int ret = BAD_FUNC_ARG;\n\n    switch (type) {\n        case CA_TYPE:       /* same as below */\n        case TRUSTED_PEER_TYPE:\n        case CERT_TYPE:\n            if (header) *header = BEGIN_CERT;\n            if (footer) *footer = END_CERT;\n            ret = 0;\n            break;\n\n        case CRL_TYPE:\n            if (header) *header = BEGIN_X509_CRL;\n            if (footer) *footer = END_X509_CRL;\n            ret = 0;\n            break;\n    #ifndef NO_DH\n        case DH_PARAM_TYPE:\n            if (header) *header = BEGIN_DH_PARAM;\n            if (footer) *footer = END_DH_PARAM;\n            ret = 0;\n            break;\n    #endif\n    #ifndef NO_DSA\n        case DSA_PARAM_TYPE:\n            if (header) *header = BEGIN_DSA_PARAM;\n            if (footer) *footer = END_DSA_PARAM;\n            ret = 0;\n            break;\n    #endif\n    #ifdef WOLFSSL_CERT_REQ\n        case CERTREQ_TYPE:\n            if (header) *header = BEGIN_CERT_REQ;\n            if (footer) *footer = END_CERT_REQ;\n            ret = 0;\n            break;\n    #endif\n    #ifndef NO_DSA\n        case DSA_TYPE:\n        case DSA_PRIVATEKEY_TYPE:\n            if (header) *header = BEGIN_DSA_PRIV;\n            if (footer) *footer = END_DSA_PRIV;\n            ret = 0;\n            break;\n    #endif\n    #ifdef HAVE_ECC\n        case ECC_TYPE:\n        case ECC_PRIVATEKEY_TYPE:\n            if (header) *header = BEGIN_EC_PRIV;\n            if (footer) *footer = END_EC_PRIV;\n            ret = 0;\n            break;\n    #endif\n        case RSA_TYPE:\n        case PRIVATEKEY_TYPE:\n            if (header) *header = BEGIN_RSA_PRIV;\n            if (footer) *footer = END_RSA_PRIV;\n            ret = 0;\n            break;\n    #ifdef HAVE_ED25519\n        case ED25519_TYPE:\n    #endif\n    #ifdef HAVE_ED448\n        case ED448_TYPE:\n    #endif\n    #if defined(HAVE_ED25519) || defined(HAVE_ED448)\n        case EDDSA_PRIVATEKEY_TYPE:\n            if (header) *header = BEGIN_EDDSA_PRIV;\n            if (footer) *footer = END_EDDSA_PRIV;\n            ret = 0;\n            break;\n    #endif\n        case PUBLICKEY_TYPE:\n        case ECC_PUBLICKEY_TYPE:\n            if (header) *header = BEGIN_PUB_KEY;\n            if (footer) *footer = END_PUB_KEY;\n            ret = 0;\n            break;\n    #ifndef NO_DH\n        case DH_PRIVATEKEY_TYPE:\n    #endif\n        case PKCS8_PRIVATEKEY_TYPE:\n            if (header) *header = BEGIN_PRIV_KEY;\n            if (footer) *footer = END_PRIV_KEY;\n            ret = 0;\n            break;\n        case PKCS8_ENC_PRIVATEKEY_TYPE:\n            if (header) *header = BEGIN_ENC_PRIV_KEY;\n            if (footer) *footer = END_ENC_PRIV_KEY;\n            ret = 0;\n            break;\n        default:\n            break;\n    }\n    return ret;\n}\n\n#ifdef WOLFSSL_ENCRYPTED_KEYS\n\nstatic wcchar kProcTypeHeader = \"Proc-Type\";\nstatic wcchar kDecInfoHeader = \"DEK-Info\";\n\n#ifdef WOLFSSL_PEM_TO_DER\n#ifndef NO_DES3\n    static wcchar kEncTypeDes = \"DES-CBC\";\n    static wcchar kEncTypeDes3 = \"DES-EDE3-CBC\";\n#endif\n#if !defined(NO_AES) && defined(HAVE_AES_CBC) && defined(WOLFSSL_AES_128)\n    static wcchar kEncTypeAesCbc128 = \"AES-128-CBC\";\n#endif\n#if !defined(NO_AES) && defined(HAVE_AES_CBC) && defined(WOLFSSL_AES_192)\n    static wcchar kEncTypeAesCbc192 = \"AES-192-CBC\";\n#endif\n#if !defined(NO_AES) && defined(HAVE_AES_CBC) && defined(WOLFSSL_AES_256)\n    static wcchar kEncTypeAesCbc256 = \"AES-256-CBC\";\n#endif\n\nint wc_EncryptedInfoGet(EncryptedInfo* info, const char* cipherInfo)\n{\n    int ret = 0;\n\n    if (info == NULL || cipherInfo == NULL)\n        return BAD_FUNC_ARG;\n\n    /* determine cipher information */\n#ifndef NO_DES3\n    if (XSTRNCMP(cipherInfo, kEncTypeDes, XSTRLEN(kEncTypeDes)) == 0) {\n        info->cipherType = WC_CIPHER_DES;\n        info->keySz = DES_KEY_SIZE;\n        if (info->ivSz == 0) info->ivSz  = DES_IV_SIZE;\n    }\n    else if (XSTRNCMP(cipherInfo, kEncTypeDes3, XSTRLEN(kEncTypeDes3)) == 0) {\n        info->cipherType = WC_CIPHER_DES3;\n        info->keySz = DES3_KEY_SIZE;\n        if (info->ivSz == 0) info->ivSz  = DES_IV_SIZE;\n    }\n    else\n#endif /* !NO_DES3 */\n#if !defined(NO_AES) && defined(HAVE_AES_CBC) && defined(WOLFSSL_AES_128)\n    if (XSTRNCMP(cipherInfo, kEncTypeAesCbc128, XSTRLEN(kEncTypeAesCbc128)) == 0) {\n        info->cipherType = WC_CIPHER_AES_CBC;\n        info->keySz = AES_128_KEY_SIZE;\n        if (info->ivSz == 0) info->ivSz  = AES_IV_SIZE;\n    }\n    else\n#endif\n#if !defined(NO_AES) && defined(HAVE_AES_CBC) && defined(WOLFSSL_AES_192)\n    if (XSTRNCMP(cipherInfo, kEncTypeAesCbc192, XSTRLEN(kEncTypeAesCbc192)) == 0) {\n        info->cipherType = WC_CIPHER_AES_CBC;\n        info->keySz = AES_192_KEY_SIZE;\n        if (info->ivSz == 0) info->ivSz  = AES_IV_SIZE;\n    }\n    else\n#endif\n#if !defined(NO_AES) && defined(HAVE_AES_CBC) && defined(WOLFSSL_AES_256)\n    if (XSTRNCMP(cipherInfo, kEncTypeAesCbc256, XSTRLEN(kEncTypeAesCbc256)) == 0) {\n        info->cipherType = WC_CIPHER_AES_CBC;\n        info->keySz = AES_256_KEY_SIZE;\n        if (info->ivSz == 0) info->ivSz  = AES_IV_SIZE;\n    }\n    else\n#endif\n    {\n        ret = NOT_COMPILED_IN;\n    }\n    return ret;\n}\n\nint wc_EncryptedInfoParse(EncryptedInfo* info, const char** pBuffer,\n                          size_t bufSz)\n{\n    int         err = 0;\n    const char* bufferStart;\n    const char* bufferEnd;\n    char*       line;\n    word32      lineSz;\n    char*       finish;\n    word32      finishSz;\n    char*       start = NULL;\n    word32      startSz;\n    const char* newline = NULL;\n\n    if (info == NULL || pBuffer == NULL || bufSz == 0)\n        return BAD_FUNC_ARG;\n\n    bufferStart = *pBuffer;\n    bufferEnd = bufferStart + bufSz;\n\n    /* find encrypted info marker */\n    line = XSTRNSTR(bufferStart, kProcTypeHeader,\n                    min((word32)bufSz, PEM_LINE_LEN));\n    if (line != NULL) {\n        if (line >= bufferEnd) {\n            return BUFFER_E;\n        }\n\n        lineSz = (word32)(bufferEnd - line);\n\n        /* find DEC-Info marker */\n        start = XSTRNSTR(line, kDecInfoHeader, min(lineSz, PEM_LINE_LEN));\n\n        if (start == NULL)\n            return BUFFER_E;\n\n        /* skip dec-info and \": \" */\n        start += XSTRLEN(kDecInfoHeader);\n        if (start >= bufferEnd)\n            return BUFFER_E;\n\n        if (start[0] == ':') {\n            start++;\n            if (start >= bufferEnd)\n                return BUFFER_E;\n        }\n        if (start[0] == ' ')\n            start++;\n\n        startSz = (word32)(bufferEnd - start);\n        finish = XSTRNSTR(start, \",\", min(startSz, PEM_LINE_LEN));\n\n        if ((start != NULL) && (finish != NULL) && (start < finish)) {\n            if (finish >= bufferEnd) {\n                return BUFFER_E;\n            }\n\n            finishSz = (word32)(bufferEnd - finish);\n            newline = XSTRNSTR(finish, \"\\r\", min(finishSz, PEM_LINE_LEN));\n\n            /* get cipher name */\n            if (NAME_SZ < (finish - start)) /* buffer size of info->name */\n                return BUFFER_E;\n            if (XMEMCPY(info->name, start, finish - start) == NULL)\n                return BUFFER_E;\n            info->name[finish - start] = '\\0'; /* null term */\n\n            /* populate info */\n            err = wc_EncryptedInfoGet(info, info->name);\n            if (err != 0)\n                return err;\n\n            /* get IV */\n            if (finishSz < info->ivSz + 1)\n                return BUFFER_E;\n\n            if (newline == NULL) {\n                newline = XSTRNSTR(finish, \"\\n\", min(finishSz,\n                                                     PEM_LINE_LEN));\n            }\n            if ((newline != NULL) && (newline > finish)) {\n                finish++;\n                info->ivSz = (word32)(newline - finish);\n                if (info->ivSz > IV_SZ)\n                    return BUFFER_E;\n                if (XMEMCPY(info->iv, finish, info->ivSz) == NULL)\n                    return BUFFER_E;\n                info->set = 1;\n            }\n            else\n                return BUFFER_E;\n        }\n        else\n            return BUFFER_E;\n\n        /* eat end of line characters */\n        newline = SkipEndOfLineChars(newline, bufferEnd);\n\n        /* return new headerEnd */\n\n        *pBuffer = newline;\n    }\n\n    return err;\n}\n#endif /* WOLFSSL_PEM_TO_DER */\n\n#ifdef WOLFSSL_DER_TO_PEM\nstatic int wc_EncryptedInfoAppend(char* dest, int destSz, char* cipherInfo)\n{\n    if (cipherInfo != NULL) {\n        int cipherInfoStrLen = (int)XSTRLEN((char*)cipherInfo);\n\n        if (cipherInfoStrLen > HEADER_ENCRYPTED_KEY_SIZE - (9+14+10+3))\n            cipherInfoStrLen = HEADER_ENCRYPTED_KEY_SIZE - (9+14+10+3);\n\n        if (destSz - (int)XSTRLEN(dest) >= cipherInfoStrLen + (9+14+8+2+2+1)) {\n            /* strncat's src length needs to include the NULL */\n            XSTRNCAT(dest, kProcTypeHeader, 10);\n            XSTRNCAT(dest, \": 4,ENCRYPTED\\n\", 15);\n            XSTRNCAT(dest, kDecInfoHeader, 9);\n            XSTRNCAT(dest, \": \", 3);\n            XSTRNCAT(dest, cipherInfo, destSz - (int)XSTRLEN(dest) - 1);\n            XSTRNCAT(dest, \"\\n\\n\", 4);\n        }\n    }\n    return 0;\n}\n#endif /* WOLFSSL_DER_TO_PEM */\n#endif /* WOLFSSL_ENCRYPTED_KEYS */\n\n#ifdef WOLFSSL_DER_TO_PEM\n\n/* Used for compatibility API */\nint wc_DerToPem(const byte* der, word32 derSz,\n                byte* output, word32 outSz, int type)\n{\n    return wc_DerToPemEx(der, derSz, output, outSz, NULL, type);\n}\n\n/* convert der buffer to pem into output, can't do inplace, der and output\n   need to be different */\nint wc_DerToPemEx(const byte* der, word32 derSz, byte* output, word32 outSz,\n             byte *cipher_info, int type)\n{\n    const char* headerStr = NULL;\n    const char* footerStr = NULL;\n#ifdef WOLFSSL_SMALL_STACK\n    char* header = NULL;\n    char* footer = NULL;\n#else\n    char header[MAX_X509_HEADER_SZ + HEADER_ENCRYPTED_KEY_SIZE];\n    char footer[MAX_X509_HEADER_SZ];\n#endif\n    int headerLen = MAX_X509_HEADER_SZ + HEADER_ENCRYPTED_KEY_SIZE;\n    int footerLen = MAX_X509_HEADER_SZ;\n    int i;\n    int err;\n    int outLen;   /* return length or error */\n\n    (void)cipher_info;\n\n    if (der == output)      /* no in place conversion */\n        return BAD_FUNC_ARG;\n\n    err = wc_PemGetHeaderFooter(type, &headerStr, &footerStr);\n    if (err != 0)\n        return err;\n\n#ifdef WOLFSSL_SMALL_STACK\n    header = (char*)XMALLOC(headerLen, NULL, DYNAMIC_TYPE_TMP_BUFFER);\n    if (header == NULL)\n        return MEMORY_E;\n\n    footer = (char*)XMALLOC(footerLen, NULL, DYNAMIC_TYPE_TMP_BUFFER);\n    if (footer == NULL) {\n        XFREE(header, NULL, DYNAMIC_TYPE_TMP_BUFFER);\n        return MEMORY_E;\n    }\n#endif\n\n    /* build header and footer based on type */\n    XSTRNCPY(header, headerStr, headerLen - 1);\n    header[headerLen - 2] = 0;\n    XSTRNCPY(footer, footerStr, footerLen - 1);\n    footer[footerLen - 2] = 0;\n\n    /* add new line to end */\n    XSTRNCAT(header, \"\\n\", 2);\n    XSTRNCAT(footer, \"\\n\", 2);\n\n#ifdef WOLFSSL_ENCRYPTED_KEYS\n    err = wc_EncryptedInfoAppend(header, headerLen, (char*)cipher_info);\n    if (err != 0) {\n    #ifdef WOLFSSL_SMALL_STACK\n        XFREE(header, NULL, DYNAMIC_TYPE_TMP_BUFFER);\n        XFREE(footer, NULL, DYNAMIC_TYPE_TMP_BUFFER);\n    #endif\n        return err;\n    }\n#endif\n\n    headerLen = (int)XSTRLEN(header);\n    footerLen = (int)XSTRLEN(footer);\n\n    /* if null output and 0 size passed in then return size needed */\n    if (!output && outSz == 0) {\n#ifdef WOLFSSL_SMALL_STACK\n        XFREE(header, NULL, DYNAMIC_TYPE_TMP_BUFFER);\n        XFREE(footer, NULL, DYNAMIC_TYPE_TMP_BUFFER);\n#endif\n        outLen = 0;\n        if ((err = Base64_Encode(der, derSz, NULL, (word32*)&outLen))\n                != LENGTH_ONLY_E) {\n            return err;\n        }\n        return headerLen + footerLen + outLen;\n    }\n\n    if (!der || !output) {\n#ifdef WOLFSSL_SMALL_STACK\n        XFREE(header, NULL, DYNAMIC_TYPE_TMP_BUFFER);\n        XFREE(footer, NULL, DYNAMIC_TYPE_TMP_BUFFER);\n#endif\n        return BAD_FUNC_ARG;\n    }\n\n    /* don't even try if outSz too short */\n    if (outSz < headerLen + footerLen + derSz) {\n#ifdef WOLFSSL_SMALL_STACK\n        XFREE(header, NULL, DYNAMIC_TYPE_TMP_BUFFER);\n        XFREE(footer, NULL, DYNAMIC_TYPE_TMP_BUFFER);\n#endif\n        return BAD_FUNC_ARG;\n    }\n\n    /* header */\n    XMEMCPY(output, header, headerLen);\n    i = headerLen;\n\n#ifdef WOLFSSL_SMALL_STACK\n    XFREE(header, NULL, DYNAMIC_TYPE_TMP_BUFFER);\n#endif\n\n    /* body */\n    outLen = outSz - (headerLen + footerLen);  /* input to Base64_Encode */\n    if ( (err = Base64_Encode(der, derSz, output + i, (word32*)&outLen)) < 0) {\n#ifdef WOLFSSL_SMALL_STACK\n        XFREE(footer, NULL, DYNAMIC_TYPE_TMP_BUFFER);\n#endif\n        return err;\n    }\n    i += outLen;\n\n    /* footer */\n    if ( (i + footerLen) > (int)outSz) {\n#ifdef WOLFSSL_SMALL_STACK\n        XFREE(footer, NULL, DYNAMIC_TYPE_TMP_BUFFER);\n#endif\n        return BAD_FUNC_ARG;\n    }\n    XMEMCPY(output + i, footer, footerLen);\n\n#ifdef WOLFSSL_SMALL_STACK\n    XFREE(footer, NULL, DYNAMIC_TYPE_TMP_BUFFER);\n#endif\n\n    return outLen + headerLen + footerLen;\n}\n\n#endif /* WOLFSSL_DER_TO_PEM */\n\n#ifdef WOLFSSL_PEM_TO_DER\n\n/* Remove PEM header/footer, convert to ASN1, store any encrypted data\n   info->consumed tracks of PEM bytes consumed in case multiple parts */\nint PemToDer(const unsigned char* buff, long longSz, int type,\n              DerBuffer** pDer, void* heap, EncryptedInfo* info, int* keyFormat)\n{\n    const char* header      = NULL;\n    const char* footer      = NULL;\n    const char* headerEnd;\n    const char* footerEnd;\n    const char* consumedEnd;\n    const char* bufferEnd   = (const char*)(buff + longSz);\n    long        neededSz;\n    int         ret         = 0;\n    int         sz          = (int)longSz;\n    int         encrypted_key = 0;\n    DerBuffer*  der;\n#if defined(HAVE_PKCS8) || defined(WOLFSSL_ENCRYPTED_KEYS)\n    word32      algId = 0;\n    #if defined(WOLFSSL_ENCRYPTED_KEYS) && !defined(NO_DES3) && !defined(NO_WOLFSSL_SKIP_TRAILING_PAD)\n        int     padVal = 0;\n    #endif\n#endif\n#ifdef OPENSSL_EXTRA\n    char        beginBuf[PEM_LINE_LEN + 1]; /* add 1 for null terminator */\n    char        endBuf[PEM_LINE_LEN + 1];   /* add 1 for null terminator */\n#endif\n\n    WOLFSSL_ENTER(\"PemToDer\");\n\n    /* get PEM header and footer based on type */\n    ret = wc_PemGetHeaderFooter(type, &header, &footer);\n    if (ret != 0)\n        return ret;\n\n    /* map header if not found for type */\n    for (;;) {\n        headerEnd = XSTRNSTR((char*)buff, header, sz);\n\n        if (headerEnd) {\n            break;\n        } else\n        if (type == PRIVATEKEY_TYPE) {\n            if (header == BEGIN_RSA_PRIV) {\n                header =  BEGIN_PRIV_KEY;       footer = END_PRIV_KEY;\n            } else\n            if (header == BEGIN_PRIV_KEY) {\n                header =  BEGIN_ENC_PRIV_KEY;   footer = END_ENC_PRIV_KEY;\n            } else\n    #ifdef HAVE_ECC\n            if (header == BEGIN_ENC_PRIV_KEY) {\n                header =  BEGIN_EC_PRIV;        footer = END_EC_PRIV;\n            } else\n            if (header == BEGIN_EC_PRIV) {\n                header =  BEGIN_DSA_PRIV;       footer = END_DSA_PRIV;\n            } else\n    #endif\n    #if defined(HAVE_ED25519) || defined(HAVE_ED448)\n        #ifdef HAVE_ECC\n            if (header == BEGIN_DSA_PRIV)\n        #else\n            if (header == BEGIN_ENC_PRIV_KEY)\n        #endif\n            {\n                header =  BEGIN_EDDSA_PRIV;     footer = END_EDDSA_PRIV;\n            } else\n    #endif\n            {\n                break;\n            }\n        } else\n#ifdef HAVE_CRL\n        if ((type == CRL_TYPE) && (header != BEGIN_X509_CRL)) {\n            header =  BEGIN_X509_CRL;           footer = END_X509_CRL;\n        } else\n#endif\n        {\n            break;\n        }\n    }\n\n    if (!headerEnd) {\n#ifdef OPENSSL_EXTRA\n        if (type == PRIVATEKEY_TYPE) {\n            const char* beginEnd;\n            int endLen;\n            /* see if there is a -----BEGIN * PRIVATE KEY----- header */\n            headerEnd = XSTRNSTR((char*)buff, PRIV_KEY_SUFFIX, sz);\n            if (headerEnd) {\n                beginEnd = headerEnd + XSTR_SIZEOF(PRIV_KEY_SUFFIX);\n                if (beginEnd >= (char*)buff + sz) {\n                    return BUFFER_E;\n                }\n\n                /* back up to BEGIN_PRIV_KEY_PREFIX */\n                while (headerEnd > (char*)buff &&\n                        XSTRNCMP(headerEnd, BEGIN_PRIV_KEY_PREFIX,\n                                XSTR_SIZEOF(BEGIN_PRIV_KEY_PREFIX)) != 0 &&\n                        *headerEnd != '\\n') {\n                    headerEnd--;\n                }\n                if (headerEnd <= (char*)buff ||\n                        XSTRNCMP(headerEnd, BEGIN_PRIV_KEY_PREFIX,\n                        XSTR_SIZEOF(BEGIN_PRIV_KEY_PREFIX)) != 0 ||\n                        beginEnd - headerEnd > PEM_LINE_LEN) {\n                    WOLFSSL_MSG(\"Couldn't find PEM header\");\n                    WOLFSSL_ERROR(ASN_NO_PEM_HEADER);\n                    return ASN_NO_PEM_HEADER;\n                }\n\n                /* headerEnd now points to beginning of header */\n                XMEMCPY(beginBuf, headerEnd, beginEnd - headerEnd);\n                beginBuf[beginEnd - headerEnd] = '\\0';\n                /* look for matching footer */\n                footer = XSTRNSTR(beginEnd,\n                                beginBuf + XSTR_SIZEOF(BEGIN_PRIV_KEY_PREFIX),\n                                (unsigned int)((char*)buff + sz - beginEnd));\n                if (!footer) {\n                    WOLFSSL_MSG(\"Couldn't find PEM footer\");\n                    WOLFSSL_ERROR(ASN_NO_PEM_HEADER);\n                    return ASN_NO_PEM_HEADER;\n                }\n\n                footer -= XSTR_SIZEOF(END_PRIV_KEY_PREFIX);\n                if (footer > (char*)buff + sz - XSTR_SIZEOF(END_PRIV_KEY_PREFIX)\n                        || XSTRNCMP(footer, END_PRIV_KEY_PREFIX,\n                            XSTR_SIZEOF(END_PRIV_KEY_PREFIX)) != 0) {\n                    WOLFSSL_MSG(\"Unexpected footer for PEM\");\n                    return BUFFER_E;\n                }\n\n                endLen = (unsigned int)(beginEnd - headerEnd -\n                            (XSTR_SIZEOF(BEGIN_PRIV_KEY_PREFIX) -\n                                    XSTR_SIZEOF(END_PRIV_KEY_PREFIX)));\n                XMEMCPY(endBuf, footer, endLen);\n                endBuf[endLen] = '\\0';\n\n                header = beginBuf;\n                footer = endBuf;\n                headerEnd = beginEnd;\n            }\n        }\n\n        if (!headerEnd) {\n            WOLFSSL_MSG(\"Couldn't find PEM header\");\n            WOLFSSL_ERROR(ASN_NO_PEM_HEADER);\n            return ASN_NO_PEM_HEADER;\n        }\n#else\n        WOLFSSL_MSG(\"Couldn't find PEM header\");\n        return ASN_NO_PEM_HEADER;\n#endif\n    } else {\n        headerEnd += XSTRLEN(header);\n    }\n\n    /* eat end of line characters */\n    headerEnd = SkipEndOfLineChars(headerEnd, bufferEnd);\n\n    if (type == PRIVATEKEY_TYPE) {\n        /* keyFormat is Key_Sum enum */\n        if (keyFormat) {\n        #ifdef HAVE_ECC\n            if (header == BEGIN_EC_PRIV)\n                *keyFormat = ECDSAk;\n        #endif\n        #if !defined(NO_DSA)\n            if (header == BEGIN_DSA_PRIV)\n                *keyFormat = DSAk;\n        #endif\n        }\n    }\n\n#ifdef WOLFSSL_ENCRYPTED_KEYS\n    if (info) {\n        ret = wc_EncryptedInfoParse(info, &headerEnd, bufferEnd - headerEnd);\n        if (ret < 0)\n            return ret;\n        if (info->set)\n            encrypted_key = 1;\n    }\n#endif /* WOLFSSL_ENCRYPTED_KEYS */\n\n    /* find footer */\n    footerEnd = XSTRNSTR(headerEnd, footer, (unsigned int)((char*)buff + sz - headerEnd));\n    if (!footerEnd) {\n        if (info)\n            info->consumed = longSz; /* No more certs if no footer */\n        return BUFFER_E;\n    }\n\n    consumedEnd = footerEnd + XSTRLEN(footer);\n\n    if (consumedEnd < bufferEnd) { /* handle no end of line on last line */\n        /* eat end of line characters */\n        consumedEnd = SkipEndOfLineChars(consumedEnd, bufferEnd);\n        /* skip possible null term */\n        if (consumedEnd < bufferEnd && consumedEnd[0] == '\\0')\n            consumedEnd++;\n    }\n\n    if (info)\n        info->consumed = (long)(consumedEnd - (const char*)buff);\n\n    /* set up der buffer */\n    neededSz = (long)(footerEnd - headerEnd);\n    if (neededSz > sz || neededSz <= 0)\n        return BUFFER_E;\n\n    ret = AllocDer(pDer, (word32)neededSz, type, heap);\n    if (ret < 0) {\n        return ret;\n    }\n    der = *pDer;\n\n    if (Base64_Decode((byte*)headerEnd, (word32)neededSz,\n                      der->buffer, &der->length) < 0)\n        return BUFFER_E;\n\n    if ((header == BEGIN_PRIV_KEY\n#ifdef OPENSSL_EXTRA\n         || header == beginBuf\n#endif\n#ifdef HAVE_ECC\n         || header == BEGIN_EC_PRIV\n#endif\n        ) && !encrypted_key)\n    {\n    #ifdef HAVE_PKCS8\n        /* pkcs8 key, convert and adjust length */\n        if ((ret = ToTraditional_ex(der->buffer, der->length, &algId)) > 0) {\n            der->length = ret;\n            if (keyFormat) {\n                *keyFormat = algId;\n            }\n        }\n        else {\n            /* ignore failure here and assume key is not pkcs8 wrapped */\n        }\n    #endif\n\n        return 0;\n    }\n\n#ifdef WOLFSSL_ENCRYPTED_KEYS\n    if (encrypted_key || header == BEGIN_ENC_PRIV_KEY) {\n        int   passwordSz = NAME_SZ;\n    #ifdef WOLFSSL_SMALL_STACK\n        char* password = NULL;\n    #else\n        char  password[NAME_SZ];\n    #endif\n\n        if (!info || !info->passwd_cb) {\n            WOLFSSL_MSG(\"No password callback set\");\n            return NO_PASSWORD;\n        }\n\n    #ifdef WOLFSSL_SMALL_STACK\n        password = (char*)XMALLOC(passwordSz, heap, DYNAMIC_TYPE_STRING);\n        if (password == NULL)\n            return MEMORY_E;\n    #endif\n\n        /* get password */\n        ret = info->passwd_cb(password, passwordSz, PEM_PASS_READ,\n            info->passwd_userdata);\n        if (ret >= 0) {\n            passwordSz = ret;\n\n            /* convert and adjust length */\n            if (header == BEGIN_ENC_PRIV_KEY) {\n            #ifndef NO_PWDBASED\n                ret = ToTraditionalEnc(der->buffer, der->length,\n                                       password, passwordSz, &algId);\n\n                if (ret >= 0) {\n                    der->length = ret;\n                    if (keyFormat) {\n                        *keyFormat = algId;\n                    }\n                    ret = 0;\n                }\n            #else\n                ret = NOT_COMPILED_IN;\n            #endif\n            }\n            /* decrypt the key */\n            else {\n                if (passwordSz == 0) {\n                    /* The key is encrypted but does not have a password */\n                    WOLFSSL_MSG(\"No password for encrypted key\");\n                    ret = NO_PASSWORD;\n                }\n                else {\n                    ret = wc_BufferKeyDecrypt(info, der->buffer, der->length,\n                        (byte*)password, passwordSz, WC_MD5);\n\n#ifndef NO_WOLFSSL_SKIP_TRAILING_PAD\n                #ifndef NO_DES3\n                    if (info->cipherType == WC_CIPHER_DES3) {\n                        /* Assuming there is padding:\n                         *      (der->length > 0 && der->length > DES_BLOCK_SIZE &&\n                         *       (der->length % DES_BLOCK_SIZE) != 0)\n                         * and assuming the last value signifies the number of\n                         * padded bytes IE if last value is 0x08 then there are\n                         * 8 bytes of padding:\n                         *      padVal = der->buffer[der->length-1];\n                         * then strip this padding before proceeding:\n                         * der->length -= padVal;\n                         */\n                        if (der->length > DES_BLOCK_SIZE &&\n                            (der->length % DES_BLOCK_SIZE) != 0) {\n                            padVal = der->buffer[der->length-1];\n                            if (padVal < DES_BLOCK_SIZE) {\n                                der->length -= padVal;\n                            }\n                        }\n                    }\n                #endif /* !NO_DES3 */\n#endif /* !NO_WOLFSSL_SKIP_TRAILING_PAD */\n                }\n            }\n#ifdef OPENSSL_EXTRA\n            if (ret) {\n                PEMerr(0, PEM_R_BAD_DECRYPT);\n            }\n#endif\n            ForceZero(password, passwordSz);\n        }\n#ifdef OPENSSL_EXTRA\n        else {\n            PEMerr(0, PEM_R_BAD_PASSWORD_READ);\n        }\n#endif\n\n    #ifdef WOLFSSL_SMALL_STACK\n        XFREE(password, heap, DYNAMIC_TYPE_STRING);\n    #endif\n    }\n#endif /* WOLFSSL_ENCRYPTED_KEYS */\n\n    return ret;\n}\n\nint wc_PemToDer(const unsigned char* buff, long longSz, int type,\n              DerBuffer** pDer, void* heap, EncryptedInfo* info, int* eccKey)\n{\n    return PemToDer(buff, longSz, type, pDer, heap, info, eccKey);\n}\n\n\n/* our KeyPemToDer password callback, password in userData */\nstatic WC_INLINE int OurPasswordCb(char* passwd, int sz, int rw, void* userdata)\n{\n    (void)rw;\n\n    if (userdata == NULL)\n        return 0;\n\n    XSTRNCPY(passwd, (char*)userdata, sz);\n    return min((word32)sz, (word32)XSTRLEN((char*)userdata));\n}\n\n/* Return bytes written to buff or < 0 for error */\nint wc_KeyPemToDer(const unsigned char* pem, int pemSz,\n                        unsigned char* buff, int buffSz, const char* pass)\n{\n    int            eccKey = 0;\n    int            ret;\n    DerBuffer*     der = NULL;\n#ifdef WOLFSSL_SMALL_STACK\n    EncryptedInfo* info = NULL;\n#else\n    EncryptedInfo  info[1];\n#endif\n\n    WOLFSSL_ENTER(\"wc_KeyPemToDer\");\n\n    if (pem == NULL || buff == NULL || buffSz <= 0) {\n        WOLFSSL_MSG(\"Bad pem der args\");\n        return BAD_FUNC_ARG;\n    }\n\n#ifdef WOLFSSL_SMALL_STACK\n    info = (EncryptedInfo*)XMALLOC(sizeof(EncryptedInfo), NULL,\n                                   DYNAMIC_TYPE_ENCRYPTEDINFO);\n    if (info == NULL)\n        return MEMORY_E;\n#endif\n\n    XMEMSET(info, 0, sizeof(EncryptedInfo));\n    info->passwd_cb = OurPasswordCb;\n    info->passwd_userdata = (void*)pass;\n\n    ret = PemToDer(pem, pemSz, PRIVATEKEY_TYPE, &der, NULL, info, &eccKey);\n\n#ifdef WOLFSSL_SMALL_STACK\n    XFREE(info, NULL, DYNAMIC_TYPE_ENCRYPTEDINFO);\n#endif\n\n    if (ret < 0 || der == NULL) {\n        WOLFSSL_MSG(\"Bad Pem To Der\");\n    }\n    else {\n        if (der->length <= (word32)buffSz) {\n            XMEMCPY(buff, der->buffer, der->length);\n            ret = der->length;\n        }\n        else {\n            WOLFSSL_MSG(\"Bad der length\");\n            ret = BAD_FUNC_ARG;\n        }\n    }\n\n    FreeDer(&der);\n    return ret;\n}\n\n\n/* Return bytes written to buff or < 0 for error */\nint wc_CertPemToDer(const unsigned char* pem, int pemSz,\n                        unsigned char* buff, int buffSz, int type)\n{\n    int            eccKey = 0;\n    int            ret;\n    DerBuffer*     der = NULL;\n\n    WOLFSSL_ENTER(\"wc_CertPemToDer\");\n\n    if (pem == NULL || buff == NULL || buffSz <= 0) {\n        WOLFSSL_MSG(\"Bad pem der args\");\n        return BAD_FUNC_ARG;\n    }\n\n    if (type != CERT_TYPE && type != CA_TYPE && type != CERTREQ_TYPE) {\n        WOLFSSL_MSG(\"Bad cert type\");\n        return BAD_FUNC_ARG;\n    }\n\n\n    ret = PemToDer(pem, pemSz, type, &der, NULL, NULL, &eccKey);\n    if (ret < 0 || der == NULL) {\n        WOLFSSL_MSG(\"Bad Pem To Der\");\n    }\n    else {\n        if (der->length <= (word32)buffSz) {\n            XMEMCPY(buff, der->buffer, der->length);\n            ret = der->length;\n        }\n        else {\n            WOLFSSL_MSG(\"Bad der length\");\n            ret = BAD_FUNC_ARG;\n        }\n    }\n\n    FreeDer(&der);\n    return ret;\n}\n\n#endif /* WOLFSSL_PEM_TO_DER */\n#endif /* WOLFSSL_PEM_TO_DER || WOLFSSL_DER_TO_PEM */\n\n\n#ifdef WOLFSSL_PEM_TO_DER\n#if defined(WOLFSSL_CERT_EXT) || defined(WOLFSSL_PUB_PEM_TO_DER)\n/* Return bytes written to buff or < 0 for error */\nint wc_PubKeyPemToDer(const unsigned char* pem, int pemSz,\n                           unsigned char* buff, int buffSz)\n{\n    int ret;\n    DerBuffer* der = NULL;\n\n    WOLFSSL_ENTER(\"wc_PubKeyPemToDer\");\n\n    if (pem == NULL || buff == NULL || buffSz <= 0) {\n        WOLFSSL_MSG(\"Bad pem der args\");\n        return BAD_FUNC_ARG;\n    }\n\n    ret = PemToDer(pem, pemSz, PUBLICKEY_TYPE, &der, NULL, NULL, NULL);\n    if (ret < 0 || der == NULL) {\n        WOLFSSL_MSG(\"Bad Pem To Der\");\n    }\n    else {\n        if (der->length <= (word32)buffSz) {\n            XMEMCPY(buff, der->buffer, der->length);\n            ret = der->length;\n        }\n        else {\n            WOLFSSL_MSG(\"Bad der length\");\n            ret = BAD_FUNC_ARG;\n        }\n    }\n\n    FreeDer(&der);\n    return ret;\n}\n#endif /* WOLFSSL_CERT_EXT || WOLFSSL_PUB_PEM_TO_DER */\n#endif /* WOLFSSL_PEM_TO_DER */\n\n#ifndef NO_FILESYSTEM\n\n#ifdef WOLFSSL_CERT_GEN\n/* load pem cert from file into der buffer, return der size or error */\nint wc_PemCertToDer(const char* fileName, unsigned char* derBuf, int derSz)\n{\n#ifdef WOLFSSL_SMALL_STACK\n    byte   staticBuffer[1]; /* force XMALLOC */\n#else\n    byte   staticBuffer[FILE_BUFFER_SIZE];\n#endif\n    byte*  fileBuf = staticBuffer;\n    int    dynamic = 0;\n    int    ret     = 0;\n    long   sz      = 0;\n    XFILE  file;\n    DerBuffer* converted = NULL;\n\n    WOLFSSL_ENTER(\"wc_PemCertToDer\");\n\n    if (fileName == NULL) {\n        ret = BAD_FUNC_ARG;\n    }\n    else {\n        file = XFOPEN(fileName, \"rb\");\n        if (file == XBADFILE) {\n            ret = BUFFER_E;\n        }\n    }\n\n    if (ret == 0) {\n        if(XFSEEK(file, 0, XSEEK_END) != 0)\n            ret = BUFFER_E;\n        sz = XFTELL(file);\n        XREWIND(file);\n\n        if (sz <= 0) {\n            ret = BUFFER_E;\n        }\n        else if (sz > (long)sizeof(staticBuffer)) {\n        #ifdef WOLFSSL_STATIC_MEMORY\n            WOLFSSL_MSG(\"File was larger then static buffer\");\n            return MEMORY_E;\n        #endif\n            fileBuf = (byte*)XMALLOC(sz, NULL, DYNAMIC_TYPE_FILE);\n            if (fileBuf == NULL)\n                ret = MEMORY_E;\n            else\n                dynamic = 1;\n        }\n\n        if (ret == 0) {\n            if ((size_t)XFREAD(fileBuf, 1, sz, file) != (size_t)sz) {\n                ret = BUFFER_E;\n            }\n        #ifdef WOLFSSL_PEM_TO_DER\n            else {\n                ret = PemToDer(fileBuf, sz, CA_TYPE, &converted,  0, NULL,NULL);\n            }\n        #endif\n\n            if (ret == 0) {\n                if (converted->length < (word32)derSz) {\n                    XMEMCPY(derBuf, converted->buffer, converted->length);\n                    ret = converted->length;\n                }\n                else\n                    ret = BUFFER_E;\n            }\n\n            FreeDer(&converted);\n        }\n\n        XFCLOSE(file);\n        if (dynamic)\n            XFREE(fileBuf, NULL, DYNAMIC_TYPE_FILE);\n    }\n\n    return ret;\n}\n#endif /* WOLFSSL_CERT_GEN */\n\n#if defined(WOLFSSL_CERT_EXT) || defined(WOLFSSL_PUB_PEM_TO_DER)\n/* load pem public key from file into der buffer, return der size or error */\nint wc_PemPubKeyToDer(const char* fileName,\n                           unsigned char* derBuf, int derSz)\n{\n#ifdef WOLFSSL_SMALL_STACK\n    byte   staticBuffer[1]; /* force XMALLOC */\n#else\n    byte   staticBuffer[FILE_BUFFER_SIZE];\n#endif\n    byte*  fileBuf = staticBuffer;\n    int    dynamic = 0;\n    int    ret     = 0;\n    long   sz      = 0;\n    XFILE  file;\n    DerBuffer* converted = NULL;\n\n    WOLFSSL_ENTER(\"wc_PemPubKeyToDer\");\n\n    if (fileName == NULL) {\n        ret = BAD_FUNC_ARG;\n    }\n    else {\n        file = XFOPEN(fileName, \"rb\");\n        if (file == XBADFILE) {\n            ret = BUFFER_E;\n        }\n    }\n\n    if (ret == 0) {\n        if(XFSEEK(file, 0, XSEEK_END) != 0)\n            ret = BUFFER_E;\n        sz = XFTELL(file);\n        XREWIND(file);\n\n        if (sz <= 0) {\n            ret = BUFFER_E;\n        }\n        else if (sz > (long)sizeof(staticBuffer)) {\n        #ifdef WOLFSSL_STATIC_MEMORY\n            WOLFSSL_MSG(\"File was larger then static buffer\");\n            return MEMORY_E;\n        #endif\n            fileBuf = (byte*)XMALLOC(sz, NULL, DYNAMIC_TYPE_FILE);\n            if (fileBuf == NULL)\n                ret = MEMORY_E;\n            else\n                dynamic = 1;\n        }\n        if (ret == 0) {\n            if ((size_t)XFREAD(fileBuf, 1, sz, file) != (size_t)sz) {\n                ret = BUFFER_E;\n            }\n        #ifdef WOLFSSL_PEM_TO_DER\n            else {\n                ret = PemToDer(fileBuf, sz, PUBLICKEY_TYPE, &converted,\n                               0, NULL, NULL);\n            }\n        #endif\n\n            if (ret == 0) {\n                if (converted->length < (word32)derSz) {\n                    XMEMCPY(derBuf, converted->buffer, converted->length);\n                    ret = converted->length;\n                }\n                else\n                    ret = BUFFER_E;\n            }\n\n            FreeDer(&converted);\n        }\n\n        XFCLOSE(file);\n        if (dynamic)\n            XFREE(fileBuf, NULL, DYNAMIC_TYPE_FILE);\n    }\n\n    return ret;\n}\n#endif /* WOLFSSL_CERT_EXT || WOLFSSL_PUB_PEM_TO_DER */\n\n#endif /* !NO_FILESYSTEM */\n\n\n#if !defined(NO_RSA) && (defined(WOLFSSL_CERT_GEN) || \\\n    ((defined(WOLFSSL_KEY_GEN) || defined(OPENSSL_EXTRA)) && !defined(HAVE_USER_RSA)))\n/* USER RSA ifdef portions used instead of refactor in consideration for\n   possible fips build */\n/* Write a public RSA key to output */\nstatic int SetRsaPublicKey(byte* output, RsaKey* key,\n                           int outLen, int with_header)\n{\n#ifdef WOLFSSL_SMALL_STACK\n    byte* n = NULL;\n    byte* e = NULL;\n#else\n    byte n[MAX_RSA_INT_SZ];\n    byte e[MAX_RSA_E_SZ];\n#endif\n    byte seq[MAX_SEQ_SZ];\n    byte bitString[1 + MAX_LENGTH_SZ + 1];\n    int  nSz;\n    int  eSz;\n    int  seqSz;\n    int  bitStringSz;\n    int  idx;\n\n    if (output == NULL || key == NULL || outLen < MAX_SEQ_SZ)\n        return BAD_FUNC_ARG;\n\n    /* n */\n#ifdef WOLFSSL_SMALL_STACK\n    n = (byte*)XMALLOC(MAX_RSA_INT_SZ, key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n    if (n == NULL)\n        return MEMORY_E;\n#endif\n\n#ifdef HAVE_USER_RSA\n    nSz = SetASNIntRSA(key->n, n);\n#else\n    nSz = SetASNIntMP(&key->n, MAX_RSA_INT_SZ, n);\n#endif\n    if (nSz < 0) {\n#ifdef WOLFSSL_SMALL_STACK\n        XFREE(n, key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n#endif\n        return nSz;\n    }\n\n    /* e */\n#ifdef WOLFSSL_SMALL_STACK\n    e = (byte*)XMALLOC(MAX_RSA_E_SZ, key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n    if (e == NULL) {\n#ifdef WOLFSSL_SMALL_STACK\n        XFREE(n, key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n#endif\n        return MEMORY_E;\n    }\n#endif\n\n#ifdef HAVE_USER_RSA\n    eSz = SetASNIntRSA(key->e, e);\n#else\n    eSz = SetASNIntMP(&key->e, MAX_RSA_INT_SZ, e);\n#endif\n    if (eSz < 0) {\n#ifdef WOLFSSL_SMALL_STACK\n        XFREE(n, key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n        XFREE(e, key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n#endif\n        return eSz;\n    }\n\n    seqSz  = SetSequence(nSz + eSz, seq);\n\n    /* check output size */\n    if ( (seqSz + nSz + eSz) > outLen) {\n#ifdef WOLFSSL_SMALL_STACK\n        XFREE(n,    key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n        XFREE(e,    key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n#endif\n        return BUFFER_E;\n    }\n\n    /* headers */\n    if (with_header) {\n        int  algoSz;\n#ifdef WOLFSSL_SMALL_STACK\n        byte* algo;\n\n        algo = (byte*)XMALLOC(MAX_ALGO_SZ, key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n        if (algo == NULL) {\n            XFREE(n, key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n            XFREE(e, key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n            return MEMORY_E;\n        }\n#else\n        byte algo[MAX_ALGO_SZ];\n#endif\n        algoSz = SetAlgoID(RSAk, algo, oidKeyType, 0);\n        bitStringSz  = SetBitString(seqSz + nSz + eSz, 0, bitString);\n\n        idx = SetSequence(nSz + eSz + seqSz + bitStringSz + algoSz, output);\n\n        /* check output size */\n        if ( (idx + algoSz + bitStringSz + seqSz + nSz + eSz) > outLen) {\n            #ifdef WOLFSSL_SMALL_STACK\n                XFREE(n,    key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n                XFREE(e,    key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n                XFREE(algo, key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n            #endif\n\n            return BUFFER_E;\n        }\n\n        /* algo */\n        XMEMCPY(output + idx, algo, algoSz);\n        idx += algoSz;\n        /* bit string */\n        XMEMCPY(output + idx, bitString, bitStringSz);\n        idx += bitStringSz;\n#ifdef WOLFSSL_SMALL_STACK\n        XFREE(algo, key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n#endif\n    }\n    else\n        idx = 0;\n\n    /* seq */\n    XMEMCPY(output + idx, seq, seqSz);\n    idx += seqSz;\n    /* n */\n    XMEMCPY(output + idx, n, nSz);\n    idx += nSz;\n    /* e */\n    XMEMCPY(output + idx, e, eSz);\n    idx += eSz;\n\n#ifdef WOLFSSL_SMALL_STACK\n    XFREE(n,    key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n    XFREE(e,    key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n#endif\n\n    return idx;\n}\n\n#endif /* !NO_RSA && (WOLFSSL_CERT_GEN || (WOLFSSL_KEY_GEN &&\n                                           !HAVE_USER_RSA))) */\n\n#if !defined(NO_RSA) && (defined(WOLFSSL_CERT_GEN) || defined(OPENSSL_EXTRA))\nint wc_RsaPublicKeyDerSize(RsaKey* key, int with_header)\n{\n    int  idx = 0;\n    int  nSz, eSz, seqSz, bitStringSz, algoSz;\n\n    if (key == NULL)\n        return BAD_FUNC_ARG;\n\n    /* n */\n#ifdef HAVE_USER_RSA\n    nSz = SetASNIntRSA(key->n, NULL);\n#else\n    nSz = SetASNIntMP(&key->n, MAX_RSA_INT_SZ, NULL);\n#endif\n    if (nSz < 0) {\n        return nSz;\n    }\n\n    /* e */\n#ifdef HAVE_USER_RSA\n    eSz = SetASNIntRSA(key->e, NULL);\n#else\n    eSz = SetASNIntMP(&key->e, MAX_RSA_INT_SZ, NULL);\n#endif\n    if (eSz < 0) {\n        return eSz;\n    }\n\n    seqSz  = SetSequence(nSz + eSz, NULL);\n\n    /* headers */\n    if (with_header) {\n        algoSz = SetAlgoID(RSAk, NULL, oidKeyType, 0);\n        bitStringSz = SetBitString(seqSz + nSz + eSz, 0, NULL);\n\n        idx += SetSequence(nSz + eSz + seqSz + bitStringSz + algoSz, NULL);\n\n        /* algo */\n        idx += algoSz;\n        /* bit string */\n        idx += bitStringSz;\n    }\n\n    /* seq */\n    idx += seqSz;\n    /* n */\n    idx += nSz;\n    /* e */\n    idx += eSz;\n\n    return idx;\n}\n\n#endif /* !NO_RSA && WOLFSSL_CERT_GEN */\n\n\n#if defined(WOLFSSL_KEY_GEN) && !defined(NO_RSA) && !defined(HAVE_USER_RSA)\n\nstatic mp_int* GetRsaInt(RsaKey* key, int idx)\n{\n    if (idx == 0)\n        return &key->n;\n    if (idx == 1)\n        return &key->e;\n    if (idx == 2)\n        return &key->d;\n    if (idx == 3)\n        return &key->p;\n    if (idx == 4)\n        return &key->q;\n    if (idx == 5)\n        return &key->dP;\n    if (idx == 6)\n        return &key->dQ;\n    if (idx == 7)\n        return &key->u;\n\n    return NULL;\n}\n\n\n/* Release Tmp RSA resources */\nstatic WC_INLINE void FreeTmpRsas(byte** tmps, void* heap)\n{\n    int i;\n\n    (void)heap;\n\n    for (i = 0; i < RSA_INTS; i++)\n        XFREE(tmps[i], heap, DYNAMIC_TYPE_RSA);\n}\n\n\n/* Convert RsaKey key to DER format, write to output (inLen), return bytes\n   written */\nint wc_RsaKeyToDer(RsaKey* key, byte* output, word32 inLen)\n{\n    word32 seqSz, verSz, rawLen, intTotalLen = 0;\n    word32 sizes[RSA_INTS];\n    int    i, j, outLen, ret = 0, mpSz;\n\n    byte  seq[MAX_SEQ_SZ];\n    byte  ver[MAX_VERSION_SZ];\n    byte* tmps[RSA_INTS];\n\n    if (!key)\n        return BAD_FUNC_ARG;\n\n    if (key->type != RSA_PRIVATE)\n        return BAD_FUNC_ARG;\n\n    for (i = 0; i < RSA_INTS; i++)\n        tmps[i] = NULL;\n\n    /* write all big ints from key to DER tmps */\n    for (i = 0; i < RSA_INTS; i++) {\n        mp_int* keyInt = GetRsaInt(key, i);\n\n        rawLen = mp_unsigned_bin_size(keyInt) + 1;\n        tmps[i] = (byte*)XMALLOC(rawLen + MAX_SEQ_SZ, key->heap,\n                                 DYNAMIC_TYPE_RSA);\n        if (tmps[i] == NULL) {\n            ret = MEMORY_E;\n            break;\n        }\n\n        mpSz = SetASNIntMP(keyInt, MAX_RSA_INT_SZ, tmps[i]);\n        if (mpSz < 0) {\n            ret = mpSz;\n            break;\n        }\n        intTotalLen += (sizes[i] = mpSz);\n    }\n\n    if (ret != 0) {\n        FreeTmpRsas(tmps, key->heap);\n        return ret;\n    }\n\n    /* make headers */\n    verSz = SetMyVersion(0, ver, FALSE);\n    seqSz = SetSequence(verSz + intTotalLen, seq);\n\n    outLen = seqSz + verSz + intTotalLen;\n    if (output) {\n        if (outLen > (int)inLen) {\n            FreeTmpRsas(tmps, key->heap);\n            return BAD_FUNC_ARG;\n        }\n\n        /* write to output */\n        XMEMCPY(output, seq, seqSz);\n        j = seqSz;\n        XMEMCPY(output + j, ver, verSz);\n        j += verSz;\n\n        for (i = 0; i < RSA_INTS; i++) {\n            XMEMCPY(output + j, tmps[i], sizes[i]);\n            j += sizes[i];\n        }\n    }\n    FreeTmpRsas(tmps, key->heap);\n\n    return outLen;\n}\n#endif\n\n#if (defined(WOLFSSL_KEY_GEN) || defined(OPENSSL_EXTRA)) && !defined(NO_RSA) && !defined(HAVE_USER_RSA)\n/* Convert Rsa Public key to DER format, write to output (inLen), return bytes\n   written */\nint wc_RsaKeyToPublicDer(RsaKey* key, byte* output, word32 inLen)\n{\n    return SetRsaPublicKey(output, key, inLen, 1);\n}\n\n#endif /* (WOLFSSL_KEY_GEN || OPENSSL_EXTRA) && !NO_RSA && !HAVE_USER_RSA */\n\n\n#ifdef WOLFSSL_CERT_GEN\n\n/* Initialize and Set Certificate defaults:\n   version    = 3 (0x2)\n   serial     = 0\n   sigType    = SHA_WITH_RSA\n   issuer     = blank\n   daysValid  = 500\n   selfSigned = 1 (true) use subject as issuer\n   subject    = blank\n*/\nint wc_InitCert(Cert* cert)\n{\n#ifdef WOLFSSL_MULTI_ATTRIB\n    int i = 0;\n#endif\n    if (cert == NULL) {\n        return BAD_FUNC_ARG;\n    }\n\n    XMEMSET(cert, 0, sizeof(Cert));\n\n    cert->version    = 2;   /* version 3 is hex 2 */\n#ifndef NO_SHA\n    cert->sigType    = CTC_SHAwRSA;\n#elif !defined(NO_SHA256)\n    cert->sigType    = CTC_SHA256wRSA;\n#else\n    cert->sigType    = 0;\n#endif\n    cert->daysValid  = 500;\n    cert->selfSigned = 1;\n    cert->keyType    = RSA_KEY;\n\n    cert->issuer.countryEnc = CTC_PRINTABLE;\n    cert->issuer.stateEnc = CTC_UTF8;\n    cert->issuer.localityEnc = CTC_UTF8;\n    cert->issuer.surEnc = CTC_UTF8;\n    cert->issuer.orgEnc = CTC_UTF8;\n    cert->issuer.unitEnc = CTC_UTF8;\n    cert->issuer.commonNameEnc = CTC_UTF8;\n\n    cert->subject.countryEnc = CTC_PRINTABLE;\n    cert->subject.stateEnc = CTC_UTF8;\n    cert->subject.localityEnc = CTC_UTF8;\n    cert->subject.surEnc = CTC_UTF8;\n    cert->subject.orgEnc = CTC_UTF8;\n    cert->subject.unitEnc = CTC_UTF8;\n    cert->subject.commonNameEnc = CTC_UTF8;\n\n#ifdef WOLFSSL_MULTI_ATTRIB\n    for (i = 0; i < CTC_MAX_ATTRIB; i++) {\n        cert->issuer.name[i].type   = CTC_UTF8;\n        cert->subject.name[i].type  = CTC_UTF8;\n    }\n#endif /* WOLFSSL_MULTI_ATTRIB */\n\n#ifdef WOLFSSL_HEAP_TEST\n    cert->heap = (void*)WOLFSSL_HEAP_TEST;\n#endif\n\n    return 0;\n}\n\n\n/* DER encoded x509 Certificate */\ntypedef struct DerCert {\n    byte size[MAX_LENGTH_SZ];          /* length encoded */\n    byte version[MAX_VERSION_SZ];      /* version encoded */\n    byte serial[(int)CTC_SERIAL_SIZE + (int)MAX_LENGTH_SZ]; /* serial number encoded */\n    byte sigAlgo[MAX_ALGO_SZ];         /* signature algo encoded */\n    byte issuer[ASN_NAME_MAX];         /* issuer  encoded */\n    byte subject[ASN_NAME_MAX];        /* subject encoded */\n    byte validity[MAX_DATE_SIZE*2 + MAX_SEQ_SZ*2];  /* before and after dates */\n    byte publicKey[MAX_PUBLIC_KEY_SZ]; /* rsa / ntru public key encoded */\n    byte ca[MAX_CA_SZ];                /* basic constraint CA true size */\n    byte extensions[MAX_EXTENSIONS_SZ]; /* all extensions */\n#ifdef WOLFSSL_CERT_EXT\n    byte skid[MAX_KID_SZ];             /* Subject Key Identifier extension */\n    byte akid[MAX_KID_SZ];             /* Authority Key Identifier extension */\n    byte keyUsage[MAX_KEYUSAGE_SZ];    /* Key Usage extension */\n    byte extKeyUsage[MAX_EXTKEYUSAGE_SZ]; /* Extended Key Usage extension */\n    byte certPolicies[MAX_CERTPOL_NB*MAX_CERTPOL_SZ]; /* Certificate Policies */\n#endif\n#ifdef WOLFSSL_CERT_REQ\n    byte attrib[MAX_ATTRIB_SZ];        /* Cert req attributes encoded */\n#endif\n#ifdef WOLFSSL_ALT_NAMES\n    byte altNames[CTC_MAX_ALT_SIZE];   /* Alternative Names encoded */\n#endif\n    int  sizeSz;                       /* encoded size length */\n    int  versionSz;                    /* encoded version length */\n    int  serialSz;                     /* encoded serial length */\n    int  sigAlgoSz;                    /* encoded sig algo length */\n    int  issuerSz;                     /* encoded issuer length */\n    int  subjectSz;                    /* encoded subject length */\n    int  validitySz;                   /* encoded validity length */\n    int  publicKeySz;                  /* encoded public key length */\n    int  caSz;                         /* encoded CA extension length */\n#ifdef WOLFSSL_CERT_EXT\n    int  skidSz;                       /* encoded SKID extension length */\n    int  akidSz;                       /* encoded SKID extension length */\n    int  keyUsageSz;                   /* encoded KeyUsage extension length */\n    int  extKeyUsageSz;                /* encoded ExtendedKeyUsage extension length */\n    int  certPoliciesSz;               /* encoded CertPolicies extension length*/\n#endif\n#ifdef WOLFSSL_ALT_NAMES\n    int  altNamesSz;                   /* encoded AltNames extension length */\n#endif\n    int  extensionsSz;                 /* encoded extensions total length */\n    int  total;                        /* total encoded lengths */\n#ifdef WOLFSSL_CERT_REQ\n    int  attribSz;\n#endif\n} DerCert;\n\n\n#ifdef WOLFSSL_CERT_REQ\n\n/* Write a set header to output */\nstatic word32 SetPrintableString(word32 len, byte* output)\n{\n    output[0] = ASN_PRINTABLE_STRING;\n    return SetLength(len, output + 1) + 1;\n}\n\nstatic word32 SetUTF8String(word32 len, byte* output)\n{\n    output[0] = ASN_UTF8STRING;\n    return SetLength(len, output + 1) + 1;\n}\n\n#endif /* WOLFSSL_CERT_REQ */\n\n\n#ifndef WOLFSSL_CERT_GEN_CACHE\n/* wc_SetCert_Free is only public when WOLFSSL_CERT_GEN_CACHE is not defined */\nstatic\n#endif\nvoid wc_SetCert_Free(Cert* cert)\n{\n    if (cert != NULL) {\n        cert->der = NULL;\n        if (cert->decodedCert) {\n            FreeDecodedCert((DecodedCert*)cert->decodedCert);\n\n            XFREE(cert->decodedCert, cert->heap, DYNAMIC_TYPE_DCERT);\n            cert->decodedCert = NULL;\n        }\n    }\n}\n\nstatic int wc_SetCert_LoadDer(Cert* cert, const byte* der, word32 derSz)\n{\n    int ret;\n\n    if (cert == NULL) {\n        ret = BAD_FUNC_ARG;\n    }\n    else {\n        /* Allocate DecodedCert struct and Zero */\n        cert->decodedCert = (void*)XMALLOC(sizeof(DecodedCert), cert->heap,\n            DYNAMIC_TYPE_DCERT);\n\n        if (cert->decodedCert == NULL) {\n            ret = MEMORY_E;\n        }\n        else {\n            XMEMSET(cert->decodedCert, 0, sizeof(DecodedCert));\n\n            InitDecodedCert((DecodedCert*)cert->decodedCert, der, derSz,\n                    cert->heap);\n            ret = ParseCertRelative((DecodedCert*)cert->decodedCert,\n                    CERT_TYPE, 0, NULL);\n            if (ret >= 0) {\n                cert->der = (byte*)der;\n            }\n            else {\n                wc_SetCert_Free(cert);\n            }\n        }\n    }\n\n    return ret;\n}\n\n#endif /* WOLFSSL_CERT_GEN */\n\n\n#if defined(HAVE_ECC) && defined(HAVE_ECC_KEY_EXPORT)\n\n/* Write a public ECC key to output */\nstatic int SetEccPublicKey(byte* output, ecc_key* key, int with_header)\n{\n    byte bitString[1 + MAX_LENGTH_SZ + 1];\n    int  algoSz;\n    int  curveSz;\n    int  bitStringSz;\n    int  idx;\n    word32 pubSz = ECC_BUFSIZE;\n#ifdef WOLFSSL_SMALL_STACK\n    byte* algo = NULL;\n    byte* curve = NULL;\n    byte* pub;\n#else\n    byte algo[MAX_ALGO_SZ];\n    byte curve[MAX_ALGO_SZ];\n    byte pub[ECC_BUFSIZE];\n#endif\n    int ret;\n\n#ifdef WOLFSSL_SMALL_STACK\n    pub = (byte*)XMALLOC(ECC_BUFSIZE, key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n    if (pub == NULL)\n        return MEMORY_E;\n#endif\n\n#if defined(HAVE_SELFTEST) || defined(HAVE_FIPS)\n    /* older version of ecc.c can not handle dp being NULL */\n    if (key != NULL && key->dp == NULL) {\n        ret = BAD_FUNC_ARG;\n    }\n    else {\n        ret = wc_ecc_export_x963(key, pub, &pubSz);\n    }\n#else\n    ret = wc_ecc_export_x963(key, pub, &pubSz);\n#endif\n    if (ret != 0) {\n#ifdef WOLFSSL_SMALL_STACK\n        XFREE(pub, key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n#endif\n        return ret;\n    }\n\n    /* headers */\n    if (with_header) {\n#ifdef WOLFSSL_SMALL_STACK\n        curve = (byte*)XMALLOC(MAX_ALGO_SZ, key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n        if (curve == NULL) {\n            XFREE(pub, key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n            return MEMORY_E;\n        }\n#endif\n        curveSz = SetCurve(key, curve);\n        if (curveSz <= 0) {\n#ifdef WOLFSSL_SMALL_STACK\n            XFREE(curve, key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n            XFREE(pub,   key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n#endif\n            return curveSz;\n        }\n\n#ifdef WOLFSSL_SMALL_STACK\n        algo = (byte*)XMALLOC(MAX_ALGO_SZ, key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n        if (algo == NULL) {\n            XFREE(curve, key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n            XFREE(pub,   key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n            return MEMORY_E;\n        }\n#endif\n        algoSz  = SetAlgoID(ECDSAk, algo, oidKeyType, curveSz);\n\n        bitStringSz = SetBitString(pubSz, 0, bitString);\n\n        idx = SetSequence(pubSz + curveSz + bitStringSz + algoSz, output);\n        /* algo */\n        if (output)\n            XMEMCPY(output + idx, algo, algoSz);\n        idx += algoSz;\n        /* curve */\n        if (output)\n            XMEMCPY(output + idx, curve, curveSz);\n        idx += curveSz;\n        /* bit string */\n        if (output)\n            XMEMCPY(output + idx, bitString, bitStringSz);\n        idx += bitStringSz;\n    }\n    else\n        idx = 0;\n\n    /* pub */\n    if (output)\n        XMEMCPY(output + idx, pub, pubSz);\n    idx += pubSz;\n\n#ifdef WOLFSSL_SMALL_STACK\n    if (with_header) {\n        XFREE(algo,  key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n        XFREE(curve, key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n    }\n    XFREE(pub,   key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n#endif\n\n    return idx;\n}\n\n\n/* returns the size of buffer used, the public ECC key in DER format is stored\n   in output buffer\n   with_AlgCurve is a flag for when to include a header that has the Algorithm\n   and Curve information */\nint wc_EccPublicKeyToDer(ecc_key* key, byte* output, word32 inLen,\n                                                              int with_AlgCurve)\n{\n    word32 infoSz = 0;\n    word32 keySz  = 0;\n    int ret;\n\n    if (key == NULL) {\n        return BAD_FUNC_ARG;\n    }\n\n    if (with_AlgCurve) {\n        /* buffer space for algorithm/curve */\n        infoSz += MAX_SEQ_SZ;\n        infoSz += 2 * MAX_ALGO_SZ;\n\n        /* buffer space for public key sequence */\n        infoSz += MAX_SEQ_SZ;\n        infoSz += TRAILING_ZERO;\n    }\n\n#if defined(HAVE_SELFTEST) || defined(HAVE_FIPS)\n    /* older version of ecc.c can not handle dp being NULL */\n    if (key->dp == NULL) {\n        keySz = 1 + 2 * MAX_ECC_BYTES;\n        ret = LENGTH_ONLY_E;\n    }\n    else {\n        ret = wc_ecc_export_x963(key, NULL, &keySz);\n    }\n#else\n    ret = wc_ecc_export_x963(key, NULL, &keySz);\n#endif\n    if (ret != LENGTH_ONLY_E) {\n        WOLFSSL_MSG(\"Error in getting ECC public key size\");\n        return ret;\n    }\n\n    /* if output null then just return size */\n    if (output == NULL) {\n        return keySz + infoSz;\n    }\n\n    if (inLen < keySz + infoSz) {\n        return BUFFER_E;\n    }\n\n    return SetEccPublicKey(output, key, with_AlgCurve);\n}\n\nint wc_EccPublicKeyDerSize(ecc_key* key, int with_AlgCurve)\n{\n    return wc_EccPublicKeyToDer(key, NULL, 0, with_AlgCurve);\n}\n\n#endif /* HAVE_ECC && HAVE_ECC_KEY_EXPORT */\n\n#if defined(HAVE_ED25519) && (defined(WOLFSSL_CERT_GEN) || \\\n                              defined(WOLFSSL_KEY_GEN))\n\n/* Write a public ECC key to output */\nstatic int SetEd25519PublicKey(byte* output, ed25519_key* key, int with_header)\n{\n    byte bitString[1 + MAX_LENGTH_SZ + 1];\n    int  algoSz;\n    int  bitStringSz;\n    int  idx;\n    word32 pubSz = ED25519_PUB_KEY_SIZE;\n#ifdef WOLFSSL_SMALL_STACK\n    byte* algo = NULL;\n    byte* pub;\n#else\n    byte algo[MAX_ALGO_SZ];\n    byte pub[ED25519_PUB_KEY_SIZE];\n#endif\n\n#ifdef WOLFSSL_SMALL_STACK\n    pub = (byte*)XMALLOC(ECC_BUFSIZE, NULL, DYNAMIC_TYPE_TMP_BUFFER);\n    if (pub == NULL)\n        return MEMORY_E;\n#endif\n\n    idx = wc_ed25519_export_public(key, pub, &pubSz);\n    if (idx != 0) {\n#ifdef WOLFSSL_SMALL_STACK\n        XFREE(pub, NULL, DYNAMIC_TYPE_TMP_BUFFER);\n#endif\n        return idx;\n    }\n\n    /* headers */\n    if (with_header) {\n#ifdef WOLFSSL_SMALL_STACK\n        algo = (byte*)XMALLOC(MAX_ALGO_SZ, NULL, DYNAMIC_TYPE_TMP_BUFFER);\n        if (algo == NULL) {\n            XFREE(pub, NULL, DYNAMIC_TYPE_TMP_BUFFER);\n            return MEMORY_E;\n        }\n#endif\n        algoSz  = SetAlgoID(ED25519k, algo, oidKeyType, 0);\n\n        bitStringSz = SetBitString(pubSz, 0, bitString);\n\n        idx = SetSequence(pubSz + bitStringSz + algoSz, output);\n        /* algo */\n        XMEMCPY(output + idx, algo, algoSz);\n        idx += algoSz;\n        /* bit string */\n        XMEMCPY(output + idx, bitString, bitStringSz);\n        idx += bitStringSz;\n    }\n    else\n        idx = 0;\n\n    /* pub */\n    XMEMCPY(output + idx, pub, pubSz);\n    idx += pubSz;\n\n#ifdef WOLFSSL_SMALL_STACK\n    if (with_header) {\n        XFREE(algo, NULL, DYNAMIC_TYPE_TMP_BUFFER);\n    }\n    XFREE(pub, NULL, DYNAMIC_TYPE_TMP_BUFFER);\n#endif\n\n    return idx;\n}\n\nint wc_Ed25519PublicKeyToDer(ed25519_key* key, byte* output, word32 inLen,\n                                                                    int withAlg)\n{\n    word32 infoSz = 0;\n    word32 keySz  = 0;\n    int ret;\n\n    if (output == NULL || key == NULL) {\n        return BAD_FUNC_ARG;\n    }\n\n    if (withAlg) {\n        /* buffer space for algorithm */\n        infoSz += MAX_SEQ_SZ;\n        infoSz += MAX_ALGO_SZ;\n\n        /* buffer space for public key sequence */\n        infoSz += MAX_SEQ_SZ;\n        infoSz += TRAILING_ZERO;\n    }\n\n    if ((ret = wc_ed25519_export_public(key, output, &keySz)) != BUFFER_E) {\n        WOLFSSL_MSG(\"Error in getting ECC public key size\");\n        return ret;\n    }\n\n    if (inLen < keySz + infoSz) {\n        return BUFFER_E;\n    }\n\n    return SetEd25519PublicKey(output, key, withAlg);\n}\n#endif /* HAVE_ED25519 && (WOLFSSL_CERT_GEN || WOLFSSL_KEY_GEN) */\n#if defined(HAVE_ED448) && (defined(WOLFSSL_CERT_GEN) || \\\n                                                       defined(WOLFSSL_KEY_GEN))\n\n/* Write a public ECC key to output */\nstatic int SetEd448PublicKey(byte* output, ed448_key* key, int with_header)\n{\n    byte bitString[1 + MAX_LENGTH_SZ + 1];\n    int  algoSz;\n    int  bitStringSz;\n    int  idx;\n    word32 pubSz = ED448_PUB_KEY_SIZE;\n#ifdef WOLFSSL_SMALL_STACK\n    byte* algo = NULL;\n    byte* pub = NULL;\n#else\n    byte algo[MAX_ALGO_SZ];\n    byte pub[ED448_PUB_KEY_SIZE];\n#endif\n\n#ifdef WOLFSSL_SMALL_STACK\n    pub = (byte*)XMALLOC(ECC_BUFSIZE, NULL, DYNAMIC_TYPE_TMP_BUFFER);\n    if (pub == NULL)\n        return MEMORY_E;\n#endif\n\n    idx = wc_ed448_export_public(key, pub, &pubSz);\n    if (idx != 0) {\n#ifdef WOLFSSL_SMALL_STACK\n        XFREE(pub, NULL, DYNAMIC_TYPE_TMP_BUFFER);\n#endif\n        return idx;\n    }\n\n    /* headers */\n    if (with_header) {\n#ifdef WOLFSSL_SMALL_STACK\n        algo = (byte*)XMALLOC(MAX_ALGO_SZ, NULL, DYNAMIC_TYPE_TMP_BUFFER);\n        if (algo == NULL) {\n            XFREE(pub, NULL, DYNAMIC_TYPE_TMP_BUFFER);\n            return MEMORY_E;\n        }\n#endif\n        algoSz  = SetAlgoID(ED448k, algo, oidKeyType, 0);\n\n        bitStringSz = SetBitString(pubSz, 0, bitString);\n\n        idx = SetSequence(pubSz + bitStringSz + algoSz, output);\n        /* algo */\n        XMEMCPY(output + idx, algo, algoSz);\n        idx += algoSz;\n        /* bit string */\n        XMEMCPY(output + idx, bitString, bitStringSz);\n        idx += bitStringSz;\n    }\n    else\n        idx = 0;\n\n    /* pub */\n    XMEMCPY(output + idx, pub, pubSz);\n    idx += pubSz;\n\n#ifdef WOLFSSL_SMALL_STACK\n    if (with_header) {\n        XFREE(algo, NULL, DYNAMIC_TYPE_TMP_BUFFER);\n    }\n    XFREE(pub, NULL, DYNAMIC_TYPE_TMP_BUFFER);\n#endif\n\n    return idx;\n}\n\nint wc_Ed448PublicKeyToDer(ed448_key* key, byte* output, word32 inLen,\n                                                                    int withAlg)\n{\n    word32 infoSz = 0;\n    word32 keySz  = 0;\n    int ret;\n\n    if (output == NULL || key == NULL) {\n        return BAD_FUNC_ARG;\n    }\n\n    if (withAlg) {\n        /* buffer space for algorithm */\n        infoSz += MAX_SEQ_SZ;\n        infoSz += MAX_ALGO_SZ;\n\n        /* buffer space for public key sequence */\n        infoSz += MAX_SEQ_SZ;\n        infoSz += TRAILING_ZERO;\n    }\n\n    if ((ret = wc_ed448_export_public(key, output, &keySz)) != BUFFER_E) {\n        WOLFSSL_MSG(\"Error in getting ECC public key size\");\n        return ret;\n    }\n\n    if (inLen < keySz + infoSz) {\n        return BUFFER_E;\n    }\n\n    return SetEd448PublicKey(output, key, withAlg);\n}\n#endif /* HAVE_ED448 && (WOLFSSL_CERT_GEN || WOLFSSL_KEY_GEN) */\n\n\n#ifdef WOLFSSL_CERT_GEN\n\n#ifndef NO_ASN_TIME\nstatic WC_INLINE byte itob(int number)\n{\n    return (byte)number + 0x30;\n}\n\n\n/* write time to output, format */\nstatic void SetTime(struct tm* date, byte* output)\n{\n    int i = 0;\n\n    output[i++] = itob((date->tm_year % 10000) / 1000);\n    output[i++] = itob((date->tm_year % 1000)  /  100);\n    output[i++] = itob((date->tm_year % 100)   /   10);\n    output[i++] = itob( date->tm_year % 10);\n\n    output[i++] = itob(date->tm_mon / 10);\n    output[i++] = itob(date->tm_mon % 10);\n\n    output[i++] = itob(date->tm_mday / 10);\n    output[i++] = itob(date->tm_mday % 10);\n\n    output[i++] = itob(date->tm_hour / 10);\n    output[i++] = itob(date->tm_hour % 10);\n\n    output[i++] = itob(date->tm_min / 10);\n    output[i++] = itob(date->tm_min % 10);\n\n    output[i++] = itob(date->tm_sec / 10);\n    output[i++] = itob(date->tm_sec % 10);\n\n    output[i] = 'Z';  /* Zulu profile */\n}\n#endif\n\n#ifdef WOLFSSL_ALT_NAMES\n\n/* Copy Dates from cert, return bytes written */\nstatic int CopyValidity(byte* output, Cert* cert)\n{\n    int seqSz;\n\n    WOLFSSL_ENTER(\"CopyValidity\");\n\n    /* headers and output */\n    seqSz = SetSequence(cert->beforeDateSz + cert->afterDateSz, output);\n    if (output) {\n        XMEMCPY(output + seqSz, cert->beforeDate, cert->beforeDateSz);\n        XMEMCPY(output + seqSz + cert->beforeDateSz, cert->afterDate,\n                                                     cert->afterDateSz);\n    }\n    return seqSz + cert->beforeDateSz + cert->afterDateSz;\n}\n\n#endif\n\n/* Get Which Name from index */\nconst char* GetOneCertName(CertName* name, int idx)\n{\n    switch (idx) {\n    case 0:\n       return name->country;\n\n    case 1:\n       return name->state;\n\n    case 2:\n       return name->locality;\n\n    case 3:\n       return name->sur;\n\n    case 4:\n       return name->org;\n\n    case 5:\n       return name->unit;\n\n    case 6:\n       return name->commonName;\n\n    case 7:\n       return name->serialDev;\n\n#ifdef WOLFSSL_CERT_EXT\n    case 8:\n       return name->busCat;\n\n    case 9:\n#else\n    case 8:\n#endif\n       return name->email;\n\n    default:\n       return 0;\n    }\n}\n\n\n/* Get Which Name Encoding from index */\nstatic char GetNameType(CertName* name, int idx)\n{\n    switch (idx) {\n    case 0:\n       return name->countryEnc;\n\n    case 1:\n       return name->stateEnc;\n\n    case 2:\n       return name->localityEnc;\n\n    case 3:\n       return name->surEnc;\n\n    case 4:\n       return name->orgEnc;\n\n    case 5:\n       return name->unitEnc;\n\n    case 6:\n       return name->commonNameEnc;\n\n    case 7:\n       return name->serialDevEnc;\n\n#ifdef WOLFSSL_CERT_EXT\n    case 8:\n       return name->busCatEnc;\n\n    case 9:\n#else\n    case 8:\n#endif\n        /* FALL THROUGH */\n        /* The last index, email name, does not have encoding type.\n           The empty case here is to keep track of it for future reference. */\n    default:\n       return 0;\n    }\n}\n\n\n/* Get ASN Name from index */\nbyte GetCertNameId(int idx)\n{\n    switch (idx) {\n    case 0:\n       return ASN_COUNTRY_NAME;\n\n    case 1:\n       return ASN_STATE_NAME;\n\n    case 2:\n       return ASN_LOCALITY_NAME;\n\n    case 3:\n       return ASN_SUR_NAME;\n\n    case 4:\n       return ASN_ORG_NAME;\n\n    case 5:\n       return ASN_ORGUNIT_NAME;\n\n    case 6:\n       return ASN_COMMON_NAME;\n\n    case 7:\n       return ASN_SERIAL_NUMBER;\n\n#ifdef WOLFSSL_CERT_EXT\n    case 8:\n        return ASN_BUS_CAT;\n\n    case 9:\n#else\n    case 8:\n#endif\n        return ASN_EMAIL_NAME;\n\n    default:\n       return 0;\n    }\n}\n\n\n/*\n Extensions ::= SEQUENCE OF Extension\n\n Extension ::= SEQUENCE {\n extnId     OBJECT IDENTIFIER,\n critical   BOOLEAN DEFAULT FALSE,\n extnValue  OCTET STRING }\n */\n\n/* encode all extensions, return total bytes written */\nstatic int SetExtensions(byte* out, word32 outSz, int *IdxInOut,\n                         const byte* ext, int extSz)\n{\n    if (out == NULL || IdxInOut == NULL || ext == NULL)\n        return BAD_FUNC_ARG;\n\n    if (outSz < (word32)(*IdxInOut+extSz))\n        return BUFFER_E;\n\n    XMEMCPY(&out[*IdxInOut], ext, extSz);  /* extensions */\n    *IdxInOut += extSz;\n\n    return *IdxInOut;\n}\n\n/* encode extensions header, return total bytes written */\nstatic int SetExtensionsHeader(byte* out, word32 outSz, int extSz)\n{\n    byte sequence[MAX_SEQ_SZ];\n    byte len[MAX_LENGTH_SZ];\n    int seqSz, lenSz, idx = 0;\n\n    if (out == NULL)\n        return BAD_FUNC_ARG;\n\n    if (outSz < 3)\n        return BUFFER_E;\n\n    seqSz = SetSequence(extSz, sequence);\n\n    /* encode extensions length provided */\n    lenSz = SetLength(extSz+seqSz, len);\n\n    if (outSz < (word32)(lenSz+seqSz+1))\n        return BUFFER_E;\n\n    out[idx++] = ASN_EXTENSIONS; /* extensions id */\n    XMEMCPY(&out[idx], len, lenSz);  /* length */\n    idx += lenSz;\n\n    XMEMCPY(&out[idx], sequence, seqSz);  /* sequence */\n    idx += seqSz;\n\n    return idx;\n}\n\n\n/* encode CA basic constraint true, return total bytes written */\nstatic int SetCa(byte* out, word32 outSz)\n{\n    const byte ca[] = { 0x30, 0x0c, 0x06, 0x03, 0x55, 0x1d, 0x13, 0x04,\n                               0x05, 0x30, 0x03, 0x01, 0x01, 0xff };\n\n    if (out == NULL)\n        return BAD_FUNC_ARG;\n\n    if (outSz < sizeof(ca))\n        return BUFFER_E;\n\n    XMEMCPY(out, ca, sizeof(ca));\n\n    return (int)sizeof(ca);\n}\n\n\n#ifdef WOLFSSL_CERT_EXT\n/* encode OID and associated value, return total bytes written */\nstatic int SetOidValue(byte* out, word32 outSz, const byte *oid, word32 oidSz,\n                       byte *in, word32 inSz)\n{\n    int idx = 0;\n\n    if (out == NULL || oid == NULL || in == NULL)\n        return BAD_FUNC_ARG;\n\n    if (outSz < 3)\n        return BUFFER_E;\n\n    /* sequence,  + 1 => byte to put value size */\n    idx = SetSequence(inSz + oidSz + 1, out);\n\n    if ((idx + inSz + oidSz + 1) > outSz)\n        return BUFFER_E;\n\n    XMEMCPY(out+idx, oid, oidSz);\n    idx += oidSz;\n    out[idx++] = (byte)inSz;\n    XMEMCPY(out+idx, in, inSz);\n\n    return (idx+inSz);\n}\n\n/* encode Subject Key Identifier, return total bytes written\n * RFC5280 : non-critical */\nstatic int SetSKID(byte* output, word32 outSz, const byte *input, word32 length)\n{\n    byte skid_len[1 + MAX_LENGTH_SZ];\n    byte skid_enc_len[MAX_LENGTH_SZ];\n    int idx = 0, skid_lenSz, skid_enc_lenSz;\n    const byte skid_oid[] = { 0x06, 0x03, 0x55, 0x1d, 0x0e, 0x04 };\n\n    if (output == NULL || input == NULL)\n        return BAD_FUNC_ARG;\n\n    /* Octet String header */\n    skid_lenSz = SetOctetString(length, skid_len);\n\n    /* length of encoded value */\n    skid_enc_lenSz = SetLength(length + skid_lenSz, skid_enc_len);\n\n    if (outSz < 3)\n        return BUFFER_E;\n\n    idx = SetSequence(length + sizeof(skid_oid) + skid_lenSz + skid_enc_lenSz,\n                      output);\n\n    if ((length + sizeof(skid_oid) + skid_lenSz + skid_enc_lenSz) > outSz)\n        return BUFFER_E;\n\n    /* put oid */\n    XMEMCPY(output+idx, skid_oid, sizeof(skid_oid));\n    idx += sizeof(skid_oid);\n\n    /* put encoded len */\n    XMEMCPY(output+idx, skid_enc_len, skid_enc_lenSz);\n    idx += skid_enc_lenSz;\n\n    /* put octet header */\n    XMEMCPY(output+idx, skid_len, skid_lenSz);\n    idx += skid_lenSz;\n\n    /* put value */\n    XMEMCPY(output+idx, input, length);\n    idx += length;\n\n    return idx;\n}\n\n/* encode Authority Key Identifier, return total bytes written\n * RFC5280 : non-critical */\nstatic int SetAKID(byte* output, word32 outSz,\n                                         byte *input, word32 length, void* heap)\n{\n    byte    *enc_val;\n    int     ret, enc_valSz;\n    const byte akid_oid[] = { 0x06, 0x03, 0x55, 0x1d, 0x23, 0x04 };\n    const byte akid_cs[] = { 0x80 };\n\n    (void)heap;\n\n    if (output == NULL || input == NULL)\n        return BAD_FUNC_ARG;\n\n    enc_valSz = length + 3 + sizeof(akid_cs);\n    enc_val = (byte *)XMALLOC(enc_valSz, heap, DYNAMIC_TYPE_TMP_BUFFER);\n    if (enc_val == NULL)\n        return MEMORY_E;\n\n    /* sequence for ContentSpec & value */\n    ret = SetOidValue(enc_val, enc_valSz, akid_cs, sizeof(akid_cs),\n                      input, length);\n    if (ret > 0) {\n        enc_valSz = ret;\n\n        ret = SetOidValue(output, outSz, akid_oid, sizeof(akid_oid),\n                          enc_val, enc_valSz);\n    }\n\n    XFREE(enc_val, heap, DYNAMIC_TYPE_TMP_BUFFER);\n    return ret;\n}\n\n/* encode Key Usage, return total bytes written\n * RFC5280 : critical */\nstatic int SetKeyUsage(byte* output, word32 outSz, word16 input)\n{\n    byte ku[5];\n    int  idx;\n    const byte keyusage_oid[] = { 0x06, 0x03, 0x55, 0x1d, 0x0f,\n                                         0x01, 0x01, 0xff, 0x04};\n    if (output == NULL)\n        return BAD_FUNC_ARG;\n\n    idx = SetBitString16Bit(input, ku);\n    return SetOidValue(output, outSz, keyusage_oid, sizeof(keyusage_oid),\n                       ku, idx);\n}\n\nstatic int SetOjectIdValue(byte* output, word32 outSz, int* idx,\n    const byte* oid, word32 oidSz)\n{\n    /* verify room */\n    if (*idx + 2 + oidSz >= outSz)\n        return ASN_PARSE_E;\n\n    *idx += SetObjectId(oidSz, &output[*idx]);\n    XMEMCPY(&output[*idx], oid, oidSz);\n    *idx += oidSz;\n\n    return 0;\n}\n\n/* encode Extended Key Usage (RFC 5280 4.2.1.12), return total bytes written */\nstatic int SetExtKeyUsage(Cert* cert, byte* output, word32 outSz, byte input)\n{\n    int idx = 0, oidListSz = 0, totalSz, ret = 0;\n    const byte extkeyusage_oid[] = { 0x06, 0x03, 0x55, 0x1d, 0x25 };\n\n    if (output == NULL)\n        return BAD_FUNC_ARG;\n\n    /* Skip to OID List */\n    totalSz = 2 + sizeof(extkeyusage_oid) + 4;\n    idx = totalSz;\n\n    /* Build OID List */\n    /* If any set, then just use it */\n    if (input & EXTKEYUSE_ANY) {\n        ret |= SetOjectIdValue(output, outSz, &idx,\n            extExtKeyUsageAnyOid, sizeof(extExtKeyUsageAnyOid));\n    }\n    else {\n        if (input & EXTKEYUSE_SERVER_AUTH)\n            ret |= SetOjectIdValue(output, outSz, &idx,\n                extExtKeyUsageServerAuthOid, sizeof(extExtKeyUsageServerAuthOid));\n        if (input & EXTKEYUSE_CLIENT_AUTH)\n            ret |= SetOjectIdValue(output, outSz, &idx,\n                extExtKeyUsageClientAuthOid, sizeof(extExtKeyUsageClientAuthOid));\n        if (input & EXTKEYUSE_CODESIGN)\n            ret |= SetOjectIdValue(output, outSz, &idx,\n                extExtKeyUsageCodeSigningOid, sizeof(extExtKeyUsageCodeSigningOid));\n        if (input & EXTKEYUSE_EMAILPROT)\n            ret |= SetOjectIdValue(output, outSz, &idx,\n                extExtKeyUsageEmailProtectOid, sizeof(extExtKeyUsageEmailProtectOid));\n        if (input & EXTKEYUSE_TIMESTAMP)\n            ret |= SetOjectIdValue(output, outSz, &idx,\n                extExtKeyUsageTimestampOid, sizeof(extExtKeyUsageTimestampOid));\n        if (input & EXTKEYUSE_OCSP_SIGN)\n            ret |= SetOjectIdValue(output, outSz, &idx,\n                extExtKeyUsageOcspSignOid, sizeof(extExtKeyUsageOcspSignOid));\n    #ifdef WOLFSSL_EKU_OID\n        /* iterate through OID values */\n        if (input & EXTKEYUSE_USER) {\n            int i, sz;\n            for (i = 0; i < CTC_MAX_EKU_NB; i++) {\n                sz = cert->extKeyUsageOIDSz[i];\n                if (sz > 0) {\n                    ret |= SetOjectIdValue(output, outSz, &idx,\n                        cert->extKeyUsageOID[i], sz);\n                }\n            }\n        }\n    #endif /* WOLFSSL_EKU_OID */\n    }\n    if (ret != 0)\n        return ASN_PARSE_E;\n\n    /* Calculate Sizes */\n    oidListSz = idx - totalSz;\n    totalSz = idx - 2; /* exclude first seq/len (2) */\n\n    /* 1. Seq + Total Len (2) */\n    idx = SetSequence(totalSz, output);\n\n    /* 2. Object ID (2) */\n    XMEMCPY(&output[idx], extkeyusage_oid, sizeof(extkeyusage_oid));\n    idx += sizeof(extkeyusage_oid);\n\n    /* 3. Octet String (2) */\n    idx += SetOctetString(totalSz - idx, &output[idx]);\n\n    /* 4. Seq + OidListLen (2) */\n    idx += SetSequence(oidListSz, &output[idx]);\n\n    /* 5. Oid List (already set in-place above) */\n    idx += oidListSz;\n\n    (void)cert;\n    return idx;\n}\n\n/* encode Certificate Policies, return total bytes written\n * each input value must be ITU-T X.690 formatted : a.b.c...\n * input must be an array of values with a NULL terminated for the latest\n * RFC5280 : non-critical */\nstatic int SetCertificatePolicies(byte *output,\n                                  word32 outputSz,\n                                  char input[MAX_CERTPOL_NB][MAX_CERTPOL_SZ],\n                                  word16 nb_certpol,\n                                  void* heap)\n{\n    byte    oid[MAX_OID_SZ],\n            der_oid[MAX_CERTPOL_NB][MAX_OID_SZ],\n            out[MAX_CERTPOL_SZ];\n    word32  oidSz;\n    word32  outSz, i = 0, der_oidSz[MAX_CERTPOL_NB];\n    int     ret;\n\n    const byte certpol_oid[] = { 0x06, 0x03, 0x55, 0x1d, 0x20, 0x04 };\n    const byte oid_oid[] = { 0x06 };\n\n    if (output == NULL || input == NULL || nb_certpol > MAX_CERTPOL_NB)\n        return BAD_FUNC_ARG;\n\n    for (i = 0; i < nb_certpol; i++) {\n        oidSz = sizeof(oid);\n        XMEMSET(oid, 0, oidSz);\n\n        ret = EncodePolicyOID(oid, &oidSz, input[i], heap);\n        if (ret != 0)\n            return ret;\n\n        /* compute sequence value for the oid */\n        ret = SetOidValue(der_oid[i], MAX_OID_SZ, oid_oid,\n                          sizeof(oid_oid), oid, oidSz);\n        if (ret <= 0)\n            return ret;\n        else\n            der_oidSz[i] = (word32)ret;\n    }\n\n    /* concatenate oid, keep two byte for sequence/size of the created value */\n    for (i = 0, outSz = 2; i < nb_certpol; i++) {\n        XMEMCPY(out+outSz, der_oid[i], der_oidSz[i]);\n        outSz += der_oidSz[i];\n    }\n\n    /* add sequence */\n    ret = SetSequence(outSz-2, out);\n    if (ret <= 0)\n        return ret;\n\n    /* add Policy OID to compute final value */\n    return SetOidValue(output, outputSz, certpol_oid, sizeof(certpol_oid),\n                      out, outSz);\n}\n#endif /* WOLFSSL_CERT_EXT */\n\n\n#ifdef WOLFSSL_ALT_NAMES\n\n/* encode Alternative Names, return total bytes written */\nstatic int SetAltNames(byte *output, word32 outSz,\n        const byte *input, word32 length)\n{\n    byte san_len[1 + MAX_LENGTH_SZ];\n    int idx = 0, san_lenSz;\n    const byte san_oid[] = { 0x06, 0x03, 0x55, 0x1d, 0x11 };\n\n    if (output == NULL || input == NULL)\n        return BAD_FUNC_ARG;\n\n    if (outSz < length)\n        return BUFFER_E;\n\n    /* Octet String header */\n    san_lenSz = SetOctetString(length, san_len);\n\n    if (outSz < MAX_SEQ_SZ)\n        return BUFFER_E;\n\n    idx = SetSequence(length + sizeof(san_oid) + san_lenSz, output);\n\n    if ((length + sizeof(san_oid) + san_lenSz) > outSz)\n        return BUFFER_E;\n\n    /* put oid */\n    XMEMCPY(output+idx, san_oid, sizeof(san_oid));\n    idx += sizeof(san_oid);\n\n    /* put octet header */\n    XMEMCPY(output+idx, san_len, san_lenSz);\n    idx += san_lenSz;\n\n    /* put value */\n    XMEMCPY(output+idx, input, length);\n    idx += length;\n\n    return idx;\n}\n\n\n#ifdef WOLFSSL_CERT_GEN\n\nint FlattenAltNames(byte* output, word32 outputSz, const DNS_entry* names)\n{\n    word32 idx;\n    const DNS_entry* curName;\n    word32 namesSz = 0;\n\n    if (output == NULL)\n        return BAD_FUNC_ARG;\n\n    if (names == NULL)\n        return 0;\n\n    curName = names;\n    do {\n        namesSz += curName->len + 2 +\n            ((curName->len < ASN_LONG_LENGTH) ? 0\n             : BytePrecision(curName->len));\n        curName = curName->next;\n    } while (curName != NULL);\n\n    if (outputSz < MAX_SEQ_SZ + namesSz)\n        return BUFFER_E;\n\n    idx = SetSequence(namesSz, output);\n\n    curName = names;\n    do {\n        output[idx] = ASN_CONTEXT_SPECIFIC | curName->type;\n        if (curName->type == ASN_DIR_TYPE) {\n            output[idx] |= ASN_CONSTRUCTED;\n        }\n        idx++;\n        idx += SetLength(curName->len, output + idx);\n        XMEMCPY(output + idx, curName->name, curName->len);\n        idx += curName->len;\n        curName = curName->next;\n    } while (curName != NULL);\n\n    return idx;\n}\n\n#endif /* WOLFSSL_CERT_GEN */\n\n#endif /* WOLFSSL_ALT_NAMES */\n\n/* Encodes one attribute of the name (issuer/subject)\n *\n * name     structure to hold result of encoding\n * nameStr  value to be encoded\n * nameType type of encoding i.e CTC_UTF8\n * type     id of attribute i.e ASN_COMMON_NAME\n * emailType type of email i.e CTC_UTF8\n * returns length on success\n */\nstatic int wc_EncodeName_ex(EncodedName* name, const char* nameStr, char nameType,\n                  byte type, byte emailType)\n{\n    word32 idx = 0;\n    /* bottom up */\n    byte firstLen[1 + MAX_LENGTH_SZ];\n    byte secondLen[MAX_LENGTH_SZ];\n    byte sequence[MAX_SEQ_SZ];\n    byte set[MAX_SET_SZ];\n\n    int strLen;\n    int thisLen;\n    int firstSz, secondSz, seqSz, setSz;\n\n    if (nameStr == NULL) {\n        name->used = 0;\n        return 0;\n    }\n    thisLen = strLen = (int)XSTRLEN(nameStr);\n    if (strLen == 0) { /* no user data for this item */\n        name->used = 0;\n        return 0;\n    }\n\n    /* Restrict country code size */\n    if (ASN_COUNTRY_NAME == type && strLen != CTC_COUNTRY_SIZE) {\n        WOLFSSL_MSG(\"Country code size error\");\n        return ASN_COUNTRY_SIZE_E;\n    }\n\n    secondSz = SetLength(strLen, secondLen);\n    thisLen += secondSz;\n    switch (type) {\n        case ASN_EMAIL_NAME: /* email */\n            thisLen += EMAIL_JOINT_LEN;\n            firstSz  = EMAIL_JOINT_LEN;\n            break;\n\n        case ASN_DOMAIN_COMPONENT:\n            thisLen += PILOT_JOINT_LEN;\n            firstSz  = PILOT_JOINT_LEN;\n            break;\n\n        default:\n            thisLen++;                                 /* str type */\n            thisLen += JOINT_LEN;\n            firstSz  = JOINT_LEN + 1;\n    }\n    thisLen++; /* id  type */\n    firstSz  = SetObjectId(firstSz, firstLen);\n    thisLen += firstSz;\n\n    seqSz = SetSequence(thisLen, sequence);\n    thisLen += seqSz;\n    setSz = SetSet(thisLen, set);\n    thisLen += setSz;\n\n    if (thisLen > (int)sizeof(name->encoded)) {\n        return BUFFER_E;\n    }\n\n    /* store it */\n    idx = 0;\n    /* set */\n    XMEMCPY(name->encoded, set, setSz);\n    idx += setSz;\n    /* seq */\n    XMEMCPY(name->encoded + idx, sequence, seqSz);\n    idx += seqSz;\n    /* asn object id */\n    XMEMCPY(name->encoded + idx, firstLen, firstSz);\n    idx += firstSz;\n    switch (type) {\n        case ASN_EMAIL_NAME:\n        {\n            const byte EMAIL_OID[] = {\n                0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x09, 0x01\n            };\n            /* email joint id */\n            XMEMCPY(name->encoded + idx, EMAIL_OID, sizeof(EMAIL_OID));\n            idx += (int)sizeof(EMAIL_OID);\n            name->encoded[idx++] = emailType;\n            break;\n        }\n\n        case ASN_DOMAIN_COMPONENT:\n        {\n            const byte PILOT_OID[] = {\n                0x09, 0x92, 0x26, 0x89, 0x93, 0xF2, 0x2C, 0x64, 0x01\n            };\n\n            XMEMCPY(name->encoded + idx, PILOT_OID, sizeof(PILOT_OID));\n            idx += (int)sizeof(PILOT_OID);\n            /* id type */\n            name->encoded[idx++] = type;\n            /* str type */\n            name->encoded[idx++] = nameType;\n            break;\n        }\n\n        default:\n            name->encoded[idx++] = 0x55;\n            name->encoded[idx++] = 0x04;\n            /* id type */\n            name->encoded[idx++] = type;\n            /* str type */\n            name->encoded[idx++] = nameType;\n    }\n    /* second length */\n    XMEMCPY(name->encoded + idx, secondLen, secondSz);\n    idx += secondSz;\n    /* str value */\n    XMEMCPY(name->encoded + idx, nameStr, strLen);\n    idx += strLen;\n\n    name->type = type;\n    name->totalLen = idx;\n    name->used = 1;\n\n    return idx;\n}\n\n/* canonical encoding one attribute of the name (issuer/subject)\n * call wc_EncodeName_ex with CTC_UTF8 for email type\n *\n * name     structure to hold result of encoding\n * nameStr  value to be encoded\n * nameType type of encoding i.e CTC_UTF8\n * type     id of attribute i.e ASN_COMMON_NAME\n *\n * returns length on success\n */\nint wc_EncodeNameCanonical(EncodedName* name, const char* nameStr, char nameType,\n        byte type)\n{\n    return wc_EncodeName_ex(name, nameStr, nameType, type, 0x0c/* CTC_UTF8 */);\n}\n\n/* Encodes one attribute of the name (issuer/subject)\n * call we_EncodeName_ex with 0x16, IA5String for email type\n * name     structure to hold result of encoding\n * nameStr  value to be encoded\n * nameType type of encoding i.e CTC_UTF8\n * type     id of attribute i.e ASN_COMMON_NAME\n *\n * returns length on success\n */\nint wc_EncodeName(EncodedName* name, const char* nameStr, char nameType,\n                  byte type)\n{\n    return wc_EncodeName_ex(name, nameStr, nameType, type, ASN_IA5_STRING);\n}\n/* encode CertName into output, return total bytes written */\nint SetName(byte* output, word32 outputSz, CertName* name)\n{\n    int          totalBytes = 0, i, idx;\n#ifdef WOLFSSL_SMALL_STACK\n    EncodedName* names = NULL;\n#else\n    EncodedName  names[NAME_ENTRIES];\n#endif\n#ifdef WOLFSSL_MULTI_ATTRIB\n    EncodedName addNames[CTC_MAX_ATTRIB];\n    int j, type;\n#endif\n\n    if (output == NULL || name == NULL)\n        return BAD_FUNC_ARG;\n\n    if (outputSz < 3)\n        return BUFFER_E;\n\n#ifdef WOLFSSL_SMALL_STACK\n    names = (EncodedName*)XMALLOC(sizeof(EncodedName) * NAME_ENTRIES, NULL,\n                                                       DYNAMIC_TYPE_TMP_BUFFER);\n    if (names == NULL)\n        return MEMORY_E;\n#endif\n\n    for (i = 0; i < NAME_ENTRIES; i++) {\n        int ret;\n        const char* nameStr = GetOneCertName(name, i);\n\n        ret = wc_EncodeName(&names[i], nameStr, GetNameType(name, i),\n                          GetCertNameId(i));\n        if (ret < 0) {\n        #ifdef WOLFSSL_SMALL_STACK\n            XFREE(names, NULL, DYNAMIC_TYPE_TMP_BUFFER);\n        #endif\n            WOLFSSL_MSG(\"EncodeName failed\");\n            return BUFFER_E;\n        }\n        totalBytes += ret;\n    }\n#ifdef WOLFSSL_MULTI_ATTRIB\n    for (i = 0; i < CTC_MAX_ATTRIB; i++) {\n        if (name->name[i].sz > 0) {\n            int ret;\n            ret = wc_EncodeName(&addNames[i], name->name[i].value,\n                        name->name[i].type, name->name[i].id);\n            if (ret < 0) {\n            #ifdef WOLFSSL_SMALL_STACK\n                XFREE(names, NULL, DYNAMIC_TYPE_TMP_BUFFER);\n            #endif\n                WOLFSSL_MSG(\"EncodeName on multiple attributes failed\\n\");\n                return BUFFER_E;\n            }\n            totalBytes += ret;\n        }\n        else {\n            addNames[i].used = 0;\n        }\n    }\n#endif /* WOLFSSL_MULTI_ATTRIB */\n\n    /* header */\n    idx = SetSequence(totalBytes, output);\n    totalBytes += idx;\n    if (totalBytes > ASN_NAME_MAX) {\n#ifdef WOLFSSL_SMALL_STACK\n        XFREE(names, NULL, DYNAMIC_TYPE_TMP_BUFFER);\n#endif\n        WOLFSSL_MSG(\"Total Bytes is greater than ASN_NAME_MAX\");\n        return BUFFER_E;\n    }\n\n    for (i = 0; i < NAME_ENTRIES; i++) {\n    #ifdef WOLFSSL_MULTI_ATTRIB\n        type = GetCertNameId(i);\n\n        /* list all DC values before OUs */\n        if (type == ASN_ORGUNIT_NAME) {\n            type = ASN_DOMAIN_COMPONENT;\n            for (j = 0; j < CTC_MAX_ATTRIB; j++) {\n                if (name->name[j].sz > 0 && type == name->name[j].id) {\n                    if (outputSz < (word32)(idx+addNames[j].totalLen)) {\n                    #ifdef WOLFSSL_SMALL_STACK\n                        XFREE(names, NULL, DYNAMIC_TYPE_TMP_BUFFER);\n                    #endif\n                        WOLFSSL_MSG(\"Not enough space left for DC value\");\n                        return BUFFER_E;\n                    }\n\n                    XMEMCPY(output + idx, addNames[j].encoded,\n                            addNames[j].totalLen);\n                    idx += addNames[j].totalLen;\n                }\n            }\n            type = ASN_ORGUNIT_NAME;\n        }\n\n        /* write all similar types to the buffer */\n        for (j = 0; j < CTC_MAX_ATTRIB; j++) {\n            if (name->name[j].sz > 0 && type == name->name[j].id) {\n                if (outputSz < (word32)(idx+addNames[j].totalLen)) {\n                #ifdef WOLFSSL_SMALL_STACK\n                    XFREE(names, NULL, DYNAMIC_TYPE_TMP_BUFFER);\n                #endif\n                    return BUFFER_E;\n                }\n\n                XMEMCPY(output + idx, addNames[j].encoded,\n                        addNames[j].totalLen);\n                idx += addNames[j].totalLen;\n            }\n        }\n    #endif /* WOLFSSL_MULTI_ATTRIB */\n\n        if (names[i].used) {\n            if (outputSz < (word32)(idx+names[i].totalLen)) {\n#ifdef WOLFSSL_SMALL_STACK\n                XFREE(names, NULL, DYNAMIC_TYPE_TMP_BUFFER);\n#endif\n                return BUFFER_E;\n            }\n\n            XMEMCPY(output + idx, names[i].encoded, names[i].totalLen);\n            idx += names[i].totalLen;\n        }\n    }\n\n#ifdef WOLFSSL_SMALL_STACK\n    XFREE(names, NULL, DYNAMIC_TYPE_TMP_BUFFER);\n#endif\n\n    return totalBytes;\n}\n\n/* Set Date validity from now until now + daysValid\n * return size in bytes written to output, 0 on error */\nstatic int SetValidity(byte* output, int daysValid)\n{\n#ifndef NO_ASN_TIME\n    byte before[MAX_DATE_SIZE];\n    byte  after[MAX_DATE_SIZE];\n\n    int beforeSz;\n    int afterSz;\n    int seqSz;\n\n    time_t now;\n    time_t then;\n    struct tm* tmpTime;\n    struct tm* expandedTime;\n    struct tm localTime;\n\n#if defined(NEED_TMP_TIME)\n    /* for use with gmtime_r */\n    struct tm tmpTimeStorage;\n    tmpTime = &tmpTimeStorage;\n#else\n    tmpTime = NULL;\n#endif\n    (void)tmpTime;\n\n    now = XTIME(0);\n\n    /* before now */\n    before[0] = ASN_GENERALIZED_TIME;\n    beforeSz = SetLength(ASN_GEN_TIME_SZ, before + 1) + 1;  /* gen tag */\n\n    /* subtract 1 day of seconds for more compliance */\n    then = now - 86400;\n    expandedTime = XGMTIME(&then, tmpTime);\n    if (expandedTime == NULL) {\n        WOLFSSL_MSG(\"XGMTIME failed\");\n        return 0;   /* error */\n    }\n    localTime = *expandedTime;\n\n    /* adjust */\n    localTime.tm_year += 1900;\n    localTime.tm_mon +=    1;\n\n    SetTime(&localTime, before + beforeSz);\n    beforeSz += ASN_GEN_TIME_SZ;\n\n    after[0] = ASN_GENERALIZED_TIME;\n    afterSz  = SetLength(ASN_GEN_TIME_SZ, after + 1) + 1;  /* gen tag */\n\n    /* add daysValid of seconds */\n    then = now + (daysValid * (time_t)86400);\n    expandedTime = XGMTIME(&then, tmpTime);\n    if (expandedTime == NULL) {\n        WOLFSSL_MSG(\"XGMTIME failed\");\n        return 0;   /* error */\n    }\n    localTime = *expandedTime;\n\n    /* adjust */\n    localTime.tm_year += 1900;\n    localTime.tm_mon  +=    1;\n\n    SetTime(&localTime, after + afterSz);\n    afterSz += ASN_GEN_TIME_SZ;\n\n    /* headers and output */\n    seqSz = SetSequence(beforeSz + afterSz, output);\n    XMEMCPY(output + seqSz, before, beforeSz);\n    XMEMCPY(output + seqSz + beforeSz, after, afterSz);\n\n    return seqSz + beforeSz + afterSz;\n#else\n    (void)output;\n    (void)daysValid;\n    return NOT_COMPILED_IN;\n#endif\n}\n\n/* encode info from cert into DER encoded format */\nstatic int EncodeCert(Cert* cert, DerCert* der, RsaKey* rsaKey, ecc_key* eccKey,\n                      WC_RNG* rng, const byte* ntruKey, word16 ntruSz, DsaKey* dsaKey,\n                      ed25519_key* ed25519Key, ed448_key* ed448Key)\n{\n    int ret;\n\n    if (cert == NULL || der == NULL || rng == NULL)\n        return BAD_FUNC_ARG;\n\n    /* make sure at least one key type is provided */\n    if (rsaKey == NULL && eccKey == NULL && ed25519Key == NULL &&\n            dsaKey == NULL && ed448Key == NULL && ntruKey == NULL) {\n        return PUBLIC_KEY_E;\n    }\n\n    /* init */\n    XMEMSET(der, 0, sizeof(DerCert));\n\n    /* version */\n    der->versionSz = SetMyVersion(cert->version, der->version, TRUE);\n\n    /* serial number (must be positive) */\n    if (cert->serialSz == 0) {\n        /* generate random serial */\n        cert->serialSz = CTC_GEN_SERIAL_SZ;\n        ret = wc_RNG_GenerateBlock(rng, cert->serial, cert->serialSz);\n        if (ret != 0)\n            return ret;\n        /* Clear the top bit to avoid a negative value */\n        cert->serial[0] &= 0x7f;\n    }\n    der->serialSz = SetSerialNumber(cert->serial, cert->serialSz, der->serial,\n        sizeof(der->serial), CTC_SERIAL_SIZE);\n    if (der->serialSz < 0)\n        return der->serialSz;\n\n    /* signature algo */\n    der->sigAlgoSz = SetAlgoID(cert->sigType, der->sigAlgo, oidSigType, 0);\n    if (der->sigAlgoSz <= 0)\n        return ALGO_ID_E;\n\n    /* public key */\n#ifndef NO_RSA\n    if (cert->keyType == RSA_KEY) {\n        if (rsaKey == NULL)\n            return PUBLIC_KEY_E;\n        der->publicKeySz = SetRsaPublicKey(der->publicKey, rsaKey,\n                                           sizeof(der->publicKey), 1);\n    }\n#endif\n\n#ifdef HAVE_ECC\n    if (cert->keyType == ECC_KEY) {\n        if (eccKey == NULL)\n            return PUBLIC_KEY_E;\n        der->publicKeySz = SetEccPublicKey(der->publicKey, eccKey, 1);\n    }\n#endif\n\n#if !defined(NO_DSA) && !defined(HAVE_SELFTEST)\n    if (cert->keyType == DSA_KEY) {\n        if (dsaKey == NULL)\n            return PUBLIC_KEY_E;\n        der->publicKeySz = wc_SetDsaPublicKey(der->publicKey, dsaKey,\n                                           sizeof(der->publicKey), 1);\n    }\n#endif\n\n#ifdef HAVE_ED25519\n    if (cert->keyType == ED25519_KEY) {\n        if (ed25519Key == NULL)\n            return PUBLIC_KEY_E;\n        der->publicKeySz = SetEd25519PublicKey(der->publicKey, ed25519Key, 1);\n    }\n#endif\n\n#ifdef HAVE_ED448\n    if (cert->keyType == ED448_KEY) {\n        if (ed448Key == NULL)\n            return PUBLIC_KEY_E;\n        der->publicKeySz = SetEd448PublicKey(der->publicKey, ed448Key, 1);\n    }\n#endif\n\n#ifdef HAVE_NTRU\n    if (cert->keyType == NTRU_KEY) {\n        word32 rc;\n        word16 encodedSz;\n\n        if (ntruKey == NULL)\n            return PUBLIC_KEY_E;\n\n        rc  = ntru_crypto_ntru_encrypt_publicKey2SubjectPublicKeyInfo(ntruSz,\n                                                   ntruKey, &encodedSz, NULL);\n        if (rc != NTRU_OK)\n            return PUBLIC_KEY_E;\n        if (encodedSz > MAX_PUBLIC_KEY_SZ)\n            return PUBLIC_KEY_E;\n\n        rc  = ntru_crypto_ntru_encrypt_publicKey2SubjectPublicKeyInfo(ntruSz,\n                                         ntruKey, &encodedSz, der->publicKey);\n        if (rc != NTRU_OK)\n            return PUBLIC_KEY_E;\n\n        der->publicKeySz = encodedSz;\n    }\n#else\n    (void)ntruSz;\n#endif /* HAVE_NTRU */\n\n    if (der->publicKeySz <= 0)\n        return PUBLIC_KEY_E;\n\n    der->validitySz = 0;\n#ifdef WOLFSSL_ALT_NAMES\n    /* date validity copy ? */\n    if (cert->beforeDateSz && cert->afterDateSz) {\n        der->validitySz = CopyValidity(der->validity, cert);\n        if (der->validitySz <= 0)\n            return DATE_E;\n    }\n#endif\n\n    /* date validity */\n    if (der->validitySz == 0) {\n        der->validitySz = SetValidity(der->validity, cert->daysValid);\n        if (der->validitySz <= 0)\n            return DATE_E;\n    }\n\n    /* subject name */\n#if defined(WOLFSSL_CERT_EXT) || defined(OPENSSL_EXTRA)\n    if (XSTRLEN((const char*)cert->sbjRaw) > 0) {\n        /* Use the raw subject */\n        int idx;\n\n        der->subjectSz = min(sizeof(der->subject),\n                (word32)XSTRLEN((const char*)cert->sbjRaw));\n        /* header */\n        idx = SetSequence(der->subjectSz, der->subject);\n        if (der->subjectSz + idx > (int)sizeof(der->subject)) {\n            return SUBJECT_E;\n        }\n\n        XMEMCPY((char*)der->subject + idx, (const char*)cert->sbjRaw,\n                der->subjectSz);\n        der->subjectSz += idx;\n    }\n    else\n#endif\n    {\n        /* Use the name structure */\n        der->subjectSz = SetName(der->subject, sizeof(der->subject),\n                &cert->subject);\n    }\n    if (der->subjectSz <= 0)\n        return SUBJECT_E;\n\n    /* issuer name */\n#if defined(WOLFSSL_CERT_EXT) || defined(OPENSSL_EXTRA)\n    if (XSTRLEN((const char*)cert->issRaw) > 0) {\n        /* Use the raw issuer */\n        int idx;\n\n        der->issuerSz = min(sizeof(der->issuer),\n                (word32)XSTRLEN((const char*)cert->issRaw));\n\n        /* header */\n        idx = SetSequence(der->issuerSz, der->issuer);\n        if (der->issuerSz + idx > (int)sizeof(der->issuer)) {\n            return ISSUER_E;\n        }\n\n        XMEMCPY((char*)der->issuer + idx, (const char*)cert->issRaw,\n                der->issuerSz);\n        der->issuerSz += idx;\n    }\n    else\n#endif\n    {\n        /* Use the name structure */\n        der->issuerSz = SetName(der->issuer, sizeof(der->issuer),\n                cert->selfSigned ? &cert->subject : &cert->issuer);\n    }\n    if (der->issuerSz <= 0)\n        return ISSUER_E;\n\n    /* set the extensions */\n    der->extensionsSz = 0;\n\n    /* CA */\n    if (cert->isCA) {\n        der->caSz = SetCa(der->ca, sizeof(der->ca));\n        if (der->caSz <= 0)\n            return CA_TRUE_E;\n\n        der->extensionsSz += der->caSz;\n    }\n    else\n        der->caSz = 0;\n\n#ifdef WOLFSSL_ALT_NAMES\n    /* Alternative Name */\n    if (cert->altNamesSz) {\n        der->altNamesSz = SetAltNames(der->altNames, sizeof(der->altNames),\n                                      cert->altNames, cert->altNamesSz);\n        if (der->altNamesSz <= 0)\n            return ALT_NAME_E;\n\n        der->extensionsSz += der->altNamesSz;\n    }\n    else\n        der->altNamesSz = 0;\n#endif\n\n#ifdef WOLFSSL_CERT_EXT\n    /* SKID */\n    if (cert->skidSz) {\n        /* check the provided SKID size */\n        if (cert->skidSz > (int)min(CTC_MAX_SKID_SIZE, sizeof(der->skid)))\n            return SKID_E;\n\n        /* Note: different skid buffers sizes for der (MAX_KID_SZ) and\n            cert (CTC_MAX_SKID_SIZE). */\n        der->skidSz = SetSKID(der->skid, sizeof(der->skid),\n                              cert->skid, cert->skidSz);\n        if (der->skidSz <= 0)\n            return SKID_E;\n\n        der->extensionsSz += der->skidSz;\n    }\n    else\n        der->skidSz = 0;\n\n    /* AKID */\n    if (cert->akidSz) {\n        /* check the provided AKID size */\n        if (cert->akidSz > (int)min(CTC_MAX_AKID_SIZE, sizeof(der->akid)))\n            return AKID_E;\n\n        der->akidSz = SetAKID(der->akid, sizeof(der->akid),\n                              cert->akid, cert->akidSz, cert->heap);\n        if (der->akidSz <= 0)\n            return AKID_E;\n\n        der->extensionsSz += der->akidSz;\n    }\n    else\n        der->akidSz = 0;\n\n    /* Key Usage */\n    if (cert->keyUsage != 0){\n        der->keyUsageSz = SetKeyUsage(der->keyUsage, sizeof(der->keyUsage),\n                                      cert->keyUsage);\n        if (der->keyUsageSz <= 0)\n            return KEYUSAGE_E;\n\n        der->extensionsSz += der->keyUsageSz;\n    }\n    else\n        der->keyUsageSz = 0;\n\n    /* Extended Key Usage */\n    if (cert->extKeyUsage != 0){\n        der->extKeyUsageSz = SetExtKeyUsage(cert, der->extKeyUsage,\n                                sizeof(der->extKeyUsage), cert->extKeyUsage);\n        if (der->extKeyUsageSz <= 0)\n            return EXTKEYUSAGE_E;\n\n        der->extensionsSz += der->extKeyUsageSz;\n    }\n    else\n        der->extKeyUsageSz = 0;\n\n    /* Certificate Policies */\n    if (cert->certPoliciesNb != 0) {\n        der->certPoliciesSz = SetCertificatePolicies(der->certPolicies,\n                                                     sizeof(der->certPolicies),\n                                                     cert->certPolicies,\n                                                     cert->certPoliciesNb,\n                                                     cert->heap);\n        if (der->certPoliciesSz <= 0)\n            return CERTPOLICIES_E;\n\n        der->extensionsSz += der->certPoliciesSz;\n    }\n    else\n        der->certPoliciesSz = 0;\n#endif /* WOLFSSL_CERT_EXT */\n\n    /* put extensions */\n    if (der->extensionsSz > 0) {\n\n        /* put the start of extensions sequence (ID, Size) */\n        der->extensionsSz = SetExtensionsHeader(der->extensions,\n                                                sizeof(der->extensions),\n                                                der->extensionsSz);\n        if (der->extensionsSz <= 0)\n            return EXTENSIONS_E;\n\n        /* put CA */\n        if (der->caSz) {\n            ret = SetExtensions(der->extensions, sizeof(der->extensions),\n                                &der->extensionsSz,\n                                der->ca, der->caSz);\n            if (ret == 0)\n                return EXTENSIONS_E;\n        }\n\n#ifdef WOLFSSL_ALT_NAMES\n        /* put Alternative Names */\n        if (der->altNamesSz) {\n            ret = SetExtensions(der->extensions, sizeof(der->extensions),\n                                &der->extensionsSz,\n                                der->altNames, der->altNamesSz);\n            if (ret <= 0)\n                return EXTENSIONS_E;\n        }\n#endif\n\n#ifdef WOLFSSL_CERT_EXT\n        /* put SKID */\n        if (der->skidSz) {\n            ret = SetExtensions(der->extensions, sizeof(der->extensions),\n                                &der->extensionsSz,\n                                der->skid, der->skidSz);\n            if (ret <= 0)\n                return EXTENSIONS_E;\n        }\n\n        /* put AKID */\n        if (der->akidSz) {\n            ret = SetExtensions(der->extensions, sizeof(der->extensions),\n                                &der->extensionsSz,\n                                der->akid, der->akidSz);\n            if (ret <= 0)\n                return EXTENSIONS_E;\n        }\n\n        /* put KeyUsage */\n        if (der->keyUsageSz) {\n            ret = SetExtensions(der->extensions, sizeof(der->extensions),\n                                &der->extensionsSz,\n                                der->keyUsage, der->keyUsageSz);\n            if (ret <= 0)\n                return EXTENSIONS_E;\n        }\n\n        /* put ExtendedKeyUsage */\n        if (der->extKeyUsageSz) {\n            ret = SetExtensions(der->extensions, sizeof(der->extensions),\n                                &der->extensionsSz,\n                                der->extKeyUsage, der->extKeyUsageSz);\n            if (ret <= 0)\n                return EXTENSIONS_E;\n        }\n\n        /* put Certificate Policies */\n        if (der->certPoliciesSz) {\n            ret = SetExtensions(der->extensions, sizeof(der->extensions),\n                                &der->extensionsSz,\n                                der->certPolicies, der->certPoliciesSz);\n            if (ret <= 0)\n                return EXTENSIONS_E;\n        }\n#endif /* WOLFSSL_CERT_EXT */\n    }\n\n    der->total = der->versionSz + der->serialSz + der->sigAlgoSz +\n        der->publicKeySz + der->validitySz + der->subjectSz + der->issuerSz +\n        der->extensionsSz;\n\n    return 0;\n}\n\n\n/* write DER encoded cert to buffer, size already checked */\nstatic int WriteCertBody(DerCert* der, byte* buf)\n{\n    int idx;\n\n    /* signed part header */\n    idx = SetSequence(der->total, buf);\n    /* version */\n    XMEMCPY(buf + idx, der->version, der->versionSz);\n    idx += der->versionSz;\n    /* serial */\n    XMEMCPY(buf + idx, der->serial, der->serialSz);\n    idx += der->serialSz;\n    /* sig algo */\n    XMEMCPY(buf + idx, der->sigAlgo, der->sigAlgoSz);\n    idx += der->sigAlgoSz;\n    /* issuer */\n    XMEMCPY(buf + idx, der->issuer, der->issuerSz);\n    idx += der->issuerSz;\n    /* validity */\n    XMEMCPY(buf + idx, der->validity, der->validitySz);\n    idx += der->validitySz;\n    /* subject */\n    XMEMCPY(buf + idx, der->subject, der->subjectSz);\n    idx += der->subjectSz;\n    /* public key */\n    XMEMCPY(buf + idx, der->publicKey, der->publicKeySz);\n    idx += der->publicKeySz;\n    if (der->extensionsSz) {\n        /* extensions */\n        XMEMCPY(buf + idx, der->extensions, min(der->extensionsSz,\n                                                   (int)sizeof(der->extensions)));\n        idx += der->extensionsSz;\n    }\n\n    return idx;\n}\n\n\n/* Make RSA signature from buffer (sz), write to sig (sigSz) */\nstatic int MakeSignature(CertSignCtx* certSignCtx, const byte* buf, int sz,\n    byte* sig, int sigSz, RsaKey* rsaKey, ecc_key* eccKey,\n    ed25519_key* ed25519Key, ed448_key* ed448Key, WC_RNG* rng, int sigAlgoType,\n    void* heap)\n{\n    int digestSz = 0, typeH = 0, ret = 0;\n\n    (void)digestSz;\n    (void)typeH;\n    (void)buf;\n    (void)sz;\n    (void)sig;\n    (void)sigSz;\n    (void)rsaKey;\n    (void)eccKey;\n    (void)ed25519Key;\n    (void)ed448Key;\n    (void)rng;\n    (void)heap;\n\n    switch (certSignCtx->state) {\n    case CERTSIGN_STATE_BEGIN:\n    case CERTSIGN_STATE_DIGEST:\n\n        certSignCtx->state = CERTSIGN_STATE_DIGEST;\n        certSignCtx->digest = (byte*)XMALLOC(WC_MAX_DIGEST_SIZE, heap,\n            DYNAMIC_TYPE_TMP_BUFFER);\n        if (certSignCtx->digest == NULL) {\n            ret = MEMORY_E; goto exit_ms;\n        }\n\n        ret = HashForSignature(buf, sz, sigAlgoType, certSignCtx->digest,\n                               &typeH, &digestSz, 0);\n        /* set next state, since WC_PENDING_E rentry for these are not \"call again\" */\n        certSignCtx->state = CERTSIGN_STATE_ENCODE;\n        if (ret != 0) {\n            goto exit_ms;\n        }\n        FALL_THROUGH;\n\n    case CERTSIGN_STATE_ENCODE:\n    #ifndef NO_RSA\n        if (rsaKey) {\n            certSignCtx->encSig = (byte*)XMALLOC(MAX_DER_DIGEST_SZ, heap,\n                DYNAMIC_TYPE_TMP_BUFFER);\n            if (certSignCtx->encSig == NULL) {\n                ret = MEMORY_E; goto exit_ms;\n            }\n\n            /* signature */\n            certSignCtx->encSigSz = wc_EncodeSignature(certSignCtx->encSig,\n                                          certSignCtx->digest, digestSz, typeH);\n        }\n    #endif /* !NO_RSA */\n        FALL_THROUGH;\n\n    case CERTSIGN_STATE_DO:\n        certSignCtx->state = CERTSIGN_STATE_DO;\n        ret = ALGO_ID_E; /* default to error */\n\n    #ifndef NO_RSA\n        if (rsaKey) {\n            /* signature */\n            ret = wc_RsaSSL_Sign(certSignCtx->encSig, certSignCtx->encSigSz,\n                                 sig, sigSz, rsaKey, rng);\n        }\n    #endif /* !NO_RSA */\n\n    #ifdef HAVE_ECC\n        if (!rsaKey && eccKey) {\n            word32 outSz = sigSz;\n\n            ret = wc_ecc_sign_hash(certSignCtx->digest, digestSz,\n                                   sig, &outSz, rng, eccKey);\n            if (ret == 0)\n                ret = outSz;\n        }\n    #endif /* HAVE_ECC */\n\n    #ifdef HAVE_ED25519\n        if (!rsaKey && !eccKey && ed25519Key) {\n            word32 outSz = sigSz;\n\n            ret = wc_ed25519_sign_msg(buf, sz, sig, &outSz, ed25519Key);\n            if (ret == 0)\n                ret = outSz;\n        }\n    #endif /* HAVE_ECC */\n\n    #ifdef HAVE_ED448\n        if (!rsaKey && !eccKey && !ed25519Key && ed448Key) {\n            word32 outSz = sigSz;\n\n            ret = wc_ed448_sign_msg(buf, sz, sig, &outSz, ed448Key, NULL, 0);\n            if (ret == 0)\n                ret = outSz;\n        }\n    #endif /* HAVE_ECC */\n        break;\n    }\n\nexit_ms:\n\n#ifdef WOLFSSL_ASYNC_CRYPT\n    if (ret == WC_PENDING_E) {\n        return ret;\n    }\n#endif\n\n#ifndef NO_RSA\n    if (rsaKey) {\n        XFREE(certSignCtx->encSig, heap, DYNAMIC_TYPE_TMP_BUFFER);\n    }\n#endif /* !NO_RSA */\n\n    XFREE(certSignCtx->digest, heap, DYNAMIC_TYPE_TMP_BUFFER);\n    certSignCtx->digest = NULL;\n\n    /* reset state */\n    certSignCtx->state = CERTSIGN_STATE_BEGIN;\n\n    return ret;\n}\n\n\n/* add signature to end of buffer, size of buffer assumed checked, return\n   new length */\nint AddSignature(byte* buf, int bodySz, const byte* sig, int sigSz,\n                        int sigAlgoType)\n{\n    byte seq[MAX_SEQ_SZ];\n    int  idx = bodySz, seqSz;\n\n    /* algo */\n    idx += SetAlgoID(sigAlgoType, buf ? buf + idx : NULL, oidSigType, 0);\n    /* bit string */\n    idx += SetBitString(sigSz, 0, buf ? buf + idx : NULL);\n    /* signature */\n    if (buf)\n        XMEMCPY(buf + idx, sig, sigSz);\n    idx += sigSz;\n\n    /* make room for overall header */\n    seqSz = SetSequence(idx, seq);\n    if (buf) {\n        XMEMMOVE(buf + seqSz, buf, idx);\n        XMEMCPY(buf, seq, seqSz);\n    }\n\n    return idx + seqSz;\n}\n\n\n/* Make an x509 Certificate v3 any key type from cert input, write to buffer */\nstatic int MakeAnyCert(Cert* cert, byte* derBuffer, word32 derSz,\n                       RsaKey* rsaKey, ecc_key* eccKey, WC_RNG* rng,\n                       DsaKey* dsaKey, const byte* ntruKey, word16 ntruSz,\n                       ed25519_key* ed25519Key, ed448_key* ed448Key)\n{\n    int ret;\n#ifdef WOLFSSL_SMALL_STACK\n    DerCert* der;\n#else\n    DerCert der[1];\n#endif\n\n    if (derBuffer == NULL)\n        return BAD_FUNC_ARG;\n\n    if (eccKey)\n        cert->keyType = ECC_KEY;\n    else if (rsaKey)\n        cert->keyType = RSA_KEY;\n    else if (dsaKey)\n        cert->keyType = DSA_KEY;\n    else if (ed25519Key)\n        cert->keyType = ED25519_KEY;\n    else if (ed448Key)\n        cert->keyType = ED448_KEY;\n    else if (ntruKey)\n        cert->keyType = NTRU_KEY;\n    else\n        return BAD_FUNC_ARG;\n\n#ifdef WOLFSSL_SMALL_STACK\n    der = (DerCert*)XMALLOC(sizeof(DerCert), cert->heap, DYNAMIC_TYPE_TMP_BUFFER);\n    if (der == NULL)\n        return MEMORY_E;\n#endif\n\n    ret = EncodeCert(cert, der, rsaKey, eccKey, rng, ntruKey, ntruSz, dsaKey,\n                     ed25519Key, ed448Key);\n    if (ret == 0) {\n        if (der->total + MAX_SEQ_SZ * 2 > (int)derSz)\n            ret = BUFFER_E;\n        else\n            ret = cert->bodySz = WriteCertBody(der, derBuffer);\n    }\n\n#ifdef WOLFSSL_SMALL_STACK\n    XFREE(der, cert->heap, DYNAMIC_TYPE_TMP_BUFFER);\n#endif\n\n    return ret;\n}\n\n\n/* Make an x509 Certificate v3 RSA or ECC from cert input, write to buffer */\nint wc_MakeCert_ex(Cert* cert, byte* derBuffer, word32 derSz, int keyType,\n                   void* key, WC_RNG* rng)\n{\n    RsaKey*      rsaKey = NULL;\n    DsaKey*      dsaKey = NULL;\n    ecc_key*     eccKey = NULL;\n    ed25519_key* ed25519Key = NULL;\n    ed448_key*   ed448Key = NULL;\n\n    if (keyType == RSA_TYPE)\n        rsaKey = (RsaKey*)key;\n    else if (keyType == DSA_TYPE)\n        dsaKey = (DsaKey*)key;\n    else if (keyType == ECC_TYPE)\n        eccKey = (ecc_key*)key;\n    else if (keyType == ED25519_TYPE)\n        ed25519Key = (ed25519_key*)key;\n    else if (keyType == ED448_TYPE)\n        ed448Key = (ed448_key*)key;\n\n    return MakeAnyCert(cert, derBuffer, derSz, rsaKey, eccKey, rng, dsaKey,\n                       NULL, 0, ed25519Key, ed448Key);\n}\n/* Make an x509 Certificate v3 RSA or ECC from cert input, write to buffer */\nint wc_MakeCert(Cert* cert, byte* derBuffer, word32 derSz, RsaKey* rsaKey,\n             ecc_key* eccKey, WC_RNG* rng)\n{\n    return MakeAnyCert(cert, derBuffer, derSz, rsaKey, eccKey, rng, NULL, NULL, 0,\n                       NULL, NULL);\n}\n\n\n#ifdef HAVE_NTRU\n\nint wc_MakeNtruCert(Cert* cert, byte* derBuffer, word32 derSz,\n                  const byte* ntruKey, word16 keySz, WC_RNG* rng)\n{\n    return MakeAnyCert(cert, derBuffer, derSz, NULL, NULL, rng, NULL,\n            ntruKey, keySz, NULL, NULL);\n}\n\n#endif /* HAVE_NTRU */\n\n\n#ifdef WOLFSSL_CERT_REQ\n\nstatic int SetReqAttrib(byte* output, char* pw, int pwPrintableString,\n                        int extSz)\n{\n    const byte erOid[] =\n        { ASN_OBJECT_ID, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01,\n                         0x09, 0x0e };\n\n    int sz      = 0; /* overall size */\n    int cpSz    = 0; /* Challenge Password section size */\n    int cpSeqSz = 0;\n    int cpSetSz = 0;\n    int cpStrSz = 0;\n    int pwSz    = 0;\n    int erSz    = 0; /* Extension Request section size */\n    int erSeqSz = 0;\n    int erSetSz = 0;\n    byte cpSeq[MAX_SEQ_SZ];\n    byte cpSet[MAX_SET_SZ];\n    byte cpStr[MAX_PRSTR_SZ];\n    byte erSeq[MAX_SEQ_SZ];\n    byte erSet[MAX_SET_SZ];\n\n    output[0] = ASN_CONTEXT_SPECIFIC | ASN_CONSTRUCTED;\n    sz++;\n\n    if (pw && pw[0]) {\n        pwSz = (int)XSTRLEN(pw);\n        if (pwPrintableString) {\n            cpStrSz = SetPrintableString(pwSz, cpStr);\n        } else {\n            cpStrSz = SetUTF8String(pwSz, cpStr);\n        }\n        cpSetSz = SetSet(cpStrSz + pwSz, cpSet);\n        /* +2 for tag and length parts of the TLV triplet */\n        cpSeqSz = SetSequence(2 + sizeof(attrChallengePasswordOid) + cpSetSz +\n                cpStrSz + pwSz, cpSeq);\n        cpSz = cpSeqSz + 2 + sizeof(attrChallengePasswordOid) + cpSetSz +\n                cpStrSz + pwSz;\n    }\n\n    if (extSz) {\n        erSetSz = SetSet(extSz, erSet);\n        erSeqSz = SetSequence(erSetSz + sizeof(erOid) + extSz, erSeq);\n        erSz = extSz + erSetSz + erSeqSz + sizeof(erOid);\n    }\n\n    /* Put the pieces together. */\n    sz += SetLength(cpSz + erSz, &output[sz]);\n\n    if (cpSz) {\n        XMEMCPY(&output[sz], cpSeq, cpSeqSz);\n        sz += cpSeqSz;\n        sz += SetObjectId(sizeof(attrChallengePasswordOid), output + sz);\n        XMEMCPY(&output[sz], attrChallengePasswordOid,\n                sizeof(attrChallengePasswordOid));\n        sz += sizeof(attrChallengePasswordOid);\n        XMEMCPY(&output[sz], cpSet, cpSetSz);\n        sz += cpSetSz;\n        XMEMCPY(&output[sz], cpStr, cpStrSz);\n        sz += cpStrSz;\n        XMEMCPY(&output[sz], pw, pwSz);\n        sz += pwSz;\n    }\n\n    if (erSz) {\n        XMEMCPY(&output[sz], erSeq, erSeqSz);\n        sz += erSeqSz;\n        XMEMCPY(&output[sz], erOid, sizeof(erOid));\n        sz += sizeof(erOid);\n        XMEMCPY(&output[sz], erSet, erSetSz);\n        sz += erSetSz;\n        /* The actual extension data will be tacked onto the output later. */\n    }\n\n    return sz;\n}\n\n\n/* encode info from cert into DER encoded format */\nstatic int EncodeCertReq(Cert* cert, DerCert* der, RsaKey* rsaKey,\n                         DsaKey* dsaKey, ecc_key* eccKey,\n                         ed25519_key* ed25519Key, ed448_key* ed448Key)\n{\n    (void)eccKey;\n    (void)ed25519Key;\n    (void)ed448Key;\n\n    if (cert == NULL || der == NULL)\n        return BAD_FUNC_ARG;\n\n    if (rsaKey == NULL && eccKey == NULL && ed25519Key == NULL &&\n            dsaKey == NULL && ed448Key == NULL) {\n            return PUBLIC_KEY_E;\n    }\n\n    /* init */\n    XMEMSET(der, 0, sizeof(DerCert));\n\n    /* version */\n    der->versionSz = SetMyVersion(cert->version, der->version, FALSE);\n\n    /* subject name */\n#if defined(WOLFSSL_CERT_EXT) || defined(OPENSSL_EXTRA)\n    if (XSTRLEN((const char*)cert->sbjRaw) > 0) {\n        /* Use the raw subject */\n        int idx;\n\n        der->subjectSz = min(sizeof(der->subject),\n                (word32)XSTRLEN((const char*)cert->sbjRaw));\n        /* header */\n        idx = SetSequence(der->subjectSz, der->subject);\n        if (der->subjectSz + idx > (int)sizeof(der->subject)) {\n            return SUBJECT_E;\n        }\n\n        XMEMCPY((char*)der->subject + idx, (const char*)cert->sbjRaw,\n                der->subjectSz);\n        der->subjectSz += idx;\n    }\n    else\n#endif\n    {\n        der->subjectSz = SetName(der->subject, sizeof(der->subject),\n                &cert->subject);\n    }\n    if (der->subjectSz <= 0)\n        return SUBJECT_E;\n\n    /* public key */\n#ifndef NO_RSA\n    if (cert->keyType == RSA_KEY) {\n        if (rsaKey == NULL)\n            return PUBLIC_KEY_E;\n        der->publicKeySz = SetRsaPublicKey(der->publicKey, rsaKey,\n                                           sizeof(der->publicKey), 1);\n    }\n#endif\n\n#if !defined(NO_DSA) && !defined(HAVE_SELFTEST)\n    if (cert->keyType == DSA_KEY) {\n        if (dsaKey == NULL)\n            return PUBLIC_KEY_E;\n        der->publicKeySz = wc_SetDsaPublicKey(der->publicKey, dsaKey,\n                                           sizeof(der->publicKey), 1);\n    }\n#endif\n\n#ifdef HAVE_ECC\n    if (cert->keyType == ECC_KEY) {\n        if (eccKey == NULL)\n            return PUBLIC_KEY_E;\n        der->publicKeySz = SetEccPublicKey(der->publicKey, eccKey, 1);\n    }\n#endif\n\n#ifdef HAVE_ED25519\n    if (cert->keyType == ED25519_KEY) {\n        if (ed25519Key == NULL)\n            return PUBLIC_KEY_E;\n        der->publicKeySz = SetEd25519PublicKey(der->publicKey, ed25519Key, 1);\n    }\n#endif\n\n#ifdef HAVE_ED448\n    if (cert->keyType == ED448_KEY) {\n        if (ed448Key == NULL)\n            return PUBLIC_KEY_E;\n        der->publicKeySz = SetEd448PublicKey(der->publicKey, ed448Key, 1);\n    }\n#endif\n    if (der->publicKeySz <= 0)\n        return PUBLIC_KEY_E;\n\n    /* set the extensions */\n    der->extensionsSz = 0;\n\n    /* CA */\n    if (cert->isCA) {\n        der->caSz = SetCa(der->ca, sizeof(der->ca));\n        if (der->caSz <= 0)\n            return CA_TRUE_E;\n\n        der->extensionsSz += der->caSz;\n    }\n    else\n        der->caSz = 0;\n\n#ifdef WOLFSSL_ALT_NAMES\n    /* Alternative Name */\n    if (cert->altNamesSz) {\n        der->altNamesSz = SetAltNames(der->altNames, sizeof(der->altNames),\n                                      cert->altNames, cert->altNamesSz);\n        if (der->altNamesSz <= 0)\n            return ALT_NAME_E;\n\n        der->extensionsSz += der->altNamesSz;\n    }\n    else\n        der->altNamesSz = 0;\n#endif\n\n#ifdef WOLFSSL_CERT_EXT\n    /* SKID */\n    if (cert->skidSz) {\n        /* check the provided SKID size */\n        if (cert->skidSz > (int)min(CTC_MAX_SKID_SIZE, sizeof(der->skid)))\n            return SKID_E;\n\n        der->skidSz = SetSKID(der->skid, sizeof(der->skid),\n                              cert->skid, cert->skidSz);\n        if (der->skidSz <= 0)\n            return SKID_E;\n\n        der->extensionsSz += der->skidSz;\n    }\n    else\n        der->skidSz = 0;\n\n    /* Key Usage */\n    if (cert->keyUsage != 0){\n        der->keyUsageSz = SetKeyUsage(der->keyUsage, sizeof(der->keyUsage),\n                                      cert->keyUsage);\n        if (der->keyUsageSz <= 0)\n            return KEYUSAGE_E;\n\n        der->extensionsSz += der->keyUsageSz;\n    }\n    else\n        der->keyUsageSz = 0;\n\n    /* Extended Key Usage */\n    if (cert->extKeyUsage != 0){\n        der->extKeyUsageSz = SetExtKeyUsage(cert, der->extKeyUsage,\n                                sizeof(der->extKeyUsage), cert->extKeyUsage);\n        if (der->extKeyUsageSz <= 0)\n            return EXTKEYUSAGE_E;\n\n        der->extensionsSz += der->extKeyUsageSz;\n    }\n    else\n        der->extKeyUsageSz = 0;\n\n#endif /* WOLFSSL_CERT_EXT */\n\n    /* put extensions */\n    if (der->extensionsSz > 0) {\n        int ret;\n\n        /* put the start of sequence (ID, Size) */\n        der->extensionsSz = SetSequence(der->extensionsSz, der->extensions);\n        if (der->extensionsSz <= 0)\n            return EXTENSIONS_E;\n\n        /* put CA */\n        if (der->caSz) {\n            ret = SetExtensions(der->extensions, sizeof(der->extensions),\n                                &der->extensionsSz,\n                                der->ca, der->caSz);\n            if (ret <= 0)\n                return EXTENSIONS_E;\n        }\n\n#ifdef WOLFSSL_ALT_NAMES\n        /* put Alternative Names */\n        if (der->altNamesSz) {\n            ret = SetExtensions(der->extensions, sizeof(der->extensions),\n                                &der->extensionsSz,\n                                der->altNames, der->altNamesSz);\n            if (ret <= 0)\n                return EXTENSIONS_E;\n        }\n#endif\n\n#ifdef WOLFSSL_CERT_EXT\n        /* put SKID */\n        if (der->skidSz) {\n            ret = SetExtensions(der->extensions, sizeof(der->extensions),\n                                &der->extensionsSz,\n                                der->skid, der->skidSz);\n            if (ret <= 0)\n                return EXTENSIONS_E;\n        }\n\n        /* put AKID */\n        if (der->akidSz) {\n            ret = SetExtensions(der->extensions, sizeof(der->extensions),\n                                &der->extensionsSz,\n                                der->akid, der->akidSz);\n            if (ret <= 0)\n                return EXTENSIONS_E;\n        }\n\n        /* put KeyUsage */\n        if (der->keyUsageSz) {\n            ret = SetExtensions(der->extensions, sizeof(der->extensions),\n                                &der->extensionsSz,\n                                der->keyUsage, der->keyUsageSz);\n            if (ret <= 0)\n                return EXTENSIONS_E;\n        }\n\n        /* put ExtendedKeyUsage */\n        if (der->extKeyUsageSz) {\n            ret = SetExtensions(der->extensions, sizeof(der->extensions),\n                                &der->extensionsSz,\n                                der->extKeyUsage, der->extKeyUsageSz);\n            if (ret <= 0)\n                return EXTENSIONS_E;\n        }\n\n#endif /* WOLFSSL_CERT_EXT */\n    }\n\n    der->attribSz = SetReqAttrib(der->attrib, cert->challengePw,\n                                 cert->challengePwPrintableString,\n                                 der->extensionsSz);\n    if (der->attribSz <= 0)\n        return REQ_ATTRIBUTE_E;\n\n    der->total = der->versionSz + der->subjectSz + der->publicKeySz +\n        der->extensionsSz + der->attribSz;\n\n    return 0;\n}\n\n\n/* write DER encoded cert req to buffer, size already checked */\nstatic int WriteCertReqBody(DerCert* der, byte* buf)\n{\n    int idx;\n\n    /* signed part header */\n    idx = SetSequence(der->total, buf);\n    /* version */\n    if (buf)\n        XMEMCPY(buf + idx, der->version, der->versionSz);\n    idx += der->versionSz;\n    /* subject */\n    if (buf)\n        XMEMCPY(buf + idx, der->subject, der->subjectSz);\n    idx += der->subjectSz;\n    /* public key */\n    if (buf)\n        XMEMCPY(buf + idx, der->publicKey, der->publicKeySz);\n    idx += der->publicKeySz;\n    /* attributes */\n    if (buf)\n        XMEMCPY(buf + idx, der->attrib, der->attribSz);\n    idx += der->attribSz;\n    /* extensions */\n    if (der->extensionsSz) {\n        if (buf)\n            XMEMCPY(buf + idx, der->extensions, min(der->extensionsSz,\n                                               (int)sizeof(der->extensions)));\n        idx += der->extensionsSz;\n    }\n\n    return idx;\n}\n\n\nstatic int MakeCertReq(Cert* cert, byte* derBuffer, word32 derSz,\n                   RsaKey* rsaKey, DsaKey* dsaKey, ecc_key* eccKey,\n                   ed25519_key* ed25519Key, ed448_key* ed448Key)\n{\n    int ret;\n#ifdef WOLFSSL_SMALL_STACK\n    DerCert* der;\n#else\n    DerCert der[1];\n#endif\n\n    if (eccKey)\n        cert->keyType = ECC_KEY;\n    else if (rsaKey)\n        cert->keyType = RSA_KEY;\n    else if (dsaKey)\n        cert->keyType = DSA_KEY;\n    else if (ed25519Key)\n        cert->keyType = ED25519_KEY;\n    else if (ed448Key)\n        cert->keyType = ED448_KEY;\n    else\n        return BAD_FUNC_ARG;\n\n#ifdef WOLFSSL_SMALL_STACK\n    der = (DerCert*)XMALLOC(sizeof(DerCert), cert->heap,\n                                                    DYNAMIC_TYPE_TMP_BUFFER);\n    if (der == NULL)\n        return MEMORY_E;\n#endif\n\n    ret = EncodeCertReq(cert, der, rsaKey, dsaKey, eccKey, ed25519Key, ed448Key);\n\n    if (ret == 0) {\n        if (der->total + MAX_SEQ_SZ * 2 > (int)derSz)\n            ret = BUFFER_E;\n        else\n            ret = cert->bodySz = WriteCertReqBody(der, derBuffer);\n    }\n\n#ifdef WOLFSSL_SMALL_STACK\n    XFREE(der, cert->heap, DYNAMIC_TYPE_TMP_BUFFER);\n#endif\n\n    return ret;\n}\n\nint wc_MakeCertReq_ex(Cert* cert, byte* derBuffer, word32 derSz, int keyType,\n                      void* key)\n{\n    RsaKey*      rsaKey = NULL;\n    DsaKey*      dsaKey = NULL;\n    ecc_key*     eccKey = NULL;\n    ed25519_key* ed25519Key = NULL;\n    ed448_key*   ed448Key = NULL;\n\n    if (keyType == RSA_TYPE)\n        rsaKey = (RsaKey*)key;\n    else if (keyType == DSA_TYPE)\n        dsaKey = (DsaKey*)key;\n    else if (keyType == ECC_TYPE)\n        eccKey = (ecc_key*)key;\n    else if (keyType == ED25519_TYPE)\n        ed25519Key = (ed25519_key*)key;\n    else if (keyType == ED448_TYPE)\n        ed448Key = (ed448_key*)key;\n\n    return MakeCertReq(cert, derBuffer, derSz, rsaKey, dsaKey, eccKey, ed25519Key,\n                       ed448Key);\n}\n\nint wc_MakeCertReq(Cert* cert, byte* derBuffer, word32 derSz,\n                   RsaKey* rsaKey, ecc_key* eccKey)\n{\n    return MakeCertReq(cert, derBuffer, derSz, rsaKey, NULL, eccKey, NULL, NULL);\n}\n#endif /* WOLFSSL_CERT_REQ */\n\n\nstatic int SignCert(int requestSz, int sType, byte* buf, word32 buffSz,\n                    RsaKey* rsaKey, ecc_key* eccKey, ed25519_key* ed25519Key,\n                    ed448_key* ed448Key, WC_RNG* rng)\n{\n    int sigSz = 0;\n    void* heap = NULL;\n    CertSignCtx* certSignCtx;\n#ifndef WOLFSSL_ASYNC_CRYPT\n    CertSignCtx  certSignCtx_lcl;\n\n    certSignCtx = &certSignCtx_lcl;\n    XMEMSET(certSignCtx, 0, sizeof(CertSignCtx));\n#else\n    certSignCtx = NULL;\n#endif\n\n    if (requestSz < 0)\n        return requestSz;\n\n    /* locate ctx */\n    if (rsaKey) {\n    #ifndef NO_RSA\n    #ifdef WOLFSSL_ASYNC_CRYPT\n        certSignCtx = &rsaKey->certSignCtx;\n    #endif\n        heap = rsaKey->heap;\n    #else\n        return NOT_COMPILED_IN;\n    #endif /* NO_RSA */\n    }\n    else if (eccKey) {\n    #ifdef HAVE_ECC\n    #ifdef WOLFSSL_ASYNC_CRYPT\n        certSignCtx = &eccKey->certSignCtx;\n    #endif\n        heap = eccKey->heap;\n    #else\n        return NOT_COMPILED_IN;\n    #endif /* HAVE_ECC */\n    }\n\n#ifdef WOLFSSL_ASYNC_CRYPT\n    if (certSignCtx == NULL) {\n        return BAD_FUNC_ARG;\n    }\n#endif\n\n    if (certSignCtx->sig == NULL) {\n        certSignCtx->sig = (byte*)XMALLOC(MAX_ENCODED_SIG_SZ, heap,\n            DYNAMIC_TYPE_TMP_BUFFER);\n        if (certSignCtx->sig == NULL)\n            return MEMORY_E;\n    }\n\n    sigSz = MakeSignature(certSignCtx, buf, requestSz, certSignCtx->sig,\n        MAX_ENCODED_SIG_SZ, rsaKey, eccKey, ed25519Key, ed448Key, rng, sType,\n        heap);\n#ifdef WOLFSSL_ASYNC_CRYPT\n    if (sigSz == WC_PENDING_E) {\n        /* Not free'ing certSignCtx->sig here because it could still be in use\n         * with async operations. */\n        return sigSz;\n    }\n#endif\n\n    if (sigSz >= 0) {\n        if (requestSz + MAX_SEQ_SZ * 2 + sigSz > (int)buffSz)\n            sigSz = BUFFER_E;\n        else\n            sigSz = AddSignature(buf, requestSz, certSignCtx->sig, sigSz,\n                                 sType);\n    }\n\n    XFREE(certSignCtx->sig, heap, DYNAMIC_TYPE_TMP_BUFFER);\n    certSignCtx->sig = NULL;\n\n    return sigSz;\n}\n\nint wc_SignCert_ex(int requestSz, int sType, byte* buf, word32 buffSz,\n                   int keyType, void* key, WC_RNG* rng)\n{\n    RsaKey*      rsaKey = NULL;\n    ecc_key*     eccKey = NULL;\n    ed25519_key* ed25519Key = NULL;\n    ed448_key*   ed448Key = NULL;\n\n    if (keyType == RSA_TYPE)\n        rsaKey = (RsaKey*)key;\n    else if (keyType == ECC_TYPE)\n        eccKey = (ecc_key*)key;\n    else if (keyType == ED25519_TYPE)\n        ed25519Key = (ed25519_key*)key;\n    else if (keyType == ED448_TYPE)\n        ed448Key = (ed448_key*)key;\n\n    return SignCert(requestSz, sType, buf, buffSz, rsaKey, eccKey, ed25519Key,\n                    ed448Key, rng);\n}\n\nint wc_SignCert(int requestSz, int sType, byte* buf, word32 buffSz,\n                RsaKey* rsaKey, ecc_key* eccKey, WC_RNG* rng)\n{\n    return SignCert(requestSz, sType, buf, buffSz, rsaKey, eccKey, NULL, NULL,\n                    rng);\n}\n\nint wc_MakeSelfCert(Cert* cert, byte* buf, word32 buffSz,\n                    RsaKey* key, WC_RNG* rng)\n{\n    int ret;\n\n    ret = wc_MakeCert(cert, buf, buffSz, key, NULL, rng);\n    if (ret < 0)\n        return ret;\n\n    return wc_SignCert(cert->bodySz, cert->sigType,\n                       buf, buffSz, key, NULL, rng);\n}\n\n\n#ifdef WOLFSSL_CERT_EXT\n\n/* Get raw subject from cert, which may contain OIDs not parsed by Decode.\n   The raw subject pointer will only be valid while \"cert\" is valid. */\nint wc_GetSubjectRaw(byte **subjectRaw, Cert *cert)\n{\n    int rc = BAD_FUNC_ARG;\n    if ((subjectRaw != NULL) && (cert != NULL)) {\n        *subjectRaw = cert->sbjRaw;\n        rc = 0;\n    }\n    return rc;\n}\n\n/* Set KID from public key */\nstatic int SetKeyIdFromPublicKey(Cert *cert, RsaKey *rsakey, ecc_key *eckey,\n                                 byte *ntruKey, word16 ntruKeySz,\n                                 ed25519_key* ed25519Key, ed448_key* ed448Key,\n                                 int kid_type)\n{\n    byte *buf;\n    int   bufferSz, ret;\n\n    if (cert == NULL ||\n        (rsakey == NULL && eckey == NULL && ntruKey == NULL &&\n                                      ed25519Key == NULL && ed448Key == NULL) ||\n        (kid_type != SKID_TYPE && kid_type != AKID_TYPE))\n        return BAD_FUNC_ARG;\n\n    buf = (byte *)XMALLOC(MAX_PUBLIC_KEY_SZ, cert->heap,\n                                                       DYNAMIC_TYPE_TMP_BUFFER);\n    if (buf == NULL)\n        return MEMORY_E;\n\n    /* Public Key */\n    bufferSz = -1;\n#ifndef NO_RSA\n    /* RSA public key */\n    if (rsakey != NULL)\n        bufferSz = SetRsaPublicKey(buf, rsakey, MAX_PUBLIC_KEY_SZ, 0);\n#endif\n#ifdef HAVE_ECC\n    /* ECC public key */\n    if (eckey != NULL)\n        bufferSz = SetEccPublicKey(buf, eckey, 0);\n#endif\n#ifdef HAVE_NTRU\n    /* NTRU public key */\n    if (ntruKey != NULL) {\n        bufferSz = MAX_PUBLIC_KEY_SZ;\n        ret = ntru_crypto_ntru_encrypt_publicKey2SubjectPublicKeyInfo(\n                        ntruKeySz, ntruKey, (word16 *)(&bufferSz), buf);\n        if (ret != NTRU_OK)\n            bufferSz = -1;\n    }\n#else\n    (void)ntruKeySz;\n#endif\n#ifdef HAVE_ED25519\n    /* ED25519 public key */\n    if (ed25519Key != NULL)\n        bufferSz = SetEd25519PublicKey(buf, ed25519Key, 0);\n#endif\n#ifdef HAVE_ED448\n    /* ED448 public key */\n    if (ed448Key != NULL)\n        bufferSz = SetEd448PublicKey(buf, ed448Key, 0);\n#endif\n\n    if (bufferSz <= 0) {\n        XFREE(buf, cert->heap, DYNAMIC_TYPE_TMP_BUFFER);\n        return PUBLIC_KEY_E;\n    }\n\n    /* Compute SKID by hashing public key */\n    if (kid_type == SKID_TYPE) {\n        ret = CalcHashId(buf, bufferSz, cert->skid);\n        cert->skidSz = KEYID_SIZE;\n    }\n    else if (kid_type == AKID_TYPE) {\n        ret = CalcHashId(buf, bufferSz, cert->akid);\n        cert->akidSz = KEYID_SIZE;\n    }\n    else\n        ret = BAD_FUNC_ARG;\n\n    XFREE(buf, cert->heap, DYNAMIC_TYPE_TMP_BUFFER);\n    return ret;\n}\n\nint wc_SetSubjectKeyIdFromPublicKey_ex(Cert *cert, int keyType, void* key)\n{\n    RsaKey*      rsaKey = NULL;\n    ecc_key*     eccKey = NULL;\n    ed25519_key* ed25519Key = NULL;\n    ed448_key*   ed448Key = NULL;\n\n    if (keyType == RSA_TYPE)\n        rsaKey = (RsaKey*)key;\n    else if (keyType == ECC_TYPE)\n        eccKey = (ecc_key*)key;\n    else if (keyType == ED25519_TYPE)\n        ed25519Key = (ed25519_key*)key;\n    else if (keyType == ED448_TYPE)\n        ed448Key = (ed448_key*)key;\n\n    return SetKeyIdFromPublicKey(cert, rsaKey, eccKey, NULL, 0, ed25519Key,\n                                 ed448Key, SKID_TYPE);\n}\n\n/* Set SKID from RSA or ECC public key */\nint wc_SetSubjectKeyIdFromPublicKey(Cert *cert, RsaKey *rsakey, ecc_key *eckey)\n{\n    return SetKeyIdFromPublicKey(cert, rsakey, eckey, NULL, 0, NULL, NULL,\n                                 SKID_TYPE);\n}\n\n#ifdef HAVE_NTRU\n/* Set SKID from NTRU public key */\nint wc_SetSubjectKeyIdFromNtruPublicKey(Cert *cert,\n                                        byte *ntruKey, word16 ntruKeySz)\n{\n    return SetKeyIdFromPublicKey(cert, NULL,NULL,ntruKey, ntruKeySz, NULL, NULL,\n                                 SKID_TYPE);\n}\n#endif\n\nint wc_SetAuthKeyIdFromPublicKey_ex(Cert *cert, int keyType, void* key)\n{\n    RsaKey*      rsaKey = NULL;\n    ecc_key*     eccKey = NULL;\n    ed25519_key* ed25519Key = NULL;\n    ed448_key*   ed448Key = NULL;\n\n    if (keyType == RSA_TYPE)\n        rsaKey = (RsaKey*)key;\n    else if (keyType == ECC_TYPE)\n        eccKey = (ecc_key*)key;\n    else if (keyType == ED25519_TYPE)\n        ed25519Key = (ed25519_key*)key;\n    else if (keyType == ED448_TYPE)\n        ed448Key = (ed448_key*)key;\n\n    return SetKeyIdFromPublicKey(cert, rsaKey, eccKey, NULL, 0, ed25519Key,\n                                 ed448Key, AKID_TYPE);\n}\n\n/* Set SKID from RSA or ECC public key */\nint wc_SetAuthKeyIdFromPublicKey(Cert *cert, RsaKey *rsakey, ecc_key *eckey)\n{\n    return SetKeyIdFromPublicKey(cert, rsakey, eckey, NULL, 0, NULL, NULL,\n                                 AKID_TYPE);\n}\n\n\n#if !defined(NO_FILESYSTEM) && !defined(NO_ASN_CRYPT)\n\n/* Set SKID from public key file in PEM */\nint wc_SetSubjectKeyId(Cert *cert, const char* file)\n{\n    int     ret, derSz;\n    byte*   der;\n    word32  idx;\n    RsaKey  *rsakey = NULL;\n    ecc_key *eckey = NULL;\n\n    if (cert == NULL || file == NULL)\n        return BAD_FUNC_ARG;\n\n    der = (byte*)XMALLOC(MAX_PUBLIC_KEY_SZ, cert->heap, DYNAMIC_TYPE_CERT);\n    if (der == NULL) {\n        WOLFSSL_MSG(\"wc_SetSubjectKeyId memory Problem\");\n        return MEMORY_E;\n    }\n    derSz = MAX_PUBLIC_KEY_SZ;\n\n    XMEMSET(der, 0, derSz);\n    derSz = wc_PemPubKeyToDer(file, der, derSz);\n    if (derSz <= 0) {\n        XFREE(der, cert->heap, DYNAMIC_TYPE_CERT);\n        return derSz;\n    }\n\n    /* Load PubKey in internal structure */\n#ifndef NO_RSA\n    rsakey = (RsaKey*) XMALLOC(sizeof(RsaKey), cert->heap, DYNAMIC_TYPE_RSA);\n    if (rsakey == NULL) {\n        XFREE(der, cert->heap, DYNAMIC_TYPE_CERT);\n        return MEMORY_E;\n    }\n\n    if (wc_InitRsaKey(rsakey, cert->heap) != 0) {\n        WOLFSSL_MSG(\"wc_InitRsaKey failure\");\n        XFREE(rsakey, cert->heap, DYNAMIC_TYPE_RSA);\n        XFREE(der, cert->heap, DYNAMIC_TYPE_CERT);\n        return MEMORY_E;\n    }\n\n    idx = 0;\n    ret = wc_RsaPublicKeyDecode(der, &idx, rsakey, derSz);\n    if (ret != 0)\n#endif\n    {\n#ifndef NO_RSA\n        WOLFSSL_MSG(\"wc_RsaPublicKeyDecode failed\");\n        wc_FreeRsaKey(rsakey);\n        XFREE(rsakey, cert->heap, DYNAMIC_TYPE_RSA);\n        rsakey = NULL;\n#endif\n#ifdef HAVE_ECC\n        /* Check to load ecc public key */\n        eckey = (ecc_key*) XMALLOC(sizeof(ecc_key), cert->heap,\n                                                              DYNAMIC_TYPE_ECC);\n        if (eckey == NULL) {\n            XFREE(der, cert->heap, DYNAMIC_TYPE_CERT);\n            return MEMORY_E;\n        }\n\n        if (wc_ecc_init(eckey) != 0) {\n            WOLFSSL_MSG(\"wc_ecc_init failure\");\n            wc_ecc_free(eckey);\n            XFREE(eckey, cert->heap, DYNAMIC_TYPE_ECC);\n            XFREE(der, cert->heap, DYNAMIC_TYPE_CERT);\n            return MEMORY_E;\n        }\n\n        idx = 0;\n        ret = wc_EccPublicKeyDecode(der, &idx, eckey, derSz);\n        if (ret != 0) {\n            WOLFSSL_MSG(\"wc_EccPublicKeyDecode failed\");\n            XFREE(der, cert->heap, DYNAMIC_TYPE_CERT);\n            wc_ecc_free(eckey);\n            XFREE(eckey, cert->heap, DYNAMIC_TYPE_ECC);\n            return PUBLIC_KEY_E;\n        }\n#else\n        XFREE(der, cert->heap, DYNAMIC_TYPE_CERT);\n        return PUBLIC_KEY_E;\n#endif /* HAVE_ECC */\n    }\n\n    XFREE(der, cert->heap, DYNAMIC_TYPE_CERT);\n\n    ret = wc_SetSubjectKeyIdFromPublicKey(cert, rsakey, eckey);\n\n#ifndef NO_RSA\n    wc_FreeRsaKey(rsakey);\n    XFREE(rsakey, cert->heap, DYNAMIC_TYPE_RSA);\n#endif\n#ifdef HAVE_ECC\n    wc_ecc_free(eckey);\n    XFREE(eckey, cert->heap, DYNAMIC_TYPE_ECC);\n#endif\n    return ret;\n}\n\n#endif /* !NO_FILESYSTEM && !NO_ASN_CRYPT */\n\nstatic int SetAuthKeyIdFromDcert(Cert* cert, DecodedCert* decoded)\n{\n    int ret = 0;\n\n    /* Subject Key Id not found !! */\n    if (decoded->extSubjKeyIdSet == 0) {\n        ret = ASN_NO_SKID;\n    }\n\n    /* SKID invalid size */\n    else if (sizeof(cert->akid) < sizeof(decoded->extSubjKeyId)) {\n        ret = MEMORY_E;\n    }\n\n    else {\n        /* Put the SKID of CA to AKID of certificate */\n        XMEMCPY(cert->akid, decoded->extSubjKeyId, KEYID_SIZE);\n        cert->akidSz = KEYID_SIZE;\n    }\n\n    return ret;\n}\n\n/* Set AKID from certificate contains in buffer (DER encoded) */\nint wc_SetAuthKeyIdFromCert(Cert *cert, const byte *der, int derSz)\n{\n    int ret = 0;\n\n    if (cert == NULL) {\n        ret = BAD_FUNC_ARG;\n    }\n    else {\n        /* Check if decodedCert is cached */\n        if (cert->der != der) {\n            /* Allocate cache for the decoded cert */\n            ret = wc_SetCert_LoadDer(cert, der, derSz);\n        }\n\n        if (ret >= 0) {\n            ret = SetAuthKeyIdFromDcert(cert, (DecodedCert*)cert->decodedCert);\n#ifndef WOLFSSL_CERT_GEN_CACHE\n            wc_SetCert_Free(cert);\n#endif\n        }\n    }\n\n    return ret;\n}\n\n\n#ifndef NO_FILESYSTEM\n\n/* Set AKID from certificate file in PEM */\nint wc_SetAuthKeyId(Cert *cert, const char* file)\n{\n    int         ret;\n    int         derSz;\n    byte*       der;\n\n    if (cert == NULL || file == NULL)\n        return BAD_FUNC_ARG;\n\n    der = (byte*)XMALLOC(EIGHTK_BUF, cert->heap, DYNAMIC_TYPE_CERT);\n    if (der == NULL) {\n        WOLFSSL_MSG(\"wc_SetAuthKeyId OOF Problem\");\n        return MEMORY_E;\n    }\n\n    derSz = wc_PemCertToDer(file, der, EIGHTK_BUF);\n    if (derSz <= 0)\n    {\n        XFREE(der, cert->heap, DYNAMIC_TYPE_CERT);\n        return derSz;\n    }\n\n    ret = wc_SetAuthKeyIdFromCert(cert, der, derSz);\n    XFREE(der, cert->heap, DYNAMIC_TYPE_CERT);\n\n    return ret;\n}\n\n#endif /* !NO_FILESYSTEM */\n\n/* Set KeyUsage from human readable string */\nint wc_SetKeyUsage(Cert *cert, const char *value)\n{\n    int ret = 0;\n    char *token, *str, *ptr;\n    word32 len;\n\n    if (cert == NULL || value == NULL)\n        return BAD_FUNC_ARG;\n\n    cert->keyUsage = 0;\n\n    /* duplicate string (including terminator) */\n    len = (word32)XSTRLEN(value);\n    str = (char*)XMALLOC(len+1, cert->heap, DYNAMIC_TYPE_TMP_BUFFER);\n    if (str == NULL)\n        return MEMORY_E;\n    XMEMCPY(str, value, len+1);\n\n    /* parse value, and set corresponding Key Usage value */\n    if ((token = XSTRTOK(str, \",\", &ptr)) == NULL) {\n        XFREE(str, cert->heap, DYNAMIC_TYPE_TMP_BUFFER);\n        return KEYUSAGE_E;\n    }\n    while (token != NULL)\n    {\n        len = (word32)XSTRLEN(token);\n\n        if (!XSTRNCASECMP(token, \"digitalSignature\", len))\n            cert->keyUsage |= KEYUSE_DIGITAL_SIG;\n        else if (!XSTRNCASECMP(token, \"nonRepudiation\", len) ||\n                 !XSTRNCASECMP(token, \"contentCommitment\", len))\n            cert->keyUsage |= KEYUSE_CONTENT_COMMIT;\n        else if (!XSTRNCASECMP(token, \"keyEncipherment\", len))\n            cert->keyUsage |= KEYUSE_KEY_ENCIPHER;\n        else if (!XSTRNCASECMP(token, \"dataEncipherment\", len))\n            cert->keyUsage |= KEYUSE_DATA_ENCIPHER;\n        else if (!XSTRNCASECMP(token, \"keyAgreement\", len))\n            cert->keyUsage |= KEYUSE_KEY_AGREE;\n        else if (!XSTRNCASECMP(token, \"keyCertSign\", len))\n            cert->keyUsage |= KEYUSE_KEY_CERT_SIGN;\n        else if (!XSTRNCASECMP(token, \"cRLSign\", len))\n            cert->keyUsage |= KEYUSE_CRL_SIGN;\n        else if (!XSTRNCASECMP(token, \"encipherOnly\", len))\n            cert->keyUsage |= KEYUSE_ENCIPHER_ONLY;\n        else if (!XSTRNCASECMP(token, \"decipherOnly\", len))\n            cert->keyUsage |= KEYUSE_DECIPHER_ONLY;\n        else {\n            ret = KEYUSAGE_E;\n            break;\n        }\n\n        token = XSTRTOK(NULL, \",\", &ptr);\n    }\n\n    XFREE(str, cert->heap, DYNAMIC_TYPE_TMP_BUFFER);\n    return ret;\n}\n\n/* Set ExtendedKeyUsage from human readable string */\nint wc_SetExtKeyUsage(Cert *cert, const char *value)\n{\n    int ret = 0;\n    char *token, *str, *ptr;\n    word32 len;\n\n    if (cert == NULL || value == NULL)\n        return BAD_FUNC_ARG;\n\n    cert->extKeyUsage = 0;\n\n    /* duplicate string (including terminator) */\n    len = (word32)XSTRLEN(value);\n    str = (char*)XMALLOC(len+1, cert->heap, DYNAMIC_TYPE_TMP_BUFFER);\n    if (str == NULL)\n        return MEMORY_E;\n    XMEMCPY(str, value, len+1);\n\n    /* parse value, and set corresponding Key Usage value */\n    if ((token = XSTRTOK(str, \",\", &ptr)) == NULL) {\n        XFREE(str, cert->heap, DYNAMIC_TYPE_TMP_BUFFER);\n        return EXTKEYUSAGE_E;\n    }\n\n    while (token != NULL)\n    {\n        len = (word32)XSTRLEN(token);\n\n        if (!XSTRNCASECMP(token, \"any\", len))\n            cert->extKeyUsage |= EXTKEYUSE_ANY;\n        else if (!XSTRNCASECMP(token, \"serverAuth\", len))\n            cert->extKeyUsage |= EXTKEYUSE_SERVER_AUTH;\n        else if (!XSTRNCASECMP(token, \"clientAuth\", len))\n            cert->extKeyUsage |= EXTKEYUSE_CLIENT_AUTH;\n        else if (!XSTRNCASECMP(token, \"codeSigning\", len))\n            cert->extKeyUsage |= EXTKEYUSE_CODESIGN;\n        else if (!XSTRNCASECMP(token, \"emailProtection\", len))\n            cert->extKeyUsage |= EXTKEYUSE_EMAILPROT;\n        else if (!XSTRNCASECMP(token, \"timeStamping\", len))\n            cert->extKeyUsage |= EXTKEYUSE_TIMESTAMP;\n        else if (!XSTRNCASECMP(token, \"OCSPSigning\", len))\n            cert->extKeyUsage |= EXTKEYUSE_OCSP_SIGN;\n        else {\n            ret = EXTKEYUSAGE_E;\n            break;\n        }\n\n        token = XSTRTOK(NULL, \",\", &ptr);\n    }\n\n    XFREE(str, cert->heap, DYNAMIC_TYPE_TMP_BUFFER);\n    return ret;\n}\n\n#ifdef WOLFSSL_EKU_OID\n/*\n * cert structure to set EKU oid in\n * oid  the oid in byte representation\n * sz   size of oid buffer\n * idx  index of array to place oid\n *\n * returns 0 on success\n */\nint wc_SetExtKeyUsageOID(Cert *cert, const char *in, word32 sz, byte idx,\n        void* heap)\n{\n    byte oid[MAX_OID_SZ];\n    word32 oidSz = MAX_OID_SZ;\n\n    if (idx >= CTC_MAX_EKU_NB || sz >= CTC_MAX_EKU_OID_SZ) {\n        WOLFSSL_MSG(\"Either idx or sz was too large\");\n        return BAD_FUNC_ARG;\n    }\n\n    if (EncodePolicyOID(oid, &oidSz, in, heap) != 0) {\n        return BUFFER_E;\n    }\n\n    XMEMCPY(cert->extKeyUsageOID[idx], oid, oidSz);\n    cert->extKeyUsageOIDSz[idx] = oidSz;\n    cert->extKeyUsage |= EXTKEYUSE_USER;\n\n    return 0;\n}\n#endif /* WOLFSSL_EKU_OID */\n#endif /* WOLFSSL_CERT_EXT */\n\n\n#ifdef WOLFSSL_ALT_NAMES\n\nstatic int SetAltNamesFromDcert(Cert* cert, DecodedCert* decoded)\n{\n    int ret = 0;\n\n    cert->altNamesSz = 0;\n    if (decoded->altNames) {\n        ret = FlattenAltNames(cert->altNames,\n            sizeof(cert->altNames), decoded->altNames);\n        if (ret >= 0) {\n            cert->altNamesSz = ret;\n            ret = 0;\n        }\n    }\n\n    return ret;\n}\n\n#ifndef NO_FILESYSTEM\n\n/* Set Alt Names from der cert, return 0 on success */\nstatic int SetAltNamesFromCert(Cert* cert, const byte* der, int derSz)\n{\n    int ret;\n#ifdef WOLFSSL_SMALL_STACK\n    DecodedCert* decoded;\n#else\n    DecodedCert decoded[1];\n#endif\n\n    if (derSz < 0)\n        return derSz;\n\n#ifdef WOLFSSL_SMALL_STACK\n    decoded = (DecodedCert*)XMALLOC(sizeof(DecodedCert), cert->heap,\n                                                       DYNAMIC_TYPE_TMP_BUFFER);\n    if (decoded == NULL)\n        return MEMORY_E;\n#endif\n\n    InitDecodedCert(decoded, der, derSz, NULL);\n    ret = ParseCertRelative(decoded, CA_TYPE, NO_VERIFY, 0);\n\n    if (ret < 0) {\n        WOLFSSL_MSG(\"ParseCertRelative error\");\n    }\n    else {\n        ret = SetAltNamesFromDcert(cert, decoded);\n    }\n\n    FreeDecodedCert(decoded);\n#ifdef WOLFSSL_SMALL_STACK\n    XFREE(decoded, cert->heap, DYNAMIC_TYPE_TMP_BUFFER);\n#endif\n\n    return ret < 0 ? ret : 0;\n}\n\n#endif\n\nstatic int SetDatesFromDcert(Cert* cert, DecodedCert* decoded)\n{\n    int ret = 0;\n\n    if (decoded->beforeDate == NULL || decoded->afterDate == NULL) {\n        WOLFSSL_MSG(\"Couldn't extract dates\");\n        ret = -1;\n    }\n    else if (decoded->beforeDateLen > MAX_DATE_SIZE ||\n                                        decoded->afterDateLen > MAX_DATE_SIZE) {\n        WOLFSSL_MSG(\"Bad date size\");\n        ret = -1;\n    }\n    else {\n        XMEMCPY(cert->beforeDate, decoded->beforeDate, decoded->beforeDateLen);\n        XMEMCPY(cert->afterDate,  decoded->afterDate,  decoded->afterDateLen);\n\n        cert->beforeDateSz = decoded->beforeDateLen;\n        cert->afterDateSz  = decoded->afterDateLen;\n    }\n\n    return ret;\n}\n\n#endif /* WOLFSSL_ALT_NAMES */\n\nstatic void SetNameFromDcert(CertName* cn, DecodedCert* decoded)\n{\n    int sz;\n\n    if (decoded->subjectCN) {\n        sz = (decoded->subjectCNLen < CTC_NAME_SIZE) ? decoded->subjectCNLen\n                                                     : CTC_NAME_SIZE - 1;\n        XSTRNCPY(cn->commonName, decoded->subjectCN, sz);\n        cn->commonName[sz] = '\\0';\n        cn->commonNameEnc = decoded->subjectCNEnc;\n    }\n    if (decoded->subjectC) {\n        sz = (decoded->subjectCLen < CTC_NAME_SIZE) ? decoded->subjectCLen\n                                                    : CTC_NAME_SIZE - 1;\n        XSTRNCPY(cn->country, decoded->subjectC, sz);\n        cn->country[sz] = '\\0';\n        cn->countryEnc = decoded->subjectCEnc;\n    }\n    if (decoded->subjectST) {\n        sz = (decoded->subjectSTLen < CTC_NAME_SIZE) ? decoded->subjectSTLen\n                                                     : CTC_NAME_SIZE - 1;\n        XSTRNCPY(cn->state, decoded->subjectST, sz);\n        cn->state[sz] = '\\0';\n        cn->stateEnc = decoded->subjectSTEnc;\n    }\n    if (decoded->subjectL) {\n        sz = (decoded->subjectLLen < CTC_NAME_SIZE) ? decoded->subjectLLen\n                                                    : CTC_NAME_SIZE - 1;\n        XSTRNCPY(cn->locality, decoded->subjectL, sz);\n        cn->locality[sz] = '\\0';\n        cn->localityEnc = decoded->subjectLEnc;\n    }\n    if (decoded->subjectO) {\n        sz = (decoded->subjectOLen < CTC_NAME_SIZE) ? decoded->subjectOLen\n                                                    : CTC_NAME_SIZE - 1;\n        XSTRNCPY(cn->org, decoded->subjectO, sz);\n        cn->org[sz] = '\\0';\n        cn->orgEnc = decoded->subjectOEnc;\n    }\n    if (decoded->subjectOU) {\n        sz = (decoded->subjectOULen < CTC_NAME_SIZE) ? decoded->subjectOULen\n                                                     : CTC_NAME_SIZE - 1;\n        XSTRNCPY(cn->unit, decoded->subjectOU, sz);\n        cn->unit[sz] = '\\0';\n        cn->unitEnc = decoded->subjectOUEnc;\n    }\n    if (decoded->subjectSN) {\n        sz = (decoded->subjectSNLen < CTC_NAME_SIZE) ? decoded->subjectSNLen\n                                                     : CTC_NAME_SIZE - 1;\n        XSTRNCPY(cn->sur, decoded->subjectSN, sz);\n        cn->sur[sz] = '\\0';\n        cn->surEnc = decoded->subjectSNEnc;\n    }\n    if (decoded->subjectSND) {\n        sz = (decoded->subjectSNDLen < CTC_NAME_SIZE) ? decoded->subjectSNDLen\n                                                     : CTC_NAME_SIZE - 1;\n        XSTRNCPY(cn->serialDev, decoded->subjectSND, sz);\n        cn->serialDev[sz] = '\\0';\n        cn->serialDevEnc = decoded->subjectSNDEnc;\n    }\n#ifdef WOLFSSL_CERT_EXT\n    if (decoded->subjectBC) {\n        sz = (decoded->subjectBCLen < CTC_NAME_SIZE) ? decoded->subjectBCLen\n                                                     : CTC_NAME_SIZE - 1;\n        XSTRNCPY(cn->busCat, decoded->subjectBC, sz);\n        cn->busCat[sz] = '\\0';\n        cn->busCatEnc = decoded->subjectBCEnc;\n    }\n    if (decoded->subjectJC) {\n        sz = (decoded->subjectJCLen < CTC_NAME_SIZE) ? decoded->subjectJCLen\n                                                     : CTC_NAME_SIZE - 1;\n        XSTRNCPY(cn->joiC, decoded->subjectJC, sz);\n        cn->joiC[sz] = '\\0';\n        cn->joiCEnc = decoded->subjectJCEnc;\n    }\n    if (decoded->subjectJS) {\n        sz = (decoded->subjectJSLen < CTC_NAME_SIZE) ? decoded->subjectJSLen\n                                                     : CTC_NAME_SIZE - 1;\n        XSTRNCPY(cn->joiSt, decoded->subjectJS, sz);\n        cn->joiSt[sz] = '\\0';\n        cn->joiStEnc = decoded->subjectJSEnc;\n    }\n#endif\n    if (decoded->subjectEmail) {\n        sz = (decoded->subjectEmailLen < CTC_NAME_SIZE)\n           ?  decoded->subjectEmailLen : CTC_NAME_SIZE - 1;\n        XSTRNCPY(cn->email, decoded->subjectEmail, sz);\n        cn->email[sz] = '\\0';\n    }\n}\n\n#ifndef NO_FILESYSTEM\n\n/* Set cn name from der buffer, return 0 on success */\nstatic int SetNameFromCert(CertName* cn, const byte* der, int derSz)\n{\n    int ret;\n#ifdef WOLFSSL_SMALL_STACK\n    DecodedCert* decoded;\n#else\n    DecodedCert decoded[1];\n#endif\n\n    if (derSz < 0)\n        return derSz;\n\n#ifdef WOLFSSL_SMALL_STACK\n    decoded = (DecodedCert*)XMALLOC(sizeof(DecodedCert), NULL,\n                                                       DYNAMIC_TYPE_TMP_BUFFER);\n    if (decoded == NULL)\n        return MEMORY_E;\n#endif\n\n    InitDecodedCert(decoded, der, derSz, NULL);\n    ret = ParseCertRelative(decoded, CA_TYPE, NO_VERIFY, 0);\n\n    if (ret < 0) {\n        WOLFSSL_MSG(\"ParseCertRelative error\");\n    }\n    else {\n        SetNameFromDcert(cn, decoded);\n    }\n\n    FreeDecodedCert(decoded);\n\n#ifdef WOLFSSL_SMALL_STACK\n    XFREE(decoded, NULL, DYNAMIC_TYPE_TMP_BUFFER);\n#endif\n\n    return ret < 0 ? ret : 0;\n}\n\n/* Set cert issuer from issuerFile in PEM */\nint wc_SetIssuer(Cert* cert, const char* issuerFile)\n{\n    int         ret;\n    int         derSz;\n    byte*       der;\n\n    if (cert == NULL) {\n        return BAD_FUNC_ARG;\n    }\n\n    der = (byte*)XMALLOC(EIGHTK_BUF, cert->heap, DYNAMIC_TYPE_CERT);\n    if (der == NULL) {\n        WOLFSSL_MSG(\"wc_SetIssuer OOF Problem\");\n        return MEMORY_E;\n    }\n    derSz = wc_PemCertToDer(issuerFile, der, EIGHTK_BUF);\n    cert->selfSigned = 0;\n    ret = SetNameFromCert(&cert->issuer, der, derSz);\n    XFREE(der, cert->heap, DYNAMIC_TYPE_CERT);\n\n    return ret;\n}\n\n\n/* Set cert subject from subjectFile in PEM */\nint wc_SetSubject(Cert* cert, const char* subjectFile)\n{\n    int         ret;\n    int         derSz;\n    byte*       der;\n\n    if (cert == NULL) {\n        return BAD_FUNC_ARG;\n    }\n\n    der = (byte*)XMALLOC(EIGHTK_BUF, cert->heap, DYNAMIC_TYPE_CERT);\n    if (der == NULL) {\n        WOLFSSL_MSG(\"wc_SetSubject OOF Problem\");\n        return MEMORY_E;\n    }\n\n    derSz = wc_PemCertToDer(subjectFile, der, EIGHTK_BUF);\n    ret = SetNameFromCert(&cert->subject, der, derSz);\n    XFREE(der, cert->heap, DYNAMIC_TYPE_CERT);\n\n    return ret;\n}\n\n#ifdef WOLFSSL_ALT_NAMES\n\n/* Set alt names from file in PEM */\nint wc_SetAltNames(Cert* cert, const char* file)\n{\n    int         ret;\n    int         derSz;\n    byte*       der;\n\n    if (cert == NULL) {\n        return BAD_FUNC_ARG;\n    }\n\n    der = (byte*)XMALLOC(EIGHTK_BUF, cert->heap, DYNAMIC_TYPE_CERT);\n    if (der == NULL) {\n        WOLFSSL_MSG(\"wc_SetAltNames OOF Problem\");\n        return MEMORY_E;\n    }\n    derSz = wc_PemCertToDer(file, der, EIGHTK_BUF);\n    ret = SetAltNamesFromCert(cert, der, derSz);\n    XFREE(der, cert->heap, DYNAMIC_TYPE_CERT);\n\n    return ret;\n}\n\n#endif /* WOLFSSL_ALT_NAMES */\n\n#endif /* !NO_FILESYSTEM */\n\n/* Set cert issuer from DER buffer */\nint wc_SetIssuerBuffer(Cert* cert, const byte* der, int derSz)\n{\n    int ret = 0;\n\n    if (cert == NULL) {\n        ret = BAD_FUNC_ARG;\n    }\n    else {\n        cert->selfSigned = 0;\n\n        /* Check if decodedCert is cached */\n        if (cert->der != der) {\n            /* Allocate cache for the decoded cert */\n            ret = wc_SetCert_LoadDer(cert, der, derSz);\n        }\n\n        if (ret >= 0) {\n            SetNameFromDcert(&cert->issuer, (DecodedCert*)cert->decodedCert);\n#ifndef WOLFSSL_CERT_GEN_CACHE\n            wc_SetCert_Free(cert);\n#endif\n        }\n    }\n\n    return ret;\n}\n\n/* Set cert subject from DER buffer */\nint wc_SetSubjectBuffer(Cert* cert, const byte* der, int derSz)\n{\n    int ret = 0;\n\n    if (cert == NULL) {\n        ret = BAD_FUNC_ARG;\n    }\n    else {\n        /* Check if decodedCert is cached */\n        if (cert->der != der) {\n            /* Allocate cache for the decoded cert */\n            ret = wc_SetCert_LoadDer(cert, der, derSz);\n        }\n\n        if (ret >= 0) {\n            SetNameFromDcert(&cert->subject, (DecodedCert*)cert->decodedCert);\n#ifndef WOLFSSL_CERT_GEN_CACHE\n            wc_SetCert_Free(cert);\n#endif\n        }\n    }\n\n    return ret;\n}\n#ifdef WOLFSSL_CERT_EXT\n/* Set cert raw subject from DER buffer */\nint wc_SetSubjectRaw(Cert* cert, const byte* der, int derSz)\n{\n    int ret = 0;\n\n    if (cert == NULL) {\n        ret = BAD_FUNC_ARG;\n    }\n    else {\n        /* Check if decodedCert is cached */\n        if (cert->der != der) {\n            /* Allocate cache for the decoded cert */\n            ret = wc_SetCert_LoadDer(cert, der, derSz);\n        }\n\n        if (ret >= 0) {\n            if ((((DecodedCert*)cert->decodedCert)->subjectRaw) &&\n                (((DecodedCert*)cert->decodedCert)->subjectRawLen <=\n                        (int)sizeof(CertName))) {\n                XMEMCPY(cert->sbjRaw,\n                        ((DecodedCert*)cert->decodedCert)->subjectRaw,\n                        ((DecodedCert*)cert->decodedCert)->subjectRawLen);\n            }\n#ifndef WOLFSSL_CERT_GEN_CACHE\n            wc_SetCert_Free(cert);\n#endif\n        }\n    }\n\n    return ret;\n}\n\n/* Set cert raw issuer from DER buffer */\nint wc_SetIssuerRaw(Cert* cert, const byte* der, int derSz)\n{\n    int ret = 0;\n\n    if (cert == NULL) {\n        ret = BAD_FUNC_ARG;\n    }\n    else {\n        /* Check if decodedCert is cached */\n        if (cert->der != der) {\n            /* Allocate cache for the decoded cert */\n            ret = wc_SetCert_LoadDer(cert, der, derSz);\n        }\n\n        if (ret >= 0) {\n            if ((((DecodedCert*)cert->decodedCert)->subjectRaw) &&\n                (((DecodedCert*)cert->decodedCert)->subjectRawLen <=\n                        (int)sizeof(CertName))) {\n                /* Copy the subject to the issuer field */\n                XMEMCPY(cert->issRaw,\n                        ((DecodedCert*)cert->decodedCert)->subjectRaw,\n                        ((DecodedCert*)cert->decodedCert)->subjectRawLen);\n            }\n#ifndef WOLFSSL_CERT_GEN_CACHE\n            wc_SetCert_Free(cert);\n#endif\n        }\n    }\n    return ret;\n}\n#endif\n\n#ifdef WOLFSSL_ALT_NAMES\n\n/* Set cert alt names from DER buffer */\nint wc_SetAltNamesBuffer(Cert* cert, const byte* der, int derSz)\n{\n    int ret = 0;\n\n    if (cert == NULL) {\n       ret = BAD_FUNC_ARG;\n    }\n    else {\n        /* Check if decodedCert is cached */\n        if (cert->der != der) {\n            /* Allocate cache for the decoded cert */\n            ret = wc_SetCert_LoadDer(cert, der, derSz);\n        }\n\n        if (ret >= 0) {\n            ret = SetAltNamesFromDcert(cert, (DecodedCert*)cert->decodedCert);\n#ifndef WOLFSSL_CERT_GEN_CACHE\n            wc_SetCert_Free(cert);\n#endif\n       }\n    }\n\n    return(ret);\n}\n\n/* Set cert dates from DER buffer */\nint wc_SetDatesBuffer(Cert* cert, const byte* der, int derSz)\n{\n    int ret = 0;\n\n    if (cert == NULL) {\n     ret = BAD_FUNC_ARG;\n    }\n    else {\n        /* Check if decodedCert is cached */\n        if (cert->der != der) {\n            /* Allocate cache for the decoded cert */\n            ret = wc_SetCert_LoadDer(cert, der, derSz);\n        }\n\n        if (ret >= 0) {\n            ret = SetDatesFromDcert(cert, (DecodedCert*)cert->decodedCert);\n#ifndef WOLFSSL_CERT_GEN_CACHE\n            wc_SetCert_Free(cert);\n#endif\n        }\n    }\n\n    return(ret);\n}\n\n#endif /* WOLFSSL_ALT_NAMES */\n\n#endif /* WOLFSSL_CERT_GEN */\n\n#if (defined(WOLFSSL_CERT_GEN) && defined(WOLFSSL_CERT_EXT)) \\\n        || defined(OPENSSL_EXTRA)\n/* Encode OID string representation to ITU-T X.690 format */\nint EncodePolicyOID(byte *out, word32 *outSz, const char *in, void* heap)\n{\n    word32 val, idx = 0, nb_val;\n    char *token, *str, *ptr;\n    word32 len;\n\n    (void)heap;\n\n    if (out == NULL || outSz == NULL || *outSz < 2 || in == NULL)\n        return BAD_FUNC_ARG;\n\n    /* duplicate string (including terminator) */\n    len = (word32)XSTRLEN(in);\n    str = (char *)XMALLOC(len+1, heap, DYNAMIC_TYPE_TMP_BUFFER);\n    if (str == NULL)\n        return MEMORY_E;\n    XMEMCPY(str, in, len+1);\n\n    nb_val = 0;\n\n    /* parse value, and set corresponding Policy OID value */\n    token = XSTRTOK(str, \".\", &ptr);\n    while (token != NULL)\n    {\n        val = (word32)XATOI(token);\n\n        if (nb_val == 0) {\n            if (val > 2) {\n                XFREE(str, heap, DYNAMIC_TYPE_TMP_BUFFER);\n                return ASN_OBJECT_ID_E;\n            }\n\n            out[idx] = (byte)(40 * val);\n        }\n        else if (nb_val == 1) {\n            if (val > 127) {\n                XFREE(str, heap, DYNAMIC_TYPE_TMP_BUFFER);\n                return ASN_OBJECT_ID_E;\n            }\n\n            if (idx > *outSz) {\n                XFREE(str, heap, DYNAMIC_TYPE_TMP_BUFFER);\n                return BUFFER_E;\n            }\n\n            out[idx++] += (byte)val;\n        }\n        else {\n            word32  tb = 0, x;\n            int     i = 0;\n            byte    oid[MAX_OID_SZ];\n\n            while (val >= 128) {\n                x = val % 128;\n                val /= 128;\n                oid[i++] = (byte) (((tb++) ? 0x80 : 0) | x);\n            }\n\n            if ((idx+(word32)i) >= *outSz) {\n                XFREE(str, heap, DYNAMIC_TYPE_TMP_BUFFER);\n                return BUFFER_E;\n            }\n\n            oid[i] = (byte) (((tb++) ? 0x80 : 0) | val);\n\n            /* push value in the right order */\n            while (i >= 0)\n                out[idx++] = oid[i--];\n        }\n\n        token = XSTRTOK(NULL, \".\", &ptr);\n        nb_val++;\n    }\n\n    *outSz = idx;\n\n    XFREE(str, heap, DYNAMIC_TYPE_TMP_BUFFER);\n    return 0;\n}\n#endif /* WOLFSSL_CERT_EXT || OPENSSL_EXTRA */\n\n#endif /* !NO_CERTS */\n\n#if !defined(NO_DH) && (defined(WOLFSSL_QT) || defined(OPENSSL_ALL))\n/* Helper function for wolfSSL_i2d_DHparams */\nint StoreDHparams(byte* out, word32* outLen, mp_int* p, mp_int* g)\n{\n    word32 idx = 0;\n    int pSz;\n    int gSz;\n    unsigned int tmp;\n    word32 headerSz = 4; /* 2*ASN_TAG + 2*LEN(ENUM) */\n\n    /* If the leading bit on the INTEGER is a 1, add a leading zero */\n    int pLeadingZero = mp_leading_bit(p);\n    int gLeadingZero = mp_leading_bit(g);\n    int pLen = mp_unsigned_bin_size(p);\n    int gLen = mp_unsigned_bin_size(g);\n\n    WOLFSSL_ENTER(\"StoreDHparams\");\n    if (out == NULL) {\n        WOLFSSL_MSG(\"Null buffer error\");\n        return BUFFER_E;\n    }\n\n    tmp = pLeadingZero + gLeadingZero + pLen + gLen;\n    if (*outLen < (tmp + headerSz)) {\n        return BUFFER_E;\n    }\n\n    /* Set sequence */\n    idx = SetSequence(tmp + headerSz + 2, out);\n\n    /* Encode p */\n    pSz = SetASNIntMP(p, -1, &out[idx]);\n    if (pSz < 0) {\n        WOLFSSL_MSG(\"SetASNIntMP failed\");\n        return pSz;\n    }\n    idx += pSz;\n\n    /* Encode g */\n    gSz = SetASNIntMP(g, -1, &out[idx]);\n    if (gSz < 0) {\n        WOLFSSL_MSG(\"SetASNIntMP failed\");\n        return gSz;\n    }\n    idx += gSz;\n\n    *outLen = idx;\n\n    return 0;\n}\n#endif /* !NO_DH && (WOLFSSL_QT || OPENSSL_ALL) */\n\n#ifdef HAVE_ECC\n\n/* Der Encode r & s ints into out, outLen is (in/out) size */\nint StoreECC_DSA_Sig(byte* out, word32* outLen, mp_int* r, mp_int* s)\n{\n    word32 idx = 0;\n    int    rSz;                           /* encoding size */\n    int    sSz;\n    word32 headerSz = 4;   /* 2*ASN_TAG + 2*LEN(ENUM) */\n\n    /* If the leading bit on the INTEGER is a 1, add a leading zero */\n    int rLeadingZero = mp_leading_bit(r);\n    int sLeadingZero = mp_leading_bit(s);\n    int rLen = mp_unsigned_bin_size(r);   /* big int size */\n    int sLen = mp_unsigned_bin_size(s);\n\n    if (*outLen < (rLen + rLeadingZero + sLen + sLeadingZero +\n                   headerSz + 2))  /* SEQ_TAG + LEN(ENUM) */\n        return BUFFER_E;\n\n    idx = SetSequence(rLen + rLeadingZero + sLen+sLeadingZero + headerSz, out);\n\n    /* store r */\n    rSz = SetASNIntMP(r, *outLen - idx, &out[idx]);\n    if (rSz < 0)\n        return rSz;\n    idx += rSz;\n\n    /* store s */\n    sSz = SetASNIntMP(s, *outLen - idx, &out[idx]);\n    if (sSz < 0)\n        return sSz;\n    idx += sSz;\n\n    *outLen = idx;\n\n    return 0;\n}\n\n/* determine if leading bit is set */\nstatic int is_leading_bit_set(const byte* input, word32 sz)\n{\n    byte c = 0;\n    if (sz > 0)\n        c = input[0];\n    return (c & 0x80) != 0;\n}\nstatic int trim_leading_zeros(const byte** input, word32 sz)\n{\n    int i, leadingZeroCount = 0;\n    const byte* tmp = *input;\n    for (i=0; i<(int)sz; i++) {\n        if (tmp[i] != 0)\n            break;\n        leadingZeroCount++;\n    }\n    /* catch all zero case */\n    if (sz > 0 && leadingZeroCount == (int)sz) {\n        leadingZeroCount--;\n    }\n    *input += leadingZeroCount;\n    sz -= leadingZeroCount;\n    return sz;\n}\n\n/* Der Encode r & s ints into out, outLen is (in/out) size */\n/* All input/outputs are assumed to be big-endian */\nint StoreECC_DSA_Sig_Bin(byte* out, word32* outLen, const byte* r, word32 rLen, \n    const byte* s, word32 sLen)\n{\n    int ret;\n    word32 idx;\n    word32 headerSz = 4;   /* 2*ASN_TAG + 2*LEN(ENUM) */\n    int rAddLeadZero, sAddLeadZero;\n\n    if ((out == NULL) || (outLen == NULL) || (r == NULL) || (s == NULL))\n        return BAD_FUNC_ARG;\n\n    /* Trim leading zeros */\n    rLen = trim_leading_zeros(&r, rLen);\n    sLen = trim_leading_zeros(&s, sLen);\n    /* If the leading bit on the INTEGER is a 1, add a leading zero */\n    /* Add leading zero if MSB is set */\n    rAddLeadZero = is_leading_bit_set(r, rLen);\n    sAddLeadZero = is_leading_bit_set(s, sLen);\n\n    if (*outLen < (rLen + rAddLeadZero + sLen + sAddLeadZero +\n                   headerSz + 2))  /* SEQ_TAG + LEN(ENUM) */\n        return BUFFER_E;\n\n    idx = SetSequence(rLen+rAddLeadZero + sLen+sAddLeadZero + headerSz, out);\n\n    /* store r */\n    ret = SetASNInt(rLen, rAddLeadZero ? 0x80 : 0x00, &out[idx]);\n    if (ret < 0)\n        return ret;\n    idx += ret;\n    XMEMCPY(&out[idx], r, rLen);\n    idx += rLen;\n\n    /* store s */\n    ret = SetASNInt(sLen, sAddLeadZero ? 0x80 : 0x00, &out[idx]);\n    if (ret < 0)\n        return ret;\n    idx += ret;\n    XMEMCPY(&out[idx], s, sLen);\n    idx += sLen;\n\n    *outLen = idx;\n\n    return 0;\n}\n\n/* Der Decode ECC-DSA Signature with R/S as unsigned bin */\n/* All input/outputs are assumed to be big-endian */\nint DecodeECC_DSA_Sig_Bin(const byte* sig, word32 sigLen, byte* r, word32* rLen,\n    byte* s, word32* sLen)\n{\n    int    ret;\n    word32 idx = 0;\n    int    len = 0;\n\n    if (GetSequence(sig, &idx, &len, sigLen) < 0) {\n        return ASN_ECC_KEY_E;\n    }\n\n#ifndef NO_STRICT_ECDSA_LEN\n    /* enable strict length checking for signature */\n    if (sigLen != idx + (word32)len) {\n        return ASN_ECC_KEY_E;\n    }\n#else\n    /* allow extra signature bytes at end */\n    if ((word32)len > (sigLen - idx)) {\n        return ASN_ECC_KEY_E;\n    }\n#endif\n\n    ret = GetASNInt(sig, &idx, &len, sigLen);\n    if (ret != 0)\n        return ret;\n    if (rLen)\n        *rLen = len;\n    if (r)\n        XMEMCPY(r, (byte*)sig + idx, len);\n    idx += len;\n\n    ret = GetASNInt(sig, &idx, &len, sigLen);\n    if (ret != 0)\n        return ret;\n    if (sLen)\n        *sLen = len;\n    if (s)\n        XMEMCPY(s, (byte*)sig + idx, len);\n\n#ifndef NO_STRICT_ECDSA_LEN\n    /* sanity check that the index has been advanced all the way to the end of\n     * the buffer */\n    if (idx + len != sigLen) {\n        ret = ASN_ECC_KEY_E;\n    }\n#endif\n\n    return ret;\n}\n#endif\n\n#if defined(HAVE_ECC) || !defined(NO_DSA)\nint DecodeECC_DSA_Sig(const byte* sig, word32 sigLen, mp_int* r, mp_int* s)\n{\n    word32 idx = 0;\n    int    len = 0;\n\n    if (GetSequence(sig, &idx, &len, sigLen) < 0) {\n        return ASN_ECC_KEY_E;\n    }\n\n#ifndef NO_STRICT_ECDSA_LEN\n    /* enable strict length checking for signature */\n    if (sigLen != idx + (word32)len) {\n        return ASN_ECC_KEY_E;\n    }\n#else\n    /* allow extra signature bytes at end */\n    if ((word32)len > (sigLen - idx)) {\n        return ASN_ECC_KEY_E;\n    }\n#endif\n\n    if (GetInt(r, sig, &idx, sigLen) < 0) {\n        return ASN_ECC_KEY_E;\n    }\n\n    if (GetInt(s, sig, &idx, sigLen) < 0) {\n        mp_clear(r);\n        return ASN_ECC_KEY_E;\n    }\n\n#ifndef NO_STRICT_ECDSA_LEN\n    /* sanity check that the index has been advanced all the way to the end of\n     * the buffer */\n    if (idx != sigLen) {\n        mp_clear(r);\n        mp_clear(s);\n        return ASN_ECC_KEY_E;\n    }\n#endif\n\n    return 0;\n}\n#endif\n\n#ifdef HAVE_ECC\nint wc_EccPrivateKeyDecode(const byte* input, word32* inOutIdx, ecc_key* key,\n                        word32 inSz)\n{\n    word32 oidSum;\n    int    version, length;\n    int    privSz, pubSz = 0;\n    byte   b;\n    int    ret = 0;\n    int    curve_id = ECC_CURVE_DEF;\n#ifdef WOLFSSL_SMALL_STACK\n    byte* priv;\n    byte* pub = NULL;\n#else\n    byte priv[ECC_MAXSIZE+1];\n    byte pub[2*(ECC_MAXSIZE+1)]; /* public key has two parts plus header */\n#endif\n    byte* pubData = NULL;\n\n    if (input == NULL || inOutIdx == NULL || key == NULL || inSz == 0)\n        return BAD_FUNC_ARG;\n\n    if (GetSequence(input, inOutIdx, &length, inSz) < 0)\n        return ASN_PARSE_E;\n\n    if (GetMyVersion(input, inOutIdx, &version, inSz) < 0)\n        return ASN_PARSE_E;\n\n    if (*inOutIdx >= inSz)\n        return ASN_PARSE_E;\n\n    b = input[*inOutIdx];\n    *inOutIdx += 1;\n\n    /* priv type */\n    if (b != 4 && b != 6 && b != 7)\n        return ASN_PARSE_E;\n\n    if (GetLength(input, inOutIdx, &length, inSz) < 0)\n        return ASN_PARSE_E;\n    privSz = length;\n\n    if (privSz > ECC_MAXSIZE)\n        return BUFFER_E;\n\n#ifdef WOLFSSL_SMALL_STACK\n    priv = (byte*)XMALLOC(privSz, key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n    if (priv == NULL)\n        return MEMORY_E;\n#endif\n\n    /* priv key */\n    XMEMCPY(priv, &input[*inOutIdx], privSz);\n    *inOutIdx += length;\n\n    if ((*inOutIdx + 1) < inSz) {\n        /* prefix 0, may have */\n        b = input[*inOutIdx];\n        if (b == ECC_PREFIX_0) {\n            *inOutIdx += 1;\n\n            if (GetLength(input, inOutIdx, &length, inSz) <= 0)\n                ret = ASN_PARSE_E;\n            else {\n                ret = GetObjectId(input, inOutIdx, &oidSum, oidIgnoreType,\n                                  inSz);\n                if (ret == 0) {\n                    if ((ret = CheckCurve(oidSum)) < 0)\n                        ret = ECC_CURVE_OID_E;\n                    else {\n                        curve_id = ret;\n                        ret = 0;\n                    }\n                }\n            }\n        }\n    }\n\n    if (ret == 0 && (*inOutIdx + 1) < inSz) {\n        /* prefix 1 */\n        b = input[*inOutIdx];\n        *inOutIdx += 1;\n\n        if (b != ECC_PREFIX_1) {\n            ret = ASN_ECC_KEY_E;\n        }\n        else if (GetLength(input, inOutIdx, &length, inSz) <= 0) {\n            ret = ASN_PARSE_E;\n        }\n        else {\n            /* key header */\n            ret = CheckBitString(input, inOutIdx, &length, inSz, 0, NULL);\n            if (ret == 0) {\n                /* pub key */\n                pubSz = length;\n                if (pubSz > 2*(ECC_MAXSIZE+1))\n                    ret = BUFFER_E;\n                else {\n            #ifdef WOLFSSL_SMALL_STACK\n                    pub = (byte*)XMALLOC(pubSz, key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n                    if (pub == NULL)\n                        ret = MEMORY_E;\n                    else\n            #endif\n                    {\n                        XMEMCPY(pub, &input[*inOutIdx], pubSz);\n                        *inOutIdx += length;\n                        pubData = pub;\n                    }\n                }\n            }\n        }\n    }\n\n    if (ret == 0) {\n        ret = wc_ecc_import_private_key_ex(priv, privSz, pubData, pubSz, key,\n                                                                      curve_id);\n    }\n\n#ifdef WOLFSSL_SMALL_STACK\n    XFREE(priv, key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n    XFREE(pub,  key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n#endif\n\n    return ret;\n}\n\n\n#ifdef WOLFSSL_CUSTOM_CURVES\nstatic void ByteToHex(byte n, char* str)\n{\n    const char hexChar[] = { '0', '1', '2', '3', '4', '5', '6', '7',\n                                    '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };\n\n    str[0] = hexChar[n >> 4];\n    str[1] = hexChar[n & 0xf];\n}\n\n/* returns 0 on success */\nstatic int ASNToHexString(const byte* input, word32* inOutIdx, char** out,\n                          word32 inSz, void* heap, int heapType)\n{\n    int len;\n    int i;\n    char* str;\n    word32 localIdx;\n    byte   tag;\n\n    if (*inOutIdx >= inSz) {\n        return BUFFER_E;\n    }\n\n    localIdx = *inOutIdx;\n    if (GetASNTag(input, &localIdx, &tag, inSz) == 0 && tag == ASN_INTEGER) {\n        if (GetASNInt(input, inOutIdx, &len, inSz) < 0)\n            return ASN_PARSE_E;\n    }\n    else {\n        if (GetOctetString(input, inOutIdx, &len, inSz) < 0)\n            return ASN_PARSE_E;\n    }\n\n    str = (char*)XMALLOC(len * 2 + 1, heap, heapType);\n    if (str == NULL) {\n        return MEMORY_E;\n    }\n\n    for (i=0; i<len; i++)\n        ByteToHex(input[*inOutIdx + i], str + i*2);\n    str[len*2] = '\\0';\n\n    *inOutIdx += len;\n    *out = str;\n\n    (void)heap;\n    (void)heapType;\n\n    return 0;\n}\n#endif /* WOLFSSL_CUSTOM_CURVES */\n\n#ifdef WOLFSSL_CUSTOM_CURVES\nstatic int EccKeyParamCopy(char** dst, char* src)\n{\n    int ret = 0;\n#ifdef WOLFSSL_ECC_CURVE_STATIC\n    word32 length;\n#endif\n\n    if (dst == NULL || src == NULL)\n        return BAD_FUNC_ARG;\n\n#ifndef WOLFSSL_ECC_CURVE_STATIC\n    *dst = src;\n#else\n    length = (int)XSTRLEN(src) + 1;\n    if (length > MAX_ECC_STRING) {\n        WOLFSSL_MSG(\"ECC Param too large for buffer\");\n        ret = BUFFER_E;\n    }\n    else {\n        XSTRNCPY(*dst, src, MAX_ECC_STRING);\n    }\n    XFREE(src, key->heap, DYNAMIC_TYPE_ECC_BUFFER);\n#endif\n\n    return ret;\n}\n#endif /* WOLFSSL_CUSTOM_CURVES */\n\nint wc_EccPublicKeyDecode(const byte* input, word32* inOutIdx,\n                          ecc_key* key, word32 inSz)\n{\n    int    ret;\n    int    version, length;\n    int    curve_id = ECC_CURVE_DEF;\n    word32 oidSum, localIdx;\n    byte   tag, isPrivFormat = 0;\n\n    if (input == NULL || inOutIdx == NULL || key == NULL || inSz == 0)\n        return BAD_FUNC_ARG;\n\n    if (GetSequence(input, inOutIdx, &length, inSz) < 0)\n        return ASN_PARSE_E;\n\n    /* Check if ECC private key is being used and skip private portion */\n    if (GetMyVersion(input, inOutIdx, &version, inSz) >= 0) {\n        isPrivFormat = 1;\n\n        /* Type private key */\n        if (*inOutIdx >= inSz)\n            return ASN_PARSE_E;\n        tag = input[*inOutIdx];\n        *inOutIdx += 1;\n        if (tag != 4 && tag != 6 && tag != 7)\n            return ASN_PARSE_E;\n\n        /* Skip Private Key */\n        if (GetLength(input, inOutIdx, &length, inSz) < 0)\n            return ASN_PARSE_E;\n        if (length > ECC_MAXSIZE)\n            return BUFFER_E;\n        *inOutIdx += length;\n\n        /* Private Curve Header */\n        if (*inOutIdx >= inSz)\n            return ASN_PARSE_E;\n        tag = input[*inOutIdx];\n        *inOutIdx += 1;\n        if (tag != ECC_PREFIX_0)\n            return ASN_ECC_KEY_E;\n        if (GetLength(input, inOutIdx, &length, inSz) <= 0)\n            return ASN_PARSE_E;\n    }\n    /* Standard ECC public key */\n    else {\n        if (GetSequence(input, inOutIdx, &length, inSz) < 0)\n            return ASN_PARSE_E;\n\n        ret = SkipObjectId(input, inOutIdx, inSz);\n        if (ret != 0)\n            return ret;\n    }\n\n    if (*inOutIdx >= inSz) {\n        return BUFFER_E;\n    }\n\n    localIdx = *inOutIdx;\n    if (GetASNTag(input, &localIdx, &tag, inSz) == 0 &&\n            tag == (ASN_SEQUENCE | ASN_CONSTRUCTED)) {\n#ifdef WOLFSSL_CUSTOM_CURVES\n        ecc_set_type* curve;\n        int len;\n        char* point = NULL;\n\n        ret = 0;\n\n        curve = (ecc_set_type*)XMALLOC(sizeof(*curve), key->heap,\n                                                       DYNAMIC_TYPE_ECC_BUFFER);\n        if (curve == NULL)\n            ret = MEMORY_E;\n\n        if (ret == 0) {\n            static const char customName[] = \"Custom\";\n            XMEMSET(curve, 0, sizeof(*curve));\n        #ifndef WOLFSSL_ECC_CURVE_STATIC\n            curve->name = customName;\n        #else\n            XMEMCPY((void*)curve->name, customName, sizeof(customName));\n        #endif\n            curve->id = ECC_CURVE_CUSTOM;\n\n            if (GetSequence(input, inOutIdx, &length, inSz) < 0)\n                ret = ASN_PARSE_E;\n        }\n\n        if (ret == 0) {\n            GetInteger7Bit(input, inOutIdx, inSz);\n            if (GetSequence(input, inOutIdx, &length, inSz) < 0)\n                ret = ASN_PARSE_E;\n        }\n        if (ret == 0) {\n            char* p = NULL;\n            SkipObjectId(input, inOutIdx, inSz);\n            ret = ASNToHexString(input, inOutIdx, &p, inSz,\n                                            key->heap, DYNAMIC_TYPE_ECC_BUFFER);\n            if (ret == 0)\n                ret = EccKeyParamCopy((char**)&curve->prime, p);\n        }\n        if (ret == 0) {\n            curve->size = (int)XSTRLEN(curve->prime) / 2;\n\n            if (GetSequence(input, inOutIdx, &length, inSz) < 0)\n                ret = ASN_PARSE_E;\n        }\n        if (ret == 0) {\n            char* af = NULL;\n            ret = ASNToHexString(input, inOutIdx, &af, inSz,\n                                            key->heap, DYNAMIC_TYPE_ECC_BUFFER);\n            if (ret == 0)\n                ret = EccKeyParamCopy((char**)&curve->Af, af);\n        }\n        if (ret == 0) {\n            char* bf = NULL;\n            ret = ASNToHexString(input, inOutIdx, &bf, inSz,\n                                            key->heap, DYNAMIC_TYPE_ECC_BUFFER);\n            if (ret == 0)\n                ret = EccKeyParamCopy((char**)&curve->Bf, bf);\n        }\n        if (ret == 0) {\n            localIdx = *inOutIdx;\n            if (*inOutIdx < inSz && GetASNTag(input, &localIdx, &tag, inSz)\n                    == 0 && tag == ASN_BIT_STRING) {\n                len = 0;\n                ret = GetASNHeader(input, ASN_BIT_STRING, inOutIdx, &len, inSz);\n                *inOutIdx += len;\n            }\n        }\n        if (ret == 0) {\n            ret = ASNToHexString(input, inOutIdx, (char**)&point, inSz,\n                                            key->heap, DYNAMIC_TYPE_ECC_BUFFER);\n\n            /* sanity check that point buffer is not smaller than the expected\n             * size to hold ( 0 4 || Gx || Gy )\n             * where Gx and Gy are each the size of curve->size * 2 */\n            if (ret == 0 && (int)XSTRLEN(point) < (curve->size * 4) + 2) {\n                XFREE(point, key->heap, DYNAMIC_TYPE_ECC_BUFFER);\n                ret = BUFFER_E;\n            }\n        }\n        if (ret == 0) {\n        #ifndef WOLFSSL_ECC_CURVE_STATIC\n            curve->Gx = (const char*)XMALLOC(curve->size * 2 + 2, key->heap,\n                                                       DYNAMIC_TYPE_ECC_BUFFER);\n            curve->Gy = (const char*)XMALLOC(curve->size * 2 + 2, key->heap,\n                                                       DYNAMIC_TYPE_ECC_BUFFER);\n            if (curve->Gx == NULL || curve->Gy == NULL) {\n                XFREE(point, key->heap, DYNAMIC_TYPE_ECC_BUFFER);\n                ret = MEMORY_E;\n            }\n        #else\n            if (curve->size * 2 + 2 > MAX_ECC_STRING) {\n                WOLFSSL_MSG(\"curve size is too large to fit in buffer\");\n                ret = BUFFER_E;\n            }\n        #endif\n        }\n        if (ret == 0) {\n            char* o = NULL;\n\n            XMEMCPY((char*)curve->Gx, point + 2, curve->size * 2);\n            XMEMCPY((char*)curve->Gy, point + curve->size * 2 + 2,\n                                                               curve->size * 2);\n            ((char*)curve->Gx)[curve->size * 2] = '\\0';\n            ((char*)curve->Gy)[curve->size * 2] = '\\0';\n            XFREE(point, key->heap, DYNAMIC_TYPE_ECC_BUFFER);\n            ret = ASNToHexString(input, inOutIdx, &o, inSz,\n                                            key->heap, DYNAMIC_TYPE_ECC_BUFFER);\n            if (ret == 0)\n                ret = EccKeyParamCopy((char**)&curve->order, o);\n        }\n        if (ret == 0) {\n            curve->cofactor = GetInteger7Bit(input, inOutIdx, inSz);\n\n        #ifndef WOLFSSL_ECC_CURVE_STATIC\n            curve->oid = NULL;\n        #else\n            XMEMSET((void*)curve->oid, 0, sizeof(curve->oid));\n        #endif\n            curve->oidSz = 0;\n            curve->oidSum = 0;\n\n            if (wc_ecc_set_custom_curve(key, curve) < 0) {\n                ret = ASN_PARSE_E;\n            }\n        #ifdef WOLFSSL_CUSTOM_CURVES\n            key->deallocSet = 1;\n        #endif\n            curve = NULL;\n        }\n        if (curve != NULL)\n            wc_ecc_free_curve(curve, key->heap);\n\n        if (ret < 0)\n            return ret;\n#else\n        return ASN_PARSE_E;\n#endif /* WOLFSSL_CUSTOM_CURVES */\n    }\n    else {\n        /* ecc params information */\n        ret = GetObjectId(input, inOutIdx, &oidSum, oidIgnoreType, inSz);\n        if (ret != 0)\n            return ret;\n\n        /* get curve id */\n        if ((ret = CheckCurve(oidSum)) < 0)\n            return ECC_CURVE_OID_E;\n        else {\n            curve_id = ret;\n        }\n    }\n\n    if (isPrivFormat) {\n        /* Public Curve Header - skip */\n        if (*inOutIdx >= inSz)\n            return ASN_PARSE_E;\n        tag = input[*inOutIdx];\n        *inOutIdx += 1;\n        if (tag != ECC_PREFIX_1)\n            return ASN_ECC_KEY_E;\n        if (GetLength(input, inOutIdx, &length, inSz) <= 0)\n            return ASN_PARSE_E;\n    }\n\n    /* key header */\n    ret = CheckBitString(input, inOutIdx, &length, inSz, 1, NULL);\n    if (ret != 0)\n        return ret;\n\n    /* This is the raw point data compressed or uncompressed. */\n    if (wc_ecc_import_x963_ex(input + *inOutIdx, length, key,\n                                                            curve_id) != 0) {\n        return ASN_ECC_KEY_E;\n    }\n\n    *inOutIdx += length;\n\n    return 0;\n}\n\n#if defined(HAVE_ECC_KEY_EXPORT) && !defined(NO_ASN_CRYPT)\n/* build DER formatted ECC key, include optional public key if requested,\n * return length on success, negative on error */\nstatic int wc_BuildEccKeyDer(ecc_key* key, byte* output, word32 *inLen,\n                             int pubIn)\n{\n    byte   curve[MAX_ALGO_SZ+2];\n    byte   ver[MAX_VERSION_SZ];\n    byte   seq[MAX_SEQ_SZ];\n    int    ret, totalSz, curveSz, verSz;\n    int    privHdrSz  = ASN_ECC_HEADER_SZ;\n    int    pubHdrSz   = ASN_ECC_CONTEXT_SZ + ASN_ECC_HEADER_SZ;\n#ifdef WOLFSSL_NO_MALLOC\n    byte   prv[MAX_ECC_BYTES + ASN_ECC_HEADER_SZ + MAX_SEQ_SZ];\n    byte   pub[(MAX_ECC_BYTES * 2) + 1 + ASN_ECC_CONTEXT_SZ + \n                              ASN_ECC_HEADER_SZ + MAX_SEQ_SZ];\n#else\n    byte   *prv = NULL, *pub = NULL;\n#endif\n\n    word32 idx = 0, prvidx = 0, pubidx = 0, curveidx = 0;\n    word32 seqSz, privSz, pubSz = ECC_BUFSIZE;\n\n    if (key == NULL || (output == NULL && inLen == NULL))\n        return BAD_FUNC_ARG;\n\n    /* curve */\n    curve[curveidx++] = ECC_PREFIX_0;\n    curveidx++ /* to put the size after computation */;\n    curveSz = SetCurve(key, curve+curveidx);\n    if (curveSz < 0)\n        return curveSz;\n    /* set computed size */\n    curve[1] = (byte)curveSz;\n    curveidx += curveSz;\n\n    /* private */\n    privSz = key->dp->size;\n\n#ifdef WOLFSSL_QNX_CAAM\n    /* check if is a black key, and add MAC size if so */\n    if (key->blackKey > 0) {\n        privSz = privSz + WC_CAAM_MAC_SZ;\n    }\n#endif\n\n#ifndef WOLFSSL_NO_MALLOC\n    prv = (byte*)XMALLOC(privSz + privHdrSz + MAX_SEQ_SZ,\n                         key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n    if (prv == NULL) {\n        return MEMORY_E;\n    }\n#else\n    if (sizeof(prv) < privSz + privHdrSz + MAX_SEQ_SZ) {\n        return BUFFER_E;\n    }\n#endif\n    if (privSz < ASN_LONG_LENGTH) {\n        prvidx += SetOctetString8Bit(privSz, &prv[prvidx]);\n    }\n    else {\n        prvidx += SetOctetString(privSz, &prv[prvidx]);\n    }\n    ret = wc_ecc_export_private_only(key, prv + prvidx, &privSz);\n    if (ret < 0) {\n    #ifndef WOLFSSL_NO_MALLOC\n        XFREE(prv, key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n    #endif\n        return ret;\n    }\n    prvidx += privSz;\n\n    /* pubIn */\n    if (pubIn) {\n        ret = wc_ecc_export_x963(key, NULL, &pubSz);\n        if (ret != LENGTH_ONLY_E) {\n        #ifndef WOLFSSL_NO_MALLOC\n            XFREE(prv, key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n        #endif\n            return ret;\n        }\n\n    #ifndef WOLFSSL_NO_MALLOC\n        pub = (byte*)XMALLOC(pubSz + pubHdrSz + MAX_SEQ_SZ,\n                             key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n        if (pub == NULL) {\n            XFREE(prv, key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n            return MEMORY_E;\n        }\n    #else\n        if (sizeof(pub) < pubSz + pubHdrSz + MAX_SEQ_SZ) {\n            return BUFFER_E;\n        }\n    #endif\n\n        pub[pubidx++] = ECC_PREFIX_1;\n        if (pubSz > 128) /* leading zero + extra size byte */\n            pubidx += SetLength(pubSz + ASN_ECC_CONTEXT_SZ + 2, pub+pubidx);\n        else /* leading zero */\n            pubidx += SetLength(pubSz + ASN_ECC_CONTEXT_SZ + 1, pub+pubidx);\n\n        /* SetBitString adds leading zero */\n        pubidx += SetBitString(pubSz, 0, pub + pubidx);\n        ret = wc_ecc_export_x963(key, pub + pubidx, &pubSz);\n        if (ret != 0) {\n        #ifndef WOLFSSL_NO_MALLOC\n            XFREE(prv, key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n            XFREE(pub, key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n        #endif\n            return ret;\n        }\n        pubidx += pubSz;\n    }\n\n    /* make headers */\n    verSz = SetMyVersion(1, ver, FALSE);\n    seqSz = SetSequence(verSz + prvidx + pubidx + curveidx, seq);\n\n    totalSz = prvidx + pubidx + curveidx + verSz + seqSz;\n    if (output == NULL) {\n        *inLen = totalSz;\n    #ifndef WOLFSSL_NO_MALLOC\n        XFREE(prv, key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n        if (pub) {\n            XFREE(pub, key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n        }\n    #endif\n        return LENGTH_ONLY_E;\n    }\n    if (inLen != NULL && totalSz > (int)*inLen) {\n        #ifndef WOLFSSL_NO_MALLOC\n        XFREE(prv, key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n        if (pubIn) {\n            XFREE(pub, key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n        }\n        #endif\n        return BAD_FUNC_ARG;\n    }\n\n    /* write out */\n    /* seq */\n    XMEMCPY(output + idx, seq, seqSz);\n    idx = seqSz;\n\n    /* ver */\n    XMEMCPY(output + idx, ver, verSz);\n    idx += verSz;\n\n    /* private */\n    XMEMCPY(output + idx, prv, prvidx);\n    idx += prvidx;\n#ifndef WOLFSSL_NO_MALLOC\n    XFREE(prv, key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n#endif\n\n    /* curve */\n    XMEMCPY(output + idx, curve, curveidx);\n    idx += curveidx;\n\n    /* pubIn */\n    if (pubIn) {\n        XMEMCPY(output + idx, pub, pubidx);\n        /* idx += pubidx;  not used after write, if more data remove comment */\n    #ifndef WOLFSSL_NO_MALLOC\n        XFREE(pub, key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n    #endif\n    }\n\n    return totalSz;\n}\n\n/* Write a Private ecc key, including public to DER format,\n * length on success else < 0 */\nint wc_EccKeyToDer(ecc_key* key, byte* output, word32 inLen)\n{\n    return wc_BuildEccKeyDer(key, output, &inLen, 1);\n}\n\n/* Write only private ecc key to DER format,\n * length on success else < 0 */\nint wc_EccKeyDerSize(ecc_key* key, int pub)\n{\n    word32 sz = 0;\n    int ret;\n\n    ret = wc_BuildEccKeyDer(key, NULL, &sz, pub);\n\n    if (ret != LENGTH_ONLY_E) {\n        return ret;\n    }\n    return sz;\n }\n\n/* Write only private ecc key to DER format,\n * length on success else < 0 */\nint wc_EccPrivateKeyToDer(ecc_key* key, byte* output, word32 inLen)\n{\n    return wc_BuildEccKeyDer(key, output, &inLen, 0);\n}\n\n\n\n#ifdef HAVE_PKCS8\n/* Write only private ecc key or both private and public parts to unencrypted\n * PKCS#8 format.\n *\n * If output is NULL, places required PKCS#8 buffer size in outLen and\n * returns LENGTH_ONLY_E.\n *\n * return length on success else < 0 */\nstatic int eccToPKCS8(ecc_key* key, byte* output, word32* outLen,\n        int includePublic)\n{\n    int ret, tmpDerSz;\n    int algoID = 0;\n    word32 oidSz = 0;\n    word32 pkcs8Sz = 0;\n    const byte* curveOID = NULL;\n#ifdef WOLFSSL_NO_MALLOC\n    byte  tmpDer[ECC_BUFSIZE];\n#else\n    byte* tmpDer = NULL;\n#endif\n    word32 sz = ECC_BUFSIZE;\n\n    if (key == NULL || key->dp == NULL || outLen == NULL)\n        return BAD_FUNC_ARG;\n\n    /* set algoID, get curve OID */\n    algoID = ECDSAk;\n    ret = wc_ecc_get_oid(key->dp->oidSum, &curveOID, &oidSz);\n    if (ret < 0)\n        return ret;\n\n#ifndef WOLFSSL_NO_MALLOC\n    /* temp buffer for plain DER key */\n    tmpDer = (byte*)XMALLOC(ECC_BUFSIZE, key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n    if (tmpDer == NULL)\n        return MEMORY_E;\n#endif\n    XMEMSET(tmpDer, 0, ECC_BUFSIZE);\n\n    tmpDerSz = wc_BuildEccKeyDer(key, tmpDer, &sz, includePublic);\n    if (tmpDerSz < 0) {\n    #ifndef WOLFSSL_NO_MALLOC\n        XFREE(tmpDer, key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n    #endif\n        return tmpDerSz;\n    }\n\n    /* get pkcs8 expected output size */\n    ret = wc_CreatePKCS8Key(NULL, &pkcs8Sz, tmpDer, tmpDerSz, algoID,\n                            curveOID, oidSz);\n    if (ret != LENGTH_ONLY_E) {\n    #ifndef WOLFSSL_NO_MALLOC\n        XFREE(tmpDer, key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n    #endif\n        return ret;\n    }\n\n    if (output == NULL) {\n    #ifndef WOLFSSL_NO_MALLOC\n        XFREE(tmpDer, key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n    #endif\n        *outLen = pkcs8Sz;\n        return LENGTH_ONLY_E;\n\n    }\n    else if (*outLen < pkcs8Sz) {\n    #ifndef WOLFSSL_NO_MALLOC\n        XFREE(tmpDer, key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n    #endif\n        WOLFSSL_MSG(\"Input buffer too small for ECC PKCS#8 key\");\n        return BUFFER_E;\n    }\n\n    ret = wc_CreatePKCS8Key(output, &pkcs8Sz, tmpDer, tmpDerSz,\n                            algoID, curveOID, oidSz);\n    if (ret < 0) {\n    #ifndef WOLFSSL_NO_MALLOC\n        XFREE(tmpDer, key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n    #endif\n        return ret;\n    }\n\n#ifndef WOLFSSL_NO_MALLOC\n    XFREE(tmpDer, key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n#endif\n\n    *outLen = ret;\n    return ret;\n}\n\n/* Write only private ecc key to unencrypted PKCS#8 format.\n *\n * return length on success else < 0 */\nint wc_EccPrivateKeyToPKCS8(ecc_key* key, byte* output, word32* outLen)\n{\n    return eccToPKCS8(key, output, outLen, 0);\n}\n\n/* Write both private and public ecc keys to unencrypted PKCS#8 format.\n *\n * return length on success else < 0 */\nint wc_EccKeyToPKCS8(ecc_key* key, byte* output,\n                     word32* outLen)\n{\n    return eccToPKCS8(key, output, outLen, 1);\n}\n#endif /* HAVE_PKCS8 */\n#endif /* HAVE_ECC_KEY_EXPORT && !NO_ASN_CRYPT */\n#endif /* HAVE_ECC */\n\n\n#ifdef HAVE_ED25519\n\nint wc_Ed25519PrivateKeyDecode(const byte* input, word32* inOutIdx,\n                               ed25519_key* key, word32 inSz)\n{\n    word32      oid;\n    int         ret, version, length, endKeyIdx, privSz, pubSz;\n    const byte* priv;\n    const byte* pub;\n\n    if (input == NULL || inOutIdx == NULL || key == NULL || inSz == 0)\n        return BAD_FUNC_ARG;\n\n    if (GetSequence(input, inOutIdx, &length, inSz) >= 0) {\n        endKeyIdx = *inOutIdx + length;\n\n        if (GetMyVersion(input, inOutIdx, &version, inSz) < 0)\n            return ASN_PARSE_E;\n        if (version != 0) {\n            WOLFSSL_MSG(\"Unrecognized version of ED25519 private key\");\n            return ASN_PARSE_E;\n        }\n\n        if (GetAlgoId(input, inOutIdx, &oid, oidKeyType, inSz) < 0)\n            return ASN_PARSE_E;\n        if (oid != ED25519k)\n            return ASN_PARSE_E;\n\n        if (GetOctetString(input, inOutIdx, &length, inSz) < 0)\n            return ASN_PARSE_E;\n\n        if (GetOctetString(input, inOutIdx, &privSz, inSz) < 0)\n            return ASN_PARSE_E;\n\n        priv = input + *inOutIdx;\n        *inOutIdx += privSz;\n    }\n    else {\n        if (GetOctetString(input, inOutIdx, &privSz, inSz) < 0)\n            return ASN_PARSE_E;\n\n        if (privSz != 32)\n            return ASN_PARSE_E;\n\n        priv = input + *inOutIdx;\n        *inOutIdx += privSz;\n        endKeyIdx = *inOutIdx;\n    }\n\n    if (endKeyIdx == (int)*inOutIdx) {\n        ret = wc_ed25519_import_private_only(priv, privSz, key);\n    }\n    else {\n        if (GetASNHeader(input, ASN_CONTEXT_SPECIFIC | ASN_CONSTRUCTED | 1,\n                         inOutIdx, &length, inSz) < 0) {\n            return ASN_PARSE_E;\n        }\n        if (GetOctetString(input, inOutIdx, &pubSz, inSz) < 0)\n            return ASN_PARSE_E;\n        pub = input + *inOutIdx;\n        *inOutIdx += pubSz;\n\n        ret = wc_ed25519_import_private_key(priv, privSz, pub, pubSz, key);\n    }\n    if (ret == 0 && endKeyIdx != (int)*inOutIdx)\n        return ASN_PARSE_E;\n\n    return ret;\n}\n\n\nint wc_Ed25519PublicKeyDecode(const byte* input, word32* inOutIdx,\n                              ed25519_key* key, word32 inSz)\n{\n    int    length;\n    int    ret;\n\n    if (input == NULL || inOutIdx == NULL || key == NULL || inSz == 0)\n        return BAD_FUNC_ARG;\n\n    if (GetSequence(input, inOutIdx, &length, inSz) < 0)\n        return ASN_PARSE_E;\n\n    if (GetSequence(input, inOutIdx, &length, inSz) < 0)\n        return ASN_PARSE_E;\n\n    ret = SkipObjectId(input, inOutIdx, inSz);\n    if (ret != 0)\n        return ret;\n\n    /* key header */\n    ret = CheckBitString(input, inOutIdx, NULL, inSz, 1, NULL);\n    if (ret != 0)\n        return ret;\n\n    /* This is the raw point data compressed or uncompressed. */\n    if (wc_ed25519_import_public(input + *inOutIdx, inSz - *inOutIdx, key) != 0)\n        return ASN_ECC_KEY_E;\n\n    return 0;\n}\n\n\n#ifdef WOLFSSL_KEY_GEN\n\n/* build DER formatted ED25519 key,\n * return length on success, negative on error */\nstatic int wc_BuildEd25519KeyDer(ed25519_key* key, byte* output, word32 inLen,\n                                 int pubOut)\n{\n    byte   algoArray[MAX_ALGO_SZ];\n    byte   ver[MAX_VERSION_SZ];\n    byte   seq[MAX_SEQ_SZ];\n    int    ret;\n    word32 idx = 0, seqSz, verSz, algoSz, privSz, pubSz = 0;\n\n    if (key == NULL || output == NULL || inLen == 0)\n        return BAD_FUNC_ARG;\n\n    if (pubOut)\n        pubSz = 2 + 2 + ED25519_PUB_KEY_SIZE;\n    privSz = 2 + 2 + ED25519_KEY_SIZE;\n    algoSz = SetAlgoID(ED25519k, algoArray, oidKeyType, 0);\n    verSz  = SetMyVersion(0, ver, FALSE);\n    seqSz  = SetSequence(verSz + algoSz + privSz + pubSz, seq);\n\n    if (seqSz + verSz + algoSz + privSz + pubSz > inLen)\n        return BAD_FUNC_ARG;\n\n    /* write out */\n    /* seq */\n    XMEMCPY(output + idx, seq, seqSz);\n    idx = seqSz;\n    /* ver */\n    XMEMCPY(output + idx, ver, verSz);\n    idx += verSz;\n    /* algo */\n    XMEMCPY(output + idx, algoArray, algoSz);\n    idx += algoSz;\n    /* privKey */\n    idx += SetOctetString(2 + ED25519_KEY_SIZE, output + idx);\n    idx += SetOctetString(ED25519_KEY_SIZE, output + idx);\n    ret = wc_ed25519_export_private_only(key, output + idx, &privSz);\n    if (ret != 0)\n        return ret;\n    idx += privSz;\n    /* pubKey */\n    if (pubOut) {\n        idx += SetExplicit(1, 2 + ED25519_PUB_KEY_SIZE, output + idx);\n        idx += SetOctetString(ED25519_KEY_SIZE, output + idx);\n        ret = wc_ed25519_export_public(key, output + idx, &pubSz);\n        if (ret != 0)\n            return ret;\n        idx += pubSz;\n    }\n\n    return idx;\n}\n\n/* Write a Private ecc key, including public to DER format,\n * length on success else < 0 */\nint wc_Ed25519KeyToDer(ed25519_key* key, byte* output, word32 inLen)\n{\n    return wc_BuildEd25519KeyDer(key, output, inLen, 1);\n}\n\n\n\n/* Write only private ecc key to DER format,\n * length on success else < 0 */\nint wc_Ed25519PrivateKeyToDer(ed25519_key* key, byte* output, word32 inLen)\n{\n    return wc_BuildEd25519KeyDer(key, output, inLen, 0);\n}\n\n#endif /* WOLFSSL_KEY_GEN */\n\n#endif /* HAVE_ED25519 */\n\n#ifdef HAVE_ED448\n\nint wc_Ed448PrivateKeyDecode(const byte* input, word32* inOutIdx,\n                             ed448_key* key, word32 inSz)\n{\n    word32      oid;\n    int         ret, version, length, endKeyIdx, privSz, pubSz;\n    const byte* priv;\n    const byte* pub;\n\n    if (input == NULL || inOutIdx == NULL || key == NULL || inSz == 0)\n        return BAD_FUNC_ARG;\n\n    if (GetSequence(input, inOutIdx, &length, inSz) >= 0) {\n        endKeyIdx = *inOutIdx + length;\n\n        if (GetMyVersion(input, inOutIdx, &version, inSz) < 0)\n            return ASN_PARSE_E;\n        if (version != 0) {\n            WOLFSSL_MSG(\"Unrecognized version of ED448 private key\");\n            return ASN_PARSE_E;\n        }\n\n        if (GetAlgoId(input, inOutIdx, &oid, oidKeyType, inSz) < 0)\n            return ASN_PARSE_E;\n        if (oid != ED448k)\n            return ASN_PARSE_E;\n\n        if (GetOctetString(input, inOutIdx, &length, inSz) < 0)\n            return ASN_PARSE_E;\n\n        if (GetOctetString(input, inOutIdx, &privSz, inSz) < 0)\n            return ASN_PARSE_E;\n\n        priv = input + *inOutIdx;\n        *inOutIdx += privSz;\n    }\n    else {\n        if (GetOctetString(input, inOutIdx, &privSz, inSz) < 0)\n            return ASN_PARSE_E;\n\n        if (privSz != 57)\n            return ASN_PARSE_E;\n\n        priv = input + *inOutIdx;\n        *inOutIdx += privSz;\n        endKeyIdx = *inOutIdx;\n    }\n\n    if (endKeyIdx == (int)*inOutIdx) {\n        ret = wc_ed448_import_private_only(priv, privSz, key);\n    }\n    else {\n        if (GetASNHeader(input, ASN_CONTEXT_SPECIFIC | ASN_CONSTRUCTED | 1,\n                         inOutIdx, &length, inSz) < 0) {\n            return ASN_PARSE_E;\n        }\n        if (GetOctetString(input, inOutIdx, &pubSz, inSz) < 0)\n            return ASN_PARSE_E;\n        pub = input + *inOutIdx;\n        *inOutIdx += pubSz;\n\n        ret = wc_ed448_import_private_key(priv, privSz, pub, pubSz, key);\n    }\n    if (ret == 0 && endKeyIdx != (int)*inOutIdx)\n        return ASN_PARSE_E;\n\n    return ret;\n}\n\n\nint wc_Ed448PublicKeyDecode(const byte* input, word32* inOutIdx,\n                            ed448_key* key, word32 inSz)\n{\n    int    length;\n    int    ret;\n\n    if (input == NULL || inOutIdx == NULL || key == NULL || inSz == 0)\n        return BAD_FUNC_ARG;\n\n    if (GetSequence(input, inOutIdx, &length, inSz) < 0)\n        return ASN_PARSE_E;\n\n    if (GetSequence(input, inOutIdx, &length, inSz) < 0)\n        return ASN_PARSE_E;\n\n    ret = SkipObjectId(input, inOutIdx, inSz);\n    if (ret != 0)\n        return ret;\n\n    /* key header */\n    ret = CheckBitString(input, inOutIdx, NULL, inSz, 1, NULL);\n    if (ret != 0)\n        return ret;\n\n    /* This is the raw point data compressed or uncompressed. */\n    if (wc_ed448_import_public(input + *inOutIdx, inSz - *inOutIdx, key) != 0)\n        return ASN_ECC_KEY_E;\n\n    return 0;\n}\n\n\n#ifdef WOLFSSL_KEY_GEN\n\n/* build DER formatted ED448 key,\n * return length on success, negative on error */\nstatic int wc_BuildEd448KeyDer(ed448_key* key, byte* output, word32 inLen,\n                               int pubOut)\n{\n    byte   algoArray[MAX_ALGO_SZ];\n    byte   ver[MAX_VERSION_SZ];\n    byte   seq[MAX_SEQ_SZ];\n    int    ret;\n    word32 idx = 0, seqSz, verSz, algoSz, privSz, pubSz = 0;\n\n    if (key == NULL || output == NULL || inLen == 0)\n        return BAD_FUNC_ARG;\n\n    if (pubOut) {\n        pubSz = 2 + 2 + ED448_PUB_KEY_SIZE;\n    }\n    privSz = 2 + 2 + ED448_KEY_SIZE;\n    algoSz = SetAlgoID(ED448k, algoArray, oidKeyType, 0);\n    verSz  = SetMyVersion(0, ver, FALSE);\n    seqSz  = SetSequence(verSz + algoSz + privSz + pubSz, seq);\n\n    if (seqSz + verSz + algoSz + privSz + pubSz > inLen)\n        return BAD_FUNC_ARG;\n\n    /* write out */\n    /* seq */\n    XMEMCPY(output + idx, seq, seqSz);\n    idx = seqSz;\n    /* ver */\n    XMEMCPY(output + idx, ver, verSz);\n    idx += verSz;\n    /* algo */\n    XMEMCPY(output + idx, algoArray, algoSz);\n    idx += algoSz;\n    /* privKey */\n    idx += SetOctetString(2 + ED448_KEY_SIZE, output + idx);\n    idx += SetOctetString(ED448_KEY_SIZE, output + idx);\n    ret = wc_ed448_export_private_only(key, output + idx, &privSz);\n    if (ret != 0)\n        return ret;\n    idx += privSz;\n    /* pubKey */\n    if (pubOut) {\n        idx += SetExplicit(1, 2 + ED448_PUB_KEY_SIZE, output + idx);\n        idx += SetOctetString(ED448_KEY_SIZE, output + idx);\n        ret = wc_ed448_export_public(key, output + idx, &pubSz);\n        if (ret != 0)\n            return ret;\n        idx += pubSz;\n    }\n\n    return idx;\n}\n\n/* Write a Private ecc key, including public to DER format,\n * length on success else < 0 */\nint wc_Ed448KeyToDer(ed448_key* key, byte* output, word32 inLen)\n{\n    return wc_BuildEd448KeyDer(key, output, inLen, 1);\n}\n\n\n\n/* Write only private ecc key to DER format,\n * length on success else < 0 */\nint wc_Ed448PrivateKeyToDer(ed448_key* key, byte* output, word32 inLen)\n{\n    return wc_BuildEd448KeyDer(key, output, inLen, 0);\n}\n\n#endif /* WOLFSSL_KEY_GEN */\n\n#endif /* HAVE_ED448 */\n\n#if defined(HAVE_OCSP) || defined(HAVE_CRL)\n\n/* Get raw Date only, no processing, 0 on success */\nstatic int GetBasicDate(const byte* source, word32* idx, byte* date,\n                        byte* format, int maxIdx)\n{\n    int    ret, length;\n    const byte *datePtr = NULL;\n\n    WOLFSSL_ENTER(\"GetBasicDate\");\n\n    ret = GetDateInfo(source, idx, &datePtr, format, &length, maxIdx);\n    if (ret < 0)\n        return ret;\n\n    XMEMCPY(date, datePtr, length);\n\n    return 0;\n}\n\n#endif /* HAVE_OCSP || HAVE_CRL */\n\n\n#ifdef HAVE_OCSP\n\nstatic int GetEnumerated(const byte* input, word32* inOutIdx, int *value,\n        int sz)\n{\n    word32 idx = *inOutIdx;\n    word32 len;\n    byte   tag;\n\n    WOLFSSL_ENTER(\"GetEnumerated\");\n\n    *value = 0;\n\n    if (GetASNTag(input, &idx, &tag, sz) < 0)\n        return ASN_PARSE_E;\n\n    if (tag != ASN_ENUMERATED)\n        return ASN_PARSE_E;\n\n    if ((int)idx >= sz)\n        return BUFFER_E;\n\n    len = input[idx++];\n    if (len > 4 || (int)(len + idx) > sz)\n        return ASN_PARSE_E;\n\n    while (len--) {\n        *value  = *value << 8 | input[idx++];\n    }\n\n    *inOutIdx = idx;\n\n    return *value;\n}\n\n\nstatic int DecodeSingleResponse(byte* source, word32* ioIndex, word32 size,\n                                int wrapperSz, OcspEntry* single)\n{\n    word32 idx = *ioIndex, prevIndex, oid, localIdx, certIdIdx;\n    int length;\n    int ret;\n    byte tag;\n\n    WOLFSSL_ENTER(\"DecodeSingleResponse\");\n\n    prevIndex = idx;\n\n    /* Wrapper around the Single Response */\n    if (GetSequence(source, &idx, &length, size) < 0)\n        return ASN_PARSE_E;\n\n    /* Wrapper around the CertID */\n    certIdIdx = idx;\n    if (GetSequence(source, &idx, &length, size) < 0)\n        return ASN_PARSE_E;\n    single->rawCertId = source + certIdIdx;\n    /* Hash algorithm */\n    ret = GetAlgoId(source, &idx, &oid, oidIgnoreType, size);\n    if (ret < 0)\n        return ret;\n    single->hashAlgoOID = oid;\n    /* Save reference to the hash of CN */\n    ret = GetOctetString(source, &idx, &length, size);\n    if (ret < 0)\n        return ret;\n    if (length > (int)sizeof(single->issuerHash))\n        return BUFFER_E;\n    XMEMCPY(single->issuerHash, source + idx, length);\n    idx += length;\n    /* Save reference to the hash of the issuer public key */\n    ret = GetOctetString(source, &idx, &length, size);\n    if (ret < 0)\n        return ret;\n    if (length > (int)sizeof(single->issuerKeyHash))\n        return BUFFER_E;\n    XMEMCPY(single->issuerKeyHash, source + idx, length);\n    idx += length;\n\n    /* Get serial number */\n    if (GetSerialNumber(source, &idx, single->status->serial, &single->status->serialSz, size) < 0)\n        return ASN_PARSE_E;\n    single->rawCertIdSize = idx - certIdIdx;\n\n    if (idx >= size)\n        return BUFFER_E;\n\n    /* CertStatus */\n    switch (source[idx++])\n    {\n        case (ASN_CONTEXT_SPECIFIC | CERT_GOOD):\n            single->status->status = CERT_GOOD;\n            idx++;\n            break;\n        case (ASN_CONTEXT_SPECIFIC | ASN_CONSTRUCTED | CERT_REVOKED):\n            single->status->status = CERT_REVOKED;\n            if (GetLength(source, &idx, &length, size) < 0)\n                return ASN_PARSE_E;\n            idx += length;\n            break;\n        case (ASN_CONTEXT_SPECIFIC | CERT_UNKNOWN):\n            single->status->status = CERT_UNKNOWN;\n            idx++;\n            break;\n        default:\n            return ASN_PARSE_E;\n    }\n\n#if defined(OPENSSL_ALL) || defined(WOLFSSL_NGINX) || defined(WOLFSSL_HAPROXY)\n    single->status->thisDateAsn = source + idx;\n    localIdx = 0;\n    if (GetDateInfo(single->status->thisDateAsn, &localIdx, NULL,\n                    (byte*)&single->status->thisDateParsed.type,\n                    &single->status->thisDateParsed.length, size) < 0)\n        return ASN_PARSE_E;\n    XMEMCPY(single->status->thisDateParsed.data,\n            single->status->thisDateAsn + localIdx - single->status->thisDateParsed.length,\n            single->status->thisDateParsed.length);\n#endif\n    if (GetBasicDate(source, &idx, single->status->thisDate,\n                                                &single->status->thisDateFormat, size) < 0)\n        return ASN_PARSE_E;\n\n#ifndef NO_ASN_TIME\n#ifndef WOLFSSL_NO_OCSP_DATE_CHECK\n    if (!XVALIDATE_DATE(single->status->thisDate, single->status->thisDateFormat, BEFORE))\n        return ASN_BEFORE_DATE_E;\n#endif\n#endif\n\n    /* The following items are optional. Only check for them if there is more\n     * unprocessed data in the singleResponse wrapper. */\n    localIdx = idx;\n    if (((int)(idx - prevIndex) < wrapperSz) &&\n        GetASNTag(source, &localIdx, &tag, size) == 0 &&\n        tag == (ASN_CONSTRUCTED | ASN_CONTEXT_SPECIFIC | 0))\n    {\n        idx++;\n        if (GetLength(source, &idx, &length, size) < 0)\n            return ASN_PARSE_E;\n#if defined(OPENSSL_ALL) || defined(WOLFSSL_NGINX) || defined(WOLFSSL_HAPROXY)\n        single->status->nextDateAsn = source + idx;\n        localIdx = 0;\n        if (GetDateInfo(single->status->nextDateAsn, &localIdx, NULL,\n                        (byte*)&single->status->nextDateParsed.type,\n                        &single->status->nextDateParsed.length, size) < 0)\n            return ASN_PARSE_E;\n        XMEMCPY(single->status->nextDateParsed.data,\n                single->status->nextDateAsn + localIdx - single->status->nextDateParsed.length,\n                single->status->nextDateParsed.length);\n#endif\n        if (GetBasicDate(source, &idx, single->status->nextDate,\n                                                &single->status->nextDateFormat, size) < 0)\n            return ASN_PARSE_E;\n\n#ifndef NO_ASN_TIME\n#ifndef WOLFSSL_NO_OCSP_DATE_CHECK\n        if (!XVALIDATE_DATE(single->status->nextDate, single->status->nextDateFormat, AFTER))\n            return ASN_AFTER_DATE_E;\n#endif\n#endif\n    }\n\n    /* Skip the optional extensions in singleResponse. */\n    localIdx = idx;\n    if (((int)(idx - prevIndex) < wrapperSz) &&\n        GetASNTag(source, &localIdx, &tag, size) == 0 &&\n        tag == (ASN_CONSTRUCTED | ASN_CONTEXT_SPECIFIC | 1))\n    {\n        idx++;\n        if (GetLength(source, &idx, &length, size) < 0)\n            return ASN_PARSE_E;\n        idx += length;\n    }\n\n    *ioIndex = idx;\n\n    return 0;\n}\n\nstatic int DecodeOcspRespExtensions(byte* source,\n                            word32* ioIndex, OcspResponse* resp, word32 sz)\n{\n    word32 idx = *ioIndex;\n    int length;\n    int ext_bound; /* boundary index for the sequence of extensions */\n    word32 oid;\n    int ret;\n    byte tag;\n\n    WOLFSSL_ENTER(\"DecodeOcspRespExtensions\");\n\n    if ((idx + 1) > sz)\n        return BUFFER_E;\n\n    if (GetASNTag(source, &idx, &tag, sz) < 0)\n        return ASN_PARSE_E;\n\n    if (tag != (ASN_CONSTRUCTED | ASN_CONTEXT_SPECIFIC | 1))\n        return ASN_PARSE_E;\n\n    if (GetLength(source, &idx, &length, sz) < 0)\n        return ASN_PARSE_E;\n\n    if (GetSequence(source, &idx, &length, sz) < 0)\n        return ASN_PARSE_E;\n\n    ext_bound = idx + length;\n\n    while (idx < (word32)ext_bound) {\n        word32 localIdx;\n\n        if (GetSequence(source, &idx, &length, sz) < 0) {\n            WOLFSSL_MSG(\"\\tfail: should be a SEQUENCE\");\n            return ASN_PARSE_E;\n        }\n\n        oid = 0;\n        if (GetObjectId(source, &idx, &oid, oidOcspType, sz) < 0) {\n            WOLFSSL_MSG(\"\\tfail: OBJECT ID\");\n            return ASN_PARSE_E;\n        }\n\n        /* check for critical flag */\n        if ((idx + 1) > (word32)sz) {\n            WOLFSSL_MSG(\"\\tfail: malformed buffer\");\n            return BUFFER_E;\n        }\n\n        localIdx = idx;\n        if (GetASNTag(source, &localIdx, &tag, sz) == 0 && tag == ASN_BOOLEAN) {\n            WOLFSSL_MSG(\"\\tfound optional critical flag, moving past\");\n            ret = GetBoolean(source, &idx, sz);\n            if (ret < 0)\n                return ret;\n        }\n\n        ret = GetOctetString(source, &idx, &length, sz);\n        if (ret < 0)\n            return ret;\n\n        if (oid == OCSP_NONCE_OID) {\n            /* get data inside extra OCTET_STRING */\n            ret = GetOctetString(source, &idx, &length, sz);\n            if (ret < 0)\n                return ret;\n\n            resp->nonce = source + idx;\n            resp->nonceSz = length;\n        }\n\n        idx += length;\n    }\n\n    *ioIndex = idx;\n    return 0;\n}\n\n\nstatic int DecodeResponseData(byte* source,\n                            word32* ioIndex, OcspResponse* resp, word32 size)\n{\n    word32 idx = *ioIndex, prev_idx, localIdx;\n    int length;\n    int version;\n    int ret;\n    byte tag;\n    int wrapperSz;\n    OcspEntry* single;\n\n    WOLFSSL_ENTER(\"DecodeResponseData\");\n\n    resp->response = source + idx;\n    prev_idx = idx;\n    if (GetSequence(source, &idx, &length, size) < 0)\n        return ASN_PARSE_E;\n    resp->responseSz = length + idx - prev_idx;\n\n    /* Get version. It is an EXPLICIT[0] DEFAULT(0) value. If this\n     * item isn't an EXPLICIT[0], then set version to zero and move\n     * onto the next item.\n     */\n    localIdx = idx;\n    if (GetASNTag(source, &localIdx, &tag, size) == 0 &&\n            tag == (ASN_CONTEXT_SPECIFIC | ASN_CONSTRUCTED))\n    {\n        idx += 2; /* Eat the value and length */\n        if (GetMyVersion(source, &idx, &version, size) < 0)\n            return ASN_PARSE_E;\n    } else\n        version = 0;\n\n    localIdx = idx;\n    if (GetASNTag(source, &localIdx, &tag, size) == 0 &&\n        ( tag == (ASN_CONTEXT_SPECIFIC | ASN_CONSTRUCTED | 1) ||\n          tag == (ASN_CONTEXT_SPECIFIC | ASN_CONSTRUCTED | 2) ))\n    {\n        idx++; /* advance past ASN tag */\n        if (GetLength(source, &idx, &length, size) < 0)\n            return ASN_PARSE_E;\n        idx += length;\n    }\n    else\n        return ASN_PARSE_E;\n\n    /* save pointer to the producedAt time */\n    if (GetBasicDate(source, &idx, resp->producedDate,\n                                        &resp->producedDateFormat, size) < 0)\n        return ASN_PARSE_E;\n\n    /* Outer wrapper of the SEQUENCE OF Single Responses. */\n    if (GetSequence(source, &idx, &wrapperSz, size) < 0)\n        return ASN_PARSE_E;\n\n    localIdx = idx;\n    single = resp->single;\n\n    while (idx - localIdx < (word32)wrapperSz) {\n        ret = DecodeSingleResponse(source, &idx, size, wrapperSz, single);\n        if (ret < 0)\n            return ret; /* ASN_PARSE_E, ASN_BEFORE_DATE_E, ASN_AFTER_DATE_E */\n        if (idx - localIdx < (word32)wrapperSz) {\n            single->next = (OcspEntry*)XMALLOC(sizeof(OcspEntry), resp->heap, \n                DYNAMIC_TYPE_OCSP_ENTRY);\n            if (single->next == NULL) {\n                return MEMORY_E;\n            }\n            XMEMSET(single->next, 0, sizeof(OcspEntry));\n\n            single->next->status = (CertStatus*)XMALLOC(sizeof(CertStatus),\n                resp->heap, DYNAMIC_TYPE_OCSP_STATUS);\n            if (single->next->status == NULL) {\n                XFREE(single->next, resp->heap, DYNAMIC_TYPE_OCSP_ENTRY);\n                single->next = NULL;\n                return MEMORY_E;\n            }\n            XMEMSET(single->next->status, 0, sizeof(CertStatus));\n\n            single->next->isDynamic = 1;\n\n            single = single->next;\n        }\n    }\n\n    /*\n     * Check the length of the ResponseData against the current index to\n     * see if there are extensions, they are optional.\n     */\n    if (idx - prev_idx < resp->responseSz)\n        if (DecodeOcspRespExtensions(source, &idx, resp, size) < 0)\n            return ASN_PARSE_E;\n\n    *ioIndex = idx;\n    return 0;\n}\n\n\n#ifndef WOLFSSL_NO_OCSP_OPTIONAL_CERTS\n\nstatic int DecodeCerts(byte* source,\n                            word32* ioIndex, OcspResponse* resp, word32 size)\n{\n    word32 idx = *ioIndex;\n    byte tag;\n\n    WOLFSSL_ENTER(\"DecodeCerts\");\n\n    if (GetASNTag(source, &idx, &tag, size) < 0)\n        return ASN_PARSE_E;\n\n    if (tag == (ASN_CONSTRUCTED | ASN_CONTEXT_SPECIFIC))\n    {\n        int length;\n\n        if (GetLength(source, &idx, &length, size) < 0)\n            return ASN_PARSE_E;\n\n        if (GetSequence(source, &idx, &length, size) < 0)\n            return ASN_PARSE_E;\n\n        resp->cert = source + idx;\n        resp->certSz = length;\n\n        idx += length;\n    }\n    *ioIndex = idx;\n    return 0;\n}\n\n#endif /* WOLFSSL_NO_OCSP_OPTIONAL_CERTS */\n\n\nstatic int DecodeBasicOcspResponse(byte* source, word32* ioIndex,\n            OcspResponse* resp, word32 size, void* cm, void* heap, int noVerify)\n{\n    int    length;\n    word32 idx = *ioIndex;\n    word32 end_index;\n    int    ret;\n    int    sigLength;\n\n    WOLFSSL_ENTER(\"DecodeBasicOcspResponse\");\n    (void)heap;\n\n    if (GetSequence(source, &idx, &length, size) < 0)\n        return ASN_PARSE_E;\n\n    if (idx + length > size)\n        return ASN_INPUT_E;\n    end_index = idx + length;\n\n    if ((ret = DecodeResponseData(source, &idx, resp, size)) < 0)\n        return ret; /* ASN_PARSE_E, ASN_BEFORE_DATE_E, ASN_AFTER_DATE_E */\n\n    /* Get the signature algorithm */\n    if (GetAlgoId(source, &idx, &resp->sigOID, oidSigType, size) < 0)\n        return ASN_PARSE_E;\n\n    ret = CheckBitString(source, &idx, &sigLength, size, 1, NULL);\n    if (ret != 0)\n        return ret;\n\n    resp->sigSz = sigLength;\n    resp->sig = source + idx;\n    idx += sigLength;\n\n    /*\n     * Check the length of the BasicOcspResponse against the current index to\n     * see if there are certificates, they are optional.\n     */\n#ifndef WOLFSSL_NO_OCSP_OPTIONAL_CERTS\n    if (idx < end_index)\n    {\n        DecodedCert cert;\n\n        if (DecodeCerts(source, &idx, resp, size) < 0)\n            return ASN_PARSE_E;\n\n        InitDecodedCert(&cert, resp->cert, resp->certSz, heap);\n\n        /* Don't verify if we don't have access to Cert Manager. */\n        ret = ParseCertRelative(&cert, CERT_TYPE,\n                                noVerify ? NO_VERIFY : VERIFY_OCSP_CERT, cm);\n        if (ret < 0) {\n            WOLFSSL_MSG(\"\\tOCSP Responder certificate parsing failed\");\n            FreeDecodedCert(&cert);\n            return ret;\n        }\n\n#ifndef WOLFSSL_NO_OCSP_ISSUER_CHECK\n        if ((cert.extExtKeyUsage & EXTKEYUSE_OCSP_SIGN) == 0) {\n            if (XMEMCMP(cert.subjectHash,\n                        resp->single->issuerHash, OCSP_DIGEST_SIZE) == 0) {\n                WOLFSSL_MSG(\"\\tOCSP Response signed by issuer\");\n            }\n            else {\n                WOLFSSL_MSG(\"\\tOCSP Responder key usage check failed\");\n    #ifdef OPENSSL_EXTRA\n                resp->verifyError = OCSP_BAD_ISSUER;\n    #else\n                FreeDecodedCert(&cert);\n                return BAD_OCSP_RESPONDER;\n    #endif\n            }\n        }\n#endif\n\n        /* ConfirmSignature is blocking here */\n        ret = ConfirmSignature(&cert.sigCtx,\n            resp->response, resp->responseSz,\n            cert.publicKey, cert.pubKeySize, cert.keyOID,\n            resp->sig, resp->sigSz, resp->sigOID, NULL);\n\n        FreeDecodedCert(&cert);\n\n        if (ret != 0) {\n            WOLFSSL_MSG(\"\\tOCSP Confirm signature failed\");\n            return ASN_OCSP_CONFIRM_E;\n        }\n    }\n    else\n#endif /* WOLFSSL_NO_OCSP_OPTIONAL_CERTS */\n    {\n        Signer* ca;\n        int sigValid = -1;\n\n        #ifndef NO_SKID\n            ca = GetCA(cm, resp->single->issuerKeyHash);\n        #else\n            ca = GetCA(cm, resp->single->issuerHash);\n        #endif\n\n        if (ca) {\n            SignatureCtx sigCtx;\n            InitSignatureCtx(&sigCtx, heap, INVALID_DEVID);\n\n            /* ConfirmSignature is blocking here */\n            sigValid = ConfirmSignature(&sigCtx, resp->response,\n                resp->responseSz, ca->publicKey, ca->pubKeySize, ca->keyOID,\n                                resp->sig, resp->sigSz, resp->sigOID, NULL);\n        }\n        if (ca == NULL || sigValid != 0) {\n            WOLFSSL_MSG(\"\\tOCSP Confirm signature failed\");\n            return ASN_OCSP_CONFIRM_E;\n        }\n\n        (void)noVerify;\n    }\n\n    *ioIndex = idx;\n    return 0;\n}\n\n\nvoid InitOcspResponse(OcspResponse* resp, OcspEntry* single, CertStatus* status,\n                      byte* source, word32 inSz, void* heap)\n{\n    WOLFSSL_ENTER(\"InitOcspResponse\");\n\n    XMEMSET(status, 0, sizeof(CertStatus));\n    XMEMSET(single,  0, sizeof(OcspEntry));\n    XMEMSET(resp,   0, sizeof(OcspResponse));\n\n    single->status       = status;\n    resp->responseStatus = -1;\n    resp->single         = single;\n    resp->source         = source;\n    resp->maxIdx         = inSz;\n    resp->heap           = heap;\n}\n\nvoid FreeOcspResponse(OcspResponse* resp)\n{\n    OcspEntry *single, *next;\n    for (single = resp->single; single; single = next) {\n        next = single->next;\n        if (single->isDynamic) {\n            XFREE(single->status, resp->heap, DYNAMIC_TYPE_OCSP_STATUS);\n            XFREE(single, resp->heap, DYNAMIC_TYPE_OCSP_ENTRY);\n        }\n    }\n}\n\n\nint OcspResponseDecode(OcspResponse* resp, void* cm, void* heap, int noVerify)\n{\n    int ret;\n    int length = 0;\n    word32 idx = 0;\n    byte* source = resp->source;\n    word32 size = resp->maxIdx;\n    word32 oid;\n    byte   tag;\n\n    WOLFSSL_ENTER(\"OcspResponseDecode\");\n\n    /* peel the outer SEQUENCE wrapper */\n    if (GetSequence(source, &idx, &length, size) < 0)\n        return ASN_PARSE_E;\n\n    /* First get the responseStatus, an ENUMERATED */\n    if (GetEnumerated(source, &idx, &resp->responseStatus, size) < 0)\n        return ASN_PARSE_E;\n\n    if (resp->responseStatus != OCSP_SUCCESSFUL)\n        return 0;\n\n    /* Next is an EXPLICIT record called ResponseBytes, OPTIONAL */\n    if (idx >= size)\n        return ASN_INPUT_E;\n    if (GetASNTag(source, &idx, &tag, size) < 0)\n        return ASN_PARSE_E;\n    if (tag != (ASN_CONSTRUCTED | ASN_CONTEXT_SPECIFIC))\n        return ASN_PARSE_E;\n    if (GetLength(source, &idx, &length, size) < 0)\n        return ASN_PARSE_E;\n\n    /* Get the responseBytes SEQUENCE */\n    if (GetSequence(source, &idx, &length, size) < 0)\n        return ASN_PARSE_E;\n\n    /* Check ObjectID for the resposeBytes */\n    if (GetObjectId(source, &idx, &oid, oidOcspType, size) < 0)\n        return ASN_PARSE_E;\n    if (oid != OCSP_BASIC_OID)\n        return ASN_PARSE_E;\n    ret = GetOctetString(source, &idx, &length, size);\n    if (ret < 0)\n        return ret;\n\n    ret = DecodeBasicOcspResponse(source, &idx, resp, size, cm, heap, noVerify);\n    if (ret < 0)\n        return ret;\n\n    return 0;\n}\n\n\nword32 EncodeOcspRequestExtensions(OcspRequest* req, byte* output, word32 size)\n{\n    const byte NonceObjId[] = { 0x2b, 0x06, 0x01, 0x05, 0x05, 0x07,\n                                       0x30, 0x01, 0x02 };\n    byte seqArray[5][MAX_SEQ_SZ];\n    word32 seqSz[5], totalSz = (word32)sizeof(NonceObjId);\n\n    WOLFSSL_ENTER(\"SetOcspReqExtensions\");\n\n    if (!req || !output || !req->nonceSz)\n        return 0;\n\n    totalSz += req->nonceSz;\n    totalSz += seqSz[0] = SetOctetString(req->nonceSz, seqArray[0]);\n    totalSz += seqSz[1] = SetOctetString(req->nonceSz + seqSz[0], seqArray[1]);\n    totalSz += seqSz[2] = SetObjectId(sizeof(NonceObjId), seqArray[2]);\n    totalSz += seqSz[3] = SetSequence(totalSz, seqArray[3]);\n    totalSz += seqSz[4] = SetSequence(totalSz, seqArray[4]);\n\n    if (totalSz > size)\n        return 0;\n\n    totalSz = 0;\n\n    XMEMCPY(output + totalSz, seqArray[4], seqSz[4]);\n    totalSz += seqSz[4];\n\n    XMEMCPY(output + totalSz, seqArray[3], seqSz[3]);\n    totalSz += seqSz[3];\n\n    XMEMCPY(output + totalSz, seqArray[2], seqSz[2]);\n    totalSz += seqSz[2];\n\n    XMEMCPY(output + totalSz, NonceObjId, sizeof(NonceObjId));\n    totalSz += (word32)sizeof(NonceObjId);\n\n    XMEMCPY(output + totalSz, seqArray[1], seqSz[1]);\n    totalSz += seqSz[1];\n\n    XMEMCPY(output + totalSz, seqArray[0], seqSz[0]);\n    totalSz += seqSz[0];\n\n    XMEMCPY(output + totalSz, req->nonce, req->nonceSz);\n    totalSz += req->nonceSz;\n\n    return totalSz;\n}\n\n\nint EncodeOcspRequest(OcspRequest* req, byte* output, word32 size)\n{\n    byte seqArray[5][MAX_SEQ_SZ];\n    /* The ASN.1 of the OCSP Request is an onion of sequences */\n    byte algoArray[MAX_ALGO_SZ];\n    byte issuerArray[MAX_ENCODED_DIG_SZ];\n    byte issuerKeyArray[MAX_ENCODED_DIG_SZ];\n    byte snArray[MAX_SN_SZ];\n    byte extArray[MAX_OCSP_EXT_SZ];\n    word32 seqSz[5], algoSz, issuerSz, issuerKeySz, extSz, totalSz;\n    int i, snSz;\n\n    WOLFSSL_ENTER(\"EncodeOcspRequest\");\n\n#ifdef NO_SHA\n    algoSz = SetAlgoID(SHA256h, algoArray, oidHashType, 0);\n#else\n    algoSz = SetAlgoID(SHAh, algoArray, oidHashType, 0);\n#endif\n\n    issuerSz    = SetDigest(req->issuerHash,    KEYID_SIZE,    issuerArray);\n    issuerKeySz = SetDigest(req->issuerKeyHash, KEYID_SIZE,    issuerKeyArray);\n    snSz        = SetSerialNumber(req->serial,  req->serialSz, snArray,\n                                                          MAX_SN_SZ, MAX_SN_SZ);\n    extSz       = 0;\n\n    if (snSz < 0)\n        return snSz;\n\n    if (req->nonceSz) {\n        /* TLS Extensions use this function too - put extensions after\n         * ASN.1: Context Specific [2].\n         */\n        extSz = EncodeOcspRequestExtensions(req, extArray + 2,\n                                            OCSP_NONCE_EXT_SZ);\n        extSz += SetExplicit(2, extSz, extArray);\n    }\n\n    totalSz = algoSz + issuerSz + issuerKeySz + snSz;\n    for (i = 4; i >= 0; i--) {\n        seqSz[i] = SetSequence(totalSz, seqArray[i]);\n        totalSz += seqSz[i];\n        if (i == 2) totalSz += extSz;\n    }\n\n    if (output == NULL)\n        return totalSz;\n    if (totalSz > size)\n        return BUFFER_E;\n\n    totalSz = 0;\n    for (i = 0; i < 5; i++) {\n        XMEMCPY(output + totalSz, seqArray[i], seqSz[i]);\n        totalSz += seqSz[i];\n    }\n\n    XMEMCPY(output + totalSz, algoArray, algoSz);\n    totalSz += algoSz;\n\n    XMEMCPY(output + totalSz, issuerArray, issuerSz);\n    totalSz += issuerSz;\n\n    XMEMCPY(output + totalSz, issuerKeyArray, issuerKeySz);\n    totalSz += issuerKeySz;\n\n    XMEMCPY(output + totalSz, snArray, snSz);\n    totalSz += snSz;\n\n    if (extSz != 0) {\n        XMEMCPY(output + totalSz, extArray, extSz);\n        totalSz += extSz;\n    }\n\n    return totalSz;\n}\n\n\nint InitOcspRequest(OcspRequest* req, DecodedCert* cert, byte useNonce,\n                                                                     void* heap)\n{\n    int ret;\n\n    WOLFSSL_ENTER(\"InitOcspRequest\");\n\n    if (req == NULL)\n        return BAD_FUNC_ARG;\n\n    ForceZero(req, sizeof(OcspRequest));\n    req->heap = heap;\n\n    if (cert) {\n        XMEMCPY(req->issuerHash,    cert->issuerHash,    KEYID_SIZE);\n        XMEMCPY(req->issuerKeyHash, cert->issuerKeyHash, KEYID_SIZE);\n\n        req->serial = (byte*)XMALLOC(cert->serialSz, req->heap,\n                                                     DYNAMIC_TYPE_OCSP_REQUEST);\n        if (req->serial == NULL)\n            return MEMORY_E;\n\n        XMEMCPY(req->serial, cert->serial, cert->serialSz);\n        req->serialSz = cert->serialSz;\n\n        if (cert->extAuthInfoSz != 0 && cert->extAuthInfo != NULL) {\n            req->url = (byte*)XMALLOC(cert->extAuthInfoSz + 1, req->heap,\n                                                     DYNAMIC_TYPE_OCSP_REQUEST);\n            if (req->url == NULL) {\n                XFREE(req->serial, req->heap, DYNAMIC_TYPE_OCSP);\n                return MEMORY_E;\n            }\n\n            XMEMCPY(req->url, cert->extAuthInfo, cert->extAuthInfoSz);\n            req->urlSz = cert->extAuthInfoSz;\n            req->url[req->urlSz] = 0;\n        }\n    }\n\n    if (useNonce) {\n        WC_RNG rng;\n\n    #ifndef HAVE_FIPS\n        ret = wc_InitRng_ex(&rng, req->heap, INVALID_DEVID);\n    #else\n        ret = wc_InitRng(&rng);\n    #endif\n        if (ret != 0) {\n            WOLFSSL_MSG(\"\\tCannot initialize RNG. Skipping the OSCP Nonce.\");\n        } else {\n            if (wc_RNG_GenerateBlock(&rng, req->nonce, MAX_OCSP_NONCE_SZ) != 0)\n                WOLFSSL_MSG(\"\\tCannot run RNG. Skipping the OSCP Nonce.\");\n            else\n                req->nonceSz = MAX_OCSP_NONCE_SZ;\n\n            wc_FreeRng(&rng);\n        }\n    }\n\n    return 0;\n}\n\nvoid FreeOcspRequest(OcspRequest* req)\n{\n    WOLFSSL_ENTER(\"FreeOcspRequest\");\n\n    if (req) {\n        if (req->serial)\n            XFREE(req->serial, req->heap, DYNAMIC_TYPE_OCSP_REQUEST);\n        req->serial = NULL;\n\n#ifdef OPENSSL_EXTRA\n        if (req->serialInt) {\n            if (req->serialInt->isDynamic) {\n                XFREE(req->serialInt->data, NULL, DYNAMIC_TYPE_OPENSSL);\n            }\n            XFREE(req->serialInt, NULL, DYNAMIC_TYPE_OPENSSL);\n        }\n        req->serialInt = NULL;\n#endif\n\n        if (req->url)\n            XFREE(req->url, req->heap, DYNAMIC_TYPE_OCSP_REQUEST);\n        req->url = NULL;\n    }\n}\n\n\nint CompareOcspReqResp(OcspRequest* req, OcspResponse* resp)\n{\n    int cmp = -1; /* default as not matching, cmp gets set on each check */\n    OcspEntry *single, *next, *prev = NULL, *top;\n\n    WOLFSSL_ENTER(\"CompareOcspReqResp\");\n\n    if (req == NULL) {\n        WOLFSSL_MSG(\"\\tReq missing\");\n        return -1;\n    }\n    if (resp == NULL || resp->single == NULL) {\n        WOLFSSL_MSG(\"\\tResp missing\");\n        return 1;\n    }\n\n    /* Nonces are not critical. The responder may not necessarily add\n     * the nonce to the response. */\n    if (req->nonceSz && resp->nonce != NULL\n#ifndef WOLFSSL_FORCE_OCSP_NONCE_CHECK\n            && resp->nonceSz != 0\n#endif\n    ) {\n        cmp = req->nonceSz - resp->nonceSz;\n        if (cmp != 0) {\n            WOLFSSL_MSG(\"\\tnonceSz mismatch\");\n            return cmp;\n        }\n\n        cmp = XMEMCMP(req->nonce, resp->nonce, req->nonceSz);\n        if (cmp != 0) {\n            WOLFSSL_MSG(\"\\tnonce mismatch\");\n            return cmp;\n        }\n    }\n\n    /* match based on found status and return */\n    for (single = resp->single; single; single = next) {\n        cmp = req->serialSz - single->status->serialSz;\n        if (cmp == 0) {\n            cmp = XMEMCMP(req->serial, single->status->serial, req->serialSz)\n               || XMEMCMP(req->issuerHash, single->issuerHash, OCSP_DIGEST_SIZE)\n               || XMEMCMP(req->issuerKeyHash, single->issuerKeyHash, OCSP_DIGEST_SIZE);\n            if (cmp == 0) {\n                /* match found */\n                if (resp->single != single && prev) {\n                    /* move to top of list */\n                    top = resp->single;\n                    resp->single = single;\n                    prev->next = single->next;\n                    single->next = top;\n                }\n                break;\n            }\n        }\n        next = single->next;\n        prev = single;\n    }\n\n    if (cmp != 0) {\n        WOLFSSL_MSG(\"\\trequest and response mismatch\");\n        return cmp;\n    }\n\n    return 0;\n}\n\n#endif /* HAVE_OCSP */\n\n\n/* store WC_SHA hash of NAME */\nint GetNameHash(const byte* source, word32* idx, byte* hash,\n                             int maxIdx)\n{\n    int    length;  /* length of all distinguished names */\n    int    ret;\n    word32 dummy;\n    byte   tag;\n\n    WOLFSSL_ENTER(\"GetNameHash\");\n\n    dummy = *idx;\n    if (GetASNTag(source, &dummy, &tag, maxIdx) == 0 && tag == ASN_OBJECT_ID) {\n        WOLFSSL_MSG(\"Trying optional prefix...\");\n\n        if (GetLength(source, idx, &length, maxIdx) < 0)\n            return ASN_PARSE_E;\n\n        *idx += length;\n        WOLFSSL_MSG(\"Got optional prefix\");\n    }\n\n    /* For OCSP, RFC2560 section 4.1.1 states the issuer hash should be\n     * calculated over the entire DER encoding of the Name field, including\n     * the tag and length. */\n    dummy = *idx;\n    if (GetSequence(source, idx, &length, maxIdx) < 0)\n        return ASN_PARSE_E;\n\n    ret = CalcHashId(source + dummy, length + *idx - dummy, hash);\n\n    *idx += length;\n\n    return ret;\n}\n\n\n#ifdef HAVE_CRL\n\n/* initialize decoded CRL */\nvoid InitDecodedCRL(DecodedCRL* dcrl, void* heap)\n{\n    WOLFSSL_MSG(\"InitDecodedCRL\");\n\n    XMEMSET(dcrl, 0, sizeof(DecodedCRL));\n    dcrl->heap = heap;\n    #ifdef WOLFSSL_HEAP_TEST\n        dcrl->heap = (void*)WOLFSSL_HEAP_TEST;\n    #endif\n}\n\n\n/* free decoded CRL resources */\nvoid FreeDecodedCRL(DecodedCRL* dcrl)\n{\n    RevokedCert* tmp = dcrl->certs;\n\n    WOLFSSL_MSG(\"FreeDecodedCRL\");\n\n    while(tmp) {\n        RevokedCert* next = tmp->next;\n        XFREE(tmp, dcrl->heap, DYNAMIC_TYPE_REVOKED);\n        tmp = next;\n    }\n}\n\n\n/* Get Revoked Cert list, 0 on success */\nstatic int GetRevoked(const byte* buff, word32* idx, DecodedCRL* dcrl,\n                      int maxIdx)\n{\n    int    ret, len;\n    word32 end;\n    byte   b;\n    RevokedCert* rc;\n\n    WOLFSSL_ENTER(\"GetRevoked\");\n\n    if (GetSequence(buff, idx, &len, maxIdx) < 0)\n        return ASN_PARSE_E;\n\n    end = *idx + len;\n\n    rc = (RevokedCert*)XMALLOC(sizeof(RevokedCert), dcrl->heap,\n                                                          DYNAMIC_TYPE_REVOKED);\n    if (rc == NULL) {\n        WOLFSSL_MSG(\"Alloc Revoked Cert failed\");\n        return MEMORY_E;\n    }\n\n    if (GetSerialNumber(buff, idx, rc->serialNumber, &rc->serialSz,\n                                                                maxIdx) < 0) {\n        XFREE(rc, dcrl->heap, DYNAMIC_TYPE_REVOKED);\n        return ASN_PARSE_E;\n    }\n\n    /* add to list */\n    rc->next = dcrl->certs;\n    dcrl->certs = rc;\n    dcrl->totalCerts++;\n\n    /* get date */\n    ret = GetDateInfo(buff, idx, NULL, &b, NULL, maxIdx);\n    if (ret < 0) {\n        WOLFSSL_MSG(\"Expecting Date\");\n        return ret;\n    }\n\n    /* skip extensions */\n    *idx = end;\n\n    return 0;\n}\n\n\n/* Get CRL Signature, 0 on success */\nstatic int GetCRL_Signature(const byte* source, word32* idx, DecodedCRL* dcrl,\n                            int maxIdx)\n{\n    int    length;\n    int    ret;\n\n    WOLFSSL_ENTER(\"GetCRL_Signature\");\n\n    ret = CheckBitString(source, idx, &length, maxIdx, 1, NULL);\n    if (ret != 0)\n        return ret;\n    dcrl->sigLength = length;\n\n    dcrl->signature = (byte*)&source[*idx];\n    *idx += dcrl->sigLength;\n\n    return 0;\n}\n\nint VerifyCRL_Signature(SignatureCtx* sigCtx, const byte* toBeSigned,\n                        word32 tbsSz, const byte* signature, word32 sigSz,\n                        word32 signatureOID, Signer *ca, void* heap)\n{\n    /* try to confirm/verify signature */\n#ifndef IGNORE_KEY_EXTENSIONS\n    if ((ca->keyUsage & KEYUSE_CRL_SIGN) == 0) {\n        WOLFSSL_MSG(\"CA cannot sign CRLs\");\n        return ASN_CRL_NO_SIGNER_E;\n    }\n#endif /* IGNORE_KEY_EXTENSIONS */\n\n    InitSignatureCtx(sigCtx, heap, INVALID_DEVID);\n    if (ConfirmSignature(sigCtx, toBeSigned, tbsSz, ca->publicKey,\n                         ca->pubKeySize, ca->keyOID, signature, sigSz,\n                         signatureOID, NULL) != 0) {\n        WOLFSSL_MSG(\"CRL Confirm signature failed\");\n        return ASN_CRL_CONFIRM_E;\n    }\n\n    return 0;\n}\n\n\nstatic int ParseCRL_CertList(DecodedCRL* dcrl, const byte* buf,\n        word32* inOutIdx, int sz)\n{\n    word32 oid, dateIdx, idx, checkIdx;\n    int version;\n#ifdef WOLFSSL_NO_CRL_NEXT_DATE\n    int doNextDate = 1;\n#endif\n    byte tag;\n\n    if (dcrl == NULL || inOutIdx == NULL || buf == NULL) {\n        return BAD_FUNC_ARG;\n    }\n\n    /* may have version */\n    idx = *inOutIdx;\n\n    checkIdx = idx;\n    if (GetASNTag(buf, &checkIdx, &tag, sz) == 0 && tag == ASN_INTEGER) {\n        if (GetMyVersion(buf, &idx, &version, sz) < 0)\n            return ASN_PARSE_E;\n    }\n\n    if (GetAlgoId(buf, &idx, &oid, oidIgnoreType, sz) < 0)\n        return ASN_PARSE_E;\n\n    if (GetNameHash(buf, &idx, dcrl->issuerHash, sz) < 0)\n        return ASN_PARSE_E;\n\n    if (GetBasicDate(buf, &idx, dcrl->lastDate, &dcrl->lastDateFormat, sz) < 0)\n        return ASN_PARSE_E;\n\n    dateIdx = idx;\n\n    if (GetBasicDate(buf, &idx, dcrl->nextDate, &dcrl->nextDateFormat, sz) < 0)\n    {\n#ifndef WOLFSSL_NO_CRL_NEXT_DATE\n        (void)dateIdx;\n        return ASN_PARSE_E;\n#else\n        dcrl->nextDateFormat = ASN_OTHER_TYPE;  /* skip flag */\n        doNextDate = 0;\n        idx = dateIdx;\n#endif\n    }\n\n#ifdef WOLFSSL_NO_CRL_NEXT_DATE\n    if (doNextDate)x\n#endif\n    {\n#ifndef NO_ASN_TIME\n        if (!XVALIDATE_DATE(dcrl->nextDate, dcrl->nextDateFormat, AFTER)) {\n            WOLFSSL_MSG(\"CRL after date is no longer valid\");\n            return ASN_AFTER_DATE_E;\n        }\n#endif\n    }\n\n    checkIdx = idx;\n    if (idx != dcrl->sigIndex &&\n           GetASNTag(buf, &checkIdx, &tag, sz) == 0 && tag != CRL_EXTENSIONS) {\n\n        int len;\n\n        if (GetSequence(buf, &idx, &len, sz) < 0)\n            return ASN_PARSE_E;\n        len += idx;\n\n        while (idx < (word32)len) {\n            if (GetRevoked(buf, &idx, dcrl, len) < 0)\n                return ASN_PARSE_E;\n        }\n    }\n\n    *inOutIdx = idx;\n\n    return 0;\n}\n\n\n#ifndef NO_SKID\nstatic int ParseCRL_AuthKeyIdExt(const byte* input, int sz, DecodedCRL* dcrl)\n{\n    word32 idx = 0;\n    int length = 0, ret = 0;\n    byte tag;\n\n    WOLFSSL_ENTER(\"ParseCRL_AuthKeyIdExt\");\n\n    if (GetSequence(input, &idx, &length, sz) < 0) {\n        WOLFSSL_MSG(\"\\tfail: should be a SEQUENCE\\n\");\n        return ASN_PARSE_E;\n    }\n\n    if (GetASNTag(input, &idx, &tag, sz) < 0) {\n        return ASN_PARSE_E;\n    }\n\n    if (tag != (ASN_CONTEXT_SPECIFIC | 0)) {\n        WOLFSSL_MSG(\"\\tinfo: OPTIONAL item 0, not available\\n\");\n        return 0;\n    }\n\n    if (GetLength(input, &idx, &length, sz) <= 0) {\n        WOLFSSL_MSG(\"\\tfail: extension data length\");\n        return ASN_PARSE_E;\n    }\n\n    dcrl->extAuthKeyIdSet = 1;\n    if (length == KEYID_SIZE) {\n        XMEMCPY(dcrl->extAuthKeyId, input + idx, length);\n    }\n    else {\n        ret = CalcHashId(input + idx, length, dcrl->extAuthKeyId);\n    }\n\n    return ret;\n}\n#endif\n\n\nstatic int ParseCRL_Extensions(DecodedCRL* dcrl, const byte* buf,\n        word32* inOutIdx, word32 sz)\n{\n    int length;\n    word32 idx;\n    word32 ext_bound; /* boundary index for the sequence of extensions */\n    word32 oid;\n    byte tag;\n\n    WOLFSSL_ENTER(\"ParseCRL_Extensions\");\n    (void)dcrl;\n\n    if (inOutIdx == NULL)\n        return BAD_FUNC_ARG;\n\n    idx = *inOutIdx;\n\n    /* CRL Extensions are optional */\n    if ((idx + 1) > sz)\n        return 0;\n\n    /* CRL Extensions are optional */\n    if (GetASNTag(buf, &idx, &tag, sz) < 0)\n        return 0;\n\n    /* CRL Extensions are optional */\n    if (tag != (ASN_CONSTRUCTED | ASN_CONTEXT_SPECIFIC | 0))\n        return 0;\n\n    if (GetLength(buf, &idx, &length, sz) < 0)\n        return ASN_PARSE_E;\n\n    if (GetSequence(buf, &idx, &length, sz) < 0)\n        return ASN_PARSE_E;\n\n    ext_bound = idx + length;\n\n    while (idx < (word32)ext_bound) {\n        word32 localIdx;\n        int ret;\n\n        if (GetSequence(buf, &idx, &length, sz) < 0) {\n            WOLFSSL_MSG(\"\\tfail: should be a SEQUENCE\");\n            return ASN_PARSE_E;\n        }\n\n        oid = 0;\n        if (GetObjectId(buf, &idx, &oid, oidCrlExtType, sz) < 0) {\n            WOLFSSL_MSG(\"\\tfail: OBJECT ID\");\n            return ASN_PARSE_E;\n        }\n\n        /* check for critical flag */\n        if ((idx + 1) > (word32)sz) {\n            WOLFSSL_MSG(\"\\tfail: malformed buffer\");\n            return BUFFER_E;\n        }\n\n        localIdx = idx;\n        if (GetASNTag(buf, &localIdx, &tag, sz) == 0 && tag == ASN_BOOLEAN) {\n            WOLFSSL_MSG(\"\\tfound optional critical flag, moving past\");\n            ret = GetBoolean(buf, &idx, sz);\n            if (ret < 0)\n                return ret;\n        }\n\n        ret = GetOctetString(buf, &idx, &length, sz);\n        if (ret < 0)\n            return ret;\n\n        if (oid == AUTH_KEY_OID) {\n        #ifndef NO_SKID\n            ret = ParseCRL_AuthKeyIdExt(buf + idx, length, dcrl);\n            if (ret < 0) {\n                WOLFSSL_MSG(\"\\tcouldn't parse AuthKeyId extension\");\n                return ret;\n            }\n        #endif\n        }\n\n        idx += length;\n    }\n\n    *inOutIdx = idx;\n\n    return 0;\n}\n\n\n/* parse crl buffer into decoded state, 0 on success */\nint ParseCRL(DecodedCRL* dcrl, const byte* buff, word32 sz, void* cm)\n{\n    int          len;\n    word32       idx = 0;\n    Signer*      ca = NULL;\n    SignatureCtx sigCtx;\n\n    WOLFSSL_MSG(\"ParseCRL\");\n\n    /* raw crl hash */\n    /* hash here if needed for optimized comparisons\n     * wc_Sha sha;\n     * wc_InitSha(&sha);\n     * wc_ShaUpdate(&sha, buff, sz);\n     * wc_ShaFinal(&sha, dcrl->crlHash); */\n\n    if (GetSequence(buff, &idx, &len, sz) < 0)\n        return ASN_PARSE_E;\n\n    dcrl->certBegin = idx;\n    /* Normalize sz for the length inside the outer sequence. */\n    sz = len + idx;\n\n    if (GetSequence(buff, &idx, &len, sz) < 0)\n        return ASN_PARSE_E;\n    dcrl->sigIndex = len + idx;\n\n    if (ParseCRL_CertList(dcrl, buff, &idx, dcrl->sigIndex) < 0)\n        return ASN_PARSE_E;\n\n    if (ParseCRL_Extensions(dcrl, buff, &idx, dcrl->sigIndex) < 0)\n        return ASN_PARSE_E;\n\n    idx = dcrl->sigIndex;\n\n    if (GetAlgoId(buff, &idx, &dcrl->signatureOID, oidSigType, sz) < 0)\n        return ASN_PARSE_E;\n\n    if (GetCRL_Signature(buff, &idx, dcrl, sz) < 0)\n        return ASN_PARSE_E;\n\n    /* openssl doesn't add skid by default for CRLs cause firefox chokes\n       if experiencing issues uncomment NO_SKID define in CRL section of\n       wolfssl/wolfcrypt/settings.h */\n#ifndef NO_SKID\n    if (dcrl->extAuthKeyIdSet) {\n        ca = GetCA(cm, dcrl->extAuthKeyId); /* more unique than issuerHash */\n    }\n    if (ca != NULL && XMEMCMP(dcrl->issuerHash, ca->subjectNameHash,\n                KEYID_SIZE) != 0) {\n        ca = NULL;\n    }\n    if (ca == NULL) {\n        ca = GetCAByName(cm, dcrl->issuerHash); /* last resort */\n        /* If AKID is available then this CA doesn't have the public\n         * key required */\n        if (ca && dcrl->extAuthKeyIdSet) {\n            WOLFSSL_MSG(\"CA SKID doesn't match AKID\");\n            ca = NULL;\n        }\n    }\n#else\n    ca = GetCA(cm, dcrl->issuerHash);\n#endif /* !NO_SKID */\n    WOLFSSL_MSG(\"About to verify CRL signature\");\n\n    if (ca == NULL) {\n        WOLFSSL_MSG(\"Did NOT find CRL issuer CA\");\n        return ASN_CRL_NO_SIGNER_E;\n    }\n\n    WOLFSSL_MSG(\"Found CRL issuer CA\");\n    return VerifyCRL_Signature(&sigCtx, buff + dcrl->certBegin,\n           dcrl->sigIndex - dcrl->certBegin, dcrl->signature, dcrl->sigLength,\n           dcrl->signatureOID, ca, dcrl->heap);\n}\n\n#endif /* HAVE_CRL */\n\n\n\n#ifdef WOLFSSL_CERT_PIV\n\nint wc_ParseCertPIV(wc_CertPIV* piv, const byte* buf, word32 totalSz)\n{\n    int length = 0;\n    word32 idx = 0;\n\n    WOLFSSL_ENTER(\"wc_ParseCertPIV\");\n\n    if (piv == NULL || buf == NULL || totalSz == 0)\n        return BAD_FUNC_ARG;\n\n    XMEMSET(piv, 0, sizeof(wc_CertPIV));\n\n    /* Detect Identiv PIV (with 0x0A, 0x0B and 0x0C sections) */\n    /* Certificate (0A 82 05FA) */\n    if (GetASNHeader(buf, ASN_PIV_CERT, &idx, &length, totalSz) >= 0) {\n        /* Identiv Type PIV card */\n        piv->isIdentiv = 1;\n\n        piv->cert =   &buf[idx];\n        piv->certSz = length;\n        idx += length;\n\n        /* Nonce (0B 14) */\n        if (GetASNHeader(buf, ASN_PIV_NONCE, &idx, &length, totalSz) >= 0) {\n            piv->nonce =   &buf[idx];\n            piv->nonceSz = length;\n            idx += length;\n        }\n\n        /* Signed Nonce (0C 82 0100) */\n        if (GetASNHeader(buf, ASN_PIV_SIGNED_NONCE, &idx, &length, totalSz) >= 0) {\n            piv->signedNonce =   &buf[idx];\n            piv->signedNonceSz = length;\n        }\n\n        idx = 0;\n        buf = piv->cert;\n        totalSz = piv->certSz;\n    }\n\n    /* Certificate Buffer Total Size (53 82 05F6) */\n    if (GetASNHeader(buf, ASN_APPLICATION | ASN_PRINTABLE_STRING, &idx,\n                                                   &length, totalSz) < 0) {\n        return ASN_PARSE_E;\n    }\n    /* PIV Certificate (70 82 05ED) */\n    if (GetASNHeader(buf, ASN_PIV_TAG_CERT, &idx, &length,\n                                                         totalSz) < 0) {\n        return ASN_PARSE_E;\n    }\n\n    /* Capture certificate buffer pointer and length */\n    piv->cert =   &buf[idx];\n    piv->certSz = length;\n    idx += length;\n\n    /* PIV Certificate Info (71 01 00) */\n    if (GetASNHeader(buf, ASN_PIV_TAG_CERT_INFO, &idx, &length,\n                                                        totalSz) >= 0) {\n        if (length >= 1) {\n            piv->compression = (buf[idx] & ASN_PIV_CERT_INFO_COMPRESSED);\n            piv->isX509 =      (buf[idx] & ASN_PIV_CERT_INFO_ISX509);\n        }\n        idx += length;\n    }\n\n    /* PIV Error Detection (FE 00) */\n    if (GetASNHeader(buf, ASN_PIV_TAG_ERR_DET, &idx, &length,\n                                                        totalSz) >= 0) {\n        piv->certErrDet =   &buf[idx];\n        piv->certErrDetSz = length;\n        idx += length;\n    }\n\n    return 0;\n}\n\n#endif /* WOLFSSL_CERT_PIV */\n\n\n\n#ifdef HAVE_SMIME\n\n/*****************************************************************************\n* wc_MIME_parse_headers - Reads the char array in and parses out MIME headers\n* and parameters into headers.  Will continue until in has no more content.\n*\n* RETURNS:\n* returns zero on success, non-zero on error.\n*/\nint wc_MIME_parse_headers(char* in, int inLen, MimeHdr** headers)\n{\n    MimeHdr* nextHdr = NULL;\n    MimeHdr* curHdr = NULL;\n    MimeParam* nextParam = NULL;\n    size_t start = 0;\n    size_t end = 0;\n    char* nameAttr = NULL;\n    char* bodyVal = NULL;\n    MimeTypes mimeType = MIME_HDR;\n    MimeStatus mimeStatus = MIME_NAMEATTR;\n    int ret = -1;\n    size_t pos = 0;\n    size_t lineLen = 0;\n    char* curLine = NULL;\n    char* ptr = NULL;\n\n    if (in == NULL || inLen <= 0 || in[inLen] != '\\0' || headers == NULL) {\n        ret = BAD_FUNC_ARG;\n        goto error;\n    }\n    nextHdr = (MimeHdr*)XMALLOC(sizeof(MimeHdr), NULL, DYNAMIC_TYPE_PKCS7);\n    nextParam = (MimeParam*)XMALLOC(sizeof(MimeParam), NULL,\n                                    DYNAMIC_TYPE_PKCS7);\n    if (nextHdr == NULL || nextParam == NULL) {\n        ret = MEMORY_E;\n        goto error;\n    }\n    XMEMSET(nextHdr, 0, (word32)sizeof(MimeHdr));\n    XMEMSET(nextParam, 0, (word32)sizeof(MimeParam));\n\n    curLine = XSTRTOK(in, \"\\r\\n\", &ptr);\n    if (curLine == NULL) {\n        ret = ASN_PARSE_E;\n        goto error;\n    }\n\n    while (curLine != NULL) {\n        /* Leftover from previous line, add params to previous header. */\n        if (curLine[0] == ' ' && curHdr) {\n            mimeType = MIME_PARAM;\n        }\n        else {\n            mimeType = MIME_HDR;\n        }\n        start = 0;\n        lineLen = XSTRLEN(curLine);\n        if (lineLen == 0) {\n            ret = BAD_FUNC_ARG;\n            goto error;\n        }\n\n        for (pos = 0; pos < lineLen; pos++) {\n            char cur = curLine[pos];\n\n            if (mimeStatus == MIME_NAMEATTR && ((cur == ':' &&\n                mimeType == MIME_HDR) || (cur == '=' &&\n                mimeType == MIME_PARAM)) && pos >= 1) {\n                mimeStatus = MIME_BODYVAL;\n                end = pos-1;\n                ret = wc_MIME_header_strip(curLine, &nameAttr, start, end);\n                if (ret) {\n                    goto error;\n                }\n                start = pos+1;\n            }\n            else if (mimeStatus == MIME_BODYVAL && cur == ';' && pos >= 1) {\n                end = pos-1;\n                ret = wc_MIME_header_strip(curLine, &bodyVal, start, end);\n                if (ret) {\n                    goto error;\n                }\n                if (mimeType == MIME_HDR) {\n                    nextHdr->name = nameAttr;\n                    nameAttr = NULL;\n                    nextHdr->body = bodyVal;\n                    bodyVal = NULL;\n                    nextHdr->next = curHdr;\n                    curHdr = nextHdr;\n                    nextHdr = (MimeHdr*)XMALLOC(sizeof(MimeHdr), NULL,\n                                                DYNAMIC_TYPE_PKCS7);\n                    if (nextHdr == NULL) {\n                        ret = MEMORY_E;\n                        goto error;\n                    }\n                    XMEMSET(nextHdr, 0, (word32)sizeof(MimeHdr));\n                }\n                else {\n                    nextParam->attribute = nameAttr;\n                    nameAttr = NULL;\n                    nextParam->value = bodyVal;\n                    bodyVal = NULL;\n                    nextParam->next = curHdr->params;\n                    curHdr->params = nextParam;\n                    nextParam = (MimeParam*)XMALLOC(sizeof(MimeParam), NULL,\n                                                    DYNAMIC_TYPE_PKCS7);\n                    if (nextParam == NULL) {\n                        ret = MEMORY_E;\n                        goto error;\n                    }\n                    XMEMSET(nextParam, 0, (word32)sizeof(MimeParam));\n                }\n                mimeType = MIME_PARAM;\n                mimeStatus = MIME_NAMEATTR;\n                start = pos+1;\n            }\n        }\n\n        end = lineLen-1;\n        /* Omit newline characters. */\n        while ((curLine[end] == '\\r' || curLine[end] == '\\n') && end > 0) {\n            end--;\n        }\n        if (end >= start && mimeStatus == MIME_BODYVAL) {\n            ret = wc_MIME_header_strip(curLine, &bodyVal, start, end);\n            if (ret) {\n                goto error;\n            }\n            if (mimeType == MIME_HDR) {\n                nextHdr->name = nameAttr;\n                nameAttr = NULL;\n                nextHdr->body = bodyVal;\n                bodyVal = NULL;\n                nextHdr->next = curHdr;\n                curHdr = nextHdr;\n                nextHdr = (MimeHdr*)XMALLOC(sizeof(MimeHdr), NULL,\n                                            DYNAMIC_TYPE_PKCS7);\n                if (nextHdr == NULL) {\n                    ret = MEMORY_E;\n                    goto error;\n                }\n                XMEMSET(nextHdr, 0, (word32)sizeof(MimeHdr));\n            } else {\n                nextParam->attribute = nameAttr;\n                nameAttr = NULL;\n                nextParam->value = bodyVal;\n                bodyVal = NULL;\n                nextParam->next = curHdr->params;\n                curHdr->params = nextParam;\n                nextParam = (MimeParam*)XMALLOC(sizeof(MimeParam), NULL,\n                                                DYNAMIC_TYPE_PKCS7);\n                if (nextParam == NULL) {\n                    ret = MEMORY_E;\n                    goto error;\n                }\n                XMEMSET(nextParam, 0, (word32)sizeof(MimeParam));\n            }\n        }\n\n        curLine = XSTRTOK(NULL, \"\\r\\n\", &ptr);\n        mimeStatus = MIME_NAMEATTR;\n    }\n\n    *headers = curHdr;\n    ret = 0; /* success if at this point */\n\nerror:\n    if (ret != 0)\n        wc_MIME_free_hdrs(curHdr);\n    wc_MIME_free_hdrs(nextHdr);\n    if (nameAttr != NULL)\n        XFREE(nameAttr, NULL, DYNAMIC_TYPE_PKCS7);\n    if (bodyVal != NULL)\n        XFREE(bodyVal, NULL, DYNAMIC_TYPE_PKCS7);\n    XFREE(nextParam, NULL, DYNAMIC_TYPE_PKCS7);\n\n    return ret;\n}\n\n/*****************************************************************************\n* wc_MIME_header_strip - Reads the string in from indices start to end, strips\n* out disallowed/separator characters and places the rest into *out.\n*\n* RETURNS:\n* returns zero on success, non-zero on error.\n*/\nint wc_MIME_header_strip(char* in, char** out, size_t start, size_t end)\n{\n    size_t inPos = start;\n    size_t outPos = 0;\n    size_t inLen = 0;\n\n    if (end < start || in == NULL || out == NULL) {\n        return BAD_FUNC_ARG;\n    }\n\n    inLen = XSTRLEN(in);\n    if (start > inLen || end > inLen) {\n        return BAD_FUNC_ARG;\n    }\n\n    *out = (char*)XMALLOC(((end-start)+2)*sizeof(char), NULL,\n                          DYNAMIC_TYPE_PKCS7);\n    if (*out == NULL) {\n        return MEMORY_E;\n    }\n\n    while (inPos <= end) {\n        if (in[inPos] >= MIME_HEADER_ASCII_MIN && in[inPos] <=\n            MIME_HEADER_ASCII_MAX && in[inPos] != ';' && in[inPos] != '\\\"') {\n            (*out)[outPos] = in[inPos];\n            outPos++;\n        }\n        inPos++;\n    }\n    (*out)[outPos] = '\\0';\n\n    return 0;\n}\n\n/*****************************************************************************\n* wc_MIME_find_header_name - Searches through all given headers until a header with\n* a name matching the provided name is found.\n*\n* RETURNS:\n* returns a pointer to the found header, if no match was found, returns NULL.\n*/\nMimeHdr* wc_MIME_find_header_name(const char* name, MimeHdr* header)\n{\n    size_t len = XSTRLEN(name);\n\n    while (header) {\n        if (!XSTRNCMP(name, header->name, len)) {\n            return header;\n        }\n        header = header->next;\n    }\n\n    return header;\n}\n\n/*****************************************************************************\n* wc_MIME_find_param_attr - Searches through all parameters until a parameter\n* with a attribute matching the provided attribute is found.\n*\n* RETURNS:\n* returns a pointer to the found parameter, if no match was found,\n* returns NULL.\n*/\nMimeParam* wc_MIME_find_param_attr(const char* attribute,\n                                    MimeParam* param)\n{\n    size_t len = XSTRLEN(attribute);\n\n    while (param) {\n        if (!XSTRNCMP(attribute, param->attribute, len)) {\n            return param;\n        }\n        param = param->next;\n    }\n\n    return param;\n}\n\n/*****************************************************************************\n* wc_MIME_canonicalize - Canonicalize a line by converting all line endings\n* to CRLF.\n*\n* RETURNS:\n* returns a pointer to a canonicalized line on success, NULL on error.\n*/\nchar* wc_MIME_canonicalize(const char* line)\n{\n    size_t end = 0;\n    char* canonLine = NULL;\n\n    if (line == NULL || XSTRLEN(line) == 0) {\n        return NULL;\n    }\n\n    end = XSTRLEN(line);\n    while (end >= 1 && ((line[end-1] == '\\r') || (line[end-1] == '\\n'))) {\n        end--;\n    }\n\n    /* Need 2 chars for \\r\\n and 1 for EOL */\n    canonLine = (char*)XMALLOC((end+3)*sizeof(char), NULL, DYNAMIC_TYPE_PKCS7);\n    if (canonLine == NULL) {\n        return NULL;\n    }\n\n    XSTRNCPY(canonLine, line, end);\n    canonLine[end] = '\\r';\n    canonLine[end+1] = '\\n';\n    canonLine[end+2] = '\\0';\n\n    return canonLine;\n}\n\n/*****************************************************************************\n* wc_MIME_free_hdrs - Frees all MIME headers, parameters and strings starting from\n* the provided header pointer.\n*\n* RETURNS:\n* returns zero on success, non-zero on error.\n*/\nint wc_MIME_free_hdrs(MimeHdr* head)\n{\n    MimeHdr* curHdr = NULL;\n    MimeParam* curParam = NULL;\n\n    while (head) {\n        while (head->params) {\n            curParam = head->params;\n            head->params = head->params->next;\n            XFREE(curParam->attribute, NULL, DYNAMIC_TYPE_PKCS7);\n            XFREE(curParam->value, NULL, DYNAMIC_TYPE_PKCS7);\n            XFREE(curParam, NULL, DYNAMIC_TYPE_PKCS7);\n        }\n        curHdr = head;\n        head = head->next;\n        XFREE(curHdr->name, NULL, DYNAMIC_TYPE_PKCS7);\n        XFREE(curHdr->body, NULL, DYNAMIC_TYPE_PKCS7);\n        XFREE(curHdr, NULL, DYNAMIC_TYPE_PKCS7);\n    }\n\n    return 0;\n}\n\n#endif /* HAVE_SMIME */\n\n\n#undef ERROR_OUT\n\n#endif /* !NO_ASN */\n\n#ifdef WOLFSSL_SEP\n\n\n#endif /* WOLFSSL_SEP */\n", "/* asn.h\n *\n * Copyright (C) 2006-2021 wolfSSL Inc.\n *\n * This file is part of wolfSSL.\n *\n * wolfSSL is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * wolfSSL is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1335, USA\n */\n\n/*!\n    \\file wolfssl/wolfcrypt/asn.h\n*/\n\n/*\n\nDESCRIPTION\nThis library provides the interface to Abstract Syntax Notation One (ASN.1) objects.\nASN.1 is a standard interface description language for defining data structures\nthat can be serialized and deserialized in a cross-platform way.\n\n*/\n#ifndef WOLF_CRYPT_ASN_H\n#define WOLF_CRYPT_ASN_H\n\n#include <wolfssl/wolfcrypt/types.h>\n\n#ifndef NO_ASN\n\n\n#if !defined(NO_ASN_TIME) && defined(NO_TIME_H)\n    #define NO_ASN_TIME /* backwards compatibility with NO_TIME_H */\n#endif\n\n#include <wolfssl/wolfcrypt/integer.h>\n\n/* fips declare of RsaPrivateKeyDecode @wc_fips */\n#if defined(HAVE_FIPS) && !defined(NO_RSA) && \\\n\t(!defined(HAVE_FIPS_VERSION) || (HAVE_FIPS_VERSION < 2))\n    #include <cyassl/ctaocrypt/rsa.h>\n#endif\n\n#ifndef NO_DH\n    #include <wolfssl/wolfcrypt/dh.h>\n#endif\n#ifndef NO_DSA\n    #include <wolfssl/wolfcrypt/dsa.h>\n#endif\n#ifndef NO_SHA\n    #include <wolfssl/wolfcrypt/sha.h>\n#endif\n#ifndef NO_MD5\n    #include <wolfssl/wolfcrypt/md5.h>\n#endif\n#include <wolfssl/wolfcrypt/sha256.h>\n#include <wolfssl/wolfcrypt/asn_public.h>   /* public interface */\n\n#if defined(NO_SHA) && defined(NO_SHA256)\n    #define WC_SHA256_DIGEST_SIZE 32\n#endif\n\n#ifdef __cplusplus\n    extern \"C\" {\n#endif\n\n#ifndef EXTERNAL_SERIAL_SIZE\n    #define EXTERNAL_SERIAL_SIZE 32\n#endif\n\nenum {\n    ISSUER  = 0,\n    SUBJECT = 1,\n\n    BEFORE  = 0,\n    AFTER   = 1\n};\n\n/* ASN Tags   */\nenum ASN_Tags {\n    ASN_EOC               = 0x00,\n    ASN_BOOLEAN           = 0x01,\n    ASN_INTEGER           = 0x02,\n    ASN_BIT_STRING        = 0x03,\n    ASN_OCTET_STRING      = 0x04,\n    ASN_TAG_NULL          = 0x05,\n    ASN_OBJECT_ID         = 0x06,\n    ASN_ENUMERATED        = 0x0a,\n    ASN_UTF8STRING        = 0x0c,\n    ASN_SEQUENCE          = 0x10,\n    ASN_SET               = 0x11,\n    ASN_PRINTABLE_STRING  = 0x13,\n    ASN_IA5_STRING        = 0x16,\n    ASN_UTC_TIME          = 0x17,\n    ASN_OTHER_TYPE        = 0x00,\n    ASN_RFC822_TYPE       = 0x01,\n    ASN_DNS_TYPE          = 0x02,\n    ASN_DIR_TYPE          = 0x04,\n    ASN_URI_TYPE          = 0x06, /* the value 6 is from GeneralName OID */\n    ASN_IP_TYPE           = 0x07, /* the value 7 is from GeneralName OID */\n    ASN_GENERALIZED_TIME  = 0x18,\n    CRL_EXTENSIONS        = 0xa0,\n    ASN_EXTENSIONS        = 0xa3,\n    ASN_LONG_LENGTH       = 0x80,\n    ASN_INDEF_LENGTH      = 0x80,\n\n    /* ASN_Flags - Bitmask */\n    ASN_CONSTRUCTED       = 0x20,\n    ASN_APPLICATION       = 0x40,\n    ASN_CONTEXT_SPECIFIC  = 0x80,\n};\n\n#define ASN_UTC_TIME_SIZE 14\n#define ASN_GENERALIZED_TIME_SIZE 16\n#define ASN_GENERALIZED_TIME_MAX 68\n\nenum DN_Tags {\n    ASN_DN_NULL       = 0x00,\n    ASN_COMMON_NAME   = 0x03,   /* CN */\n    ASN_SUR_NAME      = 0x04,   /* SN */\n    ASN_SERIAL_NUMBER = 0x05,   /* serialNumber */\n    ASN_COUNTRY_NAME  = 0x06,   /* C  */\n    ASN_LOCALITY_NAME = 0x07,   /* L  */\n    ASN_STATE_NAME    = 0x08,   /* ST */\n    ASN_ORG_NAME      = 0x0a,   /* O  */\n    ASN_ORGUNIT_NAME  = 0x0b,   /* OU */\n    ASN_BUS_CAT       = 0x0f,   /* businessCategory */\n    ASN_EMAIL_NAME    = 0x98,   /* not oid number there is 97 in 2.5.4.0-97 */\n\n    /* pilot attribute types\n     * OID values of 0.9.2342.19200300.100.1.* */\n    ASN_USER_ID          = 0x01, /* UID */\n    ASN_FAVOURITE_DRINK  = 0x05, /* favouriteDrink */\n    ASN_DOMAIN_COMPONENT = 0x19  /* DC */\n};\n\n/* This is the size of the smallest possible PEM header and footer */\nextern const int pem_struct_min_sz;\n\n#if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)\ntypedef struct WOLFSSL_ObjectInfo {\n    int nid;\n    int id;\n    word32 type;\n    const char* sName;\n    const char* lName;\n} WOLFSSL_ObjectInfo;\nextern const size_t wolfssl_object_info_sz;\nextern const WOLFSSL_ObjectInfo wolfssl_object_info[];\n#endif /* defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL) */\n\n/* DN Tag Strings */\n#define WOLFSSL_COMMON_NAME      \"/CN=\"\n#define WOLFSSL_LN_COMMON_NAME   \"/commonName=\"\n#define WOLFSSL_SUR_NAME         \"/SN=\"\n#define WOLFSSL_SERIAL_NUMBER    \"/serialNumber=\"\n#define WOLFSSL_COUNTRY_NAME     \"/C=\"\n#define WOLFSSL_LN_COUNTRY_NAME  \"/countryName=\"\n#define WOLFSSL_LOCALITY_NAME    \"/L=\"\n#define WOLFSSL_LN_LOCALITY_NAME \"/localityName=\"\n#define WOLFSSL_STATE_NAME       \"/ST=\"\n#define WOLFSSL_LN_STATE_NAME    \"/stateOrProvinceName=\"\n#define WOLFSSL_ORG_NAME         \"/O=\"\n#define WOLFSSL_LN_ORG_NAME      \"/organizationName=\"\n#define WOLFSSL_ORGUNIT_NAME     \"/OU=\"\n#define WOLFSSL_LN_ORGUNIT_NAME  \"/organizationalUnitName=\"\n#define WOLFSSL_DOMAIN_COMPONENT \"/DC=\"\n#define WOLFSSL_LN_DOMAIN_COMPONENT \"/domainComponent=\"\n#define WOLFSSL_BUS_CAT          \"/businessCategory=\"\n#define WOLFSSL_JOI_C            \"/jurisdictionC=\"\n#define WOLFSSL_JOI_ST           \"/jurisdictionST=\"\n#define WOLFSSL_EMAIL_ADDR       \"/emailAddress=\"\n\n#define WOLFSSL_USER_ID          \"/UID=\"\n#define WOLFSSL_DOMAIN_COMPONENT \"/DC=\"\n#define WOLFSSL_FAVOURITE_DRINK  \"/favouriteDrink=\"\n\n#if defined(WOLFSSL_APACHE_HTTPD)\n    /* otherName strings */\n    #define WOLFSSL_SN_MS_UPN       \"msUPN\"\n    #define WOLFSSL_LN_MS_UPN       \"Microsoft User Principal Name\"\n    #define WOLFSSL_MS_UPN_SUM 265\n    #define WOLFSSL_SN_DNS_SRV      \"id-on-dnsSRV\"\n    #define WOLFSSL_LN_DNS_SRV      \"SRVName\"\n    /* TLS features extension strings */\n    #define WOLFSSL_SN_TLS_FEATURE  \"tlsfeature\"\n    #define WOLFSSL_LN_TLS_FEATURE  \"TLS Feature\"\n    #define WOLFSSL_TLS_FEATURE_SUM 92\n#endif\n\n#if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)\n/* NIDs */\nenum\n{\n    NID_undef = 0,\n    NID_netscape_cert_type = NID_undef,\n    NID_des = 66,\n    NID_des3 = 67,\n    NID_sha256 = 672,\n    NID_sha384 = 673,\n    NID_sha512 = 674,\n    NID_pkcs9_challengePassword = 54,\n    NID_hw_name_oid = 73,\n    NID_id_pkix_OCSP_basic = 74,\n    NID_any_policy = 75,\n    NID_anyExtendedKeyUsage = 76,\n    NID_givenName = 99,\n    NID_initials = 101,\n    NID_title = 106,\n    NID_description = 107,\n    NID_basic_constraints = 133,\n    NID_key_usage = 129,     /* 2.5.29.15 */\n    NID_ext_key_usage = 151, /* 2.5.29.37 */\n    NID_subject_key_identifier = 128,\n    NID_authority_key_identifier = 149,\n    NID_private_key_usage_period = 130, /* 2.5.29.16 */\n    NID_subject_alt_name = 131,\n    NID_issuer_alt_name = 132,\n    NID_info_access = 69,\n    NID_sinfo_access = 79,      /* id-pe 11 */\n    NID_name_constraints = 144, /* 2.5.29.30 */\n    NID_crl_distribution_points = 145, /* 2.5.29.31 */\n    NID_certificate_policies = 146,\n    NID_policy_mappings = 147,\n    NID_policy_constraints = 150,\n    NID_inhibit_any_policy = 168,      /* 2.5.29.54 */\n    NID_tlsfeature = 1020,             /* id-pe 24 */\n    NID_commonName = 0x03,             /* matches ASN_COMMON_NAME in asn.h */\n    NID_buildingName = 1494,\n\n\n    NID_surname = 0x04,                /* SN */\n    NID_serialNumber = 0x05,           /* serialNumber */\n    NID_countryName = 0x06,            /* C  */\n    NID_localityName = 0x07,           /* L  */\n    NID_stateOrProvinceName = 0x08,    /* ST */\n    NID_organizationName = 0x0a,       /* O  */\n    NID_organizationalUnitName = 0x0b, /* OU */\n    NID_jurisdictionCountryName = 0xc,\n    NID_jurisdictionStateOrProvinceName = 0xd,\n    NID_businessCategory = ASN_BUS_CAT,\n    NID_domainComponent = ASN_DOMAIN_COMPONENT,\n    NID_favouriteDrink = 462,\n    NID_userId = 458,\n    NID_emailAddress = 0x30,           /* emailAddress */\n    NID_id_on_dnsSRV = 82,             /* 1.3.6.1.5.5.7.8.7 */\n    NID_ms_upn = 265,                  /* 1.3.6.1.4.1.311.20.2.3 */\n\n    NID_X9_62_prime_field = 406        /* 1.2.840.10045.1.1 */\n};\n#endif /* OPENSSL_EXTRA */\n\nenum ECC_TYPES\n{\n    ECC_PREFIX_0 = 160,\n    ECC_PREFIX_1 = 161\n};\n\n#ifdef WOLFSSL_CERT_PIV\n    enum PIV_Tags {\n        ASN_PIV_CERT          = 0x0A,\n        ASN_PIV_NONCE         = 0x0B,\n        ASN_PIV_SIGNED_NONCE  = 0x0C,\n\n        ASN_PIV_TAG_CERT      = 0x70,\n        ASN_PIV_TAG_CERT_INFO = 0x71,\n        ASN_PIV_TAG_MSCUID    = 0x72,\n        ASN_PIV_TAG_ERR_DET   = 0xFE,\n\n        /* certificate info masks */\n        ASN_PIV_CERT_INFO_COMPRESSED = 0x03,\n        ASN_PIV_CERT_INFO_ISX509     = 0x04,\n    };\n#endif /* WOLFSSL_CERT_PIV */\n\n\n#define ASN_JOI_PREFIX_SZ       10\n#define ASN_JOI_PREFIX          \"\\x2b\\x06\\x01\\x04\\x01\\x82\\x37\\x3c\\x02\\x01\"\n#define ASN_JOI_C               0x3\n#define ASN_JOI_ST              0x2\n\n#ifndef WC_ASN_NAME_MAX\n    #ifdef OPENSSL_EXTRA\n        #define WC_ASN_NAME_MAX 300\n    #else\n        #define WC_ASN_NAME_MAX 256\n    #endif\n#endif\n#define ASN_NAME_MAX WC_ASN_NAME_MAX\n\nenum Misc_ASN {\n    MAX_SALT_SIZE       =  64,     /* MAX PKCS Salt length */\n    MAX_IV_SIZE         =  64,     /* MAX PKCS Iv length */\n    ASN_BOOL_SIZE       =   2,     /* including type */\n    ASN_ECC_HEADER_SZ   =   2,     /* String type + 1 byte len */\n    ASN_ECC_CONTEXT_SZ  =   2,     /* Content specific type + 1 byte len */\n#ifdef NO_SHA\n    KEYID_SIZE          = WC_SHA256_DIGEST_SIZE,\n#else\n    KEYID_SIZE          = WC_SHA_DIGEST_SIZE,\n#endif\n    RSA_INTS            =   8,     /* RSA ints in private key */\n    DSA_PARAM_INTS      =   3,     /* DSA paramater ints */\n    DSA_INTS            =   5,     /* DSA ints in private key */\n    MIN_DATE_SIZE       =  12,\n    MAX_DATE_SIZE       =  32,\n    ASN_GEN_TIME_SZ     =  15,     /* 7 numbers * 2 + Zulu tag */\n#ifndef NO_RSA\n#ifdef WOLFSSL_HAPROXY\n    MAX_ENCODED_SIG_SZ  = 1024,    /* Supports 8192 bit keys */\n#else\n    MAX_ENCODED_SIG_SZ  = 512,     /* Supports 4096 bit keys */\n#endif\n#elif defined(HAVE_ECC)\n    MAX_ENCODED_SIG_SZ  = 140,\n#elif defined(HAVE_CURVE448)\n    MAX_ENCODED_SIG_SZ  = 114,\n#else\n    MAX_ENCODED_SIG_SZ  =  64,\n#endif\n    MAX_SIG_SZ          = 256,\n    MAX_ALGO_SZ         =  20,\n    MAX_SHORT_SZ        =   6,     /* asn int + byte len + 4 byte length */\n    MAX_SEQ_SZ          =   5,     /* enum(seq | con) + length(4) */\n    MAX_SET_SZ          =   5,     /* enum(set | con) + length(4) */\n    MAX_OCTET_STR_SZ    =   5,     /* enum(set | con) + length(4) */\n    MAX_EXP_SZ          =   5,     /* enum(contextspec|con|exp) + length(4) */\n    MAX_PRSTR_SZ        =   5,     /* enum(prstr) + length(4) */\n    MAX_VERSION_SZ      =   5,     /* enum + id + version(byte) + (header(2))*/\n    MAX_ENCODED_DIG_ASN_SZ= 9,     /* enum(bit or octet) + length(4) */\n    MAX_ENCODED_DIG_SZ  =  64 + MAX_ENCODED_DIG_ASN_SZ, /* asn header + sha512 */\n    MAX_RSA_INT_SZ      = 517,     /* RSA raw sz 4096 for bits + tag + len(4) */\n    MAX_DSA_INT_SZ      = 389,     /* DSA raw sz 3072 for bits + tag + len(4) */\n    MAX_NTRU_KEY_SZ     = 610,     /* NTRU 112 bit public key */\n    MAX_NTRU_ENC_SZ     = 628,     /* NTRU 112 bit DER public encoding */\n    MAX_LENGTH_SZ       =   4,     /* Max length size for DER encoding */\n    MAX_RSA_E_SZ        =  16,     /* Max RSA public e size */\n    MAX_CA_SZ           =  32,     /* Max encoded CA basic constraint length */\n    MAX_SN_SZ           =  35,     /* Max encoded serial number (INT) length */\n    MAX_DER_DIGEST_SZ     = MAX_ENCODED_DIG_SZ + MAX_ALGO_SZ + MAX_SEQ_SZ,\n                            /* Maximum DER digest size */\n    MAX_DER_DIGEST_ASN_SZ = MAX_ENCODED_DIG_ASN_SZ + MAX_ALGO_SZ + MAX_SEQ_SZ,\n                            /* Maximum DER digest ASN header size */\n                            /* Max X509 header length indicates the max length + 2 ('\\n', '\\0') */\n    MAX_X509_HEADER_SZ  = (37 + 2), /* Maximum PEM Header/Footer Size */\n#ifdef WOLFSSL_CERT_GEN\n    #ifdef WOLFSSL_CERT_REQ\n                          /* Max encoded cert req attributes length */\n        MAX_ATTRIB_SZ   = MAX_SEQ_SZ * 3 + (11 + MAX_SEQ_SZ) * 2 +\n                          MAX_PRSTR_SZ + CTC_NAME_SIZE, /* 11 is the OID size */\n    #endif\n    #if defined(WOLFSSL_ALT_NAMES) || defined(WOLFSSL_CERT_EXT)\n        MAX_EXTENSIONS_SZ   = 1 + MAX_LENGTH_SZ + CTC_MAX_ALT_SIZE,\n    #else\n        MAX_EXTENSIONS_SZ   = 1 + MAX_LENGTH_SZ + MAX_CA_SZ,\n    #endif\n                                   /* Max total extensions, id + len + others */\n#endif\n#if defined(WOLFSSL_CERT_EXT) || defined(OPENSSL_EXTRA) || \\\n        defined(HAVE_PKCS7) || defined(OPENSSL_EXTRA_X509_SMALL)\n    MAX_OID_SZ          = 32,      /* Max DER length of OID*/\n    MAX_OID_STRING_SZ   = 64,      /* Max string length representation of OID*/\n#endif\n#ifdef WOLFSSL_CERT_EXT\n    MAX_KID_SZ          = 45,      /* Max encoded KID length (SHA-256 case) */\n    MAX_KEYUSAGE_SZ     = 18,      /* Max encoded Key Usage length */\n    MAX_EXTKEYUSAGE_SZ  = 12 + (6 * (8 + 2)) +\n                          CTC_MAX_EKU_OID_SZ, /* Max encoded ExtKeyUsage\n                          (SEQ/LEN + OBJID + OCTSTR/LEN + SEQ +\n                          (6 * (SEQ + OID))) */\n    MAX_CERTPOL_NB      = CTC_MAX_CERTPOL_NB,/* Max number of Cert Policy */\n    MAX_CERTPOL_SZ      = CTC_MAX_CERTPOL_SZ,\n#endif\n    MAX_AIA_SZ          = 2,       /* Max Authority Info Access extension size*/\n    OCSP_NONCE_EXT_SZ   = 35,      /* OCSP Nonce Extension size */\n    MAX_OCSP_EXT_SZ     = 58,      /* Max OCSP Extension length */\n    MAX_OCSP_NONCE_SZ   = 16,      /* OCSP Nonce size           */\n    EIGHTK_BUF          = 8192,    /* Tmp buffer size           */\n    MAX_PUBLIC_KEY_SZ   = MAX_NTRU_ENC_SZ + MAX_ALGO_SZ + MAX_SEQ_SZ * 2,\n                                   /* use bigger NTRU size */\n#ifdef WOLFSSL_ENCRYPTED_KEYS\n    HEADER_ENCRYPTED_KEY_SIZE = 88,/* Extra header size for encrypted key */\n#else\n    HEADER_ENCRYPTED_KEY_SIZE = 0,\n#endif\n    TRAILING_ZERO       = 1,       /* Used for size of zero pad */\n    ASN_TAG_SZ          = 1,       /* single byte ASN.1 tag */\n    MIN_VERSION_SZ      = 3,       /* Min bytes needed for GetMyVersion */\n    MAX_X509_VERSION    = 3,       /* Max X509 version allowed */\n    MIN_X509_VERSION    = 0,       /* Min X509 version allowed */\n    WOLFSSL_X509_V1     = 0,\n    WOLFSSL_X509_V2     = 1,\n    WOLFSSL_X509_V3     = 2,\n#if defined(OPENSSL_ALL)  || defined(WOLFSSL_MYSQL_COMPATIBLE) || \\\n    defined(WOLFSSL_NGINX) || defined(WOLFSSL_HAPROXY) || \\\n    defined(OPENSSL_EXTRA) || defined(HAVE_PKCS7)\n    MAX_TIME_STRING_SZ  = 25,      /* Max length of formatted time string */\n#endif\n\n    PKCS5_SALT_SZ       = 8,\n\n    PEM_LINE_SZ        = 64,               /* Length of Base64 encoded line, not including new line */\n    PEM_LINE_LEN       = PEM_LINE_SZ + 12, /* PEM line max + fudge */\n};\n\n#ifndef WC_MAX_NAME_ENTRIES\n    /* entries added to x509 name struct */\n    #define WC_MAX_NAME_ENTRIES 13\n#endif\n#define MAX_NAME_ENTRIES WC_MAX_NAME_ENTRIES\n\n\nenum Oid_Types {\n    oidHashType         = 0,\n    oidSigType          = 1,\n    oidKeyType          = 2,\n    oidCurveType        = 3,\n    oidBlkType          = 4,\n    oidOcspType         = 5,\n    oidCertExtType      = 6,\n    oidCertAuthInfoType = 7,\n    oidCertPolicyType   = 8,\n    oidCertAltNameType  = 9,\n    oidCertKeyUseType   = 10,\n    oidKdfType          = 11,\n    oidKeyWrapType      = 12,\n    oidCmsKeyAgreeType  = 13,\n    oidPBEType          = 14,\n    oidHmacType         = 15,\n    oidCompressType     = 16,\n    oidCertNameType     = 17,\n    oidTlsExtType       = 18,\n    oidCrlExtType       = 19,\n    oidCsrAttrType      = 20,\n    oidIgnoreType\n};\n\n\nenum Hash_Sum  {\n    MD2h      = 646,\n    MD5h      = 649,\n    SHAh      =  88,\n    SHA224h   = 417,\n    SHA256h   = 414,\n    SHA384h   = 415,\n    SHA512h   = 416,\n    SHA3_224h = 420,\n    SHA3_256h = 421,\n    SHA3_384h = 422,\n    SHA3_512h = 423\n};\n\n\n#if !defined(NO_DES3) || !defined(NO_AES)\nenum Block_Sum {\n#ifdef WOLFSSL_AES_128\n    AES128CBCb = 414,\n    AES128GCMb = 418,\n    AES128CCMb = 419,\n#endif\n#ifdef WOLFSSL_AES_192\n    AES192CBCb = 434,\n    AES192GCMb = 438,\n    AES192CCMb = 439,\n#endif\n#ifdef WOLFSSL_AES_256\n    AES256CBCb = 454,\n    AES256GCMb = 458,\n    AES256CCMb = 459,\n#endif\n#ifndef NO_DES3\n    DESb       = 69,\n    DES3b      = 652\n#endif\n};\n#endif /* !NO_DES3 || !NO_AES */\n\n\nenum Key_Sum {\n    DSAk     = 515,\n    RSAk     = 645,\n    NTRUk    = 274,\n    ECDSAk   = 518,\n    ED25519k = 256,\n    ED448k   = 257,\n    DHk      = 647, /* dhKeyAgreement OID: 1.2.840.113549.1.3.1 */\n};\n\n#if !defined(NO_AES) || defined(HAVE_PKCS7)\nenum KeyWrap_Sum {\n#ifdef WOLFSSL_AES_128\n    AES128_WRAP  = 417,\n#endif\n#ifdef WOLFSSL_AES_192\n    AES192_WRAP  = 437,\n#endif\n#ifdef WOLFSSL_AES_256\n    AES256_WRAP  = 457,\n#endif\n#ifdef HAVE_PKCS7\n    PWRI_KEK_WRAP = 680  /*id-alg-PWRI-KEK, 1.2.840.113549.1.9.16.3.9 */\n#endif\n};\n#endif /* !NO_AES || PKCS7 */\n\nenum Key_Agree {\n    dhSinglePass_stdDH_sha1kdf_scheme   = 464,\n    dhSinglePass_stdDH_sha224kdf_scheme = 188,\n    dhSinglePass_stdDH_sha256kdf_scheme = 189,\n    dhSinglePass_stdDH_sha384kdf_scheme = 190,\n    dhSinglePass_stdDH_sha512kdf_scheme = 191,\n};\n\n\n\nenum KDF_Sum {\n    PBKDF2_OID = 660\n};\n\n\nenum HMAC_Sum {\n    HMAC_SHA224_OID   = 652,\n    HMAC_SHA256_OID   = 653,\n    HMAC_SHA384_OID   = 654,\n    HMAC_SHA512_OID   = 655,\n    HMAC_SHA3_224_OID = 426,\n    HMAC_SHA3_256_OID = 427,\n    HMAC_SHA3_384_OID = 428,\n    HMAC_SHA3_512_OID = 429\n};\n\n\nenum Extensions_Sum {\n    BASIC_CA_OID    = 133,           /* 2.5.29.19 */\n    ALT_NAMES_OID   = 131,           /* 2.5.29.17 */\n    CRL_DIST_OID    = 145,           /* 2.5.29.31 */\n    AUTH_INFO_OID   = 69,            /* 1.3.6.1.5.5.7.1.1 */\n    AUTH_KEY_OID    = 149,           /* 2.5.29.35 */\n    SUBJ_KEY_OID    = 128,           /* 2.5.29.14 */\n    CERT_POLICY_OID = 146,           /* 2.5.29.32 */\n    KEY_USAGE_OID   = 129,           /* 2.5.29.15 */\n    INHIBIT_ANY_OID = 168,           /* 2.5.29.54 */\n    EXT_KEY_USAGE_OID         = 151, /* 2.5.29.37 */\n    NAME_CONS_OID             = 144, /* 2.5.29.30 */\n    PRIV_KEY_USAGE_PERIOD_OID = 130, /* 2.5.29.16 */\n    SUBJECT_INFO_ACCESS       = 79,  /* 1.3.6.1.5.5.7.1.11 */\n    POLICY_MAP_OID            = 147, /* 2.5.29.33 */\n    POLICY_CONST_OID          = 150, /* 2.5.29.36 */\n    ISSUE_ALT_NAMES_OID       = 132, /* 2.5.29.18 */\n    TLS_FEATURE_OID           = 92,  /* 1.3.6.1.5.5.7.1.24 */\n    NETSCAPE_CT_OID           = 753, /* 2.16.840.1.113730.1.1 */\n    OCSP_NOCHECK_OID          = 121  /* 1.3.6.1.5.5.7.48.1.5\n                                         id-pkix-ocsp-nocheck */\n};\n\nenum CertificatePolicy_Sum {\n    CP_ANY_OID      = 146  /* id-ce 32 0 */\n};\n\nenum SepHardwareName_Sum {\n    HW_NAME_OID     = 79   /* 1.3.6.1.5.5.7.8.4 from RFC 4108*/\n};\n\nenum AuthInfo_Sum {\n    AIA_OCSP_OID      = 116, /* 1.3.6.1.5.5.7.48.1 */\n    AIA_CA_ISSUER_OID = 117  /* 1.3.6.1.5.5.7.48.2 */\n};\n\nenum ExtKeyUsage_Sum { /* From RFC 5280 */\n    EKU_ANY_OID         = 151, /* 2.5.29.37.0, anyExtendedKeyUsage         */\n    EKU_SERVER_AUTH_OID = 71,  /* 1.3.6.1.5.5.7.3.1, id-kp-serverAuth      */\n    EKU_CLIENT_AUTH_OID = 72,  /* 1.3.6.1.5.5.7.3.2, id-kp-clientAuth      */\n    EKU_CODESIGNING_OID = 73,  /* 1.3.6.1.5.5.7.3.3, id-kp-codeSigning     */\n    EKU_EMAILPROTECT_OID = 74, /* 1.3.6.1.5.5.7.3.4, id-kp-emailProtection */\n    EKU_TIMESTAMP_OID   = 78,  /* 1.3.6.1.5.5.7.3.8, id-kp-timeStamping    */\n    EKU_OCSP_SIGN_OID   = 79   /* 1.3.6.1.5.5.7.3.9, id-kp-OCSPSigning     */\n};\n\n#ifdef HAVE_LIBZ\nenum CompressAlg_Sum {\n    ZLIBc = 679  /* 1.2.840.113549.1.9.16.3.8, id-alg-zlibCompress */\n};\n#endif\n\nenum VerifyType {\n    NO_VERIFY   = 0,\n    VERIFY      = 1,\n    VERIFY_CRL  = 2,\n    VERIFY_OCSP = 3,\n    VERIFY_NAME = 4,\n    VERIFY_SKIP_DATE = 5,\n    VERIFY_OCSP_CERT = 6,\n};\n\n#ifdef WOLFSSL_CERT_EXT\nenum KeyIdType {\n    SKID_TYPE = 0,\n    AKID_TYPE = 1\n};\n#endif\n\n#ifdef WOLFSSL_CERT_REQ\nenum CsrAttrType {\n    CHALLENGE_PASSWORD_OID = 659,\n    SERIAL_NUMBER_OID = 94,\n    EXTENSION_REQUEST_OID = 666,\n};\n#endif\n\n/* Key usage extension bits (based on RFC 5280) */\n#define KEYUSE_DIGITAL_SIG    0x0080\n#define KEYUSE_CONTENT_COMMIT 0x0040\n#define KEYUSE_KEY_ENCIPHER   0x0020\n#define KEYUSE_DATA_ENCIPHER  0x0010\n#define KEYUSE_KEY_AGREE      0x0008\n#define KEYUSE_KEY_CERT_SIGN  0x0004\n#define KEYUSE_CRL_SIGN       0x0002\n#define KEYUSE_ENCIPHER_ONLY  0x0001\n#define KEYUSE_DECIPHER_ONLY  0x8000\n\n/* Extended Key Usage bits (internal mapping only) */\n#define EXTKEYUSE_USER        0x80\n#define EXTKEYUSE_OCSP_SIGN   0x40\n#define EXTKEYUSE_TIMESTAMP   0x20\n#define EXTKEYUSE_EMAILPROT   0x10\n#define EXTKEYUSE_CODESIGN    0x08\n#define EXTKEYUSE_CLIENT_AUTH 0x04\n#define EXTKEYUSE_SERVER_AUTH 0x02\n#define EXTKEYUSE_ANY         0x01\n\ntypedef struct DNS_entry   DNS_entry;\n\nstruct DNS_entry {\n    DNS_entry* next;   /* next on DNS list */\n    int        type;   /* i.e. ASN_DNS_TYPE */\n    int        len;    /* actual DNS len */\n    char*      name;   /* actual DNS name */\n};\n\n\ntypedef struct Base_entry  Base_entry;\n\nstruct Base_entry {\n    Base_entry* next;   /* next on name base list */\n    char*       name;   /* actual name base */\n    int         nameSz; /* name length */\n    byte        type;   /* Name base type (DNS or RFC822) */\n};\n\n\nenum SignatureState {\n    SIG_STATE_BEGIN,\n    SIG_STATE_HASH,\n    SIG_STATE_KEY,\n    SIG_STATE_DO,\n    SIG_STATE_CHECK,\n};\n\n\n#ifdef HAVE_PK_CALLBACKS\n#ifdef HAVE_ECC\n    typedef int (*wc_CallbackEccVerify)(\n           const unsigned char* sig, unsigned int sigSz,\n           const unsigned char* hash, unsigned int hashSz,\n           const unsigned char* keyDer, unsigned int keySz,\n           int* result, void* ctx);\n#endif\n#ifndef NO_RSA\n    typedef int (*wc_CallbackRsaVerify)(\n           unsigned char* sig, unsigned int sigSz,\n           unsigned char** out,\n           const unsigned char* keyDer, unsigned int keySz,\n           void* ctx);\n#endif\n#endif /* HAVE_PK_CALLBACKS */\n\nstruct SignatureCtx {\n    void* heap;\n    byte* digest;\n#ifndef NO_RSA\n    byte* out;\n#endif\n#if !(defined(NO_RSA) && defined(NO_DSA))\n    byte* sigCpy;\n#endif\n#if defined(HAVE_ECC) || defined(HAVE_ED25519) || defined(HAVE_ED448) || \\\n    !defined(NO_DSA)\n    int verify;\n#endif\n    union {\n    #ifndef NO_RSA\n        struct RsaKey*      rsa;\n    #endif\n    #ifndef NO_DSA\n        struct DsaKey*      dsa;\n    #endif\n    #ifdef HAVE_ECC\n        struct ecc_key*     ecc;\n    #endif\n    #ifdef HAVE_ED25519\n        struct ed25519_key* ed25519;\n    #endif\n    #ifdef HAVE_ED448\n        struct ed448_key* ed448;\n    #endif\n        void* ptr;\n    } key;\n    int devId;\n    int state;\n    int typeH;\n    int digestSz;\n    word32 keyOID;\n#ifdef WOLFSSL_ASYNC_CRYPT\n    WC_ASYNC_DEV* asyncDev;\n    void* asyncCtx;\n#endif\n\n#ifdef HAVE_PK_CALLBACKS\n#ifdef HAVE_ECC\n    wc_CallbackEccVerify pkCbEcc;\n    void* pkCtxEcc;\n#endif\n#ifndef NO_RSA\n    wc_CallbackRsaVerify pkCbRsa;\n    void* pkCtxRsa;\n#endif\n#endif /* HAVE_PK_CALLBACKS */\n#ifndef NO_RSA\n#ifdef WOLFSSL_RENESAS_TSIP_TLS\n    byte verifyByTSIP;\n    word32 certBegin;\n    word32 pubkey_n_start;\n    word32 pubkey_n_len;\n    word32 pubkey_e_start;\n    word32 pubkey_e_len;\n#endif\n#endif\n};\n\nenum CertSignState {\n    CERTSIGN_STATE_BEGIN,\n    CERTSIGN_STATE_DIGEST,\n    CERTSIGN_STATE_ENCODE,\n    CERTSIGN_STATE_DO,\n};\n\nstruct CertSignCtx {\n    byte* sig;\n    byte* digest;\n    #ifndef NO_RSA\n        byte* encSig;\n        int encSigSz;\n    #endif\n    int state; /* enum CertSignState */\n};\n\n#ifndef WOLFSSL_MAX_PATH_LEN\n    /* RFC 5280 Section 6.1.2. \"Initialization\" - item (k) defines\n     *     (k)  max_path_length:  this integer is initialized to \"n\", is\n     *     decremented for each non-self-issued certificate in the path,\n     *     and may be reduced to the value in the path length constraint\n     *     field within the basic constraints extension of a CA\n     *     certificate.\n     *\n     * wolfSSL has arbitrarily selected the value 127 for \"n\" in the above\n     * description. Users can modify the maximum path length by setting\n     * WOLFSSL_MAX_PATH_LEN to a preferred value at build time\n     */\n    #define WOLFSSL_MAX_PATH_LEN 127\n#endif\n\ntypedef struct DecodedCert DecodedCert;\ntypedef struct Signer      Signer;\n#ifdef WOLFSSL_TRUST_PEER_CERT\ntypedef struct TrustedPeerCert TrustedPeerCert;\n#endif /* WOLFSSL_TRUST_PEER_CERT */\ntypedef struct SignatureCtx SignatureCtx;\ntypedef struct CertSignCtx  CertSignCtx;\n\n\nstruct DecodedCert {\n    const byte* publicKey;\n    word32  pubKeySize;\n    int     pubKeyStored;\n    word32  certBegin;               /* offset to start of cert          */\n    word32  sigIndex;                /* offset to start of signature     */\n    word32  sigLength;               /* length of signature              */\n    word32  signatureOID;            /* sum of algorithm object id       */\n    word32  keyOID;                  /* sum of key algo  object id       */\n    int     version;                 /* cert version, 1 or 3             */\n    DNS_entry* altNames;             /* alt names list of dns entries    */\n#ifndef IGNORE_NAME_CONSTRAINTS\n    DNS_entry* altEmailNames;        /* alt names list of RFC822 entries */\n    DNS_entry* altDirNames;          /* alt names list of DIR entries    */\n    Base_entry* permittedNames;      /* Permitted name bases             */\n    Base_entry* excludedNames;       /* Excluded name bases              */\n#endif /* IGNORE_NAME_CONSTRAINTS */\n    byte    subjectHash[KEYID_SIZE]; /* hash of all Names                */\n    byte    issuerHash[KEYID_SIZE];  /* hash of all Names                */\n#ifdef HAVE_OCSP\n    byte    subjectKeyHash[KEYID_SIZE]; /* hash of the public Key         */\n    byte    issuerKeyHash[KEYID_SIZE]; /* hash of the public Key         */\n#endif /* HAVE_OCSP */\n    const byte* signature;           /* not owned, points into raw cert  */\n    char*   subjectCN;               /* CommonName                       */\n    int     subjectCNLen;            /* CommonName Length                */\n    char    subjectCNEnc;            /* CommonName Encoding              */\n    char    issuer[ASN_NAME_MAX];    /* full name including common name  */\n    char    subject[ASN_NAME_MAX];   /* full name including common name  */\n    int     verify;                  /* Default to yes, but could be off */\n    const byte* source;              /* byte buffer holder cert, NOT owner */\n    word32  srcIdx;                  /* current offset into buffer       */\n    word32  maxIdx;                  /* max offset based on init size    */\n    void*   heap;                    /* for user memory overrides        */\n    byte    serial[EXTERNAL_SERIAL_SIZE];  /* raw serial number          */\n    int     serialSz;                /* raw serial bytes stored */\n    const byte* extensions;          /* not owned, points into raw cert  */\n    int     extensionsSz;            /* length of cert extensions */\n    word32  extensionsIdx;           /* if want to go back and parse later */\n    const byte* extAuthInfo;         /* Authority Information Access URI */\n    int     extAuthInfoSz;           /* length of the URI                */\n#if defined(OPENSSL_ALL) || defined(WOLFSSL_QT)\n    const byte* extAuthInfoCaIssuer; /* Authority Info Access caIssuer URI */\n    int     extAuthInfoCaIssuerSz;   /* length of the caIssuer URI         */\n#endif\n    const byte* extCrlInfo;          /* CRL Distribution Points          */\n    int     extCrlInfoSz;            /* length of the URI                */\n    byte    extSubjKeyId[KEYID_SIZE]; /* Subject Key ID                  */\n    byte    extAuthKeyId[KEYID_SIZE]; /* Authority Key ID                */\n    byte    pathLength;              /* CA basic constraint path length  */\n    byte    maxPathLen;              /* max_path_len see RFC 5280 section\n                                      * 6.1.2 \"Initialization\" - (k) for\n                                      * description of max_path_len */\n    byte    policyConstSkip;         /* Policy Constraints skip certs value */\n    word16  extKeyUsage;             /* Key usage bitfield               */\n    byte    extExtKeyUsage;          /* Extended Key usage bitfield      */\n\n#if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)\n    const byte* extExtKeyUsageSrc;\n    word32  extExtKeyUsageSz;\n    word32  extExtKeyUsageCount;\n    const byte* extAuthKeyIdSrc;\n    word32  extAuthKeyIdSz;\n    const byte* extSubjKeyIdSrc;\n    word32  extSubjKeyIdSz;\n#endif\n\n#if defined(HAVE_ECC) || defined(HAVE_ED25519) || defined(HAVE_ED448)\n    word32  pkCurveOID;           /* Public Key's curve OID */\n#endif /* HAVE_ECC */\n    const byte* beforeDate;\n    int     beforeDateLen;\n    const byte* afterDate;\n    int     afterDateLen;\n#if defined(HAVE_PKCS7) || defined(WOLFSSL_CERT_EXT)\n    const byte* issuerRaw;           /* pointer to issuer inside source */\n    int     issuerRawLen;\n#endif\n#if !defined(IGNORE_NAME_CONSTRAINTS) || defined(WOLFSSL_CERT_EXT)\n    const byte* subjectRaw;          /* pointer to subject inside source */\n    int     subjectRawLen;\n#endif\n#if defined(WOLFSSL_CERT_GEN) || defined(WOLFSSL_CERT_EXT)\n    /* easy access to subject info for other sign */\n    char*   subjectSN;\n    int     subjectSNLen;\n    char    subjectSNEnc;\n    char*   subjectC;\n    int     subjectCLen;\n    char    subjectCEnc;\n    char*   subjectL;\n    int     subjectLLen;\n    char    subjectLEnc;\n    char*   subjectST;\n    int     subjectSTLen;\n    char    subjectSTEnc;\n    char*   subjectO;\n    int     subjectOLen;\n    char    subjectOEnc;\n    char*   subjectOU;\n    int     subjectOULen;\n    char    subjectOUEnc;\n    char*   subjectSND;\n    int     subjectSNDLen;\n    char    subjectSNDEnc;\n#ifdef WOLFSSL_CERT_EXT\n    char*   subjectBC;\n    int     subjectBCLen;\n    char    subjectBCEnc;\n    char*   subjectJC;\n    int     subjectJCLen;\n    char    subjectJCEnc;\n    char*   subjectJS;\n    int     subjectJSLen;\n    char    subjectJSEnc;\n#endif\n    char*   subjectEmail;\n    int     subjectEmailLen;\n#endif /* WOLFSSL_CERT_GEN */\n#if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)\n    /* WOLFSSL_X509_NAME structures (used void* to avoid including ssl.h) */\n    void* issuerName;\n    void* subjectName;\n#endif /* OPENSSL_EXTRA */\n#ifdef WOLFSSL_SEP\n    int     deviceTypeSz;\n    byte*   deviceType;\n    int     hwTypeSz;\n    byte*   hwType;\n    int     hwSerialNumSz;\n    byte*   hwSerialNum;\n#endif /* WOLFSSL_SEP */\n#ifdef WOLFSSL_CERT_EXT\n    char    extCertPolicies[MAX_CERTPOL_NB][MAX_CERTPOL_SZ];\n    int     extCertPoliciesNb;\n#endif /* defined(WOLFSSL_CERT_GEN) || defined(WOLFSSL_CERT_EXT) */\n\n#ifdef WOLFSSL_CERT_REQ\n    /* CSR attributes */\n    char*   cPwd; /* challengePassword */\n    int     cPwdLen;\n    char*   sNum; /* Serial Number */\n    int     sNumLen;\n#endif /* WOLFSSL_CERT_REQ */\n\n    Signer* ca;\n#ifndef NO_CERTS\n    SignatureCtx sigCtx;\n#endif\n#ifdef WOLFSSL_RENESAS_TSIP\n    byte*  tsip_encRsaKeyIdx;\n#endif\n\n    int badDate;\n    int criticalExt;\n\n    /* Option Bits */\n    byte subjectCNStored : 1;      /* have we saved a copy we own */\n    byte extSubjKeyIdSet : 1;      /* Set when the SKID was read from cert */\n    byte extAuthKeyIdSet : 1;      /* Set when the AKID was read from cert */\n#ifndef IGNORE_NAME_CONSTRAINTS\n    byte extNameConstraintSet : 1;\n#endif\n    byte isCA : 1;                 /* CA basic constraint true */\n    byte pathLengthSet : 1;        /* CA basic const path length set */\n    byte weOwnAltNames : 1;        /* altNames haven't been given to copy */\n    byte extKeyUsageSet : 1;\n    byte extExtKeyUsageSet : 1;    /* Extended Key Usage set */\n#ifdef HAVE_OCSP\n    byte ocspNoCheckSet : 1;       /* id-pkix-ocsp-nocheck set */\n#endif\n    byte extCRLdistSet : 1;\n    byte extAuthInfoSet : 1;\n    byte extBasicConstSet : 1;\n    byte extPolicyConstSet : 1;\n    byte extPolicyConstRxpSet : 1; /* requireExplicitPolicy set */\n    byte extPolicyConstIpmSet : 1; /* inhibitPolicyMapping set */\n    byte extSubjAltNameSet : 1;\n    byte inhibitAnyOidSet : 1;\n    byte selfSigned : 1;           /* Indicates subject and issuer are same */\n#if defined(WOLFSSL_SEP) || defined(WOLFSSL_QT)\n    byte extCertPolicySet : 1;\n#endif\n#if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)\n    byte extCRLdistCrit : 1;\n    byte extAuthInfoCrit : 1;\n    byte extBasicConstCrit : 1;\n    byte extPolicyConstCrit : 1;\n    byte extSubjAltNameCrit : 1;\n    byte extAuthKeyIdCrit : 1;\n    #ifndef IGNORE_NAME_CONSTRAINTS\n        byte extNameConstraintCrit : 1;\n    #endif\n    byte extSubjKeyIdCrit : 1;\n    byte extKeyUsageCrit : 1;\n    byte extExtKeyUsageCrit : 1;\n#endif /* OPENSSL_EXTRA */\n#if defined(WOLFSSL_SEP) || defined(WOLFSSL_QT)\n    byte extCertPolicyCrit : 1;\n#endif\n#ifdef WOLFSSL_CERT_REQ\n    byte isCSR : 1;                /* Do we intend on parsing a CSR? */\n#endif\n};\n\n/* ASN Encoded Name field */\ntypedef struct EncodedName {\n    int  nameLen;                /* actual string value length */\n    int  totalLen;               /* total encoded length */\n    int  type;                   /* type of name */\n    int  used;                   /* are we actually using this one */\n    byte encoded[CTC_NAME_SIZE * 2]; /* encoding */\n} EncodedName;\n\n#ifdef NO_SHA\n    #define SIGNER_DIGEST_SIZE WC_SHA256_DIGEST_SIZE\n#else\n    #define SIGNER_DIGEST_SIZE WC_SHA_DIGEST_SIZE\n#endif\n\n/* CA Signers */\n/* if change layout change PERSIST_CERT_CACHE functions too */\nstruct Signer {\n    word32  pubKeySize;\n    word32  keyOID;                  /* key type */\n    word16  keyUsage;\n    byte    maxPathLen;\n    byte    pathLength;\n    byte    pathLengthSet : 1;\n    byte    selfSigned : 1;\n    const byte* publicKey;\n    int     nameLen;\n    char*   name;                    /* common name */\n#ifndef IGNORE_NAME_CONSTRAINTS\n        Base_entry* permittedNames;\n        Base_entry* excludedNames;\n#endif /* IGNORE_NAME_CONSTRAINTS */\n    byte    subjectNameHash[SIGNER_DIGEST_SIZE];\n                                     /* sha hash of names in certificate */\n    #ifndef NO_SKID\n        byte    subjectKeyIdHash[SIGNER_DIGEST_SIZE];\n                                     /* sha hash of names in certificate */\n    #endif\n    #ifdef HAVE_OCSP\n        byte subjectKeyHash[KEYID_SIZE];\n    #endif\n#ifdef WOLFSSL_SIGNER_DER_CERT\n    DerBuffer* derCert;\n#endif\n#ifdef WOLFSSL_RENESAS_TSIP_TLS\n    word32 cm_idx;\n#endif\n    Signer* next;\n};\n\n\n#ifdef WOLFSSL_TRUST_PEER_CERT\n/* used for having trusted peer certs rather then CA */\nstruct TrustedPeerCert {\n    int     nameLen;\n    char*   name;                    /* common name */\n    #ifndef IGNORE_NAME_CONSTRAINTS\n        Base_entry* permittedNames;\n        Base_entry* excludedNames;\n    #endif /* IGNORE_NAME_CONSTRAINTS */\n    byte    subjectNameHash[SIGNER_DIGEST_SIZE];\n                                     /* sha hash of names in certificate */\n    #ifndef NO_SKID\n        byte    subjectKeyIdHash[SIGNER_DIGEST_SIZE];\n                                     /* sha hash of names in certificate */\n    #endif\n    word32 sigLen;\n    byte*  sig;\n    struct TrustedPeerCert* next;\n};\n#endif /* WOLFSSL_TRUST_PEER_CERT */\n\n\n/* for testing or custom openssl wrappers */\n#if defined(WOLFSSL_TEST_CERT) || defined(OPENSSL_EXTRA) || \\\n    defined(OPENSSL_EXTRA_X509_SMALL)\n    #define WOLFSSL_ASN_API WOLFSSL_API\n#else\n    #define WOLFSSL_ASN_API WOLFSSL_LOCAL\n#endif\n\n#ifdef HAVE_SMIME\n#define MIME_HEADER_ASCII_MIN   33\n#define MIME_HEADER_ASCII_MAX   126\n\ntypedef struct MimeParam MimeParam;\ntypedef struct MimeHdr MimeHdr;\n\nstruct MimeParam\n{\n    MimeParam*  next;\n    char*       attribute;\n    char*       value;\n};\n\nstruct MimeHdr\n{\n    MimeHdr*    next;\n    MimeParam*  params;\n    char*       name;\n    char*       body;\n};\n\ntypedef enum MimeTypes\n{\n    MIME_HDR,\n    MIME_PARAM\n} MimeTypes;\n\ntypedef enum MimeStatus\n{\n    MIME_NAMEATTR,\n    MIME_BODYVAL\n} MimeStatus;\n#endif /* HAVE_SMIME */\n\n\nWOLFSSL_LOCAL int CalcHashId(const byte* data, word32 len, byte* hash);\nWOLFSSL_LOCAL int GetName(DecodedCert* cert, int nameType, int maxIdx);\n\nWOLFSSL_ASN_API int wc_BerToDer(const byte* ber, word32 berSz, byte* der,\n                                word32* derSz);\n\nWOLFSSL_ASN_API void FreeAltNames(DNS_entry*, void*);\n#ifndef IGNORE_NAME_CONSTRAINTS\n    WOLFSSL_ASN_API void FreeNameSubtrees(Base_entry*, void*);\n#endif /* IGNORE_NAME_CONSTRAINTS */\nWOLFSSL_ASN_API void InitDecodedCert(DecodedCert*, const byte*, word32, void*);\nWOLFSSL_ASN_API void FreeDecodedCert(DecodedCert*);\nWOLFSSL_ASN_API int  ParseCert(DecodedCert*, int type, int verify, void* cm);\n\nWOLFSSL_LOCAL int DecodePolicyOID(char *o, word32 oSz,\n                                  const byte *in, word32 inSz);\nWOLFSSL_LOCAL int EncodePolicyOID(byte *out, word32 *outSz,\n                                  const char *in, void* heap);\nWOLFSSL_API int CheckCertSignature(const byte*,word32,void*,void* cm);\nWOLFSSL_LOCAL int CheckCertSignaturePubKey(const byte* cert, word32 certSz,\n        void* heap, const byte* pubKey, word32 pubKeySz, int pubKeyOID);\n#ifdef WOLFSSL_CERT_REQ\nWOLFSSL_LOCAL int CheckCSRSignaturePubKey(const byte* cert, word32 certSz, void* heap,\n        const byte* pubKey, word32 pubKeySz, int pubKeyOID);\n#endif /* WOLFSSL_CERT_REQ */\nWOLFSSL_LOCAL int AddSignature(byte* buf, int bodySz, const byte* sig, int sigSz,\n                        int sigAlgoType);\nWOLFSSL_LOCAL int ParseCertRelative(DecodedCert*,int type,int verify,void* cm);\nWOLFSSL_LOCAL int DecodeToKey(DecodedCert*, int verify);\nWOLFSSL_LOCAL int wc_GetPubX509(DecodedCert* cert, int verify, int* badDate);\n\nWOLFSSL_LOCAL const byte* OidFromId(word32 id, word32 type, word32* oidSz);\nWOLFSSL_LOCAL Signer* MakeSigner(void*);\nWOLFSSL_LOCAL void    FreeSigner(Signer*, void*);\nWOLFSSL_LOCAL void    FreeSignerTable(Signer**, int, void*);\n#ifdef WOLFSSL_TRUST_PEER_CERT\nWOLFSSL_LOCAL void    FreeTrustedPeer(TrustedPeerCert*, void*);\nWOLFSSL_LOCAL void    FreeTrustedPeerTable(TrustedPeerCert**, int, void*);\n#endif /* WOLFSSL_TRUST_PEER_CERT */\n\nWOLFSSL_ASN_API int ToTraditional(byte* buffer, word32 length);\nWOLFSSL_ASN_API int ToTraditional_ex(byte* buffer, word32 length,\n                                     word32* algId);\nWOLFSSL_LOCAL int ToTraditionalInline(const byte* input, word32* inOutIdx,\n                                      word32 length);\nWOLFSSL_LOCAL int ToTraditionalInline_ex(const byte* input, word32* inOutIdx,\n                                         word32 length, word32* algId);\nWOLFSSL_LOCAL int ToTraditionalEnc(byte* buffer, word32 length,const char*,int,\n                                   word32* algId);\nWOLFSSL_ASN_API int UnTraditionalEnc(byte* key, word32 keySz, byte* out,\n        word32* outSz, const char* password, int passwordSz, int vPKCS,\n        int vAlgo, byte* salt, word32 saltSz, int itt, WC_RNG* rng, void* heap);\nWOLFSSL_ASN_API int TraditionalEnc(byte* key, word32 keySz, byte* out,\n        word32* outSz, const char* password, int passwordSz, int vPKCS,\n        int vAlgo, int encAlgId, byte* salt, word32 saltSz, int itt,\n        WC_RNG* rng, void* heap);\nWOLFSSL_LOCAL int DecryptContent(byte* input, word32 sz,const char* psw,int pswSz);\nWOLFSSL_LOCAL int EncryptContent(byte* input, word32 sz, byte* out, word32* outSz,\n        const char* password,int passwordSz, int vPKCS, int vAlgo,\n        byte* salt, word32 saltSz, int itt, WC_RNG* rng, void* heap);\nWOLFSSL_LOCAL int wc_GetKeyOID(byte* key, word32 keySz, const byte** curveOID,\n        word32* oidSz, int* algoID, void* heap);\n\ntypedef struct tm wolfssl_tm;\n#if defined(OPENSSL_ALL) || defined(WOLFSSL_MYSQL_COMPATIBLE) || defined(OPENSSL_EXTRA) || \\\n    defined(WOLFSSL_NGINX) || defined(WOLFSSL_HAPROXY)\nWOLFSSL_LOCAL int GetTimeString(byte* date, int format, char* buf, int len);\n#endif\n#if !defined(NO_ASN_TIME) && defined(HAVE_PKCS7)\nWOLFSSL_LOCAL int GetAsnTimeString(void* currTime, byte* buf, word32 len);\n#endif\nWOLFSSL_LOCAL int ExtractDate(const unsigned char* date, unsigned char format,\n                                                 wolfssl_tm* certTime, int* idx);\nWOLFSSL_LOCAL int DateGreaterThan(const struct tm* a, const struct tm* b);\nWOLFSSL_LOCAL int wc_ValidateDate(const byte* date, byte format, int dateType);\nWOLFSSL_LOCAL int wc_OBJ_sn2nid(const char *sn);\n\nWOLFSSL_LOCAL int wc_EncodeName(EncodedName* name, const char* nameStr,\n                                char nameType, byte type);\nWOLFSSL_LOCAL int wc_EncodeNameCanonical(EncodedName* name, const char* nameStr,\n                                char nameType, byte type);\n/* ASN.1 helper functions */\n#ifdef WOLFSSL_CERT_GEN\nWOLFSSL_ASN_API int SetName(byte* output, word32 outputSz, CertName* name);\nWOLFSSL_LOCAL const char* GetOneCertName(CertName* name, int idx);\nWOLFSSL_LOCAL byte GetCertNameId(int idx);\n#endif\nWOLFSSL_LOCAL int GetShortInt(const byte* input, word32* inOutIdx, int* number,\n                              word32 maxIdx);\nWOLFSSL_LOCAL int SetShortInt(byte* input, word32* inOutIdx, word32 number,\n                              word32 maxIdx);\n\nWOLFSSL_LOCAL const char* GetSigName(int oid);\nWOLFSSL_LOCAL int GetLength(const byte* input, word32* inOutIdx, int* len,\n                           word32 maxIdx);\nWOLFSSL_LOCAL int GetLength_ex(const byte* input, word32* inOutIdx, int* len,\n                           word32 maxIdx, int check);\nWOLFSSL_LOCAL int GetSequence(const byte* input, word32* inOutIdx, int* len,\n                             word32 maxIdx);\nWOLFSSL_LOCAL int GetSequence_ex(const byte* input, word32* inOutIdx, int* len,\n                           word32 maxIdx, int check);\nWOLFSSL_LOCAL int GetOctetString(const byte* input, word32* inOutIdx, int* len,\n                         word32 maxIdx);\nWOLFSSL_LOCAL int CheckBitString(const byte* input, word32* inOutIdx, int* len,\n                          word32 maxIdx, int zeroBits, byte* unusedBits);\nWOLFSSL_LOCAL int GetSet(const byte* input, word32* inOutIdx, int* len,\n                        word32 maxIdx);\nWOLFSSL_LOCAL int GetSet_ex(const byte* input, word32* inOutIdx, int* len,\n                        word32 maxIdx, int check);\nWOLFSSL_LOCAL int GetMyVersion(const byte* input, word32* inOutIdx,\n                              int* version, word32 maxIdx);\nWOLFSSL_LOCAL int GetInt(mp_int* mpi, const byte* input, word32* inOutIdx,\n                        word32 maxIdx);\n#ifdef HAVE_OID_ENCODING\n    WOLFSSL_LOCAL int EncodeObjectId(const word16* in, word32 inSz,\n        byte* out, word32* outSz);\n#endif\n#ifdef HAVE_OID_DECODING\n    WOLFSSL_LOCAL int DecodeObjectId(const byte* in, word32 inSz,\n        word16* out, word32* outSz);\n#endif\nWOLFSSL_LOCAL int GetASNObjectId(const byte* input, word32* inOutIdx, int* len,\n                                 word32 maxIdx);\nWOLFSSL_LOCAL int SetObjectId(int len, byte* output);\nWOLFSSL_LOCAL int GetObjectId(const byte* input, word32* inOutIdx, word32* oid,\n                              word32 oidType, word32 maxIdx);\nWOLFSSL_LOCAL int GetAlgoId(const byte* input, word32* inOutIdx, word32* oid,\n                           word32 oidType, word32 maxIdx);\nWOLFSSL_LOCAL int GetASNTag(const byte* input, word32* idx, byte* tag,\n                            word32 inputSz);\nWOLFSSL_LOCAL word32 SetLength(word32 length, byte* output);\nWOLFSSL_LOCAL word32 SetSequence(word32 len, byte* output);\nWOLFSSL_LOCAL word32 SetOctetString(word32 len, byte* output);\nWOLFSSL_LOCAL int SetASNInt(int len, byte firstByte, byte* output);\nWOLFSSL_LOCAL word32 SetBitString(word32 len, byte unusedBits, byte* output);\nWOLFSSL_LOCAL word32 SetImplicit(byte tag,byte number,word32 len,byte* output);\nWOLFSSL_LOCAL word32 SetExplicit(byte number, word32 len, byte* output);\nWOLFSSL_LOCAL word32 SetSet(word32 len, byte* output);\nWOLFSSL_LOCAL word32 SetAlgoID(int algoOID,byte* output,int type,int curveSz);\nWOLFSSL_LOCAL int SetMyVersion(word32 version, byte* output, int header);\nWOLFSSL_LOCAL int SetSerialNumber(const byte* sn, word32 snSz, byte* output,\n    word32 outputSz, int maxSnSz);\nWOLFSSL_LOCAL int GetSerialNumber(const byte* input, word32* inOutIdx,\n    byte* serial, int* serialSz, word32 maxIdx);\nWOLFSSL_LOCAL int GetNameHash(const byte* source, word32* idx, byte* hash,\n                             int maxIdx);\nWOLFSSL_LOCAL int wc_CheckPrivateKeyCert(const byte* key, word32 keySz, DecodedCert* der);\nWOLFSSL_LOCAL int wc_CheckPrivateKey(const byte* privKey, word32 privKeySz,\n                                     const byte* pubKey, word32 pubKeySz, enum Key_Sum ks);\nWOLFSSL_LOCAL int StoreDHparams(byte* out, word32* outLen, mp_int* p, mp_int* g);\nWOLFSSL_LOCAL int FlattenAltNames( byte*, word32, const DNS_entry*);\n\n#ifdef HAVE_ECC\n    /* ASN sig helpers */\n    WOLFSSL_LOCAL int StoreECC_DSA_Sig(byte* out, word32* outLen, mp_int* r,\n                                      mp_int* s);\n    WOLFSSL_LOCAL int StoreECC_DSA_Sig_Bin(byte* out, word32* outLen, \n        const byte* r, word32 rLen, const byte* s, word32 sLen);\n    WOLFSSL_LOCAL int DecodeECC_DSA_Sig_Bin(const byte* sig, word32 sigLen, \n        byte* r, word32* rLen, byte* s, word32* sLen);\n#endif\n#if defined(HAVE_ECC) || !defined(NO_DSA)\n    WOLFSSL_LOCAL int DecodeECC_DSA_Sig(const byte* sig, word32 sigLen,\n                                       mp_int* r, mp_int* s);\n#endif\n#if defined HAVE_ECC && (defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL))\nWOLFSSL_API int EccEnumToNID(int n);\n#endif\n\nWOLFSSL_LOCAL void InitSignatureCtx(SignatureCtx* sigCtx, void* heap, int devId);\nWOLFSSL_LOCAL void FreeSignatureCtx(SignatureCtx* sigCtx);\n\n#ifndef NO_CERTS\n\nWOLFSSL_LOCAL int wc_EncryptedInfoParse(EncryptedInfo* info,\n                                        const char** pBuffer, size_t bufSz);\n\nWOLFSSL_LOCAL int PemToDer(const unsigned char* buff, long sz, int type,\n                          DerBuffer** pDer, void* heap, EncryptedInfo* info,\n                          int* eccKey);\nWOLFSSL_LOCAL int AllocDer(DerBuffer** der, word32 length, int type, void* heap);\nWOLFSSL_LOCAL void FreeDer(DerBuffer** der);\n\n#endif /* !NO_CERTS */\n\n#ifdef HAVE_SMIME\nWOLFSSL_LOCAL int wc_MIME_parse_headers(char* in, int inLen, MimeHdr** hdrs);\nWOLFSSL_LOCAL int wc_MIME_header_strip(char* in, char** out, size_t start, size_t end);\nWOLFSSL_LOCAL int wc_MIME_create_header(char* name, char* body, MimeHdr** hdr);\nWOLFSSL_LOCAL int wc_MIME_create_parameter(char* attribute, char* value, MimeParam** param);\nWOLFSSL_LOCAL MimeHdr* wc_MIME_find_header_name(const char* name, MimeHdr* hdr);\nWOLFSSL_LOCAL MimeParam* wc_MIME_find_param_attr(const char* attribute, MimeParam* param);\nWOLFSSL_LOCAL char* wc_MIME_canonicalize(const char* line);\nWOLFSSL_LOCAL int wc_MIME_free_hdrs(MimeHdr* head);\n#endif /* HAVE_SMIME */\n\n#ifdef WOLFSSL_CERT_GEN\n\nenum cert_enums {\n#ifdef WOLFSSL_CERT_EXT\n    NAME_ENTRIES    =  10,\n#else\n    NAME_ENTRIES    =  9,\n#endif\n    JOINT_LEN       =  2,\n    EMAIL_JOINT_LEN =  9,\n    PILOT_JOINT_LEN =  10,\n    RSA_KEY         = 10,\n    NTRU_KEY        = 11,\n    ECC_KEY         = 12,\n    ED25519_KEY     = 13,\n    ED448_KEY       = 14,\n    DSA_KEY         = 15\n};\n\n#endif /* WOLFSSL_CERT_GEN */\n\n\n\n/* for pointer use */\ntypedef struct CertStatus CertStatus;\n\n#ifdef HAVE_OCSP\n\nenum Ocsp_Response_Status {\n    OCSP_SUCCESSFUL        = 0, /* Response has valid confirmations */\n    OCSP_MALFORMED_REQUEST = 1, /* Illegal confirmation request */\n    OCSP_INTERNAL_ERROR    = 2, /* Internal error in issuer */\n    OCSP_TRY_LATER         = 3, /* Try again later */\n    OCSP_SIG_REQUIRED      = 5, /* Must sign the request (4 is skipped) */\n    OCSP_UNAUTHROIZED      = 6  /* Request unauthorized */\n};\n\n\nenum Ocsp_Cert_Status {\n    CERT_GOOD    = 0,\n    CERT_REVOKED = 1,\n    CERT_UNKNOWN = 2\n};\n\n\nenum Ocsp_Sums {\n    OCSP_BASIC_OID = 117,\n    OCSP_NONCE_OID = 118\n};\n\n#ifdef OPENSSL_EXTRA\nenum Ocsp_Verify_Error {\n    OCSP_VERIFY_ERROR_NONE = 0,\n    OCSP_BAD_ISSUER = 1\n};\n#endif\n\n\ntypedef struct OcspRequest  OcspRequest;\ntypedef struct OcspResponse OcspResponse;\n\n\nstruct CertStatus {\n    CertStatus* next;\n\n    byte serial[EXTERNAL_SERIAL_SIZE];\n    int serialSz;\n#ifdef OPENSSL_EXTRA\n    WOLFSSL_ASN1_INTEGER* serialInt;\n#endif\n\n    int status;\n\n    byte thisDate[MAX_DATE_SIZE];\n    byte nextDate[MAX_DATE_SIZE];\n    byte thisDateFormat;\n    byte nextDateFormat;\n#if defined(OPENSSL_ALL) || defined(WOLFSSL_NGINX) || defined(WOLFSSL_HAPROXY) || defined(HAVE_LIGHTY)\n    WOLFSSL_ASN1_TIME thisDateParsed;\n    WOLFSSL_ASN1_TIME nextDateParsed;\n    byte* thisDateAsn;\n    byte* nextDateAsn;\n#endif\n\n    byte*  rawOcspResponse;\n    word32 rawOcspResponseSz;\n};\n\ntypedef struct OcspEntry OcspEntry;\n\n#ifdef NO_SHA\n#define OCSP_DIGEST_SIZE WC_SHA256_DIGEST_SIZE\n#else\n#define OCSP_DIGEST_SIZE WC_SHA_DIGEST_SIZE\n#endif\n\nstruct OcspEntry\n{\n    OcspEntry *next;                      /* next entry                */\n    word32 hashAlgoOID;                   /* hash algo ID              */\n    byte issuerHash[OCSP_DIGEST_SIZE];    /* issuer hash               */\n    byte issuerKeyHash[OCSP_DIGEST_SIZE]; /* issuer public key hash    */\n    CertStatus *status;                   /* OCSP response list        */\n    int totalStatus;                      /* number on list            */\n    byte* rawCertId;                      /* raw bytes of the CertID   */\n    int rawCertIdSize;                    /* num bytes in raw CertID   */\n    /* option bits - using 32-bit for alignment */\n    word32 ownStatus:1;                   /* do we need to free the status\n                                           * response list */\n    word32 isDynamic:1;                   /* was dynamically allocated */\n\n};\n\n/* TODO: Long-term, it would be helpful if we made this struct and other OCSP\n         structs conform to the ASN spec as described in RFC 6960. It will help\n         with readability and with implementing OpenSSL compatibility API\n         functions, because OpenSSL's OCSP data structures conform to the\n         RFC. */\nstruct OcspResponse {\n    int     responseStatus;  /* return code from Responder */\n\n    byte*   response;        /* Pointer to beginning of OCSP Response */\n    word32  responseSz;      /* length of the OCSP Response */\n\n    byte    producedDate[MAX_DATE_SIZE];\n                             /* Date at which this response was signed */\n    byte    producedDateFormat; /* format of the producedDate */\n\n    byte*   cert;\n    word32  certSz;\n\n    byte*   sig;             /* Pointer to sig in source */\n    word32  sigSz;           /* Length in octets for the sig */\n    word32  sigOID;          /* OID for hash used for sig */\n\n    OcspEntry* single;       /* chain of OCSP single responses */\n\n    byte*   nonce;           /* pointer to nonce inside ASN.1 response */\n    int     nonceSz;         /* length of the nonce string */\n\n    byte*   source;          /* pointer to source buffer, not owned */\n    word32  maxIdx;          /* max offset based on init size */\n\n#ifdef OPENSSL_EXTRA\n    int     verifyError;\n#endif\n    void*  heap;\n};\n\n\nstruct OcspRequest {\n    byte   issuerHash[KEYID_SIZE];\n    byte   issuerKeyHash[KEYID_SIZE];\n    byte*  serial;   /* copy of the serial number in source cert */\n    int    serialSz;\n#ifdef OPENSSL_EXTRA\n    WOLFSSL_ASN1_INTEGER* serialInt;\n#endif\n    byte*  url;      /* copy of the extAuthInfo in source cert */\n    int    urlSz;\n\n    byte   nonce[MAX_OCSP_NONCE_SZ];\n    int    nonceSz;\n    void*  heap;\n    void*  ssl;\n};\n\nWOLFSSL_LOCAL void InitOcspResponse(OcspResponse*, OcspEntry*, CertStatus*, byte*, word32, void*);\nWOLFSSL_LOCAL void FreeOcspResponse(OcspResponse*);\nWOLFSSL_LOCAL int OcspResponseDecode(OcspResponse*, void*, void* heap, int);\n\nWOLFSSL_LOCAL int    InitOcspRequest(OcspRequest*, DecodedCert*, byte, void*);\nWOLFSSL_LOCAL void   FreeOcspRequest(OcspRequest*);\nWOLFSSL_LOCAL int    EncodeOcspRequest(OcspRequest*, byte*, word32);\nWOLFSSL_LOCAL word32 EncodeOcspRequestExtensions(OcspRequest*, byte*, word32);\n\n\nWOLFSSL_LOCAL int  CompareOcspReqResp(OcspRequest*, OcspResponse*);\n\n\n#endif /* HAVE_OCSP */\n\n\n/* for pointer use */\ntypedef struct RevokedCert RevokedCert;\n\n#ifdef HAVE_CRL\n\nstruct RevokedCert {\n    byte         serialNumber[EXTERNAL_SERIAL_SIZE];\n    int          serialSz;\n    RevokedCert* next;\n};\n\ntypedef struct DecodedCRL DecodedCRL;\n\nstruct DecodedCRL {\n    word32  certBegin;               /* offset to start of cert          */\n    word32  sigIndex;                /* offset to start of signature     */\n    word32  sigLength;               /* length of signature              */\n    word32  signatureOID;            /* sum of algorithm object id       */\n    byte*   signature;               /* pointer into raw source, not owned */\n    byte    issuerHash[SIGNER_DIGEST_SIZE]; /* issuer name hash          */\n    byte    crlHash[SIGNER_DIGEST_SIZE]; /* raw crl data hash            */\n    byte    lastDate[MAX_DATE_SIZE]; /* last date updated  */\n    byte    nextDate[MAX_DATE_SIZE]; /* next update date   */\n    byte    lastDateFormat;          /* format of last date */\n    byte    nextDateFormat;          /* format of next date */\n    RevokedCert* certs;              /* revoked cert list  */\n    int          totalCerts;         /* number on list     */\n    void*   heap;\n#ifndef NO_SKID\n    byte    extAuthKeyIdSet;\n    byte    extAuthKeyId[SIGNER_DIGEST_SIZE]; /* Authority Key ID        */\n#endif\n};\n\nWOLFSSL_LOCAL void InitDecodedCRL(DecodedCRL*, void* heap);\nWOLFSSL_LOCAL int VerifyCRL_Signature(SignatureCtx* sigCtx,\n                                      const byte* toBeSigned, word32 tbsSz,\n                                      const byte* signature, word32 sigSz,\n                                      word32 signatureOID, Signer *ca,\n                                      void* heap);\nWOLFSSL_LOCAL int  ParseCRL(DecodedCRL*, const byte* buff, word32 sz, void* cm);\nWOLFSSL_LOCAL void FreeDecodedCRL(DecodedCRL*);\n\n\n#endif /* HAVE_CRL */\n\n\n#ifdef __cplusplus\n    } /* extern \"C\" */\n#endif\n\n#endif /* !NO_ASN */\n\n\n#if !defined(NO_ASN) || !defined(NO_PWDBASED)\n\n#ifndef MAX_KEY_SIZE\n    #define MAX_KEY_SIZE    64  /* MAX PKCS Key length */\n#endif\n#ifndef MAX_UNICODE_SZ\n    #define MAX_UNICODE_SZ  256\n#endif\n\nenum PBESTypes {\n    PBE_MD5_DES        = 0,\n    PBE_SHA1_RC4_128   = 1,\n    PBE_SHA1_DES       = 2,\n    PBE_SHA1_DES3      = 3,\n    PBE_AES256_CBC     = 4,\n    PBE_AES128_CBC     = 5,\n    PBE_SHA1_40RC2_CBC = 6,\n\n    PBE_SHA1_RC4_128_SUM = 657,\n    PBE_SHA1_DES3_SUM    = 659,\n    PBES2            = 13       /* algo ID */\n};\n\nenum PKCSTypes {\n    PKCS5v2             =   6,     /* PKCS #5 v2.0 */\n    PKCS12v1            =  12,     /* PKCS #12 */\n    PKCS5               =   5,     /* PKCS oid tag */\n    PKCS8v0             =   0,     /* default PKCS#8 version */\n};\n\n#endif /* !NO_ASN || !NO_PWDBASED */\n\n#endif /* WOLF_CRYPT_ASN_H */\n"], "filenames": ["wolfcrypt/src/asn.c", "wolfssl/wolfcrypt/asn.h"], "buggy_code_start_loc": [10215, 601], "buggy_code_end_loc": [17961, 601], "fixing_code_start_loc": [10215, 602], "fixing_code_end_loc": [17965, 603], "type": "CWE-345", "message": "wolfSSL before 4.8.1 incorrectly skips OCSP verification in certain situations of irrelevant response data that contains the NoCheck extension.", "other": {"cve": {"id": "CVE-2021-38597", "sourceIdentifier": "cve@mitre.org", "published": "2021-08-12T15:15:08.017", "lastModified": "2021-08-23T14:07:03.670", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "wolfSSL before 4.8.1 incorrectly skips OCSP verification in certain situations of irrelevant response data that contains the NoCheck extension."}, {"lang": "es", "value": "wolfSSL versiones anteriores a 4.8.1, omite incorrectamente la comprobaci\u00f3n OCSP en determinadas situaciones de datos de respuesta irrelevantes que contienen la extensi\u00f3n NoCheck"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.2, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-345"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:wolfssl:wolfssl:*:*:*:*:*:*:*:*", "versionEndExcluding": "4.8.1", "matchCriteriaId": "27F00BE2-7CD4-4CCC-B5FC-DE9C8389D98D"}]}]}], "references": [{"url": "https://github.com/wolfSSL/wolfssl/commit/f93083be72a3b3d956b52a7ec13f307a27b6e093", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.wolfssl.com/docs/wolfssl-changelog/", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/wolfSSL/wolfssl/commit/f93083be72a3b3d956b52a7ec13f307a27b6e093"}}