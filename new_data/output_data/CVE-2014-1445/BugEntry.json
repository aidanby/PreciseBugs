{"buggy_code": ["/*\n * wanXL serial card driver for Linux\n * host part\n *\n * Copyright (C) 2003 Krzysztof Halasa <khc@pm.waw.pl>\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of version 2 of the GNU General Public License\n * as published by the Free Software Foundation.\n *\n * Status:\n *   - Only DTE (external clock) support with NRZ and NRZI encodings\n *   - wanXL100 will require minor driver modifications, no access to hw\n */\n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/netdevice.h>\n#include <linux/hdlc.h>\n#include <linux/pci.h>\n#include <linux/dma-mapping.h>\n#include <linux/delay.h>\n#include <asm/io.h>\n\n#include \"wanxl.h\"\n\nstatic const char* version = \"wanXL serial card driver version: 0.48\";\n\n#define PLX_CTL_RESET   0x40000000 /* adapter reset */\n\n#undef DEBUG_PKT\n#undef DEBUG_PCI\n\n/* MAILBOX #1 - PUTS COMMANDS */\n#define MBX1_CMD_ABORTJ 0x85000000 /* Abort and Jump */\n#ifdef __LITTLE_ENDIAN\n#define MBX1_CMD_BSWAP  0x8C000001 /* little-endian Byte Swap Mode */\n#else\n#define MBX1_CMD_BSWAP  0x8C000000 /* big-endian Byte Swap Mode */\n#endif\n\n/* MAILBOX #2 - DRAM SIZE */\n#define MBX2_MEMSZ_MASK 0xFFFF0000 /* PUTS Memory Size Register mask */\n\n\ntypedef struct {\n\tstruct net_device *dev;\n\tstruct card_t *card;\n\tspinlock_t lock;\t/* for wanxl_xmit */\n        int node;\t\t/* physical port #0 - 3 */\n\tunsigned int clock_type;\n\tint tx_in, tx_out;\n\tstruct sk_buff *tx_skbs[TX_BUFFERS];\n}port_t;\n\n\ntypedef struct {\n\tdesc_t rx_descs[RX_QUEUE_LENGTH];\n\tport_status_t port_status[4];\n}card_status_t;\n\n\ntypedef struct card_t {\n\tint n_ports;\t\t/* 1, 2 or 4 ports */\n\tu8 irq;\n\n\tu8 __iomem *plx;\t/* PLX PCI9060 virtual base address */\n\tstruct pci_dev *pdev;\t/* for pci_name(pdev) */\n\tint rx_in;\n\tstruct sk_buff *rx_skbs[RX_QUEUE_LENGTH];\n\tcard_status_t *status;\t/* shared between host and card */\n\tdma_addr_t status_address;\n\tport_t ports[0];\t/* 1 - 4 port_t structures follow */\n}card_t;\n\n\n\nstatic inline port_t* dev_to_port(struct net_device *dev)\n{\n        return (port_t *)dev_to_hdlc(dev)->priv;\n}\n\n\nstatic inline port_status_t* get_status(port_t *port)\n{\n\treturn &port->card->status->port_status[port->node];\n}\n\n\n#ifdef DEBUG_PCI\nstatic inline dma_addr_t pci_map_single_debug(struct pci_dev *pdev, void *ptr,\n\t\t\t\t\t      size_t size, int direction)\n{\n\tdma_addr_t addr = pci_map_single(pdev, ptr, size, direction);\n\tif (addr + size > 0x100000000LL)\n\t\tpr_crit(\"%s: pci_map_single() returned memory at 0x%llx!\\n\",\n\t\t\tpci_name(pdev), (unsigned long long)addr);\n\treturn addr;\n}\n\n#undef pci_map_single\n#define pci_map_single pci_map_single_debug\n#endif\n\n\n/* Cable and/or personality module change interrupt service */\nstatic inline void wanxl_cable_intr(port_t *port)\n{\n\tu32 value = get_status(port)->cable;\n\tint valid = 1;\n\tconst char *cable, *pm, *dte = \"\", *dsr = \"\", *dcd = \"\";\n\n\tswitch(value & 0x7) {\n\tcase STATUS_CABLE_V35: cable = \"V.35\"; break;\n\tcase STATUS_CABLE_X21: cable = \"X.21\"; break;\n\tcase STATUS_CABLE_V24: cable = \"V.24\"; break;\n\tcase STATUS_CABLE_EIA530: cable = \"EIA530\"; break;\n\tcase STATUS_CABLE_NONE: cable = \"no\"; break;\n\tdefault: cable = \"invalid\";\n\t}\n\n\tswitch((value >> STATUS_CABLE_PM_SHIFT) & 0x7) {\n\tcase STATUS_CABLE_V35: pm = \"V.35\"; break;\n\tcase STATUS_CABLE_X21: pm = \"X.21\"; break;\n\tcase STATUS_CABLE_V24: pm = \"V.24\"; break;\n\tcase STATUS_CABLE_EIA530: pm = \"EIA530\"; break;\n\tcase STATUS_CABLE_NONE: pm = \"no personality\"; valid = 0; break;\n\tdefault: pm = \"invalid personality\"; valid = 0;\n\t}\n\n\tif (valid) {\n\t\tif ((value & 7) == ((value >> STATUS_CABLE_PM_SHIFT) & 7)) {\n\t\t\tdsr = (value & STATUS_CABLE_DSR) ? \", DSR ON\" :\n\t\t\t\t\", DSR off\";\n\t\t\tdcd = (value & STATUS_CABLE_DCD) ? \", carrier ON\" :\n\t\t\t\t\", carrier off\";\n\t\t}\n\t\tdte = (value & STATUS_CABLE_DCE) ? \" DCE\" : \" DTE\";\n\t}\n\tnetdev_info(port->dev, \"%s%s module, %s cable%s%s\\n\",\n\t\t    pm, dte, cable, dsr, dcd);\n\n\tif (value & STATUS_CABLE_DCD)\n\t\tnetif_carrier_on(port->dev);\n\telse\n\t\tnetif_carrier_off(port->dev);\n}\n\n\n\n/* Transmit complete interrupt service */\nstatic inline void wanxl_tx_intr(port_t *port)\n{\n\tstruct net_device *dev = port->dev;\n\twhile (1) {\n                desc_t *desc = &get_status(port)->tx_descs[port->tx_in];\n\t\tstruct sk_buff *skb = port->tx_skbs[port->tx_in];\n\n\t\tswitch (desc->stat) {\n\t\tcase PACKET_FULL:\n\t\tcase PACKET_EMPTY:\n\t\t\tnetif_wake_queue(dev);\n\t\t\treturn;\n\n\t\tcase PACKET_UNDERRUN:\n\t\t\tdev->stats.tx_errors++;\n\t\t\tdev->stats.tx_fifo_errors++;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tdev->stats.tx_packets++;\n\t\t\tdev->stats.tx_bytes += skb->len;\n\t\t}\n                desc->stat = PACKET_EMPTY; /* Free descriptor */\n\t\tpci_unmap_single(port->card->pdev, desc->address, skb->len,\n\t\t\t\t PCI_DMA_TODEVICE);\n\t\tdev_kfree_skb_irq(skb);\n                port->tx_in = (port->tx_in + 1) % TX_BUFFERS;\n        }\n}\n\n\n\n/* Receive complete interrupt service */\nstatic inline void wanxl_rx_intr(card_t *card)\n{\n\tdesc_t *desc;\n\twhile (desc = &card->status->rx_descs[card->rx_in],\n\t       desc->stat != PACKET_EMPTY) {\n\t\tif ((desc->stat & PACKET_PORT_MASK) > card->n_ports)\n\t\t\tpr_crit(\"%s: received packet for nonexistent port\\n\",\n\t\t\t\tpci_name(card->pdev));\n\t\telse {\n\t\t\tstruct sk_buff *skb = card->rx_skbs[card->rx_in];\n\t\t\tport_t *port = &card->ports[desc->stat &\n\t\t\t\t\t\t    PACKET_PORT_MASK];\n\t\t\tstruct net_device *dev = port->dev;\n\n\t\t\tif (!skb)\n\t\t\t\tdev->stats.rx_dropped++;\n\t\t\telse {\n\t\t\t\tpci_unmap_single(card->pdev, desc->address,\n\t\t\t\t\t\t BUFFER_LENGTH,\n\t\t\t\t\t\t PCI_DMA_FROMDEVICE);\n\t\t\t\tskb_put(skb, desc->length);\n\n#ifdef DEBUG_PKT\n\t\t\t\tprintk(KERN_DEBUG \"%s RX(%i):\", dev->name,\n\t\t\t\t       skb->len);\n\t\t\t\tdebug_frame(skb);\n#endif\n\t\t\t\tdev->stats.rx_packets++;\n\t\t\t\tdev->stats.rx_bytes += skb->len;\n\t\t\t\tskb->protocol = hdlc_type_trans(skb, dev);\n\t\t\t\tnetif_rx(skb);\n\t\t\t\tskb = NULL;\n\t\t\t}\n\n\t\t\tif (!skb) {\n\t\t\t\tskb = dev_alloc_skb(BUFFER_LENGTH);\n\t\t\t\tdesc->address = skb ?\n\t\t\t\t\tpci_map_single(card->pdev, skb->data,\n\t\t\t\t\t\t       BUFFER_LENGTH,\n\t\t\t\t\t\t       PCI_DMA_FROMDEVICE) : 0;\n\t\t\t\tcard->rx_skbs[card->rx_in] = skb;\n\t\t\t}\n\t\t}\n\t\tdesc->stat = PACKET_EMPTY; /* Free descriptor */\n\t\tcard->rx_in = (card->rx_in + 1) % RX_QUEUE_LENGTH;\n\t}\n}\n\n\n\nstatic irqreturn_t wanxl_intr(int irq, void* dev_id)\n{\n        card_t *card = dev_id;\n        int i;\n        u32 stat;\n        int handled = 0;\n\n\n        while((stat = readl(card->plx + PLX_DOORBELL_FROM_CARD)) != 0) {\n                handled = 1;\n\t\twritel(stat, card->plx + PLX_DOORBELL_FROM_CARD);\n\n                for (i = 0; i < card->n_ports; i++) {\n\t\t\tif (stat & (1 << (DOORBELL_FROM_CARD_TX_0 + i)))\n\t\t\t\twanxl_tx_intr(&card->ports[i]);\n\t\t\tif (stat & (1 << (DOORBELL_FROM_CARD_CABLE_0 + i)))\n\t\t\t\twanxl_cable_intr(&card->ports[i]);\n\t\t}\n\t\tif (stat & (1 << DOORBELL_FROM_CARD_RX))\n\t\t\twanxl_rx_intr(card);\n        }\n\n        return IRQ_RETVAL(handled);\n}\n\n\n\nstatic netdev_tx_t wanxl_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n        port_t *port = dev_to_port(dev);\n\tdesc_t *desc;\n\n        spin_lock(&port->lock);\n\n\tdesc = &get_status(port)->tx_descs[port->tx_out];\n        if (desc->stat != PACKET_EMPTY) {\n                /* should never happen - previous xmit should stop queue */\n#ifdef DEBUG_PKT\n                printk(KERN_DEBUG \"%s: transmitter buffer full\\n\", dev->name);\n#endif\n\t\tnetif_stop_queue(dev);\n\t\tspin_unlock(&port->lock);\n\t\treturn NETDEV_TX_BUSY;       /* request packet to be queued */\n\t}\n\n#ifdef DEBUG_PKT\n\tprintk(KERN_DEBUG \"%s TX(%i):\", dev->name, skb->len);\n\tdebug_frame(skb);\n#endif\n\n\tport->tx_skbs[port->tx_out] = skb;\n\tdesc->address = pci_map_single(port->card->pdev, skb->data, skb->len,\n\t\t\t\t       PCI_DMA_TODEVICE);\n\tdesc->length = skb->len;\n\tdesc->stat = PACKET_FULL;\n\twritel(1 << (DOORBELL_TO_CARD_TX_0 + port->node),\n\t       port->card->plx + PLX_DOORBELL_TO_CARD);\n\n\tport->tx_out = (port->tx_out + 1) % TX_BUFFERS;\n\n\tif (get_status(port)->tx_descs[port->tx_out].stat != PACKET_EMPTY) {\n\t\tnetif_stop_queue(dev);\n#ifdef DEBUG_PKT\n\t\tprintk(KERN_DEBUG \"%s: transmitter buffer full\\n\", dev->name);\n#endif\n\t}\n\n\tspin_unlock(&port->lock);\n\treturn NETDEV_TX_OK;\n}\n\n\n\nstatic int wanxl_attach(struct net_device *dev, unsigned short encoding,\n\t\t\tunsigned short parity)\n{\n\tport_t *port = dev_to_port(dev);\n\n\tif (encoding != ENCODING_NRZ &&\n\t    encoding != ENCODING_NRZI)\n\t\treturn -EINVAL;\n\n\tif (parity != PARITY_NONE &&\n\t    parity != PARITY_CRC32_PR1_CCITT &&\n\t    parity != PARITY_CRC16_PR1_CCITT &&\n\t    parity != PARITY_CRC32_PR0_CCITT &&\n\t    parity != PARITY_CRC16_PR0_CCITT)\n\t\treturn -EINVAL;\n\n\tget_status(port)->encoding = encoding;\n\tget_status(port)->parity = parity;\n\treturn 0;\n}\n\n\n\nstatic int wanxl_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)\n{\n\tconst size_t size = sizeof(sync_serial_settings);\n\tsync_serial_settings line;\n\tport_t *port = dev_to_port(dev);\n\n\tif (cmd != SIOCWANDEV)\n\t\treturn hdlc_ioctl(dev, ifr, cmd);\n\n\tswitch (ifr->ifr_settings.type) {\n\tcase IF_GET_IFACE:\n\t\tifr->ifr_settings.type = IF_IFACE_SYNC_SERIAL;\n\t\tif (ifr->ifr_settings.size < size) {\n\t\t\tifr->ifr_settings.size = size; /* data size wanted */\n\t\t\treturn -ENOBUFS;\n\t\t}\n\t\tline.clock_type = get_status(port)->clocking;\n\t\tline.clock_rate = 0;\n\t\tline.loopback = 0;\n\n\t\tif (copy_to_user(ifr->ifr_settings.ifs_ifsu.sync, &line, size))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\n\tcase IF_IFACE_SYNC_SERIAL:\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\t\tif (dev->flags & IFF_UP)\n\t\t\treturn -EBUSY;\n\n\t\tif (copy_from_user(&line, ifr->ifr_settings.ifs_ifsu.sync,\n\t\t\t\t   size))\n\t\t\treturn -EFAULT;\n\n\t\tif (line.clock_type != CLOCK_EXT &&\n\t\t    line.clock_type != CLOCK_TXFROMRX)\n\t\t\treturn -EINVAL; /* No such clock setting */\n\n\t\tif (line.loopback != 0)\n\t\t\treturn -EINVAL;\n\n\t\tget_status(port)->clocking = line.clock_type;\n\t\treturn 0;\n\n\tdefault:\n\t\treturn hdlc_ioctl(dev, ifr, cmd);\n        }\n}\n\n\n\nstatic int wanxl_open(struct net_device *dev)\n{\n\tport_t *port = dev_to_port(dev);\n\tu8 __iomem *dbr = port->card->plx + PLX_DOORBELL_TO_CARD;\n\tunsigned long timeout;\n\tint i;\n\n\tif (get_status(port)->open) {\n\t\tnetdev_err(dev, \"port already open\\n\");\n\t\treturn -EIO;\n\t}\n\tif ((i = hdlc_open(dev)) != 0)\n\t\treturn i;\n\n\tport->tx_in = port->tx_out = 0;\n\tfor (i = 0; i < TX_BUFFERS; i++)\n\t\tget_status(port)->tx_descs[i].stat = PACKET_EMPTY;\n\t/* signal the card */\n\twritel(1 << (DOORBELL_TO_CARD_OPEN_0 + port->node), dbr);\n\n\ttimeout = jiffies + HZ;\n\tdo {\n\t\tif (get_status(port)->open) {\n\t\t\tnetif_start_queue(dev);\n\t\t\treturn 0;\n\t\t}\n\t} while (time_after(timeout, jiffies));\n\n\tnetdev_err(dev, \"unable to open port\\n\");\n\t/* ask the card to close the port, should it be still alive */\n\twritel(1 << (DOORBELL_TO_CARD_CLOSE_0 + port->node), dbr);\n\treturn -EFAULT;\n}\n\n\n\nstatic int wanxl_close(struct net_device *dev)\n{\n\tport_t *port = dev_to_port(dev);\n\tunsigned long timeout;\n\tint i;\n\n\thdlc_close(dev);\n\t/* signal the card */\n\twritel(1 << (DOORBELL_TO_CARD_CLOSE_0 + port->node),\n\t       port->card->plx + PLX_DOORBELL_TO_CARD);\n\n\ttimeout = jiffies + HZ;\n\tdo {\n\t\tif (!get_status(port)->open)\n\t\t\tbreak;\n\t} while (time_after(timeout, jiffies));\n\n\tif (get_status(port)->open)\n\t\tnetdev_err(dev, \"unable to close port\\n\");\n\n\tnetif_stop_queue(dev);\n\n\tfor (i = 0; i < TX_BUFFERS; i++) {\n\t\tdesc_t *desc = &get_status(port)->tx_descs[i];\n\n\t\tif (desc->stat != PACKET_EMPTY) {\n\t\t\tdesc->stat = PACKET_EMPTY;\n\t\t\tpci_unmap_single(port->card->pdev, desc->address,\n\t\t\t\t\t port->tx_skbs[i]->len,\n\t\t\t\t\t PCI_DMA_TODEVICE);\n\t\t\tdev_kfree_skb(port->tx_skbs[i]);\n\t\t}\n\t}\n\treturn 0;\n}\n\n\n\nstatic struct net_device_stats *wanxl_get_stats(struct net_device *dev)\n{\n\tport_t *port = dev_to_port(dev);\n\n\tdev->stats.rx_over_errors = get_status(port)->rx_overruns;\n\tdev->stats.rx_frame_errors = get_status(port)->rx_frame_errors;\n\tdev->stats.rx_errors = dev->stats.rx_over_errors +\n\t\tdev->stats.rx_frame_errors;\n\treturn &dev->stats;\n}\n\n\n\nstatic int wanxl_puts_command(card_t *card, u32 cmd)\n{\n\tunsigned long timeout = jiffies + 5 * HZ;\n\n\twritel(cmd, card->plx + PLX_MAILBOX_1);\n\tdo {\n\t\tif (readl(card->plx + PLX_MAILBOX_1) == 0)\n\t\t\treturn 0;\n\n\t\tschedule();\n\t}while (time_after(timeout, jiffies));\n\n\treturn -1;\n}\n\n\n\nstatic void wanxl_reset(card_t *card)\n{\n\tu32 old_value = readl(card->plx + PLX_CONTROL) & ~PLX_CTL_RESET;\n\n\twritel(0x80, card->plx + PLX_MAILBOX_0);\n\twritel(old_value | PLX_CTL_RESET, card->plx + PLX_CONTROL);\n\treadl(card->plx + PLX_CONTROL); /* wait for posted write */\n\tudelay(1);\n\twritel(old_value, card->plx + PLX_CONTROL);\n\treadl(card->plx + PLX_CONTROL); /* wait for posted write */\n}\n\n\n\nstatic void wanxl_pci_remove_one(struct pci_dev *pdev)\n{\n\tcard_t *card = pci_get_drvdata(pdev);\n\tint i;\n\n\tfor (i = 0; i < card->n_ports; i++) {\n\t\tunregister_hdlc_device(card->ports[i].dev);\n\t\tfree_netdev(card->ports[i].dev);\n\t}\n\n\t/* unregister and free all host resources */\n\tif (card->irq)\n\t\tfree_irq(card->irq, card);\n\n\twanxl_reset(card);\n\n\tfor (i = 0; i < RX_QUEUE_LENGTH; i++)\n\t\tif (card->rx_skbs[i]) {\n\t\t\tpci_unmap_single(card->pdev,\n\t\t\t\t\t card->status->rx_descs[i].address,\n\t\t\t\t\t BUFFER_LENGTH, PCI_DMA_FROMDEVICE);\n\t\t\tdev_kfree_skb(card->rx_skbs[i]);\n\t\t}\n\n\tif (card->plx)\n\t\tiounmap(card->plx);\n\n\tif (card->status)\n\t\tpci_free_consistent(pdev, sizeof(card_status_t),\n\t\t\t\t    card->status, card->status_address);\n\n\tpci_release_regions(pdev);\n\tpci_disable_device(pdev);\n\tpci_set_drvdata(pdev, NULL);\n\tkfree(card);\n}\n\n\n#include \"wanxlfw.inc\"\n\nstatic const struct net_device_ops wanxl_ops = {\n\t.ndo_open       = wanxl_open,\n\t.ndo_stop       = wanxl_close,\n\t.ndo_change_mtu = hdlc_change_mtu,\n\t.ndo_start_xmit = hdlc_start_xmit,\n\t.ndo_do_ioctl   = wanxl_ioctl,\n\t.ndo_get_stats  = wanxl_get_stats,\n};\n\nstatic int wanxl_pci_init_one(struct pci_dev *pdev,\n\t\t\t      const struct pci_device_id *ent)\n{\n\tcard_t *card;\n\tu32 ramsize, stat;\n\tunsigned long timeout;\n\tu32 plx_phy;\t\t/* PLX PCI base address */\n\tu32 mem_phy;\t\t/* memory PCI base addr */\n\tu8 __iomem *mem;\t/* memory virtual base addr */\n\tint i, ports, alloc_size;\n\n#ifndef MODULE\n\tpr_info_once(\"%s\\n\", version);\n#endif\n\n\ti = pci_enable_device(pdev);\n\tif (i)\n\t\treturn i;\n\n\t/* QUICC can only access first 256 MB of host RAM directly,\n\t   but PLX9060 DMA does 32-bits for actual packet data transfers */\n\n\t/* FIXME when PCI/DMA subsystems are fixed.\n\t   We set both dma_mask and consistent_dma_mask to 28 bits\n\t   and pray pci_alloc_consistent() will use this info. It should\n\t   work on most platforms */\n\tif (pci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(28)) ||\n\t    pci_set_dma_mask(pdev, DMA_BIT_MASK(28))) {\n\t\tpr_err(\"No usable DMA configuration\\n\");\n\t\treturn -EIO;\n\t}\n\n\ti = pci_request_regions(pdev, \"wanXL\");\n\tif (i) {\n\t\tpci_disable_device(pdev);\n\t\treturn i;\n\t}\n\n\tswitch (pdev->device) {\n\tcase PCI_DEVICE_ID_SBE_WANXL100: ports = 1; break;\n\tcase PCI_DEVICE_ID_SBE_WANXL200: ports = 2; break;\n\tdefault: ports = 4;\n\t}\n\n\talloc_size = sizeof(card_t) + ports * sizeof(port_t);\n\tcard = kzalloc(alloc_size, GFP_KERNEL);\n\tif (card == NULL) {\n\t\tpci_release_regions(pdev);\n\t\tpci_disable_device(pdev);\n\t\treturn -ENOBUFS;\n\t}\n\n\tpci_set_drvdata(pdev, card);\n\tcard->pdev = pdev;\n\n\tcard->status = pci_alloc_consistent(pdev, sizeof(card_status_t),\n\t\t\t\t\t    &card->status_address);\n\tif (card->status == NULL) {\n\t\twanxl_pci_remove_one(pdev);\n\t\treturn -ENOBUFS;\n\t}\n\n#ifdef DEBUG_PCI\n\tprintk(KERN_DEBUG \"wanXL %s: pci_alloc_consistent() returned memory\"\n\t       \" at 0x%LX\\n\", pci_name(pdev),\n\t       (unsigned long long)card->status_address);\n#endif\n\n\t/* FIXME when PCI/DMA subsystems are fixed.\n\t   We set both dma_mask and consistent_dma_mask back to 32 bits\n\t   to indicate the card can do 32-bit DMA addressing */\n\tif (pci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(32)) ||\n\t    pci_set_dma_mask(pdev, DMA_BIT_MASK(32))) {\n\t\tpr_err(\"No usable DMA configuration\\n\");\n\t\twanxl_pci_remove_one(pdev);\n\t\treturn -EIO;\n\t}\n\n\t/* set up PLX mapping */\n\tplx_phy = pci_resource_start(pdev, 0);\n\n\tcard->plx = ioremap_nocache(plx_phy, 0x70);\n\tif (!card->plx) {\n\t\tpr_err(\"ioremap() failed\\n\");\n \t\twanxl_pci_remove_one(pdev);\n\t\treturn -EFAULT;\n\t}\n\n#if RESET_WHILE_LOADING\n\twanxl_reset(card);\n#endif\n\n\ttimeout = jiffies + 20 * HZ;\n\twhile ((stat = readl(card->plx + PLX_MAILBOX_0)) != 0) {\n\t\tif (time_before(timeout, jiffies)) {\n\t\t\tpr_warn(\"%s: timeout waiting for PUTS to complete\\n\",\n\t\t\t\tpci_name(pdev));\n\t\t\twanxl_pci_remove_one(pdev);\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\tswitch(stat & 0xC0) {\n\t\tcase 0x00:\t/* hmm - PUTS completed with non-zero code? */\n\t\tcase 0x80:\t/* PUTS still testing the hardware */\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tpr_warn(\"%s: PUTS test 0x%X failed\\n\",\n\t\t\t\tpci_name(pdev), stat & 0x30);\n\t\t\twanxl_pci_remove_one(pdev);\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\tschedule();\n\t}\n\n\t/* get on-board memory size (PUTS detects no more than 4 MB) */\n\tramsize = readl(card->plx + PLX_MAILBOX_2) & MBX2_MEMSZ_MASK;\n\n\t/* set up on-board RAM mapping */\n\tmem_phy = pci_resource_start(pdev, 2);\n\n\n\t/* sanity check the board's reported memory size */\n\tif (ramsize < BUFFERS_ADDR +\n\t    (TX_BUFFERS + RX_BUFFERS) * BUFFER_LENGTH * ports) {\n\t\tpr_warn(\"%s: no enough on-board RAM (%u bytes detected, %u bytes required)\\n\",\n\t\t\tpci_name(pdev), ramsize,\n\t\t\tBUFFERS_ADDR +\n\t\t\t(TX_BUFFERS + RX_BUFFERS) * BUFFER_LENGTH * ports);\n\t\twanxl_pci_remove_one(pdev);\n\t\treturn -ENODEV;\n\t}\n\n\tif (wanxl_puts_command(card, MBX1_CMD_BSWAP)) {\n\t\tpr_warn(\"%s: unable to Set Byte Swap Mode\\n\", pci_name(pdev));\n\t\twanxl_pci_remove_one(pdev);\n\t\treturn -ENODEV;\n\t}\n\n\tfor (i = 0; i < RX_QUEUE_LENGTH; i++) {\n\t\tstruct sk_buff *skb = dev_alloc_skb(BUFFER_LENGTH);\n\t\tcard->rx_skbs[i] = skb;\n\t\tif (skb)\n\t\t\tcard->status->rx_descs[i].address =\n\t\t\t\tpci_map_single(card->pdev, skb->data,\n\t\t\t\t\t       BUFFER_LENGTH,\n\t\t\t\t\t       PCI_DMA_FROMDEVICE);\n\t}\n\n\tmem = ioremap_nocache(mem_phy, PDM_OFFSET + sizeof(firmware));\n\tif (!mem) {\n\t\tpr_err(\"ioremap() failed\\n\");\n \t\twanxl_pci_remove_one(pdev);\n\t\treturn -EFAULT;\n\t}\n\n\tfor (i = 0; i < sizeof(firmware); i += 4)\n\t\twritel(ntohl(*(__be32*)(firmware + i)), mem + PDM_OFFSET + i);\n\n\tfor (i = 0; i < ports; i++)\n\t\twritel(card->status_address +\n\t\t       (void *)&card->status->port_status[i] -\n\t\t       (void *)card->status, mem + PDM_OFFSET + 4 + i * 4);\n\twritel(card->status_address, mem + PDM_OFFSET + 20);\n\twritel(PDM_OFFSET, mem);\n\tiounmap(mem);\n\n\twritel(0, card->plx + PLX_MAILBOX_5);\n\n\tif (wanxl_puts_command(card, MBX1_CMD_ABORTJ)) {\n\t\tpr_warn(\"%s: unable to Abort and Jump\\n\", pci_name(pdev));\n\t\twanxl_pci_remove_one(pdev);\n\t\treturn -ENODEV;\n\t}\n\n\tstat = 0;\n\ttimeout = jiffies + 5 * HZ;\n\tdo {\n\t\tif ((stat = readl(card->plx + PLX_MAILBOX_5)) != 0)\n\t\t\tbreak;\n\t\tschedule();\n\t}while (time_after(timeout, jiffies));\n\n\tif (!stat) {\n\t\tpr_warn(\"%s: timeout while initializing card firmware\\n\",\n\t\t\tpci_name(pdev));\n\t\twanxl_pci_remove_one(pdev);\n\t\treturn -ENODEV;\n\t}\n\n#if DETECT_RAM\n\tramsize = stat;\n#endif\n\n\tpr_info(\"%s: at 0x%X, %u KB of RAM at 0x%X, irq %u\\n\",\n\t\tpci_name(pdev), plx_phy, ramsize / 1024, mem_phy, pdev->irq);\n\n\t/* Allocate IRQ */\n\tif (request_irq(pdev->irq, wanxl_intr, IRQF_SHARED, \"wanXL\", card)) {\n\t\tpr_warn(\"%s: could not allocate IRQ%i\\n\",\n\t\t\tpci_name(pdev), pdev->irq);\n\t\twanxl_pci_remove_one(pdev);\n\t\treturn -EBUSY;\n\t}\n\tcard->irq = pdev->irq;\n\n\tfor (i = 0; i < ports; i++) {\n\t\thdlc_device *hdlc;\n\t\tport_t *port = &card->ports[i];\n\t\tstruct net_device *dev = alloc_hdlcdev(port);\n\t\tif (!dev) {\n\t\t\tpr_err(\"%s: unable to allocate memory\\n\",\n\t\t\t       pci_name(pdev));\n\t\t\twanxl_pci_remove_one(pdev);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tport->dev = dev;\n\t\thdlc = dev_to_hdlc(dev);\n\t\tspin_lock_init(&port->lock);\n\t\tdev->tx_queue_len = 50;\n\t\tdev->netdev_ops = &wanxl_ops;\n\t\thdlc->attach = wanxl_attach;\n\t\thdlc->xmit = wanxl_xmit;\n\t\tport->card = card;\n\t\tport->node = i;\n\t\tget_status(port)->clocking = CLOCK_EXT;\n\t\tif (register_hdlc_device(dev)) {\n\t\t\tpr_err(\"%s: unable to register hdlc device\\n\",\n\t\t\t       pci_name(pdev));\n\t\t\tfree_netdev(dev);\n\t\t\twanxl_pci_remove_one(pdev);\n\t\t\treturn -ENOBUFS;\n\t\t}\n\t\tcard->n_ports++;\n\t}\n\n\tpr_info(\"%s: port\", pci_name(pdev));\n\tfor (i = 0; i < ports; i++)\n\t\tpr_cont(\"%s #%i: %s\",\n\t\t\ti ? \",\" : \"\", i, card->ports[i].dev->name);\n\tpr_cont(\"\\n\");\n\n\tfor (i = 0; i < ports; i++)\n\t\twanxl_cable_intr(&card->ports[i]); /* get carrier status etc.*/\n\n\treturn 0;\n}\n\nstatic DEFINE_PCI_DEVICE_TABLE(wanxl_pci_tbl) = {\n\t{ PCI_VENDOR_ID_SBE, PCI_DEVICE_ID_SBE_WANXL100, PCI_ANY_ID,\n\t  PCI_ANY_ID, 0, 0, 0 },\n\t{ PCI_VENDOR_ID_SBE, PCI_DEVICE_ID_SBE_WANXL200, PCI_ANY_ID,\n\t  PCI_ANY_ID, 0, 0, 0 },\n\t{ PCI_VENDOR_ID_SBE, PCI_DEVICE_ID_SBE_WANXL400, PCI_ANY_ID,\n\t  PCI_ANY_ID, 0, 0, 0 },\n\t{ 0, }\n};\n\n\nstatic struct pci_driver wanxl_pci_driver = {\n\t.name\t\t= \"wanXL\",\n\t.id_table\t= wanxl_pci_tbl,\n\t.probe\t\t= wanxl_pci_init_one,\n\t.remove\t\t= wanxl_pci_remove_one,\n};\n\n\nstatic int __init wanxl_init_module(void)\n{\n#ifdef MODULE\n\tpr_info(\"%s\\n\", version);\n#endif\n\treturn pci_register_driver(&wanxl_pci_driver);\n}\n\nstatic void __exit wanxl_cleanup_module(void)\n{\n\tpci_unregister_driver(&wanxl_pci_driver);\n}\n\n\nMODULE_AUTHOR(\"Krzysztof Halasa <khc@pm.waw.pl>\");\nMODULE_DESCRIPTION(\"SBE Inc. wanXL serial port driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DEVICE_TABLE(pci, wanxl_pci_tbl);\n\nmodule_init(wanxl_init_module);\nmodule_exit(wanxl_cleanup_module);\n"], "fixing_code": ["/*\n * wanXL serial card driver for Linux\n * host part\n *\n * Copyright (C) 2003 Krzysztof Halasa <khc@pm.waw.pl>\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of version 2 of the GNU General Public License\n * as published by the Free Software Foundation.\n *\n * Status:\n *   - Only DTE (external clock) support with NRZ and NRZI encodings\n *   - wanXL100 will require minor driver modifications, no access to hw\n */\n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/netdevice.h>\n#include <linux/hdlc.h>\n#include <linux/pci.h>\n#include <linux/dma-mapping.h>\n#include <linux/delay.h>\n#include <asm/io.h>\n\n#include \"wanxl.h\"\n\nstatic const char* version = \"wanXL serial card driver version: 0.48\";\n\n#define PLX_CTL_RESET   0x40000000 /* adapter reset */\n\n#undef DEBUG_PKT\n#undef DEBUG_PCI\n\n/* MAILBOX #1 - PUTS COMMANDS */\n#define MBX1_CMD_ABORTJ 0x85000000 /* Abort and Jump */\n#ifdef __LITTLE_ENDIAN\n#define MBX1_CMD_BSWAP  0x8C000001 /* little-endian Byte Swap Mode */\n#else\n#define MBX1_CMD_BSWAP  0x8C000000 /* big-endian Byte Swap Mode */\n#endif\n\n/* MAILBOX #2 - DRAM SIZE */\n#define MBX2_MEMSZ_MASK 0xFFFF0000 /* PUTS Memory Size Register mask */\n\n\ntypedef struct {\n\tstruct net_device *dev;\n\tstruct card_t *card;\n\tspinlock_t lock;\t/* for wanxl_xmit */\n        int node;\t\t/* physical port #0 - 3 */\n\tunsigned int clock_type;\n\tint tx_in, tx_out;\n\tstruct sk_buff *tx_skbs[TX_BUFFERS];\n}port_t;\n\n\ntypedef struct {\n\tdesc_t rx_descs[RX_QUEUE_LENGTH];\n\tport_status_t port_status[4];\n}card_status_t;\n\n\ntypedef struct card_t {\n\tint n_ports;\t\t/* 1, 2 or 4 ports */\n\tu8 irq;\n\n\tu8 __iomem *plx;\t/* PLX PCI9060 virtual base address */\n\tstruct pci_dev *pdev;\t/* for pci_name(pdev) */\n\tint rx_in;\n\tstruct sk_buff *rx_skbs[RX_QUEUE_LENGTH];\n\tcard_status_t *status;\t/* shared between host and card */\n\tdma_addr_t status_address;\n\tport_t ports[0];\t/* 1 - 4 port_t structures follow */\n}card_t;\n\n\n\nstatic inline port_t* dev_to_port(struct net_device *dev)\n{\n        return (port_t *)dev_to_hdlc(dev)->priv;\n}\n\n\nstatic inline port_status_t* get_status(port_t *port)\n{\n\treturn &port->card->status->port_status[port->node];\n}\n\n\n#ifdef DEBUG_PCI\nstatic inline dma_addr_t pci_map_single_debug(struct pci_dev *pdev, void *ptr,\n\t\t\t\t\t      size_t size, int direction)\n{\n\tdma_addr_t addr = pci_map_single(pdev, ptr, size, direction);\n\tif (addr + size > 0x100000000LL)\n\t\tpr_crit(\"%s: pci_map_single() returned memory at 0x%llx!\\n\",\n\t\t\tpci_name(pdev), (unsigned long long)addr);\n\treturn addr;\n}\n\n#undef pci_map_single\n#define pci_map_single pci_map_single_debug\n#endif\n\n\n/* Cable and/or personality module change interrupt service */\nstatic inline void wanxl_cable_intr(port_t *port)\n{\n\tu32 value = get_status(port)->cable;\n\tint valid = 1;\n\tconst char *cable, *pm, *dte = \"\", *dsr = \"\", *dcd = \"\";\n\n\tswitch(value & 0x7) {\n\tcase STATUS_CABLE_V35: cable = \"V.35\"; break;\n\tcase STATUS_CABLE_X21: cable = \"X.21\"; break;\n\tcase STATUS_CABLE_V24: cable = \"V.24\"; break;\n\tcase STATUS_CABLE_EIA530: cable = \"EIA530\"; break;\n\tcase STATUS_CABLE_NONE: cable = \"no\"; break;\n\tdefault: cable = \"invalid\";\n\t}\n\n\tswitch((value >> STATUS_CABLE_PM_SHIFT) & 0x7) {\n\tcase STATUS_CABLE_V35: pm = \"V.35\"; break;\n\tcase STATUS_CABLE_X21: pm = \"X.21\"; break;\n\tcase STATUS_CABLE_V24: pm = \"V.24\"; break;\n\tcase STATUS_CABLE_EIA530: pm = \"EIA530\"; break;\n\tcase STATUS_CABLE_NONE: pm = \"no personality\"; valid = 0; break;\n\tdefault: pm = \"invalid personality\"; valid = 0;\n\t}\n\n\tif (valid) {\n\t\tif ((value & 7) == ((value >> STATUS_CABLE_PM_SHIFT) & 7)) {\n\t\t\tdsr = (value & STATUS_CABLE_DSR) ? \", DSR ON\" :\n\t\t\t\t\", DSR off\";\n\t\t\tdcd = (value & STATUS_CABLE_DCD) ? \", carrier ON\" :\n\t\t\t\t\", carrier off\";\n\t\t}\n\t\tdte = (value & STATUS_CABLE_DCE) ? \" DCE\" : \" DTE\";\n\t}\n\tnetdev_info(port->dev, \"%s%s module, %s cable%s%s\\n\",\n\t\t    pm, dte, cable, dsr, dcd);\n\n\tif (value & STATUS_CABLE_DCD)\n\t\tnetif_carrier_on(port->dev);\n\telse\n\t\tnetif_carrier_off(port->dev);\n}\n\n\n\n/* Transmit complete interrupt service */\nstatic inline void wanxl_tx_intr(port_t *port)\n{\n\tstruct net_device *dev = port->dev;\n\twhile (1) {\n                desc_t *desc = &get_status(port)->tx_descs[port->tx_in];\n\t\tstruct sk_buff *skb = port->tx_skbs[port->tx_in];\n\n\t\tswitch (desc->stat) {\n\t\tcase PACKET_FULL:\n\t\tcase PACKET_EMPTY:\n\t\t\tnetif_wake_queue(dev);\n\t\t\treturn;\n\n\t\tcase PACKET_UNDERRUN:\n\t\t\tdev->stats.tx_errors++;\n\t\t\tdev->stats.tx_fifo_errors++;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tdev->stats.tx_packets++;\n\t\t\tdev->stats.tx_bytes += skb->len;\n\t\t}\n                desc->stat = PACKET_EMPTY; /* Free descriptor */\n\t\tpci_unmap_single(port->card->pdev, desc->address, skb->len,\n\t\t\t\t PCI_DMA_TODEVICE);\n\t\tdev_kfree_skb_irq(skb);\n                port->tx_in = (port->tx_in + 1) % TX_BUFFERS;\n        }\n}\n\n\n\n/* Receive complete interrupt service */\nstatic inline void wanxl_rx_intr(card_t *card)\n{\n\tdesc_t *desc;\n\twhile (desc = &card->status->rx_descs[card->rx_in],\n\t       desc->stat != PACKET_EMPTY) {\n\t\tif ((desc->stat & PACKET_PORT_MASK) > card->n_ports)\n\t\t\tpr_crit(\"%s: received packet for nonexistent port\\n\",\n\t\t\t\tpci_name(card->pdev));\n\t\telse {\n\t\t\tstruct sk_buff *skb = card->rx_skbs[card->rx_in];\n\t\t\tport_t *port = &card->ports[desc->stat &\n\t\t\t\t\t\t    PACKET_PORT_MASK];\n\t\t\tstruct net_device *dev = port->dev;\n\n\t\t\tif (!skb)\n\t\t\t\tdev->stats.rx_dropped++;\n\t\t\telse {\n\t\t\t\tpci_unmap_single(card->pdev, desc->address,\n\t\t\t\t\t\t BUFFER_LENGTH,\n\t\t\t\t\t\t PCI_DMA_FROMDEVICE);\n\t\t\t\tskb_put(skb, desc->length);\n\n#ifdef DEBUG_PKT\n\t\t\t\tprintk(KERN_DEBUG \"%s RX(%i):\", dev->name,\n\t\t\t\t       skb->len);\n\t\t\t\tdebug_frame(skb);\n#endif\n\t\t\t\tdev->stats.rx_packets++;\n\t\t\t\tdev->stats.rx_bytes += skb->len;\n\t\t\t\tskb->protocol = hdlc_type_trans(skb, dev);\n\t\t\t\tnetif_rx(skb);\n\t\t\t\tskb = NULL;\n\t\t\t}\n\n\t\t\tif (!skb) {\n\t\t\t\tskb = dev_alloc_skb(BUFFER_LENGTH);\n\t\t\t\tdesc->address = skb ?\n\t\t\t\t\tpci_map_single(card->pdev, skb->data,\n\t\t\t\t\t\t       BUFFER_LENGTH,\n\t\t\t\t\t\t       PCI_DMA_FROMDEVICE) : 0;\n\t\t\t\tcard->rx_skbs[card->rx_in] = skb;\n\t\t\t}\n\t\t}\n\t\tdesc->stat = PACKET_EMPTY; /* Free descriptor */\n\t\tcard->rx_in = (card->rx_in + 1) % RX_QUEUE_LENGTH;\n\t}\n}\n\n\n\nstatic irqreturn_t wanxl_intr(int irq, void* dev_id)\n{\n        card_t *card = dev_id;\n        int i;\n        u32 stat;\n        int handled = 0;\n\n\n        while((stat = readl(card->plx + PLX_DOORBELL_FROM_CARD)) != 0) {\n                handled = 1;\n\t\twritel(stat, card->plx + PLX_DOORBELL_FROM_CARD);\n\n                for (i = 0; i < card->n_ports; i++) {\n\t\t\tif (stat & (1 << (DOORBELL_FROM_CARD_TX_0 + i)))\n\t\t\t\twanxl_tx_intr(&card->ports[i]);\n\t\t\tif (stat & (1 << (DOORBELL_FROM_CARD_CABLE_0 + i)))\n\t\t\t\twanxl_cable_intr(&card->ports[i]);\n\t\t}\n\t\tif (stat & (1 << DOORBELL_FROM_CARD_RX))\n\t\t\twanxl_rx_intr(card);\n        }\n\n        return IRQ_RETVAL(handled);\n}\n\n\n\nstatic netdev_tx_t wanxl_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n        port_t *port = dev_to_port(dev);\n\tdesc_t *desc;\n\n        spin_lock(&port->lock);\n\n\tdesc = &get_status(port)->tx_descs[port->tx_out];\n        if (desc->stat != PACKET_EMPTY) {\n                /* should never happen - previous xmit should stop queue */\n#ifdef DEBUG_PKT\n                printk(KERN_DEBUG \"%s: transmitter buffer full\\n\", dev->name);\n#endif\n\t\tnetif_stop_queue(dev);\n\t\tspin_unlock(&port->lock);\n\t\treturn NETDEV_TX_BUSY;       /* request packet to be queued */\n\t}\n\n#ifdef DEBUG_PKT\n\tprintk(KERN_DEBUG \"%s TX(%i):\", dev->name, skb->len);\n\tdebug_frame(skb);\n#endif\n\n\tport->tx_skbs[port->tx_out] = skb;\n\tdesc->address = pci_map_single(port->card->pdev, skb->data, skb->len,\n\t\t\t\t       PCI_DMA_TODEVICE);\n\tdesc->length = skb->len;\n\tdesc->stat = PACKET_FULL;\n\twritel(1 << (DOORBELL_TO_CARD_TX_0 + port->node),\n\t       port->card->plx + PLX_DOORBELL_TO_CARD);\n\n\tport->tx_out = (port->tx_out + 1) % TX_BUFFERS;\n\n\tif (get_status(port)->tx_descs[port->tx_out].stat != PACKET_EMPTY) {\n\t\tnetif_stop_queue(dev);\n#ifdef DEBUG_PKT\n\t\tprintk(KERN_DEBUG \"%s: transmitter buffer full\\n\", dev->name);\n#endif\n\t}\n\n\tspin_unlock(&port->lock);\n\treturn NETDEV_TX_OK;\n}\n\n\n\nstatic int wanxl_attach(struct net_device *dev, unsigned short encoding,\n\t\t\tunsigned short parity)\n{\n\tport_t *port = dev_to_port(dev);\n\n\tif (encoding != ENCODING_NRZ &&\n\t    encoding != ENCODING_NRZI)\n\t\treturn -EINVAL;\n\n\tif (parity != PARITY_NONE &&\n\t    parity != PARITY_CRC32_PR1_CCITT &&\n\t    parity != PARITY_CRC16_PR1_CCITT &&\n\t    parity != PARITY_CRC32_PR0_CCITT &&\n\t    parity != PARITY_CRC16_PR0_CCITT)\n\t\treturn -EINVAL;\n\n\tget_status(port)->encoding = encoding;\n\tget_status(port)->parity = parity;\n\treturn 0;\n}\n\n\n\nstatic int wanxl_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)\n{\n\tconst size_t size = sizeof(sync_serial_settings);\n\tsync_serial_settings line;\n\tport_t *port = dev_to_port(dev);\n\n\tif (cmd != SIOCWANDEV)\n\t\treturn hdlc_ioctl(dev, ifr, cmd);\n\n\tswitch (ifr->ifr_settings.type) {\n\tcase IF_GET_IFACE:\n\t\tifr->ifr_settings.type = IF_IFACE_SYNC_SERIAL;\n\t\tif (ifr->ifr_settings.size < size) {\n\t\t\tifr->ifr_settings.size = size; /* data size wanted */\n\t\t\treturn -ENOBUFS;\n\t\t}\n\t\tmemset(&line, 0, sizeof(line));\n\t\tline.clock_type = get_status(port)->clocking;\n\t\tline.clock_rate = 0;\n\t\tline.loopback = 0;\n\n\t\tif (copy_to_user(ifr->ifr_settings.ifs_ifsu.sync, &line, size))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\n\tcase IF_IFACE_SYNC_SERIAL:\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\t\tif (dev->flags & IFF_UP)\n\t\t\treturn -EBUSY;\n\n\t\tif (copy_from_user(&line, ifr->ifr_settings.ifs_ifsu.sync,\n\t\t\t\t   size))\n\t\t\treturn -EFAULT;\n\n\t\tif (line.clock_type != CLOCK_EXT &&\n\t\t    line.clock_type != CLOCK_TXFROMRX)\n\t\t\treturn -EINVAL; /* No such clock setting */\n\n\t\tif (line.loopback != 0)\n\t\t\treturn -EINVAL;\n\n\t\tget_status(port)->clocking = line.clock_type;\n\t\treturn 0;\n\n\tdefault:\n\t\treturn hdlc_ioctl(dev, ifr, cmd);\n        }\n}\n\n\n\nstatic int wanxl_open(struct net_device *dev)\n{\n\tport_t *port = dev_to_port(dev);\n\tu8 __iomem *dbr = port->card->plx + PLX_DOORBELL_TO_CARD;\n\tunsigned long timeout;\n\tint i;\n\n\tif (get_status(port)->open) {\n\t\tnetdev_err(dev, \"port already open\\n\");\n\t\treturn -EIO;\n\t}\n\tif ((i = hdlc_open(dev)) != 0)\n\t\treturn i;\n\n\tport->tx_in = port->tx_out = 0;\n\tfor (i = 0; i < TX_BUFFERS; i++)\n\t\tget_status(port)->tx_descs[i].stat = PACKET_EMPTY;\n\t/* signal the card */\n\twritel(1 << (DOORBELL_TO_CARD_OPEN_0 + port->node), dbr);\n\n\ttimeout = jiffies + HZ;\n\tdo {\n\t\tif (get_status(port)->open) {\n\t\t\tnetif_start_queue(dev);\n\t\t\treturn 0;\n\t\t}\n\t} while (time_after(timeout, jiffies));\n\n\tnetdev_err(dev, \"unable to open port\\n\");\n\t/* ask the card to close the port, should it be still alive */\n\twritel(1 << (DOORBELL_TO_CARD_CLOSE_0 + port->node), dbr);\n\treturn -EFAULT;\n}\n\n\n\nstatic int wanxl_close(struct net_device *dev)\n{\n\tport_t *port = dev_to_port(dev);\n\tunsigned long timeout;\n\tint i;\n\n\thdlc_close(dev);\n\t/* signal the card */\n\twritel(1 << (DOORBELL_TO_CARD_CLOSE_0 + port->node),\n\t       port->card->plx + PLX_DOORBELL_TO_CARD);\n\n\ttimeout = jiffies + HZ;\n\tdo {\n\t\tif (!get_status(port)->open)\n\t\t\tbreak;\n\t} while (time_after(timeout, jiffies));\n\n\tif (get_status(port)->open)\n\t\tnetdev_err(dev, \"unable to close port\\n\");\n\n\tnetif_stop_queue(dev);\n\n\tfor (i = 0; i < TX_BUFFERS; i++) {\n\t\tdesc_t *desc = &get_status(port)->tx_descs[i];\n\n\t\tif (desc->stat != PACKET_EMPTY) {\n\t\t\tdesc->stat = PACKET_EMPTY;\n\t\t\tpci_unmap_single(port->card->pdev, desc->address,\n\t\t\t\t\t port->tx_skbs[i]->len,\n\t\t\t\t\t PCI_DMA_TODEVICE);\n\t\t\tdev_kfree_skb(port->tx_skbs[i]);\n\t\t}\n\t}\n\treturn 0;\n}\n\n\n\nstatic struct net_device_stats *wanxl_get_stats(struct net_device *dev)\n{\n\tport_t *port = dev_to_port(dev);\n\n\tdev->stats.rx_over_errors = get_status(port)->rx_overruns;\n\tdev->stats.rx_frame_errors = get_status(port)->rx_frame_errors;\n\tdev->stats.rx_errors = dev->stats.rx_over_errors +\n\t\tdev->stats.rx_frame_errors;\n\treturn &dev->stats;\n}\n\n\n\nstatic int wanxl_puts_command(card_t *card, u32 cmd)\n{\n\tunsigned long timeout = jiffies + 5 * HZ;\n\n\twritel(cmd, card->plx + PLX_MAILBOX_1);\n\tdo {\n\t\tif (readl(card->plx + PLX_MAILBOX_1) == 0)\n\t\t\treturn 0;\n\n\t\tschedule();\n\t}while (time_after(timeout, jiffies));\n\n\treturn -1;\n}\n\n\n\nstatic void wanxl_reset(card_t *card)\n{\n\tu32 old_value = readl(card->plx + PLX_CONTROL) & ~PLX_CTL_RESET;\n\n\twritel(0x80, card->plx + PLX_MAILBOX_0);\n\twritel(old_value | PLX_CTL_RESET, card->plx + PLX_CONTROL);\n\treadl(card->plx + PLX_CONTROL); /* wait for posted write */\n\tudelay(1);\n\twritel(old_value, card->plx + PLX_CONTROL);\n\treadl(card->plx + PLX_CONTROL); /* wait for posted write */\n}\n\n\n\nstatic void wanxl_pci_remove_one(struct pci_dev *pdev)\n{\n\tcard_t *card = pci_get_drvdata(pdev);\n\tint i;\n\n\tfor (i = 0; i < card->n_ports; i++) {\n\t\tunregister_hdlc_device(card->ports[i].dev);\n\t\tfree_netdev(card->ports[i].dev);\n\t}\n\n\t/* unregister and free all host resources */\n\tif (card->irq)\n\t\tfree_irq(card->irq, card);\n\n\twanxl_reset(card);\n\n\tfor (i = 0; i < RX_QUEUE_LENGTH; i++)\n\t\tif (card->rx_skbs[i]) {\n\t\t\tpci_unmap_single(card->pdev,\n\t\t\t\t\t card->status->rx_descs[i].address,\n\t\t\t\t\t BUFFER_LENGTH, PCI_DMA_FROMDEVICE);\n\t\t\tdev_kfree_skb(card->rx_skbs[i]);\n\t\t}\n\n\tif (card->plx)\n\t\tiounmap(card->plx);\n\n\tif (card->status)\n\t\tpci_free_consistent(pdev, sizeof(card_status_t),\n\t\t\t\t    card->status, card->status_address);\n\n\tpci_release_regions(pdev);\n\tpci_disable_device(pdev);\n\tpci_set_drvdata(pdev, NULL);\n\tkfree(card);\n}\n\n\n#include \"wanxlfw.inc\"\n\nstatic const struct net_device_ops wanxl_ops = {\n\t.ndo_open       = wanxl_open,\n\t.ndo_stop       = wanxl_close,\n\t.ndo_change_mtu = hdlc_change_mtu,\n\t.ndo_start_xmit = hdlc_start_xmit,\n\t.ndo_do_ioctl   = wanxl_ioctl,\n\t.ndo_get_stats  = wanxl_get_stats,\n};\n\nstatic int wanxl_pci_init_one(struct pci_dev *pdev,\n\t\t\t      const struct pci_device_id *ent)\n{\n\tcard_t *card;\n\tu32 ramsize, stat;\n\tunsigned long timeout;\n\tu32 plx_phy;\t\t/* PLX PCI base address */\n\tu32 mem_phy;\t\t/* memory PCI base addr */\n\tu8 __iomem *mem;\t/* memory virtual base addr */\n\tint i, ports, alloc_size;\n\n#ifndef MODULE\n\tpr_info_once(\"%s\\n\", version);\n#endif\n\n\ti = pci_enable_device(pdev);\n\tif (i)\n\t\treturn i;\n\n\t/* QUICC can only access first 256 MB of host RAM directly,\n\t   but PLX9060 DMA does 32-bits for actual packet data transfers */\n\n\t/* FIXME when PCI/DMA subsystems are fixed.\n\t   We set both dma_mask and consistent_dma_mask to 28 bits\n\t   and pray pci_alloc_consistent() will use this info. It should\n\t   work on most platforms */\n\tif (pci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(28)) ||\n\t    pci_set_dma_mask(pdev, DMA_BIT_MASK(28))) {\n\t\tpr_err(\"No usable DMA configuration\\n\");\n\t\treturn -EIO;\n\t}\n\n\ti = pci_request_regions(pdev, \"wanXL\");\n\tif (i) {\n\t\tpci_disable_device(pdev);\n\t\treturn i;\n\t}\n\n\tswitch (pdev->device) {\n\tcase PCI_DEVICE_ID_SBE_WANXL100: ports = 1; break;\n\tcase PCI_DEVICE_ID_SBE_WANXL200: ports = 2; break;\n\tdefault: ports = 4;\n\t}\n\n\talloc_size = sizeof(card_t) + ports * sizeof(port_t);\n\tcard = kzalloc(alloc_size, GFP_KERNEL);\n\tif (card == NULL) {\n\t\tpci_release_regions(pdev);\n\t\tpci_disable_device(pdev);\n\t\treturn -ENOBUFS;\n\t}\n\n\tpci_set_drvdata(pdev, card);\n\tcard->pdev = pdev;\n\n\tcard->status = pci_alloc_consistent(pdev, sizeof(card_status_t),\n\t\t\t\t\t    &card->status_address);\n\tif (card->status == NULL) {\n\t\twanxl_pci_remove_one(pdev);\n\t\treturn -ENOBUFS;\n\t}\n\n#ifdef DEBUG_PCI\n\tprintk(KERN_DEBUG \"wanXL %s: pci_alloc_consistent() returned memory\"\n\t       \" at 0x%LX\\n\", pci_name(pdev),\n\t       (unsigned long long)card->status_address);\n#endif\n\n\t/* FIXME when PCI/DMA subsystems are fixed.\n\t   We set both dma_mask and consistent_dma_mask back to 32 bits\n\t   to indicate the card can do 32-bit DMA addressing */\n\tif (pci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(32)) ||\n\t    pci_set_dma_mask(pdev, DMA_BIT_MASK(32))) {\n\t\tpr_err(\"No usable DMA configuration\\n\");\n\t\twanxl_pci_remove_one(pdev);\n\t\treturn -EIO;\n\t}\n\n\t/* set up PLX mapping */\n\tplx_phy = pci_resource_start(pdev, 0);\n\n\tcard->plx = ioremap_nocache(plx_phy, 0x70);\n\tif (!card->plx) {\n\t\tpr_err(\"ioremap() failed\\n\");\n \t\twanxl_pci_remove_one(pdev);\n\t\treturn -EFAULT;\n\t}\n\n#if RESET_WHILE_LOADING\n\twanxl_reset(card);\n#endif\n\n\ttimeout = jiffies + 20 * HZ;\n\twhile ((stat = readl(card->plx + PLX_MAILBOX_0)) != 0) {\n\t\tif (time_before(timeout, jiffies)) {\n\t\t\tpr_warn(\"%s: timeout waiting for PUTS to complete\\n\",\n\t\t\t\tpci_name(pdev));\n\t\t\twanxl_pci_remove_one(pdev);\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\tswitch(stat & 0xC0) {\n\t\tcase 0x00:\t/* hmm - PUTS completed with non-zero code? */\n\t\tcase 0x80:\t/* PUTS still testing the hardware */\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tpr_warn(\"%s: PUTS test 0x%X failed\\n\",\n\t\t\t\tpci_name(pdev), stat & 0x30);\n\t\t\twanxl_pci_remove_one(pdev);\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\tschedule();\n\t}\n\n\t/* get on-board memory size (PUTS detects no more than 4 MB) */\n\tramsize = readl(card->plx + PLX_MAILBOX_2) & MBX2_MEMSZ_MASK;\n\n\t/* set up on-board RAM mapping */\n\tmem_phy = pci_resource_start(pdev, 2);\n\n\n\t/* sanity check the board's reported memory size */\n\tif (ramsize < BUFFERS_ADDR +\n\t    (TX_BUFFERS + RX_BUFFERS) * BUFFER_LENGTH * ports) {\n\t\tpr_warn(\"%s: no enough on-board RAM (%u bytes detected, %u bytes required)\\n\",\n\t\t\tpci_name(pdev), ramsize,\n\t\t\tBUFFERS_ADDR +\n\t\t\t(TX_BUFFERS + RX_BUFFERS) * BUFFER_LENGTH * ports);\n\t\twanxl_pci_remove_one(pdev);\n\t\treturn -ENODEV;\n\t}\n\n\tif (wanxl_puts_command(card, MBX1_CMD_BSWAP)) {\n\t\tpr_warn(\"%s: unable to Set Byte Swap Mode\\n\", pci_name(pdev));\n\t\twanxl_pci_remove_one(pdev);\n\t\treturn -ENODEV;\n\t}\n\n\tfor (i = 0; i < RX_QUEUE_LENGTH; i++) {\n\t\tstruct sk_buff *skb = dev_alloc_skb(BUFFER_LENGTH);\n\t\tcard->rx_skbs[i] = skb;\n\t\tif (skb)\n\t\t\tcard->status->rx_descs[i].address =\n\t\t\t\tpci_map_single(card->pdev, skb->data,\n\t\t\t\t\t       BUFFER_LENGTH,\n\t\t\t\t\t       PCI_DMA_FROMDEVICE);\n\t}\n\n\tmem = ioremap_nocache(mem_phy, PDM_OFFSET + sizeof(firmware));\n\tif (!mem) {\n\t\tpr_err(\"ioremap() failed\\n\");\n \t\twanxl_pci_remove_one(pdev);\n\t\treturn -EFAULT;\n\t}\n\n\tfor (i = 0; i < sizeof(firmware); i += 4)\n\t\twritel(ntohl(*(__be32*)(firmware + i)), mem + PDM_OFFSET + i);\n\n\tfor (i = 0; i < ports; i++)\n\t\twritel(card->status_address +\n\t\t       (void *)&card->status->port_status[i] -\n\t\t       (void *)card->status, mem + PDM_OFFSET + 4 + i * 4);\n\twritel(card->status_address, mem + PDM_OFFSET + 20);\n\twritel(PDM_OFFSET, mem);\n\tiounmap(mem);\n\n\twritel(0, card->plx + PLX_MAILBOX_5);\n\n\tif (wanxl_puts_command(card, MBX1_CMD_ABORTJ)) {\n\t\tpr_warn(\"%s: unable to Abort and Jump\\n\", pci_name(pdev));\n\t\twanxl_pci_remove_one(pdev);\n\t\treturn -ENODEV;\n\t}\n\n\tstat = 0;\n\ttimeout = jiffies + 5 * HZ;\n\tdo {\n\t\tif ((stat = readl(card->plx + PLX_MAILBOX_5)) != 0)\n\t\t\tbreak;\n\t\tschedule();\n\t}while (time_after(timeout, jiffies));\n\n\tif (!stat) {\n\t\tpr_warn(\"%s: timeout while initializing card firmware\\n\",\n\t\t\tpci_name(pdev));\n\t\twanxl_pci_remove_one(pdev);\n\t\treturn -ENODEV;\n\t}\n\n#if DETECT_RAM\n\tramsize = stat;\n#endif\n\n\tpr_info(\"%s: at 0x%X, %u KB of RAM at 0x%X, irq %u\\n\",\n\t\tpci_name(pdev), plx_phy, ramsize / 1024, mem_phy, pdev->irq);\n\n\t/* Allocate IRQ */\n\tif (request_irq(pdev->irq, wanxl_intr, IRQF_SHARED, \"wanXL\", card)) {\n\t\tpr_warn(\"%s: could not allocate IRQ%i\\n\",\n\t\t\tpci_name(pdev), pdev->irq);\n\t\twanxl_pci_remove_one(pdev);\n\t\treturn -EBUSY;\n\t}\n\tcard->irq = pdev->irq;\n\n\tfor (i = 0; i < ports; i++) {\n\t\thdlc_device *hdlc;\n\t\tport_t *port = &card->ports[i];\n\t\tstruct net_device *dev = alloc_hdlcdev(port);\n\t\tif (!dev) {\n\t\t\tpr_err(\"%s: unable to allocate memory\\n\",\n\t\t\t       pci_name(pdev));\n\t\t\twanxl_pci_remove_one(pdev);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tport->dev = dev;\n\t\thdlc = dev_to_hdlc(dev);\n\t\tspin_lock_init(&port->lock);\n\t\tdev->tx_queue_len = 50;\n\t\tdev->netdev_ops = &wanxl_ops;\n\t\thdlc->attach = wanxl_attach;\n\t\thdlc->xmit = wanxl_xmit;\n\t\tport->card = card;\n\t\tport->node = i;\n\t\tget_status(port)->clocking = CLOCK_EXT;\n\t\tif (register_hdlc_device(dev)) {\n\t\t\tpr_err(\"%s: unable to register hdlc device\\n\",\n\t\t\t       pci_name(pdev));\n\t\t\tfree_netdev(dev);\n\t\t\twanxl_pci_remove_one(pdev);\n\t\t\treturn -ENOBUFS;\n\t\t}\n\t\tcard->n_ports++;\n\t}\n\n\tpr_info(\"%s: port\", pci_name(pdev));\n\tfor (i = 0; i < ports; i++)\n\t\tpr_cont(\"%s #%i: %s\",\n\t\t\ti ? \",\" : \"\", i, card->ports[i].dev->name);\n\tpr_cont(\"\\n\");\n\n\tfor (i = 0; i < ports; i++)\n\t\twanxl_cable_intr(&card->ports[i]); /* get carrier status etc.*/\n\n\treturn 0;\n}\n\nstatic DEFINE_PCI_DEVICE_TABLE(wanxl_pci_tbl) = {\n\t{ PCI_VENDOR_ID_SBE, PCI_DEVICE_ID_SBE_WANXL100, PCI_ANY_ID,\n\t  PCI_ANY_ID, 0, 0, 0 },\n\t{ PCI_VENDOR_ID_SBE, PCI_DEVICE_ID_SBE_WANXL200, PCI_ANY_ID,\n\t  PCI_ANY_ID, 0, 0, 0 },\n\t{ PCI_VENDOR_ID_SBE, PCI_DEVICE_ID_SBE_WANXL400, PCI_ANY_ID,\n\t  PCI_ANY_ID, 0, 0, 0 },\n\t{ 0, }\n};\n\n\nstatic struct pci_driver wanxl_pci_driver = {\n\t.name\t\t= \"wanXL\",\n\t.id_table\t= wanxl_pci_tbl,\n\t.probe\t\t= wanxl_pci_init_one,\n\t.remove\t\t= wanxl_pci_remove_one,\n};\n\n\nstatic int __init wanxl_init_module(void)\n{\n#ifdef MODULE\n\tpr_info(\"%s\\n\", version);\n#endif\n\treturn pci_register_driver(&wanxl_pci_driver);\n}\n\nstatic void __exit wanxl_cleanup_module(void)\n{\n\tpci_unregister_driver(&wanxl_pci_driver);\n}\n\n\nMODULE_AUTHOR(\"Krzysztof Halasa <khc@pm.waw.pl>\");\nMODULE_DESCRIPTION(\"SBE Inc. wanXL serial port driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DEVICE_TABLE(pci, wanxl_pci_tbl);\n\nmodule_init(wanxl_init_module);\nmodule_exit(wanxl_cleanup_module);\n"], "filenames": ["drivers/net/wan/wanxl.c"], "buggy_code_start_loc": [357], "buggy_code_end_loc": [357], "fixing_code_start_loc": [358], "fixing_code_end_loc": [359], "type": "CWE-399", "message": "The wanxl_ioctl function in drivers/net/wan/wanxl.c in the Linux kernel before 3.11.7 does not properly initialize a certain data structure, which allows local users to obtain sensitive information from kernel memory via an ioctl call.", "other": {"cve": {"id": "CVE-2014-1445", "sourceIdentifier": "cve@mitre.org", "published": "2014-01-18T22:55:03.320", "lastModified": "2017-08-29T01:34:25.077", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The wanxl_ioctl function in drivers/net/wan/wanxl.c in the Linux kernel before 3.11.7 does not properly initialize a certain data structure, which allows local users to obtain sensitive information from kernel memory via an ioctl call."}, {"lang": "es", "value": "La funci\u00f3n wanxl_ioctl en drivers/net/wan/wanxl.c en el kernel Linux anteriores a 3.11.7 no inicializa cierta estructura de datos apropiadamente, lo cual permite a usuarios locales obtener informaci\u00f3n sensible de la memoria del kernel a trav\u00e9s de un allamada ioctl."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 2.1}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-399"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "3.11.6", "matchCriteriaId": "C3D55C7B-D6AF-4DB4-8CCC-3BFC8C15F45D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.11:*:*:*:*:*:*:*", "matchCriteriaId": "639E3A57-A9E7-40E6-8929-81CCC0060EFB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.11.1:*:*:*:*:*:*:*", "matchCriteriaId": "07012ADD-F521-40A8-B067-E87C2238A3D2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.11.2:*:*:*:*:*:*:*", "matchCriteriaId": "3F5FF393-3F89-4274-B82B-F671358072ED"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.11.3:*:*:*:*:*:*:*", "matchCriteriaId": "E348698F-54D1-4F5E-B701-CFAF50881E0A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.11.4:*:*:*:*:*:*:*", "matchCriteriaId": "932205D9-3514-4289-9B55-C7A169276930"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.11.5:*:*:*:*:*:*:*", "matchCriteriaId": "2ECB2D33-F517-480F-8A6F-99D9D6C49596"}]}]}], "references": [{"url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git;a=commit;h=2b13d06c9584b4eb773f1e80bbaedab9a1c344e1", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "http://www.kernel.org/pub/linux/kernel/v3.x/ChangeLog-3.11.7", "source": "cve@mitre.org"}, {"url": "http://www.openwall.com/lists/oss-security/2014/01/15/3", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "http://www.securityfocus.com/bid/64953", "source": "cve@mitre.org"}, {"url": "http://www.ubuntu.com/usn/USN-2128-1", "source": "cve@mitre.org"}, {"url": "http://www.ubuntu.com/usn/USN-2129-1", "source": "cve@mitre.org"}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1053613", "source": "cve@mitre.org"}, {"url": "https://exchange.xforce.ibmcloud.com/vulnerabilities/90444", "source": "cve@mitre.org"}, {"url": "https://github.com/torvalds/linux/commit/2b13d06c9584b4eb773f1e80bbaedab9a1c344e1", "source": "cve@mitre.org", "tags": ["Patch"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/2b13d06c9584b4eb773f1e80bbaedab9a1c344e1"}}