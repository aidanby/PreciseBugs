{"buggy_code": ["// Copyright 2012 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage agent\n\nimport (\n\t\"bytes\"\n\t\"crypto/rand\"\n\t\"errors\"\n\t\"net\"\n\t\"os\"\n\t\"os/exec\"\n\t\"path/filepath\"\n\t\"strconv\"\n\t\"testing\"\n\t\"time\"\n\n\t\"golang.org/x/crypto/ssh\"\n)\n\n// startAgent executes ssh-agent, and returns a Agent interface to it.\nfunc startAgent(t *testing.T) (client Agent, socket string, cleanup func()) {\n\tif testing.Short() {\n\t\t// ssh-agent is not always available, and the key\n\t\t// types supported vary by platform.\n\t\tt.Skip(\"skipping test due to -short\")\n\t}\n\n\tbin, err := exec.LookPath(\"ssh-agent\")\n\tif err != nil {\n\t\tt.Skip(\"could not find ssh-agent\")\n\t}\n\n\tcmd := exec.Command(bin, \"-s\")\n\tout, err := cmd.Output()\n\tif err != nil {\n\t\tt.Fatalf(\"cmd.Output: %v\", err)\n\t}\n\n\t/* Output looks like:\n\n\t\t   SSH_AUTH_SOCK=/tmp/ssh-P65gpcqArqvH/agent.15541; export SSH_AUTH_SOCK;\n\t           SSH_AGENT_PID=15542; export SSH_AGENT_PID;\n\t           echo Agent pid 15542;\n\t*/\n\tfields := bytes.Split(out, []byte(\";\"))\n\tline := bytes.SplitN(fields[0], []byte(\"=\"), 2)\n\tline[0] = bytes.TrimLeft(line[0], \"\\n\")\n\tif string(line[0]) != \"SSH_AUTH_SOCK\" {\n\t\tt.Fatalf(\"could not find key SSH_AUTH_SOCK in %q\", fields[0])\n\t}\n\tsocket = string(line[1])\n\n\tline = bytes.SplitN(fields[2], []byte(\"=\"), 2)\n\tline[0] = bytes.TrimLeft(line[0], \"\\n\")\n\tif string(line[0]) != \"SSH_AGENT_PID\" {\n\t\tt.Fatalf(\"could not find key SSH_AGENT_PID in %q\", fields[2])\n\t}\n\tpidStr := line[1]\n\tpid, err := strconv.Atoi(string(pidStr))\n\tif err != nil {\n\t\tt.Fatalf(\"Atoi(%q): %v\", pidStr, err)\n\t}\n\n\tconn, err := net.Dial(\"unix\", string(socket))\n\tif err != nil {\n\t\tt.Fatalf(\"net.Dial: %v\", err)\n\t}\n\n\tac := NewClient(conn)\n\treturn ac, socket, func() {\n\t\tproc, _ := os.FindProcess(pid)\n\t\tif proc != nil {\n\t\t\tproc.Kill()\n\t\t}\n\t\tconn.Close()\n\t\tos.RemoveAll(filepath.Dir(socket))\n\t}\n}\n\nfunc testAgent(t *testing.T, key interface{}, cert *ssh.Certificate, lifetimeSecs uint32) {\n\tagent, _, cleanup := startAgent(t)\n\tdefer cleanup()\n\n\ttestAgentInterface(t, agent, key, cert, lifetimeSecs)\n}\n\nfunc testKeyring(t *testing.T, key interface{}, cert *ssh.Certificate, lifetimeSecs uint32) {\n\ta := NewKeyring()\n\ttestAgentInterface(t, a, key, cert, lifetimeSecs)\n}\n\nfunc testAgentInterface(t *testing.T, agent Agent, key interface{}, cert *ssh.Certificate, lifetimeSecs uint32) {\n\tsigner, err := ssh.NewSignerFromKey(key)\n\tif err != nil {\n\t\tt.Fatalf(\"NewSignerFromKey(%T): %v\", key, err)\n\t}\n\t// The agent should start up empty.\n\tif keys, err := agent.List(); err != nil {\n\t\tt.Fatalf(\"RequestIdentities: %v\", err)\n\t} else if len(keys) > 0 {\n\t\tt.Fatalf(\"got %d keys, want 0: %v\", len(keys), keys)\n\t}\n\n\t// Attempt to insert the key, with certificate if specified.\n\tvar pubKey ssh.PublicKey\n\tif cert != nil {\n\t\terr = agent.Add(AddedKey{\n\t\t\tPrivateKey:   key,\n\t\t\tCertificate:  cert,\n\t\t\tComment:      \"comment\",\n\t\t\tLifetimeSecs: lifetimeSecs,\n\t\t})\n\t\tpubKey = cert\n\t} else {\n\t\terr = agent.Add(AddedKey{PrivateKey: key, Comment: \"comment\", LifetimeSecs: lifetimeSecs})\n\t\tpubKey = signer.PublicKey()\n\t}\n\tif err != nil {\n\t\tt.Fatalf(\"insert(%T): %v\", key, err)\n\t}\n\n\t// Did the key get inserted successfully?\n\tif keys, err := agent.List(); err != nil {\n\t\tt.Fatalf(\"List: %v\", err)\n\t} else if len(keys) != 1 {\n\t\tt.Fatalf(\"got %v, want 1 key\", keys)\n\t} else if keys[0].Comment != \"comment\" {\n\t\tt.Fatalf(\"key comment: got %v, want %v\", keys[0].Comment, \"comment\")\n\t} else if !bytes.Equal(keys[0].Blob, pubKey.Marshal()) {\n\t\tt.Fatalf(\"key mismatch\")\n\t}\n\n\t// Can the agent make a valid signature?\n\tdata := []byte(\"hello\")\n\tsig, err := agent.Sign(pubKey, data)\n\tif err != nil {\n\t\tt.Fatalf(\"Sign(%s): %v\", pubKey.Type(), err)\n\t}\n\n\tif err := pubKey.Verify(data, sig); err != nil {\n\t\tt.Fatalf(\"Verify(%s): %v\", pubKey.Type(), err)\n\t}\n\n\t// If the key has a lifetime, is it removed when it should be?\n\tif lifetimeSecs > 0 {\n\t\ttime.Sleep(time.Second*time.Duration(lifetimeSecs) + 100*time.Millisecond)\n\t\tkeys, err := agent.List()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"List: %v\", err)\n\t\t}\n\t\tif len(keys) > 0 {\n\t\t\tt.Fatalf(\"key not expired\")\n\t\t}\n\t}\n\n}\n\nfunc TestAgent(t *testing.T) {\n\tfor _, keyType := range []string{\"rsa\", \"dsa\", \"ecdsa\", \"ed25519\"} {\n\t\ttestAgent(t, testPrivateKeys[keyType], nil, 0)\n\t\ttestKeyring(t, testPrivateKeys[keyType], nil, 1)\n\t}\n}\n\nfunc TestCert(t *testing.T) {\n\tcert := &ssh.Certificate{\n\t\tKey:         testPublicKeys[\"rsa\"],\n\t\tValidBefore: ssh.CertTimeInfinity,\n\t\tCertType:    ssh.UserCert,\n\t}\n\tcert.SignCert(rand.Reader, testSigners[\"ecdsa\"])\n\n\ttestAgent(t, testPrivateKeys[\"rsa\"], cert, 0)\n\ttestKeyring(t, testPrivateKeys[\"rsa\"], cert, 1)\n}\n\n// netPipe is analogous to net.Pipe, but it uses a real net.Conn, and\n// therefore is buffered (net.Pipe deadlocks if both sides start with\n// a write.)\nfunc netPipe() (net.Conn, net.Conn, error) {\n\tlistener, err := net.Listen(\"tcp\", \":0\")\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tdefer listener.Close()\n\tc1, err := net.Dial(\"tcp\", listener.Addr().String())\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tc2, err := listener.Accept()\n\tif err != nil {\n\t\tc1.Close()\n\t\treturn nil, nil, err\n\t}\n\n\treturn c1, c2, nil\n}\n\nfunc TestAuth(t *testing.T) {\n\ta, b, err := netPipe()\n\tif err != nil {\n\t\tt.Fatalf(\"netPipe: %v\", err)\n\t}\n\n\tdefer a.Close()\n\tdefer b.Close()\n\n\tagent, _, cleanup := startAgent(t)\n\tdefer cleanup()\n\n\tif err := agent.Add(AddedKey{PrivateKey: testPrivateKeys[\"rsa\"], Comment: \"comment\"}); err != nil {\n\t\tt.Errorf(\"Add: %v\", err)\n\t}\n\n\tserverConf := ssh.ServerConfig{}\n\tserverConf.AddHostKey(testSigners[\"rsa\"])\n\tserverConf.PublicKeyCallback = func(c ssh.ConnMetadata, key ssh.PublicKey) (*ssh.Permissions, error) {\n\t\tif bytes.Equal(key.Marshal(), testPublicKeys[\"rsa\"].Marshal()) {\n\t\t\treturn nil, nil\n\t\t}\n\n\t\treturn nil, errors.New(\"pubkey rejected\")\n\t}\n\n\tgo func() {\n\t\tconn, _, _, err := ssh.NewServerConn(a, &serverConf)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Server: %v\", err)\n\t\t}\n\t\tconn.Close()\n\t}()\n\n\tconf := ssh.ClientConfig{}\n\tconf.Auth = append(conf.Auth, ssh.PublicKeysCallback(agent.Signers))\n\tconn, _, _, err := ssh.NewClientConn(b, \"\", &conf)\n\tif err != nil {\n\t\tt.Fatalf(\"NewClientConn: %v\", err)\n\t}\n\tconn.Close()\n}\n\nfunc TestLockClient(t *testing.T) {\n\tagent, _, cleanup := startAgent(t)\n\tdefer cleanup()\n\ttestLockAgent(agent, t)\n}\n\nfunc testLockAgent(agent Agent, t *testing.T) {\n\tif err := agent.Add(AddedKey{PrivateKey: testPrivateKeys[\"rsa\"], Comment: \"comment 1\"}); err != nil {\n\t\tt.Errorf(\"Add: %v\", err)\n\t}\n\tif err := agent.Add(AddedKey{PrivateKey: testPrivateKeys[\"dsa\"], Comment: \"comment dsa\"}); err != nil {\n\t\tt.Errorf(\"Add: %v\", err)\n\t}\n\tif keys, err := agent.List(); err != nil {\n\t\tt.Errorf(\"List: %v\", err)\n\t} else if len(keys) != 2 {\n\t\tt.Errorf(\"Want 2 keys, got %v\", keys)\n\t}\n\n\tpassphrase := []byte(\"secret\")\n\tif err := agent.Lock(passphrase); err != nil {\n\t\tt.Errorf(\"Lock: %v\", err)\n\t}\n\n\tif keys, err := agent.List(); err != nil {\n\t\tt.Errorf(\"List: %v\", err)\n\t} else if len(keys) != 0 {\n\t\tt.Errorf(\"Want 0 keys, got %v\", keys)\n\t}\n\n\tsigner, _ := ssh.NewSignerFromKey(testPrivateKeys[\"rsa\"])\n\tif _, err := agent.Sign(signer.PublicKey(), []byte(\"hello\")); err == nil {\n\t\tt.Fatalf(\"Sign did not fail\")\n\t}\n\n\tif err := agent.Remove(signer.PublicKey()); err == nil {\n\t\tt.Fatalf(\"Remove did not fail\")\n\t}\n\n\tif err := agent.RemoveAll(); err == nil {\n\t\tt.Fatalf(\"RemoveAll did not fail\")\n\t}\n\n\tif err := agent.Unlock(nil); err == nil {\n\t\tt.Errorf(\"Unlock with wrong passphrase succeeded\")\n\t}\n\tif err := agent.Unlock(passphrase); err != nil {\n\t\tt.Errorf(\"Unlock: %v\", err)\n\t}\n\n\tif err := agent.Remove(signer.PublicKey()); err != nil {\n\t\tt.Fatalf(\"Remove: %v\", err)\n\t}\n\n\tif keys, err := agent.List(); err != nil {\n\t\tt.Errorf(\"List: %v\", err)\n\t} else if len(keys) != 1 {\n\t\tt.Errorf(\"Want 1 keys, got %v\", keys)\n\t}\n}\n\nfunc TestAgentLifetime(t *testing.T) {\n\tagent, _, cleanup := startAgent(t)\n\tdefer cleanup()\n\n\tfor _, keyType := range []string{\"rsa\", \"dsa\", \"ecdsa\"} {\n\t\t// Add private keys to the agent.\n\t\terr := agent.Add(AddedKey{\n\t\t\tPrivateKey:   testPrivateKeys[keyType],\n\t\t\tComment:      \"comment\",\n\t\t\tLifetimeSecs: 1,\n\t\t})\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"add: %v\", err)\n\t\t}\n\t\t// Add certs to the agent.\n\t\tcert := &ssh.Certificate{\n\t\t\tKey:         testPublicKeys[keyType],\n\t\t\tValidBefore: ssh.CertTimeInfinity,\n\t\t\tCertType:    ssh.UserCert,\n\t\t}\n\t\tcert.SignCert(rand.Reader, testSigners[keyType])\n\t\terr = agent.Add(AddedKey{\n\t\t\tPrivateKey:   testPrivateKeys[keyType],\n\t\t\tCertificate:  cert,\n\t\t\tComment:      \"comment\",\n\t\t\tLifetimeSecs: 1,\n\t\t})\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"add: %v\", err)\n\t\t}\n\t}\n\ttime.Sleep(1100 * time.Millisecond)\n\tif keys, err := agent.List(); err != nil {\n\t\tt.Errorf(\"List: %v\", err)\n\t} else if len(keys) != 0 {\n\t\tt.Errorf(\"Want 0 keys, got %v\", len(keys))\n\t}\n}\n", "// Copyright 2016 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage agent_test\n\nimport (\n\t\"log\"\n\t\"os\"\n\t\"net\"\n\n        \"golang.org/x/crypto/ssh\"\n        \"golang.org/x/crypto/ssh/agent\"\n)\n\nfunc ExampleClientAgent() {\n\t// ssh-agent has a UNIX socket under $SSH_AUTH_SOCK\n\tsocket := os.Getenv(\"SSH_AUTH_SOCK\")\n        conn, err := net.Dial(\"unix\", socket)\n        if err != nil {\n                log.Fatalf(\"net.Dial: %v\", err)\n        }\n\tagentClient := agent.NewClient(conn)\n\tconfig := &ssh.ClientConfig{\n\t\tUser: \"username\",\n\t\tAuth: []ssh.AuthMethod{\n\t\t\t// Use a callback rather than PublicKeys\n\t\t\t// so we only consult the agent once the remote server\n\t\t\t// wants it.\n\t\t\tssh.PublicKeysCallback(agentClient.Signers),\n\t\t},\n\t}\n\n\tsshc, err := ssh.Dial(\"tcp\", \"localhost:22\", config)\n\tif err != nil {\n\t\tlog.Fatalf(\"Dial: %v\", err)\n\t}\n\t// .. use sshc\n\tsshc.Close()\n}\n", "// Copyright 2012 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage agent\n\nimport (\n\t\"crypto\"\n\t\"crypto/rand\"\n\t\"fmt\"\n\t\"testing\"\n\n\t\"golang.org/x/crypto/ssh\"\n)\n\nfunc TestServer(t *testing.T) {\n\tc1, c2, err := netPipe()\n\tif err != nil {\n\t\tt.Fatalf(\"netPipe: %v\", err)\n\t}\n\tdefer c1.Close()\n\tdefer c2.Close()\n\tclient := NewClient(c1)\n\n\tgo ServeAgent(NewKeyring(), c2)\n\n\ttestAgentInterface(t, client, testPrivateKeys[\"rsa\"], nil, 0)\n}\n\nfunc TestLockServer(t *testing.T) {\n\ttestLockAgent(NewKeyring(), t)\n}\n\nfunc TestSetupForwardAgent(t *testing.T) {\n\ta, b, err := netPipe()\n\tif err != nil {\n\t\tt.Fatalf(\"netPipe: %v\", err)\n\t}\n\n\tdefer a.Close()\n\tdefer b.Close()\n\n\t_, socket, cleanup := startAgent(t)\n\tdefer cleanup()\n\n\tserverConf := ssh.ServerConfig{\n\t\tNoClientAuth: true,\n\t}\n\tserverConf.AddHostKey(testSigners[\"rsa\"])\n\tincoming := make(chan *ssh.ServerConn, 1)\n\tgo func() {\n\t\tconn, _, _, err := ssh.NewServerConn(a, &serverConf)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Server: %v\", err)\n\t\t}\n\t\tincoming <- conn\n\t}()\n\n\tconf := ssh.ClientConfig{}\n\tconn, chans, reqs, err := ssh.NewClientConn(b, \"\", &conf)\n\tif err != nil {\n\t\tt.Fatalf(\"NewClientConn: %v\", err)\n\t}\n\tclient := ssh.NewClient(conn, chans, reqs)\n\n\tif err := ForwardToRemote(client, socket); err != nil {\n\t\tt.Fatalf(\"SetupForwardAgent: %v\", err)\n\t}\n\n\tserver := <-incoming\n\tch, reqs, err := server.OpenChannel(channelType, nil)\n\tif err != nil {\n\t\tt.Fatalf(\"OpenChannel(%q): %v\", channelType, err)\n\t}\n\tgo ssh.DiscardRequests(reqs)\n\n\tagentClient := NewClient(ch)\n\ttestAgentInterface(t, agentClient, testPrivateKeys[\"rsa\"], nil, 0)\n\tconn.Close()\n}\n\nfunc TestV1ProtocolMessages(t *testing.T) {\n\tc1, c2, err := netPipe()\n\tif err != nil {\n\t\tt.Fatalf(\"netPipe: %v\", err)\n\t}\n\tdefer c1.Close()\n\tdefer c2.Close()\n\tc := NewClient(c1)\n\n\tgo ServeAgent(NewKeyring(), c2)\n\n\ttestV1ProtocolMessages(t, c.(*client))\n}\n\nfunc testV1ProtocolMessages(t *testing.T, c *client) {\n\treply, err := c.call([]byte{agentRequestV1Identities})\n\tif err != nil {\n\t\tt.Fatalf(\"v1 request all failed: %v\", err)\n\t}\n\tif msg, ok := reply.(*agentV1IdentityMsg); !ok || msg.Numkeys != 0 {\n\t\tt.Fatalf(\"invalid request all response: %#v\", reply)\n\t}\n\n\treply, err = c.call([]byte{agentRemoveAllV1Identities})\n\tif err != nil {\n\t\tt.Fatalf(\"v1 remove all failed: %v\", err)\n\t}\n\tif _, ok := reply.(*successAgentMsg); !ok {\n\t\tt.Fatalf(\"invalid remove all response: %#v\", reply)\n\t}\n}\n\nfunc verifyKey(sshAgent Agent) error {\n\tkeys, err := sshAgent.List()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"listing keys: %v\", err)\n\t}\n\n\tif len(keys) != 1 {\n\t\treturn fmt.Errorf(\"bad number of keys found. expected 1, got %d\", len(keys))\n\t}\n\n\tbuf := make([]byte, 128)\n\tif _, err := rand.Read(buf); err != nil {\n\t\treturn fmt.Errorf(\"rand: %v\", err)\n\t}\n\n\tsig, err := sshAgent.Sign(keys[0], buf)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"sign: %v\", err)\n\t}\n\n\tif err := keys[0].Verify(buf, sig); err != nil {\n\t\treturn fmt.Errorf(\"verify: %v\", err)\n\t}\n\treturn nil\n}\n\nfunc addKeyToAgent(key crypto.PrivateKey) error {\n\tsshAgent := NewKeyring()\n\tif err := sshAgent.Add(AddedKey{PrivateKey: key}); err != nil {\n\t\treturn fmt.Errorf(\"add: %v\", err)\n\t}\n\treturn verifyKey(sshAgent)\n}\n\nfunc TestKeyTypes(t *testing.T) {\n\tfor k, v := range testPrivateKeys {\n\t\tif err := addKeyToAgent(v); err != nil {\n\t\t\tt.Errorf(\"error adding key type %s, %v\", k, err)\n\t\t}\n\t\tif err := addCertToAgentSock(v, nil); err != nil {\n\t\t\tt.Errorf(\"error adding key type %s, %v\", k, err)\n\t\t}\n\t}\n}\n\nfunc addCertToAgentSock(key crypto.PrivateKey, cert *ssh.Certificate) error {\n\ta, b, err := netPipe()\n\tif err != nil {\n\t\treturn err\n\t}\n\tagentServer := NewKeyring()\n\tgo ServeAgent(agentServer, a)\n\n\tagentClient := NewClient(b)\n\tif err := agentClient.Add(AddedKey{PrivateKey: key, Certificate: cert}); err != nil {\n\t\treturn fmt.Errorf(\"add: %v\", err)\n\t}\n\treturn verifyKey(agentClient)\n}\n\nfunc addCertToAgent(key crypto.PrivateKey, cert *ssh.Certificate) error {\n\tsshAgent := NewKeyring()\n\tif err := sshAgent.Add(AddedKey{PrivateKey: key, Certificate: cert}); err != nil {\n\t\treturn fmt.Errorf(\"add: %v\", err)\n\t}\n\treturn verifyKey(sshAgent)\n}\n\nfunc TestCertTypes(t *testing.T) {\n\tfor keyType, key := range testPublicKeys {\n\t\tcert := &ssh.Certificate{\n\t\t\tValidPrincipals: []string{\"gopher1\"},\n\t\t\tValidAfter:      0,\n\t\t\tValidBefore:     ssh.CertTimeInfinity,\n\t\t\tKey:             key,\n\t\t\tSerial:          1,\n\t\t\tCertType:        ssh.UserCert,\n\t\t\tSignatureKey:    testPublicKeys[\"rsa\"],\n\t\t\tPermissions: ssh.Permissions{\n\t\t\t\tCriticalOptions: map[string]string{},\n\t\t\t\tExtensions:      map[string]string{},\n\t\t\t},\n\t\t}\n\t\tif err := cert.SignCert(rand.Reader, testSigners[\"rsa\"]); err != nil {\n\t\t\tt.Fatalf(\"signcert: %v\", err)\n\t\t}\n\t\tif err := addCertToAgent(testPrivateKeys[keyType], cert); err != nil {\n\t\t\tt.Fatalf(\"%v\", err)\n\t\t}\n\t\tif err := addCertToAgentSock(testPrivateKeys[keyType], cert); err != nil {\n\t\t\tt.Fatalf(\"%v\", err)\n\t\t}\n\t}\n}\n", "// Copyright 2012 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage ssh\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n\t\"sort\"\n\t\"time\"\n)\n\n// These constants from [PROTOCOL.certkeys] represent the algorithm names\n// for certificate types supported by this package.\nconst (\n\tCertAlgoRSAv01      = \"ssh-rsa-cert-v01@openssh.com\"\n\tCertAlgoDSAv01      = \"ssh-dss-cert-v01@openssh.com\"\n\tCertAlgoECDSA256v01 = \"ecdsa-sha2-nistp256-cert-v01@openssh.com\"\n\tCertAlgoECDSA384v01 = \"ecdsa-sha2-nistp384-cert-v01@openssh.com\"\n\tCertAlgoECDSA521v01 = \"ecdsa-sha2-nistp521-cert-v01@openssh.com\"\n\tCertAlgoED25519v01  = \"ssh-ed25519-cert-v01@openssh.com\"\n)\n\n// Certificate types distinguish between host and user\n// certificates. The values can be set in the CertType field of\n// Certificate.\nconst (\n\tUserCert = 1\n\tHostCert = 2\n)\n\n// Signature represents a cryptographic signature.\ntype Signature struct {\n\tFormat string\n\tBlob   []byte\n}\n\n// CertTimeInfinity can be used for OpenSSHCertV01.ValidBefore to indicate that\n// a certificate does not expire.\nconst CertTimeInfinity = 1<<64 - 1\n\n// An Certificate represents an OpenSSH certificate as defined in\n// [PROTOCOL.certkeys]?rev=1.8.\ntype Certificate struct {\n\tNonce           []byte\n\tKey             PublicKey\n\tSerial          uint64\n\tCertType        uint32\n\tKeyId           string\n\tValidPrincipals []string\n\tValidAfter      uint64\n\tValidBefore     uint64\n\tPermissions\n\tReserved     []byte\n\tSignatureKey PublicKey\n\tSignature    *Signature\n}\n\n// genericCertData holds the key-independent part of the certificate data.\n// Overall, certificates contain an nonce, public key fields and\n// key-independent fields.\ntype genericCertData struct {\n\tSerial          uint64\n\tCertType        uint32\n\tKeyId           string\n\tValidPrincipals []byte\n\tValidAfter      uint64\n\tValidBefore     uint64\n\tCriticalOptions []byte\n\tExtensions      []byte\n\tReserved        []byte\n\tSignatureKey    []byte\n\tSignature       []byte\n}\n\nfunc marshalStringList(namelist []string) []byte {\n\tvar to []byte\n\tfor _, name := range namelist {\n\t\ts := struct{ N string }{name}\n\t\tto = append(to, Marshal(&s)...)\n\t}\n\treturn to\n}\n\ntype optionsTuple struct {\n\tKey   string\n\tValue []byte\n}\n\ntype optionsTupleValue struct {\n\tValue string\n}\n\n// serialize a map of critical options or extensions\n// issue #10569 - per [PROTOCOL.certkeys] and SSH implementation,\n// we need two length prefixes for a non-empty string value\nfunc marshalTuples(tups map[string]string) []byte {\n\tkeys := make([]string, 0, len(tups))\n\tfor key := range tups {\n\t\tkeys = append(keys, key)\n\t}\n\tsort.Strings(keys)\n\n\tvar ret []byte\n\tfor _, key := range keys {\n\t\ts := optionsTuple{Key: key}\n\t\tif value := tups[key]; len(value) > 0 {\n\t\t\ts.Value = Marshal(&optionsTupleValue{value})\n\t\t}\n\t\tret = append(ret, Marshal(&s)...)\n\t}\n\treturn ret\n}\n\n// issue #10569 - per [PROTOCOL.certkeys] and SSH implementation,\n// we need two length prefixes for a non-empty option value\nfunc parseTuples(in []byte) (map[string]string, error) {\n\ttups := map[string]string{}\n\tvar lastKey string\n\tvar haveLastKey bool\n\n\tfor len(in) > 0 {\n\t\tvar key, val, extra []byte\n\t\tvar ok bool\n\n\t\tif key, in, ok = parseString(in); !ok {\n\t\t\treturn nil, errShortRead\n\t\t}\n\t\tkeyStr := string(key)\n\t\t// according to [PROTOCOL.certkeys], the names must be in\n\t\t// lexical order.\n\t\tif haveLastKey && keyStr <= lastKey {\n\t\t\treturn nil, fmt.Errorf(\"ssh: certificate options are not in lexical order\")\n\t\t}\n\t\tlastKey, haveLastKey = keyStr, true\n\t\t// the next field is a data field, which if non-empty has a string embedded\n\t\tif val, in, ok = parseString(in); !ok {\n\t\t\treturn nil, errShortRead\n\t\t}\n\t\tif len(val) > 0 {\n\t\t\tval, extra, ok = parseString(val)\n\t\t\tif !ok {\n\t\t\t\treturn nil, errShortRead\n\t\t\t}\n\t\t\tif len(extra) > 0 {\n\t\t\t\treturn nil, fmt.Errorf(\"ssh: unexpected trailing data after certificate option value\")\n\t\t\t}\n\t\t\ttups[keyStr] = string(val)\n\t\t} else {\n\t\t\ttups[keyStr] = \"\"\n\t\t}\n\t}\n\treturn tups, nil\n}\n\nfunc parseCert(in []byte, privAlgo string) (*Certificate, error) {\n\tnonce, rest, ok := parseString(in)\n\tif !ok {\n\t\treturn nil, errShortRead\n\t}\n\n\tkey, rest, err := parsePubKey(rest, privAlgo)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar g genericCertData\n\tif err := Unmarshal(rest, &g); err != nil {\n\t\treturn nil, err\n\t}\n\n\tc := &Certificate{\n\t\tNonce:       nonce,\n\t\tKey:         key,\n\t\tSerial:      g.Serial,\n\t\tCertType:    g.CertType,\n\t\tKeyId:       g.KeyId,\n\t\tValidAfter:  g.ValidAfter,\n\t\tValidBefore: g.ValidBefore,\n\t}\n\n\tfor principals := g.ValidPrincipals; len(principals) > 0; {\n\t\tprincipal, rest, ok := parseString(principals)\n\t\tif !ok {\n\t\t\treturn nil, errShortRead\n\t\t}\n\t\tc.ValidPrincipals = append(c.ValidPrincipals, string(principal))\n\t\tprincipals = rest\n\t}\n\n\tc.CriticalOptions, err = parseTuples(g.CriticalOptions)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tc.Extensions, err = parseTuples(g.Extensions)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tc.Reserved = g.Reserved\n\tk, err := ParsePublicKey(g.SignatureKey)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tc.SignatureKey = k\n\tc.Signature, rest, ok = parseSignatureBody(g.Signature)\n\tif !ok || len(rest) > 0 {\n\t\treturn nil, errors.New(\"ssh: signature parse error\")\n\t}\n\n\treturn c, nil\n}\n\ntype openSSHCertSigner struct {\n\tpub    *Certificate\n\tsigner Signer\n}\n\n// NewCertSigner returns a Signer that signs with the given Certificate, whose\n// private key is held by signer. It returns an error if the public key in cert\n// doesn't match the key used by signer.\nfunc NewCertSigner(cert *Certificate, signer Signer) (Signer, error) {\n\tif bytes.Compare(cert.Key.Marshal(), signer.PublicKey().Marshal()) != 0 {\n\t\treturn nil, errors.New(\"ssh: signer and cert have different public key\")\n\t}\n\n\treturn &openSSHCertSigner{cert, signer}, nil\n}\n\nfunc (s *openSSHCertSigner) Sign(rand io.Reader, data []byte) (*Signature, error) {\n\treturn s.signer.Sign(rand, data)\n}\n\nfunc (s *openSSHCertSigner) PublicKey() PublicKey {\n\treturn s.pub\n}\n\nconst sourceAddressCriticalOption = \"source-address\"\n\n// CertChecker does the work of verifying a certificate. Its methods\n// can be plugged into ClientConfig.HostKeyCallback and\n// ServerConfig.PublicKeyCallback. For the CertChecker to work,\n// minimally, the IsAuthority callback should be set.\ntype CertChecker struct {\n\t// SupportedCriticalOptions lists the CriticalOptions that the\n\t// server application layer understands. These are only used\n\t// for user certificates.\n\tSupportedCriticalOptions []string\n\n\t// IsAuthority should return true if the key is recognized as\n\t// an authority. This allows for certificates to be signed by other\n\t// certificates.\n\tIsAuthority func(auth PublicKey) bool\n\n\t// Clock is used for verifying time stamps. If nil, time.Now\n\t// is used.\n\tClock func() time.Time\n\n\t// UserKeyFallback is called when CertChecker.Authenticate encounters a\n\t// public key that is not a certificate. It must implement validation\n\t// of user keys or else, if nil, all such keys are rejected.\n\tUserKeyFallback func(conn ConnMetadata, key PublicKey) (*Permissions, error)\n\n\t// HostKeyFallback is called when CertChecker.CheckHostKey encounters a\n\t// public key that is not a certificate. It must implement host key\n\t// validation or else, if nil, all such keys are rejected.\n\tHostKeyFallback func(addr string, remote net.Addr, key PublicKey) error\n\n\t// IsRevoked is called for each certificate so that revocation checking\n\t// can be implemented. It should return true if the given certificate\n\t// is revoked and false otherwise. If nil, no certificates are\n\t// considered to have been revoked.\n\tIsRevoked func(cert *Certificate) bool\n}\n\n// CheckHostKey checks a host key certificate. This method can be\n// plugged into ClientConfig.HostKeyCallback.\nfunc (c *CertChecker) CheckHostKey(addr string, remote net.Addr, key PublicKey) error {\n\tcert, ok := key.(*Certificate)\n\tif !ok {\n\t\tif c.HostKeyFallback != nil {\n\t\t\treturn c.HostKeyFallback(addr, remote, key)\n\t\t}\n\t\treturn errors.New(\"ssh: non-certificate host key\")\n\t}\n\tif cert.CertType != HostCert {\n\t\treturn fmt.Errorf(\"ssh: certificate presented as a host key has type %d\", cert.CertType)\n\t}\n\n\treturn c.CheckCert(addr, cert)\n}\n\n// Authenticate checks a user certificate. Authenticate can be used as\n// a value for ServerConfig.PublicKeyCallback.\nfunc (c *CertChecker) Authenticate(conn ConnMetadata, pubKey PublicKey) (*Permissions, error) {\n\tcert, ok := pubKey.(*Certificate)\n\tif !ok {\n\t\tif c.UserKeyFallback != nil {\n\t\t\treturn c.UserKeyFallback(conn, pubKey)\n\t\t}\n\t\treturn nil, errors.New(\"ssh: normal key pairs not accepted\")\n\t}\n\n\tif cert.CertType != UserCert {\n\t\treturn nil, fmt.Errorf(\"ssh: cert has type %d\", cert.CertType)\n\t}\n\n\tif err := c.CheckCert(conn.User(), cert); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &cert.Permissions, nil\n}\n\n// CheckCert checks CriticalOptions, ValidPrincipals, revocation, timestamp and\n// the signature of the certificate.\nfunc (c *CertChecker) CheckCert(principal string, cert *Certificate) error {\n\tif c.IsRevoked != nil && c.IsRevoked(cert) {\n\t\treturn fmt.Errorf(\"ssh: certicate serial %d revoked\", cert.Serial)\n\t}\n\n\tfor opt, _ := range cert.CriticalOptions {\n\t\t// sourceAddressCriticalOption will be enforced by\n\t\t// serverAuthenticate\n\t\tif opt == sourceAddressCriticalOption {\n\t\t\tcontinue\n\t\t}\n\n\t\tfound := false\n\t\tfor _, supp := range c.SupportedCriticalOptions {\n\t\t\tif supp == opt {\n\t\t\t\tfound = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !found {\n\t\t\treturn fmt.Errorf(\"ssh: unsupported critical option %q in certificate\", opt)\n\t\t}\n\t}\n\n\tif len(cert.ValidPrincipals) > 0 {\n\t\t// By default, certs are valid for all users/hosts.\n\t\tfound := false\n\t\tfor _, p := range cert.ValidPrincipals {\n\t\t\tif p == principal {\n\t\t\t\tfound = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !found {\n\t\t\treturn fmt.Errorf(\"ssh: principal %q not in the set of valid principals for given certificate: %q\", principal, cert.ValidPrincipals)\n\t\t}\n\t}\n\n\tif !c.IsAuthority(cert.SignatureKey) {\n\t\treturn fmt.Errorf(\"ssh: certificate signed by unrecognized authority\")\n\t}\n\n\tclock := c.Clock\n\tif clock == nil {\n\t\tclock = time.Now\n\t}\n\n\tunixNow := clock().Unix()\n\tif after := int64(cert.ValidAfter); after < 0 || unixNow < int64(cert.ValidAfter) {\n\t\treturn fmt.Errorf(\"ssh: cert is not yet valid\")\n\t}\n\tif before := int64(cert.ValidBefore); cert.ValidBefore != uint64(CertTimeInfinity) && (unixNow >= before || before < 0) {\n\t\treturn fmt.Errorf(\"ssh: cert has expired\")\n\t}\n\tif err := cert.SignatureKey.Verify(cert.bytesForSigning(), cert.Signature); err != nil {\n\t\treturn fmt.Errorf(\"ssh: certificate signature does not verify\")\n\t}\n\n\treturn nil\n}\n\n// SignCert sets c.SignatureKey to the authority's public key and stores a\n// Signature, by authority, in the certificate.\nfunc (c *Certificate) SignCert(rand io.Reader, authority Signer) error {\n\tc.Nonce = make([]byte, 32)\n\tif _, err := io.ReadFull(rand, c.Nonce); err != nil {\n\t\treturn err\n\t}\n\tc.SignatureKey = authority.PublicKey()\n\n\tsig, err := authority.Sign(rand, c.bytesForSigning())\n\tif err != nil {\n\t\treturn err\n\t}\n\tc.Signature = sig\n\treturn nil\n}\n\nvar certAlgoNames = map[string]string{\n\tKeyAlgoRSA:      CertAlgoRSAv01,\n\tKeyAlgoDSA:      CertAlgoDSAv01,\n\tKeyAlgoECDSA256: CertAlgoECDSA256v01,\n\tKeyAlgoECDSA384: CertAlgoECDSA384v01,\n\tKeyAlgoECDSA521: CertAlgoECDSA521v01,\n\tKeyAlgoED25519:  CertAlgoED25519v01,\n}\n\n// certToPrivAlgo returns the underlying algorithm for a certificate algorithm.\n// Panics if a non-certificate algorithm is passed.\nfunc certToPrivAlgo(algo string) string {\n\tfor privAlgo, pubAlgo := range certAlgoNames {\n\t\tif pubAlgo == algo {\n\t\t\treturn privAlgo\n\t\t}\n\t}\n\tpanic(\"unknown cert algorithm\")\n}\n\nfunc (cert *Certificate) bytesForSigning() []byte {\n\tc2 := *cert\n\tc2.Signature = nil\n\tout := c2.Marshal()\n\t// Drop trailing signature length.\n\treturn out[:len(out)-4]\n}\n\n// Marshal serializes c into OpenSSH's wire format. It is part of the\n// PublicKey interface.\nfunc (c *Certificate) Marshal() []byte {\n\tgeneric := genericCertData{\n\t\tSerial:          c.Serial,\n\t\tCertType:        c.CertType,\n\t\tKeyId:           c.KeyId,\n\t\tValidPrincipals: marshalStringList(c.ValidPrincipals),\n\t\tValidAfter:      uint64(c.ValidAfter),\n\t\tValidBefore:     uint64(c.ValidBefore),\n\t\tCriticalOptions: marshalTuples(c.CriticalOptions),\n\t\tExtensions:      marshalTuples(c.Extensions),\n\t\tReserved:        c.Reserved,\n\t\tSignatureKey:    c.SignatureKey.Marshal(),\n\t}\n\tif c.Signature != nil {\n\t\tgeneric.Signature = Marshal(c.Signature)\n\t}\n\tgenericBytes := Marshal(&generic)\n\tkeyBytes := c.Key.Marshal()\n\t_, keyBytes, _ = parseString(keyBytes)\n\tprefix := Marshal(&struct {\n\t\tName  string\n\t\tNonce []byte\n\t\tKey   []byte `ssh:\"rest\"`\n\t}{c.Type(), c.Nonce, keyBytes})\n\n\tresult := make([]byte, 0, len(prefix)+len(genericBytes))\n\tresult = append(result, prefix...)\n\tresult = append(result, genericBytes...)\n\treturn result\n}\n\n// Type returns the key name. It is part of the PublicKey interface.\nfunc (c *Certificate) Type() string {\n\talgo, ok := certAlgoNames[c.Key.Type()]\n\tif !ok {\n\t\tpanic(\"unknown cert key type \" + c.Key.Type())\n\t}\n\treturn algo\n}\n\n// Verify verifies a signature against the certificate's public\n// key. It is part of the PublicKey interface.\nfunc (c *Certificate) Verify(data []byte, sig *Signature) error {\n\treturn c.Key.Verify(data, sig)\n}\n\nfunc parseSignatureBody(in []byte) (out *Signature, rest []byte, ok bool) {\n\tformat, in, ok := parseString(in)\n\tif !ok {\n\t\treturn\n\t}\n\n\tout = &Signature{\n\t\tFormat: string(format),\n\t}\n\n\tif out.Blob, in, ok = parseString(in); !ok {\n\t\treturn\n\t}\n\n\treturn out, in, ok\n}\n\nfunc parseSignature(in []byte) (out *Signature, rest []byte, ok bool) {\n\tsigBytes, rest, ok := parseString(in)\n\tif !ok {\n\t\treturn\n\t}\n\n\tout, trailing, ok := parseSignatureBody(sigBytes)\n\tif !ok || len(trailing) > 0 {\n\t\treturn nil, nil, false\n\t}\n\treturn\n}\n", "// Copyright 2011 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage ssh\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"net\"\n\t\"sync\"\n\t\"time\"\n)\n\n// Client implements a traditional SSH client that supports shells,\n// subprocesses, port forwarding and tunneled dialing.\ntype Client struct {\n\tConn\n\n\tforwards        forwardList // forwarded tcpip connections from the remote side\n\tmu              sync.Mutex\n\tchannelHandlers map[string]chan NewChannel\n}\n\n// HandleChannelOpen returns a channel on which NewChannel requests\n// for the given type are sent. If the type already is being handled,\n// nil is returned. The channel is closed when the connection is closed.\nfunc (c *Client) HandleChannelOpen(channelType string) <-chan NewChannel {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\tif c.channelHandlers == nil {\n\t\t// The SSH channel has been closed.\n\t\tc := make(chan NewChannel)\n\t\tclose(c)\n\t\treturn c\n\t}\n\n\tch := c.channelHandlers[channelType]\n\tif ch != nil {\n\t\treturn nil\n\t}\n\n\tch = make(chan NewChannel, chanSize)\n\tc.channelHandlers[channelType] = ch\n\treturn ch\n}\n\n// NewClient creates a Client on top of the given connection.\nfunc NewClient(c Conn, chans <-chan NewChannel, reqs <-chan *Request) *Client {\n\tconn := &Client{\n\t\tConn:            c,\n\t\tchannelHandlers: make(map[string]chan NewChannel, 1),\n\t}\n\n\tgo conn.handleGlobalRequests(reqs)\n\tgo conn.handleChannelOpens(chans)\n\tgo func() {\n\t\tconn.Wait()\n\t\tconn.forwards.closeAll()\n\t}()\n\tgo conn.forwards.handleChannels(conn.HandleChannelOpen(\"forwarded-tcpip\"))\n\treturn conn\n}\n\n// NewClientConn establishes an authenticated SSH connection using c\n// as the underlying transport.  The Request and NewChannel channels\n// must be serviced or the connection will hang.\nfunc NewClientConn(c net.Conn, addr string, config *ClientConfig) (Conn, <-chan NewChannel, <-chan *Request, error) {\n\tfullConf := *config\n\tfullConf.SetDefaults()\n\tconn := &connection{\n\t\tsshConn: sshConn{conn: c},\n\t}\n\n\tif err := conn.clientHandshake(addr, &fullConf); err != nil {\n\t\tc.Close()\n\t\treturn nil, nil, nil, fmt.Errorf(\"ssh: handshake failed: %v\", err)\n\t}\n\tconn.mux = newMux(conn.transport)\n\treturn conn, conn.mux.incomingChannels, conn.mux.incomingRequests, nil\n}\n\n// clientHandshake performs the client side key exchange. See RFC 4253 Section\n// 7.\nfunc (c *connection) clientHandshake(dialAddress string, config *ClientConfig) error {\n\tif config.ClientVersion != \"\" {\n\t\tc.clientVersion = []byte(config.ClientVersion)\n\t} else {\n\t\tc.clientVersion = []byte(packageVersion)\n\t}\n\tvar err error\n\tc.serverVersion, err = exchangeVersions(c.sshConn.conn, c.clientVersion)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tc.transport = newClientTransport(\n\t\tnewTransport(c.sshConn.conn, config.Rand, true /* is client */),\n\t\tc.clientVersion, c.serverVersion, config, dialAddress, c.sshConn.RemoteAddr())\n\tif err := c.transport.waitSession(); err != nil {\n\t\treturn err\n\t}\n\n\tc.sessionID = c.transport.getSessionID()\n\treturn c.clientAuthenticate(config)\n}\n\n// verifyHostKeySignature verifies the host key obtained in the key\n// exchange.\nfunc verifyHostKeySignature(hostKey PublicKey, result *kexResult) error {\n\tsig, rest, ok := parseSignatureBody(result.Signature)\n\tif len(rest) > 0 || !ok {\n\t\treturn errors.New(\"ssh: signature parse error\")\n\t}\n\n\treturn hostKey.Verify(result.H, sig)\n}\n\n// NewSession opens a new Session for this client. (A session is a remote\n// execution of a program.)\nfunc (c *Client) NewSession() (*Session, error) {\n\tch, in, err := c.OpenChannel(\"session\", nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn newSession(ch, in)\n}\n\nfunc (c *Client) handleGlobalRequests(incoming <-chan *Request) {\n\tfor r := range incoming {\n\t\t// This handles keepalive messages and matches\n\t\t// the behaviour of OpenSSH.\n\t\tr.Reply(false, nil)\n\t}\n}\n\n// handleChannelOpens channel open messages from the remote side.\nfunc (c *Client) handleChannelOpens(in <-chan NewChannel) {\n\tfor ch := range in {\n\t\tc.mu.Lock()\n\t\thandler := c.channelHandlers[ch.ChannelType()]\n\t\tc.mu.Unlock()\n\n\t\tif handler != nil {\n\t\t\thandler <- ch\n\t\t} else {\n\t\t\tch.Reject(UnknownChannelType, fmt.Sprintf(\"unknown channel type: %v\", ch.ChannelType()))\n\t\t}\n\t}\n\n\tc.mu.Lock()\n\tfor _, ch := range c.channelHandlers {\n\t\tclose(ch)\n\t}\n\tc.channelHandlers = nil\n\tc.mu.Unlock()\n}\n\n// Dial starts a client connection to the given SSH server. It is a\n// convenience function that connects to the given network address,\n// initiates the SSH handshake, and then sets up a Client.  For access\n// to incoming channels and requests, use net.Dial with NewClientConn\n// instead.\nfunc Dial(network, addr string, config *ClientConfig) (*Client, error) {\n\tconn, err := net.DialTimeout(network, addr, config.Timeout)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tc, chans, reqs, err := NewClientConn(conn, addr, config)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn NewClient(c, chans, reqs), nil\n}\n\n// A ClientConfig structure is used to configure a Client. It must not be\n// modified after having been passed to an SSH function.\ntype ClientConfig struct {\n\t// Config contains configuration that is shared between clients and\n\t// servers.\n\tConfig\n\n\t// User contains the username to authenticate as.\n\tUser string\n\n\t// Auth contains possible authentication methods to use with the\n\t// server. Only the first instance of a particular RFC 4252 method will\n\t// be used during authentication.\n\tAuth []AuthMethod\n\n\t// HostKeyCallback, if not nil, is called during the cryptographic\n\t// handshake to validate the server's host key. A nil HostKeyCallback\n\t// implies that all host keys are accepted.\n\tHostKeyCallback func(hostname string, remote net.Addr, key PublicKey) error\n\n\t// ClientVersion contains the version identification string that will\n\t// be used for the connection. If empty, a reasonable default is used.\n\tClientVersion string\n\n\t// HostKeyAlgorithms lists the key types that the client will\n\t// accept from the server as host key, in order of\n\t// preference. If empty, a reasonable default is used. Any\n\t// string returned from PublicKey.Type method may be used, or\n\t// any of the CertAlgoXxxx and KeyAlgoXxxx constants.\n\tHostKeyAlgorithms []string\n\n\t// Timeout is the maximum amount of time for the TCP connection to establish.\n\t//\n\t// A Timeout of zero means no timeout.\n\tTimeout time.Duration\n}\n", "// Copyright 2011 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage ssh\n\nimport (\n\t\"bytes\"\n\t\"crypto/rand\"\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n\t\"strings\"\n\t\"testing\"\n)\n\ntype keyboardInteractive map[string]string\n\nfunc (cr keyboardInteractive) Challenge(user string, instruction string, questions []string, echos []bool) ([]string, error) {\n\tvar answers []string\n\tfor _, q := range questions {\n\t\tanswers = append(answers, cr[q])\n\t}\n\treturn answers, nil\n}\n\n// reused internally by tests\nvar clientPassword = \"tiger\"\n\n// tryAuth runs a handshake with a given config against an SSH server\n// with config serverConfig\nfunc tryAuth(t *testing.T, config *ClientConfig) error {\n\tc1, c2, err := netPipe()\n\tif err != nil {\n\t\tt.Fatalf(\"netPipe: %v\", err)\n\t}\n\tdefer c1.Close()\n\tdefer c2.Close()\n\n\tcertChecker := CertChecker{\n\t\tIsAuthority: func(k PublicKey) bool {\n\t\t\treturn bytes.Equal(k.Marshal(), testPublicKeys[\"ecdsa\"].Marshal())\n\t\t},\n\t\tUserKeyFallback: func(conn ConnMetadata, key PublicKey) (*Permissions, error) {\n\t\t\tif conn.User() == \"testuser\" && bytes.Equal(key.Marshal(), testPublicKeys[\"rsa\"].Marshal()) {\n\t\t\t\treturn nil, nil\n\t\t\t}\n\n\t\t\treturn nil, fmt.Errorf(\"pubkey for %q not acceptable\", conn.User())\n\t\t},\n\t\tIsRevoked: func(c *Certificate) bool {\n\t\t\treturn c.Serial == 666\n\t\t},\n\t}\n\n\tserverConfig := &ServerConfig{\n\t\tPasswordCallback: func(conn ConnMetadata, pass []byte) (*Permissions, error) {\n\t\t\tif conn.User() == \"testuser\" && string(pass) == clientPassword {\n\t\t\t\treturn nil, nil\n\t\t\t}\n\t\t\treturn nil, errors.New(\"password auth failed\")\n\t\t},\n\t\tPublicKeyCallback: certChecker.Authenticate,\n\t\tKeyboardInteractiveCallback: func(conn ConnMetadata, challenge KeyboardInteractiveChallenge) (*Permissions, error) {\n\t\t\tans, err := challenge(\"user\",\n\t\t\t\t\"instruction\",\n\t\t\t\t[]string{\"question1\", \"question2\"},\n\t\t\t\t[]bool{true, true})\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tok := conn.User() == \"testuser\" && ans[0] == \"answer1\" && ans[1] == \"answer2\"\n\t\t\tif ok {\n\t\t\t\tchallenge(\"user\", \"motd\", nil, nil)\n\t\t\t\treturn nil, nil\n\t\t\t}\n\t\t\treturn nil, errors.New(\"keyboard-interactive failed\")\n\t\t},\n\t\tAuthLogCallback: func(conn ConnMetadata, method string, err error) {\n\t\t},\n\t}\n\tserverConfig.AddHostKey(testSigners[\"rsa\"])\n\n\tgo newServer(c1, serverConfig)\n\t_, _, _, err = NewClientConn(c2, \"\", config)\n\treturn err\n}\n\nfunc TestClientAuthPublicKey(t *testing.T) {\n\tconfig := &ClientConfig{\n\t\tUser: \"testuser\",\n\t\tAuth: []AuthMethod{\n\t\t\tPublicKeys(testSigners[\"rsa\"]),\n\t\t},\n\t}\n\tif err := tryAuth(t, config); err != nil {\n\t\tt.Fatalf(\"unable to dial remote side: %s\", err)\n\t}\n}\n\nfunc TestAuthMethodPassword(t *testing.T) {\n\tconfig := &ClientConfig{\n\t\tUser: \"testuser\",\n\t\tAuth: []AuthMethod{\n\t\t\tPassword(clientPassword),\n\t\t},\n\t}\n\n\tif err := tryAuth(t, config); err != nil {\n\t\tt.Fatalf(\"unable to dial remote side: %s\", err)\n\t}\n}\n\nfunc TestAuthMethodFallback(t *testing.T) {\n\tvar passwordCalled bool\n\tconfig := &ClientConfig{\n\t\tUser: \"testuser\",\n\t\tAuth: []AuthMethod{\n\t\t\tPublicKeys(testSigners[\"rsa\"]),\n\t\t\tPasswordCallback(\n\t\t\t\tfunc() (string, error) {\n\t\t\t\t\tpasswordCalled = true\n\t\t\t\t\treturn \"WRONG\", nil\n\t\t\t\t}),\n\t\t},\n\t}\n\n\tif err := tryAuth(t, config); err != nil {\n\t\tt.Fatalf(\"unable to dial remote side: %s\", err)\n\t}\n\n\tif passwordCalled {\n\t\tt.Errorf(\"password auth tried before public-key auth.\")\n\t}\n}\n\nfunc TestAuthMethodWrongPassword(t *testing.T) {\n\tconfig := &ClientConfig{\n\t\tUser: \"testuser\",\n\t\tAuth: []AuthMethod{\n\t\t\tPassword(\"wrong\"),\n\t\t\tPublicKeys(testSigners[\"rsa\"]),\n\t\t},\n\t}\n\n\tif err := tryAuth(t, config); err != nil {\n\t\tt.Fatalf(\"unable to dial remote side: %s\", err)\n\t}\n}\n\nfunc TestAuthMethodKeyboardInteractive(t *testing.T) {\n\tanswers := keyboardInteractive(map[string]string{\n\t\t\"question1\": \"answer1\",\n\t\t\"question2\": \"answer2\",\n\t})\n\tconfig := &ClientConfig{\n\t\tUser: \"testuser\",\n\t\tAuth: []AuthMethod{\n\t\t\tKeyboardInteractive(answers.Challenge),\n\t\t},\n\t}\n\n\tif err := tryAuth(t, config); err != nil {\n\t\tt.Fatalf(\"unable to dial remote side: %s\", err)\n\t}\n}\n\nfunc TestAuthMethodWrongKeyboardInteractive(t *testing.T) {\n\tanswers := keyboardInteractive(map[string]string{\n\t\t\"question1\": \"answer1\",\n\t\t\"question2\": \"WRONG\",\n\t})\n\tconfig := &ClientConfig{\n\t\tUser: \"testuser\",\n\t\tAuth: []AuthMethod{\n\t\t\tKeyboardInteractive(answers.Challenge),\n\t\t},\n\t}\n\n\tif err := tryAuth(t, config); err == nil {\n\t\tt.Fatalf(\"wrong answers should not have authenticated with KeyboardInteractive\")\n\t}\n}\n\n// the mock server will only authenticate ssh-rsa keys\nfunc TestAuthMethodInvalidPublicKey(t *testing.T) {\n\tconfig := &ClientConfig{\n\t\tUser: \"testuser\",\n\t\tAuth: []AuthMethod{\n\t\t\tPublicKeys(testSigners[\"dsa\"]),\n\t\t},\n\t}\n\n\tif err := tryAuth(t, config); err == nil {\n\t\tt.Fatalf(\"dsa private key should not have authenticated with rsa public key\")\n\t}\n}\n\n// the client should authenticate with the second key\nfunc TestAuthMethodRSAandDSA(t *testing.T) {\n\tconfig := &ClientConfig{\n\t\tUser: \"testuser\",\n\t\tAuth: []AuthMethod{\n\t\t\tPublicKeys(testSigners[\"dsa\"], testSigners[\"rsa\"]),\n\t\t},\n\t}\n\tif err := tryAuth(t, config); err != nil {\n\t\tt.Fatalf(\"client could not authenticate with rsa key: %v\", err)\n\t}\n}\n\nfunc TestClientHMAC(t *testing.T) {\n\tfor _, mac := range supportedMACs {\n\t\tconfig := &ClientConfig{\n\t\t\tUser: \"testuser\",\n\t\t\tAuth: []AuthMethod{\n\t\t\t\tPublicKeys(testSigners[\"rsa\"]),\n\t\t\t},\n\t\t\tConfig: Config{\n\t\t\t\tMACs: []string{mac},\n\t\t\t},\n\t\t}\n\t\tif err := tryAuth(t, config); err != nil {\n\t\t\tt.Fatalf(\"client could not authenticate with mac algo %s: %v\", mac, err)\n\t\t}\n\t}\n}\n\n// issue 4285.\nfunc TestClientUnsupportedCipher(t *testing.T) {\n\tconfig := &ClientConfig{\n\t\tUser: \"testuser\",\n\t\tAuth: []AuthMethod{\n\t\t\tPublicKeys(),\n\t\t},\n\t\tConfig: Config{\n\t\t\tCiphers: []string{\"aes128-cbc\"}, // not currently supported\n\t\t},\n\t}\n\tif err := tryAuth(t, config); err == nil {\n\t\tt.Errorf(\"expected no ciphers in common\")\n\t}\n}\n\nfunc TestClientUnsupportedKex(t *testing.T) {\n\tif os.Getenv(\"GO_BUILDER_NAME\") != \"\" {\n\t\tt.Skip(\"skipping known-flaky test on the Go build dashboard; see golang.org/issue/15198\")\n\t}\n\tconfig := &ClientConfig{\n\t\tUser: \"testuser\",\n\t\tAuth: []AuthMethod{\n\t\t\tPublicKeys(),\n\t\t},\n\t\tConfig: Config{\n\t\t\tKeyExchanges: []string{\"diffie-hellman-group-exchange-sha256\"}, // not currently supported\n\t\t},\n\t}\n\tif err := tryAuth(t, config); err == nil || !strings.Contains(err.Error(), \"common algorithm\") {\n\t\tt.Errorf(\"got %v, expected 'common algorithm'\", err)\n\t}\n}\n\nfunc TestClientLoginCert(t *testing.T) {\n\tcert := &Certificate{\n\t\tKey:         testPublicKeys[\"rsa\"],\n\t\tValidBefore: CertTimeInfinity,\n\t\tCertType:    UserCert,\n\t}\n\tcert.SignCert(rand.Reader, testSigners[\"ecdsa\"])\n\tcertSigner, err := NewCertSigner(cert, testSigners[\"rsa\"])\n\tif err != nil {\n\t\tt.Fatalf(\"NewCertSigner: %v\", err)\n\t}\n\n\tclientConfig := &ClientConfig{\n\t\tUser: \"user\",\n\t}\n\tclientConfig.Auth = append(clientConfig.Auth, PublicKeys(certSigner))\n\n\t// should succeed\n\tif err := tryAuth(t, clientConfig); err != nil {\n\t\tt.Errorf(\"cert login failed: %v\", err)\n\t}\n\n\t// corrupted signature\n\tcert.Signature.Blob[0]++\n\tif err := tryAuth(t, clientConfig); err == nil {\n\t\tt.Errorf(\"cert login passed with corrupted sig\")\n\t}\n\n\t// revoked\n\tcert.Serial = 666\n\tcert.SignCert(rand.Reader, testSigners[\"ecdsa\"])\n\tif err := tryAuth(t, clientConfig); err == nil {\n\t\tt.Errorf(\"revoked cert login succeeded\")\n\t}\n\tcert.Serial = 1\n\n\t// sign with wrong key\n\tcert.SignCert(rand.Reader, testSigners[\"dsa\"])\n\tif err := tryAuth(t, clientConfig); err == nil {\n\t\tt.Errorf(\"cert login passed with non-authoritative key\")\n\t}\n\n\t// host cert\n\tcert.CertType = HostCert\n\tcert.SignCert(rand.Reader, testSigners[\"ecdsa\"])\n\tif err := tryAuth(t, clientConfig); err == nil {\n\t\tt.Errorf(\"cert login passed with wrong type\")\n\t}\n\tcert.CertType = UserCert\n\n\t// principal specified\n\tcert.ValidPrincipals = []string{\"user\"}\n\tcert.SignCert(rand.Reader, testSigners[\"ecdsa\"])\n\tif err := tryAuth(t, clientConfig); err != nil {\n\t\tt.Errorf(\"cert login failed: %v\", err)\n\t}\n\n\t// wrong principal specified\n\tcert.ValidPrincipals = []string{\"fred\"}\n\tcert.SignCert(rand.Reader, testSigners[\"ecdsa\"])\n\tif err := tryAuth(t, clientConfig); err == nil {\n\t\tt.Errorf(\"cert login passed with wrong principal\")\n\t}\n\tcert.ValidPrincipals = nil\n\n\t// added critical option\n\tcert.CriticalOptions = map[string]string{\"root-access\": \"yes\"}\n\tcert.SignCert(rand.Reader, testSigners[\"ecdsa\"])\n\tif err := tryAuth(t, clientConfig); err == nil {\n\t\tt.Errorf(\"cert login passed with unrecognized critical option\")\n\t}\n\n\t// allowed source address\n\tcert.CriticalOptions = map[string]string{\"source-address\": \"127.0.0.42/24,::42/120\"}\n\tcert.SignCert(rand.Reader, testSigners[\"ecdsa\"])\n\tif err := tryAuth(t, clientConfig); err != nil {\n\t\tt.Errorf(\"cert login with source-address failed: %v\", err)\n\t}\n\n\t// disallowed source address\n\tcert.CriticalOptions = map[string]string{\"source-address\": \"127.0.0.42,::42\"}\n\tcert.SignCert(rand.Reader, testSigners[\"ecdsa\"])\n\tif err := tryAuth(t, clientConfig); err == nil {\n\t\tt.Errorf(\"cert login with source-address succeeded\")\n\t}\n}\n\nfunc testPermissionsPassing(withPermissions bool, t *testing.T) {\n\tserverConfig := &ServerConfig{\n\t\tPublicKeyCallback: func(conn ConnMetadata, key PublicKey) (*Permissions, error) {\n\t\t\tif conn.User() == \"nopermissions\" {\n\t\t\t\treturn nil, nil\n\t\t\t} else {\n\t\t\t\treturn &Permissions{}, nil\n\t\t\t}\n\t\t},\n\t}\n\tserverConfig.AddHostKey(testSigners[\"rsa\"])\n\n\tclientConfig := &ClientConfig{\n\t\tAuth: []AuthMethod{\n\t\t\tPublicKeys(testSigners[\"rsa\"]),\n\t\t},\n\t}\n\tif withPermissions {\n\t\tclientConfig.User = \"permissions\"\n\t} else {\n\t\tclientConfig.User = \"nopermissions\"\n\t}\n\n\tc1, c2, err := netPipe()\n\tif err != nil {\n\t\tt.Fatalf(\"netPipe: %v\", err)\n\t}\n\tdefer c1.Close()\n\tdefer c2.Close()\n\n\tgo NewClientConn(c2, \"\", clientConfig)\n\tserverConn, err := newServer(c1, serverConfig)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif p := serverConn.Permissions; (p != nil) != withPermissions {\n\t\tt.Fatalf(\"withPermissions is %t, but Permissions object is %#v\", withPermissions, p)\n\t}\n}\n\nfunc TestPermissionsPassing(t *testing.T) {\n\ttestPermissionsPassing(true, t)\n}\n\nfunc TestNoPermissionsPassing(t *testing.T) {\n\ttestPermissionsPassing(false, t)\n}\n\nfunc TestRetryableAuth(t *testing.T) {\n\tn := 0\n\tpasswords := []string{\"WRONG1\", \"WRONG2\"}\n\n\tconfig := &ClientConfig{\n\t\tUser: \"testuser\",\n\t\tAuth: []AuthMethod{\n\t\t\tRetryableAuthMethod(PasswordCallback(func() (string, error) {\n\t\t\t\tp := passwords[n]\n\t\t\t\tn++\n\t\t\t\treturn p, nil\n\t\t\t}), 2),\n\t\t\tPublicKeys(testSigners[\"rsa\"]),\n\t\t},\n\t}\n\n\tif err := tryAuth(t, config); err != nil {\n\t\tt.Fatalf(\"unable to dial remote side: %s\", err)\n\t}\n\tif n != 2 {\n\t\tt.Fatalf(\"Did not try all passwords\")\n\t}\n}\n\nfunc ExampleRetryableAuthMethod(t *testing.T) {\n\tuser := \"testuser\"\n\tNumberOfPrompts := 3\n\n\t// Normally this would be a callback that prompts the user to answer the\n\t// provided questions\n\tCb := func(user, instruction string, questions []string, echos []bool) (answers []string, err error) {\n\t\treturn []string{\"answer1\", \"answer2\"}, nil\n\t}\n\n\tconfig := &ClientConfig{\n\t\tUser: user,\n\t\tAuth: []AuthMethod{\n\t\t\tRetryableAuthMethod(KeyboardInteractiveChallenge(Cb), NumberOfPrompts),\n\t\t},\n\t}\n\n\tif err := tryAuth(t, config); err != nil {\n\t\tt.Fatalf(\"unable to dial remote side: %s\", err)\n\t}\n}\n\n// Test if username is received on server side when NoClientAuth is used\nfunc TestClientAuthNone(t *testing.T) {\n\tuser := \"testuser\"\n\tserverConfig := &ServerConfig{\n\t\tNoClientAuth: true,\n\t}\n\tserverConfig.AddHostKey(testSigners[\"rsa\"])\n\n\tclientConfig := &ClientConfig{\n\t\tUser: user,\n\t}\n\n\tc1, c2, err := netPipe()\n\tif err != nil {\n\t\tt.Fatalf(\"netPipe: %v\", err)\n\t}\n\tdefer c1.Close()\n\tdefer c2.Close()\n\n\tgo NewClientConn(c2, \"\", clientConfig)\n\tserverConn, err := newServer(c1, serverConfig)\n\tif err != nil {\n\t\tt.Fatalf(\"newServer: %v\", err)\n\t}\n\tif serverConn.User() != user {\n\t\tt.Fatalf(\"server: got %q, want %q\", serverConn.User(), user)\n\t}\n}\n", "// Copyright 2014 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage ssh\n\nimport (\n\t\"net\"\n\t\"testing\"\n)\n\nfunc testClientVersion(t *testing.T, config *ClientConfig, expected string) {\n\tclientConn, serverConn := net.Pipe()\n\tdefer clientConn.Close()\n\treceivedVersion := make(chan string, 1)\n\tgo func() {\n\t\tversion, err := readVersion(serverConn)\n\t\tif err != nil {\n\t\t\treceivedVersion <- \"\"\n\t\t} else {\n\t\t\treceivedVersion <- string(version)\n\t\t}\n\t\tserverConn.Close()\n\t}()\n\tNewClientConn(clientConn, \"\", config)\n\tactual := <-receivedVersion\n\tif actual != expected {\n\t\tt.Fatalf(\"got %s; want %s\", actual, expected)\n\t}\n}\n\nfunc TestCustomClientVersion(t *testing.T) {\n\tversion := \"Test-Client-Version-0.0\"\n\ttestClientVersion(t, &ClientConfig{ClientVersion: version}, version)\n}\n\nfunc TestDefaultClientVersion(t *testing.T) {\n\ttestClientVersion(t, &ClientConfig{}, packageVersion)\n}\n", "// Copyright 2011 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n/*\nPackage ssh implements an SSH client and server.\n\nSSH is a transport security protocol, an authentication protocol and a\nfamily of application protocols. The most typical application level\nprotocol is a remote shell and this is specifically implemented.  However,\nthe multiplexed nature of SSH is exposed to users that wish to support\nothers.\n\nReferences:\n  [PROTOCOL.certkeys]: http://cvsweb.openbsd.org/cgi-bin/cvsweb/src/usr.bin/ssh/PROTOCOL.certkeys?rev=HEAD\n  [SSH-PARAMETERS]:    http://www.iana.org/assignments/ssh-parameters/ssh-parameters.xml#ssh-parameters-1\n*/\npackage ssh // import \"golang.org/x/crypto/ssh\"\n", "// Copyright 2011 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage ssh_test\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"net\"\n\t\"net/http\"\n\n\t\"golang.org/x/crypto/ssh\"\n\t\"golang.org/x/crypto/ssh/terminal\"\n)\n\nfunc ExampleNewServerConn() {\n\t// Public key authentication is done by comparing\n\t// the public key of a received connection\n\t// with the entries in the authorized_keys file.\n\tauthorizedKeysBytes, err := ioutil.ReadFile(\"authorized_keys\")\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to load authorized_keys, err: %v\", err)\n\t}\n\n\tauthorizedKeysMap := map[string]bool{}\n\tfor len(authorizedKeysBytes) > 0 {\n\t\tpubKey, _, _, rest, err := ssh.ParseAuthorizedKey(authorizedKeysBytes)\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\n\t\tauthorizedKeysMap[string(pubKey.Marshal())] = true\n\t\tauthorizedKeysBytes = rest\n\t}\n\n\t// An SSH server is represented by a ServerConfig, which holds\n\t// certificate details and handles authentication of ServerConns.\n\tconfig := &ssh.ServerConfig{\n\t\t// Remove to disable password auth.\n\t\tPasswordCallback: func(c ssh.ConnMetadata, pass []byte) (*ssh.Permissions, error) {\n\t\t\t// Should use constant-time compare (or better, salt+hash) in\n\t\t\t// a production setting.\n\t\t\tif c.User() == \"testuser\" && string(pass) == \"tiger\" {\n\t\t\t\treturn nil, nil\n\t\t\t}\n\t\t\treturn nil, fmt.Errorf(\"password rejected for %q\", c.User())\n\t\t},\n\n\t\t// Remove to disable public key auth.\n\t\tPublicKeyCallback: func(c ssh.ConnMetadata, pubKey ssh.PublicKey) (*ssh.Permissions, error) {\n\t\t\tif authorizedKeysMap[string(pubKey.Marshal())] {\n\t\t\t\treturn nil, nil\n\t\t\t}\n\t\t\treturn nil, fmt.Errorf(\"unknown public key for %q\", c.User())\n\t\t},\n\t}\n\n\tprivateBytes, err := ioutil.ReadFile(\"id_rsa\")\n\tif err != nil {\n\t\tlog.Fatal(\"Failed to load private key: \", err)\n\t}\n\n\tprivate, err := ssh.ParsePrivateKey(privateBytes)\n\tif err != nil {\n\t\tlog.Fatal(\"Failed to parse private key: \", err)\n\t}\n\n\tconfig.AddHostKey(private)\n\n\t// Once a ServerConfig has been configured, connections can be\n\t// accepted.\n\tlistener, err := net.Listen(\"tcp\", \"0.0.0.0:2022\")\n\tif err != nil {\n\t\tlog.Fatal(\"failed to listen for connection: \", err)\n\t}\n\tnConn, err := listener.Accept()\n\tif err != nil {\n\t\tlog.Fatal(\"failed to accept incoming connection: \", err)\n\t}\n\n\t// Before use, a handshake must be performed on the incoming\n\t// net.Conn.\n\t_, chans, reqs, err := ssh.NewServerConn(nConn, config)\n\tif err != nil {\n\t\tlog.Fatal(\"failed to handshake: \", err)\n\t}\n\t// The incoming Request channel must be serviced.\n\tgo ssh.DiscardRequests(reqs)\n\n\t// Service the incoming Channel channel.\n\n\t// Service the incoming Channel channel.\n\tfor newChannel := range chans {\n\t\t// Channels have a type, depending on the application level\n\t\t// protocol intended. In the case of a shell, the type is\n\t\t// \"session\" and ServerShell may be used to present a simple\n\t\t// terminal interface.\n\t\tif newChannel.ChannelType() != \"session\" {\n\t\t\tnewChannel.Reject(ssh.UnknownChannelType, \"unknown channel type\")\n\t\t\tcontinue\n\t\t}\n\t\tchannel, requests, err := newChannel.Accept()\n\t\tif err != nil {\n\t\t\tlog.Fatalf(\"Could not accept channel: %v\", err)\n\t\t}\n\n\t\t// Sessions have out-of-band requests such as \"shell\",\n\t\t// \"pty-req\" and \"env\".  Here we handle only the\n\t\t// \"shell\" request.\n\t\tgo func(in <-chan *ssh.Request) {\n\t\t\tfor req := range in {\n\t\t\t\treq.Reply(req.Type == \"shell\", nil)\n\t\t\t}\n\t\t}(requests)\n\n\t\tterm := terminal.NewTerminal(channel, \"> \")\n\n\t\tgo func() {\n\t\t\tdefer channel.Close()\n\t\t\tfor {\n\t\t\t\tline, err := term.ReadLine()\n\t\t\t\tif err != nil {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tfmt.Println(line)\n\t\t\t}\n\t\t}()\n\t}\n}\n\nfunc ExampleDial() {\n\t// An SSH client is represented with a ClientConn.\n\t//\n\t// To authenticate with the remote server you must pass at least one\n\t// implementation of AuthMethod via the Auth field in ClientConfig.\n\tconfig := &ssh.ClientConfig{\n\t\tUser: \"username\",\n\t\tAuth: []ssh.AuthMethod{\n\t\t\tssh.Password(\"yourpassword\"),\n\t\t},\n\t}\n\tclient, err := ssh.Dial(\"tcp\", \"yourserver.com:22\", config)\n\tif err != nil {\n\t\tlog.Fatal(\"Failed to dial: \", err)\n\t}\n\n\t// Each ClientConn can support multiple interactive sessions,\n\t// represented by a Session.\n\tsession, err := client.NewSession()\n\tif err != nil {\n\t\tlog.Fatal(\"Failed to create session: \", err)\n\t}\n\tdefer session.Close()\n\n\t// Once a Session is created, you can execute a single command on\n\t// the remote side using the Run method.\n\tvar b bytes.Buffer\n\tsession.Stdout = &b\n\tif err := session.Run(\"/usr/bin/whoami\"); err != nil {\n\t\tlog.Fatal(\"Failed to run: \" + err.Error())\n\t}\n\tfmt.Println(b.String())\n}\n\nfunc ExamplePublicKeys() {\n\t// A public key may be used to authenticate against the remote\n\t// server by using an unencrypted PEM-encoded private key file.\n\t//\n\t// If you have an encrypted private key, the crypto/x509 package\n\t// can be used to decrypt it.\n\tkey, err := ioutil.ReadFile(\"/home/user/.ssh/id_rsa\")\n\tif err != nil {\n\t\tlog.Fatalf(\"unable to read private key: %v\", err)\n\t}\n\n\t// Create the Signer for this private key.\n\tsigner, err := ssh.ParsePrivateKey(key)\n\tif err != nil {\n\t\tlog.Fatalf(\"unable to parse private key: %v\", err)\n\t}\n\n\tconfig := &ssh.ClientConfig{\n\t\tUser: \"user\",\n\t\tAuth: []ssh.AuthMethod{\n\t\t\t// Use the PublicKeys method for remote authentication.\n\t\t\tssh.PublicKeys(signer),\n\t\t},\n\t}\n\n\t// Connect to the remote server and perform the SSH handshake.\n\tclient, err := ssh.Dial(\"tcp\", \"host.com:22\", config)\n\tif err != nil {\n\t\tlog.Fatalf(\"unable to connect: %v\", err)\n\t}\n\tdefer client.Close()\n}\n\nfunc ExampleClient_Listen() {\n\tconfig := &ssh.ClientConfig{\n\t\tUser: \"username\",\n\t\tAuth: []ssh.AuthMethod{\n\t\t\tssh.Password(\"password\"),\n\t\t},\n\t}\n\t// Dial your ssh server.\n\tconn, err := ssh.Dial(\"tcp\", \"localhost:22\", config)\n\tif err != nil {\n\t\tlog.Fatal(\"unable to connect: \", err)\n\t}\n\tdefer conn.Close()\n\n\t// Request the remote side to open port 8080 on all interfaces.\n\tl, err := conn.Listen(\"tcp\", \"0.0.0.0:8080\")\n\tif err != nil {\n\t\tlog.Fatal(\"unable to register tcp forward: \", err)\n\t}\n\tdefer l.Close()\n\n\t// Serve HTTP with your SSH server acting as a reverse proxy.\n\thttp.Serve(l, http.HandlerFunc(func(resp http.ResponseWriter, req *http.Request) {\n\t\tfmt.Fprintf(resp, \"Hello world!\\n\")\n\t}))\n}\n\nfunc ExampleSession_RequestPty() {\n\t// Create client config\n\tconfig := &ssh.ClientConfig{\n\t\tUser: \"username\",\n\t\tAuth: []ssh.AuthMethod{\n\t\t\tssh.Password(\"password\"),\n\t\t},\n\t}\n\t// Connect to ssh server\n\tconn, err := ssh.Dial(\"tcp\", \"localhost:22\", config)\n\tif err != nil {\n\t\tlog.Fatal(\"unable to connect: \", err)\n\t}\n\tdefer conn.Close()\n\t// Create a session\n\tsession, err := conn.NewSession()\n\tif err != nil {\n\t\tlog.Fatal(\"unable to create session: \", err)\n\t}\n\tdefer session.Close()\n\t// Set up terminal modes\n\tmodes := ssh.TerminalModes{\n\t\tssh.ECHO:          0,     // disable echoing\n\t\tssh.TTY_OP_ISPEED: 14400, // input speed = 14.4kbaud\n\t\tssh.TTY_OP_OSPEED: 14400, // output speed = 14.4kbaud\n\t}\n\t// Request pseudo terminal\n\tif err := session.RequestPty(\"xterm\", 40, 80, modes); err != nil {\n\t\tlog.Fatal(\"request for pseudo terminal failed: \", err)\n\t}\n\t// Start remote shell\n\tif err := session.Shell(); err != nil {\n\t\tlog.Fatal(\"failed to start shell: \", err)\n\t}\n}\n", "// Copyright 2013 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage ssh\n\nimport (\n\t\"crypto/rand\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"net\"\n\t\"sync\"\n)\n\n// debugHandshake, if set, prints messages sent and received.  Key\n// exchange messages are printed as if DH were used, so the debug\n// messages are wrong when using ECDH.\nconst debugHandshake = false\n\n// chanSize sets the amount of buffering SSH connections. This is\n// primarily for testing: setting chanSize=0 uncovers deadlocks more\n// quickly.\nconst chanSize = 16\n\n// keyingTransport is a packet based transport that supports key\n// changes. It need not be thread-safe. It should pass through\n// msgNewKeys in both directions.\ntype keyingTransport interface {\n\tpacketConn\n\n\t// prepareKeyChange sets up a key change. The key change for a\n\t// direction will be effected if a msgNewKeys message is sent\n\t// or received.\n\tprepareKeyChange(*algorithms, *kexResult) error\n}\n\n// handshakeTransport implements rekeying on top of a keyingTransport\n// and offers a thread-safe writePacket() interface.\ntype handshakeTransport struct {\n\tconn   keyingTransport\n\tconfig *Config\n\n\tserverVersion []byte\n\tclientVersion []byte\n\n\t// hostKeys is non-empty if we are the server. In that case,\n\t// it contains all host keys that can be used to sign the\n\t// connection.\n\thostKeys []Signer\n\n\t// hostKeyAlgorithms is non-empty if we are the client. In that case,\n\t// we accept these key types from the server as host key.\n\thostKeyAlgorithms []string\n\n\t// On read error, incoming is closed, and readError is set.\n\tincoming  chan []byte\n\treadError error\n\n\tmu             sync.Mutex\n\twriteError     error\n\tsentInitPacket []byte\n\tsentInitMsg    *kexInitMsg\n\tpendingPackets [][]byte // Used when a key exchange is in progress.\n\n\t// If the read loop wants to schedule a kex, it pings this\n\t// channel, and the write loop will send out a kex\n\t// message.\n\trequestKex chan struct{}\n\n\t// If the other side requests or confirms a kex, its kexInit\n\t// packet is sent here for the write loop to find it.\n\tstartKex chan *pendingKex\n\n\t// data for host key checking\n\thostKeyCallback func(hostname string, remote net.Addr, key PublicKey) error\n\tdialAddress     string\n\tremoteAddr      net.Addr\n\n\t// Algorithms agreed in the last key exchange.\n\talgorithms *algorithms\n\n\treadPacketsLeft uint32\n\treadBytesLeft   int64\n\n\twritePacketsLeft uint32\n\twriteBytesLeft   int64\n\n\t// The session ID or nil if first kex did not complete yet.\n\tsessionID []byte\n}\n\ntype pendingKex struct {\n\totherInit []byte\n\tdone      chan error\n}\n\nfunc newHandshakeTransport(conn keyingTransport, config *Config, clientVersion, serverVersion []byte) *handshakeTransport {\n\tt := &handshakeTransport{\n\t\tconn:          conn,\n\t\tserverVersion: serverVersion,\n\t\tclientVersion: clientVersion,\n\t\tincoming:      make(chan []byte, chanSize),\n\t\trequestKex:    make(chan struct{}, 1),\n\t\tstartKex:      make(chan *pendingKex, 1),\n\n\t\tconfig: config,\n\t}\n\n\t// We always start with a mandatory key exchange.\n\tt.requestKex <- struct{}{}\n\treturn t\n}\n\nfunc newClientTransport(conn keyingTransport, clientVersion, serverVersion []byte, config *ClientConfig, dialAddr string, addr net.Addr) *handshakeTransport {\n\tt := newHandshakeTransport(conn, &config.Config, clientVersion, serverVersion)\n\tt.dialAddress = dialAddr\n\tt.remoteAddr = addr\n\tt.hostKeyCallback = config.HostKeyCallback\n\tif config.HostKeyAlgorithms != nil {\n\t\tt.hostKeyAlgorithms = config.HostKeyAlgorithms\n\t} else {\n\t\tt.hostKeyAlgorithms = supportedHostKeyAlgos\n\t}\n\tgo t.readLoop()\n\tgo t.kexLoop()\n\treturn t\n}\n\nfunc newServerTransport(conn keyingTransport, clientVersion, serverVersion []byte, config *ServerConfig) *handshakeTransport {\n\tt := newHandshakeTransport(conn, &config.Config, clientVersion, serverVersion)\n\tt.hostKeys = config.hostKeys\n\tgo t.readLoop()\n\tgo t.kexLoop()\n\treturn t\n}\n\nfunc (t *handshakeTransport) getSessionID() []byte {\n\treturn t.sessionID\n}\n\n// waitSession waits for the session to be established. This should be\n// the first thing to call after instantiating handshakeTransport.\nfunc (t *handshakeTransport) waitSession() error {\n\tp, err := t.readPacket()\n\tif err != nil {\n\t\treturn err\n\t}\n\tif p[0] != msgNewKeys {\n\t\treturn fmt.Errorf(\"ssh: first packet should be msgNewKeys\")\n\t}\n\n\treturn nil\n}\n\nfunc (t *handshakeTransport) id() string {\n\tif len(t.hostKeys) > 0 {\n\t\treturn \"server\"\n\t}\n\treturn \"client\"\n}\n\nfunc (t *handshakeTransport) printPacket(p []byte, write bool) {\n\taction := \"got\"\n\tif write {\n\t\taction = \"sent\"\n\t}\n\n\tif p[0] == msgChannelData || p[0] == msgChannelExtendedData {\n\t\tlog.Printf(\"%s %s data (packet %d bytes)\", t.id(), action, len(p))\n\t} else {\n\t\tmsg, err := decode(p)\n\t\tlog.Printf(\"%s %s %T %v (%v)\", t.id(), action, msg, msg, err)\n\t}\n}\n\nfunc (t *handshakeTransport) readPacket() ([]byte, error) {\n\tp, ok := <-t.incoming\n\tif !ok {\n\t\treturn nil, t.readError\n\t}\n\treturn p, nil\n}\n\nfunc (t *handshakeTransport) readLoop() {\n\tfirst := true\n\tfor {\n\t\tp, err := t.readOnePacket(first)\n\t\tfirst = false\n\t\tif err != nil {\n\t\t\tt.readError = err\n\t\t\tclose(t.incoming)\n\t\t\tbreak\n\t\t}\n\t\tif p[0] == msgIgnore || p[0] == msgDebug {\n\t\t\tcontinue\n\t\t}\n\t\tt.incoming <- p\n\t}\n\n\t// Stop writers too.\n\tt.recordWriteError(t.readError)\n\n\t// Unblock the writer should it wait for this.\n\tclose(t.startKex)\n\n\t// Don't close t.requestKex; it's also written to from writePacket.\n}\n\nfunc (t *handshakeTransport) pushPacket(p []byte) error {\n\tif debugHandshake {\n\t\tt.printPacket(p, true)\n\t}\n\treturn t.conn.writePacket(p)\n}\n\nfunc (t *handshakeTransport) getWriteError() error {\n\tt.mu.Lock()\n\tdefer t.mu.Unlock()\n\treturn t.writeError\n}\n\nfunc (t *handshakeTransport) recordWriteError(err error) {\n\tt.mu.Lock()\n\tdefer t.mu.Unlock()\n\tif t.writeError == nil && err != nil {\n\t\tt.writeError = err\n\t}\n}\n\nfunc (t *handshakeTransport) requestKeyExchange() {\n\tselect {\n\tcase t.requestKex <- struct{}{}:\n\tdefault:\n\t\t// something already requested a kex, so do nothing.\n\t}\n}\n\nfunc (t *handshakeTransport) kexLoop() {\n\nwrite:\n\tfor t.getWriteError() == nil {\n\t\tvar request *pendingKex\n\t\tvar sent bool\n\n\t\tfor request == nil || !sent {\n\t\t\tvar ok bool\n\t\t\tselect {\n\t\t\tcase request, ok = <-t.startKex:\n\t\t\t\tif !ok {\n\t\t\t\t\tbreak write\n\t\t\t\t}\n\t\t\tcase <-t.requestKex:\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tif !sent {\n\t\t\t\tif err := t.sendKexInit(); err != nil {\n\t\t\t\t\tt.recordWriteError(err)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tsent = true\n\t\t\t}\n\t\t}\n\n\t\tif err := t.getWriteError(); err != nil {\n\t\t\tif request != nil {\n\t\t\t\trequest.done <- err\n\t\t\t}\n\t\t\tbreak\n\t\t}\n\n\t\t// We're not servicing t.requestKex, but that is OK:\n\t\t// we never block on sending to t.requestKex.\n\n\t\t// We're not servicing t.startKex, but the remote end\n\t\t// has just sent us a kexInitMsg, so it can't send\n\t\t// another key change request, until we close the done\n\t\t// channel on the pendingKex request.\n\n\t\terr := t.enterKeyExchange(request.otherInit)\n\n\t\tt.mu.Lock()\n\t\tt.writeError = err\n\t\tt.sentInitPacket = nil\n\t\tt.sentInitMsg = nil\n\t\tt.writePacketsLeft = packetRekeyThreshold\n\t\tif t.config.RekeyThreshold > 0 {\n\t\t\tt.writeBytesLeft = int64(t.config.RekeyThreshold)\n\t\t} else if t.algorithms != nil {\n\t\t\tt.writeBytesLeft = t.algorithms.w.rekeyBytes()\n\t\t}\n\n\t\t// we have completed the key exchange. Since the\n\t\t// reader is still blocked, it is safe to clear out\n\t\t// the requestKex channel. This avoids the situation\n\t\t// where: 1) we consumed our own request for the\n\t\t// initial kex, and 2) the kex from the remote side\n\t\t// caused another send on the requestKex channel,\n\tclear:\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-t.requestKex:\n\t\t\t\t//\n\t\t\tdefault:\n\t\t\t\tbreak clear\n\t\t\t}\n\t\t}\n\n\t\trequest.done <- t.writeError\n\n\t\t// kex finished. Push packets that we received while\n\t\t// the kex was in progress. Don't look at t.startKex\n\t\t// and don't increment writtenSinceKex: if we trigger\n\t\t// another kex while we are still busy with the last\n\t\t// one, things will become very confusing.\n\t\tfor _, p := range t.pendingPackets {\n\t\t\tt.writeError = t.pushPacket(p)\n\t\t\tif t.writeError != nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tt.pendingPackets = t.pendingPackets[:0]\n\t\tt.mu.Unlock()\n\t}\n\n\t// drain startKex channel. We don't service t.requestKex\n\t// because nobody does blocking sends there.\n\tgo func() {\n\t\tfor init := range t.startKex {\n\t\t\tinit.done <- t.writeError\n\t\t}\n\t}()\n\n\t// Unblock reader.\n\tt.conn.Close()\n}\n\n// The protocol uses uint32 for packet counters, so we can't let them\n// reach 1<<32.  We will actually read and write more packets than\n// this, though: the other side may send more packets, and after we\n// hit this limit on writing we will send a few more packets for the\n// key exchange itself.\nconst packetRekeyThreshold = (1 << 31)\n\nfunc (t *handshakeTransport) readOnePacket(first bool) ([]byte, error) {\n\tp, err := t.conn.readPacket()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif t.readPacketsLeft > 0 {\n\t\tt.readPacketsLeft--\n\t} else {\n\t\tt.requestKeyExchange()\n\t}\n\n\tif t.readBytesLeft > 0 {\n\t\tt.readBytesLeft -= int64(len(p))\n\t} else {\n\t\tt.requestKeyExchange()\n\t}\n\n\tif debugHandshake {\n\t\tt.printPacket(p, false)\n\t}\n\n\tif first && p[0] != msgKexInit {\n\t\treturn nil, fmt.Errorf(\"ssh: first packet should be msgKexInit\")\n\t}\n\n\tif p[0] != msgKexInit {\n\t\treturn p, nil\n\t}\n\n\tfirstKex := t.sessionID == nil\n\n\tkex := pendingKex{\n\t\tdone:      make(chan error, 1),\n\t\totherInit: p,\n\t}\n\tt.startKex <- &kex\n\terr = <-kex.done\n\n\tif debugHandshake {\n\t\tlog.Printf(\"%s exited key exchange (first %v), err %v\", t.id(), firstKex, err)\n\t}\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tt.readPacketsLeft = packetRekeyThreshold\n\tif t.config.RekeyThreshold > 0 {\n\t\tt.readBytesLeft = int64(t.config.RekeyThreshold)\n\t} else {\n\t\tt.readBytesLeft = t.algorithms.r.rekeyBytes()\n\t}\n\n\t// By default, a key exchange is hidden from higher layers by\n\t// translating it into msgIgnore.\n\tsuccessPacket := []byte{msgIgnore}\n\tif firstKex {\n\t\t// sendKexInit() for the first kex waits for\n\t\t// msgNewKeys so the authentication process is\n\t\t// guaranteed to happen over an encrypted transport.\n\t\tsuccessPacket = []byte{msgNewKeys}\n\t}\n\n\treturn successPacket, nil\n}\n\n// sendKexInit sends a key change message.\nfunc (t *handshakeTransport) sendKexInit() error {\n\tt.mu.Lock()\n\tdefer t.mu.Unlock()\n\tif t.sentInitMsg != nil {\n\t\t// kexInits may be sent either in response to the other side,\n\t\t// or because our side wants to initiate a key change, so we\n\t\t// may have already sent a kexInit. In that case, don't send a\n\t\t// second kexInit.\n\t\treturn nil\n\t}\n\n\tmsg := &kexInitMsg{\n\t\tKexAlgos:                t.config.KeyExchanges,\n\t\tCiphersClientServer:     t.config.Ciphers,\n\t\tCiphersServerClient:     t.config.Ciphers,\n\t\tMACsClientServer:        t.config.MACs,\n\t\tMACsServerClient:        t.config.MACs,\n\t\tCompressionClientServer: supportedCompressions,\n\t\tCompressionServerClient: supportedCompressions,\n\t}\n\tio.ReadFull(rand.Reader, msg.Cookie[:])\n\n\tif len(t.hostKeys) > 0 {\n\t\tfor _, k := range t.hostKeys {\n\t\t\tmsg.ServerHostKeyAlgos = append(\n\t\t\t\tmsg.ServerHostKeyAlgos, k.PublicKey().Type())\n\t\t}\n\t} else {\n\t\tmsg.ServerHostKeyAlgos = t.hostKeyAlgorithms\n\t}\n\tpacket := Marshal(msg)\n\n\t// writePacket destroys the contents, so save a copy.\n\tpacketCopy := make([]byte, len(packet))\n\tcopy(packetCopy, packet)\n\n\tif err := t.pushPacket(packetCopy); err != nil {\n\t\treturn err\n\t}\n\n\tt.sentInitMsg = msg\n\tt.sentInitPacket = packet\n\n\treturn nil\n}\n\nfunc (t *handshakeTransport) writePacket(p []byte) error {\n\tswitch p[0] {\n\tcase msgKexInit:\n\t\treturn errors.New(\"ssh: only handshakeTransport can send kexInit\")\n\tcase msgNewKeys:\n\t\treturn errors.New(\"ssh: only handshakeTransport can send newKeys\")\n\t}\n\n\tt.mu.Lock()\n\tdefer t.mu.Unlock()\n\tif t.writeError != nil {\n\t\treturn t.writeError\n\t}\n\n\tif t.sentInitMsg != nil {\n\t\t// Copy the packet so the writer can reuse the buffer.\n\t\tcp := make([]byte, len(p))\n\t\tcopy(cp, p)\n\t\tt.pendingPackets = append(t.pendingPackets, cp)\n\t\treturn nil\n\t}\n\n\tif t.writeBytesLeft > 0 {\n\t\tt.writeBytesLeft -= int64(len(p))\n\t} else {\n\t\tt.requestKeyExchange()\n\t}\n\n\tif t.writePacketsLeft > 0 {\n\t\tt.writePacketsLeft--\n\t} else {\n\t\tt.requestKeyExchange()\n\t}\n\n\tif err := t.pushPacket(p); err != nil {\n\t\tt.writeError = err\n\t}\n\n\treturn nil\n}\n\nfunc (t *handshakeTransport) Close() error {\n\treturn t.conn.Close()\n}\n\nfunc (t *handshakeTransport) enterKeyExchange(otherInitPacket []byte) error {\n\tif debugHandshake {\n\t\tlog.Printf(\"%s entered key exchange\", t.id())\n\t}\n\n\totherInit := &kexInitMsg{}\n\tif err := Unmarshal(otherInitPacket, otherInit); err != nil {\n\t\treturn err\n\t}\n\n\tmagics := handshakeMagics{\n\t\tclientVersion: t.clientVersion,\n\t\tserverVersion: t.serverVersion,\n\t\tclientKexInit: otherInitPacket,\n\t\tserverKexInit: t.sentInitPacket,\n\t}\n\n\tclientInit := otherInit\n\tserverInit := t.sentInitMsg\n\tif len(t.hostKeys) == 0 {\n\t\tclientInit, serverInit = serverInit, clientInit\n\n\t\tmagics.clientKexInit = t.sentInitPacket\n\t\tmagics.serverKexInit = otherInitPacket\n\t}\n\n\tvar err error\n\tt.algorithms, err = findAgreedAlgorithms(clientInit, serverInit)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// We don't send FirstKexFollows, but we handle receiving it.\n\t//\n\t// RFC 4253 section 7 defines the kex and the agreement method for\n\t// first_kex_packet_follows. It states that the guessed packet\n\t// should be ignored if the \"kex algorithm and/or the host\n\t// key algorithm is guessed wrong (server and client have\n\t// different preferred algorithm), or if any of the other\n\t// algorithms cannot be agreed upon\". The other algorithms have\n\t// already been checked above so the kex algorithm and host key\n\t// algorithm are checked here.\n\tif otherInit.FirstKexFollows && (clientInit.KexAlgos[0] != serverInit.KexAlgos[0] || clientInit.ServerHostKeyAlgos[0] != serverInit.ServerHostKeyAlgos[0]) {\n\t\t// other side sent a kex message for the wrong algorithm,\n\t\t// which we have to ignore.\n\t\tif _, err := t.conn.readPacket(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tkex, ok := kexAlgoMap[t.algorithms.kex]\n\tif !ok {\n\t\treturn fmt.Errorf(\"ssh: unexpected key exchange algorithm %v\", t.algorithms.kex)\n\t}\n\n\tvar result *kexResult\n\tif len(t.hostKeys) > 0 {\n\t\tresult, err = t.server(kex, t.algorithms, &magics)\n\t} else {\n\t\tresult, err = t.client(kex, t.algorithms, &magics)\n\t}\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif t.sessionID == nil {\n\t\tt.sessionID = result.H\n\t}\n\tresult.SessionID = t.sessionID\n\n\tt.conn.prepareKeyChange(t.algorithms, result)\n\tif err = t.conn.writePacket([]byte{msgNewKeys}); err != nil {\n\t\treturn err\n\t}\n\tif packet, err := t.conn.readPacket(); err != nil {\n\t\treturn err\n\t} else if packet[0] != msgNewKeys {\n\t\treturn unexpectedMessageError(msgNewKeys, packet[0])\n\t}\n\n\treturn nil\n}\n\nfunc (t *handshakeTransport) server(kex kexAlgorithm, algs *algorithms, magics *handshakeMagics) (*kexResult, error) {\n\tvar hostKey Signer\n\tfor _, k := range t.hostKeys {\n\t\tif algs.hostKey == k.PublicKey().Type() {\n\t\t\thostKey = k\n\t\t}\n\t}\n\n\tr, err := kex.Server(t.conn, t.config.Rand, magics, hostKey)\n\treturn r, err\n}\n\nfunc (t *handshakeTransport) client(kex kexAlgorithm, algs *algorithms, magics *handshakeMagics) (*kexResult, error) {\n\tresult, err := kex.Client(t.conn, t.config.Rand, magics)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\thostKey, err := ParsePublicKey(result.HostKey)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif err := verifyHostKeySignature(hostKey, result); err != nil {\n\t\treturn nil, err\n\t}\n\n\tif t.hostKeyCallback != nil {\n\t\terr = t.hostKeyCallback(t.dialAddress, t.remoteAddr, hostKey)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treturn result, nil\n}\n", "// Copyright 2013 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage ssh\n\nimport (\n\t\"bytes\"\n\t\"crypto/rand\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n\t\"reflect\"\n\t\"runtime\"\n\t\"strings\"\n\t\"sync\"\n\t\"testing\"\n)\n\ntype testChecker struct {\n\tcalls []string\n}\n\nfunc (t *testChecker) Check(dialAddr string, addr net.Addr, key PublicKey) error {\n\tif dialAddr == \"bad\" {\n\t\treturn fmt.Errorf(\"dialAddr is bad\")\n\t}\n\n\tif tcpAddr, ok := addr.(*net.TCPAddr); !ok || tcpAddr == nil {\n\t\treturn fmt.Errorf(\"testChecker: got %T want *net.TCPAddr\", addr)\n\t}\n\n\tt.calls = append(t.calls, fmt.Sprintf(\"%s %v %s %x\", dialAddr, addr, key.Type(), key.Marshal()))\n\n\treturn nil\n}\n\n// netPipe is analogous to net.Pipe, but it uses a real net.Conn, and\n// therefore is buffered (net.Pipe deadlocks if both sides start with\n// a write.)\nfunc netPipe() (net.Conn, net.Conn, error) {\n\tlistener, err := net.Listen(\"tcp\", \":0\")\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tdefer listener.Close()\n\tc1, err := net.Dial(\"tcp\", listener.Addr().String())\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tc2, err := listener.Accept()\n\tif err != nil {\n\t\tc1.Close()\n\t\treturn nil, nil, err\n\t}\n\n\treturn c1, c2, nil\n}\n\n// noiseTransport inserts ignore messages to check that the read loop\n// and the key exchange filters out these messages.\ntype noiseTransport struct {\n\tkeyingTransport\n}\n\nfunc (t *noiseTransport) writePacket(p []byte) error {\n\tignore := []byte{msgIgnore}\n\tif err := t.keyingTransport.writePacket(ignore); err != nil {\n\t\treturn err\n\t}\n\tdebug := []byte{msgDebug, 1, 2, 3}\n\tif err := t.keyingTransport.writePacket(debug); err != nil {\n\t\treturn err\n\t}\n\n\treturn t.keyingTransport.writePacket(p)\n}\n\nfunc addNoiseTransport(t keyingTransport) keyingTransport {\n\treturn &noiseTransport{t}\n}\n\n// handshakePair creates two handshakeTransports connected with each\n// other. If the noise argument is true, both transports will try to\n// confuse the other side by sending ignore and debug messages.\nfunc handshakePair(clientConf *ClientConfig, addr string, noise bool) (client *handshakeTransport, server *handshakeTransport, err error) {\n\ta, b, err := netPipe()\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar trC, trS keyingTransport\n\n\ttrC = newTransport(a, rand.Reader, true)\n\ttrS = newTransport(b, rand.Reader, false)\n\tif noise {\n\t\ttrC = addNoiseTransport(trC)\n\t\ttrS = addNoiseTransport(trS)\n\t}\n\tclientConf.SetDefaults()\n\n\tv := []byte(\"version\")\n\tclient = newClientTransport(trC, v, v, clientConf, addr, a.RemoteAddr())\n\n\tserverConf := &ServerConfig{}\n\tserverConf.AddHostKey(testSigners[\"ecdsa\"])\n\tserverConf.AddHostKey(testSigners[\"rsa\"])\n\tserverConf.SetDefaults()\n\tserver = newServerTransport(trS, v, v, serverConf)\n\n\tif err := server.waitSession(); err != nil {\n\t\treturn nil, nil, fmt.Errorf(\"server.waitSession: %v\", err)\n\t}\n\tif err := client.waitSession(); err != nil {\n\t\treturn nil, nil, fmt.Errorf(\"client.waitSession: %v\", err)\n\t}\n\n\treturn client, server, nil\n}\n\nfunc TestHandshakeBasic(t *testing.T) {\n\tif runtime.GOOS == \"plan9\" {\n\t\tt.Skip(\"see golang.org/issue/7237\")\n\t}\n\n\tchecker := &syncChecker{\n\t\twaitCall: make(chan int, 10),\n\t\tcalled:   make(chan int, 10),\n\t}\n\n\tchecker.waitCall <- 1\n\ttrC, trS, err := handshakePair(&ClientConfig{HostKeyCallback: checker.Check}, \"addr\", false)\n\tif err != nil {\n\t\tt.Fatalf(\"handshakePair: %v\", err)\n\t}\n\n\tdefer trC.Close()\n\tdefer trS.Close()\n\n\t// Let first kex complete normally.\n\t<-checker.called\n\n\tclientDone := make(chan int, 0)\n\tgotHalf := make(chan int, 0)\n\tconst N = 20\n\n\tgo func() {\n\t\tdefer close(clientDone)\n\t\t// Client writes a bunch of stuff, and does a key\n\t\t// change in the middle. This should not confuse the\n\t\t// handshake in progress. We do this twice, so we test\n\t\t// that the packet buffer is reset correctly.\n\t\tfor i := 0; i < N; i++ {\n\t\t\tp := []byte{msgRequestSuccess, byte(i)}\n\t\t\tif err := trC.writePacket(p); err != nil {\n\t\t\t\tt.Fatalf(\"sendPacket: %v\", err)\n\t\t\t}\n\t\t\tif (i % 10) == 5 {\n\t\t\t\t<-gotHalf\n\t\t\t\t// halfway through, we request a key change.\n\t\t\t\ttrC.requestKeyExchange()\n\n\t\t\t\t// Wait until we can be sure the key\n\t\t\t\t// change has really started before we\n\t\t\t\t// write more.\n\t\t\t\t<-checker.called\n\t\t\t}\n\t\t\tif (i % 10) == 7 {\n\t\t\t\t// write some packets until the kex\n\t\t\t\t// completes, to test buffering of\n\t\t\t\t// packets.\n\t\t\t\tchecker.waitCall <- 1\n\t\t\t}\n\t\t}\n\t}()\n\n\t// Server checks that client messages come in cleanly\n\ti := 0\n\terr = nil\n\tfor ; i < N; i++ {\n\t\tvar p []byte\n\t\tp, err = trS.readPacket()\n\t\tif err != nil {\n\t\t\tbreak\n\t\t}\n\t\tif (i % 10) == 5 {\n\t\t\tgotHalf <- 1\n\t\t}\n\n\t\twant := []byte{msgRequestSuccess, byte(i)}\n\t\tif bytes.Compare(p, want) != 0 {\n\t\t\tt.Errorf(\"message %d: got %v, want %v\", i, p, want)\n\t\t}\n\t}\n\t<-clientDone\n\tif err != nil && err != io.EOF {\n\t\tt.Fatalf(\"server error: %v\", err)\n\t}\n\tif i != N {\n\t\tt.Errorf(\"received %d messages, want 10.\", i)\n\t}\n\n\tclose(checker.called)\n\tif _, ok := <-checker.called; ok {\n\t\t// If all went well, we registered exactly 2 key changes: one\n\t\t// that establishes the session, and one that we requested\n\t\t// additionally.\n\t\tt.Fatalf(\"got another host key checks after 2 handshakes\")\n\t}\n}\n\nfunc TestForceFirstKex(t *testing.T) {\n\t// like handshakePair, but must access the keyingTransport.\n\tchecker := &testChecker{}\n\tclientConf := &ClientConfig{HostKeyCallback: checker.Check}\n\ta, b, err := netPipe()\n\tif err != nil {\n\t\tt.Fatalf(\"netPipe: %v\", err)\n\t}\n\n\tvar trC, trS keyingTransport\n\n\ttrC = newTransport(a, rand.Reader, true)\n\n\t// This is the disallowed packet:\n\ttrC.writePacket(Marshal(&serviceRequestMsg{serviceUserAuth}))\n\n\t// Rest of the setup.\n\ttrS = newTransport(b, rand.Reader, false)\n\tclientConf.SetDefaults()\n\n\tv := []byte(\"version\")\n\tclient := newClientTransport(trC, v, v, clientConf, \"addr\", a.RemoteAddr())\n\n\tserverConf := &ServerConfig{}\n\tserverConf.AddHostKey(testSigners[\"ecdsa\"])\n\tserverConf.AddHostKey(testSigners[\"rsa\"])\n\tserverConf.SetDefaults()\n\tserver := newServerTransport(trS, v, v, serverConf)\n\n\tdefer client.Close()\n\tdefer server.Close()\n\n\t// We setup the initial key exchange, but the remote side\n\t// tries to send serviceRequestMsg in cleartext, which is\n\t// disallowed.\n\n\tif err := server.waitSession(); err == nil {\n\t\tt.Errorf(\"server first kex init should reject unexpected packet\")\n\t}\n}\n\nfunc TestHandshakeAutoRekeyWrite(t *testing.T) {\n\tchecker := &syncChecker{\n\t\tcalled:   make(chan int, 10),\n\t\twaitCall: nil,\n\t}\n\tclientConf := &ClientConfig{HostKeyCallback: checker.Check}\n\tclientConf.RekeyThreshold = 500\n\ttrC, trS, err := handshakePair(clientConf, \"addr\", false)\n\tif err != nil {\n\t\tt.Fatalf(\"handshakePair: %v\", err)\n\t}\n\tdefer trC.Close()\n\tdefer trS.Close()\n\n\tinput := make([]byte, 251)\n\tinput[0] = msgRequestSuccess\n\n\tdone := make(chan int, 1)\n\tconst numPacket = 5\n\tgo func() {\n\t\tdefer close(done)\n\t\tj := 0\n\t\tfor ; j < numPacket; j++ {\n\t\t\tif p, err := trS.readPacket(); err != nil {\n\t\t\t\tbreak\n\t\t\t} else if !bytes.Equal(input, p) {\n\t\t\t\tt.Errorf(\"got packet type %d, want %d\", p[0], input[0])\n\t\t\t}\n\t\t}\n\n\t\tif j != numPacket {\n\t\t\tt.Errorf(\"got %d, want 5 messages\", j)\n\t\t}\n\t}()\n\n\t<-checker.called\n\n\tfor i := 0; i < numPacket; i++ {\n\t\tp := make([]byte, len(input))\n\t\tcopy(p, input)\n\t\tif err := trC.writePacket(p); err != nil {\n\t\t\tt.Errorf(\"writePacket: %v\", err)\n\t\t}\n\t\tif i == 2 {\n\t\t\t// Make sure the kex is in progress.\n\t\t\t<-checker.called\n\t\t}\n\n\t}\n\t<-done\n}\n\ntype syncChecker struct {\n\twaitCall chan int\n\tcalled   chan int\n}\n\nfunc (c *syncChecker) Check(dialAddr string, addr net.Addr, key PublicKey) error {\n\tc.called <- 1\n\tif c.waitCall != nil {\n\t\t<-c.waitCall\n\t}\n\treturn nil\n}\n\nfunc TestHandshakeAutoRekeyRead(t *testing.T) {\n\tsync := &syncChecker{\n\t\tcalled:   make(chan int, 2),\n\t\twaitCall: nil,\n\t}\n\tclientConf := &ClientConfig{\n\t\tHostKeyCallback: sync.Check,\n\t}\n\tclientConf.RekeyThreshold = 500\n\n\ttrC, trS, err := handshakePair(clientConf, \"addr\", false)\n\tif err != nil {\n\t\tt.Fatalf(\"handshakePair: %v\", err)\n\t}\n\tdefer trC.Close()\n\tdefer trS.Close()\n\n\tpacket := make([]byte, 501)\n\tpacket[0] = msgRequestSuccess\n\tif err := trS.writePacket(packet); err != nil {\n\t\tt.Fatalf(\"writePacket: %v\", err)\n\t}\n\n\t// While we read out the packet, a key change will be\n\t// initiated.\n\tdone := make(chan int, 1)\n\tgo func() {\n\t\tdefer close(done)\n\t\tif _, err := trC.readPacket(); err != nil {\n\t\t\tt.Fatalf(\"readPacket(client): %v\", err)\n\t\t}\n\n\t}()\n\n\t<-done\n\t<-sync.called\n}\n\n// errorKeyingTransport generates errors after a given number of\n// read/write operations.\ntype errorKeyingTransport struct {\n\tpacketConn\n\treadLeft, writeLeft int\n}\n\nfunc (n *errorKeyingTransport) prepareKeyChange(*algorithms, *kexResult) error {\n\treturn nil\n}\n\nfunc (n *errorKeyingTransport) getSessionID() []byte {\n\treturn nil\n}\n\nfunc (n *errorKeyingTransport) writePacket(packet []byte) error {\n\tif n.writeLeft == 0 {\n\t\tn.Close()\n\t\treturn errors.New(\"barf\")\n\t}\n\n\tn.writeLeft--\n\treturn n.packetConn.writePacket(packet)\n}\n\nfunc (n *errorKeyingTransport) readPacket() ([]byte, error) {\n\tif n.readLeft == 0 {\n\t\tn.Close()\n\t\treturn nil, errors.New(\"barf\")\n\t}\n\n\tn.readLeft--\n\treturn n.packetConn.readPacket()\n}\n\nfunc TestHandshakeErrorHandlingRead(t *testing.T) {\n\tfor i := 0; i < 20; i++ {\n\t\ttestHandshakeErrorHandlingN(t, i, -1, false)\n\t}\n}\n\nfunc TestHandshakeErrorHandlingWrite(t *testing.T) {\n\tfor i := 0; i < 20; i++ {\n\t\ttestHandshakeErrorHandlingN(t, -1, i, false)\n\t}\n}\n\nfunc TestHandshakeErrorHandlingReadCoupled(t *testing.T) {\n\tfor i := 0; i < 20; i++ {\n\t\ttestHandshakeErrorHandlingN(t, i, -1, true)\n\t}\n}\n\nfunc TestHandshakeErrorHandlingWriteCoupled(t *testing.T) {\n\tfor i := 0; i < 20; i++ {\n\t\ttestHandshakeErrorHandlingN(t, -1, i, true)\n\t}\n}\n\n// testHandshakeErrorHandlingN runs handshakes, injecting errors. If\n// handshakeTransport deadlocks, the go runtime will detect it and\n// panic.\nfunc testHandshakeErrorHandlingN(t *testing.T, readLimit, writeLimit int, coupled bool) {\n\tmsg := Marshal(&serviceRequestMsg{strings.Repeat(\"x\", int(minRekeyThreshold)/4)})\n\n\ta, b := memPipe()\n\tdefer a.Close()\n\tdefer b.Close()\n\n\tkey := testSigners[\"ecdsa\"]\n\tserverConf := Config{RekeyThreshold: minRekeyThreshold}\n\tserverConf.SetDefaults()\n\tserverConn := newHandshakeTransport(&errorKeyingTransport{a, readLimit, writeLimit}, &serverConf, []byte{'a'}, []byte{'b'})\n\tserverConn.hostKeys = []Signer{key}\n\tgo serverConn.readLoop()\n\tgo serverConn.kexLoop()\n\n\tclientConf := Config{RekeyThreshold: 10 * minRekeyThreshold}\n\tclientConf.SetDefaults()\n\tclientConn := newHandshakeTransport(&errorKeyingTransport{b, -1, -1}, &clientConf, []byte{'a'}, []byte{'b'})\n\tclientConn.hostKeyAlgorithms = []string{key.PublicKey().Type()}\n\tgo clientConn.readLoop()\n\tgo clientConn.kexLoop()\n\n\tvar wg sync.WaitGroup\n\n\tfor _, hs := range []packetConn{serverConn, clientConn} {\n\t\tif !coupled {\n\t\t\twg.Add(2)\n\t\t\tgo func(c packetConn) {\n\t\t\t\tfor i := 0; ; i++ {\n\t\t\t\t\tstr := fmt.Sprintf(\"%08x\", i) + strings.Repeat(\"x\", int(minRekeyThreshold)/4-8)\n\t\t\t\t\terr := c.writePacket(Marshal(&serviceRequestMsg{str}))\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\twg.Done()\n\t\t\t\tc.Close()\n\t\t\t}(hs)\n\t\t\tgo func(c packetConn) {\n\t\t\t\tfor {\n\t\t\t\t\t_, err := c.readPacket()\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\twg.Done()\n\t\t\t}(hs)\n\t\t} else {\n\t\t\twg.Add(1)\n\t\t\tgo func(c packetConn) {\n\t\t\t\tfor {\n\t\t\t\t\t_, err := c.readPacket()\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t\tif err := c.writePacket(msg); err != nil {\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\twg.Done()\n\t\t\t}(hs)\n\t\t}\n\t}\n\twg.Wait()\n}\n\nfunc TestDisconnect(t *testing.T) {\n\tif runtime.GOOS == \"plan9\" {\n\t\tt.Skip(\"see golang.org/issue/7237\")\n\t}\n\tchecker := &testChecker{}\n\ttrC, trS, err := handshakePair(&ClientConfig{HostKeyCallback: checker.Check}, \"addr\", false)\n\tif err != nil {\n\t\tt.Fatalf(\"handshakePair: %v\", err)\n\t}\n\n\tdefer trC.Close()\n\tdefer trS.Close()\n\n\ttrC.writePacket([]byte{msgRequestSuccess, 0, 0})\n\terrMsg := &disconnectMsg{\n\t\tReason:  42,\n\t\tMessage: \"such is life\",\n\t}\n\ttrC.writePacket(Marshal(errMsg))\n\ttrC.writePacket([]byte{msgRequestSuccess, 0, 0})\n\n\tpacket, err := trS.readPacket()\n\tif err != nil {\n\t\tt.Fatalf(\"readPacket 1: %v\", err)\n\t}\n\tif packet[0] != msgRequestSuccess {\n\t\tt.Errorf(\"got packet %v, want packet type %d\", packet, msgRequestSuccess)\n\t}\n\n\t_, err = trS.readPacket()\n\tif err == nil {\n\t\tt.Errorf(\"readPacket 2 succeeded\")\n\t} else if !reflect.DeepEqual(err, errMsg) {\n\t\tt.Errorf(\"got error %#v, want %#v\", err, errMsg)\n\t}\n\n\t_, err = trS.readPacket()\n\tif err == nil {\n\t\tt.Errorf(\"readPacket 3 succeeded\")\n\t}\n}\n", "// Copyright 2011 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage ssh\n\n// Session tests.\n\nimport (\n\t\"bytes\"\n\tcrypto_rand \"crypto/rand\"\n\t\"errors\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"math/rand\"\n\t\"net\"\n\t\"testing\"\n\n\t\"golang.org/x/crypto/ssh/terminal\"\n)\n\ntype serverType func(Channel, <-chan *Request, *testing.T)\n\n// dial constructs a new test server and returns a *ClientConn.\nfunc dial(handler serverType, t *testing.T) *Client {\n\tc1, c2, err := netPipe()\n\tif err != nil {\n\t\tt.Fatalf(\"netPipe: %v\", err)\n\t}\n\n\tgo func() {\n\t\tdefer c1.Close()\n\t\tconf := ServerConfig{\n\t\t\tNoClientAuth: true,\n\t\t}\n\t\tconf.AddHostKey(testSigners[\"rsa\"])\n\n\t\t_, chans, reqs, err := NewServerConn(c1, &conf)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Unable to handshake: %v\", err)\n\t\t}\n\t\tgo DiscardRequests(reqs)\n\n\t\tfor newCh := range chans {\n\t\t\tif newCh.ChannelType() != \"session\" {\n\t\t\t\tnewCh.Reject(UnknownChannelType, \"unknown channel type\")\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tch, inReqs, err := newCh.Accept()\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Accept: %v\", err)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tgo func() {\n\t\t\t\thandler(ch, inReqs, t)\n\t\t\t}()\n\t\t}\n\t}()\n\n\tconfig := &ClientConfig{\n\t\tUser: \"testuser\",\n\t}\n\n\tconn, chans, reqs, err := NewClientConn(c2, \"\", config)\n\tif err != nil {\n\t\tt.Fatalf(\"unable to dial remote side: %v\", err)\n\t}\n\n\treturn NewClient(conn, chans, reqs)\n}\n\n// Test a simple string is returned to session.Stdout.\nfunc TestSessionShell(t *testing.T) {\n\tconn := dial(shellHandler, t)\n\tdefer conn.Close()\n\tsession, err := conn.NewSession()\n\tif err != nil {\n\t\tt.Fatalf(\"Unable to request new session: %v\", err)\n\t}\n\tdefer session.Close()\n\tstdout := new(bytes.Buffer)\n\tsession.Stdout = stdout\n\tif err := session.Shell(); err != nil {\n\t\tt.Fatalf(\"Unable to execute command: %s\", err)\n\t}\n\tif err := session.Wait(); err != nil {\n\t\tt.Fatalf(\"Remote command did not exit cleanly: %v\", err)\n\t}\n\tactual := stdout.String()\n\tif actual != \"golang\" {\n\t\tt.Fatalf(\"Remote shell did not return expected string: expected=golang, actual=%s\", actual)\n\t}\n}\n\n// TODO(dfc) add support for Std{in,err}Pipe when the Server supports it.\n\n// Test a simple string is returned via StdoutPipe.\nfunc TestSessionStdoutPipe(t *testing.T) {\n\tconn := dial(shellHandler, t)\n\tdefer conn.Close()\n\tsession, err := conn.NewSession()\n\tif err != nil {\n\t\tt.Fatalf(\"Unable to request new session: %v\", err)\n\t}\n\tdefer session.Close()\n\tstdout, err := session.StdoutPipe()\n\tif err != nil {\n\t\tt.Fatalf(\"Unable to request StdoutPipe(): %v\", err)\n\t}\n\tvar buf bytes.Buffer\n\tif err := session.Shell(); err != nil {\n\t\tt.Fatalf(\"Unable to execute command: %v\", err)\n\t}\n\tdone := make(chan bool, 1)\n\tgo func() {\n\t\tif _, err := io.Copy(&buf, stdout); err != nil {\n\t\t\tt.Errorf(\"Copy of stdout failed: %v\", err)\n\t\t}\n\t\tdone <- true\n\t}()\n\tif err := session.Wait(); err != nil {\n\t\tt.Fatalf(\"Remote command did not exit cleanly: %v\", err)\n\t}\n\t<-done\n\tactual := buf.String()\n\tif actual != \"golang\" {\n\t\tt.Fatalf(\"Remote shell did not return expected string: expected=golang, actual=%s\", actual)\n\t}\n}\n\n// Test that a simple string is returned via the Output helper,\n// and that stderr is discarded.\nfunc TestSessionOutput(t *testing.T) {\n\tconn := dial(fixedOutputHandler, t)\n\tdefer conn.Close()\n\tsession, err := conn.NewSession()\n\tif err != nil {\n\t\tt.Fatalf(\"Unable to request new session: %v\", err)\n\t}\n\tdefer session.Close()\n\n\tbuf, err := session.Output(\"\") // cmd is ignored by fixedOutputHandler\n\tif err != nil {\n\t\tt.Error(\"Remote command did not exit cleanly:\", err)\n\t}\n\tw := \"this-is-stdout.\"\n\tg := string(buf)\n\tif g != w {\n\t\tt.Error(\"Remote command did not return expected string:\")\n\t\tt.Logf(\"want %q\", w)\n\t\tt.Logf(\"got  %q\", g)\n\t}\n}\n\n// Test that both stdout and stderr are returned\n// via the CombinedOutput helper.\nfunc TestSessionCombinedOutput(t *testing.T) {\n\tconn := dial(fixedOutputHandler, t)\n\tdefer conn.Close()\n\tsession, err := conn.NewSession()\n\tif err != nil {\n\t\tt.Fatalf(\"Unable to request new session: %v\", err)\n\t}\n\tdefer session.Close()\n\n\tbuf, err := session.CombinedOutput(\"\") // cmd is ignored by fixedOutputHandler\n\tif err != nil {\n\t\tt.Error(\"Remote command did not exit cleanly:\", err)\n\t}\n\tconst stdout = \"this-is-stdout.\"\n\tconst stderr = \"this-is-stderr.\"\n\tg := string(buf)\n\tif g != stdout+stderr && g != stderr+stdout {\n\t\tt.Error(\"Remote command did not return expected string:\")\n\t\tt.Logf(\"want %q, or %q\", stdout+stderr, stderr+stdout)\n\t\tt.Logf(\"got  %q\", g)\n\t}\n}\n\n// Test non-0 exit status is returned correctly.\nfunc TestExitStatusNonZero(t *testing.T) {\n\tconn := dial(exitStatusNonZeroHandler, t)\n\tdefer conn.Close()\n\tsession, err := conn.NewSession()\n\tif err != nil {\n\t\tt.Fatalf(\"Unable to request new session: %v\", err)\n\t}\n\tdefer session.Close()\n\tif err := session.Shell(); err != nil {\n\t\tt.Fatalf(\"Unable to execute command: %v\", err)\n\t}\n\terr = session.Wait()\n\tif err == nil {\n\t\tt.Fatalf(\"expected command to fail but it didn't\")\n\t}\n\te, ok := err.(*ExitError)\n\tif !ok {\n\t\tt.Fatalf(\"expected *ExitError but got %T\", err)\n\t}\n\tif e.ExitStatus() != 15 {\n\t\tt.Fatalf(\"expected command to exit with 15 but got %v\", e.ExitStatus())\n\t}\n}\n\n// Test 0 exit status is returned correctly.\nfunc TestExitStatusZero(t *testing.T) {\n\tconn := dial(exitStatusZeroHandler, t)\n\tdefer conn.Close()\n\tsession, err := conn.NewSession()\n\tif err != nil {\n\t\tt.Fatalf(\"Unable to request new session: %v\", err)\n\t}\n\tdefer session.Close()\n\n\tif err := session.Shell(); err != nil {\n\t\tt.Fatalf(\"Unable to execute command: %v\", err)\n\t}\n\terr = session.Wait()\n\tif err != nil {\n\t\tt.Fatalf(\"expected nil but got %v\", err)\n\t}\n}\n\n// Test exit signal and status are both returned correctly.\nfunc TestExitSignalAndStatus(t *testing.T) {\n\tconn := dial(exitSignalAndStatusHandler, t)\n\tdefer conn.Close()\n\tsession, err := conn.NewSession()\n\tif err != nil {\n\t\tt.Fatalf(\"Unable to request new session: %v\", err)\n\t}\n\tdefer session.Close()\n\tif err := session.Shell(); err != nil {\n\t\tt.Fatalf(\"Unable to execute command: %v\", err)\n\t}\n\terr = session.Wait()\n\tif err == nil {\n\t\tt.Fatalf(\"expected command to fail but it didn't\")\n\t}\n\te, ok := err.(*ExitError)\n\tif !ok {\n\t\tt.Fatalf(\"expected *ExitError but got %T\", err)\n\t}\n\tif e.Signal() != \"TERM\" || e.ExitStatus() != 15 {\n\t\tt.Fatalf(\"expected command to exit with signal TERM and status 15 but got signal %s and status %v\", e.Signal(), e.ExitStatus())\n\t}\n}\n\n// Test exit signal and status are both returned correctly.\nfunc TestKnownExitSignalOnly(t *testing.T) {\n\tconn := dial(exitSignalHandler, t)\n\tdefer conn.Close()\n\tsession, err := conn.NewSession()\n\tif err != nil {\n\t\tt.Fatalf(\"Unable to request new session: %v\", err)\n\t}\n\tdefer session.Close()\n\tif err := session.Shell(); err != nil {\n\t\tt.Fatalf(\"Unable to execute command: %v\", err)\n\t}\n\terr = session.Wait()\n\tif err == nil {\n\t\tt.Fatalf(\"expected command to fail but it didn't\")\n\t}\n\te, ok := err.(*ExitError)\n\tif !ok {\n\t\tt.Fatalf(\"expected *ExitError but got %T\", err)\n\t}\n\tif e.Signal() != \"TERM\" || e.ExitStatus() != 143 {\n\t\tt.Fatalf(\"expected command to exit with signal TERM and status 143 but got signal %s and status %v\", e.Signal(), e.ExitStatus())\n\t}\n}\n\n// Test exit signal and status are both returned correctly.\nfunc TestUnknownExitSignal(t *testing.T) {\n\tconn := dial(exitSignalUnknownHandler, t)\n\tdefer conn.Close()\n\tsession, err := conn.NewSession()\n\tif err != nil {\n\t\tt.Fatalf(\"Unable to request new session: %v\", err)\n\t}\n\tdefer session.Close()\n\tif err := session.Shell(); err != nil {\n\t\tt.Fatalf(\"Unable to execute command: %v\", err)\n\t}\n\terr = session.Wait()\n\tif err == nil {\n\t\tt.Fatalf(\"expected command to fail but it didn't\")\n\t}\n\te, ok := err.(*ExitError)\n\tif !ok {\n\t\tt.Fatalf(\"expected *ExitError but got %T\", err)\n\t}\n\tif e.Signal() != \"SYS\" || e.ExitStatus() != 128 {\n\t\tt.Fatalf(\"expected command to exit with signal SYS and status 128 but got signal %s and status %v\", e.Signal(), e.ExitStatus())\n\t}\n}\n\nfunc TestExitWithoutStatusOrSignal(t *testing.T) {\n\tconn := dial(exitWithoutSignalOrStatus, t)\n\tdefer conn.Close()\n\tsession, err := conn.NewSession()\n\tif err != nil {\n\t\tt.Fatalf(\"Unable to request new session: %v\", err)\n\t}\n\tdefer session.Close()\n\tif err := session.Shell(); err != nil {\n\t\tt.Fatalf(\"Unable to execute command: %v\", err)\n\t}\n\terr = session.Wait()\n\tif err == nil {\n\t\tt.Fatalf(\"expected command to fail but it didn't\")\n\t}\n\tif _, ok := err.(*ExitMissingError); !ok {\n\t\tt.Fatalf(\"got %T want *ExitMissingError\", err)\n\t}\n}\n\n// windowTestBytes is the number of bytes that we'll send to the SSH server.\nconst windowTestBytes = 16000 * 200\n\n// TestServerWindow writes random data to the server. The server is expected to echo\n// the same data back, which is compared against the original.\nfunc TestServerWindow(t *testing.T) {\n\torigBuf := bytes.NewBuffer(make([]byte, 0, windowTestBytes))\n\tio.CopyN(origBuf, crypto_rand.Reader, windowTestBytes)\n\torigBytes := origBuf.Bytes()\n\n\tconn := dial(echoHandler, t)\n\tdefer conn.Close()\n\tsession, err := conn.NewSession()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer session.Close()\n\tresult := make(chan []byte)\n\n\tgo func() {\n\t\tdefer close(result)\n\t\techoedBuf := bytes.NewBuffer(make([]byte, 0, windowTestBytes))\n\t\tserverStdout, err := session.StdoutPipe()\n\t\tif err != nil {\n\t\t\tt.Errorf(\"StdoutPipe failed: %v\", err)\n\t\t\treturn\n\t\t}\n\t\tn, err := copyNRandomly(\"stdout\", echoedBuf, serverStdout, windowTestBytes)\n\t\tif err != nil && err != io.EOF {\n\t\t\tt.Errorf(\"Read only %d bytes from server, expected %d: %v\", n, windowTestBytes, err)\n\t\t}\n\t\tresult <- echoedBuf.Bytes()\n\t}()\n\n\tserverStdin, err := session.StdinPipe()\n\tif err != nil {\n\t\tt.Fatalf(\"StdinPipe failed: %v\", err)\n\t}\n\twritten, err := copyNRandomly(\"stdin\", serverStdin, origBuf, windowTestBytes)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to copy origBuf to serverStdin: %v\", err)\n\t}\n\tif written != windowTestBytes {\n\t\tt.Fatalf(\"Wrote only %d of %d bytes to server\", written, windowTestBytes)\n\t}\n\n\techoedBytes := <-result\n\n\tif !bytes.Equal(origBytes, echoedBytes) {\n\t\tt.Fatalf(\"Echoed buffer differed from original, orig %d, echoed %d\", len(origBytes), len(echoedBytes))\n\t}\n}\n\n// Verify the client can handle a keepalive packet from the server.\nfunc TestClientHandlesKeepalives(t *testing.T) {\n\tconn := dial(channelKeepaliveSender, t)\n\tdefer conn.Close()\n\tsession, err := conn.NewSession()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer session.Close()\n\tif err := session.Shell(); err != nil {\n\t\tt.Fatalf(\"Unable to execute command: %v\", err)\n\t}\n\terr = session.Wait()\n\tif err != nil {\n\t\tt.Fatalf(\"expected nil but got: %v\", err)\n\t}\n}\n\ntype exitStatusMsg struct {\n\tStatus uint32\n}\n\ntype exitSignalMsg struct {\n\tSignal     string\n\tCoreDumped bool\n\tErrmsg     string\n\tLang       string\n}\n\nfunc handleTerminalRequests(in <-chan *Request) {\n\tfor req := range in {\n\t\tok := false\n\t\tswitch req.Type {\n\t\tcase \"shell\":\n\t\t\tok = true\n\t\t\tif len(req.Payload) > 0 {\n\t\t\t\t// We don't accept any commands, only the default shell.\n\t\t\t\tok = false\n\t\t\t}\n\t\tcase \"env\":\n\t\t\tok = true\n\t\t}\n\t\treq.Reply(ok, nil)\n\t}\n}\n\nfunc newServerShell(ch Channel, in <-chan *Request, prompt string) *terminal.Terminal {\n\tterm := terminal.NewTerminal(ch, prompt)\n\tgo handleTerminalRequests(in)\n\treturn term\n}\n\nfunc exitStatusZeroHandler(ch Channel, in <-chan *Request, t *testing.T) {\n\tdefer ch.Close()\n\t// this string is returned to stdout\n\tshell := newServerShell(ch, in, \"> \")\n\treadLine(shell, t)\n\tsendStatus(0, ch, t)\n}\n\nfunc exitStatusNonZeroHandler(ch Channel, in <-chan *Request, t *testing.T) {\n\tdefer ch.Close()\n\tshell := newServerShell(ch, in, \"> \")\n\treadLine(shell, t)\n\tsendStatus(15, ch, t)\n}\n\nfunc exitSignalAndStatusHandler(ch Channel, in <-chan *Request, t *testing.T) {\n\tdefer ch.Close()\n\tshell := newServerShell(ch, in, \"> \")\n\treadLine(shell, t)\n\tsendStatus(15, ch, t)\n\tsendSignal(\"TERM\", ch, t)\n}\n\nfunc exitSignalHandler(ch Channel, in <-chan *Request, t *testing.T) {\n\tdefer ch.Close()\n\tshell := newServerShell(ch, in, \"> \")\n\treadLine(shell, t)\n\tsendSignal(\"TERM\", ch, t)\n}\n\nfunc exitSignalUnknownHandler(ch Channel, in <-chan *Request, t *testing.T) {\n\tdefer ch.Close()\n\tshell := newServerShell(ch, in, \"> \")\n\treadLine(shell, t)\n\tsendSignal(\"SYS\", ch, t)\n}\n\nfunc exitWithoutSignalOrStatus(ch Channel, in <-chan *Request, t *testing.T) {\n\tdefer ch.Close()\n\tshell := newServerShell(ch, in, \"> \")\n\treadLine(shell, t)\n}\n\nfunc shellHandler(ch Channel, in <-chan *Request, t *testing.T) {\n\tdefer ch.Close()\n\t// this string is returned to stdout\n\tshell := newServerShell(ch, in, \"golang\")\n\treadLine(shell, t)\n\tsendStatus(0, ch, t)\n}\n\n// Ignores the command, writes fixed strings to stderr and stdout.\n// Strings are \"this-is-stdout.\" and \"this-is-stderr.\".\nfunc fixedOutputHandler(ch Channel, in <-chan *Request, t *testing.T) {\n\tdefer ch.Close()\n\t_, err := ch.Read(nil)\n\n\treq, ok := <-in\n\tif !ok {\n\t\tt.Fatalf(\"error: expected channel request, got: %#v\", err)\n\t\treturn\n\t}\n\n\t// ignore request, always send some text\n\treq.Reply(true, nil)\n\n\t_, err = io.WriteString(ch, \"this-is-stdout.\")\n\tif err != nil {\n\t\tt.Fatalf(\"error writing on server: %v\", err)\n\t}\n\t_, err = io.WriteString(ch.Stderr(), \"this-is-stderr.\")\n\tif err != nil {\n\t\tt.Fatalf(\"error writing on server: %v\", err)\n\t}\n\tsendStatus(0, ch, t)\n}\n\nfunc readLine(shell *terminal.Terminal, t *testing.T) {\n\tif _, err := shell.ReadLine(); err != nil && err != io.EOF {\n\t\tt.Errorf(\"unable to read line: %v\", err)\n\t}\n}\n\nfunc sendStatus(status uint32, ch Channel, t *testing.T) {\n\tmsg := exitStatusMsg{\n\t\tStatus: status,\n\t}\n\tif _, err := ch.SendRequest(\"exit-status\", false, Marshal(&msg)); err != nil {\n\t\tt.Errorf(\"unable to send status: %v\", err)\n\t}\n}\n\nfunc sendSignal(signal string, ch Channel, t *testing.T) {\n\tsig := exitSignalMsg{\n\t\tSignal:     signal,\n\t\tCoreDumped: false,\n\t\tErrmsg:     \"Process terminated\",\n\t\tLang:       \"en-GB-oed\",\n\t}\n\tif _, err := ch.SendRequest(\"exit-signal\", false, Marshal(&sig)); err != nil {\n\t\tt.Errorf(\"unable to send signal: %v\", err)\n\t}\n}\n\nfunc discardHandler(ch Channel, t *testing.T) {\n\tdefer ch.Close()\n\tio.Copy(ioutil.Discard, ch)\n}\n\nfunc echoHandler(ch Channel, in <-chan *Request, t *testing.T) {\n\tdefer ch.Close()\n\tif n, err := copyNRandomly(\"echohandler\", ch, ch, windowTestBytes); err != nil {\n\t\tt.Errorf(\"short write, wrote %d, expected %d: %v \", n, windowTestBytes, err)\n\t}\n}\n\n// copyNRandomly copies n bytes from src to dst. It uses a variable, and random,\n// buffer size to exercise more code paths.\nfunc copyNRandomly(title string, dst io.Writer, src io.Reader, n int) (int, error) {\n\tvar (\n\t\tbuf       = make([]byte, 32*1024)\n\t\twritten   int\n\t\tremaining = n\n\t)\n\tfor remaining > 0 {\n\t\tl := rand.Intn(1 << 15)\n\t\tif remaining < l {\n\t\t\tl = remaining\n\t\t}\n\t\tnr, er := src.Read(buf[:l])\n\t\tnw, ew := dst.Write(buf[:nr])\n\t\tremaining -= nw\n\t\twritten += nw\n\t\tif ew != nil {\n\t\t\treturn written, ew\n\t\t}\n\t\tif nr != nw {\n\t\t\treturn written, io.ErrShortWrite\n\t\t}\n\t\tif er != nil && er != io.EOF {\n\t\t\treturn written, er\n\t\t}\n\t}\n\treturn written, nil\n}\n\nfunc channelKeepaliveSender(ch Channel, in <-chan *Request, t *testing.T) {\n\tdefer ch.Close()\n\tshell := newServerShell(ch, in, \"> \")\n\treadLine(shell, t)\n\tif _, err := ch.SendRequest(\"keepalive@openssh.com\", true, nil); err != nil {\n\t\tt.Errorf(\"unable to send channel keepalive request: %v\", err)\n\t}\n\tsendStatus(0, ch, t)\n}\n\nfunc TestClientWriteEOF(t *testing.T) {\n\tconn := dial(simpleEchoHandler, t)\n\tdefer conn.Close()\n\n\tsession, err := conn.NewSession()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer session.Close()\n\tstdin, err := session.StdinPipe()\n\tif err != nil {\n\t\tt.Fatalf(\"StdinPipe failed: %v\", err)\n\t}\n\tstdout, err := session.StdoutPipe()\n\tif err != nil {\n\t\tt.Fatalf(\"StdoutPipe failed: %v\", err)\n\t}\n\n\tdata := []byte(`0000`)\n\t_, err = stdin.Write(data)\n\tif err != nil {\n\t\tt.Fatalf(\"Write failed: %v\", err)\n\t}\n\tstdin.Close()\n\n\tres, err := ioutil.ReadAll(stdout)\n\tif err != nil {\n\t\tt.Fatalf(\"Read failed: %v\", err)\n\t}\n\n\tif !bytes.Equal(data, res) {\n\t\tt.Fatalf(\"Read differed from write, wrote: %v, read: %v\", data, res)\n\t}\n}\n\nfunc simpleEchoHandler(ch Channel, in <-chan *Request, t *testing.T) {\n\tdefer ch.Close()\n\tdata, err := ioutil.ReadAll(ch)\n\tif err != nil {\n\t\tt.Errorf(\"handler read error: %v\", err)\n\t}\n\t_, err = ch.Write(data)\n\tif err != nil {\n\t\tt.Errorf(\"handler write error: %v\", err)\n\t}\n}\n\nfunc TestSessionID(t *testing.T) {\n\tc1, c2, err := netPipe()\n\tif err != nil {\n\t\tt.Fatalf(\"netPipe: %v\", err)\n\t}\n\tdefer c1.Close()\n\tdefer c2.Close()\n\n\tserverID := make(chan []byte, 1)\n\tclientID := make(chan []byte, 1)\n\n\tserverConf := &ServerConfig{\n\t\tNoClientAuth: true,\n\t}\n\tserverConf.AddHostKey(testSigners[\"ecdsa\"])\n\tclientConf := &ClientConfig{\n\t\tUser: \"user\",\n\t}\n\n\tgo func() {\n\t\tconn, chans, reqs, err := NewServerConn(c1, serverConf)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"server handshake: %v\", err)\n\t\t}\n\t\tserverID <- conn.SessionID()\n\t\tgo DiscardRequests(reqs)\n\t\tfor ch := range chans {\n\t\t\tch.Reject(Prohibited, \"\")\n\t\t}\n\t}()\n\n\tgo func() {\n\t\tconn, chans, reqs, err := NewClientConn(c2, \"\", clientConf)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"client handshake: %v\", err)\n\t\t}\n\t\tclientID <- conn.SessionID()\n\t\tgo DiscardRequests(reqs)\n\t\tfor ch := range chans {\n\t\t\tch.Reject(Prohibited, \"\")\n\t\t}\n\t}()\n\n\ts := <-serverID\n\tc := <-clientID\n\tif bytes.Compare(s, c) != 0 {\n\t\tt.Errorf(\"server session ID (%x) != client session ID (%x)\", s, c)\n\t} else if len(s) == 0 {\n\t\tt.Errorf(\"client and server SessionID were empty.\")\n\t}\n}\n\ntype noReadConn struct {\n\treadSeen bool\n\tnet.Conn\n}\n\nfunc (c *noReadConn) Close() error {\n\treturn nil\n}\n\nfunc (c *noReadConn) Read(b []byte) (int, error) {\n\tc.readSeen = true\n\treturn 0, errors.New(\"noReadConn error\")\n}\n\nfunc TestInvalidServerConfiguration(t *testing.T) {\n\tc1, c2, err := netPipe()\n\tif err != nil {\n\t\tt.Fatalf(\"netPipe: %v\", err)\n\t}\n\tdefer c1.Close()\n\tdefer c2.Close()\n\n\tserveConn := noReadConn{Conn: c1}\n\tserverConf := &ServerConfig{}\n\n\tNewServerConn(&serveConn, serverConf)\n\tif serveConn.readSeen {\n\t\tt.Fatalf(\"NewServerConn attempted to Read() from Conn while configuration is missing host key\")\n\t}\n\n\tserverConf.AddHostKey(testSigners[\"ecdsa\"])\n\n\tNewServerConn(&serveConn, serverConf)\n\tif serveConn.readSeen {\n\t\tt.Fatalf(\"NewServerConn attempted to Read() from Conn while configuration is missing authentication method\")\n\t}\n}\n\nfunc TestHostKeyAlgorithms(t *testing.T) {\n\tserverConf := &ServerConfig{\n\t\tNoClientAuth: true,\n\t}\n\tserverConf.AddHostKey(testSigners[\"rsa\"])\n\tserverConf.AddHostKey(testSigners[\"ecdsa\"])\n\n\tconnect := func(clientConf *ClientConfig, want string) {\n\t\tvar alg string\n\t\tclientConf.HostKeyCallback = func(h string, a net.Addr, key PublicKey) error {\n\t\t\talg = key.Type()\n\t\t\treturn nil\n\t\t}\n\t\tc1, c2, err := netPipe()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"netPipe: %v\", err)\n\t\t}\n\t\tdefer c1.Close()\n\t\tdefer c2.Close()\n\n\t\tgo NewServerConn(c1, serverConf)\n\t\t_, _, _, err = NewClientConn(c2, \"\", clientConf)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"NewClientConn: %v\", err)\n\t\t}\n\t\tif alg != want {\n\t\t\tt.Errorf(\"selected key algorithm %s, want %s\", alg, want)\n\t\t}\n\t}\n\n\t// By default, we get the preferred algorithm, which is ECDSA 256.\n\n\tclientConf := &ClientConfig{}\n\tconnect(clientConf, KeyAlgoECDSA256)\n\n\t// Client asks for RSA explicitly.\n\tclientConf.HostKeyAlgorithms = []string{KeyAlgoRSA}\n\tconnect(clientConf, KeyAlgoRSA)\n\n\tc1, c2, err := netPipe()\n\tif err != nil {\n\t\tt.Fatalf(\"netPipe: %v\", err)\n\t}\n\tdefer c1.Close()\n\tdefer c2.Close()\n\n\tgo NewServerConn(c1, serverConf)\n\tclientConf.HostKeyAlgorithms = []string{\"nonexistent-hostkey-algo\"}\n\t_, _, _, err = NewClientConn(c2, \"\", clientConf)\n\tif err == nil {\n\t\tt.Fatal(\"succeeded connecting with unknown hostkey algorithm\")\n\t}\n}\n", "// Copyright 2014 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n// +build darwin dragonfly freebsd linux netbsd openbsd\n\npackage test\n\nimport (\n\t\"crypto/rand\"\n\t\"testing\"\n\n\t\"golang.org/x/crypto/ssh\"\n)\n\nfunc TestCertLogin(t *testing.T) {\n\ts := newServer(t)\n\tdefer s.Shutdown()\n\n\t// Use a key different from the default.\n\tclientKey := testSigners[\"dsa\"]\n\tcaAuthKey := testSigners[\"ecdsa\"]\n\tcert := &ssh.Certificate{\n\t\tKey:             clientKey.PublicKey(),\n\t\tValidPrincipals: []string{username()},\n\t\tCertType:        ssh.UserCert,\n\t\tValidBefore:     ssh.CertTimeInfinity,\n\t}\n\tif err := cert.SignCert(rand.Reader, caAuthKey); err != nil {\n\t\tt.Fatalf(\"SetSignature: %v\", err)\n\t}\n\n\tcertSigner, err := ssh.NewCertSigner(cert, clientKey)\n\tif err != nil {\n\t\tt.Fatalf(\"NewCertSigner: %v\", err)\n\t}\n\n\tconf := &ssh.ClientConfig{\n\t\tUser: username(),\n\t}\n\tconf.Auth = append(conf.Auth, ssh.PublicKeys(certSigner))\n\tclient, err := s.TryDial(conf)\n\tif err != nil {\n\t\tt.Fatalf(\"TryDial: %v\", err)\n\t}\n\tclient.Close()\n}\n"], "fixing_code": ["// Copyright 2012 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage agent\n\nimport (\n\t\"bytes\"\n\t\"crypto/rand\"\n\t\"errors\"\n\t\"net\"\n\t\"os\"\n\t\"os/exec\"\n\t\"path/filepath\"\n\t\"strconv\"\n\t\"testing\"\n\t\"time\"\n\n\t\"golang.org/x/crypto/ssh\"\n)\n\n// startAgent executes ssh-agent, and returns a Agent interface to it.\nfunc startAgent(t *testing.T) (client Agent, socket string, cleanup func()) {\n\tif testing.Short() {\n\t\t// ssh-agent is not always available, and the key\n\t\t// types supported vary by platform.\n\t\tt.Skip(\"skipping test due to -short\")\n\t}\n\n\tbin, err := exec.LookPath(\"ssh-agent\")\n\tif err != nil {\n\t\tt.Skip(\"could not find ssh-agent\")\n\t}\n\n\tcmd := exec.Command(bin, \"-s\")\n\tout, err := cmd.Output()\n\tif err != nil {\n\t\tt.Fatalf(\"cmd.Output: %v\", err)\n\t}\n\n\t/* Output looks like:\n\n\t\t   SSH_AUTH_SOCK=/tmp/ssh-P65gpcqArqvH/agent.15541; export SSH_AUTH_SOCK;\n\t           SSH_AGENT_PID=15542; export SSH_AGENT_PID;\n\t           echo Agent pid 15542;\n\t*/\n\tfields := bytes.Split(out, []byte(\";\"))\n\tline := bytes.SplitN(fields[0], []byte(\"=\"), 2)\n\tline[0] = bytes.TrimLeft(line[0], \"\\n\")\n\tif string(line[0]) != \"SSH_AUTH_SOCK\" {\n\t\tt.Fatalf(\"could not find key SSH_AUTH_SOCK in %q\", fields[0])\n\t}\n\tsocket = string(line[1])\n\n\tline = bytes.SplitN(fields[2], []byte(\"=\"), 2)\n\tline[0] = bytes.TrimLeft(line[0], \"\\n\")\n\tif string(line[0]) != \"SSH_AGENT_PID\" {\n\t\tt.Fatalf(\"could not find key SSH_AGENT_PID in %q\", fields[2])\n\t}\n\tpidStr := line[1]\n\tpid, err := strconv.Atoi(string(pidStr))\n\tif err != nil {\n\t\tt.Fatalf(\"Atoi(%q): %v\", pidStr, err)\n\t}\n\n\tconn, err := net.Dial(\"unix\", string(socket))\n\tif err != nil {\n\t\tt.Fatalf(\"net.Dial: %v\", err)\n\t}\n\n\tac := NewClient(conn)\n\treturn ac, socket, func() {\n\t\tproc, _ := os.FindProcess(pid)\n\t\tif proc != nil {\n\t\t\tproc.Kill()\n\t\t}\n\t\tconn.Close()\n\t\tos.RemoveAll(filepath.Dir(socket))\n\t}\n}\n\nfunc testAgent(t *testing.T, key interface{}, cert *ssh.Certificate, lifetimeSecs uint32) {\n\tagent, _, cleanup := startAgent(t)\n\tdefer cleanup()\n\n\ttestAgentInterface(t, agent, key, cert, lifetimeSecs)\n}\n\nfunc testKeyring(t *testing.T, key interface{}, cert *ssh.Certificate, lifetimeSecs uint32) {\n\ta := NewKeyring()\n\ttestAgentInterface(t, a, key, cert, lifetimeSecs)\n}\n\nfunc testAgentInterface(t *testing.T, agent Agent, key interface{}, cert *ssh.Certificate, lifetimeSecs uint32) {\n\tsigner, err := ssh.NewSignerFromKey(key)\n\tif err != nil {\n\t\tt.Fatalf(\"NewSignerFromKey(%T): %v\", key, err)\n\t}\n\t// The agent should start up empty.\n\tif keys, err := agent.List(); err != nil {\n\t\tt.Fatalf(\"RequestIdentities: %v\", err)\n\t} else if len(keys) > 0 {\n\t\tt.Fatalf(\"got %d keys, want 0: %v\", len(keys), keys)\n\t}\n\n\t// Attempt to insert the key, with certificate if specified.\n\tvar pubKey ssh.PublicKey\n\tif cert != nil {\n\t\terr = agent.Add(AddedKey{\n\t\t\tPrivateKey:   key,\n\t\t\tCertificate:  cert,\n\t\t\tComment:      \"comment\",\n\t\t\tLifetimeSecs: lifetimeSecs,\n\t\t})\n\t\tpubKey = cert\n\t} else {\n\t\terr = agent.Add(AddedKey{PrivateKey: key, Comment: \"comment\", LifetimeSecs: lifetimeSecs})\n\t\tpubKey = signer.PublicKey()\n\t}\n\tif err != nil {\n\t\tt.Fatalf(\"insert(%T): %v\", key, err)\n\t}\n\n\t// Did the key get inserted successfully?\n\tif keys, err := agent.List(); err != nil {\n\t\tt.Fatalf(\"List: %v\", err)\n\t} else if len(keys) != 1 {\n\t\tt.Fatalf(\"got %v, want 1 key\", keys)\n\t} else if keys[0].Comment != \"comment\" {\n\t\tt.Fatalf(\"key comment: got %v, want %v\", keys[0].Comment, \"comment\")\n\t} else if !bytes.Equal(keys[0].Blob, pubKey.Marshal()) {\n\t\tt.Fatalf(\"key mismatch\")\n\t}\n\n\t// Can the agent make a valid signature?\n\tdata := []byte(\"hello\")\n\tsig, err := agent.Sign(pubKey, data)\n\tif err != nil {\n\t\tt.Fatalf(\"Sign(%s): %v\", pubKey.Type(), err)\n\t}\n\n\tif err := pubKey.Verify(data, sig); err != nil {\n\t\tt.Fatalf(\"Verify(%s): %v\", pubKey.Type(), err)\n\t}\n\n\t// If the key has a lifetime, is it removed when it should be?\n\tif lifetimeSecs > 0 {\n\t\ttime.Sleep(time.Second*time.Duration(lifetimeSecs) + 100*time.Millisecond)\n\t\tkeys, err := agent.List()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"List: %v\", err)\n\t\t}\n\t\tif len(keys) > 0 {\n\t\t\tt.Fatalf(\"key not expired\")\n\t\t}\n\t}\n\n}\n\nfunc TestAgent(t *testing.T) {\n\tfor _, keyType := range []string{\"rsa\", \"dsa\", \"ecdsa\", \"ed25519\"} {\n\t\ttestAgent(t, testPrivateKeys[keyType], nil, 0)\n\t\ttestKeyring(t, testPrivateKeys[keyType], nil, 1)\n\t}\n}\n\nfunc TestCert(t *testing.T) {\n\tcert := &ssh.Certificate{\n\t\tKey:         testPublicKeys[\"rsa\"],\n\t\tValidBefore: ssh.CertTimeInfinity,\n\t\tCertType:    ssh.UserCert,\n\t}\n\tcert.SignCert(rand.Reader, testSigners[\"ecdsa\"])\n\n\ttestAgent(t, testPrivateKeys[\"rsa\"], cert, 0)\n\ttestKeyring(t, testPrivateKeys[\"rsa\"], cert, 1)\n}\n\n// netPipe is analogous to net.Pipe, but it uses a real net.Conn, and\n// therefore is buffered (net.Pipe deadlocks if both sides start with\n// a write.)\nfunc netPipe() (net.Conn, net.Conn, error) {\n\tlistener, err := net.Listen(\"tcp\", \":0\")\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tdefer listener.Close()\n\tc1, err := net.Dial(\"tcp\", listener.Addr().String())\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tc2, err := listener.Accept()\n\tif err != nil {\n\t\tc1.Close()\n\t\treturn nil, nil, err\n\t}\n\n\treturn c1, c2, nil\n}\n\nfunc TestAuth(t *testing.T) {\n\ta, b, err := netPipe()\n\tif err != nil {\n\t\tt.Fatalf(\"netPipe: %v\", err)\n\t}\n\n\tdefer a.Close()\n\tdefer b.Close()\n\n\tagent, _, cleanup := startAgent(t)\n\tdefer cleanup()\n\n\tif err := agent.Add(AddedKey{PrivateKey: testPrivateKeys[\"rsa\"], Comment: \"comment\"}); err != nil {\n\t\tt.Errorf(\"Add: %v\", err)\n\t}\n\n\tserverConf := ssh.ServerConfig{}\n\tserverConf.AddHostKey(testSigners[\"rsa\"])\n\tserverConf.PublicKeyCallback = func(c ssh.ConnMetadata, key ssh.PublicKey) (*ssh.Permissions, error) {\n\t\tif bytes.Equal(key.Marshal(), testPublicKeys[\"rsa\"].Marshal()) {\n\t\t\treturn nil, nil\n\t\t}\n\n\t\treturn nil, errors.New(\"pubkey rejected\")\n\t}\n\n\tgo func() {\n\t\tconn, _, _, err := ssh.NewServerConn(a, &serverConf)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Server: %v\", err)\n\t\t}\n\t\tconn.Close()\n\t}()\n\n\tconf := ssh.ClientConfig{\n\t\tHostKeyCallback: ssh.InsecureIgnoreHostKey(),\n\t}\n\tconf.Auth = append(conf.Auth, ssh.PublicKeysCallback(agent.Signers))\n\tconn, _, _, err := ssh.NewClientConn(b, \"\", &conf)\n\tif err != nil {\n\t\tt.Fatalf(\"NewClientConn: %v\", err)\n\t}\n\tconn.Close()\n}\n\nfunc TestLockClient(t *testing.T) {\n\tagent, _, cleanup := startAgent(t)\n\tdefer cleanup()\n\ttestLockAgent(agent, t)\n}\n\nfunc testLockAgent(agent Agent, t *testing.T) {\n\tif err := agent.Add(AddedKey{PrivateKey: testPrivateKeys[\"rsa\"], Comment: \"comment 1\"}); err != nil {\n\t\tt.Errorf(\"Add: %v\", err)\n\t}\n\tif err := agent.Add(AddedKey{PrivateKey: testPrivateKeys[\"dsa\"], Comment: \"comment dsa\"}); err != nil {\n\t\tt.Errorf(\"Add: %v\", err)\n\t}\n\tif keys, err := agent.List(); err != nil {\n\t\tt.Errorf(\"List: %v\", err)\n\t} else if len(keys) != 2 {\n\t\tt.Errorf(\"Want 2 keys, got %v\", keys)\n\t}\n\n\tpassphrase := []byte(\"secret\")\n\tif err := agent.Lock(passphrase); err != nil {\n\t\tt.Errorf(\"Lock: %v\", err)\n\t}\n\n\tif keys, err := agent.List(); err != nil {\n\t\tt.Errorf(\"List: %v\", err)\n\t} else if len(keys) != 0 {\n\t\tt.Errorf(\"Want 0 keys, got %v\", keys)\n\t}\n\n\tsigner, _ := ssh.NewSignerFromKey(testPrivateKeys[\"rsa\"])\n\tif _, err := agent.Sign(signer.PublicKey(), []byte(\"hello\")); err == nil {\n\t\tt.Fatalf(\"Sign did not fail\")\n\t}\n\n\tif err := agent.Remove(signer.PublicKey()); err == nil {\n\t\tt.Fatalf(\"Remove did not fail\")\n\t}\n\n\tif err := agent.RemoveAll(); err == nil {\n\t\tt.Fatalf(\"RemoveAll did not fail\")\n\t}\n\n\tif err := agent.Unlock(nil); err == nil {\n\t\tt.Errorf(\"Unlock with wrong passphrase succeeded\")\n\t}\n\tif err := agent.Unlock(passphrase); err != nil {\n\t\tt.Errorf(\"Unlock: %v\", err)\n\t}\n\n\tif err := agent.Remove(signer.PublicKey()); err != nil {\n\t\tt.Fatalf(\"Remove: %v\", err)\n\t}\n\n\tif keys, err := agent.List(); err != nil {\n\t\tt.Errorf(\"List: %v\", err)\n\t} else if len(keys) != 1 {\n\t\tt.Errorf(\"Want 1 keys, got %v\", keys)\n\t}\n}\n\nfunc TestAgentLifetime(t *testing.T) {\n\tagent, _, cleanup := startAgent(t)\n\tdefer cleanup()\n\n\tfor _, keyType := range []string{\"rsa\", \"dsa\", \"ecdsa\"} {\n\t\t// Add private keys to the agent.\n\t\terr := agent.Add(AddedKey{\n\t\t\tPrivateKey:   testPrivateKeys[keyType],\n\t\t\tComment:      \"comment\",\n\t\t\tLifetimeSecs: 1,\n\t\t})\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"add: %v\", err)\n\t\t}\n\t\t// Add certs to the agent.\n\t\tcert := &ssh.Certificate{\n\t\t\tKey:         testPublicKeys[keyType],\n\t\t\tValidBefore: ssh.CertTimeInfinity,\n\t\t\tCertType:    ssh.UserCert,\n\t\t}\n\t\tcert.SignCert(rand.Reader, testSigners[keyType])\n\t\terr = agent.Add(AddedKey{\n\t\t\tPrivateKey:   testPrivateKeys[keyType],\n\t\t\tCertificate:  cert,\n\t\t\tComment:      \"comment\",\n\t\t\tLifetimeSecs: 1,\n\t\t})\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"add: %v\", err)\n\t\t}\n\t}\n\ttime.Sleep(1100 * time.Millisecond)\n\tif keys, err := agent.List(); err != nil {\n\t\tt.Errorf(\"List: %v\", err)\n\t} else if len(keys) != 0 {\n\t\tt.Errorf(\"Want 0 keys, got %v\", len(keys))\n\t}\n}\n", "// Copyright 2016 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage agent_test\n\nimport (\n\t\"log\"\n\t\"net\"\n\t\"os\"\n\n\t\"golang.org/x/crypto/ssh\"\n\t\"golang.org/x/crypto/ssh/agent\"\n)\n\nfunc ExampleClientAgent() {\n\t// ssh-agent has a UNIX socket under $SSH_AUTH_SOCK\n\tsocket := os.Getenv(\"SSH_AUTH_SOCK\")\n\tconn, err := net.Dial(\"unix\", socket)\n\tif err != nil {\n\t\tlog.Fatalf(\"net.Dial: %v\", err)\n\t}\n\tagentClient := agent.NewClient(conn)\n\tconfig := &ssh.ClientConfig{\n\t\tUser: \"username\",\n\t\tAuth: []ssh.AuthMethod{\n\t\t\t// Use a callback rather than PublicKeys\n\t\t\t// so we only consult the agent once the remote server\n\t\t\t// wants it.\n\t\t\tssh.PublicKeysCallback(agentClient.Signers),\n\t\t},\n\t\tHostKeyCallback: ssh.InsecureIgnoreHostKey(),\n\t}\n\n\tsshc, err := ssh.Dial(\"tcp\", \"localhost:22\", config)\n\tif err != nil {\n\t\tlog.Fatalf(\"Dial: %v\", err)\n\t}\n\t// .. use sshc\n\tsshc.Close()\n}\n", "// Copyright 2012 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage agent\n\nimport (\n\t\"crypto\"\n\t\"crypto/rand\"\n\t\"fmt\"\n\t\"testing\"\n\n\t\"golang.org/x/crypto/ssh\"\n)\n\nfunc TestServer(t *testing.T) {\n\tc1, c2, err := netPipe()\n\tif err != nil {\n\t\tt.Fatalf(\"netPipe: %v\", err)\n\t}\n\tdefer c1.Close()\n\tdefer c2.Close()\n\tclient := NewClient(c1)\n\n\tgo ServeAgent(NewKeyring(), c2)\n\n\ttestAgentInterface(t, client, testPrivateKeys[\"rsa\"], nil, 0)\n}\n\nfunc TestLockServer(t *testing.T) {\n\ttestLockAgent(NewKeyring(), t)\n}\n\nfunc TestSetupForwardAgent(t *testing.T) {\n\ta, b, err := netPipe()\n\tif err != nil {\n\t\tt.Fatalf(\"netPipe: %v\", err)\n\t}\n\n\tdefer a.Close()\n\tdefer b.Close()\n\n\t_, socket, cleanup := startAgent(t)\n\tdefer cleanup()\n\n\tserverConf := ssh.ServerConfig{\n\t\tNoClientAuth: true,\n\t}\n\tserverConf.AddHostKey(testSigners[\"rsa\"])\n\tincoming := make(chan *ssh.ServerConn, 1)\n\tgo func() {\n\t\tconn, _, _, err := ssh.NewServerConn(a, &serverConf)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Server: %v\", err)\n\t\t}\n\t\tincoming <- conn\n\t}()\n\n\tconf := ssh.ClientConfig{\n\t\tHostKeyCallback: ssh.InsecureIgnoreHostKey(),\n\t}\n\tconn, chans, reqs, err := ssh.NewClientConn(b, \"\", &conf)\n\tif err != nil {\n\t\tt.Fatalf(\"NewClientConn: %v\", err)\n\t}\n\tclient := ssh.NewClient(conn, chans, reqs)\n\n\tif err := ForwardToRemote(client, socket); err != nil {\n\t\tt.Fatalf(\"SetupForwardAgent: %v\", err)\n\t}\n\n\tserver := <-incoming\n\tch, reqs, err := server.OpenChannel(channelType, nil)\n\tif err != nil {\n\t\tt.Fatalf(\"OpenChannel(%q): %v\", channelType, err)\n\t}\n\tgo ssh.DiscardRequests(reqs)\n\n\tagentClient := NewClient(ch)\n\ttestAgentInterface(t, agentClient, testPrivateKeys[\"rsa\"], nil, 0)\n\tconn.Close()\n}\n\nfunc TestV1ProtocolMessages(t *testing.T) {\n\tc1, c2, err := netPipe()\n\tif err != nil {\n\t\tt.Fatalf(\"netPipe: %v\", err)\n\t}\n\tdefer c1.Close()\n\tdefer c2.Close()\n\tc := NewClient(c1)\n\n\tgo ServeAgent(NewKeyring(), c2)\n\n\ttestV1ProtocolMessages(t, c.(*client))\n}\n\nfunc testV1ProtocolMessages(t *testing.T, c *client) {\n\treply, err := c.call([]byte{agentRequestV1Identities})\n\tif err != nil {\n\t\tt.Fatalf(\"v1 request all failed: %v\", err)\n\t}\n\tif msg, ok := reply.(*agentV1IdentityMsg); !ok || msg.Numkeys != 0 {\n\t\tt.Fatalf(\"invalid request all response: %#v\", reply)\n\t}\n\n\treply, err = c.call([]byte{agentRemoveAllV1Identities})\n\tif err != nil {\n\t\tt.Fatalf(\"v1 remove all failed: %v\", err)\n\t}\n\tif _, ok := reply.(*successAgentMsg); !ok {\n\t\tt.Fatalf(\"invalid remove all response: %#v\", reply)\n\t}\n}\n\nfunc verifyKey(sshAgent Agent) error {\n\tkeys, err := sshAgent.List()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"listing keys: %v\", err)\n\t}\n\n\tif len(keys) != 1 {\n\t\treturn fmt.Errorf(\"bad number of keys found. expected 1, got %d\", len(keys))\n\t}\n\n\tbuf := make([]byte, 128)\n\tif _, err := rand.Read(buf); err != nil {\n\t\treturn fmt.Errorf(\"rand: %v\", err)\n\t}\n\n\tsig, err := sshAgent.Sign(keys[0], buf)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"sign: %v\", err)\n\t}\n\n\tif err := keys[0].Verify(buf, sig); err != nil {\n\t\treturn fmt.Errorf(\"verify: %v\", err)\n\t}\n\treturn nil\n}\n\nfunc addKeyToAgent(key crypto.PrivateKey) error {\n\tsshAgent := NewKeyring()\n\tif err := sshAgent.Add(AddedKey{PrivateKey: key}); err != nil {\n\t\treturn fmt.Errorf(\"add: %v\", err)\n\t}\n\treturn verifyKey(sshAgent)\n}\n\nfunc TestKeyTypes(t *testing.T) {\n\tfor k, v := range testPrivateKeys {\n\t\tif err := addKeyToAgent(v); err != nil {\n\t\t\tt.Errorf(\"error adding key type %s, %v\", k, err)\n\t\t}\n\t\tif err := addCertToAgentSock(v, nil); err != nil {\n\t\t\tt.Errorf(\"error adding key type %s, %v\", k, err)\n\t\t}\n\t}\n}\n\nfunc addCertToAgentSock(key crypto.PrivateKey, cert *ssh.Certificate) error {\n\ta, b, err := netPipe()\n\tif err != nil {\n\t\treturn err\n\t}\n\tagentServer := NewKeyring()\n\tgo ServeAgent(agentServer, a)\n\n\tagentClient := NewClient(b)\n\tif err := agentClient.Add(AddedKey{PrivateKey: key, Certificate: cert}); err != nil {\n\t\treturn fmt.Errorf(\"add: %v\", err)\n\t}\n\treturn verifyKey(agentClient)\n}\n\nfunc addCertToAgent(key crypto.PrivateKey, cert *ssh.Certificate) error {\n\tsshAgent := NewKeyring()\n\tif err := sshAgent.Add(AddedKey{PrivateKey: key, Certificate: cert}); err != nil {\n\t\treturn fmt.Errorf(\"add: %v\", err)\n\t}\n\treturn verifyKey(sshAgent)\n}\n\nfunc TestCertTypes(t *testing.T) {\n\tfor keyType, key := range testPublicKeys {\n\t\tcert := &ssh.Certificate{\n\t\t\tValidPrincipals: []string{\"gopher1\"},\n\t\t\tValidAfter:      0,\n\t\t\tValidBefore:     ssh.CertTimeInfinity,\n\t\t\tKey:             key,\n\t\t\tSerial:          1,\n\t\t\tCertType:        ssh.UserCert,\n\t\t\tSignatureKey:    testPublicKeys[\"rsa\"],\n\t\t\tPermissions: ssh.Permissions{\n\t\t\t\tCriticalOptions: map[string]string{},\n\t\t\t\tExtensions:      map[string]string{},\n\t\t\t},\n\t\t}\n\t\tif err := cert.SignCert(rand.Reader, testSigners[\"rsa\"]); err != nil {\n\t\t\tt.Fatalf(\"signcert: %v\", err)\n\t\t}\n\t\tif err := addCertToAgent(testPrivateKeys[keyType], cert); err != nil {\n\t\t\tt.Fatalf(\"%v\", err)\n\t\t}\n\t\tif err := addCertToAgentSock(testPrivateKeys[keyType], cert); err != nil {\n\t\t\tt.Fatalf(\"%v\", err)\n\t\t}\n\t}\n}\n", "// Copyright 2012 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage ssh\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n\t\"sort\"\n\t\"time\"\n)\n\n// These constants from [PROTOCOL.certkeys] represent the algorithm names\n// for certificate types supported by this package.\nconst (\n\tCertAlgoRSAv01      = \"ssh-rsa-cert-v01@openssh.com\"\n\tCertAlgoDSAv01      = \"ssh-dss-cert-v01@openssh.com\"\n\tCertAlgoECDSA256v01 = \"ecdsa-sha2-nistp256-cert-v01@openssh.com\"\n\tCertAlgoECDSA384v01 = \"ecdsa-sha2-nistp384-cert-v01@openssh.com\"\n\tCertAlgoECDSA521v01 = \"ecdsa-sha2-nistp521-cert-v01@openssh.com\"\n\tCertAlgoED25519v01  = \"ssh-ed25519-cert-v01@openssh.com\"\n)\n\n// Certificate types distinguish between host and user\n// certificates. The values can be set in the CertType field of\n// Certificate.\nconst (\n\tUserCert = 1\n\tHostCert = 2\n)\n\n// Signature represents a cryptographic signature.\ntype Signature struct {\n\tFormat string\n\tBlob   []byte\n}\n\n// CertTimeInfinity can be used for OpenSSHCertV01.ValidBefore to indicate that\n// a certificate does not expire.\nconst CertTimeInfinity = 1<<64 - 1\n\n// An Certificate represents an OpenSSH certificate as defined in\n// [PROTOCOL.certkeys]?rev=1.8.\ntype Certificate struct {\n\tNonce           []byte\n\tKey             PublicKey\n\tSerial          uint64\n\tCertType        uint32\n\tKeyId           string\n\tValidPrincipals []string\n\tValidAfter      uint64\n\tValidBefore     uint64\n\tPermissions\n\tReserved     []byte\n\tSignatureKey PublicKey\n\tSignature    *Signature\n}\n\n// genericCertData holds the key-independent part of the certificate data.\n// Overall, certificates contain an nonce, public key fields and\n// key-independent fields.\ntype genericCertData struct {\n\tSerial          uint64\n\tCertType        uint32\n\tKeyId           string\n\tValidPrincipals []byte\n\tValidAfter      uint64\n\tValidBefore     uint64\n\tCriticalOptions []byte\n\tExtensions      []byte\n\tReserved        []byte\n\tSignatureKey    []byte\n\tSignature       []byte\n}\n\nfunc marshalStringList(namelist []string) []byte {\n\tvar to []byte\n\tfor _, name := range namelist {\n\t\ts := struct{ N string }{name}\n\t\tto = append(to, Marshal(&s)...)\n\t}\n\treturn to\n}\n\ntype optionsTuple struct {\n\tKey   string\n\tValue []byte\n}\n\ntype optionsTupleValue struct {\n\tValue string\n}\n\n// serialize a map of critical options or extensions\n// issue #10569 - per [PROTOCOL.certkeys] and SSH implementation,\n// we need two length prefixes for a non-empty string value\nfunc marshalTuples(tups map[string]string) []byte {\n\tkeys := make([]string, 0, len(tups))\n\tfor key := range tups {\n\t\tkeys = append(keys, key)\n\t}\n\tsort.Strings(keys)\n\n\tvar ret []byte\n\tfor _, key := range keys {\n\t\ts := optionsTuple{Key: key}\n\t\tif value := tups[key]; len(value) > 0 {\n\t\t\ts.Value = Marshal(&optionsTupleValue{value})\n\t\t}\n\t\tret = append(ret, Marshal(&s)...)\n\t}\n\treturn ret\n}\n\n// issue #10569 - per [PROTOCOL.certkeys] and SSH implementation,\n// we need two length prefixes for a non-empty option value\nfunc parseTuples(in []byte) (map[string]string, error) {\n\ttups := map[string]string{}\n\tvar lastKey string\n\tvar haveLastKey bool\n\n\tfor len(in) > 0 {\n\t\tvar key, val, extra []byte\n\t\tvar ok bool\n\n\t\tif key, in, ok = parseString(in); !ok {\n\t\t\treturn nil, errShortRead\n\t\t}\n\t\tkeyStr := string(key)\n\t\t// according to [PROTOCOL.certkeys], the names must be in\n\t\t// lexical order.\n\t\tif haveLastKey && keyStr <= lastKey {\n\t\t\treturn nil, fmt.Errorf(\"ssh: certificate options are not in lexical order\")\n\t\t}\n\t\tlastKey, haveLastKey = keyStr, true\n\t\t// the next field is a data field, which if non-empty has a string embedded\n\t\tif val, in, ok = parseString(in); !ok {\n\t\t\treturn nil, errShortRead\n\t\t}\n\t\tif len(val) > 0 {\n\t\t\tval, extra, ok = parseString(val)\n\t\t\tif !ok {\n\t\t\t\treturn nil, errShortRead\n\t\t\t}\n\t\t\tif len(extra) > 0 {\n\t\t\t\treturn nil, fmt.Errorf(\"ssh: unexpected trailing data after certificate option value\")\n\t\t\t}\n\t\t\ttups[keyStr] = string(val)\n\t\t} else {\n\t\t\ttups[keyStr] = \"\"\n\t\t}\n\t}\n\treturn tups, nil\n}\n\nfunc parseCert(in []byte, privAlgo string) (*Certificate, error) {\n\tnonce, rest, ok := parseString(in)\n\tif !ok {\n\t\treturn nil, errShortRead\n\t}\n\n\tkey, rest, err := parsePubKey(rest, privAlgo)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar g genericCertData\n\tif err := Unmarshal(rest, &g); err != nil {\n\t\treturn nil, err\n\t}\n\n\tc := &Certificate{\n\t\tNonce:       nonce,\n\t\tKey:         key,\n\t\tSerial:      g.Serial,\n\t\tCertType:    g.CertType,\n\t\tKeyId:       g.KeyId,\n\t\tValidAfter:  g.ValidAfter,\n\t\tValidBefore: g.ValidBefore,\n\t}\n\n\tfor principals := g.ValidPrincipals; len(principals) > 0; {\n\t\tprincipal, rest, ok := parseString(principals)\n\t\tif !ok {\n\t\t\treturn nil, errShortRead\n\t\t}\n\t\tc.ValidPrincipals = append(c.ValidPrincipals, string(principal))\n\t\tprincipals = rest\n\t}\n\n\tc.CriticalOptions, err = parseTuples(g.CriticalOptions)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tc.Extensions, err = parseTuples(g.Extensions)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tc.Reserved = g.Reserved\n\tk, err := ParsePublicKey(g.SignatureKey)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tc.SignatureKey = k\n\tc.Signature, rest, ok = parseSignatureBody(g.Signature)\n\tif !ok || len(rest) > 0 {\n\t\treturn nil, errors.New(\"ssh: signature parse error\")\n\t}\n\n\treturn c, nil\n}\n\ntype openSSHCertSigner struct {\n\tpub    *Certificate\n\tsigner Signer\n}\n\n// NewCertSigner returns a Signer that signs with the given Certificate, whose\n// private key is held by signer. It returns an error if the public key in cert\n// doesn't match the key used by signer.\nfunc NewCertSigner(cert *Certificate, signer Signer) (Signer, error) {\n\tif bytes.Compare(cert.Key.Marshal(), signer.PublicKey().Marshal()) != 0 {\n\t\treturn nil, errors.New(\"ssh: signer and cert have different public key\")\n\t}\n\n\treturn &openSSHCertSigner{cert, signer}, nil\n}\n\nfunc (s *openSSHCertSigner) Sign(rand io.Reader, data []byte) (*Signature, error) {\n\treturn s.signer.Sign(rand, data)\n}\n\nfunc (s *openSSHCertSigner) PublicKey() PublicKey {\n\treturn s.pub\n}\n\nconst sourceAddressCriticalOption = \"source-address\"\n\n// CertChecker does the work of verifying a certificate. Its methods\n// can be plugged into ClientConfig.HostKeyCallback and\n// ServerConfig.PublicKeyCallback. For the CertChecker to work,\n// minimally, the IsAuthority callback should be set.\ntype CertChecker struct {\n\t// SupportedCriticalOptions lists the CriticalOptions that the\n\t// server application layer understands. These are only used\n\t// for user certificates.\n\tSupportedCriticalOptions []string\n\n\t// IsAuthority should return true if the key is recognized as\n\t// an authority. This allows for certificates to be signed by other\n\t// certificates.\n\tIsAuthority func(auth PublicKey) bool\n\n\t// Clock is used for verifying time stamps. If nil, time.Now\n\t// is used.\n\tClock func() time.Time\n\n\t// UserKeyFallback is called when CertChecker.Authenticate encounters a\n\t// public key that is not a certificate. It must implement validation\n\t// of user keys or else, if nil, all such keys are rejected.\n\tUserKeyFallback func(conn ConnMetadata, key PublicKey) (*Permissions, error)\n\n\t// HostKeyFallback is called when CertChecker.CheckHostKey encounters a\n\t// public key that is not a certificate. It must implement host key\n\t// validation or else, if nil, all such keys are rejected.\n\tHostKeyFallback HostKeyCallback\n\n\t// IsRevoked is called for each certificate so that revocation checking\n\t// can be implemented. It should return true if the given certificate\n\t// is revoked and false otherwise. If nil, no certificates are\n\t// considered to have been revoked.\n\tIsRevoked func(cert *Certificate) bool\n}\n\n// CheckHostKey checks a host key certificate. This method can be\n// plugged into ClientConfig.HostKeyCallback.\nfunc (c *CertChecker) CheckHostKey(addr string, remote net.Addr, key PublicKey) error {\n\tcert, ok := key.(*Certificate)\n\tif !ok {\n\t\tif c.HostKeyFallback != nil {\n\t\t\treturn c.HostKeyFallback(addr, remote, key)\n\t\t}\n\t\treturn errors.New(\"ssh: non-certificate host key\")\n\t}\n\tif cert.CertType != HostCert {\n\t\treturn fmt.Errorf(\"ssh: certificate presented as a host key has type %d\", cert.CertType)\n\t}\n\n\treturn c.CheckCert(addr, cert)\n}\n\n// Authenticate checks a user certificate. Authenticate can be used as\n// a value for ServerConfig.PublicKeyCallback.\nfunc (c *CertChecker) Authenticate(conn ConnMetadata, pubKey PublicKey) (*Permissions, error) {\n\tcert, ok := pubKey.(*Certificate)\n\tif !ok {\n\t\tif c.UserKeyFallback != nil {\n\t\t\treturn c.UserKeyFallback(conn, pubKey)\n\t\t}\n\t\treturn nil, errors.New(\"ssh: normal key pairs not accepted\")\n\t}\n\n\tif cert.CertType != UserCert {\n\t\treturn nil, fmt.Errorf(\"ssh: cert has type %d\", cert.CertType)\n\t}\n\n\tif err := c.CheckCert(conn.User(), cert); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &cert.Permissions, nil\n}\n\n// CheckCert checks CriticalOptions, ValidPrincipals, revocation, timestamp and\n// the signature of the certificate.\nfunc (c *CertChecker) CheckCert(principal string, cert *Certificate) error {\n\tif c.IsRevoked != nil && c.IsRevoked(cert) {\n\t\treturn fmt.Errorf(\"ssh: certicate serial %d revoked\", cert.Serial)\n\t}\n\n\tfor opt, _ := range cert.CriticalOptions {\n\t\t// sourceAddressCriticalOption will be enforced by\n\t\t// serverAuthenticate\n\t\tif opt == sourceAddressCriticalOption {\n\t\t\tcontinue\n\t\t}\n\n\t\tfound := false\n\t\tfor _, supp := range c.SupportedCriticalOptions {\n\t\t\tif supp == opt {\n\t\t\t\tfound = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !found {\n\t\t\treturn fmt.Errorf(\"ssh: unsupported critical option %q in certificate\", opt)\n\t\t}\n\t}\n\n\tif len(cert.ValidPrincipals) > 0 {\n\t\t// By default, certs are valid for all users/hosts.\n\t\tfound := false\n\t\tfor _, p := range cert.ValidPrincipals {\n\t\t\tif p == principal {\n\t\t\t\tfound = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !found {\n\t\t\treturn fmt.Errorf(\"ssh: principal %q not in the set of valid principals for given certificate: %q\", principal, cert.ValidPrincipals)\n\t\t}\n\t}\n\n\tif !c.IsAuthority(cert.SignatureKey) {\n\t\treturn fmt.Errorf(\"ssh: certificate signed by unrecognized authority\")\n\t}\n\n\tclock := c.Clock\n\tif clock == nil {\n\t\tclock = time.Now\n\t}\n\n\tunixNow := clock().Unix()\n\tif after := int64(cert.ValidAfter); after < 0 || unixNow < int64(cert.ValidAfter) {\n\t\treturn fmt.Errorf(\"ssh: cert is not yet valid\")\n\t}\n\tif before := int64(cert.ValidBefore); cert.ValidBefore != uint64(CertTimeInfinity) && (unixNow >= before || before < 0) {\n\t\treturn fmt.Errorf(\"ssh: cert has expired\")\n\t}\n\tif err := cert.SignatureKey.Verify(cert.bytesForSigning(), cert.Signature); err != nil {\n\t\treturn fmt.Errorf(\"ssh: certificate signature does not verify\")\n\t}\n\n\treturn nil\n}\n\n// SignCert sets c.SignatureKey to the authority's public key and stores a\n// Signature, by authority, in the certificate.\nfunc (c *Certificate) SignCert(rand io.Reader, authority Signer) error {\n\tc.Nonce = make([]byte, 32)\n\tif _, err := io.ReadFull(rand, c.Nonce); err != nil {\n\t\treturn err\n\t}\n\tc.SignatureKey = authority.PublicKey()\n\n\tsig, err := authority.Sign(rand, c.bytesForSigning())\n\tif err != nil {\n\t\treturn err\n\t}\n\tc.Signature = sig\n\treturn nil\n}\n\nvar certAlgoNames = map[string]string{\n\tKeyAlgoRSA:      CertAlgoRSAv01,\n\tKeyAlgoDSA:      CertAlgoDSAv01,\n\tKeyAlgoECDSA256: CertAlgoECDSA256v01,\n\tKeyAlgoECDSA384: CertAlgoECDSA384v01,\n\tKeyAlgoECDSA521: CertAlgoECDSA521v01,\n\tKeyAlgoED25519:  CertAlgoED25519v01,\n}\n\n// certToPrivAlgo returns the underlying algorithm for a certificate algorithm.\n// Panics if a non-certificate algorithm is passed.\nfunc certToPrivAlgo(algo string) string {\n\tfor privAlgo, pubAlgo := range certAlgoNames {\n\t\tif pubAlgo == algo {\n\t\t\treturn privAlgo\n\t\t}\n\t}\n\tpanic(\"unknown cert algorithm\")\n}\n\nfunc (cert *Certificate) bytesForSigning() []byte {\n\tc2 := *cert\n\tc2.Signature = nil\n\tout := c2.Marshal()\n\t// Drop trailing signature length.\n\treturn out[:len(out)-4]\n}\n\n// Marshal serializes c into OpenSSH's wire format. It is part of the\n// PublicKey interface.\nfunc (c *Certificate) Marshal() []byte {\n\tgeneric := genericCertData{\n\t\tSerial:          c.Serial,\n\t\tCertType:        c.CertType,\n\t\tKeyId:           c.KeyId,\n\t\tValidPrincipals: marshalStringList(c.ValidPrincipals),\n\t\tValidAfter:      uint64(c.ValidAfter),\n\t\tValidBefore:     uint64(c.ValidBefore),\n\t\tCriticalOptions: marshalTuples(c.CriticalOptions),\n\t\tExtensions:      marshalTuples(c.Extensions),\n\t\tReserved:        c.Reserved,\n\t\tSignatureKey:    c.SignatureKey.Marshal(),\n\t}\n\tif c.Signature != nil {\n\t\tgeneric.Signature = Marshal(c.Signature)\n\t}\n\tgenericBytes := Marshal(&generic)\n\tkeyBytes := c.Key.Marshal()\n\t_, keyBytes, _ = parseString(keyBytes)\n\tprefix := Marshal(&struct {\n\t\tName  string\n\t\tNonce []byte\n\t\tKey   []byte `ssh:\"rest\"`\n\t}{c.Type(), c.Nonce, keyBytes})\n\n\tresult := make([]byte, 0, len(prefix)+len(genericBytes))\n\tresult = append(result, prefix...)\n\tresult = append(result, genericBytes...)\n\treturn result\n}\n\n// Type returns the key name. It is part of the PublicKey interface.\nfunc (c *Certificate) Type() string {\n\talgo, ok := certAlgoNames[c.Key.Type()]\n\tif !ok {\n\t\tpanic(\"unknown cert key type \" + c.Key.Type())\n\t}\n\treturn algo\n}\n\n// Verify verifies a signature against the certificate's public\n// key. It is part of the PublicKey interface.\nfunc (c *Certificate) Verify(data []byte, sig *Signature) error {\n\treturn c.Key.Verify(data, sig)\n}\n\nfunc parseSignatureBody(in []byte) (out *Signature, rest []byte, ok bool) {\n\tformat, in, ok := parseString(in)\n\tif !ok {\n\t\treturn\n\t}\n\n\tout = &Signature{\n\t\tFormat: string(format),\n\t}\n\n\tif out.Blob, in, ok = parseString(in); !ok {\n\t\treturn\n\t}\n\n\treturn out, in, ok\n}\n\nfunc parseSignature(in []byte) (out *Signature, rest []byte, ok bool) {\n\tsigBytes, rest, ok := parseString(in)\n\tif !ok {\n\t\treturn\n\t}\n\n\tout, trailing, ok := parseSignatureBody(sigBytes)\n\tif !ok || len(trailing) > 0 {\n\t\treturn nil, nil, false\n\t}\n\treturn\n}\n", "// Copyright 2011 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage ssh\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"fmt\"\n\t\"net\"\n\t\"sync\"\n\t\"time\"\n)\n\n// Client implements a traditional SSH client that supports shells,\n// subprocesses, port forwarding and tunneled dialing.\ntype Client struct {\n\tConn\n\n\tforwards        forwardList // forwarded tcpip connections from the remote side\n\tmu              sync.Mutex\n\tchannelHandlers map[string]chan NewChannel\n}\n\n// HandleChannelOpen returns a channel on which NewChannel requests\n// for the given type are sent. If the type already is being handled,\n// nil is returned. The channel is closed when the connection is closed.\nfunc (c *Client) HandleChannelOpen(channelType string) <-chan NewChannel {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\tif c.channelHandlers == nil {\n\t\t// The SSH channel has been closed.\n\t\tc := make(chan NewChannel)\n\t\tclose(c)\n\t\treturn c\n\t}\n\n\tch := c.channelHandlers[channelType]\n\tif ch != nil {\n\t\treturn nil\n\t}\n\n\tch = make(chan NewChannel, chanSize)\n\tc.channelHandlers[channelType] = ch\n\treturn ch\n}\n\n// NewClient creates a Client on top of the given connection.\nfunc NewClient(c Conn, chans <-chan NewChannel, reqs <-chan *Request) *Client {\n\tconn := &Client{\n\t\tConn:            c,\n\t\tchannelHandlers: make(map[string]chan NewChannel, 1),\n\t}\n\n\tgo conn.handleGlobalRequests(reqs)\n\tgo conn.handleChannelOpens(chans)\n\tgo func() {\n\t\tconn.Wait()\n\t\tconn.forwards.closeAll()\n\t}()\n\tgo conn.forwards.handleChannels(conn.HandleChannelOpen(\"forwarded-tcpip\"))\n\treturn conn\n}\n\n// NewClientConn establishes an authenticated SSH connection using c\n// as the underlying transport.  The Request and NewChannel channels\n// must be serviced or the connection will hang.\nfunc NewClientConn(c net.Conn, addr string, config *ClientConfig) (Conn, <-chan NewChannel, <-chan *Request, error) {\n\tfullConf := *config\n\tfullConf.SetDefaults()\n\tif fullConf.HostKeyCallback == nil {\n\t\tc.Close()\n\t\treturn nil, nil, nil, errors.New(\"ssh: must specify HostKeyCallback\")\n\t}\n\n\tconn := &connection{\n\t\tsshConn: sshConn{conn: c},\n\t}\n\n\tif err := conn.clientHandshake(addr, &fullConf); err != nil {\n\t\tc.Close()\n\t\treturn nil, nil, nil, fmt.Errorf(\"ssh: handshake failed: %v\", err)\n\t}\n\tconn.mux = newMux(conn.transport)\n\treturn conn, conn.mux.incomingChannels, conn.mux.incomingRequests, nil\n}\n\n// clientHandshake performs the client side key exchange. See RFC 4253 Section\n// 7.\nfunc (c *connection) clientHandshake(dialAddress string, config *ClientConfig) error {\n\tif config.ClientVersion != \"\" {\n\t\tc.clientVersion = []byte(config.ClientVersion)\n\t} else {\n\t\tc.clientVersion = []byte(packageVersion)\n\t}\n\tvar err error\n\tc.serverVersion, err = exchangeVersions(c.sshConn.conn, c.clientVersion)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tc.transport = newClientTransport(\n\t\tnewTransport(c.sshConn.conn, config.Rand, true /* is client */),\n\t\tc.clientVersion, c.serverVersion, config, dialAddress, c.sshConn.RemoteAddr())\n\tif err := c.transport.waitSession(); err != nil {\n\t\treturn err\n\t}\n\n\tc.sessionID = c.transport.getSessionID()\n\treturn c.clientAuthenticate(config)\n}\n\n// verifyHostKeySignature verifies the host key obtained in the key\n// exchange.\nfunc verifyHostKeySignature(hostKey PublicKey, result *kexResult) error {\n\tsig, rest, ok := parseSignatureBody(result.Signature)\n\tif len(rest) > 0 || !ok {\n\t\treturn errors.New(\"ssh: signature parse error\")\n\t}\n\n\treturn hostKey.Verify(result.H, sig)\n}\n\n// NewSession opens a new Session for this client. (A session is a remote\n// execution of a program.)\nfunc (c *Client) NewSession() (*Session, error) {\n\tch, in, err := c.OpenChannel(\"session\", nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn newSession(ch, in)\n}\n\nfunc (c *Client) handleGlobalRequests(incoming <-chan *Request) {\n\tfor r := range incoming {\n\t\t// This handles keepalive messages and matches\n\t\t// the behaviour of OpenSSH.\n\t\tr.Reply(false, nil)\n\t}\n}\n\n// handleChannelOpens channel open messages from the remote side.\nfunc (c *Client) handleChannelOpens(in <-chan NewChannel) {\n\tfor ch := range in {\n\t\tc.mu.Lock()\n\t\thandler := c.channelHandlers[ch.ChannelType()]\n\t\tc.mu.Unlock()\n\n\t\tif handler != nil {\n\t\t\thandler <- ch\n\t\t} else {\n\t\t\tch.Reject(UnknownChannelType, fmt.Sprintf(\"unknown channel type: %v\", ch.ChannelType()))\n\t\t}\n\t}\n\n\tc.mu.Lock()\n\tfor _, ch := range c.channelHandlers {\n\t\tclose(ch)\n\t}\n\tc.channelHandlers = nil\n\tc.mu.Unlock()\n}\n\n// Dial starts a client connection to the given SSH server. It is a\n// convenience function that connects to the given network address,\n// initiates the SSH handshake, and then sets up a Client.  For access\n// to incoming channels and requests, use net.Dial with NewClientConn\n// instead.\nfunc Dial(network, addr string, config *ClientConfig) (*Client, error) {\n\tconn, err := net.DialTimeout(network, addr, config.Timeout)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tc, chans, reqs, err := NewClientConn(conn, addr, config)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn NewClient(c, chans, reqs), nil\n}\n\n// HostKeyCallback is the function type used for verifying server\n// keys.  A HostKeyCallback must return nil if the host key is OK, or\n// an error to reject it. It receives the hostname as passed to Dial\n// or NewClientConn. The remote address is the RemoteAddr of the\n// net.Conn underlying the the SSH connection.\ntype HostKeyCallback func(hostname string, remote net.Addr, key PublicKey) error\n\n// A ClientConfig structure is used to configure a Client. It must not be\n// modified after having been passed to an SSH function.\ntype ClientConfig struct {\n\t// Config contains configuration that is shared between clients and\n\t// servers.\n\tConfig\n\n\t// User contains the username to authenticate as.\n\tUser string\n\n\t// Auth contains possible authentication methods to use with the\n\t// server. Only the first instance of a particular RFC 4252 method will\n\t// be used during authentication.\n\tAuth []AuthMethod\n\n\t// HostKeyCallback is called during the cryptographic\n\t// handshake to validate the server's host key. The client\n\t// configuration must supply this callback for the connection\n\t// to succeed. The functions InsecureIgnoreHostKey or\n\t// FixedHostKey can be used for simplistic host key checks.\n\tHostKeyCallback HostKeyCallback\n\n\t// ClientVersion contains the version identification string that will\n\t// be used for the connection. If empty, a reasonable default is used.\n\tClientVersion string\n\n\t// HostKeyAlgorithms lists the key types that the client will\n\t// accept from the server as host key, in order of\n\t// preference. If empty, a reasonable default is used. Any\n\t// string returned from PublicKey.Type method may be used, or\n\t// any of the CertAlgoXxxx and KeyAlgoXxxx constants.\n\tHostKeyAlgorithms []string\n\n\t// Timeout is the maximum amount of time for the TCP connection to establish.\n\t//\n\t// A Timeout of zero means no timeout.\n\tTimeout time.Duration\n}\n\n// InsecureIgnoreHostKey returns a function that can be used for\n// ClientConfig.HostKeyCallback to accept any host key. It should\n// not be used for production code.\nfunc InsecureIgnoreHostKey() HostKeyCallback {\n\treturn func(hostname string, remote net.Addr, key PublicKey) error {\n\t\treturn nil\n\t}\n}\n\ntype fixedHostKey struct {\n\tkey PublicKey\n}\n\nfunc (f *fixedHostKey) check(hostname string, remote net.Addr, key PublicKey) error {\n\tif f.key == nil {\n\t\treturn fmt.Errorf(\"ssh: required host key was nil\")\n\t}\n\tif !bytes.Equal(key.Marshal(), f.key.Marshal()) {\n\t\treturn fmt.Errorf(\"ssh: host key mismatch\")\n\t}\n\treturn nil\n}\n\n// FixedHostKey returns a function for use in\n// ClientConfig.HostKeyCallback to accept only a specific host key.\nfunc FixedHostKey(key PublicKey) HostKeyCallback {\n\thk := &fixedHostKey{key}\n\treturn hk.check\n}\n", "// Copyright 2011 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage ssh\n\nimport (\n\t\"bytes\"\n\t\"crypto/rand\"\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n\t\"strings\"\n\t\"testing\"\n)\n\ntype keyboardInteractive map[string]string\n\nfunc (cr keyboardInteractive) Challenge(user string, instruction string, questions []string, echos []bool) ([]string, error) {\n\tvar answers []string\n\tfor _, q := range questions {\n\t\tanswers = append(answers, cr[q])\n\t}\n\treturn answers, nil\n}\n\n// reused internally by tests\nvar clientPassword = \"tiger\"\n\n// tryAuth runs a handshake with a given config against an SSH server\n// with config serverConfig\nfunc tryAuth(t *testing.T, config *ClientConfig) error {\n\tc1, c2, err := netPipe()\n\tif err != nil {\n\t\tt.Fatalf(\"netPipe: %v\", err)\n\t}\n\tdefer c1.Close()\n\tdefer c2.Close()\n\n\tcertChecker := CertChecker{\n\t\tIsAuthority: func(k PublicKey) bool {\n\t\t\treturn bytes.Equal(k.Marshal(), testPublicKeys[\"ecdsa\"].Marshal())\n\t\t},\n\t\tUserKeyFallback: func(conn ConnMetadata, key PublicKey) (*Permissions, error) {\n\t\t\tif conn.User() == \"testuser\" && bytes.Equal(key.Marshal(), testPublicKeys[\"rsa\"].Marshal()) {\n\t\t\t\treturn nil, nil\n\t\t\t}\n\n\t\t\treturn nil, fmt.Errorf(\"pubkey for %q not acceptable\", conn.User())\n\t\t},\n\t\tIsRevoked: func(c *Certificate) bool {\n\t\t\treturn c.Serial == 666\n\t\t},\n\t}\n\n\tserverConfig := &ServerConfig{\n\t\tPasswordCallback: func(conn ConnMetadata, pass []byte) (*Permissions, error) {\n\t\t\tif conn.User() == \"testuser\" && string(pass) == clientPassword {\n\t\t\t\treturn nil, nil\n\t\t\t}\n\t\t\treturn nil, errors.New(\"password auth failed\")\n\t\t},\n\t\tPublicKeyCallback: certChecker.Authenticate,\n\t\tKeyboardInteractiveCallback: func(conn ConnMetadata, challenge KeyboardInteractiveChallenge) (*Permissions, error) {\n\t\t\tans, err := challenge(\"user\",\n\t\t\t\t\"instruction\",\n\t\t\t\t[]string{\"question1\", \"question2\"},\n\t\t\t\t[]bool{true, true})\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tok := conn.User() == \"testuser\" && ans[0] == \"answer1\" && ans[1] == \"answer2\"\n\t\t\tif ok {\n\t\t\t\tchallenge(\"user\", \"motd\", nil, nil)\n\t\t\t\treturn nil, nil\n\t\t\t}\n\t\t\treturn nil, errors.New(\"keyboard-interactive failed\")\n\t\t},\n\t\tAuthLogCallback: func(conn ConnMetadata, method string, err error) {\n\t\t},\n\t}\n\tserverConfig.AddHostKey(testSigners[\"rsa\"])\n\n\tgo newServer(c1, serverConfig)\n\t_, _, _, err = NewClientConn(c2, \"\", config)\n\treturn err\n}\n\nfunc TestClientAuthPublicKey(t *testing.T) {\n\tconfig := &ClientConfig{\n\t\tUser: \"testuser\",\n\t\tAuth: []AuthMethod{\n\t\t\tPublicKeys(testSigners[\"rsa\"]),\n\t\t},\n\t\tHostKeyCallback: InsecureIgnoreHostKey(),\n\t}\n\tif err := tryAuth(t, config); err != nil {\n\t\tt.Fatalf(\"unable to dial remote side: %s\", err)\n\t}\n}\n\nfunc TestAuthMethodPassword(t *testing.T) {\n\tconfig := &ClientConfig{\n\t\tUser: \"testuser\",\n\t\tAuth: []AuthMethod{\n\t\t\tPassword(clientPassword),\n\t\t},\n\t\tHostKeyCallback: InsecureIgnoreHostKey(),\n\t}\n\n\tif err := tryAuth(t, config); err != nil {\n\t\tt.Fatalf(\"unable to dial remote side: %s\", err)\n\t}\n}\n\nfunc TestAuthMethodFallback(t *testing.T) {\n\tvar passwordCalled bool\n\tconfig := &ClientConfig{\n\t\tUser: \"testuser\",\n\t\tAuth: []AuthMethod{\n\t\t\tPublicKeys(testSigners[\"rsa\"]),\n\t\t\tPasswordCallback(\n\t\t\t\tfunc() (string, error) {\n\t\t\t\t\tpasswordCalled = true\n\t\t\t\t\treturn \"WRONG\", nil\n\t\t\t\t}),\n\t\t},\n\t\tHostKeyCallback: InsecureIgnoreHostKey(),\n\t}\n\n\tif err := tryAuth(t, config); err != nil {\n\t\tt.Fatalf(\"unable to dial remote side: %s\", err)\n\t}\n\n\tif passwordCalled {\n\t\tt.Errorf(\"password auth tried before public-key auth.\")\n\t}\n}\n\nfunc TestAuthMethodWrongPassword(t *testing.T) {\n\tconfig := &ClientConfig{\n\t\tUser: \"testuser\",\n\t\tAuth: []AuthMethod{\n\t\t\tPassword(\"wrong\"),\n\t\t\tPublicKeys(testSigners[\"rsa\"]),\n\t\t},\n\t\tHostKeyCallback: InsecureIgnoreHostKey(),\n\t}\n\n\tif err := tryAuth(t, config); err != nil {\n\t\tt.Fatalf(\"unable to dial remote side: %s\", err)\n\t}\n}\n\nfunc TestAuthMethodKeyboardInteractive(t *testing.T) {\n\tanswers := keyboardInteractive(map[string]string{\n\t\t\"question1\": \"answer1\",\n\t\t\"question2\": \"answer2\",\n\t})\n\tconfig := &ClientConfig{\n\t\tUser: \"testuser\",\n\t\tAuth: []AuthMethod{\n\t\t\tKeyboardInteractive(answers.Challenge),\n\t\t},\n\t\tHostKeyCallback: InsecureIgnoreHostKey(),\n\t}\n\n\tif err := tryAuth(t, config); err != nil {\n\t\tt.Fatalf(\"unable to dial remote side: %s\", err)\n\t}\n}\n\nfunc TestAuthMethodWrongKeyboardInteractive(t *testing.T) {\n\tanswers := keyboardInteractive(map[string]string{\n\t\t\"question1\": \"answer1\",\n\t\t\"question2\": \"WRONG\",\n\t})\n\tconfig := &ClientConfig{\n\t\tUser: \"testuser\",\n\t\tAuth: []AuthMethod{\n\t\t\tKeyboardInteractive(answers.Challenge),\n\t\t},\n\t}\n\n\tif err := tryAuth(t, config); err == nil {\n\t\tt.Fatalf(\"wrong answers should not have authenticated with KeyboardInteractive\")\n\t}\n}\n\n// the mock server will only authenticate ssh-rsa keys\nfunc TestAuthMethodInvalidPublicKey(t *testing.T) {\n\tconfig := &ClientConfig{\n\t\tUser: \"testuser\",\n\t\tAuth: []AuthMethod{\n\t\t\tPublicKeys(testSigners[\"dsa\"]),\n\t\t},\n\t}\n\n\tif err := tryAuth(t, config); err == nil {\n\t\tt.Fatalf(\"dsa private key should not have authenticated with rsa public key\")\n\t}\n}\n\n// the client should authenticate with the second key\nfunc TestAuthMethodRSAandDSA(t *testing.T) {\n\tconfig := &ClientConfig{\n\t\tUser: \"testuser\",\n\t\tAuth: []AuthMethod{\n\t\t\tPublicKeys(testSigners[\"dsa\"], testSigners[\"rsa\"]),\n\t\t},\n\t\tHostKeyCallback: InsecureIgnoreHostKey(),\n\t}\n\tif err := tryAuth(t, config); err != nil {\n\t\tt.Fatalf(\"client could not authenticate with rsa key: %v\", err)\n\t}\n}\n\nfunc TestClientHMAC(t *testing.T) {\n\tfor _, mac := range supportedMACs {\n\t\tconfig := &ClientConfig{\n\t\t\tUser: \"testuser\",\n\t\t\tAuth: []AuthMethod{\n\t\t\t\tPublicKeys(testSigners[\"rsa\"]),\n\t\t\t},\n\t\t\tConfig: Config{\n\t\t\t\tMACs: []string{mac},\n\t\t\t},\n\t\t\tHostKeyCallback: InsecureIgnoreHostKey(),\n\t\t}\n\t\tif err := tryAuth(t, config); err != nil {\n\t\t\tt.Fatalf(\"client could not authenticate with mac algo %s: %v\", mac, err)\n\t\t}\n\t}\n}\n\n// issue 4285.\nfunc TestClientUnsupportedCipher(t *testing.T) {\n\tconfig := &ClientConfig{\n\t\tUser: \"testuser\",\n\t\tAuth: []AuthMethod{\n\t\t\tPublicKeys(),\n\t\t},\n\t\tConfig: Config{\n\t\t\tCiphers: []string{\"aes128-cbc\"}, // not currently supported\n\t\t},\n\t}\n\tif err := tryAuth(t, config); err == nil {\n\t\tt.Errorf(\"expected no ciphers in common\")\n\t}\n}\n\nfunc TestClientUnsupportedKex(t *testing.T) {\n\tif os.Getenv(\"GO_BUILDER_NAME\") != \"\" {\n\t\tt.Skip(\"skipping known-flaky test on the Go build dashboard; see golang.org/issue/15198\")\n\t}\n\tconfig := &ClientConfig{\n\t\tUser: \"testuser\",\n\t\tAuth: []AuthMethod{\n\t\t\tPublicKeys(),\n\t\t},\n\t\tConfig: Config{\n\t\t\tKeyExchanges: []string{\"diffie-hellman-group-exchange-sha256\"}, // not currently supported\n\t\t},\n\t\tHostKeyCallback: InsecureIgnoreHostKey(),\n\t}\n\tif err := tryAuth(t, config); err == nil || !strings.Contains(err.Error(), \"common algorithm\") {\n\t\tt.Errorf(\"got %v, expected 'common algorithm'\", err)\n\t}\n}\n\nfunc TestClientLoginCert(t *testing.T) {\n\tcert := &Certificate{\n\t\tKey:         testPublicKeys[\"rsa\"],\n\t\tValidBefore: CertTimeInfinity,\n\t\tCertType:    UserCert,\n\t}\n\tcert.SignCert(rand.Reader, testSigners[\"ecdsa\"])\n\tcertSigner, err := NewCertSigner(cert, testSigners[\"rsa\"])\n\tif err != nil {\n\t\tt.Fatalf(\"NewCertSigner: %v\", err)\n\t}\n\n\tclientConfig := &ClientConfig{\n\t\tUser:            \"user\",\n\t\tHostKeyCallback: InsecureIgnoreHostKey(),\n\t}\n\tclientConfig.Auth = append(clientConfig.Auth, PublicKeys(certSigner))\n\n\t// should succeed\n\tif err := tryAuth(t, clientConfig); err != nil {\n\t\tt.Errorf(\"cert login failed: %v\", err)\n\t}\n\n\t// corrupted signature\n\tcert.Signature.Blob[0]++\n\tif err := tryAuth(t, clientConfig); err == nil {\n\t\tt.Errorf(\"cert login passed with corrupted sig\")\n\t}\n\n\t// revoked\n\tcert.Serial = 666\n\tcert.SignCert(rand.Reader, testSigners[\"ecdsa\"])\n\tif err := tryAuth(t, clientConfig); err == nil {\n\t\tt.Errorf(\"revoked cert login succeeded\")\n\t}\n\tcert.Serial = 1\n\n\t// sign with wrong key\n\tcert.SignCert(rand.Reader, testSigners[\"dsa\"])\n\tif err := tryAuth(t, clientConfig); err == nil {\n\t\tt.Errorf(\"cert login passed with non-authoritative key\")\n\t}\n\n\t// host cert\n\tcert.CertType = HostCert\n\tcert.SignCert(rand.Reader, testSigners[\"ecdsa\"])\n\tif err := tryAuth(t, clientConfig); err == nil {\n\t\tt.Errorf(\"cert login passed with wrong type\")\n\t}\n\tcert.CertType = UserCert\n\n\t// principal specified\n\tcert.ValidPrincipals = []string{\"user\"}\n\tcert.SignCert(rand.Reader, testSigners[\"ecdsa\"])\n\tif err := tryAuth(t, clientConfig); err != nil {\n\t\tt.Errorf(\"cert login failed: %v\", err)\n\t}\n\n\t// wrong principal specified\n\tcert.ValidPrincipals = []string{\"fred\"}\n\tcert.SignCert(rand.Reader, testSigners[\"ecdsa\"])\n\tif err := tryAuth(t, clientConfig); err == nil {\n\t\tt.Errorf(\"cert login passed with wrong principal\")\n\t}\n\tcert.ValidPrincipals = nil\n\n\t// added critical option\n\tcert.CriticalOptions = map[string]string{\"root-access\": \"yes\"}\n\tcert.SignCert(rand.Reader, testSigners[\"ecdsa\"])\n\tif err := tryAuth(t, clientConfig); err == nil {\n\t\tt.Errorf(\"cert login passed with unrecognized critical option\")\n\t}\n\n\t// allowed source address\n\tcert.CriticalOptions = map[string]string{\"source-address\": \"127.0.0.42/24,::42/120\"}\n\tcert.SignCert(rand.Reader, testSigners[\"ecdsa\"])\n\tif err := tryAuth(t, clientConfig); err != nil {\n\t\tt.Errorf(\"cert login with source-address failed: %v\", err)\n\t}\n\n\t// disallowed source address\n\tcert.CriticalOptions = map[string]string{\"source-address\": \"127.0.0.42,::42\"}\n\tcert.SignCert(rand.Reader, testSigners[\"ecdsa\"])\n\tif err := tryAuth(t, clientConfig); err == nil {\n\t\tt.Errorf(\"cert login with source-address succeeded\")\n\t}\n}\n\nfunc testPermissionsPassing(withPermissions bool, t *testing.T) {\n\tserverConfig := &ServerConfig{\n\t\tPublicKeyCallback: func(conn ConnMetadata, key PublicKey) (*Permissions, error) {\n\t\t\tif conn.User() == \"nopermissions\" {\n\t\t\t\treturn nil, nil\n\t\t\t} else {\n\t\t\t\treturn &Permissions{}, nil\n\t\t\t}\n\t\t},\n\t}\n\tserverConfig.AddHostKey(testSigners[\"rsa\"])\n\n\tclientConfig := &ClientConfig{\n\t\tAuth: []AuthMethod{\n\t\t\tPublicKeys(testSigners[\"rsa\"]),\n\t\t},\n\t\tHostKeyCallback: InsecureIgnoreHostKey(),\n\t}\n\tif withPermissions {\n\t\tclientConfig.User = \"permissions\"\n\t} else {\n\t\tclientConfig.User = \"nopermissions\"\n\t}\n\n\tc1, c2, err := netPipe()\n\tif err != nil {\n\t\tt.Fatalf(\"netPipe: %v\", err)\n\t}\n\tdefer c1.Close()\n\tdefer c2.Close()\n\n\tgo NewClientConn(c2, \"\", clientConfig)\n\tserverConn, err := newServer(c1, serverConfig)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif p := serverConn.Permissions; (p != nil) != withPermissions {\n\t\tt.Fatalf(\"withPermissions is %t, but Permissions object is %#v\", withPermissions, p)\n\t}\n}\n\nfunc TestPermissionsPassing(t *testing.T) {\n\ttestPermissionsPassing(true, t)\n}\n\nfunc TestNoPermissionsPassing(t *testing.T) {\n\ttestPermissionsPassing(false, t)\n}\n\nfunc TestRetryableAuth(t *testing.T) {\n\tn := 0\n\tpasswords := []string{\"WRONG1\", \"WRONG2\"}\n\n\tconfig := &ClientConfig{\n\t\tUser: \"testuser\",\n\t\tAuth: []AuthMethod{\n\t\t\tRetryableAuthMethod(PasswordCallback(func() (string, error) {\n\t\t\t\tp := passwords[n]\n\t\t\t\tn++\n\t\t\t\treturn p, nil\n\t\t\t}), 2),\n\t\t\tPublicKeys(testSigners[\"rsa\"]),\n\t\t},\n\t\tHostKeyCallback: InsecureIgnoreHostKey(),\n\t}\n\n\tif err := tryAuth(t, config); err != nil {\n\t\tt.Fatalf(\"unable to dial remote side: %s\", err)\n\t}\n\tif n != 2 {\n\t\tt.Fatalf(\"Did not try all passwords\")\n\t}\n}\n\nfunc ExampleRetryableAuthMethod(t *testing.T) {\n\tuser := \"testuser\"\n\tNumberOfPrompts := 3\n\n\t// Normally this would be a callback that prompts the user to answer the\n\t// provided questions\n\tCb := func(user, instruction string, questions []string, echos []bool) (answers []string, err error) {\n\t\treturn []string{\"answer1\", \"answer2\"}, nil\n\t}\n\n\tconfig := &ClientConfig{\n\t\tHostKeyCallback: InsecureIgnoreHostKey(),\n\t\tUser:            user,\n\t\tAuth: []AuthMethod{\n\t\t\tRetryableAuthMethod(KeyboardInteractiveChallenge(Cb), NumberOfPrompts),\n\t\t},\n\t}\n\n\tif err := tryAuth(t, config); err != nil {\n\t\tt.Fatalf(\"unable to dial remote side: %s\", err)\n\t}\n}\n\n// Test if username is received on server side when NoClientAuth is used\nfunc TestClientAuthNone(t *testing.T) {\n\tuser := \"testuser\"\n\tserverConfig := &ServerConfig{\n\t\tNoClientAuth: true,\n\t}\n\tserverConfig.AddHostKey(testSigners[\"rsa\"])\n\n\tclientConfig := &ClientConfig{\n\t\tUser:            user,\n\t\tHostKeyCallback: InsecureIgnoreHostKey(),\n\t}\n\n\tc1, c2, err := netPipe()\n\tif err != nil {\n\t\tt.Fatalf(\"netPipe: %v\", err)\n\t}\n\tdefer c1.Close()\n\tdefer c2.Close()\n\n\tgo NewClientConn(c2, \"\", clientConfig)\n\tserverConn, err := newServer(c1, serverConfig)\n\tif err != nil {\n\t\tt.Fatalf(\"newServer: %v\", err)\n\t}\n\tif serverConn.User() != user {\n\t\tt.Fatalf(\"server: got %q, want %q\", serverConn.User(), user)\n\t}\n}\n", "// Copyright 2014 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage ssh\n\nimport (\n\t\"net\"\n\t\"strings\"\n\t\"testing\"\n)\n\nfunc testClientVersion(t *testing.T, config *ClientConfig, expected string) {\n\tclientConn, serverConn := net.Pipe()\n\tdefer clientConn.Close()\n\treceivedVersion := make(chan string, 1)\n\tconfig.HostKeyCallback = InsecureIgnoreHostKey()\n\tgo func() {\n\t\tversion, err := readVersion(serverConn)\n\t\tif err != nil {\n\t\t\treceivedVersion <- \"\"\n\t\t} else {\n\t\t\treceivedVersion <- string(version)\n\t\t}\n\t\tserverConn.Close()\n\t}()\n\tNewClientConn(clientConn, \"\", config)\n\tactual := <-receivedVersion\n\tif actual != expected {\n\t\tt.Fatalf(\"got %s; want %s\", actual, expected)\n\t}\n}\n\nfunc TestCustomClientVersion(t *testing.T) {\n\tversion := \"Test-Client-Version-0.0\"\n\ttestClientVersion(t, &ClientConfig{ClientVersion: version}, version)\n}\n\nfunc TestDefaultClientVersion(t *testing.T) {\n\ttestClientVersion(t, &ClientConfig{}, packageVersion)\n}\n\nfunc TestHostKeyCheck(t *testing.T) {\n\tfor _, tt := range []struct {\n\t\tname      string\n\t\twantError string\n\t\tkey       PublicKey\n\t}{\n\t\t{\"no callback\", \"must specify HostKeyCallback\", nil},\n\t\t{\"correct key\", \"\", testSigners[\"rsa\"].PublicKey()},\n\t\t{\"mismatch\", \"mismatch\", testSigners[\"ecdsa\"].PublicKey()},\n\t} {\n\t\tc1, c2, err := netPipe()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"netPipe: %v\", err)\n\t\t}\n\t\tdefer c1.Close()\n\t\tdefer c2.Close()\n\t\tserverConf := &ServerConfig{\n\t\t\tNoClientAuth: true,\n\t\t}\n\t\tserverConf.AddHostKey(testSigners[\"rsa\"])\n\n\t\tgo NewServerConn(c1, serverConf)\n\t\tclientConf := ClientConfig{\n\t\t\tUser: \"user\",\n\t\t}\n\t\tif tt.key != nil {\n\t\t\tclientConf.HostKeyCallback = FixedHostKey(tt.key)\n\t\t}\n\n\t\t_, _, _, err = NewClientConn(c2, \"\", &clientConf)\n\t\tif err != nil {\n\t\t\tif tt.wantError == \"\" || !strings.Contains(err.Error(), tt.wantError) {\n\t\t\t\tt.Errorf(\"%s: got error %q, missing %q\", err.Error(), tt.wantError)\n\t\t\t}\n\t\t} else if tt.wantError != \"\" {\n\t\t\tt.Errorf(\"%s: succeeded, but want error string %q\", tt.name, tt.wantError)\n\t\t}\n\t}\n}\n", "// Copyright 2011 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n/*\nPackage ssh implements an SSH client and server.\n\nSSH is a transport security protocol, an authentication protocol and a\nfamily of application protocols. The most typical application level\nprotocol is a remote shell and this is specifically implemented.  However,\nthe multiplexed nature of SSH is exposed to users that wish to support\nothers.\n\nReferences:\n  [PROTOCOL.certkeys]: http://cvsweb.openbsd.org/cgi-bin/cvsweb/src/usr.bin/ssh/PROTOCOL.certkeys?rev=HEAD\n  [SSH-PARAMETERS]:    http://www.iana.org/assignments/ssh-parameters/ssh-parameters.xml#ssh-parameters-1\n\nThis package does not fall under the stability promise of the Go language itself,\nso its API may be changed when pressing needs arise.\n*/\npackage ssh // import \"golang.org/x/crypto/ssh\"\n", "// Copyright 2011 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage ssh_test\n\nimport (\n\t\"bufio\"\n\t\"bytes\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"net\"\n\t\"net/http\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\n\t\"golang.org/x/crypto/ssh\"\n\t\"golang.org/x/crypto/ssh/terminal\"\n)\n\nfunc ExampleNewServerConn() {\n\t// Public key authentication is done by comparing\n\t// the public key of a received connection\n\t// with the entries in the authorized_keys file.\n\tauthorizedKeysBytes, err := ioutil.ReadFile(\"authorized_keys\")\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to load authorized_keys, err: %v\", err)\n\t}\n\n\tauthorizedKeysMap := map[string]bool{}\n\tfor len(authorizedKeysBytes) > 0 {\n\t\tpubKey, _, _, rest, err := ssh.ParseAuthorizedKey(authorizedKeysBytes)\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\n\t\tauthorizedKeysMap[string(pubKey.Marshal())] = true\n\t\tauthorizedKeysBytes = rest\n\t}\n\n\t// An SSH server is represented by a ServerConfig, which holds\n\t// certificate details and handles authentication of ServerConns.\n\tconfig := &ssh.ServerConfig{\n\t\t// Remove to disable password auth.\n\t\tPasswordCallback: func(c ssh.ConnMetadata, pass []byte) (*ssh.Permissions, error) {\n\t\t\t// Should use constant-time compare (or better, salt+hash) in\n\t\t\t// a production setting.\n\t\t\tif c.User() == \"testuser\" && string(pass) == \"tiger\" {\n\t\t\t\treturn nil, nil\n\t\t\t}\n\t\t\treturn nil, fmt.Errorf(\"password rejected for %q\", c.User())\n\t\t},\n\n\t\t// Remove to disable public key auth.\n\t\tPublicKeyCallback: func(c ssh.ConnMetadata, pubKey ssh.PublicKey) (*ssh.Permissions, error) {\n\t\t\tif authorizedKeysMap[string(pubKey.Marshal())] {\n\t\t\t\treturn nil, nil\n\t\t\t}\n\t\t\treturn nil, fmt.Errorf(\"unknown public key for %q\", c.User())\n\t\t},\n\t}\n\n\tprivateBytes, err := ioutil.ReadFile(\"id_rsa\")\n\tif err != nil {\n\t\tlog.Fatal(\"Failed to load private key: \", err)\n\t}\n\n\tprivate, err := ssh.ParsePrivateKey(privateBytes)\n\tif err != nil {\n\t\tlog.Fatal(\"Failed to parse private key: \", err)\n\t}\n\n\tconfig.AddHostKey(private)\n\n\t// Once a ServerConfig has been configured, connections can be\n\t// accepted.\n\tlistener, err := net.Listen(\"tcp\", \"0.0.0.0:2022\")\n\tif err != nil {\n\t\tlog.Fatal(\"failed to listen for connection: \", err)\n\t}\n\tnConn, err := listener.Accept()\n\tif err != nil {\n\t\tlog.Fatal(\"failed to accept incoming connection: \", err)\n\t}\n\n\t// Before use, a handshake must be performed on the incoming\n\t// net.Conn.\n\t_, chans, reqs, err := ssh.NewServerConn(nConn, config)\n\tif err != nil {\n\t\tlog.Fatal(\"failed to handshake: \", err)\n\t}\n\t// The incoming Request channel must be serviced.\n\tgo ssh.DiscardRequests(reqs)\n\n\t// Service the incoming Channel channel.\n\tfor newChannel := range chans {\n\t\t// Channels have a type, depending on the application level\n\t\t// protocol intended. In the case of a shell, the type is\n\t\t// \"session\" and ServerShell may be used to present a simple\n\t\t// terminal interface.\n\t\tif newChannel.ChannelType() != \"session\" {\n\t\t\tnewChannel.Reject(ssh.UnknownChannelType, \"unknown channel type\")\n\t\t\tcontinue\n\t\t}\n\t\tchannel, requests, err := newChannel.Accept()\n\t\tif err != nil {\n\t\t\tlog.Fatalf(\"Could not accept channel: %v\", err)\n\t\t}\n\n\t\t// Sessions have out-of-band requests such as \"shell\",\n\t\t// \"pty-req\" and \"env\".  Here we handle only the\n\t\t// \"shell\" request.\n\t\tgo func(in <-chan *ssh.Request) {\n\t\t\tfor req := range in {\n\t\t\t\treq.Reply(req.Type == \"shell\", nil)\n\t\t\t}\n\t\t}(requests)\n\n\t\tterm := terminal.NewTerminal(channel, \"> \")\n\n\t\tgo func() {\n\t\t\tdefer channel.Close()\n\t\t\tfor {\n\t\t\t\tline, err := term.ReadLine()\n\t\t\t\tif err != nil {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tfmt.Println(line)\n\t\t\t}\n\t\t}()\n\t}\n}\n\nfunc ExampleHostKeyCheck() {\n\t// Every client must provide a host key check.  Here is a\n\t// simple-minded parse of OpenSSH's known_hosts file\n\thost := \"hostname\"\n\tfile, err := os.Open(filepath.Join(os.Getenv(\"HOME\"), \".ssh\", \"known_hosts\"))\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer file.Close()\n\n\tscanner := bufio.NewScanner(file)\n\tvar hostKey ssh.PublicKey\n\tfor scanner.Scan() {\n\t\tfields := strings.Split(scanner.Text(), \" \")\n\t\tif len(fields) != 3 {\n\t\t\tcontinue\n\t\t}\n\t\tif strings.Contains(fields[0], host) {\n\t\t\tvar err error\n\t\t\thostKey, _, _, _, err = ssh.ParseAuthorizedKey(scanner.Bytes())\n\t\t\tif err != nil {\n\t\t\t\tlog.Fatalf(\"error parsing %q: %v\", fields[2], err)\n\t\t\t}\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif hostKey == nil {\n\t\tlog.Fatalf(\"no hostkey for %s\", host)\n\t}\n\n\tconfig := ssh.ClientConfig{\n\t\tUser:            os.Getenv(\"USER\"),\n\t\tHostKeyCallback: ssh.FixedHostKey(hostKey),\n\t}\n\n\t_, err = ssh.Dial(\"tcp\", host+\":22\", &config)\n\tlog.Println(err)\n}\n\nfunc ExampleDial() {\n\tvar hostKey ssh.PublicKey\n\t// An SSH client is represented with a ClientConn.\n\t//\n\t// To authenticate with the remote server you must pass at least one\n\t// implementation of AuthMethod via the Auth field in ClientConfig,\n\t// and provide a HostKeyCallback.\n\tconfig := &ssh.ClientConfig{\n\t\tUser: \"username\",\n\t\tAuth: []ssh.AuthMethod{\n\t\t\tssh.Password(\"yourpassword\"),\n\t\t},\n\t\tHostKeyCallback: ssh.FixedHostKey(hostKey),\n\t}\n\tclient, err := ssh.Dial(\"tcp\", \"yourserver.com:22\", config)\n\tif err != nil {\n\t\tlog.Fatal(\"Failed to dial: \", err)\n\t}\n\n\t// Each ClientConn can support multiple interactive sessions,\n\t// represented by a Session.\n\tsession, err := client.NewSession()\n\tif err != nil {\n\t\tlog.Fatal(\"Failed to create session: \", err)\n\t}\n\tdefer session.Close()\n\n\t// Once a Session is created, you can execute a single command on\n\t// the remote side using the Run method.\n\tvar b bytes.Buffer\n\tsession.Stdout = &b\n\tif err := session.Run(\"/usr/bin/whoami\"); err != nil {\n\t\tlog.Fatal(\"Failed to run: \" + err.Error())\n\t}\n\tfmt.Println(b.String())\n}\n\nfunc ExamplePublicKeys() {\n\tvar hostKey ssh.PublicKey\n\t// A public key may be used to authenticate against the remote\n\t// server by using an unencrypted PEM-encoded private key file.\n\t//\n\t// If you have an encrypted private key, the crypto/x509 package\n\t// can be used to decrypt it.\n\tkey, err := ioutil.ReadFile(\"/home/user/.ssh/id_rsa\")\n\tif err != nil {\n\t\tlog.Fatalf(\"unable to read private key: %v\", err)\n\t}\n\n\t// Create the Signer for this private key.\n\tsigner, err := ssh.ParsePrivateKey(key)\n\tif err != nil {\n\t\tlog.Fatalf(\"unable to parse private key: %v\", err)\n\t}\n\n\tconfig := &ssh.ClientConfig{\n\t\tUser: \"user\",\n\t\tAuth: []ssh.AuthMethod{\n\t\t\t// Use the PublicKeys method for remote authentication.\n\t\t\tssh.PublicKeys(signer),\n\t\t},\n\t\tHostKeyCallback: ssh.FixedHostKey(hostKey),\n\t}\n\n\t// Connect to the remote server and perform the SSH handshake.\n\tclient, err := ssh.Dial(\"tcp\", \"host.com:22\", config)\n\tif err != nil {\n\t\tlog.Fatalf(\"unable to connect: %v\", err)\n\t}\n\tdefer client.Close()\n}\n\nfunc ExampleClient_Listen() {\n\tvar hostKey ssh.PublicKey\n\tconfig := &ssh.ClientConfig{\n\t\tUser: \"username\",\n\t\tAuth: []ssh.AuthMethod{\n\t\t\tssh.Password(\"password\"),\n\t\t},\n\t\tHostKeyCallback: ssh.FixedHostKey(hostKey),\n\t}\n\t// Dial your ssh server.\n\tconn, err := ssh.Dial(\"tcp\", \"localhost:22\", config)\n\tif err != nil {\n\t\tlog.Fatal(\"unable to connect: \", err)\n\t}\n\tdefer conn.Close()\n\n\t// Request the remote side to open port 8080 on all interfaces.\n\tl, err := conn.Listen(\"tcp\", \"0.0.0.0:8080\")\n\tif err != nil {\n\t\tlog.Fatal(\"unable to register tcp forward: \", err)\n\t}\n\tdefer l.Close()\n\n\t// Serve HTTP with your SSH server acting as a reverse proxy.\n\thttp.Serve(l, http.HandlerFunc(func(resp http.ResponseWriter, req *http.Request) {\n\t\tfmt.Fprintf(resp, \"Hello world!\\n\")\n\t}))\n}\n\nfunc ExampleSession_RequestPty() {\n\tvar hostKey ssh.PublicKey\n\t// Create client config\n\tconfig := &ssh.ClientConfig{\n\t\tUser: \"username\",\n\t\tAuth: []ssh.AuthMethod{\n\t\t\tssh.Password(\"password\"),\n\t\t},\n\t\tHostKeyCallback: ssh.FixedHostKey(hostKey),\n\t}\n\t// Connect to ssh server\n\tconn, err := ssh.Dial(\"tcp\", \"localhost:22\", config)\n\tif err != nil {\n\t\tlog.Fatal(\"unable to connect: \", err)\n\t}\n\tdefer conn.Close()\n\t// Create a session\n\tsession, err := conn.NewSession()\n\tif err != nil {\n\t\tlog.Fatal(\"unable to create session: \", err)\n\t}\n\tdefer session.Close()\n\t// Set up terminal modes\n\tmodes := ssh.TerminalModes{\n\t\tssh.ECHO:          0,     // disable echoing\n\t\tssh.TTY_OP_ISPEED: 14400, // input speed = 14.4kbaud\n\t\tssh.TTY_OP_OSPEED: 14400, // output speed = 14.4kbaud\n\t}\n\t// Request pseudo terminal\n\tif err := session.RequestPty(\"xterm\", 40, 80, modes); err != nil {\n\t\tlog.Fatal(\"request for pseudo terminal failed: \", err)\n\t}\n\t// Start remote shell\n\tif err := session.Shell(); err != nil {\n\t\tlog.Fatal(\"failed to start shell: \", err)\n\t}\n}\n", "// Copyright 2013 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage ssh\n\nimport (\n\t\"crypto/rand\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"net\"\n\t\"sync\"\n)\n\n// debugHandshake, if set, prints messages sent and received.  Key\n// exchange messages are printed as if DH were used, so the debug\n// messages are wrong when using ECDH.\nconst debugHandshake = false\n\n// chanSize sets the amount of buffering SSH connections. This is\n// primarily for testing: setting chanSize=0 uncovers deadlocks more\n// quickly.\nconst chanSize = 16\n\n// keyingTransport is a packet based transport that supports key\n// changes. It need not be thread-safe. It should pass through\n// msgNewKeys in both directions.\ntype keyingTransport interface {\n\tpacketConn\n\n\t// prepareKeyChange sets up a key change. The key change for a\n\t// direction will be effected if a msgNewKeys message is sent\n\t// or received.\n\tprepareKeyChange(*algorithms, *kexResult) error\n}\n\n// handshakeTransport implements rekeying on top of a keyingTransport\n// and offers a thread-safe writePacket() interface.\ntype handshakeTransport struct {\n\tconn   keyingTransport\n\tconfig *Config\n\n\tserverVersion []byte\n\tclientVersion []byte\n\n\t// hostKeys is non-empty if we are the server. In that case,\n\t// it contains all host keys that can be used to sign the\n\t// connection.\n\thostKeys []Signer\n\n\t// hostKeyAlgorithms is non-empty if we are the client. In that case,\n\t// we accept these key types from the server as host key.\n\thostKeyAlgorithms []string\n\n\t// On read error, incoming is closed, and readError is set.\n\tincoming  chan []byte\n\treadError error\n\n\tmu             sync.Mutex\n\twriteError     error\n\tsentInitPacket []byte\n\tsentInitMsg    *kexInitMsg\n\tpendingPackets [][]byte // Used when a key exchange is in progress.\n\n\t// If the read loop wants to schedule a kex, it pings this\n\t// channel, and the write loop will send out a kex\n\t// message.\n\trequestKex chan struct{}\n\n\t// If the other side requests or confirms a kex, its kexInit\n\t// packet is sent here for the write loop to find it.\n\tstartKex chan *pendingKex\n\n\t// data for host key checking\n\thostKeyCallback HostKeyCallback\n\tdialAddress     string\n\tremoteAddr      net.Addr\n\n\t// Algorithms agreed in the last key exchange.\n\talgorithms *algorithms\n\n\treadPacketsLeft uint32\n\treadBytesLeft   int64\n\n\twritePacketsLeft uint32\n\twriteBytesLeft   int64\n\n\t// The session ID or nil if first kex did not complete yet.\n\tsessionID []byte\n}\n\ntype pendingKex struct {\n\totherInit []byte\n\tdone      chan error\n}\n\nfunc newHandshakeTransport(conn keyingTransport, config *Config, clientVersion, serverVersion []byte) *handshakeTransport {\n\tt := &handshakeTransport{\n\t\tconn:          conn,\n\t\tserverVersion: serverVersion,\n\t\tclientVersion: clientVersion,\n\t\tincoming:      make(chan []byte, chanSize),\n\t\trequestKex:    make(chan struct{}, 1),\n\t\tstartKex:      make(chan *pendingKex, 1),\n\n\t\tconfig: config,\n\t}\n\n\t// We always start with a mandatory key exchange.\n\tt.requestKex <- struct{}{}\n\treturn t\n}\n\nfunc newClientTransport(conn keyingTransport, clientVersion, serverVersion []byte, config *ClientConfig, dialAddr string, addr net.Addr) *handshakeTransport {\n\tt := newHandshakeTransport(conn, &config.Config, clientVersion, serverVersion)\n\tt.dialAddress = dialAddr\n\tt.remoteAddr = addr\n\tt.hostKeyCallback = config.HostKeyCallback\n\tif config.HostKeyAlgorithms != nil {\n\t\tt.hostKeyAlgorithms = config.HostKeyAlgorithms\n\t} else {\n\t\tt.hostKeyAlgorithms = supportedHostKeyAlgos\n\t}\n\tgo t.readLoop()\n\tgo t.kexLoop()\n\treturn t\n}\n\nfunc newServerTransport(conn keyingTransport, clientVersion, serverVersion []byte, config *ServerConfig) *handshakeTransport {\n\tt := newHandshakeTransport(conn, &config.Config, clientVersion, serverVersion)\n\tt.hostKeys = config.hostKeys\n\tgo t.readLoop()\n\tgo t.kexLoop()\n\treturn t\n}\n\nfunc (t *handshakeTransport) getSessionID() []byte {\n\treturn t.sessionID\n}\n\n// waitSession waits for the session to be established. This should be\n// the first thing to call after instantiating handshakeTransport.\nfunc (t *handshakeTransport) waitSession() error {\n\tp, err := t.readPacket()\n\tif err != nil {\n\t\treturn err\n\t}\n\tif p[0] != msgNewKeys {\n\t\treturn fmt.Errorf(\"ssh: first packet should be msgNewKeys\")\n\t}\n\n\treturn nil\n}\n\nfunc (t *handshakeTransport) id() string {\n\tif len(t.hostKeys) > 0 {\n\t\treturn \"server\"\n\t}\n\treturn \"client\"\n}\n\nfunc (t *handshakeTransport) printPacket(p []byte, write bool) {\n\taction := \"got\"\n\tif write {\n\t\taction = \"sent\"\n\t}\n\n\tif p[0] == msgChannelData || p[0] == msgChannelExtendedData {\n\t\tlog.Printf(\"%s %s data (packet %d bytes)\", t.id(), action, len(p))\n\t} else {\n\t\tmsg, err := decode(p)\n\t\tlog.Printf(\"%s %s %T %v (%v)\", t.id(), action, msg, msg, err)\n\t}\n}\n\nfunc (t *handshakeTransport) readPacket() ([]byte, error) {\n\tp, ok := <-t.incoming\n\tif !ok {\n\t\treturn nil, t.readError\n\t}\n\treturn p, nil\n}\n\nfunc (t *handshakeTransport) readLoop() {\n\tfirst := true\n\tfor {\n\t\tp, err := t.readOnePacket(first)\n\t\tfirst = false\n\t\tif err != nil {\n\t\t\tt.readError = err\n\t\t\tclose(t.incoming)\n\t\t\tbreak\n\t\t}\n\t\tif p[0] == msgIgnore || p[0] == msgDebug {\n\t\t\tcontinue\n\t\t}\n\t\tt.incoming <- p\n\t}\n\n\t// Stop writers too.\n\tt.recordWriteError(t.readError)\n\n\t// Unblock the writer should it wait for this.\n\tclose(t.startKex)\n\n\t// Don't close t.requestKex; it's also written to from writePacket.\n}\n\nfunc (t *handshakeTransport) pushPacket(p []byte) error {\n\tif debugHandshake {\n\t\tt.printPacket(p, true)\n\t}\n\treturn t.conn.writePacket(p)\n}\n\nfunc (t *handshakeTransport) getWriteError() error {\n\tt.mu.Lock()\n\tdefer t.mu.Unlock()\n\treturn t.writeError\n}\n\nfunc (t *handshakeTransport) recordWriteError(err error) {\n\tt.mu.Lock()\n\tdefer t.mu.Unlock()\n\tif t.writeError == nil && err != nil {\n\t\tt.writeError = err\n\t}\n}\n\nfunc (t *handshakeTransport) requestKeyExchange() {\n\tselect {\n\tcase t.requestKex <- struct{}{}:\n\tdefault:\n\t\t// something already requested a kex, so do nothing.\n\t}\n}\n\nfunc (t *handshakeTransport) kexLoop() {\n\nwrite:\n\tfor t.getWriteError() == nil {\n\t\tvar request *pendingKex\n\t\tvar sent bool\n\n\t\tfor request == nil || !sent {\n\t\t\tvar ok bool\n\t\t\tselect {\n\t\t\tcase request, ok = <-t.startKex:\n\t\t\t\tif !ok {\n\t\t\t\t\tbreak write\n\t\t\t\t}\n\t\t\tcase <-t.requestKex:\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tif !sent {\n\t\t\t\tif err := t.sendKexInit(); err != nil {\n\t\t\t\t\tt.recordWriteError(err)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tsent = true\n\t\t\t}\n\t\t}\n\n\t\tif err := t.getWriteError(); err != nil {\n\t\t\tif request != nil {\n\t\t\t\trequest.done <- err\n\t\t\t}\n\t\t\tbreak\n\t\t}\n\n\t\t// We're not servicing t.requestKex, but that is OK:\n\t\t// we never block on sending to t.requestKex.\n\n\t\t// We're not servicing t.startKex, but the remote end\n\t\t// has just sent us a kexInitMsg, so it can't send\n\t\t// another key change request, until we close the done\n\t\t// channel on the pendingKex request.\n\n\t\terr := t.enterKeyExchange(request.otherInit)\n\n\t\tt.mu.Lock()\n\t\tt.writeError = err\n\t\tt.sentInitPacket = nil\n\t\tt.sentInitMsg = nil\n\t\tt.writePacketsLeft = packetRekeyThreshold\n\t\tif t.config.RekeyThreshold > 0 {\n\t\t\tt.writeBytesLeft = int64(t.config.RekeyThreshold)\n\t\t} else if t.algorithms != nil {\n\t\t\tt.writeBytesLeft = t.algorithms.w.rekeyBytes()\n\t\t}\n\n\t\t// we have completed the key exchange. Since the\n\t\t// reader is still blocked, it is safe to clear out\n\t\t// the requestKex channel. This avoids the situation\n\t\t// where: 1) we consumed our own request for the\n\t\t// initial kex, and 2) the kex from the remote side\n\t\t// caused another send on the requestKex channel,\n\tclear:\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-t.requestKex:\n\t\t\t\t//\n\t\t\tdefault:\n\t\t\t\tbreak clear\n\t\t\t}\n\t\t}\n\n\t\trequest.done <- t.writeError\n\n\t\t// kex finished. Push packets that we received while\n\t\t// the kex was in progress. Don't look at t.startKex\n\t\t// and don't increment writtenSinceKex: if we trigger\n\t\t// another kex while we are still busy with the last\n\t\t// one, things will become very confusing.\n\t\tfor _, p := range t.pendingPackets {\n\t\t\tt.writeError = t.pushPacket(p)\n\t\t\tif t.writeError != nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tt.pendingPackets = t.pendingPackets[:0]\n\t\tt.mu.Unlock()\n\t}\n\n\t// drain startKex channel. We don't service t.requestKex\n\t// because nobody does blocking sends there.\n\tgo func() {\n\t\tfor init := range t.startKex {\n\t\t\tinit.done <- t.writeError\n\t\t}\n\t}()\n\n\t// Unblock reader.\n\tt.conn.Close()\n}\n\n// The protocol uses uint32 for packet counters, so we can't let them\n// reach 1<<32.  We will actually read and write more packets than\n// this, though: the other side may send more packets, and after we\n// hit this limit on writing we will send a few more packets for the\n// key exchange itself.\nconst packetRekeyThreshold = (1 << 31)\n\nfunc (t *handshakeTransport) readOnePacket(first bool) ([]byte, error) {\n\tp, err := t.conn.readPacket()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif t.readPacketsLeft > 0 {\n\t\tt.readPacketsLeft--\n\t} else {\n\t\tt.requestKeyExchange()\n\t}\n\n\tif t.readBytesLeft > 0 {\n\t\tt.readBytesLeft -= int64(len(p))\n\t} else {\n\t\tt.requestKeyExchange()\n\t}\n\n\tif debugHandshake {\n\t\tt.printPacket(p, false)\n\t}\n\n\tif first && p[0] != msgKexInit {\n\t\treturn nil, fmt.Errorf(\"ssh: first packet should be msgKexInit\")\n\t}\n\n\tif p[0] != msgKexInit {\n\t\treturn p, nil\n\t}\n\n\tfirstKex := t.sessionID == nil\n\n\tkex := pendingKex{\n\t\tdone:      make(chan error, 1),\n\t\totherInit: p,\n\t}\n\tt.startKex <- &kex\n\terr = <-kex.done\n\n\tif debugHandshake {\n\t\tlog.Printf(\"%s exited key exchange (first %v), err %v\", t.id(), firstKex, err)\n\t}\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tt.readPacketsLeft = packetRekeyThreshold\n\tif t.config.RekeyThreshold > 0 {\n\t\tt.readBytesLeft = int64(t.config.RekeyThreshold)\n\t} else {\n\t\tt.readBytesLeft = t.algorithms.r.rekeyBytes()\n\t}\n\n\t// By default, a key exchange is hidden from higher layers by\n\t// translating it into msgIgnore.\n\tsuccessPacket := []byte{msgIgnore}\n\tif firstKex {\n\t\t// sendKexInit() for the first kex waits for\n\t\t// msgNewKeys so the authentication process is\n\t\t// guaranteed to happen over an encrypted transport.\n\t\tsuccessPacket = []byte{msgNewKeys}\n\t}\n\n\treturn successPacket, nil\n}\n\n// sendKexInit sends a key change message.\nfunc (t *handshakeTransport) sendKexInit() error {\n\tt.mu.Lock()\n\tdefer t.mu.Unlock()\n\tif t.sentInitMsg != nil {\n\t\t// kexInits may be sent either in response to the other side,\n\t\t// or because our side wants to initiate a key change, so we\n\t\t// may have already sent a kexInit. In that case, don't send a\n\t\t// second kexInit.\n\t\treturn nil\n\t}\n\n\tmsg := &kexInitMsg{\n\t\tKexAlgos:                t.config.KeyExchanges,\n\t\tCiphersClientServer:     t.config.Ciphers,\n\t\tCiphersServerClient:     t.config.Ciphers,\n\t\tMACsClientServer:        t.config.MACs,\n\t\tMACsServerClient:        t.config.MACs,\n\t\tCompressionClientServer: supportedCompressions,\n\t\tCompressionServerClient: supportedCompressions,\n\t}\n\tio.ReadFull(rand.Reader, msg.Cookie[:])\n\n\tif len(t.hostKeys) > 0 {\n\t\tfor _, k := range t.hostKeys {\n\t\t\tmsg.ServerHostKeyAlgos = append(\n\t\t\t\tmsg.ServerHostKeyAlgos, k.PublicKey().Type())\n\t\t}\n\t} else {\n\t\tmsg.ServerHostKeyAlgos = t.hostKeyAlgorithms\n\t}\n\tpacket := Marshal(msg)\n\n\t// writePacket destroys the contents, so save a copy.\n\tpacketCopy := make([]byte, len(packet))\n\tcopy(packetCopy, packet)\n\n\tif err := t.pushPacket(packetCopy); err != nil {\n\t\treturn err\n\t}\n\n\tt.sentInitMsg = msg\n\tt.sentInitPacket = packet\n\n\treturn nil\n}\n\nfunc (t *handshakeTransport) writePacket(p []byte) error {\n\tswitch p[0] {\n\tcase msgKexInit:\n\t\treturn errors.New(\"ssh: only handshakeTransport can send kexInit\")\n\tcase msgNewKeys:\n\t\treturn errors.New(\"ssh: only handshakeTransport can send newKeys\")\n\t}\n\n\tt.mu.Lock()\n\tdefer t.mu.Unlock()\n\tif t.writeError != nil {\n\t\treturn t.writeError\n\t}\n\n\tif t.sentInitMsg != nil {\n\t\t// Copy the packet so the writer can reuse the buffer.\n\t\tcp := make([]byte, len(p))\n\t\tcopy(cp, p)\n\t\tt.pendingPackets = append(t.pendingPackets, cp)\n\t\treturn nil\n\t}\n\n\tif t.writeBytesLeft > 0 {\n\t\tt.writeBytesLeft -= int64(len(p))\n\t} else {\n\t\tt.requestKeyExchange()\n\t}\n\n\tif t.writePacketsLeft > 0 {\n\t\tt.writePacketsLeft--\n\t} else {\n\t\tt.requestKeyExchange()\n\t}\n\n\tif err := t.pushPacket(p); err != nil {\n\t\tt.writeError = err\n\t}\n\n\treturn nil\n}\n\nfunc (t *handshakeTransport) Close() error {\n\treturn t.conn.Close()\n}\n\nfunc (t *handshakeTransport) enterKeyExchange(otherInitPacket []byte) error {\n\tif debugHandshake {\n\t\tlog.Printf(\"%s entered key exchange\", t.id())\n\t}\n\n\totherInit := &kexInitMsg{}\n\tif err := Unmarshal(otherInitPacket, otherInit); err != nil {\n\t\treturn err\n\t}\n\n\tmagics := handshakeMagics{\n\t\tclientVersion: t.clientVersion,\n\t\tserverVersion: t.serverVersion,\n\t\tclientKexInit: otherInitPacket,\n\t\tserverKexInit: t.sentInitPacket,\n\t}\n\n\tclientInit := otherInit\n\tserverInit := t.sentInitMsg\n\tif len(t.hostKeys) == 0 {\n\t\tclientInit, serverInit = serverInit, clientInit\n\n\t\tmagics.clientKexInit = t.sentInitPacket\n\t\tmagics.serverKexInit = otherInitPacket\n\t}\n\n\tvar err error\n\tt.algorithms, err = findAgreedAlgorithms(clientInit, serverInit)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// We don't send FirstKexFollows, but we handle receiving it.\n\t//\n\t// RFC 4253 section 7 defines the kex and the agreement method for\n\t// first_kex_packet_follows. It states that the guessed packet\n\t// should be ignored if the \"kex algorithm and/or the host\n\t// key algorithm is guessed wrong (server and client have\n\t// different preferred algorithm), or if any of the other\n\t// algorithms cannot be agreed upon\". The other algorithms have\n\t// already been checked above so the kex algorithm and host key\n\t// algorithm are checked here.\n\tif otherInit.FirstKexFollows && (clientInit.KexAlgos[0] != serverInit.KexAlgos[0] || clientInit.ServerHostKeyAlgos[0] != serverInit.ServerHostKeyAlgos[0]) {\n\t\t// other side sent a kex message for the wrong algorithm,\n\t\t// which we have to ignore.\n\t\tif _, err := t.conn.readPacket(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tkex, ok := kexAlgoMap[t.algorithms.kex]\n\tif !ok {\n\t\treturn fmt.Errorf(\"ssh: unexpected key exchange algorithm %v\", t.algorithms.kex)\n\t}\n\n\tvar result *kexResult\n\tif len(t.hostKeys) > 0 {\n\t\tresult, err = t.server(kex, t.algorithms, &magics)\n\t} else {\n\t\tresult, err = t.client(kex, t.algorithms, &magics)\n\t}\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif t.sessionID == nil {\n\t\tt.sessionID = result.H\n\t}\n\tresult.SessionID = t.sessionID\n\n\tt.conn.prepareKeyChange(t.algorithms, result)\n\tif err = t.conn.writePacket([]byte{msgNewKeys}); err != nil {\n\t\treturn err\n\t}\n\tif packet, err := t.conn.readPacket(); err != nil {\n\t\treturn err\n\t} else if packet[0] != msgNewKeys {\n\t\treturn unexpectedMessageError(msgNewKeys, packet[0])\n\t}\n\n\treturn nil\n}\n\nfunc (t *handshakeTransport) server(kex kexAlgorithm, algs *algorithms, magics *handshakeMagics) (*kexResult, error) {\n\tvar hostKey Signer\n\tfor _, k := range t.hostKeys {\n\t\tif algs.hostKey == k.PublicKey().Type() {\n\t\t\thostKey = k\n\t\t}\n\t}\n\n\tr, err := kex.Server(t.conn, t.config.Rand, magics, hostKey)\n\treturn r, err\n}\n\nfunc (t *handshakeTransport) client(kex kexAlgorithm, algs *algorithms, magics *handshakeMagics) (*kexResult, error) {\n\tresult, err := kex.Client(t.conn, t.config.Rand, magics)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\thostKey, err := ParsePublicKey(result.HostKey)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif err := verifyHostKeySignature(hostKey, result); err != nil {\n\t\treturn nil, err\n\t}\n\n\terr = t.hostKeyCallback(t.dialAddress, t.remoteAddr, hostKey)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn result, nil\n}\n", "// Copyright 2013 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage ssh\n\nimport (\n\t\"bytes\"\n\t\"crypto/rand\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n\t\"reflect\"\n\t\"runtime\"\n\t\"strings\"\n\t\"sync\"\n\t\"testing\"\n)\n\ntype testChecker struct {\n\tcalls []string\n}\n\nfunc (t *testChecker) Check(dialAddr string, addr net.Addr, key PublicKey) error {\n\tif dialAddr == \"bad\" {\n\t\treturn fmt.Errorf(\"dialAddr is bad\")\n\t}\n\n\tif tcpAddr, ok := addr.(*net.TCPAddr); !ok || tcpAddr == nil {\n\t\treturn fmt.Errorf(\"testChecker: got %T want *net.TCPAddr\", addr)\n\t}\n\n\tt.calls = append(t.calls, fmt.Sprintf(\"%s %v %s %x\", dialAddr, addr, key.Type(), key.Marshal()))\n\n\treturn nil\n}\n\n// netPipe is analogous to net.Pipe, but it uses a real net.Conn, and\n// therefore is buffered (net.Pipe deadlocks if both sides start with\n// a write.)\nfunc netPipe() (net.Conn, net.Conn, error) {\n\tlistener, err := net.Listen(\"tcp\", \":0\")\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tdefer listener.Close()\n\tc1, err := net.Dial(\"tcp\", listener.Addr().String())\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tc2, err := listener.Accept()\n\tif err != nil {\n\t\tc1.Close()\n\t\treturn nil, nil, err\n\t}\n\n\treturn c1, c2, nil\n}\n\n// noiseTransport inserts ignore messages to check that the read loop\n// and the key exchange filters out these messages.\ntype noiseTransport struct {\n\tkeyingTransport\n}\n\nfunc (t *noiseTransport) writePacket(p []byte) error {\n\tignore := []byte{msgIgnore}\n\tif err := t.keyingTransport.writePacket(ignore); err != nil {\n\t\treturn err\n\t}\n\tdebug := []byte{msgDebug, 1, 2, 3}\n\tif err := t.keyingTransport.writePacket(debug); err != nil {\n\t\treturn err\n\t}\n\n\treturn t.keyingTransport.writePacket(p)\n}\n\nfunc addNoiseTransport(t keyingTransport) keyingTransport {\n\treturn &noiseTransport{t}\n}\n\n// handshakePair creates two handshakeTransports connected with each\n// other. If the noise argument is true, both transports will try to\n// confuse the other side by sending ignore and debug messages.\nfunc handshakePair(clientConf *ClientConfig, addr string, noise bool) (client *handshakeTransport, server *handshakeTransport, err error) {\n\ta, b, err := netPipe()\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar trC, trS keyingTransport\n\n\ttrC = newTransport(a, rand.Reader, true)\n\ttrS = newTransport(b, rand.Reader, false)\n\tif noise {\n\t\ttrC = addNoiseTransport(trC)\n\t\ttrS = addNoiseTransport(trS)\n\t}\n\tclientConf.SetDefaults()\n\n\tv := []byte(\"version\")\n\tclient = newClientTransport(trC, v, v, clientConf, addr, a.RemoteAddr())\n\n\tserverConf := &ServerConfig{}\n\tserverConf.AddHostKey(testSigners[\"ecdsa\"])\n\tserverConf.AddHostKey(testSigners[\"rsa\"])\n\tserverConf.SetDefaults()\n\tserver = newServerTransport(trS, v, v, serverConf)\n\n\tif err := server.waitSession(); err != nil {\n\t\treturn nil, nil, fmt.Errorf(\"server.waitSession: %v\", err)\n\t}\n\tif err := client.waitSession(); err != nil {\n\t\treturn nil, nil, fmt.Errorf(\"client.waitSession: %v\", err)\n\t}\n\n\treturn client, server, nil\n}\n\nfunc TestHandshakeBasic(t *testing.T) {\n\tif runtime.GOOS == \"plan9\" {\n\t\tt.Skip(\"see golang.org/issue/7237\")\n\t}\n\n\tchecker := &syncChecker{\n\t\twaitCall: make(chan int, 10),\n\t\tcalled:   make(chan int, 10),\n\t}\n\n\tchecker.waitCall <- 1\n\ttrC, trS, err := handshakePair(&ClientConfig{HostKeyCallback: checker.Check}, \"addr\", false)\n\tif err != nil {\n\t\tt.Fatalf(\"handshakePair: %v\", err)\n\t}\n\n\tdefer trC.Close()\n\tdefer trS.Close()\n\n\t// Let first kex complete normally.\n\t<-checker.called\n\n\tclientDone := make(chan int, 0)\n\tgotHalf := make(chan int, 0)\n\tconst N = 20\n\n\tgo func() {\n\t\tdefer close(clientDone)\n\t\t// Client writes a bunch of stuff, and does a key\n\t\t// change in the middle. This should not confuse the\n\t\t// handshake in progress. We do this twice, so we test\n\t\t// that the packet buffer is reset correctly.\n\t\tfor i := 0; i < N; i++ {\n\t\t\tp := []byte{msgRequestSuccess, byte(i)}\n\t\t\tif err := trC.writePacket(p); err != nil {\n\t\t\t\tt.Fatalf(\"sendPacket: %v\", err)\n\t\t\t}\n\t\t\tif (i % 10) == 5 {\n\t\t\t\t<-gotHalf\n\t\t\t\t// halfway through, we request a key change.\n\t\t\t\ttrC.requestKeyExchange()\n\n\t\t\t\t// Wait until we can be sure the key\n\t\t\t\t// change has really started before we\n\t\t\t\t// write more.\n\t\t\t\t<-checker.called\n\t\t\t}\n\t\t\tif (i % 10) == 7 {\n\t\t\t\t// write some packets until the kex\n\t\t\t\t// completes, to test buffering of\n\t\t\t\t// packets.\n\t\t\t\tchecker.waitCall <- 1\n\t\t\t}\n\t\t}\n\t}()\n\n\t// Server checks that client messages come in cleanly\n\ti := 0\n\terr = nil\n\tfor ; i < N; i++ {\n\t\tvar p []byte\n\t\tp, err = trS.readPacket()\n\t\tif err != nil {\n\t\t\tbreak\n\t\t}\n\t\tif (i % 10) == 5 {\n\t\t\tgotHalf <- 1\n\t\t}\n\n\t\twant := []byte{msgRequestSuccess, byte(i)}\n\t\tif bytes.Compare(p, want) != 0 {\n\t\t\tt.Errorf(\"message %d: got %v, want %v\", i, p, want)\n\t\t}\n\t}\n\t<-clientDone\n\tif err != nil && err != io.EOF {\n\t\tt.Fatalf(\"server error: %v\", err)\n\t}\n\tif i != N {\n\t\tt.Errorf(\"received %d messages, want 10.\", i)\n\t}\n\n\tclose(checker.called)\n\tif _, ok := <-checker.called; ok {\n\t\t// If all went well, we registered exactly 2 key changes: one\n\t\t// that establishes the session, and one that we requested\n\t\t// additionally.\n\t\tt.Fatalf(\"got another host key checks after 2 handshakes\")\n\t}\n}\n\nfunc TestForceFirstKex(t *testing.T) {\n\t// like handshakePair, but must access the keyingTransport.\n\tchecker := &testChecker{}\n\tclientConf := &ClientConfig{HostKeyCallback: checker.Check}\n\ta, b, err := netPipe()\n\tif err != nil {\n\t\tt.Fatalf(\"netPipe: %v\", err)\n\t}\n\n\tvar trC, trS keyingTransport\n\n\ttrC = newTransport(a, rand.Reader, true)\n\n\t// This is the disallowed packet:\n\ttrC.writePacket(Marshal(&serviceRequestMsg{serviceUserAuth}))\n\n\t// Rest of the setup.\n\ttrS = newTransport(b, rand.Reader, false)\n\tclientConf.SetDefaults()\n\n\tv := []byte(\"version\")\n\tclient := newClientTransport(trC, v, v, clientConf, \"addr\", a.RemoteAddr())\n\n\tserverConf := &ServerConfig{}\n\tserverConf.AddHostKey(testSigners[\"ecdsa\"])\n\tserverConf.AddHostKey(testSigners[\"rsa\"])\n\tserverConf.SetDefaults()\n\tserver := newServerTransport(trS, v, v, serverConf)\n\n\tdefer client.Close()\n\tdefer server.Close()\n\n\t// We setup the initial key exchange, but the remote side\n\t// tries to send serviceRequestMsg in cleartext, which is\n\t// disallowed.\n\n\tif err := server.waitSession(); err == nil {\n\t\tt.Errorf(\"server first kex init should reject unexpected packet\")\n\t}\n}\n\nfunc TestHandshakeAutoRekeyWrite(t *testing.T) {\n\tchecker := &syncChecker{\n\t\tcalled:   make(chan int, 10),\n\t\twaitCall: nil,\n\t}\n\tclientConf := &ClientConfig{HostKeyCallback: checker.Check}\n\tclientConf.RekeyThreshold = 500\n\ttrC, trS, err := handshakePair(clientConf, \"addr\", false)\n\tif err != nil {\n\t\tt.Fatalf(\"handshakePair: %v\", err)\n\t}\n\tdefer trC.Close()\n\tdefer trS.Close()\n\n\tinput := make([]byte, 251)\n\tinput[0] = msgRequestSuccess\n\n\tdone := make(chan int, 1)\n\tconst numPacket = 5\n\tgo func() {\n\t\tdefer close(done)\n\t\tj := 0\n\t\tfor ; j < numPacket; j++ {\n\t\t\tif p, err := trS.readPacket(); err != nil {\n\t\t\t\tbreak\n\t\t\t} else if !bytes.Equal(input, p) {\n\t\t\t\tt.Errorf(\"got packet type %d, want %d\", p[0], input[0])\n\t\t\t}\n\t\t}\n\n\t\tif j != numPacket {\n\t\t\tt.Errorf(\"got %d, want 5 messages\", j)\n\t\t}\n\t}()\n\n\t<-checker.called\n\n\tfor i := 0; i < numPacket; i++ {\n\t\tp := make([]byte, len(input))\n\t\tcopy(p, input)\n\t\tif err := trC.writePacket(p); err != nil {\n\t\t\tt.Errorf(\"writePacket: %v\", err)\n\t\t}\n\t\tif i == 2 {\n\t\t\t// Make sure the kex is in progress.\n\t\t\t<-checker.called\n\t\t}\n\n\t}\n\t<-done\n}\n\ntype syncChecker struct {\n\twaitCall chan int\n\tcalled   chan int\n}\n\nfunc (c *syncChecker) Check(dialAddr string, addr net.Addr, key PublicKey) error {\n\tc.called <- 1\n\tif c.waitCall != nil {\n\t\t<-c.waitCall\n\t}\n\treturn nil\n}\n\nfunc TestHandshakeAutoRekeyRead(t *testing.T) {\n\tsync := &syncChecker{\n\t\tcalled:   make(chan int, 2),\n\t\twaitCall: nil,\n\t}\n\tclientConf := &ClientConfig{\n\t\tHostKeyCallback: sync.Check,\n\t}\n\tclientConf.RekeyThreshold = 500\n\n\ttrC, trS, err := handshakePair(clientConf, \"addr\", false)\n\tif err != nil {\n\t\tt.Fatalf(\"handshakePair: %v\", err)\n\t}\n\tdefer trC.Close()\n\tdefer trS.Close()\n\n\tpacket := make([]byte, 501)\n\tpacket[0] = msgRequestSuccess\n\tif err := trS.writePacket(packet); err != nil {\n\t\tt.Fatalf(\"writePacket: %v\", err)\n\t}\n\n\t// While we read out the packet, a key change will be\n\t// initiated.\n\tdone := make(chan int, 1)\n\tgo func() {\n\t\tdefer close(done)\n\t\tif _, err := trC.readPacket(); err != nil {\n\t\t\tt.Fatalf(\"readPacket(client): %v\", err)\n\t\t}\n\n\t}()\n\n\t<-done\n\t<-sync.called\n}\n\n// errorKeyingTransport generates errors after a given number of\n// read/write operations.\ntype errorKeyingTransport struct {\n\tpacketConn\n\treadLeft, writeLeft int\n}\n\nfunc (n *errorKeyingTransport) prepareKeyChange(*algorithms, *kexResult) error {\n\treturn nil\n}\n\nfunc (n *errorKeyingTransport) getSessionID() []byte {\n\treturn nil\n}\n\nfunc (n *errorKeyingTransport) writePacket(packet []byte) error {\n\tif n.writeLeft == 0 {\n\t\tn.Close()\n\t\treturn errors.New(\"barf\")\n\t}\n\n\tn.writeLeft--\n\treturn n.packetConn.writePacket(packet)\n}\n\nfunc (n *errorKeyingTransport) readPacket() ([]byte, error) {\n\tif n.readLeft == 0 {\n\t\tn.Close()\n\t\treturn nil, errors.New(\"barf\")\n\t}\n\n\tn.readLeft--\n\treturn n.packetConn.readPacket()\n}\n\nfunc TestHandshakeErrorHandlingRead(t *testing.T) {\n\tfor i := 0; i < 20; i++ {\n\t\ttestHandshakeErrorHandlingN(t, i, -1, false)\n\t}\n}\n\nfunc TestHandshakeErrorHandlingWrite(t *testing.T) {\n\tfor i := 0; i < 20; i++ {\n\t\ttestHandshakeErrorHandlingN(t, -1, i, false)\n\t}\n}\n\nfunc TestHandshakeErrorHandlingReadCoupled(t *testing.T) {\n\tfor i := 0; i < 20; i++ {\n\t\ttestHandshakeErrorHandlingN(t, i, -1, true)\n\t}\n}\n\nfunc TestHandshakeErrorHandlingWriteCoupled(t *testing.T) {\n\tfor i := 0; i < 20; i++ {\n\t\ttestHandshakeErrorHandlingN(t, -1, i, true)\n\t}\n}\n\n// testHandshakeErrorHandlingN runs handshakes, injecting errors. If\n// handshakeTransport deadlocks, the go runtime will detect it and\n// panic.\nfunc testHandshakeErrorHandlingN(t *testing.T, readLimit, writeLimit int, coupled bool) {\n\tmsg := Marshal(&serviceRequestMsg{strings.Repeat(\"x\", int(minRekeyThreshold)/4)})\n\n\ta, b := memPipe()\n\tdefer a.Close()\n\tdefer b.Close()\n\n\tkey := testSigners[\"ecdsa\"]\n\tserverConf := Config{RekeyThreshold: minRekeyThreshold}\n\tserverConf.SetDefaults()\n\tserverConn := newHandshakeTransport(&errorKeyingTransport{a, readLimit, writeLimit}, &serverConf, []byte{'a'}, []byte{'b'})\n\tserverConn.hostKeys = []Signer{key}\n\tgo serverConn.readLoop()\n\tgo serverConn.kexLoop()\n\n\tclientConf := Config{RekeyThreshold: 10 * minRekeyThreshold}\n\tclientConf.SetDefaults()\n\tclientConn := newHandshakeTransport(&errorKeyingTransport{b, -1, -1}, &clientConf, []byte{'a'}, []byte{'b'})\n\tclientConn.hostKeyAlgorithms = []string{key.PublicKey().Type()}\n\tclientConn.hostKeyCallback = InsecureIgnoreHostKey()\n\tgo clientConn.readLoop()\n\tgo clientConn.kexLoop()\n\n\tvar wg sync.WaitGroup\n\n\tfor _, hs := range []packetConn{serverConn, clientConn} {\n\t\tif !coupled {\n\t\t\twg.Add(2)\n\t\t\tgo func(c packetConn) {\n\t\t\t\tfor i := 0; ; i++ {\n\t\t\t\t\tstr := fmt.Sprintf(\"%08x\", i) + strings.Repeat(\"x\", int(minRekeyThreshold)/4-8)\n\t\t\t\t\terr := c.writePacket(Marshal(&serviceRequestMsg{str}))\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\twg.Done()\n\t\t\t\tc.Close()\n\t\t\t}(hs)\n\t\t\tgo func(c packetConn) {\n\t\t\t\tfor {\n\t\t\t\t\t_, err := c.readPacket()\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\twg.Done()\n\t\t\t}(hs)\n\t\t} else {\n\t\t\twg.Add(1)\n\t\t\tgo func(c packetConn) {\n\t\t\t\tfor {\n\t\t\t\t\t_, err := c.readPacket()\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t\tif err := c.writePacket(msg); err != nil {\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\twg.Done()\n\t\t\t}(hs)\n\t\t}\n\t}\n\twg.Wait()\n}\n\nfunc TestDisconnect(t *testing.T) {\n\tif runtime.GOOS == \"plan9\" {\n\t\tt.Skip(\"see golang.org/issue/7237\")\n\t}\n\tchecker := &testChecker{}\n\ttrC, trS, err := handshakePair(&ClientConfig{HostKeyCallback: checker.Check}, \"addr\", false)\n\tif err != nil {\n\t\tt.Fatalf(\"handshakePair: %v\", err)\n\t}\n\n\tdefer trC.Close()\n\tdefer trS.Close()\n\n\ttrC.writePacket([]byte{msgRequestSuccess, 0, 0})\n\terrMsg := &disconnectMsg{\n\t\tReason:  42,\n\t\tMessage: \"such is life\",\n\t}\n\ttrC.writePacket(Marshal(errMsg))\n\ttrC.writePacket([]byte{msgRequestSuccess, 0, 0})\n\n\tpacket, err := trS.readPacket()\n\tif err != nil {\n\t\tt.Fatalf(\"readPacket 1: %v\", err)\n\t}\n\tif packet[0] != msgRequestSuccess {\n\t\tt.Errorf(\"got packet %v, want packet type %d\", packet, msgRequestSuccess)\n\t}\n\n\t_, err = trS.readPacket()\n\tif err == nil {\n\t\tt.Errorf(\"readPacket 2 succeeded\")\n\t} else if !reflect.DeepEqual(err, errMsg) {\n\t\tt.Errorf(\"got error %#v, want %#v\", err, errMsg)\n\t}\n\n\t_, err = trS.readPacket()\n\tif err == nil {\n\t\tt.Errorf(\"readPacket 3 succeeded\")\n\t}\n}\n", "// Copyright 2011 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage ssh\n\n// Session tests.\n\nimport (\n\t\"bytes\"\n\tcrypto_rand \"crypto/rand\"\n\t\"errors\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"math/rand\"\n\t\"net\"\n\t\"testing\"\n\n\t\"golang.org/x/crypto/ssh/terminal\"\n)\n\ntype serverType func(Channel, <-chan *Request, *testing.T)\n\n// dial constructs a new test server and returns a *ClientConn.\nfunc dial(handler serverType, t *testing.T) *Client {\n\tc1, c2, err := netPipe()\n\tif err != nil {\n\t\tt.Fatalf(\"netPipe: %v\", err)\n\t}\n\n\tgo func() {\n\t\tdefer c1.Close()\n\t\tconf := ServerConfig{\n\t\t\tNoClientAuth: true,\n\t\t}\n\t\tconf.AddHostKey(testSigners[\"rsa\"])\n\n\t\t_, chans, reqs, err := NewServerConn(c1, &conf)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Unable to handshake: %v\", err)\n\t\t}\n\t\tgo DiscardRequests(reqs)\n\n\t\tfor newCh := range chans {\n\t\t\tif newCh.ChannelType() != \"session\" {\n\t\t\t\tnewCh.Reject(UnknownChannelType, \"unknown channel type\")\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tch, inReqs, err := newCh.Accept()\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Accept: %v\", err)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tgo func() {\n\t\t\t\thandler(ch, inReqs, t)\n\t\t\t}()\n\t\t}\n\t}()\n\n\tconfig := &ClientConfig{\n\t\tUser:            \"testuser\",\n\t\tHostKeyCallback: InsecureIgnoreHostKey(),\n\t}\n\n\tconn, chans, reqs, err := NewClientConn(c2, \"\", config)\n\tif err != nil {\n\t\tt.Fatalf(\"unable to dial remote side: %v\", err)\n\t}\n\n\treturn NewClient(conn, chans, reqs)\n}\n\n// Test a simple string is returned to session.Stdout.\nfunc TestSessionShell(t *testing.T) {\n\tconn := dial(shellHandler, t)\n\tdefer conn.Close()\n\tsession, err := conn.NewSession()\n\tif err != nil {\n\t\tt.Fatalf(\"Unable to request new session: %v\", err)\n\t}\n\tdefer session.Close()\n\tstdout := new(bytes.Buffer)\n\tsession.Stdout = stdout\n\tif err := session.Shell(); err != nil {\n\t\tt.Fatalf(\"Unable to execute command: %s\", err)\n\t}\n\tif err := session.Wait(); err != nil {\n\t\tt.Fatalf(\"Remote command did not exit cleanly: %v\", err)\n\t}\n\tactual := stdout.String()\n\tif actual != \"golang\" {\n\t\tt.Fatalf(\"Remote shell did not return expected string: expected=golang, actual=%s\", actual)\n\t}\n}\n\n// TODO(dfc) add support for Std{in,err}Pipe when the Server supports it.\n\n// Test a simple string is returned via StdoutPipe.\nfunc TestSessionStdoutPipe(t *testing.T) {\n\tconn := dial(shellHandler, t)\n\tdefer conn.Close()\n\tsession, err := conn.NewSession()\n\tif err != nil {\n\t\tt.Fatalf(\"Unable to request new session: %v\", err)\n\t}\n\tdefer session.Close()\n\tstdout, err := session.StdoutPipe()\n\tif err != nil {\n\t\tt.Fatalf(\"Unable to request StdoutPipe(): %v\", err)\n\t}\n\tvar buf bytes.Buffer\n\tif err := session.Shell(); err != nil {\n\t\tt.Fatalf(\"Unable to execute command: %v\", err)\n\t}\n\tdone := make(chan bool, 1)\n\tgo func() {\n\t\tif _, err := io.Copy(&buf, stdout); err != nil {\n\t\t\tt.Errorf(\"Copy of stdout failed: %v\", err)\n\t\t}\n\t\tdone <- true\n\t}()\n\tif err := session.Wait(); err != nil {\n\t\tt.Fatalf(\"Remote command did not exit cleanly: %v\", err)\n\t}\n\t<-done\n\tactual := buf.String()\n\tif actual != \"golang\" {\n\t\tt.Fatalf(\"Remote shell did not return expected string: expected=golang, actual=%s\", actual)\n\t}\n}\n\n// Test that a simple string is returned via the Output helper,\n// and that stderr is discarded.\nfunc TestSessionOutput(t *testing.T) {\n\tconn := dial(fixedOutputHandler, t)\n\tdefer conn.Close()\n\tsession, err := conn.NewSession()\n\tif err != nil {\n\t\tt.Fatalf(\"Unable to request new session: %v\", err)\n\t}\n\tdefer session.Close()\n\n\tbuf, err := session.Output(\"\") // cmd is ignored by fixedOutputHandler\n\tif err != nil {\n\t\tt.Error(\"Remote command did not exit cleanly:\", err)\n\t}\n\tw := \"this-is-stdout.\"\n\tg := string(buf)\n\tif g != w {\n\t\tt.Error(\"Remote command did not return expected string:\")\n\t\tt.Logf(\"want %q\", w)\n\t\tt.Logf(\"got  %q\", g)\n\t}\n}\n\n// Test that both stdout and stderr are returned\n// via the CombinedOutput helper.\nfunc TestSessionCombinedOutput(t *testing.T) {\n\tconn := dial(fixedOutputHandler, t)\n\tdefer conn.Close()\n\tsession, err := conn.NewSession()\n\tif err != nil {\n\t\tt.Fatalf(\"Unable to request new session: %v\", err)\n\t}\n\tdefer session.Close()\n\n\tbuf, err := session.CombinedOutput(\"\") // cmd is ignored by fixedOutputHandler\n\tif err != nil {\n\t\tt.Error(\"Remote command did not exit cleanly:\", err)\n\t}\n\tconst stdout = \"this-is-stdout.\"\n\tconst stderr = \"this-is-stderr.\"\n\tg := string(buf)\n\tif g != stdout+stderr && g != stderr+stdout {\n\t\tt.Error(\"Remote command did not return expected string:\")\n\t\tt.Logf(\"want %q, or %q\", stdout+stderr, stderr+stdout)\n\t\tt.Logf(\"got  %q\", g)\n\t}\n}\n\n// Test non-0 exit status is returned correctly.\nfunc TestExitStatusNonZero(t *testing.T) {\n\tconn := dial(exitStatusNonZeroHandler, t)\n\tdefer conn.Close()\n\tsession, err := conn.NewSession()\n\tif err != nil {\n\t\tt.Fatalf(\"Unable to request new session: %v\", err)\n\t}\n\tdefer session.Close()\n\tif err := session.Shell(); err != nil {\n\t\tt.Fatalf(\"Unable to execute command: %v\", err)\n\t}\n\terr = session.Wait()\n\tif err == nil {\n\t\tt.Fatalf(\"expected command to fail but it didn't\")\n\t}\n\te, ok := err.(*ExitError)\n\tif !ok {\n\t\tt.Fatalf(\"expected *ExitError but got %T\", err)\n\t}\n\tif e.ExitStatus() != 15 {\n\t\tt.Fatalf(\"expected command to exit with 15 but got %v\", e.ExitStatus())\n\t}\n}\n\n// Test 0 exit status is returned correctly.\nfunc TestExitStatusZero(t *testing.T) {\n\tconn := dial(exitStatusZeroHandler, t)\n\tdefer conn.Close()\n\tsession, err := conn.NewSession()\n\tif err != nil {\n\t\tt.Fatalf(\"Unable to request new session: %v\", err)\n\t}\n\tdefer session.Close()\n\n\tif err := session.Shell(); err != nil {\n\t\tt.Fatalf(\"Unable to execute command: %v\", err)\n\t}\n\terr = session.Wait()\n\tif err != nil {\n\t\tt.Fatalf(\"expected nil but got %v\", err)\n\t}\n}\n\n// Test exit signal and status are both returned correctly.\nfunc TestExitSignalAndStatus(t *testing.T) {\n\tconn := dial(exitSignalAndStatusHandler, t)\n\tdefer conn.Close()\n\tsession, err := conn.NewSession()\n\tif err != nil {\n\t\tt.Fatalf(\"Unable to request new session: %v\", err)\n\t}\n\tdefer session.Close()\n\tif err := session.Shell(); err != nil {\n\t\tt.Fatalf(\"Unable to execute command: %v\", err)\n\t}\n\terr = session.Wait()\n\tif err == nil {\n\t\tt.Fatalf(\"expected command to fail but it didn't\")\n\t}\n\te, ok := err.(*ExitError)\n\tif !ok {\n\t\tt.Fatalf(\"expected *ExitError but got %T\", err)\n\t}\n\tif e.Signal() != \"TERM\" || e.ExitStatus() != 15 {\n\t\tt.Fatalf(\"expected command to exit with signal TERM and status 15 but got signal %s and status %v\", e.Signal(), e.ExitStatus())\n\t}\n}\n\n// Test exit signal and status are both returned correctly.\nfunc TestKnownExitSignalOnly(t *testing.T) {\n\tconn := dial(exitSignalHandler, t)\n\tdefer conn.Close()\n\tsession, err := conn.NewSession()\n\tif err != nil {\n\t\tt.Fatalf(\"Unable to request new session: %v\", err)\n\t}\n\tdefer session.Close()\n\tif err := session.Shell(); err != nil {\n\t\tt.Fatalf(\"Unable to execute command: %v\", err)\n\t}\n\terr = session.Wait()\n\tif err == nil {\n\t\tt.Fatalf(\"expected command to fail but it didn't\")\n\t}\n\te, ok := err.(*ExitError)\n\tif !ok {\n\t\tt.Fatalf(\"expected *ExitError but got %T\", err)\n\t}\n\tif e.Signal() != \"TERM\" || e.ExitStatus() != 143 {\n\t\tt.Fatalf(\"expected command to exit with signal TERM and status 143 but got signal %s and status %v\", e.Signal(), e.ExitStatus())\n\t}\n}\n\n// Test exit signal and status are both returned correctly.\nfunc TestUnknownExitSignal(t *testing.T) {\n\tconn := dial(exitSignalUnknownHandler, t)\n\tdefer conn.Close()\n\tsession, err := conn.NewSession()\n\tif err != nil {\n\t\tt.Fatalf(\"Unable to request new session: %v\", err)\n\t}\n\tdefer session.Close()\n\tif err := session.Shell(); err != nil {\n\t\tt.Fatalf(\"Unable to execute command: %v\", err)\n\t}\n\terr = session.Wait()\n\tif err == nil {\n\t\tt.Fatalf(\"expected command to fail but it didn't\")\n\t}\n\te, ok := err.(*ExitError)\n\tif !ok {\n\t\tt.Fatalf(\"expected *ExitError but got %T\", err)\n\t}\n\tif e.Signal() != \"SYS\" || e.ExitStatus() != 128 {\n\t\tt.Fatalf(\"expected command to exit with signal SYS and status 128 but got signal %s and status %v\", e.Signal(), e.ExitStatus())\n\t}\n}\n\nfunc TestExitWithoutStatusOrSignal(t *testing.T) {\n\tconn := dial(exitWithoutSignalOrStatus, t)\n\tdefer conn.Close()\n\tsession, err := conn.NewSession()\n\tif err != nil {\n\t\tt.Fatalf(\"Unable to request new session: %v\", err)\n\t}\n\tdefer session.Close()\n\tif err := session.Shell(); err != nil {\n\t\tt.Fatalf(\"Unable to execute command: %v\", err)\n\t}\n\terr = session.Wait()\n\tif err == nil {\n\t\tt.Fatalf(\"expected command to fail but it didn't\")\n\t}\n\tif _, ok := err.(*ExitMissingError); !ok {\n\t\tt.Fatalf(\"got %T want *ExitMissingError\", err)\n\t}\n}\n\n// windowTestBytes is the number of bytes that we'll send to the SSH server.\nconst windowTestBytes = 16000 * 200\n\n// TestServerWindow writes random data to the server. The server is expected to echo\n// the same data back, which is compared against the original.\nfunc TestServerWindow(t *testing.T) {\n\torigBuf := bytes.NewBuffer(make([]byte, 0, windowTestBytes))\n\tio.CopyN(origBuf, crypto_rand.Reader, windowTestBytes)\n\torigBytes := origBuf.Bytes()\n\n\tconn := dial(echoHandler, t)\n\tdefer conn.Close()\n\tsession, err := conn.NewSession()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer session.Close()\n\tresult := make(chan []byte)\n\n\tgo func() {\n\t\tdefer close(result)\n\t\techoedBuf := bytes.NewBuffer(make([]byte, 0, windowTestBytes))\n\t\tserverStdout, err := session.StdoutPipe()\n\t\tif err != nil {\n\t\t\tt.Errorf(\"StdoutPipe failed: %v\", err)\n\t\t\treturn\n\t\t}\n\t\tn, err := copyNRandomly(\"stdout\", echoedBuf, serverStdout, windowTestBytes)\n\t\tif err != nil && err != io.EOF {\n\t\t\tt.Errorf(\"Read only %d bytes from server, expected %d: %v\", n, windowTestBytes, err)\n\t\t}\n\t\tresult <- echoedBuf.Bytes()\n\t}()\n\n\tserverStdin, err := session.StdinPipe()\n\tif err != nil {\n\t\tt.Fatalf(\"StdinPipe failed: %v\", err)\n\t}\n\twritten, err := copyNRandomly(\"stdin\", serverStdin, origBuf, windowTestBytes)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to copy origBuf to serverStdin: %v\", err)\n\t}\n\tif written != windowTestBytes {\n\t\tt.Fatalf(\"Wrote only %d of %d bytes to server\", written, windowTestBytes)\n\t}\n\n\techoedBytes := <-result\n\n\tif !bytes.Equal(origBytes, echoedBytes) {\n\t\tt.Fatalf(\"Echoed buffer differed from original, orig %d, echoed %d\", len(origBytes), len(echoedBytes))\n\t}\n}\n\n// Verify the client can handle a keepalive packet from the server.\nfunc TestClientHandlesKeepalives(t *testing.T) {\n\tconn := dial(channelKeepaliveSender, t)\n\tdefer conn.Close()\n\tsession, err := conn.NewSession()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer session.Close()\n\tif err := session.Shell(); err != nil {\n\t\tt.Fatalf(\"Unable to execute command: %v\", err)\n\t}\n\terr = session.Wait()\n\tif err != nil {\n\t\tt.Fatalf(\"expected nil but got: %v\", err)\n\t}\n}\n\ntype exitStatusMsg struct {\n\tStatus uint32\n}\n\ntype exitSignalMsg struct {\n\tSignal     string\n\tCoreDumped bool\n\tErrmsg     string\n\tLang       string\n}\n\nfunc handleTerminalRequests(in <-chan *Request) {\n\tfor req := range in {\n\t\tok := false\n\t\tswitch req.Type {\n\t\tcase \"shell\":\n\t\t\tok = true\n\t\t\tif len(req.Payload) > 0 {\n\t\t\t\t// We don't accept any commands, only the default shell.\n\t\t\t\tok = false\n\t\t\t}\n\t\tcase \"env\":\n\t\t\tok = true\n\t\t}\n\t\treq.Reply(ok, nil)\n\t}\n}\n\nfunc newServerShell(ch Channel, in <-chan *Request, prompt string) *terminal.Terminal {\n\tterm := terminal.NewTerminal(ch, prompt)\n\tgo handleTerminalRequests(in)\n\treturn term\n}\n\nfunc exitStatusZeroHandler(ch Channel, in <-chan *Request, t *testing.T) {\n\tdefer ch.Close()\n\t// this string is returned to stdout\n\tshell := newServerShell(ch, in, \"> \")\n\treadLine(shell, t)\n\tsendStatus(0, ch, t)\n}\n\nfunc exitStatusNonZeroHandler(ch Channel, in <-chan *Request, t *testing.T) {\n\tdefer ch.Close()\n\tshell := newServerShell(ch, in, \"> \")\n\treadLine(shell, t)\n\tsendStatus(15, ch, t)\n}\n\nfunc exitSignalAndStatusHandler(ch Channel, in <-chan *Request, t *testing.T) {\n\tdefer ch.Close()\n\tshell := newServerShell(ch, in, \"> \")\n\treadLine(shell, t)\n\tsendStatus(15, ch, t)\n\tsendSignal(\"TERM\", ch, t)\n}\n\nfunc exitSignalHandler(ch Channel, in <-chan *Request, t *testing.T) {\n\tdefer ch.Close()\n\tshell := newServerShell(ch, in, \"> \")\n\treadLine(shell, t)\n\tsendSignal(\"TERM\", ch, t)\n}\n\nfunc exitSignalUnknownHandler(ch Channel, in <-chan *Request, t *testing.T) {\n\tdefer ch.Close()\n\tshell := newServerShell(ch, in, \"> \")\n\treadLine(shell, t)\n\tsendSignal(\"SYS\", ch, t)\n}\n\nfunc exitWithoutSignalOrStatus(ch Channel, in <-chan *Request, t *testing.T) {\n\tdefer ch.Close()\n\tshell := newServerShell(ch, in, \"> \")\n\treadLine(shell, t)\n}\n\nfunc shellHandler(ch Channel, in <-chan *Request, t *testing.T) {\n\tdefer ch.Close()\n\t// this string is returned to stdout\n\tshell := newServerShell(ch, in, \"golang\")\n\treadLine(shell, t)\n\tsendStatus(0, ch, t)\n}\n\n// Ignores the command, writes fixed strings to stderr and stdout.\n// Strings are \"this-is-stdout.\" and \"this-is-stderr.\".\nfunc fixedOutputHandler(ch Channel, in <-chan *Request, t *testing.T) {\n\tdefer ch.Close()\n\t_, err := ch.Read(nil)\n\n\treq, ok := <-in\n\tif !ok {\n\t\tt.Fatalf(\"error: expected channel request, got: %#v\", err)\n\t\treturn\n\t}\n\n\t// ignore request, always send some text\n\treq.Reply(true, nil)\n\n\t_, err = io.WriteString(ch, \"this-is-stdout.\")\n\tif err != nil {\n\t\tt.Fatalf(\"error writing on server: %v\", err)\n\t}\n\t_, err = io.WriteString(ch.Stderr(), \"this-is-stderr.\")\n\tif err != nil {\n\t\tt.Fatalf(\"error writing on server: %v\", err)\n\t}\n\tsendStatus(0, ch, t)\n}\n\nfunc readLine(shell *terminal.Terminal, t *testing.T) {\n\tif _, err := shell.ReadLine(); err != nil && err != io.EOF {\n\t\tt.Errorf(\"unable to read line: %v\", err)\n\t}\n}\n\nfunc sendStatus(status uint32, ch Channel, t *testing.T) {\n\tmsg := exitStatusMsg{\n\t\tStatus: status,\n\t}\n\tif _, err := ch.SendRequest(\"exit-status\", false, Marshal(&msg)); err != nil {\n\t\tt.Errorf(\"unable to send status: %v\", err)\n\t}\n}\n\nfunc sendSignal(signal string, ch Channel, t *testing.T) {\n\tsig := exitSignalMsg{\n\t\tSignal:     signal,\n\t\tCoreDumped: false,\n\t\tErrmsg:     \"Process terminated\",\n\t\tLang:       \"en-GB-oed\",\n\t}\n\tif _, err := ch.SendRequest(\"exit-signal\", false, Marshal(&sig)); err != nil {\n\t\tt.Errorf(\"unable to send signal: %v\", err)\n\t}\n}\n\nfunc discardHandler(ch Channel, t *testing.T) {\n\tdefer ch.Close()\n\tio.Copy(ioutil.Discard, ch)\n}\n\nfunc echoHandler(ch Channel, in <-chan *Request, t *testing.T) {\n\tdefer ch.Close()\n\tif n, err := copyNRandomly(\"echohandler\", ch, ch, windowTestBytes); err != nil {\n\t\tt.Errorf(\"short write, wrote %d, expected %d: %v \", n, windowTestBytes, err)\n\t}\n}\n\n// copyNRandomly copies n bytes from src to dst. It uses a variable, and random,\n// buffer size to exercise more code paths.\nfunc copyNRandomly(title string, dst io.Writer, src io.Reader, n int) (int, error) {\n\tvar (\n\t\tbuf       = make([]byte, 32*1024)\n\t\twritten   int\n\t\tremaining = n\n\t)\n\tfor remaining > 0 {\n\t\tl := rand.Intn(1 << 15)\n\t\tif remaining < l {\n\t\t\tl = remaining\n\t\t}\n\t\tnr, er := src.Read(buf[:l])\n\t\tnw, ew := dst.Write(buf[:nr])\n\t\tremaining -= nw\n\t\twritten += nw\n\t\tif ew != nil {\n\t\t\treturn written, ew\n\t\t}\n\t\tif nr != nw {\n\t\t\treturn written, io.ErrShortWrite\n\t\t}\n\t\tif er != nil && er != io.EOF {\n\t\t\treturn written, er\n\t\t}\n\t}\n\treturn written, nil\n}\n\nfunc channelKeepaliveSender(ch Channel, in <-chan *Request, t *testing.T) {\n\tdefer ch.Close()\n\tshell := newServerShell(ch, in, \"> \")\n\treadLine(shell, t)\n\tif _, err := ch.SendRequest(\"keepalive@openssh.com\", true, nil); err != nil {\n\t\tt.Errorf(\"unable to send channel keepalive request: %v\", err)\n\t}\n\tsendStatus(0, ch, t)\n}\n\nfunc TestClientWriteEOF(t *testing.T) {\n\tconn := dial(simpleEchoHandler, t)\n\tdefer conn.Close()\n\n\tsession, err := conn.NewSession()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer session.Close()\n\tstdin, err := session.StdinPipe()\n\tif err != nil {\n\t\tt.Fatalf(\"StdinPipe failed: %v\", err)\n\t}\n\tstdout, err := session.StdoutPipe()\n\tif err != nil {\n\t\tt.Fatalf(\"StdoutPipe failed: %v\", err)\n\t}\n\n\tdata := []byte(`0000`)\n\t_, err = stdin.Write(data)\n\tif err != nil {\n\t\tt.Fatalf(\"Write failed: %v\", err)\n\t}\n\tstdin.Close()\n\n\tres, err := ioutil.ReadAll(stdout)\n\tif err != nil {\n\t\tt.Fatalf(\"Read failed: %v\", err)\n\t}\n\n\tif !bytes.Equal(data, res) {\n\t\tt.Fatalf(\"Read differed from write, wrote: %v, read: %v\", data, res)\n\t}\n}\n\nfunc simpleEchoHandler(ch Channel, in <-chan *Request, t *testing.T) {\n\tdefer ch.Close()\n\tdata, err := ioutil.ReadAll(ch)\n\tif err != nil {\n\t\tt.Errorf(\"handler read error: %v\", err)\n\t}\n\t_, err = ch.Write(data)\n\tif err != nil {\n\t\tt.Errorf(\"handler write error: %v\", err)\n\t}\n}\n\nfunc TestSessionID(t *testing.T) {\n\tc1, c2, err := netPipe()\n\tif err != nil {\n\t\tt.Fatalf(\"netPipe: %v\", err)\n\t}\n\tdefer c1.Close()\n\tdefer c2.Close()\n\n\tserverID := make(chan []byte, 1)\n\tclientID := make(chan []byte, 1)\n\n\tserverConf := &ServerConfig{\n\t\tNoClientAuth: true,\n\t}\n\tserverConf.AddHostKey(testSigners[\"ecdsa\"])\n\tclientConf := &ClientConfig{\n\t\tHostKeyCallback: InsecureIgnoreHostKey(),\n\t\tUser:            \"user\",\n\t}\n\n\tgo func() {\n\t\tconn, chans, reqs, err := NewServerConn(c1, serverConf)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"server handshake: %v\", err)\n\t\t}\n\t\tserverID <- conn.SessionID()\n\t\tgo DiscardRequests(reqs)\n\t\tfor ch := range chans {\n\t\t\tch.Reject(Prohibited, \"\")\n\t\t}\n\t}()\n\n\tgo func() {\n\t\tconn, chans, reqs, err := NewClientConn(c2, \"\", clientConf)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"client handshake: %v\", err)\n\t\t}\n\t\tclientID <- conn.SessionID()\n\t\tgo DiscardRequests(reqs)\n\t\tfor ch := range chans {\n\t\t\tch.Reject(Prohibited, \"\")\n\t\t}\n\t}()\n\n\ts := <-serverID\n\tc := <-clientID\n\tif bytes.Compare(s, c) != 0 {\n\t\tt.Errorf(\"server session ID (%x) != client session ID (%x)\", s, c)\n\t} else if len(s) == 0 {\n\t\tt.Errorf(\"client and server SessionID were empty.\")\n\t}\n}\n\ntype noReadConn struct {\n\treadSeen bool\n\tnet.Conn\n}\n\nfunc (c *noReadConn) Close() error {\n\treturn nil\n}\n\nfunc (c *noReadConn) Read(b []byte) (int, error) {\n\tc.readSeen = true\n\treturn 0, errors.New(\"noReadConn error\")\n}\n\nfunc TestInvalidServerConfiguration(t *testing.T) {\n\tc1, c2, err := netPipe()\n\tif err != nil {\n\t\tt.Fatalf(\"netPipe: %v\", err)\n\t}\n\tdefer c1.Close()\n\tdefer c2.Close()\n\n\tserveConn := noReadConn{Conn: c1}\n\tserverConf := &ServerConfig{}\n\n\tNewServerConn(&serveConn, serverConf)\n\tif serveConn.readSeen {\n\t\tt.Fatalf(\"NewServerConn attempted to Read() from Conn while configuration is missing host key\")\n\t}\n\n\tserverConf.AddHostKey(testSigners[\"ecdsa\"])\n\n\tNewServerConn(&serveConn, serverConf)\n\tif serveConn.readSeen {\n\t\tt.Fatalf(\"NewServerConn attempted to Read() from Conn while configuration is missing authentication method\")\n\t}\n}\n\nfunc TestHostKeyAlgorithms(t *testing.T) {\n\tserverConf := &ServerConfig{\n\t\tNoClientAuth: true,\n\t}\n\tserverConf.AddHostKey(testSigners[\"rsa\"])\n\tserverConf.AddHostKey(testSigners[\"ecdsa\"])\n\n\tconnect := func(clientConf *ClientConfig, want string) {\n\t\tvar alg string\n\t\tclientConf.HostKeyCallback = func(h string, a net.Addr, key PublicKey) error {\n\t\t\talg = key.Type()\n\t\t\treturn nil\n\t\t}\n\t\tc1, c2, err := netPipe()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"netPipe: %v\", err)\n\t\t}\n\t\tdefer c1.Close()\n\t\tdefer c2.Close()\n\n\t\tgo NewServerConn(c1, serverConf)\n\t\t_, _, _, err = NewClientConn(c2, \"\", clientConf)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"NewClientConn: %v\", err)\n\t\t}\n\t\tif alg != want {\n\t\t\tt.Errorf(\"selected key algorithm %s, want %s\", alg, want)\n\t\t}\n\t}\n\n\t// By default, we get the preferred algorithm, which is ECDSA 256.\n\n\tclientConf := &ClientConfig{\n\t\tHostKeyCallback: InsecureIgnoreHostKey(),\n\t}\n\tconnect(clientConf, KeyAlgoECDSA256)\n\n\t// Client asks for RSA explicitly.\n\tclientConf.HostKeyAlgorithms = []string{KeyAlgoRSA}\n\tconnect(clientConf, KeyAlgoRSA)\n\n\tc1, c2, err := netPipe()\n\tif err != nil {\n\t\tt.Fatalf(\"netPipe: %v\", err)\n\t}\n\tdefer c1.Close()\n\tdefer c2.Close()\n\n\tgo NewServerConn(c1, serverConf)\n\tclientConf.HostKeyAlgorithms = []string{\"nonexistent-hostkey-algo\"}\n\t_, _, _, err = NewClientConn(c2, \"\", clientConf)\n\tif err == nil {\n\t\tt.Fatal(\"succeeded connecting with unknown hostkey algorithm\")\n\t}\n}\n", "// Copyright 2014 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n// +build darwin dragonfly freebsd linux netbsd openbsd\n\npackage test\n\nimport (\n\t\"crypto/rand\"\n\t\"testing\"\n\n\t\"golang.org/x/crypto/ssh\"\n)\n\nfunc TestCertLogin(t *testing.T) {\n\ts := newServer(t)\n\tdefer s.Shutdown()\n\n\t// Use a key different from the default.\n\tclientKey := testSigners[\"dsa\"]\n\tcaAuthKey := testSigners[\"ecdsa\"]\n\tcert := &ssh.Certificate{\n\t\tKey:             clientKey.PublicKey(),\n\t\tValidPrincipals: []string{username()},\n\t\tCertType:        ssh.UserCert,\n\t\tValidBefore:     ssh.CertTimeInfinity,\n\t}\n\tif err := cert.SignCert(rand.Reader, caAuthKey); err != nil {\n\t\tt.Fatalf(\"SetSignature: %v\", err)\n\t}\n\n\tcertSigner, err := ssh.NewCertSigner(cert, clientKey)\n\tif err != nil {\n\t\tt.Fatalf(\"NewCertSigner: %v\", err)\n\t}\n\n\tconf := &ssh.ClientConfig{\n\t\tUser:            username(),\n\t\tHostKeyCallback: ssh.InsecureIgnoreHostKey(),\n\t}\n\tconf.Auth = append(conf.Auth, ssh.PublicKeys(certSigner))\n\tclient, err := s.TryDial(conf)\n\tif err != nil {\n\t\tt.Fatalf(\"TryDial: %v\", err)\n\t}\n\tclient.Close()\n}\n"], "filenames": ["ssh/agent/client_test.go", "ssh/agent/example_test.go", "ssh/agent/server_test.go", "ssh/certs.go", "ssh/client.go", "ssh/client_auth_test.go", "ssh/client_test.go", "ssh/doc.go", "ssh/example_test.go", "ssh/handshake.go", "ssh/handshake_test.go", "ssh/session_test.go", "ssh/test/cert_test.go"], "buggy_code_start_loc": [236, 8, 59, 271, 7, 94, 8, 16, 7, 77, 438, 62, 39], "buggy_code_end_loc": [237, 31, 60, 272, 211, 454, 39, 16, 234, 622, 438, 751, 40], "fixing_code_start_loc": [236, 9, 59, 271, 8, 95, 9, 17, 8, 77, 439, 62, 39], "fixing_code_end_loc": [239, 33, 62, 272, 257, 467, 82, 20, 286, 620, 440, 755, 41], "type": "NVD-CWE-noinfo", "message": "The Go SSH library (x/crypto/ssh) by default does not verify host keys, facilitating man-in-the-middle attacks. Default behavior changed in commit e4e2799 to require explicitly registering a hostkey verification mechanism.", "other": {"cve": {"id": "CVE-2017-3204", "sourceIdentifier": "cret@cert.org", "published": "2017-04-04T14:59:00.180", "lastModified": "2020-07-07T18:21:43.420", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The Go SSH library (x/crypto/ssh) by default does not verify host keys, facilitating man-in-the-middle attacks. Default behavior changed in commit e4e2799 to require explicitly registering a hostkey verification mechanism."}, {"lang": "es", "value": "La librer\u00eda Go SSH (x/crypto/ssh) por defecto no verifica las claves del host, facilitando ataques man-in-the-middle. El comportamiento predeterminado cambi\u00f3 en commit e4e2799 para requerir el registro expl\u00edcito de un mecanismo de verificaci\u00f3n de hostkey."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.2, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}, {"source": "cret@cert.org", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-310"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:golang:crypto:*:*:*:*:*:*:*:*", "versionEndIncluding": "2017-03-17", "matchCriteriaId": "4C978A0F-3C80-4898-B1B3-DFF7F97D22DF"}]}]}], "references": [{"url": "http://www.securityfocus.com/bid/97481", "source": "cret@cert.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://bridge.grumpy-troll.org/2017/04/golang-ssh-security/", "source": "cret@cert.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/golang/crypto/commit/e4e2799dd7aab89f583e1d898300d96367750991", "source": "cret@cert.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/golang/go/issues/19767", "source": "cret@cert.org", "tags": ["Third Party Advisory"]}, {"url": "https://godoc.org/golang.org/x/crypto/ssh", "source": "cret@cert.org", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/golang/crypto/commit/e4e2799dd7aab89f583e1d898300d96367750991"}}