{"buggy_code": ["/*\n    Copyright (C) 2019-Present SKALE Labs\n\n    This file is part of sgxwallet.\n\n    sgxwallet is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    sgxwallet is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with sgxwallet.  If not, see <https://www.gnu.org/licenses/>.\n\n    @file BLSCrypto.cpp\n    @author Stan Kladko\n    @date 2019\n*/\n\n#include <memory>\n#include \"libff/algebra/curves/alt_bn128/alt_bn128_init.hpp\"\n#include \"leveldb/db.h\"\n#include <jsonrpccpp/server/connectors/httpserver.h>\n\n#include \"third_party/intel/create_enclave.h\"\n\n\n\n#include \"bls.h\"\n#include <bls/BLSutils.h>\n\n#include \"BLSPrivateKeyShareSGX.h\"\n\n\n\n#include \"sgxwallet_common.h\"\n#include \"sgxwallet.h\"\n#include \"SGXException.h\"\n#include \"third_party/spdlog/spdlog.h\"\n#include \"common.h\"\n#include \"SGXWalletServer.h\"\n\n#include \"BLSCrypto.h\"\n#include \"ServerInit.h\"\n\n\nstring *FqToString(libff::alt_bn128_Fq *_fq) {\n\n    CHECK_STATE(_fq);\n\n    mpz_t t;\n    mpz_init(t);\n\n    _fq->as_bigint().to_mpz(t);\n\n    SAFE_CHAR_BUF(arr,mpz_sizeinbase(t, 10) + 2);\n\n    mpz_get_str(arr, 10, t);\n    mpz_clear(t);\n\n    return new string(arr);\n}\n\nint char2int(char _input) {\n    if (_input >= '0' && _input <= '9')\n        return _input - '0';\n    if (_input >= 'A' && _input <= 'F')\n        return _input - 'A' + 10;\n    if (_input >= 'a' && _input <= 'f')\n        return _input - 'a' + 10;\n    return -1;\n}\n\nvoid carray2Hex(const unsigned char *d, uint64_t _len, char *_hexArray,\n                uint64_t _hexArrayLen) {\n\n    CHECK_STATE(d);\n    CHECK_STATE(_hexArray);\n\n    char hexval[16] = {'0', '1', '2', '3', '4', '5', '6', '7',\n                       '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};\n\n    CHECK_STATE(_hexArrayLen > 2 * _len);\n\n    for (int j = 0; j < _len; j++) {\n        _hexArray[j * 2] = hexval[((d[j] >> 4) & 0xF)];\n        _hexArray[j * 2 + 1] = hexval[(d[j]) & 0x0F];\n    }\n\n    _hexArray[_len * 2] = 0;\n}\n\n\n\nbool hex2carray(const char *_hex, uint64_t *_bin_len,\n                 uint8_t *_bin, uint64_t _max_length) {\n\n\n    CHECK_STATE(_hex);\n    CHECK_STATE(_bin);\n    CHECK_STATE(_bin_len)\n\n\n    int len = strnlen(_hex, 2 * _max_length + 1);\n\n    CHECK_STATE(len != 2 * _max_length + 1);\n\n    CHECK_STATE(len <= 2 * _max_length );\n\n\n    if (len == 0 && len % 2 == 1)\n        return false;\n\n    *_bin_len = len / 2;\n\n    for (int i = 0; i < len / 2; i++) {\n        int high = char2int((char) _hex[i * 2]);\n        int low = char2int((char) _hex[i * 2 + 1]);\n\n        if (high < 0 || low < 0) {\n            return false;\n        }\n\n        _bin[i] = (unsigned char) (high * 16 + low);\n    }\n\n    return true;\n}\n\nbool sign(const char *_encryptedKeyHex, const char *_hashHex, size_t _t, size_t _n, size_t _signerIndex,\n          char *_sig) {\n\n\n    CHECK_STATE(_encryptedKeyHex);\n    CHECK_STATE(_hashHex);\n    CHECK_STATE(_sig);\n\n    auto keyStr = make_shared<string>(_encryptedKeyHex);\n\n    auto hash = make_shared<array<uint8_t, 32>>();\n\n    uint64_t binLen;\n\n    if (!hex2carray(_hashHex, &binLen, hash->data(), hash->size())) {\n        throw SGXException(INVALID_HEX, \"Invalid hash\");\n    }\n\n    auto keyShare = make_shared<BLSPrivateKeyShareSGX>(keyStr, _t, _n);\n\n    auto sigShare = keyShare->signWithHelperSGX(hash, _signerIndex);\n\n    auto sigShareStr = sigShare->toString();\n\n    strncpy(_sig, sigShareStr->c_str(), BUF_LEN);\n\n    return true;\n}\n\nbool sign_aes(const char *_encryptedKeyHex, const char *_hashHex, size_t _t, size_t _n, char *_sig) {\n\n    CHECK_STATE(_encryptedKeyHex);\n    CHECK_STATE(_hashHex);\n    CHECK_STATE(_sig);\n\n    auto hash = make_shared<array<uint8_t, 32>>();\n\n    uint64_t binLen;\n\n    if (!hex2carray(_hashHex, &binLen, hash->data(), hash->size())) {\n        throw SGXException(INVALID_HEX, \"Invalid hash\");\n    }\n\n    shared_ptr<signatures::Bls> obj;\n    obj = make_shared<signatures::Bls>(signatures::Bls(_t, _n));\n\n    pair<libff::alt_bn128_G1, string> hash_with_hint = obj->HashtoG1withHint(hash);\n\n    string *xStr = FqToString(&(hash_with_hint.first.X));\n\n    CHECK_STATE(xStr);\n\n    string *yStr = FqToString(&(hash_with_hint.first.Y));\n\n    if (yStr == nullptr) {\n        delete xStr;\n        BOOST_THROW_EXCEPTION(runtime_error(\"Null yStr\"));\n    }\n\n    vector<char> errMsg(BUF_LEN,0);\n\n    SAFE_CHAR_BUF(xStrArg,BUF_LEN);\n    SAFE_CHAR_BUF(yStrArg,BUF_LEN);\n    SAFE_CHAR_BUF(signature,BUF_LEN);\n\n    strncpy(xStrArg, xStr->c_str(), BUF_LEN);\n    strncpy(yStrArg, yStr->c_str(), BUF_LEN);\n\n    delete xStr;\n    delete yStr;\n\n    size_t sz = 0;\n\n    SAFE_UINT8_BUF(encryptedKey,BUF_LEN);\n\n    bool result = hex2carray(_encryptedKeyHex, &sz, encryptedKey, BUF_LEN);\n\n    if (!result) {\n        BOOST_THROW_EXCEPTION(invalid_argument(\"Invalid hex encrypted key\"));\n    }\n\n    int errStatus = 0;\n    sgx_status_t status =\n            trustedBlsSignMessageAES(eid, &errStatus, errMsg.data(), encryptedKey,\n                                 sz, xStrArg, yStrArg, signature);\n    HANDLE_TRUSTED_FUNCTION_ERROR(status, errStatus, errMsg.data());\n\n    string hint = BLSutils::ConvertToString(hash_with_hint.first.Y) + \":\" + hash_with_hint.second;\n\n    string sig = signature;\n\n    sig.append(\":\");\n    sig.append(hint);\n\n    strncpy(_sig, sig.c_str(), BUF_LEN);\n\n    return true;\n}\n\nbool bls_sign(const char *_encryptedKeyHex, const char *_hashHex, size_t _t, size_t _n, char *_sig) {\n    CHECK_STATE(_encryptedKeyHex);\n    CHECK_STATE(_hashHex);\n    return sign_aes(_encryptedKeyHex, _hashHex, _t, _n, _sig);\n}\n\nstring encryptBLSKeyShare2Hex(int *errStatus, char *err_string, const char *_key) {\n    CHECK_STATE(errStatus);\n    CHECK_STATE(err_string);\n    CHECK_STATE(_key);\n    auto keyArray = make_shared<vector<char>>(BUF_LEN, 0);\n    auto encryptedKey = make_shared<vector<uint8_t>>(BUF_LEN, 0);\n\n    vector<char> errMsg(BUF_LEN, 0);\n\n    strncpy(keyArray->data(), _key, BUF_LEN);\n    *errStatus = 0;\n    unsigned int encryptedLen = 0;\n\n    sgx_status_t status = trustedEncryptKeyAES(eid, errStatus, errMsg.data(), keyArray->data(), encryptedKey->data(), &encryptedLen);\n\n    HANDLE_TRUSTED_FUNCTION_ERROR(status, *errStatus, errMsg.data());\n\n    SAFE_CHAR_BUF(resultBuf, 2 * BUF_LEN + 1);\n\n    carray2Hex(encryptedKey->data(), encryptedLen, resultBuf, 2 * BUF_LEN + 1);\n\n    return string(resultBuf);\n}\n", "/*\n    Copyright (C) 2019-Present SKALE Labs\n\n    This file is part of sgxwallet.\n\n    sgxwallet is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    sgxwallet is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with sgxwallet.  If not, see <https://www.gnu.org/licenses/>.\n\n    @file DKGCrypto.cpp\n    @author Stan Kladko\n    @date 2019\n*/\n\n\n#include <iostream>\n#include <memory>\n\n\n\n#include \"third_party/spdlog/spdlog.h\"\n#include \"sgxwallet.h\"\n#include \"SGXException.h\"\n#include \"common.h\"\n#include \"SGXWalletServer.hpp\"\n\n\n#include \"DKGCrypto.h\"\n#include \"BLSCrypto.h\"\n\n\n\n\n\n\n\nvector <string> splitString(const char *coeffs, const char symbol) {\n    CHECK_STATE(coeffs);\n    string str(coeffs);\n    string delim;\n    delim.push_back(symbol);\n    vector <string> G2_strings;\n    size_t prev = 0, pos = 0;\n    do {\n        pos = str.find(delim, prev);\n        if (pos == string::npos) pos = str.length();\n        string token = str.substr(prev, pos - prev);\n        if (!token.empty()) {\n            string coeff(token.c_str());\n            G2_strings.push_back(coeff);\n        }\n        prev = pos + delim.length();\n    } while (pos < str.length() && prev < str.length());\n\n    return G2_strings;\n}\n\ntemplate<class T>\nstring ConvertToString(T field_elem, int base = 10) {\n    mpz_t t;\n    mpz_init(t);\n\n    field_elem.as_bigint().to_mpz(t);\n\n    SAFE_CHAR_BUF(arr,mpz_sizeinbase(t, base) + 2);\n\n    mpz_get_str(arr, base, t);\n    mpz_clear(t);\n\n    string output = arr;\n\n    return output;\n}\n\nstring convertHexToDec(const string &hex_str) {\n    mpz_t dec;\n    mpz_init(dec);\n\n    string ret = \"\";\n\n    try {\n        if (mpz_set_str(dec, hex_str.c_str(), 16) == -1) {\n            mpz_clear(dec);\n            return ret;\n        }\n\n        SAFE_CHAR_BUF(arr,mpz_sizeinbase(dec, 10) + 2);\n        mpz_get_str(arr, 10, dec);\n        ret = arr;\n    } catch (exception &e) {\n        mpz_clear(dec);\n        throw SGXException(INCORRECT_STRING_CONVERSION, e.what());\n    } catch (...) {\n        mpz_clear(dec);\n        throw SGXException(UNKNOWN_ERROR, \"\");\n    }\n\n    return ret;\n}\n\nstring convertG2ToString(const libff::alt_bn128_G2 &elem, int base, const string &delim) {\n    string result = \"\";\n\n    try {\n        result += ConvertToString(elem.X.c0);\n        result += delim;\n        result += ConvertToString(elem.X.c1);\n        result += delim;\n        result += ConvertToString(elem.Y.c0);\n        result += delim;\n        result += ConvertToString(elem.Y.c1);\n\n        return result;\n\n    } catch (exception &e) {\n        throw SGXException(INCORRECT_STRING_CONVERSION, e.what());\n        return result;\n    } catch (...) {\n        throw SGXException(UNKNOWN_ERROR, \"\");\n        return result;\n    }\n\n    return result;\n}\n\nstring gen_dkg_poly(int _t) {\n    vector<char> errMsg(BUF_LEN, 0);\n    int errStatus = 0;\n    uint32_t enc_len = 0;\n\n    vector <uint8_t> encrypted_dkg_secret(BUF_LEN, 0);\n\n\n\n    sgx_status_t status = trustedGenDkgSecretAES(eid, &errStatus, errMsg.data(), encrypted_dkg_secret.data(), &enc_len, _t);\n    HANDLE_TRUSTED_FUNCTION_ERROR(status, errStatus, errMsg.data());\n\n    uint64_t length = enc_len;;\n\n    vector<char> hexEncrPoly(BUF_LEN, 0);\n    CHECK_STATE(encrypted_dkg_secret.size() >= length);\n    carray2Hex(encrypted_dkg_secret.data(), length, hexEncrPoly.data(), BUF_LEN);\n    string result(hexEncrPoly.data());\n\n    return result;\n}\n\nvector <vector<string>> get_verif_vect(const char *encryptedPolyHex, int t, int n) {\n\n    CHECK_STATE(encryptedPolyHex);\n\n    vector<char> errMsg(BUF_LEN, 0);\n\n    int errStatus = 0;\n\n    vector<char> pubShares(10000, 0);\n\n    uint64_t encLen = 0;\n\n    vector <uint8_t> encrDKGPoly(2 * BUF_LEN, 0);\n\n    if (!hex2carray(encryptedPolyHex, &encLen, encrDKGPoly.data(), 6100)) {\n        throw SGXException(INVALID_HEX, \"Invalid encryptedPolyHex\");\n    }\n\n\n\n    sgx_status_t status = trustedGetPublicSharesAES(eid, &errStatus, errMsg.data(), encrDKGPoly.data(), encLen,\n                                       pubShares.data(), t, n);\n    HANDLE_TRUSTED_FUNCTION_ERROR(status, errStatus, errMsg.data());\n\n    vector <string> g2Strings = splitString(pubShares.data(), ',');\n    vector <vector<string>> pubSharesVect;\n    for (uint64_t i = 0; i < g2Strings.size(); i++) {\n        vector <string> coeffStr = splitString(g2Strings.at(i).c_str(), ':');\n        pubSharesVect.push_back(coeffStr);\n    }\n\n    return pubSharesVect;\n}\n\nstring\ngetSecretShares(const string &_polyName, const char *_encryptedPolyHex, const vector <string> &_publicKeys,\n                       int _t,\n                       int _n) {\n\n    CHECK_STATE(_encryptedPolyHex);\n\n    vector<char> hexEncrKey(BUF_LEN, 0);\n    vector<char> errMsg1(BUF_LEN, 0);\n    vector <uint8_t> encrDKGPoly(BUF_LEN, 0);\n    int errStatus = 0;\n    uint64_t encLen = 0;\n\n\n\n    if (!hex2carray(_encryptedPolyHex, &encLen, encrDKGPoly.data(), BUF_LEN)) {\n        throw SGXException(INVALID_HEX, \"Invalid encryptedPolyHex\");\n    }\n\n    sgx_status_t status = trustedSetEncryptedDkgPolyAES(eid, &errStatus, errMsg1.data(), encrDKGPoly.data(), encLen);\n    HANDLE_TRUSTED_FUNCTION_ERROR(status, errStatus, errMsg1.data());\n\n    string result;\n\n    for (int i = 0; i < _n; i++) {\n        vector <uint8_t> encryptedSkey(BUF_LEN, 0);\n        uint32_t decLen;\n        vector<char> currentShare(193, 0);\n        vector<char> sShareG2(320, 0);\n\n        string pub_keyB = _publicKeys.at(i);\n        vector<char> pubKeyB(129, 0);\n\n        strncpy(pubKeyB.data(), pub_keyB.c_str(), 128);\n        pubKeyB.at(128) = 0;\n\n        spdlog::debug(\"pubKeyB is {}\", pub_keyB);\n\n        sgx_status_t status = trustedGetEncryptedSecretShareAES(eid, &errStatus, errMsg1.data(), encryptedSkey.data(), &decLen,\n                                          currentShare.data(), sShareG2.data(), pubKeyB.data(), _t, _n, i + 1);\n        HANDLE_TRUSTED_FUNCTION_ERROR(status, errStatus, errMsg1.data());\n\n        spdlog::debug(\"cur_share is {}\", currentShare.data());\n\n        result += string(currentShare.data());\n\n        spdlog::debug(\"dec len is {}\", decLen);\n        carray2Hex(encryptedSkey.data(), decLen, hexEncrKey.data(), BUF_LEN);\n        string dhKeyName = \"DKG_DH_KEY_\" + _polyName + \"_\" + to_string(i) + \":\";\n\n        spdlog::debug(\"hexEncr DH Key: { }\", hexEncrKey.data());\n        spdlog::debug(\"name to write to db is {}\", dhKeyName);\n        SGXWalletServer::writeDataToDB(dhKeyName, hexEncrKey.data());\n\n        string shareG2_name = \"shareG2_\" + _polyName + \"_\" + to_string(i) + \":\";\n        spdlog::debug(\"name to write to db is {}\", shareG2_name);\n        spdlog::debug(\"s_shareG2: {}\", sShareG2.data());\n\n        SGXWalletServer::writeDataToDB(shareG2_name, sShareG2.data());\n\n\n    }\n\n    return result;\n}\n\nbool\nverifyShares(const char *publicShares, const char *encr_sshare, const char *encryptedKeyHex, int t, int n, int ind) {\n\n    CHECK_STATE(publicShares);\n    CHECK_STATE(encr_sshare);\n    CHECK_STATE(encryptedKeyHex);\n\n    vector<char> errMsg(BUF_LEN, 0);\n    int errStatus = 0;\n    uint64_t decKeyLen = 0;\n    int result = 0;\n\n    SAFE_UINT8_BUF(encr_key, BUF_LEN);\n    if (!hex2carray(encryptedKeyHex, &decKeyLen, encr_key, BUF_LEN)) {\n        throw SGXException(INVALID_HEX, \"Invalid encryptedPolyHex\");\n    }\n\n    SAFE_CHAR_BUF(pshares,8193);\n    strncpy(pshares, publicShares, strlen(publicShares));\n\n    sgx_status_t status = trustedDkgVerifyAES(eid, &errStatus, errMsg.data(), pshares, encr_sshare, encr_key, decKeyLen, t,\n                                              ind, &result);\n    HANDLE_TRUSTED_FUNCTION_ERROR(status, errStatus, errMsg.data());\n\n    if (result == 2) {\n        throw SGXException(INVALID_HEX, \"Invalid public shares\");\n    }\n\n    return result;\n}\n\nbool createBLSShare(const string &blsKeyName, const char *s_shares, const char *encryptedKeyHex) {\n\n    CHECK_STATE(s_shares);\n    CHECK_STATE(encryptedKeyHex);\n\n    vector<char> errMsg(BUF_LEN,0);\n    int errStatus = 0;\n\n    uint64_t decKeyLen;\n    SAFE_UINT8_BUF(encr_bls_key,BUF_LEN);\n    SAFE_UINT8_BUF(encr_key,BUF_LEN);\n    if (!hex2carray(encryptedKeyHex, &decKeyLen, encr_key, BUF_LEN)) {\n        throw SGXException(INVALID_HEX, \"Invalid encryptedKeyHex\");\n    }\n\n    uint32_t enc_bls_len = 0;\n\n    sgx_status_t status = trustedCreateBlsKeyAES(eid, &errStatus, errMsg.data(), s_shares, encr_key, decKeyLen, encr_bls_key,\n                                                 &enc_bls_len);\n\n    HANDLE_TRUSTED_FUNCTION_ERROR(status, errStatus, errMsg.data());\n\n    SAFE_CHAR_BUF(hexBLSKey,2 * BUF_LEN)\n\n    carray2Hex(encr_bls_key, enc_bls_len, hexBLSKey, 2 * BUF_LEN);\n\n    SGXWalletServer::writeDataToDB(blsKeyName, hexBLSKey);\n\n    return true;\n\n}\n\nvector <string> getBLSPubKey(const char *encryptedKeyHex) {\n\n    CHECK_STATE(encryptedKeyHex);\n\n    vector<char> errMsg1(BUF_LEN, 0);\n\n    int errStatus = 0;\n    uint64_t decKeyLen = 0;\n\n    SAFE_UINT8_BUF(encrKey, BUF_LEN);\n    if (!hex2carray(encryptedKeyHex, &decKeyLen, encrKey, BUF_LEN)) {\n        throw SGXException(INVALID_HEX, \"Invalid encryptedKeyHex\");\n    }\n\n    SAFE_CHAR_BUF(pubKey,320)\n\n    sgx_status_t status = trustedGetBlsPubKeyAES(eid, &errStatus, errMsg1.data(), encrKey, decKeyLen, pubKey);\n    HANDLE_TRUSTED_FUNCTION_ERROR(status, errStatus, errMsg1.data());\n\n    vector <string> pubKeyVect = splitString(pubKey, ':');\n\n    spdlog::debug(\"pub key is \");\n    for (int i = 0; i < 4; i++)\n        spdlog::debug(\"{}\", pubKeyVect.at(i));\n\n    return pubKeyVect;\n}\n\nvector <string> calculateAllBlsPublicKeys(const vector <string> &public_shares) {\n    size_t n = public_shares.size();\n    size_t t = public_shares[0].length() / 256;\n    uint64_t share_length = 256;\n    uint8_t coord_length = 64;\n\n    vector <libff::alt_bn128_G2> public_keys(n, libff::alt_bn128_G2::zero());\n\n    vector <libff::alt_bn128_G2> public_values(t, libff::alt_bn128_G2::zero());\n    for (size_t i = 0; i < n; ++i) {\n        for (size_t j = 0; j < t; ++j) {\n            libff::alt_bn128_G2 public_share;\n\n            uint64_t pos0 = share_length * j;\n            string x_c0_str = convertHexToDec(public_shares[i].substr(pos0, coord_length));\n            string x_c1_str = convertHexToDec(public_shares[i].substr(pos0 + coord_length, coord_length));\n            string y_c0_str = convertHexToDec(public_shares[i].substr(pos0 + 2 * coord_length, coord_length));\n            string y_c1_str = convertHexToDec(public_shares[i].substr(pos0 + 3 * coord_length, coord_length));\n\n            if (x_c0_str == \"\" || x_c1_str == \"\" || y_c0_str == \"\" || y_c1_str == \"\") {\n                return {};\n            }\n\n            public_share.X.c0 = libff::alt_bn128_Fq(x_c0_str.c_str());\n            public_share.X.c1 = libff::alt_bn128_Fq(x_c1_str.c_str());\n            public_share.Y.c0 = libff::alt_bn128_Fq(y_c0_str.c_str());\n            public_share.Y.c1 = libff::alt_bn128_Fq(y_c1_str.c_str());\n            public_share.Z = libff::alt_bn128_Fq2::one();\n\n            public_values[j] = public_values[j] + public_share;\n\n        }\n    }\n\n    for (size_t i = 0; i < n; ++i) {\n        for (size_t j = 0; j < t; ++j) {\n            public_keys[i] = public_keys[i] + libff::power(libff::alt_bn128_Fr(i + 1), j) * public_values[j];\n        }\n        public_keys[i].to_affine_coordinates();\n    }\n\n    vector <string> result(n);\n    for (size_t i = 0; i < n; ++i) {\n        result[i] = convertG2ToString(public_keys[i]);\n    }\n\n    return result;\n}\n\nstring decryptDHKey(const string &polyName, int ind) {\n    vector<char> errMsg1(BUF_LEN, 0);\n    int errStatus = 0;\n\n    string DH_key_name = polyName + \"_\" + to_string(ind) + \":\";\n    shared_ptr <string> hexEncrKeyPtr = SGXWalletServer::readFromDb(DH_key_name, \"DKG_DH_KEY_\");\n\n    spdlog::debug(\"encr DH key is {}\", *hexEncrKeyPtr);\n\n    vector<char> hexEncrKey(2 * BUF_LEN, 0);\n\n    uint64_t dhEncLen = 0;\n    SAFE_UINT8_BUF(encryptedDHKey, BUF_LEN);\n    if (!hex2carray(hexEncrKeyPtr->c_str(), &dhEncLen, encryptedDHKey, BUF_LEN)) {\n        throw SGXException(INVALID_HEX, \"Invalid hexEncrKey\");\n    }\n    spdlog::debug(\"encr DH key length is {}\", dhEncLen);\n    spdlog::debug(\"hex encr DH key length is {}\", hexEncrKeyPtr->length());\n\n    SAFE_CHAR_BUF(DHKey, ECDSA_SKEY_LEN);\n\n    sgx_status_t status = trustedDecryptKeyAES(eid, &errStatus, errMsg1.data(), encryptedDHKey, dhEncLen, DHKey);\n    HANDLE_TRUSTED_FUNCTION_ERROR(status, errStatus, errMsg1.data());\n\n    return DHKey;\n}\n\nvector <string> mult_G2(const string &x) {\n    vector <string> result(4);\n    libff::alt_bn128_Fr el(x.c_str());\n    libff::alt_bn128_G2 elG2 = el * libff::alt_bn128_G2::one();\n    elG2.to_affine_coordinates();\n    result[0] = ConvertToString(elG2.X.c0);\n    result[1] = ConvertToString(elG2.X.c1);\n    result[2] = ConvertToString(elG2.Y.c0);\n    result[3] = ConvertToString(elG2.Y.c1);\n    return result;\n}\n", "/*\n    Copyright (C) 2019-Present SKALE Labs\n\n    This file is part of sgxwallet.\n\n    sgxwallet is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    sgxwallet is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with sgxwallet.  If not, see <https://www.gnu.org/licenses/>.\n\n    @file ECDSACrypto.cpp\n    @author Stan Kladko\n    @date 2019\n*/\n\n#include \"sgxwallet.h\"\n\n#include \"SGXException.h\"\n\n#include <iostream>\n#include <fstream>\n\n#include <gmp.h>\n#include <random>\n\n#include \"third_party/spdlog/spdlog.h\"\n#include \"common.h\"\n\n#include \"secure_enclave/Verify.h\"\n\n#include \"BLSCrypto.h\"\n\n#include \"ECDSACrypto.h\"\n\nvoid fillRandomBuffer(vector<unsigned char> &_buffer) {\n    ifstream devRandom(\"/dev/urandom\", ios::in | ios::binary);\n    devRandom.exceptions(ifstream::failbit | ifstream::badbit);\n    devRandom.read((char *) _buffer.data(), _buffer.size());\n    devRandom.close();\n}\n\nvector <string> genECDSAKey() {\n    vector<char> errMsg(BUF_LEN, 0);\n    int errStatus = 0;\n    vector <uint8_t> encr_pr_key(BUF_LEN, 0);\n    vector<char> pub_key_x(BUF_LEN, 0);\n    vector<char> pub_key_y(BUF_LEN, 0);\n\n    uint32_t enc_len = 0;\n\n    sgx_status_t status = trustedGenerateEcdsaKeyAES(eid, &errStatus,\n                                        errMsg.data(), encr_pr_key.data(), &enc_len,\n                                        pub_key_x.data(), pub_key_y.data());\n\n    HANDLE_TRUSTED_FUNCTION_ERROR(status, errStatus,errMsg.data());\n\n    vector <string> keys(3);\n\n    vector<char> hexEncrKey(BUF_LEN * 2, 0);\n\n    carray2Hex(encr_pr_key.data(), enc_len, hexEncrKey.data(),\n               BUF_LEN * 2);\n    keys.at(0) = hexEncrKey.data();\n    keys.at(1) = string(pub_key_x.data()) + string(pub_key_y.data());\n\n    vector<unsigned char> randBuffer(32, 0);\n    fillRandomBuffer(randBuffer);\n\n    vector<char> rand_str(BUF_LEN, 0);\n\n    carray2Hex(randBuffer.data(), 32, rand_str.data(), BUF_LEN);\n\n    keys.at(2) = rand_str.data();\n\n    CHECK_STATE(keys.at(2).size() == 64);\n\n    return keys;\n}\n\nstring getECDSAPubKey(const std::string& _encryptedKeyHex) {\n    vector<char> errMsg(BUF_LEN, 0);\n    vector<char> pubKeyX(BUF_LEN, 0);\n    vector<char> pubKeyY(BUF_LEN, 0);\n    vector<uint8_t> encrPrKey(BUF_LEN, 0);\n\n    int errStatus = 0;\n    uint64_t enc_len = 0;\n\n    if (!hex2carray(_encryptedKeyHex.c_str(), &enc_len, encrPrKey.data(),\n                    BUF_LEN)) {\n        throw SGXException(INVALID_HEX, \"Invalid encryptedKeyHex\");\n    }\n\n    sgx_status_t status = trustedGetPublicEcdsaKeyAES(eid, &errStatus,\n                                         errMsg.data(), encrPrKey.data(), enc_len, pubKeyX.data(), pubKeyY.data());\n\n    HANDLE_TRUSTED_FUNCTION_ERROR(status, errStatus, errMsg.data())\n\n    string pubKey = string(pubKeyX.data()) + string(pubKeyY.data());\n\n    if (pubKey.size() != 128) {\n        spdlog::error(\"Incorrect pub key size\", status);\n        throw SGXException(666, \"Incorrect pub key size\");\n    }\n\n    return pubKey;\n}\n\nbool verifyECDSASig(string& pubKeyStr, const char *hashHex, const char *signatureR,\n        const char *signatureS, int base) {\n\n    CHECK_STATE(hashHex)\n    CHECK_STATE(signatureR)\n    CHECK_STATE(signatureS)\n\n    auto x = pubKeyStr.substr(0, 64);\n    auto y = pubKeyStr.substr(64, 128);\n\n    mpz_t msgMpz;\n    mpz_init(msgMpz);\n    if (mpz_set_str(msgMpz, hashHex, 16) == -1) {\n        spdlog::error(\"invalid message hash {}\", hashHex);\n        mpz_clear(msgMpz);\n        return false;\n    }\n\n    signature sig = signature_init();\n    if (signature_set_str(sig, signatureR, signatureS, base) != 0) {\n        spdlog::error(\"Failed to set str signature\");\n        mpz_clear(msgMpz);\n        signature_free(sig);\n        return false;\n    }\n\n    domain_parameters curve = domain_parameters_init();\n    domain_parameters_load_curve(curve, secp256k1);\n\n    point publicKey = point_init();\n\n    point_set_hex(publicKey, x.c_str(), y.c_str());\n    if (!signature_verify(msgMpz, sig, publicKey, curve)) {\n        spdlog::error(\"ECDSA sig not verified\");\n        mpz_clear(msgMpz);\n        signature_free(sig);\n        domain_parameters_clear(curve);\n        point_clear(publicKey);\n        return false;\n    }\n\n    mpz_clear(msgMpz);\n    signature_free(sig);\n    domain_parameters_clear(curve);\n    point_clear(publicKey);\n\n    return true;\n}\n\nvector <string> ecdsaSignHash(const std::string& encryptedKeyHex, const char *hashHex, int base) {\n\n    CHECK_STATE(hashHex);\n\n    vector <string> signatureVector(3);\n\n    vector<char> errMsg(BUF_LEN, 0);\n    int errStatus = 0;\n    vector<char> signatureR(BUF_LEN, 0);\n    vector<char> signatureS(BUF_LEN, 0);\n    vector<uint8_t> encryptedKey(BUF_LEN, 0);\n    uint8_t signatureV = 0;\n    uint64_t decLen = 0;\n\n    string pubKeyStr = \"\";\n\n    if (!hex2carray(encryptedKeyHex.c_str(), &decLen, encryptedKey.data(),\n                    BUF_LEN)) {\n        throw SGXException(INVALID_HEX, \"Invalid encryptedKeyHex\");\n    }\n\n    sgx_status_t status = trustedEcdsaSignAES(eid, &errStatus,\n            errMsg.data(), encryptedKey.data(), decLen, hashHex,\n                                 signatureR.data(),\n                                 signatureS.data(), &signatureV, base);\n\n    HANDLE_TRUSTED_FUNCTION_ERROR(status, errStatus, errMsg.data());\n\n\n    signatureVector.at(0) = to_string(signatureV);\n\n    if (base == 16) {\n        signatureVector.at(1) = \"0x\" + string(signatureR.data());\n        signatureVector.at(2) = \"0x\" + string(signatureS.data());\n    } else {\n        signatureVector.at(1) = string(signatureR.data());\n        signatureVector.at(2) = string(signatureS.data());\n    }\n\n    /* Now verify signature */\n\n    pubKeyStr = getECDSAPubKey(encryptedKeyHex);\n\n    static uint64_t  i = 0;\n\n    i++;\n\n    if (i % 1000 == 0) {\n\n        if (!verifyECDSASig(pubKeyStr, hashHex, signatureR.data(), signatureS.data(), base)) {\n            spdlog::error(\"failed to verify ecdsa signature\");\n            throw SGXException(667, \"ECDSA did not verify\");\n        }\n    }\n\n    return signatureVector;\n}\n", "/*\n    Copyright (C) 2019-Present SKALE Labs\n\n    This file is part of sgxwallet.\n\n    sgxwallet is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    sgxwallet is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with sgxwallet.  If not, see <https://www.gnu.org/licenses/>.\n\n    @file SEKManager.cpp\n    @author Stan Kladko\n    @date 2020\n*/\n\n#include \"SEKManager.h\"\n#include \"SGXException.h\"\n#include \"BLSCrypto.h\"\n#include \"LevelDB.h\"\n\n#include <fstream>\n#include <iostream>\n#include <algorithm>\n\n#include \"sgxwallet_common.h\"\n#include \"common.h\"\n#include \"sgxwallet.h\"\n\n#include \"ServerDataChecker.h\"\n#include \"third_party/spdlog/spdlog.h\"\n\nusing namespace std;\n\n#define BACKUP_PATH \"./sgx_data/sgxwallet_backup_key.txt\"\n\n\nbool case_insensitive_match(string s1, string s2) {\n    //convert s1 and s2 into lower case strings\n    transform(s1.begin(), s1.end(), s1.begin(), ::tolower);\n    transform(s2.begin(), s2.end(), s2.begin(), ::tolower);\n    return s1.compare(s2);\n}\n\nvoid create_test_key() {\n    int errStatus = 0;\n    vector<char> errMsg(1024, 0);\n    uint32_t enc_len;\n\n    SAFE_UINT8_BUF(encrypted_key, BUF_LEN);\n\n    string key = TEST_VALUE;\n\n    sgx_status_t status = trustedEncryptKeyAES(eid, &errStatus, errMsg.data(), key.c_str(), encrypted_key, &enc_len);\n\n    HANDLE_TRUSTED_FUNCTION_ERROR(status, errStatus, errMsg.data());\n\n    vector<char> hexEncrKey(2 * enc_len + 1, 0);\n\n    carray2Hex(encrypted_key, enc_len, hexEncrKey.data(), 2 * enc_len + 1);\n\n    LevelDB::getLevelDb()->writeDataUnique(\"TEST_KEY\", hexEncrKey.data());\n}\n\n\nvoid validate_SEK() {\n\n    shared_ptr <string> test_key_ptr = LevelDB::getLevelDb()->readString(\"TEST_KEY\");\n    vector <uint8_t> encr_test_key(BUF_LEN, 0);\n    vector<char> decr_key(BUF_LEN, 0);\n    uint64_t len = 0;\n    vector<char> errMsg(BUF_LEN, 0);\n\n    int err_status = 0;\n\n    if (!hex2carray(test_key_ptr->c_str(), &len, encr_test_key.data(),\n                    BUF_LEN)) {\n        spdlog::error(\"Corrupt test key is LevelDB\");\n        exit(-1);\n    }\n\n    sgx_status_t status = trustedDecryptKeyAES(eid, &err_status, errMsg.data(), encr_test_key.data(), len, decr_key.data());\n\n    HANDLE_TRUSTED_FUNCTION_ERROR(status, err_status, errMsg.data());\n\n    string test_key = TEST_VALUE;\n\n    if (test_key.compare(decr_key.data()) != 0) {\n        spdlog::error(\"Invalid storage key. You need to recover using backup key\");\n        spdlog::error(\"Set the correct backup key into sgx_datasgxwallet_backup_key.txt\");\n        spdlog::error(\"Then run sgxwallet using backup flag\");\n        exit(-1);\n    }\n}\n\n\nshared_ptr <vector<uint8_t>> check_and_set_SEK(const string &SEK) {\n\n    vector<char> decr_key(BUF_LEN, 0);\n    vector<char> errMsg(BUF_LEN, 0);\n    int err_status = 0;\n\n    auto encrypted_SEK = make_shared < vector < uint8_t >> (BUF_LEN, 0);\n\n    uint32_t l = 0;\n\n    sgx_status_t status = trustedSetSEK_backup(eid, &err_status, errMsg.data(), encrypted_SEK->data(), &l,\n                                               SEK.c_str());\n\n    encrypted_SEK->resize(l);\n\n    HANDLE_TRUSTED_FUNCTION_ERROR(status, err_status, errMsg.data());\n\n    validate_SEK();\n\n    return encrypted_SEK;\n}\n\nvoid gen_SEK() {\n    vector<char> errMsg(1024, 0);\n    int err_status = 0;\n    vector <uint8_t> encrypted_SEK(1024, 0);\n    uint32_t enc_len = 0;\n\n    SAFE_CHAR_BUF(SEK, 65);\n\n    spdlog::info(\"Generating backup key. Will be stored in backup_key.txt ... \");\n\n    sgx_status_t status = trustedGenerateSEK(eid, &err_status, errMsg.data(), encrypted_SEK.data(), &enc_len, SEK);\n\n    HANDLE_TRUSTED_FUNCTION_ERROR(status, err_status, errMsg.data());\n\n\n    if (strnlen(SEK, 33) != 32) {\n        throw SGXException(-1, \"strnlen(SEK,33) != 32\");\n    }\n\n    vector<char> hexEncrKey(2 * enc_len + 1, 0);\n\n    carray2Hex(encrypted_SEK.data(), enc_len, hexEncrKey.data(), 2 * enc_len + 1);\n\n    spdlog::info(string(\"Encrypted storage encryption key:\") + hexEncrKey.data());\n\n    ofstream sek_file(BACKUP_PATH);\n    sek_file.clear();\n\n    sek_file << SEK;\n\n\n    cout << \"ATTENTION! YOUR BACKUP KEY HAS BEEN WRITTEN INTO sgx_data/backup_key.txt \\n\" <<\n         \"PLEASE COPY IT TO THE SAFE PLACE AND THEN DELETE THE FILE MANUALLY BY RUNNING THE FOLLOWING COMMAND:\\n\" <<\n         \"apt-get install secure-delete && srm -vz sgx_data/backup_key.txt\" << endl;\n\n\n    if (!autoconfirm) {\n        string confirm_str = \"I confirm\";\n        string buffer;\n        do {\n            cout << \" DO YOU CONFIRM THAT YOU COPIED THE KEY? (if you confirm type - I confirm)\"\n                 << endl;\n            getline(cin, buffer);\n        } while (case_insensitive_match(confirm_str, buffer));\n    }\n\n\n    LevelDB::getLevelDb()->writeDataUnique(\"SEK\", hexEncrKey.data());\n\n    create_test_key();\n\n    validate_SEK();\n\n    shared_ptr <string> encrypted_SEK_ptr = LevelDB::getLevelDb()->readString(\"SEK\");\n\n    setSEK(encrypted_SEK_ptr);\n\n    validate_SEK();\n\n}\n\nvoid setSEK(shared_ptr <string> hex_encrypted_SEK) {\n\n    CHECK_STATE(hex_encrypted_SEK);\n\n    vector<char> errMsg(1024, 0);\n    int err_status = 0;\n\n    SAFE_UINT8_BUF(encrypted_SEK, BUF_LEN);\n\n    uint64_t len = 0;\n\n    if (!hex2carray(hex_encrypted_SEK->c_str(), &len, encrypted_SEK,\n                    BUF_LEN)) {\n        throw SGXException(INVALID_HEX, \"Invalid encrypted SEK Hex\");\n    }\n\n    sgx_status_t status = trustedSetSEK(eid, &err_status, errMsg.data(), encrypted_SEK);\n\n    HANDLE_TRUSTED_FUNCTION_ERROR(status, err_status, errMsg.data());\n\n\n    validate_SEK();\n\n\n}\n\n#include \"experimental/filesystem\"\n\n#include <boost/algorithm/string.hpp>\n\nvoid enter_SEK() {\n\n    shared_ptr <string> test_key_ptr = LevelDB::getLevelDb()->readString(\"TEST_KEY\");\n    if (test_key_ptr == nullptr) {\n        spdlog::error(\"Error: corrupt or empty LevelDB database\");\n        exit(-1);\n    }\n\n\n    if (!experimental::filesystem::is_regular_file(BACKUP_PATH)) {\n        spdlog::error(\"File does not exist: \"  BACKUP_PATH);\n        exit(-1);\n    }\n\n    ifstream sek_file(BACKUP_PATH);\n\n    spdlog::info(\"Reading backup key from file ...\");\n\n    string sek((istreambuf_iterator<char>(sek_file)),\n               istreambuf_iterator<char>());\n\n    boost::trim(sek);\n\n    spdlog::info(\"Setting backup key ...\");\n\n    while (!checkHex(sek, 16)) {\n        spdlog::error(\"Invalid hex in key\");\n        exit(-1);\n    }\n\n    auto encrypted_SEK = check_and_set_SEK(sek);\n\n    vector<char> hexEncrKey(BUF_LEN, 0);\n\n    carray2Hex(encrypted_SEK->data(), encrypted_SEK->size(), hexEncrKey.data(),\n               BUF_LEN);\n\n    spdlog::info(\"Got sealed storage encryption key.\");\n\n    LevelDB::getLevelDb()->deleteKey(\"SEK\");\n\n    spdlog::info(\"Storing sealed storage encryption key in LevelDB ...\");\n\n    LevelDB::getLevelDb()->writeDataUnique(\"SEK\", hexEncrKey.data());\n\n    spdlog::info(\"Stored storage encryption key in LevelDB.\");\n\n}\n\nvoid initSEK() {\n    shared_ptr <string> encrypted_SEK_ptr = LevelDB::getLevelDb()->readString(\"SEK\");\n    if (enterBackupKey) {\n        enter_SEK();\n    } else {\n        if (encrypted_SEK_ptr == nullptr) {\n            spdlog::warn(\"SEK was not created yet. Going to create SEK\");\n            gen_SEK();\n        } else {\n            setSEK(encrypted_SEK_ptr);\n        }\n    }\n}\n\n//a002e7ca685d46a32771d16fe2518e58\n", "/*\n    Copyright (C) 2019-Present SKALE Labs\n\n    This file is part of sgxwallet.\n\n    sgxwallet is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    sgxwallet is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with sgxwallet.  If not, see <https://www.gnu.org/licenses/>.\n\n    @file SGXWalletServer.cpp\n    @author Stan Kladko\n    @date 2019\n*/\n\n#include <iostream>\n\n#include \"abstractstubserver.h\"\n#include <jsonrpccpp/server/connectors/httpserver.h>\n\n#include <stdio.h>\n\n#include \"sgxwallet_common.h\"\n#include \"sgxwallet.h\"\n\n\n#include \"SGXException.h\"\n#include \"LevelDB.h\"\n#include \"BLSCrypto.h\"\n#include \"ECDSACrypto.h\"\n#include \"DKGCrypto.h\"\n\n#include \"SGXWalletServer.h\"\n#include \"SGXWalletServer.hpp\"\n\n#include \"ServerDataChecker.h\"\n\n#include <algorithm>\n#include <stdlib.h>\n\n#include <unistd.h>\n\n#include \"ServerInit.h\"\n\n#include \"Log.h\"\n\nusing namespace std;\n\nvoid setFullOptions(uint64_t _logLevel, int _useHTTPS, int _autoconfirm, int _enterBackupKey) {\n    spdlog::info(\"Entering {}\", __FUNCTION__);\n\n    CHECK_STATE(_logLevel <= 2)\n\n    if (_logLevel == L_TRACE) {\n        spdlog::set_level(spdlog::level::trace);\n    } else if (_logLevel == L_DEBUG) {\n        spdlog::set_level(spdlog::level::debug);\n    } else {\n        spdlog::set_level(spdlog::level::info);\n    }\n\n    useHTTPS = _useHTTPS;\n    spdlog::info(\"useHTTPS set to \" + to_string(_useHTTPS));\n    autoconfirm = _autoconfirm;\n    spdlog::info(\"autoconfirm set to \" + to_string(autoconfirm));\n    enterBackupKey = _enterBackupKey;\n    spdlog::info(\"enterBackupKey set to \" + to_string(enterBackupKey));\n}\n\nvoid setOptions(uint64_t _logLevel, int _useHTTPS, int _autoconfirm) {\n    spdlog::info(\"Entering {}\", __FUNCTION__);\n    setFullOptions(_logLevel, _useHTTPS, _autoconfirm, false);\n}\n\nbool isStringDec(const string &_str) {\n    auto res = find_if_not(_str.begin(), _str.end(), [](char c) -> bool {\n        return isdigit(c);\n    });\n    return !_str.empty() && res == _str.end();\n}\n\nshared_ptr <SGXWalletServer> SGXWalletServer::server = nullptr;\nshared_ptr <HttpServer> SGXWalletServer::httpServer = nullptr;\n\nSGXWalletServer::SGXWalletServer(AbstractServerConnector &_connector,\n                                 serverVersion_t _type)\n        : AbstractStubServer(_connector, _type) {}\n\nvoid SGXWalletServer::printDB() {\n    cout << \"PRINTING LEVELDB: \" << endl;\n    class MyVisitor : public LevelDB::KeyVisitor {\n    public:\n        virtual void visitDBKey(const char *_data) {\n            cout << _data << endl;\n        }\n    };\n\n    MyVisitor v;\n\n    LevelDB::getLevelDb()->visitKeys(&v, 100000000);\n}\n\nint SGXWalletServer::initHttpsServer(bool _checkCerts) {\n    spdlog::info(\"Entering {}\", __FUNCTION__);\n    string rootCAPath = string(SGXDATA_FOLDER) + \"cert_data/rootCA.pem\";\n    string keyCAPath = string(SGXDATA_FOLDER) + \"cert_data/rootCA.key\";\n\n    if (access(rootCAPath.c_str(), F_OK) != 0 || access(keyCAPath.c_str(), F_OK) != 0) {\n        spdlog::info(\"NO ROOT CA CERTIFICATE YET. CREATING ...\");\n\n        string genRootCACert = \"cd cert && ./create_CA\";\n\n        if (system(genRootCACert.c_str()) == 0) {\n            spdlog::info(\"ROOT CA CERTIFICATE IS SUCCESSFULLY GENERATED\");\n        } else {\n            spdlog::error(\"ROOT CA CERTIFICATE GENERATION FAILED\");\n            exit(-1);\n        }\n    }\n\n    string certPath = string(SGXDATA_FOLDER) + \"cert_data/SGXServerCert.crt\";\n    string keyPath = string(SGXDATA_FOLDER) + \"cert_data/SGXServerCert.key\";\n\n    if (access(certPath.c_str(), F_OK) != 0 || access(certPath.c_str(), F_OK) != 0) {\n        spdlog::info(\"YOU DO NOT HAVE SERVER CERTIFICATE\");\n        spdlog::info(\"SERVER CERTIFICATE IS GOING TO BE CREATED\");\n\n        string genCert = \"cd cert && ./create_server_cert\";\n\n        if (system(genCert.c_str()) == 0) {\n            spdlog::info(\"SERVER CERTIFICATE IS SUCCESSFULLY GENERATED\");\n        } else {\n            spdlog::info(\"SERVER CERTIFICATE GENERATION FAILED\");\n            exit(-1);\n        }\n    }\n\n\n    int numThreads = 64;\n\n#if SGX_MODE == SIM\n   numThreads = 16; \n#endif\n\n\n    httpServer = make_shared<HttpServer>(BASE_PORT, certPath, keyPath, rootCAPath, _checkCerts, numThreads);\n    server = make_shared<SGXWalletServer>(*httpServer,\n                                          JSONRPC_SERVER_V2); // hybrid server (json-rpc 1.0 & 2.0)\n\n    if (!server->StartListening()) {\n        spdlog::error(\"SGX Server could not start listening\");\n        exit(-1);\n    } else {\n        spdlog::info(\"SGX Server started on port {}\", BASE_PORT);\n    }\n    return 0;\n}\n\nint SGXWalletServer::initHttpServer() { //without ssl\n    spdlog::info(\"Entering {}\", __FUNCTION__);\n    httpServer = make_shared<HttpServer>(BASE_PORT + 3);\n    server = make_shared<SGXWalletServer>(*httpServer,\n                                          JSONRPC_SERVER_V2); // hybrid server (json-rpc 1.0 & 2.0)\n    if (!server->StartListening()) {\n        spdlog::error(\"Server could not start listening\");\n        exit(-1);\n    }\n    return 0;\n}\n\nJson::Value\nSGXWalletServer::importBLSKeyShareImpl(const string &_keyShare, const string &_keyShareName) {\n    spdlog::info(\"Entering {}\", __FUNCTION__);\n    INIT_RESULT(result);\n\n    result[\"encryptedKeyShare\"] = \"\";\n\n    string encryptedKeyShareHex;\n\n    try {\n        if (!checkName(_keyShareName, \"BLS_KEY\")) {\n            throw SGXException(INVALID_BLS_NAME, \"Invalid BLS key name\");\n        }\n\n        encryptedKeyShareHex = encryptBLSKeyShare2Hex(&errStatus, (char *) errMsg.data(), _keyShare.c_str());\n\n        if (errStatus != 0) {\n            throw SGXException(errStatus, errMsg.data());\n        }\n\n        if (encryptedKeyShareHex.empty()) {\n            throw SGXException(UNKNOWN_ERROR, \"\");\n        }\n\n        result[\"encryptedKeyShare\"] = encryptedKeyShareHex;\n\n        writeKeyShare(_keyShareName, encryptedKeyShareHex);\n    } HANDLE_SGX_EXCEPTION(result)\n\n    RETURN_SUCCESS(result);\n}\n\nJson::Value\nSGXWalletServer::blsSignMessageHashImpl(const string &_keyShareName, const string &_messageHash, int t, int n) {\n    spdlog::trace(\"Entering {}\", __FUNCTION__);\n    INIT_RESULT(result)\n\n    result[\"status\"] = -1;\n\n    result[\"signatureShare\"] = \"\";\n\n    vector<char> signature(BUF_LEN, 0);\n\n    shared_ptr <string> value = nullptr;\n\n    try {\n        if (!checkName(_keyShareName, \"BLS_KEY\")) {\n            throw SGXException(INVALID_POLY_NAME, \"Invalid BLSKey name\");\n        }\n\n        if (!check_n_t(t, n)) {\n            throw SGXException(INVALID_DKG_PARAMS, \"Invalid t/n parameters\");\n        }\n\n        string hashTmp = _messageHash;\n        if (hashTmp[0] == '0' && (hashTmp[1] == 'x' || hashTmp[1] == 'X')) {\n            hashTmp.erase(hashTmp.begin(), hashTmp.begin() + 2);\n        }\n        while (hashTmp[0] == '0') {\n            hashTmp.erase(hashTmp.begin(), hashTmp.begin() + 1);\n        }\n\n        if (!checkHex(hashTmp)) {\n            throw SGXException(INVALID_HEX, \"Invalid hash\");\n        }\n\n        value = readFromDb(_keyShareName);\n\n        if (!bls_sign(value->c_str(), _messageHash.c_str(), t, n, signature.data())) {\n            throw SGXException(-1, \"Could not sign data \");\n        }\n    } HANDLE_SGX_EXCEPTION(result)\n\n\n    result[\"signatureShare\"] = string(signature.data());\n\n    RETURN_SUCCESS(result);\n\n}\n\nJson::Value SGXWalletServer::generateECDSAKeyImpl() {\n    spdlog::info(\"Entering {}\", __FUNCTION__);\n    INIT_RESULT(result)\n    result[\"encryptedKey\"] = \"\";\n\n    vector <string> keys;\n\n    try {\n        keys = genECDSAKey();\n\n        if (keys.size() == 0) {\n            throw SGXException(UNKNOWN_ERROR, \"key was not generated\");\n        }\n\n        string keyName = \"NEK:\" + keys.at(2);\n\n        writeDataToDB(keyName, keys.at(0));\n\n        result[\"encryptedKey\"] = keys.at(0);\n        result[\"publicKey\"] = keys.at(1);\n        result[\"PublicKey\"] = keys.at(1);\n        result[\"keyName\"] = keyName;\n    } HANDLE_SGX_EXCEPTION(result)\n\n    RETURN_SUCCESS(result);\n}\n\nJson::Value SGXWalletServer::ecdsaSignMessageHashImpl(int _base, const string &_keyName, const string &_messageHash) {\n    spdlog::trace(\"Entering {}\", __FUNCTION__);\n    INIT_RESULT(result)\n\n    result[\"signature_v\"] = \"\";\n    result[\"signature_r\"] = \"\";\n    result[\"signature_s\"] = \"\";\n\n    vector <string> signatureVector(3);\n\n    try {\n        string hashTmp = _messageHash;\n        if (hashTmp[0] == '0' && (hashTmp[1] == 'x' || hashTmp[1] == 'X')) {\n            hashTmp.erase(hashTmp.begin(), hashTmp.begin() + 2);\n        }\n        while (hashTmp[0] == '0') {\n            hashTmp.erase(hashTmp.begin(), hashTmp.begin() + 1);\n        }\n\n        if (!checkECDSAKeyName(_keyName)) {\n            throw SGXException(INVALID_ECDSA_KEY_NAME, \"Invalid ECDSA key name\");\n        }\n        if (!checkHex(hashTmp)) {\n            throw SGXException(INVALID_HEX, \"Invalid hash\");\n        }\n        if (_base <= 0 || _base > 32) {\n            throw SGXException(-22, \"Invalid base\");\n        }\n\n        shared_ptr <string> encryptedKey = readFromDb(_keyName, \"\");\n\n        signatureVector = ecdsaSignHash(encryptedKey->c_str(), hashTmp.c_str(), _base);\n        if (signatureVector.size() != 3) {\n            throw SGXException(INVALID_ECSDA_SIGNATURE, \"Invalid ecdsa signature\");\n        }\n\n        result[\"signature_v\"] = signatureVector.at(0);\n        result[\"signature_r\"] = signatureVector.at(1);\n        result[\"signature_s\"] = signatureVector.at(2);\n    } HANDLE_SGX_EXCEPTION(result)\n\n    RETURN_SUCCESS(result)\n}\n\nJson::Value SGXWalletServer::getPublicECDSAKeyImpl(const string &_keyName) {\n    spdlog::debug(\"Entering {}\", __FUNCTION__);\n    INIT_RESULT(result)\n\n    result[\"publicKey\"] = \"\";\n    result[\"PublicKey\"] = \"\";\n\n    string publicKey;\n\n    try {\n        if (!checkECDSAKeyName(_keyName)) {\n            throw SGXException(INVALID_ECDSA_KEY_NAME, \"Invalid ECDSA key name\");\n        }\n        shared_ptr <string> keyStr = readFromDb(_keyName);\n        publicKey = getECDSAPubKey(keyStr->c_str());\n        result[\"PublicKey\"] = publicKey;\n        result[\"publicKey\"] = publicKey;\n    } HANDLE_SGX_EXCEPTION(result)\n\n    RETURN_SUCCESS(result)\n}\n\nJson::Value SGXWalletServer::generateDKGPolyImpl(const string &_polyName, int _t) {\n    spdlog::info(\"Entering {}\", __FUNCTION__);\n    INIT_RESULT(result)\n\n    string encrPolyHex;\n\n    try {\n        if (!checkName(_polyName, \"POLY\")) {\n            throw SGXException(INVALID_POLY_NAME,\n                               \"Invalid polynomial name, it should be like POLY:SCHAIN_ID:1:NODE_ID:1:DKG_ID:1\");\n        }\n        if (_t <= 0 || _t > 32) {\n            throw SGXException(INVALID_DKG_PARAMS, \"Invalid parameter t \");\n        }\n        encrPolyHex = gen_dkg_poly(_t);\n        writeDataToDB(_polyName, encrPolyHex);\n    } HANDLE_SGX_EXCEPTION(result)\n\n    RETURN_SUCCESS(result)\n}\n\nJson::Value SGXWalletServer::getVerificationVectorImpl(const string &_polyName, int _t, int _n) {\n    spdlog::info(\"Entering {}\", __FUNCTION__);\n    INIT_RESULT(result)\n\n    vector <vector<string>> verifVector;\n    try {\n        if (!checkName(_polyName, \"POLY\")) {\n            throw SGXException(INVALID_POLY_NAME, \"Invalid polynomial name\");\n        }\n        if (!check_n_t(_t, _n)) {\n            throw SGXException(INVALID_DKG_PARAMS, \"Invalid parameters: n or t \");\n        }\n\n        shared_ptr <string> encrPoly = readFromDb(_polyName);\n\n        verifVector = get_verif_vect(encrPoly->c_str(), _t, _n);\n\n        for (int i = 0; i < _t; i++) {\n            vector <string> currentCoef = verifVector.at(i);\n            for (int j = 0; j < 4; j++) {\n                result[\"verificationVector\"][i][j] = currentCoef.at(j);\n            }\n        }\n    } HANDLE_SGX_EXCEPTION(result)\n\n    RETURN_SUCCESS(result)\n\n}\n\nJson::Value SGXWalletServer::getSecretShareImpl(const string &_polyName, const Json::Value &_pubKeys, int _t, int _n) {\n    spdlog::info(\"Entering {}\", __FUNCTION__);\n    INIT_RESULT(result);\n    result[\"secretShare\"] = \"\";\n    result[\"SecretShare\"] = \"\";\n\n    try {\n        if (_pubKeys.size() != (uint64_t) _n) {\n            throw SGXException(INVALID_DKG_PARAMS, \"invalid number of public keys\");\n        }\n        if (!checkName(_polyName, \"POLY\")) {\n            throw SGXException(INVALID_POLY_NAME, \"Invalid polynomial name\");\n        }\n        if (!check_n_t(_t, _n)) {\n            throw SGXException(INVALID_DKG_PARAMS, \"Invalid DKG parameters: n or t \");\n        }\n\n        shared_ptr <string> encrPoly = readFromDb(_polyName);\n\n        vector <string> pubKeysStrs;\n        for (int i = 0; i < _n; i++) {\n            if (!checkHex(_pubKeys[i].asString(), 64)) {\n                throw SGXException(INVALID_HEX, \"Invalid public key\");\n            }\n            pubKeysStrs.push_back(_pubKeys[i].asString());\n        }\n\n        string s = getSecretShares(_polyName, encrPoly->c_str(), pubKeysStrs, _t, _n);\n        result[\"secretShare\"] = s;\n        result[\"SecretShare\"] = s;\n    } HANDLE_SGX_EXCEPTION(result)\n\n    RETURN_SUCCESS(result)\n}\n\nJson::Value SGXWalletServer::dkgVerificationImpl(const string &_publicShares, const string &_ethKeyName,\n                                                 const string &_secretShare, int _t, int _n, int _index) {\n    spdlog::info(\"Entering {}\", __FUNCTION__);\n    INIT_RESULT(result)\n    result[\"result\"] = false;\n\n    try {\n        if (!checkECDSAKeyName(_ethKeyName)) {\n            throw SGXException(INVALID_ECDSA_KEY_NAME, \"Invalid ECDSA key name\");\n        }\n        if (!check_n_t(_t, _n) || _index >= _n || _index < 0) {\n            throw SGXException(INVALID_DKG_PARAMS, \"Invalid DKG parameters: n or t \");\n        }\n        if (!checkHex(_secretShare, SECRET_SHARE_NUM_BYTES)) {\n            throw SGXException(INVALID_HEX, \"Invalid Secret share\");\n        }\n        if (_publicShares.length() != (uint64_t) 256 * _t) {\n            throw SGXException(INVALID_DKG_PARAMS, \"Invalid length of public shares\");\n        }\n\n        shared_ptr <string> encryptedKeyHex_ptr = readFromDb(_ethKeyName);\n\n        if (verifyShares(_publicShares.c_str(), _secretShare.c_str(), encryptedKeyHex_ptr->c_str(), _t, _n, _index)) {\n            result[\"result\"] = true;\n        }\n    } HANDLE_SGX_EXCEPTION(result)\n\n    RETURN_SUCCESS(result)\n}\n\nJson::Value\nSGXWalletServer::createBLSPrivateKeyImpl(const string &_blsKeyName, const string &_ethKeyName, const string &_polyName,\n                                         const string &_secretShare, int _t, int _n) {\n    spdlog::info(\"Entering {}\", __FUNCTION__);\n    INIT_RESULT(result)\n\n    try {\n        if (_secretShare.length() != (uint64_t) _n * 192) {\n            throw SGXException(INVALID_SECRET_SHARES_LENGTH, \"Invalid secret share length\");\n        }\n        if (!checkECDSAKeyName(_ethKeyName)) {\n            throw SGXException(INVALID_ECDSA_KEY_NAME, \"Invalid ECDSA key name\");\n        }\n        if (!checkName(_polyName, \"POLY\")) {\n            throw SGXException(INVALID_POLY_NAME, \"Invalid polynomial name\");\n        }\n        if (!checkName(_blsKeyName, \"BLS_KEY\")) {\n            throw SGXException(INVALID_BLS_NAME, \"Invalid BLS key name\");\n        }\n        if (!check_n_t(_t, _n)) {\n            throw SGXException(INVALID_DKG_PARAMS, \"Invalid DKG parameters: n or t \");\n        }\n        vector <string> sshares_vect;\n\n        shared_ptr <string> encryptedKeyHex_ptr = readFromDb(_ethKeyName);\n\n        bool res = createBLSShare(_blsKeyName, _secretShare.c_str(), encryptedKeyHex_ptr->c_str());\n        if (res) {\n            spdlog::info(\"BLS KEY SHARE CREATED \");\n        } else {\n            throw SGXException(-122, \"Error while creating BLS key share\");\n        }\n\n        for (int i = 0; i < _n; i++) {\n            string name = _polyName + \"_\" + to_string(i) + \":\";\n            LevelDB::getLevelDb()->deleteDHDKGKey(name);\n            string shareG2_name = \"shareG2_\" + _polyName + \"_\" + to_string(i) + \":\";\n            LevelDB::getLevelDb()->deleteKey(shareG2_name);\n        }\n        LevelDB::getLevelDb()->deleteKey(_polyName);\n\n    } HANDLE_SGX_EXCEPTION(result)\n\n    RETURN_SUCCESS(result);\n}\n\nJson::Value SGXWalletServer::getBLSPublicKeyShareImpl(const string &_blsKeyName) {\n    spdlog::info(\"Entering {}\", __FUNCTION__);\n    INIT_RESULT(result)\n\n    try {\n        if (!checkName(_blsKeyName, \"BLS_KEY\")) {\n            throw SGXException(INVALID_BLS_NAME, \"Invalid BLSKey name\");\n        }\n        shared_ptr <string> encryptedKeyHex_ptr = readFromDb(_blsKeyName);\n\n        vector <string> public_key_vect = getBLSPubKey(encryptedKeyHex_ptr->c_str());\n        for (uint8_t i = 0; i < 4; i++) {\n            result[\"blsPublicKeyShare\"][i] = public_key_vect.at(i);\n        }\n    } HANDLE_SGX_EXCEPTION(result)\n\n    RETURN_SUCCESS(result);\n}\n\nJson::Value SGXWalletServer::calculateAllBLSPublicKeysImpl(const Json::Value& publicShares, int t, int n) {\n    spdlog::info(\"Entering {}\", __FUNCTION__);\n    INIT_RESULT(result)\n\n    try {\n        if (!check_n_t(t, n)) {\n            throw SGXException(INVALID_DKG_PARAMS, \"Invalid DKG parameters: n or t \");\n        }\n\n        if (!publicShares.isArray()) {\n            throw SGXException(INVALID_DKG_PARAMS, \"Invalid public shares format\");\n        }\n\n        if (publicShares.size() != (uint64_t) n) {\n            throw SGXException(INVALID_DKG_PARAMS, \"Invalid length of public shares\");\n        }\n\n        for (int i = 0; i < n; ++i) {\n            if (!publicShares[i].isString()) {\n                throw SGXException(INVALID_DKG_PARAMS, \"Invalid public shares parts format\");\n            }\n\n            if (publicShares[i].asString().length() != (uint64_t) 256 * t) {\n                throw SGXException(INVALID_DKG_PARAMS, \"Invalid length of public shares parts\");\n            }\n        }\n\n        vector<string> public_shares(n);\n        for (int i = 0; i < n; ++i) {\n            public_shares[i] = publicShares[i].asString();\n        }\n\n        vector<string> public_keys = calculateAllBlsPublicKeys(public_shares);\n\n        if (public_keys.size() != n) {\n            throw SGXException(UNKNOWN_ERROR, \"\");\n        }\n\n        for (int i = 0; i < n; ++i) {\n            result[\"publicKeys\"][i] = public_keys[i];\n        }\n    } HANDLE_SGX_EXCEPTION(result)\n\n    RETURN_SUCCESS(result);\n}\n\nJson::Value SGXWalletServer::complaintResponseImpl(const string &_polyName, int _ind) {\n    spdlog::info(\"Entering {}\", __FUNCTION__);\n    INIT_RESULT(result)\n\n    try {\n        if (!checkName(_polyName, \"POLY\")) {\n            throw SGXException(INVALID_POLY_NAME, \"Invalid polynomial name\");\n        }\n\n        string shareG2_name = \"shareG2_\" + _polyName + \"_\" + to_string(_ind) + \":\";\n        shared_ptr <string> shareG2_ptr = readFromDb(shareG2_name);\n\n        string DHKey = decryptDHKey(_polyName, _ind);\n\n        result[\"share*G2\"] = *shareG2_ptr;\n        result[\"dhKey\"] = DHKey;\n    } HANDLE_SGX_EXCEPTION(result)\n\n    RETURN_SUCCESS(result);\n}\n\nJson::Value SGXWalletServer::multG2Impl(const string &_x) {\n    INIT_RESULT(result)\n\n    try {\n        auto xG2_vect = mult_G2(_x);\n        for (uint8_t i = 0; i < 4; i++) {\n            result[\"x*G2\"][i] = xG2_vect.at(i);\n        }\n    } HANDLE_SGX_EXCEPTION(result)\n\n    RETURN_SUCCESS(result);\n}\n\nJson::Value SGXWalletServer::isPolyExistsImpl(const string &_polyName) {\n    spdlog::info(\"Entering {}\", __FUNCTION__);\n    INIT_RESULT(result)\n\n    result[\"IsExist\"] = false;\n\n    try {\n        shared_ptr <string> poly_str_ptr = LevelDB::getLevelDb()->readString(_polyName);\n\n        if (poly_str_ptr != nullptr) {\n            result[\"IsExist\"] = true;\n        }\n    } HANDLE_SGX_EXCEPTION(result)\n\n    RETURN_SUCCESS(result);\n}\n\nJson::Value SGXWalletServer::getServerStatusImpl() {\n    INIT_RESULT(result)\n    RETURN_SUCCESS(result)\n}\n\nJson::Value SGXWalletServer::getServerVersionImpl() {\n    INIT_RESULT(result)\n    result[\"version\"] = TOSTRING(SGXWALLET_VERSION);\n    RETURN_SUCCESS(result)\n}\n\nJson::Value SGXWalletServer::deleteBlsKeyImpl(const string &name) {\n    spdlog::info(\"Entering {}\", __FUNCTION__);\n    INIT_RESULT(result)\n\n    result[\"deleted\"] = false;\n    try {\n        if (!checkName(name, \"BLS_KEY\")) {\n            throw SGXException(INVALID_BLS_NAME, \"Invalid BLSKey name format\");\n        }\n        shared_ptr <string> bls_ptr = LevelDB::getLevelDb()->readString(name);\n\n        if (bls_ptr != nullptr) {\n            LevelDB::getLevelDb()->deleteKey(name);\n            result[\"deleted\"] = true;\n        } else {\n            auto error_msg = \"BLS key not found: \" + name;\n            throw SGXException(INVALID_BLS_NAME, error_msg.c_str());\n        }\n    } HANDLE_SGX_EXCEPTION(result)\n\n    RETURN_SUCCESS(result)\n}\n\nJson::Value SGXWalletServer::generateDKGPoly(const string &_polyName, int _t) {\n    return generateDKGPolyImpl(_polyName, _t);\n}\n\nJson::Value SGXWalletServer::getVerificationVector(const string &_polynomeName, int _t, int _n) {\n    return getVerificationVectorImpl(_polynomeName, _t, _n);\n}\n\nJson::Value SGXWalletServer::getSecretShare(const string &_polyName, const Json::Value &_publicKeys, int t, int n) {\n    return getSecretShareImpl(_polyName, _publicKeys, t, n);\n}\n\nJson::Value\nSGXWalletServer::dkgVerification(const string &_publicShares, const string &ethKeyName, const string &SecretShare,\n                                 int t,\n                                 int n, int index) {\n    return dkgVerificationImpl(_publicShares, ethKeyName, SecretShare, t, n, index);\n}\n\nJson::Value\nSGXWalletServer::createBLSPrivateKey(const string &blsKeyName, const string &ethKeyName, const string &polyName,\n                                     const string &SecretShare, int t, int n) {\n    return createBLSPrivateKeyImpl(blsKeyName, ethKeyName, polyName, SecretShare, t, n);\n}\n\nJson::Value SGXWalletServer::getBLSPublicKeyShare(const string &blsKeyName) {\n    return getBLSPublicKeyShareImpl(blsKeyName);\n}\n\nJson::Value SGXWalletServer::calculateAllBLSPublicKeys(const Json::Value& publicShares, int t, int n) {\n    return calculateAllBLSPublicKeysImpl(publicShares, t, n);\n}\n\nJson::Value SGXWalletServer::generateECDSAKey() {\n    return generateECDSAKeyImpl();\n}\n\nJson::Value SGXWalletServer::getPublicECDSAKey(const string &_keyName) {\n    return getPublicECDSAKeyImpl(_keyName);\n}\n\nJson::Value SGXWalletServer::ecdsaSignMessageHash(int _base, const string &_keyShareName, const string &_messageHash) {\n    return ecdsaSignMessageHashImpl(_base, _keyShareName, _messageHash);\n}\n\nJson::Value\nSGXWalletServer::importBLSKeyShare(const string &_keyShare, const string &_keyShareName) {\n    return importBLSKeyShareImpl(_keyShare, _keyShareName);\n}\n\nJson::Value SGXWalletServer::blsSignMessageHash(const string &_keyShareName, const string &_messageHash, int _t, int _n) {\n    return blsSignMessageHashImpl(_keyShareName, _messageHash, _t, _n);\n}\n\nJson::Value SGXWalletServer::complaintResponse(const string &polyName, int ind) {\n    return complaintResponseImpl(polyName, ind);\n}\n\nJson::Value SGXWalletServer::multG2(const string &x) {\n    return multG2Impl(x);\n}\n\nJson::Value SGXWalletServer::isPolyExists(const string &polyName) {\n    return isPolyExistsImpl(polyName);\n}\n\nJson::Value SGXWalletServer::getServerStatus() {\n    return getServerStatusImpl();\n}\n\nJson::Value SGXWalletServer::getServerVersion() {\n    return getServerVersionImpl();\n}\n\nJson::Value SGXWalletServer::deleteBlsKey(const string &name) {\n    return deleteBlsKeyImpl(name);\n}\n\nshared_ptr <string> SGXWalletServer::readFromDb(const string &name, const string &prefix) {\n    auto dataStr = LevelDB::getLevelDb()->readString(prefix + name);\n\n    if (dataStr == nullptr) {\n        throw SGXException(KEY_SHARE_DOES_NOT_EXIST, \"Data with this name does not exist\");\n    }\n\n    return dataStr;\n}\n\nvoid SGXWalletServer::writeKeyShare(const string &_keyShareName, const string &_value) {\n    if (LevelDB::getLevelDb()->readString(_keyShareName) != nullptr) {\n        throw SGXException(KEY_SHARE_ALREADY_EXISTS, \"Key share with this name already exists\");\n    }\n\n    LevelDB::getLevelDb()->writeString(_keyShareName, _value);\n}\n\nvoid SGXWalletServer::writeDataToDB(const string &name, const string &value) {\n    if (LevelDB::getLevelDb()->readString(name) != nullptr) {\n        throw SGXException(KEY_NAME_ALREADY_EXISTS, \"Name already exists\");\n    }\n\n    LevelDB::getLevelDb()->writeString(name, value);\n}\n", "/*\n    Copyright (C) 2019-Present SKALE Labs\n\n    This file is part of sgxwallet.\n\n    sgxwallet is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    sgxwallet is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with sgxwallet.  If not, see <https://www.gnu.org/licenses/>.\n\n    @file AESUtils.c\n    @author Stan Kladko\n    @date 2020\n*/\n\n\n#include \"sgx_trts.h\"\n#include \"sgx_tcrypto.h\"\n#include \"stdlib.h\"\n#include <string.h>\n\n#include \"AESUtils.h\"\n\nsgx_aes_gcm_128bit_key_t AES_key;\nsgx_aes_gcm_128bit_key_t AES_DH_key;\n\nint AES_encrypt(char *message, uint8_t *encr_message, uint64_t encrLen) {\n\n    if (!message) {\n        LOG_ERROR(\"Null message in AES_encrypt\");\n        return -1;\n    }\n\n    if (!encr_message) {\n        LOG_ERROR(\"Null encr message in AES_encrypt\");\n        return -2;\n    }\n\n    uint64_t len = strlen(message) + 1;\n\n    if (len + SGX_AESGCM_MAC_SIZE + SGX_AESGCM_IV_SIZE > encrLen ) {\n        LOG_ERROR(\"Output buffer too small\");\n        return -3;\n    }\n\n    sgx_read_rand(encr_message + SGX_AESGCM_MAC_SIZE, SGX_AESGCM_IV_SIZE);\n\n    sgx_status_t status = sgx_rijndael128GCM_encrypt(&AES_key, (uint8_t*)message, strlen(message),\n                                                     encr_message + SGX_AESGCM_MAC_SIZE + SGX_AESGCM_IV_SIZE,\n                                                     encr_message + SGX_AESGCM_MAC_SIZE, SGX_AESGCM_IV_SIZE,\n                                                     NULL, 0,\n                                                     (sgx_aes_gcm_128bit_tag_t *) encr_message);\n\n    return status;\n}\n\nint AES_decrypt(uint8_t *encr_message, uint64_t length, char *message, uint64_t msgLen) {\n\n    if (!message) {\n        LOG_ERROR(\"Null message in AES_encrypt\");\n        return -1;\n    }\n\n    if (!encr_message) {\n        LOG_ERROR(\"Null encr message in AES_encrypt\");\n        return -2;\n    }\n\n\n  if (length < SGX_AESGCM_MAC_SIZE + SGX_AESGCM_IV_SIZE) {\n      LOG_ERROR(\"length < SGX_AESGCM_MAC_SIZE - SGX_AESGCM_IV_SIZE\");\n      return -1;\n  }\n\n\n\n  uint64_t len = length - SGX_AESGCM_MAC_SIZE - SGX_AESGCM_IV_SIZE;\n\n  if (msgLen < len) {\n        LOG_ERROR(\"Output buffer not large enough\");\n        return -2;\n  }\n\n  sgx_status_t status = sgx_rijndael128GCM_decrypt(&AES_key,\n                                                   encr_message + SGX_AESGCM_MAC_SIZE + SGX_AESGCM_IV_SIZE, len,\n                                                   (unsigned char*) message,\n                                                   encr_message + SGX_AESGCM_MAC_SIZE, SGX_AESGCM_IV_SIZE,\n                                                   NULL, 0,\n                                                   (sgx_aes_gcm_128bit_tag_t *)encr_message);\n\n  return status;\n}\n\n\n\n\nint AES_encrypt_DH(char *message, uint8_t *encr_message, uint64_t encrLen) {\n\n    if (!message) {\n        LOG_ERROR(\"Null message in AES_encrypt_DH\");\n        return -1;\n    }\n\n    if (!encr_message) {\n        LOG_ERROR(\"Null encr message in AES_encrypt_DH\");\n        return -2;\n    }\n\n    uint64_t len = strlen(message) + 1;\n\n    if (len + SGX_AESGCM_MAC_SIZE + SGX_AESGCM_IV_SIZE > encrLen ) {\n        LOG_ERROR(\"Output buffer too small\");\n        return -3;\n    }\n\n    sgx_read_rand(encr_message + SGX_AESGCM_MAC_SIZE, SGX_AESGCM_IV_SIZE);\n\n    sgx_status_t status = sgx_rijndael128GCM_encrypt(&AES_DH_key, (uint8_t*)message, strlen(message),\n                                                     encr_message + SGX_AESGCM_MAC_SIZE + SGX_AESGCM_IV_SIZE,\n                                                     encr_message + SGX_AESGCM_MAC_SIZE, SGX_AESGCM_IV_SIZE,\n                                                     NULL, 0,\n                                                     (sgx_aes_gcm_128bit_tag_t *) encr_message);\n\n    return status;\n}\n\nint AES_decrypt_DH(uint8_t *encr_message, uint64_t length, char *message, uint64_t msgLen) {\n\n    if (!message) {\n        LOG_ERROR(\"Null message in AES_encrypt_DH\");\n        return -1;\n    }\n\n    if (!encr_message) {\n        LOG_ERROR(\"Null encr message in AES_encrypt_DH\");\n        return -2;\n    }\n\n\n    if (length < SGX_AESGCM_MAC_SIZE + SGX_AESGCM_IV_SIZE) {\n        LOG_ERROR(\"length < SGX_AESGCM_MAC_SIZE - SGX_AESGCM_IV_SIZE\");\n        return -1;\n    }\n\n\n\n    uint64_t len = length - SGX_AESGCM_MAC_SIZE - SGX_AESGCM_IV_SIZE;\n\n    if (msgLen < len) {\n        LOG_ERROR(\"Output buffer not large enough\");\n        return -2;\n    }\n\n    sgx_status_t status = sgx_rijndael128GCM_decrypt(&AES_DH_key,\n                                                     encr_message + SGX_AESGCM_MAC_SIZE + SGX_AESGCM_IV_SIZE, len,\n                                                     (unsigned char*) message,\n                                                     encr_message + SGX_AESGCM_MAC_SIZE, SGX_AESGCM_IV_SIZE,\n                                                     NULL, 0,\n                                                     (sgx_aes_gcm_128bit_tag_t *)encr_message);\n\n    return status;\n}\n\n\n\n\n\n\nvoid derive_DH_Key() {\n    memcpy(AES_DH_key, AES_key, SGX_AESGCM_KEY_SIZE );\n    /*AES_DH_key[1] = 1;AES_DH_key[2] = 2;*/\n}\n\n", "/*\n    Copyright (C) 2019-Present SKALE Labs\n\n    This file is part of sgxwallet.\n\n    sgxwallet is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    sgxwallet is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with sgxwallet.  If not, see <https://www.gnu.org/licenses/>.\n\n    @file AESUtils.h\n    @author Stan Kladko\n    @date 2020\n*/\n\n#ifndef SGXD_AESUTILS_H\n#define SGXD_AESUTILS_H\n\nextern sgx_aes_gcm_128bit_key_t AES_key;\nextern sgx_aes_gcm_128bit_key_t AES_DH_key;\n\nint AES_encrypt(char *message, uint8_t *encr_message, uint64_t encrLen);\nint AES_decrypt(uint8_t *encr_message, uint64_t length, char *message, uint64_t msgLen) ;\n\nint AES_encrypt_DH(char *message, uint8_t *encr_message, uint64_t encrLen);\nint AES_decrypt_DH(uint8_t *encr_message, uint64_t length, char *message, uint64_t msgLen) ;\n\nvoid derive_DH_Key();\n\n\n#endif //SGXD_AESUTILS_H\n", "/*\n\nModifications Copyright (C) 2019-2020 SKALE Labs\n\nCopyright 2018 Intel Corporation\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\n1. Redistributions of source code must retain the above copyright\nnotice, this list of conditions and the following disclaimer.\n\n2. Redistributions in binary form must reproduce the above copyright\nnotice, this list of conditions and the following disclaimer in the\ndocumentation and/or other materials provided with the distribution.\n\n3. Neither the name of the copyright holder nor the names of its\ncontributors may be used to endorse or promote products derived from\nthis software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\nIS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED\nTO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A\nPARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nHOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED\nTO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\nPROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\nLIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\nNEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n*/\n\n#include <math.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdbool.h>\n#include <assert.h>\n\n#include \"secure_enclave_t.h\"\n#include \"sgx_tcrypto.h\"\n#include \"sgx_tseal.h\"\n#include <sgx_tgmp.h>\n#include <sgx_trts.h>\n\n#include <sgx_key.h>\n\n#include \"Point.h\"\n#include \"DomainParameters.h\"\n\n#include \"Signature.h\"\n#include \"Curves.h\"\n#include \"DHDkg.h\"\n#include \"AESUtils.h\"\n\n#include \"EnclaveConstants.h\"\n#include \"EnclaveCommon.h\"\n#include \"SIGNED_ENCLAVE_VERSION\"\n\n\n#define STRINGIFY(x) #x\n#define TOSTRING(x) STRINGIFY(x)\n\n#define INIT_ERROR_STATE *errString = 0; *errStatus = UNKNOWN_ERROR;\n#define SET_SUCCESS *errStatus = 0;\n\n\n#define CHECK_STATE(_EXPRESSION_) \\\n    if (!(_EXPRESSION_)) {        \\\n        LOG_ERROR(\"State check failed::\");LOG_ERROR(#_EXPRESSION_); \\\n        LOG_ERROR((const char*) __FILE__); \\\n        snprintf(errString, BUF_LEN, \"State check failed. Check log.\"); \\\n        *errStatus = -1;                          \\\n        return;}\n\n#define CHECK_STATE_CLEAN(_EXPRESSION_) \\\n    if (!(_EXPRESSION_)) {        \\\n        LOG_ERROR(\"State check failed::\");LOG_ERROR(#_EXPRESSION_); \\\n        LOG_ERROR(__FILE__); LOG_ERROR(__LINE__);                   \\\n        snprintf(errString, BUF_LEN, \"State check failed. Check log.\"); \\\n        *errStatus = -1;                          \\\n        goto clean;}\n\n#define CHECK_STATUS(__ERRMESSAGE__) if (status != SGX_SUCCESS) { \\\nLOG_ERROR(__FUNCTION__); \\\nsnprintf(errString, BUF_LEN, \"failed with status %d : %s\",  status,  __ERRMESSAGE__); \\\nLOG_ERROR(errString); \\\n*errStatus = status; \\\ngoto clean; \\\n};\n\n\n#define CHECK_STATUS2(__ERRMESSAGE__) if (status != SGX_SUCCESS) { \\\nsnprintf(errString, BUF_LEN, __ERRMESSAGE__, status); \\\nLOG_ERROR(errString); \\\n*errStatus = status; \\\ngoto clean; \\\n};\n\nvoid *(*gmp_realloc_func)(void *, size_t, size_t);\n\nvoid *(*oc_realloc_func)(void *, size_t, size_t);\n\nvoid (*gmp_free_func)(void *, size_t);\n\nvoid (*oc_free_func)(void *, size_t);\n\nvoid *reallocate_function(void *, size_t, size_t);\n\nvoid free_function(void *, size_t);\n\nunsigned char *globalRandom = NULL;\n\n\n#define CALL_ONCE \\\n    static volatile bool called = false;\\\n    if (called)  { \\\n        LOG_ERROR(__FUNCTION__); \\\n        LOG_ERROR(\"This function shouldnt be called twice. Aborting!\"); \\\n        abort(); \\\n    } else {called = true;};\n\nvoid trustedEnclaveInit(uint32_t _logLevel) {\n    CALL_ONCE\n    LOG_INFO(__FUNCTION__);\n\n    globalLogLevel_ = _logLevel;\n\n    oc_realloc_func = &reallocate_function;\n    oc_free_func = &free_function;\n\n    LOG_INFO(\"Setting memory functions\");\n\n    mp_get_memory_functions(NULL, &gmp_realloc_func, &gmp_free_func);\n    mp_set_memory_functions(NULL, oc_realloc_func, oc_free_func);\n\n    LOG_INFO(\"Calling enclave init\");\n\n\n    enclave_init();\n\n\n    LOG_INFO(\"Reading random\");\n\n    globalRandom = calloc(32,1);\n\n    int ret = sgx_read_rand(globalRandom, 32);\n\n    if(ret != SGX_SUCCESS)\n    {\n        LOG_ERROR(\"sgx_read_rand failed. Aboring enclave.\");\n        abort();\n    }\n\n    LOG_INFO(\"Successfully inited enclave. Signed enclave version:\" SIGNED_ENCLAVE_VERSION );\n#ifndef SGX_DEBUG\n    LOG_INFO(\"SECURITY WARNING: sgxwallet is running in INSECURE DEBUG MODE! NEVER USE IN PRODUCTION!\");\n#endif\n\n#if SGX_DEBUG != 0\n    LOG_INFO(\"SECURITY WARNING: sgxwallet is running in INSECURE DEBUG MODE! NEVER USE IN PRODUCTION!\");\n#endif\n\n#if SGX_MODE == SIM\n    LOG_INFO(\"SECURITY WARNING: sgxwallet is running in INSECURE SIMULATION MODE! NEVER USE IN PRODUCTION!\");\n#endif\n\n\n\n\n\n\n}\n\nvoid free_function(void *ptr, size_t sz) {\n    if (sgx_is_within_enclave(ptr, sz))\n        gmp_free_func(ptr, sz);\n    else {\n        sgx_status_t status;\n\n        status = oc_free(ptr, sz);\n        if (status != SGX_SUCCESS)\n            abort();\n    }\n}\n\nvoid *reallocate_function(void *ptr, size_t osize, size_t nsize) {\n    uint64_t nptr;\n    sgx_status_t status;\n\n    if (sgx_is_within_enclave(ptr, osize)) {\n        return gmp_realloc_func(ptr, osize, nsize);\n    }\n\n    status = oc_realloc(&nptr, ptr, osize, nsize);\n    if (status != SGX_SUCCESS)\n        abort();\n\n    /*\n     * If the entire range of allocated memory is not outside the enclave\n     * then something truly terrible has happened. In theory, we could\n     * free() and try again, but would you trust the OS at this point?\n     */\n\n    if (!sgx_is_outside_enclave((void *) ptr, nsize))\n        abort();\n\n    return (void *) nptr;\n}\n\nvoid get_global_random(unsigned char *_randBuff, uint64_t _size) {\n    char errString[BUF_LEN];\n    int status;\n    int *errStatus = &status;\n\n    INIT_ERROR_STATE\n\n    CHECK_STATE(_size <= 32)\n    CHECK_STATE(_randBuff);\n\n    sgx_sha_state_handle_t shaStateHandle;\n\n    CHECK_STATE(sgx_sha256_init(&shaStateHandle) == SGX_SUCCESS);\n    CHECK_STATE(sgx_sha256_update(globalRandom, 32, shaStateHandle) == SGX_SUCCESS);\n    CHECK_STATE(sgx_sha256_get_hash(shaStateHandle, (sgx_sha256_hash_t *)globalRandom) == SGX_SUCCESS);\n    CHECK_STATE(sgx_sha256_close(shaStateHandle) == SGX_SUCCESS);\n\n    memcpy(_randBuff, globalRandom, _size);\n}\n\n\nvoid sealHexSEK(int *errStatus, char *errString,\n                        uint8_t *encrypted_sek, uint32_t *enc_len, char *sek_hex) {\n    CALL_ONCE\n    LOG_INFO(__FUNCTION__);\n    INIT_ERROR_STATE\n\n    CHECK_STATE(encrypted_sek);\n    CHECK_STATE(sek_hex);\n    CHECK_STATE(strnlen(sek_hex, 33) == 32)\n    \n\n    uint64_t plaintextLen = strlen(sek_hex) + 1;\n    \n    uint64_t sealedLen = sgx_calc_sealed_data_size(0, plaintextLen);\n\n    sgx_attributes_t attribute_mask;\n    attribute_mask.flags = 0xfffffffffffffff3;\n    attribute_mask.xfrm = 0x0;\n    sgx_misc_select_t misc = 0xF0000000;\n\n    sgx_status_t status = sgx_seal_data_ex(SGX_KEYPOLICY_MRENCLAVE, attribute_mask, misc, 0, NULL, plaintextLen, (uint8_t *) sek_hex, sealedLen,\n                                           (sgx_sealed_data_t *) encrypted_sek);\n    CHECK_STATUS(\"seal SEK failed after SEK generation\");\n\n    uint32_t encrypt_text_length = sgx_get_encrypt_txt_len((const sgx_sealed_data_t *)encrypted_sek);\n\n    CHECK_STATE(encrypt_text_length = plaintextLen);\n\n\n    SAFE_CHAR_BUF(unsealedKey, BUF_LEN);\n    uint32_t decLen = BUF_LEN;\n\n    uint32_t add_text_length = sgx_get_add_mac_txt_len((const sgx_sealed_data_t *)encrypted_sek);\n    CHECK_STATE(add_text_length == 0);\n    CHECK_STATE(sgx_is_within_enclave(encrypted_sek,sizeof(sgx_sealed_data_t)));\n    status = sgx_unseal_data((const sgx_sealed_data_t *)encrypted_sek, NULL, NULL,\n                             (uint8_t *) unsealedKey, &decLen );\n\n    CHECK_STATUS(\"seal/unseal SEK failed after SEK generation in unseal\");\n    *enc_len = sealedLen;\n\n    SET_SUCCESS\n    clean:\n    LOG_INFO(__FUNCTION__ );\n    LOG_INFO(\"SGX call completed\");\n}\n\nvoid trustedGenerateSEK(int *errStatus, char *errString,\n                        uint8_t *encrypted_sek, uint32_t *enc_len, char *sek_hex) {\n    CALL_ONCE\n    LOG_INFO(__FUNCTION__);\n    INIT_ERROR_STATE\n\n\n    CHECK_STATE(encrypted_sek);\n    CHECK_STATE(sek_hex);\n\n    RANDOM_CHAR_BUF(SEK_raw, SGX_AESGCM_KEY_SIZE);\n\n    carray2Hex((uint8_t*) SEK_raw, SGX_AESGCM_KEY_SIZE, sek_hex);\n    memcpy(AES_key, SEK_raw, SGX_AESGCM_KEY_SIZE);\n    derive_DH_Key();\n\n    sealHexSEK(errStatus, errString, encrypted_sek, enc_len, sek_hex);\n\n    if (*errStatus != 0) {\n        LOG_ERROR(\"sealHexSEK failed\");\n        goto clean;\n    }\n\n    SET_SUCCESS\n    clean:\n    LOG_INFO(__FUNCTION__ );\n    LOG_INFO(\"SGX call completed\");\n}\n\nvoid trustedSetSEK(int *errStatus, char *errString, uint8_t *encrypted_sek) {\n    CALL_ONCE\n    LOG_INFO(__FUNCTION__);\n    INIT_ERROR_STATE\n    CHECK_STATE(encrypted_sek);\n    SAFE_CHAR_BUF(aes_key_hex, BUF_LEN);\n\n    uint32_t dec_len = BUF_LEN;\n\n    sgx_status_t status = sgx_unseal_data(\n            (const sgx_sealed_data_t *) encrypted_sek, NULL, 0,\n            (uint8_t *)aes_key_hex, &dec_len);\n\n    if (status == 0x3001) {\n        LOG_ERROR(\"Could not decrypt LevelDB storage! \\n\"\n                  \"If you upgraded sgxwallet software or if you are restoring from backup, please run sgxwallet with -b flag  and \"\n                  \"pass your backup key.\");\n    }\n\n    CHECK_STATUS2(\"sgx unseal SEK failed with status %d\");\n\n    uint64_t len;\n\n\n    hex2carray(aes_key_hex, &len, (uint8_t *) AES_key);\n    derive_DH_Key();\n\n    SET_SUCCESS\n    clean:\n    LOG_INFO(__FUNCTION__ );\n    LOG_INFO(\"SGX call completed\");\n}\n\nvoid trustedSetSEK_backup(int *errStatus, char *errString,\n                          uint8_t *encrypted_sek, uint32_t *enc_len, const char *sek_hex) {\n    CALL_ONCE\n    LOG_INFO(__FUNCTION__);\n    INIT_ERROR_STATE\n\n    CHECK_STATE(encrypted_sek);\n    CHECK_STATE(sek_hex);\n\n    uint64_t len;\n    hex2carray(sek_hex, &len, (uint8_t *) AES_key);\n    derive_DH_Key();\n\n    sealHexSEK(errStatus, errString, encrypted_sek, enc_len, (char *)sek_hex);\n\n    if (*errStatus != 0) {\n        LOG_ERROR(\"sealHexSEK failed\");\n        goto clean;\n    }\n\n    SET_SUCCESS\n    clean:\n    ;\n    LOG_INFO(__FUNCTION__ );\n    LOG_INFO(\"SGX call completed\");\n}\n\n\n\nvoid trustedGenerateEcdsaKeyAES(int *errStatus, char *errString,\n                                uint8_t *encryptedPrivateKey, uint32_t *enc_len, char *pub_key_x, char *pub_key_y) {\n    LOG_INFO(__FUNCTION__);\n    INIT_ERROR_STATE\n\n    CHECK_STATE(encryptedPrivateKey);\n    CHECK_STATE(pub_key_x);\n    CHECK_STATE(pub_key_y);\n\n    RANDOM_CHAR_BUF(rand_char, 32);\n\n    mpz_t seed;\n    mpz_init(seed);\n    mpz_t skey;\n    mpz_init(skey);\n\n    point Pkey = point_init();\n\n    mpz_import(seed, 32, 1, sizeof(rand_char[0]), 0, 0, rand_char);\n\n    mpz_mod(skey, seed, curve->p);\n\n    signature_extract_public_key(Pkey, skey, curve);\n\n    SAFE_CHAR_BUF(arr_x, BUF_LEN);\n    mpz_get_str(arr_x, ECDSA_SKEY_BASE, Pkey->x);\n    int n_zeroes = 64 - strlen(arr_x);\n    for (int i = 0; i < n_zeroes; i++) {\n        pub_key_x[i] = '0';\n    }\n\n    strncpy(pub_key_x + n_zeroes, arr_x, 1024 - n_zeroes);\n\n    SAFE_CHAR_BUF(arr_y, BUF_LEN);\n    mpz_get_str(arr_y, ECDSA_SKEY_BASE, Pkey->y);\n    n_zeroes = 64 - strlen(arr_y);\n    for (int i = 0; i < n_zeroes; i++) {\n        pub_key_y[i] = '0';\n    }\n    strncpy(pub_key_y + n_zeroes, arr_y, 1024 - n_zeroes);\n\n    SAFE_CHAR_BUF(skey_str, ECDSA_SKEY_LEN);SAFE_CHAR_BUF(arr_skey_str, mpz_sizeinbase(skey, ECDSA_SKEY_BASE) + 2);\n    mpz_get_str(arr_skey_str, ECDSA_SKEY_BASE, skey);\n    n_zeroes = 64 - strlen(arr_skey_str);\n    for (int i = 0; i < n_zeroes; i++) {\n        skey_str[i] = '0';\n    }\n    strncpy(skey_str + n_zeroes, arr_skey_str, 65 - n_zeroes);\n    skey_str[ECDSA_SKEY_LEN - 1] = 0;\n    snprintf(errString, BUF_LEN, \"skey len is %d\\n\", (int) strlen(skey_str));\n\n    int status = AES_encrypt((char *) skey_str, encryptedPrivateKey, BUF_LEN);\n    CHECK_STATUS(\"ecdsa private key encryption failed\");\n\n    *enc_len = strlen(skey_str) + SGX_AESGCM_MAC_SIZE + SGX_AESGCM_IV_SIZE;\n\n    status = AES_decrypt(encryptedPrivateKey, *enc_len, skey_str, ECDSA_SKEY_LEN);\n\n    CHECK_STATUS2(\"ecdsa private key decr failed with status %d\");\n\n    SET_SUCCESS\n    clean:\n    mpz_clear(seed);\n    mpz_clear(skey);\n    point_clear(Pkey);\n    LOG_INFO(__FUNCTION__ );\n    LOG_INFO(\"SGX call completed\");\n}\n\nvoid trustedGetPublicEcdsaKeyAES(int *errStatus, char *errString,\n                                 uint8_t *encryptedPrivateKey, uint32_t enc_len, char *pub_key_x, char *pub_key_y) {\n    LOG_DEBUG(__FUNCTION__);\n    INIT_ERROR_STATE\n\n    SAFE_CHAR_BUF(skey, ECDSA_SKEY_LEN);\n\n    mpz_t privateKeyMpz;\n    mpz_init(privateKeyMpz);\n    point pKey = point_init();\n\n    point pKey_test = point_init();\n\n    CHECK_STATE(encryptedPrivateKey);\n    CHECK_STATE(pub_key_x);\n    CHECK_STATE(pub_key_y);\n\n    int status = AES_decrypt(encryptedPrivateKey, enc_len, skey, ECDSA_SKEY_LEN);\n    CHECK_STATUS2(\"AES_decrypt failed with status %d\");\n\n    skey[enc_len - SGX_AESGCM_MAC_SIZE - SGX_AESGCM_IV_SIZE] = '\\0';\n    strncpy(errString, skey, 1024);\n\n    status = mpz_set_str(privateKeyMpz, skey, ECDSA_SKEY_BASE);\n\n    CHECK_STATUS(\"mpz_set_str failed for private key\");\n\n    signature_extract_public_key(pKey, privateKeyMpz, curve);\n\n\n    point_multiplication(pKey_test, privateKeyMpz, curve->G, curve);\n\n    if (!point_cmp(pKey, pKey_test)) {\n        snprintf(errString, BUF_LEN, \"Points are not equal\");\n        LOG_ERROR(errString);\n        *errStatus = -11;\n        goto clean;\n    }\n\n    SAFE_CHAR_BUF(arr_x, BUF_LEN);\n    mpz_get_str(arr_x, ECDSA_SKEY_BASE, pKey->x);\n\n    int n_zeroes = 64 - strlen(arr_x);\n    for (int i = 0; i < n_zeroes; i++) {\n        pub_key_x[i] = '0';\n    }\n\n    strncpy(pub_key_x + n_zeroes, arr_x, 1024 - n_zeroes);\n\n    SAFE_CHAR_BUF(arr_y, BUF_LEN);\n    mpz_get_str(arr_y, ECDSA_SKEY_BASE, pKey->y);\n\n    n_zeroes = 64 - strlen(arr_y);\n    for (int i = 0; i < n_zeroes; i++) {\n        pub_key_y[i] = '0';\n    }\n    strncpy(pub_key_y + n_zeroes, arr_y, 1024 - n_zeroes);\n\n    SET_SUCCESS\n    clean:\n    mpz_clear(privateKeyMpz);\n    point_clear(pKey);\n    point_clear(pKey_test);\n\n    static uint64_t counter = 0;\n\n    if (counter % 1000 == 0) {\n        LOG_INFO(__FUNCTION__);\n        LOG_INFO(\"Thousand SGX calls completed\");\n    }\n\n    counter++;\n\n}\n\nstatic uint64_t sigCounter = 0;\n\nvoid trustedEcdsaSignAES(int *errStatus, char *errString, uint8_t *encryptedPrivateKey, uint32_t enc_len,\n                         const char *hash, char *sigR, char *sigS, uint8_t *sig_v, int base) {\n    LOG_DEBUG(__FUNCTION__);\n\n    INIT_ERROR_STATE\n\n    CHECK_STATE(encryptedPrivateKey);\n    CHECK_STATE(hash);\n    CHECK_STATE(sigR);\n    CHECK_STATE(sigS);\n\n    SAFE_CHAR_BUF(skey, ECDSA_SKEY_LEN);\n\n    mpz_t privateKeyMpz;\n    mpz_init(privateKeyMpz);\n    mpz_t msgMpz;\n    mpz_init(msgMpz);\n    signature sign = signature_init();\n\n    int status = AES_decrypt(encryptedPrivateKey, enc_len, skey, ECDSA_SKEY_LEN);\n\n    CHECK_STATUS2(\"aes decrypt failed with status %d\");\n\n    skey[enc_len - SGX_AESGCM_MAC_SIZE - SGX_AESGCM_IV_SIZE] = '\\0';\n\n    if (mpz_set_str(privateKeyMpz, skey, ECDSA_SKEY_BASE) == -1) {\n        *errStatus = -1;\n        snprintf(errString, BUF_LEN, \"invalid secret key\");\n        LOG_ERROR(errString);\n        goto clean;\n    }\n\n    if (mpz_set_str(msgMpz, hash, 16) == -1) {\n        *errStatus = -1;\n        snprintf(errString, BUF_LEN, \"invalid message hash\");\n        LOG_ERROR(errString);\n        goto clean;\n    }\n\n    signature_sign(sign, msgMpz, privateKeyMpz, curve);\n\n    sigCounter++;\n\n    if (sigCounter % 1000 == 0) {\n\n        point Pkey = point_init();\n\n        signature_extract_public_key(Pkey, privateKeyMpz, curve);\n\n        if (!signature_verify(msgMpz, sign, Pkey, curve)) {\n            *errStatus = -2;\n            snprintf(errString, BUF_LEN, \"signature is not verified! \");\n            point_clear(Pkey);\n            goto clean;\n        }\n\n        point_clear(Pkey);\n    }\n\n    SAFE_CHAR_BUF(arrM, BUF_LEN);\n    mpz_get_str(arrM, 16, msgMpz);\n    snprintf(errString, BUF_LEN, \"message is %s \", arrM);\n\n    SAFE_CHAR_BUF(arrR, BUF_LEN);\n    mpz_get_str(arrR, base, sign->r);\n    strncpy(sigR, arrR, 1024);\n\n    SAFE_CHAR_BUF(arrS, BUF_LEN);\n    mpz_get_str(arrS, base, sign->s);\n    strncpy(sigS, arrS, 1024);\n\n    *sig_v = sign->v;\n\n    SET_SUCCESS\n    clean:\n\n    mpz_clear(privateKeyMpz);\n    mpz_clear(msgMpz);\n    signature_free(sign);\n    LOG_DEBUG(__FUNCTION__ );\n    LOG_DEBUG(\"SGX call completed\");\n}\n\n\nvoid trustedDecryptKeyAES(int *errStatus, char *errString, uint8_t *encryptedPrivateKey,\n                          uint32_t enc_len, char *key) {\n\n    LOG_DEBUG(__FUNCTION__);\n    INIT_ERROR_STATE\n\n    CHECK_STATE(encryptedPrivateKey);\n    CHECK_STATE(key);\n\n    *errStatus = -9;\n\n    int status = AES_decrypt_DH(encryptedPrivateKey, enc_len, key, 3072);\n\n    if (status != 0) {\n        *errStatus = status;\n        snprintf(errString, BUF_LEN, \"aes decrypt failed with status %d\", status);\n        LOG_ERROR(errString);\n        goto clean;\n    }\n\n    *errStatus = -10;\n\n    uint64_t keyLen = strnlen(key, MAX_KEY_LENGTH);\n\n    if (keyLen == MAX_KEY_LENGTH) {\n        snprintf(errString, BUF_LEN, \"Key is not null terminated\");\n        LOG_ERROR(errString);\n        goto clean;\n    }\n\n    SET_SUCCESS\n    clean:\n    ;\n}\n\n\nvoid trustedEncryptKeyAES(int *errStatus, char *errString, const char *key,\n                          uint8_t *encryptedPrivateKey, uint32_t *enc_len) {\n    LOG_INFO(__FUNCTION__);\n\n    *errString = 0;\n    *errStatus = UNKNOWN_ERROR;\n\n    CHECK_STATE(key);\n    CHECK_STATE(encryptedPrivateKey);\n\n    *errStatus = UNKNOWN_ERROR;\n\n    int status = AES_encrypt_DH((char *)key, encryptedPrivateKey, BUF_LEN);\n\n    CHECK_STATUS2(\"AES encrypt failed with status %d\");\n\n    *enc_len = strlen(key) + SGX_AESGCM_MAC_SIZE + SGX_AESGCM_IV_SIZE;\n\n    SAFE_CHAR_BUF(decryptedKey, BUF_LEN);\n\n    status = AES_decrypt_DH(encryptedPrivateKey, *enc_len, decryptedKey, BUF_LEN);\n\n    CHECK_STATUS2(\"trustedDecryptKey failed with status %d\");\n\n    uint64_t decryptedKeyLen = strnlen(decryptedKey, MAX_KEY_LENGTH);\n\n    if (decryptedKeyLen == MAX_KEY_LENGTH) {\n        snprintf(errString, BUF_LEN, \"Decrypted key is not null terminated\");\n        LOG_ERROR(errString);\n        goto clean;\n    }\n\n    *errStatus = -8;\n\n    if (strncmp(key, decryptedKey, MAX_KEY_LENGTH) != 0) {\n        snprintf(errString, BUF_LEN, \"Decrypted key does not match original key\");\n        LOG_ERROR(errString);\n        goto clean;\n    }\n\n    SET_SUCCESS\n    clean:\n    ;\n    LOG_INFO(__FUNCTION__ );\n    LOG_INFO(\"SGX call completed\");\n}\n\n\nvoid trustedBlsSignMessageAES(int *errStatus, char *errString, uint8_t *encryptedPrivateKey,\n                              uint32_t enc_len, char *_hashX,\n                              char *_hashY, char *signature) {\n    LOG_DEBUG(__FUNCTION__);\n    INIT_ERROR_STATE\n\n    CHECK_STATE(encryptedPrivateKey);\n    CHECK_STATE(_hashX);\n    CHECK_STATE(_hashY);\n    CHECK_STATE(signature);\n\n    SAFE_CHAR_BUF(key, BUF_LEN);SAFE_CHAR_BUF(sig, BUF_LEN);\n\n    int status = AES_decrypt(encryptedPrivateKey, enc_len, key, BUF_LEN);\n\n    CHECK_STATUS(\"AES decrypt failed\")\n\n    if (!enclave_sign(key, _hashX, _hashY, sig)) {\n        strncpy(errString, \"Enclave failed to create bls signature\", BUF_LEN);\n        LOG_ERROR(errString);\n        *errStatus = -1;\n        goto clean;\n    }\n\n    strncpy(signature, sig, BUF_LEN);\n\n    if (strnlen(signature, BUF_LEN) < 10) {\n        strncpy(errString, \"Signature too short\", BUF_LEN);\n        LOG_ERROR(errString);\n        *errStatus = -1;\n        goto clean;\n    }\n\n    SET_SUCCESS\n\n    LOG_DEBUG(\"SGX call completed\");\n\n    clean:\n    ;\n    LOG_DEBUG(\"SGX call completed\");\n}\n\nvoid\ntrustedGenDkgSecretAES(int *errStatus, char *errString, uint8_t *encrypted_dkg_secret, uint32_t *enc_len, size_t _t) {\n    LOG_INFO(__FUNCTION__);\n    INIT_ERROR_STATE\n\n    CHECK_STATE(encrypted_dkg_secret);\n\n    SAFE_CHAR_BUF(dkg_secret, DKG_BUFER_LENGTH);\n\n    int status = gen_dkg_poly(dkg_secret, _t);\n\n    CHECK_STATUS(\"gen_dkg_poly failed\")\n\n    status = AES_encrypt(dkg_secret, encrypted_dkg_secret, 3 * BUF_LEN);\n\n    CHECK_STATUS(\"SGX AES encrypt DKG poly failed\");\n\n    *enc_len = strlen(dkg_secret) + SGX_AESGCM_MAC_SIZE + SGX_AESGCM_IV_SIZE;\n\n    SAFE_CHAR_BUF(decr_dkg_secret, DKG_BUFER_LENGTH);\n\n    status = AES_decrypt(encrypted_dkg_secret, *enc_len, decr_dkg_secret,\n                         DKG_BUFER_LENGTH);\n\n    CHECK_STATUS(\"aes decrypt dkg poly failed\");\n\n    if (strcmp(dkg_secret, decr_dkg_secret) != 0) {\n        snprintf(errString, BUF_LEN,\n                 \"encrypted poly is not equal to decrypted poly\");\n        LOG_ERROR(errString);\n        *errStatus = -333;\n        goto clean;\n    }\n\n    SET_SUCCESS\n    clean:\n    ;\n    LOG_INFO(__FUNCTION__ );\n    LOG_INFO(\"SGX call completed\");\n}\n\nvoid\ntrustedDecryptDkgSecretAES(int *errStatus, char *errString, uint8_t *encrypted_dkg_secret,\n                           uint32_t enc_len,\n                           uint8_t *decrypted_dkg_secret) {\n    LOG_INFO(__FUNCTION__);\n    INIT_ERROR_STATE\n\n    CHECK_STATE(encrypted_dkg_secret);\n    CHECK_STATE(decrypted_dkg_secret);\n\n    int status = AES_decrypt(encrypted_dkg_secret, enc_len, (char *) decrypted_dkg_secret,\n                             3072);\n\n    CHECK_STATUS2(\"aes decrypt data - encrypted_dkg_secret failed with status %d\")\n\n    SET_SUCCESS\n\n    clean:\n    ;\n    LOG_INFO(__FUNCTION__ );\n    LOG_INFO(\"SGX call completed\");\n}\n\n\nvoid trustedSetEncryptedDkgPolyAES(int *errStatus, char *errString, uint8_t *encrypted_poly, uint32_t enc_len) {\n    LOG_INFO(__FUNCTION__);\n    INIT_ERROR_STATE\n\n    CHECK_STATE(encrypted_poly);\n\n    memset(getThreadLocalDecryptedDkgPoly(), 0, DKG_BUFER_LENGTH);\n\n    int status = AES_decrypt(encrypted_poly, enc_len, (char *) getThreadLocalDecryptedDkgPoly(),\n                             DKG_BUFER_LENGTH);\n\n    CHECK_STATUS2(\"sgx_unseal_data - encrypted_poly failed with status %d\")\n\n    SET_SUCCESS\n    clean:\n    ;\n    LOG_INFO(__FUNCTION__ );\n    LOG_INFO(\"SGX call completed\");\n}\n\nvoid trustedGetEncryptedSecretShareAES(int *errStatus, char *errString, uint8_t *encrypted_skey, uint32_t *dec_len,\n                                       char *result_str, char *s_shareG2, char *pub_keyB, uint8_t _t, uint8_t _n,\n                                       uint8_t ind) {\n\n    LOG_INFO(__FUNCTION__);\n    INIT_ERROR_STATE\n\n    uint32_t enc_len;\n    int status;\n\n    CHECK_STATE(encrypted_skey);\n    CHECK_STATE(result_str);\n    CHECK_STATE(s_shareG2);\n    CHECK_STATE(pub_keyB);\n\n    LOG_DEBUG(__FUNCTION__);\n\n    SAFE_CHAR_BUF(skey, ECDSA_SKEY_LEN);\n\n    SAFE_CHAR_BUF(pub_key_x, BUF_LEN);SAFE_CHAR_BUF(pub_key_y, BUF_LEN);\n\n    trustedGenerateEcdsaKeyAES(&status, errString, encrypted_skey, &enc_len, pub_key_x, pub_key_y);\n\n    CHECK_STATUS(\"trustedGenerateEcdsaKeyAES failed\");\n\n    status = AES_decrypt(encrypted_skey, enc_len, skey, ECDSA_SKEY_LEN);\n\n    skey[ECDSA_SKEY_LEN - 1] = 0;\n\n    CHECK_STATUS2(\"AES_decrypt failed (in trustedGetEncryptedSecretShareAES) with status %d\");\n\n    *dec_len = enc_len;\n\n    SAFE_CHAR_BUF(common_key, ECDSA_SKEY_LEN);\n\n    status = gen_session_key(skey, pub_keyB, common_key);\n\n    CHECK_STATUS(\"gen_session_key failed\")\n\n    SAFE_CHAR_BUF(s_share, ECDSA_SKEY_LEN);\n\n    status = calc_secret_share(getThreadLocalDecryptedDkgPoly(), s_share, _t, _n, ind);\n    CHECK_STATUS(\"calc secret share failed\")\n\n\n    status = calc_secret_shareG2(s_share, s_shareG2);\n    CHECK_STATUS(\"invalid decr secret share\");\n\n    SAFE_CHAR_BUF(cypher, ECDSA_SKEY_LEN);\n    status=xor_encrypt(common_key, s_share, cypher);\n\n    CHECK_STATUS(\"xor_encrypt failed\")\n\n    strncpy(result_str, cypher, strlen(cypher));\n    strncpy(result_str + strlen(cypher), pub_key_x, strlen(pub_key_x));\n    strncpy(result_str + strlen(pub_key_x) + strlen(pub_key_y), pub_key_y, strlen(pub_key_y));\n\n    SET_SUCCESS\n\n    clean:\n    ;\n    LOG_INFO(__FUNCTION__ );\n    LOG_INFO(\"SGX call completed\");\n}\n\nvoid trustedGetPublicSharesAES(int *errStatus, char *errString, uint8_t *encrypted_dkg_secret, uint32_t enc_len,\n                               char *public_shares,\n                               unsigned _t, unsigned _n) {\n    LOG_INFO(__FUNCTION__);\n\n    INIT_ERROR_STATE\n\n    CHECK_STATE(encrypted_dkg_secret);\n    CHECK_STATE(public_shares);\n    CHECK_STATE(_t <= _n && _n > 0)\n\n    SAFE_CHAR_BUF(decrypted_dkg_secret, DKG_MAX_SEALED_LEN);\n\n    int status = AES_decrypt(encrypted_dkg_secret, enc_len, decrypted_dkg_secret,\n                             DKG_MAX_SEALED_LEN);\n\n    CHECK_STATUS2(\"aes decrypt data - encrypted_dkg_secret failed with status %d\");\n\n    status = calc_public_shares(decrypted_dkg_secret, public_shares, _t) != 0;\n    CHECK_STATUS(\"t does not match polynomial in db\");\n\n    SET_SUCCESS\n\n    clean:\n    ;\n    LOG_INFO(\"SGX call completed\");\n}\n\nvoid trustedDkgVerifyAES(int *errStatus, char *errString, const char *public_shares, const char *s_share,\n                         uint8_t *encryptedPrivateKey, uint64_t enc_len, unsigned _t, int _ind, int *result) {\n    LOG_INFO(__FUNCTION__);\n\n    INIT_ERROR_STATE\n\n    CHECK_STATE(public_shares);\n    CHECK_STATE(s_share);\n    CHECK_STATE(encryptedPrivateKey);\n\n    SAFE_CHAR_BUF(skey, ECDSA_SKEY_LEN);\n\n    mpz_t s;\n    mpz_init(s);\n\n    int status = AES_decrypt(encryptedPrivateKey, enc_len, skey, ECDSA_SKEY_LEN);\n\n    CHECK_STATUS2(\"AES_decrypt failed (in trustedDkgVerifyAES) with status %d\");\n\n    SAFE_CHAR_BUF(encr_sshare, ECDSA_SKEY_LEN);\n\n    strncpy(encr_sshare, s_share, ECDSA_SKEY_LEN - 1);\n\n    SAFE_CHAR_BUF(common_key, ECDSA_SKEY_LEN);\n\n    status = session_key_recover(skey, s_share, common_key);\n\n    CHECK_STATUS(\"session_key_recover failed\");\n\n    SAFE_CHAR_BUF(decr_sshare, ECDSA_SKEY_LEN);\n\n    status=xor_decrypt(common_key, encr_sshare, decr_sshare);\n\n    CHECK_STATUS(\"xor_decrypt failed\")\n\n\n    status  = mpz_set_str(s, decr_sshare, 16);\n    CHECK_STATUS(\"invalid decr secret share\");\n\n    *result = Verification(public_shares, s, _t, _ind);\n\n    SET_SUCCESS\n    clean:\n\n    mpz_clear(s);\n    LOG_INFO(__FUNCTION__ );\n    LOG_INFO(\"SGX call completed\");\n}\n\nvoid trustedCreateBlsKeyAES(int *errStatus, char *errString, const char *s_shares,\n                            uint8_t *encryptedPrivateKey, uint64_t key_len, uint8_t *encr_bls_key,\n                            uint32_t *enc_bls_key_len) {\n\n    LOG_INFO(__FUNCTION__);\n\n    INIT_ERROR_STATE\n\n    CHECK_STATE(s_shares);\n    CHECK_STATE(encryptedPrivateKey);\n    CHECK_STATE(encr_bls_key);\n\n    SAFE_CHAR_BUF(skey, ECDSA_SKEY_LEN);\n\n    mpz_t sum;\n    mpz_init(sum);\n    mpz_set_ui(sum, 0);\n\n    mpz_t q;\n    mpz_init(q);\n    mpz_set_str(q, \"21888242871839275222246405745257275088548364400416034343698204186575808495617\", 10);\n\n    mpz_t bls_key;\n    mpz_init(bls_key);\n\n\n    int status = AES_decrypt(encryptedPrivateKey, key_len, skey, ECDSA_SKEY_LEN);\n    CHECK_STATUS2(\"aes decrypt failed with status %d\");\n\n    skey[ECDSA_SKEY_LEN - 1] = 0;\n\n    int num_shares = strlen(s_shares) / 192;\n\n    for (int i = 0; i < num_shares; i++) { SAFE_CHAR_BUF(encr_sshare, 65);\n        strncpy(encr_sshare, s_shares + 192 * i, 64);\n        encr_sshare[64] = 0;\n\n        SAFE_CHAR_BUF(s_share, 193);\n        strncpy(s_share, s_shares + 192 * i, 192);\n        s_share[192] = 0;\n\n        SAFE_CHAR_BUF(common_key, 65);\n\n        status = session_key_recover(skey, s_share, common_key);\n\n        CHECK_STATUS(\"session_key_recover failed\");\n\n        common_key[64] = 0;\n\n        SAFE_CHAR_BUF(decr_sshare, 65);\n\n        status = xor_decrypt(common_key, encr_sshare, decr_sshare);\n        CHECK_STATUS(\"xor_decrypt failed\");\n\n        decr_sshare[64] = 0;\n\n        mpz_t decr_secret_share;\n        mpz_init(decr_secret_share);\n        if (mpz_set_str(decr_secret_share, decr_sshare, 16) == -1) {\n            *errStatus = 111;\n            snprintf(errString, BUF_LEN, \"invalid decrypted secret share\");\n            LOG_ERROR(errString);\n\n            mpz_clear(decr_secret_share);\n            goto clean;\n        }\n\n        mpz_addmul_ui(sum, decr_secret_share, 1);\n        mpz_clear(decr_secret_share);\n    }\n\n\n    mpz_mod(bls_key, sum, q);\n\n    SAFE_CHAR_BUF(key_share, BLS_KEY_LENGTH);\n\n    SAFE_CHAR_BUF(arr_skey_str, BUF_LEN);\n\n    mpz_get_str(arr_skey_str, 16, bls_key);\n    int n_zeroes = 64 - strlen(arr_skey_str);\n    for (int i = 0; i < n_zeroes; i++) {\n        key_share[i] = '0';\n    }\n    strncpy(key_share + n_zeroes, arr_skey_str, 65 - n_zeroes);\n    key_share[BLS_KEY_LENGTH - 1] = 0;\n\n    status = AES_encrypt(key_share, encr_bls_key, BUF_LEN);\n\n    CHECK_STATUS2(\"aes encrypt bls private key failed with status %d \");\n\n    *enc_bls_key_len = strlen(key_share) + SGX_AESGCM_MAC_SIZE + SGX_AESGCM_IV_SIZE;\n\n    SET_SUCCESS\n    clean:\n\n    mpz_clear(bls_key);\n    mpz_clear(sum);\n    mpz_clear(q);\n    LOG_INFO(__FUNCTION__ );\n    LOG_INFO(\"SGX call completed\");\n}\n\nvoid\ntrustedGetBlsPubKeyAES(int *errStatus, char *errString, uint8_t *encryptedPrivateKey, uint64_t key_len,\n                       char *bls_pub_key) {\n    LOG_DEBUG(__FUNCTION__);\n\n    INIT_ERROR_STATE\n\n    CHECK_STATE(bls_pub_key);\n    CHECK_STATE(encryptedPrivateKey);\n\n    SAFE_CHAR_BUF(skey_hex, ECDSA_SKEY_LEN);\n\n    int status = AES_decrypt(encryptedPrivateKey, key_len, skey_hex, ECDSA_SKEY_LEN);\n\n    CHECK_STATUS2(\"AES decrypt failed %d\");\n\n    skey_hex[ECDSA_SKEY_LEN - 1] = 0;\n\n    status = calc_bls_public_key(skey_hex, bls_pub_key);\n\n    CHECK_STATUS(\"could not calculate bls public key\");\n\n    SET_SUCCESS\n    static uint64_t counter = 0;\n    clean:\n    if (counter % 1000 == 0) {\n        LOG_INFO(__FUNCTION__);\n        LOG_INFO(\"Thousand SGX calls completed\");\n    }\n\n    counter++;\n}\n", "#define ECDSA_SKEY_LEN 65\n#define ECDSA_SKEY_BASE 16\n#define ECDSA_ENCR_LEN 93\n#define ECDSA_BIN_LEN 33\n#define SMALL_BUF_SIZE 1024\n#define VERY_SMALL_BUF_SIZE 512\n#define TINY_BUF_SIZE 256\n\nenclave {\n\n\ttrusted {\n\t\tinclude \"sgx_tgmp.h\"\n\n\t\tpublic void trustedEnclaveInit(uint32_t _logLevel);\n\n\n        public void trustedGenerateSEK(\n                                [out] int *errStatus,\n                                [out, count = SMALL_BUF_SIZE] char *err_string,\n                                [out, count = SMALL_BUF_SIZE] uint8_t *encrypted_SEK,\n                                [out] uint32_t *enc_len,\n                                [out, count = 65] char* hex_SEK);\n\n        public void trustedSetSEK(\n                                [out] int *errStatus,\n                                [out, count = SMALL_BUF_SIZE] char *err_string,\n                                [in, count = SMALL_BUF_SIZE] uint8_t *encrypted_SEK);\n\n        public void trustedSetSEK_backup(\n                                [out] int *errStatus,\n                                [out, count = SMALL_BUF_SIZE] char *err_string,\n                                [out, count = SMALL_BUF_SIZE] uint8_t *encrypted_SEK,\n                                [out] uint32_t *enc_len,\n                                [in, string] const char* SEK_hex);\n\n        public void trustedGenerateEcdsaKeyAES (\n                                [out] int *errStatus,\n                                [out, count = SMALL_BUF_SIZE] char* err_string,\n                                [out, count = SMALL_BUF_SIZE] uint8_t* encrypted_key,\n                                [out] uint32_t *enc_len,\n                                [out, count = SMALL_BUF_SIZE] char * pub_key_x,\n                                [out, count = SMALL_BUF_SIZE] char * pub_key_y);\n\n        public void trustedGetPublicEcdsaKeyAES(\n                                [out] int *errStatus,\n                                [out, count = SMALL_BUF_SIZE] char* err_string,\n                                [in, count = SMALL_BUF_SIZE] uint8_t* encrypted_key,\n                                uint32_t dec_len,\n                                [out, count = SMALL_BUF_SIZE] char * pub_key_x,\n                                [out, count = SMALL_BUF_SIZE] char * pub_key_y);\n\n        public void trustedEcdsaSignAES(\n                                [out] int *errStatus,\n                                [out, count = SMALL_BUF_SIZE] char* err_string,\n                                [in, count = SMALL_BUF_SIZE] uint8_t* encrypted_key,\n                                uint32_t enc_len,\n                                [in, string] const char* hash,\n                                [out, count = SMALL_BUF_SIZE] char* sig_r,\n                                [out, count = SMALL_BUF_SIZE] char* sig_s,\n                                [out] uint8_t* sig_v,\n                                int base);\n\n        public void trustedEncryptKeyAES (\n                                [out] int *errStatus,\n                                [out, count = SMALL_BUF_SIZE] char* err_string,\n                                [in, count = SMALL_BUF_SIZE] const char* key,\n                                [out, count = SMALL_BUF_SIZE] uint8_t* encrypted_key,\n                                [out] uint32_t *enc_len);\n\n        public void trustedDecryptKeyAES (\n                                [out] int *errStatus,\n                                [out, count = SMALL_BUF_SIZE] char* err_string,\n                                [in, count = SMALL_BUF_SIZE] uint8_t* encrypted_key,\n                                uint32_t enc_len,\n                                [out, count = SMALL_BUF_SIZE] char* key );\n\n        public void trustedGenDkgSecretAES (\n                                [out] int *errStatus,\n                                [out, count = SMALL_BUF_SIZE] char* err_string,\n                                [out, count = 3072] uint8_t* encrypted_dkg_secret,\n                                [out] uint32_t * enc_len, size_t _t);\n\n        public void trustedDecryptDkgSecretAES (\n                                [out] int *errStatus,\n                                [out, count = SMALL_BUF_SIZE] char* err_string,\n                                [in, count = 3050] uint8_t* encrypted_dkg_secret,\n                                uint32_t enc_len,\n                                [out, count = 3072] uint8_t* decrypted_dkg_secret\n                                );\n\n        public void trustedSetEncryptedDkgPolyAES(\n                                [out] int *errStatus,\n                                [out, count = SMALL_BUF_SIZE] char* err_string,\n                                [in, count = 3050] uint8_t* encrypted_poly,\n                                uint32_t enc_len);\n\n        public void trustedGetEncryptedSecretShareAES(\n                                [out]int *errStatus,\n                                [out, count = SMALL_BUF_SIZE] char *err_string,\n                                [out, count = SMALL_BUF_SIZE] uint8_t *encrypted_skey,\n                                [out] uint32_t* dec_len,\n                                [out, count = 193] char* result_str,\n                                [out, count = 320] char* s_shareG2,\n                                [in, string] char* pub_keyB,\n                                uint8_t _t,\n                                uint8_t _n,\n                                uint8_t ind);\n\n        public void trustedGetPublicSharesAES(\n                                [out] int *errStatus,\n                                [out, count = SMALL_BUF_SIZE] char* err_string,\n                                [in, count = 3050] uint8_t* encrypted_dkg_secret,\n                                uint32_t enc_len,\n                                [out, count = 10000] char* public_shares,\n                                unsigned _t,\n                                unsigned _n);\n\n        public void trustedDkgVerifyAES(\n                                [out] int *errStatus,\n                                [out, count = SMALL_BUF_SIZE] char* err_string,\n                                [in, string] const char* public_shares,\n                                [in, string] const char* s_share,\n                                [in, count = SMALL_BUF_SIZE] uint8_t* encrypted_key,\n                                uint64_t key_len,\n                                unsigned _t,\n                                int _ind,\n                                [out] int* result);\n\n        public void trustedCreateBlsKeyAES(\n                                [out]int *errStatus,\n                                [out, count = SMALL_BUF_SIZE] char* err_string,\n                                [in, count = 6145] const char* s_shares,\n                                [in, count = SMALL_BUF_SIZE] uint8_t* encrypted_key,\n                                uint64_t key_len,\n                                [out, count = SMALL_BUF_SIZE] uint8_t * encr_bls_key,\n                                [out] uint32_t *enc_bls_key_len);\n\n        public void trustedBlsSignMessageAES (\n                                [out] int *errStatus,\n                                [out, count = TINY_BUF_SIZE] char* err_string,\n                                [in, count = TINY_BUF_SIZE] uint8_t* encrypted_key,\n                                uint32_t enc_len,\n                                [in, string] char* hashX ,\n                                [in, string] char* hashY,\n                                [out, count = SMALL_BUF_SIZE] char* signature);\n\n        public void trustedGetBlsPubKeyAES(\n                                [out]int *errStatus,\n                                [out, count = SMALL_BUF_SIZE]  char* err_string,\n                                [in, count = SMALL_BUF_SIZE] uint8_t* encrypted_key,\n                                uint64_t key_len,\n                                [out, count = 320] char* bls_pub_key);\n\t};\n\n\tuntrusted {\n\t\tinclude \"gmp.h\"\n\n\t\tuint64_t oc_realloc([user_check] void *optr, size_t osz, size_t nsz);\n\t\tvoid oc_printf([in, string] const char *str);\n\t\tvoid oc_free([user_check] void *optr, size_t sz);\n\t};\n};\n", "/*\n    Copyright (C) 2019-Present SKALE Labs\n\n    This file is part of sgxwallet.\n\n    sgxwallet is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    sgxwallet is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with sgxwallet.  If not, see <https://www.gnu.org/licenses/>.\n\n    @file testw.cpp\n    @author Stan Kladko\n    @date 2020\n*/\n\n#include <libff/algebra/fields/fp.hpp>\n#include <dkg/dkg.h>\n#include <jsonrpccpp/server/connectors/httpserver.h>\n#include <libff/algebra/curves/alt_bn128/alt_bn128_pp.hpp>\n#include <libff/algebra/exponentiation/exponentiation.hpp>\n#include <libff/algebra/fields/fp.hpp>\n#include <dkg/dkg.h>\n#include \"sgxwallet_common.h\"\n#include \"third_party/intel/create_enclave.h\"\n#include \"secure_enclave_u.h\"\n#include \"third_party/intel/sgx_detect.h\"\n#include <gmp.h>\n#include <sgx_urts.h>\n#include <stdio.h>\n#include <jsonrpccpp/client/connectors/httpclient.h>\n#include <sgx_tcrypto.h>\n\n#include \"BLSCrypto.h\"\n#include \"ServerInit.h\"\n#include \"DKGCrypto.h\"\n#include \"SGXException.h\"\n#include \"LevelDB.h\"\n#include \"SGXWalletServer.hpp\"\n\n#define CATCH_CONFIG_MAIN\n\n#include \"catch.hpp\"\n#include \"stubclient.h\"\n#include \"BLSSigShare.h\"\n#include \"BLSSigShareSet.h\"\n#include \"BLSPublicKeyShare.h\"\n#include \"BLSPublicKey.h\"\n#include \"SEKManager.h\"\n#include <thread>\n#include \"common.h\"\n\n#include \"SGXRegistrationServer.h\"\n#include \"SGXWalletServer.h\"\n#include \"sgxwallet.h\"\n#include \"TestUtils.h\"\n#include \"testw.h\"\n\n#define PRINT_SRC_LINE cerr << \"Executing line \" <<  to_string(__LINE__) << endl;\n\n\nusing namespace jsonrpc;\nusing namespace std;\n\nclass TestFixture {\npublic:\n    TestFixture() {\n        TestUtils::resetDB();\n        setOptions(L_INFO, false, true);\n        initAll(L_INFO, false, true);\n    }\n\n    ~TestFixture() {\n        TestUtils::destroyEnclave();\n    }\n};\n\nclass TestFixtureHTTPS {\npublic:\n    TestFixtureHTTPS() {\n        TestUtils::resetDB();\n        setOptions(L_INFO, true, true);\n        initAll(L_INFO, false, true);\n    }\n\n    ~TestFixtureHTTPS() {\n        TestUtils::destroyEnclave();\n    }\n};\n\nclass TestFixtureNoResetFromBackup {\npublic:\n    TestFixtureNoResetFromBackup() {\n        setFullOptions(L_INFO, false, true, true);\n        initAll(L_INFO, false, true);\n    }\n\n    ~TestFixtureNoResetFromBackup() {\n        TestUtils::destroyEnclave();\n    }\n};\n\n\nclass TestFixtureNoReset {\npublic:\n    TestFixtureNoReset() {\n        setOptions(L_INFO, false, true);\n        initAll(L_INFO, false, true);\n    }\n\n    ~TestFixtureNoReset() {\n        TestUtils::destroyEnclave();\n    }\n};\n\nTEST_CASE_METHOD(TestFixture, \"ECDSA AES keygen and signature test\", \"[ecdsa-aes-key-sig-gen]\") {\n    vector<char> errMsg(BUF_LEN, 0);\n    int errStatus = 0;\n    vector <uint8_t> encrPrivKey(BUF_LEN, 0);\n    vector<char> pubKeyX(BUF_LEN, 0);\n    vector<char> pubKeyY(BUF_LEN, 0);\n\n    uint32_t encLen = 0;\n    PRINT_SRC_LINE\n    auto status = trustedGenerateEcdsaKeyAES(eid, &errStatus, errMsg.data(), encrPrivKey.data(), &encLen,\n                                             pubKeyX.data(),\n                                             pubKeyY.data());\n    REQUIRE(status == SGX_SUCCESS);\n    REQUIRE(errStatus == SGX_SUCCESS);\n\n    string hex = SAMPLE_HEX_HASH;\n    vector<char> signatureR(BUF_LEN, 0);\n    vector<char> signatureS(BUF_LEN, 0);\n    uint8_t signatureV = 0;\n\n\n    for (int i = 0; i < 50; i++) {\n        PRINT_SRC_LINE\n        status = trustedEcdsaSignAES(eid, &errStatus, errMsg.data(), encrPrivKey.data(), encLen,\n                                     hex.data(),\n                                     signatureR.data(),\n                                     signatureS.data(), &signatureV, 16);\n        REQUIRE(status == SGX_SUCCESS);\n        REQUIRE(errStatus == SGX_SUCCESS);\n    }\n\n}\n\n\nTEST_CASE_METHOD(TestFixture, \"ECDSA AES key gen\", \"[ecdsa-aes-key-gen]\") {\n    vector<char> errMsg(BUF_LEN, 0);\n    int errStatus = 0;\n    vector <uint8_t> encrPrivKey(BUF_LEN, 0);\n    vector<char> pubKeyX(BUF_LEN, 0);\n    vector<char> pubKeyY(BUF_LEN, 0);\n    uint32_t encLen = 0;\n    PRINT_SRC_LINE\n    auto status = trustedGenerateEcdsaKeyAES(eid, &errStatus, errMsg.data(), encrPrivKey.data(), &encLen,\n                                             pubKeyX.data(),\n                                             pubKeyY.data());\n\n    REQUIRE(status == SGX_SUCCESS);\n    REQUIRE(errStatus == SGX_SUCCESS);\n}\n\n\nTEST_CASE_METHOD(TestFixture, \"ECDSA AES get public key\", \"[ecdsa-aes-get-pub-key]\") {\n    int errStatus = 0;\n    vector<char> errMsg(BUF_LEN, 0);\n    vector <uint8_t> encPrivKey(BUF_LEN, 0);\n    vector<char> pubKeyX(BUF_LEN, 0);\n    vector<char> pubKeyY(BUF_LEN, 0);\n    uint32_t encLen = 0;\n\n    PRINT_SRC_LINE\n    auto status = trustedGenerateEcdsaKeyAES(eid, &errStatus, errMsg.data(), encPrivKey.data(), &encLen, pubKeyX.data(),\n                                             pubKeyY.data());\n\n    REQUIRE(status == SGX_SUCCESS);\n    REQUIRE(errStatus == SGX_SUCCESS);\n\n    vector<char> receivedPubKeyX(BUF_LEN, 0);\n    vector<char> receivedPubKeyY(BUF_LEN, 0);\n\n    PRINT_SRC_LINE\n    status = trustedGetPublicEcdsaKeyAES(eid, &errStatus, errMsg.data(), encPrivKey.data(), encLen,\n                                         receivedPubKeyX.data(),\n                                         receivedPubKeyY.data());\n    REQUIRE(status == SGX_SUCCESS);\n    REQUIRE(errStatus == SGX_SUCCESS);\n}\n\n\n/* Do later\nTEST_CASE_METHOD(\"BLS key encrypt/decrypt\", \"[bls-key-encrypt-decrypt]\") {\n    resetDB();\n    setOptions(false, false, false, true);\n    initAll(0, false, true);\n\n    //init_enclave();\n\n    int errStatus = -1;\n\n    vector<char> errMsg(BUF_LEN, 0);\n\n    char *encryptedKey = TestUtils::encryptTestKey();\n    REQUIRE(encryptedKey != nullptr);\n    char *plaintextKey = decryptBLSKeyShareFromHex(&errStatus, errMsg.data(), encryptedKey);\n    free(encryptedKey);\n\n    REQUIRE(errStatus == 0);\n    REQUIRE(strcmp(plaintextKey, TEST_BLS_KEY_SHARE) == 0);\n\n    printf(\"Decrypt key completed with status: %d %s \\n\", errStatus, errMsg.data());\n    printf(\"Decrypted key len %d\\n\", (int) strlen(plaintextKey));\n    printf(\"Decrypted key: %s\\n\", plaintextKey);\n    free(plaintextKey);\n\n\n\n}\n\n*/\n\n\nstring genECDSAKeyAPI(StubClient &_c) {\n    Json::Value genKey = _c.generateECDSAKey();\n    CHECK_STATE(genKey[\"status\"].asInt() == 0);\n    auto keyName = genKey[\"keyName\"].asString();\n    CHECK_STATE(keyName.size() == ECDSA_KEY_NAME_SIZE);\n    return keyName;\n}\n\nTEST_CASE_METHOD(TestFixture, \"ECDSA key gen API\", \"[ecdsa-key-gen-api]\") {\n    HttpClient client(RPC_ENDPOINT);\n    StubClient c(client, JSONRPC_CLIENT_V2);\n\n    for (int i = 0; i <= 20; i++) {\n        try {\n            PRINT_SRC_LINE\n            auto keyName = genECDSAKeyAPI(c);\n            PRINT_SRC_LINE\n            Json::Value sig = c.ecdsaSignMessageHash(16, keyName, SAMPLE_HASH);\n            REQUIRE(sig[\"status\"].asInt() == 0);\n            Json::Value getPubKey = c.getPublicECDSAKey(keyName);\n            REQUIRE(getPubKey[\"status\"].asInt() == 0);\n        } catch (JsonRpcException &e) {\n            cerr << e.what() << endl;\n            throw;\n        }\n    }\n\n    auto keyName = genECDSAKeyAPI(c);\n\n\n    Json::Value sig = c.ecdsaSignMessageHash(10, keyName, SAMPLE_HASH);\n\n\n    for (int i = 0; i <= 20; i++) {\n        try {\n            PRINT_SRC_LINE\n            auto keyName = genECDSAKeyAPI(c);\n            PRINT_SRC_LINE\n            Json::Value sig = c.ecdsaSignMessageHash(10, keyName, SAMPLE_HASH);\n            REQUIRE(sig[\"status\"].asInt() == 0);\n            PRINT_SRC_LINE\n            Json::Value getPubKey = c.getPublicECDSAKey(keyName);\n            REQUIRE(getPubKey[\"status\"].asInt() == 0);\n        } catch (JsonRpcException &e) {\n            cerr << e.what() << endl;\n            throw;\n        }\n    }\n}\n\nTEST_CASE_METHOD(TestFixture, \"BLS key encrypt\", \"[bls-key-encrypt]\") {\n    auto key = TestUtils::encryptTestKey();\n    REQUIRE(key != nullptr);\n}\n\n\nTEST_CASE_METHOD(TestFixture, \"DKG AES gen test\", \"[dkg-aes-gen]\") {\n    vector <uint8_t> encryptedDKGSecret(BUF_LEN, 0);\n    vector<char> errMsg(BUF_LEN, 0);\n\n    int errStatus = 0;\n    uint32_t encLen = 0;\n\n    PRINT_SRC_LINE\n    auto status = trustedGenDkgSecretAES(eid, &errStatus, errMsg.data(), encryptedDKGSecret.data(), &encLen, 32);\n    REQUIRE(status == SGX_SUCCESS);\n    REQUIRE(errStatus == SGX_SUCCESS);\n\n    vector<char> secret(BUF_LEN, 0);\n    vector<char> errMsg1(BUF_LEN, 0);\n\n    status = trustedDecryptDkgSecretAES(eid, &errStatus, errMsg1.data(), encryptedDKGSecret.data(),\n                                        encLen, (uint8_t *) secret.data());\n\n    REQUIRE(status == SGX_SUCCESS);\n    REQUIRE(errStatus == SGX_SUCCESS);\n}\n\n\nTEST_CASE_METHOD(TestFixture, \"DKG AES public shares test\", \"[dkg-aes-pub-shares]\") {\n    vector <uint8_t> encryptedDKGSecret(BUF_LEN, 0);\n    vector<char> errMsg(BUF_LEN, 0);\n\n    int errStatus = 0;\n    uint32_t encLen = 0;\n\n    unsigned t = 32, n = 32;\n    PRINT_SRC_LINE\n    auto status = trustedGenDkgSecretAES(eid, &errStatus, errMsg.data(), encryptedDKGSecret.data(), &encLen, n);\n    REQUIRE(status == SGX_SUCCESS);\n    REQUIRE(errStatus == SGX_SUCCESS);\n\n    vector<char> errMsg1(BUF_LEN, 0);\n\n    char colon = ':';\n    vector<char> pubShares(10000, 0);\n    PRINT_SRC_LINE\n    status = trustedGetPublicSharesAES(eid, &errStatus, errMsg1.data(),\n                                       encryptedDKGSecret.data(), encLen, pubShares.data(), t, n);\n    REQUIRE(status == SGX_SUCCESS);\n    REQUIRE(errStatus == SGX_SUCCESS);\n\n    vector <string> g2Strings = splitString(pubShares.data(), ',');\n    vector <libff::alt_bn128_G2> pubSharesG2;\n    for (u_int64_t i = 0; i < g2Strings.size(); i++) {\n        vector <string> coeffStr = splitString(g2Strings.at(i).c_str(), ':');\n\n        pubSharesG2.push_back(TestUtils::vectStringToG2(coeffStr));\n    }\n\n    vector<char> secret(BUF_LEN, 0);\n    PRINT_SRC_LINE\n    status = trustedDecryptDkgSecretAES(eid, &errStatus, errMsg1.data(), encryptedDKGSecret.data(), encLen,\n                                        (uint8_t *) secret.data());\n    REQUIRE(status == SGX_SUCCESS);\n    REQUIRE(errStatus == SGX_SUCCESS);\n\n    signatures::Dkg dkgObj(t, n);\n\n    vector <libff::alt_bn128_Fr> poly = TestUtils::splitStringToFr(secret.data(), colon);\n    vector <libff::alt_bn128_G2> pubSharesDkg = dkgObj.VerificationVector(poly);\n    for (uint32_t i = 0; i < pubSharesDkg.size(); i++) {\n        libff::alt_bn128_G2 el = pubSharesDkg.at(i);\n        el.to_affine_coordinates();\n    }\n    REQUIRE(pubSharesG2 == pubSharesDkg);\n}\n\nTEST_CASE_METHOD(TestFixture, \"DKG AES encrypted secret shares test\", \"[dkg-aes-encr-sshares]\") {\n    vector<char> errMsg(BUF_LEN, 0);\n    vector<char> result(BUF_LEN, 0);\n\n    int errStatus = 0;\n    uint32_t encLen = 0;\n\n    vector <uint8_t> encryptedDKGSecret(BUF_LEN, 0);\n    PRINT_SRC_LINE\n    auto status = trustedGenDkgSecretAES(eid, &errStatus, errMsg.data(), encryptedDKGSecret.data(), &encLen, 2);\n    REQUIRE(status == SGX_SUCCESS);\n    REQUIRE(errStatus == SGX_SUCCESS);\n\n    uint64_t enc_len = encLen;\n\n    PRINT_SRC_LINE\n    status = trustedSetEncryptedDkgPolyAES(eid, &errStatus, errMsg.data(), encryptedDKGSecret.data(), enc_len);\n    REQUIRE(status == SGX_SUCCESS);\n    REQUIRE(errStatus == SGX_SUCCESS);\n\n    vector <uint8_t> encrPRDHKey(BUF_LEN, 0);\n\n    string pub_keyB = SAMPLE_PUBLIC_KEY_B;\n\n    vector<char> s_shareG2(BUF_LEN, 0);\n    PRINT_SRC_LINE\n    status = trustedGetEncryptedSecretShareAES(eid, &errStatus, errMsg.data(), encrPRDHKey.data(), &encLen,\n                                               result.data(),\n                                               s_shareG2.data(),\n                                               (char *) pub_keyB.data(), 2, 2, 1);\n\n    REQUIRE(status == SGX_SUCCESS);\n    REQUIRE(errStatus == SGX_SUCCESS);\n}\n\n\n/*\n * ( \"verification test\", \"[verify]\" ) {\n\n\n    char*  pubshares = \"0d72c21fc5a43452ad5f36699822309149ce6ce2cdce50dafa896e873f1b8ddd12f65a2e9c39c617a1f695f076b33b236b47ed773901fc2762f8b6f63277f5e30d7080be8e98c97f913d1920357f345dc0916c1fcb002b7beb060aa8b6b473a011bfafe9f8a5d8ea4c643ca4101e5119adbef5ae64f8dfb39cd10f1e69e31c591858d7eaca25b4c412fe909ca87ca7aadbf6d97d32d9b984e93d436f13d43ec31f40432cc750a64ac239cad6b8f78c1f1dd37427e4ff8c1cc4fe1c950fcbcec10ebfd79e0c19d0587adafe6db4f3c63ea9a329724a8804b63a9422e6898c0923209e828facf3a073254ec31af4231d999ba04eb5b7d1e0056d742a65b766f2f3\";\n    char *sec_share = \"11592366544581417165283270001305852351194685098958224535357729125789505948557\";\n    mpz_t sshare;\n    mpz_init(sshare);\n    mpz_set_str(sshare, \"11592366544581417165283270001305852351194685098958224535357729125789505948557\", 10);\n    int result = Verification(pubshares, sshare, 2, 0);\n    REQUIRE(result == 1);\n\n\n}*/\n\n\n\n\n\n\nTEST_CASE_METHOD(TestFixture, \"DKG_BLS test\", \"[dkg-bls]\") {\n    HttpClient client(RPC_ENDPOINT);\n    StubClient c(client, JSONRPC_CLIENT_V2);\n\n    vector <string> ecdsaKeyNames;\n    vector <string> blsKeyNames;\n\n    int schainID = TestUtils::randGen();\n    int dkgID = TestUtils::randGen();\n\n    PRINT_SRC_LINE\n    TestUtils::doDKG(c, 4, 1, ecdsaKeyNames, blsKeyNames, schainID, dkgID);\n\n    REQUIRE(blsKeyNames.size() == 4);\n\n    schainID = TestUtils::randGen();\n    dkgID = TestUtils::randGen();\n\n    TestUtils::doDKG(c, 16, 5, ecdsaKeyNames, blsKeyNames, schainID, dkgID);\n}\n\nTEST_CASE_METHOD(TestFixture, \"Delete Bls Key\", \"[delete-bls-key]\") {\n    HttpClient client(RPC_ENDPOINT);\n    StubClient c(client, JSONRPC_CLIENT_V2);\n    std::string name = \"BLS_KEY:SCHAIN_ID:123456789:NODE_ID:0:DKG_ID:0\";\n    libff::alt_bn128_Fr key = libff::alt_bn128_Fr(\n            \"6507625568967977077291849236396320012317305261598035438182864059942098934847\");\n    std::string key_str = TestUtils::stringFromFr(key);\n    PRINT_SRC_LINE\n    c.importBLSKeyShare(key_str, name);\n    PRINT_SRC_LINE\n    REQUIRE(c.deleteBlsKey(name)[\"deleted\"] == true);\n}\n\nTEST_CASE_METHOD(TestFixture, \"Backup Key\", \"[backup-key]\") {\n    HttpClient client(RPC_ENDPOINT);\n    StubClient c(client, JSONRPC_CLIENT_V2);\n    std::ifstream sek_file(\"sgx_data/sgxwallet_backup_key.txt\");\n    REQUIRE(sek_file.good());\n\n    std::string sek;\n    sek_file >> sek;\n\n    REQUIRE(sek.size() == 32);\n}\n\nTEST_CASE_METHOD(TestFixture, \"Get ServerStatus\", \"[get-server-status]\") {\n    HttpClient client(RPC_ENDPOINT);\n    StubClient c(client, JSONRPC_CLIENT_V2);\n    REQUIRE(c.getServerStatus()[\"status\"] == 0);\n}\n\nTEST_CASE_METHOD(TestFixture, \"Get ServerVersion\", \"[get-server-version]\") {\n    HttpClient client(RPC_ENDPOINT);\n    StubClient c(client, JSONRPC_CLIENT_V2);\n    REQUIRE(c.getServerVersion()[\"version\"] == SGXWalletServer::getVersion());\n}\n\n\nTEST_CASE_METHOD(TestFixtureHTTPS, \"Cert request sign\", \"[cert-sign]\") {\n\n    PRINT_SRC_LINE\n\n    REQUIRE_NOTHROW(SGXRegistrationServer::getServer());\n\n    PRINT_SRC_LINE\n\n    string csrFile = \"insecure-samples/yourdomain.csr\";\n\n    ifstream infile(csrFile);\n    infile.exceptions(std::ifstream::failbit | std::ifstream::badbit);\n    ostringstream ss;\n    ss << infile.rdbuf();\n    infile.close();\n\n    PRINT_SRC_LINE\n\n    auto result = SGXRegistrationServer::getServer()->SignCertificate(ss.str());\n\n    REQUIRE(result[\"status\"] == 0);\n\n\n    PRINT_SRC_LINE\n    result = SGXRegistrationServer::getServer()->SignCertificate(\"Haha\");\n\n    REQUIRE(result[\"status\"] != 0);\n}\n\nTEST_CASE_METHOD(TestFixture, \"DKG API test\", \"[dkg-api]\") {\n    HttpClient client(RPC_ENDPOINT);\n    StubClient c(client, JSONRPC_CLIENT_V2);\n\n    string polyName = SAMPLE_POLY_NAME;\n\n    PRINT_SRC_LINE\n    Json::Value genPoly = c.generateDKGPoly(polyName, 2);\n    REQUIRE(genPoly[\"status\"].asInt() == 0);\n\n    Json::Value publicKeys;\n    publicKeys.append(SAMPLE_DKG_PUB_KEY_1);\n    publicKeys.append(SAMPLE_DKG_PUB_KEY_2);\n\n    // wrongName\n    Json::Value genPolyWrongName = c.generateDKGPoly(\"poly\", 2);\n    REQUIRE(genPolyWrongName[\"status\"].asInt() != 0);\n\n    Json::Value verifVectWrongName = c.getVerificationVector(\"poly\", 2, 2);\n    REQUIRE(verifVectWrongName[\"status\"].asInt() != 0);\n\n    Json::Value secretSharesWrongName = c.getSecretShare(\"poly\", publicKeys, 2, 2);\n    REQUIRE(secretSharesWrongName[\"status\"].asInt() != 0);\n\n    // wrong_t\n    Json::Value genPolyWrong_t = c.generateDKGPoly(polyName, 33);\n    REQUIRE(genPolyWrong_t[\"status\"].asInt() != 0);\n\n    Json::Value verifVectWrong_t = c.getVerificationVector(polyName, 1, 2);\n    REQUIRE(verifVectWrong_t[\"status\"].asInt() != 0);\n\n    Json::Value secretSharesWrong_t = c.getSecretShare(polyName, publicKeys, 3, 3);\n    REQUIRE(secretSharesWrong_t[\"status\"].asInt() != 0);\n\n    // wrong_n\n    Json::Value verifVectWrong_n = c.getVerificationVector(polyName, 2, 1);\n    REQUIRE(verifVectWrong_n[\"status\"].asInt() != 0);\n\n    Json::Value publicKeys1;\n    publicKeys1.append(SAMPLE_DKG_PUB_KEY_1);\n    Json::Value secretSharesWrong_n = c.getSecretShare(polyName, publicKeys1, 2, 1);\n    REQUIRE(secretSharesWrong_n[\"status\"].asInt() != 0);\n\n    //wrong number of publicKeys\n    Json::Value secretSharesWrongPkeys = c.getSecretShare(polyName, publicKeys, 2, 3);\n    REQUIRE(secretSharesWrongPkeys[\"status\"].asInt() != 0);\n\n    //wrong verif\n    Json::Value Skeys = c.getSecretShare(polyName, publicKeys, 2, 2);\n    Json::Value verifVect = c.getVerificationVector(polyName, 2, 2);\n    Json::Value verificationWrongSkeys = c.dkgVerification(\"\", \"\", \"\", 2, 2, 1);\n    REQUIRE(verificationWrongSkeys[\"status\"].asInt() != 0);\n}\n\nTEST_CASE_METHOD(TestFixture, \"PolyExists test\", \"[dkg-poly-exists]\") {\n    HttpClient client(RPC_ENDPOINT);\n    StubClient c(client, JSONRPC_CLIENT_V2);\n\n    string polyName = SAMPLE_POLY_NAME;\n    PRINT_SRC_LINE\n    Json::Value genPoly = c.generateDKGPoly(polyName, 2);\n    REQUIRE(genPoly[\"status\"] == 0);\n\n    PRINT_SRC_LINE\n    Json::Value polyExists = c.isPolyExists(polyName);\n    REQUIRE(polyExists[\"status\"] == 0);\n    REQUIRE(polyExists[\"IsExist\"].asBool());\n\n    PRINT_SRC_LINE\n    Json::Value polyDoesNotExist = c.isPolyExists(\"Vasya\");\n    REQUIRE(!polyDoesNotExist[\"IsExist\"].asBool());\n}\n\nTEST_CASE_METHOD(TestFixture, \"AES_DKG test\", \"[aes-dkg]\") {\n    HttpClient client(RPC_ENDPOINT);\n    StubClient c(client, JSONRPC_CLIENT_V2);\n\n    int n = 2, t = 2;\n    Json::Value ethKeys[n];\n    Json::Value verifVects[n];\n    Json::Value pubEthKeys;\n    Json::Value secretShares[n];\n    Json::Value pubBLSKeys[n];\n    Json::Value blsSigShares[n];\n    vector <string> pubShares(n);\n    vector <string> polyNames(n);\n\n    int schainID = TestUtils::randGen();\n    int dkgID = TestUtils::randGen();\n    for (uint8_t i = 0; i < n; i++) {\n        PRINT_SRC_LINE\n        ethKeys[i] = c.generateECDSAKey();\n        REQUIRE(ethKeys[i][\"status\"] == 0);\n        string polyName =\n                \"POLY:SCHAIN_ID:\" + to_string(schainID) + \":NODE_ID:\" + to_string(i) + \":DKG_ID:\" + to_string(dkgID);\n        REQUIRE(ethKeys[i][\"status\"] == 0);\n        auto response = c.generateDKGPoly(polyName, t);\n        REQUIRE(response[\"status\"] == 0);\n\n        polyNames[i] = polyName;\n        PRINT_SRC_LINE\n        verifVects[i] = c.getVerificationVector(polyName, t, n);\n        REQUIRE(verifVects[i][\"status\"] == 0);\n\n        pubEthKeys.append(ethKeys[i][\"publicKey\"]);\n    }\n\n    for (uint8_t i = 0; i < n; i++) {\n        PRINT_SRC_LINE\n        secretShares[i] = c.getSecretShare(polyNames[i], pubEthKeys, t, n);\n        REQUIRE(secretShares[i][\"status\"] == 0);\n\n        for (uint8_t k = 0; k < t; k++)\n            for (uint8_t j = 0; j < 4; j++) {\n                string pubShare = verifVects[i][\"verificationVector\"][k][j].asString();\n                pubShares[i] += TestUtils::convertDecToHex(pubShare);\n            }\n    }\n\n    int k = 0;\n    vector <string> secShares(n);\n\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j < n; j++) {\n            string secretShare = secretShares[i][\"secretShare\"].asString().substr(192 * j, 192);\n            secShares[i] += secretShares[j][\"secretShare\"].asString().substr(192 * i, 192);\n            PRINT_SRC_LINE\n            Json::Value verif = c.dkgVerification(pubShares[i], ethKeys[j][\"keyName\"].asString(), secretShare, t, n, j);\n            REQUIRE(verif[\"status\"] == 0);\n            bool res = verif[\"result\"].asBool();\n            k++;\n            REQUIRE(res);\n        }\n\n    Json::Value complaintResponse = c.complaintResponse(polyNames[1], 0);\n    REQUIRE(complaintResponse[\"status\"] == 0);\n\n    BLSSigShareSet sigShareSet(t, n);\n\n    string hash = SAMPLE_HASH;\n\n    auto hash_arr = make_shared < array < uint8_t,\n    32 >> ();\n\n    uint64_t binLen;\n\n    if (!hex2carray(hash.c_str(), &binLen, hash_arr->data(), 32)) {\n        throw SGXException(INVALID_HEX, \"Invalid hash\");\n    }\n\n    map <size_t, shared_ptr<BLSPublicKeyShare>> coeffs_pkeys_map;\n\n    for (int i = 0; i < t; i++) {\n        string endName = polyNames[i].substr(4);\n        string blsName = \"BLS_KEY\" + polyNames[i].substr(4);\n        auto response = c.createBLSPrivateKey(blsName, ethKeys[i][\"keyName\"].asString(), polyNames[i], secShares[i], t,\n                                              n);\n        REQUIRE(response[\"status\"] == 0);\n\n        PRINT_SRC_LINE\n        pubBLSKeys[i] = c.getBLSPublicKeyShare(blsName);\n        REQUIRE(pubBLSKeys[i][\"status\"] == 0);\n\n        string hash = SAMPLE_HASH;\n        blsSigShares[i] = c.blsSignMessageHash(blsName, hash, t, n);\n        REQUIRE(blsSigShares[i][\"status\"] == 0);\n\n        shared_ptr <string> sig_share_ptr = make_shared<string>(blsSigShares[i][\"signatureShare\"].asString());\n        BLSSigShare sig(sig_share_ptr, i + 1, t, n);\n        sigShareSet.addSigShare(make_shared<BLSSigShare>(sig));\n\n        vector <string> pubKey_vect;\n        for (uint8_t j = 0; j < 4; j++) {\n            pubKey_vect.push_back(pubBLSKeys[i][\"blsPublicKeyShare\"][j].asString());\n        }\n        BLSPublicKeyShare pubKey(make_shared < vector < string >> (pubKey_vect), t, n);\n        PRINT_SRC_LINE\n        REQUIRE(pubKey.VerifySigWithHelper(hash_arr, make_shared<BLSSigShare>(sig), t, n));\n\n        coeffs_pkeys_map[i + 1] = make_shared<BLSPublicKeyShare>(pubKey);\n    }\n\n    shared_ptr <BLSSignature> commonSig = sigShareSet.merge();\n    BLSPublicKey\n    common_public(make_shared < map < size_t, shared_ptr < BLSPublicKeyShare >>>(coeffs_pkeys_map), t,\n            n);\n    REQUIRE(common_public.VerifySigWithHelper(hash_arr, commonSig, t, n));\n}\n\nTEST_CASE_METHOD(TestFixture, \"AES encrypt/decrypt\", \"[aes-encrypt-decrypt]\") {\n    int errStatus = 0;\n    vector<char> errMsg(BUF_LEN, 0);\n    uint32_t encLen;\n    string key = SAMPLE_AES_KEY;\n    vector <uint8_t> encrypted_key(BUF_LEN, 0);\n\n    PRINT_SRC_LINE\n    auto status = trustedEncryptKeyAES(eid, &errStatus, errMsg.data(), key.c_str(), encrypted_key.data(), &encLen);\n\n    REQUIRE(status == 0);\n    REQUIRE(errStatus == 0);\n\n    vector<char> decr_key(BUF_LEN, 0);\n    PRINT_SRC_LINE\n    status = trustedDecryptKeyAES(eid, &errStatus, errMsg.data(), encrypted_key.data(), encLen, decr_key.data());\n\n    REQUIRE(status == 0);\n    REQUIRE(errStatus == 0);\n    REQUIRE(key.compare(decr_key.data()) == 0);\n}\n\n\nTEST_CASE_METHOD(TestFixture, \"Many threads ecdsa dkg bls\", \"[many-threads-crypto]\") {\n    vector <thread> threads;\n    int num_threads = 4;\n    for (int i = 0; i < num_threads; i++) {\n        threads.push_back(thread(TestUtils::sendRPCRequest));\n    }\n\n    for (auto &thread : threads) {\n        thread.join();\n    }\n}\n\nTEST_CASE_METHOD(TestFixture, \"First run\", \"[first-run]\") {\n\n    HttpClient client(RPC_ENDPOINT);\n    StubClient c(client, JSONRPC_CLIENT_V2);\n    try {\n        PRINT_SRC_LINE\n        auto keyName = genECDSAKeyAPI(c);\n        ofstream namefile(\"/tmp/keyname\");\n        namefile << keyName;\n\n        PRINT_SRC_LINE\n    } catch (JsonRpcException & e)\n    {\n        cerr << e.what() << endl;\n        throw;\n    }\n\n\n}\n\nTEST_CASE_METHOD(TestFixtureNoReset, \"Second run\", \"[second-run]\") {\n\n    HttpClient client(RPC_ENDPOINT);\n    StubClient c(client, JSONRPC_CLIENT_V2);\n    try {\n        PRINT_SRC_LINE\n        string keyName;\n        ifstream namefile(\"/tmp/keyname\");\n        getline(namefile, keyName);\n\n        Json::Value sig = c.ecdsaSignMessageHash(16, keyName, SAMPLE_HASH);\n        REQUIRE(sig[\"status\"].asInt() == 0);\n        Json::Value getPubKey = c.getPublicECDSAKey(keyName);\n        REQUIRE(getPubKey[\"status\"].asInt() == 0);\n    } catch (JsonRpcException &e) {\n        cerr << e.what() << endl;\n        throw;\n    }\n}\n\n\nTEST_CASE_METHOD(TestFixtureNoResetFromBackup, \"Backup restore\", \"[backup-restore]\") {\n}\n"], "fixing_code": ["/*\n    Copyright (C) 2019-Present SKALE Labs\n\n    This file is part of sgxwallet.\n\n    sgxwallet is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    sgxwallet is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with sgxwallet.  If not, see <https://www.gnu.org/licenses/>.\n\n    @file BLSCrypto.cpp\n    @author Stan Kladko\n    @date 2019\n*/\n\n#include <memory>\n#include \"libff/algebra/curves/alt_bn128/alt_bn128_init.hpp\"\n#include \"leveldb/db.h\"\n#include <jsonrpccpp/server/connectors/httpserver.h>\n\n#include \"third_party/intel/create_enclave.h\"\n\n\n\n#include \"bls.h\"\n#include <bls/BLSutils.h>\n\n#include \"BLSPrivateKeyShareSGX.h\"\n\n\n\n#include \"sgxwallet_common.h\"\n#include \"sgxwallet.h\"\n#include \"SGXException.h\"\n#include \"third_party/spdlog/spdlog.h\"\n#include \"common.h\"\n#include \"SGXWalletServer.h\"\n\n#include \"BLSCrypto.h\"\n#include \"ServerInit.h\"\n\n\nstring *FqToString(libff::alt_bn128_Fq *_fq) {\n\n    CHECK_STATE(_fq);\n\n    mpz_t t;\n    mpz_init(t);\n\n    _fq->as_bigint().to_mpz(t);\n\n    SAFE_CHAR_BUF(arr,mpz_sizeinbase(t, 10) + 2);\n\n    mpz_get_str(arr, 10, t);\n    mpz_clear(t);\n\n    return new string(arr);\n}\n\nint char2int(char _input) {\n    if (_input >= '0' && _input <= '9')\n        return _input - '0';\n    if (_input >= 'A' && _input <= 'F')\n        return _input - 'A' + 10;\n    if (_input >= 'a' && _input <= 'f')\n        return _input - 'a' + 10;\n    return -1;\n}\n\nvoid carray2Hex(const unsigned char *d, uint64_t _len, char *_hexArray,\n                uint64_t _hexArrayLen) {\n\n    CHECK_STATE(d);\n    CHECK_STATE(_hexArray);\n\n    char hexval[16] = {'0', '1', '2', '3', '4', '5', '6', '7',\n                       '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};\n\n    CHECK_STATE(_hexArrayLen > 2 * _len);\n\n    for (uint64_t j = 0; j < _len; j++) {\n        _hexArray[j * 2] = hexval[((d[j] >> 4) & 0xF)];\n        _hexArray[j * 2 + 1] = hexval[(d[j]) & 0x0F];\n    }\n\n    _hexArray[_len * 2] = 0;\n}\n\n\n\nbool hex2carray(const char *_hex, uint64_t *_bin_len,\n                 uint8_t *_bin, uint64_t _max_length) {\n\n\n    CHECK_STATE(_hex);\n    CHECK_STATE(_bin);\n    CHECK_STATE(_bin_len)\n\n\n    uint64_t len = strnlen(_hex, 2 * _max_length + 1);\n\n    CHECK_STATE(len != 2 * _max_length + 1);\n\n    CHECK_STATE(len <= 2 * _max_length );\n\n\n    if (len == 0 && len % 2 == 1)\n        return false;\n\n    *_bin_len = len / 2;\n\n    for (uint64_t i = 0; i < len / 2; i++) {\n        int high = char2int((char) _hex[i * 2]);\n        int low = char2int((char) _hex[i * 2 + 1]);\n\n        if (high < 0 || low < 0) {\n            return false;\n        }\n\n        _bin[i] = (unsigned char) (high * 16 + low);\n    }\n\n    return true;\n}\n\nbool sign(const char *_encryptedKeyHex, const char *_hashHex, size_t _t, size_t _n, size_t _signerIndex,\n          char *_sig) {\n\n\n    CHECK_STATE(_encryptedKeyHex);\n    CHECK_STATE(_hashHex);\n    CHECK_STATE(_sig);\n\n    auto keyStr = make_shared<string>(_encryptedKeyHex);\n\n    auto hash = make_shared<array<uint8_t, 32>>();\n\n    uint64_t binLen;\n\n    if (!hex2carray(_hashHex, &binLen, hash->data(), hash->size())) {\n        throw SGXException(INVALID_HEX, \"Invalid hash\");\n    }\n\n    auto keyShare = make_shared<BLSPrivateKeyShareSGX>(keyStr, _t, _n);\n\n    auto sigShare = keyShare->signWithHelperSGX(hash, _signerIndex);\n\n    auto sigShareStr = sigShare->toString();\n\n    strncpy(_sig, sigShareStr->c_str(), BUF_LEN);\n\n    return true;\n}\n\nbool sign_aes(const char *_encryptedKeyHex, const char *_hashHex, size_t _t, size_t _n, char *_sig) {\n\n    CHECK_STATE(_encryptedKeyHex);\n    CHECK_STATE(_hashHex);\n    CHECK_STATE(_sig);\n\n    auto hash = make_shared<array<uint8_t, 32>>();\n\n    uint64_t binLen;\n\n    if (!hex2carray(_hashHex, &binLen, hash->data(), hash->size())) {\n        throw SGXException(INVALID_HEX, \"Invalid hash\");\n    }\n\n    shared_ptr<signatures::Bls> obj;\n    obj = make_shared<signatures::Bls>(signatures::Bls(_t, _n));\n\n    pair<libff::alt_bn128_G1, string> hash_with_hint = obj->HashtoG1withHint(hash);\n\n    string *xStr = FqToString(&(hash_with_hint.first.X));\n\n    CHECK_STATE(xStr);\n\n    string *yStr = FqToString(&(hash_with_hint.first.Y));\n\n    if (yStr == nullptr) {\n        delete xStr;\n        BOOST_THROW_EXCEPTION(runtime_error(\"Null yStr\"));\n    }\n\n    vector<char> errMsg(BUF_LEN,0);\n\n    SAFE_CHAR_BUF(xStrArg,BUF_LEN);\n    SAFE_CHAR_BUF(yStrArg,BUF_LEN);\n    SAFE_CHAR_BUF(signature,BUF_LEN);\n\n    strncpy(xStrArg, xStr->c_str(), BUF_LEN);\n    strncpy(yStrArg, yStr->c_str(), BUF_LEN);\n\n    delete xStr;\n    delete yStr;\n\n    size_t sz = 0;\n\n    SAFE_UINT8_BUF(encryptedKey,BUF_LEN);\n\n    bool result = hex2carray(_encryptedKeyHex, &sz, encryptedKey, BUF_LEN);\n\n    if (!result) {\n        BOOST_THROW_EXCEPTION(invalid_argument(\"Invalid hex encrypted key\"));\n    }\n\n    int errStatus = 0;\n    sgx_status_t status =\n            trustedBlsSignMessageAES(eid, &errStatus, errMsg.data(), encryptedKey,\n                                 sz, xStrArg, yStrArg, signature);\n    HANDLE_TRUSTED_FUNCTION_ERROR(status, errStatus, errMsg.data());\n\n    string hint = BLSutils::ConvertToString(hash_with_hint.first.Y) + \":\" + hash_with_hint.second;\n\n    string sig = signature;\n\n    sig.append(\":\");\n    sig.append(hint);\n\n    strncpy(_sig, sig.c_str(), BUF_LEN);\n\n    return true;\n}\n\nbool bls_sign(const char *_encryptedKeyHex, const char *_hashHex, size_t _t, size_t _n, char *_sig) {\n    CHECK_STATE(_encryptedKeyHex);\n    CHECK_STATE(_hashHex);\n    return sign_aes(_encryptedKeyHex, _hashHex, _t, _n, _sig);\n}\n\nstring encryptBLSKeyShare2Hex(int *errStatus, char *err_string, const char *_key) {\n    CHECK_STATE(errStatus);\n    CHECK_STATE(err_string);\n    CHECK_STATE(_key);\n    auto keyArray = make_shared<vector<char>>(BUF_LEN, 0);\n    auto encryptedKey = make_shared<vector<uint8_t>>(BUF_LEN, 0);\n\n    vector<char> errMsg(BUF_LEN, 0);\n\n    strncpy(keyArray->data(), _key, BUF_LEN);\n    *errStatus = 0;\n\n    uint64_t encryptedLen = 0;\n\n    sgx_status_t status = trustedEncryptKeyAES(eid, errStatus, errMsg.data(), keyArray->data(), encryptedKey->data(), &encryptedLen);\n\n    HANDLE_TRUSTED_FUNCTION_ERROR(status, *errStatus, errMsg.data());\n\n    SAFE_CHAR_BUF(resultBuf, 2 * BUF_LEN + 1);\n\n    carray2Hex(encryptedKey->data(), encryptedLen, resultBuf, 2 * BUF_LEN + 1);\n\n    return string(resultBuf);\n}\n", "/*\n    Copyright (C) 2019-Present SKALE Labs\n\n    This file is part of sgxwallet.\n\n    sgxwallet is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    sgxwallet is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with sgxwallet.  If not, see <https://www.gnu.org/licenses/>.\n\n    @file DKGCrypto.cpp\n    @author Stan Kladko\n    @date 2019\n*/\n\n\n#include <iostream>\n#include <memory>\n\n\n\n#include \"third_party/spdlog/spdlog.h\"\n#include \"sgxwallet.h\"\n#include \"SGXException.h\"\n#include \"common.h\"\n#include \"SGXWalletServer.hpp\"\n\n\n#include \"DKGCrypto.h\"\n#include \"BLSCrypto.h\"\n\n\n\n\n\n\n\nvector <string> splitString(const char *coeffs, const char symbol) {\n    CHECK_STATE(coeffs);\n    string str(coeffs);\n    string delim;\n    delim.push_back(symbol);\n    vector <string> G2_strings;\n    size_t prev = 0, pos = 0;\n    do {\n        pos = str.find(delim, prev);\n        if (pos == string::npos) pos = str.length();\n        string token = str.substr(prev, pos - prev);\n        if (!token.empty()) {\n            string coeff(token.c_str());\n            G2_strings.push_back(coeff);\n        }\n        prev = pos + delim.length();\n    } while (pos < str.length() && prev < str.length());\n\n    return G2_strings;\n}\n\ntemplate<class T>\nstring ConvertToString(T field_elem, int base = 10) {\n    mpz_t t;\n    mpz_init(t);\n\n    field_elem.as_bigint().to_mpz(t);\n\n    SAFE_CHAR_BUF(arr,mpz_sizeinbase(t, base) + 2);\n\n    mpz_get_str(arr, base, t);\n    mpz_clear(t);\n\n    string output = arr;\n\n    return output;\n}\n\nstring convertHexToDec(const string &hex_str) {\n    mpz_t dec;\n    mpz_init(dec);\n\n    string ret = \"\";\n\n    try {\n        if (mpz_set_str(dec, hex_str.c_str(), 16) == -1) {\n            mpz_clear(dec);\n            return ret;\n        }\n\n        SAFE_CHAR_BUF(arr,mpz_sizeinbase(dec, 10) + 2);\n        mpz_get_str(arr, 10, dec);\n        ret = arr;\n    } catch (exception &e) {\n        mpz_clear(dec);\n        throw SGXException(INCORRECT_STRING_CONVERSION, e.what());\n    } catch (...) {\n        mpz_clear(dec);\n        throw SGXException(UNKNOWN_ERROR, \"\");\n    }\n\n    return ret;\n}\n\nstring convertG2ToString(const libff::alt_bn128_G2 &elem, int base, const string &delim) {\n    string result = \"\";\n\n    try {\n        result += ConvertToString(elem.X.c0);\n        result += delim;\n        result += ConvertToString(elem.X.c1);\n        result += delim;\n        result += ConvertToString(elem.Y.c0);\n        result += delim;\n        result += ConvertToString(elem.Y.c1);\n\n        return result;\n\n    } catch (exception &e) {\n        throw SGXException(INCORRECT_STRING_CONVERSION, e.what());\n        return result;\n    } catch (...) {\n        throw SGXException(UNKNOWN_ERROR, \"\");\n        return result;\n    }\n\n    return result;\n}\n\nstring gen_dkg_poly(int _t) {\n    vector<char> errMsg(BUF_LEN, 0);\n    int errStatus = 0;\n    uint64_t enc_len = 0;\n\n    vector <uint8_t> encrypted_dkg_secret(BUF_LEN, 0);\n\n    sgx_status_t status = trustedGenDkgSecretAES(\n            eid, &errStatus,errMsg.data(), encrypted_dkg_secret.data(), &enc_len, _t);\n\n    HANDLE_TRUSTED_FUNCTION_ERROR(status, errStatus, errMsg.data());\n\n    uint64_t length = enc_len;;\n\n    vector<char> hexEncrPoly(BUF_LEN, 0);\n    CHECK_STATE(encrypted_dkg_secret.size() >= length);\n    carray2Hex(encrypted_dkg_secret.data(), length, hexEncrPoly.data(), BUF_LEN);\n    string result(hexEncrPoly.data());\n\n    return result;\n}\n\nvector <vector<string>> get_verif_vect(const char *encryptedPolyHex, int t, int n) {\n\n    CHECK_STATE(encryptedPolyHex);\n\n    vector<char> errMsg(BUF_LEN, 0);\n\n    int errStatus = 0;\n\n    vector<char> pubShares(10000, 0);\n\n    uint64_t encLen = 0;\n\n    vector <uint8_t> encrDKGPoly(2 * BUF_LEN, 0);\n\n    if (!hex2carray(encryptedPolyHex, &encLen, encrDKGPoly.data(), 6100)) {\n        throw SGXException(INVALID_HEX, \"Invalid encryptedPolyHex\");\n    }\n\n\n\n    sgx_status_t status = trustedGetPublicSharesAES(eid, &errStatus, errMsg.data(), encrDKGPoly.data(), encLen,\n                                       pubShares.data(), t, n);\n    HANDLE_TRUSTED_FUNCTION_ERROR(status, errStatus, errMsg.data());\n\n    vector <string> g2Strings = splitString(pubShares.data(), ',');\n    vector <vector<string>> pubSharesVect;\n    for (uint64_t i = 0; i < g2Strings.size(); i++) {\n        vector <string> coeffStr = splitString(g2Strings.at(i).c_str(), ':');\n        pubSharesVect.push_back(coeffStr);\n    }\n\n    return pubSharesVect;\n}\n\nstring\ngetSecretShares(const string &_polyName, const char *_encryptedPolyHex, const vector <string> &_publicKeys,\n                       int _t,\n                       int _n) {\n\n    CHECK_STATE(_encryptedPolyHex);\n\n    vector<char> hexEncrKey(BUF_LEN, 0);\n    vector<char> errMsg1(BUF_LEN, 0);\n    vector <uint8_t> encrDKGPoly(BUF_LEN, 0);\n    int errStatus = 0;\n    uint64_t encLen = 0;\n\n\n\n    if (!hex2carray(_encryptedPolyHex, &encLen, encrDKGPoly.data(), BUF_LEN)) {\n        throw SGXException(INVALID_HEX, \"Invalid encryptedPolyHex\");\n    }\n\n    sgx_status_t status = trustedSetEncryptedDkgPolyAES(eid, &errStatus, errMsg1.data(), encrDKGPoly.data(), encLen);\n    HANDLE_TRUSTED_FUNCTION_ERROR(status, errStatus, errMsg1.data());\n\n    string result;\n\n    for (int i = 0; i < _n; i++) {\n        vector <uint8_t> encryptedSkey(BUF_LEN, 0);\n        uint64_t decLen;\n        vector<char> currentShare(193, 0);\n        vector<char> sShareG2(320, 0);\n\n        string pub_keyB = _publicKeys.at(i);\n        vector<char> pubKeyB(129, 0);\n\n        strncpy(pubKeyB.data(), pub_keyB.c_str(), 128);\n        pubKeyB.at(128) = 0;\n\n        spdlog::debug(\"pubKeyB is {}\", pub_keyB);\n\n        sgx_status_t status = trustedGetEncryptedSecretShareAES(eid, &errStatus, errMsg1.data(), encryptedSkey.data(), &decLen,\n                                          currentShare.data(), sShareG2.data(), pubKeyB.data(), _t, _n, i + 1);\n        HANDLE_TRUSTED_FUNCTION_ERROR(status, errStatus, errMsg1.data());\n\n        spdlog::debug(\"cur_share is {}\", currentShare.data());\n\n        result += string(currentShare.data());\n\n        spdlog::debug(\"dec len is {}\", decLen);\n        carray2Hex(encryptedSkey.data(), decLen, hexEncrKey.data(), BUF_LEN);\n        string dhKeyName = \"DKG_DH_KEY_\" + _polyName + \"_\" + to_string(i) + \":\";\n\n        spdlog::debug(\"hexEncr DH Key: { }\", hexEncrKey.data());\n        spdlog::debug(\"name to write to db is {}\", dhKeyName);\n        SGXWalletServer::writeDataToDB(dhKeyName, hexEncrKey.data());\n\n        string shareG2_name = \"shareG2_\" + _polyName + \"_\" + to_string(i) + \":\";\n        spdlog::debug(\"name to write to db is {}\", shareG2_name);\n        spdlog::debug(\"s_shareG2: {}\", sShareG2.data());\n\n        SGXWalletServer::writeDataToDB(shareG2_name, sShareG2.data());\n\n\n    }\n\n    return result;\n}\n\nbool\nverifyShares(const char *publicShares, const char *encr_sshare, const char *encryptedKeyHex, int t, int n, int ind) {\n\n    CHECK_STATE(publicShares);\n    CHECK_STATE(encr_sshare);\n    CHECK_STATE(encryptedKeyHex);\n\n    vector<char> errMsg(BUF_LEN, 0);\n    int errStatus = 0;\n    uint64_t decKeyLen = 0;\n    int result = 0;\n\n    SAFE_UINT8_BUF(encr_key, BUF_LEN);\n    if (!hex2carray(encryptedKeyHex, &decKeyLen, encr_key, BUF_LEN)) {\n        throw SGXException(INVALID_HEX, \"Invalid encryptedPolyHex\");\n    }\n\n    SAFE_CHAR_BUF(pshares,8193);\n    strncpy(pshares, publicShares, strlen(publicShares));\n\n    sgx_status_t status = trustedDkgVerifyAES(eid, &errStatus, errMsg.data(), pshares, encr_sshare, encr_key, decKeyLen, t,\n                                              ind, &result);\n    HANDLE_TRUSTED_FUNCTION_ERROR(status, errStatus, errMsg.data());\n\n    if (result == 2) {\n        throw SGXException(INVALID_HEX, \"Invalid public shares\");\n    }\n\n    return result;\n}\n\nbool createBLSShare(const string &blsKeyName, const char *s_shares, const char *encryptedKeyHex) {\n\n    CHECK_STATE(s_shares);\n    CHECK_STATE(encryptedKeyHex);\n\n    vector<char> errMsg(BUF_LEN,0);\n    int errStatus = 0;\n\n    uint64_t decKeyLen;\n    SAFE_UINT8_BUF(encr_bls_key,BUF_LEN);\n    SAFE_UINT8_BUF(encr_key,BUF_LEN);\n    if (!hex2carray(encryptedKeyHex, &decKeyLen, encr_key, BUF_LEN)) {\n        throw SGXException(INVALID_HEX, \"Invalid encryptedKeyHex\");\n    }\n\n    uint64_t enc_bls_len = 0;\n\n    sgx_status_t status = trustedCreateBlsKeyAES(eid, &errStatus, errMsg.data(), s_shares, encr_key, decKeyLen, encr_bls_key,\n                                                 &enc_bls_len);\n\n    HANDLE_TRUSTED_FUNCTION_ERROR(status, errStatus, errMsg.data());\n\n    SAFE_CHAR_BUF(hexBLSKey,2 * BUF_LEN)\n\n    carray2Hex(encr_bls_key, enc_bls_len, hexBLSKey, 2 * BUF_LEN);\n\n    SGXWalletServer::writeDataToDB(blsKeyName, hexBLSKey);\n\n    return true;\n\n}\n\nvector <string> getBLSPubKey(const char *encryptedKeyHex) {\n\n    CHECK_STATE(encryptedKeyHex);\n\n    vector<char> errMsg1(BUF_LEN, 0);\n\n    int errStatus = 0;\n    uint64_t decKeyLen = 0;\n\n    SAFE_UINT8_BUF(encrKey, BUF_LEN);\n    if (!hex2carray(encryptedKeyHex, &decKeyLen, encrKey, BUF_LEN)) {\n        throw SGXException(INVALID_HEX, \"Invalid encryptedKeyHex\");\n    }\n\n    SAFE_CHAR_BUF(pubKey,320)\n\n    sgx_status_t status = trustedGetBlsPubKeyAES(eid, &errStatus, errMsg1.data(), encrKey, decKeyLen, pubKey);\n    HANDLE_TRUSTED_FUNCTION_ERROR(status, errStatus, errMsg1.data());\n\n    vector <string> pubKeyVect = splitString(pubKey, ':');\n\n    spdlog::debug(\"pub key is \");\n    for (int i = 0; i < 4; i++)\n        spdlog::debug(\"{}\", pubKeyVect.at(i));\n\n    return pubKeyVect;\n}\n\nvector <string> calculateAllBlsPublicKeys(const vector <string> &public_shares) {\n    size_t n = public_shares.size();\n    size_t t = public_shares[0].length() / 256;\n    uint64_t share_length = 256;\n    uint8_t coord_length = 64;\n\n    vector <libff::alt_bn128_G2> public_keys(n, libff::alt_bn128_G2::zero());\n\n    vector <libff::alt_bn128_G2> public_values(t, libff::alt_bn128_G2::zero());\n    for (size_t i = 0; i < n; ++i) {\n        for (size_t j = 0; j < t; ++j) {\n            libff::alt_bn128_G2 public_share;\n\n            uint64_t pos0 = share_length * j;\n            string x_c0_str = convertHexToDec(public_shares[i].substr(pos0, coord_length));\n            string x_c1_str = convertHexToDec(public_shares[i].substr(pos0 + coord_length, coord_length));\n            string y_c0_str = convertHexToDec(public_shares[i].substr(pos0 + 2 * coord_length, coord_length));\n            string y_c1_str = convertHexToDec(public_shares[i].substr(pos0 + 3 * coord_length, coord_length));\n\n            if (x_c0_str == \"\" || x_c1_str == \"\" || y_c0_str == \"\" || y_c1_str == \"\") {\n                return {};\n            }\n\n            public_share.X.c0 = libff::alt_bn128_Fq(x_c0_str.c_str());\n            public_share.X.c1 = libff::alt_bn128_Fq(x_c1_str.c_str());\n            public_share.Y.c0 = libff::alt_bn128_Fq(y_c0_str.c_str());\n            public_share.Y.c1 = libff::alt_bn128_Fq(y_c1_str.c_str());\n            public_share.Z = libff::alt_bn128_Fq2::one();\n\n            public_values[j] = public_values[j] + public_share;\n\n        }\n    }\n\n    for (size_t i = 0; i < n; ++i) {\n        for (size_t j = 0; j < t; ++j) {\n            public_keys[i] = public_keys[i] + libff::power(libff::alt_bn128_Fr(i + 1), j) * public_values[j];\n        }\n        public_keys[i].to_affine_coordinates();\n    }\n\n    vector <string> result(n);\n    for (size_t i = 0; i < n; ++i) {\n        result[i] = convertG2ToString(public_keys[i]);\n    }\n\n    return result;\n}\n\nstring decryptDHKey(const string &polyName, int ind) {\n    vector<char> errMsg1(BUF_LEN, 0);\n    int errStatus = 0;\n\n    string DH_key_name = polyName + \"_\" + to_string(ind) + \":\";\n    shared_ptr <string> hexEncrKeyPtr = SGXWalletServer::readFromDb(DH_key_name, \"DKG_DH_KEY_\");\n\n    spdlog::debug(\"encr DH key is {}\", *hexEncrKeyPtr);\n\n    vector<char> hexEncrKey(2 * BUF_LEN, 0);\n\n    uint64_t dhEncLen = 0;\n    SAFE_UINT8_BUF(encryptedDHKey, BUF_LEN);\n    if (!hex2carray(hexEncrKeyPtr->c_str(), &dhEncLen, encryptedDHKey, BUF_LEN)) {\n        throw SGXException(INVALID_HEX, \"Invalid hexEncrKey\");\n    }\n    spdlog::debug(\"encr DH key length is {}\", dhEncLen);\n    spdlog::debug(\"hex encr DH key length is {}\", hexEncrKeyPtr->length());\n\n    SAFE_CHAR_BUF(DHKey, ECDSA_SKEY_LEN);\n\n    sgx_status_t status = trustedDecryptKeyAES(eid, &errStatus, errMsg1.data(), encryptedDHKey, dhEncLen, DHKey);\n    HANDLE_TRUSTED_FUNCTION_ERROR(status, errStatus, errMsg1.data());\n\n    return DHKey;\n}\n\nvector <string> mult_G2(const string &x) {\n    vector <string> result(4);\n    libff::alt_bn128_Fr el(x.c_str());\n    libff::alt_bn128_G2 elG2 = el * libff::alt_bn128_G2::one();\n    elG2.to_affine_coordinates();\n    result[0] = ConvertToString(elG2.X.c0);\n    result[1] = ConvertToString(elG2.X.c1);\n    result[2] = ConvertToString(elG2.Y.c0);\n    result[3] = ConvertToString(elG2.Y.c1);\n    return result;\n}\n", "/*\n    Copyright (C) 2019-Present SKALE Labs\n\n    This file is part of sgxwallet.\n\n    sgxwallet is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    sgxwallet is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with sgxwallet.  If not, see <https://www.gnu.org/licenses/>.\n\n    @file ECDSACrypto.cpp\n    @author Stan Kladko\n    @date 2019\n*/\n\n#include \"sgxwallet.h\"\n\n#include \"SGXException.h\"\n\n#include <iostream>\n#include <fstream>\n\n#include <gmp.h>\n#include <random>\n\n#include \"third_party/spdlog/spdlog.h\"\n#include \"common.h\"\n\n#include \"secure_enclave/Verify.h\"\n\n#include \"BLSCrypto.h\"\n\n#include \"ECDSACrypto.h\"\n\nvoid fillRandomBuffer(vector<unsigned char> &_buffer) {\n    ifstream devRandom(\"/dev/urandom\", ios::in | ios::binary);\n    devRandom.exceptions(ifstream::failbit | ifstream::badbit);\n    devRandom.read((char *) _buffer.data(), _buffer.size());\n    devRandom.close();\n}\n\nvector <string> genECDSAKey() {\n    vector<char> errMsg(BUF_LEN, 0);\n    int errStatus = 0;\n    vector <uint8_t> encr_pr_key(BUF_LEN, 0);\n    vector<char> pub_key_x(BUF_LEN, 0);\n    vector<char> pub_key_y(BUF_LEN, 0);\n\n    uint64_t enc_len = 0;\n\n    sgx_status_t status = trustedGenerateEcdsaKeyAES(eid, &errStatus,\n                                        errMsg.data(), encr_pr_key.data(), &enc_len,\n                                        pub_key_x.data(), pub_key_y.data());\n\n    HANDLE_TRUSTED_FUNCTION_ERROR(status, errStatus,errMsg.data());\n\n    vector <string> keys(3);\n\n    vector<char> hexEncrKey(BUF_LEN * 2, 0);\n\n    carray2Hex(encr_pr_key.data(), enc_len, hexEncrKey.data(),\n               BUF_LEN * 2);\n    keys.at(0) = hexEncrKey.data();\n    keys.at(1) = string(pub_key_x.data()) + string(pub_key_y.data());\n\n    vector<unsigned char> randBuffer(32, 0);\n    fillRandomBuffer(randBuffer);\n\n    vector<char> rand_str(BUF_LEN, 0);\n\n    carray2Hex(randBuffer.data(), 32, rand_str.data(), BUF_LEN);\n\n    keys.at(2) = rand_str.data();\n\n    CHECK_STATE(keys.at(2).size() == 64);\n\n    return keys;\n}\n\nstring getECDSAPubKey(const std::string& _encryptedKeyHex) {\n    vector<char> errMsg(BUF_LEN, 0);\n    vector<char> pubKeyX(BUF_LEN, 0);\n    vector<char> pubKeyY(BUF_LEN, 0);\n    vector<uint8_t> encrPrKey(BUF_LEN, 0);\n\n    int errStatus = 0;\n    uint64_t enc_len = 0;\n\n    if (!hex2carray(_encryptedKeyHex.c_str(), &enc_len, encrPrKey.data(),\n                    BUF_LEN)) {\n        throw SGXException(INVALID_HEX, \"Invalid encryptedKeyHex\");\n    }\n\n    sgx_status_t status = trustedGetPublicEcdsaKeyAES(eid, &errStatus,\n                                         errMsg.data(), encrPrKey.data(), enc_len, pubKeyX.data(), pubKeyY.data());\n\n    HANDLE_TRUSTED_FUNCTION_ERROR(status, errStatus, errMsg.data())\n\n    string pubKey = string(pubKeyX.data()) + string(pubKeyY.data());\n\n    if (pubKey.size() != 128) {\n        spdlog::error(\"Incorrect pub key size\", status);\n        throw SGXException(666, \"Incorrect pub key size\");\n    }\n\n    return pubKey;\n}\n\nbool verifyECDSASig(string& pubKeyStr, const char *hashHex, const char *signatureR,\n        const char *signatureS, int base) {\n\n    CHECK_STATE(hashHex)\n    CHECK_STATE(signatureR)\n    CHECK_STATE(signatureS)\n\n    auto x = pubKeyStr.substr(0, 64);\n    auto y = pubKeyStr.substr(64, 128);\n\n    mpz_t msgMpz;\n    mpz_init(msgMpz);\n    if (mpz_set_str(msgMpz, hashHex, 16) == -1) {\n        spdlog::error(\"invalid message hash {}\", hashHex);\n        mpz_clear(msgMpz);\n        return false;\n    }\n\n    signature sig = signature_init();\n    if (signature_set_str(sig, signatureR, signatureS, base) != 0) {\n        spdlog::error(\"Failed to set str signature\");\n        mpz_clear(msgMpz);\n        signature_free(sig);\n        return false;\n    }\n\n    domain_parameters curve = domain_parameters_init();\n    domain_parameters_load_curve(curve, secp256k1);\n\n    point publicKey = point_init();\n\n    point_set_hex(publicKey, x.c_str(), y.c_str());\n    if (!signature_verify(msgMpz, sig, publicKey, curve)) {\n        spdlog::error(\"ECDSA sig not verified\");\n        mpz_clear(msgMpz);\n        signature_free(sig);\n        domain_parameters_clear(curve);\n        point_clear(publicKey);\n        return false;\n    }\n\n    mpz_clear(msgMpz);\n    signature_free(sig);\n    domain_parameters_clear(curve);\n    point_clear(publicKey);\n\n    return true;\n}\n\nvector <string> ecdsaSignHash(const std::string& encryptedKeyHex, const char *hashHex, int base) {\n\n    CHECK_STATE(hashHex);\n\n    vector <string> signatureVector(3);\n\n    vector<char> errMsg(BUF_LEN, 0);\n    int errStatus = 0;\n    vector<char> signatureR(BUF_LEN, 0);\n    vector<char> signatureS(BUF_LEN, 0);\n    vector<uint8_t> encryptedKey(BUF_LEN, 0);\n    uint8_t signatureV = 0;\n    uint64_t decLen = 0;\n\n    string pubKeyStr = \"\";\n\n    if (!hex2carray(encryptedKeyHex.c_str(), &decLen, encryptedKey.data(),\n                    BUF_LEN)) {\n        throw SGXException(INVALID_HEX, \"Invalid encryptedKeyHex\");\n    }\n\n    sgx_status_t status = trustedEcdsaSignAES(eid, &errStatus,\n            errMsg.data(), encryptedKey.data(), decLen, hashHex,\n                                 signatureR.data(),\n                                 signatureS.data(), &signatureV, base);\n\n    HANDLE_TRUSTED_FUNCTION_ERROR(status, errStatus, errMsg.data());\n\n\n    signatureVector.at(0) = to_string(signatureV);\n\n    if (base == 16) {\n        signatureVector.at(1) = \"0x\" + string(signatureR.data());\n        signatureVector.at(2) = \"0x\" + string(signatureS.data());\n    } else {\n        signatureVector.at(1) = string(signatureR.data());\n        signatureVector.at(2) = string(signatureS.data());\n    }\n\n    /* Now verify signature */\n\n    pubKeyStr = getECDSAPubKey(encryptedKeyHex);\n\n    static uint64_t  i = 0;\n\n    i++;\n\n    if (i % 1000 == 0) {\n\n        if (!verifyECDSASig(pubKeyStr, hashHex, signatureR.data(), signatureS.data(), base)) {\n            spdlog::error(\"failed to verify ecdsa signature\");\n            throw SGXException(667, \"ECDSA did not verify\");\n        }\n    }\n\n    return signatureVector;\n}\n", "/*\n    Copyright (C) 2019-Present SKALE Labs\n\n    This file is part of sgxwallet.\n\n    sgxwallet is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    sgxwallet is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with sgxwallet.  If not, see <https://www.gnu.org/licenses/>.\n\n    @file SEKManager.cpp\n    @author Stan Kladko\n    @date 2020\n*/\n\n#include \"SEKManager.h\"\n#include \"SGXException.h\"\n#include \"BLSCrypto.h\"\n#include \"LevelDB.h\"\n\n#include <fstream>\n#include <iostream>\n#include <algorithm>\n\n#include \"sgxwallet_common.h\"\n#include \"common.h\"\n#include \"sgxwallet.h\"\n\n#include \"ServerDataChecker.h\"\n#include \"third_party/spdlog/spdlog.h\"\n\nusing namespace std;\n\n#define BACKUP_PATH \"./sgx_data/sgxwallet_backup_key.txt\"\n\n\nbool case_insensitive_match(string s1, string s2) {\n    //convert s1 and s2 into lower case strings\n    transform(s1.begin(), s1.end(), s1.begin(), ::tolower);\n    transform(s2.begin(), s2.end(), s2.begin(), ::tolower);\n    return s1.compare(s2);\n}\n\nvoid create_test_key() {\n    int errStatus = 0;\n    vector<char> errMsg(1024, 0);\n    uint64_t enc_len;\n\n    SAFE_UINT8_BUF(encrypted_key, BUF_LEN);\n\n    string key = TEST_VALUE;\n\n    sgx_status_t status = trustedEncryptKeyAES(eid, &errStatus, errMsg.data(), key.c_str(), encrypted_key, &enc_len);\n\n    HANDLE_TRUSTED_FUNCTION_ERROR(status, errStatus, errMsg.data());\n\n    vector<char> hexEncrKey(2 * enc_len + 1, 0);\n\n    carray2Hex(encrypted_key, enc_len, hexEncrKey.data(), 2 * enc_len + 1);\n\n    LevelDB::getLevelDb()->writeDataUnique(\"TEST_KEY\", hexEncrKey.data());\n}\n\n\nvoid validate_SEK() {\n\n    shared_ptr <string> test_key_ptr = LevelDB::getLevelDb()->readString(\"TEST_KEY\");\n    vector <uint8_t> encr_test_key(BUF_LEN, 0);\n    vector<char> decr_key(BUF_LEN, 0);\n    uint64_t len = 0;\n    vector<char> errMsg(BUF_LEN, 0);\n\n    int err_status = 0;\n\n    if (!hex2carray(test_key_ptr->c_str(), &len, encr_test_key.data(),\n                    BUF_LEN)) {\n        spdlog::error(\"Corrupt test key is LevelDB\");\n        exit(-1);\n    }\n\n    sgx_status_t status = trustedDecryptKeyAES(eid, &err_status, errMsg.data(), encr_test_key.data(), len, decr_key.data());\n\n    HANDLE_TRUSTED_FUNCTION_ERROR(status, err_status, errMsg.data());\n\n    string test_key = TEST_VALUE;\n\n    if (test_key.compare(decr_key.data()) != 0) {\n        spdlog::error(\"Invalid storage key. You need to recover using backup key\");\n        spdlog::error(\"Set the correct backup key into sgx_datasgxwallet_backup_key.txt\");\n        spdlog::error(\"Then run sgxwallet using backup flag\");\n        exit(-1);\n    }\n}\n\n\nshared_ptr <vector<uint8_t>> check_and_set_SEK(const string &SEK) {\n\n    vector<char> decr_key(BUF_LEN, 0);\n    vector<char> errMsg(BUF_LEN, 0);\n    int err_status = 0;\n\n    auto encrypted_SEK = make_shared < vector < uint8_t >> (BUF_LEN, 0);\n\n    uint64_t l = 0;\n\n    sgx_status_t status = trustedSetSEK_backup(eid, &err_status, errMsg.data(), encrypted_SEK->data(), &l,\n                                               SEK.c_str());\n\n    encrypted_SEK->resize(l);\n\n    HANDLE_TRUSTED_FUNCTION_ERROR(status, err_status, errMsg.data());\n\n    validate_SEK();\n\n    return encrypted_SEK;\n}\n\nvoid gen_SEK() {\n    vector<char> errMsg(1024, 0);\n    int err_status = 0;\n    vector <uint8_t> encrypted_SEK(1024, 0);\n    uint64_t enc_len = 0;\n\n    SAFE_CHAR_BUF(SEK, 65);\n\n    spdlog::info(\"Generating backup key. Will be stored in backup_key.txt ... \");\n\n    sgx_status_t status = trustedGenerateSEK(eid, &err_status, errMsg.data(), encrypted_SEK.data(), &enc_len, SEK);\n\n    HANDLE_TRUSTED_FUNCTION_ERROR(status, err_status, errMsg.data());\n\n\n    if (strnlen(SEK, 33) != 32) {\n        throw SGXException(-1, \"strnlen(SEK,33) != 32\");\n    }\n\n    vector<char> hexEncrKey(2 * enc_len + 1, 0);\n\n    carray2Hex(encrypted_SEK.data(), enc_len, hexEncrKey.data(), 2 * enc_len + 1);\n\n    spdlog::info(string(\"Encrypted storage encryption key:\") + hexEncrKey.data());\n\n    ofstream sek_file(BACKUP_PATH);\n    sek_file.clear();\n\n    sek_file << SEK;\n\n\n    cout << \"ATTENTION! YOUR BACKUP KEY HAS BEEN WRITTEN INTO sgx_data/backup_key.txt \\n\" <<\n         \"PLEASE COPY IT TO THE SAFE PLACE AND THEN DELETE THE FILE MANUALLY BY RUNNING THE FOLLOWING COMMAND:\\n\" <<\n         \"apt-get install secure-delete && srm -vz sgx_data/backup_key.txt\" << endl;\n\n\n    if (!autoconfirm) {\n        string confirm_str = \"I confirm\";\n        string buffer;\n        do {\n            cout << \" DO YOU CONFIRM THAT YOU COPIED THE KEY? (if you confirm type - I confirm)\"\n                 << endl;\n            getline(cin, buffer);\n        } while (case_insensitive_match(confirm_str, buffer));\n    }\n\n\n    LevelDB::getLevelDb()->writeDataUnique(\"SEK\", hexEncrKey.data());\n\n    create_test_key();\n\n    validate_SEK();\n\n    shared_ptr <string> encrypted_SEK_ptr = LevelDB::getLevelDb()->readString(\"SEK\");\n\n    setSEK(encrypted_SEK_ptr);\n\n    validate_SEK();\n\n}\n\nvoid setSEK(shared_ptr <string> hex_encrypted_SEK) {\n\n    CHECK_STATE(hex_encrypted_SEK);\n\n    vector<char> errMsg(1024, 0);\n    int err_status = 0;\n\n    SAFE_UINT8_BUF(encrypted_SEK, BUF_LEN);\n\n    uint64_t len = 0;\n\n    if (!hex2carray(hex_encrypted_SEK->c_str(), &len, encrypted_SEK,\n                    BUF_LEN)) {\n        throw SGXException(INVALID_HEX, \"Invalid encrypted SEK Hex\");\n    }\n\n    sgx_status_t status = trustedSetSEK(eid, &err_status, errMsg.data(), encrypted_SEK);\n\n    HANDLE_TRUSTED_FUNCTION_ERROR(status, err_status, errMsg.data());\n\n\n    validate_SEK();\n\n\n}\n\n#include \"experimental/filesystem\"\n\n#include <boost/algorithm/string.hpp>\n\nvoid enter_SEK() {\n\n    shared_ptr <string> test_key_ptr = LevelDB::getLevelDb()->readString(\"TEST_KEY\");\n    if (test_key_ptr == nullptr) {\n        spdlog::error(\"Error: corrupt or empty LevelDB database\");\n        exit(-1);\n    }\n\n\n    if (!experimental::filesystem::is_regular_file(BACKUP_PATH)) {\n        spdlog::error(\"File does not exist: \"  BACKUP_PATH);\n        exit(-1);\n    }\n\n    ifstream sek_file(BACKUP_PATH);\n\n    spdlog::info(\"Reading backup key from file ...\");\n\n    string sek((istreambuf_iterator<char>(sek_file)),\n               istreambuf_iterator<char>());\n\n    boost::trim(sek);\n\n    spdlog::info(\"Setting backup key ...\");\n\n    while (!checkHex(sek, 16)) {\n        spdlog::error(\"Invalid hex in key\");\n        exit(-1);\n    }\n\n    auto encrypted_SEK = check_and_set_SEK(sek);\n\n    vector<char> hexEncrKey(BUF_LEN, 0);\n\n    carray2Hex(encrypted_SEK->data(), encrypted_SEK->size(), hexEncrKey.data(),\n               BUF_LEN);\n\n    spdlog::info(\"Got sealed storage encryption key.\");\n\n    LevelDB::getLevelDb()->deleteKey(\"SEK\");\n\n    spdlog::info(\"Storing sealed storage encryption key in LevelDB ...\");\n\n    LevelDB::getLevelDb()->writeDataUnique(\"SEK\", hexEncrKey.data());\n\n    spdlog::info(\"Stored storage encryption key in LevelDB.\");\n\n}\n\nvoid initSEK() {\n    shared_ptr <string> encrypted_SEK_ptr = LevelDB::getLevelDb()->readString(\"SEK\");\n    if (enterBackupKey) {\n        enter_SEK();\n    } else {\n        if (encrypted_SEK_ptr == nullptr) {\n            spdlog::warn(\"SEK was not created yet. Going to create SEK\");\n            gen_SEK();\n        } else {\n            setSEK(encrypted_SEK_ptr);\n        }\n    }\n}\n\n//a002e7ca685d46a32771d16fe2518e58\n", "/*\n    Copyright (C) 2019-Present SKALE Labs\n\n    This file is part of sgxwallet.\n\n    sgxwallet is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    sgxwallet is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with sgxwallet.  If not, see <https://www.gnu.org/licenses/>.\n\n    @file SGXWalletServer.cpp\n    @author Stan Kladko\n    @date 2019\n*/\n\n#include <iostream>\n\n#include \"abstractstubserver.h\"\n#include <jsonrpccpp/server/connectors/httpserver.h>\n\n#include <stdio.h>\n\n#include \"sgxwallet_common.h\"\n#include \"sgxwallet.h\"\n\n\n#include \"SGXException.h\"\n#include \"LevelDB.h\"\n#include \"BLSCrypto.h\"\n#include \"ECDSACrypto.h\"\n#include \"DKGCrypto.h\"\n\n#include \"SGXWalletServer.h\"\n#include \"SGXWalletServer.hpp\"\n\n#include \"ServerDataChecker.h\"\n\n#include <algorithm>\n#include <stdlib.h>\n\n#include <unistd.h>\n\n#include \"ServerInit.h\"\n\n#include \"Log.h\"\n\nusing namespace std;\n\nvoid setFullOptions(uint64_t _logLevel, int _useHTTPS, int _autoconfirm, int _enterBackupKey) {\n    spdlog::info(\"Entering {}\", __FUNCTION__);\n\n    CHECK_STATE(_logLevel <= 2)\n\n    if (_logLevel == L_TRACE) {\n        spdlog::set_level(spdlog::level::trace);\n    } else if (_logLevel == L_DEBUG) {\n        spdlog::set_level(spdlog::level::debug);\n    } else {\n        spdlog::set_level(spdlog::level::info);\n    }\n\n    useHTTPS = _useHTTPS;\n    spdlog::info(\"useHTTPS set to \" + to_string(_useHTTPS));\n    autoconfirm = _autoconfirm;\n    spdlog::info(\"autoconfirm set to \" + to_string(autoconfirm));\n    enterBackupKey = _enterBackupKey;\n    spdlog::info(\"enterBackupKey set to \" + to_string(enterBackupKey));\n}\n\nvoid setOptions(uint64_t _logLevel, int _useHTTPS, int _autoconfirm) {\n    spdlog::info(\"Entering {}\", __FUNCTION__);\n    setFullOptions(_logLevel, _useHTTPS, _autoconfirm, false);\n}\n\nbool isStringDec(const string &_str) {\n    auto res = find_if_not(_str.begin(), _str.end(), [](char c) -> bool {\n        return isdigit(c);\n    });\n    return !_str.empty() && res == _str.end();\n}\n\nshared_ptr <SGXWalletServer> SGXWalletServer::server = nullptr;\nshared_ptr <HttpServer> SGXWalletServer::httpServer = nullptr;\n\nSGXWalletServer::SGXWalletServer(AbstractServerConnector &_connector,\n                                 serverVersion_t _type)\n        : AbstractStubServer(_connector, _type) {}\n\nvoid SGXWalletServer::printDB() {\n    cout << \"PRINTING LEVELDB: \" << endl;\n    class MyVisitor : public LevelDB::KeyVisitor {\n    public:\n        virtual void visitDBKey(const char *_data) {\n            cout << _data << endl;\n        }\n    };\n\n    MyVisitor v;\n\n    LevelDB::getLevelDb()->visitKeys(&v, 100000000);\n}\n\nint SGXWalletServer::initHttpsServer(bool _checkCerts) {\n    spdlog::info(\"Entering {}\", __FUNCTION__);\n    string rootCAPath = string(SGXDATA_FOLDER) + \"cert_data/rootCA.pem\";\n    string keyCAPath = string(SGXDATA_FOLDER) + \"cert_data/rootCA.key\";\n\n    if (access(rootCAPath.c_str(), F_OK) != 0 || access(keyCAPath.c_str(), F_OK) != 0) {\n        spdlog::info(\"NO ROOT CA CERTIFICATE YET. CREATING ...\");\n\n        string genRootCACert = \"cd cert && ./create_CA\";\n\n        if (system(genRootCACert.c_str()) == 0) {\n            spdlog::info(\"ROOT CA CERTIFICATE IS SUCCESSFULLY GENERATED\");\n        } else {\n            spdlog::error(\"ROOT CA CERTIFICATE GENERATION FAILED\");\n            exit(-1);\n        }\n    }\n\n    string certPath = string(SGXDATA_FOLDER) + \"cert_data/SGXServerCert.crt\";\n    string keyPath = string(SGXDATA_FOLDER) + \"cert_data/SGXServerCert.key\";\n\n    if (access(certPath.c_str(), F_OK) != 0 || access(certPath.c_str(), F_OK) != 0) {\n        spdlog::info(\"YOU DO NOT HAVE SERVER CERTIFICATE\");\n        spdlog::info(\"SERVER CERTIFICATE IS GOING TO BE CREATED\");\n\n        string genCert = \"cd cert && ./create_server_cert\";\n\n        if (system(genCert.c_str()) == 0) {\n            spdlog::info(\"SERVER CERTIFICATE IS SUCCESSFULLY GENERATED\");\n        } else {\n            spdlog::info(\"SERVER CERTIFICATE GENERATION FAILED\");\n            exit(-1);\n        }\n    }\n\n\n    int numThreads = 64;\n\n#if SGX_MODE == SIM\n   numThreads = 16; \n#endif\n\n\n    httpServer = make_shared<HttpServer>(BASE_PORT, certPath, keyPath, rootCAPath, _checkCerts, numThreads);\n    server = make_shared<SGXWalletServer>(*httpServer,\n                                          JSONRPC_SERVER_V2); // hybrid server (json-rpc 1.0 & 2.0)\n\n    if (!server->StartListening()) {\n        spdlog::error(\"SGX Server could not start listening\");\n        exit(-1);\n    } else {\n        spdlog::info(\"SGX Server started on port {}\", BASE_PORT);\n    }\n    return 0;\n}\n\nint SGXWalletServer::initHttpServer() { //without ssl\n    spdlog::info(\"Entering {}\", __FUNCTION__);\n    httpServer = make_shared<HttpServer>(BASE_PORT + 3);\n    server = make_shared<SGXWalletServer>(*httpServer,\n                                          JSONRPC_SERVER_V2); // hybrid server (json-rpc 1.0 & 2.0)\n    if (!server->StartListening()) {\n        spdlog::error(\"Server could not start listening\");\n        exit(-1);\n    }\n    return 0;\n}\n\nJson::Value\nSGXWalletServer::importBLSKeyShareImpl(const string &_keyShare, const string &_keyShareName) {\n    spdlog::info(\"Entering {}\", __FUNCTION__);\n    INIT_RESULT(result);\n\n    result[\"encryptedKeyShare\"] = \"\";\n\n    string encryptedKeyShareHex;\n\n    try {\n        if (!checkName(_keyShareName, \"BLS_KEY\")) {\n            throw SGXException(INVALID_BLS_NAME, \"Invalid BLS key name\");\n        }\n\n        encryptedKeyShareHex = encryptBLSKeyShare2Hex(&errStatus, (char *) errMsg.data(), _keyShare.c_str());\n\n        if (errStatus != 0) {\n            throw SGXException(errStatus, errMsg.data());\n        }\n\n        if (encryptedKeyShareHex.empty()) {\n            throw SGXException(UNKNOWN_ERROR, \"\");\n        }\n\n        result[\"encryptedKeyShare\"] = encryptedKeyShareHex;\n\n        writeKeyShare(_keyShareName, encryptedKeyShareHex);\n    } HANDLE_SGX_EXCEPTION(result)\n\n    RETURN_SUCCESS(result);\n}\n\nJson::Value\nSGXWalletServer::blsSignMessageHashImpl(const string &_keyShareName, const string &_messageHash, int t, int n) {\n    spdlog::trace(\"Entering {}\", __FUNCTION__);\n    INIT_RESULT(result)\n\n    result[\"status\"] = -1;\n\n    result[\"signatureShare\"] = \"\";\n\n    vector<char> signature(BUF_LEN, 0);\n\n    shared_ptr <string> value = nullptr;\n\n    try {\n        if (!checkName(_keyShareName, \"BLS_KEY\")) {\n            throw SGXException(INVALID_POLY_NAME, \"Invalid BLSKey name\");\n        }\n\n        if (!check_n_t(t, n)) {\n            throw SGXException(INVALID_DKG_PARAMS, \"Invalid t/n parameters\");\n        }\n\n        string hashTmp = _messageHash;\n        if (hashTmp[0] == '0' && (hashTmp[1] == 'x' || hashTmp[1] == 'X')) {\n            hashTmp.erase(hashTmp.begin(), hashTmp.begin() + 2);\n        }\n        while (hashTmp[0] == '0') {\n            hashTmp.erase(hashTmp.begin(), hashTmp.begin() + 1);\n        }\n\n        if (!checkHex(hashTmp)) {\n            throw SGXException(INVALID_HEX, \"Invalid hash\");\n        }\n\n        value = readFromDb(_keyShareName);\n\n        if (!bls_sign(value->c_str(), _messageHash.c_str(), t, n, signature.data())) {\n            throw SGXException(-1, \"Could not sign data \");\n        }\n    } HANDLE_SGX_EXCEPTION(result)\n\n\n    result[\"signatureShare\"] = string(signature.data());\n\n    RETURN_SUCCESS(result);\n\n}\n\nJson::Value SGXWalletServer::generateECDSAKeyImpl() {\n    spdlog::info(\"Entering {}\", __FUNCTION__);\n    INIT_RESULT(result)\n    result[\"encryptedKey\"] = \"\";\n\n    vector <string> keys;\n\n    try {\n        keys = genECDSAKey();\n\n        if (keys.size() == 0) {\n            throw SGXException(UNKNOWN_ERROR, \"key was not generated\");\n        }\n\n        string keyName = \"NEK:\" + keys.at(2);\n\n        writeDataToDB(keyName, keys.at(0));\n\n        result[\"encryptedKey\"] = keys.at(0);\n        result[\"publicKey\"] = keys.at(1);\n        result[\"PublicKey\"] = keys.at(1);\n        result[\"keyName\"] = keyName;\n    } HANDLE_SGX_EXCEPTION(result)\n\n    RETURN_SUCCESS(result);\n}\n\nJson::Value SGXWalletServer::ecdsaSignMessageHashImpl(int _base, const string &_keyName, const string &_messageHash) {\n    spdlog::trace(\"Entering {}\", __FUNCTION__);\n    INIT_RESULT(result)\n\n    result[\"signature_v\"] = \"\";\n    result[\"signature_r\"] = \"\";\n    result[\"signature_s\"] = \"\";\n\n    vector <string> signatureVector(3);\n\n    try {\n        string hashTmp = _messageHash;\n        if (hashTmp[0] == '0' && (hashTmp[1] == 'x' || hashTmp[1] == 'X')) {\n            hashTmp.erase(hashTmp.begin(), hashTmp.begin() + 2);\n        }\n        while (hashTmp[0] == '0') {\n            hashTmp.erase(hashTmp.begin(), hashTmp.begin() + 1);\n        }\n\n        if (!checkECDSAKeyName(_keyName)) {\n            throw SGXException(INVALID_ECDSA_KEY_NAME, \"Invalid ECDSA key name\");\n        }\n        if (!checkHex(hashTmp)) {\n            throw SGXException(INVALID_HEX, \"Invalid hash\");\n        }\n        if (_base <= 0 || _base > 32) {\n            throw SGXException(-22, \"Invalid base\");\n        }\n\n        shared_ptr <string> encryptedKey = readFromDb(_keyName, \"\");\n\n        signatureVector = ecdsaSignHash(encryptedKey->c_str(), hashTmp.c_str(), _base);\n        if (signatureVector.size() != 3) {\n            throw SGXException(INVALID_ECSDA_SIGNATURE, \"Invalid ecdsa signature\");\n        }\n\n        result[\"signature_v\"] = signatureVector.at(0);\n        result[\"signature_r\"] = signatureVector.at(1);\n        result[\"signature_s\"] = signatureVector.at(2);\n    } HANDLE_SGX_EXCEPTION(result)\n\n    RETURN_SUCCESS(result)\n}\n\nJson::Value SGXWalletServer::getPublicECDSAKeyImpl(const string &_keyName) {\n    spdlog::debug(\"Entering {}\", __FUNCTION__);\n    INIT_RESULT(result)\n\n    result[\"publicKey\"] = \"\";\n    result[\"PublicKey\"] = \"\";\n\n    string publicKey;\n\n    try {\n        if (!checkECDSAKeyName(_keyName)) {\n            throw SGXException(INVALID_ECDSA_KEY_NAME, \"Invalid ECDSA key name\");\n        }\n        shared_ptr <string> keyStr = readFromDb(_keyName);\n        publicKey = getECDSAPubKey(keyStr->c_str());\n        result[\"PublicKey\"] = publicKey;\n        result[\"publicKey\"] = publicKey;\n    } HANDLE_SGX_EXCEPTION(result)\n\n    RETURN_SUCCESS(result)\n}\n\nJson::Value SGXWalletServer::generateDKGPolyImpl(const string &_polyName, int _t) {\n    spdlog::info(\"Entering {}\", __FUNCTION__);\n    INIT_RESULT(result)\n\n    string encrPolyHex;\n\n    try {\n        if (!checkName(_polyName, \"POLY\")) {\n            throw SGXException(INVALID_POLY_NAME,\n                               \"Invalid polynomial name, it should be like POLY:SCHAIN_ID:1:NODE_ID:1:DKG_ID:1\");\n        }\n        if (_t <= 0 || _t > 32) {\n            throw SGXException(INVALID_DKG_PARAMS, \"Invalid parameter t \");\n        }\n        encrPolyHex = gen_dkg_poly(_t);\n        writeDataToDB(_polyName, encrPolyHex);\n    } HANDLE_SGX_EXCEPTION(result)\n\n    RETURN_SUCCESS(result)\n}\n\nJson::Value SGXWalletServer::getVerificationVectorImpl(const string &_polyName, int _t, int _n) {\n    spdlog::info(\"Entering {}\", __FUNCTION__);\n    INIT_RESULT(result)\n\n    vector <vector<string>> verifVector;\n    try {\n        if (!checkName(_polyName, \"POLY\")) {\n            throw SGXException(INVALID_POLY_NAME, \"Invalid polynomial name\");\n        }\n        if (!check_n_t(_t, _n)) {\n            throw SGXException(INVALID_DKG_PARAMS, \"Invalid parameters: n or t \");\n        }\n\n        shared_ptr <string> encrPoly = readFromDb(_polyName);\n\n        verifVector = get_verif_vect(encrPoly->c_str(), _t, _n);\n\n        for (int i = 0; i < _t; i++) {\n            vector <string> currentCoef = verifVector.at(i);\n            for (int j = 0; j < 4; j++) {\n                result[\"verificationVector\"][i][j] = currentCoef.at(j);\n            }\n        }\n    } HANDLE_SGX_EXCEPTION(result)\n\n    RETURN_SUCCESS(result)\n\n}\n\nJson::Value SGXWalletServer::getSecretShareImpl(const string &_polyName, const Json::Value &_pubKeys, int _t, int _n) {\n    spdlog::info(\"Entering {}\", __FUNCTION__);\n    INIT_RESULT(result);\n    result[\"secretShare\"] = \"\";\n    result[\"SecretShare\"] = \"\";\n\n    try {\n        if (_pubKeys.size() != (uint64_t) _n) {\n            throw SGXException(INVALID_DKG_PARAMS, \"invalid number of public keys\");\n        }\n        if (!checkName(_polyName, \"POLY\")) {\n            throw SGXException(INVALID_POLY_NAME, \"Invalid polynomial name\");\n        }\n        if (!check_n_t(_t, _n)) {\n            throw SGXException(INVALID_DKG_PARAMS, \"Invalid DKG parameters: n or t \");\n        }\n\n        shared_ptr <string> encrPoly = readFromDb(_polyName);\n\n        vector <string> pubKeysStrs;\n        for (int i = 0; i < _n; i++) {\n            if (!checkHex(_pubKeys[i].asString(), 64)) {\n                throw SGXException(INVALID_HEX, \"Invalid public key\");\n            }\n            pubKeysStrs.push_back(_pubKeys[i].asString());\n        }\n\n        string s = getSecretShares(_polyName, encrPoly->c_str(), pubKeysStrs, _t, _n);\n        result[\"secretShare\"] = s;\n        result[\"SecretShare\"] = s;\n    } HANDLE_SGX_EXCEPTION(result)\n\n    RETURN_SUCCESS(result)\n}\n\nJson::Value SGXWalletServer::dkgVerificationImpl(const string &_publicShares, const string &_ethKeyName,\n                                                 const string &_secretShare, int _t, int _n, int _index) {\n    spdlog::info(\"Entering {}\", __FUNCTION__);\n    INIT_RESULT(result)\n    result[\"result\"] = false;\n\n    try {\n        if (!checkECDSAKeyName(_ethKeyName)) {\n            throw SGXException(INVALID_ECDSA_KEY_NAME, \"Invalid ECDSA key name\");\n        }\n        if (!check_n_t(_t, _n) || _index >= _n || _index < 0) {\n            throw SGXException(INVALID_DKG_PARAMS, \"Invalid DKG parameters: n or t \");\n        }\n        if (!checkHex(_secretShare, SECRET_SHARE_NUM_BYTES)) {\n            throw SGXException(INVALID_HEX, \"Invalid Secret share\");\n        }\n        if (_publicShares.length() != (uint64_t) 256 * _t) {\n            throw SGXException(INVALID_DKG_PARAMS, \"Invalid length of public shares\");\n        }\n\n        shared_ptr <string> encryptedKeyHex_ptr = readFromDb(_ethKeyName);\n\n        if (verifyShares(_publicShares.c_str(), _secretShare.c_str(), encryptedKeyHex_ptr->c_str(), _t, _n, _index)) {\n            result[\"result\"] = true;\n        }\n    } HANDLE_SGX_EXCEPTION(result)\n\n    RETURN_SUCCESS(result)\n}\n\nJson::Value\nSGXWalletServer::createBLSPrivateKeyImpl(const string &_blsKeyName, const string &_ethKeyName, const string &_polyName,\n                                         const string &_secretShare, int _t, int _n) {\n    spdlog::info(\"Entering {}\", __FUNCTION__);\n    INIT_RESULT(result)\n\n    try {\n        if (_secretShare.length() != (uint64_t) _n * 192) {\n            throw SGXException(INVALID_SECRET_SHARES_LENGTH, \"Invalid secret share length\");\n        }\n        if (!checkECDSAKeyName(_ethKeyName)) {\n            throw SGXException(INVALID_ECDSA_KEY_NAME, \"Invalid ECDSA key name\");\n        }\n        if (!checkName(_polyName, \"POLY\")) {\n            throw SGXException(INVALID_POLY_NAME, \"Invalid polynomial name\");\n        }\n        if (!checkName(_blsKeyName, \"BLS_KEY\")) {\n            throw SGXException(INVALID_BLS_NAME, \"Invalid BLS key name\");\n        }\n        if (!check_n_t(_t, _n)) {\n            throw SGXException(INVALID_DKG_PARAMS, \"Invalid DKG parameters: n or t \");\n        }\n        vector <string> sshares_vect;\n\n        shared_ptr <string> encryptedKeyHex_ptr = readFromDb(_ethKeyName);\n\n        bool res = createBLSShare(_blsKeyName, _secretShare.c_str(), encryptedKeyHex_ptr->c_str());\n        if (res) {\n            spdlog::info(\"BLS KEY SHARE CREATED \");\n        } else {\n            throw SGXException(-122, \"Error while creating BLS key share\");\n        }\n\n        for (int i = 0; i < _n; i++) {\n            string name = _polyName + \"_\" + to_string(i) + \":\";\n            LevelDB::getLevelDb()->deleteDHDKGKey(name);\n            string shareG2_name = \"shareG2_\" + _polyName + \"_\" + to_string(i) + \":\";\n            LevelDB::getLevelDb()->deleteKey(shareG2_name);\n        }\n        LevelDB::getLevelDb()->deleteKey(_polyName);\n\n    } HANDLE_SGX_EXCEPTION(result)\n\n    RETURN_SUCCESS(result);\n}\n\nJson::Value SGXWalletServer::getBLSPublicKeyShareImpl(const string &_blsKeyName) {\n    spdlog::info(\"Entering {}\", __FUNCTION__);\n    INIT_RESULT(result)\n\n    try {\n        if (!checkName(_blsKeyName, \"BLS_KEY\")) {\n            throw SGXException(INVALID_BLS_NAME, \"Invalid BLSKey name\");\n        }\n        shared_ptr <string> encryptedKeyHex_ptr = readFromDb(_blsKeyName);\n\n        vector <string> public_key_vect = getBLSPubKey(encryptedKeyHex_ptr->c_str());\n        for (uint8_t i = 0; i < 4; i++) {\n            result[\"blsPublicKeyShare\"][i] = public_key_vect.at(i);\n        }\n    } HANDLE_SGX_EXCEPTION(result)\n\n    RETURN_SUCCESS(result);\n}\n\nJson::Value SGXWalletServer::calculateAllBLSPublicKeysImpl(const Json::Value& publicShares, int t, int n) {\n    spdlog::info(\"Entering {}\", __FUNCTION__);\n    INIT_RESULT(result)\n\n    try {\n        if (!check_n_t(t, n)) {\n            throw SGXException(INVALID_DKG_PARAMS, \"Invalid DKG parameters: n or t \");\n        }\n\n        if (!publicShares.isArray()) {\n            throw SGXException(INVALID_DKG_PARAMS, \"Invalid public shares format\");\n        }\n\n        if (publicShares.size() != (uint64_t) n) {\n            throw SGXException(INVALID_DKG_PARAMS, \"Invalid length of public shares\");\n        }\n\n        for (int i = 0; i < n; ++i) {\n            if (!publicShares[i].isString()) {\n                throw SGXException(INVALID_DKG_PARAMS, \"Invalid public shares parts format\");\n            }\n\n            if (publicShares[i].asString().length() != (uint64_t) 256 * t) {\n                throw SGXException(INVALID_DKG_PARAMS, \"Invalid length of public shares parts\");\n            }\n        }\n\n        vector<string> public_shares(n);\n        for (int i = 0; i < n; ++i) {\n            public_shares[i] = publicShares[i].asString();\n        }\n\n        vector<string> public_keys = calculateAllBlsPublicKeys(public_shares);\n\n        if (public_keys.size() != (uint64_t)n) {\n            throw SGXException(UNKNOWN_ERROR, \"\");\n        }\n\n        for (int i = 0; i < n; ++i) {\n            result[\"publicKeys\"][i] = public_keys[i];\n        }\n    } HANDLE_SGX_EXCEPTION(result)\n\n    RETURN_SUCCESS(result);\n}\n\nJson::Value SGXWalletServer::complaintResponseImpl(const string &_polyName, int _ind) {\n    spdlog::info(\"Entering {}\", __FUNCTION__);\n    INIT_RESULT(result)\n\n    try {\n        if (!checkName(_polyName, \"POLY\")) {\n            throw SGXException(INVALID_POLY_NAME, \"Invalid polynomial name\");\n        }\n\n        string shareG2_name = \"shareG2_\" + _polyName + \"_\" + to_string(_ind) + \":\";\n        shared_ptr <string> shareG2_ptr = readFromDb(shareG2_name);\n\n        string DHKey = decryptDHKey(_polyName, _ind);\n\n        result[\"share*G2\"] = *shareG2_ptr;\n        result[\"dhKey\"] = DHKey;\n    } HANDLE_SGX_EXCEPTION(result)\n\n    RETURN_SUCCESS(result);\n}\n\nJson::Value SGXWalletServer::multG2Impl(const string &_x) {\n    INIT_RESULT(result)\n\n    try {\n        auto xG2_vect = mult_G2(_x);\n        for (uint8_t i = 0; i < 4; i++) {\n            result[\"x*G2\"][i] = xG2_vect.at(i);\n        }\n    } HANDLE_SGX_EXCEPTION(result)\n\n    RETURN_SUCCESS(result);\n}\n\nJson::Value SGXWalletServer::isPolyExistsImpl(const string &_polyName) {\n    spdlog::info(\"Entering {}\", __FUNCTION__);\n    INIT_RESULT(result)\n\n    result[\"IsExist\"] = false;\n\n    try {\n        shared_ptr <string> poly_str_ptr = LevelDB::getLevelDb()->readString(_polyName);\n\n        if (poly_str_ptr != nullptr) {\n            result[\"IsExist\"] = true;\n        }\n    } HANDLE_SGX_EXCEPTION(result)\n\n    RETURN_SUCCESS(result);\n}\n\nJson::Value SGXWalletServer::getServerStatusImpl() {\n    INIT_RESULT(result)\n    RETURN_SUCCESS(result)\n}\n\nJson::Value SGXWalletServer::getServerVersionImpl() {\n    INIT_RESULT(result)\n    result[\"version\"] = TOSTRING(SGXWALLET_VERSION);\n    RETURN_SUCCESS(result)\n}\n\nJson::Value SGXWalletServer::deleteBlsKeyImpl(const string &name) {\n    spdlog::info(\"Entering {}\", __FUNCTION__);\n    INIT_RESULT(result)\n\n    result[\"deleted\"] = false;\n    try {\n        if (!checkName(name, \"BLS_KEY\")) {\n            throw SGXException(INVALID_BLS_NAME, \"Invalid BLSKey name format\");\n        }\n        shared_ptr <string> bls_ptr = LevelDB::getLevelDb()->readString(name);\n\n        if (bls_ptr != nullptr) {\n            LevelDB::getLevelDb()->deleteKey(name);\n            result[\"deleted\"] = true;\n        } else {\n            auto error_msg = \"BLS key not found: \" + name;\n            throw SGXException(INVALID_BLS_NAME, error_msg.c_str());\n        }\n    } HANDLE_SGX_EXCEPTION(result)\n\n    RETURN_SUCCESS(result)\n}\n\nJson::Value SGXWalletServer::generateDKGPoly(const string &_polyName, int _t) {\n    return generateDKGPolyImpl(_polyName, _t);\n}\n\nJson::Value SGXWalletServer::getVerificationVector(const string &_polynomeName, int _t, int _n) {\n    return getVerificationVectorImpl(_polynomeName, _t, _n);\n}\n\nJson::Value SGXWalletServer::getSecretShare(const string &_polyName, const Json::Value &_publicKeys, int t, int n) {\n    return getSecretShareImpl(_polyName, _publicKeys, t, n);\n}\n\nJson::Value\nSGXWalletServer::dkgVerification(const string &_publicShares, const string &ethKeyName, const string &SecretShare,\n                                 int t,\n                                 int n, int index) {\n    return dkgVerificationImpl(_publicShares, ethKeyName, SecretShare, t, n, index);\n}\n\nJson::Value\nSGXWalletServer::createBLSPrivateKey(const string &blsKeyName, const string &ethKeyName, const string &polyName,\n                                     const string &SecretShare, int t, int n) {\n    return createBLSPrivateKeyImpl(blsKeyName, ethKeyName, polyName, SecretShare, t, n);\n}\n\nJson::Value SGXWalletServer::getBLSPublicKeyShare(const string &blsKeyName) {\n    return getBLSPublicKeyShareImpl(blsKeyName);\n}\n\nJson::Value SGXWalletServer::calculateAllBLSPublicKeys(const Json::Value& publicShares, int t, int n) {\n    return calculateAllBLSPublicKeysImpl(publicShares, t, n);\n}\n\nJson::Value SGXWalletServer::generateECDSAKey() {\n    return generateECDSAKeyImpl();\n}\n\nJson::Value SGXWalletServer::getPublicECDSAKey(const string &_keyName) {\n    return getPublicECDSAKeyImpl(_keyName);\n}\n\nJson::Value SGXWalletServer::ecdsaSignMessageHash(int _base, const string &_keyShareName, const string &_messageHash) {\n    return ecdsaSignMessageHashImpl(_base, _keyShareName, _messageHash);\n}\n\nJson::Value\nSGXWalletServer::importBLSKeyShare(const string &_keyShare, const string &_keyShareName) {\n    return importBLSKeyShareImpl(_keyShare, _keyShareName);\n}\n\nJson::Value SGXWalletServer::blsSignMessageHash(const string &_keyShareName, const string &_messageHash, int _t, int _n) {\n    return blsSignMessageHashImpl(_keyShareName, _messageHash, _t, _n);\n}\n\nJson::Value SGXWalletServer::complaintResponse(const string &polyName, int ind) {\n    return complaintResponseImpl(polyName, ind);\n}\n\nJson::Value SGXWalletServer::multG2(const string &x) {\n    return multG2Impl(x);\n}\n\nJson::Value SGXWalletServer::isPolyExists(const string &polyName) {\n    return isPolyExistsImpl(polyName);\n}\n\nJson::Value SGXWalletServer::getServerStatus() {\n    return getServerStatusImpl();\n}\n\nJson::Value SGXWalletServer::getServerVersion() {\n    return getServerVersionImpl();\n}\n\nJson::Value SGXWalletServer::deleteBlsKey(const string &name) {\n    return deleteBlsKeyImpl(name);\n}\n\nshared_ptr <string> SGXWalletServer::readFromDb(const string &name, const string &prefix) {\n    auto dataStr = LevelDB::getLevelDb()->readString(prefix + name);\n\n    if (dataStr == nullptr) {\n        throw SGXException(KEY_SHARE_DOES_NOT_EXIST, \"Data with this name does not exist\");\n    }\n\n    return dataStr;\n}\n\nvoid SGXWalletServer::writeKeyShare(const string &_keyShareName, const string &_value) {\n    if (LevelDB::getLevelDb()->readString(_keyShareName) != nullptr) {\n        throw SGXException(KEY_SHARE_ALREADY_EXISTS, \"Key share with this name already exists\");\n    }\n\n    LevelDB::getLevelDb()->writeString(_keyShareName, _value);\n}\n\nvoid SGXWalletServer::writeDataToDB(const string &name, const string &value) {\n    if (LevelDB::getLevelDb()->readString(name) != nullptr) {\n        throw SGXException(KEY_NAME_ALREADY_EXISTS, \"Name already exists\");\n    }\n\n    LevelDB::getLevelDb()->writeString(name, value);\n}\n", "/*\n    Copyright (C) 2019-Present SKALE Labs\n\n    This file is part of sgxwallet.\n\n    sgxwallet is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    sgxwallet is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with sgxwallet.  If not, see <https://www.gnu.org/licenses/>.\n\n    @file AESUtils.c\n    @author Stan Kladko\n    @date 2020\n*/\n\n\n#include \"sgx_trts.h\"\n#include \"sgx_tcrypto.h\"\n#include \"stdlib.h\"\n#include <string.h>\n\n\n#include \"AESUtils.h\"\n\nsgx_aes_gcm_128bit_key_t AES_key;\nsgx_aes_gcm_128bit_key_t AES_DH_key;\n\n\n#define SAFE_CHAR_BUF(__X__, __Y__)  ;char __X__ [ __Y__ ]; memset(__X__, 0, __Y__);\n\nint AES_encrypt(char *message, uint8_t *encr_message, uint64_t encrBufLen, unsigned  char type,\n                unsigned char decryptable, uint64_t* resultLen) {\n\n\n\n    if (!type) {\n        LOG_ERROR(\"Null type in AES_encrypt\");\n        return -1;\n    }\n\n    if (!message) {\n        LOG_ERROR(\"Null message in AES_encrypt\");\n        return -1;\n    }\n\n    if (!encr_message) {\n        LOG_ERROR(\"Null encr message in AES_encrypt\");\n        return -2;\n    }\n\n    uint64_t len = strlen(message) + 1;\n\n    if (2 + len + SGX_AESGCM_MAC_SIZE + SGX_AESGCM_IV_SIZE > encrBufLen ) {\n        LOG_ERROR(\"Output buffer too small\");\n        return -3;\n    }\n\n    SAFE_CHAR_BUF(fullMessage, len + 2);\n\n    fullMessage[0] = type;\n    fullMessage[1] = decryptable;\n\n    strncpy(fullMessage + 2, message, len );\n\n    len = len + 2;\n    message = fullMessage;\n\n    sgx_read_rand(encr_message + SGX_AESGCM_MAC_SIZE, SGX_AESGCM_IV_SIZE);\n\n    sgx_status_t status = sgx_rijndael128GCM_encrypt(&AES_key, (uint8_t*)message, len,\n                                                     encr_message + SGX_AESGCM_MAC_SIZE + SGX_AESGCM_IV_SIZE,\n                                                     encr_message + SGX_AESGCM_MAC_SIZE, SGX_AESGCM_IV_SIZE,\n                                                     NULL, 0,\n                                                     (sgx_aes_gcm_128bit_tag_t *) encr_message);\n\n    *resultLen = len + SGX_AESGCM_MAC_SIZE + SGX_AESGCM_IV_SIZE;\n\n    return status;\n}\n\nint AES_decrypt(uint8_t *encr_message, uint64_t length, char *message, uint64_t msgLen) {\n\n    if (!message) {\n        LOG_ERROR(\"Null message in AES_encrypt\");\n        return -1;\n    }\n\n    if (!encr_message) {\n        LOG_ERROR(\"Null encr message in AES_encrypt\");\n        return -2;\n    }\n\n\n  if (length < SGX_AESGCM_MAC_SIZE + SGX_AESGCM_IV_SIZE) {\n      LOG_ERROR(\"length < SGX_AESGCM_MAC_SIZE - SGX_AESGCM_IV_SIZE\");\n      return -1;\n  }\n\n\n\n  uint64_t len = length - SGX_AESGCM_MAC_SIZE - SGX_AESGCM_IV_SIZE;\n\n  if (msgLen < len) {\n        LOG_ERROR(\"Output buffer not large enough\");\n        return -2;\n  }\n\n  sgx_status_t status = sgx_rijndael128GCM_decrypt(&AES_key,\n                                                   encr_message + SGX_AESGCM_MAC_SIZE + SGX_AESGCM_IV_SIZE, len,\n                                                   (unsigned char*) message,\n                                                   encr_message + SGX_AESGCM_MAC_SIZE, SGX_AESGCM_IV_SIZE,\n                                                   NULL, 0,\n                                                   (sgx_aes_gcm_128bit_tag_t *)encr_message);\n\n  for (int i = 2; i < strlen(message) + 1; i++) {\n      message[i - 2 ] = message[i];\n  }\n\n  return status;\n}\n\n\n\n\n\n\n\n\n\n\n\n\nvoid derive_DH_Key() {\n    memcpy(AES_DH_key, AES_key, SGX_AESGCM_KEY_SIZE );\n    /*AES_DH_key[1] = 1;AES_DH_key[2] = 2;*/\n}\n\n", "/*\n    Copyright (C) 2019-Present SKALE Labs\n\n    This file is part of sgxwallet.\n\n    sgxwallet is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    sgxwallet is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with sgxwallet.  If not, see <https://www.gnu.org/licenses/>.\n\n    @file AESUtils.h\n    @author Stan Kladko\n    @date 2020\n*/\n\n#ifndef SGXD_AESUTILS_H\n#define SGXD_AESUTILS_H\n\nextern sgx_aes_gcm_128bit_key_t AES_key;\nextern sgx_aes_gcm_128bit_key_t AES_DH_key;\n\nint AES_encrypt(char *message, uint8_t *encr_message, uint64_t encrLen,\n                unsigned char type, unsigned char decryptable, uint64_t* resultLen);\nint AES_decrypt(uint8_t *encr_message, uint64_t length, char *message, uint64_t msgLen) ;\n\nint AES_encrypt_DH(char *message, uint8_t *encr_message, uint64_t encrLen);\nint AES_decrypt_DH(uint8_t *encr_message, uint64_t length, char *message, uint64_t msgLen) ;\n\nvoid derive_DH_Key();\n\n#define ECDSA '1'\n#define BLS '2'\n#define DKG '3'\n\n#define DECRYPTABLE '1'\n#define NON_DECRYPTABLE '2'\n\n\n\n#endif //SGXD_AESUTILS_H\n", "/*\n\nModifications Copyright (C) 2019-2020 SKALE Labs\n\nCopyright 2018 Intel Corporation\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\n1. Redistributions of source code must retain the above copyright\nnotice, this list of conditions and the following disclaimer.\n\n2. Redistributions in binary form must reproduce the above copyright\nnotice, this list of conditions and the following disclaimer in the\ndocumentation and/or other materials provided with the distribution.\n\n3. Neither the name of the copyright holder nor the names of its\ncontributors may be used to endorse or promote products derived from\nthis software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\nIS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED\nTO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A\nPARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nHOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED\nTO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\nPROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\nLIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\nNEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n*/\n\n#include <math.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdbool.h>\n#include <assert.h>\n\n#include \"secure_enclave_t.h\"\n#include \"sgx_tcrypto.h\"\n#include \"sgx_tseal.h\"\n#include <sgx_tgmp.h>\n#include <sgx_trts.h>\n\n#include <sgx_key.h>\n\n#include \"Point.h\"\n#include \"DomainParameters.h\"\n\n#include \"Signature.h\"\n#include \"Curves.h\"\n#include \"DHDkg.h\"\n#include \"AESUtils.h\"\n\n#include \"EnclaveConstants.h\"\n#include \"EnclaveCommon.h\"\n#include \"SIGNED_ENCLAVE_VERSION\"\n\n\n#define STRINGIFY(x) #x\n#define TOSTRING(x) STRINGIFY(x)\n\n#define INIT_ERROR_STATE *errString = 0; *errStatus = UNKNOWN_ERROR;\n#define SET_SUCCESS *errStatus = 0;\n\n\n#define CHECK_STATE(_EXPRESSION_) \\\n    if (!(_EXPRESSION_)) {        \\\n        LOG_ERROR(\"State check failed::\");LOG_ERROR(#_EXPRESSION_); \\\n        LOG_ERROR((const char*) __FILE__); \\\n        snprintf(errString, BUF_LEN, \"State check failed. Check log.\"); \\\n        *errStatus = -1;                          \\\n        return;}\n\n#define CHECK_STATE_CLEAN(_EXPRESSION_) \\\n    if (!(_EXPRESSION_)) {        \\\n        LOG_ERROR(\"State check failed::\");LOG_ERROR(#_EXPRESSION_); \\\n        LOG_ERROR(__FILE__); LOG_ERROR(__LINE__);                   \\\n        snprintf(errString, BUF_LEN, \"State check failed. Check log.\"); \\\n        *errStatus = -1;                          \\\n        goto clean;}\n\n#define CHECK_STATUS(__ERRMESSAGE__) if (status != SGX_SUCCESS) { \\\nLOG_ERROR(__FUNCTION__); \\\nsnprintf(errString, BUF_LEN, \"failed with status %d : %s\",  status,  __ERRMESSAGE__); \\\nLOG_ERROR(errString); \\\n*errStatus = status; \\\ngoto clean; \\\n};\n\n\n#define CHECK_STATUS2(__ERRMESSAGE__) if (status != SGX_SUCCESS) { \\\nsnprintf(errString, BUF_LEN, __ERRMESSAGE__, status); \\\nLOG_ERROR(errString); \\\n*errStatus = status; \\\ngoto clean; \\\n};\n\nvoid *(*gmp_realloc_func)(void *, size_t, size_t);\n\nvoid *(*oc_realloc_func)(void *, size_t, size_t);\n\nvoid (*gmp_free_func)(void *, size_t);\n\nvoid (*oc_free_func)(void *, size_t);\n\nvoid *reallocate_function(void *, size_t, size_t);\n\nvoid free_function(void *, size_t);\n\nunsigned char *globalRandom = NULL;\n\n\n#define CALL_ONCE \\\n    static volatile bool called = false;\\\n    if (called)  { \\\n        LOG_ERROR(__FUNCTION__); \\\n        LOG_ERROR(\"This function shouldnt be called twice. Aborting!\"); \\\n        abort(); \\\n    } else {called = true;};\n\nvoid trustedEnclaveInit(uint64_t _logLevel) {\n    CALL_ONCE\n    LOG_INFO(__FUNCTION__);\n\n    globalLogLevel_ = _logLevel;\n\n    oc_realloc_func = &reallocate_function;\n    oc_free_func = &free_function;\n\n    LOG_INFO(\"Setting memory functions\");\n\n    mp_get_memory_functions(NULL, &gmp_realloc_func, &gmp_free_func);\n    mp_set_memory_functions(NULL, oc_realloc_func, oc_free_func);\n\n    LOG_INFO(\"Calling enclave init\");\n\n\n    enclave_init();\n\n\n    LOG_INFO(\"Reading random\");\n\n    globalRandom = calloc(32,1);\n\n    int ret = sgx_read_rand(globalRandom, 32);\n\n    if(ret != SGX_SUCCESS)\n    {\n        LOG_ERROR(\"sgx_read_rand failed. Aboring enclave.\");\n        abort();\n    }\n\n    LOG_INFO(\"Successfully inited enclave. Signed enclave version:\" SIGNED_ENCLAVE_VERSION );\n#ifndef SGX_DEBUG\n    LOG_INFO(\"SECURITY WARNING: sgxwallet is running in INSECURE DEBUG MODE! NEVER USE IN PRODUCTION!\");\n#endif\n\n#if SGX_DEBUG != 0\n    LOG_INFO(\"SECURITY WARNING: sgxwallet is running in INSECURE DEBUG MODE! NEVER USE IN PRODUCTION!\");\n#endif\n\n#if SGX_MODE == SIM\n    LOG_INFO(\"SECURITY WARNING: sgxwallet is running in INSECURE SIMULATION MODE! NEVER USE IN PRODUCTION!\");\n#endif\n\n\n\n\n\n\n}\n\nvoid free_function(void *ptr, size_t sz) {\n    if (sgx_is_within_enclave(ptr, sz))\n        gmp_free_func(ptr, sz);\n    else {\n        sgx_status_t status;\n\n        status = oc_free(ptr, sz);\n        if (status != SGX_SUCCESS)\n            abort();\n    }\n}\n\nvoid *reallocate_function(void *ptr, size_t osize, size_t nsize) {\n    uint64_t nptr;\n    sgx_status_t status;\n\n    if (sgx_is_within_enclave(ptr, osize)) {\n        return gmp_realloc_func(ptr, osize, nsize);\n    }\n\n    status = oc_realloc(&nptr, ptr, osize, nsize);\n    if (status != SGX_SUCCESS)\n        abort();\n\n    /*\n     * If the entire range of allocated memory is not outside the enclave\n     * then something truly terrible has happened. In theory, we could\n     * free() and try again, but would you trust the OS at this point?\n     */\n\n    if (!sgx_is_outside_enclave((void *) ptr, nsize))\n        abort();\n\n    return (void *) nptr;\n}\n\nvoid get_global_random(unsigned char *_randBuff, uint64_t _size) {\n    char errString[BUF_LEN];\n    int status;\n    int *errStatus = &status;\n\n    INIT_ERROR_STATE\n\n    CHECK_STATE(_size <= 32)\n    CHECK_STATE(_randBuff);\n\n    sgx_sha_state_handle_t shaStateHandle;\n\n    CHECK_STATE(sgx_sha256_init(&shaStateHandle) == SGX_SUCCESS);\n    CHECK_STATE(sgx_sha256_update(globalRandom, 32, shaStateHandle) == SGX_SUCCESS);\n    CHECK_STATE(sgx_sha256_get_hash(shaStateHandle, (sgx_sha256_hash_t *)globalRandom) == SGX_SUCCESS);\n    CHECK_STATE(sgx_sha256_close(shaStateHandle) == SGX_SUCCESS);\n\n    memcpy(_randBuff, globalRandom, _size);\n}\n\n\nvoid sealHexSEK(int *errStatus, char *errString,\n                        uint8_t *encrypted_sek, uint64_t *enc_len, char *sek_hex) {\n    CALL_ONCE\n    LOG_INFO(__FUNCTION__);\n    INIT_ERROR_STATE\n\n    CHECK_STATE(encrypted_sek);\n    CHECK_STATE(sek_hex);\n    CHECK_STATE(strnlen(sek_hex, 33) == 32)\n    \n\n    uint64_t plaintextLen = strlen(sek_hex) + 1;\n    \n    uint64_t sealedLen = sgx_calc_sealed_data_size(0, plaintextLen);\n\n    sgx_attributes_t attribute_mask;\n    attribute_mask.flags = 0xfffffffffffffff3;\n    attribute_mask.xfrm = 0x0;\n    sgx_misc_select_t misc = 0xF0000000;\n\n    sgx_status_t status = sgx_seal_data_ex(SGX_KEYPOLICY_MRENCLAVE, attribute_mask, misc, 0, NULL, plaintextLen, (uint8_t *) sek_hex, sealedLen,\n                                           (sgx_sealed_data_t *) encrypted_sek);\n    CHECK_STATUS(\"seal SEK failed after SEK generation\");\n\n    uint64_t encrypt_text_length = sgx_get_encrypt_txt_len((const sgx_sealed_data_t *)encrypted_sek);\n\n    CHECK_STATE(encrypt_text_length = plaintextLen);\n\n\n    SAFE_CHAR_BUF(unsealedKey, BUF_LEN);\n    uint32_t decLen = BUF_LEN;\n\n    uint64_t add_text_length = sgx_get_add_mac_txt_len((const sgx_sealed_data_t *)encrypted_sek);\n    CHECK_STATE(add_text_length == 0);\n    CHECK_STATE(sgx_is_within_enclave(encrypted_sek,sizeof(sgx_sealed_data_t)));\n    status = sgx_unseal_data((const sgx_sealed_data_t *)encrypted_sek, NULL, NULL,\n                             (uint8_t *) unsealedKey, &decLen );\n\n    CHECK_STATUS(\"seal/unseal SEK failed after SEK generation in unseal\");\n    *enc_len = sealedLen;\n\n    SET_SUCCESS\n    clean:\n    LOG_INFO(__FUNCTION__ );\n    LOG_INFO(\"SGX call completed\");\n}\n\nvoid trustedGenerateSEK(int *errStatus, char *errString,\n                        uint8_t *encrypted_sek, uint64_t *enc_len, char *sek_hex) {\n    CALL_ONCE\n    LOG_INFO(__FUNCTION__);\n    INIT_ERROR_STATE\n\n\n    CHECK_STATE(encrypted_sek);\n    CHECK_STATE(sek_hex);\n\n    RANDOM_CHAR_BUF(SEK_raw, SGX_AESGCM_KEY_SIZE);\n\n    carray2Hex((uint8_t*) SEK_raw, SGX_AESGCM_KEY_SIZE, sek_hex);\n    memcpy(AES_key, SEK_raw, SGX_AESGCM_KEY_SIZE);\n    derive_DH_Key();\n\n    sealHexSEK(errStatus, errString, encrypted_sek, enc_len, sek_hex);\n\n    if (*errStatus != 0) {\n        LOG_ERROR(\"sealHexSEK failed\");\n        goto clean;\n    }\n\n    SET_SUCCESS\n    clean:\n    LOG_INFO(__FUNCTION__ );\n    LOG_INFO(\"SGX call completed\");\n}\n\nvoid trustedSetSEK(int *errStatus, char *errString, uint8_t *encrypted_sek) {\n    CALL_ONCE\n    LOG_INFO(__FUNCTION__);\n    INIT_ERROR_STATE\n    CHECK_STATE(encrypted_sek);\n    SAFE_CHAR_BUF(aes_key_hex, BUF_LEN);\n\n    uint32_t dec_len = BUF_LEN;\n\n    sgx_status_t status = sgx_unseal_data(\n            (const sgx_sealed_data_t *) encrypted_sek, NULL, 0,\n            (uint8_t *)aes_key_hex, &dec_len);\n\n    if (status == 0x3001) {\n        LOG_ERROR(\"Could not decrypt LevelDB storage! \\n\"\n                  \"If you upgraded sgxwallet software or if you are restoring from backup, please run sgxwallet with -b flag  and \"\n                  \"pass your backup key.\");\n    }\n\n    CHECK_STATUS2(\"sgx unseal SEK failed with status %d\");\n\n    uint64_t len;\n\n\n    hex2carray(aes_key_hex, &len, (uint8_t *) AES_key);\n    derive_DH_Key();\n\n    SET_SUCCESS\n    clean:\n    LOG_INFO(__FUNCTION__ );\n    LOG_INFO(\"SGX call completed\");\n}\n\nvoid trustedSetSEK_backup(int *errStatus, char *errString,\n                          uint8_t *encrypted_sek, uint64_t *enc_len, const char *sek_hex) {\n    CALL_ONCE\n    LOG_INFO(__FUNCTION__);\n    INIT_ERROR_STATE\n\n    CHECK_STATE(encrypted_sek);\n    CHECK_STATE(sek_hex);\n\n    uint64_t len;\n    hex2carray(sek_hex, &len, (uint8_t *) AES_key);\n    derive_DH_Key();\n\n    sealHexSEK(errStatus, errString, encrypted_sek, enc_len, (char *)sek_hex);\n\n    if (*errStatus != 0) {\n        LOG_ERROR(\"sealHexSEK failed\");\n        goto clean;\n    }\n\n    SET_SUCCESS\n    clean:\n    ;\n    LOG_INFO(__FUNCTION__ );\n    LOG_INFO(\"SGX call completed\");\n}\n\n\n\nvoid trustedGenerateEcdsaKeyAES(int *errStatus, char *errString,\n                                uint8_t *encryptedPrivateKey, uint64_t *enc_len, char *pub_key_x, char *pub_key_y) {\n    LOG_INFO(__FUNCTION__);\n    INIT_ERROR_STATE\n\n    CHECK_STATE(encryptedPrivateKey);\n    CHECK_STATE(pub_key_x);\n    CHECK_STATE(pub_key_y);\n\n    RANDOM_CHAR_BUF(rand_char, 32);\n\n    mpz_t seed;\n    mpz_init(seed);\n    mpz_t skey;\n    mpz_init(skey);\n\n    point Pkey = point_init();\n\n    mpz_import(seed, 32, 1, sizeof(rand_char[0]), 0, 0, rand_char);\n\n    mpz_mod(skey, seed, curve->p);\n\n    signature_extract_public_key(Pkey, skey, curve);\n\n    SAFE_CHAR_BUF(arr_x, BUF_LEN);\n    mpz_get_str(arr_x, ECDSA_SKEY_BASE, Pkey->x);\n    int n_zeroes = 64 - strlen(arr_x);\n    for (int i = 0; i < n_zeroes; i++) {\n        pub_key_x[i] = '0';\n    }\n\n    strncpy(pub_key_x + n_zeroes, arr_x, 1024 - n_zeroes);\n\n    SAFE_CHAR_BUF(arr_y, BUF_LEN);\n    mpz_get_str(arr_y, ECDSA_SKEY_BASE, Pkey->y);\n    n_zeroes = 64 - strlen(arr_y);\n    for (int i = 0; i < n_zeroes; i++) {\n        pub_key_y[i] = '0';\n    }\n    strncpy(pub_key_y + n_zeroes, arr_y, 1024 - n_zeroes);\n\n    SAFE_CHAR_BUF(skey_str, BUF_LEN);\n    SAFE_CHAR_BUF(arr_skey_str, mpz_sizeinbase(skey, ECDSA_SKEY_BASE) + 2);\n    mpz_get_str(arr_skey_str, ECDSA_SKEY_BASE, skey);\n    n_zeroes = 64 - strlen(arr_skey_str);\n    for (int i = 0; i < n_zeroes; i++) {\n        skey_str[i] = '0';\n    }\n    strncpy(skey_str + n_zeroes, arr_skey_str, 65 - n_zeroes);\n    snprintf(errString, BUF_LEN, \"skey len is %d\\n\", (int) strlen(skey_str));\n\n    int status = AES_encrypt((char *) skey_str, encryptedPrivateKey, BUF_LEN,\n                             ECDSA, NON_DECRYPTABLE, enc_len);\n    CHECK_STATUS(\"ecdsa private key encryption failed\");\n\n    status = AES_decrypt(encryptedPrivateKey, *enc_len, skey_str, BUF_LEN);\n\n    CHECK_STATUS2(\"ecdsa private key decr failed with status %d\");\n\n    SET_SUCCESS\n    clean:\n    mpz_clear(seed);\n    mpz_clear(skey);\n    point_clear(Pkey);\n    LOG_INFO(__FUNCTION__ );\n    LOG_INFO(\"SGX call completed\");\n}\n\nvoid trustedGetPublicEcdsaKeyAES(int *errStatus, char *errString,\n                                 uint8_t *encryptedPrivateKey, uint64_t enc_len, char *pub_key_x, char *pub_key_y) {\n    LOG_DEBUG(__FUNCTION__);\n    INIT_ERROR_STATE\n\n    SAFE_CHAR_BUF(skey, BUF_LEN);\n\n    mpz_t privateKeyMpz;\n    mpz_init(privateKeyMpz);\n    point pKey = point_init();\n\n    point pKey_test = point_init();\n\n    CHECK_STATE(encryptedPrivateKey);\n    CHECK_STATE(pub_key_x);\n    CHECK_STATE(pub_key_y);\n\n    int status = AES_decrypt(encryptedPrivateKey, enc_len, skey, BUF_LEN);\n    CHECK_STATUS2(\"AES_decrypt failed with status %d\");\n\n    skey[enc_len - SGX_AESGCM_MAC_SIZE - SGX_AESGCM_IV_SIZE] = '\\0';\n    strncpy(errString, skey, 1024);\n\n    status = mpz_set_str(privateKeyMpz, skey, ECDSA_SKEY_BASE);\n\n    CHECK_STATUS(\"mpz_set_str failed for private key\");\n\n    signature_extract_public_key(pKey, privateKeyMpz, curve);\n\n\n    point_multiplication(pKey_test, privateKeyMpz, curve->G, curve);\n\n    if (!point_cmp(pKey, pKey_test)) {\n        snprintf(errString, BUF_LEN, \"Points are not equal\");\n        LOG_ERROR(errString);\n        *errStatus = -11;\n        goto clean;\n    }\n\n    SAFE_CHAR_BUF(arr_x, BUF_LEN);\n    mpz_get_str(arr_x, ECDSA_SKEY_BASE, pKey->x);\n\n    int n_zeroes = 64 - strlen(arr_x);\n    for (int i = 0; i < n_zeroes; i++) {\n        pub_key_x[i] = '0';\n    }\n\n    strncpy(pub_key_x + n_zeroes, arr_x, 1024 - n_zeroes);\n\n    SAFE_CHAR_BUF(arr_y, BUF_LEN);\n    mpz_get_str(arr_y, ECDSA_SKEY_BASE, pKey->y);\n\n    n_zeroes = 64 - strlen(arr_y);\n    for (int i = 0; i < n_zeroes; i++) {\n        pub_key_y[i] = '0';\n    }\n    strncpy(pub_key_y + n_zeroes, arr_y, 1024 - n_zeroes);\n\n    SET_SUCCESS\n    clean:\n    mpz_clear(privateKeyMpz);\n    point_clear(pKey);\n    point_clear(pKey_test);\n\n    static uint64_t counter = 0;\n\n    if (counter % 1000 == 0) {\n        LOG_INFO(__FUNCTION__);\n        LOG_INFO(\"Thousand SGX calls completed\");\n    }\n\n    counter++;\n\n}\n\nstatic uint64_t sigCounter = 0;\n\nvoid trustedEcdsaSignAES(int *errStatus, char *errString, uint8_t *encryptedPrivateKey, uint64_t enc_len,\n                         const char *hash, char *sigR, char *sigS, uint8_t *sig_v, int base) {\n    LOG_DEBUG(__FUNCTION__);\n\n    INIT_ERROR_STATE\n\n    CHECK_STATE(encryptedPrivateKey);\n    CHECK_STATE(hash);\n    CHECK_STATE(sigR);\n    CHECK_STATE(sigS);\n\n    SAFE_CHAR_BUF(skey, BUF_LEN);\n\n    mpz_t privateKeyMpz;\n    mpz_init(privateKeyMpz);\n    mpz_t msgMpz;\n    mpz_init(msgMpz);\n    signature sign = signature_init();\n\n    int status = AES_decrypt(encryptedPrivateKey, enc_len, skey, BUF_LEN);\n\n    CHECK_STATUS2(\"aes decrypt failed with status %d\");\n\n    skey[enc_len - SGX_AESGCM_MAC_SIZE - SGX_AESGCM_IV_SIZE] = '\\0';\n\n    if (mpz_set_str(privateKeyMpz, skey, ECDSA_SKEY_BASE) == -1) {\n        *errStatus = -1;\n        snprintf(errString, BUF_LEN, \"invalid secret key\");\n        LOG_ERROR(errString);\n        goto clean;\n    }\n\n    if (mpz_set_str(msgMpz, hash, 16) == -1) {\n        *errStatus = -1;\n        snprintf(errString, BUF_LEN, \"invalid message hash\");\n        LOG_ERROR(errString);\n        goto clean;\n    }\n\n    signature_sign(sign, msgMpz, privateKeyMpz, curve);\n\n    sigCounter++;\n\n    if (sigCounter % 1000 == 0) {\n\n        point Pkey = point_init();\n\n        signature_extract_public_key(Pkey, privateKeyMpz, curve);\n\n        if (!signature_verify(msgMpz, sign, Pkey, curve)) {\n            *errStatus = -2;\n            snprintf(errString, BUF_LEN, \"signature is not verified! \");\n            point_clear(Pkey);\n            goto clean;\n        }\n\n        point_clear(Pkey);\n    }\n\n    SAFE_CHAR_BUF(arrM, BUF_LEN);\n    mpz_get_str(arrM, 16, msgMpz);\n    snprintf(errString, BUF_LEN, \"message is %s \", arrM);\n\n    SAFE_CHAR_BUF(arrR, BUF_LEN);\n    mpz_get_str(arrR, base, sign->r);\n    strncpy(sigR, arrR, 1024);\n\n    SAFE_CHAR_BUF(arrS, BUF_LEN);\n    mpz_get_str(arrS, base, sign->s);\n    strncpy(sigS, arrS, 1024);\n\n    *sig_v = sign->v;\n\n    SET_SUCCESS\n    clean:\n\n    mpz_clear(privateKeyMpz);\n    mpz_clear(msgMpz);\n    signature_free(sign);\n    LOG_DEBUG(__FUNCTION__ );\n    LOG_DEBUG(\"SGX call completed\");\n}\n\n\nvoid trustedDecryptKeyAES(int *errStatus, char *errString, uint8_t *encryptedPrivateKey,\n                          uint64_t enc_len, char *key) {\n\n    LOG_DEBUG(__FUNCTION__);\n    INIT_ERROR_STATE\n\n    CHECK_STATE(encryptedPrivateKey);\n    CHECK_STATE(key);\n\n    *errStatus = -9;\n\n    int status = AES_decrypt(encryptedPrivateKey, enc_len, key, 3072);\n\n    if (status != 0) {\n        *errStatus = status;\n        snprintf(errString, BUF_LEN, \"aes decrypt failed with status %d\", status);\n        LOG_ERROR(errString);\n        goto clean;\n    }\n\n    *errStatus = -10;\n\n    uint64_t keyLen = strnlen(key, MAX_KEY_LENGTH);\n\n    if (keyLen == MAX_KEY_LENGTH) {\n        snprintf(errString, BUF_LEN, \"Key is not null terminated\");\n        LOG_ERROR(errString);\n        goto clean;\n    }\n\n    SET_SUCCESS\n    clean:\n    ;\n}\n\n\nvoid trustedEncryptKeyAES(int *errStatus, char *errString, const char *key,\n                          uint8_t *encryptedPrivateKey, uint64_t *enc_len) {\n    LOG_INFO(__FUNCTION__);\n\n    *errString = 0;\n    *errStatus = UNKNOWN_ERROR;\n\n    CHECK_STATE(key);\n    CHECK_STATE(encryptedPrivateKey);\n\n    *errStatus = UNKNOWN_ERROR;\n\n    int status = AES_encrypt((char *)key, encryptedPrivateKey, BUF_LEN,\n                             DKG, DECRYPTABLE, enc_len);\n\n    CHECK_STATUS2(\"AES encrypt failed with status %d\");\n\n    SAFE_CHAR_BUF(decryptedKey, BUF_LEN);\n\n    status = AES_decrypt(encryptedPrivateKey, *enc_len, decryptedKey, BUF_LEN);\n\n    CHECK_STATUS2(\"trustedDecryptKey failed with status %d\");\n\n    uint64_t decryptedKeyLen = strnlen(decryptedKey, MAX_KEY_LENGTH);\n\n    if (decryptedKeyLen == MAX_KEY_LENGTH) {\n        snprintf(errString, BUF_LEN, \"Decrypted key is not null terminated\");\n        LOG_ERROR(errString);\n        goto clean;\n    }\n\n    *errStatus = -8;\n\n    if (strncmp(key, decryptedKey, MAX_KEY_LENGTH) != 0) {\n        snprintf(errString, BUF_LEN, \"Decrypted key does not match original key\");\n        LOG_ERROR(key);\n        LOG_ERROR(decryptedKey);\n        LOG_ERROR(errString);\n        goto clean;\n    }\n\n    SET_SUCCESS\n    clean:\n    ;\n    LOG_INFO(__FUNCTION__ );\n    LOG_INFO(\"SGX call completed\");\n}\n\n\nvoid trustedBlsSignMessageAES(int *errStatus, char *errString, uint8_t *encryptedPrivateKey,\n                              uint64_t enc_len, char *_hashX,\n                              char *_hashY, char *signature) {\n    LOG_DEBUG(__FUNCTION__);\n    INIT_ERROR_STATE\n\n    CHECK_STATE(encryptedPrivateKey);\n    CHECK_STATE(_hashX);\n    CHECK_STATE(_hashY);\n    CHECK_STATE(signature);\n\n    SAFE_CHAR_BUF(key, BUF_LEN);SAFE_CHAR_BUF(sig, BUF_LEN);\n\n    int status = AES_decrypt(encryptedPrivateKey, enc_len, key, BUF_LEN);\n\n    CHECK_STATUS(\"AES decrypt failed\")\n\n    if (!enclave_sign(key, _hashX, _hashY, sig)) {\n        strncpy(errString, \"Enclave failed to create bls signature\", BUF_LEN);\n        LOG_ERROR(errString);\n        *errStatus = -1;\n        goto clean;\n    }\n\n    strncpy(signature, sig, BUF_LEN);\n\n    if (strnlen(signature, BUF_LEN) < 10) {\n        strncpy(errString, \"Signature too short\", BUF_LEN);\n        LOG_ERROR(errString);\n        *errStatus = -1;\n        goto clean;\n    }\n\n    SET_SUCCESS\n\n    LOG_DEBUG(\"SGX call completed\");\n\n    clean:\n    ;\n    LOG_DEBUG(\"SGX call completed\");\n}\n\nvoid\ntrustedGenDkgSecretAES(int *errStatus, char *errString, uint8_t *encrypted_dkg_secret, uint64_t *enc_len, size_t _t) {\n    LOG_INFO(__FUNCTION__);\n    INIT_ERROR_STATE\n\n    CHECK_STATE(encrypted_dkg_secret);\n\n    SAFE_CHAR_BUF(dkg_secret, DKG_BUFER_LENGTH);\n\n    int status = gen_dkg_poly(dkg_secret, _t);\n\n    CHECK_STATUS(\"gen_dkg_poly failed\")\n\n    status = AES_encrypt(dkg_secret, encrypted_dkg_secret, 3 * BUF_LEN,\n                         DKG, DECRYPTABLE, enc_len);\n\n    CHECK_STATUS(\"SGX AES encrypt DKG poly failed\");\n\n\n\n    SAFE_CHAR_BUF(decr_dkg_secret, DKG_BUFER_LENGTH);\n\n    status = AES_decrypt(encrypted_dkg_secret, *enc_len, decr_dkg_secret,\n                         DKG_BUFER_LENGTH);\n\n    CHECK_STATUS(\"aes decrypt dkg poly failed\");\n\n    if (strcmp(dkg_secret, decr_dkg_secret) != 0) {\n        snprintf(errString, BUF_LEN,\n                 \"encrypted poly is not equal to decrypted poly\");\n        LOG_ERROR(errString);\n        *errStatus = -333;\n        goto clean;\n    }\n\n    SET_SUCCESS\n    clean:\n    ;\n    LOG_INFO(__FUNCTION__ );\n    LOG_INFO(\"SGX call completed\");\n}\n\nvoid\ntrustedDecryptDkgSecretAES(int *errStatus, char *errString, uint8_t *encrypted_dkg_secret,\n                           uint64_t enc_len,\n                           uint8_t *decrypted_dkg_secret) {\n    LOG_INFO(__FUNCTION__);\n    INIT_ERROR_STATE\n\n    CHECK_STATE(encrypted_dkg_secret);\n    CHECK_STATE(decrypted_dkg_secret);\n\n    int status = AES_decrypt(encrypted_dkg_secret, enc_len, (char *) decrypted_dkg_secret,\n                             3072);\n\n    CHECK_STATUS2(\"aes decrypt data - encrypted_dkg_secret failed with status %d\")\n\n    SET_SUCCESS\n\n    clean:\n    ;\n    LOG_INFO(__FUNCTION__ );\n    LOG_INFO(\"SGX call completed\");\n}\n\n\nvoid trustedSetEncryptedDkgPolyAES(int *errStatus, char *errString, uint8_t *encrypted_poly, uint64_t enc_len) {\n    LOG_INFO(__FUNCTION__);\n    INIT_ERROR_STATE\n\n    CHECK_STATE(encrypted_poly);\n\n    memset(getThreadLocalDecryptedDkgPoly(), 0, DKG_BUFER_LENGTH);\n\n    int status = AES_decrypt(encrypted_poly, enc_len, (char *) getThreadLocalDecryptedDkgPoly(),\n                             DKG_BUFER_LENGTH);\n\n    CHECK_STATUS2(\"sgx_unseal_data - encrypted_poly failed with status %d\")\n\n    SET_SUCCESS\n    clean:\n    ;\n    LOG_INFO(__FUNCTION__ );\n    LOG_INFO(\"SGX call completed\");\n}\n\nvoid trustedGetEncryptedSecretShareAES(int *errStatus, char *errString, uint8_t *encrypted_skey, uint64_t *dec_len,\n                                       char *result_str, char *s_shareG2, char *pub_keyB, uint8_t _t, uint8_t _n,\n                                       uint8_t ind) {\n\n    LOG_INFO(__FUNCTION__);\n    INIT_ERROR_STATE\n\n    uint64_t enc_len;\n    int status;\n\n    CHECK_STATE(encrypted_skey);\n    CHECK_STATE(result_str);\n    CHECK_STATE(s_shareG2);\n    CHECK_STATE(pub_keyB);\n\n    LOG_DEBUG(__FUNCTION__);\n\n    SAFE_CHAR_BUF(skey, BUF_LEN);\n\n    SAFE_CHAR_BUF(pub_key_x, BUF_LEN);SAFE_CHAR_BUF(pub_key_y, BUF_LEN);\n\n    trustedGenerateEcdsaKeyAES(&status, errString, encrypted_skey, &enc_len, pub_key_x, pub_key_y);\n\n    CHECK_STATUS(\"trustedGenerateEcdsaKeyAES failed\");\n\n    status = AES_decrypt(encrypted_skey, enc_len, skey, BUF_LEN);\n\n    skey[ECDSA_SKEY_LEN - 1] = 0;\n\n    CHECK_STATUS2(\"AES_decrypt failed (in trustedGetEncryptedSecretShareAES) with status %d\");\n\n    *dec_len = enc_len;\n\n    SAFE_CHAR_BUF(common_key, BUF_LEN);\n\n    status = gen_session_key(skey, pub_keyB, common_key);\n\n    CHECK_STATUS(\"gen_session_key failed\")\n\n    SAFE_CHAR_BUF(s_share, BUF_LEN);\n\n    status = calc_secret_share(getThreadLocalDecryptedDkgPoly(), s_share, _t, _n, ind);\n    CHECK_STATUS(\"calc secret share failed\")\n\n\n    status = calc_secret_shareG2(s_share, s_shareG2);\n    CHECK_STATUS(\"invalid decr secret share\");\n\n    SAFE_CHAR_BUF(cypher, BUF_LEN);\n    status=xor_encrypt(common_key, s_share, cypher);\n\n    CHECK_STATUS(\"xor_encrypt failed\")\n\n    strncpy(result_str, cypher, strlen(cypher));\n    strncpy(result_str + strlen(cypher), pub_key_x, strlen(pub_key_x));\n    strncpy(result_str + strlen(pub_key_x) + strlen(pub_key_y), pub_key_y, strlen(pub_key_y));\n\n    SET_SUCCESS\n\n    clean:\n    ;\n    LOG_INFO(__FUNCTION__ );\n    LOG_INFO(\"SGX call completed\");\n}\n\nvoid trustedGetPublicSharesAES(int *errStatus, char *errString, uint8_t *encrypted_dkg_secret, uint64_t enc_len,\n                               char *public_shares,\n                               unsigned _t, unsigned _n) {\n    LOG_INFO(__FUNCTION__);\n\n    INIT_ERROR_STATE\n\n    CHECK_STATE(encrypted_dkg_secret);\n    CHECK_STATE(public_shares);\n    CHECK_STATE(_t <= _n && _n > 0)\n\n    SAFE_CHAR_BUF(decrypted_dkg_secret, DKG_MAX_SEALED_LEN);\n\n    int status = AES_decrypt(encrypted_dkg_secret, enc_len, decrypted_dkg_secret,\n                             DKG_MAX_SEALED_LEN);\n\n    CHECK_STATUS2(\"aes decrypt data - encrypted_dkg_secret failed with status %d\");\n\n    status = calc_public_shares(decrypted_dkg_secret, public_shares, _t) != 0;\n    CHECK_STATUS(\"t does not match polynomial in db\");\n\n    SET_SUCCESS\n\n    clean:\n    ;\n    LOG_INFO(\"SGX call completed\");\n}\n\nvoid trustedDkgVerifyAES(int *errStatus, char *errString, const char *public_shares, const char *s_share,\n                         uint8_t *encryptedPrivateKey, uint64_t enc_len, unsigned _t, int _ind, int *result) {\n    LOG_INFO(__FUNCTION__);\n\n    INIT_ERROR_STATE\n\n    CHECK_STATE(public_shares);\n    CHECK_STATE(s_share);\n    CHECK_STATE(encryptedPrivateKey);\n\n    SAFE_CHAR_BUF(skey,BUF_LEN);\n\n    mpz_t s;\n    mpz_init(s);\n\n    int status = AES_decrypt(encryptedPrivateKey, enc_len, skey, BUF_LEN);\n\n    CHECK_STATUS2(\"AES_decrypt failed (in trustedDkgVerifyAES) with status %d\");\n\n    SAFE_CHAR_BUF(encr_sshare, BUF_LEN);\n\n    strncpy(encr_sshare, s_share, ECDSA_SKEY_LEN - 1);\n\n    SAFE_CHAR_BUF(common_key, BUF_LEN);\n\n    status = session_key_recover(skey, s_share, common_key);\n\n    CHECK_STATUS(\"session_key_recover failed\");\n\n    SAFE_CHAR_BUF(decr_sshare, BUF_LEN);\n\n    status=xor_decrypt(common_key, encr_sshare, decr_sshare);\n\n    CHECK_STATUS(\"xor_decrypt failed\")\n\n\n    status  = mpz_set_str(s, decr_sshare, 16);\n    CHECK_STATUS(\"invalid decr secret share\");\n\n    *result = Verification(public_shares, s, _t, _ind);\n\n    SET_SUCCESS\n    clean:\n\n    mpz_clear(s);\n    LOG_INFO(__FUNCTION__ );\n    LOG_INFO(\"SGX call completed\");\n}\n\nvoid trustedCreateBlsKeyAES(int *errStatus, char *errString, const char *s_shares,\n                            uint8_t *encryptedPrivateKey, uint64_t key_len, uint8_t *encr_bls_key,\n                            uint64_t *enc_bls_key_len) {\n\n    LOG_INFO(__FUNCTION__);\n\n    INIT_ERROR_STATE\n\n    CHECK_STATE(s_shares);\n    CHECK_STATE(encryptedPrivateKey);\n    CHECK_STATE(encr_bls_key);\n\n    SAFE_CHAR_BUF(skey, BUF_LEN);\n\n    mpz_t sum;\n    mpz_init(sum);\n    mpz_set_ui(sum, 0);\n\n    mpz_t q;\n    mpz_init(q);\n    mpz_set_str(q, \"21888242871839275222246405745257275088548364400416034343698204186575808495617\", 10);\n\n    mpz_t bls_key;\n    mpz_init(bls_key);\n\n\n    int status = AES_decrypt(encryptedPrivateKey, key_len, skey, BUF_LEN);\n    CHECK_STATUS2(\"aes decrypt failed with status %d\");\n\n    skey[ECDSA_SKEY_LEN - 1] = 0;\n\n    int num_shares = strlen(s_shares) / 192;\n\n    for (int i = 0; i < num_shares; i++) { SAFE_CHAR_BUF(encr_sshare, 65);\n        strncpy(encr_sshare, s_shares + 192 * i, 64);\n        encr_sshare[64] = 0;\n\n        SAFE_CHAR_BUF(s_share, 193);\n        strncpy(s_share, s_shares + 192 * i, 192);\n        s_share[192] = 0;\n\n        SAFE_CHAR_BUF(common_key, 65);\n\n        status = session_key_recover(skey, s_share, common_key);\n\n        CHECK_STATUS(\"session_key_recover failed\");\n\n        common_key[64] = 0;\n\n        SAFE_CHAR_BUF(decr_sshare, 65);\n\n        status = xor_decrypt(common_key, encr_sshare, decr_sshare);\n        CHECK_STATUS(\"xor_decrypt failed\");\n\n        decr_sshare[64] = 0;\n\n        mpz_t decr_secret_share;\n        mpz_init(decr_secret_share);\n        if (mpz_set_str(decr_secret_share, decr_sshare, 16) == -1) {\n            *errStatus = 111;\n            snprintf(errString, BUF_LEN, \"invalid decrypted secret share\");\n            LOG_ERROR(errString);\n\n            mpz_clear(decr_secret_share);\n            goto clean;\n        }\n\n        mpz_addmul_ui(sum, decr_secret_share, 1);\n        mpz_clear(decr_secret_share);\n    }\n\n\n    mpz_mod(bls_key, sum, q);\n\n    SAFE_CHAR_BUF(key_share, BLS_KEY_LENGTH);\n\n    SAFE_CHAR_BUF(arr_skey_str, BUF_LEN);\n\n    mpz_get_str(arr_skey_str, 16, bls_key);\n    int n_zeroes = 64 - strlen(arr_skey_str);\n    for (int i = 0; i < n_zeroes; i++) {\n        key_share[i] = '0';\n    }\n    strncpy(key_share + n_zeroes, arr_skey_str, 65 - n_zeroes);\n    key_share[BLS_KEY_LENGTH - 1] = 0;\n\n    status = AES_encrypt(key_share, encr_bls_key, BUF_LEN, BLS, NON_DECRYPTABLE, enc_bls_key_len);\n\n    CHECK_STATUS2(\"aes encrypt bls private key failed with status %d \");\n\n    SET_SUCCESS\n    clean:\n\n    mpz_clear(bls_key);\n    mpz_clear(sum);\n    mpz_clear(q);\n    LOG_INFO(__FUNCTION__ );\n    LOG_INFO(\"SGX call completed\");\n}\n\nvoid\ntrustedGetBlsPubKeyAES(int *errStatus, char *errString, uint8_t *encryptedPrivateKey, uint64_t key_len,\n                       char *bls_pub_key) {\n    LOG_DEBUG(__FUNCTION__);\n\n    INIT_ERROR_STATE\n\n    CHECK_STATE(bls_pub_key);\n    CHECK_STATE(encryptedPrivateKey);\n\n    SAFE_CHAR_BUF(skey_hex, BUF_LEN);\n\n    int status = AES_decrypt(encryptedPrivateKey, key_len, skey_hex, BUF_LEN);\n\n    CHECK_STATUS2(\"AES decrypt failed %d\");\n\n    skey_hex[ECDSA_SKEY_LEN - 1] = 0;\n\n    status = calc_bls_public_key(skey_hex, bls_pub_key);\n\n    CHECK_STATUS(\"could not calculate bls public key\");\n\n    SET_SUCCESS\n    static uint64_t counter = 0;\n    clean:\n    if (counter % 1000 == 0) {\n        LOG_INFO(__FUNCTION__);\n        LOG_INFO(\"Thousand SGX calls completed\");\n    }\n\n    counter++;\n}\n", "#define ECDSA_SKEY_LEN 65\n#define ECDSA_SKEY_BASE 16\n#define ECDSA_ENCR_LEN 93\n#define ECDSA_BIN_LEN 33\n#define SMALL_BUF_SIZE 1024\n#define VERY_SMALL_BUF_SIZE 512\n#define TINY_BUF_SIZE 256\n\nenclave {\n\n\ttrusted {\n\t\tinclude \"sgx_tgmp.h\"\n\n\t\tpublic void trustedEnclaveInit(uint64_t _logLevel);\n\n\n        public void trustedGenerateSEK(\n                                [out] int *errStatus,\n                                [out, count = SMALL_BUF_SIZE] char *err_string,\n                                [out, count = SMALL_BUF_SIZE] uint8_t *encrypted_SEK,\n                                [out] uint64_t *enc_len,\n                                [out, count = 65] char* hex_SEK);\n\n        public void trustedSetSEK(\n                                [out] int *errStatus,\n                                [out, count = SMALL_BUF_SIZE] char *err_string,\n                                [in, count = SMALL_BUF_SIZE] uint8_t *encrypted_SEK);\n\n        public void trustedSetSEK_backup(\n                                [out] int *errStatus,\n                                [out, count = SMALL_BUF_SIZE] char *err_string,\n                                [out, count = SMALL_BUF_SIZE] uint8_t *encrypted_SEK,\n                                [out] uint64_t *enc_len,\n                                [in, string] const char* SEK_hex);\n\n        public void trustedGenerateEcdsaKeyAES (\n                                [out] int *errStatus,\n                                [out, count = SMALL_BUF_SIZE] char* err_string,\n                                [out, count = SMALL_BUF_SIZE] uint8_t* encrypted_key,\n                                [out] uint64_t *enc_len,\n                                [out, count = SMALL_BUF_SIZE] char * pub_key_x,\n                                [out, count = SMALL_BUF_SIZE] char * pub_key_y);\n\n        public void trustedGetPublicEcdsaKeyAES(\n                                [out] int *errStatus,\n                                [out, count = SMALL_BUF_SIZE] char* err_string,\n                                [in, count = SMALL_BUF_SIZE] uint8_t* encrypted_key,\n                                uint64_t dec_len,\n                                [out, count = SMALL_BUF_SIZE] char * pub_key_x,\n                                [out, count = SMALL_BUF_SIZE] char * pub_key_y);\n\n        public void trustedEcdsaSignAES(\n                                [out] int *errStatus,\n                                [out, count = SMALL_BUF_SIZE] char* err_string,\n                                [in, count = SMALL_BUF_SIZE] uint8_t* encrypted_key,\n                                uint64_t enc_len,\n                                [in, string] const char* hash,\n                                [out, count = SMALL_BUF_SIZE] char* sig_r,\n                                [out, count = SMALL_BUF_SIZE] char* sig_s,\n                                [out] uint8_t* sig_v,\n                                int base);\n\n        public void trustedEncryptKeyAES (\n                                [out] int *errStatus,\n                                [out, count = SMALL_BUF_SIZE] char* err_string,\n                                [in, count = SMALL_BUF_SIZE] const char* key,\n                                [out, count = SMALL_BUF_SIZE] uint8_t* encrypted_key,\n                                [out] uint64_t *enc_len);\n\n        public void trustedDecryptKeyAES (\n                                [out] int *errStatus,\n                                [out, count = SMALL_BUF_SIZE] char* err_string,\n                                [in, count = SMALL_BUF_SIZE] uint8_t* encrypted_key,\n                                uint64_t enc_len,\n                                [out, count = SMALL_BUF_SIZE] char* key );\n\n        public void trustedGenDkgSecretAES (\n                                [out] int *errStatus,\n                                [out, count = SMALL_BUF_SIZE] char* err_string,\n                                [out, count = 3072] uint8_t* encrypted_dkg_secret,\n                                [out] uint64_t * enc_len, size_t _t);\n\n        public void trustedDecryptDkgSecretAES (\n                                [out] int *errStatus,\n                                [out, count = SMALL_BUF_SIZE] char* err_string,\n                                [in, count = 3050] uint8_t* encrypted_dkg_secret,\n                                uint64_t enc_len,\n                                [out, count = 3072] uint8_t* decrypted_dkg_secret\n                                );\n\n        public void trustedSetEncryptedDkgPolyAES(\n                                [out] int *errStatus,\n                                [out, count = SMALL_BUF_SIZE] char* err_string,\n                                [in, count = 3050] uint8_t* encrypted_poly,\n                                uint64_t enc_len);\n\n        public void trustedGetEncryptedSecretShareAES(\n                                [out]int *errStatus,\n                                [out, count = SMALL_BUF_SIZE] char *err_string,\n                                [out, count = SMALL_BUF_SIZE] uint8_t *encrypted_skey,\n                                [out] uint64_t* dec_len,\n                                [out, count = 193] char* result_str,\n                                [out, count = 320] char* s_shareG2,\n                                [in, string] char* pub_keyB,\n                                uint8_t _t,\n                                uint8_t _n,\n                                uint8_t ind);\n\n        public void trustedGetPublicSharesAES(\n                                [out] int *errStatus,\n                                [out, count = SMALL_BUF_SIZE] char* err_string,\n                                [in, count = 3050] uint8_t* encrypted_dkg_secret,\n                                uint64_t enc_len,\n                                [out, count = 10000] char* public_shares,\n                                unsigned _t,\n                                unsigned _n);\n\n        public void trustedDkgVerifyAES(\n                                [out] int *errStatus,\n                                [out, count = SMALL_BUF_SIZE] char* err_string,\n                                [in, string] const char* public_shares,\n                                [in, string] const char* s_share,\n                                [in, count = SMALL_BUF_SIZE] uint8_t* encrypted_key,\n                                uint64_t key_len,\n                                unsigned _t,\n                                int _ind,\n                                [out] int* result);\n\n        public void trustedCreateBlsKeyAES(\n                                [out]int *errStatus,\n                                [out, count = SMALL_BUF_SIZE] char* err_string,\n                                [in, count = 6145] const char* s_shares,\n                                [in, count = SMALL_BUF_SIZE] uint8_t* encrypted_key,\n                                uint64_t key_len,\n                                [out, count = SMALL_BUF_SIZE] uint8_t * encr_bls_key,\n                                [out] uint64_t *enc_bls_key_len);\n\n        public void trustedBlsSignMessageAES (\n                                [out] int *errStatus,\n                                [out, count = TINY_BUF_SIZE] char* err_string,\n                                [in, count = TINY_BUF_SIZE] uint8_t* encrypted_key,\n                                uint64_t enc_len,\n                                [in, string] char* hashX ,\n                                [in, string] char* hashY,\n                                [out, count = SMALL_BUF_SIZE] char* signature);\n\n        public void trustedGetBlsPubKeyAES(\n                                [out]int *errStatus,\n                                [out, count = SMALL_BUF_SIZE]  char* err_string,\n                                [in, count = SMALL_BUF_SIZE] uint8_t* encrypted_key,\n                                uint64_t key_len,\n                                [out, count = 320] char* bls_pub_key);\n\t};\n\n\tuntrusted {\n\t\tinclude \"gmp.h\"\n\n\t\tuint64_t oc_realloc([user_check] void *optr, size_t osz, size_t nsz);\n\t\tvoid oc_printf([in, string] const char *str);\n\t\tvoid oc_free([user_check] void *optr, size_t sz);\n\t};\n};\n", "/*\n    Copyright (C) 2019-Present SKALE Labs\n\n    This file is part of sgxwallet.\n\n    sgxwallet is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    sgxwallet is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with sgxwallet.  If not, see <https://www.gnu.org/licenses/>.\n\n    @file testw.cpp\n    @author Stan Kladko\n    @date 2020\n*/\n\n#include <libff/algebra/fields/fp.hpp>\n#include <dkg/dkg.h>\n#include <jsonrpccpp/server/connectors/httpserver.h>\n#include <libff/algebra/curves/alt_bn128/alt_bn128_pp.hpp>\n#include <libff/algebra/exponentiation/exponentiation.hpp>\n#include <libff/algebra/fields/fp.hpp>\n#include <dkg/dkg.h>\n#include \"sgxwallet_common.h\"\n#include \"third_party/intel/create_enclave.h\"\n#include \"secure_enclave_u.h\"\n#include \"third_party/intel/sgx_detect.h\"\n#include <gmp.h>\n#include <sgx_urts.h>\n#include <stdio.h>\n#include <jsonrpccpp/client/connectors/httpclient.h>\n#include <sgx_tcrypto.h>\n\n#include \"BLSCrypto.h\"\n#include \"ServerInit.h\"\n#include \"DKGCrypto.h\"\n#include \"SGXException.h\"\n#include \"LevelDB.h\"\n#include \"SGXWalletServer.hpp\"\n\n#define CATCH_CONFIG_MAIN\n\n#include \"catch.hpp\"\n#include \"stubclient.h\"\n#include \"BLSSigShare.h\"\n#include \"BLSSigShareSet.h\"\n#include \"BLSPublicKeyShare.h\"\n#include \"BLSPublicKey.h\"\n#include \"SEKManager.h\"\n#include <thread>\n#include \"common.h\"\n\n#include \"SGXRegistrationServer.h\"\n#include \"SGXWalletServer.h\"\n#include \"sgxwallet.h\"\n#include \"TestUtils.h\"\n#include \"testw.h\"\n\n#define PRINT_SRC_LINE cerr << \"Executing line \" <<  to_string(__LINE__) << endl;\n\n\nusing namespace jsonrpc;\nusing namespace std;\n\nclass TestFixture {\npublic:\n    TestFixture() {\n        TestUtils::resetDB();\n        setOptions(L_INFO, false, true);\n        initAll(L_INFO, false, true);\n    }\n\n    ~TestFixture() {\n        TestUtils::destroyEnclave();\n    }\n};\n\nclass TestFixtureHTTPS {\npublic:\n    TestFixtureHTTPS() {\n        TestUtils::resetDB();\n        setOptions(L_INFO, true, true);\n        initAll(L_INFO, false, true);\n    }\n\n    ~TestFixtureHTTPS() {\n        TestUtils::destroyEnclave();\n    }\n};\n\nclass TestFixtureNoResetFromBackup {\npublic:\n    TestFixtureNoResetFromBackup() {\n        setFullOptions(L_INFO, false, true, true);\n        initAll(L_INFO, false, true);\n    }\n\n    ~TestFixtureNoResetFromBackup() {\n        TestUtils::destroyEnclave();\n    }\n};\n\n\nclass TestFixtureNoReset {\npublic:\n    TestFixtureNoReset() {\n        setOptions(L_INFO, false, true);\n        initAll(L_INFO, false, true);\n    }\n\n    ~TestFixtureNoReset() {\n        TestUtils::destroyEnclave();\n    }\n};\n\nTEST_CASE_METHOD(TestFixture, \"ECDSA AES keygen and signature test\", \"[ecdsa-aes-key-sig-gen]\") {\n    vector<char> errMsg(BUF_LEN, 0);\n    int errStatus = 0;\n    vector <uint8_t> encrPrivKey(BUF_LEN, 0);\n    vector<char> pubKeyX(BUF_LEN, 0);\n    vector<char> pubKeyY(BUF_LEN, 0);\n\n    uint64_t encLen = 0;\n    PRINT_SRC_LINE\n    auto status = trustedGenerateEcdsaKeyAES(eid, &errStatus, errMsg.data(), encrPrivKey.data(), &encLen,\n                                             pubKeyX.data(),\n                                             pubKeyY.data());\n    REQUIRE(status == SGX_SUCCESS);\n    REQUIRE(errStatus == SGX_SUCCESS);\n\n    string hex = SAMPLE_HEX_HASH;\n    vector<char> signatureR(BUF_LEN, 0);\n    vector<char> signatureS(BUF_LEN, 0);\n    uint8_t signatureV = 0;\n\n\n    for (int i = 0; i < 50; i++) {\n        PRINT_SRC_LINE\n        status = trustedEcdsaSignAES(eid, &errStatus, errMsg.data(), encrPrivKey.data(), encLen,\n                                     hex.data(),\n                                     signatureR.data(),\n                                     signatureS.data(), &signatureV, 16);\n        REQUIRE(status == SGX_SUCCESS);\n        REQUIRE(errStatus == SGX_SUCCESS);\n    }\n\n}\n\n\nTEST_CASE_METHOD(TestFixture, \"ECDSA AES key gen\", \"[ecdsa-aes-key-gen]\") {\n    vector<char> errMsg(BUF_LEN, 0);\n    int errStatus = 0;\n    vector <uint8_t> encrPrivKey(BUF_LEN, 0);\n    vector<char> pubKeyX(BUF_LEN, 0);\n    vector<char> pubKeyY(BUF_LEN, 0);\n    uint64_t encLen = 0;\n    PRINT_SRC_LINE\n    auto status = trustedGenerateEcdsaKeyAES(eid, &errStatus, errMsg.data(), encrPrivKey.data(), &encLen,\n                                             pubKeyX.data(),\n                                             pubKeyY.data());\n\n    REQUIRE(status == SGX_SUCCESS);\n    REQUIRE(errStatus == SGX_SUCCESS);\n}\n\n\nTEST_CASE_METHOD(TestFixture, \"ECDSA AES get public key\", \"[ecdsa-aes-get-pub-key]\") {\n    int errStatus = 0;\n    vector<char> errMsg(BUF_LEN, 0);\n    vector <uint8_t> encPrivKey(BUF_LEN, 0);\n    vector<char> pubKeyX(BUF_LEN, 0);\n    vector<char> pubKeyY(BUF_LEN, 0);\n\n    uint64_t encLen = 0;\n\n    PRINT_SRC_LINE\n    auto status = trustedGenerateEcdsaKeyAES(eid, &errStatus, errMsg.data(), encPrivKey.data(), &encLen, pubKeyX.data(),\n                                             pubKeyY.data());\n\n    REQUIRE(status == SGX_SUCCESS);\n    REQUIRE(errStatus == SGX_SUCCESS);\n\n    vector<char> receivedPubKeyX(BUF_LEN, 0);\n    vector<char> receivedPubKeyY(BUF_LEN, 0);\n\n    PRINT_SRC_LINE\n    status = trustedGetPublicEcdsaKeyAES(eid, &errStatus, errMsg.data(), encPrivKey.data(), encLen,\n                                         receivedPubKeyX.data(),\n                                         receivedPubKeyY.data());\n    REQUIRE(status == SGX_SUCCESS);\n    REQUIRE(errStatus == SGX_SUCCESS);\n}\n\n\n/* Do later\nTEST_CASE_METHOD(\"BLS key encrypt/decrypt\", \"[bls-key-encrypt-decrypt]\") {\n    resetDB();\n    setOptions(false, false, false, true);\n    initAll(0, false, true);\n\n    //init_enclave();\n\n    int errStatus = -1;\n\n    vector<char> errMsg(BUF_LEN, 0);\n\n    char *encryptedKey = TestUtils::encryptTestKey();\n    REQUIRE(encryptedKey != nullptr);\n    char *plaintextKey = decryptBLSKeyShareFromHex(&errStatus, errMsg.data(), encryptedKey);\n    free(encryptedKey);\n\n    REQUIRE(errStatus == 0);\n    REQUIRE(strcmp(plaintextKey, TEST_BLS_KEY_SHARE) == 0);\n\n    printf(\"Decrypt key completed with status: %d %s \\n\", errStatus, errMsg.data());\n    printf(\"Decrypted key len %d\\n\", (int) strlen(plaintextKey));\n    printf(\"Decrypted key: %s\\n\", plaintextKey);\n    free(plaintextKey);\n\n\n\n}\n\n*/\n\n\nstring genECDSAKeyAPI(StubClient &_c) {\n    Json::Value genKey = _c.generateECDSAKey();\n    CHECK_STATE(genKey[\"status\"].asInt() == 0);\n    auto keyName = genKey[\"keyName\"].asString();\n    CHECK_STATE(keyName.size() == ECDSA_KEY_NAME_SIZE);\n    return keyName;\n}\n\nTEST_CASE_METHOD(TestFixture, \"ECDSA key gen API\", \"[ecdsa-key-gen-api]\") {\n    HttpClient client(RPC_ENDPOINT);\n    StubClient c(client, JSONRPC_CLIENT_V2);\n\n    for (int i = 0; i <= 20; i++) {\n        try {\n            PRINT_SRC_LINE\n            auto keyName = genECDSAKeyAPI(c);\n            PRINT_SRC_LINE\n            Json::Value sig = c.ecdsaSignMessageHash(16, keyName, SAMPLE_HASH);\n            REQUIRE(sig[\"status\"].asInt() == 0);\n            Json::Value getPubKey = c.getPublicECDSAKey(keyName);\n            REQUIRE(getPubKey[\"status\"].asInt() == 0);\n        } catch (JsonRpcException &e) {\n            cerr << e.what() << endl;\n            throw;\n        }\n    }\n\n    auto keyName = genECDSAKeyAPI(c);\n\n\n    Json::Value sig = c.ecdsaSignMessageHash(10, keyName, SAMPLE_HASH);\n\n\n    for (int i = 0; i <= 20; i++) {\n        try {\n            PRINT_SRC_LINE\n            auto keyName = genECDSAKeyAPI(c);\n            PRINT_SRC_LINE\n            Json::Value sig = c.ecdsaSignMessageHash(10, keyName, SAMPLE_HASH);\n            REQUIRE(sig[\"status\"].asInt() == 0);\n            PRINT_SRC_LINE\n            Json::Value getPubKey = c.getPublicECDSAKey(keyName);\n            REQUIRE(getPubKey[\"status\"].asInt() == 0);\n        } catch (JsonRpcException &e) {\n            cerr << e.what() << endl;\n            throw;\n        }\n    }\n}\n\nTEST_CASE_METHOD(TestFixture, \"BLS key encrypt\", \"[bls-key-encrypt]\") {\n    auto key = TestUtils::encryptTestKey();\n    REQUIRE(key != nullptr);\n}\n\n\nTEST_CASE_METHOD(TestFixture, \"DKG AES gen test\", \"[dkg-aes-gen]\") {\n    vector <uint8_t> encryptedDKGSecret(BUF_LEN, 0);\n    vector<char> errMsg(BUF_LEN, 0);\n\n    int errStatus = 0;\n    uint64_t encLen = 0;\n\n    PRINT_SRC_LINE\n    auto status = trustedGenDkgSecretAES(eid, &errStatus, errMsg.data(), encryptedDKGSecret.data(), &encLen, 32);\n    REQUIRE(status == SGX_SUCCESS);\n    REQUIRE(errStatus == SGX_SUCCESS);\n\n    vector<char> secret(BUF_LEN, 0);\n    vector<char> errMsg1(BUF_LEN, 0);\n\n    status = trustedDecryptDkgSecretAES(eid, &errStatus, errMsg1.data(), encryptedDKGSecret.data(),\n                                        encLen, (uint8_t *) secret.data());\n\n    REQUIRE(status == SGX_SUCCESS);\n    REQUIRE(errStatus == SGX_SUCCESS);\n}\n\n\nTEST_CASE_METHOD(TestFixture, \"DKG AES public shares test\", \"[dkg-aes-pub-shares]\") {\n    vector <uint8_t> encryptedDKGSecret(BUF_LEN, 0);\n    vector<char> errMsg(BUF_LEN, 0);\n\n    int errStatus = 0;\n    uint64_t encLen = 0;\n\n    unsigned t = 32, n = 32;\n    PRINT_SRC_LINE\n    auto status = trustedGenDkgSecretAES(eid, &errStatus, errMsg.data(), encryptedDKGSecret.data(), &encLen, n);\n    REQUIRE(status == SGX_SUCCESS);\n    REQUIRE(errStatus == SGX_SUCCESS);\n\n    vector<char> errMsg1(BUF_LEN, 0);\n\n    char colon = ':';\n    vector<char> pubShares(10000, 0);\n    PRINT_SRC_LINE\n    status = trustedGetPublicSharesAES(eid, &errStatus, errMsg1.data(),\n                                       encryptedDKGSecret.data(), encLen, pubShares.data(), t, n);\n    REQUIRE(status == SGX_SUCCESS);\n    REQUIRE(errStatus == SGX_SUCCESS);\n\n    vector <string> g2Strings = splitString(pubShares.data(), ',');\n    vector <libff::alt_bn128_G2> pubSharesG2;\n    for (u_int64_t i = 0; i < g2Strings.size(); i++) {\n        vector <string> coeffStr = splitString(g2Strings.at(i).c_str(), ':');\n\n        pubSharesG2.push_back(TestUtils::vectStringToG2(coeffStr));\n    }\n\n    vector<char> secret(BUF_LEN, 0);\n    PRINT_SRC_LINE\n    status = trustedDecryptDkgSecretAES(eid, &errStatus, errMsg1.data(), encryptedDKGSecret.data(), encLen,\n                                        (uint8_t *) secret.data());\n    REQUIRE(status == SGX_SUCCESS);\n    REQUIRE(errStatus == SGX_SUCCESS);\n\n    signatures::Dkg dkgObj(t, n);\n\n    vector <libff::alt_bn128_Fr> poly = TestUtils::splitStringToFr(secret.data(), colon);\n    vector <libff::alt_bn128_G2> pubSharesDkg = dkgObj.VerificationVector(poly);\n    for (uint32_t i = 0; i < pubSharesDkg.size(); i++) {\n        libff::alt_bn128_G2 el = pubSharesDkg.at(i);\n        el.to_affine_coordinates();\n    }\n    REQUIRE(pubSharesG2 == pubSharesDkg);\n}\n\nTEST_CASE_METHOD(TestFixture, \"DKG AES encrypted secret shares test\", \"[dkg-aes-encr-sshares]\") {\n    vector<char> errMsg(BUF_LEN, 0);\n    vector<char> result(BUF_LEN, 0);\n\n    int errStatus = 0;\n    uint64_t encLen = 0;\n\n    vector <uint8_t> encryptedDKGSecret(BUF_LEN, 0);\n    PRINT_SRC_LINE\n    auto status = trustedGenDkgSecretAES(eid, &errStatus, errMsg.data(), encryptedDKGSecret.data(), &encLen, 2);\n    REQUIRE(status == SGX_SUCCESS);\n    REQUIRE(errStatus == SGX_SUCCESS);\n\n    uint64_t enc_len = encLen;\n\n    PRINT_SRC_LINE\n    status = trustedSetEncryptedDkgPolyAES(eid, &errStatus, errMsg.data(), encryptedDKGSecret.data(), enc_len);\n    REQUIRE(status == SGX_SUCCESS);\n    REQUIRE(errStatus == SGX_SUCCESS);\n\n    vector <uint8_t> encrPRDHKey(BUF_LEN, 0);\n\n    string pub_keyB = SAMPLE_PUBLIC_KEY_B;\n\n    vector<char> s_shareG2(BUF_LEN, 0);\n    PRINT_SRC_LINE\n    status = trustedGetEncryptedSecretShareAES(eid, &errStatus, errMsg.data(), encrPRDHKey.data(), &encLen,\n                                               result.data(),\n                                               s_shareG2.data(),\n                                               (char *) pub_keyB.data(), 2, 2, 1);\n\n    REQUIRE(status == SGX_SUCCESS);\n    REQUIRE(errStatus == SGX_SUCCESS);\n}\n\n\n/*\n * ( \"verification test\", \"[verify]\" ) {\n\n\n    char*  pubshares = \"0d72c21fc5a43452ad5f36699822309149ce6ce2cdce50dafa896e873f1b8ddd12f65a2e9c39c617a1f695f076b33b236b47ed773901fc2762f8b6f63277f5e30d7080be8e98c97f913d1920357f345dc0916c1fcb002b7beb060aa8b6b473a011bfafe9f8a5d8ea4c643ca4101e5119adbef5ae64f8dfb39cd10f1e69e31c591858d7eaca25b4c412fe909ca87ca7aadbf6d97d32d9b984e93d436f13d43ec31f40432cc750a64ac239cad6b8f78c1f1dd37427e4ff8c1cc4fe1c950fcbcec10ebfd79e0c19d0587adafe6db4f3c63ea9a329724a8804b63a9422e6898c0923209e828facf3a073254ec31af4231d999ba04eb5b7d1e0056d742a65b766f2f3\";\n    char *sec_share = \"11592366544581417165283270001305852351194685098958224535357729125789505948557\";\n    mpz_t sshare;\n    mpz_init(sshare);\n    mpz_set_str(sshare, \"11592366544581417165283270001305852351194685098958224535357729125789505948557\", 10);\n    int result = Verification(pubshares, sshare, 2, 0);\n    REQUIRE(result == 1);\n\n\n}*/\n\n\n\n\n\n\nTEST_CASE_METHOD(TestFixture, \"DKG_BLS test\", \"[dkg-bls]\") {\n    HttpClient client(RPC_ENDPOINT);\n    StubClient c(client, JSONRPC_CLIENT_V2);\n\n    vector <string> ecdsaKeyNames;\n    vector <string> blsKeyNames;\n\n    int schainID = TestUtils::randGen();\n    int dkgID = TestUtils::randGen();\n\n    PRINT_SRC_LINE\n    TestUtils::doDKG(c, 4, 1, ecdsaKeyNames, blsKeyNames, schainID, dkgID);\n\n    REQUIRE(blsKeyNames.size() == 4);\n\n    schainID = TestUtils::randGen();\n    dkgID = TestUtils::randGen();\n\n    TestUtils::doDKG(c, 16, 5, ecdsaKeyNames, blsKeyNames, schainID, dkgID);\n}\n\nTEST_CASE_METHOD(TestFixture, \"Delete Bls Key\", \"[delete-bls-key]\") {\n    HttpClient client(RPC_ENDPOINT);\n    StubClient c(client, JSONRPC_CLIENT_V2);\n    std::string name = \"BLS_KEY:SCHAIN_ID:123456789:NODE_ID:0:DKG_ID:0\";\n    libff::alt_bn128_Fr key = libff::alt_bn128_Fr(\n            \"6507625568967977077291849236396320012317305261598035438182864059942098934847\");\n    std::string key_str = TestUtils::stringFromFr(key);\n    PRINT_SRC_LINE\n    c.importBLSKeyShare(key_str, name);\n    PRINT_SRC_LINE\n    REQUIRE(c.deleteBlsKey(name)[\"deleted\"] == true);\n}\n\nTEST_CASE_METHOD(TestFixture, \"Backup Key\", \"[backup-key]\") {\n    HttpClient client(RPC_ENDPOINT);\n    StubClient c(client, JSONRPC_CLIENT_V2);\n    std::ifstream sek_file(\"sgx_data/sgxwallet_backup_key.txt\");\n    REQUIRE(sek_file.good());\n\n    std::string sek;\n    sek_file >> sek;\n\n    REQUIRE(sek.size() == 32);\n}\n\nTEST_CASE_METHOD(TestFixture, \"Get ServerStatus\", \"[get-server-status]\") {\n    HttpClient client(RPC_ENDPOINT);\n    StubClient c(client, JSONRPC_CLIENT_V2);\n    REQUIRE(c.getServerStatus()[\"status\"] == 0);\n}\n\nTEST_CASE_METHOD(TestFixture, \"Get ServerVersion\", \"[get-server-version]\") {\n    HttpClient client(RPC_ENDPOINT);\n    StubClient c(client, JSONRPC_CLIENT_V2);\n    REQUIRE(c.getServerVersion()[\"version\"] == SGXWalletServer::getVersion());\n}\n\n\nTEST_CASE_METHOD(TestFixtureHTTPS, \"Cert request sign\", \"[cert-sign]\") {\n\n    PRINT_SRC_LINE\n\n    REQUIRE_NOTHROW(SGXRegistrationServer::getServer());\n\n    PRINT_SRC_LINE\n\n    string csrFile = \"insecure-samples/yourdomain.csr\";\n\n    ifstream infile(csrFile);\n    infile.exceptions(std::ifstream::failbit | std::ifstream::badbit);\n    ostringstream ss;\n    ss << infile.rdbuf();\n    infile.close();\n\n    PRINT_SRC_LINE\n\n    auto result = SGXRegistrationServer::getServer()->SignCertificate(ss.str());\n\n    REQUIRE(result[\"status\"] == 0);\n\n\n    PRINT_SRC_LINE\n    result = SGXRegistrationServer::getServer()->SignCertificate(\"Haha\");\n\n    REQUIRE(result[\"status\"] != 0);\n}\n\nTEST_CASE_METHOD(TestFixture, \"DKG API test\", \"[dkg-api]\") {\n    HttpClient client(RPC_ENDPOINT);\n    StubClient c(client, JSONRPC_CLIENT_V2);\n\n    string polyName = SAMPLE_POLY_NAME;\n\n    PRINT_SRC_LINE\n    Json::Value genPoly = c.generateDKGPoly(polyName, 2);\n    REQUIRE(genPoly[\"status\"].asInt() == 0);\n\n    Json::Value publicKeys;\n    publicKeys.append(SAMPLE_DKG_PUB_KEY_1);\n    publicKeys.append(SAMPLE_DKG_PUB_KEY_2);\n\n    // wrongName\n    Json::Value genPolyWrongName = c.generateDKGPoly(\"poly\", 2);\n    REQUIRE(genPolyWrongName[\"status\"].asInt() != 0);\n\n    Json::Value verifVectWrongName = c.getVerificationVector(\"poly\", 2, 2);\n    REQUIRE(verifVectWrongName[\"status\"].asInt() != 0);\n\n    Json::Value secretSharesWrongName = c.getSecretShare(\"poly\", publicKeys, 2, 2);\n    REQUIRE(secretSharesWrongName[\"status\"].asInt() != 0);\n\n    // wrong_t\n    Json::Value genPolyWrong_t = c.generateDKGPoly(polyName, 33);\n    REQUIRE(genPolyWrong_t[\"status\"].asInt() != 0);\n\n    Json::Value verifVectWrong_t = c.getVerificationVector(polyName, 1, 2);\n    REQUIRE(verifVectWrong_t[\"status\"].asInt() != 0);\n\n    Json::Value secretSharesWrong_t = c.getSecretShare(polyName, publicKeys, 3, 3);\n    REQUIRE(secretSharesWrong_t[\"status\"].asInt() != 0);\n\n    // wrong_n\n    Json::Value verifVectWrong_n = c.getVerificationVector(polyName, 2, 1);\n    REQUIRE(verifVectWrong_n[\"status\"].asInt() != 0);\n\n    Json::Value publicKeys1;\n    publicKeys1.append(SAMPLE_DKG_PUB_KEY_1);\n    Json::Value secretSharesWrong_n = c.getSecretShare(polyName, publicKeys1, 2, 1);\n    REQUIRE(secretSharesWrong_n[\"status\"].asInt() != 0);\n\n    //wrong number of publicKeys\n    Json::Value secretSharesWrongPkeys = c.getSecretShare(polyName, publicKeys, 2, 3);\n    REQUIRE(secretSharesWrongPkeys[\"status\"].asInt() != 0);\n\n    //wrong verif\n    Json::Value Skeys = c.getSecretShare(polyName, publicKeys, 2, 2);\n    Json::Value verifVect = c.getVerificationVector(polyName, 2, 2);\n    Json::Value verificationWrongSkeys = c.dkgVerification(\"\", \"\", \"\", 2, 2, 1);\n    REQUIRE(verificationWrongSkeys[\"status\"].asInt() != 0);\n}\n\nTEST_CASE_METHOD(TestFixture, \"PolyExists test\", \"[dkg-poly-exists]\") {\n    HttpClient client(RPC_ENDPOINT);\n    StubClient c(client, JSONRPC_CLIENT_V2);\n\n    string polyName = SAMPLE_POLY_NAME;\n    PRINT_SRC_LINE\n    Json::Value genPoly = c.generateDKGPoly(polyName, 2);\n    REQUIRE(genPoly[\"status\"] == 0);\n\n    PRINT_SRC_LINE\n    Json::Value polyExists = c.isPolyExists(polyName);\n    REQUIRE(polyExists[\"status\"] == 0);\n    REQUIRE(polyExists[\"IsExist\"].asBool());\n\n    PRINT_SRC_LINE\n    Json::Value polyDoesNotExist = c.isPolyExists(\"Vasya\");\n    REQUIRE(!polyDoesNotExist[\"IsExist\"].asBool());\n}\n\nTEST_CASE_METHOD(TestFixture, \"AES_DKG test\", \"[aes-dkg]\") {\n    HttpClient client(RPC_ENDPOINT);\n    StubClient c(client, JSONRPC_CLIENT_V2);\n\n    int n = 2, t = 2;\n    Json::Value ethKeys[n];\n    Json::Value verifVects[n];\n    Json::Value pubEthKeys;\n    Json::Value secretShares[n];\n    Json::Value pubBLSKeys[n];\n    Json::Value blsSigShares[n];\n    vector <string> pubShares(n);\n    vector <string> polyNames(n);\n\n    int schainID = TestUtils::randGen();\n    int dkgID = TestUtils::randGen();\n    for (uint8_t i = 0; i < n; i++) {\n        PRINT_SRC_LINE\n        ethKeys[i] = c.generateECDSAKey();\n        REQUIRE(ethKeys[i][\"status\"] == 0);\n        string polyName =\n                \"POLY:SCHAIN_ID:\" + to_string(schainID) + \":NODE_ID:\" + to_string(i) + \":DKG_ID:\" + to_string(dkgID);\n        REQUIRE(ethKeys[i][\"status\"] == 0);\n        auto response = c.generateDKGPoly(polyName, t);\n        REQUIRE(response[\"status\"] == 0);\n\n        polyNames[i] = polyName;\n        PRINT_SRC_LINE\n        verifVects[i] = c.getVerificationVector(polyName, t, n);\n        REQUIRE(verifVects[i][\"status\"] == 0);\n\n        pubEthKeys.append(ethKeys[i][\"publicKey\"]);\n    }\n\n    for (uint8_t i = 0; i < n; i++) {\n        PRINT_SRC_LINE\n        secretShares[i] = c.getSecretShare(polyNames[i], pubEthKeys, t, n);\n        REQUIRE(secretShares[i][\"status\"] == 0);\n\n        for (uint8_t k = 0; k < t; k++)\n            for (uint8_t j = 0; j < 4; j++) {\n                string pubShare = verifVects[i][\"verificationVector\"][k][j].asString();\n                pubShares[i] += TestUtils::convertDecToHex(pubShare);\n            }\n    }\n\n    int k = 0;\n    vector <string> secShares(n);\n\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j < n; j++) {\n            string secretShare = secretShares[i][\"secretShare\"].asString().substr(192 * j, 192);\n            secShares[i] += secretShares[j][\"secretShare\"].asString().substr(192 * i, 192);\n            PRINT_SRC_LINE\n            Json::Value verif = c.dkgVerification(pubShares[i], ethKeys[j][\"keyName\"].asString(), secretShare, t, n, j);\n            REQUIRE(verif[\"status\"] == 0);\n            bool res = verif[\"result\"].asBool();\n            k++;\n            REQUIRE(res);\n        }\n\n    Json::Value complaintResponse = c.complaintResponse(polyNames[1], 0);\n    REQUIRE(complaintResponse[\"status\"] == 0);\n\n    BLSSigShareSet sigShareSet(t, n);\n\n    string hash = SAMPLE_HASH;\n\n    auto hash_arr = make_shared < array < uint8_t,\n    32 >> ();\n\n    uint64_t binLen;\n\n    if (!hex2carray(hash.c_str(), &binLen, hash_arr->data(), 32)) {\n        throw SGXException(INVALID_HEX, \"Invalid hash\");\n    }\n\n    map <size_t, shared_ptr<BLSPublicKeyShare>> coeffs_pkeys_map;\n\n    for (int i = 0; i < t; i++) {\n        string endName = polyNames[i].substr(4);\n        string blsName = \"BLS_KEY\" + polyNames[i].substr(4);\n        auto response = c.createBLSPrivateKey(blsName, ethKeys[i][\"keyName\"].asString(), polyNames[i], secShares[i], t,\n                                              n);\n        REQUIRE(response[\"status\"] == 0);\n\n        PRINT_SRC_LINE\n        pubBLSKeys[i] = c.getBLSPublicKeyShare(blsName);\n        REQUIRE(pubBLSKeys[i][\"status\"] == 0);\n\n        string hash = SAMPLE_HASH;\n        blsSigShares[i] = c.blsSignMessageHash(blsName, hash, t, n);\n        REQUIRE(blsSigShares[i][\"status\"] == 0);\n\n        shared_ptr <string> sig_share_ptr = make_shared<string>(blsSigShares[i][\"signatureShare\"].asString());\n        BLSSigShare sig(sig_share_ptr, i + 1, t, n);\n        sigShareSet.addSigShare(make_shared<BLSSigShare>(sig));\n\n        vector <string> pubKey_vect;\n        for (uint8_t j = 0; j < 4; j++) {\n            pubKey_vect.push_back(pubBLSKeys[i][\"blsPublicKeyShare\"][j].asString());\n        }\n        BLSPublicKeyShare pubKey(make_shared < vector < string >> (pubKey_vect), t, n);\n        PRINT_SRC_LINE\n        REQUIRE(pubKey.VerifySigWithHelper(hash_arr, make_shared<BLSSigShare>(sig), t, n));\n\n        coeffs_pkeys_map[i + 1] = make_shared<BLSPublicKeyShare>(pubKey);\n    }\n\n    shared_ptr <BLSSignature> commonSig = sigShareSet.merge();\n    BLSPublicKey\n    common_public(make_shared < map < size_t, shared_ptr < BLSPublicKeyShare >>>(coeffs_pkeys_map), t,\n            n);\n    REQUIRE(common_public.VerifySigWithHelper(hash_arr, commonSig, t, n));\n}\n\nTEST_CASE_METHOD(TestFixture, \"AES encrypt/decrypt\", \"[aes-encrypt-decrypt]\") {\n    int errStatus = 0;\n    vector<char> errMsg(BUF_LEN, 0);\n    uint64_t encLen;\n    string key = SAMPLE_AES_KEY;\n    vector <uint8_t> encrypted_key(BUF_LEN, 0);\n\n    PRINT_SRC_LINE\n    auto status = trustedEncryptKeyAES(eid, &errStatus, errMsg.data(), key.c_str(), encrypted_key.data(), &encLen);\n\n    REQUIRE(status == 0);\n    REQUIRE(errStatus == 0);\n\n    vector<char> decr_key(BUF_LEN, 0);\n    PRINT_SRC_LINE\n    status = trustedDecryptKeyAES(eid, &errStatus, errMsg.data(), encrypted_key.data(), encLen, decr_key.data());\n\n    REQUIRE(status == 0);\n    REQUIRE(errStatus == 0);\n    REQUIRE(key.compare(decr_key.data()) == 0);\n}\n\n\nTEST_CASE_METHOD(TestFixture, \"Many threads ecdsa dkg bls\", \"[many-threads-crypto]\") {\n    vector <thread> threads;\n    int num_threads = 4;\n    for (int i = 0; i < num_threads; i++) {\n        threads.push_back(thread(TestUtils::sendRPCRequest));\n    }\n\n    for (auto &thread : threads) {\n        thread.join();\n    }\n}\n\nTEST_CASE_METHOD(TestFixture, \"First run\", \"[first-run]\") {\n\n    HttpClient client(RPC_ENDPOINT);\n    StubClient c(client, JSONRPC_CLIENT_V2);\n    try {\n        PRINT_SRC_LINE\n        auto keyName = genECDSAKeyAPI(c);\n        ofstream namefile(\"/tmp/keyname\");\n        namefile << keyName;\n\n        PRINT_SRC_LINE\n    } catch (JsonRpcException & e)\n    {\n        cerr << e.what() << endl;\n        throw;\n    }\n\n\n}\n\nTEST_CASE_METHOD(TestFixtureNoReset, \"Second run\", \"[second-run]\") {\n\n    HttpClient client(RPC_ENDPOINT);\n    StubClient c(client, JSONRPC_CLIENT_V2);\n    try {\n        PRINT_SRC_LINE\n        string keyName;\n        ifstream namefile(\"/tmp/keyname\");\n        getline(namefile, keyName);\n\n        Json::Value sig = c.ecdsaSignMessageHash(16, keyName, SAMPLE_HASH);\n        REQUIRE(sig[\"status\"].asInt() == 0);\n        Json::Value getPubKey = c.getPublicECDSAKey(keyName);\n        REQUIRE(getPubKey[\"status\"].asInt() == 0);\n    } catch (JsonRpcException &e) {\n        cerr << e.what() << endl;\n        throw;\n    }\n}\n\n\nTEST_CASE_METHOD(TestFixtureNoResetFromBackup, \"Backup restore\", \"[backup-restore]\") {\n}\n"], "filenames": ["BLSCrypto.cpp", "DKGCrypto.cpp", "ECDSACrypto.cpp", "SEKManager.cpp", "SGXWalletServer.cpp", "secure_enclave/AESUtils.c", "secure_enclave/AESUtils.h", "secure_enclave/secure_enclave.c", "secure_enclave/secure_enclave.edl", "testw.cpp"], "buggy_code_start_loc": [89, 138, 57, 55, 566, 29, 30, 125, 14, 130], "buggy_code_end_loc": [251, 304, 58, 131, 567, 171, 37, 1070, 143, 698], "fixing_code_start_loc": [89, 138, 57, 55, 566, 30, 30, 125, 14, 130], "fixing_code_end_loc": [252, 304, 58, 131, 567, 134, 47, 1069, 143, 699], "type": "CWE-787", "message": "An issue was discovered in SKALE sgxwallet 1.58.3. sgx_disp_ippsAES_GCMEncrypt allows an out-of-bounds write, resulting in a segfault and compromised enclave. This issue describes a buffer overflow, which was resolved prior to v1.77.0 and not reproducible in latest sgxwallet v1.77.0", "other": {"cve": {"id": "CVE-2021-36218", "sourceIdentifier": "cve@mitre.org", "published": "2021-09-27T14:15:08.490", "lastModified": "2021-10-02T02:05:43.953", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in SKALE sgxwallet 1.58.3. sgx_disp_ippsAES_GCMEncrypt allows an out-of-bounds write, resulting in a segfault and compromised enclave. This issue describes a buffer overflow, which was resolved prior to v1.77.0 and not reproducible in latest sgxwallet v1.77.0"}, {"lang": "es", "value": "Se ha detectado un problema en SKALE sgxwallet versi\u00f3n 1.58.3. La funci\u00f3n sgx_disp_ippsAES_GCMEncrypt permite una escritura fuera de los l\u00edmites, resultando en un fallo de seguridad y a un enclave comprometido. Este problema describe un desbordamiento del b\u00fafer, que fue resuelto en versiones anteriores a v1.77.0 y no es reproducible en la \u00faltima versi\u00f3n de sgxwallet v1.77.0"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:skale:sgxwallet:1.58.3:*:*:*:*:*:*:*", "matchCriteriaId": "BB490637-105D-41DF-9664-A8E5542D9D42"}]}]}], "references": [{"url": "https://github.com/skalenetwork/sgxwallet/commit/77425c862ad20cd270d42c54f3d63e1eb4e02195", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/skalenetwork/sgxwallet/releases", "source": "cve@mitre.org", "tags": ["Release Notes", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/skalenetwork/sgxwallet/commit/77425c862ad20cd270d42c54f3d63e1eb4e02195"}}