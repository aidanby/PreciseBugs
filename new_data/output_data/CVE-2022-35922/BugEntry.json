{"buggy_code": ["//! The default implementation of a WebSocket Receiver.\n\nuse std::io::Read;\nuse std::io::Result as IoResult;\n\nuse hyper::buffer::BufReader;\n\nuse crate::dataframe::{DataFrame, Opcode};\nuse crate::message::OwnedMessage;\nuse crate::result::{WebSocketError, WebSocketResult};\npub use crate::stream::sync::Shutdown;\nuse crate::stream::sync::{AsTcpStream, Stream};\nuse crate::ws;\nuse crate::ws::receiver::Receiver as ReceiverTrait;\nuse crate::ws::receiver::{DataFrameIterator, MessageIterator};\n\n/// This reader bundles an existing stream with a parsing algorithm.\n/// It is used by the client in its `.split()` function as the reading component.\npub struct Reader<R>\nwhere\n\tR: Read,\n{\n\t/// the stream to be read from\n\tpub stream: BufReader<R>,\n\t/// the parser to parse bytes into messages\n\tpub receiver: Receiver,\n}\n\nimpl<R> Reader<R>\nwhere\n\tR: Read,\n{\n\t/// Reads a single data frame from the remote endpoint.\n\tpub fn recv_dataframe(&mut self) -> WebSocketResult<DataFrame> {\n\t\tself.receiver.recv_dataframe(&mut self.stream)\n\t}\n\n\t/// Returns an iterator over incoming data frames.\n\tpub fn incoming_dataframes(&mut self) -> DataFrameIterator<Receiver, BufReader<R>> {\n\t\tself.receiver.incoming_dataframes(&mut self.stream)\n\t}\n\n\t/// Reads a single message from this receiver.\n\tpub fn recv_message(&mut self) -> WebSocketResult<OwnedMessage> {\n\t\tself.receiver.recv_message(&mut self.stream)\n\t}\n\n\t/// An iterator over incoming messsages.\n\t/// This iterator will block until new messages arrive and will never halt.\n\tpub fn incoming_messages<'a>(&'a mut self) -> MessageIterator<'a, Receiver, BufReader<R>> {\n\t\tself.receiver.incoming_messages(&mut self.stream)\n\t}\n}\n\nimpl<S> Reader<S>\nwhere\n\tS: AsTcpStream + Stream + Read,\n{\n\t/// Closes the receiver side of the connection, will cause all pending and future IO to\n\t/// return immediately with an appropriate value.\n\tpub fn shutdown(&self) -> IoResult<()> {\n\t\tself.stream.get_ref().as_tcp().shutdown(Shutdown::Read)\n\t}\n\n\t/// Shuts down both Sender and Receiver, will cause all pending and future IO to\n\t/// return immediately with an appropriate value.\n\tpub fn shutdown_all(&self) -> IoResult<()> {\n\t\tself.stream.get_ref().as_tcp().shutdown(Shutdown::Both)\n\t}\n}\n\n/// A Receiver that wraps a Reader and provides a default implementation using\n/// DataFrames and Messages.\npub struct Receiver {\n\tbuffer: Vec<DataFrame>,\n\tmask: bool,\n}\n\nimpl Receiver {\n\t/// Create a new Receiver using the specified Reader.\n\tpub fn new(mask: bool) -> Receiver {\n\t\tReceiver {\n\t\t\tbuffer: Vec::new(),\n\t\t\tmask,\n\t\t}\n\t}\n}\n\nimpl ws::Receiver for Receiver {\n\ttype F = DataFrame;\n\n\ttype M = OwnedMessage;\n\n\t/// Reads a single data frame from the remote endpoint.\n\tfn recv_dataframe<R>(&mut self, reader: &mut R) -> WebSocketResult<DataFrame>\n\twhere\n\t\tR: Read,\n\t{\n\t\tDataFrame::read_dataframe(reader, self.mask)\n\t}\n\n\t/// Returns the data frames that constitute one message.\n\tfn recv_message_dataframes<R>(&mut self, reader: &mut R) -> WebSocketResult<Vec<DataFrame>>\n\twhere\n\t\tR: Read,\n\t{\n\t\tlet mut finished = if self.buffer.is_empty() {\n\t\t\tlet first = self.recv_dataframe(reader)?;\n\n\t\t\tif first.opcode == Opcode::Continuation {\n\t\t\t\treturn Err(WebSocketError::ProtocolError(\n\t\t\t\t\t\"Unexpected continuation data frame opcode\",\n\t\t\t\t));\n\t\t\t}\n\n\t\t\tlet finished = first.finished;\n\t\t\tself.buffer.push(first);\n\t\t\tfinished\n\t\t} else {\n\t\t\tfalse\n\t\t};\n\n\t\twhile !finished {\n\t\t\tlet next = self.recv_dataframe(reader)?;\n\t\t\tfinished = next.finished;\n\n\t\t\tmatch next.opcode as u8 {\n\t\t\t\t// Continuation opcode\n\t\t\t\t0 => self.buffer.push(next),\n\t\t\t\t// Control frame\n\t\t\t\t8..=15 => {\n\t\t\t\t\treturn Ok(vec![next]);\n\t\t\t\t}\n\t\t\t\t// Others\n\t\t\t\t_ => {\n\t\t\t\t\treturn Err(WebSocketError::ProtocolError(\n\t\t\t\t\t\t\"Unexpected data frame opcode\",\n\t\t\t\t\t));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tOk(::std::mem::replace(&mut self.buffer, Vec::new()))\n\t}\n}\n", "//! Module containing the default implementation of data frames.\nuse crate::result::{WebSocketError, WebSocketResult};\nuse crate::ws::dataframe::DataFrame as DataFrameable;\nuse crate::ws::util::header as dfh;\nuse crate::ws::util::header::DataFrameHeader;\nuse crate::ws::util::mask;\nuse std::io::{self, Read, Write};\n\n/// Represents a WebSocket data frame.\n///\n/// The data held in a DataFrame is never masked.\n/// Masking/unmasking is done when sending and receiving the data frame,\n///\n/// This DataFrame, unlike the standard Message implementation (which also\n/// implements the DataFrame trait), owns its entire payload. This means that calls to `payload`\n/// don't allocate extra memory (again unlike the default Message implementation).\n#[derive(Debug, Clone, PartialEq)]\npub struct DataFrame {\n\t/// Whether or no this constitutes the end of a message\n\tpub finished: bool,\n\t/// The reserved portion of the data frame (RFC6455 5.2)\n\tpub reserved: [bool; 3],\n\t/// The opcode associated with this data frame\n\tpub opcode: Opcode,\n\t/// The payload associated with this data frame\n\tpub data: Vec<u8>,\n}\n\nimpl DataFrame {\n\t/// Creates a new DataFrame.\n\tpub fn new(finished: bool, opcode: Opcode, data: Vec<u8>) -> DataFrame {\n\t\tDataFrame {\n\t\t\tfinished,\n\t\t\treserved: [false; 3],\n\t\t\topcode,\n\t\t\tdata,\n\t\t}\n\t}\n\n\t/// Take the body and header of a dataframe and combine it into a single\n\t/// Dataframe struct. A websocket message can be made up of many individual\n\t/// dataframes, use the methods from the Message or OwnedMessage structs to\n\t/// take many of these and create a websocket message.\n\tpub fn read_dataframe_body(\n\t\theader: DataFrameHeader,\n\t\tbody: Vec<u8>,\n\t\tshould_be_masked: bool,\n\t) -> WebSocketResult<Self> {\n\t\tlet finished = header.flags.contains(dfh::DataFrameFlags::FIN);\n\n\t\tlet reserved = [\n\t\t\theader.flags.contains(dfh::DataFrameFlags::RSV1),\n\t\t\theader.flags.contains(dfh::DataFrameFlags::RSV2),\n\t\t\theader.flags.contains(dfh::DataFrameFlags::RSV3),\n\t\t];\n\n\t\tlet opcode = Opcode::new(header.opcode).expect(\"Invalid header opcode!\");\n\n\t\tlet data = match header.mask {\n\t\t\tSome(mask) => {\n\t\t\t\tif !should_be_masked {\n\t\t\t\t\treturn Err(WebSocketError::DataFrameError(\n\t\t\t\t\t\t\"Expected unmasked data frame\",\n\t\t\t\t\t));\n\t\t\t\t}\n\t\t\t\tmask::mask_data(mask, &body)\n\t\t\t}\n\t\t\tNone => {\n\t\t\t\tif should_be_masked {\n\t\t\t\t\treturn Err(WebSocketError::DataFrameError(\"Expected masked data frame\"));\n\t\t\t\t}\n\t\t\t\tbody\n\t\t\t}\n\t\t};\n\n\t\tOk(DataFrame {\n\t\t\tfinished,\n\t\t\treserved,\n\t\t\topcode,\n\t\t\tdata,\n\t\t})\n\t}\n\n\t/// Reads a DataFrame from a Reader.\n\tpub fn read_dataframe<R>(reader: &mut R, should_be_masked: bool) -> WebSocketResult<Self>\n\twhere\n\t\tR: Read,\n\t{\n\t\tlet header = dfh::read_header(reader)?;\n\n\t\tlet mut data: Vec<u8> = Vec::with_capacity(header.len as usize);\n\t\tlet read = reader.take(header.len).read_to_end(&mut data)?;\n\t\tif (read as u64) < header.len {\n\t\t\treturn Err(io::Error::new(io::ErrorKind::UnexpectedEof, \"incomplete payload\").into());\n\t\t}\n\n\t\tDataFrame::read_dataframe_body(header, data, should_be_masked)\n\t}\n}\n\nimpl DataFrameable for DataFrame {\n\t#[inline(always)]\n\tfn is_last(&self) -> bool {\n\t\tself.finished\n\t}\n\n\t#[inline(always)]\n\tfn opcode(&self) -> u8 {\n\t\tself.opcode as u8\n\t}\n\n\t#[inline(always)]\n\tfn reserved(&self) -> &[bool; 3] {\n\t\t&self.reserved\n\t}\n\n\t#[inline(always)]\n\tfn size(&self) -> usize {\n\t\tself.data.len()\n\t}\n\n\t#[inline(always)]\n\tfn write_payload(&self, socket: &mut dyn Write) -> WebSocketResult<()> {\n\t\tsocket.write_all(self.data.as_slice())?;\n\t\tOk(())\n\t}\n\n\t#[inline(always)]\n\tfn take_payload(self) -> Vec<u8> {\n\t\tself.data\n\t}\n}\n\n/// Represents a WebSocket data frame opcode\n#[derive(Clone, Debug, Copy, PartialEq)]\npub enum Opcode {\n\t/// A continuation data frame\n\tContinuation,\n\t/// A UTF-8 text data frame\n\tText,\n\t/// A binary data frame\n\tBinary,\n\t/// An undefined non-control data frame\n\tNonControl1,\n\t/// An undefined non-control data frame\n\tNonControl2,\n\t/// An undefined non-control data frame\n\tNonControl3,\n\t/// An undefined non-control data frame\n\tNonControl4,\n\t/// An undefined non-control data frame\n\tNonControl5,\n\t/// A close data frame\n\tClose,\n\t/// A ping data frame\n\tPing,\n\t/// A pong data frame\n\tPong,\n\t/// An undefined control data frame\n\tControl1,\n\t/// An undefined control data frame\n\tControl2,\n\t/// An undefined control data frame\n\tControl3,\n\t/// An undefined control data frame\n\tControl4,\n\t/// An undefined control data frame\n\tControl5,\n}\n\nimpl Opcode {\n\t/// Attempts to form an Opcode from a nibble.\n\t///\n\t/// Returns the Opcode, or None if the opcode is out of range.\n\t#[warn(clippy::new_ret_no_self)]\n\tpub fn new(op: u8) -> Option<Opcode> {\n\t\tSome(match op {\n\t\t\t0 => Opcode::Continuation,\n\t\t\t1 => Opcode::Text,\n\t\t\t2 => Opcode::Binary,\n\t\t\t3 => Opcode::NonControl1,\n\t\t\t4 => Opcode::NonControl2,\n\t\t\t5 => Opcode::NonControl3,\n\t\t\t6 => Opcode::NonControl4,\n\t\t\t7 => Opcode::NonControl5,\n\t\t\t8 => Opcode::Close,\n\t\t\t9 => Opcode::Ping,\n\t\t\t10 => Opcode::Pong,\n\t\t\t11 => Opcode::Control1,\n\t\t\t12 => Opcode::Control2,\n\t\t\t13 => Opcode::Control3,\n\t\t\t14 => Opcode::Control4,\n\t\t\t15 => Opcode::Control5,\n\t\t\t_ => return None,\n\t\t})\n\t}\n}\n\n#[cfg(all(feature = \"nightly\", test))]\nmod tests {\n\tuse super::*;\n\tuse test::Bencher;\n\tuse ws::dataframe::DataFrame as DataFrameable;\n\n\t#[test]\n\tfn test_read_dataframe() {\n\t\tlet data = b\"The quick brown fox jumps over the lazy dog\";\n\t\tlet mut dataframe = vec![0x81, 0x2B];\n\t\tfor i in data.iter() {\n\t\t\tdataframe.push(*i);\n\t\t}\n\t\tlet obtained = DataFrame::read_dataframe(&mut &dataframe[..], false).unwrap();\n\t\tlet expected = DataFrame {\n\t\t\tfinished: true,\n\t\t\treserved: [false; 3],\n\t\t\topcode: Opcode::Text,\n\t\t\tdata: data.to_vec(),\n\t\t};\n\t\tassert_eq!(obtained, expected);\n\t}\n\n\t#[test]\n\tfn read_incomplete_payloads() {\n\t\tlet mut data = vec![0x8au8, 0x08, 0x19, 0xac, 0xab, 0x8a, 0x52, 0x4e, 0x05, 0x00];\n\t\tlet payload = vec![25, 172, 171, 138, 82, 78, 5, 0];\n\t\tlet short_header = DataFrame::read_dataframe(&mut &data[..1], false);\n\t\tlet short_payload = DataFrame::read_dataframe(&mut &data[..6], false);\n\t\tlet full_payload = DataFrame::read_dataframe(&mut &data[..], false);\n\t\tdata.push(0xff);\n\t\tlet more_payload = DataFrame::read_dataframe(&mut &data[..], false);\n\n\t\tmatch (short_header.unwrap_err(), short_payload.unwrap_err()) {\n\t\t\t(WebSocketError::NoDataAvailable, WebSocketError::NoDataAvailable) => (),\n\t\t\t_ => assert!(false),\n\t\t};\n\t\tassert_eq!(full_payload.unwrap().data, payload);\n\t\tassert_eq!(more_payload.unwrap().data, payload);\n\t}\n\n\t#[bench]\n\tfn bench_read_dataframe(b: &mut Bencher) {\n\t\tlet data = b\"The quick brown fox jumps over the lazy dog\";\n\t\tlet mut dataframe = vec![0x81, 0x2B];\n\t\tfor i in data.iter() {\n\t\t\tdataframe.push(*i);\n\t\t}\n\t\tb.iter(|| {\n\t\t\tDataFrame::read_dataframe(&mut &dataframe[..], false).unwrap();\n\t\t});\n\t}\n\n\t#[test]\n\tfn test_write_dataframe() {\n\t\tlet data = b\"The quick brown fox jumps over the lazy dog\";\n\t\tlet mut expected = vec![0x81, 0x2B];\n\t\tfor i in data.iter() {\n\t\t\texpected.push(*i);\n\t\t}\n\t\tlet dataframe = DataFrame {\n\t\t\tfinished: true,\n\t\t\treserved: [false; 3],\n\t\t\topcode: Opcode::Text,\n\t\t\tdata: data.to_vec(),\n\t\t};\n\t\tlet mut obtained = Vec::new();\n\t\tdataframe.write_to(&mut obtained, false).unwrap();\n\n\t\tassert_eq!(&obtained[..], &expected[..]);\n\t}\n\n\t#[bench]\n\tfn bench_write_dataframe(b: &mut Bencher) {\n\t\tlet data = b\"The quick brown fox jumps over the lazy dog\";\n\t\tlet dataframe = DataFrame {\n\t\t\tfinished: true,\n\t\t\treserved: [false; 3],\n\t\t\topcode: Opcode::Text,\n\t\t\tdata: data.to_vec(),\n\t\t};\n\t\tlet mut writer = Vec::with_capacity(45);\n\t\tb.iter(|| {\n\t\t\tdataframe.write_to(&mut writer, false).unwrap();\n\t\t});\n\t}\n}\n"], "fixing_code": ["//! The default implementation of a WebSocket Receiver.\n\nuse std::io::Read;\nuse std::io::Result as IoResult;\n\nuse hyper::buffer::BufReader;\n\nuse crate::dataframe::{DataFrame, Opcode};\nuse crate::message::OwnedMessage;\nuse crate::result::{WebSocketError, WebSocketResult};\npub use crate::stream::sync::Shutdown;\nuse crate::stream::sync::{AsTcpStream, Stream};\nuse crate::ws;\nuse crate::ws::receiver::Receiver as ReceiverTrait;\nuse crate::ws::receiver::{DataFrameIterator, MessageIterator};\n\nconst DEFAULT_MAX_DATAFRAME_SIZE : usize = 1024*1024*100;\nconst DEFAULT_MAX_MESSAGE_SIZE : usize = 1024*1024*200;\nconst MAX_DATAFRAMES_IN_ONE_MESSAGE: usize = 1024*1024;\n\n/// This reader bundles an existing stream with a parsing algorithm.\n/// It is used by the client in its `.split()` function as the reading component.\npub struct Reader<R>\nwhere\n\tR: Read,\n{\n\t/// the stream to be read from\n\tpub stream: BufReader<R>,\n\t/// the parser to parse bytes into messages\n\tpub receiver: Receiver,\n}\n\nimpl<R> Reader<R>\nwhere\n\tR: Read,\n{\n\t/// Reads a single data frame from the remote endpoint.\n\tpub fn recv_dataframe(&mut self) -> WebSocketResult<DataFrame> {\n\t\tself.receiver.recv_dataframe(&mut self.stream)\n\t}\n\n\t/// Returns an iterator over incoming data frames.\n\tpub fn incoming_dataframes(&mut self) -> DataFrameIterator<Receiver, BufReader<R>> {\n\t\tself.receiver.incoming_dataframes(&mut self.stream)\n\t}\n\n\t/// Reads a single message from this receiver.\n\tpub fn recv_message(&mut self) -> WebSocketResult<OwnedMessage> {\n\t\tself.receiver.recv_message(&mut self.stream)\n\t}\n\n\t/// An iterator over incoming messsages.\n\t/// This iterator will block until new messages arrive and will never halt.\n\tpub fn incoming_messages<'a>(&'a mut self) -> MessageIterator<'a, Receiver, BufReader<R>> {\n\t\tself.receiver.incoming_messages(&mut self.stream)\n\t}\n}\n\nimpl<S> Reader<S>\nwhere\n\tS: AsTcpStream + Stream + Read,\n{\n\t/// Closes the receiver side of the connection, will cause all pending and future IO to\n\t/// return immediately with an appropriate value.\n\tpub fn shutdown(&self) -> IoResult<()> {\n\t\tself.stream.get_ref().as_tcp().shutdown(Shutdown::Read)\n\t}\n\n\t/// Shuts down both Sender and Receiver, will cause all pending and future IO to\n\t/// return immediately with an appropriate value.\n\tpub fn shutdown_all(&self) -> IoResult<()> {\n\t\tself.stream.get_ref().as_tcp().shutdown(Shutdown::Both)\n\t}\n}\n\n/// A Receiver that wraps a Reader and provides a default implementation using\n/// DataFrames and Messages.\npub struct Receiver {\n\tbuffer: Vec<DataFrame>,\n\tmask: bool,\n\t// u32s instead uf usizes to economize used memory by this struct\n\tmax_dataframe_size: u32,\n\tmax_message_size: u32,\n}\n\nimpl Receiver {\n\t/// Create a new Receiver using the specified Reader.\n\t/// \n\t/// Uses built-in limits for dataframe and message sizes. \n\tpub fn new(mask: bool) -> Receiver {\n\t\tReceiver::new_with_limits(mask, DEFAULT_MAX_DATAFRAME_SIZE, DEFAULT_MAX_MESSAGE_SIZE)\n\t}\n\n\t/// Create a new Receiver using the specified Reader, with configurable limits\n\t/// \n\t/// Sizes should not be larger than `u32::MAX`.\n\t/// \n\t/// Note that `max_message_size` denotes message size where no new dataframes would be read,\n\t/// so actual maximum message size is larger.\n\tpub fn new_with_limits(mask: bool, max_dataframe_size: usize, max_message_size: usize) -> Receiver {\n\t\tlet max_dataframe_size: u32 = max_dataframe_size.min(u32::MAX as usize) as u32;\n\t\tlet max_message_size: u32 = max_message_size.min(u32::MAX as usize) as u32;\n\t\tReceiver {\n\t\t\tbuffer: Vec::new(),\n\t\t\tmask,\n\t\t\tmax_dataframe_size,\n\t\t\tmax_message_size,\n\t\t}\n\t}\n}\n\nimpl ws::Receiver for Receiver {\n\ttype F = DataFrame;\n\n\ttype M = OwnedMessage;\n\n\t/// Reads a single data frame from the remote endpoint.\n\tfn recv_dataframe<R>(&mut self, reader: &mut R) -> WebSocketResult<DataFrame>\n\twhere\n\t\tR: Read,\n\t{\n\t\tDataFrame::read_dataframe_with_limit(reader, self.mask, self.max_dataframe_size as usize)\n\t}\n\n\t/// Returns the data frames that constitute one message.\n\tfn recv_message_dataframes<R>(&mut self, reader: &mut R) -> WebSocketResult<Vec<DataFrame>>\n\twhere\n\t\tR: Read,\n\t{\n\t\tlet mut current_message_length : usize = self.buffer.iter().map(|x|x.data.len()).sum();\n\t\tlet mut finished = if self.buffer.is_empty() {\n\t\t\tlet first = self.recv_dataframe(reader)?;\n\n\t\t\tif first.opcode == Opcode::Continuation {\n\t\t\t\treturn Err(WebSocketError::ProtocolError(\n\t\t\t\t\t\"Unexpected continuation data frame opcode\",\n\t\t\t\t));\n\t\t\t}\n\n\t\t\tlet finished = first.finished;\n\t\t\tcurrent_message_length += first.data.len();\n\t\t\tself.buffer.push(first);\n\t\t\tfinished\n\t\t} else {\n\t\t\tfalse\n\t\t};\n\n\t\twhile !finished {\n\t\t\tlet next = self.recv_dataframe(reader)?;\n\t\t\tfinished = next.finished;\n\n\t\t\tmatch next.opcode as u8 {\n\t\t\t\t// Continuation opcode\n\t\t\t\t0 => {\n\t\t\t\t\tcurrent_message_length += next.data.len();\n\t\t\t\t\tself.buffer.push(next)\n\t\t\t\t}\n\t\t\t\t// Control frame\n\t\t\t\t8..=15 => {\n\t\t\t\t\treturn Ok(vec![next]);\n\t\t\t\t}\n\t\t\t\t// Others\n\t\t\t\t_ => {\n\t\t\t\t\treturn Err(WebSocketError::ProtocolError(\n\t\t\t\t\t\t\"Unexpected data frame opcode\",\n\t\t\t\t\t));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif !finished {\n\t\t\t\tif self.buffer.len() >= MAX_DATAFRAMES_IN_ONE_MESSAGE {\n\t\t\t\t\treturn Err(WebSocketError::ProtocolError(\n\t\t\t\t\t\t\"Exceeded count of data frames in one WebSocket message\",\n\t\t\t\t\t));\n\t\t\t\t}\n\t\t\t\tif current_message_length >= self.max_message_size as usize {\n\t\t\t\t\treturn Err(WebSocketError::ProtocolError(\n\t\t\t\t\t\t\"Exceeded maximum WebSocket message size\",\n\t\t\t\t\t));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tOk(::std::mem::replace(&mut self.buffer, Vec::new()))\n\t}\n}\n", "//! Module containing the default implementation of data frames.\nuse crate::result::{WebSocketError, WebSocketResult};\nuse crate::ws::dataframe::DataFrame as DataFrameable;\nuse crate::ws::util::header as dfh;\nuse crate::ws::util::header::DataFrameHeader;\nuse crate::ws::util::mask;\nuse std::io::{self, Read, Write};\n\n/// Represents a WebSocket data frame.\n///\n/// The data held in a DataFrame is never masked.\n/// Masking/unmasking is done when sending and receiving the data frame,\n///\n/// This DataFrame, unlike the standard Message implementation (which also\n/// implements the DataFrame trait), owns its entire payload. This means that calls to `payload`\n/// don't allocate extra memory (again unlike the default Message implementation).\n#[derive(Debug, Clone, PartialEq)]\npub struct DataFrame {\n\t/// Whether or no this constitutes the end of a message\n\tpub finished: bool,\n\t/// The reserved portion of the data frame (RFC6455 5.2)\n\tpub reserved: [bool; 3],\n\t/// The opcode associated with this data frame\n\tpub opcode: Opcode,\n\t/// The payload associated with this data frame\n\tpub data: Vec<u8>,\n}\n\nimpl DataFrame {\n\t/// Creates a new DataFrame.\n\tpub fn new(finished: bool, opcode: Opcode, data: Vec<u8>) -> DataFrame {\n\t\tDataFrame {\n\t\t\tfinished,\n\t\t\treserved: [false; 3],\n\t\t\topcode,\n\t\t\tdata,\n\t\t}\n\t}\n\n\t/// Take the body and header of a dataframe and combine it into a single\n\t/// Dataframe struct. A websocket message can be made up of many individual\n\t/// dataframes, use the methods from the Message or OwnedMessage structs to\n\t/// take many of these and create a websocket message.\n\tpub fn read_dataframe_body(\n\t\theader: DataFrameHeader,\n\t\tbody: Vec<u8>,\n\t\tshould_be_masked: bool,\n\t) -> WebSocketResult<Self> {\n\t\tlet finished = header.flags.contains(dfh::DataFrameFlags::FIN);\n\n\t\tlet reserved = [\n\t\t\theader.flags.contains(dfh::DataFrameFlags::RSV1),\n\t\t\theader.flags.contains(dfh::DataFrameFlags::RSV2),\n\t\t\theader.flags.contains(dfh::DataFrameFlags::RSV3),\n\t\t];\n\n\t\tlet opcode = Opcode::new(header.opcode).expect(\"Invalid header opcode!\");\n\n\t\tlet data = match header.mask {\n\t\t\tSome(mask) => {\n\t\t\t\tif !should_be_masked {\n\t\t\t\t\treturn Err(WebSocketError::DataFrameError(\n\t\t\t\t\t\t\"Expected unmasked data frame\",\n\t\t\t\t\t));\n\t\t\t\t}\n\t\t\t\tmask::mask_data(mask, &body)\n\t\t\t}\n\t\t\tNone => {\n\t\t\t\tif should_be_masked {\n\t\t\t\t\treturn Err(WebSocketError::DataFrameError(\"Expected masked data frame\"));\n\t\t\t\t}\n\t\t\t\tbody\n\t\t\t}\n\t\t};\n\n\t\tOk(DataFrame {\n\t\t\tfinished,\n\t\t\treserved,\n\t\t\topcode,\n\t\t\tdata,\n\t\t})\n\t}\n\n\t/// Reads a DataFrame from a Reader.\n\tpub fn read_dataframe<R>(reader: &mut R, should_be_masked: bool) -> WebSocketResult<Self>\n\twhere\n\t\tR: Read,\n\t{\n\t\tlet header = dfh::read_header(reader)?;\n\n\t\tlet mut data: Vec<u8> = Vec::with_capacity(header.len as usize);\n\t\tlet read = reader.take(header.len).read_to_end(&mut data)?;\n\t\tif (read as u64) < header.len {\n\t\t\treturn Err(io::Error::new(io::ErrorKind::UnexpectedEof, \"incomplete payload\").into());\n\t\t}\n\n\t\tDataFrame::read_dataframe_body(header, data, should_be_masked)\n\t}\n\n\t/// Reads a DataFrame from a Reader, or error out if header declares exceeding limit you specify\n\tpub fn read_dataframe_with_limit<R>(reader: &mut R, should_be_masked: bool, limit: usize) -> WebSocketResult<Self>\n\twhere\n\t\tR: Read,\n\t{\n\t\tlet header = dfh::read_header(reader)?;\n\n\t\tif header.len > limit as u64 {\n\t\t\treturn Err(io::Error::new(io::ErrorKind::InvalidData, \"exceeded DataFrame length limit\").into());\n\t\t}\n\t\tlet mut data: Vec<u8> = Vec::with_capacity(header.len as usize);\n\t\tlet read = reader.take(header.len).read_to_end(&mut data)?;\n\t\tif (read as u64) < header.len {\n\t\t\treturn Err(io::Error::new(io::ErrorKind::UnexpectedEof, \"incomplete payload\").into());\n\t\t}\n\n\t\tDataFrame::read_dataframe_body(header, data, should_be_masked)\n\t}\n}\n\nimpl DataFrameable for DataFrame {\n\t#[inline(always)]\n\tfn is_last(&self) -> bool {\n\t\tself.finished\n\t}\n\n\t#[inline(always)]\n\tfn opcode(&self) -> u8 {\n\t\tself.opcode as u8\n\t}\n\n\t#[inline(always)]\n\tfn reserved(&self) -> &[bool; 3] {\n\t\t&self.reserved\n\t}\n\n\t#[inline(always)]\n\tfn size(&self) -> usize {\n\t\tself.data.len()\n\t}\n\n\t#[inline(always)]\n\tfn write_payload(&self, socket: &mut dyn Write) -> WebSocketResult<()> {\n\t\tsocket.write_all(self.data.as_slice())?;\n\t\tOk(())\n\t}\n\n\t#[inline(always)]\n\tfn take_payload(self) -> Vec<u8> {\n\t\tself.data\n\t}\n}\n\n/// Represents a WebSocket data frame opcode\n#[derive(Clone, Debug, Copy, PartialEq)]\npub enum Opcode {\n\t/// A continuation data frame\n\tContinuation,\n\t/// A UTF-8 text data frame\n\tText,\n\t/// A binary data frame\n\tBinary,\n\t/// An undefined non-control data frame\n\tNonControl1,\n\t/// An undefined non-control data frame\n\tNonControl2,\n\t/// An undefined non-control data frame\n\tNonControl3,\n\t/// An undefined non-control data frame\n\tNonControl4,\n\t/// An undefined non-control data frame\n\tNonControl5,\n\t/// A close data frame\n\tClose,\n\t/// A ping data frame\n\tPing,\n\t/// A pong data frame\n\tPong,\n\t/// An undefined control data frame\n\tControl1,\n\t/// An undefined control data frame\n\tControl2,\n\t/// An undefined control data frame\n\tControl3,\n\t/// An undefined control data frame\n\tControl4,\n\t/// An undefined control data frame\n\tControl5,\n}\n\nimpl Opcode {\n\t/// Attempts to form an Opcode from a nibble.\n\t///\n\t/// Returns the Opcode, or None if the opcode is out of range.\n\t#[warn(clippy::new_ret_no_self)]\n\tpub fn new(op: u8) -> Option<Opcode> {\n\t\tSome(match op {\n\t\t\t0 => Opcode::Continuation,\n\t\t\t1 => Opcode::Text,\n\t\t\t2 => Opcode::Binary,\n\t\t\t3 => Opcode::NonControl1,\n\t\t\t4 => Opcode::NonControl2,\n\t\t\t5 => Opcode::NonControl3,\n\t\t\t6 => Opcode::NonControl4,\n\t\t\t7 => Opcode::NonControl5,\n\t\t\t8 => Opcode::Close,\n\t\t\t9 => Opcode::Ping,\n\t\t\t10 => Opcode::Pong,\n\t\t\t11 => Opcode::Control1,\n\t\t\t12 => Opcode::Control2,\n\t\t\t13 => Opcode::Control3,\n\t\t\t14 => Opcode::Control4,\n\t\t\t15 => Opcode::Control5,\n\t\t\t_ => return None,\n\t\t})\n\t}\n}\n\n#[cfg(all(feature = \"nightly\", test))]\nmod tests {\n\tuse super::*;\n\tuse test::Bencher;\n\tuse ws::dataframe::DataFrame as DataFrameable;\n\n\t#[test]\n\tfn test_read_dataframe() {\n\t\tlet data = b\"The quick brown fox jumps over the lazy dog\";\n\t\tlet mut dataframe = vec![0x81, 0x2B];\n\t\tfor i in data.iter() {\n\t\t\tdataframe.push(*i);\n\t\t}\n\t\tlet obtained = DataFrame::read_dataframe(&mut &dataframe[..], false).unwrap();\n\t\tlet expected = DataFrame {\n\t\t\tfinished: true,\n\t\t\treserved: [false; 3],\n\t\t\topcode: Opcode::Text,\n\t\t\tdata: data.to_vec(),\n\t\t};\n\t\tassert_eq!(obtained, expected);\n\t}\n\n\t#[test]\n\tfn read_incomplete_payloads() {\n\t\tlet mut data = vec![0x8au8, 0x08, 0x19, 0xac, 0xab, 0x8a, 0x52, 0x4e, 0x05, 0x00];\n\t\tlet payload = vec![25, 172, 171, 138, 82, 78, 5, 0];\n\t\tlet short_header = DataFrame::read_dataframe(&mut &data[..1], false);\n\t\tlet short_payload = DataFrame::read_dataframe(&mut &data[..6], false);\n\t\tlet full_payload = DataFrame::read_dataframe(&mut &data[..], false);\n\t\tdata.push(0xff);\n\t\tlet more_payload = DataFrame::read_dataframe(&mut &data[..], false);\n\n\t\tmatch (short_header.unwrap_err(), short_payload.unwrap_err()) {\n\t\t\t(WebSocketError::NoDataAvailable, WebSocketError::NoDataAvailable) => (),\n\t\t\t_ => assert!(false),\n\t\t};\n\t\tassert_eq!(full_payload.unwrap().data, payload);\n\t\tassert_eq!(more_payload.unwrap().data, payload);\n\t}\n\n\t#[bench]\n\tfn bench_read_dataframe(b: &mut Bencher) {\n\t\tlet data = b\"The quick brown fox jumps over the lazy dog\";\n\t\tlet mut dataframe = vec![0x81, 0x2B];\n\t\tfor i in data.iter() {\n\t\t\tdataframe.push(*i);\n\t\t}\n\t\tb.iter(|| {\n\t\t\tDataFrame::read_dataframe(&mut &dataframe[..], false).unwrap();\n\t\t});\n\t}\n\n\t#[test]\n\tfn test_write_dataframe() {\n\t\tlet data = b\"The quick brown fox jumps over the lazy dog\";\n\t\tlet mut expected = vec![0x81, 0x2B];\n\t\tfor i in data.iter() {\n\t\t\texpected.push(*i);\n\t\t}\n\t\tlet dataframe = DataFrame {\n\t\t\tfinished: true,\n\t\t\treserved: [false; 3],\n\t\t\topcode: Opcode::Text,\n\t\t\tdata: data.to_vec(),\n\t\t};\n\t\tlet mut obtained = Vec::new();\n\t\tdataframe.write_to(&mut obtained, false).unwrap();\n\n\t\tassert_eq!(&obtained[..], &expected[..]);\n\t}\n\n\t#[bench]\n\tfn bench_write_dataframe(b: &mut Bencher) {\n\t\tlet data = b\"The quick brown fox jumps over the lazy dog\";\n\t\tlet dataframe = DataFrame {\n\t\t\tfinished: true,\n\t\t\treserved: [false; 3],\n\t\t\topcode: Opcode::Text,\n\t\t\tdata: data.to_vec(),\n\t\t};\n\t\tlet mut writer = Vec::with_capacity(45);\n\t\tb.iter(|| {\n\t\t\tdataframe.write_to(&mut writer, false).unwrap();\n\t\t});\n\t}\n}\n"], "filenames": ["src/receiver.rs", "websocket-base/src/dataframe.rs"], "buggy_code_start_loc": [15, 90], "buggy_code_end_loc": [140, 90], "fixing_code_start_loc": [16, 91], "fixing_code_end_loc": [182, 110], "type": "CWE-400", "message": "Rust-WebSocket is a WebSocket (RFC6455) library written in Rust. In versions prior to 0.26.5 untrusted websocket connections can cause an out-of-memory (OOM) process abort in a client or a server. The root cause of the issue is during dataframe parsing. Affected versions would allocate a buffer based on the declared dataframe size, which may come from an untrusted source. When `Vec::with_capacity` fails to allocate, the default Rust allocator will abort the current process, killing all threads. This affects only sync (non-Tokio) implementation. Async version also does not limit memory, but does not use `with_capacity`, so DoS can happen only when bytes for oversized dataframe or message actually got delivered by the attacker. The crashes are fixed in version 0.26.5 by imposing default dataframe size limits. Affected users are advised to update to this version. Users unable to upgrade are advised to filter websocket traffic externally or to only accept trusted traffic.", "other": {"cve": {"id": "CVE-2022-35922", "sourceIdentifier": "security-advisories@github.com", "published": "2022-08-01T22:15:10.460", "lastModified": "2022-10-26T18:06:37.477", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Rust-WebSocket is a WebSocket (RFC6455) library written in Rust. In versions prior to 0.26.5 untrusted websocket connections can cause an out-of-memory (OOM) process abort in a client or a server. The root cause of the issue is during dataframe parsing. Affected versions would allocate a buffer based on the declared dataframe size, which may come from an untrusted source. When `Vec::with_capacity` fails to allocate, the default Rust allocator will abort the current process, killing all threads. This affects only sync (non-Tokio) implementation. Async version also does not limit memory, but does not use `with_capacity`, so DoS can happen only when bytes for oversized dataframe or message actually got delivered by the attacker. The crashes are fixed in version 0.26.5 by imposing default dataframe size limits. Affected users are advised to update to this version. Users unable to upgrade are advised to filter websocket traffic externally or to only accept trusted traffic."}, {"lang": "es", "value": "Rust-WebSocket es una biblioteca WebSocket (RFC6455) escrita en Rust. En versiones anteriores a la 0.26.5, las conexiones de websocket que no son confiables pueden causar una interrupci\u00f3n del proceso por falta de memoria (OOM) en un cliente o un servidor. La causa del problema es durante el an\u00e1lisis de los marcos de datos. Las versiones afectadas asignan un b\u00fafer basado en el tama\u00f1o declarado del marco de datos, que puede provenir de una fuente no confiable. Cuando \"Vec::with_capacity\" falla en la asignaci\u00f3n, el asignador por defecto de Rust abortar\u00e1 el proceso actual, matando todos los hilos. Esto afecta s\u00f3lo a la implementaci\u00f3n sync (no-Tokio). La versi\u00f3n as\u00edncrona tampoco limita la memoria, pero no usa \"with_capacity\", por lo que el DoS puede ocurrir s\u00f3lo cuando los bytes para el marco de datos o el mensaje sobredimensionados son realmente entregados por el atacante. Los bloqueos son corregidos en versi\u00f3n 0.26.5, al imponer l\u00edmites de tama\u00f1o de dataframe por defecto. Es recomendado a usuarios afectados actualizar a esta versi\u00f3n. Es recomendado a usuarios que no puedan actualizar filtrar el tr\u00e1fico de websocket externamente o que s\u00f3lo acepten tr\u00e1fico confiable"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-400"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:rust-websocket_project:rust-websocket:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.26.5", "matchCriteriaId": "2ABBA7B4-72B4-4792-ACE3-012315F713DF"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:35:*:*:*:*:*:*:*", "matchCriteriaId": "80E516C0-98A4-4ADE-B69F-66A772E2BAAA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:36:*:*:*:*:*:*:*", "matchCriteriaId": "5C675112-476C-4D7C-BCB9-A2FB2D0BC9FD"}]}]}], "references": [{"url": "https://github.com/websockets-rs/rust-websocket/commit/cbf6e9983e839d2ecad86de8cd1b3f20ed43390b", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/websockets-rs/rust-websocket/security/advisories/GHSA-qrjv-rf5q-qpxc", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/4V2EOOU5OLEHVMKAH6BALQXKDKIZRXCI/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/HYPNCM4H4OFBIZI6XMJ2DUTS54FT2TWP/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/websockets-rs/rust-websocket/commit/cbf6e9983e839d2ecad86de8cd1b3f20ed43390b"}}