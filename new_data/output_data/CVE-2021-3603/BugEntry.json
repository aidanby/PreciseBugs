{"buggy_code": ["# Security notices relating to PHPMailer\n\nPlease disclose any security issues or vulnerabilities found through [Tidelift's coordinated disclosure system](https://tidelift.com/security) or to the maintainers privately.\n\nPHPMailer 6.4.1 and earlier contain a vulnerability that can result in untrusted code being called (if such code is injected into the host project's scope by other means). If the `$patternselect` parameter to `validateAddress()` is set to `'php'` (the default, defined by `static::$validator`), and the global namespace contains a function called `php`, it will be called in preference to the built-in validator of the same name. This is patched in PHPMailer 6.5.0 by denying the use of callables with the same names as built-in validators. Reported by [Vikrant Singh Chauhan](mailto:vi@hackberry.xyz) via [huntr.dev](https://www.huntr.dev/). Recorded as [CVE-2021-3603](https://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2021-3603).\n\nPHPMailer versions between 6.1.8 and 6.4.0 contain a regression of the earlier CVE-2018-19296 object injection vulnerability as a result of [a fix for Windows UNC paths in 6.1.8](https://github.com/PHPMailer/PHPMailer/commit/e2e07a355ee8ff36aba21d0242c5950c56e4c6f9). Recorded as [CVE-2020-36326](https://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2020-36326). Reported by Fariskhi Vidyan via Tidelift. 6.4.1 fixes this issue, and also enforces stricter checks for URL schemes in local path contexts.\n\nPHPMailer versions 6.1.5 and earlier contain an output escaping bug that occurs in `Content-Type` and `Content-Disposition` when filenames passed into `addAttachment` and other methods that accept attachment names contain double quote characters, in contravention of RFC822 3.4.1. No specific vulnerability has been found relating to this, but it could allow file attachments to bypass attachment filters that are based on matching filename extensions. Recorded as [CVE-2020-13625](https://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2020-13625). Reported by Elar Lang of Clarified Security.\n\nPHPMailer versions prior to 6.0.6 and 5.2.27 are vulnerable to an object injection attack by passing `phar://` paths into `addAttachment()` and other functions that may receive unfiltered local paths, possibly leading to RCE. Recorded as [CVE-2018-19296](https://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2018-19296). See [this article](https://knasmueller.net/5-answers-about-php-phar-exploitation) for more info on this type of vulnerability. Mitigated by blocking the use of paths containing URL-protocol style prefixes such as `phar://`. Reported by Sehun Oh of cyberone.kr.\n\nPHPMailer versions prior to 5.2.24 (released July 26th 2017) have an XSS vulnerability in one of the code examples, [CVE-2017-11503](https://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2017-11503). The `code_generator.phps` example did not filter user input prior to output. This file is distributed with a `.phps` extension, so it it not normally executable unless it is explicitly renamed, and the file is not included when PHPMailer is loaded through composer, so it is safe by default. There was also an undisclosed potential XSS vulnerability in the default exception handler (unused by default). Patches for both issues kindly provided by Patrick Monnerat of the Fedora Project.\n\nPHPMailer versions prior to 5.2.22 (released January 9th 2017) have a local file disclosure vulnerability, [CVE-2017-5223](https://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2017-5223). If content passed into `msgHTML()` is sourced from unfiltered user input, relative paths can map to absolute local file paths and added as attachments. Also note that `addAttachment` (just like `file_get_contents`, `passthru`, `unlink`, etc) should not be passed user-sourced params either! Reported by Yongxiang Li of Asiasecurity.\n\nPHPMailer versions prior to 5.2.20 (released December 28th 2016) are vulnerable to [CVE-2016-10045](https://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2016-10045) a remote code execution vulnerability, responsibly reported by [Dawid Golunski](https://legalhackers.com/advisories/PHPMailer-Exploit-Remote-Code-Exec-CVE-2016-10045-Vuln-Patch-Bypass.html), and patched by Paul Buonopane (@Zenexer).\n\nPHPMailer versions prior to 5.2.18 (released December 2016) are vulnerable to [CVE-2016-10033](https://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2016-10033) a remote code execution vulnerability, responsibly reported by [Dawid Golunski](http://legalhackers.com/advisories/PHPMailer-Exploit-Remote-Code-Exec-CVE-2016-10033-Vuln.html).\n\nPHPMailer versions prior to 5.2.14 (released November 2015) are vulnerable to [CVE-2015-8476](https://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2015-8476) an SMTP CRLF injection bug permitting arbitrary message sending.\n\nPHPMailer versions prior to 5.2.10 (released May 2015) are vulnerable to [CVE-2008-5619](https://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2008-5619), a remote code execution vulnerability in the bundled html2text library. This file was removed in 5.2.10, so if you are using a version prior to that and make use of the html2text function, it's vitally important that you upgrade and remove this file.\n\nPHPMailer versions prior to 2.0.7 and 2.2.1 are vulnerable to [CVE-2012-0796](https://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2012-0796), an email header injection attack.\n\nJoomla 1.6.0 uses PHPMailer in an unsafe way, allowing it to reveal local file paths, reported in [CVE-2011-3747](https://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2011-3747).\n\nPHPMailer didn't sanitise the `$lang_path` parameter in `SetLanguage`. This wasn't a problem in itself, but some apps (PHPClassifieds, ATutor) also failed to sanitise user-provided parameters passed to it, permitting semi-arbitrary local file inclusion, reported in [CVE-2010-4914](https://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2010-4914), [CVE-2007-2021](https://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2007-2021) and [CVE-2006-5734](https://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2006-5734).\n\nPHPMailer 1.7.2 and earlier contained a possible DDoS vulnerability reported in [CVE-2005-1807](https://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2005-1807).\n\nPHPMailer 1.7 and earlier (June 2003) have a possible vulnerability in the `SendmailSend` method where shell commands may not be sanitised. Reported in [CVE-2007-3215](https://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2007-3215).\n\n", "<?php\n\n/**\n * PHPMailer - PHP email creation and transport class.\n * PHP Version 5.5.\n *\n * @see https://github.com/PHPMailer/PHPMailer/ The PHPMailer GitHub project\n *\n * @author    Marcus Bointon (Synchro/coolbru) <phpmailer@synchromedia.co.uk>\n * @author    Jim Jagielski (jimjag) <jimjag@gmail.com>\n * @author    Andy Prevost (codeworxtech) <codeworxtech@users.sourceforge.net>\n * @author    Brent R. Matzelle (original founder)\n * @copyright 2012 - 2020 Marcus Bointon\n * @copyright 2010 - 2012 Jim Jagielski\n * @copyright 2004 - 2009 Andy Prevost\n * @license   http://www.gnu.org/copyleft/lesser.html GNU Lesser General Public License\n * @note      This program is distributed in the hope that it will be useful - WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.\n */\n\nnamespace PHPMailer\\PHPMailer;\n\n/**\n * PHPMailer - PHP email creation and transport class.\n *\n * @author Marcus Bointon (Synchro/coolbru) <phpmailer@synchromedia.co.uk>\n * @author Jim Jagielski (jimjag) <jimjag@gmail.com>\n * @author Andy Prevost (codeworxtech) <codeworxtech@users.sourceforge.net>\n * @author Brent R. Matzelle (original founder)\n */\nclass PHPMailer\n{\n    const CHARSET_ASCII = 'us-ascii';\n    const CHARSET_ISO88591 = 'iso-8859-1';\n    const CHARSET_UTF8 = 'utf-8';\n\n    const CONTENT_TYPE_PLAINTEXT = 'text/plain';\n    const CONTENT_TYPE_TEXT_CALENDAR = 'text/calendar';\n    const CONTENT_TYPE_TEXT_HTML = 'text/html';\n    const CONTENT_TYPE_MULTIPART_ALTERNATIVE = 'multipart/alternative';\n    const CONTENT_TYPE_MULTIPART_MIXED = 'multipart/mixed';\n    const CONTENT_TYPE_MULTIPART_RELATED = 'multipart/related';\n\n    const ENCODING_7BIT = '7bit';\n    const ENCODING_8BIT = '8bit';\n    const ENCODING_BASE64 = 'base64';\n    const ENCODING_BINARY = 'binary';\n    const ENCODING_QUOTED_PRINTABLE = 'quoted-printable';\n\n    const ENCRYPTION_STARTTLS = 'tls';\n    const ENCRYPTION_SMTPS = 'ssl';\n\n    const ICAL_METHOD_REQUEST = 'REQUEST';\n    const ICAL_METHOD_PUBLISH = 'PUBLISH';\n    const ICAL_METHOD_REPLY = 'REPLY';\n    const ICAL_METHOD_ADD = 'ADD';\n    const ICAL_METHOD_CANCEL = 'CANCEL';\n    const ICAL_METHOD_REFRESH = 'REFRESH';\n    const ICAL_METHOD_COUNTER = 'COUNTER';\n    const ICAL_METHOD_DECLINECOUNTER = 'DECLINECOUNTER';\n\n    /**\n     * Email priority.\n     * Options: null (default), 1 = High, 3 = Normal, 5 = low.\n     * When null, the header is not set at all.\n     *\n     * @var int|null\n     */\n    public $Priority;\n\n    /**\n     * The character set of the message.\n     *\n     * @var string\n     */\n    public $CharSet = self::CHARSET_ISO88591;\n\n    /**\n     * The MIME Content-type of the message.\n     *\n     * @var string\n     */\n    public $ContentType = self::CONTENT_TYPE_PLAINTEXT;\n\n    /**\n     * The message encoding.\n     * Options: \"8bit\", \"7bit\", \"binary\", \"base64\", and \"quoted-printable\".\n     *\n     * @var string\n     */\n    public $Encoding = self::ENCODING_8BIT;\n\n    /**\n     * Holds the most recent mailer error message.\n     *\n     * @var string\n     */\n    public $ErrorInfo = '';\n\n    /**\n     * The From email address for the message.\n     *\n     * @var string\n     */\n    public $From = 'root@localhost';\n\n    /**\n     * The From name of the message.\n     *\n     * @var string\n     */\n    public $FromName = 'Root User';\n\n    /**\n     * The envelope sender of the message.\n     * This will usually be turned into a Return-Path header by the receiver,\n     * and is the address that bounces will be sent to.\n     * If not empty, will be passed via `-f` to sendmail or as the 'MAIL FROM' value over SMTP.\n     *\n     * @var string\n     */\n    public $Sender = '';\n\n    /**\n     * The Subject of the message.\n     *\n     * @var string\n     */\n    public $Subject = '';\n\n    /**\n     * An HTML or plain text message body.\n     * If HTML then call isHTML(true).\n     *\n     * @var string\n     */\n    public $Body = '';\n\n    /**\n     * The plain-text message body.\n     * This body can be read by mail clients that do not have HTML email\n     * capability such as mutt & Eudora.\n     * Clients that can read HTML will view the normal Body.\n     *\n     * @var string\n     */\n    public $AltBody = '';\n\n    /**\n     * An iCal message part body.\n     * Only supported in simple alt or alt_inline message types\n     * To generate iCal event structures, use classes like EasyPeasyICS or iCalcreator.\n     *\n     * @see http://sprain.ch/blog/downloads/php-class-easypeasyics-create-ical-files-with-php/\n     * @see http://kigkonsult.se/iCalcreator/\n     *\n     * @var string\n     */\n    public $Ical = '';\n\n    /**\n     * Value-array of \"method\" in Contenttype header \"text/calendar\"\n     *\n     * @var string[]\n     */\n    protected static $IcalMethods = [\n        self::ICAL_METHOD_REQUEST,\n        self::ICAL_METHOD_PUBLISH,\n        self::ICAL_METHOD_REPLY,\n        self::ICAL_METHOD_ADD,\n        self::ICAL_METHOD_CANCEL,\n        self::ICAL_METHOD_REFRESH,\n        self::ICAL_METHOD_COUNTER,\n        self::ICAL_METHOD_DECLINECOUNTER,\n    ];\n\n    /**\n     * The complete compiled MIME message body.\n     *\n     * @var string\n     */\n    protected $MIMEBody = '';\n\n    /**\n     * The complete compiled MIME message headers.\n     *\n     * @var string\n     */\n    protected $MIMEHeader = '';\n\n    /**\n     * Extra headers that createHeader() doesn't fold in.\n     *\n     * @var string\n     */\n    protected $mailHeader = '';\n\n    /**\n     * Word-wrap the message body to this number of chars.\n     * Set to 0 to not wrap. A useful value here is 78, for RFC2822 section 2.1.1 compliance.\n     *\n     * @see static::STD_LINE_LENGTH\n     *\n     * @var int\n     */\n    public $WordWrap = 0;\n\n    /**\n     * Which method to use to send mail.\n     * Options: \"mail\", \"sendmail\", or \"smtp\".\n     *\n     * @var string\n     */\n    public $Mailer = 'mail';\n\n    /**\n     * The path to the sendmail program.\n     *\n     * @var string\n     */\n    public $Sendmail = '/usr/sbin/sendmail';\n\n    /**\n     * Whether mail() uses a fully sendmail-compatible MTA.\n     * One which supports sendmail's \"-oi -f\" options.\n     *\n     * @var bool\n     */\n    public $UseSendmailOptions = true;\n\n    /**\n     * The email address that a reading confirmation should be sent to, also known as read receipt.\n     *\n     * @var string\n     */\n    public $ConfirmReadingTo = '';\n\n    /**\n     * The hostname to use in the Message-ID header and as default HELO string.\n     * If empty, PHPMailer attempts to find one with, in order,\n     * $_SERVER['SERVER_NAME'], gethostname(), php_uname('n'), or the value\n     * 'localhost.localdomain'.\n     *\n     * @see PHPMailer::$Helo\n     *\n     * @var string\n     */\n    public $Hostname = '';\n\n    /**\n     * An ID to be used in the Message-ID header.\n     * If empty, a unique id will be generated.\n     * You can set your own, but it must be in the format \"<id@domain>\",\n     * as defined in RFC5322 section 3.6.4 or it will be ignored.\n     *\n     * @see https://tools.ietf.org/html/rfc5322#section-3.6.4\n     *\n     * @var string\n     */\n    public $MessageID = '';\n\n    /**\n     * The message Date to be used in the Date header.\n     * If empty, the current date will be added.\n     *\n     * @var string\n     */\n    public $MessageDate = '';\n\n    /**\n     * SMTP hosts.\n     * Either a single hostname or multiple semicolon-delimited hostnames.\n     * You can also specify a different port\n     * for each host by using this format: [hostname:port]\n     * (e.g. \"smtp1.example.com:25;smtp2.example.com\").\n     * You can also specify encryption type, for example:\n     * (e.g. \"tls://smtp1.example.com:587;ssl://smtp2.example.com:465\").\n     * Hosts will be tried in order.\n     *\n     * @var string\n     */\n    public $Host = 'localhost';\n\n    /**\n     * The default SMTP server port.\n     *\n     * @var int\n     */\n    public $Port = 25;\n\n    /**\n     * The SMTP HELO/EHLO name used for the SMTP connection.\n     * Default is $Hostname. If $Hostname is empty, PHPMailer attempts to find\n     * one with the same method described above for $Hostname.\n     *\n     * @see PHPMailer::$Hostname\n     *\n     * @var string\n     */\n    public $Helo = '';\n\n    /**\n     * What kind of encryption to use on the SMTP connection.\n     * Options: '', static::ENCRYPTION_STARTTLS, or static::ENCRYPTION_SMTPS.\n     *\n     * @var string\n     */\n    public $SMTPSecure = '';\n\n    /**\n     * Whether to enable TLS encryption automatically if a server supports it,\n     * even if `SMTPSecure` is not set to 'tls'.\n     * Be aware that in PHP >= 5.6 this requires that the server's certificates are valid.\n     *\n     * @var bool\n     */\n    public $SMTPAutoTLS = true;\n\n    /**\n     * Whether to use SMTP authentication.\n     * Uses the Username and Password properties.\n     *\n     * @see PHPMailer::$Username\n     * @see PHPMailer::$Password\n     *\n     * @var bool\n     */\n    public $SMTPAuth = false;\n\n    /**\n     * Options array passed to stream_context_create when connecting via SMTP.\n     *\n     * @var array\n     */\n    public $SMTPOptions = [];\n\n    /**\n     * SMTP username.\n     *\n     * @var string\n     */\n    public $Username = '';\n\n    /**\n     * SMTP password.\n     *\n     * @var string\n     */\n    public $Password = '';\n\n    /**\n     * SMTP auth type.\n     * Options are CRAM-MD5, LOGIN, PLAIN, XOAUTH2, attempted in that order if not specified.\n     *\n     * @var string\n     */\n    public $AuthType = '';\n\n    /**\n     * An instance of the PHPMailer OAuth class.\n     *\n     * @var OAuth\n     */\n    protected $oauth;\n\n    /**\n     * The SMTP server timeout in seconds.\n     * Default of 5 minutes (300sec) is from RFC2821 section 4.5.3.2.\n     *\n     * @var int\n     */\n    public $Timeout = 300;\n\n    /**\n     * Comma separated list of DSN notifications\n     * 'NEVER' under no circumstances a DSN must be returned to the sender.\n     *         If you use NEVER all other notifications will be ignored.\n     * 'SUCCESS' will notify you when your mail has arrived at its destination.\n     * 'FAILURE' will arrive if an error occurred during delivery.\n     * 'DELAY'   will notify you if there is an unusual delay in delivery, but the actual\n     *           delivery's outcome (success or failure) is not yet decided.\n     *\n     * @see https://tools.ietf.org/html/rfc3461 See section 4.1 for more information about NOTIFY\n     */\n    public $dsn = '';\n\n    /**\n     * SMTP class debug output mode.\n     * Debug output level.\n     * Options:\n     * @see SMTP::DEBUG_OFF: No output\n     * @see SMTP::DEBUG_CLIENT: Client messages\n     * @see SMTP::DEBUG_SERVER: Client and server messages\n     * @see SMTP::DEBUG_CONNECTION: As SERVER plus connection status\n     * @see SMTP::DEBUG_LOWLEVEL: Noisy, low-level data output, rarely needed\n     *\n     * @see SMTP::$do_debug\n     *\n     * @var int\n     */\n    public $SMTPDebug = 0;\n\n    /**\n     * How to handle debug output.\n     * Options:\n     * * `echo` Output plain-text as-is, appropriate for CLI\n     * * `html` Output escaped, line breaks converted to `<br>`, appropriate for browser output\n     * * `error_log` Output to error log as configured in php.ini\n     * By default PHPMailer will use `echo` if run from a `cli` or `cli-server` SAPI, `html` otherwise.\n     * Alternatively, you can provide a callable expecting two params: a message string and the debug level:\n     *\n     * ```php\n     * $mail->Debugoutput = function($str, $level) {echo \"debug level $level; message: $str\";};\n     * ```\n     *\n     * Alternatively, you can pass in an instance of a PSR-3 compatible logger, though only `debug`\n     * level output is used:\n     *\n     * ```php\n     * $mail->Debugoutput = new myPsr3Logger;\n     * ```\n     *\n     * @see SMTP::$Debugoutput\n     *\n     * @var string|callable|\\Psr\\Log\\LoggerInterface\n     */\n    public $Debugoutput = 'echo';\n\n    /**\n     * Whether to keep the SMTP connection open after each message.\n     * If this is set to true then the connection will remain open after a send,\n     * and closing the connection will require an explicit call to smtpClose().\n     * It's a good idea to use this if you are sending multiple messages as it reduces overhead.\n     * See the mailing list example for how to use it.\n     *\n     * @var bool\n     */\n    public $SMTPKeepAlive = false;\n\n    /**\n     * Whether to split multiple to addresses into multiple messages\n     * or send them all in one message.\n     * Only supported in `mail` and `sendmail` transports, not in SMTP.\n     *\n     * @var bool\n     *\n     * @deprecated 6.0.0 PHPMailer isn't a mailing list manager!\n     */\n    public $SingleTo = false;\n\n    /**\n     * Storage for addresses when SingleTo is enabled.\n     *\n     * @var array\n     */\n    protected $SingleToArray = [];\n\n    /**\n     * Whether to generate VERP addresses on send.\n     * Only applicable when sending via SMTP.\n     *\n     * @see https://en.wikipedia.org/wiki/Variable_envelope_return_path\n     * @see http://www.postfix.org/VERP_README.html Postfix VERP info\n     *\n     * @var bool\n     */\n    public $do_verp = false;\n\n    /**\n     * Whether to allow sending messages with an empty body.\n     *\n     * @var bool\n     */\n    public $AllowEmpty = false;\n\n    /**\n     * DKIM selector.\n     *\n     * @var string\n     */\n    public $DKIM_selector = '';\n\n    /**\n     * DKIM Identity.\n     * Usually the email address used as the source of the email.\n     *\n     * @var string\n     */\n    public $DKIM_identity = '';\n\n    /**\n     * DKIM passphrase.\n     * Used if your key is encrypted.\n     *\n     * @var string\n     */\n    public $DKIM_passphrase = '';\n\n    /**\n     * DKIM signing domain name.\n     *\n     * @example 'example.com'\n     *\n     * @var string\n     */\n    public $DKIM_domain = '';\n\n    /**\n     * DKIM Copy header field values for diagnostic use.\n     *\n     * @var bool\n     */\n    public $DKIM_copyHeaderFields = true;\n\n    /**\n     * DKIM Extra signing headers.\n     *\n     * @example ['List-Unsubscribe', 'List-Help']\n     *\n     * @var array\n     */\n    public $DKIM_extraHeaders = [];\n\n    /**\n     * DKIM private key file path.\n     *\n     * @var string\n     */\n    public $DKIM_private = '';\n\n    /**\n     * DKIM private key string.\n     *\n     * If set, takes precedence over `$DKIM_private`.\n     *\n     * @var string\n     */\n    public $DKIM_private_string = '';\n\n    /**\n     * Callback Action function name.\n     *\n     * The function that handles the result of the send email action.\n     * It is called out by send() for each email sent.\n     *\n     * Value can be any php callable: http://www.php.net/is_callable\n     *\n     * Parameters:\n     *   bool $result        result of the send action\n     *   array   $to            email addresses of the recipients\n     *   array   $cc            cc email addresses\n     *   array   $bcc           bcc email addresses\n     *   string  $subject       the subject\n     *   string  $body          the email body\n     *   string  $from          email address of sender\n     *   string  $extra         extra information of possible use\n     *                          \"smtp_transaction_id' => last smtp transaction id\n     *\n     * @var string\n     */\n    public $action_function = '';\n\n    /**\n     * What to put in the X-Mailer header.\n     * Options: An empty string for PHPMailer default, whitespace/null for none, or a string to use.\n     *\n     * @var string|null\n     */\n    public $XMailer = '';\n\n    /**\n     * Which validator to use by default when validating email addresses.\n     * May be a callable to inject your own validator, but there are several built-in validators.\n     * The default validator uses PHP's FILTER_VALIDATE_EMAIL filter_var option.\n     *\n     * @see PHPMailer::validateAddress()\n     *\n     * @var string|callable\n     */\n    public static $validator = 'php';\n\n    /**\n     * An instance of the SMTP sender class.\n     *\n     * @var SMTP\n     */\n    protected $smtp;\n\n    /**\n     * The array of 'to' names and addresses.\n     *\n     * @var array\n     */\n    protected $to = [];\n\n    /**\n     * The array of 'cc' names and addresses.\n     *\n     * @var array\n     */\n    protected $cc = [];\n\n    /**\n     * The array of 'bcc' names and addresses.\n     *\n     * @var array\n     */\n    protected $bcc = [];\n\n    /**\n     * The array of reply-to names and addresses.\n     *\n     * @var array\n     */\n    protected $ReplyTo = [];\n\n    /**\n     * An array of all kinds of addresses.\n     * Includes all of $to, $cc, $bcc.\n     *\n     * @see PHPMailer::$to\n     * @see PHPMailer::$cc\n     * @see PHPMailer::$bcc\n     *\n     * @var array\n     */\n    protected $all_recipients = [];\n\n    /**\n     * An array of names and addresses queued for validation.\n     * In send(), valid and non duplicate entries are moved to $all_recipients\n     * and one of $to, $cc, or $bcc.\n     * This array is used only for addresses with IDN.\n     *\n     * @see PHPMailer::$to\n     * @see PHPMailer::$cc\n     * @see PHPMailer::$bcc\n     * @see PHPMailer::$all_recipients\n     *\n     * @var array\n     */\n    protected $RecipientsQueue = [];\n\n    /**\n     * An array of reply-to names and addresses queued for validation.\n     * In send(), valid and non duplicate entries are moved to $ReplyTo.\n     * This array is used only for addresses with IDN.\n     *\n     * @see PHPMailer::$ReplyTo\n     *\n     * @var array\n     */\n    protected $ReplyToQueue = [];\n\n    /**\n     * The array of attachments.\n     *\n     * @var array\n     */\n    protected $attachment = [];\n\n    /**\n     * The array of custom headers.\n     *\n     * @var array\n     */\n    protected $CustomHeader = [];\n\n    /**\n     * The most recent Message-ID (including angular brackets).\n     *\n     * @var string\n     */\n    protected $lastMessageID = '';\n\n    /**\n     * The message's MIME type.\n     *\n     * @var string\n     */\n    protected $message_type = '';\n\n    /**\n     * The array of MIME boundary strings.\n     *\n     * @var array\n     */\n    protected $boundary = [];\n\n    /**\n     * The array of available languages.\n     *\n     * @var array\n     */\n    protected $language = [];\n\n    /**\n     * The number of errors encountered.\n     *\n     * @var int\n     */\n    protected $error_count = 0;\n\n    /**\n     * The S/MIME certificate file path.\n     *\n     * @var string\n     */\n    protected $sign_cert_file = '';\n\n    /**\n     * The S/MIME key file path.\n     *\n     * @var string\n     */\n    protected $sign_key_file = '';\n\n    /**\n     * The optional S/MIME extra certificates (\"CA Chain\") file path.\n     *\n     * @var string\n     */\n    protected $sign_extracerts_file = '';\n\n    /**\n     * The S/MIME password for the key.\n     * Used only if the key is encrypted.\n     *\n     * @var string\n     */\n    protected $sign_key_pass = '';\n\n    /**\n     * Whether to throw exceptions for errors.\n     *\n     * @var bool\n     */\n    protected $exceptions = false;\n\n    /**\n     * Unique ID used for message ID and boundaries.\n     *\n     * @var string\n     */\n    protected $uniqueid = '';\n\n    /**\n     * The PHPMailer Version number.\n     *\n     * @var string\n     */\n    const VERSION = '6.4.1';\n\n    /**\n     * Error severity: message only, continue processing.\n     *\n     * @var int\n     */\n    const STOP_MESSAGE = 0;\n\n    /**\n     * Error severity: message, likely ok to continue processing.\n     *\n     * @var int\n     */\n    const STOP_CONTINUE = 1;\n\n    /**\n     * Error severity: message, plus full stop, critical error reached.\n     *\n     * @var int\n     */\n    const STOP_CRITICAL = 2;\n\n    /**\n     * The SMTP standard CRLF line break.\n     * If you want to change line break format, change static::$LE, not this.\n     */\n    const CRLF = \"\\r\\n\";\n\n    /**\n     * \"Folding White Space\" a white space string used for line folding.\n     */\n    const FWS = ' ';\n\n    /**\n     * SMTP RFC standard line ending; Carriage Return, Line Feed.\n     *\n     * @var string\n     */\n    protected static $LE = self::CRLF;\n\n    /**\n     * The maximum line length supported by mail().\n     *\n     * Background: mail() will sometimes corrupt messages\n     * with headers headers longer than 65 chars, see #818.\n     *\n     * @var int\n     */\n    const MAIL_MAX_LINE_LENGTH = 63;\n\n    /**\n     * The maximum line length allowed by RFC 2822 section 2.1.1.\n     *\n     * @var int\n     */\n    const MAX_LINE_LENGTH = 998;\n\n    /**\n     * The lower maximum line length allowed by RFC 2822 section 2.1.1.\n     * This length does NOT include the line break\n     * 76 means that lines will be 77 or 78 chars depending on whether\n     * the line break format is LF or CRLF; both are valid.\n     *\n     * @var int\n     */\n    const STD_LINE_LENGTH = 76;\n\n    /**\n     * Constructor.\n     *\n     * @param bool $exceptions Should we throw external exceptions?\n     */\n    public function __construct($exceptions = null)\n    {\n        if (null !== $exceptions) {\n            $this->exceptions = (bool) $exceptions;\n        }\n        //Pick an appropriate debug output format automatically\n        $this->Debugoutput = (strpos(PHP_SAPI, 'cli') !== false ? 'echo' : 'html');\n    }\n\n    /**\n     * Destructor.\n     */\n    public function __destruct()\n    {\n        //Close any open SMTP connection nicely\n        $this->smtpClose();\n    }\n\n    /**\n     * Call mail() in a safe_mode-aware fashion.\n     * Also, unless sendmail_path points to sendmail (or something that\n     * claims to be sendmail), don't pass params (not a perfect fix,\n     * but it will do).\n     *\n     * @param string      $to      To\n     * @param string      $subject Subject\n     * @param string      $body    Message Body\n     * @param string      $header  Additional Header(s)\n     * @param string|null $params  Params\n     *\n     * @return bool\n     */\n    private function mailPassthru($to, $subject, $body, $header, $params)\n    {\n        //Check overloading of mail function to avoid double-encoding\n        if (ini_get('mbstring.func_overload') & 1) {\n            $subject = $this->secureHeader($subject);\n        } else {\n            $subject = $this->encodeHeader($this->secureHeader($subject));\n        }\n        //Calling mail() with null params breaks\n        $this->edebug('Sending with mail()');\n        $this->edebug('Sendmail path: ' . ini_get('sendmail_path'));\n        $this->edebug(\"Envelope sender: {$this->Sender}\");\n        $this->edebug(\"To: {$to}\");\n        $this->edebug(\"Subject: {$subject}\");\n        $this->edebug(\"Headers: {$header}\");\n        if (!$this->UseSendmailOptions || null === $params) {\n            $result = @mail($to, $subject, $body, $header);\n        } else {\n            $this->edebug(\"Additional params: {$params}\");\n            $result = @mail($to, $subject, $body, $header, $params);\n        }\n        $this->edebug('Result: ' . ($result ? 'true' : 'false'));\n        return $result;\n    }\n\n    /**\n     * Output debugging info via a user-defined method.\n     * Only generates output if debug output is enabled.\n     *\n     * @see PHPMailer::$Debugoutput\n     * @see PHPMailer::$SMTPDebug\n     *\n     * @param string $str\n     */\n    protected function edebug($str)\n    {\n        if ($this->SMTPDebug <= 0) {\n            return;\n        }\n        //Is this a PSR-3 logger?\n        if ($this->Debugoutput instanceof \\Psr\\Log\\LoggerInterface) {\n            $this->Debugoutput->debug($str);\n\n            return;\n        }\n        //Avoid clash with built-in function names\n        if (is_callable($this->Debugoutput) && !in_array($this->Debugoutput, ['error_log', 'html', 'echo'])) {\n            call_user_func($this->Debugoutput, $str, $this->SMTPDebug);\n\n            return;\n        }\n        switch ($this->Debugoutput) {\n            case 'error_log':\n                //Don't output, just log\n                /** @noinspection ForgottenDebugOutputInspection */\n                error_log($str);\n                break;\n            case 'html':\n                //Cleans up output a bit for a better looking, HTML-safe output\n                echo htmlentities(\n                    preg_replace('/[\\r\\n]+/', '', $str),\n                    ENT_QUOTES,\n                    'UTF-8'\n                ), \"<br>\\n\";\n                break;\n            case 'echo':\n            default:\n                //Normalize line breaks\n                $str = preg_replace('/\\r\\n|\\r/m', \"\\n\", $str);\n                echo gmdate('Y-m-d H:i:s'),\n                \"\\t\",\n                    //Trim trailing space\n                trim(\n                    //Indent for readability, except for trailing break\n                    str_replace(\n                        \"\\n\",\n                        \"\\n                   \\t                  \",\n                        trim($str)\n                    )\n                ),\n                \"\\n\";\n        }\n    }\n\n    /**\n     * Sets message type to HTML or plain.\n     *\n     * @param bool $isHtml True for HTML mode\n     */\n    public function isHTML($isHtml = true)\n    {\n        if ($isHtml) {\n            $this->ContentType = static::CONTENT_TYPE_TEXT_HTML;\n        } else {\n            $this->ContentType = static::CONTENT_TYPE_PLAINTEXT;\n        }\n    }\n\n    /**\n     * Send messages using SMTP.\n     */\n    public function isSMTP()\n    {\n        $this->Mailer = 'smtp';\n    }\n\n    /**\n     * Send messages using PHP's mail() function.\n     */\n    public function isMail()\n    {\n        $this->Mailer = 'mail';\n    }\n\n    /**\n     * Send messages using $Sendmail.\n     */\n    public function isSendmail()\n    {\n        $ini_sendmail_path = ini_get('sendmail_path');\n\n        if (false === stripos($ini_sendmail_path, 'sendmail')) {\n            $this->Sendmail = '/usr/sbin/sendmail';\n        } else {\n            $this->Sendmail = $ini_sendmail_path;\n        }\n        $this->Mailer = 'sendmail';\n    }\n\n    /**\n     * Send messages using qmail.\n     */\n    public function isQmail()\n    {\n        $ini_sendmail_path = ini_get('sendmail_path');\n\n        if (false === stripos($ini_sendmail_path, 'qmail')) {\n            $this->Sendmail = '/var/qmail/bin/qmail-inject';\n        } else {\n            $this->Sendmail = $ini_sendmail_path;\n        }\n        $this->Mailer = 'qmail';\n    }\n\n    /**\n     * Add a \"To\" address.\n     *\n     * @param string $address The email address to send to\n     * @param string $name\n     *\n     * @throws Exception\n     *\n     * @return bool true on success, false if address already used or invalid in some way\n     */\n    public function addAddress($address, $name = '')\n    {\n        return $this->addOrEnqueueAnAddress('to', $address, $name);\n    }\n\n    /**\n     * Add a \"CC\" address.\n     *\n     * @param string $address The email address to send to\n     * @param string $name\n     *\n     * @throws Exception\n     *\n     * @return bool true on success, false if address already used or invalid in some way\n     */\n    public function addCC($address, $name = '')\n    {\n        return $this->addOrEnqueueAnAddress('cc', $address, $name);\n    }\n\n    /**\n     * Add a \"BCC\" address.\n     *\n     * @param string $address The email address to send to\n     * @param string $name\n     *\n     * @throws Exception\n     *\n     * @return bool true on success, false if address already used or invalid in some way\n     */\n    public function addBCC($address, $name = '')\n    {\n        return $this->addOrEnqueueAnAddress('bcc', $address, $name);\n    }\n\n    /**\n     * Add a \"Reply-To\" address.\n     *\n     * @param string $address The email address to reply to\n     * @param string $name\n     *\n     * @throws Exception\n     *\n     * @return bool true on success, false if address already used or invalid in some way\n     */\n    public function addReplyTo($address, $name = '')\n    {\n        return $this->addOrEnqueueAnAddress('Reply-To', $address, $name);\n    }\n\n    /**\n     * Add an address to one of the recipient arrays or to the ReplyTo array. Because PHPMailer\n     * can't validate addresses with an IDN without knowing the PHPMailer::$CharSet (that can still\n     * be modified after calling this function), addition of such addresses is delayed until send().\n     * Addresses that have been added already return false, but do not throw exceptions.\n     *\n     * @param string $kind    One of 'to', 'cc', 'bcc', or 'ReplyTo'\n     * @param string $address The email address to send, resp. to reply to\n     * @param string $name\n     *\n     * @throws Exception\n     *\n     * @return bool true on success, false if address already used or invalid in some way\n     */\n    protected function addOrEnqueueAnAddress($kind, $address, $name)\n    {\n        $address = trim($address);\n        $name = trim(preg_replace('/[\\r\\n]+/', '', $name)); //Strip breaks and trim\n        $pos = strrpos($address, '@');\n        if (false === $pos) {\n            //At-sign is missing.\n            $error_message = sprintf(\n                '%s (%s): %s',\n                $this->lang('invalid_address'),\n                $kind,\n                $address\n            );\n            $this->setError($error_message);\n            $this->edebug($error_message);\n            if ($this->exceptions) {\n                throw new Exception($error_message);\n            }\n\n            return false;\n        }\n        $params = [$kind, $address, $name];\n        //Enqueue addresses with IDN until we know the PHPMailer::$CharSet.\n        if (static::idnSupported() && $this->has8bitChars(substr($address, ++$pos))) {\n            if ('Reply-To' !== $kind) {\n                if (!array_key_exists($address, $this->RecipientsQueue)) {\n                    $this->RecipientsQueue[$address] = $params;\n\n                    return true;\n                }\n            } elseif (!array_key_exists($address, $this->ReplyToQueue)) {\n                $this->ReplyToQueue[$address] = $params;\n\n                return true;\n            }\n\n            return false;\n        }\n\n        //Immediately add standard addresses without IDN.\n        return call_user_func_array([$this, 'addAnAddress'], $params);\n    }\n\n    /**\n     * Add an address to one of the recipient arrays or to the ReplyTo array.\n     * Addresses that have been added already return false, but do not throw exceptions.\n     *\n     * @param string $kind    One of 'to', 'cc', 'bcc', or 'ReplyTo'\n     * @param string $address The email address to send, resp. to reply to\n     * @param string $name\n     *\n     * @throws Exception\n     *\n     * @return bool true on success, false if address already used or invalid in some way\n     */\n    protected function addAnAddress($kind, $address, $name = '')\n    {\n        if (!in_array($kind, ['to', 'cc', 'bcc', 'Reply-To'])) {\n            $error_message = sprintf(\n                '%s: %s',\n                $this->lang('Invalid recipient kind'),\n                $kind\n            );\n            $this->setError($error_message);\n            $this->edebug($error_message);\n            if ($this->exceptions) {\n                throw new Exception($error_message);\n            }\n\n            return false;\n        }\n        if (!static::validateAddress($address)) {\n            $error_message = sprintf(\n                '%s (%s): %s',\n                $this->lang('invalid_address'),\n                $kind,\n                $address\n            );\n            $this->setError($error_message);\n            $this->edebug($error_message);\n            if ($this->exceptions) {\n                throw new Exception($error_message);\n            }\n\n            return false;\n        }\n        if ('Reply-To' !== $kind) {\n            if (!array_key_exists(strtolower($address), $this->all_recipients)) {\n                $this->{$kind}[] = [$address, $name];\n                $this->all_recipients[strtolower($address)] = true;\n\n                return true;\n            }\n        } elseif (!array_key_exists(strtolower($address), $this->ReplyTo)) {\n            $this->ReplyTo[strtolower($address)] = [$address, $name];\n\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Parse and validate a string containing one or more RFC822-style comma-separated email addresses\n     * of the form \"display name <address>\" into an array of name/address pairs.\n     * Uses the imap_rfc822_parse_adrlist function if the IMAP extension is available.\n     * Note that quotes in the name part are removed.\n     *\n     * @see http://www.andrew.cmu.edu/user/agreen1/testing/mrbs/web/Mail/RFC822.php A more careful implementation\n     *\n     * @param string $addrstr The address list string\n     * @param bool   $useimap Whether to use the IMAP extension to parse the list\n     *\n     * @return array\n     */\n    public static function parseAddresses($addrstr, $useimap = true)\n    {\n        $addresses = [];\n        if ($useimap && function_exists('imap_rfc822_parse_adrlist')) {\n            //Use this built-in parser if it's available\n            $list = imap_rfc822_parse_adrlist($addrstr, '');\n            foreach ($list as $address) {\n                if (\n                    ('.SYNTAX-ERROR.' !== $address->host) && static::validateAddress(\n                        $address->mailbox . '@' . $address->host\n                    )\n                ) {\n                    //Decode the name part if it's present and encoded\n                    if (\n                        property_exists($address, 'personal') &&\n                        extension_loaded('mbstring') &&\n                        preg_match('/^=\\?.*\\?=$/', $address->personal)\n                    ) {\n                        $address->personal = mb_decode_mimeheader($address->personal);\n                    }\n\n                    $addresses[] = [\n                        'name' => (property_exists($address, 'personal') ? $address->personal : ''),\n                        'address' => $address->mailbox . '@' . $address->host,\n                    ];\n                }\n            }\n        } else {\n            //Use this simpler parser\n            $list = explode(',', $addrstr);\n            foreach ($list as $address) {\n                $address = trim($address);\n                //Is there a separate name part?\n                if (strpos($address, '<') === false) {\n                    //No separate name, just use the whole thing\n                    if (static::validateAddress($address)) {\n                        $addresses[] = [\n                            'name' => '',\n                            'address' => $address,\n                        ];\n                    }\n                } else {\n                    list($name, $email) = explode('<', $address);\n                    $email = trim(str_replace('>', '', $email));\n                    $name = trim($name);\n                    if (static::validateAddress($email)) {\n                        //If this name is encoded, decode it\n                        if (preg_match('/^=\\?.*\\?=$/', $name)) {\n                            $name = mb_decode_mimeheader($name);\n                        }\n                        $addresses[] = [\n                            //Remove any surrounding quotes and spaces from the name\n                            'name' => trim($name, '\\'\" '),\n                            'address' => $email,\n                        ];\n                    }\n                }\n            }\n        }\n\n        return $addresses;\n    }\n\n    /**\n     * Set the From and FromName properties.\n     *\n     * @param string $address\n     * @param string $name\n     * @param bool   $auto    Whether to also set the Sender address, defaults to true\n     *\n     * @throws Exception\n     *\n     * @return bool\n     */\n    public function setFrom($address, $name = '', $auto = true)\n    {\n        $address = trim($address);\n        $name = trim(preg_replace('/[\\r\\n]+/', '', $name)); //Strip breaks and trim\n        //Don't validate now addresses with IDN. Will be done in send().\n        $pos = strrpos($address, '@');\n        if (\n            (false === $pos)\n            || ((!$this->has8bitChars(substr($address, ++$pos)) || !static::idnSupported())\n            && !static::validateAddress($address))\n        ) {\n            $error_message = sprintf(\n                '%s (From): %s',\n                $this->lang('invalid_address'),\n                $address\n            );\n            $this->setError($error_message);\n            $this->edebug($error_message);\n            if ($this->exceptions) {\n                throw new Exception($error_message);\n            }\n\n            return false;\n        }\n        $this->From = $address;\n        $this->FromName = $name;\n        if ($auto && empty($this->Sender)) {\n            $this->Sender = $address;\n        }\n\n        return true;\n    }\n\n    /**\n     * Return the Message-ID header of the last email.\n     * Technically this is the value from the last time the headers were created,\n     * but it's also the message ID of the last sent message except in\n     * pathological cases.\n     *\n     * @return string\n     */\n    public function getLastMessageID()\n    {\n        return $this->lastMessageID;\n    }\n\n    /**\n     * Check that a string looks like an email address.\n     * Validation patterns supported:\n     * * `auto` Pick best pattern automatically;\n     * * `pcre8` Use the squiloople.com pattern, requires PCRE > 8.0;\n     * * `pcre` Use old PCRE implementation;\n     * * `php` Use PHP built-in FILTER_VALIDATE_EMAIL;\n     * * `html5` Use the pattern given by the HTML5 spec for 'email' type form input elements.\n     * * `noregex` Don't use a regex: super fast, really dumb.\n     * Alternatively you may pass in a callable to inject your own validator, for example:\n     *\n     * ```php\n     * PHPMailer::validateAddress('user@example.com', function($address) {\n     *     return (strpos($address, '@') !== false);\n     * });\n     * ```\n     *\n     * You can also set the PHPMailer::$validator static to a callable, allowing built-in methods to use your validator.\n     *\n     * @param string          $address       The email address to check\n     * @param string|callable $patternselect Which pattern to use\n     *\n     * @return bool\n     */\n    public static function validateAddress($address, $patternselect = null)\n    {\n        if (null === $patternselect) {\n            $patternselect = static::$validator;\n        }\n        //Don't allow overriding built-in validators with callables\n        if (\n            is_callable($patternselect) &&\n            //It's callable and not a string, or it's a string callable that's not a built-in pattern\n            (!is_string($patternselect) || !in_array(strtolower($patternselect), ['php', 'pcre', 'pcre8', 'html5']))\n        ) {\n            return call_user_func($patternselect, $address);\n        }\n        //Reject line breaks in addresses; it's valid RFC5322, but not RFC5321\n        if (strpos($address, \"\\n\") !== false || strpos($address, \"\\r\") !== false) {\n            return false;\n        }\n        switch ($patternselect) {\n            case 'pcre': //Kept for BC\n            case 'pcre8':\n                /*\n                 * A more complex and more permissive version of the RFC5322 regex on which FILTER_VALIDATE_EMAIL\n                 * is based.\n                 * In addition to the addresses allowed by filter_var, also permits:\n                 *  * dotless domains: `a@b`\n                 *  * comments: `1234 @ local(blah) .machine .example`\n                 *  * quoted elements: `'\"test blah\"@example.org'`\n                 *  * numeric TLDs: `a@b.123`\n                 *  * unbracketed IPv4 literals: `a@192.168.0.1`\n                 *  * IPv6 literals: 'first.last@[IPv6:a1::]'\n                 * Not all of these will necessarily work for sending!\n                 *\n                 * @see       http://squiloople.com/2009/12/20/email-address-validation/\n                 * @copyright 2009-2010 Michael Rushton\n                 * Feel free to use and redistribute this code. But please keep this copyright notice.\n                 */\n                return (bool) preg_match(\n                    '/^(?!(?>(?1)\"?(?>\\\\\\[ -~]|[^\"])\"?(?1)){255,})(?!(?>(?1)\"?(?>\\\\\\[ -~]|[^\"])\"?(?1)){65,}@)' .\n                    '((?>(?>(?>((?>(?>(?>\\x0D\\x0A)?[\\t ])+|(?>[\\t ]*\\x0D\\x0A)?[\\t ]+)?)(\\((?>(?2)' .\n                    '(?>[\\x01-\\x08\\x0B\\x0C\\x0E-\\'*-\\[\\]-\\x7F]|\\\\\\[\\x00-\\x7F]|(?3)))*(?2)\\)))+(?2))|(?2))?)' .\n                    '([!#-\\'*+\\/-9=?^-~-]+|\"(?>(?2)(?>[\\x01-\\x08\\x0B\\x0C\\x0E-!#-\\[\\]-\\x7F]|\\\\\\[\\x00-\\x7F]))*' .\n                    '(?2)\")(?>(?1)\\.(?1)(?4))*(?1)@(?!(?1)[a-z0-9-]{64,})(?1)(?>([a-z0-9](?>[a-z0-9-]*[a-z0-9])?)' .\n                    '(?>(?1)\\.(?!(?1)[a-z0-9-]{64,})(?1)(?5)){0,126}|\\[(?:(?>IPv6:(?>([a-f0-9]{1,4})(?>:(?6)){7}' .\n                    '|(?!(?:.*[a-f0-9][:\\]]){8,})((?6)(?>:(?6)){0,6})?::(?7)?))|(?>(?>IPv6:(?>(?6)(?>:(?6)){5}:' .\n                    '|(?!(?:.*[a-f0-9]:){6,})(?8)?::(?>((?6)(?>:(?6)){0,4}):)?))?(25[0-5]|2[0-4][0-9]|1[0-9]{2}' .\n                    '|[1-9]?[0-9])(?>\\.(?9)){3}))\\])(?1)$/isD',\n                    $address\n                );\n            case 'html5':\n                /*\n                 * This is the pattern used in the HTML5 spec for validation of 'email' type form input elements.\n                 *\n                 * @see https://html.spec.whatwg.org/#e-mail-state-(type=email)\n                 */\n                return (bool) preg_match(\n                    '/^[a-zA-Z0-9.!#$%&\\'*+\\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}' .\n                    '[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/sD',\n                    $address\n                );\n            case 'php':\n            default:\n                return filter_var($address, FILTER_VALIDATE_EMAIL) !== false;\n        }\n    }\n\n    /**\n     * Tells whether IDNs (Internationalized Domain Names) are supported or not. This requires the\n     * `intl` and `mbstring` PHP extensions.\n     *\n     * @return bool `true` if required functions for IDN support are present\n     */\n    public static function idnSupported()\n    {\n        return function_exists('idn_to_ascii') && function_exists('mb_convert_encoding');\n    }\n\n    /**\n     * Converts IDN in given email address to its ASCII form, also known as punycode, if possible.\n     * Important: Address must be passed in same encoding as currently set in PHPMailer::$CharSet.\n     * This function silently returns unmodified address if:\n     * - No conversion is necessary (i.e. domain name is not an IDN, or is already in ASCII form)\n     * - Conversion to punycode is impossible (e.g. required PHP functions are not available)\n     *   or fails for any reason (e.g. domain contains characters not allowed in an IDN).\n     *\n     * @see PHPMailer::$CharSet\n     *\n     * @param string $address The email address to convert\n     *\n     * @return string The encoded address in ASCII form\n     */\n    public function punyencodeAddress($address)\n    {\n        //Verify we have required functions, CharSet, and at-sign.\n        $pos = strrpos($address, '@');\n        if (\n            !empty($this->CharSet) &&\n            false !== $pos &&\n            static::idnSupported()\n        ) {\n            $domain = substr($address, ++$pos);\n            //Verify CharSet string is a valid one, and domain properly encoded in this CharSet.\n            if ($this->has8bitChars($domain) && @mb_check_encoding($domain, $this->CharSet)) {\n                //Convert the domain from whatever charset it's in to UTF-8\n                $domain = mb_convert_encoding($domain, self::CHARSET_UTF8, $this->CharSet);\n                //Ignore IDE complaints about this line - method signature changed in PHP 5.4\n                $errorcode = 0;\n                if (defined('INTL_IDNA_VARIANT_UTS46')) {\n                    //Use the current punycode standard (appeared in PHP 7.2)\n                    $punycode = idn_to_ascii($domain, $errorcode, \\INTL_IDNA_VARIANT_UTS46);\n                } elseif (defined('INTL_IDNA_VARIANT_2003')) {\n                    //Fall back to this old, deprecated/removed encoding\n                    $punycode = idn_to_ascii($domain, $errorcode, \\INTL_IDNA_VARIANT_2003);\n                } else {\n                    //Fall back to a default we don't know about\n                    $punycode = idn_to_ascii($domain, $errorcode);\n                }\n                if (false !== $punycode) {\n                    return substr($address, 0, $pos) . $punycode;\n                }\n            }\n        }\n\n        return $address;\n    }\n\n    /**\n     * Create a message and send it.\n     * Uses the sending method specified by $Mailer.\n     *\n     * @throws Exception\n     *\n     * @return bool false on error - See the ErrorInfo property for details of the error\n     */\n    public function send()\n    {\n        try {\n            if (!$this->preSend()) {\n                return false;\n            }\n\n            return $this->postSend();\n        } catch (Exception $exc) {\n            $this->mailHeader = '';\n            $this->setError($exc->getMessage());\n            if ($this->exceptions) {\n                throw $exc;\n            }\n\n            return false;\n        }\n    }\n\n    /**\n     * Prepare a message for sending.\n     *\n     * @throws Exception\n     *\n     * @return bool\n     */\n    public function preSend()\n    {\n        if (\n            'smtp' === $this->Mailer\n            || ('mail' === $this->Mailer && (\\PHP_VERSION_ID >= 80000 || stripos(PHP_OS, 'WIN') === 0))\n        ) {\n            //SMTP mandates RFC-compliant line endings\n            //and it's also used with mail() on Windows\n            static::setLE(self::CRLF);\n        } else {\n            //Maintain backward compatibility with legacy Linux command line mailers\n            static::setLE(PHP_EOL);\n        }\n        //Check for buggy PHP versions that add a header with an incorrect line break\n        if (\n            'mail' === $this->Mailer\n            && ((\\PHP_VERSION_ID >= 70000 && \\PHP_VERSION_ID < 70017)\n                || (\\PHP_VERSION_ID >= 70100 && \\PHP_VERSION_ID < 70103))\n            && ini_get('mail.add_x_header') === '1'\n            && stripos(PHP_OS, 'WIN') === 0\n        ) {\n            trigger_error(\n                'Your version of PHP is affected by a bug that may result in corrupted messages.' .\n                ' To fix it, switch to sending using SMTP, disable the mail.add_x_header option in' .\n                ' your php.ini, switch to MacOS or Linux, or upgrade your PHP to version 7.0.17+ or 7.1.3+.',\n                E_USER_WARNING\n            );\n        }\n\n        try {\n            $this->error_count = 0; //Reset errors\n            $this->mailHeader = '';\n\n            //Dequeue recipient and Reply-To addresses with IDN\n            foreach (array_merge($this->RecipientsQueue, $this->ReplyToQueue) as $params) {\n                $params[1] = $this->punyencodeAddress($params[1]);\n                call_user_func_array([$this, 'addAnAddress'], $params);\n            }\n            if (count($this->to) + count($this->cc) + count($this->bcc) < 1) {\n                throw new Exception($this->lang('provide_address'), self::STOP_CRITICAL);\n            }\n\n            //Validate From, Sender, and ConfirmReadingTo addresses\n            foreach (['From', 'Sender', 'ConfirmReadingTo'] as $address_kind) {\n                $this->$address_kind = trim($this->$address_kind);\n                if (empty($this->$address_kind)) {\n                    continue;\n                }\n                $this->$address_kind = $this->punyencodeAddress($this->$address_kind);\n                if (!static::validateAddress($this->$address_kind)) {\n                    $error_message = sprintf(\n                        '%s (%s): %s',\n                        $this->lang('invalid_address'),\n                        $address_kind,\n                        $this->$address_kind\n                    );\n                    $this->setError($error_message);\n                    $this->edebug($error_message);\n                    if ($this->exceptions) {\n                        throw new Exception($error_message);\n                    }\n\n                    return false;\n                }\n            }\n\n            //Set whether the message is multipart/alternative\n            if ($this->alternativeExists()) {\n                $this->ContentType = static::CONTENT_TYPE_MULTIPART_ALTERNATIVE;\n            }\n\n            $this->setMessageType();\n            //Refuse to send an empty message unless we are specifically allowing it\n            if (!$this->AllowEmpty && empty($this->Body)) {\n                throw new Exception($this->lang('empty_message'), self::STOP_CRITICAL);\n            }\n\n            //Trim subject consistently\n            $this->Subject = trim($this->Subject);\n            //Create body before headers in case body makes changes to headers (e.g. altering transfer encoding)\n            $this->MIMEHeader = '';\n            $this->MIMEBody = $this->createBody();\n            //createBody may have added some headers, so retain them\n            $tempheaders = $this->MIMEHeader;\n            $this->MIMEHeader = $this->createHeader();\n            $this->MIMEHeader .= $tempheaders;\n\n            //To capture the complete message when using mail(), create\n            //an extra header list which createHeader() doesn't fold in\n            if ('mail' === $this->Mailer) {\n                if (count($this->to) > 0) {\n                    $this->mailHeader .= $this->addrAppend('To', $this->to);\n                } else {\n                    $this->mailHeader .= $this->headerLine('To', 'undisclosed-recipients:;');\n                }\n                $this->mailHeader .= $this->headerLine(\n                    'Subject',\n                    $this->encodeHeader($this->secureHeader($this->Subject))\n                );\n            }\n\n            //Sign with DKIM if enabled\n            if (\n                !empty($this->DKIM_domain)\n                && !empty($this->DKIM_selector)\n                && (!empty($this->DKIM_private_string)\n                    || (!empty($this->DKIM_private)\n                        && static::isPermittedPath($this->DKIM_private)\n                        && file_exists($this->DKIM_private)\n                    )\n                )\n            ) {\n                $header_dkim = $this->DKIM_Add(\n                    $this->MIMEHeader . $this->mailHeader,\n                    $this->encodeHeader($this->secureHeader($this->Subject)),\n                    $this->MIMEBody\n                );\n                $this->MIMEHeader = static::stripTrailingWSP($this->MIMEHeader) . static::$LE .\n                    static::normalizeBreaks($header_dkim) . static::$LE;\n            }\n\n            return true;\n        } catch (Exception $exc) {\n            $this->setError($exc->getMessage());\n            if ($this->exceptions) {\n                throw $exc;\n            }\n\n            return false;\n        }\n    }\n\n    /**\n     * Actually send a message via the selected mechanism.\n     *\n     * @throws Exception\n     *\n     * @return bool\n     */\n    public function postSend()\n    {\n        try {\n            //Choose the mailer and send through it\n            switch ($this->Mailer) {\n                case 'sendmail':\n                case 'qmail':\n                    return $this->sendmailSend($this->MIMEHeader, $this->MIMEBody);\n                case 'smtp':\n                    return $this->smtpSend($this->MIMEHeader, $this->MIMEBody);\n                case 'mail':\n                    return $this->mailSend($this->MIMEHeader, $this->MIMEBody);\n                default:\n                    $sendMethod = $this->Mailer . 'Send';\n                    if (method_exists($this, $sendMethod)) {\n                        return $this->$sendMethod($this->MIMEHeader, $this->MIMEBody);\n                    }\n\n                    return $this->mailSend($this->MIMEHeader, $this->MIMEBody);\n            }\n        } catch (Exception $exc) {\n            if ($this->Mailer === 'smtp' && $this->SMTPKeepAlive == true) {\n                $this->smtp->reset();\n            }\n            $this->setError($exc->getMessage());\n            $this->edebug($exc->getMessage());\n            if ($this->exceptions) {\n                throw $exc;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Send mail using the $Sendmail program.\n     *\n     * @see PHPMailer::$Sendmail\n     *\n     * @param string $header The message headers\n     * @param string $body   The message body\n     *\n     * @throws Exception\n     *\n     * @return bool\n     */\n    protected function sendmailSend($header, $body)\n    {\n        if ($this->Mailer === 'qmail') {\n            $this->edebug('Sending with qmail');\n        } else {\n            $this->edebug('Sending with sendmail');\n        }\n        $header = static::stripTrailingWSP($header) . static::$LE . static::$LE;\n        //This sets the SMTP envelope sender which gets turned into a return-path header by the receiver\n        //A space after `-f` is optional, but there is a long history of its presence\n        //causing problems, so we don't use one\n        //Exim docs: http://www.exim.org/exim-html-current/doc/html/spec_html/ch-the_exim_command_line.html\n        //Sendmail docs: http://www.sendmail.org/~ca/email/man/sendmail.html\n        //Qmail docs: http://www.qmail.org/man/man8/qmail-inject.html\n        //Example problem: https://www.drupal.org/node/1057954\n        if (empty($this->Sender) && !empty(ini_get('sendmail_from'))) {\n            //PHP config has a sender address we can use\n            $this->Sender = ini_get('sendmail_from');\n        }\n        //CVE-2016-10033, CVE-2016-10045: Don't pass -f if characters will be escaped.\n        if (!empty($this->Sender) && static::validateAddress($this->Sender) && self::isShellSafe($this->Sender)) {\n            if ($this->Mailer === 'qmail') {\n                $sendmailFmt = '%s -f%s';\n            } else {\n                $sendmailFmt = '%s -oi -f%s -t';\n            }\n        } else {\n            //allow sendmail to choose a default envelope sender. It may\n            //seem preferable to force it to use the From header as with\n            //SMTP, but that introduces new problems (see\n            //<https://github.com/PHPMailer/PHPMailer/issues/2298>), and\n            //it has historically worked this way.\n            $sendmailFmt = '%s -oi -t';\n        }\n\n        $sendmail = sprintf($sendmailFmt, escapeshellcmd($this->Sendmail), $this->Sender);\n        $this->edebug('Sendmail path: ' . $this->Sendmail);\n        $this->edebug('Sendmail command: ' . $sendmail);\n        $this->edebug('Envelope sender: ' . $this->Sender);\n        $this->edebug(\"Headers: {$header}\");\n\n        if ($this->SingleTo) {\n            foreach ($this->SingleToArray as $toAddr) {\n                $mail = @popen($sendmail, 'w');\n                if (!$mail) {\n                    throw new Exception($this->lang('execute') . $this->Sendmail, self::STOP_CRITICAL);\n                }\n                $this->edebug(\"To: {$toAddr}\");\n                fwrite($mail, 'To: ' . $toAddr . \"\\n\");\n                fwrite($mail, $header);\n                fwrite($mail, $body);\n                $result = pclose($mail);\n                $addrinfo = static::parseAddresses($toAddr);\n                $this->doCallback(\n                    ($result === 0),\n                    [[$addrinfo['address'], $addrinfo['name']]],\n                    $this->cc,\n                    $this->bcc,\n                    $this->Subject,\n                    $body,\n                    $this->From,\n                    []\n                );\n                $this->edebug(\"Result: \" . ($result === 0 ? 'true' : 'false'));\n                if (0 !== $result) {\n                    throw new Exception($this->lang('execute') . $this->Sendmail, self::STOP_CRITICAL);\n                }\n            }\n        } else {\n            $mail = @popen($sendmail, 'w');\n            if (!$mail) {\n                throw new Exception($this->lang('execute') . $this->Sendmail, self::STOP_CRITICAL);\n            }\n            fwrite($mail, $header);\n            fwrite($mail, $body);\n            $result = pclose($mail);\n            $this->doCallback(\n                ($result === 0),\n                $this->to,\n                $this->cc,\n                $this->bcc,\n                $this->Subject,\n                $body,\n                $this->From,\n                []\n            );\n            $this->edebug(\"Result: \" . ($result === 0 ? 'true' : 'false'));\n            if (0 !== $result) {\n                throw new Exception($this->lang('execute') . $this->Sendmail, self::STOP_CRITICAL);\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * Fix CVE-2016-10033 and CVE-2016-10045 by disallowing potentially unsafe shell characters.\n     * Note that escapeshellarg and escapeshellcmd are inadequate for our purposes, especially on Windows.\n     *\n     * @see https://github.com/PHPMailer/PHPMailer/issues/924 CVE-2016-10045 bug report\n     *\n     * @param string $string The string to be validated\n     *\n     * @return bool\n     */\n    protected static function isShellSafe($string)\n    {\n        //Future-proof\n        if (\n            escapeshellcmd($string) !== $string\n            || !in_array(escapeshellarg($string), [\"'$string'\", \"\\\"$string\\\"\"])\n        ) {\n            return false;\n        }\n\n        $length = strlen($string);\n\n        for ($i = 0; $i < $length; ++$i) {\n            $c = $string[$i];\n\n            //All other characters have a special meaning in at least one common shell, including = and +.\n            //Full stop (.) has a special meaning in cmd.exe, but its impact should be negligible here.\n            //Note that this does permit non-Latin alphanumeric characters based on the current locale.\n            if (!ctype_alnum($c) && strpos('@_-.', $c) === false) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * Check whether a file path is of a permitted type.\n     * Used to reject URLs and phar files from functions that access local file paths,\n     * such as addAttachment.\n     *\n     * @param string $path A relative or absolute path to a file\n     *\n     * @return bool\n     */\n    protected static function isPermittedPath($path)\n    {\n        //Matches scheme definition from https://tools.ietf.org/html/rfc3986#section-3.1\n        return !preg_match('#^[a-z][a-z\\d+.-]*://#i', $path);\n    }\n\n    /**\n     * Check whether a file path is safe, accessible, and readable.\n     *\n     * @param string $path A relative or absolute path to a file\n     *\n     * @return bool\n     */\n    protected static function fileIsAccessible($path)\n    {\n        if (!static::isPermittedPath($path)) {\n            return false;\n        }\n        $readable = file_exists($path);\n        //If not a UNC path (expected to start with \\\\), check read permission, see #2069\n        if (strpos($path, '\\\\\\\\') !== 0) {\n            $readable = $readable && is_readable($path);\n        }\n        return  $readable;\n    }\n\n    /**\n     * Send mail using the PHP mail() function.\n     *\n     * @see http://www.php.net/manual/en/book.mail.php\n     *\n     * @param string $header The message headers\n     * @param string $body   The message body\n     *\n     * @throws Exception\n     *\n     * @return bool\n     */\n    protected function mailSend($header, $body)\n    {\n        $header = static::stripTrailingWSP($header) . static::$LE . static::$LE;\n\n        $toArr = [];\n        foreach ($this->to as $toaddr) {\n            $toArr[] = $this->addrFormat($toaddr);\n        }\n        $to = implode(', ', $toArr);\n\n        $params = null;\n        //This sets the SMTP envelope sender which gets turned into a return-path header by the receiver\n        //A space after `-f` is optional, but there is a long history of its presence\n        //causing problems, so we don't use one\n        //Exim docs: http://www.exim.org/exim-html-current/doc/html/spec_html/ch-the_exim_command_line.html\n        //Sendmail docs: http://www.sendmail.org/~ca/email/man/sendmail.html\n        //Qmail docs: http://www.qmail.org/man/man8/qmail-inject.html\n        //Example problem: https://www.drupal.org/node/1057954\n        //CVE-2016-10033, CVE-2016-10045: Don't pass -f if characters will be escaped.\n        if (empty($this->Sender) && !empty(ini_get('sendmail_from'))) {\n            //PHP config has a sender address we can use\n            $this->Sender = ini_get('sendmail_from');\n        }\n        if (!empty($this->Sender) && static::validateAddress($this->Sender)) {\n            if (self::isShellSafe($this->Sender)) {\n                $params = sprintf('-f%s', $this->Sender);\n            }\n            $old_from = ini_get('sendmail_from');\n            ini_set('sendmail_from', $this->Sender);\n        }\n        $result = false;\n        if ($this->SingleTo && count($toArr) > 1) {\n            foreach ($toArr as $toAddr) {\n                $result = $this->mailPassthru($toAddr, $this->Subject, $body, $header, $params);\n                $addrinfo = static::parseAddresses($toAddr);\n                $this->doCallback(\n                    $result,\n                    [[$addrinfo['address'], $addrinfo['name']]],\n                    $this->cc,\n                    $this->bcc,\n                    $this->Subject,\n                    $body,\n                    $this->From,\n                    []\n                );\n            }\n        } else {\n            $result = $this->mailPassthru($to, $this->Subject, $body, $header, $params);\n            $this->doCallback($result, $this->to, $this->cc, $this->bcc, $this->Subject, $body, $this->From, []);\n        }\n        if (isset($old_from)) {\n            ini_set('sendmail_from', $old_from);\n        }\n        if (!$result) {\n            throw new Exception($this->lang('instantiate'), self::STOP_CRITICAL);\n        }\n\n        return true;\n    }\n\n    /**\n     * Get an instance to use for SMTP operations.\n     * Override this function to load your own SMTP implementation,\n     * or set one with setSMTPInstance.\n     *\n     * @return SMTP\n     */\n    public function getSMTPInstance()\n    {\n        if (!is_object($this->smtp)) {\n            $this->smtp = new SMTP();\n        }\n\n        return $this->smtp;\n    }\n\n    /**\n     * Provide an instance to use for SMTP operations.\n     *\n     * @return SMTP\n     */\n    public function setSMTPInstance(SMTP $smtp)\n    {\n        $this->smtp = $smtp;\n\n        return $this->smtp;\n    }\n\n    /**\n     * Send mail via SMTP.\n     * Returns false if there is a bad MAIL FROM, RCPT, or DATA input.\n     *\n     * @see PHPMailer::setSMTPInstance() to use a different class.\n     *\n     * @uses \\PHPMailer\\PHPMailer\\SMTP\n     *\n     * @param string $header The message headers\n     * @param string $body   The message body\n     *\n     * @throws Exception\n     *\n     * @return bool\n     */\n    protected function smtpSend($header, $body)\n    {\n        $header = static::stripTrailingWSP($header) . static::$LE . static::$LE;\n        $bad_rcpt = [];\n        if (!$this->smtpConnect($this->SMTPOptions)) {\n            throw new Exception($this->lang('smtp_connect_failed'), self::STOP_CRITICAL);\n        }\n        //Sender already validated in preSend()\n        if ('' === $this->Sender) {\n            $smtp_from = $this->From;\n        } else {\n            $smtp_from = $this->Sender;\n        }\n        if (!$this->smtp->mail($smtp_from)) {\n            $this->setError($this->lang('from_failed') . $smtp_from . ' : ' . implode(',', $this->smtp->getError()));\n            throw new Exception($this->ErrorInfo, self::STOP_CRITICAL);\n        }\n\n        $callbacks = [];\n        //Attempt to send to all recipients\n        foreach ([$this->to, $this->cc, $this->bcc] as $togroup) {\n            foreach ($togroup as $to) {\n                if (!$this->smtp->recipient($to[0], $this->dsn)) {\n                    $error = $this->smtp->getError();\n                    $bad_rcpt[] = ['to' => $to[0], 'error' => $error['detail']];\n                    $isSent = false;\n                } else {\n                    $isSent = true;\n                }\n\n                $callbacks[] = ['issent' => $isSent, 'to' => $to[0], 'name' => $to[1]];\n            }\n        }\n\n        //Only send the DATA command if we have viable recipients\n        if ((count($this->all_recipients) > count($bad_rcpt)) && !$this->smtp->data($header . $body)) {\n            throw new Exception($this->lang('data_not_accepted'), self::STOP_CRITICAL);\n        }\n\n        $smtp_transaction_id = $this->smtp->getLastTransactionID();\n\n        if ($this->SMTPKeepAlive) {\n            $this->smtp->reset();\n        } else {\n            $this->smtp->quit();\n            $this->smtp->close();\n        }\n\n        foreach ($callbacks as $cb) {\n            $this->doCallback(\n                $cb['issent'],\n                [[$cb['to'], $cb['name']]],\n                [],\n                [],\n                $this->Subject,\n                $body,\n                $this->From,\n                ['smtp_transaction_id' => $smtp_transaction_id]\n            );\n        }\n\n        //Create error message for any bad addresses\n        if (count($bad_rcpt) > 0) {\n            $errstr = '';\n            foreach ($bad_rcpt as $bad) {\n                $errstr .= $bad['to'] . ': ' . $bad['error'];\n            }\n            throw new Exception($this->lang('recipients_failed') . $errstr, self::STOP_CONTINUE);\n        }\n\n        return true;\n    }\n\n    /**\n     * Initiate a connection to an SMTP server.\n     * Returns false if the operation failed.\n     *\n     * @param array $options An array of options compatible with stream_context_create()\n     *\n     * @throws Exception\n     *\n     * @uses \\PHPMailer\\PHPMailer\\SMTP\n     *\n     * @return bool\n     */\n    public function smtpConnect($options = null)\n    {\n        if (null === $this->smtp) {\n            $this->smtp = $this->getSMTPInstance();\n        }\n\n        //If no options are provided, use whatever is set in the instance\n        if (null === $options) {\n            $options = $this->SMTPOptions;\n        }\n\n        //Already connected?\n        if ($this->smtp->connected()) {\n            return true;\n        }\n\n        $this->smtp->setTimeout($this->Timeout);\n        $this->smtp->setDebugLevel($this->SMTPDebug);\n        $this->smtp->setDebugOutput($this->Debugoutput);\n        $this->smtp->setVerp($this->do_verp);\n        $hosts = explode(';', $this->Host);\n        $lastexception = null;\n\n        foreach ($hosts as $hostentry) {\n            $hostinfo = [];\n            if (\n                !preg_match(\n                    '/^(?:(ssl|tls):\\/\\/)?(.+?)(?::(\\d+))?$/',\n                    trim($hostentry),\n                    $hostinfo\n                )\n            ) {\n                $this->edebug($this->lang('invalid_hostentry') . ' ' . trim($hostentry));\n                //Not a valid host entry\n                continue;\n            }\n            //$hostinfo[1]: optional ssl or tls prefix\n            //$hostinfo[2]: the hostname\n            //$hostinfo[3]: optional port number\n            //The host string prefix can temporarily override the current setting for SMTPSecure\n            //If it's not specified, the default value is used\n\n            //Check the host name is a valid name or IP address before trying to use it\n            if (!static::isValidHost($hostinfo[2])) {\n                $this->edebug($this->lang('invalid_host') . ' ' . $hostinfo[2]);\n                continue;\n            }\n            $prefix = '';\n            $secure = $this->SMTPSecure;\n            $tls = (static::ENCRYPTION_STARTTLS === $this->SMTPSecure);\n            if ('ssl' === $hostinfo[1] || ('' === $hostinfo[1] && static::ENCRYPTION_SMTPS === $this->SMTPSecure)) {\n                $prefix = 'ssl://';\n                $tls = false; //Can't have SSL and TLS at the same time\n                $secure = static::ENCRYPTION_SMTPS;\n            } elseif ('tls' === $hostinfo[1]) {\n                $tls = true;\n                //TLS doesn't use a prefix\n                $secure = static::ENCRYPTION_STARTTLS;\n            }\n            //Do we need the OpenSSL extension?\n            $sslext = defined('OPENSSL_ALGO_SHA256');\n            if (static::ENCRYPTION_STARTTLS === $secure || static::ENCRYPTION_SMTPS === $secure) {\n                //Check for an OpenSSL constant rather than using extension_loaded, which is sometimes disabled\n                if (!$sslext) {\n                    throw new Exception($this->lang('extension_missing') . 'openssl', self::STOP_CRITICAL);\n                }\n            }\n            $host = $hostinfo[2];\n            $port = $this->Port;\n            if (\n                array_key_exists(3, $hostinfo) &&\n                is_numeric($hostinfo[3]) &&\n                $hostinfo[3] > 0 &&\n                $hostinfo[3] < 65536\n            ) {\n                $port = (int) $hostinfo[3];\n            }\n            if ($this->smtp->connect($prefix . $host, $port, $this->Timeout, $options)) {\n                try {\n                    if ($this->Helo) {\n                        $hello = $this->Helo;\n                    } else {\n                        $hello = $this->serverHostname();\n                    }\n                    $this->smtp->hello($hello);\n                    //Automatically enable TLS encryption if:\n                    //* it's not disabled\n                    //* we have openssl extension\n                    //* we are not already using SSL\n                    //* the server offers STARTTLS\n                    if ($this->SMTPAutoTLS && $sslext && 'ssl' !== $secure && $this->smtp->getServerExt('STARTTLS')) {\n                        $tls = true;\n                    }\n                    if ($tls) {\n                        if (!$this->smtp->startTLS()) {\n                            throw new Exception($this->lang('connect_host'));\n                        }\n                        //We must resend EHLO after TLS negotiation\n                        $this->smtp->hello($hello);\n                    }\n                    if (\n                        $this->SMTPAuth && !$this->smtp->authenticate(\n                            $this->Username,\n                            $this->Password,\n                            $this->AuthType,\n                            $this->oauth\n                        )\n                    ) {\n                        throw new Exception($this->lang('authenticate'));\n                    }\n\n                    return true;\n                } catch (Exception $exc) {\n                    $lastexception = $exc;\n                    $this->edebug($exc->getMessage());\n                    //We must have connected, but then failed TLS or Auth, so close connection nicely\n                    $this->smtp->quit();\n                }\n            }\n        }\n        //If we get here, all connection attempts have failed, so close connection hard\n        $this->smtp->close();\n        //As we've caught all exceptions, just report whatever the last one was\n        if ($this->exceptions && null !== $lastexception) {\n            throw $lastexception;\n        }\n\n        return false;\n    }\n\n    /**\n     * Close the active SMTP session if one exists.\n     */\n    public function smtpClose()\n    {\n        if ((null !== $this->smtp) && $this->smtp->connected()) {\n            $this->smtp->quit();\n            $this->smtp->close();\n        }\n    }\n\n    /**\n     * Set the language for error messages.\n     * Returns false if it cannot load the language file.\n     * The default language is English.\n     *\n     * @param string $langcode  ISO 639-1 2-character language code (e.g. French is \"fr\")\n     * @param string $lang_path Path to the language file directory, with trailing separator (slash)\n     *\n     * @return bool\n     */\n    public function setLanguage($langcode = 'en', $lang_path = '')\n    {\n        //Backwards compatibility for renamed language codes\n        $renamed_langcodes = [\n            'br' => 'pt_br',\n            'cz' => 'cs',\n            'dk' => 'da',\n            'no' => 'nb',\n            'se' => 'sv',\n            'rs' => 'sr',\n            'tg' => 'tl',\n            'am' => 'hy',\n        ];\n\n        if (array_key_exists($langcode, $renamed_langcodes)) {\n            $langcode = $renamed_langcodes[$langcode];\n        }\n\n        //Define full set of translatable strings in English\n        $PHPMAILER_LANG = [\n            'authenticate' => 'SMTP Error: Could not authenticate.',\n            'connect_host' => 'SMTP Error: Could not connect to SMTP host.',\n            'data_not_accepted' => 'SMTP Error: data not accepted.',\n            'empty_message' => 'Message body empty',\n            'encoding' => 'Unknown encoding: ',\n            'execute' => 'Could not execute: ',\n            'file_access' => 'Could not access file: ',\n            'file_open' => 'File Error: Could not open file: ',\n            'from_failed' => 'The following From address failed: ',\n            'instantiate' => 'Could not instantiate mail function.',\n            'invalid_address' => 'Invalid address: ',\n            'invalid_hostentry' => 'Invalid hostentry: ',\n            'invalid_host' => 'Invalid host: ',\n            'mailer_not_supported' => ' mailer is not supported.',\n            'provide_address' => 'You must provide at least one recipient email address.',\n            'recipients_failed' => 'SMTP Error: The following recipients failed: ',\n            'signing' => 'Signing Error: ',\n            'smtp_connect_failed' => 'SMTP connect() failed.',\n            'smtp_error' => 'SMTP server error: ',\n            'variable_set' => 'Cannot set or reset variable: ',\n            'extension_missing' => 'Extension missing: ',\n        ];\n        if (empty($lang_path)) {\n            //Calculate an absolute path so it can work if CWD is not here\n            $lang_path = dirname(__DIR__) . DIRECTORY_SEPARATOR . 'language' . DIRECTORY_SEPARATOR;\n        }\n        //Validate $langcode\n        if (!preg_match('/^[a-z]{2}(?:_[a-zA-Z]{2})?$/', $langcode)) {\n            $langcode = 'en';\n        }\n        $foundlang = true;\n        $lang_file = $lang_path . 'phpmailer.lang-' . $langcode . '.php';\n        //There is no English translation file\n        if ('en' !== $langcode) {\n            //Make sure language file path is readable\n            if (!static::fileIsAccessible($lang_file)) {\n                $foundlang = false;\n            } else {\n                //Overwrite language-specific strings.\n                //This way we'll never have missing translation keys.\n                $foundlang = include $lang_file;\n            }\n        }\n        $this->language = $PHPMAILER_LANG;\n\n        return (bool) $foundlang; //Returns false if language not found\n    }\n\n    /**\n     * Get the array of strings for the current language.\n     *\n     * @return array\n     */\n    public function getTranslations()\n    {\n        return $this->language;\n    }\n\n    /**\n     * Create recipient headers.\n     *\n     * @param string $type\n     * @param array  $addr An array of recipients,\n     *                     where each recipient is a 2-element indexed array with element 0 containing an address\n     *                     and element 1 containing a name, like:\n     *                     [['joe@example.com', 'Joe User'], ['zoe@example.com', 'Zoe User']]\n     *\n     * @return string\n     */\n    public function addrAppend($type, $addr)\n    {\n        $addresses = [];\n        foreach ($addr as $address) {\n            $addresses[] = $this->addrFormat($address);\n        }\n\n        return $type . ': ' . implode(', ', $addresses) . static::$LE;\n    }\n\n    /**\n     * Format an address for use in a message header.\n     *\n     * @param array $addr A 2-element indexed array, element 0 containing an address, element 1 containing a name like\n     *                    ['joe@example.com', 'Joe User']\n     *\n     * @return string\n     */\n    public function addrFormat($addr)\n    {\n        if (empty($addr[1])) { //No name provided\n            return $this->secureHeader($addr[0]);\n        }\n\n        return $this->encodeHeader($this->secureHeader($addr[1]), 'phrase') .\n            ' <' . $this->secureHeader($addr[0]) . '>';\n    }\n\n    /**\n     * Word-wrap message.\n     * For use with mailers that do not automatically perform wrapping\n     * and for quoted-printable encoded messages.\n     * Original written by philippe.\n     *\n     * @param string $message The message to wrap\n     * @param int    $length  The line length to wrap to\n     * @param bool   $qp_mode Whether to run in Quoted-Printable mode\n     *\n     * @return string\n     */\n    public function wrapText($message, $length, $qp_mode = false)\n    {\n        if ($qp_mode) {\n            $soft_break = sprintf(' =%s', static::$LE);\n        } else {\n            $soft_break = static::$LE;\n        }\n        //If utf-8 encoding is used, we will need to make sure we don't\n        //split multibyte characters when we wrap\n        $is_utf8 = static::CHARSET_UTF8 === strtolower($this->CharSet);\n        $lelen = strlen(static::$LE);\n        $crlflen = strlen(static::$LE);\n\n        $message = static::normalizeBreaks($message);\n        //Remove a trailing line break\n        if (substr($message, -$lelen) === static::$LE) {\n            $message = substr($message, 0, -$lelen);\n        }\n\n        //Split message into lines\n        $lines = explode(static::$LE, $message);\n        //Message will be rebuilt in here\n        $message = '';\n        foreach ($lines as $line) {\n            $words = explode(' ', $line);\n            $buf = '';\n            $firstword = true;\n            foreach ($words as $word) {\n                if ($qp_mode && (strlen($word) > $length)) {\n                    $space_left = $length - strlen($buf) - $crlflen;\n                    if (!$firstword) {\n                        if ($space_left > 20) {\n                            $len = $space_left;\n                            if ($is_utf8) {\n                                $len = $this->utf8CharBoundary($word, $len);\n                            } elseif ('=' === substr($word, $len - 1, 1)) {\n                                --$len;\n                            } elseif ('=' === substr($word, $len - 2, 1)) {\n                                $len -= 2;\n                            }\n                            $part = substr($word, 0, $len);\n                            $word = substr($word, $len);\n                            $buf .= ' ' . $part;\n                            $message .= $buf . sprintf('=%s', static::$LE);\n                        } else {\n                            $message .= $buf . $soft_break;\n                        }\n                        $buf = '';\n                    }\n                    while ($word !== '') {\n                        if ($length <= 0) {\n                            break;\n                        }\n                        $len = $length;\n                        if ($is_utf8) {\n                            $len = $this->utf8CharBoundary($word, $len);\n                        } elseif ('=' === substr($word, $len - 1, 1)) {\n                            --$len;\n                        } elseif ('=' === substr($word, $len - 2, 1)) {\n                            $len -= 2;\n                        }\n                        $part = substr($word, 0, $len);\n                        $word = (string) substr($word, $len);\n\n                        if ($word !== '') {\n                            $message .= $part . sprintf('=%s', static::$LE);\n                        } else {\n                            $buf = $part;\n                        }\n                    }\n                } else {\n                    $buf_o = $buf;\n                    if (!$firstword) {\n                        $buf .= ' ';\n                    }\n                    $buf .= $word;\n\n                    if ('' !== $buf_o && strlen($buf) > $length) {\n                        $message .= $buf_o . $soft_break;\n                        $buf = $word;\n                    }\n                }\n                $firstword = false;\n            }\n            $message .= $buf . static::$LE;\n        }\n\n        return $message;\n    }\n\n    /**\n     * Find the last character boundary prior to $maxLength in a utf-8\n     * quoted-printable encoded string.\n     * Original written by Colin Brown.\n     *\n     * @param string $encodedText utf-8 QP text\n     * @param int    $maxLength   Find the last character boundary prior to this length\n     *\n     * @return int\n     */\n    public function utf8CharBoundary($encodedText, $maxLength)\n    {\n        $foundSplitPos = false;\n        $lookBack = 3;\n        while (!$foundSplitPos) {\n            $lastChunk = substr($encodedText, $maxLength - $lookBack, $lookBack);\n            $encodedCharPos = strpos($lastChunk, '=');\n            if (false !== $encodedCharPos) {\n                //Found start of encoded character byte within $lookBack block.\n                //Check the encoded byte value (the 2 chars after the '=')\n                $hex = substr($encodedText, $maxLength - $lookBack + $encodedCharPos + 1, 2);\n                $dec = hexdec($hex);\n                if ($dec < 128) {\n                    //Single byte character.\n                    //If the encoded char was found at pos 0, it will fit\n                    //otherwise reduce maxLength to start of the encoded char\n                    if ($encodedCharPos > 0) {\n                        $maxLength -= $lookBack - $encodedCharPos;\n                    }\n                    $foundSplitPos = true;\n                } elseif ($dec >= 192) {\n                    //First byte of a multi byte character\n                    //Reduce maxLength to split at start of character\n                    $maxLength -= $lookBack - $encodedCharPos;\n                    $foundSplitPos = true;\n                } elseif ($dec < 192) {\n                    //Middle byte of a multi byte character, look further back\n                    $lookBack += 3;\n                }\n            } else {\n                //No encoded character found\n                $foundSplitPos = true;\n            }\n        }\n\n        return $maxLength;\n    }\n\n    /**\n     * Apply word wrapping to the message body.\n     * Wraps the message body to the number of chars set in the WordWrap property.\n     * You should only do this to plain-text bodies as wrapping HTML tags may break them.\n     * This is called automatically by createBody(), so you don't need to call it yourself.\n     */\n    public function setWordWrap()\n    {\n        if ($this->WordWrap < 1) {\n            return;\n        }\n\n        switch ($this->message_type) {\n            case 'alt':\n            case 'alt_inline':\n            case 'alt_attach':\n            case 'alt_inline_attach':\n                $this->AltBody = $this->wrapText($this->AltBody, $this->WordWrap);\n                break;\n            default:\n                $this->Body = $this->wrapText($this->Body, $this->WordWrap);\n                break;\n        }\n    }\n\n    /**\n     * Assemble message headers.\n     *\n     * @return string The assembled headers\n     */\n    public function createHeader()\n    {\n        $result = '';\n\n        $result .= $this->headerLine('Date', '' === $this->MessageDate ? self::rfcDate() : $this->MessageDate);\n\n        //The To header is created automatically by mail(), so needs to be omitted here\n        if ('mail' !== $this->Mailer) {\n            if ($this->SingleTo) {\n                foreach ($this->to as $toaddr) {\n                    $this->SingleToArray[] = $this->addrFormat($toaddr);\n                }\n            } elseif (count($this->to) > 0) {\n                $result .= $this->addrAppend('To', $this->to);\n            } elseif (count($this->cc) === 0) {\n                $result .= $this->headerLine('To', 'undisclosed-recipients:;');\n            }\n        }\n        $result .= $this->addrAppend('From', [[trim($this->From), $this->FromName]]);\n\n        //sendmail and mail() extract Cc from the header before sending\n        if (count($this->cc) > 0) {\n            $result .= $this->addrAppend('Cc', $this->cc);\n        }\n\n        //sendmail and mail() extract Bcc from the header before sending\n        if (\n            (\n                'sendmail' === $this->Mailer || 'qmail' === $this->Mailer || 'mail' === $this->Mailer\n            )\n            && count($this->bcc) > 0\n        ) {\n            $result .= $this->addrAppend('Bcc', $this->bcc);\n        }\n\n        if (count($this->ReplyTo) > 0) {\n            $result .= $this->addrAppend('Reply-To', $this->ReplyTo);\n        }\n\n        //mail() sets the subject itself\n        if ('mail' !== $this->Mailer) {\n            $result .= $this->headerLine('Subject', $this->encodeHeader($this->secureHeader($this->Subject)));\n        }\n\n        //Only allow a custom message ID if it conforms to RFC 5322 section 3.6.4\n        //https://tools.ietf.org/html/rfc5322#section-3.6.4\n        if ('' !== $this->MessageID && preg_match('/^<.*@.*>$/', $this->MessageID)) {\n            $this->lastMessageID = $this->MessageID;\n        } else {\n            $this->lastMessageID = sprintf('<%s@%s>', $this->uniqueid, $this->serverHostname());\n        }\n        $result .= $this->headerLine('Message-ID', $this->lastMessageID);\n        if (null !== $this->Priority) {\n            $result .= $this->headerLine('X-Priority', $this->Priority);\n        }\n        if ('' === $this->XMailer) {\n            $result .= $this->headerLine(\n                'X-Mailer',\n                'PHPMailer ' . self::VERSION . ' (https://github.com/PHPMailer/PHPMailer)'\n            );\n        } else {\n            $myXmailer = trim($this->XMailer);\n            if ($myXmailer) {\n                $result .= $this->headerLine('X-Mailer', $myXmailer);\n            }\n        }\n\n        if ('' !== $this->ConfirmReadingTo) {\n            $result .= $this->headerLine('Disposition-Notification-To', '<' . $this->ConfirmReadingTo . '>');\n        }\n\n        //Add custom headers\n        foreach ($this->CustomHeader as $header) {\n            $result .= $this->headerLine(\n                trim($header[0]),\n                $this->encodeHeader(trim($header[1]))\n            );\n        }\n        if (!$this->sign_key_file) {\n            $result .= $this->headerLine('MIME-Version', '1.0');\n            $result .= $this->getMailMIME();\n        }\n\n        return $result;\n    }\n\n    /**\n     * Get the message MIME type headers.\n     *\n     * @return string\n     */\n    public function getMailMIME()\n    {\n        $result = '';\n        $ismultipart = true;\n        switch ($this->message_type) {\n            case 'inline':\n                $result .= $this->headerLine('Content-Type', static::CONTENT_TYPE_MULTIPART_RELATED . ';');\n                $result .= $this->textLine(' boundary=\"' . $this->boundary[1] . '\"');\n                break;\n            case 'attach':\n            case 'inline_attach':\n            case 'alt_attach':\n            case 'alt_inline_attach':\n                $result .= $this->headerLine('Content-Type', static::CONTENT_TYPE_MULTIPART_MIXED . ';');\n                $result .= $this->textLine(' boundary=\"' . $this->boundary[1] . '\"');\n                break;\n            case 'alt':\n            case 'alt_inline':\n                $result .= $this->headerLine('Content-Type', static::CONTENT_TYPE_MULTIPART_ALTERNATIVE . ';');\n                $result .= $this->textLine(' boundary=\"' . $this->boundary[1] . '\"');\n                break;\n            default:\n                //Catches case 'plain': and case '':\n                $result .= $this->textLine('Content-Type: ' . $this->ContentType . '; charset=' . $this->CharSet);\n                $ismultipart = false;\n                break;\n        }\n        //RFC1341 part 5 says 7bit is assumed if not specified\n        if (static::ENCODING_7BIT !== $this->Encoding) {\n            //RFC 2045 section 6.4 says multipart MIME parts may only use 7bit, 8bit or binary CTE\n            if ($ismultipart) {\n                if (static::ENCODING_8BIT === $this->Encoding) {\n                    $result .= $this->headerLine('Content-Transfer-Encoding', static::ENCODING_8BIT);\n                }\n                //The only remaining alternatives are quoted-printable and base64, which are both 7bit compatible\n            } else {\n                $result .= $this->headerLine('Content-Transfer-Encoding', $this->Encoding);\n            }\n        }\n\n        return $result;\n    }\n\n    /**\n     * Returns the whole MIME message.\n     * Includes complete headers and body.\n     * Only valid post preSend().\n     *\n     * @see PHPMailer::preSend()\n     *\n     * @return string\n     */\n    public function getSentMIMEMessage()\n    {\n        return static::stripTrailingWSP($this->MIMEHeader . $this->mailHeader) .\n            static::$LE . static::$LE . $this->MIMEBody;\n    }\n\n    /**\n     * Create a unique ID to use for boundaries.\n     *\n     * @return string\n     */\n    protected function generateId()\n    {\n        $len = 32; //32 bytes = 256 bits\n        $bytes = '';\n        if (function_exists('random_bytes')) {\n            try {\n                $bytes = random_bytes($len);\n            } catch (\\Exception $e) {\n                //Do nothing\n            }\n        } elseif (function_exists('openssl_random_pseudo_bytes')) {\n            /** @noinspection CryptographicallySecureRandomnessInspection */\n            $bytes = openssl_random_pseudo_bytes($len);\n        }\n        if ($bytes === '') {\n            //We failed to produce a proper random string, so make do.\n            //Use a hash to force the length to the same as the other methods\n            $bytes = hash('sha256', uniqid((string) mt_rand(), true), true);\n        }\n\n        //We don't care about messing up base64 format here, just want a random string\n        return str_replace(['=', '+', '/'], '', base64_encode(hash('sha256', $bytes, true)));\n    }\n\n    /**\n     * Assemble the message body.\n     * Returns an empty string on failure.\n     *\n     * @throws Exception\n     *\n     * @return string The assembled message body\n     */\n    public function createBody()\n    {\n        $body = '';\n        //Create unique IDs and preset boundaries\n        $this->uniqueid = $this->generateId();\n        $this->boundary[1] = 'b1_' . $this->uniqueid;\n        $this->boundary[2] = 'b2_' . $this->uniqueid;\n        $this->boundary[3] = 'b3_' . $this->uniqueid;\n\n        if ($this->sign_key_file) {\n            $body .= $this->getMailMIME() . static::$LE;\n        }\n\n        $this->setWordWrap();\n\n        $bodyEncoding = $this->Encoding;\n        $bodyCharSet = $this->CharSet;\n        //Can we do a 7-bit downgrade?\n        if (static::ENCODING_8BIT === $bodyEncoding && !$this->has8bitChars($this->Body)) {\n            $bodyEncoding = static::ENCODING_7BIT;\n            //All ISO 8859, Windows codepage and UTF-8 charsets are ascii compatible up to 7-bit\n            $bodyCharSet = static::CHARSET_ASCII;\n        }\n        //If lines are too long, and we're not already using an encoding that will shorten them,\n        //change to quoted-printable transfer encoding for the body part only\n        if (static::ENCODING_BASE64 !== $this->Encoding && static::hasLineLongerThanMax($this->Body)) {\n            $bodyEncoding = static::ENCODING_QUOTED_PRINTABLE;\n        }\n\n        $altBodyEncoding = $this->Encoding;\n        $altBodyCharSet = $this->CharSet;\n        //Can we do a 7-bit downgrade?\n        if (static::ENCODING_8BIT === $altBodyEncoding && !$this->has8bitChars($this->AltBody)) {\n            $altBodyEncoding = static::ENCODING_7BIT;\n            //All ISO 8859, Windows codepage and UTF-8 charsets are ascii compatible up to 7-bit\n            $altBodyCharSet = static::CHARSET_ASCII;\n        }\n        //If lines are too long, and we're not already using an encoding that will shorten them,\n        //change to quoted-printable transfer encoding for the alt body part only\n        if (static::ENCODING_BASE64 !== $altBodyEncoding && static::hasLineLongerThanMax($this->AltBody)) {\n            $altBodyEncoding = static::ENCODING_QUOTED_PRINTABLE;\n        }\n        //Use this as a preamble in all multipart message types\n        $mimepre = 'This is a multi-part message in MIME format.' . static::$LE . static::$LE;\n        switch ($this->message_type) {\n            case 'inline':\n                $body .= $mimepre;\n                $body .= $this->getBoundary($this->boundary[1], $bodyCharSet, '', $bodyEncoding);\n                $body .= $this->encodeString($this->Body, $bodyEncoding);\n                $body .= static::$LE;\n                $body .= $this->attachAll('inline', $this->boundary[1]);\n                break;\n            case 'attach':\n                $body .= $mimepre;\n                $body .= $this->getBoundary($this->boundary[1], $bodyCharSet, '', $bodyEncoding);\n                $body .= $this->encodeString($this->Body, $bodyEncoding);\n                $body .= static::$LE;\n                $body .= $this->attachAll('attachment', $this->boundary[1]);\n                break;\n            case 'inline_attach':\n                $body .= $mimepre;\n                $body .= $this->textLine('--' . $this->boundary[1]);\n                $body .= $this->headerLine('Content-Type', static::CONTENT_TYPE_MULTIPART_RELATED . ';');\n                $body .= $this->textLine(' boundary=\"' . $this->boundary[2] . '\";');\n                $body .= $this->textLine(' type=\"' . static::CONTENT_TYPE_TEXT_HTML . '\"');\n                $body .= static::$LE;\n                $body .= $this->getBoundary($this->boundary[2], $bodyCharSet, '', $bodyEncoding);\n                $body .= $this->encodeString($this->Body, $bodyEncoding);\n                $body .= static::$LE;\n                $body .= $this->attachAll('inline', $this->boundary[2]);\n                $body .= static::$LE;\n                $body .= $this->attachAll('attachment', $this->boundary[1]);\n                break;\n            case 'alt':\n                $body .= $mimepre;\n                $body .= $this->getBoundary(\n                    $this->boundary[1],\n                    $altBodyCharSet,\n                    static::CONTENT_TYPE_PLAINTEXT,\n                    $altBodyEncoding\n                );\n                $body .= $this->encodeString($this->AltBody, $altBodyEncoding);\n                $body .= static::$LE;\n                $body .= $this->getBoundary(\n                    $this->boundary[1],\n                    $bodyCharSet,\n                    static::CONTENT_TYPE_TEXT_HTML,\n                    $bodyEncoding\n                );\n                $body .= $this->encodeString($this->Body, $bodyEncoding);\n                $body .= static::$LE;\n                if (!empty($this->Ical)) {\n                    $method = static::ICAL_METHOD_REQUEST;\n                    foreach (static::$IcalMethods as $imethod) {\n                        if (stripos($this->Ical, 'METHOD:' . $imethod) !== false) {\n                            $method = $imethod;\n                            break;\n                        }\n                    }\n                    $body .= $this->getBoundary(\n                        $this->boundary[1],\n                        '',\n                        static::CONTENT_TYPE_TEXT_CALENDAR . '; method=' . $method,\n                        ''\n                    );\n                    $body .= $this->encodeString($this->Ical, $this->Encoding);\n                    $body .= static::$LE;\n                }\n                $body .= $this->endBoundary($this->boundary[1]);\n                break;\n            case 'alt_inline':\n                $body .= $mimepre;\n                $body .= $this->getBoundary(\n                    $this->boundary[1],\n                    $altBodyCharSet,\n                    static::CONTENT_TYPE_PLAINTEXT,\n                    $altBodyEncoding\n                );\n                $body .= $this->encodeString($this->AltBody, $altBodyEncoding);\n                $body .= static::$LE;\n                $body .= $this->textLine('--' . $this->boundary[1]);\n                $body .= $this->headerLine('Content-Type', static::CONTENT_TYPE_MULTIPART_RELATED . ';');\n                $body .= $this->textLine(' boundary=\"' . $this->boundary[2] . '\";');\n                $body .= $this->textLine(' type=\"' . static::CONTENT_TYPE_TEXT_HTML . '\"');\n                $body .= static::$LE;\n                $body .= $this->getBoundary(\n                    $this->boundary[2],\n                    $bodyCharSet,\n                    static::CONTENT_TYPE_TEXT_HTML,\n                    $bodyEncoding\n                );\n                $body .= $this->encodeString($this->Body, $bodyEncoding);\n                $body .= static::$LE;\n                $body .= $this->attachAll('inline', $this->boundary[2]);\n                $body .= static::$LE;\n                $body .= $this->endBoundary($this->boundary[1]);\n                break;\n            case 'alt_attach':\n                $body .= $mimepre;\n                $body .= $this->textLine('--' . $this->boundary[1]);\n                $body .= $this->headerLine('Content-Type', static::CONTENT_TYPE_MULTIPART_ALTERNATIVE . ';');\n                $body .= $this->textLine(' boundary=\"' . $this->boundary[2] . '\"');\n                $body .= static::$LE;\n                $body .= $this->getBoundary(\n                    $this->boundary[2],\n                    $altBodyCharSet,\n                    static::CONTENT_TYPE_PLAINTEXT,\n                    $altBodyEncoding\n                );\n                $body .= $this->encodeString($this->AltBody, $altBodyEncoding);\n                $body .= static::$LE;\n                $body .= $this->getBoundary(\n                    $this->boundary[2],\n                    $bodyCharSet,\n                    static::CONTENT_TYPE_TEXT_HTML,\n                    $bodyEncoding\n                );\n                $body .= $this->encodeString($this->Body, $bodyEncoding);\n                $body .= static::$LE;\n                if (!empty($this->Ical)) {\n                    $method = static::ICAL_METHOD_REQUEST;\n                    foreach (static::$IcalMethods as $imethod) {\n                        if (stripos($this->Ical, 'METHOD:' . $imethod) !== false) {\n                            $method = $imethod;\n                            break;\n                        }\n                    }\n                    $body .= $this->getBoundary(\n                        $this->boundary[2],\n                        '',\n                        static::CONTENT_TYPE_TEXT_CALENDAR . '; method=' . $method,\n                        ''\n                    );\n                    $body .= $this->encodeString($this->Ical, $this->Encoding);\n                }\n                $body .= $this->endBoundary($this->boundary[2]);\n                $body .= static::$LE;\n                $body .= $this->attachAll('attachment', $this->boundary[1]);\n                break;\n            case 'alt_inline_attach':\n                $body .= $mimepre;\n                $body .= $this->textLine('--' . $this->boundary[1]);\n                $body .= $this->headerLine('Content-Type', static::CONTENT_TYPE_MULTIPART_ALTERNATIVE . ';');\n                $body .= $this->textLine(' boundary=\"' . $this->boundary[2] . '\"');\n                $body .= static::$LE;\n                $body .= $this->getBoundary(\n                    $this->boundary[2],\n                    $altBodyCharSet,\n                    static::CONTENT_TYPE_PLAINTEXT,\n                    $altBodyEncoding\n                );\n                $body .= $this->encodeString($this->AltBody, $altBodyEncoding);\n                $body .= static::$LE;\n                $body .= $this->textLine('--' . $this->boundary[2]);\n                $body .= $this->headerLine('Content-Type', static::CONTENT_TYPE_MULTIPART_RELATED . ';');\n                $body .= $this->textLine(' boundary=\"' . $this->boundary[3] . '\";');\n                $body .= $this->textLine(' type=\"' . static::CONTENT_TYPE_TEXT_HTML . '\"');\n                $body .= static::$LE;\n                $body .= $this->getBoundary(\n                    $this->boundary[3],\n                    $bodyCharSet,\n                    static::CONTENT_TYPE_TEXT_HTML,\n                    $bodyEncoding\n                );\n                $body .= $this->encodeString($this->Body, $bodyEncoding);\n                $body .= static::$LE;\n                $body .= $this->attachAll('inline', $this->boundary[3]);\n                $body .= static::$LE;\n                $body .= $this->endBoundary($this->boundary[2]);\n                $body .= static::$LE;\n                $body .= $this->attachAll('attachment', $this->boundary[1]);\n                break;\n            default:\n                //Catch case 'plain' and case '', applies to simple `text/plain` and `text/html` body content types\n                //Reset the `Encoding` property in case we changed it for line length reasons\n                $this->Encoding = $bodyEncoding;\n                $body .= $this->encodeString($this->Body, $this->Encoding);\n                break;\n        }\n\n        if ($this->isError()) {\n            $body = '';\n            if ($this->exceptions) {\n                throw new Exception($this->lang('empty_message'), self::STOP_CRITICAL);\n            }\n        } elseif ($this->sign_key_file) {\n            try {\n                if (!defined('PKCS7_TEXT')) {\n                    throw new Exception($this->lang('extension_missing') . 'openssl');\n                }\n\n                $file = tempnam(sys_get_temp_dir(), 'srcsign');\n                $signed = tempnam(sys_get_temp_dir(), 'mailsign');\n                file_put_contents($file, $body);\n\n                //Workaround for PHP bug https://bugs.php.net/bug.php?id=69197\n                if (empty($this->sign_extracerts_file)) {\n                    $sign = @openssl_pkcs7_sign(\n                        $file,\n                        $signed,\n                        'file://' . realpath($this->sign_cert_file),\n                        ['file://' . realpath($this->sign_key_file), $this->sign_key_pass],\n                        []\n                    );\n                } else {\n                    $sign = @openssl_pkcs7_sign(\n                        $file,\n                        $signed,\n                        'file://' . realpath($this->sign_cert_file),\n                        ['file://' . realpath($this->sign_key_file), $this->sign_key_pass],\n                        [],\n                        PKCS7_DETACHED,\n                        $this->sign_extracerts_file\n                    );\n                }\n\n                @unlink($file);\n                if ($sign) {\n                    $body = file_get_contents($signed);\n                    @unlink($signed);\n                    //The message returned by openssl contains both headers and body, so need to split them up\n                    $parts = explode(\"\\n\\n\", $body, 2);\n                    $this->MIMEHeader .= $parts[0] . static::$LE . static::$LE;\n                    $body = $parts[1];\n                } else {\n                    @unlink($signed);\n                    throw new Exception($this->lang('signing') . openssl_error_string());\n                }\n            } catch (Exception $exc) {\n                $body = '';\n                if ($this->exceptions) {\n                    throw $exc;\n                }\n            }\n        }\n\n        return $body;\n    }\n\n    /**\n     * Return the start of a message boundary.\n     *\n     * @param string $boundary\n     * @param string $charSet\n     * @param string $contentType\n     * @param string $encoding\n     *\n     * @return string\n     */\n    protected function getBoundary($boundary, $charSet, $contentType, $encoding)\n    {\n        $result = '';\n        if ('' === $charSet) {\n            $charSet = $this->CharSet;\n        }\n        if ('' === $contentType) {\n            $contentType = $this->ContentType;\n        }\n        if ('' === $encoding) {\n            $encoding = $this->Encoding;\n        }\n        $result .= $this->textLine('--' . $boundary);\n        $result .= sprintf('Content-Type: %s; charset=%s', $contentType, $charSet);\n        $result .= static::$LE;\n        //RFC1341 part 5 says 7bit is assumed if not specified\n        if (static::ENCODING_7BIT !== $encoding) {\n            $result .= $this->headerLine('Content-Transfer-Encoding', $encoding);\n        }\n        $result .= static::$LE;\n\n        return $result;\n    }\n\n    /**\n     * Return the end of a message boundary.\n     *\n     * @param string $boundary\n     *\n     * @return string\n     */\n    protected function endBoundary($boundary)\n    {\n        return static::$LE . '--' . $boundary . '--' . static::$LE;\n    }\n\n    /**\n     * Set the message type.\n     * PHPMailer only supports some preset message types, not arbitrary MIME structures.\n     */\n    protected function setMessageType()\n    {\n        $type = [];\n        if ($this->alternativeExists()) {\n            $type[] = 'alt';\n        }\n        if ($this->inlineImageExists()) {\n            $type[] = 'inline';\n        }\n        if ($this->attachmentExists()) {\n            $type[] = 'attach';\n        }\n        $this->message_type = implode('_', $type);\n        if ('' === $this->message_type) {\n            //The 'plain' message_type refers to the message having a single body element, not that it is plain-text\n            $this->message_type = 'plain';\n        }\n    }\n\n    /**\n     * Format a header line.\n     *\n     * @param string     $name\n     * @param string|int $value\n     *\n     * @return string\n     */\n    public function headerLine($name, $value)\n    {\n        return $name . ': ' . $value . static::$LE;\n    }\n\n    /**\n     * Return a formatted mail line.\n     *\n     * @param string $value\n     *\n     * @return string\n     */\n    public function textLine($value)\n    {\n        return $value . static::$LE;\n    }\n\n    /**\n     * Add an attachment from a path on the filesystem.\n     * Never use a user-supplied path to a file!\n     * Returns false if the file could not be found or read.\n     * Explicitly *does not* support passing URLs; PHPMailer is not an HTTP client.\n     * If you need to do that, fetch the resource yourself and pass it in via a local file or string.\n     *\n     * @param string $path        Path to the attachment\n     * @param string $name        Overrides the attachment name\n     * @param string $encoding    File encoding (see $Encoding)\n     * @param string $type        MIME type, e.g. `image/jpeg`; determined automatically from $path if not specified\n     * @param string $disposition Disposition to use\n     *\n     * @throws Exception\n     *\n     * @return bool\n     */\n    public function addAttachment(\n        $path,\n        $name = '',\n        $encoding = self::ENCODING_BASE64,\n        $type = '',\n        $disposition = 'attachment'\n    ) {\n        try {\n            if (!static::fileIsAccessible($path)) {\n                throw new Exception($this->lang('file_access') . $path, self::STOP_CONTINUE);\n            }\n\n            //If a MIME type is not specified, try to work it out from the file name\n            if ('' === $type) {\n                $type = static::filenameToType($path);\n            }\n\n            $filename = (string) static::mb_pathinfo($path, PATHINFO_BASENAME);\n            if ('' === $name) {\n                $name = $filename;\n            }\n            if (!$this->validateEncoding($encoding)) {\n                throw new Exception($this->lang('encoding') . $encoding);\n            }\n\n            $this->attachment[] = [\n                0 => $path,\n                1 => $filename,\n                2 => $name,\n                3 => $encoding,\n                4 => $type,\n                5 => false, //isStringAttachment\n                6 => $disposition,\n                7 => $name,\n            ];\n        } catch (Exception $exc) {\n            $this->setError($exc->getMessage());\n            $this->edebug($exc->getMessage());\n            if ($this->exceptions) {\n                throw $exc;\n            }\n\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * Return the array of attachments.\n     *\n     * @return array\n     */\n    public function getAttachments()\n    {\n        return $this->attachment;\n    }\n\n    /**\n     * Attach all file, string, and binary attachments to the message.\n     * Returns an empty string on failure.\n     *\n     * @param string $disposition_type\n     * @param string $boundary\n     *\n     * @throws Exception\n     *\n     * @return string\n     */\n    protected function attachAll($disposition_type, $boundary)\n    {\n        //Return text of body\n        $mime = [];\n        $cidUniq = [];\n        $incl = [];\n\n        //Add all attachments\n        foreach ($this->attachment as $attachment) {\n            //Check if it is a valid disposition_filter\n            if ($attachment[6] === $disposition_type) {\n                //Check for string attachment\n                $string = '';\n                $path = '';\n                $bString = $attachment[5];\n                if ($bString) {\n                    $string = $attachment[0];\n                } else {\n                    $path = $attachment[0];\n                }\n\n                $inclhash = hash('sha256', serialize($attachment));\n                if (in_array($inclhash, $incl, true)) {\n                    continue;\n                }\n                $incl[] = $inclhash;\n                $name = $attachment[2];\n                $encoding = $attachment[3];\n                $type = $attachment[4];\n                $disposition = $attachment[6];\n                $cid = $attachment[7];\n                if ('inline' === $disposition && array_key_exists($cid, $cidUniq)) {\n                    continue;\n                }\n                $cidUniq[$cid] = true;\n\n                $mime[] = sprintf('--%s%s', $boundary, static::$LE);\n                //Only include a filename property if we have one\n                if (!empty($name)) {\n                    $mime[] = sprintf(\n                        'Content-Type: %s; name=%s%s',\n                        $type,\n                        static::quotedString($this->encodeHeader($this->secureHeader($name))),\n                        static::$LE\n                    );\n                } else {\n                    $mime[] = sprintf(\n                        'Content-Type: %s%s',\n                        $type,\n                        static::$LE\n                    );\n                }\n                //RFC1341 part 5 says 7bit is assumed if not specified\n                if (static::ENCODING_7BIT !== $encoding) {\n                    $mime[] = sprintf('Content-Transfer-Encoding: %s%s', $encoding, static::$LE);\n                }\n\n                //Only set Content-IDs on inline attachments\n                if ((string) $cid !== '' && $disposition === 'inline') {\n                    $mime[] = 'Content-ID: <' . $this->encodeHeader($this->secureHeader($cid)) . '>' . static::$LE;\n                }\n\n                //Allow for bypassing the Content-Disposition header\n                if (!empty($disposition)) {\n                    $encoded_name = $this->encodeHeader($this->secureHeader($name));\n                    if (!empty($encoded_name)) {\n                        $mime[] = sprintf(\n                            'Content-Disposition: %s; filename=%s%s',\n                            $disposition,\n                            static::quotedString($encoded_name),\n                            static::$LE . static::$LE\n                        );\n                    } else {\n                        $mime[] = sprintf(\n                            'Content-Disposition: %s%s',\n                            $disposition,\n                            static::$LE . static::$LE\n                        );\n                    }\n                } else {\n                    $mime[] = static::$LE;\n                }\n\n                //Encode as string attachment\n                if ($bString) {\n                    $mime[] = $this->encodeString($string, $encoding);\n                } else {\n                    $mime[] = $this->encodeFile($path, $encoding);\n                }\n                if ($this->isError()) {\n                    return '';\n                }\n                $mime[] = static::$LE;\n            }\n        }\n\n        $mime[] = sprintf('--%s--%s', $boundary, static::$LE);\n\n        return implode('', $mime);\n    }\n\n    /**\n     * Encode a file attachment in requested format.\n     * Returns an empty string on failure.\n     *\n     * @param string $path     The full path to the file\n     * @param string $encoding The encoding to use; one of 'base64', '7bit', '8bit', 'binary', 'quoted-printable'\n     *\n     * @return string\n     */\n    protected function encodeFile($path, $encoding = self::ENCODING_BASE64)\n    {\n        try {\n            if (!static::fileIsAccessible($path)) {\n                throw new Exception($this->lang('file_open') . $path, self::STOP_CONTINUE);\n            }\n            $file_buffer = file_get_contents($path);\n            if (false === $file_buffer) {\n                throw new Exception($this->lang('file_open') . $path, self::STOP_CONTINUE);\n            }\n            $file_buffer = $this->encodeString($file_buffer, $encoding);\n\n            return $file_buffer;\n        } catch (Exception $exc) {\n            $this->setError($exc->getMessage());\n            $this->edebug($exc->getMessage());\n            if ($this->exceptions) {\n                throw $exc;\n            }\n\n            return '';\n        }\n    }\n\n    /**\n     * Encode a string in requested format.\n     * Returns an empty string on failure.\n     *\n     * @param string $str      The text to encode\n     * @param string $encoding The encoding to use; one of 'base64', '7bit', '8bit', 'binary', 'quoted-printable'\n     *\n     * @throws Exception\n     *\n     * @return string\n     */\n    public function encodeString($str, $encoding = self::ENCODING_BASE64)\n    {\n        $encoded = '';\n        switch (strtolower($encoding)) {\n            case static::ENCODING_BASE64:\n                $encoded = chunk_split(\n                    base64_encode($str),\n                    static::STD_LINE_LENGTH,\n                    static::$LE\n                );\n                break;\n            case static::ENCODING_7BIT:\n            case static::ENCODING_8BIT:\n                $encoded = static::normalizeBreaks($str);\n                //Make sure it ends with a line break\n                if (substr($encoded, -(strlen(static::$LE))) !== static::$LE) {\n                    $encoded .= static::$LE;\n                }\n                break;\n            case static::ENCODING_BINARY:\n                $encoded = $str;\n                break;\n            case static::ENCODING_QUOTED_PRINTABLE:\n                $encoded = $this->encodeQP($str);\n                break;\n            default:\n                $this->setError($this->lang('encoding') . $encoding);\n                if ($this->exceptions) {\n                    throw new Exception($this->lang('encoding') . $encoding);\n                }\n                break;\n        }\n\n        return $encoded;\n    }\n\n    /**\n     * Encode a header value (not including its label) optimally.\n     * Picks shortest of Q, B, or none. Result includes folding if needed.\n     * See RFC822 definitions for phrase, comment and text positions.\n     *\n     * @param string $str      The header value to encode\n     * @param string $position What context the string will be used in\n     *\n     * @return string\n     */\n    public function encodeHeader($str, $position = 'text')\n    {\n        $matchcount = 0;\n        switch (strtolower($position)) {\n            case 'phrase':\n                if (!preg_match('/[\\200-\\377]/', $str)) {\n                    //Can't use addslashes as we don't know the value of magic_quotes_sybase\n                    $encoded = addcslashes($str, \"\\0..\\37\\177\\\\\\\"\");\n                    if (($str === $encoded) && !preg_match('/[^A-Za-z0-9!#$%&\\'*+\\/=?^_`{|}~ -]/', $str)) {\n                        return $encoded;\n                    }\n\n                    return \"\\\"$encoded\\\"\";\n                }\n                $matchcount = preg_match_all('/[^\\040\\041\\043-\\133\\135-\\176]/', $str, $matches);\n                break;\n            /* @noinspection PhpMissingBreakStatementInspection */\n            case 'comment':\n                $matchcount = preg_match_all('/[()\"]/', $str, $matches);\n            //fallthrough\n            case 'text':\n            default:\n                $matchcount += preg_match_all('/[\\000-\\010\\013\\014\\016-\\037\\177-\\377]/', $str, $matches);\n                break;\n        }\n\n        if ($this->has8bitChars($str)) {\n            $charset = $this->CharSet;\n        } else {\n            $charset = static::CHARSET_ASCII;\n        }\n\n        //Q/B encoding adds 8 chars and the charset (\"` =?<charset>?[QB]?<content>?=`\").\n        $overhead = 8 + strlen($charset);\n\n        if ('mail' === $this->Mailer) {\n            $maxlen = static::MAIL_MAX_LINE_LENGTH - $overhead;\n        } else {\n            $maxlen = static::MAX_LINE_LENGTH - $overhead;\n        }\n\n        //Select the encoding that produces the shortest output and/or prevents corruption.\n        if ($matchcount > strlen($str) / 3) {\n            //More than 1/3 of the content needs encoding, use B-encode.\n            $encoding = 'B';\n        } elseif ($matchcount > 0) {\n            //Less than 1/3 of the content needs encoding, use Q-encode.\n            $encoding = 'Q';\n        } elseif (strlen($str) > $maxlen) {\n            //No encoding needed, but value exceeds max line length, use Q-encode to prevent corruption.\n            $encoding = 'Q';\n        } else {\n            //No reformatting needed\n            $encoding = false;\n        }\n\n        switch ($encoding) {\n            case 'B':\n                if ($this->hasMultiBytes($str)) {\n                    //Use a custom function which correctly encodes and wraps long\n                    //multibyte strings without breaking lines within a character\n                    $encoded = $this->base64EncodeWrapMB($str, \"\\n\");\n                } else {\n                    $encoded = base64_encode($str);\n                    $maxlen -= $maxlen % 4;\n                    $encoded = trim(chunk_split($encoded, $maxlen, \"\\n\"));\n                }\n                $encoded = preg_replace('/^(.*)$/m', ' =?' . $charset . \"?$encoding?\\\\1?=\", $encoded);\n                break;\n            case 'Q':\n                $encoded = $this->encodeQ($str, $position);\n                $encoded = $this->wrapText($encoded, $maxlen, true);\n                $encoded = str_replace('=' . static::$LE, \"\\n\", trim($encoded));\n                $encoded = preg_replace('/^(.*)$/m', ' =?' . $charset . \"?$encoding?\\\\1?=\", $encoded);\n                break;\n            default:\n                return $str;\n        }\n\n        return trim(static::normalizeBreaks($encoded));\n    }\n\n    /**\n     * Check if a string contains multi-byte characters.\n     *\n     * @param string $str multi-byte text to wrap encode\n     *\n     * @return bool\n     */\n    public function hasMultiBytes($str)\n    {\n        if (function_exists('mb_strlen')) {\n            return strlen($str) > mb_strlen($str, $this->CharSet);\n        }\n\n        //Assume no multibytes (we can't handle without mbstring functions anyway)\n        return false;\n    }\n\n    /**\n     * Does a string contain any 8-bit chars (in any charset)?\n     *\n     * @param string $text\n     *\n     * @return bool\n     */\n    public function has8bitChars($text)\n    {\n        return (bool) preg_match('/[\\x80-\\xFF]/', $text);\n    }\n\n    /**\n     * Encode and wrap long multibyte strings for mail headers\n     * without breaking lines within a character.\n     * Adapted from a function by paravoid.\n     *\n     * @see http://www.php.net/manual/en/function.mb-encode-mimeheader.php#60283\n     *\n     * @param string $str       multi-byte text to wrap encode\n     * @param string $linebreak string to use as linefeed/end-of-line\n     *\n     * @return string\n     */\n    public function base64EncodeWrapMB($str, $linebreak = null)\n    {\n        $start = '=?' . $this->CharSet . '?B?';\n        $end = '?=';\n        $encoded = '';\n        if (null === $linebreak) {\n            $linebreak = static::$LE;\n        }\n\n        $mb_length = mb_strlen($str, $this->CharSet);\n        //Each line must have length <= 75, including $start and $end\n        $length = 75 - strlen($start) - strlen($end);\n        //Average multi-byte ratio\n        $ratio = $mb_length / strlen($str);\n        //Base64 has a 4:3 ratio\n        $avgLength = floor($length * $ratio * .75);\n\n        $offset = 0;\n        for ($i = 0; $i < $mb_length; $i += $offset) {\n            $lookBack = 0;\n            do {\n                $offset = $avgLength - $lookBack;\n                $chunk = mb_substr($str, $i, $offset, $this->CharSet);\n                $chunk = base64_encode($chunk);\n                ++$lookBack;\n            } while (strlen($chunk) > $length);\n            $encoded .= $chunk . $linebreak;\n        }\n\n        //Chomp the last linefeed\n        return substr($encoded, 0, -strlen($linebreak));\n    }\n\n    /**\n     * Encode a string in quoted-printable format.\n     * According to RFC2045 section 6.7.\n     *\n     * @param string $string The text to encode\n     *\n     * @return string\n     */\n    public function encodeQP($string)\n    {\n        return static::normalizeBreaks(quoted_printable_encode($string));\n    }\n\n    /**\n     * Encode a string using Q encoding.\n     *\n     * @see http://tools.ietf.org/html/rfc2047#section-4.2\n     *\n     * @param string $str      the text to encode\n     * @param string $position Where the text is going to be used, see the RFC for what that means\n     *\n     * @return string\n     */\n    public function encodeQ($str, $position = 'text')\n    {\n        //There should not be any EOL in the string\n        $pattern = '';\n        $encoded = str_replace([\"\\r\", \"\\n\"], '', $str);\n        switch (strtolower($position)) {\n            case 'phrase':\n                //RFC 2047 section 5.3\n                $pattern = '^A-Za-z0-9!*+\\/ -';\n                break;\n            /*\n             * RFC 2047 section 5.2.\n             * Build $pattern without including delimiters and []\n             */\n            /* @noinspection PhpMissingBreakStatementInspection */\n            case 'comment':\n                $pattern = '\\(\\)\"';\n            /* Intentional fall through */\n            case 'text':\n            default:\n                //RFC 2047 section 5.1\n                //Replace every high ascii, control, =, ? and _ characters\n                $pattern = '\\000-\\011\\013\\014\\016-\\037\\075\\077\\137\\177-\\377' . $pattern;\n                break;\n        }\n        $matches = [];\n        if (preg_match_all(\"/[{$pattern}]/\", $encoded, $matches)) {\n            //If the string contains an '=', make sure it's the first thing we replace\n            //so as to avoid double-encoding\n            $eqkey = array_search('=', $matches[0], true);\n            if (false !== $eqkey) {\n                unset($matches[0][$eqkey]);\n                array_unshift($matches[0], '=');\n            }\n            foreach (array_unique($matches[0]) as $char) {\n                $encoded = str_replace($char, '=' . sprintf('%02X', ord($char)), $encoded);\n            }\n        }\n        //Replace spaces with _ (more readable than =20)\n        //RFC 2047 section 4.2(2)\n        return str_replace(' ', '_', $encoded);\n    }\n\n    /**\n     * Add a string or binary attachment (non-filesystem).\n     * This method can be used to attach ascii or binary data,\n     * such as a BLOB record from a database.\n     *\n     * @param string $string      String attachment data\n     * @param string $filename    Name of the attachment\n     * @param string $encoding    File encoding (see $Encoding)\n     * @param string $type        File extension (MIME) type\n     * @param string $disposition Disposition to use\n     *\n     * @throws Exception\n     *\n     * @return bool True on successfully adding an attachment\n     */\n    public function addStringAttachment(\n        $string,\n        $filename,\n        $encoding = self::ENCODING_BASE64,\n        $type = '',\n        $disposition = 'attachment'\n    ) {\n        try {\n            //If a MIME type is not specified, try to work it out from the file name\n            if ('' === $type) {\n                $type = static::filenameToType($filename);\n            }\n\n            if (!$this->validateEncoding($encoding)) {\n                throw new Exception($this->lang('encoding') . $encoding);\n            }\n\n            //Append to $attachment array\n            $this->attachment[] = [\n                0 => $string,\n                1 => $filename,\n                2 => static::mb_pathinfo($filename, PATHINFO_BASENAME),\n                3 => $encoding,\n                4 => $type,\n                5 => true, //isStringAttachment\n                6 => $disposition,\n                7 => 0,\n            ];\n        } catch (Exception $exc) {\n            $this->setError($exc->getMessage());\n            $this->edebug($exc->getMessage());\n            if ($this->exceptions) {\n                throw $exc;\n            }\n\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * Add an embedded (inline) attachment from a file.\n     * This can include images, sounds, and just about any other document type.\n     * These differ from 'regular' attachments in that they are intended to be\n     * displayed inline with the message, not just attached for download.\n     * This is used in HTML messages that embed the images\n     * the HTML refers to using the $cid value.\n     * Never use a user-supplied path to a file!\n     *\n     * @param string $path        Path to the attachment\n     * @param string $cid         Content ID of the attachment; Use this to reference\n     *                            the content when using an embedded image in HTML\n     * @param string $name        Overrides the attachment name\n     * @param string $encoding    File encoding (see $Encoding)\n     * @param string $type        File MIME type\n     * @param string $disposition Disposition to use\n     *\n     * @throws Exception\n     *\n     * @return bool True on successfully adding an attachment\n     */\n    public function addEmbeddedImage(\n        $path,\n        $cid,\n        $name = '',\n        $encoding = self::ENCODING_BASE64,\n        $type = '',\n        $disposition = 'inline'\n    ) {\n        try {\n            if (!static::fileIsAccessible($path)) {\n                throw new Exception($this->lang('file_access') . $path, self::STOP_CONTINUE);\n            }\n\n            //If a MIME type is not specified, try to work it out from the file name\n            if ('' === $type) {\n                $type = static::filenameToType($path);\n            }\n\n            if (!$this->validateEncoding($encoding)) {\n                throw new Exception($this->lang('encoding') . $encoding);\n            }\n\n            $filename = (string) static::mb_pathinfo($path, PATHINFO_BASENAME);\n            if ('' === $name) {\n                $name = $filename;\n            }\n\n            //Append to $attachment array\n            $this->attachment[] = [\n                0 => $path,\n                1 => $filename,\n                2 => $name,\n                3 => $encoding,\n                4 => $type,\n                5 => false, //isStringAttachment\n                6 => $disposition,\n                7 => $cid,\n            ];\n        } catch (Exception $exc) {\n            $this->setError($exc->getMessage());\n            $this->edebug($exc->getMessage());\n            if ($this->exceptions) {\n                throw $exc;\n            }\n\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * Add an embedded stringified attachment.\n     * This can include images, sounds, and just about any other document type.\n     * If your filename doesn't contain an extension, be sure to set the $type to an appropriate MIME type.\n     *\n     * @param string $string      The attachment binary data\n     * @param string $cid         Content ID of the attachment; Use this to reference\n     *                            the content when using an embedded image in HTML\n     * @param string $name        A filename for the attachment. If this contains an extension,\n     *                            PHPMailer will attempt to set a MIME type for the attachment.\n     *                            For example 'file.jpg' would get an 'image/jpeg' MIME type.\n     * @param string $encoding    File encoding (see $Encoding), defaults to 'base64'\n     * @param string $type        MIME type - will be used in preference to any automatically derived type\n     * @param string $disposition Disposition to use\n     *\n     * @throws Exception\n     *\n     * @return bool True on successfully adding an attachment\n     */\n    public function addStringEmbeddedImage(\n        $string,\n        $cid,\n        $name = '',\n        $encoding = self::ENCODING_BASE64,\n        $type = '',\n        $disposition = 'inline'\n    ) {\n        try {\n            //If a MIME type is not specified, try to work it out from the name\n            if ('' === $type && !empty($name)) {\n                $type = static::filenameToType($name);\n            }\n\n            if (!$this->validateEncoding($encoding)) {\n                throw new Exception($this->lang('encoding') . $encoding);\n            }\n\n            //Append to $attachment array\n            $this->attachment[] = [\n                0 => $string,\n                1 => $name,\n                2 => $name,\n                3 => $encoding,\n                4 => $type,\n                5 => true, //isStringAttachment\n                6 => $disposition,\n                7 => $cid,\n            ];\n        } catch (Exception $exc) {\n            $this->setError($exc->getMessage());\n            $this->edebug($exc->getMessage());\n            if ($this->exceptions) {\n                throw $exc;\n            }\n\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * Validate encodings.\n     *\n     * @param string $encoding\n     *\n     * @return bool\n     */\n    protected function validateEncoding($encoding)\n    {\n        return in_array(\n            $encoding,\n            [\n                self::ENCODING_7BIT,\n                self::ENCODING_QUOTED_PRINTABLE,\n                self::ENCODING_BASE64,\n                self::ENCODING_8BIT,\n                self::ENCODING_BINARY,\n            ],\n            true\n        );\n    }\n\n    /**\n     * Check if an embedded attachment is present with this cid.\n     *\n     * @param string $cid\n     *\n     * @return bool\n     */\n    protected function cidExists($cid)\n    {\n        foreach ($this->attachment as $attachment) {\n            if ('inline' === $attachment[6] && $cid === $attachment[7]) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Check if an inline attachment is present.\n     *\n     * @return bool\n     */\n    public function inlineImageExists()\n    {\n        foreach ($this->attachment as $attachment) {\n            if ('inline' === $attachment[6]) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Check if an attachment (non-inline) is present.\n     *\n     * @return bool\n     */\n    public function attachmentExists()\n    {\n        foreach ($this->attachment as $attachment) {\n            if ('attachment' === $attachment[6]) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Check if this message has an alternative body set.\n     *\n     * @return bool\n     */\n    public function alternativeExists()\n    {\n        return !empty($this->AltBody);\n    }\n\n    /**\n     * Clear queued addresses of given kind.\n     *\n     * @param string $kind 'to', 'cc', or 'bcc'\n     */\n    public function clearQueuedAddresses($kind)\n    {\n        $this->RecipientsQueue = array_filter(\n            $this->RecipientsQueue,\n            static function ($params) use ($kind) {\n                return $params[0] !== $kind;\n            }\n        );\n    }\n\n    /**\n     * Clear all To recipients.\n     */\n    public function clearAddresses()\n    {\n        foreach ($this->to as $to) {\n            unset($this->all_recipients[strtolower($to[0])]);\n        }\n        $this->to = [];\n        $this->clearQueuedAddresses('to');\n    }\n\n    /**\n     * Clear all CC recipients.\n     */\n    public function clearCCs()\n    {\n        foreach ($this->cc as $cc) {\n            unset($this->all_recipients[strtolower($cc[0])]);\n        }\n        $this->cc = [];\n        $this->clearQueuedAddresses('cc');\n    }\n\n    /**\n     * Clear all BCC recipients.\n     */\n    public function clearBCCs()\n    {\n        foreach ($this->bcc as $bcc) {\n            unset($this->all_recipients[strtolower($bcc[0])]);\n        }\n        $this->bcc = [];\n        $this->clearQueuedAddresses('bcc');\n    }\n\n    /**\n     * Clear all ReplyTo recipients.\n     */\n    public function clearReplyTos()\n    {\n        $this->ReplyTo = [];\n        $this->ReplyToQueue = [];\n    }\n\n    /**\n     * Clear all recipient types.\n     */\n    public function clearAllRecipients()\n    {\n        $this->to = [];\n        $this->cc = [];\n        $this->bcc = [];\n        $this->all_recipients = [];\n        $this->RecipientsQueue = [];\n    }\n\n    /**\n     * Clear all filesystem, string, and binary attachments.\n     */\n    public function clearAttachments()\n    {\n        $this->attachment = [];\n    }\n\n    /**\n     * Clear all custom headers.\n     */\n    public function clearCustomHeaders()\n    {\n        $this->CustomHeader = [];\n    }\n\n    /**\n     * Add an error message to the error container.\n     *\n     * @param string $msg\n     */\n    protected function setError($msg)\n    {\n        ++$this->error_count;\n        if ('smtp' === $this->Mailer && null !== $this->smtp) {\n            $lasterror = $this->smtp->getError();\n            if (!empty($lasterror['error'])) {\n                $msg .= $this->lang('smtp_error') . $lasterror['error'];\n                if (!empty($lasterror['detail'])) {\n                    $msg .= ' Detail: ' . $lasterror['detail'];\n                }\n                if (!empty($lasterror['smtp_code'])) {\n                    $msg .= ' SMTP code: ' . $lasterror['smtp_code'];\n                }\n                if (!empty($lasterror['smtp_code_ex'])) {\n                    $msg .= ' Additional SMTP info: ' . $lasterror['smtp_code_ex'];\n                }\n            }\n        }\n        $this->ErrorInfo = $msg;\n    }\n\n    /**\n     * Return an RFC 822 formatted date.\n     *\n     * @return string\n     */\n    public static function rfcDate()\n    {\n        //Set the time zone to whatever the default is to avoid 500 errors\n        //Will default to UTC if it's not set properly in php.ini\n        date_default_timezone_set(@date_default_timezone_get());\n\n        return date('D, j M Y H:i:s O');\n    }\n\n    /**\n     * Get the server hostname.\n     * Returns 'localhost.localdomain' if unknown.\n     *\n     * @return string\n     */\n    protected function serverHostname()\n    {\n        $result = '';\n        if (!empty($this->Hostname)) {\n            $result = $this->Hostname;\n        } elseif (isset($_SERVER) && array_key_exists('SERVER_NAME', $_SERVER)) {\n            $result = $_SERVER['SERVER_NAME'];\n        } elseif (function_exists('gethostname') && gethostname() !== false) {\n            $result = gethostname();\n        } elseif (php_uname('n') !== false) {\n            $result = php_uname('n');\n        }\n        if (!static::isValidHost($result)) {\n            return 'localhost.localdomain';\n        }\n\n        return $result;\n    }\n\n    /**\n     * Validate whether a string contains a valid value to use as a hostname or IP address.\n     * IPv6 addresses must include [], e.g. `[::1]`, not just `::1`.\n     *\n     * @param string $host The host name or IP address to check\n     *\n     * @return bool\n     */\n    public static function isValidHost($host)\n    {\n        //Simple syntax limits\n        if (\n            empty($host)\n            || !is_string($host)\n            || strlen($host) > 256\n            || !preg_match('/^([a-zA-Z\\d.-]*|\\[[a-fA-F\\d:]+])$/', $host)\n        ) {\n            return false;\n        }\n        //Looks like a bracketed IPv6 address\n        if (strlen($host) > 2 && substr($host, 0, 1) === '[' && substr($host, -1, 1) === ']') {\n            return filter_var(substr($host, 1, -1), FILTER_VALIDATE_IP, FILTER_FLAG_IPV6) !== false;\n        }\n        //If removing all the dots results in a numeric string, it must be an IPv4 address.\n        //Need to check this first because otherwise things like `999.0.0.0` are considered valid host names\n        if (is_numeric(str_replace('.', '', $host))) {\n            //Is it a valid IPv4 address?\n            return filter_var($host, FILTER_VALIDATE_IP, FILTER_FLAG_IPV4) !== false;\n        }\n        if (filter_var('http://' . $host, FILTER_VALIDATE_URL) !== false) {\n            //Is it a syntactically valid hostname?\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Get an error message in the current language.\n     *\n     * @param string $key\n     *\n     * @return string\n     */\n    protected function lang($key)\n    {\n        if (count($this->language) < 1) {\n            $this->setLanguage(); //Set the default language\n        }\n\n        if (array_key_exists($key, $this->language)) {\n            if ('smtp_connect_failed' === $key) {\n                //Include a link to troubleshooting docs on SMTP connection failure.\n                //This is by far the biggest cause of support questions\n                //but it's usually not PHPMailer's fault.\n                return $this->language[$key] . ' https://github.com/PHPMailer/PHPMailer/wiki/Troubleshooting';\n            }\n\n            return $this->language[$key];\n        }\n\n        //Return the key as a fallback\n        return $key;\n    }\n\n    /**\n     * Check if an error occurred.\n     *\n     * @return bool True if an error did occur\n     */\n    public function isError()\n    {\n        return $this->error_count > 0;\n    }\n\n    /**\n     * Add a custom header.\n     * $name value can be overloaded to contain\n     * both header name and value (name:value).\n     *\n     * @param string      $name  Custom header name\n     * @param string|null $value Header value\n     *\n     * @throws Exception\n     */\n    public function addCustomHeader($name, $value = null)\n    {\n        if (null === $value && strpos($name, ':') !== false) {\n            //Value passed in as name:value\n            list($name, $value) = explode(':', $name, 2);\n        }\n        $name = trim($name);\n        $value = trim($value);\n        //Ensure name is not empty, and that neither name nor value contain line breaks\n        if (empty($name) || strpbrk($name . $value, \"\\r\\n\") !== false) {\n            if ($this->exceptions) {\n                throw new Exception('Invalid header name or value');\n            }\n\n            return false;\n        }\n        $this->CustomHeader[] = [$name, $value];\n\n        return true;\n    }\n\n    /**\n     * Returns all custom headers.\n     *\n     * @return array\n     */\n    public function getCustomHeaders()\n    {\n        return $this->CustomHeader;\n    }\n\n    /**\n     * Create a message body from an HTML string.\n     * Automatically inlines images and creates a plain-text version by converting the HTML,\n     * overwriting any existing values in Body and AltBody.\n     * Do not source $message content from user input!\n     * $basedir is prepended when handling relative URLs, e.g. <img src=\"/images/a.png\"> and must not be empty\n     * will look for an image file in $basedir/images/a.png and convert it to inline.\n     * If you don't provide a $basedir, relative paths will be left untouched (and thus probably break in email)\n     * Converts data-uri images into embedded attachments.\n     * If you don't want to apply these transformations to your HTML, just set Body and AltBody directly.\n     *\n     * @param string        $message  HTML message string\n     * @param string        $basedir  Absolute path to a base directory to prepend to relative paths to images\n     * @param bool|callable $advanced Whether to use the internal HTML to text converter\n     *                                or your own custom converter\n     * @return string The transformed message body\n     *\n     * @throws Exception\n     *\n     * @see PHPMailer::html2text()\n     */\n    public function msgHTML($message, $basedir = '', $advanced = false)\n    {\n        preg_match_all('/(?<!-)(src|background)=[\"\\'](.*)[\"\\']/Ui', $message, $images);\n        if (array_key_exists(2, $images)) {\n            if (strlen($basedir) > 1 && '/' !== substr($basedir, -1)) {\n                //Ensure $basedir has a trailing /\n                $basedir .= '/';\n            }\n            foreach ($images[2] as $imgindex => $url) {\n                //Convert data URIs into embedded images\n                //e.g. \"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\"\n                $match = [];\n                if (preg_match('#^data:(image/(?:jpe?g|gif|png));?(base64)?,(.+)#', $url, $match)) {\n                    if (count($match) === 4 && static::ENCODING_BASE64 === $match[2]) {\n                        $data = base64_decode($match[3]);\n                    } elseif ('' === $match[2]) {\n                        $data = rawurldecode($match[3]);\n                    } else {\n                        //Not recognised so leave it alone\n                        continue;\n                    }\n                    //Hash the decoded data, not the URL, so that the same data-URI image used in multiple places\n                    //will only be embedded once, even if it used a different encoding\n                    $cid = substr(hash('sha256', $data), 0, 32) . '@phpmailer.0'; //RFC2392 S 2\n\n                    if (!$this->cidExists($cid)) {\n                        $this->addStringEmbeddedImage(\n                            $data,\n                            $cid,\n                            'embed' . $imgindex,\n                            static::ENCODING_BASE64,\n                            $match[1]\n                        );\n                    }\n                    $message = str_replace(\n                        $images[0][$imgindex],\n                        $images[1][$imgindex] . '=\"cid:' . $cid . '\"',\n                        $message\n                    );\n                    continue;\n                }\n                if (\n                    //Only process relative URLs if a basedir is provided (i.e. no absolute local paths)\n                    !empty($basedir)\n                    //Ignore URLs containing parent dir traversal (..)\n                    && (strpos($url, '..') === false)\n                    //Do not change urls that are already inline images\n                    && 0 !== strpos($url, 'cid:')\n                    //Do not change absolute URLs, including anonymous protocol\n                    && !preg_match('#^[a-z][a-z0-9+.-]*:?//#i', $url)\n                ) {\n                    $filename = static::mb_pathinfo($url, PATHINFO_BASENAME);\n                    $directory = dirname($url);\n                    if ('.' === $directory) {\n                        $directory = '';\n                    }\n                    //RFC2392 S 2\n                    $cid = substr(hash('sha256', $url), 0, 32) . '@phpmailer.0';\n                    if (strlen($basedir) > 1 && '/' !== substr($basedir, -1)) {\n                        $basedir .= '/';\n                    }\n                    if (strlen($directory) > 1 && '/' !== substr($directory, -1)) {\n                        $directory .= '/';\n                    }\n                    if (\n                        $this->addEmbeddedImage(\n                            $basedir . $directory . $filename,\n                            $cid,\n                            $filename,\n                            static::ENCODING_BASE64,\n                            static::_mime_types((string) static::mb_pathinfo($filename, PATHINFO_EXTENSION))\n                        )\n                    ) {\n                        $message = preg_replace(\n                            '/' . $images[1][$imgindex] . '=[\"\\']' . preg_quote($url, '/') . '[\"\\']/Ui',\n                            $images[1][$imgindex] . '=\"cid:' . $cid . '\"',\n                            $message\n                        );\n                    }\n                }\n            }\n        }\n        $this->isHTML();\n        //Convert all message body line breaks to LE, makes quoted-printable encoding work much better\n        $this->Body = static::normalizeBreaks($message);\n        $this->AltBody = static::normalizeBreaks($this->html2text($message, $advanced));\n        if (!$this->alternativeExists()) {\n            $this->AltBody = 'This is an HTML-only message. To view it, activate HTML in your email application.'\n                . static::$LE;\n        }\n\n        return $this->Body;\n    }\n\n    /**\n     * Convert an HTML string into plain text.\n     * This is used by msgHTML().\n     * Note - older versions of this function used a bundled advanced converter\n     * which was removed for license reasons in #232.\n     * Example usage:\n     *\n     * ```php\n     * //Use default conversion\n     * $plain = $mail->html2text($html);\n     * //Use your own custom converter\n     * $plain = $mail->html2text($html, function($html) {\n     *     $converter = new MyHtml2text($html);\n     *     return $converter->get_text();\n     * });\n     * ```\n     *\n     * @param string        $html     The HTML text to convert\n     * @param bool|callable $advanced Any boolean value to use the internal converter,\n     *                                or provide your own callable for custom conversion\n     *\n     * @return string\n     */\n    public function html2text($html, $advanced = false)\n    {\n        if (is_callable($advanced)) {\n            return call_user_func($advanced, $html);\n        }\n\n        return html_entity_decode(\n            trim(strip_tags(preg_replace('/<(head|title|style|script)[^>]*>.*?<\\/\\\\1>/si', '', $html))),\n            ENT_QUOTES,\n            $this->CharSet\n        );\n    }\n\n    /**\n     * Get the MIME type for a file extension.\n     *\n     * @param string $ext File extension\n     *\n     * @return string MIME type of file\n     */\n    public static function _mime_types($ext = '')\n    {\n        $mimes = [\n            'xl' => 'application/excel',\n            'js' => 'application/javascript',\n            'hqx' => 'application/mac-binhex40',\n            'cpt' => 'application/mac-compactpro',\n            'bin' => 'application/macbinary',\n            'doc' => 'application/msword',\n            'word' => 'application/msword',\n            'xlsx' => 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',\n            'xltx' => 'application/vnd.openxmlformats-officedocument.spreadsheetml.template',\n            'potx' => 'application/vnd.openxmlformats-officedocument.presentationml.template',\n            'ppsx' => 'application/vnd.openxmlformats-officedocument.presentationml.slideshow',\n            'pptx' => 'application/vnd.openxmlformats-officedocument.presentationml.presentation',\n            'sldx' => 'application/vnd.openxmlformats-officedocument.presentationml.slide',\n            'docx' => 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',\n            'dotx' => 'application/vnd.openxmlformats-officedocument.wordprocessingml.template',\n            'xlam' => 'application/vnd.ms-excel.addin.macroEnabled.12',\n            'xlsb' => 'application/vnd.ms-excel.sheet.binary.macroEnabled.12',\n            'class' => 'application/octet-stream',\n            'dll' => 'application/octet-stream',\n            'dms' => 'application/octet-stream',\n            'exe' => 'application/octet-stream',\n            'lha' => 'application/octet-stream',\n            'lzh' => 'application/octet-stream',\n            'psd' => 'application/octet-stream',\n            'sea' => 'application/octet-stream',\n            'so' => 'application/octet-stream',\n            'oda' => 'application/oda',\n            'pdf' => 'application/pdf',\n            'ai' => 'application/postscript',\n            'eps' => 'application/postscript',\n            'ps' => 'application/postscript',\n            'smi' => 'application/smil',\n            'smil' => 'application/smil',\n            'mif' => 'application/vnd.mif',\n            'xls' => 'application/vnd.ms-excel',\n            'ppt' => 'application/vnd.ms-powerpoint',\n            'wbxml' => 'application/vnd.wap.wbxml',\n            'wmlc' => 'application/vnd.wap.wmlc',\n            'dcr' => 'application/x-director',\n            'dir' => 'application/x-director',\n            'dxr' => 'application/x-director',\n            'dvi' => 'application/x-dvi',\n            'gtar' => 'application/x-gtar',\n            'php3' => 'application/x-httpd-php',\n            'php4' => 'application/x-httpd-php',\n            'php' => 'application/x-httpd-php',\n            'phtml' => 'application/x-httpd-php',\n            'phps' => 'application/x-httpd-php-source',\n            'swf' => 'application/x-shockwave-flash',\n            'sit' => 'application/x-stuffit',\n            'tar' => 'application/x-tar',\n            'tgz' => 'application/x-tar',\n            'xht' => 'application/xhtml+xml',\n            'xhtml' => 'application/xhtml+xml',\n            'zip' => 'application/zip',\n            'mid' => 'audio/midi',\n            'midi' => 'audio/midi',\n            'mp2' => 'audio/mpeg',\n            'mp3' => 'audio/mpeg',\n            'm4a' => 'audio/mp4',\n            'mpga' => 'audio/mpeg',\n            'aif' => 'audio/x-aiff',\n            'aifc' => 'audio/x-aiff',\n            'aiff' => 'audio/x-aiff',\n            'ram' => 'audio/x-pn-realaudio',\n            'rm' => 'audio/x-pn-realaudio',\n            'rpm' => 'audio/x-pn-realaudio-plugin',\n            'ra' => 'audio/x-realaudio',\n            'wav' => 'audio/x-wav',\n            'mka' => 'audio/x-matroska',\n            'bmp' => 'image/bmp',\n            'gif' => 'image/gif',\n            'jpeg' => 'image/jpeg',\n            'jpe' => 'image/jpeg',\n            'jpg' => 'image/jpeg',\n            'png' => 'image/png',\n            'tiff' => 'image/tiff',\n            'tif' => 'image/tiff',\n            'webp' => 'image/webp',\n            'avif' => 'image/avif',\n            'heif' => 'image/heif',\n            'heifs' => 'image/heif-sequence',\n            'heic' => 'image/heic',\n            'heics' => 'image/heic-sequence',\n            'eml' => 'message/rfc822',\n            'css' => 'text/css',\n            'html' => 'text/html',\n            'htm' => 'text/html',\n            'shtml' => 'text/html',\n            'log' => 'text/plain',\n            'text' => 'text/plain',\n            'txt' => 'text/plain',\n            'rtx' => 'text/richtext',\n            'rtf' => 'text/rtf',\n            'vcf' => 'text/vcard',\n            'vcard' => 'text/vcard',\n            'ics' => 'text/calendar',\n            'xml' => 'text/xml',\n            'xsl' => 'text/xml',\n            'wmv' => 'video/x-ms-wmv',\n            'mpeg' => 'video/mpeg',\n            'mpe' => 'video/mpeg',\n            'mpg' => 'video/mpeg',\n            'mp4' => 'video/mp4',\n            'm4v' => 'video/mp4',\n            'mov' => 'video/quicktime',\n            'qt' => 'video/quicktime',\n            'rv' => 'video/vnd.rn-realvideo',\n            'avi' => 'video/x-msvideo',\n            'movie' => 'video/x-sgi-movie',\n            'webm' => 'video/webm',\n            'mkv' => 'video/x-matroska',\n        ];\n        $ext = strtolower($ext);\n        if (array_key_exists($ext, $mimes)) {\n            return $mimes[$ext];\n        }\n\n        return 'application/octet-stream';\n    }\n\n    /**\n     * Map a file name to a MIME type.\n     * Defaults to 'application/octet-stream', i.e.. arbitrary binary data.\n     *\n     * @param string $filename A file name or full path, does not need to exist as a file\n     *\n     * @return string\n     */\n    public static function filenameToType($filename)\n    {\n        //In case the path is a URL, strip any query string before getting extension\n        $qpos = strpos($filename, '?');\n        if (false !== $qpos) {\n            $filename = substr($filename, 0, $qpos);\n        }\n        $ext = static::mb_pathinfo($filename, PATHINFO_EXTENSION);\n\n        return static::_mime_types($ext);\n    }\n\n    /**\n     * Multi-byte-safe pathinfo replacement.\n     * Drop-in replacement for pathinfo(), but multibyte- and cross-platform-safe.\n     *\n     * @see http://www.php.net/manual/en/function.pathinfo.php#107461\n     *\n     * @param string     $path    A filename or path, does not need to exist as a file\n     * @param int|string $options Either a PATHINFO_* constant,\n     *                            or a string name to return only the specified piece\n     *\n     * @return string|array\n     */\n    public static function mb_pathinfo($path, $options = null)\n    {\n        $ret = ['dirname' => '', 'basename' => '', 'extension' => '', 'filename' => ''];\n        $pathinfo = [];\n        if (preg_match('#^(.*?)[\\\\\\\\/]*(([^/\\\\\\\\]*?)(\\.([^.\\\\\\\\/]+?)|))[\\\\\\\\/.]*$#m', $path, $pathinfo)) {\n            if (array_key_exists(1, $pathinfo)) {\n                $ret['dirname'] = $pathinfo[1];\n            }\n            if (array_key_exists(2, $pathinfo)) {\n                $ret['basename'] = $pathinfo[2];\n            }\n            if (array_key_exists(5, $pathinfo)) {\n                $ret['extension'] = $pathinfo[5];\n            }\n            if (array_key_exists(3, $pathinfo)) {\n                $ret['filename'] = $pathinfo[3];\n            }\n        }\n        switch ($options) {\n            case PATHINFO_DIRNAME:\n            case 'dirname':\n                return $ret['dirname'];\n            case PATHINFO_BASENAME:\n            case 'basename':\n                return $ret['basename'];\n            case PATHINFO_EXTENSION:\n            case 'extension':\n                return $ret['extension'];\n            case PATHINFO_FILENAME:\n            case 'filename':\n                return $ret['filename'];\n            default:\n                return $ret;\n        }\n    }\n\n    /**\n     * Set or reset instance properties.\n     * You should avoid this function - it's more verbose, less efficient, more error-prone and\n     * harder to debug than setting properties directly.\n     * Usage Example:\n     * `$mail->set('SMTPSecure', static::ENCRYPTION_STARTTLS);`\n     *   is the same as:\n     * `$mail->SMTPSecure = static::ENCRYPTION_STARTTLS;`.\n     *\n     * @param string $name  The property name to set\n     * @param mixed  $value The value to set the property to\n     *\n     * @return bool\n     */\n    public function set($name, $value = '')\n    {\n        if (property_exists($this, $name)) {\n            $this->$name = $value;\n\n            return true;\n        }\n        $this->setError($this->lang('variable_set') . $name);\n\n        return false;\n    }\n\n    /**\n     * Strip newlines to prevent header injection.\n     *\n     * @param string $str\n     *\n     * @return string\n     */\n    public function secureHeader($str)\n    {\n        return trim(str_replace([\"\\r\", \"\\n\"], '', $str));\n    }\n\n    /**\n     * Normalize line breaks in a string.\n     * Converts UNIX LF, Mac CR and Windows CRLF line breaks into a single line break format.\n     * Defaults to CRLF (for message bodies) and preserves consecutive breaks.\n     *\n     * @param string $text\n     * @param string $breaktype What kind of line break to use; defaults to static::$LE\n     *\n     * @return string\n     */\n    public static function normalizeBreaks($text, $breaktype = null)\n    {\n        if (null === $breaktype) {\n            $breaktype = static::$LE;\n        }\n        //Normalise to \\n\n        $text = str_replace([self::CRLF, \"\\r\"], \"\\n\", $text);\n        //Now convert LE as needed\n        if (\"\\n\" !== $breaktype) {\n            $text = str_replace(\"\\n\", $breaktype, $text);\n        }\n\n        return $text;\n    }\n\n    /**\n     * Remove trailing breaks from a string.\n     *\n     * @param string $text\n     *\n     * @return string The text to remove breaks from\n     */\n    public static function stripTrailingWSP($text)\n    {\n        return rtrim($text, \" \\r\\n\\t\");\n    }\n\n    /**\n     * Return the current line break format string.\n     *\n     * @return string\n     */\n    public static function getLE()\n    {\n        return static::$LE;\n    }\n\n    /**\n     * Set the line break format string, e.g. \"\\r\\n\".\n     *\n     * @param string $le\n     */\n    protected static function setLE($le)\n    {\n        static::$LE = $le;\n    }\n\n    /**\n     * Set the public and private key files and password for S/MIME signing.\n     *\n     * @param string $cert_filename\n     * @param string $key_filename\n     * @param string $key_pass            Password for private key\n     * @param string $extracerts_filename Optional path to chain certificate\n     */\n    public function sign($cert_filename, $key_filename, $key_pass, $extracerts_filename = '')\n    {\n        $this->sign_cert_file = $cert_filename;\n        $this->sign_key_file = $key_filename;\n        $this->sign_key_pass = $key_pass;\n        $this->sign_extracerts_file = $extracerts_filename;\n    }\n\n    /**\n     * Quoted-Printable-encode a DKIM header.\n     *\n     * @param string $txt\n     *\n     * @return string\n     */\n    public function DKIM_QP($txt)\n    {\n        $line = '';\n        $len = strlen($txt);\n        for ($i = 0; $i < $len; ++$i) {\n            $ord = ord($txt[$i]);\n            if (((0x21 <= $ord) && ($ord <= 0x3A)) || $ord === 0x3C || ((0x3E <= $ord) && ($ord <= 0x7E))) {\n                $line .= $txt[$i];\n            } else {\n                $line .= '=' . sprintf('%02X', $ord);\n            }\n        }\n\n        return $line;\n    }\n\n    /**\n     * Generate a DKIM signature.\n     *\n     * @param string $signHeader\n     *\n     * @throws Exception\n     *\n     * @return string The DKIM signature value\n     */\n    public function DKIM_Sign($signHeader)\n    {\n        if (!defined('PKCS7_TEXT')) {\n            if ($this->exceptions) {\n                throw new Exception($this->lang('extension_missing') . 'openssl');\n            }\n\n            return '';\n        }\n        $privKeyStr = !empty($this->DKIM_private_string) ?\n            $this->DKIM_private_string :\n            file_get_contents($this->DKIM_private);\n        if ('' !== $this->DKIM_passphrase) {\n            $privKey = openssl_pkey_get_private($privKeyStr, $this->DKIM_passphrase);\n        } else {\n            $privKey = openssl_pkey_get_private($privKeyStr);\n        }\n        if (openssl_sign($signHeader, $signature, $privKey, 'sha256WithRSAEncryption')) {\n            if (\\PHP_MAJOR_VERSION < 8) {\n                openssl_pkey_free($privKey);\n            }\n\n            return base64_encode($signature);\n        }\n        if (\\PHP_MAJOR_VERSION < 8) {\n            openssl_pkey_free($privKey);\n        }\n\n        return '';\n    }\n\n    /**\n     * Generate a DKIM canonicalization header.\n     * Uses the 'relaxed' algorithm from RFC6376 section 3.4.2.\n     * Canonicalized headers should *always* use CRLF, regardless of mailer setting.\n     *\n     * @see https://tools.ietf.org/html/rfc6376#section-3.4.2\n     *\n     * @param string $signHeader Header\n     *\n     * @return string\n     */\n    public function DKIM_HeaderC($signHeader)\n    {\n        //Normalize breaks to CRLF (regardless of the mailer)\n        $signHeader = static::normalizeBreaks($signHeader, self::CRLF);\n        //Unfold header lines\n        //Note PCRE \\s is too broad a definition of whitespace; RFC5322 defines it as `[ \\t]`\n        //@see https://tools.ietf.org/html/rfc5322#section-2.2\n        //That means this may break if you do something daft like put vertical tabs in your headers.\n        $signHeader = preg_replace('/\\r\\n[ \\t]+/', ' ', $signHeader);\n        //Break headers out into an array\n        $lines = explode(self::CRLF, $signHeader);\n        foreach ($lines as $key => $line) {\n            //If the header is missing a :, skip it as it's invalid\n            //This is likely to happen because the explode() above will also split\n            //on the trailing LE, leaving an empty line\n            if (strpos($line, ':') === false) {\n                continue;\n            }\n            list($heading, $value) = explode(':', $line, 2);\n            //Lower-case header name\n            $heading = strtolower($heading);\n            //Collapse white space within the value, also convert WSP to space\n            $value = preg_replace('/[ \\t]+/', ' ', $value);\n            //RFC6376 is slightly unclear here - it says to delete space at the *end* of each value\n            //But then says to delete space before and after the colon.\n            //Net result is the same as trimming both ends of the value.\n            //By elimination, the same applies to the field name\n            $lines[$key] = trim($heading, \" \\t\") . ':' . trim($value, \" \\t\");\n        }\n\n        return implode(self::CRLF, $lines);\n    }\n\n    /**\n     * Generate a DKIM canonicalization body.\n     * Uses the 'simple' algorithm from RFC6376 section 3.4.3.\n     * Canonicalized bodies should *always* use CRLF, regardless of mailer setting.\n     *\n     * @see https://tools.ietf.org/html/rfc6376#section-3.4.3\n     *\n     * @param string $body Message Body\n     *\n     * @return string\n     */\n    public function DKIM_BodyC($body)\n    {\n        if (empty($body)) {\n            return self::CRLF;\n        }\n        //Normalize line endings to CRLF\n        $body = static::normalizeBreaks($body, self::CRLF);\n\n        //Reduce multiple trailing line breaks to a single one\n        return static::stripTrailingWSP($body) . self::CRLF;\n    }\n\n    /**\n     * Create the DKIM header and body in a new message header.\n     *\n     * @param string $headers_line Header lines\n     * @param string $subject      Subject\n     * @param string $body         Body\n     *\n     * @throws Exception\n     *\n     * @return string\n     */\n    public function DKIM_Add($headers_line, $subject, $body)\n    {\n        $DKIMsignatureType = 'rsa-sha256'; //Signature & hash algorithms\n        $DKIMcanonicalization = 'relaxed/simple'; //Canonicalization methods of header & body\n        $DKIMquery = 'dns/txt'; //Query method\n        $DKIMtime = time();\n        //Always sign these headers without being asked\n        //Recommended list from https://tools.ietf.org/html/rfc6376#section-5.4.1\n        $autoSignHeaders = [\n            'from',\n            'to',\n            'cc',\n            'date',\n            'subject',\n            'reply-to',\n            'message-id',\n            'content-type',\n            'mime-version',\n            'x-mailer',\n        ];\n        if (stripos($headers_line, 'Subject') === false) {\n            $headers_line .= 'Subject: ' . $subject . static::$LE;\n        }\n        $headerLines = explode(static::$LE, $headers_line);\n        $currentHeaderLabel = '';\n        $currentHeaderValue = '';\n        $parsedHeaders = [];\n        $headerLineIndex = 0;\n        $headerLineCount = count($headerLines);\n        foreach ($headerLines as $headerLine) {\n            $matches = [];\n            if (preg_match('/^([^ \\t]*?)(?::[ \\t]*)(.*)$/', $headerLine, $matches)) {\n                if ($currentHeaderLabel !== '') {\n                    //We were previously in another header; This is the start of a new header, so save the previous one\n                    $parsedHeaders[] = ['label' => $currentHeaderLabel, 'value' => $currentHeaderValue];\n                }\n                $currentHeaderLabel = $matches[1];\n                $currentHeaderValue = $matches[2];\n            } elseif (preg_match('/^[ \\t]+(.*)$/', $headerLine, $matches)) {\n                //This is a folded continuation of the current header, so unfold it\n                $currentHeaderValue .= ' ' . $matches[1];\n            }\n            ++$headerLineIndex;\n            if ($headerLineIndex >= $headerLineCount) {\n                //This was the last line, so finish off this header\n                $parsedHeaders[] = ['label' => $currentHeaderLabel, 'value' => $currentHeaderValue];\n            }\n        }\n        $copiedHeaders = [];\n        $headersToSignKeys = [];\n        $headersToSign = [];\n        foreach ($parsedHeaders as $header) {\n            //Is this header one that must be included in the DKIM signature?\n            if (in_array(strtolower($header['label']), $autoSignHeaders, true)) {\n                $headersToSignKeys[] = $header['label'];\n                $headersToSign[] = $header['label'] . ': ' . $header['value'];\n                if ($this->DKIM_copyHeaderFields) {\n                    $copiedHeaders[] = $header['label'] . ':' . //Note no space after this, as per RFC\n                        str_replace('|', '=7C', $this->DKIM_QP($header['value']));\n                }\n                continue;\n            }\n            //Is this an extra custom header we've been asked to sign?\n            if (in_array($header['label'], $this->DKIM_extraHeaders, true)) {\n                //Find its value in custom headers\n                foreach ($this->CustomHeader as $customHeader) {\n                    if ($customHeader[0] === $header['label']) {\n                        $headersToSignKeys[] = $header['label'];\n                        $headersToSign[] = $header['label'] . ': ' . $header['value'];\n                        if ($this->DKIM_copyHeaderFields) {\n                            $copiedHeaders[] = $header['label'] . ':' . //Note no space after this, as per RFC\n                                str_replace('|', '=7C', $this->DKIM_QP($header['value']));\n                        }\n                        //Skip straight to the next header\n                        continue 2;\n                    }\n                }\n            }\n        }\n        $copiedHeaderFields = '';\n        if ($this->DKIM_copyHeaderFields && count($copiedHeaders) > 0) {\n            //Assemble a DKIM 'z' tag\n            $copiedHeaderFields = ' z=';\n            $first = true;\n            foreach ($copiedHeaders as $copiedHeader) {\n                if (!$first) {\n                    $copiedHeaderFields .= static::$LE . ' |';\n                }\n                //Fold long values\n                if (strlen($copiedHeader) > self::STD_LINE_LENGTH - 3) {\n                    $copiedHeaderFields .= substr(\n                        chunk_split($copiedHeader, self::STD_LINE_LENGTH - 3, static::$LE . self::FWS),\n                        0,\n                        -strlen(static::$LE . self::FWS)\n                    );\n                } else {\n                    $copiedHeaderFields .= $copiedHeader;\n                }\n                $first = false;\n            }\n            $copiedHeaderFields .= ';' . static::$LE;\n        }\n        $headerKeys = ' h=' . implode(':', $headersToSignKeys) . ';' . static::$LE;\n        $headerValues = implode(static::$LE, $headersToSign);\n        $body = $this->DKIM_BodyC($body);\n        //Base64 of packed binary SHA-256 hash of body\n        $DKIMb64 = base64_encode(pack('H*', hash('sha256', $body)));\n        $ident = '';\n        if ('' !== $this->DKIM_identity) {\n            $ident = ' i=' . $this->DKIM_identity . ';' . static::$LE;\n        }\n        //The DKIM-Signature header is included in the signature *except for* the value of the `b` tag\n        //which is appended after calculating the signature\n        //https://tools.ietf.org/html/rfc6376#section-3.5\n        $dkimSignatureHeader = 'DKIM-Signature: v=1;' .\n            ' d=' . $this->DKIM_domain . ';' .\n            ' s=' . $this->DKIM_selector . ';' . static::$LE .\n            ' a=' . $DKIMsignatureType . ';' .\n            ' q=' . $DKIMquery . ';' .\n            ' t=' . $DKIMtime . ';' .\n            ' c=' . $DKIMcanonicalization . ';' . static::$LE .\n            $headerKeys .\n            $ident .\n            $copiedHeaderFields .\n            ' bh=' . $DKIMb64 . ';' . static::$LE .\n            ' b=';\n        //Canonicalize the set of headers\n        $canonicalizedHeaders = $this->DKIM_HeaderC(\n            $headerValues . static::$LE . $dkimSignatureHeader\n        );\n        $signature = $this->DKIM_Sign($canonicalizedHeaders);\n        $signature = trim(chunk_split($signature, self::STD_LINE_LENGTH - 3, static::$LE . self::FWS));\n\n        return static::normalizeBreaks($dkimSignatureHeader . $signature);\n    }\n\n    /**\n     * Detect if a string contains a line longer than the maximum line length\n     * allowed by RFC 2822 section 2.1.1.\n     *\n     * @param string $str\n     *\n     * @return bool\n     */\n    public static function hasLineLongerThanMax($str)\n    {\n        return (bool) preg_match('/^(.{' . (self::MAX_LINE_LENGTH + strlen(static::$LE)) . ',})/m', $str);\n    }\n\n    /**\n     * If a string contains any \"special\" characters, double-quote the name,\n     * and escape any double quotes with a backslash.\n     *\n     * @param string $str\n     *\n     * @return string\n     *\n     * @see RFC822 3.4.1\n     */\n    public static function quotedString($str)\n    {\n        if (preg_match('/[ ()<>@,;:\"\\/\\[\\]?=]/', $str)) {\n            //If the string contains any of these chars, it must be double-quoted\n            //and any double quotes must be escaped with a backslash\n            return '\"' . str_replace('\"', '\\\\\"', $str) . '\"';\n        }\n\n        //Return the string untouched, it doesn't need quoting\n        return $str;\n    }\n\n    /**\n     * Allows for public read access to 'to' property.\n     * Before the send() call, queued addresses (i.e. with IDN) are not yet included.\n     *\n     * @return array\n     */\n    public function getToAddresses()\n    {\n        return $this->to;\n    }\n\n    /**\n     * Allows for public read access to 'cc' property.\n     * Before the send() call, queued addresses (i.e. with IDN) are not yet included.\n     *\n     * @return array\n     */\n    public function getCcAddresses()\n    {\n        return $this->cc;\n    }\n\n    /**\n     * Allows for public read access to 'bcc' property.\n     * Before the send() call, queued addresses (i.e. with IDN) are not yet included.\n     *\n     * @return array\n     */\n    public function getBccAddresses()\n    {\n        return $this->bcc;\n    }\n\n    /**\n     * Allows for public read access to 'ReplyTo' property.\n     * Before the send() call, queued addresses (i.e. with IDN) are not yet included.\n     *\n     * @return array\n     */\n    public function getReplyToAddresses()\n    {\n        return $this->ReplyTo;\n    }\n\n    /**\n     * Allows for public read access to 'all_recipients' property.\n     * Before the send() call, queued addresses (i.e. with IDN) are not yet included.\n     *\n     * @return array\n     */\n    public function getAllRecipientAddresses()\n    {\n        return $this->all_recipients;\n    }\n\n    /**\n     * Perform a callback.\n     *\n     * @param bool   $isSent\n     * @param array  $to\n     * @param array  $cc\n     * @param array  $bcc\n     * @param string $subject\n     * @param string $body\n     * @param string $from\n     * @param array  $extra\n     */\n    protected function doCallback($isSent, $to, $cc, $bcc, $subject, $body, $from, $extra)\n    {\n        if (!empty($this->action_function) && is_callable($this->action_function)) {\n            call_user_func($this->action_function, $isSent, $to, $cc, $bcc, $subject, $body, $from, $extra);\n        }\n    }\n\n    /**\n     * Get the OAuth instance.\n     *\n     * @return OAuth\n     */\n    public function getOAuth()\n    {\n        return $this->oauth;\n    }\n\n    /**\n     * Set an OAuth instance.\n     */\n    public function setOAuth(OAuth $oauth)\n    {\n        $this->oauth = $oauth;\n    }\n}\n", "<?php\n\n/**\n * PHPMailer - PHP email transport unit tests.\n * PHP version 5.5.\n *\n * @author    Marcus Bointon <phpmailer@synchromedia.co.uk>\n * @author    Andy Prevost\n * @copyright 2012 - 2020 Marcus Bointon\n * @copyright 2004 - 2009 Andy Prevost\n * @license   http://www.gnu.org/copyleft/lesser.html GNU Lesser General Public License\n */\n\nnamespace PHPMailer\\Test;\n\nuse PHPMailer\\PHPMailer\\Exception;\nuse PHPMailer\\PHPMailer\\OAuth;\nuse PHPMailer\\PHPMailer\\PHPMailer;\nuse PHPMailer\\PHPMailer\\POP3;\nuse PHPMailer\\PHPMailer\\SMTP;\nuse Yoast\\PHPUnitPolyfills\\TestCases\\TestCase;\n\nrequire_once __DIR__ . '/validators.php';\n\n/**\n * PHPMailer - PHP email transport unit test class.\n */\nfinal class PHPMailerTest extends TestCase\n{\n    /**\n     * Holds the PHPMailer instance.\n     *\n     * @var PHPMailer\n     */\n    private $Mail;\n\n    /**\n     * Holds the SMTP mail host.\n     *\n     * @var string\n     */\n    private $Host = '';\n\n    /**\n     * Holds the change log.\n     *\n     * @var string[]\n     */\n    private $ChangeLog = [];\n\n    /**\n     * Holds the note log.\n     *\n     * @var string[]\n     */\n    private $NoteLog = [];\n\n    /**\n     * Default include path.\n     *\n     * @var string\n     */\n    private $INCLUDE_DIR = '..';\n\n    /**\n     * PIDs of any processes we need to kill.\n     *\n     * @var array\n     */\n    private $pids = [];\n\n    /**\n     * Run before each test is started.\n     */\n    protected function set_up()\n    {\n        $this->INCLUDE_DIR = dirname(__DIR__); //Default to the dir above the test dir, i.e. the project home dir\n        if (file_exists($this->INCLUDE_DIR . '/test/testbootstrap.php')) {\n            include $this->INCLUDE_DIR . '/test/testbootstrap.php'; //Overrides go in here\n        }\n        $this->Mail = new PHPMailer();\n        $this->Mail->SMTPDebug = SMTP::DEBUG_CONNECTION; //Full debug output\n        $this->Mail->Debugoutput = ['PHPMailer\\Test\\DebugLogTestListener', 'debugLog'];\n        $this->Mail->Priority = 3;\n        $this->Mail->Encoding = '8bit';\n        $this->Mail->CharSet = PHPMailer::CHARSET_ISO88591;\n        if (array_key_exists('mail_from', $_REQUEST)) {\n            $this->Mail->From = $_REQUEST['mail_from'];\n        } else {\n            $this->Mail->From = 'unit_test@phpmailer.example.com';\n        }\n        $this->Mail->FromName = 'Unit Tester';\n        $this->Mail->Sender = '';\n        $this->Mail->Subject = 'Unit Test';\n        $this->Mail->Body = '';\n        $this->Mail->AltBody = '';\n        $this->Mail->WordWrap = 0;\n        if (array_key_exists('mail_host', $_REQUEST)) {\n            $this->Mail->Host = $_REQUEST['mail_host'];\n        } else {\n            $this->Mail->Host = 'mail.example.com';\n        }\n        if (array_key_exists('mail_port', $_REQUEST)) {\n            $this->Mail->Port = $_REQUEST['mail_port'];\n        } else {\n            $this->Mail->Port = 25;\n        }\n        $this->Mail->Helo = 'localhost.localdomain';\n        $this->Mail->SMTPAuth = false;\n        $this->Mail->Username = '';\n        $this->Mail->Password = '';\n        if (array_key_exists('mail_useauth', $_REQUEST)) {\n            $this->Mail->SMTPAuth = $_REQUEST['mail_useauth'];\n        }\n        if (array_key_exists('mail_username', $_REQUEST)) {\n            $this->Mail->Username = $_REQUEST['mail_username'];\n        }\n        if (array_key_exists('mail_userpass', $_REQUEST)) {\n            $this->Mail->Password = $_REQUEST['mail_userpass'];\n        }\n        $this->Mail->addReplyTo('no_reply@phpmailer.example.com', 'Reply Guy');\n        $this->Mail->Sender = 'unit_test@phpmailer.example.com';\n        if ($this->Mail->Host != '') {\n            $this->Mail->isSMTP();\n        } else {\n            $this->Mail->isMail();\n        }\n        if (array_key_exists('mail_to', $_REQUEST)) {\n            $this->setAddress($_REQUEST['mail_to'], 'Test User', 'to');\n        }\n        if (array_key_exists('mail_cc', $_REQUEST) && $_REQUEST['mail_cc'] !== '') {\n            $this->setAddress($_REQUEST['mail_cc'], 'Carbon User', 'cc');\n        }\n    }\n\n    /**\n     * Run after each test is completed.\n     */\n    protected function tear_down()\n    {\n        //Clean global variables\n        $this->Mail = null;\n        $this->ChangeLog = [];\n        $this->NoteLog = [];\n\n        foreach ($this->pids as $pid) {\n            $p = escapeshellarg($pid);\n            shell_exec(\"ps $p && kill -TERM $p\");\n        }\n    }\n\n    /**\n     * Build the body of the message in the appropriate format.\n     */\n    private function buildBody()\n    {\n        $this->checkChanges();\n\n        //Determine line endings for message\n        if ('text/html' === $this->Mail->ContentType || $this->Mail->AltBody !== '') {\n            $eol = \"<br>\\r\\n\";\n            $bullet_start = '<li>';\n            $bullet_end = \"</li>\\r\\n\";\n            $list_start = \"<ul>\\r\\n\";\n            $list_end = \"</ul>\\r\\n\";\n        } else {\n            $eol = \"\\r\\n\";\n            $bullet_start = ' - ';\n            $bullet_end = \"\\r\\n\";\n            $list_start = '';\n            $list_end = '';\n        }\n\n        $ReportBody = '';\n\n        $ReportBody .= '---------------------' . $eol;\n        $ReportBody .= 'Unit Test Information' . $eol;\n        $ReportBody .= '---------------------' . $eol;\n        $ReportBody .= 'phpmailer version: ' . PHPMailer::VERSION . $eol;\n        $ReportBody .= 'Content Type: ' . $this->Mail->ContentType . $eol;\n        $ReportBody .= 'CharSet: ' . $this->Mail->CharSet . $eol;\n\n        if ($this->Mail->Host !== '') {\n            $ReportBody .= 'Host: ' . $this->Mail->Host . $eol;\n        }\n\n        //If attachments then create an attachment list\n        $attachments = $this->Mail->getAttachments();\n        if (count($attachments) > 0) {\n            $ReportBody .= 'Attachments:' . $eol;\n            $ReportBody .= $list_start;\n            foreach ($attachments as $attachment) {\n                $ReportBody .= $bullet_start . 'Name: ' . $attachment[1] . ', ';\n                $ReportBody .= 'Encoding: ' . $attachment[3] . ', ';\n                $ReportBody .= 'Type: ' . $attachment[4] . $bullet_end;\n            }\n            $ReportBody .= $list_end . $eol;\n        }\n\n        //If there are changes then list them\n        if (count($this->ChangeLog) > 0) {\n            $ReportBody .= 'Changes' . $eol;\n            $ReportBody .= '-------' . $eol;\n\n            $ReportBody .= $list_start;\n            foreach ($this->ChangeLog as $iValue) {\n                $ReportBody .= $bullet_start . $iValue[0] . ' was changed to [' .\n                    $iValue[1] . ']' . $bullet_end;\n            }\n            $ReportBody .= $list_end . $eol . $eol;\n        }\n\n        //If there are notes then list them\n        if (count($this->NoteLog) > 0) {\n            $ReportBody .= 'Notes' . $eol;\n            $ReportBody .= '-----' . $eol;\n\n            $ReportBody .= $list_start;\n            foreach ($this->NoteLog as $iValue) {\n                $ReportBody .= $bullet_start . $iValue . $bullet_end;\n            }\n            $ReportBody .= $list_end;\n        }\n\n        //Re-attach the original body\n        $this->Mail->Body .= $eol . $ReportBody;\n    }\n\n    /**\n     * Check which default settings have been changed for the report.\n     */\n    private function checkChanges()\n    {\n        if (3 != $this->Mail->Priority) {\n            $this->addChange('Priority', $this->Mail->Priority);\n        }\n        if (PHPMailer::ENCODING_8BIT !== $this->Mail->Encoding) {\n            $this->addChange('Encoding', $this->Mail->Encoding);\n        }\n        if (PHPMailer::CHARSET_ISO88591 !== $this->Mail->CharSet) {\n            $this->addChange('CharSet', $this->Mail->CharSet);\n        }\n        if ('' != $this->Mail->Sender) {\n            $this->addChange('Sender', $this->Mail->Sender);\n        }\n        if (0 != $this->Mail->WordWrap) {\n            $this->addChange('WordWrap', $this->Mail->WordWrap);\n        }\n        if ('mail' !== $this->Mail->Mailer) {\n            $this->addChange('Mailer', $this->Mail->Mailer);\n        }\n        if (25 != $this->Mail->Port) {\n            $this->addChange('Port', $this->Mail->Port);\n        }\n        if ('localhost.localdomain' !== $this->Mail->Helo) {\n            $this->addChange('Helo', $this->Mail->Helo);\n        }\n        if ($this->Mail->SMTPAuth) {\n            $this->addChange('SMTPAuth', 'true');\n        }\n    }\n\n    /**\n     * Add a changelog entry.\n     *\n     * @param string $sName\n     * @param string $sNewValue\n     */\n    private function addChange($sName, $sNewValue)\n    {\n        $this->ChangeLog[] = [$sName, $sNewValue];\n    }\n\n    /**\n     * Adds a simple note to the message.\n     *\n     * @param string $sValue\n     */\n    private function addNote($sValue)\n    {\n        $this->NoteLog[] = $sValue;\n    }\n\n    /**\n     * Adds all of the addresses.\n     *\n     * @param string $sAddress\n     * @param string $sName\n     * @param string $sType\n     *\n     * @return bool\n     */\n    private function setAddress($sAddress, $sName = '', $sType = 'to')\n    {\n        switch ($sType) {\n            case 'to':\n                return $this->Mail->addAddress($sAddress, $sName);\n            case 'cc':\n                return $this->Mail->addCC($sAddress, $sName);\n            case 'bcc':\n                return $this->Mail->addBCC($sAddress, $sName);\n        }\n\n        return false;\n    }\n\n    /**\n     * Check that we have loaded default test params.\n     * Pretty much everything will fail due to unset recipient if this is not done.\n     */\n    public function testBootstrap()\n    {\n        self::assertFileExists(\n            $this->INCLUDE_DIR . '/test/testbootstrap.php',\n            'Test config params missing - copy testbootstrap.php to testbootstrap-dist.php and change as appropriate'\n        );\n    }\n\n    /**\n     * Test CRAM-MD5 authentication.\n     * Needs a connection to a server that supports this auth mechanism, so commented out by default.\n     */\n    public function testAuthCRAMMD5()\n    {\n        $this->markTestIncomplete(\n            'Test needs a connection to a server supporting the CRAMMD5 auth mechanism.'\n        );\n\n        $this->Mail->Host = 'hostname';\n        $this->Mail->Port = 587;\n        $this->Mail->SMTPAuth = true;\n        $this->Mail->SMTPSecure = PHPMailer::ENCRYPTION_STARTTLS;\n        $this->Mail->AuthType = 'CRAM-MD5';\n        $this->Mail->Username = 'username';\n        $this->Mail->Password = 'password';\n        $this->Mail->Body = 'Test body';\n        $this->Mail->Subject .= ': Auth CRAM-MD5';\n        $this->Mail->From = 'from@example.com';\n        $this->Mail->Sender = 'from@example.com';\n        $this->Mail->clearAllRecipients();\n        $this->Mail->addAddress('user@example.com');\n        //self::assertTrue($this->mail->send(), $this->mail->ErrorInfo);\n    }\n\n    /**\n     * Test email address validation.\n     * Test addresses obtained from http://isemail.info\n     * Some failing cases commented out that are apparently up for debate!\n     */\n    public function testValidate()\n    {\n        $validaddresses = [\n            'first@example.org',\n            'first.last@example.org',\n            '1234567890123456789012345678901234567890123456789012345678901234@example.org',\n            '\"first\\\"last\"@example.org',\n            '\"first@last\"@example.org',\n            '\"first\\last\"@example.org',\n            'first.last@[12.34.56.78]',\n            'first.last@x23456789012345678901234567890123456789012345678901234567890123.example.org',\n            'first.last@123.example.org',\n            '\"first\\last\"@example.org',\n            '\"Abc\\@def\"@example.org',\n            '\"Fred\\ Bloggs\"@example.org',\n            '\"Joe.\\Blow\"@example.org',\n            '\"Abc@def\"@example.org',\n            'user+mailbox@example.org',\n            'customer/department=shipping@example.org',\n            '$A12345@example.org',\n            '!def!xyz%abc@example.org',\n            '_somename@example.org',\n            'dclo@us.example.com',\n            'peter.piper@example.org',\n            'test@example.org',\n            'TEST@example.org',\n            '1234567890@example.org',\n            'test+test@example.org',\n            'test-test@example.org',\n            't*est@example.org',\n            '+1~1+@example.org',\n            '{_test_}@example.org',\n            'test.test@example.org',\n            '\"test.test\"@example.org',\n            'test.\"test\"@example.org',\n            '\"test@test\"@example.org',\n            'test@123.123.123.x123',\n            'test@[123.123.123.123]',\n            'test@example.example.org',\n            'test@example.example.example.org',\n            '\"test\\test\"@example.org',\n            '\"test\\blah\"@example.org',\n            '\"test\\blah\"@example.org',\n            '\"test\\\"blah\"@example.org',\n            'customer/department@example.org',\n            '_Yosemite.Sam@example.org',\n            '~@example.org',\n            '\"Austin@Powers\"@example.org',\n            'Ima.Fool@example.org',\n            '\"Ima.Fool\"@example.org',\n            '\"first\".\"last\"@example.org',\n            '\"first\".middle.\"last\"@example.org',\n            '\"first\".last@example.org',\n            'first.\"last\"@example.org',\n            '\"first\".\"middle\".\"last\"@example.org',\n            '\"first.middle\".\"last\"@example.org',\n            '\"first.middle.last\"@example.org',\n            '\"first..last\"@example.org',\n            '\"first\\\"last\"@example.org',\n            'first.\"mid\\dle\".\"last\"@example.org',\n            'name.lastname@example.com',\n            'a@example.com',\n            'aaa@[123.123.123.123]',\n            'a-b@example.com',\n            '+@b.c',\n            '+@b.com',\n            'a@b.co-foo.uk',\n            'valid@about.museum',\n            'shaitan@my-domain.thisisminekthx',\n            '\"Joe\\Blow\"@example.org',\n            'user%uucp!path@example.edu',\n            'cdburgess+!#$%&\\'*-/=?+_{}|~test@example.com',\n            'test@test.com',\n            'test@xn--example.com',\n            'test@example.com',\n        ];\n        //These are invalid according to PHP's filter_var\n        //which doesn't allow dotless domains, numeric TLDs or unbracketed IPv4 literals\n        $invalidphp = [\n            'a@b',\n            'a@bar',\n            'first.last@com',\n            'test@123.123.123.123',\n            'foobar@192.168.0.1',\n            'first.last@example.123',\n        ];\n        //Valid RFC 5322 addresses using quoting and comments\n        //Note that these are *not* all valid for RFC5321\n        $validqandc = [\n            'HM2Kinsists@(that comments are allowed)this.is.ok',\n            '\"Doug \\\"Ace\\\" L.\"@example.org',\n            '\"[[ test ]]\"@example.org',\n            '\"Ima Fool\"@example.org',\n            '\"test blah\"@example.org',\n            '(foo)cal(bar)@(baz)example.com(quux)',\n            'cal@example(woo).(yay)com',\n            'cal(woo(yay)hoopla)@example.com',\n            'cal(foo\\@bar)@example.com',\n            'cal(foo\\)bar)@example.com',\n            'first().last@example.org',\n            'pete(his account)@silly.test(his host)',\n            'c@(Chris\\'s host.)public.example',\n            'jdoe@machine(comment). example',\n            '1234 @ local(blah) .machine .example',\n            'first(abc.def).last@example.org',\n            'first(a\"bc.def).last@example.org',\n            'first.(\")middle.last(\")@example.org',\n            'first(abc\\(def)@example.org',\n            'first.last@x(1234567890123456789012345678901234567890123456789012345678901234567890).com',\n            'a(a(b(c)d(e(f))g)h(i)j)@example.org',\n            '\"hello my name is\"@example.com',\n            '\"Test \\\"Fail\\\" Ing\"@example.org',\n            'first.last @example.org',\n        ];\n        //Valid explicit IPv6 numeric addresses\n        $validipv6 = [\n            'first.last@[IPv6:::a2:a3:a4:b1:b2:b3:b4]',\n            'first.last@[IPv6:a1:a2:a3:a4:b1:b2:b3::]',\n            'first.last@[IPv6:::]',\n            'first.last@[IPv6:::b4]',\n            'first.last@[IPv6:::b3:b4]',\n            'first.last@[IPv6:a1::b4]',\n            'first.last@[IPv6:a1::]',\n            'first.last@[IPv6:a1:a2::]',\n            'first.last@[IPv6:0123:4567:89ab:cdef::]',\n            'first.last@[IPv6:0123:4567:89ab:CDEF::]',\n            'first.last@[IPv6:::a3:a4:b1:ffff:11.22.33.44]',\n            'first.last@[IPv6:::a2:a3:a4:b1:ffff:11.22.33.44]',\n            'first.last@[IPv6:a1:a2:a3:a4::11.22.33.44]',\n            'first.last@[IPv6:a1:a2:a3:a4:b1::11.22.33.44]',\n            'first.last@[IPv6:a1::11.22.33.44]',\n            'first.last@[IPv6:a1:a2::11.22.33.44]',\n            'first.last@[IPv6:0123:4567:89ab:cdef::11.22.33.44]',\n            'first.last@[IPv6:0123:4567:89ab:CDEF::11.22.33.44]',\n            'first.last@[IPv6:a1::b2:11.22.33.44]',\n            'first.last@[IPv6:::12.34.56.78]',\n            'first.last@[IPv6:1111:2222:3333::4444:12.34.56.78]',\n            'first.last@[IPv6:1111:2222:3333:4444:5555:6666:12.34.56.78]',\n            'first.last@[IPv6:::1111:2222:3333:4444:5555:6666]',\n            'first.last@[IPv6:1111:2222:3333::4444:5555:6666]',\n            'first.last@[IPv6:1111:2222:3333:4444:5555:6666::]',\n            'first.last@[IPv6:1111:2222:3333:4444:5555:6666:7777:8888]',\n            'first.last@[IPv6:1111:2222:3333::4444:5555:12.34.56.78]',\n            'first.last@[IPv6:1111:2222:3333::4444:5555:6666:7777]',\n        ];\n        $invalidaddresses = [\n            'first.last@sub.do,com',\n            'first\\@last@iana.org',\n            '123456789012345678901234567890123456789012345678901234567890' .\n            '@12345678901234567890123456789012345678901234 [...]',\n            'first.last',\n            '12345678901234567890123456789012345678901234567890123456789012345@iana.org',\n            '.first.last@iana.org',\n            'first.last.@iana.org',\n            'first..last@iana.org',\n            '\"first\"last\"@iana.org',\n            '\"\"\"@iana.org',\n            '\"\\\"@iana.org',\n            //'\"\"@iana.org',\n            'first\\@last@iana.org',\n            'first.last@',\n            'x@x23456789.x23456789.x23456789.x23456789.x23456789.x23456789.x23456789.' .\n            'x23456789.x23456789.x23456789.x23 [...]',\n            'first.last@[.12.34.56.78]',\n            'first.last@[12.34.56.789]',\n            'first.last@[::12.34.56.78]',\n            'first.last@[IPv5:::12.34.56.78]',\n            'first.last@[IPv6:1111:2222:3333:4444:5555:12.34.56.78]',\n            'first.last@[IPv6:1111:2222:3333:4444:5555:6666:7777:12.34.56.78]',\n            'first.last@[IPv6:1111:2222:3333:4444:5555:6666:7777]',\n            'first.last@[IPv6:1111:2222:3333:4444:5555:6666:7777:8888:9999]',\n            'first.last@[IPv6:1111:2222::3333::4444:5555:6666]',\n            'first.last@[IPv6:1111:2222:333x::4444:5555]',\n            'first.last@[IPv6:1111:2222:33333::4444:5555]',\n            'first.last@-xample.com',\n            'first.last@exampl-.com',\n            'first.last@x234567890123456789012345678901234567890123456789012345678901234.iana.org',\n            'abc\\@def@iana.org',\n            'abc\\@iana.org',\n            'Doug\\ \\\"Ace\\\"\\ Lovell@iana.org',\n            'abc@def@iana.org',\n            'abc\\@def@iana.org',\n            'abc\\@iana.org',\n            '@iana.org',\n            'doug@',\n            '\"qu@iana.org',\n            'ote\"@iana.org',\n            '.dot@iana.org',\n            'dot.@iana.org',\n            'two..dot@iana.org',\n            '\"Doug \"Ace\" L.\"@iana.org',\n            'Doug\\ \\\"Ace\\\"\\ L\\.@iana.org',\n            'hello world@iana.org',\n            //'helloworld@iana .org',\n            'gatsby@f.sc.ot.t.f.i.tzg.era.l.d.',\n            'test.iana.org',\n            'test.@iana.org',\n            'test..test@iana.org',\n            '.test@iana.org',\n            'test@test@iana.org',\n            'test@@iana.org',\n            '-- test --@iana.org',\n            '[test]@iana.org',\n            '\"test\"test\"@iana.org',\n            '()[]\\;:,><@iana.org',\n            'test@.',\n            'test@example.',\n            'test@.org',\n            'test@12345678901234567890123456789012345678901234567890123456789012345678901234567890' .\n            '12345678901234567890 [...]',\n            'test@[123.123.123.123',\n            'test@123.123.123.123]',\n            'NotAnEmail',\n            '@NotAnEmail',\n            '\"test\"blah\"@iana.org',\n            '.wooly@iana.org',\n            'wo..oly@iana.org',\n            'pootietang.@iana.org',\n            '.@iana.org',\n            'Ima Fool@iana.org',\n            'phil.h\\@\\@ck@haacked.com',\n            'foo@[\\1.2.3.4]',\n            //'first.\"\".last@iana.org',\n            'first\\last@iana.org',\n            'Abc\\@def@iana.org',\n            'Fred\\ Bloggs@iana.org',\n            'Joe.\\Blow@iana.org',\n            'first.last@[IPv6:1111:2222:3333:4444:5555:6666:12.34.567.89]',\n            '{^c\\@**Dog^}@cartoon.com',\n            //'\"foo\"(yay)@(hoopla)[1.2.3.4]',\n            'cal(foo(bar)@iamcal.com',\n            'cal(foo)bar)@iamcal.com',\n            'cal(foo\\)@iamcal.com',\n            'first(12345678901234567890123456789012345678901234567890)last@(1234567890123456789' .\n            '01234567890123456789012 [...]',\n            'first(middle)last@iana.org',\n            'first(abc(\"def\".ghi).mno)middle(abc(\"def\".ghi).mno).last@(abc(\"def\".ghi).mno)example' .\n            '(abc(\"def\".ghi).mno). [...]',\n            'a(a(b(c)d(e(f))g)(h(i)j)@iana.org',\n            '.@',\n            '@bar.com',\n            '@@bar.com',\n            'aaa.com',\n            'aaa@.com',\n            'aaa@.123',\n            'aaa@[123.123.123.123]a',\n            'aaa@[123.123.123.333]',\n            'a@bar.com.',\n            'a@-b.com',\n            'a@b-.com',\n            '-@..com',\n            '-@a..com',\n            'invalid@about.museum-',\n            'test@...........com',\n            '\"Unicode NULL' . chr(0) . '\"@char.com',\n            'Unicode NULL' . chr(0) . '@char.com',\n            'first.last@[IPv6::]',\n            'first.last@[IPv6::::]',\n            'first.last@[IPv6::b4]',\n            'first.last@[IPv6::::b4]',\n            'first.last@[IPv6::b3:b4]',\n            'first.last@[IPv6::::b3:b4]',\n            'first.last@[IPv6:a1:::b4]',\n            'first.last@[IPv6:a1:]',\n            'first.last@[IPv6:a1:::]',\n            'first.last@[IPv6:a1:a2:]',\n            'first.last@[IPv6:a1:a2:::]',\n            'first.last@[IPv6::11.22.33.44]',\n            'first.last@[IPv6::::11.22.33.44]',\n            'first.last@[IPv6:a1:11.22.33.44]',\n            'first.last@[IPv6:a1:::11.22.33.44]',\n            'first.last@[IPv6:a1:a2:::11.22.33.44]',\n            'first.last@[IPv6:0123:4567:89ab:cdef::11.22.33.xx]',\n            'first.last@[IPv6:0123:4567:89ab:CDEFF::11.22.33.44]',\n            'first.last@[IPv6:a1::a4:b1::b4:11.22.33.44]',\n            'first.last@[IPv6:a1::11.22.33]',\n            'first.last@[IPv6:a1::11.22.33.44.55]',\n            'first.last@[IPv6:a1::b211.22.33.44]',\n            'first.last@[IPv6:a1::b2::11.22.33.44]',\n            'first.last@[IPv6:a1::b3:]',\n            'first.last@[IPv6::a2::b4]',\n            'first.last@[IPv6:a1:a2:a3:a4:b1:b2:b3:]',\n            'first.last@[IPv6::a2:a3:a4:b1:b2:b3:b4]',\n            'first.last@[IPv6:a1:a2:a3:a4::b1:b2:b3:b4]',\n            //This is a valid RFC5322 address, but we don't want to allow it for obvious reasons!\n            \"(\\r\\n RCPT TO:user@example.com\\r\\n DATA \\\\\\nSubject: spam10\\\\\\n\\r\\n Hello,\" .\n            \"\\r\\n this is a spam mail.\\\\\\n.\\r\\n QUIT\\r\\n ) a@example.net\",\n        ];\n        //IDNs in Unicode and ASCII forms.\n        $unicodeaddresses = [\n            'first.last@b\u00fccher.ch',\n            'first.last@\u043a\u0442\u043e.\u0440\u0444',\n            'first.last@phpl\u00edst.com',\n        ];\n        $asciiaddresses = [\n            'first.last@xn--bcher-kva.ch',\n            'first.last@xn--j1ail.xn--p1ai',\n            'first.last@xn--phplst-6va.com',\n        ];\n        $goodfails = [];\n        foreach (array_merge($validaddresses, $asciiaddresses) as $address) {\n            if (!PHPMailer::validateAddress($address)) {\n                $goodfails[] = $address;\n            }\n        }\n        $badpasses = [];\n        foreach (array_merge($invalidaddresses, $unicodeaddresses) as $address) {\n            if (PHPMailer::validateAddress($address)) {\n                $badpasses[] = $address;\n            }\n        }\n        $err = '';\n        if (count($goodfails) > 0) {\n            $err .= \"Good addresses that failed validation:\\n\";\n            $err .= implode(\"\\n\", $goodfails);\n        }\n        if (count($badpasses) > 0) {\n            if (!empty($err)) {\n                $err .= \"\\n\\n\";\n            }\n            $err .= \"Bad addresses that passed validation:\\n\";\n            $err .= implode(\"\\n\", $badpasses);\n        }\n        self::assertEmpty($err, $err);\n\n        //For coverage\n        self::assertTrue(PHPMailer::validateAddress('test@example.com', 'auto'));\n        self::assertFalse(PHPMailer::validateAddress('test@example.com.', 'auto'));\n        self::assertTrue(PHPMailer::validateAddress('test@example.com', 'pcre'));\n        self::assertFalse(PHPMailer::validateAddress('test@example.com.', 'pcre'));\n        self::assertTrue(PHPMailer::validateAddress('test@example.com', 'pcre8'));\n        self::assertFalse(PHPMailer::validateAddress('test@example.com.', 'pcre8'));\n        self::assertTrue(PHPMailer::validateAddress('test@example.com', 'html5'));\n        self::assertFalse(PHPMailer::validateAddress('test@example.com.', 'html5'));\n        self::assertTrue(PHPMailer::validateAddress('test@example.com', 'php'));\n        self::assertFalse(PHPMailer::validateAddress('test@example.com.', 'php'));\n        self::assertTrue(PHPMailer::validateAddress('test@example.com', 'noregex'));\n        self::assertFalse(PHPMailer::validateAddress('bad', 'noregex'));\n    }\n\n    /**\n     * Test injecting a custom validator.\n     */\n    public function testCustomValidator()\n    {\n        //Inject a one-off custom validator\n        self::assertTrue(\n            PHPMailer::validateAddress(\n                'user@example.com',\n                function ($address) {\n                    return strpos($address, '@') !== false;\n                }\n            ),\n            'Custom validator false negative'\n        );\n        self::assertFalse(\n            PHPMailer::validateAddress(\n                'userexample.com',\n                function ($address) {\n                    return strpos($address, '@') !== false;\n                }\n            ),\n            'Custom validator false positive'\n        );\n        //Set the default validator to an injected function\n        PHPMailer::$validator = function ($address) {\n            return 'user@example.com' === $address;\n        };\n        self::assertTrue(\n            $this->Mail->addAddress('user@example.com'),\n            'Custom default validator false negative'\n        );\n        self::assertFalse(\n        //Need to pick a failing value which would pass all other validators\n        //to be sure we're using our custom one\n            $this->Mail->addAddress('bananas@example.com'),\n            'Custom default validator false positive'\n        );\n        //Set validator back to default\n        PHPMailer::$validator = 'php';\n        self::assertFalse(\n        //This is a valid address that FILTER_VALIDATE_EMAIL thinks is invalid\n            $this->Mail->addAddress('first.last@example.123'),\n            'PHP validator not behaving as expected'\n        );\n\n        //Test denying override of built-in validator names\n        //See SECURITY.md and CVE-2021-3603\n        //If a `php` function defined in validators.php successfully overrides this built-in validator name,\n        //this would return false \u2013 and we don't want to allow that\n        self::assertTrue(PHPMailer::validateAddress('test@example.com', 'php'));\n        //Check a non-matching validator function, which should be permitted, and return false in this case\n        self::assertFalse(PHPMailer::validateAddress('test@example.com', 'phpx'));\n    }\n\n    /**\n     * Word-wrap an ASCII message.\n     */\n    public function testWordWrap()\n    {\n        $this->Mail->WordWrap = 40;\n        $my_body = str_repeat(\n            'Here is the main body of this message.  It should ' .\n            'be quite a few lines.  It should be wrapped at ' .\n            '40 characters.  Make sure that it is. ',\n            10\n        );\n        $nBodyLen = strlen($my_body);\n        $my_body .= \"\\n\\nThis is the above body length: \" . $nBodyLen;\n\n        $this->Mail->Body = $my_body;\n        $this->Mail->Subject .= ': Wordwrap';\n\n        $this->buildBody();\n        self::assertTrue($this->Mail->send(), $this->Mail->ErrorInfo);\n    }\n\n    /**\n     * Word-wrap a multibyte message.\n     */\n    public function testWordWrapMultibyte()\n    {\n        $this->Mail->WordWrap = 40;\n        $my_body = str_repeat(\n            '\u98db\u5152\u6a02 \u5718\u5149\u832b \u98db\u5152\u6a02 \u5718\u5149\u832b \u98db\u5152\u6a02 \u5718\u5149\u832b \u98db\u5152\u6a02 \u5718\u5149\u832b ' .\n            '\u98db\u98db\u5152\u6a02 \u5718\u5149\u832b\u5152\u6a02 \u5718\u5149\u832b\u98db\u5152\u6a02 \u5718\u5149\u98db\u5152\u6a02 \u5718\u5149\u832b\u98db\u5152\u6a02 \u5718\u5149\u832b\u5152\u6a02 \u5718\u5149\u832b ' .\n            '\u98db\u5152\u6a02 \u5718\u5149\u832b\u98db\u5152\u6a02 \u5718\u98db\u5152\u6a02 \u5718\u5149\u832b\u5149\u832b\u98db\u5152\u6a02 \u5718\u5149\u832b. ',\n            10\n        );\n        $nBodyLen = strlen($my_body);\n        $my_body .= \"\\n\\nThis is the above body length: \" . $nBodyLen;\n\n        $this->Mail->Body = $my_body;\n        $this->Mail->Subject .= ': Wordwrap multibyte';\n\n        $this->buildBody();\n        self::assertTrue($this->Mail->send(), $this->Mail->ErrorInfo);\n    }\n\n    /**\n     * Test low priority.\n     */\n    public function testLowPriority()\n    {\n        $this->Mail->Priority = 5;\n        $this->Mail->Body = 'Here is the main body.  There should be ' .\n            'a reply to address in this message.';\n        $this->Mail->Subject .= ': Low Priority';\n        $this->Mail->addReplyTo('nobody@nobody.com', 'Nobody (Unit Test)');\n\n        $this->buildBody();\n        self::assertTrue($this->Mail->send(), $this->Mail->ErrorInfo);\n    }\n\n    /**\n     * Simple plain file attachment test.\n     */\n    public function testMultiplePlainFileAttachment()\n    {\n        $this->Mail->Body = 'Here is the text body';\n        $this->Mail->Subject .= ': Plain + Multiple FileAttachments';\n\n        if (!$this->Mail->addAttachment(realpath($this->INCLUDE_DIR . '/examples/images/phpmailer.png'))) {\n            self::assertTrue(false, $this->Mail->ErrorInfo);\n\n            return;\n        }\n\n        if (!$this->Mail->addAttachment(__FILE__, 'test.txt')) {\n            self::assertTrue(false, $this->Mail->ErrorInfo);\n\n            return;\n        }\n\n        $this->buildBody();\n        self::assertTrue($this->Mail->send(), $this->Mail->ErrorInfo);\n    }\n\n    /**\n     * Rejection of non-local file attachments test.\n     */\n    public function testRejectNonLocalFileAttachment()\n    {\n        self::assertFalse(\n            $this->Mail->addAttachment('https://github.com/PHPMailer/PHPMailer/raw/master/README.md'),\n            'addAttachment should reject remote URLs'\n        );\n\n        self::assertFalse(\n            $this->Mail->addAttachment('phar://phar.php'),\n            'addAttachment should reject phar resources'\n        );\n    }\n\n    /**\n     * Simple plain string attachment test.\n     */\n    public function testPlainStringAttachment()\n    {\n        $this->Mail->Body = 'Here is the text body';\n        $this->Mail->Subject .= ': Plain + StringAttachment';\n\n        $sAttachment = 'These characters are the content of the ' .\n            \"string attachment.\\nThis might be taken from a \" .\n            'database or some other such thing. ';\n\n        $this->Mail->addStringAttachment($sAttachment, 'string_attach.txt');\n\n        $this->buildBody();\n        self::assertTrue($this->Mail->send(), $this->Mail->ErrorInfo);\n    }\n\n    /**\n     * Plain quoted-printable message.\n     */\n    public function testQuotedPrintable()\n    {\n        $this->Mail->Body = 'Here is the main body';\n        $this->Mail->Subject .= ': Plain + Quoted-printable';\n        $this->Mail->Encoding = 'quoted-printable';\n\n        $this->buildBody();\n        self::assertTrue($this->Mail->send(), $this->Mail->ErrorInfo);\n\n        //Check that a quoted printable encode and decode results in the same as went in\n        $t = file_get_contents(__FILE__); //Use this file as test content\n        //Force line breaks to UNIX-style\n        $t = str_replace([\"\\r\\n\", \"\\r\"], \"\\n\", $t);\n        self::assertEquals(\n            $t,\n            quoted_printable_decode($this->Mail->encodeQP($t)),\n            'Quoted-Printable encoding round-trip failed'\n        );\n        //Force line breaks to Windows-style\n        $t = str_replace(\"\\n\", \"\\r\\n\", $t);\n        self::assertEquals(\n            $t,\n            quoted_printable_decode($this->Mail->encodeQP($t)),\n            'Quoted-Printable encoding round-trip failed (Windows line breaks)'\n        );\n    }\n\n    /**\n     * Test header encoding & folding.\n     */\n    public function testHeaderEncoding()\n    {\n        $this->Mail->CharSet = PHPMailer::CHARSET_UTF8;\n        $letter = html_entity_decode('&eacute;', ENT_COMPAT, PHPMailer::CHARSET_UTF8);\n        //This should select B-encoding automatically and should fold\n        $bencode = str_repeat($letter, PHPMailer::STD_LINE_LENGTH + 1);\n        //This should select Q-encoding automatically and should fold\n        $qencode = str_repeat('e', PHPMailer::STD_LINE_LENGTH) . $letter;\n        //This should select B-encoding automatically and should not fold\n        $bencodenofold = str_repeat($letter, 10);\n        //This should select Q-encoding automatically and should not fold\n        $qencodenofold = str_repeat('e', 9) . $letter;\n        //This should Q-encode as ASCII and fold (previously, this did not encode)\n        $longheader = str_repeat('e', PHPMailer::STD_LINE_LENGTH + 10);\n        //This should Q-encode as UTF-8 and fold\n        $longutf8 = str_repeat($letter, PHPMailer::STD_LINE_LENGTH + 10);\n        //This should not change\n        $noencode = 'eeeeeeeeee';\n        $this->Mail->isMail();\n        //Expected results\n\n        $bencoderes = '=?utf-8?B?w6nDqcOpw6nDqcOpw6nDqcOpw6nDqcOpw6nDqcOpw6nDqcOpw6nDqcOpw6k=?=' .\n            PHPMailer::getLE() .\n            ' =?utf-8?B?w6nDqcOpw6nDqcOpw6nDqcOpw6nDqcOpw6nDqcOpw6nDqcOpw6nDqcOpw6k=?=' .\n            PHPMailer::getLE() .\n            ' =?utf-8?B?w6nDqcOpw6nDqcOpw6nDqcOpw6nDqcOpw6nDqcOpw6nDqcOpw6nDqcOpw6k=?=' .\n            PHPMailer::getLE() .\n            ' =?utf-8?B?w6nDqcOpw6nDqcOpw6nDqcOpw6nDqQ==?=';\n        $qencoderes = '=?utf-8?Q?eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee?=' .\n            PHPMailer::getLE() .\n            ' =?utf-8?Q?eeeeeeeeeeeeeeeeeeeeeeeeee=C3=A9?=';\n        $bencodenofoldres = '=?utf-8?B?w6nDqcOpw6nDqcOpw6nDqcOpw6k=?=';\n        $qencodenofoldres = '=?utf-8?Q?eeeeeeeee=C3=A9?=';\n        $longheaderres = '=?us-ascii?Q?eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee?=' .\n            PHPMailer::getLE() . ' =?us-ascii?Q?eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee?=';\n        $longutf8res = '=?utf-8?B?w6nDqcOpw6nDqcOpw6nDqcOpw6nDqcOpw6nDqcOpw6nDqcOpw6nDqcOpw6k=?=' .\n             PHPMailer::getLE() . ' =?utf-8?B?w6nDqcOpw6nDqcOpw6nDqcOpw6nDqcOpw6nDqcOpw6nDqcOpw6nDqcOpw6k=?=' .\n             PHPMailer::getLE() . ' =?utf-8?B?w6nDqcOpw6nDqcOpw6nDqcOpw6nDqcOpw6nDqcOpw6nDqcOpw6nDqcOpw6k=?=' .\n             PHPMailer::getLE() . ' =?utf-8?B?w6nDqcOpw6nDqcOpw6nDqcOpw6nDqcOpw6nDqcOpw6nDqcOpw6nDqQ==?=';\n        $noencoderes = 'eeeeeeeeee';\n        self::assertEquals(\n            $bencoderes,\n            $this->Mail->encodeHeader($bencode),\n            'Folded B-encoded header value incorrect'\n        );\n        self::assertEquals(\n            $qencoderes,\n            $this->Mail->encodeHeader($qencode),\n            'Folded Q-encoded header value incorrect'\n        );\n        self::assertEquals(\n            $bencodenofoldres,\n            $this->Mail->encodeHeader($bencodenofold),\n            'B-encoded header value incorrect'\n        );\n        self::assertEquals(\n            $qencodenofoldres,\n            $this->Mail->encodeHeader($qencodenofold),\n            'Q-encoded header value incorrect'\n        );\n        self::assertEquals(\n            $longheaderres,\n            $this->Mail->encodeHeader($longheader),\n            'Long header value incorrect'\n        );\n        self::assertEquals(\n            $longutf8res,\n            $this->Mail->encodeHeader($longutf8),\n            'Long UTF-8 header value incorrect'\n        );\n        self::assertEquals(\n            $noencoderes,\n            $this->Mail->encodeHeader($noencode),\n            'Unencoded header value incorrect'\n        );\n    }\n\n    /**\n     * Send an HTML message.\n     */\n    public function testHtml()\n    {\n        $this->Mail->isHTML(true);\n        $this->Mail->Subject .= ': HTML only';\n\n        $this->Mail->Body = <<<'EOT'\n<!DOCTYPE html>\n<html lang=\"en\">\n    <head>\n        <title>HTML email test</title>\n    </head>\n    <body>\n        <h1>PHPMailer does HTML!</h1>\n        <p>This is a <strong>test message</strong> written in HTML.<br>\n        Go to <a href=\"https://github.com/PHPMailer/PHPMailer/\">https://github.com/PHPMailer/PHPMailer/</a>\n        for new versions of PHPMailer.</p>\n        <p>Thank you!</p>\n    </body>\n</html>\nEOT;\n        $this->buildBody();\n        self::assertTrue($this->Mail->send(), $this->Mail->ErrorInfo);\n        $msg = $this->Mail->getSentMIMEMessage();\n        self::assertStringNotContainsString(\"\\r\\n\\r\\nMIME-Version:\", $msg, 'Incorrect MIME headers');\n    }\n\n    /**\n     * Send an HTML message specifying the DSN notifications we expect.\n     */\n    public function testDsn()\n    {\n        $this->Mail->isHTML(true);\n        $this->Mail->Subject .= ': HTML only';\n\n        $this->Mail->Body = <<<'EOT'\n<!DOCTYPE html>\n<html lang=\"en\">\n    <head>\n        <title>HTML email test</title>\n    </head>\n    <body>\n        <p>PHPMailer</p>\n    </body>\n</html>\nEOT;\n        $this->buildBody();\n        $this->Mail->dsn = 'SUCCESS,FAILURE';\n        self::assertTrue($this->Mail->send(), $this->Mail->ErrorInfo);\n        //Sends the same mail, but sets the DSN notification to NEVER\n        $this->Mail->dsn = 'NEVER';\n        self::assertTrue($this->Mail->send(), $this->Mail->ErrorInfo);\n    }\n\n    /**\n     * createBody test of switch case\n     */\n    public function testCreateBody()\n    {\n        $PHPMailer = new PHPMailer();\n        $reflection = new \\ReflectionClass($PHPMailer);\n        $property = $reflection->getProperty('message_type');\n        $property->setAccessible(true);\n        $property->setValue($PHPMailer, 'inline');\n        self::assertIsString($PHPMailer->createBody());\n\n        $property->setValue($PHPMailer, 'attach');\n        self::assertIsString($PHPMailer->createBody());\n\n        $property->setValue($PHPMailer, 'inline_attach');\n        self::assertIsString($PHPMailer->createBody());\n\n        $property->setValue($PHPMailer, 'alt');\n        self::assertIsString($PHPMailer->createBody());\n\n        $property->setValue($PHPMailer, 'alt_inline');\n        self::assertIsString($PHPMailer->createBody());\n\n        $property->setValue($PHPMailer, 'alt_attach');\n        self::assertIsString($PHPMailer->createBody());\n\n        $property->setValue($PHPMailer, 'alt_inline_attach');\n        self::assertIsString($PHPMailer->createBody());\n    }\n\n    /**\n     * Send a message containing ISO-8859-1 text.\n     */\n    public function testHtmlIso8859()\n    {\n        $this->Mail->isHTML(true);\n        $this->Mail->Subject .= ': ISO-8859-1 HTML';\n        $this->Mail->CharSet = PHPMailer::CHARSET_ISO88591;\n\n        //This file is in ISO-8859-1 charset\n        //Needs to be external because this file is in UTF-8\n        $content = file_get_contents(realpath($this->INCLUDE_DIR . '/examples/contents.html'));\n        //This is the string '\u00e9\u00e8\u00ee\u00fc\u00e7\u00c5\u00f1\u00e6\u00df' in ISO-8859-1, base-64 encoded\n        $check = base64_decode('6eju/OfF8ebf');\n        //Make sure it really is in ISO-8859-1!\n        $this->Mail->msgHTML(\n            mb_convert_encoding(\n                $content,\n                'ISO-8859-1',\n                mb_detect_encoding($content, 'UTF-8, ISO-8859-1, ISO-8859-15', true)\n            ),\n            realpath($this->INCLUDE_DIR . '/examples')\n        );\n        $this->buildBody();\n        self::assertStringContainsString($check, $this->Mail->Body, 'ISO message body does not contain expected text');\n        self::assertTrue($this->Mail->send(), $this->Mail->ErrorInfo);\n    }\n\n    /**\n     * Send a message containing multilingual UTF-8 text.\n     */\n    public function testHtmlUtf8()\n    {\n        $this->Mail->isHTML(true);\n        $this->Mail->Subject .= ': UTF-8 HTML \u041f\u0443\u0441\u0442\u043e\u0435 \u0442\u0435\u043b\u043e \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u044f';\n        $this->Mail->CharSet = 'UTF-8';\n\n        $this->Mail->Body = <<<'EOT'\n<!DOCTYPE html>\n<html lang=\"en\">\n    <head>\n        <meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\">\n        <title>HTML email test</title>\n    </head>\n    <body>\n        <p>Chinese text: \u90f5\u4ef6\u5167\u5bb9\u70ba\u7a7a</p>\n        <p>Russian text: \u041f\u0443\u0441\u0442\u043e\u0435 \u0442\u0435\u043b\u043e \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u044f</p>\n        <p>Armenian text: \u0540\u0561\u0572\u0578\u0580\u0564\u0561\u0563\u0580\u0578\u0582\u0569\u0575\u0578\u0582\u0576\u0568 \u0564\u0561\u057f\u0561\u0580\u056f \u0567</p>\n        <p>Czech text: Pr\u00e1zdn\u00e9 t\u011blo zpr\u00e1vy</p>\n    </body>\n</html>\nEOT;\n        $this->buildBody();\n        self::assertTrue($this->Mail->send(), $this->Mail->ErrorInfo);\n        $msg = $this->Mail->getSentMIMEMessage();\n        self::assertStringNotContainsString(\"\\r\\n\\r\\nMIME-Version:\", $msg, 'Incorrect MIME headers');\n    }\n\n    /**\n     * Send a message containing multilingual UTF-8 text with an embedded image.\n     */\n    public function testUtf8WithEmbeddedImage()\n    {\n        $this->Mail->isHTML(true);\n        $this->Mail->Subject .= ': UTF-8 with embedded image';\n        $this->Mail->CharSet = 'UTF-8';\n\n        $this->Mail->Body = <<<'EOT'\n<!DOCTYPE html>\n<html lang=\"en\">\n    <head>\n        <meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\">\n        <title>HTML email test</title>\n    </head>\n    <body>\n        <p>Chinese text: \u90f5\u4ef6\u5167\u5bb9\u70ba\u7a7a</p>\n        <p>Russian text: \u041f\u0443\u0441\u0442\u043e\u0435 \u0442\u0435\u043b\u043e \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u044f</p>\n        <p>Armenian text: \u0540\u0561\u0572\u0578\u0580\u0564\u0561\u0563\u0580\u0578\u0582\u0569\u0575\u0578\u0582\u0576\u0568 \u0564\u0561\u057f\u0561\u0580\u056f \u0567</p>\n        <p>Czech text: Pr\u00e1zdn\u00e9 t\u011blo zpr\u00e1vy</p>\n        Embedded Image: <img alt=\"phpmailer\" src=\"cid:b\u00e4ck\">\n    </body>\n</html>\nEOT;\n        $this->Mail->addEmbeddedImage(\n            realpath($this->INCLUDE_DIR . '/examples/images/phpmailer.png'),\n            'b\u00e4ck',\n            'phpmailer.png',\n            'base64',\n            'image/png'\n        );\n        $this->buildBody();\n        self::assertTrue($this->Mail->send(), $this->Mail->ErrorInfo);\n    }\n\n    /**\n     * Send a message containing multilingual UTF-8 text.\n     */\n    public function testPlainUtf8()\n    {\n        $this->Mail->isHTML(false);\n        $this->Mail->Subject .= ': UTF-8 plain text';\n        $this->Mail->CharSet = 'UTF-8';\n\n        $this->Mail->Body = <<<'EOT'\nChinese text: \u90f5\u4ef6\u5167\u5bb9\u70ba\u7a7a\nRussian text: \u041f\u0443\u0441\u0442\u043e\u0435 \u0442\u0435\u043b\u043e \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u044f\nArmenian text: \u0540\u0561\u0572\u0578\u0580\u0564\u0561\u0563\u0580\u0578\u0582\u0569\u0575\u0578\u0582\u0576\u0568 \u0564\u0561\u057f\u0561\u0580\u056f \u0567\nCzech text: Pr\u00e1zdn\u00e9 t\u011blo zpr\u00e1vy\nEOT;\n        $this->buildBody();\n        self::assertTrue($this->Mail->send(), $this->Mail->ErrorInfo);\n        $msg = $this->Mail->getSentMIMEMessage();\n        self::assertStringNotContainsString(\"\\r\\n\\r\\nMIME-Version:\", $msg, 'Incorrect MIME headers');\n    }\n\n    /**\n     * Test simple message builder and html2text converters.\n     */\n    public function testMsgHTML()\n    {\n        $message = file_get_contents(realpath($this->INCLUDE_DIR . '/examples/contentsutf8.html'));\n        $this->Mail->CharSet = PHPMailer::CHARSET_UTF8;\n        $this->Mail->Body = '';\n        $this->Mail->AltBody = '';\n        //Uses internal HTML to text conversion\n        $this->Mail->msgHTML($message, realpath($this->INCLUDE_DIR . '/examples'));\n        $sub = $this->Mail->Subject . ': msgHTML';\n        $this->Mail->Subject .= $sub;\n\n        self::assertNotEmpty($this->Mail->Body, 'Body not set by msgHTML');\n        self::assertNotEmpty($this->Mail->AltBody, 'AltBody not set by msgHTML');\n        self::assertTrue($this->Mail->send(), $this->Mail->ErrorInfo);\n\n        //Again, using a custom HTML to text converter\n        $this->Mail->AltBody = '';\n        $this->Mail->msgHTML(\n            $message,\n            realpath($this->INCLUDE_DIR . '/examples'),\n            function ($html) {\n                return strtoupper(strip_tags($html));\n            }\n        );\n        $this->Mail->Subject = $sub . ' + custom html2text';\n        self::assertTrue($this->Mail->send(), $this->Mail->ErrorInfo);\n\n        //Test that local paths without a basedir are ignored\n        $this->Mail->msgHTML('<img src=\"/etc/hostname\">test');\n        self::assertStringContainsString('src=\"/etc/hostname\"', $this->Mail->Body);\n        //Test that local paths with a basedir are not ignored\n        $this->Mail->msgHTML('<img src=\"composer.json\">test', realpath($this->INCLUDE_DIR));\n        self::assertStringNotContainsString('src=\"composer.json\"', $this->Mail->Body);\n        //Test that local paths with parent traversal are ignored\n        $this->Mail->msgHTML('<img src=\"../composer.json\">test', realpath($this->INCLUDE_DIR));\n        self::assertStringNotContainsString('src=\"composer.json\"', $this->Mail->Body);\n        //Test that existing embedded URLs are ignored\n        $this->Mail->msgHTML('<img src=\"cid:5d41402abc4b2a76b9719d911017c592\">test');\n        self::assertStringContainsString('src=\"cid:5d41402abc4b2a76b9719d911017c592\"', $this->Mail->Body);\n        //Test that absolute URLs are ignored\n        $this->Mail->msgHTML('<img src=\"https://github.com/PHPMailer/PHPMailer/blob/master/composer.json\">test');\n        self::assertStringContainsString(\n            'src=\"https://github.com/PHPMailer/PHPMailer/blob/master/composer.json\"',\n            $this->Mail->Body\n        );\n        //Test that absolute URLs with anonymous/relative protocol are ignored\n        //Note that such URLs will not work in email anyway because they have no protocol to be relative to\n        $this->Mail->msgHTML('<img src=\"//github.com/PHPMailer/PHPMailer/blob/master/composer.json\">test');\n        self::assertStringContainsString(\n            'src=\"//github.com/PHPMailer/PHPMailer/blob/master/composer.json\"',\n            $this->Mail->Body\n        );\n    }\n\n    /**\n     * Simple HTML and attachment test.\n     */\n    public function testHTMLAttachment()\n    {\n        $this->Mail->Body = 'This is the <strong>HTML</strong> part of the email.';\n        $this->Mail->Subject .= ': HTML + Attachment';\n        $this->Mail->isHTML(true);\n        $this->Mail->CharSet = 'UTF-8';\n\n        if (\n            !$this->Mail->addAttachment(\n                realpath($this->INCLUDE_DIR . '/examples/images/phpmailer_mini.png'),\n                'phpmailer_mini.png'\n            )\n        ) {\n            self::assertTrue(false, $this->Mail->ErrorInfo);\n\n            return;\n        }\n\n        //Make sure phar paths are rejected\n        self::assertFalse($this->Mail->addAttachment('phar://pharfile.php', 'pharfile.php'));\n        //Make sure any path that looks URLish is rejected\n        self::assertFalse($this->Mail->addAttachment('http://example.com/test.php', 'test.php'));\n        self::assertFalse(\n            $this->Mail->addAttachment(\n                'ssh2.sftp://user:pass@attacker-controlled.example.com:22/tmp/payload.phar',\n                'test.php'\n            )\n        );\n        self::assertFalse($this->Mail->addAttachment('x-1.cd+-://example.com/test.php', 'test.php'));\n\n        //Make sure that trying to attach a nonexistent file fails\n        $filename = __FILE__ . md5(microtime()) . 'nonexistent_file.txt';\n        self::assertFalse($this->Mail->addAttachment($filename));\n        //Make sure that trying to attach an existing but unreadable file fails\n        touch($filename);\n        chmod($filename, 0200);\n        self::assertFalse($this->Mail->addAttachment($filename));\n        chmod($filename, 0644);\n        unlink($filename);\n\n        $this->buildBody();\n        self::assertTrue($this->Mail->send(), $this->Mail->ErrorInfo);\n    }\n\n    /**\n     * Attachment naming test.\n     */\n    public function testAttachmentNaming()\n    {\n        $this->Mail->Body = 'Attachments.';\n        $this->Mail->Subject .= ': Attachments';\n        $this->Mail->isHTML(true);\n        $this->Mail->CharSet = 'UTF-8';\n        $this->Mail->addAttachment(\n            realpath($this->INCLUDE_DIR . '/examples/images/phpmailer_mini.png'),\n            'phpmailer_mini.png\";.jpg'\n        );\n        $this->Mail->addAttachment(\n            realpath($this->INCLUDE_DIR . '/examples/images/phpmailer.png'),\n            'phpmailer.png'\n        );\n        $this->Mail->addAttachment(\n            realpath($this->INCLUDE_DIR . '/examples/images/PHPMailer card logo.png'),\n            'PHPMailer card logo.png'\n        );\n        $this->Mail->addAttachment(\n            realpath($this->INCLUDE_DIR . '/examples/images/phpmailer_mini.png'),\n            'phpmailer_mini.png\\\\\\\";.jpg'\n        );\n        $this->buildBody();\n        $this->Mail->preSend();\n        $message = $this->Mail->getSentMIMEMessage();\n        self::assertStringContainsString(\n            'Content-Type: image/png; name=\"phpmailer_mini.png\\\";.jpg\"',\n            $message,\n            'Name containing double quote should be escaped in Content-Type'\n        );\n        self::assertStringContainsString(\n            'Content-Disposition: attachment; filename=\"phpmailer_mini.png\\\";.jpg\"',\n            $message,\n            'Filename containing double quote should be escaped in Content-Disposition'\n        );\n        self::assertStringContainsString(\n            'Content-Type: image/png; name=phpmailer.png',\n            $message,\n            'Name without special chars should not be quoted in Content-Type'\n        );\n        self::assertStringContainsString(\n            'Content-Disposition: attachment; filename=phpmailer.png',\n            $message,\n            'Filename without special chars should not be quoted in Content-Disposition'\n        );\n        self::assertStringContainsString(\n            'Content-Type: image/png; name=\"PHPMailer card logo.png\"',\n            $message,\n            'Name with spaces should be quoted in Content-Type'\n        );\n        self::assertStringContainsString(\n            'Content-Disposition: attachment; filename=\"PHPMailer card logo.png\"',\n            $message,\n            'Filename with spaces should be quoted in Content-Disposition'\n        );\n    }\n\n    /**\n     * Test embedded image without a name.\n     */\n    public function testHTMLStringEmbedNoName()\n    {\n        $this->Mail->Body = 'This is the <strong>HTML</strong> part of the email.';\n        $this->Mail->Subject .= ': HTML + unnamed embedded image';\n        $this->Mail->isHTML(true);\n\n        if (\n            !$this->Mail->addStringEmbeddedImage(\n                file_get_contents(realpath($this->INCLUDE_DIR . '/examples/images/phpmailer_mini.png')),\n                hash('sha256', 'phpmailer_mini.png') . '@phpmailer.0',\n                '', //Intentionally empty name\n                'base64',\n                '', //Intentionally empty MIME type\n                'inline'\n            )\n        ) {\n            self::assertTrue(false, $this->Mail->ErrorInfo);\n\n            return;\n        }\n\n        $this->buildBody();\n        self::assertTrue($this->Mail->send(), $this->Mail->ErrorInfo);\n    }\n\n    /**\n     * Simple HTML and multiple attachment test.\n     */\n    public function testHTMLMultiAttachment()\n    {\n        $this->Mail->Body = 'This is the <strong>HTML</strong> part of the email.';\n        $this->Mail->Subject .= ': HTML + multiple Attachment';\n        $this->Mail->isHTML(true);\n\n        if (\n            !$this->Mail->addAttachment(\n                realpath($this->INCLUDE_DIR . '/examples/images/phpmailer_mini.png'),\n                'phpmailer_mini.png'\n            )\n        ) {\n            self::assertTrue(false, $this->Mail->ErrorInfo);\n\n            return;\n        }\n\n        if (\n            !$this->Mail->addAttachment(\n                realpath($this->INCLUDE_DIR . '/examples/images/phpmailer.png'),\n                'phpmailer.png'\n            )\n        ) {\n            self::assertTrue(false, $this->Mail->ErrorInfo);\n\n            return;\n        }\n\n        $this->buildBody();\n        self::assertTrue($this->Mail->send(), $this->Mail->ErrorInfo);\n    }\n\n    /**\n     * An embedded attachment test.\n     */\n    public function testEmbeddedImage()\n    {\n        $this->Mail->Body = 'Embedded Image: <img alt=\"phpmailer\" src=\"' .\n            'cid:my-attach\">' .\n            'Here is an image!';\n        $this->Mail->Subject .= ': Embedded Image';\n        $this->Mail->isHTML(true);\n\n        if (\n            !$this->Mail->addEmbeddedImage(\n                realpath($this->INCLUDE_DIR . '/examples/images/phpmailer.png'),\n                'my-attach',\n                'phpmailer.png',\n                'base64',\n                'image/png'\n            )\n        ) {\n            self::assertTrue(false, $this->Mail->ErrorInfo);\n\n            return;\n        }\n\n        $this->buildBody();\n        self::assertTrue($this->Mail->send(), $this->Mail->ErrorInfo);\n        $this->Mail->clearAttachments();\n        $this->Mail->msgHTML('<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" />\n    <title>E-Mail Inline Image Test</title>\n  </head>\n  <body>\n    <p><img src=\"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\"></p>\n  </body>\n</html>');\n        $this->Mail->preSend();\n        self::assertStringContainsString(\n            'Content-ID: <bb229a48bee31f5d54ca12dc9bd960c6@phpmailer.0>',\n            $this->Mail->getSentMIMEMessage(),\n            'Embedded image header encoding incorrect.'\n        );\n        //For code coverage\n        $this->Mail->addEmbeddedImage('thisfiledoesntexist', 'xyz'); //Non-existent file\n        $this->Mail->addEmbeddedImage(__FILE__, '123'); //Missing name\n    }\n\n    /**\n     * An embedded attachment test.\n     */\n    public function testMultiEmbeddedImage()\n    {\n        $this->Mail->Body = 'Embedded Image: <img alt=\"phpmailer\" src=\"' .\n            'cid:my-attach\">' .\n            'Here is an image!</a>';\n        $this->Mail->Subject .= ': Embedded Image + Attachment';\n        $this->Mail->isHTML(true);\n\n        if (\n            !$this->Mail->addEmbeddedImage(\n                realpath($this->INCLUDE_DIR . '/examples/images/phpmailer.png'),\n                'my-attach',\n                'phpmailer.png',\n                'base64',\n                'image/png'\n            )\n        ) {\n            self::assertTrue(false, $this->Mail->ErrorInfo);\n\n            return;\n        }\n\n        if (!$this->Mail->addAttachment(__FILE__, 'test.txt')) {\n            self::assertTrue(false, $this->Mail->ErrorInfo);\n\n            return;\n        }\n\n        $this->buildBody();\n        self::assertTrue($this->Mail->send(), $this->Mail->ErrorInfo);\n    }\n\n    /**\n     * Simple multipart/alternative test.\n     */\n    public function testAltBody()\n    {\n        $this->Mail->Body = 'This is the <strong>HTML</strong> part of the email.';\n        $this->Mail->AltBody = 'Here is the plain text body of this message. ' .\n            'It should be quite a few lines. It should be wrapped at ' .\n            '40 characters.  Make sure that it is.';\n        $this->Mail->WordWrap = 40;\n        $this->addNote('This is a multipart/alternative email');\n        $this->Mail->Subject .= ': AltBody + Word Wrap';\n\n        $this->buildBody();\n        self::assertTrue($this->Mail->send(), $this->Mail->ErrorInfo);\n    }\n\n    /**\n     * Simple HTML and attachment test.\n     */\n    public function testAltBodyAttachment()\n    {\n        $this->Mail->Body = 'This is the <strong>HTML</strong> part of the email.';\n        $this->Mail->AltBody = 'This is the text part of the email.';\n        $this->Mail->Subject .= ': AltBody + Attachment';\n        $this->Mail->isHTML(true);\n\n        if (!$this->Mail->addAttachment(__FILE__, 'test_attach.txt')) {\n            self::assertTrue(false, $this->Mail->ErrorInfo);\n\n            return;\n        }\n\n        //Test using non-existent UNC path\n        self::assertFalse($this->Mail->addAttachment('\\\\\\\\nowhere\\\\nothing'));\n\n        $this->buildBody();\n        self::assertTrue($this->Mail->send(), $this->Mail->ErrorInfo);\n    }\n\n    /**\n     * Test sending multiple messages with separate connections.\n     */\n    public function testMultipleSend()\n    {\n        $this->Mail->Body = 'Sending two messages without keepalive';\n        $this->buildBody();\n        $subject = $this->Mail->Subject;\n\n        $this->Mail->Subject = $subject . ': SMTP 1';\n        self::assertTrue($this->Mail->send(), $this->Mail->ErrorInfo);\n\n        $this->Mail->Subject = $subject . ': SMTP 2';\n        $this->Mail->Sender = 'blah@example.com';\n        self::assertTrue($this->Mail->send(), $this->Mail->ErrorInfo);\n    }\n\n    /**\n     * Test sending using SendMail.\n     */\n    public function testSendmailSend()\n    {\n        $this->Mail->Body = 'Sending via sendmail';\n        $this->buildBody();\n        $subject = $this->Mail->Subject;\n\n        $this->Mail->Subject = $subject . ': sendmail';\n        $this->Mail->isSendmail();\n\n        self::assertTrue($this->Mail->send(), $this->Mail->ErrorInfo);\n    }\n\n    /**\n     * Test sending using Qmail.\n     */\n    public function testQmailSend()\n    {\n        //Only run if we have qmail installed\n        if (file_exists('/var/qmail/bin/qmail-inject')) {\n            $this->Mail->Body = 'Sending via qmail';\n            $this->buildBody();\n            $subject = $this->Mail->Subject;\n\n            $this->Mail->Subject = $subject . ': qmail';\n            $this->Mail->isQmail();\n            self::assertTrue($this->Mail->send(), $this->Mail->ErrorInfo);\n        } else {\n            self::markTestSkipped('Qmail is not installed');\n        }\n    }\n\n    /**\n     * Test sending using PHP mail() function.\n     */\n    public function testMailSend()\n    {\n        $sendmail = ini_get('sendmail_path');\n        //No path in sendmail_path\n        if (strpos($sendmail, '/') === false) {\n            ini_set('sendmail_path', '/usr/sbin/sendmail -t -i ');\n        }\n        $this->Mail->Body = 'Sending via mail()';\n        $this->buildBody();\n        $this->Mail->Subject = $this->Mail->Subject . ': mail()';\n        $this->Mail->clearAddresses();\n        $this->Mail->clearCCs();\n        $this->Mail->clearBCCs();\n        $this->setAddress('testmailsend@example.com', 'totest');\n        $this->setAddress('cctestmailsend@example.com', 'cctest', $sType = 'cc');\n        $this->setAddress('bcctestmailsend@example.com', 'bcctest', $sType = 'bcc');\n        $this->Mail->addReplyTo('replytotestmailsend@example.com', 'replytotest');\n        self::assertContains('testmailsend@example.com', $this->Mail->getToAddresses()[0]);\n        self::assertContains('cctestmailsend@example.com', $this->Mail->getCcAddresses()[0]);\n        self::assertContains('bcctestmailsend@example.com', $this->Mail->getBccAddresses()[0]);\n        self::assertContains(\n            'replytotestmailsend@example.com',\n            $this->Mail->getReplyToAddresses()['replytotestmailsend@example.com']\n        );\n        self::assertTrue($this->Mail->getAllRecipientAddresses()['testmailsend@example.com']);\n        self::assertTrue($this->Mail->getAllRecipientAddresses()['cctestmailsend@example.com']);\n        self::assertTrue($this->Mail->getAllRecipientAddresses()['bcctestmailsend@example.com']);\n\n        $this->Mail->createHeader();\n        $this->Mail->isMail();\n        self::assertTrue($this->Mail->send(), $this->Mail->ErrorInfo);\n        $msg = $this->Mail->getSentMIMEMessage();\n        self::assertStringNotContainsString(\"\\r\\n\\r\\nMIME-Version:\", $msg, 'Incorrect MIME headers');\n    }\n\n    /**\n     * Test sending an empty body.\n     */\n    public function testEmptyBody()\n    {\n        $this->buildBody();\n        $this->Mail->Body = '';\n        $this->Mail->Subject = $this->Mail->Subject . ': Empty Body';\n        $this->Mail->isMail();\n        $this->Mail->AllowEmpty = true;\n        self::assertTrue($this->Mail->send(), $this->Mail->ErrorInfo);\n        $this->Mail->AllowEmpty = false;\n        self::assertFalse($this->Mail->send(), $this->Mail->ErrorInfo);\n    }\n\n    /**\n     * Test constructing a multipart message that contains lines that are too long for RFC compliance.\n     */\n    public function testLongBody()\n    {\n        $oklen = str_repeat(str_repeat('0', PHPMailer::MAX_LINE_LENGTH) . PHPMailer::getLE(), 2);\n        //Use +2 to ensure line length is over limit - LE may only be 1 char\n        $badlen = str_repeat(str_repeat('1', PHPMailer::MAX_LINE_LENGTH + 2) . PHPMailer::getLE(), 2);\n\n        $this->Mail->Body = 'This message contains lines that are too long.' .\n            PHPMailer::getLE() . $oklen . $badlen . $oklen;\n        self::assertTrue(\n            PHPMailer::hasLineLongerThanMax($this->Mail->Body),\n            'Test content does not contain long lines!'\n        );\n        $this->Mail->isHTML();\n        $this->buildBody();\n        $this->Mail->AltBody = $this->Mail->Body;\n        $this->Mail->Encoding = '8bit';\n        $this->Mail->preSend();\n        $message = $this->Mail->getSentMIMEMessage();\n        self::assertFalse(\n            PHPMailer::hasLineLongerThanMax($message),\n            'Long line not corrected (Max: ' . (PHPMailer::MAX_LINE_LENGTH + strlen(PHPMailer::getLE())) . ' chars)'\n        );\n        self::assertStringContainsString(\n            'Content-Transfer-Encoding: quoted-printable',\n            $message,\n            'Long line did not cause transfer encoding switch.'\n        );\n    }\n\n    /**\n     * Test constructing a message that does NOT contain lines that are too long for RFC compliance.\n     */\n    public function testShortBody()\n    {\n        $oklen = str_repeat(str_repeat('0', PHPMailer::MAX_LINE_LENGTH) . PHPMailer::getLE(), 10);\n\n        $this->Mail->Body = 'This message does not contain lines that are too long.' .\n            PHPMailer::getLE() . $oklen;\n        self::assertFalse(\n            PHPMailer::hasLineLongerThanMax($this->Mail->Body),\n            'Test content contains long lines!'\n        );\n        $this->buildBody();\n        $this->Mail->Encoding = '8bit';\n        $this->Mail->preSend();\n        $message = $this->Mail->getSentMIMEMessage();\n        self::assertFalse(PHPMailer::hasLineLongerThanMax($message), 'Long line not corrected.');\n        self::assertStringNotContainsString(\n            'Content-Transfer-Encoding: quoted-printable',\n            $message,\n            'Short line caused transfer encoding switch.'\n        );\n    }\n\n    /**\n     * Test keepalive (sending multiple messages in a single connection).\n     */\n    public function testSmtpKeepAlive()\n    {\n        $this->Mail->Body = 'SMTP keep-alive test.';\n        $this->buildBody();\n        $subject = $this->Mail->Subject;\n\n        $this->Mail->SMTPKeepAlive = true;\n        $this->Mail->Subject = $subject . ': SMTP keep-alive 1';\n        self::assertTrue($this->Mail->send(), $this->Mail->ErrorInfo);\n\n        $this->Mail->Subject = $subject . ': SMTP keep-alive 2';\n        self::assertTrue($this->Mail->send(), $this->Mail->ErrorInfo);\n        $this->Mail->smtpClose();\n    }\n\n    /**\n     * Test this denial of service attack.\n     *\n     * @see http://www.cybsec.com/vuln/PHPMailer-DOS.pdf\n     */\n    public function testDenialOfServiceAttack()\n    {\n        $this->Mail->Body = 'This should no longer cause a denial of service.';\n        $this->buildBody();\n\n        $this->Mail->Subject = substr(str_repeat('0123456789', 100), 0, 998);\n        self::assertTrue($this->Mail->send(), $this->Mail->ErrorInfo);\n    }\n\n    /**\n     * Tests this denial of service attack.\n     *\n     * According to the ticket, this should get stuck in a loop, though I can't make it happen.\n     * @see https://sourceforge.net/p/phpmailer/bugs/383/\n     *\n     * @doesNotPerformAssertions\n     */\n    public function testDenialOfServiceAttack2()\n    {\n        //Encoding name longer than 68 chars\n        $this->Mail->Encoding = '1234567890123456789012345678901234567890123456789012345678901234567890';\n        //Call wrapText with a zero length value\n        $this->Mail->wrapText(str_repeat('This should no longer cause a denial of service. ', 30), 0);\n    }\n\n    /**\n     * Test error handling.\n     */\n    public function testError()\n    {\n        $this->Mail->Subject .= ': Error handling test - this should be sent ok';\n        $this->buildBody();\n        $this->Mail->clearAllRecipients(); //No addresses should cause an error\n        self::assertTrue($this->Mail->isError() == false, 'Error found');\n        self::assertTrue($this->Mail->send() == false, 'send succeeded');\n        self::assertTrue($this->Mail->isError(), 'No error found');\n        self::assertEquals('You must provide at least one recipient email address.', $this->Mail->ErrorInfo);\n        $this->Mail->addAddress($_REQUEST['mail_to']);\n        self::assertTrue($this->Mail->send(), 'send failed');\n    }\n\n    /**\n     * Test addressing.\n     */\n    public function testAddressing()\n    {\n        self::assertFalse($this->Mail->addAddress(''), 'Empty address accepted');\n        self::assertFalse($this->Mail->addAddress('', 'Nobody'), 'Empty address with name accepted');\n        self::assertFalse($this->Mail->addAddress('a@example..com'), 'Invalid address accepted');\n        self::assertTrue($this->Mail->addAddress('a@example.com'), 'Addressing failed');\n        self::assertFalse($this->Mail->addAddress('a@example.com'), 'Duplicate addressing failed');\n        self::assertTrue($this->Mail->addCC('b@example.com'), 'CC addressing failed');\n        self::assertFalse($this->Mail->addCC('b@example.com'), 'CC duplicate addressing failed');\n        self::assertFalse($this->Mail->addCC('a@example.com'), 'CC duplicate addressing failed (2)');\n        self::assertTrue($this->Mail->addBCC('c@example.com'), 'BCC addressing failed');\n        self::assertFalse($this->Mail->addBCC('c@example.com'), 'BCC duplicate addressing failed');\n        self::assertFalse($this->Mail->addBCC('a@example.com'), 'BCC duplicate addressing failed (2)');\n        self::assertTrue($this->Mail->addReplyTo('a@example.com'), 'Replyto Addressing failed');\n        self::assertFalse($this->Mail->addReplyTo('a@example..com'), 'Invalid Replyto address accepted');\n        self::assertTrue($this->Mail->setFrom('a@example.com', 'some name'), 'setFrom failed');\n        self::assertFalse($this->Mail->setFrom('a@example.com.', 'some name'), 'setFrom accepted invalid address');\n        $this->Mail->Sender = '';\n        $this->Mail->setFrom('a@example.com', 'some name', true);\n        self::assertEquals($this->Mail->Sender, 'a@example.com', 'setFrom failed to set sender');\n        $this->Mail->Sender = '';\n        $this->Mail->setFrom('a@example.com', 'some name', false);\n        self::assertEquals($this->Mail->Sender, '', 'setFrom should not have set sender');\n        $this->Mail->clearCCs();\n        $this->Mail->clearBCCs();\n        $this->Mail->clearReplyTos();\n    }\n\n    /**\n     * Test addressing.\n     */\n    public function testAddressing2()\n    {\n        $this->buildBody();\n        $this->Mail->setFrom('bob@example.com', '\"Bob\\'s Burgers\" (Bob\\'s \"Burgers\")', true);\n        $this->Mail->isSMTP();\n        $this->Mail->Subject .= ': quotes in from name';\n        self::assertTrue($this->Mail->send(), 'send failed');\n    }\n\n    /**\n     * Test RFC822 address splitting.\n     */\n    public function testAddressSplitting()\n    {\n        //Test built-in address parser\n        self::assertCount(\n            2,\n            PHPMailer::parseAddresses(\n                'Joe User <joe@example.com>, Jill User <jill@example.net>'\n            ),\n            'Failed to recognise address list (IMAP parser)'\n        );\n        self::assertEquals(\n            [\n                ['name' => 'Joe User', 'address' => 'joe@example.com'],\n                ['name' => 'Jill User', 'address' => 'jill@example.net'],\n                ['name' => '', 'address' => 'frank@example.com'],\n            ],\n            PHPMailer::parseAddresses(\n                'Joe User <joe@example.com>,'\n                . 'Jill User <jill@example.net>,'\n                . 'frank@example.com,'\n            ),\n            'Parsed addresses'\n        );\n        //Test simple address parser\n        self::assertCount(\n            2,\n            PHPMailer::parseAddresses(\n                'Joe User <joe@example.com>, Jill User <jill@example.net>',\n                false\n            ),\n            'Failed to recognise address list'\n        );\n        //Test single address\n        self::assertNotEmpty(\n            PHPMailer::parseAddresses(\n                'Joe User <joe@example.com>',\n                false\n            ),\n            'Failed to recognise single address'\n        );\n        //Test quoted name IMAP\n        self::assertNotEmpty(\n            PHPMailer::parseAddresses(\n                'Tim \"The Book\" O\\'Reilly <foo@example.com>'\n            ),\n            'Failed to recognise quoted name (IMAP)'\n        );\n        //Test quoted name\n        self::assertNotEmpty(\n            PHPMailer::parseAddresses(\n                'Tim \"The Book\" O\\'Reilly <foo@example.com>',\n                false\n            ),\n            'Failed to recognise quoted name'\n        );\n        //Test single address IMAP\n        self::assertNotEmpty(\n            PHPMailer::parseAddresses(\n                'Joe User <joe@example.com>'\n            ),\n            'Failed to recognise single address (IMAP)'\n        );\n        //Test unnamed address\n        self::assertNotEmpty(\n            PHPMailer::parseAddresses(\n                'joe@example.com',\n                false\n            ),\n            'Failed to recognise unnamed address'\n        );\n        //Test unnamed address IMAP\n        self::assertNotEmpty(\n            PHPMailer::parseAddresses(\n                'joe@example.com'\n            ),\n            'Failed to recognise unnamed address (IMAP)'\n        );\n        //Test invalid addresses\n        self::assertEmpty(\n            PHPMailer::parseAddresses(\n                'Joe User <joe@example.com.>, Jill User <jill.@example.net>'\n            ),\n            'Failed to recognise invalid addresses (IMAP)'\n        );\n        //Test invalid addresses\n        self::assertEmpty(\n            PHPMailer::parseAddresses(\n                'Joe User <joe@example.com.>, Jill User <jill.@example.net>',\n                false\n            ),\n            'Failed to recognise invalid addresses'\n        );\n    }\n\n    /**\n     * Test address escaping.\n     */\n    public function testAddressEscaping()\n    {\n        $this->Mail->Subject .= ': Address escaping';\n        $this->Mail->clearAddresses();\n        $this->Mail->addAddress('foo@example.com', 'Tim \"The Book\" O\\'Reilly');\n        $this->Mail->Body = 'Test correct escaping of quotes in addresses.';\n        $this->buildBody();\n        $this->Mail->preSend();\n        $b = $this->Mail->getSentMIMEMessage();\n        self::assertStringContainsString('To: \"Tim \\\"The Book\\\" O\\'Reilly\" <foo@example.com>', $b);\n\n        $this->Mail->Subject .= ': Address escaping invalid';\n        $this->Mail->clearAddresses();\n        $this->Mail->addAddress('foo@example.com', 'Tim \"The Book\" O\\'Reilly');\n        $this->Mail->addAddress('invalidaddressexample.com', 'invalidaddress');\n        $this->Mail->Body = 'invalid address';\n        $this->buildBody();\n        $this->Mail->preSend();\n        self::assertEquals('Invalid address:  (to): invalidaddressexample.com', $this->Mail->ErrorInfo);\n\n        $this->Mail->addAttachment(\n            realpath($this->INCLUDE_DIR . '/examples/images/phpmailer_mini.png'),\n            'phpmailer_mini.png'\n        );\n        self::assertTrue($this->Mail->attachmentExists());\n    }\n\n    /**\n     * Test MIME structure assembly.\n     */\n    public function testMIMEStructure()\n    {\n        $this->Mail->Subject .= ': MIME structure';\n        $this->Mail->Body = '<h3>MIME structure test.</h3>';\n        $this->Mail->AltBody = 'MIME structure test.';\n        $this->buildBody();\n        $this->Mail->preSend();\n        self::assertMatchesRegularExpression(\n            \"/Content-Transfer-Encoding: 8bit\\r\\n\\r\\n\" .\n            'This is a multi-part message in MIME format./',\n            $this->Mail->getSentMIMEMessage(),\n            'MIME structure broken'\n        );\n    }\n\n    /**\n     * Test BCC-only addressing.\n     */\n    public function testBCCAddressing()\n    {\n        $this->Mail->isSMTP();\n        $this->Mail->Subject .= ': BCC-only addressing';\n        $this->buildBody();\n        $this->Mail->clearAllRecipients();\n        $this->Mail->addAddress('foo@example.com', 'Foo');\n        $this->Mail->preSend();\n        $b = $this->Mail->getSentMIMEMessage();\n        self::assertTrue($this->Mail->addBCC('a@example.com'), 'BCC addressing failed');\n        self::assertStringContainsString('To: Foo <foo@example.com>', $b);\n        self::assertTrue($this->Mail->send(), 'send failed');\n    }\n\n    /**\n     * Encoding and charset tests.\n     */\n    public function testEncodings()\n    {\n        $this->Mail->CharSet = PHPMailer::CHARSET_ISO88591;\n        self::assertEquals(\n            '=A1Hola!_Se=F1or!',\n            $this->Mail->encodeQ(\"\\xa1Hola! Se\\xf1or!\", 'text'),\n            'Q Encoding (text) failed'\n        );\n        self::assertEquals(\n            '=A1Hola!_Se=F1or!',\n            $this->Mail->encodeQ(\"\\xa1Hola! Se\\xf1or!\", 'comment'),\n            'Q Encoding (comment) failed'\n        );\n        self::assertEquals(\n            '=A1Hola!_Se=F1or!',\n            $this->Mail->encodeQ(\"\\xa1Hola! Se\\xf1or!\", 'phrase'),\n            'Q Encoding (phrase) failed'\n        );\n        $this->Mail->CharSet = 'UTF-8';\n        self::assertEquals(\n            '=C2=A1Hola!_Se=C3=B1or!',\n            $this->Mail->encodeQ(\"\\xc2\\xa1Hola! Se\\xc3\\xb1or!\", 'text'),\n            'Q Encoding (text) failed'\n        );\n        //Strings containing '=' are a special case\n        self::assertEquals(\n            'Nov=C3=A1=3D',\n            $this->Mail->encodeQ(\"Nov\\xc3\\xa1=\", 'text'),\n            'Q Encoding (text) failed 2'\n        );\n\n        self::assertEquals(\n            'hello',\n            $this->Mail->encodeString('hello', 'binary'),\n            'Binary encoding changed input'\n        );\n        $this->Mail->ErrorInfo = '';\n        $this->Mail->encodeString('hello', 'asdfghjkl');\n        self::assertNotEmpty($this->Mail->ErrorInfo, 'Invalid encoding not detected');\n        self::assertMatchesRegularExpression(\n            '/' . base64_encode('hello') . '/',\n            $this->Mail->encodeString('hello')\n        );\n    }\n\n    /**\n     * Expect exceptions on bad encoding\n     */\n    public function testAddAttachmentEncodingException()\n    {\n        $this->expectException(Exception::class);\n\n        $mail = new PHPMailer(true);\n        $mail->addAttachment(__FILE__, 'test.txt', 'invalidencoding');\n    }\n\n    /**\n     * Expect exceptions on sending after deleting a previously successfully attached file\n     */\n    public function testDeletedAttachmentException()\n    {\n        $this->expectException(Exception::class);\n\n        $filename = __FILE__ . md5(microtime()) . 'test.txt';\n        touch($filename);\n        $this->Mail = new PHPMailer(true);\n        $this->Mail->addAttachment($filename);\n        unlink($filename);\n        $this->Mail->send();\n    }\n\n    /**\n     * Expect error on sending after deleting a previously successfully attached file\n     */\n    public function testDeletedAttachmentError()\n    {\n        $filename = __FILE__ . md5(microtime()) . 'test.txt';\n        touch($filename);\n        $this->Mail = new PHPMailer();\n        $this->Mail->addAttachment($filename);\n        unlink($filename);\n        self::assertFalse($this->Mail->send());\n    }\n\n    /**\n     * Expect exceptions on bad encoding\n     */\n    public function testStringAttachmentEncodingException()\n    {\n        $this->expectException(Exception::class);\n\n        $mail = new PHPMailer(true);\n        $mail->addStringAttachment('hello', 'test.txt', 'invalidencoding');\n    }\n\n    /**\n     * Expect exceptions on bad encoding\n     */\n    public function testEmbeddedImageEncodingException()\n    {\n        $this->expectException(Exception::class);\n\n        $mail = new PHPMailer(true);\n        $mail->addEmbeddedImage(__FILE__, 'cid', 'test.png', 'invalidencoding');\n    }\n\n    /**\n     * Expect exceptions on bad encoding\n     */\n    public function testStringEmbeddedImageEncodingException()\n    {\n        $this->expectException(Exception::class);\n\n        $mail = new PHPMailer(true);\n        $mail->addStringEmbeddedImage('hello', 'cid', 'test.png', 'invalidencoding');\n    }\n\n    /**\n     * Test base-64 encoding.\n     */\n    public function testBase64()\n    {\n        $this->Mail->Subject .= ': Base-64 encoding';\n        $this->Mail->Encoding = 'base64';\n        $this->buildBody();\n        self::assertTrue($this->Mail->send(), 'Base64 encoding failed');\n    }\n\n    /**\n     * S/MIME Signing tests (self-signed).\n     *\n     * @requires extension openssl\n     */\n    public function testSigning()\n    {\n        $this->Mail->Subject .= ': S/MIME signing';\n        $this->Mail->Body = 'This message is S/MIME signed.';\n        $this->buildBody();\n\n        $dn = [\n            'countryName' => 'UK',\n            'stateOrProvinceName' => 'Here',\n            'localityName' => 'There',\n            'organizationName' => 'PHP',\n            'organizationalUnitName' => 'PHPMailer',\n            'commonName' => 'PHPMailer Test',\n            'emailAddress' => 'phpmailer@example.com',\n        ];\n        $keyconfig = [\n            'digest_alg' => 'sha256',\n            'private_key_bits' => 2048,\n            'private_key_type' => OPENSSL_KEYTYPE_RSA,\n        ];\n        $password = 'password';\n        $certfile = 'certfile.pem';\n        $keyfile = 'keyfile.pem';\n\n        //Make a new key pair\n        $pk = openssl_pkey_new($keyconfig);\n        //Create a certificate signing request\n        $csr = openssl_csr_new($dn, $pk);\n        //Create a self-signed cert\n        $cert = openssl_csr_sign($csr, null, $pk, 1);\n        //Save the cert\n        openssl_x509_export($cert, $certout);\n        file_put_contents($certfile, $certout);\n        //Save the key\n        openssl_pkey_export($pk, $pkeyout, $password);\n        file_put_contents($keyfile, $pkeyout);\n\n        $this->Mail->sign(\n            $certfile,\n            $keyfile,\n            $password\n        );\n        self::assertTrue($this->Mail->send(), 'S/MIME signing failed');\n\n        $msg = $this->Mail->getSentMIMEMessage();\n        self::assertStringNotContainsString(\"\\r\\n\\r\\nMIME-Version:\", $msg, 'Incorrect MIME headers');\n        unlink($certfile);\n        unlink($keyfile);\n    }\n\n    /**\n     * S/MIME Signing tests using a CA chain cert.\n     * To test that a generated message is signed correctly, save the message in a file called `signed.eml`\n     * and use openssl along with the certs generated by this script:\n     * `openssl smime -verify -in signed.eml -signer certfile.pem -CAfile cacertfile.pem`.\n     *\n     * @requires extension openssl\n     */\n    public function testSigningWithCA()\n    {\n        $this->Mail->Subject .= ': S/MIME signing with CA';\n        $this->Mail->Body = 'This message is S/MIME signed with an extra CA cert.';\n        $this->buildBody();\n\n        $certprops = [\n            'countryName' => 'UK',\n            'stateOrProvinceName' => 'Here',\n            'localityName' => 'There',\n            'organizationName' => 'PHP',\n            'organizationalUnitName' => 'PHPMailer',\n            'commonName' => 'PHPMailer Test',\n            'emailAddress' => 'phpmailer@example.com',\n        ];\n        $cacertprops = [\n            'countryName' => 'UK',\n            'stateOrProvinceName' => 'Here',\n            'localityName' => 'There',\n            'organizationName' => 'PHP',\n            'organizationalUnitName' => 'PHPMailer CA',\n            'commonName' => 'PHPMailer Test CA',\n            'emailAddress' => 'phpmailer@example.com',\n        ];\n        $keyconfig = [\n            'digest_alg' => 'sha256',\n            'private_key_bits' => 2048,\n            'private_key_type' => OPENSSL_KEYTYPE_RSA,\n        ];\n        $password = 'password';\n        $cacertfile = 'cacertfile.pem';\n        $cakeyfile = 'cakeyfile.pem';\n        $certfile = 'certfile.pem';\n        $keyfile = 'keyfile.pem';\n\n        //Create a CA cert\n        //Make a new key pair\n        $capk = openssl_pkey_new($keyconfig);\n        //Create a certificate signing request\n        $csr = openssl_csr_new($cacertprops, $capk);\n        //Create a self-signed cert\n        $cert = openssl_csr_sign($csr, null, $capk, 1);\n        //Save the CA cert\n        openssl_x509_export($cert, $certout);\n        file_put_contents($cacertfile, $certout);\n        //Save the CA key\n        openssl_pkey_export($capk, $pkeyout, $password);\n        file_put_contents($cakeyfile, $pkeyout);\n\n        //Create a cert signed by our CA\n        //Make a new key pair\n        $pk = openssl_pkey_new($keyconfig);\n        //Create a certificate signing request\n        $csr = openssl_csr_new($certprops, $pk);\n        //Create a self-signed cert\n        $cacert = file_get_contents($cacertfile);\n        $cert = openssl_csr_sign($csr, $cacert, $capk, 1);\n        //Save the cert\n        openssl_x509_export($cert, $certout);\n        file_put_contents($certfile, $certout);\n        //Save the key\n        openssl_pkey_export($pk, $pkeyout, $password);\n        file_put_contents($keyfile, $pkeyout);\n\n        $this->Mail->sign(\n            $certfile,\n            $keyfile,\n            $password,\n            $cacertfile\n        );\n        self::assertTrue($this->Mail->send(), 'S/MIME signing with CA failed');\n        unlink($cacertfile);\n        unlink($cakeyfile);\n        unlink($certfile);\n        unlink($keyfile);\n    }\n\n    /**\n     * DKIM body canonicalization tests.\n     *\n     * @see https://tools.ietf.org/html/rfc6376#section-3.4.4\n     */\n    public function testDKIMBodyCanonicalization()\n    {\n        //Example from https://tools.ietf.org/html/rfc6376#section-3.4.5\n        $prebody = \" C \\r\\nD \\t E\\r\\n\\r\\n\\r\\n\";\n        $postbody = \" C \\r\\nD \\t E\\r\\n\";\n        self::assertEquals($this->Mail->DKIM_BodyC(''), \"\\r\\n\", 'DKIM empty body canonicalization incorrect');\n        self::assertEquals(\n            'frcCV1k9oG9oKj3dpUqdJg1PxRT2RSN/XKdLCPjaYaY=',\n            base64_encode(hash('sha256', $this->Mail->DKIM_BodyC(''), true)),\n            'DKIM canonicalized empty body hash mismatch'\n        );\n        self::assertEquals($this->Mail->DKIM_BodyC($prebody), $postbody, 'DKIM body canonicalization incorrect');\n    }\n\n    /**\n     * DKIM header canonicalization tests.\n     *\n     * @see https://tools.ietf.org/html/rfc6376#section-3.4.2\n     */\n    public function testDKIMHeaderCanonicalization()\n    {\n        //Example from https://tools.ietf.org/html/rfc6376#section-3.4.5\n        $preheaders = \"A: X\\r\\nB : Y\\t\\r\\n\\tZ  \\r\\n\";\n        $postheaders = \"a:X\\r\\nb:Y Z\\r\\n\";\n        self::assertEquals(\n            $postheaders,\n            $this->Mail->DKIM_HeaderC($preheaders),\n            'DKIM header canonicalization incorrect'\n        );\n        //Check that long folded lines with runs of spaces are canonicalized properly\n        $preheaders = 'Long-Header-1: <https://example.com/somescript.php?' .\n            \"id=1234567890&name=Abcdefghijklmnopquestuvwxyz&hash=\\r\\n abc1234\\r\\n\" .\n            \"Long-Header-2: This  is  a  long  header  value  that  contains  runs  of  spaces and trailing    \\r\\n\" .\n            ' and   is   folded   onto   2   lines';\n        $postheaders = 'long-header-1:<https://example.com/somescript.php?id=1234567890&' .\n            \"name=Abcdefghijklmnopquestuvwxyz&hash= abc1234\\r\\nlong-header-2:This is a long\" .\n            ' header value that contains runs of spaces and trailing and is folded onto 2 lines';\n        self::assertEquals(\n            $postheaders,\n            $this->Mail->DKIM_HeaderC($preheaders),\n            'DKIM header canonicalization of long lines incorrect'\n        );\n    }\n\n    /**\n     * DKIM copied header fields tests.\n     *\n     * @group dkim\n     *\n     * @see https://tools.ietf.org/html/rfc6376#section-3.5\n     */\n    public function testDKIMOptionalHeaderFieldsCopy()\n    {\n        $privatekeyfile = 'dkim_private.pem';\n        $pk = openssl_pkey_new(\n            [\n                'private_key_bits' => 2048,\n                'private_key_type' => OPENSSL_KEYTYPE_RSA,\n            ]\n        );\n        openssl_pkey_export_to_file($pk, $privatekeyfile);\n        $this->Mail->DKIM_private = 'dkim_private.pem';\n\n        //Example from https://tools.ietf.org/html/rfc6376#section-3.5\n        $from = 'from@example.com';\n        $to = 'to@example.com';\n        $date = 'date';\n        $subject = 'example';\n\n        $headerLines = \"From:$from\\r\\nTo:$to\\r\\nDate:$date\\r\\n\";\n        $copyHeaderFields = \" z=From:$from\\r\\n |To:$to\\r\\n |Date:$date\\r\\n |Subject:$subject;\\r\\n\";\n\n        $this->Mail->DKIM_copyHeaderFields = true;\n        self::assertStringContainsString(\n            $copyHeaderFields,\n            $this->Mail->DKIM_Add($headerLines, $subject, ''),\n            'DKIM header with copied header fields incorrect'\n        );\n\n        $this->Mail->DKIM_copyHeaderFields = false;\n        self::assertStringNotContainsString(\n            $copyHeaderFields,\n            $this->Mail->DKIM_Add($headerLines, $subject, ''),\n            'DKIM header without copied header fields incorrect'\n        );\n\n        unlink($privatekeyfile);\n    }\n\n    /**\n     * DKIM signing extra headers tests.\n     *\n     * @group dkim\n     */\n    public function testDKIMExtraHeaders()\n    {\n        $privatekeyfile = 'dkim_private.pem';\n        $pk = openssl_pkey_new(\n            [\n                'private_key_bits' => 2048,\n                'private_key_type' => OPENSSL_KEYTYPE_RSA,\n            ]\n        );\n        openssl_pkey_export_to_file($pk, $privatekeyfile);\n        $this->Mail->DKIM_private = 'dkim_private.pem';\n\n        //Example from https://tools.ietf.org/html/rfc6376#section-3.5\n        $from = 'from@example.com';\n        $to = 'to@example.com';\n        $date = 'date';\n        $subject = 'example';\n        $anyHeader = 'foo';\n        $unsubscribeUrl = '<https://www.example.com/unsubscribe/?newsletterId=anytoken&amp;actionToken=anyToken' .\n                            '&otherParam=otherValue&anotherParam=anotherVeryVeryVeryLongValue>';\n\n        $this->Mail->addCustomHeader('X-AnyHeader', $anyHeader);\n        $this->Mail->addCustomHeader('Baz', 'bar');\n        $this->Mail->addCustomHeader('List-Unsubscribe', $unsubscribeUrl);\n\n        $this->Mail->DKIM_extraHeaders = ['Baz', 'List-Unsubscribe'];\n\n        $headerLines = \"From:$from\\r\\nTo:$to\\r\\nDate:$date\\r\\n\";\n        $headerLines .= \"X-AnyHeader:$anyHeader\\r\\nBaz:bar\\r\\n\";\n        $headerLines .= 'List-Unsubscribe:' . $this->Mail->encodeHeader($unsubscribeUrl) . \"\\r\\n\";\n\n        $headerFields = 'h=From:To:Date:Baz:List-Unsubscribe:Subject';\n\n        $result = $this->Mail->DKIM_Add($headerLines, $subject, '');\n\n        self::assertStringContainsString($headerFields, $result, 'DKIM header with extra headers incorrect');\n\n        unlink($privatekeyfile);\n    }\n\n    /**\n     * DKIM Signing tests.\n     *\n     * @requires extension openssl\n     */\n    public function testDKIM()\n    {\n        $this->Mail->Subject .= ': DKIM signing';\n        $this->Mail->Body = 'This message is DKIM signed.';\n        $this->buildBody();\n        $privatekeyfile = 'dkim_private.pem';\n        //Make a new key pair\n        //(2048 bits is the recommended minimum key length -\n        //gmail won't accept less than 1024 bits)\n        $pk = openssl_pkey_new(\n            [\n                'private_key_bits' => 2048,\n                'private_key_type' => OPENSSL_KEYTYPE_RSA,\n            ]\n        );\n        openssl_pkey_export_to_file($pk, $privatekeyfile);\n        $this->Mail->DKIM_domain = 'example.com';\n        $this->Mail->DKIM_private = $privatekeyfile;\n        $this->Mail->DKIM_selector = 'phpmailer';\n        $this->Mail->DKIM_passphrase = ''; //key is not encrypted\n        self::assertTrue($this->Mail->send(), 'DKIM signed mail failed');\n        $this->Mail->isMail();\n        self::assertTrue($this->Mail->send(), 'DKIM signed mail via mail() failed');\n        unlink($privatekeyfile);\n    }\n\n    /**\n     * Test line break reformatting.\n     */\n    public function testLineBreaks()\n    {\n        //May have been altered by earlier tests, can interfere with line break format\n        $this->Mail->isSMTP();\n        $this->Mail->preSend();\n        $unixsrc = \"hello\\nWorld\\nAgain\\n\";\n        $macsrc = \"hello\\rWorld\\rAgain\\r\";\n        $windowssrc = \"hello\\r\\nWorld\\r\\nAgain\\r\\n\";\n        $mixedsrc = \"hello\\nWorld\\rAgain\\r\\n\";\n        $target = \"hello\\r\\nWorld\\r\\nAgain\\r\\n\";\n        self::assertEquals($target, PHPMailer::normalizeBreaks($unixsrc), 'UNIX break reformatting failed');\n        self::assertEquals($target, PHPMailer::normalizeBreaks($macsrc), 'Mac break reformatting failed');\n        self::assertEquals($target, PHPMailer::normalizeBreaks($windowssrc), 'Windows break reformatting failed');\n        self::assertEquals($target, PHPMailer::normalizeBreaks($mixedsrc), 'Mixed break reformatting failed');\n\n        //To see accurate results when using postfix, set `sendmail_fix_line_endings = never` in main.cf\n        $this->Mail->Subject = 'PHPMailer DOS line breaks';\n        $this->Mail->Body = \"This message\\r\\ncontains\\r\\nDOS-format\\r\\nCRLF line breaks.\";\n        self::assertTrue($this->Mail->send());\n\n        $this->Mail->Subject = 'PHPMailer UNIX line breaks';\n        $this->Mail->Body = \"This message\\ncontains\\nUNIX-format\\nLF line breaks.\";\n        self::assertTrue($this->Mail->send());\n\n        $this->Mail->Encoding = 'quoted-printable';\n        $this->Mail->Subject = 'PHPMailer DOS line breaks, QP';\n        $this->Mail->Body = \"This message\\r\\ncontains\\r\\nDOS-format\\r\\nCRLF line breaks.\";\n        self::assertTrue($this->Mail->send());\n\n        $this->Mail->Subject = 'PHPMailer UNIX line breaks, QP';\n        $this->Mail->Body = \"This message\\ncontains\\nUNIX-format\\nLF line breaks.\";\n        self::assertTrue($this->Mail->send());\n    }\n\n    /**\n     * Test line length detection.\n     */\n    public function testLineLength()\n    {\n        //May have been altered by earlier tests, can interfere with line break format\n        $this->Mail->isSMTP();\n        $this->Mail->preSend();\n        $oklen = str_repeat(str_repeat('0', PHPMailer::MAX_LINE_LENGTH) . \"\\r\\n\", 2);\n        $badlen = str_repeat(str_repeat('1', PHPMailer::MAX_LINE_LENGTH + 1) . \"\\r\\n\", 2);\n        self::assertTrue(PHPMailer::hasLineLongerThanMax($badlen), 'Long line not detected (only)');\n        self::assertTrue(PHPMailer::hasLineLongerThanMax($oklen . $badlen), 'Long line not detected (first)');\n        self::assertTrue(PHPMailer::hasLineLongerThanMax($badlen . $oklen), 'Long line not detected (last)');\n        self::assertTrue(\n            PHPMailer::hasLineLongerThanMax($oklen . $badlen . $oklen),\n            'Long line not detected (middle)'\n        );\n        self::assertFalse(PHPMailer::hasLineLongerThanMax($oklen), 'Long line false positive');\n        $this->Mail->isHTML(false);\n        $this->Mail->Subject .= ': Line length test';\n        $this->Mail->CharSet = 'UTF-8';\n        $this->Mail->Encoding = '8bit';\n        $this->Mail->Body = $oklen . $badlen . $oklen . $badlen;\n        $this->buildBody();\n        self::assertTrue($this->Mail->send(), $this->Mail->ErrorInfo);\n        self::assertEquals('quoted-printable', $this->Mail->Encoding, 'Long line did not override transfer encoding');\n    }\n\n    /**\n     * Test setting and retrieving message ID.\n     */\n    public function testMessageID()\n    {\n        $this->Mail->Body = 'Test message ID.';\n        $id = hash('sha256', 12345);\n        $this->Mail->MessageID = $id;\n        $this->buildBody();\n        $this->Mail->preSend();\n        $lastid = $this->Mail->getLastMessageID();\n        self::assertNotEquals($lastid, $id, 'Invalid Message ID allowed');\n        $id = '<' . hash('sha256', 12345) . '@example.com>';\n        $this->Mail->MessageID = $id;\n        $this->buildBody();\n        $this->Mail->preSend();\n        $lastid = $this->Mail->getLastMessageID();\n        self::assertEquals($lastid, $id, 'Custom Message ID not used');\n        $this->Mail->MessageID = '';\n        $this->buildBody();\n        $this->Mail->preSend();\n        $lastid = $this->Mail->getLastMessageID();\n        self::assertMatchesRegularExpression('/^<.*@.*>$/', $lastid, 'Invalid default Message ID');\n    }\n\n    /**\n     * Check whether setting a bad custom header throws exceptions.\n     *\n     * @throws Exception\n     */\n    public function testHeaderException()\n    {\n        $this->expectException(Exception::class);\n\n        $mail = new PHPMailer(true);\n        $mail->addCustomHeader('SomeHeader', \"Some\\n Value\");\n    }\n\n    /**\n     * Miscellaneous calls to improve test coverage and some small tests.\n     */\n    public function testMiscellaneous()\n    {\n        self::assertEquals('application/pdf', PHPMailer::_mime_types('pdf'), 'MIME TYPE lookup failed');\n        $this->Mail->clearAttachments();\n        $this->Mail->isHTML(false);\n        $this->Mail->isSMTP();\n        $this->Mail->isMail();\n        $this->Mail->isSendmail();\n        $this->Mail->isQmail();\n        $this->Mail->setLanguage('fr');\n        $this->Mail->Sender = '';\n        $this->Mail->createHeader();\n        self::assertFalse($this->Mail->set('x', 'y'), 'Invalid property set succeeded');\n        self::assertTrue($this->Mail->set('Timeout', 11), 'Valid property set failed');\n        self::assertTrue($this->Mail->set('AllowEmpty', null), 'Null property set failed');\n        self::assertTrue($this->Mail->set('AllowEmpty', false), 'Valid property set of null property failed');\n        //Test pathinfo\n        $a = '/mnt/files/\u98db\u5152\u6a02 \u5718\u5149\u832b.mp3';\n        $q = PHPMailer::mb_pathinfo($a);\n        self::assertEquals($q['dirname'], '/mnt/files', 'UNIX dirname not matched');\n        self::assertEquals($q['basename'], '\u98db\u5152\u6a02 \u5718\u5149\u832b.mp3', 'UNIX basename not matched');\n        self::assertEquals($q['extension'], 'mp3', 'UNIX extension not matched');\n        self::assertEquals($q['filename'], '\u98db\u5152\u6a02 \u5718\u5149\u832b', 'UNIX filename not matched');\n        self::assertEquals(\n            PHPMailer::mb_pathinfo($a, PATHINFO_DIRNAME),\n            '/mnt/files',\n            'Dirname path element not matched'\n        );\n        self::assertEquals(\n            PHPMailer::mb_pathinfo($a, PATHINFO_BASENAME),\n            '\u98db\u5152\u6a02 \u5718\u5149\u832b.mp3',\n            'Basename path element not matched'\n        );\n        self::assertEquals(PHPMailer::mb_pathinfo($a, 'filename'), '\u98db\u5152\u6a02 \u5718\u5149\u832b', 'Filename path element not matched');\n        $a = 'c:\\mnt\\files\\\u98db\u5152\u6a02 \u5718\u5149\u832b.mp3';\n        $q = PHPMailer::mb_pathinfo($a);\n        self::assertEquals($q['dirname'], 'c:\\mnt\\files', 'Windows dirname not matched');\n        self::assertEquals($q['basename'], '\u98db\u5152\u6a02 \u5718\u5149\u832b.mp3', 'Windows basename not matched');\n        self::assertEquals($q['extension'], 'mp3', 'Windows extension not matched');\n        self::assertEquals($q['filename'], '\u98db\u5152\u6a02 \u5718\u5149\u832b', 'Windows filename not matched');\n\n        self::assertEquals(\n            PHPMailer::filenameToType('abc.jpg?xyz=1'),\n            'image/jpeg',\n            'Query string not ignored in filename'\n        );\n        self::assertEquals(\n            PHPMailer::filenameToType('abc.xyzpdq'),\n            'application/octet-stream',\n            'Default MIME type not applied to unknown extension'\n        );\n\n        //Line break normalization\n        $eol = PHPMailer::getLE();\n        $b1 = \"1\\r2\\r3\\r\";\n        $b2 = \"1\\n2\\n3\\n\";\n        $b3 = \"1\\r\\n2\\r3\\n\";\n        $t1 = \"1{$eol}2{$eol}3{$eol}\";\n        self::assertEquals(PHPMailer::normalizeBreaks($b1), $t1, 'Failed to normalize line breaks (1)');\n        self::assertEquals(PHPMailer::normalizeBreaks($b2), $t1, 'Failed to normalize line breaks (2)');\n        self::assertEquals(PHPMailer::normalizeBreaks($b3), $t1, 'Failed to normalize line breaks (3)');\n    }\n\n    public function testBadSMTP()\n    {\n        $this->Mail->smtpConnect();\n        $smtp = $this->Mail->getSMTPInstance();\n        self::assertFalse($smtp->mail(\"somewhere\\nbad\"), 'Bad SMTP command containing breaks accepted');\n    }\n\n    public function testHostValidation()\n    {\n        $good = [\n            'localhost',\n            'example.com',\n            'smtp.gmail.com',\n            '127.0.0.1',\n            trim(str_repeat('a0123456789.', 21), '.'),\n            '[::1]',\n            '[0:1234:dc0:41:216:3eff:fe67:3e01]',\n        ];\n        $bad = [\n            null,\n            123,\n            1.5,\n            new \\stdClass(),\n            [],\n            '',\n            '999.0.0.0',\n            '[1234]',\n            '[1234:::1]',\n            trim(str_repeat('a0123456789.', 22), '.'),\n            '0:1234:dc0:41:216:3eff:fe67:3e01',\n            '[012q:1234:dc0:41:216:3eff:fe67:3e01]',\n            '[[::1]]',\n        ];\n        foreach ($good as $h) {\n            self::assertTrue(PHPMailer::isValidHost($h), 'Good hostname denied: ' . $h);\n        }\n        foreach ($bad as $h) {\n            self::assertFalse(PHPMailer::isValidHost($h), 'Bad hostname accepted: ' . var_export($h, true));\n        }\n    }\n\n    /**\n     * Tests the Custom header getter.\n     */\n    public function testCustomHeaderGetter()\n    {\n        $this->Mail->addCustomHeader('foo', 'bar');\n        self::assertEquals([['foo', 'bar']], $this->Mail->getCustomHeaders());\n\n        $this->Mail->addCustomHeader('foo', 'baz');\n        self::assertEquals(\n            [\n                ['foo', 'bar'],\n                ['foo', 'baz'],\n            ],\n            $this->Mail->getCustomHeaders()\n        );\n\n        $this->Mail->clearCustomHeaders();\n        self::assertEmpty($this->Mail->getCustomHeaders());\n\n        $this->Mail->addCustomHeader('yux');\n        self::assertEquals([['yux', '']], $this->Mail->getCustomHeaders());\n\n        $this->Mail->addCustomHeader('Content-Type: application/json');\n        self::assertEquals(\n            [\n                ['yux', ''],\n                ['Content-Type', 'application/json'],\n            ],\n            $this->Mail->getCustomHeaders()\n        );\n        $this->Mail->clearCustomHeaders();\n        $this->Mail->addCustomHeader('SomeHeader: Some Value');\n        $headers = $this->Mail->getCustomHeaders();\n        self::assertEquals($headers[0], ['SomeHeader', 'Some Value']);\n        $this->Mail->clearCustomHeaders();\n        $this->Mail->addCustomHeader('SomeHeader', 'Some Value');\n        $headers = $this->Mail->getCustomHeaders();\n        self::assertEquals($headers[0], ['SomeHeader', 'Some Value']);\n        $this->Mail->clearCustomHeaders();\n        self::assertFalse($this->Mail->addCustomHeader('SomeHeader', \"Some\\n Value\"));\n        self::assertFalse($this->Mail->addCustomHeader(\"Some\\nHeader\", 'Some Value'));\n    }\n\n    /**\n     * Tests setting and retrieving ConfirmReadingTo address, also known as \"read receipt\" address.\n     */\n    public function testConfirmReadingTo()\n    {\n        $this->Mail->CharSet = PHPMailer::CHARSET_UTF8;\n        $this->buildBody();\n\n        $this->Mail->ConfirmReadingTo = 'test@example..com';  //Invalid address\n        self::assertFalse($this->Mail->send(), $this->Mail->ErrorInfo);\n\n        $this->Mail->ConfirmReadingTo = ' test@example.com';  //Extra space to trim\n        self::assertTrue($this->Mail->send(), $this->Mail->ErrorInfo);\n        self::assertEquals(\n            'test@example.com',\n            $this->Mail->ConfirmReadingTo,\n            'Unexpected read receipt address'\n        );\n\n        $letter = html_entity_decode('&ccedil;', ENT_COMPAT, PHPMailer::CHARSET_UTF8);\n        $this->Mail->ConfirmReadingTo = 'test@fran' . $letter . 'ois.ch';  //Address with IDN\n        if (PHPMailer::idnSupported()) {\n            self::assertTrue($this->Mail->send(), $this->Mail->ErrorInfo);\n            self::assertEquals(\n                'test@xn--franois-xxa.ch',\n                $this->Mail->ConfirmReadingTo,\n                'IDN address not converted to punycode'\n            );\n        } else {\n            self::assertFalse($this->Mail->send(), $this->Mail->ErrorInfo);\n        }\n    }\n\n    /**\n     * Tests CharSet and Unicode -> ASCII conversions for addresses with IDN.\n     */\n    public function testConvertEncoding()\n    {\n        if (!PHPMailer::idnSupported()) {\n            self::markTestSkipped('intl and/or mbstring extensions are not available');\n        }\n\n        $this->Mail->clearAllRecipients();\n        $this->Mail->clearReplyTos();\n\n        //This file is UTF-8 encoded. Create a domain encoded in \"iso-8859-1\".\n        $letter = html_entity_decode('&ccedil;', ENT_COMPAT, PHPMailer::CHARSET_ISO88591);\n        $domain = '@' . 'fran' . $letter . 'ois.ch';\n        $this->Mail->addAddress('test' . $domain);\n        $this->Mail->addCC('test+cc' . $domain);\n        $this->Mail->addBCC('test+bcc' . $domain);\n        $this->Mail->addReplyTo('test+replyto' . $domain);\n\n        //Queued addresses are not returned by get*Addresses() before send() call.\n        self::assertEmpty($this->Mail->getToAddresses(), 'Bad \"to\" recipients');\n        self::assertEmpty($this->Mail->getCcAddresses(), 'Bad \"cc\" recipients');\n        self::assertEmpty($this->Mail->getBccAddresses(), 'Bad \"bcc\" recipients');\n        self::assertEmpty($this->Mail->getReplyToAddresses(), 'Bad \"reply-to\" recipients');\n\n        //Clear queued BCC recipient.\n        $this->Mail->clearBCCs();\n\n        $this->buildBody();\n        self::assertTrue($this->Mail->send(), $this->Mail->ErrorInfo);\n\n        //Addresses with IDN are returned by get*Addresses() after send() call.\n        $domain = $this->Mail->punyencodeAddress($domain);\n        self::assertEquals(\n            [['test' . $domain, '']],\n            $this->Mail->getToAddresses(),\n            'Bad \"to\" recipients'\n        );\n        self::assertEquals(\n            [['test+cc' . $domain, '']],\n            $this->Mail->getCcAddresses(),\n            'Bad \"cc\" recipients'\n        );\n        self::assertEmpty($this->Mail->getBccAddresses(), 'Bad \"bcc\" recipients');\n        self::assertEquals(\n            ['test+replyto' . $domain => ['test+replyto' . $domain, '']],\n            $this->Mail->getReplyToAddresses(),\n            'Bad \"reply-to\" addresses'\n        );\n    }\n\n    /**\n     * Tests removal of duplicate recipients and reply-tos.\n     */\n    public function testDuplicateIDNRemoved()\n    {\n        if (!PHPMailer::idnSupported()) {\n            self::markTestSkipped('intl and/or mbstring extensions are not available');\n        }\n\n        $this->Mail->clearAllRecipients();\n        $this->Mail->clearReplyTos();\n\n        $this->Mail->CharSet = PHPMailer::CHARSET_UTF8;\n\n        self::assertTrue($this->Mail->addAddress('test@fran\u00e7ois.ch'));\n        self::assertFalse($this->Mail->addAddress('test@fran\u00e7ois.ch'));\n        self::assertTrue($this->Mail->addAddress('test@FRAN\u00c7OIS.CH'));\n        self::assertFalse($this->Mail->addAddress('test@FRAN\u00c7OIS.CH'));\n        self::assertTrue($this->Mail->addAddress('test@xn--franois-xxa.ch'));\n        self::assertFalse($this->Mail->addAddress('test@xn--franois-xxa.ch'));\n        self::assertFalse($this->Mail->addAddress('test@XN--FRANOIS-XXA.CH'));\n\n        self::assertTrue($this->Mail->addReplyTo('test+replyto@fran\u00e7ois.ch'));\n        self::assertFalse($this->Mail->addReplyTo('test+replyto@fran\u00e7ois.ch'));\n        self::assertTrue($this->Mail->addReplyTo('test+replyto@FRAN\u00c7OIS.CH'));\n        self::assertFalse($this->Mail->addReplyTo('test+replyto@FRAN\u00c7OIS.CH'));\n        self::assertTrue($this->Mail->addReplyTo('test+replyto@xn--franois-xxa.ch'));\n        self::assertFalse($this->Mail->addReplyTo('test+replyto@xn--franois-xxa.ch'));\n        self::assertFalse($this->Mail->addReplyTo('test+replyto@XN--FRANOIS-XXA.CH'));\n\n        $this->buildBody();\n        self::assertTrue($this->Mail->send(), $this->Mail->ErrorInfo);\n\n        //There should be only one \"To\" address and one \"Reply-To\" address.\n        self::assertCount(\n            1,\n            $this->Mail->getToAddresses(),\n            'Bad count of \"to\" recipients'\n        );\n        self::assertCount(\n            1,\n            $this->Mail->getReplyToAddresses(),\n            'Bad count of \"reply-to\" addresses'\n        );\n    }\n\n    /**\n     * Use a fake POP3 server to test POP-before-SMTP auth with a known-good login.\n     *\n     * @group pop3\n     */\n    public function testPopBeforeSmtpGood()\n    {\n        //Start a fake POP server\n        $pid = shell_exec(\n            '/usr/bin/nohup ' .\n            $this->INCLUDE_DIR .\n            '/test/runfakepopserver.sh 1100 >/dev/null 2>/dev/null & printf \"%u\" $!'\n        );\n        $this->pids[] = $pid;\n\n        sleep(1);\n        //Test a known-good login\n        self::assertTrue(\n            POP3::popBeforeSmtp('localhost', 1100, 10, 'user', 'test', $this->Mail->SMTPDebug),\n            'POP before SMTP failed'\n        );\n        //Kill the fake server, don't care if it fails\n        @shell_exec('kill -TERM ' . escapeshellarg($pid));\n        sleep(2);\n    }\n\n    /**\n     * Use a fake POP3 server to test POP-before-SMTP auth\n     * with a known-bad login.\n     *\n     * @group pop3\n     */\n    public function testPopBeforeSmtpBad()\n    {\n        //Start a fake POP server on a different port\n        //so we don't inadvertently connect to the previous instance\n        $pid = shell_exec(\n            '/usr/bin/nohup ' .\n            $this->INCLUDE_DIR .\n            '/test/runfakepopserver.sh 1101 >/dev/null 2>/dev/null & printf \"%u\" $!'\n        );\n        $this->pids[] = $pid;\n\n        sleep(2);\n        //Test a known-bad login\n        self::assertFalse(\n            POP3::popBeforeSmtp('localhost', 1101, 10, 'user', 'xxx', $this->Mail->SMTPDebug),\n            'POP before SMTP should have failed'\n        );\n        //Kill the fake server, don't care if it fails\n        @shell_exec('kill -TERM ' . escapeshellarg($pid));\n        sleep(2);\n    }\n\n    /**\n     * Test SMTP host connections.\n     * This test can take a long time, so run it last.\n     *\n     * @group slow\n     */\n    public function testSmtpConnect()\n    {\n        $this->Mail->SMTPDebug = SMTP::DEBUG_LOWLEVEL; //Show connection-level errors\n        self::assertTrue($this->Mail->smtpConnect(), 'SMTP single connect failed');\n        $this->Mail->smtpClose();\n\n        //$this->Mail->Host = 'localhost:12345;10.10.10.10:54321;' . $_REQUEST['mail_host'];\n        //self::assertTrue($this->Mail->smtpConnect(), 'SMTP multi-connect failed');\n        //$this->Mail->smtpClose();\n        //$this->Mail->Host = '[::1]:' . $this->Mail->Port . ';' . $_REQUEST['mail_host'];\n        //self::assertTrue($this->Mail->smtpConnect(), 'SMTP IPv6 literal multi-connect failed');\n        //$this->Mail->smtpClose();\n\n        //All these hosts are expected to fail\n        //$this->Mail->Host = 'xyz://bogus:25;tls://[bogus]:25;ssl://localhost:12345;\n        //tls://localhost:587;10.10.10.10:54321;localhost:12345;10.10.10.10'. $_REQUEST['mail_host'].' ';\n        //self::assertFalse($this->Mail->smtpConnect());\n        //$this->Mail->smtpClose();\n\n        $this->Mail->Host = ' localhost:12345 ; ' . $_REQUEST['mail_host'] . ' ';\n        self::assertTrue($this->Mail->smtpConnect(), 'SMTP hosts with stray spaces failed');\n        $this->Mail->smtpClose();\n\n        //Need to pick a harmless option so as not cause problems of its own! socket:bind doesn't work with Travis-CI\n        $this->Mail->Host = $_REQUEST['mail_host'];\n        self::assertTrue($this->Mail->smtpConnect(['ssl' => ['verify_depth' => 10]]));\n\n        $this->Smtp = $this->Mail->getSMTPInstance();\n        self::assertInstanceOf(\\get_class($this->Smtp), $this->Mail->setSMTPInstance($this->Smtp));\n        self::assertFalse($this->Smtp->startTLS(), 'SMTP connect with options failed');\n        self::assertFalse($this->Mail->SMTPAuth);\n        $this->Mail->smtpClose();\n    }\n\n    /**\n     * Test OAuth method\n     */\n    public function testOAuth()\n    {\n        $PHPMailer = new PHPMailer();\n        $reflection = new \\ReflectionClass($PHPMailer);\n        $property = $reflection->getProperty('oauth');\n        $property->setAccessible(true);\n        $property->setValue($PHPMailer, true);\n        self::assertTrue($PHPMailer->getOAuth());\n\n        $options = [\n            'provider' => 'dummyprovider',\n            'userName' => 'dummyusername',\n            'clientSecret' => 'dummyclientsecret',\n            'clientId' => 'dummyclientid',\n            'refreshToken' => 'dummyrefreshtoken',\n        ];\n\n        $oauth = new OAuth($options);\n        self::assertInstanceOf(OAuth::class, $oauth);\n        $subject = $PHPMailer->setOAuth($oauth);\n        self::assertNull($subject);\n        self::assertInstanceOf(OAuth::class, $PHPMailer->getOAuth());\n    }\n\n    /**\n     * Test ICal method\n     */\n    public function testICalMethod()\n    {\n        $this->Mail->Subject .= ': ICal method';\n        $this->Mail->Body = '<h3>ICal method test.</h3>';\n        $this->Mail->AltBody = 'ICal method test.';\n        $this->Mail->Ical = 'BEGIN:VCALENDAR'\n            . \"\\r\\nVERSION:2.0\"\n            . \"\\r\\nPRODID:-//PHPMailer//PHPMailer Calendar Plugin 1.0//EN\"\n            . \"\\r\\nMETHOD:CANCEL\"\n            . \"\\r\\nCALSCALE:GREGORIAN\"\n            . \"\\r\\nX-MICROSOFT-CALSCALE:GREGORIAN\"\n            . \"\\r\\nBEGIN:VEVENT\"\n            . \"\\r\\nUID:201909250755-42825@test\"\n            . \"\\r\\nDTSTART;20190930T080000Z\"\n            . \"\\r\\nSEQUENCE:2\"\n            . \"\\r\\nTRANSP:OPAQUE\"\n            . \"\\r\\nSTATUS:CONFIRMED\"\n            . \"\\r\\nDTEND:20190930T084500Z\"\n            . \"\\r\\nLOCATION:[London] London Eye\"\n            . \"\\r\\nSUMMARY:Test ICal method\"\n            . \"\\r\\nATTENDEE;CN=Attendee, Test;ROLE=OPT-PARTICIPANT;PARTSTAT=NEEDS-ACTION;RSVP=\"\n            . \"\\r\\n TRUE:MAILTO:attendee-test@example.com\"\n            . \"\\r\\nCLASS:PUBLIC\"\n            . \"\\r\\nDESCRIPTION:Some plain text\"\n            . \"\\r\\nORGANIZER;CN=\\\"Example, Test\\\":MAILTO:test@example.com\"\n            . \"\\r\\nDTSTAMP:20190925T075546Z\"\n            . \"\\r\\nCREATED:20190925T075709Z\"\n            . \"\\r\\nLAST-MODIFIED:20190925T075546Z\"\n            . \"\\r\\nEND:VEVENT\"\n            . \"\\r\\nEND:VCALENDAR\";\n        $this->buildBody();\n        $this->Mail->preSend();\n        self::assertMatchesRegularExpression(\n            '/Content-Type: text\\/calendar; method=CANCEL;/',\n            $this->Mail->getSentMIMEMessage(),\n            'Wrong ICal method in Content-Type header'\n        );\n    }\n\n    /**\n     * Test ICal missing method to use default (REQUEST)\n     */\n    public function testICalInvalidMethod()\n    {\n        $this->Mail->Subject .= ': ICal method';\n        $this->Mail->Body = '<h3>ICal method test.</h3>';\n        $this->Mail->AltBody = 'ICal method test.';\n        $this->Mail->Ical = 'BEGIN:VCALENDAR'\n            . \"\\r\\nVERSION:2.0\"\n            . \"\\r\\nPRODID:-//PHPMailer//PHPMailer Calendar Plugin 1.0//EN\"\n            . \"\\r\\nMETHOD:INVALID\"\n            . \"\\r\\nCALSCALE:GREGORIAN\"\n            . \"\\r\\nX-MICROSOFT-CALSCALE:GREGORIAN\"\n            . \"\\r\\nBEGIN:VEVENT\"\n            . \"\\r\\nUID:201909250755-42825@test\"\n            . \"\\r\\nDTSTART;20190930T080000Z\"\n            . \"\\r\\nSEQUENCE:2\"\n            . \"\\r\\nTRANSP:OPAQUE\"\n            . \"\\r\\nSTATUS:CONFIRMED\"\n            . \"\\r\\nDTEND:20190930T084500Z\"\n            . \"\\r\\nLOCATION:[London] London Eye\"\n            . \"\\r\\nSUMMARY:Test ICal method\"\n            . \"\\r\\nATTENDEE;CN=Attendee, Test;ROLE=OPT-PARTICIPANT;PARTSTAT=NEEDS-ACTION;RSVP=\"\n            . \"\\r\\n TRUE:MAILTO:attendee-test@example.com\"\n            . \"\\r\\nCLASS:PUBLIC\"\n            . \"\\r\\nDESCRIPTION:Some plain text\"\n            . \"\\r\\nORGANIZER;CN=\\\"Example, Test\\\":MAILTO:test@example.com\"\n            . \"\\r\\nDTSTAMP:20190925T075546Z\"\n            . \"\\r\\nCREATED:20190925T075709Z\"\n            . \"\\r\\nLAST-MODIFIED:20190925T075546Z\"\n            . \"\\r\\nEND:VEVENT\"\n            . \"\\r\\nEND:VCALENDAR\";\n        $this->buildBody();\n        $this->Mail->preSend();\n        self::assertMatchesRegularExpression(\n            '/Content-Type: text\\/calendar; method=REQUEST;/',\n            $this->Mail->getSentMIMEMessage(),\n            'Wrong ICal method in Content-Type header'\n        );\n    }\n\n    /**\n     * Test ICal invalid method to use default (REQUEST)\n     */\n    public function testICalDefaultMethod()\n    {\n        $this->Mail->Subject .= ': ICal method';\n        $this->Mail->Body = '<h3>ICal method test.</h3>';\n        $this->Mail->AltBody = 'ICal method test.';\n        $this->Mail->Ical = 'BEGIN:VCALENDAR'\n            . \"\\r\\nVERSION:2.0\"\n            . \"\\r\\nPRODID:-//PHPMailer//PHPMailer Calendar Plugin 1.0//EN\"\n            . \"\\r\\nCALSCALE:GREGORIAN\"\n            . \"\\r\\nX-MICROSOFT-CALSCALE:GREGORIAN\"\n            . \"\\r\\nBEGIN:VEVENT\"\n            . \"\\r\\nUID:201909250755-42825@test\"\n            . \"\\r\\nDTSTART;20190930T080000Z\"\n            . \"\\r\\nSEQUENCE:2\"\n            . \"\\r\\nTRANSP:OPAQUE\"\n            . \"\\r\\nSTATUS:CONFIRMED\"\n            . \"\\r\\nDTEND:20190930T084500Z\"\n            . \"\\r\\nLOCATION:[London] London Eye\"\n            . \"\\r\\nSUMMARY:Test ICal method\"\n            . \"\\r\\nATTENDEE;CN=Attendee, Test;ROLE=OPT-PARTICIPANT;PARTSTAT=NEEDS-ACTION;RSVP=\"\n            . \"\\r\\n TRUE:MAILTO:attendee-test@example.com\"\n            . \"\\r\\nCLASS:PUBLIC\"\n            . \"\\r\\nDESCRIPTION:Some plain text\"\n            . \"\\r\\nORGANIZER;CN=\\\"Example, Test\\\":MAILTO:test@example.com\"\n            . \"\\r\\nDTSTAMP:20190925T075546Z\"\n            . \"\\r\\nCREATED:20190925T075709Z\"\n            . \"\\r\\nLAST-MODIFIED:20190925T075546Z\"\n            . \"\\r\\nEND:VEVENT\"\n            . \"\\r\\nEND:VCALENDAR\";\n        $this->buildBody();\n        $this->Mail->preSend();\n        self::assertMatchesRegularExpression(\n            '/Content-Type: text\\/calendar; method=REQUEST;/',\n            $this->Mail->getSentMIMEMessage(),\n            'Wrong ICal method in Content-Type header'\n        );\n    }\n\n    /**\n     * @test\n     */\n    public function givenIdnAddress_addAddress_returns_true()\n    {\n        if (file_exists($this->INCLUDE_DIR . '/test/fakefunctions.php')) {\n            include $this->INCLUDE_DIR . '/test/fakefunctions.php';\n            $this->assertTrue($this->Mail->addAddress('test@fran\u00e7ois.ch'));\n        }\n    }\n\n    /**\n     * @test\n     */\n    public function givenIdnAddress_addReplyTo_returns_true()\n    {\n        if (file_exists($this->INCLUDE_DIR . '/test/fakefunctions.php')) {\n            include $this->INCLUDE_DIR . '/test/fakefunctions.php';\n            $this->assertTrue($this->Mail->addReplyTo('test@fran\u00e7ois.ch'));\n        }\n    }\n\n    /**\n     * @test\n     */\n    public function erroneousAddress_addAddress_returns_false()\n    {\n        $this->assertFalse($this->Mail->addAddress('mehome.com'));\n    }\n\n    /**\n     * Test RFC822 address list parsing using PHPMailer's parser.\n     * @test\n     */\n    public function imapParsedAddressList_parseAddress_returnsAddressArray()\n    {\n        $addressLine = 'joe@example.com, <me@example.com>, Joe Doe <doe@example.com>,' .\n            ' \"John O\\'Groats\" <johnog@example.net>,' .\n            ' =?utf-8?B?0J3QsNC30LLQsNC90LjQtSDRgtC10YHRgtCw?= <encoded@example.org>';\n\n        //Test using PHPMailer's own parser\n        $expected = [\n            [\n                'name' => '',\n                'address' => 'joe@example.com',\n            ],\n            [\n                'name' => '',\n                'address' => 'me@example.com',\n            ],\n            [\n                'name' => 'Joe Doe',\n                'address' => 'doe@example.com',\n            ],\n            [\n                'name' => \"John O'Groats\",\n                'address' => 'johnog@example.net',\n            ],\n            [\n                'name' => '\u041d\u0430\u0437\u0432\u0430\u043d\u0438\u0435 \u0442\u0435\u0441\u0442\u0430',\n                'address' => 'encoded@example.org',\n            ],\n        ];\n        $parsed = PHPMailer::parseAddresses($addressLine, false);\n        $this->assertSameSize($expected, $parsed);\n        for ($i = 0; $i < count($expected); $i++) {\n            $this->assertSame($expected[$i], $parsed[$i]);\n        }\n    }\n\n    /**\n     * Test RFC822 address list parsing using the IMAP extension's parser.\n     * @test\n     */\n    public function imapParsedAddressList_parseAddress_returnsAddressArray_usingImap()\n    {\n        if (!extension_loaded('imap')) {\n            $this->markTestSkipped(\"imap extension missing, can't run this test\");\n        }\n        $addressLine = 'joe@example.com, <me@example.com>, Joe Doe <doe@example.com>,' .\n            ' \"John O\\'Groats\" <johnog@example.net>,' .\n            ' =?utf-8?B?0J3QsNC30LLQsNC90LjQtSDRgtC10YHRgtCw?= <encoded@example.org>';\n        $expected = [\n            [\n                'name' => '',\n                'address' => 'joe@example.com',\n            ],\n            [\n                'name' => '',\n                'address' => 'me@example.com',\n            ],\n            [\n                'name' => 'Joe Doe',\n                'address' => 'doe@example.com',\n            ],\n            [\n                'name' => \"John O'Groats\",\n                'address' => 'johnog@example.net',\n            ],\n            [\n                'name' => '\u041d\u0430\u0437\u0432\u0430\u043d\u0438\u0435 \u0442\u0435\u0441\u0442\u0430',\n                'address' => 'encoded@example.org',\n            ],\n        ];\n        $parsed = PHPMailer::parseAddresses($addressLine, true);\n        $this->assertSameSize($expected, $parsed);\n        for ($i = 0; $i < count($expected); $i++) {\n            $this->assertSame($expected[$i], $parsed[$i]);\n        }\n    }\n\n    /**\n     * @test\n     */\n    public function givenIdnAddress_punyencodeAddress_returnsCorrectCode()\n    {\n        if (file_exists($this->INCLUDE_DIR . '/test/fakefunctions.php')) {\n            include $this->INCLUDE_DIR . '/test/fakefunctions.php';\n            //This source file is in UTF-8, so characters here are in native charset\n            $this->Mail->CharSet = PHPMailer::CHARSET_UTF8;\n            $result = $this->Mail->punyencodeAddress(\n                html_entity_decode('test@fran&ccedil;ois.ch', ENT_COMPAT, PHPMailer::CHARSET_UTF8)\n            );\n            $this->assertEquals('test@xn--franois-xxa.ch', $result);\n            //To force working another charset, decode an ASCII string to avoid literal string charset issues\n            $this->Mail->CharSet = PHPMailer::CHARSET_ISO88591;\n            $result = $this->Mail->punyencodeAddress(\n                html_entity_decode('test@fran&ccedil;ois.ch', ENT_COMPAT, PHPMailer::CHARSET_ISO88591)\n            );\n            $this->assertEquals('test@xn--franois-xxa.ch', $result);\n        }\n    }\n\n    /**\n     * @test\n     */\n    public function veryLongWordInMessage_wrapText_returnsWrappedText()\n    {\n        $message = 'Lorem ipsumdolorsitametconsetetursadipscingelitrseddiamnonumy';\n        $expected = 'Lorem' . PHPMailer::getLE() .\n            'ipsumdolorsitametconsetetursadipscingelitrseddiamnonumy' . PHPMailer::getLE();\n        $expectedqp = 'Lorem ipsumdolorsitametconsetetursadipscingelitrs=' .\n            PHPMailer::getLE() . 'eddiamnonumy' . PHPMailer::getLE();\n        $this->assertEquals($this->Mail->wrapText($message, 50, true), $expectedqp);\n        $this->assertEquals($this->Mail->wrapText($message, 50, false), $expected);\n    }\n\n    /**\n     * @test\n     */\n    public function encodedText_utf8CharBoundary_returnsCorrectMaxLength()\n    {\n        $encodedWordWithMultiByteCharFirstByte = 'H=E4tten';\n        $encodedSingleByteCharacter = '=0C';\n        $encodedWordWithMultiByteCharMiddletByte = 'L=C3=B6rem';\n\n        $this->assertEquals(1, $this->Mail->utf8CharBoundary($encodedWordWithMultiByteCharFirstByte, 3));\n        $this->assertEquals(3, $this->Mail->utf8CharBoundary($encodedSingleByteCharacter, 3));\n        $this->assertEquals(1, $this->Mail->utf8CharBoundary($encodedWordWithMultiByteCharMiddletByte, 6));\n    }\n}\n/*\n * This is a sample form for setting appropriate test values through a browser\n * These values can also be set using a file called testbootstrap.php (not in repo) in the same folder as this script\n * which is probably more useful if you run these tests a lot\n * <html>\n * <body>\n * <h3>PHPMailer Unit Test</h3>\n * By entering a SMTP hostname it will automatically perform tests with SMTP.\n *\n * <form name=\"phpmailer_unit\" action=__FILE__ method=\"get\">\n * <input type=\"hidden\" name=\"submitted\" value=\"1\"/>\n * From Address: <input type=\"text\" size=\"50\" name=\"mail_from\" value=\"<?php echo get(\"mail_from\"); ?>\"/>\n * <br/>\n * To Address: <input type=\"text\" size=\"50\" name=\"mail_to\" value=\"<?php echo get(\"mail_to\"); ?>\"/>\n * <br/>\n * Cc Address: <input type=\"text\" size=\"50\" name=\"mail_cc\" value=\"<?php echo get(\"mail_cc\"); ?>\"/>\n * <br/>\n * SMTP Hostname: <input type=\"text\" size=\"50\" name=\"mail_host\" value=\"<?php echo get(\"mail_host\"); ?>\"/>\n * <p/>\n * <input type=\"submit\" value=\"Run Test\"/>\n *\n * </form>\n * </body>\n * </html>\n */\n"], "fixing_code": ["# Security notices relating to PHPMailer\n\nPlease disclose any security issues or vulnerabilities found through [Tidelift's coordinated disclosure system](https://tidelift.com/security) or to the maintainers privately.\n\nPHPMailer 6.4.1 and earlier contain a vulnerability that can result in untrusted code being called (if such code is injected into the host project's scope by other means). If the `$patternselect` parameter to `validateAddress()` is set to `'php'` (the default, defined by `static::$validator`), and the global namespace contains a function called `php`, it will be called in preference to the built-in validator of the same name. This is patched in PHPMailer 6.5.0 by denying the use of simple strings as validator function names, which is a very minor BC break. Reported by [Vikrant Singh Chauhan](mailto:vi@hackberry.xyz) via [huntr.dev](https://www.huntr.dev/). Recorded as [CVE-2021-3603](https://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2021-3603).\n\nPHPMailer versions between 6.1.8 and 6.4.0 contain a regression of the earlier CVE-2018-19296 object injection vulnerability as a result of [a fix for Windows UNC paths in 6.1.8](https://github.com/PHPMailer/PHPMailer/commit/e2e07a355ee8ff36aba21d0242c5950c56e4c6f9). Recorded as [CVE-2020-36326](https://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2020-36326). Reported by Fariskhi Vidyan via Tidelift. 6.4.1 fixes this issue, and also enforces stricter checks for URL schemes in local path contexts.\n\nPHPMailer versions 6.1.5 and earlier contain an output escaping bug that occurs in `Content-Type` and `Content-Disposition` when filenames passed into `addAttachment` and other methods that accept attachment names contain double quote characters, in contravention of RFC822 3.4.1. No specific vulnerability has been found relating to this, but it could allow file attachments to bypass attachment filters that are based on matching filename extensions. Recorded as [CVE-2020-13625](https://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2020-13625). Reported by Elar Lang of Clarified Security.\n\nPHPMailer versions prior to 6.0.6 and 5.2.27 are vulnerable to an object injection attack by passing `phar://` paths into `addAttachment()` and other functions that may receive unfiltered local paths, possibly leading to RCE. Recorded as [CVE-2018-19296](https://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2018-19296). See [this article](https://knasmueller.net/5-answers-about-php-phar-exploitation) for more info on this type of vulnerability. Mitigated by blocking the use of paths containing URL-protocol style prefixes such as `phar://`. Reported by Sehun Oh of cyberone.kr.\n\nPHPMailer versions prior to 5.2.24 (released July 26th 2017) have an XSS vulnerability in one of the code examples, [CVE-2017-11503](https://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2017-11503). The `code_generator.phps` example did not filter user input prior to output. This file is distributed with a `.phps` extension, so it it not normally executable unless it is explicitly renamed, and the file is not included when PHPMailer is loaded through composer, so it is safe by default. There was also an undisclosed potential XSS vulnerability in the default exception handler (unused by default). Patches for both issues kindly provided by Patrick Monnerat of the Fedora Project.\n\nPHPMailer versions prior to 5.2.22 (released January 9th 2017) have a local file disclosure vulnerability, [CVE-2017-5223](https://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2017-5223). If content passed into `msgHTML()` is sourced from unfiltered user input, relative paths can map to absolute local file paths and added as attachments. Also note that `addAttachment` (just like `file_get_contents`, `passthru`, `unlink`, etc) should not be passed user-sourced params either! Reported by Yongxiang Li of Asiasecurity.\n\nPHPMailer versions prior to 5.2.20 (released December 28th 2016) are vulnerable to [CVE-2016-10045](https://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2016-10045) a remote code execution vulnerability, responsibly reported by [Dawid Golunski](https://legalhackers.com/advisories/PHPMailer-Exploit-Remote-Code-Exec-CVE-2016-10045-Vuln-Patch-Bypass.html), and patched by Paul Buonopane (@Zenexer).\n\nPHPMailer versions prior to 5.2.18 (released December 2016) are vulnerable to [CVE-2016-10033](https://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2016-10033) a remote code execution vulnerability, responsibly reported by [Dawid Golunski](http://legalhackers.com/advisories/PHPMailer-Exploit-Remote-Code-Exec-CVE-2016-10033-Vuln.html).\n\nPHPMailer versions prior to 5.2.14 (released November 2015) are vulnerable to [CVE-2015-8476](https://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2015-8476) an SMTP CRLF injection bug permitting arbitrary message sending.\n\nPHPMailer versions prior to 5.2.10 (released May 2015) are vulnerable to [CVE-2008-5619](https://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2008-5619), a remote code execution vulnerability in the bundled html2text library. This file was removed in 5.2.10, so if you are using a version prior to that and make use of the html2text function, it's vitally important that you upgrade and remove this file.\n\nPHPMailer versions prior to 2.0.7 and 2.2.1 are vulnerable to [CVE-2012-0796](https://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2012-0796), an email header injection attack.\n\nJoomla 1.6.0 uses PHPMailer in an unsafe way, allowing it to reveal local file paths, reported in [CVE-2011-3747](https://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2011-3747).\n\nPHPMailer didn't sanitise the `$lang_path` parameter in `SetLanguage`. This wasn't a problem in itself, but some apps (PHPClassifieds, ATutor) also failed to sanitise user-provided parameters passed to it, permitting semi-arbitrary local file inclusion, reported in [CVE-2010-4914](https://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2010-4914), [CVE-2007-2021](https://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2007-2021) and [CVE-2006-5734](https://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2006-5734).\n\nPHPMailer 1.7.2 and earlier contained a possible DDoS vulnerability reported in [CVE-2005-1807](https://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2005-1807).\n\nPHPMailer 1.7 and earlier (June 2003) have a possible vulnerability in the `SendmailSend` method where shell commands may not be sanitised. Reported in [CVE-2007-3215](https://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2007-3215).\n\n", "<?php\n\n/**\n * PHPMailer - PHP email creation and transport class.\n * PHP Version 5.5.\n *\n * @see https://github.com/PHPMailer/PHPMailer/ The PHPMailer GitHub project\n *\n * @author    Marcus Bointon (Synchro/coolbru) <phpmailer@synchromedia.co.uk>\n * @author    Jim Jagielski (jimjag) <jimjag@gmail.com>\n * @author    Andy Prevost (codeworxtech) <codeworxtech@users.sourceforge.net>\n * @author    Brent R. Matzelle (original founder)\n * @copyright 2012 - 2020 Marcus Bointon\n * @copyright 2010 - 2012 Jim Jagielski\n * @copyright 2004 - 2009 Andy Prevost\n * @license   http://www.gnu.org/copyleft/lesser.html GNU Lesser General Public License\n * @note      This program is distributed in the hope that it will be useful - WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.\n */\n\nnamespace PHPMailer\\PHPMailer;\n\n/**\n * PHPMailer - PHP email creation and transport class.\n *\n * @author Marcus Bointon (Synchro/coolbru) <phpmailer@synchromedia.co.uk>\n * @author Jim Jagielski (jimjag) <jimjag@gmail.com>\n * @author Andy Prevost (codeworxtech) <codeworxtech@users.sourceforge.net>\n * @author Brent R. Matzelle (original founder)\n */\nclass PHPMailer\n{\n    const CHARSET_ASCII = 'us-ascii';\n    const CHARSET_ISO88591 = 'iso-8859-1';\n    const CHARSET_UTF8 = 'utf-8';\n\n    const CONTENT_TYPE_PLAINTEXT = 'text/plain';\n    const CONTENT_TYPE_TEXT_CALENDAR = 'text/calendar';\n    const CONTENT_TYPE_TEXT_HTML = 'text/html';\n    const CONTENT_TYPE_MULTIPART_ALTERNATIVE = 'multipart/alternative';\n    const CONTENT_TYPE_MULTIPART_MIXED = 'multipart/mixed';\n    const CONTENT_TYPE_MULTIPART_RELATED = 'multipart/related';\n\n    const ENCODING_7BIT = '7bit';\n    const ENCODING_8BIT = '8bit';\n    const ENCODING_BASE64 = 'base64';\n    const ENCODING_BINARY = 'binary';\n    const ENCODING_QUOTED_PRINTABLE = 'quoted-printable';\n\n    const ENCRYPTION_STARTTLS = 'tls';\n    const ENCRYPTION_SMTPS = 'ssl';\n\n    const ICAL_METHOD_REQUEST = 'REQUEST';\n    const ICAL_METHOD_PUBLISH = 'PUBLISH';\n    const ICAL_METHOD_REPLY = 'REPLY';\n    const ICAL_METHOD_ADD = 'ADD';\n    const ICAL_METHOD_CANCEL = 'CANCEL';\n    const ICAL_METHOD_REFRESH = 'REFRESH';\n    const ICAL_METHOD_COUNTER = 'COUNTER';\n    const ICAL_METHOD_DECLINECOUNTER = 'DECLINECOUNTER';\n\n    /**\n     * Email priority.\n     * Options: null (default), 1 = High, 3 = Normal, 5 = low.\n     * When null, the header is not set at all.\n     *\n     * @var int|null\n     */\n    public $Priority;\n\n    /**\n     * The character set of the message.\n     *\n     * @var string\n     */\n    public $CharSet = self::CHARSET_ISO88591;\n\n    /**\n     * The MIME Content-type of the message.\n     *\n     * @var string\n     */\n    public $ContentType = self::CONTENT_TYPE_PLAINTEXT;\n\n    /**\n     * The message encoding.\n     * Options: \"8bit\", \"7bit\", \"binary\", \"base64\", and \"quoted-printable\".\n     *\n     * @var string\n     */\n    public $Encoding = self::ENCODING_8BIT;\n\n    /**\n     * Holds the most recent mailer error message.\n     *\n     * @var string\n     */\n    public $ErrorInfo = '';\n\n    /**\n     * The From email address for the message.\n     *\n     * @var string\n     */\n    public $From = 'root@localhost';\n\n    /**\n     * The From name of the message.\n     *\n     * @var string\n     */\n    public $FromName = 'Root User';\n\n    /**\n     * The envelope sender of the message.\n     * This will usually be turned into a Return-Path header by the receiver,\n     * and is the address that bounces will be sent to.\n     * If not empty, will be passed via `-f` to sendmail or as the 'MAIL FROM' value over SMTP.\n     *\n     * @var string\n     */\n    public $Sender = '';\n\n    /**\n     * The Subject of the message.\n     *\n     * @var string\n     */\n    public $Subject = '';\n\n    /**\n     * An HTML or plain text message body.\n     * If HTML then call isHTML(true).\n     *\n     * @var string\n     */\n    public $Body = '';\n\n    /**\n     * The plain-text message body.\n     * This body can be read by mail clients that do not have HTML email\n     * capability such as mutt & Eudora.\n     * Clients that can read HTML will view the normal Body.\n     *\n     * @var string\n     */\n    public $AltBody = '';\n\n    /**\n     * An iCal message part body.\n     * Only supported in simple alt or alt_inline message types\n     * To generate iCal event structures, use classes like EasyPeasyICS or iCalcreator.\n     *\n     * @see http://sprain.ch/blog/downloads/php-class-easypeasyics-create-ical-files-with-php/\n     * @see http://kigkonsult.se/iCalcreator/\n     *\n     * @var string\n     */\n    public $Ical = '';\n\n    /**\n     * Value-array of \"method\" in Contenttype header \"text/calendar\"\n     *\n     * @var string[]\n     */\n    protected static $IcalMethods = [\n        self::ICAL_METHOD_REQUEST,\n        self::ICAL_METHOD_PUBLISH,\n        self::ICAL_METHOD_REPLY,\n        self::ICAL_METHOD_ADD,\n        self::ICAL_METHOD_CANCEL,\n        self::ICAL_METHOD_REFRESH,\n        self::ICAL_METHOD_COUNTER,\n        self::ICAL_METHOD_DECLINECOUNTER,\n    ];\n\n    /**\n     * The complete compiled MIME message body.\n     *\n     * @var string\n     */\n    protected $MIMEBody = '';\n\n    /**\n     * The complete compiled MIME message headers.\n     *\n     * @var string\n     */\n    protected $MIMEHeader = '';\n\n    /**\n     * Extra headers that createHeader() doesn't fold in.\n     *\n     * @var string\n     */\n    protected $mailHeader = '';\n\n    /**\n     * Word-wrap the message body to this number of chars.\n     * Set to 0 to not wrap. A useful value here is 78, for RFC2822 section 2.1.1 compliance.\n     *\n     * @see static::STD_LINE_LENGTH\n     *\n     * @var int\n     */\n    public $WordWrap = 0;\n\n    /**\n     * Which method to use to send mail.\n     * Options: \"mail\", \"sendmail\", or \"smtp\".\n     *\n     * @var string\n     */\n    public $Mailer = 'mail';\n\n    /**\n     * The path to the sendmail program.\n     *\n     * @var string\n     */\n    public $Sendmail = '/usr/sbin/sendmail';\n\n    /**\n     * Whether mail() uses a fully sendmail-compatible MTA.\n     * One which supports sendmail's \"-oi -f\" options.\n     *\n     * @var bool\n     */\n    public $UseSendmailOptions = true;\n\n    /**\n     * The email address that a reading confirmation should be sent to, also known as read receipt.\n     *\n     * @var string\n     */\n    public $ConfirmReadingTo = '';\n\n    /**\n     * The hostname to use in the Message-ID header and as default HELO string.\n     * If empty, PHPMailer attempts to find one with, in order,\n     * $_SERVER['SERVER_NAME'], gethostname(), php_uname('n'), or the value\n     * 'localhost.localdomain'.\n     *\n     * @see PHPMailer::$Helo\n     *\n     * @var string\n     */\n    public $Hostname = '';\n\n    /**\n     * An ID to be used in the Message-ID header.\n     * If empty, a unique id will be generated.\n     * You can set your own, but it must be in the format \"<id@domain>\",\n     * as defined in RFC5322 section 3.6.4 or it will be ignored.\n     *\n     * @see https://tools.ietf.org/html/rfc5322#section-3.6.4\n     *\n     * @var string\n     */\n    public $MessageID = '';\n\n    /**\n     * The message Date to be used in the Date header.\n     * If empty, the current date will be added.\n     *\n     * @var string\n     */\n    public $MessageDate = '';\n\n    /**\n     * SMTP hosts.\n     * Either a single hostname or multiple semicolon-delimited hostnames.\n     * You can also specify a different port\n     * for each host by using this format: [hostname:port]\n     * (e.g. \"smtp1.example.com:25;smtp2.example.com\").\n     * You can also specify encryption type, for example:\n     * (e.g. \"tls://smtp1.example.com:587;ssl://smtp2.example.com:465\").\n     * Hosts will be tried in order.\n     *\n     * @var string\n     */\n    public $Host = 'localhost';\n\n    /**\n     * The default SMTP server port.\n     *\n     * @var int\n     */\n    public $Port = 25;\n\n    /**\n     * The SMTP HELO/EHLO name used for the SMTP connection.\n     * Default is $Hostname. If $Hostname is empty, PHPMailer attempts to find\n     * one with the same method described above for $Hostname.\n     *\n     * @see PHPMailer::$Hostname\n     *\n     * @var string\n     */\n    public $Helo = '';\n\n    /**\n     * What kind of encryption to use on the SMTP connection.\n     * Options: '', static::ENCRYPTION_STARTTLS, or static::ENCRYPTION_SMTPS.\n     *\n     * @var string\n     */\n    public $SMTPSecure = '';\n\n    /**\n     * Whether to enable TLS encryption automatically if a server supports it,\n     * even if `SMTPSecure` is not set to 'tls'.\n     * Be aware that in PHP >= 5.6 this requires that the server's certificates are valid.\n     *\n     * @var bool\n     */\n    public $SMTPAutoTLS = true;\n\n    /**\n     * Whether to use SMTP authentication.\n     * Uses the Username and Password properties.\n     *\n     * @see PHPMailer::$Username\n     * @see PHPMailer::$Password\n     *\n     * @var bool\n     */\n    public $SMTPAuth = false;\n\n    /**\n     * Options array passed to stream_context_create when connecting via SMTP.\n     *\n     * @var array\n     */\n    public $SMTPOptions = [];\n\n    /**\n     * SMTP username.\n     *\n     * @var string\n     */\n    public $Username = '';\n\n    /**\n     * SMTP password.\n     *\n     * @var string\n     */\n    public $Password = '';\n\n    /**\n     * SMTP auth type.\n     * Options are CRAM-MD5, LOGIN, PLAIN, XOAUTH2, attempted in that order if not specified.\n     *\n     * @var string\n     */\n    public $AuthType = '';\n\n    /**\n     * An instance of the PHPMailer OAuth class.\n     *\n     * @var OAuth\n     */\n    protected $oauth;\n\n    /**\n     * The SMTP server timeout in seconds.\n     * Default of 5 minutes (300sec) is from RFC2821 section 4.5.3.2.\n     *\n     * @var int\n     */\n    public $Timeout = 300;\n\n    /**\n     * Comma separated list of DSN notifications\n     * 'NEVER' under no circumstances a DSN must be returned to the sender.\n     *         If you use NEVER all other notifications will be ignored.\n     * 'SUCCESS' will notify you when your mail has arrived at its destination.\n     * 'FAILURE' will arrive if an error occurred during delivery.\n     * 'DELAY'   will notify you if there is an unusual delay in delivery, but the actual\n     *           delivery's outcome (success or failure) is not yet decided.\n     *\n     * @see https://tools.ietf.org/html/rfc3461 See section 4.1 for more information about NOTIFY\n     */\n    public $dsn = '';\n\n    /**\n     * SMTP class debug output mode.\n     * Debug output level.\n     * Options:\n     * @see SMTP::DEBUG_OFF: No output\n     * @see SMTP::DEBUG_CLIENT: Client messages\n     * @see SMTP::DEBUG_SERVER: Client and server messages\n     * @see SMTP::DEBUG_CONNECTION: As SERVER plus connection status\n     * @see SMTP::DEBUG_LOWLEVEL: Noisy, low-level data output, rarely needed\n     *\n     * @see SMTP::$do_debug\n     *\n     * @var int\n     */\n    public $SMTPDebug = 0;\n\n    /**\n     * How to handle debug output.\n     * Options:\n     * * `echo` Output plain-text as-is, appropriate for CLI\n     * * `html` Output escaped, line breaks converted to `<br>`, appropriate for browser output\n     * * `error_log` Output to error log as configured in php.ini\n     * By default PHPMailer will use `echo` if run from a `cli` or `cli-server` SAPI, `html` otherwise.\n     * Alternatively, you can provide a callable expecting two params: a message string and the debug level:\n     *\n     * ```php\n     * $mail->Debugoutput = function($str, $level) {echo \"debug level $level; message: $str\";};\n     * ```\n     *\n     * Alternatively, you can pass in an instance of a PSR-3 compatible logger, though only `debug`\n     * level output is used:\n     *\n     * ```php\n     * $mail->Debugoutput = new myPsr3Logger;\n     * ```\n     *\n     * @see SMTP::$Debugoutput\n     *\n     * @var string|callable|\\Psr\\Log\\LoggerInterface\n     */\n    public $Debugoutput = 'echo';\n\n    /**\n     * Whether to keep the SMTP connection open after each message.\n     * If this is set to true then the connection will remain open after a send,\n     * and closing the connection will require an explicit call to smtpClose().\n     * It's a good idea to use this if you are sending multiple messages as it reduces overhead.\n     * See the mailing list example for how to use it.\n     *\n     * @var bool\n     */\n    public $SMTPKeepAlive = false;\n\n    /**\n     * Whether to split multiple to addresses into multiple messages\n     * or send them all in one message.\n     * Only supported in `mail` and `sendmail` transports, not in SMTP.\n     *\n     * @var bool\n     *\n     * @deprecated 6.0.0 PHPMailer isn't a mailing list manager!\n     */\n    public $SingleTo = false;\n\n    /**\n     * Storage for addresses when SingleTo is enabled.\n     *\n     * @var array\n     */\n    protected $SingleToArray = [];\n\n    /**\n     * Whether to generate VERP addresses on send.\n     * Only applicable when sending via SMTP.\n     *\n     * @see https://en.wikipedia.org/wiki/Variable_envelope_return_path\n     * @see http://www.postfix.org/VERP_README.html Postfix VERP info\n     *\n     * @var bool\n     */\n    public $do_verp = false;\n\n    /**\n     * Whether to allow sending messages with an empty body.\n     *\n     * @var bool\n     */\n    public $AllowEmpty = false;\n\n    /**\n     * DKIM selector.\n     *\n     * @var string\n     */\n    public $DKIM_selector = '';\n\n    /**\n     * DKIM Identity.\n     * Usually the email address used as the source of the email.\n     *\n     * @var string\n     */\n    public $DKIM_identity = '';\n\n    /**\n     * DKIM passphrase.\n     * Used if your key is encrypted.\n     *\n     * @var string\n     */\n    public $DKIM_passphrase = '';\n\n    /**\n     * DKIM signing domain name.\n     *\n     * @example 'example.com'\n     *\n     * @var string\n     */\n    public $DKIM_domain = '';\n\n    /**\n     * DKIM Copy header field values for diagnostic use.\n     *\n     * @var bool\n     */\n    public $DKIM_copyHeaderFields = true;\n\n    /**\n     * DKIM Extra signing headers.\n     *\n     * @example ['List-Unsubscribe', 'List-Help']\n     *\n     * @var array\n     */\n    public $DKIM_extraHeaders = [];\n\n    /**\n     * DKIM private key file path.\n     *\n     * @var string\n     */\n    public $DKIM_private = '';\n\n    /**\n     * DKIM private key string.\n     *\n     * If set, takes precedence over `$DKIM_private`.\n     *\n     * @var string\n     */\n    public $DKIM_private_string = '';\n\n    /**\n     * Callback Action function name.\n     *\n     * The function that handles the result of the send email action.\n     * It is called out by send() for each email sent.\n     *\n     * Value can be any php callable: http://www.php.net/is_callable\n     *\n     * Parameters:\n     *   bool $result        result of the send action\n     *   array   $to            email addresses of the recipients\n     *   array   $cc            cc email addresses\n     *   array   $bcc           bcc email addresses\n     *   string  $subject       the subject\n     *   string  $body          the email body\n     *   string  $from          email address of sender\n     *   string  $extra         extra information of possible use\n     *                          \"smtp_transaction_id' => last smtp transaction id\n     *\n     * @var string\n     */\n    public $action_function = '';\n\n    /**\n     * What to put in the X-Mailer header.\n     * Options: An empty string for PHPMailer default, whitespace/null for none, or a string to use.\n     *\n     * @var string|null\n     */\n    public $XMailer = '';\n\n    /**\n     * Which validator to use by default when validating email addresses.\n     * May be a callable to inject your own validator, but there are several built-in validators.\n     * The default validator uses PHP's FILTER_VALIDATE_EMAIL filter_var option.\n     *\n     * @see PHPMailer::validateAddress()\n     *\n     * @var string|callable\n     */\n    public static $validator = 'php';\n\n    /**\n     * An instance of the SMTP sender class.\n     *\n     * @var SMTP\n     */\n    protected $smtp;\n\n    /**\n     * The array of 'to' names and addresses.\n     *\n     * @var array\n     */\n    protected $to = [];\n\n    /**\n     * The array of 'cc' names and addresses.\n     *\n     * @var array\n     */\n    protected $cc = [];\n\n    /**\n     * The array of 'bcc' names and addresses.\n     *\n     * @var array\n     */\n    protected $bcc = [];\n\n    /**\n     * The array of reply-to names and addresses.\n     *\n     * @var array\n     */\n    protected $ReplyTo = [];\n\n    /**\n     * An array of all kinds of addresses.\n     * Includes all of $to, $cc, $bcc.\n     *\n     * @see PHPMailer::$to\n     * @see PHPMailer::$cc\n     * @see PHPMailer::$bcc\n     *\n     * @var array\n     */\n    protected $all_recipients = [];\n\n    /**\n     * An array of names and addresses queued for validation.\n     * In send(), valid and non duplicate entries are moved to $all_recipients\n     * and one of $to, $cc, or $bcc.\n     * This array is used only for addresses with IDN.\n     *\n     * @see PHPMailer::$to\n     * @see PHPMailer::$cc\n     * @see PHPMailer::$bcc\n     * @see PHPMailer::$all_recipients\n     *\n     * @var array\n     */\n    protected $RecipientsQueue = [];\n\n    /**\n     * An array of reply-to names and addresses queued for validation.\n     * In send(), valid and non duplicate entries are moved to $ReplyTo.\n     * This array is used only for addresses with IDN.\n     *\n     * @see PHPMailer::$ReplyTo\n     *\n     * @var array\n     */\n    protected $ReplyToQueue = [];\n\n    /**\n     * The array of attachments.\n     *\n     * @var array\n     */\n    protected $attachment = [];\n\n    /**\n     * The array of custom headers.\n     *\n     * @var array\n     */\n    protected $CustomHeader = [];\n\n    /**\n     * The most recent Message-ID (including angular brackets).\n     *\n     * @var string\n     */\n    protected $lastMessageID = '';\n\n    /**\n     * The message's MIME type.\n     *\n     * @var string\n     */\n    protected $message_type = '';\n\n    /**\n     * The array of MIME boundary strings.\n     *\n     * @var array\n     */\n    protected $boundary = [];\n\n    /**\n     * The array of available languages.\n     *\n     * @var array\n     */\n    protected $language = [];\n\n    /**\n     * The number of errors encountered.\n     *\n     * @var int\n     */\n    protected $error_count = 0;\n\n    /**\n     * The S/MIME certificate file path.\n     *\n     * @var string\n     */\n    protected $sign_cert_file = '';\n\n    /**\n     * The S/MIME key file path.\n     *\n     * @var string\n     */\n    protected $sign_key_file = '';\n\n    /**\n     * The optional S/MIME extra certificates (\"CA Chain\") file path.\n     *\n     * @var string\n     */\n    protected $sign_extracerts_file = '';\n\n    /**\n     * The S/MIME password for the key.\n     * Used only if the key is encrypted.\n     *\n     * @var string\n     */\n    protected $sign_key_pass = '';\n\n    /**\n     * Whether to throw exceptions for errors.\n     *\n     * @var bool\n     */\n    protected $exceptions = false;\n\n    /**\n     * Unique ID used for message ID and boundaries.\n     *\n     * @var string\n     */\n    protected $uniqueid = '';\n\n    /**\n     * The PHPMailer Version number.\n     *\n     * @var string\n     */\n    const VERSION = '6.4.1';\n\n    /**\n     * Error severity: message only, continue processing.\n     *\n     * @var int\n     */\n    const STOP_MESSAGE = 0;\n\n    /**\n     * Error severity: message, likely ok to continue processing.\n     *\n     * @var int\n     */\n    const STOP_CONTINUE = 1;\n\n    /**\n     * Error severity: message, plus full stop, critical error reached.\n     *\n     * @var int\n     */\n    const STOP_CRITICAL = 2;\n\n    /**\n     * The SMTP standard CRLF line break.\n     * If you want to change line break format, change static::$LE, not this.\n     */\n    const CRLF = \"\\r\\n\";\n\n    /**\n     * \"Folding White Space\" a white space string used for line folding.\n     */\n    const FWS = ' ';\n\n    /**\n     * SMTP RFC standard line ending; Carriage Return, Line Feed.\n     *\n     * @var string\n     */\n    protected static $LE = self::CRLF;\n\n    /**\n     * The maximum line length supported by mail().\n     *\n     * Background: mail() will sometimes corrupt messages\n     * with headers headers longer than 65 chars, see #818.\n     *\n     * @var int\n     */\n    const MAIL_MAX_LINE_LENGTH = 63;\n\n    /**\n     * The maximum line length allowed by RFC 2822 section 2.1.1.\n     *\n     * @var int\n     */\n    const MAX_LINE_LENGTH = 998;\n\n    /**\n     * The lower maximum line length allowed by RFC 2822 section 2.1.1.\n     * This length does NOT include the line break\n     * 76 means that lines will be 77 or 78 chars depending on whether\n     * the line break format is LF or CRLF; both are valid.\n     *\n     * @var int\n     */\n    const STD_LINE_LENGTH = 76;\n\n    /**\n     * Constructor.\n     *\n     * @param bool $exceptions Should we throw external exceptions?\n     */\n    public function __construct($exceptions = null)\n    {\n        if (null !== $exceptions) {\n            $this->exceptions = (bool) $exceptions;\n        }\n        //Pick an appropriate debug output format automatically\n        $this->Debugoutput = (strpos(PHP_SAPI, 'cli') !== false ? 'echo' : 'html');\n    }\n\n    /**\n     * Destructor.\n     */\n    public function __destruct()\n    {\n        //Close any open SMTP connection nicely\n        $this->smtpClose();\n    }\n\n    /**\n     * Call mail() in a safe_mode-aware fashion.\n     * Also, unless sendmail_path points to sendmail (or something that\n     * claims to be sendmail), don't pass params (not a perfect fix,\n     * but it will do).\n     *\n     * @param string      $to      To\n     * @param string      $subject Subject\n     * @param string      $body    Message Body\n     * @param string      $header  Additional Header(s)\n     * @param string|null $params  Params\n     *\n     * @return bool\n     */\n    private function mailPassthru($to, $subject, $body, $header, $params)\n    {\n        //Check overloading of mail function to avoid double-encoding\n        if (ini_get('mbstring.func_overload') & 1) {\n            $subject = $this->secureHeader($subject);\n        } else {\n            $subject = $this->encodeHeader($this->secureHeader($subject));\n        }\n        //Calling mail() with null params breaks\n        $this->edebug('Sending with mail()');\n        $this->edebug('Sendmail path: ' . ini_get('sendmail_path'));\n        $this->edebug(\"Envelope sender: {$this->Sender}\");\n        $this->edebug(\"To: {$to}\");\n        $this->edebug(\"Subject: {$subject}\");\n        $this->edebug(\"Headers: {$header}\");\n        if (!$this->UseSendmailOptions || null === $params) {\n            $result = @mail($to, $subject, $body, $header);\n        } else {\n            $this->edebug(\"Additional params: {$params}\");\n            $result = @mail($to, $subject, $body, $header, $params);\n        }\n        $this->edebug('Result: ' . ($result ? 'true' : 'false'));\n        return $result;\n    }\n\n    /**\n     * Output debugging info via a user-defined method.\n     * Only generates output if debug output is enabled.\n     *\n     * @see PHPMailer::$Debugoutput\n     * @see PHPMailer::$SMTPDebug\n     *\n     * @param string $str\n     */\n    protected function edebug($str)\n    {\n        if ($this->SMTPDebug <= 0) {\n            return;\n        }\n        //Is this a PSR-3 logger?\n        if ($this->Debugoutput instanceof \\Psr\\Log\\LoggerInterface) {\n            $this->Debugoutput->debug($str);\n\n            return;\n        }\n        //Avoid clash with built-in function names\n        if (is_callable($this->Debugoutput) && !in_array($this->Debugoutput, ['error_log', 'html', 'echo'])) {\n            call_user_func($this->Debugoutput, $str, $this->SMTPDebug);\n\n            return;\n        }\n        switch ($this->Debugoutput) {\n            case 'error_log':\n                //Don't output, just log\n                /** @noinspection ForgottenDebugOutputInspection */\n                error_log($str);\n                break;\n            case 'html':\n                //Cleans up output a bit for a better looking, HTML-safe output\n                echo htmlentities(\n                    preg_replace('/[\\r\\n]+/', '', $str),\n                    ENT_QUOTES,\n                    'UTF-8'\n                ), \"<br>\\n\";\n                break;\n            case 'echo':\n            default:\n                //Normalize line breaks\n                $str = preg_replace('/\\r\\n|\\r/m', \"\\n\", $str);\n                echo gmdate('Y-m-d H:i:s'),\n                \"\\t\",\n                    //Trim trailing space\n                trim(\n                    //Indent for readability, except for trailing break\n                    str_replace(\n                        \"\\n\",\n                        \"\\n                   \\t                  \",\n                        trim($str)\n                    )\n                ),\n                \"\\n\";\n        }\n    }\n\n    /**\n     * Sets message type to HTML or plain.\n     *\n     * @param bool $isHtml True for HTML mode\n     */\n    public function isHTML($isHtml = true)\n    {\n        if ($isHtml) {\n            $this->ContentType = static::CONTENT_TYPE_TEXT_HTML;\n        } else {\n            $this->ContentType = static::CONTENT_TYPE_PLAINTEXT;\n        }\n    }\n\n    /**\n     * Send messages using SMTP.\n     */\n    public function isSMTP()\n    {\n        $this->Mailer = 'smtp';\n    }\n\n    /**\n     * Send messages using PHP's mail() function.\n     */\n    public function isMail()\n    {\n        $this->Mailer = 'mail';\n    }\n\n    /**\n     * Send messages using $Sendmail.\n     */\n    public function isSendmail()\n    {\n        $ini_sendmail_path = ini_get('sendmail_path');\n\n        if (false === stripos($ini_sendmail_path, 'sendmail')) {\n            $this->Sendmail = '/usr/sbin/sendmail';\n        } else {\n            $this->Sendmail = $ini_sendmail_path;\n        }\n        $this->Mailer = 'sendmail';\n    }\n\n    /**\n     * Send messages using qmail.\n     */\n    public function isQmail()\n    {\n        $ini_sendmail_path = ini_get('sendmail_path');\n\n        if (false === stripos($ini_sendmail_path, 'qmail')) {\n            $this->Sendmail = '/var/qmail/bin/qmail-inject';\n        } else {\n            $this->Sendmail = $ini_sendmail_path;\n        }\n        $this->Mailer = 'qmail';\n    }\n\n    /**\n     * Add a \"To\" address.\n     *\n     * @param string $address The email address to send to\n     * @param string $name\n     *\n     * @throws Exception\n     *\n     * @return bool true on success, false if address already used or invalid in some way\n     */\n    public function addAddress($address, $name = '')\n    {\n        return $this->addOrEnqueueAnAddress('to', $address, $name);\n    }\n\n    /**\n     * Add a \"CC\" address.\n     *\n     * @param string $address The email address to send to\n     * @param string $name\n     *\n     * @throws Exception\n     *\n     * @return bool true on success, false if address already used or invalid in some way\n     */\n    public function addCC($address, $name = '')\n    {\n        return $this->addOrEnqueueAnAddress('cc', $address, $name);\n    }\n\n    /**\n     * Add a \"BCC\" address.\n     *\n     * @param string $address The email address to send to\n     * @param string $name\n     *\n     * @throws Exception\n     *\n     * @return bool true on success, false if address already used or invalid in some way\n     */\n    public function addBCC($address, $name = '')\n    {\n        return $this->addOrEnqueueAnAddress('bcc', $address, $name);\n    }\n\n    /**\n     * Add a \"Reply-To\" address.\n     *\n     * @param string $address The email address to reply to\n     * @param string $name\n     *\n     * @throws Exception\n     *\n     * @return bool true on success, false if address already used or invalid in some way\n     */\n    public function addReplyTo($address, $name = '')\n    {\n        return $this->addOrEnqueueAnAddress('Reply-To', $address, $name);\n    }\n\n    /**\n     * Add an address to one of the recipient arrays or to the ReplyTo array. Because PHPMailer\n     * can't validate addresses with an IDN without knowing the PHPMailer::$CharSet (that can still\n     * be modified after calling this function), addition of such addresses is delayed until send().\n     * Addresses that have been added already return false, but do not throw exceptions.\n     *\n     * @param string $kind    One of 'to', 'cc', 'bcc', or 'ReplyTo'\n     * @param string $address The email address to send, resp. to reply to\n     * @param string $name\n     *\n     * @throws Exception\n     *\n     * @return bool true on success, false if address already used or invalid in some way\n     */\n    protected function addOrEnqueueAnAddress($kind, $address, $name)\n    {\n        $address = trim($address);\n        $name = trim(preg_replace('/[\\r\\n]+/', '', $name)); //Strip breaks and trim\n        $pos = strrpos($address, '@');\n        if (false === $pos) {\n            //At-sign is missing.\n            $error_message = sprintf(\n                '%s (%s): %s',\n                $this->lang('invalid_address'),\n                $kind,\n                $address\n            );\n            $this->setError($error_message);\n            $this->edebug($error_message);\n            if ($this->exceptions) {\n                throw new Exception($error_message);\n            }\n\n            return false;\n        }\n        $params = [$kind, $address, $name];\n        //Enqueue addresses with IDN until we know the PHPMailer::$CharSet.\n        if (static::idnSupported() && $this->has8bitChars(substr($address, ++$pos))) {\n            if ('Reply-To' !== $kind) {\n                if (!array_key_exists($address, $this->RecipientsQueue)) {\n                    $this->RecipientsQueue[$address] = $params;\n\n                    return true;\n                }\n            } elseif (!array_key_exists($address, $this->ReplyToQueue)) {\n                $this->ReplyToQueue[$address] = $params;\n\n                return true;\n            }\n\n            return false;\n        }\n\n        //Immediately add standard addresses without IDN.\n        return call_user_func_array([$this, 'addAnAddress'], $params);\n    }\n\n    /**\n     * Add an address to one of the recipient arrays or to the ReplyTo array.\n     * Addresses that have been added already return false, but do not throw exceptions.\n     *\n     * @param string $kind    One of 'to', 'cc', 'bcc', or 'ReplyTo'\n     * @param string $address The email address to send, resp. to reply to\n     * @param string $name\n     *\n     * @throws Exception\n     *\n     * @return bool true on success, false if address already used or invalid in some way\n     */\n    protected function addAnAddress($kind, $address, $name = '')\n    {\n        if (!in_array($kind, ['to', 'cc', 'bcc', 'Reply-To'])) {\n            $error_message = sprintf(\n                '%s: %s',\n                $this->lang('Invalid recipient kind'),\n                $kind\n            );\n            $this->setError($error_message);\n            $this->edebug($error_message);\n            if ($this->exceptions) {\n                throw new Exception($error_message);\n            }\n\n            return false;\n        }\n        if (!static::validateAddress($address)) {\n            $error_message = sprintf(\n                '%s (%s): %s',\n                $this->lang('invalid_address'),\n                $kind,\n                $address\n            );\n            $this->setError($error_message);\n            $this->edebug($error_message);\n            if ($this->exceptions) {\n                throw new Exception($error_message);\n            }\n\n            return false;\n        }\n        if ('Reply-To' !== $kind) {\n            if (!array_key_exists(strtolower($address), $this->all_recipients)) {\n                $this->{$kind}[] = [$address, $name];\n                $this->all_recipients[strtolower($address)] = true;\n\n                return true;\n            }\n        } elseif (!array_key_exists(strtolower($address), $this->ReplyTo)) {\n            $this->ReplyTo[strtolower($address)] = [$address, $name];\n\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Parse and validate a string containing one or more RFC822-style comma-separated email addresses\n     * of the form \"display name <address>\" into an array of name/address pairs.\n     * Uses the imap_rfc822_parse_adrlist function if the IMAP extension is available.\n     * Note that quotes in the name part are removed.\n     *\n     * @see http://www.andrew.cmu.edu/user/agreen1/testing/mrbs/web/Mail/RFC822.php A more careful implementation\n     *\n     * @param string $addrstr The address list string\n     * @param bool   $useimap Whether to use the IMAP extension to parse the list\n     *\n     * @return array\n     */\n    public static function parseAddresses($addrstr, $useimap = true)\n    {\n        $addresses = [];\n        if ($useimap && function_exists('imap_rfc822_parse_adrlist')) {\n            //Use this built-in parser if it's available\n            $list = imap_rfc822_parse_adrlist($addrstr, '');\n            foreach ($list as $address) {\n                if (\n                    ('.SYNTAX-ERROR.' !== $address->host) && static::validateAddress(\n                        $address->mailbox . '@' . $address->host\n                    )\n                ) {\n                    //Decode the name part if it's present and encoded\n                    if (\n                        property_exists($address, 'personal') &&\n                        extension_loaded('mbstring') &&\n                        preg_match('/^=\\?.*\\?=$/', $address->personal)\n                    ) {\n                        $address->personal = mb_decode_mimeheader($address->personal);\n                    }\n\n                    $addresses[] = [\n                        'name' => (property_exists($address, 'personal') ? $address->personal : ''),\n                        'address' => $address->mailbox . '@' . $address->host,\n                    ];\n                }\n            }\n        } else {\n            //Use this simpler parser\n            $list = explode(',', $addrstr);\n            foreach ($list as $address) {\n                $address = trim($address);\n                //Is there a separate name part?\n                if (strpos($address, '<') === false) {\n                    //No separate name, just use the whole thing\n                    if (static::validateAddress($address)) {\n                        $addresses[] = [\n                            'name' => '',\n                            'address' => $address,\n                        ];\n                    }\n                } else {\n                    list($name, $email) = explode('<', $address);\n                    $email = trim(str_replace('>', '', $email));\n                    $name = trim($name);\n                    if (static::validateAddress($email)) {\n                        //If this name is encoded, decode it\n                        if (preg_match('/^=\\?.*\\?=$/', $name)) {\n                            $name = mb_decode_mimeheader($name);\n                        }\n                        $addresses[] = [\n                            //Remove any surrounding quotes and spaces from the name\n                            'name' => trim($name, '\\'\" '),\n                            'address' => $email,\n                        ];\n                    }\n                }\n            }\n        }\n\n        return $addresses;\n    }\n\n    /**\n     * Set the From and FromName properties.\n     *\n     * @param string $address\n     * @param string $name\n     * @param bool   $auto    Whether to also set the Sender address, defaults to true\n     *\n     * @throws Exception\n     *\n     * @return bool\n     */\n    public function setFrom($address, $name = '', $auto = true)\n    {\n        $address = trim($address);\n        $name = trim(preg_replace('/[\\r\\n]+/', '', $name)); //Strip breaks and trim\n        //Don't validate now addresses with IDN. Will be done in send().\n        $pos = strrpos($address, '@');\n        if (\n            (false === $pos)\n            || ((!$this->has8bitChars(substr($address, ++$pos)) || !static::idnSupported())\n            && !static::validateAddress($address))\n        ) {\n            $error_message = sprintf(\n                '%s (From): %s',\n                $this->lang('invalid_address'),\n                $address\n            );\n            $this->setError($error_message);\n            $this->edebug($error_message);\n            if ($this->exceptions) {\n                throw new Exception($error_message);\n            }\n\n            return false;\n        }\n        $this->From = $address;\n        $this->FromName = $name;\n        if ($auto && empty($this->Sender)) {\n            $this->Sender = $address;\n        }\n\n        return true;\n    }\n\n    /**\n     * Return the Message-ID header of the last email.\n     * Technically this is the value from the last time the headers were created,\n     * but it's also the message ID of the last sent message except in\n     * pathological cases.\n     *\n     * @return string\n     */\n    public function getLastMessageID()\n    {\n        return $this->lastMessageID;\n    }\n\n    /**\n     * Check that a string looks like an email address.\n     * Validation patterns supported:\n     * * `auto` Pick best pattern automatically;\n     * * `pcre8` Use the squiloople.com pattern, requires PCRE > 8.0;\n     * * `pcre` Use old PCRE implementation;\n     * * `php` Use PHP built-in FILTER_VALIDATE_EMAIL;\n     * * `html5` Use the pattern given by the HTML5 spec for 'email' type form input elements.\n     * * `noregex` Don't use a regex: super fast, really dumb.\n     * Alternatively you may pass in a callable to inject your own validator, for example:\n     *\n     * ```php\n     * PHPMailer::validateAddress('user@example.com', function($address) {\n     *     return (strpos($address, '@') !== false);\n     * });\n     * ```\n     *\n     * You can also set the PHPMailer::$validator static to a callable, allowing built-in methods to use your validator.\n     *\n     * @param string          $address       The email address to check\n     * @param string|callable $patternselect Which pattern to use\n     *\n     * @return bool\n     */\n    public static function validateAddress($address, $patternselect = null)\n    {\n        if (null === $patternselect) {\n            $patternselect = static::$validator;\n        }\n        //Don't allow strings as callables, see SECURITY.md and CVE-2021-3603\n        if (is_callable($patternselect) && !is_string($patternselect)) {\n            return call_user_func($patternselect, $address);\n        }\n        //Reject line breaks in addresses; it's valid RFC5322, but not RFC5321\n        if (strpos($address, \"\\n\") !== false || strpos($address, \"\\r\") !== false) {\n            return false;\n        }\n        switch ($patternselect) {\n            case 'pcre': //Kept for BC\n            case 'pcre8':\n                /*\n                 * A more complex and more permissive version of the RFC5322 regex on which FILTER_VALIDATE_EMAIL\n                 * is based.\n                 * In addition to the addresses allowed by filter_var, also permits:\n                 *  * dotless domains: `a@b`\n                 *  * comments: `1234 @ local(blah) .machine .example`\n                 *  * quoted elements: `'\"test blah\"@example.org'`\n                 *  * numeric TLDs: `a@b.123`\n                 *  * unbracketed IPv4 literals: `a@192.168.0.1`\n                 *  * IPv6 literals: 'first.last@[IPv6:a1::]'\n                 * Not all of these will necessarily work for sending!\n                 *\n                 * @see       http://squiloople.com/2009/12/20/email-address-validation/\n                 * @copyright 2009-2010 Michael Rushton\n                 * Feel free to use and redistribute this code. But please keep this copyright notice.\n                 */\n                return (bool) preg_match(\n                    '/^(?!(?>(?1)\"?(?>\\\\\\[ -~]|[^\"])\"?(?1)){255,})(?!(?>(?1)\"?(?>\\\\\\[ -~]|[^\"])\"?(?1)){65,}@)' .\n                    '((?>(?>(?>((?>(?>(?>\\x0D\\x0A)?[\\t ])+|(?>[\\t ]*\\x0D\\x0A)?[\\t ]+)?)(\\((?>(?2)' .\n                    '(?>[\\x01-\\x08\\x0B\\x0C\\x0E-\\'*-\\[\\]-\\x7F]|\\\\\\[\\x00-\\x7F]|(?3)))*(?2)\\)))+(?2))|(?2))?)' .\n                    '([!#-\\'*+\\/-9=?^-~-]+|\"(?>(?2)(?>[\\x01-\\x08\\x0B\\x0C\\x0E-!#-\\[\\]-\\x7F]|\\\\\\[\\x00-\\x7F]))*' .\n                    '(?2)\")(?>(?1)\\.(?1)(?4))*(?1)@(?!(?1)[a-z0-9-]{64,})(?1)(?>([a-z0-9](?>[a-z0-9-]*[a-z0-9])?)' .\n                    '(?>(?1)\\.(?!(?1)[a-z0-9-]{64,})(?1)(?5)){0,126}|\\[(?:(?>IPv6:(?>([a-f0-9]{1,4})(?>:(?6)){7}' .\n                    '|(?!(?:.*[a-f0-9][:\\]]){8,})((?6)(?>:(?6)){0,6})?::(?7)?))|(?>(?>IPv6:(?>(?6)(?>:(?6)){5}:' .\n                    '|(?!(?:.*[a-f0-9]:){6,})(?8)?::(?>((?6)(?>:(?6)){0,4}):)?))?(25[0-5]|2[0-4][0-9]|1[0-9]{2}' .\n                    '|[1-9]?[0-9])(?>\\.(?9)){3}))\\])(?1)$/isD',\n                    $address\n                );\n            case 'html5':\n                /*\n                 * This is the pattern used in the HTML5 spec for validation of 'email' type form input elements.\n                 *\n                 * @see https://html.spec.whatwg.org/#e-mail-state-(type=email)\n                 */\n                return (bool) preg_match(\n                    '/^[a-zA-Z0-9.!#$%&\\'*+\\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}' .\n                    '[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/sD',\n                    $address\n                );\n            case 'php':\n            default:\n                return filter_var($address, FILTER_VALIDATE_EMAIL) !== false;\n        }\n    }\n\n    /**\n     * Tells whether IDNs (Internationalized Domain Names) are supported or not. This requires the\n     * `intl` and `mbstring` PHP extensions.\n     *\n     * @return bool `true` if required functions for IDN support are present\n     */\n    public static function idnSupported()\n    {\n        return function_exists('idn_to_ascii') && function_exists('mb_convert_encoding');\n    }\n\n    /**\n     * Converts IDN in given email address to its ASCII form, also known as punycode, if possible.\n     * Important: Address must be passed in same encoding as currently set in PHPMailer::$CharSet.\n     * This function silently returns unmodified address if:\n     * - No conversion is necessary (i.e. domain name is not an IDN, or is already in ASCII form)\n     * - Conversion to punycode is impossible (e.g. required PHP functions are not available)\n     *   or fails for any reason (e.g. domain contains characters not allowed in an IDN).\n     *\n     * @see PHPMailer::$CharSet\n     *\n     * @param string $address The email address to convert\n     *\n     * @return string The encoded address in ASCII form\n     */\n    public function punyencodeAddress($address)\n    {\n        //Verify we have required functions, CharSet, and at-sign.\n        $pos = strrpos($address, '@');\n        if (\n            !empty($this->CharSet) &&\n            false !== $pos &&\n            static::idnSupported()\n        ) {\n            $domain = substr($address, ++$pos);\n            //Verify CharSet string is a valid one, and domain properly encoded in this CharSet.\n            if ($this->has8bitChars($domain) && @mb_check_encoding($domain, $this->CharSet)) {\n                //Convert the domain from whatever charset it's in to UTF-8\n                $domain = mb_convert_encoding($domain, self::CHARSET_UTF8, $this->CharSet);\n                //Ignore IDE complaints about this line - method signature changed in PHP 5.4\n                $errorcode = 0;\n                if (defined('INTL_IDNA_VARIANT_UTS46')) {\n                    //Use the current punycode standard (appeared in PHP 7.2)\n                    $punycode = idn_to_ascii($domain, $errorcode, \\INTL_IDNA_VARIANT_UTS46);\n                } elseif (defined('INTL_IDNA_VARIANT_2003')) {\n                    //Fall back to this old, deprecated/removed encoding\n                    $punycode = idn_to_ascii($domain, $errorcode, \\INTL_IDNA_VARIANT_2003);\n                } else {\n                    //Fall back to a default we don't know about\n                    $punycode = idn_to_ascii($domain, $errorcode);\n                }\n                if (false !== $punycode) {\n                    return substr($address, 0, $pos) . $punycode;\n                }\n            }\n        }\n\n        return $address;\n    }\n\n    /**\n     * Create a message and send it.\n     * Uses the sending method specified by $Mailer.\n     *\n     * @throws Exception\n     *\n     * @return bool false on error - See the ErrorInfo property for details of the error\n     */\n    public function send()\n    {\n        try {\n            if (!$this->preSend()) {\n                return false;\n            }\n\n            return $this->postSend();\n        } catch (Exception $exc) {\n            $this->mailHeader = '';\n            $this->setError($exc->getMessage());\n            if ($this->exceptions) {\n                throw $exc;\n            }\n\n            return false;\n        }\n    }\n\n    /**\n     * Prepare a message for sending.\n     *\n     * @throws Exception\n     *\n     * @return bool\n     */\n    public function preSend()\n    {\n        if (\n            'smtp' === $this->Mailer\n            || ('mail' === $this->Mailer && (\\PHP_VERSION_ID >= 80000 || stripos(PHP_OS, 'WIN') === 0))\n        ) {\n            //SMTP mandates RFC-compliant line endings\n            //and it's also used with mail() on Windows\n            static::setLE(self::CRLF);\n        } else {\n            //Maintain backward compatibility with legacy Linux command line mailers\n            static::setLE(PHP_EOL);\n        }\n        //Check for buggy PHP versions that add a header with an incorrect line break\n        if (\n            'mail' === $this->Mailer\n            && ((\\PHP_VERSION_ID >= 70000 && \\PHP_VERSION_ID < 70017)\n                || (\\PHP_VERSION_ID >= 70100 && \\PHP_VERSION_ID < 70103))\n            && ini_get('mail.add_x_header') === '1'\n            && stripos(PHP_OS, 'WIN') === 0\n        ) {\n            trigger_error(\n                'Your version of PHP is affected by a bug that may result in corrupted messages.' .\n                ' To fix it, switch to sending using SMTP, disable the mail.add_x_header option in' .\n                ' your php.ini, switch to MacOS or Linux, or upgrade your PHP to version 7.0.17+ or 7.1.3+.',\n                E_USER_WARNING\n            );\n        }\n\n        try {\n            $this->error_count = 0; //Reset errors\n            $this->mailHeader = '';\n\n            //Dequeue recipient and Reply-To addresses with IDN\n            foreach (array_merge($this->RecipientsQueue, $this->ReplyToQueue) as $params) {\n                $params[1] = $this->punyencodeAddress($params[1]);\n                call_user_func_array([$this, 'addAnAddress'], $params);\n            }\n            if (count($this->to) + count($this->cc) + count($this->bcc) < 1) {\n                throw new Exception($this->lang('provide_address'), self::STOP_CRITICAL);\n            }\n\n            //Validate From, Sender, and ConfirmReadingTo addresses\n            foreach (['From', 'Sender', 'ConfirmReadingTo'] as $address_kind) {\n                $this->$address_kind = trim($this->$address_kind);\n                if (empty($this->$address_kind)) {\n                    continue;\n                }\n                $this->$address_kind = $this->punyencodeAddress($this->$address_kind);\n                if (!static::validateAddress($this->$address_kind)) {\n                    $error_message = sprintf(\n                        '%s (%s): %s',\n                        $this->lang('invalid_address'),\n                        $address_kind,\n                        $this->$address_kind\n                    );\n                    $this->setError($error_message);\n                    $this->edebug($error_message);\n                    if ($this->exceptions) {\n                        throw new Exception($error_message);\n                    }\n\n                    return false;\n                }\n            }\n\n            //Set whether the message is multipart/alternative\n            if ($this->alternativeExists()) {\n                $this->ContentType = static::CONTENT_TYPE_MULTIPART_ALTERNATIVE;\n            }\n\n            $this->setMessageType();\n            //Refuse to send an empty message unless we are specifically allowing it\n            if (!$this->AllowEmpty && empty($this->Body)) {\n                throw new Exception($this->lang('empty_message'), self::STOP_CRITICAL);\n            }\n\n            //Trim subject consistently\n            $this->Subject = trim($this->Subject);\n            //Create body before headers in case body makes changes to headers (e.g. altering transfer encoding)\n            $this->MIMEHeader = '';\n            $this->MIMEBody = $this->createBody();\n            //createBody may have added some headers, so retain them\n            $tempheaders = $this->MIMEHeader;\n            $this->MIMEHeader = $this->createHeader();\n            $this->MIMEHeader .= $tempheaders;\n\n            //To capture the complete message when using mail(), create\n            //an extra header list which createHeader() doesn't fold in\n            if ('mail' === $this->Mailer) {\n                if (count($this->to) > 0) {\n                    $this->mailHeader .= $this->addrAppend('To', $this->to);\n                } else {\n                    $this->mailHeader .= $this->headerLine('To', 'undisclosed-recipients:;');\n                }\n                $this->mailHeader .= $this->headerLine(\n                    'Subject',\n                    $this->encodeHeader($this->secureHeader($this->Subject))\n                );\n            }\n\n            //Sign with DKIM if enabled\n            if (\n                !empty($this->DKIM_domain)\n                && !empty($this->DKIM_selector)\n                && (!empty($this->DKIM_private_string)\n                    || (!empty($this->DKIM_private)\n                        && static::isPermittedPath($this->DKIM_private)\n                        && file_exists($this->DKIM_private)\n                    )\n                )\n            ) {\n                $header_dkim = $this->DKIM_Add(\n                    $this->MIMEHeader . $this->mailHeader,\n                    $this->encodeHeader($this->secureHeader($this->Subject)),\n                    $this->MIMEBody\n                );\n                $this->MIMEHeader = static::stripTrailingWSP($this->MIMEHeader) . static::$LE .\n                    static::normalizeBreaks($header_dkim) . static::$LE;\n            }\n\n            return true;\n        } catch (Exception $exc) {\n            $this->setError($exc->getMessage());\n            if ($this->exceptions) {\n                throw $exc;\n            }\n\n            return false;\n        }\n    }\n\n    /**\n     * Actually send a message via the selected mechanism.\n     *\n     * @throws Exception\n     *\n     * @return bool\n     */\n    public function postSend()\n    {\n        try {\n            //Choose the mailer and send through it\n            switch ($this->Mailer) {\n                case 'sendmail':\n                case 'qmail':\n                    return $this->sendmailSend($this->MIMEHeader, $this->MIMEBody);\n                case 'smtp':\n                    return $this->smtpSend($this->MIMEHeader, $this->MIMEBody);\n                case 'mail':\n                    return $this->mailSend($this->MIMEHeader, $this->MIMEBody);\n                default:\n                    $sendMethod = $this->Mailer . 'Send';\n                    if (method_exists($this, $sendMethod)) {\n                        return $this->$sendMethod($this->MIMEHeader, $this->MIMEBody);\n                    }\n\n                    return $this->mailSend($this->MIMEHeader, $this->MIMEBody);\n            }\n        } catch (Exception $exc) {\n            if ($this->Mailer === 'smtp' && $this->SMTPKeepAlive == true) {\n                $this->smtp->reset();\n            }\n            $this->setError($exc->getMessage());\n            $this->edebug($exc->getMessage());\n            if ($this->exceptions) {\n                throw $exc;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Send mail using the $Sendmail program.\n     *\n     * @see PHPMailer::$Sendmail\n     *\n     * @param string $header The message headers\n     * @param string $body   The message body\n     *\n     * @throws Exception\n     *\n     * @return bool\n     */\n    protected function sendmailSend($header, $body)\n    {\n        if ($this->Mailer === 'qmail') {\n            $this->edebug('Sending with qmail');\n        } else {\n            $this->edebug('Sending with sendmail');\n        }\n        $header = static::stripTrailingWSP($header) . static::$LE . static::$LE;\n        //This sets the SMTP envelope sender which gets turned into a return-path header by the receiver\n        //A space after `-f` is optional, but there is a long history of its presence\n        //causing problems, so we don't use one\n        //Exim docs: http://www.exim.org/exim-html-current/doc/html/spec_html/ch-the_exim_command_line.html\n        //Sendmail docs: http://www.sendmail.org/~ca/email/man/sendmail.html\n        //Qmail docs: http://www.qmail.org/man/man8/qmail-inject.html\n        //Example problem: https://www.drupal.org/node/1057954\n        if (empty($this->Sender) && !empty(ini_get('sendmail_from'))) {\n            //PHP config has a sender address we can use\n            $this->Sender = ini_get('sendmail_from');\n        }\n        //CVE-2016-10033, CVE-2016-10045: Don't pass -f if characters will be escaped.\n        if (!empty($this->Sender) && static::validateAddress($this->Sender) && self::isShellSafe($this->Sender)) {\n            if ($this->Mailer === 'qmail') {\n                $sendmailFmt = '%s -f%s';\n            } else {\n                $sendmailFmt = '%s -oi -f%s -t';\n            }\n        } else {\n            //allow sendmail to choose a default envelope sender. It may\n            //seem preferable to force it to use the From header as with\n            //SMTP, but that introduces new problems (see\n            //<https://github.com/PHPMailer/PHPMailer/issues/2298>), and\n            //it has historically worked this way.\n            $sendmailFmt = '%s -oi -t';\n        }\n\n        $sendmail = sprintf($sendmailFmt, escapeshellcmd($this->Sendmail), $this->Sender);\n        $this->edebug('Sendmail path: ' . $this->Sendmail);\n        $this->edebug('Sendmail command: ' . $sendmail);\n        $this->edebug('Envelope sender: ' . $this->Sender);\n        $this->edebug(\"Headers: {$header}\");\n\n        if ($this->SingleTo) {\n            foreach ($this->SingleToArray as $toAddr) {\n                $mail = @popen($sendmail, 'w');\n                if (!$mail) {\n                    throw new Exception($this->lang('execute') . $this->Sendmail, self::STOP_CRITICAL);\n                }\n                $this->edebug(\"To: {$toAddr}\");\n                fwrite($mail, 'To: ' . $toAddr . \"\\n\");\n                fwrite($mail, $header);\n                fwrite($mail, $body);\n                $result = pclose($mail);\n                $addrinfo = static::parseAddresses($toAddr);\n                $this->doCallback(\n                    ($result === 0),\n                    [[$addrinfo['address'], $addrinfo['name']]],\n                    $this->cc,\n                    $this->bcc,\n                    $this->Subject,\n                    $body,\n                    $this->From,\n                    []\n                );\n                $this->edebug(\"Result: \" . ($result === 0 ? 'true' : 'false'));\n                if (0 !== $result) {\n                    throw new Exception($this->lang('execute') . $this->Sendmail, self::STOP_CRITICAL);\n                }\n            }\n        } else {\n            $mail = @popen($sendmail, 'w');\n            if (!$mail) {\n                throw new Exception($this->lang('execute') . $this->Sendmail, self::STOP_CRITICAL);\n            }\n            fwrite($mail, $header);\n            fwrite($mail, $body);\n            $result = pclose($mail);\n            $this->doCallback(\n                ($result === 0),\n                $this->to,\n                $this->cc,\n                $this->bcc,\n                $this->Subject,\n                $body,\n                $this->From,\n                []\n            );\n            $this->edebug(\"Result: \" . ($result === 0 ? 'true' : 'false'));\n            if (0 !== $result) {\n                throw new Exception($this->lang('execute') . $this->Sendmail, self::STOP_CRITICAL);\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * Fix CVE-2016-10033 and CVE-2016-10045 by disallowing potentially unsafe shell characters.\n     * Note that escapeshellarg and escapeshellcmd are inadequate for our purposes, especially on Windows.\n     *\n     * @see https://github.com/PHPMailer/PHPMailer/issues/924 CVE-2016-10045 bug report\n     *\n     * @param string $string The string to be validated\n     *\n     * @return bool\n     */\n    protected static function isShellSafe($string)\n    {\n        //Future-proof\n        if (\n            escapeshellcmd($string) !== $string\n            || !in_array(escapeshellarg($string), [\"'$string'\", \"\\\"$string\\\"\"])\n        ) {\n            return false;\n        }\n\n        $length = strlen($string);\n\n        for ($i = 0; $i < $length; ++$i) {\n            $c = $string[$i];\n\n            //All other characters have a special meaning in at least one common shell, including = and +.\n            //Full stop (.) has a special meaning in cmd.exe, but its impact should be negligible here.\n            //Note that this does permit non-Latin alphanumeric characters based on the current locale.\n            if (!ctype_alnum($c) && strpos('@_-.', $c) === false) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * Check whether a file path is of a permitted type.\n     * Used to reject URLs and phar files from functions that access local file paths,\n     * such as addAttachment.\n     *\n     * @param string $path A relative or absolute path to a file\n     *\n     * @return bool\n     */\n    protected static function isPermittedPath($path)\n    {\n        //Matches scheme definition from https://tools.ietf.org/html/rfc3986#section-3.1\n        return !preg_match('#^[a-z][a-z\\d+.-]*://#i', $path);\n    }\n\n    /**\n     * Check whether a file path is safe, accessible, and readable.\n     *\n     * @param string $path A relative or absolute path to a file\n     *\n     * @return bool\n     */\n    protected static function fileIsAccessible($path)\n    {\n        if (!static::isPermittedPath($path)) {\n            return false;\n        }\n        $readable = file_exists($path);\n        //If not a UNC path (expected to start with \\\\), check read permission, see #2069\n        if (strpos($path, '\\\\\\\\') !== 0) {\n            $readable = $readable && is_readable($path);\n        }\n        return  $readable;\n    }\n\n    /**\n     * Send mail using the PHP mail() function.\n     *\n     * @see http://www.php.net/manual/en/book.mail.php\n     *\n     * @param string $header The message headers\n     * @param string $body   The message body\n     *\n     * @throws Exception\n     *\n     * @return bool\n     */\n    protected function mailSend($header, $body)\n    {\n        $header = static::stripTrailingWSP($header) . static::$LE . static::$LE;\n\n        $toArr = [];\n        foreach ($this->to as $toaddr) {\n            $toArr[] = $this->addrFormat($toaddr);\n        }\n        $to = implode(', ', $toArr);\n\n        $params = null;\n        //This sets the SMTP envelope sender which gets turned into a return-path header by the receiver\n        //A space after `-f` is optional, but there is a long history of its presence\n        //causing problems, so we don't use one\n        //Exim docs: http://www.exim.org/exim-html-current/doc/html/spec_html/ch-the_exim_command_line.html\n        //Sendmail docs: http://www.sendmail.org/~ca/email/man/sendmail.html\n        //Qmail docs: http://www.qmail.org/man/man8/qmail-inject.html\n        //Example problem: https://www.drupal.org/node/1057954\n        //CVE-2016-10033, CVE-2016-10045: Don't pass -f if characters will be escaped.\n        if (empty($this->Sender) && !empty(ini_get('sendmail_from'))) {\n            //PHP config has a sender address we can use\n            $this->Sender = ini_get('sendmail_from');\n        }\n        if (!empty($this->Sender) && static::validateAddress($this->Sender)) {\n            if (self::isShellSafe($this->Sender)) {\n                $params = sprintf('-f%s', $this->Sender);\n            }\n            $old_from = ini_get('sendmail_from');\n            ini_set('sendmail_from', $this->Sender);\n        }\n        $result = false;\n        if ($this->SingleTo && count($toArr) > 1) {\n            foreach ($toArr as $toAddr) {\n                $result = $this->mailPassthru($toAddr, $this->Subject, $body, $header, $params);\n                $addrinfo = static::parseAddresses($toAddr);\n                $this->doCallback(\n                    $result,\n                    [[$addrinfo['address'], $addrinfo['name']]],\n                    $this->cc,\n                    $this->bcc,\n                    $this->Subject,\n                    $body,\n                    $this->From,\n                    []\n                );\n            }\n        } else {\n            $result = $this->mailPassthru($to, $this->Subject, $body, $header, $params);\n            $this->doCallback($result, $this->to, $this->cc, $this->bcc, $this->Subject, $body, $this->From, []);\n        }\n        if (isset($old_from)) {\n            ini_set('sendmail_from', $old_from);\n        }\n        if (!$result) {\n            throw new Exception($this->lang('instantiate'), self::STOP_CRITICAL);\n        }\n\n        return true;\n    }\n\n    /**\n     * Get an instance to use for SMTP operations.\n     * Override this function to load your own SMTP implementation,\n     * or set one with setSMTPInstance.\n     *\n     * @return SMTP\n     */\n    public function getSMTPInstance()\n    {\n        if (!is_object($this->smtp)) {\n            $this->smtp = new SMTP();\n        }\n\n        return $this->smtp;\n    }\n\n    /**\n     * Provide an instance to use for SMTP operations.\n     *\n     * @return SMTP\n     */\n    public function setSMTPInstance(SMTP $smtp)\n    {\n        $this->smtp = $smtp;\n\n        return $this->smtp;\n    }\n\n    /**\n     * Send mail via SMTP.\n     * Returns false if there is a bad MAIL FROM, RCPT, or DATA input.\n     *\n     * @see PHPMailer::setSMTPInstance() to use a different class.\n     *\n     * @uses \\PHPMailer\\PHPMailer\\SMTP\n     *\n     * @param string $header The message headers\n     * @param string $body   The message body\n     *\n     * @throws Exception\n     *\n     * @return bool\n     */\n    protected function smtpSend($header, $body)\n    {\n        $header = static::stripTrailingWSP($header) . static::$LE . static::$LE;\n        $bad_rcpt = [];\n        if (!$this->smtpConnect($this->SMTPOptions)) {\n            throw new Exception($this->lang('smtp_connect_failed'), self::STOP_CRITICAL);\n        }\n        //Sender already validated in preSend()\n        if ('' === $this->Sender) {\n            $smtp_from = $this->From;\n        } else {\n            $smtp_from = $this->Sender;\n        }\n        if (!$this->smtp->mail($smtp_from)) {\n            $this->setError($this->lang('from_failed') . $smtp_from . ' : ' . implode(',', $this->smtp->getError()));\n            throw new Exception($this->ErrorInfo, self::STOP_CRITICAL);\n        }\n\n        $callbacks = [];\n        //Attempt to send to all recipients\n        foreach ([$this->to, $this->cc, $this->bcc] as $togroup) {\n            foreach ($togroup as $to) {\n                if (!$this->smtp->recipient($to[0], $this->dsn)) {\n                    $error = $this->smtp->getError();\n                    $bad_rcpt[] = ['to' => $to[0], 'error' => $error['detail']];\n                    $isSent = false;\n                } else {\n                    $isSent = true;\n                }\n\n                $callbacks[] = ['issent' => $isSent, 'to' => $to[0], 'name' => $to[1]];\n            }\n        }\n\n        //Only send the DATA command if we have viable recipients\n        if ((count($this->all_recipients) > count($bad_rcpt)) && !$this->smtp->data($header . $body)) {\n            throw new Exception($this->lang('data_not_accepted'), self::STOP_CRITICAL);\n        }\n\n        $smtp_transaction_id = $this->smtp->getLastTransactionID();\n\n        if ($this->SMTPKeepAlive) {\n            $this->smtp->reset();\n        } else {\n            $this->smtp->quit();\n            $this->smtp->close();\n        }\n\n        foreach ($callbacks as $cb) {\n            $this->doCallback(\n                $cb['issent'],\n                [[$cb['to'], $cb['name']]],\n                [],\n                [],\n                $this->Subject,\n                $body,\n                $this->From,\n                ['smtp_transaction_id' => $smtp_transaction_id]\n            );\n        }\n\n        //Create error message for any bad addresses\n        if (count($bad_rcpt) > 0) {\n            $errstr = '';\n            foreach ($bad_rcpt as $bad) {\n                $errstr .= $bad['to'] . ': ' . $bad['error'];\n            }\n            throw new Exception($this->lang('recipients_failed') . $errstr, self::STOP_CONTINUE);\n        }\n\n        return true;\n    }\n\n    /**\n     * Initiate a connection to an SMTP server.\n     * Returns false if the operation failed.\n     *\n     * @param array $options An array of options compatible with stream_context_create()\n     *\n     * @throws Exception\n     *\n     * @uses \\PHPMailer\\PHPMailer\\SMTP\n     *\n     * @return bool\n     */\n    public function smtpConnect($options = null)\n    {\n        if (null === $this->smtp) {\n            $this->smtp = $this->getSMTPInstance();\n        }\n\n        //If no options are provided, use whatever is set in the instance\n        if (null === $options) {\n            $options = $this->SMTPOptions;\n        }\n\n        //Already connected?\n        if ($this->smtp->connected()) {\n            return true;\n        }\n\n        $this->smtp->setTimeout($this->Timeout);\n        $this->smtp->setDebugLevel($this->SMTPDebug);\n        $this->smtp->setDebugOutput($this->Debugoutput);\n        $this->smtp->setVerp($this->do_verp);\n        $hosts = explode(';', $this->Host);\n        $lastexception = null;\n\n        foreach ($hosts as $hostentry) {\n            $hostinfo = [];\n            if (\n                !preg_match(\n                    '/^(?:(ssl|tls):\\/\\/)?(.+?)(?::(\\d+))?$/',\n                    trim($hostentry),\n                    $hostinfo\n                )\n            ) {\n                $this->edebug($this->lang('invalid_hostentry') . ' ' . trim($hostentry));\n                //Not a valid host entry\n                continue;\n            }\n            //$hostinfo[1]: optional ssl or tls prefix\n            //$hostinfo[2]: the hostname\n            //$hostinfo[3]: optional port number\n            //The host string prefix can temporarily override the current setting for SMTPSecure\n            //If it's not specified, the default value is used\n\n            //Check the host name is a valid name or IP address before trying to use it\n            if (!static::isValidHost($hostinfo[2])) {\n                $this->edebug($this->lang('invalid_host') . ' ' . $hostinfo[2]);\n                continue;\n            }\n            $prefix = '';\n            $secure = $this->SMTPSecure;\n            $tls = (static::ENCRYPTION_STARTTLS === $this->SMTPSecure);\n            if ('ssl' === $hostinfo[1] || ('' === $hostinfo[1] && static::ENCRYPTION_SMTPS === $this->SMTPSecure)) {\n                $prefix = 'ssl://';\n                $tls = false; //Can't have SSL and TLS at the same time\n                $secure = static::ENCRYPTION_SMTPS;\n            } elseif ('tls' === $hostinfo[1]) {\n                $tls = true;\n                //TLS doesn't use a prefix\n                $secure = static::ENCRYPTION_STARTTLS;\n            }\n            //Do we need the OpenSSL extension?\n            $sslext = defined('OPENSSL_ALGO_SHA256');\n            if (static::ENCRYPTION_STARTTLS === $secure || static::ENCRYPTION_SMTPS === $secure) {\n                //Check for an OpenSSL constant rather than using extension_loaded, which is sometimes disabled\n                if (!$sslext) {\n                    throw new Exception($this->lang('extension_missing') . 'openssl', self::STOP_CRITICAL);\n                }\n            }\n            $host = $hostinfo[2];\n            $port = $this->Port;\n            if (\n                array_key_exists(3, $hostinfo) &&\n                is_numeric($hostinfo[3]) &&\n                $hostinfo[3] > 0 &&\n                $hostinfo[3] < 65536\n            ) {\n                $port = (int) $hostinfo[3];\n            }\n            if ($this->smtp->connect($prefix . $host, $port, $this->Timeout, $options)) {\n                try {\n                    if ($this->Helo) {\n                        $hello = $this->Helo;\n                    } else {\n                        $hello = $this->serverHostname();\n                    }\n                    $this->smtp->hello($hello);\n                    //Automatically enable TLS encryption if:\n                    //* it's not disabled\n                    //* we have openssl extension\n                    //* we are not already using SSL\n                    //* the server offers STARTTLS\n                    if ($this->SMTPAutoTLS && $sslext && 'ssl' !== $secure && $this->smtp->getServerExt('STARTTLS')) {\n                        $tls = true;\n                    }\n                    if ($tls) {\n                        if (!$this->smtp->startTLS()) {\n                            throw new Exception($this->lang('connect_host'));\n                        }\n                        //We must resend EHLO after TLS negotiation\n                        $this->smtp->hello($hello);\n                    }\n                    if (\n                        $this->SMTPAuth && !$this->smtp->authenticate(\n                            $this->Username,\n                            $this->Password,\n                            $this->AuthType,\n                            $this->oauth\n                        )\n                    ) {\n                        throw new Exception($this->lang('authenticate'));\n                    }\n\n                    return true;\n                } catch (Exception $exc) {\n                    $lastexception = $exc;\n                    $this->edebug($exc->getMessage());\n                    //We must have connected, but then failed TLS or Auth, so close connection nicely\n                    $this->smtp->quit();\n                }\n            }\n        }\n        //If we get here, all connection attempts have failed, so close connection hard\n        $this->smtp->close();\n        //As we've caught all exceptions, just report whatever the last one was\n        if ($this->exceptions && null !== $lastexception) {\n            throw $lastexception;\n        }\n\n        return false;\n    }\n\n    /**\n     * Close the active SMTP session if one exists.\n     */\n    public function smtpClose()\n    {\n        if ((null !== $this->smtp) && $this->smtp->connected()) {\n            $this->smtp->quit();\n            $this->smtp->close();\n        }\n    }\n\n    /**\n     * Set the language for error messages.\n     * Returns false if it cannot load the language file.\n     * The default language is English.\n     *\n     * @param string $langcode  ISO 639-1 2-character language code (e.g. French is \"fr\")\n     * @param string $lang_path Path to the language file directory, with trailing separator (slash)\n     *\n     * @return bool\n     */\n    public function setLanguage($langcode = 'en', $lang_path = '')\n    {\n        //Backwards compatibility for renamed language codes\n        $renamed_langcodes = [\n            'br' => 'pt_br',\n            'cz' => 'cs',\n            'dk' => 'da',\n            'no' => 'nb',\n            'se' => 'sv',\n            'rs' => 'sr',\n            'tg' => 'tl',\n            'am' => 'hy',\n        ];\n\n        if (array_key_exists($langcode, $renamed_langcodes)) {\n            $langcode = $renamed_langcodes[$langcode];\n        }\n\n        //Define full set of translatable strings in English\n        $PHPMAILER_LANG = [\n            'authenticate' => 'SMTP Error: Could not authenticate.',\n            'connect_host' => 'SMTP Error: Could not connect to SMTP host.',\n            'data_not_accepted' => 'SMTP Error: data not accepted.',\n            'empty_message' => 'Message body empty',\n            'encoding' => 'Unknown encoding: ',\n            'execute' => 'Could not execute: ',\n            'file_access' => 'Could not access file: ',\n            'file_open' => 'File Error: Could not open file: ',\n            'from_failed' => 'The following From address failed: ',\n            'instantiate' => 'Could not instantiate mail function.',\n            'invalid_address' => 'Invalid address: ',\n            'invalid_hostentry' => 'Invalid hostentry: ',\n            'invalid_host' => 'Invalid host: ',\n            'mailer_not_supported' => ' mailer is not supported.',\n            'provide_address' => 'You must provide at least one recipient email address.',\n            'recipients_failed' => 'SMTP Error: The following recipients failed: ',\n            'signing' => 'Signing Error: ',\n            'smtp_connect_failed' => 'SMTP connect() failed.',\n            'smtp_error' => 'SMTP server error: ',\n            'variable_set' => 'Cannot set or reset variable: ',\n            'extension_missing' => 'Extension missing: ',\n        ];\n        if (empty($lang_path)) {\n            //Calculate an absolute path so it can work if CWD is not here\n            $lang_path = dirname(__DIR__) . DIRECTORY_SEPARATOR . 'language' . DIRECTORY_SEPARATOR;\n        }\n        //Validate $langcode\n        if (!preg_match('/^[a-z]{2}(?:_[a-zA-Z]{2})?$/', $langcode)) {\n            $langcode = 'en';\n        }\n        $foundlang = true;\n        $lang_file = $lang_path . 'phpmailer.lang-' . $langcode . '.php';\n        //There is no English translation file\n        if ('en' !== $langcode) {\n            //Make sure language file path is readable\n            if (!static::fileIsAccessible($lang_file)) {\n                $foundlang = false;\n            } else {\n                //Overwrite language-specific strings.\n                //This way we'll never have missing translation keys.\n                $foundlang = include $lang_file;\n            }\n        }\n        $this->language = $PHPMAILER_LANG;\n\n        return (bool) $foundlang; //Returns false if language not found\n    }\n\n    /**\n     * Get the array of strings for the current language.\n     *\n     * @return array\n     */\n    public function getTranslations()\n    {\n        return $this->language;\n    }\n\n    /**\n     * Create recipient headers.\n     *\n     * @param string $type\n     * @param array  $addr An array of recipients,\n     *                     where each recipient is a 2-element indexed array with element 0 containing an address\n     *                     and element 1 containing a name, like:\n     *                     [['joe@example.com', 'Joe User'], ['zoe@example.com', 'Zoe User']]\n     *\n     * @return string\n     */\n    public function addrAppend($type, $addr)\n    {\n        $addresses = [];\n        foreach ($addr as $address) {\n            $addresses[] = $this->addrFormat($address);\n        }\n\n        return $type . ': ' . implode(', ', $addresses) . static::$LE;\n    }\n\n    /**\n     * Format an address for use in a message header.\n     *\n     * @param array $addr A 2-element indexed array, element 0 containing an address, element 1 containing a name like\n     *                    ['joe@example.com', 'Joe User']\n     *\n     * @return string\n     */\n    public function addrFormat($addr)\n    {\n        if (empty($addr[1])) { //No name provided\n            return $this->secureHeader($addr[0]);\n        }\n\n        return $this->encodeHeader($this->secureHeader($addr[1]), 'phrase') .\n            ' <' . $this->secureHeader($addr[0]) . '>';\n    }\n\n    /**\n     * Word-wrap message.\n     * For use with mailers that do not automatically perform wrapping\n     * and for quoted-printable encoded messages.\n     * Original written by philippe.\n     *\n     * @param string $message The message to wrap\n     * @param int    $length  The line length to wrap to\n     * @param bool   $qp_mode Whether to run in Quoted-Printable mode\n     *\n     * @return string\n     */\n    public function wrapText($message, $length, $qp_mode = false)\n    {\n        if ($qp_mode) {\n            $soft_break = sprintf(' =%s', static::$LE);\n        } else {\n            $soft_break = static::$LE;\n        }\n        //If utf-8 encoding is used, we will need to make sure we don't\n        //split multibyte characters when we wrap\n        $is_utf8 = static::CHARSET_UTF8 === strtolower($this->CharSet);\n        $lelen = strlen(static::$LE);\n        $crlflen = strlen(static::$LE);\n\n        $message = static::normalizeBreaks($message);\n        //Remove a trailing line break\n        if (substr($message, -$lelen) === static::$LE) {\n            $message = substr($message, 0, -$lelen);\n        }\n\n        //Split message into lines\n        $lines = explode(static::$LE, $message);\n        //Message will be rebuilt in here\n        $message = '';\n        foreach ($lines as $line) {\n            $words = explode(' ', $line);\n            $buf = '';\n            $firstword = true;\n            foreach ($words as $word) {\n                if ($qp_mode && (strlen($word) > $length)) {\n                    $space_left = $length - strlen($buf) - $crlflen;\n                    if (!$firstword) {\n                        if ($space_left > 20) {\n                            $len = $space_left;\n                            if ($is_utf8) {\n                                $len = $this->utf8CharBoundary($word, $len);\n                            } elseif ('=' === substr($word, $len - 1, 1)) {\n                                --$len;\n                            } elseif ('=' === substr($word, $len - 2, 1)) {\n                                $len -= 2;\n                            }\n                            $part = substr($word, 0, $len);\n                            $word = substr($word, $len);\n                            $buf .= ' ' . $part;\n                            $message .= $buf . sprintf('=%s', static::$LE);\n                        } else {\n                            $message .= $buf . $soft_break;\n                        }\n                        $buf = '';\n                    }\n                    while ($word !== '') {\n                        if ($length <= 0) {\n                            break;\n                        }\n                        $len = $length;\n                        if ($is_utf8) {\n                            $len = $this->utf8CharBoundary($word, $len);\n                        } elseif ('=' === substr($word, $len - 1, 1)) {\n                            --$len;\n                        } elseif ('=' === substr($word, $len - 2, 1)) {\n                            $len -= 2;\n                        }\n                        $part = substr($word, 0, $len);\n                        $word = (string) substr($word, $len);\n\n                        if ($word !== '') {\n                            $message .= $part . sprintf('=%s', static::$LE);\n                        } else {\n                            $buf = $part;\n                        }\n                    }\n                } else {\n                    $buf_o = $buf;\n                    if (!$firstword) {\n                        $buf .= ' ';\n                    }\n                    $buf .= $word;\n\n                    if ('' !== $buf_o && strlen($buf) > $length) {\n                        $message .= $buf_o . $soft_break;\n                        $buf = $word;\n                    }\n                }\n                $firstword = false;\n            }\n            $message .= $buf . static::$LE;\n        }\n\n        return $message;\n    }\n\n    /**\n     * Find the last character boundary prior to $maxLength in a utf-8\n     * quoted-printable encoded string.\n     * Original written by Colin Brown.\n     *\n     * @param string $encodedText utf-8 QP text\n     * @param int    $maxLength   Find the last character boundary prior to this length\n     *\n     * @return int\n     */\n    public function utf8CharBoundary($encodedText, $maxLength)\n    {\n        $foundSplitPos = false;\n        $lookBack = 3;\n        while (!$foundSplitPos) {\n            $lastChunk = substr($encodedText, $maxLength - $lookBack, $lookBack);\n            $encodedCharPos = strpos($lastChunk, '=');\n            if (false !== $encodedCharPos) {\n                //Found start of encoded character byte within $lookBack block.\n                //Check the encoded byte value (the 2 chars after the '=')\n                $hex = substr($encodedText, $maxLength - $lookBack + $encodedCharPos + 1, 2);\n                $dec = hexdec($hex);\n                if ($dec < 128) {\n                    //Single byte character.\n                    //If the encoded char was found at pos 0, it will fit\n                    //otherwise reduce maxLength to start of the encoded char\n                    if ($encodedCharPos > 0) {\n                        $maxLength -= $lookBack - $encodedCharPos;\n                    }\n                    $foundSplitPos = true;\n                } elseif ($dec >= 192) {\n                    //First byte of a multi byte character\n                    //Reduce maxLength to split at start of character\n                    $maxLength -= $lookBack - $encodedCharPos;\n                    $foundSplitPos = true;\n                } elseif ($dec < 192) {\n                    //Middle byte of a multi byte character, look further back\n                    $lookBack += 3;\n                }\n            } else {\n                //No encoded character found\n                $foundSplitPos = true;\n            }\n        }\n\n        return $maxLength;\n    }\n\n    /**\n     * Apply word wrapping to the message body.\n     * Wraps the message body to the number of chars set in the WordWrap property.\n     * You should only do this to plain-text bodies as wrapping HTML tags may break them.\n     * This is called automatically by createBody(), so you don't need to call it yourself.\n     */\n    public function setWordWrap()\n    {\n        if ($this->WordWrap < 1) {\n            return;\n        }\n\n        switch ($this->message_type) {\n            case 'alt':\n            case 'alt_inline':\n            case 'alt_attach':\n            case 'alt_inline_attach':\n                $this->AltBody = $this->wrapText($this->AltBody, $this->WordWrap);\n                break;\n            default:\n                $this->Body = $this->wrapText($this->Body, $this->WordWrap);\n                break;\n        }\n    }\n\n    /**\n     * Assemble message headers.\n     *\n     * @return string The assembled headers\n     */\n    public function createHeader()\n    {\n        $result = '';\n\n        $result .= $this->headerLine('Date', '' === $this->MessageDate ? self::rfcDate() : $this->MessageDate);\n\n        //The To header is created automatically by mail(), so needs to be omitted here\n        if ('mail' !== $this->Mailer) {\n            if ($this->SingleTo) {\n                foreach ($this->to as $toaddr) {\n                    $this->SingleToArray[] = $this->addrFormat($toaddr);\n                }\n            } elseif (count($this->to) > 0) {\n                $result .= $this->addrAppend('To', $this->to);\n            } elseif (count($this->cc) === 0) {\n                $result .= $this->headerLine('To', 'undisclosed-recipients:;');\n            }\n        }\n        $result .= $this->addrAppend('From', [[trim($this->From), $this->FromName]]);\n\n        //sendmail and mail() extract Cc from the header before sending\n        if (count($this->cc) > 0) {\n            $result .= $this->addrAppend('Cc', $this->cc);\n        }\n\n        //sendmail and mail() extract Bcc from the header before sending\n        if (\n            (\n                'sendmail' === $this->Mailer || 'qmail' === $this->Mailer || 'mail' === $this->Mailer\n            )\n            && count($this->bcc) > 0\n        ) {\n            $result .= $this->addrAppend('Bcc', $this->bcc);\n        }\n\n        if (count($this->ReplyTo) > 0) {\n            $result .= $this->addrAppend('Reply-To', $this->ReplyTo);\n        }\n\n        //mail() sets the subject itself\n        if ('mail' !== $this->Mailer) {\n            $result .= $this->headerLine('Subject', $this->encodeHeader($this->secureHeader($this->Subject)));\n        }\n\n        //Only allow a custom message ID if it conforms to RFC 5322 section 3.6.4\n        //https://tools.ietf.org/html/rfc5322#section-3.6.4\n        if ('' !== $this->MessageID && preg_match('/^<.*@.*>$/', $this->MessageID)) {\n            $this->lastMessageID = $this->MessageID;\n        } else {\n            $this->lastMessageID = sprintf('<%s@%s>', $this->uniqueid, $this->serverHostname());\n        }\n        $result .= $this->headerLine('Message-ID', $this->lastMessageID);\n        if (null !== $this->Priority) {\n            $result .= $this->headerLine('X-Priority', $this->Priority);\n        }\n        if ('' === $this->XMailer) {\n            $result .= $this->headerLine(\n                'X-Mailer',\n                'PHPMailer ' . self::VERSION . ' (https://github.com/PHPMailer/PHPMailer)'\n            );\n        } else {\n            $myXmailer = trim($this->XMailer);\n            if ($myXmailer) {\n                $result .= $this->headerLine('X-Mailer', $myXmailer);\n            }\n        }\n\n        if ('' !== $this->ConfirmReadingTo) {\n            $result .= $this->headerLine('Disposition-Notification-To', '<' . $this->ConfirmReadingTo . '>');\n        }\n\n        //Add custom headers\n        foreach ($this->CustomHeader as $header) {\n            $result .= $this->headerLine(\n                trim($header[0]),\n                $this->encodeHeader(trim($header[1]))\n            );\n        }\n        if (!$this->sign_key_file) {\n            $result .= $this->headerLine('MIME-Version', '1.0');\n            $result .= $this->getMailMIME();\n        }\n\n        return $result;\n    }\n\n    /**\n     * Get the message MIME type headers.\n     *\n     * @return string\n     */\n    public function getMailMIME()\n    {\n        $result = '';\n        $ismultipart = true;\n        switch ($this->message_type) {\n            case 'inline':\n                $result .= $this->headerLine('Content-Type', static::CONTENT_TYPE_MULTIPART_RELATED . ';');\n                $result .= $this->textLine(' boundary=\"' . $this->boundary[1] . '\"');\n                break;\n            case 'attach':\n            case 'inline_attach':\n            case 'alt_attach':\n            case 'alt_inline_attach':\n                $result .= $this->headerLine('Content-Type', static::CONTENT_TYPE_MULTIPART_MIXED . ';');\n                $result .= $this->textLine(' boundary=\"' . $this->boundary[1] . '\"');\n                break;\n            case 'alt':\n            case 'alt_inline':\n                $result .= $this->headerLine('Content-Type', static::CONTENT_TYPE_MULTIPART_ALTERNATIVE . ';');\n                $result .= $this->textLine(' boundary=\"' . $this->boundary[1] . '\"');\n                break;\n            default:\n                //Catches case 'plain': and case '':\n                $result .= $this->textLine('Content-Type: ' . $this->ContentType . '; charset=' . $this->CharSet);\n                $ismultipart = false;\n                break;\n        }\n        //RFC1341 part 5 says 7bit is assumed if not specified\n        if (static::ENCODING_7BIT !== $this->Encoding) {\n            //RFC 2045 section 6.4 says multipart MIME parts may only use 7bit, 8bit or binary CTE\n            if ($ismultipart) {\n                if (static::ENCODING_8BIT === $this->Encoding) {\n                    $result .= $this->headerLine('Content-Transfer-Encoding', static::ENCODING_8BIT);\n                }\n                //The only remaining alternatives are quoted-printable and base64, which are both 7bit compatible\n            } else {\n                $result .= $this->headerLine('Content-Transfer-Encoding', $this->Encoding);\n            }\n        }\n\n        return $result;\n    }\n\n    /**\n     * Returns the whole MIME message.\n     * Includes complete headers and body.\n     * Only valid post preSend().\n     *\n     * @see PHPMailer::preSend()\n     *\n     * @return string\n     */\n    public function getSentMIMEMessage()\n    {\n        return static::stripTrailingWSP($this->MIMEHeader . $this->mailHeader) .\n            static::$LE . static::$LE . $this->MIMEBody;\n    }\n\n    /**\n     * Create a unique ID to use for boundaries.\n     *\n     * @return string\n     */\n    protected function generateId()\n    {\n        $len = 32; //32 bytes = 256 bits\n        $bytes = '';\n        if (function_exists('random_bytes')) {\n            try {\n                $bytes = random_bytes($len);\n            } catch (\\Exception $e) {\n                //Do nothing\n            }\n        } elseif (function_exists('openssl_random_pseudo_bytes')) {\n            /** @noinspection CryptographicallySecureRandomnessInspection */\n            $bytes = openssl_random_pseudo_bytes($len);\n        }\n        if ($bytes === '') {\n            //We failed to produce a proper random string, so make do.\n            //Use a hash to force the length to the same as the other methods\n            $bytes = hash('sha256', uniqid((string) mt_rand(), true), true);\n        }\n\n        //We don't care about messing up base64 format here, just want a random string\n        return str_replace(['=', '+', '/'], '', base64_encode(hash('sha256', $bytes, true)));\n    }\n\n    /**\n     * Assemble the message body.\n     * Returns an empty string on failure.\n     *\n     * @throws Exception\n     *\n     * @return string The assembled message body\n     */\n    public function createBody()\n    {\n        $body = '';\n        //Create unique IDs and preset boundaries\n        $this->uniqueid = $this->generateId();\n        $this->boundary[1] = 'b1_' . $this->uniqueid;\n        $this->boundary[2] = 'b2_' . $this->uniqueid;\n        $this->boundary[3] = 'b3_' . $this->uniqueid;\n\n        if ($this->sign_key_file) {\n            $body .= $this->getMailMIME() . static::$LE;\n        }\n\n        $this->setWordWrap();\n\n        $bodyEncoding = $this->Encoding;\n        $bodyCharSet = $this->CharSet;\n        //Can we do a 7-bit downgrade?\n        if (static::ENCODING_8BIT === $bodyEncoding && !$this->has8bitChars($this->Body)) {\n            $bodyEncoding = static::ENCODING_7BIT;\n            //All ISO 8859, Windows codepage and UTF-8 charsets are ascii compatible up to 7-bit\n            $bodyCharSet = static::CHARSET_ASCII;\n        }\n        //If lines are too long, and we're not already using an encoding that will shorten them,\n        //change to quoted-printable transfer encoding for the body part only\n        if (static::ENCODING_BASE64 !== $this->Encoding && static::hasLineLongerThanMax($this->Body)) {\n            $bodyEncoding = static::ENCODING_QUOTED_PRINTABLE;\n        }\n\n        $altBodyEncoding = $this->Encoding;\n        $altBodyCharSet = $this->CharSet;\n        //Can we do a 7-bit downgrade?\n        if (static::ENCODING_8BIT === $altBodyEncoding && !$this->has8bitChars($this->AltBody)) {\n            $altBodyEncoding = static::ENCODING_7BIT;\n            //All ISO 8859, Windows codepage and UTF-8 charsets are ascii compatible up to 7-bit\n            $altBodyCharSet = static::CHARSET_ASCII;\n        }\n        //If lines are too long, and we're not already using an encoding that will shorten them,\n        //change to quoted-printable transfer encoding for the alt body part only\n        if (static::ENCODING_BASE64 !== $altBodyEncoding && static::hasLineLongerThanMax($this->AltBody)) {\n            $altBodyEncoding = static::ENCODING_QUOTED_PRINTABLE;\n        }\n        //Use this as a preamble in all multipart message types\n        $mimepre = 'This is a multi-part message in MIME format.' . static::$LE . static::$LE;\n        switch ($this->message_type) {\n            case 'inline':\n                $body .= $mimepre;\n                $body .= $this->getBoundary($this->boundary[1], $bodyCharSet, '', $bodyEncoding);\n                $body .= $this->encodeString($this->Body, $bodyEncoding);\n                $body .= static::$LE;\n                $body .= $this->attachAll('inline', $this->boundary[1]);\n                break;\n            case 'attach':\n                $body .= $mimepre;\n                $body .= $this->getBoundary($this->boundary[1], $bodyCharSet, '', $bodyEncoding);\n                $body .= $this->encodeString($this->Body, $bodyEncoding);\n                $body .= static::$LE;\n                $body .= $this->attachAll('attachment', $this->boundary[1]);\n                break;\n            case 'inline_attach':\n                $body .= $mimepre;\n                $body .= $this->textLine('--' . $this->boundary[1]);\n                $body .= $this->headerLine('Content-Type', static::CONTENT_TYPE_MULTIPART_RELATED . ';');\n                $body .= $this->textLine(' boundary=\"' . $this->boundary[2] . '\";');\n                $body .= $this->textLine(' type=\"' . static::CONTENT_TYPE_TEXT_HTML . '\"');\n                $body .= static::$LE;\n                $body .= $this->getBoundary($this->boundary[2], $bodyCharSet, '', $bodyEncoding);\n                $body .= $this->encodeString($this->Body, $bodyEncoding);\n                $body .= static::$LE;\n                $body .= $this->attachAll('inline', $this->boundary[2]);\n                $body .= static::$LE;\n                $body .= $this->attachAll('attachment', $this->boundary[1]);\n                break;\n            case 'alt':\n                $body .= $mimepre;\n                $body .= $this->getBoundary(\n                    $this->boundary[1],\n                    $altBodyCharSet,\n                    static::CONTENT_TYPE_PLAINTEXT,\n                    $altBodyEncoding\n                );\n                $body .= $this->encodeString($this->AltBody, $altBodyEncoding);\n                $body .= static::$LE;\n                $body .= $this->getBoundary(\n                    $this->boundary[1],\n                    $bodyCharSet,\n                    static::CONTENT_TYPE_TEXT_HTML,\n                    $bodyEncoding\n                );\n                $body .= $this->encodeString($this->Body, $bodyEncoding);\n                $body .= static::$LE;\n                if (!empty($this->Ical)) {\n                    $method = static::ICAL_METHOD_REQUEST;\n                    foreach (static::$IcalMethods as $imethod) {\n                        if (stripos($this->Ical, 'METHOD:' . $imethod) !== false) {\n                            $method = $imethod;\n                            break;\n                        }\n                    }\n                    $body .= $this->getBoundary(\n                        $this->boundary[1],\n                        '',\n                        static::CONTENT_TYPE_TEXT_CALENDAR . '; method=' . $method,\n                        ''\n                    );\n                    $body .= $this->encodeString($this->Ical, $this->Encoding);\n                    $body .= static::$LE;\n                }\n                $body .= $this->endBoundary($this->boundary[1]);\n                break;\n            case 'alt_inline':\n                $body .= $mimepre;\n                $body .= $this->getBoundary(\n                    $this->boundary[1],\n                    $altBodyCharSet,\n                    static::CONTENT_TYPE_PLAINTEXT,\n                    $altBodyEncoding\n                );\n                $body .= $this->encodeString($this->AltBody, $altBodyEncoding);\n                $body .= static::$LE;\n                $body .= $this->textLine('--' . $this->boundary[1]);\n                $body .= $this->headerLine('Content-Type', static::CONTENT_TYPE_MULTIPART_RELATED . ';');\n                $body .= $this->textLine(' boundary=\"' . $this->boundary[2] . '\";');\n                $body .= $this->textLine(' type=\"' . static::CONTENT_TYPE_TEXT_HTML . '\"');\n                $body .= static::$LE;\n                $body .= $this->getBoundary(\n                    $this->boundary[2],\n                    $bodyCharSet,\n                    static::CONTENT_TYPE_TEXT_HTML,\n                    $bodyEncoding\n                );\n                $body .= $this->encodeString($this->Body, $bodyEncoding);\n                $body .= static::$LE;\n                $body .= $this->attachAll('inline', $this->boundary[2]);\n                $body .= static::$LE;\n                $body .= $this->endBoundary($this->boundary[1]);\n                break;\n            case 'alt_attach':\n                $body .= $mimepre;\n                $body .= $this->textLine('--' . $this->boundary[1]);\n                $body .= $this->headerLine('Content-Type', static::CONTENT_TYPE_MULTIPART_ALTERNATIVE . ';');\n                $body .= $this->textLine(' boundary=\"' . $this->boundary[2] . '\"');\n                $body .= static::$LE;\n                $body .= $this->getBoundary(\n                    $this->boundary[2],\n                    $altBodyCharSet,\n                    static::CONTENT_TYPE_PLAINTEXT,\n                    $altBodyEncoding\n                );\n                $body .= $this->encodeString($this->AltBody, $altBodyEncoding);\n                $body .= static::$LE;\n                $body .= $this->getBoundary(\n                    $this->boundary[2],\n                    $bodyCharSet,\n                    static::CONTENT_TYPE_TEXT_HTML,\n                    $bodyEncoding\n                );\n                $body .= $this->encodeString($this->Body, $bodyEncoding);\n                $body .= static::$LE;\n                if (!empty($this->Ical)) {\n                    $method = static::ICAL_METHOD_REQUEST;\n                    foreach (static::$IcalMethods as $imethod) {\n                        if (stripos($this->Ical, 'METHOD:' . $imethod) !== false) {\n                            $method = $imethod;\n                            break;\n                        }\n                    }\n                    $body .= $this->getBoundary(\n                        $this->boundary[2],\n                        '',\n                        static::CONTENT_TYPE_TEXT_CALENDAR . '; method=' . $method,\n                        ''\n                    );\n                    $body .= $this->encodeString($this->Ical, $this->Encoding);\n                }\n                $body .= $this->endBoundary($this->boundary[2]);\n                $body .= static::$LE;\n                $body .= $this->attachAll('attachment', $this->boundary[1]);\n                break;\n            case 'alt_inline_attach':\n                $body .= $mimepre;\n                $body .= $this->textLine('--' . $this->boundary[1]);\n                $body .= $this->headerLine('Content-Type', static::CONTENT_TYPE_MULTIPART_ALTERNATIVE . ';');\n                $body .= $this->textLine(' boundary=\"' . $this->boundary[2] . '\"');\n                $body .= static::$LE;\n                $body .= $this->getBoundary(\n                    $this->boundary[2],\n                    $altBodyCharSet,\n                    static::CONTENT_TYPE_PLAINTEXT,\n                    $altBodyEncoding\n                );\n                $body .= $this->encodeString($this->AltBody, $altBodyEncoding);\n                $body .= static::$LE;\n                $body .= $this->textLine('--' . $this->boundary[2]);\n                $body .= $this->headerLine('Content-Type', static::CONTENT_TYPE_MULTIPART_RELATED . ';');\n                $body .= $this->textLine(' boundary=\"' . $this->boundary[3] . '\";');\n                $body .= $this->textLine(' type=\"' . static::CONTENT_TYPE_TEXT_HTML . '\"');\n                $body .= static::$LE;\n                $body .= $this->getBoundary(\n                    $this->boundary[3],\n                    $bodyCharSet,\n                    static::CONTENT_TYPE_TEXT_HTML,\n                    $bodyEncoding\n                );\n                $body .= $this->encodeString($this->Body, $bodyEncoding);\n                $body .= static::$LE;\n                $body .= $this->attachAll('inline', $this->boundary[3]);\n                $body .= static::$LE;\n                $body .= $this->endBoundary($this->boundary[2]);\n                $body .= static::$LE;\n                $body .= $this->attachAll('attachment', $this->boundary[1]);\n                break;\n            default:\n                //Catch case 'plain' and case '', applies to simple `text/plain` and `text/html` body content types\n                //Reset the `Encoding` property in case we changed it for line length reasons\n                $this->Encoding = $bodyEncoding;\n                $body .= $this->encodeString($this->Body, $this->Encoding);\n                break;\n        }\n\n        if ($this->isError()) {\n            $body = '';\n            if ($this->exceptions) {\n                throw new Exception($this->lang('empty_message'), self::STOP_CRITICAL);\n            }\n        } elseif ($this->sign_key_file) {\n            try {\n                if (!defined('PKCS7_TEXT')) {\n                    throw new Exception($this->lang('extension_missing') . 'openssl');\n                }\n\n                $file = tempnam(sys_get_temp_dir(), 'srcsign');\n                $signed = tempnam(sys_get_temp_dir(), 'mailsign');\n                file_put_contents($file, $body);\n\n                //Workaround for PHP bug https://bugs.php.net/bug.php?id=69197\n                if (empty($this->sign_extracerts_file)) {\n                    $sign = @openssl_pkcs7_sign(\n                        $file,\n                        $signed,\n                        'file://' . realpath($this->sign_cert_file),\n                        ['file://' . realpath($this->sign_key_file), $this->sign_key_pass],\n                        []\n                    );\n                } else {\n                    $sign = @openssl_pkcs7_sign(\n                        $file,\n                        $signed,\n                        'file://' . realpath($this->sign_cert_file),\n                        ['file://' . realpath($this->sign_key_file), $this->sign_key_pass],\n                        [],\n                        PKCS7_DETACHED,\n                        $this->sign_extracerts_file\n                    );\n                }\n\n                @unlink($file);\n                if ($sign) {\n                    $body = file_get_contents($signed);\n                    @unlink($signed);\n                    //The message returned by openssl contains both headers and body, so need to split them up\n                    $parts = explode(\"\\n\\n\", $body, 2);\n                    $this->MIMEHeader .= $parts[0] . static::$LE . static::$LE;\n                    $body = $parts[1];\n                } else {\n                    @unlink($signed);\n                    throw new Exception($this->lang('signing') . openssl_error_string());\n                }\n            } catch (Exception $exc) {\n                $body = '';\n                if ($this->exceptions) {\n                    throw $exc;\n                }\n            }\n        }\n\n        return $body;\n    }\n\n    /**\n     * Return the start of a message boundary.\n     *\n     * @param string $boundary\n     * @param string $charSet\n     * @param string $contentType\n     * @param string $encoding\n     *\n     * @return string\n     */\n    protected function getBoundary($boundary, $charSet, $contentType, $encoding)\n    {\n        $result = '';\n        if ('' === $charSet) {\n            $charSet = $this->CharSet;\n        }\n        if ('' === $contentType) {\n            $contentType = $this->ContentType;\n        }\n        if ('' === $encoding) {\n            $encoding = $this->Encoding;\n        }\n        $result .= $this->textLine('--' . $boundary);\n        $result .= sprintf('Content-Type: %s; charset=%s', $contentType, $charSet);\n        $result .= static::$LE;\n        //RFC1341 part 5 says 7bit is assumed if not specified\n        if (static::ENCODING_7BIT !== $encoding) {\n            $result .= $this->headerLine('Content-Transfer-Encoding', $encoding);\n        }\n        $result .= static::$LE;\n\n        return $result;\n    }\n\n    /**\n     * Return the end of a message boundary.\n     *\n     * @param string $boundary\n     *\n     * @return string\n     */\n    protected function endBoundary($boundary)\n    {\n        return static::$LE . '--' . $boundary . '--' . static::$LE;\n    }\n\n    /**\n     * Set the message type.\n     * PHPMailer only supports some preset message types, not arbitrary MIME structures.\n     */\n    protected function setMessageType()\n    {\n        $type = [];\n        if ($this->alternativeExists()) {\n            $type[] = 'alt';\n        }\n        if ($this->inlineImageExists()) {\n            $type[] = 'inline';\n        }\n        if ($this->attachmentExists()) {\n            $type[] = 'attach';\n        }\n        $this->message_type = implode('_', $type);\n        if ('' === $this->message_type) {\n            //The 'plain' message_type refers to the message having a single body element, not that it is plain-text\n            $this->message_type = 'plain';\n        }\n    }\n\n    /**\n     * Format a header line.\n     *\n     * @param string     $name\n     * @param string|int $value\n     *\n     * @return string\n     */\n    public function headerLine($name, $value)\n    {\n        return $name . ': ' . $value . static::$LE;\n    }\n\n    /**\n     * Return a formatted mail line.\n     *\n     * @param string $value\n     *\n     * @return string\n     */\n    public function textLine($value)\n    {\n        return $value . static::$LE;\n    }\n\n    /**\n     * Add an attachment from a path on the filesystem.\n     * Never use a user-supplied path to a file!\n     * Returns false if the file could not be found or read.\n     * Explicitly *does not* support passing URLs; PHPMailer is not an HTTP client.\n     * If you need to do that, fetch the resource yourself and pass it in via a local file or string.\n     *\n     * @param string $path        Path to the attachment\n     * @param string $name        Overrides the attachment name\n     * @param string $encoding    File encoding (see $Encoding)\n     * @param string $type        MIME type, e.g. `image/jpeg`; determined automatically from $path if not specified\n     * @param string $disposition Disposition to use\n     *\n     * @throws Exception\n     *\n     * @return bool\n     */\n    public function addAttachment(\n        $path,\n        $name = '',\n        $encoding = self::ENCODING_BASE64,\n        $type = '',\n        $disposition = 'attachment'\n    ) {\n        try {\n            if (!static::fileIsAccessible($path)) {\n                throw new Exception($this->lang('file_access') . $path, self::STOP_CONTINUE);\n            }\n\n            //If a MIME type is not specified, try to work it out from the file name\n            if ('' === $type) {\n                $type = static::filenameToType($path);\n            }\n\n            $filename = (string) static::mb_pathinfo($path, PATHINFO_BASENAME);\n            if ('' === $name) {\n                $name = $filename;\n            }\n            if (!$this->validateEncoding($encoding)) {\n                throw new Exception($this->lang('encoding') . $encoding);\n            }\n\n            $this->attachment[] = [\n                0 => $path,\n                1 => $filename,\n                2 => $name,\n                3 => $encoding,\n                4 => $type,\n                5 => false, //isStringAttachment\n                6 => $disposition,\n                7 => $name,\n            ];\n        } catch (Exception $exc) {\n            $this->setError($exc->getMessage());\n            $this->edebug($exc->getMessage());\n            if ($this->exceptions) {\n                throw $exc;\n            }\n\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * Return the array of attachments.\n     *\n     * @return array\n     */\n    public function getAttachments()\n    {\n        return $this->attachment;\n    }\n\n    /**\n     * Attach all file, string, and binary attachments to the message.\n     * Returns an empty string on failure.\n     *\n     * @param string $disposition_type\n     * @param string $boundary\n     *\n     * @throws Exception\n     *\n     * @return string\n     */\n    protected function attachAll($disposition_type, $boundary)\n    {\n        //Return text of body\n        $mime = [];\n        $cidUniq = [];\n        $incl = [];\n\n        //Add all attachments\n        foreach ($this->attachment as $attachment) {\n            //Check if it is a valid disposition_filter\n            if ($attachment[6] === $disposition_type) {\n                //Check for string attachment\n                $string = '';\n                $path = '';\n                $bString = $attachment[5];\n                if ($bString) {\n                    $string = $attachment[0];\n                } else {\n                    $path = $attachment[0];\n                }\n\n                $inclhash = hash('sha256', serialize($attachment));\n                if (in_array($inclhash, $incl, true)) {\n                    continue;\n                }\n                $incl[] = $inclhash;\n                $name = $attachment[2];\n                $encoding = $attachment[3];\n                $type = $attachment[4];\n                $disposition = $attachment[6];\n                $cid = $attachment[7];\n                if ('inline' === $disposition && array_key_exists($cid, $cidUniq)) {\n                    continue;\n                }\n                $cidUniq[$cid] = true;\n\n                $mime[] = sprintf('--%s%s', $boundary, static::$LE);\n                //Only include a filename property if we have one\n                if (!empty($name)) {\n                    $mime[] = sprintf(\n                        'Content-Type: %s; name=%s%s',\n                        $type,\n                        static::quotedString($this->encodeHeader($this->secureHeader($name))),\n                        static::$LE\n                    );\n                } else {\n                    $mime[] = sprintf(\n                        'Content-Type: %s%s',\n                        $type,\n                        static::$LE\n                    );\n                }\n                //RFC1341 part 5 says 7bit is assumed if not specified\n                if (static::ENCODING_7BIT !== $encoding) {\n                    $mime[] = sprintf('Content-Transfer-Encoding: %s%s', $encoding, static::$LE);\n                }\n\n                //Only set Content-IDs on inline attachments\n                if ((string) $cid !== '' && $disposition === 'inline') {\n                    $mime[] = 'Content-ID: <' . $this->encodeHeader($this->secureHeader($cid)) . '>' . static::$LE;\n                }\n\n                //Allow for bypassing the Content-Disposition header\n                if (!empty($disposition)) {\n                    $encoded_name = $this->encodeHeader($this->secureHeader($name));\n                    if (!empty($encoded_name)) {\n                        $mime[] = sprintf(\n                            'Content-Disposition: %s; filename=%s%s',\n                            $disposition,\n                            static::quotedString($encoded_name),\n                            static::$LE . static::$LE\n                        );\n                    } else {\n                        $mime[] = sprintf(\n                            'Content-Disposition: %s%s',\n                            $disposition,\n                            static::$LE . static::$LE\n                        );\n                    }\n                } else {\n                    $mime[] = static::$LE;\n                }\n\n                //Encode as string attachment\n                if ($bString) {\n                    $mime[] = $this->encodeString($string, $encoding);\n                } else {\n                    $mime[] = $this->encodeFile($path, $encoding);\n                }\n                if ($this->isError()) {\n                    return '';\n                }\n                $mime[] = static::$LE;\n            }\n        }\n\n        $mime[] = sprintf('--%s--%s', $boundary, static::$LE);\n\n        return implode('', $mime);\n    }\n\n    /**\n     * Encode a file attachment in requested format.\n     * Returns an empty string on failure.\n     *\n     * @param string $path     The full path to the file\n     * @param string $encoding The encoding to use; one of 'base64', '7bit', '8bit', 'binary', 'quoted-printable'\n     *\n     * @return string\n     */\n    protected function encodeFile($path, $encoding = self::ENCODING_BASE64)\n    {\n        try {\n            if (!static::fileIsAccessible($path)) {\n                throw new Exception($this->lang('file_open') . $path, self::STOP_CONTINUE);\n            }\n            $file_buffer = file_get_contents($path);\n            if (false === $file_buffer) {\n                throw new Exception($this->lang('file_open') . $path, self::STOP_CONTINUE);\n            }\n            $file_buffer = $this->encodeString($file_buffer, $encoding);\n\n            return $file_buffer;\n        } catch (Exception $exc) {\n            $this->setError($exc->getMessage());\n            $this->edebug($exc->getMessage());\n            if ($this->exceptions) {\n                throw $exc;\n            }\n\n            return '';\n        }\n    }\n\n    /**\n     * Encode a string in requested format.\n     * Returns an empty string on failure.\n     *\n     * @param string $str      The text to encode\n     * @param string $encoding The encoding to use; one of 'base64', '7bit', '8bit', 'binary', 'quoted-printable'\n     *\n     * @throws Exception\n     *\n     * @return string\n     */\n    public function encodeString($str, $encoding = self::ENCODING_BASE64)\n    {\n        $encoded = '';\n        switch (strtolower($encoding)) {\n            case static::ENCODING_BASE64:\n                $encoded = chunk_split(\n                    base64_encode($str),\n                    static::STD_LINE_LENGTH,\n                    static::$LE\n                );\n                break;\n            case static::ENCODING_7BIT:\n            case static::ENCODING_8BIT:\n                $encoded = static::normalizeBreaks($str);\n                //Make sure it ends with a line break\n                if (substr($encoded, -(strlen(static::$LE))) !== static::$LE) {\n                    $encoded .= static::$LE;\n                }\n                break;\n            case static::ENCODING_BINARY:\n                $encoded = $str;\n                break;\n            case static::ENCODING_QUOTED_PRINTABLE:\n                $encoded = $this->encodeQP($str);\n                break;\n            default:\n                $this->setError($this->lang('encoding') . $encoding);\n                if ($this->exceptions) {\n                    throw new Exception($this->lang('encoding') . $encoding);\n                }\n                break;\n        }\n\n        return $encoded;\n    }\n\n    /**\n     * Encode a header value (not including its label) optimally.\n     * Picks shortest of Q, B, or none. Result includes folding if needed.\n     * See RFC822 definitions for phrase, comment and text positions.\n     *\n     * @param string $str      The header value to encode\n     * @param string $position What context the string will be used in\n     *\n     * @return string\n     */\n    public function encodeHeader($str, $position = 'text')\n    {\n        $matchcount = 0;\n        switch (strtolower($position)) {\n            case 'phrase':\n                if (!preg_match('/[\\200-\\377]/', $str)) {\n                    //Can't use addslashes as we don't know the value of magic_quotes_sybase\n                    $encoded = addcslashes($str, \"\\0..\\37\\177\\\\\\\"\");\n                    if (($str === $encoded) && !preg_match('/[^A-Za-z0-9!#$%&\\'*+\\/=?^_`{|}~ -]/', $str)) {\n                        return $encoded;\n                    }\n\n                    return \"\\\"$encoded\\\"\";\n                }\n                $matchcount = preg_match_all('/[^\\040\\041\\043-\\133\\135-\\176]/', $str, $matches);\n                break;\n            /* @noinspection PhpMissingBreakStatementInspection */\n            case 'comment':\n                $matchcount = preg_match_all('/[()\"]/', $str, $matches);\n            //fallthrough\n            case 'text':\n            default:\n                $matchcount += preg_match_all('/[\\000-\\010\\013\\014\\016-\\037\\177-\\377]/', $str, $matches);\n                break;\n        }\n\n        if ($this->has8bitChars($str)) {\n            $charset = $this->CharSet;\n        } else {\n            $charset = static::CHARSET_ASCII;\n        }\n\n        //Q/B encoding adds 8 chars and the charset (\"` =?<charset>?[QB]?<content>?=`\").\n        $overhead = 8 + strlen($charset);\n\n        if ('mail' === $this->Mailer) {\n            $maxlen = static::MAIL_MAX_LINE_LENGTH - $overhead;\n        } else {\n            $maxlen = static::MAX_LINE_LENGTH - $overhead;\n        }\n\n        //Select the encoding that produces the shortest output and/or prevents corruption.\n        if ($matchcount > strlen($str) / 3) {\n            //More than 1/3 of the content needs encoding, use B-encode.\n            $encoding = 'B';\n        } elseif ($matchcount > 0) {\n            //Less than 1/3 of the content needs encoding, use Q-encode.\n            $encoding = 'Q';\n        } elseif (strlen($str) > $maxlen) {\n            //No encoding needed, but value exceeds max line length, use Q-encode to prevent corruption.\n            $encoding = 'Q';\n        } else {\n            //No reformatting needed\n            $encoding = false;\n        }\n\n        switch ($encoding) {\n            case 'B':\n                if ($this->hasMultiBytes($str)) {\n                    //Use a custom function which correctly encodes and wraps long\n                    //multibyte strings without breaking lines within a character\n                    $encoded = $this->base64EncodeWrapMB($str, \"\\n\");\n                } else {\n                    $encoded = base64_encode($str);\n                    $maxlen -= $maxlen % 4;\n                    $encoded = trim(chunk_split($encoded, $maxlen, \"\\n\"));\n                }\n                $encoded = preg_replace('/^(.*)$/m', ' =?' . $charset . \"?$encoding?\\\\1?=\", $encoded);\n                break;\n            case 'Q':\n                $encoded = $this->encodeQ($str, $position);\n                $encoded = $this->wrapText($encoded, $maxlen, true);\n                $encoded = str_replace('=' . static::$LE, \"\\n\", trim($encoded));\n                $encoded = preg_replace('/^(.*)$/m', ' =?' . $charset . \"?$encoding?\\\\1?=\", $encoded);\n                break;\n            default:\n                return $str;\n        }\n\n        return trim(static::normalizeBreaks($encoded));\n    }\n\n    /**\n     * Check if a string contains multi-byte characters.\n     *\n     * @param string $str multi-byte text to wrap encode\n     *\n     * @return bool\n     */\n    public function hasMultiBytes($str)\n    {\n        if (function_exists('mb_strlen')) {\n            return strlen($str) > mb_strlen($str, $this->CharSet);\n        }\n\n        //Assume no multibytes (we can't handle without mbstring functions anyway)\n        return false;\n    }\n\n    /**\n     * Does a string contain any 8-bit chars (in any charset)?\n     *\n     * @param string $text\n     *\n     * @return bool\n     */\n    public function has8bitChars($text)\n    {\n        return (bool) preg_match('/[\\x80-\\xFF]/', $text);\n    }\n\n    /**\n     * Encode and wrap long multibyte strings for mail headers\n     * without breaking lines within a character.\n     * Adapted from a function by paravoid.\n     *\n     * @see http://www.php.net/manual/en/function.mb-encode-mimeheader.php#60283\n     *\n     * @param string $str       multi-byte text to wrap encode\n     * @param string $linebreak string to use as linefeed/end-of-line\n     *\n     * @return string\n     */\n    public function base64EncodeWrapMB($str, $linebreak = null)\n    {\n        $start = '=?' . $this->CharSet . '?B?';\n        $end = '?=';\n        $encoded = '';\n        if (null === $linebreak) {\n            $linebreak = static::$LE;\n        }\n\n        $mb_length = mb_strlen($str, $this->CharSet);\n        //Each line must have length <= 75, including $start and $end\n        $length = 75 - strlen($start) - strlen($end);\n        //Average multi-byte ratio\n        $ratio = $mb_length / strlen($str);\n        //Base64 has a 4:3 ratio\n        $avgLength = floor($length * $ratio * .75);\n\n        $offset = 0;\n        for ($i = 0; $i < $mb_length; $i += $offset) {\n            $lookBack = 0;\n            do {\n                $offset = $avgLength - $lookBack;\n                $chunk = mb_substr($str, $i, $offset, $this->CharSet);\n                $chunk = base64_encode($chunk);\n                ++$lookBack;\n            } while (strlen($chunk) > $length);\n            $encoded .= $chunk . $linebreak;\n        }\n\n        //Chomp the last linefeed\n        return substr($encoded, 0, -strlen($linebreak));\n    }\n\n    /**\n     * Encode a string in quoted-printable format.\n     * According to RFC2045 section 6.7.\n     *\n     * @param string $string The text to encode\n     *\n     * @return string\n     */\n    public function encodeQP($string)\n    {\n        return static::normalizeBreaks(quoted_printable_encode($string));\n    }\n\n    /**\n     * Encode a string using Q encoding.\n     *\n     * @see http://tools.ietf.org/html/rfc2047#section-4.2\n     *\n     * @param string $str      the text to encode\n     * @param string $position Where the text is going to be used, see the RFC for what that means\n     *\n     * @return string\n     */\n    public function encodeQ($str, $position = 'text')\n    {\n        //There should not be any EOL in the string\n        $pattern = '';\n        $encoded = str_replace([\"\\r\", \"\\n\"], '', $str);\n        switch (strtolower($position)) {\n            case 'phrase':\n                //RFC 2047 section 5.3\n                $pattern = '^A-Za-z0-9!*+\\/ -';\n                break;\n            /*\n             * RFC 2047 section 5.2.\n             * Build $pattern without including delimiters and []\n             */\n            /* @noinspection PhpMissingBreakStatementInspection */\n            case 'comment':\n                $pattern = '\\(\\)\"';\n            /* Intentional fall through */\n            case 'text':\n            default:\n                //RFC 2047 section 5.1\n                //Replace every high ascii, control, =, ? and _ characters\n                $pattern = '\\000-\\011\\013\\014\\016-\\037\\075\\077\\137\\177-\\377' . $pattern;\n                break;\n        }\n        $matches = [];\n        if (preg_match_all(\"/[{$pattern}]/\", $encoded, $matches)) {\n            //If the string contains an '=', make sure it's the first thing we replace\n            //so as to avoid double-encoding\n            $eqkey = array_search('=', $matches[0], true);\n            if (false !== $eqkey) {\n                unset($matches[0][$eqkey]);\n                array_unshift($matches[0], '=');\n            }\n            foreach (array_unique($matches[0]) as $char) {\n                $encoded = str_replace($char, '=' . sprintf('%02X', ord($char)), $encoded);\n            }\n        }\n        //Replace spaces with _ (more readable than =20)\n        //RFC 2047 section 4.2(2)\n        return str_replace(' ', '_', $encoded);\n    }\n\n    /**\n     * Add a string or binary attachment (non-filesystem).\n     * This method can be used to attach ascii or binary data,\n     * such as a BLOB record from a database.\n     *\n     * @param string $string      String attachment data\n     * @param string $filename    Name of the attachment\n     * @param string $encoding    File encoding (see $Encoding)\n     * @param string $type        File extension (MIME) type\n     * @param string $disposition Disposition to use\n     *\n     * @throws Exception\n     *\n     * @return bool True on successfully adding an attachment\n     */\n    public function addStringAttachment(\n        $string,\n        $filename,\n        $encoding = self::ENCODING_BASE64,\n        $type = '',\n        $disposition = 'attachment'\n    ) {\n        try {\n            //If a MIME type is not specified, try to work it out from the file name\n            if ('' === $type) {\n                $type = static::filenameToType($filename);\n            }\n\n            if (!$this->validateEncoding($encoding)) {\n                throw new Exception($this->lang('encoding') . $encoding);\n            }\n\n            //Append to $attachment array\n            $this->attachment[] = [\n                0 => $string,\n                1 => $filename,\n                2 => static::mb_pathinfo($filename, PATHINFO_BASENAME),\n                3 => $encoding,\n                4 => $type,\n                5 => true, //isStringAttachment\n                6 => $disposition,\n                7 => 0,\n            ];\n        } catch (Exception $exc) {\n            $this->setError($exc->getMessage());\n            $this->edebug($exc->getMessage());\n            if ($this->exceptions) {\n                throw $exc;\n            }\n\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * Add an embedded (inline) attachment from a file.\n     * This can include images, sounds, and just about any other document type.\n     * These differ from 'regular' attachments in that they are intended to be\n     * displayed inline with the message, not just attached for download.\n     * This is used in HTML messages that embed the images\n     * the HTML refers to using the $cid value.\n     * Never use a user-supplied path to a file!\n     *\n     * @param string $path        Path to the attachment\n     * @param string $cid         Content ID of the attachment; Use this to reference\n     *                            the content when using an embedded image in HTML\n     * @param string $name        Overrides the attachment name\n     * @param string $encoding    File encoding (see $Encoding)\n     * @param string $type        File MIME type\n     * @param string $disposition Disposition to use\n     *\n     * @throws Exception\n     *\n     * @return bool True on successfully adding an attachment\n     */\n    public function addEmbeddedImage(\n        $path,\n        $cid,\n        $name = '',\n        $encoding = self::ENCODING_BASE64,\n        $type = '',\n        $disposition = 'inline'\n    ) {\n        try {\n            if (!static::fileIsAccessible($path)) {\n                throw new Exception($this->lang('file_access') . $path, self::STOP_CONTINUE);\n            }\n\n            //If a MIME type is not specified, try to work it out from the file name\n            if ('' === $type) {\n                $type = static::filenameToType($path);\n            }\n\n            if (!$this->validateEncoding($encoding)) {\n                throw new Exception($this->lang('encoding') . $encoding);\n            }\n\n            $filename = (string) static::mb_pathinfo($path, PATHINFO_BASENAME);\n            if ('' === $name) {\n                $name = $filename;\n            }\n\n            //Append to $attachment array\n            $this->attachment[] = [\n                0 => $path,\n                1 => $filename,\n                2 => $name,\n                3 => $encoding,\n                4 => $type,\n                5 => false, //isStringAttachment\n                6 => $disposition,\n                7 => $cid,\n            ];\n        } catch (Exception $exc) {\n            $this->setError($exc->getMessage());\n            $this->edebug($exc->getMessage());\n            if ($this->exceptions) {\n                throw $exc;\n            }\n\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * Add an embedded stringified attachment.\n     * This can include images, sounds, and just about any other document type.\n     * If your filename doesn't contain an extension, be sure to set the $type to an appropriate MIME type.\n     *\n     * @param string $string      The attachment binary data\n     * @param string $cid         Content ID of the attachment; Use this to reference\n     *                            the content when using an embedded image in HTML\n     * @param string $name        A filename for the attachment. If this contains an extension,\n     *                            PHPMailer will attempt to set a MIME type for the attachment.\n     *                            For example 'file.jpg' would get an 'image/jpeg' MIME type.\n     * @param string $encoding    File encoding (see $Encoding), defaults to 'base64'\n     * @param string $type        MIME type - will be used in preference to any automatically derived type\n     * @param string $disposition Disposition to use\n     *\n     * @throws Exception\n     *\n     * @return bool True on successfully adding an attachment\n     */\n    public function addStringEmbeddedImage(\n        $string,\n        $cid,\n        $name = '',\n        $encoding = self::ENCODING_BASE64,\n        $type = '',\n        $disposition = 'inline'\n    ) {\n        try {\n            //If a MIME type is not specified, try to work it out from the name\n            if ('' === $type && !empty($name)) {\n                $type = static::filenameToType($name);\n            }\n\n            if (!$this->validateEncoding($encoding)) {\n                throw new Exception($this->lang('encoding') . $encoding);\n            }\n\n            //Append to $attachment array\n            $this->attachment[] = [\n                0 => $string,\n                1 => $name,\n                2 => $name,\n                3 => $encoding,\n                4 => $type,\n                5 => true, //isStringAttachment\n                6 => $disposition,\n                7 => $cid,\n            ];\n        } catch (Exception $exc) {\n            $this->setError($exc->getMessage());\n            $this->edebug($exc->getMessage());\n            if ($this->exceptions) {\n                throw $exc;\n            }\n\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * Validate encodings.\n     *\n     * @param string $encoding\n     *\n     * @return bool\n     */\n    protected function validateEncoding($encoding)\n    {\n        return in_array(\n            $encoding,\n            [\n                self::ENCODING_7BIT,\n                self::ENCODING_QUOTED_PRINTABLE,\n                self::ENCODING_BASE64,\n                self::ENCODING_8BIT,\n                self::ENCODING_BINARY,\n            ],\n            true\n        );\n    }\n\n    /**\n     * Check if an embedded attachment is present with this cid.\n     *\n     * @param string $cid\n     *\n     * @return bool\n     */\n    protected function cidExists($cid)\n    {\n        foreach ($this->attachment as $attachment) {\n            if ('inline' === $attachment[6] && $cid === $attachment[7]) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Check if an inline attachment is present.\n     *\n     * @return bool\n     */\n    public function inlineImageExists()\n    {\n        foreach ($this->attachment as $attachment) {\n            if ('inline' === $attachment[6]) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Check if an attachment (non-inline) is present.\n     *\n     * @return bool\n     */\n    public function attachmentExists()\n    {\n        foreach ($this->attachment as $attachment) {\n            if ('attachment' === $attachment[6]) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Check if this message has an alternative body set.\n     *\n     * @return bool\n     */\n    public function alternativeExists()\n    {\n        return !empty($this->AltBody);\n    }\n\n    /**\n     * Clear queued addresses of given kind.\n     *\n     * @param string $kind 'to', 'cc', or 'bcc'\n     */\n    public function clearQueuedAddresses($kind)\n    {\n        $this->RecipientsQueue = array_filter(\n            $this->RecipientsQueue,\n            static function ($params) use ($kind) {\n                return $params[0] !== $kind;\n            }\n        );\n    }\n\n    /**\n     * Clear all To recipients.\n     */\n    public function clearAddresses()\n    {\n        foreach ($this->to as $to) {\n            unset($this->all_recipients[strtolower($to[0])]);\n        }\n        $this->to = [];\n        $this->clearQueuedAddresses('to');\n    }\n\n    /**\n     * Clear all CC recipients.\n     */\n    public function clearCCs()\n    {\n        foreach ($this->cc as $cc) {\n            unset($this->all_recipients[strtolower($cc[0])]);\n        }\n        $this->cc = [];\n        $this->clearQueuedAddresses('cc');\n    }\n\n    /**\n     * Clear all BCC recipients.\n     */\n    public function clearBCCs()\n    {\n        foreach ($this->bcc as $bcc) {\n            unset($this->all_recipients[strtolower($bcc[0])]);\n        }\n        $this->bcc = [];\n        $this->clearQueuedAddresses('bcc');\n    }\n\n    /**\n     * Clear all ReplyTo recipients.\n     */\n    public function clearReplyTos()\n    {\n        $this->ReplyTo = [];\n        $this->ReplyToQueue = [];\n    }\n\n    /**\n     * Clear all recipient types.\n     */\n    public function clearAllRecipients()\n    {\n        $this->to = [];\n        $this->cc = [];\n        $this->bcc = [];\n        $this->all_recipients = [];\n        $this->RecipientsQueue = [];\n    }\n\n    /**\n     * Clear all filesystem, string, and binary attachments.\n     */\n    public function clearAttachments()\n    {\n        $this->attachment = [];\n    }\n\n    /**\n     * Clear all custom headers.\n     */\n    public function clearCustomHeaders()\n    {\n        $this->CustomHeader = [];\n    }\n\n    /**\n     * Add an error message to the error container.\n     *\n     * @param string $msg\n     */\n    protected function setError($msg)\n    {\n        ++$this->error_count;\n        if ('smtp' === $this->Mailer && null !== $this->smtp) {\n            $lasterror = $this->smtp->getError();\n            if (!empty($lasterror['error'])) {\n                $msg .= $this->lang('smtp_error') . $lasterror['error'];\n                if (!empty($lasterror['detail'])) {\n                    $msg .= ' Detail: ' . $lasterror['detail'];\n                }\n                if (!empty($lasterror['smtp_code'])) {\n                    $msg .= ' SMTP code: ' . $lasterror['smtp_code'];\n                }\n                if (!empty($lasterror['smtp_code_ex'])) {\n                    $msg .= ' Additional SMTP info: ' . $lasterror['smtp_code_ex'];\n                }\n            }\n        }\n        $this->ErrorInfo = $msg;\n    }\n\n    /**\n     * Return an RFC 822 formatted date.\n     *\n     * @return string\n     */\n    public static function rfcDate()\n    {\n        //Set the time zone to whatever the default is to avoid 500 errors\n        //Will default to UTC if it's not set properly in php.ini\n        date_default_timezone_set(@date_default_timezone_get());\n\n        return date('D, j M Y H:i:s O');\n    }\n\n    /**\n     * Get the server hostname.\n     * Returns 'localhost.localdomain' if unknown.\n     *\n     * @return string\n     */\n    protected function serverHostname()\n    {\n        $result = '';\n        if (!empty($this->Hostname)) {\n            $result = $this->Hostname;\n        } elseif (isset($_SERVER) && array_key_exists('SERVER_NAME', $_SERVER)) {\n            $result = $_SERVER['SERVER_NAME'];\n        } elseif (function_exists('gethostname') && gethostname() !== false) {\n            $result = gethostname();\n        } elseif (php_uname('n') !== false) {\n            $result = php_uname('n');\n        }\n        if (!static::isValidHost($result)) {\n            return 'localhost.localdomain';\n        }\n\n        return $result;\n    }\n\n    /**\n     * Validate whether a string contains a valid value to use as a hostname or IP address.\n     * IPv6 addresses must include [], e.g. `[::1]`, not just `::1`.\n     *\n     * @param string $host The host name or IP address to check\n     *\n     * @return bool\n     */\n    public static function isValidHost($host)\n    {\n        //Simple syntax limits\n        if (\n            empty($host)\n            || !is_string($host)\n            || strlen($host) > 256\n            || !preg_match('/^([a-zA-Z\\d.-]*|\\[[a-fA-F\\d:]+])$/', $host)\n        ) {\n            return false;\n        }\n        //Looks like a bracketed IPv6 address\n        if (strlen($host) > 2 && substr($host, 0, 1) === '[' && substr($host, -1, 1) === ']') {\n            return filter_var(substr($host, 1, -1), FILTER_VALIDATE_IP, FILTER_FLAG_IPV6) !== false;\n        }\n        //If removing all the dots results in a numeric string, it must be an IPv4 address.\n        //Need to check this first because otherwise things like `999.0.0.0` are considered valid host names\n        if (is_numeric(str_replace('.', '', $host))) {\n            //Is it a valid IPv4 address?\n            return filter_var($host, FILTER_VALIDATE_IP, FILTER_FLAG_IPV4) !== false;\n        }\n        if (filter_var('http://' . $host, FILTER_VALIDATE_URL) !== false) {\n            //Is it a syntactically valid hostname?\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Get an error message in the current language.\n     *\n     * @param string $key\n     *\n     * @return string\n     */\n    protected function lang($key)\n    {\n        if (count($this->language) < 1) {\n            $this->setLanguage(); //Set the default language\n        }\n\n        if (array_key_exists($key, $this->language)) {\n            if ('smtp_connect_failed' === $key) {\n                //Include a link to troubleshooting docs on SMTP connection failure.\n                //This is by far the biggest cause of support questions\n                //but it's usually not PHPMailer's fault.\n                return $this->language[$key] . ' https://github.com/PHPMailer/PHPMailer/wiki/Troubleshooting';\n            }\n\n            return $this->language[$key];\n        }\n\n        //Return the key as a fallback\n        return $key;\n    }\n\n    /**\n     * Check if an error occurred.\n     *\n     * @return bool True if an error did occur\n     */\n    public function isError()\n    {\n        return $this->error_count > 0;\n    }\n\n    /**\n     * Add a custom header.\n     * $name value can be overloaded to contain\n     * both header name and value (name:value).\n     *\n     * @param string      $name  Custom header name\n     * @param string|null $value Header value\n     *\n     * @throws Exception\n     */\n    public function addCustomHeader($name, $value = null)\n    {\n        if (null === $value && strpos($name, ':') !== false) {\n            //Value passed in as name:value\n            list($name, $value) = explode(':', $name, 2);\n        }\n        $name = trim($name);\n        $value = trim($value);\n        //Ensure name is not empty, and that neither name nor value contain line breaks\n        if (empty($name) || strpbrk($name . $value, \"\\r\\n\") !== false) {\n            if ($this->exceptions) {\n                throw new Exception('Invalid header name or value');\n            }\n\n            return false;\n        }\n        $this->CustomHeader[] = [$name, $value];\n\n        return true;\n    }\n\n    /**\n     * Returns all custom headers.\n     *\n     * @return array\n     */\n    public function getCustomHeaders()\n    {\n        return $this->CustomHeader;\n    }\n\n    /**\n     * Create a message body from an HTML string.\n     * Automatically inlines images and creates a plain-text version by converting the HTML,\n     * overwriting any existing values in Body and AltBody.\n     * Do not source $message content from user input!\n     * $basedir is prepended when handling relative URLs, e.g. <img src=\"/images/a.png\"> and must not be empty\n     * will look for an image file in $basedir/images/a.png and convert it to inline.\n     * If you don't provide a $basedir, relative paths will be left untouched (and thus probably break in email)\n     * Converts data-uri images into embedded attachments.\n     * If you don't want to apply these transformations to your HTML, just set Body and AltBody directly.\n     *\n     * @param string        $message  HTML message string\n     * @param string        $basedir  Absolute path to a base directory to prepend to relative paths to images\n     * @param bool|callable $advanced Whether to use the internal HTML to text converter\n     *                                or your own custom converter\n     * @return string The transformed message body\n     *\n     * @throws Exception\n     *\n     * @see PHPMailer::html2text()\n     */\n    public function msgHTML($message, $basedir = '', $advanced = false)\n    {\n        preg_match_all('/(?<!-)(src|background)=[\"\\'](.*)[\"\\']/Ui', $message, $images);\n        if (array_key_exists(2, $images)) {\n            if (strlen($basedir) > 1 && '/' !== substr($basedir, -1)) {\n                //Ensure $basedir has a trailing /\n                $basedir .= '/';\n            }\n            foreach ($images[2] as $imgindex => $url) {\n                //Convert data URIs into embedded images\n                //e.g. \"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\"\n                $match = [];\n                if (preg_match('#^data:(image/(?:jpe?g|gif|png));?(base64)?,(.+)#', $url, $match)) {\n                    if (count($match) === 4 && static::ENCODING_BASE64 === $match[2]) {\n                        $data = base64_decode($match[3]);\n                    } elseif ('' === $match[2]) {\n                        $data = rawurldecode($match[3]);\n                    } else {\n                        //Not recognised so leave it alone\n                        continue;\n                    }\n                    //Hash the decoded data, not the URL, so that the same data-URI image used in multiple places\n                    //will only be embedded once, even if it used a different encoding\n                    $cid = substr(hash('sha256', $data), 0, 32) . '@phpmailer.0'; //RFC2392 S 2\n\n                    if (!$this->cidExists($cid)) {\n                        $this->addStringEmbeddedImage(\n                            $data,\n                            $cid,\n                            'embed' . $imgindex,\n                            static::ENCODING_BASE64,\n                            $match[1]\n                        );\n                    }\n                    $message = str_replace(\n                        $images[0][$imgindex],\n                        $images[1][$imgindex] . '=\"cid:' . $cid . '\"',\n                        $message\n                    );\n                    continue;\n                }\n                if (\n                    //Only process relative URLs if a basedir is provided (i.e. no absolute local paths)\n                    !empty($basedir)\n                    //Ignore URLs containing parent dir traversal (..)\n                    && (strpos($url, '..') === false)\n                    //Do not change urls that are already inline images\n                    && 0 !== strpos($url, 'cid:')\n                    //Do not change absolute URLs, including anonymous protocol\n                    && !preg_match('#^[a-z][a-z0-9+.-]*:?//#i', $url)\n                ) {\n                    $filename = static::mb_pathinfo($url, PATHINFO_BASENAME);\n                    $directory = dirname($url);\n                    if ('.' === $directory) {\n                        $directory = '';\n                    }\n                    //RFC2392 S 2\n                    $cid = substr(hash('sha256', $url), 0, 32) . '@phpmailer.0';\n                    if (strlen($basedir) > 1 && '/' !== substr($basedir, -1)) {\n                        $basedir .= '/';\n                    }\n                    if (strlen($directory) > 1 && '/' !== substr($directory, -1)) {\n                        $directory .= '/';\n                    }\n                    if (\n                        $this->addEmbeddedImage(\n                            $basedir . $directory . $filename,\n                            $cid,\n                            $filename,\n                            static::ENCODING_BASE64,\n                            static::_mime_types((string) static::mb_pathinfo($filename, PATHINFO_EXTENSION))\n                        )\n                    ) {\n                        $message = preg_replace(\n                            '/' . $images[1][$imgindex] . '=[\"\\']' . preg_quote($url, '/') . '[\"\\']/Ui',\n                            $images[1][$imgindex] . '=\"cid:' . $cid . '\"',\n                            $message\n                        );\n                    }\n                }\n            }\n        }\n        $this->isHTML();\n        //Convert all message body line breaks to LE, makes quoted-printable encoding work much better\n        $this->Body = static::normalizeBreaks($message);\n        $this->AltBody = static::normalizeBreaks($this->html2text($message, $advanced));\n        if (!$this->alternativeExists()) {\n            $this->AltBody = 'This is an HTML-only message. To view it, activate HTML in your email application.'\n                . static::$LE;\n        }\n\n        return $this->Body;\n    }\n\n    /**\n     * Convert an HTML string into plain text.\n     * This is used by msgHTML().\n     * Note - older versions of this function used a bundled advanced converter\n     * which was removed for license reasons in #232.\n     * Example usage:\n     *\n     * ```php\n     * //Use default conversion\n     * $plain = $mail->html2text($html);\n     * //Use your own custom converter\n     * $plain = $mail->html2text($html, function($html) {\n     *     $converter = new MyHtml2text($html);\n     *     return $converter->get_text();\n     * });\n     * ```\n     *\n     * @param string        $html     The HTML text to convert\n     * @param bool|callable $advanced Any boolean value to use the internal converter,\n     *                                or provide your own callable for custom conversion\n     *\n     * @return string\n     */\n    public function html2text($html, $advanced = false)\n    {\n        if (is_callable($advanced)) {\n            return call_user_func($advanced, $html);\n        }\n\n        return html_entity_decode(\n            trim(strip_tags(preg_replace('/<(head|title|style|script)[^>]*>.*?<\\/\\\\1>/si', '', $html))),\n            ENT_QUOTES,\n            $this->CharSet\n        );\n    }\n\n    /**\n     * Get the MIME type for a file extension.\n     *\n     * @param string $ext File extension\n     *\n     * @return string MIME type of file\n     */\n    public static function _mime_types($ext = '')\n    {\n        $mimes = [\n            'xl' => 'application/excel',\n            'js' => 'application/javascript',\n            'hqx' => 'application/mac-binhex40',\n            'cpt' => 'application/mac-compactpro',\n            'bin' => 'application/macbinary',\n            'doc' => 'application/msword',\n            'word' => 'application/msword',\n            'xlsx' => 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',\n            'xltx' => 'application/vnd.openxmlformats-officedocument.spreadsheetml.template',\n            'potx' => 'application/vnd.openxmlformats-officedocument.presentationml.template',\n            'ppsx' => 'application/vnd.openxmlformats-officedocument.presentationml.slideshow',\n            'pptx' => 'application/vnd.openxmlformats-officedocument.presentationml.presentation',\n            'sldx' => 'application/vnd.openxmlformats-officedocument.presentationml.slide',\n            'docx' => 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',\n            'dotx' => 'application/vnd.openxmlformats-officedocument.wordprocessingml.template',\n            'xlam' => 'application/vnd.ms-excel.addin.macroEnabled.12',\n            'xlsb' => 'application/vnd.ms-excel.sheet.binary.macroEnabled.12',\n            'class' => 'application/octet-stream',\n            'dll' => 'application/octet-stream',\n            'dms' => 'application/octet-stream',\n            'exe' => 'application/octet-stream',\n            'lha' => 'application/octet-stream',\n            'lzh' => 'application/octet-stream',\n            'psd' => 'application/octet-stream',\n            'sea' => 'application/octet-stream',\n            'so' => 'application/octet-stream',\n            'oda' => 'application/oda',\n            'pdf' => 'application/pdf',\n            'ai' => 'application/postscript',\n            'eps' => 'application/postscript',\n            'ps' => 'application/postscript',\n            'smi' => 'application/smil',\n            'smil' => 'application/smil',\n            'mif' => 'application/vnd.mif',\n            'xls' => 'application/vnd.ms-excel',\n            'ppt' => 'application/vnd.ms-powerpoint',\n            'wbxml' => 'application/vnd.wap.wbxml',\n            'wmlc' => 'application/vnd.wap.wmlc',\n            'dcr' => 'application/x-director',\n            'dir' => 'application/x-director',\n            'dxr' => 'application/x-director',\n            'dvi' => 'application/x-dvi',\n            'gtar' => 'application/x-gtar',\n            'php3' => 'application/x-httpd-php',\n            'php4' => 'application/x-httpd-php',\n            'php' => 'application/x-httpd-php',\n            'phtml' => 'application/x-httpd-php',\n            'phps' => 'application/x-httpd-php-source',\n            'swf' => 'application/x-shockwave-flash',\n            'sit' => 'application/x-stuffit',\n            'tar' => 'application/x-tar',\n            'tgz' => 'application/x-tar',\n            'xht' => 'application/xhtml+xml',\n            'xhtml' => 'application/xhtml+xml',\n            'zip' => 'application/zip',\n            'mid' => 'audio/midi',\n            'midi' => 'audio/midi',\n            'mp2' => 'audio/mpeg',\n            'mp3' => 'audio/mpeg',\n            'm4a' => 'audio/mp4',\n            'mpga' => 'audio/mpeg',\n            'aif' => 'audio/x-aiff',\n            'aifc' => 'audio/x-aiff',\n            'aiff' => 'audio/x-aiff',\n            'ram' => 'audio/x-pn-realaudio',\n            'rm' => 'audio/x-pn-realaudio',\n            'rpm' => 'audio/x-pn-realaudio-plugin',\n            'ra' => 'audio/x-realaudio',\n            'wav' => 'audio/x-wav',\n            'mka' => 'audio/x-matroska',\n            'bmp' => 'image/bmp',\n            'gif' => 'image/gif',\n            'jpeg' => 'image/jpeg',\n            'jpe' => 'image/jpeg',\n            'jpg' => 'image/jpeg',\n            'png' => 'image/png',\n            'tiff' => 'image/tiff',\n            'tif' => 'image/tiff',\n            'webp' => 'image/webp',\n            'avif' => 'image/avif',\n            'heif' => 'image/heif',\n            'heifs' => 'image/heif-sequence',\n            'heic' => 'image/heic',\n            'heics' => 'image/heic-sequence',\n            'eml' => 'message/rfc822',\n            'css' => 'text/css',\n            'html' => 'text/html',\n            'htm' => 'text/html',\n            'shtml' => 'text/html',\n            'log' => 'text/plain',\n            'text' => 'text/plain',\n            'txt' => 'text/plain',\n            'rtx' => 'text/richtext',\n            'rtf' => 'text/rtf',\n            'vcf' => 'text/vcard',\n            'vcard' => 'text/vcard',\n            'ics' => 'text/calendar',\n            'xml' => 'text/xml',\n            'xsl' => 'text/xml',\n            'wmv' => 'video/x-ms-wmv',\n            'mpeg' => 'video/mpeg',\n            'mpe' => 'video/mpeg',\n            'mpg' => 'video/mpeg',\n            'mp4' => 'video/mp4',\n            'm4v' => 'video/mp4',\n            'mov' => 'video/quicktime',\n            'qt' => 'video/quicktime',\n            'rv' => 'video/vnd.rn-realvideo',\n            'avi' => 'video/x-msvideo',\n            'movie' => 'video/x-sgi-movie',\n            'webm' => 'video/webm',\n            'mkv' => 'video/x-matroska',\n        ];\n        $ext = strtolower($ext);\n        if (array_key_exists($ext, $mimes)) {\n            return $mimes[$ext];\n        }\n\n        return 'application/octet-stream';\n    }\n\n    /**\n     * Map a file name to a MIME type.\n     * Defaults to 'application/octet-stream', i.e.. arbitrary binary data.\n     *\n     * @param string $filename A file name or full path, does not need to exist as a file\n     *\n     * @return string\n     */\n    public static function filenameToType($filename)\n    {\n        //In case the path is a URL, strip any query string before getting extension\n        $qpos = strpos($filename, '?');\n        if (false !== $qpos) {\n            $filename = substr($filename, 0, $qpos);\n        }\n        $ext = static::mb_pathinfo($filename, PATHINFO_EXTENSION);\n\n        return static::_mime_types($ext);\n    }\n\n    /**\n     * Multi-byte-safe pathinfo replacement.\n     * Drop-in replacement for pathinfo(), but multibyte- and cross-platform-safe.\n     *\n     * @see http://www.php.net/manual/en/function.pathinfo.php#107461\n     *\n     * @param string     $path    A filename or path, does not need to exist as a file\n     * @param int|string $options Either a PATHINFO_* constant,\n     *                            or a string name to return only the specified piece\n     *\n     * @return string|array\n     */\n    public static function mb_pathinfo($path, $options = null)\n    {\n        $ret = ['dirname' => '', 'basename' => '', 'extension' => '', 'filename' => ''];\n        $pathinfo = [];\n        if (preg_match('#^(.*?)[\\\\\\\\/]*(([^/\\\\\\\\]*?)(\\.([^.\\\\\\\\/]+?)|))[\\\\\\\\/.]*$#m', $path, $pathinfo)) {\n            if (array_key_exists(1, $pathinfo)) {\n                $ret['dirname'] = $pathinfo[1];\n            }\n            if (array_key_exists(2, $pathinfo)) {\n                $ret['basename'] = $pathinfo[2];\n            }\n            if (array_key_exists(5, $pathinfo)) {\n                $ret['extension'] = $pathinfo[5];\n            }\n            if (array_key_exists(3, $pathinfo)) {\n                $ret['filename'] = $pathinfo[3];\n            }\n        }\n        switch ($options) {\n            case PATHINFO_DIRNAME:\n            case 'dirname':\n                return $ret['dirname'];\n            case PATHINFO_BASENAME:\n            case 'basename':\n                return $ret['basename'];\n            case PATHINFO_EXTENSION:\n            case 'extension':\n                return $ret['extension'];\n            case PATHINFO_FILENAME:\n            case 'filename':\n                return $ret['filename'];\n            default:\n                return $ret;\n        }\n    }\n\n    /**\n     * Set or reset instance properties.\n     * You should avoid this function - it's more verbose, less efficient, more error-prone and\n     * harder to debug than setting properties directly.\n     * Usage Example:\n     * `$mail->set('SMTPSecure', static::ENCRYPTION_STARTTLS);`\n     *   is the same as:\n     * `$mail->SMTPSecure = static::ENCRYPTION_STARTTLS;`.\n     *\n     * @param string $name  The property name to set\n     * @param mixed  $value The value to set the property to\n     *\n     * @return bool\n     */\n    public function set($name, $value = '')\n    {\n        if (property_exists($this, $name)) {\n            $this->$name = $value;\n\n            return true;\n        }\n        $this->setError($this->lang('variable_set') . $name);\n\n        return false;\n    }\n\n    /**\n     * Strip newlines to prevent header injection.\n     *\n     * @param string $str\n     *\n     * @return string\n     */\n    public function secureHeader($str)\n    {\n        return trim(str_replace([\"\\r\", \"\\n\"], '', $str));\n    }\n\n    /**\n     * Normalize line breaks in a string.\n     * Converts UNIX LF, Mac CR and Windows CRLF line breaks into a single line break format.\n     * Defaults to CRLF (for message bodies) and preserves consecutive breaks.\n     *\n     * @param string $text\n     * @param string $breaktype What kind of line break to use; defaults to static::$LE\n     *\n     * @return string\n     */\n    public static function normalizeBreaks($text, $breaktype = null)\n    {\n        if (null === $breaktype) {\n            $breaktype = static::$LE;\n        }\n        //Normalise to \\n\n        $text = str_replace([self::CRLF, \"\\r\"], \"\\n\", $text);\n        //Now convert LE as needed\n        if (\"\\n\" !== $breaktype) {\n            $text = str_replace(\"\\n\", $breaktype, $text);\n        }\n\n        return $text;\n    }\n\n    /**\n     * Remove trailing breaks from a string.\n     *\n     * @param string $text\n     *\n     * @return string The text to remove breaks from\n     */\n    public static function stripTrailingWSP($text)\n    {\n        return rtrim($text, \" \\r\\n\\t\");\n    }\n\n    /**\n     * Return the current line break format string.\n     *\n     * @return string\n     */\n    public static function getLE()\n    {\n        return static::$LE;\n    }\n\n    /**\n     * Set the line break format string, e.g. \"\\r\\n\".\n     *\n     * @param string $le\n     */\n    protected static function setLE($le)\n    {\n        static::$LE = $le;\n    }\n\n    /**\n     * Set the public and private key files and password for S/MIME signing.\n     *\n     * @param string $cert_filename\n     * @param string $key_filename\n     * @param string $key_pass            Password for private key\n     * @param string $extracerts_filename Optional path to chain certificate\n     */\n    public function sign($cert_filename, $key_filename, $key_pass, $extracerts_filename = '')\n    {\n        $this->sign_cert_file = $cert_filename;\n        $this->sign_key_file = $key_filename;\n        $this->sign_key_pass = $key_pass;\n        $this->sign_extracerts_file = $extracerts_filename;\n    }\n\n    /**\n     * Quoted-Printable-encode a DKIM header.\n     *\n     * @param string $txt\n     *\n     * @return string\n     */\n    public function DKIM_QP($txt)\n    {\n        $line = '';\n        $len = strlen($txt);\n        for ($i = 0; $i < $len; ++$i) {\n            $ord = ord($txt[$i]);\n            if (((0x21 <= $ord) && ($ord <= 0x3A)) || $ord === 0x3C || ((0x3E <= $ord) && ($ord <= 0x7E))) {\n                $line .= $txt[$i];\n            } else {\n                $line .= '=' . sprintf('%02X', $ord);\n            }\n        }\n\n        return $line;\n    }\n\n    /**\n     * Generate a DKIM signature.\n     *\n     * @param string $signHeader\n     *\n     * @throws Exception\n     *\n     * @return string The DKIM signature value\n     */\n    public function DKIM_Sign($signHeader)\n    {\n        if (!defined('PKCS7_TEXT')) {\n            if ($this->exceptions) {\n                throw new Exception($this->lang('extension_missing') . 'openssl');\n            }\n\n            return '';\n        }\n        $privKeyStr = !empty($this->DKIM_private_string) ?\n            $this->DKIM_private_string :\n            file_get_contents($this->DKIM_private);\n        if ('' !== $this->DKIM_passphrase) {\n            $privKey = openssl_pkey_get_private($privKeyStr, $this->DKIM_passphrase);\n        } else {\n            $privKey = openssl_pkey_get_private($privKeyStr);\n        }\n        if (openssl_sign($signHeader, $signature, $privKey, 'sha256WithRSAEncryption')) {\n            if (\\PHP_MAJOR_VERSION < 8) {\n                openssl_pkey_free($privKey);\n            }\n\n            return base64_encode($signature);\n        }\n        if (\\PHP_MAJOR_VERSION < 8) {\n            openssl_pkey_free($privKey);\n        }\n\n        return '';\n    }\n\n    /**\n     * Generate a DKIM canonicalization header.\n     * Uses the 'relaxed' algorithm from RFC6376 section 3.4.2.\n     * Canonicalized headers should *always* use CRLF, regardless of mailer setting.\n     *\n     * @see https://tools.ietf.org/html/rfc6376#section-3.4.2\n     *\n     * @param string $signHeader Header\n     *\n     * @return string\n     */\n    public function DKIM_HeaderC($signHeader)\n    {\n        //Normalize breaks to CRLF (regardless of the mailer)\n        $signHeader = static::normalizeBreaks($signHeader, self::CRLF);\n        //Unfold header lines\n        //Note PCRE \\s is too broad a definition of whitespace; RFC5322 defines it as `[ \\t]`\n        //@see https://tools.ietf.org/html/rfc5322#section-2.2\n        //That means this may break if you do something daft like put vertical tabs in your headers.\n        $signHeader = preg_replace('/\\r\\n[ \\t]+/', ' ', $signHeader);\n        //Break headers out into an array\n        $lines = explode(self::CRLF, $signHeader);\n        foreach ($lines as $key => $line) {\n            //If the header is missing a :, skip it as it's invalid\n            //This is likely to happen because the explode() above will also split\n            //on the trailing LE, leaving an empty line\n            if (strpos($line, ':') === false) {\n                continue;\n            }\n            list($heading, $value) = explode(':', $line, 2);\n            //Lower-case header name\n            $heading = strtolower($heading);\n            //Collapse white space within the value, also convert WSP to space\n            $value = preg_replace('/[ \\t]+/', ' ', $value);\n            //RFC6376 is slightly unclear here - it says to delete space at the *end* of each value\n            //But then says to delete space before and after the colon.\n            //Net result is the same as trimming both ends of the value.\n            //By elimination, the same applies to the field name\n            $lines[$key] = trim($heading, \" \\t\") . ':' . trim($value, \" \\t\");\n        }\n\n        return implode(self::CRLF, $lines);\n    }\n\n    /**\n     * Generate a DKIM canonicalization body.\n     * Uses the 'simple' algorithm from RFC6376 section 3.4.3.\n     * Canonicalized bodies should *always* use CRLF, regardless of mailer setting.\n     *\n     * @see https://tools.ietf.org/html/rfc6376#section-3.4.3\n     *\n     * @param string $body Message Body\n     *\n     * @return string\n     */\n    public function DKIM_BodyC($body)\n    {\n        if (empty($body)) {\n            return self::CRLF;\n        }\n        //Normalize line endings to CRLF\n        $body = static::normalizeBreaks($body, self::CRLF);\n\n        //Reduce multiple trailing line breaks to a single one\n        return static::stripTrailingWSP($body) . self::CRLF;\n    }\n\n    /**\n     * Create the DKIM header and body in a new message header.\n     *\n     * @param string $headers_line Header lines\n     * @param string $subject      Subject\n     * @param string $body         Body\n     *\n     * @throws Exception\n     *\n     * @return string\n     */\n    public function DKIM_Add($headers_line, $subject, $body)\n    {\n        $DKIMsignatureType = 'rsa-sha256'; //Signature & hash algorithms\n        $DKIMcanonicalization = 'relaxed/simple'; //Canonicalization methods of header & body\n        $DKIMquery = 'dns/txt'; //Query method\n        $DKIMtime = time();\n        //Always sign these headers without being asked\n        //Recommended list from https://tools.ietf.org/html/rfc6376#section-5.4.1\n        $autoSignHeaders = [\n            'from',\n            'to',\n            'cc',\n            'date',\n            'subject',\n            'reply-to',\n            'message-id',\n            'content-type',\n            'mime-version',\n            'x-mailer',\n        ];\n        if (stripos($headers_line, 'Subject') === false) {\n            $headers_line .= 'Subject: ' . $subject . static::$LE;\n        }\n        $headerLines = explode(static::$LE, $headers_line);\n        $currentHeaderLabel = '';\n        $currentHeaderValue = '';\n        $parsedHeaders = [];\n        $headerLineIndex = 0;\n        $headerLineCount = count($headerLines);\n        foreach ($headerLines as $headerLine) {\n            $matches = [];\n            if (preg_match('/^([^ \\t]*?)(?::[ \\t]*)(.*)$/', $headerLine, $matches)) {\n                if ($currentHeaderLabel !== '') {\n                    //We were previously in another header; This is the start of a new header, so save the previous one\n                    $parsedHeaders[] = ['label' => $currentHeaderLabel, 'value' => $currentHeaderValue];\n                }\n                $currentHeaderLabel = $matches[1];\n                $currentHeaderValue = $matches[2];\n            } elseif (preg_match('/^[ \\t]+(.*)$/', $headerLine, $matches)) {\n                //This is a folded continuation of the current header, so unfold it\n                $currentHeaderValue .= ' ' . $matches[1];\n            }\n            ++$headerLineIndex;\n            if ($headerLineIndex >= $headerLineCount) {\n                //This was the last line, so finish off this header\n                $parsedHeaders[] = ['label' => $currentHeaderLabel, 'value' => $currentHeaderValue];\n            }\n        }\n        $copiedHeaders = [];\n        $headersToSignKeys = [];\n        $headersToSign = [];\n        foreach ($parsedHeaders as $header) {\n            //Is this header one that must be included in the DKIM signature?\n            if (in_array(strtolower($header['label']), $autoSignHeaders, true)) {\n                $headersToSignKeys[] = $header['label'];\n                $headersToSign[] = $header['label'] . ': ' . $header['value'];\n                if ($this->DKIM_copyHeaderFields) {\n                    $copiedHeaders[] = $header['label'] . ':' . //Note no space after this, as per RFC\n                        str_replace('|', '=7C', $this->DKIM_QP($header['value']));\n                }\n                continue;\n            }\n            //Is this an extra custom header we've been asked to sign?\n            if (in_array($header['label'], $this->DKIM_extraHeaders, true)) {\n                //Find its value in custom headers\n                foreach ($this->CustomHeader as $customHeader) {\n                    if ($customHeader[0] === $header['label']) {\n                        $headersToSignKeys[] = $header['label'];\n                        $headersToSign[] = $header['label'] . ': ' . $header['value'];\n                        if ($this->DKIM_copyHeaderFields) {\n                            $copiedHeaders[] = $header['label'] . ':' . //Note no space after this, as per RFC\n                                str_replace('|', '=7C', $this->DKIM_QP($header['value']));\n                        }\n                        //Skip straight to the next header\n                        continue 2;\n                    }\n                }\n            }\n        }\n        $copiedHeaderFields = '';\n        if ($this->DKIM_copyHeaderFields && count($copiedHeaders) > 0) {\n            //Assemble a DKIM 'z' tag\n            $copiedHeaderFields = ' z=';\n            $first = true;\n            foreach ($copiedHeaders as $copiedHeader) {\n                if (!$first) {\n                    $copiedHeaderFields .= static::$LE . ' |';\n                }\n                //Fold long values\n                if (strlen($copiedHeader) > self::STD_LINE_LENGTH - 3) {\n                    $copiedHeaderFields .= substr(\n                        chunk_split($copiedHeader, self::STD_LINE_LENGTH - 3, static::$LE . self::FWS),\n                        0,\n                        -strlen(static::$LE . self::FWS)\n                    );\n                } else {\n                    $copiedHeaderFields .= $copiedHeader;\n                }\n                $first = false;\n            }\n            $copiedHeaderFields .= ';' . static::$LE;\n        }\n        $headerKeys = ' h=' . implode(':', $headersToSignKeys) . ';' . static::$LE;\n        $headerValues = implode(static::$LE, $headersToSign);\n        $body = $this->DKIM_BodyC($body);\n        //Base64 of packed binary SHA-256 hash of body\n        $DKIMb64 = base64_encode(pack('H*', hash('sha256', $body)));\n        $ident = '';\n        if ('' !== $this->DKIM_identity) {\n            $ident = ' i=' . $this->DKIM_identity . ';' . static::$LE;\n        }\n        //The DKIM-Signature header is included in the signature *except for* the value of the `b` tag\n        //which is appended after calculating the signature\n        //https://tools.ietf.org/html/rfc6376#section-3.5\n        $dkimSignatureHeader = 'DKIM-Signature: v=1;' .\n            ' d=' . $this->DKIM_domain . ';' .\n            ' s=' . $this->DKIM_selector . ';' . static::$LE .\n            ' a=' . $DKIMsignatureType . ';' .\n            ' q=' . $DKIMquery . ';' .\n            ' t=' . $DKIMtime . ';' .\n            ' c=' . $DKIMcanonicalization . ';' . static::$LE .\n            $headerKeys .\n            $ident .\n            $copiedHeaderFields .\n            ' bh=' . $DKIMb64 . ';' . static::$LE .\n            ' b=';\n        //Canonicalize the set of headers\n        $canonicalizedHeaders = $this->DKIM_HeaderC(\n            $headerValues . static::$LE . $dkimSignatureHeader\n        );\n        $signature = $this->DKIM_Sign($canonicalizedHeaders);\n        $signature = trim(chunk_split($signature, self::STD_LINE_LENGTH - 3, static::$LE . self::FWS));\n\n        return static::normalizeBreaks($dkimSignatureHeader . $signature);\n    }\n\n    /**\n     * Detect if a string contains a line longer than the maximum line length\n     * allowed by RFC 2822 section 2.1.1.\n     *\n     * @param string $str\n     *\n     * @return bool\n     */\n    public static function hasLineLongerThanMax($str)\n    {\n        return (bool) preg_match('/^(.{' . (self::MAX_LINE_LENGTH + strlen(static::$LE)) . ',})/m', $str);\n    }\n\n    /**\n     * If a string contains any \"special\" characters, double-quote the name,\n     * and escape any double quotes with a backslash.\n     *\n     * @param string $str\n     *\n     * @return string\n     *\n     * @see RFC822 3.4.1\n     */\n    public static function quotedString($str)\n    {\n        if (preg_match('/[ ()<>@,;:\"\\/\\[\\]?=]/', $str)) {\n            //If the string contains any of these chars, it must be double-quoted\n            //and any double quotes must be escaped with a backslash\n            return '\"' . str_replace('\"', '\\\\\"', $str) . '\"';\n        }\n\n        //Return the string untouched, it doesn't need quoting\n        return $str;\n    }\n\n    /**\n     * Allows for public read access to 'to' property.\n     * Before the send() call, queued addresses (i.e. with IDN) are not yet included.\n     *\n     * @return array\n     */\n    public function getToAddresses()\n    {\n        return $this->to;\n    }\n\n    /**\n     * Allows for public read access to 'cc' property.\n     * Before the send() call, queued addresses (i.e. with IDN) are not yet included.\n     *\n     * @return array\n     */\n    public function getCcAddresses()\n    {\n        return $this->cc;\n    }\n\n    /**\n     * Allows for public read access to 'bcc' property.\n     * Before the send() call, queued addresses (i.e. with IDN) are not yet included.\n     *\n     * @return array\n     */\n    public function getBccAddresses()\n    {\n        return $this->bcc;\n    }\n\n    /**\n     * Allows for public read access to 'ReplyTo' property.\n     * Before the send() call, queued addresses (i.e. with IDN) are not yet included.\n     *\n     * @return array\n     */\n    public function getReplyToAddresses()\n    {\n        return $this->ReplyTo;\n    }\n\n    /**\n     * Allows for public read access to 'all_recipients' property.\n     * Before the send() call, queued addresses (i.e. with IDN) are not yet included.\n     *\n     * @return array\n     */\n    public function getAllRecipientAddresses()\n    {\n        return $this->all_recipients;\n    }\n\n    /**\n     * Perform a callback.\n     *\n     * @param bool   $isSent\n     * @param array  $to\n     * @param array  $cc\n     * @param array  $bcc\n     * @param string $subject\n     * @param string $body\n     * @param string $from\n     * @param array  $extra\n     */\n    protected function doCallback($isSent, $to, $cc, $bcc, $subject, $body, $from, $extra)\n    {\n        if (!empty($this->action_function) && is_callable($this->action_function)) {\n            call_user_func($this->action_function, $isSent, $to, $cc, $bcc, $subject, $body, $from, $extra);\n        }\n    }\n\n    /**\n     * Get the OAuth instance.\n     *\n     * @return OAuth\n     */\n    public function getOAuth()\n    {\n        return $this->oauth;\n    }\n\n    /**\n     * Set an OAuth instance.\n     */\n    public function setOAuth(OAuth $oauth)\n    {\n        $this->oauth = $oauth;\n    }\n}\n", "<?php\n\n/**\n * PHPMailer - PHP email transport unit tests.\n * PHP version 5.5.\n *\n * @author    Marcus Bointon <phpmailer@synchromedia.co.uk>\n * @author    Andy Prevost\n * @copyright 2012 - 2020 Marcus Bointon\n * @copyright 2004 - 2009 Andy Prevost\n * @license   http://www.gnu.org/copyleft/lesser.html GNU Lesser General Public License\n */\n\nnamespace PHPMailer\\Test;\n\nuse PHPMailer\\PHPMailer\\Exception;\nuse PHPMailer\\PHPMailer\\OAuth;\nuse PHPMailer\\PHPMailer\\PHPMailer;\nuse PHPMailer\\PHPMailer\\POP3;\nuse PHPMailer\\PHPMailer\\SMTP;\nuse Yoast\\PHPUnitPolyfills\\TestCases\\TestCase;\n\nrequire_once __DIR__ . '/validators.php';\n\n/**\n * PHPMailer - PHP email transport unit test class.\n */\nfinal class PHPMailerTest extends TestCase\n{\n    /**\n     * Holds the PHPMailer instance.\n     *\n     * @var PHPMailer\n     */\n    private $Mail;\n\n    /**\n     * Holds the SMTP mail host.\n     *\n     * @var string\n     */\n    private $Host = '';\n\n    /**\n     * Holds the change log.\n     *\n     * @var string[]\n     */\n    private $ChangeLog = [];\n\n    /**\n     * Holds the note log.\n     *\n     * @var string[]\n     */\n    private $NoteLog = [];\n\n    /**\n     * Default include path.\n     *\n     * @var string\n     */\n    private $INCLUDE_DIR = '..';\n\n    /**\n     * PIDs of any processes we need to kill.\n     *\n     * @var array\n     */\n    private $pids = [];\n\n    /**\n     * Run before each test is started.\n     */\n    protected function set_up()\n    {\n        $this->INCLUDE_DIR = dirname(__DIR__); //Default to the dir above the test dir, i.e. the project home dir\n        if (file_exists($this->INCLUDE_DIR . '/test/testbootstrap.php')) {\n            include $this->INCLUDE_DIR . '/test/testbootstrap.php'; //Overrides go in here\n        }\n        $this->Mail = new PHPMailer();\n        $this->Mail->SMTPDebug = SMTP::DEBUG_CONNECTION; //Full debug output\n        $this->Mail->Debugoutput = ['PHPMailer\\Test\\DebugLogTestListener', 'debugLog'];\n        $this->Mail->Priority = 3;\n        $this->Mail->Encoding = '8bit';\n        $this->Mail->CharSet = PHPMailer::CHARSET_ISO88591;\n        if (array_key_exists('mail_from', $_REQUEST)) {\n            $this->Mail->From = $_REQUEST['mail_from'];\n        } else {\n            $this->Mail->From = 'unit_test@phpmailer.example.com';\n        }\n        $this->Mail->FromName = 'Unit Tester';\n        $this->Mail->Sender = '';\n        $this->Mail->Subject = 'Unit Test';\n        $this->Mail->Body = '';\n        $this->Mail->AltBody = '';\n        $this->Mail->WordWrap = 0;\n        if (array_key_exists('mail_host', $_REQUEST)) {\n            $this->Mail->Host = $_REQUEST['mail_host'];\n        } else {\n            $this->Mail->Host = 'mail.example.com';\n        }\n        if (array_key_exists('mail_port', $_REQUEST)) {\n            $this->Mail->Port = $_REQUEST['mail_port'];\n        } else {\n            $this->Mail->Port = 25;\n        }\n        $this->Mail->Helo = 'localhost.localdomain';\n        $this->Mail->SMTPAuth = false;\n        $this->Mail->Username = '';\n        $this->Mail->Password = '';\n        if (array_key_exists('mail_useauth', $_REQUEST)) {\n            $this->Mail->SMTPAuth = $_REQUEST['mail_useauth'];\n        }\n        if (array_key_exists('mail_username', $_REQUEST)) {\n            $this->Mail->Username = $_REQUEST['mail_username'];\n        }\n        if (array_key_exists('mail_userpass', $_REQUEST)) {\n            $this->Mail->Password = $_REQUEST['mail_userpass'];\n        }\n        $this->Mail->addReplyTo('no_reply@phpmailer.example.com', 'Reply Guy');\n        $this->Mail->Sender = 'unit_test@phpmailer.example.com';\n        if ($this->Mail->Host != '') {\n            $this->Mail->isSMTP();\n        } else {\n            $this->Mail->isMail();\n        }\n        if (array_key_exists('mail_to', $_REQUEST)) {\n            $this->setAddress($_REQUEST['mail_to'], 'Test User', 'to');\n        }\n        if (array_key_exists('mail_cc', $_REQUEST) && $_REQUEST['mail_cc'] !== '') {\n            $this->setAddress($_REQUEST['mail_cc'], 'Carbon User', 'cc');\n        }\n    }\n\n    /**\n     * Run after each test is completed.\n     */\n    protected function tear_down()\n    {\n        //Clean global variables\n        $this->Mail = null;\n        $this->ChangeLog = [];\n        $this->NoteLog = [];\n\n        foreach ($this->pids as $pid) {\n            $p = escapeshellarg($pid);\n            shell_exec(\"ps $p && kill -TERM $p\");\n        }\n    }\n\n    /**\n     * Build the body of the message in the appropriate format.\n     */\n    private function buildBody()\n    {\n        $this->checkChanges();\n\n        //Determine line endings for message\n        if ('text/html' === $this->Mail->ContentType || $this->Mail->AltBody !== '') {\n            $eol = \"<br>\\r\\n\";\n            $bullet_start = '<li>';\n            $bullet_end = \"</li>\\r\\n\";\n            $list_start = \"<ul>\\r\\n\";\n            $list_end = \"</ul>\\r\\n\";\n        } else {\n            $eol = \"\\r\\n\";\n            $bullet_start = ' - ';\n            $bullet_end = \"\\r\\n\";\n            $list_start = '';\n            $list_end = '';\n        }\n\n        $ReportBody = '';\n\n        $ReportBody .= '---------------------' . $eol;\n        $ReportBody .= 'Unit Test Information' . $eol;\n        $ReportBody .= '---------------------' . $eol;\n        $ReportBody .= 'phpmailer version: ' . PHPMailer::VERSION . $eol;\n        $ReportBody .= 'Content Type: ' . $this->Mail->ContentType . $eol;\n        $ReportBody .= 'CharSet: ' . $this->Mail->CharSet . $eol;\n\n        if ($this->Mail->Host !== '') {\n            $ReportBody .= 'Host: ' . $this->Mail->Host . $eol;\n        }\n\n        //If attachments then create an attachment list\n        $attachments = $this->Mail->getAttachments();\n        if (count($attachments) > 0) {\n            $ReportBody .= 'Attachments:' . $eol;\n            $ReportBody .= $list_start;\n            foreach ($attachments as $attachment) {\n                $ReportBody .= $bullet_start . 'Name: ' . $attachment[1] . ', ';\n                $ReportBody .= 'Encoding: ' . $attachment[3] . ', ';\n                $ReportBody .= 'Type: ' . $attachment[4] . $bullet_end;\n            }\n            $ReportBody .= $list_end . $eol;\n        }\n\n        //If there are changes then list them\n        if (count($this->ChangeLog) > 0) {\n            $ReportBody .= 'Changes' . $eol;\n            $ReportBody .= '-------' . $eol;\n\n            $ReportBody .= $list_start;\n            foreach ($this->ChangeLog as $iValue) {\n                $ReportBody .= $bullet_start . $iValue[0] . ' was changed to [' .\n                    $iValue[1] . ']' . $bullet_end;\n            }\n            $ReportBody .= $list_end . $eol . $eol;\n        }\n\n        //If there are notes then list them\n        if (count($this->NoteLog) > 0) {\n            $ReportBody .= 'Notes' . $eol;\n            $ReportBody .= '-----' . $eol;\n\n            $ReportBody .= $list_start;\n            foreach ($this->NoteLog as $iValue) {\n                $ReportBody .= $bullet_start . $iValue . $bullet_end;\n            }\n            $ReportBody .= $list_end;\n        }\n\n        //Re-attach the original body\n        $this->Mail->Body .= $eol . $ReportBody;\n    }\n\n    /**\n     * Check which default settings have been changed for the report.\n     */\n    private function checkChanges()\n    {\n        if (3 != $this->Mail->Priority) {\n            $this->addChange('Priority', $this->Mail->Priority);\n        }\n        if (PHPMailer::ENCODING_8BIT !== $this->Mail->Encoding) {\n            $this->addChange('Encoding', $this->Mail->Encoding);\n        }\n        if (PHPMailer::CHARSET_ISO88591 !== $this->Mail->CharSet) {\n            $this->addChange('CharSet', $this->Mail->CharSet);\n        }\n        if ('' != $this->Mail->Sender) {\n            $this->addChange('Sender', $this->Mail->Sender);\n        }\n        if (0 != $this->Mail->WordWrap) {\n            $this->addChange('WordWrap', $this->Mail->WordWrap);\n        }\n        if ('mail' !== $this->Mail->Mailer) {\n            $this->addChange('Mailer', $this->Mail->Mailer);\n        }\n        if (25 != $this->Mail->Port) {\n            $this->addChange('Port', $this->Mail->Port);\n        }\n        if ('localhost.localdomain' !== $this->Mail->Helo) {\n            $this->addChange('Helo', $this->Mail->Helo);\n        }\n        if ($this->Mail->SMTPAuth) {\n            $this->addChange('SMTPAuth', 'true');\n        }\n    }\n\n    /**\n     * Add a changelog entry.\n     *\n     * @param string $sName\n     * @param string $sNewValue\n     */\n    private function addChange($sName, $sNewValue)\n    {\n        $this->ChangeLog[] = [$sName, $sNewValue];\n    }\n\n    /**\n     * Adds a simple note to the message.\n     *\n     * @param string $sValue\n     */\n    private function addNote($sValue)\n    {\n        $this->NoteLog[] = $sValue;\n    }\n\n    /**\n     * Adds all of the addresses.\n     *\n     * @param string $sAddress\n     * @param string $sName\n     * @param string $sType\n     *\n     * @return bool\n     */\n    private function setAddress($sAddress, $sName = '', $sType = 'to')\n    {\n        switch ($sType) {\n            case 'to':\n                return $this->Mail->addAddress($sAddress, $sName);\n            case 'cc':\n                return $this->Mail->addCC($sAddress, $sName);\n            case 'bcc':\n                return $this->Mail->addBCC($sAddress, $sName);\n        }\n\n        return false;\n    }\n\n    /**\n     * Check that we have loaded default test params.\n     * Pretty much everything will fail due to unset recipient if this is not done.\n     */\n    public function testBootstrap()\n    {\n        self::assertFileExists(\n            $this->INCLUDE_DIR . '/test/testbootstrap.php',\n            'Test config params missing - copy testbootstrap.php to testbootstrap-dist.php and change as appropriate'\n        );\n    }\n\n    /**\n     * Test CRAM-MD5 authentication.\n     * Needs a connection to a server that supports this auth mechanism, so commented out by default.\n     */\n    public function testAuthCRAMMD5()\n    {\n        $this->markTestIncomplete(\n            'Test needs a connection to a server supporting the CRAMMD5 auth mechanism.'\n        );\n\n        $this->Mail->Host = 'hostname';\n        $this->Mail->Port = 587;\n        $this->Mail->SMTPAuth = true;\n        $this->Mail->SMTPSecure = PHPMailer::ENCRYPTION_STARTTLS;\n        $this->Mail->AuthType = 'CRAM-MD5';\n        $this->Mail->Username = 'username';\n        $this->Mail->Password = 'password';\n        $this->Mail->Body = 'Test body';\n        $this->Mail->Subject .= ': Auth CRAM-MD5';\n        $this->Mail->From = 'from@example.com';\n        $this->Mail->Sender = 'from@example.com';\n        $this->Mail->clearAllRecipients();\n        $this->Mail->addAddress('user@example.com');\n        //self::assertTrue($this->mail->send(), $this->mail->ErrorInfo);\n    }\n\n    /**\n     * Test email address validation.\n     * Test addresses obtained from http://isemail.info\n     * Some failing cases commented out that are apparently up for debate!\n     */\n    public function testValidate()\n    {\n        $validaddresses = [\n            'first@example.org',\n            'first.last@example.org',\n            '1234567890123456789012345678901234567890123456789012345678901234@example.org',\n            '\"first\\\"last\"@example.org',\n            '\"first@last\"@example.org',\n            '\"first\\last\"@example.org',\n            'first.last@[12.34.56.78]',\n            'first.last@x23456789012345678901234567890123456789012345678901234567890123.example.org',\n            'first.last@123.example.org',\n            '\"first\\last\"@example.org',\n            '\"Abc\\@def\"@example.org',\n            '\"Fred\\ Bloggs\"@example.org',\n            '\"Joe.\\Blow\"@example.org',\n            '\"Abc@def\"@example.org',\n            'user+mailbox@example.org',\n            'customer/department=shipping@example.org',\n            '$A12345@example.org',\n            '!def!xyz%abc@example.org',\n            '_somename@example.org',\n            'dclo@us.example.com',\n            'peter.piper@example.org',\n            'test@example.org',\n            'TEST@example.org',\n            '1234567890@example.org',\n            'test+test@example.org',\n            'test-test@example.org',\n            't*est@example.org',\n            '+1~1+@example.org',\n            '{_test_}@example.org',\n            'test.test@example.org',\n            '\"test.test\"@example.org',\n            'test.\"test\"@example.org',\n            '\"test@test\"@example.org',\n            'test@123.123.123.x123',\n            'test@[123.123.123.123]',\n            'test@example.example.org',\n            'test@example.example.example.org',\n            '\"test\\test\"@example.org',\n            '\"test\\blah\"@example.org',\n            '\"test\\blah\"@example.org',\n            '\"test\\\"blah\"@example.org',\n            'customer/department@example.org',\n            '_Yosemite.Sam@example.org',\n            '~@example.org',\n            '\"Austin@Powers\"@example.org',\n            'Ima.Fool@example.org',\n            '\"Ima.Fool\"@example.org',\n            '\"first\".\"last\"@example.org',\n            '\"first\".middle.\"last\"@example.org',\n            '\"first\".last@example.org',\n            'first.\"last\"@example.org',\n            '\"first\".\"middle\".\"last\"@example.org',\n            '\"first.middle\".\"last\"@example.org',\n            '\"first.middle.last\"@example.org',\n            '\"first..last\"@example.org',\n            '\"first\\\"last\"@example.org',\n            'first.\"mid\\dle\".\"last\"@example.org',\n            'name.lastname@example.com',\n            'a@example.com',\n            'aaa@[123.123.123.123]',\n            'a-b@example.com',\n            '+@b.c',\n            '+@b.com',\n            'a@b.co-foo.uk',\n            'valid@about.museum',\n            'shaitan@my-domain.thisisminekthx',\n            '\"Joe\\Blow\"@example.org',\n            'user%uucp!path@example.edu',\n            'cdburgess+!#$%&\\'*-/=?+_{}|~test@example.com',\n            'test@test.com',\n            'test@xn--example.com',\n            'test@example.com',\n        ];\n        //These are invalid according to PHP's filter_var\n        //which doesn't allow dotless domains, numeric TLDs or unbracketed IPv4 literals\n        $invalidphp = [\n            'a@b',\n            'a@bar',\n            'first.last@com',\n            'test@123.123.123.123',\n            'foobar@192.168.0.1',\n            'first.last@example.123',\n        ];\n        //Valid RFC 5322 addresses using quoting and comments\n        //Note that these are *not* all valid for RFC5321\n        $validqandc = [\n            'HM2Kinsists@(that comments are allowed)this.is.ok',\n            '\"Doug \\\"Ace\\\" L.\"@example.org',\n            '\"[[ test ]]\"@example.org',\n            '\"Ima Fool\"@example.org',\n            '\"test blah\"@example.org',\n            '(foo)cal(bar)@(baz)example.com(quux)',\n            'cal@example(woo).(yay)com',\n            'cal(woo(yay)hoopla)@example.com',\n            'cal(foo\\@bar)@example.com',\n            'cal(foo\\)bar)@example.com',\n            'first().last@example.org',\n            'pete(his account)@silly.test(his host)',\n            'c@(Chris\\'s host.)public.example',\n            'jdoe@machine(comment). example',\n            '1234 @ local(blah) .machine .example',\n            'first(abc.def).last@example.org',\n            'first(a\"bc.def).last@example.org',\n            'first.(\")middle.last(\")@example.org',\n            'first(abc\\(def)@example.org',\n            'first.last@x(1234567890123456789012345678901234567890123456789012345678901234567890).com',\n            'a(a(b(c)d(e(f))g)h(i)j)@example.org',\n            '\"hello my name is\"@example.com',\n            '\"Test \\\"Fail\\\" Ing\"@example.org',\n            'first.last @example.org',\n        ];\n        //Valid explicit IPv6 numeric addresses\n        $validipv6 = [\n            'first.last@[IPv6:::a2:a3:a4:b1:b2:b3:b4]',\n            'first.last@[IPv6:a1:a2:a3:a4:b1:b2:b3::]',\n            'first.last@[IPv6:::]',\n            'first.last@[IPv6:::b4]',\n            'first.last@[IPv6:::b3:b4]',\n            'first.last@[IPv6:a1::b4]',\n            'first.last@[IPv6:a1::]',\n            'first.last@[IPv6:a1:a2::]',\n            'first.last@[IPv6:0123:4567:89ab:cdef::]',\n            'first.last@[IPv6:0123:4567:89ab:CDEF::]',\n            'first.last@[IPv6:::a3:a4:b1:ffff:11.22.33.44]',\n            'first.last@[IPv6:::a2:a3:a4:b1:ffff:11.22.33.44]',\n            'first.last@[IPv6:a1:a2:a3:a4::11.22.33.44]',\n            'first.last@[IPv6:a1:a2:a3:a4:b1::11.22.33.44]',\n            'first.last@[IPv6:a1::11.22.33.44]',\n            'first.last@[IPv6:a1:a2::11.22.33.44]',\n            'first.last@[IPv6:0123:4567:89ab:cdef::11.22.33.44]',\n            'first.last@[IPv6:0123:4567:89ab:CDEF::11.22.33.44]',\n            'first.last@[IPv6:a1::b2:11.22.33.44]',\n            'first.last@[IPv6:::12.34.56.78]',\n            'first.last@[IPv6:1111:2222:3333::4444:12.34.56.78]',\n            'first.last@[IPv6:1111:2222:3333:4444:5555:6666:12.34.56.78]',\n            'first.last@[IPv6:::1111:2222:3333:4444:5555:6666]',\n            'first.last@[IPv6:1111:2222:3333::4444:5555:6666]',\n            'first.last@[IPv6:1111:2222:3333:4444:5555:6666::]',\n            'first.last@[IPv6:1111:2222:3333:4444:5555:6666:7777:8888]',\n            'first.last@[IPv6:1111:2222:3333::4444:5555:12.34.56.78]',\n            'first.last@[IPv6:1111:2222:3333::4444:5555:6666:7777]',\n        ];\n        $invalidaddresses = [\n            'first.last@sub.do,com',\n            'first\\@last@iana.org',\n            '123456789012345678901234567890123456789012345678901234567890' .\n            '@12345678901234567890123456789012345678901234 [...]',\n            'first.last',\n            '12345678901234567890123456789012345678901234567890123456789012345@iana.org',\n            '.first.last@iana.org',\n            'first.last.@iana.org',\n            'first..last@iana.org',\n            '\"first\"last\"@iana.org',\n            '\"\"\"@iana.org',\n            '\"\\\"@iana.org',\n            //'\"\"@iana.org',\n            'first\\@last@iana.org',\n            'first.last@',\n            'x@x23456789.x23456789.x23456789.x23456789.x23456789.x23456789.x23456789.' .\n            'x23456789.x23456789.x23456789.x23 [...]',\n            'first.last@[.12.34.56.78]',\n            'first.last@[12.34.56.789]',\n            'first.last@[::12.34.56.78]',\n            'first.last@[IPv5:::12.34.56.78]',\n            'first.last@[IPv6:1111:2222:3333:4444:5555:12.34.56.78]',\n            'first.last@[IPv6:1111:2222:3333:4444:5555:6666:7777:12.34.56.78]',\n            'first.last@[IPv6:1111:2222:3333:4444:5555:6666:7777]',\n            'first.last@[IPv6:1111:2222:3333:4444:5555:6666:7777:8888:9999]',\n            'first.last@[IPv6:1111:2222::3333::4444:5555:6666]',\n            'first.last@[IPv6:1111:2222:333x::4444:5555]',\n            'first.last@[IPv6:1111:2222:33333::4444:5555]',\n            'first.last@-xample.com',\n            'first.last@exampl-.com',\n            'first.last@x234567890123456789012345678901234567890123456789012345678901234.iana.org',\n            'abc\\@def@iana.org',\n            'abc\\@iana.org',\n            'Doug\\ \\\"Ace\\\"\\ Lovell@iana.org',\n            'abc@def@iana.org',\n            'abc\\@def@iana.org',\n            'abc\\@iana.org',\n            '@iana.org',\n            'doug@',\n            '\"qu@iana.org',\n            'ote\"@iana.org',\n            '.dot@iana.org',\n            'dot.@iana.org',\n            'two..dot@iana.org',\n            '\"Doug \"Ace\" L.\"@iana.org',\n            'Doug\\ \\\"Ace\\\"\\ L\\.@iana.org',\n            'hello world@iana.org',\n            //'helloworld@iana .org',\n            'gatsby@f.sc.ot.t.f.i.tzg.era.l.d.',\n            'test.iana.org',\n            'test.@iana.org',\n            'test..test@iana.org',\n            '.test@iana.org',\n            'test@test@iana.org',\n            'test@@iana.org',\n            '-- test --@iana.org',\n            '[test]@iana.org',\n            '\"test\"test\"@iana.org',\n            '()[]\\;:,><@iana.org',\n            'test@.',\n            'test@example.',\n            'test@.org',\n            'test@12345678901234567890123456789012345678901234567890123456789012345678901234567890' .\n            '12345678901234567890 [...]',\n            'test@[123.123.123.123',\n            'test@123.123.123.123]',\n            'NotAnEmail',\n            '@NotAnEmail',\n            '\"test\"blah\"@iana.org',\n            '.wooly@iana.org',\n            'wo..oly@iana.org',\n            'pootietang.@iana.org',\n            '.@iana.org',\n            'Ima Fool@iana.org',\n            'phil.h\\@\\@ck@haacked.com',\n            'foo@[\\1.2.3.4]',\n            //'first.\"\".last@iana.org',\n            'first\\last@iana.org',\n            'Abc\\@def@iana.org',\n            'Fred\\ Bloggs@iana.org',\n            'Joe.\\Blow@iana.org',\n            'first.last@[IPv6:1111:2222:3333:4444:5555:6666:12.34.567.89]',\n            '{^c\\@**Dog^}@cartoon.com',\n            //'\"foo\"(yay)@(hoopla)[1.2.3.4]',\n            'cal(foo(bar)@iamcal.com',\n            'cal(foo)bar)@iamcal.com',\n            'cal(foo\\)@iamcal.com',\n            'first(12345678901234567890123456789012345678901234567890)last@(1234567890123456789' .\n            '01234567890123456789012 [...]',\n            'first(middle)last@iana.org',\n            'first(abc(\"def\".ghi).mno)middle(abc(\"def\".ghi).mno).last@(abc(\"def\".ghi).mno)example' .\n            '(abc(\"def\".ghi).mno). [...]',\n            'a(a(b(c)d(e(f))g)(h(i)j)@iana.org',\n            '.@',\n            '@bar.com',\n            '@@bar.com',\n            'aaa.com',\n            'aaa@.com',\n            'aaa@.123',\n            'aaa@[123.123.123.123]a',\n            'aaa@[123.123.123.333]',\n            'a@bar.com.',\n            'a@-b.com',\n            'a@b-.com',\n            '-@..com',\n            '-@a..com',\n            'invalid@about.museum-',\n            'test@...........com',\n            '\"Unicode NULL' . chr(0) . '\"@char.com',\n            'Unicode NULL' . chr(0) . '@char.com',\n            'first.last@[IPv6::]',\n            'first.last@[IPv6::::]',\n            'first.last@[IPv6::b4]',\n            'first.last@[IPv6::::b4]',\n            'first.last@[IPv6::b3:b4]',\n            'first.last@[IPv6::::b3:b4]',\n            'first.last@[IPv6:a1:::b4]',\n            'first.last@[IPv6:a1:]',\n            'first.last@[IPv6:a1:::]',\n            'first.last@[IPv6:a1:a2:]',\n            'first.last@[IPv6:a1:a2:::]',\n            'first.last@[IPv6::11.22.33.44]',\n            'first.last@[IPv6::::11.22.33.44]',\n            'first.last@[IPv6:a1:11.22.33.44]',\n            'first.last@[IPv6:a1:::11.22.33.44]',\n            'first.last@[IPv6:a1:a2:::11.22.33.44]',\n            'first.last@[IPv6:0123:4567:89ab:cdef::11.22.33.xx]',\n            'first.last@[IPv6:0123:4567:89ab:CDEFF::11.22.33.44]',\n            'first.last@[IPv6:a1::a4:b1::b4:11.22.33.44]',\n            'first.last@[IPv6:a1::11.22.33]',\n            'first.last@[IPv6:a1::11.22.33.44.55]',\n            'first.last@[IPv6:a1::b211.22.33.44]',\n            'first.last@[IPv6:a1::b2::11.22.33.44]',\n            'first.last@[IPv6:a1::b3:]',\n            'first.last@[IPv6::a2::b4]',\n            'first.last@[IPv6:a1:a2:a3:a4:b1:b2:b3:]',\n            'first.last@[IPv6::a2:a3:a4:b1:b2:b3:b4]',\n            'first.last@[IPv6:a1:a2:a3:a4::b1:b2:b3:b4]',\n            //This is a valid RFC5322 address, but we don't want to allow it for obvious reasons!\n            \"(\\r\\n RCPT TO:user@example.com\\r\\n DATA \\\\\\nSubject: spam10\\\\\\n\\r\\n Hello,\" .\n            \"\\r\\n this is a spam mail.\\\\\\n.\\r\\n QUIT\\r\\n ) a@example.net\",\n        ];\n        //IDNs in Unicode and ASCII forms.\n        $unicodeaddresses = [\n            'first.last@b\u00fccher.ch',\n            'first.last@\u043a\u0442\u043e.\u0440\u0444',\n            'first.last@phpl\u00edst.com',\n        ];\n        $asciiaddresses = [\n            'first.last@xn--bcher-kva.ch',\n            'first.last@xn--j1ail.xn--p1ai',\n            'first.last@xn--phplst-6va.com',\n        ];\n        $goodfails = [];\n        foreach (array_merge($validaddresses, $asciiaddresses) as $address) {\n            if (!PHPMailer::validateAddress($address)) {\n                $goodfails[] = $address;\n            }\n        }\n        $badpasses = [];\n        foreach (array_merge($invalidaddresses, $unicodeaddresses) as $address) {\n            if (PHPMailer::validateAddress($address)) {\n                $badpasses[] = $address;\n            }\n        }\n        $err = '';\n        if (count($goodfails) > 0) {\n            $err .= \"Good addresses that failed validation:\\n\";\n            $err .= implode(\"\\n\", $goodfails);\n        }\n        if (count($badpasses) > 0) {\n            if (!empty($err)) {\n                $err .= \"\\n\\n\";\n            }\n            $err .= \"Bad addresses that passed validation:\\n\";\n            $err .= implode(\"\\n\", $badpasses);\n        }\n        self::assertEmpty($err, $err);\n\n        //For coverage\n        self::assertTrue(PHPMailer::validateAddress('test@example.com', 'auto'));\n        self::assertFalse(PHPMailer::validateAddress('test@example.com.', 'auto'));\n        self::assertTrue(PHPMailer::validateAddress('test@example.com', 'pcre'));\n        self::assertFalse(PHPMailer::validateAddress('test@example.com.', 'pcre'));\n        self::assertTrue(PHPMailer::validateAddress('test@example.com', 'pcre8'));\n        self::assertFalse(PHPMailer::validateAddress('test@example.com.', 'pcre8'));\n        self::assertTrue(PHPMailer::validateAddress('test@example.com', 'html5'));\n        self::assertFalse(PHPMailer::validateAddress('test@example.com.', 'html5'));\n        self::assertTrue(PHPMailer::validateAddress('test@example.com', 'php'));\n        self::assertFalse(PHPMailer::validateAddress('test@example.com.', 'php'));\n        self::assertTrue(PHPMailer::validateAddress('test@example.com', 'noregex'));\n        self::assertFalse(PHPMailer::validateAddress('bad', 'noregex'));\n    }\n\n    /**\n     * Test injecting a custom validator.\n     */\n    public function testCustomValidator()\n    {\n        //Inject a one-off custom validator\n        self::assertTrue(\n            PHPMailer::validateAddress(\n                'user@example.com',\n                function ($address) {\n                    return strpos($address, '@') !== false;\n                }\n            ),\n            'Custom validator false negative'\n        );\n        self::assertFalse(\n            PHPMailer::validateAddress(\n                'userexample.com',\n                function ($address) {\n                    return strpos($address, '@') !== false;\n                }\n            ),\n            'Custom validator false positive'\n        );\n        //Set the default validator to an injected function\n        PHPMailer::$validator = function ($address) {\n            return 'user@example.com' === $address;\n        };\n        self::assertTrue(\n            $this->Mail->addAddress('user@example.com'),\n            'Custom default validator false negative'\n        );\n        self::assertFalse(\n        //Need to pick a failing value which would pass all other validators\n        //to be sure we're using our custom one\n            $this->Mail->addAddress('bananas@example.com'),\n            'Custom default validator false positive'\n        );\n        //Set validator back to default\n        PHPMailer::$validator = 'php';\n        self::assertFalse(\n        //This is a valid address that FILTER_VALIDATE_EMAIL thinks is invalid\n            $this->Mail->addAddress('first.last@example.123'),\n            'PHP validator not behaving as expected'\n        );\n\n        //Test denying function name callables as validators\n        //See SECURITY.md and CVE-2021-3603\n        //If a `php` function defined in validators.php successfully overrides this built-in validator name,\n        //this would return false \u2013 and we don't want to allow that\n        self::assertTrue(PHPMailer::validateAddress('test@example.com', 'php'));\n        //Check that a non-existent validator name falls back to a built-in validator\n        //and does not call a global function with that name\n        self::assertTrue(PHPMailer::validateAddress('test@example.com', 'phpx'));\n    }\n\n    /**\n     * Word-wrap an ASCII message.\n     */\n    public function testWordWrap()\n    {\n        $this->Mail->WordWrap = 40;\n        $my_body = str_repeat(\n            'Here is the main body of this message.  It should ' .\n            'be quite a few lines.  It should be wrapped at ' .\n            '40 characters.  Make sure that it is. ',\n            10\n        );\n        $nBodyLen = strlen($my_body);\n        $my_body .= \"\\n\\nThis is the above body length: \" . $nBodyLen;\n\n        $this->Mail->Body = $my_body;\n        $this->Mail->Subject .= ': Wordwrap';\n\n        $this->buildBody();\n        self::assertTrue($this->Mail->send(), $this->Mail->ErrorInfo);\n    }\n\n    /**\n     * Word-wrap a multibyte message.\n     */\n    public function testWordWrapMultibyte()\n    {\n        $this->Mail->WordWrap = 40;\n        $my_body = str_repeat(\n            '\u98db\u5152\u6a02 \u5718\u5149\u832b \u98db\u5152\u6a02 \u5718\u5149\u832b \u98db\u5152\u6a02 \u5718\u5149\u832b \u98db\u5152\u6a02 \u5718\u5149\u832b ' .\n            '\u98db\u98db\u5152\u6a02 \u5718\u5149\u832b\u5152\u6a02 \u5718\u5149\u832b\u98db\u5152\u6a02 \u5718\u5149\u98db\u5152\u6a02 \u5718\u5149\u832b\u98db\u5152\u6a02 \u5718\u5149\u832b\u5152\u6a02 \u5718\u5149\u832b ' .\n            '\u98db\u5152\u6a02 \u5718\u5149\u832b\u98db\u5152\u6a02 \u5718\u98db\u5152\u6a02 \u5718\u5149\u832b\u5149\u832b\u98db\u5152\u6a02 \u5718\u5149\u832b. ',\n            10\n        );\n        $nBodyLen = strlen($my_body);\n        $my_body .= \"\\n\\nThis is the above body length: \" . $nBodyLen;\n\n        $this->Mail->Body = $my_body;\n        $this->Mail->Subject .= ': Wordwrap multibyte';\n\n        $this->buildBody();\n        self::assertTrue($this->Mail->send(), $this->Mail->ErrorInfo);\n    }\n\n    /**\n     * Test low priority.\n     */\n    public function testLowPriority()\n    {\n        $this->Mail->Priority = 5;\n        $this->Mail->Body = 'Here is the main body.  There should be ' .\n            'a reply to address in this message.';\n        $this->Mail->Subject .= ': Low Priority';\n        $this->Mail->addReplyTo('nobody@nobody.com', 'Nobody (Unit Test)');\n\n        $this->buildBody();\n        self::assertTrue($this->Mail->send(), $this->Mail->ErrorInfo);\n    }\n\n    /**\n     * Simple plain file attachment test.\n     */\n    public function testMultiplePlainFileAttachment()\n    {\n        $this->Mail->Body = 'Here is the text body';\n        $this->Mail->Subject .= ': Plain + Multiple FileAttachments';\n\n        if (!$this->Mail->addAttachment(realpath($this->INCLUDE_DIR . '/examples/images/phpmailer.png'))) {\n            self::assertTrue(false, $this->Mail->ErrorInfo);\n\n            return;\n        }\n\n        if (!$this->Mail->addAttachment(__FILE__, 'test.txt')) {\n            self::assertTrue(false, $this->Mail->ErrorInfo);\n\n            return;\n        }\n\n        $this->buildBody();\n        self::assertTrue($this->Mail->send(), $this->Mail->ErrorInfo);\n    }\n\n    /**\n     * Rejection of non-local file attachments test.\n     */\n    public function testRejectNonLocalFileAttachment()\n    {\n        self::assertFalse(\n            $this->Mail->addAttachment('https://github.com/PHPMailer/PHPMailer/raw/master/README.md'),\n            'addAttachment should reject remote URLs'\n        );\n\n        self::assertFalse(\n            $this->Mail->addAttachment('phar://phar.php'),\n            'addAttachment should reject phar resources'\n        );\n    }\n\n    /**\n     * Simple plain string attachment test.\n     */\n    public function testPlainStringAttachment()\n    {\n        $this->Mail->Body = 'Here is the text body';\n        $this->Mail->Subject .= ': Plain + StringAttachment';\n\n        $sAttachment = 'These characters are the content of the ' .\n            \"string attachment.\\nThis might be taken from a \" .\n            'database or some other such thing. ';\n\n        $this->Mail->addStringAttachment($sAttachment, 'string_attach.txt');\n\n        $this->buildBody();\n        self::assertTrue($this->Mail->send(), $this->Mail->ErrorInfo);\n    }\n\n    /**\n     * Plain quoted-printable message.\n     */\n    public function testQuotedPrintable()\n    {\n        $this->Mail->Body = 'Here is the main body';\n        $this->Mail->Subject .= ': Plain + Quoted-printable';\n        $this->Mail->Encoding = 'quoted-printable';\n\n        $this->buildBody();\n        self::assertTrue($this->Mail->send(), $this->Mail->ErrorInfo);\n\n        //Check that a quoted printable encode and decode results in the same as went in\n        $t = file_get_contents(__FILE__); //Use this file as test content\n        //Force line breaks to UNIX-style\n        $t = str_replace([\"\\r\\n\", \"\\r\"], \"\\n\", $t);\n        self::assertEquals(\n            $t,\n            quoted_printable_decode($this->Mail->encodeQP($t)),\n            'Quoted-Printable encoding round-trip failed'\n        );\n        //Force line breaks to Windows-style\n        $t = str_replace(\"\\n\", \"\\r\\n\", $t);\n        self::assertEquals(\n            $t,\n            quoted_printable_decode($this->Mail->encodeQP($t)),\n            'Quoted-Printable encoding round-trip failed (Windows line breaks)'\n        );\n    }\n\n    /**\n     * Test header encoding & folding.\n     */\n    public function testHeaderEncoding()\n    {\n        $this->Mail->CharSet = PHPMailer::CHARSET_UTF8;\n        $letter = html_entity_decode('&eacute;', ENT_COMPAT, PHPMailer::CHARSET_UTF8);\n        //This should select B-encoding automatically and should fold\n        $bencode = str_repeat($letter, PHPMailer::STD_LINE_LENGTH + 1);\n        //This should select Q-encoding automatically and should fold\n        $qencode = str_repeat('e', PHPMailer::STD_LINE_LENGTH) . $letter;\n        //This should select B-encoding automatically and should not fold\n        $bencodenofold = str_repeat($letter, 10);\n        //This should select Q-encoding automatically and should not fold\n        $qencodenofold = str_repeat('e', 9) . $letter;\n        //This should Q-encode as ASCII and fold (previously, this did not encode)\n        $longheader = str_repeat('e', PHPMailer::STD_LINE_LENGTH + 10);\n        //This should Q-encode as UTF-8 and fold\n        $longutf8 = str_repeat($letter, PHPMailer::STD_LINE_LENGTH + 10);\n        //This should not change\n        $noencode = 'eeeeeeeeee';\n        $this->Mail->isMail();\n        //Expected results\n\n        $bencoderes = '=?utf-8?B?w6nDqcOpw6nDqcOpw6nDqcOpw6nDqcOpw6nDqcOpw6nDqcOpw6nDqcOpw6k=?=' .\n            PHPMailer::getLE() .\n            ' =?utf-8?B?w6nDqcOpw6nDqcOpw6nDqcOpw6nDqcOpw6nDqcOpw6nDqcOpw6nDqcOpw6k=?=' .\n            PHPMailer::getLE() .\n            ' =?utf-8?B?w6nDqcOpw6nDqcOpw6nDqcOpw6nDqcOpw6nDqcOpw6nDqcOpw6nDqcOpw6k=?=' .\n            PHPMailer::getLE() .\n            ' =?utf-8?B?w6nDqcOpw6nDqcOpw6nDqcOpw6nDqQ==?=';\n        $qencoderes = '=?utf-8?Q?eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee?=' .\n            PHPMailer::getLE() .\n            ' =?utf-8?Q?eeeeeeeeeeeeeeeeeeeeeeeeee=C3=A9?=';\n        $bencodenofoldres = '=?utf-8?B?w6nDqcOpw6nDqcOpw6nDqcOpw6k=?=';\n        $qencodenofoldres = '=?utf-8?Q?eeeeeeeee=C3=A9?=';\n        $longheaderres = '=?us-ascii?Q?eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee?=' .\n            PHPMailer::getLE() . ' =?us-ascii?Q?eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee?=';\n        $longutf8res = '=?utf-8?B?w6nDqcOpw6nDqcOpw6nDqcOpw6nDqcOpw6nDqcOpw6nDqcOpw6nDqcOpw6k=?=' .\n             PHPMailer::getLE() . ' =?utf-8?B?w6nDqcOpw6nDqcOpw6nDqcOpw6nDqcOpw6nDqcOpw6nDqcOpw6nDqcOpw6k=?=' .\n             PHPMailer::getLE() . ' =?utf-8?B?w6nDqcOpw6nDqcOpw6nDqcOpw6nDqcOpw6nDqcOpw6nDqcOpw6nDqcOpw6k=?=' .\n             PHPMailer::getLE() . ' =?utf-8?B?w6nDqcOpw6nDqcOpw6nDqcOpw6nDqcOpw6nDqcOpw6nDqcOpw6nDqQ==?=';\n        $noencoderes = 'eeeeeeeeee';\n        self::assertEquals(\n            $bencoderes,\n            $this->Mail->encodeHeader($bencode),\n            'Folded B-encoded header value incorrect'\n        );\n        self::assertEquals(\n            $qencoderes,\n            $this->Mail->encodeHeader($qencode),\n            'Folded Q-encoded header value incorrect'\n        );\n        self::assertEquals(\n            $bencodenofoldres,\n            $this->Mail->encodeHeader($bencodenofold),\n            'B-encoded header value incorrect'\n        );\n        self::assertEquals(\n            $qencodenofoldres,\n            $this->Mail->encodeHeader($qencodenofold),\n            'Q-encoded header value incorrect'\n        );\n        self::assertEquals(\n            $longheaderres,\n            $this->Mail->encodeHeader($longheader),\n            'Long header value incorrect'\n        );\n        self::assertEquals(\n            $longutf8res,\n            $this->Mail->encodeHeader($longutf8),\n            'Long UTF-8 header value incorrect'\n        );\n        self::assertEquals(\n            $noencoderes,\n            $this->Mail->encodeHeader($noencode),\n            'Unencoded header value incorrect'\n        );\n    }\n\n    /**\n     * Send an HTML message.\n     */\n    public function testHtml()\n    {\n        $this->Mail->isHTML(true);\n        $this->Mail->Subject .= ': HTML only';\n\n        $this->Mail->Body = <<<'EOT'\n<!DOCTYPE html>\n<html lang=\"en\">\n    <head>\n        <title>HTML email test</title>\n    </head>\n    <body>\n        <h1>PHPMailer does HTML!</h1>\n        <p>This is a <strong>test message</strong> written in HTML.<br>\n        Go to <a href=\"https://github.com/PHPMailer/PHPMailer/\">https://github.com/PHPMailer/PHPMailer/</a>\n        for new versions of PHPMailer.</p>\n        <p>Thank you!</p>\n    </body>\n</html>\nEOT;\n        $this->buildBody();\n        self::assertTrue($this->Mail->send(), $this->Mail->ErrorInfo);\n        $msg = $this->Mail->getSentMIMEMessage();\n        self::assertStringNotContainsString(\"\\r\\n\\r\\nMIME-Version:\", $msg, 'Incorrect MIME headers');\n    }\n\n    /**\n     * Send an HTML message specifying the DSN notifications we expect.\n     */\n    public function testDsn()\n    {\n        $this->Mail->isHTML(true);\n        $this->Mail->Subject .= ': HTML only';\n\n        $this->Mail->Body = <<<'EOT'\n<!DOCTYPE html>\n<html lang=\"en\">\n    <head>\n        <title>HTML email test</title>\n    </head>\n    <body>\n        <p>PHPMailer</p>\n    </body>\n</html>\nEOT;\n        $this->buildBody();\n        $this->Mail->dsn = 'SUCCESS,FAILURE';\n        self::assertTrue($this->Mail->send(), $this->Mail->ErrorInfo);\n        //Sends the same mail, but sets the DSN notification to NEVER\n        $this->Mail->dsn = 'NEVER';\n        self::assertTrue($this->Mail->send(), $this->Mail->ErrorInfo);\n    }\n\n    /**\n     * createBody test of switch case\n     */\n    public function testCreateBody()\n    {\n        $PHPMailer = new PHPMailer();\n        $reflection = new \\ReflectionClass($PHPMailer);\n        $property = $reflection->getProperty('message_type');\n        $property->setAccessible(true);\n        $property->setValue($PHPMailer, 'inline');\n        self::assertIsString($PHPMailer->createBody());\n\n        $property->setValue($PHPMailer, 'attach');\n        self::assertIsString($PHPMailer->createBody());\n\n        $property->setValue($PHPMailer, 'inline_attach');\n        self::assertIsString($PHPMailer->createBody());\n\n        $property->setValue($PHPMailer, 'alt');\n        self::assertIsString($PHPMailer->createBody());\n\n        $property->setValue($PHPMailer, 'alt_inline');\n        self::assertIsString($PHPMailer->createBody());\n\n        $property->setValue($PHPMailer, 'alt_attach');\n        self::assertIsString($PHPMailer->createBody());\n\n        $property->setValue($PHPMailer, 'alt_inline_attach');\n        self::assertIsString($PHPMailer->createBody());\n    }\n\n    /**\n     * Send a message containing ISO-8859-1 text.\n     */\n    public function testHtmlIso8859()\n    {\n        $this->Mail->isHTML(true);\n        $this->Mail->Subject .= ': ISO-8859-1 HTML';\n        $this->Mail->CharSet = PHPMailer::CHARSET_ISO88591;\n\n        //This file is in ISO-8859-1 charset\n        //Needs to be external because this file is in UTF-8\n        $content = file_get_contents(realpath($this->INCLUDE_DIR . '/examples/contents.html'));\n        //This is the string '\u00e9\u00e8\u00ee\u00fc\u00e7\u00c5\u00f1\u00e6\u00df' in ISO-8859-1, base-64 encoded\n        $check = base64_decode('6eju/OfF8ebf');\n        //Make sure it really is in ISO-8859-1!\n        $this->Mail->msgHTML(\n            mb_convert_encoding(\n                $content,\n                'ISO-8859-1',\n                mb_detect_encoding($content, 'UTF-8, ISO-8859-1, ISO-8859-15', true)\n            ),\n            realpath($this->INCLUDE_DIR . '/examples')\n        );\n        $this->buildBody();\n        self::assertStringContainsString($check, $this->Mail->Body, 'ISO message body does not contain expected text');\n        self::assertTrue($this->Mail->send(), $this->Mail->ErrorInfo);\n    }\n\n    /**\n     * Send a message containing multilingual UTF-8 text.\n     */\n    public function testHtmlUtf8()\n    {\n        $this->Mail->isHTML(true);\n        $this->Mail->Subject .= ': UTF-8 HTML \u041f\u0443\u0441\u0442\u043e\u0435 \u0442\u0435\u043b\u043e \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u044f';\n        $this->Mail->CharSet = 'UTF-8';\n\n        $this->Mail->Body = <<<'EOT'\n<!DOCTYPE html>\n<html lang=\"en\">\n    <head>\n        <meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\">\n        <title>HTML email test</title>\n    </head>\n    <body>\n        <p>Chinese text: \u90f5\u4ef6\u5167\u5bb9\u70ba\u7a7a</p>\n        <p>Russian text: \u041f\u0443\u0441\u0442\u043e\u0435 \u0442\u0435\u043b\u043e \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u044f</p>\n        <p>Armenian text: \u0540\u0561\u0572\u0578\u0580\u0564\u0561\u0563\u0580\u0578\u0582\u0569\u0575\u0578\u0582\u0576\u0568 \u0564\u0561\u057f\u0561\u0580\u056f \u0567</p>\n        <p>Czech text: Pr\u00e1zdn\u00e9 t\u011blo zpr\u00e1vy</p>\n    </body>\n</html>\nEOT;\n        $this->buildBody();\n        self::assertTrue($this->Mail->send(), $this->Mail->ErrorInfo);\n        $msg = $this->Mail->getSentMIMEMessage();\n        self::assertStringNotContainsString(\"\\r\\n\\r\\nMIME-Version:\", $msg, 'Incorrect MIME headers');\n    }\n\n    /**\n     * Send a message containing multilingual UTF-8 text with an embedded image.\n     */\n    public function testUtf8WithEmbeddedImage()\n    {\n        $this->Mail->isHTML(true);\n        $this->Mail->Subject .= ': UTF-8 with embedded image';\n        $this->Mail->CharSet = 'UTF-8';\n\n        $this->Mail->Body = <<<'EOT'\n<!DOCTYPE html>\n<html lang=\"en\">\n    <head>\n        <meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\">\n        <title>HTML email test</title>\n    </head>\n    <body>\n        <p>Chinese text: \u90f5\u4ef6\u5167\u5bb9\u70ba\u7a7a</p>\n        <p>Russian text: \u041f\u0443\u0441\u0442\u043e\u0435 \u0442\u0435\u043b\u043e \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u044f</p>\n        <p>Armenian text: \u0540\u0561\u0572\u0578\u0580\u0564\u0561\u0563\u0580\u0578\u0582\u0569\u0575\u0578\u0582\u0576\u0568 \u0564\u0561\u057f\u0561\u0580\u056f \u0567</p>\n        <p>Czech text: Pr\u00e1zdn\u00e9 t\u011blo zpr\u00e1vy</p>\n        Embedded Image: <img alt=\"phpmailer\" src=\"cid:b\u00e4ck\">\n    </body>\n</html>\nEOT;\n        $this->Mail->addEmbeddedImage(\n            realpath($this->INCLUDE_DIR . '/examples/images/phpmailer.png'),\n            'b\u00e4ck',\n            'phpmailer.png',\n            'base64',\n            'image/png'\n        );\n        $this->buildBody();\n        self::assertTrue($this->Mail->send(), $this->Mail->ErrorInfo);\n    }\n\n    /**\n     * Send a message containing multilingual UTF-8 text.\n     */\n    public function testPlainUtf8()\n    {\n        $this->Mail->isHTML(false);\n        $this->Mail->Subject .= ': UTF-8 plain text';\n        $this->Mail->CharSet = 'UTF-8';\n\n        $this->Mail->Body = <<<'EOT'\nChinese text: \u90f5\u4ef6\u5167\u5bb9\u70ba\u7a7a\nRussian text: \u041f\u0443\u0441\u0442\u043e\u0435 \u0442\u0435\u043b\u043e \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u044f\nArmenian text: \u0540\u0561\u0572\u0578\u0580\u0564\u0561\u0563\u0580\u0578\u0582\u0569\u0575\u0578\u0582\u0576\u0568 \u0564\u0561\u057f\u0561\u0580\u056f \u0567\nCzech text: Pr\u00e1zdn\u00e9 t\u011blo zpr\u00e1vy\nEOT;\n        $this->buildBody();\n        self::assertTrue($this->Mail->send(), $this->Mail->ErrorInfo);\n        $msg = $this->Mail->getSentMIMEMessage();\n        self::assertStringNotContainsString(\"\\r\\n\\r\\nMIME-Version:\", $msg, 'Incorrect MIME headers');\n    }\n\n    /**\n     * Test simple message builder and html2text converters.\n     */\n    public function testMsgHTML()\n    {\n        $message = file_get_contents(realpath($this->INCLUDE_DIR . '/examples/contentsutf8.html'));\n        $this->Mail->CharSet = PHPMailer::CHARSET_UTF8;\n        $this->Mail->Body = '';\n        $this->Mail->AltBody = '';\n        //Uses internal HTML to text conversion\n        $this->Mail->msgHTML($message, realpath($this->INCLUDE_DIR . '/examples'));\n        $sub = $this->Mail->Subject . ': msgHTML';\n        $this->Mail->Subject .= $sub;\n\n        self::assertNotEmpty($this->Mail->Body, 'Body not set by msgHTML');\n        self::assertNotEmpty($this->Mail->AltBody, 'AltBody not set by msgHTML');\n        self::assertTrue($this->Mail->send(), $this->Mail->ErrorInfo);\n\n        //Again, using a custom HTML to text converter\n        $this->Mail->AltBody = '';\n        $this->Mail->msgHTML(\n            $message,\n            realpath($this->INCLUDE_DIR . '/examples'),\n            function ($html) {\n                return strtoupper(strip_tags($html));\n            }\n        );\n        $this->Mail->Subject = $sub . ' + custom html2text';\n        self::assertTrue($this->Mail->send(), $this->Mail->ErrorInfo);\n\n        //Test that local paths without a basedir are ignored\n        $this->Mail->msgHTML('<img src=\"/etc/hostname\">test');\n        self::assertStringContainsString('src=\"/etc/hostname\"', $this->Mail->Body);\n        //Test that local paths with a basedir are not ignored\n        $this->Mail->msgHTML('<img src=\"composer.json\">test', realpath($this->INCLUDE_DIR));\n        self::assertStringNotContainsString('src=\"composer.json\"', $this->Mail->Body);\n        //Test that local paths with parent traversal are ignored\n        $this->Mail->msgHTML('<img src=\"../composer.json\">test', realpath($this->INCLUDE_DIR));\n        self::assertStringNotContainsString('src=\"composer.json\"', $this->Mail->Body);\n        //Test that existing embedded URLs are ignored\n        $this->Mail->msgHTML('<img src=\"cid:5d41402abc4b2a76b9719d911017c592\">test');\n        self::assertStringContainsString('src=\"cid:5d41402abc4b2a76b9719d911017c592\"', $this->Mail->Body);\n        //Test that absolute URLs are ignored\n        $this->Mail->msgHTML('<img src=\"https://github.com/PHPMailer/PHPMailer/blob/master/composer.json\">test');\n        self::assertStringContainsString(\n            'src=\"https://github.com/PHPMailer/PHPMailer/blob/master/composer.json\"',\n            $this->Mail->Body\n        );\n        //Test that absolute URLs with anonymous/relative protocol are ignored\n        //Note that such URLs will not work in email anyway because they have no protocol to be relative to\n        $this->Mail->msgHTML('<img src=\"//github.com/PHPMailer/PHPMailer/blob/master/composer.json\">test');\n        self::assertStringContainsString(\n            'src=\"//github.com/PHPMailer/PHPMailer/blob/master/composer.json\"',\n            $this->Mail->Body\n        );\n    }\n\n    /**\n     * Simple HTML and attachment test.\n     */\n    public function testHTMLAttachment()\n    {\n        $this->Mail->Body = 'This is the <strong>HTML</strong> part of the email.';\n        $this->Mail->Subject .= ': HTML + Attachment';\n        $this->Mail->isHTML(true);\n        $this->Mail->CharSet = 'UTF-8';\n\n        if (\n            !$this->Mail->addAttachment(\n                realpath($this->INCLUDE_DIR . '/examples/images/phpmailer_mini.png'),\n                'phpmailer_mini.png'\n            )\n        ) {\n            self::assertTrue(false, $this->Mail->ErrorInfo);\n\n            return;\n        }\n\n        //Make sure phar paths are rejected\n        self::assertFalse($this->Mail->addAttachment('phar://pharfile.php', 'pharfile.php'));\n        //Make sure any path that looks URLish is rejected\n        self::assertFalse($this->Mail->addAttachment('http://example.com/test.php', 'test.php'));\n        self::assertFalse(\n            $this->Mail->addAttachment(\n                'ssh2.sftp://user:pass@attacker-controlled.example.com:22/tmp/payload.phar',\n                'test.php'\n            )\n        );\n        self::assertFalse($this->Mail->addAttachment('x-1.cd+-://example.com/test.php', 'test.php'));\n\n        //Make sure that trying to attach a nonexistent file fails\n        $filename = __FILE__ . md5(microtime()) . 'nonexistent_file.txt';\n        self::assertFalse($this->Mail->addAttachment($filename));\n        //Make sure that trying to attach an existing but unreadable file fails\n        touch($filename);\n        chmod($filename, 0200);\n        self::assertFalse($this->Mail->addAttachment($filename));\n        chmod($filename, 0644);\n        unlink($filename);\n\n        $this->buildBody();\n        self::assertTrue($this->Mail->send(), $this->Mail->ErrorInfo);\n    }\n\n    /**\n     * Attachment naming test.\n     */\n    public function testAttachmentNaming()\n    {\n        $this->Mail->Body = 'Attachments.';\n        $this->Mail->Subject .= ': Attachments';\n        $this->Mail->isHTML(true);\n        $this->Mail->CharSet = 'UTF-8';\n        $this->Mail->addAttachment(\n            realpath($this->INCLUDE_DIR . '/examples/images/phpmailer_mini.png'),\n            'phpmailer_mini.png\";.jpg'\n        );\n        $this->Mail->addAttachment(\n            realpath($this->INCLUDE_DIR . '/examples/images/phpmailer.png'),\n            'phpmailer.png'\n        );\n        $this->Mail->addAttachment(\n            realpath($this->INCLUDE_DIR . '/examples/images/PHPMailer card logo.png'),\n            'PHPMailer card logo.png'\n        );\n        $this->Mail->addAttachment(\n            realpath($this->INCLUDE_DIR . '/examples/images/phpmailer_mini.png'),\n            'phpmailer_mini.png\\\\\\\";.jpg'\n        );\n        $this->buildBody();\n        $this->Mail->preSend();\n        $message = $this->Mail->getSentMIMEMessage();\n        self::assertStringContainsString(\n            'Content-Type: image/png; name=\"phpmailer_mini.png\\\";.jpg\"',\n            $message,\n            'Name containing double quote should be escaped in Content-Type'\n        );\n        self::assertStringContainsString(\n            'Content-Disposition: attachment; filename=\"phpmailer_mini.png\\\";.jpg\"',\n            $message,\n            'Filename containing double quote should be escaped in Content-Disposition'\n        );\n        self::assertStringContainsString(\n            'Content-Type: image/png; name=phpmailer.png',\n            $message,\n            'Name without special chars should not be quoted in Content-Type'\n        );\n        self::assertStringContainsString(\n            'Content-Disposition: attachment; filename=phpmailer.png',\n            $message,\n            'Filename without special chars should not be quoted in Content-Disposition'\n        );\n        self::assertStringContainsString(\n            'Content-Type: image/png; name=\"PHPMailer card logo.png\"',\n            $message,\n            'Name with spaces should be quoted in Content-Type'\n        );\n        self::assertStringContainsString(\n            'Content-Disposition: attachment; filename=\"PHPMailer card logo.png\"',\n            $message,\n            'Filename with spaces should be quoted in Content-Disposition'\n        );\n    }\n\n    /**\n     * Test embedded image without a name.\n     */\n    public function testHTMLStringEmbedNoName()\n    {\n        $this->Mail->Body = 'This is the <strong>HTML</strong> part of the email.';\n        $this->Mail->Subject .= ': HTML + unnamed embedded image';\n        $this->Mail->isHTML(true);\n\n        if (\n            !$this->Mail->addStringEmbeddedImage(\n                file_get_contents(realpath($this->INCLUDE_DIR . '/examples/images/phpmailer_mini.png')),\n                hash('sha256', 'phpmailer_mini.png') . '@phpmailer.0',\n                '', //Intentionally empty name\n                'base64',\n                '', //Intentionally empty MIME type\n                'inline'\n            )\n        ) {\n            self::assertTrue(false, $this->Mail->ErrorInfo);\n\n            return;\n        }\n\n        $this->buildBody();\n        self::assertTrue($this->Mail->send(), $this->Mail->ErrorInfo);\n    }\n\n    /**\n     * Simple HTML and multiple attachment test.\n     */\n    public function testHTMLMultiAttachment()\n    {\n        $this->Mail->Body = 'This is the <strong>HTML</strong> part of the email.';\n        $this->Mail->Subject .= ': HTML + multiple Attachment';\n        $this->Mail->isHTML(true);\n\n        if (\n            !$this->Mail->addAttachment(\n                realpath($this->INCLUDE_DIR . '/examples/images/phpmailer_mini.png'),\n                'phpmailer_mini.png'\n            )\n        ) {\n            self::assertTrue(false, $this->Mail->ErrorInfo);\n\n            return;\n        }\n\n        if (\n            !$this->Mail->addAttachment(\n                realpath($this->INCLUDE_DIR . '/examples/images/phpmailer.png'),\n                'phpmailer.png'\n            )\n        ) {\n            self::assertTrue(false, $this->Mail->ErrorInfo);\n\n            return;\n        }\n\n        $this->buildBody();\n        self::assertTrue($this->Mail->send(), $this->Mail->ErrorInfo);\n    }\n\n    /**\n     * An embedded attachment test.\n     */\n    public function testEmbeddedImage()\n    {\n        $this->Mail->Body = 'Embedded Image: <img alt=\"phpmailer\" src=\"' .\n            'cid:my-attach\">' .\n            'Here is an image!';\n        $this->Mail->Subject .= ': Embedded Image';\n        $this->Mail->isHTML(true);\n\n        if (\n            !$this->Mail->addEmbeddedImage(\n                realpath($this->INCLUDE_DIR . '/examples/images/phpmailer.png'),\n                'my-attach',\n                'phpmailer.png',\n                'base64',\n                'image/png'\n            )\n        ) {\n            self::assertTrue(false, $this->Mail->ErrorInfo);\n\n            return;\n        }\n\n        $this->buildBody();\n        self::assertTrue($this->Mail->send(), $this->Mail->ErrorInfo);\n        $this->Mail->clearAttachments();\n        $this->Mail->msgHTML('<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" />\n    <title>E-Mail Inline Image Test</title>\n  </head>\n  <body>\n    <p><img src=\"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\"></p>\n  </body>\n</html>');\n        $this->Mail->preSend();\n        self::assertStringContainsString(\n            'Content-ID: <bb229a48bee31f5d54ca12dc9bd960c6@phpmailer.0>',\n            $this->Mail->getSentMIMEMessage(),\n            'Embedded image header encoding incorrect.'\n        );\n        //For code coverage\n        $this->Mail->addEmbeddedImage('thisfiledoesntexist', 'xyz'); //Non-existent file\n        $this->Mail->addEmbeddedImage(__FILE__, '123'); //Missing name\n    }\n\n    /**\n     * An embedded attachment test.\n     */\n    public function testMultiEmbeddedImage()\n    {\n        $this->Mail->Body = 'Embedded Image: <img alt=\"phpmailer\" src=\"' .\n            'cid:my-attach\">' .\n            'Here is an image!</a>';\n        $this->Mail->Subject .= ': Embedded Image + Attachment';\n        $this->Mail->isHTML(true);\n\n        if (\n            !$this->Mail->addEmbeddedImage(\n                realpath($this->INCLUDE_DIR . '/examples/images/phpmailer.png'),\n                'my-attach',\n                'phpmailer.png',\n                'base64',\n                'image/png'\n            )\n        ) {\n            self::assertTrue(false, $this->Mail->ErrorInfo);\n\n            return;\n        }\n\n        if (!$this->Mail->addAttachment(__FILE__, 'test.txt')) {\n            self::assertTrue(false, $this->Mail->ErrorInfo);\n\n            return;\n        }\n\n        $this->buildBody();\n        self::assertTrue($this->Mail->send(), $this->Mail->ErrorInfo);\n    }\n\n    /**\n     * Simple multipart/alternative test.\n     */\n    public function testAltBody()\n    {\n        $this->Mail->Body = 'This is the <strong>HTML</strong> part of the email.';\n        $this->Mail->AltBody = 'Here is the plain text body of this message. ' .\n            'It should be quite a few lines. It should be wrapped at ' .\n            '40 characters.  Make sure that it is.';\n        $this->Mail->WordWrap = 40;\n        $this->addNote('This is a multipart/alternative email');\n        $this->Mail->Subject .= ': AltBody + Word Wrap';\n\n        $this->buildBody();\n        self::assertTrue($this->Mail->send(), $this->Mail->ErrorInfo);\n    }\n\n    /**\n     * Simple HTML and attachment test.\n     */\n    public function testAltBodyAttachment()\n    {\n        $this->Mail->Body = 'This is the <strong>HTML</strong> part of the email.';\n        $this->Mail->AltBody = 'This is the text part of the email.';\n        $this->Mail->Subject .= ': AltBody + Attachment';\n        $this->Mail->isHTML(true);\n\n        if (!$this->Mail->addAttachment(__FILE__, 'test_attach.txt')) {\n            self::assertTrue(false, $this->Mail->ErrorInfo);\n\n            return;\n        }\n\n        //Test using non-existent UNC path\n        self::assertFalse($this->Mail->addAttachment('\\\\\\\\nowhere\\\\nothing'));\n\n        $this->buildBody();\n        self::assertTrue($this->Mail->send(), $this->Mail->ErrorInfo);\n    }\n\n    /**\n     * Test sending multiple messages with separate connections.\n     */\n    public function testMultipleSend()\n    {\n        $this->Mail->Body = 'Sending two messages without keepalive';\n        $this->buildBody();\n        $subject = $this->Mail->Subject;\n\n        $this->Mail->Subject = $subject . ': SMTP 1';\n        self::assertTrue($this->Mail->send(), $this->Mail->ErrorInfo);\n\n        $this->Mail->Subject = $subject . ': SMTP 2';\n        $this->Mail->Sender = 'blah@example.com';\n        self::assertTrue($this->Mail->send(), $this->Mail->ErrorInfo);\n    }\n\n    /**\n     * Test sending using SendMail.\n     */\n    public function testSendmailSend()\n    {\n        $this->Mail->Body = 'Sending via sendmail';\n        $this->buildBody();\n        $subject = $this->Mail->Subject;\n\n        $this->Mail->Subject = $subject . ': sendmail';\n        $this->Mail->isSendmail();\n\n        self::assertTrue($this->Mail->send(), $this->Mail->ErrorInfo);\n    }\n\n    /**\n     * Test sending using Qmail.\n     */\n    public function testQmailSend()\n    {\n        //Only run if we have qmail installed\n        if (file_exists('/var/qmail/bin/qmail-inject')) {\n            $this->Mail->Body = 'Sending via qmail';\n            $this->buildBody();\n            $subject = $this->Mail->Subject;\n\n            $this->Mail->Subject = $subject . ': qmail';\n            $this->Mail->isQmail();\n            self::assertTrue($this->Mail->send(), $this->Mail->ErrorInfo);\n        } else {\n            self::markTestSkipped('Qmail is not installed');\n        }\n    }\n\n    /**\n     * Test sending using PHP mail() function.\n     */\n    public function testMailSend()\n    {\n        $sendmail = ini_get('sendmail_path');\n        //No path in sendmail_path\n        if (strpos($sendmail, '/') === false) {\n            ini_set('sendmail_path', '/usr/sbin/sendmail -t -i ');\n        }\n        $this->Mail->Body = 'Sending via mail()';\n        $this->buildBody();\n        $this->Mail->Subject = $this->Mail->Subject . ': mail()';\n        $this->Mail->clearAddresses();\n        $this->Mail->clearCCs();\n        $this->Mail->clearBCCs();\n        $this->setAddress('testmailsend@example.com', 'totest');\n        $this->setAddress('cctestmailsend@example.com', 'cctest', $sType = 'cc');\n        $this->setAddress('bcctestmailsend@example.com', 'bcctest', $sType = 'bcc');\n        $this->Mail->addReplyTo('replytotestmailsend@example.com', 'replytotest');\n        self::assertContains('testmailsend@example.com', $this->Mail->getToAddresses()[0]);\n        self::assertContains('cctestmailsend@example.com', $this->Mail->getCcAddresses()[0]);\n        self::assertContains('bcctestmailsend@example.com', $this->Mail->getBccAddresses()[0]);\n        self::assertContains(\n            'replytotestmailsend@example.com',\n            $this->Mail->getReplyToAddresses()['replytotestmailsend@example.com']\n        );\n        self::assertTrue($this->Mail->getAllRecipientAddresses()['testmailsend@example.com']);\n        self::assertTrue($this->Mail->getAllRecipientAddresses()['cctestmailsend@example.com']);\n        self::assertTrue($this->Mail->getAllRecipientAddresses()['bcctestmailsend@example.com']);\n\n        $this->Mail->createHeader();\n        $this->Mail->isMail();\n        self::assertTrue($this->Mail->send(), $this->Mail->ErrorInfo);\n        $msg = $this->Mail->getSentMIMEMessage();\n        self::assertStringNotContainsString(\"\\r\\n\\r\\nMIME-Version:\", $msg, 'Incorrect MIME headers');\n    }\n\n    /**\n     * Test sending an empty body.\n     */\n    public function testEmptyBody()\n    {\n        $this->buildBody();\n        $this->Mail->Body = '';\n        $this->Mail->Subject = $this->Mail->Subject . ': Empty Body';\n        $this->Mail->isMail();\n        $this->Mail->AllowEmpty = true;\n        self::assertTrue($this->Mail->send(), $this->Mail->ErrorInfo);\n        $this->Mail->AllowEmpty = false;\n        self::assertFalse($this->Mail->send(), $this->Mail->ErrorInfo);\n    }\n\n    /**\n     * Test constructing a multipart message that contains lines that are too long for RFC compliance.\n     */\n    public function testLongBody()\n    {\n        $oklen = str_repeat(str_repeat('0', PHPMailer::MAX_LINE_LENGTH) . PHPMailer::getLE(), 2);\n        //Use +2 to ensure line length is over limit - LE may only be 1 char\n        $badlen = str_repeat(str_repeat('1', PHPMailer::MAX_LINE_LENGTH + 2) . PHPMailer::getLE(), 2);\n\n        $this->Mail->Body = 'This message contains lines that are too long.' .\n            PHPMailer::getLE() . $oklen . $badlen . $oklen;\n        self::assertTrue(\n            PHPMailer::hasLineLongerThanMax($this->Mail->Body),\n            'Test content does not contain long lines!'\n        );\n        $this->Mail->isHTML();\n        $this->buildBody();\n        $this->Mail->AltBody = $this->Mail->Body;\n        $this->Mail->Encoding = '8bit';\n        $this->Mail->preSend();\n        $message = $this->Mail->getSentMIMEMessage();\n        self::assertFalse(\n            PHPMailer::hasLineLongerThanMax($message),\n            'Long line not corrected (Max: ' . (PHPMailer::MAX_LINE_LENGTH + strlen(PHPMailer::getLE())) . ' chars)'\n        );\n        self::assertStringContainsString(\n            'Content-Transfer-Encoding: quoted-printable',\n            $message,\n            'Long line did not cause transfer encoding switch.'\n        );\n    }\n\n    /**\n     * Test constructing a message that does NOT contain lines that are too long for RFC compliance.\n     */\n    public function testShortBody()\n    {\n        $oklen = str_repeat(str_repeat('0', PHPMailer::MAX_LINE_LENGTH) . PHPMailer::getLE(), 10);\n\n        $this->Mail->Body = 'This message does not contain lines that are too long.' .\n            PHPMailer::getLE() . $oklen;\n        self::assertFalse(\n            PHPMailer::hasLineLongerThanMax($this->Mail->Body),\n            'Test content contains long lines!'\n        );\n        $this->buildBody();\n        $this->Mail->Encoding = '8bit';\n        $this->Mail->preSend();\n        $message = $this->Mail->getSentMIMEMessage();\n        self::assertFalse(PHPMailer::hasLineLongerThanMax($message), 'Long line not corrected.');\n        self::assertStringNotContainsString(\n            'Content-Transfer-Encoding: quoted-printable',\n            $message,\n            'Short line caused transfer encoding switch.'\n        );\n    }\n\n    /**\n     * Test keepalive (sending multiple messages in a single connection).\n     */\n    public function testSmtpKeepAlive()\n    {\n        $this->Mail->Body = 'SMTP keep-alive test.';\n        $this->buildBody();\n        $subject = $this->Mail->Subject;\n\n        $this->Mail->SMTPKeepAlive = true;\n        $this->Mail->Subject = $subject . ': SMTP keep-alive 1';\n        self::assertTrue($this->Mail->send(), $this->Mail->ErrorInfo);\n\n        $this->Mail->Subject = $subject . ': SMTP keep-alive 2';\n        self::assertTrue($this->Mail->send(), $this->Mail->ErrorInfo);\n        $this->Mail->smtpClose();\n    }\n\n    /**\n     * Test this denial of service attack.\n     *\n     * @see http://www.cybsec.com/vuln/PHPMailer-DOS.pdf\n     */\n    public function testDenialOfServiceAttack()\n    {\n        $this->Mail->Body = 'This should no longer cause a denial of service.';\n        $this->buildBody();\n\n        $this->Mail->Subject = substr(str_repeat('0123456789', 100), 0, 998);\n        self::assertTrue($this->Mail->send(), $this->Mail->ErrorInfo);\n    }\n\n    /**\n     * Tests this denial of service attack.\n     *\n     * According to the ticket, this should get stuck in a loop, though I can't make it happen.\n     * @see https://sourceforge.net/p/phpmailer/bugs/383/\n     *\n     * @doesNotPerformAssertions\n     */\n    public function testDenialOfServiceAttack2()\n    {\n        //Encoding name longer than 68 chars\n        $this->Mail->Encoding = '1234567890123456789012345678901234567890123456789012345678901234567890';\n        //Call wrapText with a zero length value\n        $this->Mail->wrapText(str_repeat('This should no longer cause a denial of service. ', 30), 0);\n    }\n\n    /**\n     * Test error handling.\n     */\n    public function testError()\n    {\n        $this->Mail->Subject .= ': Error handling test - this should be sent ok';\n        $this->buildBody();\n        $this->Mail->clearAllRecipients(); //No addresses should cause an error\n        self::assertTrue($this->Mail->isError() == false, 'Error found');\n        self::assertTrue($this->Mail->send() == false, 'send succeeded');\n        self::assertTrue($this->Mail->isError(), 'No error found');\n        self::assertEquals('You must provide at least one recipient email address.', $this->Mail->ErrorInfo);\n        $this->Mail->addAddress($_REQUEST['mail_to']);\n        self::assertTrue($this->Mail->send(), 'send failed');\n    }\n\n    /**\n     * Test addressing.\n     */\n    public function testAddressing()\n    {\n        self::assertFalse($this->Mail->addAddress(''), 'Empty address accepted');\n        self::assertFalse($this->Mail->addAddress('', 'Nobody'), 'Empty address with name accepted');\n        self::assertFalse($this->Mail->addAddress('a@example..com'), 'Invalid address accepted');\n        self::assertTrue($this->Mail->addAddress('a@example.com'), 'Addressing failed');\n        self::assertFalse($this->Mail->addAddress('a@example.com'), 'Duplicate addressing failed');\n        self::assertTrue($this->Mail->addCC('b@example.com'), 'CC addressing failed');\n        self::assertFalse($this->Mail->addCC('b@example.com'), 'CC duplicate addressing failed');\n        self::assertFalse($this->Mail->addCC('a@example.com'), 'CC duplicate addressing failed (2)');\n        self::assertTrue($this->Mail->addBCC('c@example.com'), 'BCC addressing failed');\n        self::assertFalse($this->Mail->addBCC('c@example.com'), 'BCC duplicate addressing failed');\n        self::assertFalse($this->Mail->addBCC('a@example.com'), 'BCC duplicate addressing failed (2)');\n        self::assertTrue($this->Mail->addReplyTo('a@example.com'), 'Replyto Addressing failed');\n        self::assertFalse($this->Mail->addReplyTo('a@example..com'), 'Invalid Replyto address accepted');\n        self::assertTrue($this->Mail->setFrom('a@example.com', 'some name'), 'setFrom failed');\n        self::assertFalse($this->Mail->setFrom('a@example.com.', 'some name'), 'setFrom accepted invalid address');\n        $this->Mail->Sender = '';\n        $this->Mail->setFrom('a@example.com', 'some name', true);\n        self::assertEquals($this->Mail->Sender, 'a@example.com', 'setFrom failed to set sender');\n        $this->Mail->Sender = '';\n        $this->Mail->setFrom('a@example.com', 'some name', false);\n        self::assertEquals($this->Mail->Sender, '', 'setFrom should not have set sender');\n        $this->Mail->clearCCs();\n        $this->Mail->clearBCCs();\n        $this->Mail->clearReplyTos();\n    }\n\n    /**\n     * Test addressing.\n     */\n    public function testAddressing2()\n    {\n        $this->buildBody();\n        $this->Mail->setFrom('bob@example.com', '\"Bob\\'s Burgers\" (Bob\\'s \"Burgers\")', true);\n        $this->Mail->isSMTP();\n        $this->Mail->Subject .= ': quotes in from name';\n        self::assertTrue($this->Mail->send(), 'send failed');\n    }\n\n    /**\n     * Test RFC822 address splitting.\n     */\n    public function testAddressSplitting()\n    {\n        //Test built-in address parser\n        self::assertCount(\n            2,\n            PHPMailer::parseAddresses(\n                'Joe User <joe@example.com>, Jill User <jill@example.net>'\n            ),\n            'Failed to recognise address list (IMAP parser)'\n        );\n        self::assertEquals(\n            [\n                ['name' => 'Joe User', 'address' => 'joe@example.com'],\n                ['name' => 'Jill User', 'address' => 'jill@example.net'],\n                ['name' => '', 'address' => 'frank@example.com'],\n            ],\n            PHPMailer::parseAddresses(\n                'Joe User <joe@example.com>,'\n                . 'Jill User <jill@example.net>,'\n                . 'frank@example.com,'\n            ),\n            'Parsed addresses'\n        );\n        //Test simple address parser\n        self::assertCount(\n            2,\n            PHPMailer::parseAddresses(\n                'Joe User <joe@example.com>, Jill User <jill@example.net>',\n                false\n            ),\n            'Failed to recognise address list'\n        );\n        //Test single address\n        self::assertNotEmpty(\n            PHPMailer::parseAddresses(\n                'Joe User <joe@example.com>',\n                false\n            ),\n            'Failed to recognise single address'\n        );\n        //Test quoted name IMAP\n        self::assertNotEmpty(\n            PHPMailer::parseAddresses(\n                'Tim \"The Book\" O\\'Reilly <foo@example.com>'\n            ),\n            'Failed to recognise quoted name (IMAP)'\n        );\n        //Test quoted name\n        self::assertNotEmpty(\n            PHPMailer::parseAddresses(\n                'Tim \"The Book\" O\\'Reilly <foo@example.com>',\n                false\n            ),\n            'Failed to recognise quoted name'\n        );\n        //Test single address IMAP\n        self::assertNotEmpty(\n            PHPMailer::parseAddresses(\n                'Joe User <joe@example.com>'\n            ),\n            'Failed to recognise single address (IMAP)'\n        );\n        //Test unnamed address\n        self::assertNotEmpty(\n            PHPMailer::parseAddresses(\n                'joe@example.com',\n                false\n            ),\n            'Failed to recognise unnamed address'\n        );\n        //Test unnamed address IMAP\n        self::assertNotEmpty(\n            PHPMailer::parseAddresses(\n                'joe@example.com'\n            ),\n            'Failed to recognise unnamed address (IMAP)'\n        );\n        //Test invalid addresses\n        self::assertEmpty(\n            PHPMailer::parseAddresses(\n                'Joe User <joe@example.com.>, Jill User <jill.@example.net>'\n            ),\n            'Failed to recognise invalid addresses (IMAP)'\n        );\n        //Test invalid addresses\n        self::assertEmpty(\n            PHPMailer::parseAddresses(\n                'Joe User <joe@example.com.>, Jill User <jill.@example.net>',\n                false\n            ),\n            'Failed to recognise invalid addresses'\n        );\n    }\n\n    /**\n     * Test address escaping.\n     */\n    public function testAddressEscaping()\n    {\n        $this->Mail->Subject .= ': Address escaping';\n        $this->Mail->clearAddresses();\n        $this->Mail->addAddress('foo@example.com', 'Tim \"The Book\" O\\'Reilly');\n        $this->Mail->Body = 'Test correct escaping of quotes in addresses.';\n        $this->buildBody();\n        $this->Mail->preSend();\n        $b = $this->Mail->getSentMIMEMessage();\n        self::assertStringContainsString('To: \"Tim \\\"The Book\\\" O\\'Reilly\" <foo@example.com>', $b);\n\n        $this->Mail->Subject .= ': Address escaping invalid';\n        $this->Mail->clearAddresses();\n        $this->Mail->addAddress('foo@example.com', 'Tim \"The Book\" O\\'Reilly');\n        $this->Mail->addAddress('invalidaddressexample.com', 'invalidaddress');\n        $this->Mail->Body = 'invalid address';\n        $this->buildBody();\n        $this->Mail->preSend();\n        self::assertEquals('Invalid address:  (to): invalidaddressexample.com', $this->Mail->ErrorInfo);\n\n        $this->Mail->addAttachment(\n            realpath($this->INCLUDE_DIR . '/examples/images/phpmailer_mini.png'),\n            'phpmailer_mini.png'\n        );\n        self::assertTrue($this->Mail->attachmentExists());\n    }\n\n    /**\n     * Test MIME structure assembly.\n     */\n    public function testMIMEStructure()\n    {\n        $this->Mail->Subject .= ': MIME structure';\n        $this->Mail->Body = '<h3>MIME structure test.</h3>';\n        $this->Mail->AltBody = 'MIME structure test.';\n        $this->buildBody();\n        $this->Mail->preSend();\n        self::assertMatchesRegularExpression(\n            \"/Content-Transfer-Encoding: 8bit\\r\\n\\r\\n\" .\n            'This is a multi-part message in MIME format./',\n            $this->Mail->getSentMIMEMessage(),\n            'MIME structure broken'\n        );\n    }\n\n    /**\n     * Test BCC-only addressing.\n     */\n    public function testBCCAddressing()\n    {\n        $this->Mail->isSMTP();\n        $this->Mail->Subject .= ': BCC-only addressing';\n        $this->buildBody();\n        $this->Mail->clearAllRecipients();\n        $this->Mail->addAddress('foo@example.com', 'Foo');\n        $this->Mail->preSend();\n        $b = $this->Mail->getSentMIMEMessage();\n        self::assertTrue($this->Mail->addBCC('a@example.com'), 'BCC addressing failed');\n        self::assertStringContainsString('To: Foo <foo@example.com>', $b);\n        self::assertTrue($this->Mail->send(), 'send failed');\n    }\n\n    /**\n     * Encoding and charset tests.\n     */\n    public function testEncodings()\n    {\n        $this->Mail->CharSet = PHPMailer::CHARSET_ISO88591;\n        self::assertEquals(\n            '=A1Hola!_Se=F1or!',\n            $this->Mail->encodeQ(\"\\xa1Hola! Se\\xf1or!\", 'text'),\n            'Q Encoding (text) failed'\n        );\n        self::assertEquals(\n            '=A1Hola!_Se=F1or!',\n            $this->Mail->encodeQ(\"\\xa1Hola! Se\\xf1or!\", 'comment'),\n            'Q Encoding (comment) failed'\n        );\n        self::assertEquals(\n            '=A1Hola!_Se=F1or!',\n            $this->Mail->encodeQ(\"\\xa1Hola! Se\\xf1or!\", 'phrase'),\n            'Q Encoding (phrase) failed'\n        );\n        $this->Mail->CharSet = 'UTF-8';\n        self::assertEquals(\n            '=C2=A1Hola!_Se=C3=B1or!',\n            $this->Mail->encodeQ(\"\\xc2\\xa1Hola! Se\\xc3\\xb1or!\", 'text'),\n            'Q Encoding (text) failed'\n        );\n        //Strings containing '=' are a special case\n        self::assertEquals(\n            'Nov=C3=A1=3D',\n            $this->Mail->encodeQ(\"Nov\\xc3\\xa1=\", 'text'),\n            'Q Encoding (text) failed 2'\n        );\n\n        self::assertEquals(\n            'hello',\n            $this->Mail->encodeString('hello', 'binary'),\n            'Binary encoding changed input'\n        );\n        $this->Mail->ErrorInfo = '';\n        $this->Mail->encodeString('hello', 'asdfghjkl');\n        self::assertNotEmpty($this->Mail->ErrorInfo, 'Invalid encoding not detected');\n        self::assertMatchesRegularExpression(\n            '/' . base64_encode('hello') . '/',\n            $this->Mail->encodeString('hello')\n        );\n    }\n\n    /**\n     * Expect exceptions on bad encoding\n     */\n    public function testAddAttachmentEncodingException()\n    {\n        $this->expectException(Exception::class);\n\n        $mail = new PHPMailer(true);\n        $mail->addAttachment(__FILE__, 'test.txt', 'invalidencoding');\n    }\n\n    /**\n     * Expect exceptions on sending after deleting a previously successfully attached file\n     */\n    public function testDeletedAttachmentException()\n    {\n        $this->expectException(Exception::class);\n\n        $filename = __FILE__ . md5(microtime()) . 'test.txt';\n        touch($filename);\n        $this->Mail = new PHPMailer(true);\n        $this->Mail->addAttachment($filename);\n        unlink($filename);\n        $this->Mail->send();\n    }\n\n    /**\n     * Expect error on sending after deleting a previously successfully attached file\n     */\n    public function testDeletedAttachmentError()\n    {\n        $filename = __FILE__ . md5(microtime()) . 'test.txt';\n        touch($filename);\n        $this->Mail = new PHPMailer();\n        $this->Mail->addAttachment($filename);\n        unlink($filename);\n        self::assertFalse($this->Mail->send());\n    }\n\n    /**\n     * Expect exceptions on bad encoding\n     */\n    public function testStringAttachmentEncodingException()\n    {\n        $this->expectException(Exception::class);\n\n        $mail = new PHPMailer(true);\n        $mail->addStringAttachment('hello', 'test.txt', 'invalidencoding');\n    }\n\n    /**\n     * Expect exceptions on bad encoding\n     */\n    public function testEmbeddedImageEncodingException()\n    {\n        $this->expectException(Exception::class);\n\n        $mail = new PHPMailer(true);\n        $mail->addEmbeddedImage(__FILE__, 'cid', 'test.png', 'invalidencoding');\n    }\n\n    /**\n     * Expect exceptions on bad encoding\n     */\n    public function testStringEmbeddedImageEncodingException()\n    {\n        $this->expectException(Exception::class);\n\n        $mail = new PHPMailer(true);\n        $mail->addStringEmbeddedImage('hello', 'cid', 'test.png', 'invalidencoding');\n    }\n\n    /**\n     * Test base-64 encoding.\n     */\n    public function testBase64()\n    {\n        $this->Mail->Subject .= ': Base-64 encoding';\n        $this->Mail->Encoding = 'base64';\n        $this->buildBody();\n        self::assertTrue($this->Mail->send(), 'Base64 encoding failed');\n    }\n\n    /**\n     * S/MIME Signing tests (self-signed).\n     *\n     * @requires extension openssl\n     */\n    public function testSigning()\n    {\n        $this->Mail->Subject .= ': S/MIME signing';\n        $this->Mail->Body = 'This message is S/MIME signed.';\n        $this->buildBody();\n\n        $dn = [\n            'countryName' => 'UK',\n            'stateOrProvinceName' => 'Here',\n            'localityName' => 'There',\n            'organizationName' => 'PHP',\n            'organizationalUnitName' => 'PHPMailer',\n            'commonName' => 'PHPMailer Test',\n            'emailAddress' => 'phpmailer@example.com',\n        ];\n        $keyconfig = [\n            'digest_alg' => 'sha256',\n            'private_key_bits' => 2048,\n            'private_key_type' => OPENSSL_KEYTYPE_RSA,\n        ];\n        $password = 'password';\n        $certfile = 'certfile.pem';\n        $keyfile = 'keyfile.pem';\n\n        //Make a new key pair\n        $pk = openssl_pkey_new($keyconfig);\n        //Create a certificate signing request\n        $csr = openssl_csr_new($dn, $pk);\n        //Create a self-signed cert\n        $cert = openssl_csr_sign($csr, null, $pk, 1);\n        //Save the cert\n        openssl_x509_export($cert, $certout);\n        file_put_contents($certfile, $certout);\n        //Save the key\n        openssl_pkey_export($pk, $pkeyout, $password);\n        file_put_contents($keyfile, $pkeyout);\n\n        $this->Mail->sign(\n            $certfile,\n            $keyfile,\n            $password\n        );\n        self::assertTrue($this->Mail->send(), 'S/MIME signing failed');\n\n        $msg = $this->Mail->getSentMIMEMessage();\n        self::assertStringNotContainsString(\"\\r\\n\\r\\nMIME-Version:\", $msg, 'Incorrect MIME headers');\n        unlink($certfile);\n        unlink($keyfile);\n    }\n\n    /**\n     * S/MIME Signing tests using a CA chain cert.\n     * To test that a generated message is signed correctly, save the message in a file called `signed.eml`\n     * and use openssl along with the certs generated by this script:\n     * `openssl smime -verify -in signed.eml -signer certfile.pem -CAfile cacertfile.pem`.\n     *\n     * @requires extension openssl\n     */\n    public function testSigningWithCA()\n    {\n        $this->Mail->Subject .= ': S/MIME signing with CA';\n        $this->Mail->Body = 'This message is S/MIME signed with an extra CA cert.';\n        $this->buildBody();\n\n        $certprops = [\n            'countryName' => 'UK',\n            'stateOrProvinceName' => 'Here',\n            'localityName' => 'There',\n            'organizationName' => 'PHP',\n            'organizationalUnitName' => 'PHPMailer',\n            'commonName' => 'PHPMailer Test',\n            'emailAddress' => 'phpmailer@example.com',\n        ];\n        $cacertprops = [\n            'countryName' => 'UK',\n            'stateOrProvinceName' => 'Here',\n            'localityName' => 'There',\n            'organizationName' => 'PHP',\n            'organizationalUnitName' => 'PHPMailer CA',\n            'commonName' => 'PHPMailer Test CA',\n            'emailAddress' => 'phpmailer@example.com',\n        ];\n        $keyconfig = [\n            'digest_alg' => 'sha256',\n            'private_key_bits' => 2048,\n            'private_key_type' => OPENSSL_KEYTYPE_RSA,\n        ];\n        $password = 'password';\n        $cacertfile = 'cacertfile.pem';\n        $cakeyfile = 'cakeyfile.pem';\n        $certfile = 'certfile.pem';\n        $keyfile = 'keyfile.pem';\n\n        //Create a CA cert\n        //Make a new key pair\n        $capk = openssl_pkey_new($keyconfig);\n        //Create a certificate signing request\n        $csr = openssl_csr_new($cacertprops, $capk);\n        //Create a self-signed cert\n        $cert = openssl_csr_sign($csr, null, $capk, 1);\n        //Save the CA cert\n        openssl_x509_export($cert, $certout);\n        file_put_contents($cacertfile, $certout);\n        //Save the CA key\n        openssl_pkey_export($capk, $pkeyout, $password);\n        file_put_contents($cakeyfile, $pkeyout);\n\n        //Create a cert signed by our CA\n        //Make a new key pair\n        $pk = openssl_pkey_new($keyconfig);\n        //Create a certificate signing request\n        $csr = openssl_csr_new($certprops, $pk);\n        //Create a self-signed cert\n        $cacert = file_get_contents($cacertfile);\n        $cert = openssl_csr_sign($csr, $cacert, $capk, 1);\n        //Save the cert\n        openssl_x509_export($cert, $certout);\n        file_put_contents($certfile, $certout);\n        //Save the key\n        openssl_pkey_export($pk, $pkeyout, $password);\n        file_put_contents($keyfile, $pkeyout);\n\n        $this->Mail->sign(\n            $certfile,\n            $keyfile,\n            $password,\n            $cacertfile\n        );\n        self::assertTrue($this->Mail->send(), 'S/MIME signing with CA failed');\n        unlink($cacertfile);\n        unlink($cakeyfile);\n        unlink($certfile);\n        unlink($keyfile);\n    }\n\n    /**\n     * DKIM body canonicalization tests.\n     *\n     * @see https://tools.ietf.org/html/rfc6376#section-3.4.4\n     */\n    public function testDKIMBodyCanonicalization()\n    {\n        //Example from https://tools.ietf.org/html/rfc6376#section-3.4.5\n        $prebody = \" C \\r\\nD \\t E\\r\\n\\r\\n\\r\\n\";\n        $postbody = \" C \\r\\nD \\t E\\r\\n\";\n        self::assertEquals($this->Mail->DKIM_BodyC(''), \"\\r\\n\", 'DKIM empty body canonicalization incorrect');\n        self::assertEquals(\n            'frcCV1k9oG9oKj3dpUqdJg1PxRT2RSN/XKdLCPjaYaY=',\n            base64_encode(hash('sha256', $this->Mail->DKIM_BodyC(''), true)),\n            'DKIM canonicalized empty body hash mismatch'\n        );\n        self::assertEquals($this->Mail->DKIM_BodyC($prebody), $postbody, 'DKIM body canonicalization incorrect');\n    }\n\n    /**\n     * DKIM header canonicalization tests.\n     *\n     * @see https://tools.ietf.org/html/rfc6376#section-3.4.2\n     */\n    public function testDKIMHeaderCanonicalization()\n    {\n        //Example from https://tools.ietf.org/html/rfc6376#section-3.4.5\n        $preheaders = \"A: X\\r\\nB : Y\\t\\r\\n\\tZ  \\r\\n\";\n        $postheaders = \"a:X\\r\\nb:Y Z\\r\\n\";\n        self::assertEquals(\n            $postheaders,\n            $this->Mail->DKIM_HeaderC($preheaders),\n            'DKIM header canonicalization incorrect'\n        );\n        //Check that long folded lines with runs of spaces are canonicalized properly\n        $preheaders = 'Long-Header-1: <https://example.com/somescript.php?' .\n            \"id=1234567890&name=Abcdefghijklmnopquestuvwxyz&hash=\\r\\n abc1234\\r\\n\" .\n            \"Long-Header-2: This  is  a  long  header  value  that  contains  runs  of  spaces and trailing    \\r\\n\" .\n            ' and   is   folded   onto   2   lines';\n        $postheaders = 'long-header-1:<https://example.com/somescript.php?id=1234567890&' .\n            \"name=Abcdefghijklmnopquestuvwxyz&hash= abc1234\\r\\nlong-header-2:This is a long\" .\n            ' header value that contains runs of spaces and trailing and is folded onto 2 lines';\n        self::assertEquals(\n            $postheaders,\n            $this->Mail->DKIM_HeaderC($preheaders),\n            'DKIM header canonicalization of long lines incorrect'\n        );\n    }\n\n    /**\n     * DKIM copied header fields tests.\n     *\n     * @group dkim\n     *\n     * @see https://tools.ietf.org/html/rfc6376#section-3.5\n     */\n    public function testDKIMOptionalHeaderFieldsCopy()\n    {\n        $privatekeyfile = 'dkim_private.pem';\n        $pk = openssl_pkey_new(\n            [\n                'private_key_bits' => 2048,\n                'private_key_type' => OPENSSL_KEYTYPE_RSA,\n            ]\n        );\n        openssl_pkey_export_to_file($pk, $privatekeyfile);\n        $this->Mail->DKIM_private = 'dkim_private.pem';\n\n        //Example from https://tools.ietf.org/html/rfc6376#section-3.5\n        $from = 'from@example.com';\n        $to = 'to@example.com';\n        $date = 'date';\n        $subject = 'example';\n\n        $headerLines = \"From:$from\\r\\nTo:$to\\r\\nDate:$date\\r\\n\";\n        $copyHeaderFields = \" z=From:$from\\r\\n |To:$to\\r\\n |Date:$date\\r\\n |Subject:$subject;\\r\\n\";\n\n        $this->Mail->DKIM_copyHeaderFields = true;\n        self::assertStringContainsString(\n            $copyHeaderFields,\n            $this->Mail->DKIM_Add($headerLines, $subject, ''),\n            'DKIM header with copied header fields incorrect'\n        );\n\n        $this->Mail->DKIM_copyHeaderFields = false;\n        self::assertStringNotContainsString(\n            $copyHeaderFields,\n            $this->Mail->DKIM_Add($headerLines, $subject, ''),\n            'DKIM header without copied header fields incorrect'\n        );\n\n        unlink($privatekeyfile);\n    }\n\n    /**\n     * DKIM signing extra headers tests.\n     *\n     * @group dkim\n     */\n    public function testDKIMExtraHeaders()\n    {\n        $privatekeyfile = 'dkim_private.pem';\n        $pk = openssl_pkey_new(\n            [\n                'private_key_bits' => 2048,\n                'private_key_type' => OPENSSL_KEYTYPE_RSA,\n            ]\n        );\n        openssl_pkey_export_to_file($pk, $privatekeyfile);\n        $this->Mail->DKIM_private = 'dkim_private.pem';\n\n        //Example from https://tools.ietf.org/html/rfc6376#section-3.5\n        $from = 'from@example.com';\n        $to = 'to@example.com';\n        $date = 'date';\n        $subject = 'example';\n        $anyHeader = 'foo';\n        $unsubscribeUrl = '<https://www.example.com/unsubscribe/?newsletterId=anytoken&amp;actionToken=anyToken' .\n                            '&otherParam=otherValue&anotherParam=anotherVeryVeryVeryLongValue>';\n\n        $this->Mail->addCustomHeader('X-AnyHeader', $anyHeader);\n        $this->Mail->addCustomHeader('Baz', 'bar');\n        $this->Mail->addCustomHeader('List-Unsubscribe', $unsubscribeUrl);\n\n        $this->Mail->DKIM_extraHeaders = ['Baz', 'List-Unsubscribe'];\n\n        $headerLines = \"From:$from\\r\\nTo:$to\\r\\nDate:$date\\r\\n\";\n        $headerLines .= \"X-AnyHeader:$anyHeader\\r\\nBaz:bar\\r\\n\";\n        $headerLines .= 'List-Unsubscribe:' . $this->Mail->encodeHeader($unsubscribeUrl) . \"\\r\\n\";\n\n        $headerFields = 'h=From:To:Date:Baz:List-Unsubscribe:Subject';\n\n        $result = $this->Mail->DKIM_Add($headerLines, $subject, '');\n\n        self::assertStringContainsString($headerFields, $result, 'DKIM header with extra headers incorrect');\n\n        unlink($privatekeyfile);\n    }\n\n    /**\n     * DKIM Signing tests.\n     *\n     * @requires extension openssl\n     */\n    public function testDKIM()\n    {\n        $this->Mail->Subject .= ': DKIM signing';\n        $this->Mail->Body = 'This message is DKIM signed.';\n        $this->buildBody();\n        $privatekeyfile = 'dkim_private.pem';\n        //Make a new key pair\n        //(2048 bits is the recommended minimum key length -\n        //gmail won't accept less than 1024 bits)\n        $pk = openssl_pkey_new(\n            [\n                'private_key_bits' => 2048,\n                'private_key_type' => OPENSSL_KEYTYPE_RSA,\n            ]\n        );\n        openssl_pkey_export_to_file($pk, $privatekeyfile);\n        $this->Mail->DKIM_domain = 'example.com';\n        $this->Mail->DKIM_private = $privatekeyfile;\n        $this->Mail->DKIM_selector = 'phpmailer';\n        $this->Mail->DKIM_passphrase = ''; //key is not encrypted\n        self::assertTrue($this->Mail->send(), 'DKIM signed mail failed');\n        $this->Mail->isMail();\n        self::assertTrue($this->Mail->send(), 'DKIM signed mail via mail() failed');\n        unlink($privatekeyfile);\n    }\n\n    /**\n     * Test line break reformatting.\n     */\n    public function testLineBreaks()\n    {\n        //May have been altered by earlier tests, can interfere with line break format\n        $this->Mail->isSMTP();\n        $this->Mail->preSend();\n        $unixsrc = \"hello\\nWorld\\nAgain\\n\";\n        $macsrc = \"hello\\rWorld\\rAgain\\r\";\n        $windowssrc = \"hello\\r\\nWorld\\r\\nAgain\\r\\n\";\n        $mixedsrc = \"hello\\nWorld\\rAgain\\r\\n\";\n        $target = \"hello\\r\\nWorld\\r\\nAgain\\r\\n\";\n        self::assertEquals($target, PHPMailer::normalizeBreaks($unixsrc), 'UNIX break reformatting failed');\n        self::assertEquals($target, PHPMailer::normalizeBreaks($macsrc), 'Mac break reformatting failed');\n        self::assertEquals($target, PHPMailer::normalizeBreaks($windowssrc), 'Windows break reformatting failed');\n        self::assertEquals($target, PHPMailer::normalizeBreaks($mixedsrc), 'Mixed break reformatting failed');\n\n        //To see accurate results when using postfix, set `sendmail_fix_line_endings = never` in main.cf\n        $this->Mail->Subject = 'PHPMailer DOS line breaks';\n        $this->Mail->Body = \"This message\\r\\ncontains\\r\\nDOS-format\\r\\nCRLF line breaks.\";\n        self::assertTrue($this->Mail->send());\n\n        $this->Mail->Subject = 'PHPMailer UNIX line breaks';\n        $this->Mail->Body = \"This message\\ncontains\\nUNIX-format\\nLF line breaks.\";\n        self::assertTrue($this->Mail->send());\n\n        $this->Mail->Encoding = 'quoted-printable';\n        $this->Mail->Subject = 'PHPMailer DOS line breaks, QP';\n        $this->Mail->Body = \"This message\\r\\ncontains\\r\\nDOS-format\\r\\nCRLF line breaks.\";\n        self::assertTrue($this->Mail->send());\n\n        $this->Mail->Subject = 'PHPMailer UNIX line breaks, QP';\n        $this->Mail->Body = \"This message\\ncontains\\nUNIX-format\\nLF line breaks.\";\n        self::assertTrue($this->Mail->send());\n    }\n\n    /**\n     * Test line length detection.\n     */\n    public function testLineLength()\n    {\n        //May have been altered by earlier tests, can interfere with line break format\n        $this->Mail->isSMTP();\n        $this->Mail->preSend();\n        $oklen = str_repeat(str_repeat('0', PHPMailer::MAX_LINE_LENGTH) . \"\\r\\n\", 2);\n        $badlen = str_repeat(str_repeat('1', PHPMailer::MAX_LINE_LENGTH + 1) . \"\\r\\n\", 2);\n        self::assertTrue(PHPMailer::hasLineLongerThanMax($badlen), 'Long line not detected (only)');\n        self::assertTrue(PHPMailer::hasLineLongerThanMax($oklen . $badlen), 'Long line not detected (first)');\n        self::assertTrue(PHPMailer::hasLineLongerThanMax($badlen . $oklen), 'Long line not detected (last)');\n        self::assertTrue(\n            PHPMailer::hasLineLongerThanMax($oklen . $badlen . $oklen),\n            'Long line not detected (middle)'\n        );\n        self::assertFalse(PHPMailer::hasLineLongerThanMax($oklen), 'Long line false positive');\n        $this->Mail->isHTML(false);\n        $this->Mail->Subject .= ': Line length test';\n        $this->Mail->CharSet = 'UTF-8';\n        $this->Mail->Encoding = '8bit';\n        $this->Mail->Body = $oklen . $badlen . $oklen . $badlen;\n        $this->buildBody();\n        self::assertTrue($this->Mail->send(), $this->Mail->ErrorInfo);\n        self::assertEquals('quoted-printable', $this->Mail->Encoding, 'Long line did not override transfer encoding');\n    }\n\n    /**\n     * Test setting and retrieving message ID.\n     */\n    public function testMessageID()\n    {\n        $this->Mail->Body = 'Test message ID.';\n        $id = hash('sha256', 12345);\n        $this->Mail->MessageID = $id;\n        $this->buildBody();\n        $this->Mail->preSend();\n        $lastid = $this->Mail->getLastMessageID();\n        self::assertNotEquals($lastid, $id, 'Invalid Message ID allowed');\n        $id = '<' . hash('sha256', 12345) . '@example.com>';\n        $this->Mail->MessageID = $id;\n        $this->buildBody();\n        $this->Mail->preSend();\n        $lastid = $this->Mail->getLastMessageID();\n        self::assertEquals($lastid, $id, 'Custom Message ID not used');\n        $this->Mail->MessageID = '';\n        $this->buildBody();\n        $this->Mail->preSend();\n        $lastid = $this->Mail->getLastMessageID();\n        self::assertMatchesRegularExpression('/^<.*@.*>$/', $lastid, 'Invalid default Message ID');\n    }\n\n    /**\n     * Check whether setting a bad custom header throws exceptions.\n     *\n     * @throws Exception\n     */\n    public function testHeaderException()\n    {\n        $this->expectException(Exception::class);\n\n        $mail = new PHPMailer(true);\n        $mail->addCustomHeader('SomeHeader', \"Some\\n Value\");\n    }\n\n    /**\n     * Miscellaneous calls to improve test coverage and some small tests.\n     */\n    public function testMiscellaneous()\n    {\n        self::assertEquals('application/pdf', PHPMailer::_mime_types('pdf'), 'MIME TYPE lookup failed');\n        $this->Mail->clearAttachments();\n        $this->Mail->isHTML(false);\n        $this->Mail->isSMTP();\n        $this->Mail->isMail();\n        $this->Mail->isSendmail();\n        $this->Mail->isQmail();\n        $this->Mail->setLanguage('fr');\n        $this->Mail->Sender = '';\n        $this->Mail->createHeader();\n        self::assertFalse($this->Mail->set('x', 'y'), 'Invalid property set succeeded');\n        self::assertTrue($this->Mail->set('Timeout', 11), 'Valid property set failed');\n        self::assertTrue($this->Mail->set('AllowEmpty', null), 'Null property set failed');\n        self::assertTrue($this->Mail->set('AllowEmpty', false), 'Valid property set of null property failed');\n        //Test pathinfo\n        $a = '/mnt/files/\u98db\u5152\u6a02 \u5718\u5149\u832b.mp3';\n        $q = PHPMailer::mb_pathinfo($a);\n        self::assertEquals($q['dirname'], '/mnt/files', 'UNIX dirname not matched');\n        self::assertEquals($q['basename'], '\u98db\u5152\u6a02 \u5718\u5149\u832b.mp3', 'UNIX basename not matched');\n        self::assertEquals($q['extension'], 'mp3', 'UNIX extension not matched');\n        self::assertEquals($q['filename'], '\u98db\u5152\u6a02 \u5718\u5149\u832b', 'UNIX filename not matched');\n        self::assertEquals(\n            PHPMailer::mb_pathinfo($a, PATHINFO_DIRNAME),\n            '/mnt/files',\n            'Dirname path element not matched'\n        );\n        self::assertEquals(\n            PHPMailer::mb_pathinfo($a, PATHINFO_BASENAME),\n            '\u98db\u5152\u6a02 \u5718\u5149\u832b.mp3',\n            'Basename path element not matched'\n        );\n        self::assertEquals(PHPMailer::mb_pathinfo($a, 'filename'), '\u98db\u5152\u6a02 \u5718\u5149\u832b', 'Filename path element not matched');\n        $a = 'c:\\mnt\\files\\\u98db\u5152\u6a02 \u5718\u5149\u832b.mp3';\n        $q = PHPMailer::mb_pathinfo($a);\n        self::assertEquals($q['dirname'], 'c:\\mnt\\files', 'Windows dirname not matched');\n        self::assertEquals($q['basename'], '\u98db\u5152\u6a02 \u5718\u5149\u832b.mp3', 'Windows basename not matched');\n        self::assertEquals($q['extension'], 'mp3', 'Windows extension not matched');\n        self::assertEquals($q['filename'], '\u98db\u5152\u6a02 \u5718\u5149\u832b', 'Windows filename not matched');\n\n        self::assertEquals(\n            PHPMailer::filenameToType('abc.jpg?xyz=1'),\n            'image/jpeg',\n            'Query string not ignored in filename'\n        );\n        self::assertEquals(\n            PHPMailer::filenameToType('abc.xyzpdq'),\n            'application/octet-stream',\n            'Default MIME type not applied to unknown extension'\n        );\n\n        //Line break normalization\n        $eol = PHPMailer::getLE();\n        $b1 = \"1\\r2\\r3\\r\";\n        $b2 = \"1\\n2\\n3\\n\";\n        $b3 = \"1\\r\\n2\\r3\\n\";\n        $t1 = \"1{$eol}2{$eol}3{$eol}\";\n        self::assertEquals(PHPMailer::normalizeBreaks($b1), $t1, 'Failed to normalize line breaks (1)');\n        self::assertEquals(PHPMailer::normalizeBreaks($b2), $t1, 'Failed to normalize line breaks (2)');\n        self::assertEquals(PHPMailer::normalizeBreaks($b3), $t1, 'Failed to normalize line breaks (3)');\n    }\n\n    public function testBadSMTP()\n    {\n        $this->Mail->smtpConnect();\n        $smtp = $this->Mail->getSMTPInstance();\n        self::assertFalse($smtp->mail(\"somewhere\\nbad\"), 'Bad SMTP command containing breaks accepted');\n    }\n\n    public function testHostValidation()\n    {\n        $good = [\n            'localhost',\n            'example.com',\n            'smtp.gmail.com',\n            '127.0.0.1',\n            trim(str_repeat('a0123456789.', 21), '.'),\n            '[::1]',\n            '[0:1234:dc0:41:216:3eff:fe67:3e01]',\n        ];\n        $bad = [\n            null,\n            123,\n            1.5,\n            new \\stdClass(),\n            [],\n            '',\n            '999.0.0.0',\n            '[1234]',\n            '[1234:::1]',\n            trim(str_repeat('a0123456789.', 22), '.'),\n            '0:1234:dc0:41:216:3eff:fe67:3e01',\n            '[012q:1234:dc0:41:216:3eff:fe67:3e01]',\n            '[[::1]]',\n        ];\n        foreach ($good as $h) {\n            self::assertTrue(PHPMailer::isValidHost($h), 'Good hostname denied: ' . $h);\n        }\n        foreach ($bad as $h) {\n            self::assertFalse(PHPMailer::isValidHost($h), 'Bad hostname accepted: ' . var_export($h, true));\n        }\n    }\n\n    /**\n     * Tests the Custom header getter.\n     */\n    public function testCustomHeaderGetter()\n    {\n        $this->Mail->addCustomHeader('foo', 'bar');\n        self::assertEquals([['foo', 'bar']], $this->Mail->getCustomHeaders());\n\n        $this->Mail->addCustomHeader('foo', 'baz');\n        self::assertEquals(\n            [\n                ['foo', 'bar'],\n                ['foo', 'baz'],\n            ],\n            $this->Mail->getCustomHeaders()\n        );\n\n        $this->Mail->clearCustomHeaders();\n        self::assertEmpty($this->Mail->getCustomHeaders());\n\n        $this->Mail->addCustomHeader('yux');\n        self::assertEquals([['yux', '']], $this->Mail->getCustomHeaders());\n\n        $this->Mail->addCustomHeader('Content-Type: application/json');\n        self::assertEquals(\n            [\n                ['yux', ''],\n                ['Content-Type', 'application/json'],\n            ],\n            $this->Mail->getCustomHeaders()\n        );\n        $this->Mail->clearCustomHeaders();\n        $this->Mail->addCustomHeader('SomeHeader: Some Value');\n        $headers = $this->Mail->getCustomHeaders();\n        self::assertEquals($headers[0], ['SomeHeader', 'Some Value']);\n        $this->Mail->clearCustomHeaders();\n        $this->Mail->addCustomHeader('SomeHeader', 'Some Value');\n        $headers = $this->Mail->getCustomHeaders();\n        self::assertEquals($headers[0], ['SomeHeader', 'Some Value']);\n        $this->Mail->clearCustomHeaders();\n        self::assertFalse($this->Mail->addCustomHeader('SomeHeader', \"Some\\n Value\"));\n        self::assertFalse($this->Mail->addCustomHeader(\"Some\\nHeader\", 'Some Value'));\n    }\n\n    /**\n     * Tests setting and retrieving ConfirmReadingTo address, also known as \"read receipt\" address.\n     */\n    public function testConfirmReadingTo()\n    {\n        $this->Mail->CharSet = PHPMailer::CHARSET_UTF8;\n        $this->buildBody();\n\n        $this->Mail->ConfirmReadingTo = 'test@example..com';  //Invalid address\n        self::assertFalse($this->Mail->send(), $this->Mail->ErrorInfo);\n\n        $this->Mail->ConfirmReadingTo = ' test@example.com';  //Extra space to trim\n        self::assertTrue($this->Mail->send(), $this->Mail->ErrorInfo);\n        self::assertEquals(\n            'test@example.com',\n            $this->Mail->ConfirmReadingTo,\n            'Unexpected read receipt address'\n        );\n\n        $letter = html_entity_decode('&ccedil;', ENT_COMPAT, PHPMailer::CHARSET_UTF8);\n        $this->Mail->ConfirmReadingTo = 'test@fran' . $letter . 'ois.ch';  //Address with IDN\n        if (PHPMailer::idnSupported()) {\n            self::assertTrue($this->Mail->send(), $this->Mail->ErrorInfo);\n            self::assertEquals(\n                'test@xn--franois-xxa.ch',\n                $this->Mail->ConfirmReadingTo,\n                'IDN address not converted to punycode'\n            );\n        } else {\n            self::assertFalse($this->Mail->send(), $this->Mail->ErrorInfo);\n        }\n    }\n\n    /**\n     * Tests CharSet and Unicode -> ASCII conversions for addresses with IDN.\n     */\n    public function testConvertEncoding()\n    {\n        if (!PHPMailer::idnSupported()) {\n            self::markTestSkipped('intl and/or mbstring extensions are not available');\n        }\n\n        $this->Mail->clearAllRecipients();\n        $this->Mail->clearReplyTos();\n\n        //This file is UTF-8 encoded. Create a domain encoded in \"iso-8859-1\".\n        $letter = html_entity_decode('&ccedil;', ENT_COMPAT, PHPMailer::CHARSET_ISO88591);\n        $domain = '@' . 'fran' . $letter . 'ois.ch';\n        $this->Mail->addAddress('test' . $domain);\n        $this->Mail->addCC('test+cc' . $domain);\n        $this->Mail->addBCC('test+bcc' . $domain);\n        $this->Mail->addReplyTo('test+replyto' . $domain);\n\n        //Queued addresses are not returned by get*Addresses() before send() call.\n        self::assertEmpty($this->Mail->getToAddresses(), 'Bad \"to\" recipients');\n        self::assertEmpty($this->Mail->getCcAddresses(), 'Bad \"cc\" recipients');\n        self::assertEmpty($this->Mail->getBccAddresses(), 'Bad \"bcc\" recipients');\n        self::assertEmpty($this->Mail->getReplyToAddresses(), 'Bad \"reply-to\" recipients');\n\n        //Clear queued BCC recipient.\n        $this->Mail->clearBCCs();\n\n        $this->buildBody();\n        self::assertTrue($this->Mail->send(), $this->Mail->ErrorInfo);\n\n        //Addresses with IDN are returned by get*Addresses() after send() call.\n        $domain = $this->Mail->punyencodeAddress($domain);\n        self::assertEquals(\n            [['test' . $domain, '']],\n            $this->Mail->getToAddresses(),\n            'Bad \"to\" recipients'\n        );\n        self::assertEquals(\n            [['test+cc' . $domain, '']],\n            $this->Mail->getCcAddresses(),\n            'Bad \"cc\" recipients'\n        );\n        self::assertEmpty($this->Mail->getBccAddresses(), 'Bad \"bcc\" recipients');\n        self::assertEquals(\n            ['test+replyto' . $domain => ['test+replyto' . $domain, '']],\n            $this->Mail->getReplyToAddresses(),\n            'Bad \"reply-to\" addresses'\n        );\n    }\n\n    /**\n     * Tests removal of duplicate recipients and reply-tos.\n     */\n    public function testDuplicateIDNRemoved()\n    {\n        if (!PHPMailer::idnSupported()) {\n            self::markTestSkipped('intl and/or mbstring extensions are not available');\n        }\n\n        $this->Mail->clearAllRecipients();\n        $this->Mail->clearReplyTos();\n\n        $this->Mail->CharSet = PHPMailer::CHARSET_UTF8;\n\n        self::assertTrue($this->Mail->addAddress('test@fran\u00e7ois.ch'));\n        self::assertFalse($this->Mail->addAddress('test@fran\u00e7ois.ch'));\n        self::assertTrue($this->Mail->addAddress('test@FRAN\u00c7OIS.CH'));\n        self::assertFalse($this->Mail->addAddress('test@FRAN\u00c7OIS.CH'));\n        self::assertTrue($this->Mail->addAddress('test@xn--franois-xxa.ch'));\n        self::assertFalse($this->Mail->addAddress('test@xn--franois-xxa.ch'));\n        self::assertFalse($this->Mail->addAddress('test@XN--FRANOIS-XXA.CH'));\n\n        self::assertTrue($this->Mail->addReplyTo('test+replyto@fran\u00e7ois.ch'));\n        self::assertFalse($this->Mail->addReplyTo('test+replyto@fran\u00e7ois.ch'));\n        self::assertTrue($this->Mail->addReplyTo('test+replyto@FRAN\u00c7OIS.CH'));\n        self::assertFalse($this->Mail->addReplyTo('test+replyto@FRAN\u00c7OIS.CH'));\n        self::assertTrue($this->Mail->addReplyTo('test+replyto@xn--franois-xxa.ch'));\n        self::assertFalse($this->Mail->addReplyTo('test+replyto@xn--franois-xxa.ch'));\n        self::assertFalse($this->Mail->addReplyTo('test+replyto@XN--FRANOIS-XXA.CH'));\n\n        $this->buildBody();\n        self::assertTrue($this->Mail->send(), $this->Mail->ErrorInfo);\n\n        //There should be only one \"To\" address and one \"Reply-To\" address.\n        self::assertCount(\n            1,\n            $this->Mail->getToAddresses(),\n            'Bad count of \"to\" recipients'\n        );\n        self::assertCount(\n            1,\n            $this->Mail->getReplyToAddresses(),\n            'Bad count of \"reply-to\" addresses'\n        );\n    }\n\n    /**\n     * Use a fake POP3 server to test POP-before-SMTP auth with a known-good login.\n     *\n     * @group pop3\n     */\n    public function testPopBeforeSmtpGood()\n    {\n        //Start a fake POP server\n        $pid = shell_exec(\n            '/usr/bin/nohup ' .\n            $this->INCLUDE_DIR .\n            '/test/runfakepopserver.sh 1100 >/dev/null 2>/dev/null & printf \"%u\" $!'\n        );\n        $this->pids[] = $pid;\n\n        sleep(1);\n        //Test a known-good login\n        self::assertTrue(\n            POP3::popBeforeSmtp('localhost', 1100, 10, 'user', 'test', $this->Mail->SMTPDebug),\n            'POP before SMTP failed'\n        );\n        //Kill the fake server, don't care if it fails\n        @shell_exec('kill -TERM ' . escapeshellarg($pid));\n        sleep(2);\n    }\n\n    /**\n     * Use a fake POP3 server to test POP-before-SMTP auth\n     * with a known-bad login.\n     *\n     * @group pop3\n     */\n    public function testPopBeforeSmtpBad()\n    {\n        //Start a fake POP server on a different port\n        //so we don't inadvertently connect to the previous instance\n        $pid = shell_exec(\n            '/usr/bin/nohup ' .\n            $this->INCLUDE_DIR .\n            '/test/runfakepopserver.sh 1101 >/dev/null 2>/dev/null & printf \"%u\" $!'\n        );\n        $this->pids[] = $pid;\n\n        sleep(2);\n        //Test a known-bad login\n        self::assertFalse(\n            POP3::popBeforeSmtp('localhost', 1101, 10, 'user', 'xxx', $this->Mail->SMTPDebug),\n            'POP before SMTP should have failed'\n        );\n        //Kill the fake server, don't care if it fails\n        @shell_exec('kill -TERM ' . escapeshellarg($pid));\n        sleep(2);\n    }\n\n    /**\n     * Test SMTP host connections.\n     * This test can take a long time, so run it last.\n     *\n     * @group slow\n     */\n    public function testSmtpConnect()\n    {\n        $this->Mail->SMTPDebug = SMTP::DEBUG_LOWLEVEL; //Show connection-level errors\n        self::assertTrue($this->Mail->smtpConnect(), 'SMTP single connect failed');\n        $this->Mail->smtpClose();\n\n        //$this->Mail->Host = 'localhost:12345;10.10.10.10:54321;' . $_REQUEST['mail_host'];\n        //self::assertTrue($this->Mail->smtpConnect(), 'SMTP multi-connect failed');\n        //$this->Mail->smtpClose();\n        //$this->Mail->Host = '[::1]:' . $this->Mail->Port . ';' . $_REQUEST['mail_host'];\n        //self::assertTrue($this->Mail->smtpConnect(), 'SMTP IPv6 literal multi-connect failed');\n        //$this->Mail->smtpClose();\n\n        //All these hosts are expected to fail\n        //$this->Mail->Host = 'xyz://bogus:25;tls://[bogus]:25;ssl://localhost:12345;\n        //tls://localhost:587;10.10.10.10:54321;localhost:12345;10.10.10.10'. $_REQUEST['mail_host'].' ';\n        //self::assertFalse($this->Mail->smtpConnect());\n        //$this->Mail->smtpClose();\n\n        $this->Mail->Host = ' localhost:12345 ; ' . $_REQUEST['mail_host'] . ' ';\n        self::assertTrue($this->Mail->smtpConnect(), 'SMTP hosts with stray spaces failed');\n        $this->Mail->smtpClose();\n\n        //Need to pick a harmless option so as not cause problems of its own! socket:bind doesn't work with Travis-CI\n        $this->Mail->Host = $_REQUEST['mail_host'];\n        self::assertTrue($this->Mail->smtpConnect(['ssl' => ['verify_depth' => 10]]));\n\n        $this->Smtp = $this->Mail->getSMTPInstance();\n        self::assertInstanceOf(\\get_class($this->Smtp), $this->Mail->setSMTPInstance($this->Smtp));\n        self::assertFalse($this->Smtp->startTLS(), 'SMTP connect with options failed');\n        self::assertFalse($this->Mail->SMTPAuth);\n        $this->Mail->smtpClose();\n    }\n\n    /**\n     * Test OAuth method\n     */\n    public function testOAuth()\n    {\n        $PHPMailer = new PHPMailer();\n        $reflection = new \\ReflectionClass($PHPMailer);\n        $property = $reflection->getProperty('oauth');\n        $property->setAccessible(true);\n        $property->setValue($PHPMailer, true);\n        self::assertTrue($PHPMailer->getOAuth());\n\n        $options = [\n            'provider' => 'dummyprovider',\n            'userName' => 'dummyusername',\n            'clientSecret' => 'dummyclientsecret',\n            'clientId' => 'dummyclientid',\n            'refreshToken' => 'dummyrefreshtoken',\n        ];\n\n        $oauth = new OAuth($options);\n        self::assertInstanceOf(OAuth::class, $oauth);\n        $subject = $PHPMailer->setOAuth($oauth);\n        self::assertNull($subject);\n        self::assertInstanceOf(OAuth::class, $PHPMailer->getOAuth());\n    }\n\n    /**\n     * Test ICal method\n     */\n    public function testICalMethod()\n    {\n        $this->Mail->Subject .= ': ICal method';\n        $this->Mail->Body = '<h3>ICal method test.</h3>';\n        $this->Mail->AltBody = 'ICal method test.';\n        $this->Mail->Ical = 'BEGIN:VCALENDAR'\n            . \"\\r\\nVERSION:2.0\"\n            . \"\\r\\nPRODID:-//PHPMailer//PHPMailer Calendar Plugin 1.0//EN\"\n            . \"\\r\\nMETHOD:CANCEL\"\n            . \"\\r\\nCALSCALE:GREGORIAN\"\n            . \"\\r\\nX-MICROSOFT-CALSCALE:GREGORIAN\"\n            . \"\\r\\nBEGIN:VEVENT\"\n            . \"\\r\\nUID:201909250755-42825@test\"\n            . \"\\r\\nDTSTART;20190930T080000Z\"\n            . \"\\r\\nSEQUENCE:2\"\n            . \"\\r\\nTRANSP:OPAQUE\"\n            . \"\\r\\nSTATUS:CONFIRMED\"\n            . \"\\r\\nDTEND:20190930T084500Z\"\n            . \"\\r\\nLOCATION:[London] London Eye\"\n            . \"\\r\\nSUMMARY:Test ICal method\"\n            . \"\\r\\nATTENDEE;CN=Attendee, Test;ROLE=OPT-PARTICIPANT;PARTSTAT=NEEDS-ACTION;RSVP=\"\n            . \"\\r\\n TRUE:MAILTO:attendee-test@example.com\"\n            . \"\\r\\nCLASS:PUBLIC\"\n            . \"\\r\\nDESCRIPTION:Some plain text\"\n            . \"\\r\\nORGANIZER;CN=\\\"Example, Test\\\":MAILTO:test@example.com\"\n            . \"\\r\\nDTSTAMP:20190925T075546Z\"\n            . \"\\r\\nCREATED:20190925T075709Z\"\n            . \"\\r\\nLAST-MODIFIED:20190925T075546Z\"\n            . \"\\r\\nEND:VEVENT\"\n            . \"\\r\\nEND:VCALENDAR\";\n        $this->buildBody();\n        $this->Mail->preSend();\n        self::assertMatchesRegularExpression(\n            '/Content-Type: text\\/calendar; method=CANCEL;/',\n            $this->Mail->getSentMIMEMessage(),\n            'Wrong ICal method in Content-Type header'\n        );\n    }\n\n    /**\n     * Test ICal missing method to use default (REQUEST)\n     */\n    public function testICalInvalidMethod()\n    {\n        $this->Mail->Subject .= ': ICal method';\n        $this->Mail->Body = '<h3>ICal method test.</h3>';\n        $this->Mail->AltBody = 'ICal method test.';\n        $this->Mail->Ical = 'BEGIN:VCALENDAR'\n            . \"\\r\\nVERSION:2.0\"\n            . \"\\r\\nPRODID:-//PHPMailer//PHPMailer Calendar Plugin 1.0//EN\"\n            . \"\\r\\nMETHOD:INVALID\"\n            . \"\\r\\nCALSCALE:GREGORIAN\"\n            . \"\\r\\nX-MICROSOFT-CALSCALE:GREGORIAN\"\n            . \"\\r\\nBEGIN:VEVENT\"\n            . \"\\r\\nUID:201909250755-42825@test\"\n            . \"\\r\\nDTSTART;20190930T080000Z\"\n            . \"\\r\\nSEQUENCE:2\"\n            . \"\\r\\nTRANSP:OPAQUE\"\n            . \"\\r\\nSTATUS:CONFIRMED\"\n            . \"\\r\\nDTEND:20190930T084500Z\"\n            . \"\\r\\nLOCATION:[London] London Eye\"\n            . \"\\r\\nSUMMARY:Test ICal method\"\n            . \"\\r\\nATTENDEE;CN=Attendee, Test;ROLE=OPT-PARTICIPANT;PARTSTAT=NEEDS-ACTION;RSVP=\"\n            . \"\\r\\n TRUE:MAILTO:attendee-test@example.com\"\n            . \"\\r\\nCLASS:PUBLIC\"\n            . \"\\r\\nDESCRIPTION:Some plain text\"\n            . \"\\r\\nORGANIZER;CN=\\\"Example, Test\\\":MAILTO:test@example.com\"\n            . \"\\r\\nDTSTAMP:20190925T075546Z\"\n            . \"\\r\\nCREATED:20190925T075709Z\"\n            . \"\\r\\nLAST-MODIFIED:20190925T075546Z\"\n            . \"\\r\\nEND:VEVENT\"\n            . \"\\r\\nEND:VCALENDAR\";\n        $this->buildBody();\n        $this->Mail->preSend();\n        self::assertMatchesRegularExpression(\n            '/Content-Type: text\\/calendar; method=REQUEST;/',\n            $this->Mail->getSentMIMEMessage(),\n            'Wrong ICal method in Content-Type header'\n        );\n    }\n\n    /**\n     * Test ICal invalid method to use default (REQUEST)\n     */\n    public function testICalDefaultMethod()\n    {\n        $this->Mail->Subject .= ': ICal method';\n        $this->Mail->Body = '<h3>ICal method test.</h3>';\n        $this->Mail->AltBody = 'ICal method test.';\n        $this->Mail->Ical = 'BEGIN:VCALENDAR'\n            . \"\\r\\nVERSION:2.0\"\n            . \"\\r\\nPRODID:-//PHPMailer//PHPMailer Calendar Plugin 1.0//EN\"\n            . \"\\r\\nCALSCALE:GREGORIAN\"\n            . \"\\r\\nX-MICROSOFT-CALSCALE:GREGORIAN\"\n            . \"\\r\\nBEGIN:VEVENT\"\n            . \"\\r\\nUID:201909250755-42825@test\"\n            . \"\\r\\nDTSTART;20190930T080000Z\"\n            . \"\\r\\nSEQUENCE:2\"\n            . \"\\r\\nTRANSP:OPAQUE\"\n            . \"\\r\\nSTATUS:CONFIRMED\"\n            . \"\\r\\nDTEND:20190930T084500Z\"\n            . \"\\r\\nLOCATION:[London] London Eye\"\n            . \"\\r\\nSUMMARY:Test ICal method\"\n            . \"\\r\\nATTENDEE;CN=Attendee, Test;ROLE=OPT-PARTICIPANT;PARTSTAT=NEEDS-ACTION;RSVP=\"\n            . \"\\r\\n TRUE:MAILTO:attendee-test@example.com\"\n            . \"\\r\\nCLASS:PUBLIC\"\n            . \"\\r\\nDESCRIPTION:Some plain text\"\n            . \"\\r\\nORGANIZER;CN=\\\"Example, Test\\\":MAILTO:test@example.com\"\n            . \"\\r\\nDTSTAMP:20190925T075546Z\"\n            . \"\\r\\nCREATED:20190925T075709Z\"\n            . \"\\r\\nLAST-MODIFIED:20190925T075546Z\"\n            . \"\\r\\nEND:VEVENT\"\n            . \"\\r\\nEND:VCALENDAR\";\n        $this->buildBody();\n        $this->Mail->preSend();\n        self::assertMatchesRegularExpression(\n            '/Content-Type: text\\/calendar; method=REQUEST;/',\n            $this->Mail->getSentMIMEMessage(),\n            'Wrong ICal method in Content-Type header'\n        );\n    }\n\n    /**\n     * @test\n     */\n    public function givenIdnAddress_addAddress_returns_true()\n    {\n        if (file_exists($this->INCLUDE_DIR . '/test/fakefunctions.php')) {\n            include $this->INCLUDE_DIR . '/test/fakefunctions.php';\n            $this->assertTrue($this->Mail->addAddress('test@fran\u00e7ois.ch'));\n        }\n    }\n\n    /**\n     * @test\n     */\n    public function givenIdnAddress_addReplyTo_returns_true()\n    {\n        if (file_exists($this->INCLUDE_DIR . '/test/fakefunctions.php')) {\n            include $this->INCLUDE_DIR . '/test/fakefunctions.php';\n            $this->assertTrue($this->Mail->addReplyTo('test@fran\u00e7ois.ch'));\n        }\n    }\n\n    /**\n     * @test\n     */\n    public function erroneousAddress_addAddress_returns_false()\n    {\n        $this->assertFalse($this->Mail->addAddress('mehome.com'));\n    }\n\n    /**\n     * Test RFC822 address list parsing using PHPMailer's parser.\n     * @test\n     */\n    public function imapParsedAddressList_parseAddress_returnsAddressArray()\n    {\n        $addressLine = 'joe@example.com, <me@example.com>, Joe Doe <doe@example.com>,' .\n            ' \"John O\\'Groats\" <johnog@example.net>,' .\n            ' =?utf-8?B?0J3QsNC30LLQsNC90LjQtSDRgtC10YHRgtCw?= <encoded@example.org>';\n\n        //Test using PHPMailer's own parser\n        $expected = [\n            [\n                'name' => '',\n                'address' => 'joe@example.com',\n            ],\n            [\n                'name' => '',\n                'address' => 'me@example.com',\n            ],\n            [\n                'name' => 'Joe Doe',\n                'address' => 'doe@example.com',\n            ],\n            [\n                'name' => \"John O'Groats\",\n                'address' => 'johnog@example.net',\n            ],\n            [\n                'name' => '\u041d\u0430\u0437\u0432\u0430\u043d\u0438\u0435 \u0442\u0435\u0441\u0442\u0430',\n                'address' => 'encoded@example.org',\n            ],\n        ];\n        $parsed = PHPMailer::parseAddresses($addressLine, false);\n        $this->assertSameSize($expected, $parsed);\n        for ($i = 0; $i < count($expected); $i++) {\n            $this->assertSame($expected[$i], $parsed[$i]);\n        }\n    }\n\n    /**\n     * Test RFC822 address list parsing using the IMAP extension's parser.\n     * @test\n     */\n    public function imapParsedAddressList_parseAddress_returnsAddressArray_usingImap()\n    {\n        if (!extension_loaded('imap')) {\n            $this->markTestSkipped(\"imap extension missing, can't run this test\");\n        }\n        $addressLine = 'joe@example.com, <me@example.com>, Joe Doe <doe@example.com>,' .\n            ' \"John O\\'Groats\" <johnog@example.net>,' .\n            ' =?utf-8?B?0J3QsNC30LLQsNC90LjQtSDRgtC10YHRgtCw?= <encoded@example.org>';\n        $expected = [\n            [\n                'name' => '',\n                'address' => 'joe@example.com',\n            ],\n            [\n                'name' => '',\n                'address' => 'me@example.com',\n            ],\n            [\n                'name' => 'Joe Doe',\n                'address' => 'doe@example.com',\n            ],\n            [\n                'name' => \"John O'Groats\",\n                'address' => 'johnog@example.net',\n            ],\n            [\n                'name' => '\u041d\u0430\u0437\u0432\u0430\u043d\u0438\u0435 \u0442\u0435\u0441\u0442\u0430',\n                'address' => 'encoded@example.org',\n            ],\n        ];\n        $parsed = PHPMailer::parseAddresses($addressLine, true);\n        $this->assertSameSize($expected, $parsed);\n        for ($i = 0; $i < count($expected); $i++) {\n            $this->assertSame($expected[$i], $parsed[$i]);\n        }\n    }\n\n    /**\n     * @test\n     */\n    public function givenIdnAddress_punyencodeAddress_returnsCorrectCode()\n    {\n        if (file_exists($this->INCLUDE_DIR . '/test/fakefunctions.php')) {\n            include $this->INCLUDE_DIR . '/test/fakefunctions.php';\n            //This source file is in UTF-8, so characters here are in native charset\n            $this->Mail->CharSet = PHPMailer::CHARSET_UTF8;\n            $result = $this->Mail->punyencodeAddress(\n                html_entity_decode('test@fran&ccedil;ois.ch', ENT_COMPAT, PHPMailer::CHARSET_UTF8)\n            );\n            $this->assertEquals('test@xn--franois-xxa.ch', $result);\n            //To force working another charset, decode an ASCII string to avoid literal string charset issues\n            $this->Mail->CharSet = PHPMailer::CHARSET_ISO88591;\n            $result = $this->Mail->punyencodeAddress(\n                html_entity_decode('test@fran&ccedil;ois.ch', ENT_COMPAT, PHPMailer::CHARSET_ISO88591)\n            );\n            $this->assertEquals('test@xn--franois-xxa.ch', $result);\n        }\n    }\n\n    /**\n     * @test\n     */\n    public function veryLongWordInMessage_wrapText_returnsWrappedText()\n    {\n        $message = 'Lorem ipsumdolorsitametconsetetursadipscingelitrseddiamnonumy';\n        $expected = 'Lorem' . PHPMailer::getLE() .\n            'ipsumdolorsitametconsetetursadipscingelitrseddiamnonumy' . PHPMailer::getLE();\n        $expectedqp = 'Lorem ipsumdolorsitametconsetetursadipscingelitrs=' .\n            PHPMailer::getLE() . 'eddiamnonumy' . PHPMailer::getLE();\n        $this->assertEquals($this->Mail->wrapText($message, 50, true), $expectedqp);\n        $this->assertEquals($this->Mail->wrapText($message, 50, false), $expected);\n    }\n\n    /**\n     * @test\n     */\n    public function encodedText_utf8CharBoundary_returnsCorrectMaxLength()\n    {\n        $encodedWordWithMultiByteCharFirstByte = 'H=E4tten';\n        $encodedSingleByteCharacter = '=0C';\n        $encodedWordWithMultiByteCharMiddletByte = 'L=C3=B6rem';\n\n        $this->assertEquals(1, $this->Mail->utf8CharBoundary($encodedWordWithMultiByteCharFirstByte, 3));\n        $this->assertEquals(3, $this->Mail->utf8CharBoundary($encodedSingleByteCharacter, 3));\n        $this->assertEquals(1, $this->Mail->utf8CharBoundary($encodedWordWithMultiByteCharMiddletByte, 6));\n    }\n}\n/*\n * This is a sample form for setting appropriate test values through a browser\n * These values can also be set using a file called testbootstrap.php (not in repo) in the same folder as this script\n * which is probably more useful if you run these tests a lot\n * <html>\n * <body>\n * <h3>PHPMailer Unit Test</h3>\n * By entering a SMTP hostname it will automatically perform tests with SMTP.\n *\n * <form name=\"phpmailer_unit\" action=__FILE__ method=\"get\">\n * <input type=\"hidden\" name=\"submitted\" value=\"1\"/>\n * From Address: <input type=\"text\" size=\"50\" name=\"mail_from\" value=\"<?php echo get(\"mail_from\"); ?>\"/>\n * <br/>\n * To Address: <input type=\"text\" size=\"50\" name=\"mail_to\" value=\"<?php echo get(\"mail_to\"); ?>\"/>\n * <br/>\n * Cc Address: <input type=\"text\" size=\"50\" name=\"mail_cc\" value=\"<?php echo get(\"mail_cc\"); ?>\"/>\n * <br/>\n * SMTP Hostname: <input type=\"text\" size=\"50\" name=\"mail_host\" value=\"<?php echo get(\"mail_host\"); ?>\"/>\n * <p/>\n * <input type=\"submit\" value=\"Run Test\"/>\n *\n * </form>\n * </body>\n * </html>\n */\n"], "filenames": ["SECURITY.md", "src/PHPMailer.php", "test/PHPMailerTest.php"], "buggy_code_start_loc": [5, 1340, 736], "buggy_code_end_loc": [6, 1346, 743], "fixing_code_start_loc": [5, 1340, 736], "fixing_code_end_loc": [6, 1342, 744], "type": "CWE-829", "message": "PHPMailer 6.4.1 and earlier contain a vulnerability that can result in untrusted code being called (if such code is injected into the host project's scope by other means). If the $patternselect parameter to validateAddress() is set to 'php' (the default, defined by PHPMailer::$validator), and the global namespace contains a function called php, it will be called in preference to the built-in validator of the same name. Mitigated in PHPMailer 6.5.0 by denying the use of simple strings as validator function names.", "other": {"cve": {"id": "CVE-2021-3603", "sourceIdentifier": "security@huntr.dev", "published": "2021-06-17T12:15:08.150", "lastModified": "2021-09-20T17:07:52.560", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "PHPMailer 6.4.1 and earlier contain a vulnerability that can result in untrusted code being called (if such code is injected into the host project's scope by other means). If the $patternselect parameter to validateAddress() is set to 'php' (the default, defined by PHPMailer::$validator), and the global namespace contains a function called php, it will be called in preference to the built-in validator of the same name. Mitigated in PHPMailer 6.5.0 by denying the use of simple strings as validator function names."}, {"lang": "es", "value": "PHPMailer versi\u00f3n 6.4.1 y anteriores contienen una vulnerabilidad que puede resultar en la llamada de c\u00f3digo no confiable (si dicho c\u00f3digo es inyectado en el \u00e1mbito del proyecto anfitri\u00f3n por otros medios). Si el par\u00e1metro $patternselect de la funci\u00f3n validateAddress() es ajustada como \"php\" (el valor predeterminado, definido por PHPMailer::$validator), y el namespace global contiene una funci\u00f3n llamada php, \u00e9sta ser\u00e1 llamada con preferencia al validador incorporado del mismo nombre. Mitigado en PHPMailer versi\u00f3n 6.5.0 negando el uso de cadenas simples como nombres de funciones de validador"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.2, "impactScore": 5.9}, {"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.2, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-829"}]}, {"source": "security@huntr.dev", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-829"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:phpmailer_project:phpmailer:*:*:*:*:*:*:*:*", "versionEndIncluding": "6.4.1", "matchCriteriaId": "437831BD-D01F-42E9-A248-2AFEE67FB017"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:33:*:*:*:*:*:*:*", "matchCriteriaId": "E460AA51-FCDA-46B9-AE97-E6676AA5E194"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:34:*:*:*:*:*:*:*", "matchCriteriaId": "A930E247-0B43-43CB-98FF-6CE7B8189835"}]}]}], "references": [{"url": "https://github.com/PHPMailer/PHPMailer/commit/45f3c18dc6a2de1cb1bf49b9b249a9ee36a5f7f3", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/3YRMWGA4VTMXFB22KICMB7YMFZNFV3EJ/", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/FJYSOFCUBS67J3TKR74SD3C454N7VTYM/", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://www.huntr.dev/bounties/1-PHPMailer/PHPMailer/", "source": "security@huntr.dev", "tags": ["Product"]}]}, "github_commit_url": "https://github.com/PHPMailer/PHPMailer/commit/45f3c18dc6a2de1cb1bf49b9b249a9ee36a5f7f3"}}