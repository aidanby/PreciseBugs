{"buggy_code": ["/* -*- Mode: C; indent-tabs-mode: nil; c-basic-offset: 4 -*- */\n/* vim: set sw=4 sts=4 expandtab: */\n/*\n   rsvg-filter.c: Provides filters\n\n   Copyright (C) 2004 Caleb Moore\n\n   This program is free software; you can redistribute it and/or\n   modify it under the terms of the GNU Library General Public License as\n   published by the Free Software Foundation; either version 2 of the\n   License, or (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n   Library General Public License for more details.\n\n   You should have received a copy of the GNU Library General Public\n   License along with this program; if not, write to the\n   Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n   Boston, MA 02111-1307, USA.\n\n   Author: Caleb Moore <c.moore@student.unsw.edu.au>\n*/\n\n#include \"config.h\"\n\n#include \"rsvg-private.h\"\n#include \"rsvg-filter.h\"\n#include \"rsvg-styles.h\"\n#include \"rsvg-image.h\"\n#include \"rsvg-css.h\"\n#include \"rsvg-cairo-render.h\"\n\n#include <string.h>\n\n#include <math.h>\n\n\n/*************************************************************/\n/*************************************************************/\n\ntypedef struct _RsvgFilterPrimitiveOutput RsvgFilterPrimitiveOutput;\n\nstruct _RsvgFilterPrimitiveOutput {\n    cairo_surface_t *surface;\n    RsvgIRect bounds;\n};\n\ntypedef struct _RsvgFilterContext RsvgFilterContext;\n\nstruct _RsvgFilterContext {\n    gint width, height;\n    RsvgFilter *filter;\n    GHashTable *results;\n    cairo_surface_t *source_surface;\n    cairo_surface_t *bg_surface;\n    RsvgFilterPrimitiveOutput lastresult;\n    cairo_matrix_t affine;\n    cairo_matrix_t paffine;\n    int channelmap[4];\n    RsvgDrawingCtx *ctx;\n};\n\ntypedef struct _RsvgFilterPrimitive RsvgFilterPrimitive;\n\n/* We don't have real subclassing here.  If you derive something from\n * RsvgFilterPrimitive, and don't need any special code to free your\n * RsvgFilterPrimitiveFoo structure, you can just pass rsvg_filter_primitive_free\n * to rsvg_rust_cnode_new() for the destructor.  Otherwise, create a custom destructor like this:\n *\n *    static void\n *    rsvg_filter_primitive_foo_free (gpointer impl)\n *    {\n *        RsvgFilterPrimitiveFoo *foo = impl;\n *\n *        g_free (foo->my_custom_stuff);\n *        g_free (foo->more_custom_stuff);\n *        ... etc ...\n *\n *        rsvg_filter_primitive_free (impl);\n *    }\n *\n * That last call to rsvg_filter_primitive_free() will free the base RsvgFilterPrimitive's own fields,\n * and your whole structure itself, via g_free().\n */\nstruct _RsvgFilterPrimitive {\n    RsvgLength x, y, width, height;\n    gboolean x_specified;\n    gboolean y_specified;\n    gboolean width_specified;\n    gboolean height_specified;\n    GString *in;\n    GString *result;\n\n    void (*render) (RsvgNode *node, RsvgFilterPrimitive *primitive, RsvgFilterContext *ctx);\n};\n\n/*************************************************************/\n/*************************************************************/\n\nstatic void\nrsvg_filter_primitive_free (gpointer impl)\n{\n    RsvgFilterPrimitive *primitive = impl;\n\n    g_string_free (primitive->in, TRUE);\n    g_string_free (primitive->result, TRUE);\n\n    g_free (primitive);\n}\n\nstatic void\nfilter_primitive_set_x_y_width_height_atts (RsvgFilterPrimitive *prim, RsvgPropertyBag *atts)\n{\n    const char *value;\n\n    if ((value = rsvg_property_bag_lookup (atts, \"x\"))) {\n        prim->x = rsvg_length_parse (value, LENGTH_DIR_HORIZONTAL);\n        prim->x_specified = TRUE;\n    }\n    if ((value = rsvg_property_bag_lookup (atts, \"y\"))) {\n        prim->y = rsvg_length_parse (value, LENGTH_DIR_VERTICAL);\n        prim->y_specified = TRUE;\n    }\n    if ((value = rsvg_property_bag_lookup (atts, \"width\"))) {\n        prim->width = rsvg_length_parse (value, LENGTH_DIR_HORIZONTAL);\n        prim->width_specified = TRUE;\n    }\n    if ((value = rsvg_property_bag_lookup (atts, \"height\"))) {\n        prim->height = rsvg_length_parse (value, LENGTH_DIR_VERTICAL);\n        prim->height_specified = TRUE;\n    }\n}\n\nstatic void\nrsvg_filter_primitive_render (RsvgNode *node, RsvgFilterPrimitive *primitive, RsvgFilterContext *ctx)\n{\n    primitive->render (node, primitive, ctx);\n}\n\nstatic RsvgIRect\nrsvg_filter_primitive_get_bounds (RsvgFilterPrimitive * self, RsvgFilterContext * ctx)\n{\n    RsvgBbox box, otherbox;\n    cairo_matrix_t affine;\n\n    cairo_matrix_init_identity (&affine);\n    rsvg_bbox_init (&box, &affine);\n    rsvg_bbox_init (&otherbox, &ctx->affine);\n    otherbox.virgin = 0;\n    if (ctx->filter->filterunits == objectBoundingBox)\n        rsvg_drawing_ctx_push_view_box (ctx->ctx, 1., 1.);\n    otherbox.rect.x = rsvg_length_normalize (&ctx->filter->x, ctx->ctx);\n    otherbox.rect.y = rsvg_length_normalize (&ctx->filter->y, ctx->ctx);\n    otherbox.rect.width = rsvg_length_normalize (&ctx->filter->width, ctx->ctx);\n    otherbox.rect.height = rsvg_length_normalize (&ctx->filter->height, ctx->ctx);\n    if (ctx->filter->filterunits == objectBoundingBox)\n        rsvg_drawing_ctx_pop_view_box (ctx->ctx);\n\n    rsvg_bbox_insert (&box, &otherbox);\n\n    if (self != NULL) {\n        if (self->x_specified || self->y_specified || self->width_specified || self->height_specified) {\n            rsvg_bbox_init (&otherbox, &ctx->paffine);\n            otherbox.virgin = 0;\n            if (ctx->filter->primitiveunits == objectBoundingBox)\n                rsvg_drawing_ctx_push_view_box (ctx->ctx, 1., 1.);\n            if (self->x_specified)\n                otherbox.rect.x = rsvg_length_normalize (&self->x, ctx->ctx);\n            else\n                otherbox.rect.x = 0;\n            if (self->y_specified)\n                otherbox.rect.y = rsvg_length_normalize (&self->y, ctx->ctx);\n            else\n                otherbox.rect.y = 0;\n\n            if (self->width_specified || self->height_specified) {\n                double curr_vbox_w, curr_vbox_h;\n\n                rsvg_drawing_ctx_get_view_box_size (ctx->ctx, &curr_vbox_w, &curr_vbox_h);\n\n                if (self->width_specified)\n                    otherbox.rect.width = rsvg_length_normalize (&self->width, ctx->ctx);\n                else\n                    otherbox.rect.width = curr_vbox_w;\n\n                if (self->height_specified)\n                    otherbox.rect.height = rsvg_length_normalize (&self->height, ctx->ctx);\n                else\n                    otherbox.rect.height = curr_vbox_h;\n            }\n\n            if (ctx->filter->primitiveunits == objectBoundingBox)\n                rsvg_drawing_ctx_pop_view_box (ctx->ctx);\n            rsvg_bbox_clip (&box, &otherbox);\n        }\n    }\n\n    rsvg_bbox_init (&otherbox, &affine);\n    otherbox.virgin = 0;\n    otherbox.rect.x = 0;\n    otherbox.rect.y = 0;\n    otherbox.rect.width = ctx->width;\n    otherbox.rect.height = ctx->height;\n    rsvg_bbox_clip (&box, &otherbox);\n    {\n        RsvgIRect output = { box.rect.x, box.rect.y,\n            box.rect.x + box.rect.width,\n            box.rect.y + box.rect.height\n        };\n        return output;\n    }\n}\n\nstatic cairo_surface_t *\n_rsvg_image_surface_new (int width, int height)\n{\n    cairo_surface_t *surface;\n\n    surface = cairo_image_surface_create (CAIRO_FORMAT_ARGB32, width, height);\n    if (cairo_surface_status (surface) != CAIRO_STATUS_SUCCESS) {\n        cairo_surface_destroy (surface);\n        return NULL;\n    }\n\n    return surface;\n}\n\nstatic guchar\nget_interp_pixel (guchar * src, gdouble ox, gdouble oy, guchar ch, RsvgIRect boundarys,\n                  guint rowstride)\n{\n    double xmod, ymod;\n    double dist1, dist2, dist3, dist4;\n    double c, c1, c2, c3, c4;\n    double fox, foy, cox, coy;\n\n    xmod = fmod (ox, 1.0);\n    ymod = fmod (oy, 1.0);\n\n    dist1 = (1 - xmod) * (1 - ymod);\n    dist2 = (xmod) * (1 - ymod);\n    dist3 = (xmod) * (ymod);\n    dist4 = (1 - xmod) * (ymod);\n\n    fox = floor (ox);\n    foy = floor (oy);\n    cox = ceil (ox);\n    coy = ceil (oy);\n\n    if (fox <= boundarys.x0 || fox >= boundarys.x1 ||\n        foy <= boundarys.y0 || foy >= boundarys.y1)\n        c1 = 0;\n    else\n        c1 = src[(guint) foy * rowstride + (guint) fox * 4 + ch];\n\n    if (cox <= boundarys.x0 || cox >= boundarys.x1 ||\n        foy <= boundarys.y0 || foy >= boundarys.y1)\n        c2 = 0;\n    else\n        c2 = src[(guint) foy * rowstride + (guint) cox * 4 + ch];\n\n    if (cox <= boundarys.x0 || cox >= boundarys.x1 ||\n        coy <= boundarys.y0 || coy >= boundarys.y1)\n        c3 = 0;\n    else\n        c3 = src[(guint) coy * rowstride + (guint) cox * 4 + ch];\n\n    if (fox <= boundarys.x0 || fox >= boundarys.x1 ||\n        coy <= boundarys.y0 || coy >= boundarys.y1)\n        c4 = 0;\n    else\n        c4 = src[(guint) coy * rowstride + (guint) fox * 4 + ch];\n\n    c = (c1 * dist1 + c2 * dist2 + c3 * dist3 + c4 * dist4) / (dist1 + dist2 + dist3 + dist4);\n\n    return (guchar) c;\n}\n\nstatic void\nrsvg_filter_fix_coordinate_system (RsvgFilterContext * ctx, RsvgState * state, RsvgBbox *bbox)\n{\n    int x, y, height, width;\n\n    x = bbox->rect.x;\n    y = bbox->rect.y;\n    width = bbox->rect.width;\n    height = bbox->rect.height;\n\n    ctx->width = cairo_image_surface_get_width (ctx->source_surface);\n    ctx->height = cairo_image_surface_get_height (ctx->source_surface);\n\n    ctx->affine = state->affine;\n    if (ctx->filter->filterunits == objectBoundingBox) {\n        cairo_matrix_t affine;\n        cairo_matrix_init (&affine, width, 0, 0, height, x, y);\n        cairo_matrix_multiply (&ctx->affine, &affine, &ctx->affine);\n    }\n    ctx->paffine = state->affine;\n    if (ctx->filter->primitiveunits == objectBoundingBox) {\n        cairo_matrix_t affine;\n        cairo_matrix_init (&affine, width, 0, 0, height, x, y);\n        cairo_matrix_multiply (&ctx->paffine, &affine, &ctx->paffine);\n    }\n}\n\nstatic gboolean\nrectangle_intersect (gint ax, gint ay, gint awidth, gint aheight,\n                     gint bx, gint by, gint bwidth, gint bheight,\n                     gint *rx, gint *ry, gint *rwidth, gint *rheight)\n{\n    gint rx1, ry1, rx2, ry2;\n\n    rx1 = MAX (ax, bx);\n    ry1 = MAX (ay, by);\n    rx2 = MIN (ax + awidth, bx + bwidth);\n    ry2 = MIN (ay + aheight, by + bheight);\n\n    if (rx2 > rx1 && ry2 > ry1) {\n        *rx = rx1;\n        *ry = ry1;\n        *rwidth = rx2 - rx1;\n        *rheight = ry2 - ry1;\n\n        return TRUE;\n    } else {\n        *rx = *ry = *rwidth = *rheight = 0;\n\n        return FALSE;\n    }\n}\n\nstatic void\nrsvg_alpha_blt (cairo_surface_t *src,\n                gint srcx,\n                gint srcy,\n                gint srcwidth,\n                gint srcheight,\n                cairo_surface_t *dst,\n                gint dstx,\n                gint dsty)\n{\n    gint src_surf_width, src_surf_height;\n    gint dst_surf_width, dst_surf_height;\n    gint src_clipped_x, src_clipped_y, src_clipped_width, src_clipped_height;\n    gint dst_clipped_x, dst_clipped_y, dst_clipped_width, dst_clipped_height;\n    gint x, y, srcrowstride, dstrowstride, sx, sy, dx, dy;\n    guchar *src_pixels, *dst_pixels;\n\n    g_assert (cairo_image_surface_get_format (src) == CAIRO_FORMAT_ARGB32);\n    g_assert (cairo_image_surface_get_format (dst) == CAIRO_FORMAT_ARGB32);\n\n    cairo_surface_flush (src);\n\n    src_surf_width  = cairo_image_surface_get_width (src);\n    src_surf_height = cairo_image_surface_get_height (src);\n\n    dst_surf_width  = cairo_image_surface_get_width (dst);\n    dst_surf_height = cairo_image_surface_get_height (dst);\n\n    if (!rectangle_intersect (0, 0, src_surf_width, src_surf_height,\n                              srcx, srcy, srcwidth, srcheight,\n                              &src_clipped_x, &src_clipped_y, &src_clipped_width, &src_clipped_height))\n        return; /* source rectangle is not in source surface */\n\n    if (!rectangle_intersect (0, 0, dst_surf_width, dst_surf_height,\n                              dstx, dsty, src_clipped_width, src_clipped_height,\n                              &dst_clipped_x, &dst_clipped_y, &dst_clipped_width, &dst_clipped_height))\n        return; /* dest rectangle is not in dest surface */\n\n    srcrowstride = cairo_image_surface_get_stride (src);\n    dstrowstride = cairo_image_surface_get_stride (dst);\n\n    src_pixels = cairo_image_surface_get_data (src);\n    dst_pixels = cairo_image_surface_get_data (dst);\n\n    for (y = 0; y < dst_clipped_height; y++)\n        for (x = 0; x < dst_clipped_width; x++) {\n            guint a, c, ad, cd, ar, cr, i;\n\n            sx = x + src_clipped_x;\n            sy = y + src_clipped_y;\n            dx = x + dst_clipped_x;\n            dy = y + dst_clipped_y;\n            a = src_pixels[4 * sx + sy * srcrowstride + 3];\n\n            if (a) {\n                ad = dst_pixels[4 * dx + dy * dstrowstride + 3];\n                ar = a + ad * (255 - a) / 255;\n                dst_pixels[4 * dx + dy * dstrowstride + 3] = ar;\n                for (i = 0; i < 3; i++) {\n                    c = src_pixels[4 * sx + sy * srcrowstride + i];\n                    cd = dst_pixels[4 * dx + dy * dstrowstride + i];\n                    cr = c + cd * (255 - a) / 255;\n                    dst_pixels[4 * dx + dy * dstrowstride + i] = cr;\n                }\n            }\n        }\n\n    cairo_surface_mark_dirty (dst);\n}\n\nstatic gboolean\nrsvg_art_affine_image (cairo_surface_t *img,\n                       cairo_surface_t *intermediate,\n                       cairo_matrix_t *affine,\n                       double w,\n                       double h)\n{\n    cairo_matrix_t inv_affine, raw_inv_affine;\n    gint intstride;\n    gint basestride;\n    gint basex, basey;\n    gdouble fbasex, fbasey;\n    gdouble rawx, rawy;\n    guchar *intpix;\n    guchar *basepix;\n    gint i, j, k, basebpp, ii, jj;\n    gboolean has_alpha;\n    gdouble pixsum[4];\n    gboolean xrunnoff, yrunnoff;\n    gint iwidth, iheight;\n    gint width, height;\n\n    g_assert (cairo_image_surface_get_format (intermediate) == CAIRO_FORMAT_ARGB32);\n\n    cairo_surface_flush (img);\n\n    width = cairo_image_surface_get_width (img);\n    height = cairo_image_surface_get_height (img);\n    iwidth = cairo_image_surface_get_width (intermediate);\n    iheight = cairo_image_surface_get_height (intermediate);\n\n    has_alpha = cairo_image_surface_get_format (img) == CAIRO_FORMAT_ARGB32;\n\n    basestride = cairo_image_surface_get_stride (img);\n    intstride = cairo_image_surface_get_stride (intermediate);\n    basepix = cairo_image_surface_get_data (img);\n    intpix = cairo_image_surface_get_data (intermediate);\n    basebpp = has_alpha ? 4 : 3;\n\n    raw_inv_affine = *affine;\n    if (cairo_matrix_invert (&raw_inv_affine) != CAIRO_STATUS_SUCCESS)\n      return FALSE;\n\n    cairo_matrix_init_scale (&inv_affine, w, h);\n    cairo_matrix_multiply (&inv_affine, &inv_affine, affine);\n    if (cairo_matrix_invert (&inv_affine) != CAIRO_STATUS_SUCCESS)\n      return FALSE;\n\n    /*apply the transformation */\n    for (i = 0; i < iwidth; i++)\n        for (j = 0; j < iheight; j++) {\n            fbasex = (inv_affine.xx * (double) i + inv_affine.xy * (double) j +\n                      inv_affine.x0) * (double) width;\n            fbasey = (inv_affine.yx * (double) i + inv_affine.yy * (double) j +\n                      inv_affine.y0) * (double) height;\n            basex = floor (fbasex);\n            basey = floor (fbasey);\n            rawx = raw_inv_affine.xx * i + raw_inv_affine.xy * j + raw_inv_affine.x0;\n            rawy = raw_inv_affine.yx * i + raw_inv_affine.yy * j + raw_inv_affine.y0;\n            if (rawx < 0 || rawy < 0 || rawx >= w ||\n                rawy >= h || basex < 0 || basey < 0 || basex >= width || basey >= height) {\n                for (k = 0; k < 4; k++)\n                    intpix[i * 4 + j * intstride + k] = 0;\n            } else {\n                if (basex < 0 || basex + 1 >= width)\n                    xrunnoff = TRUE;\n                else\n                    xrunnoff = FALSE;\n                if (basey < 0 || basey + 1 >= height)\n                    yrunnoff = TRUE;\n                else\n                    yrunnoff = FALSE;\n                for (k = 0; k < basebpp; k++)\n                    pixsum[k] = 0;\n                for (ii = 0; ii < 2; ii++)\n                    for (jj = 0; jj < 2; jj++) {\n                        if (basex + ii < 0 || basey + jj < 0\n                            || basex + ii >= width || basey + jj >= height);\n                        else {\n                            for (k = 0; k < basebpp; k++) {\n                                pixsum[k] +=\n                                    (double) basepix[basebpp * (basex + ii) +\n                                                     (basey + jj) * basestride + k]\n                                    * (xrunnoff ? 1 : fabs (fbasex - (double) (basex + (1 - ii))))\n                                    * (yrunnoff ? 1 : fabs (fbasey - (double) (basey + (1 - jj))));\n                            }\n                        }\n                    }\n                for (k = 0; k < basebpp; k++)\n                    intpix[i * 4 + j * intstride + k] = pixsum[k];\n                if (!has_alpha)\n                    intpix[i * 4 + j * intstride + 3] = 255;\n            }\n\n        }\n\n    /* Don't need cairo_surface_mark_dirty(intermediate) here since\n     * the only caller does further work and then calls that himself.\n     */\n\n    return TRUE;\n}\n\nstatic void\nrsvg_filter_free_pair (gpointer value)\n{\n    RsvgFilterPrimitiveOutput *output;\n\n    output = (RsvgFilterPrimitiveOutput *) value;\n    cairo_surface_destroy (output->surface);\n    g_free (output);\n}\n\nstatic void\nrsvg_filter_context_free (RsvgFilterContext * ctx)\n{\n    if (!ctx)\n        return;\n\n    if (ctx->bg_surface)\n        cairo_surface_destroy (ctx->bg_surface);\n\n    g_free (ctx);\n}\n\nstatic gboolean\nnode_is_filter_primitive (RsvgNode *node)\n{\n    RsvgNodeType type = rsvg_node_get_type (node);\n\n    return type > RSVG_NODE_TYPE_FILTER_PRIMITIVE_FIRST && type < RSVG_NODE_TYPE_FILTER_PRIMITIVE_LAST;\n}\n\nstatic gboolean\nrender_child_if_filter_primitive (RsvgNode *node, gpointer data)\n{\n    RsvgFilterContext *filter_ctx = data;\n\n    if (node_is_filter_primitive (node)) {\n        RsvgFilterPrimitive *primitive;\n\n        primitive = rsvg_rust_cnode_get_impl (node);\n        rsvg_filter_primitive_render (node, primitive, filter_ctx);\n    }\n\n    return TRUE;\n}\n\n/**\n * rsvg_filter_render:\n * @node: a pointer to the filter node to use\n * @source: the a #cairo_surface_t of type %CAIRO_SURFACE_TYPE_IMAGE\n * @context: the context\n *\n * Create a new surface applied the filter. This function will create\n * a context for itself, set up the coordinate systems execute all its\n * little primatives and then clean up its own mess.\n *\n * Returns: (transfer full): a new #cairo_surface_t\n **/\ncairo_surface_t *\nrsvg_filter_render (RsvgNode *filter_node,\n                    cairo_surface_t *source,\n                    RsvgDrawingCtx *context,\n                    RsvgBbox *bounds,\n                    char *channelmap)\n{\n    RsvgFilter *filter;\n    RsvgFilterContext *ctx;\n    guint i;\n    cairo_surface_t *output;\n\n    g_return_val_if_fail (source != NULL, NULL);\n    g_return_val_if_fail (cairo_surface_get_type (source) == CAIRO_SURFACE_TYPE_IMAGE, NULL);\n\n    g_assert (rsvg_node_get_type (filter_node) == RSVG_NODE_TYPE_FILTER);\n    filter = rsvg_rust_cnode_get_impl (filter_node);\n\n    ctx = g_new0 (RsvgFilterContext, 1);\n    ctx->filter = filter;\n    ctx->source_surface = source;\n    ctx->bg_surface = NULL;\n    ctx->results = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, rsvg_filter_free_pair);\n    ctx->ctx = context;\n\n    rsvg_filter_fix_coordinate_system (ctx, rsvg_current_state (context), bounds);\n\n    ctx->lastresult.surface = cairo_surface_reference (source);\n    ctx->lastresult.bounds = rsvg_filter_primitive_get_bounds (NULL, ctx);\n\n    for (i = 0; i < 4; i++)\n        ctx->channelmap[i] = channelmap[i] - '0';\n\n    rsvg_node_foreach_child (filter_node, render_child_if_filter_primitive, ctx);\n\n    output = ctx->lastresult.surface;\n\n    g_hash_table_destroy (ctx->results);\n\n    rsvg_filter_context_free (ctx);\n\n    return output;\n}\n\n/**\n * rsvg_filter_store_result:\n * @name: The name of the result\n * @result: The pointer to the result\n * @ctx: the context that this was called in\n *\n * Puts the new result into the hash for easy finding later, also\n * Stores it as the last result\n **/\nstatic void\nrsvg_filter_store_output (GString * name, RsvgFilterPrimitiveOutput result, RsvgFilterContext * ctx)\n{\n    RsvgFilterPrimitiveOutput *store;\n\n    cairo_surface_destroy (ctx->lastresult.surface);\n\n    store = g_new0 (RsvgFilterPrimitiveOutput, 1);\n    *store = result;\n\n    if (name->str[0] != '\\0') {\n        cairo_surface_reference (result.surface);        /* increments the references for the table */\n        g_hash_table_insert (ctx->results, g_strdup (name->str), store);\n    }\n\n    cairo_surface_reference (result.surface);    /* increments the references for the last result */\n    ctx->lastresult = result;\n}\n\nstatic void\nrsvg_filter_store_result (GString * name,\n                          cairo_surface_t *surface,\n                          RsvgFilterContext * ctx)\n{\n    RsvgFilterPrimitiveOutput output;\n    output.bounds.x0 = 0;\n    output.bounds.y0 = 0;\n    output.bounds.x1 = ctx->width;\n    output.bounds.y1 = ctx->height;\n    output.surface = surface;\n\n    rsvg_filter_store_output (name, output, ctx);\n}\n\nstatic cairo_surface_t *\nsurface_get_alpha (cairo_surface_t *source,\n                   RsvgFilterContext * ctx)\n{\n    guchar *data;\n    guchar *pbdata;\n    gsize i, pbsize;\n    cairo_surface_t *surface;\n\n    if (source == NULL)\n        return NULL;\n\n    cairo_surface_flush (source);\n\n    pbsize = cairo_image_surface_get_width (source) *\n             cairo_image_surface_get_height (source);\n\n    surface = _rsvg_image_surface_new (cairo_image_surface_get_width (source),\n                                       cairo_image_surface_get_height (source));\n    if (surface == NULL)\n        return NULL;\n\n    data = cairo_image_surface_get_data (surface);\n    pbdata = cairo_image_surface_get_data (source);\n\n    /* FIXMEchpe: rewrite this into nested width, height loops */\n    for (i = 0; i < pbsize; i++)\n        data[i * 4 + ctx->channelmap[3]] = pbdata[i * 4 + ctx->channelmap[3]];\n\n    cairo_surface_mark_dirty (surface);\n    return surface;\n}\n\nstatic cairo_surface_t *\nrsvg_compile_bg (RsvgDrawingCtx * ctx)\n{\n    RsvgCairoRender *render = RSVG_CAIRO_RENDER (ctx->render);\n    cairo_surface_t *surface;\n    cairo_t *cr;\n    GList *i;\n\n    surface = _rsvg_image_surface_new (render->width, render->height);\n    if (surface == NULL)\n        return NULL;\n\n    cr = cairo_create (surface);\n\n    for (i = g_list_last (render->cr_stack); i != NULL; i = g_list_previous (i)) {\n        cairo_t *draw = i->data;\n        gboolean nest = draw != render->initial_cr;\n        cairo_set_source_surface (cr, cairo_get_target (draw),\n                                  nest ? 0 : -render->offset_x,\n                                  nest ? 0 : -render->offset_y);\n        cairo_paint (cr);\n    }\n\n    cairo_destroy (cr);\n\n    return surface;\n}\n\n/**\n * rsvg_filter_get_bg:\n *\n * Returns: (transfer none) (nullable): a #cairo_surface_t, or %NULL\n */\nstatic cairo_surface_t *\nrsvg_filter_get_bg (RsvgFilterContext * ctx)\n{\n    if (!ctx->bg_surface)\n        ctx->bg_surface = rsvg_compile_bg (ctx->ctx);\n\n    return ctx->bg_surface;\n}\n\n/* FIXMEchpe: proper return value and out param! */\n/**\n * rsvg_filter_get_result:\n * @name: The name of the surface\n * @ctx: the context that this was called in\n *\n * Gets a surface for a primitive\n *\n * Returns: (nullable): a pointer to the result that the name refers to, a special\n * surface if the name is a special keyword or %NULL if nothing was found\n **/\nstatic RsvgFilterPrimitiveOutput\nrsvg_filter_get_result (GString * name, RsvgFilterContext * ctx)\n{\n    RsvgFilterPrimitiveOutput output;\n    RsvgFilterPrimitiveOutput *outputpointer;\n    output.bounds.x0 = output.bounds.x1 = output.bounds.y0 = output.bounds.y1 = 0;\n\n    if (!strcmp (name->str, \"SourceGraphic\")) {\n        output.surface = cairo_surface_reference (ctx->source_surface);\n        return output;\n    } else if (!strcmp (name->str, \"BackgroundImage\")) {\n        output.surface = rsvg_filter_get_bg (ctx);\n        if (output.surface)\n            cairo_surface_reference (output.surface);\n        return output;\n    } else if (!strcmp (name->str, \"\") || !strcmp (name->str, \"none\")) {\n        output = ctx->lastresult;\n        cairo_surface_reference (output.surface);\n        return output;\n    } else if (!strcmp (name->str, \"SourceAlpha\")) {\n        output.surface = surface_get_alpha (ctx->source_surface, ctx);\n        return output;\n    } else if (!strcmp (name->str, \"BackgroundAlpha\")) {\n        output.surface = surface_get_alpha (rsvg_filter_get_bg (ctx), ctx);\n        return output;\n    }\n\n    outputpointer = (RsvgFilterPrimitiveOutput *) (g_hash_table_lookup (ctx->results, name->str));\n\n    if (outputpointer != NULL) {\n        output = *outputpointer;\n        cairo_surface_reference (output.surface);\n        return output;\n    }\n\n    /* g_warning (_(\"%s not found\\n\"), name->str); */\n\n    output = ctx->lastresult;\n    cairo_surface_reference (output.surface);\n    return output;\n}\n\n/**\n * rsvg_filter_get_in:\n * @name:\n * @ctx:\n *\n * Returns: (transfer full) (nullable): a new #cairo_surface_t, or %NULL\n */\nstatic cairo_surface_t *\nrsvg_filter_get_in (GString * name, RsvgFilterContext * ctx)\n{\n    return rsvg_filter_get_result (name, ctx).surface;\n}\n\nstatic void\nrsvg_filter_set_atts (RsvgNode *node, gpointer impl, RsvgHandle *handle, RsvgPropertyBag *atts)\n{\n    RsvgFilter *filter = impl;\n    const char *value;\n\n    if ((value = rsvg_property_bag_lookup (atts, \"filterUnits\"))) {\n        if (!strcmp (value, \"userSpaceOnUse\"))\n            filter->filterunits = userSpaceOnUse;\n        else\n            filter->filterunits = objectBoundingBox;\n    }\n    if ((value = rsvg_property_bag_lookup (atts, \"primitiveUnits\"))) {\n        if (!strcmp (value, \"objectBoundingBox\"))\n            filter->primitiveunits = objectBoundingBox;\n        else\n            filter->primitiveunits = userSpaceOnUse;\n    }\n    if ((value = rsvg_property_bag_lookup (atts, \"x\")))\n        filter->x = rsvg_length_parse (value, LENGTH_DIR_HORIZONTAL);\n    if ((value = rsvg_property_bag_lookup (atts, \"y\")))\n        filter->y = rsvg_length_parse (value, LENGTH_DIR_VERTICAL);\n    if ((value = rsvg_property_bag_lookup (atts, \"width\")))\n        filter->width = rsvg_length_parse (value, LENGTH_DIR_HORIZONTAL);\n    if ((value = rsvg_property_bag_lookup (atts, \"height\")))\n        filter->height = rsvg_length_parse (value, LENGTH_DIR_VERTICAL);\n}\n\nstatic void\nrsvg_filter_draw (RsvgNode *node, gpointer impl, RsvgDrawingCtx *ctx, int dominate)\n{\n    /* nothing; filters are drawn in rsvg-cairo-draw.c */\n}\n\nstatic void\nrsvg_filter_free (gpointer impl)\n{\n    RsvgFilter *filter = impl;\n\n    g_free (filter);\n}\n\n/**\n * rsvg_new_filter:\n *\n * Creates a blank filter and assigns default values to everything\n **/\nRsvgNode *\nrsvg_new_filter (const char *element_name, RsvgNode *parent)\n{\n    RsvgFilter *filter;\n\n    filter = g_new0 (RsvgFilter, 1);\n    filter->filterunits = objectBoundingBox;\n    filter->primitiveunits = userSpaceOnUse;\n    filter->x = rsvg_length_parse (\"-10%\", LENGTH_DIR_HORIZONTAL);\n    filter->y = rsvg_length_parse (\"-10%\", LENGTH_DIR_VERTICAL);\n    filter->width = rsvg_length_parse (\"120%\", LENGTH_DIR_HORIZONTAL);\n    filter->height = rsvg_length_parse (\"120%\", LENGTH_DIR_VERTICAL);\n\n    return rsvg_rust_cnode_new (RSVG_NODE_TYPE_FILTER,\n                                parent,\n                                rsvg_state_new (),\n                                filter,\n                                rsvg_filter_set_atts,\n                                rsvg_filter_draw,\n                                rsvg_filter_free);\n}\n\n/*************************************************************/\n/*************************************************************/\n\ntypedef enum {\n    normal, multiply, screen, darken, lighten, softlight,\n    hardlight, colordodge, colorburn, overlay, exclusion,\n    difference\n} RsvgFilterPrimitiveBlendMode;\n\ntypedef struct _RsvgFilterPrimitiveBlend RsvgFilterPrimitiveBlend;\nstruct _RsvgFilterPrimitiveBlend {\n    RsvgFilterPrimitive super;\n    RsvgFilterPrimitiveBlendMode mode;\n    GString *in2;\n};\n\nstatic void\nrsvg_filter_blend (RsvgFilterPrimitiveBlendMode mode,\n                   cairo_surface_t *in,\n                   cairo_surface_t *in2,\n                   cairo_surface_t* output,\n                   RsvgIRect boundarys,\n                   int *channelmap)\n{\n    guchar i;\n    gint x, y;\n    gint rowstride, rowstride2, rowstrideo, height, width;\n    guchar *in_pixels;\n    guchar *in2_pixels;\n    guchar *output_pixels;\n\n    cairo_surface_flush (in);\n    cairo_surface_flush (in2);\n\n    height = cairo_image_surface_get_height (in);\n    width = cairo_image_surface_get_width (in);\n    rowstride = cairo_image_surface_get_stride (in);\n    rowstride2 = cairo_image_surface_get_stride (in2);\n    rowstrideo = cairo_image_surface_get_stride (output);\n\n    output_pixels = cairo_image_surface_get_data (output);\n    in_pixels = cairo_image_surface_get_data (in);\n    in2_pixels = cairo_image_surface_get_data (in2);\n\n    if (boundarys.x0 < 0)\n        boundarys.x0 = 0;\n    if (boundarys.y0 < 0)\n        boundarys.y0 = 0;\n    if (boundarys.x1 >= width)\n        boundarys.x1 = width;\n    if (boundarys.y1 >= height)\n        boundarys.y1 = height;\n\n    for (y = boundarys.y0; y < boundarys.y1; y++)\n        for (x = boundarys.x0; x < boundarys.x1; x++) {\n            double qr, cr, qa, qb, ca, cb, bca, bcb;\n            int ch;\n\n            qa = (double) in_pixels[4 * x + y * rowstride + channelmap[3]] / 255.0;\n            qb = (double) in2_pixels[4 * x + y * rowstride2 + channelmap[3]] / 255.0;\n            qr = 1 - (1 - qa) * (1 - qb);\n            cr = 0;\n            for (ch = 0; ch < 3; ch++) {\n                i = channelmap[ch];\n                ca = (double) in_pixels[4 * x + y * rowstride + i] / 255.0;\n                cb = (double) in2_pixels[4 * x + y * rowstride2 + i] / 255.0;\n                /*these are the ca and cb that are used in the non-standard blend functions */\n                bcb = (1 - qa) * cb + ca;\n                bca = (1 - qb) * ca + cb;\n                switch (mode) {\n                case normal:\n                    cr = (1 - qa) * cb + ca;\n                    break;\n                case multiply:\n                    cr = (1 - qa) * cb + (1 - qb) * ca + ca * cb;\n                    break;\n                case screen:\n                    cr = cb + ca - ca * cb;\n                    break;\n                case darken:\n                    cr = MIN ((1 - qa) * cb + ca, (1 - qb) * ca + cb);\n                    break;\n                case lighten:\n                    cr = MAX ((1 - qa) * cb + ca, (1 - qb) * ca + cb);\n                    break;\n                case softlight:\n                    if (bcb < 0.5)\n                        cr = 2 * bca * bcb + bca * bca * (1 - 2 * bcb);\n                    else\n                        cr = sqrt (bca) * (2 * bcb - 1) + (2 * bca) * (1 - bcb);\n                    break;\n                case hardlight:\n                    if (cb < 0.5)\n                        cr = 2 * bca * bcb;\n                    else\n                        cr = 1 - 2 * (1 - bca) * (1 - bcb);\n                    break;\n                case colordodge:\n                    if (bcb == 1)\n                        cr = 1;\n                    else\n                        cr = MIN (bca / (1 - bcb), 1);\n                    break;\n                case colorburn:\n                    if (bcb == 0)\n                        cr = 0;\n                    else\n                        cr = MAX (1 - (1 - bca) / bcb, 0);\n                    break;\n                case overlay:\n                    if (bca < 0.5)\n                        cr = 2 * bca * bcb;\n                    else\n                        cr = 1 - 2 * (1 - bca) * (1 - bcb);\n                    break;\n                case exclusion:\n                    cr = bca + bcb - 2 * bca * bcb;\n                    break;\n                case difference:\n                    cr = abs (bca - bcb);\n                    break;\n                }\n                cr *= 255.0;\n                if (cr > 255)\n                    cr = 255;\n                if (cr < 0)\n                    cr = 0;\n                output_pixels[4 * x + y * rowstrideo + i] = (guchar) cr;\n\n            }\n            output_pixels[4 * x + y * rowstrideo + channelmap[3]] = qr * 255.0;\n        }\n\n    cairo_surface_mark_dirty (output);\n}\n\nstatic void\nrsvg_filter_primitive_blend_render (RsvgNode *node, RsvgFilterPrimitive *primitive, RsvgFilterContext *ctx)\n{\n    RsvgFilterPrimitiveBlend *blend = (RsvgFilterPrimitiveBlend *) primitive;\n    RsvgIRect boundarys;\n    cairo_surface_t *output, *in, *in2;\n\n    boundarys = rsvg_filter_primitive_get_bounds (primitive, ctx);\n\n    in = rsvg_filter_get_in (primitive->in, ctx);\n    if (in == NULL)\n      return;\n\n    in2 = rsvg_filter_get_in (blend->in2, ctx);\n    if (in2 == NULL) {\n        cairo_surface_destroy (in);\n        return;\n    }\n\n    output = _rsvg_image_surface_new (cairo_image_surface_get_width (in),\n                                      cairo_image_surface_get_height (in));\n    if (output == NULL) {\n        cairo_surface_destroy (in);\n        cairo_surface_destroy (in2);\n        return;\n    }\n\n    rsvg_filter_blend (blend->mode, in, in2, output, boundarys, ctx->channelmap);\n\n    rsvg_filter_store_result (primitive->result, output, ctx);\n\n    cairo_surface_destroy (in);\n    cairo_surface_destroy (in2);\n    cairo_surface_destroy (output);\n}\n\nstatic void\nrsvg_filter_primitive_blend_free (gpointer impl)\n{\n    RsvgFilterPrimitiveBlend *blend = impl;\n\n    g_string_free (blend->in2, TRUE);\n\n    rsvg_filter_primitive_free (impl);\n}\n\nstatic void\nrsvg_filter_primitive_blend_set_atts (RsvgNode *node, gpointer impl, RsvgHandle *handle, RsvgPropertyBag *atts)\n{\n    RsvgFilterPrimitiveBlend *filter = impl;\n    const char *value;\n\n    if ((value = rsvg_property_bag_lookup (atts, \"mode\"))) {\n        if (!strcmp (value, \"multiply\"))\n            filter->mode = multiply;\n        else if (!strcmp (value, \"screen\"))\n            filter->mode = screen;\n        else if (!strcmp (value, \"darken\"))\n            filter->mode = darken;\n        else if (!strcmp (value, \"lighten\"))\n            filter->mode = lighten;\n        else\n            filter->mode = normal;\n    }\n    if ((value = rsvg_property_bag_lookup (atts, \"in\")))\n        g_string_assign (filter->super.in, value);\n    if ((value = rsvg_property_bag_lookup (atts, \"in2\")))\n        g_string_assign (filter->in2, value);\n    if ((value = rsvg_property_bag_lookup (atts, \"result\")))\n        g_string_assign (filter->super.result, value);\n\n    filter_primitive_set_x_y_width_height_atts ((RsvgFilterPrimitive *) filter, atts);\n}\n\nRsvgNode *\nrsvg_new_filter_primitive_blend (const char *element_name, RsvgNode *parent)\n{\n    RsvgFilterPrimitiveBlend *filter;\n\n    filter = g_new0 (RsvgFilterPrimitiveBlend, 1);\n    filter->mode = normal;\n    filter->super.in = g_string_new (\"none\");\n    filter->in2 = g_string_new (\"none\");\n    filter->super.result = g_string_new (\"none\");\n    filter->super.render = rsvg_filter_primitive_blend_render;\n\n    return rsvg_rust_cnode_new (RSVG_NODE_TYPE_FILTER_PRIMITIVE_BLEND,\n                                parent,\n                                rsvg_state_new (),\n                                filter,\n                                rsvg_filter_primitive_blend_set_atts,\n                                rsvg_filter_draw,\n                                rsvg_filter_primitive_blend_free);\n}\n\n/*************************************************************/\n/*************************************************************/\n\ntypedef struct _RsvgFilterPrimitiveConvolveMatrix RsvgFilterPrimitiveConvolveMatrix;\n\ntypedef enum {\n    EDGE_MODE_DUPLICATE,\n    EDGE_MODE_WRAP,\n    EDGE_MODE_NONE\n} EdgeMode;\n\nstruct _RsvgFilterPrimitiveConvolveMatrix {\n    RsvgFilterPrimitive super;\n    double *KernelMatrix;\n    double divisor;\n    gint orderx, ordery;\n    double dx, dy;\n    double bias;\n    gint targetx, targety;\n    gboolean preservealpha;\n    EdgeMode edgemode;\n};\n\nstatic void\nrsvg_filter_primitive_convolve_matrix_render (RsvgNode *node, RsvgFilterPrimitive *primitive, RsvgFilterContext *ctx)\n{\n    RsvgFilterPrimitiveConvolveMatrix *convolve = (RsvgFilterPrimitiveConvolveMatrix *) primitive;\n\n    guchar ch;\n    gint x, y;\n    gint i, j;\n    gint rowstride, height, width;\n    RsvgIRect boundarys;\n\n    guchar *in_pixels;\n    guchar *output_pixels;\n\n    cairo_surface_t *output, *in;\n\n    gint sx, sy, kx, ky;\n    guchar sval;\n    double kval, sum, dx, dy, targetx, targety;\n    int umch;\n\n    gint tempresult;\n\n    boundarys = rsvg_filter_primitive_get_bounds (primitive, ctx);\n\n    in = rsvg_filter_get_in (primitive->in, ctx);\n    if (in == NULL)\n        return;\n\n    cairo_surface_flush (in);\n\n    in_pixels = cairo_image_surface_get_data (in);\n\n    height = cairo_image_surface_get_height (in);\n    width = cairo_image_surface_get_width (in);\n\n    targetx = convolve->targetx * ctx->paffine.xx;\n    targety = convolve->targety * ctx->paffine.yy;\n\n    if (convolve->dx != 0 || convolve->dy != 0) {\n        dx = convolve->dx * ctx->paffine.xx;\n        dy = convolve->dy * ctx->paffine.yy;\n    } else\n        dx = dy = 1;\n\n    rowstride = cairo_image_surface_get_stride (in);\n\n    output = _rsvg_image_surface_new (width, height);\n    if (output == NULL) {\n        cairo_surface_destroy (in);\n        return;\n    }\n\n    output_pixels = cairo_image_surface_get_data (output);\n\n    for (y = boundarys.y0; y < boundarys.y1; y++) {\n        for (x = boundarys.x0; x < boundarys.x1; x++) {\n            for (umch = 0; umch < 3 + !convolve->preservealpha; umch++) {\n                ch = ctx->channelmap[umch];\n                sum = 0;\n                for (i = 0; i < convolve->ordery; i++) {\n                    for (j = 0; j < convolve->orderx; j++) {\n                        int alpha;\n                        sx = x - targetx + j * dx;\n                        sy = y - targety + i * dy;\n                        if (convolve->edgemode == EDGE_MODE_DUPLICATE) {\n                            if (sx < boundarys.x0)\n                                sx = boundarys.x0;\n                            if (sx >= boundarys.x1)\n                                sx = boundarys.x1 - 1;\n                            if (sy < boundarys.y0)\n                                sy = boundarys.y0;\n                            if (sy >= boundarys.y1)\n                                sy = boundarys.y1 - 1;\n                        } else if (convolve->edgemode == EDGE_MODE_WRAP) {\n                            if (sx < boundarys.x0 || (sx >= boundarys.x1))\n                                sx = boundarys.x0 + (sx - boundarys.x0) %\n                                    (boundarys.x1 - boundarys.x0);\n                            if (sy < boundarys.y0 || (sy >= boundarys.y1))\n                                sy = boundarys.y0 + (sy - boundarys.y0) %\n                                    (boundarys.y1 - boundarys.y0);\n                        } else if (convolve->edgemode == EDGE_MODE_NONE) {\n                            if (sx < boundarys.x0 || (sx >= boundarys.x1) ||\n                                sy < boundarys.y0 || (sy >= boundarys.y1))\n                                continue;\n                        } else {\n                            g_assert_not_reached ();\n                        }\n\n                        kx = convolve->orderx - j - 1;\n                        ky = convolve->ordery - i - 1;\n                        alpha = in_pixels[4 * sx + sy * rowstride + 3];\n                        if (ch == 3)\n                            sval = alpha;\n                        else if (alpha)\n                            sval = in_pixels[4 * sx + sy * rowstride + ch] * 255 / alpha;\n                        else\n                            sval = 0;\n                        kval = convolve->KernelMatrix[kx + ky * convolve->orderx];\n                        sum += (double) sval *kval;\n                    }\n                }\n\n                tempresult = sum / convolve->divisor + convolve->bias;\n\n                if (tempresult > 255)\n                    tempresult = 255;\n                if (tempresult < 0)\n                    tempresult = 0;\n\n                output_pixels[4 * x + y * rowstride + ch] = tempresult;\n            }\n            if (convolve->preservealpha)\n                output_pixels[4 * x + y * rowstride + ctx->channelmap[3]] =\n                    in_pixels[4 * x + y * rowstride + ctx->channelmap[3]];\n            for (umch = 0; umch < 3; umch++) {\n                ch = ctx->channelmap[umch];\n                output_pixels[4 * x + y * rowstride + ch] =\n                    output_pixels[4 * x + y * rowstride + ch] *\n                    output_pixels[4 * x + y * rowstride + ctx->channelmap[3]] / 255;\n            }\n        }\n    }\n\n    cairo_surface_mark_dirty (output);\n\n    rsvg_filter_store_result (primitive->result, output, ctx);\n\n    cairo_surface_destroy (in);\n    cairo_surface_destroy (output);\n}\n\nstatic void\nrsvg_filter_primitive_convolve_matrix_free (gpointer impl)\n{\n    RsvgFilterPrimitiveConvolveMatrix *convolve = impl;\n\n    g_free (convolve->KernelMatrix);\n\n    rsvg_filter_primitive_free (impl);\n}\n\nstatic void\nrsvg_filter_primitive_convolve_matrix_set_atts (RsvgNode *node, gpointer impl, RsvgHandle *handle, RsvgPropertyBag *atts)\n{\n    RsvgFilterPrimitiveConvolveMatrix *filter = impl;\n    gint i, j;\n    const char *value;\n    gboolean has_target_x, has_target_y;\n\n    has_target_x = 0;\n    has_target_y = 0;\n\n    if ((value = rsvg_property_bag_lookup (atts, \"in\")))\n        g_string_assign (filter->super.in, value);\n    if ((value = rsvg_property_bag_lookup (atts, \"result\")))\n        g_string_assign (filter->super.result, value);\n\n    filter_primitive_set_x_y_width_height_atts ((RsvgFilterPrimitive *) filter, atts);\n\n    if ((value = rsvg_property_bag_lookup (atts, \"targetX\"))) {\n        has_target_x = 1;\n        filter->targetx = atoi (value);\n    }\n    if ((value = rsvg_property_bag_lookup (atts, \"targetY\"))) {\n        has_target_y = 1;\n        filter->targety = atoi (value);\n    }\n    if ((value = rsvg_property_bag_lookup (atts, \"bias\")))\n        filter->bias = atof (value);\n    if ((value = rsvg_property_bag_lookup (atts, \"preserveAlpha\"))) {\n        if (!strcmp (value, \"true\"))\n            filter->preservealpha = TRUE;\n        else\n            filter->preservealpha = FALSE;\n    }\n    if ((value = rsvg_property_bag_lookup (atts, \"divisor\")))\n        filter->divisor = atof (value);\n\n    if ((value = rsvg_property_bag_lookup (atts, \"order\"))) {\n        double tempx, tempy;\n        if (rsvg_css_parse_number_optional_number (value, &tempx, &tempy)\n            && tempx >= 1.0 && tempy <= 100.0\n            && tempy >= 1.0 && tempy <= 100.0) {\n            filter->orderx = (int) tempx;\n            filter->ordery = (int) tempy;\n            g_assert (filter->orderx >= 1);\n            g_assert (filter->ordery >= 1);\n\n#define SIZE_OVERFLOWS(a,b) (G_UNLIKELY ((b) > 0 && (a) > G_MAXSIZE / (b)))\n\n            if (SIZE_OVERFLOWS (filter->orderx, filter->ordery)) {\n                rsvg_node_set_attribute_parse_error (node, \"order\", \"number of kernelMatrix elements would be too big\");\n                return;\n            }\n        } else {\n            rsvg_node_set_attribute_parse_error (node, \"order\", \"invalid size for convolve matrix\");\n            return;\n        }\n    }\n\n    if ((value = rsvg_property_bag_lookup (atts, \"kernelUnitLength\"))) {\n        if (!rsvg_css_parse_number_optional_number (value, &filter->dx, &filter->dy)) {\n            rsvg_node_set_attribute_parse_error (node, \"kernelUnitLength\", \"expected number-optional-number\");\n            return;\n        }\n    }\n\n    if ((value = rsvg_property_bag_lookup (atts, \"kernelMatrix\"))) {\n        gsize num_elems;\n        gsize got_num_elems;\n\n        num_elems = filter->orderx * filter->ordery;\n\n        if (!rsvg_css_parse_number_list (value,\n                                         NUMBER_LIST_LENGTH_EXACT,\n                                         num_elems,\n                                         &filter->KernelMatrix,\n                                         &got_num_elems)) {\n            rsvg_node_set_attribute_parse_error (node, \"kernelMatrix\", \"expected a matrix of numbers\");\n            return;\n        }\n\n        g_assert (num_elems == got_num_elems);\n    }\n\n    if ((value = rsvg_property_bag_lookup (atts, \"edgeMode\"))) {\n        if (!strcmp (value, \"duplicate\")) {\n            filter->edgemode = EDGE_MODE_DUPLICATE;\n        } else if (!strcmp (value, \"wrap\")) {\n            filter->edgemode = EDGE_MODE_WRAP;\n        } else if (!strcmp (value, \"none\")) {\n            filter->edgemode = EDGE_MODE_NONE;\n        } else {\n            rsvg_node_set_attribute_parse_error (node, \"edgeMode\", \"expected 'duplicate' | 'wrap' | 'none'\");\n            return;\n        }\n    }\n\n    if (filter->divisor == 0) {\n        for (j = 0; j < filter->orderx; j++)\n            for (i = 0; i < filter->ordery; i++)\n                filter->divisor += filter->KernelMatrix[j + i * filter->orderx];\n    }\n\n    if (filter->divisor == 0)\n        filter->divisor = 1;\n\n    if (!has_target_x) {\n        filter->targetx = floor (filter->orderx / 2);\n    }\n    if (!has_target_y) {\n        filter->targety = floor (filter->ordery / 2);\n    }\n}\n\nRsvgNode *\nrsvg_new_filter_primitive_convolve_matrix (const char *element_name, RsvgNode *parent)\n{\n    RsvgFilterPrimitiveConvolveMatrix *filter;\n\n    filter = g_new0 (RsvgFilterPrimitiveConvolveMatrix, 1);\n    filter->super.in = g_string_new (\"none\");\n    filter->super.result = g_string_new (\"none\");\n    filter->KernelMatrix = NULL;\n    filter->divisor = 0;\n    filter->bias = 0;\n    filter->dx = 0;\n    filter->dy = 0;\n    filter->preservealpha = FALSE;\n    filter->edgemode = EDGE_MODE_DUPLICATE;\n    filter->super.render = rsvg_filter_primitive_convolve_matrix_render;\n\n    return rsvg_rust_cnode_new (RSVG_NODE_TYPE_FILTER_PRIMITIVE_CONVOLVE_MATRIX,\n                                parent,\n                                rsvg_state_new (),\n                                filter,\n                                rsvg_filter_primitive_convolve_matrix_set_atts,\n                                rsvg_filter_draw,\n                                rsvg_filter_primitive_convolve_matrix_free);\n}\n\n/*************************************************************/\n/*************************************************************/\n\ntypedef struct _RsvgFilterPrimitiveGaussianBlur\n RsvgFilterPrimitiveGaussianBlur;\n\nstruct _RsvgFilterPrimitiveGaussianBlur {\n    RsvgFilterPrimitive super;\n    double sdx, sdy;\n};\n\nstatic void\nbox_blur_line (gint box_width, gint even_offset,\n               guchar *src, guchar *dest,\n               gint len, gint bpp)\n{\n    gint  i;\n    gint  lead;    /* This marks the leading edge of the kernel              */\n    gint  output;  /* This marks the center of the kernel                    */\n    gint  trail;   /* This marks the pixel BEHIND the last 1 in the\n                      kernel; it's the pixel to remove from the accumulator. */\n    gint  *ac;     /* Accumulator for each channel                           */\n\n    ac = g_new0 (gint, bpp);\n\n    /* The algorithm differs for even and odd-sized kernels.\n     * With the output at the center,\n     * If odd, the kernel might look like this: 0011100\n     * If even, the kernel will either be centered on the boundary between\n     * the output and its left neighbor, or on the boundary between the\n     * output and its right neighbor, depending on even_lr.\n     * So it might be 0111100 or 0011110, where output is on the center\n     * of these arrays.\n     */\n    lead = 0;\n\n    if (box_width % 2 != 0) {\n        /* Odd-width kernel */\n        output = lead - (box_width - 1) / 2;\n        trail  = lead - box_width;\n    } else {\n        /* Even-width kernel. */\n        if (even_offset == 1) {\n            /* Right offset */\n            output = lead + 1 - box_width / 2;\n            trail  = lead - box_width;\n        } else if (even_offset == -1) {\n            /* Left offset */\n            output = lead - box_width / 2;\n            trail  = lead - box_width;\n        } else {\n            /* If even_offset isn't 1 or -1, there's some error. */\n            g_assert_not_reached ();\n        }\n    }\n\n    /* Initialize accumulator */\n    for (i = 0; i < bpp; i++)\n        ac[i] = 0;\n\n    /* As the kernel moves across the image, it has a leading edge and a\n     * trailing edge, and the output is in the middle. */\n    while (output < len) {\n        /* The number of pixels that are both in the image and\n         * currently covered by the kernel. This is necessary to\n         * handle edge cases. */\n        guint coverage = (lead < len ? lead : len - 1) - (trail >= 0 ? trail : -1);\n\n#ifdef READABLE_BOXBLUR_CODE\n/* The code here does the same as the code below, but the code below\n * has been optimized by moving the if statements out of the tight for\n * loop, and is harder to understand.\n * Don't use both this code and the code below. */\n        for (i = 0; i < bpp; i++) {\n            /* If the leading edge of the kernel is still on the image,\n             * add the value there to the accumulator. */\n            if (lead < len)\n                ac[i] += src[bpp * lead + i];\n\n            /* If the trailing edge of the kernel is on the image,\n             * subtract the value there from the accumulator. */\n            if (trail >= 0)\n                ac[i] -= src[bpp * trail + i];\n\n            /* Take the averaged value in the accumulator and store\n             * that value in the output. The number of pixels currently\n             * stored in the accumulator can be less than the nominal\n             * width of the kernel because the kernel can go \"over the edge\"\n             * of the image. */\n            if (output >= 0)\n                dest[bpp * output + i] = (ac[i] + (coverage >> 1)) / coverage;\n        }\n#endif\n\n        /* If the leading edge of the kernel is still on the image... */\n        if (lead < len) {\n            if (trail >= 0) {\n                /* If the trailing edge of the kernel is on the image. (Since\n                 * the output is in between the lead and trail, it must be on\n                 * the image. */\n                for (i = 0; i < bpp; i++) {\n                    ac[i] += src[bpp * lead + i];\n                    ac[i] -= src[bpp * trail + i];\n                    dest[bpp * output + i] = (ac[i] + (coverage >> 1)) / coverage;\n                }\n            } else if (output >= 0) {\n                /* If the output is on the image, but the trailing edge isn't yet\n                 * on the image. */\n\n                for (i = 0; i < bpp; i++) {\n                    ac[i] += src[bpp * lead + i];\n                    dest[bpp * output + i] = (ac[i] + (coverage >> 1)) / coverage;\n                }\n            } else {\n                /* If leading edge is on the image, but the output and trailing\n                 * edge aren't yet on the image. */\n                for (i = 0; i < bpp; i++)\n                    ac[i] += src[bpp * lead + i];\n            }\n        } else if (trail >= 0) {\n            /* If the leading edge has gone off the image, but the output and\n             * trailing edge are on the image. (The big loop exits when the\n             * output goes off the image. */\n            for (i = 0; i < bpp; i++) {\n                ac[i] -= src[bpp * trail + i];\n                dest[bpp * output + i] = (ac[i] + (coverage >> 1)) / coverage;\n            }\n        } else if (output >= 0) {\n            /* Leading has gone off the image and trailing isn't yet in it\n             * (small image) */\n            for (i = 0; i < bpp; i++)\n                dest[bpp * output + i] = (ac[i] + (coverage >> 1)) / coverage;\n        }\n\n        lead++;\n        output++;\n        trail++;\n    }\n\n    g_free (ac);\n}\n\nstatic gint\ncompute_box_blur_width (double radius)\n{\n    double width;\n\n    width = radius * 3 * sqrt (2 * G_PI) / 4;\n    return (gint) (width + 0.5);\n}\n\n#define SQR(x) ((x) * (x))\n\nstatic void\nmake_gaussian_convolution_matrix (gdouble radius, gdouble **out_matrix, gint *out_matrix_len)\n{\n    gdouble *matrix;\n    gdouble std_dev;\n    gdouble sum;\n    gint matrix_len;\n    gint i, j;\n\n    std_dev = radius + 1.0;\n    radius = std_dev * 2;\n\n    matrix_len = 2 * ceil (radius - 0.5) + 1;\n    if (matrix_len <= 0)\n        matrix_len = 1;\n\n    matrix = g_new0 (gdouble, matrix_len);\n\n    /* Fill the matrix by doing numerical integration approximation\n     * from -2*std_dev to 2*std_dev, sampling 50 points per pixel.\n     * We do the bottom half, mirror it to the top half, then compute the\n     * center point.  Otherwise asymmetric quantization errors will occur.\n     * The formula to integrate is e^-(x^2/2s^2).\n     */\n\n    for (i = matrix_len / 2 + 1; i < matrix_len; i++)\n    {\n        gdouble base_x = i - (matrix_len / 2) - 0.5;\n\n        sum = 0;\n        for (j = 1; j <= 50; j++)\n        {\n            gdouble r = base_x + 0.02 * j;\n\n            if (r <= radius)\n                sum += exp (- SQR (r) / (2 * SQR (std_dev)));\n        }\n\n        matrix[i] = sum / 50;\n    }\n\n    /* mirror to the bottom half */\n    for (i = 0; i <= matrix_len / 2; i++)\n        matrix[i] = matrix[matrix_len - 1 - i];\n\n    /* find center val -- calculate an odd number of quanta to make it\n     * symmetric, even if the center point is weighted slightly higher\n     * than others.\n     */\n    sum = 0;\n    for (j = 0; j <= 50; j++)\n        sum += exp (- SQR (- 0.5 + 0.02 * j) / (2 * SQR (std_dev)));\n\n    matrix[matrix_len / 2] = sum / 51;\n\n    /* normalize the distribution by scaling the total sum to one */\n    sum = 0;\n    for (i = 0; i < matrix_len; i++)\n        sum += matrix[i];\n\n    for (i = 0; i < matrix_len; i++)\n        matrix[i] = matrix[i] / sum;\n\n    *out_matrix = matrix;\n    *out_matrix_len = matrix_len;\n}\n\nstatic void\ngaussian_blur_line (gdouble *matrix,\n                    gint matrix_len,\n                    guchar *src,\n                    guchar *dest,\n                    gint len,\n                    gint bpp)\n{\n    guchar *src_p;\n    guchar *src_p1;\n    gint matrix_middle;\n    gint row;\n    gint i, j;\n\n    matrix_middle = matrix_len / 2;\n\n    /* picture smaller than the matrix? */\n    if (matrix_len > len) {\n        for (row = 0; row < len; row++) {\n            /* find the scale factor */\n            gdouble scale = 0;\n\n            for (j = 0; j < len; j++) {\n                /* if the index is in bounds, add it to the scale counter */\n                if (j + matrix_middle - row >= 0 &&\n                    j + matrix_middle - row < matrix_len)\n                    scale += matrix[j];\n            }\n\n            src_p = src;\n\n            for (i = 0; i < bpp; i++) {\n                gdouble sum = 0;\n\n                src_p1 = src_p++;\n\n                for (j = 0; j < len; j++) {\n                    if (j + matrix_middle - row >= 0 &&\n                        j + matrix_middle - row < matrix_len)\n                        sum += *src_p1 * matrix[j];\n\n                    src_p1 += bpp;\n                }\n\n                *dest++ = (guchar) (sum / scale + 0.5);\n            }\n        }\n    } else {\n        /* left edge */\n\n        for (row = 0; row < matrix_middle; row++) {\n            /* find scale factor */\n            gdouble scale = 0;\n\n            for (j = matrix_middle - row; j < matrix_len; j++)\n                scale += matrix[j];\n\n            src_p = src;\n\n            for (i = 0; i < bpp; i++) {\n                gdouble sum = 0;\n\n                src_p1 = src_p++;\n\n                for (j = matrix_middle - row; j < matrix_len; j++) {\n                    sum += *src_p1 * matrix[j];\n                    src_p1 += bpp;\n                }\n\n                *dest++ = (guchar) (sum / scale + 0.5);\n            }\n        }\n\n        /* go through each pixel in each col */\n        for (; row < len - matrix_middle; row++) {\n            src_p = src + (row - matrix_middle) * bpp;\n\n            for (i = 0; i < bpp; i++) {\n                gdouble sum = 0;\n\n                src_p1 = src_p++;\n\n                for (j = 0; j < matrix_len; j++) {\n                    sum += matrix[j] * *src_p1;\n                    src_p1 += bpp;\n                }\n\n                *dest++ = (guchar) (sum + 0.5);\n            }\n        }\n\n        /* for the edge condition, we only use available info and scale to one */\n        for (; row < len; row++) {\n            /* find scale factor */\n            gdouble scale = 0;\n\n            for (j = 0; j < len - row + matrix_middle; j++)\n                scale += matrix[j];\n\n            src_p = src + (row - matrix_middle) * bpp;\n\n            for (i = 0; i < bpp; i++) {\n                gdouble sum = 0;\n\n                src_p1 = src_p++;\n\n                for (j = 0; j < len - row + matrix_middle; j++) {\n                    sum += *src_p1 * matrix[j];\n                    src_p1 += bpp;\n                }\n\n                *dest++ = (guchar) (sum / scale + 0.5);\n            }\n        }\n    }\n}\n\nstatic void\nget_column (guchar *column_data,\n            guchar *src_data,\n            gint src_stride,\n            gint bpp,\n            gint height,\n            gint x)\n{\n    gint y;\n    gint c;\n\n    for (y = 0; y < height; y++) {\n        guchar *src = src_data + y * src_stride + x * bpp;\n\n        for (c = 0; c < bpp; c++)\n            column_data[c] = src[c];\n\n        column_data += bpp;\n    }\n}\n\nstatic void\nput_column (guchar *column_data, guchar *dest_data, gint dest_stride, gint bpp, gint height, gint x)\n{\n    gint y;\n    gint c;\n\n    for (y = 0; y < height; y++) {\n        guchar *dst = dest_data + y * dest_stride + x * bpp;\n\n        for (c = 0; c < bpp; c++)\n            dst[c] = column_data[c];\n\n        column_data += bpp;\n    }\n}\n\nstatic void\ngaussian_blur_surface (cairo_surface_t *in,\n                       cairo_surface_t *out,\n                       gdouble sx,\n                       gdouble sy)\n{\n    gboolean use_box_blur;\n    gint width, height;\n    cairo_format_t in_format, out_format;\n    gint in_stride;\n    gint out_stride;\n    guchar *in_data, *out_data;\n    gint bpp;\n    gboolean out_has_data;\n\n    cairo_surface_flush (in);\n\n    width = cairo_image_surface_get_width (in);\n    height = cairo_image_surface_get_height (in);\n\n    g_assert (width == cairo_image_surface_get_width (out)\n              && height == cairo_image_surface_get_height (out));\n\n    in_format = cairo_image_surface_get_format (in);\n    out_format = cairo_image_surface_get_format (out);\n    g_assert (in_format == out_format);\n    g_assert (in_format == CAIRO_FORMAT_ARGB32\n              || in_format == CAIRO_FORMAT_A8);\n\n    if (in_format == CAIRO_FORMAT_ARGB32)\n        bpp = 4;\n    else if (in_format == CAIRO_FORMAT_A8)\n        bpp = 1;\n    else {\n        g_assert_not_reached ();\n        return;\n    }\n\n    in_stride = cairo_image_surface_get_stride (in);\n    out_stride = cairo_image_surface_get_stride (out);\n\n    in_data = cairo_image_surface_get_data (in);\n    out_data = cairo_image_surface_get_data (out);\n\n    if (sx < 0.0)\n        sx = 0.0;\n\n    if (sy < 0.0)\n        sy = 0.0;\n\n    /* For small radiuses, use a true gaussian kernel; otherwise use three box blurs with\n     * clever offsets.\n     */\n    if (sx < 10.0 && sy < 10.0)\n        use_box_blur = FALSE;\n    else\n        use_box_blur = TRUE;\n\n    /* Bail out by just copying? */\n    if ((sx == 0.0 && sy == 0.0)\n        || sx > 1000 || sy > 1000) {\n        cairo_t *cr;\n\n        cr = cairo_create (out);\n        cairo_set_source_surface (cr, in, 0, 0);\n        cairo_paint (cr);\n        cairo_destroy (cr);\n        return;\n    }\n\n    if (sx != 0.0) {\n        gint box_width;\n        gdouble *gaussian_matrix;\n        gint gaussian_matrix_len;\n        int y;\n        guchar *row_buffer = NULL;\n        guchar *row1, *row2;\n\n        if (use_box_blur) {\n            box_width = compute_box_blur_width (sx);\n\n            /* twice the size so we can have \"two\" scratch rows */\n            row_buffer = g_new0 (guchar, width * bpp * 2);\n            row1 = row_buffer;\n            row2 = row_buffer + width * bpp;\n        } else\n            make_gaussian_convolution_matrix (sx, &gaussian_matrix, &gaussian_matrix_len);\n\n        for (y = 0; y < height; y++) {\n            guchar *in_row, *out_row;\n\n            in_row = in_data + in_stride * y;\n            out_row = out_data + out_stride * y;\n\n            if (use_box_blur) {\n                if (box_width % 2 != 0) {\n                    /* Odd-width box blur: repeat 3 times, centered on output pixel */\n\n                    box_blur_line (box_width, 0, in_row, row1,    width, bpp);\n                    box_blur_line (box_width, 0, row1,   row2,    width, bpp);\n                    box_blur_line (box_width, 0, row2,   out_row, width, bpp);\n                } else {\n                    /* Even-width box blur:\n                     * This method is suggested by the specification for SVG.\n                     * One pass with width n, centered between output and right pixel\n                     * One pass with width n, centered between output and left pixel\n                     * One pass with width n+1, centered on output pixel\n                     */\n                    box_blur_line (box_width,     -1, in_row, row1,    width, bpp);\n                    box_blur_line (box_width,      1, row1,   row2,    width, bpp);\n                    box_blur_line (box_width + 1,  0, row2,   out_row, width, bpp);\n                }\n            } else\n                gaussian_blur_line (gaussian_matrix, gaussian_matrix_len, in_row, out_row, width, bpp);\n        }\n\n        if (!use_box_blur)\n            g_free (gaussian_matrix);\n\n        g_free (row_buffer);\n\n        out_has_data = TRUE;\n    } else\n        out_has_data = FALSE;\n\n    if (sy != 0.0) {\n        gint box_height;\n        gdouble *gaussian_matrix = NULL;\n        gint gaussian_matrix_len;\n        guchar *col_buffer;\n        guchar *col1, *col2;\n        int x;\n\n        /* twice the size so we can have the source pixels and the blurred pixels */\n        col_buffer = g_new0 (guchar, height * bpp * 2);\n        col1 = col_buffer;\n        col2 = col_buffer + height * bpp;\n\n        if (use_box_blur) {\n            box_height = compute_box_blur_width (sy);\n        } else\n            make_gaussian_convolution_matrix (sy, &gaussian_matrix, &gaussian_matrix_len);\n\n        for (x = 0; x < width; x++) {\n            if (out_has_data)\n                get_column (col1, out_data, out_stride, bpp, height, x);\n            else\n                get_column (col1, in_data, in_stride, bpp, height, x);\n\n            if (use_box_blur) {\n                if (box_height % 2 != 0) {\n                    /* Odd-width box blur */\n                    box_blur_line (box_height, 0, col1, col2, height, bpp);\n                    box_blur_line (box_height, 0, col2, col1, height, bpp);\n                    box_blur_line (box_height, 0, col1, col2, height, bpp);\n                } else {\n                    /* Even-width box blur */\n                    box_blur_line (box_height,     -1, col1, col2, height, bpp);\n                    box_blur_line (box_height,      1, col2, col1, height, bpp);\n                    box_blur_line (box_height + 1,  0, col1, col2, height, bpp);\n                }\n            } else\n                gaussian_blur_line (gaussian_matrix, gaussian_matrix_len, col1, col2, height, bpp);\n\n            put_column (col2, out_data, out_stride, bpp, height, x);\n        }\n\n        g_free (gaussian_matrix);\n        g_free (col_buffer);\n    }\n\n    cairo_surface_mark_dirty (out);\n}\n\nstatic void\nrsvg_filter_primitive_gaussian_blur_render (RsvgNode *node, RsvgFilterPrimitive *primitive, RsvgFilterContext *ctx)\n{\n    RsvgFilterPrimitiveGaussianBlur *gaussian = (RsvgFilterPrimitiveGaussianBlur *) primitive;\n\n    int width, height;\n    cairo_surface_t *output, *in;\n    RsvgIRect boundarys;\n    gdouble sdx, sdy;\n    RsvgFilterPrimitiveOutput op;\n    cairo_t *cr;\n\n    boundarys = rsvg_filter_primitive_get_bounds (primitive, ctx);\n\n    op = rsvg_filter_get_result (primitive->in, ctx);\n    in = op.surface;\n\n    width = cairo_image_surface_get_width (in);\n    height = cairo_image_surface_get_height (in);\n\n    output = _rsvg_image_surface_new (width, height);\n\n    if (output == NULL) {\n        cairo_surface_destroy (in);\n        return;\n    }\n\n    /* scale the SD values */\n    sdx = fabs (gaussian->sdx * ctx->paffine.xx);\n    sdy = fabs (gaussian->sdy * ctx->paffine.yy);\n\n    gaussian_blur_surface (in, output, sdx, sdy);\n\n    /* Hard-clip to the filter area */\n    if (!(boundarys.x0 == 0\n          && boundarys.y0 == 0\n          && boundarys.x1 == width\n          && boundarys.y1 == height)) {\n        cr = cairo_create (output);\n        cairo_set_operator (cr, CAIRO_OPERATOR_CLEAR);\n        cairo_set_fill_rule (cr, CAIRO_FILL_RULE_EVEN_ODD);\n        cairo_rectangle (cr, 0, 0, width, height);\n        cairo_rectangle (cr,\n                         boundarys.x0, boundarys.y0,\n                         boundarys.x1 - boundarys.x0, boundarys.y1 - boundarys.y0);\n        cairo_fill (cr);\n        cairo_destroy (cr);\n    }\n\n    op.surface = output;\n    op.bounds = boundarys;\n    rsvg_filter_store_output (primitive->result, op, ctx);\n\n    cairo_surface_destroy (in);\n    cairo_surface_destroy (output);\n}\n\nstatic void\nrsvg_filter_primitive_gaussian_blur_set_atts (RsvgNode *node, gpointer impl, RsvgHandle *handle, RsvgPropertyBag *atts)\n{\n    RsvgFilterPrimitiveGaussianBlur *filter = impl;\n    const char *value;\n\n    if ((value = rsvg_property_bag_lookup (atts, \"in\")))\n        g_string_assign (filter->super.in, value);\n    if ((value = rsvg_property_bag_lookup (atts, \"result\")))\n        g_string_assign (filter->super.result, value);\n\n    filter_primitive_set_x_y_width_height_atts ((RsvgFilterPrimitive *) filter, atts);\n\n    if ((value = rsvg_property_bag_lookup (atts, \"stdDeviation\"))) {\n        if (!rsvg_css_parse_number_optional_number (value, &filter->sdx, &filter->sdy)) {\n            rsvg_node_set_attribute_parse_error (node, \"stdDeviation\", \"expected number-optional-number\");\n            return;\n        }\n    }\n}\n\nRsvgNode *\nrsvg_new_filter_primitive_gaussian_blur (const char *element_name, RsvgNode *parent)\n{\n    RsvgFilterPrimitiveGaussianBlur *filter;\n\n    filter = g_new0 (RsvgFilterPrimitiveGaussianBlur, 1);\n    filter->super.in = g_string_new (\"none\");\n    filter->super.result = g_string_new (\"none\");\n    filter->sdx = 0;\n    filter->sdy = 0;\n    filter->super.render = rsvg_filter_primitive_gaussian_blur_render;\n\n    return rsvg_rust_cnode_new (RSVG_NODE_TYPE_FILTER_PRIMITIVE_GAUSSIAN_BLUR,\n                                parent,\n                                rsvg_state_new (),\n                                filter,\n                                rsvg_filter_primitive_gaussian_blur_set_atts,\n                                rsvg_filter_draw,\n                                rsvg_filter_primitive_free);\n}\n\n/*************************************************************/\n/*************************************************************/\n\ntypedef struct _RsvgFilterPrimitiveOffset RsvgFilterPrimitiveOffset;\n\nstruct _RsvgFilterPrimitiveOffset {\n    RsvgFilterPrimitive super;\n    RsvgLength dx, dy;\n};\n\nstatic void\nrsvg_filter_primitive_offset_render (RsvgNode *node, RsvgFilterPrimitive *primitive, RsvgFilterContext *ctx)\n{\n    RsvgFilterPrimitiveOffset *offset = (RsvgFilterPrimitiveOffset *) primitive;\n\n    guchar ch;\n    gint x, y;\n    gint rowstride, height, width;\n    RsvgIRect boundarys;\n\n    guchar *in_pixels;\n    guchar *output_pixels;\n\n    RsvgFilterPrimitiveOutput out;\n\n    cairo_surface_t *output, *in;\n\n    double dx, dy;\n    int ox, oy;\n\n    boundarys = rsvg_filter_primitive_get_bounds (primitive, ctx);\n\n    in = rsvg_filter_get_in (primitive->in, ctx);\n    if (in == NULL)\n        return;\n\n    cairo_surface_flush (in);\n\n    in_pixels = cairo_image_surface_get_data (in);\n\n    height = cairo_image_surface_get_height (in);\n    width = cairo_image_surface_get_width (in);\n\n    rowstride = cairo_image_surface_get_stride (in);\n\n    output = _rsvg_image_surface_new (width, height);\n    if (output == NULL) {\n        cairo_surface_destroy (in);\n        return;\n    }\n\n    output_pixels = cairo_image_surface_get_data (output);\n\n    dx = rsvg_length_normalize (&offset->dx, ctx->ctx);\n    dy = rsvg_length_normalize (&offset->dy, ctx->ctx);\n\n    ox = ctx->paffine.xx * dx + ctx->paffine.xy * dy;\n    oy = ctx->paffine.yx * dx + ctx->paffine.yy * dy;\n\n    for (y = boundarys.y0; y < boundarys.y1; y++)\n        for (x = boundarys.x0; x < boundarys.x1; x++) {\n            if (x - ox < boundarys.x0 || x - ox >= boundarys.x1)\n                continue;\n            if (y - oy < boundarys.y0 || y - oy >= boundarys.y1)\n                continue;\n\n            for (ch = 0; ch < 4; ch++) {\n                output_pixels[y * rowstride + x * 4 + ch] =\n                    in_pixels[(y - oy) * rowstride + (x - ox) * 4 + ch];\n            }\n        }\n\n    cairo_surface_mark_dirty (output);\n\n    out.surface = output;\n    out.bounds = boundarys;\n\n    rsvg_filter_store_output (primitive->result, out, ctx);\n\n    cairo_surface_destroy  (in);\n    cairo_surface_destroy (output);\n}\n\nstatic void\nrsvg_filter_primitive_offset_set_atts (RsvgNode *node, gpointer impl, RsvgHandle *handle, RsvgPropertyBag * atts)\n{\n    RsvgFilterPrimitiveOffset *filter = impl;\n    const char *value;\n\n    if ((value = rsvg_property_bag_lookup (atts, \"in\")))\n        g_string_assign (filter->super.in, value);\n    if ((value = rsvg_property_bag_lookup (atts, \"result\")))\n        g_string_assign (filter->super.result, value);\n\n    filter_primitive_set_x_y_width_height_atts ((RsvgFilterPrimitive *) filter, atts);\n\n    if ((value = rsvg_property_bag_lookup (atts, \"dx\")))\n        filter->dx = rsvg_length_parse (value, LENGTH_DIR_HORIZONTAL);\n    if ((value = rsvg_property_bag_lookup (atts, \"dy\")))\n        filter->dy = rsvg_length_parse (value, LENGTH_DIR_VERTICAL);\n}\n\nRsvgNode *\nrsvg_new_filter_primitive_offset (const char *element_name, RsvgNode *parent)\n{\n    RsvgFilterPrimitiveOffset *filter;\n\n    filter = g_new0 (RsvgFilterPrimitiveOffset, 1);\n    filter->super.in = g_string_new (\"none\");\n    filter->super.result = g_string_new (\"none\");\n    filter->dx = rsvg_length_parse (\"0\", LENGTH_DIR_HORIZONTAL);\n    filter->dy = rsvg_length_parse (\"0\", LENGTH_DIR_VERTICAL);\n    filter->super.render = rsvg_filter_primitive_offset_render;\n\n    return rsvg_rust_cnode_new (RSVG_NODE_TYPE_FILTER_PRIMITIVE_OFFSET,\n                                parent,\n                                rsvg_state_new (),\n                                filter,\n                                rsvg_filter_primitive_offset_set_atts,\n                                rsvg_filter_draw,\n                                rsvg_filter_primitive_free);\n}\n\n/*************************************************************/\n/*************************************************************/\n\ntypedef struct _RsvgFilterPrimitiveMerge RsvgFilterPrimitiveMerge;\n\nstruct _RsvgFilterPrimitiveMerge {\n    RsvgFilterPrimitive super;\n};\n\nstruct merge_render_closure {\n    cairo_surface_t *output;\n    RsvgIRect boundarys;\n    RsvgFilterContext *ctx;\n};\n\nstatic gboolean\nmerge_render_child (RsvgNode *node, gpointer data)\n{\n    struct merge_render_closure *closure = data;\n    RsvgFilterPrimitive *fp;\n    cairo_surface_t *in;\n\n    if (rsvg_node_get_type (node) != RSVG_NODE_TYPE_FILTER_PRIMITIVE_MERGE_NODE)\n        return TRUE;\n\n    fp = rsvg_rust_cnode_get_impl (node);\n\n    in = rsvg_filter_get_in (fp->in, closure->ctx);\n    if (in == NULL)\n        return TRUE;\n\n    rsvg_alpha_blt (in,\n                    closure->boundarys.x0,\n                    closure->boundarys.y0,\n                    closure->boundarys.x1 - closure->boundarys.x0,\n                    closure->boundarys.y1 - closure->boundarys.y0,\n                    closure->output,\n                    closure->boundarys.x0,\n                    closure->boundarys.y0);\n\n    cairo_surface_destroy (in);\n\n    return TRUE;\n}\n\nstatic void\nrsvg_filter_primitive_merge_render (RsvgNode *node, RsvgFilterPrimitive *primitive, RsvgFilterContext *ctx)\n{\n    struct merge_render_closure closure;\n\n    closure.boundarys = rsvg_filter_primitive_get_bounds (primitive, ctx);\n\n    closure.output = _rsvg_image_surface_new (ctx->width, ctx->height);\n    if (closure.output == NULL) {\n        return;\n    }\n\n    closure.ctx = ctx;\n\n    rsvg_node_foreach_child (node, merge_render_child, &closure);\n\n    rsvg_filter_store_result (primitive->result, closure.output, ctx);\n\n    cairo_surface_destroy (closure.output);\n}\n\nstatic void\nrsvg_filter_primitive_merge_set_atts (RsvgNode *node, gpointer impl, RsvgHandle *handle, RsvgPropertyBag *atts)\n{\n    RsvgFilterPrimitiveMerge *filter = impl;\n    const char *value;\n\n    if ((value = rsvg_property_bag_lookup (atts, \"result\")))\n        g_string_assign (filter->super.result, value);\n\n    filter_primitive_set_x_y_width_height_atts ((RsvgFilterPrimitive *) filter, atts);\n}\n\nRsvgNode *\nrsvg_new_filter_primitive_merge (const char *element_name, RsvgNode *parent)\n{\n    RsvgFilterPrimitiveMerge *filter;\n\n    filter = g_new0 (RsvgFilterPrimitiveMerge, 1);\n    filter->super.result = g_string_new (\"none\");\n    filter->super.render = rsvg_filter_primitive_merge_render;\n\n    return rsvg_rust_cnode_new (RSVG_NODE_TYPE_FILTER_PRIMITIVE_MERGE,\n                                parent,\n                                rsvg_state_new (),\n                                filter,\n                                rsvg_filter_primitive_merge_set_atts,\n                                rsvg_filter_draw,\n                                rsvg_filter_primitive_free);\n}\n\nstatic void\nrsvg_filter_primitive_merge_node_set_atts (RsvgNode *node, gpointer impl, RsvgHandle *handle, RsvgPropertyBag *atts)\n{\n    RsvgFilterPrimitive *primitive = impl;\n    const char *value;\n\n    /* see bug 145149 - sodipodi generates bad SVG... */\n    if ((value = rsvg_property_bag_lookup (atts, \"in\")))\n        g_string_assign (primitive->in, value);\n}\n\nstatic void\nrsvg_filter_primitive_merge_node_render (RsvgNode *node, RsvgFilterPrimitive *primitive, RsvgFilterContext *ctx)\n{\n    /* todo */\n}\n\nRsvgNode *\nrsvg_new_filter_primitive_merge_node (const char *element_name, RsvgNode *parent)\n{\n    RsvgFilterPrimitive *filter;\n\n    filter = g_new0 (RsvgFilterPrimitive, 1);\n    filter->in = g_string_new (\"none\");\n    filter->render = rsvg_filter_primitive_merge_node_render;\n\n    return rsvg_rust_cnode_new (RSVG_NODE_TYPE_FILTER_PRIMITIVE_MERGE_NODE,\n                                parent,\n                                rsvg_state_new (),\n                                filter,\n                                rsvg_filter_primitive_merge_node_set_atts,\n                                rsvg_filter_draw,\n                                rsvg_filter_primitive_free);\n}\n\n/*************************************************************/\n/*************************************************************/\n\ntypedef struct _RsvgFilterPrimitiveColorMatrix RsvgFilterPrimitiveColorMatrix;\n\nstruct _RsvgFilterPrimitiveColorMatrix {\n    RsvgFilterPrimitive super;\n    gint *KernelMatrix;\n};\n\nstatic void\nrsvg_filter_primitive_color_matrix_render (RsvgNode *node, RsvgFilterPrimitive *primitive, RsvgFilterContext *ctx)\n{\n    RsvgFilterPrimitiveColorMatrix *color_matrix = (RsvgFilterPrimitiveColorMatrix *) primitive;\n\n    guchar ch;\n    gint x, y;\n    gint i;\n    gint rowstride, height, width;\n    RsvgIRect boundarys;\n\n    guchar *in_pixels;\n    guchar *output_pixels;\n\n    cairo_surface_t *output, *in;\n\n    int sum;\n\n    boundarys = rsvg_filter_primitive_get_bounds (primitive, ctx);\n\n    in = rsvg_filter_get_in (primitive->in, ctx);\n    if (in == NULL)\n        return;\n\n    cairo_surface_flush (in);\n\n    in_pixels = cairo_image_surface_get_data (in);\n\n    height = cairo_image_surface_get_height (in);\n    width = cairo_image_surface_get_width (in);\n\n    rowstride = cairo_image_surface_get_stride (in);\n\n    output = _rsvg_image_surface_new (width, height);\n    if (output == NULL) {\n        cairo_surface_destroy (in);\n        return;\n    }\n\n    output_pixels = cairo_image_surface_get_data (output);\n\n    for (y = boundarys.y0; y < boundarys.y1; y++)\n        for (x = boundarys.x0; x < boundarys.x1; x++) {\n            int umch;\n            int alpha = in_pixels[4 * x + y * rowstride + ctx->channelmap[3]];\n            if (!alpha)\n                for (umch = 0; umch < 4; umch++) {\n                    sum = color_matrix->KernelMatrix[umch * 5 + 4];\n                    if (sum > 255)\n                        sum = 255;\n                    if (sum < 0)\n                        sum = 0;\n                    output_pixels[4 * x + y * rowstride + ctx->channelmap[umch]] = sum;\n            } else\n                for (umch = 0; umch < 4; umch++) {\n                    int umi;\n                    ch = ctx->channelmap[umch];\n                    sum = 0;\n                    for (umi = 0; umi < 4; umi++) {\n                        i = ctx->channelmap[umi];\n                        if (umi != 3)\n                            sum += color_matrix->KernelMatrix[umch * 5 + umi] *\n                                in_pixels[4 * x + y * rowstride + i] / alpha;\n                        else\n                            sum += color_matrix->KernelMatrix[umch * 5 + umi] *\n                                in_pixels[4 * x + y * rowstride + i] / 255;\n                    }\n                    sum += color_matrix->KernelMatrix[umch * 5 + 4];\n\n\n\n                    if (sum > 255)\n                        sum = 255;\n                    if (sum < 0)\n                        sum = 0;\n\n                    output_pixels[4 * x + y * rowstride + ch] = sum;\n                }\n            for (umch = 0; umch < 3; umch++) {\n                ch = ctx->channelmap[umch];\n                output_pixels[4 * x + y * rowstride + ch] =\n                    output_pixels[4 * x + y * rowstride + ch] *\n                    output_pixels[4 * x + y * rowstride + ctx->channelmap[3]] / 255;\n            }\n        }\n\n    cairo_surface_mark_dirty (output);\n\n    rsvg_filter_store_result (primitive->result, output, ctx);\n\n    cairo_surface_destroy (in);\n    cairo_surface_destroy (output);\n}\n\nstatic void\nrsvg_filter_primitive_color_matrix_free (gpointer impl)\n{\n    RsvgFilterPrimitiveColorMatrix *matrix = impl;\n\n    g_free (matrix->KernelMatrix);\n\n    rsvg_filter_primitive_free (impl);\n}\n\nstatic void\nrsvg_filter_primitive_color_matrix_set_atts (RsvgNode *node, gpointer impl, RsvgHandle *handle, RsvgPropertyBag *atts)\n{\n    RsvgFilterPrimitiveColorMatrix *filter = impl;\n    gint type;\n    gsize listlen = 0;\n    const char *value;\n\n    type = 0;\n\n    if ((value = rsvg_property_bag_lookup (atts, \"in\")))\n        g_string_assign (filter->super.in, value);\n    if ((value = rsvg_property_bag_lookup (atts, \"result\")))\n        g_string_assign (filter->super.result, value);\n\n    filter_primitive_set_x_y_width_height_atts ((RsvgFilterPrimitive *) filter, atts);\n\n    if ((value = rsvg_property_bag_lookup (atts, \"values\"))) {\n        unsigned int i;\n        double *temp;\n        if (!rsvg_css_parse_number_list (value,\n                                         NUMBER_LIST_LENGTH_MAXIMUM,\n                                         20,\n                                         &temp,\n                                         &listlen)) {\n            rsvg_node_set_attribute_parse_error (node, \"values\", \"invalid number list\");\n            return;\n        }\n\n        filter->KernelMatrix = g_new0 (int, listlen);\n        for (i = 0; i < listlen; i++)\n            filter->KernelMatrix[i] = temp[i] * 255.;\n        g_free (temp);\n    }\n    if ((value = rsvg_property_bag_lookup (atts, \"type\"))) {\n        if (!strcmp (value, \"matrix\"))\n            type = 0;\n        else if (!strcmp (value, \"saturate\"))\n            type = 1;\n        else if (!strcmp (value, \"hueRotate\"))\n            type = 2;\n        else if (!strcmp (value, \"luminanceToAlpha\"))\n            type = 3;\n        else\n            type = 0;\n    }\n\n    if (type == 0) {\n        if (listlen != 20) {\n            if (filter->KernelMatrix != NULL)\n                g_free (filter->KernelMatrix);\n            filter->KernelMatrix = g_new0 (int, 20);\n        }\n    } else if (type == 1) {\n        float s;\n        if (listlen != 0) {\n            s = filter->KernelMatrix[0];\n            g_free (filter->KernelMatrix);\n        } else\n            s = 255;\n        filter->KernelMatrix = g_new0 (int, 20);\n\n        filter->KernelMatrix[0] = 0.213 * 255. + 0.787 * s;\n        filter->KernelMatrix[1] = 0.715 * 255. - 0.715 * s;\n        filter->KernelMatrix[2] = 0.072 * 255. - 0.072 * s;\n        filter->KernelMatrix[5] = 0.213 * 255. - 0.213 * s;\n        filter->KernelMatrix[6] = 0.715 * 255. + 0.285 * s;\n        filter->KernelMatrix[7] = 0.072 * 255. - 0.072 * s;\n        filter->KernelMatrix[10] = 0.213 * 255. - 0.213 * s;\n        filter->KernelMatrix[11] = 0.715 * 255. - 0.715 * s;\n        filter->KernelMatrix[12] = 0.072 * 255. + 0.928 * s;\n        filter->KernelMatrix[18] = 255;\n    } else if (type == 2) {\n        double cosval, sinval, arg;\n\n        if (listlen != 0) {\n            arg = (double) filter->KernelMatrix[0] / 255.;\n            g_free (filter->KernelMatrix);\n        } else\n            arg = 0;\n\n        cosval = cos (arg);\n        sinval = sin (arg);\n\n        filter->KernelMatrix = g_new0 (int, 20);\n\n        filter->KernelMatrix[0] = (0.213 + cosval * 0.787 + sinval * -0.213) * 255.;\n        filter->KernelMatrix[1] = (0.715 + cosval * -0.715 + sinval * -0.715) * 255.;\n        filter->KernelMatrix[2] = (0.072 + cosval * -0.072 + sinval * 0.928) * 255.;\n        filter->KernelMatrix[5] = (0.213 + cosval * -0.213 + sinval * 0.143) * 255.;\n        filter->KernelMatrix[6] = (0.715 + cosval * 0.285 + sinval * 0.140) * 255.;\n        filter->KernelMatrix[7] = (0.072 + cosval * -0.072 + sinval * -0.283) * 255.;\n        filter->KernelMatrix[10] = (0.213 + cosval * -0.213 + sinval * -0.787) * 255.;\n        filter->KernelMatrix[11] = (0.715 + cosval * -0.715 + sinval * 0.715) * 255.;\n        filter->KernelMatrix[12] = (0.072 + cosval * 0.928 + sinval * 0.072) * 255.;\n        filter->KernelMatrix[18] = 255;\n    } else if (type == 3) {\n        if (filter->KernelMatrix != NULL)\n            g_free (filter->KernelMatrix);\n\n        filter->KernelMatrix = g_new0 (int, 20);\n\n        filter->KernelMatrix[15] = 0.2125 * 255.;\n        filter->KernelMatrix[16] = 0.7154 * 255.;\n        filter->KernelMatrix[17] = 0.0721 * 255.;\n    } else {\n        g_assert_not_reached ();\n    }\n}\n\nRsvgNode *\nrsvg_new_filter_primitive_color_matrix (const char *element_name, RsvgNode *parent)\n{\n    RsvgFilterPrimitiveColorMatrix *filter;\n\n    filter = g_new0 (RsvgFilterPrimitiveColorMatrix, 1);\n    filter->super.in = g_string_new (\"none\");\n    filter->super.result = g_string_new (\"none\");\n    filter->KernelMatrix = NULL;\n    filter->super.render = rsvg_filter_primitive_color_matrix_render;\n\n    return rsvg_rust_cnode_new (RSVG_NODE_TYPE_FILTER_PRIMITIVE_COLOR_MATRIX,\n                                parent,\n                                rsvg_state_new (),\n                                filter,\n                                rsvg_filter_primitive_color_matrix_set_atts,\n                                rsvg_filter_draw,\n                                rsvg_filter_primitive_color_matrix_free);                                \n}\n\n\n/*************************************************************/\n/*************************************************************/\n\ntypedef struct _RsvgNodeComponentTransferFunc RsvgNodeComponentTransferFunc;\n\ntypedef gint (*ComponentTransferFunc) (gint C, RsvgNodeComponentTransferFunc * user_data);\n\ntypedef struct _RsvgFilterPrimitiveComponentTransfer\n RsvgFilterPrimitiveComponentTransfer;\n\nstruct _RsvgNodeComponentTransferFunc {\n    ComponentTransferFunc function;\n    gint *tableValues;\n    gsize nbTableValues;\n    gint slope;\n    gint intercept;\n    gint amplitude;\n    gint offset;\n    gdouble exponent;\n    char channel;\n};\n\nstruct _RsvgFilterPrimitiveComponentTransfer {\n    RsvgFilterPrimitive super;\n};\n\nstatic gint\nidentity_component_transfer_func (gint C, RsvgNodeComponentTransferFunc * user_data)\n{\n    return C;\n}\n\nstatic gint\ntable_component_transfer_func (gint C, RsvgNodeComponentTransferFunc * user_data)\n{\n    guint k;\n    gint vk, vk1, distancefromlast;\n    guint num_values;\n\n    if (!user_data->nbTableValues)\n        return C;\n\n    num_values = user_data->nbTableValues;\n\n    k = (C * (num_values - 1)) / 255;\n\n    vk = user_data->tableValues[MIN (k, num_values - 1)];\n    vk1 = user_data->tableValues[MIN (k + 1, num_values - 1)];\n\n    distancefromlast = (C * (user_data->nbTableValues - 1)) - k * 255;\n\n    return vk + distancefromlast * (vk1 - vk) / 255;\n}\n\nstatic gint\ndiscrete_component_transfer_func (gint C, RsvgNodeComponentTransferFunc * user_data)\n{\n    gint k;\n\n    if (!user_data->nbTableValues)\n        return C;\n\n    k = (C * user_data->nbTableValues) / 255;\n\n    return user_data->tableValues[CLAMP (k, 0, user_data->nbTableValues - 1)];\n}\n\nstatic gint\nlinear_component_transfer_func (gint C, RsvgNodeComponentTransferFunc * user_data)\n{\n    return (user_data->slope * C) / 255 + user_data->intercept;\n}\n\nstatic gint\nfixpow (gint base, gint exp)\n{\n    int out = 255;\n    for (; exp > 0; exp--)\n        out = out * base / 255;\n    return out;\n}\n\nstatic gint\ngamma_component_transfer_func (gint C, RsvgNodeComponentTransferFunc * user_data)\n{\n    if (floor (user_data->exponent) == user_data->exponent)\n        return user_data->amplitude * fixpow (C, user_data->exponent) / 255 + user_data->offset;\n    else\n        return (double) user_data->amplitude * pow ((double) C / 255.,\n                                                    user_data->exponent) + user_data->offset;\n}\n\nstruct component_transfer_closure {\n    int channel_num;\n    char channel;\n    gboolean set_func;\n    RsvgNodeComponentTransferFunc *channels[4];\n    ComponentTransferFunc functions[4];\n    RsvgFilterContext *ctx;\n};\n\nstatic gboolean\ncomponent_transfer_render_child (RsvgNode *node, gpointer data)\n{\n    struct component_transfer_closure *closure = data;\n    RsvgNodeComponentTransferFunc *f;\n\n    if (rsvg_node_get_type (node) != RSVG_NODE_TYPE_COMPONENT_TRANFER_FUNCTION)\n        return TRUE;\n\n    f = rsvg_rust_cnode_get_impl (node);\n\n    if (f->channel == closure->channel) {\n        closure->functions[closure->ctx->channelmap[closure->channel_num]] = f->function;\n        closure->channels[closure->ctx->channelmap[closure->channel_num]] = f;\n        closure->set_func = TRUE;\n    }\n\n    return TRUE;\n}\n\nstatic void\nrsvg_filter_primitive_component_transfer_render (RsvgNode *node, RsvgFilterPrimitive *primitive, RsvgFilterContext *ctx)\n{\n    gint x, y, c;\n    gint rowstride, height, width;\n    RsvgIRect boundarys;\n    guchar *inpix, outpix[4];\n    gint achan = ctx->channelmap[3];\n    guchar *in_pixels;\n    guchar *output_pixels;\n    cairo_surface_t *output, *in;\n    struct component_transfer_closure closure;\n\n    boundarys = rsvg_filter_primitive_get_bounds (primitive, ctx);\n\n    closure.ctx = ctx;\n\n    for (c = 0; c < 4; c++) {\n        closure.channel_num = c;\n        closure.channel = \"rgba\"[c]; /* see rsvg_new_node_component_transfer_function() for where these chars come from */\n        closure.set_func = FALSE;\n\n        rsvg_node_foreach_child (node, component_transfer_render_child, &closure);\n\n        if (!closure.set_func)\n            closure.functions[ctx->channelmap[c]] = identity_component_transfer_func;\n    }\n\n    in = rsvg_filter_get_in (primitive->in, ctx);\n    if (in == NULL)\n        return;\n\n    cairo_surface_flush (in);\n\n    in_pixels = cairo_image_surface_get_data (in);\n\n    height = cairo_image_surface_get_height (in);\n    width = cairo_image_surface_get_width (in);\n\n    rowstride = cairo_image_surface_get_stride (in);\n\n    output = _rsvg_image_surface_new (width, height);\n    if (output == NULL) {\n        cairo_surface_destroy (in);\n        return;\n    }\n\n    output_pixels = cairo_image_surface_get_data (output);\n\n    for (y = boundarys.y0; y < boundarys.y1; y++)\n        for (x = boundarys.x0; x < boundarys.x1; x++) {\n            inpix = in_pixels + (y * rowstride + x * 4);\n            for (c = 0; c < 4; c++) {\n                gint temp;\n                int inval;\n                if (c != achan) {\n                    if (inpix[achan] == 0)\n                        inval = 0;\n                    else\n                        inval = inpix[c] * 255 / inpix[achan];\n                } else\n                    inval = inpix[c];\n\n                temp = closure.functions[c] (inval, closure.channels[c]);\n                if (temp > 255)\n                    temp = 255;\n                else if (temp < 0)\n                    temp = 0;\n                outpix[c] = temp;\n            }\n            for (c = 0; c < 3; c++)\n                output_pixels[y * rowstride + x * 4 + ctx->channelmap[c]] =\n                    outpix[ctx->channelmap[c]] * outpix[achan] / 255;\n            output_pixels[y * rowstride + x * 4 + achan] = outpix[achan];\n        }\n\n    cairo_surface_mark_dirty (output);\n\n    rsvg_filter_store_result (primitive->result, output, ctx);\n\n    cairo_surface_destroy (in);\n    cairo_surface_destroy (output);\n}\n\nstatic void\nrsvg_filter_primitive_component_transfer_set_atts (RsvgNode *node, gpointer impl, RsvgHandle *handle, RsvgPropertyBag *atts)\n{\n    RsvgFilterPrimitiveComponentTransfer *filter = impl;\n    const char *value;\n\n    if ((value = rsvg_property_bag_lookup (atts, \"result\")))\n        g_string_assign (filter->super.result, value);\n    if ((value = rsvg_property_bag_lookup (atts, \"in\")))\n        g_string_assign (filter->super.in, value);\n\n    filter_primitive_set_x_y_width_height_atts ((RsvgFilterPrimitive *) filter, atts);\n}\n\nRsvgNode *\nrsvg_new_filter_primitive_component_transfer (const char *element_name, RsvgNode *parent)\n{\n    RsvgFilterPrimitiveComponentTransfer *filter;\n\n    filter = g_new0 (RsvgFilterPrimitiveComponentTransfer, 1);\n    filter->super.result = g_string_new (\"none\");\n    filter->super.in = g_string_new (\"none\");\n    filter->super.render = rsvg_filter_primitive_component_transfer_render;\n\n    return rsvg_rust_cnode_new (RSVG_NODE_TYPE_FILTER_PRIMITIVE_COMPONENT_TRANSFER,\n                                parent,\n                                rsvg_state_new (),\n                                filter,\n                                rsvg_filter_primitive_component_transfer_set_atts,\n                                rsvg_filter_draw,\n                                rsvg_filter_primitive_free);                                \n}\n\nstatic void\nrsvg_node_component_transfer_function_set_atts (RsvgNode *node, gpointer impl, RsvgHandle *handle, RsvgPropertyBag *atts)\n{\n    RsvgNodeComponentTransferFunc *data = impl;\n    const char *value;\n\n    if ((value = rsvg_property_bag_lookup (atts, \"type\"))) {\n        if (!strcmp (value, \"identity\"))\n            data->function = identity_component_transfer_func;\n        else if (!strcmp (value, \"table\"))\n            data->function = table_component_transfer_func;\n        else if (!strcmp (value, \"discrete\"))\n            data->function = discrete_component_transfer_func;\n        else if (!strcmp (value, \"linear\"))\n            data->function = linear_component_transfer_func;\n        else if (!strcmp (value, \"gamma\"))\n            data->function = gamma_component_transfer_func;\n    }\n\n    if ((value = rsvg_property_bag_lookup (atts, \"tableValues\"))) {\n        unsigned int i;\n        double *temp;\n        if (!rsvg_css_parse_number_list (value,\n                                         NUMBER_LIST_LENGTH_MAXIMUM,\n                                         256,\n                                         &temp,\n                                         &data->nbTableValues)) {\n            rsvg_node_set_attribute_parse_error (node, \"tableValues\", \"invalid number list\");\n            return;\n        }\n\n        data->tableValues = g_new0 (gint, data->nbTableValues);\n        for (i = 0; i < data->nbTableValues; i++)\n            data->tableValues[i] = temp[i] * 255.;\n        g_free (temp);\n    }\n    if ((value = rsvg_property_bag_lookup (atts, \"slope\"))) {\n        data->slope = g_ascii_strtod (value, NULL) * 255.;\n    }\n    if ((value = rsvg_property_bag_lookup (atts, \"intercept\"))) {\n        data->intercept = g_ascii_strtod (value, NULL) * 255.;\n    }\n    if ((value = rsvg_property_bag_lookup (atts, \"amplitude\"))) {\n        data->amplitude = g_ascii_strtod (value, NULL) * 255.;\n    }\n    if ((value = rsvg_property_bag_lookup (atts, \"exponent\"))) {\n        data->exponent = g_ascii_strtod (value, NULL);\n    }\n    if ((value = rsvg_property_bag_lookup (atts, \"offset\"))) {\n        data->offset = g_ascii_strtod (value, NULL) * 255.;\n    }\n}\n\nstatic void\nrsvg_node_component_transfer_function_free (gpointer impl)\n{\n    RsvgNodeComponentTransferFunc *filter = impl;\n\n    if (filter->nbTableValues)\n        g_free (filter->tableValues);\n\n    g_free (filter);\n}\n\nRsvgNode *\nrsvg_new_node_component_transfer_function (const char *element_name, RsvgNode *parent)\n{\n    RsvgNodeComponentTransferFunc *filter;\n\n    char channel;\n\n    if (strcmp (element_name, \"feFuncR\") == 0)\n        channel = 'r';\n    else if (strcmp (element_name, \"feFuncG\") == 0)\n        channel = 'g';\n    else if (strcmp (element_name, \"feFuncB\") == 0)\n        channel = 'b';\n    else if (strcmp (element_name, \"feFuncA\") == 0)\n        channel = 'a';\n    else {\n        g_assert_not_reached ();\n        channel = '\\0';\n    }\n\n    filter = g_new0 (RsvgNodeComponentTransferFunc, 1);\n    filter->function = identity_component_transfer_func;\n    filter->nbTableValues = 0;\n    filter->channel = channel;\n\n    return rsvg_rust_cnode_new (RSVG_NODE_TYPE_COMPONENT_TRANFER_FUNCTION,\n                                parent,\n                                rsvg_state_new (),\n                                filter,\n                                rsvg_node_component_transfer_function_set_atts,\n                                rsvg_filter_draw,\n                                rsvg_node_component_transfer_function_free);\n}\n\n/*************************************************************/\n/*************************************************************/\n\ntypedef struct _RsvgFilterPrimitiveErode\n RsvgFilterPrimitiveErode;\n\nstruct _RsvgFilterPrimitiveErode {\n    RsvgFilterPrimitive super;\n    double rx, ry;\n    int mode;\n};\n\nstatic void\nrsvg_filter_primitive_erode_render (RsvgNode *node, RsvgFilterPrimitive *primitive, RsvgFilterContext *ctx)\n{\n    RsvgFilterPrimitiveErode *erode = (RsvgFilterPrimitiveErode *) primitive;\n\n    guchar ch, extreme;\n    gint x, y;\n    gint i, j;\n    gint rowstride, height, width;\n    RsvgIRect boundarys;\n\n    guchar *in_pixels;\n    guchar *output_pixels;\n\n    cairo_surface_t *output, *in;\n\n    gint kx, ky;\n    guchar val;\n\n    boundarys = rsvg_filter_primitive_get_bounds (primitive, ctx);\n\n    in = rsvg_filter_get_in (primitive->in, ctx);\n    if (in == NULL)\n        return;\n\n    cairo_surface_flush (in);\n\n    in_pixels = cairo_image_surface_get_data (in);\n\n    height = cairo_image_surface_get_height (in);\n    width = cairo_image_surface_get_width (in);\n\n    rowstride = cairo_image_surface_get_stride (in);\n\n    /* scale the radius values */\n    kx = erode->rx * ctx->paffine.xx;\n    ky = erode->ry * ctx->paffine.yy;\n\n    output = _rsvg_image_surface_new (width, height);\n    if (output == NULL) {\n        cairo_surface_destroy (in);\n        return;\n    }\n\n    output_pixels = cairo_image_surface_get_data (output);\n\n    for (y = boundarys.y0; y < boundarys.y1; y++)\n        for (x = boundarys.x0; x < boundarys.x1; x++)\n            for (ch = 0; ch < 4; ch++) {\n                if (erode->mode == 0)\n                    extreme = 255;\n                else\n                    extreme = 0;\n                for (i = -ky; i < ky + 1; i++)\n                    for (j = -kx; j < kx + 1; j++) {\n                        if (y + i >= height || y + i < 0 || x + j >= width || x + j < 0)\n                            continue;\n\n                        val = in_pixels[(y + i) * rowstride + (x + j) * 4 + ch];\n\n\n                        if (erode->mode == 0) {\n                            if (extreme > val)\n                                extreme = val;\n                        } else {\n                            if (extreme < val)\n                                extreme = val;\n                        }\n\n                    }\n                output_pixels[y * rowstride + x * 4 + ch] = extreme;\n            }\n\n    cairo_surface_mark_dirty (output);\n\n    rsvg_filter_store_result (primitive->result, output, ctx);\n\n    cairo_surface_destroy (in);\n    cairo_surface_destroy (output);\n}\n\nstatic void\nrsvg_filter_primitive_erode_set_atts (RsvgNode *node, gpointer impl, RsvgHandle *handle, RsvgPropertyBag *atts)\n{\n    RsvgFilterPrimitiveErode *filter = impl;\n    const char *value;\n\n    if ((value = rsvg_property_bag_lookup (atts, \"in\")))\n        g_string_assign (filter->super.in, value);\n    if ((value = rsvg_property_bag_lookup (atts, \"result\")))\n        g_string_assign (filter->super.result, value);\n\n    filter_primitive_set_x_y_width_height_atts ((RsvgFilterPrimitive *) filter, atts);\n\n    if ((value = rsvg_property_bag_lookup (atts, \"radius\"))) {\n        if (!rsvg_css_parse_number_optional_number (value, &filter->rx, &filter->ry)) {\n            rsvg_node_set_attribute_parse_error (node, \"radius\", \"expected number-optional-number\");\n            return;\n        }\n    }\n\n    if ((value = rsvg_property_bag_lookup (atts, \"operator\"))) {\n        if (!strcmp (value, \"erode\"))\n            filter->mode = 0;\n        else if (!strcmp (value, \"dilate\"))\n            filter->mode = 1;\n    }\n}\n\nRsvgNode *\nrsvg_new_filter_primitive_erode (const char *element_name, RsvgNode *parent)\n{\n    RsvgFilterPrimitiveErode *filter;\n\n    filter = g_new0 (RsvgFilterPrimitiveErode, 1);\n    filter->super.in = g_string_new (\"none\");\n    filter->super.result = g_string_new (\"none\");\n    filter->rx = 0;\n    filter->ry = 0;\n    filter->mode = 0;\n    filter->super.render = rsvg_filter_primitive_erode_render;\n\n    return rsvg_rust_cnode_new (RSVG_NODE_TYPE_FILTER_PRIMITIVE_ERODE,\n                                parent,\n                                rsvg_state_new (),\n                                filter,\n                                rsvg_filter_primitive_erode_set_atts,\n                                rsvg_filter_draw,\n                                rsvg_filter_primitive_free);\n}\n\n/*************************************************************/\n/*************************************************************/\n\ntypedef enum {\n    COMPOSITE_MODE_OVER, COMPOSITE_MODE_IN, COMPOSITE_MODE_OUT,\n    COMPOSITE_MODE_ATOP, COMPOSITE_MODE_XOR, COMPOSITE_MODE_ARITHMETIC\n} RsvgFilterPrimitiveCompositeMode;\n\ntypedef struct _RsvgFilterPrimitiveComposite RsvgFilterPrimitiveComposite;\nstruct _RsvgFilterPrimitiveComposite {\n    RsvgFilterPrimitive super;\n    RsvgFilterPrimitiveCompositeMode mode;\n    GString *in2;\n\n    int k1, k2, k3, k4;\n};\n\nstatic cairo_operator_t\ncomposite_mode_to_cairo_operator (RsvgFilterPrimitiveCompositeMode mode)\n{\n    switch (mode) {\n    case COMPOSITE_MODE_OVER:\n        return CAIRO_OPERATOR_OVER;\n\n    case COMPOSITE_MODE_IN:\n        return CAIRO_OPERATOR_IN;\n\n    case COMPOSITE_MODE_OUT:\n        return CAIRO_OPERATOR_OUT;\n\n    case COMPOSITE_MODE_ATOP:\n        return CAIRO_OPERATOR_ATOP;\n\n    case COMPOSITE_MODE_XOR:\n        return CAIRO_OPERATOR_XOR;\n\n    default:\n        g_assert_not_reached ();\n        return CAIRO_OPERATOR_CLEAR;\n    }\n}\n\nstatic void\nrsvg_filter_primitive_composite_render (RsvgNode *node, RsvgFilterPrimitive *primitive, RsvgFilterContext *ctx)\n{\n    RsvgFilterPrimitiveComposite *composite = (RsvgFilterPrimitiveComposite *) primitive;\n    RsvgIRect boundarys;\n    cairo_surface_t *output, *in, *in2;\n\n    boundarys = rsvg_filter_primitive_get_bounds (primitive, ctx);\n\n    in = rsvg_filter_get_in (primitive->in, ctx);\n    if (in == NULL)\n        return;\n\n    in2 = rsvg_filter_get_in (composite->in2, ctx);\n    if (in2 == NULL) {\n        cairo_surface_destroy (in);\n        return;\n    }\n\n    if (composite->mode == COMPOSITE_MODE_ARITHMETIC) {\n        guchar i;\n        gint x, y;\n        gint rowstride, height, width;\n        guchar *in_pixels;\n        guchar *in2_pixels;\n        guchar *output_pixels;\n\n        height = cairo_image_surface_get_height (in);\n        width = cairo_image_surface_get_width (in);\n        rowstride = cairo_image_surface_get_stride (in);\n\n        output = _rsvg_image_surface_new (width, height);\n        if (output == NULL) {\n            cairo_surface_destroy (in);\n            cairo_surface_destroy (in2);\n            return;\n        }\n\n        cairo_surface_flush (in);\n        cairo_surface_flush (in2);\n\n        in_pixels = cairo_image_surface_get_data (in);\n        in2_pixels = cairo_image_surface_get_data (in2);\n        output_pixels = cairo_image_surface_get_data (output);\n\n        for (y = boundarys.y0; y < boundarys.y1; y++) {\n            for (x = boundarys.x0; x < boundarys.x1; x++) {\n                int qr, qa, qb;\n\n                qa = in_pixels[4 * x + y * rowstride + 3];\n                qb = in2_pixels[4 * x + y * rowstride + 3];\n                qr = (composite->k1 * qa * qb / 255 + composite->k2 * qa + composite->k3 * qb) / 255;\n\n                if (qr > 255)\n                    qr = 255;\n                if (qr < 0)\n                    qr = 0;\n                output_pixels[4 * x + y * rowstride + 3] = qr;\n                if (qr) {\n                    for (i = 0; i < 3; i++) {\n                        int ca, cb, cr;\n                        ca = in_pixels[4 * x + y * rowstride + i];\n                        cb = in2_pixels[4 * x + y * rowstride + i];\n\n                        cr = (ca * cb * composite->k1 / 255 + ca * composite->k2 +\n                              cb * composite->k3 + composite->k4 * qr) / 255;\n                        if (cr > qr)\n                            cr = qr;\n                        if (cr < 0)\n                            cr = 0;\n                        output_pixels[4 * x + y * rowstride + i] = cr;\n                    }\n                }\n            }\n        }\n\n        cairo_surface_mark_dirty (output);\n    } else {\n        cairo_t *cr;\n\n        cairo_surface_reference (in2);\n        output = in2;\n\n        cr = cairo_create (output);\n        cairo_set_source_surface (cr, in, 0, 0);\n        cairo_rectangle (cr,\n                         boundarys.x0,\n                         boundarys.y0,\n                         boundarys.x1 - boundarys.x0,\n                         boundarys.y1 - boundarys.y0);\n        cairo_clip (cr);\n        cairo_set_operator (cr, composite_mode_to_cairo_operator (composite->mode));\n        cairo_paint (cr);\n        cairo_destroy (cr);\n    }\n\n    rsvg_filter_store_result (primitive->result, output, ctx);\n\n    cairo_surface_destroy (in);\n    cairo_surface_destroy (in2);\n    cairo_surface_destroy (output);\n}\n\nstatic void\nrsvg_filter_primitive_composite_free (gpointer impl)\n{\n    RsvgFilterPrimitiveComposite *composite = impl;\n\n    g_string_free (composite->in2, TRUE);\n\n    rsvg_filter_primitive_free (impl);\n}\n\nstatic void\nrsvg_filter_primitive_composite_set_atts (RsvgNode *node, gpointer impl, RsvgHandle *handle, RsvgPropertyBag *atts)\n{\n    RsvgFilterPrimitiveComposite *filter = impl;\n    const char *value;\n\n    if ((value = rsvg_property_bag_lookup (atts, \"operator\"))) {\n        if (!strcmp (value, \"in\"))\n            filter->mode = COMPOSITE_MODE_IN;\n        else if (!strcmp (value, \"out\"))\n            filter->mode = COMPOSITE_MODE_OUT;\n        else if (!strcmp (value, \"atop\"))\n            filter->mode = COMPOSITE_MODE_ATOP;\n        else if (!strcmp (value, \"xor\"))\n            filter->mode = COMPOSITE_MODE_XOR;\n        else if (!strcmp (value, \"arithmetic\"))\n            filter->mode = COMPOSITE_MODE_ARITHMETIC;\n        else\n            filter->mode = COMPOSITE_MODE_OVER;\n    }\n    if ((value = rsvg_property_bag_lookup (atts, \"in\")))\n        g_string_assign (filter->super.in, value);\n    if ((value = rsvg_property_bag_lookup (atts, \"in2\")))\n        g_string_assign (filter->in2, value);\n    if ((value = rsvg_property_bag_lookup (atts, \"result\")))\n        g_string_assign (filter->super.result, value);\n\n    filter_primitive_set_x_y_width_height_atts ((RsvgFilterPrimitive *) filter, atts);\n\n    if ((value = rsvg_property_bag_lookup (atts, \"k1\")))\n        filter->k1 = g_ascii_strtod (value, NULL) * 255.;\n    if ((value = rsvg_property_bag_lookup (atts, \"k2\")))\n        filter->k2 = g_ascii_strtod (value, NULL) * 255.;\n    if ((value = rsvg_property_bag_lookup (atts, \"k3\")))\n        filter->k3 = g_ascii_strtod (value, NULL) * 255.;\n    if ((value = rsvg_property_bag_lookup (atts, \"k4\")))\n        filter->k4 = g_ascii_strtod (value, NULL) * 255.;\n}\n\nRsvgNode *\nrsvg_new_filter_primitive_composite (const char *element_name, RsvgNode *parent)\n{\n    RsvgFilterPrimitiveComposite *filter;\n\n    filter = g_new0 (RsvgFilterPrimitiveComposite, 1);\n    filter->mode = COMPOSITE_MODE_OVER;\n    filter->super.in = g_string_new (\"none\");\n    filter->in2 = g_string_new (\"none\");\n    filter->super.result = g_string_new (\"none\");\n    filter->k1 = 0;\n    filter->k2 = 0;\n    filter->k3 = 0;\n    filter->k4 = 0;\n    filter->super.render = rsvg_filter_primitive_composite_render;\n\n    return rsvg_rust_cnode_new (RSVG_NODE_TYPE_FILTER_PRIMITIVE_COMPOSITE,\n                                parent,\n                                rsvg_state_new (),\n                                filter,\n                                rsvg_filter_primitive_composite_set_atts,\n                                rsvg_filter_draw,\n                                rsvg_filter_primitive_composite_free);\n}\n\n/*************************************************************/\n/*************************************************************/\n\nstatic void\nrsvg_filter_primitive_flood_render (RsvgNode *node, RsvgFilterPrimitive *primitive, RsvgFilterContext *ctx)\n{\n    RsvgState *state;\n    guchar i;\n    gint x, y;\n    gint rowstride, height, width;\n    RsvgIRect boundarys;\n    guchar *output_pixels;\n    cairo_surface_t *output;\n    char pixcolor[4];\n    RsvgFilterPrimitiveOutput out;\n\n    state = rsvg_node_get_state (node);\n\n    guint32 color = state->flood_color;\n    guint8 opacity = state->flood_opacity;\n\n    boundarys = rsvg_filter_primitive_get_bounds (primitive, ctx);\n\n    height = ctx->height;\n    width = ctx->width;\n    output = _rsvg_image_surface_new (width, height);\n    if (output == NULL)\n        return;\n\n    rowstride = cairo_image_surface_get_stride (output);\n\n    output_pixels = cairo_image_surface_get_data (output);\n\n    for (i = 0; i < 3; i++)\n        pixcolor[i] = (int) (((unsigned char *)\n                              (&color))[2 - i]) * opacity / 255;\n    pixcolor[3] = opacity;\n\n    for (y = boundarys.y0; y < boundarys.y1; y++)\n        for (x = boundarys.x0; x < boundarys.x1; x++)\n            for (i = 0; i < 4; i++)\n                output_pixels[4 * x + y * rowstride + ctx->channelmap[i]] = pixcolor[i];\n\n    cairo_surface_mark_dirty (output);\n\n    out.surface = output;\n    out.bounds = boundarys;\n\n    rsvg_filter_store_output (primitive->result, out, ctx);\n\n    cairo_surface_destroy (output);\n}\n\nstatic void\nrsvg_filter_primitive_flood_set_atts (RsvgNode *node, gpointer impl, RsvgHandle *handle, RsvgPropertyBag *atts)\n{\n    RsvgFilterPrimitive *filter = impl;\n    const char *value;\n\n    if ((value = rsvg_property_bag_lookup (atts, \"result\")))\n        g_string_assign (filter->result, value);\n\n    filter_primitive_set_x_y_width_height_atts ((RsvgFilterPrimitive *) filter, atts);\n}\n\nRsvgNode *\nrsvg_new_filter_primitive_flood (const char *element_name, RsvgNode *parent)\n{\n    RsvgFilterPrimitive *filter;\n\n    filter = g_new0 (RsvgFilterPrimitive, 1);\n    filter->in = g_string_new (\"none\");\n    filter->result = g_string_new (\"none\");\n    filter->render = rsvg_filter_primitive_flood_render;\n\n    return rsvg_rust_cnode_new (RSVG_NODE_TYPE_FILTER_PRIMITIVE_FLOOD,\n                                parent,\n                                rsvg_state_new (),\n                                filter,\n                                rsvg_filter_primitive_flood_set_atts,\n                                rsvg_filter_draw,\n                                rsvg_filter_primitive_free);\n}\n\n/*************************************************************/\n/*************************************************************/\n\ntypedef struct _RsvgFilterPrimitiveDisplacementMap RsvgFilterPrimitiveDisplacementMap;\n\nstruct _RsvgFilterPrimitiveDisplacementMap {\n    RsvgFilterPrimitive super;\n    gint dx, dy;\n    char xChannelSelector, yChannelSelector;\n    GString *in2;\n    double scale;\n};\n\nstatic void\nrsvg_filter_primitive_displacement_map_render (RsvgNode *node, RsvgFilterPrimitive *primitive, RsvgFilterContext *ctx)\n{\n    RsvgFilterPrimitiveDisplacementMap *displacement_map = (RsvgFilterPrimitiveDisplacementMap *) primitive;\n    guchar ch, xch, ych;\n    gint x, y;\n    gint rowstride, height, width;\n    RsvgIRect boundarys;\n\n    guchar *in_pixels;\n    guchar *in2_pixels;\n    guchar *output_pixels;\n\n    cairo_surface_t *output, *in, *in2;\n\n    double ox, oy;\n\n    boundarys = rsvg_filter_primitive_get_bounds (primitive, ctx);\n\n    in = rsvg_filter_get_in (primitive->in, ctx);\n    if (in == NULL)\n        return;\n\n    cairo_surface_flush (in);\n\n    in2 = rsvg_filter_get_in (displacement_map->in2, ctx);\n    if (in2 == NULL) {\n        cairo_surface_destroy (in);\n        return;\n    }\n\n    cairo_surface_flush (in2);\n\n    in_pixels = cairo_image_surface_get_data (in);\n    in2_pixels = cairo_image_surface_get_data (in2);\n\n    height = cairo_image_surface_get_height (in);\n    width = cairo_image_surface_get_width (in);\n\n    rowstride = cairo_image_surface_get_stride (in);\n\n    output = _rsvg_image_surface_new (width, height);\n    if (output == NULL) {\n        cairo_surface_destroy (in);\n        cairo_surface_destroy (in2);\n        return;\n    }\n\n    output_pixels = cairo_image_surface_get_data (output);\n\n    switch (displacement_map->xChannelSelector) {\n    case 'R':\n        xch = 0;\n        break;\n    case 'G':\n        xch = 1;\n        break;\n    case 'B':\n        xch = 2;\n        break;\n    case 'A':\n        xch = 3;\n        break;\n    default:\n        xch = 0;\n        break;\n    }\n\n    switch (displacement_map->yChannelSelector) {\n    case 'R':\n        ych = 0;\n        break;\n    case 'G':\n        ych = 1;\n        break;\n    case 'B':\n        ych = 2;\n        break;\n    case 'A':\n        ych = 3;\n        break;\n    default:\n        ych = 1;\n        break;\n    }\n\n    xch = ctx->channelmap[xch];\n    ych = ctx->channelmap[ych];\n    for (y = boundarys.y0; y < boundarys.y1; y++)\n        for (x = boundarys.x0; x < boundarys.x1; x++) {\n            if (xch != 4)\n                ox = x + displacement_map->scale * ctx->paffine.xx *\n                    ((double) in2_pixels[y * rowstride + x * 4 + xch] / 255.0 - 0.5);\n            else\n                ox = x;\n\n            if (ych != 4)\n                oy = y + displacement_map->scale * ctx->paffine.yy *\n                    ((double) in2_pixels[y * rowstride + x * 4 + ych] / 255.0 - 0.5);\n            else\n                oy = y;\n\n            for (ch = 0; ch < 4; ch++) {\n                output_pixels[y * rowstride + x * 4 + ch] =\n                    get_interp_pixel (in_pixels, ox, oy, ch, boundarys, rowstride);\n            }\n        }\n\n    cairo_surface_mark_dirty (output);\n\n    rsvg_filter_store_result (primitive->result, output, ctx);\n\n    cairo_surface_destroy (in);\n    cairo_surface_destroy (in2);\n    cairo_surface_destroy (output);\n}\n\nstatic void\nrsvg_filter_primitive_displacement_map_free (gpointer impl)\n{\n    RsvgFilterPrimitiveDisplacementMap *dmap = impl;\n\n    g_string_free (dmap->in2, TRUE);\n\n    rsvg_filter_primitive_free (impl);\n}\n\nstatic void\nrsvg_filter_primitive_displacement_map_set_atts (RsvgNode *node, gpointer impl, RsvgHandle *handle, RsvgPropertyBag *atts)\n{\n    RsvgFilterPrimitiveDisplacementMap *filter = impl;\n    const char *value;\n\n    if ((value = rsvg_property_bag_lookup (atts, \"in\")))\n        g_string_assign (filter->super.in, value);\n    if ((value = rsvg_property_bag_lookup (atts, \"in2\")))\n        g_string_assign (filter->in2, value);\n    if ((value = rsvg_property_bag_lookup (atts, \"result\")))\n        g_string_assign (filter->super.result, value);\n\n    filter_primitive_set_x_y_width_height_atts ((RsvgFilterPrimitive *) filter, atts);\n\n    if ((value = rsvg_property_bag_lookup (atts, \"xChannelSelector\")))\n        filter->xChannelSelector = (value)[0];\n    if ((value = rsvg_property_bag_lookup (atts, \"yChannelSelector\")))\n        filter->yChannelSelector = (value)[0];\n    if ((value = rsvg_property_bag_lookup (atts, \"scale\")))\n        filter->scale = g_ascii_strtod (value, NULL);\n}\n\nRsvgNode *\nrsvg_new_filter_primitive_displacement_map (const char *element_name, RsvgNode *parent)\n{\n    RsvgFilterPrimitiveDisplacementMap *filter;\n\n    filter = g_new0 (RsvgFilterPrimitiveDisplacementMap, 1);\n    filter->super.in = g_string_new (\"none\");\n    filter->in2 = g_string_new (\"none\");\n    filter->super.result = g_string_new (\"none\");\n    filter->xChannelSelector = ' ';\n    filter->yChannelSelector = ' ';\n    filter->scale = 0;\n    filter->super.render = rsvg_filter_primitive_displacement_map_render;\n\n    return rsvg_rust_cnode_new (RSVG_NODE_TYPE_FILTER_PRIMITIVE_DISPLACEMENT_MAP,\n                                parent,\n                                rsvg_state_new (),\n                                filter,\n                                rsvg_filter_primitive_displacement_map_set_atts,\n                                rsvg_filter_draw,\n                                rsvg_filter_primitive_displacement_map_free);\n}\n\n/*************************************************************/\n/*************************************************************/\n\n/* Produces results in the range [1, 2**31 - 2].\n   Algorithm is: r = (a * r) mod m\n   where a = 16807 and m = 2**31 - 1 = 2147483647\n   See [Park & Miller], CACM vol. 31 no. 10 p. 1195, Oct. 1988\n   To test: the algorithm should produce the result 1043618065\n   as the 10,000th generated number if the original seed is 1.\n*/\n#define feTurbulence_RAND_m 2147483647  /* 2**31 - 1 */\n#define feTurbulence_RAND_a 16807       /* 7**5; primitive root of m */\n#define feTurbulence_RAND_q 127773      /* m / a */\n#define feTurbulence_RAND_r 2836        /* m % a */\n#define feTurbulence_BSize 0x100\n#define feTurbulence_BM 0xff\n#define feTurbulence_PerlinN 0x1000\n#define feTurbulence_NP 12      /* 2^PerlinN */\n#define feTurbulence_NM 0xfff\n\ntypedef struct _RsvgFilterPrimitiveTurbulence RsvgFilterPrimitiveTurbulence;\nstruct _RsvgFilterPrimitiveTurbulence {\n    RsvgFilterPrimitive super;\n\n    int uLatticeSelector[feTurbulence_BSize + feTurbulence_BSize + 2];\n    double fGradient[4][feTurbulence_BSize + feTurbulence_BSize + 2][2];\n\n    int seed;\n\n    double fBaseFreqX;\n    double fBaseFreqY;\n\n    int nNumOctaves;\n    gboolean bFractalSum;\n    gboolean bDoStitching;\n};\n\nstruct feTurbulence_StitchInfo {\n    int nWidth;                 /* How much to subtract to wrap for stitching. */\n    int nHeight;\n    int nWrapX;                 /* Minimum value to wrap. */\n    int nWrapY;\n};\n\nstatic long\nfeTurbulence_setup_seed (int lSeed)\n{\n    if (lSeed <= 0)\n        lSeed = -(lSeed % (feTurbulence_RAND_m - 1)) + 1;\n    if (lSeed > feTurbulence_RAND_m - 1)\n        lSeed = feTurbulence_RAND_m - 1;\n    return lSeed;\n}\n\nstatic long\nfeTurbulence_random (int lSeed)\n{\n    long result;\n\n    result =\n        feTurbulence_RAND_a * (lSeed % feTurbulence_RAND_q) -\n        feTurbulence_RAND_r * (lSeed / feTurbulence_RAND_q);\n    if (result <= 0)\n        result += feTurbulence_RAND_m;\n    return result;\n}\n\nstatic void\nfeTurbulence_init (RsvgFilterPrimitiveTurbulence * filter)\n{\n    double s;\n    int i, j, k, lSeed;\n\n    lSeed = feTurbulence_setup_seed (filter->seed);\n    for (k = 0; k < 4; k++) {\n        for (i = 0; i < feTurbulence_BSize; i++) {\n            filter->uLatticeSelector[i] = i;\n            for (j = 0; j < 2; j++)\n                filter->fGradient[k][i][j] =\n                    (double) (((lSeed =\n                                feTurbulence_random (lSeed)) % (feTurbulence_BSize +\n                                                                feTurbulence_BSize)) -\n                              feTurbulence_BSize) / feTurbulence_BSize;\n            s = (double) (sqrt\n                          (filter->fGradient[k][i][0] * filter->fGradient[k][i][0] +\n                           filter->fGradient[k][i][1] * filter->fGradient[k][i][1]));\n            filter->fGradient[k][i][0] /= s;\n            filter->fGradient[k][i][1] /= s;\n        }\n    }\n\n    while (--i) {\n        k = filter->uLatticeSelector[i];\n        filter->uLatticeSelector[i] = filter->uLatticeSelector[j =\n                                                               (lSeed =\n                                                                feTurbulence_random (lSeed)) %\n                                                               feTurbulence_BSize];\n        filter->uLatticeSelector[j] = k;\n    }\n\n    for (i = 0; i < feTurbulence_BSize + 2; i++) {\n        filter->uLatticeSelector[feTurbulence_BSize + i] = filter->uLatticeSelector[i];\n        for (k = 0; k < 4; k++)\n            for (j = 0; j < 2; j++)\n                filter->fGradient[k][feTurbulence_BSize + i][j] = filter->fGradient[k][i][j];\n    }\n}\n\n#define feTurbulence_s_curve(t) ( t * t * (3. - 2. * t) )\n#define feTurbulence_lerp(t, a, b) ( a + t * (b - a) )\n\nstatic double\nfeTurbulence_noise2 (RsvgFilterPrimitiveTurbulence * filter,\n                     int nColorChannel, double vec[2], struct feTurbulence_StitchInfo *pStitchInfo)\n{\n    int bx0, bx1, by0, by1, b00, b10, b01, b11;\n    double rx0, rx1, ry0, ry1, *q, sx, sy, a, b, t, u, v;\n    register int i, j;\n\n    t = vec[0] + feTurbulence_PerlinN;\n    bx0 = (int) t;\n    bx1 = bx0 + 1;\n    rx0 = t - (int) t;\n    rx1 = rx0 - 1.0f;\n    t = vec[1] + feTurbulence_PerlinN;\n    by0 = (int) t;\n    by1 = by0 + 1;\n    ry0 = t - (int) t;\n    ry1 = ry0 - 1.0f;\n\n    /* If stitching, adjust lattice points accordingly. */\n    if (pStitchInfo != NULL) {\n        if (bx0 >= pStitchInfo->nWrapX)\n            bx0 -= pStitchInfo->nWidth;\n        if (bx1 >= pStitchInfo->nWrapX)\n            bx1 -= pStitchInfo->nWidth;\n        if (by0 >= pStitchInfo->nWrapY)\n            by0 -= pStitchInfo->nHeight;\n        if (by1 >= pStitchInfo->nWrapY)\n            by1 -= pStitchInfo->nHeight;\n    }\n\n    bx0 &= feTurbulence_BM;\n    bx1 &= feTurbulence_BM;\n    by0 &= feTurbulence_BM;\n    by1 &= feTurbulence_BM;\n    i = filter->uLatticeSelector[bx0];\n    j = filter->uLatticeSelector[bx1];\n    b00 = filter->uLatticeSelector[i + by0];\n    b10 = filter->uLatticeSelector[j + by0];\n    b01 = filter->uLatticeSelector[i + by1];\n    b11 = filter->uLatticeSelector[j + by1];\n    sx = (double) (feTurbulence_s_curve (rx0));\n    sy = (double) (feTurbulence_s_curve (ry0));\n    q = filter->fGradient[nColorChannel][b00];\n    u = rx0 * q[0] + ry0 * q[1];\n    q = filter->fGradient[nColorChannel][b10];\n    v = rx1 * q[0] + ry0 * q[1];\n    a = feTurbulence_lerp (sx, u, v);\n    q = filter->fGradient[nColorChannel][b01];\n    u = rx0 * q[0] + ry1 * q[1];\n    q = filter->fGradient[nColorChannel][b11];\n    v = rx1 * q[0] + ry1 * q[1];\n    b = feTurbulence_lerp (sx, u, v);\n\n    return feTurbulence_lerp (sy, a, b);\n}\n\nstatic double\nfeTurbulence_turbulence (RsvgFilterPrimitiveTurbulence * filter,\n                         int nColorChannel, double *point,\n                         double fTileX, double fTileY, double fTileWidth, double fTileHeight)\n{\n    struct feTurbulence_StitchInfo stitch;\n    struct feTurbulence_StitchInfo *pStitchInfo = NULL; /* Not stitching when NULL. */\n\n    double fSum = 0.0f, vec[2], ratio = 1.;\n    int nOctave;\n\n    /* Adjust the base frequencies if necessary for stitching. */\n    if (filter->bDoStitching) {\n        /* When stitching tiled turbulence, the frequencies must be adjusted\n           so that the tile borders will be continuous. */\n        if (filter->fBaseFreqX != 0.0) {\n            double fLoFreq = (double) (floor (fTileWidth * filter->fBaseFreqX)) / fTileWidth;\n            double fHiFreq = (double) (ceil (fTileWidth * filter->fBaseFreqX)) / fTileWidth;\n            if (filter->fBaseFreqX / fLoFreq < fHiFreq / filter->fBaseFreqX)\n                filter->fBaseFreqX = fLoFreq;\n            else\n                filter->fBaseFreqX = fHiFreq;\n        }\n\n        if (filter->fBaseFreqY != 0.0) {\n            double fLoFreq = (double) (floor (fTileHeight * filter->fBaseFreqY)) / fTileHeight;\n            double fHiFreq = (double) (ceil (fTileHeight * filter->fBaseFreqY)) / fTileHeight;\n            if (filter->fBaseFreqY / fLoFreq < fHiFreq / filter->fBaseFreqY)\n                filter->fBaseFreqY = fLoFreq;\n            else\n                filter->fBaseFreqY = fHiFreq;\n        }\n\n        /* Set up initial stitch values. */\n        pStitchInfo = &stitch;\n        stitch.nWidth = (int) (fTileWidth * filter->fBaseFreqX + 0.5f);\n        stitch.nWrapX = fTileX * filter->fBaseFreqX + feTurbulence_PerlinN + stitch.nWidth;\n        stitch.nHeight = (int) (fTileHeight * filter->fBaseFreqY + 0.5f);\n        stitch.nWrapY = fTileY * filter->fBaseFreqY + feTurbulence_PerlinN + stitch.nHeight;\n    }\n\n    vec[0] = point[0] * filter->fBaseFreqX;\n    vec[1] = point[1] * filter->fBaseFreqY;\n\n    for (nOctave = 0; nOctave < filter->nNumOctaves; nOctave++) {\n        if (filter->bFractalSum)\n            fSum +=\n                (double) (feTurbulence_noise2 (filter, nColorChannel, vec, pStitchInfo) / ratio);\n        else\n            fSum +=\n                (double) (fabs (feTurbulence_noise2 (filter, nColorChannel, vec, pStitchInfo)) /\n                          ratio);\n\n        vec[0] *= 2;\n        vec[1] *= 2;\n        ratio *= 2;\n\n        if (pStitchInfo != NULL) {\n            /* Update stitch values. Subtracting PerlinN before the multiplication and\n               adding it afterward simplifies to subtracting it once. */\n            stitch.nWidth *= 2;\n            stitch.nWrapX = 2 * stitch.nWrapX - feTurbulence_PerlinN;\n            stitch.nHeight *= 2;\n            stitch.nWrapY = 2 * stitch.nWrapY - feTurbulence_PerlinN;\n        }\n    }\n\n    return fSum;\n}\n\nstatic void\nrsvg_filter_primitive_turbulence_render (RsvgNode *node, RsvgFilterPrimitive *primitive, RsvgFilterContext *ctx)\n{\n    RsvgFilterPrimitiveTurbulence *turbulence = (RsvgFilterPrimitiveTurbulence *) primitive;\n\n    gint x, y, tileWidth, tileHeight, rowstride, width, height;\n    RsvgIRect boundarys;\n    guchar *output_pixels;\n    cairo_surface_t *output, *in;\n    cairo_matrix_t affine;\n\n    affine = ctx->paffine;\n    if (cairo_matrix_invert (&affine) != CAIRO_STATUS_SUCCESS)\n      return;\n\n    in = rsvg_filter_get_in (primitive->in, ctx);\n    if (in == NULL)\n        return;\n\n    cairo_surface_flush (in);\n\n    height = cairo_image_surface_get_height (in);\n    width = cairo_image_surface_get_width (in);\n    rowstride = cairo_image_surface_get_stride (in);\n\n    boundarys = rsvg_filter_primitive_get_bounds (primitive, ctx);\n\n    tileWidth = (boundarys.x1 - boundarys.x0);\n    tileHeight = (boundarys.y1 - boundarys.y0);\n\n    output = _rsvg_image_surface_new (width, height);\n    if (output == NULL) {\n        cairo_surface_destroy (in);\n        return;\n    }\n\n    output_pixels = cairo_image_surface_get_data (output);\n\n    for (y = 0; y < tileHeight; y++) {\n        for (x = 0; x < tileWidth; x++) {\n            gint i;\n            double point[2];\n            guchar *pixel;\n            point[0] = affine.xx * (x + boundarys.x0) + affine.xy * (y + boundarys.y0) + affine.x0;\n            point[1] = affine.yx * (x + boundarys.x0) + affine.yy * (y + boundarys.y0) + affine.y0;\n\n            pixel = output_pixels + 4 * (x + boundarys.x0) + (y + boundarys.y0) * rowstride;\n\n            for (i = 0; i < 4; i++) {\n                double cr;\n\n                cr = feTurbulence_turbulence (turbulence, i, point, (double) x, (double) y,\n                                              (double) tileWidth, (double) tileHeight);\n\n                if (turbulence->bFractalSum)\n                    cr = ((cr * 255.) + 255.) / 2.;\n                else\n                    cr = (cr * 255.);\n\n                cr = CLAMP (cr, 0., 255.);\n\n                pixel[ctx->channelmap[i]] = (guchar) cr;\n            }\n            for (i = 0; i < 3; i++)\n                pixel[ctx->channelmap[i]] =\n                    pixel[ctx->channelmap[i]] * pixel[ctx->channelmap[3]] / 255;\n\n        }\n    }\n\n    cairo_surface_mark_dirty (output);\n\n    rsvg_filter_store_result (primitive->result, output, ctx);\n\n    cairo_surface_destroy (in);\n    cairo_surface_destroy (output);\n}\n\nstatic void\nrsvg_filter_primitive_turbulence_set_atts (RsvgNode *node, gpointer impl, RsvgHandle *handle, RsvgPropertyBag *atts)\n{\n    RsvgFilterPrimitiveTurbulence *filter = impl;\n    const char *value;\n\n    if ((value = rsvg_property_bag_lookup (atts, \"in\")))\n        g_string_assign (filter->super.in, value);\n    if ((value = rsvg_property_bag_lookup (atts, \"result\")))\n        g_string_assign (filter->super.result, value);\n\n    filter_primitive_set_x_y_width_height_atts ((RsvgFilterPrimitive *) filter, atts);\n\n    if ((value = rsvg_property_bag_lookup (atts, \"baseFrequency\"))) {\n        if (!rsvg_css_parse_number_optional_number (value, &filter->fBaseFreqX, &filter->fBaseFreqY)) {\n            rsvg_node_set_attribute_parse_error (node, \"baseFrequency\", \"expected number-optional-number\");\n            return;\n        }\n    }\n\n    if ((value = rsvg_property_bag_lookup (atts, \"numOctaves\")))\n        filter->nNumOctaves = atoi (value);\n    if ((value = rsvg_property_bag_lookup (atts, \"seed\")))\n        filter->seed = atoi (value);\n    if ((value = rsvg_property_bag_lookup (atts, \"stitchTiles\")))\n        filter->bDoStitching = (!strcmp (value, \"stitch\"));\n    if ((value = rsvg_property_bag_lookup (atts, \"type\")))\n        filter->bFractalSum = (!strcmp (value, \"fractalNoise\"));\n}\n\nRsvgNode *\nrsvg_new_filter_primitive_turbulence (const char *element_name, RsvgNode *parent)\n{\n    RsvgFilterPrimitiveTurbulence *filter;\n\n    filter = g_new0 (RsvgFilterPrimitiveTurbulence, 1);\n    filter->super.in = g_string_new (\"none\");\n    filter->super.result = g_string_new (\"none\");\n    filter->fBaseFreqX = 0;\n    filter->fBaseFreqY = 0;\n    filter->nNumOctaves = 1;\n    filter->seed = 0;\n    filter->bDoStitching = 0;\n    filter->bFractalSum = 0;\n\n    feTurbulence_init (filter);\n\n    filter->super.render = rsvg_filter_primitive_turbulence_render;\n\n    return rsvg_rust_cnode_new (RSVG_NODE_TYPE_FILTER_PRIMITIVE_TURBULENCE,\n                                parent,\n                                rsvg_state_new (),\n                                filter,\n                                rsvg_filter_primitive_turbulence_set_atts,\n                                rsvg_filter_draw,\n                                rsvg_filter_primitive_free);\n}\n\n\n/*************************************************************/\n/*************************************************************/\n\ntypedef struct _RsvgFilterPrimitiveImage RsvgFilterPrimitiveImage;\n\nstruct _RsvgFilterPrimitiveImage {\n    RsvgFilterPrimitive super;\n    RsvgHandle *ctx;\n    GString *href;\n};\n\nstatic cairo_surface_t *\nrsvg_filter_primitive_image_render_in (RsvgFilterPrimitiveImage *image, RsvgFilterContext * context)\n{\n    RsvgDrawingCtx *ctx;\n    RsvgNode *drawable;\n    cairo_surface_t *result;\n\n    ctx = context->ctx;\n\n    if (!image->href)\n        return NULL;\n\n    drawable = rsvg_drawing_ctx_acquire_node (ctx, image->href->str);\n    if (!drawable)\n        return NULL;\n\n    rsvg_current_state (ctx)->affine = context->paffine;\n\n    result = rsvg_get_surface_of_node (ctx, drawable, context->width, context->height);\n\n    rsvg_drawing_ctx_release_node (ctx, drawable);\n\n    return result;\n}\n\nstatic cairo_surface_t *\nrsvg_filter_primitive_image_render_ext (RsvgFilterPrimitive *self, RsvgFilterContext * ctx)\n{\n    RsvgFilterPrimitiveImage *image = (RsvgFilterPrimitiveImage *) self;\n    RsvgIRect boundarys;\n    cairo_surface_t *img, *intermediate;\n    int i;\n    unsigned char *pixels;\n    int channelmap[4];\n    int length;\n    int width, height;\n\n    if (!image->href)\n        return NULL;\n\n    boundarys = rsvg_filter_primitive_get_bounds (self, ctx);\n\n    width = boundarys.x1 - boundarys.x0;\n    height = boundarys.y1 - boundarys.y0;\n    if (width == 0 || height == 0)\n        return NULL;\n\n    img = rsvg_cairo_surface_new_from_href (image->ctx,\n                                            image->href->str,\n                                            NULL);\n    if (!img)\n        return NULL;\n\n    intermediate = cairo_image_surface_create (CAIRO_FORMAT_ARGB32, width, height);\n    if (cairo_surface_status (intermediate) != CAIRO_STATUS_SUCCESS ||\n        !rsvg_art_affine_image (img, intermediate,\n                                &ctx->paffine,\n                                (gdouble) width / ctx->paffine.xx,\n                                (gdouble) height / ctx->paffine.yy)) {\n        cairo_surface_destroy (intermediate);\n        cairo_surface_destroy (img);\n        return NULL;\n    }\n\n    cairo_surface_destroy (img);\n\n    length = cairo_image_surface_get_height (intermediate) *\n             cairo_image_surface_get_stride (intermediate);\n    for (i = 0; i < 4; i++)\n        channelmap[i] = ctx->channelmap[i];\n    pixels = cairo_image_surface_get_data (intermediate);\n    for (i = 0; i < length; i += 4) {\n        unsigned char alpha;\n        unsigned char pixel[4];\n        int ch;\n        alpha = pixels[i + 3];\n\n        pixel[channelmap[3]] = alpha;\n        if (alpha)\n            for (ch = 0; ch < 3; ch++)\n                pixel[channelmap[ch]] = pixels[i + ch] * alpha / 255;\n        else\n            for (ch = 0; ch < 3; ch++)\n                pixel[channelmap[ch]] = 0;\n        for (ch = 0; ch < 4; ch++)\n            pixels[i + ch] = pixel[ch];\n    }\n\n    cairo_surface_mark_dirty (intermediate);\n    return intermediate;\n}\n\nstatic void\nrsvg_filter_primitive_image_render (RsvgNode *node, RsvgFilterPrimitive *primitive, RsvgFilterContext *ctx)\n{\n    RsvgFilterPrimitiveImage *image = (RsvgFilterPrimitiveImage *) primitive;\n\n    RsvgIRect boundarys;\n    RsvgFilterPrimitiveOutput op;\n    cairo_surface_t *output, *img;\n\n    if (!image->href)\n        return;\n\n    boundarys = rsvg_filter_primitive_get_bounds (primitive, ctx);\n\n    output = _rsvg_image_surface_new (ctx->width, ctx->height);\n    if (output == NULL)\n        return;\n\n    img = rsvg_filter_primitive_image_render_in (image, ctx);\n    if (img == NULL) {\n        img = rsvg_filter_primitive_image_render_ext (primitive, ctx);\n    }\n\n    if (img) {\n        cairo_t *cr;\n\n        cr = cairo_create (output);\n        cairo_set_source_surface (cr, img, 0, 0);\n        cairo_rectangle (cr,\n                         boundarys.x0,\n                         boundarys.y0,\n                         boundarys.x1 - boundarys.x0,\n                         boundarys.y1 - boundarys.y0);\n        cairo_clip (cr);\n        cairo_paint (cr);\n        cairo_destroy (cr);\n\n        cairo_surface_destroy (img);\n    }\n\n    op.surface = output;\n    op.bounds = boundarys;\n\n    rsvg_filter_store_output (primitive->result, op, ctx);\n\n    cairo_surface_destroy (output);\n}\n\nstatic void\nrsvg_filter_primitive_image_free (gpointer impl)\n{\n    RsvgFilterPrimitiveImage *image = impl;\n\n    if (image->href)\n        g_string_free (image->href, TRUE);\n\n    rsvg_filter_primitive_free (impl);\n}\n\nstatic void\nrsvg_filter_primitive_image_set_atts (RsvgNode *node, gpointer impl, RsvgHandle *handle, RsvgPropertyBag *atts)\n{\n    RsvgFilterPrimitiveImage *filter = impl;\n    const char *value;\n\n    filter->ctx = handle;\n\n    if ((value = rsvg_property_bag_lookup (atts, \"in\")))\n        g_string_assign (filter->super.in, value);\n    if ((value = rsvg_property_bag_lookup (atts, \"result\")))\n        g_string_assign (filter->super.result, value);\n    if ((value = rsvg_property_bag_lookup (atts, \"xlink:href\"))) {\n        filter->href = g_string_new (NULL);\n        g_string_assign (filter->href, value);\n    }\n\n    filter_primitive_set_x_y_width_height_atts ((RsvgFilterPrimitive *) filter, atts);\n}\n\nRsvgNode *\nrsvg_new_filter_primitive_image (const char *element_name, RsvgNode *parent)\n{\n    RsvgFilterPrimitiveImage *filter;\n\n    filter = g_new0 (RsvgFilterPrimitiveImage, 1);\n    filter->super.in = g_string_new (\"none\");\n    filter->super.result = g_string_new (\"none\");\n    filter->super.render = rsvg_filter_primitive_image_render;\n    filter->href = NULL;\n\n    return rsvg_rust_cnode_new (RSVG_NODE_TYPE_FILTER_PRIMITIVE_IMAGE,\n                                parent,\n                                rsvg_state_new (),\n                                filter,\n                                rsvg_filter_primitive_image_set_atts,\n                                rsvg_filter_draw,\n                                rsvg_filter_primitive_image_free);\n}\n\n/*************************************************************/\n/*************************************************************/\n\n\ntypedef struct _FactorAndMatrix FactorAndMatrix;\n\nstruct _FactorAndMatrix {\n    gint matrix[9];\n    gdouble factor;\n};\n\ntypedef struct _vector3 vector3;\n\nstruct _vector3 {\n    gdouble x;\n    gdouble y;\n    gdouble z;\n};\n\nstatic gdouble\nnorm (vector3 A)\n{\n    return sqrt (A.x * A.x + A.y * A.y + A.z * A.z);\n}\n\nstatic gdouble\ndotproduct (vector3 A, vector3 B)\n{\n    return A.x * B.x + A.y * B.y + A.z * B.z;\n}\n\nstatic vector3\nnormalise (vector3 A)\n{\n    double divisor;\n    divisor = norm (A);\n\n    A.x /= divisor;\n    A.y /= divisor;\n    A.z /= divisor;\n\n    return A;\n}\n\nstatic FactorAndMatrix\nget_light_normal_matrix_x (gint n)\n{\n    static const FactorAndMatrix matrix_list[] = {\n        {\n         {0, 0, 0,\n          0, -2, 2,\n          0, -1, 1},\n         2.0 / 3.0},\n        {\n         {0, 0, 0,\n          -2, 0, 2,\n          -1, 0, 1},\n         1.0 / 3.0},\n        {\n         {0, 0, 0,\n          -2, 2, 0,\n          -1, 1, 0},\n         2.0 / 3.0},\n        {\n         {0, -1, 1,\n          0, -2, 2,\n          0, -1, 1},\n         1.0 / 2.0},\n        {\n         {-1, 0, 1,\n          -2, 0, 2,\n          -1, 0, 1},\n         1.0 / 4.0},\n        {\n         {-1, 1, 0,\n          -2, 2, 0,\n          -1, 1, 0},\n         1.0 / 2.0},\n        {\n         {0, -1, 1,\n          0, -2, 2,\n          0, 0, 0},\n         2.0 / 3.0},\n        {\n         {-1, 0, 1,\n          -2, 0, 2,\n          0, 0, 0},\n         1.0 / 3.0},\n        {\n         {-1, 1, 0,\n          -2, 2, 0,\n          0, 0, 0},\n         2.0 / 3.0}\n    };\n\n    return matrix_list[n];\n}\n\nstatic FactorAndMatrix\nget_light_normal_matrix_y (gint n)\n{\n    static const FactorAndMatrix matrix_list[] = {\n        {\n         {0, 0, 0,\n          0, -2, -1,\n          0, 2, 1},\n         2.0 / 3.0},\n        {\n         {0, 0, 0,\n          -1, -2, -1,\n          1, 2, 1},\n         1.0 / 3.0},\n        {\n         {0, 0, 0,\n          -1, -2, 0,\n          1, 2, 0},\n         2.0 / 3.0},\n        {\n\n         {0, -2, -1,\n          0, 0, 0,\n          0, 2, 1},\n         1.0 / 2.0},\n        {\n         {-1, -2, -1,\n          0, 0, 0,\n          1, 2, 1},\n         1.0 / 4.0},\n        {\n         {-1, -2, 0,\n          0, 0, 0,\n          1, 2, 0},\n         1.0 / 2.0},\n        {\n\n         {0, -2, -1,\n          0, 2, 1,\n          0, 0, 0},\n         2.0 / 3.0},\n        {\n         {0, -2, -1,\n          1, 2, 1,\n          0, 0, 0},\n         1.0 / 3.0},\n        {\n         {-1, -2, 0,\n          1, 2, 0,\n          0, 0, 0},\n         2.0 / 3.0}\n    };\n\n    return matrix_list[n];\n}\n\nstatic vector3\nget_surface_normal (guchar * I, RsvgIRect boundarys, gint x, gint y,\n                    gdouble dx, gdouble dy, gdouble rawdx, gdouble rawdy, gdouble surfaceScale,\n                    gint rowstride, int chan)\n{\n    gint mrow, mcol;\n    FactorAndMatrix fnmx, fnmy;\n    gint *Kx, *Ky;\n    gdouble factorx, factory;\n    gdouble Nx, Ny;\n    vector3 output;\n\n    if (x + dx >= boundarys.x1 - 1)\n        mcol = 2;\n    else if (x - dx < boundarys.x0 + 1)\n        mcol = 0;\n    else\n        mcol = 1;\n\n    if (y + dy >= boundarys.y1 - 1)\n        mrow = 2;\n    else if (y - dy < boundarys.y0 + 1)\n        mrow = 0;\n    else\n        mrow = 1;\n\n    fnmx = get_light_normal_matrix_x (mrow * 3 + mcol);\n    factorx = fnmx.factor / rawdx;\n    Kx = fnmx.matrix;\n\n    fnmy = get_light_normal_matrix_y (mrow * 3 + mcol);\n    factory = fnmy.factor / rawdy;\n    Ky = fnmy.matrix;\n\n    Nx = -surfaceScale * factorx * ((gdouble)\n                                    (Kx[0] *\n                                     get_interp_pixel (I, x - dx, y - dy, chan,\n                                                                  boundarys,\n                                                                  rowstride) +\n                                     Kx[1] * get_interp_pixel (I, x, y - dy, chan,\n                                                                          boundarys,\n                                                                          rowstride) +\n                                     Kx[2] * get_interp_pixel (I, x + dx, y - dy, chan,\n                                                                          boundarys,\n                                                                          rowstride) +\n                                     Kx[3] * get_interp_pixel (I, x - dx, y, chan,\n                                                                          boundarys,\n                                                                          rowstride) +\n                                     Kx[4] * get_interp_pixel (I, x, y, chan, boundarys,\n                                                                          rowstride) +\n                                     Kx[5] * get_interp_pixel (I, x + dx, y, chan,\n                                                                          boundarys,\n                                                                          rowstride) +\n                                     Kx[6] * get_interp_pixel (I, x - dx, y + dy, chan,\n                                                                          boundarys,\n                                                                          rowstride) +\n                                     Kx[7] * get_interp_pixel (I, x, y + dy, chan,\n                                                                          boundarys,\n                                                                          rowstride) +\n                                     Kx[8] * get_interp_pixel (I, x + dx, y + dy, chan,\n                                                                          boundarys,\n                                                                          rowstride))) / 255.0;\n\n    Ny = -surfaceScale * factory * ((gdouble)\n                                    (Ky[0] *\n                                     get_interp_pixel (I, x - dx, y - dy, chan,\n                                                                  boundarys,\n                                                                  rowstride) +\n                                     Ky[1] * get_interp_pixel (I, x, y - dy, chan,\n                                                                          boundarys,\n                                                                          rowstride) +\n                                     Ky[2] * get_interp_pixel (I, x + dx, y - dy, chan,\n                                                                          boundarys,\n                                                                          rowstride) +\n                                     Ky[3] * get_interp_pixel (I, x - dx, y, chan,\n                                                                          boundarys,\n                                                                          rowstride) +\n                                     Ky[4] * get_interp_pixel (I, x, y, chan, boundarys,\n                                                                          rowstride) +\n                                     Ky[5] * get_interp_pixel (I, x + dx, y, chan,\n                                                                          boundarys,\n                                                                          rowstride) +\n                                     Ky[6] * get_interp_pixel (I, x - dx, y + dy, chan,\n                                                                          boundarys,\n                                                                          rowstride) +\n                                     Ky[7] * get_interp_pixel (I, x, y + dy, chan,\n                                                                          boundarys,\n                                                                          rowstride) +\n                                     Ky[8] * get_interp_pixel (I, x + dx, y + dy, chan,\n                                                                          boundarys,\n                                                                          rowstride))) / 255.0;\n\n    output.x = Nx;\n    output.y = Ny;\n\n    output.z = 1;\n    output = normalise (output);\n    return output;\n}\n\ntypedef enum {\n    DISTANTLIGHT, POINTLIGHT, SPOTLIGHT\n} lightType;\n\ntypedef struct _RsvgNodeLightSource RsvgNodeLightSource;\n\nstruct _RsvgNodeLightSource {\n    lightType type;\n    gdouble azimuth;\n    gdouble elevation;\n    RsvgLength x, y, z, pointsAtX, pointsAtY, pointsAtZ;\n    gdouble specularExponent;\n    gdouble limitingconeAngle;\n};\n\nstatic vector3\nget_light_direction (RsvgNodeLightSource * source, gdouble x1, gdouble y1, gdouble z,\n                     cairo_matrix_t *affine, RsvgDrawingCtx * ctx)\n{\n    vector3 output;\n\n    switch (source->type) {\n    case DISTANTLIGHT:\n        output.x = cos (source->azimuth) * cos (source->elevation);\n        output.y = sin (source->azimuth) * cos (source->elevation);\n        output.z = sin (source->elevation);\n        break;\n    default:\n        {\n            double x, y;\n            x = affine->xx * x1 + affine->xy * y1 + affine->x0;\n            y = affine->yx * x1 + affine->yy * y1 + affine->y0;\n            output.x = rsvg_length_normalize (&source->x, ctx) - x;\n            output.y = rsvg_length_normalize (&source->y, ctx) - y;\n            output.z = rsvg_length_normalize (&source->z, ctx) - z;\n            output = normalise (output);\n        }\n        break;\n    }\n    return output;\n}\n\nstatic vector3\nget_light_color (RsvgNodeLightSource * source, vector3 color,\n                 gdouble x1, gdouble y1, gdouble z, cairo_matrix_t *affine, RsvgDrawingCtx * ctx)\n{\n    double base, angle, x, y;\n    vector3 s;\n    vector3 L;\n    vector3 output;\n    double sx, sy, sz, spx, spy, spz;\n\n    if (source->type != SPOTLIGHT)\n        return color;\n\n    sx = rsvg_length_normalize (&source->x, ctx);\n    sy = rsvg_length_normalize (&source->y, ctx);\n    sz = rsvg_length_normalize (&source->z, ctx);\n    spx = rsvg_length_normalize (&source->pointsAtX, ctx);\n    spy = rsvg_length_normalize (&source->pointsAtY, ctx);\n    spz = rsvg_length_normalize (&source->pointsAtZ, ctx);\n\n    x = affine->xx * x1 + affine->xy * y1 + affine->x0;\n    y = affine->yx * x1 + affine->yy * y1 + affine->y0;\n\n    L.x = sx - x;\n    L.y = sy - y;\n    L.z = sz - z;\n    L = normalise (L);\n\n    s.x = spx - sx;\n    s.y = spy - sy;\n    s.z = spz - sz;\n    s = normalise (s);\n\n    base = -dotproduct (L, s);\n\n    angle = acos (base);\n\n    if (base < 0 || angle > source->limitingconeAngle) {\n        output.x = 0;\n        output.y = 0;\n        output.z = 0;\n        return output;\n    }\n\n    output.x = color.x * pow (base, source->specularExponent);\n    output.y = color.y * pow (base, source->specularExponent);\n    output.z = color.z * pow (base, source->specularExponent);\n\n    return output;\n}\n\n\nstatic void\nrsvg_node_light_source_set_atts (RsvgNode *node, gpointer impl, RsvgHandle *handle, RsvgPropertyBag *atts)\n{\n    RsvgNodeLightSource *data = impl;\n    const char *value;\n\n    if ((value = rsvg_property_bag_lookup (atts, \"azimuth\")))\n        data->azimuth = g_ascii_strtod (value, NULL) / 180.0 * M_PI;\n    if ((value = rsvg_property_bag_lookup (atts, \"elevation\")))\n        data->elevation = g_ascii_strtod (value, NULL) / 180.0 * M_PI;\n    if ((value = rsvg_property_bag_lookup (atts, \"limitingConeAngle\")))\n        data->limitingconeAngle = g_ascii_strtod (value, NULL) / 180.0 * M_PI;\n    if ((value = rsvg_property_bag_lookup (atts, \"x\")))\n        data->x = data->pointsAtX = rsvg_length_parse (value, LENGTH_DIR_HORIZONTAL);\n    if ((value = rsvg_property_bag_lookup (atts, \"y\")))\n        data->y = data->pointsAtX = rsvg_length_parse (value, LENGTH_DIR_VERTICAL);\n    if ((value = rsvg_property_bag_lookup (atts, \"z\")))\n        data->z = data->pointsAtX = rsvg_length_parse (value, LENGTH_DIR_BOTH);\n    if ((value = rsvg_property_bag_lookup (atts, \"pointsAtX\")))\n        data->pointsAtX = rsvg_length_parse (value, LENGTH_DIR_HORIZONTAL);\n    if ((value = rsvg_property_bag_lookup (atts, \"pointsAtY\")))\n        data->pointsAtY = rsvg_length_parse (value, LENGTH_DIR_VERTICAL);\n    if ((value = rsvg_property_bag_lookup (atts, \"pointsAtZ\")))\n        data->pointsAtZ = rsvg_length_parse (value, LENGTH_DIR_BOTH);\n    if ((value = rsvg_property_bag_lookup (atts, \"specularExponent\")))\n        data->specularExponent = g_ascii_strtod (value, NULL);\n}\n\nRsvgNode *\nrsvg_new_node_light_source (const char *element_name, RsvgNode *parent)\n{\n    RsvgNodeLightSource *data;\n\n    data = g_new0 (RsvgNodeLightSource, 1);\n\n    data->specularExponent = 1;\n\n    if (strcmp (element_name, \"feDistantLight\") == 0)\n        data->type = SPOTLIGHT;\n    else if (strcmp (element_name, \"feSpotLight\") == 0)\n        data->type = DISTANTLIGHT;\n    else if (strcmp (element_name, \"fePointLight\") == 0)\n        data->type = POINTLIGHT;\n    else\n        g_assert_not_reached ();\n\n    data->limitingconeAngle = 180;\n\n    return rsvg_rust_cnode_new (RSVG_NODE_TYPE_LIGHT_SOURCE,\n                                parent,\n                                rsvg_state_new (),\n                                data,\n                                rsvg_node_light_source_set_atts,\n                                rsvg_filter_draw,\n                                g_free);                                \n}\n\n/*************************************************************/\n/*************************************************************/\n\ntypedef struct _RsvgFilterPrimitiveDiffuseLighting RsvgFilterPrimitiveDiffuseLighting;\n\nstruct _RsvgFilterPrimitiveDiffuseLighting {\n    RsvgFilterPrimitive super;\n    gdouble dx, dy;\n    double diffuseConstant;\n    double surfaceScale;\n    guint32 lightingcolor;\n};\n\nstruct find_light_source_closure {\n    RsvgNode *found_node;\n};\n\nstatic gboolean\nis_light_source (RsvgNode *node, gpointer data)\n{\n    struct find_light_source_closure *closure = data;\n\n    if (rsvg_node_get_type (node) == RSVG_NODE_TYPE_LIGHT_SOURCE) {\n        closure->found_node = rsvg_node_ref (node);\n    }\n\n    return TRUE;\n}\n\nstatic RsvgNodeLightSource *\nfind_light_source_in_children (RsvgNode *node)\n{\n    struct find_light_source_closure closure;\n    RsvgNodeLightSource *source;\n\n    closure.found_node = NULL;\n    rsvg_node_foreach_child (node, is_light_source, &closure);\n    if (closure.found_node == NULL)\n        return NULL;\n\n    g_assert (rsvg_node_get_type (closure.found_node) == RSVG_NODE_TYPE_LIGHT_SOURCE);\n\n    source = rsvg_rust_cnode_get_impl (closure.found_node);\n    closure.found_node = rsvg_node_unref (closure.found_node);\n\n    return source;\n}\n\nstatic void\nrsvg_filter_primitive_diffuse_lighting_render (RsvgNode *node, RsvgFilterPrimitive *primitive, RsvgFilterContext *ctx)\n{\n    RsvgFilterPrimitiveDiffuseLighting *diffuse_lighting = (RsvgFilterPrimitiveDiffuseLighting *) primitive;\n\n    gint x, y;\n    float dy, dx, rawdy, rawdx;\n    gdouble z;\n    gint rowstride, height, width;\n    gdouble factor, surfaceScale;\n    vector3 lightcolor, L, N;\n    vector3 color;\n    cairo_matrix_t iaffine;\n    RsvgNodeLightSource *source = NULL;\n    RsvgIRect boundarys;\n\n    guchar *in_pixels;\n    guchar *output_pixels;\n\n    cairo_surface_t *output, *in;\n\n    source = find_light_source_in_children (node);\n    if (source == NULL)\n        return;\n\n    iaffine = ctx->paffine;\n    if (cairo_matrix_invert (&iaffine) != CAIRO_STATUS_SUCCESS)\n      return;\n\n    boundarys = rsvg_filter_primitive_get_bounds (primitive, ctx);\n\n    in = rsvg_filter_get_in (primitive->in, ctx);\n    if (in == NULL)\n        return;\n\n    cairo_surface_flush (in);\n\n    in_pixels = cairo_image_surface_get_data (in);\n\n    height = cairo_image_surface_get_height (in);\n    width = cairo_image_surface_get_width (in);\n\n    rowstride = cairo_image_surface_get_stride (in);\n\n    output = _rsvg_image_surface_new (width, height);\n    if (output == NULL) {\n        cairo_surface_destroy (in);\n        return;\n    }\n\n    output_pixels = cairo_image_surface_get_data (output);\n\n    color.x = ((guchar *) (&diffuse_lighting->lightingcolor))[2] / 255.0;\n    color.y = ((guchar *) (&diffuse_lighting->lightingcolor))[1] / 255.0;\n    color.z = ((guchar *) (&diffuse_lighting->lightingcolor))[0] / 255.0;\n\n    surfaceScale = diffuse_lighting->surfaceScale / 255.0;\n\n    if (diffuse_lighting->dy < 0 || diffuse_lighting->dx < 0) {\n        dx = 1;\n        dy = 1;\n        rawdx = 1;\n        rawdy = 1;\n    } else {\n        dx = diffuse_lighting->dx * ctx->paffine.xx;\n        dy = diffuse_lighting->dy * ctx->paffine.yy;\n        rawdx = diffuse_lighting->dx;\n        rawdy = diffuse_lighting->dy;\n    }\n\n    for (y = boundarys.y0; y < boundarys.y1; y++)\n        for (x = boundarys.x0; x < boundarys.x1; x++) {\n            z = surfaceScale * (double) in_pixels[y * rowstride + x * 4 + ctx->channelmap[3]];\n            L = get_light_direction (source, x, y, z, &iaffine, ctx->ctx);\n            N = get_surface_normal (in_pixels, boundarys, x, y,\n                                    dx, dy, rawdx, rawdy, diffuse_lighting->surfaceScale,\n                                    rowstride, ctx->channelmap[3]);\n            lightcolor = get_light_color (source, color, x, y, z, &iaffine, ctx->ctx);\n            factor = dotproduct (N, L);\n\n            output_pixels[y * rowstride + x * 4 + ctx->channelmap[0]] =\n                MAX (0, MIN (255, diffuse_lighting->diffuseConstant * factor * lightcolor.x * 255.0));\n            output_pixels[y * rowstride + x * 4 + ctx->channelmap[1]] =\n                MAX (0, MIN (255, diffuse_lighting->diffuseConstant * factor * lightcolor.y * 255.0));\n            output_pixels[y * rowstride + x * 4 + ctx->channelmap[2]] =\n                MAX (0, MIN (255, diffuse_lighting->diffuseConstant * factor * lightcolor.z * 255.0));\n            output_pixels[y * rowstride + x * 4 + ctx->channelmap[3]] = 255;\n        }\n\n    cairo_surface_mark_dirty (output);\n\n    rsvg_filter_store_result (primitive->result, output, ctx);\n\n    cairo_surface_destroy (in);\n    cairo_surface_destroy (output);\n}\n\nstatic void\nrsvg_filter_primitive_diffuse_lighting_set_atts (RsvgNode *node, gpointer impl, RsvgHandle *handle, RsvgPropertyBag *atts)\n{\n    RsvgFilterPrimitiveDiffuseLighting *filter = impl;\n    const char *value;\n    RsvgState *state;\n\n    if ((value = rsvg_property_bag_lookup (atts, \"in\")))\n        g_string_assign (filter->super.in, value);\n    if ((value = rsvg_property_bag_lookup (atts, \"result\")))\n        g_string_assign (filter->super.result, value);\n\n    filter_primitive_set_x_y_width_height_atts ((RsvgFilterPrimitive *) filter, atts);\n\n    if ((value = rsvg_property_bag_lookup (atts, \"kernelUnitLength\")))\n        rsvg_css_parse_number_optional_number (value, &filter->dx, &filter->dy);\n\n    if ((value = rsvg_property_bag_lookup (atts, \"lighting-color\"))) {\n        RsvgCssColorSpec spec;\n\n        spec = rsvg_css_parse_color (value, ALLOW_INHERIT_YES, ALLOW_CURRENT_COLOR_YES);\n\n        switch (spec.kind) {\n        case RSVG_CSS_COLOR_SPEC_INHERIT:\n            /* FIXME: we should inherit; see how stop-color is handled in rsvg-styles.c */\n            break;\n\n        case RSVG_CSS_COLOR_SPEC_CURRENT_COLOR:\n            state = rsvg_state_new ();\n            rsvg_state_reconstruct (state, node);\n            filter->lightingcolor = state->current_color;\n            break;\n\n        case RSVG_CSS_COLOR_SPEC_ARGB:\n            filter->lightingcolor = spec.argb;\n            break;\n\n        case RSVG_CSS_COLOR_PARSE_ERROR:\n            rsvg_node_set_attribute_parse_error (node, \"lighting-color\", \"Invalid color\");\n            break;\n\n        default:\n            g_assert_not_reached ();\n        }\n    }\n\n    if ((value = rsvg_property_bag_lookup (atts, \"diffuseConstant\")))\n        filter->diffuseConstant = g_ascii_strtod (value, NULL);\n    if ((value = rsvg_property_bag_lookup (atts, \"surfaceScale\")))\n        filter->surfaceScale = g_ascii_strtod (value, NULL);\n}\n\nRsvgNode *\nrsvg_new_filter_primitive_diffuse_lighting (const char *element_name, RsvgNode *parent)\n{\n    RsvgFilterPrimitiveDiffuseLighting *filter;\n\n    filter = g_new0 (RsvgFilterPrimitiveDiffuseLighting, 1);\n    filter->super.in = g_string_new (\"none\");\n    filter->super.result = g_string_new (\"none\");\n    filter->surfaceScale = 1;\n    filter->diffuseConstant = 1;\n    filter->dx = 1;\n    filter->dy = 1;\n    filter->lightingcolor = 0xFFFFFFFF;\n    filter->super.render = rsvg_filter_primitive_diffuse_lighting_render;\n\n    return rsvg_rust_cnode_new (RSVG_NODE_TYPE_FILTER_PRIMITIVE_DIFFUSE_LIGHTING,\n                                parent,\n                                rsvg_state_new (),\n                                filter,\n                                rsvg_filter_primitive_diffuse_lighting_set_atts,\n                                rsvg_filter_draw,\n                                rsvg_filter_primitive_free);\n}\n\n/*************************************************************/\n/*************************************************************/\n\ntypedef struct _RsvgFilterPrimitiveSpecularLighting RsvgFilterPrimitiveSpecularLighting;\n\nstruct _RsvgFilterPrimitiveSpecularLighting {\n    RsvgFilterPrimitive super;\n    double specularConstant;\n    double specularExponent;\n    double surfaceScale;\n    guint32 lightingcolor;\n};\n\nstatic void\nrsvg_filter_primitive_specular_lighting_render (RsvgNode *node, RsvgFilterPrimitive *primitive, RsvgFilterContext *ctx)\n{\n    RsvgFilterPrimitiveSpecularLighting *specular_lighting = (RsvgFilterPrimitiveSpecularLighting *) primitive;\n\n    gint x, y;\n    gdouble z, surfaceScale;\n    gint rowstride, height, width;\n    gdouble factor, max, base;\n    vector3 lightcolor, color;\n    vector3 L;\n    cairo_matrix_t iaffine;\n    RsvgIRect boundarys;\n    RsvgNodeLightSource *source = NULL;\n\n    guchar *in_pixels;\n    guchar *output_pixels;\n\n    cairo_surface_t *output, *in;\n\n    source = find_light_source_in_children (node);\n    if (source == NULL)\n        return;\n\n    iaffine = ctx->paffine;\n    if (cairo_matrix_invert (&iaffine) != CAIRO_STATUS_SUCCESS)\n      return;\n\n    boundarys = rsvg_filter_primitive_get_bounds (primitive, ctx);\n\n    in = rsvg_filter_get_in (primitive->in, ctx);\n    if (in == NULL)\n        return;\n\n    cairo_surface_flush (in);\n\n    in_pixels = cairo_image_surface_get_data (in);\n\n    height = cairo_image_surface_get_height (in);\n    width = cairo_image_surface_get_width (in);\n\n    rowstride = cairo_image_surface_get_stride (in);\n\n    output = _rsvg_image_surface_new (width, height);\n    if (output == NULL) {\n        cairo_surface_destroy (in);\n        return;\n    }\n\n    output_pixels = cairo_image_surface_get_data (output);\n\n    color.x = ((guchar *) (&specular_lighting->lightingcolor))[2] / 255.0;\n    color.y = ((guchar *) (&specular_lighting->lightingcolor))[1] / 255.0;\n    color.z = ((guchar *) (&specular_lighting->lightingcolor))[0] / 255.0;\n\n    surfaceScale = specular_lighting->surfaceScale / 255.0;\n\n    for (y = boundarys.y0; y < boundarys.y1; y++)\n        for (x = boundarys.x0; x < boundarys.x1; x++) {\n            z = in_pixels[y * rowstride + x * 4 + 3] * surfaceScale;\n            L = get_light_direction (source, x, y, z, &iaffine, ctx->ctx);\n            L.z += 1;\n            L = normalise (L);\n\n            lightcolor = get_light_color (source, color, x, y, z, &iaffine, ctx->ctx);\n            base = dotproduct (get_surface_normal (in_pixels, boundarys, x, y,\n                                                   1, 1, 1.0 / ctx->paffine.xx,\n                                                   1.0 / ctx->paffine.yy, specular_lighting->surfaceScale,\n                                                   rowstride, ctx->channelmap[3]), L);\n\n            factor = specular_lighting->specularConstant * pow (base, specular_lighting->specularExponent) * 255;\n\n            max = 0;\n            if (max < lightcolor.x)\n                max = lightcolor.x;\n            if (max < lightcolor.y)\n                max = lightcolor.y;\n            if (max < lightcolor.z)\n                max = lightcolor.z;\n\n            max *= factor;\n            if (max > 255)\n                max = 255;\n            if (max < 0)\n                max = 0;\n\n            output_pixels[y * rowstride + x * 4 + ctx->channelmap[0]] = lightcolor.x * max;\n            output_pixels[y * rowstride + x * 4 + ctx->channelmap[1]] = lightcolor.y * max;\n            output_pixels[y * rowstride + x * 4 + ctx->channelmap[2]] = lightcolor.z * max;\n            output_pixels[y * rowstride + x * 4 + ctx->channelmap[3]] = max;\n\n        }\n\n    cairo_surface_mark_dirty (output);\n\n    rsvg_filter_store_result (primitive->result, output, ctx);\n\n    cairo_surface_destroy (in);\n    cairo_surface_destroy (output);\n}\n\nstatic void\nrsvg_filter_primitive_specular_lighting_set_atts (RsvgNode *node, gpointer impl, RsvgHandle *handle, RsvgPropertyBag *atts)\n{\n    RsvgFilterPrimitiveSpecularLighting *filter = impl;\n    const char *value;\n\n    if ((value = rsvg_property_bag_lookup (atts, \"in\")))\n        g_string_assign (filter->super.in, value);\n    if ((value = rsvg_property_bag_lookup (atts, \"result\")))\n        g_string_assign (filter->super.result, value);\n\n    filter_primitive_set_x_y_width_height_atts ((RsvgFilterPrimitive *) filter, atts);\n\n    if ((value = rsvg_property_bag_lookup (atts, \"lighting-color\"))) {\n        RsvgCssColorSpec spec;\n        RsvgState *state;\n\n        spec = rsvg_css_parse_color (value, ALLOW_INHERIT_YES, ALLOW_CURRENT_COLOR_YES);\n\n        switch (spec.kind) {\n        case RSVG_CSS_COLOR_SPEC_INHERIT:\n            /* FIXME: we should inherit; see how stop-color is handled in rsvg-styles.c */\n            break;\n\n        case RSVG_CSS_COLOR_SPEC_CURRENT_COLOR:\n            state = rsvg_state_new ();\n            rsvg_state_reconstruct (state, node);\n            filter->lightingcolor = state->current_color;\n            break;\n\n        case RSVG_CSS_COLOR_SPEC_ARGB:\n            filter->lightingcolor = spec.argb;\n            break;\n\n        case RSVG_CSS_COLOR_PARSE_ERROR:\n            rsvg_node_set_attribute_parse_error (node, \"lighting-color\", \"Invalid color\");\n            break;\n\n        default:\n            g_assert_not_reached ();\n        }\n    }\n\n    if ((value = rsvg_property_bag_lookup (atts, \"specularConstant\")))\n        filter->specularConstant = g_ascii_strtod (value, NULL);\n    if ((value = rsvg_property_bag_lookup (atts, \"specularExponent\")))\n        filter->specularExponent = g_ascii_strtod (value, NULL);\n    if ((value = rsvg_property_bag_lookup (atts, \"surfaceScale\")))\n        filter->surfaceScale = g_ascii_strtod (value, NULL);\n}\n\nRsvgNode *\nrsvg_new_filter_primitive_specular_lighting (const char *element_name, RsvgNode *parent)\n{\n    RsvgFilterPrimitiveSpecularLighting *filter;\n\n    filter = g_new0 (RsvgFilterPrimitiveSpecularLighting, 1);\n    filter->super.in = g_string_new (\"none\");\n    filter->super.result = g_string_new (\"none\");\n    filter->surfaceScale = 1;\n    filter->specularConstant = 1;\n    filter->specularExponent = 1;\n    filter->lightingcolor = 0xFFFFFFFF;\n    filter->super.render = rsvg_filter_primitive_specular_lighting_render;\n\n    return rsvg_rust_cnode_new (RSVG_NODE_TYPE_FILTER_PRIMITIVE_SPECULAR_LIGHTING,\n                                parent,\n                                rsvg_state_new (),\n                                filter,\n                                rsvg_filter_primitive_specular_lighting_set_atts,\n                                rsvg_filter_draw,\n                                rsvg_filter_primitive_free);\n}\n\n/*************************************************************/\n/*************************************************************/\n\ntypedef struct _RsvgFilterPrimitiveTile RsvgFilterPrimitiveTile;\n\nstruct _RsvgFilterPrimitiveTile {\n    RsvgFilterPrimitive super;\n};\n\nstatic int\nmod (int a, int b)\n{\n    while (a < 0)\n        a += b;\n    return a % b;\n}\n\nstatic void\nrsvg_filter_primitive_tile_render (RsvgNode *node, RsvgFilterPrimitive *primitive, RsvgFilterContext *ctx)\n{\n    guchar i;\n    gint x, y, rowstride;\n    RsvgIRect boundarys, oboundarys;\n\n    RsvgFilterPrimitiveOutput input;\n\n    guchar *in_pixels;\n    guchar *output_pixels;\n\n    cairo_surface_t *output, *in;\n\n    oboundarys = rsvg_filter_primitive_get_bounds (primitive, ctx);\n\n    input = rsvg_filter_get_result (primitive->in, ctx);\n    in = input.surface;\n    boundarys = input.bounds;\n\n    cairo_surface_flush (in);\n\n    in_pixels = cairo_image_surface_get_data (in);\n\n    output = _rsvg_image_surface_new (ctx->width, ctx->height);\n    if (output == NULL) {\n        cairo_surface_destroy (in);\n        return;\n    }\n\n    rowstride = cairo_image_surface_get_stride (output);\n\n    output_pixels = cairo_image_surface_get_data (output);\n\n    for (y = oboundarys.y0; y < oboundarys.y1; y++)\n        for (x = oboundarys.x0; x < oboundarys.x1; x++)\n            for (i = 0; i < 4; i++) {\n                output_pixels[4 * x + y * rowstride + i] =\n                    in_pixels[(mod ((x - boundarys.x0), (boundarys.x1 - boundarys.x0)) +\n                               boundarys.x0) * 4 +\n                              (mod ((y - boundarys.y0), (boundarys.y1 - boundarys.y0)) +\n                               boundarys.y0) * rowstride + i];\n            }\n\n    cairo_surface_mark_dirty (output);\n\n    rsvg_filter_store_result (primitive->result, output, ctx);\n\n    cairo_surface_destroy (in);\n    cairo_surface_destroy (output);\n}\n\nstatic void\nrsvg_filter_primitive_tile_set_atts (RsvgNode *node, gpointer impl, RsvgHandle *handle, RsvgPropertyBag *atts)\n{\n    RsvgFilterPrimitiveTile *filter = impl;\n    const char *value;\n\n    if ((value = rsvg_property_bag_lookup (atts, \"in\")))\n        g_string_assign (filter->super.in, value);\n    if ((value = rsvg_property_bag_lookup (atts, \"result\")))\n        g_string_assign (filter->super.result, value);\n\n    filter_primitive_set_x_y_width_height_atts ((RsvgFilterPrimitive *) filter, atts);\n}\n\nRsvgNode *\nrsvg_new_filter_primitive_tile (const char *element_name, RsvgNode *parent)\n{\n    RsvgFilterPrimitiveTile *filter;\n\n    filter = g_new0 (RsvgFilterPrimitiveTile, 1);\n    filter->super.in = g_string_new (\"none\");\n    filter->super.result = g_string_new (\"none\");\n    filter->super.render = rsvg_filter_primitive_tile_render;\n\n    return rsvg_rust_cnode_new (RSVG_NODE_TYPE_FILTER_PRIMITIVE_TILE,\n                                parent,\n                                rsvg_state_new (),\n                                filter,\n                                rsvg_filter_primitive_tile_set_atts,\n                                rsvg_filter_draw,\n                                rsvg_filter_primitive_free);\n}\n"], "fixing_code": ["/* -*- Mode: C; indent-tabs-mode: nil; c-basic-offset: 4 -*- */\n/* vim: set sw=4 sts=4 expandtab: */\n/*\n   rsvg-filter.c: Provides filters\n\n   Copyright (C) 2004 Caleb Moore\n\n   This program is free software; you can redistribute it and/or\n   modify it under the terms of the GNU Library General Public License as\n   published by the Free Software Foundation; either version 2 of the\n   License, or (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n   Library General Public License for more details.\n\n   You should have received a copy of the GNU Library General Public\n   License along with this program; if not, write to the\n   Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n   Boston, MA 02111-1307, USA.\n\n   Author: Caleb Moore <c.moore@student.unsw.edu.au>\n*/\n\n#include \"config.h\"\n\n#include \"rsvg-private.h\"\n#include \"rsvg-filter.h\"\n#include \"rsvg-styles.h\"\n#include \"rsvg-image.h\"\n#include \"rsvg-css.h\"\n#include \"rsvg-cairo-render.h\"\n\n#include <string.h>\n\n#include <math.h>\n\n\n/*************************************************************/\n/*************************************************************/\n\ntypedef struct _RsvgFilterPrimitiveOutput RsvgFilterPrimitiveOutput;\n\nstruct _RsvgFilterPrimitiveOutput {\n    cairo_surface_t *surface;\n    RsvgIRect bounds;\n};\n\ntypedef struct _RsvgFilterContext RsvgFilterContext;\n\nstruct _RsvgFilterContext {\n    gint width, height;\n    RsvgFilter *filter;\n    GHashTable *results;\n    cairo_surface_t *source_surface;\n    cairo_surface_t *bg_surface;\n    RsvgFilterPrimitiveOutput lastresult;\n    cairo_matrix_t affine;\n    cairo_matrix_t paffine;\n    int channelmap[4];\n    RsvgDrawingCtx *ctx;\n};\n\ntypedef struct _RsvgFilterPrimitive RsvgFilterPrimitive;\n\n/* We don't have real subclassing here.  If you derive something from\n * RsvgFilterPrimitive, and don't need any special code to free your\n * RsvgFilterPrimitiveFoo structure, you can just pass rsvg_filter_primitive_free\n * to rsvg_rust_cnode_new() for the destructor.  Otherwise, create a custom destructor like this:\n *\n *    static void\n *    rsvg_filter_primitive_foo_free (gpointer impl)\n *    {\n *        RsvgFilterPrimitiveFoo *foo = impl;\n *\n *        g_free (foo->my_custom_stuff);\n *        g_free (foo->more_custom_stuff);\n *        ... etc ...\n *\n *        rsvg_filter_primitive_free (impl);\n *    }\n *\n * That last call to rsvg_filter_primitive_free() will free the base RsvgFilterPrimitive's own fields,\n * and your whole structure itself, via g_free().\n */\nstruct _RsvgFilterPrimitive {\n    RsvgLength x, y, width, height;\n    gboolean x_specified;\n    gboolean y_specified;\n    gboolean width_specified;\n    gboolean height_specified;\n    GString *in;\n    GString *result;\n\n    void (*render) (RsvgNode *node, RsvgFilterPrimitive *primitive, RsvgFilterContext *ctx);\n};\n\n/*************************************************************/\n/*************************************************************/\n\nstatic void\nrsvg_filter_primitive_free (gpointer impl)\n{\n    RsvgFilterPrimitive *primitive = impl;\n\n    g_string_free (primitive->in, TRUE);\n    g_string_free (primitive->result, TRUE);\n\n    g_free (primitive);\n}\n\nstatic void\nfilter_primitive_set_x_y_width_height_atts (RsvgFilterPrimitive *prim, RsvgPropertyBag *atts)\n{\n    const char *value;\n\n    if ((value = rsvg_property_bag_lookup (atts, \"x\"))) {\n        prim->x = rsvg_length_parse (value, LENGTH_DIR_HORIZONTAL);\n        prim->x_specified = TRUE;\n    }\n    if ((value = rsvg_property_bag_lookup (atts, \"y\"))) {\n        prim->y = rsvg_length_parse (value, LENGTH_DIR_VERTICAL);\n        prim->y_specified = TRUE;\n    }\n    if ((value = rsvg_property_bag_lookup (atts, \"width\"))) {\n        prim->width = rsvg_length_parse (value, LENGTH_DIR_HORIZONTAL);\n        prim->width_specified = TRUE;\n    }\n    if ((value = rsvg_property_bag_lookup (atts, \"height\"))) {\n        prim->height = rsvg_length_parse (value, LENGTH_DIR_VERTICAL);\n        prim->height_specified = TRUE;\n    }\n}\n\nstatic void\nrsvg_filter_primitive_render (RsvgNode *node, RsvgFilterPrimitive *primitive, RsvgFilterContext *ctx)\n{\n    primitive->render (node, primitive, ctx);\n}\n\nstatic RsvgIRect\nrsvg_filter_primitive_get_bounds (RsvgFilterPrimitive * self, RsvgFilterContext * ctx)\n{\n    RsvgBbox box, otherbox;\n    cairo_matrix_t affine;\n\n    cairo_matrix_init_identity (&affine);\n    rsvg_bbox_init (&box, &affine);\n    rsvg_bbox_init (&otherbox, &ctx->affine);\n    otherbox.virgin = 0;\n    if (ctx->filter->filterunits == objectBoundingBox)\n        rsvg_drawing_ctx_push_view_box (ctx->ctx, 1., 1.);\n    otherbox.rect.x = rsvg_length_normalize (&ctx->filter->x, ctx->ctx);\n    otherbox.rect.y = rsvg_length_normalize (&ctx->filter->y, ctx->ctx);\n    otherbox.rect.width = rsvg_length_normalize (&ctx->filter->width, ctx->ctx);\n    otherbox.rect.height = rsvg_length_normalize (&ctx->filter->height, ctx->ctx);\n    if (ctx->filter->filterunits == objectBoundingBox)\n        rsvg_drawing_ctx_pop_view_box (ctx->ctx);\n\n    rsvg_bbox_insert (&box, &otherbox);\n\n    if (self != NULL) {\n        if (self->x_specified || self->y_specified || self->width_specified || self->height_specified) {\n            rsvg_bbox_init (&otherbox, &ctx->paffine);\n            otherbox.virgin = 0;\n            if (ctx->filter->primitiveunits == objectBoundingBox)\n                rsvg_drawing_ctx_push_view_box (ctx->ctx, 1., 1.);\n            if (self->x_specified)\n                otherbox.rect.x = rsvg_length_normalize (&self->x, ctx->ctx);\n            else\n                otherbox.rect.x = 0;\n            if (self->y_specified)\n                otherbox.rect.y = rsvg_length_normalize (&self->y, ctx->ctx);\n            else\n                otherbox.rect.y = 0;\n\n            if (self->width_specified || self->height_specified) {\n                double curr_vbox_w, curr_vbox_h;\n\n                rsvg_drawing_ctx_get_view_box_size (ctx->ctx, &curr_vbox_w, &curr_vbox_h);\n\n                if (self->width_specified)\n                    otherbox.rect.width = rsvg_length_normalize (&self->width, ctx->ctx);\n                else\n                    otherbox.rect.width = curr_vbox_w;\n\n                if (self->height_specified)\n                    otherbox.rect.height = rsvg_length_normalize (&self->height, ctx->ctx);\n                else\n                    otherbox.rect.height = curr_vbox_h;\n            }\n\n            if (ctx->filter->primitiveunits == objectBoundingBox)\n                rsvg_drawing_ctx_pop_view_box (ctx->ctx);\n            rsvg_bbox_clip (&box, &otherbox);\n        }\n    }\n\n    rsvg_bbox_init (&otherbox, &affine);\n    otherbox.virgin = 0;\n    otherbox.rect.x = 0;\n    otherbox.rect.y = 0;\n    otherbox.rect.width = ctx->width;\n    otherbox.rect.height = ctx->height;\n    rsvg_bbox_clip (&box, &otherbox);\n    {\n        RsvgIRect output = { box.rect.x, box.rect.y,\n            box.rect.x + box.rect.width,\n            box.rect.y + box.rect.height\n        };\n        return output;\n    }\n}\n\nstatic cairo_surface_t *\n_rsvg_image_surface_new (int width, int height)\n{\n    cairo_surface_t *surface;\n\n    surface = cairo_image_surface_create (CAIRO_FORMAT_ARGB32, width, height);\n    if (cairo_surface_status (surface) != CAIRO_STATUS_SUCCESS) {\n        cairo_surface_destroy (surface);\n        return NULL;\n    }\n\n    return surface;\n}\n\nstatic guchar\nget_interp_pixel (guchar * src, gdouble ox, gdouble oy, guchar ch, RsvgIRect boundarys,\n                  guint rowstride)\n{\n    double xmod, ymod;\n    double dist1, dist2, dist3, dist4;\n    double c, c1, c2, c3, c4;\n    double fox, foy, cox, coy;\n\n    xmod = fmod (ox, 1.0);\n    ymod = fmod (oy, 1.0);\n\n    dist1 = (1 - xmod) * (1 - ymod);\n    dist2 = (xmod) * (1 - ymod);\n    dist3 = (xmod) * (ymod);\n    dist4 = (1 - xmod) * (ymod);\n\n    fox = floor (ox);\n    foy = floor (oy);\n    cox = ceil (ox);\n    coy = ceil (oy);\n\n    if (fox <= boundarys.x0 || fox >= boundarys.x1 ||\n        foy <= boundarys.y0 || foy >= boundarys.y1)\n        c1 = 0;\n    else\n        c1 = src[(guint) foy * rowstride + (guint) fox * 4 + ch];\n\n    if (cox <= boundarys.x0 || cox >= boundarys.x1 ||\n        foy <= boundarys.y0 || foy >= boundarys.y1)\n        c2 = 0;\n    else\n        c2 = src[(guint) foy * rowstride + (guint) cox * 4 + ch];\n\n    if (cox <= boundarys.x0 || cox >= boundarys.x1 ||\n        coy <= boundarys.y0 || coy >= boundarys.y1)\n        c3 = 0;\n    else\n        c3 = src[(guint) coy * rowstride + (guint) cox * 4 + ch];\n\n    if (fox <= boundarys.x0 || fox >= boundarys.x1 ||\n        coy <= boundarys.y0 || coy >= boundarys.y1)\n        c4 = 0;\n    else\n        c4 = src[(guint) coy * rowstride + (guint) fox * 4 + ch];\n\n    c = (c1 * dist1 + c2 * dist2 + c3 * dist3 + c4 * dist4) / (dist1 + dist2 + dist3 + dist4);\n\n    return (guchar) c;\n}\n\nstatic void\nrsvg_filter_fix_coordinate_system (RsvgFilterContext * ctx, RsvgState * state, RsvgBbox *bbox)\n{\n    int x, y, height, width;\n\n    x = bbox->rect.x;\n    y = bbox->rect.y;\n    width = bbox->rect.width;\n    height = bbox->rect.height;\n\n    ctx->width = cairo_image_surface_get_width (ctx->source_surface);\n    ctx->height = cairo_image_surface_get_height (ctx->source_surface);\n\n    ctx->affine = state->affine;\n    if (ctx->filter->filterunits == objectBoundingBox) {\n        cairo_matrix_t affine;\n        cairo_matrix_init (&affine, width, 0, 0, height, x, y);\n        cairo_matrix_multiply (&ctx->affine, &affine, &ctx->affine);\n    }\n    ctx->paffine = state->affine;\n    if (ctx->filter->primitiveunits == objectBoundingBox) {\n        cairo_matrix_t affine;\n        cairo_matrix_init (&affine, width, 0, 0, height, x, y);\n        cairo_matrix_multiply (&ctx->paffine, &affine, &ctx->paffine);\n    }\n}\n\nstatic gboolean\nrectangle_intersect (gint ax, gint ay, gint awidth, gint aheight,\n                     gint bx, gint by, gint bwidth, gint bheight,\n                     gint *rx, gint *ry, gint *rwidth, gint *rheight)\n{\n    gint rx1, ry1, rx2, ry2;\n\n    rx1 = MAX (ax, bx);\n    ry1 = MAX (ay, by);\n    rx2 = MIN (ax + awidth, bx + bwidth);\n    ry2 = MIN (ay + aheight, by + bheight);\n\n    if (rx2 > rx1 && ry2 > ry1) {\n        *rx = rx1;\n        *ry = ry1;\n        *rwidth = rx2 - rx1;\n        *rheight = ry2 - ry1;\n\n        return TRUE;\n    } else {\n        *rx = *ry = *rwidth = *rheight = 0;\n\n        return FALSE;\n    }\n}\n\nstatic void\nrsvg_alpha_blt (cairo_surface_t *src,\n                gint srcx,\n                gint srcy,\n                gint srcwidth,\n                gint srcheight,\n                cairo_surface_t *dst,\n                gint dstx,\n                gint dsty)\n{\n    gint src_surf_width, src_surf_height;\n    gint dst_surf_width, dst_surf_height;\n    gint src_clipped_x, src_clipped_y, src_clipped_width, src_clipped_height;\n    gint dst_clipped_x, dst_clipped_y, dst_clipped_width, dst_clipped_height;\n    gint x, y, srcrowstride, dstrowstride, sx, sy, dx, dy;\n    guchar *src_pixels, *dst_pixels;\n\n    g_assert (cairo_image_surface_get_format (src) == CAIRO_FORMAT_ARGB32);\n    g_assert (cairo_image_surface_get_format (dst) == CAIRO_FORMAT_ARGB32);\n\n    cairo_surface_flush (src);\n\n    src_surf_width  = cairo_image_surface_get_width (src);\n    src_surf_height = cairo_image_surface_get_height (src);\n\n    dst_surf_width  = cairo_image_surface_get_width (dst);\n    dst_surf_height = cairo_image_surface_get_height (dst);\n\n    if (!rectangle_intersect (0, 0, src_surf_width, src_surf_height,\n                              srcx, srcy, srcwidth, srcheight,\n                              &src_clipped_x, &src_clipped_y, &src_clipped_width, &src_clipped_height))\n        return; /* source rectangle is not in source surface */\n\n    if (!rectangle_intersect (0, 0, dst_surf_width, dst_surf_height,\n                              dstx, dsty, src_clipped_width, src_clipped_height,\n                              &dst_clipped_x, &dst_clipped_y, &dst_clipped_width, &dst_clipped_height))\n        return; /* dest rectangle is not in dest surface */\n\n    srcrowstride = cairo_image_surface_get_stride (src);\n    dstrowstride = cairo_image_surface_get_stride (dst);\n\n    src_pixels = cairo_image_surface_get_data (src);\n    dst_pixels = cairo_image_surface_get_data (dst);\n\n    for (y = 0; y < dst_clipped_height; y++)\n        for (x = 0; x < dst_clipped_width; x++) {\n            guint a, c, ad, cd, ar, cr, i;\n\n            sx = x + src_clipped_x;\n            sy = y + src_clipped_y;\n            dx = x + dst_clipped_x;\n            dy = y + dst_clipped_y;\n            a = src_pixels[4 * sx + sy * srcrowstride + 3];\n\n            if (a) {\n                ad = dst_pixels[4 * dx + dy * dstrowstride + 3];\n                ar = a + ad * (255 - a) / 255;\n                dst_pixels[4 * dx + dy * dstrowstride + 3] = ar;\n                for (i = 0; i < 3; i++) {\n                    c = src_pixels[4 * sx + sy * srcrowstride + i];\n                    cd = dst_pixels[4 * dx + dy * dstrowstride + i];\n                    cr = c + cd * (255 - a) / 255;\n                    dst_pixels[4 * dx + dy * dstrowstride + i] = cr;\n                }\n            }\n        }\n\n    cairo_surface_mark_dirty (dst);\n}\n\nstatic gboolean\nrsvg_art_affine_image (cairo_surface_t *img,\n                       cairo_surface_t *intermediate,\n                       cairo_matrix_t *affine,\n                       double w,\n                       double h)\n{\n    cairo_matrix_t inv_affine, raw_inv_affine;\n    gint intstride;\n    gint basestride;\n    gint basex, basey;\n    gdouble fbasex, fbasey;\n    gdouble rawx, rawy;\n    guchar *intpix;\n    guchar *basepix;\n    gint i, j, k, basebpp, ii, jj;\n    gboolean has_alpha;\n    gdouble pixsum[4];\n    gboolean xrunnoff, yrunnoff;\n    gint iwidth, iheight;\n    gint width, height;\n\n    g_assert (cairo_image_surface_get_format (intermediate) == CAIRO_FORMAT_ARGB32);\n\n    cairo_surface_flush (img);\n\n    width = cairo_image_surface_get_width (img);\n    height = cairo_image_surface_get_height (img);\n    iwidth = cairo_image_surface_get_width (intermediate);\n    iheight = cairo_image_surface_get_height (intermediate);\n\n    has_alpha = cairo_image_surface_get_format (img) == CAIRO_FORMAT_ARGB32;\n\n    basestride = cairo_image_surface_get_stride (img);\n    intstride = cairo_image_surface_get_stride (intermediate);\n    basepix = cairo_image_surface_get_data (img);\n    intpix = cairo_image_surface_get_data (intermediate);\n    basebpp = has_alpha ? 4 : 3;\n\n    raw_inv_affine = *affine;\n    if (cairo_matrix_invert (&raw_inv_affine) != CAIRO_STATUS_SUCCESS)\n      return FALSE;\n\n    cairo_matrix_init_scale (&inv_affine, w, h);\n    cairo_matrix_multiply (&inv_affine, &inv_affine, affine);\n    if (cairo_matrix_invert (&inv_affine) != CAIRO_STATUS_SUCCESS)\n      return FALSE;\n\n    /*apply the transformation */\n    for (i = 0; i < iwidth; i++)\n        for (j = 0; j < iheight; j++) {\n            fbasex = (inv_affine.xx * (double) i + inv_affine.xy * (double) j +\n                      inv_affine.x0) * (double) width;\n            fbasey = (inv_affine.yx * (double) i + inv_affine.yy * (double) j +\n                      inv_affine.y0) * (double) height;\n            basex = floor (fbasex);\n            basey = floor (fbasey);\n            rawx = raw_inv_affine.xx * i + raw_inv_affine.xy * j + raw_inv_affine.x0;\n            rawy = raw_inv_affine.yx * i + raw_inv_affine.yy * j + raw_inv_affine.y0;\n            if (rawx < 0 || rawy < 0 || rawx >= w ||\n                rawy >= h || basex < 0 || basey < 0 || basex >= width || basey >= height) {\n                for (k = 0; k < 4; k++)\n                    intpix[i * 4 + j * intstride + k] = 0;\n            } else {\n                if (basex < 0 || basex + 1 >= width)\n                    xrunnoff = TRUE;\n                else\n                    xrunnoff = FALSE;\n                if (basey < 0 || basey + 1 >= height)\n                    yrunnoff = TRUE;\n                else\n                    yrunnoff = FALSE;\n                for (k = 0; k < basebpp; k++)\n                    pixsum[k] = 0;\n                for (ii = 0; ii < 2; ii++)\n                    for (jj = 0; jj < 2; jj++) {\n                        if (basex + ii < 0 || basey + jj < 0\n                            || basex + ii >= width || basey + jj >= height);\n                        else {\n                            for (k = 0; k < basebpp; k++) {\n                                pixsum[k] +=\n                                    (double) basepix[basebpp * (basex + ii) +\n                                                     (basey + jj) * basestride + k]\n                                    * (xrunnoff ? 1 : fabs (fbasex - (double) (basex + (1 - ii))))\n                                    * (yrunnoff ? 1 : fabs (fbasey - (double) (basey + (1 - jj))));\n                            }\n                        }\n                    }\n                for (k = 0; k < basebpp; k++)\n                    intpix[i * 4 + j * intstride + k] = pixsum[k];\n                if (!has_alpha)\n                    intpix[i * 4 + j * intstride + 3] = 255;\n            }\n\n        }\n\n    /* Don't need cairo_surface_mark_dirty(intermediate) here since\n     * the only caller does further work and then calls that himself.\n     */\n\n    return TRUE;\n}\n\nstatic void\nrsvg_filter_free_pair (gpointer value)\n{\n    RsvgFilterPrimitiveOutput *output;\n\n    output = (RsvgFilterPrimitiveOutput *) value;\n    cairo_surface_destroy (output->surface);\n    g_free (output);\n}\n\nstatic void\nrsvg_filter_context_free (RsvgFilterContext * ctx)\n{\n    if (!ctx)\n        return;\n\n    if (ctx->bg_surface)\n        cairo_surface_destroy (ctx->bg_surface);\n\n    g_free (ctx);\n}\n\nstatic gboolean\nnode_is_filter_primitive (RsvgNode *node)\n{\n    RsvgNodeType type = rsvg_node_get_type (node);\n\n    return type > RSVG_NODE_TYPE_FILTER_PRIMITIVE_FIRST && type < RSVG_NODE_TYPE_FILTER_PRIMITIVE_LAST;\n}\n\nstatic gboolean\nrender_child_if_filter_primitive (RsvgNode *node, gpointer data)\n{\n    RsvgFilterContext *filter_ctx = data;\n\n    if (node_is_filter_primitive (node)) {\n        RsvgFilterPrimitive *primitive;\n\n        primitive = rsvg_rust_cnode_get_impl (node);\n        rsvg_filter_primitive_render (node, primitive, filter_ctx);\n    }\n\n    return TRUE;\n}\n\n/**\n * rsvg_filter_render:\n * @node: a pointer to the filter node to use\n * @source: the a #cairo_surface_t of type %CAIRO_SURFACE_TYPE_IMAGE\n * @context: the context\n *\n * Create a new surface applied the filter. This function will create\n * a context for itself, set up the coordinate systems execute all its\n * little primatives and then clean up its own mess.\n *\n * Returns: (transfer full): a new #cairo_surface_t\n **/\ncairo_surface_t *\nrsvg_filter_render (RsvgNode *filter_node,\n                    cairo_surface_t *source,\n                    RsvgDrawingCtx *context,\n                    RsvgBbox *bounds,\n                    char *channelmap)\n{\n    RsvgFilter *filter;\n    RsvgFilterContext *ctx;\n    guint i;\n    cairo_surface_t *output;\n\n    g_return_val_if_fail (source != NULL, NULL);\n    g_return_val_if_fail (cairo_surface_get_type (source) == CAIRO_SURFACE_TYPE_IMAGE, NULL);\n\n    g_assert (rsvg_node_get_type (filter_node) == RSVG_NODE_TYPE_FILTER);\n    filter = rsvg_rust_cnode_get_impl (filter_node);\n\n    ctx = g_new0 (RsvgFilterContext, 1);\n    ctx->filter = filter;\n    ctx->source_surface = source;\n    ctx->bg_surface = NULL;\n    ctx->results = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, rsvg_filter_free_pair);\n    ctx->ctx = context;\n\n    rsvg_filter_fix_coordinate_system (ctx, rsvg_current_state (context), bounds);\n\n    ctx->lastresult.surface = cairo_surface_reference (source);\n    ctx->lastresult.bounds = rsvg_filter_primitive_get_bounds (NULL, ctx);\n\n    for (i = 0; i < 4; i++)\n        ctx->channelmap[i] = channelmap[i] - '0';\n\n    rsvg_node_foreach_child (filter_node, render_child_if_filter_primitive, ctx);\n\n    output = ctx->lastresult.surface;\n\n    g_hash_table_destroy (ctx->results);\n\n    rsvg_filter_context_free (ctx);\n\n    return output;\n}\n\n/**\n * rsvg_filter_store_result:\n * @name: The name of the result\n * @result: The pointer to the result\n * @ctx: the context that this was called in\n *\n * Puts the new result into the hash for easy finding later, also\n * Stores it as the last result\n **/\nstatic void\nrsvg_filter_store_output (GString * name, RsvgFilterPrimitiveOutput result, RsvgFilterContext * ctx)\n{\n    RsvgFilterPrimitiveOutput *store;\n\n    cairo_surface_destroy (ctx->lastresult.surface);\n\n    store = g_new0 (RsvgFilterPrimitiveOutput, 1);\n    *store = result;\n\n    if (name->str[0] != '\\0') {\n        cairo_surface_reference (result.surface);        /* increments the references for the table */\n        g_hash_table_insert (ctx->results, g_strdup (name->str), store);\n    }\n\n    cairo_surface_reference (result.surface);    /* increments the references for the last result */\n    ctx->lastresult = result;\n}\n\nstatic void\nrsvg_filter_store_result (GString * name,\n                          cairo_surface_t *surface,\n                          RsvgFilterContext * ctx)\n{\n    RsvgFilterPrimitiveOutput output;\n    output.bounds.x0 = 0;\n    output.bounds.y0 = 0;\n    output.bounds.x1 = ctx->width;\n    output.bounds.y1 = ctx->height;\n    output.surface = surface;\n\n    rsvg_filter_store_output (name, output, ctx);\n}\n\nstatic cairo_surface_t *\nsurface_get_alpha (cairo_surface_t *source,\n                   RsvgFilterContext * ctx)\n{\n    guchar *data;\n    guchar *pbdata;\n    gsize i, pbsize;\n    cairo_surface_t *surface;\n\n    if (source == NULL)\n        return NULL;\n\n    cairo_surface_flush (source);\n\n    pbsize = cairo_image_surface_get_width (source) *\n             cairo_image_surface_get_height (source);\n\n    surface = _rsvg_image_surface_new (cairo_image_surface_get_width (source),\n                                       cairo_image_surface_get_height (source));\n    if (surface == NULL)\n        return NULL;\n\n    data = cairo_image_surface_get_data (surface);\n    pbdata = cairo_image_surface_get_data (source);\n\n    /* FIXMEchpe: rewrite this into nested width, height loops */\n    for (i = 0; i < pbsize; i++)\n        data[i * 4 + ctx->channelmap[3]] = pbdata[i * 4 + ctx->channelmap[3]];\n\n    cairo_surface_mark_dirty (surface);\n    return surface;\n}\n\nstatic cairo_surface_t *\nrsvg_compile_bg (RsvgDrawingCtx * ctx)\n{\n    RsvgCairoRender *render = RSVG_CAIRO_RENDER (ctx->render);\n    cairo_surface_t *surface;\n    cairo_t *cr;\n    GList *i;\n\n    surface = _rsvg_image_surface_new (render->width, render->height);\n    if (surface == NULL)\n        return NULL;\n\n    cr = cairo_create (surface);\n\n    for (i = g_list_last (render->cr_stack); i != NULL; i = g_list_previous (i)) {\n        cairo_t *draw = i->data;\n        gboolean nest = draw != render->initial_cr;\n        cairo_set_source_surface (cr, cairo_get_target (draw),\n                                  nest ? 0 : -render->offset_x,\n                                  nest ? 0 : -render->offset_y);\n        cairo_paint (cr);\n    }\n\n    cairo_destroy (cr);\n\n    return surface;\n}\n\n/**\n * rsvg_filter_get_bg:\n *\n * Returns: (transfer none) (nullable): a #cairo_surface_t, or %NULL\n */\nstatic cairo_surface_t *\nrsvg_filter_get_bg (RsvgFilterContext * ctx)\n{\n    if (!ctx->bg_surface)\n        ctx->bg_surface = rsvg_compile_bg (ctx->ctx);\n\n    return ctx->bg_surface;\n}\n\n/* FIXMEchpe: proper return value and out param! */\n/**\n * rsvg_filter_get_result:\n * @name: The name of the surface\n * @ctx: the context that this was called in\n *\n * Gets a surface for a primitive\n *\n * Returns: (nullable): a pointer to the result that the name refers to, a special\n * surface if the name is a special keyword or %NULL if nothing was found\n **/\nstatic RsvgFilterPrimitiveOutput\nrsvg_filter_get_result (GString * name, RsvgFilterContext * ctx)\n{\n    RsvgFilterPrimitiveOutput output;\n    RsvgFilterPrimitiveOutput *outputpointer;\n    output.bounds.x0 = output.bounds.x1 = output.bounds.y0 = output.bounds.y1 = 0;\n\n    if (!strcmp (name->str, \"SourceGraphic\")) {\n        output.surface = cairo_surface_reference (ctx->source_surface);\n        return output;\n    } else if (!strcmp (name->str, \"BackgroundImage\")) {\n        output.surface = rsvg_filter_get_bg (ctx);\n        if (output.surface)\n            cairo_surface_reference (output.surface);\n        return output;\n    } else if (!strcmp (name->str, \"\") || !strcmp (name->str, \"none\")) {\n        output = ctx->lastresult;\n        cairo_surface_reference (output.surface);\n        return output;\n    } else if (!strcmp (name->str, \"SourceAlpha\")) {\n        output.surface = surface_get_alpha (ctx->source_surface, ctx);\n        return output;\n    } else if (!strcmp (name->str, \"BackgroundAlpha\")) {\n        output.surface = surface_get_alpha (rsvg_filter_get_bg (ctx), ctx);\n        return output;\n    }\n\n    outputpointer = (RsvgFilterPrimitiveOutput *) (g_hash_table_lookup (ctx->results, name->str));\n\n    if (outputpointer != NULL) {\n        output = *outputpointer;\n        cairo_surface_reference (output.surface);\n        return output;\n    }\n\n    /* g_warning (_(\"%s not found\\n\"), name->str); */\n\n    output = ctx->lastresult;\n    cairo_surface_reference (output.surface);\n    return output;\n}\n\n/**\n * rsvg_filter_get_in:\n * @name:\n * @ctx:\n *\n * Returns: (transfer full) (nullable): a new #cairo_surface_t, or %NULL\n */\nstatic cairo_surface_t *\nrsvg_filter_get_in (GString * name, RsvgFilterContext * ctx)\n{\n    return rsvg_filter_get_result (name, ctx).surface;\n}\n\nstatic void\nrsvg_filter_set_atts (RsvgNode *node, gpointer impl, RsvgHandle *handle, RsvgPropertyBag *atts)\n{\n    RsvgFilter *filter = impl;\n    const char *value;\n\n    if ((value = rsvg_property_bag_lookup (atts, \"filterUnits\"))) {\n        if (!strcmp (value, \"userSpaceOnUse\"))\n            filter->filterunits = userSpaceOnUse;\n        else\n            filter->filterunits = objectBoundingBox;\n    }\n    if ((value = rsvg_property_bag_lookup (atts, \"primitiveUnits\"))) {\n        if (!strcmp (value, \"objectBoundingBox\"))\n            filter->primitiveunits = objectBoundingBox;\n        else\n            filter->primitiveunits = userSpaceOnUse;\n    }\n    if ((value = rsvg_property_bag_lookup (atts, \"x\")))\n        filter->x = rsvg_length_parse (value, LENGTH_DIR_HORIZONTAL);\n    if ((value = rsvg_property_bag_lookup (atts, \"y\")))\n        filter->y = rsvg_length_parse (value, LENGTH_DIR_VERTICAL);\n    if ((value = rsvg_property_bag_lookup (atts, \"width\")))\n        filter->width = rsvg_length_parse (value, LENGTH_DIR_HORIZONTAL);\n    if ((value = rsvg_property_bag_lookup (atts, \"height\")))\n        filter->height = rsvg_length_parse (value, LENGTH_DIR_VERTICAL);\n}\n\nstatic void\nrsvg_filter_draw (RsvgNode *node, gpointer impl, RsvgDrawingCtx *ctx, int dominate)\n{\n    /* nothing; filters are drawn in rsvg-cairo-draw.c */\n}\n\nstatic void\nrsvg_filter_free (gpointer impl)\n{\n    RsvgFilter *filter = impl;\n\n    g_free (filter);\n}\n\n/**\n * rsvg_new_filter:\n *\n * Creates a blank filter and assigns default values to everything\n **/\nRsvgNode *\nrsvg_new_filter (const char *element_name, RsvgNode *parent)\n{\n    RsvgFilter *filter;\n\n    filter = g_new0 (RsvgFilter, 1);\n    filter->filterunits = objectBoundingBox;\n    filter->primitiveunits = userSpaceOnUse;\n    filter->x = rsvg_length_parse (\"-10%\", LENGTH_DIR_HORIZONTAL);\n    filter->y = rsvg_length_parse (\"-10%\", LENGTH_DIR_VERTICAL);\n    filter->width = rsvg_length_parse (\"120%\", LENGTH_DIR_HORIZONTAL);\n    filter->height = rsvg_length_parse (\"120%\", LENGTH_DIR_VERTICAL);\n\n    return rsvg_rust_cnode_new (RSVG_NODE_TYPE_FILTER,\n                                parent,\n                                rsvg_state_new (),\n                                filter,\n                                rsvg_filter_set_atts,\n                                rsvg_filter_draw,\n                                rsvg_filter_free);\n}\n\n/*************************************************************/\n/*************************************************************/\n\ntypedef enum {\n    normal, multiply, screen, darken, lighten, softlight,\n    hardlight, colordodge, colorburn, overlay, exclusion,\n    difference\n} RsvgFilterPrimitiveBlendMode;\n\ntypedef struct _RsvgFilterPrimitiveBlend RsvgFilterPrimitiveBlend;\nstruct _RsvgFilterPrimitiveBlend {\n    RsvgFilterPrimitive super;\n    RsvgFilterPrimitiveBlendMode mode;\n    GString *in2;\n};\n\nstatic void\nrsvg_filter_blend (RsvgFilterPrimitiveBlendMode mode,\n                   cairo_surface_t *in,\n                   cairo_surface_t *in2,\n                   cairo_surface_t* output,\n                   RsvgIRect boundarys,\n                   int *channelmap)\n{\n    guchar i;\n    gint x, y;\n    gint rowstride, rowstride2, rowstrideo, height, width;\n    guchar *in_pixels;\n    guchar *in2_pixels;\n    guchar *output_pixels;\n\n    cairo_surface_flush (in);\n    cairo_surface_flush (in2);\n\n    height = cairo_image_surface_get_height (in);\n    width = cairo_image_surface_get_width (in);\n    rowstride = cairo_image_surface_get_stride (in);\n    rowstride2 = cairo_image_surface_get_stride (in2);\n    rowstrideo = cairo_image_surface_get_stride (output);\n\n    output_pixels = cairo_image_surface_get_data (output);\n    in_pixels = cairo_image_surface_get_data (in);\n    in2_pixels = cairo_image_surface_get_data (in2);\n\n    if (boundarys.x0 < 0)\n        boundarys.x0 = 0;\n    if (boundarys.y0 < 0)\n        boundarys.y0 = 0;\n    if (boundarys.x1 >= width)\n        boundarys.x1 = width;\n    if (boundarys.y1 >= height)\n        boundarys.y1 = height;\n\n    for (y = boundarys.y0; y < boundarys.y1; y++)\n        for (x = boundarys.x0; x < boundarys.x1; x++) {\n            double qr, cr, qa, qb, ca, cb, bca, bcb;\n            int ch;\n\n            qa = (double) in_pixels[4 * x + y * rowstride + channelmap[3]] / 255.0;\n            qb = (double) in2_pixels[4 * x + y * rowstride2 + channelmap[3]] / 255.0;\n            qr = 1 - (1 - qa) * (1 - qb);\n            cr = 0;\n            for (ch = 0; ch < 3; ch++) {\n                i = channelmap[ch];\n                ca = (double) in_pixels[4 * x + y * rowstride + i] / 255.0;\n                cb = (double) in2_pixels[4 * x + y * rowstride2 + i] / 255.0;\n                /*these are the ca and cb that are used in the non-standard blend functions */\n                bcb = (1 - qa) * cb + ca;\n                bca = (1 - qb) * ca + cb;\n                switch (mode) {\n                case normal:\n                    cr = (1 - qa) * cb + ca;\n                    break;\n                case multiply:\n                    cr = (1 - qa) * cb + (1 - qb) * ca + ca * cb;\n                    break;\n                case screen:\n                    cr = cb + ca - ca * cb;\n                    break;\n                case darken:\n                    cr = MIN ((1 - qa) * cb + ca, (1 - qb) * ca + cb);\n                    break;\n                case lighten:\n                    cr = MAX ((1 - qa) * cb + ca, (1 - qb) * ca + cb);\n                    break;\n                case softlight:\n                    if (bcb < 0.5)\n                        cr = 2 * bca * bcb + bca * bca * (1 - 2 * bcb);\n                    else\n                        cr = sqrt (bca) * (2 * bcb - 1) + (2 * bca) * (1 - bcb);\n                    break;\n                case hardlight:\n                    if (cb < 0.5)\n                        cr = 2 * bca * bcb;\n                    else\n                        cr = 1 - 2 * (1 - bca) * (1 - bcb);\n                    break;\n                case colordodge:\n                    if (bcb == 1)\n                        cr = 1;\n                    else\n                        cr = MIN (bca / (1 - bcb), 1);\n                    break;\n                case colorburn:\n                    if (bcb == 0)\n                        cr = 0;\n                    else\n                        cr = MAX (1 - (1 - bca) / bcb, 0);\n                    break;\n                case overlay:\n                    if (bca < 0.5)\n                        cr = 2 * bca * bcb;\n                    else\n                        cr = 1 - 2 * (1 - bca) * (1 - bcb);\n                    break;\n                case exclusion:\n                    cr = bca + bcb - 2 * bca * bcb;\n                    break;\n                case difference:\n                    cr = abs (bca - bcb);\n                    break;\n                }\n                cr *= 255.0;\n                if (cr > 255)\n                    cr = 255;\n                if (cr < 0)\n                    cr = 0;\n                output_pixels[4 * x + y * rowstrideo + i] = (guchar) cr;\n\n            }\n            output_pixels[4 * x + y * rowstrideo + channelmap[3]] = qr * 255.0;\n        }\n\n    cairo_surface_mark_dirty (output);\n}\n\nstatic void\nrsvg_filter_primitive_blend_render (RsvgNode *node, RsvgFilterPrimitive *primitive, RsvgFilterContext *ctx)\n{\n    RsvgFilterPrimitiveBlend *blend = (RsvgFilterPrimitiveBlend *) primitive;\n    RsvgIRect boundarys;\n    cairo_surface_t *output, *in, *in2;\n\n    boundarys = rsvg_filter_primitive_get_bounds (primitive, ctx);\n\n    in = rsvg_filter_get_in (primitive->in, ctx);\n    if (in == NULL)\n      return;\n\n    in2 = rsvg_filter_get_in (blend->in2, ctx);\n    if (in2 == NULL) {\n        cairo_surface_destroy (in);\n        return;\n    }\n\n    output = _rsvg_image_surface_new (cairo_image_surface_get_width (in),\n                                      cairo_image_surface_get_height (in));\n    if (output == NULL) {\n        cairo_surface_destroy (in);\n        cairo_surface_destroy (in2);\n        return;\n    }\n\n    rsvg_filter_blend (blend->mode, in, in2, output, boundarys, ctx->channelmap);\n\n    rsvg_filter_store_result (primitive->result, output, ctx);\n\n    cairo_surface_destroy (in);\n    cairo_surface_destroy (in2);\n    cairo_surface_destroy (output);\n}\n\nstatic void\nrsvg_filter_primitive_blend_free (gpointer impl)\n{\n    RsvgFilterPrimitiveBlend *blend = impl;\n\n    g_string_free (blend->in2, TRUE);\n\n    rsvg_filter_primitive_free (impl);\n}\n\nstatic void\nrsvg_filter_primitive_blend_set_atts (RsvgNode *node, gpointer impl, RsvgHandle *handle, RsvgPropertyBag *atts)\n{\n    RsvgFilterPrimitiveBlend *filter = impl;\n    const char *value;\n\n    if ((value = rsvg_property_bag_lookup (atts, \"mode\"))) {\n        if (!strcmp (value, \"multiply\"))\n            filter->mode = multiply;\n        else if (!strcmp (value, \"screen\"))\n            filter->mode = screen;\n        else if (!strcmp (value, \"darken\"))\n            filter->mode = darken;\n        else if (!strcmp (value, \"lighten\"))\n            filter->mode = lighten;\n        else\n            filter->mode = normal;\n    }\n    if ((value = rsvg_property_bag_lookup (atts, \"in\")))\n        g_string_assign (filter->super.in, value);\n    if ((value = rsvg_property_bag_lookup (atts, \"in2\")))\n        g_string_assign (filter->in2, value);\n    if ((value = rsvg_property_bag_lookup (atts, \"result\")))\n        g_string_assign (filter->super.result, value);\n\n    filter_primitive_set_x_y_width_height_atts ((RsvgFilterPrimitive *) filter, atts);\n}\n\nRsvgNode *\nrsvg_new_filter_primitive_blend (const char *element_name, RsvgNode *parent)\n{\n    RsvgFilterPrimitiveBlend *filter;\n\n    filter = g_new0 (RsvgFilterPrimitiveBlend, 1);\n    filter->mode = normal;\n    filter->super.in = g_string_new (\"none\");\n    filter->in2 = g_string_new (\"none\");\n    filter->super.result = g_string_new (\"none\");\n    filter->super.render = rsvg_filter_primitive_blend_render;\n\n    return rsvg_rust_cnode_new (RSVG_NODE_TYPE_FILTER_PRIMITIVE_BLEND,\n                                parent,\n                                rsvg_state_new (),\n                                filter,\n                                rsvg_filter_primitive_blend_set_atts,\n                                rsvg_filter_draw,\n                                rsvg_filter_primitive_blend_free);\n}\n\n/*************************************************************/\n/*************************************************************/\n\ntypedef struct _RsvgFilterPrimitiveConvolveMatrix RsvgFilterPrimitiveConvolveMatrix;\n\ntypedef enum {\n    EDGE_MODE_DUPLICATE,\n    EDGE_MODE_WRAP,\n    EDGE_MODE_NONE\n} EdgeMode;\n\nstruct _RsvgFilterPrimitiveConvolveMatrix {\n    RsvgFilterPrimitive super;\n    double *KernelMatrix;\n    double divisor;\n    gint orderx, ordery;\n    double dx, dy;\n    double bias;\n    gint targetx, targety;\n    gboolean preservealpha;\n    EdgeMode edgemode;\n};\n\nstatic void\nrsvg_filter_primitive_convolve_matrix_render (RsvgNode *node, RsvgFilterPrimitive *primitive, RsvgFilterContext *ctx)\n{\n    RsvgFilterPrimitiveConvolveMatrix *convolve = (RsvgFilterPrimitiveConvolveMatrix *) primitive;\n\n    guchar ch;\n    gint x, y;\n    gint i, j;\n    gint rowstride, height, width;\n    RsvgIRect boundarys;\n\n    guchar *in_pixels;\n    guchar *output_pixels;\n\n    cairo_surface_t *output, *in;\n\n    gint sx, sy, kx, ky;\n    guchar sval;\n    double kval, sum, dx, dy, targetx, targety;\n    int umch;\n\n    gint tempresult;\n\n    boundarys = rsvg_filter_primitive_get_bounds (primitive, ctx);\n\n    in = rsvg_filter_get_in (primitive->in, ctx);\n    if (in == NULL)\n        return;\n\n    cairo_surface_flush (in);\n\n    in_pixels = cairo_image_surface_get_data (in);\n\n    height = cairo_image_surface_get_height (in);\n    width = cairo_image_surface_get_width (in);\n\n    targetx = convolve->targetx * ctx->paffine.xx;\n    targety = convolve->targety * ctx->paffine.yy;\n\n    if (convolve->dx != 0 || convolve->dy != 0) {\n        dx = convolve->dx * ctx->paffine.xx;\n        dy = convolve->dy * ctx->paffine.yy;\n    } else\n        dx = dy = 1;\n\n    rowstride = cairo_image_surface_get_stride (in);\n\n    output = _rsvg_image_surface_new (width, height);\n    if (output == NULL) {\n        cairo_surface_destroy (in);\n        return;\n    }\n\n    output_pixels = cairo_image_surface_get_data (output);\n\n    for (y = boundarys.y0; y < boundarys.y1; y++) {\n        for (x = boundarys.x0; x < boundarys.x1; x++) {\n            for (umch = 0; umch < 3 + !convolve->preservealpha; umch++) {\n                ch = ctx->channelmap[umch];\n                sum = 0;\n                for (i = 0; i < convolve->ordery; i++) {\n                    for (j = 0; j < convolve->orderx; j++) {\n                        int alpha;\n                        sx = x - targetx + j * dx;\n                        sy = y - targety + i * dy;\n                        if (convolve->edgemode == EDGE_MODE_DUPLICATE) {\n                            if (sx < boundarys.x0)\n                                sx = boundarys.x0;\n                            if (sx >= boundarys.x1)\n                                sx = boundarys.x1 - 1;\n                            if (sy < boundarys.y0)\n                                sy = boundarys.y0;\n                            if (sy >= boundarys.y1)\n                                sy = boundarys.y1 - 1;\n                        } else if (convolve->edgemode == EDGE_MODE_WRAP) {\n                            if (sx < boundarys.x0 || (sx >= boundarys.x1))\n                                sx = boundarys.x0 + (sx - boundarys.x0) %\n                                    (boundarys.x1 - boundarys.x0);\n                            if (sy < boundarys.y0 || (sy >= boundarys.y1))\n                                sy = boundarys.y0 + (sy - boundarys.y0) %\n                                    (boundarys.y1 - boundarys.y0);\n                        } else if (convolve->edgemode == EDGE_MODE_NONE) {\n                            if (sx < boundarys.x0 || (sx >= boundarys.x1) ||\n                                sy < boundarys.y0 || (sy >= boundarys.y1))\n                                continue;\n                        } else {\n                            g_assert_not_reached ();\n                        }\n\n                        kx = convolve->orderx - j - 1;\n                        ky = convolve->ordery - i - 1;\n                        alpha = in_pixels[4 * sx + sy * rowstride + 3];\n                        if (ch == 3)\n                            sval = alpha;\n                        else if (alpha)\n                            sval = in_pixels[4 * sx + sy * rowstride + ch] * 255 / alpha;\n                        else\n                            sval = 0;\n                        kval = convolve->KernelMatrix[kx + ky * convolve->orderx];\n                        sum += (double) sval *kval;\n                    }\n                }\n\n                tempresult = sum / convolve->divisor + convolve->bias;\n\n                if (tempresult > 255)\n                    tempresult = 255;\n                if (tempresult < 0)\n                    tempresult = 0;\n\n                output_pixels[4 * x + y * rowstride + ch] = tempresult;\n            }\n            if (convolve->preservealpha)\n                output_pixels[4 * x + y * rowstride + ctx->channelmap[3]] =\n                    in_pixels[4 * x + y * rowstride + ctx->channelmap[3]];\n            for (umch = 0; umch < 3; umch++) {\n                ch = ctx->channelmap[umch];\n                output_pixels[4 * x + y * rowstride + ch] =\n                    output_pixels[4 * x + y * rowstride + ch] *\n                    output_pixels[4 * x + y * rowstride + ctx->channelmap[3]] / 255;\n            }\n        }\n    }\n\n    cairo_surface_mark_dirty (output);\n\n    rsvg_filter_store_result (primitive->result, output, ctx);\n\n    cairo_surface_destroy (in);\n    cairo_surface_destroy (output);\n}\n\nstatic void\nrsvg_filter_primitive_convolve_matrix_free (gpointer impl)\n{\n    RsvgFilterPrimitiveConvolveMatrix *convolve = impl;\n\n    g_free (convolve->KernelMatrix);\n\n    rsvg_filter_primitive_free (impl);\n}\n\nstatic void\nrsvg_filter_primitive_convolve_matrix_set_atts (RsvgNode *node, gpointer impl, RsvgHandle *handle, RsvgPropertyBag *atts)\n{\n    RsvgFilterPrimitiveConvolveMatrix *filter = impl;\n    gint i, j;\n    const char *value;\n    gboolean has_target_x, has_target_y;\n\n    has_target_x = 0;\n    has_target_y = 0;\n\n    if ((value = rsvg_property_bag_lookup (atts, \"in\")))\n        g_string_assign (filter->super.in, value);\n    if ((value = rsvg_property_bag_lookup (atts, \"result\")))\n        g_string_assign (filter->super.result, value);\n\n    filter_primitive_set_x_y_width_height_atts ((RsvgFilterPrimitive *) filter, atts);\n\n    if ((value = rsvg_property_bag_lookup (atts, \"targetX\"))) {\n        has_target_x = 1;\n        filter->targetx = atoi (value);\n    }\n    if ((value = rsvg_property_bag_lookup (atts, \"targetY\"))) {\n        has_target_y = 1;\n        filter->targety = atoi (value);\n    }\n    if ((value = rsvg_property_bag_lookup (atts, \"bias\")))\n        filter->bias = atof (value);\n    if ((value = rsvg_property_bag_lookup (atts, \"preserveAlpha\"))) {\n        if (!strcmp (value, \"true\"))\n            filter->preservealpha = TRUE;\n        else\n            filter->preservealpha = FALSE;\n    }\n    if ((value = rsvg_property_bag_lookup (atts, \"divisor\")))\n        filter->divisor = atof (value);\n\n    if ((value = rsvg_property_bag_lookup (atts, \"order\"))) {\n        double tempx, tempy;\n        if (rsvg_css_parse_number_optional_number (value, &tempx, &tempy)\n            && tempx >= 1.0 && tempy <= 100.0\n            && tempy >= 1.0 && tempy <= 100.0) {\n            filter->orderx = (int) tempx;\n            filter->ordery = (int) tempy;\n            g_assert (filter->orderx >= 1);\n            g_assert (filter->ordery >= 1);\n\n#define SIZE_OVERFLOWS(a,b) (G_UNLIKELY ((b) > 0 && (a) > G_MAXSIZE / (b)))\n\n            if (SIZE_OVERFLOWS (filter->orderx, filter->ordery)) {\n                rsvg_node_set_attribute_parse_error (node, \"order\", \"number of kernelMatrix elements would be too big\");\n                return;\n            }\n        } else {\n            rsvg_node_set_attribute_parse_error (node, \"order\", \"invalid size for convolve matrix\");\n            return;\n        }\n    }\n\n    if ((value = rsvg_property_bag_lookup (atts, \"kernelUnitLength\"))) {\n        if (!rsvg_css_parse_number_optional_number (value, &filter->dx, &filter->dy)) {\n            rsvg_node_set_attribute_parse_error (node, \"kernelUnitLength\", \"expected number-optional-number\");\n            return;\n        }\n    }\n\n    if ((value = rsvg_property_bag_lookup (atts, \"kernelMatrix\"))) {\n        gsize num_elems;\n        gsize got_num_elems;\n\n        num_elems = filter->orderx * filter->ordery;\n\n        if (!rsvg_css_parse_number_list (value,\n                                         NUMBER_LIST_LENGTH_EXACT,\n                                         num_elems,\n                                         &filter->KernelMatrix,\n                                         &got_num_elems)) {\n            rsvg_node_set_attribute_parse_error (node, \"kernelMatrix\", \"expected a matrix of numbers\");\n            return;\n        }\n\n        g_assert (num_elems == got_num_elems);\n    }\n\n    if ((value = rsvg_property_bag_lookup (atts, \"edgeMode\"))) {\n        if (!strcmp (value, \"duplicate\")) {\n            filter->edgemode = EDGE_MODE_DUPLICATE;\n        } else if (!strcmp (value, \"wrap\")) {\n            filter->edgemode = EDGE_MODE_WRAP;\n        } else if (!strcmp (value, \"none\")) {\n            filter->edgemode = EDGE_MODE_NONE;\n        } else {\n            rsvg_node_set_attribute_parse_error (node, \"edgeMode\", \"expected 'duplicate' | 'wrap' | 'none'\");\n            return;\n        }\n    }\n\n    if (filter->divisor == 0) {\n        for (j = 0; j < filter->orderx; j++)\n            for (i = 0; i < filter->ordery; i++)\n                filter->divisor += filter->KernelMatrix[j + i * filter->orderx];\n    }\n\n    if (filter->divisor == 0)\n        filter->divisor = 1;\n\n    if (!has_target_x) {\n        filter->targetx = floor (filter->orderx / 2);\n    }\n    if (!has_target_y) {\n        filter->targety = floor (filter->ordery / 2);\n    }\n}\n\nRsvgNode *\nrsvg_new_filter_primitive_convolve_matrix (const char *element_name, RsvgNode *parent)\n{\n    RsvgFilterPrimitiveConvolveMatrix *filter;\n\n    filter = g_new0 (RsvgFilterPrimitiveConvolveMatrix, 1);\n    filter->super.in = g_string_new (\"none\");\n    filter->super.result = g_string_new (\"none\");\n    filter->KernelMatrix = NULL;\n    filter->divisor = 0;\n    filter->bias = 0;\n    filter->dx = 0;\n    filter->dy = 0;\n    filter->preservealpha = FALSE;\n    filter->edgemode = EDGE_MODE_DUPLICATE;\n    filter->super.render = rsvg_filter_primitive_convolve_matrix_render;\n\n    return rsvg_rust_cnode_new (RSVG_NODE_TYPE_FILTER_PRIMITIVE_CONVOLVE_MATRIX,\n                                parent,\n                                rsvg_state_new (),\n                                filter,\n                                rsvg_filter_primitive_convolve_matrix_set_atts,\n                                rsvg_filter_draw,\n                                rsvg_filter_primitive_convolve_matrix_free);\n}\n\n/*************************************************************/\n/*************************************************************/\n\ntypedef struct _RsvgFilterPrimitiveGaussianBlur\n RsvgFilterPrimitiveGaussianBlur;\n\nstruct _RsvgFilterPrimitiveGaussianBlur {\n    RsvgFilterPrimitive super;\n    double sdx, sdy;\n};\n\nstatic void\nbox_blur_line (gint box_width, gint even_offset,\n               guchar *src, guchar *dest,\n               gint len, gint bpp)\n{\n    gint  i;\n    gint  lead;    /* This marks the leading edge of the kernel              */\n    gint  output;  /* This marks the center of the kernel                    */\n    gint  trail;   /* This marks the pixel BEHIND the last 1 in the\n                      kernel; it's the pixel to remove from the accumulator. */\n    gint  *ac;     /* Accumulator for each channel                           */\n\n    g_assert (box_width > 0);\n\n    ac = g_new0 (gint, bpp);\n\n    /* The algorithm differs for even and odd-sized kernels.\n     * With the output at the center,\n     * If odd, the kernel might look like this: 0011100\n     * If even, the kernel will either be centered on the boundary between\n     * the output and its left neighbor, or on the boundary between the\n     * output and its right neighbor, depending on even_lr.\n     * So it might be 0111100 or 0011110, where output is on the center\n     * of these arrays.\n     */\n    lead = 0;\n\n    if (box_width % 2 != 0) {\n        /* Odd-width kernel */\n        output = lead - (box_width - 1) / 2;\n        trail  = lead - box_width;\n    } else {\n        /* Even-width kernel. */\n        if (even_offset == 1) {\n            /* Right offset */\n            output = lead + 1 - box_width / 2;\n            trail  = lead - box_width;\n        } else if (even_offset == -1) {\n            /* Left offset */\n            output = lead - box_width / 2;\n            trail  = lead - box_width;\n        } else {\n            /* If even_offset isn't 1 or -1, there's some error. */\n            g_assert_not_reached ();\n        }\n    }\n\n    /* Initialize accumulator */\n    for (i = 0; i < bpp; i++)\n        ac[i] = 0;\n\n    /* As the kernel moves across the image, it has a leading edge and a\n     * trailing edge, and the output is in the middle. */\n    while (output < len) {\n        /* The number of pixels that are both in the image and\n         * currently covered by the kernel. This is necessary to\n         * handle edge cases. */\n        guint coverage = (lead < len ? lead : len - 1) - (trail >= 0 ? trail : -1);\n\n#ifdef READABLE_BOXBLUR_CODE\n/* The code here does the same as the code below, but the code below\n * has been optimized by moving the if statements out of the tight for\n * loop, and is harder to understand.\n * Don't use both this code and the code below. */\n        for (i = 0; i < bpp; i++) {\n            /* If the leading edge of the kernel is still on the image,\n             * add the value there to the accumulator. */\n            if (lead < len)\n                ac[i] += src[bpp * lead + i];\n\n            /* If the trailing edge of the kernel is on the image,\n             * subtract the value there from the accumulator. */\n            if (trail >= 0)\n                ac[i] -= src[bpp * trail + i];\n\n            /* Take the averaged value in the accumulator and store\n             * that value in the output. The number of pixels currently\n             * stored in the accumulator can be less than the nominal\n             * width of the kernel because the kernel can go \"over the edge\"\n             * of the image. */\n            if (output >= 0)\n                dest[bpp * output + i] = (ac[i] + (coverage >> 1)) / coverage;\n        }\n#endif\n\n        /* If the leading edge of the kernel is still on the image... */\n        if (lead < len) {\n            if (trail >= 0) {\n                /* If the trailing edge of the kernel is on the image. (Since\n                 * the output is in between the lead and trail, it must be on\n                 * the image. */\n                for (i = 0; i < bpp; i++) {\n                    ac[i] += src[bpp * lead + i];\n                    ac[i] -= src[bpp * trail + i];\n                    dest[bpp * output + i] = (ac[i] + (coverage >> 1)) / coverage;\n                }\n            } else if (output >= 0) {\n                /* If the output is on the image, but the trailing edge isn't yet\n                 * on the image. */\n\n                for (i = 0; i < bpp; i++) {\n                    ac[i] += src[bpp * lead + i];\n                    dest[bpp * output + i] = (ac[i] + (coverage >> 1)) / coverage;\n                }\n            } else {\n                /* If leading edge is on the image, but the output and trailing\n                 * edge aren't yet on the image. */\n                for (i = 0; i < bpp; i++)\n                    ac[i] += src[bpp * lead + i];\n            }\n        } else if (trail >= 0) {\n            /* If the leading edge has gone off the image, but the output and\n             * trailing edge are on the image. (The big loop exits when the\n             * output goes off the image. */\n            for (i = 0; i < bpp; i++) {\n                ac[i] -= src[bpp * trail + i];\n                dest[bpp * output + i] = (ac[i] + (coverage >> 1)) / coverage;\n            }\n        } else if (output >= 0) {\n            /* Leading has gone off the image and trailing isn't yet in it\n             * (small image) */\n            for (i = 0; i < bpp; i++)\n                dest[bpp * output + i] = (ac[i] + (coverage >> 1)) / coverage;\n        }\n\n        lead++;\n        output++;\n        trail++;\n    }\n\n    g_free (ac);\n}\n\nstatic gint\ncompute_box_blur_width (double radius)\n{\n    double width;\n\n    width = radius * 3 * sqrt (2 * G_PI) / 4;\n    return (gint) (width + 0.5);\n}\n\n#define SQR(x) ((x) * (x))\n\nstatic void\nmake_gaussian_convolution_matrix (gdouble radius, gdouble **out_matrix, gint *out_matrix_len)\n{\n    gdouble *matrix;\n    gdouble std_dev;\n    gdouble sum;\n    gint matrix_len;\n    gint i, j;\n\n    std_dev = radius + 1.0;\n    radius = std_dev * 2;\n\n    matrix_len = 2 * ceil (radius - 0.5) + 1;\n    if (matrix_len <= 0)\n        matrix_len = 1;\n\n    matrix = g_new0 (gdouble, matrix_len);\n\n    /* Fill the matrix by doing numerical integration approximation\n     * from -2*std_dev to 2*std_dev, sampling 50 points per pixel.\n     * We do the bottom half, mirror it to the top half, then compute the\n     * center point.  Otherwise asymmetric quantization errors will occur.\n     * The formula to integrate is e^-(x^2/2s^2).\n     */\n\n    for (i = matrix_len / 2 + 1; i < matrix_len; i++)\n    {\n        gdouble base_x = i - (matrix_len / 2) - 0.5;\n\n        sum = 0;\n        for (j = 1; j <= 50; j++)\n        {\n            gdouble r = base_x + 0.02 * j;\n\n            if (r <= radius)\n                sum += exp (- SQR (r) / (2 * SQR (std_dev)));\n        }\n\n        matrix[i] = sum / 50;\n    }\n\n    /* mirror to the bottom half */\n    for (i = 0; i <= matrix_len / 2; i++)\n        matrix[i] = matrix[matrix_len - 1 - i];\n\n    /* find center val -- calculate an odd number of quanta to make it\n     * symmetric, even if the center point is weighted slightly higher\n     * than others.\n     */\n    sum = 0;\n    for (j = 0; j <= 50; j++)\n        sum += exp (- SQR (- 0.5 + 0.02 * j) / (2 * SQR (std_dev)));\n\n    matrix[matrix_len / 2] = sum / 51;\n\n    /* normalize the distribution by scaling the total sum to one */\n    sum = 0;\n    for (i = 0; i < matrix_len; i++)\n        sum += matrix[i];\n\n    for (i = 0; i < matrix_len; i++)\n        matrix[i] = matrix[i] / sum;\n\n    *out_matrix = matrix;\n    *out_matrix_len = matrix_len;\n}\n\nstatic void\ngaussian_blur_line (gdouble *matrix,\n                    gint matrix_len,\n                    guchar *src,\n                    guchar *dest,\n                    gint len,\n                    gint bpp)\n{\n    guchar *src_p;\n    guchar *src_p1;\n    gint matrix_middle;\n    gint row;\n    gint i, j;\n\n    matrix_middle = matrix_len / 2;\n\n    /* picture smaller than the matrix? */\n    if (matrix_len > len) {\n        for (row = 0; row < len; row++) {\n            /* find the scale factor */\n            gdouble scale = 0;\n\n            for (j = 0; j < len; j++) {\n                /* if the index is in bounds, add it to the scale counter */\n                if (j + matrix_middle - row >= 0 &&\n                    j + matrix_middle - row < matrix_len)\n                    scale += matrix[j];\n            }\n\n            src_p = src;\n\n            for (i = 0; i < bpp; i++) {\n                gdouble sum = 0;\n\n                src_p1 = src_p++;\n\n                for (j = 0; j < len; j++) {\n                    if (j + matrix_middle - row >= 0 &&\n                        j + matrix_middle - row < matrix_len)\n                        sum += *src_p1 * matrix[j];\n\n                    src_p1 += bpp;\n                }\n\n                *dest++ = (guchar) (sum / scale + 0.5);\n            }\n        }\n    } else {\n        /* left edge */\n\n        for (row = 0; row < matrix_middle; row++) {\n            /* find scale factor */\n            gdouble scale = 0;\n\n            for (j = matrix_middle - row; j < matrix_len; j++)\n                scale += matrix[j];\n\n            src_p = src;\n\n            for (i = 0; i < bpp; i++) {\n                gdouble sum = 0;\n\n                src_p1 = src_p++;\n\n                for (j = matrix_middle - row; j < matrix_len; j++) {\n                    sum += *src_p1 * matrix[j];\n                    src_p1 += bpp;\n                }\n\n                *dest++ = (guchar) (sum / scale + 0.5);\n            }\n        }\n\n        /* go through each pixel in each col */\n        for (; row < len - matrix_middle; row++) {\n            src_p = src + (row - matrix_middle) * bpp;\n\n            for (i = 0; i < bpp; i++) {\n                gdouble sum = 0;\n\n                src_p1 = src_p++;\n\n                for (j = 0; j < matrix_len; j++) {\n                    sum += matrix[j] * *src_p1;\n                    src_p1 += bpp;\n                }\n\n                *dest++ = (guchar) (sum + 0.5);\n            }\n        }\n\n        /* for the edge condition, we only use available info and scale to one */\n        for (; row < len; row++) {\n            /* find scale factor */\n            gdouble scale = 0;\n\n            for (j = 0; j < len - row + matrix_middle; j++)\n                scale += matrix[j];\n\n            src_p = src + (row - matrix_middle) * bpp;\n\n            for (i = 0; i < bpp; i++) {\n                gdouble sum = 0;\n\n                src_p1 = src_p++;\n\n                for (j = 0; j < len - row + matrix_middle; j++) {\n                    sum += *src_p1 * matrix[j];\n                    src_p1 += bpp;\n                }\n\n                *dest++ = (guchar) (sum / scale + 0.5);\n            }\n        }\n    }\n}\n\nstatic void\nget_column (guchar *column_data,\n            guchar *src_data,\n            gint src_stride,\n            gint bpp,\n            gint height,\n            gint x)\n{\n    gint y;\n    gint c;\n\n    for (y = 0; y < height; y++) {\n        guchar *src = src_data + y * src_stride + x * bpp;\n\n        for (c = 0; c < bpp; c++)\n            column_data[c] = src[c];\n\n        column_data += bpp;\n    }\n}\n\nstatic void\nput_column (guchar *column_data, guchar *dest_data, gint dest_stride, gint bpp, gint height, gint x)\n{\n    gint y;\n    gint c;\n\n    for (y = 0; y < height; y++) {\n        guchar *dst = dest_data + y * dest_stride + x * bpp;\n\n        for (c = 0; c < bpp; c++)\n            dst[c] = column_data[c];\n\n        column_data += bpp;\n    }\n}\n\nstatic void\ngaussian_blur_surface (cairo_surface_t *in,\n                       cairo_surface_t *out,\n                       gdouble sx,\n                       gdouble sy)\n{\n    gint width, height;\n    cairo_format_t in_format, out_format;\n    gint in_stride;\n    gint out_stride;\n    guchar *in_data, *out_data;\n    gint bpp;\n    gboolean out_has_data;\n\n    cairo_surface_flush (in);\n\n    width = cairo_image_surface_get_width (in);\n    height = cairo_image_surface_get_height (in);\n\n    g_assert (width == cairo_image_surface_get_width (out)\n              && height == cairo_image_surface_get_height (out));\n\n    in_format = cairo_image_surface_get_format (in);\n    out_format = cairo_image_surface_get_format (out);\n    g_assert (in_format == out_format);\n    g_assert (in_format == CAIRO_FORMAT_ARGB32\n              || in_format == CAIRO_FORMAT_A8);\n\n    if (in_format == CAIRO_FORMAT_ARGB32)\n        bpp = 4;\n    else if (in_format == CAIRO_FORMAT_A8)\n        bpp = 1;\n    else {\n        g_assert_not_reached ();\n        return;\n    }\n\n    in_stride = cairo_image_surface_get_stride (in);\n    out_stride = cairo_image_surface_get_stride (out);\n\n    in_data = cairo_image_surface_get_data (in);\n    out_data = cairo_image_surface_get_data (out);\n\n    if (sx < 0.0)\n        sx = 0.0;\n\n    if (sy < 0.0)\n        sy = 0.0;\n\n    /* Bail out by just copying? */\n    if ((sx == 0.0 && sy == 0.0)\n        || sx > 1000 || sy > 1000) {\n        cairo_t *cr;\n\n        cr = cairo_create (out);\n        cairo_set_source_surface (cr, in, 0, 0);\n        cairo_paint (cr);\n        cairo_destroy (cr);\n        return;\n    }\n\n    if (sx != 0.0) {\n        gint box_width;\n        gdouble *gaussian_matrix;\n        gint gaussian_matrix_len;\n        int y;\n        guchar *row_buffer = NULL;\n        guchar *row1, *row2;\n        gboolean use_box_blur;\n\n        /* For small radiuses, use a true gaussian kernel; otherwise use three box blurs with\n         * clever offsets.\n         */\n        if (sx < 10.0)\n            use_box_blur = FALSE;\n        else\n            use_box_blur = TRUE;\n\n        if (use_box_blur) {\n            box_width = compute_box_blur_width (sx);\n\n            /* twice the size so we can have \"two\" scratch rows */\n            row_buffer = g_new0 (guchar, width * bpp * 2);\n            row1 = row_buffer;\n            row2 = row_buffer + width * bpp;\n        } else\n            make_gaussian_convolution_matrix (sx, &gaussian_matrix, &gaussian_matrix_len);\n\n        for (y = 0; y < height; y++) {\n            guchar *in_row, *out_row;\n\n            in_row = in_data + in_stride * y;\n            out_row = out_data + out_stride * y;\n\n            if (use_box_blur) {\n                if (box_width % 2 != 0) {\n                    /* Odd-width box blur: repeat 3 times, centered on output pixel */\n\n                    box_blur_line (box_width, 0, in_row, row1,    width, bpp);\n                    box_blur_line (box_width, 0, row1,   row2,    width, bpp);\n                    box_blur_line (box_width, 0, row2,   out_row, width, bpp);\n                } else {\n                    /* Even-width box blur:\n                     * This method is suggested by the specification for SVG.\n                     * One pass with width n, centered between output and right pixel\n                     * One pass with width n, centered between output and left pixel\n                     * One pass with width n+1, centered on output pixel\n                     */\n                    box_blur_line (box_width,     -1, in_row, row1,    width, bpp);\n                    box_blur_line (box_width,      1, row1,   row2,    width, bpp);\n                    box_blur_line (box_width + 1,  0, row2,   out_row, width, bpp);\n                }\n            } else\n                gaussian_blur_line (gaussian_matrix, gaussian_matrix_len, in_row, out_row, width, bpp);\n        }\n\n        if (!use_box_blur)\n            g_free (gaussian_matrix);\n\n        g_free (row_buffer);\n\n        out_has_data = TRUE;\n    } else\n        out_has_data = FALSE;\n\n    if (sy != 0.0) {\n        gint box_height;\n        gdouble *gaussian_matrix = NULL;\n        gint gaussian_matrix_len;\n        guchar *col_buffer;\n        guchar *col1, *col2;\n        int x;\n        gboolean use_box_blur;\n\n        /* For small radiuses, use a true gaussian kernel; otherwise use three box blurs with\n         * clever offsets.\n         */\n        if (sy < 10.0)\n            use_box_blur = FALSE;\n        else\n            use_box_blur = TRUE;\n\n        /* twice the size so we can have the source pixels and the blurred pixels */\n        col_buffer = g_new0 (guchar, height * bpp * 2);\n        col1 = col_buffer;\n        col2 = col_buffer + height * bpp;\n\n        if (use_box_blur) {\n            box_height = compute_box_blur_width (sy);\n        } else\n            make_gaussian_convolution_matrix (sy, &gaussian_matrix, &gaussian_matrix_len);\n\n        for (x = 0; x < width; x++) {\n            if (out_has_data)\n                get_column (col1, out_data, out_stride, bpp, height, x);\n            else\n                get_column (col1, in_data, in_stride, bpp, height, x);\n\n            if (use_box_blur) {\n                if (box_height % 2 != 0) {\n                    /* Odd-width box blur */\n                    box_blur_line (box_height, 0, col1, col2, height, bpp);\n                    box_blur_line (box_height, 0, col2, col1, height, bpp);\n                    box_blur_line (box_height, 0, col1, col2, height, bpp);\n                } else {\n                    /* Even-width box blur */\n                    box_blur_line (box_height,     -1, col1, col2, height, bpp);\n                    box_blur_line (box_height,      1, col2, col1, height, bpp);\n                    box_blur_line (box_height + 1,  0, col1, col2, height, bpp);\n                }\n            } else\n                gaussian_blur_line (gaussian_matrix, gaussian_matrix_len, col1, col2, height, bpp);\n\n            put_column (col2, out_data, out_stride, bpp, height, x);\n        }\n\n        g_free (gaussian_matrix);\n        g_free (col_buffer);\n    }\n\n    cairo_surface_mark_dirty (out);\n}\n\nstatic void\nrsvg_filter_primitive_gaussian_blur_render (RsvgNode *node, RsvgFilterPrimitive *primitive, RsvgFilterContext *ctx)\n{\n    RsvgFilterPrimitiveGaussianBlur *gaussian = (RsvgFilterPrimitiveGaussianBlur *) primitive;\n\n    int width, height;\n    cairo_surface_t *output, *in;\n    RsvgIRect boundarys;\n    gdouble sdx, sdy;\n    RsvgFilterPrimitiveOutput op;\n    cairo_t *cr;\n\n    boundarys = rsvg_filter_primitive_get_bounds (primitive, ctx);\n\n    op = rsvg_filter_get_result (primitive->in, ctx);\n    in = op.surface;\n\n    width = cairo_image_surface_get_width (in);\n    height = cairo_image_surface_get_height (in);\n\n    output = _rsvg_image_surface_new (width, height);\n\n    if (output == NULL) {\n        cairo_surface_destroy (in);\n        return;\n    }\n\n    /* scale the SD values */\n    sdx = fabs (gaussian->sdx * ctx->paffine.xx);\n    sdy = fabs (gaussian->sdy * ctx->paffine.yy);\n\n    gaussian_blur_surface (in, output, sdx, sdy);\n\n    /* Hard-clip to the filter area */\n    if (!(boundarys.x0 == 0\n          && boundarys.y0 == 0\n          && boundarys.x1 == width\n          && boundarys.y1 == height)) {\n        cr = cairo_create (output);\n        cairo_set_operator (cr, CAIRO_OPERATOR_CLEAR);\n        cairo_set_fill_rule (cr, CAIRO_FILL_RULE_EVEN_ODD);\n        cairo_rectangle (cr, 0, 0, width, height);\n        cairo_rectangle (cr,\n                         boundarys.x0, boundarys.y0,\n                         boundarys.x1 - boundarys.x0, boundarys.y1 - boundarys.y0);\n        cairo_fill (cr);\n        cairo_destroy (cr);\n    }\n\n    op.surface = output;\n    op.bounds = boundarys;\n    rsvg_filter_store_output (primitive->result, op, ctx);\n\n    cairo_surface_destroy (in);\n    cairo_surface_destroy (output);\n}\n\nstatic void\nrsvg_filter_primitive_gaussian_blur_set_atts (RsvgNode *node, gpointer impl, RsvgHandle *handle, RsvgPropertyBag *atts)\n{\n    RsvgFilterPrimitiveGaussianBlur *filter = impl;\n    const char *value;\n\n    if ((value = rsvg_property_bag_lookup (atts, \"in\")))\n        g_string_assign (filter->super.in, value);\n    if ((value = rsvg_property_bag_lookup (atts, \"result\")))\n        g_string_assign (filter->super.result, value);\n\n    filter_primitive_set_x_y_width_height_atts ((RsvgFilterPrimitive *) filter, atts);\n\n    if ((value = rsvg_property_bag_lookup (atts, \"stdDeviation\"))) {\n        if (!rsvg_css_parse_number_optional_number (value, &filter->sdx, &filter->sdy)) {\n            rsvg_node_set_attribute_parse_error (node, \"stdDeviation\", \"expected number-optional-number\");\n            return;\n        }\n    }\n}\n\nRsvgNode *\nrsvg_new_filter_primitive_gaussian_blur (const char *element_name, RsvgNode *parent)\n{\n    RsvgFilterPrimitiveGaussianBlur *filter;\n\n    filter = g_new0 (RsvgFilterPrimitiveGaussianBlur, 1);\n    filter->super.in = g_string_new (\"none\");\n    filter->super.result = g_string_new (\"none\");\n    filter->sdx = 0;\n    filter->sdy = 0;\n    filter->super.render = rsvg_filter_primitive_gaussian_blur_render;\n\n    return rsvg_rust_cnode_new (RSVG_NODE_TYPE_FILTER_PRIMITIVE_GAUSSIAN_BLUR,\n                                parent,\n                                rsvg_state_new (),\n                                filter,\n                                rsvg_filter_primitive_gaussian_blur_set_atts,\n                                rsvg_filter_draw,\n                                rsvg_filter_primitive_free);\n}\n\n/*************************************************************/\n/*************************************************************/\n\ntypedef struct _RsvgFilterPrimitiveOffset RsvgFilterPrimitiveOffset;\n\nstruct _RsvgFilterPrimitiveOffset {\n    RsvgFilterPrimitive super;\n    RsvgLength dx, dy;\n};\n\nstatic void\nrsvg_filter_primitive_offset_render (RsvgNode *node, RsvgFilterPrimitive *primitive, RsvgFilterContext *ctx)\n{\n    RsvgFilterPrimitiveOffset *offset = (RsvgFilterPrimitiveOffset *) primitive;\n\n    guchar ch;\n    gint x, y;\n    gint rowstride, height, width;\n    RsvgIRect boundarys;\n\n    guchar *in_pixels;\n    guchar *output_pixels;\n\n    RsvgFilterPrimitiveOutput out;\n\n    cairo_surface_t *output, *in;\n\n    double dx, dy;\n    int ox, oy;\n\n    boundarys = rsvg_filter_primitive_get_bounds (primitive, ctx);\n\n    in = rsvg_filter_get_in (primitive->in, ctx);\n    if (in == NULL)\n        return;\n\n    cairo_surface_flush (in);\n\n    in_pixels = cairo_image_surface_get_data (in);\n\n    height = cairo_image_surface_get_height (in);\n    width = cairo_image_surface_get_width (in);\n\n    rowstride = cairo_image_surface_get_stride (in);\n\n    output = _rsvg_image_surface_new (width, height);\n    if (output == NULL) {\n        cairo_surface_destroy (in);\n        return;\n    }\n\n    output_pixels = cairo_image_surface_get_data (output);\n\n    dx = rsvg_length_normalize (&offset->dx, ctx->ctx);\n    dy = rsvg_length_normalize (&offset->dy, ctx->ctx);\n\n    ox = ctx->paffine.xx * dx + ctx->paffine.xy * dy;\n    oy = ctx->paffine.yx * dx + ctx->paffine.yy * dy;\n\n    for (y = boundarys.y0; y < boundarys.y1; y++)\n        for (x = boundarys.x0; x < boundarys.x1; x++) {\n            if (x - ox < boundarys.x0 || x - ox >= boundarys.x1)\n                continue;\n            if (y - oy < boundarys.y0 || y - oy >= boundarys.y1)\n                continue;\n\n            for (ch = 0; ch < 4; ch++) {\n                output_pixels[y * rowstride + x * 4 + ch] =\n                    in_pixels[(y - oy) * rowstride + (x - ox) * 4 + ch];\n            }\n        }\n\n    cairo_surface_mark_dirty (output);\n\n    out.surface = output;\n    out.bounds = boundarys;\n\n    rsvg_filter_store_output (primitive->result, out, ctx);\n\n    cairo_surface_destroy  (in);\n    cairo_surface_destroy (output);\n}\n\nstatic void\nrsvg_filter_primitive_offset_set_atts (RsvgNode *node, gpointer impl, RsvgHandle *handle, RsvgPropertyBag * atts)\n{\n    RsvgFilterPrimitiveOffset *filter = impl;\n    const char *value;\n\n    if ((value = rsvg_property_bag_lookup (atts, \"in\")))\n        g_string_assign (filter->super.in, value);\n    if ((value = rsvg_property_bag_lookup (atts, \"result\")))\n        g_string_assign (filter->super.result, value);\n\n    filter_primitive_set_x_y_width_height_atts ((RsvgFilterPrimitive *) filter, atts);\n\n    if ((value = rsvg_property_bag_lookup (atts, \"dx\")))\n        filter->dx = rsvg_length_parse (value, LENGTH_DIR_HORIZONTAL);\n    if ((value = rsvg_property_bag_lookup (atts, \"dy\")))\n        filter->dy = rsvg_length_parse (value, LENGTH_DIR_VERTICAL);\n}\n\nRsvgNode *\nrsvg_new_filter_primitive_offset (const char *element_name, RsvgNode *parent)\n{\n    RsvgFilterPrimitiveOffset *filter;\n\n    filter = g_new0 (RsvgFilterPrimitiveOffset, 1);\n    filter->super.in = g_string_new (\"none\");\n    filter->super.result = g_string_new (\"none\");\n    filter->dx = rsvg_length_parse (\"0\", LENGTH_DIR_HORIZONTAL);\n    filter->dy = rsvg_length_parse (\"0\", LENGTH_DIR_VERTICAL);\n    filter->super.render = rsvg_filter_primitive_offset_render;\n\n    return rsvg_rust_cnode_new (RSVG_NODE_TYPE_FILTER_PRIMITIVE_OFFSET,\n                                parent,\n                                rsvg_state_new (),\n                                filter,\n                                rsvg_filter_primitive_offset_set_atts,\n                                rsvg_filter_draw,\n                                rsvg_filter_primitive_free);\n}\n\n/*************************************************************/\n/*************************************************************/\n\ntypedef struct _RsvgFilterPrimitiveMerge RsvgFilterPrimitiveMerge;\n\nstruct _RsvgFilterPrimitiveMerge {\n    RsvgFilterPrimitive super;\n};\n\nstruct merge_render_closure {\n    cairo_surface_t *output;\n    RsvgIRect boundarys;\n    RsvgFilterContext *ctx;\n};\n\nstatic gboolean\nmerge_render_child (RsvgNode *node, gpointer data)\n{\n    struct merge_render_closure *closure = data;\n    RsvgFilterPrimitive *fp;\n    cairo_surface_t *in;\n\n    if (rsvg_node_get_type (node) != RSVG_NODE_TYPE_FILTER_PRIMITIVE_MERGE_NODE)\n        return TRUE;\n\n    fp = rsvg_rust_cnode_get_impl (node);\n\n    in = rsvg_filter_get_in (fp->in, closure->ctx);\n    if (in == NULL)\n        return TRUE;\n\n    rsvg_alpha_blt (in,\n                    closure->boundarys.x0,\n                    closure->boundarys.y0,\n                    closure->boundarys.x1 - closure->boundarys.x0,\n                    closure->boundarys.y1 - closure->boundarys.y0,\n                    closure->output,\n                    closure->boundarys.x0,\n                    closure->boundarys.y0);\n\n    cairo_surface_destroy (in);\n\n    return TRUE;\n}\n\nstatic void\nrsvg_filter_primitive_merge_render (RsvgNode *node, RsvgFilterPrimitive *primitive, RsvgFilterContext *ctx)\n{\n    struct merge_render_closure closure;\n\n    closure.boundarys = rsvg_filter_primitive_get_bounds (primitive, ctx);\n\n    closure.output = _rsvg_image_surface_new (ctx->width, ctx->height);\n    if (closure.output == NULL) {\n        return;\n    }\n\n    closure.ctx = ctx;\n\n    rsvg_node_foreach_child (node, merge_render_child, &closure);\n\n    rsvg_filter_store_result (primitive->result, closure.output, ctx);\n\n    cairo_surface_destroy (closure.output);\n}\n\nstatic void\nrsvg_filter_primitive_merge_set_atts (RsvgNode *node, gpointer impl, RsvgHandle *handle, RsvgPropertyBag *atts)\n{\n    RsvgFilterPrimitiveMerge *filter = impl;\n    const char *value;\n\n    if ((value = rsvg_property_bag_lookup (atts, \"result\")))\n        g_string_assign (filter->super.result, value);\n\n    filter_primitive_set_x_y_width_height_atts ((RsvgFilterPrimitive *) filter, atts);\n}\n\nRsvgNode *\nrsvg_new_filter_primitive_merge (const char *element_name, RsvgNode *parent)\n{\n    RsvgFilterPrimitiveMerge *filter;\n\n    filter = g_new0 (RsvgFilterPrimitiveMerge, 1);\n    filter->super.result = g_string_new (\"none\");\n    filter->super.render = rsvg_filter_primitive_merge_render;\n\n    return rsvg_rust_cnode_new (RSVG_NODE_TYPE_FILTER_PRIMITIVE_MERGE,\n                                parent,\n                                rsvg_state_new (),\n                                filter,\n                                rsvg_filter_primitive_merge_set_atts,\n                                rsvg_filter_draw,\n                                rsvg_filter_primitive_free);\n}\n\nstatic void\nrsvg_filter_primitive_merge_node_set_atts (RsvgNode *node, gpointer impl, RsvgHandle *handle, RsvgPropertyBag *atts)\n{\n    RsvgFilterPrimitive *primitive = impl;\n    const char *value;\n\n    /* see bug 145149 - sodipodi generates bad SVG... */\n    if ((value = rsvg_property_bag_lookup (atts, \"in\")))\n        g_string_assign (primitive->in, value);\n}\n\nstatic void\nrsvg_filter_primitive_merge_node_render (RsvgNode *node, RsvgFilterPrimitive *primitive, RsvgFilterContext *ctx)\n{\n    /* todo */\n}\n\nRsvgNode *\nrsvg_new_filter_primitive_merge_node (const char *element_name, RsvgNode *parent)\n{\n    RsvgFilterPrimitive *filter;\n\n    filter = g_new0 (RsvgFilterPrimitive, 1);\n    filter->in = g_string_new (\"none\");\n    filter->render = rsvg_filter_primitive_merge_node_render;\n\n    return rsvg_rust_cnode_new (RSVG_NODE_TYPE_FILTER_PRIMITIVE_MERGE_NODE,\n                                parent,\n                                rsvg_state_new (),\n                                filter,\n                                rsvg_filter_primitive_merge_node_set_atts,\n                                rsvg_filter_draw,\n                                rsvg_filter_primitive_free);\n}\n\n/*************************************************************/\n/*************************************************************/\n\ntypedef struct _RsvgFilterPrimitiveColorMatrix RsvgFilterPrimitiveColorMatrix;\n\nstruct _RsvgFilterPrimitiveColorMatrix {\n    RsvgFilterPrimitive super;\n    gint *KernelMatrix;\n};\n\nstatic void\nrsvg_filter_primitive_color_matrix_render (RsvgNode *node, RsvgFilterPrimitive *primitive, RsvgFilterContext *ctx)\n{\n    RsvgFilterPrimitiveColorMatrix *color_matrix = (RsvgFilterPrimitiveColorMatrix *) primitive;\n\n    guchar ch;\n    gint x, y;\n    gint i;\n    gint rowstride, height, width;\n    RsvgIRect boundarys;\n\n    guchar *in_pixels;\n    guchar *output_pixels;\n\n    cairo_surface_t *output, *in;\n\n    int sum;\n\n    boundarys = rsvg_filter_primitive_get_bounds (primitive, ctx);\n\n    in = rsvg_filter_get_in (primitive->in, ctx);\n    if (in == NULL)\n        return;\n\n    cairo_surface_flush (in);\n\n    in_pixels = cairo_image_surface_get_data (in);\n\n    height = cairo_image_surface_get_height (in);\n    width = cairo_image_surface_get_width (in);\n\n    rowstride = cairo_image_surface_get_stride (in);\n\n    output = _rsvg_image_surface_new (width, height);\n    if (output == NULL) {\n        cairo_surface_destroy (in);\n        return;\n    }\n\n    output_pixels = cairo_image_surface_get_data (output);\n\n    for (y = boundarys.y0; y < boundarys.y1; y++)\n        for (x = boundarys.x0; x < boundarys.x1; x++) {\n            int umch;\n            int alpha = in_pixels[4 * x + y * rowstride + ctx->channelmap[3]];\n            if (!alpha)\n                for (umch = 0; umch < 4; umch++) {\n                    sum = color_matrix->KernelMatrix[umch * 5 + 4];\n                    if (sum > 255)\n                        sum = 255;\n                    if (sum < 0)\n                        sum = 0;\n                    output_pixels[4 * x + y * rowstride + ctx->channelmap[umch]] = sum;\n            } else\n                for (umch = 0; umch < 4; umch++) {\n                    int umi;\n                    ch = ctx->channelmap[umch];\n                    sum = 0;\n                    for (umi = 0; umi < 4; umi++) {\n                        i = ctx->channelmap[umi];\n                        if (umi != 3)\n                            sum += color_matrix->KernelMatrix[umch * 5 + umi] *\n                                in_pixels[4 * x + y * rowstride + i] / alpha;\n                        else\n                            sum += color_matrix->KernelMatrix[umch * 5 + umi] *\n                                in_pixels[4 * x + y * rowstride + i] / 255;\n                    }\n                    sum += color_matrix->KernelMatrix[umch * 5 + 4];\n\n\n\n                    if (sum > 255)\n                        sum = 255;\n                    if (sum < 0)\n                        sum = 0;\n\n                    output_pixels[4 * x + y * rowstride + ch] = sum;\n                }\n            for (umch = 0; umch < 3; umch++) {\n                ch = ctx->channelmap[umch];\n                output_pixels[4 * x + y * rowstride + ch] =\n                    output_pixels[4 * x + y * rowstride + ch] *\n                    output_pixels[4 * x + y * rowstride + ctx->channelmap[3]] / 255;\n            }\n        }\n\n    cairo_surface_mark_dirty (output);\n\n    rsvg_filter_store_result (primitive->result, output, ctx);\n\n    cairo_surface_destroy (in);\n    cairo_surface_destroy (output);\n}\n\nstatic void\nrsvg_filter_primitive_color_matrix_free (gpointer impl)\n{\n    RsvgFilterPrimitiveColorMatrix *matrix = impl;\n\n    g_free (matrix->KernelMatrix);\n\n    rsvg_filter_primitive_free (impl);\n}\n\nstatic void\nrsvg_filter_primitive_color_matrix_set_atts (RsvgNode *node, gpointer impl, RsvgHandle *handle, RsvgPropertyBag *atts)\n{\n    RsvgFilterPrimitiveColorMatrix *filter = impl;\n    gint type;\n    gsize listlen = 0;\n    const char *value;\n\n    type = 0;\n\n    if ((value = rsvg_property_bag_lookup (atts, \"in\")))\n        g_string_assign (filter->super.in, value);\n    if ((value = rsvg_property_bag_lookup (atts, \"result\")))\n        g_string_assign (filter->super.result, value);\n\n    filter_primitive_set_x_y_width_height_atts ((RsvgFilterPrimitive *) filter, atts);\n\n    if ((value = rsvg_property_bag_lookup (atts, \"values\"))) {\n        unsigned int i;\n        double *temp;\n        if (!rsvg_css_parse_number_list (value,\n                                         NUMBER_LIST_LENGTH_MAXIMUM,\n                                         20,\n                                         &temp,\n                                         &listlen)) {\n            rsvg_node_set_attribute_parse_error (node, \"values\", \"invalid number list\");\n            return;\n        }\n\n        filter->KernelMatrix = g_new0 (int, listlen);\n        for (i = 0; i < listlen; i++)\n            filter->KernelMatrix[i] = temp[i] * 255.;\n        g_free (temp);\n    }\n    if ((value = rsvg_property_bag_lookup (atts, \"type\"))) {\n        if (!strcmp (value, \"matrix\"))\n            type = 0;\n        else if (!strcmp (value, \"saturate\"))\n            type = 1;\n        else if (!strcmp (value, \"hueRotate\"))\n            type = 2;\n        else if (!strcmp (value, \"luminanceToAlpha\"))\n            type = 3;\n        else\n            type = 0;\n    }\n\n    if (type == 0) {\n        if (listlen != 20) {\n            if (filter->KernelMatrix != NULL)\n                g_free (filter->KernelMatrix);\n            filter->KernelMatrix = g_new0 (int, 20);\n        }\n    } else if (type == 1) {\n        float s;\n        if (listlen != 0) {\n            s = filter->KernelMatrix[0];\n            g_free (filter->KernelMatrix);\n        } else\n            s = 255;\n        filter->KernelMatrix = g_new0 (int, 20);\n\n        filter->KernelMatrix[0] = 0.213 * 255. + 0.787 * s;\n        filter->KernelMatrix[1] = 0.715 * 255. - 0.715 * s;\n        filter->KernelMatrix[2] = 0.072 * 255. - 0.072 * s;\n        filter->KernelMatrix[5] = 0.213 * 255. - 0.213 * s;\n        filter->KernelMatrix[6] = 0.715 * 255. + 0.285 * s;\n        filter->KernelMatrix[7] = 0.072 * 255. - 0.072 * s;\n        filter->KernelMatrix[10] = 0.213 * 255. - 0.213 * s;\n        filter->KernelMatrix[11] = 0.715 * 255. - 0.715 * s;\n        filter->KernelMatrix[12] = 0.072 * 255. + 0.928 * s;\n        filter->KernelMatrix[18] = 255;\n    } else if (type == 2) {\n        double cosval, sinval, arg;\n\n        if (listlen != 0) {\n            arg = (double) filter->KernelMatrix[0] / 255.;\n            g_free (filter->KernelMatrix);\n        } else\n            arg = 0;\n\n        cosval = cos (arg);\n        sinval = sin (arg);\n\n        filter->KernelMatrix = g_new0 (int, 20);\n\n        filter->KernelMatrix[0] = (0.213 + cosval * 0.787 + sinval * -0.213) * 255.;\n        filter->KernelMatrix[1] = (0.715 + cosval * -0.715 + sinval * -0.715) * 255.;\n        filter->KernelMatrix[2] = (0.072 + cosval * -0.072 + sinval * 0.928) * 255.;\n        filter->KernelMatrix[5] = (0.213 + cosval * -0.213 + sinval * 0.143) * 255.;\n        filter->KernelMatrix[6] = (0.715 + cosval * 0.285 + sinval * 0.140) * 255.;\n        filter->KernelMatrix[7] = (0.072 + cosval * -0.072 + sinval * -0.283) * 255.;\n        filter->KernelMatrix[10] = (0.213 + cosval * -0.213 + sinval * -0.787) * 255.;\n        filter->KernelMatrix[11] = (0.715 + cosval * -0.715 + sinval * 0.715) * 255.;\n        filter->KernelMatrix[12] = (0.072 + cosval * 0.928 + sinval * 0.072) * 255.;\n        filter->KernelMatrix[18] = 255;\n    } else if (type == 3) {\n        if (filter->KernelMatrix != NULL)\n            g_free (filter->KernelMatrix);\n\n        filter->KernelMatrix = g_new0 (int, 20);\n\n        filter->KernelMatrix[15] = 0.2125 * 255.;\n        filter->KernelMatrix[16] = 0.7154 * 255.;\n        filter->KernelMatrix[17] = 0.0721 * 255.;\n    } else {\n        g_assert_not_reached ();\n    }\n}\n\nRsvgNode *\nrsvg_new_filter_primitive_color_matrix (const char *element_name, RsvgNode *parent)\n{\n    RsvgFilterPrimitiveColorMatrix *filter;\n\n    filter = g_new0 (RsvgFilterPrimitiveColorMatrix, 1);\n    filter->super.in = g_string_new (\"none\");\n    filter->super.result = g_string_new (\"none\");\n    filter->KernelMatrix = NULL;\n    filter->super.render = rsvg_filter_primitive_color_matrix_render;\n\n    return rsvg_rust_cnode_new (RSVG_NODE_TYPE_FILTER_PRIMITIVE_COLOR_MATRIX,\n                                parent,\n                                rsvg_state_new (),\n                                filter,\n                                rsvg_filter_primitive_color_matrix_set_atts,\n                                rsvg_filter_draw,\n                                rsvg_filter_primitive_color_matrix_free);                                \n}\n\n\n/*************************************************************/\n/*************************************************************/\n\ntypedef struct _RsvgNodeComponentTransferFunc RsvgNodeComponentTransferFunc;\n\ntypedef gint (*ComponentTransferFunc) (gint C, RsvgNodeComponentTransferFunc * user_data);\n\ntypedef struct _RsvgFilterPrimitiveComponentTransfer\n RsvgFilterPrimitiveComponentTransfer;\n\nstruct _RsvgNodeComponentTransferFunc {\n    ComponentTransferFunc function;\n    gint *tableValues;\n    gsize nbTableValues;\n    gint slope;\n    gint intercept;\n    gint amplitude;\n    gint offset;\n    gdouble exponent;\n    char channel;\n};\n\nstruct _RsvgFilterPrimitiveComponentTransfer {\n    RsvgFilterPrimitive super;\n};\n\nstatic gint\nidentity_component_transfer_func (gint C, RsvgNodeComponentTransferFunc * user_data)\n{\n    return C;\n}\n\nstatic gint\ntable_component_transfer_func (gint C, RsvgNodeComponentTransferFunc * user_data)\n{\n    guint k;\n    gint vk, vk1, distancefromlast;\n    guint num_values;\n\n    if (!user_data->nbTableValues)\n        return C;\n\n    num_values = user_data->nbTableValues;\n\n    k = (C * (num_values - 1)) / 255;\n\n    vk = user_data->tableValues[MIN (k, num_values - 1)];\n    vk1 = user_data->tableValues[MIN (k + 1, num_values - 1)];\n\n    distancefromlast = (C * (user_data->nbTableValues - 1)) - k * 255;\n\n    return vk + distancefromlast * (vk1 - vk) / 255;\n}\n\nstatic gint\ndiscrete_component_transfer_func (gint C, RsvgNodeComponentTransferFunc * user_data)\n{\n    gint k;\n\n    if (!user_data->nbTableValues)\n        return C;\n\n    k = (C * user_data->nbTableValues) / 255;\n\n    return user_data->tableValues[CLAMP (k, 0, user_data->nbTableValues - 1)];\n}\n\nstatic gint\nlinear_component_transfer_func (gint C, RsvgNodeComponentTransferFunc * user_data)\n{\n    return (user_data->slope * C) / 255 + user_data->intercept;\n}\n\nstatic gint\nfixpow (gint base, gint exp)\n{\n    int out = 255;\n    for (; exp > 0; exp--)\n        out = out * base / 255;\n    return out;\n}\n\nstatic gint\ngamma_component_transfer_func (gint C, RsvgNodeComponentTransferFunc * user_data)\n{\n    if (floor (user_data->exponent) == user_data->exponent)\n        return user_data->amplitude * fixpow (C, user_data->exponent) / 255 + user_data->offset;\n    else\n        return (double) user_data->amplitude * pow ((double) C / 255.,\n                                                    user_data->exponent) + user_data->offset;\n}\n\nstruct component_transfer_closure {\n    int channel_num;\n    char channel;\n    gboolean set_func;\n    RsvgNodeComponentTransferFunc *channels[4];\n    ComponentTransferFunc functions[4];\n    RsvgFilterContext *ctx;\n};\n\nstatic gboolean\ncomponent_transfer_render_child (RsvgNode *node, gpointer data)\n{\n    struct component_transfer_closure *closure = data;\n    RsvgNodeComponentTransferFunc *f;\n\n    if (rsvg_node_get_type (node) != RSVG_NODE_TYPE_COMPONENT_TRANFER_FUNCTION)\n        return TRUE;\n\n    f = rsvg_rust_cnode_get_impl (node);\n\n    if (f->channel == closure->channel) {\n        closure->functions[closure->ctx->channelmap[closure->channel_num]] = f->function;\n        closure->channels[closure->ctx->channelmap[closure->channel_num]] = f;\n        closure->set_func = TRUE;\n    }\n\n    return TRUE;\n}\n\nstatic void\nrsvg_filter_primitive_component_transfer_render (RsvgNode *node, RsvgFilterPrimitive *primitive, RsvgFilterContext *ctx)\n{\n    gint x, y, c;\n    gint rowstride, height, width;\n    RsvgIRect boundarys;\n    guchar *inpix, outpix[4];\n    gint achan = ctx->channelmap[3];\n    guchar *in_pixels;\n    guchar *output_pixels;\n    cairo_surface_t *output, *in;\n    struct component_transfer_closure closure;\n\n    boundarys = rsvg_filter_primitive_get_bounds (primitive, ctx);\n\n    closure.ctx = ctx;\n\n    for (c = 0; c < 4; c++) {\n        closure.channel_num = c;\n        closure.channel = \"rgba\"[c]; /* see rsvg_new_node_component_transfer_function() for where these chars come from */\n        closure.set_func = FALSE;\n\n        rsvg_node_foreach_child (node, component_transfer_render_child, &closure);\n\n        if (!closure.set_func)\n            closure.functions[ctx->channelmap[c]] = identity_component_transfer_func;\n    }\n\n    in = rsvg_filter_get_in (primitive->in, ctx);\n    if (in == NULL)\n        return;\n\n    cairo_surface_flush (in);\n\n    in_pixels = cairo_image_surface_get_data (in);\n\n    height = cairo_image_surface_get_height (in);\n    width = cairo_image_surface_get_width (in);\n\n    rowstride = cairo_image_surface_get_stride (in);\n\n    output = _rsvg_image_surface_new (width, height);\n    if (output == NULL) {\n        cairo_surface_destroy (in);\n        return;\n    }\n\n    output_pixels = cairo_image_surface_get_data (output);\n\n    for (y = boundarys.y0; y < boundarys.y1; y++)\n        for (x = boundarys.x0; x < boundarys.x1; x++) {\n            inpix = in_pixels + (y * rowstride + x * 4);\n            for (c = 0; c < 4; c++) {\n                gint temp;\n                int inval;\n                if (c != achan) {\n                    if (inpix[achan] == 0)\n                        inval = 0;\n                    else\n                        inval = inpix[c] * 255 / inpix[achan];\n                } else\n                    inval = inpix[c];\n\n                temp = closure.functions[c] (inval, closure.channels[c]);\n                if (temp > 255)\n                    temp = 255;\n                else if (temp < 0)\n                    temp = 0;\n                outpix[c] = temp;\n            }\n            for (c = 0; c < 3; c++)\n                output_pixels[y * rowstride + x * 4 + ctx->channelmap[c]] =\n                    outpix[ctx->channelmap[c]] * outpix[achan] / 255;\n            output_pixels[y * rowstride + x * 4 + achan] = outpix[achan];\n        }\n\n    cairo_surface_mark_dirty (output);\n\n    rsvg_filter_store_result (primitive->result, output, ctx);\n\n    cairo_surface_destroy (in);\n    cairo_surface_destroy (output);\n}\n\nstatic void\nrsvg_filter_primitive_component_transfer_set_atts (RsvgNode *node, gpointer impl, RsvgHandle *handle, RsvgPropertyBag *atts)\n{\n    RsvgFilterPrimitiveComponentTransfer *filter = impl;\n    const char *value;\n\n    if ((value = rsvg_property_bag_lookup (atts, \"result\")))\n        g_string_assign (filter->super.result, value);\n    if ((value = rsvg_property_bag_lookup (atts, \"in\")))\n        g_string_assign (filter->super.in, value);\n\n    filter_primitive_set_x_y_width_height_atts ((RsvgFilterPrimitive *) filter, atts);\n}\n\nRsvgNode *\nrsvg_new_filter_primitive_component_transfer (const char *element_name, RsvgNode *parent)\n{\n    RsvgFilterPrimitiveComponentTransfer *filter;\n\n    filter = g_new0 (RsvgFilterPrimitiveComponentTransfer, 1);\n    filter->super.result = g_string_new (\"none\");\n    filter->super.in = g_string_new (\"none\");\n    filter->super.render = rsvg_filter_primitive_component_transfer_render;\n\n    return rsvg_rust_cnode_new (RSVG_NODE_TYPE_FILTER_PRIMITIVE_COMPONENT_TRANSFER,\n                                parent,\n                                rsvg_state_new (),\n                                filter,\n                                rsvg_filter_primitive_component_transfer_set_atts,\n                                rsvg_filter_draw,\n                                rsvg_filter_primitive_free);                                \n}\n\nstatic void\nrsvg_node_component_transfer_function_set_atts (RsvgNode *node, gpointer impl, RsvgHandle *handle, RsvgPropertyBag *atts)\n{\n    RsvgNodeComponentTransferFunc *data = impl;\n    const char *value;\n\n    if ((value = rsvg_property_bag_lookup (atts, \"type\"))) {\n        if (!strcmp (value, \"identity\"))\n            data->function = identity_component_transfer_func;\n        else if (!strcmp (value, \"table\"))\n            data->function = table_component_transfer_func;\n        else if (!strcmp (value, \"discrete\"))\n            data->function = discrete_component_transfer_func;\n        else if (!strcmp (value, \"linear\"))\n            data->function = linear_component_transfer_func;\n        else if (!strcmp (value, \"gamma\"))\n            data->function = gamma_component_transfer_func;\n    }\n\n    if ((value = rsvg_property_bag_lookup (atts, \"tableValues\"))) {\n        unsigned int i;\n        double *temp;\n        if (!rsvg_css_parse_number_list (value,\n                                         NUMBER_LIST_LENGTH_MAXIMUM,\n                                         256,\n                                         &temp,\n                                         &data->nbTableValues)) {\n            rsvg_node_set_attribute_parse_error (node, \"tableValues\", \"invalid number list\");\n            return;\n        }\n\n        data->tableValues = g_new0 (gint, data->nbTableValues);\n        for (i = 0; i < data->nbTableValues; i++)\n            data->tableValues[i] = temp[i] * 255.;\n        g_free (temp);\n    }\n    if ((value = rsvg_property_bag_lookup (atts, \"slope\"))) {\n        data->slope = g_ascii_strtod (value, NULL) * 255.;\n    }\n    if ((value = rsvg_property_bag_lookup (atts, \"intercept\"))) {\n        data->intercept = g_ascii_strtod (value, NULL) * 255.;\n    }\n    if ((value = rsvg_property_bag_lookup (atts, \"amplitude\"))) {\n        data->amplitude = g_ascii_strtod (value, NULL) * 255.;\n    }\n    if ((value = rsvg_property_bag_lookup (atts, \"exponent\"))) {\n        data->exponent = g_ascii_strtod (value, NULL);\n    }\n    if ((value = rsvg_property_bag_lookup (atts, \"offset\"))) {\n        data->offset = g_ascii_strtod (value, NULL) * 255.;\n    }\n}\n\nstatic void\nrsvg_node_component_transfer_function_free (gpointer impl)\n{\n    RsvgNodeComponentTransferFunc *filter = impl;\n\n    if (filter->nbTableValues)\n        g_free (filter->tableValues);\n\n    g_free (filter);\n}\n\nRsvgNode *\nrsvg_new_node_component_transfer_function (const char *element_name, RsvgNode *parent)\n{\n    RsvgNodeComponentTransferFunc *filter;\n\n    char channel;\n\n    if (strcmp (element_name, \"feFuncR\") == 0)\n        channel = 'r';\n    else if (strcmp (element_name, \"feFuncG\") == 0)\n        channel = 'g';\n    else if (strcmp (element_name, \"feFuncB\") == 0)\n        channel = 'b';\n    else if (strcmp (element_name, \"feFuncA\") == 0)\n        channel = 'a';\n    else {\n        g_assert_not_reached ();\n        channel = '\\0';\n    }\n\n    filter = g_new0 (RsvgNodeComponentTransferFunc, 1);\n    filter->function = identity_component_transfer_func;\n    filter->nbTableValues = 0;\n    filter->channel = channel;\n\n    return rsvg_rust_cnode_new (RSVG_NODE_TYPE_COMPONENT_TRANFER_FUNCTION,\n                                parent,\n                                rsvg_state_new (),\n                                filter,\n                                rsvg_node_component_transfer_function_set_atts,\n                                rsvg_filter_draw,\n                                rsvg_node_component_transfer_function_free);\n}\n\n/*************************************************************/\n/*************************************************************/\n\ntypedef struct _RsvgFilterPrimitiveErode\n RsvgFilterPrimitiveErode;\n\nstruct _RsvgFilterPrimitiveErode {\n    RsvgFilterPrimitive super;\n    double rx, ry;\n    int mode;\n};\n\nstatic void\nrsvg_filter_primitive_erode_render (RsvgNode *node, RsvgFilterPrimitive *primitive, RsvgFilterContext *ctx)\n{\n    RsvgFilterPrimitiveErode *erode = (RsvgFilterPrimitiveErode *) primitive;\n\n    guchar ch, extreme;\n    gint x, y;\n    gint i, j;\n    gint rowstride, height, width;\n    RsvgIRect boundarys;\n\n    guchar *in_pixels;\n    guchar *output_pixels;\n\n    cairo_surface_t *output, *in;\n\n    gint kx, ky;\n    guchar val;\n\n    boundarys = rsvg_filter_primitive_get_bounds (primitive, ctx);\n\n    in = rsvg_filter_get_in (primitive->in, ctx);\n    if (in == NULL)\n        return;\n\n    cairo_surface_flush (in);\n\n    in_pixels = cairo_image_surface_get_data (in);\n\n    height = cairo_image_surface_get_height (in);\n    width = cairo_image_surface_get_width (in);\n\n    rowstride = cairo_image_surface_get_stride (in);\n\n    /* scale the radius values */\n    kx = erode->rx * ctx->paffine.xx;\n    ky = erode->ry * ctx->paffine.yy;\n\n    output = _rsvg_image_surface_new (width, height);\n    if (output == NULL) {\n        cairo_surface_destroy (in);\n        return;\n    }\n\n    output_pixels = cairo_image_surface_get_data (output);\n\n    for (y = boundarys.y0; y < boundarys.y1; y++)\n        for (x = boundarys.x0; x < boundarys.x1; x++)\n            for (ch = 0; ch < 4; ch++) {\n                if (erode->mode == 0)\n                    extreme = 255;\n                else\n                    extreme = 0;\n                for (i = -ky; i < ky + 1; i++)\n                    for (j = -kx; j < kx + 1; j++) {\n                        if (y + i >= height || y + i < 0 || x + j >= width || x + j < 0)\n                            continue;\n\n                        val = in_pixels[(y + i) * rowstride + (x + j) * 4 + ch];\n\n\n                        if (erode->mode == 0) {\n                            if (extreme > val)\n                                extreme = val;\n                        } else {\n                            if (extreme < val)\n                                extreme = val;\n                        }\n\n                    }\n                output_pixels[y * rowstride + x * 4 + ch] = extreme;\n            }\n\n    cairo_surface_mark_dirty (output);\n\n    rsvg_filter_store_result (primitive->result, output, ctx);\n\n    cairo_surface_destroy (in);\n    cairo_surface_destroy (output);\n}\n\nstatic void\nrsvg_filter_primitive_erode_set_atts (RsvgNode *node, gpointer impl, RsvgHandle *handle, RsvgPropertyBag *atts)\n{\n    RsvgFilterPrimitiveErode *filter = impl;\n    const char *value;\n\n    if ((value = rsvg_property_bag_lookup (atts, \"in\")))\n        g_string_assign (filter->super.in, value);\n    if ((value = rsvg_property_bag_lookup (atts, \"result\")))\n        g_string_assign (filter->super.result, value);\n\n    filter_primitive_set_x_y_width_height_atts ((RsvgFilterPrimitive *) filter, atts);\n\n    if ((value = rsvg_property_bag_lookup (atts, \"radius\"))) {\n        if (!rsvg_css_parse_number_optional_number (value, &filter->rx, &filter->ry)) {\n            rsvg_node_set_attribute_parse_error (node, \"radius\", \"expected number-optional-number\");\n            return;\n        }\n    }\n\n    if ((value = rsvg_property_bag_lookup (atts, \"operator\"))) {\n        if (!strcmp (value, \"erode\"))\n            filter->mode = 0;\n        else if (!strcmp (value, \"dilate\"))\n            filter->mode = 1;\n    }\n}\n\nRsvgNode *\nrsvg_new_filter_primitive_erode (const char *element_name, RsvgNode *parent)\n{\n    RsvgFilterPrimitiveErode *filter;\n\n    filter = g_new0 (RsvgFilterPrimitiveErode, 1);\n    filter->super.in = g_string_new (\"none\");\n    filter->super.result = g_string_new (\"none\");\n    filter->rx = 0;\n    filter->ry = 0;\n    filter->mode = 0;\n    filter->super.render = rsvg_filter_primitive_erode_render;\n\n    return rsvg_rust_cnode_new (RSVG_NODE_TYPE_FILTER_PRIMITIVE_ERODE,\n                                parent,\n                                rsvg_state_new (),\n                                filter,\n                                rsvg_filter_primitive_erode_set_atts,\n                                rsvg_filter_draw,\n                                rsvg_filter_primitive_free);\n}\n\n/*************************************************************/\n/*************************************************************/\n\ntypedef enum {\n    COMPOSITE_MODE_OVER, COMPOSITE_MODE_IN, COMPOSITE_MODE_OUT,\n    COMPOSITE_MODE_ATOP, COMPOSITE_MODE_XOR, COMPOSITE_MODE_ARITHMETIC\n} RsvgFilterPrimitiveCompositeMode;\n\ntypedef struct _RsvgFilterPrimitiveComposite RsvgFilterPrimitiveComposite;\nstruct _RsvgFilterPrimitiveComposite {\n    RsvgFilterPrimitive super;\n    RsvgFilterPrimitiveCompositeMode mode;\n    GString *in2;\n\n    int k1, k2, k3, k4;\n};\n\nstatic cairo_operator_t\ncomposite_mode_to_cairo_operator (RsvgFilterPrimitiveCompositeMode mode)\n{\n    switch (mode) {\n    case COMPOSITE_MODE_OVER:\n        return CAIRO_OPERATOR_OVER;\n\n    case COMPOSITE_MODE_IN:\n        return CAIRO_OPERATOR_IN;\n\n    case COMPOSITE_MODE_OUT:\n        return CAIRO_OPERATOR_OUT;\n\n    case COMPOSITE_MODE_ATOP:\n        return CAIRO_OPERATOR_ATOP;\n\n    case COMPOSITE_MODE_XOR:\n        return CAIRO_OPERATOR_XOR;\n\n    default:\n        g_assert_not_reached ();\n        return CAIRO_OPERATOR_CLEAR;\n    }\n}\n\nstatic void\nrsvg_filter_primitive_composite_render (RsvgNode *node, RsvgFilterPrimitive *primitive, RsvgFilterContext *ctx)\n{\n    RsvgFilterPrimitiveComposite *composite = (RsvgFilterPrimitiveComposite *) primitive;\n    RsvgIRect boundarys;\n    cairo_surface_t *output, *in, *in2;\n\n    boundarys = rsvg_filter_primitive_get_bounds (primitive, ctx);\n\n    in = rsvg_filter_get_in (primitive->in, ctx);\n    if (in == NULL)\n        return;\n\n    in2 = rsvg_filter_get_in (composite->in2, ctx);\n    if (in2 == NULL) {\n        cairo_surface_destroy (in);\n        return;\n    }\n\n    if (composite->mode == COMPOSITE_MODE_ARITHMETIC) {\n        guchar i;\n        gint x, y;\n        gint rowstride, height, width;\n        guchar *in_pixels;\n        guchar *in2_pixels;\n        guchar *output_pixels;\n\n        height = cairo_image_surface_get_height (in);\n        width = cairo_image_surface_get_width (in);\n        rowstride = cairo_image_surface_get_stride (in);\n\n        output = _rsvg_image_surface_new (width, height);\n        if (output == NULL) {\n            cairo_surface_destroy (in);\n            cairo_surface_destroy (in2);\n            return;\n        }\n\n        cairo_surface_flush (in);\n        cairo_surface_flush (in2);\n\n        in_pixels = cairo_image_surface_get_data (in);\n        in2_pixels = cairo_image_surface_get_data (in2);\n        output_pixels = cairo_image_surface_get_data (output);\n\n        for (y = boundarys.y0; y < boundarys.y1; y++) {\n            for (x = boundarys.x0; x < boundarys.x1; x++) {\n                int qr, qa, qb;\n\n                qa = in_pixels[4 * x + y * rowstride + 3];\n                qb = in2_pixels[4 * x + y * rowstride + 3];\n                qr = (composite->k1 * qa * qb / 255 + composite->k2 * qa + composite->k3 * qb) / 255;\n\n                if (qr > 255)\n                    qr = 255;\n                if (qr < 0)\n                    qr = 0;\n                output_pixels[4 * x + y * rowstride + 3] = qr;\n                if (qr) {\n                    for (i = 0; i < 3; i++) {\n                        int ca, cb, cr;\n                        ca = in_pixels[4 * x + y * rowstride + i];\n                        cb = in2_pixels[4 * x + y * rowstride + i];\n\n                        cr = (ca * cb * composite->k1 / 255 + ca * composite->k2 +\n                              cb * composite->k3 + composite->k4 * qr) / 255;\n                        if (cr > qr)\n                            cr = qr;\n                        if (cr < 0)\n                            cr = 0;\n                        output_pixels[4 * x + y * rowstride + i] = cr;\n                    }\n                }\n            }\n        }\n\n        cairo_surface_mark_dirty (output);\n    } else {\n        cairo_t *cr;\n\n        cairo_surface_reference (in2);\n        output = in2;\n\n        cr = cairo_create (output);\n        cairo_set_source_surface (cr, in, 0, 0);\n        cairo_rectangle (cr,\n                         boundarys.x0,\n                         boundarys.y0,\n                         boundarys.x1 - boundarys.x0,\n                         boundarys.y1 - boundarys.y0);\n        cairo_clip (cr);\n        cairo_set_operator (cr, composite_mode_to_cairo_operator (composite->mode));\n        cairo_paint (cr);\n        cairo_destroy (cr);\n    }\n\n    rsvg_filter_store_result (primitive->result, output, ctx);\n\n    cairo_surface_destroy (in);\n    cairo_surface_destroy (in2);\n    cairo_surface_destroy (output);\n}\n\nstatic void\nrsvg_filter_primitive_composite_free (gpointer impl)\n{\n    RsvgFilterPrimitiveComposite *composite = impl;\n\n    g_string_free (composite->in2, TRUE);\n\n    rsvg_filter_primitive_free (impl);\n}\n\nstatic void\nrsvg_filter_primitive_composite_set_atts (RsvgNode *node, gpointer impl, RsvgHandle *handle, RsvgPropertyBag *atts)\n{\n    RsvgFilterPrimitiveComposite *filter = impl;\n    const char *value;\n\n    if ((value = rsvg_property_bag_lookup (atts, \"operator\"))) {\n        if (!strcmp (value, \"in\"))\n            filter->mode = COMPOSITE_MODE_IN;\n        else if (!strcmp (value, \"out\"))\n            filter->mode = COMPOSITE_MODE_OUT;\n        else if (!strcmp (value, \"atop\"))\n            filter->mode = COMPOSITE_MODE_ATOP;\n        else if (!strcmp (value, \"xor\"))\n            filter->mode = COMPOSITE_MODE_XOR;\n        else if (!strcmp (value, \"arithmetic\"))\n            filter->mode = COMPOSITE_MODE_ARITHMETIC;\n        else\n            filter->mode = COMPOSITE_MODE_OVER;\n    }\n    if ((value = rsvg_property_bag_lookup (atts, \"in\")))\n        g_string_assign (filter->super.in, value);\n    if ((value = rsvg_property_bag_lookup (atts, \"in2\")))\n        g_string_assign (filter->in2, value);\n    if ((value = rsvg_property_bag_lookup (atts, \"result\")))\n        g_string_assign (filter->super.result, value);\n\n    filter_primitive_set_x_y_width_height_atts ((RsvgFilterPrimitive *) filter, atts);\n\n    if ((value = rsvg_property_bag_lookup (atts, \"k1\")))\n        filter->k1 = g_ascii_strtod (value, NULL) * 255.;\n    if ((value = rsvg_property_bag_lookup (atts, \"k2\")))\n        filter->k2 = g_ascii_strtod (value, NULL) * 255.;\n    if ((value = rsvg_property_bag_lookup (atts, \"k3\")))\n        filter->k3 = g_ascii_strtod (value, NULL) * 255.;\n    if ((value = rsvg_property_bag_lookup (atts, \"k4\")))\n        filter->k4 = g_ascii_strtod (value, NULL) * 255.;\n}\n\nRsvgNode *\nrsvg_new_filter_primitive_composite (const char *element_name, RsvgNode *parent)\n{\n    RsvgFilterPrimitiveComposite *filter;\n\n    filter = g_new0 (RsvgFilterPrimitiveComposite, 1);\n    filter->mode = COMPOSITE_MODE_OVER;\n    filter->super.in = g_string_new (\"none\");\n    filter->in2 = g_string_new (\"none\");\n    filter->super.result = g_string_new (\"none\");\n    filter->k1 = 0;\n    filter->k2 = 0;\n    filter->k3 = 0;\n    filter->k4 = 0;\n    filter->super.render = rsvg_filter_primitive_composite_render;\n\n    return rsvg_rust_cnode_new (RSVG_NODE_TYPE_FILTER_PRIMITIVE_COMPOSITE,\n                                parent,\n                                rsvg_state_new (),\n                                filter,\n                                rsvg_filter_primitive_composite_set_atts,\n                                rsvg_filter_draw,\n                                rsvg_filter_primitive_composite_free);\n}\n\n/*************************************************************/\n/*************************************************************/\n\nstatic void\nrsvg_filter_primitive_flood_render (RsvgNode *node, RsvgFilterPrimitive *primitive, RsvgFilterContext *ctx)\n{\n    RsvgState *state;\n    guchar i;\n    gint x, y;\n    gint rowstride, height, width;\n    RsvgIRect boundarys;\n    guchar *output_pixels;\n    cairo_surface_t *output;\n    char pixcolor[4];\n    RsvgFilterPrimitiveOutput out;\n\n    state = rsvg_node_get_state (node);\n\n    guint32 color = state->flood_color;\n    guint8 opacity = state->flood_opacity;\n\n    boundarys = rsvg_filter_primitive_get_bounds (primitive, ctx);\n\n    height = ctx->height;\n    width = ctx->width;\n    output = _rsvg_image_surface_new (width, height);\n    if (output == NULL)\n        return;\n\n    rowstride = cairo_image_surface_get_stride (output);\n\n    output_pixels = cairo_image_surface_get_data (output);\n\n    for (i = 0; i < 3; i++)\n        pixcolor[i] = (int) (((unsigned char *)\n                              (&color))[2 - i]) * opacity / 255;\n    pixcolor[3] = opacity;\n\n    for (y = boundarys.y0; y < boundarys.y1; y++)\n        for (x = boundarys.x0; x < boundarys.x1; x++)\n            for (i = 0; i < 4; i++)\n                output_pixels[4 * x + y * rowstride + ctx->channelmap[i]] = pixcolor[i];\n\n    cairo_surface_mark_dirty (output);\n\n    out.surface = output;\n    out.bounds = boundarys;\n\n    rsvg_filter_store_output (primitive->result, out, ctx);\n\n    cairo_surface_destroy (output);\n}\n\nstatic void\nrsvg_filter_primitive_flood_set_atts (RsvgNode *node, gpointer impl, RsvgHandle *handle, RsvgPropertyBag *atts)\n{\n    RsvgFilterPrimitive *filter = impl;\n    const char *value;\n\n    if ((value = rsvg_property_bag_lookup (atts, \"result\")))\n        g_string_assign (filter->result, value);\n\n    filter_primitive_set_x_y_width_height_atts ((RsvgFilterPrimitive *) filter, atts);\n}\n\nRsvgNode *\nrsvg_new_filter_primitive_flood (const char *element_name, RsvgNode *parent)\n{\n    RsvgFilterPrimitive *filter;\n\n    filter = g_new0 (RsvgFilterPrimitive, 1);\n    filter->in = g_string_new (\"none\");\n    filter->result = g_string_new (\"none\");\n    filter->render = rsvg_filter_primitive_flood_render;\n\n    return rsvg_rust_cnode_new (RSVG_NODE_TYPE_FILTER_PRIMITIVE_FLOOD,\n                                parent,\n                                rsvg_state_new (),\n                                filter,\n                                rsvg_filter_primitive_flood_set_atts,\n                                rsvg_filter_draw,\n                                rsvg_filter_primitive_free);\n}\n\n/*************************************************************/\n/*************************************************************/\n\ntypedef struct _RsvgFilterPrimitiveDisplacementMap RsvgFilterPrimitiveDisplacementMap;\n\nstruct _RsvgFilterPrimitiveDisplacementMap {\n    RsvgFilterPrimitive super;\n    gint dx, dy;\n    char xChannelSelector, yChannelSelector;\n    GString *in2;\n    double scale;\n};\n\nstatic void\nrsvg_filter_primitive_displacement_map_render (RsvgNode *node, RsvgFilterPrimitive *primitive, RsvgFilterContext *ctx)\n{\n    RsvgFilterPrimitiveDisplacementMap *displacement_map = (RsvgFilterPrimitiveDisplacementMap *) primitive;\n    guchar ch, xch, ych;\n    gint x, y;\n    gint rowstride, height, width;\n    RsvgIRect boundarys;\n\n    guchar *in_pixels;\n    guchar *in2_pixels;\n    guchar *output_pixels;\n\n    cairo_surface_t *output, *in, *in2;\n\n    double ox, oy;\n\n    boundarys = rsvg_filter_primitive_get_bounds (primitive, ctx);\n\n    in = rsvg_filter_get_in (primitive->in, ctx);\n    if (in == NULL)\n        return;\n\n    cairo_surface_flush (in);\n\n    in2 = rsvg_filter_get_in (displacement_map->in2, ctx);\n    if (in2 == NULL) {\n        cairo_surface_destroy (in);\n        return;\n    }\n\n    cairo_surface_flush (in2);\n\n    in_pixels = cairo_image_surface_get_data (in);\n    in2_pixels = cairo_image_surface_get_data (in2);\n\n    height = cairo_image_surface_get_height (in);\n    width = cairo_image_surface_get_width (in);\n\n    rowstride = cairo_image_surface_get_stride (in);\n\n    output = _rsvg_image_surface_new (width, height);\n    if (output == NULL) {\n        cairo_surface_destroy (in);\n        cairo_surface_destroy (in2);\n        return;\n    }\n\n    output_pixels = cairo_image_surface_get_data (output);\n\n    switch (displacement_map->xChannelSelector) {\n    case 'R':\n        xch = 0;\n        break;\n    case 'G':\n        xch = 1;\n        break;\n    case 'B':\n        xch = 2;\n        break;\n    case 'A':\n        xch = 3;\n        break;\n    default:\n        xch = 0;\n        break;\n    }\n\n    switch (displacement_map->yChannelSelector) {\n    case 'R':\n        ych = 0;\n        break;\n    case 'G':\n        ych = 1;\n        break;\n    case 'B':\n        ych = 2;\n        break;\n    case 'A':\n        ych = 3;\n        break;\n    default:\n        ych = 1;\n        break;\n    }\n\n    xch = ctx->channelmap[xch];\n    ych = ctx->channelmap[ych];\n    for (y = boundarys.y0; y < boundarys.y1; y++)\n        for (x = boundarys.x0; x < boundarys.x1; x++) {\n            if (xch != 4)\n                ox = x + displacement_map->scale * ctx->paffine.xx *\n                    ((double) in2_pixels[y * rowstride + x * 4 + xch] / 255.0 - 0.5);\n            else\n                ox = x;\n\n            if (ych != 4)\n                oy = y + displacement_map->scale * ctx->paffine.yy *\n                    ((double) in2_pixels[y * rowstride + x * 4 + ych] / 255.0 - 0.5);\n            else\n                oy = y;\n\n            for (ch = 0; ch < 4; ch++) {\n                output_pixels[y * rowstride + x * 4 + ch] =\n                    get_interp_pixel (in_pixels, ox, oy, ch, boundarys, rowstride);\n            }\n        }\n\n    cairo_surface_mark_dirty (output);\n\n    rsvg_filter_store_result (primitive->result, output, ctx);\n\n    cairo_surface_destroy (in);\n    cairo_surface_destroy (in2);\n    cairo_surface_destroy (output);\n}\n\nstatic void\nrsvg_filter_primitive_displacement_map_free (gpointer impl)\n{\n    RsvgFilterPrimitiveDisplacementMap *dmap = impl;\n\n    g_string_free (dmap->in2, TRUE);\n\n    rsvg_filter_primitive_free (impl);\n}\n\nstatic void\nrsvg_filter_primitive_displacement_map_set_atts (RsvgNode *node, gpointer impl, RsvgHandle *handle, RsvgPropertyBag *atts)\n{\n    RsvgFilterPrimitiveDisplacementMap *filter = impl;\n    const char *value;\n\n    if ((value = rsvg_property_bag_lookup (atts, \"in\")))\n        g_string_assign (filter->super.in, value);\n    if ((value = rsvg_property_bag_lookup (atts, \"in2\")))\n        g_string_assign (filter->in2, value);\n    if ((value = rsvg_property_bag_lookup (atts, \"result\")))\n        g_string_assign (filter->super.result, value);\n\n    filter_primitive_set_x_y_width_height_atts ((RsvgFilterPrimitive *) filter, atts);\n\n    if ((value = rsvg_property_bag_lookup (atts, \"xChannelSelector\")))\n        filter->xChannelSelector = (value)[0];\n    if ((value = rsvg_property_bag_lookup (atts, \"yChannelSelector\")))\n        filter->yChannelSelector = (value)[0];\n    if ((value = rsvg_property_bag_lookup (atts, \"scale\")))\n        filter->scale = g_ascii_strtod (value, NULL);\n}\n\nRsvgNode *\nrsvg_new_filter_primitive_displacement_map (const char *element_name, RsvgNode *parent)\n{\n    RsvgFilterPrimitiveDisplacementMap *filter;\n\n    filter = g_new0 (RsvgFilterPrimitiveDisplacementMap, 1);\n    filter->super.in = g_string_new (\"none\");\n    filter->in2 = g_string_new (\"none\");\n    filter->super.result = g_string_new (\"none\");\n    filter->xChannelSelector = ' ';\n    filter->yChannelSelector = ' ';\n    filter->scale = 0;\n    filter->super.render = rsvg_filter_primitive_displacement_map_render;\n\n    return rsvg_rust_cnode_new (RSVG_NODE_TYPE_FILTER_PRIMITIVE_DISPLACEMENT_MAP,\n                                parent,\n                                rsvg_state_new (),\n                                filter,\n                                rsvg_filter_primitive_displacement_map_set_atts,\n                                rsvg_filter_draw,\n                                rsvg_filter_primitive_displacement_map_free);\n}\n\n/*************************************************************/\n/*************************************************************/\n\n/* Produces results in the range [1, 2**31 - 2].\n   Algorithm is: r = (a * r) mod m\n   where a = 16807 and m = 2**31 - 1 = 2147483647\n   See [Park & Miller], CACM vol. 31 no. 10 p. 1195, Oct. 1988\n   To test: the algorithm should produce the result 1043618065\n   as the 10,000th generated number if the original seed is 1.\n*/\n#define feTurbulence_RAND_m 2147483647  /* 2**31 - 1 */\n#define feTurbulence_RAND_a 16807       /* 7**5; primitive root of m */\n#define feTurbulence_RAND_q 127773      /* m / a */\n#define feTurbulence_RAND_r 2836        /* m % a */\n#define feTurbulence_BSize 0x100\n#define feTurbulence_BM 0xff\n#define feTurbulence_PerlinN 0x1000\n#define feTurbulence_NP 12      /* 2^PerlinN */\n#define feTurbulence_NM 0xfff\n\ntypedef struct _RsvgFilterPrimitiveTurbulence RsvgFilterPrimitiveTurbulence;\nstruct _RsvgFilterPrimitiveTurbulence {\n    RsvgFilterPrimitive super;\n\n    int uLatticeSelector[feTurbulence_BSize + feTurbulence_BSize + 2];\n    double fGradient[4][feTurbulence_BSize + feTurbulence_BSize + 2][2];\n\n    int seed;\n\n    double fBaseFreqX;\n    double fBaseFreqY;\n\n    int nNumOctaves;\n    gboolean bFractalSum;\n    gboolean bDoStitching;\n};\n\nstruct feTurbulence_StitchInfo {\n    int nWidth;                 /* How much to subtract to wrap for stitching. */\n    int nHeight;\n    int nWrapX;                 /* Minimum value to wrap. */\n    int nWrapY;\n};\n\nstatic long\nfeTurbulence_setup_seed (int lSeed)\n{\n    if (lSeed <= 0)\n        lSeed = -(lSeed % (feTurbulence_RAND_m - 1)) + 1;\n    if (lSeed > feTurbulence_RAND_m - 1)\n        lSeed = feTurbulence_RAND_m - 1;\n    return lSeed;\n}\n\nstatic long\nfeTurbulence_random (int lSeed)\n{\n    long result;\n\n    result =\n        feTurbulence_RAND_a * (lSeed % feTurbulence_RAND_q) -\n        feTurbulence_RAND_r * (lSeed / feTurbulence_RAND_q);\n    if (result <= 0)\n        result += feTurbulence_RAND_m;\n    return result;\n}\n\nstatic void\nfeTurbulence_init (RsvgFilterPrimitiveTurbulence * filter)\n{\n    double s;\n    int i, j, k, lSeed;\n\n    lSeed = feTurbulence_setup_seed (filter->seed);\n    for (k = 0; k < 4; k++) {\n        for (i = 0; i < feTurbulence_BSize; i++) {\n            filter->uLatticeSelector[i] = i;\n            for (j = 0; j < 2; j++)\n                filter->fGradient[k][i][j] =\n                    (double) (((lSeed =\n                                feTurbulence_random (lSeed)) % (feTurbulence_BSize +\n                                                                feTurbulence_BSize)) -\n                              feTurbulence_BSize) / feTurbulence_BSize;\n            s = (double) (sqrt\n                          (filter->fGradient[k][i][0] * filter->fGradient[k][i][0] +\n                           filter->fGradient[k][i][1] * filter->fGradient[k][i][1]));\n            filter->fGradient[k][i][0] /= s;\n            filter->fGradient[k][i][1] /= s;\n        }\n    }\n\n    while (--i) {\n        k = filter->uLatticeSelector[i];\n        filter->uLatticeSelector[i] = filter->uLatticeSelector[j =\n                                                               (lSeed =\n                                                                feTurbulence_random (lSeed)) %\n                                                               feTurbulence_BSize];\n        filter->uLatticeSelector[j] = k;\n    }\n\n    for (i = 0; i < feTurbulence_BSize + 2; i++) {\n        filter->uLatticeSelector[feTurbulence_BSize + i] = filter->uLatticeSelector[i];\n        for (k = 0; k < 4; k++)\n            for (j = 0; j < 2; j++)\n                filter->fGradient[k][feTurbulence_BSize + i][j] = filter->fGradient[k][i][j];\n    }\n}\n\n#define feTurbulence_s_curve(t) ( t * t * (3. - 2. * t) )\n#define feTurbulence_lerp(t, a, b) ( a + t * (b - a) )\n\nstatic double\nfeTurbulence_noise2 (RsvgFilterPrimitiveTurbulence * filter,\n                     int nColorChannel, double vec[2], struct feTurbulence_StitchInfo *pStitchInfo)\n{\n    int bx0, bx1, by0, by1, b00, b10, b01, b11;\n    double rx0, rx1, ry0, ry1, *q, sx, sy, a, b, t, u, v;\n    register int i, j;\n\n    t = vec[0] + feTurbulence_PerlinN;\n    bx0 = (int) t;\n    bx1 = bx0 + 1;\n    rx0 = t - (int) t;\n    rx1 = rx0 - 1.0f;\n    t = vec[1] + feTurbulence_PerlinN;\n    by0 = (int) t;\n    by1 = by0 + 1;\n    ry0 = t - (int) t;\n    ry1 = ry0 - 1.0f;\n\n    /* If stitching, adjust lattice points accordingly. */\n    if (pStitchInfo != NULL) {\n        if (bx0 >= pStitchInfo->nWrapX)\n            bx0 -= pStitchInfo->nWidth;\n        if (bx1 >= pStitchInfo->nWrapX)\n            bx1 -= pStitchInfo->nWidth;\n        if (by0 >= pStitchInfo->nWrapY)\n            by0 -= pStitchInfo->nHeight;\n        if (by1 >= pStitchInfo->nWrapY)\n            by1 -= pStitchInfo->nHeight;\n    }\n\n    bx0 &= feTurbulence_BM;\n    bx1 &= feTurbulence_BM;\n    by0 &= feTurbulence_BM;\n    by1 &= feTurbulence_BM;\n    i = filter->uLatticeSelector[bx0];\n    j = filter->uLatticeSelector[bx1];\n    b00 = filter->uLatticeSelector[i + by0];\n    b10 = filter->uLatticeSelector[j + by0];\n    b01 = filter->uLatticeSelector[i + by1];\n    b11 = filter->uLatticeSelector[j + by1];\n    sx = (double) (feTurbulence_s_curve (rx0));\n    sy = (double) (feTurbulence_s_curve (ry0));\n    q = filter->fGradient[nColorChannel][b00];\n    u = rx0 * q[0] + ry0 * q[1];\n    q = filter->fGradient[nColorChannel][b10];\n    v = rx1 * q[0] + ry0 * q[1];\n    a = feTurbulence_lerp (sx, u, v);\n    q = filter->fGradient[nColorChannel][b01];\n    u = rx0 * q[0] + ry1 * q[1];\n    q = filter->fGradient[nColorChannel][b11];\n    v = rx1 * q[0] + ry1 * q[1];\n    b = feTurbulence_lerp (sx, u, v);\n\n    return feTurbulence_lerp (sy, a, b);\n}\n\nstatic double\nfeTurbulence_turbulence (RsvgFilterPrimitiveTurbulence * filter,\n                         int nColorChannel, double *point,\n                         double fTileX, double fTileY, double fTileWidth, double fTileHeight)\n{\n    struct feTurbulence_StitchInfo stitch;\n    struct feTurbulence_StitchInfo *pStitchInfo = NULL; /* Not stitching when NULL. */\n\n    double fSum = 0.0f, vec[2], ratio = 1.;\n    int nOctave;\n\n    /* Adjust the base frequencies if necessary for stitching. */\n    if (filter->bDoStitching) {\n        /* When stitching tiled turbulence, the frequencies must be adjusted\n           so that the tile borders will be continuous. */\n        if (filter->fBaseFreqX != 0.0) {\n            double fLoFreq = (double) (floor (fTileWidth * filter->fBaseFreqX)) / fTileWidth;\n            double fHiFreq = (double) (ceil (fTileWidth * filter->fBaseFreqX)) / fTileWidth;\n            if (filter->fBaseFreqX / fLoFreq < fHiFreq / filter->fBaseFreqX)\n                filter->fBaseFreqX = fLoFreq;\n            else\n                filter->fBaseFreqX = fHiFreq;\n        }\n\n        if (filter->fBaseFreqY != 0.0) {\n            double fLoFreq = (double) (floor (fTileHeight * filter->fBaseFreqY)) / fTileHeight;\n            double fHiFreq = (double) (ceil (fTileHeight * filter->fBaseFreqY)) / fTileHeight;\n            if (filter->fBaseFreqY / fLoFreq < fHiFreq / filter->fBaseFreqY)\n                filter->fBaseFreqY = fLoFreq;\n            else\n                filter->fBaseFreqY = fHiFreq;\n        }\n\n        /* Set up initial stitch values. */\n        pStitchInfo = &stitch;\n        stitch.nWidth = (int) (fTileWidth * filter->fBaseFreqX + 0.5f);\n        stitch.nWrapX = fTileX * filter->fBaseFreqX + feTurbulence_PerlinN + stitch.nWidth;\n        stitch.nHeight = (int) (fTileHeight * filter->fBaseFreqY + 0.5f);\n        stitch.nWrapY = fTileY * filter->fBaseFreqY + feTurbulence_PerlinN + stitch.nHeight;\n    }\n\n    vec[0] = point[0] * filter->fBaseFreqX;\n    vec[1] = point[1] * filter->fBaseFreqY;\n\n    for (nOctave = 0; nOctave < filter->nNumOctaves; nOctave++) {\n        if (filter->bFractalSum)\n            fSum +=\n                (double) (feTurbulence_noise2 (filter, nColorChannel, vec, pStitchInfo) / ratio);\n        else\n            fSum +=\n                (double) (fabs (feTurbulence_noise2 (filter, nColorChannel, vec, pStitchInfo)) /\n                          ratio);\n\n        vec[0] *= 2;\n        vec[1] *= 2;\n        ratio *= 2;\n\n        if (pStitchInfo != NULL) {\n            /* Update stitch values. Subtracting PerlinN before the multiplication and\n               adding it afterward simplifies to subtracting it once. */\n            stitch.nWidth *= 2;\n            stitch.nWrapX = 2 * stitch.nWrapX - feTurbulence_PerlinN;\n            stitch.nHeight *= 2;\n            stitch.nWrapY = 2 * stitch.nWrapY - feTurbulence_PerlinN;\n        }\n    }\n\n    return fSum;\n}\n\nstatic void\nrsvg_filter_primitive_turbulence_render (RsvgNode *node, RsvgFilterPrimitive *primitive, RsvgFilterContext *ctx)\n{\n    RsvgFilterPrimitiveTurbulence *turbulence = (RsvgFilterPrimitiveTurbulence *) primitive;\n\n    gint x, y, tileWidth, tileHeight, rowstride, width, height;\n    RsvgIRect boundarys;\n    guchar *output_pixels;\n    cairo_surface_t *output, *in;\n    cairo_matrix_t affine;\n\n    affine = ctx->paffine;\n    if (cairo_matrix_invert (&affine) != CAIRO_STATUS_SUCCESS)\n      return;\n\n    in = rsvg_filter_get_in (primitive->in, ctx);\n    if (in == NULL)\n        return;\n\n    cairo_surface_flush (in);\n\n    height = cairo_image_surface_get_height (in);\n    width = cairo_image_surface_get_width (in);\n    rowstride = cairo_image_surface_get_stride (in);\n\n    boundarys = rsvg_filter_primitive_get_bounds (primitive, ctx);\n\n    tileWidth = (boundarys.x1 - boundarys.x0);\n    tileHeight = (boundarys.y1 - boundarys.y0);\n\n    output = _rsvg_image_surface_new (width, height);\n    if (output == NULL) {\n        cairo_surface_destroy (in);\n        return;\n    }\n\n    output_pixels = cairo_image_surface_get_data (output);\n\n    for (y = 0; y < tileHeight; y++) {\n        for (x = 0; x < tileWidth; x++) {\n            gint i;\n            double point[2];\n            guchar *pixel;\n            point[0] = affine.xx * (x + boundarys.x0) + affine.xy * (y + boundarys.y0) + affine.x0;\n            point[1] = affine.yx * (x + boundarys.x0) + affine.yy * (y + boundarys.y0) + affine.y0;\n\n            pixel = output_pixels + 4 * (x + boundarys.x0) + (y + boundarys.y0) * rowstride;\n\n            for (i = 0; i < 4; i++) {\n                double cr;\n\n                cr = feTurbulence_turbulence (turbulence, i, point, (double) x, (double) y,\n                                              (double) tileWidth, (double) tileHeight);\n\n                if (turbulence->bFractalSum)\n                    cr = ((cr * 255.) + 255.) / 2.;\n                else\n                    cr = (cr * 255.);\n\n                cr = CLAMP (cr, 0., 255.);\n\n                pixel[ctx->channelmap[i]] = (guchar) cr;\n            }\n            for (i = 0; i < 3; i++)\n                pixel[ctx->channelmap[i]] =\n                    pixel[ctx->channelmap[i]] * pixel[ctx->channelmap[3]] / 255;\n\n        }\n    }\n\n    cairo_surface_mark_dirty (output);\n\n    rsvg_filter_store_result (primitive->result, output, ctx);\n\n    cairo_surface_destroy (in);\n    cairo_surface_destroy (output);\n}\n\nstatic void\nrsvg_filter_primitive_turbulence_set_atts (RsvgNode *node, gpointer impl, RsvgHandle *handle, RsvgPropertyBag *atts)\n{\n    RsvgFilterPrimitiveTurbulence *filter = impl;\n    const char *value;\n\n    if ((value = rsvg_property_bag_lookup (atts, \"in\")))\n        g_string_assign (filter->super.in, value);\n    if ((value = rsvg_property_bag_lookup (atts, \"result\")))\n        g_string_assign (filter->super.result, value);\n\n    filter_primitive_set_x_y_width_height_atts ((RsvgFilterPrimitive *) filter, atts);\n\n    if ((value = rsvg_property_bag_lookup (atts, \"baseFrequency\"))) {\n        if (!rsvg_css_parse_number_optional_number (value, &filter->fBaseFreqX, &filter->fBaseFreqY)) {\n            rsvg_node_set_attribute_parse_error (node, \"baseFrequency\", \"expected number-optional-number\");\n            return;\n        }\n    }\n\n    if ((value = rsvg_property_bag_lookup (atts, \"numOctaves\")))\n        filter->nNumOctaves = atoi (value);\n    if ((value = rsvg_property_bag_lookup (atts, \"seed\")))\n        filter->seed = atoi (value);\n    if ((value = rsvg_property_bag_lookup (atts, \"stitchTiles\")))\n        filter->bDoStitching = (!strcmp (value, \"stitch\"));\n    if ((value = rsvg_property_bag_lookup (atts, \"type\")))\n        filter->bFractalSum = (!strcmp (value, \"fractalNoise\"));\n}\n\nRsvgNode *\nrsvg_new_filter_primitive_turbulence (const char *element_name, RsvgNode *parent)\n{\n    RsvgFilterPrimitiveTurbulence *filter;\n\n    filter = g_new0 (RsvgFilterPrimitiveTurbulence, 1);\n    filter->super.in = g_string_new (\"none\");\n    filter->super.result = g_string_new (\"none\");\n    filter->fBaseFreqX = 0;\n    filter->fBaseFreqY = 0;\n    filter->nNumOctaves = 1;\n    filter->seed = 0;\n    filter->bDoStitching = 0;\n    filter->bFractalSum = 0;\n\n    feTurbulence_init (filter);\n\n    filter->super.render = rsvg_filter_primitive_turbulence_render;\n\n    return rsvg_rust_cnode_new (RSVG_NODE_TYPE_FILTER_PRIMITIVE_TURBULENCE,\n                                parent,\n                                rsvg_state_new (),\n                                filter,\n                                rsvg_filter_primitive_turbulence_set_atts,\n                                rsvg_filter_draw,\n                                rsvg_filter_primitive_free);\n}\n\n\n/*************************************************************/\n/*************************************************************/\n\ntypedef struct _RsvgFilterPrimitiveImage RsvgFilterPrimitiveImage;\n\nstruct _RsvgFilterPrimitiveImage {\n    RsvgFilterPrimitive super;\n    RsvgHandle *ctx;\n    GString *href;\n};\n\nstatic cairo_surface_t *\nrsvg_filter_primitive_image_render_in (RsvgFilterPrimitiveImage *image, RsvgFilterContext * context)\n{\n    RsvgDrawingCtx *ctx;\n    RsvgNode *drawable;\n    cairo_surface_t *result;\n\n    ctx = context->ctx;\n\n    if (!image->href)\n        return NULL;\n\n    drawable = rsvg_drawing_ctx_acquire_node (ctx, image->href->str);\n    if (!drawable)\n        return NULL;\n\n    rsvg_current_state (ctx)->affine = context->paffine;\n\n    result = rsvg_get_surface_of_node (ctx, drawable, context->width, context->height);\n\n    rsvg_drawing_ctx_release_node (ctx, drawable);\n\n    return result;\n}\n\nstatic cairo_surface_t *\nrsvg_filter_primitive_image_render_ext (RsvgFilterPrimitive *self, RsvgFilterContext * ctx)\n{\n    RsvgFilterPrimitiveImage *image = (RsvgFilterPrimitiveImage *) self;\n    RsvgIRect boundarys;\n    cairo_surface_t *img, *intermediate;\n    int i;\n    unsigned char *pixels;\n    int channelmap[4];\n    int length;\n    int width, height;\n\n    if (!image->href)\n        return NULL;\n\n    boundarys = rsvg_filter_primitive_get_bounds (self, ctx);\n\n    width = boundarys.x1 - boundarys.x0;\n    height = boundarys.y1 - boundarys.y0;\n    if (width == 0 || height == 0)\n        return NULL;\n\n    img = rsvg_cairo_surface_new_from_href (image->ctx,\n                                            image->href->str,\n                                            NULL);\n    if (!img)\n        return NULL;\n\n    intermediate = cairo_image_surface_create (CAIRO_FORMAT_ARGB32, width, height);\n    if (cairo_surface_status (intermediate) != CAIRO_STATUS_SUCCESS ||\n        !rsvg_art_affine_image (img, intermediate,\n                                &ctx->paffine,\n                                (gdouble) width / ctx->paffine.xx,\n                                (gdouble) height / ctx->paffine.yy)) {\n        cairo_surface_destroy (intermediate);\n        cairo_surface_destroy (img);\n        return NULL;\n    }\n\n    cairo_surface_destroy (img);\n\n    length = cairo_image_surface_get_height (intermediate) *\n             cairo_image_surface_get_stride (intermediate);\n    for (i = 0; i < 4; i++)\n        channelmap[i] = ctx->channelmap[i];\n    pixels = cairo_image_surface_get_data (intermediate);\n    for (i = 0; i < length; i += 4) {\n        unsigned char alpha;\n        unsigned char pixel[4];\n        int ch;\n        alpha = pixels[i + 3];\n\n        pixel[channelmap[3]] = alpha;\n        if (alpha)\n            for (ch = 0; ch < 3; ch++)\n                pixel[channelmap[ch]] = pixels[i + ch] * alpha / 255;\n        else\n            for (ch = 0; ch < 3; ch++)\n                pixel[channelmap[ch]] = 0;\n        for (ch = 0; ch < 4; ch++)\n            pixels[i + ch] = pixel[ch];\n    }\n\n    cairo_surface_mark_dirty (intermediate);\n    return intermediate;\n}\n\nstatic void\nrsvg_filter_primitive_image_render (RsvgNode *node, RsvgFilterPrimitive *primitive, RsvgFilterContext *ctx)\n{\n    RsvgFilterPrimitiveImage *image = (RsvgFilterPrimitiveImage *) primitive;\n\n    RsvgIRect boundarys;\n    RsvgFilterPrimitiveOutput op;\n    cairo_surface_t *output, *img;\n\n    if (!image->href)\n        return;\n\n    boundarys = rsvg_filter_primitive_get_bounds (primitive, ctx);\n\n    output = _rsvg_image_surface_new (ctx->width, ctx->height);\n    if (output == NULL)\n        return;\n\n    img = rsvg_filter_primitive_image_render_in (image, ctx);\n    if (img == NULL) {\n        img = rsvg_filter_primitive_image_render_ext (primitive, ctx);\n    }\n\n    if (img) {\n        cairo_t *cr;\n\n        cr = cairo_create (output);\n        cairo_set_source_surface (cr, img, 0, 0);\n        cairo_rectangle (cr,\n                         boundarys.x0,\n                         boundarys.y0,\n                         boundarys.x1 - boundarys.x0,\n                         boundarys.y1 - boundarys.y0);\n        cairo_clip (cr);\n        cairo_paint (cr);\n        cairo_destroy (cr);\n\n        cairo_surface_destroy (img);\n    }\n\n    op.surface = output;\n    op.bounds = boundarys;\n\n    rsvg_filter_store_output (primitive->result, op, ctx);\n\n    cairo_surface_destroy (output);\n}\n\nstatic void\nrsvg_filter_primitive_image_free (gpointer impl)\n{\n    RsvgFilterPrimitiveImage *image = impl;\n\n    if (image->href)\n        g_string_free (image->href, TRUE);\n\n    rsvg_filter_primitive_free (impl);\n}\n\nstatic void\nrsvg_filter_primitive_image_set_atts (RsvgNode *node, gpointer impl, RsvgHandle *handle, RsvgPropertyBag *atts)\n{\n    RsvgFilterPrimitiveImage *filter = impl;\n    const char *value;\n\n    filter->ctx = handle;\n\n    if ((value = rsvg_property_bag_lookup (atts, \"in\")))\n        g_string_assign (filter->super.in, value);\n    if ((value = rsvg_property_bag_lookup (atts, \"result\")))\n        g_string_assign (filter->super.result, value);\n    if ((value = rsvg_property_bag_lookup (atts, \"xlink:href\"))) {\n        filter->href = g_string_new (NULL);\n        g_string_assign (filter->href, value);\n    }\n\n    filter_primitive_set_x_y_width_height_atts ((RsvgFilterPrimitive *) filter, atts);\n}\n\nRsvgNode *\nrsvg_new_filter_primitive_image (const char *element_name, RsvgNode *parent)\n{\n    RsvgFilterPrimitiveImage *filter;\n\n    filter = g_new0 (RsvgFilterPrimitiveImage, 1);\n    filter->super.in = g_string_new (\"none\");\n    filter->super.result = g_string_new (\"none\");\n    filter->super.render = rsvg_filter_primitive_image_render;\n    filter->href = NULL;\n\n    return rsvg_rust_cnode_new (RSVG_NODE_TYPE_FILTER_PRIMITIVE_IMAGE,\n                                parent,\n                                rsvg_state_new (),\n                                filter,\n                                rsvg_filter_primitive_image_set_atts,\n                                rsvg_filter_draw,\n                                rsvg_filter_primitive_image_free);\n}\n\n/*************************************************************/\n/*************************************************************/\n\n\ntypedef struct _FactorAndMatrix FactorAndMatrix;\n\nstruct _FactorAndMatrix {\n    gint matrix[9];\n    gdouble factor;\n};\n\ntypedef struct _vector3 vector3;\n\nstruct _vector3 {\n    gdouble x;\n    gdouble y;\n    gdouble z;\n};\n\nstatic gdouble\nnorm (vector3 A)\n{\n    return sqrt (A.x * A.x + A.y * A.y + A.z * A.z);\n}\n\nstatic gdouble\ndotproduct (vector3 A, vector3 B)\n{\n    return A.x * B.x + A.y * B.y + A.z * B.z;\n}\n\nstatic vector3\nnormalise (vector3 A)\n{\n    double divisor;\n    divisor = norm (A);\n\n    A.x /= divisor;\n    A.y /= divisor;\n    A.z /= divisor;\n\n    return A;\n}\n\nstatic FactorAndMatrix\nget_light_normal_matrix_x (gint n)\n{\n    static const FactorAndMatrix matrix_list[] = {\n        {\n         {0, 0, 0,\n          0, -2, 2,\n          0, -1, 1},\n         2.0 / 3.0},\n        {\n         {0, 0, 0,\n          -2, 0, 2,\n          -1, 0, 1},\n         1.0 / 3.0},\n        {\n         {0, 0, 0,\n          -2, 2, 0,\n          -1, 1, 0},\n         2.0 / 3.0},\n        {\n         {0, -1, 1,\n          0, -2, 2,\n          0, -1, 1},\n         1.0 / 2.0},\n        {\n         {-1, 0, 1,\n          -2, 0, 2,\n          -1, 0, 1},\n         1.0 / 4.0},\n        {\n         {-1, 1, 0,\n          -2, 2, 0,\n          -1, 1, 0},\n         1.0 / 2.0},\n        {\n         {0, -1, 1,\n          0, -2, 2,\n          0, 0, 0},\n         2.0 / 3.0},\n        {\n         {-1, 0, 1,\n          -2, 0, 2,\n          0, 0, 0},\n         1.0 / 3.0},\n        {\n         {-1, 1, 0,\n          -2, 2, 0,\n          0, 0, 0},\n         2.0 / 3.0}\n    };\n\n    return matrix_list[n];\n}\n\nstatic FactorAndMatrix\nget_light_normal_matrix_y (gint n)\n{\n    static const FactorAndMatrix matrix_list[] = {\n        {\n         {0, 0, 0,\n          0, -2, -1,\n          0, 2, 1},\n         2.0 / 3.0},\n        {\n         {0, 0, 0,\n          -1, -2, -1,\n          1, 2, 1},\n         1.0 / 3.0},\n        {\n         {0, 0, 0,\n          -1, -2, 0,\n          1, 2, 0},\n         2.0 / 3.0},\n        {\n\n         {0, -2, -1,\n          0, 0, 0,\n          0, 2, 1},\n         1.0 / 2.0},\n        {\n         {-1, -2, -1,\n          0, 0, 0,\n          1, 2, 1},\n         1.0 / 4.0},\n        {\n         {-1, -2, 0,\n          0, 0, 0,\n          1, 2, 0},\n         1.0 / 2.0},\n        {\n\n         {0, -2, -1,\n          0, 2, 1,\n          0, 0, 0},\n         2.0 / 3.0},\n        {\n         {0, -2, -1,\n          1, 2, 1,\n          0, 0, 0},\n         1.0 / 3.0},\n        {\n         {-1, -2, 0,\n          1, 2, 0,\n          0, 0, 0},\n         2.0 / 3.0}\n    };\n\n    return matrix_list[n];\n}\n\nstatic vector3\nget_surface_normal (guchar * I, RsvgIRect boundarys, gint x, gint y,\n                    gdouble dx, gdouble dy, gdouble rawdx, gdouble rawdy, gdouble surfaceScale,\n                    gint rowstride, int chan)\n{\n    gint mrow, mcol;\n    FactorAndMatrix fnmx, fnmy;\n    gint *Kx, *Ky;\n    gdouble factorx, factory;\n    gdouble Nx, Ny;\n    vector3 output;\n\n    if (x + dx >= boundarys.x1 - 1)\n        mcol = 2;\n    else if (x - dx < boundarys.x0 + 1)\n        mcol = 0;\n    else\n        mcol = 1;\n\n    if (y + dy >= boundarys.y1 - 1)\n        mrow = 2;\n    else if (y - dy < boundarys.y0 + 1)\n        mrow = 0;\n    else\n        mrow = 1;\n\n    fnmx = get_light_normal_matrix_x (mrow * 3 + mcol);\n    factorx = fnmx.factor / rawdx;\n    Kx = fnmx.matrix;\n\n    fnmy = get_light_normal_matrix_y (mrow * 3 + mcol);\n    factory = fnmy.factor / rawdy;\n    Ky = fnmy.matrix;\n\n    Nx = -surfaceScale * factorx * ((gdouble)\n                                    (Kx[0] *\n                                     get_interp_pixel (I, x - dx, y - dy, chan,\n                                                                  boundarys,\n                                                                  rowstride) +\n                                     Kx[1] * get_interp_pixel (I, x, y - dy, chan,\n                                                                          boundarys,\n                                                                          rowstride) +\n                                     Kx[2] * get_interp_pixel (I, x + dx, y - dy, chan,\n                                                                          boundarys,\n                                                                          rowstride) +\n                                     Kx[3] * get_interp_pixel (I, x - dx, y, chan,\n                                                                          boundarys,\n                                                                          rowstride) +\n                                     Kx[4] * get_interp_pixel (I, x, y, chan, boundarys,\n                                                                          rowstride) +\n                                     Kx[5] * get_interp_pixel (I, x + dx, y, chan,\n                                                                          boundarys,\n                                                                          rowstride) +\n                                     Kx[6] * get_interp_pixel (I, x - dx, y + dy, chan,\n                                                                          boundarys,\n                                                                          rowstride) +\n                                     Kx[7] * get_interp_pixel (I, x, y + dy, chan,\n                                                                          boundarys,\n                                                                          rowstride) +\n                                     Kx[8] * get_interp_pixel (I, x + dx, y + dy, chan,\n                                                                          boundarys,\n                                                                          rowstride))) / 255.0;\n\n    Ny = -surfaceScale * factory * ((gdouble)\n                                    (Ky[0] *\n                                     get_interp_pixel (I, x - dx, y - dy, chan,\n                                                                  boundarys,\n                                                                  rowstride) +\n                                     Ky[1] * get_interp_pixel (I, x, y - dy, chan,\n                                                                          boundarys,\n                                                                          rowstride) +\n                                     Ky[2] * get_interp_pixel (I, x + dx, y - dy, chan,\n                                                                          boundarys,\n                                                                          rowstride) +\n                                     Ky[3] * get_interp_pixel (I, x - dx, y, chan,\n                                                                          boundarys,\n                                                                          rowstride) +\n                                     Ky[4] * get_interp_pixel (I, x, y, chan, boundarys,\n                                                                          rowstride) +\n                                     Ky[5] * get_interp_pixel (I, x + dx, y, chan,\n                                                                          boundarys,\n                                                                          rowstride) +\n                                     Ky[6] * get_interp_pixel (I, x - dx, y + dy, chan,\n                                                                          boundarys,\n                                                                          rowstride) +\n                                     Ky[7] * get_interp_pixel (I, x, y + dy, chan,\n                                                                          boundarys,\n                                                                          rowstride) +\n                                     Ky[8] * get_interp_pixel (I, x + dx, y + dy, chan,\n                                                                          boundarys,\n                                                                          rowstride))) / 255.0;\n\n    output.x = Nx;\n    output.y = Ny;\n\n    output.z = 1;\n    output = normalise (output);\n    return output;\n}\n\ntypedef enum {\n    DISTANTLIGHT, POINTLIGHT, SPOTLIGHT\n} lightType;\n\ntypedef struct _RsvgNodeLightSource RsvgNodeLightSource;\n\nstruct _RsvgNodeLightSource {\n    lightType type;\n    gdouble azimuth;\n    gdouble elevation;\n    RsvgLength x, y, z, pointsAtX, pointsAtY, pointsAtZ;\n    gdouble specularExponent;\n    gdouble limitingconeAngle;\n};\n\nstatic vector3\nget_light_direction (RsvgNodeLightSource * source, gdouble x1, gdouble y1, gdouble z,\n                     cairo_matrix_t *affine, RsvgDrawingCtx * ctx)\n{\n    vector3 output;\n\n    switch (source->type) {\n    case DISTANTLIGHT:\n        output.x = cos (source->azimuth) * cos (source->elevation);\n        output.y = sin (source->azimuth) * cos (source->elevation);\n        output.z = sin (source->elevation);\n        break;\n    default:\n        {\n            double x, y;\n            x = affine->xx * x1 + affine->xy * y1 + affine->x0;\n            y = affine->yx * x1 + affine->yy * y1 + affine->y0;\n            output.x = rsvg_length_normalize (&source->x, ctx) - x;\n            output.y = rsvg_length_normalize (&source->y, ctx) - y;\n            output.z = rsvg_length_normalize (&source->z, ctx) - z;\n            output = normalise (output);\n        }\n        break;\n    }\n    return output;\n}\n\nstatic vector3\nget_light_color (RsvgNodeLightSource * source, vector3 color,\n                 gdouble x1, gdouble y1, gdouble z, cairo_matrix_t *affine, RsvgDrawingCtx * ctx)\n{\n    double base, angle, x, y;\n    vector3 s;\n    vector3 L;\n    vector3 output;\n    double sx, sy, sz, spx, spy, spz;\n\n    if (source->type != SPOTLIGHT)\n        return color;\n\n    sx = rsvg_length_normalize (&source->x, ctx);\n    sy = rsvg_length_normalize (&source->y, ctx);\n    sz = rsvg_length_normalize (&source->z, ctx);\n    spx = rsvg_length_normalize (&source->pointsAtX, ctx);\n    spy = rsvg_length_normalize (&source->pointsAtY, ctx);\n    spz = rsvg_length_normalize (&source->pointsAtZ, ctx);\n\n    x = affine->xx * x1 + affine->xy * y1 + affine->x0;\n    y = affine->yx * x1 + affine->yy * y1 + affine->y0;\n\n    L.x = sx - x;\n    L.y = sy - y;\n    L.z = sz - z;\n    L = normalise (L);\n\n    s.x = spx - sx;\n    s.y = spy - sy;\n    s.z = spz - sz;\n    s = normalise (s);\n\n    base = -dotproduct (L, s);\n\n    angle = acos (base);\n\n    if (base < 0 || angle > source->limitingconeAngle) {\n        output.x = 0;\n        output.y = 0;\n        output.z = 0;\n        return output;\n    }\n\n    output.x = color.x * pow (base, source->specularExponent);\n    output.y = color.y * pow (base, source->specularExponent);\n    output.z = color.z * pow (base, source->specularExponent);\n\n    return output;\n}\n\n\nstatic void\nrsvg_node_light_source_set_atts (RsvgNode *node, gpointer impl, RsvgHandle *handle, RsvgPropertyBag *atts)\n{\n    RsvgNodeLightSource *data = impl;\n    const char *value;\n\n    if ((value = rsvg_property_bag_lookup (atts, \"azimuth\")))\n        data->azimuth = g_ascii_strtod (value, NULL) / 180.0 * M_PI;\n    if ((value = rsvg_property_bag_lookup (atts, \"elevation\")))\n        data->elevation = g_ascii_strtod (value, NULL) / 180.0 * M_PI;\n    if ((value = rsvg_property_bag_lookup (atts, \"limitingConeAngle\")))\n        data->limitingconeAngle = g_ascii_strtod (value, NULL) / 180.0 * M_PI;\n    if ((value = rsvg_property_bag_lookup (atts, \"x\")))\n        data->x = data->pointsAtX = rsvg_length_parse (value, LENGTH_DIR_HORIZONTAL);\n    if ((value = rsvg_property_bag_lookup (atts, \"y\")))\n        data->y = data->pointsAtX = rsvg_length_parse (value, LENGTH_DIR_VERTICAL);\n    if ((value = rsvg_property_bag_lookup (atts, \"z\")))\n        data->z = data->pointsAtX = rsvg_length_parse (value, LENGTH_DIR_BOTH);\n    if ((value = rsvg_property_bag_lookup (atts, \"pointsAtX\")))\n        data->pointsAtX = rsvg_length_parse (value, LENGTH_DIR_HORIZONTAL);\n    if ((value = rsvg_property_bag_lookup (atts, \"pointsAtY\")))\n        data->pointsAtY = rsvg_length_parse (value, LENGTH_DIR_VERTICAL);\n    if ((value = rsvg_property_bag_lookup (atts, \"pointsAtZ\")))\n        data->pointsAtZ = rsvg_length_parse (value, LENGTH_DIR_BOTH);\n    if ((value = rsvg_property_bag_lookup (atts, \"specularExponent\")))\n        data->specularExponent = g_ascii_strtod (value, NULL);\n}\n\nRsvgNode *\nrsvg_new_node_light_source (const char *element_name, RsvgNode *parent)\n{\n    RsvgNodeLightSource *data;\n\n    data = g_new0 (RsvgNodeLightSource, 1);\n\n    data->specularExponent = 1;\n\n    if (strcmp (element_name, \"feDistantLight\") == 0)\n        data->type = SPOTLIGHT;\n    else if (strcmp (element_name, \"feSpotLight\") == 0)\n        data->type = DISTANTLIGHT;\n    else if (strcmp (element_name, \"fePointLight\") == 0)\n        data->type = POINTLIGHT;\n    else\n        g_assert_not_reached ();\n\n    data->limitingconeAngle = 180;\n\n    return rsvg_rust_cnode_new (RSVG_NODE_TYPE_LIGHT_SOURCE,\n                                parent,\n                                rsvg_state_new (),\n                                data,\n                                rsvg_node_light_source_set_atts,\n                                rsvg_filter_draw,\n                                g_free);                                \n}\n\n/*************************************************************/\n/*************************************************************/\n\ntypedef struct _RsvgFilterPrimitiveDiffuseLighting RsvgFilterPrimitiveDiffuseLighting;\n\nstruct _RsvgFilterPrimitiveDiffuseLighting {\n    RsvgFilterPrimitive super;\n    gdouble dx, dy;\n    double diffuseConstant;\n    double surfaceScale;\n    guint32 lightingcolor;\n};\n\nstruct find_light_source_closure {\n    RsvgNode *found_node;\n};\n\nstatic gboolean\nis_light_source (RsvgNode *node, gpointer data)\n{\n    struct find_light_source_closure *closure = data;\n\n    if (rsvg_node_get_type (node) == RSVG_NODE_TYPE_LIGHT_SOURCE) {\n        closure->found_node = rsvg_node_ref (node);\n    }\n\n    return TRUE;\n}\n\nstatic RsvgNodeLightSource *\nfind_light_source_in_children (RsvgNode *node)\n{\n    struct find_light_source_closure closure;\n    RsvgNodeLightSource *source;\n\n    closure.found_node = NULL;\n    rsvg_node_foreach_child (node, is_light_source, &closure);\n    if (closure.found_node == NULL)\n        return NULL;\n\n    g_assert (rsvg_node_get_type (closure.found_node) == RSVG_NODE_TYPE_LIGHT_SOURCE);\n\n    source = rsvg_rust_cnode_get_impl (closure.found_node);\n    closure.found_node = rsvg_node_unref (closure.found_node);\n\n    return source;\n}\n\nstatic void\nrsvg_filter_primitive_diffuse_lighting_render (RsvgNode *node, RsvgFilterPrimitive *primitive, RsvgFilterContext *ctx)\n{\n    RsvgFilterPrimitiveDiffuseLighting *diffuse_lighting = (RsvgFilterPrimitiveDiffuseLighting *) primitive;\n\n    gint x, y;\n    float dy, dx, rawdy, rawdx;\n    gdouble z;\n    gint rowstride, height, width;\n    gdouble factor, surfaceScale;\n    vector3 lightcolor, L, N;\n    vector3 color;\n    cairo_matrix_t iaffine;\n    RsvgNodeLightSource *source = NULL;\n    RsvgIRect boundarys;\n\n    guchar *in_pixels;\n    guchar *output_pixels;\n\n    cairo_surface_t *output, *in;\n\n    source = find_light_source_in_children (node);\n    if (source == NULL)\n        return;\n\n    iaffine = ctx->paffine;\n    if (cairo_matrix_invert (&iaffine) != CAIRO_STATUS_SUCCESS)\n      return;\n\n    boundarys = rsvg_filter_primitive_get_bounds (primitive, ctx);\n\n    in = rsvg_filter_get_in (primitive->in, ctx);\n    if (in == NULL)\n        return;\n\n    cairo_surface_flush (in);\n\n    in_pixels = cairo_image_surface_get_data (in);\n\n    height = cairo_image_surface_get_height (in);\n    width = cairo_image_surface_get_width (in);\n\n    rowstride = cairo_image_surface_get_stride (in);\n\n    output = _rsvg_image_surface_new (width, height);\n    if (output == NULL) {\n        cairo_surface_destroy (in);\n        return;\n    }\n\n    output_pixels = cairo_image_surface_get_data (output);\n\n    color.x = ((guchar *) (&diffuse_lighting->lightingcolor))[2] / 255.0;\n    color.y = ((guchar *) (&diffuse_lighting->lightingcolor))[1] / 255.0;\n    color.z = ((guchar *) (&diffuse_lighting->lightingcolor))[0] / 255.0;\n\n    surfaceScale = diffuse_lighting->surfaceScale / 255.0;\n\n    if (diffuse_lighting->dy < 0 || diffuse_lighting->dx < 0) {\n        dx = 1;\n        dy = 1;\n        rawdx = 1;\n        rawdy = 1;\n    } else {\n        dx = diffuse_lighting->dx * ctx->paffine.xx;\n        dy = diffuse_lighting->dy * ctx->paffine.yy;\n        rawdx = diffuse_lighting->dx;\n        rawdy = diffuse_lighting->dy;\n    }\n\n    for (y = boundarys.y0; y < boundarys.y1; y++)\n        for (x = boundarys.x0; x < boundarys.x1; x++) {\n            z = surfaceScale * (double) in_pixels[y * rowstride + x * 4 + ctx->channelmap[3]];\n            L = get_light_direction (source, x, y, z, &iaffine, ctx->ctx);\n            N = get_surface_normal (in_pixels, boundarys, x, y,\n                                    dx, dy, rawdx, rawdy, diffuse_lighting->surfaceScale,\n                                    rowstride, ctx->channelmap[3]);\n            lightcolor = get_light_color (source, color, x, y, z, &iaffine, ctx->ctx);\n            factor = dotproduct (N, L);\n\n            output_pixels[y * rowstride + x * 4 + ctx->channelmap[0]] =\n                MAX (0, MIN (255, diffuse_lighting->diffuseConstant * factor * lightcolor.x * 255.0));\n            output_pixels[y * rowstride + x * 4 + ctx->channelmap[1]] =\n                MAX (0, MIN (255, diffuse_lighting->diffuseConstant * factor * lightcolor.y * 255.0));\n            output_pixels[y * rowstride + x * 4 + ctx->channelmap[2]] =\n                MAX (0, MIN (255, diffuse_lighting->diffuseConstant * factor * lightcolor.z * 255.0));\n            output_pixels[y * rowstride + x * 4 + ctx->channelmap[3]] = 255;\n        }\n\n    cairo_surface_mark_dirty (output);\n\n    rsvg_filter_store_result (primitive->result, output, ctx);\n\n    cairo_surface_destroy (in);\n    cairo_surface_destroy (output);\n}\n\nstatic void\nrsvg_filter_primitive_diffuse_lighting_set_atts (RsvgNode *node, gpointer impl, RsvgHandle *handle, RsvgPropertyBag *atts)\n{\n    RsvgFilterPrimitiveDiffuseLighting *filter = impl;\n    const char *value;\n    RsvgState *state;\n\n    if ((value = rsvg_property_bag_lookup (atts, \"in\")))\n        g_string_assign (filter->super.in, value);\n    if ((value = rsvg_property_bag_lookup (atts, \"result\")))\n        g_string_assign (filter->super.result, value);\n\n    filter_primitive_set_x_y_width_height_atts ((RsvgFilterPrimitive *) filter, atts);\n\n    if ((value = rsvg_property_bag_lookup (atts, \"kernelUnitLength\")))\n        rsvg_css_parse_number_optional_number (value, &filter->dx, &filter->dy);\n\n    if ((value = rsvg_property_bag_lookup (atts, \"lighting-color\"))) {\n        RsvgCssColorSpec spec;\n\n        spec = rsvg_css_parse_color (value, ALLOW_INHERIT_YES, ALLOW_CURRENT_COLOR_YES);\n\n        switch (spec.kind) {\n        case RSVG_CSS_COLOR_SPEC_INHERIT:\n            /* FIXME: we should inherit; see how stop-color is handled in rsvg-styles.c */\n            break;\n\n        case RSVG_CSS_COLOR_SPEC_CURRENT_COLOR:\n            state = rsvg_state_new ();\n            rsvg_state_reconstruct (state, node);\n            filter->lightingcolor = state->current_color;\n            break;\n\n        case RSVG_CSS_COLOR_SPEC_ARGB:\n            filter->lightingcolor = spec.argb;\n            break;\n\n        case RSVG_CSS_COLOR_PARSE_ERROR:\n            rsvg_node_set_attribute_parse_error (node, \"lighting-color\", \"Invalid color\");\n            break;\n\n        default:\n            g_assert_not_reached ();\n        }\n    }\n\n    if ((value = rsvg_property_bag_lookup (atts, \"diffuseConstant\")))\n        filter->diffuseConstant = g_ascii_strtod (value, NULL);\n    if ((value = rsvg_property_bag_lookup (atts, \"surfaceScale\")))\n        filter->surfaceScale = g_ascii_strtod (value, NULL);\n}\n\nRsvgNode *\nrsvg_new_filter_primitive_diffuse_lighting (const char *element_name, RsvgNode *parent)\n{\n    RsvgFilterPrimitiveDiffuseLighting *filter;\n\n    filter = g_new0 (RsvgFilterPrimitiveDiffuseLighting, 1);\n    filter->super.in = g_string_new (\"none\");\n    filter->super.result = g_string_new (\"none\");\n    filter->surfaceScale = 1;\n    filter->diffuseConstant = 1;\n    filter->dx = 1;\n    filter->dy = 1;\n    filter->lightingcolor = 0xFFFFFFFF;\n    filter->super.render = rsvg_filter_primitive_diffuse_lighting_render;\n\n    return rsvg_rust_cnode_new (RSVG_NODE_TYPE_FILTER_PRIMITIVE_DIFFUSE_LIGHTING,\n                                parent,\n                                rsvg_state_new (),\n                                filter,\n                                rsvg_filter_primitive_diffuse_lighting_set_atts,\n                                rsvg_filter_draw,\n                                rsvg_filter_primitive_free);\n}\n\n/*************************************************************/\n/*************************************************************/\n\ntypedef struct _RsvgFilterPrimitiveSpecularLighting RsvgFilterPrimitiveSpecularLighting;\n\nstruct _RsvgFilterPrimitiveSpecularLighting {\n    RsvgFilterPrimitive super;\n    double specularConstant;\n    double specularExponent;\n    double surfaceScale;\n    guint32 lightingcolor;\n};\n\nstatic void\nrsvg_filter_primitive_specular_lighting_render (RsvgNode *node, RsvgFilterPrimitive *primitive, RsvgFilterContext *ctx)\n{\n    RsvgFilterPrimitiveSpecularLighting *specular_lighting = (RsvgFilterPrimitiveSpecularLighting *) primitive;\n\n    gint x, y;\n    gdouble z, surfaceScale;\n    gint rowstride, height, width;\n    gdouble factor, max, base;\n    vector3 lightcolor, color;\n    vector3 L;\n    cairo_matrix_t iaffine;\n    RsvgIRect boundarys;\n    RsvgNodeLightSource *source = NULL;\n\n    guchar *in_pixels;\n    guchar *output_pixels;\n\n    cairo_surface_t *output, *in;\n\n    source = find_light_source_in_children (node);\n    if (source == NULL)\n        return;\n\n    iaffine = ctx->paffine;\n    if (cairo_matrix_invert (&iaffine) != CAIRO_STATUS_SUCCESS)\n      return;\n\n    boundarys = rsvg_filter_primitive_get_bounds (primitive, ctx);\n\n    in = rsvg_filter_get_in (primitive->in, ctx);\n    if (in == NULL)\n        return;\n\n    cairo_surface_flush (in);\n\n    in_pixels = cairo_image_surface_get_data (in);\n\n    height = cairo_image_surface_get_height (in);\n    width = cairo_image_surface_get_width (in);\n\n    rowstride = cairo_image_surface_get_stride (in);\n\n    output = _rsvg_image_surface_new (width, height);\n    if (output == NULL) {\n        cairo_surface_destroy (in);\n        return;\n    }\n\n    output_pixels = cairo_image_surface_get_data (output);\n\n    color.x = ((guchar *) (&specular_lighting->lightingcolor))[2] / 255.0;\n    color.y = ((guchar *) (&specular_lighting->lightingcolor))[1] / 255.0;\n    color.z = ((guchar *) (&specular_lighting->lightingcolor))[0] / 255.0;\n\n    surfaceScale = specular_lighting->surfaceScale / 255.0;\n\n    for (y = boundarys.y0; y < boundarys.y1; y++)\n        for (x = boundarys.x0; x < boundarys.x1; x++) {\n            z = in_pixels[y * rowstride + x * 4 + 3] * surfaceScale;\n            L = get_light_direction (source, x, y, z, &iaffine, ctx->ctx);\n            L.z += 1;\n            L = normalise (L);\n\n            lightcolor = get_light_color (source, color, x, y, z, &iaffine, ctx->ctx);\n            base = dotproduct (get_surface_normal (in_pixels, boundarys, x, y,\n                                                   1, 1, 1.0 / ctx->paffine.xx,\n                                                   1.0 / ctx->paffine.yy, specular_lighting->surfaceScale,\n                                                   rowstride, ctx->channelmap[3]), L);\n\n            factor = specular_lighting->specularConstant * pow (base, specular_lighting->specularExponent) * 255;\n\n            max = 0;\n            if (max < lightcolor.x)\n                max = lightcolor.x;\n            if (max < lightcolor.y)\n                max = lightcolor.y;\n            if (max < lightcolor.z)\n                max = lightcolor.z;\n\n            max *= factor;\n            if (max > 255)\n                max = 255;\n            if (max < 0)\n                max = 0;\n\n            output_pixels[y * rowstride + x * 4 + ctx->channelmap[0]] = lightcolor.x * max;\n            output_pixels[y * rowstride + x * 4 + ctx->channelmap[1]] = lightcolor.y * max;\n            output_pixels[y * rowstride + x * 4 + ctx->channelmap[2]] = lightcolor.z * max;\n            output_pixels[y * rowstride + x * 4 + ctx->channelmap[3]] = max;\n\n        }\n\n    cairo_surface_mark_dirty (output);\n\n    rsvg_filter_store_result (primitive->result, output, ctx);\n\n    cairo_surface_destroy (in);\n    cairo_surface_destroy (output);\n}\n\nstatic void\nrsvg_filter_primitive_specular_lighting_set_atts (RsvgNode *node, gpointer impl, RsvgHandle *handle, RsvgPropertyBag *atts)\n{\n    RsvgFilterPrimitiveSpecularLighting *filter = impl;\n    const char *value;\n\n    if ((value = rsvg_property_bag_lookup (atts, \"in\")))\n        g_string_assign (filter->super.in, value);\n    if ((value = rsvg_property_bag_lookup (atts, \"result\")))\n        g_string_assign (filter->super.result, value);\n\n    filter_primitive_set_x_y_width_height_atts ((RsvgFilterPrimitive *) filter, atts);\n\n    if ((value = rsvg_property_bag_lookup (atts, \"lighting-color\"))) {\n        RsvgCssColorSpec spec;\n        RsvgState *state;\n\n        spec = rsvg_css_parse_color (value, ALLOW_INHERIT_YES, ALLOW_CURRENT_COLOR_YES);\n\n        switch (spec.kind) {\n        case RSVG_CSS_COLOR_SPEC_INHERIT:\n            /* FIXME: we should inherit; see how stop-color is handled in rsvg-styles.c */\n            break;\n\n        case RSVG_CSS_COLOR_SPEC_CURRENT_COLOR:\n            state = rsvg_state_new ();\n            rsvg_state_reconstruct (state, node);\n            filter->lightingcolor = state->current_color;\n            break;\n\n        case RSVG_CSS_COLOR_SPEC_ARGB:\n            filter->lightingcolor = spec.argb;\n            break;\n\n        case RSVG_CSS_COLOR_PARSE_ERROR:\n            rsvg_node_set_attribute_parse_error (node, \"lighting-color\", \"Invalid color\");\n            break;\n\n        default:\n            g_assert_not_reached ();\n        }\n    }\n\n    if ((value = rsvg_property_bag_lookup (atts, \"specularConstant\")))\n        filter->specularConstant = g_ascii_strtod (value, NULL);\n    if ((value = rsvg_property_bag_lookup (atts, \"specularExponent\")))\n        filter->specularExponent = g_ascii_strtod (value, NULL);\n    if ((value = rsvg_property_bag_lookup (atts, \"surfaceScale\")))\n        filter->surfaceScale = g_ascii_strtod (value, NULL);\n}\n\nRsvgNode *\nrsvg_new_filter_primitive_specular_lighting (const char *element_name, RsvgNode *parent)\n{\n    RsvgFilterPrimitiveSpecularLighting *filter;\n\n    filter = g_new0 (RsvgFilterPrimitiveSpecularLighting, 1);\n    filter->super.in = g_string_new (\"none\");\n    filter->super.result = g_string_new (\"none\");\n    filter->surfaceScale = 1;\n    filter->specularConstant = 1;\n    filter->specularExponent = 1;\n    filter->lightingcolor = 0xFFFFFFFF;\n    filter->super.render = rsvg_filter_primitive_specular_lighting_render;\n\n    return rsvg_rust_cnode_new (RSVG_NODE_TYPE_FILTER_PRIMITIVE_SPECULAR_LIGHTING,\n                                parent,\n                                rsvg_state_new (),\n                                filter,\n                                rsvg_filter_primitive_specular_lighting_set_atts,\n                                rsvg_filter_draw,\n                                rsvg_filter_primitive_free);\n}\n\n/*************************************************************/\n/*************************************************************/\n\ntypedef struct _RsvgFilterPrimitiveTile RsvgFilterPrimitiveTile;\n\nstruct _RsvgFilterPrimitiveTile {\n    RsvgFilterPrimitive super;\n};\n\nstatic int\nmod (int a, int b)\n{\n    while (a < 0)\n        a += b;\n    return a % b;\n}\n\nstatic void\nrsvg_filter_primitive_tile_render (RsvgNode *node, RsvgFilterPrimitive *primitive, RsvgFilterContext *ctx)\n{\n    guchar i;\n    gint x, y, rowstride;\n    RsvgIRect boundarys, oboundarys;\n\n    RsvgFilterPrimitiveOutput input;\n\n    guchar *in_pixels;\n    guchar *output_pixels;\n\n    cairo_surface_t *output, *in;\n\n    oboundarys = rsvg_filter_primitive_get_bounds (primitive, ctx);\n\n    input = rsvg_filter_get_result (primitive->in, ctx);\n    in = input.surface;\n    boundarys = input.bounds;\n\n    cairo_surface_flush (in);\n\n    in_pixels = cairo_image_surface_get_data (in);\n\n    output = _rsvg_image_surface_new (ctx->width, ctx->height);\n    if (output == NULL) {\n        cairo_surface_destroy (in);\n        return;\n    }\n\n    rowstride = cairo_image_surface_get_stride (output);\n\n    output_pixels = cairo_image_surface_get_data (output);\n\n    for (y = oboundarys.y0; y < oboundarys.y1; y++)\n        for (x = oboundarys.x0; x < oboundarys.x1; x++)\n            for (i = 0; i < 4; i++) {\n                output_pixels[4 * x + y * rowstride + i] =\n                    in_pixels[(mod ((x - boundarys.x0), (boundarys.x1 - boundarys.x0)) +\n                               boundarys.x0) * 4 +\n                              (mod ((y - boundarys.y0), (boundarys.y1 - boundarys.y0)) +\n                               boundarys.y0) * rowstride + i];\n            }\n\n    cairo_surface_mark_dirty (output);\n\n    rsvg_filter_store_result (primitive->result, output, ctx);\n\n    cairo_surface_destroy (in);\n    cairo_surface_destroy (output);\n}\n\nstatic void\nrsvg_filter_primitive_tile_set_atts (RsvgNode *node, gpointer impl, RsvgHandle *handle, RsvgPropertyBag *atts)\n{\n    RsvgFilterPrimitiveTile *filter = impl;\n    const char *value;\n\n    if ((value = rsvg_property_bag_lookup (atts, \"in\")))\n        g_string_assign (filter->super.in, value);\n    if ((value = rsvg_property_bag_lookup (atts, \"result\")))\n        g_string_assign (filter->super.result, value);\n\n    filter_primitive_set_x_y_width_height_atts ((RsvgFilterPrimitive *) filter, atts);\n}\n\nRsvgNode *\nrsvg_new_filter_primitive_tile (const char *element_name, RsvgNode *parent)\n{\n    RsvgFilterPrimitiveTile *filter;\n\n    filter = g_new0 (RsvgFilterPrimitiveTile, 1);\n    filter->super.in = g_string_new (\"none\");\n    filter->super.result = g_string_new (\"none\");\n    filter->super.render = rsvg_filter_primitive_tile_render;\n\n    return rsvg_rust_cnode_new (RSVG_NODE_TYPE_FILTER_PRIMITIVE_TILE,\n                                parent,\n                                rsvg_state_new (),\n                                filter,\n                                rsvg_filter_primitive_tile_set_atts,\n                                rsvg_filter_draw,\n                                rsvg_filter_primitive_free);\n}\n"], "filenames": ["rsvg-filter.c"], "buggy_code_start_loc": [1419], "buggy_code_end_loc": [1902], "fixing_code_start_loc": [1420], "fixing_code_end_loc": [1914], "type": "CWE-369", "message": "A SIGFPE is raised in the function box_blur_line of rsvg-filter.c in GNOME librsvg 2.40.17 during an attempted parse of a crafted SVG file, because of incorrect protection against division by zero.", "other": {"cve": {"id": "CVE-2017-11464", "sourceIdentifier": "cve@mitre.org", "published": "2017-07-19T21:29:00.197", "lastModified": "2020-07-28T22:15:11.897", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "A SIGFPE is raised in the function box_blur_line of rsvg-filter.c in GNOME librsvg 2.40.17 during an attempted parse of a crafted SVG file, because of incorrect protection against division by zero."}, {"lang": "es", "value": "Un SIGFPE se genera en la funci\u00f3n box_blur_line del archivo rsvg-filter.c en GNOME librsvg versi\u00f3n 2.40.17 durante un intento de an\u00e1lisis de un archivo SVG creado, debido a la protecci\u00f3n incorrecta contra la divisi\u00f3n por cero."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-369"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:gnome:librsvg:2.40.17:*:*:*:*:*:*:*", "matchCriteriaId": "87A5C854-983B-42B9-AF52-7D8F62549768"}]}]}], "references": [{"url": "http://www.securityfocus.com/bid/99956", "source": "cve@mitre.org"}, {"url": "https://bugzilla.gnome.org/show_bug.cgi?id=783835", "source": "cve@mitre.org", "tags": ["Permissions Required"]}, {"url": "https://git.gnome.org/browse/librsvg/commit/?id=ecf9267a24b2c3c0cd211dbdfa9ef2232511972a", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/GNOME/librsvg/commit/ecf9267a24b2c3c0cd211dbdfa9ef2232511972a", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/07/msg00016.html", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/4436-1/", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/GNOME/librsvg/commit/ecf9267a24b2c3c0cd211dbdfa9ef2232511972a"}}