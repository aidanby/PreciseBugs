{"buggy_code": ["import { body, validationResult } from 'express-validator';\n\n// form rules\nexport const registerRules = () => {\n  return [\n    body('registerForm.username')\n      .matches(/^[\\da-zA-Z\\-_.]+$/)\n      .withMessage('Username has invalid characters')\n      .not()\n      .isEmpty()\n      .withMessage('Username field is required'),\n    body('registerForm.name').not().isEmpty().withMessage('Name field is required'),\n    body('registerForm.email')\n      .isEmail()\n      .withMessage('Email format is invalid.')\n      .exists()\n      .withMessage('Email field is required.'),\n    body('registerForm.password')\n      .matches(/^[\\x20-\\x7F]*$/)\n      .withMessage('Password has invalid character')\n      .isLength({ min: 6 })\n      .withMessage('Password minimum character should be more than 6 characters')\n      .not()\n      .isEmpty()\n      .withMessage('Password field is required'),\n    body('registerForm[app:globalLang]'),\n  ];\n};\n\n// validation action\nexport const registerValidation = (req, res, next) => {\n  const form = req.body;\n\n  const errors = validationResult(req);\n  if (errors.isEmpty()) {\n    Object.assign(form, { isValid: true });\n    req.form = form;\n    return next();\n  }\n\n  const extractedErrors: string[] = [];\n  errors.array().map(err => extractedErrors.push(err.msg));\n\n  Object.assign(form, {\n    isValid: false,\n    errors: extractedErrors,\n  });\n  req.form = form;\n\n  return next();\n};\n", "import path from 'path';\nimport * as express from 'express';\nimport { body, validationResult } from 'express-validator';\nimport ErrorV3 from '../../models/vo/error-apiv3';\n\n// validation rules for complete registration form\nexport const completeRegistrationRules = () => {\n  return [\n    body('username')\n      .matches(/^[\\da-zA-Z\\-_.]+$/)\n      .withMessage('Username has invalid characters')\n      .not()\n      .isEmpty()\n      .withMessage('Username field is required'),\n    body('name').not().isEmpty().withMessage('Name field is required'),\n    body('token').not().isEmpty().withMessage('Token value is required'),\n    body('password')\n      .matches(/^[\\x20-\\x7F]*$/)\n      .withMessage('Password has invalid character')\n      .isLength({ min: 6 })\n      .withMessage('Password minimum character should be more than 6 characters')\n      .not()\n      .isEmpty()\n      .withMessage('Password field is required'),\n  ];\n};\n\n// middleware to validate complete registration form\nexport const validateCompleteRegistration = (req, res, next) => {\n  const errors = validationResult(req);\n  if (errors.isEmpty()) {\n    return next();\n  }\n\n  const extractedErrors: string[] = [];\n  errors.array().map(err => extractedErrors.push(err.msg));\n\n  return res.apiv3Err(extractedErrors);\n};\n\nasync function sendEmailToAllAdmins(userData, admins, appTitle, mailService, template, url) {\n  const promises = admins.map((admin) => {\n    return mailService.send({\n      to: admin.email,\n      subject: `[${appTitle}:admin] A New User Created and Waiting for Activation`,\n      template,\n      vars: {\n        createdUser: userData,\n        admin,\n        url,\n        appTitle,\n      },\n    });\n  });\n}\n\nexport const completeRegistrationAction = (crowi) => {\n  const User = crowi.model('User');\n  const {\n    configManager,\n    aclService,\n    appService,\n    mailService,\n  } = crowi;\n\n  return async function(req, res) {\n    if (req.user != null) {\n      return res.apiv3Err(new ErrorV3('You have been logged in', 'registration-failed'), 403);\n    }\n\n    // config \u3067 closed \u306a\u3089\u3055\u3088\u306a\u3089\n    if (configManager.getConfig('crowi', 'security:registrationMode') === aclService.labels.SECURITY_REGISTRATION_MODE_CLOSED) {\n      return res.apiv3Err(new ErrorV3('Registration closed', 'registration-failed'), 403);\n    }\n\n    const { userRegistrationOrder } = req;\n    const registerForm = req.body;\n\n    const email = userRegistrationOrder.email;\n    const name = registerForm.name;\n    const username = registerForm.username;\n    const password = registerForm.password;\n\n    // email \u3068 username \u306e unique \u30c1\u30a7\u30c3\u30af\u3059\u308b\n    User.isRegisterable(email, username, (isRegisterable, errOn) => {\n      let isError = false;\n      let errorMessage = '';\n      if (!User.isEmailValid(email)) {\n        isError = true;\n        errorMessage += req.t('message.email_address_could_not_be_used');\n      }\n      if (!isRegisterable) {\n        if (!errOn.username) {\n          isError = true;\n          errorMessage += req.t('message.user_id_is_not_available');\n        }\n        if (!errOn.email) {\n          isError = true;\n          errorMessage += req.t('message.email_address_is_already_registered');\n        }\n      }\n      if (isError) {\n        return res.apiv3Err(new ErrorV3(errorMessage, 'registration-failed'), 403);\n      }\n\n      if (configManager.getConfig('crowi', 'security:passport-local:isEmailAuthenticationEnabled') === true) {\n        User.createUserByEmailAndPassword(name, username, email, password, undefined, async(err, userData) => {\n          if (err) {\n            if (err.name === 'UserUpperLimitException') {\n              errorMessage = req.t('message.can_not_register_maximum_number_of_users');\n            }\n            else {\n              errorMessage = req.t('message.failed_to_register');\n            }\n            return res.apiv3Err(new ErrorV3(errorMessage, 'registration-failed'), 403);\n          }\n\n          userRegistrationOrder.revokeOneTimeToken();\n\n          if (configManager.getConfig('crowi', 'security:registrationMode') !== aclService.labels.SECURITY_REGISTRATION_MODE_RESTRICTED) {\n            const admins = await User.findAdmins();\n            const appTitle = appService.getAppTitle();\n            const template = path.join(crowi.localeDir, 'en_US/admin/userWaitingActivation.txt');\n            const url = appService.getSiteUrl();\n\n            sendEmailToAllAdmins(userData, admins, appTitle, mailService, template, url);\n          }\n\n          req.flash('successMessage', req.t('message.successfully_created', { username }));\n          res.apiv3({ status: 'ok' });\n        });\n      }\n      else {\n        return res.apiv3Err(new ErrorV3('Email authentication configuration is disabled', 'registration-failed'), 403);\n      }\n    });\n  };\n};\n"], "fixing_code": ["import { body, validationResult } from 'express-validator';\n\nconst PASSOWRD_MINIMUM_NUMBER = 8;\n// form rules\nexport const registerRules = () => {\n  return [\n    body('registerForm.username')\n      .matches(/^[\\da-zA-Z\\-_.]+$/)\n      .withMessage('Username has invalid characters')\n      .not()\n      .isEmpty()\n      .withMessage('Username field is required'),\n    body('registerForm.name').not().isEmpty().withMessage('Name field is required'),\n    body('registerForm.email')\n      .isEmail()\n      .withMessage('Email format is invalid.')\n      .exists()\n      .withMessage('Email field is required.'),\n    body('registerForm.password')\n      .matches(/^[\\x20-\\x7F]*$/)\n      .withMessage('Password has invalid character')\n      .isLength({ min: PASSOWRD_MINIMUM_NUMBER })\n      .withMessage('Password minimum character should be more than 8 characters')\n      .not()\n      .isEmpty()\n      .withMessage('Password field is required'),\n    body('registerForm[app:globalLang]'),\n  ];\n};\n\n// validation action\nexport const registerValidation = (req, res, next) => {\n  const form = req.body;\n\n  const errors = validationResult(req);\n  if (errors.isEmpty()) {\n    Object.assign(form, { isValid: true });\n    req.form = form;\n    return next();\n  }\n\n  const extractedErrors: string[] = [];\n  errors.array().map(err => extractedErrors.push(err.msg));\n\n  Object.assign(form, {\n    isValid: false,\n    errors: extractedErrors,\n  });\n  req.form = form;\n\n  return next();\n};\n", "import path from 'path';\nimport * as express from 'express';\nimport { body, validationResult } from 'express-validator';\nimport ErrorV3 from '../../models/vo/error-apiv3';\n\nconst PASSOWRD_MINIMUM_NUMBER = 8;\n// validation rules for complete registration form\nexport const completeRegistrationRules = () => {\n  return [\n    body('username')\n      .matches(/^[\\da-zA-Z\\-_.]+$/)\n      .withMessage('Username has invalid characters')\n      .not()\n      .isEmpty()\n      .withMessage('Username field is required'),\n    body('name').not().isEmpty().withMessage('Name field is required'),\n    body('token').not().isEmpty().withMessage('Token value is required'),\n    body('password')\n      .matches(/^[\\x20-\\x7F]*$/)\n      .withMessage('Password has invalid character')\n      .isLength({ min: PASSOWRD_MINIMUM_NUMBER })\n      .withMessage('Password minimum character should be more than 8 characters')\n      .not()\n      .isEmpty()\n      .withMessage('Password field is required'),\n  ];\n};\n\n// middleware to validate complete registration form\nexport const validateCompleteRegistration = (req, res, next) => {\n  const errors = validationResult(req);\n  if (errors.isEmpty()) {\n    return next();\n  }\n\n  const extractedErrors: string[] = [];\n  errors.array().map(err => extractedErrors.push(err.msg));\n\n  return res.apiv3Err(extractedErrors);\n};\n\nasync function sendEmailToAllAdmins(userData, admins, appTitle, mailService, template, url) {\n  const promises = admins.map((admin) => {\n    return mailService.send({\n      to: admin.email,\n      subject: `[${appTitle}:admin] A New User Created and Waiting for Activation`,\n      template,\n      vars: {\n        createdUser: userData,\n        admin,\n        url,\n        appTitle,\n      },\n    });\n  });\n}\n\nexport const completeRegistrationAction = (crowi) => {\n  const User = crowi.model('User');\n  const {\n    configManager,\n    aclService,\n    appService,\n    mailService,\n  } = crowi;\n\n  return async function(req, res) {\n    if (req.user != null) {\n      return res.apiv3Err(new ErrorV3('You have been logged in', 'registration-failed'), 403);\n    }\n\n    // config \u3067 closed \u306a\u3089\u3055\u3088\u306a\u3089\n    if (configManager.getConfig('crowi', 'security:registrationMode') === aclService.labels.SECURITY_REGISTRATION_MODE_CLOSED) {\n      return res.apiv3Err(new ErrorV3('Registration closed', 'registration-failed'), 403);\n    }\n\n    const { userRegistrationOrder } = req;\n    const registerForm = req.body;\n\n    const email = userRegistrationOrder.email;\n    const name = registerForm.name;\n    const username = registerForm.username;\n    const password = registerForm.password;\n\n    // email \u3068 username \u306e unique \u30c1\u30a7\u30c3\u30af\u3059\u308b\n    User.isRegisterable(email, username, (isRegisterable, errOn) => {\n      let isError = false;\n      let errorMessage = '';\n      if (!User.isEmailValid(email)) {\n        isError = true;\n        errorMessage += req.t('message.email_address_could_not_be_used');\n      }\n      if (!isRegisterable) {\n        if (!errOn.username) {\n          isError = true;\n          errorMessage += req.t('message.user_id_is_not_available');\n        }\n        if (!errOn.email) {\n          isError = true;\n          errorMessage += req.t('message.email_address_is_already_registered');\n        }\n      }\n      if (isError) {\n        return res.apiv3Err(new ErrorV3(errorMessage, 'registration-failed'), 403);\n      }\n\n      if (configManager.getConfig('crowi', 'security:passport-local:isEmailAuthenticationEnabled') === true) {\n        User.createUserByEmailAndPassword(name, username, email, password, undefined, async(err, userData) => {\n          if (err) {\n            if (err.name === 'UserUpperLimitException') {\n              errorMessage = req.t('message.can_not_register_maximum_number_of_users');\n            }\n            else {\n              errorMessage = req.t('message.failed_to_register');\n            }\n            return res.apiv3Err(new ErrorV3(errorMessage, 'registration-failed'), 403);\n          }\n\n          userRegistrationOrder.revokeOneTimeToken();\n\n          if (configManager.getConfig('crowi', 'security:registrationMode') !== aclService.labels.SECURITY_REGISTRATION_MODE_RESTRICTED) {\n            const admins = await User.findAdmins();\n            const appTitle = appService.getAppTitle();\n            const template = path.join(crowi.localeDir, 'en_US/admin/userWaitingActivation.txt');\n            const url = appService.getSiteUrl();\n\n            sendEmailToAllAdmins(userData, admins, appTitle, mailService, template, url);\n          }\n\n          req.flash('successMessage', req.t('message.successfully_created', { username }));\n          res.apiv3({ status: 'ok' });\n        });\n      }\n      else {\n        return res.apiv3Err(new ErrorV3('Email authentication configuration is disabled', 'registration-failed'), 403);\n      }\n    });\n  };\n};\n"], "filenames": ["packages/app/src/server/middlewares/register-form-validator.ts", "packages/app/src/server/routes/apiv3/user-activation.ts"], "buggy_code_start_loc": [2, 5], "buggy_code_end_loc": [23, 22], "fixing_code_start_loc": [3, 6], "fixing_code_end_loc": [24, 23], "type": "CWE-521", "message": "Weak Password Requirements in GitHub repository weseek/growi prior to v5.0.0.", "other": {"cve": {"id": "CVE-2022-1236", "sourceIdentifier": "security@huntr.dev", "published": "2022-04-05T09:15:07.770", "lastModified": "2022-04-13T17:10:37.087", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Weak Password Requirements in GitHub repository weseek/growi prior to v5.0.0."}, {"lang": "es", "value": "Unos Requisitos D\u00e9biles de la Contrase\u00f1a en el repositorio de GitHub weseek/growi versiones anteriores a v5.0.0"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 2.5}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 6.4}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-521"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:weseek:growi:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.0.0", "matchCriteriaId": "7790B31F-6B88-4198-BDC5-282E4D675869"}]}]}], "references": [{"url": "https://github.com/weseek/growi/commit/b584e2a47ee3c8ce1d8ef38238302825c015327e", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/c7df088f-e355-45e6-9267-e41030dc6a32", "source": "security@huntr.dev", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/weseek/growi/commit/b584e2a47ee3c8ce1d8ef38238302825c015327e"}}