{"buggy_code": ["#\n# Copyright (c) 2006, 2007 Michael Schroeder, Novell Inc.\n#\n# This program is free software; you can redistribute it and/or modify\n# it under the terms of the GNU General Public License version 2 as\n# published by the Free Software Foundation.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program (see the file COPYING); if not, write to the\n# Free Software Foundation, Inc.,\n# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA\n#\n################################################################\n#\n# HTTP protocol functions. Also contains file/cpio sender/receiver.\n#\n\npackage BSHTTP;\n\nuse POSIX;\nuse Digest::MD5 ();\nuse Fcntl qw(:DEFAULT);\nBEGIN { Fcntl->import(':seek') unless defined &SEEK_SET; }\n\nuse strict;\n\n=head1 NAME\n\nBSHTTP\n\n=cut\n\n=head1 SYNOPSIS\n\n TODO\n\n=cut\n\n=head1 DESCRIPTION\n\nThis library contains functions to handle http requests in obs\n\n=cut\n\n=head1 FUNCTIONS / METHODS\n\n=cut\n\n\nsub gethead {\n  my ($h, $t) = @_;\n\n  my ($field, $data);\n  for (split(/[\\r\\n]+/, $t)) {\n    next if $_ eq '';\n    if (/^[ \\t]/s) {\n      s/^\\s*/ /s;\n      $h->{$field} .= $_ if defined $field;\n    } else {\n      ($field, $data) = split(/\\s*:\\s*/, $_, 2);\n      $field =~ tr/A-Z/a-z/;\n      $h->{$field} = $h->{$field} && $h->{$field} ne '' ? \"$h->{$field},$data\" : $data;\n    }\n  }\n}\n\nsub unexpected_eof {\n  my ($req) = @_;\n  $req->{'__eof'} = 1 if $req;\n  die(\"unexpected EOF\\n\");\n}\n\n\n=head2 BSHTTP::read_data\n\nread data from socket, do chunk decoding if needed\n\n  my $ret = BSHTTP::read_data(\n    # request data\n    {\n      headers\t  => {\n\t\t\ttransfer-encoding => 'chunked'\n\t\t\tcontent-length\t  => ...\n\t\t     }, #\n      __socket\t  => <FILEHANDLE> , # filehandle to socket or opened file\n      __cl\t  => ...\t  , #\n      __data\n    },\n    $maxl,\t  # if undef read as much as you can\n    $exact,\t  # Boolean\n\t\t  # if 1 read maxl data\n\t\t  # if maxl == undef -> read to eof\n  );\n\n=cut\n\nsub read_data {\n  my ($req, $maxl, $exact) = @_;\n\n  my $ret = '';\n  my $hdr = $req->{'headers'} || {};\n  local *S = $req->{'__socket'};\n  if ($hdr->{'transfer-encoding'} && lc($hdr->{'transfer-encoding'}) eq 'chunked') {\n    my $cl = $req->{'__cl'} || 0;\n    if ($cl < 0) {\n      die(\"unexpected EOF\\n\") if $exact && defined($maxl) && length($ret) < $maxl;\n      return $ret;\n    }\n    my $qu = $req->{'__data'};\n    while (1) {\n      if (defined($maxl) && $maxl <= $cl) {\n\twhile(length($qu) < $maxl) {\n\t  my $r = sysread(S, $qu, 8192, length($qu));\n\t  unexpected_eof($req) if !$r && (defined($r) || ($! != POSIX::EINTR && $! != POSIX::EWOULDBLOCK));\n\t}\n\t$ret .= substr($qu, 0, $maxl);\n\t$req->{'__cl'} = $cl - $maxl;\n\t$req->{'__data'} = substr($qu, $maxl);\n\treturn $ret;\n      }\n      if ($cl) {\n\t# no maxl or maxl > cl, read full cl\n\twhile(length($qu) < $cl) {\n\t  my $r = sysread(S, $qu, 8192, length($qu));\n\t  unexpected_eof($req) if !$r && (defined($r) || ($! != POSIX::EINTR && $! != POSIX::EWOULDBLOCK));\n\t}\n\t$ret .= substr($qu, 0, $cl);\n\t$qu = substr($qu, $cl);\n\t$maxl -= $cl if defined $maxl;\n\t$cl = 0;\n\tif (!defined($maxl) && !$exact) { # no maxl, return every chunk\n\t  $req->{'__cl'} = $cl;\n\t  $req->{'__data'} = $qu;\n\t  return $ret;\n\t}\n      }\n      # reached end of chunk, prepare for next one\n      while ($qu !~ /\\r?\\n/s) {\n\tmy $r = sysread(S, $qu, 8192, length($qu));\n        unexpected_eof($req) if !$r && (defined($r) || ($! != POSIX::EINTR && $! != POSIX::EWOULDBLOCK));\n      }\n      if (substr($qu, 0, 1) eq \"\\n\") {\n\t$qu = substr($qu, 1);\n\tnext;\n      }\n      if (substr($qu, 0, 2) eq \"\\r\\n\") {\n\t$qu = substr($qu, 2);\n\tnext;\n      }\n      die(\"bad CHUNK data: $qu\\n\") unless $qu =~ /^([0-9a-fA-F]+)/;\n      $cl = hex($1);\n      die if $cl < 0;\n      $qu =~ s/^.*?\\r?\\n//s;\n      if ($cl == 0) {\n\t$req->{'__cl'} = -1;\t# mark EOF\n\t$req->{'__eof'} = 1;\n\tdie(\"unexpected EOF\\n\") if $exact && defined($maxl) && length($ret) < $maxl;\n\t# read trailer\n\t$qu = \"\\r\\n$qu\";\n\twhile ($qu !~ /\\n\\r?\\n/s) {\n\t  my $r = sysread(S, $qu, 8192, length($qu));\n\t  unexpected_eof($req) if !$r && (defined($r) || ($! != POSIX::EINTR && $! != POSIX::EWOULDBLOCK));\n\t}\n\t$qu =~ /^(.*?)\\n\\r?\\n/;\n\t# get trailing header\n\tgethead($hdr, length($1) >= 2 ? substr($1, 2) : '');\n\treturn $ret;\n      }\n    }\n  } else {\n    my $qu = $req->{'__data'};\n    my $cl = $req->{'__cl'};\n    $cl = $hdr->{'content-length'} unless defined $cl;\n    if (defined($cl) && (!defined($maxl) || $maxl > $cl)) {\n      die(\"unexpected EOF\\n\") if $exact && defined($maxl);\n      $maxl = $cl >= 0 ? $cl : 0;\n    }\n    while (!defined($maxl) || length($qu) < $maxl) {\n      my $m = ($maxl || 0) - length($qu);\n      $m = 8192 if $m < 8192;\n      my $r = sysread(S, $qu, $m, length($qu));\n      if (!$r &&  (defined($r) || ($! != POSIX::EINTR && $! != POSIX::EWOULDBLOCK))) {\n\t$req->{'__eof'} = 1;\n\tdie(\"unexpected EOF\\n\") if defined($cl) || ($exact && defined($maxl));\n\t$cl = $maxl = length($qu);\n      }\n    }\n    $cl -= $maxl if defined($cl);\n    $ret = substr($qu, 0, $maxl);\n    $req->{'__cl'} = $cl;\n    $req->{'__data'} = substr($qu, $maxl);\n    $req->{'__eof'} = 1 if defined($cl) && $cl == 0;\n    return $ret;\n  }\n}\n\nsub str2req {\n  my ($str) = @_;\n  my $req = {\n    '__data' => $str,\n    '__cl' => length($str),\n  };\n  return $req;\n}\n\nsub fd2req {\n  my ($fd) = @_;\n  my $req = {\n    '__data' => '',\n    '__socket' => $fd,\n    '__cl' => -s *$fd,\n  };\n  return $req;\n}\n\nsub null_receiver {\n  my ($req, $param) = @_;\n  1 while(read_data($req, 8192) ne '');\n  return '';\n}\n\nsub file_receiver {\n  my ($req, $param) = @_;\n\n  die(\"file_receiver: no filename\\n\") unless defined $param->{'filename'};\n  my $fn = $param->{'filename'};\n  my $withmd5 = $param->{'withmd5'};\n  local *F;\n  my $ctx;\n  $ctx = Digest::MD5->new if $withmd5;\n  open(F, '>', $fn) || die(\"$fn: $!\\n\");\n  my $size = 0;\n  while(1) {\n    my $s = read_data($req, 8192);\n    last if $s eq '';\n    (syswrite(F, $s) || 0) == length($s) || die(\"syswrite: $!\\n\");\n    $size += length($s);\n    $ctx->add($s) if $ctx;\n  }\n  close(F) || die(\"close: $!\\n\");\n  my $res = {size => $size};\n  $res->{'md5'} = $ctx->hexdigest if $ctx;\n  return $res;\n}\n\n\n=head2 BSHTTP::cpio_receiver\n\nTODO: add meaningful explanation\n\n  my $result = BSHTTP::cpio_receiver(\n    # options given to read_data\n    {\n      ... # SEE BSHTTP::read_data\n    },\n    # all parameters are optional\n    {\n      directory\t    => <STRING>        , # store files in given directory\n\t\t\t\t\t # (Otherwise data is stored in $result->[]\n      withmd5\t    => <BOOLEAN>       , #\n      acceptsubdirs => <BOOLEAN>       , #\n      createsubdirs => <BOOLEAN>       , #\n      accept\t    => <REGEX|CODEREF> , # Check included files\n\t\t\t\t\t # by regex or function\n      map\t    => <REGEX|CODEREF> , # Rename files\n\t\t\t\t\t # by regex or function\n      no_unlink\t    => <BOOLEAN>       , # Do not remove already existent\n\t\t\t\t\t # (sub)directories. Only relevant\n\t\t\t\t\t # if directory is given\n\t\t\t\t\t #\n      cpiopostfile  => ... , #\n    }\n  );\n\n  # returns an ArrayRef of HashRefs\n  # $result = [\n  #   {\n  #\tname\t  => <STRING>\t  , # filename\n  #\tsize\t  => ...\n  #\tmtime\t  => ...\t  ,\n  #\tmode\t  => ...\t  ,\n  #\tmd5\t  => <STRING>\t  , # md5 as hexdigest\n  #\t\t\t\t    # only if withmd5 was true\n  #\tdata\t  => <BINARYDATA> , # binary data from file\n  #\t\t\t\t    # only if no directory was given\n  #   },\n  #   {\n  #\t....\n  #   },\n  #   ....\n  # ];\n\n=cut\n\nsub cpio_receiver {\n  my ($req, $param) = @_;\n  my @res;\n  my $dn = $param->{'directory'};\n  my $withmd5 = $param->{'withmd5'};\n  local *F;\n  while(1) {\n    my $cpiohead = read_data($req, 110, 1);\n    die(\"cpio: not a 'SVR4 no CRC ascii' cpio\\n\") unless substr($cpiohead, 0, 6) eq '070701';\n    my $mode = hex(substr($cpiohead, 14, 8));\n    my $mtime = hex(substr($cpiohead, 46, 8));\n    my $size  = hex(substr($cpiohead, 54, 8));\n    if ($size == 0xffffffff) {\n      # build service length extension\n      $cpiohead .= read_data($req, 16, 1);\n      $size = hex(substr($cpiohead, 62, 8)) * 4294967296. + hex(substr($cpiohead, 70, 8));\n      substr($cpiohead, 62, 16) = '';\n    }\n    my $nsize = hex(substr($cpiohead, 94, 8));\n    die(\"ridiculous long filename\\n\") if $nsize > 8192;\n    my $nsizepad = $nsize;\n    $nsizepad += 4 - ($nsize + 2 & 3) if $nsize + 2 & 3;\n    my $name = read_data($req, $nsizepad, 1);\n    $name =~ s/\\0.*//s;\n    $name =~ s/^\\.\\///s;\n    my $sizepad = $size;\n    $sizepad += 4 - ($size % 4) if $size % 4;\n    last if !$size && $name eq 'TRAILER!!!';\n    if ($param->{'acceptsubdirs'} || $param->{'createsubdirs'}) {\n      die(\"cpio filename is illegal: $name\\n\") if \"/$name/\" =~ /\\/\\.{0,2}\\//s;\n    } else {\n      die(\"cpio filename contains a '/': $name\\n\") if $name =~ /\\//s;\n    }\n    die(\"cpio filename is '.' or '..'\\n\") if $name eq '.' || $name eq '..';\n    my $ent = {'name' => $name, 'size' => $size, 'mtime' => $mtime, 'mode' => $mode};\n    if ($param->{'accept'}) {\n      if (ref($param->{'accept'})) {\n\tdie(\"illegal file in cpio archive: $name\\n\") unless $param->{'accept'}->($param, $name, $ent);\n      } else {\n\tdie(\"illegal file in cpio archive: $name\\n\") unless $name =~ /$param->{'accept'}/;\n      }\n    }\n    if ($param->{'map'}) {\n      $ent->{'unmappedname'} = $name;\n      if (ref($param->{'map'})) {\n\t$ent->{'name'} = $name = $param->{'map'}->($param, $name);\n      } else {\n\t$ent->{'name'} = $name = \"$param->{'map'}$name\";\n      }\n    }\n    if (!defined($name)) {\n      # skip entry\n      while ($sizepad) {\n        my $m = $sizepad > 8192 ? 8192 : $sizepad;\n        read_data($req, $m, 1);\n        $sizepad -= $m;\n      }\n      next;\n    }\n    push @res, $ent;\n    my $ctx;\n    $ctx = Digest::MD5->new if $withmd5;\n    if (defined($dn)) {\n      my $filename = \"$dn/$name\";\n      if (($mode & 0xf000) == 0x4000 && $param->{'createsubdirs'}) {\n\tdie(\"directory has non-zero size\\n\") if $sizepad;\n\tif (! -d $filename) {\n\t  unlink($filename) unless $param->{'no_unlink'};\n\t  mkdir($filename) || die(\"mkdir $filename: $!\\n\");\n\t}\n      } else {\n\tdie(\"can only unpack plain files from cpio archive, file $name, mode was $mode\\n\") unless ($mode & 0xf000) == 0x8000;\n\tunlink($filename) unless $param->{'no_unlink'};\n\topen(F, '>', $filename) || die(\"$filename: $!\\n\");\n      }\n    } else {\n      $ent->{'data'} = '';\n    }\n    while ($sizepad) {\n      my $m = $sizepad > 8192 ? 8192 : $sizepad;\n      my $data = read_data($req, $m, 1);\n      $sizepad -= $m;\n      $size -= $m;\n      $m += $size if $size < 0;\n      if (defined($dn)) {\n        (syswrite(F, $data, $m) || 0) == $m || die(\"syswrite: $!\\n\");\n      } else {\n        $ent->{'data'} .= substr($data, 0, $m);\n      }\n      $ctx->add($size >= 0 ? $data : substr($data, 0, $m)) if $ctx;\n    }\n    if (defined($dn) && ($mode & 0xf000) != 0x4000) {\n      close(F) || die(\"close: $!\\n\");\n      utime($mtime, $mtime, \"$dn/$name\") if $mtime;\n    }\n    $ent->{'md5'} = $ctx->hexdigest if $ctx && ($mode & 0xf000) != 0x4000;\n    $param->{'cpiopostfile'}->($param, $ent) if $param->{'cpiopostfile'};\n  }\n  return \\@res;\n}\n\nsub swrite {\n  my ($sock, $data, $chunked) = @_;\n  local *S = $sock;\n  return if $chunked && $data eq '';\t# can't write that\n  $data = sprintf(\"%X\\r\\n\", length($data)).$data.\"\\r\\n\" if $chunked;\n  while (length($data)) {\n    my $l = syswrite(S, $data, length($data));\n    die(\"socket write: $!\\n\") unless $l;\n    $data = substr($data, $l);\n  }\n}\n\nsub makecpiohead {\n  my ($file, $s) = @_; \n  return \"07070100000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000b00000000TRAILER!!!\\0\\0\\0\\0\" if !$file;\n  my $name = $file->{'name'};\n  my $mode = $file->{'mode'} || 0x81a4;\n  my $mtime = $file->{'mtime'} || $s->[9];\n  my $h = sprintf(\"07070100000000%08x000000000000000000000001\", $mode);\n  if ($s->[7] > 0xffffffff) {\n    # build service length extension\n    my $top = int($s->[7] / 4294967296.);\n    $h .= sprintf(\"%08xffffffff%08x%08x\", $mtime, $top, $s->[7] - $top * 4294967296.);\n  } else {\n    $h .= sprintf(\"%08x%08x\", $mtime, $s->[7]);\n  }\n  $h .= \"00000000000000000000000000000000\";\n  $h .= sprintf(\"%08x\", length($name) + 1); \n  $h .= \"00000000$name\\0\";\n  $h .= substr(\"\\0\\0\\0\\0\", (length($h) & 3)) if length($h) & 3;\n  my $pad = $s->[7] % 4 ? substr(\"\\0\\0\\0\\0\", $s->[7] % 4) : ''; \n  return ($h, $pad);\n}\n\nsub cpio_sender {\n  my ($param, $sock) = @_;\n\n  local *F;\n  my ($data, $pad);\n  my $errors = {'__errors' => 1, 'name' => '.errors', 'data' => ''};\n  for my $file (@{$param->{'cpiofiles'} || []}, $errors) {\n    my @s;\n    if ($file->{'error'}) {\n\t$errors->{'data'} .= \"$file->{'name'}: $file->{'error'}\\n\";\n\tnext;\n    }\n    if (exists $file->{'filename'}) {\n      my $filename = $file->{'filename'};\n      if (ref($filename)) {\n\t*F = $filename;\n      } elsif (!open(F, '<', $filename)) {\n\t$errors->{'data'} .= \"$file->{'name'}: $filename: $!\\n\";\n\tnext;\n      }\n      @s = stat(F);\n      if (!@s) {\n\t$errors->{'data'} .= \"$file->{'name'}: stat: $!\\n\";\n\tclose F unless ref $filename;\n\tnext;\n      }\n      if (ref($filename)) {\n\tmy $off = sysseek(F, 0, Fcntl::SEEK_CUR) || 0;\n\t$s[7] -= $off if $off > 0;\n      }\n      ($data, $pad) = makecpiohead($file, \\@s);\n      my $l = $s[7];\n      my $r = 0;\n      while(1) {\n\t$r = sysread(F, $data, $l > 8192 ? 8192 : $l, length($data)) if $l;\n\tdie(\"error while reading '$filename': $!\\n\") unless defined $r;\n\t$data .= $pad if $r == $l;\n\tswrite($sock, $data, $param->{'chunked'});\n\t$data = '';\n\t$l -= $r;\n\tlast unless $l;\n      }\n      die(\"internal error\\n\") if $l;\n      close F unless ref $filename;\n    } else {\n      next if $file->{'__errors'} && $file->{'data'} eq '';\n      $s[7] = length($file->{'data'});\n      $s[9] = time;\n      ($data, $pad) = makecpiohead($file, \\@s);\n      $data .= \"$file->{'data'}$pad\";\n      while ($param->{'chunked'} && length($data) > 8192) {\n\t# keep chunks small\n\tswrite($sock, substr($data, 0, 4096), $param->{'chunked'});\n\t$data = substr($data, 4096);\n      }\n      swrite($sock, $data, $param->{'chunked'});\n    }\n  }\n  $data = makecpiohead();\n  swrite($sock, $data, $param->{'chunked'});\n  return '';\n}\n\nsub file_sender {\n  my ($param, $sock) = @_;\n  local *F;\n\n  my $bytes = $param->{'bytes'};\n  my $data;\n  if (ref($param->{'filename'})) {\n    *F = $param->{'filename'};\n  } else {\n    open(F, '<', $param->{'filename'}) || die(\"$param->{'filename'}: $!\\n\")\n  }\n  while(1) {\n    last if defined($bytes) && !$bytes;\n    my $r = sysread(F, $data, 8192);\n    last unless $r;\n    if ($bytes) {\n      $data = substr($data, 0, $bytes) if length($data) > $bytes;\n      $bytes -= length($data);\n    }\n    swrite($sock, $data, $param->{'chunked'});\n  }\n  close F unless ref $param->{'filename'};\n  return '';\n}\n\n1;\n"], "fixing_code": ["#\n# Copyright (c) 2006, 2007 Michael Schroeder, Novell Inc.\n#\n# This program is free software; you can redistribute it and/or modify\n# it under the terms of the GNU General Public License version 2 as\n# published by the Free Software Foundation.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program (see the file COPYING); if not, write to the\n# Free Software Foundation, Inc.,\n# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA\n#\n################################################################\n#\n# HTTP protocol functions. Also contains file/cpio sender/receiver.\n#\n\npackage BSHTTP;\n\nuse POSIX;\nuse Digest::MD5 ();\nuse Fcntl qw(:DEFAULT);\nBEGIN { Fcntl->import(':seek') unless defined &SEEK_SET; }\n\nuse strict;\n\n=head1 NAME\n\nBSHTTP\n\n=cut\n\n=head1 SYNOPSIS\n\n TODO\n\n=cut\n\n=head1 DESCRIPTION\n\nThis library contains functions to handle http requests in obs\n\n=cut\n\n=head1 FUNCTIONS / METHODS\n\n=cut\n\n\nsub gethead {\n  my ($h, $t) = @_;\n\n  my ($field, $data);\n  for (split(/[\\r\\n]+/, $t)) {\n    next if $_ eq '';\n    if (/^[ \\t]/s) {\n      s/^\\s*/ /s;\n      $h->{$field} .= $_ if defined $field;\n    } else {\n      ($field, $data) = split(/\\s*:\\s*/, $_, 2);\n      $field =~ tr/A-Z/a-z/;\n      $h->{$field} = $h->{$field} && $h->{$field} ne '' ? \"$h->{$field},$data\" : $data;\n    }\n  }\n}\n\nsub unexpected_eof {\n  my ($req) = @_;\n  $req->{'__eof'} = 1 if $req;\n  die(\"unexpected EOF\\n\");\n}\n\n\n=head2 BSHTTP::read_data\n\nread data from socket, do chunk decoding if needed\n\n  my $ret = BSHTTP::read_data(\n    # request data\n    {\n      headers\t  => {\n\t\t\ttransfer-encoding => 'chunked'\n\t\t\tcontent-length\t  => ...\n\t\t     }, #\n      __socket\t  => <FILEHANDLE> , # filehandle to socket or opened file\n      __cl\t  => ...\t  , #\n      __data\n    },\n    $maxl,\t  # if undef read as much as you can\n    $exact,\t  # Boolean\n\t\t  # if 1 read maxl data\n\t\t  # if maxl == undef -> read to eof\n  );\n\n=cut\n\nsub read_data {\n  my ($req, $maxl, $exact) = @_;\n\n  my $ret = '';\n  my $hdr = $req->{'headers'} || {};\n  local *S = $req->{'__socket'};\n  if ($hdr->{'transfer-encoding'} && lc($hdr->{'transfer-encoding'}) eq 'chunked') {\n    my $cl = $req->{'__cl'} || 0;\n    if ($cl < 0) {\n      die(\"unexpected EOF\\n\") if $exact && defined($maxl) && length($ret) < $maxl;\n      return $ret;\n    }\n    my $qu = $req->{'__data'};\n    while (1) {\n      if (defined($maxl) && $maxl <= $cl) {\n\twhile(length($qu) < $maxl) {\n\t  my $r = sysread(S, $qu, 8192, length($qu));\n\t  unexpected_eof($req) if !$r && (defined($r) || ($! != POSIX::EINTR && $! != POSIX::EWOULDBLOCK));\n\t}\n\t$ret .= substr($qu, 0, $maxl);\n\t$req->{'__cl'} = $cl - $maxl;\n\t$req->{'__data'} = substr($qu, $maxl);\n\treturn $ret;\n      }\n      if ($cl) {\n\t# no maxl or maxl > cl, read full cl\n\twhile(length($qu) < $cl) {\n\t  my $r = sysread(S, $qu, 8192, length($qu));\n\t  unexpected_eof($req) if !$r && (defined($r) || ($! != POSIX::EINTR && $! != POSIX::EWOULDBLOCK));\n\t}\n\t$ret .= substr($qu, 0, $cl);\n\t$qu = substr($qu, $cl);\n\t$maxl -= $cl if defined $maxl;\n\t$cl = 0;\n\tif (!defined($maxl) && !$exact) { # no maxl, return every chunk\n\t  $req->{'__cl'} = $cl;\n\t  $req->{'__data'} = $qu;\n\t  return $ret;\n\t}\n      }\n      # reached end of chunk, prepare for next one\n      while ($qu !~ /\\r?\\n/s) {\n\tmy $r = sysread(S, $qu, 8192, length($qu));\n        unexpected_eof($req) if !$r && (defined($r) || ($! != POSIX::EINTR && $! != POSIX::EWOULDBLOCK));\n      }\n      if (substr($qu, 0, 1) eq \"\\n\") {\n\t$qu = substr($qu, 1);\n\tnext;\n      }\n      if (substr($qu, 0, 2) eq \"\\r\\n\") {\n\t$qu = substr($qu, 2);\n\tnext;\n      }\n      die(\"bad CHUNK data: $qu\\n\") unless $qu =~ /^([0-9a-fA-F]+)/;\n      $cl = hex($1);\n      die if $cl < 0;\n      $qu =~ s/^.*?\\r?\\n//s;\n      if ($cl == 0) {\n\t$req->{'__cl'} = -1;\t# mark EOF\n\t$req->{'__eof'} = 1;\n\tdie(\"unexpected EOF\\n\") if $exact && defined($maxl) && length($ret) < $maxl;\n\t# read trailer\n\t$qu = \"\\r\\n$qu\";\n\twhile ($qu !~ /\\n\\r?\\n/s) {\n\t  my $r = sysread(S, $qu, 8192, length($qu));\n\t  unexpected_eof($req) if !$r && (defined($r) || ($! != POSIX::EINTR && $! != POSIX::EWOULDBLOCK));\n\t}\n\t$qu =~ /^(.*?)\\n\\r?\\n/;\n\t# get trailing header\n\tgethead($hdr, length($1) >= 2 ? substr($1, 2) : '');\n\treturn $ret;\n      }\n    }\n  } else {\n    my $qu = $req->{'__data'};\n    my $cl = $req->{'__cl'};\n    $cl = $hdr->{'content-length'} unless defined $cl;\n    if (defined($cl) && (!defined($maxl) || $maxl > $cl)) {\n      die(\"unexpected EOF\\n\") if $exact && defined($maxl);\n      $maxl = $cl >= 0 ? $cl : 0;\n    }\n    while (!defined($maxl) || length($qu) < $maxl) {\n      my $m = ($maxl || 0) - length($qu);\n      $m = 8192 if $m < 8192;\n      my $r = sysread(S, $qu, $m, length($qu));\n      if (!$r &&  (defined($r) || ($! != POSIX::EINTR && $! != POSIX::EWOULDBLOCK))) {\n\t$req->{'__eof'} = 1;\n\tdie(\"unexpected EOF\\n\") if defined($cl) || ($exact && defined($maxl));\n\t$cl = $maxl = length($qu);\n      }\n    }\n    $cl -= $maxl if defined($cl);\n    $ret = substr($qu, 0, $maxl);\n    $req->{'__cl'} = $cl;\n    $req->{'__data'} = substr($qu, $maxl);\n    $req->{'__eof'} = 1 if defined($cl) && $cl == 0;\n    return $ret;\n  }\n}\n\nsub str2req {\n  my ($str) = @_;\n  my $req = {\n    '__data' => $str,\n    '__cl' => length($str),\n  };\n  return $req;\n}\n\nsub fd2req {\n  my ($fd) = @_;\n  my $req = {\n    '__data' => '',\n    '__socket' => $fd,\n    '__cl' => -s *$fd,\n  };\n  return $req;\n}\n\nsub null_receiver {\n  my ($req, $param) = @_;\n  1 while(read_data($req, 8192) ne '');\n  return '';\n}\n\nsub file_receiver {\n  my ($req, $param) = @_;\n\n  die(\"file_receiver: no filename\\n\") unless defined $param->{'filename'};\n  my $fn = $param->{'filename'};\n  my $withmd5 = $param->{'withmd5'};\n  local *F;\n  my $ctx;\n  $ctx = Digest::MD5->new if $withmd5;\n  open(F, '>', $fn) || die(\"$fn: $!\\n\");\n  my $size = 0;\n  while(1) {\n    my $s = read_data($req, 8192);\n    last if $s eq '';\n    (syswrite(F, $s) || 0) == length($s) || die(\"syswrite: $!\\n\");\n    $size += length($s);\n    $ctx->add($s) if $ctx;\n  }\n  close(F) || die(\"close: $!\\n\");\n  my $res = {size => $size};\n  $res->{'md5'} = $ctx->hexdigest if $ctx;\n  return $res;\n}\n\n\n=head2 BSHTTP::cpio_receiver\n\nTODO: add meaningful explanation\n\n  my $result = BSHTTP::cpio_receiver(\n    # options given to read_data\n    {\n      ... # SEE BSHTTP::read_data\n    },\n    # all parameters are optional\n    {\n      directory\t    => <STRING>        , # store files in given directory\n\t\t\t\t\t # (Otherwise data is stored in $result->[]\n      withmd5\t    => <BOOLEAN>       , #\n      acceptsubdirs => <BOOLEAN>       , #\n      createsubdirs => <BOOLEAN>       , #\n      accept\t    => <REGEX|CODEREF> , # Check included files\n\t\t\t\t\t # by regex or function\n      map\t    => <REGEX|CODEREF> , # Rename files\n\t\t\t\t\t # by regex or function\n      no_unlink\t    => <BOOLEAN>       , # Do not remove already existent\n\t\t\t\t\t # (sub)directories. Only relevant\n\t\t\t\t\t # if directory is given\n\t\t\t\t\t #\n      cpiopostfile  => ... , #\n    }\n  );\n\n  # returns an ArrayRef of HashRefs\n  # $result = [\n  #   {\n  #\tname\t  => <STRING>\t  , # filename\n  #\tsize\t  => ...\n  #\tmtime\t  => ...\t  ,\n  #\tmode\t  => ...\t  ,\n  #\tmd5\t  => <STRING>\t  , # md5 as hexdigest\n  #\t\t\t\t    # only if withmd5 was true\n  #\tdata\t  => <BINARYDATA> , # binary data from file\n  #\t\t\t\t    # only if no directory was given\n  #   },\n  #   {\n  #\t....\n  #   },\n  #   ....\n  # ];\n\n=cut\n\nsub cpio_receiver {\n  my ($req, $param) = @_;\n  my @res;\n  my $dn = $param->{'directory'};\n  my $withmd5 = $param->{'withmd5'};\n  local *F;\n  while(1) {\n    my $cpiohead = read_data($req, 110, 1);\n    die(\"cpio: not a 'SVR4 no CRC ascii' cpio\\n\") unless substr($cpiohead, 0, 6) eq '070701';\n    my $mode = hex(substr($cpiohead, 14, 8));\n    my $mtime = hex(substr($cpiohead, 46, 8));\n    my $size  = hex(substr($cpiohead, 54, 8));\n    if ($size == 0xffffffff) {\n      # build service length extension\n      $cpiohead .= read_data($req, 16, 1);\n      $size = hex(substr($cpiohead, 62, 8)) * 4294967296. + hex(substr($cpiohead, 70, 8));\n      substr($cpiohead, 62, 16) = '';\n    }\n    my $nsize = hex(substr($cpiohead, 94, 8));\n    die(\"ridiculous long filename\\n\") if $nsize > 8192;\n    my $nsizepad = $nsize;\n    $nsizepad += 4 - ($nsize + 2 & 3) if $nsize + 2 & 3;\n    my $name = read_data($req, $nsizepad, 1);\n    $name =~ s/\\0.*//s;\n    $name =~ s/^\\.\\///s;\n    my $sizepad = $size;\n    $sizepad += 4 - ($size % 4) if $size % 4;\n    last if !$size && $name eq 'TRAILER!!!';\n    if ($param->{'acceptsubdirs'} || $param->{'createsubdirs'}) {\n      die(\"cpio filename is illegal: $name\\n\") if \"/$name/\" =~ /\\/\\.{0,2}\\//s;\n    } else {\n      die(\"cpio filename contains a '/': $name\\n\") if $name =~ /\\//s;\n    }\n    die(\"cpio filename is '.' or '..'\\n\") if $name eq '.' || $name eq '..';\n    my $ent = {'name' => $name, 'size' => $size, 'mtime' => $mtime, 'mode' => $mode};\n    if ($param->{'accept'}) {\n      if (ref($param->{'accept'})) {\n\tdie(\"illegal file in cpio archive: $name\\n\") unless $param->{'accept'}->($param, $name, $ent);\n      } else {\n\tdie(\"illegal file in cpio archive: $name\\n\") unless $name =~ /$param->{'accept'}/;\n      }\n    }\n    if ($param->{'map'}) {\n      $ent->{'unmappedname'} = $name;\n      if (ref($param->{'map'})) {\n\t$ent->{'name'} = $name = $param->{'map'}->($param, $name);\n      } else {\n\t$ent->{'name'} = $name = \"$param->{'map'}$name\";\n      }\n    }\n    if (!defined($name)) {\n      # skip entry\n      while ($sizepad) {\n        my $m = $sizepad > 8192 ? 8192 : $sizepad;\n        read_data($req, $m, 1);\n        $sizepad -= $m;\n      }\n      next;\n    }\n    push @res, $ent;\n    my $ctx;\n    $ctx = Digest::MD5->new if $withmd5;\n    if (defined($dn)) {\n      my $filename = \"$dn/$name\";\n      if (($mode & 0xf000) == 0x4000 && $param->{'createsubdirs'}) {\n\tdie(\"directory has non-zero size\\n\") if $sizepad;\n\tif (! -d $filename) {\n\t  unlink($filename) unless $param->{'no_unlink'};\n\t  mkdir($filename) || die(\"mkdir $filename: $!\\n\");\n\t}\n      } else {\n\tdie(\"can only unpack plain files from cpio archive, file $name, mode was $mode\\n\") unless ($mode & 0xf000) == 0x8000;\n\tunlink($filename) unless $param->{'no_unlink'};\n\topen(F, '>', $filename) || die(\"$filename: $!\\n\");\n      }\n    } else {\n      $ent->{'data'} = '';\n    }\n    while ($sizepad) {\n      my $m = $sizepad > 8192 ? 8192 : $sizepad;\n      my $data = read_data($req, $m, 1);\n      $sizepad -= $m;\n      $size -= $m;\n      $m += $size if $size < 0;\n      if (defined($dn)) {\n        (syswrite(F, $data, $m) || 0) == $m || die(\"syswrite: $!\\n\");\n      } else {\n        $ent->{'data'} .= substr($data, 0, $m);\n      }\n      $ctx->add($size >= 0 ? $data : substr($data, 0, $m)) if $ctx;\n    }\n    if (defined($dn) && ($mode & 0xf000) != 0x4000) {\n      close(F) || die(\"close: $!\\n\");\n      utime($mtime, $mtime, \"$dn/$name\") if $mtime;\n    }\n    $ent->{'md5'} = $ctx->hexdigest if $ctx && ($mode & 0xf000) != 0x4000;\n    $param->{'cpiopostfile'}->($param, $ent) if $param->{'cpiopostfile'};\n  }\n  return \\@res;\n}\n\nsub swrite {\n  my ($sock, $data, $chunked) = @_;\n  local *S = $sock;\n  return if $chunked && $data eq '';\t# can't write that\n  $data = sprintf(\"%X\\r\\n\", length($data)).$data.\"\\r\\n\" if $chunked;\n  while (length($data)) {\n    my $l = syswrite(S, $data, length($data));\n    die(\"socket write: $!\\n\") unless $l;\n    $data = substr($data, $l);\n  }\n}\n\nsub makecpiohead {\n  my ($file, $s) = @_; \n  return \"07070100000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000b00000000TRAILER!!!\\0\\0\\0\\0\" if !$file;\n  my $name = $file->{'name'};\n  my $mode = $file->{'mode'} || 0x81a4;\n  my $mtime = $file->{'mtime'} || $s->[9];\n  my $h = sprintf(\"07070100000000%08x000000000000000000000001\", $mode);\n  if ($s->[7] > 0xffffffff) {\n    # build service length extension\n    my $top = int($s->[7] / 4294967296.);\n    $h .= sprintf(\"%08xffffffff%08x%08x\", $mtime, $top, $s->[7] - $top * 4294967296.);\n  } else {\n    $h .= sprintf(\"%08x%08x\", $mtime, $s->[7]);\n  }\n  $h .= \"00000000000000000000000000000000\";\n  $h .= sprintf(\"%08x\", length($name) + 1); \n  $h .= \"00000000$name\\0\";\n  $h .= substr(\"\\0\\0\\0\\0\", (length($h) & 3)) if length($h) & 3;\n  my $pad = $s->[7] % 4 ? substr(\"\\0\\0\\0\\0\", $s->[7] % 4) : ''; \n  return ($h, $pad);\n}\n\nsub cpio_sender {\n  my ($param, $sock) = @_;\n\n  local *F;\n  my ($data, $pad);\n  my $errors = {'__errors' => 1, 'name' => '.errors', 'data' => ''};\n  for my $file (@{$param->{'cpiofiles'} || []}, $errors) {\n    my @s;\n    if ($file->{'error'}) {\n\t$errors->{'data'} .= \"$file->{'name'}: $file->{'error'}\\n\";\n\tnext;\n    }\n    if (exists $file->{'filename'}) {\n      my $filename = $file->{'filename'};\n      if (ref($filename)) {\n\t*F = $filename;\n      } else {\n\t@s = lstat($filename);\n\tif (!@s) {\n\t  $errors->{'data'} .= \"$file->{'name'}: $filename: $!\\n\";\n\t  next;\n\t}\n\tif (-l _ || ! -f _) {\n\t  $errors->{'data'} .= \"$file->{'name'}: $filename: not a plain file\\n\";\n\t  next;\n\t}\n\tif (!open(F, '<', $filename)) {\n\t  $errors->{'data'} .= \"$file->{'name'}: $filename: $!\\n\";\n\t  next;\n\t}\n      }\n      @s = stat(F);\n      if (!@s) {\n\t$errors->{'data'} .= \"$file->{'name'}: fstat: $!\\n\";\n\tclose F unless ref $filename;\n\tnext;\n      }\n      if (ref($filename)) {\n\tmy $off = sysseek(F, 0, Fcntl::SEEK_CUR) || 0;\n\t$s[7] -= $off if $off > 0;\n      }\n      ($data, $pad) = makecpiohead($file, \\@s);\n      my $l = $s[7];\n      my $r = 0;\n      while(1) {\n\t$r = sysread(F, $data, $l > 8192 ? 8192 : $l, length($data)) if $l;\n\tdie(\"error while reading '$filename': $!\\n\") unless defined $r;\n\t$data .= $pad if $r == $l;\n\tswrite($sock, $data, $param->{'chunked'});\n\t$data = '';\n\t$l -= $r;\n\tlast unless $l;\n      }\n      die(\"internal error\\n\") if $l;\n      close F unless ref $filename;\n    } else {\n      next if $file->{'__errors'} && $file->{'data'} eq '';\n      $s[7] = length($file->{'data'});\n      $s[9] = time;\n      ($data, $pad) = makecpiohead($file, \\@s);\n      $data .= \"$file->{'data'}$pad\";\n      while ($param->{'chunked'} && length($data) > 8192) {\n\t# keep chunks small\n\tswrite($sock, substr($data, 0, 4096), $param->{'chunked'});\n\t$data = substr($data, 4096);\n      }\n      swrite($sock, $data, $param->{'chunked'});\n    }\n  }\n  $data = makecpiohead();\n  swrite($sock, $data, $param->{'chunked'});\n  return '';\n}\n\nsub file_sender {\n  my ($param, $sock) = @_;\n  local *F;\n\n  my $bytes = $param->{'bytes'};\n  my $data;\n  if (ref($param->{'filename'})) {\n    *F = $param->{'filename'};\n  } else {\n    open(F, '<', $param->{'filename'}) || die(\"$param->{'filename'}: $!\\n\")\n  }\n  while(1) {\n    last if defined($bytes) && !$bytes;\n    my $r = sysread(F, $data, 8192);\n    last unless $r;\n    if ($bytes) {\n      $data = substr($data, 0, $bytes) if length($data) > $bytes;\n      $bytes -= length($data);\n    }\n    swrite($sock, $data, $param->{'chunked'});\n  }\n  close F unless ref $param->{'filename'};\n  return '';\n}\n\n1;\n"], "filenames": ["src/backend/BSHTTP.pm"], "buggy_code_start_loc": [451], "buggy_code_end_loc": [458], "fixing_code_start_loc": [451], "fixing_code_end_loc": [469], "type": "CWE-200", "message": "The bs_worker code in open build service before 20170320 followed relative symlinks, allowing reading of files outside of the package source directory during build, allowing leakage of private information.", "other": {"cve": {"id": "CVE-2017-5188", "sourceIdentifier": "meissner@suse.de", "published": "2018-03-01T20:29:00.477", "lastModified": "2019-10-09T23:28:13.637", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The bs_worker code in open build service before 20170320 followed relative symlinks, allowing reading of files outside of the package source directory during build, allowing leakage of private information."}, {"lang": "es", "value": "El c\u00f3digo bs_worker en open build service, anterior a 20170320, segu\u00eda symlinks relativos, lo que permit\u00eda la lectura de archivos fuera del directorio origen del paquete durante la build. Esto permit\u00eda el filtrado de informaci\u00f3n privada."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "meissner@suse.de", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:R/S:U/C:H/I:N/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.0, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.3, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-200"}, {"lang": "en", "value": "CWE-59"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:opensuse:open_build_service:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.7.3", "matchCriteriaId": "4ED15B92-D7FF-4901-AC00-94D9A59489E4"}]}]}], "references": [{"url": "https://bugzilla.suse.com/show_bug.cgi?id=1029824", "source": "meissner@suse.de", "tags": ["Issue Tracking"]}, {"url": "https://github.com/openSUSE/open-build-service/commit/ba27c91351878bc297ec4baba0bd488a2f3b568d", "source": "meissner@suse.de", "tags": ["Patch"]}, {"url": "https://www.suse.com/de-de/security/cve/CVE-2017-5188/", "source": "meissner@suse.de", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/openSUSE/open-build-service/commit/ba27c91351878bc297ec4baba0bd488a2f3b568d"}}