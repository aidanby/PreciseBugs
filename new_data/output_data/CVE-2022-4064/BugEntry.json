{"buggy_code": ["Dalli Changelog\n=====================\n\nUnreleased\n==========\n\n- Namespaces passed as procs are now evaluated every time, as opposed to just on initialization (nrw505)\n- Fix missing require of uri in ServerConfigParser (adam12)\n- Fix link to the CHANGELOG.md file in README.md (rud)\n\n3.2.2\n==========\n\n- Ensure apps are resilient against old session ids (kbrock)\n\n3.2.1\n==========\n\n- Fix null replacement bug on some SASL-authenticated services (veritas1)\n\n3.2.0\n==========\n\n- BREAKING CHANGE: Remove protocol_implementation client option (petergoldstein)\n- Add protocol option with meta implementation (petergoldstein)\n\n3.1.6\n==========\n\n- Fix bug with cas/cas! with \"Not found\" value (petergoldstein)\n- Add Ruby 3.1 to CI (petergoldstein)\n- Replace reject(&:nil?) with compact (petergoldstein)\n\n3.1.5\n==========\n\n- Fix bug with get_cas key with \"Not found\" value (petergoldstein)\n- Replace should return nil, not raise error, on miss (petergoldstein)\n\n3.1.4\n==========\n\n- Improve response parsing performance (casperisfine)\n- Reorganize binary protocol parsing a bit (petergoldstein)\n- Fix handling of non-ASCII keys in get_multi (petergoldstein)\n\n3.1.3\n==========\n\n- Restore falsey behavior on delete/delete_cas for nonexistent key (petergoldstein)\n\n3.1.2\n==========\n\n- Make quiet? / multi? public on Dalli::Protocol::Binary (petergoldstein)\n\n3.1.1\n==========\n\n- Add quiet support for incr, decr, append, depend, and flush (petergoldstein)\n- Additional refactoring to allow reuse of connection behavior (petergoldstein)\n- Fix issue in flush such that it wasn't passing the delay argument to memcached (petergoldstein)\n\n3.1.0\n==========\n\n- BREAKING CHANGE: Update Rack::Session::Dalli to inherit from Abstract::PersistedSecure.  This will invalidate existing sessions (petergoldstein)\n- BREAKING CHANGE: Use of unsupported operations in a multi block now raise an error. (petergoldstein)\n- Extract PipelinedGetter from Dalli::Client (petergoldstein)\n- Fix SSL socket so that it works with pipelined gets (petergoldstein)\n- Additional refactoring to split classes (petergoldstein)\n\n3.0.6\n==========\n\n- Fix regression in SASL authentication response parsing (petergoldstein)\n\n3.0.5\n==========\n\n- Add Rubocop and fix most outstanding issues (petergoldstein)\n- Extract a number of classes, to simplify the largest classes (petergoldstein)\n- Ensure against socket corruption if an error occurs in a multi block (petergoldstein)\n\n3.0.4\n==========\n\n- Clean connections and retry after NetworkError in get_multi (andrejbl)\n- Internal refactoring and cleanup (petergoldstein)\n\n3.0.3\n==========\n\n- Restore ability for `compress` to be disabled on a per request basis (petergoldstein)\n- Fix broken image in README (deining)\n- Use bundler-cache in CI (olleolleolle)\n- Remove the OpenSSL extensions dependency (petergoldstein)\n- Add Memcached 1.5.x to the CI matrix\n- Updated compression documentation (petergoldstein)\n\n3.0.2\n==========\n\n- Restore Windows compatibility (petergoldstein)\n- Add JRuby to CI and make requisite changes (petergoldstein)\n- Clarify documentation for supported rubies (petergoldstein)\n\n3.0.1\n==========\n\n- Fix syntax error that prevented inclusion of Dalli::Server (ryanfb)\n- Restore with method required by ActiveSupport::Cache::MemCacheStore\n\n3.0.0\n==========\n- BREAKING CHANGES:\n\n  * Removes :dalli_store.\n    Use Rails' official :mem_cache_store instead.\n    https://guides.rubyonrails.org/caching_with_rails.html\n  * Attempting to store a larger value than allowed by memcached used to\n    print a warning and truncate the value. This now raises an error to\n    prevent silent data corruption.\n  * Compression now defaults to `true` for large values (greater than 4KB).\n    This is intended to minimize errors due to the previous note.\n  * Errors marshalling values now raise rather than just printing an error.\n  * The Rack session adapter has been refactored to remove support for thread-unsafe\n    configurations. You will need to include the `connection_pool` gem in\n    your Gemfile to ensure session operations are thread-safe.\n  * When using namespaces, the algorithm for calculating truncated keys was\n    changed.  Non-truncated keys and truncated keys for the non-namespace\n    case were left unchanged.\n\n- Raise NetworkError when multi response gets into corrupt state (mervync, #783)\n- Validate servers argument (semaperepelitsa, petergoldstein, #776)\n- Enable SSL support (bdunne, #775)\n- Add gat operation (tbeauvais, #769)\n- Removes inline native code, use Ruby 2.3+ support for bsearch instead. (mperham)\n- Switch repo to Github Actions and upgrade Ruby versions (petergoldstein, bdunne, Fryguy)\n- Update benchmark test for Rubyprof changes (nateberkopec)\n- Remove support for the `kgio` gem, it is not relevant in Ruby 2.3+. (mperham)\n- Remove inline native code, use Ruby 2.3+ support for bsearch instead. (mperham)\n\n\n2.7.11\n==========\n- DEPRECATION: :dalli_store will be removed in Dalli 3.0.\n  Use Rails' official :mem_cache_store instead.\n  https://guides.rubyonrails.org/caching_with_rails.html\n- Add new `digest_class` option to Dalli::Client [#724]\n- Don't treat NameError as a network error [#728]\n- Handle nested comma separated server strings (sambostock)\n\n2.7.10\n==========\n- Revert frozen string change (schneems)\n- Advertise supports_cached_versioning? in DalliStore (schneems)\n- Better detection of fork support, to allow specs to run under Truffle Ruby (deepj)\n- Update logging for over max size to log as error (aeroastro)\n\n2.7.9\n==========\n- Fix behavior for Rails 5.2+ cache_versioning (GriwMF)\n- Ensure fetch provides the key to the fallback block as an argument (0exp)\n- Assorted performance improvements (schneems)\n\n2.7.8\n==========\n- Rails 5.2 compatibility (pbougie)\n- Fix Session Cache compatibility (pixeltrix)\n\n2.7.7\n==========\n- Support large cache keys on fetch multi (sobrinho)\n- Not found checks no longer trigger the result's equality method (dannyfallon)\n- Use SVG build badges (olleolleolle)\n- Travis updates (junaruga, tiarly, petergoldstein)\n- Update default down_retry_delay (jaredhales)\n- Close kgio socket after IO.select timeouts\n- Documentation updates (tipair)\n- Instrument DalliStore errors with instrument_errors configuration option. (btatnall)\n\n2.7.6\n==========\n- Rails 5.0.0.beta2 compatibility (yui-knk, petergoldstein)\n- Add cas!, a variant of the #cas method that yields to the block whether or not the key already exist (mwpastore)\n- Performance improvements (nateberkopec)\n- Add Ruby 2.3.0 to support matrix (tricknotes)\n\n2.7.5\n==========\n\n- Support rcvbuff and sndbuff byte configuration. (btatnall)\n- Add `:cache_nils` option to support nil values in `DalliStore#fetch` and `Dalli::Client#fetch` (wjordan, #559)\n- Log retryable server errors with 'warn' instead of 'info' (phrinx)\n- Fix timeout issue with Dalli::Client#get_multi_yielder (dspeterson)\n- Escape namespaces with special regexp characters (Steven Peckins)\n- Ensure LocalCache supports the `:raw` option and Entry unwrapping (sj26)\n- Ensure bad ttl values don't cause Dalli::RingError (eagletmt, petergoldstein)\n- Always pass namespaced key to instrumentation API (kaorimatz)\n- Replace use of deprecated TimeoutError with Timeout::Error (eagletmt)\n- Clean up gemspec, and use Bundler for loading (grosser)\n- Dry up local cache testing (grosser)\n\n2.7.4\n==========\n\n- Restore Windows compatibility (dfens, #524)\n\n2.7.3\n==========\n\n- Assorted spec improvements\n- README changes to specify defaults for failover and compress options (keen99, #470)\n- SASL authentication changes to deal with Unicode characters (flypiggy, #477)\n- Call to_i on ttl to accomodate ActiveSupport::Duration (#494)\n- Change to implicit blocks for performance (glaucocustodio, #495)\n- Change to each_key for performance (jastix, #496)\n- Support stats settings - (dterei, #500)\n- Raise DallError if hostname canno be parsed (dannyfallon, #501)\n- Fix instrumentation for falsey values (AlexRiedler, #514)\n- Support UNIX socket configurations (r-stu31, #515)\n\n2.7.2\n==========\n\n- The fix for #423 didn't make it into the released 2.7.1 gem somehow.\n\n2.7.1\n==========\n\n- Rack session will check if servers are up on initialization (arthurnn, #423)\n- Add support for IPv6 addresses in hex form, ie: \"[::1]:11211\" (dplummer, #428)\n- Add symbol support for namespace (jingkai #431)\n- Support expiration intervals longer than 30 days (leonid-shevtsov #436)\n\n2.7.0\n==========\n\n- BREAKING CHANGE:\n  Dalli::Client#add and #replace now return a truthy value, not boolean true or false.\n- Multithreading support with dalli\\_store:\n  Use :pool\\_size to create a pool of shared, threadsafe Dalli clients in Rails:\n```ruby\n    config.cache_store = :dalli_store, \"cache-1.example.com\", \"cache-2.example.com\", :compress => true, :pool_size => 5, :expires_in => 300\n```\n  This will ensure the Rails.cache singleton does not become a source of contention.\n  **PLEASE NOTE** Rails's :mem\\_cache\\_store does not support pooling as of\nRails 4.0.  You must use :dalli\\_store.\n\n- Implement `version` for retrieving version of connected servers [dterei, #384]\n- Implement `fetch_multi` for batched read/write [sorentwo, #380]\n- Add more support for safe updates with multiple writers: [philipmw, #395]\n  `require 'dalli/cas/client'` augments Dalli::Client with the following methods:\n  * Get value with CAS:            `[value, cas] = get_cas(key)`\n                                   `get_cas(key) {|value, cas| ...}`\n  * Get multiple values with CAS:  `get_multi_cas(k1, k2, ...) {|value, metadata| cas = metadata[:cas]}`\n  * Set value with CAS:            `new_cas = set_cas(key, value, cas, ttl, options)`\n  * Replace value with CAS:        `replace_cas(key, new_value, cas, ttl, options)`\n  * Delete value with CAS:         `delete_cas(key, cas)`\n- Fix bug with get key with \"Not found\" value [uzzz, #375]\n\n2.6.4\n=======\n\n- Fix ADD command, aka `write(unless_exist: true)` (pitr, #365)\n- Upgrade test suite from mini\\_shoulda to minitest.\n- Even more performance improvements for get\\_multi (xaop, #331)\n\n2.6.3\n=======\n\n- Support specific stats by passing `:items` or `:slabs` to `stats` method [bukhamseen]\n- Fix 'can't modify frozen String' errors in `ActiveSupport::Cache::DalliStore` [dblock]\n- Protect against objects with custom equality checking [theron17]\n- Warn if value for key is too large to store [locriani]\n\n2.6.2\n=======\n\n- Properly handle missing RubyInline\n\n2.6.1\n=======\n\n- Add optional native C binary search for ring, add:\n\ngem 'RubyInline'\n\n  to your Gemfile to get a 10% speedup when using many servers.\n  You will see no improvement if you are only using one server.\n\n- More get_multi performance optimization [xaop, #315]\n- Add lambda support for cache namespaces [joshwlewis, #311]\n\n2.6.0\n=======\n\n- read_multi optimization, now checks local_cache [chendo, #306]\n- Re-implement get_multi to be non-blocking [tmm1, #295]\n- Add `dalli` accessor to dalli_store to access the underlying\nDalli::Client, for things like `get_multi`.\n- Add `Dalli::GzipCompressor`, primarily for compatibility with nginx's HttpMemcachedModule using `memcached_gzip_flag`\n\n2.5.0\n=======\n\n- Don't escape non-ASCII keys, memcached binary protocol doesn't care. [#257]\n- :dalli_store now implements LocalCache [#236]\n- Removed lots of old session_store test code, tests now all run without a default memcached server [#275]\n- Changed Dalli ActiveSupport adapter to always attempt instrumentation [brianmario, #284]\n- Change write operations (add/set/replace) to return false when value is too large to store [brianmario, #283]\n- Allowing different compressors per client [naseem]\n\n2.4.0\n=======\n- Added the ability to swap out the compressed used to [de]compress cache data [brianmario, #276]\n- Fix get\\_multi performance issues with lots of memcached servers [tmm1]\n- Throw more specific exceptions [tmm1]\n- Allowing different types of serialization per client [naseem]\n\n2.3.0\n=======\n- Added the ability to swap out the serializer used to [de]serialize cache data [brianmario, #274]\n\n2.2.1\n=======\n\n- Fix issues with ENV-based connections. [#266]\n- Fix problem with SessionStore in Rails 4.0 [#265]\n\n2.2.0\n=======\n\n- Add Rack session with\\_lock helper, for Rails 4.0 support [#264]\n- Accept connection string in the form of a URL (e.g., memcached://user:pass@hostname:port) [glenngillen]\n- Add touch operation [#228, uzzz]\n\n2.1.0\n=======\n\n- Add Railtie to auto-configure Dalli when included in Gemfile [#217, steveklabnik]\n\n2.0.5\n=======\n\n- Create proper keys for arrays of objects passed as keys [twinturbo, #211]\n- Handle long key with namespace [#212]\n- Add NODELAY to TCP socket options [#206]\n\n2.0.4\n=======\n\n- Dalli no longer needs to be reset after Unicorn/Passenger fork [#208]\n- Add option to re-raise errors rescued in the session and cache stores. [pitr, #200]\n- DalliStore#fetch called the block if the cached value == false [#205]\n- DalliStore should have accessible options [#195]\n- Add silence and mute support for DalliStore [#207]\n- Tracked down and fixed socket corruption due to Timeout [#146]\n\n2.0.3\n=======\n\n- Allow proper retrieval of stored `false` values [laserlemon, #197]\n- Allow non-ascii and whitespace keys, only the text protocol has those restrictions [#145]\n- Fix DalliStore#delete error-handling [#196]\n\n2.0.2\n=======\n\n- Fix all dalli\\_store operations to handle nil options [#190]\n- Increment and decrement with :initial => nil now return nil (lawrencepit, #112)\n\n2.0.1\n=======\n\n- Fix nil option handling in dalli\\_store#write [#188]\n\n2.0.0\n=======\n\n- Reimplemented the Rails' dalli\\_store to remove use of\n  ActiveSupport::Cache::Entry which added 109 bytes overhead to every\n  value stored, was a performance bottleneck and duplicated a lot of\n  functionality already in Dalli.  One benchmark went from 4.0 sec to 3.0\n  sec with the new dalli\\_store. [#173]\n- Added reset\\_stats operation [#155]\n- Added support for configuring keepalive on TCP connections to memcached servers (@bianster, #180)\n\nNotes:\n\n  * data stored with dalli\\_store 2.x is NOT backwards compatible with 1.x.\n    Upgraders are advised to namespace their keys and roll out the 2.x\n    upgrade slowly so keys do not clash and caches are warmed.\n    `config.cache_store = :dalli_store, :expires_in => 24.hours.to_i, :namespace => 'myapp2'`\n  * data stored with plain Dalli::Client API is unchanged.\n  * removed support for dalli\\_store's race\\_condition\\_ttl option.\n  * removed support for em-synchrony and unix socket connection options.\n  * removed support for Ruby 1.8.6\n  * removed memcache-client compability layer and upgrade documentation.\n\n\n1.1.5\n=======\n\n- Coerce input to incr/decr to integer via #to\\_i [#165]\n- Convert test suite to minitest/spec (crigor, #166)\n- Fix encoding issue with keys [#162]\n- Fix double namespacing with Rails and dalli\\_store. [#160]\n\n1.1.4\n=======\n\n- Use 127.0.0.1 instead of localhost as default to avoid IPv6 issues\n- Extend DalliStore's :expires\\_in when :race\\_condition\\_ttl is also used.\n- Fix :expires\\_in option not propogating from DalliStore to Client, GH-136\n- Added support for native Rack session store.  Until now, Dalli's\n  session store has required Rails.  Now you can use Dalli to store\n  sessions for any Rack application.\n\n    require 'rack/session/dalli'\n    use Rack::Session::Dalli, :memcache_server => 'localhost:11211', :compression => true\n\n1.1.3\n=======\n\n- Support Rails's autoloading hack for loading sessions with objects\n  whose classes have not be required yet, GH-129\n- Support Unix sockets for connectivity.  Shows a 2x performance\n  increase but keep in mind they only work on localhost. (dfens)\n\n1.1.2\n=======\n\n- Fix incompatibility with latest Rack session API when destroying\n  sessions, thanks @twinge!\n\n1.1.1\n=======\n\nv1.1.0 was a bad release.  Yanked.\n\n1.1.0\n=======\n\n- Remove support for Rails 2.3, add support for Rails 3.1\n- Fix socket failure retry logic, now you can restart memcached and Dalli won't complain!\n- Add support for fibered operation via em-synchrony (eliaslevy)\n- Gracefully handle write timeouts, GH-99\n- Only issue bug warning for unexpected StandardErrors, GH-102\n- Add travis-ci build support (ryanlecompte)\n- Gracefully handle errors in get_multi (michaelfairley)\n- Misc fixes from crash2burn, fphilipe, igreg, raggi\n\n1.0.5\n=======\n\n- Fix socket failure retry logic, now you can restart memcached and Dalli won't complain!\n\n1.0.4\n=======\n\n- Handle non-ASCII key content in dalli_store\n- Accept key array for read_multi in dalli_store\n- Fix multithreaded race condition in creation of mutex\n\n1.0.3\n=======\n\n- Better handling of application marshalling errors\n- Work around jruby IO#sysread compatibility issue\n\n\n1.0.2\n=======\n\n - Allow browser session cookies (blindsey)\n - Compatibility fixes (mwynholds)\n - Add backwards compatibility module for memcache-client, require 'dalli/memcache-client'.  It makes\n   Dalli more compatible with memcache-client and prints out a warning any time you do something that\n   is no longer supported so you can fix your code.\n\n1.0.1\n=======\n\n - Explicitly handle application marshalling bugs, GH-56\n - Add support for username/password as options, to allow multiple bucket access\n   from the same Ruby process, GH-52\n - Add support for >1MB values with :value_max_bytes option, GH-54 (r-stu31)\n - Add support for default TTL, :expires_in, in Rails 2.3. (Steven Novotny)\n   config.cache_store = :dalli_store, 'localhost:11211', {:expires_in => 4.hours}\n\n\n1.0.0\n=======\n\nWelcome gucki as a Dalli committer!\n\n - Fix network and namespace issues in get_multi (gucki)\n - Better handling of unmarshalling errors (mperham)\n\n0.11.2\n=======\n\n - Major reworking of socket error and failover handling (gucki)\n - Add basic JRuby support (mperham)\n\n0.11.1\n======\n\n - Minor fixes, doc updates.\n - Add optional support for kgio sockets, gives a 10-15% performance boost.\n\n0.11.0\n======\n\nWarning: this release changes how Dalli marshals data.  I do not guarantee compatibility until 1.0 but I will increment the minor version every time a release breaks compatibility until 1.0.\n\nIT IS HIGHLY RECOMMENDED YOU FLUSH YOUR CACHE BEFORE UPGRADING.\n\n - multi() now works reentrantly.\n - Added new Dalli::Client option for default TTLs, :expires_in, defaults to 0 (aka forever).\n - Added new Dalli::Client option, :compression, to enable auto-compression of values.\n - Refactor how Dalli stores data on the server.  Values are now tagged\n   as \"marshalled\" or \"compressed\" so they can be automatically deserialized\n   without the client having to know how they were stored.\n\n0.10.1\n======\n\n - Prefer server config from environment, fixes Heroku session store issues (thanks JoshMcKin)\n - Better handling of non-ASCII values (size -> bytesize)\n - Assert that keys are ASCII only\n\n0.10.0\n======\n\nWarning: this release changed how Rails marshals data with Dalli.  Unfortunately previous versions double marshalled values.  It is possible that data stored with previous versions of Dalli will not work with this version.\n\nIT IS HIGHLY RECOMMENDED YOU FLUSH YOUR CACHE BEFORE UPGRADING.\n\n - Rework how the Rails cache store does value marshalling.\n - Rework old server version detection to avoid a socket read hang.\n - Refactor the Rails 2.3 :dalli\\_store to be closer to :mem\\_cache\\_store.\n - Better documentation for session store config (plukevdh)\n\n0.9.10\n----\n\n - Better server retry logic (next2you)\n - Rails 3.1 compatibility (gucki)\n\n\n0.9.9\n----\n\n - Add support for *_multi operations for add, set, replace and delete.  This implements\n   pipelined network operations; Dalli disables network replies so we're not limited by\n   latency, allowing for much higher throughput.\n\n    dc = Dalli::Client.new\n    dc.multi do\n      dc.set 'a', 1\n      dc.set 'b', 2\n      dc.set 'c', 3\n      dc.delete 'd'\n    end\n - Minor fix to set the continuum sorted by value (kangster)\n - Implement session store with Rails 2.3.  Update docs.\n\n0.9.8\n-----\n\n - Implement namespace support\n - Misc fixes\n\n\n0.9.7\n-----\n\n - Small fix for NewRelic integration.\n - Detect and fail on older memcached servers (pre-1.4).\n\n0.9.6\n-----\n\n - Patches for Rails 3.0.1 integration.\n\n0.9.5\n-----\n\n - Major design change - raw support is back to maximize compatibility with Rails\n and the increment/decrement operations.  You can now pass :raw => true to most methods\n to bypass (un)marshalling.\n - Support symbols as keys (ddollar)\n - Rails 2.3 bug fixes\n\n\n0.9.4\n-----\n\n - Dalli support now in rack-bug (http://github.com/brynary/rack-bug), give it a try!\n - Namespace support for Rails 2.3 (bpardee)\n - Bug fixes\n\n\n0.9.3\n-----\n\n - Rails 2.3 support (beanieboi)\n - Rails SessionStore support\n - Passenger integration\n - memcache-client upgrade docs, see Upgrade.md\n\n\n0.9.2\n----\n\n - Verify proper operation in Heroku.\n\n\n0.9.1\n----\n\n - Add fetch and cas operations (mperham)\n - Add incr and decr operations (mperham)\n - Initial support for SASL authentication via the MEMCACHE_{USERNAME,PASSWORD} environment variables, needed for Heroku (mperham)\n\n0.9.0\n-----\n\n - Initial gem release.\n", "# frozen_string_literal: true\n\nrequire 'forwardable'\nrequire 'socket'\nrequire 'timeout'\n\nmodule Dalli\n  module Protocol\n    ##\n    # Access point for a single Memcached server, accessed via Memcached's meta\n    # protocol.  Contains logic for managing connection state to the server (retries, etc),\n    # formatting requests to the server, and unpacking responses.\n    ##\n    class Meta < Base\n      TERMINATOR = \"\\r\\n\"\n\n      def response_processor\n        @response_processor ||= ResponseProcessor.new(@connection_manager, @value_marshaller)\n      end\n\n      # NOTE: Additional public methods should be overridden in Dalli::Threadsafe\n\n      private\n\n      # Retrieval Commands\n      def get(key, options = nil)\n        encoded_key, base64 = KeyRegularizer.encode(key)\n        req = RequestFormatter.meta_get(key: encoded_key, base64: base64)\n        write(req)\n        response_processor.meta_get_with_value(cache_nils: cache_nils?(options))\n      end\n\n      def quiet_get_request(key)\n        encoded_key, base64 = KeyRegularizer.encode(key)\n        RequestFormatter.meta_get(key: encoded_key, return_cas: true, base64: base64, quiet: true)\n      end\n\n      def gat(key, ttl, options = nil)\n        ttl = TtlSanitizer.sanitize(ttl)\n        encoded_key, base64 = KeyRegularizer.encode(key)\n        req = RequestFormatter.meta_get(key: encoded_key, ttl: ttl, base64: base64)\n        write(req)\n        response_processor.meta_get_with_value(cache_nils: cache_nils?(options))\n      end\n\n      def touch(key, ttl)\n        encoded_key, base64 = KeyRegularizer.encode(key)\n        req = RequestFormatter.meta_get(key: encoded_key, ttl: ttl, value: false, base64: base64)\n        write(req)\n        response_processor.meta_get_without_value\n      end\n\n      # TODO: This is confusing, as there's a cas command in memcached\n      # and this isn't it.  Maybe rename?  Maybe eliminate?\n      def cas(key)\n        encoded_key, base64 = KeyRegularizer.encode(key)\n        req = RequestFormatter.meta_get(key: encoded_key, value: true, return_cas: true, base64: base64)\n        write(req)\n        response_processor.meta_get_with_value_and_cas\n      end\n\n      # Storage Commands\n      def set(key, value, ttl, cas, options)\n        write_storage_req(:set, key, value, ttl, cas, options)\n        response_processor.meta_set_with_cas unless quiet?\n      end\n\n      def add(key, value, ttl, options)\n        write_storage_req(:add, key, value, ttl, nil, options)\n        response_processor.meta_set_with_cas unless quiet?\n      end\n\n      def replace(key, value, ttl, cas, options)\n        write_storage_req(:replace, key, value, ttl, cas, options)\n        response_processor.meta_set_with_cas unless quiet?\n      end\n\n      # rubocop:disable Metrics/ParameterLists\n      def write_storage_req(mode, key, raw_value, ttl = nil, cas = nil, options = {})\n        (value, bitflags) = @value_marshaller.store(key, raw_value, options)\n        ttl = TtlSanitizer.sanitize(ttl) if ttl\n        encoded_key, base64 = KeyRegularizer.encode(key)\n        req = RequestFormatter.meta_set(key: encoded_key, value: value,\n                                        bitflags: bitflags, cas: cas,\n                                        ttl: ttl, mode: mode, quiet: quiet?, base64: base64)\n        write(req)\n      end\n      # rubocop:enable Metrics/ParameterLists\n\n      def append(key, value)\n        write_append_prepend_req(:append, key, value)\n        response_processor.meta_set_append_prepend unless quiet?\n      end\n\n      def prepend(key, value)\n        write_append_prepend_req(:prepend, key, value)\n        response_processor.meta_set_append_prepend unless quiet?\n      end\n\n      # rubocop:disable Metrics/ParameterLists\n      def write_append_prepend_req(mode, key, value, ttl = nil, cas = nil, _options = {})\n        ttl = TtlSanitizer.sanitize(ttl) if ttl\n        encoded_key, base64 = KeyRegularizer.encode(key)\n        req = RequestFormatter.meta_set(key: encoded_key, value: value, base64: base64,\n                                        cas: cas, ttl: ttl, mode: mode, quiet: quiet?)\n        write(req)\n      end\n      # rubocop:enable Metrics/ParameterLists\n\n      # Delete Commands\n      def delete(key, cas)\n        encoded_key, base64 = KeyRegularizer.encode(key)\n        req = RequestFormatter.meta_delete(key: encoded_key, cas: cas,\n                                           base64: base64, quiet: quiet?)\n        write(req)\n        response_processor.meta_delete unless quiet?\n      end\n\n      # Arithmetic Commands\n      def decr(key, count, ttl, initial)\n        decr_incr false, key, count, ttl, initial\n      end\n\n      def incr(key, count, ttl, initial)\n        decr_incr true, key, count, ttl, initial\n      end\n\n      def decr_incr(incr, key, delta, ttl, initial)\n        ttl = initial ? TtlSanitizer.sanitize(ttl) : nil # Only set a TTL if we want to set a value on miss\n        encoded_key, base64 = KeyRegularizer.encode(key)\n        write(RequestFormatter.meta_arithmetic(key: encoded_key, delta: delta, initial: initial, incr: incr, ttl: ttl,\n                                               quiet: quiet?, base64: base64))\n        response_processor.decr_incr unless quiet?\n      end\n\n      # Other Commands\n      def flush(delay = 0)\n        write(RequestFormatter.flush(delay: delay))\n        response_processor.flush unless quiet?\n      end\n\n      # Noop is a keepalive operation but also used to demarcate the end of a set of pipelined commands.\n      # We need to read all the responses at once.\n      def noop\n        write_noop\n        response_processor.consume_all_responses_until_mn\n      end\n\n      def stats(info = nil)\n        write(RequestFormatter.stats(info))\n        response_processor.stats\n      end\n\n      def reset_stats\n        write(RequestFormatter.stats('reset'))\n        response_processor.reset\n      end\n\n      def version\n        write(RequestFormatter.version)\n        response_processor.version\n      end\n\n      def write_noop\n        write(RequestFormatter.meta_noop)\n      end\n\n      def authenticate_connection\n        raise Dalli::DalliError, 'Authentication not supported for the meta protocol.'\n      end\n\n      require_relative 'meta/key_regularizer'\n      require_relative 'meta/request_formatter'\n      require_relative 'meta/response_processor'\n    end\n  end\nend\n", "# frozen_string_literal: false\n\nmodule Dalli\n  module Protocol\n    class Meta\n      ##\n      # Class that encapsulates logic for formatting meta protocol requests\n      # to memcached.\n      ##\n      class RequestFormatter\n        # Since these are string construction methods, we're going to disable these\n        # Rubocop directives.  We really can't make this construction much simpler,\n        # and introducing an intermediate object seems like overkill.\n        #\n        # rubocop:disable Metrics/CyclomaticComplexity\n        # rubocop:disable Metrics/MethodLength\n        # rubocop:disable Metrics/ParameterLists\n        # rubocop:disable Metrics/PerceivedComplexity\n        def self.meta_get(key:, value: true, return_cas: false, ttl: nil, base64: false, quiet: false)\n          cmd = \"mg #{key}\"\n          cmd << ' v f' if value\n          cmd << ' c' if return_cas\n          cmd << ' b' if base64\n          cmd << \" T#{ttl}\" if ttl\n          cmd << ' k q s' if quiet # Return the key in the response if quiet\n          cmd + TERMINATOR\n        end\n\n        def self.meta_set(key:, value:, bitflags: nil, cas: nil, ttl: nil, mode: :set, base64: false, quiet: false)\n          cmd = \"ms #{key} #{value.bytesize}\"\n          cmd << ' c' unless %i[append prepend].include?(mode)\n          cmd << ' b' if base64\n          cmd << \" F#{bitflags}\" if bitflags\n          cmd << \" C#{cas}\" if cas && !cas.zero?\n          cmd << \" T#{ttl}\" if ttl\n          cmd << \" M#{mode_to_token(mode)}\"\n          cmd << ' q' if quiet\n          cmd << TERMINATOR\n          cmd << value\n          cmd + TERMINATOR\n        end\n\n        def self.meta_delete(key:, cas: nil, ttl: nil, base64: false, quiet: false)\n          cmd = \"md #{key}\"\n          cmd << ' b' if base64\n          cmd << \" C#{cas}\" if cas && !cas.zero?\n          cmd << \" T#{ttl}\" if ttl\n          cmd << ' q' if quiet\n          cmd + TERMINATOR\n        end\n\n        def self.meta_arithmetic(key:, delta:, initial:, incr: true, cas: nil, ttl: nil, base64: false, quiet: false)\n          cmd = \"ma #{key} v\"\n          cmd << ' b' if base64\n          cmd << \" D#{delta}\" if delta\n          cmd << \" J#{initial}\" if initial\n          cmd << \" C#{cas}\" if cas && !cas.zero?\n          cmd << \" N#{ttl}\" if ttl\n          cmd << ' q' if quiet\n          cmd << \" M#{incr ? 'I' : 'D'}\"\n          cmd + TERMINATOR\n        end\n        # rubocop:enable Metrics/CyclomaticComplexity\n        # rubocop:enable Metrics/MethodLength\n        # rubocop:enable Metrics/ParameterLists\n        # rubocop:enable Metrics/PerceivedComplexity\n\n        def self.meta_noop\n          \"mn#{TERMINATOR}\"\n        end\n\n        def self.version\n          \"version#{TERMINATOR}\"\n        end\n\n        def self.flush(delay: nil, quiet: false)\n          cmd = +'flush_all'\n          cmd << \" #{delay}\" if delay\n          cmd << ' noreply' if quiet\n          cmd + TERMINATOR\n        end\n\n        def self.stats(arg = nil)\n          cmd = +'stats'\n          cmd << \" #{arg}\" if arg\n          cmd + TERMINATOR\n        end\n\n        # rubocop:disable Metrics/MethodLength\n        def self.mode_to_token(mode)\n          case mode\n          when :add\n            'E'\n          when :replace\n            'R'\n          when :append\n            'A'\n          when :prepend\n            'P'\n          else\n            'S'\n          end\n        end\n        # rubocop:enable Metrics/MethodLength\n      end\n    end\n  end\nend\n", "# frozen_string_literal: true\n\nrequire_relative '../helper'\n\ndescribe 'Network' do\n  MemcachedManager.supported_protocols.each do |p|\n    describe \"using the #{p} protocol\" do\n      describe 'assuming a bad network' do\n        it 'handle no server available' do\n          assert_raises Dalli::RingError, message: 'No server available' do\n            dc = Dalli::Client.new 'localhost:19333'\n            dc.get 'foo'\n          end\n        end\n\n        describe 'with a fake server' do\n          it 'handle connection reset' do\n            memcached_mock(->(sock) { sock.close }) do\n              assert_raises Dalli::RingError, message: 'No server available' do\n                dc = Dalli::Client.new('localhost:19123')\n                dc.get('abc')\n              end\n            end\n          end\n\n          it 'handle connection reset with unix socket' do\n            socket_path = MemcachedMock::UNIX_SOCKET_PATH\n            memcached_mock(->(sock) { sock.close }, :start_unix, socket_path) do\n              assert_raises Dalli::RingError, message: 'No server available' do\n                dc = Dalli::Client.new(socket_path)\n                dc.get('abc')\n              end\n            end\n          end\n\n          it 'handle malformed response' do\n            memcached_mock(->(sock) { sock.write('123') }) do\n              assert_raises Dalli::RingError, message: 'No server available' do\n                dc = Dalli::Client.new('localhost:19123')\n                dc.get('abc')\n              end\n            end\n          end\n\n          it 'handle connect timeouts' do\n            memcached_mock(lambda { |sock|\n                             sleep(0.6)\n                             sock.close\n                           }, :delayed_start) do\n              assert_raises Dalli::RingError, message: 'No server available' do\n                dc = Dalli::Client.new('localhost:19123')\n                dc.get('abc')\n              end\n            end\n          end\n\n          it 'handle read timeouts' do\n            memcached_mock(lambda { |sock|\n                             sleep(0.6)\n                             sock.write('giraffe')\n                           }) do\n              assert_raises Dalli::RingError, message: 'No server available' do\n                dc = Dalli::Client.new('localhost:19123')\n                dc.get('abc')\n              end\n            end\n          end\n        end\n\n        it 'opens a standard TCP connection when ssl_context is not configured' do\n          memcached_persistent(p) do |dc|\n            server = dc.send(:ring).servers.first\n            sock = Dalli::Socket::TCP.open(server.hostname, server.port, server.options)\n            assert_equal Dalli::Socket::TCP, sock.class\n\n            dc.set('abc', 123)\n            assert_equal(123, dc.get('abc'))\n          end\n        end\n\n        it 'opens a SSL TCP connection when there is an SSL context set' do\n          memcached_ssl_persistent(p) do |dc|\n            server = dc.send(:ring).servers.first\n            sock = Dalli::Socket::TCP.open(server.hostname, server.port, server.options)\n            assert_equal Dalli::Socket::SSLSocket, sock.class\n\n            dc.set('abc', 123)\n            assert_equal(123, dc.get('abc'))\n\n            # Confirm that pipelined get works, since this depends on attributes on\n            # the socket\n            assert_equal({ 'abc' => 123 }, dc.get_multi(['abc']))\n          end\n        end\n\n        it 'allow TCP connections to be configured for keepalive' do\n          memcached_persistent(p) do |_, port|\n            dc = Dalli::Client.new(\"localhost:#{port}\", keepalive: true)\n            dc.set(:a, 1)\n            ring = dc.send(:ring)\n            server = ring.servers.first\n            socket = server.sock\n\n            optval = socket.getsockopt(Socket::SOL_SOCKET, Socket::SO_KEEPALIVE)\n            optval = optval.unpack 'i'\n\n            refute_equal(optval[0], 0)\n          end\n        end\n      end\n\n      it 'passes a simple smoke test on a TCP socket' do\n        memcached_persistent(p) do |dc, port|\n          resp = dc.flush\n          refute_nil resp\n          assert_equal [true, true], resp\n\n          assert op_addset_succeeds(dc.set(:foo, 'bar'))\n          assert_equal 'bar', dc.get(:foo)\n\n          resp = dc.get('123')\n          assert_nil resp\n\n          assert op_addset_succeeds(dc.set('123', 'xyz'))\n\n          resp = dc.get('123')\n          assert_equal 'xyz', resp\n\n          assert op_addset_succeeds(dc.set('123', 'abc'))\n\n          dc.prepend('123', '0')\n          dc.append('123', '0')\n\n          assert_raises Dalli::UnmarshalError do\n            resp = dc.get('123')\n          end\n\n          dc.close\n          dc = nil\n\n          dc = Dalli::Client.new(\"localhost:#{port}\", digest_class: ::OpenSSL::Digest::SHA1)\n\n          assert op_addset_succeeds(dc.set('456', 'xyz', 0, raw: true))\n\n          resp = dc.prepend '456', '0'\n          assert resp\n\n          resp = dc.append '456', '9'\n          assert resp\n\n          resp = dc.get('456', raw: true)\n          assert_equal '0xyz9', resp\n\n          assert op_addset_succeeds(dc.set('456', false))\n\n          resp = dc.get('456')\n          refute resp\n\n          resp = dc.stats\n          assert_equal Hash, resp.class\n\n          dc.close\n        end\n      end\n\n      it 'passes a simple smoke test on unix socket' do\n        memcached_persistent(:binary, MemcachedMock::UNIX_SOCKET_PATH) do |dc, path|\n          resp = dc.flush\n          refute_nil resp\n          assert_equal [true], resp\n\n          assert op_addset_succeeds(dc.set(:foo, 'bar'))\n          assert_equal 'bar', dc.get(:foo)\n\n          resp = dc.get('123')\n          assert_nil resp\n\n          assert op_addset_succeeds(dc.set('123', 'xyz'))\n\n          resp = dc.get('123')\n          assert_equal 'xyz', resp\n\n          assert op_addset_succeeds(dc.set('123', 'abc'))\n\n          dc.prepend('123', '0')\n          dc.append('123', '0')\n\n          assert_raises Dalli::UnmarshalError do\n            resp = dc.get('123')\n          end\n\n          dc.close\n          dc = nil\n\n          dc = Dalli::Client.new(path)\n\n          assert op_addset_succeeds(dc.set('456', 'xyz', 0, raw: true))\n\n          resp = dc.prepend '456', '0'\n          assert resp\n\n          resp = dc.append '456', '9'\n          assert resp\n\n          resp = dc.get('456', raw: true)\n          assert_equal '0xyz9', resp\n\n          assert op_addset_succeeds(dc.set('456', false))\n\n          resp = dc.get('456')\n          refute resp\n\n          resp = dc.stats\n          assert_equal Hash, resp.class\n\n          dc.close\n        end\n      end\n    end\n  end\nend\n", "# frozen_string_literal: true\n\nrequire_relative '../../helper'\n\ndescribe Dalli::Protocol::Meta::RequestFormatter do\n  describe 'meta_get' do\n    let(:key) { SecureRandom.hex(4) }\n    let(:ttl) { rand(1000..1999) }\n\n    it 'returns the default get (get value and bitflags, no cas) when passed only a key' do\n      assert_equal \"mg #{key} v f\\r\\n\", Dalli::Protocol::Meta::RequestFormatter.meta_get(key: key)\n    end\n\n    it 'sets the TTL flag when passed a ttl' do\n      assert_equal \"mg #{key} v f T#{ttl}\\r\\n\",\n                   Dalli::Protocol::Meta::RequestFormatter.meta_get(key: key, ttl: ttl)\n    end\n\n    it 'skips the value and bitflags when passed a pure touch argument' do\n      assert_equal \"mg #{key} T#{ttl}\\r\\n\",\n                   Dalli::Protocol::Meta::RequestFormatter.meta_get(key: key, value: false, ttl: ttl)\n    end\n\n    it 'sets the CAS retrieval flags when passed that value' do\n      assert_equal \"mg #{key} c\\r\\n\",\n                   Dalli::Protocol::Meta::RequestFormatter.meta_get(key: key, value: false, return_cas: true)\n    end\n\n    it 'sets the flags for returning the key and body size when passed quiet' do\n      assert_equal \"mg #{key} v f k q s\\r\\n\",\n                   Dalli::Protocol::Meta::RequestFormatter.meta_get(key: key, quiet: true)\n    end\n  end\n\n  describe 'meta_set' do\n    let(:key) { SecureRandom.hex(4) }\n    let(:hexlen) { rand(500..999) }\n    let(:val) { SecureRandom.hex(hexlen) }\n    let(:bitflags) { (0..3).to_a.sample }\n    let(:cas) { rand(500..999) }\n    let(:ttl) { rand(500..999) }\n\n    it 'returns the default (treat as a set, no CAS check) when just passed key, datalen, and bitflags' do\n      assert_equal \"ms #{key} #{val.bytesize} c F#{bitflags} MS\\r\\n#{val}\\r\\n\",\n                   Dalli::Protocol::Meta::RequestFormatter.meta_set(key: key, value: val, bitflags: bitflags)\n    end\n\n    it 'supports the add mode' do\n      assert_equal \"ms #{key} #{val.bytesize} c F#{bitflags} ME\\r\\n#{val}\\r\\n\",\n                   Dalli::Protocol::Meta::RequestFormatter.meta_set(key: key, value: val, bitflags: bitflags,\n                                                                    mode: :add)\n    end\n\n    it 'supports the replace mode' do\n      assert_equal \"ms #{key} #{val.bytesize} c F#{bitflags} MR\\r\\n#{val}\\r\\n\",\n                   Dalli::Protocol::Meta::RequestFormatter.meta_set(key: key, value: val, bitflags: bitflags,\n                                                                    mode: :replace)\n    end\n\n    it 'passes a TTL if one is provided' do\n      assert_equal \"ms #{key} #{val.bytesize} c F#{bitflags} T#{ttl} MS\\r\\n#{val}\\r\\n\",\n                   Dalli::Protocol::Meta::RequestFormatter.meta_set(key: key, value: val, ttl: ttl, bitflags: bitflags)\n    end\n\n    it 'omits the CAS flag on append' do\n      assert_equal \"ms #{key} #{val.bytesize} MA\\r\\n#{val}\\r\\n\",\n                   Dalli::Protocol::Meta::RequestFormatter.meta_set(key: key, value: val, mode: :append)\n    end\n\n    it 'omits the CAS flag on prepend' do\n      assert_equal \"ms #{key} #{val.bytesize} MP\\r\\n#{val}\\r\\n\",\n                   Dalli::Protocol::Meta::RequestFormatter.meta_set(key: key, value: val, mode: :prepend)\n    end\n\n    it 'passes a CAS if one is provided' do\n      assert_equal \"ms #{key} #{val.bytesize} c F#{bitflags} C#{cas} MS\\r\\n#{val}\\r\\n\",\n                   Dalli::Protocol::Meta::RequestFormatter.meta_set(key: key, value: val, bitflags: bitflags, cas: cas)\n    end\n\n    it 'sets the quiet mode if configured' do\n      assert_equal \"ms #{key} #{val.bytesize} c F#{bitflags} MS q\\r\\n#{val}\\r\\n\",\n                   Dalli::Protocol::Meta::RequestFormatter.meta_set(key: key, value: val, bitflags: bitflags,\n                                                                    quiet: true)\n    end\n  end\n\n  describe 'meta_delete' do\n    let(:key) { SecureRandom.hex(4) }\n    let(:cas) { rand(1000..1999) }\n\n    it 'returns the default when just passed key' do\n      assert_equal \"md #{key}\\r\\n\",\n                   Dalli::Protocol::Meta::RequestFormatter.meta_delete(key: key)\n    end\n\n    it 'returns incorporates CAS when passed cas' do\n      assert_equal \"md #{key} C#{cas}\\r\\n\",\n                   Dalli::Protocol::Meta::RequestFormatter.meta_delete(key: key, cas: cas)\n    end\n\n    it 'sets the q flag when passed quiet' do\n      assert_equal \"md #{key} q\\r\\n\",\n                   Dalli::Protocol::Meta::RequestFormatter.meta_delete(key: key, quiet: true)\n    end\n  end\n\n  describe 'meta_noop' do\n    it 'returns the expected string' do\n      assert_equal \"mn\\r\\n\", Dalli::Protocol::Meta::RequestFormatter.meta_noop\n    end\n  end\n\n  describe 'version' do\n    it 'returns the expected string' do\n      assert_equal \"version\\r\\n\", Dalli::Protocol::Meta::RequestFormatter.version\n    end\n  end\n\n  describe 'flush' do\n    it 'returns the expected string with no arguments' do\n      assert_equal \"flush_all\\r\\n\", Dalli::Protocol::Meta::RequestFormatter.flush\n    end\n\n    it 'adds noreply when quiet is true' do\n      assert_equal \"flush_all noreply\\r\\n\", Dalli::Protocol::Meta::RequestFormatter.flush(quiet: true)\n    end\n\n    it 'returns the expected string with a delay argument' do\n      delay = rand(1000..1999)\n      assert_equal \"flush_all #{delay}\\r\\n\", Dalli::Protocol::Meta::RequestFormatter.flush(delay: delay)\n    end\n\n    it 'adds noreply with a delay and quiet argument' do\n      delay = rand(1000..1999)\n      assert_equal \"flush_all #{delay} noreply\\r\\n\",\n                   Dalli::Protocol::Meta::RequestFormatter.flush(delay: delay, quiet: true)\n    end\n  end\nend\n", "# frozen_string_literal: true\n\nrequire_relative 'helper'\n\nrequire 'json'\nrequire 'rack/session/dalli'\nrequire 'rack/lint'\nrequire 'rack/mock'\ndescribe Rack::Session::Dalli do\n  before do\n    @port = 19_129\n    memcached_persistent(:binary, @port)\n    Rack::Session::Dalli::DEFAULT_DALLI_OPTIONS[:memcache_server] = \"localhost:#{@port}\"\n\n    # test memcache connection\n    Rack::Session::Dalli.new(incrementor)\n  end\n\n  let(:session_key) { Rack::Session::Dalli::DEFAULT_OPTIONS[:key] }\n  let(:session_match) do\n    /#{session_key}=([0-9a-fA-F]+);/\n  end\n  let(:incrementor_proc) do\n    lambda do |env|\n      env['rack.session']['counter'] ||= 0\n      env['rack.session']['counter'] += 1\n      Rack::Response.new(env['rack.session'].inspect).to_a\n    end\n  end\n  let(:drop_session) do\n    Rack::Lint.new(proc do |env|\n                     env['rack.session.options'][:drop] = true\n                     incrementor_proc.call(env)\n                   end)\n  end\n  let(:renew_session) do\n    Rack::Lint.new(proc do |env|\n                     env['rack.session.options'][:renew] = true\n                     incrementor_proc.call(env)\n                   end)\n  end\n  let(:defer_session) do\n    Rack::Lint.new(proc do |env|\n                     env['rack.session.options'][:defer] = true\n                     incrementor_proc.call(env)\n                   end)\n  end\n  let(:skip_session) do\n    Rack::Lint.new(proc do |env|\n                     env['rack.session.options'][:skip] = true\n                     incrementor_proc.call(env)\n                   end)\n  end\n  let(:incrementor) { Rack::Lint.new(incrementor_proc) }\n\n  it 'faults on no connection' do\n    assert_raises Dalli::RingError do\n      rsd = Rack::Session::Dalli.new(incrementor, memcache_server: 'nosuchserver')\n      rsd.data.with { |c| c.set('ping', '') }\n    end\n  end\n\n  it 'connects to existing server' do\n    assert_silent do\n      rsd = Rack::Session::Dalli.new(incrementor, namespace: 'test:rack:session')\n      rsd.data.with { |c| c.set('ping', '') }\n    end\n  end\n\n  it 'passes options to MemCache' do\n    opts = {\n      namespace: 'test:rack:session',\n      compression_min_size: 1234\n    }\n\n    rsd = Rack::Session::Dalli.new(incrementor, opts)\n    assert_equal(opts[:namespace], rsd.data.with { |c| c.instance_eval { @options[:namespace] } })\n    assert_equal(opts[:compression_min_size], rsd.data.with { |c| c.instance_eval { @options[:compression_min_size] } })\n  end\n\n  it 'rejects a :cache option' do\n    server = Rack::Session::Dalli::DEFAULT_DALLI_OPTIONS[:memcache_server]\n    cache = Dalli::Client.new(server, namespace: 'test:rack:session')\n    assert_raises RuntimeError do\n      Rack::Session::Dalli.new(incrementor, cache: cache, namespace: 'foobar')\n    end\n  end\n\n  it 'generates sids without an existing Dalli::Client' do\n    rsd = Rack::Session::Dalli.new(incrementor)\n    assert rsd.send :generate_sid\n  end\n\n  it 'upgrades to a connection pool' do\n    opts = {\n      namespace: 'test:rack:session',\n      pool_size: 10\n    }\n\n    with_connectionpool do\n      rsd = Rack::Session::Dalli.new(incrementor, opts)\n      assert_equal 10, rsd.data.available\n      rsd.data.with do |mc|\n        assert_equal(opts[:namespace], mc.instance_eval { @options[:namespace] })\n      end\n    end\n  end\n\n  it 'creates a new cookie' do\n    rsd = Rack::Session::Dalli.new(incrementor)\n    res = Rack::MockRequest.new(rsd).get('/')\n    assert_includes res['Set-Cookie'], \"#{session_key}=\"\n    assert_equal '{\"counter\"=>1}', res.body\n  end\n\n  it 'determines session from a cookie' do\n    rsd = Rack::Session::Dalli.new(incrementor)\n    req = Rack::MockRequest.new(rsd)\n    res = req.get('/')\n    cookie = res['Set-Cookie']\n    assert_equal '{\"counter\"=>2}', req.get('/', 'HTTP_COOKIE' => cookie).body\n    assert_equal '{\"counter\"=>3}', req.get('/', 'HTTP_COOKIE' => cookie).body\n  end\n\n  it 'determines session only from a cookie by default' do\n    rsd = Rack::Session::Dalli.new(incrementor)\n    req = Rack::MockRequest.new(rsd)\n    res = req.get('/')\n    sid = res['Set-Cookie'][session_match, 1]\n    assert_equal '{\"counter\"=>1}', req.get(\"/?rack.session=#{sid}\").body\n    assert_equal '{\"counter\"=>1}', req.get(\"/?rack.session=#{sid}\").body\n  end\n\n  it 'determines session from params' do\n    rsd = Rack::Session::Dalli.new(incrementor, cookie_only: false)\n    req = Rack::MockRequest.new(rsd)\n    res = req.get('/')\n    sid = res['Set-Cookie'][session_match, 1]\n    assert_equal '{\"counter\"=>2}', req.get(\"/?rack.session=#{sid}\").body\n    assert_equal '{\"counter\"=>3}', req.get(\"/?rack.session=#{sid}\").body\n  end\n\n  it 'survives nonexistant cookies' do\n    bad_cookie = 'rack.session=blarghfasel'\n    rsd = Rack::Session::Dalli.new(incrementor)\n    res = Rack::MockRequest.new(rsd)\n                           .get('/', 'HTTP_COOKIE' => bad_cookie)\n    assert_equal '{\"counter\"=>1}', res.body\n    cookie = res['Set-Cookie'][session_match]\n    refute_match(/#{bad_cookie}/, cookie)\n  end\n\n  it 'survives nonexistant blank cookies' do\n    bad_cookie = 'rack.session='\n    rsd = Rack::Session::Dalli.new(incrementor)\n    res = Rack::MockRequest.new(rsd)\n                           .get('/', 'HTTP_COOKIE' => bad_cookie)\n    cookie = res['Set-Cookie'][session_match]\n    refute_match(/#{bad_cookie}$/, cookie)\n  end\n\n  it 'sets an expiration on new sessions' do\n    rsd = Rack::Session::Dalli.new(incrementor, expire_after: 3)\n    res = Rack::MockRequest.new(rsd).get('/')\n    assert_includes res.body, '\"counter\"=>1'\n    cookie = res['Set-Cookie']\n    puts 'Sleeping to expire session' if $DEBUG\n    sleep 4\n    res = Rack::MockRequest.new(rsd).get('/', 'HTTP_COOKIE' => cookie)\n    refute_equal cookie, res['Set-Cookie']\n    assert_includes res.body, '\"counter\"=>1'\n  end\n\n  it 'maintains freshness of existing sessions' do\n    rsd = Rack::Session::Dalli.new(incrementor, expire_after: 3)\n    res = Rack::MockRequest.new(rsd).get('/')\n    assert_includes res.body, '\"counter\"=>1'\n    cookie = res['Set-Cookie']\n    res = Rack::MockRequest.new(rsd).get('/', 'HTTP_COOKIE' => cookie)\n    assert_equal cookie, res['Set-Cookie']\n    assert_includes res.body, '\"counter\"=>2'\n    puts 'Sleeping to expire session' if $DEBUG\n    sleep 4\n    res = Rack::MockRequest.new(rsd).get('/', 'HTTP_COOKIE' => cookie)\n    refute_equal cookie, res['Set-Cookie']\n    assert_includes res.body, '\"counter\"=>1'\n  end\n\n  it 'does not send the same session id if it did not change' do\n    rsd = Rack::Session::Dalli.new(incrementor)\n    req = Rack::MockRequest.new(rsd)\n\n    res0 = req.get('/')\n    cookie = res0['Set-Cookie'][session_match]\n    assert_equal '{\"counter\"=>1}', res0.body\n\n    res1 = req.get('/', 'HTTP_COOKIE' => cookie)\n    assert_nil res1['Set-Cookie']\n    assert_equal '{\"counter\"=>2}', res1.body\n\n    res2 = req.get('/', 'HTTP_COOKIE' => cookie)\n    assert_nil res2['Set-Cookie']\n    assert_equal '{\"counter\"=>3}', res2.body\n  end\n\n  it 'deletes cookies with :drop option' do\n    rsd = Rack::Session::Dalli.new(incrementor)\n    req = Rack::MockRequest.new(rsd)\n    drop = Rack::Utils::Context.new(rsd, drop_session)\n    dreq = Rack::MockRequest.new(drop)\n\n    res1 = req.get('/')\n    session = (cookie = res1['Set-Cookie'])[session_match]\n    assert_equal '{\"counter\"=>1}', res1.body\n\n    res2 = dreq.get('/', 'HTTP_COOKIE' => cookie)\n    assert_nil res2['Set-Cookie']\n    assert_equal '{\"counter\"=>2}', res2.body\n\n    res3 = req.get('/', 'HTTP_COOKIE' => cookie)\n    refute_equal session, res3['Set-Cookie'][session_match]\n    assert_equal '{\"counter\"=>1}', res3.body\n  end\n\n  it 'provides new session id with :renew option' do\n    rsd = Rack::Session::Dalli.new(incrementor)\n    req = Rack::MockRequest.new(rsd)\n    renew = Rack::Utils::Context.new(rsd, renew_session)\n    rreq = Rack::MockRequest.new(renew)\n\n    res1 = req.get('/')\n    session = (cookie = res1['Set-Cookie'])[session_match]\n    assert_equal '{\"counter\"=>1}', res1.body\n\n    res2 = rreq.get('/', 'HTTP_COOKIE' => cookie)\n    new_cookie = res2['Set-Cookie']\n    new_session = new_cookie[session_match]\n    refute_equal session, new_session\n    assert_equal '{\"counter\"=>2}', res2.body\n\n    res3 = req.get('/', 'HTTP_COOKIE' => new_cookie)\n    assert_equal '{\"counter\"=>3}', res3.body\n\n    # Old cookie was deleted\n    res4 = req.get('/', 'HTTP_COOKIE' => cookie)\n    assert_equal '{\"counter\"=>1}', res4.body\n  end\n\n  it 'omits cookie with :defer option but still updates the state' do\n    rsd = Rack::Session::Dalli.new(incrementor)\n    count = Rack::Utils::Context.new(rsd, incrementor)\n    defer = Rack::Utils::Context.new(rsd, defer_session)\n    dreq = Rack::MockRequest.new(defer)\n    creq = Rack::MockRequest.new(count)\n\n    res0 = dreq.get('/')\n    assert_nil res0['Set-Cookie']\n    assert_equal '{\"counter\"=>1}', res0.body\n\n    res0 = creq.get('/')\n    res1 = dreq.get('/', 'HTTP_COOKIE' => res0['Set-Cookie'])\n    assert_equal '{\"counter\"=>2}', res1.body\n    res2 = dreq.get('/', 'HTTP_COOKIE' => res0['Set-Cookie'])\n    assert_equal '{\"counter\"=>3}', res2.body\n  end\n\n  it 'omits cookie and state update with :skip option' do\n    rsd = Rack::Session::Dalli.new(incrementor)\n    count = Rack::Utils::Context.new(rsd, incrementor)\n    skip = Rack::Utils::Context.new(rsd, skip_session)\n    sreq = Rack::MockRequest.new(skip)\n    creq = Rack::MockRequest.new(count)\n\n    res0 = sreq.get('/')\n    assert_nil res0['Set-Cookie']\n    assert_equal '{\"counter\"=>1}', res0.body\n\n    res0 = creq.get('/')\n    res1 = sreq.get('/', 'HTTP_COOKIE' => res0['Set-Cookie'])\n    assert_equal '{\"counter\"=>2}', res1.body\n    res2 = sreq.get('/', 'HTTP_COOKIE' => res0['Set-Cookie'])\n    assert_equal '{\"counter\"=>2}', res2.body\n  end\n\n  it 'updates deep hashes correctly' do\n    hash_check = proc do |env|\n      session = env['rack.session']\n      if session.include? 'test'\n        session[:f][:g][:h] = :j\n      else\n        session.update :a => :b, :c => { d: :e },\n                       :f => { g: { h: :i } }, 'test' => true\n      end\n      [200, {}, [session.to_h.to_json]]\n    end\n    rsd = Rack::Session::Dalli.new(hash_check)\n    req = Rack::MockRequest.new(rsd)\n\n    res0 = req.get('/')\n    cookie = res0['Set-Cookie']\n    ses0 = JSON.parse(res0.body)\n    refute_nil ses0\n    assert_equal '{\"a\"=>\"b\", \"c\"=>{\"d\"=>\"e\"}, \"f\"=>{\"g\"=>{\"h\"=>\"i\"}}, \"test\"=>true}', ses0.to_s\n\n    res1 = req.get('/', 'HTTP_COOKIE' => cookie)\n    ses1 = JSON.parse(res1.body)\n    refute_nil ses1\n    assert_equal '{\"a\"=>\"b\", \"c\"=>{\"d\"=>\"e\"}, \"f\"=>{\"g\"=>{\"h\"=>\"j\"}}, \"test\"=>true}', ses1.to_s\n\n    refute_equal ses0, ses1\n  end\nend\n"], "fixing_code": ["Dalli Changelog\n=====================\n\nUnreleased\n==========\n\n- Sanitize CAS inputs to ensure additional commands are not passed to memcached (xhzeem / petergoldstein)\n- Sanitize input to flush command to ensure additional commands are not passed to memcached (xhzeem / petergoldstein)\n- Namespaces passed as procs are now evaluated every time, as opposed to just on initialization (nrw505)\n- Fix missing require of uri in ServerConfigParser (adam12)\n- Fix link to the CHANGELOG.md file in README.md (rud)\n\n3.2.2\n==========\n\n- Ensure apps are resilient against old session ids (kbrock)\n\n3.2.1\n==========\n\n- Fix null replacement bug on some SASL-authenticated services (veritas1)\n\n3.2.0\n==========\n\n- BREAKING CHANGE: Remove protocol_implementation client option (petergoldstein)\n- Add protocol option with meta implementation (petergoldstein)\n\n3.1.6\n==========\n\n- Fix bug with cas/cas! with \"Not found\" value (petergoldstein)\n- Add Ruby 3.1 to CI (petergoldstein)\n- Replace reject(&:nil?) with compact (petergoldstein)\n\n3.1.5\n==========\n\n- Fix bug with get_cas key with \"Not found\" value (petergoldstein)\n- Replace should return nil, not raise error, on miss (petergoldstein)\n\n3.1.4\n==========\n\n- Improve response parsing performance (casperisfine)\n- Reorganize binary protocol parsing a bit (petergoldstein)\n- Fix handling of non-ASCII keys in get_multi (petergoldstein)\n\n3.1.3\n==========\n\n- Restore falsey behavior on delete/delete_cas for nonexistent key (petergoldstein)\n\n3.1.2\n==========\n\n- Make quiet? / multi? public on Dalli::Protocol::Binary (petergoldstein)\n\n3.1.1\n==========\n\n- Add quiet support for incr, decr, append, depend, and flush (petergoldstein)\n- Additional refactoring to allow reuse of connection behavior (petergoldstein)\n- Fix issue in flush such that it wasn't passing the delay argument to memcached (petergoldstein)\n\n3.1.0\n==========\n\n- BREAKING CHANGE: Update Rack::Session::Dalli to inherit from Abstract::PersistedSecure.  This will invalidate existing sessions (petergoldstein)\n- BREAKING CHANGE: Use of unsupported operations in a multi block now raise an error. (petergoldstein)\n- Extract PipelinedGetter from Dalli::Client (petergoldstein)\n- Fix SSL socket so that it works with pipelined gets (petergoldstein)\n- Additional refactoring to split classes (petergoldstein)\n\n3.0.6\n==========\n\n- Fix regression in SASL authentication response parsing (petergoldstein)\n\n3.0.5\n==========\n\n- Add Rubocop and fix most outstanding issues (petergoldstein)\n- Extract a number of classes, to simplify the largest classes (petergoldstein)\n- Ensure against socket corruption if an error occurs in a multi block (petergoldstein)\n\n3.0.4\n==========\n\n- Clean connections and retry after NetworkError in get_multi (andrejbl)\n- Internal refactoring and cleanup (petergoldstein)\n\n3.0.3\n==========\n\n- Restore ability for `compress` to be disabled on a per request basis (petergoldstein)\n- Fix broken image in README (deining)\n- Use bundler-cache in CI (olleolleolle)\n- Remove the OpenSSL extensions dependency (petergoldstein)\n- Add Memcached 1.5.x to the CI matrix\n- Updated compression documentation (petergoldstein)\n\n3.0.2\n==========\n\n- Restore Windows compatibility (petergoldstein)\n- Add JRuby to CI and make requisite changes (petergoldstein)\n- Clarify documentation for supported rubies (petergoldstein)\n\n3.0.1\n==========\n\n- Fix syntax error that prevented inclusion of Dalli::Server (ryanfb)\n- Restore with method required by ActiveSupport::Cache::MemCacheStore\n\n3.0.0\n==========\n- BREAKING CHANGES:\n\n  * Removes :dalli_store.\n    Use Rails' official :mem_cache_store instead.\n    https://guides.rubyonrails.org/caching_with_rails.html\n  * Attempting to store a larger value than allowed by memcached used to\n    print a warning and truncate the value. This now raises an error to\n    prevent silent data corruption.\n  * Compression now defaults to `true` for large values (greater than 4KB).\n    This is intended to minimize errors due to the previous note.\n  * Errors marshalling values now raise rather than just printing an error.\n  * The Rack session adapter has been refactored to remove support for thread-unsafe\n    configurations. You will need to include the `connection_pool` gem in\n    your Gemfile to ensure session operations are thread-safe.\n  * When using namespaces, the algorithm for calculating truncated keys was\n    changed.  Non-truncated keys and truncated keys for the non-namespace\n    case were left unchanged.\n\n- Raise NetworkError when multi response gets into corrupt state (mervync, #783)\n- Validate servers argument (semaperepelitsa, petergoldstein, #776)\n- Enable SSL support (bdunne, #775)\n- Add gat operation (tbeauvais, #769)\n- Removes inline native code, use Ruby 2.3+ support for bsearch instead. (mperham)\n- Switch repo to Github Actions and upgrade Ruby versions (petergoldstein, bdunne, Fryguy)\n- Update benchmark test for Rubyprof changes (nateberkopec)\n- Remove support for the `kgio` gem, it is not relevant in Ruby 2.3+. (mperham)\n- Remove inline native code, use Ruby 2.3+ support for bsearch instead. (mperham)\n\n\n2.7.11\n==========\n- DEPRECATION: :dalli_store will be removed in Dalli 3.0.\n  Use Rails' official :mem_cache_store instead.\n  https://guides.rubyonrails.org/caching_with_rails.html\n- Add new `digest_class` option to Dalli::Client [#724]\n- Don't treat NameError as a network error [#728]\n- Handle nested comma separated server strings (sambostock)\n\n2.7.10\n==========\n- Revert frozen string change (schneems)\n- Advertise supports_cached_versioning? in DalliStore (schneems)\n- Better detection of fork support, to allow specs to run under Truffle Ruby (deepj)\n- Update logging for over max size to log as error (aeroastro)\n\n2.7.9\n==========\n- Fix behavior for Rails 5.2+ cache_versioning (GriwMF)\n- Ensure fetch provides the key to the fallback block as an argument (0exp)\n- Assorted performance improvements (schneems)\n\n2.7.8\n==========\n- Rails 5.2 compatibility (pbougie)\n- Fix Session Cache compatibility (pixeltrix)\n\n2.7.7\n==========\n- Support large cache keys on fetch multi (sobrinho)\n- Not found checks no longer trigger the result's equality method (dannyfallon)\n- Use SVG build badges (olleolleolle)\n- Travis updates (junaruga, tiarly, petergoldstein)\n- Update default down_retry_delay (jaredhales)\n- Close kgio socket after IO.select timeouts\n- Documentation updates (tipair)\n- Instrument DalliStore errors with instrument_errors configuration option. (btatnall)\n\n2.7.6\n==========\n- Rails 5.0.0.beta2 compatibility (yui-knk, petergoldstein)\n- Add cas!, a variant of the #cas method that yields to the block whether or not the key already exist (mwpastore)\n- Performance improvements (nateberkopec)\n- Add Ruby 2.3.0 to support matrix (tricknotes)\n\n2.7.5\n==========\n\n- Support rcvbuff and sndbuff byte configuration. (btatnall)\n- Add `:cache_nils` option to support nil values in `DalliStore#fetch` and `Dalli::Client#fetch` (wjordan, #559)\n- Log retryable server errors with 'warn' instead of 'info' (phrinx)\n- Fix timeout issue with Dalli::Client#get_multi_yielder (dspeterson)\n- Escape namespaces with special regexp characters (Steven Peckins)\n- Ensure LocalCache supports the `:raw` option and Entry unwrapping (sj26)\n- Ensure bad ttl values don't cause Dalli::RingError (eagletmt, petergoldstein)\n- Always pass namespaced key to instrumentation API (kaorimatz)\n- Replace use of deprecated TimeoutError with Timeout::Error (eagletmt)\n- Clean up gemspec, and use Bundler for loading (grosser)\n- Dry up local cache testing (grosser)\n\n2.7.4\n==========\n\n- Restore Windows compatibility (dfens, #524)\n\n2.7.3\n==========\n\n- Assorted spec improvements\n- README changes to specify defaults for failover and compress options (keen99, #470)\n- SASL authentication changes to deal with Unicode characters (flypiggy, #477)\n- Call to_i on ttl to accomodate ActiveSupport::Duration (#494)\n- Change to implicit blocks for performance (glaucocustodio, #495)\n- Change to each_key for performance (jastix, #496)\n- Support stats settings - (dterei, #500)\n- Raise DallError if hostname canno be parsed (dannyfallon, #501)\n- Fix instrumentation for falsey values (AlexRiedler, #514)\n- Support UNIX socket configurations (r-stu31, #515)\n\n2.7.2\n==========\n\n- The fix for #423 didn't make it into the released 2.7.1 gem somehow.\n\n2.7.1\n==========\n\n- Rack session will check if servers are up on initialization (arthurnn, #423)\n- Add support for IPv6 addresses in hex form, ie: \"[::1]:11211\" (dplummer, #428)\n- Add symbol support for namespace (jingkai #431)\n- Support expiration intervals longer than 30 days (leonid-shevtsov #436)\n\n2.7.0\n==========\n\n- BREAKING CHANGE:\n  Dalli::Client#add and #replace now return a truthy value, not boolean true or false.\n- Multithreading support with dalli\\_store:\n  Use :pool\\_size to create a pool of shared, threadsafe Dalli clients in Rails:\n```ruby\n    config.cache_store = :dalli_store, \"cache-1.example.com\", \"cache-2.example.com\", :compress => true, :pool_size => 5, :expires_in => 300\n```\n  This will ensure the Rails.cache singleton does not become a source of contention.\n  **PLEASE NOTE** Rails's :mem\\_cache\\_store does not support pooling as of\nRails 4.0.  You must use :dalli\\_store.\n\n- Implement `version` for retrieving version of connected servers [dterei, #384]\n- Implement `fetch_multi` for batched read/write [sorentwo, #380]\n- Add more support for safe updates with multiple writers: [philipmw, #395]\n  `require 'dalli/cas/client'` augments Dalli::Client with the following methods:\n  * Get value with CAS:            `[value, cas] = get_cas(key)`\n                                   `get_cas(key) {|value, cas| ...}`\n  * Get multiple values with CAS:  `get_multi_cas(k1, k2, ...) {|value, metadata| cas = metadata[:cas]}`\n  * Set value with CAS:            `new_cas = set_cas(key, value, cas, ttl, options)`\n  * Replace value with CAS:        `replace_cas(key, new_value, cas, ttl, options)`\n  * Delete value with CAS:         `delete_cas(key, cas)`\n- Fix bug with get key with \"Not found\" value [uzzz, #375]\n\n2.6.4\n=======\n\n- Fix ADD command, aka `write(unless_exist: true)` (pitr, #365)\n- Upgrade test suite from mini\\_shoulda to minitest.\n- Even more performance improvements for get\\_multi (xaop, #331)\n\n2.6.3\n=======\n\n- Support specific stats by passing `:items` or `:slabs` to `stats` method [bukhamseen]\n- Fix 'can't modify frozen String' errors in `ActiveSupport::Cache::DalliStore` [dblock]\n- Protect against objects with custom equality checking [theron17]\n- Warn if value for key is too large to store [locriani]\n\n2.6.2\n=======\n\n- Properly handle missing RubyInline\n\n2.6.1\n=======\n\n- Add optional native C binary search for ring, add:\n\ngem 'RubyInline'\n\n  to your Gemfile to get a 10% speedup when using many servers.\n  You will see no improvement if you are only using one server.\n\n- More get_multi performance optimization [xaop, #315]\n- Add lambda support for cache namespaces [joshwlewis, #311]\n\n2.6.0\n=======\n\n- read_multi optimization, now checks local_cache [chendo, #306]\n- Re-implement get_multi to be non-blocking [tmm1, #295]\n- Add `dalli` accessor to dalli_store to access the underlying\nDalli::Client, for things like `get_multi`.\n- Add `Dalli::GzipCompressor`, primarily for compatibility with nginx's HttpMemcachedModule using `memcached_gzip_flag`\n\n2.5.0\n=======\n\n- Don't escape non-ASCII keys, memcached binary protocol doesn't care. [#257]\n- :dalli_store now implements LocalCache [#236]\n- Removed lots of old session_store test code, tests now all run without a default memcached server [#275]\n- Changed Dalli ActiveSupport adapter to always attempt instrumentation [brianmario, #284]\n- Change write operations (add/set/replace) to return false when value is too large to store [brianmario, #283]\n- Allowing different compressors per client [naseem]\n\n2.4.0\n=======\n- Added the ability to swap out the compressed used to [de]compress cache data [brianmario, #276]\n- Fix get\\_multi performance issues with lots of memcached servers [tmm1]\n- Throw more specific exceptions [tmm1]\n- Allowing different types of serialization per client [naseem]\n\n2.3.0\n=======\n- Added the ability to swap out the serializer used to [de]serialize cache data [brianmario, #274]\n\n2.2.1\n=======\n\n- Fix issues with ENV-based connections. [#266]\n- Fix problem with SessionStore in Rails 4.0 [#265]\n\n2.2.0\n=======\n\n- Add Rack session with\\_lock helper, for Rails 4.0 support [#264]\n- Accept connection string in the form of a URL (e.g., memcached://user:pass@hostname:port) [glenngillen]\n- Add touch operation [#228, uzzz]\n\n2.1.0\n=======\n\n- Add Railtie to auto-configure Dalli when included in Gemfile [#217, steveklabnik]\n\n2.0.5\n=======\n\n- Create proper keys for arrays of objects passed as keys [twinturbo, #211]\n- Handle long key with namespace [#212]\n- Add NODELAY to TCP socket options [#206]\n\n2.0.4\n=======\n\n- Dalli no longer needs to be reset after Unicorn/Passenger fork [#208]\n- Add option to re-raise errors rescued in the session and cache stores. [pitr, #200]\n- DalliStore#fetch called the block if the cached value == false [#205]\n- DalliStore should have accessible options [#195]\n- Add silence and mute support for DalliStore [#207]\n- Tracked down and fixed socket corruption due to Timeout [#146]\n\n2.0.3\n=======\n\n- Allow proper retrieval of stored `false` values [laserlemon, #197]\n- Allow non-ascii and whitespace keys, only the text protocol has those restrictions [#145]\n- Fix DalliStore#delete error-handling [#196]\n\n2.0.2\n=======\n\n- Fix all dalli\\_store operations to handle nil options [#190]\n- Increment and decrement with :initial => nil now return nil (lawrencepit, #112)\n\n2.0.1\n=======\n\n- Fix nil option handling in dalli\\_store#write [#188]\n\n2.0.0\n=======\n\n- Reimplemented the Rails' dalli\\_store to remove use of\n  ActiveSupport::Cache::Entry which added 109 bytes overhead to every\n  value stored, was a performance bottleneck and duplicated a lot of\n  functionality already in Dalli.  One benchmark went from 4.0 sec to 3.0\n  sec with the new dalli\\_store. [#173]\n- Added reset\\_stats operation [#155]\n- Added support for configuring keepalive on TCP connections to memcached servers (@bianster, #180)\n\nNotes:\n\n  * data stored with dalli\\_store 2.x is NOT backwards compatible with 1.x.\n    Upgraders are advised to namespace their keys and roll out the 2.x\n    upgrade slowly so keys do not clash and caches are warmed.\n    `config.cache_store = :dalli_store, :expires_in => 24.hours.to_i, :namespace => 'myapp2'`\n  * data stored with plain Dalli::Client API is unchanged.\n  * removed support for dalli\\_store's race\\_condition\\_ttl option.\n  * removed support for em-synchrony and unix socket connection options.\n  * removed support for Ruby 1.8.6\n  * removed memcache-client compability layer and upgrade documentation.\n\n\n1.1.5\n=======\n\n- Coerce input to incr/decr to integer via #to\\_i [#165]\n- Convert test suite to minitest/spec (crigor, #166)\n- Fix encoding issue with keys [#162]\n- Fix double namespacing with Rails and dalli\\_store. [#160]\n\n1.1.4\n=======\n\n- Use 127.0.0.1 instead of localhost as default to avoid IPv6 issues\n- Extend DalliStore's :expires\\_in when :race\\_condition\\_ttl is also used.\n- Fix :expires\\_in option not propogating from DalliStore to Client, GH-136\n- Added support for native Rack session store.  Until now, Dalli's\n  session store has required Rails.  Now you can use Dalli to store\n  sessions for any Rack application.\n\n    require 'rack/session/dalli'\n    use Rack::Session::Dalli, :memcache_server => 'localhost:11211', :compression => true\n\n1.1.3\n=======\n\n- Support Rails's autoloading hack for loading sessions with objects\n  whose classes have not be required yet, GH-129\n- Support Unix sockets for connectivity.  Shows a 2x performance\n  increase but keep in mind they only work on localhost. (dfens)\n\n1.1.2\n=======\n\n- Fix incompatibility with latest Rack session API when destroying\n  sessions, thanks @twinge!\n\n1.1.1\n=======\n\nv1.1.0 was a bad release.  Yanked.\n\n1.1.0\n=======\n\n- Remove support for Rails 2.3, add support for Rails 3.1\n- Fix socket failure retry logic, now you can restart memcached and Dalli won't complain!\n- Add support for fibered operation via em-synchrony (eliaslevy)\n- Gracefully handle write timeouts, GH-99\n- Only issue bug warning for unexpected StandardErrors, GH-102\n- Add travis-ci build support (ryanlecompte)\n- Gracefully handle errors in get_multi (michaelfairley)\n- Misc fixes from crash2burn, fphilipe, igreg, raggi\n\n1.0.5\n=======\n\n- Fix socket failure retry logic, now you can restart memcached and Dalli won't complain!\n\n1.0.4\n=======\n\n- Handle non-ASCII key content in dalli_store\n- Accept key array for read_multi in dalli_store\n- Fix multithreaded race condition in creation of mutex\n\n1.0.3\n=======\n\n- Better handling of application marshalling errors\n- Work around jruby IO#sysread compatibility issue\n\n\n1.0.2\n=======\n\n - Allow browser session cookies (blindsey)\n - Compatibility fixes (mwynholds)\n - Add backwards compatibility module for memcache-client, require 'dalli/memcache-client'.  It makes\n   Dalli more compatible with memcache-client and prints out a warning any time you do something that\n   is no longer supported so you can fix your code.\n\n1.0.1\n=======\n\n - Explicitly handle application marshalling bugs, GH-56\n - Add support for username/password as options, to allow multiple bucket access\n   from the same Ruby process, GH-52\n - Add support for >1MB values with :value_max_bytes option, GH-54 (r-stu31)\n - Add support for default TTL, :expires_in, in Rails 2.3. (Steven Novotny)\n   config.cache_store = :dalli_store, 'localhost:11211', {:expires_in => 4.hours}\n\n\n1.0.0\n=======\n\nWelcome gucki as a Dalli committer!\n\n - Fix network and namespace issues in get_multi (gucki)\n - Better handling of unmarshalling errors (mperham)\n\n0.11.2\n=======\n\n - Major reworking of socket error and failover handling (gucki)\n - Add basic JRuby support (mperham)\n\n0.11.1\n======\n\n - Minor fixes, doc updates.\n - Add optional support for kgio sockets, gives a 10-15% performance boost.\n\n0.11.0\n======\n\nWarning: this release changes how Dalli marshals data.  I do not guarantee compatibility until 1.0 but I will increment the minor version every time a release breaks compatibility until 1.0.\n\nIT IS HIGHLY RECOMMENDED YOU FLUSH YOUR CACHE BEFORE UPGRADING.\n\n - multi() now works reentrantly.\n - Added new Dalli::Client option for default TTLs, :expires_in, defaults to 0 (aka forever).\n - Added new Dalli::Client option, :compression, to enable auto-compression of values.\n - Refactor how Dalli stores data on the server.  Values are now tagged\n   as \"marshalled\" or \"compressed\" so they can be automatically deserialized\n   without the client having to know how they were stored.\n\n0.10.1\n======\n\n - Prefer server config from environment, fixes Heroku session store issues (thanks JoshMcKin)\n - Better handling of non-ASCII values (size -> bytesize)\n - Assert that keys are ASCII only\n\n0.10.0\n======\n\nWarning: this release changed how Rails marshals data with Dalli.  Unfortunately previous versions double marshalled values.  It is possible that data stored with previous versions of Dalli will not work with this version.\n\nIT IS HIGHLY RECOMMENDED YOU FLUSH YOUR CACHE BEFORE UPGRADING.\n\n - Rework how the Rails cache store does value marshalling.\n - Rework old server version detection to avoid a socket read hang.\n - Refactor the Rails 2.3 :dalli\\_store to be closer to :mem\\_cache\\_store.\n - Better documentation for session store config (plukevdh)\n\n0.9.10\n----\n\n - Better server retry logic (next2you)\n - Rails 3.1 compatibility (gucki)\n\n\n0.9.9\n----\n\n - Add support for *_multi operations for add, set, replace and delete.  This implements\n   pipelined network operations; Dalli disables network replies so we're not limited by\n   latency, allowing for much higher throughput.\n\n    dc = Dalli::Client.new\n    dc.multi do\n      dc.set 'a', 1\n      dc.set 'b', 2\n      dc.set 'c', 3\n      dc.delete 'd'\n    end\n - Minor fix to set the continuum sorted by value (kangster)\n - Implement session store with Rails 2.3.  Update docs.\n\n0.9.8\n-----\n\n - Implement namespace support\n - Misc fixes\n\n\n0.9.7\n-----\n\n - Small fix for NewRelic integration.\n - Detect and fail on older memcached servers (pre-1.4).\n\n0.9.6\n-----\n\n - Patches for Rails 3.0.1 integration.\n\n0.9.5\n-----\n\n - Major design change - raw support is back to maximize compatibility with Rails\n and the increment/decrement operations.  You can now pass :raw => true to most methods\n to bypass (un)marshalling.\n - Support symbols as keys (ddollar)\n - Rails 2.3 bug fixes\n\n\n0.9.4\n-----\n\n - Dalli support now in rack-bug (http://github.com/brynary/rack-bug), give it a try!\n - Namespace support for Rails 2.3 (bpardee)\n - Bug fixes\n\n\n0.9.3\n-----\n\n - Rails 2.3 support (beanieboi)\n - Rails SessionStore support\n - Passenger integration\n - memcache-client upgrade docs, see Upgrade.md\n\n\n0.9.2\n----\n\n - Verify proper operation in Heroku.\n\n\n0.9.1\n----\n\n - Add fetch and cas operations (mperham)\n - Add incr and decr operations (mperham)\n - Initial support for SASL authentication via the MEMCACHE_{USERNAME,PASSWORD} environment variables, needed for Heroku (mperham)\n\n0.9.0\n-----\n\n - Initial gem release.\n", "# frozen_string_literal: true\n\nrequire 'forwardable'\nrequire 'socket'\nrequire 'timeout'\n\nmodule Dalli\n  module Protocol\n    ##\n    # Access point for a single Memcached server, accessed via Memcached's meta\n    # protocol.  Contains logic for managing connection state to the server (retries, etc),\n    # formatting requests to the server, and unpacking responses.\n    ##\n    class Meta < Base\n      TERMINATOR = \"\\r\\n\"\n\n      def response_processor\n        @response_processor ||= ResponseProcessor.new(@connection_manager, @value_marshaller)\n      end\n\n      # NOTE: Additional public methods should be overridden in Dalli::Threadsafe\n\n      private\n\n      # Retrieval Commands\n      def get(key, options = nil)\n        encoded_key, base64 = KeyRegularizer.encode(key)\n        req = RequestFormatter.meta_get(key: encoded_key, base64: base64)\n        write(req)\n        response_processor.meta_get_with_value(cache_nils: cache_nils?(options))\n      end\n\n      def quiet_get_request(key)\n        encoded_key, base64 = KeyRegularizer.encode(key)\n        RequestFormatter.meta_get(key: encoded_key, return_cas: true, base64: base64, quiet: true)\n      end\n\n      def gat(key, ttl, options = nil)\n        ttl = TtlSanitizer.sanitize(ttl)\n        encoded_key, base64 = KeyRegularizer.encode(key)\n        req = RequestFormatter.meta_get(key: encoded_key, ttl: ttl, base64: base64)\n        write(req)\n        response_processor.meta_get_with_value(cache_nils: cache_nils?(options))\n      end\n\n      def touch(key, ttl)\n        ttl = TtlSanitizer.sanitize(ttl)\n        encoded_key, base64 = KeyRegularizer.encode(key)\n        req = RequestFormatter.meta_get(key: encoded_key, ttl: ttl, value: false, base64: base64)\n        write(req)\n        response_processor.meta_get_without_value\n      end\n\n      # TODO: This is confusing, as there's a cas command in memcached\n      # and this isn't it.  Maybe rename?  Maybe eliminate?\n      def cas(key)\n        encoded_key, base64 = KeyRegularizer.encode(key)\n        req = RequestFormatter.meta_get(key: encoded_key, value: true, return_cas: true, base64: base64)\n        write(req)\n        response_processor.meta_get_with_value_and_cas\n      end\n\n      # Storage Commands\n      def set(key, value, ttl, cas, options)\n        write_storage_req(:set, key, value, ttl, cas, options)\n        response_processor.meta_set_with_cas unless quiet?\n      end\n\n      def add(key, value, ttl, options)\n        write_storage_req(:add, key, value, ttl, nil, options)\n        response_processor.meta_set_with_cas unless quiet?\n      end\n\n      def replace(key, value, ttl, cas, options)\n        write_storage_req(:replace, key, value, ttl, cas, options)\n        response_processor.meta_set_with_cas unless quiet?\n      end\n\n      # rubocop:disable Metrics/ParameterLists\n      def write_storage_req(mode, key, raw_value, ttl = nil, cas = nil, options = {})\n        (value, bitflags) = @value_marshaller.store(key, raw_value, options)\n        ttl = TtlSanitizer.sanitize(ttl) if ttl\n        encoded_key, base64 = KeyRegularizer.encode(key)\n        req = RequestFormatter.meta_set(key: encoded_key, value: value,\n                                        bitflags: bitflags, cas: cas,\n                                        ttl: ttl, mode: mode, quiet: quiet?, base64: base64)\n        write(req)\n      end\n      # rubocop:enable Metrics/ParameterLists\n\n      def append(key, value)\n        write_append_prepend_req(:append, key, value)\n        response_processor.meta_set_append_prepend unless quiet?\n      end\n\n      def prepend(key, value)\n        write_append_prepend_req(:prepend, key, value)\n        response_processor.meta_set_append_prepend unless quiet?\n      end\n\n      # rubocop:disable Metrics/ParameterLists\n      def write_append_prepend_req(mode, key, value, ttl = nil, cas = nil, _options = {})\n        ttl = TtlSanitizer.sanitize(ttl) if ttl\n        encoded_key, base64 = KeyRegularizer.encode(key)\n        req = RequestFormatter.meta_set(key: encoded_key, value: value, base64: base64,\n                                        cas: cas, ttl: ttl, mode: mode, quiet: quiet?)\n        write(req)\n      end\n      # rubocop:enable Metrics/ParameterLists\n\n      # Delete Commands\n      def delete(key, cas)\n        encoded_key, base64 = KeyRegularizer.encode(key)\n        req = RequestFormatter.meta_delete(key: encoded_key, cas: cas,\n                                           base64: base64, quiet: quiet?)\n        write(req)\n        response_processor.meta_delete unless quiet?\n      end\n\n      # Arithmetic Commands\n      def decr(key, count, ttl, initial)\n        decr_incr false, key, count, ttl, initial\n      end\n\n      def incr(key, count, ttl, initial)\n        decr_incr true, key, count, ttl, initial\n      end\n\n      def decr_incr(incr, key, delta, ttl, initial)\n        ttl = initial ? TtlSanitizer.sanitize(ttl) : nil # Only set a TTL if we want to set a value on miss\n        encoded_key, base64 = KeyRegularizer.encode(key)\n        write(RequestFormatter.meta_arithmetic(key: encoded_key, delta: delta, initial: initial, incr: incr, ttl: ttl,\n                                               quiet: quiet?, base64: base64))\n        response_processor.decr_incr unless quiet?\n      end\n\n      # Other Commands\n      def flush(delay = 0)\n        write(RequestFormatter.flush(delay: delay))\n        response_processor.flush unless quiet?\n      end\n\n      # Noop is a keepalive operation but also used to demarcate the end of a set of pipelined commands.\n      # We need to read all the responses at once.\n      def noop\n        write_noop\n        response_processor.consume_all_responses_until_mn\n      end\n\n      def stats(info = nil)\n        write(RequestFormatter.stats(info))\n        response_processor.stats\n      end\n\n      def reset_stats\n        write(RequestFormatter.stats('reset'))\n        response_processor.reset\n      end\n\n      def version\n        write(RequestFormatter.version)\n        response_processor.version\n      end\n\n      def write_noop\n        write(RequestFormatter.meta_noop)\n      end\n\n      def authenticate_connection\n        raise Dalli::DalliError, 'Authentication not supported for the meta protocol.'\n      end\n\n      require_relative 'meta/key_regularizer'\n      require_relative 'meta/request_formatter'\n      require_relative 'meta/response_processor'\n    end\n  end\nend\n", "# frozen_string_literal: false\n\nmodule Dalli\n  module Protocol\n    class Meta\n      ##\n      # Class that encapsulates logic for formatting meta protocol requests\n      # to memcached.\n      ##\n      class RequestFormatter\n        # Since these are string construction methods, we're going to disable these\n        # Rubocop directives.  We really can't make this construction much simpler,\n        # and introducing an intermediate object seems like overkill.\n        #\n        # rubocop:disable Metrics/CyclomaticComplexity\n        # rubocop:disable Metrics/MethodLength\n        # rubocop:disable Metrics/ParameterLists\n        # rubocop:disable Metrics/PerceivedComplexity\n        def self.meta_get(key:, value: true, return_cas: false, ttl: nil, base64: false, quiet: false)\n          cmd = \"mg #{key}\"\n          cmd << ' v f' if value\n          cmd << ' c' if return_cas\n          cmd << ' b' if base64\n          cmd << \" T#{ttl}\" if ttl\n          cmd << ' k q s' if quiet # Return the key in the response if quiet\n          cmd + TERMINATOR\n        end\n\n        def self.meta_set(key:, value:, bitflags: nil, cas: nil, ttl: nil, mode: :set, base64: false, quiet: false)\n          cmd = \"ms #{key} #{value.bytesize}\"\n          cmd << ' c' unless %i[append prepend].include?(mode)\n          cmd << ' b' if base64\n          cmd << \" F#{bitflags}\" if bitflags\n          cmd << cas_string(cas)\n          cmd << \" T#{ttl}\" if ttl\n          cmd << \" M#{mode_to_token(mode)}\"\n          cmd << ' q' if quiet\n          cmd << TERMINATOR\n          cmd << value\n          cmd + TERMINATOR\n        end\n\n        def self.meta_delete(key:, cas: nil, ttl: nil, base64: false, quiet: false)\n          cmd = \"md #{key}\"\n          cmd << ' b' if base64\n          cmd << cas_string(cas)\n          cmd << \" T#{ttl}\" if ttl\n          cmd << ' q' if quiet\n          cmd + TERMINATOR\n        end\n\n        def self.meta_arithmetic(key:, delta:, initial:, incr: true, cas: nil, ttl: nil, base64: false, quiet: false)\n          cmd = \"ma #{key} v\"\n          cmd << ' b' if base64\n          cmd << \" D#{delta}\" if delta\n          cmd << \" J#{initial}\" if initial\n          # Always set a TTL if an initial value is specified\n          cmd << \" N#{ttl || 0}\" if ttl || initial\n          cmd << cas_string(cas)\n          cmd << ' q' if quiet\n          cmd << \" M#{incr ? 'I' : 'D'}\"\n          cmd + TERMINATOR\n        end\n        # rubocop:enable Metrics/CyclomaticComplexity\n        # rubocop:enable Metrics/MethodLength\n        # rubocop:enable Metrics/ParameterLists\n        # rubocop:enable Metrics/PerceivedComplexity\n\n        def self.meta_noop\n          \"mn#{TERMINATOR}\"\n        end\n\n        def self.version\n          \"version#{TERMINATOR}\"\n        end\n\n        def self.flush(delay: nil, quiet: false)\n          cmd = +'flush_all'\n          cmd << \" #{parse_to_64_bit_int(delay, 0)}\" if delay\n          cmd << ' noreply' if quiet\n          cmd + TERMINATOR\n        end\n\n        def self.stats(arg = nil)\n          cmd = +'stats'\n          cmd << \" #{arg}\" if arg\n          cmd + TERMINATOR\n        end\n\n        # rubocop:disable Metrics/MethodLength\n        def self.mode_to_token(mode)\n          case mode\n          when :add\n            'E'\n          when :replace\n            'R'\n          when :append\n            'A'\n          when :prepend\n            'P'\n          else\n            'S'\n          end\n        end\n        # rubocop:enable Metrics/MethodLength\n\n        def self.cas_string(cas)\n          cas = parse_to_64_bit_int(cas, nil)\n          cas.nil? || cas.zero? ? '' : \" C#{cas}\"\n        end\n\n        def self.parse_to_64_bit_int(val, default)\n          val.nil? ? nil : Integer(val)\n        rescue ArgumentError\n          # Sanitize to default if it isn't parsable as an integer\n          default\n        end\n      end\n    end\n  end\nend\n", "# frozen_string_literal: true\n\nrequire_relative '../helper'\n\ndescribe 'Network' do\n  MemcachedManager.supported_protocols.each do |p|\n    describe \"using the #{p} protocol\" do\n      describe 'assuming a bad network' do\n        it 'handle no server available' do\n          dc = Dalli::Client.new 'localhost:19333'\n          assert_raises Dalli::RingError, message: 'No server available' do\n            dc.get 'foo'\n          end\n        end\n\n        describe 'with a fake server' do\n          it 'handle connection reset' do\n            memcached_mock(->(sock) { sock.close }) do\n              dc = Dalli::Client.new('localhost:19123')\n              assert_raises Dalli::RingError, message: 'No server available' do\n                dc.get('abc')\n              end\n            end\n          end\n\n          it 'handle connection reset with unix socket' do\n            socket_path = MemcachedMock::UNIX_SOCKET_PATH\n            memcached_mock(->(sock) { sock.close }, :start_unix, socket_path) do\n              dc = Dalli::Client.new(socket_path)\n              assert_raises Dalli::RingError, message: 'No server available' do\n                dc.get('abc')\n              end\n            end\n          end\n\n          it 'handle malformed response' do\n            memcached_mock(->(sock) { sock.write('123') }) do\n              dc = Dalli::Client.new('localhost:19123')\n              assert_raises Dalli::RingError, message: 'No server available' do\n                dc.get('abc')\n              end\n            end\n          end\n\n          it 'handle connect timeouts' do\n            memcached_mock(lambda { |sock|\n                             sleep(0.6)\n                             sock.close\n                           }, :delayed_start) do\n              dc = Dalli::Client.new('localhost:19123')\n              assert_raises Dalli::RingError, message: 'No server available' do\n                dc.get('abc')\n              end\n            end\n          end\n\n          it 'handle read timeouts' do\n            memcached_mock(lambda { |sock|\n                             sleep(0.6)\n                             sock.write('giraffe')\n                           }) do\n              dc = Dalli::Client.new('localhost:19123')\n              assert_raises Dalli::RingError, message: 'No server available' do\n                dc.get('abc')\n              end\n            end\n          end\n        end\n\n        it 'opens a standard TCP connection when ssl_context is not configured' do\n          memcached_persistent(p) do |dc|\n            server = dc.send(:ring).servers.first\n            sock = Dalli::Socket::TCP.open(server.hostname, server.port, server.options)\n            assert_equal Dalli::Socket::TCP, sock.class\n\n            dc.set('abc', 123)\n            assert_equal(123, dc.get('abc'))\n          end\n        end\n\n        it 'opens a SSL TCP connection when there is an SSL context set' do\n          memcached_ssl_persistent(p) do |dc|\n            server = dc.send(:ring).servers.first\n            sock = Dalli::Socket::TCP.open(server.hostname, server.port, server.options)\n            assert_equal Dalli::Socket::SSLSocket, sock.class\n\n            dc.set('abc', 123)\n            assert_equal(123, dc.get('abc'))\n\n            # Confirm that pipelined get works, since this depends on attributes on\n            # the socket\n            assert_equal({ 'abc' => 123 }, dc.get_multi(['abc']))\n          end\n        end\n\n        it 'allow TCP connections to be configured for keepalive' do\n          memcached_persistent(p) do |_, port|\n            dc = Dalli::Client.new(\"localhost:#{port}\", keepalive: true)\n            dc.set(:a, 1)\n            ring = dc.send(:ring)\n            server = ring.servers.first\n            socket = server.sock\n\n            optval = socket.getsockopt(Socket::SOL_SOCKET, Socket::SO_KEEPALIVE)\n            optval = optval.unpack 'i'\n\n            refute_equal(optval[0], 0)\n          end\n        end\n      end\n\n      it 'passes a simple smoke test on a TCP socket' do\n        memcached_persistent(p) do |dc, port|\n          resp = dc.flush\n          refute_nil resp\n          assert_equal [true, true], resp\n\n          assert op_addset_succeeds(dc.set(:foo, 'bar'))\n          assert_equal 'bar', dc.get(:foo)\n\n          resp = dc.get('123')\n          assert_nil resp\n\n          assert op_addset_succeeds(dc.set('123', 'xyz'))\n\n          resp = dc.get('123')\n          assert_equal 'xyz', resp\n\n          assert op_addset_succeeds(dc.set('123', 'abc'))\n\n          dc.prepend('123', '0')\n          dc.append('123', '0')\n\n          assert_raises Dalli::UnmarshalError do\n            resp = dc.get('123')\n          end\n\n          dc.close\n          dc = nil\n\n          dc = Dalli::Client.new(\"localhost:#{port}\", digest_class: ::OpenSSL::Digest::SHA1)\n\n          assert op_addset_succeeds(dc.set('456', 'xyz', 0, raw: true))\n\n          resp = dc.prepend '456', '0'\n          assert resp\n\n          resp = dc.append '456', '9'\n          assert resp\n\n          resp = dc.get('456', raw: true)\n          assert_equal '0xyz9', resp\n\n          assert op_addset_succeeds(dc.set('456', false))\n\n          resp = dc.get('456')\n          refute resp\n\n          resp = dc.stats\n          assert_equal Hash, resp.class\n\n          dc.close\n        end\n      end\n\n      it 'passes a simple smoke test on unix socket' do\n        memcached_persistent(:binary, MemcachedMock::UNIX_SOCKET_PATH) do |dc, path|\n          resp = dc.flush\n          refute_nil resp\n          assert_equal [true], resp\n\n          assert op_addset_succeeds(dc.set(:foo, 'bar'))\n          assert_equal 'bar', dc.get(:foo)\n\n          resp = dc.get('123')\n          assert_nil resp\n\n          assert op_addset_succeeds(dc.set('123', 'xyz'))\n\n          resp = dc.get('123')\n          assert_equal 'xyz', resp\n\n          assert op_addset_succeeds(dc.set('123', 'abc'))\n\n          dc.prepend('123', '0')\n          dc.append('123', '0')\n\n          assert_raises Dalli::UnmarshalError do\n            resp = dc.get('123')\n          end\n\n          dc.close\n          dc = nil\n\n          dc = Dalli::Client.new(path)\n\n          assert op_addset_succeeds(dc.set('456', 'xyz', 0, raw: true))\n\n          resp = dc.prepend '456', '0'\n          assert resp\n\n          resp = dc.append '456', '9'\n          assert resp\n\n          resp = dc.get('456', raw: true)\n          assert_equal '0xyz9', resp\n\n          assert op_addset_succeeds(dc.set('456', false))\n\n          resp = dc.get('456')\n          refute resp\n\n          resp = dc.stats\n          assert_equal Hash, resp.class\n\n          dc.close\n        end\n      end\n    end\n  end\nend\n", "# frozen_string_literal: true\n\nrequire_relative '../../helper'\n\ndescribe Dalli::Protocol::Meta::RequestFormatter do\n  describe 'meta_get' do\n    let(:key) { SecureRandom.hex(4) }\n    let(:ttl) { rand(1000..1999) }\n\n    it 'returns the default get (get value and bitflags, no cas) when passed only a key' do\n      assert_equal \"mg #{key} v f\\r\\n\", Dalli::Protocol::Meta::RequestFormatter.meta_get(key: key)\n    end\n\n    it 'sets the TTL flag when passed a ttl' do\n      assert_equal \"mg #{key} v f T#{ttl}\\r\\n\",\n                   Dalli::Protocol::Meta::RequestFormatter.meta_get(key: key, ttl: ttl)\n    end\n\n    it 'skips the value and bitflags when passed a pure touch argument' do\n      assert_equal \"mg #{key} T#{ttl}\\r\\n\",\n                   Dalli::Protocol::Meta::RequestFormatter.meta_get(key: key, value: false, ttl: ttl)\n    end\n\n    it 'sets the CAS retrieval flags when passed that value' do\n      assert_equal \"mg #{key} c\\r\\n\",\n                   Dalli::Protocol::Meta::RequestFormatter.meta_get(key: key, value: false, return_cas: true)\n    end\n\n    it 'sets the flags for returning the key and body size when passed quiet' do\n      assert_equal \"mg #{key} v f k q s\\r\\n\",\n                   Dalli::Protocol::Meta::RequestFormatter.meta_get(key: key, quiet: true)\n    end\n  end\n\n  describe 'meta_set' do\n    let(:key) { SecureRandom.hex(4) }\n    let(:hexlen) { rand(500..999) }\n    let(:val) { SecureRandom.hex(hexlen) }\n    let(:bitflags) { (0..3).to_a.sample }\n    let(:cas) { rand(500..999) }\n    let(:ttl) { rand(500..999) }\n\n    it 'returns the default (treat as a set, no CAS check) when just passed key, datalen, and bitflags' do\n      assert_equal \"ms #{key} #{val.bytesize} c F#{bitflags} MS\\r\\n#{val}\\r\\n\",\n                   Dalli::Protocol::Meta::RequestFormatter.meta_set(key: key, value: val, bitflags: bitflags)\n    end\n\n    it 'supports the add mode' do\n      assert_equal \"ms #{key} #{val.bytesize} c F#{bitflags} ME\\r\\n#{val}\\r\\n\",\n                   Dalli::Protocol::Meta::RequestFormatter.meta_set(key: key, value: val, bitflags: bitflags,\n                                                                    mode: :add)\n    end\n\n    it 'supports the replace mode' do\n      assert_equal \"ms #{key} #{val.bytesize} c F#{bitflags} MR\\r\\n#{val}\\r\\n\",\n                   Dalli::Protocol::Meta::RequestFormatter.meta_set(key: key, value: val, bitflags: bitflags,\n                                                                    mode: :replace)\n    end\n\n    it 'passes a TTL if one is provided' do\n      assert_equal \"ms #{key} #{val.bytesize} c F#{bitflags} T#{ttl} MS\\r\\n#{val}\\r\\n\",\n                   Dalli::Protocol::Meta::RequestFormatter.meta_set(key: key, value: val, ttl: ttl, bitflags: bitflags)\n    end\n\n    it 'omits the CAS flag on append' do\n      assert_equal \"ms #{key} #{val.bytesize} MA\\r\\n#{val}\\r\\n\",\n                   Dalli::Protocol::Meta::RequestFormatter.meta_set(key: key, value: val, mode: :append)\n    end\n\n    it 'omits the CAS flag on prepend' do\n      assert_equal \"ms #{key} #{val.bytesize} MP\\r\\n#{val}\\r\\n\",\n                   Dalli::Protocol::Meta::RequestFormatter.meta_set(key: key, value: val, mode: :prepend)\n    end\n\n    it 'passes a CAS if one is provided' do\n      assert_equal \"ms #{key} #{val.bytesize} c F#{bitflags} C#{cas} MS\\r\\n#{val}\\r\\n\",\n                   Dalli::Protocol::Meta::RequestFormatter.meta_set(key: key, value: val, bitflags: bitflags, cas: cas)\n    end\n\n    it 'excludes CAS if set to 0' do\n      assert_equal \"ms #{key} #{val.bytesize} c F#{bitflags} MS\\r\\n#{val}\\r\\n\",\n                   Dalli::Protocol::Meta::RequestFormatter.meta_set(key: key, value: val, bitflags: bitflags, cas: 0)\n    end\n\n    it 'excludes non-numeric CAS values' do\n      assert_equal \"ms #{key} #{val.bytesize} c F#{bitflags} MS\\r\\n#{val}\\r\\n\",\n                   Dalli::Protocol::Meta::RequestFormatter.meta_set(key: key, value: val, bitflags: bitflags,\n                                                                    cas: \"\\nset importantkey 1 1000 8\\ninjected\")\n    end\n\n    it 'sets the quiet mode if configured' do\n      assert_equal \"ms #{key} #{val.bytesize} c F#{bitflags} MS q\\r\\n#{val}\\r\\n\",\n                   Dalli::Protocol::Meta::RequestFormatter.meta_set(key: key, value: val, bitflags: bitflags,\n                                                                    quiet: true)\n    end\n\n    it 'sets the base64 mode if configured' do\n      assert_equal \"ms #{key} #{val.bytesize} c b F#{bitflags} MS\\r\\n#{val}\\r\\n\",\n                   Dalli::Protocol::Meta::RequestFormatter.meta_set(key: key, value: val, bitflags: bitflags,\n                                                                    base64: true)\n    end\n  end\n\n  describe 'meta_delete' do\n    let(:key) { SecureRandom.hex(4) }\n    let(:cas) { rand(1000..1999) }\n\n    it 'returns the default when just passed key' do\n      assert_equal \"md #{key}\\r\\n\",\n                   Dalli::Protocol::Meta::RequestFormatter.meta_delete(key: key)\n    end\n\n    it 'incorporates CAS when passed cas' do\n      assert_equal \"md #{key} C#{cas}\\r\\n\",\n                   Dalli::Protocol::Meta::RequestFormatter.meta_delete(key: key, cas: cas)\n    end\n\n    it 'sets the q flag when passed quiet' do\n      assert_equal \"md #{key} q\\r\\n\",\n                   Dalli::Protocol::Meta::RequestFormatter.meta_delete(key: key, quiet: true)\n    end\n\n    it 'excludes CAS when set to 0' do\n      assert_equal \"md #{key}\\r\\n\",\n                   Dalli::Protocol::Meta::RequestFormatter.meta_delete(key: key, cas: 0)\n    end\n\n    it 'excludes non-numeric CAS values' do\n      assert_equal \"md #{key}\\r\\n\",\n                   Dalli::Protocol::Meta::RequestFormatter.meta_delete(key: key,\n                                                                       cas: \"\\nset importantkey 1 1000 8\\ninjected\")\n    end\n\n    it 'sets the base64 mode if configured' do\n      assert_equal \"md #{key} b\\r\\n\",\n                   Dalli::Protocol::Meta::RequestFormatter.meta_delete(key: key, base64: true)\n    end\n  end\n\n  describe 'meta_arithmetic' do\n    let(:key) { SecureRandom.hex(4) }\n    let(:delta) { rand(500..999) }\n    let(:initial) { rand(500..999) }\n    let(:cas) { rand(500..999) }\n    let(:ttl) { rand(500..999) }\n\n    it 'returns the expected string with the default N flag when passed non-nil key, delta, and initial' do\n      assert_equal \"ma #{key} v D#{delta} J#{initial} N0 MI\\r\\n\",\n                   Dalli::Protocol::Meta::RequestFormatter.meta_arithmetic(key: key, delta: delta, initial: initial)\n    end\n\n    it 'excludes the J and N flags when initial is nil and ttl is not set' do\n      assert_equal \"ma #{key} v D#{delta} MI\\r\\n\",\n                   Dalli::Protocol::Meta::RequestFormatter.meta_arithmetic(key: key, delta: delta, initial: nil)\n    end\n\n    it 'omits the D flag is delta is nil' do\n      assert_equal \"ma #{key} v J#{initial} N0 MI\\r\\n\",\n                   Dalli::Protocol::Meta::RequestFormatter.meta_arithmetic(key: key, delta: nil, initial: initial)\n    end\n\n    it 'uses ttl for the N flag when ttl passed explicitly along with an initial value' do\n      assert_equal \"ma #{key} v D#{delta} J#{initial} N#{ttl} MI\\r\\n\",\n                   Dalli::Protocol::Meta::RequestFormatter.meta_arithmetic(key: key, delta: delta, initial: initial,\n                                                                           ttl: ttl)\n    end\n\n    it 'incorporates CAS when passed cas' do\n      assert_equal \"ma #{key} v D#{delta} J#{initial} N0 C#{cas} MI\\r\\n\",\n                   Dalli::Protocol::Meta::RequestFormatter.meta_arithmetic(key: key, delta: delta, initial: initial,\n                                                                           cas: cas)\n    end\n\n    it 'excludes CAS when CAS is set to 0' do\n      assert_equal \"ma #{key} v D#{delta} J#{initial} N0 MI\\r\\n\",\n                   Dalli::Protocol::Meta::RequestFormatter.meta_arithmetic(key: key, delta: delta, initial: initial,\n                                                                           cas: 0)\n    end\n\n    it 'includes the N flag when ttl passed explicitly with a nil initial value' do\n      assert_equal \"ma #{key} v D#{delta} N#{ttl} MI\\r\\n\",\n                   Dalli::Protocol::Meta::RequestFormatter.meta_arithmetic(key: key, delta: delta, initial: nil,\n                                                                           ttl: ttl)\n    end\n\n    it 'swaps from MI to MD when the incr value is explicitly false' do\n      assert_equal \"ma #{key} v D#{delta} J#{initial} N0 MD\\r\\n\",\n                   Dalli::Protocol::Meta::RequestFormatter.meta_arithmetic(key: key, delta: delta, initial: initial,\n                                                                           incr: false)\n    end\n\n    it 'includes the quiet flag when specified' do\n      assert_equal \"ma #{key} v D#{delta} J#{initial} N0 q MI\\r\\n\",\n                   Dalli::Protocol::Meta::RequestFormatter.meta_arithmetic(key: key, delta: delta, initial: initial,\n                                                                           quiet: true)\n    end\n\n    it 'sets the base64 mode if configured' do\n      assert_equal \"ma #{key} v b D#{delta} J#{initial} N0 MI\\r\\n\",\n                   Dalli::Protocol::Meta::RequestFormatter.meta_arithmetic(key: key, delta: delta, initial: initial,\n                                                                           base64: true)\n    end\n  end\n\n  describe 'meta_noop' do\n    it 'returns the expected string' do\n      assert_equal \"mn\\r\\n\", Dalli::Protocol::Meta::RequestFormatter.meta_noop\n    end\n  end\n\n  describe 'version' do\n    it 'returns the expected string' do\n      assert_equal \"version\\r\\n\", Dalli::Protocol::Meta::RequestFormatter.version\n    end\n  end\n\n  describe 'flush' do\n    it 'returns the expected string with no arguments' do\n      assert_equal \"flush_all\\r\\n\", Dalli::Protocol::Meta::RequestFormatter.flush\n    end\n\n    it 'adds noreply when quiet is true' do\n      assert_equal \"flush_all noreply\\r\\n\", Dalli::Protocol::Meta::RequestFormatter.flush(quiet: true)\n    end\n\n    it 'returns the expected string with a delay argument' do\n      delay = rand(1000..1999)\n      assert_equal \"flush_all #{delay}\\r\\n\", Dalli::Protocol::Meta::RequestFormatter.flush(delay: delay)\n    end\n\n    it 'santizes the delay argument' do\n      delay = \"\\nset importantkey 1 1000 8\\ninjected\"\n      assert_equal \"flush_all 0\\r\\n\", Dalli::Protocol::Meta::RequestFormatter.flush(delay: delay)\n    end\n\n    it 'adds noreply with a delay and quiet argument' do\n      delay = rand(1000..1999)\n      assert_equal \"flush_all #{delay} noreply\\r\\n\",\n                   Dalli::Protocol::Meta::RequestFormatter.flush(delay: delay, quiet: true)\n    end\n  end\nend\n", "# frozen_string_literal: true\n\nrequire_relative 'helper'\n\nrequire 'json'\nrequire 'rack/session/dalli'\nrequire 'rack/lint'\nrequire 'rack/mock'\ndescribe Rack::Session::Dalli do\n  before do\n    @port = 19_129\n    memcached_persistent(:binary, @port)\n    Rack::Session::Dalli::DEFAULT_DALLI_OPTIONS[:memcache_server] = \"localhost:#{@port}\"\n\n    # test memcache connection\n    Rack::Session::Dalli.new(incrementor)\n  end\n\n  let(:session_key) { Rack::Session::Dalli::DEFAULT_OPTIONS[:key] }\n  let(:session_match) do\n    /#{session_key}=([0-9a-fA-F]+);/\n  end\n  let(:incrementor_proc) do\n    lambda do |env|\n      env['rack.session']['counter'] ||= 0\n      env['rack.session']['counter'] += 1\n      Rack::Response.new(env['rack.session'].inspect).to_a\n    end\n  end\n  let(:drop_session) do\n    Rack::Lint.new(proc do |env|\n                     env['rack.session.options'][:drop] = true\n                     incrementor_proc.call(env)\n                   end)\n  end\n  let(:renew_session) do\n    Rack::Lint.new(proc do |env|\n                     env['rack.session.options'][:renew] = true\n                     incrementor_proc.call(env)\n                   end)\n  end\n  let(:defer_session) do\n    Rack::Lint.new(proc do |env|\n                     env['rack.session.options'][:defer] = true\n                     incrementor_proc.call(env)\n                   end)\n  end\n  let(:skip_session) do\n    Rack::Lint.new(proc do |env|\n                     env['rack.session.options'][:skip] = true\n                     incrementor_proc.call(env)\n                   end)\n  end\n  let(:incrementor) { Rack::Lint.new(incrementor_proc) }\n\n  it 'faults on no connection' do\n    rsd = Rack::Session::Dalli.new(incrementor, memcache_server: 'nosuchserver')\n    assert_raises Dalli::RingError do\n      rsd.data.with { |c| c.set('ping', '') }\n    end\n  end\n\n  it 'connects to existing server' do\n    rsd = Rack::Session::Dalli.new(incrementor, namespace: 'test:rack:session')\n    assert_silent do\n      rsd.data.with { |c| c.set('ping', '') }\n    end\n  end\n\n  it 'passes options to MemCache' do\n    opts = {\n      namespace: 'test:rack:session',\n      compression_min_size: 1234\n    }\n\n    rsd = Rack::Session::Dalli.new(incrementor, opts)\n    assert_equal(opts[:namespace], rsd.data.with { |c| c.instance_eval { @options[:namespace] } })\n    assert_equal(opts[:compression_min_size], rsd.data.with { |c| c.instance_eval { @options[:compression_min_size] } })\n  end\n\n  it 'rejects a :cache option' do\n    server = Rack::Session::Dalli::DEFAULT_DALLI_OPTIONS[:memcache_server]\n    cache = Dalli::Client.new(server, namespace: 'test:rack:session')\n    assert_raises RuntimeError do\n      Rack::Session::Dalli.new(incrementor, cache: cache, namespace: 'foobar')\n    end\n  end\n\n  it 'generates sids without an existing Dalli::Client' do\n    rsd = Rack::Session::Dalli.new(incrementor)\n    assert rsd.send :generate_sid\n  end\n\n  it 'upgrades to a connection pool' do\n    opts = {\n      namespace: 'test:rack:session',\n      pool_size: 10\n    }\n\n    with_connectionpool do\n      rsd = Rack::Session::Dalli.new(incrementor, opts)\n      assert_equal 10, rsd.data.available\n      rsd.data.with do |mc|\n        assert_equal(opts[:namespace], mc.instance_eval { @options[:namespace] })\n      end\n    end\n  end\n\n  it 'creates a new cookie' do\n    rsd = Rack::Session::Dalli.new(incrementor)\n    res = Rack::MockRequest.new(rsd).get('/')\n    assert_includes res['Set-Cookie'], \"#{session_key}=\"\n    assert_equal '{\"counter\"=>1}', res.body\n  end\n\n  it 'determines session from a cookie' do\n    rsd = Rack::Session::Dalli.new(incrementor)\n    req = Rack::MockRequest.new(rsd)\n    res = req.get('/')\n    cookie = res['Set-Cookie']\n    assert_equal '{\"counter\"=>2}', req.get('/', 'HTTP_COOKIE' => cookie).body\n    assert_equal '{\"counter\"=>3}', req.get('/', 'HTTP_COOKIE' => cookie).body\n  end\n\n  it 'determines session only from a cookie by default' do\n    rsd = Rack::Session::Dalli.new(incrementor)\n    req = Rack::MockRequest.new(rsd)\n    res = req.get('/')\n    sid = res['Set-Cookie'][session_match, 1]\n    assert_equal '{\"counter\"=>1}', req.get(\"/?rack.session=#{sid}\").body\n    assert_equal '{\"counter\"=>1}', req.get(\"/?rack.session=#{sid}\").body\n  end\n\n  it 'determines session from params' do\n    rsd = Rack::Session::Dalli.new(incrementor, cookie_only: false)\n    req = Rack::MockRequest.new(rsd)\n    res = req.get('/')\n    sid = res['Set-Cookie'][session_match, 1]\n    assert_equal '{\"counter\"=>2}', req.get(\"/?rack.session=#{sid}\").body\n    assert_equal '{\"counter\"=>3}', req.get(\"/?rack.session=#{sid}\").body\n  end\n\n  it 'survives nonexistant cookies' do\n    bad_cookie = 'rack.session=blarghfasel'\n    rsd = Rack::Session::Dalli.new(incrementor)\n    res = Rack::MockRequest.new(rsd)\n                           .get('/', 'HTTP_COOKIE' => bad_cookie)\n    assert_equal '{\"counter\"=>1}', res.body\n    cookie = res['Set-Cookie'][session_match]\n    refute_match(/#{bad_cookie}/, cookie)\n  end\n\n  it 'survives nonexistant blank cookies' do\n    bad_cookie = 'rack.session='\n    rsd = Rack::Session::Dalli.new(incrementor)\n    res = Rack::MockRequest.new(rsd)\n                           .get('/', 'HTTP_COOKIE' => bad_cookie)\n    cookie = res['Set-Cookie'][session_match]\n    refute_match(/#{bad_cookie}$/, cookie)\n  end\n\n  it 'sets an expiration on new sessions' do\n    rsd = Rack::Session::Dalli.new(incrementor, expire_after: 3)\n    res = Rack::MockRequest.new(rsd).get('/')\n    assert_includes res.body, '\"counter\"=>1'\n    cookie = res['Set-Cookie']\n    puts 'Sleeping to expire session' if $DEBUG\n    sleep 4\n    res = Rack::MockRequest.new(rsd).get('/', 'HTTP_COOKIE' => cookie)\n    refute_equal cookie, res['Set-Cookie']\n    assert_includes res.body, '\"counter\"=>1'\n  end\n\n  it 'maintains freshness of existing sessions' do\n    rsd = Rack::Session::Dalli.new(incrementor, expire_after: 3)\n    res = Rack::MockRequest.new(rsd).get('/')\n    assert_includes res.body, '\"counter\"=>1'\n    cookie = res['Set-Cookie']\n    res = Rack::MockRequest.new(rsd).get('/', 'HTTP_COOKIE' => cookie)\n    assert_equal cookie, res['Set-Cookie']\n    assert_includes res.body, '\"counter\"=>2'\n    puts 'Sleeping to expire session' if $DEBUG\n    sleep 4\n    res = Rack::MockRequest.new(rsd).get('/', 'HTTP_COOKIE' => cookie)\n    refute_equal cookie, res['Set-Cookie']\n    assert_includes res.body, '\"counter\"=>1'\n  end\n\n  it 'does not send the same session id if it did not change' do\n    rsd = Rack::Session::Dalli.new(incrementor)\n    req = Rack::MockRequest.new(rsd)\n\n    res0 = req.get('/')\n    cookie = res0['Set-Cookie'][session_match]\n    assert_equal '{\"counter\"=>1}', res0.body\n\n    res1 = req.get('/', 'HTTP_COOKIE' => cookie)\n    assert_nil res1['Set-Cookie']\n    assert_equal '{\"counter\"=>2}', res1.body\n\n    res2 = req.get('/', 'HTTP_COOKIE' => cookie)\n    assert_nil res2['Set-Cookie']\n    assert_equal '{\"counter\"=>3}', res2.body\n  end\n\n  it 'deletes cookies with :drop option' do\n    rsd = Rack::Session::Dalli.new(incrementor)\n    req = Rack::MockRequest.new(rsd)\n    drop = Rack::Utils::Context.new(rsd, drop_session)\n    dreq = Rack::MockRequest.new(drop)\n\n    res1 = req.get('/')\n    session = (cookie = res1['Set-Cookie'])[session_match]\n    assert_equal '{\"counter\"=>1}', res1.body\n\n    res2 = dreq.get('/', 'HTTP_COOKIE' => cookie)\n    assert_nil res2['Set-Cookie']\n    assert_equal '{\"counter\"=>2}', res2.body\n\n    res3 = req.get('/', 'HTTP_COOKIE' => cookie)\n    refute_equal session, res3['Set-Cookie'][session_match]\n    assert_equal '{\"counter\"=>1}', res3.body\n  end\n\n  it 'provides new session id with :renew option' do\n    rsd = Rack::Session::Dalli.new(incrementor)\n    req = Rack::MockRequest.new(rsd)\n    renew = Rack::Utils::Context.new(rsd, renew_session)\n    rreq = Rack::MockRequest.new(renew)\n\n    res1 = req.get('/')\n    session = (cookie = res1['Set-Cookie'])[session_match]\n    assert_equal '{\"counter\"=>1}', res1.body\n\n    res2 = rreq.get('/', 'HTTP_COOKIE' => cookie)\n    new_cookie = res2['Set-Cookie']\n    new_session = new_cookie[session_match]\n    refute_equal session, new_session\n    assert_equal '{\"counter\"=>2}', res2.body\n\n    res3 = req.get('/', 'HTTP_COOKIE' => new_cookie)\n    assert_equal '{\"counter\"=>3}', res3.body\n\n    # Old cookie was deleted\n    res4 = req.get('/', 'HTTP_COOKIE' => cookie)\n    assert_equal '{\"counter\"=>1}', res4.body\n  end\n\n  it 'omits cookie with :defer option but still updates the state' do\n    rsd = Rack::Session::Dalli.new(incrementor)\n    count = Rack::Utils::Context.new(rsd, incrementor)\n    defer = Rack::Utils::Context.new(rsd, defer_session)\n    dreq = Rack::MockRequest.new(defer)\n    creq = Rack::MockRequest.new(count)\n\n    res0 = dreq.get('/')\n    assert_nil res0['Set-Cookie']\n    assert_equal '{\"counter\"=>1}', res0.body\n\n    res0 = creq.get('/')\n    res1 = dreq.get('/', 'HTTP_COOKIE' => res0['Set-Cookie'])\n    assert_equal '{\"counter\"=>2}', res1.body\n    res2 = dreq.get('/', 'HTTP_COOKIE' => res0['Set-Cookie'])\n    assert_equal '{\"counter\"=>3}', res2.body\n  end\n\n  it 'omits cookie and state update with :skip option' do\n    rsd = Rack::Session::Dalli.new(incrementor)\n    count = Rack::Utils::Context.new(rsd, incrementor)\n    skip = Rack::Utils::Context.new(rsd, skip_session)\n    sreq = Rack::MockRequest.new(skip)\n    creq = Rack::MockRequest.new(count)\n\n    res0 = sreq.get('/')\n    assert_nil res0['Set-Cookie']\n    assert_equal '{\"counter\"=>1}', res0.body\n\n    res0 = creq.get('/')\n    res1 = sreq.get('/', 'HTTP_COOKIE' => res0['Set-Cookie'])\n    assert_equal '{\"counter\"=>2}', res1.body\n    res2 = sreq.get('/', 'HTTP_COOKIE' => res0['Set-Cookie'])\n    assert_equal '{\"counter\"=>2}', res2.body\n  end\n\n  it 'updates deep hashes correctly' do\n    hash_check = proc do |env|\n      session = env['rack.session']\n      if session.include? 'test'\n        session[:f][:g][:h] = :j\n      else\n        session.update :a => :b, :c => { d: :e },\n                       :f => { g: { h: :i } }, 'test' => true\n      end\n      [200, {}, [session.to_h.to_json]]\n    end\n    rsd = Rack::Session::Dalli.new(hash_check)\n    req = Rack::MockRequest.new(rsd)\n\n    res0 = req.get('/')\n    cookie = res0['Set-Cookie']\n    ses0 = JSON.parse(res0.body)\n    refute_nil ses0\n    assert_equal '{\"a\"=>\"b\", \"c\"=>{\"d\"=>\"e\"}, \"f\"=>{\"g\"=>{\"h\"=>\"i\"}}, \"test\"=>true}', ses0.to_s\n\n    res1 = req.get('/', 'HTTP_COOKIE' => cookie)\n    ses1 = JSON.parse(res1.body)\n    refute_nil ses1\n    assert_equal '{\"a\"=>\"b\", \"c\"=>{\"d\"=>\"e\"}, \"f\"=>{\"g\"=>{\"h\"=>\"j\"}}, \"test\"=>true}', ses1.to_s\n\n    refute_equal ses0, ses1\n  end\nend\n"], "filenames": ["CHANGELOG.md", "lib/dalli/protocol/meta.rb", "lib/dalli/protocol/meta/request_formatter.rb", "test/integration/test_network.rb", "test/protocol/meta/test_request_formatter.rb", "test/test_rack_session.rb"], "buggy_code_start_loc": [6, 46, 34, 9, 79, 56], "buggy_code_end_loc": [6, 46, 104, 64, 130, 66], "fixing_code_start_loc": [7, 47, 34, 10, 80, 57], "fixing_code_end_loc": [9, 48, 118, 64, 234, 65], "type": "CWE-74", "message": "A vulnerability was found in Dalli. It has been classified as problematic. Affected is the function self.meta_set of the file lib/dalli/protocol/meta/request_formatter.rb of the component Meta Protocol Handler. The manipulation leads to injection. The exploit has been disclosed to the public and may be used. The name of the patch is 48d594dae55934476fec61789e7a7c3700e0f50d. It is recommended to apply a patch to fix this issue. VDB-214026 is the identifier assigned to this vulnerability.", "other": {"cve": {"id": "CVE-2022-4064", "sourceIdentifier": "cna@vuldb.com", "published": "2022-11-19T19:15:09.780", "lastModified": "2022-11-26T03:22:58.140", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A vulnerability was found in Dalli. It has been classified as problematic. Affected is the function self.meta_set of the file lib/dalli/protocol/meta/request_formatter.rb of the component Meta Protocol Handler. The manipulation leads to injection. The exploit has been disclosed to the public and may be used. The name of the patch is 48d594dae55934476fec61789e7a7c3700e0f50d. It is recommended to apply a patch to fix this issue. VDB-214026 is the identifier assigned to this vulnerability."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 3.7, "baseSeverity": "LOW"}, "exploitabilityScore": 2.2, "impactScore": 1.4}, {"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:A/AC:H/PR:N/UI:N/S:U/C:N/I:L/A:N", "attackVector": "ADJACENT_NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 3.1, "baseSeverity": "LOW"}, "exploitabilityScore": 1.6, "impactScore": 1.4}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-74"}]}, {"source": "cna@vuldb.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-707"}, {"lang": "en", "value": "CWE-74"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:dalli_project:dalli:*:*:*:*:*:ruby:*:*", "versionStartIncluding": "-", "versionEndExcluding": "3.2.3", "matchCriteriaId": "1E4D2EAA-00C7-487E-9FCF-0C454555528E"}]}]}], "references": [{"url": "https://github.com/petergoldstein/dalli/commit/48d594dae55934476fec61789e7a7c3700e0f50d", "source": "cna@vuldb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/petergoldstein/dalli/issues/932", "source": "cna@vuldb.com", "tags": ["Exploit", "Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/petergoldstein/dalli/pull/933", "source": "cna@vuldb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://vuldb.com/?id.214026", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/petergoldstein/dalli/commit/48d594dae55934476fec61789e7a7c3700e0f50d"}}