{"buggy_code": ["2022-07-01 Unreleased version\n  C++\n  * cpp_generated_lib_linked support is removed in protoc\n  * Reduced .pb.o object file size slightly by explicitly instantiating\n    InternalMetadata templates in the runtime.\n  * Add C++20 keywords guarded by PROTOBUF_FUTURE_CPP20_KEYWORDS\n  * Fixed crash in ThreadLocalStorage for pre-C++17 compilers on 32-bit ARM.\n  * Clarified that JSON API non-OK statuses are not a stable API.\n  * Added a default implementation of MessageDifferencer::Reporter methods.\n  * proto2::MapPair is now an alias to std::pair.\n  * Hide C++ RepeatedField::UnsafeArenaSwap\n  * Use table-driven parser for reflection based objects.\n  * Update Map's InternalSwap() to take a pointer to the other Map.\n  * Add ARM-optimized Varint decoding functions.\n  * Minor optimization for parsing groups\n  * Declare ReflectiveProtoHook class\n  * Reduce size of VarintParse code in protocol buffers, by calling the shared\n    routine after handling just one-byte varint encoding inline, rather than\n    handling one-byte and two-byte varints inline.\n  * Avoid inlining some large heavily duplicated routines in repeated_ptr_field.h\n  * Add ReflectiveProtoHook to Reflection.\n  * Turns on table-driven parser for reflection based objects.\n  * Save code space by avoiding inlining of large-in-aggregate code-space MessageLite::~MessageLite destructor.\n  * Undefine the macro `linux` when compiling protobuf\n  * Reduce memory consumption of MessageSet parsing.\n  * Save code space by avoiding inlining of large-in-aggregate code-space MessageLite::~MessageLite destructor.\n  * Breaking change: delete Arena::Init\n  * Make a PROTOBUF_POISON/UNPOISON to reduce noise in the source\n\n\n  Kotlin\n  * Suppress deprecation warnings in Kotlin generated code.\n  * Kotlin generated code comments now use kdoc format instead of javadoc.\n  * Escape keywords in package names in proto generated code\n  * Add Kotlin enum int value getters and setters\n\n  Java\n  * Performance improvement for repeated use of FieldMaskUtil#merge by caching\n    constructed FieldMaskTrees.\n  * Optimized Java proto serialization gencode for protos having many extension ranges with few fields in between.\n  * More thoroughly annotate public generated code in Java lite protocol buffers.\n  * Fixed Bug in proto3 java lite repeated enum fields. Failed to call copyOnWrite before modifying previously built message. Causes modification to already \"built\" messages that should be immutable.\n  * Refactoring java full runtime to reuse sub-message builders and prepare to migrate parsing logic from parse constructor to builder.\n  * Fix Java reflection serialization of empty packed fields.\n\n  Python\n  * Changes ordering of printed fields in .pyi files from lexicographic to the same ordering found in the proto descriptor.\n  * Adds GeneratedCodeInfo annotations to python proto .pyi outputs as a base64 encoded docstring in the last line of the .pyi file for code analysis tools.\n  * Fix message factory's behavior in python cpp extension to return same message classes for same descriptor, even if the factories are different.\n\n  Compiler\n  * Print full path name of source .proto file on error\n\n2022-09-13 version 21.6 (C++/Java/Python/PHP/Objective-C/C#/Ruby)\n\nC++\n* Reduce memory consumption of MessageSet parsing\n\n2022-08-09 version 21.5 (C++/Java/Python/PHP/Objective-C/C#/Ruby)\n\n  PHP\n  * Added getContainingOneof and getRealContainingOneof to descriptor.\n  * fix PHP readonly legacy files for nested messages\n\n  Python\n  * Fixed comparison of maps in Python.\n\n2022-07-25 version 21.4 (C++/Java/Python/PHP/Objective-C/C#/Ruby)\n\n  C++\n  * Reduce the required alignment of ArenaString from 8 to 4 (#10298)\n\n\n2022-07-19 version 21.3 (C++/Java/Python/PHP/Objective-C/C#/Ruby)\n  C++\n  * Add header search paths to Protobuf-C++.podspec (#10024)\n  * Fixed Visual Studio constinit errors (#10232)\n  * Fix #9947: make the ABI compatible between debug and non-debug builds (#10271)\n\n  UPB\n  * Allow empty package names (fixes behavior regression in 4.21.0)\n  * Fix a SEGV bug when comparing a non-materialized sub-message (#10208)\n  * Fix several bugs in descriptor mapping containers (eg. descriptor.services_by_name)\n    * for x in mapping now yields keys rather than values, to match Python conventions and the behavior of the old library.\n    * Lookup operations now correctly reject unhashable types as map keys.\n    * We implement repr() to use the same format as dict.\n  * Fix maps to use the ScalarMapContainer class when appropriate\n  * Fix bug when parsing an unknown value in a proto2 enum extension (protocolbuffers/upb#717)\n\n  PHP\n  * Add \"readonly\" as a keyword for PHP and add previous classnames to descriptor pool (#10041)\n\n  Python\n  * Make //:protobuf_python and //:well_known_types_py_pb2 public (#10118)\n\n  Bazel\n  * Add back a filegroup for :well_known_protos (#10061)\n\n2022-06-27 version 21.2 (C++/Java/Python/PHP/Objective-C/C#/Ruby)\n  C++\n  * ArenaString improvements (fix alignment issue)\n\n  PHP\n  * API changes for OneOf  (#10102)\n\n\n2022-05-27 version 21.1 (C++/Java/Python/PHP/Objective-C/C#/Ruby)\n\n  C++\n  * cmake: Revert \"Fix cmake install targets (#9822)\" (#10060)\n  * Remove Abseil dependency from CMake build (#10056)\n\n  Python\n  * Update python wheel metadata with more information incl. required python version (#10058)\n  * Fix segmentation fault when instantiating field via repeated field assignment (#10066)\n\n2022-05-25 version 21.0 (C++/Java/Python/PHP/Objective-C/C#/Ruby)\n\n  C++\n  * cmake: Call get_filename_component() with DIRECTORY mode instead of PATH mode (#9614)\n  * Escape GetObject macro inside protoc-generated code (#9739)\n  * Update CMake configuration to add a dependency on Abseil (#9793)\n  * Fix cmake install targets (#9822)\n  * Use __constinit only in GCC 12.2 and up (#9936)\n\n  Java\n  * Update protobuf_version.bzl to separate protoc and per-language java \u2026 (#9900)\n\n  Python\n  * Increment python major version to 4 in version.json for python upb (#9926)\n  * The C extension module for Python has been rewritten to use the upb library.\n    This is expected to deliver significant performance benefits, especially when\n    parsing large payloads.  There are some minor breaking changes, but these\n    should not impact most users.  For more information see:\n    https://developers.google.com/protocol-buffers/docs/news/2022-05-06#python-updates\n  * Fixed win32 build and fixed str(message) on all Windows platforms. (#9976)\n  * The binary wheel for macOS now supports Apple silicon.\n\n  PHP\n  * [PHP] fix PHP build system (#9571)\n  * Fix building packaged PHP extension (#9727)\n  * fix: reserve \"ReadOnly\" keyword for PHP 8.1 and add compatibility (#9633)\n  * fix: phpdoc syntax for repeatedfield parameters (#9784)\n  * fix: phpdoc for repeatedfield (#9783)\n  * Change enum string name for reserved words (#9780)\n  * chore: [PHP] fix phpdoc for MapField keys (#9536)\n  * Fixed PHP SEGV by not writing to shared memory for zend_class_entry. (#9996)\n\n  Ruby\n  * Allow pre-compiled binaries for ruby 3.1.0 (#9566)\n  * Implement `respond_to?` in RubyMessage (#9677)\n  * [Ruby] Fix RepeatedField#last, #first inconsistencies (#9722)\n  * Do not use range based UTF-8 validation in truffleruby (#9769)\n  * Improve range handling logic of `RepeatedField` (#9799)\n  * Support x64-mingw-ucrt platform\n\n  Other\n  * [Kotlin] remove redundant public modifiers for compiled code (#9642)\n  * [C#] Update GetExtension to support getting typed value (#9655)\n  * Fix invalid dependency manifest when using `descriptor_set_out` (#9647)\n  * Fix C# generator handling of a field named \"none\" in a oneof (#9636)\n  * Add initial version.json file for 21-dev (#9840)\n  * Remove duplicate java generated code (#9909)\n  * Cherry-pick PR #9981 into 21.x branch (#10000)\n\n\n2022-05-19 version 21.0-rc2(C++/Java/Python/PHP/Objective-C/C#/Ruby)\n\n  Python\n  * Fix windows builds\n  * Throw more helpful error if generated code is out of date\n  * Fixed two reference leaks\n\n  Ruby\n  * Support x64-mingw-ucrt platform\n\n  PHP\n  * Fix SEGV by not writing to shared memory for zend_class_entry\n\n  C#\n  * Suppress warning CS8981\n\n  Other\n  * Fix Maven release to release actual osx_aarch64 binary\n  * Fix protoc zips to have the proto files for well known types\n\n2022-05-10 version 21.0-rc1 (C++/Java/Python/PHP/Objective-C/C#/Ruby)\n\n  C++\n  * Rename main cmake/CMakeLists.txt to CMakeLists.txt (#9603)\n  * avoid allocating memory if all extension are cleared (#9345)\n  * cmake: Call get_filename_component() with DIRECTORY mode instead of PATH mode (#9614)\n  * Escape GetObject macro inside protoc-generated code (#9739)\n  * Update CMake configuration to add a dependency on Abseil (#9793)\n  * Use __constinit only in GCC 12.2 and up (#9936)\n  * Refactor generated message class layout\n  * Optimize tokenizer ParseInteger by removing division\n  * Reserve exactly the right amount of capacity in ExtensionSet::MergeFrom\n  * Parse FLT_MAX correctly when represented in JSON\n\n  Java\n  * Update protobuf_version.bzl to separate protoc and per-language java \u2026 (#9900)\n  * 6x speedup in ArrayEncoder.writeUInt32NotTag\n  * Java generated code is no longer compatible with runtimes 2.6.1 and earlier\n\n  Python\n  * Increment python major version to 4 in version.json for python upb (#9926)\n  * The C extension module for Python has been rewritten to use the upb library.\n    This is expected to deliver significant performance benefits, especially when\n    parsing large payloads.  There are some minor breaking changes, but these\n    should not impact most users.  For more information see:\n    https://developers.google.com/protocol-buffers/docs/news/2022-05-06#python-updates\n  * Due to the breaking changes for Python, the major version number for Python\n    has been incremented.\n  * The binary wheel for macOS now supports Apple silicon.\n  * In TextFormat, transform UnicodeDecodeError into ParseError.\n\n\n  PHP\n  * chore: [PHP] fix phpdoc for MapField keys (#9536)\n  * [PHP] Remove unnecessary zval initialization (#9600)\n  * [PHP] fix PHP build system (#9571)\n  * Fix building packaged PHP extension (#9727)\n  * fix: reserve \"ReadOnly\" keyword for PHP 8.1 and add compatibility (#9633)\n  * fix: phpdoc syntax for repeatedfield parameters (#9784)\n  * fix: phpdoc for repeatedfield (#9783)\n  * Change enum string name for reserved words (#9780)\n  * Fixed composer.json to only advertise compatibility with PHP 7.0+.  (#9819)\n\n  Ruby\n  * Allow pre-compiled binaries for ruby 3.1.0 (#9566)\n  * Implement `respond_to?` in RubyMessage (#9677)\n  * [Ruby] Fix RepeatedField#last, #first inconsistencies (#9722)\n  * Do not use range based UTF-8 validation in truffleruby (#9769)\n  * Improve range handling logic of `RepeatedField` (#9799)\n  * Disable the aarch64 build on macOS until it can be fixed. (#9816)\n\n  Other\n  * [Kotlin] remove redundant public modifiers for compiled code (#9642)\n  * [C#] Update GetExtension to support getting typed value (#9655)\n  * Fix invalid dependency manifest when using `descriptor_set_out` (#9647)\n  * Fix C# generator handling of a field named \"none\" in a oneof (#9636)\n  * Add initial version.json file for 21-dev (#9840)\n  * Remove duplicate java generated code (#9909)\n  * Fix versioning issues in 3.20.0\n\n  Compiler\n  * Protoc outputs the list of suggested field numbers when invalid field\n    numbers are specified in the .proto file.\n  * Require package names to be less than 512 bytes in length\n\n2022-04-21 version 3.20.1 (C++/Java/Python/PHP/Objective-C/C#/Ruby/JavaScript)\n\n  PHP\n  * Fix building packaged PHP extension (#9727)\n\n  Other\n  * Fix versioning issues in 3.20.0\n\n2022-03-04 version 3.20.0 (C++/Java/Python/PHP/Objective-C/C#/Ruby/JavaScript)\n\n  Ruby\n  * Dropped Ruby 2.3 and 2.4 support for CI and releases. (#9311)\n  * Added Ruby 3.1 support for CI and releases (#9566).\n  * Message.decode/encode: Add recursion_limit option (#9218/#9486)\n  * Allocate with xrealloc()/xfree() so message allocation is visible to the\n    Ruby GC.  In certain tests this leads to much lower memory usage due to more\n    frequent GC runs (#9586).\n  * Fix conversion of singleton classes in Ruby (#9342)\n  * Suppress warning for intentional circular require (#9556)\n  * JSON will now output shorter strings for double and float fields when possible\n    without losing precision.\n  * Encoding and decoding of binary format will now work properly on big-endian\n    systems.\n  * UTF-8 verification was fixed to properly reject surrogate code points.\n  * Unknown enums for proto2 protos now properly implement proto2's behavior of\n    putting such values in unknown fields.\n\n  Java\n  * Revert \"Standardize on Array copyOf\" (#9400)\n  * Resolve more java field accessor name conflicts (#8198)\n  * Don't support map fields in DynamicMessage.Builder.{getFieldBuilder,getRepeatedFieldBuilder}\n  * Fix parseFrom to only throw InvalidProtocolBufferException\n  * InvalidProtocolBufferException now allows arbitrary wrapped Exception types.\n  * Fix bug in `FieldSet.Builder.mergeFrom`\n  * Flush CodedOutputStream also flushes underlying OutputStream\n  * When oneof case is the same and the field type is Message, merge the\n    subfield. (previously it was replaced.)\u2019\n  * Add @CheckReturnValue to some protobuf types\n  * Report original exceptions when parsing JSON\n  * Add more info to @deprecated javadoc for set/get/has methods\n  * Fix initialization bug in doc comment line numbers\n  * Fix comments for message set wire format.\n\n  Kotlin\n  * Add test scope to kotlin-test for protobuf-kotlin-lite (#9518)\n  * Add orNull extensions for optional message fields.\n  * Add orNull extensions to all proto3 message fields.\n\n  Python\n  * Dropped support for Python < 3.7 (#9480)\n  * Protoc is now able to generate python stubs (.pyi) with --pyi_out\n  * Pin multibuild scripts to get manylinux1 wheels back (#9216)\n  * Fix type annotations of some Duration and Timestamp methods.\n  * Repeated field containers are now generic in field types and could be used\n    in type annotations.\n  * Protobuf python generated codes are simplified. Descriptors and message\n    classes' definitions are now dynamic created in internal/builder.py.\n    Insertion Points for messages classes are discarded.\n  * has_presence is added for FieldDescriptor in python\n  * Loosen indexing type requirements to allow valid __index__() implementations\n    rather than only PyLongObjects.\n  * Fix the deepcopy bug caused by not copying message_listener.\n  * Added python JSON parse recursion limit (default 100)\n  * Path info is added for python JSON parse errors\n  * Pure python repeated scalar fields will not able to pickle. Convert to list\n    first.\n  * Timestamp.ToDatetime() now accepts an optional tzinfo parameter. If\n    specified, the function returns a timezone-aware datetime in the given time\n    zone. If omitted or None, the function returns a timezone-naive UTC datetime\n    (as previously).\n  * Adds client_streaming and server_streaming fields to MethodDescriptor.\n  * Add \"ensure_ascii\" parameter to json_format.MessageToJson. This allows smaller\n    JSON serializations with UTF-8 or other non-ASCII encodings.\n  * Added experimental support for directly assigning numpy scalars and array.\n  * Improve the calculation of public_dependencies in DescriptorPool.\n  * [Breaking Change] Disallow setting fields to numpy singleton arrays or repeated fields to numpy\n    multi-dimensional arrays. Numpy arrays should be indexed or flattened explicitly before assignment.\n\n  Compiler\n  * Migrate IsDefault(const std::string*) and UnsafeSetDefault(const std::string*)\n  * Implement strong qualified tags for TaggedPtr\n  * Rework allocations to power-of-two byte sizes.\n  * Migrate IsDefault(const std::string*) and UnsafeSetDefault(const std::string*)\n  * Implement strong qualified tags for TaggedPtr\n  * Make TaggedPtr Set...() calls explicitly spell out the content type.\n  * Check for parsing error before verifying UTF8.\n  * Enforce a maximum message nesting limit of 32 in the descriptor builder to\n    guard against stack overflows\n  * Fixed bugs in operators for RepeatedPtrIterator\n  * Assert a maximum map alignment for allocated values\n  * Fix proto1 group extension protodb parsing error\n  * Do not log/report the same descriptor symbol multiple times if it contains\n    more than one invalid character.\n  * Add UnknownFieldSet::SerializeToString and SerializeToCodedStream.\n  * Remove explicit default pointers and deprecated API from protocol compiler\n\n  Arenas\n  * Change Repeated*Field to reuse memory when using arenas.\n  * Implements pbarenaz for profiling proto arenas\n  * Introduce CreateString() and CreateArenaString() for cleaner semantics\n  * Fix unreferenced parameter for MSVC builds\n  * Add UnsafeSetAllocated to be used for one-of string fields.\n  * Make Arena::AllocateAligned() a public function.\n  * Determine if ArenaDtor related code generation is necessary in one place.\n  * Implement on demand register ArenaDtor for InlinedStringField\n\n  C++\n  * Enable testing via CTest (#8737)\n  * Add option to use external GTest in CMake (#8736)\n  * CMake: Set correct sonames for libprotobuf-lite.so and libprotoc.so (#8635) (#9529)\n  * Add cmake option `protobuf_INSTALL` to not install files (#7123)\n  * CMake: Allow custom plugin options e.g. to generate mocks (#9105)\n  * CMake: Use linker version scripts (#9545)\n  * Manually *struct Cord fields to work better with arenas.\n  * Manually destruct map fields.\n  * Generate narrower code\n  * Fix https://github.com/protocolbuffers/protobuf/issues/9378 by removing\n    shadowed _cached_size_ field\n  * Remove GetPointer() and explicit nullptr defaults.\n  * Add proto_h flag for speeding up large builds\n  * Add missing overload for reference wrapped fields.\n  * Add MergedDescriptorDatabase::FindAllFileNames()\n  * RepeatedField now defines an iterator type instead of using a pointer.\n  * Remove obsolete macros GOOGLE_PROTOBUF_HAS_ONEOF and GOOGLE_PROTOBUF_HAS_ARENAS.\n\n  PHP\n  * Fix: add missing reserved classnames (#9458)\n  * PHP 8.1 compatibility (#9370)\n\n  C#\n  * Fix trim warnings (#9182)\n  * Fixes NullReferenceException when accessing FieldDescriptor.IsPacked (#9430)\n  * Add ToProto() method to all descriptor classes (#9426)\n  * Add an option to preserve proto names in JsonFormatter (#6307)\n\n  Objective-C\n  * Add prefix_to_proto_package_mappings_path option. (#9498)\n  * Rename `proto_package_to_prefix_mappings_path` to `package_to_prefix_mappings_path`. (#9552)\n  * Add a generation option to control use of forward declarations in headers. (#9568)\n\n2022-01-28 version 3.19.4 (C++/Java/Python/PHP/Objective-C/C#/Ruby/JavaScript)\n\n  Python\n  * Make libprotobuf symbols local on OSX to fix issue #9395 (#9435)\n\n  Ruby\n  * Fixed a data loss bug that could occur when the number of `optional`\n    fields in a message is an exact multiple of 32. (#9440).\n\n  PHP\n  * Fixed a data loss bug that could occur when the number of `optional`\n    fields in a message is an exact multiple of 32. (#9440).\n\n2022-01-10 version 3.19.3 (C++/Java/Python/PHP/Objective-C/C#/Ruby/JavaScript)\n\n  Python\n  * Fix missing Windows wheel for Python 3.10 on PyPI\n\n2022-01-05 version 3.19.2 (C++/Java/Python/PHP/Objective-C/C#/Ruby/JavaScript)\n\n  Java\n  * Improve performance characteristics of UnknownFieldSet parsing (#9371)\n  * This release addresses a Security Advisory for Java users\n   (https://github.com/protocolbuffers/protobuf/security/advisories/GHSA-wrvw-hg22-4m67)\n\n2022-01-05 version 3.18.2 (C++/Java/Python/PHP/Objective-C/C#/Ruby/JavaScript)\n\n  Java\n  * Improve performance characteristics of UnknownFieldSet parsing (#9371)\n  * This release addresses a Security Advisory for Java users\n   (https://github.com/protocolbuffers/protobuf/security/advisories/GHSA-wrvw-hg22-4m67)\n\n2022-01-05 version 3.16.1 (Java)\n\n  Java\n  * Improve performance characteristics of UnknownFieldSet parsing (#9371)\n  * This release addresses a Security Advisory for Java users\n   (https://github.com/protocolbuffers/protobuf/security/advisories/GHSA-wrvw-hg22-4m67)\n\n2021-10-28 version 3.19.1 (C++/Java/Python/PHP/Objective-C/C#/Ruby/JavaScript)\n\n  Bazel\n  * Ensure that release archives contain everything needed for Bazel (#9131)\n  * Align dependency handling with Bazel best practices (#9165)\n\n  JavaScript\n  * Fix `ReferenceError: window is not defined` when getting the global object (#9156)\n\n  Ruby\n  * Fix memory leak in MessageClass.encode (#9150)\n\n2021-10-15 version 3.19.0 (C++/Java/Python/PHP/Objective-C/C#/Ruby/JavaScript)\n\n  C++\n  * Make proto2::Message::DiscardUnknownFields() non-virtual\n  * Separate RepeatedPtrField into its own header file\n  * For default floating point values of 0, consider all bits significant\n  * cmake: support `MSVC_RUNTIME_LIBRARY` property (#8851)\n  * Fix shadowing warnings (#8926)\n  * Fix for issue #8484, constant initialization doesn't compile in msvc clang-cl environment (#8993)\n  * Fix build on AIX and SunOS (#8373) (#9065)\n  * Add Android stlport and default toolchains to BUILD. (#8290)\n\n  Java\n  * For default floating point values of 0, consider all bits significant\n  * Annotate `//java/com/google/protobuf/util/...` with nullness annotations\n  * Use ArrayList copy constructor (#7853)\n\n  Kotlin\n  * Switch Kotlin proto DSLs to be implemented with inline value classes\n  * Fix inlining and deprecation for repeated string fields in kotlin (#9120)\n\n  Python\n  * Proto2 DecodeError now includes message name in error message\n  * Make MessageToDict convert map keys to strings (#8122)\n  * Add python-requires in setup.py (#8989)\n  * Add python 3.10 (#9034)\n\n  JavaScript\n  * Skip exports if not available by CommonJS (#8856)\n  * JS: Comply with CSP no-unsafe-eval. (#8864)\n\n  PHP\n  * Added \"object\" as a reserved name for PHP (#8962)\n\n  Ruby\n  * Override Map.clone to use Map's dup method (#7938)\n  * Ruby: build extensions for arm64-darwin (#8232)\n  * Add class method Timestamp.from_time to ruby well known types (#8562)\n  * Adopt pure ruby DSL implementation for JRuby (#9047)\n  * Add size to Map class (#8068)\n  * Fix for descriptor_pb.rb: google/protobuf should be required first (#9121)\n\n  C#\n  * Correctly set ExtensionRegistry when parsing with MessageParser, but using an already existing CodedInputStream (#7246)\n  * [C#] Make FieldDescriptor propertyName public (#7642)\n\n2021-10-04 version 3.18.1 (C++/Java/Python/PHP/Objective-C/C#/Ruby/JavaScript)\n\n  Python\n  * Update setup.py to reflect that we now require at least Python 3.5 (#8989)\n  * Performance fix for DynamicMessage: force GetRaw() to be inlined (#9023)\n\n  Ruby\n  * Update ruby_generator.cc to allow proto2 imports in proto3 (#9003)\n\n2021-09-13 version 3.18.0 (C++/Java/Python/PHP/Objective-C/C#/Ruby/JavaScript)\n\n  Python\n  * Removed Python 2.x support.\n  * Pure python descriptor_pool.AddSerializedFile() will always build the\n    file and return FileDescriptor which is same with python c++ extension\n  * type errors thrown by MergeFrom now report fully qualified class names\n  * Protobuf python generated code are simplified. Some platforms that uses\n    \"is\"(\"is not\") to compare the enum or descriptor's label/type may fail,\n    should use \"==\"(\"!=\") instead.\n\n  C++\n  * Generated code now uses the c++11 standard integer types int{32,64}_t and\n    uint{32,64}_t\n  * Reduce memory usage of the DescriptorPool type.\n  * Moved the zero-argument New() method on messages to the base class (internal\n    optimization).\n  * Unused return values marked with `PROTOBUF_MUST_USE_RESULT` are now\n    correctly attributed.\n  * Demotes PrintPath log for maps in MessageDifferencer down from WARNING to\n    INFO.\n  * Make sure FullMessageName() is always private.\n  * Fix race condition in EnumDescriptor.\n  * Remove MessageLite::GetMaybeArenaPointer.\n\n  Java\n  * Add @deprecated javadoc for set/get/has methods\n  * correctly decode \\? escape sequence in text protos\n  * Avoid depending on Objects.requireNonNull() until we can verify that no\n    users are depending on older Android versions.\n  * disallow null string map values in put and putAll\n  * Add `@CheckReturnValue` to `ByteString` API.\n  * Make the `hasPresence` method public in `FieldDescriptor`.\n  * Report more detailed messages in Duration and Timestamp proto parsing\n    errors.\n  * New Timestamps.fromDate utility method that converts a java.util.Date to a\n    Timestamp proto object.\n\n  Kotlin\n  * Generated Kotlin code is Explicit API mode compatible\n\n2021-09-13 version 3.18.0 (C++/Java/Python/PHP/Objective-C/C#/Ruby/JavaScript)\n  C++\n  * Fix warnings raised by clang 11 (#8664)\n  * Make StringPiece constructible from std::string_view (#8707)\n  * Add missing capability attributes for LLVM 12 (#8714)\n  * Stop using std::iterator (deprecated in C++17). (#8741)\n  * Move field_access_listener from libprotobuf-lite to libprotobuf (#8775)\n  * Fix #7047 Safely handle setlocale (#8735)\n  * Remove deprecated version of SetTotalBytesLimit() (#8794)\n  * Support arena allocation of google::protobuf::AnyMetadata (#8758)\n  * Fix undefined symbol error around SharedCtor() (#8827)\n  * Fix default value of enum(int) in json_util with proto2 (#8835)\n  * Better Smaller ByteSizeLong\n  * Introduce event filters for inject_field_listener_events\n  * Reduce memory usage of DescriptorPool\n  * For lazy fields copy serialized form when allowed.\n  * Re-introduce the InlinedStringField class\n  * v2 access listener\n  * Reduce padding in the proto's ExtensionRegistry map.\n  * GetExtension performance optimizations\n  * Make tracker a static variable rather than call static functions\n  * Support extensions in field access listener\n  * Annotate MergeFrom for field access listener\n  * Fix incomplete types for field access listener\n  * Add map_entry/new_map_entry to SpecificField in MessageDifferencer. They\n    record the map items which are different in MessageDifferencer's reporter.\n  * Reduce binary size due to fieldless proto messages\n  * TextFormat: ParseInfoTree supports getting field end location in addition to\n    start.\n  * Fix repeated enum extension size in field listener\n  * Enable Any Text Expansion for Descriptors::DebugString()\n  * Switch from int{8,16,32,64} to int{8,16,32,64}_t\n  * Reduce memory usage of the DescriptorPool type.\n\n  Java\n  * Fix errorprone conflict (#8723)\n  * Removing deprecated TimeUtil class. (#8749)\n  * Optimized FieldDescriptor.valueOf() to avoid array copying.\n  * Removing deprecated TimeUtil class.\n  * Add Durations.parseUnchecked(String) and Timestamps.parseUnchecked(String)\n  * FieldMaskUtil: Add convenience method to mask the fields out of a given proto.\n\n  JavaScript\n  * Optimize binary parsing of repeated float64\n  * Fix for optimization when reading doubles from binary wire format\n  * Replace toArray implementation with toJSON.\n\n  Python\n  * Drops support for 2.7 and 3.5.\n\n  PHP\n  * Migrate PHP & Ruby to ABSL wyhash (#8854)\n  * Added support for PHP 8.1 (currently in RC1) to the C extension (#8964)\n  * Fixed PHP SEGV when constructing messages from a destructor. (#8969)\n\n  Ruby\n  * Move DSL implementation from C to pure Ruby (#8850)\n  * Fixed a memory bug with RepeatedField#+. (#8970)\n\n  Other\n  * [csharp] ByteString.CreateCodedInput should use ArraySegment offset and count (#8740)\n  * [ObjC] Add support for using the proto package to prefix symbols. (#8760)\n  * field_presence.md: fix Go example (#8788)\n\n\n  Kotlin\n  * Suppress NOTHING_TO_INLINE in Kotlin generated inline functions.\n\n2021-06-04 version 3.17.3 (C++/Java/Python/PHP/Objective-C/C#/Ruby/JavaScript)\n  Python\n  * Note: This is the last release to support Python 2.7. Future releases will\n    require Python >= 3.5.\n\n  C++\n  * Introduce FieldAccessListener.\n  * Stop emitting boilerplate {Copy/Merge}From in each ProtoBuf class\n  * Fixed some uninitialized variable warnings in generated_message_reflection.cc.\n\n  Kotlin\n  * Fix duplicate proto files error (#8699)\n\n  Java\n  * Fixed parser to check that we are at a proper limit when a sub-message has\n    finished parsing.\n\n2021-05-25 version 3.17.2 (C++/Java/Python/PHP/Objective-C/C#/Ruby/JavaScript)\n  Kotlin\n  * Fix duplicate class error (#8653)\n\n  PHP\n  * Fixed SEGV in sub-message getters for well-known types when message is unset\n    (#8670)\n\n2021-05-07 version 3.17.1 (C++/Java/Python/PHP/Objective-C/C#/Ruby/JavaScript)\n  PHP\n  * Fixed PHP memory leaks and arginfo errors. (#8614)\n  * Fixed JSON parser to allow multiple values from the same oneof as long as\n    all but one are null.\n\n  Ruby\n  * Fixed memory bug: properly root repeated/map field when assigning. (#8639)\n  * Fixed JSON parser to allow multiple values from the same oneof as long as\n    all but one are null.\n\n\n2021-05-07 version 3.17.0 (C++/Java/Python/PHP/Objective-C/C#/Ruby/JavaScript)\n\n  Protocol Compiler\n  * Fix the generated source information for reserved values in Enums.\n\n  C++\n  * Fix -Wunused-parameter in map<string, int> fields (fixes #8494) (#8500)\n  * Use byteswap.h when building against musl libc (#8503)\n  * Fix -Wundefined-inline error when using SharedCtor() or SharedDtor() (#8532)\n  * Fix bug where `Descriptor::DebugString()` printed proto3 synthetic oneofs.\n  * Provide stable versions of `SortAndUnique()`.\n  * Make sure to cache proto3 optional message fields when they are cleared.\n  * Expose UnsafeArena methods to Reflection.\n  * Use std::string::empty() rather than std::string::size() > 0.\n\n  Kotlin\n  * Restrict extension setter and getter operators to non-nullable T.\n\n  Java\n  * updating GSON and Guava to more recent versions (#8524)\n  * Reduce the time spent evaluating isExtensionNumber by storing the extension\n    ranges in a TreeMap for faster queries. This is particularly relevant for\n    protos which define a large number of extension ranges, for example when\n    each tag is defined as an extension.\n  * Fix java bytecode estimation logic for optional fields.\n  * Optimize Descriptor.isExtensionNumber.\n\n  Python\n  * Add MethodDescriptor.CopyToProto() (#8327)\n  * Remove unused python_protobuf.{cc,h} (#8513)\n  * Start publishing python aarch64 manylinux wheels normally (#8530)\n  * Fix constness issue detected by MSVC standard conforming mode (#8568)\n  * Make JSON parsing match C++ and Java when multiple fields from the same\n    oneof are present and all but one is null.\n\n  Ruby\n  * Add support for proto3 json_name in compiler and field definitions (#8356)\n  * Fixed memory leak of Ruby arena objects. (#8461)\n  * Fix source gem compilation (#8471)\n  * Fix various exceptions in Ruby on 64-bit Windows (#8563)\n  * Fix crash when calculating Message hash values on 64-bit Windows (#8565)\n\n  Conformance Tests\n  * Added a conformance test for the case of multiple fields from the same\n    oneof.\n\n2021-04-06 version 3.16.0 (C++/Java/Python/PHP/Objective-C/C#/Ruby/JavaScript)\n  Other\n  * Opensourcing kotlin protos (#8272)\n  * Use a newer version of rules_proto, with the new rule `proto_descriptor_set` (#8469)\n\n  C++\n  * Fix compiler warnings issue found in conformance_test_runner #8189 (#8190)\n  * Fix MinGW-w64 build issues. (#8286)\n  * [Protoc] C++ Resolved an issue where NO_DESTROY and CONSTINIT are in incorrect order (#8296)\n  * Fix PROTOBUF_CONSTINIT macro redefinition (#8323)\n  * Delete StringPiecePod (#8353)\n  * Fix gcc error: comparison of unsigned expression in '>= 0' is always \u2026 (#8309)\n  * Fix cmake install on iOS (#8301)\n  * Create a CMake option to control whether or not RTTI is enabled (#8347)\n  * Fix endian.h location on FreeBSD (#8351)\n  * Refactor util::Status (#8354)\n  * Make util::Status more similar to absl::Status (#8405)\n  * Fix -Wsuggest-destructor-override for generated C++ proto classes. (#8408)\n  * Refactor StatusOr and StringPiece (#8406)\n  * Refactor uint128 (#8416)\n  * The ::pb namespace is no longer exposed due to conflicts.\n  * Allow MessageDifferencer::TreatAsSet() (and friends) to override previous\n    calls instead of crashing.\n  * Reduce the size of generated proto headers for protos with `string` or\n    `bytes` fields.\n  * Move arena() operation on uncommon path to out-of-line routine\n  * For iterator-pair function parameter types, take both iterators by value.\n  * Code-space savings and perhaps some modest performance improvements in\n    RepeatedPtrField.\n  * Eliminate nullptr check from every tag parse.\n  * Remove unused _$name$_cached_byte_size_ fields.\n  * Serialize extension ranges together when not broken by a proto field in the\n    middle.\n  * Do out-of-line allocation and deallocation of string object in ArenaString.\n  * Streamline ParseContext::ParseMessage<T> to avoid code bloat and improve\n    performance.\n  * New member functions RepeatedField::Assign, RepeatedPtrField::{Add, Assign}.\n  * Fix undefined behavior warning due to innocuous uninitialization of value\n    on an error path.\n  * Avoid expensive inlined code space for encoding message length for messages\n    >= 128 bytes and instead do a procedure call to a shared out-of-line routine.\n  * util::DefaultFieldComparator will be final in a future version of protobuf.\n    Subclasses should inherit from SimpleFieldComparator instead.\n\n  C#\n  * Add .NET 5 target and improve WriteString performance with SIMD (#8147)\n\n  Java\n  * deps: update JUnit and Truth (#8319)\n  * Detect invalid overflow of byteLimit and return InvalidProtocolBufferException as documented.\n  * Exceptions thrown while reading from an InputStream in parseFrom are now\n    included as causes.\n  * Support potentially more efficient proto parsing from RopeByteStrings.\n  * Clarify runtime of ByteString.Output.toStringBuffer().\n  * Added UnsafeByteOperations to protobuf-lite (#8426)\n\n  JavaScript\n  * Make Any.pack() chainable.\n\n  Python\n  * Fix some constness / char literal issues being found by MSVC standard conforming mode (#8344)\n  * Switch on \"new\" buffer API (#8339)\n  * Enable crosscompiling aarch64 python wheels under dockcross manylinux docker image (#8280)\n  * Fixed a bug in text format where a trailing colon was printed for repeated field.\n  * When TextFormat encounters a duplicate message map key, replace the current\n    one instead of merging.\n\n  Objective-C\n  * Move the class map to a CFDictionary. (#8328)\n\n  PHP\n  * read_property() handler is not supposed to return NULL (#8362)\n  * Changed parameter type from long to integer (#7613)\n  * fix: README supported PHP version for C extension (#8236)\n\n  Ruby\n  * Fixed quadratic memory usage when appending to arrays. (#8364)\n  * Fixed memory leak of Ruby arena objects. (#8461)\n  * Add support for proto3 json_name in compiler and field definitions. (#8356)\n\n  Other\n  * Some doc on AOT compilation and protobuf (#8294)\n  * [CMake] Ability to pass options to protoc executable from cmake (#8374)\n  * Add --fatal_warnings flag to treat warnings as errors (#8131)\n  * [bazel] Remove deprecated way to depend on googletest (#8396)\n  * add error returns missing from protoc to prevent it from exiting with\u2026 (#8409)\n\n\n2021-04-07 version 3.15.8 (C++/Java/Python/PHP/Objective-C/C#/Ruby/JavaScript)\n\n  Ruby\n  * Fixed memory leak of Ruby arena objects (#8461)\n\n2021-04-02 version 3.15.7 (C++/Java/Python/PHP/Objective-C/C#/Ruby/JavaScript)\n\n  C++\n  * Remove the ::pb namespace (alias) (#8423)\n\n  Ruby\n  * Fix unbounded memory growth for Ruby <2.7 (#8429)\n  * Fixed message equality in cases where the message type is different (#8434)\n\n2021-03-10 version 3.15.6 (C++/Java/Python/PHP/Objective-C/C#/Ruby/JavaScript)\n\n  Ruby\n  * Fixed bug in string comparison logic (#8386)\n\n2021-03-04 version 3.15.5 (C++/Java/Python/PHP/Objective-C/C#/Ruby/JavaScript)\n\n  Ruby\n  * Fixed quadratic memory use in array append (#8379)\n\n  PHP\n  * Fixed quadratic memory use in array append (#8379)\n\n  C++\n  * Do not disable RTTI by default in the CMake build (#8377)\n\n2021-03-02 version 3.15.4 (C++/Java/Python/PHP/Objective-C/C#/Ruby/JavaScript)\n\n  Ruby\n  * Fixed SEGV when users pass nil messages (#8363)\n  * Fixed quadratic memory usage when appending to arrays (#8364)\n\n  C++\n  * Create a CMake option to control whether or not RTTI is enabled (#8361)\n\n  PHP\n  * read_property() handler is not supposed to return NULL (#8362)\n\n2021-02-25 version 3.15.3 (C++/Java/Python/PHP/Objective-C/C#/Ruby/JavaScript)\n\n  Ruby\n  * Ruby <2.7 now uses WeakMap too, which prevents memory leaks. (#8341)\n\n2021-02-23 version 3.15.2 (C++/Java/Python/PHP/Objective-C/C#/Ruby/JavaScript)\n\n  Ruby\n  * Fix for FieldDescriptor.get(msg) (#8330)\n\n  C++\n  * Fix PROTOBUF_CONSTINIT macro redefinition (#8323)\n\n2021-02-05 version 3.15.1 (C++/Java/Python/PHP/Objective-C/C#/Ruby/JavaScript)\n\n  Ruby\n  * Bugfix for Message.[] for repeated or map fields (#8313)\n\n2021-02-05 version 3.15.0 (C++/Java/Python/PHP/Objective-C/C#/Ruby/JavaScript)\n\n  Protocol Compiler\n  * Optional fields for proto3 are enabled by default, and no longer require\n    the --experimental_allow_proto3_optional flag.\n\n  C++\n  * MessageDifferencer: fixed bug when using custom ignore with multiple\n    unknown fields\n  * Use init_seg in MSVC to push initialization to an earlier phase.\n  * Runtime no longer triggers -Wsign-compare warnings.\n  * Fixed -Wtautological-constant-out-of-range-compare warning.\n  * DynamicCastToGenerated works for nullptr input for even if RTTI is disabled\n  * Arena is refactored and optimized.\n  * Clarified/specified that the exact value of Arena::SpaceAllocated() is an\n    implementation detail users must not rely on. It should not be used in\n    unit tests.\n  * Change the signature of Any::PackFrom() to return false on error.\n  * Add fast reflection getter API for strings.\n  * Constant initialize the global message instances\n  * Avoid potential for missed wakeup in UnknownFieldSet\n  * Now Proto3 Oneof fields have \"has\" methods for checking their presence in\n    C++.\n  * Bugfix for NVCC\n  * Return early in _InternalSerialize for empty maps.\n  * Adding functionality for outputting map key values in proto path logging\n    output (does not affect comparison logic) and stop printing 'value' in the\n    path. The modified print functionality is in the\n    MessageDifferencer::StreamReporter.\n  * Fixed https://github.com/protocolbuffers/protobuf/issues/8129\n  * Ensure that null char symbol, package and file names do not result in a\n    crash.\n  * Constant initialize the global message instances\n  * Pretty print 'max' instead of numeric values in reserved ranges.\n  * Removed remaining instances of std::is_pod, which is deprecated in C++20.\n  * Changes to reduce code size for unknown field handling by making uncommon\n    cases out of line.\n  * Fix std::is_pod deprecated in C++20 (#7180)\n  * Fix some -Wunused-parameter warnings (#8053)\n  * Fix detecting file as directory on zOS issue #8051 (#8052)\n  * Don't include sys/param.h for _BYTE_ORDER (#8106)\n  * remove CMAKE_THREAD_LIBS_INIT from pkgconfig CFLAGS (#8154)\n  * Fix TextFormatMapTest.DynamicMessage issue#5136 (#8159)\n  * Fix for compiler warning issue#8145 (#8160)\n  * fix: support deprecated enums for GCC < 6 (#8164)\n  * Fix some warning when compiling with Visual Studio 2019 on x64 target (#8125)\n\n  Python\n  * Provided an override for the reverse() method that will reverse the internal\n    collection directly instead of using the other methods of the BaseContainer.\n  * MessageFactory.CreateProtoype can be overridden to customize class creation.\n  * Fix PyUnknownFields memory leak (#7928)\n  * Add macOS Big Sur compatibility (#8126)\n\n  JavaScript\n  * Generate `getDescriptor` methods with `*` as their `this` type.\n  * Enforce `let/const` for generated messages.\n  * js/binary/utils.js: Fix jspb.utils.joinUnsignedDecimalString to work with negative bitsLow and low but non-zero bitsHigh parameter. (#8170)\n\n  PHP\n  * Added support for PHP 8. (#8105)\n  * unregister INI entries and fix invalid read on shutdown (#8042)\n  * Fix PhpDoc comments for message accessors to include \"|null\". (#8136)\n  * fix: convert native PHP floats to single precision (#8187)\n  * Fixed PHP to support field numbers >=2**28. (#8235)\n  * feat: add support for deprecated fields to PHP compiler (#8223)\n  * Protect against stack overflow if the user derives from Message. (#8248)\n  * Fixed clone for Message, RepeatedField, and MapField. (#8245)\n  * Updated upb to allow nonzero offset minutes in JSON timestamps. (#8258)\n\n  Ruby\n  * Added support for Ruby 3. (#8184)\n  * Rewrote the data storage layer to be based on upb_msg objects from the\n    upb library. This should lead to much better parsing performance,\n    particularly for large messages. (#8184).\n  * Fill out JRuby support (#7923)\n  * [Ruby] Fix: (SIGSEGV) gRPC-Ruby issue on Windows. memory alloc infinite\n    recursion/run out of memory (#8195)\n  * Fix jruby support to handle messages nested more than 1 level deep (#8194)\n\n  Java\n  * Avoid possible UnsupportedOperationException when using CodedInputSteam\n    with a direct ByteBuffer.\n  * Make Durations.comparator() and Timestamps.comparator() Serializable.\n  * Add more detailed error information for dynamic message field type\n    validation failure\n  * Removed declarations of functions declared in java_names.h from\n    java_helpers.h.\n  * Now Proto3 Oneof fields have \"has\" methods for checking their presence in\n    Java.\n  * Annotates Java proto generated *_FIELD_NUMBER constants.\n  * Add -assumevalues to remove JvmMemoryAccessor on Android.\n\n  C#\n  * Fix parsing negative Int32Value that crosses segment boundary (#8035)\n  * Change ByteString to use memory and support unsafe create without copy (#7645)\n  * Optimize MapField serialization by removing MessageAdapter (#8143)\n  * Allow FileDescriptors to be parsed with extension registries (#8220)\n  * Optimize writing small strings (#8149)\n\n2020-11-11 version 3.14.0 (C++/Java/Python/PHP/Objective-C/C#/Ruby/JavaScript)\n\n  Protocol Compiler\n  * The proto compiler no longer requires a .proto filename when it is not\n    generating code.\n  * Added flag `--deterministic_output` to `protoc --encode=...`.\n  * Fixed deadlock when using google.protobuf.Any embedded in aggregate options.\n\n  C++\n  * Arenas are now unconditionally enabled. cc_enable_arenas no longer has\n    any effect.\n  * Removed inlined string support, which is incompatible with arenas.\n  * Fix a memory corruption bug in reflection when mixing optional and\n    non-optional fields.\n  * Make SpaceUsed() calculation more thorough for map fields.\n  * Add stack overflow protection for text format with unknown field values.\n  * FieldPath::FollowAll() now returns a bool to signal if an out-of-bounds\n    error was encountered.\n  * Performance improvements for Map.\n  * Minor formatting fix when dumping a descriptor to .proto format with\n    DebugString.\n  * UBSAN fix in RepeatedField (#2073).\n  * When running under ASAN, skip a test that makes huge allocations.\n  * Fixed a crash that could happen when creating more than 256 extensions in\n    a single message.\n  * Fix a crash in BuildFile when passing in invalid descriptor proto.\n  * Parser security fix when operating with CodedInputStream.\n  * Warn against the use of AllowUnknownExtension.\n  * Migrated to C++11 for-range loops instead of index-based loops where\n    possible. This fixes a lot of warnings when compiling with -Wsign-compare.\n  * Fix segment fault for proto3 optional (#7805)\n  * Adds a CMake option to build `libprotoc` separately (#7949)\n\n  Java\n  * Bugfix in mergeFrom() when a oneof has multiple message fields.\n  * Fix RopeByteString.RopeInputStream.read() returning -1 when told to read\n    0 bytes when not at EOF.\n  * Redefine remove(Object) on primitive repeated field Lists to avoid\n    autoboxing.\n  * Support \"\\u\" escapes in textformat string literals.\n  * Trailing empty spaces are no longer ignored for FieldMask.\n  * Fix FieldMaskUtil.subtract to recursively remove mask.\n  * Mark enums with `@java.lang.Deprecated` if the proto enum has option\n    `deprecated = true;`.\n  * Adding forgotten duration.proto to the lite library (#7738)\n\n  Python\n  * Print google.protobuf.NullValue as null instead of \"NULL_VALUE\" when it is\n    used outside WKT Value/Struct.\n  * Fix bug occurring when attempting to deep copy an enum type in python 3.\n  * Add a setuptools extension for generating Python protobufs (#7783)\n  * Remove uses of pkg_resources in non-namespace packages. (#7902)\n  * [bazel/py] Omit google/__init__.py from the Protobuf runtime. (#7908)\n  * Removed the unnecessary setuptools package dependency for Python package (#7511)\n  * Fix PyUnknownFields memory leak (#7928)\n\n  PHP\n  * Added support for \"==\" to the PHP C extension (#7883)\n  * Added `==` operators for Map and Array. (#7900)\n  * Native C well-known types (#7944)\n  * Optimized away hex2bin() call in generated code (#8006)\n  * New version of upb, and a new hash function wyhash in third_party. (#8000)\n  * add missing hasOneof method to check presence of oneof fields (#8003)\n\n  Go:\n  * Update go_package options to reference google.golang.org/protobuf module.\n\n  C#:\n  * annotate ByteString.CopyFrom(ReadOnlySpan<byte>) as SecuritySafeCritical (#7701)\n  * Fix C# optional field reflection when there are regular fields too (#7705)\n  * Fix parsing negative Int32Value that crosses segment boundary (#8035)\n\n  Javascript:\n  * JS: parse (un)packed fields conditionally (#7379)\n\n2020-07-14 version 3.13.0 (C++/Java/Python/PHP/Objective-C/C#/Ruby/JavaScript)\n\n  PHP:\n  * The C extension is completely rewritten. The new C extension has significantly\n    better parsing performance and fixes a handful of conformance issues. It will\n    also make it easier to add support for more features like proto2 and proto3 presence.\n  * The new C extension does not support PHP 5.x. PHP 5.x users can still use pure-PHP.\n\n  C++:\n  * Removed deprecated unsafe arena string accessors\n  * Enabled heterogeneous lookup for std::string keys in maps.\n  * Removed implicit conversion from StringPiece to std::string\n  * Fix use-after-destroy bug when the Map is allocated in the arena.\n  * Improved the randomness of map ordering\n  * Added stack overflow protection for text format with unknown fields\n  * Use std::hash for proto maps to help with portability.\n  * Added more Windows macros to proto whitelist.\n  * Arena constructors for map entry messages are now marked \"explicit\"\n    (for regular messages they were already explicit).\n  * Fix subtle aliasing bug in RepeatedField::Add\n  * Fix mismatch between MapEntry ByteSize and Serialize with respect to unset\n    fields.\n\n  Python:\n  * JSON format conformance fixes:\n    * Reject lowercase t for Timestamp json format.\n    * Print full_name directly for extensions (no camelCase).\n    * Reject boolean values for integer fields.\n    * Reject NaN, Infinity, -Infinity that is not quoted.\n    * Base64 fixes for bytes fields: accept URL-safe base64 and missing padding.\n  * Bugfix for fields/files named \"async\" or \"await\".\n  * Improved the error message when AttributeError is returned from __getattr__\n    in EnumTypeWrapper.\n\n  Java:\n  * Fixed a bug where setting optional proto3 enums with setFooValue() would\n    not mark the value as present.\n  * Add Subtract function to FieldMaskUtil.\n\n  C#:\n  * Dropped support for netstandard1.0 (replaced by support for netstandard1.1).\n    This was required to modernize the parsing stack to use the `Span<byte>`\n    type internally. (#7351)\n  * Add `ParseFrom(ReadOnlySequence<byte>)` method to enable GC friendly\n    parsing with reduced allocations and buffer copies. (#7351)\n  * Add support for serialization directly to a `IBufferWriter<byte>` or\n    to a `Span<byte>` to enable GC friendly serialization.\n    The new API is available as extension methods on the `IMessage` type. (#7576)\n  * Add `GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE` define to make\n    generated code compatible with old C# compilers (pre-roslyn compilers\n    from .NET framework and old versions of mono) that do not support\n    ref structs. Users that are still on a legacy stack that does\n    not support C# 7.2 compiler might need to use the new define\n    in their projects to be able to build the newly generated code. (#7490)\n  * Due to the major overhaul of parsing and serialization internals (#7351 and #7576),\n    it is recommended to regenerate your generated code to achieve the best\n    performance (the legacy generated code will still work, but might incur\n    a slight performance penalty).\n\n2020-07-28 version 3.12.4 (C++/Java/Python/PHP/Objective-C/C#/Ruby/JavaScript)\n\nThis release contains no significant changes, but exists because 3.12.3 was\nmistakenly tagged at the wrong commit.\n\n2020-06-01 version 3.12.3 (C++/Java/Python/PHP/Objective-C/C#/Ruby/JavaScript)\n\n  Objective-C\n  * Tweak the union used for Extensions to support old generated code. #7573\n\n2020-05-26 version 3.12.2 (C++/Java/Python/PHP/Objective-C/C#/Ruby/JavaScript)\n\n  C++\n  * Simplified the template export macros to fix the build for mingw32. (#7539)\n\n  Objective-C\n  * Fix for the :protobuf_objc target in the Bazel BUILD file. (#7538)\n\n2020-05-20 version 3.12.1 (C++/Java/Python/PHP/Objective-C/C#/Ruby/JavaScript)\n\n  Ruby\n  * Re-add binary gems for Ruby 2.3 and 2.4. These are EOL upstream, however\n    many people still use them and dropping support will require more\n    coordination.\n\n2020-05-12 version 3.12.0 (C++/Java/Python/PHP/Objective-C/C#/Ruby/JavaScript)\n\n  Protocol Compiler\n  * [experimental] Singular, non-message typed fields in proto3 now support\n    presence tracking. This is enabled by adding the \"optional\" field label and\n    passing the --experimental_allow_proto3_optional flag to protoc.\n    * For usage info, see docs/field_presence.md.\n    * During this experimental phase, code generators should update to support\n      proto3 presence, see docs/implementing_proto3_presence.md for instructions.\n  * Allow duplicate symbol names when multiple descriptor sets are passed on\n    the command-line, to match the behavior when multiple .proto files are passed.\n  * Deterministic `protoc --descriptor_set_out` (#7175)\n\n  C++\n  * [experimental] Added proto3 presence support.\n  * New descriptor APIs to support proto3 presence.\n  * Enable Arenas by default on all .proto files.\n  * Documented that users are not allowed to subclass Message or MessageLite.\n  * Mark generated classes as final; inheriting from protos is strongly discouraged.\n  * Add stack overflow protection for text format with unknown fields.\n  * Add accessors for map key and value FieldDescriptors.\n  * Add FieldMaskUtil::FromFieldNumbers().\n  * MessageDifferencer: use ParsePartial() on Any fields so the diff does not\n    fail when there are missing required fields.\n  * ReflectionOps::Merge(): lookup messages in the right factory, if it can.\n  * Added Descriptor::WellKnownTypes enum and Descriptor::well_known_type()\n    accessor as an easier way of determining if a message is a Well-Known Type.\n  * Optimized RepeatedField::Add() when it is used in a loop.\n  * Made proto move/swap more efficient.\n  * De-virtualize the GetArena() method in MessageLite.\n  * Improves performance of json_stream_parser.cc by factor 1000 (#7230)\n  * bug: #7076 undefine Windows OUT and OPTIONAL macros (#7087)\n  * Fixed a bug in FieldDescriptor::DebugString() that would erroneously print\n    an \"optional\" label for a field in a oneof.\n  * Fix bug in parsing bool extensions that assumed they are always 1 byte.\n  * Fix off-by-one error in FieldOptions::ByteSize() when extensions are present.\n  * Clarified the comments to show an example of the difference between\n    Descriptor::extension and DescriptorPool::FindAllExtensions.\n  * Add a compiler option 'code_size' to force optimize_for=code_size on all\n    protos where this is possible.\n\n  Java\n  * [experimental] Added proto3 presence support.\n  * Mark java enum _VALUE constants as @Deprecated if the enum field is deprecated\n  * reduce <clinit> size for enums with allow_alias set to true.\n  * Sort map fields alphabetically by the field's key when printing textproto.\n  * Fixed a bug in map sorting that appeared in -rc1 and -rc2 (#7508).\n  * TextFormat.merge() handles Any as top level type.\n  * Throw a descriptive IllegalArgumentException when calling\n    getValueDescriptor() on enum special value UNRECOGNIZED instead of\n    ArrayIndexOutOfBoundsException.\n  * Fixed an issue with JsonFormat.printer() where setting printingEnumsAsInts()\n    would override the configuration passed into includingDefaultValueFields().\n  * Implement overrides of indexOf() and contains() on primitive lists returned\n    for repeated fields to avoid autoboxing the list contents.\n  * Add overload to FieldMaskUtil.fromStringList that accepts a descriptor.\n  * [bazel] Move Java runtime/toolchains into //java (#7190)\n\n  Python\n  * [experimental] Added proto3 presence support.\n  * [experimental] fast import protobuf module, only works with cpp generated code linked in.\n  * Truncate 'float' fields to 4 bytes of precision in setters for pure-Python\n    implementation (C++ extension was already doing this).\n  * Fixed a memory leak in C++ bindings.\n  * Added a deprecation warning when code tries to create Descriptor objects\n    directly.\n  * Fix unintended comparison between bytes and string in descriptor.py.\n  * Avoid printing excess digits for float fields in TextFormat.\n  * Remove Python 2.5 syntax compatibility from the proto compiler generated _pb2.py module code.\n  * Drop 3.3, 3.4 and use single version docker images for all python tests (#7396)\n\n  JavaScript\n  * Fix js message pivot selection (#6813)\n\n  PHP\n  * Persistent Descriptor Pool (#6899)\n  * Implement lazy loading of php class for proto messages (#6911)\n  * Correct @return in Any.unpack docblock (#7089)\n  * Ignore unknown enum value when ignore_unknown specified (#7455)\n\n  Ruby\n  * [experimental] Implemented proto3 presence for Ruby. (#7406)\n  * Stop building binary gems for ruby <2.5 (#7453)\n  * Fix for wrappers with a zero value (#7195)\n  * Fix for JSON serialization of 0/empty-valued wrapper types (#7198)\n  * Call \"Class#new\" over rb_class_new_instance in decoding (#7352)\n  * Build extensions for Ruby 2.7 (#7027)\n  * assigning 'nil' to submessage should clear the field. (#7397)\n\n  C#\n  * [experimental] Add support for proto3 presence fields in C# (#7382)\n  * Mark GetOption API as obsolete and expose the \"GetOptions()\" method on descriptors instead (#7491)\n  * Remove Has/Clear members for C# message fields in proto2 (#7429)\n  * Enforce recursion depth checking for unknown fields (#7132)\n  * Fix conformance test failures for Google.Protobuf (#6910)\n  * Cleanup various bits of Google.Protobuf (#6674)\n  * Fix latest ArgumentException for C# extensions (#6938)\n  * Remove unnecessary branch from ReadTag (#7289)\n\n  Objective-C\n  * [experimental] ObjC Proto3 optional support (#7421)\n  * Block subclassing of generated classes (#7124)\n  * Use references to Obj C classes instead of names in descriptors. (#7026)\n  * Revisit how the WKTs are bundled with ObjC. (#7173)\n\n  Other\n  * Add a proto_lang_toolchain for javalite (#6882)\n  * [bazel] Update gtest and deprecate //external:{gtest,gtest_main} (#7237)\n  * Add application note for explicit presence tracking. (#7390)\n  * Howto doc for implementing proto3 presence in a code generator. (#7407)\n\n\n2020-02-14 version 3.11.4 (C++/Java/Python/PHP/Objective-C/C#/Ruby/JavaScript)\n\n  C#\n  * Fix latest ArgumentException for C# extensions (#7188)\n  * Enforce recursion depth checking for unknown fields (#7210)\n\n  Ruby\n  * Fix wrappers with a zero value (#7195)\n  * Fix JSON serialization of 0/empty-valued wrapper types (#7198)\n\n2020-01-31 version 3.11.3 (C++/Java/Python/PHP/Objective-C/C#/Ruby/JavaScript)\n\n  C++\n  * Add OUT and OPTIONAL to windows portability files (#7087)\n\n  PHP\n  * Refactored ulong to zend_ulong for php7.4 compatibility (#7147)\n  * Call register_class before getClass from desc to fix segfault (#7077)\n\n\n2019-12-10 version 3.11.2 (C++/Java/Python/PHP/Objective-C/C#/Ruby/JavaScript)\n\n  PHP\n  * Make c extension portable for php 7.4 (#6968)\n\n\n2019-12-02 version 3.11.1 (C++/Java/Python/PHP/Objective-C/C#/Ruby/JavaScript)\n\n  PHP\n  * Extern declare protobuf_globals (#6946)\n\n\n2019-11-19 version 3.11.0 (C++/Java/Python/PHP/Objective-C/C#/Ruby/JavaScript)\n\n  C++\n  * Make serialization method naming consistent\n  * Make proto runtime + generated code free of deprecation warnings\n  * Moved ShutdownProtobufLibrary() to message_lite.h.  For backward compatibility a declaration is still available in stubs/common.h, but users should prefer message_lite.h\n  * Removed non-namespace macro EXPECT_OK()\n  * Removed mathlimits.h from stubs in favor of using std::numeric_limits from C++11\n  * Fixed bug in parser when ending on a group tag\n  * Add a helper function to UnknownFieldSet to deal with the changing return value of message::unknown_fields()\n  * Fix incorrect use of string_view iterators\n  * Support direct pickling of nested messages\n  * Skip extension tag validation for MessageSet if unknown dependencies are allowed\n  * Updated deprecation macros to annotate deprecated code (#6612)\n  * Remove conversion warning in MapEntryFuncs::ByteSizeLong (#6766)\n  * Revert \"Make shared libraries be able to link to MSVC static runtime libraries, so that VC runtime is not required.\" (#6914)\n\n  Java\n  * Remove the usage of MethodHandle, so that Android users prior to API version 26 can use protobuf-java\n  * Publish ProGuard config for javalite\n  * Fix for StrictMode disk read violation in ExtensionRegistryLite\n  * Include part of the ByteString's content in its toString().\n  * Include unknown fields when merging proto3 messages in Java lite builders\n\n  Python\n  * Add float_precision option in json format printer\n  * Optionally print bytes fields as messages in unknown fields, if possible\n  * FieldPath: fix testing IsSet on root path ''\n  * Experimental code gen (fast import protobuf module) which only work with cpp generated code linked in\n\n  JavaScript\n  * Remove guard for Symbol iterator for jspb.Map\n\n  PHP\n  * Avoid too much overhead in layout_init (#6716)\n  * Lazily Create Singular Wrapper Message (#6833)\n  * Implement lazy loading of php class for proto messages (#6911)\n\n  Ruby\n  * Ruby lazy wrappers optimization (#6797)\n\n  C#\n  * (RepeatedField): Capacity property to resize the internal array (#6530)\n  * Experimental proto2 support is now officially available (#4642, #5183, #5350, #5936)\n  * Getting started doc: https://github.com/protocolbuffers/protobuf/blob/master/docs/csharp/proto2.md\n  * Add length checks to ExtensionCollection (#6759)\n  * Optimize parsing of some primitive and wrapper types (#6843)\n  * Use 3 parameter Encoding.GetString for default string values (#6828)\n  * Change _Extensions property to normal body rather than expression (#6856)\n\n  Objective C\n  * Fixed unaligned reads for 32bit arm with newer Xcode versions (#6678)\n\n\n2019-09-03 version 3.10.0 (C++/Java/Python/PHP/Objective-C/C#/Ruby/JavaScript)\n\n  C++\n  * Switch the proto parser to the faster MOMI parser.\n  * Properly escape Struct keys in the proto3 JSON serializer.\n  * Fix crash on uninitialized map entries.\n  * Informed the compiler of has-bit invariant to produce better code\n  * Unused imports of files defining descriptor extensions will now be reported\n  * Add proto2::util::RemoveSubranges to remove multiple subranges in linear time.\n  * Added BaseTextGenerator::GetCurrentIndentationSize()\n  * Made implicit weak fields compatible with the Apple linker\n  * Support 32 bit values for ProtoStreamObjectWriter to Struct.\n  * Removed the internal-only header coded_stream_inl.h and the internal-only methods defined there.\n  * Enforced no SWIG wrapping of descriptor_database.h (other headers already had this restriction).\n  * Implementation of the equivalent of the MOMI parser for serialization. This removes one of the two serialization routines, by making the fast array serialization routine completely general. SerializeToCodedStream can now be implemented in terms of the much much faster array serialization. The array serialization regresses slightly, but when array serialization is not possible this wins big.\n  * Do not convert unknown field name to snake case to accurately report error.\n  * Fix a UBSAN warnings. (#6333)\n  * Add podspec for C++ (#6404)\n  * protoc: fix source code info location for missing label (#6436)\n  * C++ Add move constructor for Reflection's SetString (#6477)\n\n  Java\n  * Call loadDescriptor outside of synchronized block to remove one possible source of deadlock.\n  * Have oneof enums implement a separate interface (other than EnumLite) for clarity.\n  * Opensource Android Memory Accessors\n  * Update TextFormat to make use of the new TypeRegistry.\n  * Support getFieldBuilder and getRepeatedFieldBuilder in ExtendableBuilder\n  * Update JsonFormat to make use of the new TypeRegistry.\n  * Add proguard config generator for GmmBenchmarkSuiteLite.\n  * Change ProtobufArrayList to use Object[] instead of ArrayList for 5-10% faster parsing\n  * Implement ProtobufArrayList.add(E) for 20% (5%-40%) faster overall protolite2 parsing\n  * Make a copy of JsonFormat.TypeRegistry at the protobuf top level package. This will eventually replace JsonFormat.TypeRegistry.\n  * Fix javadoc warnings in generated files (#6231)\n  * Java: Add Automatic-Module-Name entries to the Manifest (#6568)\n\n  Python\n  * Add descriptor methods in descriptor_pool are deprecated.\n  * Uses explicit imports to prevent multithread test failures in py3.\n  * Added __delitem__ for Python extension dict\n  * Update six version to 1.12.0 and fix legacy_create_init issue (#6391)\n\n  JavaScript\n  * Remove deprecated boolean option to getResultBase64String().\n  * Fix sint64 zig-zag encoding.\n  * Simplify hash64 string conversion to avoid DIGIT array. Should reduce overhead if these functions aren't used, and be more efficient by avoiding linear array searches.\n  * Change the parameter types of binaryReaderFn in ExtensionFieldBinaryInfo to (number, ?, ?).\n  * Create dates.ts and time_of_days.ts to mirror Java versions. This is a near-identical conversion of c.g.type.util.{Dates,TimeOfDays} respectively.\n  * Migrate moneys to TypeScript.\n\n  PHP\n  * Fix incorrect leap day for Timestamp (#6696)\n  * Initialize well known type values (#6713)\n\n  Ruby\n  * Fix scope resolution for Google namespace (#5878)\n  * Support hashes for struct initializers (#5716)\n  * Optimized away the creation of empty string objects. (#6502)\n  * Roll forward Ruby upb changes now that protobuf Ruby build is fixed (#5866)\n  * Optimized layout_mark() for Ruby (#6521)\n  * Optimization for layout_init() (#6547)\n  * Fix for GC of Ruby map frames. (#6533)\n  * Fixed leap year handling by reworking upb_mktime() -> upb_timegm(). (#6695)\n\n  Objective C\n  * Remove OSReadLittle* due to alignment requirements (#6678)\n  * Don't use unions and instead use memcpy for the type swaps. (#6672)\n\n  Other\n  * Override CocoaPods module to lowercase (#6464)\n\n\n2019-06-28 version 3.9.0 (C++/Java/Python/PHP/Objective-C/C#/Ruby/JavaScript)\n\n  C++\n  * Optimize and simplify implementation of RepeatedPtrFieldBase\n  * Don't create unnecessary unknown field sets.\n  * Remove branch from accessors to repeated field element array.\n  * Added delimited parse and serialize util.\n  * Reduce size by not emitting constants for fieldnumbers\n  * Fix a bug when comparing finite and infinite field values with explicit tolerances.\n  * TextFormat::Parser should use a custom Finder to look up extensions by number if one is provided.\n  * Add MessageLite::Utf8DebugString() to make MessageLite more compatible with Message.\n  * Fail fast for better performance in DescriptorPool::FindExtensionByNumber() if descriptor has no defined extensions.\n  * Adding the file name to help debug colliding extensions\n  * Added FieldDescriptor::PrintableNameForExtension() and DescriptorPool::FindExtensionByPrintableName().\n    The latter will replace Reflection::FindKnownExtensionByName().\n  * Replace NULL with nullptr\n  * Created a new Add method in repeated field that allows adding a range of elements all at once.\n  * Enabled enum name-to-value mapping functions for C++ lite\n  * Avoid dynamic initialization in descriptor.proto generated code\n  * Move stream functions to MessageLite from Message.\n  * Move all zero_copy_stream functionality to io_lite.\n  * Do not create array of matched fields for simple repeated fields\n  * Enabling silent mode by default to reduce make compilation noise. (#6237)\n\n  Java\n  * Expose TextFormat.Printer and make it configurable. Deprecate the static methods.\n  * Library for constructing google.protobuf.Struct and google.protobuf.Value\n  * Make OneofDescriptor extend GenericDescriptor.\n  * Expose streamingness of service methods from MethodDescriptor.\n  * Fix a bug where TextFormat fails to parse Any filed with > 1 embedded message sub-fields.\n  * Establish consistent JsonFormat behavior for nulls in oneofs, regardless of order.\n  * Update GSON version to 3.8.5. (#6268)\n  * Add `protobuf_java_lite` Bazel target. (#6177)\n\n  Python\n  * Change implementation of Name() for enums that allow aliases in proto2 in Python\n    to be in line with claims in C++ implementation (to return first value).\n  * Explicitly say what field cannot be set when the new value fails a type check.\n  * Duplicate register in descriptor pool will raise errors\n  * Add __slots__ to all well_known_types classes, custom attributes are not allowed anymore.\n  * text_format only present 8 valid digits for float fields by default\n\n  JavaScript\n  * Add Oneof enum to the list of goog.provide\n\n  PHP\n  * Make php message class final to avoid mocking. (#6277)\n  * Rename get/setXXXValue to get/setXXXWrapper. (#6295)\n\n  Ruby\n  * Remove to_hash methods. (#6166)\n\n\n2019-04-29 version 3.8.0 (C++/Java/Python/PHP/Objective-C/C#/Ruby/JavaScript)\n\n  C++\n  * Use std::atomic<int32> in case of myriad2 platform\n  * Always declare enums to be int-sized\n  * Added DebugString() and ShortDebugString() methods on MessageLite\n  * Specialized different parse loop control flows\n  * Make hasbits potentially in register. The or's start forming an obstacle because it's a read modify store on the same mem address on each iteration.\n  * Move to an internal MACRO for parser validity checks.\n  * Improve map parsing performance.\n  * Make MergePartialFromCodedStream non virtual. This allows direct calls, potential inlining and is also a code health improvement\n  * Add an overall limit to parse_context to prevent reading past it. This allows to remove a annoying level of indirection.\n  * Fix a mistake, we shouldn't verify map key/value strings for utf8 in opt mode for proto2.\n  * Further improvements to cut binary size.\n  * Prepare to make MergePartialFromCodedStream non-virtual.\n  * A report on some interesting behavior change in python (caused by b/27494216) made me realize there is a check that needs to be done in case the parse ended on a end group tag.\n  * Add a note of caution to the comments around skip in CodedOutputStream.\n  * Simplify end check.\n  * Add overload for ParseMessage for MessageLite/Message types. If the explicit type is not known inlining won't help de-virtualizing the virtual call.\n  * Reduce linker input. It turns out that ParseMessage is not inlined, producing  template instantiations that are used only once and save nothing but cost more.\n  * Improve the parser.\n  * [c++17] Changed proto2::RepeatedPtrField iterators to no longer derive from the deprecated std::iterator class.\n  * Change the default value of case_insensitive_enum_parsing to false for JsonStringToMessage.\n  * Add a warning if a field name doesn't match the style guide.\n  * Fix TextFormat not round-trip correctly when float value is max float.\n  * Added locationed info for some errors at compiler\n  * Python reserved keywords are now working with getattr()/setattr() for most descriptors.\n  * Added AllowUnknownField() in text_format\n  * Append '_' to C++ reserved keywords for message, enum, extension\n  * Fix MSVC warning C4244 in protobuf's parse_context.h.\n  * Updating Iterators to be compatible with C++17 in MSVC.\n  * Use capability annotation in mutex.h\n  * Fix \"UndefinedBehaviorSanitizer: cfi-bad-type\"\n  * CriticalSectionLock class as a lightweight replacement for std::mutex on Windows platforms.\n  * Removed vestigial wire_format_lite_inl.h\n\n  C#\n  * Added System.Memory dependency.\n\n  Java\n  * Make Java protoc code generator ignore optimize_for LITE_RUNTIME. Users should instead use the Java lite protoc plugin.\n  * Change Extension getMessageDefaultInstance() to return Message instead of MessageLite.\n  * Prevent malicious input streams from leaking buffers for ByteString or ByteBuffer parsing.\n  * Release new Javalite runtime.\n  * Show warning in case potential file name conflict.\n  * Allow Java reserved keywords to be used in extensions.\n  * Added setAllowUnknownFields() in text format\n  * Add memoization to ExtensionRegistryLite.getEmptyRegistry()\n  * Improve performance of CodedOutputStream.writeUInt32NoTag\n  * Add an optimized mismatch-finding algorithm to UnsafeUtil.\n  * When serializing uint32 varints, check that we have MAX_VARINT32_SIZE bytes left, not just MAX_VARINT_SIZE.\n  * Minor optimization to RopeByteString.PieceIterator\n\n  JavaScript\n  * Simplify generated toObject code when the default value is used.\n\n  Python\n  * Changes implementation of Name() for enums that allow aliases in proto2 in Python to be in line with claims in C++ implementation (to return first value).\n  * Added double_format option in text format printer.\n  * Added iter and __contains__ to extension dict\n  * Added allow_unknown_field option in python text format parser\n  * Fixed Timestamp.ToDatetime() loses precision issue\n  * Support unknown field in text format printer.\n  * Float field will be convert to inf if bigger than struct.unpack('f', b'\\xff\\xff\\x7f\\x7f')[0] which is about 3.4028234664e+38,\n  convert to -inf if smaller than -3.4028234664e+38\n  * Allowed casting str->bytes in Message.__setstate__\n\n  Ruby\n  * Helper methods to get enum name for Ruby.\n\n\n2019-01-24 version 3.7.0 (C++/Java/Python/PHP/Objective-C/C#/Ruby/JavaScript)\n\n  C++\n  * Introduced new MOMI (maybe-outside-memory-interval) parser.\n  * Add an option to json_util to parse enum as case-insensitive. In the future, enum parsing in json_util will become case-sensitive.\n  * Added conformance test for enum aliases\n  * Added support for --cpp_out=speed:...\n  * Added use of C++ override keyword where appropriate\n  * Many other cleanups and fixes.\n\n  Java\n  * Fix illegal reflective access warning in JDK 9+\n  * Add BOM\n\n  Python\n  * Added Python 3.7 compatibility.\n  * Modified ParseFromString to return bytes parsed .\n  * Introduce Proto C API.\n  * FindFileContainingSymbol in descriptor pool is now able to find field and enum values.\n  * reflection.MakeClass()  and  reflection.ParseMessage() are deprecated.\n  * Added DescriptorPool.FindMethodByName() method in pure python (c extension already has it)\n  * Flipped proto3 to preserve unknown fields by default.\n  * Added support for memoryview in python3 proto message parsing.\n  * Added MergeFrom for repeated scalar fields in c extension (pure python already has it)\n  * Surrogates are now rejected at setters in python3.\n  * Added public unknown field API.\n  * RecursionLimit is also set to max if allow_oversize_protos is enabled.\n  * Disallow duplicate scalars in proto3 text_format parse.\n  * Fix some segment faults for c extension map field.\n\n  PHP\n  * Most issues for json encoding/decoding in the c extension have been fixed. There are still some edge cases not fixed. For more details, check conformance/failure_list_php_c.txt.\n  * Supports php 7.3\n  * Added helper methods to convert between enum values and names.\n  * Allow setting/getting wrapper message fields using primitive values.\n  * Various bug fixes.\n\n  Ruby\n  * Ruby 2.6 support.\n  * Drops support for ruby < 2.3.\n  * Most issues for json encoding/decoding in the c extension have been fixed. There are still some edge cases not fixed. For more details, check conformance/failure_list_ruby.txt.\n  * Json parsing can specify an option to ignore unknown fields: msg.decode_json(data, {ignore_unknown_fields: true}).\n  * Added support for proto2 syntax (partially).\n  * Various bug fixes.\n\n  Csharp\n  * More support for FieldMask include merge, intersect and more.\n  * Increasing the default recursion limit to 100.\n  * Support loading FileDescriptors dynamically.\n  * Provide access to comments from descriptors.\n  * Added Any.Is method.\n  * Compatible with C# 6\n  * Added IComparable and comparison operators on Timestamp.\n\n  Objective C\n  * Add ability to introspect list of enum values (#4678)\n  * Copy the value when setting message/data fields (#5215)\n  * Support suppressing the objc package prefix checks on a list of files (#5309)\n  * More complete keyword and NSObject method (via categories) checks for field names, can result in more fields being rename, but avoids the collisions at runtime (#5289)\n  * Small fixes to TextFormat generation for extensions (#5362)\n  * Provide more details/context in deprecation messages (#5412)\n  * Array/Dictionary enumeration blocks NS_NOESCAPE annotation for Swift (#5421)\n  * Properly annotate extensions for ARC when their names imply behaviors (#5427)\n  * Enum alias name collision improvements (#5480)\n\n\n2018-07-27 version 3.6.1 (C++/Java/Python/PHP/Objective-C/C#/Ruby/JavaScript)\n\n  C++\n  * Introduced workaround for Windows issue with std::atomic and std::once_flag\n    initialization (#4777, #4773).\n\n  PHP\n  * Added compatibility with PHP 7.3 (#4898).\n\n  Ruby\n  * Fixed Ruby crash involving Any encoding (#4718).\n\n2018-06-01 version 3.6.0 (C++/Java/Python/PHP/Objective-C/C#/Ruby/JavaScript)\n\n  C++\n  * Starting from this release, we now require C++11. For those we cannot yet\n    upgrade to C++11, we will try to keep the 3.5.x branch updated with\n    critical bug fixes only. If you have any concerns about this, please\n    comment on issue #2780.\n  * Moved to C++11 types like std::atomic and std::unique_ptr and away from our\n    old custom-built equivalents.\n  * Added support for repeated message fields in lite protos using implicit\n    weak fields. This is an experimental feature that allows the linker to\n    strip out more unused messages than previously was possible.\n  * Fixed SourceCodeInfo for interpreted options and extension range options.\n  * Fixed always_print_enums_as_ints option for JSON serialization.\n  * Added support for ignoring unknown enum values when parsing JSON.\n  * Create std::string in Arena memory.\n  * Fixed ValidateDateTime to correctly check the day.\n  * Fixed bug in ZeroCopyStreamByteSink.\n  * Various other cleanups and fixes.\n\n  Java\n  * Dropped support for Java 6.\n  * Added a UTF-8 decoder that uses Unsafe to directly decode a byte buffer.\n  * Added deprecation annotations to generated code for deprecated oneof\n    fields.\n  * Fixed map field serialization in DynamicMessage.\n  * Cleanup and documentation for Java Lite runtime.\n  * Various other fixes and cleanups\n  * Fixed unboxed arraylists to handle an edge case\n  * Improved performance for copying between unboxed arraylists\n  * Fixed lite protobuf to avoid Java compiler warnings\n  * Improved test coverage for lite runtime\n  * Performance improvements for lite runtime\n\n  Python\n  * Fixed bytes/string map key incompatibility between C++ and pure-Python\n    implementations (issue #4029)\n  * Added __init__.py files to compiler and util subpackages\n  * Use /MT for all Windows versions\n  * Fixed an issue affecting the Python-C++ implementation when used with\n    Cython (issue #2896)\n  * Various text format fixes\n  * Various fixes to resolve behavior differences between the pure-Python and\n    Python-C++ implementations\n\n  PHP\n  * Added php_metadata_namespace to control the file path of generated metadata\n    file.\n  * Changed generated classes of nested message/enum. E.g., Foo.Bar, which\n    previously generates Foo_Bar, now generates Foo/Bar\n  * Added array constructor. When creating a message, users can pass a php\n    array whose content is field name to value pairs into constructor. The\n    created message will be initialized according to the array. Note that\n    message field should use a message value instead of a sub-array.\n  * Various bug fixes.\n\n  Objective-C\n  * We removed some helper class methods from GPBDictionary to shrink the size\n    of the library, the functionary is still there, but you may need to do some\n    specific +alloc / -init\u2026 methods instead.\n  * Minor improvements in the performance of object field getters/setters by\n    avoiding some memory management overhead.\n  * Fix a memory leak during the raising of some errors.\n  * Make header importing completely order independent.\n  * Small code improvements for things the undefined behaviors compiler option\n    was flagging.\n\n  Ruby\n  * Added ruby_package file option to control the module of generated class.\n  * Various bug fixes.\n\n  Javascript\n  * Allow setting string to int64 field.\n\n  Csharp\n  * Unknown fields are now parsed and then sent back on the wire. They can be\n    discarded at parse time via a CodedInputStream option.\n  * Movement towards working with .NET 3.5 and Unity\n  * Expression trees are no longer used\n  * AOT generics issues in Unity/il2cpp have a workaround (see this commit for\n    details)\n  * Floating point values are now compared bitwise (affects NaN value\n    comparisons)\n  * The default size limit when parsing is now 2GB rather than 64MB\n  * MessageParser now supports parsing from a slice of a byte array\n  * JSON list parsing now accepts null values where the underlying proto\n    representation does\n\n2017-12-20 version 3.5.1 (C++/Java/Python/PHP/Objective-C/C#/Ruby/JavaScript)\n  Planned Future Changes\n  * Make C++ implementation C++11 only: we plan to require C++11 to build\n    protobuf code starting from 3.6.0 release. Please join this github issue:\n    https://github.com/protocolbuffers/protobuf/issues/2780 to provide your feedback.\n\n  protoc\n  * Fixed a bug introduced in 3.5.0 and protoc in Windows now accepts non-ascii\n    characters in paths again.\n\n  C++\n  * Removed several usages of C++11 features in the code base.\n  * Fixed some compiler warnings.\n\n  PHP\n  * Fixed memory leak in C-extension implementation.\n  * Added discardUnknokwnFields API.\n  * Removed duplicated typedef in C-extension headers.\n  * Avoided calling private php methods (timelib_update_ts).\n  * Fixed Any.php to use fully-qualified name for DescriptorPool.\n\n  Ruby\n  * Added Google_Protobuf_discard_unknown for discarding unknown fields in\n    messages.\n\n  C#\n  * Unknown fields are now preserved by default.\n  * Floating point values are now bitwise compared, affecting message equality\n    check and Contains() API in map and repeated fields.\n\n\n2017-11-13 version 3.5.0 (C++/Java/Python/PHP/Objective-C/C#/Ruby/JavaScript)\n  Planned Future Changes\n  * Make C++ implementation C++11 only: we plan to require C++11 to build\n    protobuf code starting from 3.6.0 release. Please join this github issue:\n    https://github.com/protocolbuffers/protobuf/issues/2780 to provide your feedback.\n\n  General\n  * Unknown fields are now preserved in proto3 for most of the language\n    implementations for proto3 by default. See the per-language section for\n    details.\n  * reserve keyword are now supported in enums\n\n  C++\n  * Proto3 messages are now preserving unknown fields by default. If you rely on\n    unknowns fields being dropped. Please use DiscardUnknownFields() explicitly.\n  * Deprecated the unsafe_arena_release_* and unsafe_arena_add_allocated_*\n    methods for string fields.\n  * Added move constructor and move assignment to RepeatedField,\n    RepeatedPtrField and google::protobuf::Any.\n  * Added perfect forwarding in Arena::CreateMessage\n  * In-progress experimental support for implicit weak fields with lite protos.\n    This feature allows the linker to strip out more unused messages and reduce\n    binary size.\n  * Various performance optimizations.\n\n  Java\n  * Proto3 messages are now preserving unknown fields by default. If you\u2019d like\n    to drop unknown fields, please use the DiscardUnknownFieldsParser\u00a0API. For\n    example:\n      Parser<Foo> parser = DiscardUnknownFieldsParser.wrap(Foo.parser());\n      Foo foo = parser.parseFrom(input);\n  * Added a new CodedInputStream decoder for Iterable<ByteBuffer> with direct\n    ByteBuffers.\n  * TextFormat now prints unknown length-delimited fields as messages if\n    possible.\n  * FieldMaskUtil.merge() no longer creates unnecessary empty messages when a\n    message field is unset in both source message and destination message.\n  * Various performance optimizations.\n\n  Python\n  * Proto3 messages are now preserving unknown fields by default. Use\n    message.DiscardUnknownFields() to drop unknown fields.\n  * Add FieldDescriptor.file in generated code.\n  * Add descriptor pool FindOneofByName in pure python.\n  * Change unknown enum values into unknown field set .\n  * Add more Python dict/list compatibility for Struct/ListValue.\n  * Add utf-8 support for text_format.Merge()/Parse().\n  * Support numeric unknown enum values for proto3 JSON format.\n  * Add warning for Unexpected end-group tag in cpp extension.\n\n  PHP\n  * Proto3 messages are now preserving unknown fields.\n  * Provide well known type messages in runtime.\n  * Add prefix \u2018PB\u2019 to generated class of reserved names.\n  * Fixed all conformance tests for encode/decode json in php runtime. C\n    extension needs more work.\n\n  Objective-C\n  * Fixed some issues around copying of messages with unknown fields and then\n    mutating the unknown fields in the copy.\n\n  C#\n  * Added unknown field support in JsonParser.\n  * Fixed oneof message field merge.\n  * Simplify parsing messages from array slices.\n\n  Ruby\n  * Unknown fields are now preserved by default.\n  * Fixed several bugs for segment fault.\n\n  Javascript\n  * Decoder can handle both paced and unpacked data no matter how the proto is\n    defined.\n  * Decoder now accept long varint for 32 bit integers.\n\n\n2017-08-14 version 3.4.0 (C++/Java/Python/PHP/Objective-C/C#/Ruby/JavaScript)\n  Planned Future Changes\n  * There are some changes that are not included in this release but are planned\n    for the near future\n      - Preserve unknown fields in proto3: We are going to bring unknown fields\n        back into proto3. In this release, some languages start to support\n        preserving unknown fields in proto3, controlled by flags/options. Some\n        languages also introduce explicit APIs to drop unknown fields for\n        migration. Please read the change log sections by languages for details.\n        For general timeline and plan:\n\n          https://docs.google.com/document/d/1KMRX-G91Aa-Y2FkEaHeeviLRRNblgIahbsk4wA14gRk/view\n\n        For issues and discussions:\n\n          https://github.com/protocolbuffers/protobuf/issues/272\n\n      - Make C++ implementation C++11 only: we plan to require C++11 to build\n        protobuf code starting from 3.5.0 or 3.6.0 release, after unknown fields\n        semantic changes are finished. Please join this\n        github issue:\n\n          https://github.com/protocolbuffers/protobuf/issues/2780\n\n        to provide your feedback.\n\n  General\n  * Extension ranges now accept options and are customizable.\n  * \"reserve\" keyword now supports \u201cmax\u201d in field number ranges,\n    e.g.  reserve 1000 to max;\n\n  C++\n  * Proto3 messages are now able to preserve unknown fields. The default\n    behavior is still to drop unknowns, which will be flipped in a future\n    release. If you rely on unknowns fields being dropped. Please use\n    Message::DiscardUnknownFields() explicitly.\n  * Packable proto3 fields are now packed by default in serialization.\n  * Following C++11 features are introduced when C++11 is available:\n      - move-constructor and move-assignment are introduced to messages\n      - Repeated fields constructor now takes std::initializer_list\n      - rvalue setters are introduced for string fields\n  * Experimental Table-Driven parsing and serialization available to test. To\n    enable it, pass in table_driven_parsing table_driven_serialization protoc\n    generator flags for C++\n\n      $ protoc --cpp_out=table_driven_parsing,table_driven_serialization:./ \\\n        test.proto\n\n  * lite generator parameter supported by the generator. Once set, all generated\n    files, use lite runtime regardless of the optimizer_for setting in the\n    .proto file.\n  * Various optimizations to make C++ code more performant on PowerPC platform\n  * Fixed maps data corruption when the maps are modified by both reflection API\n    and generated API.\n  * Deterministic serialization on maps reflection now uses stable sort.\n  * file() accessors are introduced to various *Descriptor classes to make\n    writing template function easier.\n  * ByteSize() and SpaceUsed() are deprecated.Use ByteSizeLong() and\n    SpaceUsedLong() instead\n  * Consistent hash function is used for maps in DEBUG and NDEBUG build.\n  * \"using namespace std\" is removed from stubs/common.h\n  * Various performance optimizations and bug fixes\n\n  Java\n  * Introduced new parser API DiscardUnknownFieldsParser in preparation of\n    proto3 unknown fields preservation change. Users who want to drop unknown\n    fields should migrate to use this new parser API. For example:\n\n      Parser<Foo> parser = DiscardUnknownFieldsParser.wrap(Foo.parser());\n      Foo foo = parser.parseFrom(input);\n\n  * Introduced new TextFormat API printUnicodeFieldValue() that prints field\n    value without escaping unicode characters.\n  * Added Durations.compare(Duration, Duration) and\n    Timestamps.compare(Timestamp, Timestamp).\n  * JsonFormat now accepts base64url encoded bytes fields.\n  * Optimized CodedInputStream to do less copies when parsing large bytes\n    fields.\n  * Optimized TextFormat to allocate less memory when printing.\n\n  Python\n  * SerializeToString API is changed to SerializeToString(self, **kwargs),\n    deterministic parameter is accepted for deterministic serialization.\n  * Added sort_keys parameter in json format to make the output deterministic.\n  * Added indent parameter in json format.\n  * Added extension support in json format.\n  * Added __repr__ support for repeated field in cpp implementation.\n  * Added file in FieldDescriptor.\n  * Added pretty-print filter to text format.\n  * Services and method descriptors are always printed even if generic_service\n    option is turned off.\n  * Note: AppEngine 2.5 is deprecated on June 2017 that AppEngine 2.5 will\n    never update protobuf runtime. Users who depend on AppEngine 2.5 should use\n    old protoc.\n\n  PHP\n  * Support PHP generic services. Specify file option php_generic_service=true\n    to enable generating service interface.\n  * Message, repeated and map fields setters take value instead of reference.\n  * Added map iterator in c extension.\n  * Support json \u00a0encode/decode.\n  * Added more type info in getter/setter phpdoc\n  * Fixed the problem that c extension and php implementation cannot be used\n    together.\n  * Added file option php_namespace to use custom php namespace instead of\n    package.\n  * Added fluent setter.\n  * Added descriptor API in runtime for custom encode/decode.\n  * Various bug fixes.\n\n  Objective-C\n  * Fix for GPBExtensionRegistry copying and add tests.\n  * Optimize GPBDictionary.m codegen to reduce size of overall library by 46K\n    per architecture.\n  * Fix some cases of reading of 64bit map values.\n  * Properly error on a tag with field number zero.\n  * Preserve unknown fields in proto3 syntax files.\n  * Document the exceptions on some of the writing apis.\n\n  C#\n  * Implemented IReadOnlyDictionary<K,V> in MapField<K,V>\n  * Added TryUnpack method for Any message in addition to Unpack.\n  * Converted C# projects to MSBuild (csproj) format.\n\n  Ruby\n  * Several bug fixes.\n\n  Javascript\n  * Added support of field option js_type. Now one can specify the JS type of a\n    64-bit integer field to be string in the generated code by adding option\n    [jstype = JS_STRING] on the field.\n\n2017-04-05 version 3.3.0 (C++/Java/Python/PHP/Objective-C/C#/Ruby/JavaScript)\n  Planned Future Changes\n  * There are some changes that are not included in this release but are\n    planned for the near future:\n      - Preserve unknown fields in proto3: please read this doc:\n\n          https://docs.google.com/document/d/1KMRX-G91Aa-Y2FkEaHeeviLRRNblgIahbsk4wA14gRk/view\n\n        for the timeline and follow up this github issue:\n\n          https://github.com/protocolbuffers/protobuf/issues/272\n\n        for discussion.\n      - Make C++ implementation C++11 only: we plan to require C++11 to build\n        protobuf code starting from 3.4.0 or 3.5.0 release. Please join this\n        github issue:\n\n          https://github.com/protocolbuffers/protobuf/issues/2780\n\n        to provide your feedback.\n\n  C++\n  * Fixed map fields serialization of DynamicMessage to correctly serialize\n    both key and value regardless of their presence.\n  * Parser now rejects field number 0 correctly.\n  * New API Message::SpaceUsedLong() that\u2019s equivalent to\n    Message::SpaceUsed() but returns the value in size_t.\n  * JSON support\n    - New flag always_print_enums_as_ints in JsonPrintOptions.\n    - New flag preserve_proto_field_names in JsonPrintOptions. It will instruct\n      the JSON printer to use the original field name declared in the .proto\n      file instead of converting them to lowerCamelCase when printing JSON.\n    - JsonPrintOptions.always_print_primtive_fields now works for oneof message\n      fields.\n    - Fixed a bug that doesn\u2019t allow different fields to set the same json_name\n      value.\n    - Fixed a performance bug that causes excessive memory copy when printing\n      large messages.\n  * Various performance optimizations.\n\n  Java\n  * Map field setters eagerly validate inputs and throw NullPointerExceptions\n    as appropriate.\n  * Added ByteBuffer overloads to the generated parsing methods and the Parser\n    interface.\n  * proto3 enum's getNumber() method now throws on UNRECOGNIZED values.\n  * Output of JsonFormat is now locale independent.\n\n  Python\n  * Added FindServiceByName() in the pure-Python DescriptorPool. This works only\n    for descriptors added with DescriptorPool.Add(). Generated descriptor_pool\n    does not support this yet.\n  * Added a descriptor_pool parameter for parsing Any in text_format.Parse().\n  * descriptor_pool.FindFileContainingSymbol() now is able to find nested\n    extensions.\n  * Extending empty [] to repeated field now sets parent message presence.\n\n  PHP\n  * Added file option php_class_prefix. The prefix will be prepended to all\n    generated classes defined in the file.\n  * When encoding, negative int32 values are sign-extended to int64.\n  * Repeated/Map field setter accepts a regular PHP array. Type checking is\n    done on the array elements.\n  * encode/decode are renamed to serializeToString/mergeFromString.\n  * Added mergeFrom, clear method on Message.\n  * Fixed a bug that oneof accessor didn\u2019t return the field name that is\n    actually set.\n  * C extension now works with php7.\n  * This is the first GA release of PHP. We guarantee that old generated code\n    can always work with new runtime and new generated code.\n\n  Objective-C\n  * Fixed help for GPBTimestamp for dates before the epoch that contain\n    fractional seconds.\n  * Added GPBMessageDropUnknownFieldsRecursively() to remove unknowns from a\n    message and any sub messages.\n  * Addressed a threading race in extension registration/lookup.\n  * Increased the max message parsing depth to 100 to match the other languages.\n  * Removed some use of dispatch_once in favor of atomic compare/set since it\n    needs to be heap based.\n  * Fixes for new Xcode 8.3 warnings.\n\n  C#\n  * Fixed MapField.Values.CopyTo, which would throw an exception unnecessarily\n    if provided exactly the right size of array to copy to.\n  * Fixed enum JSON formatting when multiple names mapped to the same numeric\n    value.\n  * Added JSON formatting option to format enums as integers.\n  * Modified RepeatedField<T> to implement IReadOnlyList<T>.\n  * Introduced the start of custom option handling; it's not as pleasant as it\n    might be, but the information is at least present. We expect to extend code\n    generation to improve this in the future.\n  * Introduced ByteString.FromStream and ByteString.FromStreamAsync to\n    efficiently create a ByteString from a stream.\n  * Added whole-message deprecation, which decorates the class with [Obsolete].\n\n  Ruby\n  * Fixed Message#to_h for messages with map fields.\n  * Fixed memcpy() in binary gems to work for old glibc, without breaking the\n    build for non-glibc libc\u2019s like musl.\n\n  Javascript\n  * Added compatibility tests for version 3.0.0.\n  * Added conformance tests.\n  * Fixed serialization of extensions: we need to emit a value even if it is\n    falsy (like the number 0).\n  * Use closurebuilder.py in favor of calcdeps.py for compiling JavaScript.\n\n2017-01-23 version 3.2.0 (C++/Java/Python/PHP/Ruby/Objective-C/C#/JavaScript/Lite)\n  General\n  * Added protoc version number to protoc plugin protocol. It can be used by\n    protoc plugin to detect which version of protoc is used with the plugin and\n    mitigate known problems in certain version of protoc.\n\n  C++\n  * The default parsing byte size limit has been raised from 64MB to 2GB.\n  * Added rvalue setters for non-arena string fields.\n  * Enabled debug logging for Android.\n  * Fixed a double-free problem when using Reflection::SetAllocatedMessage()\n    with extension fields.\n  * Fixed several deterministic serialization bugs:\n    * MessageLite::SerializeAsString() now respects the global deterministic\n      serialization flag.\n    * Extension fields are serialized deterministically as well.  Fixed protocol\n      compiler to correctly report importing-self as an error.\n  * Fixed FileDescriptor::DebugString() to print custom options correctly.\n  * Various performance/codesize optimizations and cleanups.\n\n  Java\n  * The default parsing byte size limit has been raised from 64MB to 2GB.\n  * Added recursion limit when parsing JSON.\n  * Fixed a bug that enumType.getDescriptor().getOptions() doesn't have custom\n    options.\n  * Fixed generated code to support field numbers up to 2^29-1.\n\n  Python\n  * You can now assign NumPy scalars/arrays (np.int32, np.int64) to protobuf\n    fields, and assigning other numeric types has been optimized for\n    performance.\n  * Pure-Python: message types are now garbage-collectable.\n  * Python/C++: a lot of internal cleanup/refactoring.\n\n  PHP (Alpha)\n  * For 64-bit integers type (int64/uint64/sfixed64/fixed64/sint64), use PHP\n    integer on 64-bit environment and PHP string on 32-bit environment.\n  * PHP generated code also conforms to PSR-4 now.\n  * Fixed ZTS build for c extension.\n  * Fixed c extension build on Mac.\n  * Fixed c extension build on 32-bit linux.\n  * Fixed the bug that message without namespace is not found in the descriptor\n    pool. (#2240)\n  * Fixed the bug that repeated field is not iterable in c extension.\n  * Message names Empty will be converted to GPBEmpty in generated code.\n  * Added phpdoc in generated files.\n  * The released API is almost stable. Unless there is large problem, we won't\n    change it. See\n    https://developers.google.com/protocol-buffers/docs/reference/php-generated\n    for more details.\n\n  Objective-C\n  * Added support for push/pop of the stream limit on CodedInputStream for\n    anyone doing manual parsing.\n\n  C#\n  * No changes.\n\n  Ruby\n  * Message objects now support #respond_to? for field getters/setters.\n  * You can now compare \u201cmessage == non_message_object\u201d and it will return false\n    instead of throwing an exception.\n  * JRuby: fixed #hashCode to properly reflect the values in the message.\n\n  Javascript\n  * Deserialization of repeated fields no longer has quadratic performance\n    behavior.\n  * UTF-8 encoding/decoding now properly supports high codepoints.\n  * Added convenience methods for some well-known types: Any, Struct, and\n    Timestamp. These make it easier to convert data between native JavaScript\n    types and the well-known protobuf types.\n\n2016-09-23 version 3.1.0 (C++/Java/Python/PHP/Ruby/Objective-C/C#/JavaScript/Lite)\n  General\n  * Proto3 support in PHP (alpha).\n  * Various bug fixes.\n\n  C++\n  * Added MessageLite::ByteSizeLong() that\u2019s equivalent to\n    MessageLite::ByteSize() but returns the value in size_t. Useful to check\n    whether a message is over the 2G size limit that protobuf can support.\n  * Moved default_instances to global variables. This allows default_instance\n    addresses to be known at compile time.\n  * Adding missing generic gcc 64-bit atomicops.\n  * Restore New*Callback into google::protobuf namespace since these are used\n    by the service stubs code\n  * JSON support.\n    * Fixed some conformance issues.\n  * Fixed a JSON serialization bug for bytes fields.\n\n  Java\n  * Fixed a bug in TextFormat that doesn\u2019t accept empty repeated fields (i.e.,\n    \u201cfield: [ ]\u201d).\n  * JSON support\n    * Fixed JsonFormat to do correct snake_case-to-camelCase conversion for\n      non-style-conforming field names.\n    * Fixed JsonFormat to parse empty Any message correctly.\n    * Added an option to JsonFormat.Parser to ignore unknown fields.\n  * Experimental API\n    * Added UnsafeByteOperations.unsafeWrap(byte[]) to wrap a byte array into\n      ByteString without copy.\n\n  Python\n  * JSON support\n    * Fixed some conformance issues.\n\n  PHP (Alpha)\n  * We have added the proto3 support for PHP via both a pure PHP package and a\n    native c extension. The pure PHP package is intended to provide usability\n    to wider range of PHP platforms, while the c extension is intended to\n    provide higher performance. Both implementations provide the same runtime\n    APIs and share the same generated code. Users don\u2019t need to re-generate\n    code for the same proto definition when they want to switch the\n    implementation later. The pure PHP package is included in the php/src\n    directory, and the c extension is included in the php/ext directory.\n\n    Both implementations provide idiomatic PHP APIs:\n    * All messages and enums are defined as PHP classes.\n    * All message fields can only be accessed via getter/setter.\n    * Both repeated field elements and map elements are stored in containers\n      that act like a normal PHP array.\n\n    Unlike several existing third-party PHP implementations for protobuf, our\n    implementations are built on a \"strongly-typed\" philosophy: message fields\n    and array/map containers will throw exceptions eagerly when values of the\n    incorrect type (not including those that can be type converted, e.g.,\n    double <-> integer <-> numeric string) are inserted.\n\n    Currently, pure PHP runtime supports php5.5, 5.6 and 7 on linux. C\n    extension runtime supports php5.5 and 5.6 on linux.\n\n    See php/README.md for more details about installment. See\n    https://developers.google.com/protocol-buffers/docs/phptutorial for more\n    details about APIs.\n\n  Objective-C\n  * Helpers are now provided for working the Any well known type (see\n    GPBWellKnownTypes.h for the api additions).\n  * Some improvements in startup code (especially when extensions aren\u2019t used).\n\n  Javascript\n  * Fixed missing import of jspb.Map\n  * Fixed valueWriterFn variable name\n\n  Ruby\n  * Fixed hash computation for JRuby's RubyMessage\n  * Make sure map parsing frames are GC-rooted.\n  * Added API support for well-known types.\n\n  C#\n  * Removed check on dependency in the C# reflection API.\n\n2016-09-06 version 3.0.2 (C++/Java/Python/Ruby/Objective-C/C#/JavaScript/Lite)\n  General\n  * Various bug fixes.\n\n  Objective C\n  * Fix for oneofs in proto3 syntax files where fields were set to the zero\n    value.\n  * Fix for embedded null character in strings.\n  * CocoaDocs support\n\n  Ruby\n  * Fixed memory corruption bug in parsing that could occur under GC pressure.\n\n  Javascript\n  * jspb.Map is now properly exported to CommonJS modules.\n\n  C#\n  * Removed legacy_enum_values flag.\n\n\n2016-07-27 version 3.0.0 (C++/Java/Python/Ruby/Objective-C/C#/JavaScript/Lite)\n  General\n  * This log only contains changes since the beta-4 release. Summarized change\n    log since the last stable release (v2.6.1) can be found in the github\n    release page.\n\n  Compatibility Notice\n  * v3.0.0 is the first API stable release of the v3.x series. We do not expect\n    any future API breaking changes.\n  * For C++, Java Lite and Objective-C, source level compatibility is\n    guaranteed.  Upgrading from v3.0.0 to newer minor version releases will be\n    source compatible. For example, if your code compiles against protobuf\n    v3.0.0, it will continue to compile after you upgrade protobuf library to\n    v3.1.0.\n  * For other languages, both source level compatibility and binary level\n    compatibility are guaranteed. For example, if you have a Java binary built\n    against protobuf v3.0.0. After switching the protobuf runtime binary to\n    v3.1.0, your built binary should continue to work.\n  * Compatibility is only guaranteed for documented API and documented\n    behaviors. If you are using undocumented API (e.g., use anything in the C++\n    internal namespace), it can be broken by minor version releases in an\n    undetermined manner.\n\n  Ruby\n  * When you assign a string field `a.string_field = \"X\"`, we now call\n    #encode(UTF-8) on the string and freeze the copy. This saves you from\n    needing to ensure the string is already encoded as UTF-8. It also prevents\n    you from mutating the string after it has been assigned (this is how we\n    ensure it stays valid UTF-8).\n  * The generated file for `foo.proto` is now `foo_pb.rb` instead of just\n    `foo.rb`. This makes it easier to see which imports/requires are from\n    protobuf generated code, and also prevents conflicts with any `foo.rb` file\n    you might have written directly in Ruby. It is a backward-incompatible\n    change: you will need to update all of your `require` statements.\n  * For package names like `foo_bar`, we now translate this to the Ruby module\n    `FooBar`. This is more idiomatic Ruby than what we used to do (`Foo_bar`).\n\n  JavaScript\n  * Scalar fields like numbers and boolean now return defaults instead of\n    `undefined` or `null` when they are unset. You can test for presence\n    explicitly by calling `hasFoo()`, which we now generate for scalar fields.\n\n  Java Lite\n  * Java Lite is now implemented as a separate plugin, maintained in the\n    `javalite` branch. Both lite runtime and protoc artifacts will be available\n    in Maven.\n\n  C#\n  * Target platforms now .NET 4.5, selected portable subsets and .NET Core.\n  * legacy_enum_values option is no longer supported.\n\n2016-07-15 version 3.0.0-beta-4 (C++/Java/Python/Ruby/Objective-C/C#/JavaScript)\n  General\n  * Added a deterministic serialization API for C++. The deterministic\n    serialization guarantees that given a binary, equal messages will be\n    serialized to the same bytes. This allows applications like MapReduce to\n    group equal messages based on the serialized bytes. The deterministic\n    serialization is, however, NOT canonical across languages; it is also\n    unstable across different builds with schema changes due to unknown fields.\n    Users who need canonical serialization, e.g. persistent storage in a\n    canonical form, fingerprinting, etc, should define their own\n    canonicalization specification and implement the serializer using reflection\n    APIs rather than relying on this API.\n  * Added OneofOptions. You can now define custom options for oneof groups.\n      import \"google/protobuf/descriptor.proto\";\n      extend google.protobuf.OneofOptions {\n        optional int32 my_oneof_extension = 12345;\n      }\n      message Foo {\n        oneof oneof_group {\n          (my_oneof_extension) = 54321;\n          ...\n        }\n      }\n\n  C++ (beta)\n  * Introduced a deterministic serialization API in\n    CodedOutputStream::SetSerializationDeterministic(bool). See the notes about\n    deterministic serialization in the General section.\n  * Added google::protobuf::Map::swap() to swap two map fields.\n  * Fixed a memory leak when calling Reflection::ReleaseMessage() on a message\n    allocated on arena.\n  * Improved error reporting when parsing text format protos.\n  * JSON\n      - Added a new parser option to ignore unknown fields when parsing JSON.\n      - Added convenient methods for message to/from JSON conversion.\n  * Various performance optimizations.\n\n  Java (beta)\n  * File option \"java_generate_equals_and_hash\" is now deprecated. equals() and\n    hashCode() methods are generated by default.\n  * Added a new JSON printer option \"omittingInsignificantWhitespace\" to produce\n    a more compact JSON output. The printer will pretty-print by default.\n  * Updated Java runtime to be compatible with 2.5.0/2.6.1 generated protos.\n\n  Python (beta)\n  * Added support to pretty print Any messages in text format.\n  * Added a flag to ignore unknown fields when parsing JSON.\n  * Bugfix: \"@type\" field of a JSON Any message is now correctly put before\n    other fields.\n\n  Objective-C (beta)\n  * Updated the code to support compiling with more compiler warnings\n    enabled. (Issue 1616)\n  * Exposing more detailed errors for parsing failures. (PR 1623)\n  * Small (breaking) change to the naming of some methods on the support classes\n    for map<>. There were collisions with the system provided KVO support, so\n    the names were changed to avoid those issues.  (PR 1699)\n  * Fixed for proper Swift bridging of error handling during parsing. (PR 1712)\n  * Complete support for generating sources that will go into a Framework and\n    depend on generated sources from other Frameworks. (Issue 1457)\n\n  C# (beta)\n  * RepeatedField optimizations.\n  * Support for .NET Core.\n  * Minor bug fixes.\n  * Ability to format a single value in JsonFormatter (advanced usage only).\n  * Modifications to attributes applied to generated code.\n\n  Javascript (alpha)\n  * Maps now have a real map API instead of being treated as repeated fields.\n  * Well-known types are now provided in the google-protobuf package, and the\n    code generator knows to require() them from that package.\n  * Bugfix: non-canonical varints are correctly decoded.\n\n  Ruby (alpha)\n  * Accessors for oneof fields now return default values instead of nil.\n\n  Java Lite\n  * Java lite support is removed from protocol compiler. It will be supported\n    as a protocol compiler plugin in a separate code branch.\n\n2016-05-16 version 3.0.0-beta-3 (C++/Java/Python/Ruby/Nano/Objective-C/C#/JavaScript)\n  General\n  * Supported Proto3 lite-runtime in C++/Java for mobile platforms.\n  * Any type now supports APIs to specify prefixes other than\n    type.googleapis.com\n  * Removed javanano_use_deprecated_package option; Nano will always has its own\n    \".nano\" package.\n\n  C++ (Beta)\n  * Improved hash maps.\n      - Improved hash maps comments. In particular, please note that equal hash\n        maps will not necessarily have the same iteration order and\n        serialization.\n      - Added a new hash maps implementation that will become the default in a\n        later release.\n  * Arenas\n      - Several inlined methods in Arena were moved to out-of-line to improve\n        build performance and code size.\n      - Added SpaceAllocatedAndUsed() to report both space used and allocated\n      - Added convenient class UnsafeArenaAllocatedRepeatedPtrFieldBackInserter\n  * Any\n      - Allow custom type URL prefixes in Any packing.\n      - TextFormat now expand the Any type rather than printing bytes.\n  * Performance optimizations and various bug fixes.\n\n  Java (Beta)\n  * Introduced an ExperimentalApi annotation. Annotated APIs are experimental\n    and are subject to change in a backward incompatible way in future releases.\n  * Introduced zero-copy serialization as an ExperimentalApi\n      - Introduction of the `ByteOutput` interface. This is similar to\n        `OutputStream` but provides semantics for lazy writing (i.e. no\n        immediate copy required) of fields that are considered to be immutable.\n      - `ByteString` now supports writing to a `ByteOutput`, which will directly\n        expose the internals of the `ByteString` (i.e. `byte[]` or `ByteBuffer`)\n        to the `ByteOutput` without copying.\n      - `CodedOutputStream` now supports writing to a `ByteOutput`. `ByteString`\n        instances that are too large to fit in the internal buffer will be\n        (lazily) written to the `ByteOutput` directly.\n      - This allows applications using large `ByteString` fields to avoid\n        duplication of these fields entirely. Such an application can supply a\n        `ByteOutput` that chains together the chunks received from\n        `CodedOutputStream` before forwarding them onto the IO system.\n  * Other related changes to `CodedOutputStream`\n      - Additional use of `sun.misc.Unsafe` where possible to perform fast\n        access to `byte[]` and `ByteBuffer` values and avoiding unnecessary\n        range checking.\n      - `ByteBuffer`-backed `CodedOutputStream` now writes directly to the\n        `ByteBuffer` rather than to an intermediate array.\n  * Improved lite-runtime.\n      - Lite protos now implement deep equals/hashCode/toString\n      - Significantly improved the performance of Builder#mergeFrom() and\n        Builder#mergeDelimitedFrom()\n  * Various bug fixes and small feature enhancement.\n      - Fixed stack overflow when in hashCode() for infinite recursive oneofs.\n      - Fixed the lazy field parsing in lite to merge rather than overwrite.\n      - TextFormat now supports reporting line/column numbers on errors.\n      - Updated to add appropriate @Override for better compiler errors.\n\n  Python (Beta)\n  * Added JSON format for Any, Struct, Value and ListValue\n  * [ ] is now accepted for both repeated scalar fields and repeated message\n    fields in text format parser.\n  * Numerical field name is now supported in text format.\n  * Added DiscardUnknownFields API for python protobuf message.\n\n  Objective-C (Beta)\n  * Proto comments now come over as HeaderDoc comments in the generated sources\n    so Xcode can pick them up and display them.\n  * The library headers have been updated to use HeaderDoc comments so Xcode can\n    pick them up and display them.\n  * The per message and per field overhead in both generated code and runtime\n    object sizes was reduced.\n  * Generated code now include deprecated annotations when the proto file\n    included them.\n\n  C# (Beta)\n  In general: some changes are breaking, which require regenerating messages.\n  Most user-written code will not be impacted *except* for the renaming of enum\n  values.\n\n  * Allow custom type URL prefixes in `Any` packing, and ignore them when\n    unpacking\n  * `protoc` is now in a separate NuGet package (Google.Protobuf.Tools)\n  * New option: `internal_access` to generate internal classes\n  * Enum values are now PascalCased, and if there's a prefix which matches the\n    name of the enum, that is removed (so an enum `COLOR` with a value\n    `COLOR_BLUE` would generate a value of just `Blue`). An option\n    (`legacy_enum_values`) is temporarily available to disable this, but the\n    option will be removed for GA.\n  * `json_name` option is now honored\n  * If group tags are encountered when parsing, they are validated more\n    thoroughly (although we don't support actual groups)\n  * NuGet dependencies are better specified\n  * Breaking: `Preconditions` is renamed to `ProtoPreconditions`\n  * Breaking: `GeneratedCodeInfo` is renamed to `GeneratedClrTypeInfo`\n  * `JsonFormatter` now allows writing to a `TextWriter`\n  * New interface, `ICustomDiagnosticMessage` to allow more compact\n    representations from `ToString`\n  * `CodedInputStream` and `CodedOutputStream` now implement `IDisposable`,\n    which simply disposes of the streams they were constructed with\n  * Map fields no longer support null values (in line with other languages)\n  * Improvements in JSON formatting and parsing\n\n  Javascript (Alpha)\n  * Better support for \"bytes\" fields: bytes fields can be read as either a\n    base64 string or UInt8Array (in environments where TypedArray is supported).\n  * New support for CommonJS imports.  This should make it easier to use the\n    JavaScript support in Node.js and tools like WebPack.  See js/README.md for\n    more information.\n  * Some significant internal refactoring to simplify and modularize the code.\n\n  Ruby (Alpha)\n  * JSON serialization now properly uses camelCased names, with a runtime option\n    that will preserve original names from .proto files instead.\n  * Well-known types are now included in the distribution.\n  * Release now includes binary gems for Windows, Mac, and Linux instead of just\n    source gems.\n  * Bugfix for serializing oneofs.\n\n  C++/Java Lite (Alpha)\n    A new \"lite\" generator parameter was introduced in the protoc for C++ and\n    Java for Proto3 syntax messages. Example usage:\n\n     ./protoc --cpp_out=lite:$OUTPUT_PATH foo.proto\n\n    The protoc will treat the current input and all the transitive dependencies\n    as LITE. The same generator parameter must be used to generate the\n    dependencies.\n\n    In Proto3 syntax files, \"optimized_for=LITE_RUNTIME\" is no longer supported.\n\n\n2015-12-30 version 3.0.0-beta-2 (C++/Java/Python/Ruby/Nano/Objective-C/C#/JavaScript)\n  General\n  * Introduced a new language implementation: JavaScript.\n  * Added a new field option \"json_name\". By default proto field names are\n    converted to \"lowerCamelCase\" in proto3 JSON format. This option can be\n    used to override this behavior and specify a different JSON name for the\n    field.\n  * Added conformance tests to ensure implementations are following proto3 JSON\n    specification.\n\n  C++ (Beta)\n  * Various bug fixes and improvements to the JSON support utility:\n      - Duplicate map keys in JSON are now rejected (i.e., translation will\n        fail).\n      - Fixed wire-format for google.protobuf.Value/ListValue.\n      - Fixed precision loss when converting google.protobuf.Timestamp.\n      - Fixed a bug when parsing invalid UTF-8 code points.\n      - Fixed a memory leak.\n      - Reduced call stack usage.\n\n  Java (Beta)\n  * Cleaned up some unused methods on CodedOutputStream.\n  * Presized lists for packed fields during parsing in the lite runtime to\n    reduce allocations and improve performance.\n  * Improved the performance of unknown fields in the lite runtime.\n  * Introduced UnsafeByteStrings to support zero-copy ByteString creation.\n  * Various bug fixes and improvements to the JSON support utility:\n      - Fixed a thread-safety bug.\n      - Added a new option \u201cpreservingProtoFieldNames\u201d to JsonFormat.\n      - Added a new option \u201cincludingDefaultValueFields\u201d to JsonFormat.\n      - Updated the JSON utility to comply with proto3 JSON specification.\n\n  Python (Beta)\n  * Added proto3 JSON format utility. It includes support for all field types\n    and a few well-known types except for Any and Struct.\n  * Added runtime support for Any, Timestamp, Duration and FieldMask.\n  * [ ] is now accepted for repeated scalar fields in text format parser.\n  * Map fields now have proper O(1) performance for lookup/insert/delete\n    when using the Python/C++ implementation. They were previously using O(n)\n    search-based algorithms because the C++ reflection interface didn't\n    support true map operations.\n\n  Objective-C (Beta)\n  * Various bug-fixes and code tweaks to pass more strict compiler warnings.\n  * Now has conformance test coverage and is passing all tests.\n\n  C# (Beta)\n  * Various bug-fixes.\n  * Code generation: Files generated in directories based on namespace.\n  * Code generation: Include comments from .proto files in XML doc\n    comments (naively)\n  * Code generation: Change organization/naming of \"reflection class\" (access\n    to file descriptor)\n  * Code generation and library: Add Parser property to MessageDescriptor,\n    and introduce a non-generic parser type.\n  * Library: Added TypeRegistry to support JSON parsing/formatting of Any.\n  * Library: Added Any.Pack/Unpack support.\n  * Library: Implemented JSON parsing.\n\n  Javascript (Alpha)\n  * Added proto3 support for JavaScript. The runtime is written in pure\n    JavaScript and works in browsers and in Node.js. To generate JavaScript\n    code for your proto, invoke protoc with \"--js_out\". See js/README.md\n    for more build instructions.\n\n2015-08-26 version 3.0.0-beta-1 (C++/Java/Python/Ruby/Nano/Objective-C/C#)\n  About Beta\n  * This is the first beta release of protobuf v3.0.0. Not all languages\n    have reached beta stage. Languages not marked as beta are still in\n    alpha (i.e., be prepared for API breaking changes).\n\n  General\n  * Proto3 JSON is supported in several languages (fully supported in C++\n    and Java, partially supported in Ruby/C#). The JSON spec is defined in\n    the proto3 language guide:\n\n      https://developers.google.com/protocol-buffers/docs/proto3#json\n\n    We will publish a more detailed spec to define the exact behavior of\n    proto3-conformant JSON serializers and parsers. Until then, do not rely\n    on specific behaviors of the implementation if it\u2019s not documented in\n    the above spec. More specifically, the behavior is not yet finalized for\n    the following:\n      - Parsing invalid JSON input (e.g., input with trailing commas).\n      - Non-camelCase names in JSON input.\n      - The same field appears multiple times in JSON input.\n      - JSON arrays contain \u201cnull\u201d values.\n      - The message has unknown fields.\n\n  * Proto3 now enforces strict UTF-8 checking. Parsing will fail if a string\n    field contains non UTF-8 data.\n\n  C++ (Beta)\n  * Introduced new utility functions/classes in the google/protobuf/util\n    directory:\n      - MessageDifferencer: compare two proto messages and report their\n                            differences.\n      - JsonUtil: support converting protobuf binary format to/from JSON.\n      - TimeUtil: utility functions to work with well-known types Timestamp\n                  and Duration.\n      - FieldMaskUtil: utility functions to work with FieldMask.\n\n  * Performance optimization of arena construction and destruction.\n  * Bug fixes for arena and maps support.\n  * Changed to use cmake for Windows Visual Studio builds.\n  * Added Bazel support.\n\n  Java (Beta)\n  * Introduced a new util package that will be distributed as a separate\n    artifact in maven. It contains:\n      - JsonFormat: convert proto messages to/from JSON.\n      - TimeUtil: utility functions to work with Timestamp and Duration.\n      - FieldMaskUtil: utility functions to work with FieldMask.\n\n  * The static PARSER in each generated message is deprecated, and it will\n    be removed in a future release. A static parser() getter is generated\n    for each message type instead.\n  * Performance optimizations for String fields serialization.\n  * Performance optimizations for Lite runtime on Android:\n      - Reduced allocations\n      - Reduced method overhead after ProGuarding\n      - Reduced code size after ProGuarding\n\n  Python (Alpha)\n  * Removed legacy Python 2.5 support.\n  * Moved to a single Python 2.x/3.x-compatible codebase, instead of using 2to3.\n  * Fixed build/tests on Python 2.6, 2.7, 3.3, and 3.4.\n      - Pure-Python works on all four.\n      - Python/C++ implementation works on all but 3.4, due to changes in the\n        Python/C++ API in 3.4.\n  * Some preliminary work has been done to allow for multiple DescriptorPools\n    with Python/C++.\n\n  Ruby (Alpha)\n  * Many bugfixes:\n      - fixed parsing/serialization of bytes, sint, sfixed types\n      - other parser bugfixes\n      - fixed memory leak affecting Ruby 2.2\n\n  JavaNano (Alpha)\n  * JavaNano generated code now will be put in a nano package by default to\n    avoid conflicts with Java generated code.\n\n  Objective-C (Alpha)\n  * Added non-null markup to ObjC library. Requires SDK 8.4+ to build.\n  * Many bugfixes:\n      - Removed the class/enum filter.\n      - Renamed some internal types to avoid conflicts with the well-known types\n        protos.\n      - Added missing support for parsing repeated primitive fields in packed or\n        unpacked forms.\n      - Added *Count for repeated and map<> fields to avoid auto-create when\n        checking for them being set.\n\n  C# (Alpha)\n  * Namespace changed to Google.Protobuf (and NuGet package will be named\n    correspondingly).\n  * Target platforms now .NET 4.5 and selected portable subsets only.\n  * Removed lite runtime.\n  * Reimplementation to use mutable message types.\n  * Null references used to represent \"no value\" for message type fields.\n  * Proto3 semantics supported; proto2 files are prohibited for C# codegen.\n    Most proto3 features supported:\n      - JSON formatting (a.k.a. serialization to JSON), including well-known\n        types (except for Any).\n      - Wrapper types mapped to nullable value types (or string/ByteString\n        allowing nullability). JSON parsing is not supported yet.\n      - maps\n      - oneof\n      - enum unknown value preservation\n\n2015-05-25 version 3.0.0-alpha-3 (Objective-C/C#):\n  General\n  * Introduced two new language implementations (Objective-C, C#) to proto3.\n  * Explicit \"optional\" keyword are disallowed in proto3 syntax, as fields are\n    optional by default.\n  * Group fields are no longer supported in proto3 syntax.\n  * Changed repeated primitive fields to use packed serialization by default in\n    proto3 (implemented for C++, Java, Python in this release).  The user can\n    still disable packed serialization by setting packed to false for now.\n  * Added well-known type protos (any.proto, empty.proto, timestamp.proto,\n    duration.proto, etc.). Users can import and use these protos just like\n    regular proto files. Additional runtime support will be added for them in\n    future releases (in the form of utility helper functions, or having them\n    replaced by language specific types in generated code).\n  * Added a \"reserved\" keyword in both proto2 and proto3 syntax. User can use\n    this keyword to declare reserved field numbers and names to prevent them\n    from being reused by other fields in the same message.\n\n    To reserve field numbers, add a reserved declaration in your message:\n\n      message TestMessage {\n        reserved 2, 15, 9 to 11, 3;\n      }\n\n    This reserves field numbers 2, 3, 9, 10, 11 and 15. If a user uses any of\n    these as field numbers, the protocol buffer compiler will report an error.\n\n    Field names can also be reserved:\n\n      message TestMessage {\n        reserved \"foo\", \"bar\";\n      }\n\n  * Various bug fixes since 3.0.0-alpha-2\n\n  Objective-C\n    Objective-C includes a code generator and a native objective-c runtime\n    library.  By adding \u201c--objc_out\u201d to protoc, the code generator will generate\n    a header(*.pbobjc.h) and an implementation file(*.pbobjc.m) for each proto\n    file.\n\n    In this first release, the generated interface provides: enums, messages,\n    field support(single, repeated, map, oneof), proto2 and proto3 syntax\n    support, parsing and serialization. It\u2019s  compatible with ARC and non-ARC\n    usage. Besides, user can also access it via the swift bridging header.\n\n    See objectivec/README.md for details.\n\n  C#\n    * C# protobufs are based on project\n      https://github.com/jskeet/protobuf-csharp-port. The original project was\n      frozen and all the new development will happen here.\n    * Codegen plugin for C# was completely rewritten to C++ and is now an\n      integral part of protoc.\n    * Some refactorings and cleanup has been applied to the C# runtime library.\n    * Only proto2 is supported in C# at the moment, proto3 support is in\n      progress and will likely bring significant breaking changes to the API.\n\n    See csharp/README.md for details.\n\n  C++\n    * Added runtime support for Any type. To use Any in your proto file, first\n      import the definition of Any:\n\n        // foo.proto\n        import \"google/protobuf/any.proto\";\n        message Foo {\n          google.protobuf.Any any_field = 1;\n        }\n        message Bar {\n          int32 value = 1;\n        }\n\n      Then in C++ you can access the Any field using PackFrom()/UnpackTo()\n      methods:\n\n        Foo foo;\n        Bar bar = ...;\n        foo.mutable_any_field()->PackFrom(bar);\n        ...\n        if (foo.any_field().IsType<Bar>()) {\n          foo.any_field().UnpackTo(&bar);\n          ...\n        }\n    * In text format, entries of a map field will be sorted by key.\n\n  Java\n    * Continued optimizations on the lite runtime to improve performance for\n      Android.\n\n  Python\n    * Added map support.\n      - maps now have a dict-like interface (msg.map_field[key] = value)\n      - existing code that modifies maps via the repeated field interface\n        will need to be updated.\n\n  Ruby\n    * Improvements to RepeatedField's emulation of the Ruby Array API.\n    * Various speedups and internal cleanups.\n\n2015-02-26 version 3.0.0-alpha-2 (Python/Ruby/JavaNano):\n  General\n  * Introduced three new language implementations (Ruby, JavaNano, and\n    Python) to proto3.\n  * Various bug fixes since 3.0.0-alpha-1\n\n  Python:\n    Python has received several updates, most notably support for proto3\n    semantics in any .proto file that declares syntax=\"proto3\".\n    Messages declared in proto3 files no longer represent field presence\n    for scalar fields (number, enums, booleans, or strings).  You can\n    no longer call HasField() for such fields, and they are serialized\n    based on whether they have a non-zero/empty/false value.\n\n    One other notable change is in the C++-accelerated implementation.\n    Descriptor objects (which describe the protobuf schema and allow\n    reflection over it) are no longer duplicated between the Python\n    and C++ layers.  The Python descriptors are now simple wrappers\n    around the C++ descriptors.  This change should significantly\n    reduce the memory usage of programs that use a lot of message\n    types.\n\n  Ruby:\n    We have added proto3 support for Ruby via a native C extension.\n\n    The Ruby extension itself is included in the ruby/ directory, and details on\n    building and installing the extension are in ruby/README.md. The extension\n    will also be published as a Ruby gem. Code generator support is included as\n    part of `protoc` with the `--ruby_out` flag.\n\n    The Ruby extension implements a user-friendly DSL to define message types\n    (also generated by the code generator from `.proto` files).  Once a message\n    type is defined, the user may create instances of the message that behave in\n    ways idiomatic to Ruby. For example:\n\n    - Message fields are present as ordinary Ruby properties (getter method\n      `foo` and setter method `foo=`).\n    - Repeated field elements are stored in a container that acts like a native\n      Ruby array, and map elements are stored in a container that acts like a\n      native Ruby hashmap.\n    - The usual well-known methods, such as `#to_s`, `#dup`, and the like, are\n      present.\n\n    Unlike several existing third-party Ruby extensions for protobuf, this\n    extension is built on a \"strongly-typed\" philosophy: message fields and\n    array/map containers will throw exceptions eagerly when values of the\n    incorrect type are inserted.\n\n    See ruby/README.md for details.\n\n  JavaNano:\n    JavaNano is a special code generator and runtime library designed especially\n    for resource-restricted systems, like Android. It is very resource-friendly\n    in both the amount of code and the runtime overhead. Here is an an overview\n    of JavaNano features compared with the official Java protobuf:\n\n    - No descriptors or message builders.\n    - All messages are mutable; fields are public Java fields.\n    - For optional fields only, encapsulation behind setter/getter/hazzer/\n      clearer functions is opt-in, which provide proper 'has' state support.\n    - For proto2, if not opted in, has state (field presence) is not available.\n      Serialization outputs all fields not equal to their defaults.\n      The behavior is consistent with proto3 semantics.\n    - Required fields (proto2 only) are always serialized.\n    - Enum constants are integers; protection against invalid values only\n      when parsing from the wire.\n    - Enum constants can be generated into container interfaces bearing\n      the enum's name (so the referencing code is in Java style).\n    - CodedInputByteBufferNano can only take byte[] (not InputStream).\n    - Similarly CodedOutputByteBufferNano can only write to byte[].\n    - Repeated fields are in arrays, not ArrayList or Vector. Null array\n      elements are allowed and silently ignored.\n    - Full support for serializing/deserializing repeated packed fields.\n    - Support  extensions (in proto2).\n    - Unset messages/groups are null, not an immutable empty default\n      instance.\n    - toByteArray(...) and mergeFrom(...) are now static functions of\n      MessageNano.\n    - The 'bytes' type translates to the Java type byte[].\n\n    See javanano/README.txt for details.\n\n2014-12-01 version 3.0.0-alpha-1 (C++/Java):\n\n  General\n  * Introduced Protocol Buffers language version 3 (aka proto3).\n\n    When protobuf was initially opensourced it implemented Protocol Buffers\n    language version 2 (aka proto2), which is why the version number\n    started from v2.0.0. From v3.0.0, a new language version (proto3) is\n    introduced while the old version (proto2) will continue to be supported.\n\n    The main intent of introducing proto3 is to clean up protobuf before\n    pushing the language as the foundation of Google's new API platform.\n    In proto3, the language is simplified, both for ease of use and  to\n    make it available in a wider range of programming languages. At the\n    same time a few features are added to better support common idioms\n    found in APIs.\n\n    The following are the main new features in language version 3:\n\n      1. Removal of field presence logic for primitive value fields, removal\n         of required fields, and removal of default values. This makes proto3\n         significantly easier to implement with open struct representations,\n         as in languages like Android Java, Objective C, or Go.\n      2. Removal of unknown fields.\n      3. Removal of extensions, which are instead replaced by a new standard\n         type called Any.\n      4. Fix semantics for unknown enum values.\n      5. Addition of maps.\n      6. Addition of a small set of standard types for representation of time,\n         dynamic data, etc.\n      7. A well-defined encoding in JSON as an alternative to binary proto\n         encoding.\n\n    This release (v3.0.0-alpha-1) includes partial proto3 support for C++ and\n    Java. Items 6 (well-known types) and 7 (JSON format) in the above feature\n    list are not implemented.\n\n    A new notion \"syntax\" is introduced to specify whether a .proto file\n    uses proto2 or proto3:\n\n      // foo.proto\n      syntax = \"proto3\";\n      message Bar {...}\n\n    If omitted, the protocol compiler will generate a warning and \"proto2\" will\n    be used as the default. This warning will be turned into an error in a\n    future release.\n\n    We recommend that new Protocol Buffers users use proto3. However, we do not\n    generally recommend that existing users migrate from proto2 from proto3 due\n    to API incompatibility, and we will continue to support proto2 for a long\n    time.\n\n  * Added support for map fields (implemented in C++/Java for both proto2 and\n    proto3).\n\n    Map fields can be declared using the following syntax:\n\n      message Foo {\n        map<string, string> values = 1;\n      }\n\n    Data of a map field will be stored in memory as an unordered map and it\n    can be accessed through generated accessors.\n\n  C++\n  * Added arena allocation support (for both proto2 and proto3).\n\n    Profiling shows memory allocation and deallocation constitutes a significant\n    fraction of CPU-time spent in protobuf code and arena allocation is a\n    technique introduced to reduce this cost. With arena allocation, new\n    objects will be allocated from a large piece of preallocated memory and\n    deallocation of these objects is almost free. Early adoption shows 20% to\n    50% improvement in some Google binaries.\n\n    To enable arena support, add the following option to your .proto file:\n\n      option cc_enable_arenas = true;\n\n    Protocol compiler will generate additional code to make the generated\n    message classes work with arenas. This does not change the existing API\n    of protobuf messages and does not affect wire format. Your existing code\n    should continue to work after adding this option. In the future we will\n    make this option enabled by default.\n\n    To actually take advantage of arena allocation, you need to use the arena\n    APIs when creating messages. A quick example of using the arena API:\n\n      {\n        google::protobuf::Arena arena;\n        // Allocate a protobuf message in the arena.\n        MyMessage* message = Arena::CreateMessage<MyMessage>(&arena);\n        // All submessages will be allocated in the same arena.\n        if (!message->ParseFromString(data)) {\n          // Deal with malformed input data.\n        }\n        // Must not delete the message here. It will be deleted automatically\n        // when the arena is destroyed.\n      }\n\n    Currently arena does not work with map fields. Enabling arena in a .proto\n    file containing map fields will result in compile errors in the generated\n    code. This will be addressed in a future release.\n\n2014-10-20 version 2.6.1:\n\n  C++\n  * Added atomicops support for Solaris.\n  * Released memory allocated by InitializeDefaultRepeatedFields() and\n    GetEmptyString(). Some memory sanitizers reported them as memory leaks.\n\n  Java\n  * Updated DynamicMessage.setField() to handle repeated enum values\n    correctly.\n  * Fixed a bug that caused NullPointerException to be thrown when\n    converting manually constructed FileDescriptorProto to\n    FileDescriptor.\n\n  Python\n  * Fixed WhichOneof() to work with de-serialized protobuf messages.\n  * Fixed a missing file problem of Python C++ implementation.\n\n2014-08-15 version 2.6.0:\n\n  General\n  * Added oneofs(unions) feature. Fields in the same oneof will share\n    memory and at most one field can be set at the same time. Use the\n    oneof keyword to define a oneof like:\n      message SampleMessage {\n        oneof test_oneof {\n          string name = 4;\n          YourMessage sub_message = 9;\n        }\n      }\n  * Files, services, enums, messages, methods and enum values can be marked\n    as deprecated now.\n  * Added Support for list values, including lists of messages, when\n    parsing text-formatted protos in C++ and Java.\n      For example:  foo: [1, 2, 3]\n\n  C++\n  * Enhanced customization on TestFormat printing.\n  * Added SwapFields() in reflection API to swap a subset of fields.\n    Added SetAllocatedMessage() in reflection API.\n  * Repeated primitive extensions are now packable. The\n    [packed=true] option only affects serializers. Therefore, it is\n    possible to switch a repeated extension field to packed format\n    without breaking backwards-compatibility.\n  * Various speed optimizations.\n\n  Java\n  * writeTo() method in ByteString can now write a substring to an\n    output stream. Added endWith() method for ByteString.\n  * ByteString and ByteBuffer are now supported in CodedInputStream\n    and CodedOutputStream.\n  * java_generate_equals_and_hash can now be used with the LITE_RUNTIME.\n\n  Python\n  * A new C++-backed extension module (aka \"cpp api v2\") that replaces the\n    old (\"cpp api v1\") one.  Much faster than the pure Python code.  This one\n    resolves many bugs and is recommended for general use over the\n    pure Python when possible.\n  * Descriptors now have enum_types_by_name and extension_types_by_name dict\n    attributes.\n  * Support for Python 3.\n\n2013-02-27 version 2.5.0:\n\n  General\n  * New notion \"import public\" that allows a proto file to forward the content\n    it imports to its importers. For example,\n      // foo.proto\n      import public \"bar.proto\";\n      import \"baz.proto\";\n\n      // qux.proto\n      import \"foo.proto\";\n      // Stuff defined in bar.proto may be used in this file, but stuff from\n      // baz.proto may NOT be used without importing it explicitly.\n    This is useful for moving proto files. To move a proto file, just leave\n    a single \"import public\" in the old proto file.\n  * New enum option \"allow_alias\" that specifies whether different symbols can\n    be assigned the same numeric value. Default value is \"true\". Setting it to\n    false causes the compiler to reject enum definitions where multiple symbols\n    have the same numeric value.\n    Note: We plan to flip the default value to \"false\" in a future release.\n    Projects using enum aliases should set the option to \"true\" in their .proto\n    files.\n\n  C++\n  * New generated method set_allocated_foo(Type* foo) for message and string\n    fields. This method allows you to set the field to a pre-allocated object\n    and the containing message takes the ownership of that object.\n  * Added SetAllocatedExtension() and ReleaseExtension() to extensions API.\n  * Custom options are now formatted correctly when descriptors are printed in\n    text format.\n  * Various speed optimizations.\n\n  Java\n  * Comments in proto files are now collected and put into generated code as\n    comments for corresponding classes and data members.\n  * Added Parser to parse directly into messages without a Builder. For\n    example,\n      Foo foo = Foo.PARSER.ParseFrom(input);\n    Using Parser is ~25% faster than using Builder to parse messages.\n  * Added getters/setters to access the underlying ByteString of a string field\n    directly.\n  * ByteString now supports more operations: substring(), prepend(), and\n    append(). The implementation of ByteString uses a binary tree structure\n    to support these operations efficiently.\n  * New method findInitializationErrors() that lists all missing required\n    fields.\n  * Various code size and speed optimizations.\n\n  Python\n  * Added support for dynamic message creation. DescriptorDatabase,\n    DescriptorPool, and MessageFactory work like their C++ counterparts to\n    simplify Descriptor construction from *DescriptorProtos, and MessageFactory\n    provides a message instance from a Descriptor.\n  * Added pickle support for protobuf messages.\n  * Unknown fields are now preserved after parsing.\n  * Fixed bug where custom options were not correctly populated. Custom\n    options can be accessed now.\n  * Added EnumTypeWrapper that provides better accessibility to enum types.\n  * Added ParseMessage(descriptor, bytes) to generate a new Message instance\n    from a descriptor and a byte string.\n\n2011-05-01 version 2.4.1:\n\n  C++\n  * Fixed the friendship problem for old compilers to make the library now gcc 3\n    compatible again.\n  * Fixed vcprojects/extract_includes.bat to extract compiler/plugin.h.\n\n  Java\n  * Removed usages of JDK 1.6 only features to make the library now JDK 1.5\n    compatible again.\n  * Fixed a bug about negative enum values.\n  * serialVersionUID is now defined in generated messages for java serializing.\n  * Fixed protoc to use java.lang.Object, which makes \"Object\" now a valid\n    message name again.\n\n  Python\n  * Experimental C++ implementation now requires C++ protobuf library installed.\n    See the README.txt in the python directory for details.\n\n2011-02-02 version 2.4.0:\n\n  General\n  * The RPC (cc|java|py)_generic_services default value is now false instead of\n    true.\n  * Custom options can have aggregate types. For example,\n      message MyOption {\n        optional string comment = 1;\n        optional string author = 2;\n      }\n      extend google.protobuf.FieldOptions {\n        optional MyOption myoption = 12345;\n      }\n    This option can now be set as follows:\n      message SomeType {\n        optional int32 field = 1 [(myoption) = { comment:'x' author:'y' }];\n      }\n\n  C++\n  * Various speed and code size optimizations.\n  * Added a release_foo() method on string and message fields.\n  * Fixed gzip_output_stream sub-stream handling.\n\n  Java\n  * Builders now maintain sub-builders for sub-messages. Use getFooBuilder() to\n    get the builder for the sub-message \"foo\". This allows you to repeatedly\n    modify deeply-nested sub-messages without rebuilding them.\n  * Builder.build() no longer invalidates the Builder for generated messages\n    (You may continue to modify it and then build another message).\n  * Code generator will generate efficient equals() and hashCode()\n    implementations if new option java_generate_equals_and_hash is enabled.\n    (Otherwise, reflection-based implementations are used.)\n  * Generated messages now implement Serializable.\n  * Fields with [deprecated=true] will be marked with @Deprecated in Java.\n  * Added lazy conversion of UTF-8 encoded strings to String objects to improve\n    performance.\n  * Various optimizations.\n  * Enum value can be accessed directly, instead of calling getNumber() on the\n    enum member.\n  * For each enum value, an integer constant is also generated with the suffix\n    _VALUE.\n\n  Python\n  * Added an experimental  C++ implementation for Python messages via a Python\n    extension. Implementation type is controlled by an environment variable\n    PROTOCOL_BUFFERS_PYTHON_IMPLEMENTATION (valid values: \"cpp\" and \"python\")\n    The default value is currently \"python\" but will be changed to \"cpp\" in\n    future release.\n  * Improved performance on message instantiation significantly.\n    Most of the work on message instantiation is done just once per message\n    class, instead of once per message instance.\n  * Improved performance on text message parsing.\n  * Allow add() to forward keyword arguments to the concrete class.\n      E.g. instead of\n        item = repeated_field.add()\n        item.foo = bar\n        item.baz = quux\n      You can do:\n        repeated_field.add(foo=bar, baz=quux)\n  * Added a sort() interface to the BaseContainer.\n  * Added an extend() method to repeated composite fields.\n  * Added UTF8 debug string support.\n\n2010-01-08 version 2.3.0:\n\n  General\n  * Parsers for repeated numeric fields now always accept both packed and\n    unpacked input.  The [packed=true] option only affects serializers.\n    Therefore, it is possible to switch a field to packed format without\n    breaking backwards-compatibility -- as long as all parties are using\n    protobuf 2.3.0 or above, at least.\n  * The generic RPC service code generated by the C++, Java, and Python\n    generators can be disabled via file options:\n      option cc_generic_services = false;\n      option java_generic_services = false;\n      option py_generic_services = false;\n    This allows plugins to generate alternative code, possibly specific to some\n    particular RPC implementation.\n\n  protoc\n  * Now supports a plugin system for code generators.  Plugins can generate\n    code for new languages or inject additional code into the output of other\n    code generators.  Plugins are just binaries which accept a protocol buffer\n    on stdin and write a protocol buffer to stdout, so they may be written in\n    any language.  See src/google/protobuf/compiler/plugin.proto.\n    **WARNING**:  Plugins are experimental.  The interface may change in a\n    future version.\n  * If the output location ends in .zip or .jar, protoc will write its output\n    to a zip/jar archive instead of a directory.  For example:\n      protoc --java_out=myproto_srcs.jar --python_out=myproto.zip myproto.proto\n    Currently the archive contents are not compressed, though this could change\n    in the future.\n  * inf, -inf, and nan can now be used as default values for float and double\n    fields.\n\n  C++\n  * Various speed and code size optimizations.\n  * DynamicMessageFactory is now fully thread-safe.\n  * Message::Utf8DebugString() method is like DebugString() but avoids escaping\n    UTF-8 bytes.\n  * Compiled-in message types can now contain dynamic extensions, through use\n    of CodedInputStream::SetExtensionRegistry().\n  * Now compiles shared libraries (DLLs) by default on Cygwin and MinGW, to\n    match other platforms.  Use --disable-shared to avoid this.\n\n  Java\n  * parseDelimitedFrom() and mergeDelimitedFrom() now detect EOF and return\n    false/null instead of throwing an exception.\n  * Fixed some initialization ordering bugs.\n  * Fixes for OpenJDK 7.\n\n  Python\n  * 10-25 times faster than 2.2.0, still pure-Python.\n  * Calling a mutating method on a sub-message always instantiates the message\n    in its parent even if the mutating method doesn't actually mutate anything\n    (e.g. parsing from an empty string).\n  * Expanded descriptors a bit.\n\n2009-08-11 version 2.2.0:\n\n  C++\n  * Lite mode:  The \"optimize_for = LITE_RUNTIME\" option causes the compiler\n    to generate code which only depends libprotobuf-lite, which is much smaller\n    than libprotobuf but lacks descriptors, reflection, and some other features.\n  * Fixed bug where Message.Swap(Message) was only implemented for\n    optimize_for_speed.  Swap now properly implemented in both modes\n    (Issue 91).\n  * Added RemoveLast and SwapElements(index1, index2) to Reflection\n    interface for repeated elements.\n  * Added Swap(Message) to Reflection interface.\n  * Floating-point literals in generated code that are intended to be\n    single-precision now explicitly have 'f' suffix to avoid pedantic warnings\n    produced by some compilers.\n  * The [deprecated=true] option now causes the C++ code generator to generate\n    a GCC-style deprecation annotation (no-op on other compilers).\n  * google::protobuf::GetEnumDescriptor<SomeGeneratedEnumType>() returns the\n    EnumDescriptor for that type -- useful for templates which cannot call\n    SomeGeneratedEnumType_descriptor().\n  * Various optimizations and obscure bug fixes.\n\n  Java\n  * Lite mode:  The \"optimize_for = LITE_RUNTIME\" option causes the compiler\n    to generate code which only depends libprotobuf-lite, which is much smaller\n    than libprotobuf but lacks descriptors, reflection, and some other features.\n  * Lots of style cleanups.\n\n  Python\n  * Fixed endianness bug with floats and doubles.\n  * Text format parsing support.\n  * Fix bug with parsing packed repeated fields in embedded messages.\n  * Ability to initialize fields by passing keyword args to constructor.\n  * Support iterators in extend and __setslice__ for containers.\n\n2009-05-13 version 2.1.0:\n\n  General\n  * Repeated fields of primitive types (types other that string, group, and\n    nested messages) may now use the option [packed = true] to get a more\n    efficient encoding.  In the new encoding, the entire list is written\n    as a single byte blob using the \"length-delimited\" wire type.  Within\n    this blob, the individual values are encoded the same way they would\n    be normally except without a tag before each value (thus, they are\n    tightly \"packed\").\n  * For each field, the generated code contains an integer constant assigned\n    to the field number.  For example, the .proto file:\n      message Foo { optional int bar_baz = 123; }\n    would generate the following constants, all with the integer value 123:\n      C++:     Foo::kBarBazFieldNumber\n      Java:    Foo.BAR_BAZ_FIELD_NUMBER\n      Python:  Foo.BAR_BAZ_FIELD_NUMBER\n    Constants are also generated for extensions, with the same naming scheme.\n    These constants may be used as switch cases.\n  * Updated bundled Google Test to version 1.3.0.  Google Test is now bundled\n    in its verbatim form as a nested autoconf package, so you can drop in any\n    other version of Google Test if needed.\n  * optimize_for = SPEED is now the default, by popular demand.  Use\n    optimize_for = CODE_SIZE if code size is more important in your app.\n  * It is now an error to define a default value for a repeated field.\n    Previously, this was silently ignored (it had no effect on the generated\n    code).\n  * Fields can now be marked deprecated like:\n      optional int32 foo = 1 [deprecated = true];\n    Currently this does not have any actual effect, but in the future the code\n    generators may generate deprecation annotations in each language.\n  * Cross-compiling should now be possible using the --with-protoc option to\n    configure.  See README.txt for more info.\n\n  protoc\n  * --error_format=msvs option causes errors to be printed in Visual Studio\n    format, which should allow them to be clicked on in the build log to go\n    directly to the error location.\n  * The type name resolver will no longer resolve type names to fields.  For\n    example, this now works:\n      message Foo {}\n      message Bar {\n        optional int32 Foo = 1;\n        optional Foo baz = 2;\n      }\n    Previously, the type of \"baz\" would resolve to \"Bar.Foo\", and you'd get\n    an error because Bar.Foo is a field, not a type.  Now the type of \"baz\"\n    resolves to the message type Foo.  This change is unlikely to make a\n    difference to anyone who follows the Protocol Buffers style guide.\n\n  C++\n  * Several optimizations, including but not limited to:\n    - Serialization, especially to flat arrays, is 10%-50% faster, possibly\n      more for small objects.\n    - Several descriptor operations which previously required locking no longer\n      do.\n    - Descriptors are now constructed lazily on first use, rather than at\n      process startup time.  This should save memory in programs which do not\n      use descriptors or reflection.\n    - UnknownFieldSet completely redesigned to be more efficient (especially in\n      terms of memory usage).\n    - Various optimizations to reduce code size (though the serialization speed\n      optimizations increased code size).\n  * Message interface has method ParseFromBoundedZeroCopyStream() which parses\n    a limited number of bytes from an input stream rather than parsing until\n    EOF.\n  * GzipInputStream and GzipOutputStream support reading/writing gzip- or\n    zlib-compressed streams if zlib is available.\n    (google/protobuf/io/gzip_stream.h)\n  * DescriptorPool::FindAllExtensions() and corresponding\n    DescriptorDatabase::FindAllExtensions() can be used to enumerate all\n    extensions of a given type.\n  * For each enum type Foo, protoc will generate functions:\n      const string& Foo_Name(Foo value);\n      bool Foo_Parse(const string& name, Foo* result);\n    The former returns the name of the enum constant corresponding to the given\n    value while the latter finds the value corresponding to a name.\n  * RepeatedField and RepeatedPtrField now have back-insertion iterators.\n  * String fields now have setters that take a char* and a size, in addition\n    to the existing ones that took char* or const string&.\n  * DescriptorPool::AllowUnknownDependencies() may be used to tell\n    DescriptorPool to create placeholder descriptors for unknown entities\n    referenced in a FileDescriptorProto.  This can allow you to parse a .proto\n    file without having access to other .proto files that it imports, for\n    example.\n  * Updated gtest to latest version.  The gtest package is now included as a\n    nested autoconf package, so it should be able to drop new versions into the\n    \"gtest\" subdirectory without modification.\n\n  Java\n  * Fixed bug where Message.mergeFrom(Message) failed to merge extensions.\n  * Message interface has new method toBuilder() which is equivalent to\n    newBuilderForType().mergeFrom(this).\n  * All enums now implement the ProtocolMessageEnum interface.\n  * Setting a field to null now throws NullPointerException.\n  * Fixed tendency for TextFormat's parsing to overflow the stack when\n    parsing large string values.  The underlying problem is with Java's\n    regex implementation (which unfortunately uses recursive backtracking\n    rather than building an NFA).  Worked around by making use of possessive\n    quantifiers.\n  * Generated service classes now also generate pure interfaces.  For a service\n    Foo, Foo.Interface is a pure interface containing all of the service's\n    defined methods.  Foo.newReflectiveService() can be called to wrap an\n    instance of this interface in a class that implements the generic\n    RpcService interface, which provides reflection support that is usually\n    needed by RPC server implementations.\n  * RPC interfaces now support blocking operation in addition to non-blocking.\n    The protocol compiler generates separate blocking and non-blocking stubs\n    which operate against separate blocking and non-blocking RPC interfaces.\n    RPC implementations will have to implement the new interfaces in order to\n    support blocking mode.\n  * New I/O methods parseDelimitedFrom(), mergeDelimitedFrom(), and\n    writeDelimitedTo() read and write \"delimited\" messages from/to a stream,\n    meaning that the message size precedes the data.  This way, you can write\n    multiple messages to a stream without having to worry about delimiting\n    them yourself.\n  * Throw a more descriptive exception when build() is double-called.\n  * Add a method to query whether CodedInputStream is at the end of the input\n    stream.\n  * Add a method to reset a CodedInputStream's size counter; useful when\n    reading many messages with the same stream.\n  * equals() and hashCode() now account for unknown fields.\n\n  Python\n  * Added slicing support for repeated scalar fields. Added slice retrieval and\n    removal of repeated composite fields.\n  * Updated RPC interfaces to allow for blocking operation.  A client may\n    now pass None for a callback when making an RPC, in which case the\n    call will block until the response is received, and the response\n    object will be returned directly to the caller.  This interface change\n    cannot be used in practice until RPC implementations are updated to\n    implement it.\n  * Changes to input_stream.py should make protobuf compatible with appengine.\n\n2008-11-25 version 2.0.3:\n\n  protoc\n  * Enum values may now have custom options, using syntax similar to field\n    options.\n  * Fixed bug where .proto files which use custom options but don't actually\n    define them (i.e. they import another .proto file defining the options)\n    had to explicitly import descriptor.proto.\n  * Adjacent string literals in .proto files will now be concatenated, like in\n    C.\n  * If an input file is a Windows absolute path (e.g. \"C:\\foo\\bar.proto\") and\n    the import path only contains \".\" (or contains \".\" but does not contain\n    the file), protoc incorrectly thought that the file was under \".\", because\n    it thought that the path was relative (since it didn't start with a slash).\n    This has been fixed.\n\n  C++\n  * Generated message classes now have a Swap() method which efficiently swaps\n    the contents of two objects.\n  * All message classes now have a SpaceUsed() method which returns an estimate\n    of the number of bytes of allocated memory currently owned by the object.\n    This is particularly useful when you are reusing a single message object\n    to improve performance but want to make sure it doesn't bloat up too large.\n  * New method Message::SerializeAsString() returns a string containing the\n    serialized data.  May be more convenient than calling\n    SerializeToString(string*).\n  * In debug mode, log error messages when string-type fields are found to\n    contain bytes that are not valid UTF-8.\n  * Fixed bug where a message with multiple extension ranges couldn't parse\n    extensions.\n  * Fixed bug where MergeFrom(const Message&) didn't do anything if invoked on\n    a message that contained no fields (but possibly contained extensions).\n  * Fixed ShortDebugString() to not be O(n^2).  Durr.\n  * Fixed crash in TextFormat parsing if the first token in the input caused a\n    tokenization error.\n  * Fixed obscure bugs in zero_copy_stream_impl.cc.\n  * Added support for HP C++ on Tru64.\n  * Only build tests on \"make check\", not \"make\".\n  * Fixed alignment issue that caused crashes when using DynamicMessage on\n    64-bit Sparc machines.\n  * Simplify template usage to work with MSVC 2003.\n  * Work around GCC 4.3.x x86_64 compiler bug that caused crashes on startup.\n    (This affected Fedora 9 in particular.)\n  * Now works on \"Solaris 10 using recent Sun Studio\".\n\n  Java\n  * New overload of mergeFrom() which parses a slice of a byte array instead\n    of the whole thing.\n  * New method ByteString.asReadOnlyByteBuffer() does what it sounds like.\n  * Improved performance of isInitialized() when optimizing for code size.\n\n  Python\n  * Corrected ListFields() signature in Message base class to match what\n    subclasses actually implement.\n  * Some minor refactoring.\n  * Don't pass self as first argument to superclass constructor (no longer\n    allowed in Python 2.6).\n\n2008-09-29 version 2.0.2:\n\n  General\n  * License changed from Apache 2.0 to 3-Clause BSD.\n  * It is now possible to define custom \"options\", which are basically\n    annotations which may be placed on definitions in a .proto file.\n    For example, you might define a field option called \"foo\" like so:\n      import \"google/protobuf/descriptor.proto\"\n      extend google.protobuf.FieldOptions {\n        optional string foo = 12345;\n      }\n    Then you annotate a field using the \"foo\" option:\n      message MyMessage {\n        optional int32 some_field = 1 [(foo) = \"bar\"]\n      }\n    The value of this option is then visible via the message's\n    Descriptor:\n      const FieldDescriptor* field =\n        MyMessage::descriptor()->FindFieldByName(\"some_field\");\n      assert(field->options().GetExtension(foo) == \"bar\");\n    This feature has been implemented and tested in C++ and Java.\n    Other languages may or may not need to do extra work to support\n    custom options, depending on how they construct descriptors.\n\n  C++\n  * Fixed some GCC warnings that only occur when using -pedantic.\n  * Improved static initialization code, making ordering more\n    predictable among other things.\n  * TextFormat will no longer accept messages which contain multiple\n    instances of a singular field.  Previously, the latter instance\n    would overwrite the former.\n  * Now works on systems that don't have hash_map.\n\n  Java\n  * Print @Override annotation in generated code where appropriate.\n\n  Python\n  * Strings now use the \"unicode\" type rather than the \"str\" type.\n    String fields may still be assigned ASCII \"str\" values; they will\n    automatically be converted.\n  * Adding a property to an object representing a repeated field now\n    raises an exception.  For example:\n      # No longer works (and never should have).\n      message.some_repeated_field.foo = 1\n\n  Windows\n  * We now build static libraries rather than DLLs by default on MSVC.\n    See vsprojects/readme.txt for more information.\n\n2008-08-15 version 2.0.1:\n\n  protoc\n  * New flags --encode and --decode can be used to convert between protobuf text\n    format and binary format from the command-line.\n  * New flag --descriptor_set_out can be used to write FileDescriptorProtos for\n    all parsed files directly into a single output file.  This is particularly\n    useful if you wish to parse .proto files from programs written in languages\n    other than C++: just run protoc as a background process and have it output\n    a FileDescriptorList, then parse that natively.\n  * Improved error message when an enum value's name conflicts with another\n    symbol defined in the enum type's scope, e.g. if two enum types declared\n    in the same scope have values with the same name.  This is disallowed for\n    compatibility with C++, but this wasn't clear from the error.\n  * Fixed absolute output paths on Windows.\n  * Allow trailing slashes in --proto_path mappings.\n\n  C++\n  * Reflection objects are now per-class rather than per-instance.  To make this\n    possible, the Reflection interface had to be changed such that all methods\n    take the Message instance as a parameter.  This change improves performance\n    significantly in memory-bandwidth-limited use cases, since it makes the\n    message objects smaller.  Note that source-incompatible interface changes\n    like this will not be made again after the library leaves beta.\n  * Heuristically detect sub-messages when printing unknown fields.\n  * Fix static initialization ordering bug that caused crashes at startup when\n    compiling on Mac with static linking.\n  * Fixed TokenizerTest when compiling with -DNDEBUG on Linux.\n  * Fixed incorrect definition of kint32min.\n  * Fix bytes type setter to work with byte sequences with embedded NULLs.\n  * Other irrelevant tweaks.\n\n  Java\n  * Fixed UnknownFieldSet's parsing of varints larger than 32 bits.\n  * Fixed TextFormat's parsing of \"inf\" and \"nan\".\n  * Fixed TextFormat's parsing of comments.\n  * Added info to Java POM that will be required when we upload the\n    package to a Maven repo.\n\n  Python\n  * MergeFrom(message) and CopyFrom(message) are now implemented.\n  * SerializeToString() raises an exception if the message is missing required\n    fields.\n  * Code organization improvements.\n  * Fixed doc comments for RpcController and RpcChannel, which had somehow been\n    swapped.\n  * Fixed text_format_test on Windows where floating-point exponents sometimes\n    contain extra zeros.\n  * Fix Python service CallMethod() implementation.\n\n  Other\n  * Improved readmes.\n  * VIM syntax highlighting improvements.\n\n2008-07-07 version 2.0.0:\n\n  * First public release.\n", "// Protocol Buffers - Google's data interchange format\n// Copyright 2008 Google Inc.  All rights reserved.\n// https://developers.google.com/protocol-buffers/\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\npackage com.google.protobuf;\n\nimport com.google.protobuf.Descriptors.Descriptor;\nimport com.google.protobuf.Descriptors.FieldDescriptor;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.TreeMap;\n\n/**\n * Reflection utility methods shared by both mutable and immutable messages.\n *\n * @author liujisi@google.com (Pherl Liu)\n */\nclass MessageReflection {\n\n  static void writeMessageTo(\n      Message message,\n      Map<FieldDescriptor, Object> fields,\n      CodedOutputStream output,\n      boolean alwaysWriteRequiredFields)\n      throws IOException {\n    final boolean isMessageSet =\n        message.getDescriptorForType().getOptions().getMessageSetWireFormat();\n    if (alwaysWriteRequiredFields) {\n      fields = new TreeMap<FieldDescriptor, Object>(fields);\n      for (final FieldDescriptor field : message.getDescriptorForType().getFields()) {\n        if (field.isRequired() && !fields.containsKey(field)) {\n          fields.put(field, message.getField(field));\n        }\n      }\n    }\n    for (final Map.Entry<Descriptors.FieldDescriptor, Object> entry : fields.entrySet()) {\n      final Descriptors.FieldDescriptor field = entry.getKey();\n      final Object value = entry.getValue();\n      if (isMessageSet\n          && field.isExtension()\n          && field.getType() == Descriptors.FieldDescriptor.Type.MESSAGE\n          && !field.isRepeated()) {\n        output.writeMessageSetExtension(field.getNumber(), (Message) value);\n      } else {\n        FieldSet.writeField(field, value, output);\n      }\n    }\n\n    final UnknownFieldSet unknownFields = message.getUnknownFields();\n    if (isMessageSet) {\n      unknownFields.writeAsMessageSetTo(output);\n    } else {\n      unknownFields.writeTo(output);\n    }\n  }\n\n  static int getSerializedSize(Message message, Map<FieldDescriptor, Object> fields) {\n    int size = 0;\n    final boolean isMessageSet =\n        message.getDescriptorForType().getOptions().getMessageSetWireFormat();\n\n    for (final Map.Entry<Descriptors.FieldDescriptor, Object> entry : fields.entrySet()) {\n      final Descriptors.FieldDescriptor field = entry.getKey();\n      final Object value = entry.getValue();\n      if (isMessageSet\n          && field.isExtension()\n          && field.getType() == Descriptors.FieldDescriptor.Type.MESSAGE\n          && !field.isRepeated()) {\n        size +=\n            CodedOutputStream.computeMessageSetExtensionSize(field.getNumber(), (Message) value);\n      } else {\n        size += FieldSet.computeFieldSize(field, value);\n      }\n    }\n\n    final UnknownFieldSet unknownFields = message.getUnknownFields();\n    if (isMessageSet) {\n      size += unknownFields.getSerializedSizeAsMessageSet();\n    } else {\n      size += unknownFields.getSerializedSize();\n    }\n    return size;\n  }\n\n  static String delimitWithCommas(List<String> parts) {\n    StringBuilder result = new StringBuilder();\n    for (String part : parts) {\n      if (result.length() > 0) {\n        result.append(\", \");\n      }\n      result.append(part);\n    }\n    return result.toString();\n  }\n\n  @SuppressWarnings(\"unchecked\")\n  static boolean isInitialized(MessageOrBuilder message) {\n    // Check that all required fields are present.\n    for (final Descriptors.FieldDescriptor field : message.getDescriptorForType().getFields()) {\n      if (field.isRequired()) {\n        if (!message.hasField(field)) {\n          return false;\n        }\n      }\n    }\n\n    // Check that embedded messages are initialized.\n    for (final Map.Entry<Descriptors.FieldDescriptor, Object> entry :\n        message.getAllFields().entrySet()) {\n      final Descriptors.FieldDescriptor field = entry.getKey();\n      if (field.getJavaType() == Descriptors.FieldDescriptor.JavaType.MESSAGE) {\n        if (field.isRepeated()) {\n          for (final Message element : (List<Message>) entry.getValue()) {\n            if (!element.isInitialized()) {\n              return false;\n            }\n          }\n        } else {\n          if (!((Message) entry.getValue()).isInitialized()) {\n            return false;\n          }\n        }\n      }\n    }\n\n    return true;\n  }\n\n  private static String subMessagePrefix(\n      final String prefix, final Descriptors.FieldDescriptor field, final int index) {\n    final StringBuilder result = new StringBuilder(prefix);\n    if (field.isExtension()) {\n      result.append('(').append(field.getFullName()).append(')');\n    } else {\n      result.append(field.getName());\n    }\n    if (index != -1) {\n      result.append('[').append(index).append(']');\n    }\n    result.append('.');\n    return result.toString();\n  }\n\n  private static void findMissingFields(\n      final MessageOrBuilder message, final String prefix, final List<String> results) {\n    for (final Descriptors.FieldDescriptor field : message.getDescriptorForType().getFields()) {\n      if (field.isRequired() && !message.hasField(field)) {\n        results.add(prefix + field.getName());\n      }\n    }\n\n    for (final Map.Entry<Descriptors.FieldDescriptor, Object> entry :\n        message.getAllFields().entrySet()) {\n      final Descriptors.FieldDescriptor field = entry.getKey();\n      final Object value = entry.getValue();\n\n      if (field.getJavaType() == Descriptors.FieldDescriptor.JavaType.MESSAGE) {\n        if (field.isRepeated()) {\n          int i = 0;\n          for (final Object element : (List) value) {\n            findMissingFields(\n                (MessageOrBuilder) element, subMessagePrefix(prefix, field, i++), results);\n          }\n        } else {\n          if (message.hasField(field)) {\n            findMissingFields(\n                (MessageOrBuilder) value, subMessagePrefix(prefix, field, -1), results);\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Populates {@code this.missingFields} with the full \"path\" of each missing required field in the\n   * given message.\n   */\n  static List<String> findMissingFields(final MessageOrBuilder message) {\n    final List<String> results = new ArrayList<String>();\n    findMissingFields(message, \"\", results);\n    return results;\n  }\n\n  static interface MergeTarget {\n    enum ContainerType {\n      MESSAGE,\n      EXTENSION_SET\n    }\n\n    /** Returns the descriptor for the target. */\n    public Descriptors.Descriptor getDescriptorForType();\n\n    public ContainerType getContainerType();\n\n    public ExtensionRegistry.ExtensionInfo findExtensionByName(\n        ExtensionRegistry registry, String name);\n\n    public ExtensionRegistry.ExtensionInfo findExtensionByNumber(\n        ExtensionRegistry registry, Descriptors.Descriptor containingType, int fieldNumber);\n\n    /**\n     * Obtains the value of the given field, or the default value if it is not set. For primitive\n     * fields, the boxed primitive value is returned. For enum fields, the EnumValueDescriptor for\n     * the value is returned. For embedded message fields, the sub-message is returned. For repeated\n     * fields, a java.util.List is returned.\n     */\n    public Object getField(Descriptors.FieldDescriptor field);\n\n    /**\n     * Returns true if the given field is set. This is exactly equivalent to calling the generated\n     * \"has\" accessor method corresponding to the field.\n     *\n     * @throws IllegalArgumentException The field is a repeated field, or {@code\n     *     field.getContainingType() != getDescriptorForType()}.\n     */\n    boolean hasField(Descriptors.FieldDescriptor field);\n\n    /**\n     * Sets a field to the given value. The value must be of the correct type for this field, i.e.\n     * the same type that {@link Message#getField(Descriptors.FieldDescriptor)} would return.\n     */\n    MergeTarget setField(Descriptors.FieldDescriptor field, Object value);\n\n    /**\n     * Clears the field. This is exactly equivalent to calling the generated \"clear\" accessor method\n     * corresponding to the field.\n     */\n    MergeTarget clearField(Descriptors.FieldDescriptor field);\n\n    /**\n     * Sets an element of a repeated field to the given value. The value must be of the correct type\n     * for this field, i.e. the same type that {@link\n     * Message#getRepeatedField(Descriptors.FieldDescriptor, int)} would return.\n     *\n     * @throws IllegalArgumentException The field is not a repeated field, or {@code\n     *     field.getContainingType() != getDescriptorForType()}.\n     */\n    MergeTarget setRepeatedField(Descriptors.FieldDescriptor field, int index, Object value);\n\n    /**\n     * Like {@code setRepeatedField}, but appends the value as a new element.\n     *\n     * @throws IllegalArgumentException The field is not a repeated field, or {@code\n     *     field.getContainingType() != getDescriptorForType()}.\n     */\n    MergeTarget addRepeatedField(Descriptors.FieldDescriptor field, Object value);\n\n    /**\n     * Returns true if the given oneof is set.\n     *\n     * @throws IllegalArgumentException if {@code oneof.getContainingType() !=\n     *     getDescriptorForType()}.\n     */\n    boolean hasOneof(Descriptors.OneofDescriptor oneof);\n\n    /**\n     * Clears the oneof. This is exactly equivalent to calling the generated \"clear\" accessor method\n     * corresponding to the oneof.\n     */\n    MergeTarget clearOneof(Descriptors.OneofDescriptor oneof);\n\n    /** Obtains the FieldDescriptor if the given oneof is set. Returns null if no field is set. */\n    Descriptors.FieldDescriptor getOneofFieldDescriptor(Descriptors.OneofDescriptor oneof);\n\n    /**\n     * Parse the input stream into a sub field group defined based on either FieldDescriptor or the\n     * default instance.\n     */\n    Object parseGroup(\n        CodedInputStream input,\n        ExtensionRegistryLite registry,\n        Descriptors.FieldDescriptor descriptor,\n        Message defaultInstance)\n        throws IOException;\n\n    /**\n     * Parse the input stream into a sub field message defined based on either FieldDescriptor or\n     * the default instance.\n     */\n    Object parseMessage(\n        CodedInputStream input,\n        ExtensionRegistryLite registry,\n        Descriptors.FieldDescriptor descriptor,\n        Message defaultInstance)\n        throws IOException;\n\n    /**\n     * Parse from a ByteString into a sub field message defined based on either FieldDescriptor or\n     * the default instance. There isn't a varint indicating the length of the message at the\n     * beginning of the input ByteString.\n     */\n    Object parseMessageFromBytes(\n        ByteString bytes,\n        ExtensionRegistryLite registry,\n        Descriptors.FieldDescriptor descriptor,\n        Message defaultInstance)\n        throws IOException;\n\n    /**\n     * Read the given group field from the wire, merging with the existing field if it is already\n     * present.\n     *\n     * <p>For extensions, defaultInstance must be specified. For regular fields, defaultInstance can\n     * be null.\n     */\n    void mergeGroup(\n        CodedInputStream input,\n        ExtensionRegistryLite extensionRegistry,\n        FieldDescriptor field,\n        Message defaultInstance)\n        throws IOException;\n\n    /**\n     * Read the given message field from the wire, merging with the existing field if it is already\n     * present.\n     *\n     * <p>For extensions, defaultInstance must be specified. For regular fields, defaultInstance can\n     * be null.\n     */\n    void mergeMessage(\n        CodedInputStream input,\n        ExtensionRegistryLite extensionRegistry,\n        FieldDescriptor field,\n        Message defaultInstance)\n        throws IOException;\n\n    /** Returns the UTF8 validation level for the field. */\n    WireFormat.Utf8Validation getUtf8Validation(Descriptors.FieldDescriptor descriptor);\n\n    /**\n     * Returns a new merge target for a sub-field. When defaultInstance is provided, it indicates\n     * the descriptor is for an extension type, and implementations should create a new instance\n     * from the defaultInstance prototype directly.\n     */\n    MergeTarget newMergeTargetForField(\n        Descriptors.FieldDescriptor descriptor, Message defaultInstance);\n\n    /**\n     * Returns an empty merge target for a sub-field. When defaultInstance is provided, it indicates\n     * the descriptor is for an extension type, and implementations should create a new instance\n     * from the defaultInstance prototype directly.\n     */\n    MergeTarget newEmptyTargetForField(\n        Descriptors.FieldDescriptor descriptor, Message defaultInstance);\n\n    /** Finishes the merge and returns the underlying object. */\n    Object finish();\n  }\n\n  static class BuilderAdapter implements MergeTarget {\n\n    private final Message.Builder builder;\n\n    @Override\n    public Descriptors.Descriptor getDescriptorForType() {\n      return builder.getDescriptorForType();\n    }\n\n    public BuilderAdapter(Message.Builder builder) {\n      this.builder = builder;\n    }\n\n    @Override\n    public Object getField(Descriptors.FieldDescriptor field) {\n      return builder.getField(field);\n    }\n\n    @Override\n    public boolean hasField(Descriptors.FieldDescriptor field) {\n      return builder.hasField(field);\n    }\n\n    @Override\n    public MergeTarget setField(Descriptors.FieldDescriptor field, Object value) {\n      builder.setField(field, value);\n      return this;\n    }\n\n    @Override\n    public MergeTarget clearField(Descriptors.FieldDescriptor field) {\n      builder.clearField(field);\n      return this;\n    }\n\n    @Override\n    public MergeTarget setRepeatedField(\n        Descriptors.FieldDescriptor field, int index, Object value) {\n      builder.setRepeatedField(field, index, value);\n      return this;\n    }\n\n    @Override\n    public MergeTarget addRepeatedField(Descriptors.FieldDescriptor field, Object value) {\n      builder.addRepeatedField(field, value);\n      return this;\n    }\n\n    @Override\n    public boolean hasOneof(Descriptors.OneofDescriptor oneof) {\n      return builder.hasOneof(oneof);\n    }\n\n    @Override\n    public MergeTarget clearOneof(Descriptors.OneofDescriptor oneof) {\n      builder.clearOneof(oneof);\n      return this;\n    }\n\n    @Override\n    public Descriptors.FieldDescriptor getOneofFieldDescriptor(Descriptors.OneofDescriptor oneof) {\n      return builder.getOneofFieldDescriptor(oneof);\n    }\n\n    @Override\n    public ContainerType getContainerType() {\n      return ContainerType.MESSAGE;\n    }\n\n    @Override\n    public ExtensionRegistry.ExtensionInfo findExtensionByName(\n        ExtensionRegistry registry, String name) {\n      return registry.findImmutableExtensionByName(name);\n    }\n\n    @Override\n    public ExtensionRegistry.ExtensionInfo findExtensionByNumber(\n        ExtensionRegistry registry, Descriptors.Descriptor containingType, int fieldNumber) {\n      return registry.findImmutableExtensionByNumber(containingType, fieldNumber);\n    }\n\n    @Override\n    public Object parseGroup(\n        CodedInputStream input,\n        ExtensionRegistryLite extensionRegistry,\n        Descriptors.FieldDescriptor field,\n        Message defaultInstance)\n        throws IOException {\n      Message.Builder subBuilder;\n      // When default instance is not null. The field is an extension field.\n      if (defaultInstance != null) {\n        subBuilder = defaultInstance.newBuilderForType();\n      } else {\n        subBuilder = builder.newBuilderForField(field);\n      }\n      if (!field.isRepeated()) {\n        Message originalMessage = (Message) getField(field);\n        if (originalMessage != null) {\n          subBuilder.mergeFrom(originalMessage);\n        }\n      }\n      input.readGroup(field.getNumber(), subBuilder, extensionRegistry);\n      return subBuilder.buildPartial();\n    }\n\n    @Override\n    public Object parseMessage(\n        CodedInputStream input,\n        ExtensionRegistryLite extensionRegistry,\n        Descriptors.FieldDescriptor field,\n        Message defaultInstance)\n        throws IOException {\n      Message.Builder subBuilder;\n      // When default instance is not null. The field is an extension field.\n      if (defaultInstance != null) {\n        subBuilder = defaultInstance.newBuilderForType();\n      } else {\n        subBuilder = builder.newBuilderForField(field);\n      }\n      if (!field.isRepeated()) {\n        Message originalMessage = (Message) getField(field);\n        if (originalMessage != null) {\n          subBuilder.mergeFrom(originalMessage);\n        }\n      }\n      input.readMessage(subBuilder, extensionRegistry);\n      return subBuilder.buildPartial();\n    }\n\n    @Override\n    public Object parseMessageFromBytes(\n        ByteString bytes,\n        ExtensionRegistryLite extensionRegistry,\n        Descriptors.FieldDescriptor field,\n        Message defaultInstance)\n        throws IOException {\n      Message.Builder subBuilder;\n      // When default instance is not null. The field is an extension field.\n      if (defaultInstance != null) {\n        subBuilder = defaultInstance.newBuilderForType();\n      } else {\n        subBuilder = builder.newBuilderForField(field);\n      }\n      if (!field.isRepeated()) {\n        Message originalMessage = (Message) getField(field);\n        if (originalMessage != null) {\n          subBuilder.mergeFrom(originalMessage);\n        }\n      }\n      subBuilder.mergeFrom(bytes, extensionRegistry);\n      return subBuilder.buildPartial();\n    }\n\n    @Override\n    public void mergeGroup(\n        CodedInputStream input,\n        ExtensionRegistryLite extensionRegistry,\n        FieldDescriptor field,\n        Message defaultInstance)\n        throws IOException {\n      if (!field.isRepeated()) {\n        if (hasField(field)) {\n          input.readGroup(field.getNumber(), builder.getFieldBuilder(field), extensionRegistry);\n          return;\n        }\n        Message.Builder subBuilder = newMessageFieldInstance(field, defaultInstance);\n        input.readGroup(field.getNumber(), subBuilder, extensionRegistry);\n        Object unused = setField(field, subBuilder.buildPartial());\n      } else {\n        Message.Builder subBuilder = newMessageFieldInstance(field, defaultInstance);\n        input.readGroup(field.getNumber(), subBuilder, extensionRegistry);\n        Object unused = addRepeatedField(field, subBuilder.buildPartial());\n      }\n    }\n\n    @Override\n    public void mergeMessage(\n        CodedInputStream input,\n        ExtensionRegistryLite extensionRegistry,\n        Descriptors.FieldDescriptor field,\n        Message defaultInstance)\n        throws IOException {\n      if (!field.isRepeated()) {\n        if (hasField(field)) {\n          input.readMessage(builder.getFieldBuilder(field), extensionRegistry);\n          return;\n        }\n        Message.Builder subBuilder = newMessageFieldInstance(field, defaultInstance);\n        input.readMessage(subBuilder, extensionRegistry);\n        Object unused = setField(field, subBuilder.buildPartial());\n      } else {\n        Message.Builder subBuilder = newMessageFieldInstance(field, defaultInstance);\n        input.readMessage(subBuilder, extensionRegistry);\n        Object unused = addRepeatedField(field, subBuilder.buildPartial());\n      }\n    }\n\n    private Message.Builder newMessageFieldInstance(\n        FieldDescriptor field, Message defaultInstance) {\n      // When default instance is not null. The field is an extension field.\n      if (defaultInstance != null) {\n        return defaultInstance.newBuilderForType();\n      } else {\n        return builder.newBuilderForField(field);\n      }\n    }\n\n    @Override\n    public MergeTarget newMergeTargetForField(\n        Descriptors.FieldDescriptor field, Message defaultInstance) {\n      Message.Builder subBuilder;\n      if (defaultInstance != null) {\n        subBuilder = defaultInstance.newBuilderForType();\n      } else {\n        subBuilder = builder.newBuilderForField(field);\n      }\n      if (!field.isRepeated()) {\n        Message originalMessage = (Message) getField(field);\n        if (originalMessage != null) {\n          subBuilder.mergeFrom(originalMessage);\n        }\n      }\n      return new BuilderAdapter(subBuilder);\n    }\n\n    @Override\n    public MergeTarget newEmptyTargetForField(\n        Descriptors.FieldDescriptor field, Message defaultInstance) {\n      Message.Builder subBuilder;\n      if (defaultInstance != null) {\n        subBuilder = defaultInstance.newBuilderForType();\n      } else {\n        subBuilder = builder.newBuilderForField(field);\n      }\n      return new BuilderAdapter(subBuilder);\n    }\n\n    @Override\n    public WireFormat.Utf8Validation getUtf8Validation(Descriptors.FieldDescriptor descriptor) {\n      if (descriptor.needsUtf8Check()) {\n        return WireFormat.Utf8Validation.STRICT;\n      }\n      // TODO(liujisi): support lazy strings for repeated fields.\n      if (!descriptor.isRepeated() && builder instanceof GeneratedMessage.Builder) {\n        return WireFormat.Utf8Validation.LAZY;\n      }\n      return WireFormat.Utf8Validation.LOOSE;\n    }\n\n    @Override\n    public Object finish() {\n      return builder.buildPartial();\n    }\n  }\n\n\n  static class ExtensionAdapter implements MergeTarget {\n\n    private final FieldSet<Descriptors.FieldDescriptor> extensions;\n\n    ExtensionAdapter(FieldSet<Descriptors.FieldDescriptor> extensions) {\n      this.extensions = extensions;\n    }\n\n    @Override\n    public Descriptors.Descriptor getDescriptorForType() {\n      throw new UnsupportedOperationException(\"getDescriptorForType() called on FieldSet object\");\n    }\n\n    @Override\n    public Object getField(Descriptors.FieldDescriptor field) {\n      return extensions.getField(field);\n    }\n\n    @Override\n    public boolean hasField(Descriptors.FieldDescriptor field) {\n      return extensions.hasField(field);\n    }\n\n    @Override\n    public MergeTarget setField(Descriptors.FieldDescriptor field, Object value) {\n      extensions.setField(field, value);\n      return this;\n    }\n\n    @Override\n    public MergeTarget clearField(Descriptors.FieldDescriptor field) {\n      extensions.clearField(field);\n      return this;\n    }\n\n    @Override\n    public MergeTarget setRepeatedField(\n        Descriptors.FieldDescriptor field, int index, Object value) {\n      extensions.setRepeatedField(field, index, value);\n      return this;\n    }\n\n    @Override\n    public MergeTarget addRepeatedField(Descriptors.FieldDescriptor field, Object value) {\n      extensions.addRepeatedField(field, value);\n      return this;\n    }\n\n    @Override\n    public boolean hasOneof(Descriptors.OneofDescriptor oneof) {\n      return false;\n    }\n\n    @Override\n    public MergeTarget clearOneof(Descriptors.OneofDescriptor oneof) {\n      // Nothing to clear.\n      return this;\n    }\n\n    @Override\n    public Descriptors.FieldDescriptor getOneofFieldDescriptor(Descriptors.OneofDescriptor oneof) {\n      return null;\n    }\n\n    @Override\n    public ContainerType getContainerType() {\n      return ContainerType.EXTENSION_SET;\n    }\n\n    @Override\n    public ExtensionRegistry.ExtensionInfo findExtensionByName(\n        ExtensionRegistry registry, String name) {\n      return registry.findImmutableExtensionByName(name);\n    }\n\n    @Override\n    public ExtensionRegistry.ExtensionInfo findExtensionByNumber(\n        ExtensionRegistry registry, Descriptors.Descriptor containingType, int fieldNumber) {\n      return registry.findImmutableExtensionByNumber(containingType, fieldNumber);\n    }\n\n    @Override\n    public Object parseGroup(\n        CodedInputStream input,\n        ExtensionRegistryLite registry,\n        Descriptors.FieldDescriptor field,\n        Message defaultInstance)\n        throws IOException {\n      Message.Builder subBuilder = defaultInstance.newBuilderForType();\n      if (!field.isRepeated()) {\n        Message originalMessage = (Message) getField(field);\n        if (originalMessage != null) {\n          subBuilder.mergeFrom(originalMessage);\n        }\n      }\n      input.readGroup(field.getNumber(), subBuilder, registry);\n      return subBuilder.buildPartial();\n    }\n\n    @Override\n    public Object parseMessage(\n        CodedInputStream input,\n        ExtensionRegistryLite registry,\n        Descriptors.FieldDescriptor field,\n        Message defaultInstance)\n        throws IOException {\n      Message.Builder subBuilder = defaultInstance.newBuilderForType();\n      if (!field.isRepeated()) {\n        Message originalMessage = (Message) getField(field);\n        if (originalMessage != null) {\n          subBuilder.mergeFrom(originalMessage);\n        }\n      }\n      input.readMessage(subBuilder, registry);\n      return subBuilder.buildPartial();\n    }\n\n    @Override\n    public void mergeGroup(\n        CodedInputStream input,\n        ExtensionRegistryLite extensionRegistry,\n        FieldDescriptor field,\n        Message defaultInstance)\n        throws IOException {\n      if (!field.isRepeated()) {\n        if (hasField(field)) {\n          MessageLite.Builder current = ((MessageLite) getField(field)).toBuilder();\n          input.readGroup(field.getNumber(), current, extensionRegistry);\n          Object unused = setField(field, current.buildPartial());\n          return;\n        }\n        Message.Builder subBuilder = defaultInstance.newBuilderForType();\n        input.readGroup(field.getNumber(), subBuilder, extensionRegistry);\n        Object unused = setField(field, subBuilder.buildPartial());\n      } else {\n        Message.Builder subBuilder = defaultInstance.newBuilderForType();\n        input.readGroup(field.getNumber(), subBuilder, extensionRegistry);\n        Object unused = addRepeatedField(field, subBuilder.buildPartial());\n      }\n    }\n\n    @Override\n    public void mergeMessage(\n        CodedInputStream input,\n        ExtensionRegistryLite extensionRegistry,\n        FieldDescriptor field,\n        Message defaultInstance)\n        throws IOException {\n      if (!field.isRepeated()) {\n        if (hasField(field)) {\n          MessageLite.Builder current = ((MessageLite) getField(field)).toBuilder();\n          input.readMessage(current, extensionRegistry);\n          Object unused = setField(field, current.buildPartial());\n          return;\n        }\n        Message.Builder subBuilder = defaultInstance.newBuilderForType();\n        input.readMessage(subBuilder, extensionRegistry);\n        Object unused = setField(field, subBuilder.buildPartial());\n      } else {\n        Message.Builder subBuilder = defaultInstance.newBuilderForType();\n        input.readMessage(subBuilder, extensionRegistry);\n        Object unused = addRepeatedField(field, subBuilder.buildPartial());\n      }\n    }\n\n    @Override\n    public Object parseMessageFromBytes(\n        ByteString bytes,\n        ExtensionRegistryLite registry,\n        Descriptors.FieldDescriptor field,\n        Message defaultInstance)\n        throws IOException {\n      Message.Builder subBuilder = defaultInstance.newBuilderForType();\n      if (!field.isRepeated()) {\n        Message originalMessage = (Message) getField(field);\n        if (originalMessage != null) {\n          subBuilder.mergeFrom(originalMessage);\n        }\n      }\n      subBuilder.mergeFrom(bytes, registry);\n      return subBuilder.buildPartial();\n    }\n\n    @Override\n    public MergeTarget newMergeTargetForField(\n        Descriptors.FieldDescriptor descriptor, Message defaultInstance) {\n      throw new UnsupportedOperationException(\"newMergeTargetForField() called on FieldSet object\");\n    }\n\n    @Override\n    public MergeTarget newEmptyTargetForField(\n        Descriptors.FieldDescriptor descriptor, Message defaultInstance) {\n      throw new UnsupportedOperationException(\"newEmptyTargetForField() called on FieldSet object\");\n    }\n\n    @Override\n    public WireFormat.Utf8Validation getUtf8Validation(Descriptors.FieldDescriptor descriptor) {\n      if (descriptor.needsUtf8Check()) {\n        return WireFormat.Utf8Validation.STRICT;\n      }\n      // TODO(b/248145492): support lazy strings for ExtesnsionSet.\n      return WireFormat.Utf8Validation.LOOSE;\n    }\n\n    @Override\n    public Object finish() {\n      throw new UnsupportedOperationException(\"finish() called on FieldSet object\");\n    }\n  }\n\n  static class ExtensionBuilderAdapter implements MergeTarget {\n\n    private final FieldSet.Builder<Descriptors.FieldDescriptor> extensions;\n\n    ExtensionBuilderAdapter(FieldSet.Builder<Descriptors.FieldDescriptor> extensions) {\n      this.extensions = extensions;\n    }\n\n    @Override\n    public Descriptors.Descriptor getDescriptorForType() {\n      throw new UnsupportedOperationException(\"getDescriptorForType() called on FieldSet object\");\n    }\n\n    @Override\n    public Object getField(Descriptors.FieldDescriptor field) {\n      return extensions.getField(field);\n    }\n\n    @Override\n    public boolean hasField(Descriptors.FieldDescriptor field) {\n      return extensions.hasField(field);\n    }\n\n    @Override\n    @CanIgnoreReturnValue\n    public MergeTarget setField(Descriptors.FieldDescriptor field, Object value) {\n      extensions.setField(field, value);\n      return this;\n    }\n\n    @Override\n    @CanIgnoreReturnValue\n    public MergeTarget clearField(Descriptors.FieldDescriptor field) {\n      extensions.clearField(field);\n      return this;\n    }\n\n    @Override\n    @CanIgnoreReturnValue\n    public MergeTarget setRepeatedField(\n        Descriptors.FieldDescriptor field, int index, Object value) {\n      extensions.setRepeatedField(field, index, value);\n      return this;\n    }\n\n    @Override\n    @CanIgnoreReturnValue\n    public MergeTarget addRepeatedField(Descriptors.FieldDescriptor field, Object value) {\n      extensions.addRepeatedField(field, value);\n      return this;\n    }\n\n    @Override\n    public boolean hasOneof(Descriptors.OneofDescriptor oneof) {\n      return false;\n    }\n\n    @Override\n    @CanIgnoreReturnValue\n    public MergeTarget clearOneof(Descriptors.OneofDescriptor oneof) {\n      // Nothing to clear.\n      return this;\n    }\n\n    @Override\n    public Descriptors.FieldDescriptor getOneofFieldDescriptor(Descriptors.OneofDescriptor oneof) {\n      return null;\n    }\n\n    @Override\n    public ContainerType getContainerType() {\n      return ContainerType.EXTENSION_SET;\n    }\n\n    @Override\n    public ExtensionRegistry.ExtensionInfo findExtensionByName(\n        ExtensionRegistry registry, String name) {\n      return registry.findImmutableExtensionByName(name);\n    }\n\n    @Override\n    public ExtensionRegistry.ExtensionInfo findExtensionByNumber(\n        ExtensionRegistry registry, Descriptors.Descriptor containingType, int fieldNumber) {\n      return registry.findImmutableExtensionByNumber(containingType, fieldNumber);\n    }\n\n    @Override\n    public Object parseGroup(\n        CodedInputStream input,\n        ExtensionRegistryLite registry,\n        Descriptors.FieldDescriptor field,\n        Message defaultInstance)\n        throws IOException {\n      Message.Builder subBuilder = defaultInstance.newBuilderForType();\n      if (!field.isRepeated()) {\n        Message originalMessage = (Message) getField(field);\n        if (originalMessage != null) {\n          subBuilder.mergeFrom(originalMessage);\n        }\n      }\n      input.readGroup(field.getNumber(), subBuilder, registry);\n      return subBuilder.buildPartial();\n    }\n\n    @Override\n    public Object parseMessage(\n        CodedInputStream input,\n        ExtensionRegistryLite registry,\n        Descriptors.FieldDescriptor field,\n        Message defaultInstance)\n        throws IOException {\n      Message.Builder subBuilder = defaultInstance.newBuilderForType();\n      if (!field.isRepeated()) {\n        Message originalMessage = (Message) getField(field);\n        if (originalMessage != null) {\n          subBuilder.mergeFrom(originalMessage);\n        }\n      }\n      input.readMessage(subBuilder, registry);\n      return subBuilder.buildPartial();\n    }\n\n    @Override\n    public void mergeGroup(\n        CodedInputStream input,\n        ExtensionRegistryLite extensionRegistry,\n        FieldDescriptor field,\n        Message defaultInstance)\n        throws IOException {\n      if (!field.isRepeated()) {\n        if (hasField(field)) {\n          Object fieldOrBuilder = extensions.getFieldAllowBuilders(field);\n          MessageLite.Builder subBuilder;\n          if (fieldOrBuilder instanceof MessageLite.Builder) {\n            subBuilder = (MessageLite.Builder) fieldOrBuilder;\n          } else {\n            subBuilder = ((MessageLite) fieldOrBuilder).toBuilder();\n            extensions.setField(field, subBuilder);\n          }\n          input.readGroup(field.getNumber(), subBuilder, extensionRegistry);\n          return;\n        }\n        Message.Builder subBuilder = defaultInstance.newBuilderForType();\n        input.readGroup(field.getNumber(), subBuilder, extensionRegistry);\n        Object unused = setField(field, subBuilder);\n      } else {\n        Message.Builder subBuilder = defaultInstance.newBuilderForType();\n        input.readGroup(field.getNumber(), subBuilder, extensionRegistry);\n        Object unused = addRepeatedField(field, subBuilder.buildPartial());\n      }\n    }\n\n    @Override\n    public void mergeMessage(\n        CodedInputStream input,\n        ExtensionRegistryLite extensionRegistry,\n        FieldDescriptor field,\n        Message defaultInstance)\n        throws IOException {\n      if (!field.isRepeated()) {\n        if (hasField(field)) {\n          Object fieldOrBuilder = extensions.getFieldAllowBuilders(field);\n          MessageLite.Builder subBuilder;\n          if (fieldOrBuilder instanceof MessageLite.Builder) {\n            subBuilder = (MessageLite.Builder) fieldOrBuilder;\n          } else {\n            subBuilder = ((MessageLite) fieldOrBuilder).toBuilder();\n            extensions.setField(field, subBuilder);\n          }\n          input.readMessage(subBuilder, extensionRegistry);\n          return;\n        }\n        Message.Builder subBuilder = defaultInstance.newBuilderForType();\n        input.readMessage(subBuilder, extensionRegistry);\n        Object unused = setField(field, subBuilder);\n      } else {\n        Message.Builder subBuilder = defaultInstance.newBuilderForType();\n        input.readMessage(subBuilder, extensionRegistry);\n        Object unused = addRepeatedField(field, subBuilder.buildPartial());\n      }\n    }\n\n    @Override\n    public Object parseMessageFromBytes(\n        ByteString bytes,\n        ExtensionRegistryLite registry,\n        Descriptors.FieldDescriptor field,\n        Message defaultInstance)\n        throws IOException {\n      Message.Builder subBuilder = defaultInstance.newBuilderForType();\n      if (!field.isRepeated()) {\n        Message originalMessage = (Message) getField(field);\n        if (originalMessage != null) {\n          subBuilder.mergeFrom(originalMessage);\n        }\n      }\n      subBuilder.mergeFrom(bytes, registry);\n      return subBuilder.buildPartial();\n    }\n\n    @Override\n    public MergeTarget newMergeTargetForField(\n        Descriptors.FieldDescriptor descriptor, Message defaultInstance) {\n      throw new UnsupportedOperationException(\"newMergeTargetForField() called on FieldSet object\");\n    }\n\n    @Override\n    public MergeTarget newEmptyTargetForField(\n        Descriptors.FieldDescriptor descriptor, Message defaultInstance) {\n      throw new UnsupportedOperationException(\"newEmptyTargetForField() called on FieldSet object\");\n    }\n\n    @Override\n    public WireFormat.Utf8Validation getUtf8Validation(Descriptors.FieldDescriptor descriptor) {\n      if (descriptor.needsUtf8Check()) {\n        return WireFormat.Utf8Validation.STRICT;\n      }\n      // TODO(b/248145492): support lazy strings for ExtesnsionSet.\n      return WireFormat.Utf8Validation.LOOSE;\n    }\n\n    @Override\n    public Object finish() {\n      throw new UnsupportedOperationException(\"finish() called on FieldSet object\");\n    }\n  }\n\n  /**\n   * Parses a single field into MergeTarget. The target can be Message.Builder, FieldSet or\n   * MutableMessage.\n   *\n   * <p>Package-private because it is used by GeneratedMessage.ExtendableMessage.\n   *\n   * @param tag The tag, which should have already been read.\n   * @param unknownFields If not null, unknown fields will be merged to this {@link\n   *     UnknownFieldSet}, otherwise unknown fields will be discarded.\n   * @return {@code true} unless the tag is an end-group tag.\n   */\n  static boolean mergeFieldFrom(\n      CodedInputStream input,\n      UnknownFieldSet.Builder unknownFields,\n      ExtensionRegistryLite extensionRegistry,\n      Descriptors.Descriptor type,\n      MergeTarget target,\n      int tag)\n      throws IOException {\n    if (type.getOptions().getMessageSetWireFormat() && tag == WireFormat.MESSAGE_SET_ITEM_TAG) {\n      mergeMessageSetExtensionFromCodedStream(\n          input, unknownFields, extensionRegistry, type, target);\n      return true;\n    }\n\n    final int wireType = WireFormat.getTagWireType(tag);\n    final int fieldNumber = WireFormat.getTagFieldNumber(tag);\n\n    final Descriptors.FieldDescriptor field;\n    Message defaultInstance = null;\n\n    if (type.isExtensionNumber(fieldNumber)) {\n      // extensionRegistry may be either ExtensionRegistry or\n      // ExtensionRegistryLite.  Since the type we are parsing is a full\n      // message, only a full ExtensionRegistry could possibly contain\n      // extensions of it.  Otherwise we will treat the registry as if it\n      // were empty.\n      if (extensionRegistry instanceof ExtensionRegistry) {\n        final ExtensionRegistry.ExtensionInfo extension =\n            target.findExtensionByNumber((ExtensionRegistry) extensionRegistry, type, fieldNumber);\n        if (extension == null) {\n          field = null;\n        } else {\n          field = extension.descriptor;\n          defaultInstance = extension.defaultInstance;\n          if (defaultInstance == null\n              && field.getJavaType() == Descriptors.FieldDescriptor.JavaType.MESSAGE) {\n            throw new IllegalStateException(\n                \"Message-typed extension lacked default instance: \" + field.getFullName());\n          }\n        }\n      } else {\n        field = null;\n      }\n    } else if (target.getContainerType() == MergeTarget.ContainerType.MESSAGE) {\n      field = type.findFieldByNumber(fieldNumber);\n    } else {\n      field = null;\n    }\n\n    boolean unknown = false;\n    boolean packed = false;\n    if (field == null) {\n      unknown = true; // Unknown field.\n    } else if (wireType\n        == FieldSet.getWireFormatForFieldType(field.getLiteType(), /* isPacked= */ false)) {\n      packed = false;\n    } else if (field.isPackable()\n        && wireType\n            == FieldSet.getWireFormatForFieldType(field.getLiteType(), /* isPacked= */ true)) {\n      packed = true;\n    } else {\n      unknown = true; // Unknown wire type.\n    }\n\n    if (unknown) { // Unknown field or wrong wire type.  Skip.\n      if (unknownFields != null) {\n        return unknownFields.mergeFieldFrom(tag, input);\n      } else {\n        return input.skipField(tag);\n      }\n    }\n\n    if (packed) {\n      final int length = input.readRawVarint32();\n      final int limit = input.pushLimit(length);\n      if (field.getLiteType() == WireFormat.FieldType.ENUM) {\n        while (input.getBytesUntilLimit() > 0) {\n          final int rawValue = input.readEnum();\n          if (field.getFile().supportsUnknownEnumValue()) {\n            target.addRepeatedField(\n                field, field.getEnumType().findValueByNumberCreatingIfUnknown(rawValue));\n          } else {\n            final Object value = field.getEnumType().findValueByNumber(rawValue);\n            // If the number isn't recognized as a valid value for this enum,\n            // add it to the unknown fields.\n            if (value == null) {\n              if (unknownFields != null) {\n                unknownFields.mergeVarintField(fieldNumber, rawValue);\n              }\n            } else {\n              target.addRepeatedField(field, value);\n            }\n          }\n        }\n      } else {\n        while (input.getBytesUntilLimit() > 0) {\n          final Object value =\n              WireFormat.readPrimitiveField(\n                  input, field.getLiteType(), target.getUtf8Validation(field));\n          target.addRepeatedField(field, value);\n        }\n      }\n      input.popLimit(limit);\n    } else {\n      final Object value;\n      switch (field.getType()) {\n        case GROUP:\n          {\n            target.mergeGroup(input, extensionRegistry, field, defaultInstance);\n            return true;\n          }\n        case MESSAGE:\n          {\n            target.mergeMessage(input, extensionRegistry, field, defaultInstance);\n            return true;\n          }\n        case ENUM:\n          final int rawValue = input.readEnum();\n          if (field.getFile().supportsUnknownEnumValue()) {\n            value = field.getEnumType().findValueByNumberCreatingIfUnknown(rawValue);\n          } else {\n            value = field.getEnumType().findValueByNumber(rawValue);\n            // If the number isn't recognized as a valid value for this enum,\n            // add it to the unknown fields.\n            if (value == null) {\n              if (unknownFields != null) {\n                unknownFields.mergeVarintField(fieldNumber, rawValue);\n              }\n              return true;\n            }\n          }\n          break;\n        default:\n          value =\n              WireFormat.readPrimitiveField(\n                  input, field.getLiteType(), target.getUtf8Validation(field));\n          break;\n      }\n\n      if (field.isRepeated()) {\n        target.addRepeatedField(field, value);\n      } else {\n        target.setField(field, value);\n      }\n    }\n\n    return true;\n  }\n\n  /** Read a message from the given input stream into the provided target and UnknownFieldSet. */\n  static void mergeMessageFrom(\n      Message.Builder target,\n      UnknownFieldSet.Builder unknownFields,\n      CodedInputStream input,\n      ExtensionRegistryLite extensionRegistry)\n      throws IOException {\n    BuilderAdapter builderAdapter = new BuilderAdapter(target);\n    Descriptor descriptorForType = target.getDescriptorForType();\n    while (true) {\n      final int tag = input.readTag();\n      if (tag == 0) {\n        break;\n      }\n\n      if (!mergeFieldFrom(\n          input, unknownFields, extensionRegistry, descriptorForType, builderAdapter, tag)) {\n        // end group tag\n        break;\n      }\n    }\n  }\n\n  /** Called by {@code #mergeFieldFrom()} to parse a MessageSet extension into MergeTarget. */\n  private static void mergeMessageSetExtensionFromCodedStream(\n      CodedInputStream input,\n      UnknownFieldSet.Builder unknownFields,\n      ExtensionRegistryLite extensionRegistry,\n      Descriptors.Descriptor type,\n      MergeTarget target)\n      throws IOException {\n\n    // The wire format for MessageSet is:\n    //   message MessageSet {\n    //     repeated group Item = 1 {\n    //       required uint32 typeId = 2;\n    //       required bytes message = 3;\n    //     }\n    //   }\n    // \"typeId\" is the extension's field number.  The extension can only be\n    // a message type, where \"message\" contains the encoded bytes of that\n    // message.\n    //\n    // In practice, we will probably never see a MessageSet item in which\n    // the message appears before the type ID, or where either field does not\n    // appear exactly once.  However, in theory such cases are valid, so we\n    // should be prepared to accept them.\n\n    int typeId = 0;\n    ByteString rawBytes = null; // If we encounter \"message\" before \"typeId\"\n    ExtensionRegistry.ExtensionInfo extension = null;\n\n    // Read bytes from input, if we get it's type first then parse it eagerly,\n    // otherwise we store the raw bytes in a local variable.\n    while (true) {\n      final int tag = input.readTag();\n      if (tag == 0) {\n        break;\n      }\n\n      if (tag == WireFormat.MESSAGE_SET_TYPE_ID_TAG) {\n        typeId = input.readUInt32();\n        if (typeId != 0) {\n          // extensionRegistry may be either ExtensionRegistry or\n          // ExtensionRegistryLite. Since the type we are parsing is a full\n          // message, only a full ExtensionRegistry could possibly contain\n          // extensions of it. Otherwise we will treat the registry as if it\n          // were empty.\n          if (extensionRegistry instanceof ExtensionRegistry) {\n            extension =\n                target.findExtensionByNumber((ExtensionRegistry) extensionRegistry, type, typeId);\n          }\n        }\n\n      } else if (tag == WireFormat.MESSAGE_SET_MESSAGE_TAG) {\n        if (typeId != 0) {\n          if (extension != null && ExtensionRegistryLite.isEagerlyParseMessageSets()) {\n            // We already know the type, so we can parse directly from the\n            // input with no copying.  Hooray!\n            eagerlyMergeMessageSetExtension(input, extension, extensionRegistry, target);\n            rawBytes = null;\n            continue;\n          }\n        }\n        // We haven't seen a type ID yet or we want parse message lazily.\n        rawBytes = input.readBytes();\n\n      } else { // Unknown tag. Skip it.\n        if (!input.skipField(tag)) {\n          break; // End of group\n        }\n      }\n    }\n    input.checkLastTagWas(WireFormat.MESSAGE_SET_ITEM_END_TAG);\n\n    // Process the raw bytes.\n    if (rawBytes != null && typeId != 0) { // Zero is not a valid type ID.\n      if (extension != null) { // We known the type\n        mergeMessageSetExtensionFromBytes(rawBytes, extension, extensionRegistry, target);\n      } else { // We don't know how to parse this. Ignore it.\n        if (rawBytes != null && unknownFields != null) {\n          unknownFields.mergeField(\n              typeId, UnknownFieldSet.Field.newBuilder().addLengthDelimited(rawBytes).build());\n        }\n      }\n    }\n  }\n\n  private static void mergeMessageSetExtensionFromBytes(\n      ByteString rawBytes,\n      ExtensionRegistry.ExtensionInfo extension,\n      ExtensionRegistryLite extensionRegistry,\n      MergeTarget target)\n      throws IOException {\n\n    Descriptors.FieldDescriptor field = extension.descriptor;\n    boolean hasOriginalValue = target.hasField(field);\n\n    if (hasOriginalValue || ExtensionRegistryLite.isEagerlyParseMessageSets()) {\n      // If the field already exists, we just parse the field.\n      Object value =\n          target.parseMessageFromBytes(\n              rawBytes, extensionRegistry, field, extension.defaultInstance);\n      target.setField(field, value);\n    } else {\n      // Use LazyField to load MessageSet lazily.\n      LazyField lazyField = new LazyField(extension.defaultInstance, extensionRegistry, rawBytes);\n      target.setField(field, lazyField);\n    }\n  }\n\n  private static void eagerlyMergeMessageSetExtension(\n      CodedInputStream input,\n      ExtensionRegistry.ExtensionInfo extension,\n      ExtensionRegistryLite extensionRegistry,\n      MergeTarget target)\n      throws IOException {\n    Descriptors.FieldDescriptor field = extension.descriptor;\n    Object value = target.parseMessage(input, extensionRegistry, field, extension.defaultInstance);\n    target.setField(field, value);\n  }\n}\n", "#!/usr/bin/ruby\n\nrequire 'google/protobuf'\nrequire 'test/unit'\n\n# ------------- generated code --------------\n\nmodule BasicTest\n  pool = Google::Protobuf::DescriptorPool.new\n  pool.build do\n    add_message \"Foo\" do\n      optional :bar, :message, 1, \"Bar\"\n      repeated :baz, :message, 2, \"Baz\"\n    end\n\n    add_message \"Bar\" do\n      optional :msg, :string, 1\n    end\n\n    add_message \"Baz\" do\n      optional :msg, :string, 1\n    end\n\n    add_message \"TestMessage\" do\n      optional :optional_int32,  :int32,        1\n      optional :optional_int64,  :int64,        2\n      optional :optional_uint32, :uint32,       3\n      optional :optional_uint64, :uint64,       4\n      optional :optional_bool,   :bool,         5\n      optional :optional_float,  :float,        6\n      optional :optional_double, :double,       7\n      optional :optional_string, :string,       8\n      optional :optional_bytes,  :bytes,        9\n      optional :optional_msg,    :message,      10, \"TestMessage2\"\n      optional :optional_enum,   :enum,         11, \"TestEnum\"\n\n      repeated :repeated_int32,  :int32,        12\n      repeated :repeated_int64,  :int64,        13\n      repeated :repeated_uint32, :uint32,       14\n      repeated :repeated_uint64, :uint64,       15\n      repeated :repeated_bool,   :bool,         16\n      repeated :repeated_float,  :float,        17\n      repeated :repeated_double, :double,       18\n      repeated :repeated_string, :string,       19\n      repeated :repeated_bytes,  :bytes,        20\n      repeated :repeated_msg,    :message,      21, \"TestMessage2\"\n      repeated :repeated_enum,   :enum,         22, \"TestEnum\"\n    end\n    add_message \"TestMessage2\" do\n      optional :foo, :int32, 1\n    end\n\n    add_message \"Recursive1\" do\n      optional :foo, :message, 1, \"Recursive2\"\n    end\n    add_message \"Recursive2\" do\n      optional :foo, :message, 1, \"Recursive1\"\n    end\n\n    add_enum \"TestEnum\" do\n      value :Default, 0\n      value :A, 1\n      value :B, 2\n      value :C, 3\n    end\n\n    add_message \"BadFieldNames\" do\n      optional :dup, :int32, 1\n      optional :class, :int32, 2\n    end\n\n    add_message \"MapMessage\" do\n      map :map_string_int32, :string, :int32, 1\n      map :map_string_msg, :string, :message, 2, \"TestMessage2\"\n    end\n    add_message \"MapMessageWireEquiv\" do\n      repeated :map_string_int32, :message, 1, \"MapMessageWireEquiv_entry1\"\n      repeated :map_string_msg, :message, 2, \"MapMessageWireEquiv_entry2\"\n    end\n    add_message \"MapMessageWireEquiv_entry1\" do\n      optional :key, :string, 1\n      optional :value, :int32, 2\n    end\n    add_message \"MapMessageWireEquiv_entry2\" do\n      optional :key, :string, 1\n      optional :value, :message, 2, \"TestMessage2\"\n    end\n\n    add_message \"OneofMessage\" do\n      oneof :my_oneof do\n        optional :a, :string, 1\n        optional :b, :int32, 2\n        optional :c, :message, 3, \"TestMessage2\"\n        optional :d, :enum, 4, \"TestEnum\"\n      end\n    end\n  end\n\n  Foo = pool.lookup(\"Foo\").msgclass\n  Bar = pool.lookup(\"Bar\").msgclass\n  Baz = pool.lookup(\"Baz\").msgclass\n  TestMessage = pool.lookup(\"TestMessage\").msgclass\n  TestMessage2 = pool.lookup(\"TestMessage2\").msgclass\n  Recursive1 = pool.lookup(\"Recursive1\").msgclass\n  Recursive2 = pool.lookup(\"Recursive2\").msgclass\n  TestEnum = pool.lookup(\"TestEnum\").enummodule\n  BadFieldNames = pool.lookup(\"BadFieldNames\").msgclass\n  MapMessage = pool.lookup(\"MapMessage\").msgclass\n  MapMessageWireEquiv = pool.lookup(\"MapMessageWireEquiv\").msgclass\n  MapMessageWireEquiv_entry1 =\n    pool.lookup(\"MapMessageWireEquiv_entry1\").msgclass\n  MapMessageWireEquiv_entry2 =\n    pool.lookup(\"MapMessageWireEquiv_entry2\").msgclass\n  OneofMessage = pool.lookup(\"OneofMessage\").msgclass\n\n# ------------ test cases ---------------\n\n  class MessageContainerTest < Test::Unit::TestCase\n\n    def test_defaults\n      m = TestMessage.new\n      assert m.optional_int32 == 0\n      assert m.optional_int64 == 0\n      assert m.optional_uint32 == 0\n      assert m.optional_uint64 == 0\n      assert m.optional_bool == false\n      assert m.optional_float == 0.0\n      assert m.optional_double == 0.0\n      assert m.optional_string == \"\"\n      assert m.optional_bytes == \"\"\n      assert m.optional_msg == nil\n      assert m.optional_enum == :Default\n    end\n\n    def test_setters\n      m = TestMessage.new\n      m.optional_int32 = -42\n      assert m.optional_int32 == -42\n      m.optional_int64 = -0x1_0000_0000\n      assert m.optional_int64 == -0x1_0000_0000\n      m.optional_uint32 = 0x9000_0000\n      assert m.optional_uint32 == 0x9000_0000\n      m.optional_uint64 = 0x9000_0000_0000_0000\n      assert m.optional_uint64 == 0x9000_0000_0000_0000\n      m.optional_bool = true\n      assert m.optional_bool == true\n      m.optional_float = 0.5\n      assert m.optional_float == 0.5\n      m.optional_double = 0.5\n      m.optional_string = \"hello\"\n      assert m.optional_string == \"hello\"\n      m.optional_bytes = \"world\".encode!('ASCII-8BIT')\n      assert m.optional_bytes == \"world\"\n      m.optional_msg = TestMessage2.new(:foo => 42)\n      assert m.optional_msg == TestMessage2.new(:foo => 42)\n      m.optional_msg = nil\n      assert m.optional_msg == nil\n    end\n\n    def test_ctor_args\n      m = TestMessage.new(:optional_int32 => -42,\n                          :optional_msg => TestMessage2.new,\n                          :optional_enum => :C,\n                          :repeated_string => [\"hello\", \"there\", \"world\"])\n      assert m.optional_int32 == -42\n      assert m.optional_msg.class == TestMessage2\n      assert m.repeated_string.length == 3\n      assert m.optional_enum == :C\n      assert m.repeated_string[0] == \"hello\"\n      assert m.repeated_string[1] == \"there\"\n      assert m.repeated_string[2] == \"world\"\n    end\n\n    def test_inspect\n      m = TestMessage.new(:optional_int32 => -42,\n                          :optional_enum => :A,\n                          :optional_msg => TestMessage2.new,\n                          :repeated_string => [\"hello\", \"there\", \"world\"])\n      expected = '<BasicTest::TestMessage: optional_int32: -42, optional_int64: 0, optional_uint32: 0, optional_uint64: 0, optional_bool: false, optional_float: 0.0, optional_double: 0.0, optional_string: \"\", optional_bytes: \"\", optional_msg: <BasicTest::TestMessage2: foo: 0>, optional_enum: :A, repeated_int32: [], repeated_int64: [], repeated_uint32: [], repeated_uint64: [], repeated_bool: [], repeated_float: [], repeated_double: [], repeated_string: [\"hello\", \"there\", \"world\"], repeated_bytes: [], repeated_msg: [], repeated_enum: []>'\n      assert_equal expected, m.inspect\n    end\n\n    def test_hash\n      m1 = TestMessage.new(:optional_int32 => 42)\n      m2 = TestMessage.new(:optional_int32 => 102)\n      assert m1.hash != 0\n      assert m2.hash != 0\n      # relying on the randomness here -- if hash function changes and we are\n      # unlucky enough to get a collision, then change the values above.\n      assert m1.hash != m2.hash\n    end\n\n    def test_unknown_field_errors\n      e = assert_raise NoMethodError do\n        TestMessage.new.hello\n      end\n      assert_match(/hello/, e.message)\n\n      e = assert_raise NoMethodError do\n        TestMessage.new.hello = \"world\"\n      end\n      assert_match(/hello/, e.message)\n    end\n\n    def test_initialization_map_errors\n      e = assert_raise ArgumentError do\n        TestMessage.new(:hello => \"world\")\n      end\n      assert_match(/hello/, e.message)\n\n      e = assert_raise ArgumentError do\n        MapMessage.new(:map_string_int32 => \"hello\")\n      end\n      assert_equal e.message, \"Expected Hash object as initializer value for map field 'map_string_int32' (given String).\"\n\n      e = assert_raise ArgumentError do\n        TestMessage.new(:repeated_uint32 => \"hello\")\n      end\n      assert_equal e.message, \"Expected array as initializer value for repeated field 'repeated_uint32' (given String).\"\n    end\n\n    def test_type_errors\n      m = TestMessage.new\n\n      # Use rescue to allow subclasses of error\n      success = false\n      begin\n        m.optional_int32 = \"hello\"\n      rescue TypeError\n        success = true\n      end\n      assert(success)\n\n      success = false\n      begin\n        m.optional_string = nil\n      rescue TypeError\n        success = true\n      end\n      assert(success)\n\n      success = false\n      begin\n        m.optional_bool = 42\n      rescue TypeError\n        success = true\n      end\n      assert(success)\n\n      success = false\n      begin\n        m.optional_msg = TestMessage.new  # expects TestMessage2\n      rescue TypeError\n        success = true\n      end\n      assert(success)\n\n      success = false\n      begin\n        m.repeated_int32 = []  # needs RepeatedField\n      rescue TypeError\n        success = true\n      end\n      assert(success)\n\n      success = false\n      begin\n        m.repeated_msg.push TestMessage.new\n      rescue TypeError\n        success = true\n      end\n      assert(success)\n    end\n\n    def test_string_encoding\n      m = TestMessage.new\n\n      # Assigning a normal (ASCII or UTF8) string to a bytes field, or\n      # ASCII-8BIT to a string field will convert to the proper encoding.\n      m.optional_bytes = \"Test string ASCII\".encode!('ASCII')\n      assert m.optional_bytes.frozen?\n      assert_equal Encoding::ASCII_8BIT, m.optional_bytes.encoding\n      assert_equal \"Test string ASCII\", m.optional_bytes\n\n      assert_raise Encoding::UndefinedConversionError do\n        m.optional_bytes = \"Test string UTF-8 \\u0100\".encode!('UTF-8')\n      end\n\n      assert_raise Encoding::UndefinedConversionError do\n        m.optional_string = [\"FFFF\"].pack('H*')\n      end\n\n      # \"Ordinary\" use case.\n      m.optional_bytes = [\"FFFF\"].pack('H*')\n      m.optional_string = \"\\u0100\"\n\n      # strings are immutable so we can't do this, but serialize should catch it.\n      m.optional_string = \"asdf\".encode!('UTF-8')\n      assert_raise do\n        m.optional_string.encode!('ASCII-8BIT')\n      end\n    end\n\n    def test_rptfield_int32\n      l = Google::Protobuf::RepeatedField.new(:int32)\n      assert l.count == 0\n      l = Google::Protobuf::RepeatedField.new(:int32, [1, 2, 3])\n      assert l.count == 3\n      assert_equal [1, 2, 3], l\n      assert_equal l, [1, 2, 3]\n      l.push 4\n      assert l == [1, 2, 3, 4]\n      dst_list = []\n      l.each { |val| dst_list.push val }\n      assert dst_list == [1, 2, 3, 4]\n      assert l.to_a == [1, 2, 3, 4]\n      assert l[0] == 1\n      assert l[3] == 4\n      l[0] = 5\n      assert l == [5, 2, 3, 4]\n\n      l2 = l.dup\n      assert l == l2\n      assert l.object_id != l2.object_id\n      l2.push 6\n      assert l.count == 4\n      assert l2.count == 5\n\n      assert l.inspect == '[5, 2, 3, 4]'\n\n      l.concat([7, 8, 9])\n      assert l == [5, 2, 3, 4, 7, 8, 9]\n      assert l.pop == 9\n      assert l == [5, 2, 3, 4, 7, 8]\n\n      success = false\n      begin\n        m = TestMessage.new\n        l.push m\n      rescue TypeError\n        success = true\n      end\n      assert(success)\n\n      m = TestMessage.new\n      m.repeated_int32 = l\n      assert m.repeated_int32 == [5, 2, 3, 4, 7, 8]\n      assert m.repeated_int32.object_id == l.object_id\n      l.push 42\n      assert m.repeated_int32.pop == 42\n\n      l3 = l + l.dup\n      assert l3.count == l.count * 2\n      l.count.times do |i|\n        assert l3[i] == l[i]\n        assert l3[l.count + i] == l[i]\n      end\n\n      l.clear\n      assert l.count == 0\n      l += [1, 2, 3, 4]\n      l.replace([5, 6, 7, 8])\n      assert l == [5, 6, 7, 8]\n\n      l4 = Google::Protobuf::RepeatedField.new(:int32)\n      l4[5] = 42\n      assert l4 == [0, 0, 0, 0, 0, 42]\n\n      l4 << 100\n      assert l4 == [0, 0, 0, 0, 0, 42, 100]\n      l4 << 101 << 102\n      assert l4 == [0, 0, 0, 0, 0, 42, 100, 101, 102]\n    end\n\n    def test_parent_rptfield\n      #make sure we set the RepeatedField and can add to it\n      m = TestMessage.new\n      assert m.repeated_string == []\n      m.repeated_string << 'ok'\n      m.repeated_string.push('ok2')\n      assert m.repeated_string == ['ok', 'ok2']\n      m.repeated_string += ['ok3']\n      assert m.repeated_string == ['ok', 'ok2', 'ok3']\n    end\n\n    def test_rptfield_msg\n      l = Google::Protobuf::RepeatedField.new(:message, TestMessage)\n      l.push TestMessage.new\n      assert l.count == 1\n\n      success = false\n      begin\n        l.push TestMessage2.new\n      rescue TypeError\n        success = true\n      end\n      assert(success)\n\n      success = false\n      begin\n        l.push 42\n      rescue TypeError\n        success = true\n      end\n      assert(success)\n\n      l2 = l.dup\n      assert l2[0] == l[0]\n      assert l2[0].object_id == l[0].object_id\n\n      l2 = Google::Protobuf.deep_copy(l)\n      assert l2[0] == l[0]\n      assert l2[0].object_id != l[0].object_id\n\n      l3 = l + l2\n      assert l3.count == 2\n      assert l3[0] == l[0]\n      assert l3[1] == l2[0]\n      l3[0].optional_int32 = 1000\n      assert l[0].optional_int32 == 1000\n\n      new_msg = TestMessage.new(:optional_int32 => 200)\n      l4 = l + [new_msg]\n      assert l4.count == 2\n      new_msg.optional_int32 = 1000\n      assert l4[1].optional_int32 == 1000\n    end\n\n    def test_rptfield_enum\n      l = Google::Protobuf::RepeatedField.new(:enum, TestEnum)\n      l.push :A\n      l.push :B\n      l.push :C\n      assert l.count == 3\n      assert_raise RangeError do\n        l.push :D\n      end\n      assert l[0] == :A\n\n      l.push 4\n      assert l[3] == 4\n    end\n\n    def test_rptfield_initialize\n      assert_raise ArgumentError do\n        l = Google::Protobuf::RepeatedField.new\n      end\n      assert_raise ArgumentError do\n        l = Google::Protobuf::RepeatedField.new(:message)\n      end\n      assert_raise ArgumentError do\n        l = Google::Protobuf::RepeatedField.new([1, 2, 3])\n      end\n      assert_raise ArgumentError do\n        l = Google::Protobuf::RepeatedField.new(:message, [TestMessage2.new])\n      end\n    end\n\n    def test_rptfield_array_ducktyping\n      l = Google::Protobuf::RepeatedField.new(:int32)\n      length_methods = %w(count length size)\n      length_methods.each do |lm|\n        assert l.send(lm)  == 0\n      end\n      # out of bounds returns a nil\n      assert l[0] == nil\n      assert l[1] == nil\n      assert l[-1] == nil\n      l.push 4\n      length_methods.each do |lm|\n        assert l.send(lm) == 1\n      end\n      assert l[0] == 4\n      assert l[1] == nil\n      assert l[-1] == 4\n      assert l[-2] == nil\n\n      l.push 2\n      length_methods.each do |lm|\n        assert l.send(lm) == 2\n      end\n      assert l[0] == 4\n      assert l[1] == 2\n      assert l[2] == nil\n      assert l[-1] == 2\n      assert l[-2] == 4\n      assert l[-3] == nil\n\n      #adding out of scope will backfill with empty objects\n    end\n\n    def test_map_basic\n      # allowed key types:\n      # :int32, :int64, :uint32, :uint64, :bool, :string, :bytes.\n\n      m = Google::Protobuf::Map.new(:string, :int32)\n      m[\"asdf\"] = 1\n      assert m[\"asdf\"] == 1\n      m[\"jkl;\"] = 42\n      assert m == { \"jkl;\" => 42, \"asdf\" => 1 }\n      assert m.has_key?(\"asdf\")\n      assert !m.has_key?(\"qwerty\")\n      assert m.length == 2\n\n      m2 = m.dup\n      assert m == m2\n      assert m.hash != 0\n      assert m.hash == m2.hash\n\n      collected = {}\n      m.each { |k,v| collected[v] = k }\n      assert collected == { 42 => \"jkl;\", 1 => \"asdf\" }\n\n      assert m.delete(\"asdf\") == 1\n      assert !m.has_key?(\"asdf\")\n      assert m[\"asdf\"] == nil\n      assert !m.has_key?(\"asdf\")\n\n      # We only assert on inspect value when there is one map entry because the\n      # order in which elements appear is unspecified (depends on the internal\n      # hash function). We don't want a brittle test.\n      assert m.inspect == \"{\\\"jkl;\\\"=>42}\"\n\n      assert m.keys == [\"jkl;\"]\n      assert m.values == [42]\n\n      m.clear\n      assert m.length == 0\n      assert m == {}\n\n      success = false\n      begin\n        m[1] = 1\n      rescue TypeError\n        success = true\n      end\n      assert(success)\n\n      assert_raise RangeError do\n        m[\"asdf\"] = 0x1_0000_0000\n      end\n    end\n\n    def test_map_ctor\n      m = Google::Protobuf::Map.new(:string, :int32,\n                                    {\"a\" => 1, \"b\" => 2, \"c\" => 3})\n      assert m == {\"a\" => 1, \"c\" => 3, \"b\" => 2}\n    end\n\n    def test_map_keytypes\n      m = Google::Protobuf::Map.new(:int32, :int32)\n      m[1] = 42\n      m[-1] = 42\n      assert_raise RangeError do\n        m[0x8000_0000] = 1\n      end\n\n      success = false\n      begin\n        m[\"asdf\"] = 1\n      rescue TypeError\n        success = true\n      end\n      assert(success)\n\n      m = Google::Protobuf::Map.new(:int64, :int32)\n      m[0x1000_0000_0000_0000] = 1\n      assert_raise RangeError do\n        m[0x1_0000_0000_0000_0000] = 1\n      end\n\n      success = false\n      begin\n        m[\"asdf\"] = 1\n      rescue TypeError\n        success = true\n      end\n      assert(success)\n\n      m = Google::Protobuf::Map.new(:uint32, :int32)\n      m[0x8000_0000] = 1\n      assert_raise RangeError do\n        m[0x1_0000_0000] = 1\n      end\n      assert_raise RangeError do\n        m[-1] = 1\n      end\n\n      m = Google::Protobuf::Map.new(:uint64, :int32)\n      m[0x8000_0000_0000_0000] = 1\n      assert_raise RangeError do\n        m[0x1_0000_0000_0000_0000] = 1\n      end\n      assert_raise RangeError do\n        m[-1] = 1\n      end\n\n      m = Google::Protobuf::Map.new(:bool, :int32)\n      m[true] = 1\n      m[false] = 2\n\n      success = false\n      begin\n        m[1] = 1\n      rescue TypeError\n        success = true\n      end\n      assert(success)\n\n      success = false\n      begin\n        m[\"asdf\"] = 1\n      rescue TypeError\n        success = true\n      end\n      assert(success)\n\n      m = Google::Protobuf::Map.new(:string, :int32)\n      m[\"asdf\"] = 1\n      success = false\n      begin\n        m[1] = 1\n      rescue TypeError\n        success = true\n      end\n      assert(success)\n      assert_raise Encoding::UndefinedConversionError do\n        bytestring = [\"FFFF\"].pack(\"H*\")\n        m[bytestring] = 1\n      end\n\n      m = Google::Protobuf::Map.new(:bytes, :int32)\n      bytestring = [\"FFFF\"].pack(\"H*\")\n      m[bytestring] = 1\n      # Allowed -- we will automatically convert to ASCII-8BIT.\n      m[\"asdf\"] = 1\n      success = false\n      begin\n        m[1] = 1\n      rescue TypeError\n        success = true\n      end\n      assert(success)\n    end\n\n    def test_map_msg_enum_valuetypes\n      m = Google::Protobuf::Map.new(:string, :message, TestMessage)\n      m[\"asdf\"] = TestMessage.new\n      success = false\n      begin\n        m[\"jkl;\"] = TestMessage2.new\n      rescue TypeError\n        success = true\n      end\n      assert(success)\n\n      m = Google::Protobuf::Map.new(\n        :string, :message, TestMessage,\n        { \"a\" => TestMessage.new(:optional_int32 => 42),\n          \"b\" => TestMessage.new(:optional_int32 => 84) })\n      assert m.length == 2\n      assert m.values.map{|msg| msg.optional_int32}.sort == [42, 84]\n\n      m = Google::Protobuf::Map.new(:string, :enum, TestEnum,\n                                    { \"x\" => :A, \"y\" => :B, \"z\" => :C })\n      assert m.length == 3\n      assert m[\"z\"] == :C\n      m[\"z\"] = 2\n      assert m[\"z\"] == :B\n      m[\"z\"] = 4\n      assert m[\"z\"] == 4\n      assert_raise RangeError do\n        m[\"z\"] = :Z\n      end\n      assert_raise RangeError do\n        m[\"z\"] = \"z\"\n      end\n    end\n\n    def test_map_dup_deep_copy\n      m = Google::Protobuf::Map.new(\n        :string, :message, TestMessage,\n        { \"a\" => TestMessage.new(:optional_int32 => 42),\n          \"b\" => TestMessage.new(:optional_int32 => 84) })\n\n      m2 = m.dup\n      assert m == m2\n      assert m.object_id != m2.object_id\n      assert m[\"a\"].object_id == m2[\"a\"].object_id\n      assert m[\"b\"].object_id == m2[\"b\"].object_id\n\n      m2 = Google::Protobuf.deep_copy(m)\n      assert m == m2\n      assert m.object_id != m2.object_id\n      assert m[\"a\"].object_id != m2[\"a\"].object_id\n      assert m[\"b\"].object_id != m2[\"b\"].object_id\n    end\n\n    def test_map_field\n      m = MapMessage.new\n      assert m.map_string_int32 == {}\n      assert m.map_string_msg == {}\n\n      m = MapMessage.new(\n        :map_string_int32 => {\"a\" => 1, \"b\" => 2},\n        :map_string_msg => {\"a\" => TestMessage2.new(:foo => 1),\n                            \"b\" => TestMessage2.new(:foo => 2)})\n      assert m.map_string_int32.keys.sort == [\"a\", \"b\"]\n      assert m.map_string_int32[\"a\"] == 1\n      assert m.map_string_msg[\"b\"].foo == 2\n\n      m.map_string_int32[\"c\"] = 3\n      assert m.map_string_int32[\"c\"] == 3\n      m.map_string_msg[\"c\"] = TestMessage2.new(:foo => 3)\n      assert m.map_string_msg[\"c\"] == TestMessage2.new(:foo => 3)\n      m.map_string_msg.delete(\"b\")\n      m.map_string_msg.delete(\"c\")\n      assert m.map_string_msg == { \"a\" => TestMessage2.new(:foo => 1) }\n\n      success = false\n      begin\n        m.map_string_msg[\"e\"] = TestMessage.new # wrong value type\n      rescue TypeError\n        success = true\n      end\n      assert(success)\n      # ensure nothing was added by the above\n      assert m.map_string_msg == { \"a\" => TestMessage2.new(:foo => 1) }\n\n      m.map_string_int32 = Google::Protobuf::Map.new(:string, :int32)\n      success = false\n      begin\n        m.map_string_int32 = Google::Protobuf::Map.new(:string, :int64)\n      rescue TypeError\n        success = true\n      end\n      assert(success)\n      success = false\n      begin\n        m.map_string_int32 = {}\n      rescue TypeError\n        success = true\n      end\n      assert(success)\n\n      success = false\n      begin\n        m = MapMessage.new(:map_string_int32 => { 1 => \"I am not a number\" })\n      rescue TypeError\n        success = true\n      end\n      assert(success)\n    end\n\n    def test_map_encode_decode\n      m = MapMessage.new(\n        :map_string_int32 => {\"a\" => 1, \"b\" => 2},\n        :map_string_msg => {\"a\" => TestMessage2.new(:foo => 1),\n                            \"b\" => TestMessage2.new(:foo => 2)})\n      m2 = MapMessage.decode(MapMessage.encode(m))\n      assert m == m2\n\n      m3 = MapMessageWireEquiv.decode(MapMessage.encode(m))\n      assert m3.map_string_int32.length == 2\n\n      kv = {}\n      m3.map_string_int32.map { |msg| kv[msg.key] = msg.value }\n      assert kv == {\"a\" => 1, \"b\" => 2}\n\n      kv = {}\n      m3.map_string_msg.map { |msg| kv[msg.key] = msg.value }\n      assert kv == {\"a\" => TestMessage2.new(:foo => 1),\n                    \"b\" => TestMessage2.new(:foo => 2)}\n    end\n\n    def test_oneof_descriptors\n      d = OneofMessage.descriptor\n      o = d.lookup_oneof(\"my_oneof\")\n      assert o != nil\n      assert o.class == Google::Protobuf::OneofDescriptor\n      assert o.name == \"my_oneof\"\n      oneof_count = 0\n      d.each_oneof{ |oneof|\n        oneof_count += 1\n        assert oneof == o\n      }\n      assert oneof_count == 1\n      assert o.count == 4\n      field_names = o.map{|f| f.name}.sort\n      assert field_names == [\"a\", \"b\", \"c\", \"d\"]\n    end\n\n    def test_oneof\n      d = OneofMessage.new\n      assert d.a == \"\"\n      assert d.b == 0\n      assert d.c == nil\n      assert d.d == :Default\n      assert d.my_oneof == nil\n\n      d.a = \"hi\"\n      assert d.a == \"hi\"\n      assert d.b == 0\n      assert d.c == nil\n      assert d.d == :Default\n      assert d.my_oneof == :a\n\n      d.b = 42\n      assert d.a == \"\"\n      assert d.b == 42\n      assert d.c == nil\n      assert d.d == :Default\n      assert d.my_oneof == :b\n\n      d.c = TestMessage2.new(:foo => 100)\n      assert d.a == \"\"\n      assert d.b == 0\n      assert d.c.foo == 100\n      assert d.d == :Default\n      assert d.my_oneof == :c\n\n      d.d = :C\n      assert d.a == \"\"\n      assert d.b == 0\n      assert d.c == nil\n      assert d.d == :C\n      assert d.my_oneof == :d\n\n      d2 = OneofMessage.decode(OneofMessage.encode(d))\n      assert d2 == d\n\n      encoded_field_a = OneofMessage.encode(OneofMessage.new(:a => \"string\"))\n      encoded_field_b = OneofMessage.encode(OneofMessage.new(:b => 1000))\n      encoded_field_c = OneofMessage.encode(\n        OneofMessage.new(:c => TestMessage2.new(:foo => 1)))\n      encoded_field_d = OneofMessage.encode(OneofMessage.new(:d => :B))\n\n      d3 = OneofMessage.decode(\n        encoded_field_c + encoded_field_a + encoded_field_d)\n      assert d3.a == \"\"\n      assert d3.b == 0\n      assert d3.c == nil\n      assert d3.d == :B\n\n      d4 = OneofMessage.decode(\n        encoded_field_c + encoded_field_a + encoded_field_d +\n        encoded_field_c)\n      assert d4.a == \"\"\n      assert d4.b == 0\n      assert d4.c.foo == 1\n      assert d4.d == :Default\n\n      d5 = OneofMessage.new(:a => \"hello\")\n      assert d5.a == \"hello\"\n      d5.a = nil\n      assert d5.a == \"\"\n      assert OneofMessage.encode(d5) == ''\n      assert d5.my_oneof == nil\n    end\n\n    def test_enum_field\n      m = TestMessage.new\n      assert m.optional_enum == :Default\n      m.optional_enum = :A\n      assert m.optional_enum == :A\n      assert_raise RangeError do\n        m.optional_enum = :ASDF\n      end\n      m.optional_enum = 1\n      assert m.optional_enum == :A\n      m.optional_enum = 100\n      assert m.optional_enum == 100\n    end\n\n    def test_dup\n      m = TestMessage.new\n      m.optional_string = \"hello\"\n      m.optional_int32 = 42\n      tm1 = TestMessage2.new(:foo => 100)\n      tm2 = TestMessage2.new(:foo => 200)\n      m.repeated_msg.push tm1\n      assert m.repeated_msg[-1] == tm1\n      m.repeated_msg.push tm2\n      assert m.repeated_msg[-1] == tm2\n      m2 = m.dup\n      assert m == m2\n      m.optional_int32 += 1\n      assert m != m2\n      assert m.repeated_msg[0] == m2.repeated_msg[0]\n      assert m.repeated_msg[0].object_id == m2.repeated_msg[0].object_id\n    end\n\n    def test_deep_copy\n      m = TestMessage.new(:optional_int32 => 42,\n                          :repeated_msg => [TestMessage2.new(:foo => 100)])\n      m2 = Google::Protobuf.deep_copy(m)\n      assert m == m2\n      assert m.repeated_msg == m2.repeated_msg\n      assert m.repeated_msg.object_id != m2.repeated_msg.object_id\n      assert m.repeated_msg[0].object_id != m2.repeated_msg[0].object_id\n    end\n\n    def test_eq\n      m = TestMessage.new(:optional_int32 => 42,\n                          :repeated_int32 => [1, 2, 3])\n      m2 = TestMessage.new(:optional_int32 => 43,\n                           :repeated_int32 => [1, 2, 3])\n      assert m != m2\n    end\n\n    def test_enum_lookup\n      assert TestEnum::A == 1\n      assert TestEnum::B == 2\n      assert TestEnum::C == 3\n\n      assert TestEnum::lookup(1) == :A\n      assert TestEnum::lookup(2) == :B\n      assert TestEnum::lookup(3) == :C\n\n      assert TestEnum::resolve(:A) == 1\n      assert TestEnum::resolve(:B) == 2\n      assert TestEnum::resolve(:C) == 3\n    end\n\n    def test_parse_serialize\n      m = TestMessage.new(:optional_int32 => 42,\n                          :optional_string => \"hello world\",\n                          :optional_enum => :B,\n                          :repeated_string => [\"a\", \"b\", \"c\"],\n                          :repeated_int32 => [42, 43, 44],\n                          :repeated_enum => [:A, :B, :C, 100],\n                          :repeated_msg => [TestMessage2.new(:foo => 1),\n                                            TestMessage2.new(:foo => 2)])\n      data = TestMessage.encode m\n      m2 = TestMessage.decode data\n      assert m == m2\n\n      data = Google::Protobuf.encode m\n      m2 = Google::Protobuf.decode(TestMessage, data)\n      assert m == m2\n    end\n\n    def test_encode_decode_helpers\n      m = TestMessage.new(:optional_string => 'foo', :repeated_string => ['bar1', 'bar2'])\n      assert_equal 'foo', m.optional_string\n      assert_equal ['bar1', 'bar2'], m.repeated_string\n\n      json = m.to_json\n      m2 = TestMessage.decode_json(json)\n      assert_equal 'foo', m2.optional_string\n      assert_equal ['bar1', 'bar2'], m2.repeated_string\n      if RUBY_PLATFORM != \"java\"\n        assert m2.optional_string.frozen?\n        assert m2.repeated_string[0].frozen?\n      end\n\n      proto = m.to_proto\n      m2 = TestMessage.decode(proto)\n      assert_equal 'foo', m2.optional_string\n      assert_equal ['bar1', 'bar2'], m2.repeated_string\n    end\n\n    def test_protobuf_encode_decode_helpers\n      m = TestMessage.new(:optional_string => 'foo', :repeated_string => ['bar1', 'bar2'])\n      encoded_msg = Google::Protobuf.encode(m)\n      assert_equal m.to_proto, encoded_msg\n\n      decoded_msg = Google::Protobuf.decode(TestMessage, encoded_msg)\n      assert_equal TestMessage.decode(m.to_proto), decoded_msg\n    end\n\n    def test_protobuf_encode_decode_json_helpers\n      m = TestMessage.new(:optional_string => 'foo', :repeated_string => ['bar1', 'bar2'])\n      encoded_msg = Google::Protobuf.encode_json(m)\n      assert_equal m.to_json, encoded_msg\n\n      decoded_msg = Google::Protobuf.decode_json(TestMessage, encoded_msg)\n      assert_equal TestMessage.decode_json(m.to_json), decoded_msg\n    end\n\n    def test_to_h\n      m = TestMessage.new(:optional_bool => true, :optional_double => -10.100001, :optional_string => 'foo', :repeated_string => ['bar1', 'bar2'])\n      expected_result = {\n        :optional_bool=>true,\n        :optional_bytes=>\"\",\n        :optional_double=>-10.100001,\n        :optional_enum=>:Default,\n        :optional_float=>0.0,\n        :optional_int32=>0,\n        :optional_int64=>0,\n        :optional_msg=>nil,\n        :optional_string=>\"foo\",\n        :optional_uint32=>0,\n        :optional_uint64=>0,\n        :repeated_bool=>[],\n        :repeated_bytes=>[],\n        :repeated_double=>[],\n        :repeated_enum=>[],\n        :repeated_float=>[],\n        :repeated_int32=>[],\n        :repeated_int64=>[],\n        :repeated_msg=>[],\n        :repeated_string=>[\"bar1\", \"bar2\"],\n        :repeated_uint32=>[],\n        :repeated_uint64=>[]\n      }\n      assert_equal expected_result, m.to_h\n    end\n\n\n    def test_def_errors\n      s = Google::Protobuf::DescriptorPool.new\n      success = false\n      begin\n        s.build do\n          # enum with no default (integer value 0)\n          add_enum \"MyEnum\" do\n            value :A, 1\n          end\n        end\n      rescue TypeError\n        success = true\n      end\n      assert(success)\n      success = false\n      begin\n        s.build do\n          # message with required field (unsupported in proto3)\n          add_message \"MyMessage\" do\n            required :foo, :int32, 1\n          end\n        end\n      rescue TypeError\n        success = true\n      end\n      assert(success)\n    end\n\n    def test_corecursive\n      # just be sure that we can instantiate types with corecursive field-type\n      # references.\n      m = Recursive1.new(:foo => Recursive2.new(:foo => Recursive1.new))\n      assert Recursive1.descriptor.lookup(\"foo\").subtype ==\n        Recursive2.descriptor\n      assert Recursive2.descriptor.lookup(\"foo\").subtype ==\n        Recursive1.descriptor\n\n      serialized = Recursive1.encode(m)\n      m2 = Recursive1.decode(serialized)\n      assert m == m2\n    end\n\n    def test_serialize_cycle\n      m = Recursive1.new(:foo => Recursive2.new)\n      m.foo.foo = m\n      assert_raise RuntimeError do\n        serialized = Recursive1.encode(m)\n      end\n    end\n\n    def test_bad_field_names\n      m = BadFieldNames.new(:dup => 1, :class => 2)\n      m2 = m.dup\n      assert m == m2\n      assert m['dup'] == 1\n      assert m['class'] == 2\n      m['dup'] = 3\n      assert m['dup'] == 3\n    end\n\n    def test_int_ranges\n      m = TestMessage.new\n\n      m.optional_int32 = 0\n      m.optional_int32 = -0x8000_0000\n      m.optional_int32 = +0x7fff_ffff\n      m.optional_int32 = 1.0\n      m.optional_int32 = -1.0\n      m.optional_int32 = 2e9\n      assert_raise RangeError do\n        m.optional_int32 = -0x8000_0001\n      end\n      assert_raise RangeError do\n        m.optional_int32 = +0x8000_0000\n      end\n      assert_raise RangeError do\n        m.optional_int32 = +0x1000_0000_0000_0000_0000_0000 # force Bignum\n      end\n      assert_raise RangeError do\n        m.optional_int32 = 1e12\n      end\n      assert_raise RangeError do\n        m.optional_int32 = 1.5\n      end\n\n      m.optional_uint32 = 0\n      m.optional_uint32 = +0xffff_ffff\n      m.optional_uint32 = 1.0\n      m.optional_uint32 = 4e9\n      assert_raise RangeError do\n        m.optional_uint32 = -1\n      end\n      assert_raise RangeError do\n        m.optional_uint32 = -1.5\n      end\n      assert_raise RangeError do\n        m.optional_uint32 = -1.5e12\n      end\n      assert_raise RangeError do\n        m.optional_uint32 = -0x1000_0000_0000_0000\n      end\n      assert_raise RangeError do\n        m.optional_uint32 = +0x1_0000_0000\n      end\n      assert_raise RangeError do\n        m.optional_uint32 = +0x1000_0000_0000_0000_0000_0000 # force Bignum\n      end\n      assert_raise RangeError do\n        m.optional_uint32 = 1e12\n      end\n      assert_raise RangeError do\n        m.optional_uint32 = 1.5\n      end\n\n      m.optional_int64 = 0\n      m.optional_int64 = -0x8000_0000_0000_0000\n      m.optional_int64 = +0x7fff_ffff_ffff_ffff\n      m.optional_int64 = 1.0\n      m.optional_int64 = -1.0\n      m.optional_int64 = 8e18\n      m.optional_int64 = -8e18\n      assert_raise RangeError do\n        m.optional_int64 = -0x8000_0000_0000_0001\n      end\n      assert_raise RangeError do\n        m.optional_int64 = +0x8000_0000_0000_0000\n      end\n      assert_raise RangeError do\n        m.optional_int64 = +0x1000_0000_0000_0000_0000_0000 # force Bignum\n      end\n      assert_raise RangeError do\n        m.optional_int64 = 1e50\n      end\n      assert_raise RangeError do\n        m.optional_int64 = 1.5\n      end\n\n      m.optional_uint64 = 0\n      m.optional_uint64 = +0xffff_ffff_ffff_ffff\n      m.optional_uint64 = 1.0\n      m.optional_uint64 = 16e18\n      assert_raise RangeError do\n        m.optional_uint64 = -1\n      end\n      assert_raise RangeError do\n        m.optional_uint64 = -1.5\n      end\n      assert_raise RangeError do\n        m.optional_uint64 = -1.5e12\n      end\n      assert_raise RangeError do\n        m.optional_uint64 = -0x1_0000_0000_0000_0000\n      end\n      assert_raise RangeError do\n        m.optional_uint64 = +0x1_0000_0000_0000_0000\n      end\n      assert_raise RangeError do\n        m.optional_uint64 = +0x1000_0000_0000_0000_0000_0000 # force Bignum\n      end\n      assert_raise RangeError do\n        m.optional_uint64 = 1e50\n      end\n      assert_raise RangeError do\n        m.optional_uint64 = 1.5\n      end\n    end\n\n    def test_stress_test\n      m = TestMessage.new\n      m.optional_int32 = 42\n      m.optional_int64 = 0x100000000\n      m.optional_string = \"hello world\"\n      10.times do m.repeated_msg.push TestMessage2.new(:foo => 42) end\n      10.times do m.repeated_string.push \"hello world\" end\n\n      data = TestMessage.encode(m)\n\n      l = 0\n      10_000.times do\n        m = TestMessage.decode(data)\n        data_new = TestMessage.encode(m)\n        assert data_new == data\n        data = data_new\n      end\n    end\n\n    def test_reflection\n      m = TestMessage.new(:optional_int32 => 1234)\n      msgdef = m.class.descriptor\n      assert msgdef.class == Google::Protobuf::Descriptor\n      assert msgdef.any? {|field| field.name == \"optional_int32\"}\n      optional_int32 = msgdef.lookup \"optional_int32\"\n      assert optional_int32.class == Google::Protobuf::FieldDescriptor\n      assert optional_int32 != nil\n      assert optional_int32.name == \"optional_int32\"\n      assert optional_int32.type == :int32\n      optional_int32.set(m, 5678)\n      assert m.optional_int32 == 5678\n      m.optional_int32 = 1000\n      assert optional_int32.get(m) == 1000\n\n      optional_msg = msgdef.lookup \"optional_msg\"\n      assert optional_msg.subtype == TestMessage2.descriptor\n\n      optional_msg.set(m, optional_msg.subtype.msgclass.new)\n\n      assert msgdef.msgclass == TestMessage\n\n      optional_enum = msgdef.lookup \"optional_enum\"\n      assert optional_enum.subtype == TestEnum.descriptor\n      assert optional_enum.subtype.class == Google::Protobuf::EnumDescriptor\n      optional_enum.subtype.each do |k, v|\n        # set with integer, check resolution to symbolic name\n        optional_enum.set(m, v)\n        assert optional_enum.get(m) == k\n      end\n    end\n\n    def test_json\n      # TODO: Fix JSON in JRuby version.\n      return if RUBY_PLATFORM == \"java\"\n      m = TestMessage.new(:optional_int32 => 1234,\n                          :optional_int64 => -0x1_0000_0000,\n                          :optional_uint32 => 0x8000_0000,\n                          :optional_uint64 => 0xffff_ffff_ffff_ffff,\n                          :optional_bool => true,\n                          :optional_float => 1.0,\n                          :optional_double => -1e100,\n                          :optional_string => \"Test string\",\n                          :optional_bytes => [\"FFFFFFFF\"].pack('H*'),\n                          :optional_msg => TestMessage2.new(:foo => 42),\n                          :repeated_int32 => [1, 2, 3, 4],\n                          :repeated_string => [\"a\", \"b\", \"c\"],\n                          :repeated_bool => [true, false, true, false],\n                          :repeated_msg => [TestMessage2.new(:foo => 1),\n                                            TestMessage2.new(:foo => 2)])\n\n      json_text = TestMessage.encode_json(m)\n      m2 = TestMessage.decode_json(json_text)\n      assert m == m2\n\n      # Crash case from GitHub issue 283.\n      bar = Bar.new(msg: \"bar\")\n      baz1 = Baz.new(msg: \"baz\")\n      baz2 = Baz.new(msg: \"quux\")\n      Foo.encode_json(Foo.new)\n      Foo.encode_json(Foo.new(bar: bar))\n      Foo.encode_json(Foo.new(bar: bar, baz: [baz1, baz2]))\n    end\n\n    def test_json_maps\n      # TODO: Fix JSON in JRuby version.\n      return if RUBY_PLATFORM == \"java\"\n      m = MapMessage.new(:map_string_int32 => {\"a\" => 1})\n      expected = '{\"mapStringInt32\":{\"a\":1},\"mapStringMsg\":{}}'\n      expected_preserve = '{\"map_string_int32\":{\"a\":1},\"map_string_msg\":{}}'\n      assert_equal expected, MapMessage.encode_json(m, :emit_defaults => true)\n\n      json = MapMessage.encode_json(m, :preserve_proto_fieldnames => true, :emit_defaults => true)\n      assert_equal expected_preserve, json\n\n      m2 = MapMessage.decode_json(MapMessage.encode_json(m))\n      assert m == m2\n    end\n  end\nend\n", "// Protocol Buffers - Google's data interchange format\n// Copyright 2014 Google Inc.  All rights reserved.\n// https://developers.google.com/protocol-buffers/\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n#include \"message.h\"\n\n#include \"convert.h\"\n#include \"defs.h\"\n#include \"map.h\"\n#include \"protobuf.h\"\n#include \"repeated_field.h\"\n\nstatic VALUE cParseError = Qnil;\nstatic VALUE cAbstractMessage = Qnil;\nstatic ID descriptor_instancevar_interned;\n\nstatic VALUE initialize_rb_class_with_no_args(VALUE klass) {\n  return rb_funcall(klass, rb_intern(\"new\"), 0);\n}\n\nVALUE MessageOrEnum_GetDescriptor(VALUE klass) {\n  return rb_ivar_get(klass, descriptor_instancevar_interned);\n}\n\n// -----------------------------------------------------------------------------\n// Class/module creation from msgdefs and enumdefs, respectively.\n// -----------------------------------------------------------------------------\n\ntypedef struct {\n  VALUE arena;\n  const upb_Message* msg;  // Can get as mutable when non-frozen.\n  const upb_MessageDef*\n      msgdef;  // kept alive by self.class.descriptor reference.\n} Message;\n\nstatic void Message_mark(void* _self) {\n  Message* self = (Message*)_self;\n  rb_gc_mark(self->arena);\n}\n\nstatic rb_data_type_t Message_type = {\n    \"Message\",\n    {Message_mark, RUBY_DEFAULT_FREE, NULL},\n    .flags = RUBY_TYPED_FREE_IMMEDIATELY,\n};\n\nstatic Message* ruby_to_Message(VALUE msg_rb) {\n  Message* msg;\n  TypedData_Get_Struct(msg_rb, Message, &Message_type, msg);\n  return msg;\n}\n\nstatic VALUE Message_alloc(VALUE klass) {\n  VALUE descriptor = rb_ivar_get(klass, descriptor_instancevar_interned);\n  Message* msg = ALLOC(Message);\n  VALUE ret;\n\n  msg->msgdef = Descriptor_GetMsgDef(descriptor);\n  msg->arena = Qnil;\n  msg->msg = NULL;\n\n  ret = TypedData_Wrap_Struct(klass, &Message_type, msg);\n  rb_ivar_set(ret, descriptor_instancevar_interned, descriptor);\n\n  return ret;\n}\n\nconst upb_Message* Message_Get(VALUE msg_rb, const upb_MessageDef** m) {\n  Message* msg = ruby_to_Message(msg_rb);\n  if (m) *m = msg->msgdef;\n  return msg->msg;\n}\n\nupb_Message* Message_GetMutable(VALUE msg_rb, const upb_MessageDef** m) {\n  rb_check_frozen(msg_rb);\n  return (upb_Message*)Message_Get(msg_rb, m);\n}\n\nvoid Message_InitPtr(VALUE self_, upb_Message* msg, VALUE arena) {\n  Message* self = ruby_to_Message(self_);\n  self->msg = msg;\n  self->arena = arena;\n  ObjectCache_Add(msg, self_);\n}\n\nVALUE Message_GetArena(VALUE msg_rb) {\n  Message* msg = ruby_to_Message(msg_rb);\n  return msg->arena;\n}\n\nvoid Message_CheckClass(VALUE klass) {\n  if (rb_get_alloc_func(klass) != &Message_alloc) {\n    rb_raise(rb_eArgError,\n             \"Message class was not returned by the DescriptorPool.\");\n  }\n}\n\nVALUE Message_GetRubyWrapper(upb_Message* msg, const upb_MessageDef* m,\n                             VALUE arena) {\n  if (msg == NULL) return Qnil;\n\n  VALUE val = ObjectCache_Get(msg);\n\n  if (val == Qnil) {\n    VALUE klass = Descriptor_DefToClass(m);\n    val = Message_alloc(klass);\n    Message_InitPtr(val, msg, arena);\n  }\n\n  return val;\n}\n\nvoid Message_PrintMessage(StringBuilder* b, const upb_Message* msg,\n                          const upb_MessageDef* m) {\n  bool first = true;\n  int n = upb_MessageDef_FieldCount(m);\n  VALUE klass = Descriptor_DefToClass(m);\n  StringBuilder_Printf(b, \"<%s: \", rb_class2name(klass));\n\n  for (int i = 0; i < n; i++) {\n    const upb_FieldDef* field = upb_MessageDef_Field(m, i);\n\n    if (upb_FieldDef_HasPresence(field) && !upb_Message_Has(msg, field)) {\n      continue;\n    }\n\n    if (!first) {\n      StringBuilder_Printf(b, \", \");\n    } else {\n      first = false;\n    }\n\n    upb_MessageValue msgval = upb_Message_Get(msg, field);\n\n    StringBuilder_Printf(b, \"%s: \", upb_FieldDef_Name(field));\n\n    if (upb_FieldDef_IsMap(field)) {\n      const upb_MessageDef* entry_m = upb_FieldDef_MessageSubDef(field);\n      const upb_FieldDef* key_f = upb_MessageDef_FindFieldByNumber(entry_m, 1);\n      const upb_FieldDef* val_f = upb_MessageDef_FindFieldByNumber(entry_m, 2);\n      TypeInfo val_info = TypeInfo_get(val_f);\n      Map_Inspect(b, msgval.map_val, upb_FieldDef_CType(key_f), val_info);\n    } else if (upb_FieldDef_IsRepeated(field)) {\n      RepeatedField_Inspect(b, msgval.array_val, TypeInfo_get(field));\n    } else {\n      StringBuilder_PrintMsgval(b, msgval, TypeInfo_get(field));\n    }\n  }\n\n  StringBuilder_Printf(b, \">\");\n}\n\n// Helper functions for #method_missing ////////////////////////////////////////\n\nenum {\n  METHOD_UNKNOWN = 0,\n  METHOD_GETTER = 1,\n  METHOD_SETTER = 2,\n  METHOD_CLEAR = 3,\n  METHOD_PRESENCE = 4,\n  METHOD_ENUM_GETTER = 5,\n  METHOD_WRAPPER_GETTER = 6,\n  METHOD_WRAPPER_SETTER = 7\n};\n\n// Check if the field is a well known wrapper type\nstatic bool IsWrapper(const upb_MessageDef* m) {\n  if (!m) return false;\n  switch (upb_MessageDef_WellKnownType(m)) {\n    case kUpb_WellKnown_DoubleValue:\n    case kUpb_WellKnown_FloatValue:\n    case kUpb_WellKnown_Int64Value:\n    case kUpb_WellKnown_UInt64Value:\n    case kUpb_WellKnown_Int32Value:\n    case kUpb_WellKnown_UInt32Value:\n    case kUpb_WellKnown_StringValue:\n    case kUpb_WellKnown_BytesValue:\n    case kUpb_WellKnown_BoolValue:\n      return true;\n    default:\n      return false;\n  }\n}\n\nstatic bool IsFieldWrapper(const upb_FieldDef* f) {\n  return IsWrapper(upb_FieldDef_MessageSubDef(f));\n}\n\nstatic bool Match(const upb_MessageDef* m, const char* name,\n                  const upb_FieldDef** f, const upb_OneofDef** o,\n                  const char* prefix, const char* suffix) {\n  size_t sp = strlen(prefix);\n  size_t ss = strlen(suffix);\n  size_t sn = strlen(name);\n\n  if (sn <= sp + ss) return false;\n\n  if (memcmp(name, prefix, sp) != 0 ||\n      memcmp(name + sn - ss, suffix, ss) != 0) {\n    return false;\n  }\n\n  return upb_MessageDef_FindByNameWithSize(m, name + sp, sn - sp - ss, f, o);\n}\n\nstatic int extract_method_call(VALUE method_name, Message* self,\n                               const upb_FieldDef** f, const upb_OneofDef** o) {\n  const upb_MessageDef* m = self->msgdef;\n  const char* name;\n\n  Check_Type(method_name, T_SYMBOL);\n  name = rb_id2name(SYM2ID(method_name));\n\n  if (Match(m, name, f, o, \"\", \"\")) return METHOD_GETTER;\n  if (Match(m, name, f, o, \"\", \"=\")) return METHOD_SETTER;\n  if (Match(m, name, f, o, \"clear_\", \"\")) return METHOD_CLEAR;\n  if (Match(m, name, f, o, \"has_\", \"?\") &&\n      (*o || (*f && upb_FieldDef_HasPresence(*f)))) {\n    // Disallow oneof hazzers for proto3.\n    // TODO(haberman): remove this test when we are enabling oneof hazzers for\n    // proto3.\n    if (*f && !upb_FieldDef_IsSubMessage(*f) &&\n        upb_FieldDef_RealContainingOneof(*f) &&\n        upb_MessageDef_Syntax(upb_FieldDef_ContainingType(*f)) !=\n            kUpb_Syntax_Proto2) {\n      return METHOD_UNKNOWN;\n    }\n    return METHOD_PRESENCE;\n  }\n  if (Match(m, name, f, o, \"\", \"_as_value\") && *f &&\n      !upb_FieldDef_IsRepeated(*f) && IsFieldWrapper(*f)) {\n    return METHOD_WRAPPER_GETTER;\n  }\n  if (Match(m, name, f, o, \"\", \"_as_value=\") && *f &&\n      !upb_FieldDef_IsRepeated(*f) && IsFieldWrapper(*f)) {\n    return METHOD_WRAPPER_SETTER;\n  }\n  if (Match(m, name, f, o, \"\", \"_const\") && *f &&\n      upb_FieldDef_CType(*f) == kUpb_CType_Enum) {\n    return METHOD_ENUM_GETTER;\n  }\n\n  return METHOD_UNKNOWN;\n}\n\nstatic VALUE Message_oneof_accessor(VALUE _self, const upb_OneofDef* o,\n                                    int accessor_type) {\n  Message* self = ruby_to_Message(_self);\n  const upb_FieldDef* oneof_field = upb_Message_WhichOneof(self->msg, o);\n\n  switch (accessor_type) {\n    case METHOD_PRESENCE:\n      return oneof_field == NULL ? Qfalse : Qtrue;\n    case METHOD_CLEAR:\n      if (oneof_field != NULL) {\n        upb_Message_ClearField(Message_GetMutable(_self, NULL), oneof_field);\n      }\n      return Qnil;\n    case METHOD_GETTER:\n      return oneof_field == NULL\n                 ? Qnil\n                 : ID2SYM(rb_intern(upb_FieldDef_Name(oneof_field)));\n    case METHOD_SETTER:\n      rb_raise(rb_eRuntimeError, \"Oneof accessors are read-only.\");\n  }\n  rb_raise(rb_eRuntimeError, \"Invalid access of oneof field.\");\n}\n\nstatic void Message_setfield(upb_Message* msg, const upb_FieldDef* f, VALUE val,\n                             upb_Arena* arena) {\n  upb_MessageValue msgval;\n  if (upb_FieldDef_IsMap(f)) {\n    msgval.map_val = Map_GetUpbMap(val, f, arena);\n  } else if (upb_FieldDef_IsRepeated(f)) {\n    msgval.array_val = RepeatedField_GetUpbArray(val, f, arena);\n  } else {\n    if (val == Qnil &&\n        (upb_FieldDef_IsSubMessage(f) || upb_FieldDef_RealContainingOneof(f))) {\n      upb_Message_ClearField(msg, f);\n      return;\n    }\n    msgval =\n        Convert_RubyToUpb(val, upb_FieldDef_Name(f), TypeInfo_get(f), arena);\n  }\n  upb_Message_Set(msg, f, msgval, arena);\n}\n\nVALUE Message_getfield(VALUE _self, const upb_FieldDef* f) {\n  Message* self = ruby_to_Message(_self);\n  // This is a special-case: upb_Message_Mutable() for map & array are logically\n  // const (they will not change what is serialized) but physically\n  // non-const, as they do allocate a repeated field or map. The logical\n  // constness means it's ok to do even if the message is frozen.\n  upb_Message* msg = (upb_Message*)self->msg;\n  upb_Arena* arena = Arena_get(self->arena);\n  if (upb_FieldDef_IsMap(f)) {\n    upb_Map* map = upb_Message_Mutable(msg, f, arena).map;\n    const upb_FieldDef* key_f = map_field_key(f);\n    const upb_FieldDef* val_f = map_field_value(f);\n    upb_CType key_type = upb_FieldDef_CType(key_f);\n    TypeInfo value_type_info = TypeInfo_get(val_f);\n    return Map_GetRubyWrapper(map, key_type, value_type_info, self->arena);\n  } else if (upb_FieldDef_IsRepeated(f)) {\n    upb_Array* arr = upb_Message_Mutable(msg, f, arena).array;\n    return RepeatedField_GetRubyWrapper(arr, TypeInfo_get(f), self->arena);\n  } else if (upb_FieldDef_IsSubMessage(f)) {\n    if (!upb_Message_Has(self->msg, f)) return Qnil;\n    upb_Message* submsg = upb_Message_Mutable(msg, f, arena).msg;\n    const upb_MessageDef* m = upb_FieldDef_MessageSubDef(f);\n    return Message_GetRubyWrapper(submsg, m, self->arena);\n  } else {\n    upb_MessageValue msgval = upb_Message_Get(self->msg, f);\n    return Convert_UpbToRuby(msgval, TypeInfo_get(f), self->arena);\n  }\n}\n\nstatic VALUE Message_field_accessor(VALUE _self, const upb_FieldDef* f,\n                                    int accessor_type, int argc, VALUE* argv) {\n  upb_Arena* arena = Arena_get(Message_GetArena(_self));\n\n  switch (accessor_type) {\n    case METHOD_SETTER:\n      Message_setfield(Message_GetMutable(_self, NULL), f, argv[1], arena);\n      return Qnil;\n    case METHOD_CLEAR:\n      upb_Message_ClearField(Message_GetMutable(_self, NULL), f);\n      return Qnil;\n    case METHOD_PRESENCE:\n      if (!upb_FieldDef_HasPresence(f)) {\n        rb_raise(rb_eRuntimeError, \"Field does not have presence.\");\n      }\n      return upb_Message_Has(Message_Get(_self, NULL), f);\n    case METHOD_WRAPPER_GETTER: {\n      Message* self = ruby_to_Message(_self);\n      if (upb_Message_Has(self->msg, f)) {\n        PBRUBY_ASSERT(upb_FieldDef_IsSubMessage(f) &&\n                      !upb_FieldDef_IsRepeated(f));\n        upb_MessageValue wrapper = upb_Message_Get(self->msg, f);\n        const upb_MessageDef* wrapper_m = upb_FieldDef_MessageSubDef(f);\n        const upb_FieldDef* value_f =\n            upb_MessageDef_FindFieldByNumber(wrapper_m, 1);\n        upb_MessageValue value = upb_Message_Get(wrapper.msg_val, value_f);\n        return Convert_UpbToRuby(value, TypeInfo_get(value_f), self->arena);\n      } else {\n        return Qnil;\n      }\n    }\n    case METHOD_WRAPPER_SETTER: {\n      upb_Message* msg = Message_GetMutable(_self, NULL);\n      if (argv[1] == Qnil) {\n        upb_Message_ClearField(msg, f);\n      } else {\n        const upb_FieldDef* val_f =\n            upb_MessageDef_FindFieldByNumber(upb_FieldDef_MessageSubDef(f), 1);\n        upb_MessageValue msgval = Convert_RubyToUpb(\n            argv[1], upb_FieldDef_Name(f), TypeInfo_get(val_f), arena);\n        upb_Message* wrapper = upb_Message_Mutable(msg, f, arena).msg;\n        upb_Message_Set(wrapper, val_f, msgval, arena);\n      }\n      return Qnil;\n    }\n    case METHOD_ENUM_GETTER: {\n      upb_MessageValue msgval = upb_Message_Get(Message_Get(_self, NULL), f);\n\n      if (upb_FieldDef_Label(f) == kUpb_Label_Repeated) {\n        // Map repeated fields to a new type with ints\n        VALUE arr = rb_ary_new();\n        size_t i, n = upb_Array_Size(msgval.array_val);\n        for (i = 0; i < n; i++) {\n          upb_MessageValue elem = upb_Array_Get(msgval.array_val, i);\n          rb_ary_push(arr, INT2NUM(elem.int32_val));\n        }\n        return arr;\n      } else {\n        return INT2NUM(msgval.int32_val);\n      }\n    }\n    case METHOD_GETTER:\n      return Message_getfield(_self, f);\n    default:\n      rb_raise(rb_eRuntimeError, \"Internal error, no such accessor: %d\",\n               accessor_type);\n  }\n}\n\n/*\n * call-seq:\n *     Message.method_missing(*args)\n *\n * Provides accessors and setters and methods to clear and check for presence of\n * message fields according to their field names.\n *\n * For any field whose name does not conflict with a built-in method, an\n * accessor is provided with the same name as the field, and a setter is\n * provided with the name of the field plus the '=' suffix. Thus, given a\n * message instance 'msg' with field 'foo', the following code is valid:\n *\n *     msg.foo = 42\n *     puts msg.foo\n *\n * This method also provides read-only accessors for oneofs. If a oneof exists\n * with name 'my_oneof', then msg.my_oneof will return a Ruby symbol equal to\n * the name of the field in that oneof that is currently set, or nil if none.\n *\n * It also provides methods of the form 'clear_fieldname' to clear the value\n * of the field 'fieldname'. For basic data types, this will set the default\n * value of the field.\n *\n * Additionally, it provides methods of the form 'has_fieldname?', which returns\n * true if the field 'fieldname' is set in the message object, else false. For\n * 'proto3' syntax, calling this for a basic type field will result in an error.\n */\nstatic VALUE Message_method_missing(int argc, VALUE* argv, VALUE _self) {\n  Message* self = ruby_to_Message(_self);\n  const upb_OneofDef* o;\n  const upb_FieldDef* f;\n  int accessor_type;\n\n  if (argc < 1) {\n    rb_raise(rb_eArgError, \"Expected method name as first argument.\");\n  }\n\n  accessor_type = extract_method_call(argv[0], self, &f, &o);\n\n  if (accessor_type == METHOD_UNKNOWN) return rb_call_super(argc, argv);\n\n  // Validate argument count.\n  switch (accessor_type) {\n    case METHOD_SETTER:\n    case METHOD_WRAPPER_SETTER:\n      if (argc != 2) {\n        rb_raise(rb_eArgError, \"Expected 2 arguments, received %d\", argc);\n      }\n      rb_check_frozen(_self);\n      break;\n    default:\n      if (argc != 1) {\n        rb_raise(rb_eArgError, \"Expected 1 argument, received %d\", argc);\n      }\n      break;\n  }\n\n  // Dispatch accessor.\n  if (o != NULL) {\n    return Message_oneof_accessor(_self, o, accessor_type);\n  } else {\n    return Message_field_accessor(_self, f, accessor_type, argc, argv);\n  }\n}\n\nstatic VALUE Message_respond_to_missing(int argc, VALUE* argv, VALUE _self) {\n  Message* self = ruby_to_Message(_self);\n  const upb_OneofDef* o;\n  const upb_FieldDef* f;\n  int accessor_type;\n\n  if (argc < 1) {\n    rb_raise(rb_eArgError, \"Expected method name as first argument.\");\n  }\n\n  accessor_type = extract_method_call(argv[0], self, &f, &o);\n\n  if (accessor_type == METHOD_UNKNOWN) {\n    return rb_call_super(argc, argv);\n  } else if (o != NULL) {\n    return accessor_type == METHOD_SETTER ? Qfalse : Qtrue;\n  } else {\n    return Qtrue;\n  }\n}\n\nvoid Message_InitFromValue(upb_Message* msg, const upb_MessageDef* m, VALUE val,\n                           upb_Arena* arena);\n\ntypedef struct {\n  upb_Map* map;\n  TypeInfo key_type;\n  TypeInfo val_type;\n  upb_Arena* arena;\n} MapInit;\n\nstatic int Map_initialize_kwarg(VALUE key, VALUE val, VALUE _self) {\n  MapInit* map_init = (MapInit*)_self;\n  upb_MessageValue k, v;\n  k = Convert_RubyToUpb(key, \"\", map_init->key_type, NULL);\n\n  if (map_init->val_type.type == kUpb_CType_Message && TYPE(val) == T_HASH) {\n    upb_Message* msg =\n        upb_Message_New(map_init->val_type.def.msgdef, map_init->arena);\n    Message_InitFromValue(msg, map_init->val_type.def.msgdef, val,\n                          map_init->arena);\n    v.msg_val = msg;\n  } else {\n    v = Convert_RubyToUpb(val, \"\", map_init->val_type, map_init->arena);\n  }\n  upb_Map_Set(map_init->map, k, v, map_init->arena);\n  return ST_CONTINUE;\n}\n\nstatic void Map_InitFromValue(upb_Map* map, const upb_FieldDef* f, VALUE val,\n                              upb_Arena* arena) {\n  const upb_MessageDef* entry_m = upb_FieldDef_MessageSubDef(f);\n  const upb_FieldDef* key_f = upb_MessageDef_FindFieldByNumber(entry_m, 1);\n  const upb_FieldDef* val_f = upb_MessageDef_FindFieldByNumber(entry_m, 2);\n  if (TYPE(val) != T_HASH) {\n    rb_raise(rb_eArgError,\n             \"Expected Hash object as initializer value for map field '%s' \"\n             \"(given %s).\",\n             upb_FieldDef_Name(f), rb_class2name(CLASS_OF(val)));\n  }\n  MapInit map_init = {map, TypeInfo_get(key_f), TypeInfo_get(val_f), arena};\n  rb_hash_foreach(val, Map_initialize_kwarg, (VALUE)&map_init);\n}\n\nstatic upb_MessageValue MessageValue_FromValue(VALUE val, TypeInfo info,\n                                               upb_Arena* arena) {\n  if (info.type == kUpb_CType_Message) {\n    upb_MessageValue msgval;\n    upb_Message* msg = upb_Message_New(info.def.msgdef, arena);\n    Message_InitFromValue(msg, info.def.msgdef, val, arena);\n    msgval.msg_val = msg;\n    return msgval;\n  } else {\n    return Convert_RubyToUpb(val, \"\", info, arena);\n  }\n}\n\nstatic void RepeatedField_InitFromValue(upb_Array* arr, const upb_FieldDef* f,\n                                        VALUE val, upb_Arena* arena) {\n  TypeInfo type_info = TypeInfo_get(f);\n\n  if (TYPE(val) != T_ARRAY) {\n    rb_raise(rb_eArgError,\n             \"Expected array as initializer value for repeated field '%s' \"\n             \"(given %s).\",\n             upb_FieldDef_Name(f), rb_class2name(CLASS_OF(val)));\n  }\n\n  for (int i = 0; i < RARRAY_LEN(val); i++) {\n    VALUE entry = rb_ary_entry(val, i);\n    upb_MessageValue msgval;\n    if (upb_FieldDef_IsSubMessage(f) && TYPE(entry) == T_HASH) {\n      msgval = MessageValue_FromValue(entry, type_info, arena);\n    } else {\n      msgval = Convert_RubyToUpb(entry, upb_FieldDef_Name(f), type_info, arena);\n    }\n    upb_Array_Append(arr, msgval, arena);\n  }\n}\n\nstatic void Message_InitFieldFromValue(upb_Message* msg, const upb_FieldDef* f,\n                                       VALUE val, upb_Arena* arena) {\n  if (TYPE(val) == T_NIL) return;\n\n  if (upb_FieldDef_IsMap(f)) {\n    upb_Map* map = upb_Message_Mutable(msg, f, arena).map;\n    Map_InitFromValue(map, f, val, arena);\n  } else if (upb_FieldDef_Label(f) == kUpb_Label_Repeated) {\n    upb_Array* arr = upb_Message_Mutable(msg, f, arena).array;\n    RepeatedField_InitFromValue(arr, f, val, arena);\n  } else if (upb_FieldDef_IsSubMessage(f)) {\n    if (TYPE(val) == T_HASH) {\n      upb_Message* submsg = upb_Message_Mutable(msg, f, arena).msg;\n      Message_InitFromValue(submsg, upb_FieldDef_MessageSubDef(f), val, arena);\n    } else {\n      Message_setfield(msg, f, val, arena);\n    }\n  } else {\n    upb_MessageValue msgval =\n        Convert_RubyToUpb(val, upb_FieldDef_Name(f), TypeInfo_get(f), arena);\n    upb_Message_Set(msg, f, msgval, arena);\n  }\n}\n\ntypedef struct {\n  upb_Message* msg;\n  const upb_MessageDef* msgdef;\n  upb_Arena* arena;\n} MsgInit;\n\nstatic int Message_initialize_kwarg(VALUE key, VALUE val, VALUE _self) {\n  MsgInit* msg_init = (MsgInit*)_self;\n  const char* name;\n\n  if (TYPE(key) == T_STRING) {\n    name = RSTRING_PTR(key);\n  } else if (TYPE(key) == T_SYMBOL) {\n    name = RSTRING_PTR(rb_id2str(SYM2ID(key)));\n  } else {\n    rb_raise(rb_eArgError,\n             \"Expected string or symbols as hash keys when initializing proto \"\n             \"from hash.\");\n  }\n\n  const upb_FieldDef* f =\n      upb_MessageDef_FindFieldByName(msg_init->msgdef, name);\n\n  if (f == NULL) {\n    rb_raise(rb_eArgError,\n             \"Unknown field name '%s' in initialization map entry.\", name);\n  }\n\n  Message_InitFieldFromValue(msg_init->msg, f, val, msg_init->arena);\n  return ST_CONTINUE;\n}\n\nvoid Message_InitFromValue(upb_Message* msg, const upb_MessageDef* m, VALUE val,\n                           upb_Arena* arena) {\n  MsgInit msg_init = {msg, m, arena};\n  if (TYPE(val) == T_HASH) {\n    rb_hash_foreach(val, Message_initialize_kwarg, (VALUE)&msg_init);\n  } else {\n    rb_raise(rb_eArgError, \"Expected hash arguments or message, not %s\",\n             rb_class2name(CLASS_OF(val)));\n  }\n}\n\n/*\n * call-seq:\n *     Message.new(kwargs) => new_message\n *\n * Creates a new instance of the given message class. Keyword arguments may be\n * provided with keywords corresponding to field names.\n *\n * Note that no literal Message class exists. Only concrete classes per message\n * type exist, as provided by the #msgclass method on Descriptors after they\n * have been added to a pool. The method definitions described here on the\n * Message class are provided on each concrete message class.\n */\nstatic VALUE Message_initialize(int argc, VALUE* argv, VALUE _self) {\n  Message* self = ruby_to_Message(_self);\n  VALUE arena_rb = Arena_new();\n  upb_Arena* arena = Arena_get(arena_rb);\n  upb_Message* msg = upb_Message_New(self->msgdef, arena);\n\n  Message_InitPtr(_self, msg, arena_rb);\n\n  if (argc == 0) {\n    return Qnil;\n  }\n  if (argc != 1) {\n    rb_raise(rb_eArgError, \"Expected 0 or 1 arguments.\");\n  }\n  Message_InitFromValue((upb_Message*)self->msg, self->msgdef, argv[0], arena);\n  return Qnil;\n}\n\n/*\n * call-seq:\n *     Message.dup => new_message\n *\n * Performs a shallow copy of this message and returns the new copy.\n */\nstatic VALUE Message_dup(VALUE _self) {\n  Message* self = ruby_to_Message(_self);\n  VALUE new_msg = rb_class_new_instance(0, NULL, CLASS_OF(_self));\n  Message* new_msg_self = ruby_to_Message(new_msg);\n  size_t size = upb_MessageDef_MiniTable(self->msgdef)->size;\n\n  // TODO(copy unknown fields?)\n  // TODO(use official upb msg copy function)\n  memcpy((upb_Message*)new_msg_self->msg, self->msg, size);\n  Arena_fuse(self->arena, Arena_get(new_msg_self->arena));\n  return new_msg;\n}\n\n// Support function for Message_eq, and also used by other #eq functions.\nbool Message_Equal(const upb_Message* m1, const upb_Message* m2,\n                   const upb_MessageDef* m) {\n  if (m1 == m2) return true;\n\n  size_t size1, size2;\n  int encode_opts = kUpb_Encode_SkipUnknown | kUpb_Encode_Deterministic;\n  upb_Arena* arena_tmp = upb_Arena_New();\n  const upb_MiniTable* layout = upb_MessageDef_MiniTable(m);\n\n  // Compare deterministically serialized payloads with no unknown fields.\n  char* data1 = upb_Encode(m1, layout, encode_opts, arena_tmp, &size1);\n  char* data2 = upb_Encode(m2, layout, encode_opts, arena_tmp, &size2);\n\n  if (data1 && data2) {\n    bool ret = (size1 == size2) && (memcmp(data1, data2, size1) == 0);\n    upb_Arena_Free(arena_tmp);\n    return ret;\n  } else {\n    upb_Arena_Free(arena_tmp);\n    rb_raise(cParseError, \"Error comparing messages\");\n  }\n}\n\n/*\n * call-seq:\n *     Message.==(other) => boolean\n *\n * Performs a deep comparison of this message with another. Messages are equal\n * if they have the same type and if each field is equal according to the :==\n * method's semantics (a more efficient comparison may actually be done if the\n * field is of a primitive type).\n */\nstatic VALUE Message_eq(VALUE _self, VALUE _other) {\n  if (CLASS_OF(_self) != CLASS_OF(_other)) return Qfalse;\n\n  Message* self = ruby_to_Message(_self);\n  Message* other = ruby_to_Message(_other);\n  assert(self->msgdef == other->msgdef);\n\n  return Message_Equal(self->msg, other->msg, self->msgdef) ? Qtrue : Qfalse;\n}\n\nuint64_t Message_Hash(const upb_Message* msg, const upb_MessageDef* m,\n                      uint64_t seed) {\n  upb_Arena* arena = upb_Arena_New();\n  const char* data;\n  size_t size;\n\n  // Hash a deterministically serialized payloads with no unknown fields.\n  data = upb_Encode(msg, upb_MessageDef_MiniTable(m),\n                    kUpb_Encode_SkipUnknown | kUpb_Encode_Deterministic, arena,\n                    &size);\n\n  if (data) {\n    uint64_t ret = _upb_Hash(data, size, seed);\n    upb_Arena_Free(arena);\n    return ret;\n  } else {\n    upb_Arena_Free(arena);\n    rb_raise(cParseError, \"Error calculating hash\");\n  }\n}\n\n/*\n * call-seq:\n *     Message.hash => hash_value\n *\n * Returns a hash value that represents this message's field values.\n */\nstatic VALUE Message_hash(VALUE _self) {\n  Message* self = ruby_to_Message(_self);\n  uint64_t hash_value = Message_Hash(self->msg, self->msgdef, 0);\n  // RUBY_FIXNUM_MAX should be one less than a power of 2.\n  assert((RUBY_FIXNUM_MAX & (RUBY_FIXNUM_MAX + 1)) == 0);\n  return INT2FIX(hash_value & RUBY_FIXNUM_MAX);\n}\n\n/*\n * call-seq:\n *     Message.inspect => string\n *\n * Returns a human-readable string representing this message. It will be\n * formatted as \"<MessageType: field1: value1, field2: value2, ...>\". Each\n * field's value is represented according to its own #inspect method.\n */\nstatic VALUE Message_inspect(VALUE _self) {\n  Message* self = ruby_to_Message(_self);\n\n  StringBuilder* builder = StringBuilder_New();\n  Message_PrintMessage(builder, self->msg, self->msgdef);\n  VALUE ret = StringBuilder_ToRubyString(builder);\n  StringBuilder_Free(builder);\n  return ret;\n}\n\n// Support functions for Message_to_h //////////////////////////////////////////\n\nstatic VALUE RepeatedField_CreateArray(const upb_Array* arr,\n                                       TypeInfo type_info) {\n  int size = arr ? upb_Array_Size(arr) : 0;\n  VALUE ary = rb_ary_new2(size);\n\n  for (int i = 0; i < size; i++) {\n    upb_MessageValue msgval = upb_Array_Get(arr, i);\n    VALUE val = Scalar_CreateHash(msgval, type_info);\n    rb_ary_push(ary, val);\n  }\n\n  return ary;\n}\n\nstatic VALUE Message_CreateHash(const upb_Message* msg,\n                                const upb_MessageDef* m) {\n  if (!msg) return Qnil;\n\n  VALUE hash = rb_hash_new();\n  int n = upb_MessageDef_FieldCount(m);\n  bool is_proto2;\n\n  // We currently have a few behaviors that are specific to proto2.\n  // This is unfortunate, we should key behaviors off field attributes (like\n  // whether a field has presence), not proto2 vs. proto3. We should see if we\n  // can change this without breaking users.\n  is_proto2 = upb_MessageDef_Syntax(m) == kUpb_Syntax_Proto2;\n\n  for (int i = 0; i < n; i++) {\n    const upb_FieldDef* field = upb_MessageDef_Field(m, i);\n    TypeInfo type_info = TypeInfo_get(field);\n    upb_MessageValue msgval;\n    VALUE msg_value;\n    VALUE msg_key;\n\n    if (!is_proto2 && upb_FieldDef_IsSubMessage(field) &&\n        !upb_FieldDef_IsRepeated(field) && !upb_Message_Has(msg, field)) {\n      // TODO: Legacy behavior, remove when we fix the is_proto2 differences.\n      msg_key = ID2SYM(rb_intern(upb_FieldDef_Name(field)));\n      rb_hash_aset(hash, msg_key, Qnil);\n      continue;\n    }\n\n    // Do not include fields that are not present (oneof or optional fields).\n    if (is_proto2 && upb_FieldDef_HasPresence(field) &&\n        !upb_Message_Has(msg, field)) {\n      continue;\n    }\n\n    msg_key = ID2SYM(rb_intern(upb_FieldDef_Name(field)));\n    msgval = upb_Message_Get(msg, field);\n\n    // Proto2 omits empty map/repeated filds also.\n\n    if (upb_FieldDef_IsMap(field)) {\n      const upb_MessageDef* entry_m = upb_FieldDef_MessageSubDef(field);\n      const upb_FieldDef* key_f = upb_MessageDef_FindFieldByNumber(entry_m, 1);\n      const upb_FieldDef* val_f = upb_MessageDef_FindFieldByNumber(entry_m, 2);\n      upb_CType key_type = upb_FieldDef_CType(key_f);\n      msg_value = Map_CreateHash(msgval.map_val, key_type, TypeInfo_get(val_f));\n    } else if (upb_FieldDef_IsRepeated(field)) {\n      if (is_proto2 &&\n          (!msgval.array_val || upb_Array_Size(msgval.array_val) == 0)) {\n        continue;\n      }\n      msg_value = RepeatedField_CreateArray(msgval.array_val, type_info);\n    } else {\n      msg_value = Scalar_CreateHash(msgval, type_info);\n    }\n\n    rb_hash_aset(hash, msg_key, msg_value);\n  }\n\n  return hash;\n}\n\nVALUE Scalar_CreateHash(upb_MessageValue msgval, TypeInfo type_info) {\n  if (type_info.type == kUpb_CType_Message) {\n    return Message_CreateHash(msgval.msg_val, type_info.def.msgdef);\n  } else {\n    return Convert_UpbToRuby(msgval, type_info, Qnil);\n  }\n}\n\n/*\n * call-seq:\n *     Message.to_h => {}\n *\n * Returns the message as a Ruby Hash object, with keys as symbols.\n */\nstatic VALUE Message_to_h(VALUE _self) {\n  Message* self = ruby_to_Message(_self);\n  return Message_CreateHash(self->msg, self->msgdef);\n}\n\n/*\n * call-seq:\n *     Message.freeze => self\n *\n * Freezes the message object. We have to intercept this so we can pin the\n * Ruby object into memory so we don't forget it's frozen.\n */\nstatic VALUE Message_freeze(VALUE _self) {\n  Message* self = ruby_to_Message(_self);\n  if (!RB_OBJ_FROZEN(_self)) {\n    Arena_Pin(self->arena, _self);\n    RB_OBJ_FREEZE(_self);\n  }\n  return _self;\n}\n\n/*\n * call-seq:\n *     Message.[](index) => value\n *\n * Accesses a field's value by field name. The provided field name should be a\n * string.\n */\nstatic VALUE Message_index(VALUE _self, VALUE field_name) {\n  Message* self = ruby_to_Message(_self);\n  const upb_FieldDef* field;\n\n  Check_Type(field_name, T_STRING);\n  field = upb_MessageDef_FindFieldByName(self->msgdef, RSTRING_PTR(field_name));\n\n  if (field == NULL) {\n    return Qnil;\n  }\n\n  return Message_getfield(_self, field);\n}\n\n/*\n * call-seq:\n *     Message.[]=(index, value)\n *\n * Sets a field's value by field name. The provided field name should be a\n * string.\n */\nstatic VALUE Message_index_set(VALUE _self, VALUE field_name, VALUE value) {\n  Message* self = ruby_to_Message(_self);\n  const upb_FieldDef* f;\n  upb_MessageValue val;\n  upb_Arena* arena = Arena_get(self->arena);\n\n  Check_Type(field_name, T_STRING);\n  f = upb_MessageDef_FindFieldByName(self->msgdef, RSTRING_PTR(field_name));\n\n  if (f == NULL) {\n    rb_raise(rb_eArgError, \"Unknown field: %s\", RSTRING_PTR(field_name));\n  }\n\n  val = Convert_RubyToUpb(value, upb_FieldDef_Name(f), TypeInfo_get(f), arena);\n  upb_Message_Set(Message_GetMutable(_self, NULL), f, val, arena);\n\n  return Qnil;\n}\n\n/*\n * call-seq:\n *     MessageClass.decode(data, options) => message\n *\n * Decodes the given data (as a string containing bytes in protocol buffers wire\n * format) under the interpretration given by this message class's definition\n * and returns a message object with the corresponding field values.\n * @param options [Hash] options for the decoder\n *  recursion_limit: set to maximum decoding depth for message (default is 64)\n */\nstatic VALUE Message_decode(int argc, VALUE* argv, VALUE klass) {\n  VALUE data = argv[0];\n  int options = 0;\n\n  if (argc < 1 || argc > 2) {\n    rb_raise(rb_eArgError, \"Expected 1 or 2 arguments.\");\n  }\n\n  if (argc == 2) {\n    VALUE hash_args = argv[1];\n    if (TYPE(hash_args) != T_HASH) {\n      rb_raise(rb_eArgError, \"Expected hash arguments.\");\n    }\n\n    VALUE depth = rb_hash_lookup(hash_args, ID2SYM(rb_intern(\"recursion_limit\")));\n\n    if (depth != Qnil && TYPE(depth) == T_FIXNUM) {\n      options |= UPB_DECODE_MAXDEPTH(FIX2INT(depth));\n    }\n  }\n\n  if (TYPE(data) != T_STRING) {\n    rb_raise(rb_eArgError, \"Expected string for binary protobuf data.\");\n  }\n\n  VALUE msg_rb = initialize_rb_class_with_no_args(klass);\n  Message* msg = ruby_to_Message(msg_rb);\n\n  upb_DecodeStatus status = upb_Decode(\n      RSTRING_PTR(data), RSTRING_LEN(data), (upb_Message*)msg->msg,\n      upb_MessageDef_MiniTable(msg->msgdef), NULL, options, Arena_get(msg->arena));\n\n  if (status != kUpb_DecodeStatus_Ok) {\n    rb_raise(cParseError, \"Error occurred during parsing\");\n  }\n\n  return msg_rb;\n}\n\n/*\n * call-seq:\n *     MessageClass.decode_json(data, options = {}) => message\n *\n * Decodes the given data (as a string containing bytes in protocol buffers wire\n * format) under the interpretration given by this message class's definition\n * and returns a message object with the corresponding field values.\n *\n *  @param options [Hash] options for the decoder\n *   ignore_unknown_fields: set true to ignore unknown fields (default is to\n *   raise an error)\n */\nstatic VALUE Message_decode_json(int argc, VALUE* argv, VALUE klass) {\n  VALUE data = argv[0];\n  int options = 0;\n  upb_Status status;\n\n  // TODO(haberman): use this message's pool instead.\n  const upb_DefPool* symtab = DescriptorPool_GetSymtab(generated_pool);\n\n  if (argc < 1 || argc > 2) {\n    rb_raise(rb_eArgError, \"Expected 1 or 2 arguments.\");\n  }\n\n  if (argc == 2) {\n    VALUE hash_args = argv[1];\n    if (TYPE(hash_args) != T_HASH) {\n      rb_raise(rb_eArgError, \"Expected hash arguments.\");\n    }\n\n    if (RTEST(rb_hash_lookup2(\n            hash_args, ID2SYM(rb_intern(\"ignore_unknown_fields\")), Qfalse))) {\n      options |= upb_JsonDecode_IgnoreUnknown;\n    }\n  }\n\n  if (TYPE(data) != T_STRING) {\n    rb_raise(rb_eArgError, \"Expected string for JSON data.\");\n  }\n\n  // TODO(cfallin): Check and respect string encoding. If not UTF-8, we need to\n  // convert, because string handlers pass data directly to message string\n  // fields.\n\n  VALUE msg_rb = initialize_rb_class_with_no_args(klass);\n  Message* msg = ruby_to_Message(msg_rb);\n\n  // We don't allow users to decode a wrapper type directly.\n  if (IsWrapper(msg->msgdef)) {\n    rb_raise(rb_eRuntimeError, \"Cannot parse a wrapper directly.\");\n  }\n\n  upb_Status_Clear(&status);\n  if (!upb_JsonDecode(RSTRING_PTR(data), RSTRING_LEN(data),\n                      (upb_Message*)msg->msg, msg->msgdef, symtab, options,\n                      Arena_get(msg->arena), &status)) {\n    rb_raise(cParseError, \"Error occurred during parsing: %s\",\n             upb_Status_ErrorMessage(&status));\n  }\n\n  return msg_rb;\n}\n\n/*\n * call-seq:\n *     MessageClass.encode(msg, options) => bytes\n *\n * Encodes the given message object to its serialized form in protocol buffers\n * wire format.\n * @param options [Hash] options for the encoder\n *  recursion_limit: set to maximum encoding depth for message (default is 64)\n */\nstatic VALUE Message_encode(int argc, VALUE* argv, VALUE klass) {\n  Message* msg = ruby_to_Message(argv[0]);\n  int options = 0;\n  const char* data;\n  size_t size;\n\n  if (CLASS_OF(argv[0]) != klass) {\n    rb_raise(rb_eArgError, \"Message of wrong type.\");\n  }\n\n  if (argc < 1 || argc > 2) {\n    rb_raise(rb_eArgError, \"Expected 1 or 2 arguments.\");\n  }\n\n  if (argc == 2) {\n    VALUE hash_args = argv[1];\n    if (TYPE(hash_args) != T_HASH) {\n      rb_raise(rb_eArgError, \"Expected hash arguments.\");\n    }\n    VALUE depth = rb_hash_lookup(hash_args, ID2SYM(rb_intern(\"recursion_limit\")));\n\n    if (depth != Qnil && TYPE(depth) == T_FIXNUM) {\n      options |= UPB_DECODE_MAXDEPTH(FIX2INT(depth));\n    }\n  }\n\n  upb_Arena *arena = upb_Arena_New();\n\n  data = upb_Encode(msg->msg, upb_MessageDef_MiniTable(msg->msgdef),\n                    options, arena, &size);\n\n  if (data) {\n    VALUE ret = rb_str_new(data, size);\n    rb_enc_associate(ret, rb_ascii8bit_encoding());\n    upb_Arena_Free(arena);\n    return ret;\n  } else {\n    upb_Arena_Free(arena);\n    rb_raise(rb_eRuntimeError, \"Exceeded maximum depth (possibly cycle)\");\n  }\n}\n\n/*\n * call-seq:\n *     MessageClass.encode_json(msg, options = {}) => json_string\n *\n * Encodes the given message object into its serialized JSON representation.\n * @param options [Hash] options for the decoder\n *  preserve_proto_fieldnames: set true to use original fieldnames (default is\n * to camelCase) emit_defaults: set true to emit 0/false values (default is to\n * omit them)\n */\nstatic VALUE Message_encode_json(int argc, VALUE* argv, VALUE klass) {\n  Message* msg = ruby_to_Message(argv[0]);\n  int options = 0;\n  char buf[1024];\n  size_t size;\n  upb_Status status;\n\n  // TODO(haberman): use this message's pool instead.\n  const upb_DefPool* symtab = DescriptorPool_GetSymtab(generated_pool);\n\n  if (argc < 1 || argc > 2) {\n    rb_raise(rb_eArgError, \"Expected 1 or 2 arguments.\");\n  }\n\n  if (argc == 2) {\n    VALUE hash_args = argv[1];\n    if (TYPE(hash_args) != T_HASH) {\n      if (RTEST(rb_funcall(hash_args, rb_intern(\"respond_to?\"), 1, rb_str_new2(\"to_h\")))) {\n        hash_args = rb_funcall(hash_args, rb_intern(\"to_h\"), 0);\n      } else {\n        rb_raise(rb_eArgError, \"Expected hash arguments.\");\n      }\n    }\n\n    if (RTEST(rb_hash_lookup2(hash_args,\n                              ID2SYM(rb_intern(\"preserve_proto_fieldnames\")),\n                              Qfalse))) {\n      options |= upb_JsonEncode_UseProtoNames;\n    }\n\n    if (RTEST(rb_hash_lookup2(hash_args, ID2SYM(rb_intern(\"emit_defaults\")),\n                              Qfalse))) {\n      options |= upb_JsonEncode_EmitDefaults;\n    }\n  }\n\n  upb_Status_Clear(&status);\n  size = upb_JsonEncode(msg->msg, msg->msgdef, symtab, options, buf,\n                        sizeof(buf), &status);\n\n  if (!upb_Status_IsOk(&status)) {\n    rb_raise(cParseError, \"Error occurred during encoding: %s\",\n             upb_Status_ErrorMessage(&status));\n  }\n\n  VALUE ret;\n  if (size >= sizeof(buf)) {\n    char* buf2 = malloc(size + 1);\n    upb_JsonEncode(msg->msg, msg->msgdef, symtab, options, buf2, size + 1,\n                   &status);\n    ret = rb_str_new(buf2, size);\n    free(buf2);\n  } else {\n    ret = rb_str_new(buf, size);\n  }\n\n  rb_enc_associate(ret, rb_utf8_encoding());\n  return ret;\n}\n\n/*\n * call-seq:\n *     Message.descriptor => descriptor\n *\n * Class method that returns the Descriptor instance corresponding to this\n * message class's type.\n */\nstatic VALUE Message_descriptor(VALUE klass) {\n  return rb_ivar_get(klass, descriptor_instancevar_interned);\n}\n\nVALUE build_class_from_descriptor(VALUE descriptor) {\n  const char* name;\n  VALUE klass;\n\n  name = upb_MessageDef_FullName(Descriptor_GetMsgDef(descriptor));\n  if (name == NULL) {\n    rb_raise(rb_eRuntimeError, \"Descriptor does not have assigned name.\");\n  }\n\n  klass = rb_define_class_id(\n      // Docs say this parameter is ignored. User will assign return value to\n      // their own toplevel constant class name.\n      rb_intern(\"Message\"), cAbstractMessage);\n  rb_ivar_set(klass, descriptor_instancevar_interned, descriptor);\n  return klass;\n}\n\n/*\n * call-seq:\n *     Enum.lookup(number) => name\n *\n * This module method, provided on each generated enum module, looks up an enum\n * value by number and returns its name as a Ruby symbol, or nil if not found.\n */\nstatic VALUE enum_lookup(VALUE self, VALUE number) {\n  int32_t num = NUM2INT(number);\n  VALUE desc = rb_ivar_get(self, descriptor_instancevar_interned);\n  const upb_EnumDef* e = EnumDescriptor_GetEnumDef(desc);\n  const upb_EnumValueDef* ev = upb_EnumDef_FindValueByNumber(e, num);\n  if (ev) {\n    return ID2SYM(rb_intern(upb_EnumValueDef_Name(ev)));\n  } else {\n    return Qnil;\n  }\n}\n\n/*\n * call-seq:\n *     Enum.resolve(name) => number\n *\n * This module method, provided on each generated enum module, looks up an enum\n * value by name (as a Ruby symbol) and returns its name, or nil if not found.\n */\nstatic VALUE enum_resolve(VALUE self, VALUE sym) {\n  const char* name = rb_id2name(SYM2ID(sym));\n  VALUE desc = rb_ivar_get(self, descriptor_instancevar_interned);\n  const upb_EnumDef* e = EnumDescriptor_GetEnumDef(desc);\n  const upb_EnumValueDef* ev = upb_EnumDef_FindValueByName(e, name);\n  if (ev) {\n    return INT2NUM(upb_EnumValueDef_Number(ev));\n  } else {\n    return Qnil;\n  }\n}\n\n/*\n * call-seq:\n *     Enum.descriptor\n *\n * This module method, provided on each generated enum module, returns the\n * EnumDescriptor corresponding to this enum type.\n */\nstatic VALUE enum_descriptor(VALUE self) {\n  return rb_ivar_get(self, descriptor_instancevar_interned);\n}\n\nVALUE build_module_from_enumdesc(VALUE _enumdesc) {\n  const upb_EnumDef* e = EnumDescriptor_GetEnumDef(_enumdesc);\n  VALUE mod = rb_define_module_id(rb_intern(upb_EnumDef_FullName(e)));\n\n  int n = upb_EnumDef_ValueCount(e);\n  for (int i = 0; i < n; i++) {\n    const upb_EnumValueDef* ev = upb_EnumDef_Value(e, i);\n    const char* name = upb_EnumValueDef_Name(ev);\n    int32_t value = upb_EnumValueDef_Number(ev);\n    if (name[0] < 'A' || name[0] > 'Z') {\n      rb_warn(\n          \"Enum value '%s' does not start with an uppercase letter \"\n          \"as is required for Ruby constants.\",\n          name);\n    }\n    rb_define_const(mod, name, INT2NUM(value));\n  }\n\n  rb_define_singleton_method(mod, \"lookup\", enum_lookup, 1);\n  rb_define_singleton_method(mod, \"resolve\", enum_resolve, 1);\n  rb_define_singleton_method(mod, \"descriptor\", enum_descriptor, 0);\n  rb_ivar_set(mod, descriptor_instancevar_interned, _enumdesc);\n\n  return mod;\n}\n\n// Internal only; used by Google::Protobuf.deep_copy.\nupb_Message* Message_deep_copy(const upb_Message* msg, const upb_MessageDef* m,\n                               upb_Arena* arena) {\n  // Serialize and parse.\n  upb_Arena* tmp_arena = upb_Arena_New();\n  const upb_MiniTable* layout = upb_MessageDef_MiniTable(m);\n  size_t size;\n\n  char* data = upb_Encode(msg, layout, 0, tmp_arena, &size);\n  upb_Message* new_msg = upb_Message_New(m, arena);\n\n  if (!data || upb_Decode(data, size, new_msg, layout, NULL, 0, arena) !=\n                   kUpb_DecodeStatus_Ok) {\n    upb_Arena_Free(tmp_arena);\n    rb_raise(cParseError, \"Error occurred copying proto\");\n  }\n\n  upb_Arena_Free(tmp_arena);\n  return new_msg;\n}\n\nconst upb_Message* Message_GetUpbMessage(VALUE value, const upb_MessageDef* m,\n                                         const char* name, upb_Arena* arena) {\n  if (value == Qnil) {\n    rb_raise(cTypeError, \"nil message not allowed here.\");\n  }\n\n  VALUE klass = CLASS_OF(value);\n  VALUE desc_rb = rb_ivar_get(klass, descriptor_instancevar_interned);\n  const upb_MessageDef* val_m =\n      desc_rb == Qnil ? NULL : Descriptor_GetMsgDef(desc_rb);\n\n  if (val_m != m) {\n    // Check for possible implicit conversions\n    // TODO: hash conversion?\n\n    switch (upb_MessageDef_WellKnownType(m)) {\n      case kUpb_WellKnown_Timestamp: {\n        // Time -> Google::Protobuf::Timestamp\n        upb_Message* msg = upb_Message_New(m, arena);\n        upb_MessageValue sec, nsec;\n        struct timespec time;\n        const upb_FieldDef* sec_f = upb_MessageDef_FindFieldByNumber(m, 1);\n        const upb_FieldDef* nsec_f = upb_MessageDef_FindFieldByNumber(m, 2);\n\n        if (!rb_obj_is_kind_of(value, rb_cTime)) goto badtype;\n\n        time = rb_time_timespec(value);\n        sec.int64_val = time.tv_sec;\n        nsec.int32_val = time.tv_nsec;\n        upb_Message_Set(msg, sec_f, sec, arena);\n        upb_Message_Set(msg, nsec_f, nsec, arena);\n        return msg;\n      }\n      case kUpb_WellKnown_Duration: {\n        // Numeric -> Google::Protobuf::Duration\n        upb_Message* msg = upb_Message_New(m, arena);\n        upb_MessageValue sec, nsec;\n        const upb_FieldDef* sec_f = upb_MessageDef_FindFieldByNumber(m, 1);\n        const upb_FieldDef* nsec_f = upb_MessageDef_FindFieldByNumber(m, 2);\n\n        if (!rb_obj_is_kind_of(value, rb_cNumeric)) goto badtype;\n\n        sec.int64_val = NUM2LL(value);\n        nsec.int32_val = round((NUM2DBL(value) - NUM2LL(value)) * 1000000000);\n        upb_Message_Set(msg, sec_f, sec, arena);\n        upb_Message_Set(msg, nsec_f, nsec, arena);\n        return msg;\n      }\n      default:\n      badtype:\n        rb_raise(cTypeError,\n                 \"Invalid type %s to assign to submessage field '%s'.\",\n                 rb_class2name(CLASS_OF(value)), name);\n    }\n  }\n\n  Message* self = ruby_to_Message(value);\n  Arena_fuse(self->arena, arena);\n\n  return self->msg;\n}\n\nstatic void Message_define_class(VALUE klass) {\n  rb_define_alloc_func(klass, Message_alloc);\n\n  rb_require(\"google/protobuf/message_exts\");\n  rb_define_method(klass, \"method_missing\", Message_method_missing, -1);\n  rb_define_method(klass, \"respond_to_missing?\", Message_respond_to_missing,\n                   -1);\n  rb_define_method(klass, \"initialize\", Message_initialize, -1);\n  rb_define_method(klass, \"dup\", Message_dup, 0);\n  // Also define #clone so that we don't inherit Object#clone.\n  rb_define_method(klass, \"clone\", Message_dup, 0);\n  rb_define_method(klass, \"==\", Message_eq, 1);\n  rb_define_method(klass, \"eql?\", Message_eq, 1);\n  rb_define_method(klass, \"freeze\", Message_freeze, 0);\n  rb_define_method(klass, \"hash\", Message_hash, 0);\n  rb_define_method(klass, \"to_h\", Message_to_h, 0);\n  rb_define_method(klass, \"inspect\", Message_inspect, 0);\n  rb_define_method(klass, \"to_s\", Message_inspect, 0);\n  rb_define_method(klass, \"[]\", Message_index, 1);\n  rb_define_method(klass, \"[]=\", Message_index_set, 2);\n  rb_define_singleton_method(klass, \"decode\", Message_decode, -1);\n  rb_define_singleton_method(klass, \"encode\", Message_encode, -1);\n  rb_define_singleton_method(klass, \"decode_json\", Message_decode_json, -1);\n  rb_define_singleton_method(klass, \"encode_json\", Message_encode_json, -1);\n  rb_define_singleton_method(klass, \"descriptor\", Message_descriptor, 0);\n}\n\nvoid Message_register(VALUE protobuf) {\n  cParseError = rb_const_get(protobuf, rb_intern(\"ParseError\"));\n  cAbstractMessage = rb_define_class_under(protobuf, \"AbstractMessage\", rb_cObject);\n  Message_define_class(cAbstractMessage);\n  rb_gc_register_address(&cAbstractMessage);\n\n  // Ruby-interned string: \"descriptor\". We use this identifier to store an\n  // instance variable on message classes we create in order to link them back\n  // to their descriptors.\n  descriptor_instancevar_interned = rb_intern(\"@descriptor\");\n}\n", "/*\n * Protocol Buffers - Google's data interchange format\n * Copyright 2014 Google Inc.  All rights reserved.\n * https://developers.google.com/protocol-buffers/\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *     * Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above\n * copyright notice, this list of conditions and the following disclaimer\n * in the documentation and/or other materials provided with the\n * distribution.\n *     * Neither the name of Google Inc. nor the names of its\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage com.google.protobuf.jruby;\n\nimport com.google.protobuf.DescriptorProtos.EnumDescriptorProto;\nimport com.google.protobuf.Descriptors.EnumDescriptor;\nimport com.google.protobuf.Descriptors.EnumValueDescriptor;\nimport com.google.protobuf.Descriptors.FileDescriptor;\nimport org.jruby.Ruby;\nimport org.jruby.RubyClass;\nimport org.jruby.RubyModule;\nimport org.jruby.RubyNumeric;\nimport org.jruby.RubyObject;\nimport org.jruby.anno.JRubyClass;\nimport org.jruby.anno.JRubyMethod;\nimport org.jruby.runtime.Block;\nimport org.jruby.runtime.ObjectAllocator;\nimport org.jruby.runtime.ThreadContext;\nimport org.jruby.runtime.builtin.IRubyObject;\n\n@JRubyClass(name = \"EnumDescriptor\", include = \"Enumerable\")\npublic class RubyEnumDescriptor extends RubyObject {\n  public static void createRubyEnumDescriptor(Ruby runtime) {\n    RubyModule mProtobuf = runtime.getClassFromPath(\"Google::Protobuf\");\n    RubyClass cEnumDescriptor =\n        mProtobuf.defineClassUnder(\n            \"EnumDescriptor\",\n            runtime.getObject(),\n            new ObjectAllocator() {\n              @Override\n              public IRubyObject allocate(Ruby runtime, RubyClass klazz) {\n                return new RubyEnumDescriptor(runtime, klazz);\n              }\n            });\n    cEnumDescriptor.includeModule(runtime.getEnumerable());\n    cEnumDescriptor.defineAnnotatedMethods(RubyEnumDescriptor.class);\n  }\n\n  public RubyEnumDescriptor(Ruby runtime, RubyClass klazz) {\n    super(runtime, klazz);\n  }\n\n  /*\n   * call-seq:\n   *     EnumDescriptor.name => name\n   *\n   * Returns the name of this enum type.\n   */\n  @JRubyMethod(name = \"name\")\n  public IRubyObject getName(ThreadContext context) {\n    return this.name;\n  }\n\n  /*\n   * call-seq:\n   *     EnumDescriptor.each(&block)\n   *\n   * Iterates over key => value mappings in this enum's definition, yielding to\n   * the block with (key, value) arguments for each one.\n   */\n  @JRubyMethod\n  public IRubyObject each(ThreadContext context, Block block) {\n    Ruby runtime = context.runtime;\n    for (EnumValueDescriptor enumValueDescriptor : descriptor.getValues()) {\n      block.yield(\n          context,\n          runtime.newArray(\n              runtime.newSymbol(enumValueDescriptor.getName()),\n              runtime.newFixnum(enumValueDescriptor.getNumber())));\n    }\n    return context.nil;\n  }\n\n  /*\n   * call-seq:\n   *     EnumDescriptor.enummodule => module\n   *\n   * Returns the Ruby module corresponding to this enum type. Cannot be called\n   * until the enum descriptor has been added to a pool.\n   */\n  @JRubyMethod\n  public IRubyObject enummodule(ThreadContext context) {\n    return module;\n  }\n\n  /*\n   * call-seq:\n   *    EnumDescriptor.file_descriptor\n   *\n   * Returns the FileDescriptor object this enum belongs to.\n   */\n  @JRubyMethod(name = \"file_descriptor\")\n  public IRubyObject getFileDescriptor(ThreadContext context) {\n    return RubyFileDescriptor.getRubyFileDescriptor(context, descriptor);\n  }\n\n  public boolean isValidValue(ThreadContext context, IRubyObject value) {\n    EnumValueDescriptor enumValue;\n\n    if (Utils.isRubyNum(value)) {\n      enumValue = descriptor.findValueByNumberCreatingIfUnknown(RubyNumeric.num2int(value));\n    } else {\n      enumValue = descriptor.findValueByName(value.asJavaString());\n    }\n\n    return enumValue != null;\n  }\n\n  protected IRubyObject nameToNumber(ThreadContext context, IRubyObject name) {\n    EnumValueDescriptor value = descriptor.findValueByName(name.asJavaString());\n    return value == null ? context.nil : context.runtime.newFixnum(value.getNumber());\n  }\n\n  protected IRubyObject numberToName(ThreadContext context, IRubyObject number) {\n    EnumValueDescriptor value = descriptor.findValueByNumber(RubyNumeric.num2int(number));\n    return value == null ? context.nil : context.runtime.newSymbol(value.getName());\n  }\n\n  protected void setDescriptor(ThreadContext context, EnumDescriptor descriptor) {\n    this.descriptor = descriptor;\n    this.module = buildModuleFromDescriptor(context);\n  }\n\n  protected void setName(IRubyObject name) {\n    this.name = name;\n  }\n\n  private RubyModule buildModuleFromDescriptor(ThreadContext context) {\n    Ruby runtime = context.runtime;\n\n    RubyModule enumModule = RubyModule.newModule(runtime);\n    boolean defaultValueRequiredButNotFound =\n        descriptor.getFile().getSyntax() == FileDescriptor.Syntax.PROTO3;\n    for (EnumValueDescriptor value : descriptor.getValues()) {\n      String name = value.getName();\n      // Make sure its a valid constant name before trying to create it\n      if (Character.isUpperCase(name.codePointAt(0))) {\n        enumModule.defineConstant(name, runtime.newFixnum(value.getNumber()));\n      } else {\n        runtime\n            .getWarnings()\n            .warn(\n                \"Enum value \"\n                    + name\n                    + \" does not start with an uppercase letter as is required for Ruby\"\n                    + \" constants.\");\n      }\n      if (value.getNumber() == 0) {\n        defaultValueRequiredButNotFound = false;\n      }\n    }\n\n    if (defaultValueRequiredButNotFound) {\n      throw Utils.createTypeError(\n          context, \"Enum definition \" + name + \" does not contain a value for '0'\");\n    }\n    enumModule.instance_variable_set(runtime.newString(Utils.DESCRIPTOR_INSTANCE_VAR), this);\n    enumModule.defineAnnotatedMethods(RubyEnum.class);\n    return enumModule;\n  }\n\n  private EnumDescriptor descriptor;\n  private EnumDescriptorProto.Builder builder;\n  private IRubyObject name;\n  private RubyModule module;\n}\n", "syntax = \"proto3\";\n\npackage basic_test;\n\nimport \"google/protobuf/wrappers.proto\";\nimport \"google/protobuf/timestamp.proto\";\nimport \"google/protobuf/duration.proto\";\nimport \"google/protobuf/struct.proto\";\nimport \"test_import_proto2.proto\";\n\nmessage Foo {\n  Bar bar = 1;\n  repeated Baz baz = 2;\n}\n\nmessage Bar {\n  string msg = 1;\n}\n\nmessage Baz {\n  string msg = 1;\n}\n\nmessage TestMessage {\n  optional int32 optional_int32 = 1;\n  optional int64 optional_int64 = 2;\n  optional uint32 optional_uint32 = 3;\n  optional uint64 optional_uint64 = 4;\n  optional bool optional_bool = 5;\n  optional float optional_float = 6;\n  optional double optional_double = 7;\n  optional string optional_string = 8;\n  optional bytes optional_bytes = 9;\n  optional TestMessage2 optional_msg = 10;\n  optional TestEnum optional_enum = 11;\n  optional foo_bar.proto2.TestImportedMessage optional_proto2_submessage = 24;\n\n  repeated int32 repeated_int32 = 12;\n  repeated int64 repeated_int64 = 13;\n  repeated uint32 repeated_uint32 = 14;\n  repeated uint64 repeated_uint64 = 15;\n  repeated bool repeated_bool = 16;\n  repeated float repeated_float = 17;\n  repeated double repeated_double = 18;\n  repeated string repeated_string = 19;\n  repeated bytes repeated_bytes = 20;\n  repeated TestMessage2 repeated_msg = 21;\n  repeated TestEnum repeated_enum = 22;\n\n  optional TestSingularFields optional_msg2 = 23;\n}\n\nmessage TestSingularFields {\n  int32 singular_int32 = 1;\n  int64 singular_int64 = 2;\n  uint32 singular_uint32 = 3;\n  uint64 singular_uint64 = 4;\n  bool singular_bool = 5;\n  float singular_float = 6;\n  double singular_double = 7;\n  string singular_string = 8;\n  bytes singular_bytes = 9;\n  TestMessage2 singular_msg = 10;\n  TestEnum singular_enum = 11;\n}\n\nmessage TestMessage2 {\n  optional int32 foo = 1;\n}\n\nenum TestEnum {\n  Default = 0;\n  A = 1;\n  B = 2;\n  C = 3;\n}\n\nmessage TestEmbeddedMessageParent {\n  TestEmbeddedMessageChild child_msg = 1;\n  int32 number = 2;\n\n  repeated TestEmbeddedMessageChild repeated_msg = 3;\n  repeated int32 repeated_number = 4;\n}\n\nmessage TestEmbeddedMessageChild {\n  TestMessage sub_child = 1;\n}\n\nmessage Recursive1 {\n  Recursive2 foo = 1;\n}\n\nmessage Recursive2 {\n  Recursive1 foo = 1;\n}\n\nmessage MapMessage {\n  map<string, int32> map_string_int32 = 1;\n  map<string, TestMessage2> map_string_msg = 2;\n  map<string, TestEnum> map_string_enum = 3;\n}\n\nmessage MapMessageWireEquiv {\n  repeated MapMessageWireEquiv_entry1 map_string_int32 = 1;\n  repeated MapMessageWireEquiv_entry2 map_string_msg = 2;\n}\n\nmessage MapMessageWireEquiv_entry1 {\n  string key = 1;\n  int32 value = 2;\n}\n\nmessage MapMessageWireEquiv_entry2 {\n  string key = 1;\n  TestMessage2 value = 2;\n}\n\nmessage OneofMessage {\n  oneof my_oneof {\n    string a = 1;\n    int32 b = 2;\n    TestMessage2 c = 3;\n    TestEnum d = 4;\n  }\n}\n\nmessage Outer {\n  map<int32, Inner> items = 1;\n}\n\nmessage Inner {\n}\n\nmessage Wrapper {\n  google.protobuf.DoubleValue double = 1;\n  google.protobuf.FloatValue float = 2;\n  google.protobuf.Int32Value int32 = 3;\n  google.protobuf.Int64Value int64 = 4;\n  google.protobuf.UInt32Value uint32 = 5;\n  google.protobuf.UInt64Value uint64 = 6;\n  google.protobuf.BoolValue bool = 7;\n  google.protobuf.StringValue string = 8;\n  google.protobuf.BytesValue bytes = 9;\n  string real_string = 100;\n  oneof a_oneof {\n    string string_in_oneof = 10;\n  }\n\n  // Repeated wrappers don't make sense, but we still need to make sure they\n  // work and don't crash.\n  repeated google.protobuf.DoubleValue repeated_double = 11;\n  repeated google.protobuf.FloatValue repeated_float = 12;\n  repeated google.protobuf.Int32Value repeated_int32 = 13;\n  repeated google.protobuf.Int64Value repeated_int64 = 14;\n  repeated google.protobuf.UInt32Value repeated_uint32 = 15;\n  repeated google.protobuf.UInt64Value repeated_uint64 = 16;\n  repeated google.protobuf.BoolValue repeated_bool = 17;\n  repeated google.protobuf.StringValue repeated_string = 18;\n  repeated google.protobuf.BytesValue repeated_bytes = 19;\n\n  // Wrappers as map keys don't make sense, but we still need to make sure they\n  // work and don't crash.\n  map<int32, google.protobuf.DoubleValue> map_double = 21;\n  map<int32, google.protobuf.FloatValue> map_float = 22;\n  map<int32, google.protobuf.Int32Value> map_int32 = 23;\n  map<int32, google.protobuf.Int64Value> map_int64 = 24;\n  map<int32, google.protobuf.UInt32Value> map_uint32 = 25;\n  map<int32, google.protobuf.UInt64Value> map_uint64 = 26;\n  map<int32, google.protobuf.BoolValue> map_bool = 27;\n  map<int32, google.protobuf.StringValue> map_string = 28;\n  map<int32, google.protobuf.BytesValue> map_bytes = 29;\n\n  // Wrappers in oneofs don't make sense, but we still need to make sure they\n  // work and don't crash.\n  oneof wrapper_oneof {\n    google.protobuf.DoubleValue oneof_double = 31;\n    google.protobuf.FloatValue oneof_float = 32;\n    google.protobuf.Int32Value oneof_int32 = 33;\n    google.protobuf.Int64Value oneof_int64 = 34;\n    google.protobuf.UInt32Value oneof_uint32 = 35;\n    google.protobuf.UInt64Value oneof_uint64 = 36;\n    google.protobuf.BoolValue oneof_bool = 37;\n    google.protobuf.StringValue oneof_string = 38;\n    google.protobuf.BytesValue oneof_bytes = 39;\n    string oneof_plain_string = 101;\n  }\n}\n\nmessage TimeMessage {\n  google.protobuf.Timestamp timestamp = 1;\n  google.protobuf.Duration duration = 2;\n}\n\nmessage Enumer {\n  TestEnum optional_enum = 1;\n  repeated TestEnum repeated_enum = 2;\n  string a_const = 3;\n  oneof a_oneof {\n    string str = 10;\n    TestEnum const = 11;\n  }\n}\n\nmessage MyRepeatedStruct {\n  repeated MyStruct structs = 1;\n}\n\nmessage MyStruct {\n  string string = 1;\n  google.protobuf.Struct struct = 2;\n}\n\nmessage WithJsonName {\n  optional int32 foo_bar = 1 [json_name=\"jsonFooBar\"];\n  repeated WithJsonName baz = 2 [json_name=\"jsonBaz\"];\n}\n\nmessage HelloRequest {\n  optional uint32 id = 1;\n  optional uint32 random_name_a0 = 2;\n  optional uint32 random_name_a1 = 3;\n  optional uint32 random_name_a2 = 4;\n  optional uint32 random_name_a3 = 5;\n  optional uint32 random_name_a4 = 6;\n  optional uint32 random_name_a5 = 7;\n  optional uint32 random_name_a6 = 8;\n  optional uint32 random_name_a7 = 9;\n  optional uint32 random_name_a8 = 10;\n  optional uint32 random_name_a9 = 11;\n  optional uint32 random_name_b0 = 12;\n  optional uint32 random_name_b1 = 13;\n  optional uint32 random_name_b2 = 14;\n  optional uint32 random_name_b3 = 15;\n  optional uint32 random_name_b4 = 16;\n  optional uint32 random_name_b5 = 17;\n  optional uint32 random_name_b6 = 18;\n  optional uint32 random_name_b7 = 19;\n  optional uint32 random_name_b8 = 20;\n  optional uint32 random_name_b9 = 21;\n  optional uint32 random_name_c0 = 22;\n  optional uint32 random_name_c1 = 23;\n  optional uint32 random_name_c2 = 24;\n  optional uint32 random_name_c3 = 25;\n  optional uint32 random_name_c4 = 26;\n  optional uint32 random_name_c5 = 27;\n  optional uint32 random_name_c6 = 28;\n  optional uint32 random_name_c7 = 29;\n  optional uint32 random_name_c8 = 30;\n  optional uint32 random_name_c9 = 31;\n  optional string version = 32;\n}\n", "syntax = \"proto2\";\n\npackage basic_test_proto2;\n\nimport \"google/protobuf/wrappers.proto\";\nimport \"google/protobuf/timestamp.proto\";\nimport \"google/protobuf/duration.proto\";\nimport \"google/protobuf/struct.proto\";\n\nmessage Foo {\n  optional Bar bar = 1;\n  repeated Baz baz = 2;\n}\n\nmessage Bar {\n  optional string msg = 1;\n}\n\nmessage Baz {\n  optional string msg = 1;\n}\n\nmessage TestMessage {\n  optional int32 optional_int32 = 1;\n  optional int64 optional_int64 = 2;\n  optional uint32 optional_uint32 = 3;\n  optional uint64 optional_uint64 = 4;\n  optional bool optional_bool = 5;\n  optional float optional_float = 6;\n  optional double optional_double = 7;\n  optional string optional_string = 8;\n  optional bytes optional_bytes = 9;\n  optional TestMessage2 optional_msg = 10;\n  optional TestEnum optional_enum = 11;\n\n  repeated int32 repeated_int32 = 12;\n  repeated int64 repeated_int64 = 13;\n  repeated uint32 repeated_uint32 = 14;\n  repeated uint64 repeated_uint64 = 15;\n  repeated bool repeated_bool = 16;\n  repeated float repeated_float = 17;\n  repeated double repeated_double = 18;\n  repeated string repeated_string = 19;\n  repeated bytes repeated_bytes = 20;\n  repeated TestMessage2 repeated_msg = 21;\n  repeated TestEnum repeated_enum = 22;\n}\n\nmessage TestMessage2 {\n  optional int32 foo = 1;\n}\n\nmessage TestMessageDefaults {\n  optional int32 optional_int32 = 1 [default = 1];\n  optional int64 optional_int64 = 2 [default = 2];\n  optional uint32 optional_uint32 = 3 [default = 3];\n  optional uint64 optional_uint64 = 4 [default = 4];\n  optional bool optional_bool = 5 [default = true];\n  optional float optional_float = 6 [default = 6];\n  optional double optional_double = 7 [default = 7];\n  optional string optional_string = 8 [default = \"Default Str\"];\n  optional bytes optional_bytes = 9 [default = \"\\xCF\\xA5s\\xBD\\xBA\\xE6fubar\"];\n  optional TestMessage2 optional_msg = 10;\n  optional TestNonZeroEnum optional_enum = 11 [default = B2];\n}\n\nenum TestEnum {\n  Default = 0;\n  A = 1;\n  B = 2;\n  C = 3;\n}\n\nenum TestNonZeroEnum {\n  A2 = 1;\n  B2 = 2;\n  C2 = 3;\n}\n\nmessage TestEmbeddedMessageParent {\n  optional TestEmbeddedMessageChild child_msg = 1;\n  optional int32 number = 2;\n\n  repeated TestEmbeddedMessageChild repeated_msg = 3;\n  repeated int32 repeated_number = 4;\n}\n\nmessage TestEmbeddedMessageChild {\n  optional TestMessage sub_child = 1;\n}\n\nmessage Recursive1 {\n  optional Recursive2 foo = 1;\n}\n\nmessage Recursive2 {\n  optional Recursive1 foo = 1;\n}\n\nmessage MapMessageWireEquiv {\n  repeated MapMessageWireEquiv_entry1 map_string_int32 = 1;\n  repeated MapMessageWireEquiv_entry2 map_string_msg = 2;\n}\n\nmessage MapMessageWireEquiv_entry1 {\n  optional string key = 1;\n  optional int32 value = 2;\n}\n\nmessage MapMessageWireEquiv_entry2 {\n  optional string key = 1;\n  optional TestMessage2 value = 2;\n}\n\nmessage OneofMessage {\n  oneof my_oneof {\n    string a = 1;\n    int32 b = 2;\n    TestMessage2 c = 3;\n    TestEnum d = 4;\n  }\n}\n\nmessage Wrapper {\n  optional google.protobuf.DoubleValue double = 1;\n  optional google.protobuf.FloatValue float = 2;\n  optional google.protobuf.Int32Value int32 = 3;\n  optional google.protobuf.Int64Value int64 = 4;\n  optional google.protobuf.UInt32Value uint32 = 5;\n  optional google.protobuf.UInt64Value uint64 = 6;\n  optional google.protobuf.BoolValue bool = 7;\n  optional google.protobuf.StringValue string = 8;\n  optional google.protobuf.BytesValue bytes = 9;\n  optional string real_string = 100;\n  oneof a_oneof {\n    string string_in_oneof = 10;\n  }\n\n  // Repeated wrappers don't really make sense, but we still need to make sure\n  // they work and don't crash.\n  repeated google.protobuf.DoubleValue repeated_double = 11;\n  repeated google.protobuf.FloatValue repeated_float = 12;\n  repeated google.protobuf.Int32Value repeated_int32 = 13;\n  repeated google.protobuf.Int64Value repeated_int64 = 14;\n  repeated google.protobuf.UInt32Value repeated_uint32 = 15;\n  repeated google.protobuf.UInt64Value repeated_uint64 = 16;\n  repeated google.protobuf.BoolValue repeated_bool = 17;\n  repeated google.protobuf.StringValue repeated_string = 18;\n  repeated google.protobuf.BytesValue repeated_bytes = 19;\n\n  // Wrappers in oneofs don't make sense, but we still need to make sure they\n  // work and don't crash.\n  oneof wrapper_oneof {\n    google.protobuf.DoubleValue oneof_double = 31;\n    google.protobuf.FloatValue oneof_float = 32;\n    google.protobuf.Int32Value oneof_int32 = 33;\n    google.protobuf.Int64Value oneof_int64 = 34;\n    google.protobuf.UInt32Value oneof_uint32 = 35;\n    google.protobuf.UInt64Value oneof_uint64 = 36;\n    google.protobuf.BoolValue oneof_bool = 37;\n    google.protobuf.StringValue oneof_string = 38;\n    google.protobuf.BytesValue oneof_bytes = 39;\n    string oneof_plain_string = 101;\n  }\n}\n\nmessage TimeMessage {\n  optional google.protobuf.Timestamp timestamp = 1;\n  optional google.protobuf.Duration duration = 2;\n}\n\nmessage Enumer {\n  optional TestEnum optional_enum = 11;\n  repeated TestEnum repeated_enum = 22;\n  optional string a_const = 3;\n  oneof a_oneof {\n    string str = 100;\n    TestEnum const = 101;\n  }\n}\n\nmessage MyRepeatedStruct {\n  repeated MyStruct structs = 1;\n}\n\nmessage MyStruct {\n  optional string string = 1;\n  optional google.protobuf.Struct struct = 2;\n}\n", "require 'google/protobuf/wrappers_pb.rb'\n\n# Defines tests which are common between proto2 and proto3 syntax.\n#\n# Requires that the proto messages are exactly the same in proto2 and proto3 syntax\n# and that the including class should define a 'proto_module' method which returns\n# the enclosing module of the proto message classes.\n\nrequire 'bigdecimal'\n\nmodule CommonTests\n  # Ruby 2.5 changed to raise FrozenError instead of RuntimeError\n  FrozenErrorType = Gem::Version.new(RUBY_VERSION) < Gem::Version.new('2.5') ? RuntimeError : FrozenError\n\n  def test_defaults\n    m = proto_module::TestMessage.new\n    assert m.optional_int32 == 0\n    assert m.optional_int64 == 0\n    assert m.optional_uint32 == 0\n    assert m.optional_uint64 == 0\n    assert m.optional_bool == false\n    assert m.optional_float == 0.0\n    assert m.optional_double == 0.0\n    assert m.optional_string == \"\"\n    assert m.optional_bytes == \"\"\n    assert m.optional_msg == nil\n    assert m.optional_enum == :Default\n  end\n\n  def test_setters\n    m = proto_module::TestMessage.new\n    m.optional_int32 = -42\n    assert m.optional_int32 == -42\n    m.optional_int64 = -0x1_0000_0000\n    assert m.optional_int64 == -0x1_0000_0000\n    m.optional_uint32 = 0x9000_0000\n    assert m.optional_uint32 == 0x9000_0000\n    m.optional_uint64 = 0x9000_0000_0000_0000\n    assert m.optional_uint64 == 0x9000_0000_0000_0000\n    m.optional_bool = true\n    assert m.optional_bool == true\n    m.optional_float = 0.5\n    assert m.optional_float == 0.5\n    m.optional_double = 0.5\n    assert m.optional_double == 0.5\n    m.optional_string = \"hello\"\n    assert m.optional_string == \"hello\"\n    m.optional_string = :hello\n    assert m.optional_string == \"hello\"\n    m.optional_bytes = \"world\".encode!('ASCII-8BIT')\n    assert m.optional_bytes == \"world\"\n    m.optional_msg = proto_module::TestMessage2.new(:foo => 42)\n    assert m.optional_msg == proto_module::TestMessage2.new(:foo => 42)\n    m.optional_msg = nil\n    assert m.optional_msg == nil\n    m.optional_enum = :C\n    assert m.optional_enum == :C\n    m.optional_enum = 'C'\n    assert m.optional_enum == :C\n  end\n\n  def test_ctor_args\n    m = proto_module::TestMessage.new(:optional_int32 => -42,\n                                      :optional_msg => proto_module::TestMessage2.new,\n                                      :optional_enum => :C,\n                                      :repeated_string => [\"hello\", \"there\", \"world\"])\n    assert m.optional_int32 == -42\n    assert m.optional_msg.class == proto_module::TestMessage2\n    assert m.repeated_string.length == 3\n    assert m.optional_enum == :C\n    assert m.repeated_string[0] == \"hello\"\n    assert m.repeated_string[1] == \"there\"\n    assert m.repeated_string[2] == \"world\"\n  end\n\n  def test_ctor_string_symbol_args\n    m = proto_module::TestMessage.new(:optional_enum => 'C', :repeated_enum => ['A', 'B'])\n    assert_equal :C, m.optional_enum\n    assert_equal [:A, :B], m.repeated_enum\n\n    m = proto_module::TestMessage.new(:optional_string => :foo, :repeated_string => [:foo, :bar])\n    assert_equal 'foo', m.optional_string\n    assert_equal ['foo', 'bar'], m.repeated_string\n  end\n\n  def test_ctor_nil_args\n    m = proto_module::TestMessage.new(:optional_enum => nil, :optional_int32 => nil, :optional_string => nil, :optional_msg => nil)\n\n    assert_equal :Default, m.optional_enum\n    assert_equal 0, m.optional_int32\n    assert_equal \"\", m.optional_string\n    assert_nil m.optional_msg\n  end\n\n  def test_embeddedmsg_hash_init\n    m = proto_module::TestEmbeddedMessageParent.new(\n      :child_msg => {sub_child: {optional_int32: 1}},\n      :number => 2,\n      :repeated_msg => [{sub_child: {optional_int32: 3}}],\n      :repeated_number => [10, 20, 30])\n\n    assert_equal 2, m.number\n    assert_equal [10, 20, 30], m.repeated_number\n\n    assert_not_nil m.child_msg\n    assert_not_nil m.child_msg.sub_child\n    assert_equal m.child_msg.sub_child.optional_int32, 1\n\n    assert_not_nil m.repeated_msg\n    assert_equal 1, m.repeated_msg.length\n    assert_equal 3, m.repeated_msg.first.sub_child.optional_int32\n  end\n\n  def test_inspect_eq_to_s\n    m = proto_module::TestMessage.new(\n      :optional_int32 => -42,\n      :optional_enum => :A,\n      :optional_msg => proto_module::TestMessage2.new(foo: 0),\n      :repeated_string => [\"hello\", \"there\", \"world\"])\n    expected = \"<#{proto_module}::TestMessage: optional_int32: -42, optional_msg: <#{proto_module}::TestMessage2: foo: 0>, optional_enum: :A, repeated_int32: [], repeated_int64: [], repeated_uint32: [], repeated_uint64: [], repeated_bool: [], repeated_float: [], repeated_double: [], repeated_string: [\\\"hello\\\", \\\"there\\\", \\\"world\\\"], repeated_bytes: [], repeated_msg: [], repeated_enum: []>\"\n    assert_equal expected, m.inspect\n    assert_equal expected, m.to_s\n\n    m = proto_module::OneofMessage.new(:b => -42)\n    expected = \"<#{proto_module}::OneofMessage: b: -42>\"\n    assert_equal expected, m.inspect\n    assert_equal expected, m.to_s\n  end\n\n  def test_hash\n    m1 = proto_module::TestMessage.new(:optional_int32 => 42)\n    m2 = proto_module::TestMessage.new(:optional_int32 => 102, repeated_string: ['please', 'work', 'ok?'])\n    m3 = proto_module::TestMessage.new(:optional_int32 => 102, repeated_string: ['please', 'work', 'ok?'])\n    assert m1.hash != 0\n    assert m2.hash != 0\n    assert m3.hash != 0\n    # relying on the randomness here -- if hash function changes and we are\n    # unlucky enough to get a collision, then change the values above.\n    assert m1.hash != m2.hash\n    assert_equal m2.hash, m3.hash\n  end\n\n  def test_unknown_field_errors\n    e = assert_raise NoMethodError do\n      proto_module::TestMessage.new.hello\n    end\n    assert_match(/hello/, e.message)\n\n    e = assert_raise NoMethodError do\n      proto_module::TestMessage.new.hello = \"world\"\n    end\n    assert_match(/hello/, e.message)\n  end\n\n  def test_type_errors\n    m = proto_module::TestMessage.new\n    e = assert_raise Google::Protobuf::TypeError do\n      m.optional_int32 = \"hello\"\n    end\n\n    # Google::Protobuf::TypeError should inherit from TypeError for backwards compatibility\n    # TODO: This can be removed when we can safely migrate to Google::Protobuf::TypeError\n    assert e.is_a?(::TypeError)\n\n    assert_raise Google::Protobuf::TypeError do\n      m.optional_string = 42\n    end\n    assert_raise Google::Protobuf::TypeError do\n      m.optional_string = nil\n    end\n    assert_raise Google::Protobuf::TypeError do\n      m.optional_bool = 42\n    end\n    assert_raise Google::Protobuf::TypeError do\n      m.optional_msg = proto_module::TestMessage.new  # expects TestMessage2\n    end\n\n    assert_raise Google::Protobuf::TypeError do\n      m.repeated_int32 = []  # needs RepeatedField\n    end\n\n    assert_raise Google::Protobuf::TypeError do\n      m.repeated_int32.push \"hello\"\n    end\n\n    assert_raise Google::Protobuf::TypeError do\n      m.repeated_msg.push proto_module::TestMessage.new\n    end\n  end\n\n  def test_string_encoding\n    m = proto_module::TestMessage.new\n\n    # Assigning a normal (ASCII or UTF8) string to a bytes field, or\n    # ASCII-8BIT to a string field will convert to the proper encoding.\n    m.optional_bytes = \"Test string ASCII\".encode!('ASCII')\n    assert m.optional_bytes.frozen?\n    assert_equal Encoding::ASCII_8BIT, m.optional_bytes.encoding\n    assert_equal \"Test string ASCII\", m.optional_bytes\n\n    assert_raise Encoding::UndefinedConversionError do\n      m.optional_bytes = \"Test string UTF-8 \\u0100\".encode!('UTF-8')\n    end\n\n    assert_raise Encoding::UndefinedConversionError do\n      m.optional_string = [\"FFFF\"].pack('H*')\n    end\n\n    # \"Ordinary\" use case.\n    m.optional_bytes = [\"FFFF\"].pack('H*')\n    m.optional_string = \"\\u0100\"\n\n    # strings are immutable so we can't do this, but serialize should catch it.\n    m.optional_string = \"asdf\".encode!('UTF-8')\n    assert_raise(FrozenErrorType) { m.optional_string.encode!('ASCII-8BIT') }\n  end\n\n  def test_rptfield_int32\n    l = Google::Protobuf::RepeatedField.new(:int32)\n    assert l.count == 0\n    l = Google::Protobuf::RepeatedField.new(:int32, [1, 2, 3])\n    assert l.count == 3\n    assert_equal [1, 2, 3], l\n    assert_equal l, [1, 2, 3]\n    l.push 4\n    assert l == [1, 2, 3, 4]\n    dst_list = []\n    l.each { |val| dst_list.push val }\n    assert dst_list == [1, 2, 3, 4]\n    assert l.to_a == [1, 2, 3, 4]\n    assert l[0] == 1\n    assert l[3] == 4\n    l[0] = 5\n    assert l == [5, 2, 3, 4]\n\n    l2 = l.dup\n    assert l == l2\n    assert l.object_id != l2.object_id\n    l2.push 6\n    assert l.count == 4\n    assert l2.count == 5\n\n    assert l.inspect == '[5, 2, 3, 4]'\n\n    l.concat([7, 8, 9])\n    assert l == [5, 2, 3, 4, 7, 8, 9]\n    assert l.pop == 9\n    assert l == [5, 2, 3, 4, 7, 8]\n\n    assert_raise Google::Protobuf::TypeError do\n      m = proto_module::TestMessage.new\n      l.push m\n    end\n\n    m = proto_module::TestMessage.new\n    m.repeated_int32 = l\n    assert m.repeated_int32 == [5, 2, 3, 4, 7, 8]\n    assert m.repeated_int32.object_id == l.object_id\n    l.push 42\n    assert m.repeated_int32.pop == 42\n\n    l3 = l + l.dup\n    assert l3.count == l.count * 2\n    l.count.times do |i|\n      assert l3[i] == l[i]\n      assert l3[l.count + i] == l[i]\n    end\n\n    l.clear\n    assert l.count == 0\n    l += [1, 2, 3, 4]\n    l.replace([5, 6, 7, 8])\n    assert l == [5, 6, 7, 8]\n\n    l4 = Google::Protobuf::RepeatedField.new(:int32)\n    l4[5] = 42\n    assert l4 == [0, 0, 0, 0, 0, 42]\n\n    l4 << 100\n    assert l4 == [0, 0, 0, 0, 0, 42, 100]\n    l4 << 101 << 102\n    assert l4 == [0, 0, 0, 0, 0, 42, 100, 101, 102]\n  end\n\n  def test_parent_rptfield\n    #make sure we set the RepeatedField and can add to it\n    m = proto_module::TestMessage.new\n    assert m.repeated_string == []\n    m.repeated_string << 'ok'\n    m.repeated_string.push('ok2')\n    assert m.repeated_string == ['ok', 'ok2']\n    m.repeated_string += ['ok3']\n    assert m.repeated_string == ['ok', 'ok2', 'ok3']\n  end\n\n  def test_rptfield_msg\n    l = Google::Protobuf::RepeatedField.new(:message, proto_module::TestMessage)\n    l.push proto_module::TestMessage.new\n    assert l.count == 1\n    assert_raise Google::Protobuf::TypeError do\n      l.push proto_module::TestMessage2.new\n    end\n    assert_raise Google::Protobuf::TypeError do\n      l.push 42\n    end\n\n    l2 = l.dup\n    assert l2[0] == l[0]\n    assert l2[0].object_id == l[0].object_id\n\n    l2 = Google::Protobuf.deep_copy(l)\n    assert l2[0] == l[0]\n    assert l2[0].object_id != l[0].object_id\n\n    l3 = l + l2\n    assert l3.count == 2\n    assert l3[0] == l[0]\n    assert l3[1] == l2[0]\n    l3[0].optional_int32 = 1000\n    assert l[0].optional_int32 == 1000\n\n    new_msg = proto_module::TestMessage.new(:optional_int32 => 200)\n    l4 = l + [new_msg]\n    assert l4.count == 2\n    new_msg.optional_int32 = 1000\n    assert l4[1].optional_int32 == 1000\n  end\n\n  def test_rptfield_enum\n    l = Google::Protobuf::RepeatedField.new(:enum, proto_module::TestEnum)\n    l.push :A\n    l.push :B\n    l.push :C\n    assert l.count == 3\n    assert_raise RangeError do\n      l.push :D\n    end\n    assert l[0] == :A\n\n    l.push 4\n    assert l[3] == 4\n  end\n\n  def test_rptfield_initialize\n    assert_raise ArgumentError do\n      Google::Protobuf::RepeatedField.new\n    end\n    assert_raise ArgumentError do\n      Google::Protobuf::RepeatedField.new(:message)\n    end\n    assert_raise ArgumentError do\n      Google::Protobuf::RepeatedField.new([1, 2, 3])\n    end\n    assert_raise ArgumentError do\n      Google::Protobuf::RepeatedField.new(:message, [proto_module::TestMessage2.new])\n    end\n  end\n\n  def test_rptfield_array_ducktyping\n    l = Google::Protobuf::RepeatedField.new(:int32)\n    length_methods = %w(count length size)\n    length_methods.each do |lm|\n      assert l.send(lm)  == 0\n    end\n    # out of bounds returns a nil\n    assert l[0] == nil\n    assert l[1] == nil\n    assert l[-1] == nil\n    l.push 4\n    length_methods.each do |lm|\n      assert l.send(lm) == 1\n    end\n    assert l[0] == 4\n    assert l[1] == nil\n    assert l[-1] == 4\n    assert l[-2] == nil\n\n    l.push 2\n    length_methods.each do |lm|\n      assert l.send(lm) == 2\n    end\n    assert l[0] == 4\n    assert l[1] == 2\n    assert l[2] == nil\n    assert l[-1] == 2\n    assert l[-2] == 4\n    assert l[-3] == nil\n\n    #adding out of scope will backfill with empty objects\n  end\n\n  def test_map_basic\n    # allowed key types:\n    # :int32, :int64, :uint32, :uint64, :bool, :string, :bytes.\n\n    m = Google::Protobuf::Map.new(:string, :int32)\n    m[\"asdf\"] = 1\n    assert m[\"asdf\"] == 1\n    m[\"jkl;\"] = 42\n    assert m == { \"jkl;\" => 42, \"asdf\" => 1 }\n    assert m.has_key?(\"asdf\")\n    assert !m.has_key?(\"qwerty\")\n    assert m.length == 2\n\n    m2 = m.dup\n    assert_equal m, m2\n    assert m.hash != 0\n    assert_equal m.hash, m2.hash\n\n    collected = {}\n    m.each { |k,v| collected[v] = k }\n    assert collected == { 42 => \"jkl;\", 1 => \"asdf\" }\n\n    assert m.delete(\"asdf\") == 1\n    assert !m.has_key?(\"asdf\")\n    assert m[\"asdf\"] == nil\n    assert !m.has_key?(\"asdf\")\n\n    # We only assert on inspect value when there is one map entry because the\n    # order in which elements appear is unspecified (depends on the internal\n    # hash function). We don't want a brittle test.\n    assert m.inspect == \"{\\\"jkl;\\\"=>42}\"\n\n    assert m.keys == [\"jkl;\"]\n    assert m.values == [42]\n\n    m.clear\n    assert m.length == 0\n    assert m == {}\n\n    assert_raise Google::Protobuf::TypeError do\n      m[1] = 1\n    end\n    assert_raise RangeError do\n      m[\"asdf\"] = 0x1_0000_0000\n    end\n  end\n\n  def test_b_8385\n    m1 = Google::Protobuf::Map.new(:string, :string)\n    m2 = Google::Protobuf::Map.new(:string, :string)\n\n    assert_equal m1, m2\n\n    m1[\"counter\"] = \"a\"\n    m2[\"counter\"] = \"aa\"\n\n    assert_not_equal m1, m2\n  end\n\n  def test_map_ctor\n    m = Google::Protobuf::Map.new(:string, :int32,\n                                  {\"a\" => 1, \"b\" => 2, \"c\" => 3})\n    assert m == {\"a\" => 1, \"c\" => 3, \"b\" => 2}\n  end\n\n  def test_map_keytypes\n    m = Google::Protobuf::Map.new(:int32, :int32)\n    m[1] = 42\n    m[-1] = 42\n    assert_raise RangeError do\n      m[0x8000_0000] = 1\n    end\n    assert_raise Google::Protobuf::TypeError do\n      m[\"asdf\"] = 1\n    end\n\n    m = Google::Protobuf::Map.new(:int64, :int32)\n    m[0x1000_0000_0000_0000] = 1\n    assert_raise RangeError do\n      m[0x1_0000_0000_0000_0000] = 1\n    end\n    assert_raise Google::Protobuf::TypeError do\n      m[\"asdf\"] = 1\n    end\n\n    m = Google::Protobuf::Map.new(:uint32, :int32)\n    m[0x8000_0000] = 1\n    assert_raise RangeError do\n      m[0x1_0000_0000] = 1\n    end\n    assert_raise RangeError do\n      m[-1] = 1\n    end\n\n    m = Google::Protobuf::Map.new(:uint64, :int32)\n    m[0x8000_0000_0000_0000] = 1\n    assert_raise RangeError do\n      m[0x1_0000_0000_0000_0000] = 1\n    end\n    assert_raise RangeError do\n      m[-1] = 1\n    end\n\n    m = Google::Protobuf::Map.new(:bool, :int32)\n    m[true] = 1\n    m[false] = 2\n    assert_raise Google::Protobuf::TypeError do\n      m[1] = 1\n    end\n    assert_raise Google::Protobuf::TypeError do\n      m[\"asdf\"] = 1\n    end\n\n    m = Google::Protobuf::Map.new(:string, :int32)\n    m[\"asdf\"] = 1\n    assert_raise Google::Protobuf::TypeError do\n      m[1] = 1\n    end\n    assert_raise Encoding::UndefinedConversionError do\n      bytestring = [\"FFFF\"].pack(\"H*\")\n      m[bytestring] = 1\n    end\n\n    m = Google::Protobuf::Map.new(:bytes, :int32)\n    bytestring = [\"FFFF\"].pack(\"H*\")\n    m[bytestring] = 1\n    # Allowed -- we will automatically convert to ASCII-8BIT.\n    m[\"asdf\"] = 1\n    assert_raise Google::Protobuf::TypeError do\n      m[1] = 1\n    end\n  end\n\n  def test_map_msg_enum_valuetypes\n    m = Google::Protobuf::Map.new(:string, :message, proto_module::TestMessage)\n    m[\"asdf\"] = proto_module::TestMessage.new\n    assert_raise Google::Protobuf::TypeError do\n      m[\"jkl;\"] = proto_module::TestMessage2.new\n    end\n\n    m = Google::Protobuf::Map.new(\n      :string, :message, proto_module::TestMessage,\n      { \"a\" => proto_module::TestMessage.new(:optional_int32 => 42),\n        \"b\" => proto_module::TestMessage.new(:optional_int32 => 84) })\n    assert m.length == 2\n    assert m.values.map{|msg| msg.optional_int32}.sort == [42, 84]\n\n    m = Google::Protobuf::Map.new(:string, :enum, proto_module::TestEnum,\n                                  { \"x\" => :A, \"y\" => :B, \"z\" => :C })\n    assert m.length == 3\n    assert m[\"z\"] == :C\n    m[\"z\"] = 2\n    assert m[\"z\"] == :B\n    m[\"z\"] = 4\n    assert m[\"z\"] == 4\n    assert_raise RangeError do\n      m[\"z\"] = :Z\n    end\n    assert_raise RangeError do\n      m[\"z\"] = \"z\"\n    end\n  end\n\n  def test_map_dup_deep_copy\n    m = Google::Protobuf::Map.new(\n      :string, :message, proto_module::TestMessage,\n      { \"a\" => proto_module::TestMessage.new(:optional_int32 => 42),\n        \"b\" => proto_module::TestMessage.new(:optional_int32 => 84) })\n\n    m2 = m.dup\n    assert m.to_h == m2.to_h\n    assert m == m2\n    assert m.object_id != m2.object_id\n    assert m[\"a\"].object_id == m2[\"a\"].object_id\n    assert m[\"b\"].object_id == m2[\"b\"].object_id\n\n    m2 = Google::Protobuf.deep_copy(m)\n    assert m == m2\n    assert m.object_id != m2.object_id\n    assert m[\"a\"].object_id != m2[\"a\"].object_id\n    assert m[\"b\"].object_id != m2[\"b\"].object_id\n  end\n\n  def test_oneof_descriptors\n    d = proto_module::OneofMessage.descriptor\n    o = d.lookup_oneof(\"my_oneof\")\n    assert o != nil\n    assert o.class == Google::Protobuf::OneofDescriptor\n    assert o.name == \"my_oneof\"\n    oneof_count = 0\n    d.each_oneof{ |oneof|\n      oneof_count += 1\n      assert oneof == o\n    }\n    assert oneof_count == 1\n    assert o.count == 4\n    field_names = o.map{|f| f.name}.sort\n    assert field_names == [\"a\", \"b\", \"c\", \"d\"]\n  end\n\n  def test_oneof\n    d = proto_module::OneofMessage.new\n    assert d.a == \"\"\n    assert d.b == 0\n    assert d.c == nil\n    assert d.d == :Default\n    assert d.my_oneof == nil\n\n    d.a = \"hi\"\n    assert d.a == \"hi\"\n    assert d.b == 0\n    assert d.c == nil\n    assert d.d == :Default\n    assert d.my_oneof == :a\n\n    d.b = 42\n    assert d.a == \"\"\n    assert d.b == 42\n    assert d.c == nil\n    assert d.d == :Default\n    assert d.my_oneof == :b\n\n    d.c = proto_module::TestMessage2.new(:foo => 100)\n    assert d.a == \"\"\n    assert d.b == 0\n    assert d.c.foo == 100\n    assert d.d == :Default\n    assert d.my_oneof == :c\n\n    d.d = :C\n    assert d.a == \"\"\n    assert d.b == 0\n    assert d.c == nil\n    assert d.d == :C\n    assert d.my_oneof == :d\n\n    d2 = proto_module::OneofMessage.decode(proto_module::OneofMessage.encode(d))\n    assert d2 == d\n\n    encoded_field_a = proto_module::OneofMessage.encode(proto_module::OneofMessage.new(:a => \"string\"))\n    encoded_field_b = proto_module::OneofMessage.encode(proto_module::OneofMessage.new(:b => 1000))\n    encoded_field_c = proto_module::OneofMessage.encode(\n      proto_module::OneofMessage.new(:c => proto_module::TestMessage2.new(:foo => 1)))\n    encoded_field_d = proto_module::OneofMessage.encode(proto_module::OneofMessage.new(:d => :B))\n\n    d3 = proto_module::OneofMessage.decode(\n      encoded_field_c + encoded_field_a + encoded_field_b + encoded_field_d)\n    assert d3.a == \"\"\n    assert d3.b == 0\n    assert d3.c == nil\n    assert d3.d == :B\n\n    d4 = proto_module::OneofMessage.decode(\n      encoded_field_c + encoded_field_a + encoded_field_b + encoded_field_d +\n      encoded_field_c)\n    assert d4.a == \"\"\n    assert d4.b == 0\n    assert d4.c.foo == 1\n    assert d4.d == :Default\n\n    d5 = proto_module::OneofMessage.new(:a => \"hello\")\n    assert d5.a == \"hello\"\n    d5.a = nil\n    assert d5.a == \"\"\n    assert proto_module::OneofMessage.encode(d5) == ''\n    assert d5.my_oneof == nil\n  end\n\n  def test_enum_field\n    m = proto_module::TestMessage.new\n    assert m.optional_enum == :Default\n    m.optional_enum = :A\n    assert m.optional_enum == :A\n    assert_raise RangeError do\n      m.optional_enum = :ASDF\n    end\n    m.optional_enum = 1\n    assert m.optional_enum == :A\n    m.optional_enum = 100\n    assert m.optional_enum == 100\n  end\n\n  def test_dup\n    m = proto_module::TestMessage.new\n    m.optional_string = \"hello\"\n    m.optional_int32 = 42\n    tm1 = proto_module::TestMessage2.new(:foo => 100)\n    tm2 = proto_module::TestMessage2.new(:foo => 200)\n    m.repeated_msg.push tm1\n    assert m.repeated_msg[-1] == tm1\n    m.repeated_msg.push tm2\n    assert m.repeated_msg[-1] == tm2\n    m2 = m.dup\n    assert m == m2\n    m.optional_int32 += 1\n    assert m != m2\n    assert m.repeated_msg[0] == m2.repeated_msg[0]\n    assert m.repeated_msg[0].object_id == m2.repeated_msg[0].object_id\n  end\n\n  def test_deep_copy\n    m = proto_module::TestMessage.new(:optional_int32 => 42,\n                                      :repeated_msg => [proto_module::TestMessage2.new(:foo => 100)])\n    m2 = Google::Protobuf.deep_copy(m)\n    assert m == m2\n    assert m.repeated_msg == m2.repeated_msg\n    assert m.repeated_msg.object_id != m2.repeated_msg.object_id\n    assert m.repeated_msg[0].object_id != m2.repeated_msg[0].object_id\n  end\n\n  def test_message_eq\n    m = proto_module::TestMessage.new(:optional_int32 => 42,\n                                      :repeated_int32 => [1, 2, 3])\n    m2 = proto_module::TestMessage.new(:optional_int32 => 43,\n                                       :repeated_int32 => [1, 2, 3])\n    assert m != m2\n    assert_not_equal proto_module::TestMessage.new, proto_module::TestMessage2.new\n  end\n\n  def test_enum_lookup\n    assert proto_module::TestEnum::A == 1\n    assert proto_module::TestEnum::B == 2\n    assert proto_module::TestEnum::C == 3\n\n    assert proto_module::TestEnum::lookup(1) == :A\n    assert proto_module::TestEnum::lookup(2) == :B\n    assert proto_module::TestEnum::lookup(3) == :C\n\n    assert proto_module::TestEnum::resolve(:A) == 1\n    assert proto_module::TestEnum::resolve(:B) == 2\n    assert proto_module::TestEnum::resolve(:C) == 3\n  end\n\n  def test_enum_const_get_helpers\n    m = proto_module::TestMessage.new\n    assert_equal proto_module::TestEnum::Default, m.optional_enum_const\n    assert_equal proto_module::TestEnum.const_get(:Default), m.optional_enum_const\n\n    m = proto_module::TestMessage.new({optional_enum: proto_module::TestEnum::A})\n    assert_equal proto_module::TestEnum::A, m.optional_enum_const\n    assert_equal proto_module::TestEnum.const_get(:A), m.optional_enum_const\n\n    m = proto_module::TestMessage.new({optional_enum: proto_module::TestEnum::B})\n    assert_equal proto_module::TestEnum::B, m.optional_enum_const\n    assert_equal proto_module::TestEnum.const_get(:B), m.optional_enum_const\n\n    m = proto_module::TestMessage.new({optional_enum: proto_module::TestEnum::C})\n    assert_equal proto_module::TestEnum::C, m.optional_enum_const\n    assert_equal proto_module::TestEnum.const_get(:C), m.optional_enum_const\n\n    m = proto_module::TestMessage2.new({foo: 2})\n    assert_equal 2, m.foo\n    assert_raise(NoMethodError) { m.foo_ }\n    assert_raise(NoMethodError) { m.foo_X }\n    assert_raise(NoMethodError) { m.foo_XX }\n    assert_raise(NoMethodError) { m.foo_XXX }\n    assert_raise(NoMethodError) { m.foo_XXXX }\n    assert_raise(NoMethodError) { m.foo_XXXXX }\n    assert_raise(NoMethodError) { m.foo_XXXXXX }\n\n    m = proto_module::Enumer.new({optional_enum: :B})\n    assert_equal :B, m.optional_enum\n    assert_raise(NoMethodError) { m.optional_enum_ }\n    assert_raise(NoMethodError) { m.optional_enum_X }\n    assert_raise(NoMethodError) { m.optional_enum_XX }\n    assert_raise(NoMethodError) { m.optional_enum_XXX }\n    assert_raise(NoMethodError) { m.optional_enum_XXXX }\n    assert_raise(NoMethodError) { m.optional_enum_XXXXX }\n    assert_raise(NoMethodError) { m.optional_enum_XXXXXX }\n  end\n\n  def test_enum_getter\n    m = proto_module::Enumer.new(:optional_enum => :B, :repeated_enum => [:A, :C])\n\n    assert_equal :B, m.optional_enum\n    assert_equal 2, m.optional_enum_const\n    assert_equal proto_module::TestEnum::B, m.optional_enum_const\n    assert_equal [:A, :C], m.repeated_enum\n    assert_equal [1, 3], m.repeated_enum_const\n    assert_equal [proto_module::TestEnum::A, proto_module::TestEnum::C], m.repeated_enum_const\n  end\n\n  def test_enum_getter_oneof\n    m = proto_module::Enumer.new(:const => :C)\n\n    assert_equal :C, m.const\n    assert_equal 3, m.const_const\n    assert_equal proto_module::TestEnum::C, m.const_const\n  end\n\n  def test_enum_getter_only_enums\n    m = proto_module::Enumer.new(:optional_enum => :B, :a_const => 'thing')\n\n    assert_equal 'thing', m.a_const\n    assert_equal :B, m.optional_enum\n\n    assert_raise(NoMethodError) { m.a }\n    assert_raise(NoMethodError) { m.a_const_const }\n  end\n  \n  def test_repeated_push\n    m = proto_module::TestMessage.new\n\n    m.repeated_string += ['one']\n    m.repeated_string += %w[two three]\n    assert_equal %w[one two three], m.repeated_string\n\n    m.repeated_string.push( *['four', 'five'] )\n    assert_equal %w[one two three four five], m.repeated_string\n\n    m.repeated_string.push 'six', 'seven'\n    assert_equal %w[one two three four five six seven], m.repeated_string\n\n    m = proto_module::TestMessage.new\n\n    m.repeated_msg += [proto_module::TestMessage2.new(:foo => 1), proto_module::TestMessage2.new(:foo => 2)]\n    m.repeated_msg += [proto_module::TestMessage2.new(:foo => 3)]\n    m.repeated_msg.push proto_module::TestMessage2.new(:foo => 4), proto_module::TestMessage2.new(:foo => 5)\n    assert_equal [1, 2, 3, 4, 5], m.repeated_msg.map {|x| x.foo}\n  end\n\n  def test_parse_serialize\n    m = proto_module::TestMessage.new(:optional_int32 => 42,\n                                      :optional_string => \"hello world\",\n                                      :optional_enum => :B,\n                                      :repeated_string => [\"a\", \"b\", \"c\"],\n                                      :repeated_int32 => [42, 43, 44],\n                                      :repeated_enum => [:A, :B, :C],\n                                      :repeated_msg => [proto_module::TestMessage2.new(:foo => 1),\n                                                        proto_module::TestMessage2.new(:foo => 2)])\n    if proto_module == ::BasicTest\n      # For proto3 we can add an unknown enum value safely.\n      m.repeated_enum << 100\n    end\n\n    data = proto_module::TestMessage.encode m\n    m2 = proto_module::TestMessage.decode data\n\n    assert_equal m, m2\n\n    data = Google::Protobuf.encode m\n    m2 = Google::Protobuf.decode(proto_module::TestMessage, data)\n    assert m == m2\n  end\n\n  def test_encode_decode_helpers\n    m = proto_module::TestMessage.new(:optional_string => 'foo', :repeated_string => ['bar1', 'bar2'])\n    assert_equal 'foo', m.optional_string\n    assert_equal ['bar1', 'bar2'], m.repeated_string\n\n    json = m.to_json\n    m2 = proto_module::TestMessage.decode_json(json)\n    assert_equal 'foo', m2.optional_string\n    assert_equal ['bar1', 'bar2'], m2.repeated_string\n    if RUBY_PLATFORM != \"java\"\n      assert m2.optional_string.frozen?\n      assert m2.repeated_string[0].frozen?\n    end\n\n    proto = m.to_proto\n    m2 = proto_module::TestMessage.decode(proto)\n    assert_equal 'foo', m2.optional_string\n    assert_equal ['bar1', 'bar2'], m2.repeated_string\n  end\n\n  def test_protobuf_encode_decode_helpers\n    m = proto_module::TestMessage.new(:optional_string => 'foo', :repeated_string => ['bar1', 'bar2'])\n    encoded_msg = Google::Protobuf.encode(m)\n    assert_equal m.to_proto, encoded_msg\n\n    decoded_msg = Google::Protobuf.decode(proto_module::TestMessage, encoded_msg)\n    assert_equal proto_module::TestMessage.decode(m.to_proto), decoded_msg\n  end\n\n  def test_protobuf_encode_decode_json_helpers\n    m = proto_module::TestMessage.new(:optional_string => 'foo', :repeated_string => ['bar1', 'bar2'])\n    encoded_msg = Google::Protobuf.encode_json(m)\n    assert_equal m.to_json, encoded_msg\n\n    decoded_msg = Google::Protobuf.decode_json(proto_module::TestMessage, encoded_msg)\n    assert_equal proto_module::TestMessage.decode_json(m.to_json), decoded_msg\n\n    assert_equal [m].to_json, Google::Protobuf.encode_json([m])\n    assert_equal proto_module::TestMessage.decode_json([m.to_json].first), decoded_msg\n  end\n\n  def test_def_errors\n    s = Google::Protobuf::DescriptorPool.new\n    assert_raise Google::Protobuf::TypeError do\n      s.build do\n        # enum with no default (integer value 0)\n        add_enum \"MyEnum\" do\n          value :A, 1\n        end\n      end\n    end\n    assert_raise Google::Protobuf::TypeError do\n      s.build do\n        # message with required field (unsupported in proto3)\n        add_message \"MyMessage\" do\n          required :foo, :int32, 1\n        end\n      end\n    end\n  end\n\n  def test_corecursive\n    # just be sure that we can instantiate types with corecursive field-type\n    # references.\n    m = proto_module::Recursive1.new(:foo => proto_module::Recursive2.new(:foo => proto_module::Recursive1.new))\n    assert proto_module::Recursive1.descriptor.lookup(\"foo\").subtype ==\n           proto_module::Recursive2.descriptor\n    assert proto_module::Recursive2.descriptor.lookup(\"foo\").subtype ==\n           proto_module::Recursive1.descriptor\n\n    serialized = proto_module::Recursive1.encode(m)\n    m2 = proto_module::Recursive1.decode(serialized)\n    assert m == m2\n  end\n\n  def test_serialize_cycle\n    m = proto_module::Recursive1.new(:foo => proto_module::Recursive2.new)\n    m.foo.foo = m\n    assert_raise RuntimeError do\n      proto_module::Recursive1.encode(m)\n    end\n  end\n\n  def test_bad_field_names\n    m = proto_module::BadFieldNames.new(:dup => 1, :class => 2)\n    m2 = m.dup\n    assert m == m2\n    assert m['dup'] == 1\n    assert m['class'] == 2\n    m['dup'] = 3\n    assert m['dup'] == 3\n  end\n\n  def test_int_ranges\n    m = proto_module::TestMessage.new\n\n    m.optional_int32 = 0\n    m.optional_int32 = -0x8000_0000\n    m.optional_int32 = +0x7fff_ffff\n    m.optional_int32 = 1.0\n    m.optional_int32 = -1.0\n    m.optional_int32 = 2e9\n    assert_raise RangeError do\n      m.optional_int32 = -0x8000_0001\n    end\n    assert_raise RangeError do\n      m.optional_int32 = +0x8000_0000\n    end\n    assert_raise RangeError do\n      m.optional_int32 = +0x1000_0000_0000_0000_0000_0000 # force Bignum\n    end\n    assert_raise RangeError do\n      m.optional_int32 = 1e12\n    end\n    assert_raise RangeError do\n      m.optional_int32 = 1.5\n    end\n\n    m.optional_uint32 = 0\n    m.optional_uint32 = +0xffff_ffff\n    m.optional_uint32 = 1.0\n    m.optional_uint32 = 4e9\n    assert_raise RangeError do\n      m.optional_uint32 = -1\n    end\n    assert_raise RangeError do\n      m.optional_uint32 = -1.5\n    end\n    assert_raise RangeError do\n      m.optional_uint32 = -1.5e12\n    end\n    assert_raise RangeError do\n      m.optional_uint32 = -0x1000_0000_0000_0000\n    end\n    assert_raise RangeError do\n      m.optional_uint32 = +0x1_0000_0000\n    end\n    assert_raise RangeError do\n      m.optional_uint32 = +0x1000_0000_0000_0000_0000_0000 # force Bignum\n    end\n    assert_raise RangeError do\n      m.optional_uint32 = 1e12\n    end\n    assert_raise RangeError do\n      m.optional_uint32 = 1.5\n    end\n\n    m.optional_int64 = 0\n    m.optional_int64 = -0x8000_0000_0000_0000\n    m.optional_int64 = +0x7fff_ffff_ffff_ffff\n    m.optional_int64 = 1.0\n    m.optional_int64 = -1.0\n    m.optional_int64 = 8e18\n    m.optional_int64 = -8e18\n    assert_raise RangeError do\n      m.optional_int64 = -0x8000_0000_0000_0001\n    end\n    assert_raise RangeError do\n      m.optional_int64 = +0x8000_0000_0000_0000\n    end\n    assert_raise RangeError do\n      m.optional_int64 = +0x1000_0000_0000_0000_0000_0000 # force Bignum\n    end\n    assert_raise RangeError do\n      m.optional_int64 = 1e50\n    end\n    assert_raise RangeError do\n      m.optional_int64 = 1.5\n    end\n\n    m.optional_uint64 = 0\n    m.optional_uint64 = +0xffff_ffff_ffff_ffff\n    m.optional_uint64 = 1.0\n    m.optional_uint64 = 16e18\n    assert_raise RangeError do\n      m.optional_uint64 = -1\n    end\n    assert_raise RangeError do\n      m.optional_uint64 = -1.5\n    end\n    assert_raise RangeError do\n      m.optional_uint64 = -1.5e12\n    end\n    assert_raise RangeError do\n      m.optional_uint64 = -0x1_0000_0000_0000_0000\n    end\n    assert_raise RangeError do\n      m.optional_uint64 = +0x1_0000_0000_0000_0000\n    end\n    assert_raise RangeError do\n      m.optional_uint64 = +0x1000_0000_0000_0000_0000_0000 # force Bignum\n    end\n    assert_raise RangeError do\n      m.optional_uint64 = 1e50\n    end\n    assert_raise RangeError do\n      m.optional_uint64 = 1.5\n    end\n  end\n\n  def test_stress_test\n    m = proto_module::TestMessage.new\n    m.optional_int32 = 42\n    m.optional_int64 = 0x100000000\n    m.optional_string = \"hello world\"\n    10.times do m.repeated_msg.push proto_module::TestMessage2.new(:foo => 42) end\n    10.times do m.repeated_string.push \"hello world\" end\n\n    data = proto_module::TestMessage.encode(m)\n\n    10_000.times do\n      m = proto_module::TestMessage.decode(data)\n      data_new = proto_module::TestMessage.encode(m)\n      assert data_new == data\n      data = data_new\n    end\n  end\n\n  def test_reflection\n    m = proto_module::TestMessage.new(:optional_int32 => 1234)\n    msgdef = m.class.descriptor\n    assert msgdef.class == Google::Protobuf::Descriptor\n    assert msgdef.any? {|field| field.name == \"optional_int32\"}\n    optional_int32 = msgdef.lookup \"optional_int32\"\n    assert optional_int32.class == Google::Protobuf::FieldDescriptor\n    assert optional_int32 != nil\n    assert optional_int32.name == \"optional_int32\"\n    assert optional_int32.type == :int32\n    optional_int32.set(m, 5678)\n    assert m.optional_int32 == 5678\n    m.optional_int32 = 1000\n    assert optional_int32.get(m) == 1000\n\n    optional_msg = msgdef.lookup \"optional_msg\"\n    assert optional_msg.subtype == proto_module::TestMessage2.descriptor\n\n    optional_msg.set(m, optional_msg.subtype.msgclass.new)\n\n    assert msgdef.msgclass == proto_module::TestMessage\n\n    optional_enum = msgdef.lookup \"optional_enum\"\n    assert optional_enum.subtype == proto_module::TestEnum.descriptor\n    assert optional_enum.subtype.class == Google::Protobuf::EnumDescriptor\n    optional_enum.subtype.each do |k, v|\n      # set with integer, check resolution to symbolic name\n      optional_enum.set(m, v)\n      assert optional_enum.get(m) == k\n    end\n  end\n\n  def test_json\n    m = proto_module::TestMessage.new(:optional_int32 => 1234,\n                                      :optional_int64 => -0x1_0000_0000,\n                                      :optional_uint32 => 0x8000_0000,\n                                      :optional_uint64 => 0xffff_ffff_ffff_ffff,\n                                      :optional_bool => true,\n                                      :optional_float => 1.0,\n                                      :optional_double => -1e100,\n                                      :optional_string => \"Test string\",\n                                      :optional_bytes => [\"FFFFFFFF\"].pack('H*'),\n                                      :optional_msg => proto_module::TestMessage2.new(:foo => 42),\n                                      :repeated_int32 => [1, 2, 3, 4],\n                                      :repeated_string => [\"a\", \"b\", \"c\"],\n                                      :repeated_bool => [true, false, true, false],\n                                      :repeated_msg => [proto_module::TestMessage2.new(:foo => 1),\n                                                        proto_module::TestMessage2.new(:foo => 2)])\n\n    json_text = proto_module::TestMessage.encode_json(m)\n    m2 = proto_module::TestMessage.decode_json(json_text)\n    assert_equal m, m2\n\n    # Crash case from GitHub issue 283.\n    bar = proto_module::Bar.new(msg: \"bar\")\n    baz1 = proto_module::Baz.new(msg: \"baz\")\n    baz2 = proto_module::Baz.new(msg: \"quux\")\n    proto_module::Foo.encode_json(proto_module::Foo.new)\n    proto_module::Foo.encode_json(proto_module::Foo.new(bar: bar))\n    proto_module::Foo.encode_json(proto_module::Foo.new(bar: bar, baz: [baz1, baz2]))\n  end\n\n  def test_json_empty\n    assert proto_module::TestMessage.encode_json(proto_module::TestMessage.new) == '{}'\n  end\n\n  def test_json_emit_defaults\n    # TODO: Fix JSON in JRuby version.\n    return if RUBY_PLATFORM == \"java\"\n    m = proto_module::TestMessage.new\n\n    expected = {\n      repeatedInt32: [],\n      repeatedInt64: [],\n      repeatedUint32: [],\n      repeatedUint64: [],\n      repeatedBool: [],\n      repeatedFloat: [],\n      repeatedDouble: [],\n      repeatedString: [],\n      repeatedBytes: [],\n      repeatedMsg: [],\n      repeatedEnum: []\n    }\n\n    actual = proto_module::TestMessage.encode_json(m, :emit_defaults => true)\n\n    assert_equal expected, JSON.parse(actual, :symbolize_names => true)\n  end\n\n  def test_json_emit_defaults_submsg\n    # TODO: Fix JSON in JRuby version.\n    return if RUBY_PLATFORM == \"java\"\n    m = proto_module::TestMessage.new(optional_msg: proto_module::TestMessage2.new)\n\n    expected = {\n      optionalMsg: {},\n      repeatedInt32: [],\n      repeatedInt64: [],\n      repeatedUint32: [],\n      repeatedUint64: [],\n      repeatedBool: [],\n      repeatedFloat: [],\n      repeatedDouble: [],\n      repeatedString: [],\n      repeatedBytes: [],\n      repeatedMsg: [],\n      repeatedEnum: []\n    }\n\n    actual = proto_module::TestMessage.encode_json(m, :emit_defaults => true)\n\n    assert_equal expected, JSON.parse(actual, :symbolize_names => true)\n  end\n\n  def test_json_emit_defaults_repeated_submsg\n    # TODO: Fix JSON in JRuby version.\n    return if RUBY_PLATFORM == \"java\"\n    m = proto_module::TestMessage.new(repeated_msg: [proto_module::TestMessage2.new])\n\n    expected = {\n      repeatedInt32: [],\n      repeatedInt64: [],\n      repeatedUint32: [],\n      repeatedUint64: [],\n      repeatedBool: [],\n      repeatedFloat: [],\n      repeatedDouble: [],\n      repeatedString: [],\n      repeatedBytes: [],\n      repeatedMsg: [{}],\n      repeatedEnum: []\n    }\n\n    actual = proto_module::TestMessage.encode_json(m, :emit_defaults => true)\n\n    assert_equal expected, JSON.parse(actual, :symbolize_names => true)\n  end\n\n  def value_from_ruby(value)\n    ret = Google::Protobuf::Value.new\n    case value\n    when String\n      ret.string_value = value\n    when Google::Protobuf::Struct\n      ret.struct_value = value\n    when Hash\n      ret.struct_value = struct_from_ruby(value)\n    when Google::Protobuf::ListValue\n      ret.list_value = value\n    when Array\n      ret.list_value = list_from_ruby(value)\n    else\n      @log.error \"Unknown type: #{value.class}\"\n      raise Google::Protobuf::Error, \"Unknown type: #{value.class}\"\n    end\n    ret\n  end\n\n  def list_from_ruby(arr)\n    ret = Google::Protobuf::ListValue.new\n    arr.each do |v|\n      ret.values << value_from_ruby(v)\n    end\n    ret\n  end\n\n  def struct_from_ruby(hash)\n    ret = Google::Protobuf::Struct.new\n    hash.each do |k, v|\n      ret.fields[k] ||= value_from_ruby(v)\n    end\n    ret\n  end\n\n  def test_deep_json\n    # will not overflow\n    json = '{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":'\\\n           '{\"a\":{\"a\":{\"a\":{\"a\":{}}}}}}}}}}}}}}}}'\n\n    struct = struct_from_ruby(JSON.parse(json))\n    assert_equal json, struct.to_json\n\n    encoded = proto_module::MyRepeatedStruct.encode(\n      proto_module::MyRepeatedStruct.new(structs: [proto_module::MyStruct.new(struct: struct)]))\n    assert_equal json, proto_module::MyRepeatedStruct.decode(encoded).structs[0].struct.to_json\n\n    # will overflow\n    json = '{\"a\":{\"a\":{\"a\":[{\"a\":{\"a\":[{\"a\":[{\"a\":{\"a\":[{\"a\":[{\"a\":'\\\n           '{\"a\":[{\"a\":[{\"a\":{\"a\":{\"a\":[{\"a\":\"a\"}]}}}]}]}}]}]}}]}]}}]}}}'\n\n    struct = struct_from_ruby(JSON.parse(json))\n    assert_equal json, struct.to_json\n\n    assert_raise(RuntimeError, \"Recursion limit exceeded during encoding\") do\n      struct = Google::Protobuf::Struct.new\n      struct.fields[\"foobar\"] = Google::Protobuf::Value.new(struct_value: struct)\n      Google::Protobuf::Struct.encode(struct)\n    end\n  end\n\n  def test_comparison_with_arbitrary_object\n    assert proto_module::TestMessage.new != nil\n  end\n\n  def test_wrappers_set_to_default\n    run_asserts = ->(m) {\n      assert_equal 0.0, m.double.value\n      assert_equal 0.0, m.float.value\n      assert_equal 0, m.int32.value\n      assert_equal 0, m.int64.value\n      assert_equal 0, m.uint32.value\n      assert_equal 0, m.uint64.value\n      assert_equal false, m.bool.value\n      assert_equal '', m.string.value\n      assert_equal '', m.bytes.value\n    }\n\n    m = proto_module::Wrapper.new(\n      double: Google::Protobuf::DoubleValue.new(value: 0.0),\n      float: Google::Protobuf::FloatValue.new(value: 0.0),\n      int32: Google::Protobuf::Int32Value.new(value: 0),\n      int64: Google::Protobuf::Int64Value.new(value: 0),\n      uint32: Google::Protobuf::UInt32Value.new(value: 0),\n      uint64: Google::Protobuf::UInt64Value.new(value: 0),\n      bool: Google::Protobuf::BoolValue.new(value: false),\n      string: Google::Protobuf::StringValue.new(value: \"\"),\n      bytes: Google::Protobuf::BytesValue.new(value: ''),\n    )\n\n    run_asserts.call(m)\n    m2 = proto_module::Wrapper.decode(m.to_proto)\n    run_asserts.call(m2)\n    m3 = proto_module::Wrapper.decode_json(m.to_json)\n    run_asserts.call(m3)\n  end\n\n  def test_wrapper_getters\n    run_asserts = ->(m) {\n      assert_equal 2.0, m.double_as_value\n      assert_equal 2.0, m.double.value\n      assert_equal 2.0, m.double_as_value\n\n      assert_equal 4.0, m.float_as_value\n      assert_equal 4.0, m.float.value\n      assert_equal 4.0, m.float_as_value\n\n      assert_equal 3, m.int32_as_value\n      assert_equal 3, m.int32.value\n      assert_equal 3, m.int32_as_value\n\n      assert_equal 4, m.int64_as_value\n      assert_equal 4, m.int64.value\n      assert_equal 4, m.int64_as_value\n\n      assert_equal 5, m.uint32_as_value\n      assert_equal 5, m.uint32.value\n      assert_equal 5, m.uint32_as_value\n\n      assert_equal 6, m.uint64_as_value\n      assert_equal 6, m.uint64.value\n      assert_equal 6, m.uint64_as_value\n\n      assert_equal true, m.bool_as_value\n      assert_equal true, m.bool.value\n      assert_equal true, m.bool_as_value\n\n      assert_equal \"st\\nr\", m.string_as_value\n      assert_equal \"st\\nr\", m.string.value\n      assert_equal \"st\\nr\", m.string_as_value\n\n      assert_equal 'fun', m.bytes_as_value\n      assert_equal 'fun', m.bytes.value\n      assert_equal 'fun', m.bytes_as_value\n    }\n\n    m = proto_module::Wrapper.new(\n      double: Google::Protobuf::DoubleValue.new(value: 2.0),\n      float: Google::Protobuf::FloatValue.new(value: 4.0),\n      int32: Google::Protobuf::Int32Value.new(value: 3),\n      int64: Google::Protobuf::Int64Value.new(value: 4),\n      uint32: Google::Protobuf::UInt32Value.new(value: 5),\n      uint64: Google::Protobuf::UInt64Value.new(value: 6),\n      bool: Google::Protobuf::BoolValue.new(value: true),\n      string: Google::Protobuf::StringValue.new(value: \"st\\nr\"),\n      bytes: Google::Protobuf::BytesValue.new(value: 'fun'),\n      real_string: '100'\n    )\n\n    run_asserts.call(m)\n    serialized = proto_module::Wrapper::encode(m)\n    m2 = proto_module::Wrapper::decode(serialized)\n    run_asserts.call(m2)\n\n    # Test the case where we are serializing directly from the parsed form\n    # (before anything lazy is materialized).\n    m3 = proto_module::Wrapper::decode(serialized)\n    serialized2 = proto_module::Wrapper::encode(m3)\n    m4 = proto_module::Wrapper::decode(serialized2)\n    run_asserts.call(m4)\n\n    # Test that the lazy form compares equal to the expanded form.\n    m5 = proto_module::Wrapper::decode(serialized2)\n    assert_equal m5, m\n\n    serialized_json = proto_module::Wrapper::encode_json(m)\n    m6 = proto_module::Wrapper::decode_json(serialized_json)\n    assert_equal m6, m\n  end\n\n  def test_repeated_wrappers\n    run_asserts = ->(m) {\n      assert_equal 2.0, m.repeated_double[0].value\n      assert_equal 4.0, m.repeated_float[0].value\n      assert_equal 3, m.repeated_int32[0].value\n      assert_equal 4, m.repeated_int64[0].value\n      assert_equal 5, m.repeated_uint32[0].value\n      assert_equal 6, m.repeated_uint64[0].value\n      assert_equal true, m.repeated_bool[0].value\n      assert_equal 'str', m.repeated_string[0].value\n      assert_equal 'fun', m.repeated_bytes[0].value\n    }\n\n    m = proto_module::Wrapper.new(\n      repeated_double: [Google::Protobuf::DoubleValue.new(value: 2.0)],\n      repeated_float: [Google::Protobuf::FloatValue.new(value: 4.0)],\n      repeated_int32: [Google::Protobuf::Int32Value.new(value: 3)],\n      repeated_int64: [Google::Protobuf::Int64Value.new(value: 4)],\n      repeated_uint32: [Google::Protobuf::UInt32Value.new(value: 5)],\n      repeated_uint64: [Google::Protobuf::UInt64Value.new(value: 6)],\n      repeated_bool: [Google::Protobuf::BoolValue.new(value: true)],\n      repeated_string: [Google::Protobuf::StringValue.new(value: 'str')],\n      repeated_bytes: [Google::Protobuf::BytesValue.new(value: 'fun')],\n    )\n\n    run_asserts.call(m)\n    serialized = proto_module::Wrapper::encode(m)\n    m2 = proto_module::Wrapper::decode(serialized)\n    run_asserts.call(m2)\n\n    # Test the case where we are serializing directly from the parsed form\n    # (before anything lazy is materialized).\n    m3 = proto_module::Wrapper::decode(serialized)\n    serialized2 = proto_module::Wrapper::encode(m3)\n    m4 = proto_module::Wrapper::decode(serialized2)\n    run_asserts.call(m4)\n\n    # Test that the lazy form compares equal to the expanded form.\n    m5 = proto_module::Wrapper::decode(serialized2)\n    assert_equal m5, m\n\n    # Test JSON.\n    serialized_json = proto_module::Wrapper::encode_json(m5)\n    m6 = proto_module::Wrapper::decode_json(serialized_json)\n    run_asserts.call(m6)\n    assert_equal m6, m\n  end\n\n  def test_oneof_wrappers\n    run_test = ->(m) {\n      serialized = proto_module::Wrapper::encode(m)\n      m2 = proto_module::Wrapper::decode(serialized)\n\n      # Encode directly from lazy form.\n      serialized2 = proto_module::Wrapper::encode(m2)\n\n      assert_equal m, m2\n      assert_equal serialized, serialized2\n\n      serialized_json = proto_module::Wrapper::encode_json(m)\n      m3 = proto_module::Wrapper::decode_json(serialized_json)\n      assert_equal m, m3\n    }\n\n    m = proto_module::Wrapper.new()\n\n    run_test.call(m)\n    m.oneof_double_as_value = 2.0\n    run_test.call(m)\n    m.oneof_float_as_value = 4.0\n    run_test.call(m)\n    m.oneof_int32_as_value = 3\n    run_test.call(m)\n    m.oneof_int64_as_value = 5\n    run_test.call(m)\n    m.oneof_uint32_as_value = 6\n    run_test.call(m)\n    m.oneof_uint64_as_value = 7\n    run_test.call(m)\n    m.oneof_string_as_value = 'str'\n    run_test.call(m)\n    m.oneof_bytes_as_value = 'fun'\n    run_test.call(m)\n  end\n\n  def test_top_level_wrappers\n    # We don't expect anyone to do this, but we should also make sure it does\n    # the right thing.\n    run_test = ->(klass, val) {\n      m = klass.new(value: val)\n      serialized = klass::encode(m)\n      m2 = klass::decode(serialized)\n\n      # Encode directly from lazy form.\n      serialized2 = klass::encode(m2)\n\n      assert_equal m, m2\n      assert_equal serialized, serialized2\n\n      serialized_json = klass::encode_json(m)\n\n      # This is nonsensical to do and does not work.  There is no good reason\n      # to parse a wrapper type directly.\n      assert_raise(RuntimeError) { klass::decode_json(serialized_json) }\n    }\n\n    run_test.call(Google::Protobuf::DoubleValue, 2.0)\n    run_test.call(Google::Protobuf::FloatValue, 4.0)\n    run_test.call(Google::Protobuf::Int32Value, 3)\n    run_test.call(Google::Protobuf::Int64Value, 4)\n    run_test.call(Google::Protobuf::UInt32Value, 5)\n    run_test.call(Google::Protobuf::UInt64Value, 6)\n    run_test.call(Google::Protobuf::BoolValue, true)\n    run_test.call(Google::Protobuf::StringValue, 'str')\n    run_test.call(Google::Protobuf::BytesValue, 'fun')\n  end\n\n  def test_wrapper_setters_as_value\n    run_asserts = ->(m) {\n      m.double_as_value = 4.8\n      assert_equal 4.8, m.double_as_value\n      assert_equal Google::Protobuf::DoubleValue.new(value: 4.8), m.double\n      m.float_as_value = 2.4\n      assert_in_delta 2.4, m.float_as_value\n      assert_in_delta Google::Protobuf::FloatValue.new(value: 2.4).value, m.float.value\n      m.int32_as_value = 5\n      assert_equal 5, m.int32_as_value\n      assert_equal Google::Protobuf::Int32Value.new(value: 5), m.int32\n      m.int64_as_value = 15\n      assert_equal 15, m.int64_as_value\n      assert_equal Google::Protobuf::Int64Value.new(value: 15), m.int64\n      m.uint32_as_value = 50\n      assert_equal 50, m.uint32_as_value\n      assert_equal Google::Protobuf::UInt32Value.new(value: 50), m.uint32\n      m.uint64_as_value = 500\n      assert_equal 500, m.uint64_as_value\n      assert_equal Google::Protobuf::UInt64Value.new(value: 500), m.uint64\n      m.bool_as_value = false\n      assert_equal false, m.bool_as_value\n      assert_equal Google::Protobuf::BoolValue.new(value: false), m.bool\n      m.string_as_value = 'xy'\n      assert_equal 'xy', m.string_as_value\n      assert_equal Google::Protobuf::StringValue.new(value: 'xy'), m.string\n      m.bytes_as_value = '123'\n      assert_equal '123', m.bytes_as_value\n      assert_equal Google::Protobuf::BytesValue.new(value: '123'), m.bytes\n\n      m.double_as_value = nil\n      assert_nil m.double\n      assert_nil m.double_as_value\n      m.float_as_value = nil\n      assert_nil m.float\n      assert_nil m.float_as_value\n      m.int32_as_value = nil\n      assert_nil m.int32\n      assert_nil m.int32_as_value\n      m.int64_as_value = nil\n      assert_nil m.int64\n      assert_nil m.int64_as_value\n      m.uint32_as_value = nil\n      assert_nil m.uint32\n      assert_nil m.uint32_as_value\n      m.uint64_as_value = nil\n      assert_nil m.uint64\n      assert_nil m.uint64_as_value\n      m.bool_as_value = nil\n      assert_nil m.bool\n      assert_nil m.bool_as_value\n      m.string_as_value = nil\n      assert_nil m.string\n      assert_nil m.string_as_value\n      m.bytes_as_value = nil\n      assert_nil m.bytes\n      assert_nil m.bytes_as_value\n    }\n\n    m2 = proto_module::Wrapper.new(\n      double: Google::Protobuf::DoubleValue.new(value: 2.0),\n      float: Google::Protobuf::FloatValue.new(value: 4.0),\n      int32: Google::Protobuf::Int32Value.new(value: 3),\n      int64: Google::Protobuf::Int64Value.new(value: 4),\n      uint32: Google::Protobuf::UInt32Value.new(value: 5),\n      uint64: Google::Protobuf::UInt64Value.new(value: 6),\n      bool: Google::Protobuf::BoolValue.new(value: true),\n      string: Google::Protobuf::StringValue.new(value: 'str'),\n      bytes: Google::Protobuf::BytesValue.new(value: 'fun'),\n      real_string: '100'\n    )\n\n    run_asserts.call(m2)\n\n    serialized = proto_module::Wrapper::encode(m2)\n    m3 = proto_module::Wrapper::decode(serialized)\n    run_asserts.call(m3)\n  end\n\n  def test_wrapper_setters\n    run_asserts = ->(m) {\n      m.double = Google::Protobuf::DoubleValue.new(value: 4.8)\n      assert_equal 4.8, m.double_as_value\n      assert_equal Google::Protobuf::DoubleValue.new(value: 4.8), m.double\n      m.float = Google::Protobuf::FloatValue.new(value: 2.4)\n      assert_in_delta 2.4, m.float_as_value\n      assert_in_delta Google::Protobuf::FloatValue.new(value: 2.4).value, m.float.value\n      m.int32 = Google::Protobuf::Int32Value.new(value: 5)\n      assert_equal 5, m.int32_as_value\n      assert_equal Google::Protobuf::Int32Value.new(value: 5), m.int32\n      m.int64 = Google::Protobuf::Int64Value.new(value: 15)\n      assert_equal 15, m.int64_as_value\n      assert_equal Google::Protobuf::Int64Value.new(value: 15), m.int64\n      m.uint32 = Google::Protobuf::UInt32Value.new(value: 50)\n      assert_equal 50, m.uint32_as_value\n      assert_equal Google::Protobuf::UInt32Value.new(value: 50), m.uint32\n      m.uint64 = Google::Protobuf::UInt64Value.new(value: 500)\n      assert_equal 500, m.uint64_as_value\n      assert_equal Google::Protobuf::UInt64Value.new(value: 500), m.uint64\n      m.bool = Google::Protobuf::BoolValue.new(value: false)\n      assert_equal false, m.bool_as_value\n      assert_equal Google::Protobuf::BoolValue.new(value: false), m.bool\n      m.string = Google::Protobuf::StringValue.new(value: 'xy')\n      assert_equal 'xy', m.string_as_value\n      assert_equal Google::Protobuf::StringValue.new(value: 'xy'), m.string\n      m.bytes = Google::Protobuf::BytesValue.new(value: '123')\n      assert_equal '123', m.bytes_as_value\n      assert_equal Google::Protobuf::BytesValue.new(value: '123'), m.bytes\n\n      m.double = nil\n      assert_nil m.double\n      assert_nil m.double_as_value\n      m.float = nil\n      assert_nil m.float\n      assert_nil m.float_as_value\n      m.int32 = nil\n      assert_nil m.int32\n      assert_nil m.int32_as_value\n      m.int64 = nil\n      assert_nil m.int64\n      assert_nil m.int64_as_value\n      m.uint32 = nil\n      assert_nil m.uint32\n      assert_nil m.uint32_as_value\n      m.uint64 = nil\n      assert_nil m.uint64\n      assert_nil m.uint64_as_value\n      m.bool = nil\n      assert_nil m.bool\n      assert_nil m.bool_as_value\n      m.string = nil\n      assert_nil m.string\n      assert_nil m.string_as_value\n      m.bytes = nil\n      assert_nil m.bytes\n      assert_nil m.bytes_as_value\n    }\n\n    m = proto_module::Wrapper.new\n    run_asserts.call(m)\n\n    m2 = proto_module::Wrapper.new(\n      double: Google::Protobuf::DoubleValue.new(value: 2.0),\n      float: Google::Protobuf::FloatValue.new(value: 4.0),\n      int32: Google::Protobuf::Int32Value.new(value: 3),\n      int64: Google::Protobuf::Int64Value.new(value: 4),\n      uint32: Google::Protobuf::UInt32Value.new(value: 5),\n      uint64: Google::Protobuf::UInt64Value.new(value: 6),\n      bool: Google::Protobuf::BoolValue.new(value: true),\n      string: Google::Protobuf::StringValue.new(value: 'str'),\n      bytes: Google::Protobuf::BytesValue.new(value: 'fun'),\n      real_string: '100'\n    )\n\n    run_asserts.call(m2)\n\n    serialized = proto_module::Wrapper::encode(m2)\n    m3 = proto_module::Wrapper::decode(serialized)\n    run_asserts.call(m3)\n  end\n\n  def test_wrappers_only\n    m = proto_module::Wrapper.new(real_string: 'hi', string_in_oneof: 'there')\n\n    assert_raise(NoMethodError) { m.real_string_as_value }\n    assert_raise(NoMethodError) { m.as_value }\n    assert_raise(NoMethodError) { m._as_value }\n    assert_raise(NoMethodError) { m.string_in_oneof_as_value }\n\n    m = proto_module::Wrapper.new\n    m.string_as_value = 'you'\n    assert_equal 'you', m.string.value\n    assert_equal 'you', m.string_as_value\n    assert_raise(NoMethodError) { m.string_ }\n    assert_raise(NoMethodError) { m.string_X }\n    assert_raise(NoMethodError) { m.string_XX }\n    assert_raise(NoMethodError) { m.string_XXX }\n    assert_raise(NoMethodError) { m.string_XXXX }\n    assert_raise(NoMethodError) { m.string_XXXXX }\n    assert_raise(NoMethodError) { m.string_XXXXXX }\n    assert_raise(NoMethodError) { m.string_XXXXXXX }\n    assert_raise(NoMethodError) { m.string_XXXXXXXX }\n    assert_raise(NoMethodError) { m.string_XXXXXXXXX }\n    assert_raise(NoMethodError) { m.string_XXXXXXXXXX }\n  end\n\n  def test_converts_time\n    m = proto_module::TimeMessage.new\n\n    m.timestamp = Google::Protobuf::Timestamp.new(seconds: 5, nanos: 6)\n    assert_kind_of Google::Protobuf::Timestamp, m.timestamp\n    assert_equal 5, m.timestamp.seconds\n    assert_equal 6, m.timestamp.nanos\n\n    m.timestamp = Time.at(9466, 123456.789)\n    assert_equal Google::Protobuf::Timestamp.new(seconds: 9466, nanos: 123456789), m.timestamp\n\n    m = proto_module::TimeMessage.new(timestamp: Time.at(1))\n    assert_equal Google::Protobuf::Timestamp.new(seconds: 1, nanos: 0), m.timestamp\n\n    assert_raise(Google::Protobuf::TypeError) { m.timestamp = 2 }\n    assert_raise(Google::Protobuf::TypeError) { m.timestamp = 2.4 }\n    assert_raise(Google::Protobuf::TypeError) { m.timestamp = '4' }\n    assert_raise(Google::Protobuf::TypeError) { m.timestamp = proto_module::TimeMessage.new }\n\n    def test_time(year, month, day)\n      str = (\"\\\"%04d-%02d-%02dT00:00:00.000+00:00\\\"\" % [year, month, day])\n      t = Google::Protobuf::Timestamp.decode_json(str)\n      time = Time.new(year, month, day, 0, 0, 0, \"+00:00\")\n      assert_equal t.seconds, time.to_i\n    end\n\n    (1970..2010).each do |year|\n      test_time(year, 2, 28)\n      test_time(year, 3, 01)\n    end\n  end\n\n  def test_converts_duration\n    m = proto_module::TimeMessage.new\n\n    m.duration = Google::Protobuf::Duration.new(seconds: 2, nanos: 22)\n    assert_kind_of Google::Protobuf::Duration, m.duration\n    assert_equal 2, m.duration.seconds\n    assert_equal 22, m.duration.nanos\n\n    m.duration = 10.5\n    assert_equal Google::Protobuf::Duration.new(seconds: 10, nanos: 500_000_000), m.duration\n\n    m.duration = 200\n    assert_equal Google::Protobuf::Duration.new(seconds: 200, nanos: 0), m.duration\n\n    m.duration = Rational(3, 2)\n    assert_equal Google::Protobuf::Duration.new(seconds: 1, nanos: 500_000_000), m.duration\n\n    m.duration = BigDecimal(\"5\")\n    assert_equal Google::Protobuf::Duration.new(seconds: 5, nanos: 0), m.duration\n\n    m = proto_module::TimeMessage.new(duration: 1.1)\n    assert_equal Google::Protobuf::Duration.new(seconds: 1, nanos: 100_000_000), m.duration\n\n    m = proto_module::TimeMessage.new(duration: 123.321)\n    assert_equal Google::Protobuf::Duration.new(seconds: 123, nanos: 321_000_000), m.duration\n\n    m = proto_module::TimeMessage.new(duration: -123.321)\n    assert_equal Google::Protobuf::Duration.new(seconds: -123, nanos: -321_000_000), m.duration\n\n    assert_raise(Google::Protobuf::TypeError) { m.duration = '2' }\n    assert_raise(Google::Protobuf::TypeError) { m.duration = proto_module::TimeMessage.new }\n  end\n\n  def test_freeze\n    m = proto_module::TestMessage.new\n    m.optional_int32 = 10\n    m.freeze\n\n    frozen_error = assert_raise(FrozenErrorType) { m.optional_int32 = 20 }\n    assert_match \"can't modify frozen #{proto_module}::TestMessage\", frozen_error.message\n    assert_equal 10, m.optional_int32\n    assert_equal true, m.frozen?\n\n    assert_raise(FrozenErrorType) { m.optional_int64 = 2 }\n    assert_raise(FrozenErrorType) { m.optional_uint32 = 3 }\n    assert_raise(FrozenErrorType) { m.optional_uint64 = 4 }\n    assert_raise(FrozenErrorType) { m.optional_bool = true }\n    assert_raise(FrozenErrorType) { m.optional_float = 6.0 }\n    assert_raise(FrozenErrorType) { m.optional_double = 7.0 }\n    assert_raise(FrozenErrorType) { m.optional_string = '8' }\n    assert_raise(FrozenErrorType) { m.optional_bytes = nil }\n    assert_raise(FrozenErrorType) { m.optional_msg = proto_module::TestMessage2.new }\n    assert_raise(FrozenErrorType) { m.optional_enum = :A }\n    assert_raise(FrozenErrorType) { m.repeated_int32 = 1 }\n    assert_raise(FrozenErrorType) { m.repeated_int64 = 2 }\n    assert_raise(FrozenErrorType) { m.repeated_uint32 = 3 }\n    assert_raise(FrozenErrorType) { m.repeated_uint64 = 4 }\n    assert_raise(FrozenErrorType) { m.repeated_bool = true }\n    assert_raise(FrozenErrorType) { m.repeated_float = 6.0 }\n    assert_raise(FrozenErrorType) { m.repeated_double = 7.0 }\n    assert_raise(FrozenErrorType) { m.repeated_string = '8' }\n    assert_raise(FrozenErrorType) { m.repeated_bytes = nil }\n    assert_raise(FrozenErrorType) { m.repeated_msg = proto_module::TestMessage2.new }\n    assert_raise(FrozenErrorType) { m.repeated_enum = :A }\n  end\n  \n  def test_eq\n    m1 = proto_module::TestMessage.new(:optional_string => 'foo', :repeated_string => ['bar1', 'bar2'])\n    m2 = proto_module::TestMessage.new(:optional_string => 'foo', :repeated_string => ['bar1', 'bar2'])\n\n    h = {}\n    h[m1] = :yes\n\n    assert m1 == m2\n    assert m1.eql?(m2)\n    assert m1.hash == m2.hash\n    assert h[m1] == :yes\n    assert h[m2] == :yes\n\n    m1.optional_int32 = 2\n\n    assert m1 != m2\n    assert !m1.eql?(m2)\n    assert m1.hash != m2.hash\n    assert_nil h[m2]\n  end\n\n  def cruby_or_jruby_9_3_or_higher?\n    # https://github.com/jruby/jruby/issues/6818 was fixed in JRuby 9.3.0.0\n    match = RUBY_PLATFORM == \"java\" &&\n      JRUBY_VERSION.match(/^(\\d+)\\.(\\d+)\\.\\d+\\.\\d+$/)\n    match && (match[1].to_i > 9 || (match[1].to_i == 9 && match[2].to_i >= 3))\n  end\n\n  def test_object_gc\n    m = proto_module::TestMessage.new(optional_msg: proto_module::TestMessage2.new)\n    m.optional_msg\n    # https://github.com/jruby/jruby/issues/6818 was fixed in JRuby 9.3.0.0\n    GC.start(full_mark: true, immediate_sweep: true) if cruby_or_jruby_9_3_or_higher?\n    m.optional_msg.inspect\n  end\n\n  def test_object_gc_freeze\n    m = proto_module::TestMessage.new\n    m.repeated_float.freeze\n    # https://github.com/jruby/jruby/issues/6818 was fixed in JRuby 9.3.0.0\n    GC.start(full_mark: true) if cruby_or_jruby_9_3_or_higher?\n\n    # Make sure we remember that the object is frozen.\n    # The wrapper object contains this information, so we need to ensure that\n    # the previous GC did not collect it.\n    assert m.repeated_float.frozen?\n\n    # https://github.com/jruby/jruby/issues/6818 was fixed in JRuby 9.3.0.0\n    GC.start(full_mark: true, immediate_sweep: true) if cruby_or_jruby_9_3_or_higher?\n    assert m.repeated_float.frozen?\n  end\n\n  def test_optional_fields_respond_to? # regression test for issue 9202\n    msg = proto_module::TestMessage.new\n    assert msg.respond_to? :optional_int32=\n    msg.optional_int32 = 42\n\n    assert msg.respond_to? :optional_int32\n    assert_equal 42, msg.optional_int32\n\n    assert msg.respond_to? :clear_optional_int32\n    msg.clear_optional_int32\n    assert_equal 0, msg.optional_int32\n\n    assert msg.respond_to? :has_optional_int32?\n    assert !msg.has_optional_int32?\n\n    assert !msg.respond_to?( :optional_int32_as_value= )\n    assert_raise NoMethodError do\n      msg.optional_int32_as_value = 42\n    end\n\n    assert !msg.respond_to?( :optional_int32_as_value )\n    assert_raise NoMethodError do\n      msg.optional_int32_as_value\n    end\n\n    assert msg.respond_to? :optional_enum_const\n    assert_equal 0, msg.optional_enum_const\n\n    assert !msg.respond_to?( :foo )\n    assert_raise NoMethodError do\n      msg.foo\n    end\n\n    assert !msg.respond_to?( :foo_const )\n    assert_raise NoMethodError do\n      msg.foo_const\n    end\n\n    assert !msg.respond_to?( :optional_int32_const )\n    assert_raise NoMethodError do\n      msg.optional_int32_const\n    end\n  end\n\n  def test_oneof_fields_respond_to? # regression test for issue 9202\n    msg = proto_module::OneofMessage.new\n\n    # names of the elements of a oneof and the oneof itself are valid actions.\n    assert msg.respond_to? :my_oneof\n    assert_nil msg.my_oneof\n    assert msg.respond_to? :a\n    assert_equal \"\", msg.a\n    assert msg.respond_to? :b\n    assert_equal 0, msg.b\n    assert msg.respond_to? :c\n    assert_nil msg.c\n    assert msg.respond_to? :d\n    assert_equal :Default, msg.d\n\n    # `clear` prefix actions work on elements of a oneof and the oneof itself.\n    assert msg.respond_to? :clear_my_oneof\n    msg.clear_my_oneof\n    # Repeatedly clearing a oneof used to cause a NoMethodError under JRuby\n    msg.clear_my_oneof\n    assert msg.respond_to? :clear_a\n    msg.clear_a\n    assert msg.respond_to? :clear_b\n    msg.clear_b\n    assert msg.respond_to? :clear_c\n    msg.clear_c\n    assert msg.respond_to? :clear_d\n    msg.clear_d\n\n    # `=` suffix actions should work on elements of a oneof but not the oneof itself.\n    assert !msg.respond_to?( :my_oneof= )\n    error = assert_raise RuntimeError do\n      msg.my_oneof = nil\n    end\n    assert_equal \"Oneof accessors are read-only.\", error.message\n    assert msg.respond_to? :a=\n    msg.a = \"foo\"\n    assert msg.respond_to? :b=\n    msg.b = 42\n    assert msg.respond_to? :c=\n    msg.c = proto_module::TestMessage2.new\n    assert msg.respond_to? :d=\n    msg.d = :Default\n\n    # `has_` prefix + \"?\" suffix actions work for oneofs fields.\n    assert msg.respond_to? :has_my_oneof?\n    assert msg.has_my_oneof?\n\n    # `_as_value` suffix actions should only work for wrapped fields.\n    assert !msg.respond_to?( :my_oneof_as_value )\n    assert_raise NoMethodError do\n      msg.my_oneof_as_value\n    end\n    assert !msg.respond_to?( :a_as_value )\n    assert_raise NoMethodError do\n      msg.a_as_value\n    end\n    assert !msg.respond_to?( :b_as_value )\n    assert_raise NoMethodError do\n      msg.b_as_value\n    end\n    assert !msg.respond_to?( :c_as_value )\n    assert_raise NoMethodError do\n      msg.c_as_value\n    end\n    assert !msg.respond_to?( :d_as_value )\n    assert_raise NoMethodError do\n      msg.d_as_value\n    end\n\n    # `_as_value=` suffix actions should only work for wrapped fields.\n    assert !msg.respond_to?( :my_oneof_as_value= )\n    assert_raise NoMethodError do\n      msg.my_oneof_as_value = :boom\n    end\n    assert !msg.respond_to?( :a_as_value= )\n    assert_raise NoMethodError do\n      msg.a_as_value = \"\"\n    end\n    assert !msg.respond_to?( :b_as_value= )\n    assert_raise NoMethodError do\n      msg.b_as_value = 42\n    end\n    assert !msg.respond_to?( :c_as_value= )\n    assert_raise NoMethodError do\n      msg.c_as_value = proto_module::TestMessage2.new\n    end\n    assert !msg.respond_to?( :d_as_value= )\n    assert_raise NoMethodError do\n      msg.d_as_value = :Default\n    end\n\n    # `_const` suffix actions should only work for enum fields.\n    assert !msg.respond_to?( :my_oneof_const )\n    assert_raise NoMethodError do\n      msg.my_oneof_const\n    end\n    assert !msg.respond_to?( :a_const )\n    assert_raise NoMethodError do\n      msg.a_const\n    end\n    assert !msg.respond_to?( :b_const )\n    assert_raise NoMethodError do\n      msg.b_const\n    end\n    assert !msg.respond_to?( :c_const )\n    assert_raise NoMethodError do\n      msg.c_const\n    end\n    assert msg.respond_to? :d_const\n    assert_equal 0, msg.d_const\n  end\n\n  def test_wrapped_fields_respond_to? # regression test for issue 9202\n    msg = proto_module::Wrapper.new\n    assert msg.respond_to?( :double_as_value= )\n    msg.double_as_value = 42\n    assert msg.respond_to?( :double_as_value )\n    assert_equal 42, msg.double_as_value\n    assert_equal Google::Protobuf::DoubleValue.new(value: 42), msg.double\n  end\nend\n", "syntax = \"proto3\";\n\npackage a.b.c;\n\nmessage TestMessage {\n  int32 optional_int32 = 1;\n  int64 optional_int64 = 2;\n  uint32 optional_uint32 = 3;\n  uint64 optional_uint64 = 4;\n  bool optional_bool = 5;\n  double optional_double = 6;\n  float optional_float = 7;\n  string optional_string = 8;\n  bytes optional_bytes = 9;\n  TestEnum optional_enum = 10;\n  TestMessage optional_msg = 11;\n\n  repeated int32 repeated_int32 = 21;\n  repeated int64 repeated_int64 = 22;\n  repeated uint32 repeated_uint32 = 23;\n  repeated uint64 repeated_uint64 = 24;\n  repeated bool repeated_bool = 25;\n  repeated double repeated_double = 26;\n  repeated float repeated_float = 27;\n  repeated string repeated_string = 28;\n  repeated bytes repeated_bytes = 29;\n  repeated TestEnum repeated_enum = 30;\n  repeated TestMessage repeated_msg = 31;\n\n  oneof my_oneof {\n    int32 oneof_int32 = 41;\n    int64 oneof_int64 = 42;\n    uint32 oneof_uint32 = 43;\n    uint64 oneof_uint64 = 44;\n    bool oneof_bool = 45;\n    double oneof_double = 46;\n    float oneof_float = 47;\n    string oneof_string = 48;\n    bytes oneof_bytes = 49;\n    TestEnum oneof_enum = 50;\n    TestMessage oneof_msg = 51;\n  }\n\n  map<int32, string> map_int32_string = 61;\n  map<int64, string> map_int64_string = 62;\n  map<uint32, string> map_uint32_string = 63;\n  map<uint64, string> map_uint64_string = 64;\n  map<bool, string> map_bool_string = 65;\n  map<string, string> map_string_string = 66;\n  map<string, TestMessage> map_string_msg = 67;\n  map<string, TestEnum> map_string_enum = 68;\n  map<string, int32> map_string_int32 = 69;\n  map<string, bool> map_string_bool = 70;\n\n  message NestedMessage {\n    int32 foo = 1;\n  }\n\n  NestedMessage nested_message = 80;\n\n  // Reserved for non-existing field test.\n  // int32 non_exist = 89;\n}\n\nenum TestEnum {\n  Default = 0;\n  A = 1;\n  B = 2;\n  C = 3;\n}\n\nmessage testLowercaseNested {\n  message lowercase{}\n}\n\n\nmessage TestUnknown {\n  TestUnknown optional_unknown = 11;\n  repeated TestUnknown repeated_unknown = 31;\n  oneof my_oneof {\n    TestUnknown oneof_unknown = 51;\n  }\n  map<string, TestUnknown> map_unknown = 67;\n  int32 unknown_field = 89;\n}\n\nmessage TestJsonName {\n  int32 value = 1 [json_name = \"CustomJsonName\"];\n}\n", "syntax = \"proto2\";\n\npackage a.b.proto2;\n\nmessage TestMessage {\n  optional int32 optional_int32 = 1;\n  optional int64 optional_int64 = 2;\n  optional uint32 optional_uint32 = 3;\n  optional uint64 optional_uint64 = 4;\n  optional bool optional_bool = 5;\n  optional double optional_double = 6;\n  optional float optional_float = 7;\n  optional string optional_string = 8;\n  optional bytes optional_bytes = 9;\n  optional TestEnum optional_enum = 10;\n  optional TestMessage optional_msg = 11;\n\n  repeated int32 repeated_int32 = 21;\n  repeated int64 repeated_int64 = 22;\n  repeated uint32 repeated_uint32 = 23;\n  repeated uint64 repeated_uint64 = 24;\n  repeated bool repeated_bool = 25;\n  repeated double repeated_double = 26;\n  repeated float repeated_float = 27;\n  repeated string repeated_string = 28;\n  repeated bytes repeated_bytes = 29;\n  repeated TestEnum repeated_enum = 30;\n  repeated TestMessage repeated_msg = 31;\n\n  required int32 required_int32 = 41;\n  required int64 required_int64 = 42;\n  required uint32 required_uint32 = 43;\n  required uint64 required_uint64 = 44;\n  required bool required_bool = 45;\n  required double required_double = 46;\n  required float required_float = 47;\n  required string required_string = 48;\n  required bytes required_bytes = 49;\n  required TestEnum required_enum = 50;\n  required TestMessage required_msg = 51;\n\n  oneof my_oneof {\n    int32 oneof_int32 = 61;\n    int64 oneof_int64 = 62;\n    uint32 oneof_uint32 = 63;\n    uint64 oneof_uint64 = 64;\n    bool oneof_bool = 65;\n    double oneof_double = 66;\n    float oneof_float = 67;\n    string oneof_string = 68;\n    bytes oneof_bytes = 69;\n    TestEnum oneof_enum = 70;\n    TestMessage oneof_msg = 71;\n  }\n\n  message NestedMessage {\n    optional int32 foo = 1;\n  }\n\n  optional NestedMessage nested_message = 80;\n\n  // Reserved for non-existing field test.\n  // int32 non_exist = 89;\n}\n\nenum TestEnum {\n  Default = 0;\n  A = 1;\n  B = 2;\n  C = 3;\n}\n\nmessage TestUnknown {\n  optional TestUnknown optional_unknown = 11;\n  repeated TestUnknown repeated_unknown = 31;\n  oneof my_oneof {\n    TestUnknown oneof_unknown = 51;\n  }\n  optional int32 unknown_field = 89;\n}\n", "#!/usr/bin/ruby\n\nrequire 'google/protobuf'\nrequire 'test/unit'\n\nclass RepeatedFieldTest < Test::Unit::TestCase\n\n  def test_acts_like_enumerator\n    m = TestMessage.new\n    (Enumerable.instance_methods - TestMessage.new.repeated_string.methods).each do |method_name|\n      assert m.repeated_string.respond_to?(method_name) == true, \"does not respond to #{method_name}\"\n    end\n  end\n\n  def test_acts_like_an_array\n    m = TestMessage.new\n    arr_methods = ([].methods - TestMessage.new.repeated_string.methods)\n    # jRuby additions to the Array class that we can ignore\n    arr_methods -= [ :indices, :iter_for_each, :iter_for_each_index,\n      :iter_for_each_with_index, :dimensions, :copy_data, :copy_data_simple,\n      :nitems, :iter_for_reverse_each, :indexes, :append, :prepend]\n    arr_methods -= [:union, :difference, :filter!]\n    arr_methods -= [:intersection, :deconstruct] # ruby 2.7 methods we can ignore\n    arr_methods -= [:intersect?] # ruby 3.1 methods we can ignore\n    arr_methods.each do |method_name|\n      assert m.repeated_string.respond_to?(method_name) == true, \"does not respond to #{method_name}\"\n    end\n  end\n\n  def test_first\n    m = TestMessage.new\n    repeated_field_names(TestMessage).each do |field_name|\n      assert_nil m.send(field_name).first\n      assert_equal [], m.send(field_name).first(0)\n      assert_equal [], m.send(field_name).first(1)\n    end\n\n    fill_test_msg(m)\n    assert_equal( -10, m.repeated_int32.first )\n    assert_equal( -1_000_000, m.repeated_int64.first )\n    assert_equal 10, m.repeated_uint32.first\n    assert_equal 1_000_000, m.repeated_uint64.first\n    assert_equal true, m.repeated_bool.first\n    assert_equal( -1.01,  m.repeated_float.first.round(2) )\n    assert_equal( -1.0000000000001, m.repeated_double.first )\n    assert_equal 'foo', m.repeated_string.first\n    assert_equal \"bar\".encode!('ASCII-8BIT'), m.repeated_bytes.first\n    assert_equal TestMessage2.new(:foo => 1), m.repeated_msg.first\n    assert_equal :A, m.repeated_enum.first\n\n    err = assert_raises(ArgumentError) do\n      m.repeated_int32.first(-1)\n    end\n    assert_equal \"negative array size\", err.message\n    assert_equal [], m.repeated_int32.first(0)\n    assert_equal [-10], m.repeated_int32.first(1)\n    assert_equal [-10, -11], m.repeated_int32.first(2)\n    assert_equal [-10, -11], m.repeated_int32.first(3)\n  end\n\n\n  def test_last\n    m = TestMessage.new\n    repeated_field_names(TestMessage).each do |field_name|\n      assert_nil m.send(field_name).first\n    end\n    fill_test_msg(m)\n    assert_equal( -11, m.repeated_int32.last )\n    assert_equal( -1_000_001, m.repeated_int64.last )\n    assert_equal 11, m.repeated_uint32.last\n    assert_equal 1_000_001, m.repeated_uint64.last\n    assert_equal false, m.repeated_bool.last\n    assert_equal( -1.02, m.repeated_float.last.round(2) )\n    assert_equal( -1.0000000000002, m.repeated_double.last )\n    assert_equal 'bar', m.repeated_string.last\n    assert_equal \"foo\".encode!('ASCII-8BIT'), m.repeated_bytes.last\n    assert_equal TestMessage2.new(:foo => 2), m.repeated_msg.last\n    assert_equal :B, m.repeated_enum.last\n\n    err = assert_raises(ArgumentError) do\n      m.repeated_int32.last(-1)\n    end\n    assert_equal \"negative array size\", err.message\n    assert_equal [], m.repeated_int32.last(0)\n    assert_equal [-11], m.repeated_int32.last(1)\n    assert_equal [-10, -11], m.repeated_int32.last(2)\n    assert_equal [-10, -11], m.repeated_int32.last(3)\n  end\n\n\n  def test_pop\n    m = TestMessage.new\n    repeated_field_names(TestMessage).each do |field_name|\n      assert_nil m.send(field_name).pop\n    end\n    fill_test_msg(m)\n\n    assert_equal( -11, m.repeated_int32.pop )\n    assert_equal( -10, m.repeated_int32.pop )\n    assert_equal( -1_000_001, m.repeated_int64.pop )\n    assert_equal( -1_000_000, m.repeated_int64.pop )\n    assert_equal 11, m.repeated_uint32.pop\n    assert_equal 10, m.repeated_uint32.pop\n    assert_equal 1_000_001, m.repeated_uint64.pop\n    assert_equal 1_000_000, m.repeated_uint64.pop\n    assert_equal false, m.repeated_bool.pop\n    assert_equal true, m.repeated_bool.pop\n    assert_equal( -1.02,  m.repeated_float.pop.round(2) )\n    assert_equal( -1.01,  m.repeated_float.pop.round(2) )\n    assert_equal( -1.0000000000002, m.repeated_double.pop )\n    assert_equal( -1.0000000000001, m.repeated_double.pop )\n    assert_equal 'bar', m.repeated_string.pop\n    assert_equal 'foo', m.repeated_string.pop\n    assert_equal \"foo\".encode!('ASCII-8BIT'), m.repeated_bytes.pop\n    assert_equal \"bar\".encode!('ASCII-8BIT'), m.repeated_bytes.pop\n    assert_equal TestMessage2.new(:foo => 2), m.repeated_msg.pop\n    assert_equal TestMessage2.new(:foo => 1), m.repeated_msg.pop\n    assert_equal :B, m.repeated_enum.pop\n    assert_equal :A, m.repeated_enum.pop\n    repeated_field_names(TestMessage).each do |field_name|\n      assert_nil m.send(field_name).pop\n    end\n\n    fill_test_msg(m)\n    assert_equal ['bar', 'foo'], m.repeated_string.pop(2)\n    assert_nil m.repeated_string.pop\n  end\n\n\n  def test_each\n    m = TestMessage.new\n    5.times{|i| m.repeated_string << 'string' }\n    count = 0\n    m.repeated_string.each do |val|\n      assert_equal 'string', val\n      count += 1\n    end\n    assert_equal 5, count\n    result = m.repeated_string.each{|val| val + '_junk'}\n    assert_equal ['string'] * 5, result\n  end\n\n\n  def test_empty?\n    m = TestMessage.new\n    assert_equal true, m.repeated_string.empty?\n    m.repeated_string << 'foo'\n    assert_equal false, m.repeated_string.empty?\n    m.repeated_string << 'bar'\n    assert_equal false, m.repeated_string.empty?\n  end\n\n  def test_reassign\n    m = TestMessage.new\n    m.repeated_msg = Google::Protobuf::RepeatedField.new(:message, TestMessage2, [TestMessage2.new(:foo => 1)])\n    assert_equal m.repeated_msg.first, TestMessage2.new(:foo => 1)\n  end\n\n  def test_array_accessor\n    m = TestMessage.new\n    reference_arr = %w(foo bar baz)\n    m.repeated_string += reference_arr.clone\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n      arr[1]\n    end\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n      arr[-2]\n    end\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n      arr[20]\n    end\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n      arr[1, 2]\n    end\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n      arr[0..2]\n    end\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n      arr[0..5]\n    end\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n      arr[0..-1]\n    end\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n      arr[0..-3]\n    end\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n      arr[0...-1] # Exclusive range\n    end\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n      arr[0...-3] # Exclusive range\n    end\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n      arr[-2..-1]\n    end\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n      arr[-5..-1]\n    end\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n      # Infinite range; introduce in Ruby 2.7.\n      if Gem::Version.new(RUBY_VERSION) >= Gem::Version.new('2.7')\n        eval \"arr[0..]\"\n      end\n    end\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n      # Beginless range; introduced in Ruby 2.7.\n      if Gem::Version.new(RUBY_VERSION) >= Gem::Version.new('2.7')\n        eval \"arr[..-1]\"\n      end\n    end\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n      # Infinite range; introduce in Ruby 2.7.\n      if Gem::Version.new(RUBY_VERSION) >= Gem::Version.new('2.7')\n        eval \"arr[0...]\" # Exclusive range\n      end\n    end\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n      # Beginless range; introduced in Ruby 2.7.\n      if Gem::Version.new(RUBY_VERSION) >= Gem::Version.new('2.7')\n        eval \"arr[...-1]\" # Exclusive range\n      end\n    end\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n      arr[-1, 1]\n    end\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n      arr[10, 12]\n    end\n  end\n\n  def test_array_settor\n    m = TestMessage.new\n    reference_arr = %w(foo bar baz)\n    m.repeated_string += reference_arr.clone\n\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n      arr[1] = 'junk'\n    end\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n      arr[-2] = 'snappy'\n    end\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n      arr[3] = ''\n    end\n    # slight deviation; we are strongly typed, and nil is not allowed\n    # for string types;\n    m.repeated_string[5] = 'spacious'\n    assert_equal [\"foo\", \"snappy\", \"baz\", \"\", \"\", \"spacious\"], m.repeated_string\n\n    #make sure it sests the default types for other fields besides strings\n    %w(repeated_int32 repeated_int64 repeated_uint32 repeated_uint64).each do |field_name|\n      m.send(field_name)[3] = 10\n      assert_equal [0,0,0,10], m.send(field_name)\n    end\n    m.repeated_float[3] = 10.1\n    #wonky mri float handling\n    assert_equal [0,0,0], m.repeated_float.to_a[0..2]\n    assert_equal 10.1, m.repeated_float[3].round(1)\n    m.repeated_double[3] = 10.1\n    assert_equal [0,0,0,10.1], m.repeated_double\n    m.repeated_bool[3] = true\n    assert_equal [false, false, false, true], m.repeated_bool\n    m.repeated_bytes[3] = \"bar\".encode!('ASCII-8BIT')\n    assert_equal ['', '', '', \"bar\".encode!('ASCII-8BIT')], m.repeated_bytes\n    m.repeated_msg[3] = TestMessage2.new(:foo => 1)\n    assert_equal [nil, nil, nil, TestMessage2.new(:foo => 1)], m.repeated_msg\n    m.repeated_enum[3] = :A\n    assert_equal [:Default, :Default, :Default, :A], m.repeated_enum\n\n    # check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n    #   arr[20] = 'spacious'\n    # end\n    # TODO: accessor doesn't allow other ruby-like methods\n    # check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n    #   arr[1, 2] = 'fizz'\n    # end\n    # check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n    #   arr[0..2] = 'buzz'\n    # end\n  end\n\n  def test_push\n    m = TestMessage.new\n    reference_arr = %w[foo bar baz]\n    m.repeated_string += reference_arr.clone\n\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n      arr.push('fizz')\n    end\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n      arr << 'fizz'\n    end\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n      arr.push('fizz', 'buzz')\n    end\n  end\n\n  def test_clear\n    m = TestMessage.new\n    reference_arr = %w(foo bar baz)\n    m.repeated_string += reference_arr.clone\n\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n      arr.clear\n    end\n  end\n\n  def test_concat\n    m = TestMessage.new\n    reference_arr = %w(foo bar baz)\n    m.repeated_string += reference_arr.clone\n    m.repeated_string.concat(['fizz', 'buzz'])\n    assert_equal %w(foo bar baz fizz buzz), m.repeated_string\n    #TODO: concat should return the orig array\n    # check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n    #   arr.concat(['fizz', 'buzz'])\n    # end\n  end\n\n  def test_equal\n    m = TestMessage.new\n    reference_arr = %w(foo bar baz)\n    m.repeated_string += reference_arr.clone\n    assert_equal reference_arr, m.repeated_string\n    reference_arr << 'fizz'\n    assert_not_equal reference_arr, m.repeated_string\n    m.repeated_string << 'fizz'\n    assert_equal reference_arr, m.repeated_string\n  end\n\n  def test_hash\n    # just a sanity check\n    m = TestMessage.new\n    reference_arr = %w(foo bar baz)\n    m.repeated_string += reference_arr.clone\n    assert m.repeated_string.hash.is_a?(Integer)\n    hash = m.repeated_string.hash\n    assert_equal hash, m.repeated_string.hash\n    m.repeated_string << 'j'\n    assert_not_equal hash, m.repeated_string.hash\n  end\n\n  def test_plus\n    m = TestMessage.new\n    reference_arr = %w(foo bar baz)\n    m.repeated_string += reference_arr.clone\n\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n      arr + ['fizz', 'buzz']\n    end\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n      arr += ['fizz', 'buzz']\n    end\n  end\n\n  def test_replace\n    m = TestMessage.new\n    reference_arr = %w(foo bar baz)\n    m.repeated_string += reference_arr.clone\n\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n      arr.replace(['fizz', 'buzz'])\n    end\n  end\n\n  def test_to_a\n    m = TestMessage.new\n    reference_arr = %w(foo bar baz)\n    m.repeated_string += reference_arr.clone\n\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n      arr.to_a\n    end\n  end\n\n  def test_to_ary\n    m = TestMessage.new\n    reference_arr = %w(foo bar baz)\n    m.repeated_string += reference_arr.clone\n\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n      arr.to_ary\n    end\n  end\n\n  # emulate Array behavior\n  ##########################\n\n  def test_collect!\n    m = TestMessage.new\n    reference_arr = %w(foo bar baz)\n    m.repeated_string += reference_arr.clone\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n      arr.collect!{|x| x + \"!\" }\n    end\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n      arr.collect!.with_index{|x, i| x[0...i] }\n    end\n  end\n\n  def test_delete\n    m = TestMessage.new\n    reference_arr = %w(foo bar baz)\n    m.repeated_string += reference_arr.clone\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n      arr.delete('bar')\n    end\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n      arr.delete('nope')\n    end\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n      arr.delete('nope'){'within'}\n    end\n  end\n\n  def test_delete_at\n    m = TestMessage.new\n    reference_arr = %w(foo bar baz)\n    m.repeated_string += reference_arr.clone\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n      arr.delete_at(2)\n    end\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n      arr.delete_at(10)\n    end\n  end\n\n  def test_delete_if\n    m = TestMessage.new\n    reference_arr = %w(foo bar baz)\n    m.repeated_string += reference_arr.clone\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n      arr.delete_if { |v| v == \"bar\" }\n    end\n  end\n\n  def test_fill\n    m = TestMessage.new\n    reference_arr = %w(foo bar baz)\n    m.repeated_string += reference_arr.clone\n\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n      arr.fill(\"x\")\n    end\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n      arr.fill(\"z\", 2, 2)\n    end\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n      arr.fill(\"y\", 0..1)\n    end\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n      arr.fill { |i| (i*i).to_s }\n    end\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n      arr.fill(-2) { |i| (i*i*i).to_s }\n    end\n  end\n\n  def test_flatten!\n    m = TestMessage.new\n    reference_arr = %w(foo bar baz)\n    m.repeated_string += reference_arr.clone\n\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n      arr.flatten!\n    end\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n      arr.flatten!(1)\n    end\n  end\n\n  def test_insert\n    m = TestMessage.new\n    reference_arr = %w(foo bar baz)\n    m.repeated_string += reference_arr.clone\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n      arr.insert(2, 'fizz')\n    end\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n      arr.insert(3, 'fizz', 'buzz', 'bazz')\n    end\n  end\n\n  def test_inspect\n    m = TestMessage.new\n    assert_equal '[]', m.repeated_string.inspect\n    m.repeated_string << 'foo'\n    assert_equal m.repeated_string.to_a.inspect, m.repeated_string.inspect\n    m.repeated_string << 'bar'\n    assert_equal m.repeated_string.to_a.inspect, m.repeated_string.inspect\n  end\n\n  def test_reverse!\n    m = TestMessage.new\n    reference_arr = %w(foo bar baz)\n    m.repeated_string += reference_arr.clone\n\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n      arr.reverse!\n    end\n  end\n\n  def test_rotate!\n    m = TestMessage.new\n    reference_arr = %w(foo bar baz)\n    m.repeated_string += reference_arr.clone\n\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n      arr.rotate!\n    end\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n      arr.rotate!(2)\n    end\n  end\n\n  def test_select!\n    m = TestMessage.new\n    reference_arr = %w(foo bar baz)\n    m.repeated_string += reference_arr.clone\n\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n      arr.select! { |v| v =~ /[aeiou]/ }\n    end\n  end\n\n  def test_shift\n    m = TestMessage.new\n    reference_arr = %w(foo bar baz)\n    m.repeated_string += reference_arr.clone\n\n    # should return an element\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n      arr.shift\n    end\n    # should return an array\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n      arr.shift(2)\n    end\n    # should return nil\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n      arr.shift\n    end\n  end\n\n  def test_shuffle!\n    m = TestMessage.new\n    m.repeated_string += %w(foo bar baz)\n    result = m.repeated_string.shuffle!\n    assert_equal m.repeated_string, result\n  end\n\n  def test_slice!\n    m = TestMessage.new\n    reference_arr = %w(foo bar baz bar fizz buzz)\n    m.repeated_string += reference_arr.clone\n\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n      arr.slice!(2)\n    end\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n      arr.slice!(1,2)\n    end\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n      arr.slice!(0..1)\n    end\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n      arr.slice!(10)\n    end\n  end\n\n  def test_sort!\n    m = TestMessage.new\n    reference_arr = %w(foo bar baz)\n    m.repeated_string += reference_arr.clone\n\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n      arr.sort!\n    end\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n      arr.sort! { |x,y| y <=> x }\n    end\n  end\n\n  def test_sort_by!\n    m = TestMessage.new\n    reference_arr = %w(foo bar baz)\n    m.repeated_string += reference_arr.clone\n\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n      arr.sort_by!\n    end\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n      arr.sort_by!(&:hash)\n    end\n  end\n\n  def test_uniq!\n    m = TestMessage.new\n    reference_arr = %w(foo bar baz)\n    m.repeated_string += reference_arr.clone\n\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n      arr.uniq!\n    end\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n      arr.uniq!{|s| s[0] }\n    end\n  end\n\n  def test_unshift\n    m = TestMessage.new\n    reference_arr = %w(foo bar baz)\n    m.repeated_string += reference_arr.clone\n\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n      arr.unshift('1')\n    end\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n      arr.unshift('a', 'b')\n    end\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n      arr.unshift('')\n    end\n  end\n\n\n  ##### HELPER METHODS\n\n  def check_self_modifying_method(repeated_field, ref_array)\n    expected_result = yield(ref_array)\n    actual_result = yield(repeated_field)\n    if expected_result.is_a?(Enumerator)\n      assert_equal expected_result.to_a, actual_result.to_a\n    else\n      assert_equal expected_result, actual_result\n    end\n    assert_equal ref_array, repeated_field\n  end\n\n\n  def repeated_field_names(klass)\n    klass.descriptor.find_all{|f| f.label == :repeated}.map(&:name)\n  end\n\n\n  def fill_test_msg(test_msg)\n    test_msg.repeated_int32  += [-10, -11]\n    test_msg.repeated_int64  += [-1_000_000, -1_000_001]\n    test_msg.repeated_uint32 += [10, 11]\n    test_msg.repeated_uint64 += [1_000_000, 1_000_001]\n    test_msg.repeated_bool   += [true, false]\n    test_msg.repeated_float  += [-1.01, -1.02]\n    test_msg.repeated_double += [-1.0000000000001, -1.0000000000002]\n    test_msg.repeated_string += %w(foo bar)\n    test_msg.repeated_bytes  += [\"bar\".encode!('ASCII-8BIT'), \"foo\".encode!('ASCII-8BIT')]\n    test_msg.repeated_msg    << TestMessage2.new(:foo => 1)\n    test_msg.repeated_msg    << TestMessage2.new(:foo => 2)\n    test_msg.repeated_enum   << :A\n    test_msg.repeated_enum   << :B\n  end\n\n\n  pool = Google::Protobuf::DescriptorPool.new\n  pool.build do\n\n    add_message \"TestMessage\" do\n      optional :optional_int32,  :int32,        1\n      optional :optional_int64,  :int64,        2\n      optional :optional_uint32, :uint32,       3\n      optional :optional_uint64, :uint64,       4\n      optional :optional_bool,   :bool,         5\n      optional :optional_float,  :float,        6\n      optional :optional_double, :double,       7\n      optional :optional_string, :string,       8\n      optional :optional_bytes,  :bytes,        9\n      optional :optional_msg,    :message,      10, \"TestMessage2\"\n      optional :optional_enum,   :enum,         11, \"TestEnum\"\n\n      repeated :repeated_int32,  :int32,        12\n      repeated :repeated_int64,  :int64,        13\n      repeated :repeated_uint32, :uint32,       14\n      repeated :repeated_uint64, :uint64,       15\n      repeated :repeated_bool,   :bool,         16\n      repeated :repeated_float,  :float,        17\n      repeated :repeated_double, :double,       18\n      repeated :repeated_string, :string,       19\n      repeated :repeated_bytes,  :bytes,        20\n      repeated :repeated_msg,    :message,      21, \"TestMessage2\"\n      repeated :repeated_enum,   :enum,         22, \"TestEnum\"\n    end\n    add_message \"TestMessage2\" do\n      optional :foo, :int32, 1\n    end\n\n    add_enum \"TestEnum\" do\n      value :Default, 0\n      value :A, 1\n      value :B, 2\n      value :C, 3\n    end\n  end\n\n  TestMessage = pool.lookup(\"TestMessage\").msgclass\n  TestMessage2 = pool.lookup(\"TestMessage2\").msgclass\n  TestEnum = pool.lookup(\"TestEnum\").enummodule\n\n\nend\n"], "fixing_code": ["2022-07-01 Unreleased version\n  C++\n  * cpp_generated_lib_linked support is removed in protoc\n  * Reduced .pb.o object file size slightly by explicitly instantiating\n    InternalMetadata templates in the runtime.\n  * Add C++20 keywords guarded by PROTOBUF_FUTURE_CPP20_KEYWORDS\n  * Fixed crash in ThreadLocalStorage for pre-C++17 compilers on 32-bit ARM.\n  * Clarified that JSON API non-OK statuses are not a stable API.\n  * Added a default implementation of MessageDifferencer::Reporter methods.\n  * proto2::MapPair is now an alias to std::pair.\n  * Hide C++ RepeatedField::UnsafeArenaSwap\n  * Use table-driven parser for reflection based objects.\n  * Update Map's InternalSwap() to take a pointer to the other Map.\n  * Add ARM-optimized Varint decoding functions.\n  * Minor optimization for parsing groups\n  * Declare ReflectiveProtoHook class\n  * Reduce size of VarintParse code in protocol buffers, by calling the shared\n    routine after handling just one-byte varint encoding inline, rather than\n    handling one-byte and two-byte varints inline.\n  * Avoid inlining some large heavily duplicated routines in repeated_ptr_field.h\n  * Add ReflectiveProtoHook to Reflection.\n  * Turns on table-driven parser for reflection based objects.\n  * Save code space by avoiding inlining of large-in-aggregate code-space MessageLite::~MessageLite destructor.\n  * Undefine the macro `linux` when compiling protobuf\n  * Reduce memory consumption of MessageSet parsing.\n  * Save code space by avoiding inlining of large-in-aggregate code-space MessageLite::~MessageLite destructor.\n  * Breaking change: delete Arena::Init\n  * Make a PROTOBUF_POISON/UNPOISON to reduce noise in the source\n\n\n  Kotlin\n  * Suppress deprecation warnings in Kotlin generated code.\n  * Kotlin generated code comments now use kdoc format instead of javadoc.\n  * Escape keywords in package names in proto generated code\n  * Add Kotlin enum int value getters and setters\n\n  Java\n  * Performance improvement for repeated use of FieldMaskUtil#merge by caching\n    constructed FieldMaskTrees.\n  * Optimized Java proto serialization gencode for protos having many extension ranges with few fields in between.\n  * More thoroughly annotate public generated code in Java lite protocol buffers.\n  * Fixed Bug in proto3 java lite repeated enum fields. Failed to call copyOnWrite before modifying previously built message. Causes modification to already \"built\" messages that should be immutable.\n  * Fix Java reflection serialization of empty packed fields.\n  * Refactoring java full runtime to reuse sub-message builders and prepare to\n    migrate parsing logic from parse constructor to builder.\n  * Move proto wireformat parsing functionality from the private \"parsing\n    constructor\" to the Builder class.\n  * Change the Lite runtime to prefer merging from the wireformat into mutable\n    messages rather than building up a new immutable object before merging. This\n    way results in fewer allocations and copy operations.\n  * Make message-type extensions merge from wire-format instead of building up instances and merging afterwards. This has much better performance.\n\n  Python\n  * Changes ordering of printed fields in .pyi files from lexicographic to the same ordering found in the proto descriptor.\n  * Adds GeneratedCodeInfo annotations to python proto .pyi outputs as a base64 encoded docstring in the last line of the .pyi file for code analysis tools.\n  * Fix message factory's behavior in python cpp extension to return same message classes for same descriptor, even if the factories are different.\n\n  Compiler\n  * Print full path name of source .proto file on error\n\n2022-09-13 version 21.6 (C++/Java/Python/PHP/Objective-C/C#/Ruby)\n\nC++\n* Reduce memory consumption of MessageSet parsing\n\n2022-08-09 version 21.5 (C++/Java/Python/PHP/Objective-C/C#/Ruby)\n\n  PHP\n  * Added getContainingOneof and getRealContainingOneof to descriptor.\n  * fix PHP readonly legacy files for nested messages\n\n  Python\n  * Fixed comparison of maps in Python.\n\n2022-07-25 version 21.4 (C++/Java/Python/PHP/Objective-C/C#/Ruby)\n\n  C++\n  * Reduce the required alignment of ArenaString from 8 to 4 (#10298)\n\n\n2022-07-19 version 21.3 (C++/Java/Python/PHP/Objective-C/C#/Ruby)\n  C++\n  * Add header search paths to Protobuf-C++.podspec (#10024)\n  * Fixed Visual Studio constinit errors (#10232)\n  * Fix #9947: make the ABI compatible between debug and non-debug builds (#10271)\n\n  UPB\n  * Allow empty package names (fixes behavior regression in 4.21.0)\n  * Fix a SEGV bug when comparing a non-materialized sub-message (#10208)\n  * Fix several bugs in descriptor mapping containers (eg. descriptor.services_by_name)\n    * for x in mapping now yields keys rather than values, to match Python conventions and the behavior of the old library.\n    * Lookup operations now correctly reject unhashable types as map keys.\n    * We implement repr() to use the same format as dict.\n  * Fix maps to use the ScalarMapContainer class when appropriate\n  * Fix bug when parsing an unknown value in a proto2 enum extension (protocolbuffers/upb#717)\n\n  PHP\n  * Add \"readonly\" as a keyword for PHP and add previous classnames to descriptor pool (#10041)\n\n  Python\n  * Make //:protobuf_python and //:well_known_types_py_pb2 public (#10118)\n\n  Bazel\n  * Add back a filegroup for :well_known_protos (#10061)\n\n2022-06-27 version 21.2 (C++/Java/Python/PHP/Objective-C/C#/Ruby)\n  C++\n  * ArenaString improvements (fix alignment issue)\n\n  PHP\n  * API changes for OneOf  (#10102)\n\n\n2022-05-27 version 21.1 (C++/Java/Python/PHP/Objective-C/C#/Ruby)\n\n  C++\n  * cmake: Revert \"Fix cmake install targets (#9822)\" (#10060)\n  * Remove Abseil dependency from CMake build (#10056)\n\n  Python\n  * Update python wheel metadata with more information incl. required python version (#10058)\n  * Fix segmentation fault when instantiating field via repeated field assignment (#10066)\n\n2022-05-25 version 21.0 (C++/Java/Python/PHP/Objective-C/C#/Ruby)\n\n  C++\n  * cmake: Call get_filename_component() with DIRECTORY mode instead of PATH mode (#9614)\n  * Escape GetObject macro inside protoc-generated code (#9739)\n  * Update CMake configuration to add a dependency on Abseil (#9793)\n  * Fix cmake install targets (#9822)\n  * Use __constinit only in GCC 12.2 and up (#9936)\n\n  Java\n  * Update protobuf_version.bzl to separate protoc and per-language java \u2026 (#9900)\n\n  Python\n  * Increment python major version to 4 in version.json for python upb (#9926)\n  * The C extension module for Python has been rewritten to use the upb library.\n    This is expected to deliver significant performance benefits, especially when\n    parsing large payloads.  There are some minor breaking changes, but these\n    should not impact most users.  For more information see:\n    https://developers.google.com/protocol-buffers/docs/news/2022-05-06#python-updates\n  * Fixed win32 build and fixed str(message) on all Windows platforms. (#9976)\n  * The binary wheel for macOS now supports Apple silicon.\n\n  PHP\n  * [PHP] fix PHP build system (#9571)\n  * Fix building packaged PHP extension (#9727)\n  * fix: reserve \"ReadOnly\" keyword for PHP 8.1 and add compatibility (#9633)\n  * fix: phpdoc syntax for repeatedfield parameters (#9784)\n  * fix: phpdoc for repeatedfield (#9783)\n  * Change enum string name for reserved words (#9780)\n  * chore: [PHP] fix phpdoc for MapField keys (#9536)\n  * Fixed PHP SEGV by not writing to shared memory for zend_class_entry. (#9996)\n\n  Ruby\n  * Allow pre-compiled binaries for ruby 3.1.0 (#9566)\n  * Implement `respond_to?` in RubyMessage (#9677)\n  * [Ruby] Fix RepeatedField#last, #first inconsistencies (#9722)\n  * Do not use range based UTF-8 validation in truffleruby (#9769)\n  * Improve range handling logic of `RepeatedField` (#9799)\n  * Support x64-mingw-ucrt platform\n\n  Other\n  * [Kotlin] remove redundant public modifiers for compiled code (#9642)\n  * [C#] Update GetExtension to support getting typed value (#9655)\n  * Fix invalid dependency manifest when using `descriptor_set_out` (#9647)\n  * Fix C# generator handling of a field named \"none\" in a oneof (#9636)\n  * Add initial version.json file for 21-dev (#9840)\n  * Remove duplicate java generated code (#9909)\n  * Cherry-pick PR #9981 into 21.x branch (#10000)\n\n\n2022-05-19 version 21.0-rc2(C++/Java/Python/PHP/Objective-C/C#/Ruby)\n\n  Python\n  * Fix windows builds\n  * Throw more helpful error if generated code is out of date\n  * Fixed two reference leaks\n\n  Ruby\n  * Support x64-mingw-ucrt platform\n\n  PHP\n  * Fix SEGV by not writing to shared memory for zend_class_entry\n\n  C#\n  * Suppress warning CS8981\n\n  Other\n  * Fix Maven release to release actual osx_aarch64 binary\n  * Fix protoc zips to have the proto files for well known types\n\n2022-05-10 version 21.0-rc1 (C++/Java/Python/PHP/Objective-C/C#/Ruby)\n\n  C++\n  * Rename main cmake/CMakeLists.txt to CMakeLists.txt (#9603)\n  * avoid allocating memory if all extension are cleared (#9345)\n  * cmake: Call get_filename_component() with DIRECTORY mode instead of PATH mode (#9614)\n  * Escape GetObject macro inside protoc-generated code (#9739)\n  * Update CMake configuration to add a dependency on Abseil (#9793)\n  * Use __constinit only in GCC 12.2 and up (#9936)\n  * Refactor generated message class layout\n  * Optimize tokenizer ParseInteger by removing division\n  * Reserve exactly the right amount of capacity in ExtensionSet::MergeFrom\n  * Parse FLT_MAX correctly when represented in JSON\n\n  Java\n  * Update protobuf_version.bzl to separate protoc and per-language java \u2026 (#9900)\n  * 6x speedup in ArrayEncoder.writeUInt32NotTag\n  * Java generated code is no longer compatible with runtimes 2.6.1 and earlier\n\n  Python\n  * Increment python major version to 4 in version.json for python upb (#9926)\n  * The C extension module for Python has been rewritten to use the upb library.\n    This is expected to deliver significant performance benefits, especially when\n    parsing large payloads.  There are some minor breaking changes, but these\n    should not impact most users.  For more information see:\n    https://developers.google.com/protocol-buffers/docs/news/2022-05-06#python-updates\n  * Due to the breaking changes for Python, the major version number for Python\n    has been incremented.\n  * The binary wheel for macOS now supports Apple silicon.\n  * In TextFormat, transform UnicodeDecodeError into ParseError.\n\n\n  PHP\n  * chore: [PHP] fix phpdoc for MapField keys (#9536)\n  * [PHP] Remove unnecessary zval initialization (#9600)\n  * [PHP] fix PHP build system (#9571)\n  * Fix building packaged PHP extension (#9727)\n  * fix: reserve \"ReadOnly\" keyword for PHP 8.1 and add compatibility (#9633)\n  * fix: phpdoc syntax for repeatedfield parameters (#9784)\n  * fix: phpdoc for repeatedfield (#9783)\n  * Change enum string name for reserved words (#9780)\n  * Fixed composer.json to only advertise compatibility with PHP 7.0+.  (#9819)\n\n  Ruby\n  * Allow pre-compiled binaries for ruby 3.1.0 (#9566)\n  * Implement `respond_to?` in RubyMessage (#9677)\n  * [Ruby] Fix RepeatedField#last, #first inconsistencies (#9722)\n  * Do not use range based UTF-8 validation in truffleruby (#9769)\n  * Improve range handling logic of `RepeatedField` (#9799)\n  * Disable the aarch64 build on macOS until it can be fixed. (#9816)\n\n  Other\n  * [Kotlin] remove redundant public modifiers for compiled code (#9642)\n  * [C#] Update GetExtension to support getting typed value (#9655)\n  * Fix invalid dependency manifest when using `descriptor_set_out` (#9647)\n  * Fix C# generator handling of a field named \"none\" in a oneof (#9636)\n  * Add initial version.json file for 21-dev (#9840)\n  * Remove duplicate java generated code (#9909)\n  * Fix versioning issues in 3.20.0\n\n  Compiler\n  * Protoc outputs the list of suggested field numbers when invalid field\n    numbers are specified in the .proto file.\n  * Require package names to be less than 512 bytes in length\n\n2022-04-21 version 3.20.1 (C++/Java/Python/PHP/Objective-C/C#/Ruby/JavaScript)\n\n  PHP\n  * Fix building packaged PHP extension (#9727)\n\n  Other\n  * Fix versioning issues in 3.20.0\n\n2022-03-04 version 3.20.0 (C++/Java/Python/PHP/Objective-C/C#/Ruby/JavaScript)\n\n  Ruby\n  * Dropped Ruby 2.3 and 2.4 support for CI and releases. (#9311)\n  * Added Ruby 3.1 support for CI and releases (#9566).\n  * Message.decode/encode: Add recursion_limit option (#9218/#9486)\n  * Allocate with xrealloc()/xfree() so message allocation is visible to the\n    Ruby GC.  In certain tests this leads to much lower memory usage due to more\n    frequent GC runs (#9586).\n  * Fix conversion of singleton classes in Ruby (#9342)\n  * Suppress warning for intentional circular require (#9556)\n  * JSON will now output shorter strings for double and float fields when possible\n    without losing precision.\n  * Encoding and decoding of binary format will now work properly on big-endian\n    systems.\n  * UTF-8 verification was fixed to properly reject surrogate code points.\n  * Unknown enums for proto2 protos now properly implement proto2's behavior of\n    putting such values in unknown fields.\n\n  Java\n  * Revert \"Standardize on Array copyOf\" (#9400)\n  * Resolve more java field accessor name conflicts (#8198)\n  * Don't support map fields in DynamicMessage.Builder.{getFieldBuilder,getRepeatedFieldBuilder}\n  * Fix parseFrom to only throw InvalidProtocolBufferException\n  * InvalidProtocolBufferException now allows arbitrary wrapped Exception types.\n  * Fix bug in `FieldSet.Builder.mergeFrom`\n  * Flush CodedOutputStream also flushes underlying OutputStream\n  * When oneof case is the same and the field type is Message, merge the\n    subfield. (previously it was replaced.)\u2019\n  * Add @CheckReturnValue to some protobuf types\n  * Report original exceptions when parsing JSON\n  * Add more info to @deprecated javadoc for set/get/has methods\n  * Fix initialization bug in doc comment line numbers\n  * Fix comments for message set wire format.\n\n  Kotlin\n  * Add test scope to kotlin-test for protobuf-kotlin-lite (#9518)\n  * Add orNull extensions for optional message fields.\n  * Add orNull extensions to all proto3 message fields.\n\n  Python\n  * Dropped support for Python < 3.7 (#9480)\n  * Protoc is now able to generate python stubs (.pyi) with --pyi_out\n  * Pin multibuild scripts to get manylinux1 wheels back (#9216)\n  * Fix type annotations of some Duration and Timestamp methods.\n  * Repeated field containers are now generic in field types and could be used\n    in type annotations.\n  * Protobuf python generated codes are simplified. Descriptors and message\n    classes' definitions are now dynamic created in internal/builder.py.\n    Insertion Points for messages classes are discarded.\n  * has_presence is added for FieldDescriptor in python\n  * Loosen indexing type requirements to allow valid __index__() implementations\n    rather than only PyLongObjects.\n  * Fix the deepcopy bug caused by not copying message_listener.\n  * Added python JSON parse recursion limit (default 100)\n  * Path info is added for python JSON parse errors\n  * Pure python repeated scalar fields will not able to pickle. Convert to list\n    first.\n  * Timestamp.ToDatetime() now accepts an optional tzinfo parameter. If\n    specified, the function returns a timezone-aware datetime in the given time\n    zone. If omitted or None, the function returns a timezone-naive UTC datetime\n    (as previously).\n  * Adds client_streaming and server_streaming fields to MethodDescriptor.\n  * Add \"ensure_ascii\" parameter to json_format.MessageToJson. This allows smaller\n    JSON serializations with UTF-8 or other non-ASCII encodings.\n  * Added experimental support for directly assigning numpy scalars and array.\n  * Improve the calculation of public_dependencies in DescriptorPool.\n  * [Breaking Change] Disallow setting fields to numpy singleton arrays or repeated fields to numpy\n    multi-dimensional arrays. Numpy arrays should be indexed or flattened explicitly before assignment.\n\n  Compiler\n  * Migrate IsDefault(const std::string*) and UnsafeSetDefault(const std::string*)\n  * Implement strong qualified tags for TaggedPtr\n  * Rework allocations to power-of-two byte sizes.\n  * Migrate IsDefault(const std::string*) and UnsafeSetDefault(const std::string*)\n  * Implement strong qualified tags for TaggedPtr\n  * Make TaggedPtr Set...() calls explicitly spell out the content type.\n  * Check for parsing error before verifying UTF8.\n  * Enforce a maximum message nesting limit of 32 in the descriptor builder to\n    guard against stack overflows\n  * Fixed bugs in operators for RepeatedPtrIterator\n  * Assert a maximum map alignment for allocated values\n  * Fix proto1 group extension protodb parsing error\n  * Do not log/report the same descriptor symbol multiple times if it contains\n    more than one invalid character.\n  * Add UnknownFieldSet::SerializeToString and SerializeToCodedStream.\n  * Remove explicit default pointers and deprecated API from protocol compiler\n\n  Arenas\n  * Change Repeated*Field to reuse memory when using arenas.\n  * Implements pbarenaz for profiling proto arenas\n  * Introduce CreateString() and CreateArenaString() for cleaner semantics\n  * Fix unreferenced parameter for MSVC builds\n  * Add UnsafeSetAllocated to be used for one-of string fields.\n  * Make Arena::AllocateAligned() a public function.\n  * Determine if ArenaDtor related code generation is necessary in one place.\n  * Implement on demand register ArenaDtor for InlinedStringField\n\n  C++\n  * Enable testing via CTest (#8737)\n  * Add option to use external GTest in CMake (#8736)\n  * CMake: Set correct sonames for libprotobuf-lite.so and libprotoc.so (#8635) (#9529)\n  * Add cmake option `protobuf_INSTALL` to not install files (#7123)\n  * CMake: Allow custom plugin options e.g. to generate mocks (#9105)\n  * CMake: Use linker version scripts (#9545)\n  * Manually *struct Cord fields to work better with arenas.\n  * Manually destruct map fields.\n  * Generate narrower code\n  * Fix https://github.com/protocolbuffers/protobuf/issues/9378 by removing\n    shadowed _cached_size_ field\n  * Remove GetPointer() and explicit nullptr defaults.\n  * Add proto_h flag for speeding up large builds\n  * Add missing overload for reference wrapped fields.\n  * Add MergedDescriptorDatabase::FindAllFileNames()\n  * RepeatedField now defines an iterator type instead of using a pointer.\n  * Remove obsolete macros GOOGLE_PROTOBUF_HAS_ONEOF and GOOGLE_PROTOBUF_HAS_ARENAS.\n\n  PHP\n  * Fix: add missing reserved classnames (#9458)\n  * PHP 8.1 compatibility (#9370)\n\n  C#\n  * Fix trim warnings (#9182)\n  * Fixes NullReferenceException when accessing FieldDescriptor.IsPacked (#9430)\n  * Add ToProto() method to all descriptor classes (#9426)\n  * Add an option to preserve proto names in JsonFormatter (#6307)\n\n  Objective-C\n  * Add prefix_to_proto_package_mappings_path option. (#9498)\n  * Rename `proto_package_to_prefix_mappings_path` to `package_to_prefix_mappings_path`. (#9552)\n  * Add a generation option to control use of forward declarations in headers. (#9568)\n\n2022-01-28 version 3.19.4 (C++/Java/Python/PHP/Objective-C/C#/Ruby/JavaScript)\n\n  Python\n  * Make libprotobuf symbols local on OSX to fix issue #9395 (#9435)\n\n  Ruby\n  * Fixed a data loss bug that could occur when the number of `optional`\n    fields in a message is an exact multiple of 32. (#9440).\n\n  PHP\n  * Fixed a data loss bug that could occur when the number of `optional`\n    fields in a message is an exact multiple of 32. (#9440).\n\n2022-01-10 version 3.19.3 (C++/Java/Python/PHP/Objective-C/C#/Ruby/JavaScript)\n\n  Python\n  * Fix missing Windows wheel for Python 3.10 on PyPI\n\n2022-01-05 version 3.19.2 (C++/Java/Python/PHP/Objective-C/C#/Ruby/JavaScript)\n\n  Java\n  * Improve performance characteristics of UnknownFieldSet parsing (#9371)\n  * This release addresses a Security Advisory for Java users\n   (https://github.com/protocolbuffers/protobuf/security/advisories/GHSA-wrvw-hg22-4m67)\n\n2022-01-05 version 3.18.2 (C++/Java/Python/PHP/Objective-C/C#/Ruby/JavaScript)\n\n  Java\n  * Improve performance characteristics of UnknownFieldSet parsing (#9371)\n  * This release addresses a Security Advisory for Java users\n   (https://github.com/protocolbuffers/protobuf/security/advisories/GHSA-wrvw-hg22-4m67)\n\n2022-01-05 version 3.16.1 (Java)\n\n  Java\n  * Improve performance characteristics of UnknownFieldSet parsing (#9371)\n  * This release addresses a Security Advisory for Java users\n   (https://github.com/protocolbuffers/protobuf/security/advisories/GHSA-wrvw-hg22-4m67)\n\n2021-10-28 version 3.19.1 (C++/Java/Python/PHP/Objective-C/C#/Ruby/JavaScript)\n\n  Bazel\n  * Ensure that release archives contain everything needed for Bazel (#9131)\n  * Align dependency handling with Bazel best practices (#9165)\n\n  JavaScript\n  * Fix `ReferenceError: window is not defined` when getting the global object (#9156)\n\n  Ruby\n  * Fix memory leak in MessageClass.encode (#9150)\n\n2021-10-15 version 3.19.0 (C++/Java/Python/PHP/Objective-C/C#/Ruby/JavaScript)\n\n  C++\n  * Make proto2::Message::DiscardUnknownFields() non-virtual\n  * Separate RepeatedPtrField into its own header file\n  * For default floating point values of 0, consider all bits significant\n  * cmake: support `MSVC_RUNTIME_LIBRARY` property (#8851)\n  * Fix shadowing warnings (#8926)\n  * Fix for issue #8484, constant initialization doesn't compile in msvc clang-cl environment (#8993)\n  * Fix build on AIX and SunOS (#8373) (#9065)\n  * Add Android stlport and default toolchains to BUILD. (#8290)\n\n  Java\n  * For default floating point values of 0, consider all bits significant\n  * Annotate `//java/com/google/protobuf/util/...` with nullness annotations\n  * Use ArrayList copy constructor (#7853)\n\n  Kotlin\n  * Switch Kotlin proto DSLs to be implemented with inline value classes\n  * Fix inlining and deprecation for repeated string fields in kotlin (#9120)\n\n  Python\n  * Proto2 DecodeError now includes message name in error message\n  * Make MessageToDict convert map keys to strings (#8122)\n  * Add python-requires in setup.py (#8989)\n  * Add python 3.10 (#9034)\n\n  JavaScript\n  * Skip exports if not available by CommonJS (#8856)\n  * JS: Comply with CSP no-unsafe-eval. (#8864)\n\n  PHP\n  * Added \"object\" as a reserved name for PHP (#8962)\n\n  Ruby\n  * Override Map.clone to use Map's dup method (#7938)\n  * Ruby: build extensions for arm64-darwin (#8232)\n  * Add class method Timestamp.from_time to ruby well known types (#8562)\n  * Adopt pure ruby DSL implementation for JRuby (#9047)\n  * Add size to Map class (#8068)\n  * Fix for descriptor_pb.rb: google/protobuf should be required first (#9121)\n\n  C#\n  * Correctly set ExtensionRegistry when parsing with MessageParser, but using an already existing CodedInputStream (#7246)\n  * [C#] Make FieldDescriptor propertyName public (#7642)\n\n2021-10-04 version 3.18.1 (C++/Java/Python/PHP/Objective-C/C#/Ruby/JavaScript)\n\n  Python\n  * Update setup.py to reflect that we now require at least Python 3.5 (#8989)\n  * Performance fix for DynamicMessage: force GetRaw() to be inlined (#9023)\n\n  Ruby\n  * Update ruby_generator.cc to allow proto2 imports in proto3 (#9003)\n\n2021-09-13 version 3.18.0 (C++/Java/Python/PHP/Objective-C/C#/Ruby/JavaScript)\n\n  Python\n  * Removed Python 2.x support.\n  * Pure python descriptor_pool.AddSerializedFile() will always build the\n    file and return FileDescriptor which is same with python c++ extension\n  * type errors thrown by MergeFrom now report fully qualified class names\n  * Protobuf python generated code are simplified. Some platforms that uses\n    \"is\"(\"is not\") to compare the enum or descriptor's label/type may fail,\n    should use \"==\"(\"!=\") instead.\n\n  C++\n  * Generated code now uses the c++11 standard integer types int{32,64}_t and\n    uint{32,64}_t\n  * Reduce memory usage of the DescriptorPool type.\n  * Moved the zero-argument New() method on messages to the base class (internal\n    optimization).\n  * Unused return values marked with `PROTOBUF_MUST_USE_RESULT` are now\n    correctly attributed.\n  * Demotes PrintPath log for maps in MessageDifferencer down from WARNING to\n    INFO.\n  * Make sure FullMessageName() is always private.\n  * Fix race condition in EnumDescriptor.\n  * Remove MessageLite::GetMaybeArenaPointer.\n\n  Java\n  * Add @deprecated javadoc for set/get/has methods\n  * correctly decode \\? escape sequence in text protos\n  * Avoid depending on Objects.requireNonNull() until we can verify that no\n    users are depending on older Android versions.\n  * disallow null string map values in put and putAll\n  * Add `@CheckReturnValue` to `ByteString` API.\n  * Make the `hasPresence` method public in `FieldDescriptor`.\n  * Report more detailed messages in Duration and Timestamp proto parsing\n    errors.\n  * New Timestamps.fromDate utility method that converts a java.util.Date to a\n    Timestamp proto object.\n\n  Kotlin\n  * Generated Kotlin code is Explicit API mode compatible\n\n2021-09-13 version 3.18.0 (C++/Java/Python/PHP/Objective-C/C#/Ruby/JavaScript)\n  C++\n  * Fix warnings raised by clang 11 (#8664)\n  * Make StringPiece constructible from std::string_view (#8707)\n  * Add missing capability attributes for LLVM 12 (#8714)\n  * Stop using std::iterator (deprecated in C++17). (#8741)\n  * Move field_access_listener from libprotobuf-lite to libprotobuf (#8775)\n  * Fix #7047 Safely handle setlocale (#8735)\n  * Remove deprecated version of SetTotalBytesLimit() (#8794)\n  * Support arena allocation of google::protobuf::AnyMetadata (#8758)\n  * Fix undefined symbol error around SharedCtor() (#8827)\n  * Fix default value of enum(int) in json_util with proto2 (#8835)\n  * Better Smaller ByteSizeLong\n  * Introduce event filters for inject_field_listener_events\n  * Reduce memory usage of DescriptorPool\n  * For lazy fields copy serialized form when allowed.\n  * Re-introduce the InlinedStringField class\n  * v2 access listener\n  * Reduce padding in the proto's ExtensionRegistry map.\n  * GetExtension performance optimizations\n  * Make tracker a static variable rather than call static functions\n  * Support extensions in field access listener\n  * Annotate MergeFrom for field access listener\n  * Fix incomplete types for field access listener\n  * Add map_entry/new_map_entry to SpecificField in MessageDifferencer. They\n    record the map items which are different in MessageDifferencer's reporter.\n  * Reduce binary size due to fieldless proto messages\n  * TextFormat: ParseInfoTree supports getting field end location in addition to\n    start.\n  * Fix repeated enum extension size in field listener\n  * Enable Any Text Expansion for Descriptors::DebugString()\n  * Switch from int{8,16,32,64} to int{8,16,32,64}_t\n  * Reduce memory usage of the DescriptorPool type.\n\n  Java\n  * Fix errorprone conflict (#8723)\n  * Removing deprecated TimeUtil class. (#8749)\n  * Optimized FieldDescriptor.valueOf() to avoid array copying.\n  * Removing deprecated TimeUtil class.\n  * Add Durations.parseUnchecked(String) and Timestamps.parseUnchecked(String)\n  * FieldMaskUtil: Add convenience method to mask the fields out of a given proto.\n\n  JavaScript\n  * Optimize binary parsing of repeated float64\n  * Fix for optimization when reading doubles from binary wire format\n  * Replace toArray implementation with toJSON.\n\n  Python\n  * Drops support for 2.7 and 3.5.\n\n  PHP\n  * Migrate PHP & Ruby to ABSL wyhash (#8854)\n  * Added support for PHP 8.1 (currently in RC1) to the C extension (#8964)\n  * Fixed PHP SEGV when constructing messages from a destructor. (#8969)\n\n  Ruby\n  * Move DSL implementation from C to pure Ruby (#8850)\n  * Fixed a memory bug with RepeatedField#+. (#8970)\n\n  Other\n  * [csharp] ByteString.CreateCodedInput should use ArraySegment offset and count (#8740)\n  * [ObjC] Add support for using the proto package to prefix symbols. (#8760)\n  * field_presence.md: fix Go example (#8788)\n\n\n  Kotlin\n  * Suppress NOTHING_TO_INLINE in Kotlin generated inline functions.\n\n2021-06-04 version 3.17.3 (C++/Java/Python/PHP/Objective-C/C#/Ruby/JavaScript)\n  Python\n  * Note: This is the last release to support Python 2.7. Future releases will\n    require Python >= 3.5.\n\n  C++\n  * Introduce FieldAccessListener.\n  * Stop emitting boilerplate {Copy/Merge}From in each ProtoBuf class\n  * Fixed some uninitialized variable warnings in generated_message_reflection.cc.\n\n  Kotlin\n  * Fix duplicate proto files error (#8699)\n\n  Java\n  * Fixed parser to check that we are at a proper limit when a sub-message has\n    finished parsing.\n\n2021-05-25 version 3.17.2 (C++/Java/Python/PHP/Objective-C/C#/Ruby/JavaScript)\n  Kotlin\n  * Fix duplicate class error (#8653)\n\n  PHP\n  * Fixed SEGV in sub-message getters for well-known types when message is unset\n    (#8670)\n\n2021-05-07 version 3.17.1 (C++/Java/Python/PHP/Objective-C/C#/Ruby/JavaScript)\n  PHP\n  * Fixed PHP memory leaks and arginfo errors. (#8614)\n  * Fixed JSON parser to allow multiple values from the same oneof as long as\n    all but one are null.\n\n  Ruby\n  * Fixed memory bug: properly root repeated/map field when assigning. (#8639)\n  * Fixed JSON parser to allow multiple values from the same oneof as long as\n    all but one are null.\n\n\n2021-05-07 version 3.17.0 (C++/Java/Python/PHP/Objective-C/C#/Ruby/JavaScript)\n\n  Protocol Compiler\n  * Fix the generated source information for reserved values in Enums.\n\n  C++\n  * Fix -Wunused-parameter in map<string, int> fields (fixes #8494) (#8500)\n  * Use byteswap.h when building against musl libc (#8503)\n  * Fix -Wundefined-inline error when using SharedCtor() or SharedDtor() (#8532)\n  * Fix bug where `Descriptor::DebugString()` printed proto3 synthetic oneofs.\n  * Provide stable versions of `SortAndUnique()`.\n  * Make sure to cache proto3 optional message fields when they are cleared.\n  * Expose UnsafeArena methods to Reflection.\n  * Use std::string::empty() rather than std::string::size() > 0.\n\n  Kotlin\n  * Restrict extension setter and getter operators to non-nullable T.\n\n  Java\n  * updating GSON and Guava to more recent versions (#8524)\n  * Reduce the time spent evaluating isExtensionNumber by storing the extension\n    ranges in a TreeMap for faster queries. This is particularly relevant for\n    protos which define a large number of extension ranges, for example when\n    each tag is defined as an extension.\n  * Fix java bytecode estimation logic for optional fields.\n  * Optimize Descriptor.isExtensionNumber.\n\n  Python\n  * Add MethodDescriptor.CopyToProto() (#8327)\n  * Remove unused python_protobuf.{cc,h} (#8513)\n  * Start publishing python aarch64 manylinux wheels normally (#8530)\n  * Fix constness issue detected by MSVC standard conforming mode (#8568)\n  * Make JSON parsing match C++ and Java when multiple fields from the same\n    oneof are present and all but one is null.\n\n  Ruby\n  * Add support for proto3 json_name in compiler and field definitions (#8356)\n  * Fixed memory leak of Ruby arena objects. (#8461)\n  * Fix source gem compilation (#8471)\n  * Fix various exceptions in Ruby on 64-bit Windows (#8563)\n  * Fix crash when calculating Message hash values on 64-bit Windows (#8565)\n\n  Conformance Tests\n  * Added a conformance test for the case of multiple fields from the same\n    oneof.\n\n2021-04-06 version 3.16.0 (C++/Java/Python/PHP/Objective-C/C#/Ruby/JavaScript)\n  Other\n  * Opensourcing kotlin protos (#8272)\n  * Use a newer version of rules_proto, with the new rule `proto_descriptor_set` (#8469)\n\n  C++\n  * Fix compiler warnings issue found in conformance_test_runner #8189 (#8190)\n  * Fix MinGW-w64 build issues. (#8286)\n  * [Protoc] C++ Resolved an issue where NO_DESTROY and CONSTINIT are in incorrect order (#8296)\n  * Fix PROTOBUF_CONSTINIT macro redefinition (#8323)\n  * Delete StringPiecePod (#8353)\n  * Fix gcc error: comparison of unsigned expression in '>= 0' is always \u2026 (#8309)\n  * Fix cmake install on iOS (#8301)\n  * Create a CMake option to control whether or not RTTI is enabled (#8347)\n  * Fix endian.h location on FreeBSD (#8351)\n  * Refactor util::Status (#8354)\n  * Make util::Status more similar to absl::Status (#8405)\n  * Fix -Wsuggest-destructor-override for generated C++ proto classes. (#8408)\n  * Refactor StatusOr and StringPiece (#8406)\n  * Refactor uint128 (#8416)\n  * The ::pb namespace is no longer exposed due to conflicts.\n  * Allow MessageDifferencer::TreatAsSet() (and friends) to override previous\n    calls instead of crashing.\n  * Reduce the size of generated proto headers for protos with `string` or\n    `bytes` fields.\n  * Move arena() operation on uncommon path to out-of-line routine\n  * For iterator-pair function parameter types, take both iterators by value.\n  * Code-space savings and perhaps some modest performance improvements in\n    RepeatedPtrField.\n  * Eliminate nullptr check from every tag parse.\n  * Remove unused _$name$_cached_byte_size_ fields.\n  * Serialize extension ranges together when not broken by a proto field in the\n    middle.\n  * Do out-of-line allocation and deallocation of string object in ArenaString.\n  * Streamline ParseContext::ParseMessage<T> to avoid code bloat and improve\n    performance.\n  * New member functions RepeatedField::Assign, RepeatedPtrField::{Add, Assign}.\n  * Fix undefined behavior warning due to innocuous uninitialization of value\n    on an error path.\n  * Avoid expensive inlined code space for encoding message length for messages\n    >= 128 bytes and instead do a procedure call to a shared out-of-line routine.\n  * util::DefaultFieldComparator will be final in a future version of protobuf.\n    Subclasses should inherit from SimpleFieldComparator instead.\n\n  C#\n  * Add .NET 5 target and improve WriteString performance with SIMD (#8147)\n\n  Java\n  * deps: update JUnit and Truth (#8319)\n  * Detect invalid overflow of byteLimit and return InvalidProtocolBufferException as documented.\n  * Exceptions thrown while reading from an InputStream in parseFrom are now\n    included as causes.\n  * Support potentially more efficient proto parsing from RopeByteStrings.\n  * Clarify runtime of ByteString.Output.toStringBuffer().\n  * Added UnsafeByteOperations to protobuf-lite (#8426)\n\n  JavaScript\n  * Make Any.pack() chainable.\n\n  Python\n  * Fix some constness / char literal issues being found by MSVC standard conforming mode (#8344)\n  * Switch on \"new\" buffer API (#8339)\n  * Enable crosscompiling aarch64 python wheels under dockcross manylinux docker image (#8280)\n  * Fixed a bug in text format where a trailing colon was printed for repeated field.\n  * When TextFormat encounters a duplicate message map key, replace the current\n    one instead of merging.\n\n  Objective-C\n  * Move the class map to a CFDictionary. (#8328)\n\n  PHP\n  * read_property() handler is not supposed to return NULL (#8362)\n  * Changed parameter type from long to integer (#7613)\n  * fix: README supported PHP version for C extension (#8236)\n\n  Ruby\n  * Fixed quadratic memory usage when appending to arrays. (#8364)\n  * Fixed memory leak of Ruby arena objects. (#8461)\n  * Add support for proto3 json_name in compiler and field definitions. (#8356)\n\n  Other\n  * Some doc on AOT compilation and protobuf (#8294)\n  * [CMake] Ability to pass options to protoc executable from cmake (#8374)\n  * Add --fatal_warnings flag to treat warnings as errors (#8131)\n  * [bazel] Remove deprecated way to depend on googletest (#8396)\n  * add error returns missing from protoc to prevent it from exiting with\u2026 (#8409)\n\n\n2021-04-07 version 3.15.8 (C++/Java/Python/PHP/Objective-C/C#/Ruby/JavaScript)\n\n  Ruby\n  * Fixed memory leak of Ruby arena objects (#8461)\n\n2021-04-02 version 3.15.7 (C++/Java/Python/PHP/Objective-C/C#/Ruby/JavaScript)\n\n  C++\n  * Remove the ::pb namespace (alias) (#8423)\n\n  Ruby\n  * Fix unbounded memory growth for Ruby <2.7 (#8429)\n  * Fixed message equality in cases where the message type is different (#8434)\n\n2021-03-10 version 3.15.6 (C++/Java/Python/PHP/Objective-C/C#/Ruby/JavaScript)\n\n  Ruby\n  * Fixed bug in string comparison logic (#8386)\n\n2021-03-04 version 3.15.5 (C++/Java/Python/PHP/Objective-C/C#/Ruby/JavaScript)\n\n  Ruby\n  * Fixed quadratic memory use in array append (#8379)\n\n  PHP\n  * Fixed quadratic memory use in array append (#8379)\n\n  C++\n  * Do not disable RTTI by default in the CMake build (#8377)\n\n2021-03-02 version 3.15.4 (C++/Java/Python/PHP/Objective-C/C#/Ruby/JavaScript)\n\n  Ruby\n  * Fixed SEGV when users pass nil messages (#8363)\n  * Fixed quadratic memory usage when appending to arrays (#8364)\n\n  C++\n  * Create a CMake option to control whether or not RTTI is enabled (#8361)\n\n  PHP\n  * read_property() handler is not supposed to return NULL (#8362)\n\n2021-02-25 version 3.15.3 (C++/Java/Python/PHP/Objective-C/C#/Ruby/JavaScript)\n\n  Ruby\n  * Ruby <2.7 now uses WeakMap too, which prevents memory leaks. (#8341)\n\n2021-02-23 version 3.15.2 (C++/Java/Python/PHP/Objective-C/C#/Ruby/JavaScript)\n\n  Ruby\n  * Fix for FieldDescriptor.get(msg) (#8330)\n\n  C++\n  * Fix PROTOBUF_CONSTINIT macro redefinition (#8323)\n\n2021-02-05 version 3.15.1 (C++/Java/Python/PHP/Objective-C/C#/Ruby/JavaScript)\n\n  Ruby\n  * Bugfix for Message.[] for repeated or map fields (#8313)\n\n2021-02-05 version 3.15.0 (C++/Java/Python/PHP/Objective-C/C#/Ruby/JavaScript)\n\n  Protocol Compiler\n  * Optional fields for proto3 are enabled by default, and no longer require\n    the --experimental_allow_proto3_optional flag.\n\n  C++\n  * MessageDifferencer: fixed bug when using custom ignore with multiple\n    unknown fields\n  * Use init_seg in MSVC to push initialization to an earlier phase.\n  * Runtime no longer triggers -Wsign-compare warnings.\n  * Fixed -Wtautological-constant-out-of-range-compare warning.\n  * DynamicCastToGenerated works for nullptr input for even if RTTI is disabled\n  * Arena is refactored and optimized.\n  * Clarified/specified that the exact value of Arena::SpaceAllocated() is an\n    implementation detail users must not rely on. It should not be used in\n    unit tests.\n  * Change the signature of Any::PackFrom() to return false on error.\n  * Add fast reflection getter API for strings.\n  * Constant initialize the global message instances\n  * Avoid potential for missed wakeup in UnknownFieldSet\n  * Now Proto3 Oneof fields have \"has\" methods for checking their presence in\n    C++.\n  * Bugfix for NVCC\n  * Return early in _InternalSerialize for empty maps.\n  * Adding functionality for outputting map key values in proto path logging\n    output (does not affect comparison logic) and stop printing 'value' in the\n    path. The modified print functionality is in the\n    MessageDifferencer::StreamReporter.\n  * Fixed https://github.com/protocolbuffers/protobuf/issues/8129\n  * Ensure that null char symbol, package and file names do not result in a\n    crash.\n  * Constant initialize the global message instances\n  * Pretty print 'max' instead of numeric values in reserved ranges.\n  * Removed remaining instances of std::is_pod, which is deprecated in C++20.\n  * Changes to reduce code size for unknown field handling by making uncommon\n    cases out of line.\n  * Fix std::is_pod deprecated in C++20 (#7180)\n  * Fix some -Wunused-parameter warnings (#8053)\n  * Fix detecting file as directory on zOS issue #8051 (#8052)\n  * Don't include sys/param.h for _BYTE_ORDER (#8106)\n  * remove CMAKE_THREAD_LIBS_INIT from pkgconfig CFLAGS (#8154)\n  * Fix TextFormatMapTest.DynamicMessage issue#5136 (#8159)\n  * Fix for compiler warning issue#8145 (#8160)\n  * fix: support deprecated enums for GCC < 6 (#8164)\n  * Fix some warning when compiling with Visual Studio 2019 on x64 target (#8125)\n\n  Python\n  * Provided an override for the reverse() method that will reverse the internal\n    collection directly instead of using the other methods of the BaseContainer.\n  * MessageFactory.CreateProtoype can be overridden to customize class creation.\n  * Fix PyUnknownFields memory leak (#7928)\n  * Add macOS Big Sur compatibility (#8126)\n\n  JavaScript\n  * Generate `getDescriptor` methods with `*` as their `this` type.\n  * Enforce `let/const` for generated messages.\n  * js/binary/utils.js: Fix jspb.utils.joinUnsignedDecimalString to work with negative bitsLow and low but non-zero bitsHigh parameter. (#8170)\n\n  PHP\n  * Added support for PHP 8. (#8105)\n  * unregister INI entries and fix invalid read on shutdown (#8042)\n  * Fix PhpDoc comments for message accessors to include \"|null\". (#8136)\n  * fix: convert native PHP floats to single precision (#8187)\n  * Fixed PHP to support field numbers >=2**28. (#8235)\n  * feat: add support for deprecated fields to PHP compiler (#8223)\n  * Protect against stack overflow if the user derives from Message. (#8248)\n  * Fixed clone for Message, RepeatedField, and MapField. (#8245)\n  * Updated upb to allow nonzero offset minutes in JSON timestamps. (#8258)\n\n  Ruby\n  * Added support for Ruby 3. (#8184)\n  * Rewrote the data storage layer to be based on upb_msg objects from the\n    upb library. This should lead to much better parsing performance,\n    particularly for large messages. (#8184).\n  * Fill out JRuby support (#7923)\n  * [Ruby] Fix: (SIGSEGV) gRPC-Ruby issue on Windows. memory alloc infinite\n    recursion/run out of memory (#8195)\n  * Fix jruby support to handle messages nested more than 1 level deep (#8194)\n\n  Java\n  * Avoid possible UnsupportedOperationException when using CodedInputSteam\n    with a direct ByteBuffer.\n  * Make Durations.comparator() and Timestamps.comparator() Serializable.\n  * Add more detailed error information for dynamic message field type\n    validation failure\n  * Removed declarations of functions declared in java_names.h from\n    java_helpers.h.\n  * Now Proto3 Oneof fields have \"has\" methods for checking their presence in\n    Java.\n  * Annotates Java proto generated *_FIELD_NUMBER constants.\n  * Add -assumevalues to remove JvmMemoryAccessor on Android.\n\n  C#\n  * Fix parsing negative Int32Value that crosses segment boundary (#8035)\n  * Change ByteString to use memory and support unsafe create without copy (#7645)\n  * Optimize MapField serialization by removing MessageAdapter (#8143)\n  * Allow FileDescriptors to be parsed with extension registries (#8220)\n  * Optimize writing small strings (#8149)\n\n2020-11-11 version 3.14.0 (C++/Java/Python/PHP/Objective-C/C#/Ruby/JavaScript)\n\n  Protocol Compiler\n  * The proto compiler no longer requires a .proto filename when it is not\n    generating code.\n  * Added flag `--deterministic_output` to `protoc --encode=...`.\n  * Fixed deadlock when using google.protobuf.Any embedded in aggregate options.\n\n  C++\n  * Arenas are now unconditionally enabled. cc_enable_arenas no longer has\n    any effect.\n  * Removed inlined string support, which is incompatible with arenas.\n  * Fix a memory corruption bug in reflection when mixing optional and\n    non-optional fields.\n  * Make SpaceUsed() calculation more thorough for map fields.\n  * Add stack overflow protection for text format with unknown field values.\n  * FieldPath::FollowAll() now returns a bool to signal if an out-of-bounds\n    error was encountered.\n  * Performance improvements for Map.\n  * Minor formatting fix when dumping a descriptor to .proto format with\n    DebugString.\n  * UBSAN fix in RepeatedField (#2073).\n  * When running under ASAN, skip a test that makes huge allocations.\n  * Fixed a crash that could happen when creating more than 256 extensions in\n    a single message.\n  * Fix a crash in BuildFile when passing in invalid descriptor proto.\n  * Parser security fix when operating with CodedInputStream.\n  * Warn against the use of AllowUnknownExtension.\n  * Migrated to C++11 for-range loops instead of index-based loops where\n    possible. This fixes a lot of warnings when compiling with -Wsign-compare.\n  * Fix segment fault for proto3 optional (#7805)\n  * Adds a CMake option to build `libprotoc` separately (#7949)\n\n  Java\n  * Bugfix in mergeFrom() when a oneof has multiple message fields.\n  * Fix RopeByteString.RopeInputStream.read() returning -1 when told to read\n    0 bytes when not at EOF.\n  * Redefine remove(Object) on primitive repeated field Lists to avoid\n    autoboxing.\n  * Support \"\\u\" escapes in textformat string literals.\n  * Trailing empty spaces are no longer ignored for FieldMask.\n  * Fix FieldMaskUtil.subtract to recursively remove mask.\n  * Mark enums with `@java.lang.Deprecated` if the proto enum has option\n    `deprecated = true;`.\n  * Adding forgotten duration.proto to the lite library (#7738)\n\n  Python\n  * Print google.protobuf.NullValue as null instead of \"NULL_VALUE\" when it is\n    used outside WKT Value/Struct.\n  * Fix bug occurring when attempting to deep copy an enum type in python 3.\n  * Add a setuptools extension for generating Python protobufs (#7783)\n  * Remove uses of pkg_resources in non-namespace packages. (#7902)\n  * [bazel/py] Omit google/__init__.py from the Protobuf runtime. (#7908)\n  * Removed the unnecessary setuptools package dependency for Python package (#7511)\n  * Fix PyUnknownFields memory leak (#7928)\n\n  PHP\n  * Added support for \"==\" to the PHP C extension (#7883)\n  * Added `==` operators for Map and Array. (#7900)\n  * Native C well-known types (#7944)\n  * Optimized away hex2bin() call in generated code (#8006)\n  * New version of upb, and a new hash function wyhash in third_party. (#8000)\n  * add missing hasOneof method to check presence of oneof fields (#8003)\n\n  Go:\n  * Update go_package options to reference google.golang.org/protobuf module.\n\n  C#:\n  * annotate ByteString.CopyFrom(ReadOnlySpan<byte>) as SecuritySafeCritical (#7701)\n  * Fix C# optional field reflection when there are regular fields too (#7705)\n  * Fix parsing negative Int32Value that crosses segment boundary (#8035)\n\n  Javascript:\n  * JS: parse (un)packed fields conditionally (#7379)\n\n2020-07-14 version 3.13.0 (C++/Java/Python/PHP/Objective-C/C#/Ruby/JavaScript)\n\n  PHP:\n  * The C extension is completely rewritten. The new C extension has significantly\n    better parsing performance and fixes a handful of conformance issues. It will\n    also make it easier to add support for more features like proto2 and proto3 presence.\n  * The new C extension does not support PHP 5.x. PHP 5.x users can still use pure-PHP.\n\n  C++:\n  * Removed deprecated unsafe arena string accessors\n  * Enabled heterogeneous lookup for std::string keys in maps.\n  * Removed implicit conversion from StringPiece to std::string\n  * Fix use-after-destroy bug when the Map is allocated in the arena.\n  * Improved the randomness of map ordering\n  * Added stack overflow protection for text format with unknown fields\n  * Use std::hash for proto maps to help with portability.\n  * Added more Windows macros to proto whitelist.\n  * Arena constructors for map entry messages are now marked \"explicit\"\n    (for regular messages they were already explicit).\n  * Fix subtle aliasing bug in RepeatedField::Add\n  * Fix mismatch between MapEntry ByteSize and Serialize with respect to unset\n    fields.\n\n  Python:\n  * JSON format conformance fixes:\n    * Reject lowercase t for Timestamp json format.\n    * Print full_name directly for extensions (no camelCase).\n    * Reject boolean values for integer fields.\n    * Reject NaN, Infinity, -Infinity that is not quoted.\n    * Base64 fixes for bytes fields: accept URL-safe base64 and missing padding.\n  * Bugfix for fields/files named \"async\" or \"await\".\n  * Improved the error message when AttributeError is returned from __getattr__\n    in EnumTypeWrapper.\n\n  Java:\n  * Fixed a bug where setting optional proto3 enums with setFooValue() would\n    not mark the value as present.\n  * Add Subtract function to FieldMaskUtil.\n\n  C#:\n  * Dropped support for netstandard1.0 (replaced by support for netstandard1.1).\n    This was required to modernize the parsing stack to use the `Span<byte>`\n    type internally. (#7351)\n  * Add `ParseFrom(ReadOnlySequence<byte>)` method to enable GC friendly\n    parsing with reduced allocations and buffer copies. (#7351)\n  * Add support for serialization directly to a `IBufferWriter<byte>` or\n    to a `Span<byte>` to enable GC friendly serialization.\n    The new API is available as extension methods on the `IMessage` type. (#7576)\n  * Add `GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE` define to make\n    generated code compatible with old C# compilers (pre-roslyn compilers\n    from .NET framework and old versions of mono) that do not support\n    ref structs. Users that are still on a legacy stack that does\n    not support C# 7.2 compiler might need to use the new define\n    in their projects to be able to build the newly generated code. (#7490)\n  * Due to the major overhaul of parsing and serialization internals (#7351 and #7576),\n    it is recommended to regenerate your generated code to achieve the best\n    performance (the legacy generated code will still work, but might incur\n    a slight performance penalty).\n\n2020-07-28 version 3.12.4 (C++/Java/Python/PHP/Objective-C/C#/Ruby/JavaScript)\n\nThis release contains no significant changes, but exists because 3.12.3 was\nmistakenly tagged at the wrong commit.\n\n2020-06-01 version 3.12.3 (C++/Java/Python/PHP/Objective-C/C#/Ruby/JavaScript)\n\n  Objective-C\n  * Tweak the union used for Extensions to support old generated code. #7573\n\n2020-05-26 version 3.12.2 (C++/Java/Python/PHP/Objective-C/C#/Ruby/JavaScript)\n\n  C++\n  * Simplified the template export macros to fix the build for mingw32. (#7539)\n\n  Objective-C\n  * Fix for the :protobuf_objc target in the Bazel BUILD file. (#7538)\n\n2020-05-20 version 3.12.1 (C++/Java/Python/PHP/Objective-C/C#/Ruby/JavaScript)\n\n  Ruby\n  * Re-add binary gems for Ruby 2.3 and 2.4. These are EOL upstream, however\n    many people still use them and dropping support will require more\n    coordination.\n\n2020-05-12 version 3.12.0 (C++/Java/Python/PHP/Objective-C/C#/Ruby/JavaScript)\n\n  Protocol Compiler\n  * [experimental] Singular, non-message typed fields in proto3 now support\n    presence tracking. This is enabled by adding the \"optional\" field label and\n    passing the --experimental_allow_proto3_optional flag to protoc.\n    * For usage info, see docs/field_presence.md.\n    * During this experimental phase, code generators should update to support\n      proto3 presence, see docs/implementing_proto3_presence.md for instructions.\n  * Allow duplicate symbol names when multiple descriptor sets are passed on\n    the command-line, to match the behavior when multiple .proto files are passed.\n  * Deterministic `protoc --descriptor_set_out` (#7175)\n\n  C++\n  * [experimental] Added proto3 presence support.\n  * New descriptor APIs to support proto3 presence.\n  * Enable Arenas by default on all .proto files.\n  * Documented that users are not allowed to subclass Message or MessageLite.\n  * Mark generated classes as final; inheriting from protos is strongly discouraged.\n  * Add stack overflow protection for text format with unknown fields.\n  * Add accessors for map key and value FieldDescriptors.\n  * Add FieldMaskUtil::FromFieldNumbers().\n  * MessageDifferencer: use ParsePartial() on Any fields so the diff does not\n    fail when there are missing required fields.\n  * ReflectionOps::Merge(): lookup messages in the right factory, if it can.\n  * Added Descriptor::WellKnownTypes enum and Descriptor::well_known_type()\n    accessor as an easier way of determining if a message is a Well-Known Type.\n  * Optimized RepeatedField::Add() when it is used in a loop.\n  * Made proto move/swap more efficient.\n  * De-virtualize the GetArena() method in MessageLite.\n  * Improves performance of json_stream_parser.cc by factor 1000 (#7230)\n  * bug: #7076 undefine Windows OUT and OPTIONAL macros (#7087)\n  * Fixed a bug in FieldDescriptor::DebugString() that would erroneously print\n    an \"optional\" label for a field in a oneof.\n  * Fix bug in parsing bool extensions that assumed they are always 1 byte.\n  * Fix off-by-one error in FieldOptions::ByteSize() when extensions are present.\n  * Clarified the comments to show an example of the difference between\n    Descriptor::extension and DescriptorPool::FindAllExtensions.\n  * Add a compiler option 'code_size' to force optimize_for=code_size on all\n    protos where this is possible.\n\n  Java\n  * [experimental] Added proto3 presence support.\n  * Mark java enum _VALUE constants as @Deprecated if the enum field is deprecated\n  * reduce <clinit> size for enums with allow_alias set to true.\n  * Sort map fields alphabetically by the field's key when printing textproto.\n  * Fixed a bug in map sorting that appeared in -rc1 and -rc2 (#7508).\n  * TextFormat.merge() handles Any as top level type.\n  * Throw a descriptive IllegalArgumentException when calling\n    getValueDescriptor() on enum special value UNRECOGNIZED instead of\n    ArrayIndexOutOfBoundsException.\n  * Fixed an issue with JsonFormat.printer() where setting printingEnumsAsInts()\n    would override the configuration passed into includingDefaultValueFields().\n  * Implement overrides of indexOf() and contains() on primitive lists returned\n    for repeated fields to avoid autoboxing the list contents.\n  * Add overload to FieldMaskUtil.fromStringList that accepts a descriptor.\n  * [bazel] Move Java runtime/toolchains into //java (#7190)\n\n  Python\n  * [experimental] Added proto3 presence support.\n  * [experimental] fast import protobuf module, only works with cpp generated code linked in.\n  * Truncate 'float' fields to 4 bytes of precision in setters for pure-Python\n    implementation (C++ extension was already doing this).\n  * Fixed a memory leak in C++ bindings.\n  * Added a deprecation warning when code tries to create Descriptor objects\n    directly.\n  * Fix unintended comparison between bytes and string in descriptor.py.\n  * Avoid printing excess digits for float fields in TextFormat.\n  * Remove Python 2.5 syntax compatibility from the proto compiler generated _pb2.py module code.\n  * Drop 3.3, 3.4 and use single version docker images for all python tests (#7396)\n\n  JavaScript\n  * Fix js message pivot selection (#6813)\n\n  PHP\n  * Persistent Descriptor Pool (#6899)\n  * Implement lazy loading of php class for proto messages (#6911)\n  * Correct @return in Any.unpack docblock (#7089)\n  * Ignore unknown enum value when ignore_unknown specified (#7455)\n\n  Ruby\n  * [experimental] Implemented proto3 presence for Ruby. (#7406)\n  * Stop building binary gems for ruby <2.5 (#7453)\n  * Fix for wrappers with a zero value (#7195)\n  * Fix for JSON serialization of 0/empty-valued wrapper types (#7198)\n  * Call \"Class#new\" over rb_class_new_instance in decoding (#7352)\n  * Build extensions for Ruby 2.7 (#7027)\n  * assigning 'nil' to submessage should clear the field. (#7397)\n\n  C#\n  * [experimental] Add support for proto3 presence fields in C# (#7382)\n  * Mark GetOption API as obsolete and expose the \"GetOptions()\" method on descriptors instead (#7491)\n  * Remove Has/Clear members for C# message fields in proto2 (#7429)\n  * Enforce recursion depth checking for unknown fields (#7132)\n  * Fix conformance test failures for Google.Protobuf (#6910)\n  * Cleanup various bits of Google.Protobuf (#6674)\n  * Fix latest ArgumentException for C# extensions (#6938)\n  * Remove unnecessary branch from ReadTag (#7289)\n\n  Objective-C\n  * [experimental] ObjC Proto3 optional support (#7421)\n  * Block subclassing of generated classes (#7124)\n  * Use references to Obj C classes instead of names in descriptors. (#7026)\n  * Revisit how the WKTs are bundled with ObjC. (#7173)\n\n  Other\n  * Add a proto_lang_toolchain for javalite (#6882)\n  * [bazel] Update gtest and deprecate //external:{gtest,gtest_main} (#7237)\n  * Add application note for explicit presence tracking. (#7390)\n  * Howto doc for implementing proto3 presence in a code generator. (#7407)\n\n\n2020-02-14 version 3.11.4 (C++/Java/Python/PHP/Objective-C/C#/Ruby/JavaScript)\n\n  C#\n  * Fix latest ArgumentException for C# extensions (#7188)\n  * Enforce recursion depth checking for unknown fields (#7210)\n\n  Ruby\n  * Fix wrappers with a zero value (#7195)\n  * Fix JSON serialization of 0/empty-valued wrapper types (#7198)\n\n2020-01-31 version 3.11.3 (C++/Java/Python/PHP/Objective-C/C#/Ruby/JavaScript)\n\n  C++\n  * Add OUT and OPTIONAL to windows portability files (#7087)\n\n  PHP\n  * Refactored ulong to zend_ulong for php7.4 compatibility (#7147)\n  * Call register_class before getClass from desc to fix segfault (#7077)\n\n\n2019-12-10 version 3.11.2 (C++/Java/Python/PHP/Objective-C/C#/Ruby/JavaScript)\n\n  PHP\n  * Make c extension portable for php 7.4 (#6968)\n\n\n2019-12-02 version 3.11.1 (C++/Java/Python/PHP/Objective-C/C#/Ruby/JavaScript)\n\n  PHP\n  * Extern declare protobuf_globals (#6946)\n\n\n2019-11-19 version 3.11.0 (C++/Java/Python/PHP/Objective-C/C#/Ruby/JavaScript)\n\n  C++\n  * Make serialization method naming consistent\n  * Make proto runtime + generated code free of deprecation warnings\n  * Moved ShutdownProtobufLibrary() to message_lite.h.  For backward compatibility a declaration is still available in stubs/common.h, but users should prefer message_lite.h\n  * Removed non-namespace macro EXPECT_OK()\n  * Removed mathlimits.h from stubs in favor of using std::numeric_limits from C++11\n  * Fixed bug in parser when ending on a group tag\n  * Add a helper function to UnknownFieldSet to deal with the changing return value of message::unknown_fields()\n  * Fix incorrect use of string_view iterators\n  * Support direct pickling of nested messages\n  * Skip extension tag validation for MessageSet if unknown dependencies are allowed\n  * Updated deprecation macros to annotate deprecated code (#6612)\n  * Remove conversion warning in MapEntryFuncs::ByteSizeLong (#6766)\n  * Revert \"Make shared libraries be able to link to MSVC static runtime libraries, so that VC runtime is not required.\" (#6914)\n\n  Java\n  * Remove the usage of MethodHandle, so that Android users prior to API version 26 can use protobuf-java\n  * Publish ProGuard config for javalite\n  * Fix for StrictMode disk read violation in ExtensionRegistryLite\n  * Include part of the ByteString's content in its toString().\n  * Include unknown fields when merging proto3 messages in Java lite builders\n\n  Python\n  * Add float_precision option in json format printer\n  * Optionally print bytes fields as messages in unknown fields, if possible\n  * FieldPath: fix testing IsSet on root path ''\n  * Experimental code gen (fast import protobuf module) which only work with cpp generated code linked in\n\n  JavaScript\n  * Remove guard for Symbol iterator for jspb.Map\n\n  PHP\n  * Avoid too much overhead in layout_init (#6716)\n  * Lazily Create Singular Wrapper Message (#6833)\n  * Implement lazy loading of php class for proto messages (#6911)\n\n  Ruby\n  * Ruby lazy wrappers optimization (#6797)\n\n  C#\n  * (RepeatedField): Capacity property to resize the internal array (#6530)\n  * Experimental proto2 support is now officially available (#4642, #5183, #5350, #5936)\n  * Getting started doc: https://github.com/protocolbuffers/protobuf/blob/master/docs/csharp/proto2.md\n  * Add length checks to ExtensionCollection (#6759)\n  * Optimize parsing of some primitive and wrapper types (#6843)\n  * Use 3 parameter Encoding.GetString for default string values (#6828)\n  * Change _Extensions property to normal body rather than expression (#6856)\n\n  Objective C\n  * Fixed unaligned reads for 32bit arm with newer Xcode versions (#6678)\n\n\n2019-09-03 version 3.10.0 (C++/Java/Python/PHP/Objective-C/C#/Ruby/JavaScript)\n\n  C++\n  * Switch the proto parser to the faster MOMI parser.\n  * Properly escape Struct keys in the proto3 JSON serializer.\n  * Fix crash on uninitialized map entries.\n  * Informed the compiler of has-bit invariant to produce better code\n  * Unused imports of files defining descriptor extensions will now be reported\n  * Add proto2::util::RemoveSubranges to remove multiple subranges in linear time.\n  * Added BaseTextGenerator::GetCurrentIndentationSize()\n  * Made implicit weak fields compatible with the Apple linker\n  * Support 32 bit values for ProtoStreamObjectWriter to Struct.\n  * Removed the internal-only header coded_stream_inl.h and the internal-only methods defined there.\n  * Enforced no SWIG wrapping of descriptor_database.h (other headers already had this restriction).\n  * Implementation of the equivalent of the MOMI parser for serialization. This removes one of the two serialization routines, by making the fast array serialization routine completely general. SerializeToCodedStream can now be implemented in terms of the much much faster array serialization. The array serialization regresses slightly, but when array serialization is not possible this wins big.\n  * Do not convert unknown field name to snake case to accurately report error.\n  * Fix a UBSAN warnings. (#6333)\n  * Add podspec for C++ (#6404)\n  * protoc: fix source code info location for missing label (#6436)\n  * C++ Add move constructor for Reflection's SetString (#6477)\n\n  Java\n  * Call loadDescriptor outside of synchronized block to remove one possible source of deadlock.\n  * Have oneof enums implement a separate interface (other than EnumLite) for clarity.\n  * Opensource Android Memory Accessors\n  * Update TextFormat to make use of the new TypeRegistry.\n  * Support getFieldBuilder and getRepeatedFieldBuilder in ExtendableBuilder\n  * Update JsonFormat to make use of the new TypeRegistry.\n  * Add proguard config generator for GmmBenchmarkSuiteLite.\n  * Change ProtobufArrayList to use Object[] instead of ArrayList for 5-10% faster parsing\n  * Implement ProtobufArrayList.add(E) for 20% (5%-40%) faster overall protolite2 parsing\n  * Make a copy of JsonFormat.TypeRegistry at the protobuf top level package. This will eventually replace JsonFormat.TypeRegistry.\n  * Fix javadoc warnings in generated files (#6231)\n  * Java: Add Automatic-Module-Name entries to the Manifest (#6568)\n\n  Python\n  * Add descriptor methods in descriptor_pool are deprecated.\n  * Uses explicit imports to prevent multithread test failures in py3.\n  * Added __delitem__ for Python extension dict\n  * Update six version to 1.12.0 and fix legacy_create_init issue (#6391)\n\n  JavaScript\n  * Remove deprecated boolean option to getResultBase64String().\n  * Fix sint64 zig-zag encoding.\n  * Simplify hash64 string conversion to avoid DIGIT array. Should reduce overhead if these functions aren't used, and be more efficient by avoiding linear array searches.\n  * Change the parameter types of binaryReaderFn in ExtensionFieldBinaryInfo to (number, ?, ?).\n  * Create dates.ts and time_of_days.ts to mirror Java versions. This is a near-identical conversion of c.g.type.util.{Dates,TimeOfDays} respectively.\n  * Migrate moneys to TypeScript.\n\n  PHP\n  * Fix incorrect leap day for Timestamp (#6696)\n  * Initialize well known type values (#6713)\n\n  Ruby\n  * Fix scope resolution for Google namespace (#5878)\n  * Support hashes for struct initializers (#5716)\n  * Optimized away the creation of empty string objects. (#6502)\n  * Roll forward Ruby upb changes now that protobuf Ruby build is fixed (#5866)\n  * Optimized layout_mark() for Ruby (#6521)\n  * Optimization for layout_init() (#6547)\n  * Fix for GC of Ruby map frames. (#6533)\n  * Fixed leap year handling by reworking upb_mktime() -> upb_timegm(). (#6695)\n\n  Objective C\n  * Remove OSReadLittle* due to alignment requirements (#6678)\n  * Don't use unions and instead use memcpy for the type swaps. (#6672)\n\n  Other\n  * Override CocoaPods module to lowercase (#6464)\n\n\n2019-06-28 version 3.9.0 (C++/Java/Python/PHP/Objective-C/C#/Ruby/JavaScript)\n\n  C++\n  * Optimize and simplify implementation of RepeatedPtrFieldBase\n  * Don't create unnecessary unknown field sets.\n  * Remove branch from accessors to repeated field element array.\n  * Added delimited parse and serialize util.\n  * Reduce size by not emitting constants for fieldnumbers\n  * Fix a bug when comparing finite and infinite field values with explicit tolerances.\n  * TextFormat::Parser should use a custom Finder to look up extensions by number if one is provided.\n  * Add MessageLite::Utf8DebugString() to make MessageLite more compatible with Message.\n  * Fail fast for better performance in DescriptorPool::FindExtensionByNumber() if descriptor has no defined extensions.\n  * Adding the file name to help debug colliding extensions\n  * Added FieldDescriptor::PrintableNameForExtension() and DescriptorPool::FindExtensionByPrintableName().\n    The latter will replace Reflection::FindKnownExtensionByName().\n  * Replace NULL with nullptr\n  * Created a new Add method in repeated field that allows adding a range of elements all at once.\n  * Enabled enum name-to-value mapping functions for C++ lite\n  * Avoid dynamic initialization in descriptor.proto generated code\n  * Move stream functions to MessageLite from Message.\n  * Move all zero_copy_stream functionality to io_lite.\n  * Do not create array of matched fields for simple repeated fields\n  * Enabling silent mode by default to reduce make compilation noise. (#6237)\n\n  Java\n  * Expose TextFormat.Printer and make it configurable. Deprecate the static methods.\n  * Library for constructing google.protobuf.Struct and google.protobuf.Value\n  * Make OneofDescriptor extend GenericDescriptor.\n  * Expose streamingness of service methods from MethodDescriptor.\n  * Fix a bug where TextFormat fails to parse Any filed with > 1 embedded message sub-fields.\n  * Establish consistent JsonFormat behavior for nulls in oneofs, regardless of order.\n  * Update GSON version to 3.8.5. (#6268)\n  * Add `protobuf_java_lite` Bazel target. (#6177)\n\n  Python\n  * Change implementation of Name() for enums that allow aliases in proto2 in Python\n    to be in line with claims in C++ implementation (to return first value).\n  * Explicitly say what field cannot be set when the new value fails a type check.\n  * Duplicate register in descriptor pool will raise errors\n  * Add __slots__ to all well_known_types classes, custom attributes are not allowed anymore.\n  * text_format only present 8 valid digits for float fields by default\n\n  JavaScript\n  * Add Oneof enum to the list of goog.provide\n\n  PHP\n  * Make php message class final to avoid mocking. (#6277)\n  * Rename get/setXXXValue to get/setXXXWrapper. (#6295)\n\n  Ruby\n  * Remove to_hash methods. (#6166)\n\n\n2019-04-29 version 3.8.0 (C++/Java/Python/PHP/Objective-C/C#/Ruby/JavaScript)\n\n  C++\n  * Use std::atomic<int32> in case of myriad2 platform\n  * Always declare enums to be int-sized\n  * Added DebugString() and ShortDebugString() methods on MessageLite\n  * Specialized different parse loop control flows\n  * Make hasbits potentially in register. The or's start forming an obstacle because it's a read modify store on the same mem address on each iteration.\n  * Move to an internal MACRO for parser validity checks.\n  * Improve map parsing performance.\n  * Make MergePartialFromCodedStream non virtual. This allows direct calls, potential inlining and is also a code health improvement\n  * Add an overall limit to parse_context to prevent reading past it. This allows to remove a annoying level of indirection.\n  * Fix a mistake, we shouldn't verify map key/value strings for utf8 in opt mode for proto2.\n  * Further improvements to cut binary size.\n  * Prepare to make MergePartialFromCodedStream non-virtual.\n  * A report on some interesting behavior change in python (caused by b/27494216) made me realize there is a check that needs to be done in case the parse ended on a end group tag.\n  * Add a note of caution to the comments around skip in CodedOutputStream.\n  * Simplify end check.\n  * Add overload for ParseMessage for MessageLite/Message types. If the explicit type is not known inlining won't help de-virtualizing the virtual call.\n  * Reduce linker input. It turns out that ParseMessage is not inlined, producing  template instantiations that are used only once and save nothing but cost more.\n  * Improve the parser.\n  * [c++17] Changed proto2::RepeatedPtrField iterators to no longer derive from the deprecated std::iterator class.\n  * Change the default value of case_insensitive_enum_parsing to false for JsonStringToMessage.\n  * Add a warning if a field name doesn't match the style guide.\n  * Fix TextFormat not round-trip correctly when float value is max float.\n  * Added locationed info for some errors at compiler\n  * Python reserved keywords are now working with getattr()/setattr() for most descriptors.\n  * Added AllowUnknownField() in text_format\n  * Append '_' to C++ reserved keywords for message, enum, extension\n  * Fix MSVC warning C4244 in protobuf's parse_context.h.\n  * Updating Iterators to be compatible with C++17 in MSVC.\n  * Use capability annotation in mutex.h\n  * Fix \"UndefinedBehaviorSanitizer: cfi-bad-type\"\n  * CriticalSectionLock class as a lightweight replacement for std::mutex on Windows platforms.\n  * Removed vestigial wire_format_lite_inl.h\n\n  C#\n  * Added System.Memory dependency.\n\n  Java\n  * Make Java protoc code generator ignore optimize_for LITE_RUNTIME. Users should instead use the Java lite protoc plugin.\n  * Change Extension getMessageDefaultInstance() to return Message instead of MessageLite.\n  * Prevent malicious input streams from leaking buffers for ByteString or ByteBuffer parsing.\n  * Release new Javalite runtime.\n  * Show warning in case potential file name conflict.\n  * Allow Java reserved keywords to be used in extensions.\n  * Added setAllowUnknownFields() in text format\n  * Add memoization to ExtensionRegistryLite.getEmptyRegistry()\n  * Improve performance of CodedOutputStream.writeUInt32NoTag\n  * Add an optimized mismatch-finding algorithm to UnsafeUtil.\n  * When serializing uint32 varints, check that we have MAX_VARINT32_SIZE bytes left, not just MAX_VARINT_SIZE.\n  * Minor optimization to RopeByteString.PieceIterator\n\n  JavaScript\n  * Simplify generated toObject code when the default value is used.\n\n  Python\n  * Changes implementation of Name() for enums that allow aliases in proto2 in Python to be in line with claims in C++ implementation (to return first value).\n  * Added double_format option in text format printer.\n  * Added iter and __contains__ to extension dict\n  * Added allow_unknown_field option in python text format parser\n  * Fixed Timestamp.ToDatetime() loses precision issue\n  * Support unknown field in text format printer.\n  * Float field will be convert to inf if bigger than struct.unpack('f', b'\\xff\\xff\\x7f\\x7f')[0] which is about 3.4028234664e+38,\n  convert to -inf if smaller than -3.4028234664e+38\n  * Allowed casting str->bytes in Message.__setstate__\n\n  Ruby\n  * Helper methods to get enum name for Ruby.\n\n\n2019-01-24 version 3.7.0 (C++/Java/Python/PHP/Objective-C/C#/Ruby/JavaScript)\n\n  C++\n  * Introduced new MOMI (maybe-outside-memory-interval) parser.\n  * Add an option to json_util to parse enum as case-insensitive. In the future, enum parsing in json_util will become case-sensitive.\n  * Added conformance test for enum aliases\n  * Added support for --cpp_out=speed:...\n  * Added use of C++ override keyword where appropriate\n  * Many other cleanups and fixes.\n\n  Java\n  * Fix illegal reflective access warning in JDK 9+\n  * Add BOM\n\n  Python\n  * Added Python 3.7 compatibility.\n  * Modified ParseFromString to return bytes parsed .\n  * Introduce Proto C API.\n  * FindFileContainingSymbol in descriptor pool is now able to find field and enum values.\n  * reflection.MakeClass()  and  reflection.ParseMessage() are deprecated.\n  * Added DescriptorPool.FindMethodByName() method in pure python (c extension already has it)\n  * Flipped proto3 to preserve unknown fields by default.\n  * Added support for memoryview in python3 proto message parsing.\n  * Added MergeFrom for repeated scalar fields in c extension (pure python already has it)\n  * Surrogates are now rejected at setters in python3.\n  * Added public unknown field API.\n  * RecursionLimit is also set to max if allow_oversize_protos is enabled.\n  * Disallow duplicate scalars in proto3 text_format parse.\n  * Fix some segment faults for c extension map field.\n\n  PHP\n  * Most issues for json encoding/decoding in the c extension have been fixed. There are still some edge cases not fixed. For more details, check conformance/failure_list_php_c.txt.\n  * Supports php 7.3\n  * Added helper methods to convert between enum values and names.\n  * Allow setting/getting wrapper message fields using primitive values.\n  * Various bug fixes.\n\n  Ruby\n  * Ruby 2.6 support.\n  * Drops support for ruby < 2.3.\n  * Most issues for json encoding/decoding in the c extension have been fixed. There are still some edge cases not fixed. For more details, check conformance/failure_list_ruby.txt.\n  * Json parsing can specify an option to ignore unknown fields: msg.decode_json(data, {ignore_unknown_fields: true}).\n  * Added support for proto2 syntax (partially).\n  * Various bug fixes.\n\n  Csharp\n  * More support for FieldMask include merge, intersect and more.\n  * Increasing the default recursion limit to 100.\n  * Support loading FileDescriptors dynamically.\n  * Provide access to comments from descriptors.\n  * Added Any.Is method.\n  * Compatible with C# 6\n  * Added IComparable and comparison operators on Timestamp.\n\n  Objective C\n  * Add ability to introspect list of enum values (#4678)\n  * Copy the value when setting message/data fields (#5215)\n  * Support suppressing the objc package prefix checks on a list of files (#5309)\n  * More complete keyword and NSObject method (via categories) checks for field names, can result in more fields being rename, but avoids the collisions at runtime (#5289)\n  * Small fixes to TextFormat generation for extensions (#5362)\n  * Provide more details/context in deprecation messages (#5412)\n  * Array/Dictionary enumeration blocks NS_NOESCAPE annotation for Swift (#5421)\n  * Properly annotate extensions for ARC when their names imply behaviors (#5427)\n  * Enum alias name collision improvements (#5480)\n\n\n2018-07-27 version 3.6.1 (C++/Java/Python/PHP/Objective-C/C#/Ruby/JavaScript)\n\n  C++\n  * Introduced workaround for Windows issue with std::atomic and std::once_flag\n    initialization (#4777, #4773).\n\n  PHP\n  * Added compatibility with PHP 7.3 (#4898).\n\n  Ruby\n  * Fixed Ruby crash involving Any encoding (#4718).\n\n2018-06-01 version 3.6.0 (C++/Java/Python/PHP/Objective-C/C#/Ruby/JavaScript)\n\n  C++\n  * Starting from this release, we now require C++11. For those we cannot yet\n    upgrade to C++11, we will try to keep the 3.5.x branch updated with\n    critical bug fixes only. If you have any concerns about this, please\n    comment on issue #2780.\n  * Moved to C++11 types like std::atomic and std::unique_ptr and away from our\n    old custom-built equivalents.\n  * Added support for repeated message fields in lite protos using implicit\n    weak fields. This is an experimental feature that allows the linker to\n    strip out more unused messages than previously was possible.\n  * Fixed SourceCodeInfo for interpreted options and extension range options.\n  * Fixed always_print_enums_as_ints option for JSON serialization.\n  * Added support for ignoring unknown enum values when parsing JSON.\n  * Create std::string in Arena memory.\n  * Fixed ValidateDateTime to correctly check the day.\n  * Fixed bug in ZeroCopyStreamByteSink.\n  * Various other cleanups and fixes.\n\n  Java\n  * Dropped support for Java 6.\n  * Added a UTF-8 decoder that uses Unsafe to directly decode a byte buffer.\n  * Added deprecation annotations to generated code for deprecated oneof\n    fields.\n  * Fixed map field serialization in DynamicMessage.\n  * Cleanup and documentation for Java Lite runtime.\n  * Various other fixes and cleanups\n  * Fixed unboxed arraylists to handle an edge case\n  * Improved performance for copying between unboxed arraylists\n  * Fixed lite protobuf to avoid Java compiler warnings\n  * Improved test coverage for lite runtime\n  * Performance improvements for lite runtime\n\n  Python\n  * Fixed bytes/string map key incompatibility between C++ and pure-Python\n    implementations (issue #4029)\n  * Added __init__.py files to compiler and util subpackages\n  * Use /MT for all Windows versions\n  * Fixed an issue affecting the Python-C++ implementation when used with\n    Cython (issue #2896)\n  * Various text format fixes\n  * Various fixes to resolve behavior differences between the pure-Python and\n    Python-C++ implementations\n\n  PHP\n  * Added php_metadata_namespace to control the file path of generated metadata\n    file.\n  * Changed generated classes of nested message/enum. E.g., Foo.Bar, which\n    previously generates Foo_Bar, now generates Foo/Bar\n  * Added array constructor. When creating a message, users can pass a php\n    array whose content is field name to value pairs into constructor. The\n    created message will be initialized according to the array. Note that\n    message field should use a message value instead of a sub-array.\n  * Various bug fixes.\n\n  Objective-C\n  * We removed some helper class methods from GPBDictionary to shrink the size\n    of the library, the functionary is still there, but you may need to do some\n    specific +alloc / -init\u2026 methods instead.\n  * Minor improvements in the performance of object field getters/setters by\n    avoiding some memory management overhead.\n  * Fix a memory leak during the raising of some errors.\n  * Make header importing completely order independent.\n  * Small code improvements for things the undefined behaviors compiler option\n    was flagging.\n\n  Ruby\n  * Added ruby_package file option to control the module of generated class.\n  * Various bug fixes.\n\n  Javascript\n  * Allow setting string to int64 field.\n\n  Csharp\n  * Unknown fields are now parsed and then sent back on the wire. They can be\n    discarded at parse time via a CodedInputStream option.\n  * Movement towards working with .NET 3.5 and Unity\n  * Expression trees are no longer used\n  * AOT generics issues in Unity/il2cpp have a workaround (see this commit for\n    details)\n  * Floating point values are now compared bitwise (affects NaN value\n    comparisons)\n  * The default size limit when parsing is now 2GB rather than 64MB\n  * MessageParser now supports parsing from a slice of a byte array\n  * JSON list parsing now accepts null values where the underlying proto\n    representation does\n\n2017-12-20 version 3.5.1 (C++/Java/Python/PHP/Objective-C/C#/Ruby/JavaScript)\n  Planned Future Changes\n  * Make C++ implementation C++11 only: we plan to require C++11 to build\n    protobuf code starting from 3.6.0 release. Please join this github issue:\n    https://github.com/protocolbuffers/protobuf/issues/2780 to provide your feedback.\n\n  protoc\n  * Fixed a bug introduced in 3.5.0 and protoc in Windows now accepts non-ascii\n    characters in paths again.\n\n  C++\n  * Removed several usages of C++11 features in the code base.\n  * Fixed some compiler warnings.\n\n  PHP\n  * Fixed memory leak in C-extension implementation.\n  * Added discardUnknokwnFields API.\n  * Removed duplicated typedef in C-extension headers.\n  * Avoided calling private php methods (timelib_update_ts).\n  * Fixed Any.php to use fully-qualified name for DescriptorPool.\n\n  Ruby\n  * Added Google_Protobuf_discard_unknown for discarding unknown fields in\n    messages.\n\n  C#\n  * Unknown fields are now preserved by default.\n  * Floating point values are now bitwise compared, affecting message equality\n    check and Contains() API in map and repeated fields.\n\n\n2017-11-13 version 3.5.0 (C++/Java/Python/PHP/Objective-C/C#/Ruby/JavaScript)\n  Planned Future Changes\n  * Make C++ implementation C++11 only: we plan to require C++11 to build\n    protobuf code starting from 3.6.0 release. Please join this github issue:\n    https://github.com/protocolbuffers/protobuf/issues/2780 to provide your feedback.\n\n  General\n  * Unknown fields are now preserved in proto3 for most of the language\n    implementations for proto3 by default. See the per-language section for\n    details.\n  * reserve keyword are now supported in enums\n\n  C++\n  * Proto3 messages are now preserving unknown fields by default. If you rely on\n    unknowns fields being dropped. Please use DiscardUnknownFields() explicitly.\n  * Deprecated the unsafe_arena_release_* and unsafe_arena_add_allocated_*\n    methods for string fields.\n  * Added move constructor and move assignment to RepeatedField,\n    RepeatedPtrField and google::protobuf::Any.\n  * Added perfect forwarding in Arena::CreateMessage\n  * In-progress experimental support for implicit weak fields with lite protos.\n    This feature allows the linker to strip out more unused messages and reduce\n    binary size.\n  * Various performance optimizations.\n\n  Java\n  * Proto3 messages are now preserving unknown fields by default. If you\u2019d like\n    to drop unknown fields, please use the DiscardUnknownFieldsParser\u00a0API. For\n    example:\n      Parser<Foo> parser = DiscardUnknownFieldsParser.wrap(Foo.parser());\n      Foo foo = parser.parseFrom(input);\n  * Added a new CodedInputStream decoder for Iterable<ByteBuffer> with direct\n    ByteBuffers.\n  * TextFormat now prints unknown length-delimited fields as messages if\n    possible.\n  * FieldMaskUtil.merge() no longer creates unnecessary empty messages when a\n    message field is unset in both source message and destination message.\n  * Various performance optimizations.\n\n  Python\n  * Proto3 messages are now preserving unknown fields by default. Use\n    message.DiscardUnknownFields() to drop unknown fields.\n  * Add FieldDescriptor.file in generated code.\n  * Add descriptor pool FindOneofByName in pure python.\n  * Change unknown enum values into unknown field set .\n  * Add more Python dict/list compatibility for Struct/ListValue.\n  * Add utf-8 support for text_format.Merge()/Parse().\n  * Support numeric unknown enum values for proto3 JSON format.\n  * Add warning for Unexpected end-group tag in cpp extension.\n\n  PHP\n  * Proto3 messages are now preserving unknown fields.\n  * Provide well known type messages in runtime.\n  * Add prefix \u2018PB\u2019 to generated class of reserved names.\n  * Fixed all conformance tests for encode/decode json in php runtime. C\n    extension needs more work.\n\n  Objective-C\n  * Fixed some issues around copying of messages with unknown fields and then\n    mutating the unknown fields in the copy.\n\n  C#\n  * Added unknown field support in JsonParser.\n  * Fixed oneof message field merge.\n  * Simplify parsing messages from array slices.\n\n  Ruby\n  * Unknown fields are now preserved by default.\n  * Fixed several bugs for segment fault.\n\n  Javascript\n  * Decoder can handle both paced and unpacked data no matter how the proto is\n    defined.\n  * Decoder now accept long varint for 32 bit integers.\n\n\n2017-08-14 version 3.4.0 (C++/Java/Python/PHP/Objective-C/C#/Ruby/JavaScript)\n  Planned Future Changes\n  * There are some changes that are not included in this release but are planned\n    for the near future\n      - Preserve unknown fields in proto3: We are going to bring unknown fields\n        back into proto3. In this release, some languages start to support\n        preserving unknown fields in proto3, controlled by flags/options. Some\n        languages also introduce explicit APIs to drop unknown fields for\n        migration. Please read the change log sections by languages for details.\n        For general timeline and plan:\n\n          https://docs.google.com/document/d/1KMRX-G91Aa-Y2FkEaHeeviLRRNblgIahbsk4wA14gRk/view\n\n        For issues and discussions:\n\n          https://github.com/protocolbuffers/protobuf/issues/272\n\n      - Make C++ implementation C++11 only: we plan to require C++11 to build\n        protobuf code starting from 3.5.0 or 3.6.0 release, after unknown fields\n        semantic changes are finished. Please join this\n        github issue:\n\n          https://github.com/protocolbuffers/protobuf/issues/2780\n\n        to provide your feedback.\n\n  General\n  * Extension ranges now accept options and are customizable.\n  * \"reserve\" keyword now supports \u201cmax\u201d in field number ranges,\n    e.g.  reserve 1000 to max;\n\n  C++\n  * Proto3 messages are now able to preserve unknown fields. The default\n    behavior is still to drop unknowns, which will be flipped in a future\n    release. If you rely on unknowns fields being dropped. Please use\n    Message::DiscardUnknownFields() explicitly.\n  * Packable proto3 fields are now packed by default in serialization.\n  * Following C++11 features are introduced when C++11 is available:\n      - move-constructor and move-assignment are introduced to messages\n      - Repeated fields constructor now takes std::initializer_list\n      - rvalue setters are introduced for string fields\n  * Experimental Table-Driven parsing and serialization available to test. To\n    enable it, pass in table_driven_parsing table_driven_serialization protoc\n    generator flags for C++\n\n      $ protoc --cpp_out=table_driven_parsing,table_driven_serialization:./ \\\n        test.proto\n\n  * lite generator parameter supported by the generator. Once set, all generated\n    files, use lite runtime regardless of the optimizer_for setting in the\n    .proto file.\n  * Various optimizations to make C++ code more performant on PowerPC platform\n  * Fixed maps data corruption when the maps are modified by both reflection API\n    and generated API.\n  * Deterministic serialization on maps reflection now uses stable sort.\n  * file() accessors are introduced to various *Descriptor classes to make\n    writing template function easier.\n  * ByteSize() and SpaceUsed() are deprecated.Use ByteSizeLong() and\n    SpaceUsedLong() instead\n  * Consistent hash function is used for maps in DEBUG and NDEBUG build.\n  * \"using namespace std\" is removed from stubs/common.h\n  * Various performance optimizations and bug fixes\n\n  Java\n  * Introduced new parser API DiscardUnknownFieldsParser in preparation of\n    proto3 unknown fields preservation change. Users who want to drop unknown\n    fields should migrate to use this new parser API. For example:\n\n      Parser<Foo> parser = DiscardUnknownFieldsParser.wrap(Foo.parser());\n      Foo foo = parser.parseFrom(input);\n\n  * Introduced new TextFormat API printUnicodeFieldValue() that prints field\n    value without escaping unicode characters.\n  * Added Durations.compare(Duration, Duration) and\n    Timestamps.compare(Timestamp, Timestamp).\n  * JsonFormat now accepts base64url encoded bytes fields.\n  * Optimized CodedInputStream to do less copies when parsing large bytes\n    fields.\n  * Optimized TextFormat to allocate less memory when printing.\n\n  Python\n  * SerializeToString API is changed to SerializeToString(self, **kwargs),\n    deterministic parameter is accepted for deterministic serialization.\n  * Added sort_keys parameter in json format to make the output deterministic.\n  * Added indent parameter in json format.\n  * Added extension support in json format.\n  * Added __repr__ support for repeated field in cpp implementation.\n  * Added file in FieldDescriptor.\n  * Added pretty-print filter to text format.\n  * Services and method descriptors are always printed even if generic_service\n    option is turned off.\n  * Note: AppEngine 2.5 is deprecated on June 2017 that AppEngine 2.5 will\n    never update protobuf runtime. Users who depend on AppEngine 2.5 should use\n    old protoc.\n\n  PHP\n  * Support PHP generic services. Specify file option php_generic_service=true\n    to enable generating service interface.\n  * Message, repeated and map fields setters take value instead of reference.\n  * Added map iterator in c extension.\n  * Support json \u00a0encode/decode.\n  * Added more type info in getter/setter phpdoc\n  * Fixed the problem that c extension and php implementation cannot be used\n    together.\n  * Added file option php_namespace to use custom php namespace instead of\n    package.\n  * Added fluent setter.\n  * Added descriptor API in runtime for custom encode/decode.\n  * Various bug fixes.\n\n  Objective-C\n  * Fix for GPBExtensionRegistry copying and add tests.\n  * Optimize GPBDictionary.m codegen to reduce size of overall library by 46K\n    per architecture.\n  * Fix some cases of reading of 64bit map values.\n  * Properly error on a tag with field number zero.\n  * Preserve unknown fields in proto3 syntax files.\n  * Document the exceptions on some of the writing apis.\n\n  C#\n  * Implemented IReadOnlyDictionary<K,V> in MapField<K,V>\n  * Added TryUnpack method for Any message in addition to Unpack.\n  * Converted C# projects to MSBuild (csproj) format.\n\n  Ruby\n  * Several bug fixes.\n\n  Javascript\n  * Added support of field option js_type. Now one can specify the JS type of a\n    64-bit integer field to be string in the generated code by adding option\n    [jstype = JS_STRING] on the field.\n\n2017-04-05 version 3.3.0 (C++/Java/Python/PHP/Objective-C/C#/Ruby/JavaScript)\n  Planned Future Changes\n  * There are some changes that are not included in this release but are\n    planned for the near future:\n      - Preserve unknown fields in proto3: please read this doc:\n\n          https://docs.google.com/document/d/1KMRX-G91Aa-Y2FkEaHeeviLRRNblgIahbsk4wA14gRk/view\n\n        for the timeline and follow up this github issue:\n\n          https://github.com/protocolbuffers/protobuf/issues/272\n\n        for discussion.\n      - Make C++ implementation C++11 only: we plan to require C++11 to build\n        protobuf code starting from 3.4.0 or 3.5.0 release. Please join this\n        github issue:\n\n          https://github.com/protocolbuffers/protobuf/issues/2780\n\n        to provide your feedback.\n\n  C++\n  * Fixed map fields serialization of DynamicMessage to correctly serialize\n    both key and value regardless of their presence.\n  * Parser now rejects field number 0 correctly.\n  * New API Message::SpaceUsedLong() that\u2019s equivalent to\n    Message::SpaceUsed() but returns the value in size_t.\n  * JSON support\n    - New flag always_print_enums_as_ints in JsonPrintOptions.\n    - New flag preserve_proto_field_names in JsonPrintOptions. It will instruct\n      the JSON printer to use the original field name declared in the .proto\n      file instead of converting them to lowerCamelCase when printing JSON.\n    - JsonPrintOptions.always_print_primtive_fields now works for oneof message\n      fields.\n    - Fixed a bug that doesn\u2019t allow different fields to set the same json_name\n      value.\n    - Fixed a performance bug that causes excessive memory copy when printing\n      large messages.\n  * Various performance optimizations.\n\n  Java\n  * Map field setters eagerly validate inputs and throw NullPointerExceptions\n    as appropriate.\n  * Added ByteBuffer overloads to the generated parsing methods and the Parser\n    interface.\n  * proto3 enum's getNumber() method now throws on UNRECOGNIZED values.\n  * Output of JsonFormat is now locale independent.\n\n  Python\n  * Added FindServiceByName() in the pure-Python DescriptorPool. This works only\n    for descriptors added with DescriptorPool.Add(). Generated descriptor_pool\n    does not support this yet.\n  * Added a descriptor_pool parameter for parsing Any in text_format.Parse().\n  * descriptor_pool.FindFileContainingSymbol() now is able to find nested\n    extensions.\n  * Extending empty [] to repeated field now sets parent message presence.\n\n  PHP\n  * Added file option php_class_prefix. The prefix will be prepended to all\n    generated classes defined in the file.\n  * When encoding, negative int32 values are sign-extended to int64.\n  * Repeated/Map field setter accepts a regular PHP array. Type checking is\n    done on the array elements.\n  * encode/decode are renamed to serializeToString/mergeFromString.\n  * Added mergeFrom, clear method on Message.\n  * Fixed a bug that oneof accessor didn\u2019t return the field name that is\n    actually set.\n  * C extension now works with php7.\n  * This is the first GA release of PHP. We guarantee that old generated code\n    can always work with new runtime and new generated code.\n\n  Objective-C\n  * Fixed help for GPBTimestamp for dates before the epoch that contain\n    fractional seconds.\n  * Added GPBMessageDropUnknownFieldsRecursively() to remove unknowns from a\n    message and any sub messages.\n  * Addressed a threading race in extension registration/lookup.\n  * Increased the max message parsing depth to 100 to match the other languages.\n  * Removed some use of dispatch_once in favor of atomic compare/set since it\n    needs to be heap based.\n  * Fixes for new Xcode 8.3 warnings.\n\n  C#\n  * Fixed MapField.Values.CopyTo, which would throw an exception unnecessarily\n    if provided exactly the right size of array to copy to.\n  * Fixed enum JSON formatting when multiple names mapped to the same numeric\n    value.\n  * Added JSON formatting option to format enums as integers.\n  * Modified RepeatedField<T> to implement IReadOnlyList<T>.\n  * Introduced the start of custom option handling; it's not as pleasant as it\n    might be, but the information is at least present. We expect to extend code\n    generation to improve this in the future.\n  * Introduced ByteString.FromStream and ByteString.FromStreamAsync to\n    efficiently create a ByteString from a stream.\n  * Added whole-message deprecation, which decorates the class with [Obsolete].\n\n  Ruby\n  * Fixed Message#to_h for messages with map fields.\n  * Fixed memcpy() in binary gems to work for old glibc, without breaking the\n    build for non-glibc libc\u2019s like musl.\n\n  Javascript\n  * Added compatibility tests for version 3.0.0.\n  * Added conformance tests.\n  * Fixed serialization of extensions: we need to emit a value even if it is\n    falsy (like the number 0).\n  * Use closurebuilder.py in favor of calcdeps.py for compiling JavaScript.\n\n2017-01-23 version 3.2.0 (C++/Java/Python/PHP/Ruby/Objective-C/C#/JavaScript/Lite)\n  General\n  * Added protoc version number to protoc plugin protocol. It can be used by\n    protoc plugin to detect which version of protoc is used with the plugin and\n    mitigate known problems in certain version of protoc.\n\n  C++\n  * The default parsing byte size limit has been raised from 64MB to 2GB.\n  * Added rvalue setters for non-arena string fields.\n  * Enabled debug logging for Android.\n  * Fixed a double-free problem when using Reflection::SetAllocatedMessage()\n    with extension fields.\n  * Fixed several deterministic serialization bugs:\n    * MessageLite::SerializeAsString() now respects the global deterministic\n      serialization flag.\n    * Extension fields are serialized deterministically as well.  Fixed protocol\n      compiler to correctly report importing-self as an error.\n  * Fixed FileDescriptor::DebugString() to print custom options correctly.\n  * Various performance/codesize optimizations and cleanups.\n\n  Java\n  * The default parsing byte size limit has been raised from 64MB to 2GB.\n  * Added recursion limit when parsing JSON.\n  * Fixed a bug that enumType.getDescriptor().getOptions() doesn't have custom\n    options.\n  * Fixed generated code to support field numbers up to 2^29-1.\n\n  Python\n  * You can now assign NumPy scalars/arrays (np.int32, np.int64) to protobuf\n    fields, and assigning other numeric types has been optimized for\n    performance.\n  * Pure-Python: message types are now garbage-collectable.\n  * Python/C++: a lot of internal cleanup/refactoring.\n\n  PHP (Alpha)\n  * For 64-bit integers type (int64/uint64/sfixed64/fixed64/sint64), use PHP\n    integer on 64-bit environment and PHP string on 32-bit environment.\n  * PHP generated code also conforms to PSR-4 now.\n  * Fixed ZTS build for c extension.\n  * Fixed c extension build on Mac.\n  * Fixed c extension build on 32-bit linux.\n  * Fixed the bug that message without namespace is not found in the descriptor\n    pool. (#2240)\n  * Fixed the bug that repeated field is not iterable in c extension.\n  * Message names Empty will be converted to GPBEmpty in generated code.\n  * Added phpdoc in generated files.\n  * The released API is almost stable. Unless there is large problem, we won't\n    change it. See\n    https://developers.google.com/protocol-buffers/docs/reference/php-generated\n    for more details.\n\n  Objective-C\n  * Added support for push/pop of the stream limit on CodedInputStream for\n    anyone doing manual parsing.\n\n  C#\n  * No changes.\n\n  Ruby\n  * Message objects now support #respond_to? for field getters/setters.\n  * You can now compare \u201cmessage == non_message_object\u201d and it will return false\n    instead of throwing an exception.\n  * JRuby: fixed #hashCode to properly reflect the values in the message.\n\n  Javascript\n  * Deserialization of repeated fields no longer has quadratic performance\n    behavior.\n  * UTF-8 encoding/decoding now properly supports high codepoints.\n  * Added convenience methods for some well-known types: Any, Struct, and\n    Timestamp. These make it easier to convert data between native JavaScript\n    types and the well-known protobuf types.\n\n2016-09-23 version 3.1.0 (C++/Java/Python/PHP/Ruby/Objective-C/C#/JavaScript/Lite)\n  General\n  * Proto3 support in PHP (alpha).\n  * Various bug fixes.\n\n  C++\n  * Added MessageLite::ByteSizeLong() that\u2019s equivalent to\n    MessageLite::ByteSize() but returns the value in size_t. Useful to check\n    whether a message is over the 2G size limit that protobuf can support.\n  * Moved default_instances to global variables. This allows default_instance\n    addresses to be known at compile time.\n  * Adding missing generic gcc 64-bit atomicops.\n  * Restore New*Callback into google::protobuf namespace since these are used\n    by the service stubs code\n  * JSON support.\n    * Fixed some conformance issues.\n  * Fixed a JSON serialization bug for bytes fields.\n\n  Java\n  * Fixed a bug in TextFormat that doesn\u2019t accept empty repeated fields (i.e.,\n    \u201cfield: [ ]\u201d).\n  * JSON support\n    * Fixed JsonFormat to do correct snake_case-to-camelCase conversion for\n      non-style-conforming field names.\n    * Fixed JsonFormat to parse empty Any message correctly.\n    * Added an option to JsonFormat.Parser to ignore unknown fields.\n  * Experimental API\n    * Added UnsafeByteOperations.unsafeWrap(byte[]) to wrap a byte array into\n      ByteString without copy.\n\n  Python\n  * JSON support\n    * Fixed some conformance issues.\n\n  PHP (Alpha)\n  * We have added the proto3 support for PHP via both a pure PHP package and a\n    native c extension. The pure PHP package is intended to provide usability\n    to wider range of PHP platforms, while the c extension is intended to\n    provide higher performance. Both implementations provide the same runtime\n    APIs and share the same generated code. Users don\u2019t need to re-generate\n    code for the same proto definition when they want to switch the\n    implementation later. The pure PHP package is included in the php/src\n    directory, and the c extension is included in the php/ext directory.\n\n    Both implementations provide idiomatic PHP APIs:\n    * All messages and enums are defined as PHP classes.\n    * All message fields can only be accessed via getter/setter.\n    * Both repeated field elements and map elements are stored in containers\n      that act like a normal PHP array.\n\n    Unlike several existing third-party PHP implementations for protobuf, our\n    implementations are built on a \"strongly-typed\" philosophy: message fields\n    and array/map containers will throw exceptions eagerly when values of the\n    incorrect type (not including those that can be type converted, e.g.,\n    double <-> integer <-> numeric string) are inserted.\n\n    Currently, pure PHP runtime supports php5.5, 5.6 and 7 on linux. C\n    extension runtime supports php5.5 and 5.6 on linux.\n\n    See php/README.md for more details about installment. See\n    https://developers.google.com/protocol-buffers/docs/phptutorial for more\n    details about APIs.\n\n  Objective-C\n  * Helpers are now provided for working the Any well known type (see\n    GPBWellKnownTypes.h for the api additions).\n  * Some improvements in startup code (especially when extensions aren\u2019t used).\n\n  Javascript\n  * Fixed missing import of jspb.Map\n  * Fixed valueWriterFn variable name\n\n  Ruby\n  * Fixed hash computation for JRuby's RubyMessage\n  * Make sure map parsing frames are GC-rooted.\n  * Added API support for well-known types.\n\n  C#\n  * Removed check on dependency in the C# reflection API.\n\n2016-09-06 version 3.0.2 (C++/Java/Python/Ruby/Objective-C/C#/JavaScript/Lite)\n  General\n  * Various bug fixes.\n\n  Objective C\n  * Fix for oneofs in proto3 syntax files where fields were set to the zero\n    value.\n  * Fix for embedded null character in strings.\n  * CocoaDocs support\n\n  Ruby\n  * Fixed memory corruption bug in parsing that could occur under GC pressure.\n\n  Javascript\n  * jspb.Map is now properly exported to CommonJS modules.\n\n  C#\n  * Removed legacy_enum_values flag.\n\n\n2016-07-27 version 3.0.0 (C++/Java/Python/Ruby/Objective-C/C#/JavaScript/Lite)\n  General\n  * This log only contains changes since the beta-4 release. Summarized change\n    log since the last stable release (v2.6.1) can be found in the github\n    release page.\n\n  Compatibility Notice\n  * v3.0.0 is the first API stable release of the v3.x series. We do not expect\n    any future API breaking changes.\n  * For C++, Java Lite and Objective-C, source level compatibility is\n    guaranteed.  Upgrading from v3.0.0 to newer minor version releases will be\n    source compatible. For example, if your code compiles against protobuf\n    v3.0.0, it will continue to compile after you upgrade protobuf library to\n    v3.1.0.\n  * For other languages, both source level compatibility and binary level\n    compatibility are guaranteed. For example, if you have a Java binary built\n    against protobuf v3.0.0. After switching the protobuf runtime binary to\n    v3.1.0, your built binary should continue to work.\n  * Compatibility is only guaranteed for documented API and documented\n    behaviors. If you are using undocumented API (e.g., use anything in the C++\n    internal namespace), it can be broken by minor version releases in an\n    undetermined manner.\n\n  Ruby\n  * When you assign a string field `a.string_field = \"X\"`, we now call\n    #encode(UTF-8) on the string and freeze the copy. This saves you from\n    needing to ensure the string is already encoded as UTF-8. It also prevents\n    you from mutating the string after it has been assigned (this is how we\n    ensure it stays valid UTF-8).\n  * The generated file for `foo.proto` is now `foo_pb.rb` instead of just\n    `foo.rb`. This makes it easier to see which imports/requires are from\n    protobuf generated code, and also prevents conflicts with any `foo.rb` file\n    you might have written directly in Ruby. It is a backward-incompatible\n    change: you will need to update all of your `require` statements.\n  * For package names like `foo_bar`, we now translate this to the Ruby module\n    `FooBar`. This is more idiomatic Ruby than what we used to do (`Foo_bar`).\n\n  JavaScript\n  * Scalar fields like numbers and boolean now return defaults instead of\n    `undefined` or `null` when they are unset. You can test for presence\n    explicitly by calling `hasFoo()`, which we now generate for scalar fields.\n\n  Java Lite\n  * Java Lite is now implemented as a separate plugin, maintained in the\n    `javalite` branch. Both lite runtime and protoc artifacts will be available\n    in Maven.\n\n  C#\n  * Target platforms now .NET 4.5, selected portable subsets and .NET Core.\n  * legacy_enum_values option is no longer supported.\n\n2016-07-15 version 3.0.0-beta-4 (C++/Java/Python/Ruby/Objective-C/C#/JavaScript)\n  General\n  * Added a deterministic serialization API for C++. The deterministic\n    serialization guarantees that given a binary, equal messages will be\n    serialized to the same bytes. This allows applications like MapReduce to\n    group equal messages based on the serialized bytes. The deterministic\n    serialization is, however, NOT canonical across languages; it is also\n    unstable across different builds with schema changes due to unknown fields.\n    Users who need canonical serialization, e.g. persistent storage in a\n    canonical form, fingerprinting, etc, should define their own\n    canonicalization specification and implement the serializer using reflection\n    APIs rather than relying on this API.\n  * Added OneofOptions. You can now define custom options for oneof groups.\n      import \"google/protobuf/descriptor.proto\";\n      extend google.protobuf.OneofOptions {\n        optional int32 my_oneof_extension = 12345;\n      }\n      message Foo {\n        oneof oneof_group {\n          (my_oneof_extension) = 54321;\n          ...\n        }\n      }\n\n  C++ (beta)\n  * Introduced a deterministic serialization API in\n    CodedOutputStream::SetSerializationDeterministic(bool). See the notes about\n    deterministic serialization in the General section.\n  * Added google::protobuf::Map::swap() to swap two map fields.\n  * Fixed a memory leak when calling Reflection::ReleaseMessage() on a message\n    allocated on arena.\n  * Improved error reporting when parsing text format protos.\n  * JSON\n      - Added a new parser option to ignore unknown fields when parsing JSON.\n      - Added convenient methods for message to/from JSON conversion.\n  * Various performance optimizations.\n\n  Java (beta)\n  * File option \"java_generate_equals_and_hash\" is now deprecated. equals() and\n    hashCode() methods are generated by default.\n  * Added a new JSON printer option \"omittingInsignificantWhitespace\" to produce\n    a more compact JSON output. The printer will pretty-print by default.\n  * Updated Java runtime to be compatible with 2.5.0/2.6.1 generated protos.\n\n  Python (beta)\n  * Added support to pretty print Any messages in text format.\n  * Added a flag to ignore unknown fields when parsing JSON.\n  * Bugfix: \"@type\" field of a JSON Any message is now correctly put before\n    other fields.\n\n  Objective-C (beta)\n  * Updated the code to support compiling with more compiler warnings\n    enabled. (Issue 1616)\n  * Exposing more detailed errors for parsing failures. (PR 1623)\n  * Small (breaking) change to the naming of some methods on the support classes\n    for map<>. There were collisions with the system provided KVO support, so\n    the names were changed to avoid those issues.  (PR 1699)\n  * Fixed for proper Swift bridging of error handling during parsing. (PR 1712)\n  * Complete support for generating sources that will go into a Framework and\n    depend on generated sources from other Frameworks. (Issue 1457)\n\n  C# (beta)\n  * RepeatedField optimizations.\n  * Support for .NET Core.\n  * Minor bug fixes.\n  * Ability to format a single value in JsonFormatter (advanced usage only).\n  * Modifications to attributes applied to generated code.\n\n  Javascript (alpha)\n  * Maps now have a real map API instead of being treated as repeated fields.\n  * Well-known types are now provided in the google-protobuf package, and the\n    code generator knows to require() them from that package.\n  * Bugfix: non-canonical varints are correctly decoded.\n\n  Ruby (alpha)\n  * Accessors for oneof fields now return default values instead of nil.\n\n  Java Lite\n  * Java lite support is removed from protocol compiler. It will be supported\n    as a protocol compiler plugin in a separate code branch.\n\n2016-05-16 version 3.0.0-beta-3 (C++/Java/Python/Ruby/Nano/Objective-C/C#/JavaScript)\n  General\n  * Supported Proto3 lite-runtime in C++/Java for mobile platforms.\n  * Any type now supports APIs to specify prefixes other than\n    type.googleapis.com\n  * Removed javanano_use_deprecated_package option; Nano will always has its own\n    \".nano\" package.\n\n  C++ (Beta)\n  * Improved hash maps.\n      - Improved hash maps comments. In particular, please note that equal hash\n        maps will not necessarily have the same iteration order and\n        serialization.\n      - Added a new hash maps implementation that will become the default in a\n        later release.\n  * Arenas\n      - Several inlined methods in Arena were moved to out-of-line to improve\n        build performance and code size.\n      - Added SpaceAllocatedAndUsed() to report both space used and allocated\n      - Added convenient class UnsafeArenaAllocatedRepeatedPtrFieldBackInserter\n  * Any\n      - Allow custom type URL prefixes in Any packing.\n      - TextFormat now expand the Any type rather than printing bytes.\n  * Performance optimizations and various bug fixes.\n\n  Java (Beta)\n  * Introduced an ExperimentalApi annotation. Annotated APIs are experimental\n    and are subject to change in a backward incompatible way in future releases.\n  * Introduced zero-copy serialization as an ExperimentalApi\n      - Introduction of the `ByteOutput` interface. This is similar to\n        `OutputStream` but provides semantics for lazy writing (i.e. no\n        immediate copy required) of fields that are considered to be immutable.\n      - `ByteString` now supports writing to a `ByteOutput`, which will directly\n        expose the internals of the `ByteString` (i.e. `byte[]` or `ByteBuffer`)\n        to the `ByteOutput` without copying.\n      - `CodedOutputStream` now supports writing to a `ByteOutput`. `ByteString`\n        instances that are too large to fit in the internal buffer will be\n        (lazily) written to the `ByteOutput` directly.\n      - This allows applications using large `ByteString` fields to avoid\n        duplication of these fields entirely. Such an application can supply a\n        `ByteOutput` that chains together the chunks received from\n        `CodedOutputStream` before forwarding them onto the IO system.\n  * Other related changes to `CodedOutputStream`\n      - Additional use of `sun.misc.Unsafe` where possible to perform fast\n        access to `byte[]` and `ByteBuffer` values and avoiding unnecessary\n        range checking.\n      - `ByteBuffer`-backed `CodedOutputStream` now writes directly to the\n        `ByteBuffer` rather than to an intermediate array.\n  * Improved lite-runtime.\n      - Lite protos now implement deep equals/hashCode/toString\n      - Significantly improved the performance of Builder#mergeFrom() and\n        Builder#mergeDelimitedFrom()\n  * Various bug fixes and small feature enhancement.\n      - Fixed stack overflow when in hashCode() for infinite recursive oneofs.\n      - Fixed the lazy field parsing in lite to merge rather than overwrite.\n      - TextFormat now supports reporting line/column numbers on errors.\n      - Updated to add appropriate @Override for better compiler errors.\n\n  Python (Beta)\n  * Added JSON format for Any, Struct, Value and ListValue\n  * [ ] is now accepted for both repeated scalar fields and repeated message\n    fields in text format parser.\n  * Numerical field name is now supported in text format.\n  * Added DiscardUnknownFields API for python protobuf message.\n\n  Objective-C (Beta)\n  * Proto comments now come over as HeaderDoc comments in the generated sources\n    so Xcode can pick them up and display them.\n  * The library headers have been updated to use HeaderDoc comments so Xcode can\n    pick them up and display them.\n  * The per message and per field overhead in both generated code and runtime\n    object sizes was reduced.\n  * Generated code now include deprecated annotations when the proto file\n    included them.\n\n  C# (Beta)\n  In general: some changes are breaking, which require regenerating messages.\n  Most user-written code will not be impacted *except* for the renaming of enum\n  values.\n\n  * Allow custom type URL prefixes in `Any` packing, and ignore them when\n    unpacking\n  * `protoc` is now in a separate NuGet package (Google.Protobuf.Tools)\n  * New option: `internal_access` to generate internal classes\n  * Enum values are now PascalCased, and if there's a prefix which matches the\n    name of the enum, that is removed (so an enum `COLOR` with a value\n    `COLOR_BLUE` would generate a value of just `Blue`). An option\n    (`legacy_enum_values`) is temporarily available to disable this, but the\n    option will be removed for GA.\n  * `json_name` option is now honored\n  * If group tags are encountered when parsing, they are validated more\n    thoroughly (although we don't support actual groups)\n  * NuGet dependencies are better specified\n  * Breaking: `Preconditions` is renamed to `ProtoPreconditions`\n  * Breaking: `GeneratedCodeInfo` is renamed to `GeneratedClrTypeInfo`\n  * `JsonFormatter` now allows writing to a `TextWriter`\n  * New interface, `ICustomDiagnosticMessage` to allow more compact\n    representations from `ToString`\n  * `CodedInputStream` and `CodedOutputStream` now implement `IDisposable`,\n    which simply disposes of the streams they were constructed with\n  * Map fields no longer support null values (in line with other languages)\n  * Improvements in JSON formatting and parsing\n\n  Javascript (Alpha)\n  * Better support for \"bytes\" fields: bytes fields can be read as either a\n    base64 string or UInt8Array (in environments where TypedArray is supported).\n  * New support for CommonJS imports.  This should make it easier to use the\n    JavaScript support in Node.js and tools like WebPack.  See js/README.md for\n    more information.\n  * Some significant internal refactoring to simplify and modularize the code.\n\n  Ruby (Alpha)\n  * JSON serialization now properly uses camelCased names, with a runtime option\n    that will preserve original names from .proto files instead.\n  * Well-known types are now included in the distribution.\n  * Release now includes binary gems for Windows, Mac, and Linux instead of just\n    source gems.\n  * Bugfix for serializing oneofs.\n\n  C++/Java Lite (Alpha)\n    A new \"lite\" generator parameter was introduced in the protoc for C++ and\n    Java for Proto3 syntax messages. Example usage:\n\n     ./protoc --cpp_out=lite:$OUTPUT_PATH foo.proto\n\n    The protoc will treat the current input and all the transitive dependencies\n    as LITE. The same generator parameter must be used to generate the\n    dependencies.\n\n    In Proto3 syntax files, \"optimized_for=LITE_RUNTIME\" is no longer supported.\n\n\n2015-12-30 version 3.0.0-beta-2 (C++/Java/Python/Ruby/Nano/Objective-C/C#/JavaScript)\n  General\n  * Introduced a new language implementation: JavaScript.\n  * Added a new field option \"json_name\". By default proto field names are\n    converted to \"lowerCamelCase\" in proto3 JSON format. This option can be\n    used to override this behavior and specify a different JSON name for the\n    field.\n  * Added conformance tests to ensure implementations are following proto3 JSON\n    specification.\n\n  C++ (Beta)\n  * Various bug fixes and improvements to the JSON support utility:\n      - Duplicate map keys in JSON are now rejected (i.e., translation will\n        fail).\n      - Fixed wire-format for google.protobuf.Value/ListValue.\n      - Fixed precision loss when converting google.protobuf.Timestamp.\n      - Fixed a bug when parsing invalid UTF-8 code points.\n      - Fixed a memory leak.\n      - Reduced call stack usage.\n\n  Java (Beta)\n  * Cleaned up some unused methods on CodedOutputStream.\n  * Presized lists for packed fields during parsing in the lite runtime to\n    reduce allocations and improve performance.\n  * Improved the performance of unknown fields in the lite runtime.\n  * Introduced UnsafeByteStrings to support zero-copy ByteString creation.\n  * Various bug fixes and improvements to the JSON support utility:\n      - Fixed a thread-safety bug.\n      - Added a new option \u201cpreservingProtoFieldNames\u201d to JsonFormat.\n      - Added a new option \u201cincludingDefaultValueFields\u201d to JsonFormat.\n      - Updated the JSON utility to comply with proto3 JSON specification.\n\n  Python (Beta)\n  * Added proto3 JSON format utility. It includes support for all field types\n    and a few well-known types except for Any and Struct.\n  * Added runtime support for Any, Timestamp, Duration and FieldMask.\n  * [ ] is now accepted for repeated scalar fields in text format parser.\n  * Map fields now have proper O(1) performance for lookup/insert/delete\n    when using the Python/C++ implementation. They were previously using O(n)\n    search-based algorithms because the C++ reflection interface didn't\n    support true map operations.\n\n  Objective-C (Beta)\n  * Various bug-fixes and code tweaks to pass more strict compiler warnings.\n  * Now has conformance test coverage and is passing all tests.\n\n  C# (Beta)\n  * Various bug-fixes.\n  * Code generation: Files generated in directories based on namespace.\n  * Code generation: Include comments from .proto files in XML doc\n    comments (naively)\n  * Code generation: Change organization/naming of \"reflection class\" (access\n    to file descriptor)\n  * Code generation and library: Add Parser property to MessageDescriptor,\n    and introduce a non-generic parser type.\n  * Library: Added TypeRegistry to support JSON parsing/formatting of Any.\n  * Library: Added Any.Pack/Unpack support.\n  * Library: Implemented JSON parsing.\n\n  Javascript (Alpha)\n  * Added proto3 support for JavaScript. The runtime is written in pure\n    JavaScript and works in browsers and in Node.js. To generate JavaScript\n    code for your proto, invoke protoc with \"--js_out\". See js/README.md\n    for more build instructions.\n\n2015-08-26 version 3.0.0-beta-1 (C++/Java/Python/Ruby/Nano/Objective-C/C#)\n  About Beta\n  * This is the first beta release of protobuf v3.0.0. Not all languages\n    have reached beta stage. Languages not marked as beta are still in\n    alpha (i.e., be prepared for API breaking changes).\n\n  General\n  * Proto3 JSON is supported in several languages (fully supported in C++\n    and Java, partially supported in Ruby/C#). The JSON spec is defined in\n    the proto3 language guide:\n\n      https://developers.google.com/protocol-buffers/docs/proto3#json\n\n    We will publish a more detailed spec to define the exact behavior of\n    proto3-conformant JSON serializers and parsers. Until then, do not rely\n    on specific behaviors of the implementation if it\u2019s not documented in\n    the above spec. More specifically, the behavior is not yet finalized for\n    the following:\n      - Parsing invalid JSON input (e.g., input with trailing commas).\n      - Non-camelCase names in JSON input.\n      - The same field appears multiple times in JSON input.\n      - JSON arrays contain \u201cnull\u201d values.\n      - The message has unknown fields.\n\n  * Proto3 now enforces strict UTF-8 checking. Parsing will fail if a string\n    field contains non UTF-8 data.\n\n  C++ (Beta)\n  * Introduced new utility functions/classes in the google/protobuf/util\n    directory:\n      - MessageDifferencer: compare two proto messages and report their\n                            differences.\n      - JsonUtil: support converting protobuf binary format to/from JSON.\n      - TimeUtil: utility functions to work with well-known types Timestamp\n                  and Duration.\n      - FieldMaskUtil: utility functions to work with FieldMask.\n\n  * Performance optimization of arena construction and destruction.\n  * Bug fixes for arena and maps support.\n  * Changed to use cmake for Windows Visual Studio builds.\n  * Added Bazel support.\n\n  Java (Beta)\n  * Introduced a new util package that will be distributed as a separate\n    artifact in maven. It contains:\n      - JsonFormat: convert proto messages to/from JSON.\n      - TimeUtil: utility functions to work with Timestamp and Duration.\n      - FieldMaskUtil: utility functions to work with FieldMask.\n\n  * The static PARSER in each generated message is deprecated, and it will\n    be removed in a future release. A static parser() getter is generated\n    for each message type instead.\n  * Performance optimizations for String fields serialization.\n  * Performance optimizations for Lite runtime on Android:\n      - Reduced allocations\n      - Reduced method overhead after ProGuarding\n      - Reduced code size after ProGuarding\n\n  Python (Alpha)\n  * Removed legacy Python 2.5 support.\n  * Moved to a single Python 2.x/3.x-compatible codebase, instead of using 2to3.\n  * Fixed build/tests on Python 2.6, 2.7, 3.3, and 3.4.\n      - Pure-Python works on all four.\n      - Python/C++ implementation works on all but 3.4, due to changes in the\n        Python/C++ API in 3.4.\n  * Some preliminary work has been done to allow for multiple DescriptorPools\n    with Python/C++.\n\n  Ruby (Alpha)\n  * Many bugfixes:\n      - fixed parsing/serialization of bytes, sint, sfixed types\n      - other parser bugfixes\n      - fixed memory leak affecting Ruby 2.2\n\n  JavaNano (Alpha)\n  * JavaNano generated code now will be put in a nano package by default to\n    avoid conflicts with Java generated code.\n\n  Objective-C (Alpha)\n  * Added non-null markup to ObjC library. Requires SDK 8.4+ to build.\n  * Many bugfixes:\n      - Removed the class/enum filter.\n      - Renamed some internal types to avoid conflicts with the well-known types\n        protos.\n      - Added missing support for parsing repeated primitive fields in packed or\n        unpacked forms.\n      - Added *Count for repeated and map<> fields to avoid auto-create when\n        checking for them being set.\n\n  C# (Alpha)\n  * Namespace changed to Google.Protobuf (and NuGet package will be named\n    correspondingly).\n  * Target platforms now .NET 4.5 and selected portable subsets only.\n  * Removed lite runtime.\n  * Reimplementation to use mutable message types.\n  * Null references used to represent \"no value\" for message type fields.\n  * Proto3 semantics supported; proto2 files are prohibited for C# codegen.\n    Most proto3 features supported:\n      - JSON formatting (a.k.a. serialization to JSON), including well-known\n        types (except for Any).\n      - Wrapper types mapped to nullable value types (or string/ByteString\n        allowing nullability). JSON parsing is not supported yet.\n      - maps\n      - oneof\n      - enum unknown value preservation\n\n2015-05-25 version 3.0.0-alpha-3 (Objective-C/C#):\n  General\n  * Introduced two new language implementations (Objective-C, C#) to proto3.\n  * Explicit \"optional\" keyword are disallowed in proto3 syntax, as fields are\n    optional by default.\n  * Group fields are no longer supported in proto3 syntax.\n  * Changed repeated primitive fields to use packed serialization by default in\n    proto3 (implemented for C++, Java, Python in this release).  The user can\n    still disable packed serialization by setting packed to false for now.\n  * Added well-known type protos (any.proto, empty.proto, timestamp.proto,\n    duration.proto, etc.). Users can import and use these protos just like\n    regular proto files. Additional runtime support will be added for them in\n    future releases (in the form of utility helper functions, or having them\n    replaced by language specific types in generated code).\n  * Added a \"reserved\" keyword in both proto2 and proto3 syntax. User can use\n    this keyword to declare reserved field numbers and names to prevent them\n    from being reused by other fields in the same message.\n\n    To reserve field numbers, add a reserved declaration in your message:\n\n      message TestMessage {\n        reserved 2, 15, 9 to 11, 3;\n      }\n\n    This reserves field numbers 2, 3, 9, 10, 11 and 15. If a user uses any of\n    these as field numbers, the protocol buffer compiler will report an error.\n\n    Field names can also be reserved:\n\n      message TestMessage {\n        reserved \"foo\", \"bar\";\n      }\n\n  * Various bug fixes since 3.0.0-alpha-2\n\n  Objective-C\n    Objective-C includes a code generator and a native objective-c runtime\n    library.  By adding \u201c--objc_out\u201d to protoc, the code generator will generate\n    a header(*.pbobjc.h) and an implementation file(*.pbobjc.m) for each proto\n    file.\n\n    In this first release, the generated interface provides: enums, messages,\n    field support(single, repeated, map, oneof), proto2 and proto3 syntax\n    support, parsing and serialization. It\u2019s  compatible with ARC and non-ARC\n    usage. Besides, user can also access it via the swift bridging header.\n\n    See objectivec/README.md for details.\n\n  C#\n    * C# protobufs are based on project\n      https://github.com/jskeet/protobuf-csharp-port. The original project was\n      frozen and all the new development will happen here.\n    * Codegen plugin for C# was completely rewritten to C++ and is now an\n      integral part of protoc.\n    * Some refactorings and cleanup has been applied to the C# runtime library.\n    * Only proto2 is supported in C# at the moment, proto3 support is in\n      progress and will likely bring significant breaking changes to the API.\n\n    See csharp/README.md for details.\n\n  C++\n    * Added runtime support for Any type. To use Any in your proto file, first\n      import the definition of Any:\n\n        // foo.proto\n        import \"google/protobuf/any.proto\";\n        message Foo {\n          google.protobuf.Any any_field = 1;\n        }\n        message Bar {\n          int32 value = 1;\n        }\n\n      Then in C++ you can access the Any field using PackFrom()/UnpackTo()\n      methods:\n\n        Foo foo;\n        Bar bar = ...;\n        foo.mutable_any_field()->PackFrom(bar);\n        ...\n        if (foo.any_field().IsType<Bar>()) {\n          foo.any_field().UnpackTo(&bar);\n          ...\n        }\n    * In text format, entries of a map field will be sorted by key.\n\n  Java\n    * Continued optimizations on the lite runtime to improve performance for\n      Android.\n\n  Python\n    * Added map support.\n      - maps now have a dict-like interface (msg.map_field[key] = value)\n      - existing code that modifies maps via the repeated field interface\n        will need to be updated.\n\n  Ruby\n    * Improvements to RepeatedField's emulation of the Ruby Array API.\n    * Various speedups and internal cleanups.\n\n2015-02-26 version 3.0.0-alpha-2 (Python/Ruby/JavaNano):\n  General\n  * Introduced three new language implementations (Ruby, JavaNano, and\n    Python) to proto3.\n  * Various bug fixes since 3.0.0-alpha-1\n\n  Python:\n    Python has received several updates, most notably support for proto3\n    semantics in any .proto file that declares syntax=\"proto3\".\n    Messages declared in proto3 files no longer represent field presence\n    for scalar fields (number, enums, booleans, or strings).  You can\n    no longer call HasField() for such fields, and they are serialized\n    based on whether they have a non-zero/empty/false value.\n\n    One other notable change is in the C++-accelerated implementation.\n    Descriptor objects (which describe the protobuf schema and allow\n    reflection over it) are no longer duplicated between the Python\n    and C++ layers.  The Python descriptors are now simple wrappers\n    around the C++ descriptors.  This change should significantly\n    reduce the memory usage of programs that use a lot of message\n    types.\n\n  Ruby:\n    We have added proto3 support for Ruby via a native C extension.\n\n    The Ruby extension itself is included in the ruby/ directory, and details on\n    building and installing the extension are in ruby/README.md. The extension\n    will also be published as a Ruby gem. Code generator support is included as\n    part of `protoc` with the `--ruby_out` flag.\n\n    The Ruby extension implements a user-friendly DSL to define message types\n    (also generated by the code generator from `.proto` files).  Once a message\n    type is defined, the user may create instances of the message that behave in\n    ways idiomatic to Ruby. For example:\n\n    - Message fields are present as ordinary Ruby properties (getter method\n      `foo` and setter method `foo=`).\n    - Repeated field elements are stored in a container that acts like a native\n      Ruby array, and map elements are stored in a container that acts like a\n      native Ruby hashmap.\n    - The usual well-known methods, such as `#to_s`, `#dup`, and the like, are\n      present.\n\n    Unlike several existing third-party Ruby extensions for protobuf, this\n    extension is built on a \"strongly-typed\" philosophy: message fields and\n    array/map containers will throw exceptions eagerly when values of the\n    incorrect type are inserted.\n\n    See ruby/README.md for details.\n\n  JavaNano:\n    JavaNano is a special code generator and runtime library designed especially\n    for resource-restricted systems, like Android. It is very resource-friendly\n    in both the amount of code and the runtime overhead. Here is an an overview\n    of JavaNano features compared with the official Java protobuf:\n\n    - No descriptors or message builders.\n    - All messages are mutable; fields are public Java fields.\n    - For optional fields only, encapsulation behind setter/getter/hazzer/\n      clearer functions is opt-in, which provide proper 'has' state support.\n    - For proto2, if not opted in, has state (field presence) is not available.\n      Serialization outputs all fields not equal to their defaults.\n      The behavior is consistent with proto3 semantics.\n    - Required fields (proto2 only) are always serialized.\n    - Enum constants are integers; protection against invalid values only\n      when parsing from the wire.\n    - Enum constants can be generated into container interfaces bearing\n      the enum's name (so the referencing code is in Java style).\n    - CodedInputByteBufferNano can only take byte[] (not InputStream).\n    - Similarly CodedOutputByteBufferNano can only write to byte[].\n    - Repeated fields are in arrays, not ArrayList or Vector. Null array\n      elements are allowed and silently ignored.\n    - Full support for serializing/deserializing repeated packed fields.\n    - Support  extensions (in proto2).\n    - Unset messages/groups are null, not an immutable empty default\n      instance.\n    - toByteArray(...) and mergeFrom(...) are now static functions of\n      MessageNano.\n    - The 'bytes' type translates to the Java type byte[].\n\n    See javanano/README.txt for details.\n\n2014-12-01 version 3.0.0-alpha-1 (C++/Java):\n\n  General\n  * Introduced Protocol Buffers language version 3 (aka proto3).\n\n    When protobuf was initially opensourced it implemented Protocol Buffers\n    language version 2 (aka proto2), which is why the version number\n    started from v2.0.0. From v3.0.0, a new language version (proto3) is\n    introduced while the old version (proto2) will continue to be supported.\n\n    The main intent of introducing proto3 is to clean up protobuf before\n    pushing the language as the foundation of Google's new API platform.\n    In proto3, the language is simplified, both for ease of use and  to\n    make it available in a wider range of programming languages. At the\n    same time a few features are added to better support common idioms\n    found in APIs.\n\n    The following are the main new features in language version 3:\n\n      1. Removal of field presence logic for primitive value fields, removal\n         of required fields, and removal of default values. This makes proto3\n         significantly easier to implement with open struct representations,\n         as in languages like Android Java, Objective C, or Go.\n      2. Removal of unknown fields.\n      3. Removal of extensions, which are instead replaced by a new standard\n         type called Any.\n      4. Fix semantics for unknown enum values.\n      5. Addition of maps.\n      6. Addition of a small set of standard types for representation of time,\n         dynamic data, etc.\n      7. A well-defined encoding in JSON as an alternative to binary proto\n         encoding.\n\n    This release (v3.0.0-alpha-1) includes partial proto3 support for C++ and\n    Java. Items 6 (well-known types) and 7 (JSON format) in the above feature\n    list are not implemented.\n\n    A new notion \"syntax\" is introduced to specify whether a .proto file\n    uses proto2 or proto3:\n\n      // foo.proto\n      syntax = \"proto3\";\n      message Bar {...}\n\n    If omitted, the protocol compiler will generate a warning and \"proto2\" will\n    be used as the default. This warning will be turned into an error in a\n    future release.\n\n    We recommend that new Protocol Buffers users use proto3. However, we do not\n    generally recommend that existing users migrate from proto2 from proto3 due\n    to API incompatibility, and we will continue to support proto2 for a long\n    time.\n\n  * Added support for map fields (implemented in C++/Java for both proto2 and\n    proto3).\n\n    Map fields can be declared using the following syntax:\n\n      message Foo {\n        map<string, string> values = 1;\n      }\n\n    Data of a map field will be stored in memory as an unordered map and it\n    can be accessed through generated accessors.\n\n  C++\n  * Added arena allocation support (for both proto2 and proto3).\n\n    Profiling shows memory allocation and deallocation constitutes a significant\n    fraction of CPU-time spent in protobuf code and arena allocation is a\n    technique introduced to reduce this cost. With arena allocation, new\n    objects will be allocated from a large piece of preallocated memory and\n    deallocation of these objects is almost free. Early adoption shows 20% to\n    50% improvement in some Google binaries.\n\n    To enable arena support, add the following option to your .proto file:\n\n      option cc_enable_arenas = true;\n\n    Protocol compiler will generate additional code to make the generated\n    message classes work with arenas. This does not change the existing API\n    of protobuf messages and does not affect wire format. Your existing code\n    should continue to work after adding this option. In the future we will\n    make this option enabled by default.\n\n    To actually take advantage of arena allocation, you need to use the arena\n    APIs when creating messages. A quick example of using the arena API:\n\n      {\n        google::protobuf::Arena arena;\n        // Allocate a protobuf message in the arena.\n        MyMessage* message = Arena::CreateMessage<MyMessage>(&arena);\n        // All submessages will be allocated in the same arena.\n        if (!message->ParseFromString(data)) {\n          // Deal with malformed input data.\n        }\n        // Must not delete the message here. It will be deleted automatically\n        // when the arena is destroyed.\n      }\n\n    Currently arena does not work with map fields. Enabling arena in a .proto\n    file containing map fields will result in compile errors in the generated\n    code. This will be addressed in a future release.\n\n2014-10-20 version 2.6.1:\n\n  C++\n  * Added atomicops support for Solaris.\n  * Released memory allocated by InitializeDefaultRepeatedFields() and\n    GetEmptyString(). Some memory sanitizers reported them as memory leaks.\n\n  Java\n  * Updated DynamicMessage.setField() to handle repeated enum values\n    correctly.\n  * Fixed a bug that caused NullPointerException to be thrown when\n    converting manually constructed FileDescriptorProto to\n    FileDescriptor.\n\n  Python\n  * Fixed WhichOneof() to work with de-serialized protobuf messages.\n  * Fixed a missing file problem of Python C++ implementation.\n\n2014-08-15 version 2.6.0:\n\n  General\n  * Added oneofs(unions) feature. Fields in the same oneof will share\n    memory and at most one field can be set at the same time. Use the\n    oneof keyword to define a oneof like:\n      message SampleMessage {\n        oneof test_oneof {\n          string name = 4;\n          YourMessage sub_message = 9;\n        }\n      }\n  * Files, services, enums, messages, methods and enum values can be marked\n    as deprecated now.\n  * Added Support for list values, including lists of messages, when\n    parsing text-formatted protos in C++ and Java.\n      For example:  foo: [1, 2, 3]\n\n  C++\n  * Enhanced customization on TestFormat printing.\n  * Added SwapFields() in reflection API to swap a subset of fields.\n    Added SetAllocatedMessage() in reflection API.\n  * Repeated primitive extensions are now packable. The\n    [packed=true] option only affects serializers. Therefore, it is\n    possible to switch a repeated extension field to packed format\n    without breaking backwards-compatibility.\n  * Various speed optimizations.\n\n  Java\n  * writeTo() method in ByteString can now write a substring to an\n    output stream. Added endWith() method for ByteString.\n  * ByteString and ByteBuffer are now supported in CodedInputStream\n    and CodedOutputStream.\n  * java_generate_equals_and_hash can now be used with the LITE_RUNTIME.\n\n  Python\n  * A new C++-backed extension module (aka \"cpp api v2\") that replaces the\n    old (\"cpp api v1\") one.  Much faster than the pure Python code.  This one\n    resolves many bugs and is recommended for general use over the\n    pure Python when possible.\n  * Descriptors now have enum_types_by_name and extension_types_by_name dict\n    attributes.\n  * Support for Python 3.\n\n2013-02-27 version 2.5.0:\n\n  General\n  * New notion \"import public\" that allows a proto file to forward the content\n    it imports to its importers. For example,\n      // foo.proto\n      import public \"bar.proto\";\n      import \"baz.proto\";\n\n      // qux.proto\n      import \"foo.proto\";\n      // Stuff defined in bar.proto may be used in this file, but stuff from\n      // baz.proto may NOT be used without importing it explicitly.\n    This is useful for moving proto files. To move a proto file, just leave\n    a single \"import public\" in the old proto file.\n  * New enum option \"allow_alias\" that specifies whether different symbols can\n    be assigned the same numeric value. Default value is \"true\". Setting it to\n    false causes the compiler to reject enum definitions where multiple symbols\n    have the same numeric value.\n    Note: We plan to flip the default value to \"false\" in a future release.\n    Projects using enum aliases should set the option to \"true\" in their .proto\n    files.\n\n  C++\n  * New generated method set_allocated_foo(Type* foo) for message and string\n    fields. This method allows you to set the field to a pre-allocated object\n    and the containing message takes the ownership of that object.\n  * Added SetAllocatedExtension() and ReleaseExtension() to extensions API.\n  * Custom options are now formatted correctly when descriptors are printed in\n    text format.\n  * Various speed optimizations.\n\n  Java\n  * Comments in proto files are now collected and put into generated code as\n    comments for corresponding classes and data members.\n  * Added Parser to parse directly into messages without a Builder. For\n    example,\n      Foo foo = Foo.PARSER.ParseFrom(input);\n    Using Parser is ~25% faster than using Builder to parse messages.\n  * Added getters/setters to access the underlying ByteString of a string field\n    directly.\n  * ByteString now supports more operations: substring(), prepend(), and\n    append(). The implementation of ByteString uses a binary tree structure\n    to support these operations efficiently.\n  * New method findInitializationErrors() that lists all missing required\n    fields.\n  * Various code size and speed optimizations.\n\n  Python\n  * Added support for dynamic message creation. DescriptorDatabase,\n    DescriptorPool, and MessageFactory work like their C++ counterparts to\n    simplify Descriptor construction from *DescriptorProtos, and MessageFactory\n    provides a message instance from a Descriptor.\n  * Added pickle support for protobuf messages.\n  * Unknown fields are now preserved after parsing.\n  * Fixed bug where custom options were not correctly populated. Custom\n    options can be accessed now.\n  * Added EnumTypeWrapper that provides better accessibility to enum types.\n  * Added ParseMessage(descriptor, bytes) to generate a new Message instance\n    from a descriptor and a byte string.\n\n2011-05-01 version 2.4.1:\n\n  C++\n  * Fixed the friendship problem for old compilers to make the library now gcc 3\n    compatible again.\n  * Fixed vcprojects/extract_includes.bat to extract compiler/plugin.h.\n\n  Java\n  * Removed usages of JDK 1.6 only features to make the library now JDK 1.5\n    compatible again.\n  * Fixed a bug about negative enum values.\n  * serialVersionUID is now defined in generated messages for java serializing.\n  * Fixed protoc to use java.lang.Object, which makes \"Object\" now a valid\n    message name again.\n\n  Python\n  * Experimental C++ implementation now requires C++ protobuf library installed.\n    See the README.txt in the python directory for details.\n\n2011-02-02 version 2.4.0:\n\n  General\n  * The RPC (cc|java|py)_generic_services default value is now false instead of\n    true.\n  * Custom options can have aggregate types. For example,\n      message MyOption {\n        optional string comment = 1;\n        optional string author = 2;\n      }\n      extend google.protobuf.FieldOptions {\n        optional MyOption myoption = 12345;\n      }\n    This option can now be set as follows:\n      message SomeType {\n        optional int32 field = 1 [(myoption) = { comment:'x' author:'y' }];\n      }\n\n  C++\n  * Various speed and code size optimizations.\n  * Added a release_foo() method on string and message fields.\n  * Fixed gzip_output_stream sub-stream handling.\n\n  Java\n  * Builders now maintain sub-builders for sub-messages. Use getFooBuilder() to\n    get the builder for the sub-message \"foo\". This allows you to repeatedly\n    modify deeply-nested sub-messages without rebuilding them.\n  * Builder.build() no longer invalidates the Builder for generated messages\n    (You may continue to modify it and then build another message).\n  * Code generator will generate efficient equals() and hashCode()\n    implementations if new option java_generate_equals_and_hash is enabled.\n    (Otherwise, reflection-based implementations are used.)\n  * Generated messages now implement Serializable.\n  * Fields with [deprecated=true] will be marked with @Deprecated in Java.\n  * Added lazy conversion of UTF-8 encoded strings to String objects to improve\n    performance.\n  * Various optimizations.\n  * Enum value can be accessed directly, instead of calling getNumber() on the\n    enum member.\n  * For each enum value, an integer constant is also generated with the suffix\n    _VALUE.\n\n  Python\n  * Added an experimental  C++ implementation for Python messages via a Python\n    extension. Implementation type is controlled by an environment variable\n    PROTOCOL_BUFFERS_PYTHON_IMPLEMENTATION (valid values: \"cpp\" and \"python\")\n    The default value is currently \"python\" but will be changed to \"cpp\" in\n    future release.\n  * Improved performance on message instantiation significantly.\n    Most of the work on message instantiation is done just once per message\n    class, instead of once per message instance.\n  * Improved performance on text message parsing.\n  * Allow add() to forward keyword arguments to the concrete class.\n      E.g. instead of\n        item = repeated_field.add()\n        item.foo = bar\n        item.baz = quux\n      You can do:\n        repeated_field.add(foo=bar, baz=quux)\n  * Added a sort() interface to the BaseContainer.\n  * Added an extend() method to repeated composite fields.\n  * Added UTF8 debug string support.\n\n2010-01-08 version 2.3.0:\n\n  General\n  * Parsers for repeated numeric fields now always accept both packed and\n    unpacked input.  The [packed=true] option only affects serializers.\n    Therefore, it is possible to switch a field to packed format without\n    breaking backwards-compatibility -- as long as all parties are using\n    protobuf 2.3.0 or above, at least.\n  * The generic RPC service code generated by the C++, Java, and Python\n    generators can be disabled via file options:\n      option cc_generic_services = false;\n      option java_generic_services = false;\n      option py_generic_services = false;\n    This allows plugins to generate alternative code, possibly specific to some\n    particular RPC implementation.\n\n  protoc\n  * Now supports a plugin system for code generators.  Plugins can generate\n    code for new languages or inject additional code into the output of other\n    code generators.  Plugins are just binaries which accept a protocol buffer\n    on stdin and write a protocol buffer to stdout, so they may be written in\n    any language.  See src/google/protobuf/compiler/plugin.proto.\n    **WARNING**:  Plugins are experimental.  The interface may change in a\n    future version.\n  * If the output location ends in .zip or .jar, protoc will write its output\n    to a zip/jar archive instead of a directory.  For example:\n      protoc --java_out=myproto_srcs.jar --python_out=myproto.zip myproto.proto\n    Currently the archive contents are not compressed, though this could change\n    in the future.\n  * inf, -inf, and nan can now be used as default values for float and double\n    fields.\n\n  C++\n  * Various speed and code size optimizations.\n  * DynamicMessageFactory is now fully thread-safe.\n  * Message::Utf8DebugString() method is like DebugString() but avoids escaping\n    UTF-8 bytes.\n  * Compiled-in message types can now contain dynamic extensions, through use\n    of CodedInputStream::SetExtensionRegistry().\n  * Now compiles shared libraries (DLLs) by default on Cygwin and MinGW, to\n    match other platforms.  Use --disable-shared to avoid this.\n\n  Java\n  * parseDelimitedFrom() and mergeDelimitedFrom() now detect EOF and return\n    false/null instead of throwing an exception.\n  * Fixed some initialization ordering bugs.\n  * Fixes for OpenJDK 7.\n\n  Python\n  * 10-25 times faster than 2.2.0, still pure-Python.\n  * Calling a mutating method on a sub-message always instantiates the message\n    in its parent even if the mutating method doesn't actually mutate anything\n    (e.g. parsing from an empty string).\n  * Expanded descriptors a bit.\n\n2009-08-11 version 2.2.0:\n\n  C++\n  * Lite mode:  The \"optimize_for = LITE_RUNTIME\" option causes the compiler\n    to generate code which only depends libprotobuf-lite, which is much smaller\n    than libprotobuf but lacks descriptors, reflection, and some other features.\n  * Fixed bug where Message.Swap(Message) was only implemented for\n    optimize_for_speed.  Swap now properly implemented in both modes\n    (Issue 91).\n  * Added RemoveLast and SwapElements(index1, index2) to Reflection\n    interface for repeated elements.\n  * Added Swap(Message) to Reflection interface.\n  * Floating-point literals in generated code that are intended to be\n    single-precision now explicitly have 'f' suffix to avoid pedantic warnings\n    produced by some compilers.\n  * The [deprecated=true] option now causes the C++ code generator to generate\n    a GCC-style deprecation annotation (no-op on other compilers).\n  * google::protobuf::GetEnumDescriptor<SomeGeneratedEnumType>() returns the\n    EnumDescriptor for that type -- useful for templates which cannot call\n    SomeGeneratedEnumType_descriptor().\n  * Various optimizations and obscure bug fixes.\n\n  Java\n  * Lite mode:  The \"optimize_for = LITE_RUNTIME\" option causes the compiler\n    to generate code which only depends libprotobuf-lite, which is much smaller\n    than libprotobuf but lacks descriptors, reflection, and some other features.\n  * Lots of style cleanups.\n\n  Python\n  * Fixed endianness bug with floats and doubles.\n  * Text format parsing support.\n  * Fix bug with parsing packed repeated fields in embedded messages.\n  * Ability to initialize fields by passing keyword args to constructor.\n  * Support iterators in extend and __setslice__ for containers.\n\n2009-05-13 version 2.1.0:\n\n  General\n  * Repeated fields of primitive types (types other that string, group, and\n    nested messages) may now use the option [packed = true] to get a more\n    efficient encoding.  In the new encoding, the entire list is written\n    as a single byte blob using the \"length-delimited\" wire type.  Within\n    this blob, the individual values are encoded the same way they would\n    be normally except without a tag before each value (thus, they are\n    tightly \"packed\").\n  * For each field, the generated code contains an integer constant assigned\n    to the field number.  For example, the .proto file:\n      message Foo { optional int bar_baz = 123; }\n    would generate the following constants, all with the integer value 123:\n      C++:     Foo::kBarBazFieldNumber\n      Java:    Foo.BAR_BAZ_FIELD_NUMBER\n      Python:  Foo.BAR_BAZ_FIELD_NUMBER\n    Constants are also generated for extensions, with the same naming scheme.\n    These constants may be used as switch cases.\n  * Updated bundled Google Test to version 1.3.0.  Google Test is now bundled\n    in its verbatim form as a nested autoconf package, so you can drop in any\n    other version of Google Test if needed.\n  * optimize_for = SPEED is now the default, by popular demand.  Use\n    optimize_for = CODE_SIZE if code size is more important in your app.\n  * It is now an error to define a default value for a repeated field.\n    Previously, this was silently ignored (it had no effect on the generated\n    code).\n  * Fields can now be marked deprecated like:\n      optional int32 foo = 1 [deprecated = true];\n    Currently this does not have any actual effect, but in the future the code\n    generators may generate deprecation annotations in each language.\n  * Cross-compiling should now be possible using the --with-protoc option to\n    configure.  See README.txt for more info.\n\n  protoc\n  * --error_format=msvs option causes errors to be printed in Visual Studio\n    format, which should allow them to be clicked on in the build log to go\n    directly to the error location.\n  * The type name resolver will no longer resolve type names to fields.  For\n    example, this now works:\n      message Foo {}\n      message Bar {\n        optional int32 Foo = 1;\n        optional Foo baz = 2;\n      }\n    Previously, the type of \"baz\" would resolve to \"Bar.Foo\", and you'd get\n    an error because Bar.Foo is a field, not a type.  Now the type of \"baz\"\n    resolves to the message type Foo.  This change is unlikely to make a\n    difference to anyone who follows the Protocol Buffers style guide.\n\n  C++\n  * Several optimizations, including but not limited to:\n    - Serialization, especially to flat arrays, is 10%-50% faster, possibly\n      more for small objects.\n    - Several descriptor operations which previously required locking no longer\n      do.\n    - Descriptors are now constructed lazily on first use, rather than at\n      process startup time.  This should save memory in programs which do not\n      use descriptors or reflection.\n    - UnknownFieldSet completely redesigned to be more efficient (especially in\n      terms of memory usage).\n    - Various optimizations to reduce code size (though the serialization speed\n      optimizations increased code size).\n  * Message interface has method ParseFromBoundedZeroCopyStream() which parses\n    a limited number of bytes from an input stream rather than parsing until\n    EOF.\n  * GzipInputStream and GzipOutputStream support reading/writing gzip- or\n    zlib-compressed streams if zlib is available.\n    (google/protobuf/io/gzip_stream.h)\n  * DescriptorPool::FindAllExtensions() and corresponding\n    DescriptorDatabase::FindAllExtensions() can be used to enumerate all\n    extensions of a given type.\n  * For each enum type Foo, protoc will generate functions:\n      const string& Foo_Name(Foo value);\n      bool Foo_Parse(const string& name, Foo* result);\n    The former returns the name of the enum constant corresponding to the given\n    value while the latter finds the value corresponding to a name.\n  * RepeatedField and RepeatedPtrField now have back-insertion iterators.\n  * String fields now have setters that take a char* and a size, in addition\n    to the existing ones that took char* or const string&.\n  * DescriptorPool::AllowUnknownDependencies() may be used to tell\n    DescriptorPool to create placeholder descriptors for unknown entities\n    referenced in a FileDescriptorProto.  This can allow you to parse a .proto\n    file without having access to other .proto files that it imports, for\n    example.\n  * Updated gtest to latest version.  The gtest package is now included as a\n    nested autoconf package, so it should be able to drop new versions into the\n    \"gtest\" subdirectory without modification.\n\n  Java\n  * Fixed bug where Message.mergeFrom(Message) failed to merge extensions.\n  * Message interface has new method toBuilder() which is equivalent to\n    newBuilderForType().mergeFrom(this).\n  * All enums now implement the ProtocolMessageEnum interface.\n  * Setting a field to null now throws NullPointerException.\n  * Fixed tendency for TextFormat's parsing to overflow the stack when\n    parsing large string values.  The underlying problem is with Java's\n    regex implementation (which unfortunately uses recursive backtracking\n    rather than building an NFA).  Worked around by making use of possessive\n    quantifiers.\n  * Generated service classes now also generate pure interfaces.  For a service\n    Foo, Foo.Interface is a pure interface containing all of the service's\n    defined methods.  Foo.newReflectiveService() can be called to wrap an\n    instance of this interface in a class that implements the generic\n    RpcService interface, which provides reflection support that is usually\n    needed by RPC server implementations.\n  * RPC interfaces now support blocking operation in addition to non-blocking.\n    The protocol compiler generates separate blocking and non-blocking stubs\n    which operate against separate blocking and non-blocking RPC interfaces.\n    RPC implementations will have to implement the new interfaces in order to\n    support blocking mode.\n  * New I/O methods parseDelimitedFrom(), mergeDelimitedFrom(), and\n    writeDelimitedTo() read and write \"delimited\" messages from/to a stream,\n    meaning that the message size precedes the data.  This way, you can write\n    multiple messages to a stream without having to worry about delimiting\n    them yourself.\n  * Throw a more descriptive exception when build() is double-called.\n  * Add a method to query whether CodedInputStream is at the end of the input\n    stream.\n  * Add a method to reset a CodedInputStream's size counter; useful when\n    reading many messages with the same stream.\n  * equals() and hashCode() now account for unknown fields.\n\n  Python\n  * Added slicing support for repeated scalar fields. Added slice retrieval and\n    removal of repeated composite fields.\n  * Updated RPC interfaces to allow for blocking operation.  A client may\n    now pass None for a callback when making an RPC, in which case the\n    call will block until the response is received, and the response\n    object will be returned directly to the caller.  This interface change\n    cannot be used in practice until RPC implementations are updated to\n    implement it.\n  * Changes to input_stream.py should make protobuf compatible with appengine.\n\n2008-11-25 version 2.0.3:\n\n  protoc\n  * Enum values may now have custom options, using syntax similar to field\n    options.\n  * Fixed bug where .proto files which use custom options but don't actually\n    define them (i.e. they import another .proto file defining the options)\n    had to explicitly import descriptor.proto.\n  * Adjacent string literals in .proto files will now be concatenated, like in\n    C.\n  * If an input file is a Windows absolute path (e.g. \"C:\\foo\\bar.proto\") and\n    the import path only contains \".\" (or contains \".\" but does not contain\n    the file), protoc incorrectly thought that the file was under \".\", because\n    it thought that the path was relative (since it didn't start with a slash).\n    This has been fixed.\n\n  C++\n  * Generated message classes now have a Swap() method which efficiently swaps\n    the contents of two objects.\n  * All message classes now have a SpaceUsed() method which returns an estimate\n    of the number of bytes of allocated memory currently owned by the object.\n    This is particularly useful when you are reusing a single message object\n    to improve performance but want to make sure it doesn't bloat up too large.\n  * New method Message::SerializeAsString() returns a string containing the\n    serialized data.  May be more convenient than calling\n    SerializeToString(string*).\n  * In debug mode, log error messages when string-type fields are found to\n    contain bytes that are not valid UTF-8.\n  * Fixed bug where a message with multiple extension ranges couldn't parse\n    extensions.\n  * Fixed bug where MergeFrom(const Message&) didn't do anything if invoked on\n    a message that contained no fields (but possibly contained extensions).\n  * Fixed ShortDebugString() to not be O(n^2).  Durr.\n  * Fixed crash in TextFormat parsing if the first token in the input caused a\n    tokenization error.\n  * Fixed obscure bugs in zero_copy_stream_impl.cc.\n  * Added support for HP C++ on Tru64.\n  * Only build tests on \"make check\", not \"make\".\n  * Fixed alignment issue that caused crashes when using DynamicMessage on\n    64-bit Sparc machines.\n  * Simplify template usage to work with MSVC 2003.\n  * Work around GCC 4.3.x x86_64 compiler bug that caused crashes on startup.\n    (This affected Fedora 9 in particular.)\n  * Now works on \"Solaris 10 using recent Sun Studio\".\n\n  Java\n  * New overload of mergeFrom() which parses a slice of a byte array instead\n    of the whole thing.\n  * New method ByteString.asReadOnlyByteBuffer() does what it sounds like.\n  * Improved performance of isInitialized() when optimizing for code size.\n\n  Python\n  * Corrected ListFields() signature in Message base class to match what\n    subclasses actually implement.\n  * Some minor refactoring.\n  * Don't pass self as first argument to superclass constructor (no longer\n    allowed in Python 2.6).\n\n2008-09-29 version 2.0.2:\n\n  General\n  * License changed from Apache 2.0 to 3-Clause BSD.\n  * It is now possible to define custom \"options\", which are basically\n    annotations which may be placed on definitions in a .proto file.\n    For example, you might define a field option called \"foo\" like so:\n      import \"google/protobuf/descriptor.proto\"\n      extend google.protobuf.FieldOptions {\n        optional string foo = 12345;\n      }\n    Then you annotate a field using the \"foo\" option:\n      message MyMessage {\n        optional int32 some_field = 1 [(foo) = \"bar\"]\n      }\n    The value of this option is then visible via the message's\n    Descriptor:\n      const FieldDescriptor* field =\n        MyMessage::descriptor()->FindFieldByName(\"some_field\");\n      assert(field->options().GetExtension(foo) == \"bar\");\n    This feature has been implemented and tested in C++ and Java.\n    Other languages may or may not need to do extra work to support\n    custom options, depending on how they construct descriptors.\n\n  C++\n  * Fixed some GCC warnings that only occur when using -pedantic.\n  * Improved static initialization code, making ordering more\n    predictable among other things.\n  * TextFormat will no longer accept messages which contain multiple\n    instances of a singular field.  Previously, the latter instance\n    would overwrite the former.\n  * Now works on systems that don't have hash_map.\n\n  Java\n  * Print @Override annotation in generated code where appropriate.\n\n  Python\n  * Strings now use the \"unicode\" type rather than the \"str\" type.\n    String fields may still be assigned ASCII \"str\" values; they will\n    automatically be converted.\n  * Adding a property to an object representing a repeated field now\n    raises an exception.  For example:\n      # No longer works (and never should have).\n      message.some_repeated_field.foo = 1\n\n  Windows\n  * We now build static libraries rather than DLLs by default on MSVC.\n    See vsprojects/readme.txt for more information.\n\n2008-08-15 version 2.0.1:\n\n  protoc\n  * New flags --encode and --decode can be used to convert between protobuf text\n    format and binary format from the command-line.\n  * New flag --descriptor_set_out can be used to write FileDescriptorProtos for\n    all parsed files directly into a single output file.  This is particularly\n    useful if you wish to parse .proto files from programs written in languages\n    other than C++: just run protoc as a background process and have it output\n    a FileDescriptorList, then parse that natively.\n  * Improved error message when an enum value's name conflicts with another\n    symbol defined in the enum type's scope, e.g. if two enum types declared\n    in the same scope have values with the same name.  This is disallowed for\n    compatibility with C++, but this wasn't clear from the error.\n  * Fixed absolute output paths on Windows.\n  * Allow trailing slashes in --proto_path mappings.\n\n  C++\n  * Reflection objects are now per-class rather than per-instance.  To make this\n    possible, the Reflection interface had to be changed such that all methods\n    take the Message instance as a parameter.  This change improves performance\n    significantly in memory-bandwidth-limited use cases, since it makes the\n    message objects smaller.  Note that source-incompatible interface changes\n    like this will not be made again after the library leaves beta.\n  * Heuristically detect sub-messages when printing unknown fields.\n  * Fix static initialization ordering bug that caused crashes at startup when\n    compiling on Mac with static linking.\n  * Fixed TokenizerTest when compiling with -DNDEBUG on Linux.\n  * Fixed incorrect definition of kint32min.\n  * Fix bytes type setter to work with byte sequences with embedded NULLs.\n  * Other irrelevant tweaks.\n\n  Java\n  * Fixed UnknownFieldSet's parsing of varints larger than 32 bits.\n  * Fixed TextFormat's parsing of \"inf\" and \"nan\".\n  * Fixed TextFormat's parsing of comments.\n  * Added info to Java POM that will be required when we upload the\n    package to a Maven repo.\n\n  Python\n  * MergeFrom(message) and CopyFrom(message) are now implemented.\n  * SerializeToString() raises an exception if the message is missing required\n    fields.\n  * Code organization improvements.\n  * Fixed doc comments for RpcController and RpcChannel, which had somehow been\n    swapped.\n  * Fixed text_format_test on Windows where floating-point exponents sometimes\n    contain extra zeros.\n  * Fix Python service CallMethod() implementation.\n\n  Other\n  * Improved readmes.\n  * VIM syntax highlighting improvements.\n\n2008-07-07 version 2.0.0:\n\n  * First public release.\n", "// Protocol Buffers - Google's data interchange format\n// Copyright 2008 Google Inc.  All rights reserved.\n// https://developers.google.com/protocol-buffers/\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\npackage com.google.protobuf;\n\nimport com.google.protobuf.Descriptors.Descriptor;\nimport com.google.protobuf.Descriptors.FieldDescriptor;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.TreeMap;\n\n/**\n * Reflection utility methods shared by both mutable and immutable messages.\n *\n * @author liujisi@google.com (Pherl Liu)\n */\nclass MessageReflection {\n\n  static void writeMessageTo(\n      Message message,\n      Map<FieldDescriptor, Object> fields,\n      CodedOutputStream output,\n      boolean alwaysWriteRequiredFields)\n      throws IOException {\n    final boolean isMessageSet =\n        message.getDescriptorForType().getOptions().getMessageSetWireFormat();\n    if (alwaysWriteRequiredFields) {\n      fields = new TreeMap<FieldDescriptor, Object>(fields);\n      for (final FieldDescriptor field : message.getDescriptorForType().getFields()) {\n        if (field.isRequired() && !fields.containsKey(field)) {\n          fields.put(field, message.getField(field));\n        }\n      }\n    }\n    for (final Map.Entry<Descriptors.FieldDescriptor, Object> entry : fields.entrySet()) {\n      final Descriptors.FieldDescriptor field = entry.getKey();\n      final Object value = entry.getValue();\n      if (isMessageSet\n          && field.isExtension()\n          && field.getType() == Descriptors.FieldDescriptor.Type.MESSAGE\n          && !field.isRepeated()) {\n        output.writeMessageSetExtension(field.getNumber(), (Message) value);\n      } else {\n        FieldSet.writeField(field, value, output);\n      }\n    }\n\n    final UnknownFieldSet unknownFields = message.getUnknownFields();\n    if (isMessageSet) {\n      unknownFields.writeAsMessageSetTo(output);\n    } else {\n      unknownFields.writeTo(output);\n    }\n  }\n\n  static int getSerializedSize(Message message, Map<FieldDescriptor, Object> fields) {\n    int size = 0;\n    final boolean isMessageSet =\n        message.getDescriptorForType().getOptions().getMessageSetWireFormat();\n\n    for (final Map.Entry<Descriptors.FieldDescriptor, Object> entry : fields.entrySet()) {\n      final Descriptors.FieldDescriptor field = entry.getKey();\n      final Object value = entry.getValue();\n      if (isMessageSet\n          && field.isExtension()\n          && field.getType() == Descriptors.FieldDescriptor.Type.MESSAGE\n          && !field.isRepeated()) {\n        size +=\n            CodedOutputStream.computeMessageSetExtensionSize(field.getNumber(), (Message) value);\n      } else {\n        size += FieldSet.computeFieldSize(field, value);\n      }\n    }\n\n    final UnknownFieldSet unknownFields = message.getUnknownFields();\n    if (isMessageSet) {\n      size += unknownFields.getSerializedSizeAsMessageSet();\n    } else {\n      size += unknownFields.getSerializedSize();\n    }\n    return size;\n  }\n\n  static String delimitWithCommas(List<String> parts) {\n    StringBuilder result = new StringBuilder();\n    for (String part : parts) {\n      if (result.length() > 0) {\n        result.append(\", \");\n      }\n      result.append(part);\n    }\n    return result.toString();\n  }\n\n  @SuppressWarnings(\"unchecked\")\n  static boolean isInitialized(MessageOrBuilder message) {\n    // Check that all required fields are present.\n    for (final Descriptors.FieldDescriptor field : message.getDescriptorForType().getFields()) {\n      if (field.isRequired()) {\n        if (!message.hasField(field)) {\n          return false;\n        }\n      }\n    }\n\n    // Check that embedded messages are initialized.\n    for (final Map.Entry<Descriptors.FieldDescriptor, Object> entry :\n        message.getAllFields().entrySet()) {\n      final Descriptors.FieldDescriptor field = entry.getKey();\n      if (field.getJavaType() == Descriptors.FieldDescriptor.JavaType.MESSAGE) {\n        if (field.isRepeated()) {\n          for (final Message element : (List<Message>) entry.getValue()) {\n            if (!element.isInitialized()) {\n              return false;\n            }\n          }\n        } else {\n          if (!((Message) entry.getValue()).isInitialized()) {\n            return false;\n          }\n        }\n      }\n    }\n\n    return true;\n  }\n\n  private static String subMessagePrefix(\n      final String prefix, final Descriptors.FieldDescriptor field, final int index) {\n    final StringBuilder result = new StringBuilder(prefix);\n    if (field.isExtension()) {\n      result.append('(').append(field.getFullName()).append(')');\n    } else {\n      result.append(field.getName());\n    }\n    if (index != -1) {\n      result.append('[').append(index).append(']');\n    }\n    result.append('.');\n    return result.toString();\n  }\n\n  private static void findMissingFields(\n      final MessageOrBuilder message, final String prefix, final List<String> results) {\n    for (final Descriptors.FieldDescriptor field : message.getDescriptorForType().getFields()) {\n      if (field.isRequired() && !message.hasField(field)) {\n        results.add(prefix + field.getName());\n      }\n    }\n\n    for (final Map.Entry<Descriptors.FieldDescriptor, Object> entry :\n        message.getAllFields().entrySet()) {\n      final Descriptors.FieldDescriptor field = entry.getKey();\n      final Object value = entry.getValue();\n\n      if (field.getJavaType() == Descriptors.FieldDescriptor.JavaType.MESSAGE) {\n        if (field.isRepeated()) {\n          int i = 0;\n          for (final Object element : (List) value) {\n            findMissingFields(\n                (MessageOrBuilder) element, subMessagePrefix(prefix, field, i++), results);\n          }\n        } else {\n          if (message.hasField(field)) {\n            findMissingFields(\n                (MessageOrBuilder) value, subMessagePrefix(prefix, field, -1), results);\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Populates {@code this.missingFields} with the full \"path\" of each missing required field in the\n   * given message.\n   */\n  static List<String> findMissingFields(final MessageOrBuilder message) {\n    final List<String> results = new ArrayList<String>();\n    findMissingFields(message, \"\", results);\n    return results;\n  }\n\n  static interface MergeTarget {\n    enum ContainerType {\n      MESSAGE,\n      EXTENSION_SET\n    }\n\n    /** Returns the descriptor for the target. */\n    public Descriptors.Descriptor getDescriptorForType();\n\n    public ContainerType getContainerType();\n\n    public ExtensionRegistry.ExtensionInfo findExtensionByName(\n        ExtensionRegistry registry, String name);\n\n    public ExtensionRegistry.ExtensionInfo findExtensionByNumber(\n        ExtensionRegistry registry, Descriptors.Descriptor containingType, int fieldNumber);\n\n    /**\n     * Obtains the value of the given field, or the default value if it is not set. For primitive\n     * fields, the boxed primitive value is returned. For enum fields, the EnumValueDescriptor for\n     * the value is returned. For embedded message fields, the sub-message is returned. For repeated\n     * fields, a java.util.List is returned.\n     */\n    public Object getField(Descriptors.FieldDescriptor field);\n\n    /**\n     * Returns true if the given field is set. This is exactly equivalent to calling the generated\n     * \"has\" accessor method corresponding to the field.\n     *\n     * @throws IllegalArgumentException The field is a repeated field, or {@code\n     *     field.getContainingType() != getDescriptorForType()}.\n     */\n    boolean hasField(Descriptors.FieldDescriptor field);\n\n    /**\n     * Sets a field to the given value. The value must be of the correct type for this field, i.e.\n     * the same type that {@link Message#getField(Descriptors.FieldDescriptor)} would return.\n     */\n    MergeTarget setField(Descriptors.FieldDescriptor field, Object value);\n\n    /**\n     * Clears the field. This is exactly equivalent to calling the generated \"clear\" accessor method\n     * corresponding to the field.\n     */\n    MergeTarget clearField(Descriptors.FieldDescriptor field);\n\n    /**\n     * Sets an element of a repeated field to the given value. The value must be of the correct type\n     * for this field, i.e. the same type that {@link\n     * Message#getRepeatedField(Descriptors.FieldDescriptor, int)} would return.\n     *\n     * @throws IllegalArgumentException The field is not a repeated field, or {@code\n     *     field.getContainingType() != getDescriptorForType()}.\n     */\n    MergeTarget setRepeatedField(Descriptors.FieldDescriptor field, int index, Object value);\n\n    /**\n     * Like {@code setRepeatedField}, but appends the value as a new element.\n     *\n     * @throws IllegalArgumentException The field is not a repeated field, or {@code\n     *     field.getContainingType() != getDescriptorForType()}.\n     */\n    MergeTarget addRepeatedField(Descriptors.FieldDescriptor field, Object value);\n\n    /**\n     * Returns true if the given oneof is set.\n     *\n     * @throws IllegalArgumentException if {@code oneof.getContainingType() !=\n     *     getDescriptorForType()}.\n     */\n    boolean hasOneof(Descriptors.OneofDescriptor oneof);\n\n    /**\n     * Clears the oneof. This is exactly equivalent to calling the generated \"clear\" accessor method\n     * corresponding to the oneof.\n     */\n    MergeTarget clearOneof(Descriptors.OneofDescriptor oneof);\n\n    /** Obtains the FieldDescriptor if the given oneof is set. Returns null if no field is set. */\n    Descriptors.FieldDescriptor getOneofFieldDescriptor(Descriptors.OneofDescriptor oneof);\n\n    /**\n     * Parse the input stream into a sub field group defined based on either FieldDescriptor or the\n     * default instance.\n     */\n    Object parseGroup(\n        CodedInputStream input,\n        ExtensionRegistryLite registry,\n        Descriptors.FieldDescriptor descriptor,\n        Message defaultInstance)\n        throws IOException;\n\n    /**\n     * Parse the input stream into a sub field message defined based on either FieldDescriptor or\n     * the default instance.\n     */\n    Object parseMessage(\n        CodedInputStream input,\n        ExtensionRegistryLite registry,\n        Descriptors.FieldDescriptor descriptor,\n        Message defaultInstance)\n        throws IOException;\n\n    /**\n     * Parse from a ByteString into a sub field message defined based on either FieldDescriptor or\n     * the default instance. There isn't a varint indicating the length of the message at the\n     * beginning of the input ByteString.\n     */\n    Object parseMessageFromBytes(\n        ByteString bytes,\n        ExtensionRegistryLite registry,\n        Descriptors.FieldDescriptor descriptor,\n        Message defaultInstance)\n        throws IOException;\n\n    /**\n     * Read the given group field from the wire, merging with the existing field if it is already\n     * present.\n     *\n     * <p>For extensions, defaultInstance must be specified. For regular fields, defaultInstance can\n     * be null.\n     */\n    void mergeGroup(\n        CodedInputStream input,\n        ExtensionRegistryLite extensionRegistry,\n        FieldDescriptor field,\n        Message defaultInstance)\n        throws IOException;\n\n    /**\n     * Read the given message field from the wire, merging with the existing field if it is already\n     * present.\n     *\n     * <p>For extensions, defaultInstance must be specified. For regular fields, defaultInstance can\n     * be null.\n     */\n    void mergeMessage(\n        CodedInputStream input,\n        ExtensionRegistryLite extensionRegistry,\n        FieldDescriptor field,\n        Message defaultInstance)\n        throws IOException;\n\n    /** Returns the UTF8 validation level for the field. */\n    WireFormat.Utf8Validation getUtf8Validation(Descriptors.FieldDescriptor descriptor);\n\n    /**\n     * Returns a new merge target for a sub-field. When defaultInstance is provided, it indicates\n     * the descriptor is for an extension type, and implementations should create a new instance\n     * from the defaultInstance prototype directly.\n     */\n    MergeTarget newMergeTargetForField(\n        Descriptors.FieldDescriptor descriptor, Message defaultInstance);\n\n    /**\n     * Returns an empty merge target for a sub-field. When defaultInstance is provided, it indicates\n     * the descriptor is for an extension type, and implementations should create a new instance\n     * from the defaultInstance prototype directly.\n     */\n    MergeTarget newEmptyTargetForField(\n        Descriptors.FieldDescriptor descriptor, Message defaultInstance);\n\n    /** Finishes the merge and returns the underlying object. */\n    Object finish();\n  }\n\n  static class BuilderAdapter implements MergeTarget {\n\n    private final Message.Builder builder;\n    private boolean hasNestedBuilders = true;\n\n    @Override\n    public Descriptors.Descriptor getDescriptorForType() {\n      return builder.getDescriptorForType();\n    }\n\n    public BuilderAdapter(Message.Builder builder) {\n      this.builder = builder;\n    }\n\n    @Override\n    public Object getField(Descriptors.FieldDescriptor field) {\n      return builder.getField(field);\n    }\n\n    private Message.Builder getFieldBuilder(Descriptors.FieldDescriptor field) {\n      if (hasNestedBuilders) {\n        try {\n          return builder.getFieldBuilder(field);\n        } catch (UnsupportedOperationException e) {\n          hasNestedBuilders = false;\n        }\n      }\n      return null;\n    }\n\n    @Override\n    public boolean hasField(Descriptors.FieldDescriptor field) {\n      return builder.hasField(field);\n    }\n\n    @Override\n    public MergeTarget setField(Descriptors.FieldDescriptor field, Object value) {\n      if (!field.isRepeated() && value instanceof MessageLite.Builder) {\n        if (value != getFieldBuilder(field)) {\n          builder.setField(field, ((MessageLite.Builder) value).buildPartial());\n        }\n        return this;\n      }\n      builder.setField(field, value);\n      return this;\n    }\n\n    @Override\n    public MergeTarget clearField(Descriptors.FieldDescriptor field) {\n      builder.clearField(field);\n      return this;\n    }\n\n    @Override\n    public MergeTarget setRepeatedField(\n        Descriptors.FieldDescriptor field, int index, Object value) {\n      if (value instanceof MessageLite.Builder) {\n        value = ((MessageLite.Builder) value).buildPartial();\n      }\n      builder.setRepeatedField(field, index, value);\n      return this;\n    }\n\n    @Override\n    public MergeTarget addRepeatedField(Descriptors.FieldDescriptor field, Object value) {\n      if (value instanceof MessageLite.Builder) {\n        value = ((MessageLite.Builder) value).buildPartial();\n      }\n      builder.addRepeatedField(field, value);\n      return this;\n    }\n\n    @Override\n    public boolean hasOneof(Descriptors.OneofDescriptor oneof) {\n      return builder.hasOneof(oneof);\n    }\n\n    @Override\n    public MergeTarget clearOneof(Descriptors.OneofDescriptor oneof) {\n      builder.clearOneof(oneof);\n      return this;\n    }\n\n    @Override\n    public Descriptors.FieldDescriptor getOneofFieldDescriptor(Descriptors.OneofDescriptor oneof) {\n      return builder.getOneofFieldDescriptor(oneof);\n    }\n\n    @Override\n    public ContainerType getContainerType() {\n      return ContainerType.MESSAGE;\n    }\n\n    @Override\n    public ExtensionRegistry.ExtensionInfo findExtensionByName(\n        ExtensionRegistry registry, String name) {\n      return registry.findImmutableExtensionByName(name);\n    }\n\n    @Override\n    public ExtensionRegistry.ExtensionInfo findExtensionByNumber(\n        ExtensionRegistry registry, Descriptors.Descriptor containingType, int fieldNumber) {\n      return registry.findImmutableExtensionByNumber(containingType, fieldNumber);\n    }\n\n    @Override\n    public Object parseGroup(\n        CodedInputStream input,\n        ExtensionRegistryLite extensionRegistry,\n        Descriptors.FieldDescriptor field,\n        Message defaultInstance)\n        throws IOException {\n      Message.Builder subBuilder;\n      // When default instance is not null. The field is an extension field.\n      if (defaultInstance != null) {\n        subBuilder = defaultInstance.newBuilderForType();\n      } else {\n        subBuilder = builder.newBuilderForField(field);\n      }\n      if (!field.isRepeated()) {\n        Message originalMessage = (Message) getField(field);\n        if (originalMessage != null) {\n          subBuilder.mergeFrom(originalMessage);\n        }\n      }\n      input.readGroup(field.getNumber(), subBuilder, extensionRegistry);\n      return subBuilder.buildPartial();\n    }\n\n    @Override\n    public Object parseMessage(\n        CodedInputStream input,\n        ExtensionRegistryLite extensionRegistry,\n        Descriptors.FieldDescriptor field,\n        Message defaultInstance)\n        throws IOException {\n      Message.Builder subBuilder;\n      // When default instance is not null. The field is an extension field.\n      if (defaultInstance != null) {\n        subBuilder = defaultInstance.newBuilderForType();\n      } else {\n        subBuilder = builder.newBuilderForField(field);\n      }\n      if (!field.isRepeated()) {\n        Message originalMessage = (Message) getField(field);\n        if (originalMessage != null) {\n          subBuilder.mergeFrom(originalMessage);\n        }\n      }\n      input.readMessage(subBuilder, extensionRegistry);\n      return subBuilder.buildPartial();\n    }\n\n    @Override\n    public Object parseMessageFromBytes(\n        ByteString bytes,\n        ExtensionRegistryLite extensionRegistry,\n        Descriptors.FieldDescriptor field,\n        Message defaultInstance)\n        throws IOException {\n      Message.Builder subBuilder;\n      // When default instance is not null. The field is an extension field.\n      if (defaultInstance != null) {\n        subBuilder = defaultInstance.newBuilderForType();\n      } else {\n        subBuilder = builder.newBuilderForField(field);\n      }\n      if (!field.isRepeated()) {\n        Message originalMessage = (Message) getField(field);\n        if (originalMessage != null) {\n          subBuilder.mergeFrom(originalMessage);\n        }\n      }\n      subBuilder.mergeFrom(bytes, extensionRegistry);\n      return subBuilder.buildPartial();\n    }\n\n    @Override\n    public void mergeGroup(\n        CodedInputStream input,\n        ExtensionRegistryLite extensionRegistry,\n        FieldDescriptor field,\n        Message defaultInstance)\n        throws IOException {\n      if (!field.isRepeated()) {\n        Message.Builder subBuilder;\n        if (hasField(field)) {\n          subBuilder = getFieldBuilder(field);\n          if (subBuilder != null) {\n            input.readGroup(field.getNumber(), subBuilder, extensionRegistry);\n            return;\n          } else {\n            subBuilder = newMessageFieldInstance(field, defaultInstance);\n            subBuilder.mergeFrom((Message) getField(field));\n          }\n        } else {\n          subBuilder = newMessageFieldInstance(field, defaultInstance);\n        }\n        input.readGroup(field.getNumber(), subBuilder, extensionRegistry);\n        Object unused = setField(field, subBuilder.buildPartial());\n      } else {\n        Message.Builder subBuilder = newMessageFieldInstance(field, defaultInstance);\n        input.readGroup(field.getNumber(), subBuilder, extensionRegistry);\n        Object unused = addRepeatedField(field, subBuilder.buildPartial());\n      }\n    }\n\n    @Override\n    public void mergeMessage(\n        CodedInputStream input,\n        ExtensionRegistryLite extensionRegistry,\n        Descriptors.FieldDescriptor field,\n        Message defaultInstance)\n        throws IOException {\n      if (!field.isRepeated()) {\n        Message.Builder subBuilder;\n        if (hasField(field)) {\n          subBuilder = getFieldBuilder(field);\n          if (subBuilder != null) {\n            input.readMessage(subBuilder, extensionRegistry);\n            return;\n          } else {\n            subBuilder = newMessageFieldInstance(field, defaultInstance);\n            subBuilder.mergeFrom((Message) getField(field));\n          }\n        } else {\n          subBuilder = newMessageFieldInstance(field, defaultInstance);\n        }\n        input.readMessage(subBuilder, extensionRegistry);\n        Object unused = setField(field, subBuilder.buildPartial());\n      } else {\n        Message.Builder subBuilder = newMessageFieldInstance(field, defaultInstance);\n        input.readMessage(subBuilder, extensionRegistry);\n        Object unused = addRepeatedField(field, subBuilder.buildPartial());\n      }\n    }\n\n    private Message.Builder newMessageFieldInstance(\n        FieldDescriptor field, Message defaultInstance) {\n      // When default instance is not null. The field is an extension field.\n      if (defaultInstance != null) {\n        return defaultInstance.newBuilderForType();\n      } else {\n        return builder.newBuilderForField(field);\n      }\n    }\n\n    @Override\n    public MergeTarget newMergeTargetForField(\n        Descriptors.FieldDescriptor field, Message defaultInstance) {\n      Message.Builder subBuilder;\n      if (!field.isRepeated() && hasField(field)) {\n        subBuilder = getFieldBuilder(field);\n        if (subBuilder != null) {\n          return new BuilderAdapter(subBuilder);\n        }\n      }\n\n      subBuilder = newMessageFieldInstance(field, defaultInstance);\n      if (!field.isRepeated()) {\n        Message originalMessage = (Message) getField(field);\n        if (originalMessage != null) {\n          subBuilder.mergeFrom(originalMessage);\n        }\n      }\n      return new BuilderAdapter(subBuilder);\n    }\n\n    @Override\n    public MergeTarget newEmptyTargetForField(\n        Descriptors.FieldDescriptor field, Message defaultInstance) {\n      Message.Builder subBuilder;\n      if (defaultInstance != null) {\n        subBuilder = defaultInstance.newBuilderForType();\n      } else {\n        subBuilder = builder.newBuilderForField(field);\n      }\n      return new BuilderAdapter(subBuilder);\n    }\n\n    @Override\n    public WireFormat.Utf8Validation getUtf8Validation(Descriptors.FieldDescriptor descriptor) {\n      if (descriptor.needsUtf8Check()) {\n        return WireFormat.Utf8Validation.STRICT;\n      }\n      // TODO(liujisi): support lazy strings for repeated fields.\n      if (!descriptor.isRepeated() && builder instanceof GeneratedMessage.Builder) {\n        return WireFormat.Utf8Validation.LAZY;\n      }\n      return WireFormat.Utf8Validation.LOOSE;\n    }\n\n    @Override\n    public Object finish() {\n      return builder;\n    }\n  }\n\n\n  static class ExtensionAdapter implements MergeTarget {\n\n    private final FieldSet<Descriptors.FieldDescriptor> extensions;\n\n    ExtensionAdapter(FieldSet<Descriptors.FieldDescriptor> extensions) {\n      this.extensions = extensions;\n    }\n\n    @Override\n    public Descriptors.Descriptor getDescriptorForType() {\n      throw new UnsupportedOperationException(\"getDescriptorForType() called on FieldSet object\");\n    }\n\n    @Override\n    public Object getField(Descriptors.FieldDescriptor field) {\n      return extensions.getField(field);\n    }\n\n    @Override\n    public boolean hasField(Descriptors.FieldDescriptor field) {\n      return extensions.hasField(field);\n    }\n\n    @Override\n    public MergeTarget setField(Descriptors.FieldDescriptor field, Object value) {\n      extensions.setField(field, value);\n      return this;\n    }\n\n    @Override\n    public MergeTarget clearField(Descriptors.FieldDescriptor field) {\n      extensions.clearField(field);\n      return this;\n    }\n\n    @Override\n    public MergeTarget setRepeatedField(\n        Descriptors.FieldDescriptor field, int index, Object value) {\n      extensions.setRepeatedField(field, index, value);\n      return this;\n    }\n\n    @Override\n    public MergeTarget addRepeatedField(Descriptors.FieldDescriptor field, Object value) {\n      extensions.addRepeatedField(field, value);\n      return this;\n    }\n\n    @Override\n    public boolean hasOneof(Descriptors.OneofDescriptor oneof) {\n      return false;\n    }\n\n    @Override\n    public MergeTarget clearOneof(Descriptors.OneofDescriptor oneof) {\n      // Nothing to clear.\n      return this;\n    }\n\n    @Override\n    public Descriptors.FieldDescriptor getOneofFieldDescriptor(Descriptors.OneofDescriptor oneof) {\n      return null;\n    }\n\n    @Override\n    public ContainerType getContainerType() {\n      return ContainerType.EXTENSION_SET;\n    }\n\n    @Override\n    public ExtensionRegistry.ExtensionInfo findExtensionByName(\n        ExtensionRegistry registry, String name) {\n      return registry.findImmutableExtensionByName(name);\n    }\n\n    @Override\n    public ExtensionRegistry.ExtensionInfo findExtensionByNumber(\n        ExtensionRegistry registry, Descriptors.Descriptor containingType, int fieldNumber) {\n      return registry.findImmutableExtensionByNumber(containingType, fieldNumber);\n    }\n\n    @Override\n    public Object parseGroup(\n        CodedInputStream input,\n        ExtensionRegistryLite registry,\n        Descriptors.FieldDescriptor field,\n        Message defaultInstance)\n        throws IOException {\n      Message.Builder subBuilder = defaultInstance.newBuilderForType();\n      if (!field.isRepeated()) {\n        Message originalMessage = (Message) getField(field);\n        if (originalMessage != null) {\n          subBuilder.mergeFrom(originalMessage);\n        }\n      }\n      input.readGroup(field.getNumber(), subBuilder, registry);\n      return subBuilder.buildPartial();\n    }\n\n    @Override\n    public Object parseMessage(\n        CodedInputStream input,\n        ExtensionRegistryLite registry,\n        Descriptors.FieldDescriptor field,\n        Message defaultInstance)\n        throws IOException {\n      Message.Builder subBuilder = defaultInstance.newBuilderForType();\n      if (!field.isRepeated()) {\n        Message originalMessage = (Message) getField(field);\n        if (originalMessage != null) {\n          subBuilder.mergeFrom(originalMessage);\n        }\n      }\n      input.readMessage(subBuilder, registry);\n      return subBuilder.buildPartial();\n    }\n\n    @Override\n    public void mergeGroup(\n        CodedInputStream input,\n        ExtensionRegistryLite extensionRegistry,\n        FieldDescriptor field,\n        Message defaultInstance)\n        throws IOException {\n      if (!field.isRepeated()) {\n        if (hasField(field)) {\n          MessageLite.Builder current = ((MessageLite) getField(field)).toBuilder();\n          input.readGroup(field.getNumber(), current, extensionRegistry);\n          Object unused = setField(field, current.buildPartial());\n          return;\n        }\n        Message.Builder subBuilder = defaultInstance.newBuilderForType();\n        input.readGroup(field.getNumber(), subBuilder, extensionRegistry);\n        Object unused = setField(field, subBuilder.buildPartial());\n      } else {\n        Message.Builder subBuilder = defaultInstance.newBuilderForType();\n        input.readGroup(field.getNumber(), subBuilder, extensionRegistry);\n        Object unused = addRepeatedField(field, subBuilder.buildPartial());\n      }\n    }\n\n    @Override\n    public void mergeMessage(\n        CodedInputStream input,\n        ExtensionRegistryLite extensionRegistry,\n        FieldDescriptor field,\n        Message defaultInstance)\n        throws IOException {\n      if (!field.isRepeated()) {\n        if (hasField(field)) {\n          MessageLite.Builder current = ((MessageLite) getField(field)).toBuilder();\n          input.readMessage(current, extensionRegistry);\n          Object unused = setField(field, current.buildPartial());\n          return;\n        }\n        Message.Builder subBuilder = defaultInstance.newBuilderForType();\n        input.readMessage(subBuilder, extensionRegistry);\n        Object unused = setField(field, subBuilder.buildPartial());\n      } else {\n        Message.Builder subBuilder = defaultInstance.newBuilderForType();\n        input.readMessage(subBuilder, extensionRegistry);\n        Object unused = addRepeatedField(field, subBuilder.buildPartial());\n      }\n    }\n\n    @Override\n    public Object parseMessageFromBytes(\n        ByteString bytes,\n        ExtensionRegistryLite registry,\n        Descriptors.FieldDescriptor field,\n        Message defaultInstance)\n        throws IOException {\n      Message.Builder subBuilder = defaultInstance.newBuilderForType();\n      if (!field.isRepeated()) {\n        Message originalMessage = (Message) getField(field);\n        if (originalMessage != null) {\n          subBuilder.mergeFrom(originalMessage);\n        }\n      }\n      subBuilder.mergeFrom(bytes, registry);\n      return subBuilder.buildPartial();\n    }\n\n    @Override\n    public MergeTarget newMergeTargetForField(\n        Descriptors.FieldDescriptor descriptor, Message defaultInstance) {\n      throw new UnsupportedOperationException(\"newMergeTargetForField() called on FieldSet object\");\n    }\n\n    @Override\n    public MergeTarget newEmptyTargetForField(\n        Descriptors.FieldDescriptor descriptor, Message defaultInstance) {\n      throw new UnsupportedOperationException(\"newEmptyTargetForField() called on FieldSet object\");\n    }\n\n    @Override\n    public WireFormat.Utf8Validation getUtf8Validation(Descriptors.FieldDescriptor descriptor) {\n      if (descriptor.needsUtf8Check()) {\n        return WireFormat.Utf8Validation.STRICT;\n      }\n      // TODO(b/248145492): support lazy strings for ExtesnsionSet.\n      return WireFormat.Utf8Validation.LOOSE;\n    }\n\n    @Override\n    public Object finish() {\n      throw new UnsupportedOperationException(\"finish() called on FieldSet object\");\n    }\n  }\n\n  static class ExtensionBuilderAdapter implements MergeTarget {\n\n    private final FieldSet.Builder<Descriptors.FieldDescriptor> extensions;\n\n    ExtensionBuilderAdapter(FieldSet.Builder<Descriptors.FieldDescriptor> extensions) {\n      this.extensions = extensions;\n    }\n\n    @Override\n    public Descriptors.Descriptor getDescriptorForType() {\n      throw new UnsupportedOperationException(\"getDescriptorForType() called on FieldSet object\");\n    }\n\n    @Override\n    public Object getField(Descriptors.FieldDescriptor field) {\n      return extensions.getField(field);\n    }\n\n    @Override\n    public boolean hasField(Descriptors.FieldDescriptor field) {\n      return extensions.hasField(field);\n    }\n\n    @Override\n    @CanIgnoreReturnValue\n    public MergeTarget setField(Descriptors.FieldDescriptor field, Object value) {\n      extensions.setField(field, value);\n      return this;\n    }\n\n    @Override\n    @CanIgnoreReturnValue\n    public MergeTarget clearField(Descriptors.FieldDescriptor field) {\n      extensions.clearField(field);\n      return this;\n    }\n\n    @Override\n    @CanIgnoreReturnValue\n    public MergeTarget setRepeatedField(\n        Descriptors.FieldDescriptor field, int index, Object value) {\n      extensions.setRepeatedField(field, index, value);\n      return this;\n    }\n\n    @Override\n    @CanIgnoreReturnValue\n    public MergeTarget addRepeatedField(Descriptors.FieldDescriptor field, Object value) {\n      extensions.addRepeatedField(field, value);\n      return this;\n    }\n\n    @Override\n    public boolean hasOneof(Descriptors.OneofDescriptor oneof) {\n      return false;\n    }\n\n    @Override\n    @CanIgnoreReturnValue\n    public MergeTarget clearOneof(Descriptors.OneofDescriptor oneof) {\n      // Nothing to clear.\n      return this;\n    }\n\n    @Override\n    public Descriptors.FieldDescriptor getOneofFieldDescriptor(Descriptors.OneofDescriptor oneof) {\n      return null;\n    }\n\n    @Override\n    public ContainerType getContainerType() {\n      return ContainerType.EXTENSION_SET;\n    }\n\n    @Override\n    public ExtensionRegistry.ExtensionInfo findExtensionByName(\n        ExtensionRegistry registry, String name) {\n      return registry.findImmutableExtensionByName(name);\n    }\n\n    @Override\n    public ExtensionRegistry.ExtensionInfo findExtensionByNumber(\n        ExtensionRegistry registry, Descriptors.Descriptor containingType, int fieldNumber) {\n      return registry.findImmutableExtensionByNumber(containingType, fieldNumber);\n    }\n\n    @Override\n    public Object parseGroup(\n        CodedInputStream input,\n        ExtensionRegistryLite registry,\n        Descriptors.FieldDescriptor field,\n        Message defaultInstance)\n        throws IOException {\n      Message.Builder subBuilder = defaultInstance.newBuilderForType();\n      if (!field.isRepeated()) {\n        Message originalMessage = (Message) getField(field);\n        if (originalMessage != null) {\n          subBuilder.mergeFrom(originalMessage);\n        }\n      }\n      input.readGroup(field.getNumber(), subBuilder, registry);\n      return subBuilder.buildPartial();\n    }\n\n    @Override\n    public Object parseMessage(\n        CodedInputStream input,\n        ExtensionRegistryLite registry,\n        Descriptors.FieldDescriptor field,\n        Message defaultInstance)\n        throws IOException {\n      Message.Builder subBuilder = defaultInstance.newBuilderForType();\n      if (!field.isRepeated()) {\n        Message originalMessage = (Message) getField(field);\n        if (originalMessage != null) {\n          subBuilder.mergeFrom(originalMessage);\n        }\n      }\n      input.readMessage(subBuilder, registry);\n      return subBuilder.buildPartial();\n    }\n\n    @Override\n    public void mergeGroup(\n        CodedInputStream input,\n        ExtensionRegistryLite extensionRegistry,\n        FieldDescriptor field,\n        Message defaultInstance)\n        throws IOException {\n      if (!field.isRepeated()) {\n        if (hasField(field)) {\n          Object fieldOrBuilder = extensions.getFieldAllowBuilders(field);\n          MessageLite.Builder subBuilder;\n          if (fieldOrBuilder instanceof MessageLite.Builder) {\n            subBuilder = (MessageLite.Builder) fieldOrBuilder;\n          } else {\n            subBuilder = ((MessageLite) fieldOrBuilder).toBuilder();\n            extensions.setField(field, subBuilder);\n          }\n          input.readGroup(field.getNumber(), subBuilder, extensionRegistry);\n          return;\n        }\n        Message.Builder subBuilder = defaultInstance.newBuilderForType();\n        input.readGroup(field.getNumber(), subBuilder, extensionRegistry);\n        Object unused = setField(field, subBuilder);\n      } else {\n        Message.Builder subBuilder = defaultInstance.newBuilderForType();\n        input.readGroup(field.getNumber(), subBuilder, extensionRegistry);\n        Object unused = addRepeatedField(field, subBuilder.buildPartial());\n      }\n    }\n\n    @Override\n    public void mergeMessage(\n        CodedInputStream input,\n        ExtensionRegistryLite extensionRegistry,\n        FieldDescriptor field,\n        Message defaultInstance)\n        throws IOException {\n      if (!field.isRepeated()) {\n        if (hasField(field)) {\n          Object fieldOrBuilder = extensions.getFieldAllowBuilders(field);\n          MessageLite.Builder subBuilder;\n          if (fieldOrBuilder instanceof MessageLite.Builder) {\n            subBuilder = (MessageLite.Builder) fieldOrBuilder;\n          } else {\n            subBuilder = ((MessageLite) fieldOrBuilder).toBuilder();\n            extensions.setField(field, subBuilder);\n          }\n          input.readMessage(subBuilder, extensionRegistry);\n          return;\n        }\n        Message.Builder subBuilder = defaultInstance.newBuilderForType();\n        input.readMessage(subBuilder, extensionRegistry);\n        Object unused = setField(field, subBuilder);\n      } else {\n        Message.Builder subBuilder = defaultInstance.newBuilderForType();\n        input.readMessage(subBuilder, extensionRegistry);\n        Object unused = addRepeatedField(field, subBuilder.buildPartial());\n      }\n    }\n\n    @Override\n    public Object parseMessageFromBytes(\n        ByteString bytes,\n        ExtensionRegistryLite registry,\n        Descriptors.FieldDescriptor field,\n        Message defaultInstance)\n        throws IOException {\n      Message.Builder subBuilder = defaultInstance.newBuilderForType();\n      if (!field.isRepeated()) {\n        Message originalMessage = (Message) getField(field);\n        if (originalMessage != null) {\n          subBuilder.mergeFrom(originalMessage);\n        }\n      }\n      subBuilder.mergeFrom(bytes, registry);\n      return subBuilder.buildPartial();\n    }\n\n    @Override\n    public MergeTarget newMergeTargetForField(\n        Descriptors.FieldDescriptor descriptor, Message defaultInstance) {\n      throw new UnsupportedOperationException(\"newMergeTargetForField() called on FieldSet object\");\n    }\n\n    @Override\n    public MergeTarget newEmptyTargetForField(\n        Descriptors.FieldDescriptor descriptor, Message defaultInstance) {\n      throw new UnsupportedOperationException(\"newEmptyTargetForField() called on FieldSet object\");\n    }\n\n    @Override\n    public WireFormat.Utf8Validation getUtf8Validation(Descriptors.FieldDescriptor descriptor) {\n      if (descriptor.needsUtf8Check()) {\n        return WireFormat.Utf8Validation.STRICT;\n      }\n      // TODO(b/248145492): support lazy strings for ExtesnsionSet.\n      return WireFormat.Utf8Validation.LOOSE;\n    }\n\n    @Override\n    public Object finish() {\n      throw new UnsupportedOperationException(\"finish() called on FieldSet object\");\n    }\n  }\n\n  /**\n   * Parses a single field into MergeTarget. The target can be Message.Builder, FieldSet or\n   * MutableMessage.\n   *\n   * <p>Package-private because it is used by GeneratedMessage.ExtendableMessage.\n   *\n   * @param tag The tag, which should have already been read.\n   * @param unknownFields If not null, unknown fields will be merged to this {@link\n   *     UnknownFieldSet}, otherwise unknown fields will be discarded.\n   * @return {@code true} unless the tag is an end-group tag.\n   */\n  static boolean mergeFieldFrom(\n      CodedInputStream input,\n      UnknownFieldSet.Builder unknownFields,\n      ExtensionRegistryLite extensionRegistry,\n      Descriptors.Descriptor type,\n      MergeTarget target,\n      int tag)\n      throws IOException {\n    if (type.getOptions().getMessageSetWireFormat() && tag == WireFormat.MESSAGE_SET_ITEM_TAG) {\n      mergeMessageSetExtensionFromCodedStream(\n          input, unknownFields, extensionRegistry, type, target);\n      return true;\n    }\n\n    final int wireType = WireFormat.getTagWireType(tag);\n    final int fieldNumber = WireFormat.getTagFieldNumber(tag);\n\n    final Descriptors.FieldDescriptor field;\n    Message defaultInstance = null;\n\n    if (type.isExtensionNumber(fieldNumber)) {\n      // extensionRegistry may be either ExtensionRegistry or\n      // ExtensionRegistryLite.  Since the type we are parsing is a full\n      // message, only a full ExtensionRegistry could possibly contain\n      // extensions of it.  Otherwise we will treat the registry as if it\n      // were empty.\n      if (extensionRegistry instanceof ExtensionRegistry) {\n        final ExtensionRegistry.ExtensionInfo extension =\n            target.findExtensionByNumber((ExtensionRegistry) extensionRegistry, type, fieldNumber);\n        if (extension == null) {\n          field = null;\n        } else {\n          field = extension.descriptor;\n          defaultInstance = extension.defaultInstance;\n          if (defaultInstance == null\n              && field.getJavaType() == Descriptors.FieldDescriptor.JavaType.MESSAGE) {\n            throw new IllegalStateException(\n                \"Message-typed extension lacked default instance: \" + field.getFullName());\n          }\n        }\n      } else {\n        field = null;\n      }\n    } else if (target.getContainerType() == MergeTarget.ContainerType.MESSAGE) {\n      field = type.findFieldByNumber(fieldNumber);\n    } else {\n      field = null;\n    }\n\n    boolean unknown = false;\n    boolean packed = false;\n    if (field == null) {\n      unknown = true; // Unknown field.\n    } else if (wireType\n        == FieldSet.getWireFormatForFieldType(field.getLiteType(), /* isPacked= */ false)) {\n      packed = false;\n    } else if (field.isPackable()\n        && wireType\n            == FieldSet.getWireFormatForFieldType(field.getLiteType(), /* isPacked= */ true)) {\n      packed = true;\n    } else {\n      unknown = true; // Unknown wire type.\n    }\n\n    if (unknown) { // Unknown field or wrong wire type.  Skip.\n      if (unknownFields != null) {\n        return unknownFields.mergeFieldFrom(tag, input);\n      } else {\n        return input.skipField(tag);\n      }\n    }\n\n    if (packed) {\n      final int length = input.readRawVarint32();\n      final int limit = input.pushLimit(length);\n      if (field.getLiteType() == WireFormat.FieldType.ENUM) {\n        while (input.getBytesUntilLimit() > 0) {\n          final int rawValue = input.readEnum();\n          if (field.getFile().supportsUnknownEnumValue()) {\n            target.addRepeatedField(\n                field, field.getEnumType().findValueByNumberCreatingIfUnknown(rawValue));\n          } else {\n            final Object value = field.getEnumType().findValueByNumber(rawValue);\n            // If the number isn't recognized as a valid value for this enum,\n            // add it to the unknown fields.\n            if (value == null) {\n              if (unknownFields != null) {\n                unknownFields.mergeVarintField(fieldNumber, rawValue);\n              }\n            } else {\n              target.addRepeatedField(field, value);\n            }\n          }\n        }\n      } else {\n        while (input.getBytesUntilLimit() > 0) {\n          final Object value =\n              WireFormat.readPrimitiveField(\n                  input, field.getLiteType(), target.getUtf8Validation(field));\n          target.addRepeatedField(field, value);\n        }\n      }\n      input.popLimit(limit);\n    } else {\n      final Object value;\n      switch (field.getType()) {\n        case GROUP:\n          {\n            target.mergeGroup(input, extensionRegistry, field, defaultInstance);\n            return true;\n          }\n        case MESSAGE:\n          {\n            target.mergeMessage(input, extensionRegistry, field, defaultInstance);\n            return true;\n          }\n        case ENUM:\n          final int rawValue = input.readEnum();\n          if (field.getFile().supportsUnknownEnumValue()) {\n            value = field.getEnumType().findValueByNumberCreatingIfUnknown(rawValue);\n          } else {\n            value = field.getEnumType().findValueByNumber(rawValue);\n            // If the number isn't recognized as a valid value for this enum,\n            // add it to the unknown fields.\n            if (value == null) {\n              if (unknownFields != null) {\n                unknownFields.mergeVarintField(fieldNumber, rawValue);\n              }\n              return true;\n            }\n          }\n          break;\n        default:\n          value =\n              WireFormat.readPrimitiveField(\n                  input, field.getLiteType(), target.getUtf8Validation(field));\n          break;\n      }\n\n      if (field.isRepeated()) {\n        target.addRepeatedField(field, value);\n      } else {\n        target.setField(field, value);\n      }\n    }\n\n    return true;\n  }\n\n  /** Read a message from the given input stream into the provided target and UnknownFieldSet. */\n  static void mergeMessageFrom(\n      Message.Builder target,\n      UnknownFieldSet.Builder unknownFields,\n      CodedInputStream input,\n      ExtensionRegistryLite extensionRegistry)\n      throws IOException {\n    BuilderAdapter builderAdapter = new BuilderAdapter(target);\n    Descriptor descriptorForType = target.getDescriptorForType();\n    while (true) {\n      final int tag = input.readTag();\n      if (tag == 0) {\n        break;\n      }\n\n      if (!mergeFieldFrom(\n          input, unknownFields, extensionRegistry, descriptorForType, builderAdapter, tag)) {\n        // end group tag\n        break;\n      }\n    }\n  }\n\n  /** Called by {@code #mergeFieldFrom()} to parse a MessageSet extension into MergeTarget. */\n  private static void mergeMessageSetExtensionFromCodedStream(\n      CodedInputStream input,\n      UnknownFieldSet.Builder unknownFields,\n      ExtensionRegistryLite extensionRegistry,\n      Descriptors.Descriptor type,\n      MergeTarget target)\n      throws IOException {\n\n    // The wire format for MessageSet is:\n    //   message MessageSet {\n    //     repeated group Item = 1 {\n    //       required uint32 typeId = 2;\n    //       required bytes message = 3;\n    //     }\n    //   }\n    // \"typeId\" is the extension's field number.  The extension can only be\n    // a message type, where \"message\" contains the encoded bytes of that\n    // message.\n    //\n    // In practice, we will probably never see a MessageSet item in which\n    // the message appears before the type ID, or where either field does not\n    // appear exactly once.  However, in theory such cases are valid, so we\n    // should be prepared to accept them.\n\n    int typeId = 0;\n    ByteString rawBytes = null; // If we encounter \"message\" before \"typeId\"\n    ExtensionRegistry.ExtensionInfo extension = null;\n\n    // Read bytes from input, if we get it's type first then parse it eagerly,\n    // otherwise we store the raw bytes in a local variable.\n    while (true) {\n      final int tag = input.readTag();\n      if (tag == 0) {\n        break;\n      }\n\n      if (tag == WireFormat.MESSAGE_SET_TYPE_ID_TAG) {\n        typeId = input.readUInt32();\n        if (typeId != 0) {\n          // extensionRegistry may be either ExtensionRegistry or\n          // ExtensionRegistryLite. Since the type we are parsing is a full\n          // message, only a full ExtensionRegistry could possibly contain\n          // extensions of it. Otherwise we will treat the registry as if it\n          // were empty.\n          if (extensionRegistry instanceof ExtensionRegistry) {\n            extension =\n                target.findExtensionByNumber((ExtensionRegistry) extensionRegistry, type, typeId);\n          }\n        }\n\n      } else if (tag == WireFormat.MESSAGE_SET_MESSAGE_TAG) {\n        if (typeId != 0) {\n          if (extension != null && ExtensionRegistryLite.isEagerlyParseMessageSets()) {\n            // We already know the type, so we can parse directly from the\n            // input with no copying.  Hooray!\n            eagerlyMergeMessageSetExtension(input, extension, extensionRegistry, target);\n            rawBytes = null;\n            continue;\n          }\n        }\n        // We haven't seen a type ID yet or we want parse message lazily.\n        rawBytes = input.readBytes();\n\n      } else { // Unknown tag. Skip it.\n        if (!input.skipField(tag)) {\n          break; // End of group\n        }\n      }\n    }\n    input.checkLastTagWas(WireFormat.MESSAGE_SET_ITEM_END_TAG);\n\n    // Process the raw bytes.\n    if (rawBytes != null && typeId != 0) { // Zero is not a valid type ID.\n      if (extension != null) { // We known the type\n        mergeMessageSetExtensionFromBytes(rawBytes, extension, extensionRegistry, target);\n      } else { // We don't know how to parse this. Ignore it.\n        if (rawBytes != null && unknownFields != null) {\n          unknownFields.mergeField(\n              typeId, UnknownFieldSet.Field.newBuilder().addLengthDelimited(rawBytes).build());\n        }\n      }\n    }\n  }\n\n  private static void mergeMessageSetExtensionFromBytes(\n      ByteString rawBytes,\n      ExtensionRegistry.ExtensionInfo extension,\n      ExtensionRegistryLite extensionRegistry,\n      MergeTarget target)\n      throws IOException {\n\n    Descriptors.FieldDescriptor field = extension.descriptor;\n    boolean hasOriginalValue = target.hasField(field);\n\n    if (hasOriginalValue || ExtensionRegistryLite.isEagerlyParseMessageSets()) {\n      // If the field already exists, we just parse the field.\n      Object value =\n          target.parseMessageFromBytes(\n              rawBytes, extensionRegistry, field, extension.defaultInstance);\n      target.setField(field, value);\n    } else {\n      // Use LazyField to load MessageSet lazily.\n      LazyField lazyField = new LazyField(extension.defaultInstance, extensionRegistry, rawBytes);\n      target.setField(field, lazyField);\n    }\n  }\n\n  private static void eagerlyMergeMessageSetExtension(\n      CodedInputStream input,\n      ExtensionRegistry.ExtensionInfo extension,\n      ExtensionRegistryLite extensionRegistry,\n      MergeTarget target)\n      throws IOException {\n    Descriptors.FieldDescriptor field = extension.descriptor;\n    Object value = target.parseMessage(input, extensionRegistry, field, extension.defaultInstance);\n    target.setField(field, value);\n  }\n}\n", "#!/usr/bin/ruby\n\nrequire 'google/protobuf'\nrequire 'test/unit'\n\n# ------------- generated code --------------\n\nmodule BasicTest\n  pool = Google::Protobuf::DescriptorPool.new\n  pool.build do\n    add_message \"Foo\" do\n      optional :bar, :message, 1, \"Bar\"\n      repeated :baz, :message, 2, \"Baz\"\n    end\n\n    add_message \"Bar\" do\n      optional :msg, :string, 1\n    end\n\n    add_message \"Baz\" do\n      optional :msg, :string, 1\n    end\n\n    add_message \"TestMessage\" do\n      optional :optional_int32,  :int32,        1\n      optional :optional_int64,  :int64,        2\n      optional :optional_uint32, :uint32,       3\n      optional :optional_uint64, :uint64,       4\n      optional :optional_bool,   :bool,         5\n      optional :optional_float,  :float,        6\n      optional :optional_double, :double,       7\n      optional :optional_string, :string,       8\n      optional :optional_bytes,  :bytes,        9\n      optional :optional_msg,    :message,      10, \"TestMessage2\"\n      optional :optional_enum,   :enum,         11, \"TestEnum\"\n\n      repeated :repeated_int32,  :int32,        12\n      repeated :repeated_int64,  :int64,        13\n      repeated :repeated_uint32, :uint32,       14\n      repeated :repeated_uint64, :uint64,       15\n      repeated :repeated_bool,   :bool,         16\n      repeated :repeated_float,  :float,        17\n      repeated :repeated_double, :double,       18\n      repeated :repeated_string, :string,       19\n      repeated :repeated_bytes,  :bytes,        20\n      repeated :repeated_msg,    :message,      21, \"TestMessage2\"\n      repeated :repeated_enum,   :enum,         22, \"TestEnum\"\n    end\n    add_message \"TestMessage2\" do\n      optional :foo, :int32, 1\n    end\n\n    add_message \"Recursive1\" do\n      optional :foo, :message, 1, \"Recursive2\"\n    end\n    add_message \"Recursive2\" do\n      optional :foo, :message, 1, \"Recursive1\"\n    end\n\n    add_enum \"TestEnum\" do\n      value :Default, 0\n      value :A, 1\n      value :B, 2\n      value :C, 3\n    end\n\n    add_message \"BadFieldNames\" do\n      optional :dup, :int32, 1\n      optional :class, :int32, 2\n    end\n\n    add_message \"MapMessage\" do\n      map :map_string_int32, :string, :int32, 1\n      map :map_string_msg, :string, :message, 2, \"TestMessage2\"\n    end\n    add_message \"MapMessageWireEquiv\" do\n      repeated :map_string_int32, :message, 1, \"MapMessageWireEquiv_entry1\"\n      repeated :map_string_msg, :message, 2, \"MapMessageWireEquiv_entry2\"\n    end\n    add_message \"MapMessageWireEquiv_entry1\" do\n      optional :key, :string, 1\n      optional :value, :int32, 2\n    end\n    add_message \"MapMessageWireEquiv_entry2\" do\n      optional :key, :string, 1\n      optional :value, :message, 2, \"TestMessage2\"\n    end\n\n    add_message \"OneofMessage\" do\n      oneof :my_oneof do\n        optional :a, :string, 1\n        optional :b, :int32, 2\n        optional :c, :message, 3, \"TestMessage2\"\n        optional :d, :enum, 4, \"TestEnum\"\n      end\n    end\n  end\n\n  Foo = pool.lookup(\"Foo\").msgclass\n  Bar = pool.lookup(\"Bar\").msgclass\n  Baz = pool.lookup(\"Baz\").msgclass\n  TestMessage = pool.lookup(\"TestMessage\").msgclass\n  TestMessage2 = pool.lookup(\"TestMessage2\").msgclass\n  Recursive1 = pool.lookup(\"Recursive1\").msgclass\n  Recursive2 = pool.lookup(\"Recursive2\").msgclass\n  TestEnum = pool.lookup(\"TestEnum\").enummodule\n  BadFieldNames = pool.lookup(\"BadFieldNames\").msgclass\n  MapMessage = pool.lookup(\"MapMessage\").msgclass\n  MapMessageWireEquiv = pool.lookup(\"MapMessageWireEquiv\").msgclass\n  MapMessageWireEquiv_entry1 =\n    pool.lookup(\"MapMessageWireEquiv_entry1\").msgclass\n  MapMessageWireEquiv_entry2 =\n    pool.lookup(\"MapMessageWireEquiv_entry2\").msgclass\n  OneofMessage = pool.lookup(\"OneofMessage\").msgclass\n\n# ------------ test cases ---------------\n\n  class MessageContainerTest < Test::Unit::TestCase\n\n    def test_defaults\n      m = TestMessage.new\n      assert m.optional_int32 == 0\n      assert m.optional_int64 == 0\n      assert m.optional_uint32 == 0\n      assert m.optional_uint64 == 0\n      assert m.optional_bool == false\n      assert m.optional_float == 0.0\n      assert m.optional_double == 0.0\n      assert m.optional_string == \"\"\n      assert m.optional_bytes == \"\"\n      assert m.optional_msg == nil\n      assert m.optional_enum == :Default\n    end\n\n    def test_setters\n      m = TestMessage.new\n      m.optional_int32 = -42\n      assert m.optional_int32 == -42\n      m.optional_int64 = -0x1_0000_0000\n      assert m.optional_int64 == -0x1_0000_0000\n      m.optional_uint32 = 0x9000_0000\n      assert m.optional_uint32 == 0x9000_0000\n      m.optional_uint64 = 0x9000_0000_0000_0000\n      assert m.optional_uint64 == 0x9000_0000_0000_0000\n      m.optional_bool = true\n      assert m.optional_bool == true\n      m.optional_float = 0.5\n      assert m.optional_float == 0.5\n      m.optional_double = 0.5\n      m.optional_string = \"hello\"\n      assert m.optional_string == \"hello\"\n      m.optional_bytes = \"world\".encode!('ASCII-8BIT')\n      assert m.optional_bytes == \"world\"\n      m.optional_msg = TestMessage2.new(:foo => 42)\n      assert m.optional_msg == TestMessage2.new(:foo => 42)\n      m.optional_msg = nil\n      assert m.optional_msg == nil\n    end\n\n    def test_ctor_args\n      m = TestMessage.new(:optional_int32 => -42,\n                          :optional_msg => TestMessage2.new,\n                          :optional_enum => :C,\n                          :repeated_string => [\"hello\", \"there\", \"world\"])\n      assert m.optional_int32 == -42\n      assert m.optional_msg.class == TestMessage2\n      assert m.repeated_string.length == 3\n      assert m.optional_enum == :C\n      assert m.repeated_string[0] == \"hello\"\n      assert m.repeated_string[1] == \"there\"\n      assert m.repeated_string[2] == \"world\"\n    end\n\n    def test_inspect\n      m = TestMessage.new(:optional_int32 => -42,\n                          :optional_enum => :A,\n                          :optional_msg => TestMessage2.new,\n                          :repeated_string => [\"hello\", \"there\", \"world\"])\n      expected = '<BasicTest::TestMessage: optional_int32: -42, optional_int64: 0, optional_uint32: 0, optional_uint64: 0, optional_bool: false, optional_float: 0.0, optional_double: 0.0, optional_string: \"\", optional_bytes: \"\", optional_msg: <BasicTest::TestMessage2: foo: 0>, optional_enum: :A, repeated_int32: [], repeated_int64: [], repeated_uint32: [], repeated_uint64: [], repeated_bool: [], repeated_float: [], repeated_double: [], repeated_string: [\"hello\", \"there\", \"world\"], repeated_bytes: [], repeated_msg: [], repeated_enum: []>'\n      assert_equal expected, m.inspect\n    end\n\n    def test_hash\n      m1 = TestMessage.new(:optional_int32 => 42)\n      m2 = TestMessage.new(:optional_int32 => 102)\n      assert m1.hash != 0\n      assert m2.hash != 0\n      # relying on the randomness here -- if hash function changes and we are\n      # unlucky enough to get a collision, then change the values above.\n      assert m1.hash != m2.hash\n    end\n\n    def test_unknown_field_errors\n      e = assert_raise NoMethodError do\n        TestMessage.new.hello\n      end\n      assert_match(/hello/, e.message)\n\n      e = assert_raise NoMethodError do\n        TestMessage.new.hello = \"world\"\n      end\n      assert_match(/hello/, e.message)\n    end\n\n    def test_initialization_map_errors\n      e = assert_raise ArgumentError do\n        TestMessage.new(:hello => \"world\")\n      end\n      assert_match(/hello/, e.message)\n\n      e = assert_raise ArgumentError do\n        MapMessage.new(:map_string_int32 => \"hello\")\n      end\n      assert_equal e.message, \"Expected Hash object as initializer value for map field 'map_string_int32' (given String).\"\n\n      e = assert_raise ArgumentError do\n        TestMessage.new(:repeated_uint32 => \"hello\")\n      end\n      assert_equal e.message, \"Expected array as initializer value for repeated field 'repeated_uint32' (given String).\"\n    end\n\n    def test_type_errors\n      m = TestMessage.new\n\n      # Use rescue to allow subclasses of error\n      success = false\n      begin\n        m.optional_int32 = \"hello\"\n      rescue TypeError\n        success = true\n      end\n      assert(success)\n\n      success = false\n      begin\n        m.optional_string = nil\n      rescue TypeError\n        success = true\n      end\n      assert(success)\n\n      success = false\n      begin\n        m.optional_bool = 42\n      rescue TypeError\n        success = true\n      end\n      assert(success)\n\n      success = false\n      begin\n        m.optional_msg = TestMessage.new  # expects TestMessage2\n      rescue TypeError\n        success = true\n      end\n      assert(success)\n\n      success = false\n      begin\n        m.repeated_int32 = []  # needs RepeatedField\n      rescue TypeError\n        success = true\n      end\n      assert(success)\n\n      success = false\n      begin\n        m.repeated_msg.push TestMessage.new\n      rescue TypeError\n        success = true\n      end\n      assert(success)\n    end\n\n    def test_string_encoding\n      m = TestMessage.new\n\n      # Assigning a normal (ASCII or UTF8) string to a bytes field, or\n      # ASCII-8BIT to a string field will convert to the proper encoding.\n      m.optional_bytes = \"Test string ASCII\".encode!('ASCII')\n      assert m.optional_bytes.frozen?\n      assert_equal Encoding::ASCII_8BIT, m.optional_bytes.encoding\n      assert_equal \"Test string ASCII\", m.optional_bytes\n\n      assert_raise Encoding::UndefinedConversionError do\n        m.optional_bytes = \"Test string UTF-8 \\u0100\".encode!('UTF-8')\n      end\n\n      assert_raise Encoding::UndefinedConversionError do\n        m.optional_string = [\"FFFF\"].pack('H*')\n      end\n\n      # \"Ordinary\" use case.\n      m.optional_bytes = [\"FFFF\"].pack('H*')\n      m.optional_string = \"\\u0100\"\n\n      # strings are immutable so we can't do this, but serialize should catch it.\n      m.optional_string = \"asdf\".encode!('UTF-8')\n      assert_raise do\n        m.optional_string.encode!('ASCII-8BIT')\n      end\n    end\n\n    def test_rptfield_int32\n      l = Google::Protobuf::RepeatedField.new(:int32)\n      assert l.count == 0\n      l = Google::Protobuf::RepeatedField.new(:int32, [1, 2, 3])\n      assert l.count == 3\n      assert_equal [1, 2, 3], l\n      assert_equal l, [1, 2, 3]\n      l.push 4\n      assert l == [1, 2, 3, 4]\n      dst_list = []\n      l.each { |val| dst_list.push val }\n      assert dst_list == [1, 2, 3, 4]\n      assert l.to_a == [1, 2, 3, 4]\n      assert l[0] == 1\n      assert l[3] == 4\n      l[0] = 5\n      assert l == [5, 2, 3, 4]\n\n      l2 = l.dup\n      assert l == l2\n      assert l.object_id != l2.object_id\n      l2.push 6\n      assert l.count == 4\n      assert l2.count == 5\n\n      assert l.inspect == '[5, 2, 3, 4]'\n\n      l.concat([7, 8, 9])\n      assert l == [5, 2, 3, 4, 7, 8, 9]\n      assert l.pop == 9\n      assert l == [5, 2, 3, 4, 7, 8]\n\n      success = false\n      begin\n        m = TestMessage.new\n        l.push m\n      rescue TypeError\n        success = true\n      end\n      assert(success)\n\n      m = TestMessage.new\n      m.repeated_int32 = l\n      assert m.repeated_int32 == [5, 2, 3, 4, 7, 8]\n      assert m.repeated_int32.object_id == l.object_id\n      l.push 42\n      assert m.repeated_int32.pop == 42\n\n      l3 = l + l.dup\n      assert l3.count == l.count * 2\n      l.count.times do |i|\n        assert l3[i] == l[i]\n        assert l3[l.count + i] == l[i]\n      end\n\n      l.clear\n      assert l.count == 0\n      l += [1, 2, 3, 4]\n      l.replace([5, 6, 7, 8])\n      assert l == [5, 6, 7, 8]\n\n      l4 = Google::Protobuf::RepeatedField.new(:int32)\n      l4[5] = 42\n      assert l4 == [0, 0, 0, 0, 0, 42]\n\n      l4 << 100\n      assert l4 == [0, 0, 0, 0, 0, 42, 100]\n      l4 << 101 << 102\n      assert l4 == [0, 0, 0, 0, 0, 42, 100, 101, 102]\n    end\n\n    def test_parent_rptfield\n      #make sure we set the RepeatedField and can add to it\n      m = TestMessage.new\n      assert m.repeated_string == []\n      m.repeated_string << 'ok'\n      m.repeated_string.push('ok2')\n      assert m.repeated_string == ['ok', 'ok2']\n      m.repeated_string += ['ok3']\n      assert m.repeated_string == ['ok', 'ok2', 'ok3']\n    end\n\n    def test_rptfield_msg\n      l = Google::Protobuf::RepeatedField.new(:message, TestMessage)\n      l.push TestMessage.new\n      assert l.count == 1\n\n      success = false\n      begin\n        l.push TestMessage2.new\n      rescue TypeError\n        success = true\n      end\n      assert(success)\n\n      success = false\n      begin\n        l.push 42\n      rescue TypeError\n        success = true\n      end\n      assert(success)\n\n      l2 = l.dup\n      assert l2[0] == l[0]\n      assert l2[0].object_id == l[0].object_id\n\n      l2 = Google::Protobuf.deep_copy(l)\n      assert l2[0] == l[0]\n      assert l2[0].object_id != l[0].object_id\n\n      l3 = l + l2\n      assert l3.count == 2\n      assert l3[0] == l[0]\n      assert l3[1] == l2[0]\n      l3[0].optional_int32 = 1000\n      assert l[0].optional_int32 == 1000\n\n      new_msg = TestMessage.new(:optional_int32 => 200)\n      l4 = l + [new_msg]\n      assert l4.count == 2\n      new_msg.optional_int32 = 1000\n      assert l4[1].optional_int32 == 1000\n    end\n\n    def test_rptfield_enum\n      l = Google::Protobuf::RepeatedField.new(:enum, TestEnum)\n      l.push :A\n      l.push :B\n      l.push :C\n      assert l.count == 3\n      assert_raise RangeError do\n        l.push :D\n      end\n      assert l[0] == :A\n\n      l.push 4\n      assert l[3] == 4\n    end\n\n    def test_rptfield_initialize\n      assert_raise ArgumentError do\n        l = Google::Protobuf::RepeatedField.new\n      end\n      assert_raise ArgumentError do\n        l = Google::Protobuf::RepeatedField.new(:message)\n      end\n      assert_raise ArgumentError do\n        l = Google::Protobuf::RepeatedField.new([1, 2, 3])\n      end\n      assert_raise ArgumentError do\n        l = Google::Protobuf::RepeatedField.new(:message, [TestMessage2.new])\n      end\n    end\n\n    def test_rptfield_array_ducktyping\n      l = Google::Protobuf::RepeatedField.new(:int32)\n      length_methods = %w(count length size)\n      length_methods.each do |lm|\n        assert l.send(lm)  == 0\n      end\n      # out of bounds returns a nil\n      assert l[0] == nil\n      assert l[1] == nil\n      assert l[-1] == nil\n      l.push 4\n      length_methods.each do |lm|\n        assert l.send(lm) == 1\n      end\n      assert l[0] == 4\n      assert l[1] == nil\n      assert l[-1] == 4\n      assert l[-2] == nil\n\n      l.push 2\n      length_methods.each do |lm|\n        assert l.send(lm) == 2\n      end\n      assert l[0] == 4\n      assert l[1] == 2\n      assert l[2] == nil\n      assert l[-1] == 2\n      assert l[-2] == 4\n      assert l[-3] == nil\n\n      #adding out of scope will backfill with empty objects\n    end\n\n    def test_map_basic\n      # allowed key types:\n      # :int32, :int64, :uint32, :uint64, :bool, :string, :bytes.\n\n      m = Google::Protobuf::Map.new(:string, :int32)\n      m[\"asdf\"] = 1\n      assert m[\"asdf\"] == 1\n      m[\"jkl;\"] = 42\n      assert m == { \"jkl;\" => 42, \"asdf\" => 1 }\n      assert m.has_key?(\"asdf\")\n      assert !m.has_key?(\"qwerty\")\n      assert m.length == 2\n\n      m2 = m.dup\n      assert m == m2\n      assert m.hash != 0\n      assert m.hash == m2.hash\n\n      collected = {}\n      m.each { |k,v| collected[v] = k }\n      assert collected == { 42 => \"jkl;\", 1 => \"asdf\" }\n\n      assert m.delete(\"asdf\") == 1\n      assert !m.has_key?(\"asdf\")\n      assert m[\"asdf\"] == nil\n      assert !m.has_key?(\"asdf\")\n\n      # We only assert on inspect value when there is one map entry because the\n      # order in which elements appear is unspecified (depends on the internal\n      # hash function). We don't want a brittle test.\n      assert m.inspect == \"{\\\"jkl;\\\"=>42}\"\n\n      assert m.keys == [\"jkl;\"]\n      assert m.values == [42]\n\n      m.clear\n      assert m.length == 0\n      assert m == {}\n\n      success = false\n      begin\n        m[1] = 1\n      rescue TypeError\n        success = true\n      end\n      assert(success)\n\n      assert_raise RangeError do\n        m[\"asdf\"] = 0x1_0000_0000\n      end\n    end\n\n    def test_map_ctor\n      m = Google::Protobuf::Map.new(:string, :int32,\n                                    {\"a\" => 1, \"b\" => 2, \"c\" => 3})\n      assert m == {\"a\" => 1, \"c\" => 3, \"b\" => 2}\n    end\n\n    def test_map_keytypes\n      m = Google::Protobuf::Map.new(:int32, :int32)\n      m[1] = 42\n      m[-1] = 42\n      assert_raise RangeError do\n        m[0x8000_0000] = 1\n      end\n\n      success = false\n      begin\n        m[\"asdf\"] = 1\n      rescue TypeError\n        success = true\n      end\n      assert(success)\n\n      m = Google::Protobuf::Map.new(:int64, :int32)\n      m[0x1000_0000_0000_0000] = 1\n      assert_raise RangeError do\n        m[0x1_0000_0000_0000_0000] = 1\n      end\n\n      success = false\n      begin\n        m[\"asdf\"] = 1\n      rescue TypeError\n        success = true\n      end\n      assert(success)\n\n      m = Google::Protobuf::Map.new(:uint32, :int32)\n      m[0x8000_0000] = 1\n      assert_raise RangeError do\n        m[0x1_0000_0000] = 1\n      end\n      assert_raise RangeError do\n        m[-1] = 1\n      end\n\n      m = Google::Protobuf::Map.new(:uint64, :int32)\n      m[0x8000_0000_0000_0000] = 1\n      assert_raise RangeError do\n        m[0x1_0000_0000_0000_0000] = 1\n      end\n      assert_raise RangeError do\n        m[-1] = 1\n      end\n\n      m = Google::Protobuf::Map.new(:bool, :int32)\n      m[true] = 1\n      m[false] = 2\n\n      success = false\n      begin\n        m[1] = 1\n      rescue TypeError\n        success = true\n      end\n      assert(success)\n\n      success = false\n      begin\n        m[\"asdf\"] = 1\n      rescue TypeError\n        success = true\n      end\n      assert(success)\n\n      m = Google::Protobuf::Map.new(:string, :int32)\n      m[\"asdf\"] = 1\n      success = false\n      begin\n        m[1] = 1\n      rescue TypeError\n        success = true\n      end\n      assert(success)\n      assert_raise Encoding::UndefinedConversionError do\n        bytestring = [\"FFFF\"].pack(\"H*\")\n        m[bytestring] = 1\n      end\n\n      m = Google::Protobuf::Map.new(:bytes, :int32)\n      bytestring = [\"FFFF\"].pack(\"H*\")\n      m[bytestring] = 1\n      # Allowed -- we will automatically convert to ASCII-8BIT.\n      m[\"asdf\"] = 1\n      success = false\n      begin\n        m[1] = 1\n      rescue TypeError\n        success = true\n      end\n      assert(success)\n    end\n\n    def test_map_msg_enum_valuetypes\n      m = Google::Protobuf::Map.new(:string, :message, TestMessage)\n      m[\"asdf\"] = TestMessage.new\n      success = false\n      begin\n        m[\"jkl;\"] = TestMessage2.new\n      rescue TypeError\n        success = true\n      end\n      assert(success)\n\n      m = Google::Protobuf::Map.new(\n        :string, :message, TestMessage,\n        { \"a\" => TestMessage.new(:optional_int32 => 42),\n          \"b\" => TestMessage.new(:optional_int32 => 84) })\n      assert m.length == 2\n      assert m.values.map{|msg| msg.optional_int32}.sort == [42, 84]\n\n      m = Google::Protobuf::Map.new(:string, :enum, TestEnum,\n                                    { \"x\" => :A, \"y\" => :B, \"z\" => :C })\n      assert m.length == 3\n      assert m[\"z\"] == :C\n      m[\"z\"] = 2\n      assert m[\"z\"] == :B\n      m[\"z\"] = 5\n      assert m[\"z\"] == 5\n      assert_raise RangeError do\n        m[\"z\"] = :Z\n      end\n      assert_raise RangeError do\n        m[\"z\"] = \"z\"\n      end\n    end\n\n    def test_map_dup_deep_copy\n      m = Google::Protobuf::Map.new(\n        :string, :message, TestMessage,\n        { \"a\" => TestMessage.new(:optional_int32 => 42),\n          \"b\" => TestMessage.new(:optional_int32 => 84) })\n\n      m2 = m.dup\n      assert m == m2\n      assert m.object_id != m2.object_id\n      assert m[\"a\"].object_id == m2[\"a\"].object_id\n      assert m[\"b\"].object_id == m2[\"b\"].object_id\n\n      m2 = Google::Protobuf.deep_copy(m)\n      assert m == m2\n      assert m.object_id != m2.object_id\n      assert m[\"a\"].object_id != m2[\"a\"].object_id\n      assert m[\"b\"].object_id != m2[\"b\"].object_id\n    end\n\n    def test_map_field\n      m = MapMessage.new\n      assert m.map_string_int32 == {}\n      assert m.map_string_msg == {}\n\n      m = MapMessage.new(\n        :map_string_int32 => {\"a\" => 1, \"b\" => 2},\n        :map_string_msg => {\"a\" => TestMessage2.new(:foo => 1),\n                            \"b\" => TestMessage2.new(:foo => 2)})\n      assert m.map_string_int32.keys.sort == [\"a\", \"b\"]\n      assert m.map_string_int32[\"a\"] == 1\n      assert m.map_string_msg[\"b\"].foo == 2\n\n      m.map_string_int32[\"c\"] = 3\n      assert m.map_string_int32[\"c\"] == 3\n      m.map_string_msg[\"c\"] = TestMessage2.new(:foo => 3)\n      assert m.map_string_msg[\"c\"] == TestMessage2.new(:foo => 3)\n      m.map_string_msg.delete(\"b\")\n      m.map_string_msg.delete(\"c\")\n      assert m.map_string_msg == { \"a\" => TestMessage2.new(:foo => 1) }\n\n      success = false\n      begin\n        m.map_string_msg[\"e\"] = TestMessage.new # wrong value type\n      rescue TypeError\n        success = true\n      end\n      assert(success)\n      # ensure nothing was added by the above\n      assert m.map_string_msg == { \"a\" => TestMessage2.new(:foo => 1) }\n\n      m.map_string_int32 = Google::Protobuf::Map.new(:string, :int32)\n      success = false\n      begin\n        m.map_string_int32 = Google::Protobuf::Map.new(:string, :int64)\n      rescue TypeError\n        success = true\n      end\n      assert(success)\n      success = false\n      begin\n        m.map_string_int32 = {}\n      rescue TypeError\n        success = true\n      end\n      assert(success)\n\n      success = false\n      begin\n        m = MapMessage.new(:map_string_int32 => { 1 => \"I am not a number\" })\n      rescue TypeError\n        success = true\n      end\n      assert(success)\n    end\n\n    def test_map_encode_decode\n      m = MapMessage.new(\n        :map_string_int32 => {\"a\" => 1, \"b\" => 2},\n        :map_string_msg => {\"a\" => TestMessage2.new(:foo => 1),\n                            \"b\" => TestMessage2.new(:foo => 2)})\n      m2 = MapMessage.decode(MapMessage.encode(m))\n      assert m == m2\n\n      m3 = MapMessageWireEquiv.decode(MapMessage.encode(m))\n      assert m3.map_string_int32.length == 2\n\n      kv = {}\n      m3.map_string_int32.map { |msg| kv[msg.key] = msg.value }\n      assert kv == {\"a\" => 1, \"b\" => 2}\n\n      kv = {}\n      m3.map_string_msg.map { |msg| kv[msg.key] = msg.value }\n      assert kv == {\"a\" => TestMessage2.new(:foo => 1),\n                    \"b\" => TestMessage2.new(:foo => 2)}\n    end\n\n    def test_oneof_descriptors\n      d = OneofMessage.descriptor\n      o = d.lookup_oneof(\"my_oneof\")\n      assert o != nil\n      assert o.class == Google::Protobuf::OneofDescriptor\n      assert o.name == \"my_oneof\"\n      oneof_count = 0\n      d.each_oneof{ |oneof|\n        oneof_count += 1\n        assert oneof == o\n      }\n      assert oneof_count == 1\n      assert o.count == 4\n      field_names = o.map{|f| f.name}.sort\n      assert field_names == [\"a\", \"b\", \"c\", \"d\"]\n    end\n\n    def test_oneof\n      d = OneofMessage.new\n      assert d.a == \"\"\n      assert d.b == 0\n      assert d.c == nil\n      assert d.d == :Default\n      assert d.my_oneof == nil\n\n      d.a = \"hi\"\n      assert d.a == \"hi\"\n      assert d.b == 0\n      assert d.c == nil\n      assert d.d == :Default\n      assert d.my_oneof == :a\n\n      d.b = 42\n      assert d.a == \"\"\n      assert d.b == 42\n      assert d.c == nil\n      assert d.d == :Default\n      assert d.my_oneof == :b\n\n      d.c = TestMessage2.new(:foo => 100)\n      assert d.a == \"\"\n      assert d.b == 0\n      assert d.c.foo == 100\n      assert d.d == :Default\n      assert d.my_oneof == :c\n\n      d.d = :C\n      assert d.a == \"\"\n      assert d.b == 0\n      assert d.c == nil\n      assert d.d == :C\n      assert d.my_oneof == :d\n\n      d2 = OneofMessage.decode(OneofMessage.encode(d))\n      assert d2 == d\n\n      encoded_field_a = OneofMessage.encode(OneofMessage.new(:a => \"string\"))\n      encoded_field_b = OneofMessage.encode(OneofMessage.new(:b => 1000))\n      encoded_field_c = OneofMessage.encode(\n        OneofMessage.new(:c => TestMessage2.new(:foo => 1)))\n      encoded_field_d = OneofMessage.encode(OneofMessage.new(:d => :B))\n\n      d3 = OneofMessage.decode(\n        encoded_field_c + encoded_field_a + encoded_field_d)\n      assert d3.a == \"\"\n      assert d3.b == 0\n      assert d3.c == nil\n      assert d3.d == :B\n\n      d4 = OneofMessage.decode(\n        encoded_field_c + encoded_field_a + encoded_field_d +\n        encoded_field_c)\n      assert d4.a == \"\"\n      assert d4.b == 0\n      assert d4.c.foo == 1\n      assert d4.d == :Default\n\n      d5 = OneofMessage.new(:a => \"hello\")\n      assert d5.a == \"hello\"\n      d5.a = nil\n      assert d5.a == \"\"\n      assert OneofMessage.encode(d5) == ''\n      assert d5.my_oneof == nil\n    end\n\n    def test_enum_field\n      m = TestMessage.new\n      assert m.optional_enum == :Default\n      m.optional_enum = :A\n      assert m.optional_enum == :A\n      assert_raise RangeError do\n        m.optional_enum = :ASDF\n      end\n      m.optional_enum = 1\n      assert m.optional_enum == :A\n      m.optional_enum = 100\n      assert m.optional_enum == 100\n    end\n\n    def test_dup\n      m = TestMessage.new\n      m.optional_string = \"hello\"\n      m.optional_int32 = 42\n      tm1 = TestMessage2.new(:foo => 100)\n      tm2 = TestMessage2.new(:foo => 200)\n      m.repeated_msg.push tm1\n      assert m.repeated_msg[-1] == tm1\n      m.repeated_msg.push tm2\n      assert m.repeated_msg[-1] == tm2\n      m2 = m.dup\n      assert m == m2\n      m.optional_int32 += 1\n      assert m != m2\n      assert m.repeated_msg[0] == m2.repeated_msg[0]\n      assert m.repeated_msg[0].object_id == m2.repeated_msg[0].object_id\n    end\n\n    def test_deep_copy\n      m = TestMessage.new(:optional_int32 => 42,\n                          :repeated_msg => [TestMessage2.new(:foo => 100)])\n      m2 = Google::Protobuf.deep_copy(m)\n      assert m == m2\n      assert m.repeated_msg == m2.repeated_msg\n      assert m.repeated_msg.object_id != m2.repeated_msg.object_id\n      assert m.repeated_msg[0].object_id != m2.repeated_msg[0].object_id\n    end\n\n    def test_eq\n      m = TestMessage.new(:optional_int32 => 42,\n                          :repeated_int32 => [1, 2, 3])\n      m2 = TestMessage.new(:optional_int32 => 43,\n                           :repeated_int32 => [1, 2, 3])\n      assert m != m2\n    end\n\n    def test_enum_lookup\n      assert TestEnum::A == 1\n      assert TestEnum::B == 2\n      assert TestEnum::C == 3\n\n      assert TestEnum::lookup(1) == :A\n      assert TestEnum::lookup(2) == :B\n      assert TestEnum::lookup(3) == :C\n\n      assert TestEnum::resolve(:A) == 1\n      assert TestEnum::resolve(:B) == 2\n      assert TestEnum::resolve(:C) == 3\n    end\n\n    def test_parse_serialize\n      m = TestMessage.new(:optional_int32 => 42,\n                          :optional_string => \"hello world\",\n                          :optional_enum => :B,\n                          :repeated_string => [\"a\", \"b\", \"c\"],\n                          :repeated_int32 => [42, 43, 44],\n                          :repeated_enum => [:A, :B, :C, 100],\n                          :repeated_msg => [TestMessage2.new(:foo => 1),\n                                            TestMessage2.new(:foo => 2)])\n      data = TestMessage.encode m\n      m2 = TestMessage.decode data\n      assert m == m2\n\n      data = Google::Protobuf.encode m\n      m2 = Google::Protobuf.decode(TestMessage, data)\n      assert m == m2\n    end\n\n    def test_encode_decode_helpers\n      m = TestMessage.new(:optional_string => 'foo', :repeated_string => ['bar1', 'bar2'])\n      assert_equal 'foo', m.optional_string\n      assert_equal ['bar1', 'bar2'], m.repeated_string\n\n      json = m.to_json\n      m2 = TestMessage.decode_json(json)\n      assert_equal 'foo', m2.optional_string\n      assert_equal ['bar1', 'bar2'], m2.repeated_string\n      if RUBY_PLATFORM != \"java\"\n        assert m2.optional_string.frozen?\n        assert m2.repeated_string[0].frozen?\n      end\n\n      proto = m.to_proto\n      m2 = TestMessage.decode(proto)\n      assert_equal 'foo', m2.optional_string\n      assert_equal ['bar1', 'bar2'], m2.repeated_string\n    end\n\n    def test_protobuf_encode_decode_helpers\n      m = TestMessage.new(:optional_string => 'foo', :repeated_string => ['bar1', 'bar2'])\n      encoded_msg = Google::Protobuf.encode(m)\n      assert_equal m.to_proto, encoded_msg\n\n      decoded_msg = Google::Protobuf.decode(TestMessage, encoded_msg)\n      assert_equal TestMessage.decode(m.to_proto), decoded_msg\n    end\n\n    def test_protobuf_encode_decode_json_helpers\n      m = TestMessage.new(:optional_string => 'foo', :repeated_string => ['bar1', 'bar2'])\n      encoded_msg = Google::Protobuf.encode_json(m)\n      assert_equal m.to_json, encoded_msg\n\n      decoded_msg = Google::Protobuf.decode_json(TestMessage, encoded_msg)\n      assert_equal TestMessage.decode_json(m.to_json), decoded_msg\n    end\n\n    def test_to_h\n      m = TestMessage.new(:optional_bool => true, :optional_double => -10.100001, :optional_string => 'foo', :repeated_string => ['bar1', 'bar2'])\n      expected_result = {\n        :optional_bool=>true,\n        :optional_bytes=>\"\",\n        :optional_double=>-10.100001,\n        :optional_enum=>:Default,\n        :optional_float=>0.0,\n        :optional_int32=>0,\n        :optional_int64=>0,\n        :optional_msg=>nil,\n        :optional_string=>\"foo\",\n        :optional_uint32=>0,\n        :optional_uint64=>0,\n        :repeated_bool=>[],\n        :repeated_bytes=>[],\n        :repeated_double=>[],\n        :repeated_enum=>[],\n        :repeated_float=>[],\n        :repeated_int32=>[],\n        :repeated_int64=>[],\n        :repeated_msg=>[],\n        :repeated_string=>[\"bar1\", \"bar2\"],\n        :repeated_uint32=>[],\n        :repeated_uint64=>[]\n      }\n      assert_equal expected_result, m.to_h\n    end\n\n\n    def test_def_errors\n      s = Google::Protobuf::DescriptorPool.new\n      success = false\n      begin\n        s.build do\n          # enum with no default (integer value 0)\n          add_enum \"MyEnum\" do\n            value :A, 1\n          end\n        end\n      rescue TypeError\n        success = true\n      end\n      assert(success)\n      success = false\n      begin\n        s.build do\n          # message with required field (unsupported in proto3)\n          add_message \"MyMessage\" do\n            required :foo, :int32, 1\n          end\n        end\n      rescue TypeError\n        success = true\n      end\n      assert(success)\n    end\n\n    def test_corecursive\n      # just be sure that we can instantiate types with corecursive field-type\n      # references.\n      m = Recursive1.new(:foo => Recursive2.new(:foo => Recursive1.new))\n      assert Recursive1.descriptor.lookup(\"foo\").subtype ==\n        Recursive2.descriptor\n      assert Recursive2.descriptor.lookup(\"foo\").subtype ==\n        Recursive1.descriptor\n\n      serialized = Recursive1.encode(m)\n      m2 = Recursive1.decode(serialized)\n      assert m == m2\n    end\n\n    def test_serialize_cycle\n      m = Recursive1.new(:foo => Recursive2.new)\n      m.foo.foo = m\n      assert_raise RuntimeError do\n        serialized = Recursive1.encode(m)\n      end\n    end\n\n    def test_bad_field_names\n      m = BadFieldNames.new(:dup => 1, :class => 2)\n      m2 = m.dup\n      assert m == m2\n      assert m['dup'] == 1\n      assert m['class'] == 2\n      m['dup'] = 3\n      assert m['dup'] == 3\n    end\n\n    def test_int_ranges\n      m = TestMessage.new\n\n      m.optional_int32 = 0\n      m.optional_int32 = -0x8000_0000\n      m.optional_int32 = +0x7fff_ffff\n      m.optional_int32 = 1.0\n      m.optional_int32 = -1.0\n      m.optional_int32 = 2e9\n      assert_raise RangeError do\n        m.optional_int32 = -0x8000_0001\n      end\n      assert_raise RangeError do\n        m.optional_int32 = +0x8000_0000\n      end\n      assert_raise RangeError do\n        m.optional_int32 = +0x1000_0000_0000_0000_0000_0000 # force Bignum\n      end\n      assert_raise RangeError do\n        m.optional_int32 = 1e12\n      end\n      assert_raise RangeError do\n        m.optional_int32 = 1.5\n      end\n\n      m.optional_uint32 = 0\n      m.optional_uint32 = +0xffff_ffff\n      m.optional_uint32 = 1.0\n      m.optional_uint32 = 4e9\n      assert_raise RangeError do\n        m.optional_uint32 = -1\n      end\n      assert_raise RangeError do\n        m.optional_uint32 = -1.5\n      end\n      assert_raise RangeError do\n        m.optional_uint32 = -1.5e12\n      end\n      assert_raise RangeError do\n        m.optional_uint32 = -0x1000_0000_0000_0000\n      end\n      assert_raise RangeError do\n        m.optional_uint32 = +0x1_0000_0000\n      end\n      assert_raise RangeError do\n        m.optional_uint32 = +0x1000_0000_0000_0000_0000_0000 # force Bignum\n      end\n      assert_raise RangeError do\n        m.optional_uint32 = 1e12\n      end\n      assert_raise RangeError do\n        m.optional_uint32 = 1.5\n      end\n\n      m.optional_int64 = 0\n      m.optional_int64 = -0x8000_0000_0000_0000\n      m.optional_int64 = +0x7fff_ffff_ffff_ffff\n      m.optional_int64 = 1.0\n      m.optional_int64 = -1.0\n      m.optional_int64 = 8e18\n      m.optional_int64 = -8e18\n      assert_raise RangeError do\n        m.optional_int64 = -0x8000_0000_0000_0001\n      end\n      assert_raise RangeError do\n        m.optional_int64 = +0x8000_0000_0000_0000\n      end\n      assert_raise RangeError do\n        m.optional_int64 = +0x1000_0000_0000_0000_0000_0000 # force Bignum\n      end\n      assert_raise RangeError do\n        m.optional_int64 = 1e50\n      end\n      assert_raise RangeError do\n        m.optional_int64 = 1.5\n      end\n\n      m.optional_uint64 = 0\n      m.optional_uint64 = +0xffff_ffff_ffff_ffff\n      m.optional_uint64 = 1.0\n      m.optional_uint64 = 16e18\n      assert_raise RangeError do\n        m.optional_uint64 = -1\n      end\n      assert_raise RangeError do\n        m.optional_uint64 = -1.5\n      end\n      assert_raise RangeError do\n        m.optional_uint64 = -1.5e12\n      end\n      assert_raise RangeError do\n        m.optional_uint64 = -0x1_0000_0000_0000_0000\n      end\n      assert_raise RangeError do\n        m.optional_uint64 = +0x1_0000_0000_0000_0000\n      end\n      assert_raise RangeError do\n        m.optional_uint64 = +0x1000_0000_0000_0000_0000_0000 # force Bignum\n      end\n      assert_raise RangeError do\n        m.optional_uint64 = 1e50\n      end\n      assert_raise RangeError do\n        m.optional_uint64 = 1.5\n      end\n    end\n\n    def test_stress_test\n      m = TestMessage.new\n      m.optional_int32 = 42\n      m.optional_int64 = 0x100000000\n      m.optional_string = \"hello world\"\n      10.times do m.repeated_msg.push TestMessage2.new(:foo => 42) end\n      10.times do m.repeated_string.push \"hello world\" end\n\n      data = TestMessage.encode(m)\n\n      l = 0\n      10_000.times do\n        m = TestMessage.decode(data)\n        data_new = TestMessage.encode(m)\n        assert data_new == data\n        data = data_new\n      end\n    end\n\n    def test_reflection\n      m = TestMessage.new(:optional_int32 => 1234)\n      msgdef = m.class.descriptor\n      assert msgdef.class == Google::Protobuf::Descriptor\n      assert msgdef.any? {|field| field.name == \"optional_int32\"}\n      optional_int32 = msgdef.lookup \"optional_int32\"\n      assert optional_int32.class == Google::Protobuf::FieldDescriptor\n      assert optional_int32 != nil\n      assert optional_int32.name == \"optional_int32\"\n      assert optional_int32.type == :int32\n      optional_int32.set(m, 5678)\n      assert m.optional_int32 == 5678\n      m.optional_int32 = 1000\n      assert optional_int32.get(m) == 1000\n\n      optional_msg = msgdef.lookup \"optional_msg\"\n      assert optional_msg.subtype == TestMessage2.descriptor\n\n      optional_msg.set(m, optional_msg.subtype.msgclass.new)\n\n      assert msgdef.msgclass == TestMessage\n\n      optional_enum = msgdef.lookup \"optional_enum\"\n      assert optional_enum.subtype == TestEnum.descriptor\n      assert optional_enum.subtype.class == Google::Protobuf::EnumDescriptor\n      optional_enum.subtype.each do |k, v|\n        # set with integer, check resolution to symbolic name\n        optional_enum.set(m, v)\n        assert optional_enum.get(m) == k\n      end\n    end\n\n    def test_json\n      # TODO: Fix JSON in JRuby version.\n      return if RUBY_PLATFORM == \"java\"\n      m = TestMessage.new(:optional_int32 => 1234,\n                          :optional_int64 => -0x1_0000_0000,\n                          :optional_uint32 => 0x8000_0000,\n                          :optional_uint64 => 0xffff_ffff_ffff_ffff,\n                          :optional_bool => true,\n                          :optional_float => 1.0,\n                          :optional_double => -1e100,\n                          :optional_string => \"Test string\",\n                          :optional_bytes => [\"FFFFFFFF\"].pack('H*'),\n                          :optional_msg => TestMessage2.new(:foo => 42),\n                          :repeated_int32 => [1, 2, 3, 4],\n                          :repeated_string => [\"a\", \"b\", \"c\"],\n                          :repeated_bool => [true, false, true, false],\n                          :repeated_msg => [TestMessage2.new(:foo => 1),\n                                            TestMessage2.new(:foo => 2)])\n\n      json_text = TestMessage.encode_json(m)\n      m2 = TestMessage.decode_json(json_text)\n      assert m == m2\n\n      # Crash case from GitHub issue 283.\n      bar = Bar.new(msg: \"bar\")\n      baz1 = Baz.new(msg: \"baz\")\n      baz2 = Baz.new(msg: \"quux\")\n      Foo.encode_json(Foo.new)\n      Foo.encode_json(Foo.new(bar: bar))\n      Foo.encode_json(Foo.new(bar: bar, baz: [baz1, baz2]))\n    end\n\n    def test_json_maps\n      # TODO: Fix JSON in JRuby version.\n      return if RUBY_PLATFORM == \"java\"\n      m = MapMessage.new(:map_string_int32 => {\"a\" => 1})\n      expected = '{\"mapStringInt32\":{\"a\":1},\"mapStringMsg\":{}}'\n      expected_preserve = '{\"map_string_int32\":{\"a\":1},\"map_string_msg\":{}}'\n      assert_equal expected, MapMessage.encode_json(m, :emit_defaults => true)\n\n      json = MapMessage.encode_json(m, :preserve_proto_fieldnames => true, :emit_defaults => true)\n      assert_equal expected_preserve, json\n\n      m2 = MapMessage.decode_json(MapMessage.encode_json(m))\n      assert m == m2\n    end\n  end\nend\n", "// Protocol Buffers - Google's data interchange format\n// Copyright 2014 Google Inc.  All rights reserved.\n// https://developers.google.com/protocol-buffers/\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n#include \"message.h\"\n\n#include \"convert.h\"\n#include \"defs.h\"\n#include \"map.h\"\n#include \"protobuf.h\"\n#include \"repeated_field.h\"\n\nstatic VALUE cParseError = Qnil;\nstatic VALUE cAbstractMessage = Qnil;\nstatic ID descriptor_instancevar_interned;\n\nstatic VALUE initialize_rb_class_with_no_args(VALUE klass) {\n  return rb_funcall(klass, rb_intern(\"new\"), 0);\n}\n\nVALUE MessageOrEnum_GetDescriptor(VALUE klass) {\n  return rb_ivar_get(klass, descriptor_instancevar_interned);\n}\n\n// -----------------------------------------------------------------------------\n// Class/module creation from msgdefs and enumdefs, respectively.\n// -----------------------------------------------------------------------------\n\ntypedef struct {\n  VALUE arena;\n  const upb_Message* msg;  // Can get as mutable when non-frozen.\n  const upb_MessageDef*\n      msgdef;  // kept alive by self.class.descriptor reference.\n} Message;\n\nstatic void Message_mark(void* _self) {\n  Message* self = (Message*)_self;\n  rb_gc_mark(self->arena);\n}\n\nstatic rb_data_type_t Message_type = {\n    \"Message\",\n    {Message_mark, RUBY_DEFAULT_FREE, NULL},\n    .flags = RUBY_TYPED_FREE_IMMEDIATELY,\n};\n\nstatic Message* ruby_to_Message(VALUE msg_rb) {\n  Message* msg;\n  TypedData_Get_Struct(msg_rb, Message, &Message_type, msg);\n  return msg;\n}\n\nstatic VALUE Message_alloc(VALUE klass) {\n  VALUE descriptor = rb_ivar_get(klass, descriptor_instancevar_interned);\n  Message* msg = ALLOC(Message);\n  VALUE ret;\n\n  msg->msgdef = Descriptor_GetMsgDef(descriptor);\n  msg->arena = Qnil;\n  msg->msg = NULL;\n\n  ret = TypedData_Wrap_Struct(klass, &Message_type, msg);\n  rb_ivar_set(ret, descriptor_instancevar_interned, descriptor);\n\n  return ret;\n}\n\nconst upb_Message* Message_Get(VALUE msg_rb, const upb_MessageDef** m) {\n  Message* msg = ruby_to_Message(msg_rb);\n  if (m) *m = msg->msgdef;\n  return msg->msg;\n}\n\nupb_Message* Message_GetMutable(VALUE msg_rb, const upb_MessageDef** m) {\n  rb_check_frozen(msg_rb);\n  return (upb_Message*)Message_Get(msg_rb, m);\n}\n\nvoid Message_InitPtr(VALUE self_, upb_Message* msg, VALUE arena) {\n  Message* self = ruby_to_Message(self_);\n  self->msg = msg;\n  self->arena = arena;\n  ObjectCache_Add(msg, self_);\n}\n\nVALUE Message_GetArena(VALUE msg_rb) {\n  Message* msg = ruby_to_Message(msg_rb);\n  return msg->arena;\n}\n\nvoid Message_CheckClass(VALUE klass) {\n  if (rb_get_alloc_func(klass) != &Message_alloc) {\n    rb_raise(rb_eArgError,\n             \"Message class was not returned by the DescriptorPool.\");\n  }\n}\n\nVALUE Message_GetRubyWrapper(upb_Message* msg, const upb_MessageDef* m,\n                             VALUE arena) {\n  if (msg == NULL) return Qnil;\n\n  VALUE val = ObjectCache_Get(msg);\n\n  if (val == Qnil) {\n    VALUE klass = Descriptor_DefToClass(m);\n    val = Message_alloc(klass);\n    Message_InitPtr(val, msg, arena);\n  }\n\n  return val;\n}\n\nvoid Message_PrintMessage(StringBuilder* b, const upb_Message* msg,\n                          const upb_MessageDef* m) {\n  bool first = true;\n  int n = upb_MessageDef_FieldCount(m);\n  VALUE klass = Descriptor_DefToClass(m);\n  StringBuilder_Printf(b, \"<%s: \", rb_class2name(klass));\n\n  for (int i = 0; i < n; i++) {\n    const upb_FieldDef* field = upb_MessageDef_Field(m, i);\n\n    if (upb_FieldDef_HasPresence(field) && !upb_Message_Has(msg, field)) {\n      continue;\n    }\n\n    if (!first) {\n      StringBuilder_Printf(b, \", \");\n    } else {\n      first = false;\n    }\n\n    upb_MessageValue msgval = upb_Message_Get(msg, field);\n\n    StringBuilder_Printf(b, \"%s: \", upb_FieldDef_Name(field));\n\n    if (upb_FieldDef_IsMap(field)) {\n      const upb_MessageDef* entry_m = upb_FieldDef_MessageSubDef(field);\n      const upb_FieldDef* key_f = upb_MessageDef_FindFieldByNumber(entry_m, 1);\n      const upb_FieldDef* val_f = upb_MessageDef_FindFieldByNumber(entry_m, 2);\n      TypeInfo val_info = TypeInfo_get(val_f);\n      Map_Inspect(b, msgval.map_val, upb_FieldDef_CType(key_f), val_info);\n    } else if (upb_FieldDef_IsRepeated(field)) {\n      RepeatedField_Inspect(b, msgval.array_val, TypeInfo_get(field));\n    } else {\n      StringBuilder_PrintMsgval(b, msgval, TypeInfo_get(field));\n    }\n  }\n\n  StringBuilder_Printf(b, \">\");\n}\n\n// Helper functions for #method_missing ////////////////////////////////////////\n\nenum {\n  METHOD_UNKNOWN = 0,\n  METHOD_GETTER = 1,\n  METHOD_SETTER = 2,\n  METHOD_CLEAR = 3,\n  METHOD_PRESENCE = 4,\n  METHOD_ENUM_GETTER = 5,\n  METHOD_WRAPPER_GETTER = 6,\n  METHOD_WRAPPER_SETTER = 7\n};\n\n// Check if the field is a well known wrapper type\nstatic bool IsWrapper(const upb_MessageDef* m) {\n  if (!m) return false;\n  switch (upb_MessageDef_WellKnownType(m)) {\n    case kUpb_WellKnown_DoubleValue:\n    case kUpb_WellKnown_FloatValue:\n    case kUpb_WellKnown_Int64Value:\n    case kUpb_WellKnown_UInt64Value:\n    case kUpb_WellKnown_Int32Value:\n    case kUpb_WellKnown_UInt32Value:\n    case kUpb_WellKnown_StringValue:\n    case kUpb_WellKnown_BytesValue:\n    case kUpb_WellKnown_BoolValue:\n      return true;\n    default:\n      return false;\n  }\n}\n\nstatic bool IsFieldWrapper(const upb_FieldDef* f) {\n  return IsWrapper(upb_FieldDef_MessageSubDef(f));\n}\n\nstatic bool Match(const upb_MessageDef* m, const char* name,\n                  const upb_FieldDef** f, const upb_OneofDef** o,\n                  const char* prefix, const char* suffix) {\n  size_t sp = strlen(prefix);\n  size_t ss = strlen(suffix);\n  size_t sn = strlen(name);\n\n  if (sn <= sp + ss) return false;\n\n  if (memcmp(name, prefix, sp) != 0 ||\n      memcmp(name + sn - ss, suffix, ss) != 0) {\n    return false;\n  }\n\n  return upb_MessageDef_FindByNameWithSize(m, name + sp, sn - sp - ss, f, o);\n}\n\nstatic int extract_method_call(VALUE method_name, Message* self,\n                               const upb_FieldDef** f, const upb_OneofDef** o) {\n  const upb_MessageDef* m = self->msgdef;\n  const char* name;\n\n  Check_Type(method_name, T_SYMBOL);\n  name = rb_id2name(SYM2ID(method_name));\n\n  if (Match(m, name, f, o, \"\", \"\")) return METHOD_GETTER;\n  if (Match(m, name, f, o, \"\", \"=\")) return METHOD_SETTER;\n  if (Match(m, name, f, o, \"clear_\", \"\")) return METHOD_CLEAR;\n  if (Match(m, name, f, o, \"has_\", \"?\") &&\n      (*o || (*f && upb_FieldDef_HasPresence(*f)))) {\n    // Disallow oneof hazzers for proto3.\n    // TODO(haberman): remove this test when we are enabling oneof hazzers for\n    // proto3.\n    if (*f && !upb_FieldDef_IsSubMessage(*f) &&\n        upb_FieldDef_RealContainingOneof(*f) &&\n        upb_MessageDef_Syntax(upb_FieldDef_ContainingType(*f)) !=\n            kUpb_Syntax_Proto2) {\n      return METHOD_UNKNOWN;\n    }\n    return METHOD_PRESENCE;\n  }\n  if (Match(m, name, f, o, \"\", \"_as_value\") && *f &&\n      !upb_FieldDef_IsRepeated(*f) && IsFieldWrapper(*f)) {\n    return METHOD_WRAPPER_GETTER;\n  }\n  if (Match(m, name, f, o, \"\", \"_as_value=\") && *f &&\n      !upb_FieldDef_IsRepeated(*f) && IsFieldWrapper(*f)) {\n    return METHOD_WRAPPER_SETTER;\n  }\n  if (Match(m, name, f, o, \"\", \"_const\") && *f &&\n      upb_FieldDef_CType(*f) == kUpb_CType_Enum) {\n    return METHOD_ENUM_GETTER;\n  }\n\n  return METHOD_UNKNOWN;\n}\n\nstatic VALUE Message_oneof_accessor(VALUE _self, const upb_OneofDef* o,\n                                    int accessor_type) {\n  Message* self = ruby_to_Message(_self);\n  const upb_FieldDef* oneof_field = upb_Message_WhichOneof(self->msg, o);\n\n  switch (accessor_type) {\n    case METHOD_PRESENCE:\n      return oneof_field == NULL ? Qfalse : Qtrue;\n    case METHOD_CLEAR:\n      if (oneof_field != NULL) {\n        upb_Message_ClearField(Message_GetMutable(_self, NULL), oneof_field);\n      }\n      return Qnil;\n    case METHOD_GETTER:\n      return oneof_field == NULL\n                 ? Qnil\n                 : ID2SYM(rb_intern(upb_FieldDef_Name(oneof_field)));\n    case METHOD_SETTER:\n      rb_raise(rb_eRuntimeError, \"Oneof accessors are read-only.\");\n  }\n  rb_raise(rb_eRuntimeError, \"Invalid access of oneof field.\");\n}\n\nstatic void Message_setfield(upb_Message* msg, const upb_FieldDef* f, VALUE val,\n                             upb_Arena* arena) {\n  upb_MessageValue msgval;\n  if (upb_FieldDef_IsMap(f)) {\n    msgval.map_val = Map_GetUpbMap(val, f, arena);\n  } else if (upb_FieldDef_IsRepeated(f)) {\n    msgval.array_val = RepeatedField_GetUpbArray(val, f, arena);\n  } else {\n    if (val == Qnil &&\n        (upb_FieldDef_IsSubMessage(f) || upb_FieldDef_RealContainingOneof(f))) {\n      upb_Message_ClearField(msg, f);\n      return;\n    }\n    msgval =\n        Convert_RubyToUpb(val, upb_FieldDef_Name(f), TypeInfo_get(f), arena);\n  }\n  upb_Message_Set(msg, f, msgval, arena);\n}\n\nVALUE Message_getfield(VALUE _self, const upb_FieldDef* f) {\n  Message* self = ruby_to_Message(_self);\n  // This is a special-case: upb_Message_Mutable() for map & array are logically\n  // const (they will not change what is serialized) but physically\n  // non-const, as they do allocate a repeated field or map. The logical\n  // constness means it's ok to do even if the message is frozen.\n  upb_Message* msg = (upb_Message*)self->msg;\n  upb_Arena* arena = Arena_get(self->arena);\n  if (upb_FieldDef_IsMap(f)) {\n    upb_Map* map = upb_Message_Mutable(msg, f, arena).map;\n    const upb_FieldDef* key_f = map_field_key(f);\n    const upb_FieldDef* val_f = map_field_value(f);\n    upb_CType key_type = upb_FieldDef_CType(key_f);\n    TypeInfo value_type_info = TypeInfo_get(val_f);\n    return Map_GetRubyWrapper(map, key_type, value_type_info, self->arena);\n  } else if (upb_FieldDef_IsRepeated(f)) {\n    upb_Array* arr = upb_Message_Mutable(msg, f, arena).array;\n    return RepeatedField_GetRubyWrapper(arr, TypeInfo_get(f), self->arena);\n  } else if (upb_FieldDef_IsSubMessage(f)) {\n    if (!upb_Message_Has(self->msg, f)) return Qnil;\n    upb_Message* submsg = upb_Message_Mutable(msg, f, arena).msg;\n    const upb_MessageDef* m = upb_FieldDef_MessageSubDef(f);\n    return Message_GetRubyWrapper(submsg, m, self->arena);\n  } else {\n    upb_MessageValue msgval = upb_Message_Get(self->msg, f);\n    return Convert_UpbToRuby(msgval, TypeInfo_get(f), self->arena);\n  }\n}\n\nstatic VALUE Message_field_accessor(VALUE _self, const upb_FieldDef* f,\n                                    int accessor_type, int argc, VALUE* argv) {\n  upb_Arena* arena = Arena_get(Message_GetArena(_self));\n\n  switch (accessor_type) {\n    case METHOD_SETTER:\n      Message_setfield(Message_GetMutable(_self, NULL), f, argv[1], arena);\n      return Qnil;\n    case METHOD_CLEAR:\n      upb_Message_ClearField(Message_GetMutable(_self, NULL), f);\n      return Qnil;\n    case METHOD_PRESENCE:\n      if (!upb_FieldDef_HasPresence(f)) {\n        rb_raise(rb_eRuntimeError, \"Field does not have presence.\");\n      }\n      return upb_Message_Has(Message_Get(_self, NULL), f);\n    case METHOD_WRAPPER_GETTER: {\n      Message* self = ruby_to_Message(_self);\n      if (upb_Message_Has(self->msg, f)) {\n        PBRUBY_ASSERT(upb_FieldDef_IsSubMessage(f) &&\n                      !upb_FieldDef_IsRepeated(f));\n        upb_MessageValue wrapper = upb_Message_Get(self->msg, f);\n        const upb_MessageDef* wrapper_m = upb_FieldDef_MessageSubDef(f);\n        const upb_FieldDef* value_f =\n            upb_MessageDef_FindFieldByNumber(wrapper_m, 1);\n        upb_MessageValue value = upb_Message_Get(wrapper.msg_val, value_f);\n        return Convert_UpbToRuby(value, TypeInfo_get(value_f), self->arena);\n      } else {\n        return Qnil;\n      }\n    }\n    case METHOD_WRAPPER_SETTER: {\n      upb_Message* msg = Message_GetMutable(_self, NULL);\n      if (argv[1] == Qnil) {\n        upb_Message_ClearField(msg, f);\n      } else {\n        const upb_FieldDef* val_f =\n            upb_MessageDef_FindFieldByNumber(upb_FieldDef_MessageSubDef(f), 1);\n        upb_MessageValue msgval = Convert_RubyToUpb(\n            argv[1], upb_FieldDef_Name(f), TypeInfo_get(val_f), arena);\n        upb_Message* wrapper = upb_Message_Mutable(msg, f, arena).msg;\n        upb_Message_Set(wrapper, val_f, msgval, arena);\n      }\n      return Qnil;\n    }\n    case METHOD_ENUM_GETTER: {\n      upb_MessageValue msgval = upb_Message_Get(Message_Get(_self, NULL), f);\n\n      if (upb_FieldDef_Label(f) == kUpb_Label_Repeated) {\n        // Map repeated fields to a new type with ints\n        VALUE arr = rb_ary_new();\n        size_t i, n = upb_Array_Size(msgval.array_val);\n        for (i = 0; i < n; i++) {\n          upb_MessageValue elem = upb_Array_Get(msgval.array_val, i);\n          rb_ary_push(arr, INT2NUM(elem.int32_val));\n        }\n        return arr;\n      } else {\n        return INT2NUM(msgval.int32_val);\n      }\n    }\n    case METHOD_GETTER:\n      return Message_getfield(_self, f);\n    default:\n      rb_raise(rb_eRuntimeError, \"Internal error, no such accessor: %d\",\n               accessor_type);\n  }\n}\n\n/*\n * call-seq:\n *     Message.method_missing(*args)\n *\n * Provides accessors and setters and methods to clear and check for presence of\n * message fields according to their field names.\n *\n * For any field whose name does not conflict with a built-in method, an\n * accessor is provided with the same name as the field, and a setter is\n * provided with the name of the field plus the '=' suffix. Thus, given a\n * message instance 'msg' with field 'foo', the following code is valid:\n *\n *     msg.foo = 42\n *     puts msg.foo\n *\n * This method also provides read-only accessors for oneofs. If a oneof exists\n * with name 'my_oneof', then msg.my_oneof will return a Ruby symbol equal to\n * the name of the field in that oneof that is currently set, or nil if none.\n *\n * It also provides methods of the form 'clear_fieldname' to clear the value\n * of the field 'fieldname'. For basic data types, this will set the default\n * value of the field.\n *\n * Additionally, it provides methods of the form 'has_fieldname?', which returns\n * true if the field 'fieldname' is set in the message object, else false. For\n * 'proto3' syntax, calling this for a basic type field will result in an error.\n */\nstatic VALUE Message_method_missing(int argc, VALUE* argv, VALUE _self) {\n  Message* self = ruby_to_Message(_self);\n  const upb_OneofDef* o;\n  const upb_FieldDef* f;\n  int accessor_type;\n\n  if (argc < 1) {\n    rb_raise(rb_eArgError, \"Expected method name as first argument.\");\n  }\n\n  accessor_type = extract_method_call(argv[0], self, &f, &o);\n\n  if (accessor_type == METHOD_UNKNOWN) return rb_call_super(argc, argv);\n\n  // Validate argument count.\n  switch (accessor_type) {\n    case METHOD_SETTER:\n    case METHOD_WRAPPER_SETTER:\n      if (argc != 2) {\n        rb_raise(rb_eArgError, \"Expected 2 arguments, received %d\", argc);\n      }\n      rb_check_frozen(_self);\n      break;\n    default:\n      if (argc != 1) {\n        rb_raise(rb_eArgError, \"Expected 1 argument, received %d\", argc);\n      }\n      break;\n  }\n\n  // Dispatch accessor.\n  if (o != NULL) {\n    return Message_oneof_accessor(_self, o, accessor_type);\n  } else {\n    return Message_field_accessor(_self, f, accessor_type, argc, argv);\n  }\n}\n\nstatic VALUE Message_respond_to_missing(int argc, VALUE* argv, VALUE _self) {\n  Message* self = ruby_to_Message(_self);\n  const upb_OneofDef* o;\n  const upb_FieldDef* f;\n  int accessor_type;\n\n  if (argc < 1) {\n    rb_raise(rb_eArgError, \"Expected method name as first argument.\");\n  }\n\n  accessor_type = extract_method_call(argv[0], self, &f, &o);\n\n  if (accessor_type == METHOD_UNKNOWN) {\n    return rb_call_super(argc, argv);\n  } else if (o != NULL) {\n    return accessor_type == METHOD_SETTER ? Qfalse : Qtrue;\n  } else {\n    return Qtrue;\n  }\n}\n\nvoid Message_InitFromValue(upb_Message* msg, const upb_MessageDef* m, VALUE val,\n                           upb_Arena* arena);\n\ntypedef struct {\n  upb_Map* map;\n  TypeInfo key_type;\n  TypeInfo val_type;\n  upb_Arena* arena;\n} MapInit;\n\nstatic int Map_initialize_kwarg(VALUE key, VALUE val, VALUE _self) {\n  MapInit* map_init = (MapInit*)_self;\n  upb_MessageValue k, v;\n  k = Convert_RubyToUpb(key, \"\", map_init->key_type, NULL);\n\n  if (map_init->val_type.type == kUpb_CType_Message && TYPE(val) == T_HASH) {\n    upb_Message* msg =\n        upb_Message_New(map_init->val_type.def.msgdef, map_init->arena);\n    Message_InitFromValue(msg, map_init->val_type.def.msgdef, val,\n                          map_init->arena);\n    v.msg_val = msg;\n  } else {\n    v = Convert_RubyToUpb(val, \"\", map_init->val_type, map_init->arena);\n  }\n  upb_Map_Set(map_init->map, k, v, map_init->arena);\n  return ST_CONTINUE;\n}\n\nstatic void Map_InitFromValue(upb_Map* map, const upb_FieldDef* f, VALUE val,\n                              upb_Arena* arena) {\n  const upb_MessageDef* entry_m = upb_FieldDef_MessageSubDef(f);\n  const upb_FieldDef* key_f = upb_MessageDef_FindFieldByNumber(entry_m, 1);\n  const upb_FieldDef* val_f = upb_MessageDef_FindFieldByNumber(entry_m, 2);\n  if (TYPE(val) != T_HASH) {\n    rb_raise(rb_eArgError,\n             \"Expected Hash object as initializer value for map field '%s' \"\n             \"(given %s).\",\n             upb_FieldDef_Name(f), rb_class2name(CLASS_OF(val)));\n  }\n  MapInit map_init = {map, TypeInfo_get(key_f), TypeInfo_get(val_f), arena};\n  rb_hash_foreach(val, Map_initialize_kwarg, (VALUE)&map_init);\n}\n\nstatic upb_MessageValue MessageValue_FromValue(VALUE val, TypeInfo info,\n                                               upb_Arena* arena) {\n  if (info.type == kUpb_CType_Message) {\n    upb_MessageValue msgval;\n    upb_Message* msg = upb_Message_New(info.def.msgdef, arena);\n    Message_InitFromValue(msg, info.def.msgdef, val, arena);\n    msgval.msg_val = msg;\n    return msgval;\n  } else {\n    return Convert_RubyToUpb(val, \"\", info, arena);\n  }\n}\n\nstatic void RepeatedField_InitFromValue(upb_Array* arr, const upb_FieldDef* f,\n                                        VALUE val, upb_Arena* arena) {\n  TypeInfo type_info = TypeInfo_get(f);\n\n  if (TYPE(val) != T_ARRAY) {\n    rb_raise(rb_eArgError,\n             \"Expected array as initializer value for repeated field '%s' \"\n             \"(given %s).\",\n             upb_FieldDef_Name(f), rb_class2name(CLASS_OF(val)));\n  }\n\n  for (int i = 0; i < RARRAY_LEN(val); i++) {\n    VALUE entry = rb_ary_entry(val, i);\n    upb_MessageValue msgval;\n    if (upb_FieldDef_IsSubMessage(f) && TYPE(entry) == T_HASH) {\n      msgval = MessageValue_FromValue(entry, type_info, arena);\n    } else {\n      msgval = Convert_RubyToUpb(entry, upb_FieldDef_Name(f), type_info, arena);\n    }\n    upb_Array_Append(arr, msgval, arena);\n  }\n}\n\nstatic void Message_InitFieldFromValue(upb_Message* msg, const upb_FieldDef* f,\n                                       VALUE val, upb_Arena* arena) {\n  if (TYPE(val) == T_NIL) return;\n\n  if (upb_FieldDef_IsMap(f)) {\n    upb_Map* map = upb_Message_Mutable(msg, f, arena).map;\n    Map_InitFromValue(map, f, val, arena);\n  } else if (upb_FieldDef_Label(f) == kUpb_Label_Repeated) {\n    upb_Array* arr = upb_Message_Mutable(msg, f, arena).array;\n    RepeatedField_InitFromValue(arr, f, val, arena);\n  } else if (upb_FieldDef_IsSubMessage(f)) {\n    if (TYPE(val) == T_HASH) {\n      upb_Message* submsg = upb_Message_Mutable(msg, f, arena).msg;\n      Message_InitFromValue(submsg, upb_FieldDef_MessageSubDef(f), val, arena);\n    } else {\n      Message_setfield(msg, f, val, arena);\n    }\n  } else {\n    upb_MessageValue msgval =\n        Convert_RubyToUpb(val, upb_FieldDef_Name(f), TypeInfo_get(f), arena);\n    upb_Message_Set(msg, f, msgval, arena);\n  }\n}\n\ntypedef struct {\n  upb_Message* msg;\n  const upb_MessageDef* msgdef;\n  upb_Arena* arena;\n} MsgInit;\n\nstatic int Message_initialize_kwarg(VALUE key, VALUE val, VALUE _self) {\n  MsgInit* msg_init = (MsgInit*)_self;\n  const char* name;\n\n  if (TYPE(key) == T_STRING) {\n    name = RSTRING_PTR(key);\n  } else if (TYPE(key) == T_SYMBOL) {\n    name = RSTRING_PTR(rb_id2str(SYM2ID(key)));\n  } else {\n    rb_raise(rb_eArgError,\n             \"Expected string or symbols as hash keys when initializing proto \"\n             \"from hash.\");\n  }\n\n  const upb_FieldDef* f =\n      upb_MessageDef_FindFieldByName(msg_init->msgdef, name);\n\n  if (f == NULL) {\n    rb_raise(rb_eArgError,\n             \"Unknown field name '%s' in initialization map entry.\", name);\n  }\n\n  Message_InitFieldFromValue(msg_init->msg, f, val, msg_init->arena);\n  return ST_CONTINUE;\n}\n\nvoid Message_InitFromValue(upb_Message* msg, const upb_MessageDef* m, VALUE val,\n                           upb_Arena* arena) {\n  MsgInit msg_init = {msg, m, arena};\n  if (TYPE(val) == T_HASH) {\n    rb_hash_foreach(val, Message_initialize_kwarg, (VALUE)&msg_init);\n  } else {\n    rb_raise(rb_eArgError, \"Expected hash arguments or message, not %s\",\n             rb_class2name(CLASS_OF(val)));\n  }\n}\n\n/*\n * call-seq:\n *     Message.new(kwargs) => new_message\n *\n * Creates a new instance of the given message class. Keyword arguments may be\n * provided with keywords corresponding to field names.\n *\n * Note that no literal Message class exists. Only concrete classes per message\n * type exist, as provided by the #msgclass method on Descriptors after they\n * have been added to a pool. The method definitions described here on the\n * Message class are provided on each concrete message class.\n */\nstatic VALUE Message_initialize(int argc, VALUE* argv, VALUE _self) {\n  Message* self = ruby_to_Message(_self);\n  VALUE arena_rb = Arena_new();\n  upb_Arena* arena = Arena_get(arena_rb);\n  upb_Message* msg = upb_Message_New(self->msgdef, arena);\n\n  Message_InitPtr(_self, msg, arena_rb);\n\n  if (argc == 0) {\n    return Qnil;\n  }\n  if (argc != 1) {\n    rb_raise(rb_eArgError, \"Expected 0 or 1 arguments.\");\n  }\n  Message_InitFromValue((upb_Message*)self->msg, self->msgdef, argv[0], arena);\n  return Qnil;\n}\n\n/*\n * call-seq:\n *     Message.dup => new_message\n *\n * Performs a shallow copy of this message and returns the new copy.\n */\nstatic VALUE Message_dup(VALUE _self) {\n  Message* self = ruby_to_Message(_self);\n  VALUE new_msg = rb_class_new_instance(0, NULL, CLASS_OF(_self));\n  Message* new_msg_self = ruby_to_Message(new_msg);\n  size_t size = upb_MessageDef_MiniTable(self->msgdef)->size;\n\n  // TODO(copy unknown fields?)\n  // TODO(use official upb msg copy function)\n  memcpy((upb_Message*)new_msg_self->msg, self->msg, size);\n  Arena_fuse(self->arena, Arena_get(new_msg_self->arena));\n  return new_msg;\n}\n\n// Support function for Message_eq, and also used by other #eq functions.\nbool Message_Equal(const upb_Message* m1, const upb_Message* m2,\n                   const upb_MessageDef* m) {\n  if (m1 == m2) return true;\n\n  size_t size1, size2;\n  int encode_opts = kUpb_Encode_SkipUnknown | kUpb_Encode_Deterministic;\n  upb_Arena* arena_tmp = upb_Arena_New();\n  const upb_MiniTable* layout = upb_MessageDef_MiniTable(m);\n\n  // Compare deterministically serialized payloads with no unknown fields.\n  char* data1 = upb_Encode(m1, layout, encode_opts, arena_tmp, &size1);\n  char* data2 = upb_Encode(m2, layout, encode_opts, arena_tmp, &size2);\n\n  if (data1 && data2) {\n    bool ret = (size1 == size2) && (memcmp(data1, data2, size1) == 0);\n    upb_Arena_Free(arena_tmp);\n    return ret;\n  } else {\n    upb_Arena_Free(arena_tmp);\n    rb_raise(cParseError, \"Error comparing messages\");\n  }\n}\n\n/*\n * call-seq:\n *     Message.==(other) => boolean\n *\n * Performs a deep comparison of this message with another. Messages are equal\n * if they have the same type and if each field is equal according to the :==\n * method's semantics (a more efficient comparison may actually be done if the\n * field is of a primitive type).\n */\nstatic VALUE Message_eq(VALUE _self, VALUE _other) {\n  if (CLASS_OF(_self) != CLASS_OF(_other)) return Qfalse;\n\n  Message* self = ruby_to_Message(_self);\n  Message* other = ruby_to_Message(_other);\n  assert(self->msgdef == other->msgdef);\n\n  return Message_Equal(self->msg, other->msg, self->msgdef) ? Qtrue : Qfalse;\n}\n\nuint64_t Message_Hash(const upb_Message* msg, const upb_MessageDef* m,\n                      uint64_t seed) {\n  upb_Arena* arena = upb_Arena_New();\n  const char* data;\n  size_t size;\n\n  // Hash a deterministically serialized payloads with no unknown fields.\n  data = upb_Encode(msg, upb_MessageDef_MiniTable(m),\n                    kUpb_Encode_SkipUnknown | kUpb_Encode_Deterministic, arena,\n                    &size);\n\n  if (data) {\n    uint64_t ret = _upb_Hash(data, size, seed);\n    upb_Arena_Free(arena);\n    return ret;\n  } else {\n    upb_Arena_Free(arena);\n    rb_raise(cParseError, \"Error calculating hash\");\n  }\n}\n\n/*\n * call-seq:\n *     Message.hash => hash_value\n *\n * Returns a hash value that represents this message's field values.\n */\nstatic VALUE Message_hash(VALUE _self) {\n  Message* self = ruby_to_Message(_self);\n  uint64_t hash_value = Message_Hash(self->msg, self->msgdef, 0);\n  // RUBY_FIXNUM_MAX should be one less than a power of 2.\n  assert((RUBY_FIXNUM_MAX & (RUBY_FIXNUM_MAX + 1)) == 0);\n  return INT2FIX(hash_value & RUBY_FIXNUM_MAX);\n}\n\n/*\n * call-seq:\n *     Message.inspect => string\n *\n * Returns a human-readable string representing this message. It will be\n * formatted as \"<MessageType: field1: value1, field2: value2, ...>\". Each\n * field's value is represented according to its own #inspect method.\n */\nstatic VALUE Message_inspect(VALUE _self) {\n  Message* self = ruby_to_Message(_self);\n\n  StringBuilder* builder = StringBuilder_New();\n  Message_PrintMessage(builder, self->msg, self->msgdef);\n  VALUE ret = StringBuilder_ToRubyString(builder);\n  StringBuilder_Free(builder);\n  return ret;\n}\n\n// Support functions for Message_to_h //////////////////////////////////////////\n\nstatic VALUE RepeatedField_CreateArray(const upb_Array* arr,\n                                       TypeInfo type_info) {\n  int size = arr ? upb_Array_Size(arr) : 0;\n  VALUE ary = rb_ary_new2(size);\n\n  for (int i = 0; i < size; i++) {\n    upb_MessageValue msgval = upb_Array_Get(arr, i);\n    VALUE val = Scalar_CreateHash(msgval, type_info);\n    rb_ary_push(ary, val);\n  }\n\n  return ary;\n}\n\nstatic VALUE Message_CreateHash(const upb_Message* msg,\n                                const upb_MessageDef* m) {\n  if (!msg) return Qnil;\n\n  VALUE hash = rb_hash_new();\n  int n = upb_MessageDef_FieldCount(m);\n  bool is_proto2;\n\n  // We currently have a few behaviors that are specific to proto2.\n  // This is unfortunate, we should key behaviors off field attributes (like\n  // whether a field has presence), not proto2 vs. proto3. We should see if we\n  // can change this without breaking users.\n  is_proto2 = upb_MessageDef_Syntax(m) == kUpb_Syntax_Proto2;\n\n  for (int i = 0; i < n; i++) {\n    const upb_FieldDef* field = upb_MessageDef_Field(m, i);\n    TypeInfo type_info = TypeInfo_get(field);\n    upb_MessageValue msgval;\n    VALUE msg_value;\n    VALUE msg_key;\n\n    if (!is_proto2 && upb_FieldDef_IsSubMessage(field) &&\n        !upb_FieldDef_IsRepeated(field) && !upb_Message_Has(msg, field)) {\n      // TODO: Legacy behavior, remove when we fix the is_proto2 differences.\n      msg_key = ID2SYM(rb_intern(upb_FieldDef_Name(field)));\n      rb_hash_aset(hash, msg_key, Qnil);\n      continue;\n    }\n\n    // Do not include fields that are not present (oneof or optional fields).\n    if (is_proto2 && upb_FieldDef_HasPresence(field) &&\n        !upb_Message_Has(msg, field)) {\n      continue;\n    }\n\n    msg_key = ID2SYM(rb_intern(upb_FieldDef_Name(field)));\n    msgval = upb_Message_Get(msg, field);\n\n    // Proto2 omits empty map/repeated filds also.\n\n    if (upb_FieldDef_IsMap(field)) {\n      const upb_MessageDef* entry_m = upb_FieldDef_MessageSubDef(field);\n      const upb_FieldDef* key_f = upb_MessageDef_FindFieldByNumber(entry_m, 1);\n      const upb_FieldDef* val_f = upb_MessageDef_FindFieldByNumber(entry_m, 2);\n      upb_CType key_type = upb_FieldDef_CType(key_f);\n      msg_value = Map_CreateHash(msgval.map_val, key_type, TypeInfo_get(val_f));\n    } else if (upb_FieldDef_IsRepeated(field)) {\n      if (is_proto2 &&\n          (!msgval.array_val || upb_Array_Size(msgval.array_val) == 0)) {\n        continue;\n      }\n      msg_value = RepeatedField_CreateArray(msgval.array_val, type_info);\n    } else {\n      msg_value = Scalar_CreateHash(msgval, type_info);\n    }\n\n    rb_hash_aset(hash, msg_key, msg_value);\n  }\n\n  return hash;\n}\n\nVALUE Scalar_CreateHash(upb_MessageValue msgval, TypeInfo type_info) {\n  if (type_info.type == kUpb_CType_Message) {\n    return Message_CreateHash(msgval.msg_val, type_info.def.msgdef);\n  } else {\n    return Convert_UpbToRuby(msgval, type_info, Qnil);\n  }\n}\n\n/*\n * call-seq:\n *     Message.to_h => {}\n *\n * Returns the message as a Ruby Hash object, with keys as symbols.\n */\nstatic VALUE Message_to_h(VALUE _self) {\n  Message* self = ruby_to_Message(_self);\n  return Message_CreateHash(self->msg, self->msgdef);\n}\n\n/*\n * call-seq:\n *     Message.freeze => self\n *\n * Freezes the message object. We have to intercept this so we can pin the\n * Ruby object into memory so we don't forget it's frozen.\n */\nstatic VALUE Message_freeze(VALUE _self) {\n  Message* self = ruby_to_Message(_self);\n  if (!RB_OBJ_FROZEN(_self)) {\n    Arena_Pin(self->arena, _self);\n    RB_OBJ_FREEZE(_self);\n  }\n  return _self;\n}\n\n/*\n * call-seq:\n *     Message.[](index) => value\n *\n * Accesses a field's value by field name. The provided field name should be a\n * string.\n */\nstatic VALUE Message_index(VALUE _self, VALUE field_name) {\n  Message* self = ruby_to_Message(_self);\n  const upb_FieldDef* field;\n\n  Check_Type(field_name, T_STRING);\n  field = upb_MessageDef_FindFieldByName(self->msgdef, RSTRING_PTR(field_name));\n\n  if (field == NULL) {\n    return Qnil;\n  }\n\n  return Message_getfield(_self, field);\n}\n\n/*\n * call-seq:\n *     Message.[]=(index, value)\n *\n * Sets a field's value by field name. The provided field name should be a\n * string.\n */\nstatic VALUE Message_index_set(VALUE _self, VALUE field_name, VALUE value) {\n  Message* self = ruby_to_Message(_self);\n  const upb_FieldDef* f;\n  upb_MessageValue val;\n  upb_Arena* arena = Arena_get(self->arena);\n\n  Check_Type(field_name, T_STRING);\n  f = upb_MessageDef_FindFieldByName(self->msgdef, RSTRING_PTR(field_name));\n\n  if (f == NULL) {\n    rb_raise(rb_eArgError, \"Unknown field: %s\", RSTRING_PTR(field_name));\n  }\n\n  val = Convert_RubyToUpb(value, upb_FieldDef_Name(f), TypeInfo_get(f), arena);\n  upb_Message_Set(Message_GetMutable(_self, NULL), f, val, arena);\n\n  return Qnil;\n}\n\n/*\n * call-seq:\n *     MessageClass.decode(data, options) => message\n *\n * Decodes the given data (as a string containing bytes in protocol buffers wire\n * format) under the interpretration given by this message class's definition\n * and returns a message object with the corresponding field values.\n * @param options [Hash] options for the decoder\n *  recursion_limit: set to maximum decoding depth for message (default is 64)\n */\nstatic VALUE Message_decode(int argc, VALUE* argv, VALUE klass) {\n  VALUE data = argv[0];\n  int options = 0;\n\n  if (argc < 1 || argc > 2) {\n    rb_raise(rb_eArgError, \"Expected 1 or 2 arguments.\");\n  }\n\n  if (argc == 2) {\n    VALUE hash_args = argv[1];\n    if (TYPE(hash_args) != T_HASH) {\n      rb_raise(rb_eArgError, \"Expected hash arguments.\");\n    }\n\n    VALUE depth = rb_hash_lookup(hash_args, ID2SYM(rb_intern(\"recursion_limit\")));\n\n    if (depth != Qnil && TYPE(depth) == T_FIXNUM) {\n      options |= UPB_DECODE_MAXDEPTH(FIX2INT(depth));\n    }\n  }\n\n  if (TYPE(data) != T_STRING) {\n    rb_raise(rb_eArgError, \"Expected string for binary protobuf data.\");\n  }\n\n  VALUE msg_rb = initialize_rb_class_with_no_args(klass);\n  Message* msg = ruby_to_Message(msg_rb);\n\n  upb_DecodeStatus status = upb_Decode(\n      RSTRING_PTR(data), RSTRING_LEN(data), (upb_Message*)msg->msg,\n      upb_MessageDef_MiniTable(msg->msgdef), NULL, options, Arena_get(msg->arena));\n\n  if (status != kUpb_DecodeStatus_Ok) {\n    rb_raise(cParseError, \"Error occurred during parsing\");\n  }\n\n  return msg_rb;\n}\n\n/*\n * call-seq:\n *     MessageClass.decode_json(data, options = {}) => message\n *\n * Decodes the given data (as a string containing bytes in protocol buffers wire\n * format) under the interpretration given by this message class's definition\n * and returns a message object with the corresponding field values.\n *\n *  @param options [Hash] options for the decoder\n *   ignore_unknown_fields: set true to ignore unknown fields (default is to\n *   raise an error)\n */\nstatic VALUE Message_decode_json(int argc, VALUE* argv, VALUE klass) {\n  VALUE data = argv[0];\n  int options = 0;\n  upb_Status status;\n\n  // TODO(haberman): use this message's pool instead.\n  const upb_DefPool* symtab = DescriptorPool_GetSymtab(generated_pool);\n\n  if (argc < 1 || argc > 2) {\n    rb_raise(rb_eArgError, \"Expected 1 or 2 arguments.\");\n  }\n\n  if (argc == 2) {\n    VALUE hash_args = argv[1];\n    if (TYPE(hash_args) != T_HASH) {\n      rb_raise(rb_eArgError, \"Expected hash arguments.\");\n    }\n\n    if (RTEST(rb_hash_lookup2(\n            hash_args, ID2SYM(rb_intern(\"ignore_unknown_fields\")), Qfalse))) {\n      options |= upb_JsonDecode_IgnoreUnknown;\n    }\n  }\n\n  if (TYPE(data) != T_STRING) {\n    rb_raise(rb_eArgError, \"Expected string for JSON data.\");\n  }\n\n  // TODO(cfallin): Check and respect string encoding. If not UTF-8, we need to\n  // convert, because string handlers pass data directly to message string\n  // fields.\n\n  VALUE msg_rb = initialize_rb_class_with_no_args(klass);\n  Message* msg = ruby_to_Message(msg_rb);\n\n  // We don't allow users to decode a wrapper type directly.\n  if (IsWrapper(msg->msgdef)) {\n    rb_raise(rb_eRuntimeError, \"Cannot parse a wrapper directly.\");\n  }\n\n  upb_Status_Clear(&status);\n  if (!upb_JsonDecode(RSTRING_PTR(data), RSTRING_LEN(data),\n                      (upb_Message*)msg->msg, msg->msgdef, symtab, options,\n                      Arena_get(msg->arena), &status)) {\n    rb_raise(cParseError, \"Error occurred during parsing: %s\",\n             upb_Status_ErrorMessage(&status));\n  }\n\n  return msg_rb;\n}\n\n/*\n * call-seq:\n *     MessageClass.encode(msg, options) => bytes\n *\n * Encodes the given message object to its serialized form in protocol buffers\n * wire format.\n * @param options [Hash] options for the encoder\n *  recursion_limit: set to maximum encoding depth for message (default is 64)\n */\nstatic VALUE Message_encode(int argc, VALUE* argv, VALUE klass) {\n  Message* msg = ruby_to_Message(argv[0]);\n  int options = 0;\n  const char* data;\n  size_t size;\n\n  if (CLASS_OF(argv[0]) != klass) {\n    rb_raise(rb_eArgError, \"Message of wrong type.\");\n  }\n\n  if (argc < 1 || argc > 2) {\n    rb_raise(rb_eArgError, \"Expected 1 or 2 arguments.\");\n  }\n\n  if (argc == 2) {\n    VALUE hash_args = argv[1];\n    if (TYPE(hash_args) != T_HASH) {\n      rb_raise(rb_eArgError, \"Expected hash arguments.\");\n    }\n    VALUE depth = rb_hash_lookup(hash_args, ID2SYM(rb_intern(\"recursion_limit\")));\n\n    if (depth != Qnil && TYPE(depth) == T_FIXNUM) {\n      options |= UPB_DECODE_MAXDEPTH(FIX2INT(depth));\n    }\n  }\n\n  upb_Arena *arena = upb_Arena_New();\n\n  data = upb_Encode(msg->msg, upb_MessageDef_MiniTable(msg->msgdef),\n                    options, arena, &size);\n\n  if (data) {\n    VALUE ret = rb_str_new(data, size);\n    rb_enc_associate(ret, rb_ascii8bit_encoding());\n    upb_Arena_Free(arena);\n    return ret;\n  } else {\n    upb_Arena_Free(arena);\n    rb_raise(rb_eRuntimeError, \"Exceeded maximum depth (possibly cycle)\");\n  }\n}\n\n/*\n * call-seq:\n *     MessageClass.encode_json(msg, options = {}) => json_string\n *\n * Encodes the given message object into its serialized JSON representation.\n * @param options [Hash] options for the decoder\n *  preserve_proto_fieldnames: set true to use original fieldnames (default is\n * to camelCase) emit_defaults: set true to emit 0/false values (default is to\n * omit them)\n */\nstatic VALUE Message_encode_json(int argc, VALUE* argv, VALUE klass) {\n  Message* msg = ruby_to_Message(argv[0]);\n  int options = 0;\n  char buf[1024];\n  size_t size;\n  upb_Status status;\n\n  // TODO(haberman): use this message's pool instead.\n  const upb_DefPool* symtab = DescriptorPool_GetSymtab(generated_pool);\n\n  if (argc < 1 || argc > 2) {\n    rb_raise(rb_eArgError, \"Expected 1 or 2 arguments.\");\n  }\n\n  if (argc == 2) {\n    VALUE hash_args = argv[1];\n    if (TYPE(hash_args) != T_HASH) {\n      if (RTEST(rb_funcall(hash_args, rb_intern(\"respond_to?\"), 1, rb_str_new2(\"to_h\")))) {\n        hash_args = rb_funcall(hash_args, rb_intern(\"to_h\"), 0);\n      } else {\n        rb_raise(rb_eArgError, \"Expected hash arguments.\");\n      }\n    }\n\n    if (RTEST(rb_hash_lookup2(hash_args,\n                              ID2SYM(rb_intern(\"preserve_proto_fieldnames\")),\n                              Qfalse))) {\n      options |= upb_JsonEncode_UseProtoNames;\n    }\n\n    if (RTEST(rb_hash_lookup2(hash_args, ID2SYM(rb_intern(\"emit_defaults\")),\n                              Qfalse))) {\n      options |= upb_JsonEncode_EmitDefaults;\n    }\n  }\n\n  upb_Status_Clear(&status);\n  size = upb_JsonEncode(msg->msg, msg->msgdef, symtab, options, buf,\n                        sizeof(buf), &status);\n\n  if (!upb_Status_IsOk(&status)) {\n    rb_raise(cParseError, \"Error occurred during encoding: %s\",\n             upb_Status_ErrorMessage(&status));\n  }\n\n  VALUE ret;\n  if (size >= sizeof(buf)) {\n    char* buf2 = malloc(size + 1);\n    upb_JsonEncode(msg->msg, msg->msgdef, symtab, options, buf2, size + 1,\n                   &status);\n    ret = rb_str_new(buf2, size);\n    free(buf2);\n  } else {\n    ret = rb_str_new(buf, size);\n  }\n\n  rb_enc_associate(ret, rb_utf8_encoding());\n  return ret;\n}\n\n/*\n * call-seq:\n *     Message.descriptor => descriptor\n *\n * Class method that returns the Descriptor instance corresponding to this\n * message class's type.\n */\nstatic VALUE Message_descriptor(VALUE klass) {\n  return rb_ivar_get(klass, descriptor_instancevar_interned);\n}\n\nVALUE build_class_from_descriptor(VALUE descriptor) {\n  const char* name;\n  VALUE klass;\n\n  name = upb_MessageDef_FullName(Descriptor_GetMsgDef(descriptor));\n  if (name == NULL) {\n    rb_raise(rb_eRuntimeError, \"Descriptor does not have assigned name.\");\n  }\n\n  klass = rb_define_class_id(\n      // Docs say this parameter is ignored. User will assign return value to\n      // their own toplevel constant class name.\n      rb_intern(\"Message\"), cAbstractMessage);\n  rb_ivar_set(klass, descriptor_instancevar_interned, descriptor);\n  return klass;\n}\n\n/*\n * call-seq:\n *     Enum.lookup(number) => name\n *\n * This module method, provided on each generated enum module, looks up an enum\n * value by number and returns its name as a Ruby symbol, or nil if not found.\n */\nstatic VALUE enum_lookup(VALUE self, VALUE number) {\n  int32_t num = NUM2INT(number);\n  VALUE desc = rb_ivar_get(self, descriptor_instancevar_interned);\n  const upb_EnumDef* e = EnumDescriptor_GetEnumDef(desc);\n  const upb_EnumValueDef* ev = upb_EnumDef_FindValueByNumber(e, num);\n  if (ev) {\n    return ID2SYM(rb_intern(upb_EnumValueDef_Name(ev)));\n  } else {\n    return Qnil;\n  }\n}\n\n/*\n * call-seq:\n *     Enum.resolve(name) => number\n *\n * This module method, provided on each generated enum module, looks up an enum\n * value by name (as a Ruby symbol) and returns its name, or nil if not found.\n */\nstatic VALUE enum_resolve(VALUE self, VALUE sym) {\n  const char* name = rb_id2name(SYM2ID(sym));\n  VALUE desc = rb_ivar_get(self, descriptor_instancevar_interned);\n  const upb_EnumDef* e = EnumDescriptor_GetEnumDef(desc);\n  const upb_EnumValueDef* ev = upb_EnumDef_FindValueByName(e, name);\n  if (ev) {\n    return INT2NUM(upb_EnumValueDef_Number(ev));\n  } else {\n    return Qnil;\n  }\n}\n\n/*\n * call-seq:\n *     Enum.descriptor\n *\n * This module method, provided on each generated enum module, returns the\n * EnumDescriptor corresponding to this enum type.\n */\nstatic VALUE enum_descriptor(VALUE self) {\n  return rb_ivar_get(self, descriptor_instancevar_interned);\n}\n\nVALUE build_module_from_enumdesc(VALUE _enumdesc) {\n  const upb_EnumDef* e = EnumDescriptor_GetEnumDef(_enumdesc);\n  VALUE mod = rb_define_module_id(rb_intern(upb_EnumDef_FullName(e)));\n\n  int n = upb_EnumDef_ValueCount(e);\n  for (int i = 0; i < n; i++) {\n    const upb_EnumValueDef* ev = upb_EnumDef_Value(e, i);\n    char* name = strdup(upb_EnumValueDef_Name(ev));\n    int32_t value = upb_EnumValueDef_Number(ev);\n    if (name[0] < 'A' || name[0] > 'Z') {\n      if (name[0] >= 'a' && name[0] <= 'z') {\n        name[0] -= 32; // auto capitalize\n      } else {\n        rb_warn(\n          \"Enum value '%s' does not start with an uppercase letter \"\n          \"as is required for Ruby constants.\",\n          name);\n      }\n    }\n    rb_define_const(mod, name, INT2NUM(value));\n    free(name);\n  }\n\n  rb_define_singleton_method(mod, \"lookup\", enum_lookup, 1);\n  rb_define_singleton_method(mod, \"resolve\", enum_resolve, 1);\n  rb_define_singleton_method(mod, \"descriptor\", enum_descriptor, 0);\n  rb_ivar_set(mod, descriptor_instancevar_interned, _enumdesc);\n\n  return mod;\n}\n\n// Internal only; used by Google::Protobuf.deep_copy.\nupb_Message* Message_deep_copy(const upb_Message* msg, const upb_MessageDef* m,\n                               upb_Arena* arena) {\n  // Serialize and parse.\n  upb_Arena* tmp_arena = upb_Arena_New();\n  const upb_MiniTable* layout = upb_MessageDef_MiniTable(m);\n  size_t size;\n\n  char* data = upb_Encode(msg, layout, 0, tmp_arena, &size);\n  upb_Message* new_msg = upb_Message_New(m, arena);\n\n  if (!data || upb_Decode(data, size, new_msg, layout, NULL, 0, arena) !=\n                   kUpb_DecodeStatus_Ok) {\n    upb_Arena_Free(tmp_arena);\n    rb_raise(cParseError, \"Error occurred copying proto\");\n  }\n\n  upb_Arena_Free(tmp_arena);\n  return new_msg;\n}\n\nconst upb_Message* Message_GetUpbMessage(VALUE value, const upb_MessageDef* m,\n                                         const char* name, upb_Arena* arena) {\n  if (value == Qnil) {\n    rb_raise(cTypeError, \"nil message not allowed here.\");\n  }\n\n  VALUE klass = CLASS_OF(value);\n  VALUE desc_rb = rb_ivar_get(klass, descriptor_instancevar_interned);\n  const upb_MessageDef* val_m =\n      desc_rb == Qnil ? NULL : Descriptor_GetMsgDef(desc_rb);\n\n  if (val_m != m) {\n    // Check for possible implicit conversions\n    // TODO: hash conversion?\n\n    switch (upb_MessageDef_WellKnownType(m)) {\n      case kUpb_WellKnown_Timestamp: {\n        // Time -> Google::Protobuf::Timestamp\n        upb_Message* msg = upb_Message_New(m, arena);\n        upb_MessageValue sec, nsec;\n        struct timespec time;\n        const upb_FieldDef* sec_f = upb_MessageDef_FindFieldByNumber(m, 1);\n        const upb_FieldDef* nsec_f = upb_MessageDef_FindFieldByNumber(m, 2);\n\n        if (!rb_obj_is_kind_of(value, rb_cTime)) goto badtype;\n\n        time = rb_time_timespec(value);\n        sec.int64_val = time.tv_sec;\n        nsec.int32_val = time.tv_nsec;\n        upb_Message_Set(msg, sec_f, sec, arena);\n        upb_Message_Set(msg, nsec_f, nsec, arena);\n        return msg;\n      }\n      case kUpb_WellKnown_Duration: {\n        // Numeric -> Google::Protobuf::Duration\n        upb_Message* msg = upb_Message_New(m, arena);\n        upb_MessageValue sec, nsec;\n        const upb_FieldDef* sec_f = upb_MessageDef_FindFieldByNumber(m, 1);\n        const upb_FieldDef* nsec_f = upb_MessageDef_FindFieldByNumber(m, 2);\n\n        if (!rb_obj_is_kind_of(value, rb_cNumeric)) goto badtype;\n\n        sec.int64_val = NUM2LL(value);\n        nsec.int32_val = round((NUM2DBL(value) - NUM2LL(value)) * 1000000000);\n        upb_Message_Set(msg, sec_f, sec, arena);\n        upb_Message_Set(msg, nsec_f, nsec, arena);\n        return msg;\n      }\n      default:\n      badtype:\n        rb_raise(cTypeError,\n                 \"Invalid type %s to assign to submessage field '%s'.\",\n                 rb_class2name(CLASS_OF(value)), name);\n    }\n  }\n\n  Message* self = ruby_to_Message(value);\n  Arena_fuse(self->arena, arena);\n\n  return self->msg;\n}\n\nstatic void Message_define_class(VALUE klass) {\n  rb_define_alloc_func(klass, Message_alloc);\n\n  rb_require(\"google/protobuf/message_exts\");\n  rb_define_method(klass, \"method_missing\", Message_method_missing, -1);\n  rb_define_method(klass, \"respond_to_missing?\", Message_respond_to_missing,\n                   -1);\n  rb_define_method(klass, \"initialize\", Message_initialize, -1);\n  rb_define_method(klass, \"dup\", Message_dup, 0);\n  // Also define #clone so that we don't inherit Object#clone.\n  rb_define_method(klass, \"clone\", Message_dup, 0);\n  rb_define_method(klass, \"==\", Message_eq, 1);\n  rb_define_method(klass, \"eql?\", Message_eq, 1);\n  rb_define_method(klass, \"freeze\", Message_freeze, 0);\n  rb_define_method(klass, \"hash\", Message_hash, 0);\n  rb_define_method(klass, \"to_h\", Message_to_h, 0);\n  rb_define_method(klass, \"inspect\", Message_inspect, 0);\n  rb_define_method(klass, \"to_s\", Message_inspect, 0);\n  rb_define_method(klass, \"[]\", Message_index, 1);\n  rb_define_method(klass, \"[]=\", Message_index_set, 2);\n  rb_define_singleton_method(klass, \"decode\", Message_decode, -1);\n  rb_define_singleton_method(klass, \"encode\", Message_encode, -1);\n  rb_define_singleton_method(klass, \"decode_json\", Message_decode_json, -1);\n  rb_define_singleton_method(klass, \"encode_json\", Message_encode_json, -1);\n  rb_define_singleton_method(klass, \"descriptor\", Message_descriptor, 0);\n}\n\nvoid Message_register(VALUE protobuf) {\n  cParseError = rb_const_get(protobuf, rb_intern(\"ParseError\"));\n  cAbstractMessage = rb_define_class_under(protobuf, \"AbstractMessage\", rb_cObject);\n  Message_define_class(cAbstractMessage);\n  rb_gc_register_address(&cAbstractMessage);\n\n  // Ruby-interned string: \"descriptor\". We use this identifier to store an\n  // instance variable on message classes we create in order to link them back\n  // to their descriptors.\n  descriptor_instancevar_interned = rb_intern(\"@descriptor\");\n}\n", "/*\n * Protocol Buffers - Google's data interchange format\n * Copyright 2014 Google Inc.  All rights reserved.\n * https://developers.google.com/protocol-buffers/\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *     * Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above\n * copyright notice, this list of conditions and the following disclaimer\n * in the documentation and/or other materials provided with the\n * distribution.\n *     * Neither the name of Google Inc. nor the names of its\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage com.google.protobuf.jruby;\n\nimport com.google.protobuf.DescriptorProtos.EnumDescriptorProto;\nimport com.google.protobuf.Descriptors.EnumDescriptor;\nimport com.google.protobuf.Descriptors.EnumValueDescriptor;\nimport com.google.protobuf.Descriptors.FileDescriptor;\nimport org.jruby.Ruby;\nimport org.jruby.RubyClass;\nimport org.jruby.RubyModule;\nimport org.jruby.RubyNumeric;\nimport org.jruby.RubyObject;\nimport org.jruby.anno.JRubyClass;\nimport org.jruby.anno.JRubyMethod;\nimport org.jruby.runtime.Block;\nimport org.jruby.runtime.ObjectAllocator;\nimport org.jruby.runtime.ThreadContext;\nimport org.jruby.runtime.builtin.IRubyObject;\n\n@JRubyClass(name = \"EnumDescriptor\", include = \"Enumerable\")\npublic class RubyEnumDescriptor extends RubyObject {\n  public static void createRubyEnumDescriptor(Ruby runtime) {\n    RubyModule mProtobuf = runtime.getClassFromPath(\"Google::Protobuf\");\n    RubyClass cEnumDescriptor =\n        mProtobuf.defineClassUnder(\n            \"EnumDescriptor\",\n            runtime.getObject(),\n            new ObjectAllocator() {\n              @Override\n              public IRubyObject allocate(Ruby runtime, RubyClass klazz) {\n                return new RubyEnumDescriptor(runtime, klazz);\n              }\n            });\n    cEnumDescriptor.includeModule(runtime.getEnumerable());\n    cEnumDescriptor.defineAnnotatedMethods(RubyEnumDescriptor.class);\n  }\n\n  public RubyEnumDescriptor(Ruby runtime, RubyClass klazz) {\n    super(runtime, klazz);\n  }\n\n  /*\n   * call-seq:\n   *     EnumDescriptor.name => name\n   *\n   * Returns the name of this enum type.\n   */\n  @JRubyMethod(name = \"name\")\n  public IRubyObject getName(ThreadContext context) {\n    return this.name;\n  }\n\n  /*\n   * call-seq:\n   *     EnumDescriptor.each(&block)\n   *\n   * Iterates over key => value mappings in this enum's definition, yielding to\n   * the block with (key, value) arguments for each one.\n   */\n  @JRubyMethod\n  public IRubyObject each(ThreadContext context, Block block) {\n    Ruby runtime = context.runtime;\n    for (EnumValueDescriptor enumValueDescriptor : descriptor.getValues()) {\n      block.yield(\n          context,\n          runtime.newArray(\n              runtime.newSymbol(enumValueDescriptor.getName()),\n              runtime.newFixnum(enumValueDescriptor.getNumber())));\n    }\n    return context.nil;\n  }\n\n  /*\n   * call-seq:\n   *     EnumDescriptor.enummodule => module\n   *\n   * Returns the Ruby module corresponding to this enum type. Cannot be called\n   * until the enum descriptor has been added to a pool.\n   */\n  @JRubyMethod\n  public IRubyObject enummodule(ThreadContext context) {\n    return module;\n  }\n\n  /*\n   * call-seq:\n   *    EnumDescriptor.file_descriptor\n   *\n   * Returns the FileDescriptor object this enum belongs to.\n   */\n  @JRubyMethod(name = \"file_descriptor\")\n  public IRubyObject getFileDescriptor(ThreadContext context) {\n    return RubyFileDescriptor.getRubyFileDescriptor(context, descriptor);\n  }\n\n  public boolean isValidValue(ThreadContext context, IRubyObject value) {\n    EnumValueDescriptor enumValue;\n\n    if (Utils.isRubyNum(value)) {\n      enumValue = descriptor.findValueByNumberCreatingIfUnknown(RubyNumeric.num2int(value));\n    } else {\n      enumValue = descriptor.findValueByName(value.asJavaString());\n    }\n\n    return enumValue != null;\n  }\n\n  protected IRubyObject nameToNumber(ThreadContext context, IRubyObject name) {\n    EnumValueDescriptor value = descriptor.findValueByName(name.asJavaString());\n    return value == null ? context.nil : context.runtime.newFixnum(value.getNumber());\n  }\n\n  protected IRubyObject numberToName(ThreadContext context, IRubyObject number) {\n    EnumValueDescriptor value = descriptor.findValueByNumber(RubyNumeric.num2int(number));\n    return value == null ? context.nil : context.runtime.newSymbol(value.getName());\n  }\n\n  protected void setDescriptor(ThreadContext context, EnumDescriptor descriptor) {\n    this.descriptor = descriptor;\n    this.module = buildModuleFromDescriptor(context);\n  }\n\n  protected void setName(IRubyObject name) {\n    this.name = name;\n  }\n\n  private RubyModule buildModuleFromDescriptor(ThreadContext context) {\n    Ruby runtime = context.runtime;\n\n    RubyModule enumModule = RubyModule.newModule(runtime);\n    boolean defaultValueRequiredButNotFound =\n        descriptor.getFile().getSyntax() == FileDescriptor.Syntax.PROTO3;\n    for (EnumValueDescriptor value : descriptor.getValues()) {\n      String name = fixEnumConstantName(value.getName());\n      // Make sure it's a valid constant name before trying to create it\n      int ch = name.codePointAt(0);\n      if (Character.isUpperCase(ch)) {\n        enumModule.defineConstant(name, runtime.newFixnum(value.getNumber()));\n      } else {\n        runtime\n            .getWarnings()\n            .warn(\n                \"Enum value \"\n                    + name\n                    + \" does not start with an uppercase letter as is required for Ruby\"\n                    + \" constants.\");\n      }\n      if (value.getNumber() == 0) {\n        defaultValueRequiredButNotFound = false;\n      }\n    }\n\n    if (defaultValueRequiredButNotFound) {\n      throw Utils.createTypeError(\n          context, \"Enum definition \" + name + \" does not contain a value for '0'\");\n    }\n    enumModule.instance_variable_set(runtime.newString(Utils.DESCRIPTOR_INSTANCE_VAR), this);\n    enumModule.defineAnnotatedMethods(RubyEnum.class);\n    return enumModule;\n  }\n\n  private static String fixEnumConstantName(String name) {\n    if (name != null && name.length() > 0) {\n      int ch = name.codePointAt(0);\n      if (ch >= 'a' && ch <= 'z') {\n        // Protobuf enums can start with lowercase letters, while Ruby's constant should\n        // always start with uppercase letters. We tolerate this case by capitalizing\n        // the first character if possible.\n        return new StringBuilder()\n                .appendCodePoint(Character.toUpperCase(ch))\n                .append(name.substring(1))\n                .toString();\n      }\n    }\n    return name;\n  }\n\n  private EnumDescriptor descriptor;\n  private EnumDescriptorProto.Builder builder;\n  private IRubyObject name;\n  private RubyModule module;\n}\n", "syntax = \"proto3\";\n\npackage basic_test;\n\nimport \"google/protobuf/wrappers.proto\";\nimport \"google/protobuf/timestamp.proto\";\nimport \"google/protobuf/duration.proto\";\nimport \"google/protobuf/struct.proto\";\nimport \"test_import_proto2.proto\";\n\nmessage Foo {\n  Bar bar = 1;\n  repeated Baz baz = 2;\n}\n\nmessage Bar {\n  string msg = 1;\n}\n\nmessage Baz {\n  string msg = 1;\n}\n\nmessage TestMessage {\n  optional int32 optional_int32 = 1;\n  optional int64 optional_int64 = 2;\n  optional uint32 optional_uint32 = 3;\n  optional uint64 optional_uint64 = 4;\n  optional bool optional_bool = 5;\n  optional float optional_float = 6;\n  optional double optional_double = 7;\n  optional string optional_string = 8;\n  optional bytes optional_bytes = 9;\n  optional TestMessage2 optional_msg = 10;\n  optional TestEnum optional_enum = 11;\n  optional foo_bar.proto2.TestImportedMessage optional_proto2_submessage = 24;\n\n  repeated int32 repeated_int32 = 12;\n  repeated int64 repeated_int64 = 13;\n  repeated uint32 repeated_uint32 = 14;\n  repeated uint64 repeated_uint64 = 15;\n  repeated bool repeated_bool = 16;\n  repeated float repeated_float = 17;\n  repeated double repeated_double = 18;\n  repeated string repeated_string = 19;\n  repeated bytes repeated_bytes = 20;\n  repeated TestMessage2 repeated_msg = 21;\n  repeated TestEnum repeated_enum = 22;\n\n  optional TestSingularFields optional_msg2 = 23;\n}\n\nmessage TestSingularFields {\n  int32 singular_int32 = 1;\n  int64 singular_int64 = 2;\n  uint32 singular_uint32 = 3;\n  uint64 singular_uint64 = 4;\n  bool singular_bool = 5;\n  float singular_float = 6;\n  double singular_double = 7;\n  string singular_string = 8;\n  bytes singular_bytes = 9;\n  TestMessage2 singular_msg = 10;\n  TestEnum singular_enum = 11;\n}\n\nmessage TestMessage2 {\n  optional int32 foo = 1;\n}\n\nenum TestEnum {\n  Default = 0;\n  A = 1;\n  B = 2;\n  C = 3;\n  v0 = 4;\n}\n\nmessage TestEmbeddedMessageParent {\n  TestEmbeddedMessageChild child_msg = 1;\n  int32 number = 2;\n\n  repeated TestEmbeddedMessageChild repeated_msg = 3;\n  repeated int32 repeated_number = 4;\n}\n\nmessage TestEmbeddedMessageChild {\n  TestMessage sub_child = 1;\n}\n\nmessage Recursive1 {\n  Recursive2 foo = 1;\n}\n\nmessage Recursive2 {\n  Recursive1 foo = 1;\n}\n\nmessage MapMessage {\n  map<string, int32> map_string_int32 = 1;\n  map<string, TestMessage2> map_string_msg = 2;\n  map<string, TestEnum> map_string_enum = 3;\n}\n\nmessage MapMessageWireEquiv {\n  repeated MapMessageWireEquiv_entry1 map_string_int32 = 1;\n  repeated MapMessageWireEquiv_entry2 map_string_msg = 2;\n}\n\nmessage MapMessageWireEquiv_entry1 {\n  string key = 1;\n  int32 value = 2;\n}\n\nmessage MapMessageWireEquiv_entry2 {\n  string key = 1;\n  TestMessage2 value = 2;\n}\n\nmessage OneofMessage {\n  oneof my_oneof {\n    string a = 1;\n    int32 b = 2;\n    TestMessage2 c = 3;\n    TestEnum d = 4;\n  }\n}\n\nmessage Outer {\n  map<int32, Inner> items = 1;\n}\n\nmessage Inner {\n}\n\nmessage Wrapper {\n  google.protobuf.DoubleValue double = 1;\n  google.protobuf.FloatValue float = 2;\n  google.protobuf.Int32Value int32 = 3;\n  google.protobuf.Int64Value int64 = 4;\n  google.protobuf.UInt32Value uint32 = 5;\n  google.protobuf.UInt64Value uint64 = 6;\n  google.protobuf.BoolValue bool = 7;\n  google.protobuf.StringValue string = 8;\n  google.protobuf.BytesValue bytes = 9;\n  string real_string = 100;\n  oneof a_oneof {\n    string string_in_oneof = 10;\n  }\n\n  // Repeated wrappers don't make sense, but we still need to make sure they\n  // work and don't crash.\n  repeated google.protobuf.DoubleValue repeated_double = 11;\n  repeated google.protobuf.FloatValue repeated_float = 12;\n  repeated google.protobuf.Int32Value repeated_int32 = 13;\n  repeated google.protobuf.Int64Value repeated_int64 = 14;\n  repeated google.protobuf.UInt32Value repeated_uint32 = 15;\n  repeated google.protobuf.UInt64Value repeated_uint64 = 16;\n  repeated google.protobuf.BoolValue repeated_bool = 17;\n  repeated google.protobuf.StringValue repeated_string = 18;\n  repeated google.protobuf.BytesValue repeated_bytes = 19;\n\n  // Wrappers as map keys don't make sense, but we still need to make sure they\n  // work and don't crash.\n  map<int32, google.protobuf.DoubleValue> map_double = 21;\n  map<int32, google.protobuf.FloatValue> map_float = 22;\n  map<int32, google.protobuf.Int32Value> map_int32 = 23;\n  map<int32, google.protobuf.Int64Value> map_int64 = 24;\n  map<int32, google.protobuf.UInt32Value> map_uint32 = 25;\n  map<int32, google.protobuf.UInt64Value> map_uint64 = 26;\n  map<int32, google.protobuf.BoolValue> map_bool = 27;\n  map<int32, google.protobuf.StringValue> map_string = 28;\n  map<int32, google.protobuf.BytesValue> map_bytes = 29;\n\n  // Wrappers in oneofs don't make sense, but we still need to make sure they\n  // work and don't crash.\n  oneof wrapper_oneof {\n    google.protobuf.DoubleValue oneof_double = 31;\n    google.protobuf.FloatValue oneof_float = 32;\n    google.protobuf.Int32Value oneof_int32 = 33;\n    google.protobuf.Int64Value oneof_int64 = 34;\n    google.protobuf.UInt32Value oneof_uint32 = 35;\n    google.protobuf.UInt64Value oneof_uint64 = 36;\n    google.protobuf.BoolValue oneof_bool = 37;\n    google.protobuf.StringValue oneof_string = 38;\n    google.protobuf.BytesValue oneof_bytes = 39;\n    string oneof_plain_string = 101;\n  }\n}\n\nmessage TimeMessage {\n  google.protobuf.Timestamp timestamp = 1;\n  google.protobuf.Duration duration = 2;\n}\n\nmessage Enumer {\n  TestEnum optional_enum = 1;\n  repeated TestEnum repeated_enum = 2;\n  string a_const = 3;\n  oneof a_oneof {\n    string str = 10;\n    TestEnum const = 11;\n  }\n}\n\nmessage MyRepeatedStruct {\n  repeated MyStruct structs = 1;\n}\n\nmessage MyStruct {\n  string string = 1;\n  google.protobuf.Struct struct = 2;\n}\n\nmessage WithJsonName {\n  optional int32 foo_bar = 1 [json_name=\"jsonFooBar\"];\n  repeated WithJsonName baz = 2 [json_name=\"jsonBaz\"];\n}\n\nmessage HelloRequest {\n  optional uint32 id = 1;\n  optional uint32 random_name_a0 = 2;\n  optional uint32 random_name_a1 = 3;\n  optional uint32 random_name_a2 = 4;\n  optional uint32 random_name_a3 = 5;\n  optional uint32 random_name_a4 = 6;\n  optional uint32 random_name_a5 = 7;\n  optional uint32 random_name_a6 = 8;\n  optional uint32 random_name_a7 = 9;\n  optional uint32 random_name_a8 = 10;\n  optional uint32 random_name_a9 = 11;\n  optional uint32 random_name_b0 = 12;\n  optional uint32 random_name_b1 = 13;\n  optional uint32 random_name_b2 = 14;\n  optional uint32 random_name_b3 = 15;\n  optional uint32 random_name_b4 = 16;\n  optional uint32 random_name_b5 = 17;\n  optional uint32 random_name_b6 = 18;\n  optional uint32 random_name_b7 = 19;\n  optional uint32 random_name_b8 = 20;\n  optional uint32 random_name_b9 = 21;\n  optional uint32 random_name_c0 = 22;\n  optional uint32 random_name_c1 = 23;\n  optional uint32 random_name_c2 = 24;\n  optional uint32 random_name_c3 = 25;\n  optional uint32 random_name_c4 = 26;\n  optional uint32 random_name_c5 = 27;\n  optional uint32 random_name_c6 = 28;\n  optional uint32 random_name_c7 = 29;\n  optional uint32 random_name_c8 = 30;\n  optional uint32 random_name_c9 = 31;\n  optional string version = 32;\n}\n", "syntax = \"proto2\";\n\npackage basic_test_proto2;\n\nimport \"google/protobuf/wrappers.proto\";\nimport \"google/protobuf/timestamp.proto\";\nimport \"google/protobuf/duration.proto\";\nimport \"google/protobuf/struct.proto\";\n\nmessage Foo {\n  optional Bar bar = 1;\n  repeated Baz baz = 2;\n}\n\nmessage Bar {\n  optional string msg = 1;\n}\n\nmessage Baz {\n  optional string msg = 1;\n}\n\nmessage TestMessage {\n  optional int32 optional_int32 = 1;\n  optional int64 optional_int64 = 2;\n  optional uint32 optional_uint32 = 3;\n  optional uint64 optional_uint64 = 4;\n  optional bool optional_bool = 5;\n  optional float optional_float = 6;\n  optional double optional_double = 7;\n  optional string optional_string = 8;\n  optional bytes optional_bytes = 9;\n  optional TestMessage2 optional_msg = 10;\n  optional TestEnum optional_enum = 11;\n\n  repeated int32 repeated_int32 = 12;\n  repeated int64 repeated_int64 = 13;\n  repeated uint32 repeated_uint32 = 14;\n  repeated uint64 repeated_uint64 = 15;\n  repeated bool repeated_bool = 16;\n  repeated float repeated_float = 17;\n  repeated double repeated_double = 18;\n  repeated string repeated_string = 19;\n  repeated bytes repeated_bytes = 20;\n  repeated TestMessage2 repeated_msg = 21;\n  repeated TestEnum repeated_enum = 22;\n}\n\nmessage TestMessage2 {\n  optional int32 foo = 1;\n}\n\nmessage TestMessageDefaults {\n  optional int32 optional_int32 = 1 [default = 1];\n  optional int64 optional_int64 = 2 [default = 2];\n  optional uint32 optional_uint32 = 3 [default = 3];\n  optional uint64 optional_uint64 = 4 [default = 4];\n  optional bool optional_bool = 5 [default = true];\n  optional float optional_float = 6 [default = 6];\n  optional double optional_double = 7 [default = 7];\n  optional string optional_string = 8 [default = \"Default Str\"];\n  optional bytes optional_bytes = 9 [default = \"\\xCF\\xA5s\\xBD\\xBA\\xE6fubar\"];\n  optional TestMessage2 optional_msg = 10;\n  optional TestNonZeroEnum optional_enum = 11 [default = B2];\n}\n\nenum TestEnum {\n  Default = 0;\n  A = 1;\n  B = 2;\n  C = 3;\n  v0 = 4;\n}\n\nenum TestNonZeroEnum {\n  A2 = 1;\n  B2 = 2;\n  C2 = 3;\n}\n\nmessage TestEmbeddedMessageParent {\n  optional TestEmbeddedMessageChild child_msg = 1;\n  optional int32 number = 2;\n\n  repeated TestEmbeddedMessageChild repeated_msg = 3;\n  repeated int32 repeated_number = 4;\n}\n\nmessage TestEmbeddedMessageChild {\n  optional TestMessage sub_child = 1;\n}\n\nmessage Recursive1 {\n  optional Recursive2 foo = 1;\n}\n\nmessage Recursive2 {\n  optional Recursive1 foo = 1;\n}\n\nmessage MapMessageWireEquiv {\n  repeated MapMessageWireEquiv_entry1 map_string_int32 = 1;\n  repeated MapMessageWireEquiv_entry2 map_string_msg = 2;\n}\n\nmessage MapMessageWireEquiv_entry1 {\n  optional string key = 1;\n  optional int32 value = 2;\n}\n\nmessage MapMessageWireEquiv_entry2 {\n  optional string key = 1;\n  optional TestMessage2 value = 2;\n}\n\nmessage OneofMessage {\n  oneof my_oneof {\n    string a = 1;\n    int32 b = 2;\n    TestMessage2 c = 3;\n    TestEnum d = 4;\n  }\n}\n\nmessage Wrapper {\n  optional google.protobuf.DoubleValue double = 1;\n  optional google.protobuf.FloatValue float = 2;\n  optional google.protobuf.Int32Value int32 = 3;\n  optional google.protobuf.Int64Value int64 = 4;\n  optional google.protobuf.UInt32Value uint32 = 5;\n  optional google.protobuf.UInt64Value uint64 = 6;\n  optional google.protobuf.BoolValue bool = 7;\n  optional google.protobuf.StringValue string = 8;\n  optional google.protobuf.BytesValue bytes = 9;\n  optional string real_string = 100;\n  oneof a_oneof {\n    string string_in_oneof = 10;\n  }\n\n  // Repeated wrappers don't really make sense, but we still need to make sure\n  // they work and don't crash.\n  repeated google.protobuf.DoubleValue repeated_double = 11;\n  repeated google.protobuf.FloatValue repeated_float = 12;\n  repeated google.protobuf.Int32Value repeated_int32 = 13;\n  repeated google.protobuf.Int64Value repeated_int64 = 14;\n  repeated google.protobuf.UInt32Value repeated_uint32 = 15;\n  repeated google.protobuf.UInt64Value repeated_uint64 = 16;\n  repeated google.protobuf.BoolValue repeated_bool = 17;\n  repeated google.protobuf.StringValue repeated_string = 18;\n  repeated google.protobuf.BytesValue repeated_bytes = 19;\n\n  // Wrappers in oneofs don't make sense, but we still need to make sure they\n  // work and don't crash.\n  oneof wrapper_oneof {\n    google.protobuf.DoubleValue oneof_double = 31;\n    google.protobuf.FloatValue oneof_float = 32;\n    google.protobuf.Int32Value oneof_int32 = 33;\n    google.protobuf.Int64Value oneof_int64 = 34;\n    google.protobuf.UInt32Value oneof_uint32 = 35;\n    google.protobuf.UInt64Value oneof_uint64 = 36;\n    google.protobuf.BoolValue oneof_bool = 37;\n    google.protobuf.StringValue oneof_string = 38;\n    google.protobuf.BytesValue oneof_bytes = 39;\n    string oneof_plain_string = 101;\n  }\n}\n\nmessage TimeMessage {\n  optional google.protobuf.Timestamp timestamp = 1;\n  optional google.protobuf.Duration duration = 2;\n}\n\nmessage Enumer {\n  optional TestEnum optional_enum = 11;\n  repeated TestEnum repeated_enum = 22;\n  optional string a_const = 3;\n  oneof a_oneof {\n    string str = 100;\n    TestEnum const = 101;\n  }\n}\n\nmessage MyRepeatedStruct {\n  repeated MyStruct structs = 1;\n}\n\nmessage MyStruct {\n  optional string string = 1;\n  optional google.protobuf.Struct struct = 2;\n}\n", "require 'google/protobuf/wrappers_pb.rb'\n\n# Defines tests which are common between proto2 and proto3 syntax.\n#\n# Requires that the proto messages are exactly the same in proto2 and proto3 syntax\n# and that the including class should define a 'proto_module' method which returns\n# the enclosing module of the proto message classes.\n\nrequire 'bigdecimal'\n\nmodule CommonTests\n  # Ruby 2.5 changed to raise FrozenError instead of RuntimeError\n  FrozenErrorType = Gem::Version.new(RUBY_VERSION) < Gem::Version.new('2.5') ? RuntimeError : FrozenError\n\n  def test_defaults\n    m = proto_module::TestMessage.new\n    assert m.optional_int32 == 0\n    assert m.optional_int64 == 0\n    assert m.optional_uint32 == 0\n    assert m.optional_uint64 == 0\n    assert m.optional_bool == false\n    assert m.optional_float == 0.0\n    assert m.optional_double == 0.0\n    assert m.optional_string == \"\"\n    assert m.optional_bytes == \"\"\n    assert m.optional_msg == nil\n    assert m.optional_enum == :Default\n  end\n\n  def test_setters\n    m = proto_module::TestMessage.new\n    m.optional_int32 = -42\n    assert m.optional_int32 == -42\n    m.optional_int64 = -0x1_0000_0000\n    assert m.optional_int64 == -0x1_0000_0000\n    m.optional_uint32 = 0x9000_0000\n    assert m.optional_uint32 == 0x9000_0000\n    m.optional_uint64 = 0x9000_0000_0000_0000\n    assert m.optional_uint64 == 0x9000_0000_0000_0000\n    m.optional_bool = true\n    assert m.optional_bool == true\n    m.optional_float = 0.5\n    assert m.optional_float == 0.5\n    m.optional_double = 0.5\n    assert m.optional_double == 0.5\n    m.optional_string = \"hello\"\n    assert m.optional_string == \"hello\"\n    m.optional_string = :hello\n    assert m.optional_string == \"hello\"\n    m.optional_bytes = \"world\".encode!('ASCII-8BIT')\n    assert m.optional_bytes == \"world\"\n    m.optional_msg = proto_module::TestMessage2.new(:foo => 42)\n    assert m.optional_msg == proto_module::TestMessage2.new(:foo => 42)\n    m.optional_msg = nil\n    assert m.optional_msg == nil\n    m.optional_enum = :C\n    assert m.optional_enum == :C\n    m.optional_enum = 'C'\n    assert m.optional_enum == :C\n  end\n\n  def test_ctor_args\n    m = proto_module::TestMessage.new(:optional_int32 => -42,\n                                      :optional_msg => proto_module::TestMessage2.new,\n                                      :optional_enum => :C,\n                                      :repeated_string => [\"hello\", \"there\", \"world\"])\n    assert m.optional_int32 == -42\n    assert m.optional_msg.class == proto_module::TestMessage2\n    assert m.repeated_string.length == 3\n    assert m.optional_enum == :C\n    assert m.repeated_string[0] == \"hello\"\n    assert m.repeated_string[1] == \"there\"\n    assert m.repeated_string[2] == \"world\"\n  end\n\n  def test_ctor_string_symbol_args\n    m = proto_module::TestMessage.new(:optional_enum => 'C', :repeated_enum => ['A', 'B'])\n    assert_equal :C, m.optional_enum\n    assert_equal [:A, :B], m.repeated_enum\n\n    m = proto_module::TestMessage.new(:optional_string => :foo, :repeated_string => [:foo, :bar])\n    assert_equal 'foo', m.optional_string\n    assert_equal ['foo', 'bar'], m.repeated_string\n  end\n\n  def test_ctor_nil_args\n    m = proto_module::TestMessage.new(:optional_enum => nil, :optional_int32 => nil, :optional_string => nil, :optional_msg => nil)\n\n    assert_equal :Default, m.optional_enum\n    assert_equal 0, m.optional_int32\n    assert_equal \"\", m.optional_string\n    assert_nil m.optional_msg\n  end\n\n  def test_embeddedmsg_hash_init\n    m = proto_module::TestEmbeddedMessageParent.new(\n      :child_msg => {sub_child: {optional_int32: 1}},\n      :number => 2,\n      :repeated_msg => [{sub_child: {optional_int32: 3}}],\n      :repeated_number => [10, 20, 30])\n\n    assert_equal 2, m.number\n    assert_equal [10, 20, 30], m.repeated_number\n\n    assert_not_nil m.child_msg\n    assert_not_nil m.child_msg.sub_child\n    assert_equal m.child_msg.sub_child.optional_int32, 1\n\n    assert_not_nil m.repeated_msg\n    assert_equal 1, m.repeated_msg.length\n    assert_equal 3, m.repeated_msg.first.sub_child.optional_int32\n  end\n\n  def test_inspect_eq_to_s\n    m = proto_module::TestMessage.new(\n      :optional_int32 => -42,\n      :optional_enum => :A,\n      :optional_msg => proto_module::TestMessage2.new(foo: 0),\n      :repeated_string => [\"hello\", \"there\", \"world\"])\n    expected = \"<#{proto_module}::TestMessage: optional_int32: -42, optional_msg: <#{proto_module}::TestMessage2: foo: 0>, optional_enum: :A, repeated_int32: [], repeated_int64: [], repeated_uint32: [], repeated_uint64: [], repeated_bool: [], repeated_float: [], repeated_double: [], repeated_string: [\\\"hello\\\", \\\"there\\\", \\\"world\\\"], repeated_bytes: [], repeated_msg: [], repeated_enum: []>\"\n    assert_equal expected, m.inspect\n    assert_equal expected, m.to_s\n\n    m = proto_module::OneofMessage.new(:b => -42)\n    expected = \"<#{proto_module}::OneofMessage: b: -42>\"\n    assert_equal expected, m.inspect\n    assert_equal expected, m.to_s\n  end\n\n  def test_hash\n    m1 = proto_module::TestMessage.new(:optional_int32 => 42)\n    m2 = proto_module::TestMessage.new(:optional_int32 => 102, repeated_string: ['please', 'work', 'ok?'])\n    m3 = proto_module::TestMessage.new(:optional_int32 => 102, repeated_string: ['please', 'work', 'ok?'])\n    assert m1.hash != 0\n    assert m2.hash != 0\n    assert m3.hash != 0\n    # relying on the randomness here -- if hash function changes and we are\n    # unlucky enough to get a collision, then change the values above.\n    assert m1.hash != m2.hash\n    assert_equal m2.hash, m3.hash\n  end\n\n  def test_unknown_field_errors\n    e = assert_raise NoMethodError do\n      proto_module::TestMessage.new.hello\n    end\n    assert_match(/hello/, e.message)\n\n    e = assert_raise NoMethodError do\n      proto_module::TestMessage.new.hello = \"world\"\n    end\n    assert_match(/hello/, e.message)\n  end\n\n  def test_type_errors\n    m = proto_module::TestMessage.new\n    e = assert_raise Google::Protobuf::TypeError do\n      m.optional_int32 = \"hello\"\n    end\n\n    # Google::Protobuf::TypeError should inherit from TypeError for backwards compatibility\n    # TODO: This can be removed when we can safely migrate to Google::Protobuf::TypeError\n    assert e.is_a?(::TypeError)\n\n    assert_raise Google::Protobuf::TypeError do\n      m.optional_string = 42\n    end\n    assert_raise Google::Protobuf::TypeError do\n      m.optional_string = nil\n    end\n    assert_raise Google::Protobuf::TypeError do\n      m.optional_bool = 42\n    end\n    assert_raise Google::Protobuf::TypeError do\n      m.optional_msg = proto_module::TestMessage.new  # expects TestMessage2\n    end\n\n    assert_raise Google::Protobuf::TypeError do\n      m.repeated_int32 = []  # needs RepeatedField\n    end\n\n    assert_raise Google::Protobuf::TypeError do\n      m.repeated_int32.push \"hello\"\n    end\n\n    assert_raise Google::Protobuf::TypeError do\n      m.repeated_msg.push proto_module::TestMessage.new\n    end\n  end\n\n  def test_string_encoding\n    m = proto_module::TestMessage.new\n\n    # Assigning a normal (ASCII or UTF8) string to a bytes field, or\n    # ASCII-8BIT to a string field will convert to the proper encoding.\n    m.optional_bytes = \"Test string ASCII\".encode!('ASCII')\n    assert m.optional_bytes.frozen?\n    assert_equal Encoding::ASCII_8BIT, m.optional_bytes.encoding\n    assert_equal \"Test string ASCII\", m.optional_bytes\n\n    assert_raise Encoding::UndefinedConversionError do\n      m.optional_bytes = \"Test string UTF-8 \\u0100\".encode!('UTF-8')\n    end\n\n    assert_raise Encoding::UndefinedConversionError do\n      m.optional_string = [\"FFFF\"].pack('H*')\n    end\n\n    # \"Ordinary\" use case.\n    m.optional_bytes = [\"FFFF\"].pack('H*')\n    m.optional_string = \"\\u0100\"\n\n    # strings are immutable so we can't do this, but serialize should catch it.\n    m.optional_string = \"asdf\".encode!('UTF-8')\n    assert_raise(FrozenErrorType) { m.optional_string.encode!('ASCII-8BIT') }\n  end\n\n  def test_rptfield_int32\n    l = Google::Protobuf::RepeatedField.new(:int32)\n    assert l.count == 0\n    l = Google::Protobuf::RepeatedField.new(:int32, [1, 2, 3])\n    assert l.count == 3\n    assert_equal [1, 2, 3], l\n    assert_equal l, [1, 2, 3]\n    l.push 4\n    assert l == [1, 2, 3, 4]\n    dst_list = []\n    l.each { |val| dst_list.push val }\n    assert dst_list == [1, 2, 3, 4]\n    assert l.to_a == [1, 2, 3, 4]\n    assert l[0] == 1\n    assert l[3] == 4\n    l[0] = 5\n    assert l == [5, 2, 3, 4]\n\n    l2 = l.dup\n    assert l == l2\n    assert l.object_id != l2.object_id\n    l2.push 6\n    assert l.count == 4\n    assert l2.count == 5\n\n    assert l.inspect == '[5, 2, 3, 4]'\n\n    l.concat([7, 8, 9])\n    assert l == [5, 2, 3, 4, 7, 8, 9]\n    assert l.pop == 9\n    assert l == [5, 2, 3, 4, 7, 8]\n\n    assert_raise Google::Protobuf::TypeError do\n      m = proto_module::TestMessage.new\n      l.push m\n    end\n\n    m = proto_module::TestMessage.new\n    m.repeated_int32 = l\n    assert m.repeated_int32 == [5, 2, 3, 4, 7, 8]\n    assert m.repeated_int32.object_id == l.object_id\n    l.push 42\n    assert m.repeated_int32.pop == 42\n\n    l3 = l + l.dup\n    assert l3.count == l.count * 2\n    l.count.times do |i|\n      assert l3[i] == l[i]\n      assert l3[l.count + i] == l[i]\n    end\n\n    l.clear\n    assert l.count == 0\n    l += [1, 2, 3, 4]\n    l.replace([5, 6, 7, 8])\n    assert l == [5, 6, 7, 8]\n\n    l4 = Google::Protobuf::RepeatedField.new(:int32)\n    l4[5] = 42\n    assert l4 == [0, 0, 0, 0, 0, 42]\n\n    l4 << 100\n    assert l4 == [0, 0, 0, 0, 0, 42, 100]\n    l4 << 101 << 102\n    assert l4 == [0, 0, 0, 0, 0, 42, 100, 101, 102]\n  end\n\n  def test_parent_rptfield\n    #make sure we set the RepeatedField and can add to it\n    m = proto_module::TestMessage.new\n    assert m.repeated_string == []\n    m.repeated_string << 'ok'\n    m.repeated_string.push('ok2')\n    assert m.repeated_string == ['ok', 'ok2']\n    m.repeated_string += ['ok3']\n    assert m.repeated_string == ['ok', 'ok2', 'ok3']\n  end\n\n  def test_rptfield_msg\n    l = Google::Protobuf::RepeatedField.new(:message, proto_module::TestMessage)\n    l.push proto_module::TestMessage.new\n    assert l.count == 1\n    assert_raise Google::Protobuf::TypeError do\n      l.push proto_module::TestMessage2.new\n    end\n    assert_raise Google::Protobuf::TypeError do\n      l.push 42\n    end\n\n    l2 = l.dup\n    assert l2[0] == l[0]\n    assert l2[0].object_id == l[0].object_id\n\n    l2 = Google::Protobuf.deep_copy(l)\n    assert l2[0] == l[0]\n    assert l2[0].object_id != l[0].object_id\n\n    l3 = l + l2\n    assert l3.count == 2\n    assert l3[0] == l[0]\n    assert l3[1] == l2[0]\n    l3[0].optional_int32 = 1000\n    assert l[0].optional_int32 == 1000\n\n    new_msg = proto_module::TestMessage.new(:optional_int32 => 200)\n    l4 = l + [new_msg]\n    assert l4.count == 2\n    new_msg.optional_int32 = 1000\n    assert l4[1].optional_int32 == 1000\n  end\n\n  def test_rptfield_enum\n    l = Google::Protobuf::RepeatedField.new(:enum, proto_module::TestEnum)\n    l.push :A\n    l.push :B\n    l.push :C\n    l.push :v0\n    assert l.count == 4\n    assert_raise RangeError do\n      l.push :D\n    end\n    assert l[0] == :A\n    assert l[3] == :v0\n\n    l.push 5\n    assert l[4] == 5\n  end\n\n  def test_rptfield_initialize\n    assert_raise ArgumentError do\n      Google::Protobuf::RepeatedField.new\n    end\n    assert_raise ArgumentError do\n      Google::Protobuf::RepeatedField.new(:message)\n    end\n    assert_raise ArgumentError do\n      Google::Protobuf::RepeatedField.new([1, 2, 3])\n    end\n    assert_raise ArgumentError do\n      Google::Protobuf::RepeatedField.new(:message, [proto_module::TestMessage2.new])\n    end\n  end\n\n  def test_rptfield_array_ducktyping\n    l = Google::Protobuf::RepeatedField.new(:int32)\n    length_methods = %w(count length size)\n    length_methods.each do |lm|\n      assert l.send(lm)  == 0\n    end\n    # out of bounds returns a nil\n    assert l[0] == nil\n    assert l[1] == nil\n    assert l[-1] == nil\n    l.push 4\n    length_methods.each do |lm|\n      assert l.send(lm) == 1\n    end\n    assert l[0] == 4\n    assert l[1] == nil\n    assert l[-1] == 4\n    assert l[-2] == nil\n\n    l.push 2\n    length_methods.each do |lm|\n      assert l.send(lm) == 2\n    end\n    assert l[0] == 4\n    assert l[1] == 2\n    assert l[2] == nil\n    assert l[-1] == 2\n    assert l[-2] == 4\n    assert l[-3] == nil\n\n    #adding out of scope will backfill with empty objects\n  end\n\n  def test_map_basic\n    # allowed key types:\n    # :int32, :int64, :uint32, :uint64, :bool, :string, :bytes.\n\n    m = Google::Protobuf::Map.new(:string, :int32)\n    m[\"asdf\"] = 1\n    assert m[\"asdf\"] == 1\n    m[\"jkl;\"] = 42\n    assert m == { \"jkl;\" => 42, \"asdf\" => 1 }\n    assert m.has_key?(\"asdf\")\n    assert !m.has_key?(\"qwerty\")\n    assert m.length == 2\n\n    m2 = m.dup\n    assert_equal m, m2\n    assert m.hash != 0\n    assert_equal m.hash, m2.hash\n\n    collected = {}\n    m.each { |k,v| collected[v] = k }\n    assert collected == { 42 => \"jkl;\", 1 => \"asdf\" }\n\n    assert m.delete(\"asdf\") == 1\n    assert !m.has_key?(\"asdf\")\n    assert m[\"asdf\"] == nil\n    assert !m.has_key?(\"asdf\")\n\n    # We only assert on inspect value when there is one map entry because the\n    # order in which elements appear is unspecified (depends on the internal\n    # hash function). We don't want a brittle test.\n    assert m.inspect == \"{\\\"jkl;\\\"=>42}\"\n\n    assert m.keys == [\"jkl;\"]\n    assert m.values == [42]\n\n    m.clear\n    assert m.length == 0\n    assert m == {}\n\n    assert_raise Google::Protobuf::TypeError do\n      m[1] = 1\n    end\n    assert_raise RangeError do\n      m[\"asdf\"] = 0x1_0000_0000\n    end\n  end\n\n  def test_b_8385\n    m1 = Google::Protobuf::Map.new(:string, :string)\n    m2 = Google::Protobuf::Map.new(:string, :string)\n\n    assert_equal m1, m2\n\n    m1[\"counter\"] = \"a\"\n    m2[\"counter\"] = \"aa\"\n\n    assert_not_equal m1, m2\n  end\n\n  def test_map_ctor\n    m = Google::Protobuf::Map.new(:string, :int32,\n                                  {\"a\" => 1, \"b\" => 2, \"c\" => 3})\n    assert m == {\"a\" => 1, \"c\" => 3, \"b\" => 2}\n  end\n\n  def test_map_keytypes\n    m = Google::Protobuf::Map.new(:int32, :int32)\n    m[1] = 42\n    m[-1] = 42\n    assert_raise RangeError do\n      m[0x8000_0000] = 1\n    end\n    assert_raise Google::Protobuf::TypeError do\n      m[\"asdf\"] = 1\n    end\n\n    m = Google::Protobuf::Map.new(:int64, :int32)\n    m[0x1000_0000_0000_0000] = 1\n    assert_raise RangeError do\n      m[0x1_0000_0000_0000_0000] = 1\n    end\n    assert_raise Google::Protobuf::TypeError do\n      m[\"asdf\"] = 1\n    end\n\n    m = Google::Protobuf::Map.new(:uint32, :int32)\n    m[0x8000_0000] = 1\n    assert_raise RangeError do\n      m[0x1_0000_0000] = 1\n    end\n    assert_raise RangeError do\n      m[-1] = 1\n    end\n\n    m = Google::Protobuf::Map.new(:uint64, :int32)\n    m[0x8000_0000_0000_0000] = 1\n    assert_raise RangeError do\n      m[0x1_0000_0000_0000_0000] = 1\n    end\n    assert_raise RangeError do\n      m[-1] = 1\n    end\n\n    m = Google::Protobuf::Map.new(:bool, :int32)\n    m[true] = 1\n    m[false] = 2\n    assert_raise Google::Protobuf::TypeError do\n      m[1] = 1\n    end\n    assert_raise Google::Protobuf::TypeError do\n      m[\"asdf\"] = 1\n    end\n\n    m = Google::Protobuf::Map.new(:string, :int32)\n    m[\"asdf\"] = 1\n    assert_raise Google::Protobuf::TypeError do\n      m[1] = 1\n    end\n    assert_raise Encoding::UndefinedConversionError do\n      bytestring = [\"FFFF\"].pack(\"H*\")\n      m[bytestring] = 1\n    end\n\n    m = Google::Protobuf::Map.new(:bytes, :int32)\n    bytestring = [\"FFFF\"].pack(\"H*\")\n    m[bytestring] = 1\n    # Allowed -- we will automatically convert to ASCII-8BIT.\n    m[\"asdf\"] = 1\n    assert_raise Google::Protobuf::TypeError do\n      m[1] = 1\n    end\n  end\n\n  def test_map_msg_enum_valuetypes\n    m = Google::Protobuf::Map.new(:string, :message, proto_module::TestMessage)\n    m[\"asdf\"] = proto_module::TestMessage.new\n    assert_raise Google::Protobuf::TypeError do\n      m[\"jkl;\"] = proto_module::TestMessage2.new\n    end\n\n    m = Google::Protobuf::Map.new(\n      :string, :message, proto_module::TestMessage,\n      { \"a\" => proto_module::TestMessage.new(:optional_int32 => 42),\n        \"b\" => proto_module::TestMessage.new(:optional_int32 => 84) })\n    assert m.length == 2\n    assert m.values.map{|msg| msg.optional_int32}.sort == [42, 84]\n\n    m = Google::Protobuf::Map.new(:string, :enum, proto_module::TestEnum,\n                                  { \"x\" => :A, \"y\" => :B, \"z\" => :C })\n    assert m.length == 3\n    assert m[\"z\"] == :C\n    m[\"z\"] = 2\n    assert m[\"z\"] == :B\n    m[\"z\"] = 5\n    assert m[\"z\"] == 5\n    assert_raise RangeError do\n      m[\"z\"] = :Z\n    end\n    assert_raise RangeError do\n      m[\"z\"] = \"z\"\n    end\n  end\n\n  def test_map_dup_deep_copy\n    m = Google::Protobuf::Map.new(\n      :string, :message, proto_module::TestMessage,\n      { \"a\" => proto_module::TestMessage.new(:optional_int32 => 42),\n        \"b\" => proto_module::TestMessage.new(:optional_int32 => 84) })\n\n    m2 = m.dup\n    assert m.to_h == m2.to_h\n    assert m == m2\n    assert m.object_id != m2.object_id\n    assert m[\"a\"].object_id == m2[\"a\"].object_id\n    assert m[\"b\"].object_id == m2[\"b\"].object_id\n\n    m2 = Google::Protobuf.deep_copy(m)\n    assert m == m2\n    assert m.object_id != m2.object_id\n    assert m[\"a\"].object_id != m2[\"a\"].object_id\n    assert m[\"b\"].object_id != m2[\"b\"].object_id\n  end\n\n  def test_oneof_descriptors\n    d = proto_module::OneofMessage.descriptor\n    o = d.lookup_oneof(\"my_oneof\")\n    assert o != nil\n    assert o.class == Google::Protobuf::OneofDescriptor\n    assert o.name == \"my_oneof\"\n    oneof_count = 0\n    d.each_oneof{ |oneof|\n      oneof_count += 1\n      assert oneof == o\n    }\n    assert oneof_count == 1\n    assert o.count == 4\n    field_names = o.map{|f| f.name}.sort\n    assert field_names == [\"a\", \"b\", \"c\", \"d\"]\n  end\n\n  def test_oneof\n    d = proto_module::OneofMessage.new\n    assert d.a == \"\"\n    assert d.b == 0\n    assert d.c == nil\n    assert d.d == :Default\n    assert d.my_oneof == nil\n\n    d.a = \"hi\"\n    assert d.a == \"hi\"\n    assert d.b == 0\n    assert d.c == nil\n    assert d.d == :Default\n    assert d.my_oneof == :a\n\n    d.b = 42\n    assert d.a == \"\"\n    assert d.b == 42\n    assert d.c == nil\n    assert d.d == :Default\n    assert d.my_oneof == :b\n\n    d.c = proto_module::TestMessage2.new(:foo => 100)\n    assert d.a == \"\"\n    assert d.b == 0\n    assert d.c.foo == 100\n    assert d.d == :Default\n    assert d.my_oneof == :c\n\n    d.d = :C\n    assert d.a == \"\"\n    assert d.b == 0\n    assert d.c == nil\n    assert d.d == :C\n    assert d.my_oneof == :d\n\n    d2 = proto_module::OneofMessage.decode(proto_module::OneofMessage.encode(d))\n    assert d2 == d\n\n    encoded_field_a = proto_module::OneofMessage.encode(proto_module::OneofMessage.new(:a => \"string\"))\n    encoded_field_b = proto_module::OneofMessage.encode(proto_module::OneofMessage.new(:b => 1000))\n    encoded_field_c = proto_module::OneofMessage.encode(\n      proto_module::OneofMessage.new(:c => proto_module::TestMessage2.new(:foo => 1)))\n    encoded_field_d = proto_module::OneofMessage.encode(proto_module::OneofMessage.new(:d => :B))\n\n    d3 = proto_module::OneofMessage.decode(\n      encoded_field_c + encoded_field_a + encoded_field_b + encoded_field_d)\n    assert d3.a == \"\"\n    assert d3.b == 0\n    assert d3.c == nil\n    assert d3.d == :B\n\n    d4 = proto_module::OneofMessage.decode(\n      encoded_field_c + encoded_field_a + encoded_field_b + encoded_field_d +\n      encoded_field_c)\n    assert d4.a == \"\"\n    assert d4.b == 0\n    assert d4.c.foo == 1\n    assert d4.d == :Default\n\n    d5 = proto_module::OneofMessage.new(:a => \"hello\")\n    assert d5.a == \"hello\"\n    d5.a = nil\n    assert d5.a == \"\"\n    assert proto_module::OneofMessage.encode(d5) == ''\n    assert d5.my_oneof == nil\n  end\n\n  def test_enum_field\n    m = proto_module::TestMessage.new\n    assert m.optional_enum == :Default\n    m.optional_enum = :A\n    assert m.optional_enum == :A\n    assert_raise RangeError do\n      m.optional_enum = :ASDF\n    end\n    m.optional_enum = 1\n    assert m.optional_enum == :A\n    m.optional_enum = 100\n    assert m.optional_enum == 100\n  end\n\n  def test_dup\n    m = proto_module::TestMessage.new\n    m.optional_string = \"hello\"\n    m.optional_int32 = 42\n    tm1 = proto_module::TestMessage2.new(:foo => 100)\n    tm2 = proto_module::TestMessage2.new(:foo => 200)\n    m.repeated_msg.push tm1\n    assert m.repeated_msg[-1] == tm1\n    m.repeated_msg.push tm2\n    assert m.repeated_msg[-1] == tm2\n    m2 = m.dup\n    assert m == m2\n    m.optional_int32 += 1\n    assert m != m2\n    assert m.repeated_msg[0] == m2.repeated_msg[0]\n    assert m.repeated_msg[0].object_id == m2.repeated_msg[0].object_id\n  end\n\n  def test_deep_copy\n    m = proto_module::TestMessage.new(:optional_int32 => 42,\n                                      :repeated_msg => [proto_module::TestMessage2.new(:foo => 100)])\n    m2 = Google::Protobuf.deep_copy(m)\n    assert m == m2\n    assert m.repeated_msg == m2.repeated_msg\n    assert m.repeated_msg.object_id != m2.repeated_msg.object_id\n    assert m.repeated_msg[0].object_id != m2.repeated_msg[0].object_id\n  end\n\n  def test_message_eq\n    m = proto_module::TestMessage.new(:optional_int32 => 42,\n                                      :repeated_int32 => [1, 2, 3])\n    m2 = proto_module::TestMessage.new(:optional_int32 => 43,\n                                       :repeated_int32 => [1, 2, 3])\n    assert m != m2\n    assert_not_equal proto_module::TestMessage.new, proto_module::TestMessage2.new\n  end\n\n  def test_enum_lookup\n    assert proto_module::TestEnum::A == 1\n    assert proto_module::TestEnum::B == 2\n    assert proto_module::TestEnum::C == 3\n    assert proto_module::TestEnum::V0 == 4\n\n    assert proto_module::TestEnum::lookup(1) == :A\n    assert proto_module::TestEnum::lookup(2) == :B\n    assert proto_module::TestEnum::lookup(3) == :C\n    assert proto_module::TestEnum::lookup(4) == :v0\n\n    assert proto_module::TestEnum::resolve(:A) == 1\n    assert proto_module::TestEnum::resolve(:B) == 2\n    assert proto_module::TestEnum::resolve(:C) == 3\n    assert proto_module::TestEnum::resolve(:v0) == 4\n  end\n\n  def test_enum_const_get_helpers\n    m = proto_module::TestMessage.new\n    assert_equal proto_module::TestEnum::Default, m.optional_enum_const\n    assert_equal proto_module::TestEnum.const_get(:Default), m.optional_enum_const\n\n    m = proto_module::TestMessage.new({optional_enum: proto_module::TestEnum::A})\n    assert_equal proto_module::TestEnum::A, m.optional_enum_const\n    assert_equal proto_module::TestEnum.const_get(:A), m.optional_enum_const\n\n    m = proto_module::TestMessage.new({optional_enum: proto_module::TestEnum::B})\n    assert_equal proto_module::TestEnum::B, m.optional_enum_const\n    assert_equal proto_module::TestEnum.const_get(:B), m.optional_enum_const\n\n    m = proto_module::TestMessage.new({optional_enum: proto_module::TestEnum::C})\n    assert_equal proto_module::TestEnum::C, m.optional_enum_const\n    assert_equal proto_module::TestEnum.const_get(:C), m.optional_enum_const\n\n    m = proto_module::TestMessage2.new({foo: 2})\n    assert_equal 2, m.foo\n    assert_raise(NoMethodError) { m.foo_ }\n    assert_raise(NoMethodError) { m.foo_X }\n    assert_raise(NoMethodError) { m.foo_XX }\n    assert_raise(NoMethodError) { m.foo_XXX }\n    assert_raise(NoMethodError) { m.foo_XXXX }\n    assert_raise(NoMethodError) { m.foo_XXXXX }\n    assert_raise(NoMethodError) { m.foo_XXXXXX }\n\n    m = proto_module::Enumer.new({optional_enum: :B})\n    assert_equal :B, m.optional_enum\n    assert_raise(NoMethodError) { m.optional_enum_ }\n    assert_raise(NoMethodError) { m.optional_enum_X }\n    assert_raise(NoMethodError) { m.optional_enum_XX }\n    assert_raise(NoMethodError) { m.optional_enum_XXX }\n    assert_raise(NoMethodError) { m.optional_enum_XXXX }\n    assert_raise(NoMethodError) { m.optional_enum_XXXXX }\n    assert_raise(NoMethodError) { m.optional_enum_XXXXXX }\n  end\n\n  def test_enum_getter\n    m = proto_module::Enumer.new(:optional_enum => :B, :repeated_enum => [:A, :C])\n\n    assert_equal :B, m.optional_enum\n    assert_equal 2, m.optional_enum_const\n    assert_equal proto_module::TestEnum::B, m.optional_enum_const\n    assert_equal [:A, :C], m.repeated_enum\n    assert_equal [1, 3], m.repeated_enum_const\n    assert_equal [proto_module::TestEnum::A, proto_module::TestEnum::C], m.repeated_enum_const\n  end\n\n  def test_enum_getter_oneof\n    m = proto_module::Enumer.new(:const => :C)\n\n    assert_equal :C, m.const\n    assert_equal 3, m.const_const\n    assert_equal proto_module::TestEnum::C, m.const_const\n  end\n\n  def test_enum_getter_only_enums\n    m = proto_module::Enumer.new(:optional_enum => :B, :a_const => 'thing')\n\n    assert_equal 'thing', m.a_const\n    assert_equal :B, m.optional_enum\n\n    assert_raise(NoMethodError) { m.a }\n    assert_raise(NoMethodError) { m.a_const_const }\n  end\n\n  def test_repeated_push\n    m = proto_module::TestMessage.new\n\n    m.repeated_string += ['one']\n    m.repeated_string += %w[two three]\n    assert_equal %w[one two three], m.repeated_string\n\n    m.repeated_string.push( *['four', 'five'] )\n    assert_equal %w[one two three four five], m.repeated_string\n\n    m.repeated_string.push 'six', 'seven'\n    assert_equal %w[one two three four five six seven], m.repeated_string\n\n    m = proto_module::TestMessage.new\n\n    m.repeated_msg += [proto_module::TestMessage2.new(:foo => 1), proto_module::TestMessage2.new(:foo => 2)]\n    m.repeated_msg += [proto_module::TestMessage2.new(:foo => 3)]\n    m.repeated_msg.push proto_module::TestMessage2.new(:foo => 4), proto_module::TestMessage2.new(:foo => 5)\n    assert_equal [1, 2, 3, 4, 5], m.repeated_msg.map {|x| x.foo}\n  end\n\n  def test_parse_serialize\n    m = proto_module::TestMessage.new(:optional_int32 => 42,\n                                      :optional_string => \"hello world\",\n                                      :optional_enum => :B,\n                                      :repeated_string => [\"a\", \"b\", \"c\"],\n                                      :repeated_int32 => [42, 43, 44],\n                                      :repeated_enum => [:A, :B, :C],\n                                      :repeated_msg => [proto_module::TestMessage2.new(:foo => 1),\n                                                        proto_module::TestMessage2.new(:foo => 2)])\n    if proto_module == ::BasicTest\n      # For proto3 we can add an unknown enum value safely.\n      m.repeated_enum << 100\n    end\n\n    data = proto_module::TestMessage.encode m\n    m2 = proto_module::TestMessage.decode data\n\n    assert_equal m, m2\n\n    data = Google::Protobuf.encode m\n    m2 = Google::Protobuf.decode(proto_module::TestMessage, data)\n    assert m == m2\n  end\n\n  def test_encode_decode_helpers\n    m = proto_module::TestMessage.new(:optional_string => 'foo', :repeated_string => ['bar1', 'bar2'])\n    assert_equal 'foo', m.optional_string\n    assert_equal ['bar1', 'bar2'], m.repeated_string\n\n    json = m.to_json\n    m2 = proto_module::TestMessage.decode_json(json)\n    assert_equal 'foo', m2.optional_string\n    assert_equal ['bar1', 'bar2'], m2.repeated_string\n    if RUBY_PLATFORM != \"java\"\n      assert m2.optional_string.frozen?\n      assert m2.repeated_string[0].frozen?\n    end\n\n    proto = m.to_proto\n    m2 = proto_module::TestMessage.decode(proto)\n    assert_equal 'foo', m2.optional_string\n    assert_equal ['bar1', 'bar2'], m2.repeated_string\n  end\n\n  def test_protobuf_encode_decode_helpers\n    m = proto_module::TestMessage.new(:optional_string => 'foo', :repeated_string => ['bar1', 'bar2'])\n    encoded_msg = Google::Protobuf.encode(m)\n    assert_equal m.to_proto, encoded_msg\n\n    decoded_msg = Google::Protobuf.decode(proto_module::TestMessage, encoded_msg)\n    assert_equal proto_module::TestMessage.decode(m.to_proto), decoded_msg\n  end\n\n  def test_protobuf_encode_decode_json_helpers\n    m = proto_module::TestMessage.new(:optional_string => 'foo', :repeated_string => ['bar1', 'bar2'])\n    encoded_msg = Google::Protobuf.encode_json(m)\n    assert_equal m.to_json, encoded_msg\n\n    decoded_msg = Google::Protobuf.decode_json(proto_module::TestMessage, encoded_msg)\n    assert_equal proto_module::TestMessage.decode_json(m.to_json), decoded_msg\n\n    assert_equal [m].to_json, Google::Protobuf.encode_json([m])\n    assert_equal proto_module::TestMessage.decode_json([m.to_json].first), decoded_msg\n  end\n\n  def test_def_errors\n    s = Google::Protobuf::DescriptorPool.new\n    assert_raise Google::Protobuf::TypeError do\n      s.build do\n        # enum with no default (integer value 0)\n        add_enum \"MyEnum\" do\n          value :A, 1\n        end\n      end\n    end\n    assert_raise Google::Protobuf::TypeError do\n      s.build do\n        # message with required field (unsupported in proto3)\n        add_message \"MyMessage\" do\n          required :foo, :int32, 1\n        end\n      end\n    end\n  end\n\n  def test_corecursive\n    # just be sure that we can instantiate types with corecursive field-type\n    # references.\n    m = proto_module::Recursive1.new(:foo => proto_module::Recursive2.new(:foo => proto_module::Recursive1.new))\n    assert proto_module::Recursive1.descriptor.lookup(\"foo\").subtype ==\n           proto_module::Recursive2.descriptor\n    assert proto_module::Recursive2.descriptor.lookup(\"foo\").subtype ==\n           proto_module::Recursive1.descriptor\n\n    serialized = proto_module::Recursive1.encode(m)\n    m2 = proto_module::Recursive1.decode(serialized)\n    assert m == m2\n  end\n\n  def test_serialize_cycle\n    m = proto_module::Recursive1.new(:foo => proto_module::Recursive2.new)\n    m.foo.foo = m\n    assert_raise RuntimeError do\n      proto_module::Recursive1.encode(m)\n    end\n  end\n\n  def test_bad_field_names\n    m = proto_module::BadFieldNames.new(:dup => 1, :class => 2)\n    m2 = m.dup\n    assert m == m2\n    assert m['dup'] == 1\n    assert m['class'] == 2\n    m['dup'] = 3\n    assert m['dup'] == 3\n  end\n\n  def test_int_ranges\n    m = proto_module::TestMessage.new\n\n    m.optional_int32 = 0\n    m.optional_int32 = -0x8000_0000\n    m.optional_int32 = +0x7fff_ffff\n    m.optional_int32 = 1.0\n    m.optional_int32 = -1.0\n    m.optional_int32 = 2e9\n    assert_raise RangeError do\n      m.optional_int32 = -0x8000_0001\n    end\n    assert_raise RangeError do\n      m.optional_int32 = +0x8000_0000\n    end\n    assert_raise RangeError do\n      m.optional_int32 = +0x1000_0000_0000_0000_0000_0000 # force Bignum\n    end\n    assert_raise RangeError do\n      m.optional_int32 = 1e12\n    end\n    assert_raise RangeError do\n      m.optional_int32 = 1.5\n    end\n\n    m.optional_uint32 = 0\n    m.optional_uint32 = +0xffff_ffff\n    m.optional_uint32 = 1.0\n    m.optional_uint32 = 4e9\n    assert_raise RangeError do\n      m.optional_uint32 = -1\n    end\n    assert_raise RangeError do\n      m.optional_uint32 = -1.5\n    end\n    assert_raise RangeError do\n      m.optional_uint32 = -1.5e12\n    end\n    assert_raise RangeError do\n      m.optional_uint32 = -0x1000_0000_0000_0000\n    end\n    assert_raise RangeError do\n      m.optional_uint32 = +0x1_0000_0000\n    end\n    assert_raise RangeError do\n      m.optional_uint32 = +0x1000_0000_0000_0000_0000_0000 # force Bignum\n    end\n    assert_raise RangeError do\n      m.optional_uint32 = 1e12\n    end\n    assert_raise RangeError do\n      m.optional_uint32 = 1.5\n    end\n\n    m.optional_int64 = 0\n    m.optional_int64 = -0x8000_0000_0000_0000\n    m.optional_int64 = +0x7fff_ffff_ffff_ffff\n    m.optional_int64 = 1.0\n    m.optional_int64 = -1.0\n    m.optional_int64 = 8e18\n    m.optional_int64 = -8e18\n    assert_raise RangeError do\n      m.optional_int64 = -0x8000_0000_0000_0001\n    end\n    assert_raise RangeError do\n      m.optional_int64 = +0x8000_0000_0000_0000\n    end\n    assert_raise RangeError do\n      m.optional_int64 = +0x1000_0000_0000_0000_0000_0000 # force Bignum\n    end\n    assert_raise RangeError do\n      m.optional_int64 = 1e50\n    end\n    assert_raise RangeError do\n      m.optional_int64 = 1.5\n    end\n\n    m.optional_uint64 = 0\n    m.optional_uint64 = +0xffff_ffff_ffff_ffff\n    m.optional_uint64 = 1.0\n    m.optional_uint64 = 16e18\n    assert_raise RangeError do\n      m.optional_uint64 = -1\n    end\n    assert_raise RangeError do\n      m.optional_uint64 = -1.5\n    end\n    assert_raise RangeError do\n      m.optional_uint64 = -1.5e12\n    end\n    assert_raise RangeError do\n      m.optional_uint64 = -0x1_0000_0000_0000_0000\n    end\n    assert_raise RangeError do\n      m.optional_uint64 = +0x1_0000_0000_0000_0000\n    end\n    assert_raise RangeError do\n      m.optional_uint64 = +0x1000_0000_0000_0000_0000_0000 # force Bignum\n    end\n    assert_raise RangeError do\n      m.optional_uint64 = 1e50\n    end\n    assert_raise RangeError do\n      m.optional_uint64 = 1.5\n    end\n  end\n\n  def test_stress_test\n    m = proto_module::TestMessage.new\n    m.optional_int32 = 42\n    m.optional_int64 = 0x100000000\n    m.optional_string = \"hello world\"\n    10.times do m.repeated_msg.push proto_module::TestMessage2.new(:foo => 42) end\n    10.times do m.repeated_string.push \"hello world\" end\n\n    data = proto_module::TestMessage.encode(m)\n\n    10_000.times do\n      m = proto_module::TestMessage.decode(data)\n      data_new = proto_module::TestMessage.encode(m)\n      assert data_new == data\n      data = data_new\n    end\n  end\n\n  def test_reflection\n    m = proto_module::TestMessage.new(:optional_int32 => 1234)\n    msgdef = m.class.descriptor\n    assert msgdef.class == Google::Protobuf::Descriptor\n    assert msgdef.any? {|field| field.name == \"optional_int32\"}\n    optional_int32 = msgdef.lookup \"optional_int32\"\n    assert optional_int32.class == Google::Protobuf::FieldDescriptor\n    assert optional_int32 != nil\n    assert optional_int32.name == \"optional_int32\"\n    assert optional_int32.type == :int32\n    optional_int32.set(m, 5678)\n    assert m.optional_int32 == 5678\n    m.optional_int32 = 1000\n    assert optional_int32.get(m) == 1000\n\n    optional_msg = msgdef.lookup \"optional_msg\"\n    assert optional_msg.subtype == proto_module::TestMessage2.descriptor\n\n    optional_msg.set(m, optional_msg.subtype.msgclass.new)\n\n    assert msgdef.msgclass == proto_module::TestMessage\n\n    optional_enum = msgdef.lookup \"optional_enum\"\n    assert optional_enum.subtype == proto_module::TestEnum.descriptor\n    assert optional_enum.subtype.class == Google::Protobuf::EnumDescriptor\n    optional_enum.subtype.each do |k, v|\n      # set with integer, check resolution to symbolic name\n      optional_enum.set(m, v)\n      assert optional_enum.get(m) == k\n    end\n  end\n\n  def test_json\n    m = proto_module::TestMessage.new(:optional_int32 => 1234,\n                                      :optional_int64 => -0x1_0000_0000,\n                                      :optional_uint32 => 0x8000_0000,\n                                      :optional_uint64 => 0xffff_ffff_ffff_ffff,\n                                      :optional_bool => true,\n                                      :optional_float => 1.0,\n                                      :optional_double => -1e100,\n                                      :optional_string => \"Test string\",\n                                      :optional_bytes => [\"FFFFFFFF\"].pack('H*'),\n                                      :optional_msg => proto_module::TestMessage2.new(:foo => 42),\n                                      :repeated_int32 => [1, 2, 3, 4],\n                                      :repeated_string => [\"a\", \"b\", \"c\"],\n                                      :repeated_bool => [true, false, true, false],\n                                      :repeated_msg => [proto_module::TestMessage2.new(:foo => 1),\n                                                        proto_module::TestMessage2.new(:foo => 2)])\n\n    json_text = proto_module::TestMessage.encode_json(m)\n    m2 = proto_module::TestMessage.decode_json(json_text)\n    assert_equal m, m2\n\n    # Crash case from GitHub issue 283.\n    bar = proto_module::Bar.new(msg: \"bar\")\n    baz1 = proto_module::Baz.new(msg: \"baz\")\n    baz2 = proto_module::Baz.new(msg: \"quux\")\n    proto_module::Foo.encode_json(proto_module::Foo.new)\n    proto_module::Foo.encode_json(proto_module::Foo.new(bar: bar))\n    proto_module::Foo.encode_json(proto_module::Foo.new(bar: bar, baz: [baz1, baz2]))\n  end\n\n  def test_json_empty\n    assert proto_module::TestMessage.encode_json(proto_module::TestMessage.new) == '{}'\n  end\n\n  def test_json_emit_defaults\n    # TODO: Fix JSON in JRuby version.\n    return if RUBY_PLATFORM == \"java\"\n    m = proto_module::TestMessage.new\n\n    expected = {\n      repeatedInt32: [],\n      repeatedInt64: [],\n      repeatedUint32: [],\n      repeatedUint64: [],\n      repeatedBool: [],\n      repeatedFloat: [],\n      repeatedDouble: [],\n      repeatedString: [],\n      repeatedBytes: [],\n      repeatedMsg: [],\n      repeatedEnum: []\n    }\n\n    actual = proto_module::TestMessage.encode_json(m, :emit_defaults => true)\n\n    assert_equal expected, JSON.parse(actual, :symbolize_names => true)\n  end\n\n  def test_json_emit_defaults_submsg\n    # TODO: Fix JSON in JRuby version.\n    return if RUBY_PLATFORM == \"java\"\n    m = proto_module::TestMessage.new(optional_msg: proto_module::TestMessage2.new)\n\n    expected = {\n      optionalMsg: {},\n      repeatedInt32: [],\n      repeatedInt64: [],\n      repeatedUint32: [],\n      repeatedUint64: [],\n      repeatedBool: [],\n      repeatedFloat: [],\n      repeatedDouble: [],\n      repeatedString: [],\n      repeatedBytes: [],\n      repeatedMsg: [],\n      repeatedEnum: []\n    }\n\n    actual = proto_module::TestMessage.encode_json(m, :emit_defaults => true)\n\n    assert_equal expected, JSON.parse(actual, :symbolize_names => true)\n  end\n\n  def test_json_emit_defaults_repeated_submsg\n    # TODO: Fix JSON in JRuby version.\n    return if RUBY_PLATFORM == \"java\"\n    m = proto_module::TestMessage.new(repeated_msg: [proto_module::TestMessage2.new])\n\n    expected = {\n      repeatedInt32: [],\n      repeatedInt64: [],\n      repeatedUint32: [],\n      repeatedUint64: [],\n      repeatedBool: [],\n      repeatedFloat: [],\n      repeatedDouble: [],\n      repeatedString: [],\n      repeatedBytes: [],\n      repeatedMsg: [{}],\n      repeatedEnum: []\n    }\n\n    actual = proto_module::TestMessage.encode_json(m, :emit_defaults => true)\n\n    assert_equal expected, JSON.parse(actual, :symbolize_names => true)\n  end\n\n  def value_from_ruby(value)\n    ret = Google::Protobuf::Value.new\n    case value\n    when String\n      ret.string_value = value\n    when Google::Protobuf::Struct\n      ret.struct_value = value\n    when Hash\n      ret.struct_value = struct_from_ruby(value)\n    when Google::Protobuf::ListValue\n      ret.list_value = value\n    when Array\n      ret.list_value = list_from_ruby(value)\n    else\n      @log.error \"Unknown type: #{value.class}\"\n      raise Google::Protobuf::Error, \"Unknown type: #{value.class}\"\n    end\n    ret\n  end\n\n  def list_from_ruby(arr)\n    ret = Google::Protobuf::ListValue.new\n    arr.each do |v|\n      ret.values << value_from_ruby(v)\n    end\n    ret\n  end\n\n  def struct_from_ruby(hash)\n    ret = Google::Protobuf::Struct.new\n    hash.each do |k, v|\n      ret.fields[k] ||= value_from_ruby(v)\n    end\n    ret\n  end\n\n  def test_deep_json\n    # will not overflow\n    json = '{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":'\\\n           '{\"a\":{\"a\":{\"a\":{\"a\":{}}}}}}}}}}}}}}}}'\n\n    struct = struct_from_ruby(JSON.parse(json))\n    assert_equal json, struct.to_json\n\n    encoded = proto_module::MyRepeatedStruct.encode(\n      proto_module::MyRepeatedStruct.new(structs: [proto_module::MyStruct.new(struct: struct)]))\n    assert_equal json, proto_module::MyRepeatedStruct.decode(encoded).structs[0].struct.to_json\n\n    # will overflow\n    json = '{\"a\":{\"a\":{\"a\":[{\"a\":{\"a\":[{\"a\":[{\"a\":{\"a\":[{\"a\":[{\"a\":'\\\n           '{\"a\":[{\"a\":[{\"a\":{\"a\":{\"a\":[{\"a\":\"a\"}]}}}]}]}}]}]}}]}]}}]}}}'\n\n    struct = struct_from_ruby(JSON.parse(json))\n    assert_equal json, struct.to_json\n\n    assert_raise(RuntimeError, \"Recursion limit exceeded during encoding\") do\n      struct = Google::Protobuf::Struct.new\n      struct.fields[\"foobar\"] = Google::Protobuf::Value.new(struct_value: struct)\n      Google::Protobuf::Struct.encode(struct)\n    end\n  end\n\n  def test_comparison_with_arbitrary_object\n    assert proto_module::TestMessage.new != nil\n  end\n\n  def test_wrappers_set_to_default\n    run_asserts = ->(m) {\n      assert_equal 0.0, m.double.value\n      assert_equal 0.0, m.float.value\n      assert_equal 0, m.int32.value\n      assert_equal 0, m.int64.value\n      assert_equal 0, m.uint32.value\n      assert_equal 0, m.uint64.value\n      assert_equal false, m.bool.value\n      assert_equal '', m.string.value\n      assert_equal '', m.bytes.value\n    }\n\n    m = proto_module::Wrapper.new(\n      double: Google::Protobuf::DoubleValue.new(value: 0.0),\n      float: Google::Protobuf::FloatValue.new(value: 0.0),\n      int32: Google::Protobuf::Int32Value.new(value: 0),\n      int64: Google::Protobuf::Int64Value.new(value: 0),\n      uint32: Google::Protobuf::UInt32Value.new(value: 0),\n      uint64: Google::Protobuf::UInt64Value.new(value: 0),\n      bool: Google::Protobuf::BoolValue.new(value: false),\n      string: Google::Protobuf::StringValue.new(value: \"\"),\n      bytes: Google::Protobuf::BytesValue.new(value: ''),\n    )\n\n    run_asserts.call(m)\n    m2 = proto_module::Wrapper.decode(m.to_proto)\n    run_asserts.call(m2)\n    m3 = proto_module::Wrapper.decode_json(m.to_json)\n    run_asserts.call(m3)\n  end\n\n  def test_wrapper_getters\n    run_asserts = ->(m) {\n      assert_equal 2.0, m.double_as_value\n      assert_equal 2.0, m.double.value\n      assert_equal 2.0, m.double_as_value\n\n      assert_equal 4.0, m.float_as_value\n      assert_equal 4.0, m.float.value\n      assert_equal 4.0, m.float_as_value\n\n      assert_equal 3, m.int32_as_value\n      assert_equal 3, m.int32.value\n      assert_equal 3, m.int32_as_value\n\n      assert_equal 4, m.int64_as_value\n      assert_equal 4, m.int64.value\n      assert_equal 4, m.int64_as_value\n\n      assert_equal 5, m.uint32_as_value\n      assert_equal 5, m.uint32.value\n      assert_equal 5, m.uint32_as_value\n\n      assert_equal 6, m.uint64_as_value\n      assert_equal 6, m.uint64.value\n      assert_equal 6, m.uint64_as_value\n\n      assert_equal true, m.bool_as_value\n      assert_equal true, m.bool.value\n      assert_equal true, m.bool_as_value\n\n      assert_equal \"st\\nr\", m.string_as_value\n      assert_equal \"st\\nr\", m.string.value\n      assert_equal \"st\\nr\", m.string_as_value\n\n      assert_equal 'fun', m.bytes_as_value\n      assert_equal 'fun', m.bytes.value\n      assert_equal 'fun', m.bytes_as_value\n    }\n\n    m = proto_module::Wrapper.new(\n      double: Google::Protobuf::DoubleValue.new(value: 2.0),\n      float: Google::Protobuf::FloatValue.new(value: 4.0),\n      int32: Google::Protobuf::Int32Value.new(value: 3),\n      int64: Google::Protobuf::Int64Value.new(value: 4),\n      uint32: Google::Protobuf::UInt32Value.new(value: 5),\n      uint64: Google::Protobuf::UInt64Value.new(value: 6),\n      bool: Google::Protobuf::BoolValue.new(value: true),\n      string: Google::Protobuf::StringValue.new(value: \"st\\nr\"),\n      bytes: Google::Protobuf::BytesValue.new(value: 'fun'),\n      real_string: '100'\n    )\n\n    run_asserts.call(m)\n    serialized = proto_module::Wrapper::encode(m)\n    m2 = proto_module::Wrapper::decode(serialized)\n    run_asserts.call(m2)\n\n    # Test the case where we are serializing directly from the parsed form\n    # (before anything lazy is materialized).\n    m3 = proto_module::Wrapper::decode(serialized)\n    serialized2 = proto_module::Wrapper::encode(m3)\n    m4 = proto_module::Wrapper::decode(serialized2)\n    run_asserts.call(m4)\n\n    # Test that the lazy form compares equal to the expanded form.\n    m5 = proto_module::Wrapper::decode(serialized2)\n    assert_equal m5, m\n\n    serialized_json = proto_module::Wrapper::encode_json(m)\n    m6 = proto_module::Wrapper::decode_json(serialized_json)\n    assert_equal m6, m\n  end\n\n  def test_repeated_wrappers\n    run_asserts = ->(m) {\n      assert_equal 2.0, m.repeated_double[0].value\n      assert_equal 4.0, m.repeated_float[0].value\n      assert_equal 3, m.repeated_int32[0].value\n      assert_equal 4, m.repeated_int64[0].value\n      assert_equal 5, m.repeated_uint32[0].value\n      assert_equal 6, m.repeated_uint64[0].value\n      assert_equal true, m.repeated_bool[0].value\n      assert_equal 'str', m.repeated_string[0].value\n      assert_equal 'fun', m.repeated_bytes[0].value\n    }\n\n    m = proto_module::Wrapper.new(\n      repeated_double: [Google::Protobuf::DoubleValue.new(value: 2.0)],\n      repeated_float: [Google::Protobuf::FloatValue.new(value: 4.0)],\n      repeated_int32: [Google::Protobuf::Int32Value.new(value: 3)],\n      repeated_int64: [Google::Protobuf::Int64Value.new(value: 4)],\n      repeated_uint32: [Google::Protobuf::UInt32Value.new(value: 5)],\n      repeated_uint64: [Google::Protobuf::UInt64Value.new(value: 6)],\n      repeated_bool: [Google::Protobuf::BoolValue.new(value: true)],\n      repeated_string: [Google::Protobuf::StringValue.new(value: 'str')],\n      repeated_bytes: [Google::Protobuf::BytesValue.new(value: 'fun')],\n    )\n\n    run_asserts.call(m)\n    serialized = proto_module::Wrapper::encode(m)\n    m2 = proto_module::Wrapper::decode(serialized)\n    run_asserts.call(m2)\n\n    # Test the case where we are serializing directly from the parsed form\n    # (before anything lazy is materialized).\n    m3 = proto_module::Wrapper::decode(serialized)\n    serialized2 = proto_module::Wrapper::encode(m3)\n    m4 = proto_module::Wrapper::decode(serialized2)\n    run_asserts.call(m4)\n\n    # Test that the lazy form compares equal to the expanded form.\n    m5 = proto_module::Wrapper::decode(serialized2)\n    assert_equal m5, m\n\n    # Test JSON.\n    serialized_json = proto_module::Wrapper::encode_json(m5)\n    m6 = proto_module::Wrapper::decode_json(serialized_json)\n    run_asserts.call(m6)\n    assert_equal m6, m\n  end\n\n  def test_oneof_wrappers\n    run_test = ->(m) {\n      serialized = proto_module::Wrapper::encode(m)\n      m2 = proto_module::Wrapper::decode(serialized)\n\n      # Encode directly from lazy form.\n      serialized2 = proto_module::Wrapper::encode(m2)\n\n      assert_equal m, m2\n      assert_equal serialized, serialized2\n\n      serialized_json = proto_module::Wrapper::encode_json(m)\n      m3 = proto_module::Wrapper::decode_json(serialized_json)\n      assert_equal m, m3\n    }\n\n    m = proto_module::Wrapper.new()\n\n    run_test.call(m)\n    m.oneof_double_as_value = 2.0\n    run_test.call(m)\n    m.oneof_float_as_value = 4.0\n    run_test.call(m)\n    m.oneof_int32_as_value = 3\n    run_test.call(m)\n    m.oneof_int64_as_value = 5\n    run_test.call(m)\n    m.oneof_uint32_as_value = 6\n    run_test.call(m)\n    m.oneof_uint64_as_value = 7\n    run_test.call(m)\n    m.oneof_string_as_value = 'str'\n    run_test.call(m)\n    m.oneof_bytes_as_value = 'fun'\n    run_test.call(m)\n  end\n\n  def test_top_level_wrappers\n    # We don't expect anyone to do this, but we should also make sure it does\n    # the right thing.\n    run_test = ->(klass, val) {\n      m = klass.new(value: val)\n      serialized = klass::encode(m)\n      m2 = klass::decode(serialized)\n\n      # Encode directly from lazy form.\n      serialized2 = klass::encode(m2)\n\n      assert_equal m, m2\n      assert_equal serialized, serialized2\n\n      serialized_json = klass::encode_json(m)\n\n      # This is nonsensical to do and does not work.  There is no good reason\n      # to parse a wrapper type directly.\n      assert_raise(RuntimeError) { klass::decode_json(serialized_json) }\n    }\n\n    run_test.call(Google::Protobuf::DoubleValue, 2.0)\n    run_test.call(Google::Protobuf::FloatValue, 4.0)\n    run_test.call(Google::Protobuf::Int32Value, 3)\n    run_test.call(Google::Protobuf::Int64Value, 4)\n    run_test.call(Google::Protobuf::UInt32Value, 5)\n    run_test.call(Google::Protobuf::UInt64Value, 6)\n    run_test.call(Google::Protobuf::BoolValue, true)\n    run_test.call(Google::Protobuf::StringValue, 'str')\n    run_test.call(Google::Protobuf::BytesValue, 'fun')\n  end\n\n  def test_wrapper_setters_as_value\n    run_asserts = ->(m) {\n      m.double_as_value = 4.8\n      assert_equal 4.8, m.double_as_value\n      assert_equal Google::Protobuf::DoubleValue.new(value: 4.8), m.double\n      m.float_as_value = 2.4\n      assert_in_delta 2.4, m.float_as_value\n      assert_in_delta Google::Protobuf::FloatValue.new(value: 2.4).value, m.float.value\n      m.int32_as_value = 5\n      assert_equal 5, m.int32_as_value\n      assert_equal Google::Protobuf::Int32Value.new(value: 5), m.int32\n      m.int64_as_value = 15\n      assert_equal 15, m.int64_as_value\n      assert_equal Google::Protobuf::Int64Value.new(value: 15), m.int64\n      m.uint32_as_value = 50\n      assert_equal 50, m.uint32_as_value\n      assert_equal Google::Protobuf::UInt32Value.new(value: 50), m.uint32\n      m.uint64_as_value = 500\n      assert_equal 500, m.uint64_as_value\n      assert_equal Google::Protobuf::UInt64Value.new(value: 500), m.uint64\n      m.bool_as_value = false\n      assert_equal false, m.bool_as_value\n      assert_equal Google::Protobuf::BoolValue.new(value: false), m.bool\n      m.string_as_value = 'xy'\n      assert_equal 'xy', m.string_as_value\n      assert_equal Google::Protobuf::StringValue.new(value: 'xy'), m.string\n      m.bytes_as_value = '123'\n      assert_equal '123', m.bytes_as_value\n      assert_equal Google::Protobuf::BytesValue.new(value: '123'), m.bytes\n\n      m.double_as_value = nil\n      assert_nil m.double\n      assert_nil m.double_as_value\n      m.float_as_value = nil\n      assert_nil m.float\n      assert_nil m.float_as_value\n      m.int32_as_value = nil\n      assert_nil m.int32\n      assert_nil m.int32_as_value\n      m.int64_as_value = nil\n      assert_nil m.int64\n      assert_nil m.int64_as_value\n      m.uint32_as_value = nil\n      assert_nil m.uint32\n      assert_nil m.uint32_as_value\n      m.uint64_as_value = nil\n      assert_nil m.uint64\n      assert_nil m.uint64_as_value\n      m.bool_as_value = nil\n      assert_nil m.bool\n      assert_nil m.bool_as_value\n      m.string_as_value = nil\n      assert_nil m.string\n      assert_nil m.string_as_value\n      m.bytes_as_value = nil\n      assert_nil m.bytes\n      assert_nil m.bytes_as_value\n    }\n\n    m2 = proto_module::Wrapper.new(\n      double: Google::Protobuf::DoubleValue.new(value: 2.0),\n      float: Google::Protobuf::FloatValue.new(value: 4.0),\n      int32: Google::Protobuf::Int32Value.new(value: 3),\n      int64: Google::Protobuf::Int64Value.new(value: 4),\n      uint32: Google::Protobuf::UInt32Value.new(value: 5),\n      uint64: Google::Protobuf::UInt64Value.new(value: 6),\n      bool: Google::Protobuf::BoolValue.new(value: true),\n      string: Google::Protobuf::StringValue.new(value: 'str'),\n      bytes: Google::Protobuf::BytesValue.new(value: 'fun'),\n      real_string: '100'\n    )\n\n    run_asserts.call(m2)\n\n    serialized = proto_module::Wrapper::encode(m2)\n    m3 = proto_module::Wrapper::decode(serialized)\n    run_asserts.call(m3)\n  end\n\n  def test_wrapper_setters\n    run_asserts = ->(m) {\n      m.double = Google::Protobuf::DoubleValue.new(value: 4.8)\n      assert_equal 4.8, m.double_as_value\n      assert_equal Google::Protobuf::DoubleValue.new(value: 4.8), m.double\n      m.float = Google::Protobuf::FloatValue.new(value: 2.4)\n      assert_in_delta 2.4, m.float_as_value\n      assert_in_delta Google::Protobuf::FloatValue.new(value: 2.4).value, m.float.value\n      m.int32 = Google::Protobuf::Int32Value.new(value: 5)\n      assert_equal 5, m.int32_as_value\n      assert_equal Google::Protobuf::Int32Value.new(value: 5), m.int32\n      m.int64 = Google::Protobuf::Int64Value.new(value: 15)\n      assert_equal 15, m.int64_as_value\n      assert_equal Google::Protobuf::Int64Value.new(value: 15), m.int64\n      m.uint32 = Google::Protobuf::UInt32Value.new(value: 50)\n      assert_equal 50, m.uint32_as_value\n      assert_equal Google::Protobuf::UInt32Value.new(value: 50), m.uint32\n      m.uint64 = Google::Protobuf::UInt64Value.new(value: 500)\n      assert_equal 500, m.uint64_as_value\n      assert_equal Google::Protobuf::UInt64Value.new(value: 500), m.uint64\n      m.bool = Google::Protobuf::BoolValue.new(value: false)\n      assert_equal false, m.bool_as_value\n      assert_equal Google::Protobuf::BoolValue.new(value: false), m.bool\n      m.string = Google::Protobuf::StringValue.new(value: 'xy')\n      assert_equal 'xy', m.string_as_value\n      assert_equal Google::Protobuf::StringValue.new(value: 'xy'), m.string\n      m.bytes = Google::Protobuf::BytesValue.new(value: '123')\n      assert_equal '123', m.bytes_as_value\n      assert_equal Google::Protobuf::BytesValue.new(value: '123'), m.bytes\n\n      m.double = nil\n      assert_nil m.double\n      assert_nil m.double_as_value\n      m.float = nil\n      assert_nil m.float\n      assert_nil m.float_as_value\n      m.int32 = nil\n      assert_nil m.int32\n      assert_nil m.int32_as_value\n      m.int64 = nil\n      assert_nil m.int64\n      assert_nil m.int64_as_value\n      m.uint32 = nil\n      assert_nil m.uint32\n      assert_nil m.uint32_as_value\n      m.uint64 = nil\n      assert_nil m.uint64\n      assert_nil m.uint64_as_value\n      m.bool = nil\n      assert_nil m.bool\n      assert_nil m.bool_as_value\n      m.string = nil\n      assert_nil m.string\n      assert_nil m.string_as_value\n      m.bytes = nil\n      assert_nil m.bytes\n      assert_nil m.bytes_as_value\n    }\n\n    m = proto_module::Wrapper.new\n    run_asserts.call(m)\n\n    m2 = proto_module::Wrapper.new(\n      double: Google::Protobuf::DoubleValue.new(value: 2.0),\n      float: Google::Protobuf::FloatValue.new(value: 4.0),\n      int32: Google::Protobuf::Int32Value.new(value: 3),\n      int64: Google::Protobuf::Int64Value.new(value: 4),\n      uint32: Google::Protobuf::UInt32Value.new(value: 5),\n      uint64: Google::Protobuf::UInt64Value.new(value: 6),\n      bool: Google::Protobuf::BoolValue.new(value: true),\n      string: Google::Protobuf::StringValue.new(value: 'str'),\n      bytes: Google::Protobuf::BytesValue.new(value: 'fun'),\n      real_string: '100'\n    )\n\n    run_asserts.call(m2)\n\n    serialized = proto_module::Wrapper::encode(m2)\n    m3 = proto_module::Wrapper::decode(serialized)\n    run_asserts.call(m3)\n  end\n\n  def test_wrappers_only\n    m = proto_module::Wrapper.new(real_string: 'hi', string_in_oneof: 'there')\n\n    assert_raise(NoMethodError) { m.real_string_as_value }\n    assert_raise(NoMethodError) { m.as_value }\n    assert_raise(NoMethodError) { m._as_value }\n    assert_raise(NoMethodError) { m.string_in_oneof_as_value }\n\n    m = proto_module::Wrapper.new\n    m.string_as_value = 'you'\n    assert_equal 'you', m.string.value\n    assert_equal 'you', m.string_as_value\n    assert_raise(NoMethodError) { m.string_ }\n    assert_raise(NoMethodError) { m.string_X }\n    assert_raise(NoMethodError) { m.string_XX }\n    assert_raise(NoMethodError) { m.string_XXX }\n    assert_raise(NoMethodError) { m.string_XXXX }\n    assert_raise(NoMethodError) { m.string_XXXXX }\n    assert_raise(NoMethodError) { m.string_XXXXXX }\n    assert_raise(NoMethodError) { m.string_XXXXXXX }\n    assert_raise(NoMethodError) { m.string_XXXXXXXX }\n    assert_raise(NoMethodError) { m.string_XXXXXXXXX }\n    assert_raise(NoMethodError) { m.string_XXXXXXXXXX }\n  end\n\n  def test_converts_time\n    m = proto_module::TimeMessage.new\n\n    m.timestamp = Google::Protobuf::Timestamp.new(seconds: 5, nanos: 6)\n    assert_kind_of Google::Protobuf::Timestamp, m.timestamp\n    assert_equal 5, m.timestamp.seconds\n    assert_equal 6, m.timestamp.nanos\n\n    m.timestamp = Time.at(9466, 123456.789)\n    assert_equal Google::Protobuf::Timestamp.new(seconds: 9466, nanos: 123456789), m.timestamp\n\n    m = proto_module::TimeMessage.new(timestamp: Time.at(1))\n    assert_equal Google::Protobuf::Timestamp.new(seconds: 1, nanos: 0), m.timestamp\n\n    assert_raise(Google::Protobuf::TypeError) { m.timestamp = 2 }\n    assert_raise(Google::Protobuf::TypeError) { m.timestamp = 2.4 }\n    assert_raise(Google::Protobuf::TypeError) { m.timestamp = '4' }\n    assert_raise(Google::Protobuf::TypeError) { m.timestamp = proto_module::TimeMessage.new }\n\n    def test_time(year, month, day)\n      str = (\"\\\"%04d-%02d-%02dT00:00:00.000+00:00\\\"\" % [year, month, day])\n      t = Google::Protobuf::Timestamp.decode_json(str)\n      time = Time.new(year, month, day, 0, 0, 0, \"+00:00\")\n      assert_equal t.seconds, time.to_i\n    end\n\n    (1970..2010).each do |year|\n      test_time(year, 2, 28)\n      test_time(year, 3, 01)\n    end\n  end\n\n  def test_converts_duration\n    m = proto_module::TimeMessage.new\n\n    m.duration = Google::Protobuf::Duration.new(seconds: 2, nanos: 22)\n    assert_kind_of Google::Protobuf::Duration, m.duration\n    assert_equal 2, m.duration.seconds\n    assert_equal 22, m.duration.nanos\n\n    m.duration = 10.5\n    assert_equal Google::Protobuf::Duration.new(seconds: 10, nanos: 500_000_000), m.duration\n\n    m.duration = 200\n    assert_equal Google::Protobuf::Duration.new(seconds: 200, nanos: 0), m.duration\n\n    m.duration = Rational(3, 2)\n    assert_equal Google::Protobuf::Duration.new(seconds: 1, nanos: 500_000_000), m.duration\n\n    m.duration = BigDecimal(\"5\")\n    assert_equal Google::Protobuf::Duration.new(seconds: 5, nanos: 0), m.duration\n\n    m = proto_module::TimeMessage.new(duration: 1.1)\n    assert_equal Google::Protobuf::Duration.new(seconds: 1, nanos: 100_000_000), m.duration\n\n    m = proto_module::TimeMessage.new(duration: 123.321)\n    assert_equal Google::Protobuf::Duration.new(seconds: 123, nanos: 321_000_000), m.duration\n\n    m = proto_module::TimeMessage.new(duration: -123.321)\n    assert_equal Google::Protobuf::Duration.new(seconds: -123, nanos: -321_000_000), m.duration\n\n    assert_raise(Google::Protobuf::TypeError) { m.duration = '2' }\n    assert_raise(Google::Protobuf::TypeError) { m.duration = proto_module::TimeMessage.new }\n  end\n\n  def test_freeze\n    m = proto_module::TestMessage.new\n    m.optional_int32 = 10\n    m.freeze\n\n    frozen_error = assert_raise(FrozenErrorType) { m.optional_int32 = 20 }\n    assert_match \"can't modify frozen #{proto_module}::TestMessage\", frozen_error.message\n    assert_equal 10, m.optional_int32\n    assert_equal true, m.frozen?\n\n    assert_raise(FrozenErrorType) { m.optional_int64 = 2 }\n    assert_raise(FrozenErrorType) { m.optional_uint32 = 3 }\n    assert_raise(FrozenErrorType) { m.optional_uint64 = 4 }\n    assert_raise(FrozenErrorType) { m.optional_bool = true }\n    assert_raise(FrozenErrorType) { m.optional_float = 6.0 }\n    assert_raise(FrozenErrorType) { m.optional_double = 7.0 }\n    assert_raise(FrozenErrorType) { m.optional_string = '8' }\n    assert_raise(FrozenErrorType) { m.optional_bytes = nil }\n    assert_raise(FrozenErrorType) { m.optional_msg = proto_module::TestMessage2.new }\n    assert_raise(FrozenErrorType) { m.optional_enum = :A }\n    assert_raise(FrozenErrorType) { m.repeated_int32 = 1 }\n    assert_raise(FrozenErrorType) { m.repeated_int64 = 2 }\n    assert_raise(FrozenErrorType) { m.repeated_uint32 = 3 }\n    assert_raise(FrozenErrorType) { m.repeated_uint64 = 4 }\n    assert_raise(FrozenErrorType) { m.repeated_bool = true }\n    assert_raise(FrozenErrorType) { m.repeated_float = 6.0 }\n    assert_raise(FrozenErrorType) { m.repeated_double = 7.0 }\n    assert_raise(FrozenErrorType) { m.repeated_string = '8' }\n    assert_raise(FrozenErrorType) { m.repeated_bytes = nil }\n    assert_raise(FrozenErrorType) { m.repeated_msg = proto_module::TestMessage2.new }\n    assert_raise(FrozenErrorType) { m.repeated_enum = :A }\n  end\n\n  def test_eq\n    m1 = proto_module::TestMessage.new(:optional_string => 'foo', :repeated_string => ['bar1', 'bar2'])\n    m2 = proto_module::TestMessage.new(:optional_string => 'foo', :repeated_string => ['bar1', 'bar2'])\n\n    h = {}\n    h[m1] = :yes\n\n    assert m1 == m2\n    assert m1.eql?(m2)\n    assert m1.hash == m2.hash\n    assert h[m1] == :yes\n    assert h[m2] == :yes\n\n    m1.optional_int32 = 2\n\n    assert m1 != m2\n    assert !m1.eql?(m2)\n    assert m1.hash != m2.hash\n    assert_nil h[m2]\n  end\n\n  def cruby_or_jruby_9_3_or_higher?\n    # https://github.com/jruby/jruby/issues/6818 was fixed in JRuby 9.3.0.0\n    match = RUBY_PLATFORM == \"java\" &&\n      JRUBY_VERSION.match(/^(\\d+)\\.(\\d+)\\.\\d+\\.\\d+$/)\n    match && (match[1].to_i > 9 || (match[1].to_i == 9 && match[2].to_i >= 3))\n  end\n\n  def test_object_gc\n    m = proto_module::TestMessage.new(optional_msg: proto_module::TestMessage2.new)\n    m.optional_msg\n    # https://github.com/jruby/jruby/issues/6818 was fixed in JRuby 9.3.0.0\n    GC.start(full_mark: true, immediate_sweep: true) if cruby_or_jruby_9_3_or_higher?\n    m.optional_msg.inspect\n  end\n\n  def test_object_gc_freeze\n    m = proto_module::TestMessage.new\n    m.repeated_float.freeze\n    # https://github.com/jruby/jruby/issues/6818 was fixed in JRuby 9.3.0.0\n    GC.start(full_mark: true) if cruby_or_jruby_9_3_or_higher?\n\n    # Make sure we remember that the object is frozen.\n    # The wrapper object contains this information, so we need to ensure that\n    # the previous GC did not collect it.\n    assert m.repeated_float.frozen?\n\n    # https://github.com/jruby/jruby/issues/6818 was fixed in JRuby 9.3.0.0\n    GC.start(full_mark: true, immediate_sweep: true) if cruby_or_jruby_9_3_or_higher?\n    assert m.repeated_float.frozen?\n  end\n\n  def test_optional_fields_respond_to? # regression test for issue 9202\n    msg = proto_module::TestMessage.new\n    assert msg.respond_to? :optional_int32=\n    msg.optional_int32 = 42\n\n    assert msg.respond_to? :optional_int32\n    assert_equal 42, msg.optional_int32\n\n    assert msg.respond_to? :clear_optional_int32\n    msg.clear_optional_int32\n    assert_equal 0, msg.optional_int32\n\n    assert msg.respond_to? :has_optional_int32?\n    assert !msg.has_optional_int32?\n\n    assert !msg.respond_to?( :optional_int32_as_value= )\n    assert_raise NoMethodError do\n      msg.optional_int32_as_value = 42\n    end\n\n    assert !msg.respond_to?( :optional_int32_as_value )\n    assert_raise NoMethodError do\n      msg.optional_int32_as_value\n    end\n\n    assert msg.respond_to? :optional_enum_const\n    assert_equal 0, msg.optional_enum_const\n\n    assert !msg.respond_to?( :foo )\n    assert_raise NoMethodError do\n      msg.foo\n    end\n\n    assert !msg.respond_to?( :foo_const )\n    assert_raise NoMethodError do\n      msg.foo_const\n    end\n\n    assert !msg.respond_to?( :optional_int32_const )\n    assert_raise NoMethodError do\n      msg.optional_int32_const\n    end\n  end\n\n  def test_oneof_fields_respond_to? # regression test for issue 9202\n    msg = proto_module::OneofMessage.new\n\n    # names of the elements of a oneof and the oneof itself are valid actions.\n    assert msg.respond_to? :my_oneof\n    assert_nil msg.my_oneof\n    assert msg.respond_to? :a\n    assert_equal \"\", msg.a\n    assert msg.respond_to? :b\n    assert_equal 0, msg.b\n    assert msg.respond_to? :c\n    assert_nil msg.c\n    assert msg.respond_to? :d\n    assert_equal :Default, msg.d\n\n    # `clear` prefix actions work on elements of a oneof and the oneof itself.\n    assert msg.respond_to? :clear_my_oneof\n    msg.clear_my_oneof\n    # Repeatedly clearing a oneof used to cause a NoMethodError under JRuby\n    msg.clear_my_oneof\n    assert msg.respond_to? :clear_a\n    msg.clear_a\n    assert msg.respond_to? :clear_b\n    msg.clear_b\n    assert msg.respond_to? :clear_c\n    msg.clear_c\n    assert msg.respond_to? :clear_d\n    msg.clear_d\n\n    # `=` suffix actions should work on elements of a oneof but not the oneof itself.\n    assert !msg.respond_to?( :my_oneof= )\n    error = assert_raise RuntimeError do\n      msg.my_oneof = nil\n    end\n    assert_equal \"Oneof accessors are read-only.\", error.message\n    assert msg.respond_to? :a=\n    msg.a = \"foo\"\n    assert msg.respond_to? :b=\n    msg.b = 42\n    assert msg.respond_to? :c=\n    msg.c = proto_module::TestMessage2.new\n    assert msg.respond_to? :d=\n    msg.d = :Default\n\n    # `has_` prefix + \"?\" suffix actions work for oneofs fields.\n    assert msg.respond_to? :has_my_oneof?\n    assert msg.has_my_oneof?\n\n    # `_as_value` suffix actions should only work for wrapped fields.\n    assert !msg.respond_to?( :my_oneof_as_value )\n    assert_raise NoMethodError do\n      msg.my_oneof_as_value\n    end\n    assert !msg.respond_to?( :a_as_value )\n    assert_raise NoMethodError do\n      msg.a_as_value\n    end\n    assert !msg.respond_to?( :b_as_value )\n    assert_raise NoMethodError do\n      msg.b_as_value\n    end\n    assert !msg.respond_to?( :c_as_value )\n    assert_raise NoMethodError do\n      msg.c_as_value\n    end\n    assert !msg.respond_to?( :d_as_value )\n    assert_raise NoMethodError do\n      msg.d_as_value\n    end\n\n    # `_as_value=` suffix actions should only work for wrapped fields.\n    assert !msg.respond_to?( :my_oneof_as_value= )\n    assert_raise NoMethodError do\n      msg.my_oneof_as_value = :boom\n    end\n    assert !msg.respond_to?( :a_as_value= )\n    assert_raise NoMethodError do\n      msg.a_as_value = \"\"\n    end\n    assert !msg.respond_to?( :b_as_value= )\n    assert_raise NoMethodError do\n      msg.b_as_value = 42\n    end\n    assert !msg.respond_to?( :c_as_value= )\n    assert_raise NoMethodError do\n      msg.c_as_value = proto_module::TestMessage2.new\n    end\n    assert !msg.respond_to?( :d_as_value= )\n    assert_raise NoMethodError do\n      msg.d_as_value = :Default\n    end\n\n    # `_const` suffix actions should only work for enum fields.\n    assert !msg.respond_to?( :my_oneof_const )\n    assert_raise NoMethodError do\n      msg.my_oneof_const\n    end\n    assert !msg.respond_to?( :a_const )\n    assert_raise NoMethodError do\n      msg.a_const\n    end\n    assert !msg.respond_to?( :b_const )\n    assert_raise NoMethodError do\n      msg.b_const\n    end\n    assert !msg.respond_to?( :c_const )\n    assert_raise NoMethodError do\n      msg.c_const\n    end\n    assert msg.respond_to? :d_const\n    assert_equal 0, msg.d_const\n  end\n\n  def test_wrapped_fields_respond_to? # regression test for issue 9202\n    msg = proto_module::Wrapper.new\n    assert msg.respond_to?( :double_as_value= )\n    msg.double_as_value = 42\n    assert msg.respond_to?( :double_as_value )\n    assert_equal 42, msg.double_as_value\n    assert_equal Google::Protobuf::DoubleValue.new(value: 42), msg.double\n  end\nend\n", "syntax = \"proto3\";\n\npackage a.b.c;\n\nmessage TestMessage {\n  int32 optional_int32 = 1;\n  int64 optional_int64 = 2;\n  uint32 optional_uint32 = 3;\n  uint64 optional_uint64 = 4;\n  bool optional_bool = 5;\n  double optional_double = 6;\n  float optional_float = 7;\n  string optional_string = 8;\n  bytes optional_bytes = 9;\n  TestEnum optional_enum = 10;\n  TestMessage optional_msg = 11;\n\n  repeated int32 repeated_int32 = 21;\n  repeated int64 repeated_int64 = 22;\n  repeated uint32 repeated_uint32 = 23;\n  repeated uint64 repeated_uint64 = 24;\n  repeated bool repeated_bool = 25;\n  repeated double repeated_double = 26;\n  repeated float repeated_float = 27;\n  repeated string repeated_string = 28;\n  repeated bytes repeated_bytes = 29;\n  repeated TestEnum repeated_enum = 30;\n  repeated TestMessage repeated_msg = 31;\n\n  oneof my_oneof {\n    int32 oneof_int32 = 41;\n    int64 oneof_int64 = 42;\n    uint32 oneof_uint32 = 43;\n    uint64 oneof_uint64 = 44;\n    bool oneof_bool = 45;\n    double oneof_double = 46;\n    float oneof_float = 47;\n    string oneof_string = 48;\n    bytes oneof_bytes = 49;\n    TestEnum oneof_enum = 50;\n    TestMessage oneof_msg = 51;\n  }\n\n  map<int32, string> map_int32_string = 61;\n  map<int64, string> map_int64_string = 62;\n  map<uint32, string> map_uint32_string = 63;\n  map<uint64, string> map_uint64_string = 64;\n  map<bool, string> map_bool_string = 65;\n  map<string, string> map_string_string = 66;\n  map<string, TestMessage> map_string_msg = 67;\n  map<string, TestEnum> map_string_enum = 68;\n  map<string, int32> map_string_int32 = 69;\n  map<string, bool> map_string_bool = 70;\n\n  message NestedMessage {\n    int32 foo = 1;\n  }\n\n  NestedMessage nested_message = 80;\n\n  // Reserved for non-existing field test.\n  // int32 non_exist = 89;\n}\n\nenum TestEnum {\n  Default = 0;\n  A = 1;\n  B = 2;\n  C = 3;\n\n  v0 = 4;\n}\n\nmessage testLowercaseNested {\n  message lowercase{}\n}\n\n\nmessage TestUnknown {\n  TestUnknown optional_unknown = 11;\n  repeated TestUnknown repeated_unknown = 31;\n  oneof my_oneof {\n    TestUnknown oneof_unknown = 51;\n  }\n  map<string, TestUnknown> map_unknown = 67;\n  int32 unknown_field = 89;\n}\n\nmessage TestJsonName {\n  int32 value = 1 [json_name = \"CustomJsonName\"];\n}\n", "syntax = \"proto2\";\n\npackage a.b.proto2;\n\nmessage TestMessage {\n  optional int32 optional_int32 = 1;\n  optional int64 optional_int64 = 2;\n  optional uint32 optional_uint32 = 3;\n  optional uint64 optional_uint64 = 4;\n  optional bool optional_bool = 5;\n  optional double optional_double = 6;\n  optional float optional_float = 7;\n  optional string optional_string = 8;\n  optional bytes optional_bytes = 9;\n  optional TestEnum optional_enum = 10;\n  optional TestMessage optional_msg = 11;\n\n  repeated int32 repeated_int32 = 21;\n  repeated int64 repeated_int64 = 22;\n  repeated uint32 repeated_uint32 = 23;\n  repeated uint64 repeated_uint64 = 24;\n  repeated bool repeated_bool = 25;\n  repeated double repeated_double = 26;\n  repeated float repeated_float = 27;\n  repeated string repeated_string = 28;\n  repeated bytes repeated_bytes = 29;\n  repeated TestEnum repeated_enum = 30;\n  repeated TestMessage repeated_msg = 31;\n\n  required int32 required_int32 = 41;\n  required int64 required_int64 = 42;\n  required uint32 required_uint32 = 43;\n  required uint64 required_uint64 = 44;\n  required bool required_bool = 45;\n  required double required_double = 46;\n  required float required_float = 47;\n  required string required_string = 48;\n  required bytes required_bytes = 49;\n  required TestEnum required_enum = 50;\n  required TestMessage required_msg = 51;\n\n  oneof my_oneof {\n    int32 oneof_int32 = 61;\n    int64 oneof_int64 = 62;\n    uint32 oneof_uint32 = 63;\n    uint64 oneof_uint64 = 64;\n    bool oneof_bool = 65;\n    double oneof_double = 66;\n    float oneof_float = 67;\n    string oneof_string = 68;\n    bytes oneof_bytes = 69;\n    TestEnum oneof_enum = 70;\n    TestMessage oneof_msg = 71;\n  }\n\n  message NestedMessage {\n    optional int32 foo = 1;\n  }\n\n  optional NestedMessage nested_message = 80;\n\n  // Reserved for non-existing field test.\n  // int32 non_exist = 89;\n}\n\nenum TestEnum {\n  Default = 0;\n  A = 1;\n  B = 2;\n  C = 3;\n\n  v0 = 4;\n}\n\nmessage TestUnknown {\n  optional TestUnknown optional_unknown = 11;\n  repeated TestUnknown repeated_unknown = 31;\n  oneof my_oneof {\n    TestUnknown oneof_unknown = 51;\n  }\n  optional int32 unknown_field = 89;\n}\n", "#!/usr/bin/ruby\n\nrequire 'google/protobuf'\nrequire 'test/unit'\n\nclass RepeatedFieldTest < Test::Unit::TestCase\n\n  def test_acts_like_enumerator\n    m = TestMessage.new\n    (Enumerable.instance_methods - TestMessage.new.repeated_string.methods).each do |method_name|\n      assert m.repeated_string.respond_to?(method_name) == true, \"does not respond to #{method_name}\"\n    end\n  end\n\n  def test_acts_like_an_array\n    m = TestMessage.new\n    arr_methods = ([].methods - TestMessage.new.repeated_string.methods)\n    # jRuby additions to the Array class that we can ignore\n    arr_methods -= [ :indices, :iter_for_each, :iter_for_each_index,\n      :iter_for_each_with_index, :dimensions, :copy_data, :copy_data_simple,\n      :nitems, :iter_for_reverse_each, :indexes, :append, :prepend]\n    arr_methods -= [:union, :difference, :filter!]\n    arr_methods -= [:intersection, :deconstruct] # ruby 2.7 methods we can ignore\n    arr_methods -= [:intersect?] # ruby 3.1 methods we can ignore\n    arr_methods.each do |method_name|\n      assert m.repeated_string.respond_to?(method_name) == true, \"does not respond to #{method_name}\"\n    end\n  end\n\n  def test_first\n    m = TestMessage.new\n    repeated_field_names(TestMessage).each do |field_name|\n      assert_nil m.send(field_name).first\n      assert_equal [], m.send(field_name).first(0)\n      assert_equal [], m.send(field_name).first(1)\n    end\n\n    fill_test_msg(m)\n    assert_equal( -10, m.repeated_int32.first )\n    assert_equal( -1_000_000, m.repeated_int64.first )\n    assert_equal 10, m.repeated_uint32.first\n    assert_equal 1_000_000, m.repeated_uint64.first\n    assert_equal true, m.repeated_bool.first\n    assert_equal( -1.01,  m.repeated_float.first.round(2) )\n    assert_equal( -1.0000000000001, m.repeated_double.first )\n    assert_equal 'foo', m.repeated_string.first\n    assert_equal \"bar\".encode!('ASCII-8BIT'), m.repeated_bytes.first\n    assert_equal TestMessage2.new(:foo => 1), m.repeated_msg.first\n    assert_equal :A, m.repeated_enum.first\n\n    err = assert_raises(ArgumentError) do\n      m.repeated_int32.first(-1)\n    end\n    assert_equal \"negative array size\", err.message\n    assert_equal [], m.repeated_int32.first(0)\n    assert_equal [-10], m.repeated_int32.first(1)\n    assert_equal [-10, -11], m.repeated_int32.first(2)\n    assert_equal [-10, -11], m.repeated_int32.first(3)\n  end\n\n\n  def test_last\n    m = TestMessage.new\n    repeated_field_names(TestMessage).each do |field_name|\n      assert_nil m.send(field_name).first\n    end\n    fill_test_msg(m)\n    assert_equal( -11, m.repeated_int32.last )\n    assert_equal( -1_000_001, m.repeated_int64.last )\n    assert_equal 11, m.repeated_uint32.last\n    assert_equal 1_000_001, m.repeated_uint64.last\n    assert_equal false, m.repeated_bool.last\n    assert_equal( -1.02, m.repeated_float.last.round(2) )\n    assert_equal( -1.0000000000002, m.repeated_double.last )\n    assert_equal 'bar', m.repeated_string.last\n    assert_equal \"foo\".encode!('ASCII-8BIT'), m.repeated_bytes.last\n    assert_equal TestMessage2.new(:foo => 2), m.repeated_msg.last\n    assert_equal :B, m.repeated_enum.last\n\n    err = assert_raises(ArgumentError) do\n      m.repeated_int32.last(-1)\n    end\n    assert_equal \"negative array size\", err.message\n    assert_equal [], m.repeated_int32.last(0)\n    assert_equal [-11], m.repeated_int32.last(1)\n    assert_equal [-10, -11], m.repeated_int32.last(2)\n    assert_equal [-10, -11], m.repeated_int32.last(3)\n  end\n\n\n  def test_pop\n    m = TestMessage.new\n    repeated_field_names(TestMessage).each do |field_name|\n      assert_nil m.send(field_name).pop\n    end\n    fill_test_msg(m)\n\n    assert_equal( -11, m.repeated_int32.pop )\n    assert_equal( -10, m.repeated_int32.pop )\n    assert_equal( -1_000_001, m.repeated_int64.pop )\n    assert_equal( -1_000_000, m.repeated_int64.pop )\n    assert_equal 11, m.repeated_uint32.pop\n    assert_equal 10, m.repeated_uint32.pop\n    assert_equal 1_000_001, m.repeated_uint64.pop\n    assert_equal 1_000_000, m.repeated_uint64.pop\n    assert_equal false, m.repeated_bool.pop\n    assert_equal true, m.repeated_bool.pop\n    assert_equal( -1.02,  m.repeated_float.pop.round(2) )\n    assert_equal( -1.01,  m.repeated_float.pop.round(2) )\n    assert_equal( -1.0000000000002, m.repeated_double.pop )\n    assert_equal( -1.0000000000001, m.repeated_double.pop )\n    assert_equal 'bar', m.repeated_string.pop\n    assert_equal 'foo', m.repeated_string.pop\n    assert_equal \"foo\".encode!('ASCII-8BIT'), m.repeated_bytes.pop\n    assert_equal \"bar\".encode!('ASCII-8BIT'), m.repeated_bytes.pop\n    assert_equal TestMessage2.new(:foo => 2), m.repeated_msg.pop\n    assert_equal TestMessage2.new(:foo => 1), m.repeated_msg.pop\n    assert_equal :B, m.repeated_enum.pop\n    assert_equal :A, m.repeated_enum.pop\n    repeated_field_names(TestMessage).each do |field_name|\n      assert_nil m.send(field_name).pop\n    end\n\n    fill_test_msg(m)\n    assert_equal ['bar', 'foo'], m.repeated_string.pop(2)\n    assert_nil m.repeated_string.pop\n  end\n\n\n  def test_each\n    m = TestMessage.new\n    5.times{|i| m.repeated_string << 'string' }\n    count = 0\n    m.repeated_string.each do |val|\n      assert_equal 'string', val\n      count += 1\n    end\n    assert_equal 5, count\n    result = m.repeated_string.each{|val| val + '_junk'}\n    assert_equal ['string'] * 5, result\n  end\n\n\n  def test_empty?\n    m = TestMessage.new\n    assert_equal true, m.repeated_string.empty?\n    m.repeated_string << 'foo'\n    assert_equal false, m.repeated_string.empty?\n    m.repeated_string << 'bar'\n    assert_equal false, m.repeated_string.empty?\n  end\n\n  def test_reassign\n    m = TestMessage.new\n    m.repeated_msg = Google::Protobuf::RepeatedField.new(:message, TestMessage2, [TestMessage2.new(:foo => 1)])\n    assert_equal m.repeated_msg.first, TestMessage2.new(:foo => 1)\n  end\n\n  def test_array_accessor\n    m = TestMessage.new\n    reference_arr = %w(foo bar baz)\n    m.repeated_string += reference_arr.clone\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n      arr[1]\n    end\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n      arr[-2]\n    end\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n      arr[20]\n    end\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n      arr[1, 2]\n    end\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n      arr[0..2]\n    end\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n      arr[0..5]\n    end\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n      arr[0..-1]\n    end\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n      arr[0..-3]\n    end\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n      arr[0...-1] # Exclusive range\n    end\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n      arr[0...-3] # Exclusive range\n    end\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n      arr[-2..-1]\n    end\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n      arr[-5..-1]\n    end\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n      # Infinite range; introduce in Ruby 2.7.\n      if Gem::Version.new(RUBY_VERSION) >= Gem::Version.new('2.7')\n        eval \"arr[0..]\"\n      end\n    end\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n      # Beginless range; introduced in Ruby 2.7.\n      if Gem::Version.new(RUBY_VERSION) >= Gem::Version.new('2.7')\n        eval \"arr[..-1]\"\n      end\n    end\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n      # Infinite range; introduce in Ruby 2.7.\n      if Gem::Version.new(RUBY_VERSION) >= Gem::Version.new('2.7')\n        eval \"arr[0...]\" # Exclusive range\n      end\n    end\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n      # Beginless range; introduced in Ruby 2.7.\n      if Gem::Version.new(RUBY_VERSION) >= Gem::Version.new('2.7')\n        eval \"arr[...-1]\" # Exclusive range\n      end\n    end\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n      arr[-1, 1]\n    end\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n      arr[10, 12]\n    end\n  end\n\n  def test_array_settor\n    m = TestMessage.new\n    reference_arr = %w(foo bar baz)\n    m.repeated_string += reference_arr.clone\n\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n      arr[1] = 'junk'\n    end\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n      arr[-2] = 'snappy'\n    end\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n      arr[3] = ''\n    end\n    # slight deviation; we are strongly typed, and nil is not allowed\n    # for string types;\n    m.repeated_string[5] = 'spacious'\n    assert_equal [\"foo\", \"snappy\", \"baz\", \"\", \"\", \"spacious\"], m.repeated_string\n\n    #make sure it sests the default types for other fields besides strings\n    %w(repeated_int32 repeated_int64 repeated_uint32 repeated_uint64).each do |field_name|\n      m.send(field_name)[3] = 10\n      assert_equal [0,0,0,10], m.send(field_name)\n    end\n    m.repeated_float[3] = 10.1\n    #wonky mri float handling\n    assert_equal [0,0,0], m.repeated_float.to_a[0..2]\n    assert_equal 10.1, m.repeated_float[3].round(1)\n    m.repeated_double[3] = 10.1\n    assert_equal [0,0,0,10.1], m.repeated_double\n    m.repeated_bool[3] = true\n    assert_equal [false, false, false, true], m.repeated_bool\n    m.repeated_bytes[3] = \"bar\".encode!('ASCII-8BIT')\n    assert_equal ['', '', '', \"bar\".encode!('ASCII-8BIT')], m.repeated_bytes\n    m.repeated_msg[3] = TestMessage2.new(:foo => 1)\n    assert_equal [nil, nil, nil, TestMessage2.new(:foo => 1)], m.repeated_msg\n    m.repeated_enum[3] = :A\n    assert_equal [:Default, :Default, :Default, :A], m.repeated_enum\n\n    # check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n    #   arr[20] = 'spacious'\n    # end\n    # TODO: accessor doesn't allow other ruby-like methods\n    # check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n    #   arr[1, 2] = 'fizz'\n    # end\n    # check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n    #   arr[0..2] = 'buzz'\n    # end\n  end\n\n  def test_push\n    m = TestMessage.new\n    reference_arr = %w[foo bar baz]\n    m.repeated_string += reference_arr.clone\n\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n      arr.push('fizz')\n    end\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n      arr << 'fizz'\n    end\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n      arr.push('fizz', 'buzz')\n    end\n  end\n\n  def test_clear\n    m = TestMessage.new\n    reference_arr = %w(foo bar baz)\n    m.repeated_string += reference_arr.clone\n\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n      arr.clear\n    end\n  end\n\n  def test_concat\n    m = TestMessage.new\n    reference_arr = %w(foo bar baz)\n    m.repeated_string += reference_arr.clone\n    m.repeated_string.concat(['fizz', 'buzz'])\n    assert_equal %w(foo bar baz fizz buzz), m.repeated_string\n    #TODO: concat should return the orig array\n    # check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n    #   arr.concat(['fizz', 'buzz'])\n    # end\n  end\n\n  def test_equal\n    m = TestMessage.new\n    reference_arr = %w(foo bar baz)\n    m.repeated_string += reference_arr.clone\n    assert_equal reference_arr, m.repeated_string\n    reference_arr << 'fizz'\n    assert_not_equal reference_arr, m.repeated_string\n    m.repeated_string << 'fizz'\n    assert_equal reference_arr, m.repeated_string\n  end\n\n  def test_hash\n    # just a sanity check\n    m = TestMessage.new\n    reference_arr = %w(foo bar baz)\n    m.repeated_string += reference_arr.clone\n    assert m.repeated_string.hash.is_a?(Integer)\n    hash = m.repeated_string.hash\n    assert_equal hash, m.repeated_string.hash\n    m.repeated_string << 'j'\n    assert_not_equal hash, m.repeated_string.hash\n  end\n\n  def test_plus\n    m = TestMessage.new\n    reference_arr = %w(foo bar baz)\n    m.repeated_string += reference_arr.clone\n\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n      arr + ['fizz', 'buzz']\n    end\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n      arr += ['fizz', 'buzz']\n    end\n  end\n\n  def test_replace\n    m = TestMessage.new\n    reference_arr = %w(foo bar baz)\n    m.repeated_string += reference_arr.clone\n\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n      arr.replace(['fizz', 'buzz'])\n    end\n  end\n\n  def test_to_a\n    m = TestMessage.new\n    reference_arr = %w(foo bar baz)\n    m.repeated_string += reference_arr.clone\n\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n      arr.to_a\n    end\n  end\n\n  def test_to_ary\n    m = TestMessage.new\n    reference_arr = %w(foo bar baz)\n    m.repeated_string += reference_arr.clone\n\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n      arr.to_ary\n    end\n  end\n\n  # emulate Array behavior\n  ##########################\n\n  def test_collect!\n    m = TestMessage.new\n    reference_arr = %w(foo bar baz)\n    m.repeated_string += reference_arr.clone\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n      arr.collect!{|x| x + \"!\" }\n    end\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n      arr.collect!.with_index{|x, i| x[0...i] }\n    end\n  end\n\n  def test_delete\n    m = TestMessage.new\n    reference_arr = %w(foo bar baz)\n    m.repeated_string += reference_arr.clone\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n      arr.delete('bar')\n    end\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n      arr.delete('nope')\n    end\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n      arr.delete('nope'){'within'}\n    end\n  end\n\n  def test_delete_at\n    m = TestMessage.new\n    reference_arr = %w(foo bar baz)\n    m.repeated_string += reference_arr.clone\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n      arr.delete_at(2)\n    end\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n      arr.delete_at(10)\n    end\n  end\n\n  def test_delete_if\n    m = TestMessage.new\n    reference_arr = %w(foo bar baz)\n    m.repeated_string += reference_arr.clone\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n      arr.delete_if { |v| v == \"bar\" }\n    end\n  end\n\n  def test_fill\n    m = TestMessage.new\n    reference_arr = %w(foo bar baz)\n    m.repeated_string += reference_arr.clone\n\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n      arr.fill(\"x\")\n    end\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n      arr.fill(\"z\", 2, 2)\n    end\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n      arr.fill(\"y\", 0..1)\n    end\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n      arr.fill { |i| (i*i).to_s }\n    end\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n      arr.fill(-2) { |i| (i*i*i).to_s }\n    end\n  end\n\n  def test_flatten!\n    m = TestMessage.new\n    reference_arr = %w(foo bar baz)\n    m.repeated_string += reference_arr.clone\n\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n      arr.flatten!\n    end\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n      arr.flatten!(1)\n    end\n  end\n\n  def test_insert\n    m = TestMessage.new\n    reference_arr = %w(foo bar baz)\n    m.repeated_string += reference_arr.clone\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n      arr.insert(2, 'fizz')\n    end\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n      arr.insert(3, 'fizz', 'buzz', 'bazz')\n    end\n  end\n\n  def test_inspect\n    m = TestMessage.new\n    assert_equal '[]', m.repeated_string.inspect\n    m.repeated_string << 'foo'\n    assert_equal m.repeated_string.to_a.inspect, m.repeated_string.inspect\n    m.repeated_string << 'bar'\n    assert_equal m.repeated_string.to_a.inspect, m.repeated_string.inspect\n  end\n\n  def test_reverse!\n    m = TestMessage.new\n    reference_arr = %w(foo bar baz)\n    m.repeated_string += reference_arr.clone\n\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n      arr.reverse!\n    end\n  end\n\n  def test_rotate!\n    m = TestMessage.new\n    reference_arr = %w(foo bar baz)\n    m.repeated_string += reference_arr.clone\n\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n      arr.rotate!\n    end\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n      arr.rotate!(2)\n    end\n  end\n\n  def test_select!\n    m = TestMessage.new\n    reference_arr = %w(foo bar baz)\n    m.repeated_string += reference_arr.clone\n\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n      arr.select! { |v| v =~ /[aeiou]/ }\n    end\n  end\n\n  def test_shift\n    m = TestMessage.new\n    reference_arr = %w(foo bar baz)\n    m.repeated_string += reference_arr.clone\n\n    # should return an element\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n      arr.shift\n    end\n    # should return an array\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n      arr.shift(2)\n    end\n    # should return nil\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n      arr.shift\n    end\n  end\n\n  def test_shuffle!\n    m = TestMessage.new\n    m.repeated_string += %w(foo bar baz)\n    result = m.repeated_string.shuffle!\n    assert_equal m.repeated_string, result\n  end\n\n  def test_slice!\n    m = TestMessage.new\n    reference_arr = %w(foo bar baz bar fizz buzz)\n    m.repeated_string += reference_arr.clone\n\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n      arr.slice!(2)\n    end\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n      arr.slice!(1,2)\n    end\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n      arr.slice!(0..1)\n    end\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n      arr.slice!(10)\n    end\n  end\n\n  def test_sort!\n    m = TestMessage.new\n    reference_arr = %w(foo bar baz)\n    m.repeated_string += reference_arr.clone\n\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n      arr.sort!\n    end\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n      arr.sort! { |x,y| y <=> x }\n    end\n  end\n\n  def test_sort_by!\n    m = TestMessage.new\n    reference_arr = %w(foo bar baz)\n    m.repeated_string += reference_arr.clone\n\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n      arr.sort_by!\n    end\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n      arr.sort_by!(&:hash)\n    end\n  end\n\n  def test_uniq!\n    m = TestMessage.new\n    reference_arr = %w(foo bar baz)\n    m.repeated_string += reference_arr.clone\n\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n      arr.uniq!\n    end\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n      arr.uniq!{|s| s[0] }\n    end\n  end\n\n  def test_unshift\n    m = TestMessage.new\n    reference_arr = %w(foo bar baz)\n    m.repeated_string += reference_arr.clone\n\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n      arr.unshift('1')\n    end\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n      arr.unshift('a', 'b')\n    end\n    check_self_modifying_method(m.repeated_string, reference_arr) do |arr|\n      arr.unshift('')\n    end\n  end\n\n\n  ##### HELPER METHODS\n\n  def check_self_modifying_method(repeated_field, ref_array)\n    expected_result = yield(ref_array)\n    actual_result = yield(repeated_field)\n    if expected_result.is_a?(Enumerator)\n      assert_equal expected_result.to_a, actual_result.to_a\n    else\n      assert_equal expected_result, actual_result\n    end\n    assert_equal ref_array, repeated_field\n  end\n\n\n  def repeated_field_names(klass)\n    klass.descriptor.find_all{|f| f.label == :repeated}.map(&:name)\n  end\n\n\n  def fill_test_msg(test_msg)\n    test_msg.repeated_int32  += [-10, -11]\n    test_msg.repeated_int64  += [-1_000_000, -1_000_001]\n    test_msg.repeated_uint32 += [10, 11]\n    test_msg.repeated_uint64 += [1_000_000, 1_000_001]\n    test_msg.repeated_bool   += [true, false]\n    test_msg.repeated_float  += [-1.01, -1.02]\n    test_msg.repeated_double += [-1.0000000000001, -1.0000000000002]\n    test_msg.repeated_string += %w(foo bar)\n    test_msg.repeated_bytes  += [\"bar\".encode!('ASCII-8BIT'), \"foo\".encode!('ASCII-8BIT')]\n    test_msg.repeated_msg    << TestMessage2.new(:foo => 1)\n    test_msg.repeated_msg    << TestMessage2.new(:foo => 2)\n    test_msg.repeated_enum   << :A\n    test_msg.repeated_enum   << :B\n  end\n\n\n  pool = Google::Protobuf::DescriptorPool.new\n  pool.build do\n\n    add_message \"TestMessage\" do\n      optional :optional_int32,  :int32,        1\n      optional :optional_int64,  :int64,        2\n      optional :optional_uint32, :uint32,       3\n      optional :optional_uint64, :uint64,       4\n      optional :optional_bool,   :bool,         5\n      optional :optional_float,  :float,        6\n      optional :optional_double, :double,       7\n      optional :optional_string, :string,       8\n      optional :optional_bytes,  :bytes,        9\n      optional :optional_msg,    :message,      10, \"TestMessage2\"\n      optional :optional_enum,   :enum,         11, \"TestEnum\"\n\n      repeated :repeated_int32,  :int32,        12\n      repeated :repeated_int64,  :int64,        13\n      repeated :repeated_uint32, :uint32,       14\n      repeated :repeated_uint64, :uint64,       15\n      repeated :repeated_bool,   :bool,         16\n      repeated :repeated_float,  :float,        17\n      repeated :repeated_double, :double,       18\n      repeated :repeated_string, :string,       19\n      repeated :repeated_bytes,  :bytes,        20\n      repeated :repeated_msg,    :message,      21, \"TestMessage2\"\n      repeated :repeated_enum,   :enum,         22, \"TestEnum\"\n    end\n    add_message \"TestMessage2\" do\n      optional :foo, :int32, 1\n    end\n\n    add_enum \"TestEnum\" do\n      value :Default, 0\n      value :A, 1\n      value :B, 2\n      value :C, 3\n      value :v0, 4\n    end\n  end\n\n  TestMessage = pool.lookup(\"TestMessage\").msgclass\n  TestMessage2 = pool.lookup(\"TestMessage2\").msgclass\n  TestEnum = pool.lookup(\"TestEnum\").enummodule\n\n\nend\n"], "filenames": ["CHANGES.txt", "java/core/src/main/java/com/google/protobuf/MessageReflection.java", "ruby/compatibility_tests/v3.0.0/tests/basic.rb", "ruby/ext/google/protobuf_c/message.c", "ruby/src/main/java/com/google/protobuf/jruby/RubyEnumDescriptor.java", "ruby/tests/basic_test.proto", "ruby/tests/basic_test_proto2.proto", "ruby/tests/common_tests.rb", "ruby/tests/generated_code.proto", "ruby/tests/generated_code_proto2.proto", "ruby/tests/repeated_field_test.rb"], "buggy_code_start_loc": [43, 380, 670, 1266, 165, 75, 71, 334, 69, 70, 699], "buggy_code_end_loc": [44, 630, 672, 1274, 191, 75, 71, 1766, 69, 70, 699], "fixing_code_start_loc": [42, 381, 670, 1266, 165, 76, 72, 334, 70, 71, 700], "fixing_code_end_loc": [52, 673, 672, 1280, 209, 77, 73, 1771, 72, 73, 701], "type": "NVD-CWE-noinfo", "message": "A parsing issue similar to CVE-2022-3171, but with Message-Type Extensions in protobuf-java core and lite versions prior to 3.21.7, 3.20.3, 3.19.6 and 3.16.3 can lead to a denial of service attack. Inputs containing multiple instances of non-repeated embedded messages with repeated or unknown fields causes objects to be converted back-n-forth between mutable and immutable forms, resulting in potentially long garbage collection pauses. We recommend updating to the versions mentioned above.", "other": {"cve": {"id": "CVE-2022-3510", "sourceIdentifier": "cve-coordination@google.com", "published": "2022-12-12T13:15:14.670", "lastModified": "2022-12-15T16:52:58.830", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A parsing issue similar to CVE-2022-3171, but with Message-Type Extensions in protobuf-java core and lite versions prior to 3.21.7, 3.20.3, 3.19.6 and 3.16.3 can lead to a denial of service attack. Inputs containing multiple instances of non-repeated embedded messages with repeated or unknown fields causes objects to be converted back-n-forth between mutable and immutable forms, resulting in potentially long garbage collection pauses. We recommend updating to the versions mentioned above."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "cve-coordination@google.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:google:protobuf-java:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.16.0", "versionEndExcluding": "3.16.3", "matchCriteriaId": "AB303B67-87A7-43AC-8A8B-B037C2D06B3F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:protobuf-java:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.19.0", "versionEndExcluding": "3.19.6", "matchCriteriaId": "3C2D62DC-0F66-4A30-B9FE-EA6199E60538"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:protobuf-java:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.20.0", "versionEndExcluding": "3.20.3", "matchCriteriaId": "56CA1E8D-A555-4F4F-80D8-F23D0DC50BB8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:protobuf-java:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.21.0", "versionEndExcluding": "3.21.7", "matchCriteriaId": "E82CFAC2-2F65-45FD-88D9-D42145FC4A4F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:protobuf-javalite:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.16.0", "versionEndExcluding": "3.16.3", "matchCriteriaId": "63C927E5-FAB2-4F2E-8F28-EC3CC160837C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:protobuf-javalite:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.17.0", "versionEndExcluding": "3.19.6", "matchCriteriaId": "2B4050D4-2224-467C-B46D-2CD734B3B0FB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:protobuf-javalite:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.20.0", "versionEndExcluding": "3.20.3", "matchCriteriaId": "459A8615-D2ED-49F3-A81C-DC4560D96C93"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:protobuf-javalite:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.21.0", "versionEndExcluding": "3.21.7", "matchCriteriaId": "712693B9-41AB-41D1-97B2-560FDFEE0863"}]}]}], "references": [{"url": "https://github.com/protocolbuffers/protobuf/commit/db7c17803320525722f45c1d26fc08bc41d1bf48", "source": "cve-coordination@google.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/protocolbuffers/protobuf/commit/db7c17803320525722f45c1d26fc08bc41d1bf48"}}