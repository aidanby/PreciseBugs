{"buggy_code": ["/*\nCopyright The Helm Authors.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\npackage main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"os\"\n\t\"os/signal\"\n\t\"syscall\"\n\t\"time\"\n\n\t\"github.com/pkg/errors\"\n\t\"github.com/spf13/cobra\"\n\t\"github.com/spf13/pflag\"\n\n\t\"helm.sh/helm/v3/cmd/helm/require\"\n\t\"helm.sh/helm/v3/pkg/action\"\n\t\"helm.sh/helm/v3/pkg/chart\"\n\t\"helm.sh/helm/v3/pkg/chart/loader\"\n\t\"helm.sh/helm/v3/pkg/cli/output\"\n\t\"helm.sh/helm/v3/pkg/cli/values\"\n\t\"helm.sh/helm/v3/pkg/downloader\"\n\t\"helm.sh/helm/v3/pkg/getter\"\n\t\"helm.sh/helm/v3/pkg/release\"\n)\n\nconst installDesc = `\nThis command installs a chart archive.\n\nThe install argument must be a chart reference, a path to a packaged chart,\na path to an unpacked chart directory or a URL.\n\nTo override values in a chart, use either the '--values' flag and pass in a file\nor use the '--set' flag and pass configuration from the command line, to force\na string value use '--set-string'. You can use '--set-file' to set individual\nvalues from a file when the value itself is too long for the command line\nor is dynamically generated. You can also use '--set-json' to set json values\n(scalars/objects/arrays) from the command line.\n\n    $ helm install -f myvalues.yaml myredis ./redis\n\nor\n\n    $ helm install --set name=prod myredis ./redis\n\nor\n\n    $ helm install --set-string long_int=1234567890 myredis ./redis\n\nor\n\n    $ helm install --set-file my_script=dothings.sh myredis ./redis\n\nor\n\n    $ helm install --set-json 'master.sidecars=[{\"name\":\"sidecar\",\"image\":\"myImage\",\"imagePullPolicy\":\"Always\",\"ports\":[{\"name\":\"portname\",\"containerPort\":1234}]}]' myredis ./redis\n\n\nYou can specify the '--values'/'-f' flag multiple times. The priority will be given to the\nlast (right-most) file specified. For example, if both myvalues.yaml and override.yaml\ncontained a key called 'Test', the value set in override.yaml would take precedence:\n\n    $ helm install -f myvalues.yaml -f override.yaml  myredis ./redis\n\nYou can specify the '--set' flag multiple times. The priority will be given to the\nlast (right-most) set specified. For example, if both 'bar' and 'newbar' values are\nset for a key called 'foo', the 'newbar' value would take precedence:\n\n    $ helm install --set foo=bar --set foo=newbar  myredis ./redis\n\nSimilarly, in the following example 'foo' is set to '[\"four\"]': \n\n    $ helm install --set-json='foo=[\"one\", \"two\", \"three\"]' --set-json='foo=[\"four\"]' myredis ./redis\n\nAnd in the following example, 'foo' is set to '{\"key1\":\"value1\",\"key2\":\"bar\"}':\n\n    $ helm install --set-json='foo={\"key1\":\"value1\",\"key2\":\"value2\"}' --set-json='foo.key2=\"bar\"' myredis ./redis\n\nTo check the generated manifests of a release without installing the chart,\nthe '--debug' and '--dry-run' flags can be combined.\n\nIf --verify is set, the chart MUST have a provenance file, and the provenance\nfile MUST pass all verification steps.\n\nThere are six different ways you can express the chart you want to install:\n\n1. By chart reference: helm install mymaria example/mariadb\n2. By path to a packaged chart: helm install mynginx ./nginx-1.2.3.tgz\n3. By path to an unpacked chart directory: helm install mynginx ./nginx\n4. By absolute URL: helm install mynginx https://example.com/charts/nginx-1.2.3.tgz\n5. By chart reference and repo url: helm install --repo https://example.com/charts/ mynginx nginx\n6. By OCI registries: helm install mynginx --version 1.2.3 oci://example.com/charts/nginx\n\nCHART REFERENCES\n\nA chart reference is a convenient way of referencing a chart in a chart repository.\n\nWhen you use a chart reference with a repo prefix ('example/mariadb'), Helm will look in the local\nconfiguration for a chart repository named 'example', and will then look for a\nchart in that repository whose name is 'mariadb'. It will install the latest stable version of that chart\nuntil you specify '--devel' flag to also include development version (alpha, beta, and release candidate releases), or\nsupply a version number with the '--version' flag.\n\nTo see the list of chart repositories, use 'helm repo list'. To search for\ncharts in a repository, use 'helm search'.\n`\n\nfunc newInstallCmd(cfg *action.Configuration, out io.Writer) *cobra.Command {\n\tclient := action.NewInstall(cfg)\n\tvalueOpts := &values.Options{}\n\tvar outfmt output.Format\n\n\tcmd := &cobra.Command{\n\t\tUse:   \"install [NAME] [CHART]\",\n\t\tShort: \"install a chart\",\n\t\tLong:  installDesc,\n\t\tArgs:  require.MinimumNArgs(1),\n\t\tValidArgsFunction: func(cmd *cobra.Command, args []string, toComplete string) ([]string, cobra.ShellCompDirective) {\n\t\t\treturn compInstall(args, toComplete, client)\n\t\t},\n\t\tRunE: func(_ *cobra.Command, args []string) error {\n\t\t\trel, err := runInstall(args, client, valueOpts, out)\n\t\t\tif err != nil {\n\t\t\t\treturn errors.Wrap(err, \"INSTALLATION FAILED\")\n\t\t\t}\n\n\t\t\treturn outfmt.Write(out, &statusPrinter{rel, settings.Debug, false, false})\n\t\t},\n\t}\n\n\taddInstallFlags(cmd, cmd.Flags(), client, valueOpts)\n\tbindOutputFlag(cmd, &outfmt)\n\tbindPostRenderFlag(cmd, &client.PostRenderer)\n\n\treturn cmd\n}\n\nfunc addInstallFlags(cmd *cobra.Command, f *pflag.FlagSet, client *action.Install, valueOpts *values.Options) {\n\tf.BoolVar(&client.CreateNamespace, \"create-namespace\", false, \"create the release namespace if not present\")\n\tf.BoolVar(&client.DryRun, \"dry-run\", false, \"simulate an install\")\n\tf.BoolVar(&client.Force, \"force\", false, \"force resource updates through a replacement strategy\")\n\tf.BoolVar(&client.DisableHooks, \"no-hooks\", false, \"prevent hooks from running during install\")\n\tf.BoolVar(&client.Replace, \"replace\", false, \"re-use the given name, only if that name is a deleted release which remains in the history. This is unsafe in production\")\n\tf.DurationVar(&client.Timeout, \"timeout\", 300*time.Second, \"time to wait for any individual Kubernetes operation (like Jobs for hooks)\")\n\tf.BoolVar(&client.Wait, \"wait\", false, \"if set, will wait until all Pods, PVCs, Services, and minimum number of Pods of a Deployment, StatefulSet, or ReplicaSet are in a ready state before marking the release as successful. It will wait for as long as --timeout\")\n\tf.BoolVar(&client.WaitForJobs, \"wait-for-jobs\", false, \"if set and --wait enabled, will wait until all Jobs have been completed before marking the release as successful. It will wait for as long as --timeout\")\n\tf.BoolVarP(&client.GenerateName, \"generate-name\", \"g\", false, \"generate the name (and omit the NAME parameter)\")\n\tf.StringVar(&client.NameTemplate, \"name-template\", \"\", \"specify template used to name the release\")\n\tf.StringVar(&client.Description, \"description\", \"\", \"add a custom description\")\n\tf.BoolVar(&client.Devel, \"devel\", false, \"use development versions, too. Equivalent to version '>0.0.0-0'. If --version is set, this is ignored\")\n\tf.BoolVar(&client.DependencyUpdate, \"dependency-update\", false, \"update dependencies if they are missing before installing the chart\")\n\tf.BoolVar(&client.DisableOpenAPIValidation, \"disable-openapi-validation\", false, \"if set, the installation process will not validate rendered templates against the Kubernetes OpenAPI Schema\")\n\tf.BoolVar(&client.Atomic, \"atomic\", false, \"if set, the installation process deletes the installation on failure. The --wait flag will be set automatically if --atomic is used\")\n\tf.BoolVar(&client.SkipCRDs, \"skip-crds\", false, \"if set, no CRDs will be installed. By default, CRDs are installed if not already present\")\n\tf.BoolVar(&client.SubNotes, \"render-subchart-notes\", false, \"if set, render subchart notes along with the parent\")\n\taddValueOptionsFlags(f, valueOpts)\n\taddChartPathOptionsFlags(f, &client.ChartPathOptions)\n\n\terr := cmd.RegisterFlagCompletionFunc(\"version\", func(cmd *cobra.Command, args []string, toComplete string) ([]string, cobra.ShellCompDirective) {\n\t\trequiredArgs := 2\n\t\tif client.GenerateName {\n\t\t\trequiredArgs = 1\n\t\t}\n\t\tif len(args) != requiredArgs {\n\t\t\treturn nil, cobra.ShellCompDirectiveNoFileComp\n\t\t}\n\t\treturn compVersionFlag(args[requiredArgs-1], toComplete)\n\t})\n\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n}\n\nfunc runInstall(args []string, client *action.Install, valueOpts *values.Options, out io.Writer) (*release.Release, error) {\n\tdebug(\"Original chart version: %q\", client.Version)\n\tif client.Version == \"\" && client.Devel {\n\t\tdebug(\"setting version to >0.0.0-0\")\n\t\tclient.Version = \">0.0.0-0\"\n\t}\n\n\tname, chart, err := client.NameAndChart(args)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tclient.ReleaseName = name\n\n\tcp, err := client.ChartPathOptions.LocateChart(chart, settings)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tdebug(\"CHART PATH: %s\\n\", cp)\n\n\tp := getter.All(settings)\n\tvals, err := valueOpts.MergeValues(p)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Check chart dependencies to make sure all are present in /charts\n\tchartRequested, err := loader.Load(cp)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif err := checkIfInstallable(chartRequested); err != nil {\n\t\treturn nil, err\n\t}\n\n\tif chartRequested.Metadata.Deprecated {\n\t\twarning(\"This chart is deprecated\")\n\t}\n\n\tif req := chartRequested.Metadata.Dependencies; req != nil {\n\t\t// If CheckDependencies returns an error, we have unfulfilled dependencies.\n\t\t// As of Helm 2.4.0, this is treated as a stopping condition:\n\t\t// https://github.com/helm/helm/issues/2209\n\t\tif err := action.CheckDependencies(chartRequested, req); err != nil {\n\t\t\terr = errors.Wrap(err, \"An error occurred while checking for chart dependencies. You may need to run `helm dependency build` to fetch missing dependencies\")\n\t\t\tif client.DependencyUpdate {\n\t\t\t\tman := &downloader.Manager{\n\t\t\t\t\tOut:              out,\n\t\t\t\t\tChartPath:        cp,\n\t\t\t\t\tKeyring:          client.ChartPathOptions.Keyring,\n\t\t\t\t\tSkipUpdate:       false,\n\t\t\t\t\tGetters:          p,\n\t\t\t\t\tRepositoryConfig: settings.RepositoryConfig,\n\t\t\t\t\tRepositoryCache:  settings.RepositoryCache,\n\t\t\t\t\tDebug:            settings.Debug,\n\t\t\t\t}\n\t\t\t\tif err := man.Update(); err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t\t// Reload the chart with the updated Chart.lock file.\n\t\t\t\tif chartRequested, err = loader.Load(cp); err != nil {\n\t\t\t\t\treturn nil, errors.Wrap(err, \"failed reloading chart after repo update\")\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\t}\n\n\tclient.Namespace = settings.Namespace()\n\n\t// Create context and prepare the handle of SIGTERM\n\tctx := context.Background()\n\tctx, cancel := context.WithCancel(ctx)\n\n\t// Set up channel on which to send signal notifications.\n\t// We must use a buffered channel or risk missing the signal\n\t// if we're not ready to receive when the signal is sent.\n\tcSignal := make(chan os.Signal, 2)\n\tsignal.Notify(cSignal, os.Interrupt, syscall.SIGTERM)\n\tgo func() {\n\t\t<-cSignal\n\t\tfmt.Fprintf(out, \"Release %s has been cancelled.\\n\", args[0])\n\t\tcancel()\n\t}()\n\n\treturn client.RunWithContext(ctx, chartRequested, vals)\n}\n\n// checkIfInstallable validates if a chart can be installed\n//\n// Application chart type is only installable\nfunc checkIfInstallable(ch *chart.Chart) error {\n\tswitch ch.Metadata.Type {\n\tcase \"\", \"application\":\n\t\treturn nil\n\t}\n\treturn errors.Errorf(\"%s charts are not installable\", ch.Metadata.Type)\n}\n\n// Provide dynamic auto-completion for the install and template commands\nfunc compInstall(args []string, toComplete string, client *action.Install) ([]string, cobra.ShellCompDirective) {\n\trequiredArgs := 1\n\tif client.GenerateName {\n\t\trequiredArgs = 0\n\t}\n\tif len(args) == requiredArgs {\n\t\treturn compListCharts(toComplete, true)\n\t}\n\treturn nil, cobra.ShellCompDirectiveNoFileComp\n}\n", "/*\nCopyright The Helm Authors.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\npackage main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"os\"\n\t\"os/signal\"\n\t\"syscall\"\n\t\"time\"\n\n\t\"github.com/pkg/errors\"\n\t\"github.com/spf13/cobra\"\n\n\t\"helm.sh/helm/v3/cmd/helm/require\"\n\t\"helm.sh/helm/v3/pkg/action\"\n\t\"helm.sh/helm/v3/pkg/chart/loader\"\n\t\"helm.sh/helm/v3/pkg/cli/output\"\n\t\"helm.sh/helm/v3/pkg/cli/values\"\n\t\"helm.sh/helm/v3/pkg/downloader\"\n\t\"helm.sh/helm/v3/pkg/getter\"\n\t\"helm.sh/helm/v3/pkg/storage/driver\"\n)\n\nconst upgradeDesc = `\nThis command upgrades a release to a new version of a chart.\n\nThe upgrade arguments must be a release and chart. The chart\nargument can be either: a chart reference('example/mariadb'), a path to a chart directory,\na packaged chart, or a fully qualified URL. For chart references, the latest\nversion will be specified unless the '--version' flag is set.\n\nTo override values in a chart, use either the '--values' flag and pass in a file\nor use the '--set' flag and pass configuration from the command line, to force string\nvalues, use '--set-string'. You can use '--set-file' to set individual\nvalues from a file when the value itself is too long for the command line\nor is dynamically generated. You can also use '--set-json' to set json values\n(scalars/objects/arrays) from the command line.\n\nYou can specify the '--values'/'-f' flag multiple times. The priority will be given to the\nlast (right-most) file specified. For example, if both myvalues.yaml and override.yaml\ncontained a key called 'Test', the value set in override.yaml would take precedence:\n\n    $ helm upgrade -f myvalues.yaml -f override.yaml redis ./redis\n\nYou can specify the '--set' flag multiple times. The priority will be given to the\nlast (right-most) set specified. For example, if both 'bar' and 'newbar' values are\nset for a key called 'foo', the 'newbar' value would take precedence:\n\n    $ helm upgrade --set foo=bar --set foo=newbar redis ./redis\n`\n\nfunc newUpgradeCmd(cfg *action.Configuration, out io.Writer) *cobra.Command {\n\tclient := action.NewUpgrade(cfg)\n\tvalueOpts := &values.Options{}\n\tvar outfmt output.Format\n\tvar createNamespace bool\n\n\tcmd := &cobra.Command{\n\t\tUse:   \"upgrade [RELEASE] [CHART]\",\n\t\tShort: \"upgrade a release\",\n\t\tLong:  upgradeDesc,\n\t\tArgs:  require.ExactArgs(2),\n\t\tValidArgsFunction: func(cmd *cobra.Command, args []string, toComplete string) ([]string, cobra.ShellCompDirective) {\n\t\t\tif len(args) == 0 {\n\t\t\t\treturn compListReleases(toComplete, args, cfg)\n\t\t\t}\n\t\t\tif len(args) == 1 {\n\t\t\t\treturn compListCharts(toComplete, true)\n\t\t\t}\n\t\t\treturn nil, cobra.ShellCompDirectiveNoFileComp\n\t\t},\n\t\tRunE: func(cmd *cobra.Command, args []string) error {\n\t\t\tclient.Namespace = settings.Namespace()\n\n\t\t\t// Fixes #7002 - Support reading values from STDIN for `upgrade` command\n\t\t\t// Must load values AFTER determining if we have to call install so that values loaded from stdin are are not read twice\n\t\t\tif client.Install {\n\t\t\t\t// If a release does not exist, install it.\n\t\t\t\thistClient := action.NewHistory(cfg)\n\t\t\t\thistClient.Max = 1\n\t\t\t\tif _, err := histClient.Run(args[0]); err == driver.ErrReleaseNotFound {\n\t\t\t\t\t// Only print this to stdout for table output\n\t\t\t\t\tif outfmt == output.Table {\n\t\t\t\t\t\tfmt.Fprintf(out, \"Release %q does not exist. Installing it now.\\n\", args[0])\n\t\t\t\t\t}\n\t\t\t\t\tinstClient := action.NewInstall(cfg)\n\t\t\t\t\tinstClient.CreateNamespace = createNamespace\n\t\t\t\t\tinstClient.ChartPathOptions = client.ChartPathOptions\n\t\t\t\t\tinstClient.Force = client.Force\n\t\t\t\t\tinstClient.DryRun = client.DryRun\n\t\t\t\t\tinstClient.DisableHooks = client.DisableHooks\n\t\t\t\t\tinstClient.SkipCRDs = client.SkipCRDs\n\t\t\t\t\tinstClient.Timeout = client.Timeout\n\t\t\t\t\tinstClient.Wait = client.Wait\n\t\t\t\t\tinstClient.WaitForJobs = client.WaitForJobs\n\t\t\t\t\tinstClient.Devel = client.Devel\n\t\t\t\t\tinstClient.Namespace = client.Namespace\n\t\t\t\t\tinstClient.Atomic = client.Atomic\n\t\t\t\t\tinstClient.PostRenderer = client.PostRenderer\n\t\t\t\t\tinstClient.DisableOpenAPIValidation = client.DisableOpenAPIValidation\n\t\t\t\t\tinstClient.SubNotes = client.SubNotes\n\t\t\t\t\tinstClient.Description = client.Description\n\t\t\t\t\tinstClient.DependencyUpdate = client.DependencyUpdate\n\n\t\t\t\t\trel, err := runInstall(args, instClient, valueOpts, out)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t\treturn outfmt.Write(out, &statusPrinter{rel, settings.Debug, false, false})\n\t\t\t\t} else if err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif client.Version == \"\" && client.Devel {\n\t\t\t\tdebug(\"setting version to >0.0.0-0\")\n\t\t\t\tclient.Version = \">0.0.0-0\"\n\t\t\t}\n\n\t\t\tchartPath, err := client.ChartPathOptions.LocateChart(args[1], settings)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tp := getter.All(settings)\n\t\t\tvals, err := valueOpts.MergeValues(p)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\t// Check chart dependencies to make sure all are present in /charts\n\t\t\tch, err := loader.Load(chartPath)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif req := ch.Metadata.Dependencies; req != nil {\n\t\t\t\tif err := action.CheckDependencies(ch, req); err != nil {\n\t\t\t\t\terr = errors.Wrap(err, \"An error occurred while checking for chart dependencies. You may need to run `helm dependency build` to fetch missing dependencies\")\n\t\t\t\t\tif client.DependencyUpdate {\n\t\t\t\t\t\tman := &downloader.Manager{\n\t\t\t\t\t\t\tOut:              out,\n\t\t\t\t\t\t\tChartPath:        chartPath,\n\t\t\t\t\t\t\tKeyring:          client.ChartPathOptions.Keyring,\n\t\t\t\t\t\t\tSkipUpdate:       false,\n\t\t\t\t\t\t\tGetters:          p,\n\t\t\t\t\t\t\tRepositoryConfig: settings.RepositoryConfig,\n\t\t\t\t\t\t\tRepositoryCache:  settings.RepositoryCache,\n\t\t\t\t\t\t\tDebug:            settings.Debug,\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif err := man.Update(); err != nil {\n\t\t\t\t\t\t\treturn err\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Reload the chart with the updated Chart.lock file.\n\t\t\t\t\t\tif ch, err = loader.Load(chartPath); err != nil {\n\t\t\t\t\t\t\treturn errors.Wrap(err, \"failed reloading chart after repo update\")\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ch.Metadata.Deprecated {\n\t\t\t\twarning(\"This chart is deprecated\")\n\t\t\t}\n\n\t\t\t// Create context and prepare the handle of SIGTERM\n\t\t\tctx := context.Background()\n\t\t\tctx, cancel := context.WithCancel(ctx)\n\n\t\t\t// Set up channel on which to send signal notifications.\n\t\t\t// We must use a buffered channel or risk missing the signal\n\t\t\t// if we're not ready to receive when the signal is sent.\n\t\t\tcSignal := make(chan os.Signal, 2)\n\t\t\tsignal.Notify(cSignal, os.Interrupt, syscall.SIGTERM)\n\t\t\tgo func() {\n\t\t\t\t<-cSignal\n\t\t\t\tfmt.Fprintf(out, \"Release %s has been cancelled.\\n\", args[0])\n\t\t\t\tcancel()\n\t\t\t}()\n\n\t\t\trel, err := client.RunWithContext(ctx, args[0], ch, vals)\n\t\t\tif err != nil {\n\t\t\t\treturn errors.Wrap(err, \"UPGRADE FAILED\")\n\t\t\t}\n\n\t\t\tif outfmt == output.Table {\n\t\t\t\tfmt.Fprintf(out, \"Release %q has been upgraded. Happy Helming!\\n\", args[0])\n\t\t\t}\n\n\t\t\treturn outfmt.Write(out, &statusPrinter{rel, settings.Debug, false, false})\n\t\t},\n\t}\n\n\tf := cmd.Flags()\n\tf.BoolVar(&createNamespace, \"create-namespace\", false, \"if --install is set, create the release namespace if not present\")\n\tf.BoolVarP(&client.Install, \"install\", \"i\", false, \"if a release by this name doesn't already exist, run an install\")\n\tf.BoolVar(&client.Devel, \"devel\", false, \"use development versions, too. Equivalent to version '>0.0.0-0'. If --version is set, this is ignored\")\n\tf.BoolVar(&client.DryRun, \"dry-run\", false, \"simulate an upgrade\")\n\tf.BoolVar(&client.Recreate, \"recreate-pods\", false, \"performs pods restart for the resource if applicable\")\n\tf.MarkDeprecated(\"recreate-pods\", \"functionality will no longer be updated. Consult the documentation for other methods to recreate pods\")\n\tf.BoolVar(&client.Force, \"force\", false, \"force resource updates through a replacement strategy\")\n\tf.BoolVar(&client.DisableHooks, \"no-hooks\", false, \"disable pre/post upgrade hooks\")\n\tf.BoolVar(&client.DisableOpenAPIValidation, \"disable-openapi-validation\", false, \"if set, the upgrade process will not validate rendered templates against the Kubernetes OpenAPI Schema\")\n\tf.BoolVar(&client.SkipCRDs, \"skip-crds\", false, \"if set, no CRDs will be installed when an upgrade is performed with install flag enabled. By default, CRDs are installed if not already present, when an upgrade is performed with install flag enabled\")\n\tf.DurationVar(&client.Timeout, \"timeout\", 300*time.Second, \"time to wait for any individual Kubernetes operation (like Jobs for hooks)\")\n\tf.BoolVar(&client.ResetValues, \"reset-values\", false, \"when upgrading, reset the values to the ones built into the chart\")\n\tf.BoolVar(&client.ReuseValues, \"reuse-values\", false, \"when upgrading, reuse the last release's values and merge in any overrides from the command line via --set and -f. If '--reset-values' is specified, this is ignored\")\n\tf.BoolVar(&client.Wait, \"wait\", false, \"if set, will wait until all Pods, PVCs, Services, and minimum number of Pods of a Deployment, StatefulSet, or ReplicaSet are in a ready state before marking the release as successful. It will wait for as long as --timeout\")\n\tf.BoolVar(&client.WaitForJobs, \"wait-for-jobs\", false, \"if set and --wait enabled, will wait until all Jobs have been completed before marking the release as successful. It will wait for as long as --timeout\")\n\tf.BoolVar(&client.Atomic, \"atomic\", false, \"if set, upgrade process rolls back changes made in case of failed upgrade. The --wait flag will be set automatically if --atomic is used\")\n\tf.IntVar(&client.MaxHistory, \"history-max\", settings.MaxHistory, \"limit the maximum number of revisions saved per release. Use 0 for no limit\")\n\tf.BoolVar(&client.CleanupOnFail, \"cleanup-on-fail\", false, \"allow deletion of new resources created in this upgrade when upgrade fails\")\n\tf.BoolVar(&client.SubNotes, \"render-subchart-notes\", false, \"if set, render subchart notes along with the parent\")\n\tf.StringVar(&client.Description, \"description\", \"\", \"add a custom description\")\n\tf.BoolVar(&client.DependencyUpdate, \"dependency-update\", false, \"update dependencies if they are missing before installing the chart\")\n\taddChartPathOptionsFlags(f, &client.ChartPathOptions)\n\taddValueOptionsFlags(f, valueOpts)\n\tbindOutputFlag(cmd, &outfmt)\n\tbindPostRenderFlag(cmd, &client.PostRenderer)\n\n\terr := cmd.RegisterFlagCompletionFunc(\"version\", func(cmd *cobra.Command, args []string, toComplete string) ([]string, cobra.ShellCompDirective) {\n\t\tif len(args) != 2 {\n\t\t\treturn nil, cobra.ShellCompDirectiveNoFileComp\n\t\t}\n\t\treturn compVersionFlag(args[1], toComplete)\n\t})\n\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\treturn cmd\n}\n", "/*\nCopyright The Helm Authors.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\npackage action\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"os\"\n\t\"path\"\n\t\"path/filepath\"\n\t\"regexp\"\n\t\"strings\"\n\n\t\"github.com/pkg/errors\"\n\t\"k8s.io/apimachinery/pkg/api/meta\"\n\t\"k8s.io/cli-runtime/pkg/genericclioptions\"\n\t\"k8s.io/client-go/discovery\"\n\t\"k8s.io/client-go/kubernetes\"\n\t\"k8s.io/client-go/rest\"\n\n\t\"helm.sh/helm/v3/pkg/chart\"\n\t\"helm.sh/helm/v3/pkg/chartutil\"\n\t\"helm.sh/helm/v3/pkg/engine\"\n\t\"helm.sh/helm/v3/pkg/kube\"\n\t\"helm.sh/helm/v3/pkg/postrender\"\n\t\"helm.sh/helm/v3/pkg/registry\"\n\t\"helm.sh/helm/v3/pkg/release\"\n\t\"helm.sh/helm/v3/pkg/releaseutil\"\n\t\"helm.sh/helm/v3/pkg/storage\"\n\t\"helm.sh/helm/v3/pkg/storage/driver\"\n\t\"helm.sh/helm/v3/pkg/time\"\n)\n\n// Timestamper is a function capable of producing a timestamp.Timestamper.\n//\n// By default, this is a time.Time function from the Helm time package. This can\n// be overridden for testing though, so that timestamps are predictable.\nvar Timestamper = time.Now\n\nvar (\n\t// errMissingChart indicates that a chart was not provided.\n\terrMissingChart = errors.New(\"no chart provided\")\n\t// errMissingRelease indicates that a release (name) was not provided.\n\terrMissingRelease = errors.New(\"no release provided\")\n\t// errInvalidRevision indicates that an invalid release revision number was provided.\n\terrInvalidRevision = errors.New(\"invalid release revision\")\n\t// errPending indicates that another instance of Helm is already applying an operation on a release.\n\terrPending = errors.New(\"another operation (install/upgrade/rollback) is in progress\")\n)\n\n// ValidName is a regular expression for resource names.\n//\n// DEPRECATED: This will be removed in Helm 4, and is no longer used here. See\n// pkg/lint/rules.validateMetadataNameFunc for the replacement.\n//\n// According to the Kubernetes help text, the regular expression it uses is:\n//\n//\t[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*\n//\n// This follows the above regular expression (but requires a full string match, not partial).\n//\n// The Kubernetes documentation is here, though it is not entirely correct:\n// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names\nvar ValidName = regexp.MustCompile(`^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$`)\n\n// Configuration injects the dependencies that all actions share.\ntype Configuration struct {\n\t// RESTClientGetter is an interface that loads Kubernetes clients.\n\tRESTClientGetter RESTClientGetter\n\n\t// Releases stores records of releases.\n\tReleases *storage.Storage\n\n\t// KubeClient is a Kubernetes API client.\n\tKubeClient kube.Interface\n\n\t// RegistryClient is a client for working with registries\n\tRegistryClient *registry.Client\n\n\t// Capabilities describes the capabilities of the Kubernetes cluster.\n\tCapabilities *chartutil.Capabilities\n\n\tLog func(string, ...interface{})\n}\n\n// renderResources renders the templates in a chart\n//\n// TODO: This function is badly in need of a refactor.\n// TODO: As part of the refactor the duplicate code in cmd/helm/template.go should be removed\n//       This code has to do with writing files to disk.\nfunc (cfg *Configuration) renderResources(ch *chart.Chart, values chartutil.Values, releaseName, outputDir string, subNotes, useReleaseName, includeCrds bool, pr postrender.PostRenderer, dryRun bool) ([]*release.Hook, *bytes.Buffer, string, error) {\n\ths := []*release.Hook{}\n\tb := bytes.NewBuffer(nil)\n\n\tcaps, err := cfg.getCapabilities()\n\tif err != nil {\n\t\treturn hs, b, \"\", err\n\t}\n\n\tif ch.Metadata.KubeVersion != \"\" {\n\t\tif !chartutil.IsCompatibleRange(ch.Metadata.KubeVersion, caps.KubeVersion.String()) {\n\t\t\treturn hs, b, \"\", errors.Errorf(\"chart requires kubeVersion: %s which is incompatible with Kubernetes %s\", ch.Metadata.KubeVersion, caps.KubeVersion.String())\n\t\t}\n\t}\n\n\tvar files map[string]string\n\tvar err2 error\n\n\t// A `helm template` or `helm install --dry-run` should not talk to the remote cluster.\n\t// It will break in interesting and exotic ways because other data (e.g. discovery)\n\t// is mocked. It is not up to the template author to decide when the user wants to\n\t// connect to the cluster. So when the user says to dry run, respect the user's\n\t// wishes and do not connect to the cluster.\n\tif !dryRun && cfg.RESTClientGetter != nil {\n\t\trestConfig, err := cfg.RESTClientGetter.ToRESTConfig()\n\t\tif err != nil {\n\t\t\treturn hs, b, \"\", err\n\t\t}\n\t\tfiles, err2 = engine.RenderWithClient(ch, values, restConfig)\n\t} else {\n\t\tfiles, err2 = engine.Render(ch, values)\n\t}\n\n\tif err2 != nil {\n\t\treturn hs, b, \"\", err2\n\t}\n\n\t// NOTES.txt gets rendered like all the other files, but because it's not a hook nor a resource,\n\t// pull it out of here into a separate file so that we can actually use the output of the rendered\n\t// text file. We have to spin through this map because the file contains path information, so we\n\t// look for terminating NOTES.txt. We also remove it from the files so that we don't have to skip\n\t// it in the sortHooks.\n\tvar notesBuffer bytes.Buffer\n\tfor k, v := range files {\n\t\tif strings.HasSuffix(k, notesFileSuffix) {\n\t\t\tif subNotes || (k == path.Join(ch.Name(), \"templates\", notesFileSuffix)) {\n\t\t\t\t// If buffer contains data, add newline before adding more\n\t\t\t\tif notesBuffer.Len() > 0 {\n\t\t\t\t\tnotesBuffer.WriteString(\"\\n\")\n\t\t\t\t}\n\t\t\t\tnotesBuffer.WriteString(v)\n\t\t\t}\n\t\t\tdelete(files, k)\n\t\t}\n\t}\n\tnotes := notesBuffer.String()\n\n\t// Sort hooks, manifests, and partials. Only hooks and manifests are returned,\n\t// as partials are not used after renderer.Render. Empty manifests are also\n\t// removed here.\n\ths, manifests, err := releaseutil.SortManifests(files, caps.APIVersions, releaseutil.InstallOrder)\n\tif err != nil {\n\t\t// By catching parse errors here, we can prevent bogus releases from going\n\t\t// to Kubernetes.\n\t\t//\n\t\t// We return the files as a big blob of data to help the user debug parser\n\t\t// errors.\n\t\tfor name, content := range files {\n\t\t\tif strings.TrimSpace(content) == \"\" {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tfmt.Fprintf(b, \"---\\n# Source: %s\\n%s\\n\", name, content)\n\t\t}\n\t\treturn hs, b, \"\", err\n\t}\n\n\t// Aggregate all valid manifests into one big doc.\n\tfileWritten := make(map[string]bool)\n\n\tif includeCrds {\n\t\tfor _, crd := range ch.CRDObjects() {\n\t\t\tif outputDir == \"\" {\n\t\t\t\tfmt.Fprintf(b, \"---\\n# Source: %s\\n%s\\n\", crd.Name, string(crd.File.Data[:]))\n\t\t\t} else {\n\t\t\t\terr = writeToFile(outputDir, crd.Filename, string(crd.File.Data[:]), fileWritten[crd.Name])\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn hs, b, \"\", err\n\t\t\t\t}\n\t\t\t\tfileWritten[crd.Name] = true\n\t\t\t}\n\t\t}\n\t}\n\n\tfor _, m := range manifests {\n\t\tif outputDir == \"\" {\n\t\t\tfmt.Fprintf(b, \"---\\n# Source: %s\\n%s\\n\", m.Name, m.Content)\n\t\t} else {\n\t\t\tnewDir := outputDir\n\t\t\tif useReleaseName {\n\t\t\t\tnewDir = filepath.Join(outputDir, releaseName)\n\t\t\t}\n\t\t\t// NOTE: We do not have to worry about the post-renderer because\n\t\t\t// output dir is only used by `helm template`. In the next major\n\t\t\t// release, we should move this logic to template only as it is not\n\t\t\t// used by install or upgrade\n\t\t\terr = writeToFile(newDir, m.Name, m.Content, fileWritten[m.Name])\n\t\t\tif err != nil {\n\t\t\t\treturn hs, b, \"\", err\n\t\t\t}\n\t\t\tfileWritten[m.Name] = true\n\t\t}\n\t}\n\n\tif pr != nil {\n\t\tb, err = pr.Run(b)\n\t\tif err != nil {\n\t\t\treturn hs, b, notes, errors.Wrap(err, \"error while running post render on files\")\n\t\t}\n\t}\n\n\treturn hs, b, notes, nil\n}\n\n// RESTClientGetter gets the rest client\ntype RESTClientGetter interface {\n\tToRESTConfig() (*rest.Config, error)\n\tToDiscoveryClient() (discovery.CachedDiscoveryInterface, error)\n\tToRESTMapper() (meta.RESTMapper, error)\n}\n\n// DebugLog sets the logger that writes debug strings\ntype DebugLog func(format string, v ...interface{})\n\n// capabilities builds a Capabilities from discovery information.\nfunc (cfg *Configuration) getCapabilities() (*chartutil.Capabilities, error) {\n\tif cfg.Capabilities != nil {\n\t\treturn cfg.Capabilities, nil\n\t}\n\tdc, err := cfg.RESTClientGetter.ToDiscoveryClient()\n\tif err != nil {\n\t\treturn nil, errors.Wrap(err, \"could not get Kubernetes discovery client\")\n\t}\n\t// force a discovery cache invalidation to always fetch the latest server version/capabilities.\n\tdc.Invalidate()\n\tkubeVersion, err := dc.ServerVersion()\n\tif err != nil {\n\t\treturn nil, errors.Wrap(err, \"could not get server version from Kubernetes\")\n\t}\n\t// Issue #6361:\n\t// Client-Go emits an error when an API service is registered but unimplemented.\n\t// We trap that error here and print a warning. But since the discovery client continues\n\t// building the API object, it is correctly populated with all valid APIs.\n\t// See https://github.com/kubernetes/kubernetes/issues/72051#issuecomment-521157642\n\tapiVersions, err := GetVersionSet(dc)\n\tif err != nil {\n\t\tif discovery.IsGroupDiscoveryFailedError(err) {\n\t\t\tcfg.Log(\"WARNING: The Kubernetes server has an orphaned API service. Server reports: %s\", err)\n\t\t\tcfg.Log(\"WARNING: To fix this, kubectl delete apiservice <service-name>\")\n\t\t} else {\n\t\t\treturn nil, errors.Wrap(err, \"could not get apiVersions from Kubernetes\")\n\t\t}\n\t}\n\n\tcfg.Capabilities = &chartutil.Capabilities{\n\t\tAPIVersions: apiVersions,\n\t\tKubeVersion: chartutil.KubeVersion{\n\t\t\tVersion: kubeVersion.GitVersion,\n\t\t\tMajor:   kubeVersion.Major,\n\t\t\tMinor:   kubeVersion.Minor,\n\t\t},\n\t\tHelmVersion: chartutil.DefaultCapabilities.HelmVersion,\n\t}\n\treturn cfg.Capabilities, nil\n}\n\n// KubernetesClientSet creates a new kubernetes ClientSet based on the configuration\nfunc (cfg *Configuration) KubernetesClientSet() (kubernetes.Interface, error) {\n\tconf, err := cfg.RESTClientGetter.ToRESTConfig()\n\tif err != nil {\n\t\treturn nil, errors.Wrap(err, \"unable to generate config for kubernetes client\")\n\t}\n\n\treturn kubernetes.NewForConfig(conf)\n}\n\n// Now generates a timestamp\n//\n// If the configuration has a Timestamper on it, that will be used.\n// Otherwise, this will use time.Now().\nfunc (cfg *Configuration) Now() time.Time {\n\treturn Timestamper()\n}\n\nfunc (cfg *Configuration) releaseContent(name string, version int) (*release.Release, error) {\n\tif err := chartutil.ValidateReleaseName(name); err != nil {\n\t\treturn nil, errors.Errorf(\"releaseContent: Release name is invalid: %s\", name)\n\t}\n\n\tif version <= 0 {\n\t\treturn cfg.Releases.Last(name)\n\t}\n\n\treturn cfg.Releases.Get(name, version)\n}\n\n// GetVersionSet retrieves a set of available k8s API versions\nfunc GetVersionSet(client discovery.ServerResourcesInterface) (chartutil.VersionSet, error) {\n\tgroups, resources, err := client.ServerGroupsAndResources()\n\tif err != nil && !discovery.IsGroupDiscoveryFailedError(err) {\n\t\treturn chartutil.DefaultVersionSet, errors.Wrap(err, \"could not get apiVersions from Kubernetes\")\n\t}\n\n\t// FIXME: The Kubernetes test fixture for cli appears to always return nil\n\t// for calls to Discovery().ServerGroupsAndResources(). So in this case, we\n\t// return the default API list. This is also a safe value to return in any\n\t// other odd-ball case.\n\tif len(groups) == 0 && len(resources) == 0 {\n\t\treturn chartutil.DefaultVersionSet, nil\n\t}\n\n\tversionMap := make(map[string]interface{})\n\tversions := []string{}\n\n\t// Extract the groups\n\tfor _, g := range groups {\n\t\tfor _, gv := range g.Versions {\n\t\t\tversionMap[gv.GroupVersion] = struct{}{}\n\t\t}\n\t}\n\n\t// Extract the resources\n\tvar id string\n\tvar ok bool\n\tfor _, r := range resources {\n\t\tfor _, rl := range r.APIResources {\n\n\t\t\t// A Kind at a GroupVersion can show up more than once. We only want\n\t\t\t// it displayed once in the final output.\n\t\t\tid = path.Join(r.GroupVersion, rl.Kind)\n\t\t\tif _, ok = versionMap[id]; !ok {\n\t\t\t\tversionMap[id] = struct{}{}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Convert to a form that NewVersionSet can use\n\tfor k := range versionMap {\n\t\tversions = append(versions, k)\n\t}\n\n\treturn chartutil.VersionSet(versions), nil\n}\n\n// recordRelease with an update operation in case reuse has been set.\nfunc (cfg *Configuration) recordRelease(r *release.Release) {\n\tif err := cfg.Releases.Update(r); err != nil {\n\t\tcfg.Log(\"warning: Failed to update release %s: %s\", r.Name, err)\n\t}\n}\n\n// Init initializes the action configuration\nfunc (cfg *Configuration) Init(getter genericclioptions.RESTClientGetter, namespace, helmDriver string, log DebugLog) error {\n\tkc := kube.New(getter)\n\tkc.Log = log\n\n\tlazyClient := &lazyClient{\n\t\tnamespace: namespace,\n\t\tclientFn:  kc.Factory.KubernetesClientSet,\n\t}\n\n\tvar store *storage.Storage\n\tswitch helmDriver {\n\tcase \"secret\", \"secrets\", \"\":\n\t\td := driver.NewSecrets(newSecretClient(lazyClient))\n\t\td.Log = log\n\t\tstore = storage.Init(d)\n\tcase \"configmap\", \"configmaps\":\n\t\td := driver.NewConfigMaps(newConfigMapClient(lazyClient))\n\t\td.Log = log\n\t\tstore = storage.Init(d)\n\tcase \"memory\":\n\t\tvar d *driver.Memory\n\t\tif cfg.Releases != nil {\n\t\t\tif mem, ok := cfg.Releases.Driver.(*driver.Memory); ok {\n\t\t\t\t// This function can be called more than once (e.g., helm list --all-namespaces).\n\t\t\t\t// If a memory driver was already initialized, re-use it but set the possibly new namespace.\n\t\t\t\t// We re-use it in case some releases where already created in the existing memory driver.\n\t\t\t\td = mem\n\t\t\t}\n\t\t}\n\t\tif d == nil {\n\t\t\td = driver.NewMemory()\n\t\t}\n\t\td.SetNamespace(namespace)\n\t\tstore = storage.Init(d)\n\tcase \"sql\":\n\t\td, err := driver.NewSQL(\n\t\t\tos.Getenv(\"HELM_DRIVER_SQL_CONNECTION_STRING\"),\n\t\t\tlog,\n\t\t\tnamespace,\n\t\t)\n\t\tif err != nil {\n\t\t\tpanic(fmt.Sprintf(\"Unable to instantiate SQL driver: %v\", err))\n\t\t}\n\t\tstore = storage.Init(d)\n\tdefault:\n\t\t// Not sure what to do here.\n\t\tpanic(\"Unknown driver in HELM_DRIVER: \" + helmDriver)\n\t}\n\n\tcfg.RESTClientGetter = getter\n\tcfg.KubeClient = kc\n\tcfg.Releases = store\n\tcfg.Log = log\n\n\treturn nil\n}\n", "/*\nCopyright The Helm Authors.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\npackage action\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/url\"\n\t\"os\"\n\t\"path\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"sync\"\n\t\"text/template\"\n\t\"time\"\n\n\t\"github.com/Masterminds/sprig/v3\"\n\t\"github.com/pkg/errors\"\n\tv1 \"k8s.io/api/core/v1\"\n\tapierrors \"k8s.io/apimachinery/pkg/api/errors\"\n\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n\t\"k8s.io/cli-runtime/pkg/resource\"\n\t\"sigs.k8s.io/yaml\"\n\n\t\"helm.sh/helm/v3/pkg/chart\"\n\t\"helm.sh/helm/v3/pkg/chartutil\"\n\t\"helm.sh/helm/v3/pkg/cli\"\n\t\"helm.sh/helm/v3/pkg/downloader\"\n\t\"helm.sh/helm/v3/pkg/getter\"\n\t\"helm.sh/helm/v3/pkg/kube\"\n\tkubefake \"helm.sh/helm/v3/pkg/kube/fake\"\n\t\"helm.sh/helm/v3/pkg/postrender\"\n\t\"helm.sh/helm/v3/pkg/registry\"\n\t\"helm.sh/helm/v3/pkg/release\"\n\t\"helm.sh/helm/v3/pkg/releaseutil\"\n\t\"helm.sh/helm/v3/pkg/repo\"\n\t\"helm.sh/helm/v3/pkg/storage\"\n\t\"helm.sh/helm/v3/pkg/storage/driver\"\n)\n\n// NOTESFILE_SUFFIX that we want to treat special. It goes through the templating engine\n// but it's not a yaml file (resource) hence can't have hooks, etc. And the user actually\n// wants to see this file after rendering in the status command. However, it must be a suffix\n// since there can be filepath in front of it.\nconst notesFileSuffix = \"NOTES.txt\"\n\nconst defaultDirectoryPermission = 0755\n\n// Install performs an installation operation.\ntype Install struct {\n\tcfg *Configuration\n\n\tChartPathOptions\n\n\tClientOnly               bool\n\tForce                    bool\n\tCreateNamespace          bool\n\tDryRun                   bool\n\tDisableHooks             bool\n\tReplace                  bool\n\tWait                     bool\n\tWaitForJobs              bool\n\tDevel                    bool\n\tDependencyUpdate         bool\n\tTimeout                  time.Duration\n\tNamespace                string\n\tReleaseName              string\n\tGenerateName             bool\n\tNameTemplate             string\n\tDescription              string\n\tOutputDir                string\n\tAtomic                   bool\n\tSkipCRDs                 bool\n\tSubNotes                 bool\n\tDisableOpenAPIValidation bool\n\tIncludeCRDs              bool\n\t// KubeVersion allows specifying a custom kubernetes version to use and\n\t// APIVersions allows a manual set of supported API Versions to be passed\n\t// (for things like templating). These are ignored if ClientOnly is false\n\tKubeVersion *chartutil.KubeVersion\n\tAPIVersions chartutil.VersionSet\n\t// Used by helm template to render charts with .Release.IsUpgrade. Ignored if Dry-Run is false\n\tIsUpgrade bool\n\t// Used by helm template to add the release as part of OutputDir path\n\t// OutputDir/<ReleaseName>\n\tUseReleaseName bool\n\tPostRenderer   postrender.PostRenderer\n\t// Lock to control raceconditions when the process receives a SIGTERM\n\tLock sync.Mutex\n}\n\n// ChartPathOptions captures common options used for controlling chart paths\ntype ChartPathOptions struct {\n\tCaFile                string // --ca-file\n\tCertFile              string // --cert-file\n\tKeyFile               string // --key-file\n\tInsecureSkipTLSverify bool   // --insecure-skip-verify\n\tKeyring               string // --keyring\n\tPassword              string // --password\n\tPassCredentialsAll    bool   // --pass-credentials\n\tRepoURL               string // --repo\n\tUsername              string // --username\n\tVerify                bool   // --verify\n\tVersion               string // --version\n\n\t// registryClient provides a registry client but is not added with\n\t// options from a flag\n\tregistryClient *registry.Client\n}\n\n// NewInstall creates a new Install object with the given configuration.\nfunc NewInstall(cfg *Configuration) *Install {\n\tin := &Install{\n\t\tcfg: cfg,\n\t}\n\tin.ChartPathOptions.registryClient = cfg.RegistryClient\n\n\treturn in\n}\n\nfunc (i *Install) installCRDs(crds []chart.CRD) error {\n\t// We do these one file at a time in the order they were read.\n\ttotalItems := []*resource.Info{}\n\tfor _, obj := range crds {\n\t\t// Read in the resources\n\t\tres, err := i.cfg.KubeClient.Build(bytes.NewBuffer(obj.File.Data), false)\n\t\tif err != nil {\n\t\t\treturn errors.Wrapf(err, \"failed to install CRD %s\", obj.Name)\n\t\t}\n\n\t\t// Send them to Kube\n\t\tif _, err := i.cfg.KubeClient.Create(res); err != nil {\n\t\t\t// If the error is CRD already exists, continue.\n\t\t\tif apierrors.IsAlreadyExists(err) {\n\t\t\t\tcrdName := res[0].Name\n\t\t\t\ti.cfg.Log(\"CRD %s is already present. Skipping.\", crdName)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn errors.Wrapf(err, \"failed to install CRD %s\", obj.Name)\n\t\t}\n\t\ttotalItems = append(totalItems, res...)\n\t}\n\tif len(totalItems) > 0 {\n\t\t// Invalidate the local cache, since it will not have the new CRDs\n\t\t// present.\n\t\tdiscoveryClient, err := i.cfg.RESTClientGetter.ToDiscoveryClient()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ti.cfg.Log(\"Clearing discovery cache\")\n\t\tdiscoveryClient.Invalidate()\n\t\t// Give time for the CRD to be recognized.\n\n\t\tif err := i.cfg.KubeClient.Wait(totalItems, 60*time.Second); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Make sure to force a rebuild of the cache.\n\t\tdiscoveryClient.ServerGroups()\n\t}\n\treturn nil\n}\n\n// Run executes the installation\n//\n// If DryRun is set to true, this will prepare the release, but not install it\n\nfunc (i *Install) Run(chrt *chart.Chart, vals map[string]interface{}) (*release.Release, error) {\n\tctx := context.Background()\n\treturn i.RunWithContext(ctx, chrt, vals)\n}\n\n// Run executes the installation with Context\nfunc (i *Install) RunWithContext(ctx context.Context, chrt *chart.Chart, vals map[string]interface{}) (*release.Release, error) {\n\t// Check reachability of cluster unless in client-only mode (e.g. `helm template` without `--validate`)\n\tif !i.ClientOnly {\n\t\tif err := i.cfg.KubeClient.IsReachable(); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\tif err := i.availableName(); err != nil {\n\t\treturn nil, err\n\t}\n\n\tif err := chartutil.ProcessDependencies(chrt, vals); err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Pre-install anything in the crd/ directory. We do this before Helm\n\t// contacts the upstream server and builds the capabilities object.\n\tif crds := chrt.CRDObjects(); !i.ClientOnly && !i.SkipCRDs && len(crds) > 0 {\n\t\t// On dry run, bail here\n\t\tif i.DryRun {\n\t\t\ti.cfg.Log(\"WARNING: This chart or one of its subcharts contains CRDs. Rendering may fail or contain inaccuracies.\")\n\t\t} else if err := i.installCRDs(crds); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\tif i.ClientOnly {\n\t\t// Add mock objects in here so it doesn't use Kube API server\n\t\t// NOTE(bacongobbler): used for `helm template`\n\t\ti.cfg.Capabilities = chartutil.DefaultCapabilities.Copy()\n\t\tif i.KubeVersion != nil {\n\t\t\ti.cfg.Capabilities.KubeVersion = *i.KubeVersion\n\t\t}\n\t\ti.cfg.Capabilities.APIVersions = append(i.cfg.Capabilities.APIVersions, i.APIVersions...)\n\t\ti.cfg.KubeClient = &kubefake.PrintingKubeClient{Out: ioutil.Discard}\n\n\t\tmem := driver.NewMemory()\n\t\tmem.SetNamespace(i.Namespace)\n\t\ti.cfg.Releases = storage.Init(mem)\n\t} else if !i.ClientOnly && len(i.APIVersions) > 0 {\n\t\ti.cfg.Log(\"API Version list given outside of client only mode, this list will be ignored\")\n\t}\n\n\t// Make sure if Atomic is set, that wait is set as well. This makes it so\n\t// the user doesn't have to specify both\n\ti.Wait = i.Wait || i.Atomic\n\n\tcaps, err := i.cfg.getCapabilities()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// special case for helm template --is-upgrade\n\tisUpgrade := i.IsUpgrade && i.DryRun\n\toptions := chartutil.ReleaseOptions{\n\t\tName:      i.ReleaseName,\n\t\tNamespace: i.Namespace,\n\t\tRevision:  1,\n\t\tIsInstall: !isUpgrade,\n\t\tIsUpgrade: isUpgrade,\n\t}\n\tvaluesToRender, err := chartutil.ToRenderValues(chrt, vals, options, caps)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\trel := i.createRelease(chrt, vals)\n\n\tvar manifestDoc *bytes.Buffer\n\trel.Hooks, manifestDoc, rel.Info.Notes, err = i.cfg.renderResources(chrt, valuesToRender, i.ReleaseName, i.OutputDir, i.SubNotes, i.UseReleaseName, i.IncludeCRDs, i.PostRenderer, i.DryRun)\n\t// Even for errors, attach this if available\n\tif manifestDoc != nil {\n\t\trel.Manifest = manifestDoc.String()\n\t}\n\t// Check error from render\n\tif err != nil {\n\t\trel.SetStatus(release.StatusFailed, fmt.Sprintf(\"failed to render resource: %s\", err.Error()))\n\t\t// Return a release with partial data so that the client can show debugging information.\n\t\treturn rel, err\n\t}\n\n\t// Mark this release as in-progress\n\trel.SetStatus(release.StatusPendingInstall, \"Initial install underway\")\n\n\tvar toBeAdopted kube.ResourceList\n\tresources, err := i.cfg.KubeClient.Build(bytes.NewBufferString(rel.Manifest), !i.DisableOpenAPIValidation)\n\tif err != nil {\n\t\treturn nil, errors.Wrap(err, \"unable to build kubernetes objects from release manifest\")\n\t}\n\n\t// It is safe to use \"force\" here because these are resources currently rendered by the chart.\n\terr = resources.Visit(setMetadataVisitor(rel.Name, rel.Namespace, true))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Install requires an extra validation step of checking that resources\n\t// don't already exist before we actually create resources. If we continue\n\t// forward and create the release object with resources that already exist,\n\t// we'll end up in a state where we will delete those resources upon\n\t// deleting the release because the manifest will be pointing at that\n\t// resource\n\tif !i.ClientOnly && !isUpgrade && len(resources) > 0 {\n\t\ttoBeAdopted, err = existingResourceConflict(resources, rel.Name, rel.Namespace)\n\t\tif err != nil {\n\t\t\treturn nil, errors.Wrap(err, \"rendered manifests contain a resource that already exists. Unable to continue with install\")\n\t\t}\n\t}\n\n\t// Bail out here if it is a dry run\n\tif i.DryRun {\n\t\trel.Info.Description = \"Dry run complete\"\n\t\treturn rel, nil\n\t}\n\n\tif i.CreateNamespace {\n\t\tns := &v1.Namespace{\n\t\t\tTypeMeta: metav1.TypeMeta{\n\t\t\t\tAPIVersion: \"v1\",\n\t\t\t\tKind:       \"Namespace\",\n\t\t\t},\n\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\tName: i.Namespace,\n\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\"name\": i.Namespace,\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\t\tbuf, err := yaml.Marshal(ns)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tresourceList, err := i.cfg.KubeClient.Build(bytes.NewBuffer(buf), true)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif _, err := i.cfg.KubeClient.Create(resourceList); err != nil && !apierrors.IsAlreadyExists(err) {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\t// If Replace is true, we need to supercede the last release.\n\tif i.Replace {\n\t\tif err := i.replaceRelease(rel); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\t// Store the release in history before continuing (new in Helm 3). We always know\n\t// that this is a create operation.\n\tif err := i.cfg.Releases.Create(rel); err != nil {\n\t\t// We could try to recover gracefully here, but since nothing has been installed\n\t\t// yet, this is probably safer than trying to continue when we know storage is\n\t\t// not working.\n\t\treturn rel, err\n\t}\n\trChan := make(chan resultMessage)\n\tdoneChan := make(chan struct{})\n\tdefer close(doneChan)\n\tgo i.performInstall(rChan, rel, toBeAdopted, resources)\n\tgo i.handleContext(ctx, rChan, doneChan, rel)\n\tresult := <-rChan\n\t//start preformInstall go routine\n\treturn result.r, result.e\n}\n\nfunc (i *Install) performInstall(c chan<- resultMessage, rel *release.Release, toBeAdopted kube.ResourceList, resources kube.ResourceList) {\n\n\t// pre-install hooks\n\tif !i.DisableHooks {\n\t\tif err := i.cfg.execHook(rel, release.HookPreInstall, i.Timeout); err != nil {\n\t\t\ti.reportToRun(c, rel, fmt.Errorf(\"failed pre-install: %s\", err))\n\t\t\treturn\n\t\t}\n\t}\n\n\t// At this point, we can do the install. Note that before we were detecting whether to\n\t// do an update, but it's not clear whether we WANT to do an update if the re-use is set\n\t// to true, since that is basically an upgrade operation.\n\tif len(toBeAdopted) == 0 && len(resources) > 0 {\n\t\tif _, err := i.cfg.KubeClient.Create(resources); err != nil {\n\t\t\ti.reportToRun(c, rel, err)\n\t\t\treturn\n\t\t}\n\t} else if len(resources) > 0 {\n\t\tif _, err := i.cfg.KubeClient.Update(toBeAdopted, resources, i.Force); err != nil {\n\t\t\ti.reportToRun(c, rel, err)\n\t\t\treturn\n\t\t}\n\t}\n\n\tif i.Wait {\n\t\tif i.WaitForJobs {\n\t\t\tif err := i.cfg.KubeClient.WaitWithJobs(resources, i.Timeout); err != nil {\n\t\t\t\ti.reportToRun(c, rel, err)\n\t\t\t\treturn\n\t\t\t}\n\t\t} else {\n\t\t\tif err := i.cfg.KubeClient.Wait(resources, i.Timeout); err != nil {\n\t\t\t\ti.reportToRun(c, rel, err)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}\n\n\tif !i.DisableHooks {\n\t\tif err := i.cfg.execHook(rel, release.HookPostInstall, i.Timeout); err != nil {\n\t\t\ti.reportToRun(c, rel, fmt.Errorf(\"failed post-install: %s\", err))\n\t\t\treturn\n\t\t}\n\t}\n\n\tif len(i.Description) > 0 {\n\t\trel.SetStatus(release.StatusDeployed, i.Description)\n\t} else {\n\t\trel.SetStatus(release.StatusDeployed, \"Install complete\")\n\t}\n\n\t// This is a tricky case. The release has been created, but the result\n\t// cannot be recorded. The truest thing to tell the user is that the\n\t// release was created. However, the user will not be able to do anything\n\t// further with this release.\n\t//\n\t// One possible strategy would be to do a timed retry to see if we can get\n\t// this stored in the future.\n\tif err := i.recordRelease(rel); err != nil {\n\t\ti.cfg.Log(\"failed to record the release: %s\", err)\n\t}\n\n\ti.reportToRun(c, rel, nil)\n}\nfunc (i *Install) handleContext(ctx context.Context, c chan<- resultMessage, done chan struct{}, rel *release.Release) {\n\tselect {\n\tcase <-ctx.Done():\n\t\terr := ctx.Err()\n\t\ti.reportToRun(c, rel, err)\n\tcase <-done:\n\t\treturn\n\t}\n}\nfunc (i *Install) reportToRun(c chan<- resultMessage, rel *release.Release, err error) {\n\ti.Lock.Lock()\n\tif err != nil {\n\t\trel, err = i.failRelease(rel, err)\n\t}\n\tc <- resultMessage{r: rel, e: err}\n\ti.Lock.Unlock()\n}\nfunc (i *Install) failRelease(rel *release.Release, err error) (*release.Release, error) {\n\trel.SetStatus(release.StatusFailed, fmt.Sprintf(\"Release %q failed: %s\", i.ReleaseName, err.Error()))\n\tif i.Atomic {\n\t\ti.cfg.Log(\"Install failed and atomic is set, uninstalling release\")\n\t\tuninstall := NewUninstall(i.cfg)\n\t\tuninstall.DisableHooks = i.DisableHooks\n\t\tuninstall.KeepHistory = false\n\t\tuninstall.Timeout = i.Timeout\n\t\tif _, uninstallErr := uninstall.Run(i.ReleaseName); uninstallErr != nil {\n\t\t\treturn rel, errors.Wrapf(uninstallErr, \"an error occurred while uninstalling the release. original install error: %s\", err)\n\t\t}\n\t\treturn rel, errors.Wrapf(err, \"release %s failed, and has been uninstalled due to atomic being set\", i.ReleaseName)\n\t}\n\ti.recordRelease(rel) // Ignore the error, since we have another error to deal with.\n\treturn rel, err\n}\n\n// availableName tests whether a name is available\n//\n// Roughly, this will return an error if name is\n//\n//\t- empty\n//\t- too long\n//\t- already in use, and not deleted\n//\t- used by a deleted release, and i.Replace is false\nfunc (i *Install) availableName() error {\n\tstart := i.ReleaseName\n\n\tif err := chartutil.ValidateReleaseName(start); err != nil {\n\t\treturn errors.Wrapf(err, \"release name %q\", start)\n\t}\n\tif i.DryRun {\n\t\treturn nil\n\t}\n\n\th, err := i.cfg.Releases.History(start)\n\tif err != nil || len(h) < 1 {\n\t\treturn nil\n\t}\n\treleaseutil.Reverse(h, releaseutil.SortByRevision)\n\trel := h[0]\n\n\tif st := rel.Info.Status; i.Replace && (st == release.StatusUninstalled || st == release.StatusFailed) {\n\t\treturn nil\n\t}\n\treturn errors.New(\"cannot re-use a name that is still in use\")\n}\n\n// createRelease creates a new release object\nfunc (i *Install) createRelease(chrt *chart.Chart, rawVals map[string]interface{}) *release.Release {\n\tts := i.cfg.Now()\n\treturn &release.Release{\n\t\tName:      i.ReleaseName,\n\t\tNamespace: i.Namespace,\n\t\tChart:     chrt,\n\t\tConfig:    rawVals,\n\t\tInfo: &release.Info{\n\t\t\tFirstDeployed: ts,\n\t\t\tLastDeployed:  ts,\n\t\t\tStatus:        release.StatusUnknown,\n\t\t},\n\t\tVersion: 1,\n\t}\n}\n\n// recordRelease with an update operation in case reuse has been set.\nfunc (i *Install) recordRelease(r *release.Release) error {\n\t// This is a legacy function which has been reduced to a oneliner. Could probably\n\t// refactor it out.\n\treturn i.cfg.Releases.Update(r)\n}\n\n// replaceRelease replaces an older release with this one\n//\n// This allows us to re-use names by superseding an existing release with a new one\nfunc (i *Install) replaceRelease(rel *release.Release) error {\n\thist, err := i.cfg.Releases.History(rel.Name)\n\tif err != nil || len(hist) == 0 {\n\t\t// No releases exist for this name, so we can return early\n\t\treturn nil\n\t}\n\n\treleaseutil.Reverse(hist, releaseutil.SortByRevision)\n\tlast := hist[0]\n\n\t// Update version to the next available\n\trel.Version = last.Version + 1\n\n\t// Do not change the status of a failed release.\n\tif last.Info.Status == release.StatusFailed {\n\t\treturn nil\n\t}\n\n\t// For any other status, mark it as superseded and store the old record\n\tlast.SetStatus(release.StatusSuperseded, \"superseded by new release\")\n\treturn i.recordRelease(last)\n}\n\n// write the <data> to <output-dir>/<name>. <append> controls if the file is created or content will be appended\nfunc writeToFile(outputDir string, name string, data string, append bool) error {\n\toutfileName := strings.Join([]string{outputDir, name}, string(filepath.Separator))\n\n\terr := ensureDirectoryForFile(outfileName)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tf, err := createOrOpenFile(outfileName, append)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tdefer f.Close()\n\n\t_, err = f.WriteString(fmt.Sprintf(\"---\\n# Source: %s\\n%s\\n\", name, data))\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfmt.Printf(\"wrote %s\\n\", outfileName)\n\treturn nil\n}\n\nfunc createOrOpenFile(filename string, append bool) (*os.File, error) {\n\tif append {\n\t\treturn os.OpenFile(filename, os.O_APPEND|os.O_WRONLY, 0600)\n\t}\n\treturn os.Create(filename)\n}\n\n// check if the directory exists to create file. creates if don't exists\nfunc ensureDirectoryForFile(file string) error {\n\tbaseDir := path.Dir(file)\n\t_, err := os.Stat(baseDir)\n\tif err != nil && !os.IsNotExist(err) {\n\t\treturn err\n\t}\n\n\treturn os.MkdirAll(baseDir, defaultDirectoryPermission)\n}\n\n// NameAndChart returns the name and chart that should be used.\n//\n// This will read the flags and handle name generation if necessary.\nfunc (i *Install) NameAndChart(args []string) (string, string, error) {\n\tflagsNotSet := func() error {\n\t\tif i.GenerateName {\n\t\t\treturn errors.New(\"cannot set --generate-name and also specify a name\")\n\t\t}\n\t\tif i.NameTemplate != \"\" {\n\t\t\treturn errors.New(\"cannot set --name-template and also specify a name\")\n\t\t}\n\t\treturn nil\n\t}\n\n\tif len(args) > 2 {\n\t\treturn args[0], args[1], errors.Errorf(\"expected at most two arguments, unexpected arguments: %v\", strings.Join(args[2:], \", \"))\n\t}\n\n\tif len(args) == 2 {\n\t\treturn args[0], args[1], flagsNotSet()\n\t}\n\n\tif i.NameTemplate != \"\" {\n\t\tname, err := TemplateName(i.NameTemplate)\n\t\treturn name, args[0], err\n\t}\n\n\tif i.ReleaseName != \"\" {\n\t\treturn i.ReleaseName, args[0], nil\n\t}\n\n\tif !i.GenerateName {\n\t\treturn \"\", args[0], errors.New(\"must either provide a name or specify --generate-name\")\n\t}\n\n\tbase := filepath.Base(args[0])\n\tif base == \".\" || base == \"\" {\n\t\tbase = \"chart\"\n\t}\n\t// if present, strip out the file extension from the name\n\tif idx := strings.Index(base, \".\"); idx != -1 {\n\t\tbase = base[0:idx]\n\t}\n\n\treturn fmt.Sprintf(\"%s-%d\", base, time.Now().Unix()), args[0], nil\n}\n\n// TemplateName renders a name template, returning the name or an error.\nfunc TemplateName(nameTemplate string) (string, error) {\n\tif nameTemplate == \"\" {\n\t\treturn \"\", nil\n\t}\n\n\tt, err := template.New(\"name-template\").Funcs(sprig.TxtFuncMap()).Parse(nameTemplate)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tvar b bytes.Buffer\n\tif err := t.Execute(&b, nil); err != nil {\n\t\treturn \"\", err\n\t}\n\n\treturn b.String(), nil\n}\n\n// CheckDependencies checks the dependencies for a chart.\nfunc CheckDependencies(ch *chart.Chart, reqs []*chart.Dependency) error {\n\tvar missing []string\n\nOUTER:\n\tfor _, r := range reqs {\n\t\tfor _, d := range ch.Dependencies() {\n\t\t\tif d.Name() == r.Name {\n\t\t\t\tcontinue OUTER\n\t\t\t}\n\t\t}\n\t\tmissing = append(missing, r.Name)\n\t}\n\n\tif len(missing) > 0 {\n\t\treturn errors.Errorf(\"found in Chart.yaml, but missing in charts/ directory: %s\", strings.Join(missing, \", \"))\n\t}\n\treturn nil\n}\n\n// LocateChart looks for a chart directory in known places, and returns either the full path or an error.\n//\n// This does not ensure that the chart is well-formed; only that the requested filename exists.\n//\n// Order of resolution:\n// - relative to current working directory\n// - if path is absolute or begins with '.', error out here\n// - URL\n//\n// If 'verify' was set on ChartPathOptions, this will attempt to also verify the chart.\nfunc (c *ChartPathOptions) LocateChart(name string, settings *cli.EnvSettings) (string, error) {\n\t// If there is no registry client and the name is in an OCI registry return\n\t// an error and a lookup will not occur.\n\tif registry.IsOCI(name) && c.registryClient == nil {\n\t\treturn \"\", fmt.Errorf(\"unable to lookup chart %q, missing registry client\", name)\n\t}\n\n\tname = strings.TrimSpace(name)\n\tversion := strings.TrimSpace(c.Version)\n\n\tif _, err := os.Stat(name); err == nil {\n\t\tabs, err := filepath.Abs(name)\n\t\tif err != nil {\n\t\t\treturn abs, err\n\t\t}\n\t\tif c.Verify {\n\t\t\tif _, err := downloader.VerifyChart(abs, c.Keyring); err != nil {\n\t\t\t\treturn \"\", err\n\t\t\t}\n\t\t}\n\t\treturn abs, nil\n\t}\n\tif filepath.IsAbs(name) || strings.HasPrefix(name, \".\") {\n\t\treturn name, errors.Errorf(\"path %q not found\", name)\n\t}\n\n\tdl := downloader.ChartDownloader{\n\t\tOut:     os.Stdout,\n\t\tKeyring: c.Keyring,\n\t\tGetters: getter.All(settings),\n\t\tOptions: []getter.Option{\n\t\t\tgetter.WithPassCredentialsAll(c.PassCredentialsAll),\n\t\t\tgetter.WithTLSClientConfig(c.CertFile, c.KeyFile, c.CaFile),\n\t\t\tgetter.WithInsecureSkipVerifyTLS(c.InsecureSkipTLSverify),\n\t\t},\n\t\tRepositoryConfig: settings.RepositoryConfig,\n\t\tRepositoryCache:  settings.RepositoryCache,\n\t\tRegistryClient:   c.registryClient,\n\t}\n\n\tif registry.IsOCI(name) {\n\t\tdl.Options = append(dl.Options, getter.WithRegistryClient(c.registryClient))\n\t}\n\n\tif c.Verify {\n\t\tdl.Verify = downloader.VerifyAlways\n\t}\n\tif c.RepoURL != \"\" {\n\t\tchartURL, err := repo.FindChartInAuthAndTLSAndPassRepoURL(c.RepoURL, c.Username, c.Password, name, version,\n\t\t\tc.CertFile, c.KeyFile, c.CaFile, c.InsecureSkipTLSverify, c.PassCredentialsAll, getter.All(settings))\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t\tname = chartURL\n\n\t\t// Only pass the user/pass on when the user has said to or when the\n\t\t// location of the chart repo and the chart are the same domain.\n\t\tu1, err := url.Parse(c.RepoURL)\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t\tu2, err := url.Parse(chartURL)\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\n\t\t// Host on URL (returned from url.Parse) contains the port if present.\n\t\t// This check ensures credentials are not passed between different\n\t\t// services on different ports.\n\t\tif c.PassCredentialsAll || (u1.Scheme == u2.Scheme && u1.Host == u2.Host) {\n\t\t\tdl.Options = append(dl.Options, getter.WithBasicAuth(c.Username, c.Password))\n\t\t} else {\n\t\t\tdl.Options = append(dl.Options, getter.WithBasicAuth(\"\", \"\"))\n\t\t}\n\t} else {\n\t\tdl.Options = append(dl.Options, getter.WithBasicAuth(c.Username, c.Password))\n\t}\n\n\tif err := os.MkdirAll(settings.RepositoryCache, 0755); err != nil {\n\t\treturn \"\", err\n\t}\n\n\tfilename, _, err := dl.DownloadTo(name, version, settings.RepositoryCache)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tlname, err := filepath.Abs(filename)\n\tif err != nil {\n\t\treturn filename, err\n\t}\n\treturn lname, nil\n}\n", "/*\nCopyright The Helm Authors.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\npackage action\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"fmt\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/pkg/errors\"\n\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n\t\"k8s.io/cli-runtime/pkg/resource\"\n\n\t\"helm.sh/helm/v3/pkg/chart\"\n\t\"helm.sh/helm/v3/pkg/chartutil\"\n\t\"helm.sh/helm/v3/pkg/kube\"\n\t\"helm.sh/helm/v3/pkg/postrender\"\n\t\"helm.sh/helm/v3/pkg/release\"\n\t\"helm.sh/helm/v3/pkg/releaseutil\"\n\t\"helm.sh/helm/v3/pkg/storage/driver\"\n)\n\n// Upgrade is the action for upgrading releases.\n//\n// It provides the implementation of 'helm upgrade'.\ntype Upgrade struct {\n\tcfg *Configuration\n\n\tChartPathOptions\n\n\t// Install is a purely informative flag that indicates whether this upgrade was done in \"install\" mode.\n\t//\n\t// Applications may use this to determine whether this Upgrade operation was done as part of a\n\t// pure upgrade (Upgrade.Install == false) or as part of an install-or-upgrade operation\n\t// (Upgrade.Install == true).\n\t//\n\t// Setting this to `true` will NOT cause `Upgrade` to perform an install if the release does not exist.\n\t// That process must be handled by creating an Install action directly. See cmd/upgrade.go for an\n\t// example of how this flag is used.\n\tInstall bool\n\t// Devel indicates that the operation is done in devel mode.\n\tDevel bool\n\t// Namespace is the namespace in which this operation should be performed.\n\tNamespace string\n\t// SkipCRDs skips installing CRDs when install flag is enabled during upgrade\n\tSkipCRDs bool\n\t// Timeout is the timeout for this operation\n\tTimeout time.Duration\n\t// Wait determines whether the wait operation should be performed after the upgrade is requested.\n\tWait bool\n\t// WaitForJobs determines whether the wait operation for the Jobs should be performed after the upgrade is requested.\n\tWaitForJobs bool\n\t// DisableHooks disables hook processing if set to true.\n\tDisableHooks bool\n\t// DryRun controls whether the operation is prepared, but not executed.\n\t// If `true`, the upgrade is prepared but not performed.\n\tDryRun bool\n\t// Force will, if set to `true`, ignore certain warnings and perform the upgrade anyway.\n\t//\n\t// This should be used with caution.\n\tForce bool\n\t// ResetValues will reset the values to the chart's built-ins rather than merging with existing.\n\tResetValues bool\n\t// ReuseValues will re-use the user's last supplied values.\n\tReuseValues bool\n\t// Recreate will (if true) recreate pods after a rollback.\n\tRecreate bool\n\t// MaxHistory limits the maximum number of revisions saved per release\n\tMaxHistory int\n\t// Atomic, if true, will roll back on failure.\n\tAtomic bool\n\t// CleanupOnFail will, if true, cause the upgrade to delete newly-created resources on a failed update.\n\tCleanupOnFail bool\n\t// SubNotes determines whether sub-notes are rendered in the chart.\n\tSubNotes bool\n\t// Description is the description of this operation\n\tDescription string\n\t// PostRender is an optional post-renderer\n\t//\n\t// If this is non-nil, then after templates are rendered, they will be sent to the\n\t// post renderer before sending to the Kubernetes API server.\n\tPostRenderer postrender.PostRenderer\n\t// DisableOpenAPIValidation controls whether OpenAPI validation is enforced.\n\tDisableOpenAPIValidation bool\n\t// Get missing dependencies\n\tDependencyUpdate bool\n\t// Lock to control raceconditions when the process receives a SIGTERM\n\tLock sync.Mutex\n}\n\ntype resultMessage struct {\n\tr *release.Release\n\te error\n}\n\n// NewUpgrade creates a new Upgrade object with the given configuration.\nfunc NewUpgrade(cfg *Configuration) *Upgrade {\n\tup := &Upgrade{\n\t\tcfg: cfg,\n\t}\n\tup.ChartPathOptions.registryClient = cfg.RegistryClient\n\n\treturn up\n}\n\n// Run executes the upgrade on the given release.\nfunc (u *Upgrade) Run(name string, chart *chart.Chart, vals map[string]interface{}) (*release.Release, error) {\n\tctx := context.Background()\n\treturn u.RunWithContext(ctx, name, chart, vals)\n}\n\n// RunWithContext executes the upgrade on the given release with context.\nfunc (u *Upgrade) RunWithContext(ctx context.Context, name string, chart *chart.Chart, vals map[string]interface{}) (*release.Release, error) {\n\tif err := u.cfg.KubeClient.IsReachable(); err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Make sure if Atomic is set, that wait is set as well. This makes it so\n\t// the user doesn't have to specify both\n\tu.Wait = u.Wait || u.Atomic\n\n\tif err := chartutil.ValidateReleaseName(name); err != nil {\n\t\treturn nil, errors.Errorf(\"release name is invalid: %s\", name)\n\t}\n\tu.cfg.Log(\"preparing upgrade for %s\", name)\n\tcurrentRelease, upgradedRelease, err := u.prepareUpgrade(name, chart, vals)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tu.cfg.Releases.MaxHistory = u.MaxHistory\n\n\tu.cfg.Log(\"performing update for %s\", name)\n\tres, err := u.performUpgrade(ctx, currentRelease, upgradedRelease)\n\tif err != nil {\n\t\treturn res, err\n\t}\n\n\tif !u.DryRun {\n\t\tu.cfg.Log(\"updating status for upgraded release for %s\", name)\n\t\tif err := u.cfg.Releases.Update(upgradedRelease); err != nil {\n\t\t\treturn res, err\n\t\t}\n\t}\n\n\treturn res, nil\n}\n\n// prepareUpgrade builds an upgraded release for an upgrade operation.\nfunc (u *Upgrade) prepareUpgrade(name string, chart *chart.Chart, vals map[string]interface{}) (*release.Release, *release.Release, error) {\n\tif chart == nil {\n\t\treturn nil, nil, errMissingChart\n\t}\n\n\t// finds the last non-deleted release with the given name\n\tlastRelease, err := u.cfg.Releases.Last(name)\n\tif err != nil {\n\t\t// to keep existing behavior of returning the \"%q has no deployed releases\" error when an existing release does not exist\n\t\tif errors.Is(err, driver.ErrReleaseNotFound) {\n\t\t\treturn nil, nil, driver.NewErrNoDeployedReleases(name)\n\t\t}\n\t\treturn nil, nil, err\n\t}\n\n\t// Concurrent `helm upgrade`s will either fail here with `errPending` or when creating the release with \"already exists\". This should act as a pessimistic lock.\n\tif lastRelease.Info.Status.IsPending() {\n\t\treturn nil, nil, errPending\n\t}\n\n\tvar currentRelease *release.Release\n\tif lastRelease.Info.Status == release.StatusDeployed {\n\t\t// no need to retrieve the last deployed release from storage as the last release is deployed\n\t\tcurrentRelease = lastRelease\n\t} else {\n\t\t// finds the deployed release with the given name\n\t\tcurrentRelease, err = u.cfg.Releases.Deployed(name)\n\t\tif err != nil {\n\t\t\tif errors.Is(err, driver.ErrNoDeployedReleases) &&\n\t\t\t\t(lastRelease.Info.Status == release.StatusFailed || lastRelease.Info.Status == release.StatusSuperseded) {\n\t\t\t\tcurrentRelease = lastRelease\n\t\t\t} else {\n\t\t\t\treturn nil, nil, err\n\t\t\t}\n\t\t}\n\t}\n\n\t// determine if values will be reused\n\tvals, err = u.reuseValues(chart, currentRelease, vals)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tif err := chartutil.ProcessDependencies(chart, vals); err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\t// Increment revision count. This is passed to templates, and also stored on\n\t// the release object.\n\trevision := lastRelease.Version + 1\n\n\toptions := chartutil.ReleaseOptions{\n\t\tName:      name,\n\t\tNamespace: currentRelease.Namespace,\n\t\tRevision:  revision,\n\t\tIsUpgrade: true,\n\t}\n\n\tcaps, err := u.cfg.getCapabilities()\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tvaluesToRender, err := chartutil.ToRenderValues(chart, vals, options, caps)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\thooks, manifestDoc, notesTxt, err := u.cfg.renderResources(chart, valuesToRender, \"\", \"\", u.SubNotes, false, false, u.PostRenderer, u.DryRun)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\t// Store an upgraded release.\n\tupgradedRelease := &release.Release{\n\t\tName:      name,\n\t\tNamespace: currentRelease.Namespace,\n\t\tChart:     chart,\n\t\tConfig:    vals,\n\t\tInfo: &release.Info{\n\t\t\tFirstDeployed: currentRelease.Info.FirstDeployed,\n\t\t\tLastDeployed:  Timestamper(),\n\t\t\tStatus:        release.StatusPendingUpgrade,\n\t\t\tDescription:   \"Preparing upgrade\", // This should be overwritten later.\n\t\t},\n\t\tVersion:  revision,\n\t\tManifest: manifestDoc.String(),\n\t\tHooks:    hooks,\n\t}\n\n\tif len(notesTxt) > 0 {\n\t\tupgradedRelease.Info.Notes = notesTxt\n\t}\n\terr = validateManifest(u.cfg.KubeClient, manifestDoc.Bytes(), !u.DisableOpenAPIValidation)\n\treturn currentRelease, upgradedRelease, err\n}\n\nfunc (u *Upgrade) performUpgrade(ctx context.Context, originalRelease, upgradedRelease *release.Release) (*release.Release, error) {\n\tcurrent, err := u.cfg.KubeClient.Build(bytes.NewBufferString(originalRelease.Manifest), false)\n\tif err != nil {\n\t\t// Checking for removed Kubernetes API error so can provide a more informative error message to the user\n\t\t// Ref: https://github.com/helm/helm/issues/7219\n\t\tif strings.Contains(err.Error(), \"unable to recognize \\\"\\\": no matches for kind\") {\n\t\t\treturn upgradedRelease, errors.Wrap(err, \"current release manifest contains removed kubernetes api(s) for this \"+\n\t\t\t\t\"kubernetes version and it is therefore unable to build the kubernetes \"+\n\t\t\t\t\"objects for performing the diff. error from kubernetes\")\n\t\t}\n\t\treturn upgradedRelease, errors.Wrap(err, \"unable to build kubernetes objects from current release manifest\")\n\t}\n\ttarget, err := u.cfg.KubeClient.Build(bytes.NewBufferString(upgradedRelease.Manifest), !u.DisableOpenAPIValidation)\n\tif err != nil {\n\t\treturn upgradedRelease, errors.Wrap(err, \"unable to build kubernetes objects from new release manifest\")\n\t}\n\n\t// It is safe to use force only on target because these are resources currently rendered by the chart.\n\terr = target.Visit(setMetadataVisitor(upgradedRelease.Name, upgradedRelease.Namespace, true))\n\tif err != nil {\n\t\treturn upgradedRelease, err\n\t}\n\n\t// Do a basic diff using gvk + name to figure out what new resources are being created so we can validate they don't already exist\n\texistingResources := make(map[string]bool)\n\tfor _, r := range current {\n\t\texistingResources[objectKey(r)] = true\n\t}\n\n\tvar toBeCreated kube.ResourceList\n\tfor _, r := range target {\n\t\tif !existingResources[objectKey(r)] {\n\t\t\ttoBeCreated = append(toBeCreated, r)\n\t\t}\n\t}\n\n\ttoBeUpdated, err := existingResourceConflict(toBeCreated, upgradedRelease.Name, upgradedRelease.Namespace)\n\tif err != nil {\n\t\treturn nil, errors.Wrap(err, \"rendered manifests contain a resource that already exists. Unable to continue with update\")\n\t}\n\n\ttoBeUpdated.Visit(func(r *resource.Info, err error) error {\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tcurrent.Append(r)\n\t\treturn nil\n\t})\n\n\tif u.DryRun {\n\t\tu.cfg.Log(\"dry run for %s\", upgradedRelease.Name)\n\t\tif len(u.Description) > 0 {\n\t\t\tupgradedRelease.Info.Description = u.Description\n\t\t} else {\n\t\t\tupgradedRelease.Info.Description = \"Dry run complete\"\n\t\t}\n\t\treturn upgradedRelease, nil\n\t}\n\n\tu.cfg.Log(\"creating upgraded release for %s\", upgradedRelease.Name)\n\tif err := u.cfg.Releases.Create(upgradedRelease); err != nil {\n\t\treturn nil, err\n\t}\n\trChan := make(chan resultMessage)\n\tctxChan := make(chan resultMessage)\n\tdoneChan := make(chan interface{})\n\tdefer close(doneChan)\n\tgo u.releasingUpgrade(rChan, upgradedRelease, current, target, originalRelease)\n\tgo u.handleContext(ctx, doneChan, ctxChan, upgradedRelease)\n\tselect {\n\tcase result := <-rChan:\n\t\treturn result.r, result.e\n\tcase result := <-ctxChan:\n\t\treturn result.r, result.e\n\t}\n}\n\n// Function used to lock the Mutex, this is important for the case when the atomic flag is set.\n// In that case the upgrade will finish before the rollback is finished so it is necessary to wait for the rollback to finish.\n// The rollback will be trigger by the function failRelease\nfunc (u *Upgrade) reportToPerformUpgrade(c chan<- resultMessage, rel *release.Release, created kube.ResourceList, err error) {\n\tu.Lock.Lock()\n\tif err != nil {\n\t\trel, err = u.failRelease(rel, created, err)\n\t}\n\tc <- resultMessage{r: rel, e: err}\n\tu.Lock.Unlock()\n}\n\n// Setup listener for SIGINT and SIGTERM\nfunc (u *Upgrade) handleContext(ctx context.Context, done chan interface{}, c chan<- resultMessage, upgradedRelease *release.Release) {\n\tselect {\n\tcase <-ctx.Done():\n\t\terr := ctx.Err()\n\n\t\t// when the atomic flag is set the ongoing release finish first and doesn't give time for the rollback happens.\n\t\tu.reportToPerformUpgrade(c, upgradedRelease, kube.ResourceList{}, err)\n\tcase <-done:\n\t\treturn\n\t}\n}\nfunc (u *Upgrade) releasingUpgrade(c chan<- resultMessage, upgradedRelease *release.Release, current kube.ResourceList, target kube.ResourceList, originalRelease *release.Release) {\n\t// pre-upgrade hooks\n\n\tif !u.DisableHooks {\n\t\tif err := u.cfg.execHook(upgradedRelease, release.HookPreUpgrade, u.Timeout); err != nil {\n\t\t\tu.reportToPerformUpgrade(c, upgradedRelease, kube.ResourceList{}, fmt.Errorf(\"pre-upgrade hooks failed: %s\", err))\n\t\t\treturn\n\t\t}\n\t} else {\n\t\tu.cfg.Log(\"upgrade hooks disabled for %s\", upgradedRelease.Name)\n\t}\n\n\tresults, err := u.cfg.KubeClient.Update(current, target, u.Force)\n\tif err != nil {\n\t\tu.cfg.recordRelease(originalRelease)\n\t\tu.reportToPerformUpgrade(c, upgradedRelease, results.Created, err)\n\t\treturn\n\t}\n\n\tif u.Recreate {\n\t\t// NOTE: Because this is not critical for a release to succeed, we just\n\t\t// log if an error occurs and continue onward. If we ever introduce log\n\t\t// levels, we should make these error level logs so users are notified\n\t\t// that they'll need to go do the cleanup on their own\n\t\tif err := recreate(u.cfg, results.Updated); err != nil {\n\t\t\tu.cfg.Log(err.Error())\n\t\t}\n\t}\n\n\tif u.Wait {\n\t\tu.cfg.Log(\n\t\t\t\"waiting for release %s resources (created: %d updated: %d  deleted: %d)\",\n\t\t\tupgradedRelease.Name, len(results.Created), len(results.Updated), len(results.Deleted))\n\t\tif u.WaitForJobs {\n\t\t\tif err := u.cfg.KubeClient.WaitWithJobs(target, u.Timeout); err != nil {\n\t\t\t\tu.cfg.recordRelease(originalRelease)\n\t\t\t\tu.reportToPerformUpgrade(c, upgradedRelease, results.Created, err)\n\t\t\t\treturn\n\t\t\t}\n\t\t} else {\n\t\t\tif err := u.cfg.KubeClient.Wait(target, u.Timeout); err != nil {\n\t\t\t\tu.cfg.recordRelease(originalRelease)\n\t\t\t\tu.reportToPerformUpgrade(c, upgradedRelease, results.Created, err)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}\n\n\t// post-upgrade hooks\n\tif !u.DisableHooks {\n\t\tif err := u.cfg.execHook(upgradedRelease, release.HookPostUpgrade, u.Timeout); err != nil {\n\t\t\tu.reportToPerformUpgrade(c, upgradedRelease, results.Created, fmt.Errorf(\"post-upgrade hooks failed: %s\", err))\n\t\t\treturn\n\t\t}\n\t}\n\n\toriginalRelease.Info.Status = release.StatusSuperseded\n\tu.cfg.recordRelease(originalRelease)\n\n\tupgradedRelease.Info.Status = release.StatusDeployed\n\tif len(u.Description) > 0 {\n\t\tupgradedRelease.Info.Description = u.Description\n\t} else {\n\t\tupgradedRelease.Info.Description = \"Upgrade complete\"\n\t}\n\tu.reportToPerformUpgrade(c, upgradedRelease, nil, nil)\n}\n\nfunc (u *Upgrade) failRelease(rel *release.Release, created kube.ResourceList, err error) (*release.Release, error) {\n\tmsg := fmt.Sprintf(\"Upgrade %q failed: %s\", rel.Name, err)\n\tu.cfg.Log(\"warning: %s\", msg)\n\n\trel.Info.Status = release.StatusFailed\n\trel.Info.Description = msg\n\tu.cfg.recordRelease(rel)\n\tif u.CleanupOnFail && len(created) > 0 {\n\t\tu.cfg.Log(\"Cleanup on fail set, cleaning up %d resources\", len(created))\n\t\t_, errs := u.cfg.KubeClient.Delete(created)\n\t\tif errs != nil {\n\t\t\tvar errorList []string\n\t\t\tfor _, e := range errs {\n\t\t\t\terrorList = append(errorList, e.Error())\n\t\t\t}\n\t\t\treturn rel, errors.Wrapf(fmt.Errorf(\"unable to cleanup resources: %s\", strings.Join(errorList, \", \")), \"an error occurred while cleaning up resources. original upgrade error: %s\", err)\n\t\t}\n\t\tu.cfg.Log(\"Resource cleanup complete\")\n\t}\n\tif u.Atomic {\n\t\tu.cfg.Log(\"Upgrade failed and atomic is set, rolling back to last successful release\")\n\n\t\t// As a protection, get the last successful release before rollback.\n\t\t// If there are no successful releases, bail out\n\t\thist := NewHistory(u.cfg)\n\t\tfullHistory, herr := hist.Run(rel.Name)\n\t\tif herr != nil {\n\t\t\treturn rel, errors.Wrapf(herr, \"an error occurred while finding last successful release. original upgrade error: %s\", err)\n\t\t}\n\n\t\t// There isn't a way to tell if a previous release was successful, but\n\t\t// generally failed releases do not get superseded unless the next\n\t\t// release is successful, so this should be relatively safe\n\t\tfilteredHistory := releaseutil.FilterFunc(func(r *release.Release) bool {\n\t\t\treturn r.Info.Status == release.StatusSuperseded || r.Info.Status == release.StatusDeployed\n\t\t}).Filter(fullHistory)\n\t\tif len(filteredHistory) == 0 {\n\t\t\treturn rel, errors.Wrap(err, \"unable to find a previously successful release when attempting to rollback. original upgrade error\")\n\t\t}\n\n\t\treleaseutil.Reverse(filteredHistory, releaseutil.SortByRevision)\n\n\t\trollin := NewRollback(u.cfg)\n\t\trollin.Version = filteredHistory[0].Version\n\t\trollin.Wait = true\n\t\trollin.WaitForJobs = u.WaitForJobs\n\t\trollin.DisableHooks = u.DisableHooks\n\t\trollin.Recreate = u.Recreate\n\t\trollin.Force = u.Force\n\t\trollin.Timeout = u.Timeout\n\t\tif rollErr := rollin.Run(rel.Name); rollErr != nil {\n\t\t\treturn rel, errors.Wrapf(rollErr, \"an error occurred while rolling back the release. original upgrade error: %s\", err)\n\t\t}\n\t\treturn rel, errors.Wrapf(err, \"release %s failed, and has been rolled back due to atomic being set\", rel.Name)\n\t}\n\n\treturn rel, err\n}\n\n// reuseValues copies values from the current release to a new release if the\n// new release does not have any values.\n//\n// If the request already has values, or if there are no values in the current\n// release, this does nothing.\n//\n// This is skipped if the u.ResetValues flag is set, in which case the\n// request values are not altered.\nfunc (u *Upgrade) reuseValues(chart *chart.Chart, current *release.Release, newVals map[string]interface{}) (map[string]interface{}, error) {\n\tif u.ResetValues {\n\t\t// If ResetValues is set, we completely ignore current.Config.\n\t\tu.cfg.Log(\"resetting values to the chart's original version\")\n\t\treturn newVals, nil\n\t}\n\n\t// If the ReuseValues flag is set, we always copy the old values over the new config's values.\n\tif u.ReuseValues {\n\t\tu.cfg.Log(\"reusing the old release's values\")\n\n\t\t// We have to regenerate the old coalesced values:\n\t\toldVals, err := chartutil.CoalesceValues(current.Chart, current.Config)\n\t\tif err != nil {\n\t\t\treturn nil, errors.Wrap(err, \"failed to rebuild old values\")\n\t\t}\n\n\t\tnewVals = chartutil.CoalesceTables(newVals, current.Config)\n\n\t\tchart.Values = oldVals\n\n\t\treturn newVals, nil\n\t}\n\n\tif len(newVals) == 0 && len(current.Config) > 0 {\n\t\tu.cfg.Log(\"copying values from %s (v%d) to new release.\", current.Name, current.Version)\n\t\tnewVals = current.Config\n\t}\n\treturn newVals, nil\n}\n\nfunc validateManifest(c kube.Interface, manifest []byte, openAPIValidation bool) error {\n\t_, err := c.Build(bytes.NewReader(manifest), openAPIValidation)\n\treturn err\n}\n\n// recreate captures all the logic for recreating pods for both upgrade and\n// rollback. If we end up refactoring rollback to use upgrade, this can just be\n// made an unexported method on the upgrade action.\nfunc recreate(cfg *Configuration, resources kube.ResourceList) error {\n\tfor _, res := range resources {\n\t\tversioned := kube.AsVersioned(res)\n\t\tselector, err := kube.SelectorsForObject(versioned)\n\t\tif err != nil {\n\t\t\t// If no selector is returned, it means this object is\n\t\t\t// definitely not a pod, so continue onward\n\t\t\tcontinue\n\t\t}\n\n\t\tclient, err := cfg.KubernetesClientSet()\n\t\tif err != nil {\n\t\t\treturn errors.Wrapf(err, \"unable to recreate pods for object %s/%s because an error occurred\", res.Namespace, res.Name)\n\t\t}\n\n\t\tpods, err := client.CoreV1().Pods(res.Namespace).List(context.Background(), metav1.ListOptions{\n\t\t\tLabelSelector: selector.String(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn errors.Wrapf(err, \"unable to recreate pods for object %s/%s because an error occurred\", res.Namespace, res.Name)\n\t\t}\n\n\t\t// Restart pods\n\t\tfor _, pod := range pods.Items {\n\t\t\t// Delete each pod for get them restarted with changed spec.\n\t\t\tif err := client.CoreV1().Pods(pod.Namespace).Delete(context.Background(), pod.Name, *metav1.NewPreconditionDeleteOptions(string(pod.UID))); err != nil {\n\t\t\t\treturn errors.Wrapf(err, \"unable to recreate pods for object %s/%s because an error occurred\", res.Namespace, res.Name)\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc objectKey(r *resource.Info) string {\n\tgvk := r.Object.GetObjectKind().GroupVersionKind()\n\treturn fmt.Sprintf(\"%s/%s/%s/%s\", gvk.GroupVersion().String(), gvk.Kind, r.Namespace, r.Name)\n}\n", "/*\nCopyright The Helm Authors.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\npackage engine\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"path\"\n\t\"path/filepath\"\n\t\"regexp\"\n\t\"sort\"\n\t\"strings\"\n\t\"text/template\"\n\n\t\"github.com/pkg/errors\"\n\t\"k8s.io/client-go/rest\"\n\n\t\"helm.sh/helm/v3/pkg/chart\"\n\t\"helm.sh/helm/v3/pkg/chartutil\"\n)\n\n// Engine is an implementation of the Helm rendering implementation for templates.\ntype Engine struct {\n\t// If strict is enabled, template rendering will fail if a template references\n\t// a value that was not passed in.\n\tStrict bool\n\t// In LintMode, some 'required' template values may be missing, so don't fail\n\tLintMode bool\n\t// the rest config to connect to the kubernetes api\n\tconfig *rest.Config\n}\n\n// Render takes a chart, optional values, and value overrides, and attempts to render the Go templates.\n//\n// Render can be called repeatedly on the same engine.\n//\n// This will look in the chart's 'templates' data (e.g. the 'templates/' directory)\n// and attempt to render the templates there using the values passed in.\n//\n// Values are scoped to their templates. A dependency template will not have\n// access to the values set for its parent. If chart \"foo\" includes chart \"bar\",\n// \"bar\" will not have access to the values for \"foo\".\n//\n// Values should be prepared with something like `chartutils.ReadValues`.\n//\n// Values are passed through the templates according to scope. If the top layer\n// chart includes the chart foo, which includes the chart bar, the values map\n// will be examined for a table called \"foo\". If \"foo\" is found in vals,\n// that section of the values will be passed into the \"foo\" chart. And if that\n// section contains a value named \"bar\", that value will be passed on to the\n// bar chart during render time.\nfunc (e Engine) Render(chrt *chart.Chart, values chartutil.Values) (map[string]string, error) {\n\ttmap := allTemplates(chrt, values)\n\treturn e.render(tmap)\n}\n\n// Render takes a chart, optional values, and value overrides, and attempts to\n// render the Go templates using the default options.\nfunc Render(chrt *chart.Chart, values chartutil.Values) (map[string]string, error) {\n\treturn new(Engine).Render(chrt, values)\n}\n\n// RenderWithClient takes a chart, optional values, and value overrides, and attempts to\n// render the Go templates using the default options. This engine is client aware and so can have template\n// functions that interact with the client\nfunc RenderWithClient(chrt *chart.Chart, values chartutil.Values, config *rest.Config) (map[string]string, error) {\n\treturn Engine{\n\t\tconfig: config,\n\t}.Render(chrt, values)\n}\n\n// renderable is an object that can be rendered.\ntype renderable struct {\n\t// tpl is the current template.\n\ttpl string\n\t// vals are the values to be supplied to the template.\n\tvals chartutil.Values\n\t// namespace prefix to the templates of the current chart\n\tbasePath string\n}\n\nconst warnStartDelim = \"HELM_ERR_START\"\nconst warnEndDelim = \"HELM_ERR_END\"\nconst recursionMaxNums = 1000\n\nvar warnRegex = regexp.MustCompile(warnStartDelim + `((?s).*)` + warnEndDelim)\n\nfunc warnWrap(warn string) string {\n\treturn warnStartDelim + warn + warnEndDelim\n}\n\n// initFunMap creates the Engine's FuncMap and adds context-specific functions.\nfunc (e Engine) initFunMap(t *template.Template, referenceTpls map[string]renderable) {\n\tfuncMap := funcMap()\n\tincludedNames := make(map[string]int)\n\n\t// Add the 'include' function here so we can close over t.\n\tfuncMap[\"include\"] = func(name string, data interface{}) (string, error) {\n\t\tvar buf strings.Builder\n\t\tif v, ok := includedNames[name]; ok {\n\t\t\tif v > recursionMaxNums {\n\t\t\t\treturn \"\", errors.Wrapf(fmt.Errorf(\"unable to execute template\"), \"rendering template has a nested reference name: %s\", name)\n\t\t\t}\n\t\t\tincludedNames[name]++\n\t\t} else {\n\t\t\tincludedNames[name] = 1\n\t\t}\n\t\terr := t.ExecuteTemplate(&buf, name, data)\n\t\tincludedNames[name]--\n\t\treturn buf.String(), err\n\t}\n\n\t// Add the 'tpl' function here\n\tfuncMap[\"tpl\"] = func(tpl string, vals chartutil.Values) (string, error) {\n\t\tbasePath, err := vals.PathValue(\"Template.BasePath\")\n\t\tif err != nil {\n\t\t\treturn \"\", errors.Wrapf(err, \"cannot retrieve Template.Basepath from values inside tpl function: %s\", tpl)\n\t\t}\n\n\t\ttemplateName, err := vals.PathValue(\"Template.Name\")\n\t\tif err != nil {\n\t\t\treturn \"\", errors.Wrapf(err, \"cannot retrieve Template.Name from values inside tpl function: %s\", tpl)\n\t\t}\n\n\t\ttemplates := map[string]renderable{\n\t\t\ttemplateName.(string): {\n\t\t\t\ttpl:      tpl,\n\t\t\t\tvals:     vals,\n\t\t\t\tbasePath: basePath.(string),\n\t\t\t},\n\t\t}\n\n\t\tresult, err := e.renderWithReferences(templates, referenceTpls)\n\t\tif err != nil {\n\t\t\treturn \"\", errors.Wrapf(err, \"error during tpl function execution for %q\", tpl)\n\t\t}\n\t\treturn result[templateName.(string)], nil\n\t}\n\n\t// Add the `required` function here so we can use lintMode\n\tfuncMap[\"required\"] = func(warn string, val interface{}) (interface{}, error) {\n\t\tif val == nil {\n\t\t\tif e.LintMode {\n\t\t\t\t// Don't fail on missing required values when linting\n\t\t\t\tlog.Printf(\"[INFO] Missing required value: %s\", warn)\n\t\t\t\treturn \"\", nil\n\t\t\t}\n\t\t\treturn val, errors.Errorf(warnWrap(warn))\n\t\t} else if _, ok := val.(string); ok {\n\t\t\tif val == \"\" {\n\t\t\t\tif e.LintMode {\n\t\t\t\t\t// Don't fail on missing required values when linting\n\t\t\t\t\tlog.Printf(\"[INFO] Missing required value: %s\", warn)\n\t\t\t\t\treturn \"\", nil\n\t\t\t\t}\n\t\t\t\treturn val, errors.Errorf(warnWrap(warn))\n\t\t\t}\n\t\t}\n\t\treturn val, nil\n\t}\n\n\t// Override sprig fail function for linting and wrapping message\n\tfuncMap[\"fail\"] = func(msg string) (string, error) {\n\t\tif e.LintMode {\n\t\t\t// Don't fail when linting\n\t\t\tlog.Printf(\"[INFO] Fail: %s\", msg)\n\t\t\treturn \"\", nil\n\t\t}\n\t\treturn \"\", errors.New(warnWrap(msg))\n\t}\n\n\t// If we are not linting and have a cluster connection, provide a Kubernetes-backed\n\t// implementation.\n\tif !e.LintMode && e.config != nil {\n\t\tfuncMap[\"lookup\"] = NewLookupFunction(e.config)\n\t}\n\n\tt.Funcs(funcMap)\n}\n\n// render takes a map of templates/values and renders them.\nfunc (e Engine) render(tpls map[string]renderable) (map[string]string, error) {\n\treturn e.renderWithReferences(tpls, tpls)\n}\n\n// renderWithReferences takes a map of templates/values to render, and a map of\n// templates which can be referenced within them.\nfunc (e Engine) renderWithReferences(tpls, referenceTpls map[string]renderable) (rendered map[string]string, err error) {\n\t// Basically, what we do here is start with an empty parent template and then\n\t// build up a list of templates -- one for each file. Once all of the templates\n\t// have been parsed, we loop through again and execute every template.\n\t//\n\t// The idea with this process is to make it possible for more complex templates\n\t// to share common blocks, but to make the entire thing feel like a file-based\n\t// template engine.\n\tdefer func() {\n\t\tif r := recover(); r != nil {\n\t\t\terr = errors.Errorf(\"rendering template failed: %v\", r)\n\t\t}\n\t}()\n\tt := template.New(\"gotpl\")\n\tif e.Strict {\n\t\tt.Option(\"missingkey=error\")\n\t} else {\n\t\t// Not that zero will attempt to add default values for types it knows,\n\t\t// but will still emit <no value> for others. We mitigate that later.\n\t\tt.Option(\"missingkey=zero\")\n\t}\n\n\te.initFunMap(t, referenceTpls)\n\n\t// We want to parse the templates in a predictable order. The order favors\n\t// higher-level (in file system) templates over deeply nested templates.\n\tkeys := sortTemplates(tpls)\n\treferenceKeys := sortTemplates(referenceTpls)\n\n\tfor _, filename := range keys {\n\t\tr := tpls[filename]\n\t\tif _, err := t.New(filename).Parse(r.tpl); err != nil {\n\t\t\treturn map[string]string{}, cleanupParseError(filename, err)\n\t\t}\n\t}\n\n\t// Adding the reference templates to the template context\n\t// so they can be referenced in the tpl function\n\tfor _, filename := range referenceKeys {\n\t\tif t.Lookup(filename) == nil {\n\t\t\tr := referenceTpls[filename]\n\t\t\tif _, err := t.New(filename).Parse(r.tpl); err != nil {\n\t\t\t\treturn map[string]string{}, cleanupParseError(filename, err)\n\t\t\t}\n\t\t}\n\t}\n\n\trendered = make(map[string]string, len(keys))\n\tfor _, filename := range keys {\n\t\t// Don't render partials. We don't care out the direct output of partials.\n\t\t// They are only included from other templates.\n\t\tif strings.HasPrefix(path.Base(filename), \"_\") {\n\t\t\tcontinue\n\t\t}\n\t\t// At render time, add information about the template that is being rendered.\n\t\tvals := tpls[filename].vals\n\t\tvals[\"Template\"] = chartutil.Values{\"Name\": filename, \"BasePath\": tpls[filename].basePath}\n\t\tvar buf strings.Builder\n\t\tif err := t.ExecuteTemplate(&buf, filename, vals); err != nil {\n\t\t\treturn map[string]string{}, cleanupExecError(filename, err)\n\t\t}\n\n\t\t// Work around the issue where Go will emit \"<no value>\" even if Options(missing=zero)\n\t\t// is set. Since missing=error will never get here, we do not need to handle\n\t\t// the Strict case.\n\t\trendered[filename] = strings.ReplaceAll(buf.String(), \"<no value>\", \"\")\n\t}\n\n\treturn rendered, nil\n}\n\nfunc cleanupParseError(filename string, err error) error {\n\ttokens := strings.Split(err.Error(), \": \")\n\tif len(tokens) == 1 {\n\t\t// This might happen if a non-templating error occurs\n\t\treturn fmt.Errorf(\"parse error in (%s): %s\", filename, err)\n\t}\n\t// The first token is \"template\"\n\t// The second token is either \"filename:lineno\" or \"filename:lineNo:columnNo\"\n\tlocation := tokens[1]\n\t// The remaining tokens make up a stacktrace-like chain, ending with the relevant error\n\terrMsg := tokens[len(tokens)-1]\n\treturn fmt.Errorf(\"parse error at (%s): %s\", string(location), errMsg)\n}\n\nfunc cleanupExecError(filename string, err error) error {\n\tif _, isExecError := err.(template.ExecError); !isExecError {\n\t\treturn err\n\t}\n\n\ttokens := strings.SplitN(err.Error(), \": \", 3)\n\tif len(tokens) != 3 {\n\t\t// This might happen if a non-templating error occurs\n\t\treturn fmt.Errorf(\"execution error in (%s): %s\", filename, err)\n\t}\n\n\t// The first token is \"template\"\n\t// The second token is either \"filename:lineno\" or \"filename:lineNo:columnNo\"\n\tlocation := tokens[1]\n\n\tparts := warnRegex.FindStringSubmatch(tokens[2])\n\tif len(parts) >= 2 {\n\t\treturn fmt.Errorf(\"execution error at (%s): %s\", string(location), parts[1])\n\t}\n\n\treturn err\n}\n\nfunc sortTemplates(tpls map[string]renderable) []string {\n\tkeys := make([]string, len(tpls))\n\ti := 0\n\tfor key := range tpls {\n\t\tkeys[i] = key\n\t\ti++\n\t}\n\tsort.Sort(sort.Reverse(byPathLen(keys)))\n\treturn keys\n}\n\ntype byPathLen []string\n\nfunc (p byPathLen) Len() int      { return len(p) }\nfunc (p byPathLen) Swap(i, j int) { p[j], p[i] = p[i], p[j] }\nfunc (p byPathLen) Less(i, j int) bool {\n\ta, b := p[i], p[j]\n\tca, cb := strings.Count(a, \"/\"), strings.Count(b, \"/\")\n\tif ca == cb {\n\t\treturn strings.Compare(a, b) == -1\n\t}\n\treturn ca < cb\n}\n\n// allTemplates returns all templates for a chart and its dependencies.\n//\n// As it goes, it also prepares the values in a scope-sensitive manner.\nfunc allTemplates(c *chart.Chart, vals chartutil.Values) map[string]renderable {\n\ttemplates := make(map[string]renderable)\n\trecAllTpls(c, templates, vals)\n\treturn templates\n}\n\n// recAllTpls recurses through the templates in a chart.\n//\n// As it recurses, it also sets the values to be appropriate for the template\n// scope.\nfunc recAllTpls(c *chart.Chart, templates map[string]renderable, vals chartutil.Values) map[string]interface{} {\n\tsubCharts := make(map[string]interface{})\n\tchartMetaData := struct {\n\t\tchart.Metadata\n\t\tIsRoot bool\n\t}{*c.Metadata, c.IsRoot()}\n\n\tnext := map[string]interface{}{\n\t\t\"Chart\":        chartMetaData,\n\t\t\"Files\":        newFiles(c.Files),\n\t\t\"Release\":      vals[\"Release\"],\n\t\t\"Capabilities\": vals[\"Capabilities\"],\n\t\t\"Values\":       make(chartutil.Values),\n\t\t\"Subcharts\":    subCharts,\n\t}\n\n\t// If there is a {{.Values.ThisChart}} in the parent metadata,\n\t// copy that into the {{.Values}} for this template.\n\tif c.IsRoot() {\n\t\tnext[\"Values\"] = vals[\"Values\"]\n\t} else if vs, err := vals.Table(\"Values.\" + c.Name()); err == nil {\n\t\tnext[\"Values\"] = vs\n\t}\n\n\tfor _, child := range c.Dependencies() {\n\t\tsubCharts[child.Name()] = recAllTpls(child, templates, next)\n\t}\n\n\tnewParentID := c.ChartFullPath()\n\tfor _, t := range c.Templates {\n\t\tif !isTemplateValid(c, t.Name) {\n\t\t\tcontinue\n\t\t}\n\t\ttemplates[path.Join(newParentID, t.Name)] = renderable{\n\t\t\ttpl:      string(t.Data),\n\t\t\tvals:     next,\n\t\t\tbasePath: path.Join(newParentID, \"templates\"),\n\t\t}\n\t}\n\n\treturn next\n}\n\n// isTemplateValid returns true if the template is valid for the chart type\nfunc isTemplateValid(ch *chart.Chart, templateName string) bool {\n\tif isLibraryChart(ch) {\n\t\treturn strings.HasPrefix(filepath.Base(templateName), \"_\")\n\t}\n\treturn true\n}\n\n// isLibraryChart returns true if the chart is a library chart\nfunc isLibraryChart(c *chart.Chart) bool {\n\treturn strings.EqualFold(c.Metadata.Type, \"library\")\n}\n", "/*\nCopyright The Helm Authors.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\npackage engine\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"sync\"\n\t\"testing\"\n\n\t\"helm.sh/helm/v3/pkg/chart\"\n\t\"helm.sh/helm/v3/pkg/chartutil\"\n)\n\nfunc TestSortTemplates(t *testing.T) {\n\ttpls := map[string]renderable{\n\t\t\"/mychart/templates/foo.tpl\":                                 {},\n\t\t\"/mychart/templates/charts/foo/charts/bar/templates/foo.tpl\": {},\n\t\t\"/mychart/templates/bar.tpl\":                                 {},\n\t\t\"/mychart/templates/charts/foo/templates/bar.tpl\":            {},\n\t\t\"/mychart/templates/_foo.tpl\":                                {},\n\t\t\"/mychart/templates/charts/foo/templates/foo.tpl\":            {},\n\t\t\"/mychart/templates/charts/bar/templates/foo.tpl\":            {},\n\t}\n\tgot := sortTemplates(tpls)\n\tif len(got) != len(tpls) {\n\t\tt.Fatal(\"Sorted results are missing templates\")\n\t}\n\n\texpect := []string{\n\t\t\"/mychart/templates/charts/foo/charts/bar/templates/foo.tpl\",\n\t\t\"/mychart/templates/charts/foo/templates/foo.tpl\",\n\t\t\"/mychart/templates/charts/foo/templates/bar.tpl\",\n\t\t\"/mychart/templates/charts/bar/templates/foo.tpl\",\n\t\t\"/mychart/templates/foo.tpl\",\n\t\t\"/mychart/templates/bar.tpl\",\n\t\t\"/mychart/templates/_foo.tpl\",\n\t}\n\tfor i, e := range expect {\n\t\tif got[i] != e {\n\t\t\tt.Fatalf(\"\\n\\tExp:\\n%s\\n\\tGot:\\n%s\",\n\t\t\t\tstrings.Join(expect, \"\\n\"),\n\t\t\t\tstrings.Join(got, \"\\n\"),\n\t\t\t)\n\t\t}\n\t}\n}\n\nfunc TestFuncMap(t *testing.T) {\n\tfns := funcMap()\n\tforbidden := []string{\"env\", \"expandenv\"}\n\tfor _, f := range forbidden {\n\t\tif _, ok := fns[f]; ok {\n\t\t\tt.Errorf(\"Forbidden function %s exists in FuncMap.\", f)\n\t\t}\n\t}\n\n\t// Test for Engine-specific template functions.\n\texpect := []string{\"include\", \"required\", \"tpl\", \"toYaml\", \"fromYaml\", \"toToml\", \"toJson\", \"fromJson\", \"lookup\"}\n\tfor _, f := range expect {\n\t\tif _, ok := fns[f]; !ok {\n\t\t\tt.Errorf(\"Expected add-on function %q\", f)\n\t\t}\n\t}\n}\n\nfunc TestRender(t *testing.T) {\n\tc := &chart.Chart{\n\t\tMetadata: &chart.Metadata{\n\t\t\tName:    \"moby\",\n\t\t\tVersion: \"1.2.3\",\n\t\t},\n\t\tTemplates: []*chart.File{\n\t\t\t{Name: \"templates/test1\", Data: []byte(\"{{.Values.outer | title }} {{.Values.inner | title}}\")},\n\t\t\t{Name: \"templates/test2\", Data: []byte(\"{{.Values.global.callme | lower }}\")},\n\t\t\t{Name: \"templates/test3\", Data: []byte(\"{{.noValue}}\")},\n\t\t\t{Name: \"templates/test4\", Data: []byte(\"{{toJson .Values}}\")},\n\t\t},\n\t\tValues: map[string]interface{}{\"outer\": \"DEFAULT\", \"inner\": \"DEFAULT\"},\n\t}\n\n\tvals := map[string]interface{}{\n\t\t\"Values\": map[string]interface{}{\n\t\t\t\"outer\": \"spouter\",\n\t\t\t\"inner\": \"inn\",\n\t\t\t\"global\": map[string]interface{}{\n\t\t\t\t\"callme\": \"Ishmael\",\n\t\t\t},\n\t\t},\n\t}\n\n\tv, err := chartutil.CoalesceValues(c, vals)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to coalesce values: %s\", err)\n\t}\n\tout, err := Render(c, v)\n\tif err != nil {\n\t\tt.Errorf(\"Failed to render templates: %s\", err)\n\t}\n\n\texpect := map[string]string{\n\t\t\"moby/templates/test1\": \"Spouter Inn\",\n\t\t\"moby/templates/test2\": \"ishmael\",\n\t\t\"moby/templates/test3\": \"\",\n\t\t\"moby/templates/test4\": `{\"global\":{\"callme\":\"Ishmael\"},\"inner\":\"inn\",\"outer\":\"spouter\"}`,\n\t}\n\n\tfor name, data := range expect {\n\t\tif out[name] != data {\n\t\t\tt.Errorf(\"Expected %q, got %q\", data, out[name])\n\t\t}\n\t}\n}\n\nfunc TestRenderRefsOrdering(t *testing.T) {\n\tparentChart := &chart.Chart{\n\t\tMetadata: &chart.Metadata{\n\t\t\tName:    \"parent\",\n\t\t\tVersion: \"1.2.3\",\n\t\t},\n\t\tTemplates: []*chart.File{\n\t\t\t{Name: \"templates/_helpers.tpl\", Data: []byte(`{{- define \"test\" -}}parent value{{- end -}}`)},\n\t\t\t{Name: \"templates/test.yaml\", Data: []byte(`{{ tpl \"{{ include \\\"test\\\" . }}\" . }}`)},\n\t\t},\n\t}\n\tchildChart := &chart.Chart{\n\t\tMetadata: &chart.Metadata{\n\t\t\tName:    \"child\",\n\t\t\tVersion: \"1.2.3\",\n\t\t},\n\t\tTemplates: []*chart.File{\n\t\t\t{Name: \"templates/_helpers.tpl\", Data: []byte(`{{- define \"test\" -}}child value{{- end -}}`)},\n\t\t},\n\t}\n\tparentChart.AddDependency(childChart)\n\n\texpect := map[string]string{\n\t\t\"parent/templates/test.yaml\": \"parent value\",\n\t}\n\n\tfor i := 0; i < 100; i++ {\n\t\tout, err := Render(parentChart, chartutil.Values{})\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Failed to render templates: %s\", err)\n\t\t}\n\n\t\tfor name, data := range expect {\n\t\t\tif out[name] != data {\n\t\t\t\tt.Fatalf(\"Expected %q, got %q (iteration %d)\", data, out[name], i+1)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestRenderInternals(t *testing.T) {\n\t// Test the internals of the rendering tool.\n\n\tvals := chartutil.Values{\"Name\": \"one\", \"Value\": \"two\"}\n\ttpls := map[string]renderable{\n\t\t\"one\": {tpl: `Hello {{title .Name}}`, vals: vals},\n\t\t\"two\": {tpl: `Goodbye {{upper .Value}}`, vals: vals},\n\t\t// Test whether a template can reliably reference another template\n\t\t// without regard for ordering.\n\t\t\"three\": {tpl: `{{template \"two\" dict \"Value\" \"three\"}}`, vals: vals},\n\t}\n\n\tout, err := new(Engine).render(tpls)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed template rendering: %s\", err)\n\t}\n\n\tif len(out) != 3 {\n\t\tt.Fatalf(\"Expected 3 templates, got %d\", len(out))\n\t}\n\n\tif out[\"one\"] != \"Hello One\" {\n\t\tt.Errorf(\"Expected 'Hello One', got %q\", out[\"one\"])\n\t}\n\n\tif out[\"two\"] != \"Goodbye TWO\" {\n\t\tt.Errorf(\"Expected 'Goodbye TWO'. got %q\", out[\"two\"])\n\t}\n\n\tif out[\"three\"] != \"Goodbye THREE\" {\n\t\tt.Errorf(\"Expected 'Goodbye THREE'. got %q\", out[\"two\"])\n\t}\n}\n\nfunc TestParallelRenderInternals(t *testing.T) {\n\t// Make sure that we can use one Engine to run parallel template renders.\n\te := new(Engine)\n\tvar wg sync.WaitGroup\n\tfor i := 0; i < 20; i++ {\n\t\twg.Add(1)\n\t\tgo func(i int) {\n\t\t\ttt := fmt.Sprintf(\"expect-%d\", i)\n\t\t\ttpls := map[string]renderable{\n\t\t\t\t\"t\": {\n\t\t\t\t\ttpl:  `{{.val}}`,\n\t\t\t\t\tvals: map[string]interface{}{\"val\": tt},\n\t\t\t\t},\n\t\t\t}\n\t\t\tout, err := e.render(tpls)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Failed to render %s: %s\", tt, err)\n\t\t\t}\n\t\t\tif out[\"t\"] != tt {\n\t\t\t\tt.Errorf(\"Expected %q, got %q\", tt, out[\"t\"])\n\t\t\t}\n\t\t\twg.Done()\n\t\t}(i)\n\t}\n\twg.Wait()\n}\n\nfunc TestParseErrors(t *testing.T) {\n\tvals := chartutil.Values{\"Values\": map[string]interface{}{}}\n\n\ttplsUndefinedFunction := map[string]renderable{\n\t\t\"undefined_function\": {tpl: `{{foo}}`, vals: vals},\n\t}\n\t_, err := new(Engine).render(tplsUndefinedFunction)\n\tif err == nil {\n\t\tt.Fatalf(\"Expected failures while rendering: %s\", err)\n\t}\n\texpected := `parse error at (undefined_function:1): function \"foo\" not defined`\n\tif err.Error() != expected {\n\t\tt.Errorf(\"Expected '%s', got %q\", expected, err.Error())\n\t}\n}\n\nfunc TestExecErrors(t *testing.T) {\n\tvals := chartutil.Values{\"Values\": map[string]interface{}{}}\n\tcases := []struct {\n\t\tname     string\n\t\ttpls     map[string]renderable\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname: \"MissingRequired\",\n\t\t\ttpls: map[string]renderable{\n\t\t\t\t\"missing_required\": {tpl: `{{required \"foo is required\" .Values.foo}}`, vals: vals},\n\t\t\t},\n\t\t\texpected: `execution error at (missing_required:1:2): foo is required`,\n\t\t},\n\t\t{\n\t\t\tname: \"MissingRequiredWithColons\",\n\t\t\ttpls: map[string]renderable{\n\t\t\t\t\"missing_required_with_colons\": {tpl: `{{required \":this: message: has many: colons:\" .Values.foo}}`, vals: vals},\n\t\t\t},\n\t\t\texpected: `execution error at (missing_required_with_colons:1:2): :this: message: has many: colons:`,\n\t\t},\n\t\t{\n\t\t\tname: \"Issue6044\",\n\t\t\ttpls: map[string]renderable{\n\t\t\t\t\"issue6044\": {\n\t\t\t\t\tvals: vals,\n\t\t\t\t\ttpl: `{{ $someEmptyValue := \"\" }}\n{{ $myvar := \"abc\" }}\n{{- required (printf \"%s: something is missing\" $myvar) $someEmptyValue | repeat 0 }}`,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: `execution error at (issue6044:3:4): abc: something is missing`,\n\t\t},\n\t\t{\n\t\t\tname: \"MissingRequiredWithNewlines\",\n\t\t\ttpls: map[string]renderable{\n\t\t\t\t\"issue9981\": {tpl: `{{required \"foo is required\\nmore info after the break\" .Values.foo}}`, vals: vals},\n\t\t\t},\n\t\t\texpected: `execution error at (issue9981:1:2): foo is required\nmore info after the break`,\n\t\t},\n\t\t{\n\t\t\tname: \"FailWithNewlines\",\n\t\t\ttpls: map[string]renderable{\n\t\t\t\t\"issue9981\": {tpl: `{{fail \"something is wrong\\nlinebreak\"}}`, vals: vals},\n\t\t\t},\n\t\t\texpected: `execution error at (issue9981:1:2): something is wrong\nlinebreak`,\n\t\t},\n\t}\n\n\tfor _, tt := range cases {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\t_, err := new(Engine).render(tt.tpls)\n\t\t\tif err == nil {\n\t\t\t\tt.Fatalf(\"Expected failures while rendering: %s\", err)\n\t\t\t}\n\t\t\tif err.Error() != tt.expected {\n\t\t\t\tt.Errorf(\"Expected %q, got %q\", tt.expected, err.Error())\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestFailErrors(t *testing.T) {\n\tvals := chartutil.Values{\"Values\": map[string]interface{}{}}\n\n\tfailtpl := `All your base are belong to us{{ fail \"This is an error\" }}`\n\ttplsFailed := map[string]renderable{\n\t\t\"failtpl\": {tpl: failtpl, vals: vals},\n\t}\n\t_, err := new(Engine).render(tplsFailed)\n\tif err == nil {\n\t\tt.Fatalf(\"Expected failures while rendering: %s\", err)\n\t}\n\texpected := `execution error at (failtpl:1:33): This is an error`\n\tif err.Error() != expected {\n\t\tt.Errorf(\"Expected '%s', got %q\", expected, err.Error())\n\t}\n\n\tvar e Engine\n\te.LintMode = true\n\tout, err := e.render(tplsFailed)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\texpectStr := \"All your base are belong to us\"\n\tif gotStr := out[\"failtpl\"]; gotStr != expectStr {\n\t\tt.Errorf(\"Expected %q, got %q (%v)\", expectStr, gotStr, out)\n\t}\n}\n\nfunc TestAllTemplates(t *testing.T) {\n\tch1 := &chart.Chart{\n\t\tMetadata: &chart.Metadata{Name: \"ch1\"},\n\t\tTemplates: []*chart.File{\n\t\t\t{Name: \"templates/foo\", Data: []byte(\"foo\")},\n\t\t\t{Name: \"templates/bar\", Data: []byte(\"bar\")},\n\t\t},\n\t}\n\tdep1 := &chart.Chart{\n\t\tMetadata: &chart.Metadata{Name: \"laboratory mice\"},\n\t\tTemplates: []*chart.File{\n\t\t\t{Name: \"templates/pinky\", Data: []byte(\"pinky\")},\n\t\t\t{Name: \"templates/brain\", Data: []byte(\"brain\")},\n\t\t},\n\t}\n\tch1.AddDependency(dep1)\n\n\tdep2 := &chart.Chart{\n\t\tMetadata: &chart.Metadata{Name: \"same thing we do every night\"},\n\t\tTemplates: []*chart.File{\n\t\t\t{Name: \"templates/innermost\", Data: []byte(\"innermost\")},\n\t\t},\n\t}\n\tdep1.AddDependency(dep2)\n\n\ttpls := allTemplates(ch1, chartutil.Values{})\n\tif len(tpls) != 5 {\n\t\tt.Errorf(\"Expected 5 charts, got %d\", len(tpls))\n\t}\n}\n\nfunc TestChartValuesContainsIsRoot(t *testing.T) {\n\tch1 := &chart.Chart{\n\t\tMetadata: &chart.Metadata{Name: \"parent\"},\n\t\tTemplates: []*chart.File{\n\t\t\t{Name: \"templates/isroot\", Data: []byte(\"{{.Chart.IsRoot}}\")},\n\t\t},\n\t}\n\tdep1 := &chart.Chart{\n\t\tMetadata: &chart.Metadata{Name: \"child\"},\n\t\tTemplates: []*chart.File{\n\t\t\t{Name: \"templates/isroot\", Data: []byte(\"{{.Chart.IsRoot}}\")},\n\t\t},\n\t}\n\tch1.AddDependency(dep1)\n\n\tout, err := Render(ch1, chartutil.Values{})\n\tif err != nil {\n\t\tt.Fatalf(\"failed to render templates: %s\", err)\n\t}\n\texpects := map[string]string{\n\t\t\"parent/charts/child/templates/isroot\": \"false\",\n\t\t\"parent/templates/isroot\":              \"true\",\n\t}\n\tfor file, expect := range expects {\n\t\tif out[file] != expect {\n\t\t\tt.Errorf(\"Expected %q, got %q\", expect, out[file])\n\t\t}\n\t}\n}\n\nfunc TestRenderDependency(t *testing.T) {\n\tdeptpl := `{{define \"myblock\"}}World{{end}}`\n\ttoptpl := `Hello {{template \"myblock\"}}`\n\tch := &chart.Chart{\n\t\tMetadata: &chart.Metadata{Name: \"outerchart\"},\n\t\tTemplates: []*chart.File{\n\t\t\t{Name: \"templates/outer\", Data: []byte(toptpl)},\n\t\t},\n\t}\n\tch.AddDependency(&chart.Chart{\n\t\tMetadata: &chart.Metadata{Name: \"innerchart\"},\n\t\tTemplates: []*chart.File{\n\t\t\t{Name: \"templates/inner\", Data: []byte(deptpl)},\n\t\t},\n\t})\n\n\tout, err := Render(ch, map[string]interface{}{})\n\tif err != nil {\n\t\tt.Fatalf(\"failed to render chart: %s\", err)\n\t}\n\n\tif len(out) != 2 {\n\t\tt.Errorf(\"Expected 2, got %d\", len(out))\n\t}\n\n\texpect := \"Hello World\"\n\tif out[\"outerchart/templates/outer\"] != expect {\n\t\tt.Errorf(\"Expected %q, got %q\", expect, out[\"outer\"])\n\t}\n\n}\n\nfunc TestRenderNestedValues(t *testing.T) {\n\tinnerpath := \"templates/inner.tpl\"\n\touterpath := \"templates/outer.tpl\"\n\t// Ensure namespacing rules are working.\n\tdeepestpath := \"templates/inner.tpl\"\n\tcheckrelease := \"templates/release.tpl\"\n\t// Ensure subcharts scopes are working.\n\tsubchartspath := \"templates/subcharts.tpl\"\n\n\tdeepest := &chart.Chart{\n\t\tMetadata: &chart.Metadata{Name: \"deepest\"},\n\t\tTemplates: []*chart.File{\n\t\t\t{Name: deepestpath, Data: []byte(`And this same {{.Values.what}} that smiles {{.Values.global.when}}`)},\n\t\t\t{Name: checkrelease, Data: []byte(`Tomorrow will be {{default \"happy\" .Release.Name }}`)},\n\t\t},\n\t\tValues: map[string]interface{}{\"what\": \"milkshake\", \"where\": \"here\"},\n\t}\n\n\tinner := &chart.Chart{\n\t\tMetadata: &chart.Metadata{Name: \"herrick\"},\n\t\tTemplates: []*chart.File{\n\t\t\t{Name: innerpath, Data: []byte(`Old {{.Values.who}} is still a-flyin'`)},\n\t\t},\n\t\tValues: map[string]interface{}{\"who\": \"Robert\", \"what\": \"glasses\"},\n\t}\n\tinner.AddDependency(deepest)\n\n\touter := &chart.Chart{\n\t\tMetadata: &chart.Metadata{Name: \"top\"},\n\t\tTemplates: []*chart.File{\n\t\t\t{Name: outerpath, Data: []byte(`Gather ye {{.Values.what}} while ye may`)},\n\t\t\t{Name: subchartspath, Data: []byte(`The glorious Lamp of {{.Subcharts.herrick.Subcharts.deepest.Values.where}}, the {{.Subcharts.herrick.Values.what}}`)},\n\t\t},\n\t\tValues: map[string]interface{}{\n\t\t\t\"what\": \"stinkweed\",\n\t\t\t\"who\":  \"me\",\n\t\t\t\"herrick\": map[string]interface{}{\n\t\t\t\t\"who\":  \"time\",\n\t\t\t\t\"what\": \"Sun\",\n\t\t\t},\n\t\t},\n\t}\n\touter.AddDependency(inner)\n\n\tinjValues := map[string]interface{}{\n\t\t\"what\": \"rosebuds\",\n\t\t\"herrick\": map[string]interface{}{\n\t\t\t\"deepest\": map[string]interface{}{\n\t\t\t\t\"what\":  \"flower\",\n\t\t\t\t\"where\": \"Heaven\",\n\t\t\t},\n\t\t},\n\t\t\"global\": map[string]interface{}{\n\t\t\t\"when\": \"to-day\",\n\t\t},\n\t}\n\n\ttmp, err := chartutil.CoalesceValues(outer, injValues)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to coalesce values: %s\", err)\n\t}\n\n\tinject := chartutil.Values{\n\t\t\"Values\": tmp,\n\t\t\"Chart\":  outer.Metadata,\n\t\t\"Release\": chartutil.Values{\n\t\t\t\"Name\": \"dyin\",\n\t\t},\n\t}\n\n\tt.Logf(\"Calculated values: %v\", inject)\n\n\tout, err := Render(outer, inject)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to render templates: %s\", err)\n\t}\n\n\tfullouterpath := \"top/\" + outerpath\n\tif out[fullouterpath] != \"Gather ye rosebuds while ye may\" {\n\t\tt.Errorf(\"Unexpected outer: %q\", out[fullouterpath])\n\t}\n\n\tfullinnerpath := \"top/charts/herrick/\" + innerpath\n\tif out[fullinnerpath] != \"Old time is still a-flyin'\" {\n\t\tt.Errorf(\"Unexpected inner: %q\", out[fullinnerpath])\n\t}\n\n\tfulldeepestpath := \"top/charts/herrick/charts/deepest/\" + deepestpath\n\tif out[fulldeepestpath] != \"And this same flower that smiles to-day\" {\n\t\tt.Errorf(\"Unexpected deepest: %q\", out[fulldeepestpath])\n\t}\n\n\tfullcheckrelease := \"top/charts/herrick/charts/deepest/\" + checkrelease\n\tif out[fullcheckrelease] != \"Tomorrow will be dyin\" {\n\t\tt.Errorf(\"Unexpected release: %q\", out[fullcheckrelease])\n\t}\n\n\tfullchecksubcharts := \"top/\" + subchartspath\n\tif out[fullchecksubcharts] != \"The glorious Lamp of Heaven, the Sun\" {\n\t\tt.Errorf(\"Unexpected subcharts: %q\", out[fullchecksubcharts])\n\t}\n}\n\nfunc TestRenderBuiltinValues(t *testing.T) {\n\tinner := &chart.Chart{\n\t\tMetadata: &chart.Metadata{Name: \"Latium\"},\n\t\tTemplates: []*chart.File{\n\t\t\t{Name: \"templates/Lavinia\", Data: []byte(`{{.Template.Name}}{{.Chart.Name}}{{.Release.Name}}`)},\n\t\t\t{Name: \"templates/From\", Data: []byte(`{{.Files.author | printf \"%s\"}} {{.Files.Get \"book/title.txt\"}}`)},\n\t\t},\n\t\tFiles: []*chart.File{\n\t\t\t{Name: \"author\", Data: []byte(\"Virgil\")},\n\t\t\t{Name: \"book/title.txt\", Data: []byte(\"Aeneid\")},\n\t\t},\n\t}\n\n\touter := &chart.Chart{\n\t\tMetadata: &chart.Metadata{Name: \"Troy\"},\n\t\tTemplates: []*chart.File{\n\t\t\t{Name: \"templates/Aeneas\", Data: []byte(`{{.Template.Name}}{{.Chart.Name}}{{.Release.Name}}`)},\n\t\t\t{Name: \"templates/Amata\", Data: []byte(`{{.Subcharts.Latium.Chart.Name}} {{.Subcharts.Latium.Files.author | printf \"%s\"}}`)},\n\t\t},\n\t}\n\touter.AddDependency(inner)\n\n\tinject := chartutil.Values{\n\t\t\"Values\": \"\",\n\t\t\"Chart\":  outer.Metadata,\n\t\t\"Release\": chartutil.Values{\n\t\t\t\"Name\": \"Aeneid\",\n\t\t},\n\t}\n\n\tt.Logf(\"Calculated values: %v\", outer)\n\n\tout, err := Render(outer, inject)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to render templates: %s\", err)\n\t}\n\n\texpects := map[string]string{\n\t\t\"Troy/charts/Latium/templates/Lavinia\": \"Troy/charts/Latium/templates/LaviniaLatiumAeneid\",\n\t\t\"Troy/templates/Aeneas\":                \"Troy/templates/AeneasTroyAeneid\",\n\t\t\"Troy/templates/Amata\":                 \"Latium Virgil\",\n\t\t\"Troy/charts/Latium/templates/From\":    \"Virgil Aeneid\",\n\t}\n\tfor file, expect := range expects {\n\t\tif out[file] != expect {\n\t\t\tt.Errorf(\"Expected %q, got %q\", expect, out[file])\n\t\t}\n\t}\n\n}\n\nfunc TestAlterFuncMap_include(t *testing.T) {\n\tc := &chart.Chart{\n\t\tMetadata: &chart.Metadata{Name: \"conrad\"},\n\t\tTemplates: []*chart.File{\n\t\t\t{Name: \"templates/quote\", Data: []byte(`{{include \"conrad/templates/_partial\" . | indent 2}} dead.`)},\n\t\t\t{Name: \"templates/_partial\", Data: []byte(`{{.Release.Name}} - he`)},\n\t\t},\n\t}\n\n\t// Check nested reference in include FuncMap\n\td := &chart.Chart{\n\t\tMetadata: &chart.Metadata{Name: \"nested\"},\n\t\tTemplates: []*chart.File{\n\t\t\t{Name: \"templates/quote\", Data: []byte(`{{include \"nested/templates/quote\" . | indent 2}} dead.`)},\n\t\t\t{Name: \"templates/_partial\", Data: []byte(`{{.Release.Name}} - he`)},\n\t\t},\n\t}\n\n\tv := chartutil.Values{\n\t\t\"Values\": \"\",\n\t\t\"Chart\":  c.Metadata,\n\t\t\"Release\": chartutil.Values{\n\t\t\t\"Name\": \"Mistah Kurtz\",\n\t\t},\n\t}\n\n\tout, err := Render(c, v)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\texpect := \"  Mistah Kurtz - he dead.\"\n\tif got := out[\"conrad/templates/quote\"]; got != expect {\n\t\tt.Errorf(\"Expected %q, got %q (%v)\", expect, got, out)\n\t}\n\n\t_, err = Render(d, v)\n\texpectErrName := \"nested/templates/quote\"\n\tif err == nil {\n\t\tt.Errorf(\"Expected err of nested reference name: %v\", expectErrName)\n\t}\n}\n\nfunc TestAlterFuncMap_require(t *testing.T) {\n\tc := &chart.Chart{\n\t\tMetadata: &chart.Metadata{Name: \"conan\"},\n\t\tTemplates: []*chart.File{\n\t\t\t{Name: \"templates/quote\", Data: []byte(`All your base are belong to {{ required \"A valid 'who' is required\" .Values.who }}`)},\n\t\t\t{Name: \"templates/bases\", Data: []byte(`All {{ required \"A valid 'bases' is required\" .Values.bases }} of them!`)},\n\t\t},\n\t}\n\n\tv := chartutil.Values{\n\t\t\"Values\": chartutil.Values{\n\t\t\t\"who\":   \"us\",\n\t\t\t\"bases\": 2,\n\t\t},\n\t\t\"Chart\": c.Metadata,\n\t\t\"Release\": chartutil.Values{\n\t\t\t\"Name\": \"That 90s meme\",\n\t\t},\n\t}\n\n\tout, err := Render(c, v)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\texpectStr := \"All your base are belong to us\"\n\tif gotStr := out[\"conan/templates/quote\"]; gotStr != expectStr {\n\t\tt.Errorf(\"Expected %q, got %q (%v)\", expectStr, gotStr, out)\n\t}\n\texpectNum := \"All 2 of them!\"\n\tif gotNum := out[\"conan/templates/bases\"]; gotNum != expectNum {\n\t\tt.Errorf(\"Expected %q, got %q (%v)\", expectNum, gotNum, out)\n\t}\n\n\t// test required without passing in needed values with lint mode on\n\t// verifies lint replaces required with an empty string (should not fail)\n\tlintValues := chartutil.Values{\n\t\t\"Values\": chartutil.Values{\n\t\t\t\"who\": \"us\",\n\t\t},\n\t\t\"Chart\": c.Metadata,\n\t\t\"Release\": chartutil.Values{\n\t\t\t\"Name\": \"That 90s meme\",\n\t\t},\n\t}\n\tvar e Engine\n\te.LintMode = true\n\tout, err = e.Render(c, lintValues)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\texpectStr = \"All your base are belong to us\"\n\tif gotStr := out[\"conan/templates/quote\"]; gotStr != expectStr {\n\t\tt.Errorf(\"Expected %q, got %q (%v)\", expectStr, gotStr, out)\n\t}\n\texpectNum = \"All  of them!\"\n\tif gotNum := out[\"conan/templates/bases\"]; gotNum != expectNum {\n\t\tt.Errorf(\"Expected %q, got %q (%v)\", expectNum, gotNum, out)\n\t}\n}\n\nfunc TestAlterFuncMap_tpl(t *testing.T) {\n\tc := &chart.Chart{\n\t\tMetadata: &chart.Metadata{Name: \"TplFunction\"},\n\t\tTemplates: []*chart.File{\n\t\t\t{Name: \"templates/base\", Data: []byte(`Evaluate tpl {{tpl \"Value: {{ .Values.value}}\" .}}`)},\n\t\t},\n\t}\n\n\tv := chartutil.Values{\n\t\t\"Values\": chartutil.Values{\n\t\t\t\"value\": \"myvalue\",\n\t\t},\n\t\t\"Chart\": c.Metadata,\n\t\t\"Release\": chartutil.Values{\n\t\t\t\"Name\": \"TestRelease\",\n\t\t},\n\t}\n\n\tout, err := Render(c, v)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\texpect := \"Evaluate tpl Value: myvalue\"\n\tif got := out[\"TplFunction/templates/base\"]; got != expect {\n\t\tt.Errorf(\"Expected %q, got %q (%v)\", expect, got, out)\n\t}\n}\n\nfunc TestAlterFuncMap_tplfunc(t *testing.T) {\n\tc := &chart.Chart{\n\t\tMetadata: &chart.Metadata{Name: \"TplFunction\"},\n\t\tTemplates: []*chart.File{\n\t\t\t{Name: \"templates/base\", Data: []byte(`Evaluate tpl {{tpl \"Value: {{ .Values.value | quote}}\" .}}`)},\n\t\t},\n\t}\n\n\tv := chartutil.Values{\n\t\t\"Values\": chartutil.Values{\n\t\t\t\"value\": \"myvalue\",\n\t\t},\n\t\t\"Chart\": c.Metadata,\n\t\t\"Release\": chartutil.Values{\n\t\t\t\"Name\": \"TestRelease\",\n\t\t},\n\t}\n\n\tout, err := Render(c, v)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\texpect := \"Evaluate tpl Value: \\\"myvalue\\\"\"\n\tif got := out[\"TplFunction/templates/base\"]; got != expect {\n\t\tt.Errorf(\"Expected %q, got %q (%v)\", expect, got, out)\n\t}\n}\n\nfunc TestAlterFuncMap_tplinclude(t *testing.T) {\n\tc := &chart.Chart{\n\t\tMetadata: &chart.Metadata{Name: \"TplFunction\"},\n\t\tTemplates: []*chart.File{\n\t\t\t{Name: \"templates/base\", Data: []byte(`{{ tpl \"{{include ` + \"`\" + `TplFunction/templates/_partial` + \"`\" + ` .  | quote }}\" .}}`)},\n\t\t\t{Name: \"templates/_partial\", Data: []byte(`{{.Template.Name}}`)},\n\t\t},\n\t}\n\tv := chartutil.Values{\n\t\t\"Values\": chartutil.Values{\n\t\t\t\"value\": \"myvalue\",\n\t\t},\n\t\t\"Chart\": c.Metadata,\n\t\t\"Release\": chartutil.Values{\n\t\t\t\"Name\": \"TestRelease\",\n\t\t},\n\t}\n\n\tout, err := Render(c, v)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\texpect := \"\\\"TplFunction/templates/base\\\"\"\n\tif got := out[\"TplFunction/templates/base\"]; got != expect {\n\t\tt.Errorf(\"Expected %q, got %q (%v)\", expect, got, out)\n\t}\n\n}\n\nfunc TestRenderRecursionLimit(t *testing.T) {\n\t// endless recursion should produce an error\n\tc := &chart.Chart{\n\t\tMetadata: &chart.Metadata{Name: \"bad\"},\n\t\tTemplates: []*chart.File{\n\t\t\t{Name: \"templates/base\", Data: []byte(`{{include \"recursion\" . }}`)},\n\t\t\t{Name: \"templates/recursion\", Data: []byte(`{{define \"recursion\"}}{{include \"recursion\" . }}{{end}}`)},\n\t\t},\n\t}\n\tv := chartutil.Values{\n\t\t\"Values\": \"\",\n\t\t\"Chart\":  c.Metadata,\n\t\t\"Release\": chartutil.Values{\n\t\t\t\"Name\": \"TestRelease\",\n\t\t},\n\t}\n\texpectErr := \"rendering template has a nested reference name: recursion: unable to execute template\"\n\n\t_, err := Render(c, v)\n\tif err == nil || !strings.HasSuffix(err.Error(), expectErr) {\n\t\tt.Errorf(\"Expected err with suffix: %s\", expectErr)\n\t}\n\n\t// calling the same function many times is ok\n\ttimes := 4000\n\tphrase := \"All work and no play makes Jack a dull boy\"\n\tprintFunc := `{{define \"overlook\"}}{{printf \"` + phrase + `\\n\"}}{{end}}`\n\tvar repeatedIncl string\n\tfor i := 0; i < times; i++ {\n\t\trepeatedIncl += `{{include \"overlook\" . }}`\n\t}\n\n\td := &chart.Chart{\n\t\tMetadata: &chart.Metadata{Name: \"overlook\"},\n\t\tTemplates: []*chart.File{\n\t\t\t{Name: \"templates/quote\", Data: []byte(repeatedIncl)},\n\t\t\t{Name: \"templates/_function\", Data: []byte(printFunc)},\n\t\t},\n\t}\n\n\tout, err := Render(d, v)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tvar expect string\n\tfor i := 0; i < times; i++ {\n\t\texpect += phrase + \"\\n\"\n\t}\n\tif got := out[\"overlook/templates/quote\"]; got != expect {\n\t\tt.Errorf(\"Expected %q, got %q (%v)\", expect, got, out)\n\t}\n\n}\n"], "fixing_code": ["/*\nCopyright The Helm Authors.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\npackage main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"os\"\n\t\"os/signal\"\n\t\"syscall\"\n\t\"time\"\n\n\t\"github.com/pkg/errors\"\n\t\"github.com/spf13/cobra\"\n\t\"github.com/spf13/pflag\"\n\n\t\"helm.sh/helm/v3/cmd/helm/require\"\n\t\"helm.sh/helm/v3/pkg/action\"\n\t\"helm.sh/helm/v3/pkg/chart\"\n\t\"helm.sh/helm/v3/pkg/chart/loader\"\n\t\"helm.sh/helm/v3/pkg/cli/output\"\n\t\"helm.sh/helm/v3/pkg/cli/values\"\n\t\"helm.sh/helm/v3/pkg/downloader\"\n\t\"helm.sh/helm/v3/pkg/getter\"\n\t\"helm.sh/helm/v3/pkg/release\"\n)\n\nconst installDesc = `\nThis command installs a chart archive.\n\nThe install argument must be a chart reference, a path to a packaged chart,\na path to an unpacked chart directory or a URL.\n\nTo override values in a chart, use either the '--values' flag and pass in a file\nor use the '--set' flag and pass configuration from the command line, to force\na string value use '--set-string'. You can use '--set-file' to set individual\nvalues from a file when the value itself is too long for the command line\nor is dynamically generated. You can also use '--set-json' to set json values\n(scalars/objects/arrays) from the command line.\n\n    $ helm install -f myvalues.yaml myredis ./redis\n\nor\n\n    $ helm install --set name=prod myredis ./redis\n\nor\n\n    $ helm install --set-string long_int=1234567890 myredis ./redis\n\nor\n\n    $ helm install --set-file my_script=dothings.sh myredis ./redis\n\nor\n\n    $ helm install --set-json 'master.sidecars=[{\"name\":\"sidecar\",\"image\":\"myImage\",\"imagePullPolicy\":\"Always\",\"ports\":[{\"name\":\"portname\",\"containerPort\":1234}]}]' myredis ./redis\n\n\nYou can specify the '--values'/'-f' flag multiple times. The priority will be given to the\nlast (right-most) file specified. For example, if both myvalues.yaml and override.yaml\ncontained a key called 'Test', the value set in override.yaml would take precedence:\n\n    $ helm install -f myvalues.yaml -f override.yaml  myredis ./redis\n\nYou can specify the '--set' flag multiple times. The priority will be given to the\nlast (right-most) set specified. For example, if both 'bar' and 'newbar' values are\nset for a key called 'foo', the 'newbar' value would take precedence:\n\n    $ helm install --set foo=bar --set foo=newbar  myredis ./redis\n\nSimilarly, in the following example 'foo' is set to '[\"four\"]': \n\n    $ helm install --set-json='foo=[\"one\", \"two\", \"three\"]' --set-json='foo=[\"four\"]' myredis ./redis\n\nAnd in the following example, 'foo' is set to '{\"key1\":\"value1\",\"key2\":\"bar\"}':\n\n    $ helm install --set-json='foo={\"key1\":\"value1\",\"key2\":\"value2\"}' --set-json='foo.key2=\"bar\"' myredis ./redis\n\nTo check the generated manifests of a release without installing the chart,\nthe '--debug' and '--dry-run' flags can be combined.\n\nIf --verify is set, the chart MUST have a provenance file, and the provenance\nfile MUST pass all verification steps.\n\nThere are six different ways you can express the chart you want to install:\n\n1. By chart reference: helm install mymaria example/mariadb\n2. By path to a packaged chart: helm install mynginx ./nginx-1.2.3.tgz\n3. By path to an unpacked chart directory: helm install mynginx ./nginx\n4. By absolute URL: helm install mynginx https://example.com/charts/nginx-1.2.3.tgz\n5. By chart reference and repo url: helm install --repo https://example.com/charts/ mynginx nginx\n6. By OCI registries: helm install mynginx --version 1.2.3 oci://example.com/charts/nginx\n\nCHART REFERENCES\n\nA chart reference is a convenient way of referencing a chart in a chart repository.\n\nWhen you use a chart reference with a repo prefix ('example/mariadb'), Helm will look in the local\nconfiguration for a chart repository named 'example', and will then look for a\nchart in that repository whose name is 'mariadb'. It will install the latest stable version of that chart\nuntil you specify '--devel' flag to also include development version (alpha, beta, and release candidate releases), or\nsupply a version number with the '--version' flag.\n\nTo see the list of chart repositories, use 'helm repo list'. To search for\ncharts in a repository, use 'helm search'.\n`\n\nfunc newInstallCmd(cfg *action.Configuration, out io.Writer) *cobra.Command {\n\tclient := action.NewInstall(cfg)\n\tvalueOpts := &values.Options{}\n\tvar outfmt output.Format\n\n\tcmd := &cobra.Command{\n\t\tUse:   \"install [NAME] [CHART]\",\n\t\tShort: \"install a chart\",\n\t\tLong:  installDesc,\n\t\tArgs:  require.MinimumNArgs(1),\n\t\tValidArgsFunction: func(cmd *cobra.Command, args []string, toComplete string) ([]string, cobra.ShellCompDirective) {\n\t\t\treturn compInstall(args, toComplete, client)\n\t\t},\n\t\tRunE: func(_ *cobra.Command, args []string) error {\n\t\t\trel, err := runInstall(args, client, valueOpts, out)\n\t\t\tif err != nil {\n\t\t\t\treturn errors.Wrap(err, \"INSTALLATION FAILED\")\n\t\t\t}\n\n\t\t\treturn outfmt.Write(out, &statusPrinter{rel, settings.Debug, false, false})\n\t\t},\n\t}\n\n\taddInstallFlags(cmd, cmd.Flags(), client, valueOpts)\n\tbindOutputFlag(cmd, &outfmt)\n\tbindPostRenderFlag(cmd, &client.PostRenderer)\n\n\treturn cmd\n}\n\nfunc addInstallFlags(cmd *cobra.Command, f *pflag.FlagSet, client *action.Install, valueOpts *values.Options) {\n\tf.BoolVar(&client.CreateNamespace, \"create-namespace\", false, \"create the release namespace if not present\")\n\tf.BoolVar(&client.DryRun, \"dry-run\", false, \"simulate an install\")\n\tf.BoolVar(&client.Force, \"force\", false, \"force resource updates through a replacement strategy\")\n\tf.BoolVar(&client.DisableHooks, \"no-hooks\", false, \"prevent hooks from running during install\")\n\tf.BoolVar(&client.Replace, \"replace\", false, \"re-use the given name, only if that name is a deleted release which remains in the history. This is unsafe in production\")\n\tf.DurationVar(&client.Timeout, \"timeout\", 300*time.Second, \"time to wait for any individual Kubernetes operation (like Jobs for hooks)\")\n\tf.BoolVar(&client.Wait, \"wait\", false, \"if set, will wait until all Pods, PVCs, Services, and minimum number of Pods of a Deployment, StatefulSet, or ReplicaSet are in a ready state before marking the release as successful. It will wait for as long as --timeout\")\n\tf.BoolVar(&client.WaitForJobs, \"wait-for-jobs\", false, \"if set and --wait enabled, will wait until all Jobs have been completed before marking the release as successful. It will wait for as long as --timeout\")\n\tf.BoolVarP(&client.GenerateName, \"generate-name\", \"g\", false, \"generate the name (and omit the NAME parameter)\")\n\tf.StringVar(&client.NameTemplate, \"name-template\", \"\", \"specify template used to name the release\")\n\tf.StringVar(&client.Description, \"description\", \"\", \"add a custom description\")\n\tf.BoolVar(&client.Devel, \"devel\", false, \"use development versions, too. Equivalent to version '>0.0.0-0'. If --version is set, this is ignored\")\n\tf.BoolVar(&client.DependencyUpdate, \"dependency-update\", false, \"update dependencies if they are missing before installing the chart\")\n\tf.BoolVar(&client.DisableOpenAPIValidation, \"disable-openapi-validation\", false, \"if set, the installation process will not validate rendered templates against the Kubernetes OpenAPI Schema\")\n\tf.BoolVar(&client.Atomic, \"atomic\", false, \"if set, the installation process deletes the installation on failure. The --wait flag will be set automatically if --atomic is used\")\n\tf.BoolVar(&client.SkipCRDs, \"skip-crds\", false, \"if set, no CRDs will be installed. By default, CRDs are installed if not already present\")\n\tf.BoolVar(&client.SubNotes, \"render-subchart-notes\", false, \"if set, render subchart notes along with the parent\")\n\tf.BoolVar(&client.EnableDNS, \"enable-dns\", false, \"enable DNS lookups when rendering templates\")\n\taddValueOptionsFlags(f, valueOpts)\n\taddChartPathOptionsFlags(f, &client.ChartPathOptions)\n\n\terr := cmd.RegisterFlagCompletionFunc(\"version\", func(cmd *cobra.Command, args []string, toComplete string) ([]string, cobra.ShellCompDirective) {\n\t\trequiredArgs := 2\n\t\tif client.GenerateName {\n\t\t\trequiredArgs = 1\n\t\t}\n\t\tif len(args) != requiredArgs {\n\t\t\treturn nil, cobra.ShellCompDirectiveNoFileComp\n\t\t}\n\t\treturn compVersionFlag(args[requiredArgs-1], toComplete)\n\t})\n\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n}\n\nfunc runInstall(args []string, client *action.Install, valueOpts *values.Options, out io.Writer) (*release.Release, error) {\n\tdebug(\"Original chart version: %q\", client.Version)\n\tif client.Version == \"\" && client.Devel {\n\t\tdebug(\"setting version to >0.0.0-0\")\n\t\tclient.Version = \">0.0.0-0\"\n\t}\n\n\tname, chart, err := client.NameAndChart(args)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tclient.ReleaseName = name\n\n\tcp, err := client.ChartPathOptions.LocateChart(chart, settings)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tdebug(\"CHART PATH: %s\\n\", cp)\n\n\tp := getter.All(settings)\n\tvals, err := valueOpts.MergeValues(p)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Check chart dependencies to make sure all are present in /charts\n\tchartRequested, err := loader.Load(cp)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif err := checkIfInstallable(chartRequested); err != nil {\n\t\treturn nil, err\n\t}\n\n\tif chartRequested.Metadata.Deprecated {\n\t\twarning(\"This chart is deprecated\")\n\t}\n\n\tif req := chartRequested.Metadata.Dependencies; req != nil {\n\t\t// If CheckDependencies returns an error, we have unfulfilled dependencies.\n\t\t// As of Helm 2.4.0, this is treated as a stopping condition:\n\t\t// https://github.com/helm/helm/issues/2209\n\t\tif err := action.CheckDependencies(chartRequested, req); err != nil {\n\t\t\terr = errors.Wrap(err, \"An error occurred while checking for chart dependencies. You may need to run `helm dependency build` to fetch missing dependencies\")\n\t\t\tif client.DependencyUpdate {\n\t\t\t\tman := &downloader.Manager{\n\t\t\t\t\tOut:              out,\n\t\t\t\t\tChartPath:        cp,\n\t\t\t\t\tKeyring:          client.ChartPathOptions.Keyring,\n\t\t\t\t\tSkipUpdate:       false,\n\t\t\t\t\tGetters:          p,\n\t\t\t\t\tRepositoryConfig: settings.RepositoryConfig,\n\t\t\t\t\tRepositoryCache:  settings.RepositoryCache,\n\t\t\t\t\tDebug:            settings.Debug,\n\t\t\t\t}\n\t\t\t\tif err := man.Update(); err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t\t// Reload the chart with the updated Chart.lock file.\n\t\t\t\tif chartRequested, err = loader.Load(cp); err != nil {\n\t\t\t\t\treturn nil, errors.Wrap(err, \"failed reloading chart after repo update\")\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\t}\n\n\tclient.Namespace = settings.Namespace()\n\n\t// Create context and prepare the handle of SIGTERM\n\tctx := context.Background()\n\tctx, cancel := context.WithCancel(ctx)\n\n\t// Set up channel on which to send signal notifications.\n\t// We must use a buffered channel or risk missing the signal\n\t// if we're not ready to receive when the signal is sent.\n\tcSignal := make(chan os.Signal, 2)\n\tsignal.Notify(cSignal, os.Interrupt, syscall.SIGTERM)\n\tgo func() {\n\t\t<-cSignal\n\t\tfmt.Fprintf(out, \"Release %s has been cancelled.\\n\", args[0])\n\t\tcancel()\n\t}()\n\n\treturn client.RunWithContext(ctx, chartRequested, vals)\n}\n\n// checkIfInstallable validates if a chart can be installed\n//\n// Application chart type is only installable\nfunc checkIfInstallable(ch *chart.Chart) error {\n\tswitch ch.Metadata.Type {\n\tcase \"\", \"application\":\n\t\treturn nil\n\t}\n\treturn errors.Errorf(\"%s charts are not installable\", ch.Metadata.Type)\n}\n\n// Provide dynamic auto-completion for the install and template commands\nfunc compInstall(args []string, toComplete string, client *action.Install) ([]string, cobra.ShellCompDirective) {\n\trequiredArgs := 1\n\tif client.GenerateName {\n\t\trequiredArgs = 0\n\t}\n\tif len(args) == requiredArgs {\n\t\treturn compListCharts(toComplete, true)\n\t}\n\treturn nil, cobra.ShellCompDirectiveNoFileComp\n}\n", "/*\nCopyright The Helm Authors.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\npackage main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"os\"\n\t\"os/signal\"\n\t\"syscall\"\n\t\"time\"\n\n\t\"github.com/pkg/errors\"\n\t\"github.com/spf13/cobra\"\n\n\t\"helm.sh/helm/v3/cmd/helm/require\"\n\t\"helm.sh/helm/v3/pkg/action\"\n\t\"helm.sh/helm/v3/pkg/chart/loader\"\n\t\"helm.sh/helm/v3/pkg/cli/output\"\n\t\"helm.sh/helm/v3/pkg/cli/values\"\n\t\"helm.sh/helm/v3/pkg/downloader\"\n\t\"helm.sh/helm/v3/pkg/getter\"\n\t\"helm.sh/helm/v3/pkg/storage/driver\"\n)\n\nconst upgradeDesc = `\nThis command upgrades a release to a new version of a chart.\n\nThe upgrade arguments must be a release and chart. The chart\nargument can be either: a chart reference('example/mariadb'), a path to a chart directory,\na packaged chart, or a fully qualified URL. For chart references, the latest\nversion will be specified unless the '--version' flag is set.\n\nTo override values in a chart, use either the '--values' flag and pass in a file\nor use the '--set' flag and pass configuration from the command line, to force string\nvalues, use '--set-string'. You can use '--set-file' to set individual\nvalues from a file when the value itself is too long for the command line\nor is dynamically generated. You can also use '--set-json' to set json values\n(scalars/objects/arrays) from the command line.\n\nYou can specify the '--values'/'-f' flag multiple times. The priority will be given to the\nlast (right-most) file specified. For example, if both myvalues.yaml and override.yaml\ncontained a key called 'Test', the value set in override.yaml would take precedence:\n\n    $ helm upgrade -f myvalues.yaml -f override.yaml redis ./redis\n\nYou can specify the '--set' flag multiple times. The priority will be given to the\nlast (right-most) set specified. For example, if both 'bar' and 'newbar' values are\nset for a key called 'foo', the 'newbar' value would take precedence:\n\n    $ helm upgrade --set foo=bar --set foo=newbar redis ./redis\n`\n\nfunc newUpgradeCmd(cfg *action.Configuration, out io.Writer) *cobra.Command {\n\tclient := action.NewUpgrade(cfg)\n\tvalueOpts := &values.Options{}\n\tvar outfmt output.Format\n\tvar createNamespace bool\n\n\tcmd := &cobra.Command{\n\t\tUse:   \"upgrade [RELEASE] [CHART]\",\n\t\tShort: \"upgrade a release\",\n\t\tLong:  upgradeDesc,\n\t\tArgs:  require.ExactArgs(2),\n\t\tValidArgsFunction: func(cmd *cobra.Command, args []string, toComplete string) ([]string, cobra.ShellCompDirective) {\n\t\t\tif len(args) == 0 {\n\t\t\t\treturn compListReleases(toComplete, args, cfg)\n\t\t\t}\n\t\t\tif len(args) == 1 {\n\t\t\t\treturn compListCharts(toComplete, true)\n\t\t\t}\n\t\t\treturn nil, cobra.ShellCompDirectiveNoFileComp\n\t\t},\n\t\tRunE: func(cmd *cobra.Command, args []string) error {\n\t\t\tclient.Namespace = settings.Namespace()\n\n\t\t\t// Fixes #7002 - Support reading values from STDIN for `upgrade` command\n\t\t\t// Must load values AFTER determining if we have to call install so that values loaded from stdin are are not read twice\n\t\t\tif client.Install {\n\t\t\t\t// If a release does not exist, install it.\n\t\t\t\thistClient := action.NewHistory(cfg)\n\t\t\t\thistClient.Max = 1\n\t\t\t\tif _, err := histClient.Run(args[0]); err == driver.ErrReleaseNotFound {\n\t\t\t\t\t// Only print this to stdout for table output\n\t\t\t\t\tif outfmt == output.Table {\n\t\t\t\t\t\tfmt.Fprintf(out, \"Release %q does not exist. Installing it now.\\n\", args[0])\n\t\t\t\t\t}\n\t\t\t\t\tinstClient := action.NewInstall(cfg)\n\t\t\t\t\tinstClient.CreateNamespace = createNamespace\n\t\t\t\t\tinstClient.ChartPathOptions = client.ChartPathOptions\n\t\t\t\t\tinstClient.Force = client.Force\n\t\t\t\t\tinstClient.DryRun = client.DryRun\n\t\t\t\t\tinstClient.DisableHooks = client.DisableHooks\n\t\t\t\t\tinstClient.SkipCRDs = client.SkipCRDs\n\t\t\t\t\tinstClient.Timeout = client.Timeout\n\t\t\t\t\tinstClient.Wait = client.Wait\n\t\t\t\t\tinstClient.WaitForJobs = client.WaitForJobs\n\t\t\t\t\tinstClient.Devel = client.Devel\n\t\t\t\t\tinstClient.Namespace = client.Namespace\n\t\t\t\t\tinstClient.Atomic = client.Atomic\n\t\t\t\t\tinstClient.PostRenderer = client.PostRenderer\n\t\t\t\t\tinstClient.DisableOpenAPIValidation = client.DisableOpenAPIValidation\n\t\t\t\t\tinstClient.SubNotes = client.SubNotes\n\t\t\t\t\tinstClient.Description = client.Description\n\t\t\t\t\tinstClient.DependencyUpdate = client.DependencyUpdate\n\t\t\t\t\tinstClient.EnableDNS = client.EnableDNS\n\n\t\t\t\t\trel, err := runInstall(args, instClient, valueOpts, out)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t\treturn outfmt.Write(out, &statusPrinter{rel, settings.Debug, false, false})\n\t\t\t\t} else if err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif client.Version == \"\" && client.Devel {\n\t\t\t\tdebug(\"setting version to >0.0.0-0\")\n\t\t\t\tclient.Version = \">0.0.0-0\"\n\t\t\t}\n\n\t\t\tchartPath, err := client.ChartPathOptions.LocateChart(args[1], settings)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tp := getter.All(settings)\n\t\t\tvals, err := valueOpts.MergeValues(p)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\t// Check chart dependencies to make sure all are present in /charts\n\t\t\tch, err := loader.Load(chartPath)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif req := ch.Metadata.Dependencies; req != nil {\n\t\t\t\tif err := action.CheckDependencies(ch, req); err != nil {\n\t\t\t\t\terr = errors.Wrap(err, \"An error occurred while checking for chart dependencies. You may need to run `helm dependency build` to fetch missing dependencies\")\n\t\t\t\t\tif client.DependencyUpdate {\n\t\t\t\t\t\tman := &downloader.Manager{\n\t\t\t\t\t\t\tOut:              out,\n\t\t\t\t\t\t\tChartPath:        chartPath,\n\t\t\t\t\t\t\tKeyring:          client.ChartPathOptions.Keyring,\n\t\t\t\t\t\t\tSkipUpdate:       false,\n\t\t\t\t\t\t\tGetters:          p,\n\t\t\t\t\t\t\tRepositoryConfig: settings.RepositoryConfig,\n\t\t\t\t\t\t\tRepositoryCache:  settings.RepositoryCache,\n\t\t\t\t\t\t\tDebug:            settings.Debug,\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif err := man.Update(); err != nil {\n\t\t\t\t\t\t\treturn err\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Reload the chart with the updated Chart.lock file.\n\t\t\t\t\t\tif ch, err = loader.Load(chartPath); err != nil {\n\t\t\t\t\t\t\treturn errors.Wrap(err, \"failed reloading chart after repo update\")\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ch.Metadata.Deprecated {\n\t\t\t\twarning(\"This chart is deprecated\")\n\t\t\t}\n\n\t\t\t// Create context and prepare the handle of SIGTERM\n\t\t\tctx := context.Background()\n\t\t\tctx, cancel := context.WithCancel(ctx)\n\n\t\t\t// Set up channel on which to send signal notifications.\n\t\t\t// We must use a buffered channel or risk missing the signal\n\t\t\t// if we're not ready to receive when the signal is sent.\n\t\t\tcSignal := make(chan os.Signal, 2)\n\t\t\tsignal.Notify(cSignal, os.Interrupt, syscall.SIGTERM)\n\t\t\tgo func() {\n\t\t\t\t<-cSignal\n\t\t\t\tfmt.Fprintf(out, \"Release %s has been cancelled.\\n\", args[0])\n\t\t\t\tcancel()\n\t\t\t}()\n\n\t\t\trel, err := client.RunWithContext(ctx, args[0], ch, vals)\n\t\t\tif err != nil {\n\t\t\t\treturn errors.Wrap(err, \"UPGRADE FAILED\")\n\t\t\t}\n\n\t\t\tif outfmt == output.Table {\n\t\t\t\tfmt.Fprintf(out, \"Release %q has been upgraded. Happy Helming!\\n\", args[0])\n\t\t\t}\n\n\t\t\treturn outfmt.Write(out, &statusPrinter{rel, settings.Debug, false, false})\n\t\t},\n\t}\n\n\tf := cmd.Flags()\n\tf.BoolVar(&createNamespace, \"create-namespace\", false, \"if --install is set, create the release namespace if not present\")\n\tf.BoolVarP(&client.Install, \"install\", \"i\", false, \"if a release by this name doesn't already exist, run an install\")\n\tf.BoolVar(&client.Devel, \"devel\", false, \"use development versions, too. Equivalent to version '>0.0.0-0'. If --version is set, this is ignored\")\n\tf.BoolVar(&client.DryRun, \"dry-run\", false, \"simulate an upgrade\")\n\tf.BoolVar(&client.Recreate, \"recreate-pods\", false, \"performs pods restart for the resource if applicable\")\n\tf.MarkDeprecated(\"recreate-pods\", \"functionality will no longer be updated. Consult the documentation for other methods to recreate pods\")\n\tf.BoolVar(&client.Force, \"force\", false, \"force resource updates through a replacement strategy\")\n\tf.BoolVar(&client.DisableHooks, \"no-hooks\", false, \"disable pre/post upgrade hooks\")\n\tf.BoolVar(&client.DisableOpenAPIValidation, \"disable-openapi-validation\", false, \"if set, the upgrade process will not validate rendered templates against the Kubernetes OpenAPI Schema\")\n\tf.BoolVar(&client.SkipCRDs, \"skip-crds\", false, \"if set, no CRDs will be installed when an upgrade is performed with install flag enabled. By default, CRDs are installed if not already present, when an upgrade is performed with install flag enabled\")\n\tf.DurationVar(&client.Timeout, \"timeout\", 300*time.Second, \"time to wait for any individual Kubernetes operation (like Jobs for hooks)\")\n\tf.BoolVar(&client.ResetValues, \"reset-values\", false, \"when upgrading, reset the values to the ones built into the chart\")\n\tf.BoolVar(&client.ReuseValues, \"reuse-values\", false, \"when upgrading, reuse the last release's values and merge in any overrides from the command line via --set and -f. If '--reset-values' is specified, this is ignored\")\n\tf.BoolVar(&client.Wait, \"wait\", false, \"if set, will wait until all Pods, PVCs, Services, and minimum number of Pods of a Deployment, StatefulSet, or ReplicaSet are in a ready state before marking the release as successful. It will wait for as long as --timeout\")\n\tf.BoolVar(&client.WaitForJobs, \"wait-for-jobs\", false, \"if set and --wait enabled, will wait until all Jobs have been completed before marking the release as successful. It will wait for as long as --timeout\")\n\tf.BoolVar(&client.Atomic, \"atomic\", false, \"if set, upgrade process rolls back changes made in case of failed upgrade. The --wait flag will be set automatically if --atomic is used\")\n\tf.IntVar(&client.MaxHistory, \"history-max\", settings.MaxHistory, \"limit the maximum number of revisions saved per release. Use 0 for no limit\")\n\tf.BoolVar(&client.CleanupOnFail, \"cleanup-on-fail\", false, \"allow deletion of new resources created in this upgrade when upgrade fails\")\n\tf.BoolVar(&client.SubNotes, \"render-subchart-notes\", false, \"if set, render subchart notes along with the parent\")\n\tf.StringVar(&client.Description, \"description\", \"\", \"add a custom description\")\n\tf.BoolVar(&client.DependencyUpdate, \"dependency-update\", false, \"update dependencies if they are missing before installing the chart\")\n\tf.BoolVar(&client.EnableDNS, \"enable-dns\", false, \"enable DNS lookups when rendering templates\")\n\taddChartPathOptionsFlags(f, &client.ChartPathOptions)\n\taddValueOptionsFlags(f, valueOpts)\n\tbindOutputFlag(cmd, &outfmt)\n\tbindPostRenderFlag(cmd, &client.PostRenderer)\n\n\terr := cmd.RegisterFlagCompletionFunc(\"version\", func(cmd *cobra.Command, args []string, toComplete string) ([]string, cobra.ShellCompDirective) {\n\t\tif len(args) != 2 {\n\t\t\treturn nil, cobra.ShellCompDirectiveNoFileComp\n\t\t}\n\t\treturn compVersionFlag(args[1], toComplete)\n\t})\n\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\treturn cmd\n}\n", "/*\nCopyright The Helm Authors.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\npackage action\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"os\"\n\t\"path\"\n\t\"path/filepath\"\n\t\"regexp\"\n\t\"strings\"\n\n\t\"github.com/pkg/errors\"\n\t\"k8s.io/apimachinery/pkg/api/meta\"\n\t\"k8s.io/cli-runtime/pkg/genericclioptions\"\n\t\"k8s.io/client-go/discovery\"\n\t\"k8s.io/client-go/kubernetes\"\n\t\"k8s.io/client-go/rest\"\n\n\t\"helm.sh/helm/v3/pkg/chart\"\n\t\"helm.sh/helm/v3/pkg/chartutil\"\n\t\"helm.sh/helm/v3/pkg/engine\"\n\t\"helm.sh/helm/v3/pkg/kube\"\n\t\"helm.sh/helm/v3/pkg/postrender\"\n\t\"helm.sh/helm/v3/pkg/registry\"\n\t\"helm.sh/helm/v3/pkg/release\"\n\t\"helm.sh/helm/v3/pkg/releaseutil\"\n\t\"helm.sh/helm/v3/pkg/storage\"\n\t\"helm.sh/helm/v3/pkg/storage/driver\"\n\t\"helm.sh/helm/v3/pkg/time\"\n)\n\n// Timestamper is a function capable of producing a timestamp.Timestamper.\n//\n// By default, this is a time.Time function from the Helm time package. This can\n// be overridden for testing though, so that timestamps are predictable.\nvar Timestamper = time.Now\n\nvar (\n\t// errMissingChart indicates that a chart was not provided.\n\terrMissingChart = errors.New(\"no chart provided\")\n\t// errMissingRelease indicates that a release (name) was not provided.\n\terrMissingRelease = errors.New(\"no release provided\")\n\t// errInvalidRevision indicates that an invalid release revision number was provided.\n\terrInvalidRevision = errors.New(\"invalid release revision\")\n\t// errPending indicates that another instance of Helm is already applying an operation on a release.\n\terrPending = errors.New(\"another operation (install/upgrade/rollback) is in progress\")\n)\n\n// ValidName is a regular expression for resource names.\n//\n// DEPRECATED: This will be removed in Helm 4, and is no longer used here. See\n// pkg/lint/rules.validateMetadataNameFunc for the replacement.\n//\n// According to the Kubernetes help text, the regular expression it uses is:\n//\n//\t[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*\n//\n// This follows the above regular expression (but requires a full string match, not partial).\n//\n// The Kubernetes documentation is here, though it is not entirely correct:\n// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names\nvar ValidName = regexp.MustCompile(`^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$`)\n\n// Configuration injects the dependencies that all actions share.\ntype Configuration struct {\n\t// RESTClientGetter is an interface that loads Kubernetes clients.\n\tRESTClientGetter RESTClientGetter\n\n\t// Releases stores records of releases.\n\tReleases *storage.Storage\n\n\t// KubeClient is a Kubernetes API client.\n\tKubeClient kube.Interface\n\n\t// RegistryClient is a client for working with registries\n\tRegistryClient *registry.Client\n\n\t// Capabilities describes the capabilities of the Kubernetes cluster.\n\tCapabilities *chartutil.Capabilities\n\n\tLog func(string, ...interface{})\n}\n\n// renderResources renders the templates in a chart\n//\n// TODO: This function is badly in need of a refactor.\n// TODO: As part of the refactor the duplicate code in cmd/helm/template.go should be removed\n//\n//\tThis code has to do with writing files to disk.\nfunc (cfg *Configuration) renderResources(ch *chart.Chart, values chartutil.Values, releaseName, outputDir string, subNotes, useReleaseName, includeCrds bool, pr postrender.PostRenderer, dryRun, enableDNS bool) ([]*release.Hook, *bytes.Buffer, string, error) {\n\ths := []*release.Hook{}\n\tb := bytes.NewBuffer(nil)\n\n\tcaps, err := cfg.getCapabilities()\n\tif err != nil {\n\t\treturn hs, b, \"\", err\n\t}\n\n\tif ch.Metadata.KubeVersion != \"\" {\n\t\tif !chartutil.IsCompatibleRange(ch.Metadata.KubeVersion, caps.KubeVersion.String()) {\n\t\t\treturn hs, b, \"\", errors.Errorf(\"chart requires kubeVersion: %s which is incompatible with Kubernetes %s\", ch.Metadata.KubeVersion, caps.KubeVersion.String())\n\t\t}\n\t}\n\n\tvar files map[string]string\n\tvar err2 error\n\n\t// A `helm template` or `helm install --dry-run` should not talk to the remote cluster.\n\t// It will break in interesting and exotic ways because other data (e.g. discovery)\n\t// is mocked. It is not up to the template author to decide when the user wants to\n\t// connect to the cluster. So when the user says to dry run, respect the user's\n\t// wishes and do not connect to the cluster.\n\tif !dryRun && cfg.RESTClientGetter != nil {\n\t\trestConfig, err := cfg.RESTClientGetter.ToRESTConfig()\n\t\tif err != nil {\n\t\t\treturn hs, b, \"\", err\n\t\t}\n\t\te := engine.New(restConfig)\n\t\te.EnableDNS = enableDNS\n\t\tfiles, err2 = e.Render(ch, values)\n\t} else {\n\t\tvar e engine.Engine\n\t\te.EnableDNS = enableDNS\n\t\tfiles, err2 = e.Render(ch, values)\n\t}\n\n\tif err2 != nil {\n\t\treturn hs, b, \"\", err2\n\t}\n\n\t// NOTES.txt gets rendered like all the other files, but because it's not a hook nor a resource,\n\t// pull it out of here into a separate file so that we can actually use the output of the rendered\n\t// text file. We have to spin through this map because the file contains path information, so we\n\t// look for terminating NOTES.txt. We also remove it from the files so that we don't have to skip\n\t// it in the sortHooks.\n\tvar notesBuffer bytes.Buffer\n\tfor k, v := range files {\n\t\tif strings.HasSuffix(k, notesFileSuffix) {\n\t\t\tif subNotes || (k == path.Join(ch.Name(), \"templates\", notesFileSuffix)) {\n\t\t\t\t// If buffer contains data, add newline before adding more\n\t\t\t\tif notesBuffer.Len() > 0 {\n\t\t\t\t\tnotesBuffer.WriteString(\"\\n\")\n\t\t\t\t}\n\t\t\t\tnotesBuffer.WriteString(v)\n\t\t\t}\n\t\t\tdelete(files, k)\n\t\t}\n\t}\n\tnotes := notesBuffer.String()\n\n\t// Sort hooks, manifests, and partials. Only hooks and manifests are returned,\n\t// as partials are not used after renderer.Render. Empty manifests are also\n\t// removed here.\n\ths, manifests, err := releaseutil.SortManifests(files, caps.APIVersions, releaseutil.InstallOrder)\n\tif err != nil {\n\t\t// By catching parse errors here, we can prevent bogus releases from going\n\t\t// to Kubernetes.\n\t\t//\n\t\t// We return the files as a big blob of data to help the user debug parser\n\t\t// errors.\n\t\tfor name, content := range files {\n\t\t\tif strings.TrimSpace(content) == \"\" {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tfmt.Fprintf(b, \"---\\n# Source: %s\\n%s\\n\", name, content)\n\t\t}\n\t\treturn hs, b, \"\", err\n\t}\n\n\t// Aggregate all valid manifests into one big doc.\n\tfileWritten := make(map[string]bool)\n\n\tif includeCrds {\n\t\tfor _, crd := range ch.CRDObjects() {\n\t\t\tif outputDir == \"\" {\n\t\t\t\tfmt.Fprintf(b, \"---\\n# Source: %s\\n%s\\n\", crd.Name, string(crd.File.Data[:]))\n\t\t\t} else {\n\t\t\t\terr = writeToFile(outputDir, crd.Filename, string(crd.File.Data[:]), fileWritten[crd.Name])\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn hs, b, \"\", err\n\t\t\t\t}\n\t\t\t\tfileWritten[crd.Name] = true\n\t\t\t}\n\t\t}\n\t}\n\n\tfor _, m := range manifests {\n\t\tif outputDir == \"\" {\n\t\t\tfmt.Fprintf(b, \"---\\n# Source: %s\\n%s\\n\", m.Name, m.Content)\n\t\t} else {\n\t\t\tnewDir := outputDir\n\t\t\tif useReleaseName {\n\t\t\t\tnewDir = filepath.Join(outputDir, releaseName)\n\t\t\t}\n\t\t\t// NOTE: We do not have to worry about the post-renderer because\n\t\t\t// output dir is only used by `helm template`. In the next major\n\t\t\t// release, we should move this logic to template only as it is not\n\t\t\t// used by install or upgrade\n\t\t\terr = writeToFile(newDir, m.Name, m.Content, fileWritten[m.Name])\n\t\t\tif err != nil {\n\t\t\t\treturn hs, b, \"\", err\n\t\t\t}\n\t\t\tfileWritten[m.Name] = true\n\t\t}\n\t}\n\n\tif pr != nil {\n\t\tb, err = pr.Run(b)\n\t\tif err != nil {\n\t\t\treturn hs, b, notes, errors.Wrap(err, \"error while running post render on files\")\n\t\t}\n\t}\n\n\treturn hs, b, notes, nil\n}\n\n// RESTClientGetter gets the rest client\ntype RESTClientGetter interface {\n\tToRESTConfig() (*rest.Config, error)\n\tToDiscoveryClient() (discovery.CachedDiscoveryInterface, error)\n\tToRESTMapper() (meta.RESTMapper, error)\n}\n\n// DebugLog sets the logger that writes debug strings\ntype DebugLog func(format string, v ...interface{})\n\n// capabilities builds a Capabilities from discovery information.\nfunc (cfg *Configuration) getCapabilities() (*chartutil.Capabilities, error) {\n\tif cfg.Capabilities != nil {\n\t\treturn cfg.Capabilities, nil\n\t}\n\tdc, err := cfg.RESTClientGetter.ToDiscoveryClient()\n\tif err != nil {\n\t\treturn nil, errors.Wrap(err, \"could not get Kubernetes discovery client\")\n\t}\n\t// force a discovery cache invalidation to always fetch the latest server version/capabilities.\n\tdc.Invalidate()\n\tkubeVersion, err := dc.ServerVersion()\n\tif err != nil {\n\t\treturn nil, errors.Wrap(err, \"could not get server version from Kubernetes\")\n\t}\n\t// Issue #6361:\n\t// Client-Go emits an error when an API service is registered but unimplemented.\n\t// We trap that error here and print a warning. But since the discovery client continues\n\t// building the API object, it is correctly populated with all valid APIs.\n\t// See https://github.com/kubernetes/kubernetes/issues/72051#issuecomment-521157642\n\tapiVersions, err := GetVersionSet(dc)\n\tif err != nil {\n\t\tif discovery.IsGroupDiscoveryFailedError(err) {\n\t\t\tcfg.Log(\"WARNING: The Kubernetes server has an orphaned API service. Server reports: %s\", err)\n\t\t\tcfg.Log(\"WARNING: To fix this, kubectl delete apiservice <service-name>\")\n\t\t} else {\n\t\t\treturn nil, errors.Wrap(err, \"could not get apiVersions from Kubernetes\")\n\t\t}\n\t}\n\n\tcfg.Capabilities = &chartutil.Capabilities{\n\t\tAPIVersions: apiVersions,\n\t\tKubeVersion: chartutil.KubeVersion{\n\t\t\tVersion: kubeVersion.GitVersion,\n\t\t\tMajor:   kubeVersion.Major,\n\t\t\tMinor:   kubeVersion.Minor,\n\t\t},\n\t\tHelmVersion: chartutil.DefaultCapabilities.HelmVersion,\n\t}\n\treturn cfg.Capabilities, nil\n}\n\n// KubernetesClientSet creates a new kubernetes ClientSet based on the configuration\nfunc (cfg *Configuration) KubernetesClientSet() (kubernetes.Interface, error) {\n\tconf, err := cfg.RESTClientGetter.ToRESTConfig()\n\tif err != nil {\n\t\treturn nil, errors.Wrap(err, \"unable to generate config for kubernetes client\")\n\t}\n\n\treturn kubernetes.NewForConfig(conf)\n}\n\n// Now generates a timestamp\n//\n// If the configuration has a Timestamper on it, that will be used.\n// Otherwise, this will use time.Now().\nfunc (cfg *Configuration) Now() time.Time {\n\treturn Timestamper()\n}\n\nfunc (cfg *Configuration) releaseContent(name string, version int) (*release.Release, error) {\n\tif err := chartutil.ValidateReleaseName(name); err != nil {\n\t\treturn nil, errors.Errorf(\"releaseContent: Release name is invalid: %s\", name)\n\t}\n\n\tif version <= 0 {\n\t\treturn cfg.Releases.Last(name)\n\t}\n\n\treturn cfg.Releases.Get(name, version)\n}\n\n// GetVersionSet retrieves a set of available k8s API versions\nfunc GetVersionSet(client discovery.ServerResourcesInterface) (chartutil.VersionSet, error) {\n\tgroups, resources, err := client.ServerGroupsAndResources()\n\tif err != nil && !discovery.IsGroupDiscoveryFailedError(err) {\n\t\treturn chartutil.DefaultVersionSet, errors.Wrap(err, \"could not get apiVersions from Kubernetes\")\n\t}\n\n\t// FIXME: The Kubernetes test fixture for cli appears to always return nil\n\t// for calls to Discovery().ServerGroupsAndResources(). So in this case, we\n\t// return the default API list. This is also a safe value to return in any\n\t// other odd-ball case.\n\tif len(groups) == 0 && len(resources) == 0 {\n\t\treturn chartutil.DefaultVersionSet, nil\n\t}\n\n\tversionMap := make(map[string]interface{})\n\tversions := []string{}\n\n\t// Extract the groups\n\tfor _, g := range groups {\n\t\tfor _, gv := range g.Versions {\n\t\t\tversionMap[gv.GroupVersion] = struct{}{}\n\t\t}\n\t}\n\n\t// Extract the resources\n\tvar id string\n\tvar ok bool\n\tfor _, r := range resources {\n\t\tfor _, rl := range r.APIResources {\n\n\t\t\t// A Kind at a GroupVersion can show up more than once. We only want\n\t\t\t// it displayed once in the final output.\n\t\t\tid = path.Join(r.GroupVersion, rl.Kind)\n\t\t\tif _, ok = versionMap[id]; !ok {\n\t\t\t\tversionMap[id] = struct{}{}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Convert to a form that NewVersionSet can use\n\tfor k := range versionMap {\n\t\tversions = append(versions, k)\n\t}\n\n\treturn chartutil.VersionSet(versions), nil\n}\n\n// recordRelease with an update operation in case reuse has been set.\nfunc (cfg *Configuration) recordRelease(r *release.Release) {\n\tif err := cfg.Releases.Update(r); err != nil {\n\t\tcfg.Log(\"warning: Failed to update release %s: %s\", r.Name, err)\n\t}\n}\n\n// Init initializes the action configuration\nfunc (cfg *Configuration) Init(getter genericclioptions.RESTClientGetter, namespace, helmDriver string, log DebugLog) error {\n\tkc := kube.New(getter)\n\tkc.Log = log\n\n\tlazyClient := &lazyClient{\n\t\tnamespace: namespace,\n\t\tclientFn:  kc.Factory.KubernetesClientSet,\n\t}\n\n\tvar store *storage.Storage\n\tswitch helmDriver {\n\tcase \"secret\", \"secrets\", \"\":\n\t\td := driver.NewSecrets(newSecretClient(lazyClient))\n\t\td.Log = log\n\t\tstore = storage.Init(d)\n\tcase \"configmap\", \"configmaps\":\n\t\td := driver.NewConfigMaps(newConfigMapClient(lazyClient))\n\t\td.Log = log\n\t\tstore = storage.Init(d)\n\tcase \"memory\":\n\t\tvar d *driver.Memory\n\t\tif cfg.Releases != nil {\n\t\t\tif mem, ok := cfg.Releases.Driver.(*driver.Memory); ok {\n\t\t\t\t// This function can be called more than once (e.g., helm list --all-namespaces).\n\t\t\t\t// If a memory driver was already initialized, re-use it but set the possibly new namespace.\n\t\t\t\t// We re-use it in case some releases where already created in the existing memory driver.\n\t\t\t\td = mem\n\t\t\t}\n\t\t}\n\t\tif d == nil {\n\t\t\td = driver.NewMemory()\n\t\t}\n\t\td.SetNamespace(namespace)\n\t\tstore = storage.Init(d)\n\tcase \"sql\":\n\t\td, err := driver.NewSQL(\n\t\t\tos.Getenv(\"HELM_DRIVER_SQL_CONNECTION_STRING\"),\n\t\t\tlog,\n\t\t\tnamespace,\n\t\t)\n\t\tif err != nil {\n\t\t\tpanic(fmt.Sprintf(\"Unable to instantiate SQL driver: %v\", err))\n\t\t}\n\t\tstore = storage.Init(d)\n\tdefault:\n\t\t// Not sure what to do here.\n\t\tpanic(\"Unknown driver in HELM_DRIVER: \" + helmDriver)\n\t}\n\n\tcfg.RESTClientGetter = getter\n\tcfg.KubeClient = kc\n\tcfg.Releases = store\n\tcfg.Log = log\n\n\treturn nil\n}\n", "/*\nCopyright The Helm Authors.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\npackage action\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/url\"\n\t\"os\"\n\t\"path\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"sync\"\n\t\"text/template\"\n\t\"time\"\n\n\t\"github.com/Masterminds/sprig/v3\"\n\t\"github.com/pkg/errors\"\n\tv1 \"k8s.io/api/core/v1\"\n\tapierrors \"k8s.io/apimachinery/pkg/api/errors\"\n\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n\t\"k8s.io/cli-runtime/pkg/resource\"\n\t\"sigs.k8s.io/yaml\"\n\n\t\"helm.sh/helm/v3/pkg/chart\"\n\t\"helm.sh/helm/v3/pkg/chartutil\"\n\t\"helm.sh/helm/v3/pkg/cli\"\n\t\"helm.sh/helm/v3/pkg/downloader\"\n\t\"helm.sh/helm/v3/pkg/getter\"\n\t\"helm.sh/helm/v3/pkg/kube\"\n\tkubefake \"helm.sh/helm/v3/pkg/kube/fake\"\n\t\"helm.sh/helm/v3/pkg/postrender\"\n\t\"helm.sh/helm/v3/pkg/registry\"\n\t\"helm.sh/helm/v3/pkg/release\"\n\t\"helm.sh/helm/v3/pkg/releaseutil\"\n\t\"helm.sh/helm/v3/pkg/repo\"\n\t\"helm.sh/helm/v3/pkg/storage\"\n\t\"helm.sh/helm/v3/pkg/storage/driver\"\n)\n\n// NOTESFILE_SUFFIX that we want to treat special. It goes through the templating engine\n// but it's not a yaml file (resource) hence can't have hooks, etc. And the user actually\n// wants to see this file after rendering in the status command. However, it must be a suffix\n// since there can be filepath in front of it.\nconst notesFileSuffix = \"NOTES.txt\"\n\nconst defaultDirectoryPermission = 0755\n\n// Install performs an installation operation.\ntype Install struct {\n\tcfg *Configuration\n\n\tChartPathOptions\n\n\tClientOnly               bool\n\tForce                    bool\n\tCreateNamespace          bool\n\tDryRun                   bool\n\tDisableHooks             bool\n\tReplace                  bool\n\tWait                     bool\n\tWaitForJobs              bool\n\tDevel                    bool\n\tDependencyUpdate         bool\n\tTimeout                  time.Duration\n\tNamespace                string\n\tReleaseName              string\n\tGenerateName             bool\n\tNameTemplate             string\n\tDescription              string\n\tOutputDir                string\n\tAtomic                   bool\n\tSkipCRDs                 bool\n\tSubNotes                 bool\n\tDisableOpenAPIValidation bool\n\tIncludeCRDs              bool\n\t// KubeVersion allows specifying a custom kubernetes version to use and\n\t// APIVersions allows a manual set of supported API Versions to be passed\n\t// (for things like templating). These are ignored if ClientOnly is false\n\tKubeVersion *chartutil.KubeVersion\n\tAPIVersions chartutil.VersionSet\n\t// Used by helm template to render charts with .Release.IsUpgrade. Ignored if Dry-Run is false\n\tIsUpgrade bool\n\t// Enable DNS lookups when rendering templates\n\tEnableDNS bool\n\t// Used by helm template to add the release as part of OutputDir path\n\t// OutputDir/<ReleaseName>\n\tUseReleaseName bool\n\tPostRenderer   postrender.PostRenderer\n\t// Lock to control raceconditions when the process receives a SIGTERM\n\tLock sync.Mutex\n}\n\n// ChartPathOptions captures common options used for controlling chart paths\ntype ChartPathOptions struct {\n\tCaFile                string // --ca-file\n\tCertFile              string // --cert-file\n\tKeyFile               string // --key-file\n\tInsecureSkipTLSverify bool   // --insecure-skip-verify\n\tKeyring               string // --keyring\n\tPassword              string // --password\n\tPassCredentialsAll    bool   // --pass-credentials\n\tRepoURL               string // --repo\n\tUsername              string // --username\n\tVerify                bool   // --verify\n\tVersion               string // --version\n\n\t// registryClient provides a registry client but is not added with\n\t// options from a flag\n\tregistryClient *registry.Client\n}\n\n// NewInstall creates a new Install object with the given configuration.\nfunc NewInstall(cfg *Configuration) *Install {\n\tin := &Install{\n\t\tcfg: cfg,\n\t}\n\tin.ChartPathOptions.registryClient = cfg.RegistryClient\n\n\treturn in\n}\n\nfunc (i *Install) installCRDs(crds []chart.CRD) error {\n\t// We do these one file at a time in the order they were read.\n\ttotalItems := []*resource.Info{}\n\tfor _, obj := range crds {\n\t\t// Read in the resources\n\t\tres, err := i.cfg.KubeClient.Build(bytes.NewBuffer(obj.File.Data), false)\n\t\tif err != nil {\n\t\t\treturn errors.Wrapf(err, \"failed to install CRD %s\", obj.Name)\n\t\t}\n\n\t\t// Send them to Kube\n\t\tif _, err := i.cfg.KubeClient.Create(res); err != nil {\n\t\t\t// If the error is CRD already exists, continue.\n\t\t\tif apierrors.IsAlreadyExists(err) {\n\t\t\t\tcrdName := res[0].Name\n\t\t\t\ti.cfg.Log(\"CRD %s is already present. Skipping.\", crdName)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn errors.Wrapf(err, \"failed to install CRD %s\", obj.Name)\n\t\t}\n\t\ttotalItems = append(totalItems, res...)\n\t}\n\tif len(totalItems) > 0 {\n\t\t// Invalidate the local cache, since it will not have the new CRDs\n\t\t// present.\n\t\tdiscoveryClient, err := i.cfg.RESTClientGetter.ToDiscoveryClient()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ti.cfg.Log(\"Clearing discovery cache\")\n\t\tdiscoveryClient.Invalidate()\n\t\t// Give time for the CRD to be recognized.\n\n\t\tif err := i.cfg.KubeClient.Wait(totalItems, 60*time.Second); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Make sure to force a rebuild of the cache.\n\t\tdiscoveryClient.ServerGroups()\n\t}\n\treturn nil\n}\n\n// Run executes the installation\n//\n// If DryRun is set to true, this will prepare the release, but not install it\n\nfunc (i *Install) Run(chrt *chart.Chart, vals map[string]interface{}) (*release.Release, error) {\n\tctx := context.Background()\n\treturn i.RunWithContext(ctx, chrt, vals)\n}\n\n// Run executes the installation with Context\nfunc (i *Install) RunWithContext(ctx context.Context, chrt *chart.Chart, vals map[string]interface{}) (*release.Release, error) {\n\t// Check reachability of cluster unless in client-only mode (e.g. `helm template` without `--validate`)\n\tif !i.ClientOnly {\n\t\tif err := i.cfg.KubeClient.IsReachable(); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\tif err := i.availableName(); err != nil {\n\t\treturn nil, err\n\t}\n\n\tif err := chartutil.ProcessDependencies(chrt, vals); err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Pre-install anything in the crd/ directory. We do this before Helm\n\t// contacts the upstream server and builds the capabilities object.\n\tif crds := chrt.CRDObjects(); !i.ClientOnly && !i.SkipCRDs && len(crds) > 0 {\n\t\t// On dry run, bail here\n\t\tif i.DryRun {\n\t\t\ti.cfg.Log(\"WARNING: This chart or one of its subcharts contains CRDs. Rendering may fail or contain inaccuracies.\")\n\t\t} else if err := i.installCRDs(crds); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\tif i.ClientOnly {\n\t\t// Add mock objects in here so it doesn't use Kube API server\n\t\t// NOTE(bacongobbler): used for `helm template`\n\t\ti.cfg.Capabilities = chartutil.DefaultCapabilities.Copy()\n\t\tif i.KubeVersion != nil {\n\t\t\ti.cfg.Capabilities.KubeVersion = *i.KubeVersion\n\t\t}\n\t\ti.cfg.Capabilities.APIVersions = append(i.cfg.Capabilities.APIVersions, i.APIVersions...)\n\t\ti.cfg.KubeClient = &kubefake.PrintingKubeClient{Out: ioutil.Discard}\n\n\t\tmem := driver.NewMemory()\n\t\tmem.SetNamespace(i.Namespace)\n\t\ti.cfg.Releases = storage.Init(mem)\n\t} else if !i.ClientOnly && len(i.APIVersions) > 0 {\n\t\ti.cfg.Log(\"API Version list given outside of client only mode, this list will be ignored\")\n\t}\n\n\t// Make sure if Atomic is set, that wait is set as well. This makes it so\n\t// the user doesn't have to specify both\n\ti.Wait = i.Wait || i.Atomic\n\n\tcaps, err := i.cfg.getCapabilities()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// special case for helm template --is-upgrade\n\tisUpgrade := i.IsUpgrade && i.DryRun\n\toptions := chartutil.ReleaseOptions{\n\t\tName:      i.ReleaseName,\n\t\tNamespace: i.Namespace,\n\t\tRevision:  1,\n\t\tIsInstall: !isUpgrade,\n\t\tIsUpgrade: isUpgrade,\n\t}\n\tvaluesToRender, err := chartutil.ToRenderValues(chrt, vals, options, caps)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\trel := i.createRelease(chrt, vals)\n\n\tvar manifestDoc *bytes.Buffer\n\trel.Hooks, manifestDoc, rel.Info.Notes, err = i.cfg.renderResources(chrt, valuesToRender, i.ReleaseName, i.OutputDir, i.SubNotes, i.UseReleaseName, i.IncludeCRDs, i.PostRenderer, i.DryRun, i.EnableDNS)\n\t// Even for errors, attach this if available\n\tif manifestDoc != nil {\n\t\trel.Manifest = manifestDoc.String()\n\t}\n\t// Check error from render\n\tif err != nil {\n\t\trel.SetStatus(release.StatusFailed, fmt.Sprintf(\"failed to render resource: %s\", err.Error()))\n\t\t// Return a release with partial data so that the client can show debugging information.\n\t\treturn rel, err\n\t}\n\n\t// Mark this release as in-progress\n\trel.SetStatus(release.StatusPendingInstall, \"Initial install underway\")\n\n\tvar toBeAdopted kube.ResourceList\n\tresources, err := i.cfg.KubeClient.Build(bytes.NewBufferString(rel.Manifest), !i.DisableOpenAPIValidation)\n\tif err != nil {\n\t\treturn nil, errors.Wrap(err, \"unable to build kubernetes objects from release manifest\")\n\t}\n\n\t// It is safe to use \"force\" here because these are resources currently rendered by the chart.\n\terr = resources.Visit(setMetadataVisitor(rel.Name, rel.Namespace, true))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Install requires an extra validation step of checking that resources\n\t// don't already exist before we actually create resources. If we continue\n\t// forward and create the release object with resources that already exist,\n\t// we'll end up in a state where we will delete those resources upon\n\t// deleting the release because the manifest will be pointing at that\n\t// resource\n\tif !i.ClientOnly && !isUpgrade && len(resources) > 0 {\n\t\ttoBeAdopted, err = existingResourceConflict(resources, rel.Name, rel.Namespace)\n\t\tif err != nil {\n\t\t\treturn nil, errors.Wrap(err, \"rendered manifests contain a resource that already exists. Unable to continue with install\")\n\t\t}\n\t}\n\n\t// Bail out here if it is a dry run\n\tif i.DryRun {\n\t\trel.Info.Description = \"Dry run complete\"\n\t\treturn rel, nil\n\t}\n\n\tif i.CreateNamespace {\n\t\tns := &v1.Namespace{\n\t\t\tTypeMeta: metav1.TypeMeta{\n\t\t\t\tAPIVersion: \"v1\",\n\t\t\t\tKind:       \"Namespace\",\n\t\t\t},\n\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\tName: i.Namespace,\n\t\t\t\tLabels: map[string]string{\n\t\t\t\t\t\"name\": i.Namespace,\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\t\tbuf, err := yaml.Marshal(ns)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tresourceList, err := i.cfg.KubeClient.Build(bytes.NewBuffer(buf), true)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif _, err := i.cfg.KubeClient.Create(resourceList); err != nil && !apierrors.IsAlreadyExists(err) {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\t// If Replace is true, we need to supercede the last release.\n\tif i.Replace {\n\t\tif err := i.replaceRelease(rel); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\t// Store the release in history before continuing (new in Helm 3). We always know\n\t// that this is a create operation.\n\tif err := i.cfg.Releases.Create(rel); err != nil {\n\t\t// We could try to recover gracefully here, but since nothing has been installed\n\t\t// yet, this is probably safer than trying to continue when we know storage is\n\t\t// not working.\n\t\treturn rel, err\n\t}\n\trChan := make(chan resultMessage)\n\tdoneChan := make(chan struct{})\n\tdefer close(doneChan)\n\tgo i.performInstall(rChan, rel, toBeAdopted, resources)\n\tgo i.handleContext(ctx, rChan, doneChan, rel)\n\tresult := <-rChan\n\t//start preformInstall go routine\n\treturn result.r, result.e\n}\n\nfunc (i *Install) performInstall(c chan<- resultMessage, rel *release.Release, toBeAdopted kube.ResourceList, resources kube.ResourceList) {\n\n\t// pre-install hooks\n\tif !i.DisableHooks {\n\t\tif err := i.cfg.execHook(rel, release.HookPreInstall, i.Timeout); err != nil {\n\t\t\ti.reportToRun(c, rel, fmt.Errorf(\"failed pre-install: %s\", err))\n\t\t\treturn\n\t\t}\n\t}\n\n\t// At this point, we can do the install. Note that before we were detecting whether to\n\t// do an update, but it's not clear whether we WANT to do an update if the re-use is set\n\t// to true, since that is basically an upgrade operation.\n\tif len(toBeAdopted) == 0 && len(resources) > 0 {\n\t\tif _, err := i.cfg.KubeClient.Create(resources); err != nil {\n\t\t\ti.reportToRun(c, rel, err)\n\t\t\treturn\n\t\t}\n\t} else if len(resources) > 0 {\n\t\tif _, err := i.cfg.KubeClient.Update(toBeAdopted, resources, i.Force); err != nil {\n\t\t\ti.reportToRun(c, rel, err)\n\t\t\treturn\n\t\t}\n\t}\n\n\tif i.Wait {\n\t\tif i.WaitForJobs {\n\t\t\tif err := i.cfg.KubeClient.WaitWithJobs(resources, i.Timeout); err != nil {\n\t\t\t\ti.reportToRun(c, rel, err)\n\t\t\t\treturn\n\t\t\t}\n\t\t} else {\n\t\t\tif err := i.cfg.KubeClient.Wait(resources, i.Timeout); err != nil {\n\t\t\t\ti.reportToRun(c, rel, err)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}\n\n\tif !i.DisableHooks {\n\t\tif err := i.cfg.execHook(rel, release.HookPostInstall, i.Timeout); err != nil {\n\t\t\ti.reportToRun(c, rel, fmt.Errorf(\"failed post-install: %s\", err))\n\t\t\treturn\n\t\t}\n\t}\n\n\tif len(i.Description) > 0 {\n\t\trel.SetStatus(release.StatusDeployed, i.Description)\n\t} else {\n\t\trel.SetStatus(release.StatusDeployed, \"Install complete\")\n\t}\n\n\t// This is a tricky case. The release has been created, but the result\n\t// cannot be recorded. The truest thing to tell the user is that the\n\t// release was created. However, the user will not be able to do anything\n\t// further with this release.\n\t//\n\t// One possible strategy would be to do a timed retry to see if we can get\n\t// this stored in the future.\n\tif err := i.recordRelease(rel); err != nil {\n\t\ti.cfg.Log(\"failed to record the release: %s\", err)\n\t}\n\n\ti.reportToRun(c, rel, nil)\n}\nfunc (i *Install) handleContext(ctx context.Context, c chan<- resultMessage, done chan struct{}, rel *release.Release) {\n\tselect {\n\tcase <-ctx.Done():\n\t\terr := ctx.Err()\n\t\ti.reportToRun(c, rel, err)\n\tcase <-done:\n\t\treturn\n\t}\n}\nfunc (i *Install) reportToRun(c chan<- resultMessage, rel *release.Release, err error) {\n\ti.Lock.Lock()\n\tif err != nil {\n\t\trel, err = i.failRelease(rel, err)\n\t}\n\tc <- resultMessage{r: rel, e: err}\n\ti.Lock.Unlock()\n}\nfunc (i *Install) failRelease(rel *release.Release, err error) (*release.Release, error) {\n\trel.SetStatus(release.StatusFailed, fmt.Sprintf(\"Release %q failed: %s\", i.ReleaseName, err.Error()))\n\tif i.Atomic {\n\t\ti.cfg.Log(\"Install failed and atomic is set, uninstalling release\")\n\t\tuninstall := NewUninstall(i.cfg)\n\t\tuninstall.DisableHooks = i.DisableHooks\n\t\tuninstall.KeepHistory = false\n\t\tuninstall.Timeout = i.Timeout\n\t\tif _, uninstallErr := uninstall.Run(i.ReleaseName); uninstallErr != nil {\n\t\t\treturn rel, errors.Wrapf(uninstallErr, \"an error occurred while uninstalling the release. original install error: %s\", err)\n\t\t}\n\t\treturn rel, errors.Wrapf(err, \"release %s failed, and has been uninstalled due to atomic being set\", i.ReleaseName)\n\t}\n\ti.recordRelease(rel) // Ignore the error, since we have another error to deal with.\n\treturn rel, err\n}\n\n// availableName tests whether a name is available\n//\n// Roughly, this will return an error if name is\n//\n//   - empty\n//   - too long\n//   - already in use, and not deleted\n//   - used by a deleted release, and i.Replace is false\nfunc (i *Install) availableName() error {\n\tstart := i.ReleaseName\n\n\tif err := chartutil.ValidateReleaseName(start); err != nil {\n\t\treturn errors.Wrapf(err, \"release name %q\", start)\n\t}\n\tif i.DryRun {\n\t\treturn nil\n\t}\n\n\th, err := i.cfg.Releases.History(start)\n\tif err != nil || len(h) < 1 {\n\t\treturn nil\n\t}\n\treleaseutil.Reverse(h, releaseutil.SortByRevision)\n\trel := h[0]\n\n\tif st := rel.Info.Status; i.Replace && (st == release.StatusUninstalled || st == release.StatusFailed) {\n\t\treturn nil\n\t}\n\treturn errors.New(\"cannot re-use a name that is still in use\")\n}\n\n// createRelease creates a new release object\nfunc (i *Install) createRelease(chrt *chart.Chart, rawVals map[string]interface{}) *release.Release {\n\tts := i.cfg.Now()\n\treturn &release.Release{\n\t\tName:      i.ReleaseName,\n\t\tNamespace: i.Namespace,\n\t\tChart:     chrt,\n\t\tConfig:    rawVals,\n\t\tInfo: &release.Info{\n\t\t\tFirstDeployed: ts,\n\t\t\tLastDeployed:  ts,\n\t\t\tStatus:        release.StatusUnknown,\n\t\t},\n\t\tVersion: 1,\n\t}\n}\n\n// recordRelease with an update operation in case reuse has been set.\nfunc (i *Install) recordRelease(r *release.Release) error {\n\t// This is a legacy function which has been reduced to a oneliner. Could probably\n\t// refactor it out.\n\treturn i.cfg.Releases.Update(r)\n}\n\n// replaceRelease replaces an older release with this one\n//\n// This allows us to re-use names by superseding an existing release with a new one\nfunc (i *Install) replaceRelease(rel *release.Release) error {\n\thist, err := i.cfg.Releases.History(rel.Name)\n\tif err != nil || len(hist) == 0 {\n\t\t// No releases exist for this name, so we can return early\n\t\treturn nil\n\t}\n\n\treleaseutil.Reverse(hist, releaseutil.SortByRevision)\n\tlast := hist[0]\n\n\t// Update version to the next available\n\trel.Version = last.Version + 1\n\n\t// Do not change the status of a failed release.\n\tif last.Info.Status == release.StatusFailed {\n\t\treturn nil\n\t}\n\n\t// For any other status, mark it as superseded and store the old record\n\tlast.SetStatus(release.StatusSuperseded, \"superseded by new release\")\n\treturn i.recordRelease(last)\n}\n\n// write the <data> to <output-dir>/<name>. <append> controls if the file is created or content will be appended\nfunc writeToFile(outputDir string, name string, data string, append bool) error {\n\toutfileName := strings.Join([]string{outputDir, name}, string(filepath.Separator))\n\n\terr := ensureDirectoryForFile(outfileName)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tf, err := createOrOpenFile(outfileName, append)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tdefer f.Close()\n\n\t_, err = f.WriteString(fmt.Sprintf(\"---\\n# Source: %s\\n%s\\n\", name, data))\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfmt.Printf(\"wrote %s\\n\", outfileName)\n\treturn nil\n}\n\nfunc createOrOpenFile(filename string, append bool) (*os.File, error) {\n\tif append {\n\t\treturn os.OpenFile(filename, os.O_APPEND|os.O_WRONLY, 0600)\n\t}\n\treturn os.Create(filename)\n}\n\n// check if the directory exists to create file. creates if don't exists\nfunc ensureDirectoryForFile(file string) error {\n\tbaseDir := path.Dir(file)\n\t_, err := os.Stat(baseDir)\n\tif err != nil && !os.IsNotExist(err) {\n\t\treturn err\n\t}\n\n\treturn os.MkdirAll(baseDir, defaultDirectoryPermission)\n}\n\n// NameAndChart returns the name and chart that should be used.\n//\n// This will read the flags and handle name generation if necessary.\nfunc (i *Install) NameAndChart(args []string) (string, string, error) {\n\tflagsNotSet := func() error {\n\t\tif i.GenerateName {\n\t\t\treturn errors.New(\"cannot set --generate-name and also specify a name\")\n\t\t}\n\t\tif i.NameTemplate != \"\" {\n\t\t\treturn errors.New(\"cannot set --name-template and also specify a name\")\n\t\t}\n\t\treturn nil\n\t}\n\n\tif len(args) > 2 {\n\t\treturn args[0], args[1], errors.Errorf(\"expected at most two arguments, unexpected arguments: %v\", strings.Join(args[2:], \", \"))\n\t}\n\n\tif len(args) == 2 {\n\t\treturn args[0], args[1], flagsNotSet()\n\t}\n\n\tif i.NameTemplate != \"\" {\n\t\tname, err := TemplateName(i.NameTemplate)\n\t\treturn name, args[0], err\n\t}\n\n\tif i.ReleaseName != \"\" {\n\t\treturn i.ReleaseName, args[0], nil\n\t}\n\n\tif !i.GenerateName {\n\t\treturn \"\", args[0], errors.New(\"must either provide a name or specify --generate-name\")\n\t}\n\n\tbase := filepath.Base(args[0])\n\tif base == \".\" || base == \"\" {\n\t\tbase = \"chart\"\n\t}\n\t// if present, strip out the file extension from the name\n\tif idx := strings.Index(base, \".\"); idx != -1 {\n\t\tbase = base[0:idx]\n\t}\n\n\treturn fmt.Sprintf(\"%s-%d\", base, time.Now().Unix()), args[0], nil\n}\n\n// TemplateName renders a name template, returning the name or an error.\nfunc TemplateName(nameTemplate string) (string, error) {\n\tif nameTemplate == \"\" {\n\t\treturn \"\", nil\n\t}\n\n\tt, err := template.New(\"name-template\").Funcs(sprig.TxtFuncMap()).Parse(nameTemplate)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tvar b bytes.Buffer\n\tif err := t.Execute(&b, nil); err != nil {\n\t\treturn \"\", err\n\t}\n\n\treturn b.String(), nil\n}\n\n// CheckDependencies checks the dependencies for a chart.\nfunc CheckDependencies(ch *chart.Chart, reqs []*chart.Dependency) error {\n\tvar missing []string\n\nOUTER:\n\tfor _, r := range reqs {\n\t\tfor _, d := range ch.Dependencies() {\n\t\t\tif d.Name() == r.Name {\n\t\t\t\tcontinue OUTER\n\t\t\t}\n\t\t}\n\t\tmissing = append(missing, r.Name)\n\t}\n\n\tif len(missing) > 0 {\n\t\treturn errors.Errorf(\"found in Chart.yaml, but missing in charts/ directory: %s\", strings.Join(missing, \", \"))\n\t}\n\treturn nil\n}\n\n// LocateChart looks for a chart directory in known places, and returns either the full path or an error.\n//\n// This does not ensure that the chart is well-formed; only that the requested filename exists.\n//\n// Order of resolution:\n// - relative to current working directory\n// - if path is absolute or begins with '.', error out here\n// - URL\n//\n// If 'verify' was set on ChartPathOptions, this will attempt to also verify the chart.\nfunc (c *ChartPathOptions) LocateChart(name string, settings *cli.EnvSettings) (string, error) {\n\t// If there is no registry client and the name is in an OCI registry return\n\t// an error and a lookup will not occur.\n\tif registry.IsOCI(name) && c.registryClient == nil {\n\t\treturn \"\", fmt.Errorf(\"unable to lookup chart %q, missing registry client\", name)\n\t}\n\n\tname = strings.TrimSpace(name)\n\tversion := strings.TrimSpace(c.Version)\n\n\tif _, err := os.Stat(name); err == nil {\n\t\tabs, err := filepath.Abs(name)\n\t\tif err != nil {\n\t\t\treturn abs, err\n\t\t}\n\t\tif c.Verify {\n\t\t\tif _, err := downloader.VerifyChart(abs, c.Keyring); err != nil {\n\t\t\t\treturn \"\", err\n\t\t\t}\n\t\t}\n\t\treturn abs, nil\n\t}\n\tif filepath.IsAbs(name) || strings.HasPrefix(name, \".\") {\n\t\treturn name, errors.Errorf(\"path %q not found\", name)\n\t}\n\n\tdl := downloader.ChartDownloader{\n\t\tOut:     os.Stdout,\n\t\tKeyring: c.Keyring,\n\t\tGetters: getter.All(settings),\n\t\tOptions: []getter.Option{\n\t\t\tgetter.WithPassCredentialsAll(c.PassCredentialsAll),\n\t\t\tgetter.WithTLSClientConfig(c.CertFile, c.KeyFile, c.CaFile),\n\t\t\tgetter.WithInsecureSkipVerifyTLS(c.InsecureSkipTLSverify),\n\t\t},\n\t\tRepositoryConfig: settings.RepositoryConfig,\n\t\tRepositoryCache:  settings.RepositoryCache,\n\t\tRegistryClient:   c.registryClient,\n\t}\n\n\tif registry.IsOCI(name) {\n\t\tdl.Options = append(dl.Options, getter.WithRegistryClient(c.registryClient))\n\t}\n\n\tif c.Verify {\n\t\tdl.Verify = downloader.VerifyAlways\n\t}\n\tif c.RepoURL != \"\" {\n\t\tchartURL, err := repo.FindChartInAuthAndTLSAndPassRepoURL(c.RepoURL, c.Username, c.Password, name, version,\n\t\t\tc.CertFile, c.KeyFile, c.CaFile, c.InsecureSkipTLSverify, c.PassCredentialsAll, getter.All(settings))\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t\tname = chartURL\n\n\t\t// Only pass the user/pass on when the user has said to or when the\n\t\t// location of the chart repo and the chart are the same domain.\n\t\tu1, err := url.Parse(c.RepoURL)\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t\tu2, err := url.Parse(chartURL)\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\n\t\t// Host on URL (returned from url.Parse) contains the port if present.\n\t\t// This check ensures credentials are not passed between different\n\t\t// services on different ports.\n\t\tif c.PassCredentialsAll || (u1.Scheme == u2.Scheme && u1.Host == u2.Host) {\n\t\t\tdl.Options = append(dl.Options, getter.WithBasicAuth(c.Username, c.Password))\n\t\t} else {\n\t\t\tdl.Options = append(dl.Options, getter.WithBasicAuth(\"\", \"\"))\n\t\t}\n\t} else {\n\t\tdl.Options = append(dl.Options, getter.WithBasicAuth(c.Username, c.Password))\n\t}\n\n\tif err := os.MkdirAll(settings.RepositoryCache, 0755); err != nil {\n\t\treturn \"\", err\n\t}\n\n\tfilename, _, err := dl.DownloadTo(name, version, settings.RepositoryCache)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tlname, err := filepath.Abs(filename)\n\tif err != nil {\n\t\treturn filename, err\n\t}\n\treturn lname, nil\n}\n", "/*\nCopyright The Helm Authors.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\npackage action\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"fmt\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/pkg/errors\"\n\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n\t\"k8s.io/cli-runtime/pkg/resource\"\n\n\t\"helm.sh/helm/v3/pkg/chart\"\n\t\"helm.sh/helm/v3/pkg/chartutil\"\n\t\"helm.sh/helm/v3/pkg/kube\"\n\t\"helm.sh/helm/v3/pkg/postrender\"\n\t\"helm.sh/helm/v3/pkg/release\"\n\t\"helm.sh/helm/v3/pkg/releaseutil\"\n\t\"helm.sh/helm/v3/pkg/storage/driver\"\n)\n\n// Upgrade is the action for upgrading releases.\n//\n// It provides the implementation of 'helm upgrade'.\ntype Upgrade struct {\n\tcfg *Configuration\n\n\tChartPathOptions\n\n\t// Install is a purely informative flag that indicates whether this upgrade was done in \"install\" mode.\n\t//\n\t// Applications may use this to determine whether this Upgrade operation was done as part of a\n\t// pure upgrade (Upgrade.Install == false) or as part of an install-or-upgrade operation\n\t// (Upgrade.Install == true).\n\t//\n\t// Setting this to `true` will NOT cause `Upgrade` to perform an install if the release does not exist.\n\t// That process must be handled by creating an Install action directly. See cmd/upgrade.go for an\n\t// example of how this flag is used.\n\tInstall bool\n\t// Devel indicates that the operation is done in devel mode.\n\tDevel bool\n\t// Namespace is the namespace in which this operation should be performed.\n\tNamespace string\n\t// SkipCRDs skips installing CRDs when install flag is enabled during upgrade\n\tSkipCRDs bool\n\t// Timeout is the timeout for this operation\n\tTimeout time.Duration\n\t// Wait determines whether the wait operation should be performed after the upgrade is requested.\n\tWait bool\n\t// WaitForJobs determines whether the wait operation for the Jobs should be performed after the upgrade is requested.\n\tWaitForJobs bool\n\t// DisableHooks disables hook processing if set to true.\n\tDisableHooks bool\n\t// DryRun controls whether the operation is prepared, but not executed.\n\t// If `true`, the upgrade is prepared but not performed.\n\tDryRun bool\n\t// Force will, if set to `true`, ignore certain warnings and perform the upgrade anyway.\n\t//\n\t// This should be used with caution.\n\tForce bool\n\t// ResetValues will reset the values to the chart's built-ins rather than merging with existing.\n\tResetValues bool\n\t// ReuseValues will re-use the user's last supplied values.\n\tReuseValues bool\n\t// Recreate will (if true) recreate pods after a rollback.\n\tRecreate bool\n\t// MaxHistory limits the maximum number of revisions saved per release\n\tMaxHistory int\n\t// Atomic, if true, will roll back on failure.\n\tAtomic bool\n\t// CleanupOnFail will, if true, cause the upgrade to delete newly-created resources on a failed update.\n\tCleanupOnFail bool\n\t// SubNotes determines whether sub-notes are rendered in the chart.\n\tSubNotes bool\n\t// Description is the description of this operation\n\tDescription string\n\t// PostRender is an optional post-renderer\n\t//\n\t// If this is non-nil, then after templates are rendered, they will be sent to the\n\t// post renderer before sending to the Kubernetes API server.\n\tPostRenderer postrender.PostRenderer\n\t// DisableOpenAPIValidation controls whether OpenAPI validation is enforced.\n\tDisableOpenAPIValidation bool\n\t// Get missing dependencies\n\tDependencyUpdate bool\n\t// Lock to control raceconditions when the process receives a SIGTERM\n\tLock sync.Mutex\n\t// Enable DNS lookups when rendering templates\n\tEnableDNS bool\n}\n\ntype resultMessage struct {\n\tr *release.Release\n\te error\n}\n\n// NewUpgrade creates a new Upgrade object with the given configuration.\nfunc NewUpgrade(cfg *Configuration) *Upgrade {\n\tup := &Upgrade{\n\t\tcfg: cfg,\n\t}\n\tup.ChartPathOptions.registryClient = cfg.RegistryClient\n\n\treturn up\n}\n\n// Run executes the upgrade on the given release.\nfunc (u *Upgrade) Run(name string, chart *chart.Chart, vals map[string]interface{}) (*release.Release, error) {\n\tctx := context.Background()\n\treturn u.RunWithContext(ctx, name, chart, vals)\n}\n\n// RunWithContext executes the upgrade on the given release with context.\nfunc (u *Upgrade) RunWithContext(ctx context.Context, name string, chart *chart.Chart, vals map[string]interface{}) (*release.Release, error) {\n\tif err := u.cfg.KubeClient.IsReachable(); err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Make sure if Atomic is set, that wait is set as well. This makes it so\n\t// the user doesn't have to specify both\n\tu.Wait = u.Wait || u.Atomic\n\n\tif err := chartutil.ValidateReleaseName(name); err != nil {\n\t\treturn nil, errors.Errorf(\"release name is invalid: %s\", name)\n\t}\n\tu.cfg.Log(\"preparing upgrade for %s\", name)\n\tcurrentRelease, upgradedRelease, err := u.prepareUpgrade(name, chart, vals)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tu.cfg.Releases.MaxHistory = u.MaxHistory\n\n\tu.cfg.Log(\"performing update for %s\", name)\n\tres, err := u.performUpgrade(ctx, currentRelease, upgradedRelease)\n\tif err != nil {\n\t\treturn res, err\n\t}\n\n\tif !u.DryRun {\n\t\tu.cfg.Log(\"updating status for upgraded release for %s\", name)\n\t\tif err := u.cfg.Releases.Update(upgradedRelease); err != nil {\n\t\t\treturn res, err\n\t\t}\n\t}\n\n\treturn res, nil\n}\n\n// prepareUpgrade builds an upgraded release for an upgrade operation.\nfunc (u *Upgrade) prepareUpgrade(name string, chart *chart.Chart, vals map[string]interface{}) (*release.Release, *release.Release, error) {\n\tif chart == nil {\n\t\treturn nil, nil, errMissingChart\n\t}\n\n\t// finds the last non-deleted release with the given name\n\tlastRelease, err := u.cfg.Releases.Last(name)\n\tif err != nil {\n\t\t// to keep existing behavior of returning the \"%q has no deployed releases\" error when an existing release does not exist\n\t\tif errors.Is(err, driver.ErrReleaseNotFound) {\n\t\t\treturn nil, nil, driver.NewErrNoDeployedReleases(name)\n\t\t}\n\t\treturn nil, nil, err\n\t}\n\n\t// Concurrent `helm upgrade`s will either fail here with `errPending` or when creating the release with \"already exists\". This should act as a pessimistic lock.\n\tif lastRelease.Info.Status.IsPending() {\n\t\treturn nil, nil, errPending\n\t}\n\n\tvar currentRelease *release.Release\n\tif lastRelease.Info.Status == release.StatusDeployed {\n\t\t// no need to retrieve the last deployed release from storage as the last release is deployed\n\t\tcurrentRelease = lastRelease\n\t} else {\n\t\t// finds the deployed release with the given name\n\t\tcurrentRelease, err = u.cfg.Releases.Deployed(name)\n\t\tif err != nil {\n\t\t\tif errors.Is(err, driver.ErrNoDeployedReleases) &&\n\t\t\t\t(lastRelease.Info.Status == release.StatusFailed || lastRelease.Info.Status == release.StatusSuperseded) {\n\t\t\t\tcurrentRelease = lastRelease\n\t\t\t} else {\n\t\t\t\treturn nil, nil, err\n\t\t\t}\n\t\t}\n\t}\n\n\t// determine if values will be reused\n\tvals, err = u.reuseValues(chart, currentRelease, vals)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tif err := chartutil.ProcessDependencies(chart, vals); err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\t// Increment revision count. This is passed to templates, and also stored on\n\t// the release object.\n\trevision := lastRelease.Version + 1\n\n\toptions := chartutil.ReleaseOptions{\n\t\tName:      name,\n\t\tNamespace: currentRelease.Namespace,\n\t\tRevision:  revision,\n\t\tIsUpgrade: true,\n\t}\n\n\tcaps, err := u.cfg.getCapabilities()\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tvaluesToRender, err := chartutil.ToRenderValues(chart, vals, options, caps)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\thooks, manifestDoc, notesTxt, err := u.cfg.renderResources(chart, valuesToRender, \"\", \"\", u.SubNotes, false, false, u.PostRenderer, u.DryRun, u.EnableDNS)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\t// Store an upgraded release.\n\tupgradedRelease := &release.Release{\n\t\tName:      name,\n\t\tNamespace: currentRelease.Namespace,\n\t\tChart:     chart,\n\t\tConfig:    vals,\n\t\tInfo: &release.Info{\n\t\t\tFirstDeployed: currentRelease.Info.FirstDeployed,\n\t\t\tLastDeployed:  Timestamper(),\n\t\t\tStatus:        release.StatusPendingUpgrade,\n\t\t\tDescription:   \"Preparing upgrade\", // This should be overwritten later.\n\t\t},\n\t\tVersion:  revision,\n\t\tManifest: manifestDoc.String(),\n\t\tHooks:    hooks,\n\t}\n\n\tif len(notesTxt) > 0 {\n\t\tupgradedRelease.Info.Notes = notesTxt\n\t}\n\terr = validateManifest(u.cfg.KubeClient, manifestDoc.Bytes(), !u.DisableOpenAPIValidation)\n\treturn currentRelease, upgradedRelease, err\n}\n\nfunc (u *Upgrade) performUpgrade(ctx context.Context, originalRelease, upgradedRelease *release.Release) (*release.Release, error) {\n\tcurrent, err := u.cfg.KubeClient.Build(bytes.NewBufferString(originalRelease.Manifest), false)\n\tif err != nil {\n\t\t// Checking for removed Kubernetes API error so can provide a more informative error message to the user\n\t\t// Ref: https://github.com/helm/helm/issues/7219\n\t\tif strings.Contains(err.Error(), \"unable to recognize \\\"\\\": no matches for kind\") {\n\t\t\treturn upgradedRelease, errors.Wrap(err, \"current release manifest contains removed kubernetes api(s) for this \"+\n\t\t\t\t\"kubernetes version and it is therefore unable to build the kubernetes \"+\n\t\t\t\t\"objects for performing the diff. error from kubernetes\")\n\t\t}\n\t\treturn upgradedRelease, errors.Wrap(err, \"unable to build kubernetes objects from current release manifest\")\n\t}\n\ttarget, err := u.cfg.KubeClient.Build(bytes.NewBufferString(upgradedRelease.Manifest), !u.DisableOpenAPIValidation)\n\tif err != nil {\n\t\treturn upgradedRelease, errors.Wrap(err, \"unable to build kubernetes objects from new release manifest\")\n\t}\n\n\t// It is safe to use force only on target because these are resources currently rendered by the chart.\n\terr = target.Visit(setMetadataVisitor(upgradedRelease.Name, upgradedRelease.Namespace, true))\n\tif err != nil {\n\t\treturn upgradedRelease, err\n\t}\n\n\t// Do a basic diff using gvk + name to figure out what new resources are being created so we can validate they don't already exist\n\texistingResources := make(map[string]bool)\n\tfor _, r := range current {\n\t\texistingResources[objectKey(r)] = true\n\t}\n\n\tvar toBeCreated kube.ResourceList\n\tfor _, r := range target {\n\t\tif !existingResources[objectKey(r)] {\n\t\t\ttoBeCreated = append(toBeCreated, r)\n\t\t}\n\t}\n\n\ttoBeUpdated, err := existingResourceConflict(toBeCreated, upgradedRelease.Name, upgradedRelease.Namespace)\n\tif err != nil {\n\t\treturn nil, errors.Wrap(err, \"rendered manifests contain a resource that already exists. Unable to continue with update\")\n\t}\n\n\ttoBeUpdated.Visit(func(r *resource.Info, err error) error {\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tcurrent.Append(r)\n\t\treturn nil\n\t})\n\n\tif u.DryRun {\n\t\tu.cfg.Log(\"dry run for %s\", upgradedRelease.Name)\n\t\tif len(u.Description) > 0 {\n\t\t\tupgradedRelease.Info.Description = u.Description\n\t\t} else {\n\t\t\tupgradedRelease.Info.Description = \"Dry run complete\"\n\t\t}\n\t\treturn upgradedRelease, nil\n\t}\n\n\tu.cfg.Log(\"creating upgraded release for %s\", upgradedRelease.Name)\n\tif err := u.cfg.Releases.Create(upgradedRelease); err != nil {\n\t\treturn nil, err\n\t}\n\trChan := make(chan resultMessage)\n\tctxChan := make(chan resultMessage)\n\tdoneChan := make(chan interface{})\n\tdefer close(doneChan)\n\tgo u.releasingUpgrade(rChan, upgradedRelease, current, target, originalRelease)\n\tgo u.handleContext(ctx, doneChan, ctxChan, upgradedRelease)\n\tselect {\n\tcase result := <-rChan:\n\t\treturn result.r, result.e\n\tcase result := <-ctxChan:\n\t\treturn result.r, result.e\n\t}\n}\n\n// Function used to lock the Mutex, this is important for the case when the atomic flag is set.\n// In that case the upgrade will finish before the rollback is finished so it is necessary to wait for the rollback to finish.\n// The rollback will be trigger by the function failRelease\nfunc (u *Upgrade) reportToPerformUpgrade(c chan<- resultMessage, rel *release.Release, created kube.ResourceList, err error) {\n\tu.Lock.Lock()\n\tif err != nil {\n\t\trel, err = u.failRelease(rel, created, err)\n\t}\n\tc <- resultMessage{r: rel, e: err}\n\tu.Lock.Unlock()\n}\n\n// Setup listener for SIGINT and SIGTERM\nfunc (u *Upgrade) handleContext(ctx context.Context, done chan interface{}, c chan<- resultMessage, upgradedRelease *release.Release) {\n\tselect {\n\tcase <-ctx.Done():\n\t\terr := ctx.Err()\n\n\t\t// when the atomic flag is set the ongoing release finish first and doesn't give time for the rollback happens.\n\t\tu.reportToPerformUpgrade(c, upgradedRelease, kube.ResourceList{}, err)\n\tcase <-done:\n\t\treturn\n\t}\n}\nfunc (u *Upgrade) releasingUpgrade(c chan<- resultMessage, upgradedRelease *release.Release, current kube.ResourceList, target kube.ResourceList, originalRelease *release.Release) {\n\t// pre-upgrade hooks\n\n\tif !u.DisableHooks {\n\t\tif err := u.cfg.execHook(upgradedRelease, release.HookPreUpgrade, u.Timeout); err != nil {\n\t\t\tu.reportToPerformUpgrade(c, upgradedRelease, kube.ResourceList{}, fmt.Errorf(\"pre-upgrade hooks failed: %s\", err))\n\t\t\treturn\n\t\t}\n\t} else {\n\t\tu.cfg.Log(\"upgrade hooks disabled for %s\", upgradedRelease.Name)\n\t}\n\n\tresults, err := u.cfg.KubeClient.Update(current, target, u.Force)\n\tif err != nil {\n\t\tu.cfg.recordRelease(originalRelease)\n\t\tu.reportToPerformUpgrade(c, upgradedRelease, results.Created, err)\n\t\treturn\n\t}\n\n\tif u.Recreate {\n\t\t// NOTE: Because this is not critical for a release to succeed, we just\n\t\t// log if an error occurs and continue onward. If we ever introduce log\n\t\t// levels, we should make these error level logs so users are notified\n\t\t// that they'll need to go do the cleanup on their own\n\t\tif err := recreate(u.cfg, results.Updated); err != nil {\n\t\t\tu.cfg.Log(err.Error())\n\t\t}\n\t}\n\n\tif u.Wait {\n\t\tu.cfg.Log(\n\t\t\t\"waiting for release %s resources (created: %d updated: %d  deleted: %d)\",\n\t\t\tupgradedRelease.Name, len(results.Created), len(results.Updated), len(results.Deleted))\n\t\tif u.WaitForJobs {\n\t\t\tif err := u.cfg.KubeClient.WaitWithJobs(target, u.Timeout); err != nil {\n\t\t\t\tu.cfg.recordRelease(originalRelease)\n\t\t\t\tu.reportToPerformUpgrade(c, upgradedRelease, results.Created, err)\n\t\t\t\treturn\n\t\t\t}\n\t\t} else {\n\t\t\tif err := u.cfg.KubeClient.Wait(target, u.Timeout); err != nil {\n\t\t\t\tu.cfg.recordRelease(originalRelease)\n\t\t\t\tu.reportToPerformUpgrade(c, upgradedRelease, results.Created, err)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}\n\n\t// post-upgrade hooks\n\tif !u.DisableHooks {\n\t\tif err := u.cfg.execHook(upgradedRelease, release.HookPostUpgrade, u.Timeout); err != nil {\n\t\t\tu.reportToPerformUpgrade(c, upgradedRelease, results.Created, fmt.Errorf(\"post-upgrade hooks failed: %s\", err))\n\t\t\treturn\n\t\t}\n\t}\n\n\toriginalRelease.Info.Status = release.StatusSuperseded\n\tu.cfg.recordRelease(originalRelease)\n\n\tupgradedRelease.Info.Status = release.StatusDeployed\n\tif len(u.Description) > 0 {\n\t\tupgradedRelease.Info.Description = u.Description\n\t} else {\n\t\tupgradedRelease.Info.Description = \"Upgrade complete\"\n\t}\n\tu.reportToPerformUpgrade(c, upgradedRelease, nil, nil)\n}\n\nfunc (u *Upgrade) failRelease(rel *release.Release, created kube.ResourceList, err error) (*release.Release, error) {\n\tmsg := fmt.Sprintf(\"Upgrade %q failed: %s\", rel.Name, err)\n\tu.cfg.Log(\"warning: %s\", msg)\n\n\trel.Info.Status = release.StatusFailed\n\trel.Info.Description = msg\n\tu.cfg.recordRelease(rel)\n\tif u.CleanupOnFail && len(created) > 0 {\n\t\tu.cfg.Log(\"Cleanup on fail set, cleaning up %d resources\", len(created))\n\t\t_, errs := u.cfg.KubeClient.Delete(created)\n\t\tif errs != nil {\n\t\t\tvar errorList []string\n\t\t\tfor _, e := range errs {\n\t\t\t\terrorList = append(errorList, e.Error())\n\t\t\t}\n\t\t\treturn rel, errors.Wrapf(fmt.Errorf(\"unable to cleanup resources: %s\", strings.Join(errorList, \", \")), \"an error occurred while cleaning up resources. original upgrade error: %s\", err)\n\t\t}\n\t\tu.cfg.Log(\"Resource cleanup complete\")\n\t}\n\tif u.Atomic {\n\t\tu.cfg.Log(\"Upgrade failed and atomic is set, rolling back to last successful release\")\n\n\t\t// As a protection, get the last successful release before rollback.\n\t\t// If there are no successful releases, bail out\n\t\thist := NewHistory(u.cfg)\n\t\tfullHistory, herr := hist.Run(rel.Name)\n\t\tif herr != nil {\n\t\t\treturn rel, errors.Wrapf(herr, \"an error occurred while finding last successful release. original upgrade error: %s\", err)\n\t\t}\n\n\t\t// There isn't a way to tell if a previous release was successful, but\n\t\t// generally failed releases do not get superseded unless the next\n\t\t// release is successful, so this should be relatively safe\n\t\tfilteredHistory := releaseutil.FilterFunc(func(r *release.Release) bool {\n\t\t\treturn r.Info.Status == release.StatusSuperseded || r.Info.Status == release.StatusDeployed\n\t\t}).Filter(fullHistory)\n\t\tif len(filteredHistory) == 0 {\n\t\t\treturn rel, errors.Wrap(err, \"unable to find a previously successful release when attempting to rollback. original upgrade error\")\n\t\t}\n\n\t\treleaseutil.Reverse(filteredHistory, releaseutil.SortByRevision)\n\n\t\trollin := NewRollback(u.cfg)\n\t\trollin.Version = filteredHistory[0].Version\n\t\trollin.Wait = true\n\t\trollin.WaitForJobs = u.WaitForJobs\n\t\trollin.DisableHooks = u.DisableHooks\n\t\trollin.Recreate = u.Recreate\n\t\trollin.Force = u.Force\n\t\trollin.Timeout = u.Timeout\n\t\tif rollErr := rollin.Run(rel.Name); rollErr != nil {\n\t\t\treturn rel, errors.Wrapf(rollErr, \"an error occurred while rolling back the release. original upgrade error: %s\", err)\n\t\t}\n\t\treturn rel, errors.Wrapf(err, \"release %s failed, and has been rolled back due to atomic being set\", rel.Name)\n\t}\n\n\treturn rel, err\n}\n\n// reuseValues copies values from the current release to a new release if the\n// new release does not have any values.\n//\n// If the request already has values, or if there are no values in the current\n// release, this does nothing.\n//\n// This is skipped if the u.ResetValues flag is set, in which case the\n// request values are not altered.\nfunc (u *Upgrade) reuseValues(chart *chart.Chart, current *release.Release, newVals map[string]interface{}) (map[string]interface{}, error) {\n\tif u.ResetValues {\n\t\t// If ResetValues is set, we completely ignore current.Config.\n\t\tu.cfg.Log(\"resetting values to the chart's original version\")\n\t\treturn newVals, nil\n\t}\n\n\t// If the ReuseValues flag is set, we always copy the old values over the new config's values.\n\tif u.ReuseValues {\n\t\tu.cfg.Log(\"reusing the old release's values\")\n\n\t\t// We have to regenerate the old coalesced values:\n\t\toldVals, err := chartutil.CoalesceValues(current.Chart, current.Config)\n\t\tif err != nil {\n\t\t\treturn nil, errors.Wrap(err, \"failed to rebuild old values\")\n\t\t}\n\n\t\tnewVals = chartutil.CoalesceTables(newVals, current.Config)\n\n\t\tchart.Values = oldVals\n\n\t\treturn newVals, nil\n\t}\n\n\tif len(newVals) == 0 && len(current.Config) > 0 {\n\t\tu.cfg.Log(\"copying values from %s (v%d) to new release.\", current.Name, current.Version)\n\t\tnewVals = current.Config\n\t}\n\treturn newVals, nil\n}\n\nfunc validateManifest(c kube.Interface, manifest []byte, openAPIValidation bool) error {\n\t_, err := c.Build(bytes.NewReader(manifest), openAPIValidation)\n\treturn err\n}\n\n// recreate captures all the logic for recreating pods for both upgrade and\n// rollback. If we end up refactoring rollback to use upgrade, this can just be\n// made an unexported method on the upgrade action.\nfunc recreate(cfg *Configuration, resources kube.ResourceList) error {\n\tfor _, res := range resources {\n\t\tversioned := kube.AsVersioned(res)\n\t\tselector, err := kube.SelectorsForObject(versioned)\n\t\tif err != nil {\n\t\t\t// If no selector is returned, it means this object is\n\t\t\t// definitely not a pod, so continue onward\n\t\t\tcontinue\n\t\t}\n\n\t\tclient, err := cfg.KubernetesClientSet()\n\t\tif err != nil {\n\t\t\treturn errors.Wrapf(err, \"unable to recreate pods for object %s/%s because an error occurred\", res.Namespace, res.Name)\n\t\t}\n\n\t\tpods, err := client.CoreV1().Pods(res.Namespace).List(context.Background(), metav1.ListOptions{\n\t\t\tLabelSelector: selector.String(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn errors.Wrapf(err, \"unable to recreate pods for object %s/%s because an error occurred\", res.Namespace, res.Name)\n\t\t}\n\n\t\t// Restart pods\n\t\tfor _, pod := range pods.Items {\n\t\t\t// Delete each pod for get them restarted with changed spec.\n\t\t\tif err := client.CoreV1().Pods(pod.Namespace).Delete(context.Background(), pod.Name, *metav1.NewPreconditionDeleteOptions(string(pod.UID))); err != nil {\n\t\t\t\treturn errors.Wrapf(err, \"unable to recreate pods for object %s/%s because an error occurred\", res.Namespace, res.Name)\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc objectKey(r *resource.Info) string {\n\tgvk := r.Object.GetObjectKind().GroupVersionKind()\n\treturn fmt.Sprintf(\"%s/%s/%s/%s\", gvk.GroupVersion().String(), gvk.Kind, r.Namespace, r.Name)\n}\n", "/*\nCopyright The Helm Authors.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\npackage engine\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"path\"\n\t\"path/filepath\"\n\t\"regexp\"\n\t\"sort\"\n\t\"strings\"\n\t\"text/template\"\n\n\t\"github.com/pkg/errors\"\n\t\"k8s.io/client-go/rest\"\n\n\t\"helm.sh/helm/v3/pkg/chart\"\n\t\"helm.sh/helm/v3/pkg/chartutil\"\n)\n\n// Engine is an implementation of the Helm rendering implementation for templates.\ntype Engine struct {\n\t// If strict is enabled, template rendering will fail if a template references\n\t// a value that was not passed in.\n\tStrict bool\n\t// In LintMode, some 'required' template values may be missing, so don't fail\n\tLintMode bool\n\t// the rest config to connect to the kubernetes api\n\tconfig *rest.Config\n\t// EnableDNS tells the engine to allow DNS lookups when rendering templates\n\tEnableDNS bool\n}\n\n// New creates a new instance of Engine using the passed in rest config.\nfunc New(config *rest.Config) Engine {\n\treturn Engine{\n\t\tconfig: config,\n\t}\n}\n\n// Render takes a chart, optional values, and value overrides, and attempts to render the Go templates.\n//\n// Render can be called repeatedly on the same engine.\n//\n// This will look in the chart's 'templates' data (e.g. the 'templates/' directory)\n// and attempt to render the templates there using the values passed in.\n//\n// Values are scoped to their templates. A dependency template will not have\n// access to the values set for its parent. If chart \"foo\" includes chart \"bar\",\n// \"bar\" will not have access to the values for \"foo\".\n//\n// Values should be prepared with something like `chartutils.ReadValues`.\n//\n// Values are passed through the templates according to scope. If the top layer\n// chart includes the chart foo, which includes the chart bar, the values map\n// will be examined for a table called \"foo\". If \"foo\" is found in vals,\n// that section of the values will be passed into the \"foo\" chart. And if that\n// section contains a value named \"bar\", that value will be passed on to the\n// bar chart during render time.\nfunc (e Engine) Render(chrt *chart.Chart, values chartutil.Values) (map[string]string, error) {\n\ttmap := allTemplates(chrt, values)\n\treturn e.render(tmap)\n}\n\n// Render takes a chart, optional values, and value overrides, and attempts to\n// render the Go templates using the default options.\nfunc Render(chrt *chart.Chart, values chartutil.Values) (map[string]string, error) {\n\treturn new(Engine).Render(chrt, values)\n}\n\n// RenderWithClient takes a chart, optional values, and value overrides, and attempts to\n// render the Go templates using the default options. This engine is client aware and so can have template\n// functions that interact with the client\nfunc RenderWithClient(chrt *chart.Chart, values chartutil.Values, config *rest.Config) (map[string]string, error) {\n\treturn Engine{\n\t\tconfig: config,\n\t}.Render(chrt, values)\n}\n\n// renderable is an object that can be rendered.\ntype renderable struct {\n\t// tpl is the current template.\n\ttpl string\n\t// vals are the values to be supplied to the template.\n\tvals chartutil.Values\n\t// namespace prefix to the templates of the current chart\n\tbasePath string\n}\n\nconst warnStartDelim = \"HELM_ERR_START\"\nconst warnEndDelim = \"HELM_ERR_END\"\nconst recursionMaxNums = 1000\n\nvar warnRegex = regexp.MustCompile(warnStartDelim + `((?s).*)` + warnEndDelim)\n\nfunc warnWrap(warn string) string {\n\treturn warnStartDelim + warn + warnEndDelim\n}\n\n// initFunMap creates the Engine's FuncMap and adds context-specific functions.\nfunc (e Engine) initFunMap(t *template.Template, referenceTpls map[string]renderable) {\n\tfuncMap := funcMap()\n\tincludedNames := make(map[string]int)\n\n\t// Add the 'include' function here so we can close over t.\n\tfuncMap[\"include\"] = func(name string, data interface{}) (string, error) {\n\t\tvar buf strings.Builder\n\t\tif v, ok := includedNames[name]; ok {\n\t\t\tif v > recursionMaxNums {\n\t\t\t\treturn \"\", errors.Wrapf(fmt.Errorf(\"unable to execute template\"), \"rendering template has a nested reference name: %s\", name)\n\t\t\t}\n\t\t\tincludedNames[name]++\n\t\t} else {\n\t\t\tincludedNames[name] = 1\n\t\t}\n\t\terr := t.ExecuteTemplate(&buf, name, data)\n\t\tincludedNames[name]--\n\t\treturn buf.String(), err\n\t}\n\n\t// Add the 'tpl' function here\n\tfuncMap[\"tpl\"] = func(tpl string, vals chartutil.Values) (string, error) {\n\t\tbasePath, err := vals.PathValue(\"Template.BasePath\")\n\t\tif err != nil {\n\t\t\treturn \"\", errors.Wrapf(err, \"cannot retrieve Template.Basepath from values inside tpl function: %s\", tpl)\n\t\t}\n\n\t\ttemplateName, err := vals.PathValue(\"Template.Name\")\n\t\tif err != nil {\n\t\t\treturn \"\", errors.Wrapf(err, \"cannot retrieve Template.Name from values inside tpl function: %s\", tpl)\n\t\t}\n\n\t\ttemplates := map[string]renderable{\n\t\t\ttemplateName.(string): {\n\t\t\t\ttpl:      tpl,\n\t\t\t\tvals:     vals,\n\t\t\t\tbasePath: basePath.(string),\n\t\t\t},\n\t\t}\n\n\t\tresult, err := e.renderWithReferences(templates, referenceTpls)\n\t\tif err != nil {\n\t\t\treturn \"\", errors.Wrapf(err, \"error during tpl function execution for %q\", tpl)\n\t\t}\n\t\treturn result[templateName.(string)], nil\n\t}\n\n\t// Add the `required` function here so we can use lintMode\n\tfuncMap[\"required\"] = func(warn string, val interface{}) (interface{}, error) {\n\t\tif val == nil {\n\t\t\tif e.LintMode {\n\t\t\t\t// Don't fail on missing required values when linting\n\t\t\t\tlog.Printf(\"[INFO] Missing required value: %s\", warn)\n\t\t\t\treturn \"\", nil\n\t\t\t}\n\t\t\treturn val, errors.Errorf(warnWrap(warn))\n\t\t} else if _, ok := val.(string); ok {\n\t\t\tif val == \"\" {\n\t\t\t\tif e.LintMode {\n\t\t\t\t\t// Don't fail on missing required values when linting\n\t\t\t\t\tlog.Printf(\"[INFO] Missing required value: %s\", warn)\n\t\t\t\t\treturn \"\", nil\n\t\t\t\t}\n\t\t\t\treturn val, errors.Errorf(warnWrap(warn))\n\t\t\t}\n\t\t}\n\t\treturn val, nil\n\t}\n\n\t// Override sprig fail function for linting and wrapping message\n\tfuncMap[\"fail\"] = func(msg string) (string, error) {\n\t\tif e.LintMode {\n\t\t\t// Don't fail when linting\n\t\t\tlog.Printf(\"[INFO] Fail: %s\", msg)\n\t\t\treturn \"\", nil\n\t\t}\n\t\treturn \"\", errors.New(warnWrap(msg))\n\t}\n\n\t// If we are not linting and have a cluster connection, provide a Kubernetes-backed\n\t// implementation.\n\tif !e.LintMode && e.config != nil {\n\t\tfuncMap[\"lookup\"] = NewLookupFunction(e.config)\n\t}\n\n\t// When DNS lookups are not enabled override the sprig function and return\n\t// an empty string.\n\tif !e.EnableDNS {\n\t\tfuncMap[\"getHostByName\"] = func(name string) string {\n\t\t\treturn \"\"\n\t\t}\n\t}\n\n\tt.Funcs(funcMap)\n}\n\n// render takes a map of templates/values and renders them.\nfunc (e Engine) render(tpls map[string]renderable) (map[string]string, error) {\n\treturn e.renderWithReferences(tpls, tpls)\n}\n\n// renderWithReferences takes a map of templates/values to render, and a map of\n// templates which can be referenced within them.\nfunc (e Engine) renderWithReferences(tpls, referenceTpls map[string]renderable) (rendered map[string]string, err error) {\n\t// Basically, what we do here is start with an empty parent template and then\n\t// build up a list of templates -- one for each file. Once all of the templates\n\t// have been parsed, we loop through again and execute every template.\n\t//\n\t// The idea with this process is to make it possible for more complex templates\n\t// to share common blocks, but to make the entire thing feel like a file-based\n\t// template engine.\n\tdefer func() {\n\t\tif r := recover(); r != nil {\n\t\t\terr = errors.Errorf(\"rendering template failed: %v\", r)\n\t\t}\n\t}()\n\tt := template.New(\"gotpl\")\n\tif e.Strict {\n\t\tt.Option(\"missingkey=error\")\n\t} else {\n\t\t// Not that zero will attempt to add default values for types it knows,\n\t\t// but will still emit <no value> for others. We mitigate that later.\n\t\tt.Option(\"missingkey=zero\")\n\t}\n\n\te.initFunMap(t, referenceTpls)\n\n\t// We want to parse the templates in a predictable order. The order favors\n\t// higher-level (in file system) templates over deeply nested templates.\n\tkeys := sortTemplates(tpls)\n\treferenceKeys := sortTemplates(referenceTpls)\n\n\tfor _, filename := range keys {\n\t\tr := tpls[filename]\n\t\tif _, err := t.New(filename).Parse(r.tpl); err != nil {\n\t\t\treturn map[string]string{}, cleanupParseError(filename, err)\n\t\t}\n\t}\n\n\t// Adding the reference templates to the template context\n\t// so they can be referenced in the tpl function\n\tfor _, filename := range referenceKeys {\n\t\tif t.Lookup(filename) == nil {\n\t\t\tr := referenceTpls[filename]\n\t\t\tif _, err := t.New(filename).Parse(r.tpl); err != nil {\n\t\t\t\treturn map[string]string{}, cleanupParseError(filename, err)\n\t\t\t}\n\t\t}\n\t}\n\n\trendered = make(map[string]string, len(keys))\n\tfor _, filename := range keys {\n\t\t// Don't render partials. We don't care out the direct output of partials.\n\t\t// They are only included from other templates.\n\t\tif strings.HasPrefix(path.Base(filename), \"_\") {\n\t\t\tcontinue\n\t\t}\n\t\t// At render time, add information about the template that is being rendered.\n\t\tvals := tpls[filename].vals\n\t\tvals[\"Template\"] = chartutil.Values{\"Name\": filename, \"BasePath\": tpls[filename].basePath}\n\t\tvar buf strings.Builder\n\t\tif err := t.ExecuteTemplate(&buf, filename, vals); err != nil {\n\t\t\treturn map[string]string{}, cleanupExecError(filename, err)\n\t\t}\n\n\t\t// Work around the issue where Go will emit \"<no value>\" even if Options(missing=zero)\n\t\t// is set. Since missing=error will never get here, we do not need to handle\n\t\t// the Strict case.\n\t\trendered[filename] = strings.ReplaceAll(buf.String(), \"<no value>\", \"\")\n\t}\n\n\treturn rendered, nil\n}\n\nfunc cleanupParseError(filename string, err error) error {\n\ttokens := strings.Split(err.Error(), \": \")\n\tif len(tokens) == 1 {\n\t\t// This might happen if a non-templating error occurs\n\t\treturn fmt.Errorf(\"parse error in (%s): %s\", filename, err)\n\t}\n\t// The first token is \"template\"\n\t// The second token is either \"filename:lineno\" or \"filename:lineNo:columnNo\"\n\tlocation := tokens[1]\n\t// The remaining tokens make up a stacktrace-like chain, ending with the relevant error\n\terrMsg := tokens[len(tokens)-1]\n\treturn fmt.Errorf(\"parse error at (%s): %s\", string(location), errMsg)\n}\n\nfunc cleanupExecError(filename string, err error) error {\n\tif _, isExecError := err.(template.ExecError); !isExecError {\n\t\treturn err\n\t}\n\n\ttokens := strings.SplitN(err.Error(), \": \", 3)\n\tif len(tokens) != 3 {\n\t\t// This might happen if a non-templating error occurs\n\t\treturn fmt.Errorf(\"execution error in (%s): %s\", filename, err)\n\t}\n\n\t// The first token is \"template\"\n\t// The second token is either \"filename:lineno\" or \"filename:lineNo:columnNo\"\n\tlocation := tokens[1]\n\n\tparts := warnRegex.FindStringSubmatch(tokens[2])\n\tif len(parts) >= 2 {\n\t\treturn fmt.Errorf(\"execution error at (%s): %s\", string(location), parts[1])\n\t}\n\n\treturn err\n}\n\nfunc sortTemplates(tpls map[string]renderable) []string {\n\tkeys := make([]string, len(tpls))\n\ti := 0\n\tfor key := range tpls {\n\t\tkeys[i] = key\n\t\ti++\n\t}\n\tsort.Sort(sort.Reverse(byPathLen(keys)))\n\treturn keys\n}\n\ntype byPathLen []string\n\nfunc (p byPathLen) Len() int      { return len(p) }\nfunc (p byPathLen) Swap(i, j int) { p[j], p[i] = p[i], p[j] }\nfunc (p byPathLen) Less(i, j int) bool {\n\ta, b := p[i], p[j]\n\tca, cb := strings.Count(a, \"/\"), strings.Count(b, \"/\")\n\tif ca == cb {\n\t\treturn strings.Compare(a, b) == -1\n\t}\n\treturn ca < cb\n}\n\n// allTemplates returns all templates for a chart and its dependencies.\n//\n// As it goes, it also prepares the values in a scope-sensitive manner.\nfunc allTemplates(c *chart.Chart, vals chartutil.Values) map[string]renderable {\n\ttemplates := make(map[string]renderable)\n\trecAllTpls(c, templates, vals)\n\treturn templates\n}\n\n// recAllTpls recurses through the templates in a chart.\n//\n// As it recurses, it also sets the values to be appropriate for the template\n// scope.\nfunc recAllTpls(c *chart.Chart, templates map[string]renderable, vals chartutil.Values) map[string]interface{} {\n\tsubCharts := make(map[string]interface{})\n\tchartMetaData := struct {\n\t\tchart.Metadata\n\t\tIsRoot bool\n\t}{*c.Metadata, c.IsRoot()}\n\n\tnext := map[string]interface{}{\n\t\t\"Chart\":        chartMetaData,\n\t\t\"Files\":        newFiles(c.Files),\n\t\t\"Release\":      vals[\"Release\"],\n\t\t\"Capabilities\": vals[\"Capabilities\"],\n\t\t\"Values\":       make(chartutil.Values),\n\t\t\"Subcharts\":    subCharts,\n\t}\n\n\t// If there is a {{.Values.ThisChart}} in the parent metadata,\n\t// copy that into the {{.Values}} for this template.\n\tif c.IsRoot() {\n\t\tnext[\"Values\"] = vals[\"Values\"]\n\t} else if vs, err := vals.Table(\"Values.\" + c.Name()); err == nil {\n\t\tnext[\"Values\"] = vs\n\t}\n\n\tfor _, child := range c.Dependencies() {\n\t\tsubCharts[child.Name()] = recAllTpls(child, templates, next)\n\t}\n\n\tnewParentID := c.ChartFullPath()\n\tfor _, t := range c.Templates {\n\t\tif !isTemplateValid(c, t.Name) {\n\t\t\tcontinue\n\t\t}\n\t\ttemplates[path.Join(newParentID, t.Name)] = renderable{\n\t\t\ttpl:      string(t.Data),\n\t\t\tvals:     next,\n\t\t\tbasePath: path.Join(newParentID, \"templates\"),\n\t\t}\n\t}\n\n\treturn next\n}\n\n// isTemplateValid returns true if the template is valid for the chart type\nfunc isTemplateValid(ch *chart.Chart, templateName string) bool {\n\tif isLibraryChart(ch) {\n\t\treturn strings.HasPrefix(filepath.Base(templateName), \"_\")\n\t}\n\treturn true\n}\n\n// isLibraryChart returns true if the chart is a library chart\nfunc isLibraryChart(c *chart.Chart) bool {\n\treturn strings.EqualFold(c.Metadata.Type, \"library\")\n}\n", "/*\nCopyright The Helm Authors.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\npackage engine\n\nimport (\n\t\"fmt\"\n\t\"path\"\n\t\"strings\"\n\t\"sync\"\n\t\"testing\"\n\n\t\"helm.sh/helm/v3/pkg/chart\"\n\t\"helm.sh/helm/v3/pkg/chartutil\"\n)\n\nfunc TestSortTemplates(t *testing.T) {\n\ttpls := map[string]renderable{\n\t\t\"/mychart/templates/foo.tpl\":                                 {},\n\t\t\"/mychart/templates/charts/foo/charts/bar/templates/foo.tpl\": {},\n\t\t\"/mychart/templates/bar.tpl\":                                 {},\n\t\t\"/mychart/templates/charts/foo/templates/bar.tpl\":            {},\n\t\t\"/mychart/templates/_foo.tpl\":                                {},\n\t\t\"/mychart/templates/charts/foo/templates/foo.tpl\":            {},\n\t\t\"/mychart/templates/charts/bar/templates/foo.tpl\":            {},\n\t}\n\tgot := sortTemplates(tpls)\n\tif len(got) != len(tpls) {\n\t\tt.Fatal(\"Sorted results are missing templates\")\n\t}\n\n\texpect := []string{\n\t\t\"/mychart/templates/charts/foo/charts/bar/templates/foo.tpl\",\n\t\t\"/mychart/templates/charts/foo/templates/foo.tpl\",\n\t\t\"/mychart/templates/charts/foo/templates/bar.tpl\",\n\t\t\"/mychart/templates/charts/bar/templates/foo.tpl\",\n\t\t\"/mychart/templates/foo.tpl\",\n\t\t\"/mychart/templates/bar.tpl\",\n\t\t\"/mychart/templates/_foo.tpl\",\n\t}\n\tfor i, e := range expect {\n\t\tif got[i] != e {\n\t\t\tt.Fatalf(\"\\n\\tExp:\\n%s\\n\\tGot:\\n%s\",\n\t\t\t\tstrings.Join(expect, \"\\n\"),\n\t\t\t\tstrings.Join(got, \"\\n\"),\n\t\t\t)\n\t\t}\n\t}\n}\n\nfunc TestFuncMap(t *testing.T) {\n\tfns := funcMap()\n\tforbidden := []string{\"env\", \"expandenv\"}\n\tfor _, f := range forbidden {\n\t\tif _, ok := fns[f]; ok {\n\t\t\tt.Errorf(\"Forbidden function %s exists in FuncMap.\", f)\n\t\t}\n\t}\n\n\t// Test for Engine-specific template functions.\n\texpect := []string{\"include\", \"required\", \"tpl\", \"toYaml\", \"fromYaml\", \"toToml\", \"toJson\", \"fromJson\", \"lookup\"}\n\tfor _, f := range expect {\n\t\tif _, ok := fns[f]; !ok {\n\t\t\tt.Errorf(\"Expected add-on function %q\", f)\n\t\t}\n\t}\n}\n\nfunc TestRender(t *testing.T) {\n\tc := &chart.Chart{\n\t\tMetadata: &chart.Metadata{\n\t\t\tName:    \"moby\",\n\t\t\tVersion: \"1.2.3\",\n\t\t},\n\t\tTemplates: []*chart.File{\n\t\t\t{Name: \"templates/test1\", Data: []byte(\"{{.Values.outer | title }} {{.Values.inner | title}}\")},\n\t\t\t{Name: \"templates/test2\", Data: []byte(\"{{.Values.global.callme | lower }}\")},\n\t\t\t{Name: \"templates/test3\", Data: []byte(\"{{.noValue}}\")},\n\t\t\t{Name: \"templates/test4\", Data: []byte(\"{{toJson .Values}}\")},\n\t\t\t{Name: \"templates/test5\", Data: []byte(\"{{getHostByName \\\"helm.sh\\\"}}\")},\n\t\t},\n\t\tValues: map[string]interface{}{\"outer\": \"DEFAULT\", \"inner\": \"DEFAULT\"},\n\t}\n\n\tvals := map[string]interface{}{\n\t\t\"Values\": map[string]interface{}{\n\t\t\t\"outer\": \"spouter\",\n\t\t\t\"inner\": \"inn\",\n\t\t\t\"global\": map[string]interface{}{\n\t\t\t\t\"callme\": \"Ishmael\",\n\t\t\t},\n\t\t},\n\t}\n\n\tv, err := chartutil.CoalesceValues(c, vals)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to coalesce values: %s\", err)\n\t}\n\tout, err := Render(c, v)\n\tif err != nil {\n\t\tt.Errorf(\"Failed to render templates: %s\", err)\n\t}\n\n\texpect := map[string]string{\n\t\t\"moby/templates/test1\": \"Spouter Inn\",\n\t\t\"moby/templates/test2\": \"ishmael\",\n\t\t\"moby/templates/test3\": \"\",\n\t\t\"moby/templates/test4\": `{\"global\":{\"callme\":\"Ishmael\"},\"inner\":\"inn\",\"outer\":\"spouter\"}`,\n\t\t\"moby/templates/test5\": \"\",\n\t}\n\n\tfor name, data := range expect {\n\t\tif out[name] != data {\n\t\t\tt.Errorf(\"Expected %q, got %q\", data, out[name])\n\t\t}\n\t}\n}\n\nfunc TestRenderRefsOrdering(t *testing.T) {\n\tparentChart := &chart.Chart{\n\t\tMetadata: &chart.Metadata{\n\t\t\tName:    \"parent\",\n\t\t\tVersion: \"1.2.3\",\n\t\t},\n\t\tTemplates: []*chart.File{\n\t\t\t{Name: \"templates/_helpers.tpl\", Data: []byte(`{{- define \"test\" -}}parent value{{- end -}}`)},\n\t\t\t{Name: \"templates/test.yaml\", Data: []byte(`{{ tpl \"{{ include \\\"test\\\" . }}\" . }}`)},\n\t\t},\n\t}\n\tchildChart := &chart.Chart{\n\t\tMetadata: &chart.Metadata{\n\t\t\tName:    \"child\",\n\t\t\tVersion: \"1.2.3\",\n\t\t},\n\t\tTemplates: []*chart.File{\n\t\t\t{Name: \"templates/_helpers.tpl\", Data: []byte(`{{- define \"test\" -}}child value{{- end -}}`)},\n\t\t},\n\t}\n\tparentChart.AddDependency(childChart)\n\n\texpect := map[string]string{\n\t\t\"parent/templates/test.yaml\": \"parent value\",\n\t}\n\n\tfor i := 0; i < 100; i++ {\n\t\tout, err := Render(parentChart, chartutil.Values{})\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Failed to render templates: %s\", err)\n\t\t}\n\n\t\tfor name, data := range expect {\n\t\t\tif out[name] != data {\n\t\t\t\tt.Fatalf(\"Expected %q, got %q (iteration %d)\", data, out[name], i+1)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestRenderInternals(t *testing.T) {\n\t// Test the internals of the rendering tool.\n\n\tvals := chartutil.Values{\"Name\": \"one\", \"Value\": \"two\"}\n\ttpls := map[string]renderable{\n\t\t\"one\": {tpl: `Hello {{title .Name}}`, vals: vals},\n\t\t\"two\": {tpl: `Goodbye {{upper .Value}}`, vals: vals},\n\t\t// Test whether a template can reliably reference another template\n\t\t// without regard for ordering.\n\t\t\"three\": {tpl: `{{template \"two\" dict \"Value\" \"three\"}}`, vals: vals},\n\t}\n\n\tout, err := new(Engine).render(tpls)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed template rendering: %s\", err)\n\t}\n\n\tif len(out) != 3 {\n\t\tt.Fatalf(\"Expected 3 templates, got %d\", len(out))\n\t}\n\n\tif out[\"one\"] != \"Hello One\" {\n\t\tt.Errorf(\"Expected 'Hello One', got %q\", out[\"one\"])\n\t}\n\n\tif out[\"two\"] != \"Goodbye TWO\" {\n\t\tt.Errorf(\"Expected 'Goodbye TWO'. got %q\", out[\"two\"])\n\t}\n\n\tif out[\"three\"] != \"Goodbye THREE\" {\n\t\tt.Errorf(\"Expected 'Goodbye THREE'. got %q\", out[\"two\"])\n\t}\n}\n\nfunc TestRenderWIthDNS(t *testing.T) {\n\tc := &chart.Chart{\n\t\tMetadata: &chart.Metadata{\n\t\t\tName:    \"moby\",\n\t\t\tVersion: \"1.2.3\",\n\t\t},\n\t\tTemplates: []*chart.File{\n\t\t\t{Name: \"templates/test1\", Data: []byte(\"{{getHostByName \\\"helm.sh\\\"}}\")},\n\t\t},\n\t\tValues: map[string]interface{}{},\n\t}\n\n\tvals := map[string]interface{}{\n\t\t\"Values\": map[string]interface{}{},\n\t}\n\n\tv, err := chartutil.CoalesceValues(c, vals)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to coalesce values: %s\", err)\n\t}\n\n\tvar e Engine\n\te.EnableDNS = true\n\tout, err := e.Render(c, v)\n\tif err != nil {\n\t\tt.Errorf(\"Failed to render templates: %s\", err)\n\t}\n\n\tfor _, val := range c.Templates {\n\t\tfp := path.Join(\"moby\", val.Name)\n\t\tif out[fp] == \"\" {\n\t\t\tt.Errorf(\"Expected IP address, got %q\", out[fp])\n\t\t}\n\t}\n}\n\nfunc TestParallelRenderInternals(t *testing.T) {\n\t// Make sure that we can use one Engine to run parallel template renders.\n\te := new(Engine)\n\tvar wg sync.WaitGroup\n\tfor i := 0; i < 20; i++ {\n\t\twg.Add(1)\n\t\tgo func(i int) {\n\t\t\ttt := fmt.Sprintf(\"expect-%d\", i)\n\t\t\ttpls := map[string]renderable{\n\t\t\t\t\"t\": {\n\t\t\t\t\ttpl:  `{{.val}}`,\n\t\t\t\t\tvals: map[string]interface{}{\"val\": tt},\n\t\t\t\t},\n\t\t\t}\n\t\t\tout, err := e.render(tpls)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Failed to render %s: %s\", tt, err)\n\t\t\t}\n\t\t\tif out[\"t\"] != tt {\n\t\t\t\tt.Errorf(\"Expected %q, got %q\", tt, out[\"t\"])\n\t\t\t}\n\t\t\twg.Done()\n\t\t}(i)\n\t}\n\twg.Wait()\n}\n\nfunc TestParseErrors(t *testing.T) {\n\tvals := chartutil.Values{\"Values\": map[string]interface{}{}}\n\n\ttplsUndefinedFunction := map[string]renderable{\n\t\t\"undefined_function\": {tpl: `{{foo}}`, vals: vals},\n\t}\n\t_, err := new(Engine).render(tplsUndefinedFunction)\n\tif err == nil {\n\t\tt.Fatalf(\"Expected failures while rendering: %s\", err)\n\t}\n\texpected := `parse error at (undefined_function:1): function \"foo\" not defined`\n\tif err.Error() != expected {\n\t\tt.Errorf(\"Expected '%s', got %q\", expected, err.Error())\n\t}\n}\n\nfunc TestExecErrors(t *testing.T) {\n\tvals := chartutil.Values{\"Values\": map[string]interface{}{}}\n\tcases := []struct {\n\t\tname     string\n\t\ttpls     map[string]renderable\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname: \"MissingRequired\",\n\t\t\ttpls: map[string]renderable{\n\t\t\t\t\"missing_required\": {tpl: `{{required \"foo is required\" .Values.foo}}`, vals: vals},\n\t\t\t},\n\t\t\texpected: `execution error at (missing_required:1:2): foo is required`,\n\t\t},\n\t\t{\n\t\t\tname: \"MissingRequiredWithColons\",\n\t\t\ttpls: map[string]renderable{\n\t\t\t\t\"missing_required_with_colons\": {tpl: `{{required \":this: message: has many: colons:\" .Values.foo}}`, vals: vals},\n\t\t\t},\n\t\t\texpected: `execution error at (missing_required_with_colons:1:2): :this: message: has many: colons:`,\n\t\t},\n\t\t{\n\t\t\tname: \"Issue6044\",\n\t\t\ttpls: map[string]renderable{\n\t\t\t\t\"issue6044\": {\n\t\t\t\t\tvals: vals,\n\t\t\t\t\ttpl: `{{ $someEmptyValue := \"\" }}\n{{ $myvar := \"abc\" }}\n{{- required (printf \"%s: something is missing\" $myvar) $someEmptyValue | repeat 0 }}`,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: `execution error at (issue6044:3:4): abc: something is missing`,\n\t\t},\n\t\t{\n\t\t\tname: \"MissingRequiredWithNewlines\",\n\t\t\ttpls: map[string]renderable{\n\t\t\t\t\"issue9981\": {tpl: `{{required \"foo is required\\nmore info after the break\" .Values.foo}}`, vals: vals},\n\t\t\t},\n\t\t\texpected: `execution error at (issue9981:1:2): foo is required\nmore info after the break`,\n\t\t},\n\t\t{\n\t\t\tname: \"FailWithNewlines\",\n\t\t\ttpls: map[string]renderable{\n\t\t\t\t\"issue9981\": {tpl: `{{fail \"something is wrong\\nlinebreak\"}}`, vals: vals},\n\t\t\t},\n\t\t\texpected: `execution error at (issue9981:1:2): something is wrong\nlinebreak`,\n\t\t},\n\t}\n\n\tfor _, tt := range cases {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\t_, err := new(Engine).render(tt.tpls)\n\t\t\tif err == nil {\n\t\t\t\tt.Fatalf(\"Expected failures while rendering: %s\", err)\n\t\t\t}\n\t\t\tif err.Error() != tt.expected {\n\t\t\t\tt.Errorf(\"Expected %q, got %q\", tt.expected, err.Error())\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestFailErrors(t *testing.T) {\n\tvals := chartutil.Values{\"Values\": map[string]interface{}{}}\n\n\tfailtpl := `All your base are belong to us{{ fail \"This is an error\" }}`\n\ttplsFailed := map[string]renderable{\n\t\t\"failtpl\": {tpl: failtpl, vals: vals},\n\t}\n\t_, err := new(Engine).render(tplsFailed)\n\tif err == nil {\n\t\tt.Fatalf(\"Expected failures while rendering: %s\", err)\n\t}\n\texpected := `execution error at (failtpl:1:33): This is an error`\n\tif err.Error() != expected {\n\t\tt.Errorf(\"Expected '%s', got %q\", expected, err.Error())\n\t}\n\n\tvar e Engine\n\te.LintMode = true\n\tout, err := e.render(tplsFailed)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\texpectStr := \"All your base are belong to us\"\n\tif gotStr := out[\"failtpl\"]; gotStr != expectStr {\n\t\tt.Errorf(\"Expected %q, got %q (%v)\", expectStr, gotStr, out)\n\t}\n}\n\nfunc TestAllTemplates(t *testing.T) {\n\tch1 := &chart.Chart{\n\t\tMetadata: &chart.Metadata{Name: \"ch1\"},\n\t\tTemplates: []*chart.File{\n\t\t\t{Name: \"templates/foo\", Data: []byte(\"foo\")},\n\t\t\t{Name: \"templates/bar\", Data: []byte(\"bar\")},\n\t\t},\n\t}\n\tdep1 := &chart.Chart{\n\t\tMetadata: &chart.Metadata{Name: \"laboratory mice\"},\n\t\tTemplates: []*chart.File{\n\t\t\t{Name: \"templates/pinky\", Data: []byte(\"pinky\")},\n\t\t\t{Name: \"templates/brain\", Data: []byte(\"brain\")},\n\t\t},\n\t}\n\tch1.AddDependency(dep1)\n\n\tdep2 := &chart.Chart{\n\t\tMetadata: &chart.Metadata{Name: \"same thing we do every night\"},\n\t\tTemplates: []*chart.File{\n\t\t\t{Name: \"templates/innermost\", Data: []byte(\"innermost\")},\n\t\t},\n\t}\n\tdep1.AddDependency(dep2)\n\n\ttpls := allTemplates(ch1, chartutil.Values{})\n\tif len(tpls) != 5 {\n\t\tt.Errorf(\"Expected 5 charts, got %d\", len(tpls))\n\t}\n}\n\nfunc TestChartValuesContainsIsRoot(t *testing.T) {\n\tch1 := &chart.Chart{\n\t\tMetadata: &chart.Metadata{Name: \"parent\"},\n\t\tTemplates: []*chart.File{\n\t\t\t{Name: \"templates/isroot\", Data: []byte(\"{{.Chart.IsRoot}}\")},\n\t\t},\n\t}\n\tdep1 := &chart.Chart{\n\t\tMetadata: &chart.Metadata{Name: \"child\"},\n\t\tTemplates: []*chart.File{\n\t\t\t{Name: \"templates/isroot\", Data: []byte(\"{{.Chart.IsRoot}}\")},\n\t\t},\n\t}\n\tch1.AddDependency(dep1)\n\n\tout, err := Render(ch1, chartutil.Values{})\n\tif err != nil {\n\t\tt.Fatalf(\"failed to render templates: %s\", err)\n\t}\n\texpects := map[string]string{\n\t\t\"parent/charts/child/templates/isroot\": \"false\",\n\t\t\"parent/templates/isroot\":              \"true\",\n\t}\n\tfor file, expect := range expects {\n\t\tif out[file] != expect {\n\t\t\tt.Errorf(\"Expected %q, got %q\", expect, out[file])\n\t\t}\n\t}\n}\n\nfunc TestRenderDependency(t *testing.T) {\n\tdeptpl := `{{define \"myblock\"}}World{{end}}`\n\ttoptpl := `Hello {{template \"myblock\"}}`\n\tch := &chart.Chart{\n\t\tMetadata: &chart.Metadata{Name: \"outerchart\"},\n\t\tTemplates: []*chart.File{\n\t\t\t{Name: \"templates/outer\", Data: []byte(toptpl)},\n\t\t},\n\t}\n\tch.AddDependency(&chart.Chart{\n\t\tMetadata: &chart.Metadata{Name: \"innerchart\"},\n\t\tTemplates: []*chart.File{\n\t\t\t{Name: \"templates/inner\", Data: []byte(deptpl)},\n\t\t},\n\t})\n\n\tout, err := Render(ch, map[string]interface{}{})\n\tif err != nil {\n\t\tt.Fatalf(\"failed to render chart: %s\", err)\n\t}\n\n\tif len(out) != 2 {\n\t\tt.Errorf(\"Expected 2, got %d\", len(out))\n\t}\n\n\texpect := \"Hello World\"\n\tif out[\"outerchart/templates/outer\"] != expect {\n\t\tt.Errorf(\"Expected %q, got %q\", expect, out[\"outer\"])\n\t}\n\n}\n\nfunc TestRenderNestedValues(t *testing.T) {\n\tinnerpath := \"templates/inner.tpl\"\n\touterpath := \"templates/outer.tpl\"\n\t// Ensure namespacing rules are working.\n\tdeepestpath := \"templates/inner.tpl\"\n\tcheckrelease := \"templates/release.tpl\"\n\t// Ensure subcharts scopes are working.\n\tsubchartspath := \"templates/subcharts.tpl\"\n\n\tdeepest := &chart.Chart{\n\t\tMetadata: &chart.Metadata{Name: \"deepest\"},\n\t\tTemplates: []*chart.File{\n\t\t\t{Name: deepestpath, Data: []byte(`And this same {{.Values.what}} that smiles {{.Values.global.when}}`)},\n\t\t\t{Name: checkrelease, Data: []byte(`Tomorrow will be {{default \"happy\" .Release.Name }}`)},\n\t\t},\n\t\tValues: map[string]interface{}{\"what\": \"milkshake\", \"where\": \"here\"},\n\t}\n\n\tinner := &chart.Chart{\n\t\tMetadata: &chart.Metadata{Name: \"herrick\"},\n\t\tTemplates: []*chart.File{\n\t\t\t{Name: innerpath, Data: []byte(`Old {{.Values.who}} is still a-flyin'`)},\n\t\t},\n\t\tValues: map[string]interface{}{\"who\": \"Robert\", \"what\": \"glasses\"},\n\t}\n\tinner.AddDependency(deepest)\n\n\touter := &chart.Chart{\n\t\tMetadata: &chart.Metadata{Name: \"top\"},\n\t\tTemplates: []*chart.File{\n\t\t\t{Name: outerpath, Data: []byte(`Gather ye {{.Values.what}} while ye may`)},\n\t\t\t{Name: subchartspath, Data: []byte(`The glorious Lamp of {{.Subcharts.herrick.Subcharts.deepest.Values.where}}, the {{.Subcharts.herrick.Values.what}}`)},\n\t\t},\n\t\tValues: map[string]interface{}{\n\t\t\t\"what\": \"stinkweed\",\n\t\t\t\"who\":  \"me\",\n\t\t\t\"herrick\": map[string]interface{}{\n\t\t\t\t\"who\":  \"time\",\n\t\t\t\t\"what\": \"Sun\",\n\t\t\t},\n\t\t},\n\t}\n\touter.AddDependency(inner)\n\n\tinjValues := map[string]interface{}{\n\t\t\"what\": \"rosebuds\",\n\t\t\"herrick\": map[string]interface{}{\n\t\t\t\"deepest\": map[string]interface{}{\n\t\t\t\t\"what\":  \"flower\",\n\t\t\t\t\"where\": \"Heaven\",\n\t\t\t},\n\t\t},\n\t\t\"global\": map[string]interface{}{\n\t\t\t\"when\": \"to-day\",\n\t\t},\n\t}\n\n\ttmp, err := chartutil.CoalesceValues(outer, injValues)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to coalesce values: %s\", err)\n\t}\n\n\tinject := chartutil.Values{\n\t\t\"Values\": tmp,\n\t\t\"Chart\":  outer.Metadata,\n\t\t\"Release\": chartutil.Values{\n\t\t\t\"Name\": \"dyin\",\n\t\t},\n\t}\n\n\tt.Logf(\"Calculated values: %v\", inject)\n\n\tout, err := Render(outer, inject)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to render templates: %s\", err)\n\t}\n\n\tfullouterpath := \"top/\" + outerpath\n\tif out[fullouterpath] != \"Gather ye rosebuds while ye may\" {\n\t\tt.Errorf(\"Unexpected outer: %q\", out[fullouterpath])\n\t}\n\n\tfullinnerpath := \"top/charts/herrick/\" + innerpath\n\tif out[fullinnerpath] != \"Old time is still a-flyin'\" {\n\t\tt.Errorf(\"Unexpected inner: %q\", out[fullinnerpath])\n\t}\n\n\tfulldeepestpath := \"top/charts/herrick/charts/deepest/\" + deepestpath\n\tif out[fulldeepestpath] != \"And this same flower that smiles to-day\" {\n\t\tt.Errorf(\"Unexpected deepest: %q\", out[fulldeepestpath])\n\t}\n\n\tfullcheckrelease := \"top/charts/herrick/charts/deepest/\" + checkrelease\n\tif out[fullcheckrelease] != \"Tomorrow will be dyin\" {\n\t\tt.Errorf(\"Unexpected release: %q\", out[fullcheckrelease])\n\t}\n\n\tfullchecksubcharts := \"top/\" + subchartspath\n\tif out[fullchecksubcharts] != \"The glorious Lamp of Heaven, the Sun\" {\n\t\tt.Errorf(\"Unexpected subcharts: %q\", out[fullchecksubcharts])\n\t}\n}\n\nfunc TestRenderBuiltinValues(t *testing.T) {\n\tinner := &chart.Chart{\n\t\tMetadata: &chart.Metadata{Name: \"Latium\"},\n\t\tTemplates: []*chart.File{\n\t\t\t{Name: \"templates/Lavinia\", Data: []byte(`{{.Template.Name}}{{.Chart.Name}}{{.Release.Name}}`)},\n\t\t\t{Name: \"templates/From\", Data: []byte(`{{.Files.author | printf \"%s\"}} {{.Files.Get \"book/title.txt\"}}`)},\n\t\t},\n\t\tFiles: []*chart.File{\n\t\t\t{Name: \"author\", Data: []byte(\"Virgil\")},\n\t\t\t{Name: \"book/title.txt\", Data: []byte(\"Aeneid\")},\n\t\t},\n\t}\n\n\touter := &chart.Chart{\n\t\tMetadata: &chart.Metadata{Name: \"Troy\"},\n\t\tTemplates: []*chart.File{\n\t\t\t{Name: \"templates/Aeneas\", Data: []byte(`{{.Template.Name}}{{.Chart.Name}}{{.Release.Name}}`)},\n\t\t\t{Name: \"templates/Amata\", Data: []byte(`{{.Subcharts.Latium.Chart.Name}} {{.Subcharts.Latium.Files.author | printf \"%s\"}}`)},\n\t\t},\n\t}\n\touter.AddDependency(inner)\n\n\tinject := chartutil.Values{\n\t\t\"Values\": \"\",\n\t\t\"Chart\":  outer.Metadata,\n\t\t\"Release\": chartutil.Values{\n\t\t\t\"Name\": \"Aeneid\",\n\t\t},\n\t}\n\n\tt.Logf(\"Calculated values: %v\", outer)\n\n\tout, err := Render(outer, inject)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to render templates: %s\", err)\n\t}\n\n\texpects := map[string]string{\n\t\t\"Troy/charts/Latium/templates/Lavinia\": \"Troy/charts/Latium/templates/LaviniaLatiumAeneid\",\n\t\t\"Troy/templates/Aeneas\":                \"Troy/templates/AeneasTroyAeneid\",\n\t\t\"Troy/templates/Amata\":                 \"Latium Virgil\",\n\t\t\"Troy/charts/Latium/templates/From\":    \"Virgil Aeneid\",\n\t}\n\tfor file, expect := range expects {\n\t\tif out[file] != expect {\n\t\t\tt.Errorf(\"Expected %q, got %q\", expect, out[file])\n\t\t}\n\t}\n\n}\n\nfunc TestAlterFuncMap_include(t *testing.T) {\n\tc := &chart.Chart{\n\t\tMetadata: &chart.Metadata{Name: \"conrad\"},\n\t\tTemplates: []*chart.File{\n\t\t\t{Name: \"templates/quote\", Data: []byte(`{{include \"conrad/templates/_partial\" . | indent 2}} dead.`)},\n\t\t\t{Name: \"templates/_partial\", Data: []byte(`{{.Release.Name}} - he`)},\n\t\t},\n\t}\n\n\t// Check nested reference in include FuncMap\n\td := &chart.Chart{\n\t\tMetadata: &chart.Metadata{Name: \"nested\"},\n\t\tTemplates: []*chart.File{\n\t\t\t{Name: \"templates/quote\", Data: []byte(`{{include \"nested/templates/quote\" . | indent 2}} dead.`)},\n\t\t\t{Name: \"templates/_partial\", Data: []byte(`{{.Release.Name}} - he`)},\n\t\t},\n\t}\n\n\tv := chartutil.Values{\n\t\t\"Values\": \"\",\n\t\t\"Chart\":  c.Metadata,\n\t\t\"Release\": chartutil.Values{\n\t\t\t\"Name\": \"Mistah Kurtz\",\n\t\t},\n\t}\n\n\tout, err := Render(c, v)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\texpect := \"  Mistah Kurtz - he dead.\"\n\tif got := out[\"conrad/templates/quote\"]; got != expect {\n\t\tt.Errorf(\"Expected %q, got %q (%v)\", expect, got, out)\n\t}\n\n\t_, err = Render(d, v)\n\texpectErrName := \"nested/templates/quote\"\n\tif err == nil {\n\t\tt.Errorf(\"Expected err of nested reference name: %v\", expectErrName)\n\t}\n}\n\nfunc TestAlterFuncMap_require(t *testing.T) {\n\tc := &chart.Chart{\n\t\tMetadata: &chart.Metadata{Name: \"conan\"},\n\t\tTemplates: []*chart.File{\n\t\t\t{Name: \"templates/quote\", Data: []byte(`All your base are belong to {{ required \"A valid 'who' is required\" .Values.who }}`)},\n\t\t\t{Name: \"templates/bases\", Data: []byte(`All {{ required \"A valid 'bases' is required\" .Values.bases }} of them!`)},\n\t\t},\n\t}\n\n\tv := chartutil.Values{\n\t\t\"Values\": chartutil.Values{\n\t\t\t\"who\":   \"us\",\n\t\t\t\"bases\": 2,\n\t\t},\n\t\t\"Chart\": c.Metadata,\n\t\t\"Release\": chartutil.Values{\n\t\t\t\"Name\": \"That 90s meme\",\n\t\t},\n\t}\n\n\tout, err := Render(c, v)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\texpectStr := \"All your base are belong to us\"\n\tif gotStr := out[\"conan/templates/quote\"]; gotStr != expectStr {\n\t\tt.Errorf(\"Expected %q, got %q (%v)\", expectStr, gotStr, out)\n\t}\n\texpectNum := \"All 2 of them!\"\n\tif gotNum := out[\"conan/templates/bases\"]; gotNum != expectNum {\n\t\tt.Errorf(\"Expected %q, got %q (%v)\", expectNum, gotNum, out)\n\t}\n\n\t// test required without passing in needed values with lint mode on\n\t// verifies lint replaces required with an empty string (should not fail)\n\tlintValues := chartutil.Values{\n\t\t\"Values\": chartutil.Values{\n\t\t\t\"who\": \"us\",\n\t\t},\n\t\t\"Chart\": c.Metadata,\n\t\t\"Release\": chartutil.Values{\n\t\t\t\"Name\": \"That 90s meme\",\n\t\t},\n\t}\n\tvar e Engine\n\te.LintMode = true\n\tout, err = e.Render(c, lintValues)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\texpectStr = \"All your base are belong to us\"\n\tif gotStr := out[\"conan/templates/quote\"]; gotStr != expectStr {\n\t\tt.Errorf(\"Expected %q, got %q (%v)\", expectStr, gotStr, out)\n\t}\n\texpectNum = \"All  of them!\"\n\tif gotNum := out[\"conan/templates/bases\"]; gotNum != expectNum {\n\t\tt.Errorf(\"Expected %q, got %q (%v)\", expectNum, gotNum, out)\n\t}\n}\n\nfunc TestAlterFuncMap_tpl(t *testing.T) {\n\tc := &chart.Chart{\n\t\tMetadata: &chart.Metadata{Name: \"TplFunction\"},\n\t\tTemplates: []*chart.File{\n\t\t\t{Name: \"templates/base\", Data: []byte(`Evaluate tpl {{tpl \"Value: {{ .Values.value}}\" .}}`)},\n\t\t},\n\t}\n\n\tv := chartutil.Values{\n\t\t\"Values\": chartutil.Values{\n\t\t\t\"value\": \"myvalue\",\n\t\t},\n\t\t\"Chart\": c.Metadata,\n\t\t\"Release\": chartutil.Values{\n\t\t\t\"Name\": \"TestRelease\",\n\t\t},\n\t}\n\n\tout, err := Render(c, v)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\texpect := \"Evaluate tpl Value: myvalue\"\n\tif got := out[\"TplFunction/templates/base\"]; got != expect {\n\t\tt.Errorf(\"Expected %q, got %q (%v)\", expect, got, out)\n\t}\n}\n\nfunc TestAlterFuncMap_tplfunc(t *testing.T) {\n\tc := &chart.Chart{\n\t\tMetadata: &chart.Metadata{Name: \"TplFunction\"},\n\t\tTemplates: []*chart.File{\n\t\t\t{Name: \"templates/base\", Data: []byte(`Evaluate tpl {{tpl \"Value: {{ .Values.value | quote}}\" .}}`)},\n\t\t},\n\t}\n\n\tv := chartutil.Values{\n\t\t\"Values\": chartutil.Values{\n\t\t\t\"value\": \"myvalue\",\n\t\t},\n\t\t\"Chart\": c.Metadata,\n\t\t\"Release\": chartutil.Values{\n\t\t\t\"Name\": \"TestRelease\",\n\t\t},\n\t}\n\n\tout, err := Render(c, v)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\texpect := \"Evaluate tpl Value: \\\"myvalue\\\"\"\n\tif got := out[\"TplFunction/templates/base\"]; got != expect {\n\t\tt.Errorf(\"Expected %q, got %q (%v)\", expect, got, out)\n\t}\n}\n\nfunc TestAlterFuncMap_tplinclude(t *testing.T) {\n\tc := &chart.Chart{\n\t\tMetadata: &chart.Metadata{Name: \"TplFunction\"},\n\t\tTemplates: []*chart.File{\n\t\t\t{Name: \"templates/base\", Data: []byte(`{{ tpl \"{{include ` + \"`\" + `TplFunction/templates/_partial` + \"`\" + ` .  | quote }}\" .}}`)},\n\t\t\t{Name: \"templates/_partial\", Data: []byte(`{{.Template.Name}}`)},\n\t\t},\n\t}\n\tv := chartutil.Values{\n\t\t\"Values\": chartutil.Values{\n\t\t\t\"value\": \"myvalue\",\n\t\t},\n\t\t\"Chart\": c.Metadata,\n\t\t\"Release\": chartutil.Values{\n\t\t\t\"Name\": \"TestRelease\",\n\t\t},\n\t}\n\n\tout, err := Render(c, v)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\texpect := \"\\\"TplFunction/templates/base\\\"\"\n\tif got := out[\"TplFunction/templates/base\"]; got != expect {\n\t\tt.Errorf(\"Expected %q, got %q (%v)\", expect, got, out)\n\t}\n\n}\n\nfunc TestRenderRecursionLimit(t *testing.T) {\n\t// endless recursion should produce an error\n\tc := &chart.Chart{\n\t\tMetadata: &chart.Metadata{Name: \"bad\"},\n\t\tTemplates: []*chart.File{\n\t\t\t{Name: \"templates/base\", Data: []byte(`{{include \"recursion\" . }}`)},\n\t\t\t{Name: \"templates/recursion\", Data: []byte(`{{define \"recursion\"}}{{include \"recursion\" . }}{{end}}`)},\n\t\t},\n\t}\n\tv := chartutil.Values{\n\t\t\"Values\": \"\",\n\t\t\"Chart\":  c.Metadata,\n\t\t\"Release\": chartutil.Values{\n\t\t\t\"Name\": \"TestRelease\",\n\t\t},\n\t}\n\texpectErr := \"rendering template has a nested reference name: recursion: unable to execute template\"\n\n\t_, err := Render(c, v)\n\tif err == nil || !strings.HasSuffix(err.Error(), expectErr) {\n\t\tt.Errorf(\"Expected err with suffix: %s\", expectErr)\n\t}\n\n\t// calling the same function many times is ok\n\ttimes := 4000\n\tphrase := \"All work and no play makes Jack a dull boy\"\n\tprintFunc := `{{define \"overlook\"}}{{printf \"` + phrase + `\\n\"}}{{end}}`\n\tvar repeatedIncl string\n\tfor i := 0; i < times; i++ {\n\t\trepeatedIncl += `{{include \"overlook\" . }}`\n\t}\n\n\td := &chart.Chart{\n\t\tMetadata: &chart.Metadata{Name: \"overlook\"},\n\t\tTemplates: []*chart.File{\n\t\t\t{Name: \"templates/quote\", Data: []byte(repeatedIncl)},\n\t\t\t{Name: \"templates/_function\", Data: []byte(printFunc)},\n\t\t},\n\t}\n\n\tout, err := Render(d, v)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tvar expect string\n\tfor i := 0; i < times; i++ {\n\t\texpect += phrase + \"\\n\"\n\t}\n\tif got := out[\"overlook/templates/quote\"]; got != expect {\n\t\tt.Errorf(\"Expected %q, got %q (%v)\", expect, got, out)\n\t}\n\n}\n"], "filenames": ["cmd/helm/install.go", "cmd/helm/upgrade.go", "pkg/action/action.go", "pkg/action/install.go", "pkg/action/upgrade.go", "pkg/engine/engine.go", "pkg/engine/engine_test.go"], "buggy_code_start_loc": [172, 121, 104, 99, 105, 44, 20], "buggy_code_end_loc": [172, 234, 136, 464, 235, 191, 199], "fixing_code_start_loc": [173, 122, 104, 100, 106, 45, 21], "fixing_code_end_loc": [174, 237, 141, 466, 237, 209, 239], "type": "CWE-200", "message": "Helm is a tool that streamlines installing and managing Kubernetes applications.`getHostByName` is a Helm template function introduced in Helm v3. The function is able to accept a hostname and return an IP address for that hostname. To get the IP address the function performs a DNS lookup. The DNS lookup happens when used with `helm install|upgrade|template` or when the Helm SDK is used to render a chart. Information passed into the chart can be disclosed to the DNS servers used to lookup the IP address. For example, a malicious chart could inject `getHostByName` into a chart in order to disclose values to a malicious DNS server. The issue has been fixed in Helm 3.11.1. Prior to using a chart with Helm verify the `getHostByName` function is not being used in a template to disclose any information you do not want passed to DNS servers.", "other": {"cve": {"id": "CVE-2023-25165", "sourceIdentifier": "security-advisories@github.com", "published": "2023-02-08T20:15:24.937", "lastModified": "2023-02-16T20:10:18.263", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Helm is a tool that streamlines installing and managing Kubernetes applications.`getHostByName` is a Helm template function introduced in Helm v3. The function is able to accept a hostname and return an IP address for that hostname. To get the IP address the function performs a DNS lookup. The DNS lookup happens when used with `helm install|upgrade|template` or when the Helm SDK is used to render a chart. Information passed into the chart can be disclosed to the DNS servers used to lookup the IP address. For example, a malicious chart could inject `getHostByName` into a chart in order to disclose values to a malicious DNS server. The issue has been fixed in Helm 3.11.1. Prior to using a chart with Helm verify the `getHostByName` function is not being used in a template to disclose any information you do not want passed to DNS servers."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-200"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:helm:helm:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.0.0", "versionEndExcluding": "3.11.1", "matchCriteriaId": "52B3342E-F1D8-46B9-91C1-192092207FFA"}]}]}], "references": [{"url": "https://github.com/helm/helm/commit/5abcf74227bfe8e5a3dbf105fe62e7b12deb58d2", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/helm/helm/security/advisories/GHSA-pwcw-6f5g-gxf8", "source": "security-advisories@github.com", "tags": ["Exploit", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/helm/helm/commit/5abcf74227bfe8e5a3dbf105fe62e7b12deb58d2"}}