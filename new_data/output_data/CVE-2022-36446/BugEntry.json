{"buggy_code": ["# apt-lib.pl\n# Functions for installing packages from debian APT\n\n$apt_get_command = $config{'apt_mode'} ? \"aptitude\" : \"apt-get\";\n$apt_search_command = $config{'apt_mode'} ? \"aptitude\" : \"apt-cache\";\n$sources_list_file = \"/etc/apt/sources.list\";\n$sources_list_dir = \"/etc/apt/sources.list.d\";\n\nsub list_update_system_commands\n{\nreturn ($apt_get_command, $apt_search_command);\n}\n\n# update_system_install([package], [&in], [no-force])\n# Install some package with apt\nsub update_system_install\n{\nlocal $update = $_[0] || $in{'update'};\nlocal $force = !$_[2];\nlocal (@rv, @newpacks);\n\n# Build the command to run\n$ENV{'DEBIAN_FRONTEND'} = 'noninteractive';\n$update = join(\" \", map { quotemeta($_) } split(/\\s+/, $update));\n$update =~ s/\\\\(-)|\\\\(.)/$1$2/g;\nlocal $cmd = \"$apt_get_command -y \".($force ? \" -f\" : \"\").\" install $update\";\nprint \"<b>\",&text('apt_install', \"<tt>$cmd</tt>\"),\"</b><p>\\n\";\nprint \"<pre>\";\n&additional_log('exec', undef, $cmd);\n\n# Run dpkg --configure -a to clear any un-configured packages\n$SIG{'TERM'} = 'ignore';\t# This may cause a Webmin re-config!\nlocal $out = &backquote_logged(\"dpkg --configure -a 2>&1 </dev/null\");\nprint &html_escape($out);\n\n# Create an input file of 'yes'\nlocal $yesfile = &transname();\n&open_tempfile(YESFILE, \">$yesfile\", 0, 1);\nforeach (0..100) {\n\t&print_tempfile(YESFILE, \"Yes\\n\");\n\t}\n&close_tempfile(YESFILE);\n\n# Run the command\n&clean_language();\n&open_execute_command(CMD, \"$cmd <\".quotemeta($yesfile), 2);\nwhile(<CMD>) {\n\tif (/setting\\s+up\\s+(\\S+)/i && !/as\\s+MDA/i) {\n\t\tpush(@rv, $1);\n\t\t}\n\telsif (/packages\\s+will\\s+be\\s+upgraded/i ||\n\t       /new\\s+packages\\s+will\\s+be\\s+installed/i) {\n\t\tprint;\n\t\t$line = $_ = <CMD>;\n\t\t$line =~ s/^\\s+//; $line =~ s/\\s+$//;\n\t\tpush(@newpacks, split(/\\s+/, $line));\n\t\t}\n\tprint &html_escape(\"$_\");\n\t}\nclose(CMD);\n&reset_environment();\nif (!@rv && $config{'package_system'} ne 'debian' && !$?) {\n\t# Other systems don't list the packages installed!\n\t@rv = @newpacks;\n\t}\nprint \"</pre>\\n\";\nif ($?) { print \"<b>$text{'apt_failed'}</b><p>\\n\"; }\nelse { print \"<b>$text{'apt_ok'}</b><p>\\n\"; }\nreturn @rv;\n}\n\n# update_system_operations(packages)\n# Given a list of packages, returns a list containing packages that will\n# actually get installed, each of which is a hash ref with name and version.\nsub update_system_operations\n{\nmy ($packages) = @_;\n$ENV{'DEBIAN_FRONTEND'} = 'noninteractive';\nmy $cmd = \"apt-get -s install \".\n\t  join(\" \", map { quotemeta($_) } split(/\\s+/, $packages)).\n\t  \" </dev/null 2>&1\";\n&clean_language();\nmy $out = &backquote_command($cmd);\n&reset_environment();\nmy @rv;\nforeach my $l (split(/\\r?\\n/, $out)) {\n\tif ($l =~ /Inst\\s+(\\S+)\\s+\\[(\\S+)\\]\\s+\\(([^ \\)]+)/ ||\n\t    $l =~ /Inst\\s+(\\S+)\\s+\\[(\\S+)\\]/) {\n\t\t# Format like : Inst telnet [amd64] (5.6.7 Ubuntu)\n\t\tmy $pkg = { 'name' => $1,\n\t\t\t    'version' => $3 || $2 };\n\t\tif ($pkg->{'version'} =~ s/^(\\S+)://) {\n\t\t\t$pkg->{'epoch'} = $1;\n\t\t\t}\n\t\tpush(@rv, $pkg);\n\t\t}\n\telsif ($l =~ /Inst\\s+(\\S+)\\s+\\(([^ \\)]+)/) {\n\t\t# Format like : Inst telnet (5.6.7 Ubuntu [amd64])\n\t\tmy $pkg = { 'name' => $1,\n\t\t\t    'version' => $2 };\n\t\tif ($pkg->{'version'} =~ s/^(\\S+)://) {\n\t\t\t$pkg->{'epoch'} = $1;\n\t\t\t}\n\t\tpush(@rv, $pkg);\n\t\t}\n\t}\nreturn @rv;\n}\n\n# update_system_form()\n# Shows a form for updating all packages on the system\nsub update_system_form\n{\nprint &ui_subheading($text{'apt_form'});\nprint &ui_form_start(\"apt_upgrade.cgi\");\nprint &ui_table_start($text{'apt_header'}, undef, 2);\n\nprint &ui_table_row($text{'apt_update'},\n\t&ui_yesno_radio(\"update\", 1));\n\nprint &ui_table_row($text{'apt_mode'},\n\t&ui_radio(\"mode\", 0, [ [ 2, $text{'apt_mode2'} ],\n\t\t\t       [ 1, $text{'apt_mode1'} ],\n\t\t\t       [ 0, $text{'apt_mode0'} ] ]));\n\nprint &ui_table_row($text{'apt_sim'},\n\t&ui_yesno_radio(\"sim\", 0));\n\nprint &ui_table_end();\nprint &ui_form_end([ [ undef, $text{'apt_apply'} ] ]);\n}\n\n# update_system_resolve(name)\n# Converts a standard package name like apache, sendmail or squid into\n# the name used by APT.\nsub update_system_resolve\n{\nlocal ($name) = @_;\nreturn $name eq \"dhcpd\" && $gconfig{'os_version'} >= 7 ?\n\t\t\"isc-dhcp-server\" :\n       $name eq \"dhcpd\" && $gconfig{'os_version'} < 7 ?\n\t\t\"dhcp3-server\" :\n       $name eq \"bind\" ? \"bind9\" :\n       $name eq \"mysql\" && $gconfig{'os_version'} >= 10 ?\n\t\t\"mariadb-client mariadb-server\" :\n       $name eq \"mysql\" && $gconfig{'os_version'} >= 7 ?\n\t\t\"mysql-client mysql-server\" :\n       $name eq \"mysql\" && $gconfig{'os_version'} < 7 ?\n\t\t\"mysql-client mysql-server mysql-admin\" :\n       $name eq \"apache\" ? \"apache2\" :\n       $name eq \"squid\" && $gconfig{'os_version'} >= 8 ?\n\t\t\"squid3\" :\n       $name eq \"postgresql\" ? \"postgresql postgresql-client\" :\n       $name eq \"openssh\" ? \"ssh\" :\n       $name eq \"openldap\" ? \"slapd\" :\n       $name eq \"ldap\" ? \"libnss-ldap libpam-ldap\" :\n       $name eq \"dovecot\" ? \"dovecot-common dovecot-imapd dovecot-pop3d\" :\n       $name eq \"virtualmin-modules\" ? \"webmin-.*\" :\n\t\t\t       $name;\n}\n\n# update_system_available()\n# Returns a list of package names and versions that are available from APT\nsub update_system_available\n{\nlocal (@rv, $pkg, %done);\n\n# Use dump to get versions\n&execute_command(\"$apt_get_command update\");\n&clean_language();\n&open_execute_command(DUMP, \"apt-cache dumpavail 2>/dev/null\", 1, 1);\nwhile(<DUMP>) {\n\tif (/^\\s*Package:\\s*(\\S+)/) {\n\t\t$pkg = { 'name' => $1 };\n\t\tpush(@rv, $pkg);\n\t\t$done{$1} = $pkg;\n\t\t}\n\telsif (/^\\s*Version:\\s*(\\S+)/ && $pkg && !$pkg->{'version'}) {\n\t\t$pkg->{'version'} = $1;\n\t\tif ($pkg->{'version'} =~ /^(\\d+):(.*)$/) {\n\t\t\t$pkg->{'epoch'} = $1;\n\t\t\t$pkg->{'version'} = $2;\n\t\t\t}\n\t\t}\n\telsif (/^\\s*File:\\s*(\\S+)/ && $pkg) {\n\t\t$pkg->{'file'} ||= $1;\n\t\t}\n\t}\nclose(DUMP);\n&reset_environment();\n\n# Use search to get descriptions\nforeach my $s (&update_system_search('.*')) {\n\tmy $pkg = $done{$s->{'name'}};\n\tif ($pkg) {\n\t\t$pkg->{'desc'} = $s->{'desc'};\n\t\t}\n\t}\n\n&set_pinned_versions(\\@rv);\nreturn @rv;\n}\n\n# update_system_search(text)\n# Returns a list of packages matching some search\nsub update_system_search\n{\nlocal (@rv, $pkg);\n&clean_language();\n&open_execute_command(DUMP, \"$apt_search_command search \".\n\t\t\t    quotemeta($_[0]).\" 2>/dev/null\", 1, 1);\nwhile(<DUMP>) {\n\tif (/^(\\S+)\\s*-\\s*(.*)/) {\n\t\tpush(@rv, { 'name' => $1, 'desc' => $2 });\n\t\t}\n\telsif (/^(\\S)\\s+(\\S+)\\s+-\\s*(.*)/) {\n\t\tpush(@rv, { 'name' => $2, 'desc' => $3 });\n\t\t}\n\t}\nclose(DUMP);\n&reset_environment();\nreturn @rv;\n}\n\n# update_system_updates()\n# Returns a list of available package updates\nsub update_system_updates\n{\n&execute_command(\"$apt_get_command update\");\n\n# Find held packages by dpkg\nlocal %holds;\nif ($config{'package_system'} eq 'debian') {\n\t&clean_language();\n\t&open_execute_command(HOLDS, \"dpkg --get-selections\", 1, 1);\n\twhile(<HOLDS>) {\n\t\tif (/^(\\S+)\\s+hold/) {\n\t\t\t$holds{$1}++;\n\t\t\t}\n\t\t}\n\tclose(HOLDS);\n\t&reset_environment();\n\t}\n\nif (&has_command(\"apt-show-versions\")) {\n\t# This awesome command can give us all updates in one hit, and takes\n\t# pinned versions and backports into account\n\tlocal @rv;\n\t&clean_language();\n\t&execute_command(\"apt-show-versions -i\");\n\t&open_execute_command(PKGS, \"apt-show-versions 2>/dev/null\", 1, 1);\n\twhile(<PKGS>) {\n\t\tif (/^(\\S+)\\/(\\S+)\\s+upgradeable\\s+from\\s+(\\S+)\\s+to\\s+(\\S+)/ &&\n\t\t    !$holds{$1}) {\n\t\t\t# Old format\n\t\t\tlocal $pkg = { 'name' => $1,\n\t\t\t\t       'source' => $2,\n\t\t\t\t       'version' => $4 };\n\t\t\tif ($pkg->{'version'} =~ s/^(\\S+)://) {\n\t\t\t\t$pkg->{'epoch'} = $1;\n\t\t\t\t}\n\t\t\tpush(@rv, $pkg);\n\t\t\t}\n\t\telsif (/^(\\S+):(\\S+)\\/(\\S+)\\s+(\\S+)\\s+upgradeable\\s+to\\s+(\\S+)/ && !$holds{$1}) {\n\t\t\t# New format, like \n\t\t\t# libgomp1:i386/unstable 4.8.2-2 upgradeable to 4.8.2-4\n\t\t\tlocal $pkg = { 'name' => $1,\n\t\t\t\t       'arch' => $2,\n\t\t\t\t       'source' => $3,\n\t\t\t\t       'version' => $5 };\n\t\t\tif ($pkg->{'version'} =~ s/^(\\S+)://) {\n\t\t\t\t$pkg->{'epoch'} = $1;\n\t\t\t\t}\n\t\t\tpush(@rv, $pkg);\n\t\t\t}\n\t\t}\n\tclose(PKGS);\n\t&reset_environment();\n\t@rv = &filter_held_packages(@rv);\n\tforeach my $pkg (@rv) {\n\t\t$pkg->{'security'} = 1 if ($pkg->{'source'} =~ /security/i);\n\t\t}\n\treturn @rv;\n\t}\nelsif (&has_command(\"apt\")) {\n\t# Use the apt list command\n\tlocal @rv;\n\t&clean_language();\n\t&open_execute_command(PKGS, \"apt list --upgradable 2>/dev/null\", 1, 1);\n\twhile(<PKGS>) {\n\t\tif (/^(\\S+)\\/(\\S+)\\s+(\\S+)\\s+(\\S+)\\s+\\[upgradable\\s+from:\\s+(\\S+)\\]/ && !$holds{$1}) {\n\t\t\tlocal $pkg = { 'name' => $1,\n\t\t\t\t       'source' => $2,\n\t\t\t\t       'version' => $3,\n\t\t\t\t       'arch' => $4 };\n\t\t\tif ($pkg->{'version'} =~ s/^(\\S+)://) {\n\t\t\t\t$pkg->{'epoch'} = $1;\n\t\t\t\t}\n\t\t\t$pkg->{'source'} =~ s/,.*$//;\n\t\t\tpush(@rv, $pkg);\n\t\t\t}\n\t\t}\n\tclose(PKGS);\n\t&reset_environment();\n\t@rv = &filter_held_packages(@rv);\n\tforeach my $pkg (@rv) {\n\t\t$pkg->{'security'} = 1 if ($pkg->{'source'} =~ /security/i);\n\t\t}\n\treturn @rv;\n\t}\nelse {\n\t# Need to manually compose by calling dpkg and apt-cache showpkg\n\tlocal %packages;\n\tlocal $n = &list_packages();\n\tlocal %currentmap;\n\tfor(my $i=0; $i<$n; $i++) {\n\t\tlocal $pkg = { 'name' => $packages{$i,'name'},\n\t\t\t       'oldversion' => $packages{$i,'version'},\n\t\t\t       'desc' => $packages{$i,'desc'},\n\t\t\t       'oldepoch' => $packages{$i,'epoch'} };\n\t\t$currentmap{$pkg->{'name'}} ||= $pkg;\n\t\t}\n\tlocal @rv;\n\tlocal @names = grep { !$holds{$_} } keys %currentmap;\n\twhile(scalar(@names)) {\n\t\tlocal @somenames;\n\t\tif (scalar(@names) > 100) {\n\t\t\t# Do 100 at a time\n\t\t\t@somenames = @names[0..99];\n\t\t\t@names = @names[100..$#names];\n\t\t\t}\n\t\telse {\n\t\t\t# Do the rest\n\t\t\t@somenames = @names;\n\t\t\t@names = ( );\n\t\t\t}\n\t\t&clean_language();\n\t\t&open_execute_command(PKGS, \"apt-cache showpkg \".\n\t\t\tjoin(\" \", @somenames).\" 2>/dev/null\", 1, 1);\n\t\tlocal $pkg = undef;\n\t\twhile(<PKGS>) {\n\t\t\ts/\\r|\\n//g;\n\t\t\tif (/^\\s*Package:\\s*(\\S+)/) {\n\t\t\t\t$pkg = $currentmap{$1};\n\t\t\t\t}\n\t\t\telsif (/^Versions:\\s*$/ && $pkg && !$pkg->{'version'}) {\n\t\t\t\t# Newest version is on next line\n\t\t\t\tlocal $ver = <PKGS>;\n\t\t\t\t$ver =~ s/\\s.*\\r?\\n//;\n\t\t\t\tlocal $epoch;\n\t\t\t\tif ($ver =~ s/^(\\d+)://) {\n\t\t\t\t\t$epoch = $1;\n\t\t\t\t\t}\n\t\t\t\t$pkg->{'version'} = $ver;\n\t\t\t\t$pkg->{'epoch'} = $epoch;\n\t\t\t\tlocal $newer =\n\t\t\t\t    $pkg->{'epoch'} <=> $pkg->{'oldepoch'} ||\n\t\t\t\t    &compare_versions($pkg->{'version'},\n\t\t\t\t\t\t      $pkg->{'oldversion'});\n\t\t\t\tif ($newer > 0) {\n\t\t\t\t\tpush(@rv, $pkg);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\tclose(PKGS);\n\t\t&reset_environment();\n\t\t}\n\t@rv = &filter_held_packages(@rv);\n\t&set_pinned_versions(\\@rv);\n\treturn @rv;\n\t}\n}\n\n# set_pinned_versions(&package-list)\n# Updates the version and epoch fields in a list of available packages based\n# on pinning.\nsub set_pinned_versions\n{\nlocal ($pkgs) = @_;\nlocal %pkgmap = map { $_->{'name'}, $_ } @$pkgs;\n&clean_language();\n&open_execute_command(PKGS, \"apt-cache policy 2>/dev/null\", 1, 1);\nwhile(<PKGS>) { \n\ts/\\r|\\n//g;\n\tif (/\\s+(\\S+)\\s+\\-\\>\\s+(\\S+)/) {\n\t\tmy ($name, $pin) = ($1, $2);\n\t\tmy $pkg = $pkgmap{$name};\n\t\tif ($pkg) {\n\t\t\t$pkg->{'version'} = $pin;\n\t\t\t$pkg->{'epoch'} = undef;\n\t\t\tif ($pkg->{'version'} =~ s/^(\\S+)://) {\n\t\t\t\t$pkg->{'epoch'} = $1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\nclose(PKGS);\n&reset_environment();\n}\n\n# filter_held_packages(package, ...)\n# Returns a list of package updates, minus those that are held\nsub filter_held_packages\n{\nmy @pkgs = @_;\nmy %hold;\n\n# Get holds from dpkg\n&clean_language();\n&open_execute_command(PKGS, \"dpkg --get-selections 2>/dev/null\", 1, 1);\nwhile(<PKGS>) { \n\tif (/^(\\S+)\\s+hold/) {\n\t\t$hold{$1} = 1;\n\t\t}\n\t}\nclose(PKGS);\n&reset_environment();\n\n# Get holds from aptitude\nif (&has_command(\"aptitude\")) {\n\t&clean_language();\n\t&open_execute_command(PKGS, \"aptitude search '~ahold' 2>/dev/null\", 1, 1);\n\twhile(<PKGS>) { \n\t\tif (/^\\.h\\s+(\\S+)/) {\n\t\t\t$hold{$1} = 1;\n\t\t\t}\n\t\t}\n\tclose(PKGS);\n\t&reset_environment();\n\t}\n\n# Get holds from apt-mark\nif (&has_command(\"apt-mark\")) {\n\t&clean_language();\n\t&open_execute_command(PKGS, \"apt-mark showhold 2>/dev/null\", 1, 1);\n\twhile(<PKGS>) { \n\t\tif (/^([^:\\s]+)/) {\n\t\t\t$hold{$1} = 1;\n\t\t\t}\n\t\t}\n\tclose(PKGS);\n\t&reset_environment();\n\t}\n\nreturn grep { !$hold{$_->{'name'}} } @pkgs;\n}\n\n# list_package_repos()\n# Returns a list of configured repositories\nsub list_package_repos\n{\nmy @rv;\n\n# Read all repos files\nforeach my $f ($sources_list_file, glob(\"$sources_list_dir/*\")) {\n\tmy $lref = &read_file_lines($f, 1);\n\tmy $lnum = 0;\n\tforeach my $l (@$lref) {\n\t\tif ($l =~ /^(#*)\\s*deb\\s+((http|https)\\S+)\\s+(\\S.*)/) {\n\t\t\tmy $repo = { 'file' => $f,\n\t\t\t\t     'line' => $lnum,\n\t\t\t\t     'words' => \\@w,\n\t\t\t\t     'url' => $2,\n\t\t\t\t     'enabled' => !$1 };\n\t\t\tmy @w = split(/\\s+/, $4);\n\t\t\t$repo->{'name'} = join(\"/\", @w);\n\t\t\t$repo->{'id'} = $repo->{'url'}.$repo->{'name'};\n\t\t\tpush(@rv, $repo);\n\t\t\t}\n\t\t$lnum++;\n\t\t}\n\t}\n\nreturn @rv;\n}\n\n# create_repo_form()\n# Returns HTML for a package repository creation form\nsub create_repo_form \n{\nmy $rv;\n$rv .= &ui_table_row($text{'apt_repo_url'},\n\t\t     &ui_textbox(\"url\", undef, 40));\n$rv .= &ui_table_row($text{'apt_repo_path'},\n\t\t     &ui_textbox(\"path\", undef, 40));\nreturn $rv;\n}\n\n# create_repo_parse(&in)\n# Parses input from create_repo_form, and returns either a new repo object or\n# an error string\nsub create_repo_parse\n{\nmy ($in) = @_;\nmy $repo = { 'enabled' => 1 };\n\n# Parse base URL\n$in->{'url'} =~ /^(http|https|ftp|file):\\S+$/ ||\n\treturn $text{'apt_repo_eurl'};\n$repo->{'url'} = $in->{'url'};\n\n# Parse distro components\nmy @w = split(/\\s+|\\//, $in->{'path'});\n@w || $text{'apt_repo_epath'};\n$repo->{'name'} = join(\"/\", @w);\n$repo->{'id'} = $repo->{'url'}.$repo->{'name'};\n\nreturn $repo;\n}\n\n# create_package_repo(&repo)\n# Creates a new repository from the given hash (returned by create_repo_parse)\nsub create_package_repo\n{\nmy ($repo) = @_;\n&lock_file($sources_list_file);\nmy $lref = &read_file_lines($sources_list_file);\npush(@$lref, ($repo->{'enabled'} ? \"\" : \"# \").\n\t     \"deb \".\n\t     $repo->{'url'}.\" \".\n\t     join(\" \", split(/\\//, $repo->{'name'})));\n&flush_file_lines($sources_list_file);\n&unlock_file($sources_list_file);\nreturn undef;\n}\n\n# delete_package_repo(&repo)\n# Delete a repo from the sources.list file\nsub delete_package_repo\n{\nmy ($repo) = @_;\n&lock_file($repo->{'file'});\nmy $lref = &read_file_lines($repo->{'file'});\nsplice(@$lref, $repo->{'line'}, 1);\n&flush_file_lines($repo->{'file'});\n&unlock_file($repo->{'file'});\n}\n\n# enable_package_repo(&repo, enable?)\n# Enable or disable a repository\nsub enable_package_repo\n{\nmy ($repo, $enable) = @_;\n&lock_file($repo->{'file'});\nmy $lref = &read_file_lines($repo->{'file'});\n$lref->[$repo->{'line'}] =~ s/^#+\\s*//;\nif (!$enable) {\n\t$lref->[$repo->{'line'}] = \"# \".$lref->[$repo->{'line'}];\n\t}\n&flush_file_lines($repo->{'file'});\n&unlock_file($repo->{'file'});\n}\n\n1;\n"], "fixing_code": ["# apt-lib.pl\n# Functions for installing packages from debian APT\n\n$apt_get_command = $config{'apt_mode'} ? \"aptitude\" : \"apt-get\";\n$apt_search_command = $config{'apt_mode'} ? \"aptitude\" : \"apt-cache\";\n$sources_list_file = \"/etc/apt/sources.list\";\n$sources_list_dir = \"/etc/apt/sources.list.d\";\n\nsub list_update_system_commands\n{\nreturn ($apt_get_command, $apt_search_command);\n}\n\n# update_system_install([package], [&in], [no-force])\n# Install some package with apt\nsub update_system_install\n{\nlocal $update = $_[0] || $in{'update'};\nlocal $force = !$_[2];\nlocal (@rv, @newpacks);\n\n# Build the command to run\n$ENV{'DEBIAN_FRONTEND'} = 'noninteractive';\nlocal $uicmd = \"$apt_get_command -y \".($force ? \" -f\" : \"\").\" install $update\";\n$update = join(\" \", map { quotemeta($_) } split(/\\s+/, $update));\nlocal $cmd = \"$apt_get_command -y \".($force ? \" -f\" : \"\").\" install $update\";\nprint \"<b>\",&text('apt_install', \"<tt>\".&html_escape($uicmd).\"</tt>\"),\"</b><p>\\n\";\nprint \"<pre>\";\n&additional_log('exec', undef, $cmd);\n\n# Run dpkg --configure -a to clear any un-configured packages\n$SIG{'TERM'} = 'ignore';\t# This may cause a Webmin re-config!\nlocal $out = &backquote_logged(\"dpkg --configure -a 2>&1 </dev/null\");\nprint &html_escape($out);\n\n# Create an input file of 'yes'\nlocal $yesfile = &transname();\n&open_tempfile(YESFILE, \">$yesfile\", 0, 1);\nforeach (0..100) {\n\t&print_tempfile(YESFILE, \"Yes\\n\");\n\t}\n&close_tempfile(YESFILE);\n\n# Run the command\n&clean_language();\n&open_execute_command(CMD, \"$cmd <\".quotemeta($yesfile), 2);\nwhile(<CMD>) {\n\tif (/setting\\s+up\\s+(\\S+)/i && !/as\\s+MDA/i) {\n\t\tpush(@rv, $1);\n\t\t}\n\telsif (/packages\\s+will\\s+be\\s+upgraded/i ||\n\t       /new\\s+packages\\s+will\\s+be\\s+installed/i) {\n\t\tprint;\n\t\t$line = $_ = <CMD>;\n\t\t$line =~ s/^\\s+//; $line =~ s/\\s+$//;\n\t\tpush(@newpacks, split(/\\s+/, $line));\n\t\t}\n\tprint &html_escape(\"$_\");\n\t}\nclose(CMD);\n&reset_environment();\nif (!@rv && $config{'package_system'} ne 'debian' && !$?) {\n\t# Other systems don't list the packages installed!\n\t@rv = @newpacks;\n\t}\nprint \"</pre>\\n\";\nif ($?) { print \"<b>$text{'apt_failed'}</b><p>\\n\"; }\nelse { print \"<b>$text{'apt_ok'}</b><p>\\n\"; }\nreturn @rv;\n}\n\n# update_system_operations(packages)\n# Given a list of packages, returns a list containing packages that will\n# actually get installed, each of which is a hash ref with name and version.\nsub update_system_operations\n{\nmy ($packages) = @_;\n$ENV{'DEBIAN_FRONTEND'} = 'noninteractive';\nmy $cmd = \"apt-get -s install \".\n\t  join(\" \", map { quotemeta($_) } split(/\\s+/, $packages)).\n\t  \" </dev/null 2>&1\";\n&clean_language();\nmy $out = &backquote_command($cmd);\n&reset_environment();\nmy @rv;\nforeach my $l (split(/\\r?\\n/, $out)) {\n\tif ($l =~ /Inst\\s+(\\S+)\\s+\\[(\\S+)\\]\\s+\\(([^ \\)]+)/ ||\n\t    $l =~ /Inst\\s+(\\S+)\\s+\\[(\\S+)\\]/) {\n\t\t# Format like : Inst telnet [amd64] (5.6.7 Ubuntu)\n\t\tmy $pkg = { 'name' => $1,\n\t\t\t    'version' => $3 || $2 };\n\t\tif ($pkg->{'version'} =~ s/^(\\S+)://) {\n\t\t\t$pkg->{'epoch'} = $1;\n\t\t\t}\n\t\tpush(@rv, $pkg);\n\t\t}\n\telsif ($l =~ /Inst\\s+(\\S+)\\s+\\(([^ \\)]+)/) {\n\t\t# Format like : Inst telnet (5.6.7 Ubuntu [amd64])\n\t\tmy $pkg = { 'name' => $1,\n\t\t\t    'version' => $2 };\n\t\tif ($pkg->{'version'} =~ s/^(\\S+)://) {\n\t\t\t$pkg->{'epoch'} = $1;\n\t\t\t}\n\t\tpush(@rv, $pkg);\n\t\t}\n\t}\nreturn @rv;\n}\n\n# update_system_form()\n# Shows a form for updating all packages on the system\nsub update_system_form\n{\nprint &ui_subheading($text{'apt_form'});\nprint &ui_form_start(\"apt_upgrade.cgi\");\nprint &ui_table_start($text{'apt_header'}, undef, 2);\n\nprint &ui_table_row($text{'apt_update'},\n\t&ui_yesno_radio(\"update\", 1));\n\nprint &ui_table_row($text{'apt_mode'},\n\t&ui_radio(\"mode\", 0, [ [ 2, $text{'apt_mode2'} ],\n\t\t\t       [ 1, $text{'apt_mode1'} ],\n\t\t\t       [ 0, $text{'apt_mode0'} ] ]));\n\nprint &ui_table_row($text{'apt_sim'},\n\t&ui_yesno_radio(\"sim\", 0));\n\nprint &ui_table_end();\nprint &ui_form_end([ [ undef, $text{'apt_apply'} ] ]);\n}\n\n# update_system_resolve(name)\n# Converts a standard package name like apache, sendmail or squid into\n# the name used by APT.\nsub update_system_resolve\n{\nlocal ($name) = @_;\nreturn $name eq \"dhcpd\" && $gconfig{'os_version'} >= 7 ?\n\t\t\"isc-dhcp-server\" :\n       $name eq \"dhcpd\" && $gconfig{'os_version'} < 7 ?\n\t\t\"dhcp3-server\" :\n       $name eq \"bind\" ? \"bind9\" :\n       $name eq \"mysql\" && $gconfig{'os_version'} >= 10 ?\n\t\t\"mariadb-client mariadb-server\" :\n       $name eq \"mysql\" && $gconfig{'os_version'} >= 7 ?\n\t\t\"mysql-client mysql-server\" :\n       $name eq \"mysql\" && $gconfig{'os_version'} < 7 ?\n\t\t\"mysql-client mysql-server mysql-admin\" :\n       $name eq \"apache\" ? \"apache2\" :\n       $name eq \"squid\" && $gconfig{'os_version'} >= 8 ?\n\t\t\"squid3\" :\n       $name eq \"postgresql\" ? \"postgresql postgresql-client\" :\n       $name eq \"openssh\" ? \"ssh\" :\n       $name eq \"openldap\" ? \"slapd\" :\n       $name eq \"ldap\" ? \"libnss-ldap libpam-ldap\" :\n       $name eq \"dovecot\" ? \"dovecot-common dovecot-imapd dovecot-pop3d\" :\n       $name eq \"virtualmin-modules\" ? \"webmin-.*\" :\n\t\t\t       $name;\n}\n\n# update_system_available()\n# Returns a list of package names and versions that are available from APT\nsub update_system_available\n{\nlocal (@rv, $pkg, %done);\n\n# Use dump to get versions\n&execute_command(\"$apt_get_command update\");\n&clean_language();\n&open_execute_command(DUMP, \"apt-cache dumpavail 2>/dev/null\", 1, 1);\nwhile(<DUMP>) {\n\tif (/^\\s*Package:\\s*(\\S+)/) {\n\t\t$pkg = { 'name' => $1 };\n\t\tpush(@rv, $pkg);\n\t\t$done{$1} = $pkg;\n\t\t}\n\telsif (/^\\s*Version:\\s*(\\S+)/ && $pkg && !$pkg->{'version'}) {\n\t\t$pkg->{'version'} = $1;\n\t\tif ($pkg->{'version'} =~ /^(\\d+):(.*)$/) {\n\t\t\t$pkg->{'epoch'} = $1;\n\t\t\t$pkg->{'version'} = $2;\n\t\t\t}\n\t\t}\n\telsif (/^\\s*File:\\s*(\\S+)/ && $pkg) {\n\t\t$pkg->{'file'} ||= $1;\n\t\t}\n\t}\nclose(DUMP);\n&reset_environment();\n\n# Use search to get descriptions\nforeach my $s (&update_system_search('.*')) {\n\tmy $pkg = $done{$s->{'name'}};\n\tif ($pkg) {\n\t\t$pkg->{'desc'} = $s->{'desc'};\n\t\t}\n\t}\n\n&set_pinned_versions(\\@rv);\nreturn @rv;\n}\n\n# update_system_search(text)\n# Returns a list of packages matching some search\nsub update_system_search\n{\nlocal (@rv, $pkg);\n&clean_language();\n&open_execute_command(DUMP, \"$apt_search_command search \".\n\t\t\t    quotemeta($_[0]).\" 2>/dev/null\", 1, 1);\nwhile(<DUMP>) {\n\tif (/^(\\S+)\\s*-\\s*(.*)/) {\n\t\tpush(@rv, { 'name' => $1, 'desc' => $2 });\n\t\t}\n\telsif (/^(\\S)\\s+(\\S+)\\s+-\\s*(.*)/) {\n\t\tpush(@rv, { 'name' => $2, 'desc' => $3 });\n\t\t}\n\t}\nclose(DUMP);\n&reset_environment();\nreturn @rv;\n}\n\n# update_system_updates()\n# Returns a list of available package updates\nsub update_system_updates\n{\n&execute_command(\"$apt_get_command update\");\n\n# Find held packages by dpkg\nlocal %holds;\nif ($config{'package_system'} eq 'debian') {\n\t&clean_language();\n\t&open_execute_command(HOLDS, \"dpkg --get-selections\", 1, 1);\n\twhile(<HOLDS>) {\n\t\tif (/^(\\S+)\\s+hold/) {\n\t\t\t$holds{$1}++;\n\t\t\t}\n\t\t}\n\tclose(HOLDS);\n\t&reset_environment();\n\t}\n\nif (&has_command(\"apt-show-versions\")) {\n\t# This awesome command can give us all updates in one hit, and takes\n\t# pinned versions and backports into account\n\tlocal @rv;\n\t&clean_language();\n\t&execute_command(\"apt-show-versions -i\");\n\t&open_execute_command(PKGS, \"apt-show-versions 2>/dev/null\", 1, 1);\n\twhile(<PKGS>) {\n\t\tif (/^(\\S+)\\/(\\S+)\\s+upgradeable\\s+from\\s+(\\S+)\\s+to\\s+(\\S+)/ &&\n\t\t    !$holds{$1}) {\n\t\t\t# Old format\n\t\t\tlocal $pkg = { 'name' => $1,\n\t\t\t\t       'source' => $2,\n\t\t\t\t       'version' => $4 };\n\t\t\tif ($pkg->{'version'} =~ s/^(\\S+)://) {\n\t\t\t\t$pkg->{'epoch'} = $1;\n\t\t\t\t}\n\t\t\tpush(@rv, $pkg);\n\t\t\t}\n\t\telsif (/^(\\S+):(\\S+)\\/(\\S+)\\s+(\\S+)\\s+upgradeable\\s+to\\s+(\\S+)/ && !$holds{$1}) {\n\t\t\t# New format, like \n\t\t\t# libgomp1:i386/unstable 4.8.2-2 upgradeable to 4.8.2-4\n\t\t\tlocal $pkg = { 'name' => $1,\n\t\t\t\t       'arch' => $2,\n\t\t\t\t       'source' => $3,\n\t\t\t\t       'version' => $5 };\n\t\t\tif ($pkg->{'version'} =~ s/^(\\S+)://) {\n\t\t\t\t$pkg->{'epoch'} = $1;\n\t\t\t\t}\n\t\t\tpush(@rv, $pkg);\n\t\t\t}\n\t\t}\n\tclose(PKGS);\n\t&reset_environment();\n\t@rv = &filter_held_packages(@rv);\n\tforeach my $pkg (@rv) {\n\t\t$pkg->{'security'} = 1 if ($pkg->{'source'} =~ /security/i);\n\t\t}\n\treturn @rv;\n\t}\nelsif (&has_command(\"apt\")) {\n\t# Use the apt list command\n\tlocal @rv;\n\t&clean_language();\n\t&open_execute_command(PKGS, \"apt list --upgradable 2>/dev/null\", 1, 1);\n\twhile(<PKGS>) {\n\t\tif (/^(\\S+)\\/(\\S+)\\s+(\\S+)\\s+(\\S+)\\s+\\[upgradable\\s+from:\\s+(\\S+)\\]/ && !$holds{$1}) {\n\t\t\tlocal $pkg = { 'name' => $1,\n\t\t\t\t       'source' => $2,\n\t\t\t\t       'version' => $3,\n\t\t\t\t       'arch' => $4 };\n\t\t\tif ($pkg->{'version'} =~ s/^(\\S+)://) {\n\t\t\t\t$pkg->{'epoch'} = $1;\n\t\t\t\t}\n\t\t\t$pkg->{'source'} =~ s/,.*$//;\n\t\t\tpush(@rv, $pkg);\n\t\t\t}\n\t\t}\n\tclose(PKGS);\n\t&reset_environment();\n\t@rv = &filter_held_packages(@rv);\n\tforeach my $pkg (@rv) {\n\t\t$pkg->{'security'} = 1 if ($pkg->{'source'} =~ /security/i);\n\t\t}\n\treturn @rv;\n\t}\nelse {\n\t# Need to manually compose by calling dpkg and apt-cache showpkg\n\tlocal %packages;\n\tlocal $n = &list_packages();\n\tlocal %currentmap;\n\tfor(my $i=0; $i<$n; $i++) {\n\t\tlocal $pkg = { 'name' => $packages{$i,'name'},\n\t\t\t       'oldversion' => $packages{$i,'version'},\n\t\t\t       'desc' => $packages{$i,'desc'},\n\t\t\t       'oldepoch' => $packages{$i,'epoch'} };\n\t\t$currentmap{$pkg->{'name'}} ||= $pkg;\n\t\t}\n\tlocal @rv;\n\tlocal @names = grep { !$holds{$_} } keys %currentmap;\n\twhile(scalar(@names)) {\n\t\tlocal @somenames;\n\t\tif (scalar(@names) > 100) {\n\t\t\t# Do 100 at a time\n\t\t\t@somenames = @names[0..99];\n\t\t\t@names = @names[100..$#names];\n\t\t\t}\n\t\telse {\n\t\t\t# Do the rest\n\t\t\t@somenames = @names;\n\t\t\t@names = ( );\n\t\t\t}\n\t\t&clean_language();\n\t\t&open_execute_command(PKGS, \"apt-cache showpkg \".\n\t\t\tjoin(\" \", @somenames).\" 2>/dev/null\", 1, 1);\n\t\tlocal $pkg = undef;\n\t\twhile(<PKGS>) {\n\t\t\ts/\\r|\\n//g;\n\t\t\tif (/^\\s*Package:\\s*(\\S+)/) {\n\t\t\t\t$pkg = $currentmap{$1};\n\t\t\t\t}\n\t\t\telsif (/^Versions:\\s*$/ && $pkg && !$pkg->{'version'}) {\n\t\t\t\t# Newest version is on next line\n\t\t\t\tlocal $ver = <PKGS>;\n\t\t\t\t$ver =~ s/\\s.*\\r?\\n//;\n\t\t\t\tlocal $epoch;\n\t\t\t\tif ($ver =~ s/^(\\d+)://) {\n\t\t\t\t\t$epoch = $1;\n\t\t\t\t\t}\n\t\t\t\t$pkg->{'version'} = $ver;\n\t\t\t\t$pkg->{'epoch'} = $epoch;\n\t\t\t\tlocal $newer =\n\t\t\t\t    $pkg->{'epoch'} <=> $pkg->{'oldepoch'} ||\n\t\t\t\t    &compare_versions($pkg->{'version'},\n\t\t\t\t\t\t      $pkg->{'oldversion'});\n\t\t\t\tif ($newer > 0) {\n\t\t\t\t\tpush(@rv, $pkg);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\tclose(PKGS);\n\t\t&reset_environment();\n\t\t}\n\t@rv = &filter_held_packages(@rv);\n\t&set_pinned_versions(\\@rv);\n\treturn @rv;\n\t}\n}\n\n# set_pinned_versions(&package-list)\n# Updates the version and epoch fields in a list of available packages based\n# on pinning.\nsub set_pinned_versions\n{\nlocal ($pkgs) = @_;\nlocal %pkgmap = map { $_->{'name'}, $_ } @$pkgs;\n&clean_language();\n&open_execute_command(PKGS, \"apt-cache policy 2>/dev/null\", 1, 1);\nwhile(<PKGS>) { \n\ts/\\r|\\n//g;\n\tif (/\\s+(\\S+)\\s+\\-\\>\\s+(\\S+)/) {\n\t\tmy ($name, $pin) = ($1, $2);\n\t\tmy $pkg = $pkgmap{$name};\n\t\tif ($pkg) {\n\t\t\t$pkg->{'version'} = $pin;\n\t\t\t$pkg->{'epoch'} = undef;\n\t\t\tif ($pkg->{'version'} =~ s/^(\\S+)://) {\n\t\t\t\t$pkg->{'epoch'} = $1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\nclose(PKGS);\n&reset_environment();\n}\n\n# filter_held_packages(package, ...)\n# Returns a list of package updates, minus those that are held\nsub filter_held_packages\n{\nmy @pkgs = @_;\nmy %hold;\n\n# Get holds from dpkg\n&clean_language();\n&open_execute_command(PKGS, \"dpkg --get-selections 2>/dev/null\", 1, 1);\nwhile(<PKGS>) { \n\tif (/^(\\S+)\\s+hold/) {\n\t\t$hold{$1} = 1;\n\t\t}\n\t}\nclose(PKGS);\n&reset_environment();\n\n# Get holds from aptitude\nif (&has_command(\"aptitude\")) {\n\t&clean_language();\n\t&open_execute_command(PKGS, \"aptitude search '~ahold' 2>/dev/null\", 1, 1);\n\twhile(<PKGS>) { \n\t\tif (/^\\.h\\s+(\\S+)/) {\n\t\t\t$hold{$1} = 1;\n\t\t\t}\n\t\t}\n\tclose(PKGS);\n\t&reset_environment();\n\t}\n\n# Get holds from apt-mark\nif (&has_command(\"apt-mark\")) {\n\t&clean_language();\n\t&open_execute_command(PKGS, \"apt-mark showhold 2>/dev/null\", 1, 1);\n\twhile(<PKGS>) { \n\t\tif (/^([^:\\s]+)/) {\n\t\t\t$hold{$1} = 1;\n\t\t\t}\n\t\t}\n\tclose(PKGS);\n\t&reset_environment();\n\t}\n\nreturn grep { !$hold{$_->{'name'}} } @pkgs;\n}\n\n# list_package_repos()\n# Returns a list of configured repositories\nsub list_package_repos\n{\nmy @rv;\n\n# Read all repos files\nforeach my $f ($sources_list_file, glob(\"$sources_list_dir/*\")) {\n\tmy $lref = &read_file_lines($f, 1);\n\tmy $lnum = 0;\n\tforeach my $l (@$lref) {\n\t\tif ($l =~ /^(#*)\\s*deb\\s+((http|https)\\S+)\\s+(\\S.*)/) {\n\t\t\tmy $repo = { 'file' => $f,\n\t\t\t\t     'line' => $lnum,\n\t\t\t\t     'words' => \\@w,\n\t\t\t\t     'url' => $2,\n\t\t\t\t     'enabled' => !$1 };\n\t\t\tmy @w = split(/\\s+/, $4);\n\t\t\t$repo->{'name'} = join(\"/\", @w);\n\t\t\t$repo->{'id'} = $repo->{'url'}.$repo->{'name'};\n\t\t\tpush(@rv, $repo);\n\t\t\t}\n\t\t$lnum++;\n\t\t}\n\t}\n\nreturn @rv;\n}\n\n# create_repo_form()\n# Returns HTML for a package repository creation form\nsub create_repo_form \n{\nmy $rv;\n$rv .= &ui_table_row($text{'apt_repo_url'},\n\t\t     &ui_textbox(\"url\", undef, 40));\n$rv .= &ui_table_row($text{'apt_repo_path'},\n\t\t     &ui_textbox(\"path\", undef, 40));\nreturn $rv;\n}\n\n# create_repo_parse(&in)\n# Parses input from create_repo_form, and returns either a new repo object or\n# an error string\nsub create_repo_parse\n{\nmy ($in) = @_;\nmy $repo = { 'enabled' => 1 };\n\n# Parse base URL\n$in->{'url'} =~ /^(http|https|ftp|file):\\S+$/ ||\n\treturn $text{'apt_repo_eurl'};\n$repo->{'url'} = $in->{'url'};\n\n# Parse distro components\nmy @w = split(/\\s+|\\//, $in->{'path'});\n@w || $text{'apt_repo_epath'};\n$repo->{'name'} = join(\"/\", @w);\n$repo->{'id'} = $repo->{'url'}.$repo->{'name'};\n\nreturn $repo;\n}\n\n# create_package_repo(&repo)\n# Creates a new repository from the given hash (returned by create_repo_parse)\nsub create_package_repo\n{\nmy ($repo) = @_;\n&lock_file($sources_list_file);\nmy $lref = &read_file_lines($sources_list_file);\npush(@$lref, ($repo->{'enabled'} ? \"\" : \"# \").\n\t     \"deb \".\n\t     $repo->{'url'}.\" \".\n\t     join(\" \", split(/\\//, $repo->{'name'})));\n&flush_file_lines($sources_list_file);\n&unlock_file($sources_list_file);\nreturn undef;\n}\n\n# delete_package_repo(&repo)\n# Delete a repo from the sources.list file\nsub delete_package_repo\n{\nmy ($repo) = @_;\n&lock_file($repo->{'file'});\nmy $lref = &read_file_lines($repo->{'file'});\nsplice(@$lref, $repo->{'line'}, 1);\n&flush_file_lines($repo->{'file'});\n&unlock_file($repo->{'file'});\n}\n\n# enable_package_repo(&repo, enable?)\n# Enable or disable a repository\nsub enable_package_repo\n{\nmy ($repo, $enable) = @_;\n&lock_file($repo->{'file'});\nmy $lref = &read_file_lines($repo->{'file'});\n$lref->[$repo->{'line'}] =~ s/^#+\\s*//;\nif (!$enable) {\n\t$lref->[$repo->{'line'}] = \"# \".$lref->[$repo->{'line'}];\n\t}\n&flush_file_lines($repo->{'file'});\n&unlock_file($repo->{'file'});\n}\n\n1;\n"], "filenames": ["software/apt-lib.pl"], "buggy_code_start_loc": [23], "buggy_code_end_loc": [28], "fixing_code_start_loc": [24], "fixing_code_end_loc": [28], "type": "CWE-116", "message": "software/apt-lib.pl in Webmin before 1.997 lacks HTML escaping for a UI command.", "other": {"cve": {"id": "CVE-2022-36446", "sourceIdentifier": "cve@mitre.org", "published": "2022-07-25T06:15:07.900", "lastModified": "2022-10-06T18:37:50.020", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "software/apt-lib.pl in Webmin before 1.997 lacks HTML escaping for a UI command."}, {"lang": "es", "value": "El archivo software/apt-lib.pl en Webmin versiones anteriores a 1.997, carece de escape HTML para un comando de la Interfaz de Usuario"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-116"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:webmin:webmin:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.997", "matchCriteriaId": "AD730C30-2C81-45E2-9270-4E2EEB6635B1"}]}]}], "references": [{"url": "http://packetstormsecurity.com/files/167894/Webmin-1.996-Remote-Code-Execution.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "http://packetstormsecurity.com/files/168049/Webmin-Package-Updates-Command-Injection.html", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory", "VDB Entry"]}, {"url": "https://gist.github.com/emirpolatt/cf19d6c0128fa3e25ebb47e09243919b", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://github.com/webmin/webmin/commit/13f7bf9621a82d93f1e9dbd838d1e22020221bde", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/webmin/webmin/compare/1.996...1.997", "source": "cve@mitre.org", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://www.exploit-db.com/exploits/50998", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}]}, "github_commit_url": "https://github.com/webmin/webmin/commit/13f7bf9621a82d93f1e9dbd838d1e22020221bde"}}