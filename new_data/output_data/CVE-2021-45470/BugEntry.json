{"buggy_code": ["#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n#\n# Database layer translates database calls to functions\n#\n# Software is free software released under the \"GNU Affero General Public License v3.0\"\n#\n# Copyright (c) 2015-2018  Pieter-Jan Moreels - pieterjan.moreels@gmail.com\n\n# imports\nimport ast\nimport re\nimport sys\n\nimport pymongo\n\nfrom lib.Config import Configuration as conf\n\n# Variables\ndb = conf.getMongoConnection()\ncolCVE = db[\"cves\"]\ncolCPE = db[\"cpe\"]\ncolCWE = db[\"cwe\"]\ncolCPEOTHER = db[\"cpeother\"]\ncolWHITELIST = db[\"mgmt_whitelist\"]\ncolBLACKLIST = db[\"mgmt_blacklist\"]\ncolUSERS = db[\"mgmt_users\"]\ncolINFO = db[\"info\"]\ncolRANKING = db[\"ranking\"]\ncolVIA4 = db[\"via4\"]\ncolCAPEC = db[\"capec\"]\ncolPlugSettings = db[\"plugin_settings\"]\ncolPlugUserSettings = db[\"plugin_user_settings\"]\n\nmongo_version = db.command(\"buildinfo\")[\"versionArray\"]\n# to check if mongodb > 4.4\n# if it is, then use allow_disk_use for optimized queries\n# to be removed in future with the conditional statements\n# and use allow_disk_use by default\n\n# Functions\ndef sanitize(x):\n    if type(x) == pymongo.cursor.Cursor:\n        x = list(x)\n    if type(x) == list:\n        for y in x:\n            sanitize(y)\n    if x and \"_id\" in x:\n        x.pop(\"_id\")\n    return x\n\n\n# DB Functions\ndef ensureIndex(collection, field, **kwargs):\n    db[collection].create_index(field, **kwargs)\n\n\ndef drop(collection):\n    db[collection].drop()\n\n\ndef setColUpdate(collection, date):\n    colINFO.update({\"db\": collection}, {\"$set\": {\"last-modified\": date}}, upsert=True)\n\n\ndef setColInfo(collection, field, data):\n    colINFO.update({\"db\": collection}, {\"$set\": {field: data}}, upsert=True)\n\n\ndef insertCVE(cve):\n    colCVE.insert(cve)\n\n\ndef updateCVE(cve):\n    if cve[\"cvss3\"] is not None:\n        colCVE.update(\n            {\"id\": cve[\"id\"]},\n            {\n                \"$set\": {\n                    \"cvss3\": cve[\"cvss3\"],\n                    \"impact3\": cve[\"impact3\"],\n                    \"exploitability3\": cve[\"exploitability3\"],\n                    \"cvss3-vector\": cve[\"cvss3-vector\"],\n                    \"impactScore3\": cve[\"impactScore3\"],\n                    \"exploitabilityScore3\": cve[\"exploitabilityScore3\"],\n                    \"cvss\": cve[\"cvss\"],\n                    \"summary\": cve[\"summary\"],\n                    \"references\": cve[\"references\"],\n                    \"impact\": cve[\"impact\"],\n                    \"vulnerable_product\": cve[\"vulnerable_product\"],\n                    \"access\": cve[\"access\"],\n                    \"cwe\": cve[\"cwe\"],\n                    \"vulnerable_configuration\": cve[\"vulnerable_configuration\"],\n                    \"vulnerable_configuration_cpe_2_2\": cve[\n                        \"vulnerable_configuration_cpe_2_2\"\n                    ],\n                    \"last-modified\": cve[\"Modified\"],\n                }\n            },\n            upsert=True,\n        )\n    else:\n        colCVE.update(\n            {\"id\": cve[\"id\"]},\n            {\n                \"$set\": {\n                    \"cvss3\": cve[\"cvss3\"],\n                    \"cvss\": cve[\"cvss\"],\n                    \"summary\": cve[\"summary\"],\n                    \"references\": cve[\"references\"],\n                    \"impact\": cve[\"impact\"],\n                    \"vulnerable_product\": cve[\"vulnerable_product\"],\n                    \"access\": cve[\"access\"],\n                    \"cwe\": cve[\"cwe\"],\n                    \"vulnerable_configuration\": cve[\"vulnerable_configuration\"],\n                    \"vulnerable_configuration_cpe_2_2\": cve[\n                        \"vulnerable_configuration_cpe_2_2\"\n                    ],\n                    \"last-modified\": cve[\"Modified\"],\n                }\n            },\n            upsert=True,\n        )\n\n\ndef cpeotherBulkInsert(cpeotherlist):\n    colCPEOTHER.insert(cpeotherlist)\n\n\ndef dropCollection(col):\n    return db[col].drop()\n    # jdt_NOTE: is exactly the same as drop(collection)\n    # jdt_NOTE: use only one of them\n\n\ndef getTableNames():\n    # return db.collection_names()\n    # jdt_NOTE: collection_names() is depreated, list_collection_names() should be used instead\n    return db.list_collection_names()\n\n\n# returns True if 'target_version' is less or equal than\n# 'cpe_version'\n# returns False otherwise\ndef target_version_is_included(target_version, cpe_version):\n    sp_target = target_version.split(\".\")\n    sp_cpe = cpe_version.split(\".\")\n    if len(sp_target) > len(sp_cpe):\n        sp_cpe += [0] * (len(sp_target) - len(sp_cpe))\n    if len(sp_cpe) > len(sp_target):\n        sp_cpe += [0] * (len(sp_cpe) - len(sp_target))\n    for i in range(len(sp_target)):\n        # target version smaller than cpe version\n        if int(sp_target[i]) < int(sp_cpe[i]):\n            return True\n        # target version greater than cpe version\n        if int(sp_target[i]) > int(sp_cpe[i]):\n            return False\n    # target version same version as cpe version\n    return True\n\n\n# API Functions\ndef cvesForCPE(cpe, lax=False, vulnProdSearch=False, limit=0, strict_vendor_product=False):\n    if not cpe:\n        return []\n\n    cpe_regex = cpe\n    final_cves = []\n    cpe_searchField = (\n        \"vulnerable_product\" if vulnProdSearch else \"vulnerable_configuration\"\n    )\n\n    if lax:\n        # get target version from product description provided by the user\n        target_version = cpe.split(\":\")[-1]\n        product = cpe.rsplit(\":\", 1)[0]\n        # perform checks on the target version\n        if None is target_version or [] is target_version:\n            print(\n                \"Error, target version not found at the end of product description '{}'\".format(\n                    cpe\n                )\n            )\n            sys.exit(-1)\n        for i in target_version.split(\".\"):\n            try:\n                int(i)\n            except:\n                print(\n                    \"Error, target version should be of the form '1.2.3'. Current form is '{}'\".format(\n                        target_version\n                    )\n                )\n                sys.exit(-1)\n\n        # over-approximate versions\n        cpe_regex = product\n\n        if limit != 0:\n            if mongo_version > [4, 4]:\n                cves = (\n                    colCVE.find({cpe_searchField: {\"$regex\": cpe_regex}})\n                    .limit(limit)\n                    .sort(\n                        [(\"Modified\", pymongo.DESCENDING), (\"cvss\", pymongo.DESCENDING)]\n                    )\n                    .allow_disk_use(True)\n                )\n            else:\n                cves = (\n                    colCVE.find({cpe_searchField: {\"$regex\": cpe_regex}})\n                    .limit(limit)\n                    .sort(\n                        [(\"Modified\", pymongo.DESCENDING), (\"cvss\", pymongo.DESCENDING)]\n                    )\n                )\n        else:\n            if mongo_version > [4, 4]:\n                cves = (\n                    colCVE.find({cpe_searchField: {\"$regex\": cpe_regex}})\n                    .sort(\"Modified\", direction=pymongo.DESCENDING)\n                    .allow_disk_use(True)\n                )\n            else:\n                cves = colCVE.find({cpe_searchField: {\"$regex\": cpe_regex}}).sort(\n                    \"Modified\", direction=pymongo.DESCENDING\n                )\n\n        i = 0\n\n        for cve in cves:\n            vuln_confs = cve[\"vulnerable_configuration\"]\n            vuln_confs += cve[\"vulnerable_configuration_cpe_2_2\"]\n            vuln_confs += cve[\"vulnerable_product\"]\n            i += 1\n            for vc in vuln_confs:\n                if cpe_regex not in vc:\n                    continue\n\n                re_from_start = re.compile(\"^.*{}:\".format(cpe_regex))\n                cpe_version = re_from_start.sub(\"\", vc)\n\n                # TODO: handle versions such as \"1.1.3:p2\"\n                cpe_version = cpe_version.split(\":\")[0]\n\n                # TODO: handle versions such as \"1.1.3p2\"\n                cpe_version = re.search(r\"([0-9\\.]*)\", cpe_version).group(0)\n                if len(cpe_version) == 0:\n                    # TODO: print warnings\n                    # print (\"Warning, missing cpe version for {}: '{}'. Skipping cpe.\".format(cve[\"id\"], vc))\n                    continue\n                if target_version_is_included(target_version, cpe_version):\n                    final_cves.append(cve)\n                    break\n    elif strict_vendor_product:\n        # strict product search\n\n        vendor, product = cpe\n\n        cpe_regex_string = r\"^{}\".format(re.escape(product))\n\n        if limit != 0:\n            if mongo_version > [4, 4]:\n                cves = (\n                    colCVE.find({\"vendors\": vendor, \"products\": {\"$regex\": cpe_regex_string}})\n                    .limit(limit)\n                    .sort(\"cvss\", direction=pymongo.DESCENDING)\n                    .allow_disk_use(True)\n                )\n            else:\n                cves = (\n                    colCVE.find({\"vendors\": vendor, \"products\": {\"$regex\": cpe_regex_string}})\n                    .limit(limit)\n                    .sort(\"cvss\", direction=pymongo.DESCENDING)\n                )\n        else:\n            cves = colCVE.find({\"vendors\": vendor, \"products\": {\"$regex\": cpe_regex_string}})\n\n        final_cves = cves\n\n    else:\n        # create strict cpe regex\n\n        if cpe_regex.startswith(\"cpe\"):\n            # strict search with term starting with cpe; e.g: cpe:2.3:o:microsoft:windows_7:*:sp1:*:*:*:*:*:*\n\n            remove_trailing_regex_stars = r\"(?:\\:|\\:\\:|\\:\\*)+$\"\n\n            cpe_regex = re.escape(re.sub(remove_trailing_regex_stars, \"\", cpe_regex))\n\n            cpe_regex_string = r\"^{}:\".format(cpe_regex)\n        else:\n            # more general search on same field; e.g. microsoft:windows_7\n            cpe_regex_string = \"{}\".format(re.escape(cpe_regex))\n\n        # default strict search\n        if limit != 0:\n            if mongo_version > [4, 4]:\n                cves = (\n                    colCVE.find({\"{}\".format(cpe_searchField): {\"$regex\": cpe_regex_string}})\n                    .limit(limit)\n                    .sort(\"cvss\", direction=pymongo.DESCENDING)\n                    .allow_disk_use(True)\n                )\n            else:\n                cves = (\n                    colCVE.find({\"{}\".format(cpe_searchField): {\"$regex\": cpe_regex_string}})\n                    .limit(limit)\n                    .sort(\"cvss\", direction=pymongo.DESCENDING)\n                )\n        else:\n            cves = colCVE.find({\"{}\".format(cpe_searchField): {\"$regex\": cpe_regex_string}})\n\n        final_cves = cves\n\n    final_cves = sanitize(final_cves)\n    return {\"results\": final_cves, \"total\": len(final_cves)}\n\n\n# Query Functions\n# Generic data\ndef getCVEs(limit=False, query=[], skip=0, cves=None, collection=None):\n    col = colCVE if not collection else db[collection]\n    if type(query) == dict:\n        query = [query]\n    if type(cves) == list:\n        query.append({\"id\": {\"$in\": cves}})\n    if len(query) == 0:\n        if mongo_version > [4, 4]:\n            cve = (\n                col.find()\n                .sort(\"Modified\", pymongo.DESCENDING)\n                .limit(limit)\n                .skip(skip)\n                .allow_disk_use(True)\n            )\n        else:\n            cve = (\n                col.find().sort(\"Modified\", pymongo.DESCENDING).limit(limit).skip(skip)\n            )\n    elif len(query) == 1:\n        if mongo_version > [4, 4]:\n            cve = (\n                col.find(query[0])\n                .sort(\"Modified\", pymongo.DESCENDING)\n                .limit(limit)\n                .skip(skip)\n                .allow_disk_use(True)\n            )\n        else:\n            cve = (\n                col.find(query[0])\n                .sort(\"Modified\", pymongo.DESCENDING)\n                .limit(limit)\n                .skip(skip)\n            )\n    else:\n        if mongo_version > [4, 4]:\n            cve = (\n                col.find({\"$and\": query})\n                .sort(\"Modified\", pymongo.DESCENDING)\n                .limit(limit)\n                .skip(skip)\n                .allow_disk_use(True)\n            )\n        else:\n            cve = (\n                col.find({\"$and\": query})\n                .sort(\"Modified\", pymongo.DESCENDING)\n                .limit(limit)\n                .skip(skip)\n            )\n\n    return {\"results\": sanitize(cve), \"total\": cve.count()}\n\n\ndef getCVEsNewerThan(dt):\n    return getCVEs(query={\"last-modified\": {\"$gt\": dt}})\n\n\ndef getCVEIDs(limit=-1):\n    if mongo_version > [4, 4]:\n        return [\n            x[\"id\"]\n            for x in colCVE.find()\n            .limit(limit)\n            .sort(\"Modified\", pymongo.DESCENDING)\n            .allow_disk_use(True)\n        ]\n    else:\n        return [\n            x[\"id\"]\n            for x in colCVE.find().limit(limit).sort(\"Modified\", pymongo.DESCENDING)\n        ]\n\n\ndef getCVE(id, collection=None):\n    col = colCVE if not collection else db[collection]\n    return sanitize(col.find_one({\"id\": id}))\n\n\ndef getCPE(id):\n    return sanitize(colCPE.find_one({\"id\": id}))\n\n\ndef getCPEVersionInformation(query):\n    return sanitize(colCPE.find_one(query))\n\n\ndef getCPEs():\n    return sanitize(colCPE.find())\n\n\ndef getAlternativeCPE(id):\n    return sanitize(colCPEOTHER.find_one({\"id\": id}))\n\n\ndef getAlternativeCPEs():\n    return sanitize(colCPEOTHER.find())\n\n\ndef getVIA4(id):\n    return sanitize(colVIA4.find_one({\"id\": id}))\n\n\ndef getCPEMatching(regex, fullSearch=False):\n    lst = list(colCPE.find({\"title\": {\"$regex\": regex}}))\n    if fullSearch:\n        lst.extend(colCPEOTHER.find({\"title\": {\"$regex\": regex}}))\n    return lst\n\n\ndef getFreeText(text):\n    try:  # Before Mongo 3\n        return [x[\"obj\"] for x in db.command(\"text\", \"cves\", search=text)[\"results\"]]\n    except:  # As of Mongo 3\n        return sanitize(colCVE.find({\"$text\": {\"$search\": text}}))\n\n\ndef getSearchResults(search):\n    result = {\"data\": []}\n    regSearch = re.compile(re.escape(search), re.IGNORECASE)\n    links = {\"n\": \"Link\", \"d\": []}\n    via4 = getInfo(\"via4\")\n    if via4:\n        for vLink in via4.get(\"searchables\", []):\n            links[\"d\"].extend(sanitize(colVIA4.find({vLink: {\"$in\": [regSearch]}})))\n\n    try:\n        textsearch = {\"n\": \"Text search\", \"d\": getFreeText(search)}\n    except:\n        textsearch = {\"n\": \"Text search\", \"d\": []}\n        result[\"errors\"] = [\"textsearch\"]\n\n    for collection in [links, textsearch]:\n        for item in collection[\"d\"]:\n            # Check if already in result data\n            if not any(item[\"id\"] == entry[\"id\"] for entry in result[\"data\"]):\n                entry = getCVE(item[\"id\"])\n                if entry:\n                    entry[\"reason\"] = collection[\"n\"]\n                    result[\"data\"].append(entry)\n    return result\n\n\ndef getCAPECFor(capecid):\n    return sanitize(colCAPEC.find({\"related_weakness\": {\"$in\": [capecid]}}))\n\n\ndef getCAPEC(capecid):\n    return sanitize(colCAPEC.find_one({\"id\": capecid}))\n\n\ndef getCWEs(cweid=None):\n    if cweid is None:\n        return sanitize(sorted(colCWE.find(), key=lambda k: int(k[\"id\"])))\n    else:\n        return sanitize(colCWE.find_one({\"id\": cweid}))\n\n\ndef getInfo(collection):\n    return sanitize(colINFO.find_one({\"db\": collection}))\n\n\ndef getLastModified(collection):\n    info = getInfo(collection)\n    return info[\"last-modified\"] if info else None\n\n\ndef getSize(collection):\n    return db[collection].count()\n\n\ndef via4Linked(key, val):\n    cveList = [x[\"id\"] for x in colVIA4.find({key: val})]\n    return sanitize(getCVEs(query={\"id\": {\"$in\": cveList}}))\n\n\ndef getDBStats(include_admin=False):\n    data = {\"cves\": {}, \"cpe\": {}, \"cpeOther\": {}, \"capec\": {}, \"cwe\": {}, \"via4\": {}}\n    for key in data.keys():\n        data[key] = {\n            \"size\": getSize(key.lower()),\n            \"last_update\": getLastModified(key.lower()),\n        }\n    if include_admin:\n        data[\"whitelist\"] = {\"size\": colWHITELIST.count()}\n        data[\"blacklist\"] = {\"size\": colBLACKLIST.count()}\n        data = {\n            \"stats\": {\n                \"size_on_disk\": db.command(\"dbstats\")[\"storageSize\"],\n                \"db_size\": db.command(\"dbstats\")[\"dataSize\"],\n                \"name\": conf.getMongoDB(),\n            },\n            \"data\": data,\n        }\n    return data\n\n\n# Dynamic data\ndef getWhitelist():\n    return sanitize(colWHITELIST.find())\n\n\ndef isInWhitelist(cpe):\n    return True if colWHITELIST.find({\"id\": cpe}).count() > 0 else False\n\n\ndef addToWhitelist(cpe, type, comments=None):\n    if comments:\n        colWHITELIST.insert({\"id\": cpe, \"type\": type, \"comments\": comments})\n    else:\n        colWHITELIST.insert({\"id\": cpe, \"type\": type})\n\n\ndef removeFromWhitelist(cpe):\n    colWHITELIST.remove({\"id\": cpe})\n\n\ndef updateWhitelist(oldCPE, newCPE, type, comments=None):\n    if comments:\n        colWHITELIST.update(\n            {\"id\": oldCPE}, {\"id\": newCPE, \"type\": type, \"comments\": comments}\n        )\n    else:\n        colWHITELIST.update({\"id\": oldCPE}, {\"id\": newCPE, \"type\": type})\n\n\ndef getBlacklist():\n    return sanitize(colBLACKLIST.find())\n\n\ndef isInBlacklist(cpe):\n    return True if colBLACKLIST.find({\"id\": cpe}).count() > 0 else False\n\n\ndef addToBlacklist(cpe, type, comments=None):\n    if comments:\n        colBLACKLIST.insert({\"id\": cpe, \"type\": type, \"comments\": comments})\n    else:\n        colBLACKLIST.insert({\"id\": cpe, \"type\": type})\n\n\ndef removeFromBlacklist(cpe):\n    colBLACKLIST.remove({\"id\": cpe})\n\n\ndef updateBlacklist(oldCPE, newCPE, type, comments=None):\n    if comments:\n        colBLACKLIST.update(\n            {\"id\": oldCPE}, {\"id\": newCPE, \"type\": type, \"comments\": comments}\n        )\n    else:\n        colBLACKLIST.update({\"id\": oldCPE}, {\"id\": newCPE, \"type\": type})\n\n\ndef getRules(list):\n    if list.lower() == \"whitelist\":\n        col = colWHITELIST\n    elif list.lower() == \"blacklist\":\n        col = colBLACKLIST\n    else:\n        return []\n    rlist = col.find({\"type\": \"cpe\"}).distinct(\"id\")\n    rlist.extend(\n        [\n            \"cpe:2.3:([^:]*:){9}\" + re.escape(x)\n            for x in col.find({\"type\": \"targethardware\"}).distinct(\"id\")\n        ]\n    )\n    rlist.extend(\n        [\n            \"cpe:2.3:([^:]*:){8}\" + re.escape(x)\n            for x in col.find({\"type\": \"targetsoftware\"}).distinct(\"id\")\n        ]\n    )\n    return rlist\n\n\ndef addRanking(cpe, key, rank):\n    item = findRanking(cpe)\n    if item is None:\n        colRANKING.update({\"cpe\": cpe}, {\"$push\": {\"rank\": {key: rank}}}, upsert=True)\n    else:\n        l = []\n        for i in item[\"rank\"]:\n            i[key] = rank\n            l.append(i)\n        colRANKING.update({\"cpe\": cpe}, {\"$set\": {\"rank\": l}})\n    return True\n\n\ndef removeRanking(cpe):\n    return sanitize(colRANKING.remove({\"cpe\": {\"$regex\": cpe, \"$options\": \"i\"}}))\n\n\ndef findRanking(cpe=None, regex=False):\n    if not cpe:\n        # return sanitize(colRANKING.find())\n        return None\n    if regex:\n        # return sanitize(colRANKING.find_one({'cpe': {'$regex': cpe}}))\n        return None\n    else:\n        return None\n        # return sanitize(colRANKING.find_one({'cpe': cpe}))\n\n\n###########\n# Plugins #\n###########\n# Settings\ndef p_writeSetting(plugin, setting, value):\n    colPlugSettings.update({\"plugin\": plugin}, {\"$set\": {setting: value}}, upsert=True)\n\n\ndef p_readSetting(plugin, setting):\n    data = list(\n        colPlugSettings.find({\"plugin\": plugin}, {setting: 1}).distinct(setting)\n    )\n    if len(data) != 0:\n        data = data[0]\n        return data\n    return None\n\n\ndef p_deleteSettings(plugin):\n    colPlugSettings.remove({\"plugin\": plugin})\n\n\ndef p_writeUserSetting(plugin, user, setting, value):\n    colPlugUserSettings.update(\n        {\"plugin\": plugin, \"user\": user}, {\"$set\": {setting: value}}, upsert=True\n    )\n\n\ndef p_readUserSetting(plugin, user, setting):\n    data = list(\n        colPlugUserSettings.find(\n            {\"plugin\": plugin, \"user\": user}, {setting: 1}\n        ).distinct(setting)\n    )\n    if len(data) != 0:\n        data = data[0]\n        return data\n    return None\n\n\ndef p_deleteUserSettings(plugin):\n    colPlugUserSettings.remove({\"plugin\": plugin})\n\n\n# Query\ndef p_queryData(collection, query):\n    return sanitize(db[\"plug_%s\" % collection].find(query))\n\n\ndef p_queryOne(collection, query):\n    data = sanitize(db[\"plug_%s\" % collection].find_one(query))\n    return data if data else []  # Compatibility between several Flask-PyMongo versions\n\n\n# Data manipulation\ndef p_drop(col):\n    db[\"plug_%s\" % col].drop()\n\n\ndef p_addEntry(collection, data):\n    db[\"plug_%s\" % collection].insert(data)\n\n\ndef p_removeEntry(collection, query):\n    db[\"plug_%s\" % collection].remove(query)\n\n\ndef p_bulkUpdate(collection, keyword, data):\n    if type(data) is not list:\n        data = [data]\n    if len(data) > 0:\n        bulk = db[\"plug_%s\" % collection].initialize_ordered_bulk_op()\n        for x in data:\n            bulk.find({keyword: x[keyword]}).upsert().update({\"$set\": x})\n        bulk.execute()\n\n\ndef p_addToList(collection, query, listname, data):\n    if type(data) != list:\n        data = [data]\n    current = list(p_queryData(collection, query))\n    if len(current) == 0:\n        p_addEntry(collection, query)\n    for entry in current:\n        if listname in entry:\n            data = list(\n                set([repr(x) for x in data]) - set([repr(x) for x in entry[listname]])\n            )\n            data = [ast.literal_eval(x) for x in data]\n        if data:\n            db[\"plug_%s\" % collection].update(\n                query, {\"$addToSet\": {listname: {\"$each\": data}}}\n            )\n\n\ndef p_removeFromList(collection, query, listname, data):\n    if type(data) == dict:\n        db[\"plug_%s\" % collection].update(query, {\"$pull\": {listname: data}})\n    elif type(data) != list:\n        data = [data]\n    db[\"plug_%s\" % collection].update(query, {\"$pullAll\": {listname: data}})\n"], "fixing_code": ["#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n#\n# Database layer translates database calls to functions\n#\n# Software is free software released under the \"GNU Affero General Public License v3.0\"\n#\n# Copyright (c) 2015-2018  Pieter-Jan Moreels - pieterjan.moreels@gmail.com\n\n# imports\nimport ast\nimport re\nimport sys\n\nimport pymongo\n\nfrom lib.Config import Configuration as conf\n\n# Variables\ndb = conf.getMongoConnection()\ncolCVE = db[\"cves\"]\ncolCPE = db[\"cpe\"]\ncolCWE = db[\"cwe\"]\ncolCPEOTHER = db[\"cpeother\"]\ncolWHITELIST = db[\"mgmt_whitelist\"]\ncolBLACKLIST = db[\"mgmt_blacklist\"]\ncolUSERS = db[\"mgmt_users\"]\ncolINFO = db[\"info\"]\ncolRANKING = db[\"ranking\"]\ncolVIA4 = db[\"via4\"]\ncolCAPEC = db[\"capec\"]\ncolPlugSettings = db[\"plugin_settings\"]\ncolPlugUserSettings = db[\"plugin_user_settings\"]\n\nmongo_version = db.command(\"buildinfo\")[\"versionArray\"]\n# to check if mongodb > 4.4\n# if it is, then use allow_disk_use for optimized queries\n# to be removed in future with the conditional statements\n# and use allow_disk_use by default\n\n# Functions\ndef sanitize(x):\n    if type(x) == pymongo.cursor.Cursor:\n        x = list(x)\n    if type(x) == list:\n        for y in x:\n            sanitize(y)\n    if x and \"_id\" in x:\n        x.pop(\"_id\")\n    return x\n\n\n# DB Functions\ndef ensureIndex(collection, field, **kwargs):\n    db[collection].create_index(field, **kwargs)\n\n\ndef drop(collection):\n    db[collection].drop()\n\n\ndef setColUpdate(collection, date):\n    colINFO.update({\"db\": collection}, {\"$set\": {\"last-modified\": date}}, upsert=True)\n\n\ndef setColInfo(collection, field, data):\n    colINFO.update({\"db\": collection}, {\"$set\": {field: data}}, upsert=True)\n\n\ndef insertCVE(cve):\n    colCVE.insert(cve)\n\n\ndef updateCVE(cve):\n    if cve[\"cvss3\"] is not None:\n        colCVE.update(\n            {\"id\": cve[\"id\"]},\n            {\n                \"$set\": {\n                    \"cvss3\": cve[\"cvss3\"],\n                    \"impact3\": cve[\"impact3\"],\n                    \"exploitability3\": cve[\"exploitability3\"],\n                    \"cvss3-vector\": cve[\"cvss3-vector\"],\n                    \"impactScore3\": cve[\"impactScore3\"],\n                    \"exploitabilityScore3\": cve[\"exploitabilityScore3\"],\n                    \"cvss\": cve[\"cvss\"],\n                    \"summary\": cve[\"summary\"],\n                    \"references\": cve[\"references\"],\n                    \"impact\": cve[\"impact\"],\n                    \"vulnerable_product\": cve[\"vulnerable_product\"],\n                    \"access\": cve[\"access\"],\n                    \"cwe\": cve[\"cwe\"],\n                    \"vulnerable_configuration\": cve[\"vulnerable_configuration\"],\n                    \"vulnerable_configuration_cpe_2_2\": cve[\n                        \"vulnerable_configuration_cpe_2_2\"\n                    ],\n                    \"last-modified\": cve[\"Modified\"],\n                }\n            },\n            upsert=True,\n        )\n    else:\n        colCVE.update(\n            {\"id\": cve[\"id\"]},\n            {\n                \"$set\": {\n                    \"cvss3\": cve[\"cvss3\"],\n                    \"cvss\": cve[\"cvss\"],\n                    \"summary\": cve[\"summary\"],\n                    \"references\": cve[\"references\"],\n                    \"impact\": cve[\"impact\"],\n                    \"vulnerable_product\": cve[\"vulnerable_product\"],\n                    \"access\": cve[\"access\"],\n                    \"cwe\": cve[\"cwe\"],\n                    \"vulnerable_configuration\": cve[\"vulnerable_configuration\"],\n                    \"vulnerable_configuration_cpe_2_2\": cve[\n                        \"vulnerable_configuration_cpe_2_2\"\n                    ],\n                    \"last-modified\": cve[\"Modified\"],\n                }\n            },\n            upsert=True,\n        )\n\n\ndef cpeotherBulkInsert(cpeotherlist):\n    colCPEOTHER.insert(cpeotherlist)\n\n\ndef dropCollection(col):\n    return db[col].drop()\n    # jdt_NOTE: is exactly the same as drop(collection)\n    # jdt_NOTE: use only one of them\n\n\ndef getTableNames():\n    # return db.collection_names()\n    # jdt_NOTE: collection_names() is depreated, list_collection_names() should be used instead\n    return db.list_collection_names()\n\n\n# returns True if 'target_version' is less or equal than\n# 'cpe_version'\n# returns False otherwise\ndef target_version_is_included(target_version, cpe_version):\n    sp_target = target_version.split(\".\")\n    sp_cpe = cpe_version.split(\".\")\n    if len(sp_target) > len(sp_cpe):\n        sp_cpe += [0] * (len(sp_target) - len(sp_cpe))\n    if len(sp_cpe) > len(sp_target):\n        sp_cpe += [0] * (len(sp_cpe) - len(sp_target))\n    for i in range(len(sp_target)):\n        # target version smaller than cpe version\n        if int(sp_target[i]) < int(sp_cpe[i]):\n            return True\n        # target version greater than cpe version\n        if int(sp_target[i]) > int(sp_cpe[i]):\n            return False\n    # target version same version as cpe version\n    return True\n\n\n# API Functions\ndef cvesForCPE(cpe, lax=False, vulnProdSearch=False, limit=0, strict_vendor_product=False):\n    if not cpe:\n        return []\n\n    cpe_regex = cpe\n    final_cves = []\n    cpe_searchField = (\n        \"vulnerable_product\" if vulnProdSearch else \"vulnerable_configuration\"\n    )\n\n    if lax:\n        # get target version from product description provided by the user\n        target_version = cpe.split(\":\")[-1]\n        product = cpe.rsplit(\":\", 1)[0]\n        # perform checks on the target version\n        if None is target_version or [] is target_version:\n            print(\n                \"Error, target version not found at the end of product description '{}'\".format(\n                    cpe\n                )\n            )\n            sys.exit(-1)\n        for i in target_version.split(\".\"):\n            try:\n                int(i)\n            except:\n                print(\n                    \"Error, target version should be of the form '1.2.3'. Current form is '{}'\".format(\n                        target_version\n                    )\n                )\n                sys.exit(-1)\n\n        # over-approximate versions\n        cpe_regex = product\n\n        if limit != 0:\n            if mongo_version > [4, 4]:\n                cves = (\n                    colCVE.find({cpe_searchField: {\"$regex\": cpe_regex}})\n                    .limit(limit)\n                    .sort(\n                        [(\"Modified\", pymongo.DESCENDING), (\"cvss\", pymongo.DESCENDING)]\n                    )\n                    .allow_disk_use(True)\n                )\n            else:\n                cves = (\n                    colCVE.find({cpe_searchField: {\"$regex\": cpe_regex}})\n                    .limit(limit)\n                    .sort(\n                        [(\"Modified\", pymongo.DESCENDING), (\"cvss\", pymongo.DESCENDING)]\n                    )\n                )\n        else:\n            if mongo_version > [4, 4]:\n                cves = (\n                    colCVE.find({cpe_searchField: {\"$regex\": cpe_regex}})\n                    .sort(\"Modified\", direction=pymongo.DESCENDING)\n                    .allow_disk_use(True)\n                )\n            else:\n                cves = colCVE.find({cpe_searchField: {\"$regex\": cpe_regex}}).sort(\n                    \"Modified\", direction=pymongo.DESCENDING\n                )\n\n        i = 0\n\n        for cve in cves:\n            vuln_confs = cve[\"vulnerable_configuration\"]\n            vuln_confs += cve[\"vulnerable_configuration_cpe_2_2\"]\n            vuln_confs += cve[\"vulnerable_product\"]\n            i += 1\n            for vc in vuln_confs:\n                if cpe_regex not in vc:\n                    continue\n\n                re_from_start = re.compile(\"^.*{}:\".format(re.escape(cpe_regex)))\n                cpe_version = re_from_start.sub(\"\", vc)\n\n                # TODO: handle versions such as \"1.1.3:p2\"\n                cpe_version = cpe_version.split(\":\")[0]\n\n                # TODO: handle versions such as \"1.1.3p2\"\n                cpe_version = re.search(r\"([0-9\\.]*)\", cpe_version).group(0)\n                if len(cpe_version) == 0:\n                    # TODO: print warnings\n                    # print (\"Warning, missing cpe version for {}: '{}'. Skipping cpe.\".format(cve[\"id\"], vc))\n                    continue\n                if target_version_is_included(target_version, cpe_version):\n                    final_cves.append(cve)\n                    break\n    elif strict_vendor_product:\n        # strict product search\n\n        vendor, product = cpe\n\n        cpe_regex_string = r\"^{}\".format(re.escape(product))\n\n        if limit != 0:\n            if mongo_version > [4, 4]:\n                cves = (\n                    colCVE.find({\"vendors\": vendor, \"products\": {\"$regex\": cpe_regex_string}})\n                    .limit(limit)\n                    .sort(\"cvss\", direction=pymongo.DESCENDING)\n                    .allow_disk_use(True)\n                )\n            else:\n                cves = (\n                    colCVE.find({\"vendors\": vendor, \"products\": {\"$regex\": cpe_regex_string}})\n                    .limit(limit)\n                    .sort(\"cvss\", direction=pymongo.DESCENDING)\n                )\n        else:\n            cves = colCVE.find({\"vendors\": vendor, \"products\": {\"$regex\": cpe_regex_string}})\n\n        final_cves = cves\n\n    else:\n        # create strict cpe regex\n\n        if cpe_regex.startswith(\"cpe\"):\n            # strict search with term starting with cpe; e.g: cpe:2.3:o:microsoft:windows_7:*:sp1:*:*:*:*:*:*\n\n            remove_trailing_regex_stars = r\"(?:\\:|\\:\\:|\\:\\*)+$\"\n\n            cpe_regex = re.escape(re.sub(remove_trailing_regex_stars, \"\", cpe_regex))\n\n            cpe_regex_string = r\"^{}:\".format(cpe_regex)\n        else:\n            # more general search on same field; e.g. microsoft:windows_7\n            cpe_regex_string = \"{}\".format(re.escape(cpe_regex))\n\n        # default strict search\n        if limit != 0:\n            if mongo_version > [4, 4]:\n                cves = (\n                    colCVE.find({\"{}\".format(cpe_searchField): {\"$regex\": cpe_regex_string}})\n                    .limit(limit)\n                    .sort(\"cvss\", direction=pymongo.DESCENDING)\n                    .allow_disk_use(True)\n                )\n            else:\n                cves = (\n                    colCVE.find({\"{}\".format(cpe_searchField): {\"$regex\": cpe_regex_string}})\n                    .limit(limit)\n                    .sort(\"cvss\", direction=pymongo.DESCENDING)\n                )\n        else:\n            cves = colCVE.find({\"{}\".format(cpe_searchField): {\"$regex\": cpe_regex_string}})\n\n        final_cves = cves\n\n    final_cves = sanitize(final_cves)\n    return {\"results\": final_cves, \"total\": len(final_cves)}\n\n\n# Query Functions\n# Generic data\ndef getCVEs(limit=False, query=[], skip=0, cves=None, collection=None):\n    col = colCVE if not collection else db[collection]\n    if type(query) == dict:\n        query = [query]\n    if type(cves) == list:\n        query.append({\"id\": {\"$in\": cves}})\n    if len(query) == 0:\n        if mongo_version > [4, 4]:\n            cve = (\n                col.find()\n                .sort(\"Modified\", pymongo.DESCENDING)\n                .limit(limit)\n                .skip(skip)\n                .allow_disk_use(True)\n            )\n        else:\n            cve = (\n                col.find().sort(\"Modified\", pymongo.DESCENDING).limit(limit).skip(skip)\n            )\n    elif len(query) == 1:\n        if mongo_version > [4, 4]:\n            cve = (\n                col.find(query[0])\n                .sort(\"Modified\", pymongo.DESCENDING)\n                .limit(limit)\n                .skip(skip)\n                .allow_disk_use(True)\n            )\n        else:\n            cve = (\n                col.find(query[0])\n                .sort(\"Modified\", pymongo.DESCENDING)\n                .limit(limit)\n                .skip(skip)\n            )\n    else:\n        if mongo_version > [4, 4]:\n            cve = (\n                col.find({\"$and\": query})\n                .sort(\"Modified\", pymongo.DESCENDING)\n                .limit(limit)\n                .skip(skip)\n                .allow_disk_use(True)\n            )\n        else:\n            cve = (\n                col.find({\"$and\": query})\n                .sort(\"Modified\", pymongo.DESCENDING)\n                .limit(limit)\n                .skip(skip)\n            )\n\n    return {\"results\": sanitize(cve), \"total\": cve.count()}\n\n\ndef getCVEsNewerThan(dt):\n    return getCVEs(query={\"last-modified\": {\"$gt\": dt}})\n\n\ndef getCVEIDs(limit=-1):\n    if mongo_version > [4, 4]:\n        return [\n            x[\"id\"]\n            for x in colCVE.find()\n            .limit(limit)\n            .sort(\"Modified\", pymongo.DESCENDING)\n            .allow_disk_use(True)\n        ]\n    else:\n        return [\n            x[\"id\"]\n            for x in colCVE.find().limit(limit).sort(\"Modified\", pymongo.DESCENDING)\n        ]\n\n\ndef getCVE(id, collection=None):\n    col = colCVE if not collection else db[collection]\n    return sanitize(col.find_one({\"id\": id}))\n\n\ndef getCPE(id):\n    return sanitize(colCPE.find_one({\"id\": id}))\n\n\ndef getCPEVersionInformation(query):\n    return sanitize(colCPE.find_one(query))\n\n\ndef getCPEs():\n    return sanitize(colCPE.find())\n\n\ndef getAlternativeCPE(id):\n    return sanitize(colCPEOTHER.find_one({\"id\": id}))\n\n\ndef getAlternativeCPEs():\n    return sanitize(colCPEOTHER.find())\n\n\ndef getVIA4(id):\n    return sanitize(colVIA4.find_one({\"id\": id}))\n\n\ndef getCPEMatching(regex, fullSearch=False):\n    lst = list(colCPE.find({\"title\": {\"$regex\": regex}}))\n    if fullSearch:\n        lst.extend(colCPEOTHER.find({\"title\": {\"$regex\": regex}}))\n    return lst\n\n\ndef getFreeText(text):\n    try:  # Before Mongo 3\n        return [x[\"obj\"] for x in db.command(\"text\", \"cves\", search=text)[\"results\"]]\n    except:  # As of Mongo 3\n        return sanitize(colCVE.find({\"$text\": {\"$search\": text}}))\n\n\ndef getSearchResults(search):\n    result = {\"data\": []}\n    regSearch = re.compile(re.escape(search), re.IGNORECASE)\n    links = {\"n\": \"Link\", \"d\": []}\n    via4 = getInfo(\"via4\")\n    if via4:\n        for vLink in via4.get(\"searchables\", []):\n            links[\"d\"].extend(sanitize(colVIA4.find({vLink: {\"$in\": [regSearch]}})))\n\n    try:\n        textsearch = {\"n\": \"Text search\", \"d\": getFreeText(search)}\n    except:\n        textsearch = {\"n\": \"Text search\", \"d\": []}\n        result[\"errors\"] = [\"textsearch\"]\n\n    for collection in [links, textsearch]:\n        for item in collection[\"d\"]:\n            # Check if already in result data\n            if not any(item[\"id\"] == entry[\"id\"] for entry in result[\"data\"]):\n                entry = getCVE(item[\"id\"])\n                if entry:\n                    entry[\"reason\"] = collection[\"n\"]\n                    result[\"data\"].append(entry)\n    return result\n\n\ndef getCAPECFor(capecid):\n    return sanitize(colCAPEC.find({\"related_weakness\": {\"$in\": [capecid]}}))\n\n\ndef getCAPEC(capecid):\n    return sanitize(colCAPEC.find_one({\"id\": capecid}))\n\n\ndef getCWEs(cweid=None):\n    if cweid is None:\n        return sanitize(sorted(colCWE.find(), key=lambda k: int(k[\"id\"])))\n    else:\n        return sanitize(colCWE.find_one({\"id\": cweid}))\n\n\ndef getInfo(collection):\n    return sanitize(colINFO.find_one({\"db\": collection}))\n\n\ndef getLastModified(collection):\n    info = getInfo(collection)\n    return info[\"last-modified\"] if info else None\n\n\ndef getSize(collection):\n    return db[collection].count()\n\n\ndef via4Linked(key, val):\n    cveList = [x[\"id\"] for x in colVIA4.find({key: val})]\n    return sanitize(getCVEs(query={\"id\": {\"$in\": cveList}}))\n\n\ndef getDBStats(include_admin=False):\n    data = {\"cves\": {}, \"cpe\": {}, \"cpeOther\": {}, \"capec\": {}, \"cwe\": {}, \"via4\": {}}\n    for key in data.keys():\n        data[key] = {\n            \"size\": getSize(key.lower()),\n            \"last_update\": getLastModified(key.lower()),\n        }\n    if include_admin:\n        data[\"whitelist\"] = {\"size\": colWHITELIST.count()}\n        data[\"blacklist\"] = {\"size\": colBLACKLIST.count()}\n        data = {\n            \"stats\": {\n                \"size_on_disk\": db.command(\"dbstats\")[\"storageSize\"],\n                \"db_size\": db.command(\"dbstats\")[\"dataSize\"],\n                \"name\": conf.getMongoDB(),\n            },\n            \"data\": data,\n        }\n    return data\n\n\n# Dynamic data\ndef getWhitelist():\n    return sanitize(colWHITELIST.find())\n\n\ndef isInWhitelist(cpe):\n    return True if colWHITELIST.find({\"id\": cpe}).count() > 0 else False\n\n\ndef addToWhitelist(cpe, type, comments=None):\n    if comments:\n        colWHITELIST.insert({\"id\": cpe, \"type\": type, \"comments\": comments})\n    else:\n        colWHITELIST.insert({\"id\": cpe, \"type\": type})\n\n\ndef removeFromWhitelist(cpe):\n    colWHITELIST.remove({\"id\": cpe})\n\n\ndef updateWhitelist(oldCPE, newCPE, type, comments=None):\n    if comments:\n        colWHITELIST.update(\n            {\"id\": oldCPE}, {\"id\": newCPE, \"type\": type, \"comments\": comments}\n        )\n    else:\n        colWHITELIST.update({\"id\": oldCPE}, {\"id\": newCPE, \"type\": type})\n\n\ndef getBlacklist():\n    return sanitize(colBLACKLIST.find())\n\n\ndef isInBlacklist(cpe):\n    return True if colBLACKLIST.find({\"id\": cpe}).count() > 0 else False\n\n\ndef addToBlacklist(cpe, type, comments=None):\n    if comments:\n        colBLACKLIST.insert({\"id\": cpe, \"type\": type, \"comments\": comments})\n    else:\n        colBLACKLIST.insert({\"id\": cpe, \"type\": type})\n\n\ndef removeFromBlacklist(cpe):\n    colBLACKLIST.remove({\"id\": cpe})\n\n\ndef updateBlacklist(oldCPE, newCPE, type, comments=None):\n    if comments:\n        colBLACKLIST.update(\n            {\"id\": oldCPE}, {\"id\": newCPE, \"type\": type, \"comments\": comments}\n        )\n    else:\n        colBLACKLIST.update({\"id\": oldCPE}, {\"id\": newCPE, \"type\": type})\n\n\ndef getRules(list):\n    if list.lower() == \"whitelist\":\n        col = colWHITELIST\n    elif list.lower() == \"blacklist\":\n        col = colBLACKLIST\n    else:\n        return []\n    rlist = col.find({\"type\": \"cpe\"}).distinct(\"id\")\n    rlist.extend(\n        [\n            \"cpe:2.3:([^:]*:){9}\" + re.escape(x)\n            for x in col.find({\"type\": \"targethardware\"}).distinct(\"id\")\n        ]\n    )\n    rlist.extend(\n        [\n            \"cpe:2.3:([^:]*:){8}\" + re.escape(x)\n            for x in col.find({\"type\": \"targetsoftware\"}).distinct(\"id\")\n        ]\n    )\n    return rlist\n\n\ndef addRanking(cpe, key, rank):\n    item = findRanking(cpe)\n    if item is None:\n        colRANKING.update({\"cpe\": cpe}, {\"$push\": {\"rank\": {key: rank}}}, upsert=True)\n    else:\n        l = []\n        for i in item[\"rank\"]:\n            i[key] = rank\n            l.append(i)\n        colRANKING.update({\"cpe\": cpe}, {\"$set\": {\"rank\": l}})\n    return True\n\n\ndef removeRanking(cpe):\n    return sanitize(colRANKING.remove({\"cpe\": {\"$regex\": cpe, \"$options\": \"i\"}}))\n\n\ndef findRanking(cpe=None, regex=False):\n    if not cpe:\n        # return sanitize(colRANKING.find())\n        return None\n    if regex:\n        # return sanitize(colRANKING.find_one({'cpe': {'$regex': cpe}}))\n        return None\n    else:\n        return None\n        # return sanitize(colRANKING.find_one({'cpe': cpe}))\n\n\n###########\n# Plugins #\n###########\n# Settings\ndef p_writeSetting(plugin, setting, value):\n    colPlugSettings.update({\"plugin\": plugin}, {\"$set\": {setting: value}}, upsert=True)\n\n\ndef p_readSetting(plugin, setting):\n    data = list(\n        colPlugSettings.find({\"plugin\": plugin}, {setting: 1}).distinct(setting)\n    )\n    if len(data) != 0:\n        data = data[0]\n        return data\n    return None\n\n\ndef p_deleteSettings(plugin):\n    colPlugSettings.remove({\"plugin\": plugin})\n\n\ndef p_writeUserSetting(plugin, user, setting, value):\n    colPlugUserSettings.update(\n        {\"plugin\": plugin, \"user\": user}, {\"$set\": {setting: value}}, upsert=True\n    )\n\n\ndef p_readUserSetting(plugin, user, setting):\n    data = list(\n        colPlugUserSettings.find(\n            {\"plugin\": plugin, \"user\": user}, {setting: 1}\n        ).distinct(setting)\n    )\n    if len(data) != 0:\n        data = data[0]\n        return data\n    return None\n\n\ndef p_deleteUserSettings(plugin):\n    colPlugUserSettings.remove({\"plugin\": plugin})\n\n\n# Query\ndef p_queryData(collection, query):\n    return sanitize(db[\"plug_%s\" % collection].find(query))\n\n\ndef p_queryOne(collection, query):\n    data = sanitize(db[\"plug_%s\" % collection].find_one(query))\n    return data if data else []  # Compatibility between several Flask-PyMongo versions\n\n\n# Data manipulation\ndef p_drop(col):\n    db[\"plug_%s\" % col].drop()\n\n\ndef p_addEntry(collection, data):\n    db[\"plug_%s\" % collection].insert(data)\n\n\ndef p_removeEntry(collection, query):\n    db[\"plug_%s\" % collection].remove(query)\n\n\ndef p_bulkUpdate(collection, keyword, data):\n    if type(data) is not list:\n        data = [data]\n    if len(data) > 0:\n        bulk = db[\"plug_%s\" % collection].initialize_ordered_bulk_op()\n        for x in data:\n            bulk.find({keyword: x[keyword]}).upsert().update({\"$set\": x})\n        bulk.execute()\n\n\ndef p_addToList(collection, query, listname, data):\n    if type(data) != list:\n        data = [data]\n    current = list(p_queryData(collection, query))\n    if len(current) == 0:\n        p_addEntry(collection, query)\n    for entry in current:\n        if listname in entry:\n            data = list(\n                set([repr(x) for x in data]) - set([repr(x) for x in entry[listname]])\n            )\n            data = [ast.literal_eval(x) for x in data]\n        if data:\n            db[\"plug_%s\" % collection].update(\n                query, {\"$addToSet\": {listname: {\"$each\": data}}}\n            )\n\n\ndef p_removeFromList(collection, query, listname, data):\n    if type(data) == dict:\n        db[\"plug_%s\" % collection].update(query, {\"$pull\": {listname: data}})\n    elif type(data) != list:\n        data = [data]\n    db[\"plug_%s\" % collection].update(query, {\"$pullAll\": {listname: data}})\n"], "filenames": ["lib/DatabaseLayer.py"], "buggy_code_start_loc": [241], "buggy_code_end_loc": [242], "fixing_code_start_loc": [241], "fixing_code_end_loc": [242], "type": "NVD-CWE-Other", "message": "lib/DatabaseLayer.py in cve-search before 4.1.0 allows regular expression injection, which can lead to ReDoS (regular expression denial of service) or other impacts.", "other": {"cve": {"id": "CVE-2021-45470", "sourceIdentifier": "cve@mitre.org", "published": "2021-12-23T21:15:09.030", "lastModified": "2021-12-29T19:08:18.843", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "lib/DatabaseLayer.py in cve-search before 4.1.0 allows regular expression injection, which can lead to ReDoS (regular expression denial of service) or other impacts."}, {"lang": "es", "value": "El archivo lib/DatabaseLayer.py en cve-search versiones anteriores a 4.1.0, permite una inyecci\u00f3n de expresiones regulares, que puede conllevar a ReDoS (denegaci\u00f3n de servicio por expresiones regulares) u otros impactos"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-Other"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:circl:cve-search:*:*:*:*:*:*:*:*", "versionEndExcluding": "4.1.0", "matchCriteriaId": "55C3CC15-4647-48D6-AE22-020F080BDEE4"}]}]}], "references": [{"url": "https://github.com/cve-search/cve-search/commit/c621f9f0693a728b93ff3b964f948a1d25917207", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/cve-search/cve-search/compare/v4.0...v4.1.0", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/cve-search/cve-search/pull/629", "source": "cve@mitre.org", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/cve-search/cve-search/commit/c621f9f0693a728b93ff3b964f948a1d25917207"}}