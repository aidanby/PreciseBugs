{"buggy_code": ["/*! simple-get. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\nmodule.exports = simpleGet\n\nconst concat = require('simple-concat')\nconst decompressResponse = require('decompress-response') // excluded from browser build\nconst http = require('http')\nconst https = require('https')\nconst once = require('once')\nconst querystring = require('querystring')\nconst url = require('url')\n\nconst isStream = o => o !== null && typeof o === 'object' && typeof o.pipe === 'function'\n\nfunction simpleGet (opts, cb) {\n  opts = Object.assign({ maxRedirects: 10 }, typeof opts === 'string' ? { url: opts } : opts)\n  cb = once(cb)\n\n  if (opts.url) {\n    const { hostname, port, protocol, auth, path } = url.parse(opts.url) // eslint-disable-line node/no-deprecated-api\n    delete opts.url\n    if (!hostname && !port && !protocol && !auth) opts.path = path // Relative redirect\n    else Object.assign(opts, { hostname, port, protocol, auth, path }) // Absolute redirect\n  }\n\n  const headers = { 'accept-encoding': 'gzip, deflate' }\n  if (opts.headers) Object.keys(opts.headers).forEach(k => (headers[k.toLowerCase()] = opts.headers[k]))\n  opts.headers = headers\n\n  let body\n  if (opts.body) {\n    body = opts.json && !isStream(opts.body) ? JSON.stringify(opts.body) : opts.body\n  } else if (opts.form) {\n    body = typeof opts.form === 'string' ? opts.form : querystring.stringify(opts.form)\n    opts.headers['content-type'] = 'application/x-www-form-urlencoded'\n  }\n\n  if (body) {\n    if (!opts.method) opts.method = 'POST'\n    if (!isStream(body)) opts.headers['content-length'] = Buffer.byteLength(body)\n    if (opts.json && !opts.form) opts.headers['content-type'] = 'application/json'\n  }\n  delete opts.body; delete opts.form\n\n  if (opts.json) opts.headers.accept = 'application/json'\n  if (opts.method) opts.method = opts.method.toUpperCase()\n\n  const protocol = opts.protocol === 'https:' ? https : http // Support http/https urls\n  const req = protocol.request(opts, res => {\n    if (opts.followRedirects !== false && res.statusCode >= 300 && res.statusCode < 400 && res.headers.location) {\n      opts.url = res.headers.location // Follow 3xx redirects\n      delete opts.headers.host // Discard `host` header on redirect (see #32)\n      res.resume() // Discard response\n\n      if (opts.method === 'POST' && [301, 302].includes(res.statusCode)) {\n        opts.method = 'GET' // On 301/302 redirect, change POST to GET (see #35)\n        delete opts.headers['content-length']; delete opts.headers['content-type']\n      }\n\n      if (opts.maxRedirects-- === 0) return cb(new Error('too many redirects'))\n      else return simpleGet(opts, cb)\n    }\n\n    const tryUnzip = typeof decompressResponse === 'function' && opts.method !== 'HEAD'\n    cb(null, tryUnzip ? decompressResponse(res) : res)\n  })\n  req.on('timeout', () => {\n    req.abort()\n    cb(new Error('Request timed out'))\n  })\n  req.on('error', cb)\n\n  if (isStream(body)) body.on('error', cb).pipe(req)\n  else req.end(body)\n\n  return req\n}\n\nsimpleGet.concat = (opts, cb) => {\n  return simpleGet(opts, (err, res) => {\n    if (err) return cb(err)\n    concat(res, (err, data) => {\n      if (err) return cb(err)\n      if (opts.json) {\n        try {\n          data = JSON.parse(data.toString())\n        } catch (err) {\n          return cb(err, res, data)\n        }\n      }\n      cb(null, res, data)\n    })\n  })\n}\n\n;['get', 'post', 'put', 'patch', 'head', 'delete'].forEach(method => {\n  simpleGet[method] = (opts, cb) => {\n    if (typeof opts === 'string') opts = { url: opts }\n    return simpleGet(Object.assign({ method: method.toUpperCase() }, opts), cb)\n  }\n})\n"], "fixing_code": ["/*! simple-get. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\nmodule.exports = simpleGet\n\nconst concat = require('simple-concat')\nconst decompressResponse = require('decompress-response') // excluded from browser build\nconst http = require('http')\nconst https = require('https')\nconst once = require('once')\nconst querystring = require('querystring')\nconst url = require('url')\n\nconst isStream = o => o !== null && typeof o === 'object' && typeof o.pipe === 'function'\n\nfunction simpleGet (opts, cb) {\n  opts = Object.assign({ maxRedirects: 10 }, typeof opts === 'string' ? { url: opts } : opts)\n  cb = once(cb)\n\n  if (opts.url) {\n    const { hostname, port, protocol, auth, path } = url.parse(opts.url) // eslint-disable-line node/no-deprecated-api\n    delete opts.url\n    if (!hostname && !port && !protocol && !auth) opts.path = path // Relative redirect\n    else Object.assign(opts, { hostname, port, protocol, auth, path }) // Absolute redirect\n  }\n\n  const headers = { 'accept-encoding': 'gzip, deflate' }\n  if (opts.headers) Object.keys(opts.headers).forEach(k => (headers[k.toLowerCase()] = opts.headers[k]))\n  opts.headers = headers\n\n  let body\n  if (opts.body) {\n    body = opts.json && !isStream(opts.body) ? JSON.stringify(opts.body) : opts.body\n  } else if (opts.form) {\n    body = typeof opts.form === 'string' ? opts.form : querystring.stringify(opts.form)\n    opts.headers['content-type'] = 'application/x-www-form-urlencoded'\n  }\n\n  if (body) {\n    if (!opts.method) opts.method = 'POST'\n    if (!isStream(body)) opts.headers['content-length'] = Buffer.byteLength(body)\n    if (opts.json && !opts.form) opts.headers['content-type'] = 'application/json'\n  }\n  delete opts.body; delete opts.form\n\n  if (opts.json) opts.headers.accept = 'application/json'\n  if (opts.method) opts.method = opts.method.toUpperCase()\n\n  const originalHost = opts.hostname // hostname before potential redirect\n  const protocol = opts.protocol === 'https:' ? https : http // Support http/https urls\n  const req = protocol.request(opts, res => {\n    if (opts.followRedirects !== false && res.statusCode >= 300 && res.statusCode < 400 && res.headers.location) {\n      opts.url = res.headers.location // Follow 3xx redirects\n      delete opts.headers.host // Discard `host` header on redirect (see #32)\n      res.resume() // Discard response\n\n      const redirectHost = url.parse(opts.url).hostname // eslint-disable-line node/no-deprecated-api\n      // If redirected host is different than original host, drop headers to prevent cookie leak (#73)\n      if (redirectHost !== null && redirectHost !== originalHost) {\n        delete opts.headers.cookie\n        delete opts.headers.authorization\n      }\n\n      if (opts.method === 'POST' && [301, 302].includes(res.statusCode)) {\n        opts.method = 'GET' // On 301/302 redirect, change POST to GET (see #35)\n        delete opts.headers['content-length']; delete opts.headers['content-type']\n      }\n\n      if (opts.maxRedirects-- === 0) return cb(new Error('too many redirects'))\n      else return simpleGet(opts, cb)\n    }\n\n    const tryUnzip = typeof decompressResponse === 'function' && opts.method !== 'HEAD'\n    cb(null, tryUnzip ? decompressResponse(res) : res)\n  })\n  req.on('timeout', () => {\n    req.abort()\n    cb(new Error('Request timed out'))\n  })\n  req.on('error', cb)\n\n  if (isStream(body)) body.on('error', cb).pipe(req)\n  else req.end(body)\n\n  return req\n}\n\nsimpleGet.concat = (opts, cb) => {\n  return simpleGet(opts, (err, res) => {\n    if (err) return cb(err)\n    concat(res, (err, data) => {\n      if (err) return cb(err)\n      if (opts.json) {\n        try {\n          data = JSON.parse(data.toString())\n        } catch (err) {\n          return cb(err, res, data)\n        }\n      }\n      cb(null, res, data)\n    })\n  })\n}\n\n;['get', 'post', 'put', 'patch', 'head', 'delete'].forEach(method => {\n  simpleGet[method] = (opts, cb) => {\n    if (typeof opts === 'string') opts = { url: opts }\n    return simpleGet(Object.assign({ method: method.toUpperCase() }, opts), cb)\n  }\n})\n"], "filenames": ["index.js"], "buggy_code_start_loc": [46], "buggy_code_end_loc": [52], "fixing_code_start_loc": [47], "fixing_code_end_loc": [61], "type": "CWE-200", "message": "Exposure of Sensitive Information to an Unauthorized Actor in NPM simple-get prior to 4.0.1.", "other": {"cve": {"id": "CVE-2022-0355", "sourceIdentifier": "security@huntr.dev", "published": "2022-01-26T04:15:06.813", "lastModified": "2023-02-13T22:15:12.647", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Exposure of Sensitive Information to an Unauthorized Actor in NPM simple-get prior to 4.0.1."}, {"lang": "es", "value": "Una Exposici\u00f3n de Informaci\u00f3n Confidencial a un Actor no Autorizado en NPM simple-get versiones anteriores a 4.0.1"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-200"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-200"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:simple-get_project:simple-get:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "4.0.1", "matchCriteriaId": "5E3D03A3-54A6-4D48-812F-39149D783DD3"}]}]}], "references": [{"url": "https://github.com/advisories/GHSA-wpg7-2c88-r8xv", "source": "security@huntr.dev"}, {"url": "https://github.com/feross/simple-get/commit/e4af095e06cd69a9235013e8507e220a79b9684f", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/42c79c23-6646-46c4-871d-219c0d4b4e31", "source": "security@huntr.dev", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/feross/simple-get/commit/e4af095e06cd69a9235013e8507e220a79b9684f"}}