{"buggy_code": ["'use strict';\n\nconst path = require('path');\nconst {promisify} = require('util');\nconst graphviz = require('graphviz');\n\nconst exec = promisify(require('child_process').exec);\nconst writeFile = promisify(require('fs').writeFile);\n\n/**\n * Set color on a node.\n * @param  {Object} node\n * @param  {String} color\n */\nfunction setNodeColor(node, color) {\n\tnode.set('color', color);\n\tnode.set('fontcolor', color);\n}\n\n/**\n * Check if Graphviz is installed on the system.\n * @param  {Object} config\n * @return {Promise}\n */\nfunction checkGraphvizInstalled(config) {\n\tif (config.graphVizPath) {\n\t\tconst cmd = path.join(config.graphVizPath, 'gvpr -V');\n\t\treturn exec(cmd)\n\t\t\t.catch(() => {\n\t\t\t\tthrow new Error('Could not execute ' + cmd);\n\t\t\t});\n\t}\n\n\treturn exec('gvpr -V')\n\t\t.catch((error) => {\n\t\t\tthrow new Error('Graphviz could not be found. Ensure that \"gvpr\" is in your $PATH.\\n' + error);\n\t\t});\n}\n\n/**\n * Return options to use with graphviz digraph.\n * @param  {Object} config\n * @return {Object}\n */\nfunction createGraphvizOptions(config) {\n\tconst graphVizOptions = config.graphVizOptions || {};\n\n\treturn {\n\t\t// Graph\n\t\tG: Object.assign({\n\t\t\toverlap: false,\n\t\t\tpad: 0.3,\n\t\t\trankdir: config.rankdir,\n\t\t\tlayout: config.layout,\n\t\t\tbgcolor: config.backgroundColor\n\t\t}, graphVizOptions.G),\n\t\t// Edge\n\t\tE: Object.assign({\n\t\t\tcolor: config.edgeColor\n\t\t}, graphVizOptions.E),\n\t\t// Node\n\t\tN: Object.assign({\n\t\t\tfontname: config.fontName,\n\t\t\tfontsize: config.fontSize,\n\t\t\tcolor: config.nodeColor,\n\t\t\tshape: config.nodeShape,\n\t\t\tstyle: config.nodeStyle,\n\t\t\theight: 0,\n\t\t\tfontcolor: config.nodeColor\n\t\t}, graphVizOptions.N)\n\t};\n}\n\n/**\n * Creates the graphviz graph.\n * @param  {Object} modules\n * @param  {Array} circular\n * @param  {Object} config\n * @param  {Object} options\n * @return {Promise}\n */\nfunction createGraph(modules, circular, config, options) {\n\tconst g = graphviz.digraph('G');\n\tconst nodes = {};\n\tconst cyclicModules = circular.reduce((a, b) => a.concat(b), []);\n\n\tif (config.graphVizPath) {\n\t\tg.setGraphVizPath(config.graphVizPath);\n\t}\n\n\tObject.keys(modules).forEach((id) => {\n\t\tnodes[id] = nodes[id] || g.addNode(id);\n\n\t\tif (!modules[id].length) {\n\t\t\tsetNodeColor(nodes[id], config.noDependencyColor);\n\t\t} else if (cyclicModules.indexOf(id) >= 0) {\n\t\t\tsetNodeColor(nodes[id], config.cyclicNodeColor);\n\t\t}\n\n\t\tmodules[id].forEach((depId) => {\n\t\t\tnodes[depId] = nodes[depId] || g.addNode(depId);\n\n\t\t\tif (!modules[depId]) {\n\t\t\t\tsetNodeColor(nodes[depId], config.noDependencyColor);\n\t\t\t}\n\n\t\t\tg.addEdge(nodes[id], nodes[depId]);\n\t\t});\n\t});\n\n\treturn new Promise((resolve, reject) => {\n\t\tg.output(options, resolve, (code, out, err) => {\n\t\t\treject(new Error(err));\n\t\t});\n\t});\n}\n\n/**\n * Return the module dependency graph XML SVG representation as a Buffer.\n * @param  {Object} modules\n * @param  {Array} circular\n * @param  {Object} config\n * @return {Promise}\n */\nmodule.exports.svg = function (modules, circular, config) {\n\tconst options = createGraphvizOptions(config);\n\n\toptions.type = 'svg';\n\n\treturn checkGraphvizInstalled(config)\n\t\t.then(() => createGraph(modules, circular, config, options));\n};\n\n/**\n * Creates an image from the module dependency graph.\n * @param  {Object} modules\n * @param  {Array} circular\n * @param  {String} imagePath\n * @param  {Object} config\n * @return {Promise}\n */\nmodule.exports.image = function (modules, circular, imagePath, config) {\n\tconst options = createGraphvizOptions(config);\n\n\toptions.type = path.extname(imagePath).replace('.', '') || 'png';\n\n\treturn checkGraphvizInstalled(config)\n\t\t.then(() => {\n\t\t\treturn createGraph(modules, circular, config, options)\n\t\t\t\t.then((image) => writeFile(imagePath, image))\n\t\t\t\t.then(() => path.resolve(imagePath));\n\t\t});\n};\n\n/**\n * Return the module dependency graph as DOT output.\n * @param  {Object} modules\n * @param  {Array} circular\n * @param  {Object} config\n * @return {Promise}\n */\nmodule.exports.dot = function (modules, circular, config) {\n\tconst options = createGraphvizOptions(config);\n\n\toptions.type = 'dot';\n\n\treturn checkGraphvizInstalled(config)\n\t\t.then(() => createGraph(modules, circular, config, options))\n\t\t.then((output) => output.toString('utf8'));\n};\n", "/* eslint-env mocha */\n'use strict';\n\nconst os = require('os');\nconst path = require('path');\nconst fs = require('mz/fs');\nconst madge = require('../lib/api');\n\nrequire('should');\n\ndescribe('API', () => {\n\tit('throws error on missing path argument', () => {\n\t\t(() => {\n\t\t\tmadge();\n\t\t}).should.throw('path argument not provided');\n\t});\n\n\tit('returns a Promise', () => {\n\t\tmadge(__dirname + '/cjs/a.js').should.be.Promise(); // eslint-disable-line new-cap\n\t});\n\n\tit('throws error if file or directory does not exists', (done) => {\n\t\tmadge(__dirname + '/missing.js').catch((err) => {\n\t\t\terr.message.should.match(/no such file or directory/);\n\t\t\tdone();\n\t\t}).catch(done);\n\t});\n\n\tit('takes single file as path', (done) => {\n\t\tmadge(__dirname + '/cjs/a.js').then((res) => {\n\t\t\tres.obj().should.eql({\n\t\t\t\t'a.js': ['b.js', 'c.js'],\n\t\t\t\t'b.js': ['c.js'],\n\t\t\t\t'c.js': []\n\t\t\t});\n\t\t\tdone();\n\t\t}).catch(done);\n\t});\n\n\tit('takes an array of files as path and combines the result', (done) => {\n\t\tmadge([__dirname + '/cjs/a.js', __dirname + '/cjs/normal/d.js']).then((res) => {\n\t\t\tres.obj().should.eql({\n\t\t\t\t'a.js': ['b.js', 'c.js'],\n\t\t\t\t'b.js': ['c.js'],\n\t\t\t\t'c.js': [],\n\t\t\t\t'normal/d.js': []\n\t\t\t});\n\t\t\tdone();\n\t\t}).catch(done);\n\t});\n\n\tit('take a single directory as path and find files in it', (done) => {\n\t\tmadge(__dirname + '/cjs/normal').then((res) => {\n\t\t\tres.obj().should.eql({\n\t\t\t\t'a.js': ['sub/b.js'],\n\t\t\t\t'd.js': [],\n\t\t\t\t'sub/b.js': ['sub/c.js'],\n\t\t\t\t'sub/c.js': ['d.js']\n\t\t\t});\n\t\t\tdone();\n\t\t}).catch(done);\n\t});\n\n\tit('takes an array of directories as path and compute the basedir correctly', (done) => {\n\t\tmadge([__dirname + '/cjs/multibase/1', __dirname + '/cjs/multibase/2']).then((res) => {\n\t\t\tres.obj().should.eql({\n\t\t\t\t'1/a.js': [],\n\t\t\t\t'2/b.js': []\n\t\t\t});\n\t\t\tdone();\n\t\t}).catch(done);\n\t});\n\n\tit('takes a predefined tree', (done) => {\n\t\tmadge({\n\t\t\ta: ['b', 'c', 'd'],\n\t\t\tb: ['c'],\n\t\t\tc: [],\n\t\t\td: ['a']\n\t\t}).then((res) => {\n\t\t\tres.obj().should.eql({\n\t\t\t\ta: ['b', 'c', 'd'],\n\t\t\t\tb: ['c'],\n\t\t\t\tc: [],\n\t\t\t\td: ['a']\n\t\t\t});\n\t\t\tdone();\n\t\t}).catch(done);\n\t});\n\n\tit('can exclude modules using RegExp', (done) => {\n\t\tmadge(__dirname + '/cjs/a.js', {\n\t\t\texcludeRegExp: ['^b.js$']\n\t\t}).then((res) => {\n\t\t\tres.obj().should.eql({\n\t\t\t\t'a.js': ['c.js'],\n\t\t\t\t'c.js': []\n\t\t\t});\n\t\t\tdone();\n\t\t}).catch(done);\n\t});\n\n\tit('extracts dependencies but excludes .git', (done) => {\n\t\t// eslint-disable-next-line no-sync\n\t\tfs.renameSync(`${__dirname}/git/.git_tmp`, `${__dirname}/git/.git`);\n\n\t\tmadge(__dirname + '/git/a.js', {}).then((res) => {\n\t\t\tres.obj().should.eql({\n\t\t\t\t'a.js': ['b.js', 'c.js'],\n\t\t\t\t'b.js': ['c.js'],\n\t\t\t\t'c.js': []\n\t\t\t});\n\t\t\tdone();\n\t\t}).catch(() => {\n\t\t\tdone();\n\t\t}).finally(() => {\n\t\t\t// eslint-disable-next-line no-sync\n\t\t\tfs.renameSync(`${__dirname}/git/.git`, `${__dirname}/git/.git_tmp`);\n\t\t});\n\t});\n\n\tdescribe('dependencyFilter', () => {\n\t\tit('will stop traversing when returning false', (done) => {\n\t\t\tmadge(__dirname + '/cjs/a.js', {\n\t\t\t\tdependencyFilter: () => {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}).then((res) => {\n\t\t\t\tres.obj().should.eql({\n\t\t\t\t\t'a.js': []\n\t\t\t\t});\n\t\t\t\tdone();\n\t\t\t}).catch(done);\n\t\t});\n\n\t\tit('will not stop traversing when not returning anything', (done) => {\n\t\t\tmadge(__dirname + '/cjs/a.js', {\n\t\t\t\tdependencyFilter: () => {}\n\t\t\t}).then((res) => {\n\t\t\t\tres.obj().should.eql({\n\t\t\t\t\t'a.js': ['b.js', 'c.js'],\n\t\t\t\t\t'b.js': ['c.js'],\n\t\t\t\t\t'c.js': []\n\t\t\t\t});\n\t\t\t\tdone();\n\t\t\t}).catch(done);\n\t\t});\n\n\t\tit('will pass arguments to the function', (done) => {\n\t\t\tlet counter = 0;\n\n\t\t\tmadge(__dirname + '/cjs/a.js', {\n\t\t\t\tdependencyFilter: (dependencyFilePath, traversedFilePath, baseDir) => {\n\t\t\t\t\tif (counter === 0) {\n\t\t\t\t\t\tdependencyFilePath.should.match(/test\\/cjs\\/b\\.js$/);\n\t\t\t\t\t\ttraversedFilePath.should.match(/test\\/cjs\\/a\\.js$/);\n\t\t\t\t\t\tbaseDir.should.match(/test\\/cjs$/);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (counter === 1) {\n\t\t\t\t\t\tdependencyFilePath.should.match(/test\\/cjs\\/c\\.js$/);\n\t\t\t\t\t\ttraversedFilePath.should.match(/test\\/cjs\\/a\\.js$/);\n\t\t\t\t\t\tbaseDir.should.match(/test\\/cjs$/);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (counter === 2) {\n\t\t\t\t\t\tdependencyFilePath.should.match(/test\\/cjs\\/c\\.js$/);\n\t\t\t\t\t\ttraversedFilePath.should.match(/test\\/cjs\\/b\\.js$/);\n\t\t\t\t\t\tbaseDir.should.match(/test\\/cjs$/);\n\t\t\t\t\t}\n\n\t\t\t\t\tcounter++;\n\t\t\t\t}\n\t\t\t}).then(() => {\n\t\t\t\tdone();\n\t\t\t}).catch(done);\n\t\t});\n\t});\n\n\tdescribe('obj()', () => {\n\t\tit('returns dependency object', (done) => {\n\t\t\tmadge(__dirname + '/cjs/a.js').then((res) => {\n\t\t\t\tres.obj().should.eql({\n\t\t\t\t\t'a.js': ['b.js', 'c.js'],\n\t\t\t\t\t'b.js': ['c.js'],\n\t\t\t\t\t'c.js': []\n\t\t\t\t});\n\t\t\t\tdone();\n\t\t\t}).catch(done);\n\t\t});\n\t});\n\n\tdescribe('circular()', () => {\n\t\tit('returns list of circular dependencies', (done) => {\n\t\t\tmadge(__dirname + '/cjs/circular/a.js').then((res) => {\n\t\t\t\tres.circular().should.eql([\n\t\t\t\t\t['a.js', 'd.js']\n\t\t\t\t]);\n\t\t\t\tdone();\n\t\t\t}).catch(done);\n\t\t});\n\t});\n\n\tdescribe('circularGraph()', () => {\n\t\tit('returns graph with only circular dependencies', (done) => {\n\t\t\tmadge(__dirname + '/cjs/circular/a.js').then((res) => {\n\t\t\t\tres.circularGraph().should.eql({\n\t\t\t\t\t'a.js': ['d.js'],\n\t\t\t\t\t'd.js': ['a.js']\n\t\t\t\t});\n\t\t\t\tdone();\n\t\t\t}).catch(done);\n\t\t});\n\t});\n\n\tdescribe('warnings()', () => {\n\t\tit('returns an array of skipped files', (done) => {\n\t\t\tmadge(__dirname + '/cjs/missing.js').then((res) => {\n\t\t\t\tres.obj().should.eql({\n\t\t\t\t\t'missing.js': ['c.js'],\n\t\t\t\t\t'c.js': []\n\t\t\t\t});\n\t\t\t\tres.warnings().should.eql({\n\t\t\t\t\tskipped: ['./path/non/existing/file']\n\t\t\t\t});\n\t\t\t\tdone();\n\t\t\t}).catch(done);\n\t\t});\n\t});\n\n\tdescribe('dot()', () => {\n\t\tit('returns a promise resolved with graphviz DOT output', async () => {\n\t\t\tconst res = await madge(__dirname + '/cjs/b.js');\n\t\t\tconst output = await res.dot();\n\t\t\toutput.should.match(/digraph G/);\n\t\t\toutput.should.match(/bgcolor=\"#111111\"/);\n\t\t\toutput.should.match(/fontcolor=\"#c6c5fe\"/);\n\t\t\toutput.should.match(/color=\"#757575\"/);\n\t\t\toutput.should.match(/fontcolor=\"#cfffac\"/);\n\t\t});\n\t});\n\n\tdescribe('depends()', () => {\n\t\tit('returns modules that depends on another', (done) => {\n\t\t\tmadge(__dirname + '/cjs/a.js').then((res) => {\n\t\t\t\tres.depends('c.js').should.eql(['a.js', 'b.js']);\n\t\t\t\tdone();\n\t\t\t}).catch(done);\n\t\t});\n\t});\n\n\tdescribe('orphans()', () => {\n\t\tit('returns modules that no one is depending on', (done) => {\n\t\t\tmadge(__dirname + '/cjs/normal').then((res) => {\n\t\t\t\tres.orphans().should.eql(['a.js']);\n\t\t\t\tdone();\n\t\t\t}).catch(done);\n\t\t});\n\t});\n\n\tdescribe('leaves()', () => {\n\t\tit('returns modules that have no dependencies', (done) => {\n\t\t\tmadge(__dirname + '/cjs/normal').then((res) => {\n\t\t\t\tres.leaves().should.eql(['d.js']);\n\t\t\t\tdone();\n\t\t\t}).catch(done);\n\t\t});\n\t});\n\n\tdescribe('svg()', () => {\n\t\tit('returns a promise resolved with XML SVG output in a Buffer', (done) => {\n\t\t\tmadge(__dirname + '/cjs/b.js')\n\t\t\t\t.then((res) => res.svg())\n\t\t\t\t.then((output) => {\n\t\t\t\t\toutput.should.instanceof(Buffer);\n\t\t\t\t\toutput.toString().should.match(/<svg.*/);\n\t\t\t\t\tdone();\n\t\t\t\t})\n\t\t\t\t.catch(done);\n\t\t});\n\t});\n\n\tdescribe('image()', () => {\n\t\tlet imagePath;\n\n\t\tbeforeEach(() => {\n\t\t\timagePath = path.join(os.tmpdir(), 'madge_' + Date.now() + '_image.png');\n\t\t});\n\n\t\tafterEach(() => {\n\t\t\treturn fs.unlink(imagePath).catch(() => {});\n\t\t});\n\n\t\tit('rejects if a filename is not supplied', (done) => {\n\t\t\tmadge(__dirname + '/cjs/a.js')\n\t\t\t\t.then((res) => res.image())\n\t\t\t\t.catch((err) => {\n\t\t\t\t\terr.message.should.eql('imagePath not provided');\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t});\n\n\t\tit('rejects on unsupported image format', (done) => {\n\t\t\tmadge(__dirname + '/cjs/a.js')\n\t\t\t\t.then((res) => res.image('image.zyx'))\n\t\t\t\t.catch((err) => {\n\t\t\t\t\terr.message.should.match(/Format: \"zyx\" not recognized/);\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t});\n\n\t\tit('rejects if graphviz is not installed', (done) => {\n\t\t\tmadge(__dirname + '/cjs/a.js', {graphVizPath: '/invalid/path'})\n\t\t\t\t.then((res) => res.image('image.png'))\n\t\t\t\t.catch((err) => {\n\t\t\t\t\terr.message.should.match(/Could not execute .*gvpr \\-V/);\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t});\n\n\t\tit('writes image to file', (done) => {\n\t\t\tmadge(__dirname + '/cjs/a.js')\n\t\t\t\t.then((res) => res.image(imagePath))\n\t\t\t\t.then((writtenImagePath) => {\n\t\t\t\t\twrittenImagePath.should.eql(imagePath);\n\n\t\t\t\t\treturn fs\n\t\t\t\t\t\t.exists(imagePath)\n\t\t\t\t\t\t.then((exists) => {\n\t\t\t\t\t\t\tif (!exists) {\n\t\t\t\t\t\t\t\tthrow new Error(imagePath + ' not created');\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdone();\n\t\t\t\t\t\t});\n\t\t\t\t})\n\t\t\t\t.catch(done);\n\t\t});\n\t});\n});\n"], "fixing_code": ["'use strict';\n\nconst path = require('path');\nconst {promisify} = require('util');\nconst graphviz = require('graphviz');\n\nconst exec = promisify(require('child_process').execFile);\nconst writeFile = promisify(require('fs').writeFile);\n\n/**\n * Set color on a node.\n * @param  {Object} node\n * @param  {String} color\n */\nfunction setNodeColor(node, color) {\n\tnode.set('color', color);\n\tnode.set('fontcolor', color);\n}\n\n/**\n * Check if Graphviz is installed on the system.\n * @param  {Object} config\n * @return {Promise}\n */\nasync function checkGraphvizInstalled(config) {\n\tconst cmd = config.graphVizPath ? path.join(config.graphVizPath, 'gvpr') : 'gvpr';\n\n\ttry {\n\t\tawait exec(cmd, ['-V']);\n\t} catch (err) {\n\t\tthrow new Error(`Graphviz could not be found. Ensure that \"gvpr\" is in your $PATH. ${err}`);\n\t}\n}\n\n/**\n * Return options to use with graphviz digraph.\n * @param  {Object} config\n * @return {Object}\n */\nfunction createGraphvizOptions(config) {\n\tconst graphVizOptions = config.graphVizOptions || {};\n\n\treturn {\n\t\t// Graph\n\t\tG: Object.assign({\n\t\t\toverlap: false,\n\t\t\tpad: 0.3,\n\t\t\trankdir: config.rankdir,\n\t\t\tlayout: config.layout,\n\t\t\tbgcolor: config.backgroundColor\n\t\t}, graphVizOptions.G),\n\t\t// Edge\n\t\tE: Object.assign({\n\t\t\tcolor: config.edgeColor\n\t\t}, graphVizOptions.E),\n\t\t// Node\n\t\tN: Object.assign({\n\t\t\tfontname: config.fontName,\n\t\t\tfontsize: config.fontSize,\n\t\t\tcolor: config.nodeColor,\n\t\t\tshape: config.nodeShape,\n\t\t\tstyle: config.nodeStyle,\n\t\t\theight: 0,\n\t\t\tfontcolor: config.nodeColor\n\t\t}, graphVizOptions.N)\n\t};\n}\n\n/**\n * Creates the graphviz graph.\n * @param  {Object} modules\n * @param  {Array} circular\n * @param  {Object} config\n * @param  {Object} options\n * @return {Promise}\n */\nfunction createGraph(modules, circular, config, options) {\n\tconst g = graphviz.digraph('G');\n\tconst nodes = {};\n\tconst cyclicModules = circular.reduce((a, b) => a.concat(b), []);\n\n\tif (config.graphVizPath) {\n\t\tg.setGraphVizPath(config.graphVizPath);\n\t}\n\n\tObject.keys(modules).forEach((id) => {\n\t\tnodes[id] = nodes[id] || g.addNode(id);\n\n\t\tif (!modules[id].length) {\n\t\t\tsetNodeColor(nodes[id], config.noDependencyColor);\n\t\t} else if (cyclicModules.indexOf(id) >= 0) {\n\t\t\tsetNodeColor(nodes[id], config.cyclicNodeColor);\n\t\t}\n\n\t\tmodules[id].forEach((depId) => {\n\t\t\tnodes[depId] = nodes[depId] || g.addNode(depId);\n\n\t\t\tif (!modules[depId]) {\n\t\t\t\tsetNodeColor(nodes[depId], config.noDependencyColor);\n\t\t\t}\n\n\t\t\tg.addEdge(nodes[id], nodes[depId]);\n\t\t});\n\t});\n\n\treturn new Promise((resolve, reject) => {\n\t\tg.output(options, resolve, (code, out, err) => {\n\t\t\treject(new Error(err));\n\t\t});\n\t});\n}\n\n/**\n * Return the module dependency graph XML SVG representation as a Buffer.\n * @param  {Object} modules\n * @param  {Array} circular\n * @param  {Object} config\n * @return {Promise}\n */\nmodule.exports.svg = function (modules, circular, config) {\n\tconst options = createGraphvizOptions(config);\n\n\toptions.type = 'svg';\n\n\treturn checkGraphvizInstalled(config)\n\t\t.then(() => createGraph(modules, circular, config, options));\n};\n\n/**\n * Creates an image from the module dependency graph.\n * @param  {Object} modules\n * @param  {Array} circular\n * @param  {String} imagePath\n * @param  {Object} config\n * @return {Promise}\n */\nmodule.exports.image = function (modules, circular, imagePath, config) {\n\tconst options = createGraphvizOptions(config);\n\n\toptions.type = path.extname(imagePath).replace('.', '') || 'png';\n\n\treturn checkGraphvizInstalled(config)\n\t\t.then(() => {\n\t\t\treturn createGraph(modules, circular, config, options)\n\t\t\t\t.then((image) => writeFile(imagePath, image))\n\t\t\t\t.then(() => path.resolve(imagePath));\n\t\t});\n};\n\n/**\n * Return the module dependency graph as DOT output.\n * @param  {Object} modules\n * @param  {Array} circular\n * @param  {Object} config\n * @return {Promise}\n */\nmodule.exports.dot = function (modules, circular, config) {\n\tconst options = createGraphvizOptions(config);\n\n\toptions.type = 'dot';\n\n\treturn checkGraphvizInstalled(config)\n\t\t.then(() => createGraph(modules, circular, config, options))\n\t\t.then((output) => output.toString('utf8'));\n};\n", "/* eslint-env mocha */\n'use strict';\n\nconst os = require('os');\nconst path = require('path');\nconst fs = require('mz/fs');\nconst madge = require('../lib/api');\n\nrequire('should');\n\ndescribe('API', () => {\n\tit('throws error on missing path argument', () => {\n\t\t(() => {\n\t\t\tmadge();\n\t\t}).should.throw('path argument not provided');\n\t});\n\n\tit('returns a Promise', () => {\n\t\tmadge(__dirname + '/cjs/a.js').should.be.Promise(); // eslint-disable-line new-cap\n\t});\n\n\tit('throws error if file or directory does not exists', (done) => {\n\t\tmadge(__dirname + '/missing.js').catch((err) => {\n\t\t\terr.message.should.match(/no such file or directory/);\n\t\t\tdone();\n\t\t}).catch(done);\n\t});\n\n\tit('takes single file as path', (done) => {\n\t\tmadge(__dirname + '/cjs/a.js').then((res) => {\n\t\t\tres.obj().should.eql({\n\t\t\t\t'a.js': ['b.js', 'c.js'],\n\t\t\t\t'b.js': ['c.js'],\n\t\t\t\t'c.js': []\n\t\t\t});\n\t\t\tdone();\n\t\t}).catch(done);\n\t});\n\n\tit('takes an array of files as path and combines the result', (done) => {\n\t\tmadge([__dirname + '/cjs/a.js', __dirname + '/cjs/normal/d.js']).then((res) => {\n\t\t\tres.obj().should.eql({\n\t\t\t\t'a.js': ['b.js', 'c.js'],\n\t\t\t\t'b.js': ['c.js'],\n\t\t\t\t'c.js': [],\n\t\t\t\t'normal/d.js': []\n\t\t\t});\n\t\t\tdone();\n\t\t}).catch(done);\n\t});\n\n\tit('take a single directory as path and find files in it', (done) => {\n\t\tmadge(__dirname + '/cjs/normal').then((res) => {\n\t\t\tres.obj().should.eql({\n\t\t\t\t'a.js': ['sub/b.js'],\n\t\t\t\t'd.js': [],\n\t\t\t\t'sub/b.js': ['sub/c.js'],\n\t\t\t\t'sub/c.js': ['d.js']\n\t\t\t});\n\t\t\tdone();\n\t\t}).catch(done);\n\t});\n\n\tit('takes an array of directories as path and compute the basedir correctly', (done) => {\n\t\tmadge([__dirname + '/cjs/multibase/1', __dirname + '/cjs/multibase/2']).then((res) => {\n\t\t\tres.obj().should.eql({\n\t\t\t\t'1/a.js': [],\n\t\t\t\t'2/b.js': []\n\t\t\t});\n\t\t\tdone();\n\t\t}).catch(done);\n\t});\n\n\tit('takes a predefined tree', (done) => {\n\t\tmadge({\n\t\t\ta: ['b', 'c', 'd'],\n\t\t\tb: ['c'],\n\t\t\tc: [],\n\t\t\td: ['a']\n\t\t}).then((res) => {\n\t\t\tres.obj().should.eql({\n\t\t\t\ta: ['b', 'c', 'd'],\n\t\t\t\tb: ['c'],\n\t\t\t\tc: [],\n\t\t\t\td: ['a']\n\t\t\t});\n\t\t\tdone();\n\t\t}).catch(done);\n\t});\n\n\tit('can exclude modules using RegExp', (done) => {\n\t\tmadge(__dirname + '/cjs/a.js', {\n\t\t\texcludeRegExp: ['^b.js$']\n\t\t}).then((res) => {\n\t\t\tres.obj().should.eql({\n\t\t\t\t'a.js': ['c.js'],\n\t\t\t\t'c.js': []\n\t\t\t});\n\t\t\tdone();\n\t\t}).catch(done);\n\t});\n\n\tit('extracts dependencies but excludes .git', (done) => {\n\t\t// eslint-disable-next-line no-sync\n\t\tfs.renameSync(`${__dirname}/git/.git_tmp`, `${__dirname}/git/.git`);\n\n\t\tmadge(__dirname + '/git/a.js', {}).then((res) => {\n\t\t\tres.obj().should.eql({\n\t\t\t\t'a.js': ['b.js', 'c.js'],\n\t\t\t\t'b.js': ['c.js'],\n\t\t\t\t'c.js': []\n\t\t\t});\n\t\t\tdone();\n\t\t}).catch(() => {\n\t\t\tdone();\n\t\t}).finally(() => {\n\t\t\t// eslint-disable-next-line no-sync\n\t\t\tfs.renameSync(`${__dirname}/git/.git`, `${__dirname}/git/.git_tmp`);\n\t\t});\n\t});\n\n\tdescribe('dependencyFilter', () => {\n\t\tit('will stop traversing when returning false', (done) => {\n\t\t\tmadge(__dirname + '/cjs/a.js', {\n\t\t\t\tdependencyFilter: () => {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}).then((res) => {\n\t\t\t\tres.obj().should.eql({\n\t\t\t\t\t'a.js': []\n\t\t\t\t});\n\t\t\t\tdone();\n\t\t\t}).catch(done);\n\t\t});\n\n\t\tit('will not stop traversing when not returning anything', (done) => {\n\t\t\tmadge(__dirname + '/cjs/a.js', {\n\t\t\t\tdependencyFilter: () => {}\n\t\t\t}).then((res) => {\n\t\t\t\tres.obj().should.eql({\n\t\t\t\t\t'a.js': ['b.js', 'c.js'],\n\t\t\t\t\t'b.js': ['c.js'],\n\t\t\t\t\t'c.js': []\n\t\t\t\t});\n\t\t\t\tdone();\n\t\t\t}).catch(done);\n\t\t});\n\n\t\tit('will pass arguments to the function', (done) => {\n\t\t\tlet counter = 0;\n\n\t\t\tmadge(__dirname + '/cjs/a.js', {\n\t\t\t\tdependencyFilter: (dependencyFilePath, traversedFilePath, baseDir) => {\n\t\t\t\t\tif (counter === 0) {\n\t\t\t\t\t\tdependencyFilePath.should.match(/test\\/cjs\\/b\\.js$/);\n\t\t\t\t\t\ttraversedFilePath.should.match(/test\\/cjs\\/a\\.js$/);\n\t\t\t\t\t\tbaseDir.should.match(/test\\/cjs$/);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (counter === 1) {\n\t\t\t\t\t\tdependencyFilePath.should.match(/test\\/cjs\\/c\\.js$/);\n\t\t\t\t\t\ttraversedFilePath.should.match(/test\\/cjs\\/a\\.js$/);\n\t\t\t\t\t\tbaseDir.should.match(/test\\/cjs$/);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (counter === 2) {\n\t\t\t\t\t\tdependencyFilePath.should.match(/test\\/cjs\\/c\\.js$/);\n\t\t\t\t\t\ttraversedFilePath.should.match(/test\\/cjs\\/b\\.js$/);\n\t\t\t\t\t\tbaseDir.should.match(/test\\/cjs$/);\n\t\t\t\t\t}\n\n\t\t\t\t\tcounter++;\n\t\t\t\t}\n\t\t\t}).then(() => {\n\t\t\t\tdone();\n\t\t\t}).catch(done);\n\t\t});\n\t});\n\n\tdescribe('obj()', () => {\n\t\tit('returns dependency object', (done) => {\n\t\t\tmadge(__dirname + '/cjs/a.js').then((res) => {\n\t\t\t\tres.obj().should.eql({\n\t\t\t\t\t'a.js': ['b.js', 'c.js'],\n\t\t\t\t\t'b.js': ['c.js'],\n\t\t\t\t\t'c.js': []\n\t\t\t\t});\n\t\t\t\tdone();\n\t\t\t}).catch(done);\n\t\t});\n\t});\n\n\tdescribe('circular()', () => {\n\t\tit('returns list of circular dependencies', (done) => {\n\t\t\tmadge(__dirname + '/cjs/circular/a.js').then((res) => {\n\t\t\t\tres.circular().should.eql([\n\t\t\t\t\t['a.js', 'd.js']\n\t\t\t\t]);\n\t\t\t\tdone();\n\t\t\t}).catch(done);\n\t\t});\n\t});\n\n\tdescribe('circularGraph()', () => {\n\t\tit('returns graph with only circular dependencies', (done) => {\n\t\t\tmadge(__dirname + '/cjs/circular/a.js').then((res) => {\n\t\t\t\tres.circularGraph().should.eql({\n\t\t\t\t\t'a.js': ['d.js'],\n\t\t\t\t\t'd.js': ['a.js']\n\t\t\t\t});\n\t\t\t\tdone();\n\t\t\t}).catch(done);\n\t\t});\n\t});\n\n\tdescribe('warnings()', () => {\n\t\tit('returns an array of skipped files', (done) => {\n\t\t\tmadge(__dirname + '/cjs/missing.js').then((res) => {\n\t\t\t\tres.obj().should.eql({\n\t\t\t\t\t'missing.js': ['c.js'],\n\t\t\t\t\t'c.js': []\n\t\t\t\t});\n\t\t\t\tres.warnings().should.eql({\n\t\t\t\t\tskipped: ['./path/non/existing/file']\n\t\t\t\t});\n\t\t\t\tdone();\n\t\t\t}).catch(done);\n\t\t});\n\t});\n\n\tdescribe('dot()', () => {\n\t\tit('returns a promise resolved with graphviz DOT output', async () => {\n\t\t\tconst res = await madge(__dirname + '/cjs/b.js');\n\t\t\tconst output = await res.dot();\n\t\t\toutput.should.match(/digraph G/);\n\t\t\toutput.should.match(/bgcolor=\"#111111\"/);\n\t\t\toutput.should.match(/fontcolor=\"#c6c5fe\"/);\n\t\t\toutput.should.match(/color=\"#757575\"/);\n\t\t\toutput.should.match(/fontcolor=\"#cfffac\"/);\n\t\t});\n\t});\n\n\tdescribe('depends()', () => {\n\t\tit('returns modules that depends on another', (done) => {\n\t\t\tmadge(__dirname + '/cjs/a.js').then((res) => {\n\t\t\t\tres.depends('c.js').should.eql(['a.js', 'b.js']);\n\t\t\t\tdone();\n\t\t\t}).catch(done);\n\t\t});\n\t});\n\n\tdescribe('orphans()', () => {\n\t\tit('returns modules that no one is depending on', (done) => {\n\t\t\tmadge(__dirname + '/cjs/normal').then((res) => {\n\t\t\t\tres.orphans().should.eql(['a.js']);\n\t\t\t\tdone();\n\t\t\t}).catch(done);\n\t\t});\n\t});\n\n\tdescribe('leaves()', () => {\n\t\tit('returns modules that have no dependencies', (done) => {\n\t\t\tmadge(__dirname + '/cjs/normal').then((res) => {\n\t\t\t\tres.leaves().should.eql(['d.js']);\n\t\t\t\tdone();\n\t\t\t}).catch(done);\n\t\t});\n\t});\n\n\tdescribe('svg()', () => {\n\t\tit('returns a promise resolved with XML SVG output in a Buffer', (done) => {\n\t\t\tmadge(__dirname + '/cjs/b.js')\n\t\t\t\t.then((res) => res.svg())\n\t\t\t\t.then((output) => {\n\t\t\t\t\toutput.should.instanceof(Buffer);\n\t\t\t\t\toutput.toString().should.match(/<svg.*/);\n\t\t\t\t\tdone();\n\t\t\t\t})\n\t\t\t\t.catch(done);\n\t\t});\n\t});\n\n\tdescribe('image()', () => {\n\t\tlet imagePath;\n\n\t\tbeforeEach(() => {\n\t\t\timagePath = path.join(os.tmpdir(), 'madge_' + Date.now() + '_image.png');\n\t\t});\n\n\t\tafterEach(() => {\n\t\t\treturn fs.unlink(imagePath).catch(() => {});\n\t\t});\n\n\t\tit('rejects if a filename is not supplied', (done) => {\n\t\t\tmadge(__dirname + '/cjs/a.js')\n\t\t\t\t.then((res) => res.image())\n\t\t\t\t.catch((err) => {\n\t\t\t\t\terr.message.should.eql('imagePath not provided');\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t});\n\n\t\tit('rejects on unsupported image format', (done) => {\n\t\t\tmadge(__dirname + '/cjs/a.js')\n\t\t\t\t.then((res) => res.image('image.zyx'))\n\t\t\t\t.catch((err) => {\n\t\t\t\t\terr.message.should.match(/Format: \"zyx\" not recognized/);\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t});\n\n\t\tit('rejects if graphviz is not installed', (done) => {\n\t\t\tmadge(__dirname + '/cjs/a.js', {graphVizPath: '/invalid/path'})\n\t\t\t\t.then((res) => res.image('image.png'))\n\t\t\t\t.catch((err) => {\n\t\t\t\t\terr.message.should.eql('Graphviz could not be found. Ensure that \"gvpr\" is in your $PATH. Error: spawn /invalid/path/gvpr ENOENT');\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t});\n\n\t\tit('writes image to file', (done) => {\n\t\t\tmadge(__dirname + '/cjs/a.js')\n\t\t\t\t.then((res) => res.image(imagePath))\n\t\t\t\t.then((writtenImagePath) => {\n\t\t\t\t\twrittenImagePath.should.eql(imagePath);\n\n\t\t\t\t\treturn fs\n\t\t\t\t\t\t.exists(imagePath)\n\t\t\t\t\t\t.then((exists) => {\n\t\t\t\t\t\t\tif (!exists) {\n\t\t\t\t\t\t\t\tthrow new Error(imagePath + ' not created');\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdone();\n\t\t\t\t\t\t});\n\t\t\t\t})\n\t\t\t\t.catch(done);\n\t\t});\n\t});\n});\n"], "filenames": ["lib/graph.js", "test/api.js"], "buggy_code_start_loc": [7, 316], "buggy_code_end_loc": [38, 317], "fixing_code_start_loc": [7, 316], "fixing_code_end_loc": [32, 317], "type": "CWE-89", "message": "This affects the package madge before 4.0.1. It is possible to specify a custom Graphviz path via the graphVizPath option parameter which when the .image(), .svg() or .dot() functions are called, is executed by the childprocess.exec function.", "other": {"cve": {"id": "CVE-2021-23352", "sourceIdentifier": "report@snyk.io", "published": "2021-03-09T19:15:12.860", "lastModified": "2021-03-13T00:22:00.727", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "This affects the package madge before 4.0.1. It is possible to specify a custom Graphviz path via the graphVizPath option parameter which when the .image(), .svg() or .dot() functions are called, is executed by the childprocess.exec function."}, {"lang": "es", "value": "Esto afecta al paquete madge versiones anteriores a 4.0.1.&#xa0;Es posible especificar una ruta Graphviz personalizada por medio del par\u00e1metro graphVizPath option que cuando son llamadas las funciones .image(), .svg() o .dot(), es ejecutado por la funci\u00f3n childprocess.exec"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "report@snyk.io", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 8.6, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 4.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-89"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:madge_project:madge:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "4.0.1", "matchCriteriaId": "940F078B-EA3A-4113-A8A6-C38552F64D9D"}]}]}], "references": [{"url": "https://github.com/pahen/madge/blob/master/lib/graph.js%23L27", "source": "report@snyk.io", "tags": ["Broken Link", "Third Party Advisory"]}, {"url": "https://github.com/pahen/madge/commit/da5cbc9ab30372d687fa7c324b22af7ffa5c6332", "source": "report@snyk.io", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://snyk.io/vuln/SNYK-JS-MADGE-1082875", "source": "report@snyk.io", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/pahen/madge/commit/da5cbc9ab30372d687fa7c324b22af7ffa5c6332"}}